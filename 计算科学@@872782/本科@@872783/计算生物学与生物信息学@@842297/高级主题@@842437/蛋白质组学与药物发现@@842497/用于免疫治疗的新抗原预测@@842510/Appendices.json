{"hands_on_practices": [{"introduction": "识别出潜在的新抗原仅仅是第一步；我们还需要对它们进行排序，以筛选出最有希望的候选者用于后续的实验验证。本练习将引导你应用一个简洁而强大的评分模型，该模型结合了决定免疫原性的三个关键因素：MHC结合亲和力、基因表达水平和与自身肽的“外源性”程度。通过这个实践，你将学习如何量化并整合不同的生物学证据，从而得出一个可用于排序的综合评分 [@problem_id:2409290]。", "problem": "一位研究人员正在通过结合免疫原性潜力的三个可测量决定因素，来确定癌症免疫疗法中候选新抗原肽的优先级：与主要组织相容性复合体（MHC）的结合亲和力，以50%抑制浓度（$IC_{50}$，单位nM）表示；源基因表达，以每百万转录本数（$TPM$）表示；以及一个量化与任何自身肽非相似性的无量纲异源性得分 $F \\in [0,1]$。为了获得一个无量纲的优先级评分，该评分随结合力更强、表达水平更高、异源性更大而增加，首先将每个决定因素映射到一个单调的无量纲因子，然后将它们相乘组合来定义评分 $S$：\n- 亲和力强度：$a = \\max\\{0, \\ln(IC_{50}^{\\mathrm{ref}}/IC_{50})\\}$，其中 $IC_{50}^{\\mathrm{ref}} = 500\\,\\mathrm{nM}$。\n- 表达强度：$e = \\ln(1 + TPM)$。\n- 异源性：$F$ 如给定。\n- 总评分：$S = a \\cdot e \\cdot F$。\n此处 $\\ln$ 表示自然对数。\n\n对于一个候选肽，其 $IC_{50} = 50\\,\\mathrm{nM}$，$TPM = 12$，且 $F = 0.70$，计算 $S$ 的值。将你的最终答案以单个实数的形式报告，并四舍五入到4位有效数字。评分 $S$ 是无量纲的；答案中不要包含单位。", "solution": "我们遵循问题中定义的评分方法，分步计算总评分 $S$。\n1.  **计算亲和力强度因子 $a$**：\n    给定的参数为 $IC_{50} = 50\\,\\mathrm{nM}$ 和参考值 $IC_{50}^{\\mathrm{ref}} = 500\\,\\mathrm{nM}$。\n    $$a = \\max\\{0, \\ln(IC_{50}^{\\mathrm{ref}}/IC_{50})\\} = \\ln(500 / 50) = \\ln(10) \\approx 2.302585$$\n2.  **计算表达强度因子 $e$**：\n    给定的转录本表达水平为 $TPM = 12$。\n    $$e = \\ln(1 + TPM) = \\ln(1 + 12) = \\ln(13) \\approx 2.564949$$\n3.  **异源性因子 $F$**：\n    给定的异源性得分为 $F = 0.70$。\n4.  **计算总评分 $S$**：\n    将三个因子相乘。\n    $$S = a \\cdot e \\cdot F \\approx 2.302585 \\times 2.564949 \\times 0.70 \\approx 4.13375$$\n5.  **四舍五入到4位有效数字**：\n    将结果四舍五入，得到 $4.134$。", "answer": "$$\\boxed{4.134}$$", "id": "2409290"}, {"introduction": "在掌握了如何为单个候选肽评分后，我们将在一个更真实的场景中进行实践：从测序数据中筛选候选新抗原。一个至关重要的步骤是区分真正的肿瘤特异性（体细胞）突变和存在于患者正常细胞中的胚系变异。本练习将指导你构建一个基于规则的分类器，它模仿了真实的生物信息学分析流程，综合了来自肿瘤和正常组织样本的测序数据、基因表达数据和MHC结合预测结果 [@problem_id:2409285]。", "problem": "您将处理一个正式的决策问题，该问题基于新抗原的生物学定义。新抗原是一种源自体细胞突变的肽，它存在于肿瘤中但不存在于患者的种系中，并且能被至少一个具有足够强结合力的人类白细胞抗原 (HLA) 分子呈递，同时其来源转录本在肿瘤中表达。对于每个候选肽，您将获得肿瘤和正常样本中变异等位基因和参考等位基因的读数计数、与一个或多个 HLA 等位基因的预测结合亲和力（单位为纳摩尔）以及以每百万转录本的转录本数 (TPM) 为单位的转录本表达水平。您的任务是实现一个分类器，以判断每个候选肽是否符合真实新抗原的正式定义，并将其应用于一个固定的测试套件。\n\n定义和符号。对于每个候选肽，给定非负整数 $T_{\\mathrm{ref}}$、$T_{\\mathrm{alt}}$、$N_{\\mathrm{ref}}$ 和 $N_{\\mathrm{alt}}$，分别代表肿瘤和正常样本中参考和变异等位基因的读数计数。定义肿瘤覆盖度 $T_{\\mathrm{cov}} = T_{\\mathrm{ref}} + T_{\\mathrm{alt}}$ 和正常样本覆盖度 $N_{\\mathrm{cov}} = N_{\\mathrm{ref}} + N_{\\mathrm{alt}}$。定义肿瘤变异等位基因频率（Variant Allele Fraction (VAF)）为\n$$\n\\mathrm{VAF}_T = \n\\begin{cases}\n\\dfrac{T_{\\mathrm{alt}}}{T_{\\mathrm{ref}} + T_{\\mathrm{alt}}},  \\text{if } T_{\\mathrm{ref}} + T_{\\mathrm{alt}}  0,\\\\\n0,  \\text{if } T_{\\mathrm{ref}} + T_{\\mathrm{alt}} = 0,\n\\end{cases}\n$$\n以及正常样本变异等位基因频率为\n$$\n\\mathrm{VAF}_N = \n\\begin{cases}\n\\dfrac{N_{\\mathrm{alt}}}{N_{\\mathrm{ref}} + N_{\\mathrm{alt}}},  \\text{if } N_{\\mathrm{ref}} + N_{\\mathrm{alt}}  0,\\\\\n0,  \\text{if } N_{\\mathrm{ref}} + N_{\\mathrm{alt}} = 0.\n\\end{cases}\n$$\n设预测的结合亲和力（单位为纳摩尔）列表为 $A = [a_1, a_2, \\dots, a_m]$，其中 $m \\geq 1$；肿瘤表达水平为一个非负实数 $E$，单位为每百万转录本的转录本数（Transcripts Per Million (TPM)）。\n\n分类器规范。当且仅当以下所有条件同时成立时，一个候选肽被分类为真实新抗原：\n1. 两个样本中都有足够的测序支持：$T_{\\mathrm{cov}} \\geq c_{\\min}$ 且 $N_{\\mathrm{cov}} \\geq c_{\\min}$。\n2. 体细胞突变特征，表现为变异等位基因在肿瘤中富集且在种系中缺失：$\\mathrm{VAF}_T \\geq \\tau_{\\mathrm{tumor}}$ 且 $\\mathrm{VAF}_N  \\tau_{\\mathrm{germ}}$。\n3. 至少有一个足够强的人类白细胞抗原结合预测：$\\min(A) \\leq \\theta_{\\mathrm{bind}}$（纳摩尔）。\n4. 足够的肿瘤表达水平：$E \\geq \\theta_{\\mathrm{expr}}$（每百万转录本的转录本数 (TPM)）。\n\n使用以下固定阈值：$c_{\\min} = 10$，$\\tau_{\\mathrm{tumor}} = 0.05$，$\\tau_{\\mathrm{germ}} = 0.20$，$\\theta_{\\mathrm{bind}} = 500$（纳摩尔），以及 $\\theta_{\\mathrm{expr}} = 1.0$（每百万转录本的转录本数 (TPM)）。除结合亲和力的单位纳摩尔和表达水平的单位每百万转录本的转录本数（TPM）外，没有其他物理单位；不涉及角度单位。所有比较都应在标准实数意义上进行解释。\n\n测试套件。请将您的分类器应用于以下七个候选肽。每个候选肽以元组 $(T_{\\mathrm{ref}}, T_{\\mathrm{alt}}, N_{\\mathrm{ref}}, N_{\\mathrm{alt}}, A, E)$ 的形式给出，其中 $A$ 是一个包含一个或多个实数的列表。\n\n- 候选肽 1：$(30, 20, 50, 0, [120.0, 720.0], 8.5)$。\n- 候选肽 2：$(25, 35, 30, 30, [50.0, 80.0], 12.0)$。\n- 候选肽 3：$(42, 18, 55, 0, [650.0, 800.0], 9.0)$。\n- 候选肽 4：$(15, 15, 40, 0, [100.0], 0.5)$。\n- 候选肽 5：$(28, 12, 5, 0, [30.0, 40.0], 10.0)$。\n- 候选肽 6：$(25, 25, 38, 2, [200.0, 400.0], 3.0)$。\n- 候选肽 7：$(50, 0, 60, 0, [5.0], 9.0)$。\n\n您的程序必须根据上述规范计算每个候选肽的分类，并生成一行输出。该输出包含一个用方括号括起来的、由逗号分隔的整数列表，其中 $1$ 表示“真实新抗原”，$0$ 表示“非真实新抗原”。例如，三个候选肽的输出可能看起来像 $[1,0,1]$。\n\n您的实现必须是自包含的，测试套件需嵌入程序中。不允许也不需要外部输入。", "solution": "提交分析的问题陈述被认为是有效的。它提出了一个生物信息学领域中形式化、自包含且有科学依据的计算任务。其目标是基于一套精确的规则和一个固定的测试套件，为新抗原候选肽实现一个确定性分类器。该问题定义良好，所有定义、参数和数据都已明确提供。没有矛盾、歧义或违反科学原则之处。我们现在开始进行解答。\n\n将候选肽分类为真实新抗原需要同时满足四个不同的标准。如果所有四个条件都满足，则候选肽被分类为 $1$（真实新抗原），否则为 $0$。这些条件所需的参数固定如下：\n- 最小覆盖度：$c_{\\min} = 10$ reads。\n- 最小肿瘤变异等位基因频率 (VAF)：$\\tau_{\\mathrm{tumor}} = 0.05$。\n- 最大种系 VAF：$\\tau_{\\mathrm{germ}} = 0.20$。\n- 最大结合亲和力：$\\theta_{\\mathrm{bind}} = 500$ 纳摩尔 (nM)。\n- 最小肿瘤表达水平：$\\theta_{\\mathrm{expr}} = 1.0$ 每百万转录本的转录本数 (TPM)。\n\n这四个条件是：\n1.  **测序覆盖度**：肿瘤覆盖度 $T_{\\mathrm{cov}} = T_{\\mathrm{ref}} + T_{\\mathrm{alt}}$ 和正常样本覆盖度 $N_{\\mathrm{cov}} = N_{\\mathrm{ref}} + N_{\\mathrm{alt}}$ 都必须至少为 $c_{\\min}$。\n2.  **体细胞来源**：肿瘤 VAF $\\mathrm{VAF}_T = T_{\\mathrm{alt}} / T_{\\mathrm{cov}}$ 必须至少为 $\\tau_{\\mathrm{tumor}}$，而正常样本 VAF $\\mathrm{VAF}_N = N_{\\mathrm{alt}} / N_{\\mathrm{cov}}$ 必须严格小于 $\\tau_{\\mathrm{germ}}$。如果覆盖度为 $0$，则 VAF 定义为 $0$。\n3.  **HLA 结合**：最小预测结合亲和力 $\\min(A)$ 必须小于或等于 $\\theta_{\\mathrm{bind}}$。\n4.  **基因表达**：来源转录本的表达水平 $E$ 必须至少为 $\\theta_{\\mathrm{expr}}$。\n\n我们现在将此分类逻辑系统地应用于所提供的七个候选肽中的每一个。\n\n**候选肽 1**：输入为 $(T_{\\mathrm{ref}}, T_{\\mathrm{alt}}, N_{\\mathrm{ref}}, N_{\\mathrm{alt}}, A, E) = (30, 20, 50, 0, [120.0, 720.0], 8.5)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 30 + 20 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 50 + 0 = 50 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{20}{50} = 0.4 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{50} = 0  0.20$。此条件满足。\n3.  结合：$\\min(A) = \\min([120.0, 720.0]) = 120.0 \\leq 500$。此条件满足。\n4.  表达：$E = 8.5 \\geq 1.0$。此条件满足。\n所有四个条件均满足。分类结果：$1$。\n\n**候选肽 2**：输入为 $(25, 35, 30, 30, [50.0, 80.0], 12.0)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 25 + 35 = 60 \\geq 10$。$N_{\\mathrm{cov}} = 30 + 30 = 60 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{35}{60} \\approx 0.583 \\geq 0.05$。然而，$\\mathrm{VAF}_N = \\frac{30}{60} = 0.5$，不小于 $0.20$。此条件不满足。\n该候选肽在体细胞来源标准上未通过，表明它可能是种系变异。\n分类结果：$0$。\n\n**候选肽 3**：输入为 $(42, 18, 55, 0, [650.0, 800.0], 9.0)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 42 + 18 = 60 \\geq 10$。$N_{\\mathrm{cov}} = 55 + 0 = 55 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{18}{60} = 0.3 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{55} = 0  0.20$。此条件满足。\n3.  结合：$\\min(A) = \\min([650.0, 800.0]) = 650.0$。该值不小于或等于 $500$。此条件不满足。\n该候选肽因预测的结合亲和力弱而未通过。\n分类结果：$0$。\n\n**候选肽 4**：输入为 $(15, 15, 40, 0, [100.0], 0.5)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 15 + 15 = 30 \\geq 10$。$N_{\\mathrm{cov}} = 40 + 0 = 40 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{15}{30} = 0.5 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{0}{40} = 0  0.20$。此条件满足。\n3.  结合：$\\min(A) = \\min([100.0]) = 100.0 \\leq 500$。此条件满足。\n4.  表达：$E = 0.5$。该值不大于或等于 $1.0$。此条件不满足。\n该候选肽因来源转录本的表达不足而未通过。\n分类结果：$0$。\n\n**候选肽 5**：输入为 $(28, 12, 5, 0, [30.0, 40.0], 10.0)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 28 + 12 = 40 \\geq 10$。然而，$N_{\\mathrm{cov}} = 5 + 0 = 5$，不大于或等于 $10$。此条件不满足。\n该候选肽因正常样本中的测序覆盖度不足而未通过。\n分类结果：$0$。\n\n**候选肽 6**：输入为 $(25, 25, 38, 2, [200.0, 400.0], 3.0)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 25 + 25 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 38 + 2 = 40 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{25}{50} = 0.5 \\geq 0.05$。$\\mathrm{VAF}_N = \\frac{2}{40} = 0.05  0.20$。此条件满足。\n3.  结合：$\\min(A) = \\min([200.0, 400.0]) = 200.0 \\leq 500$。此条件满足。\n4.  表达：$E = 3.0 \\geq 1.0$。此条件满足。\n所有四个条件均满足。\n分类结果：$1$。\n\n**候选肽 7**：输入为 $(50, 0, 60, 0, [5.0], 9.0)$。\n1.  覆盖度：$T_{\\mathrm{cov}} = 50 + 0 = 50 \\geq 10$。$N_{\\mathrm{cov}} = 60 + 0 = 60 \\geq 10$。此条件满足。\n2.  VAF：$\\mathrm{VAF}_T = \\frac{0}{50} = 0$。该值不大于或等于 $0.05$。此条件不满足。\n该候选肽未通过，因为在肿瘤样本中没有变异等位基因的证据。\n分类结果：$0$。\n\n最终的分类向量为 $[1, 0, 0, 0, 0, 1, 0]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a classifier for neoantigens based on a formal set of criteria\n    and applies it to a fixed test suite.\n    \"\"\"\n    \n    # Define fixed thresholds as per the problem specification.\n    C_MIN = 10         # Minimum read coverage\n    TAU_TUMOR = 0.05   # Minimum tumor VAF\n    TAU_GERM = 0.20    # Maximum normal VAF\n    THETA_BIND = 500   # Maximum binding affinity in nM\n    THETA_EXPR = 1.0   # Minimum expression in TPM\n\n    # Define the test suite of candidate peptides.\n    # Each tuple is (T_ref, T_alt, N_ref, N_alt, A, E).\n    test_cases = [\n        (30, 20, 50, 0, [120.0, 720.0], 8.5),   # Candidate 1\n        (25, 35, 30, 30, [50.0, 80.0], 12.0),  # Candidate 2\n        (42, 18, 55, 0, [650.0, 800.0], 9.0),  # Candidate 3\n        (15, 15, 40, 0, [100.0], 0.5),          # Candidate 4\n        (28, 12, 5, 0, [30.0, 40.0], 10.0),    # Candidate 5\n        (25, 25, 38, 2, [200.0, 400.0], 3.0),  # Candidate 6\n        (50, 0, 60, 0, [5.0], 9.0),            # Candidate 7\n    ]\n\n    def calculate_vaf(alt_reads, ref_reads):\n        \"\"\"\n        Calculates the Variant Allele Fraction (VAF).\n        Returns 0 if total coverage is 0, as specified.\n        \"\"\"\n        coverage = alt_reads + ref_reads\n        if coverage == 0:\n            return 0.0\n        return alt_reads / coverage\n\n    results = []\n    for case in test_cases:\n        t_ref, t_alt, n_ref, n_alt, a_list, e_val = case\n        \n        # Calculate intermediate values needed for the classification logic.\n        t_cov = t_ref + t_alt\n        n_cov = n_ref + n_alt\n        vaf_t = calculate_vaf(t_alt, t_ref)\n        vaf_n = calculate_vaf(n_alt, n_ref)\n        min_binding_affinity = np.min(a_list)\n        \n        # Condition 1: Adequate sequencing support in both samples.\n        cond1 = (t_cov >= C_MIN) and (n_cov >= C_MIN)\n        \n        # Condition 2: Somatic alteration signature.\n        cond2 = (vaf_t >= TAU_TUMOR) and (vaf_n  TAU_GERM)\n        \n        # Condition 3: Sufficiently strong HLA binding prediction.\n        cond3 = min_binding_affinity = THETA_BIND\n        \n        # Condition 4: Sufficient tumor expression.\n        cond4 = e_val >= THETA_EXPR\n        \n        # A candidate is a true neoantigen if and only if all conditions hold.\n        if cond1 and cond2 and cond3 and cond4:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409285"}, {"introduction": "新抗原不仅来源于简单的点突变，癌症中常见的大规模基因组重排也是其重要来源。本项进阶练习将探索一种特殊情况：由基因融合事件产生的新抗原。你将实现一个算法，该算法遵循分子生物学的中心法则，通过构建融合蛋白序列，识别出跨越新颖融合连接点的独特肽段，并对其进行评分。这个过程将帮助你理解癌细胞如何利用基因融合机制产生免疫系统从未见过的“外源”肽 [@problem_id:2409288]。", "problem": "您的任务是实现一个完整、确定性的算法，用于识别和优先排序由基因融合事件产生的新抗原候选者，重点是跨越融合断裂点的肽段。您的实现必须从基本的生物学原理出发，并使用明确、可形式化的规则，以确保在不同编程语言间的普适可复现性。\n\n所要求的算法必须实现以下基于分子生物学中心法则和标准生物信息学实践的步骤：\n\n1. 通过连接上游基因的前缀和下游基因的后缀，构建融合互补脱氧核糖核酸 (cDNA) 序列。设上游编码序列为核苷酸串 $S_A$，下游编码序列为核苷酸串 $S_B$。设 $L_A$ 是一个非负整数，指定从 $S_A$ 的 $5'$ 端取出的碱基数量；设 $P_B$ 是一个非负整数，指定在 $S_B$ 中开始取后缀的、以0为基准的索引。融合后的 cDNA 为\n$$\nS_{\\text{fuse}} \\;=\\; S_A[0:L_A] \\;+\\; S_B[P_B:].\n$$\n\n2. 使用标准核基因密码将 $S_{\\text{fuse}}$ 翻译成蛋白质序列，从索引0开始，将碱基分组为长度为3的连续不重叠的密码子。设得到的氨基酸序列为 $A_0 A_1 \\dots A_{m-1}$，其中 $m$ 是翻译到第一个终止密码子之前的氨基酸数量（终止密码子会终止翻译，且不被包含在序列中）。每个氨基酸 $A_i$ 由 $S_{\\text{fuse}}$ 中索引为 $3i, 3i+1, 3i+2$ 的碱基组成的密码子产生。\n\n3. 对于给定的肽段长度 $k$（一个正整数），枚举所有满足 $0 \\le i \\le m-k$ 的连续 $k$-mer 肽段窗口 $p = A_i A_{i+1} \\dots A_{i+k-1}$。在 $S_{\\text{fuse}}$ 中，以碱基坐标定义断裂点位于索引 $L_A$ 处。一个 $k$-mer $p$ 被称为跨越断裂点，当且仅当其密码子在碱基坐标上的覆盖范围跨越了 $L_A$，即：\n$$\n3i  L_A \\quad \\text{and} \\quad 3(i+k)  L_A.\n$$\n该标准严格要求构成该肽段窗口的密码子中，至少包含一个来自上游部分 $S_A[0:L_A]$ 的碱基和至少一个来自下游部分 $S_B[P_B:]$ 的碱基。\n\n4. 使用位置特异性评分矩阵 (PSSM) 为每个 $k$-mer 候选者打分，该矩阵旨在以简化的方式近似模拟人类白细胞抗原 (Human Leukocyte Antigen, HLA) I类分子的结合偏好。设氨基酸字母表为20种标准氨基酸，顺序为 $[A,C,D,E,F,G,H,I,K,L,M,N,P,Q,R,S,T,V,W,Y]$。定义 $w_{j}(a)$ 为氨基酸 $a$ 在位置 $j$（$0 \\le j \\le k-1$）的权重，并将肽段得分 $S(p)$ 设为\n$$\nS(p) \\;=\\; \\sum_{j=0}^{k-1} w_j\\!\\left( A_{i+j} \\right).\n$$\n将所有权重初始化为 $0.0$，然后应用以下覆盖规则：\n- 在位置 $j=1$：$w_1(L)=2.0$, $w_1(I)=2.0$, $w_1(M)=1.5$, $w_1(V)=1.5$, $w_1(T)=0.5$。\n- 在位置 $j=8$：$w_8(L)=1.5$, $w_8(V)=1.2$, $w_8(I)=1.0$, $w_8(A)=0.8$, $w_8(F)=0.5$。\n- 在位置 $j=5$：$w_5(S)=0.4$, $w_5(T)=0.3$, $w_5(A)=0.2$, $w_5(G)=0.3$。\n- 对所有位置施加脯氨酸（Proline）罚分：对于所有 $j$，设置 $w_j(P) \\leftarrow w_j(P) - 0.5$。\n如果上述指定的位置 $j$ 超过 $k-1$（例如，当 $k  9$ 时），则忽略该覆盖规则。除脯氨酸罚分外，未明确指定的位置权重保持为 $0.0$。\n\n5. 给定一个实数值阈值 $\\tau$，如果一个肽段的得分 $S(p) \\ge \\tau$，则将其定义为被优先排序的。对于每个测试用例，您的程序必须统计得分 $S(p) \\ge \\tau$ 的跨断裂点 $k$-mer 的数量。\n\n您必须依赖的基础依据：\n- 分子生物学中心法则：脱氧核糖核酸 (DNA) 转录为核糖核酸 (RNA)，信使RNA (mRNA) 以三个碱基为一组（密码子）翻译成蛋白质。\n- 用于将密码子翻译为氨基酸的标准核基因密码，翻译过程在遇到第一个终止密码子时终止。\n- 用于位置特异性评分矩阵的对数加性评分模型，其中 $S(p)$ 计算为各位置特异性权重的总和。\n\n实现规范：\n- 仅使用下面测试套件中列出的序列和参数。\n- 使用标准核基因密码。翻译从 $S_{\\text{fuse}}$ 的第一个碱基开始，在读码框0中进行，直到遇到终止密码子或序列结束。\n- 为本问题之目的，所有序列都是使用字母表 $\\{A,C,G,T\\}$ 的编码DNA序列。\n- 角度和物理单位不适用。所有数值答案必须是整数。\n\n测试套件：\n对于下面的每个案例，给定 $(S_A, L_A, S_B, P_B, k, \\tau)$。\n\n- 案例1（框内融合，预期产生高分数的连接处肽段）：\n  - $S_A = \\text{\"ATGGCTATCGCTCTGGCTTCC\"}$\n  - $L_A = 21$\n  - $S_B = \\text{\"ACCGGCGTGAAGCTGGCTGTGAACCGC\"}$\n  - $P_B = 0$\n  - $k = 9$\n  - $\\tau = 3.0$\n\n- 案例2（密码子内发生移码，富含亮氨酸的下游，中等阈值）：\n  - $S_A = \\text{\"ATGGGCCCCCAGGTGGTG\"}$\n  - $L_A = 13$\n  - $S_B = \\text{\"CTGCTGCTGCTGCTGCTGCTGCTGCTG\"}$\n  - $P_B = 0$\n  - $k = 9$\n  - $\\tau = 2.0$\n\n- 案例3（总蛋白长度小于窗口大小，不可能产生k-mer）：\n  - $S_A = \\text{\"ATGGCTATCGCTGTG\"}$\n  - $L_A = 15$\n  - $S_B = \\text{\"GCTGCTGCTGCTGCT\"}$\n  - $P_B = 0$\n  - $k = 11$\n  - $\\tau = 0.0$\n\n- 案例4（框内连接点后紧跟一个框内终止密码子，消除了连接处肽段）：\n  - $S_A = \\text{\"ATGGCTATCGCTCTGGCTTCC\"}$\n  - $L_A = 21$\n  - $S_B = \\text{\"TAAGCTGCTGCT\"}$\n  - $P_B = 0$\n  - $k = 9$\n  - $\\tau = 0.0$\n\n- 案例5（框内融合，从下游内部起始，低阈值）：\n  - $S_A = \\text{\"ATGGCTATCGCTCTGGCTTCC\"}$\n  - $L_A = 21$\n  - $S_B = \\text{\"ACCGGCGTGAAGCTGGCTGTGAACCGC\"}$\n  - $P_B = 3$\n  - $k = 9$\n  - $\\tau = 1.0$\n\n最终输出格式：\n- 您的程序必须按顺序计算上述5个案例中每一个的、被优先排序的跨断裂点 $k$-mer 的整数数量。\n- 程序必须打印一行，其中包含一个由方括号括起来的、按案例顺序排列的5个整数结果列表，结果之间没有空格，例如 $[\\dots]$。", "solution": "所提出的问题是计算生物学中一个定义明确且有科学依据的任务，具体来说是从基因融合事件中预测新抗原。该问题是有效的，因为它基于分子生物学和生物信息学的既定原则，提供了一套完整、确定性且可形式化的规则。所有参数、序列和评分方案都已明确定义，使得问题自洽且可解。我们将通过系统地实现所规定的算法来着手解决。\n\n问题的核心在于将构建的融合核苷酸序列翻译成蛋白质序列，然后识别和评分那些跨越融合连接点的潜在T细胞表位（称为 $k$-mer）。\n\n首先，我们必须定义标准核基因密码，它将3个碱基的密码子映射到相应的氨基酸。翻译从序列的开头开始，在遇到三个终止密码子（`TAA`、`TAG` 或 `TGA`）之一时终止。终止密码子本身不会被翻译成氨基酸。\n\n对于每个由元组 $(S_A, L_A, S_B, P_B, k, \\tau)$ 指定的测试用例，其算法流程如下：\n\n1.  **融合cDNA构建**：\n    融合互补脱氧核糖核酸 ($cDNA$) 序列，表示为 $S_{\\text{fuse}}$，是通过连接上游基因序列 $S_A$ 的前缀和下游基因序列 $S_B$ 的后缀构建的。前缀由 $S_A$ 的前 $L_A$ 个碱基组成，后缀从 $S_B$ 中以0为基准的索引 $P_B$ 处开始。\n    $$S_{\\text{fuse}} = S_A[0:L_A] + S_B[P_B:]$$\n    在 $S_{\\text{fuse}}$ 中索引为 $L_A$ 的连接点代表了融合断裂点。\n\n2.  **翻译为蛋白质序列**：\n    序列 $S_{\\text{fuse}}$ 被翻译成氨基酸序列。翻译从索引0开始，通过读取连续、不重叠的3碱基密码子进行。此过程持续进行，直到遇到第一个终止密码子或序列耗尽。设得到的蛋白质为 $m$ 个氨基酸长，表示为 $A_0 A_1 \\dots A_{m-1}$。\n\n3.  **位置特异性评分矩阵 (PSSM) 构建**：\n    构建一个 PSSM 来为长度为 $k$ 的肽段打分。该矩阵 $W$ 为肽段内每个位置 $j$（$0 \\le j \\le k-1$）的每种标准氨基酸 $a$ 存储一个权重 $w_j(a)$。权重被初始化为 $0.0$，然后根据提供的特定规则进行更新：\n    -   对于位置 $j=1$：$w_1(L)=2.0, w_1(I)=2.0, w_1(M)=1.5, w_1(V)=1.5, w_1(T)=0.5$。\n    -   对于位置 $j=8$：$w_8(L)=1.5, w_8(V)=1.2, w_8(I)=1.0, w_8(A)=0.8, w_8(F)=0.5$。\n    -   对于位置 $j=5$：$w_5(S)=0.4, w_5(T)=0.3, w_5(A)=0.2, w_5(G)=0.3$。\n    仅当指定的位置 $j$ 小于 $k$ 时，才应用这些规则。\n    -   对任意位置 $j$ 的脯氨酸 `P` 施加罚分，方法是从其现有权重中减去 $0.5$：$w_j(P) \\leftarrow w_j(P) - 0.5$。\n\n4.  **肽段的枚举、过滤和评分**：\n    从翻译出的蛋白质中，为所有满足 $0 \\le i \\le m-k$ 的有效起始索引 $i$，枚举出所有连续的 $k$-mer $p = A_i A_{i+1} \\dots A_{i+k-1}$。每个枚举出的肽段都需满足两个条件：\n\n    a. **跨断裂点条件**：如果一个以氨基酸 $A_i$ 开始的肽段 $p$，其组成密码子的基因组区域跨越了碱基索引 $L_A$ 处的融合连接位点，则定义其为跨断裂点。氨基酸 $A_i$ 的密码子占据了从 $3i$ 到 $3i+2$ 的碱基。整个肽段 $p$ 占据了从 $3i$ 到 $3(i+k)-1$ 的碱基。该条件可正式表述为：\n    $$3i  L_A \\quad \\text{and} \\quad 3(i+k) > L_A$$\n    只有满足此条件的肽段才会被进一步考虑。\n\n    b. **评分和优先排序**：对于每个跨断裂点的肽段 $p$，使用对数加性模型和构建的 PSSM 计算其得分 $S(p)$：\n    $$S(p) = \\sum_{j=0}^{k-1} w_j(A_{i+j})$$\n    如果肽段的得分达到或超过给定的阈值 $\\tau$，即 $S(p) \\ge \\tau$，则该肽段被视为“被优先排序的”。\n\n5.  **最终计数**：\n    对于每个测试用例，最终输出是此类被优先排序的、跨断裂点 $k$-mer 的总数。\n\n现在，我们将此确定性流程应用于所提供的5个测试用例中的每一个。\n\n-   **案例1**：$(S_A, L_A, S_B, P_B, k, \\tau) = (\\text{\"ATGGCTATCGCTCTGGCTTCC\"}, 21, \\text{\"ACCGGCGTGAAGCTGGCTGTGAACCGC\"}, 0, 9, 3.0)$。\n    $S_{\\text{fuse}} = \\text{\"ATGGCTATCGCTCTGGCTTCCACCGGCGTGAAGCTGGCTGTGAACCGC\"}$。蛋白质翻译产生 `MAIALASTGVKLAVNR` ($m=16$)。断裂点位于 $L_A=21$。对于 $k=9$，跨越断裂点的肽段是那些起始索引 $i$ 满足 $3i  21 \\implies i  7$ 和 $3(i+9) > 21 \\implies i > -2$ 的肽段。我们检查 $i \\in [0, 6]$。\n    -   $i=1$：肽段 `AIALASTGV`。得分 $S(p) = w_1(I) + w_5(S) + w_8(V) = 2.0 + 0.4 + 1.2 = 3.6$。由于 $3.6 \\ge 3.0$，这是一个被优先排序的肽段。\n    -   $i=3$：肽段 `ALASTGVKL`。得分 $S(p) = w_1(L) + w_5(G) + w_8(L) = 2.0 + 0.3 + 1.5 = 3.8$。由于 $3.8 \\ge 3.0$，这是一个被优先排序的肽段。\n    其他跨断裂点的肽段未达到阈值 $\\tau=3.0$。总数为 $2$。\n\n-   **案例2**：$(S_A, L_A, S_B, P_B, k, \\tau) = (\\text{\"ATGGGCCCCCAGGTGGTG\"}, 13, \\text{\"CTGCTGCTGCTGCTGCTGCTGCTGCTG\"}, 0, 9, 2.0)$。\n    $S_{\\text{fuse}} = \\text{\"ATGGGCCCCCAGGCTGCTGCTGCTGCTGCTGCTGCTGCTG\"}$。在 $L_A=13$ 处的融合导致了移码。翻译产生 `MGPQAAAA...` ($m=13$)。对于 $k=9$，跨越断裂点的肽段是那些起始于 $i$ 且满足 $3i  13 \\implies i \\le 4$ 的肽段。\n    -   来自该序列的肽段的最高可能得分为 $1.0$ (例如，来自肽段 `QAAAAAAAA` 和 `AAAAAAAAA`)。由于 $1.0  2.0$，没有肽段被优先排序。数量为 $0$。\n\n-   **案例3**：$(S_A, L_A, S_B, P_B, k, \\tau) = (\\text{\"ATGGCTATCGCTGTG\"}, 15, \\text{\"GCTGCTGCTGCTGCT\"}, 0, 11, 0.0)$。\n    $S_{\\text{fuse}} = \\text{\"ATGGCTATCGCTGTGGCTGCTGCTGCTGCT\"}$。翻译产生 `MAIAVAAAAA` ($m=10$)。要求的肽段长度为 $k=11$。由于总蛋白长度 $m=10$ 小于 $k=11$，无法形成 $k$-mer。数量为 $0$。\n\n-   **案例4**：$(S_A, L_A, S_B, P_B, k, \\tau) = (\\text{\"ATGGCTATCGCTCTGGCTTCC\"}, 21, \\text{\"TAAGCTGCTGCT\"}, 0, 9, 0.0)$。\n    $S_{\\text{fuse}} = \\text{\"ATGGCTATCGCTCTGGCTTCCTAAGCTGCTGCT\"}$。$S_B$ 部分的第一个密码子是 `TAA`，一个终止密码子。翻译在该密码子之前终止。翻译出的蛋白质是 `MAIALAS` ($m=7$)。要求的肽段长度为 $k=9$。由于 $m  k$，无法形成 $k$-mer。数量为 $0$。\n\n-   **案例5**：$(S_A, L_A, S_B, P_B, k, \\tau) = (\\text{\"ATGGCTATCGCTCTGGCTTCC\"}, 21, \\text{\"ACCGGCGTGAAGCTGGCTGTGAACCGC\"}, 3, 9, 1.0)$。\n    $S_{\\text{fuse}} = \\text{\"ATGGCTATCGCTCTGGCTTCC\"}$ + `GGCGTGAAGCTGGCTGTGAACCGC`。翻译得到 `MAIALASGVKLA VNR` ($m=15$)。对于 $k=9$ 和 $L_A=21$，所有可能的肽段（起始于 $i \\in [0, 6]$）都是跨断裂点的肽段。我们将每个肽段与阈值 $\\tau=1.0$ 进行比较。\n    -   $i=0$: `MAIALASGV`。得分 $w_5(S)+w_8(V) = 0.4+1.2=1.6 \\ge 1.0$。Pass.\n    -   $i=1$: `AIALASGVK`。得分 $w_1(I)+w_5(A) = 2.0+0.2=2.2 \\ge 1.0$。Pass.\n    -   $i=2$: `IALASGVKL`。得分 $w_5(S)+w_8(L) = 0.4+1.5=1.9 \\ge 1.0$。Pass.\n    -   $i=3$: `ALASGVKLA`。得分 $w_1(L)+w_5(G)+w_8(A) = 2.0+0.3+0.8=3.1 \\ge 1.0$。Pass.\n    -   $i=4$: `LASGVKLAV`。得分 $w_8(V) = 1.2 \\ge 1.0$。Pass.\n    -   $i=5$: `SGVKLAVNR`。得分 $w_5(A) = 0.2  1.0$。Fail.\n    -   $i=6$: `GVKLAVNRQ` (应为 `GVKLAVNR`, 长度为9)。得分 $w_1(V) = 1.5 \\ge 1.0$。Pass.\n    被优先排序的肽段总数为 $6$。\n\n计算出的5个案例的数量为 $[2, 0, 0, 0, 6]$。", "answer": "```python\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Implements a deterministic algorithm to identify and prioritize neoantigen candidates\n    from gene fusion events, according to the problem specification.\n    \"\"\"\n\n    # Standard nuclear genetic code for translation.\n    GENETIC_CODE = {\n        'TTT': 'F', 'TTC': 'F', 'TTA': 'L', 'TTG': 'L',\n        'TCT': 'S', 'TCC': 'S', 'TCA': 'S', 'TCG': 'S',\n        'TAT': 'Y', 'TAC': 'Y', 'TAA': '*', 'TAG': '*',\n        'TGT': 'C', 'TGC': 'C', 'TGA': '*', 'TGG': 'W',\n        'CTT': 'L', 'CTC': 'L', 'CTA': 'L', 'CTG': 'L',\n        'CCT': 'P', 'CCC': 'P', 'CCA': 'P', 'CCG': 'P',\n        'CAT': 'H', 'CAC': 'H', 'CAA': 'Q', 'CAG': 'Q',\n        'CGT': 'R', 'CGC': 'R', 'CGA': 'R', 'CGG': 'R',\n        'ATT': 'I', 'ATC': 'I', 'ATA': 'I', 'ATG': 'M',\n        'ACT': 'T', 'ACC': 'T', 'ACA': 'T', 'ACG': 'T',\n        'AAT': 'N', 'AAC': 'N', 'AAA': 'K', 'AAG': 'K',\n        'AGT': 'S', 'AGC': 'S', 'AGA': 'R', 'AGG': 'R',\n        'GTT': 'V', 'GTC': 'V', 'GTA': 'V', 'GTG': 'V',\n        'GCT': 'A', 'GCC': 'A', 'GCA': 'A', 'GCG': 'A',\n        'GAT': 'D', 'GAC': 'D', 'GAA': 'E', 'GAG': 'E',\n        'GGT': 'G', 'GGC': 'G', 'GGA': 'G', 'GGG': 'G',\n    }\n    \n    AMINO_ACIDS = \"ACDEFGHIKLMNPQRSTVWY\"\n\n    def translate_sequence(dna_sequence: str) - str:\n        \"\"\"Translates a DNA sequence into an amino acid sequence.\"\"\"\n        protein = []\n        for i in range(0, len(dna_sequence), 3):\n            codon = dna_sequence[i:i+3]\n            if len(codon)  3:\n                break\n            amino_acid = GENETIC_CODE.get(codon, '')\n            if amino_acid == '*':\n                break\n            protein.append(amino_acid)\n        return \"\".join(protein)\n\n    def build_pssm(k: int) - defaultdict:\n        \"\"\"Constructs the Position-Specific Scoring Matrix (PSSM).\"\"\"\n        pssm = defaultdict(float)\n\n        # Apply overrides, checking if position j is valid for k.\n        if 1  k:\n            pssm[(1, 'L')] = 2.0\n            pssm[(1, 'I')] = 2.0\n            pssm[(1, 'M')] = 1.5\n            pssm[(1, 'V')] = 1.5\n            pssm[(1, 'T')] = 0.5\n        if 8  k:\n            pssm[(8, 'L')] = 1.5\n            pssm[(8, 'V')] = 1.2\n            pssm[(8, 'I')] = 1.0\n            pssm[(8, 'A')] = 0.8\n            pssm[(8, 'F')] = 0.5\n        if 5  k:\n            pssm[(5, 'S')] = 0.4\n            pssm[(5, 'T')] = 0.3\n            pssm[(5, 'A')] = 0.2\n            pssm[(5, 'G')] = 0.3\n\n        # Apply proline penalty at all positions.\n        for j in range(k):\n            pssm[(j, 'P')] -= 0.5\n            \n        return pssm\n\n    # Test suite from the problem statement.\n    test_cases = [\n        # Case 1\n        (\"ATGGCTATCGCTCTGGCTTCC\", 21, \"ACCGGCGTGAAGCTGGCTGTGAACCGC\", 0, 9, 3.0),\n        # Case 2\n        (\"ATGGGCCCCCAGGTGGTG\", 13, \"CTGCTGCTGCTGCTGCTGCTGCTGCTG\", 0, 9, 2.0),\n        # Case 3\n        (\"ATGGCTATCGCTGTG\", 15, \"GCTGCTGCTGCTGCT\", 0, 11, 0.0),\n        # Case 4\n        (\"ATGGCTATCGCTCTGGCTTCC\", 21, \"TAAGCTGCTGCT\", 0, 9, 0.0),\n        # Case 5\n        (\"ATGGCTATCGCTCTGGCTTCC\", 21, \"ACCGGCGTGAAGCTGGCTGTGAACCGC\", 3, 9, 1.0),\n    ]\n\n    results = []\n    for s_a, l_a, s_b, p_b, k, tau in test_cases:\n        # Step 1: Construct fusion cDNA sequence\n        s_fuse = s_a[:l_a] + s_b[p_b:]\n\n        # Step 2: Translate to protein sequence\n        protein_seq = translate_sequence(s_fuse)\n        m = len(protein_seq)\n\n        # Step 3: Construct the PSSM\n        pssm = build_pssm(k)\n        \n        prioritized_count = 0\n        \n        # Step 4: Enumerate, filter, and score peptides\n        if m >= k:\n            for i in range(m - k + 1):\n                # Check breakpoint-spanning condition\n                if 3 * i  l_a and 3 * (i + k) > l_a:\n                    peptide = protein_seq[i:i+k]\n                    \n                    # Calculate score\n                    score = 0.0\n                    for j, amino_acid in enumerate(peptide):\n                        score += pssm[(j, amino_acid)]\n                    \n                    # Check prioritization threshold\n                    if score >= tau:\n                        prioritized_count += 1\n        \n        results.append(prioritized_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409288"}]}