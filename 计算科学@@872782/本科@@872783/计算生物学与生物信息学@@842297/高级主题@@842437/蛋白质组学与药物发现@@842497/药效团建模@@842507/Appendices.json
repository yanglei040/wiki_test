{"hands_on_practices": [{"introduction": "药效团模型从何而来？一个主要来源是目标蛋白的三维结构。我们可以用虚拟“探针”（如氢键供体或疏水基团）探测结合位点，并绘制出这些相互作用在能量上有利的区域。这些“热点”构成了基于受体的药效团模型的基础。这项练习 [@problem_id:2440150] 提供了将复杂的蛋白质结构转化为简单、可操作的化学假设的实践经验，通过实施一个简化的物理模型，帮助您建立对控制配体结合的分子间作用力的直观理解。", "problem": "给定三维的受体结合位点描述，其中包含原子位置（单位为埃）、元素类型和部分电荷（无量纲）。您的任务是通过识别三种探针类型（氢键供体（D）、氢键受体（A）和疏水基（H））的空间热点，构建一个受体引导的药效团。在这里，一个受体引导的药效团特征被定义为虚拟探针与受体相互作用时，在物理驱动的相互作用下，探针所处的局部能量最小值。您必须实现一个基于网格的评估方法，并为每种探针类型返回一组代表关键相互作用点的、小而多样化的局部最小值集合。所有最终报告的坐标必须以埃为单位表示，并四舍五入到三位小数。\n\n使用的基本原理和假设：\n- 静电相互作用遵循库仑定律：电荷间的相互作用取决于电荷的乘积和距离的反幂。在异质介质中，通常使用距离依赖的介电常数作为近似。此处使用与距离成正比的距离依赖介电常数，以获得静电能量与距离的平方反比关系。\n- 短程空间排斥由范德华（vdW）相互作用的排斥部分来描述。使用与距离的十二次方成反比的纯排斥项来近似这种排斥作用。\n- 疏水效应可以近似为非极性碳原子周围呈空间衰减的占据偏好。对于疏水探针，此效应被建模为以碳原子为中心的球对称高斯势阱。\n\n基于这些原理，构建一个类型为 $T \\in \\{\\mathrm{D}, \\mathrm{A}, \\mathrm{H}\\}$ 的探针在位置 $\\mathbf{x}$ 相对于位置为 $\\mathbf{r}_i$、电荷为 $q_i$ 的受体原子（索引为 $i$）的相互作用能：\n- 为保证短距离下的数值稳定性，令 $r_i(\\mathbf{x}) = \\max\\{ \\lVert \\mathbf{x} - \\mathbf{r}_i \\rVert_2, r_{\\mathrm{soft}} \\}$。\n- 静电项：$E_{\\mathrm{elec}}(\\mathbf{x}) = \\sum_i \\dfrac{q_T \\, q_i}{r_i(\\mathbf{x})^2}$，其中 $q_T$ 是探针的有效电荷：$q_{\\mathrm{D}} = +0.4$，$q_{\\mathrm{A}} = -0.4$，$q_{\\mathrm{H}} = 0.0$（无量纲）。\n- 空间排斥项：$E_{\\mathrm{rep}}(\\mathbf{x}) = \\sum_i \\dfrac{k_{\\mathrm{rep}}}{r_i(\\mathbf{x})^{12}}$，其中 $k_{\\mathrm{rep}} = 0.01$。\n- 疏水项（仅适用于疏水探针 $T = \\mathrm{H}$，且仅来源于碳原子）：$E_{\\mathrm{hyd}}(\\mathbf{x}) = - \\sum_{i \\in \\mathrm{carbons}} k_{\\mathrm{hyd}} \\, \\exp\\!\\left(-\\dfrac{r_i(\\mathbf{x})^2}{\\sigma^2}\\right)$，其中 $k_{\\mathrm{hyd}} = 0.3$，$\\sigma = 2.0$。\n- 探针 $T$ 的总能量：$E_T(\\mathbf{x}) = E_{\\mathrm{elec}}(\\mathbf{x}) + E_{\\mathrm{rep}}(\\mathbf{x}) + 1_{T=\\mathrm{H}} \\, E_{\\mathrm{hyd}}(\\mathbf{x})$。\n\n数值参数和单位：\n- 设置 $r_{\\mathrm{soft}} = 0.5$ 埃。\n- 所有能量均以任意能量单位（A.U.）表示。您不能进行单位转换。\n- 网格间距为 $\\Delta = 1.0$ 埃。\n\n局部最小值的定义和选择：\n- 在一个三维网格上评估 $E_T(\\mathbf{x})$，该网格覆盖每个测试用例定义的轴对齐边界框。\n- 如果一个网格点的值严格小于其在 $3 \\times 3 \\times 3$ 立方体中所有相邻邻居（不包括其自身，即三维空间中的26个直接邻居）的值，则该点为局部最小值。对于边界点，仅与边界内的邻居进行比较。\n- 对于每种探针类型 $T$，按能量（升序）对所有局部最小值进行排序。\n- 通过空间聚类进行多样化：遍历排序后的最小值（从最优到最差），仅当一个候选最小值与同一类型 $T$ 的所有先前接受的最小值之间的欧几里得距离至少为 $r_{\\mathrm{cluster}} = 1.0$ 埃时，才保留该候选。\n- 每个测试用例的每种探针类型最多保留 $K = 3$ 个最小值，且须满足能量截断条件 $E_T(\\mathbf{x}) < E_{\\mathrm{cut},T}$，其中 $E_{\\mathrm{cut},\\mathrm{D}} = -0.03$，$E_{\\mathrm{cut},\\mathrm{A}} = -0.03$，$E_{\\mathrm{cut},\\mathrm{H}} = -0.08$ (A.U.)。\n- 报告每种探针类型保留的最小值的坐标。\n\n测试套件（三个案例）。在每个案例中，坐标单位为埃，电荷无量纲：\n- 案例 1:\n  - 受体原子：\n    - 氧（$\\mathrm{O}$）：位置 $(0.0, 0.0, 0.0)$，$q = -0.5$。\n    - 氮（$\\mathrm{N}$）：位置 $(3.0, 0.0, 0.0)$，$q = +0.3$。\n    - 碳（$\\mathrm{C}$）：位置 $(0.0, 3.0, 0.0)$，$q = 0.0$。\n    - 碳（$\\mathrm{C}$）：位置 $(0.0, -3.0, 0.0)$，$q = 0.0$。\n  - 网格边界框：中心 $(0.0, 0.0, 0.0)$，各轴半范围 $4.0$，间距 $\\Delta = 1.0$。\n- 案例 2:\n  - 受体原子：\n    - 氧（$\\mathrm{O}$）：位置 $(-2.0, -2.0, 0.0)$，$q = -0.4$。\n    - 氧（$\\mathrm{O}$）：位置 $(2.0, 2.0, 0.0)$，$q = -0.4$。\n    - 氮（$\\mathrm{N}$）：位置 $(-2.0, 2.0, 0.0)$，$q = +0.3$。\n    - 碳（$\\mathrm{C}$）：位置 $(0.0, 0.0, 2.0)$，$q = 0.0$。\n  - 网格边界框：中心 $(0.0, 0.0, 0.0)$，各轴半范围 $3.0$，间距 $\\Delta = 1.0$。\n- 案例 3:\n  - 受体原子：\n    - 碳（$\\mathrm{C}$）：位置 $(-1.5, 0.0, 0.0)$，$q = 0.0$。\n    - 碳（$\\mathrm{C}$）：位置 $(1.5, 0.0, 0.0)$，$q = 0.0$。\n    - 碳（$\\mathrm{C}$）：位置 $(0.0, 2.0, 0.0)$，$q = 0.0$。\n  - 网格边界框：中心 $(0.0, 0.0, 0.0)$，各轴半范围 $3.0$，间距 $\\Delta = 1.0$。\n\n程序要求：\n- 根据上述基本原理实现能量模型，在指定的网格上进行评估，按定义检测和选择局部最小值，并应用聚类和截断。\n- 对每个测试用例，生成一个包含三个列表的有序列表 $[\\mathrm{D}, \\mathrm{A}, \\mathrm{H}]$，其中每个列表是对应探针类型所选出的三维点 $[x, y, z]$（单位为埃）的列表，四舍五入到三位小数。\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果，形式为方括号括起来的逗号分隔列表。具体来说：一个长度为三的列表，其中每个元素本身是该测试用例的 $[\\mathrm{D}, \\mathrm{A}, \\mathrm{H}]$ 三元组。每个坐标必须四舍五入到三位小数，并以埃为单位表示。所需格式示例（非实际值）：\n  - $[[[\\cdot,\\cdot,\\cdot],\\ldots],[[\\cdot,\\cdot,\\cdot],\\ldots],[[\\cdot,\\cdot,\\cdot],\\ldots]], \\ldots$ 对应三个案例。\n- 最终输出必须是单行，无额外文本。所有报告的坐标必须四舍五入到三位小数（埃）。", "solution": "该问题陈述经过了严格验证，在科学上是合理的，在计算上是适定的。它提出了一个计算药物设计中明确定义的任务，特别是受体引导的药效团的生成。所用的物理模型虽然简化，但基于分子力学的既定原理。所有必要的参数和算法步骤都已提供，使得问题清晰明确且可解。我们着手进行求解。\n\n问题的核心是在受体的结合位点内，为三种类型的化学探针——氢键供体（$D$）、氢键受体（$A$）和疏水基团（$H$）——识别能量上有利的位置。这些有利的位置，或称“热点”，被定义为势能面上的局部最小值。解决方案通过一个多步骤的计算程序构建。\n\n### 1. 势能函数\n\n一个类型为 $T \\in \\{D, A, H\\}$ 的虚拟探针在位置 $\\mathbf{x}$ 与受体原子之间的相互作用由一个势能函数 $E_T(\\mathbf{x})$ 建模。该函数是静电、空间排斥以及（对于疏水探针）疏水相互作用项的总和。设受体由索引为 $i$、位置为 $\\mathbf{r}_i$、部分电荷为 $q_i$ 的原子组成。探针与原子 $i$ 之间的距离为 $d_i(\\mathbf{x}) = \\lVert \\mathbf{x} - \\mathbf{r}_i \\rVert_2$。为了防止在距离趋近于零时出现数值不稳定性，使用了一个软化距离 $r_i(\\mathbf{x})$：\n$$\nr_i(\\mathbf{x}) = \\max \\{ d_i(\\mathbf{x}), r_{\\mathrm{soft}} \\}\n$$\n其中软化参数为 $r_{\\mathrm{soft}} = 0.5$ 埃。\n\n总能量 $E_T(\\mathbf{x})$ 定义为：\n$$\nE_T(\\mathbf{x}) = E_{\\mathrm{elec}}(\\mathbf{x}) + E_{\\mathrm{rep}}(\\mathbf{x}) + \\delta_{TH} \\, E_{\\mathrm{hyd}}(\\mathbf{x})\n$$\n其中 $\\delta_{TH}$ 是克罗内克δ函数，如果探针类型 $T$ 是 $H$，则等于1，否则为0。\n\n**1.1. 静电能量 ($E_{\\mathrm{elec}}$)**\n该项模拟库仑相互作用。问题指定了距离依赖的介电常数，导致能量与距离呈平方反比关系。探针具有有效电荷 $q_T$。\n$$\nE_{\\mathrm{elec}}(\\mathbf{x}) = \\sum_i \\frac{q_T \\, q_i}{r_i(\\mathbf{x})^2}\n$$\n探针电荷定义为 $q_D = +0.4$，$q_A = -0.4$，$q_H = 0.0$。\n\n**1.2. 空间排斥能量 ($E_{\\mathrm{rep}}$)**\n该项模拟电子云之间强烈的短程排斥，这是泡利不相容原理的结果。它被近似为一个反比十二次方定律，这是伦纳德-琼斯势的一个标准组成部分。\n$$\nE_{\\mathrm{rep}}(\\mathbf{x}) = \\sum_i \\frac{k_{\\mathrm{rep}}}{r_i(\\mathbf{x})^{12}}\n$$\n排斥强度常数给定为 $k_{\\mathrm{rep}} = 0.01$。\n\n**1.3. 疏水能量 ($E_{\\mathrm{hyd}}$)**\n该项特定于疏水探针（$T=H$），模拟非极性基团为减少对溶剂氢键网络的干扰而聚集在一起的趋势（此处为隐式模拟）。该相互作用是吸引性的，被建模为以受体的非极性碳原子为中心的高斯势阱之和。\n$$\nE_{\\mathrm{hyd}}(\\mathbf{x}) = - \\sum_{i \\in \\text{carbons}} k_{\\mathrm{hyd}} \\exp\\left(-\\frac{r_i(\\mathbf{x})^2}{\\sigma^2}\\right)\n$$\n该势的参数为强度 $k_{\\mathrm{hyd}} = 0.3$ 和空间范围 $\\sigma = 2.0$ 埃。\n\n### 2. 基于网格的评估\n\n为了进行计算分析，连续的势能面被离散化。对于每个测试用例，在指定的轴对齐边界框内生成一个三维网格点。网格间距是均匀的，$\\Delta = 1.0$ 埃。对于每种探针类型 $T$，在每个网格点 $\\mathbf{x}$ 上计算能量 $E_T(\\mathbf{x})$，得到一个三维能量值数组，我们称之为能量网格。\n\n### 3. 局部最小值的识别\n\n如果一个网格点的能量值严格小于其所有直接邻居的能量值，则该点被识别为局部最小值。对于网格内部的点，有 $3^3 - 1 = 26$ 个这样的邻居。对于位于网格边界、面或角上的点，仅与位于网格内的邻居进行比较。算法遍历能量网格上的每个点，并执行这些比较，以编制一个包含所有局部最小值及其网格坐标和相应能量值的列表。\n\n### 4. 最小值的选择与多样化\n\n必须对原始的局部最小值集合进行筛选，以产生一个小的、多样化的最重要相互作用热点集合。这是通过对每种探针类型依次执行一个四步过程来完成的。\n\n**4.1. 能量截断：** 能量不够有利的最小值被丢弃。位于位置 $\\mathbf{x}$ 的候选最小值仅当其能量 $E_T(\\mathbf{x})$ 低于特定类型的阈值时才被保留：\n$$\nE_T(\\mathbf{x})  E_{\\mathrm{cut},T}\n$$\n截断值给定为 $E_{\\mathrm{cut},D} = -0.03$，$E_{\\mathrm{cut},A} = -0.03$ 和 $E_{\\mathrm{cut},H} = -0.08$（单位为任意能量单位）。\n\n**4.2. 排序：** 将存活下来的最小值按其能量值升序排列，从最有利到最不利。\n\n**4.3. 空间聚类：** 为确保药效团特征集合的多样性，应用了空间聚类程序。算法遍历已排序的最小值列表。第一个最小值（能量最低的那个）总是被接受。后续的最小值仅当其位置与该探针类型所有先前接受的最小值之间的距离至少为 $r_{\\mathrm{cluster}} = 1.0$ 埃时才被接受。这可以防止从同一口袋或相互作用区域选择多个冗余的最小值。\n\n**4.4. 最终选择：** 该过程持续进行，直到每种探针类型接受了最多 $K=3$ 个多样化的、低能量的最小值。每种探针类型的最终输出是这些选定最小值的坐标列表。如果满足所有标准的最小值少于 $K$ 个，则列表会相应地变短。坐标以埃为单位报告，并四舍五入到三位小数。\n\n这整个程序被系统地应用于问题陈述中提供的每个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the pharmacophore generation for all test cases.\n    \"\"\"\n    \n    # Define physical and numerical parameters\n    PROBE_CHARGES = {'D': 0.4, 'A': -0.4, 'H': 0.0}\n    K_REP = 0.01\n    K_HYD = 0.3\n    SIGMA_HYD = 2.0\n    R_SOFT = 0.5\n    R_CLUSTER = 1.0\n    K_MAX_MINIMA = 3\n    ENERGY_CUTOFFS = {'D': -0.03, 'A': -0.03, 'H': -0.08}\n    PROBE_TYPES = ['D', 'A', 'H']\n\n    # Define the test cases from the problem statement.\n    # Each case: {atoms: [(pos, charge, type)], grid: (center, half_extent, spacing)}\n    test_cases = [\n        {\n            \"atoms\": [\n                (np.array([0.0, 0.0, 0.0]), -0.5, 'O'),\n                (np.array([3.0, 0.0, 0.0]), 0.3, 'N'),\n                (np.array([0.0, 3.0, 0.0]), 0.0, 'C'),\n                (np.array([0.0, -3.0, 0.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 4.0, \"spacing\": 1.0},\n        },\n        {\n            \"atoms\": [\n                (np.array([-2.0, -2.0, 0.0]), -0.4, 'O'),\n                (np.array([2.0, 2.0, 0.0]), -0.4, 'O'),\n                (np.array([-2.0, 2.0, 0.0]), 0.3, 'N'),\n                (np.array([0.0, 0.0, 2.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 3.0, \"spacing\": 1.0},\n        },\n        {\n            \"atoms\": [\n                (np.array([-1.5, 0.0, 0.0]), 0.0, 'C'),\n                (np.array([1.5, 0.0, 0.0]), 0.0, 'C'),\n                (np.array([0.0, 2.0, 0.0]), 0.0, 'C'),\n            ],\n            \"grid\": {\"center\": np.array([0.0, 0.0, 0.0]), \"half_extent\": 3.0, \"spacing\": 1.0},\n        },\n    ]\n\n    def calculate_energy(probe_pos, probe_type, atoms):\n        \"\"\"Calculates the interaction energy for a probe at a given position.\"\"\"\n        probe_charge = PROBE_CHARGES[probe_type]\n        e_elec, e_rep, e_hyd = 0.0, 0.0, 0.0\n\n        for atom_pos, atom_charge, atom_type in atoms:\n            dist = np.linalg.norm(probe_pos - atom_pos)\n            r = max(dist, R_SOFT)\n            \n            # Electrostatic term\n            e_elec += (probe_charge * atom_charge) / (r ** 2)\n            \n            # Repulsion term\n            e_rep += K_REP / (r ** 12)\n            \n            # Hydrophobic term\n            if probe_type == 'H' and atom_type == 'C':\n                e_hyd -= K_HYD * np.exp(-(r ** 2) / (SIGMA_HYD ** 2))\n                \n        return e_elec + e_rep + e_hyd\n\n    def solve_case(case):\n        \"\"\"Solves a single test case.\"\"\"\n        atoms = case[\"atoms\"]\n        center = case[\"grid\"][\"center\"]\n        half_extent = case[\"grid\"][\"half_extent\"]\n        spacing = case[\"grid\"][\"spacing\"]\n\n        # Generate grid coordinates\n        axis_coords = np.arange(center[0] - half_extent, center[0] + half_extent + spacing / 2, spacing)\n        grid_x, grid_y, grid_z = np.meshgrid(axis_coords, axis_coords, axis_coords, indexing='ij')\n        grid_shape = grid_x.shape\n        grid_points = np.stack([grid_x, grid_y, grid_z], axis=-1)\n\n        case_results = []\n        for probe_type in PROBE_TYPES:\n            # Calculate energy on the grid\n            energy_grid = np.zeros(grid_shape)\n            for i in range(grid_shape[0]):\n                for j in range(grid_shape[1]):\n                    for k in range(grid_shape[2]):\n                        probe_pos = grid_points[i, j, k]\n                        energy_grid[i, j, k] = calculate_energy(probe_pos, probe_type, atoms)\n\n            # Find local minima\n            local_minima = []\n            for i in range(grid_shape[0]):\n                for j in range(grid_shape[1]):\n                    for k in range(grid_shape[2]):\n                        val = energy_grid[i, j, k]\n                        is_min = True\n                        for di in [-1, 0, 1]:\n                            for dj in [-1, 0, 1]:\n                                for dk in [-1, 0, 1]:\n                                    if di == 0 and dj == 0 and dk == 0:\n                                        continue\n                                    ni, nj, nk = i + di, j + dj, k + dk\n                                    if 0 = ni  grid_shape[0] and 0 = nj  grid_shape[1] and 0 = nk  grid_shape[2]:\n                                        if energy_grid[ni, nj, nk] = val:\n                                            is_min = False\n                                            break\n                                if not is_min: break\n                            if not is_min: break\n                        if is_min:\n                            local_minima.append({\n                                'coord': grid_points[i, j, k],\n                                'energy': val\n                            })\n            \n            # Filter, sort, and diversify minima\n            # 1. Energy cutoff\n            filtered_minima = [m for m in local_minima if m['energy']  ENERGY_CUTOFFS[probe_type]]\n            \n            # 2. Sort by energy\n            sorted_minima = sorted(filtered_minima, key=lambda m: m['energy'])\n            \n            # 3. Diversify by clustering and limit to K\n            accepted_minima_coords = []\n            for minimum in sorted_minima:\n                if len(accepted_minima_coords) >= K_MAX_MINIMA:\n                    break\n                \n                is_distant_enough = True\n                for accepted_coord in accepted_minima_coords:\n                    if np.linalg.norm(minimum['coord'] - accepted_coord)  R_CLUSTER:\n                        is_distant_enough = False\n                        break\n                \n                if is_distant_enough:\n                    accepted_minima_coords.append(minimum['coord'])\n\n            case_results.append(accepted_minima_coords)\n\n        return case_results\n\n    # Process all test cases\n    all_results = [solve_case(case) for case in test_cases]\n\n    # Format the final output string\n    def format_point(p):\n        return f\"[{p[0]:.3f},{p[1]:.3f},{p[2]:.3f}]\"\n\n    def format_point_list(pl):\n        return f\"[{','.join(format_point(p) for p in pl)}]\"\n\n    def format_case_result(cr):\n        # cr is [D_points, A_points, H_points]\n        return f\"[{format_point_list(cr[0])},{format_point_list(cr[1])},{format_point_list(cr[2])}]\"\n\n    final_output_str = f\"[{','.join(format_case_result(r) for r in all_results)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "2440150"}, {"introduction": "如果我们没有受体结构，该怎么办？我们可以从已知的活性配体出发，假设它们共享一个共同的结合模式来构建模型。这通常需要比对多个独立的药效团以找到一个共识模型。这项练习 [@problem_id:2414196] 介绍了一种强大的迭代算法，用于对齐两组三维点集。通过找到最佳的刚体变换以叠加匹配的特征，我们可以创建一个合并的、更具普适性的药效团模型。掌握这项技术对于基于配体的药物设计至关重要，也有助于理解如何从少数已知例子推广到更广泛的化学空间。", "problem": "给定两个基于配体的药效团，每个药效团表示为一个有限的特征集合。每个特征是一个元组，由一个类别特征类型、一个三维坐标及其关联的容差半径组成。形式上，一个基于配体的药效团是一个集合 $F = \\{(t_i, \\mathbf{x}_i, r_i)\\}_{i=1}^{n}$，其中 $t_i$ 是从一个固定的有限词汇表中抽取的类别特征类型（例如，氢键受体、氢键供体、疏水性、芳香环、可电离正离子、可电离负离子），$\\mathbf{x}_i \\in \\mathbb{R}^3$ 是三维空间中的一个点，$r_i \\in \\mathbb{R}_{0}$ 是一个容差半径（所有长度单位均为埃）。我们假设两个药效团之间的刚体对齐是一个形如 $\\mathbf{x} \\mapsto R \\mathbf{x} + \\mathbf{t}$ 的变换，其中 $R \\in \\mathbb{R}^{3 \\times 3}$ 是一个 $\\det(R) = 1$ 的正交矩阵，$\\mathbf{t} \\in \\mathbb{R}^3$。当且仅当 $t_i = t_j$ 且 $\\|\\mathbf{x}_i - \\mathbf{y}_j\\|_2 \\le r_i + s_j + \\varepsilon$ 时，两个特征 $(t_i, \\mathbf{x}_i, r_i)$ 和 $(t_j, \\mathbf{y}_j, s_j)$ 被认为是一个匹配，其中 $\\varepsilon \\ge 0$ 是一个全局松弛参数。共识药效团由匹配对形成，每个匹配对创建一个共识特征。在此问题中，您只需要输出您的算法产生的匹配对数量（即共识特征的数量）。\n\n从以下基本原理出发：\n- $\\mathbb{R}^3$ 中的欧几里得范数，即 $\\|\\mathbf{x}\\|_2 = \\sqrt{x_1^2 + x_2^2 + x_3^2}$。\n- 刚体变换的定义，包括旋转 $R \\in \\mathrm{SO}(3)$ 和平移 $\\mathbf{t} \\in \\mathbb{R}^3$。\n- 两个配对点集之间的最小二乘最优刚体对齐可以通过最小化残差平方和来找到，并通过对协方差矩阵进行奇异值分解来求解（Kabsch 算法），该方法源于正交 Procrustes 方法。\n- 两个集合之间的一对一匹配是不相交对的选择；在满足阈值的边中按距离递增进行贪婪选择，可以得到在该约束下的一个最大匹配。\n\n设计并实现一个算法，通过以下步骤将两个输入的药效团合并为一个共识药效团：\n- 计算初始刚体对齐，步骤如下：计算两个药效团共有的特征类型集合。如果至少有 $2$ 个共有类型，则对每个共有类型，分别计算其在每个药效团中的质心，然后计算对齐这些按类型划分的质心的最小二乘最优刚体变换。否则，初始时使用单位变换。\n- 迭代优化对齐：给定当前变换，对第二个药效团进行变换，并构建所有潜在匹配的集合，这些匹配是类型相同且满足阈值 $\\|\\mathbf{x}_i - \\mathbf{y}_j\\|_2 \\le r_i + s_j + \\varepsilon$ 的特征对。按距离递增贪婪地选择一个一对一的匹配集（平局通过类型和索引确定性地打破）。使用 Kabsch 算法对匹配对的坐标（使用第二个药效团变换前的坐标）重新计算最优刚体变换，并进行迭代，直到匹配集不再变化或达到一个固定的较小迭代上限。\n- 对于每个测试用例，输出最终迭代产生的匹配对数量。输出是一个计数，不需要物理单位。\n\n测试套件。每个测试用例是一个三元组 $(P, Q, \\varepsilon)$，其中 $P$ 和 $Q$ 是药效团，以 $(\\text{类型}, \\mathbf{x}, r)$ 形式的特征列表给出，其中 $\\mathbf{x}$ 是一个以埃为单位的三维点，$r$ 是一个以埃为单位的半径。请使用以下五个测试用例：\n\n- 测试用例 $1$ (正常路径；多个共有类型和一个带小噪声的刚体变换，预期有多个匹配):\n  - $P_1 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.6), (\\text{HBD}, \\left(2, 0, 0\\right), 0.6), (\\text{HYD}, \\left(0, 2, 0\\right), 0.6)]$\n  - $Q_1 = [(\\text{HBA}, \\left(5.02, -3.01, 1.0\\right), 0.6), (\\text{HBD}, \\left(4.97, -1.0, 1.01\\right), 0.6), (\\text{HYD}, \\left(3.01, -2.98, 0.98\\right), 0.6)]$\n  - $\\varepsilon_1 = 0.2$\n- 测试用例 $2$ (部分重叠；一个药效团中缺少某些类型，预期部分但非全部匹配):\n  - $P_2 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5), (\\text{HBD}, \\left(2, 0, 0\\right), 0.5), (\\text{HYD}, \\left(0, 2, 0\\right), 0.7), (\\text{ARO}, \\left(1, 1, 0\\right), 0.8)]$\n  - $Q_2 = [(\\text{HBA}, \\left(1.01, 0.98, 0\\right), 0.5), (\\text{HBD}, \\left(-1.0, 1.03, 0\\right), 0.5)]$\n  - $\\varepsilon_2 = 0.2$\n- 测试用例 $3$ (无共有类型；预期无匹配):\n  - $P_3 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5), (\\text{HBD}, \\left(1, 0, 0\\right), 0.5)]$\n  - $Q_3 = [(\\text{HYD}, \\left(10, 10, 0\\right), 0.5), (\\text{ARO}, \\left(11, 10, 0\\right), 0.5)]$\n  - $\\varepsilon_3 = 0.2$\n- 测试用例 $4$ (边界条件；一个共有类型，距离恰好等于阈值，包含等号的不等式必须计为一个匹配):\n  - $P_4 = [(\\text{HBA}, \\left(0, 0, 0\\right), 0.5)]$\n  - $Q_4 = [(\\text{HBA}, \\left(1.0, 0, 0\\right), 0.4)]$\n  - $\\varepsilon_4 = 0.1$\n- 测试用例 $5$ (一对一约束；一个药效团中某类型特征的数量多于另一个；贪婪选择应选择最近的，并使其他特征不匹配):\n  - $P_5 = [(\\text{HYD}, \\left(0, 0, 0\\right), 0.5), (\\text{HYD}, \\left(0.6, 0, 0\\right), 0.5)]$\n  - $Q_5 = [(\\text{HYD}, \\left(0.2, 0, 0\\right), 0.5)]$\n  - $\\varepsilon_5 = 0.1$\n\n您的程序必须实现上述算法，并为每个测试用例计算最终迭代找到的匹配对数量。您的程序应产生一行输出，包含五个结果，格式为方括号内逗号分隔的列表（例如，$[a, b, c, d, e]$）。每个测试用例的最终答案要求为整数。不应打印任何其他文本。", "solution": "所提供的问题陈述是有效的。它在科学上基于计算结构生物学和生物信息学的原理，特别是在药效团建模领域。该问题是良构的，为对齐和合并两个药效团提供了一个清晰、确定性的算法。语言客观且无歧义。给定的数据和要求的变换在物理上和数学上都是合理的。\n\n任务是设计并实现一个算法，计算两个药效团 $P$ 和 $Q$ 之间匹配特征的数量。药效团定义为一个特征集合 $F = \\{(t_i, \\mathbf{x}_i, r_i)\\}_{i=1}^{n}$，其中 $t_i$ 是特征类型，$\\mathbf{x}_i \\in \\mathbb{R}^3$ 是其空间坐标，$r_i$ 是容差半径。该算法涉及对一个刚体对齐进行迭代优化，该对齐由一个旋转 $R \\in \\mathrm{SO}(3)$ 和一个平移 $\\mathbf{t} \\in \\mathbb{R}^3$ 组成，并应用于第二个药效团 $Q$。\n\n该方法论设计基于几个核心原理：\n\n1.  **叠加与对齐原理**：基本假设是，代表与同一靶点结合的配体的两个药效团，应能在三维空间中相互叠加。最优叠加是通过一个刚体变换 $\\mathbf{y} \\mapsto R\\mathbf{y} + \\mathbf{t}$ 来找到的，该变换最小化了相应特征之间的距离。问题指定使用 Kabsch 算法，该算法为两组配对点之间的最小二乘最优刚体变换提供了解析解。给定两组 $N$ 个对应点，由 $3 \\times N$ 矩阵 $P_{pts}$ 和 $Q_{pts}$ 表示，该算法首先通过减去它们各自的质心 $\\mathbf{p}_c$ 和 $\\mathbf{q}_c$ 来中心化这些点集：\n    $$P'_{pts} = P_{pts} - \\mathbf{p}_c$$\n    $$Q'_{pts} = Q_{pts} - \\mathbf{q}_c$$\n    协方差矩阵 $H$ 计算为 $H = Q'_{pts} (P'_{pts})^T$。对 $H$ 进行奇异值分解 (SVD)，得到 $H = U\\Sigma V^T$。然后最优旋转矩阵为 $R = VU^T$。如果 $\\det(R) = -1$，则应用一个特殊的校正以确保 $R$ 是一个纯旋转。随后，平移向量被计算为 $\\mathbf{t} = \\mathbf{p}_c - R\\mathbf{q}_c$。\n\n2.  **特征保守性原理**：一个有意义的对齐必须尊重特征的化学性质。因此，来自药效团 $P$ 的特征 $(t_i, \\mathbf{x}_i, r_i)$ 只能与来自药效团 $Q$ 的特征 $(t_j, \\mathbf{y}_j, s_j)$ 匹配，前提是它们的类型相同，即 $t_i = t_j$。\n\n3.  **迭代优化原理**：最优对齐取决于已知特征之间的正确对应关系，但建立对应关系又需要一个好的对齐。这个“先有鸡还是先有蛋”的问题通过一个迭代过程来解决：\n    a.  基于一个粗粒度的对应关系计算初始对齐：即共有特征类型的质心。如果共有的特征类型少于两个，则使用单位变换作为起点。\n    b.  给定当前对齐 $(R, \\mathbf{t})$，对药效团 $Q$ 的坐标进行变换。\n    c.  在 $P$ 和变换后的 $Q$ 之间建立一组新的一对一特征匹配。这通过首先识别所有满足类型相同条件 ($t_i = t_j$) 和距离阈值 $\\|\\mathbf{x}_i - (R\\mathbf{y}_j + \\mathbf{t})\\|_2 \\le r_i + s_j + \\varepsilon$ 的潜在配对来完成，其中 $\\varepsilon$ 是一个全局松弛参数。从这些潜在配对中，通过优先选择距离最小的配对，贪婪地选出一对一匹配。\n    d.  使用 Kabsch 算法对新匹配的特征对的原始坐标计算一个新的、改进的对齐 $(R', \\mathbf{t}')$。\n    e.  重复此过程，直到匹配对的集合在迭代之间不再变化（表示收敛），或达到固定的迭代次数限制。\n\n4.  **简约性原理（贪婪选择）**：寻找全局最优的一对一匹配是一个复杂的分配问题。该算法采用了一种贪婪启发式方法，该方法在计算上是高效的，并且在实践中是有效的。通过按距离递增排序所有潜在匹配，并按顺序选择它们，同时遵守一对一约束，该算法优先考虑最近、最可靠的配对。这个确定性过程，加上指定的平局打破规则，确保了解决方案的唯一性。\n\n最终输出是收敛时匹配集的基数，代表了共识药效团的大小。实现将精确遵循这些步骤来解决所提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom collections import namedtuple\n\n# Use a namedtuple for features for clarity.\nFeature = namedtuple('Feature', ['type', 'coord', 'radius'])\n# Mapping for feature types to ensure deterministic sorting for tie-breaking.\nTYPE_MAP = {'HBA': 0, 'HBD': 1, 'HYD': 2, 'ARO': 3, 'PI': 4, 'NI': 5}\n# Maximum number of iterations for the refinement loop.\nMAX_ITERATIONS = 20\n\ndef kabsch_algorithm(P, Q):\n    \"\"\"\n    Computes the optimal rigid transformation (rotation R, translation t)\n    to align point set Q to point set P using the Kabsch algorithm.\n    Points are represented as column vectors.\n    :param P: A 3xN numpy array of N points in the reference set.\n    :param Q: A 3xN numpy array of N points in the mobile set.\n    :return: A tuple (R, t) where R is a 3x3 rotation matrix and t is a 3x1\n             translation vector. The transformation is: p_new = R @ p_old + t.\n    \"\"\"\n    if P.shape[1] == 0:\n        return np.identity(3), np.zeros((3, 1))\n\n    # 1. Center the point sets\n    p_cen = np.mean(P, axis=1, keepdims=True)\n    q_cen = np.mean(Q, axis=1, keepdims=True)\n    P_centered = P - p_cen\n    Q_centered = Q - q_cen\n\n    # 2. Compute covariance matrix\n    H = Q_centered @ P_centered.T\n\n    # 3. SVD\n    U, _, Vt = np.linalg.svd(H)\n\n    # 4. Compute rotation matrix\n    R = Vt.T @ U.T\n\n    # 5. Handle reflection case\n    if np.linalg.det(R)  0:\n        Vt[2, :] *= -1\n        R = Vt.T @ U.T\n\n    # 6. Compute translation vector\n    t = p_cen - R @ q_cen\n    \n    return R, t\n\ndef solve_pharmacophore_alignment(p_pharma, q_pharma, epsilon):\n    \"\"\"\n    Merges two pharmacophores and returns the number of matched features.\n    \"\"\"\n    # 1. Initial Alignment\n    p_types = {feat.type: [] for feat in p_pharma}\n    q_types = {feat.type: [] for feat in q_pharma}\n    for feat in p_pharma:\n        p_types[feat.type].append(feat.coord)\n    for feat in q_pharma:\n        q_types[feat.type].append(feat.coord)\n    \n    shared_types = sorted(list(set(p_types.keys()).intersection(set(q_types.keys()))))\n    \n    R = np.identity(3)\n    t = np.zeros((3, 1))\n\n    if len(shared_types) >= 2:\n        p_centroids = np.array([np.mean(p_types[stype], axis=0) for stype in shared_types]).T\n        q_centroids = np.array([np.mean(q_types[stype], axis=0) for stype in shared_types]).T\n        R, t = kabsch_algorithm(p_centroids, q_centroids)\n\n    # 2. Iterative Refinement\n    last_matched_indices = None\n    \n    for _ in range(MAX_ITERATIONS):\n        q_pharma_transformed = []\n        for feat in q_pharma:\n            coord_col = feat.coord.reshape(3, 1)\n            new_coord = (R @ coord_col + t).reshape(3)\n            q_pharma_transformed.append(Feature(feat.type, new_coord, feat.radius))\n            \n        potential_matches = []\n        for p_idx, p_feat in enumerate(p_pharma):\n            for q_idx, q_feat_trans in enumerate(q_pharma_transformed):\n                if p_feat.type == q_feat_trans.type:\n                    dist = np.linalg.norm(p_feat.coord - q_feat_trans.coord)\n                    threshold = p_feat.radius + q_feat_trans.radius + epsilon\n                    if dist = threshold:\n                        potential_matches.append((dist, TYPE_MAP[p_feat.type], p_idx, q_idx))\n        \n        potential_matches.sort()\n        \n        current_matched_indices = []\n        used_p, used_q = set(), set()\n        for _, _, p_idx, q_idx in potential_matches:\n            if p_idx not in used_p and q_idx not in used_q:\n                current_matched_indices.append((p_idx, q_idx))\n                used_p.add(p_idx)\n                used_q.add(q_idx)\n        \n        current_matched_indices.sort()\n        \n        if current_matched_indices == last_matched_indices:\n            break\n        \n        last_matched_indices = current_matched_indices\n        \n        if not current_matched_indices:\n            R, t = np.identity(3), np.zeros((3, 1))\n            continue\n            \n        p_matched_coords = np.array([p_pharma[p_idx].coord for p_idx, _ in current_matched_indices]).T\n        q_matched_coords = np.array([q_pharma[q_idx].coord for _, q_idx in current_matched_indices]).T\n        \n        R, t = kabsch_algorithm(p_matched_coords, q_matched_coords)\n        \n    return len(last_matched_indices) if last_matched_indices is not None else 0\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        ([('HBA', (0, 0, 0), 0.6), ('HBD', (2, 0, 0), 0.6), ('HYD', (0, 2, 0), 0.6)],\n         [('HBA', (5.02, -3.01, 1.0), 0.6), ('HBD', (4.97, -1.0, 1.01), 0.6), ('HYD', (3.01, -2.98, 0.98), 0.6)],\n         0.2),\n        # Test case 2\n        ([('HBA', (0, 0, 0), 0.5), ('HBD', (2, 0, 0), 0.5), ('HYD', (0, 2, 0), 0.7), ('ARO', (1, 1, 0), 0.8)],\n         [('HBA', (1.01, 0.98, 0), 0.5), ('HBD', (-1.0, 1.03, 0), 0.5)],\n         0.2),\n        # Test case 3\n        ([('HBA', (0, 0, 0), 0.5), ('HBD', (1, 0, 0), 0.5)],\n         [('HYD', (10, 10, 0), 0.5), ('ARO', (11, 10, 0), 0.5)],\n         0.2),\n        # Test case 4\n        ([('HBA', (0, 0, 0), 0.5)],\n         [('HBA', (1.0, 0, 0), 0.4)],\n         0.1),\n        # Test case 5\n        ([('HYD', (0, 0, 0), 0.5), ('HYD', (0.6, 0, 0), 0.5)],\n         [('HYD', (0.2, 0, 0), 0.5)],\n         0.1)\n    ]\n\n    results = []\n    for p_raw, q_raw, epsilon in test_cases:\n        p_pharma = [Feature(t, np.array(x), r) for t, x, r in p_raw]\n        q_pharma = [Feature(t, np.array(x), r) for t, x, r in q_raw]\n        num_matches = solve_pharmacophore_alignment(p_pharma, q_pharma, epsilon)\n        results.append(num_matches)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2414196"}, {"introduction": "当一个药效团模型建立后，一个关键问题随之而来：模型中的所有特征对于活性都同等重要吗？一个简单的“有或无”模型可能过于僵化。这项练习 [@problem_id:2414221] 展示了如何利用活性数据（一组已知的活性和非活性化合物）来量化每个特征的重要性。通过应用贝叶斯统计框架，我们可以计算出权重，这些权重反映了每个特征在区分活性与非活性化合物方面的贡献程度。这种方法能够创建更精细、预测能力更强的药效团模型，从简单的特征清单发展为能够更好地对潜在新药进行排序的评分假说。", "problem": "小分子的药效团模型由一组固定的二元特征表示，这些特征由 $j \\in \\{1,\\dots,d\\}$ 索引，每个特征编码了配体中某个药效团元素（例如，某个位置的氢键供体）的存在与否。一个数据集包含被标记为活性或非活性的配体。对于每个特征 $j$，令 $x_{j} \\in \\{0,1\\}$ 表示配体中是否存在该特征，令 $y \\in \\{0,1\\}$ 表示类别标签，其中 $y=1$ 表示活性，$y=0$ 表示非活性。假设以下概率模型：在给定 $y=c \\in \\{0,1\\}$ 的条件下，对于每个特征 $j$，$x_{j} \\mid y=c \\sim \\mathrm{Bernoulli}(\\theta^{(c)}_{j})$，其中参数 $\\theta^{(c)}_{j}$ 未知，并且对所有 $j$ 和 $c$ 都是独立的。假设独立的 Beta 先验 $\\theta^{(c)}_{j} \\sim \\mathrm{Beta}(\\alpha,\\beta)$，其固定的超参数 $\\alpha0$ 和 $\\beta0$ 对所有 $j$ 和 $c$ 共享。对于每个特征 $j$，类别 $c$ 的训练数据可概括为总共有 $N^{(c)}$ 个配体，其中有 $n^{(c)}_{j}$ 个配体的 $x_{j}=1$。\n\n定义特征 $j$ 的重要性权重为\n$$\nw_{j} \\equiv \\log\\left(\\frac{\\mathrm{odds}\\!\\left(\\mathbb{E}[\\theta^{(1)}_{j} \\mid \\text{data}]\\right)}{\\mathrm{odds}\\!\\left(\\mathbb{E}[\\theta^{(0)}_{j} \\mid \\text{data}]\\right)}\\right),\n$$\n其中，对于任意 $p \\in (0,1)$，$\\mathrm{odds}(p) \\equiv \\dfrac{p}{1-p}$，且 $\\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}]$ 表示在上述模型和先验下，给定汇总计数时 $\\theta^{(c)}_{j}$ 的后验均值。所有对数均为自然对数。一个测试用例的输出是按特征顺序排列的列表 $[w_{1},\\dots,w_{d}]$。\n\n为以下每个测试用例计算 $[w_{1},\\dots,w_{d}]$。对于每个用例，您将获得活性样本数量 $N^{(1)}$、非活性样本数量 $N^{(0)}$、活性样本计数值向量 $[n^{(1)}_{1},\\dots,n^{(1)}_{d}]$、非活性样本计数值向量 $[n^{(0)}_{1},\\dots,n^{(0)}_{d}]$，以及共享的 Beta 先验超参数 $(\\alpha,\\beta)$。\n\n测试套件：\n- 用例 1：$N^{(1)}=10$，$N^{(0)}=12$，$[n^{(1)}_{j}]_{j=1}^{4} = [6,2,8,0]$，$[n^{(0)}_{j}]_{j=1}^{4} = [1,5,6,0]$，$(\\alpha,\\beta)=(0.5,0.5)$。\n- 用例 2：$N^{(1)}=3$，$N^{(0)}=20$，$[n^{(1)}_{j}]_{j=1}^{3} = [0,3,0]$，$[n^{(0)}_{j}]_{j=1}^{3} = [10,0,1]$，$(\\alpha,\\beta)=(0.5,0.5)$。\n- 用例 3：$N^{(1)}=50$，$N^{(0)}=50$，$[n^{(1)}_{j}]_{j=1}^{4} = [25,50,0,1]$，$[n^{(0)}_{j}]_{j=1}^{4} = [25,50,0,2]$，$(\\alpha,\\beta)=(1.0,1.0)$。\n- 用例 4：$N^{(1)}=1$，$N^{(0)}=1$，$[n^{(1)}_{j}]_{j=1}^{2} = [1,0]$，$[n^{(0)}_{j}]_{j=1}^{2} = [0,1]$，$(\\alpha,\\beta)=(2.0,3.0)$。\n\n答案规范：\n- 对于每个测试用例，按照上述定义以自然对数为单位计算向量 $[w_{1},\\dots,w_{d}]$。\n- 返回的每个 $w_{j}$ 值需四舍五入到 $6$ 位小数。\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个元素是对应测试用例的、由方括号括起来的逗号分隔列表。例如，整体结构必须是 $[[r_{1,1},\\dots,r_{1,d_{1}}],[r_{2,1},\\dots,r_{2,d_{2}}],\\dots]$，不含空格，其中 $r_{k,\\ell}$ 表示用例 $k$ 中特征 $\\ell$ 的四舍五入值。", "solution": "问题陈述已经过验证，被认为是可接受的。它提出了一个应用于计算生物学（特别是在药效团分析背景下）的贝叶斯统计建模中的标准良构问题。所有必要信息均已提供，前提科学合理，不存在矛盾或歧义。我们可以开始求解。\n\n该问题要求计算特征重要性权重 $w_{j}$，其定义为特征在活性分子与非活性分子中出现的后验均值概率的对数优势比。该模型是一个朴素贝叶斯分类器，其特征服从伯努利分布，伯努利参数的先验服从 Beta 分布。\n\n让我们首先对单个参数 $\\theta^{(c)}_{j}$ 进行贝叶斯推断的形式化。该参数表示类别 $c \\in \\{0, 1\\}$ 的配体中特征 $j$ 存在（$x_j=1$）的概率。\n\n参数 $\\theta^{(c)}_{j}$ 的先验分布是超参数为 $\\alpha$ 和 $\\beta$ 的 Beta 分布：\n$$\n\\theta^{(c)}_{j} \\sim \\mathrm{Beta}(\\alpha, \\beta)\n$$\n其概率密度函数 (PDF) 正比于：\n$$\np(\\theta^{(c)}_{j}) \\propto (\\theta^{(c)}_{j})^{\\alpha-1} (1 - \\theta^{(c)}_{j})^{\\beta-1}\n$$\n\n特征 $j$ 和类别 $c$ 的数据包含 $N^{(c)}$ 个配体，其中 $n^{(c)}_{j}$ 个配体具有该特征（$x_j=1$），$N^{(c)} - n^{(c)}_{j}$ 个配体不具有该特征（$x_j=0$）。假设配体是独立同分布的，在 $N^{(c)}$ 次试验中观察到 $n^{(c)}_{j}$ 次成功的似然遵循二项分布。$\\theta^{(c)}_{j}$ 的似然函数为：\n$$\nL(\\text{data} \\mid \\theta^{(c)}_{j}) = P(n^{(c)}_{j} \\mid N^{(c)}, \\theta^{(c)}_{j}) \\propto (\\theta^{(c)}_{j})^{n^{(c)}_{j}} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j}}\n$$\n\n根据贝叶斯定理，$\\theta^{(c)}_{j}$ 的后验分布正比于先验与似然的乘积：\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto p(\\theta^{(c)}_{j}) \\cdot L(\\text{data} \\mid \\theta^{(c)}_{j})\n$$\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto \\left((\\theta^{(c)}_{j})^{\\alpha-1} (1 - \\theta^{(c)}_{j})^{\\beta-1}\\right) \\cdot \\left((\\theta^{(c)}_{j})^{n^{(c)}_{j}} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j}}\\right)\n$$\n合并各项可得：\n$$\np(\\theta^{(c)}_{j} \\mid \\text{data}) \\propto (\\theta^{(c)}_{j})^{n^{(c)}_{j} + \\alpha - 1} (1 - \\theta^{(c)}_{j})^{N^{(c)} - n^{(c)}_{j} + \\beta - 1}\n$$\n这个表达式是 Beta 分布的核。这证明了 Beta 先验与伯努利/二项似然的共轭性。因此，后验分布为：\n$$\n\\theta^{(c)}_{j} \\mid \\text{data} \\sim \\mathrm{Beta}(\\alpha', \\beta')\n$$\n其中后验超参数 $\\alpha'$ 和 $\\beta'$ 为：\n$$\n\\alpha' = n^{(c)}_{j} + \\alpha\n$$\n$$\n\\beta' = N^{(c)} - n^{(c)}_{j} + \\beta\n$$\n\n问题要求后验均值 $\\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}]$。对于一个随机变量 $X \\sim \\mathrm{Beta}(a,b)$，其期望为 $\\mathbb{E}[X] = \\frac{a}{a+b}$。将此应用于我们的后验分布，我们得到 $\\theta^{(c)}_{j}$ 的后验均值：\n$$\n\\hat{\\theta}^{(c)}_{j} \\equiv \\mathbb{E}[\\theta^{(c)}_{j} \\mid \\text{data}] = \\frac{\\alpha'}{\\alpha' + \\beta'} = \\frac{n^{(c)}_{j} + \\alpha}{(n^{(c)}_{j} + \\alpha) + (N^{(c)} - n^{(c)}_{j} + \\beta)} = \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta}\n$$\n\n接下来，我们计算这个后验均值概率的优势。优势函数定义为 $\\mathrm{odds}(p) = \\frac{p}{1-p}$。对于 $\\hat{\\theta}^{(c)}_{j}$，我们有：\n$$\n1 - \\hat{\\theta}^{(c)}_{j} = 1 - \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta} = \\frac{(N^{(c)} + \\alpha + \\beta) - (n^{(c)}_{j} + \\alpha)}{N^{(c)} + \\alpha + \\beta} = \\frac{N^{(c)} - n^{(c)}_{j} + \\beta}{N^{(c)} + \\alpha + \\beta}\n$$\n因此，优势为：\n$$\n\\mathrm{odds}(\\hat{\\theta}^{(c)}_{j}) = \\frac{\\hat{\\theta}^{(c)}_{j}}{1 - \\hat{\\theta}^{(c)}_{j}} = \\frac{\\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} + \\alpha + \\beta}}{\\frac{N^{(c)} - n^{(c)}_{j} + \\beta}{N^{(c)} + \\alpha + \\beta}} = \\frac{n^{(c)}_{j} + \\alpha}{N^{(c)} - n^{(c)}_{j} + \\beta}\n$$\n\n最后，我们将此表达式代入重要性权重 $w_{j}$ 的定义中：\n$$\nw_{j} = \\log\\left(\\frac{\\mathrm{odds}(\\hat{\\theta}^{(1)}_{j})}{\\mathrm{odds}(\\hat{\\theta}^{(0)}_{j})}\\right) = \\log\\left( \\frac{\\frac{n^{(1)}_{j} + \\alpha}{N^{(1)} - n^{(1)}_{j} + \\beta}}{\\frac{n^{(0)}_{j} + \\alpha}{N^{(0)} - n^{(0)}_{j} + \\beta}} \\right)\n$$\n利用对数的性质 $\\log(\\frac{A}{B}) = \\log(A) - \\log(B)$，这可以写成：\n$$\nw_{j} = \\log\\left(\\frac{n^{(1)}_{j} + \\alpha}{N^{(1)} - n^{(1)}_{j} + \\beta}\\right) - \\log\\left(\\frac{n^{(0)}_{j} + \\alpha}{N^{(0)} - n^{(0)}_{j} + \\beta}\\right)\n$$\n这是计算每个特征 $j$ 权重的最终计算公式。现在将此公式应用于每个给定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pharmacophore feature weighting problem for the given test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'N1': 10, 'N0': 12, 'n1': np.array([6, 2, 8, 0]), 'n0': np.array([1, 5, 6, 0]), 'alpha': 0.5, 'beta': 0.5},\n        {'N1': 3, 'N0': 20, 'n1': np.array([0, 3, 0]), 'n0': np.array([10, 0, 1]), 'alpha': 0.5, 'beta': 0.5},\n        {'N1': 50, 'N0': 50, 'n1': np.array([25, 50, 0, 1]), 'n0': np.array([25, 50, 0, 2]), 'alpha': 1.0, 'beta': 1.0},\n        {'N1': 1, 'N0': 1, 'n1': np.array([1, 0]), 'n0': np.array([0, 1]), 'alpha': 2.0, 'beta': 3.0}\n    ]\n\n    # A helper function to compute weights for a single case.\n    def compute_weights(N1, N0, n1_vec, n0_vec, alpha, beta):\n        \"\"\"\n        Computes the importance weights w_j for a single test case.\n        \n        The formula for w_j is:\n        w_j = log(odds(E[theta_j^1|data])) - log(odds(E[theta_j^0|data]))\n            = log((n1_j + alpha) / (N1 - n1_j + beta)) - log((n0_j + alpha) / (N0 - n0_j + beta))\n        \n        Args:\n            N1 (int): Number of active ligands.\n            N0 (int): Number of inactive ligands.\n            n1_vec (np.ndarray): Counts of feature presence for active ligands.\n            n0_vec (np.ndarray): Counts of feature presence for inactive ligands.\n            alpha (float): Beta prior hyperparameter.\n            beta (float): Beta prior hyperparameter.\n        \n        Returns:\n            np.ndarray: An array of computed weights w_j.\n        \"\"\"\n        # Posterior odds for the active class (c=1)\n        odds1 = (n1_vec + alpha) / (N1 - n1_vec + beta)\n        \n        # Posterior odds for the inactive class (c=0)\n        odds0 = (n0_vec + alpha) / (N0 - n0_vec + beta)\n        \n        # Compute the log-odds ratio, which is the feature weight w_j\n        weights = np.log(odds1) - np.log(odds0)\n        \n        return weights\n\n    all_results_str = []\n    for case in test_cases:\n        # Extract parameters for the current case\n        N1 = case['N1']\n        N0 = case['N0']\n        n1_vec = case['n1']\n        n0_vec = case['n0']\n        alpha = case['alpha']\n        beta = case['beta']\n\n        # Calculate the weights for the current case\n        weights = compute_weights(N1, N0, n1_vec, n0_vec, alpha, beta)\n        \n        # Format the results for the current case to 6 decimal places\n        case_result_str = f\"[{','.join([f'{w:.6f}' for w in weights])}]\"\n        \n        all_results_str.append(case_result_str)\n\n    # Combine all case results into the final specified format\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Print the final result string\n    print(final_output)\n\nsolve()\n```", "id": "2414221"}]}