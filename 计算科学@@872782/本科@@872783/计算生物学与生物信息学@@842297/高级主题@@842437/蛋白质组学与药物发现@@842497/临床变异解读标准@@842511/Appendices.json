{"hands_on_practices": [{"introduction": "临床变异解读的ACMG/AMP指南本质上是一套复杂的逻辑规则。为了将这些定性指南应用于计算环境中，我们首先需要将其形式化。本练习挑战您将一部分致病性证据组合规则转化为一个决策逻辑模型，并解决一个优化问题：以最少的证据数量达到“致病性”分类。这项实践旨在锻炼您将专家知识转化为算法，并运用计算思维解决实际生物信息学问题的能力。[@problem_id:2378889]", "problem": "您的任务是将美国医学遗传学与基因组学学会 (ACMG) 临床变异解读指南的一个子集形式化为基于证据类别的决策逻辑，并计算支持“致病性”分类所需的最少证据编码数量。对于此问题，您将只考虑用于支持致病性的证据类别及其强度等级：致病性-极强 (PVS)、致病性-强 (PS)、致病性-中等 (PM) 和致病性-支持 (PP)。设 PVS、PS、PM 和 PP 证据编码的可用数量分别由非负整数 $V_{\\max}$、$S_{\\max}$、$M_{\\max}$ 和 $P_{\\max}$ 限定。下方的决策逻辑基于 2015 年 ACMG/AMP 框架，规定了“致病性”分类的充分组合，并限定于以下充分性条件。\n\n如果一个选定的证据编码多重集 $(v, s, m, p)$（其中 $0 \\le v \\le V_{\\max}$, $0 \\le s \\le S_{\\max}$, $0 \\le m \\le M_{\\max}$ 且 $0 \\le p \\le P_{\\max}$）满足以下任一组合，则该变异被视为“致病性”：\n- 条件 P1: $v >= 1$ 且 $s >= 1$。\n- 条件 P2: $v >= 1$ 且 $m >= 2$。\n- 条件 P3: $v >= 1$ 且 $m >= 1$ 且 $p >= 1$。\n- 条件 P4: $v >= 1$ 且 $p >= 2$。\n- 条件 P5: $s >= 2$。\n- 条件 P6: $s >= 1$ 且 $m >= 3$。\n- 条件 P7: $s >= 1$ 且 $m >= 2$ 且 $p >= 2$。\n- 条件 P8: $s >= 1$ 且 $m >= 1$ 且 $p >= 4$。\n\n您的任务是，在遵守可用数量上限 $(V_{\\max}, S_{\\max}, M_{\\max}, P_{\\max})$ 的前提下，为每个测试用例确定满足 P1-P8 中至少一个条件的最小总证据编码数量 $T = v + s + m + p$。如果在给定的可用数量上限下，没有任何组合能满足 P1-P8 中的任何一个条件，则返回 $-1$。\n\n建模假设：\n- 每个单独的证据编码，无论其类别如何，对总数 $T$ 的贡献成本均为 $1$。\n- 仅使用上述充分性条件 P1-P8 来确定“致病性”分类。\n- 目标是在满足约束条件的情况下最小化 $T$。\n\n测试套件：\n对于以下每个测试用例，计算最小的 $T$ 值，如果不可能，则为 $-1$。每个测试用例以四元组 $\\left(V_{\\max}, S_{\\max}, M_{\\max}, P_{\\max}\\right)$ 的形式给出。\n\n1. $\\left(0, 2, 0, 0\\right)$\n2. $\\left(1, 1, 0, 0\\right)$\n3. $\\left(1, 0, 0, 3\\right)$\n4. $\\left(0, 1, 3, 0\\right)$\n5. $\\left(0, 0, 5, 10\\right)$\n6. $\\left(1, 0, 1, 1\\right)$\n7. $\\left(1, 1, 5, 5\\right)$\n8. $\\left(0, 1, 1, 4\\right)$\n9. $\\left(0, 1, 2, 2\\right)$\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，顺序与上述测试套件相同。例如，格式必须类似于“[r1,r2,r3,...,r9]”，其中每个 $r_i$ 是测试用例 $i$ 的最小 $T$ 值的整数，或者如果在给定限制下无法实现“致病性”分类，则为 $-1$。", "solution": "该问题要求根据 ACMG/AMP 指南的一个指定子集，确定将一个遗传变异分类为“致病性”所需证据编码的最小总数。这可以被形式化为一个离散优化问题。\n\n系统的状态由一个证据编码的多重集定义，表示为非负整数四元组 $(v, s, m, p)$，其中 $v$ 是致病性-极强 (PVS) 编码的数量， $s$ 是致病性-强 (PS) 编码的数量， $m$ 是致病性-中等 (PM) 编码的数量， $p$ 是致病性-支持 (PP) 编码的数量。\n\n目标是最小化编码总数，由以下线性目标函数给出：\n$$T = v + s + m + p$$\n\n此最小化过程受两组约束条件的限制。首先，每种类型编码的可用数量是有限的：\n$$0 \\le v \\le V_{\\max}$$\n$$0 \\le s \\le S_{\\max}$$\n$$0 \\le m \\le M_{\\max}$$\n$$0 \\le p \\le P_{\\max}$$\n其中 $(V_{\\max}, S_{\\max}, M_{\\max}, P_{\\max})$ 是特定测试用例的给定可用数量。\n\n其次，要做出“致病性”分类，必须满足 P1 到 P8 这八个逻辑条件中的至少一个。这些条件表示为一个逻辑析取：\n$$P_1 \\lor P_2 \\lor P_3 \\lor P_4 \\lor P_5 \\lor P_6 \\lor P_7 \\lor P_8$$\n每个条件 $P_i$ 是关于数量 $(v, s, m, p)$ 的不等式的合取。\n\n为了最小化总成本 $T$，我们必须选择尽可能小的 $v, s, m, p$ 值。这意味着，对于我们旨在满足的任何给定条件 $P_i$，我们应该恰好使用该条件不等式所要求的最小数量的编码，而对于条件中未指定的任何其他类别，则使用零。\n\n求解方法是独立评估八个条件中的每一个。对于每个条件，我们确定所需的最小编码集及其对应的总成本 $T$。然后我们检查这个最小集在给定的可用数量上限 $(V_{\\max}, S_{\\max}, M_{\\max}, P_{\\max})$ 下是否被允许。\n\n让我们分析每个条件：\n1.  条件 P1: $v \\ge 1$ 且 $s \\ge 1$。所需最小编码：$(v, s, m, p) = (1, 1, 0, 0)$。成本为 $T_{P1} = 1 + 1 + 0 + 0 = 2$。如果 $V_{\\max} \\ge 1$ 且 $S_{\\max} \\ge 1$ 则可实现。\n2.  条件 P2: $v \\ge 1$ 且 $m \\ge 2$。所需最小编码：$(v, s, m, p) = (1, 0, 2, 0)$。成本为 $T_{P2} = 1 + 0 + 2 + 0 = 3$。如果 $V_{\\max} \\ge 1$ 且 $M_{\\max} \\ge 2$ 则可实现。\n3.  条件 P3: $v \\ge 1$ 且 $m \\ge 1$ 且 $p \\ge 1$。所需最小编码：$(v, s, m, p) = (1, 0, 1, 1)$。成本为 $T_{P3} = 1 + 0 + 1 + 1 = 3$。如果 $V_{\\max} \\ge 1$，$M_{\\max} \\ge 1$ 且 $P_{\\max} \\ge 1$ 则可实现。\n4.  条件 P4: $v \\ge 1$ 且 $p \\ge 2$。所需最小编码：$(v, s, m, p) = (1, 0, 0, 2)$。成本为 $T_{P4} = 1 + 0 + 0 + 2 = 3$。如果 $V_{\\max} \\ge 1$ 且 $P_{\\max} \\ge 2$ 则可实现。\n5.  条件 P5: $s \\ge 2$。所需最小编码：$(v, s, m, p) = (0, 2, 0, 0)$。成本为 $T_{P5} = 0 + 2 + 0 + 0 = 2$。如果 $S_{\\max} \\ge 2$ 则可实现。\n6.  条件 P6: $s \\ge 1$ 且 $m \\ge 3$。所需最小编码：$(v, s, m, p) = (0, 1, 3, 0)$。成本为 $T_{P6} = 0 + 1 + 3 + 0 = 4$。如果 $S_{\\max} \\ge 1$ 且 $M_{\\max} \\ge 3$ 则可实现。\n7.  条件 P7: $s \\ge 1$ 且 $m \\ge 2$ 且 $p \\ge 2$。所需最小编码：$(v, s, m, p) = (0, 1, 2, 2)$。成本为 $T_{P7} = 0 + 1 + 2 + 2 = 5$。如果 $S_{\\max} \\ge 1$，$M_{\\max} \\ge 2$ 且 $P_{\\max} \\ge 2$ 则可实现。\n8.  条件 P8: $s \\ge 1$ 且 $m \\ge 1$ 且 $p \\ge 4$。所需最小编码：$(v, s, m, p) = (0, 1, 1, 4)$。成本为 $T_{P8} = 0 + 1 + 1 + 4 = 6$。如果 $S_{\\max} \\ge 1$，$M_{\\max} \\ge 1$ 且 $P_{\\max} \\ge 4$ 则可实现。\n\n对于每个测试用例 $(V_{\\max}, S_{\\max}, M_{\\max}, P_{\\max})$，我们构建一个可实现成本的集合 $\\mathcal{T}_{\\text{achievable}}$，当且仅当其对应的条件在给定限制下可以满足时，才将 $T_{P_i}$ 包含在内。该测试用例的最终答案是此集合中的最小值：\n$$T_{\\min} = \\min(\\mathcal{T}_{\\text{achievable}})$$\n如果集合 $\\mathcal{T}_{\\text{achievable}}$ 为空，则意味着没有条件可以被满足，问题是不可行的。在这种情况下，结果被定义为 $-1$。这构成了解决该问题的完整算法。该算法通过遍历测试套件并将此逻辑应用于每个案例来实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the problem for a predefined test suite of ACMG evidence code bounds.\n    \"\"\"\n\n    # Each test case is a tuple (V_max, S_max, M_max, P_max).\n    test_cases = [\n        (0, 2, 0, 0),\n        (1, 1, 0, 0),\n        (1, 0, 0, 3),\n        (0, 1, 3, 0),\n        (0, 0, 5, 10),\n        (1, 0, 1, 1),\n        (1, 1, 5, 5),\n        (0, 1, 1, 4),\n        (0, 1, 2, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = _find_minimal_evidence_count(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _find_minimal_evidence_count(bounds):\n    \"\"\"\n    Calculates the minimal total number of evidence codes required to satisfy\n    at least one pathogenic condition, given the availability bounds.\n\n    Args:\n        bounds (tuple): A tuple of four integers (V_max, S_max, M_max, P_max)\n                        representing the maximum available counts for each\n                        evidence category.\n\n    Returns:\n        int: The minimal total number of codes, or -1 if no condition can be met.\n    \"\"\"\n    v_max, s_max, m_max, p_max = bounds\n    possible_costs = []\n\n    # The problem defines the objective as minimizing T = v + s + m + p.\n    # To do so, for each condition, we use the exact minimum number of codes\n    # required by that condition.\n\n    # Condition P1: v >= 1 and s >= 1. Cost (1+1=2)\n    if v_max >= 1 and s_max >= 1:\n        possible_costs.append(2)\n\n    # Condition P2: v >= 1 and m >= 2. Cost (1+2=3)\n    if v_max >= 1 and m_max >= 2:\n        possible_costs.append(3)\n\n    # Condition P3: v >= 1 and m >= 1 and p >= 1. Cost (1+1+1=3)\n    if v_max >= 1 and m_max >= 1 and p_max >= 1:\n        possible_costs.append(3)\n\n    # Condition P4: v >= 1 and p >= 2. Cost (1+2=3)\n    if v_max >= 1 and p_max >= 2:\n        possible_costs.append(3)\n\n    # Condition P5: s >= 2. Cost (2)\n    if s_max >= 2:\n        possible_costs.append(2)\n\n    # Condition P6: s >= 1 and m >= 3. Cost (1+3=4)\n    if s_max >= 1 and m_max >= 3:\n        possible_costs.append(4)\n\n    # Condition P7: s >= 1 and m >= 2 and p >= 2. Cost (1+2+2=5)\n    if s_max >= 1 and m_max >= 2 and p_max >= 2:\n        possible_costs.append(5)\n\n    # Condition P8: s >= 1 and m >= 1 and p >= 4. Cost (1+1+4=6)\n    if s_max >= 1 and m_max >= 1 and p_max >= 4:\n        possible_costs.append(6)\n\n    if not possible_costs:\n        return -1\n    else:\n        return min(possible_costs)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378889"}, {"introduction": "机械地应用指南规则有时会产生误导，尤其是在未考虑生物学背景时。例如，ACMG的BA1规则旨在将常见变异归类为良性，但对于某些隐性遗传病，致病等位基因的携带者频率可能相对较高。本练习要求您运用群体遗传学原理，建立一个数学模型来计算与致病性相容的最大等位基因频率，从而识别BA1规则可能被不当应用的情形。这项实践将加深您对模型驱动的批判性思维在变异解读中重要性的理解。[@problem_id:2378900]", "problem": "要求您形式化描述美国医学遗传学与基因组学学会 (ACMG) 证据代码 BA1（“常见变异”良性规则）的应用在何种情况下可能对临床变异解读产生误导。考虑一个双等位基因座，其群体等位基因频率为 $f \\in [0,1]$。一个实验室使用固定的 BA1 决策阈值 $\\tau \\in (0,1)$：当 $f \\ge \\tau$ 时，将应用 BA1。对于一个特定的孟德尔疾病，给定以下参数：疾病患病率 $p \\in (0,1)$，外显率 $r \\in (0,1]$，基因水平贡献度 $h \\in (0,1]$（所有病例中可归因于该基因的比例），以及变异的等位基因贡献度上限 $a \\in (0,1]$（该基因的病例中可归因于此单一变异的最大比例）。遗传模式 $m$ 为常染色体隐性 (AR) 或常染色体显性 (AD)。假设满足哈代-温伯格平衡 (HWE)，对 AD 模型使用稀有等位基因近似，并且可归因于该变异的病例比例等于乘积 $p \\cdot h \\cdot a$。\n\n在所提供的模型下，将“与致病性兼容的最大等位基因频率” $q_{\\max}(m)$ 定义为群体等位基因频率 $q$ 的最大值，使得由该变异引起的预期患者频率不超过该变异可归因的疾病负担。具体来说，在常染色体隐性 (AR) 模型下，患者主要来自纯合子，其在 HWE 下的频率为 $q^2$，外显率 $r$ 对观察到的疾病进行缩放；在常染色体显性 (AD) 模型和稀有等位基因近似下，患者主要来自杂合子，其预期频率为 $2q$，外显率 $r$ 对观察到的疾病进行缩放。利用这些主导关系，通过将模型下变异的预期贡献等同于 $p \\cdot h \\cdot a$ 来获得解 $q_{\\max}(m)$。\n\n您的任务是确定在每个给定案例中，BA1 是否“可能具有误导性”。对于此问题，将该标志定义为一个布尔值，当且仅当以下两个条件同时成立时，该标志为真：$(\\mathrm{i})$ 对于观察到的频率，将应用 BA1，即 $f \\ge \\tau$；以及 $(\\mathrm{ii})$ 观察到的频率不超过与模型一致的最大值，即 $f \\le q_{\\max}(m)$。否则，该标志为假。\n\n实现一个程序，对下面的每个测试用例计算此标志，并将所有结果以逗号分隔的列表形式（包含在方括号中）单行输出，并保持案例的顺序。所有量均为 $[0,1]$ 范围内的比例，因此不需要单位。\n\n使用以下测试套件。每个案例都是一个元组 $(m, p, r, h, a, \\tau, f)$，其参数定义如上：\n- 案例 A: ($m=\\mathrm{AR}, p=0.004, r=1.0, h=0.5, a=0.5, \\tau=0.01, f=0.02$)\n- 案例 B: ($m=\\mathrm{AR}, p=0.0001, r=1.0, h=1.0, a=1.0, \\tau=0.01, f=0.02$)\n- 案例 C: ($m=\\mathrm{AR}, p=0.004, r=1.0, h=0.5, a=0.5, \\tau=0.03, f=0.02$)\n- 案例 D: ($m=\\mathrm{AD}, p=0.001, r=0.2, h=1.0, a=0.5, \\tau=0.0008, f=0.001$)\n- 案例 E: ($m=\\mathrm{AR}, p=0.0004, r=1.0, h=1.0, a=1.0, \\tau=0.02, f=0.02$)\n- 案例 F: ($m=\\mathrm{AD}, p=0.01, r=0.5, h=0.1, a=0.05, \\tau=0.0001, f=0.0002$)\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如，$[x_1,x_2,\\ldots,x_k]$），其中每个 $x_i$ 为 true 或 false，按顺序对应于案例 A 到 F。", "solution": "在尝试解决问题之前，需要对其前提进行形式化验证。\n\n### 步骤 1：提取给定信息\n提供的参数和定义如下：\n- 变异的群体等位基因频率：$f \\in [0,1]$。\n- BA1 决策阈值：$\\tau \\in (0,1)$。如果 $f \\ge \\tau$，则应用 BA1 规则。\n- 疾病患病率：$p \\in (0,1)$。\n- 变异外显率：$r \\in (0,1]$。\n- 对疾病的基因水平贡献度：$h \\in (0,1]$。\n- 变异对基因病例的等位基因贡献度：$a \\in (0,1]$。\n- 遗传模式：$m \\in \\{\\text{常染色体隐性 (AR), 常染色体显性 (AD)}\\}$。\n- 假设：哈代-温伯格平衡 (HWE) 成立，并且对 AD 模型使用稀有等位基因近似。\n- 可归因于变异的病例比例定义为乘积 $p \\cdot h \\cdot a$。\n- “与致病性兼容的最大等位基因频率” $q_{\\max}(m)$，是指等位基因频率 $q$ 的最大值，在该值下，由该变异引起的预期患者频率不超过可归因于该变异的疾病负担。\n- 对于具有等位基因频率 $q$ 和外显率 $r$ 的变异，预期患者频率的主导关系为：\n    - 对于 AR：$q^2 r$。\n    - 对于 AD（使用稀有等位基因近似）：$2qr$。\n- “误导性”标志的定义是一个布尔值，当且仅当同时满足以下两个条件时为真：\n    1. $f \\ge \\tau$ (应用 BA1 规则)。\n    2. $f \\le q_{\\max}(m)$ (观察到的频率在模型下与致病性兼容)。\n- 提供的测试用例如下：\n    - 案例 A: $(m=\\text{AR},\\, p=0.004,\\, r=1.0,\\, h=0.5,\\, a=0.5,\\, \\tau=0.01,\\, f=0.02)$\n    - 案例 B: $(m=\\text{AR},\\, p=0.0001,\\, r=1.0,\\, h=1.0,\\, a=1.0,\\, \\tau=0.01,\\, f=0.02)$\n    - 案例 C: $(m=\\text{AR},\\, p=0.004,\\, r=1.0,\\, h=0.5,\\, a=0.5,\\, \\tau=0.03,\\, f=0.02)$\n    - 案例 D: $(m=\\text{AD},\\, p=0.001,\\, r=0.2,\\, h=1.0,\\, a=0.5,\\, \\tau=0.0008,\\, f=0.001)$\n    - 案例 E: $(m=\\text{AR},\\, p=0.0004,\\, r=1.0,\\, h=1.0,\\, a=1.0,\\, \\tau=0.02,\\, f=0.02)$\n    - 案例 F: $(m=\\text{AD},\\, p=0.01,\\, r=0.5,\\, h=0.1,\\, a=0.05,\\, \\tau=0.0001,\\, f=0.0002)$\n\n### 步骤 2：使用提取的给定信息进行验证\n根据指定标准对问题陈述进行验证。\n- **科学依据**：该问题基于群体遗传学的基本原理，特别是哈代-温伯格原理和孟德尔遗传。参数 $p, r, h, a, f$ 是医学和群体遗传学中的标准指标。该模型虽然简化，但为估算致病变异的最大等位基因频率提供了一个科学上合理的框架。该表述没有违反任何已知的科学定律，并且与计算生物学和生物信息学领域直接相关。\n- **良态问题**：问题结构清晰。它为每个测试用例提供了所有必要的定义、方程和数据。目标是根据一组明确的条件计算一个布尔标志。每个测试用例都存在唯一的解。\n- **客观性**：问题以精确的数学语言表述。它没有歧义、主观性或基于意见的主张。\n\n该问题没有指定的缺陷（例如，事实不健全、不完整、矛盾或结构不良）。它是一个自足、可形式化且科学有效的问题。\n\n### 步骤 3：结论与行动\n问题有效。将提供解决方案。\n\n### 求解推导\n任务是确定在给定一组参数的情况下，应用 ACMG BA1 标准是否“具有误导性”。当且仅当 $f \\ge \\tau$ 且 $f \\le q_{\\max}(m)$ 时，定义为真。问题的核心是推导和计算 $q_{\\max}(m)$。\n\n量 $q_{\\max}(m)$ 代表一个变异在与导致某孟德尔疾病特定比例的病例相一致的情况下，所能拥有的最大等位基因频率。这个最大值是通过将该变异的预期患者数量与归因于该变异的总疾病负担相等来找到的。\n\n可归因于变异的疾病负担，我们记为 $B_v$，由下式给出：\n$$ B_v = p \\cdot h \\cdot a $$\n其中 $p$ 是疾病患病率，$h$ 是基因水平贡献度，$a$ 是变异的等位基因贡献度。\n\n预期患者频率 $A(q, m, r)$ 取决于遗传模式 $m$、等位基因频率 $q$ 和外显率 $r$。\n\n**1. 常染色体隐性 (AR) 模型**\n对于常染色体隐性疾病，患者主要是致病等位基因的纯合子。根据哈代-温伯格平衡，纯合子的频率是 $q^2$。加上外显率 $r$，患者的频率是：\n$$ A(q, \\text{AR}, r) = q^2 r $$\n为了找到 $q_{\\max}(\\text{AR})$，我们设 $A(q_{\\max}, \\text{AR}, r) = B_v$：\n$$ (q_{\\max}(\\text{AR}))^2 r = p \\cdot h \\cdot a $$\n解出 $q_{\\max}(\\text{AR})$：\n$$ q_{\\max}(\\text{AR}) = \\sqrt{\\frac{p \\cdot h \\cdot a}{r}} $$\n\n**2. 常染色体显性 (AD) 模型**\n对于常染色体显性疾病，并使用稀有等位基因近似（$q \\ll 1$），患者主要是杂合子。根据 HWE，杂合子的频率是 $2q(1-q)$，对于小的 $q$ 近似为 $2q$。加上外显率 $r$，患者的频率是：\n$$ A(q, \\text{AD}, r) \\approx 2qr $$\n为了找到 $q_{\\max}(\\text{AD})$，我们设 $A(q_{\\max}, \\text{AD}, r) = B_v$：\n$$ 2q_{\\max}(\\text{AD}) r = p \\cdot h \\cdot a $$\n解出 $q_{\\max}(\\text{AD})$：\n$$ q_{\\max}(\\text{AD}) = \\frac{p \\cdot h \\cdot a}{2r} $$\n\n然后通过评估逻辑表达式 $(f \\ge \\tau) \\land (f \\le q_{\\max})$ 来计算“误导性”标志。\n\n### 测试用例计算\n\n**案例 A:** $(m=\\text{AR},\\, p=0.004,\\, r=1.0,\\, h=0.5,\\, a=0.5,\\, \\tau=0.01,\\, f=0.02)$\n1.  计算 $q_{\\max}(\\text{AR})$:\n    $$ q_{\\max}(\\text{AR}) = \\sqrt{\\frac{0.004 \\cdot 0.5 \\cdot 0.5}{1.0}} = \\sqrt{0.001} \\approx 0.03162 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.02 \\ge 0.01$ 为 True。\n    - $f \\le q_{\\max}(\\text{AR})$: $0.02 \\le 0.03162$ 为 True。\n3.  结果: True $\\land$ True $\\implies$ True。\n\n**案例 B:** $(m=\\text{AR},\\, p=0.0001,\\, r=1.0,\\, h=1.0,\\, a=1.0,\\, \\tau=0.01,\\, f=0.02)$\n1.  计算 $q_{\\max}(\\text{AR})$:\n    $$ q_{\\max}(\\text{AR}) = \\sqrt{\\frac{0.0001 \\cdot 1.0 \\cdot 1.0}{1.0}} = \\sqrt{0.0001} = 0.01 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.02 \\ge 0.01$ 为 True。\n    - $f \\le q_{\\max}(\\text{AR})$: $0.02 \\le 0.01$ 为 False。\n3.  结果: True $\\land$ False $\\implies$ False。\n\n**案例 C:** $(m=\\text{AR},\\, p=0.004,\\, r=1.0,\\, h=0.5,\\, a=0.5,\\, \\tau=0.03,\\, f=0.02)$\n1.  计算 $q_{\\max}(\\text{AR})$:\n    $$ q_{\\max}(\\text{AR}) = \\sqrt{\\frac{0.004 \\cdot 0.5 \\cdot 0.5}{1.0}} = \\sqrt{0.001} \\approx 0.03162 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.02 \\ge 0.03$ 为 False。\n3.  结果: 第一个条件为假，所以组合结果为 False。\n\n**案例 D:** $(m=\\text{AD},\\, p=0.001,\\, r=0.2,\\, h=1.0,\\, a=0.5,\\, \\tau=0.0008,\\, f=0.001)$\n1.  计算 $q_{\\max}(\\text{AD})$:\n    $$ q_{\\max}(\\text{AD}) = \\frac{0.001 \\cdot 1.0 \\cdot 0.5}{2 \\cdot 0.2} = \\frac{0.0005}{0.4} = 0.00125 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.001 \\ge 0.0008$ 为 True。\n    - $f \\le q_{\\max}(\\text{AD})$: $0.001 \\le 0.00125$ 为 True。\n3.  结果: True $\\land$ True $\\implies$ True。\n\n**案例 E:** $(m=\\text{AR},\\, p=0.0004,\\, r=1.0,\\, h=1.0,\\, a=1.0,\\, \\tau=0.02,\\, f=0.02)$\n1.  计算 $q_{\\max}(\\text{AR})$:\n    $$ q_{\\max}(\\text{AR}) = \\sqrt{\\frac{0.0004 \\cdot 1.0 \\cdot 1.0}{1.0}} = \\sqrt{0.0004} = 0.02 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.02 \\ge 0.02$ 为 True。\n    - $f \\le q_{\\max}(\\text{AR})$: $0.02 \\le 0.02$ 为 True。\n3.  结果: True $\\land$ True $\\implies$ True。\n\n**案例 F:** $(m=\\text{AD},\\, p=0.01,\\, r=0.5,\\, h=0.1,\\, a=0.05,\\, \\tau=0.0001,\\, f=0.0002)$\n1.  计算 $q_{\\max}(\\text{AD})$:\n    $$ q_{\\max}(\\text{AD}) = \\frac{0.01 \\cdot 0.1 \\cdot 0.05}{2 \\cdot 0.5} = \\frac{0.00005}{1.0} = 0.00005 $$\n2.  检查条件:\n    - $f \\ge \\tau$: $0.0002 \\ge 0.0001$ 为 True。\n    - $f \\le q_{\\max}(\\text{AD})$: $0.0002 \\le 0.00005$ 为 False。\n3.  结果: True $\\land$ False $\\implies$ False。\n\n从案例 A 到 F 的最终布尔结果序列为：True, False, False, True, True, False。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes a 'misleading' flag for the application of the ACMG BA1 rule\n    for several test cases, based on a population genetics model.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (m, p, r, h, a, tau, f)\n    # m: Mode of inheritance ('AR' or 'AD')\n    # p: Disease prevalence\n    # r: Penetrance\n    # h: Gene-level contribution\n    # a: Variant's allelic contribution\n    # tau: BA1 decision threshold\n    # f: Observed population allele frequency\n    test_cases = [\n        ('AR', 0.004, 1.0, 0.5, 0.5, 0.01, 0.02),      # Case A\n        ('AR', 0.0001, 1.0, 1.0, 1.0, 0.01, 0.02),     # Case B\n        ('AR', 0.004, 1.0, 0.5, 0.5, 0.03, 0.02),      # Case C\n        ('AD', 0.001, 0.2, 1.0, 0.5, 0.0008, 0.001),    # Case D\n        ('AR', 0.0004, 1.0, 1.0, 1.0, 0.02, 0.02),     # Case E\n        ('AD', 0.01, 0.5, 0.1, 0.05, 0.0001, 0.0002),   # Case F\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        m, p, r, h, a, tau, f = case\n\n        # Calculate the variant-attributable disease burden\n        variant_burden = p * h * a\n\n        # Calculate the maximum allele frequency compatible with pathogenicity (q_max)\n        # based on the mode of inheritance.\n        q_max = 0.0\n        if m == 'AR':\n            # For Autosomal Recessive, q_max = sqrt((p*h*a) / r)\n            if r > 0:\n                q_max = np.sqrt(variant_burden / r)\n        elif m == 'AD':\n            # For Autosomal Dominant, q_max = (p*h*a) / (2*r)\n            if r > 0:\n                q_max = variant_burden / (2 * r)\n\n        # A \"misleading\" flag is True if both conditions are met:\n        # 1. BA1 would be applied for the observed frequency (f >= tau)\n        # 2. The observed frequency is compatible with the model (f = q_max)\n        is_misleading = (f >= tau) and (f = q_max)\n        \n        results.append(str(is_misleading).lower())\n\n    # Format the final output as a comma-separated list of booleans\n    # within square brackets, e.g., [true,false,...]\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378900"}, {"introduction": "现代变异解读正朝着更定量的方向发展，超越了ACMG原有的半定量评分系统。本练习将引导您进入一个更严谨的贝叶斯统计框架。通过将每个证据标准（如$PS1$, $PM2$）视为一个特定的似然比，您将学习如何结合先验知识和新证据来计算变异致病性的后验概率。这不仅为整合多种证据提供了强大的数学工具，也培养了在不确定性下进行概率推理的能力。[@problem_id:2378888]", "problem": "您将把美国医学遗传学与基因组学学会 (ACMG) 证据编码的累积过程，建模为对致病性先验概率的贝叶斯更新。假设每个证据编码都提供一个支持致病性的似然比，并且所有证据项在给定真实致病性状态下是条件独立的。令致病性的先验概率表示为 $p_0 \\in (0,1)$，证据为一个从固定编码类别集合中抽取的有限序列 $E = (e_1, e_2, \\ldots, e_n)$。定义先验优势为 $O_0 = \\dfrac{p_0}{1 - p_0}$，每个证据 $e_i$ 的似然比为 $\\operatorname{LR}(e_i)$，后验优势为\n$$\nO_{\\text{post}} = O_0 \\times \\prod_{i=1}^{n} \\operatorname{LR}(e_i).\n$$\n通过以下公式将优势转换回概率\n$$\np_{\\text{post}} = \\frac{O_{\\text{post}}}{1 + O_{\\text{post}}}.\n$$\n如果 $E$ 为空，则空积取为 $1$，因此 $p_{\\text{post}} = p_0$。\n\n对 ACMG 证据强度使用以下似然比校准，这在 ACMG 标准的贝叶斯重新解读中是标准做法。似然比均支持致病性；良性标准使用倒数值：\n- 致病性-非常强 ($\\text{PVS}$): $\\operatorname{LR} = 350$。\n- 致病性-强 ($\\text{PS}$): $\\operatorname{LR} = 18.7$。\n- 致病性-中等 ($\\text{PM}$): $\\operatorname{LR} = 4.3$。\n- 致病性-支持 ($\\text{PP}$): $\\operatorname{LR} = 2.08$。\n- 良性-独立 ($\\text{BA}$): $\\operatorname{LR} = \\dfrac{1}{350}$。\n- 良性-强 ($\\text{BS}$): $\\operatorname{LR} = \\dfrac{1}{18.7}$。\n- 良性-支持 ($\\text{BP}$): $\\operatorname{LR} = \\dfrac{1}{2.08}$。\n\n实现一个程序，为每个测试用例根据上述定义计算 $p_{\\text{post}}$。将每个后验概率表示为小数点后保留六位的小数。\n\n测试套件（每个用例为 $(p_0, E)$）：\n- 用例 1：$(p_0 = 0.1, E = [\\text{\"PS\"}, \\text{\"PM\"}, \\text{\"BP\"}])$。\n- 用例 2：$(p_0 = 0.1, E = [\\,])$（无证据）。\n- 用例 3：$(p_0 = 0.5, E = [\\text{\"PVS\"}])$。\n- 用例 4：$(p_0 = 0.99, E = [\\text{\"BS\"}])$。\n- 用例 5：$(p_0 = 0.01, E = [\\text{\"BA\"}])$。\n- 用例 6：$(p_0 = 0.2, E = [\\text{\"PP\"}, \\text{\"PP\"}, \\text{\"BP\"}])$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试套件中的顺序相同，例如 $[\\text{result}_1,\\text{result}_2,\\ldots]$。每个 $\\text{result}_i$ 都必须是小数点后保留六位的十进制数，例如 $[0.123456,0.500000,0.999000]$。", "solution": "所提出的问题在科学上是合理的，在数学上是适定的。它基于贝叶斯统计的既定原则，特别是将贝叶斯定理以其优势与似然比的形式应用于临床变异解读中的证据整合问题。这种方法是美国医学遗传学与基因组学学会 (ACMG) 框架下量化证据强度的一种公认且已发表的方法。因此，该问题是有效的，我们继续进行求解。\n\n问题的核心是贝叶斯更新。令 $H$ 为遗传变异是致病性的假设，$\\neg H$ 为其非致病性的互补假设。致病性的先验概率由 $p_0 = P(H)$ 给出。支持致病性的先验优势定义为该假设的先验概率与其补集的先验概率之比：\n$$\nO_0 = \\frac{P(H)}{P(\\neg H)} = \\frac{p_0}{1 - p_0}\n$$\n我们给定一个证据项序列 $E = (e_1, e_2, \\ldots, e_n)$。对于每个证据 $e_i$，其强度由一个似然比 $\\operatorname{LR}(e_i)$ 来量化，定义为：\n$$\n\\operatorname{LR}(e_i) = \\frac{P(e_i | H)}{P(e_i | \\neg H)}\n$$\n优势形式的贝叶斯定理指出，后验优势是先验优势和似然比的乘积：$O_{\\text{post}} = O_0 \\times \\operatorname{LR}(E)$。问题指出，在给定真实致病性状态的情况下，证据项是条件独立的。这个关键假设允许我们将整个证据序列 $E$ 的似然比计算为各个似然比的乘积：\n$$\n\\operatorname{LR}(E) = \\operatorname{LR}(e_1, e_2, \\ldots, e_n) = \\prod_{i=1}^{n} \\operatorname{LR}(e_i)\n$$\n因此，在观察到 $E$ 中所有证据项之后，后验优势 $O_{\\text{post}}$ 计算如下：\n$$\nO_{\\text{post}} = O_0 \\times \\prod_{i=1}^{n} \\operatorname{LR}(e_i)\n$$\n如果证据集 $E$ 为空，则乘积取为 $1$，因此 $O_{\\text{post}} = O_0$。\n\n最后，使用以下公式将后验优势转换回后验概率 $p_{\\text{post}} = P(H|E)$：\n$$\np_{\\text{post}} = \\frac{O_{\\text{post}}}{1 + O_{\\text{post}}}\n$$\n问题提供了不同 ACMG 证据强度类别的校准似然比：\n- 致病性-非常强 ($\\text{PVS}$): $\\operatorname{LR} = 350$\n- 致病性-强 ($\\text{PS}$): $\\operatorname{LR} = 18.7$\n- 致病性-中等 ($\\text{PM}$): $\\operatorname{LR} = 4.3$\n- 致病性-支持 ($\\text{PP}$): $\\operatorname{LR} = 2.08$\n- 良性-独立 ($\\text{BA}$): $\\operatorname{LR} = 1/350$\n- 良性-强 ($\\text{BS}$): $\\operatorname{LR} = 1/18.7$\n- 良性-支持 ($\\text{BP}$): $\\operatorname{LR} = 1/2.08$\n\n我们现在将此方法应用于每个测试用例。\n\n用例 1：$(p_0 = 0.1, E = [\\text{\"PS\"}, \\text{\"PM\"}, \\text{\"BP\"}])$\n- 先验概率 $p_0 = 0.1$。\n- 先验优势 $O_0 = \\frac{0.1}{1 - 0.1} = \\frac{0.1}{0.9} = \\frac{1}{9}$。\n- 总似然比 $\\operatorname{LR}_{\\text{total}} = \\operatorname{LR}(\\text{PS}) \\times \\operatorname{LR}(\\text{PM}) \\times \\operatorname{LR}(\\text{BP}) = 18.7 \\times 4.3 \\times \\frac{1}{2.08} = \\frac{80.41}{2.08}$。\n- 后验优势 $O_{\\text{post}} = \\frac{1}{9} \\times \\frac{80.41}{2.08} = \\frac{80.41}{18.72} \\approx 4.29540598$。\n- 后验概率 $p_{\\text{post}} = \\frac{4.29540598}{1 + 4.29540598} \\approx 0.8111580$。四舍五入到小数点后六位，结果为 $0.811158$。\n\n用例 2：$(p_0 = 0.1, E = [\\,])$\n- 先验概率 $p_0 = 0.1$。\n- 证据列表为空。似然比的乘积为 $1$。\n- 后验优势 $O_{\\text{post}} = O_0 = \\frac{0.1}{0.9} = \\frac{1}{9}$。\n- 后验概率 $p_{\\text{post}} = \\frac{1/9}{1 + 1/9} = \\frac{1}{10} = 0.1$。正如预期的，这等于 $p_0$。四舍五入到小数点后六位，结果为 $0.100000$。\n\n用例 3：$(p_0 = 0.5, E = [\\text{\"PVS\"}])$\n- 先验概率 $p_0 = 0.5$。\n- 先验优势 $O_0 = \\frac{0.5}{1 - 0.5} = 1$。\n- 总似然比 $\\operatorname{LR}_{\\text{total}} = \\operatorname{LR}(\\text{PVS}) = 350$。\n- 后验优势 $O_{\\text{post}} = 1 \\times 350 = 350$。\n- 后验概率 $p_{\\text{post}} = \\frac{350}{1 + 350} = \\frac{350}{351} \\approx 0.997150997$。四舍五入到小数点后六位，结果为 $0.997151$。\n\n用例 4：$(p_0 = 0.99, E = [\\text{\"BS\"}])$\n- 先验概率 $p_0 = 0.99$。\n- 先验优势 $O_0 = \\frac{0.99}{1 - 0.99} = \\frac{0.99}{0.01} = 99$。\n- 总似然比 $\\operatorname{LR}_{\\text{total}} = \\operatorname{LR}(\\text{BS}) = \\frac{1}{18.7}$。\n- 后验优势 $O_{\\text{post}} = 99 \\times \\frac{1}{18.7} = \\frac{99}{18.7}$。\n- 后验概率 $p_{\\text{post}} = \\frac{99/18.7}{1 + 99/18.7} = \\frac{99}{18.7 + 99} = \\frac{99}{117.7} \\approx 0.841121495$。四舍五入到小数点后六位，结果为 $0.841121$。\n\n用例 5：$(p_0 = 0.01, E = [\\text{\"BA\"}])$\n- 先验概率 $p_0 = 0.01$。\n- 先验优势 $O_0 = \\frac{0.01}{1 - 0.01} = \\frac{0.01}{0.99} = \\frac{1}{99}$。\n- 总似然比 $\\operatorname{LR}_{\\text{total}} = \\operatorname{LR}(\\text{BA}) = \\frac{1}{350}$。\n- 后验优势 $O_{\\text{post}} = \\frac{1}{99} \\times \\frac{1}{350} = \\frac{1}{34650}$。\n- 后验概率 $p_{\\text{post}} = \\frac{1/34650}{1 + 1/34650} = \\frac{1}{34650 + 1} = \\frac{1}{34651} \\approx 0.000028859$。四舍五入到小数点后六位，结果为 $0.000029$。\n\n用例 6：$(p_0 = 0.2, E = [\\text{\"PP\"}, \\text{\"PP\"}, \\text{\"BP\"}])$\n- 先验概率 $p_0 = 0.2$。\n- 先验优势 $O_0 = \\frac{0.2}{1 - 0.2} = \\frac{0.2}{0.8} = 0.25$。\n- 总似然比 $\\operatorname{LR}_{\\text{total}} = \\operatorname{LR}(\\text{PP}) \\times \\operatorname{LR}(\\text{PP}) \\times \\operatorname{LR}(\\text{BP}) = 2.08 \\times 2.08 \\times \\frac{1}{2.08} = 2.08$。\n- 后验优势 $O_{\\text{post}} = 0.25 \\times 2.08 = 0.52$。\n- 后验概率 $p_{\\text{post}} = \\frac{0.52}{1 + 0.52} = \\frac{0.52}{1.52} = \\frac{13}{38} \\approx 0.342105263$。四舍五入到小数点后六位，结果为 $0.342105$。\n\n六个测试用例计算出的后验概率分别为：$0.811158$、$0.100000$、$0.997151$、$0.841121$、$0.000029$ 和 $0.342105$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes posterior probabilities of pathogenicity based on a Bayesian\n    reinterpretation of ACMG evidence codes.\n    \"\"\"\n\n    # Define the likelihood ratio (LR) calibration for ACMG evidence strengths.\n    # The LRs are given in favor of pathogenicity.\n    lr_map = {\n        \"PVS\": 350.0,\n        \"PS\": 18.7,\n        \"PM\": 4.3,\n        \"PP\": 2.08,\n        \"BA\": 1.0 / 350.0,\n        \"BS\": 1.0 / 18.7,\n        \"BP\": 1.0 / 2.08,\n    }\n\n    # Define the test suite. Each case is a tuple (p0, evidence_list).\n    # p0 is the prior probability of pathogenicity.\n    test_cases = [\n        (0.1, [\"PS\", \"PM\", \"BP\"]),\n        (0.1, []),\n        (0.5, [\"PVS\"]),\n        (0.99, [\"BS\"]),\n        (0.01, [\"BA\"]),\n        (0.2, [\"PP\", \"PP\", \"BP\"]),\n    ]\n\n    results = []\n    for p0, evidence_codes in test_cases:\n        # Step 1: Calculate prior odds from prior probability p0.\n        # O_0 = p0 / (1 - p0)\n        # A check for p0=1 is good practice but not needed for given test cases.\n        if p0 == 1.0:\n            prior_odds = float('inf')\n        else:\n            prior_odds = p0 / (1.0 - p0)\n\n        # Step 2: Calculate the total likelihood ratio from the evidence codes.\n        # The total LR is the product of individual LRs due to conditional independence.\n        if not evidence_codes:\n            # The product of an empty set of LRs is 1.\n            total_lr = 1.0\n        else:\n            # Look up LR for each code and compute the product.\n            # np.prod is convenient for this.\n            lr_values = [lr_map[code] for code in evidence_codes]\n            total_lr = np.prod(lr_values)\n\n        # Step 3: Calculate posterior odds.\n        # O_post = O_0 * LR_total\n        posterior_odds = prior_odds * total_lr\n\n        # Step 4: Convert posterior odds back to posterior probability.\n        # p_post = O_post / (1 + O_post)\n        if posterior_odds == float('inf'):\n            posterior_prob = 1.0\n        else:\n            posterior_prob = posterior_odds / (1.0 + posterior_odds)\n\n        # Append the formatted result to the list.\n        # The result must be a string rounded to six decimal places.\n        results.append(f\"{posterior_prob:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2378888"}]}