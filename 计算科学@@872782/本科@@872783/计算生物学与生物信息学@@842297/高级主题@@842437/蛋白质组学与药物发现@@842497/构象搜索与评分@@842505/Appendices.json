{"hands_on_practices": [{"introduction": "理论最好通过实践来理解。为了真正掌握构象搜索和打分的精髓，我们将从剖析一个能量函数的基本组成部分开始。这个练习聚焦于溶剂化能，这是一个模拟蛋白质如何在水环境中折叠的关键能量项。通过分析一个假设情景，你将深入理解疏水效应和极性基团的去溶剂化惩罚——这是驱动蛋白质正确折叠的核心热力学原理 [@problem_id:2381452]。", "problem": "您正在使用 Rosetta 全原子能量函数，其中包括一个基于 Lazaridis–Karplus (LK) 高斯溶剂排斥模型的、有物理动机的隐式溶剂化自由能项，名为 \"fa_sol\"。考虑两种氨基酸侧链：leucine（一种非极性、疏水性侧链）和 aspartate（一种带负电的极性侧链）。对于每种侧链，考虑其在折叠蛋白质中的两种环境：一种是具有大溶剂可及表面積 (SASA) 的高度表面暴露环境，另一种是具有极小 SASA 且没有内部氢键或盐桥的内部紧密堆积环境。假设在本问题中只考虑 \"fa_sol\" 项，而所有其他能量项（如静电作用、氢键作用、扭转熵等）均被忽略。\n\n从以下基本热力学事实出发：(i) 极性和带电基团通过与水的有利相互作用而得以稳定；(ii) 非极性基团经历疏水效应，即从其周围移除水分子会降低体系的自由能；以及 (iii) 像 LK 这样的隐式溶剂化项通过以体相溶剂为参考态，量化了邻近溶质原子遮蔽水分子时溶剂化的自由能变化。请分析将侧链从表面暴露移动到内部埋藏状态如何改变其对 \"fa_sol\" 项的贡献。\n\n哪个选项最好地描述了 leucine 和 aspartate 在这两种环境中对 \"fa_sol\" 贡献的符号和相对大小？\n\nA. 对于 leucine，\"fa_sol\" 在表面暴露时是强有利的（大的负值），而在埋藏时接近 $0$；对于 aspartate，\"fa_sol\" 在埋藏时是强有利的（大的负值），而在表面暴露时接近 $0$。\n\nB. 对于 leucine 和 aspartate，无论是否埋藏，\"fasol\" 的贡献都近似为 $0$，因为在 Rosetta 中溶剂化作用由其他项主导。\n\nC. 对于 leucine，\"fa_sol\" 在表面暴露时接近 $0$，而在埋藏时变为强的负值（有利的）；对于缺少内部氢键或盐桥的 aspartate，\"fa_sol\" 在表面暴露时接近 $0$，而在埋藏时变为强的正值（不利的）。\n\nD. 对于 leucine，只有当它形成紧密的范德华接触时，\"fa_sol\" 在埋藏时才会变为正值（不利的）；对于 aspartate，如果它损失了旋转异构体熵，\"fa_sol\" 在埋藏时会变为负值（有利的）。", "solution": "我们从热力学第一性原理和隐式溶剂化项的构建出发。溶剂化自由能反映了溶质基团与水之间的相互作用。极性或带电基团与水形成有利的静电和氢键相互作用，从而降低溶剂化状态的自由能；相反，非极性基团经历疏水效应，其周围水分子的有序排列是不利的，从其附近移除水分子（例如，通过将其埋藏在其他非极性基团旁边）会降低体系的自由能。在像 Lazaridis–Karplus (LK) 这样的高斯溶剂排斥模型中，从体相溶剂移动到蛋白质环境中的溶剂化自由能变化，是通过邻近原子如何遮蔽每个原子周围的溶剂来估算的；参考态被设为体相溶剂，因此一个完全暴露的原子对溶剂化能的贡献近似为 $0$，而埋藏则根据该原子的溶剂化特性（疏水性 vs. 极性/带电）来改变自由能。\n\n应用这些原理：\n\n- Leucine 是非极性的。在体相溶剂中（表面暴露），它被水分子包围；在一个以体相溶剂为参考态的类LK模型中，这对应于对 \"fa_sol\" 接近 $0$ 的贡献。当 leucine 被邻近的蛋白质原子埋藏时，水会从其周围被排开；移除不利的水接触会导致自由能的降低，因此溶剂化项变得更有利（更负）。因此，埋藏使 \"fa_sol\" 的值从接近 $0$ 变为负值（有利的），其大小取决于遮蔽的程度。\n\n- Aspartate 是带负电且极性的。在体相溶剂中（表面暴露），它与水形成有利的相互作用；在以体相溶剂为参考态的LK框架中，暴露状态同样对应于接近 $0$ 的贡献，因为蛋白质造成的遮蔽是最小的。当 aspartate 在没有形成补偿性内部氢键或盐桥的情况下被埋藏时，水被排开，该残基失去了有利的溶剂化作用，从而产生去溶剂化惩罚。因此，溶剂化项变为正值（不利的），其大小随着埋藏程度的增加而增加。在实际情况中，其他的 Rosetta 能量项（例如氢键、静电作用）可能会进行补偿，但根据假设，这些在这里被忽略了。\n\n通过以上分析，我们来检查各个选项：\n\nA. 声称 leucine 在表面暴露时是强有利的，在埋藏时接近 $0$，而 aspartate 在埋藏时是有利的。这颠倒了 leucine 的疏水效应和 aspartate 的去溶剂化惩罚。不正确。\n\nB. 声称对于两种残基类型，无论是否埋藏，\"fa_sol\" 都近似为 $0$。这与 \"fa_sol\" 的核心作用相矛盾，其作用是通过模拟溶剂遮蔽来惩罚极性/带电原子的埋藏并奖励非极性原子的埋藏。不正确。\n\nC. 陈述 leucine 在表面暴露时接近 $0$，在埋藏时为强的负值；而 aspartate（没有内部氢键或盐桥）在表面暴露时接近 $0$，在埋藏时为强的正值。这与热力学推理和LK参考态的选择相符。正确。\n\nD. 将 \"fa_sol\" 的符号变化归因于 leucine 的范德华接触和 aspartate 的旋转异构体熵损失。范德华作用和熵在 Rosetta 中是独立的能量项，它们不决定 \"fa_sol\" 的符号；此外，其所断言的方向与疏水效应和去溶剂化的预期相矛盾。不正确。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "2381452"}, {"introduction": "找到能量最低的构象不仅需要精确的“地图”（打分函数），还需要高效的“交通工具”（搜索算法）。这个思想实验将探讨当搜索方法存在根本性偏见时，即使有完美的打分函数也无济于事。通过这个练习，你将领会到在蒙特卡洛搜索中，移动集（move set）对于有效探索构象空间至关重要，并理解采样与打分之间密不可分的协同关系 [@problem_id:2381444]。", "problem": "在Rosetta框架下的基于片段的蛋白质结构预测中，在由打分函数引导的蒙特卡洛（MC）搜索过程中，从已知结构中提取的短主链片段（通常是$3$-聚体和$9$-聚体）被插入到演化中的模型中。设想一个假设性的从头折叠运行，目标蛋白的天然结构为全$\\beta$结构。由于一个错误，片段库完全由一个全$\\alpha$蛋白的非冗余集合构建，因此片段的$\\phi$和$\\psi$扭转角分布主要占据$\\alpha$螺旋区域。所有其他参数（温度方案、移动频率以及低分辨率和全原子阶段的打分函数）都是标准的。以下哪种结果最有可能发生？\n\nA. 搜索将强烈偏向于$\\alpha$螺旋构象；它将很少采样到形成$\\beta$折叠片所必需的伸展$\\beta$链几何构型；结果，诱饵结构将集中在螺旋拓扑结构中，与类天然的$\\beta$折叠相比，其全原子和低分辨率打分都相对较差，并且该运行将显示出向低均方根偏差（RMSD）模型的收敛性差。\n\nB. Rosetta全原子打分函数包含明确的$\\beta$折叠片氢键项，这将迫使片段插入的螺旋解开并重排成$\\beta$折叠片，因此搜索仍将有效找到正确的折叠，其收敛性与使用匹配的片段库时相似。\n\nC. 因为片段很短（$3$-聚体和$9$-聚体），所以它们的二级结构内容无关紧要；给定足够的蒙特卡洛步数，采样实际上仍然是无偏的，并且将以不受影响的效率达到正确的$\\beta$拓扑结构。\n\nD. 移动集变得无效，因为$\\alpha$和$\\beta$区域之间的$\\phi$和$\\psi$扭转角限制不同，导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法继续进行，模拟提前终止。", "solution": "问题陈述经过严格评估，被认为是有效的。它描述了计算蛋白质结构预测中一个科学上可信的情景，该情景设定良好、客观且自成体系。该问题涉及在蒙特卡洛搜索中使用构象偏向的移动集的预期结果，这是该领域的标准课题。\n\n问题描述了一个使用Rosetta框架的*从头*蛋白质折叠模拟。在这种方法中，构象空间通过蒙特卡洛（MC）搜索进行探索。一个关键的移动类型是插入主链扭转角片段，这些片段通常长度为3和9个残基（$3$-聚体和$9$-聚体），从已知蛋白质结构的文库中提取。移动的接受与否由一个打分函数和Metropolis准则决定。\n\n问题的核心在于模拟中两个组成部分之间的冲突：\n1.  **采样偏差：** 片段库完全由全$\\alpha$蛋白构建。这意味着可用片段的扭转角（$\\phi$, $\\psi$）将主要位于拉马钱德兰图的$\\alpha$螺旋区域（大约$\\phi \\approx -60^\\circ$, $\\psi \\approx -40^\\circ$）。因此，对主链构象进行显著改变的主要方法被严重偏向于产生和维持$\\alpha$螺旋二级结构。\n2.  **目标结构：** 目标蛋白的天然结构是全$\\beta$结构。这意味着其组成残基应采用拉马钱德兰图的$\\beta$折叠链区域的扭转角（大约$\\phi \\approx -120^\\circ$, $\\psi \\approx +135^\\circ$）。由Rosetta打分函数为该蛋白质定义的能量景观的全局最小值对应于这种全$\\beta$折叠。\n\n模拟的结果由这种有偏采样和能量景观之间的相互作用决定。MC搜索将按以下方式进行：\n- 片段插入移动将持续提出具有$\\alpha$螺旋特征的局部构象。这将非常有效地采样螺旋拓扑结构。\n- 搜索将无法有效采样伸展的$\\beta$折叠链构象，因为所需的($\\phi$, $\\psi$)角度在片段库提供的移动集中系统性地缺失。虽然存在其他小的扰动移动（`small`和`shear`），但它们不足以在现实的模拟时间尺度内从一个紧凑的螺旋球状体转变为一个伸展的$\\beta$折叠片拓扑结构。\n- 因此，生成的构象（“诱饵结构”）将主要是螺旋结构。\n- Rosetta打分函数（包括低分辨率和全原子）旨在识别天然折叠的能量有利性。对于一个全$\\beta$蛋白，打分函数将正确地为天然的$\\beta$折叠片拓扑结构赋予比任何非天然的螺旋排列低得多（更好）的能量。采样的螺旋诱饵结构将缺乏稳定天然$\\beta$折叠片的特定长程氢键网络和三级堆积，导致高（差）的分数。\n- 模拟将无法收敛。能量对RMSD图不会显示出典型的漏斗形状，即最低能量结构与天然态的均方根偏差（RMSD）较低。相反，搜索找到的最低能量结构将是具有高RMSD的非天然螺旋紧凑状态。\n\n有了这种理解，我们来评估给出的选项：\n\n**A. 搜索将强烈偏向于$\\alpha$螺旋构象；它将很少采样到形成$\\beta$折叠片所必需的伸展$\\beta$链几何构型；结果，诱饵结构将集中在螺旋拓扑结构中，与类天然的$\\beta$折叠相比，其全原子和低分辨率打分都相对较差，并且该运行将显示出向低均方根偏差（RMSD）模型的收敛性差。**\n这个陈述是对预期结果的精确和准确描述。采样受到片段库的偏向，阻止了对正确构象空间的访问。由此产生的诱饵结构是非天然的，因此得分很差。整体预测失败，表现为未能收敛到低RMSD的结构。\n**结论：正确。**\n\n**B. Rosetta全原子打分函数包含明确的$\\beta$折叠片氢键项，这将迫使片段插入的螺旋解开并重排成$\\beta$折叠片，因此搜索仍将有效找到正确的折叠，其收敛性与使用匹配的片段库时相似。**\n这个陈述是错误的。打分函数评估构象；它不会“迫使”构象跨越巨大的动力学势垒进行重排。模拟通过由可用移动定义的路径来探索构象空间。如果移动不导向正确的折叠，单靠打分函数是无法弥补的。低分辨率搜索将为全原子阶段产生糟糕的起始模型，而全原子精修使用局部扰动，这些扰动无法将整个蛋白质的拓扑结构从全$\\alpha$转换为全$\\beta$。声称“有效”找到正确折叠并具有“相似收敛性”是错误的。\n**结论：错误。**\n\n**C. 因为片段很短（$3$-聚体和$9$-聚体），所以它们的二级结构内容无关紧要；给定足够的蒙特卡洛步数，采样实际上仍然是无偏的，并且将以不受影响的效率达到正确的$\\beta$拓扑结构。**\n这个陈述有根本性的缺陷。片段中编码的局部二级结构信息正是使用它们的原因。它极大地加速了对类天然局部构象的搜索。声称其内容“无关紧要”与基于片段组装的整个原则相悖。虽然理论上无限长的MC运行可以采样到任何状态，但在实践中，强烈的偏差使得在任何可行的模拟时间内采样到正确折叠的概率小到可以忽略不计。采样并非“实际上无偏”；它是严重偏向的，效率将急剧下降到完全失败的程度。\n**结论：错误。**\n\n**D. 移动集变得无效，因为$\\alpha$和$\\beta$区域之间的$\\phi$和$\\psi$扭转角限制不同，导致频繁的违规并被确定性地拒绝；因此，马尔可夫链无法继续进行，模拟提前终止。**\n这个陈述误解了Rosetta算法。不存在会导致确定性拒绝和模拟终止的硬性“无效”扭转角限制。一个提出的移动如果导致不利的扭转角（例如，在拉马钱德兰图的禁区），会从相应的打分项（例如 `rama`）中获得高能量惩罚。这使得该移动根据Metropolis准则被接受的可能性极低，但这是一个概率性过程，而非确定性过程。马尔可夫链会继续进行，但它被困在了构象空间的一个非生产性区域。模拟不会终止。\n**结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2381444"}, {"introduction": "理解的最终检验是亲手构建一个工作模型。这项编码挑战将引导你实现一个受真实世界建模软件启发的简化知识库能量函数。通过为基础残基定义参数并为翻译后修饰创建一个“补丁”（Patch），你将亲手模拟化学变化如何转化为可预测的蛋白质结构变化，从而将抽象概念与具体实践联系起来 [@problem_id:2381408]。", "problem": "要求您形式化一个简化的构象搜索和打分问题，其灵感来源于 Rosetta 建模框架。您的程序必须模拟一个残基参数文件和一个磷酸化补丁 (Patch) 将如何改变一个残基的主链构象偏好和预测的最低能量构象。\n\n科学基础。您必须从这样一个原则出发：在像 Rosetta 这样基于知识的建模框架中，预测的构象是使总势能最小化的那一个。具体来说，如果 $E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ 是一个关于构象变量 $\\boldsymbol{\\theta}$ 和参数 $\\boldsymbol{\\lambda}$ 的标量能量，那么预测的构象是使 $E$ 最小化的任何 $\\boldsymbol{\\theta}^{\\star}$。化学特性或翻译后状态的变化可以通过残基参数文件（基础特性）和一个补丁（一种修饰叠加）表示为 $\\boldsymbol{\\lambda}$ 的变化。因此，通过向丝氨酸添加一个磷酸基团来进行磷酸化，可以被建模为统计扭转角偏好的改变以及反映空间位阻和静电相互作用的附加物理化学项。\n\n您将实现一个关于单个残基主链二面角 $\\phi$ 和 $\\psi$（以度为单位测量）的粗粒度、自洽的打分函数。总能量是多个可解释组分的总和，这些组分是对常见 Rosetta 术语的抽象：主链统计偏好、由增加的体积带来的空间位阻效应，以及环境定向静电或类氢键相互作用。您的程序必须在代码中将基础的“丝氨酸参数 (Serine params)”和“磷酸化丝氨酸补丁 (phospho-Serine Patch)”构建为数据结构，并应用它们来计算能量。\n\n需要实现的定义：\n- 角度以度为单位。能量以千卡/摩尔为单位。\n- 主链统计偏好被建模为代表 $\\alpha$-螺旋和 $\\beta$-折叠区域的两个各向异性高斯势阱的混合。对于残基类型 $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$，\n  $$\n  E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n  \\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right).\n  $$\n  使用中心 $\\left(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha}\\right)=(-60,-45)$ 和 $\\left(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta}\\right)=(-120,130)$（角度单位为度），以及宽度 $\\sigma_{\\phi}=\\sigma_{\\psi}=25$（度）。基础丝氨酸（“参数 (params)”）的势阱深度为 $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ 和 $d_{\\beta}^{(\\mathrm{Ser})}=2.0$。磷酸化丝氨酸（经“补丁 (Patch)”修饰）的势阱深度为 $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ 和 $d_{\\beta}^{(\\mathrm{pSer})}=3.2$。\n- 磷酸化补丁还增加了一个空间惩罚项，该项因磷酸基团的体积而对采用 $\\alpha$-螺旋的 $\\phi$ 角进行惩罚：\n  $$\n  E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right),\n  $$\n  其中 $\\mu_{\\phi,\\mathrm{steric}}=-60$，$\\sigma_{\\phi,\\mathrm{steric}}=15$，以及 $s_{0}=0.8$。对于未修饰的丝氨酸，此项为 $0$。\n- 环境可能为磷酸基团提供一个与附近正电荷的有利的定向相互作用，这可以近似地用一个以环境指定的目标 $\\psi_{0}$ 为中心、关于 $\\psi$ 的高斯函数来描述：\n  $$\n  E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right),\n  $$\n  其中 $\\sigma_{\\psi,\\mathrm{el}}=25$。该项以粗略的方式模拟了静电或类氢键的定向偏好。如果附近不存在正电荷，则设置 $k_{\\mathrm{el}}=0$。对于未修饰的丝氨酸，此项为 $0$。\n- 总能量为\n  $$\n  E_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right).\n  $$\n  此处 $\\mathbb{1}[\\cdot]$ 是指示函数，当条件为真时为 $1$，否则为 $0$。\n\n计算任务：\n- 在代码中为丝氨酸构建一个“参数 (params)”数据结构，其中包含 $d_{\\alpha}^{(\\mathrm{Ser})}$ 和 $d_{\\beta}^{(\\mathrm{Ser})}$ 以及共享的高斯中心和宽度。在代码中构建一个磷酸化“补丁 (Patch)”，当应用于丝氨酸参数时，可生成 pSer 参数 $d_{\\alpha}^{(\\mathrm{pSer})}$ 和 $d_{\\beta}^{(\\mathrm{pSer})}$，并添加上述带有常数的两个项 $E_{\\mathrm{steric}}^{(\\mathrm{pSer})}$ 和 $E_{\\mathrm{env}}^{(\\mathrm{pSer})}$。应用补丁不得改变打分函数的任何其他方面。\n- 实现一个在 $\\phi \\in \\{-180,-175,\\ldots,180\\}$ 和 $\\psi \\in \\{-180,-175,\\ldots,180\\}$（均为度）上的网格搜索，以在相同的环境参数下找到 Ser 和 pSer 的最低能量构象。\n- 对于下述每个测试用例，计算：\n  1. 能量最低的主链二面角 $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ 和 $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$，以度为单位。\n  2. 带符号的、折叠后的角度差 $\\Delta \\phi$ 和 $\\Delta \\psi$，每个都通过映射 $\\Delta \\theta \\mapsto \\left((\\Delta \\theta + 180) \\bmod 360\\right) - 180$ 折叠到 $(-180,180]$ 区间内，其中 $\\Delta \\theta = \\theta^{\\star}_{\\mathrm{pSer}} - \\theta^{\\star}_{\\mathrm{Ser}}$。\n  3. 能量变化 $\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$，以千卡/摩尔为单位。\n\n测试套件（三种环境）：\n- 情况1（理想路径）：附近的正电荷与类 $\\alpha$ 构象对齐。使用 $k_{\\mathrm{el}}=1.5$ 和 $\\psi_{0}=-60$。\n- 情况2（无定向稳定作用）：附近无正电荷。使用 $k_{\\mathrm{el}}=0.0$ 和 $\\psi_{0}=0.0$。\n- 情况3（靠近 $\\beta$ 的竞争性稳定作用）：较弱的正电荷与类 $\\beta$ 构象对齐。使用 $k_{\\mathrm{el}}=0.9$ 和 $\\psi_{0}=130.0$。\n\n要求的输出格式：\n- 您的程序必须生成一行，包含一个含有 $9$ 个数字的扁平列表：$\\left[\\Delta \\phi_{1},\\Delta \\psi_{1},\\Delta E_{1},\\Delta \\phi_{2},\\Delta \\psi_{2},\\Delta E_{2},\\Delta \\phi_{3},\\Delta \\psi_{3},\\Delta E_{3}\\right]$。\n- 角度必须四舍五入到一位小数（度）。能量必须四舍五入到三位小数（千卡/摩尔）。\n\n您的最终答案必须是一个完整的、可运行的 Python 程序，该程序构建 Ser 的“参数”，应用磷酸化“补丁”，对每个测试用例执行构象网格搜索，并以上述指定的确切格式打印结果。", "solution": "所提出的问题要求形式化并实现一个简化的、基于知识的能量函数，以预测单个氨基酸残基（在其标准状态（丝氨酸，Ser）和经过翻译后修饰（磷酸化丝氨酸，pSer）的状态下）的偏好主链构象。该任务植根于计算结构生物学的一个基本原则：分子的热力学有利构象对应于其势能面上的一个极小值。能量函数（或称打分函数）$E(\\boldsymbol{\\theta}; \\boldsymbol{\\lambda})$ 是一个数学模型，它近似于该势能，其中 $\\boldsymbol{\\theta}$ 代表系统的构象自由度，$\\boldsymbol{\\lambda}$ 是模型的参数。\n\n在此问题中，构象变量是主链二面角 $\\phi$ 和 $\\psi$。残基化学状态的变化（从 Ser 到 pSer）通过改变参数 $\\boldsymbol{\\lambda}$ 来建模。这类似于 Rosetta 等分子建模软件中使用的“参数文件 (parameter file)”和“补丁 (Patch)”系统，其中一套基础参数定义一个标准残基，而一个补丁则应用一种特定的修饰。\n\n我们的任务是为 Ser 和 pSer 构建能量函数，通过执行网格搜索找到最低能量构象 $(\\phi^{\\star}, \\psi^{\\star})$，然后量化在三种不同环境条件下由磷酸化引起的构象和能量变化。所有角度均以度为单位，能量以千卡/摩尔为单位。\n\n对于类型为 $r \\in \\{\\mathrm{Ser}, \\mathrm{pSer}\\}$ 的残基，其总能量由下式给出：\n$$\nE_{\\mathrm{total}}^{(r)}(\\phi,\\psi) \\;=\\; E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;+\\; \\mathbb{1}[r=\\mathrm{pSer}] \\left( E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) + E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\right)\n$$\n其中 $\\mathbb{1}[\\cdot]$ 是指示函数，当其参数为真时取值为 1，否则为 0。这意味着对于丝氨酸，只有 $E_{\\mathrm{bb}}$ 项起作用；而对于磷酸化丝氨酸，则应用了两个额外的“补丁”项。\n\n能量组分定义如下：\n1. **主链统计偏好，$E_{\\mathrm{bb}}^{(r)}(\\phi,\\psi)$**：该项模拟了肽主链的内在构象倾向，已知这些构象倾向于聚集在拉马钱德兰图的特定区域，即 $\\alpha$-螺旋和 $\\beta$-折叠区域。它被表述为两个高斯势阱的和，其中势阱的深度 $d_{\\alpha}^{(r)}$ 和 $d_{\\beta}^{(r)}$ 取决于残基类型 $r$。\n$$\nE_{\\mathrm{bb}}^{(r)}(\\phi,\\psi) \\;=\\; -d_{\\alpha}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\alpha}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\alpha}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n\\;-\\; d_{\\beta}^{(r)} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi-\\mu_{\\phi,\\beta}}{\\sigma_{\\phi}}\\right)^{2} - \\tfrac{1}{2}\\left(\\tfrac{\\psi-\\mu_{\\psi,\\beta}}{\\sigma_{\\psi}}\\right)^{2}\\right)\n$$\n公共参数是 $\\alpha$-区域的中心 $(\\mu_{\\phi,\\alpha},\\mu_{\\psi,\\alpha})=(-60,-45)$，$\\beta$-区域的中心 $(\\mu_{\\phi,\\beta},\\mu_{\\psi,\\beta})=(-120,130)$，以及宽度 $\\sigma_{\\phi}=\\sigma_{\\psi}=25$。\n对于丝氨酸，参数为 $d_{\\alpha}^{(\\mathrm{Ser})}=3.0$ 和 $d_{\\beta}^{(\\mathrm{Ser})}=2.0$，偏好 $\\alpha$-螺旋构象。\n磷酸化“补丁”将这些参数更改为 $d_{\\alpha}^{(\\mathrm{pSer})}=1.2$ 和 $d_{\\beta}^{(\\mathrm{pSer})}=3.2$，将偏好转向 $\\beta$-折叠构象。\n\n2. **空间惩罚，$E_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi)$**：此项仅为 pSer 添加，模拟了由庞大的磷酸基团引入的空间位阻，它特别对与 $\\alpha$-螺旋区域相关的紧密转角进行惩罚。它是一个以 $\\alpha$-螺旋区域的 $\\phi$ 值为中心的正高斯函数。\n$$\nE_{\\mathrm{steric}}^{(\\mathrm{pSer})}(\\phi) \\;=\\; + s_{0} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\phi - \\mu_{\\phi,\\mathrm{steric}}}{\\sigma_{\\phi,\\mathrm{steric}}}\\right)^{2}\\right)\n$$\n参数为振幅 $s_{0}=0.8$，中心 $\\mu_{\\phi,\\mathrm{steric}}=-60$，宽度 $\\sigma_{\\phi,\\mathrm{steric}}=15$。对于丝氨酸，此项为 $0$。\n\n3. **环境相互作用，$E_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi)$**：此项也仅为 pSer 添加，模拟了带负电的磷酸基团与蛋白质环境中附近的正电荷之间的定向静电或氢键相互作用。这种相互作用的强度是 $k_{\\mathrm{el}}$，并且它偏好一个特定的 $\\psi$ 角 $\\psi_{0}$。\n$$\nE_{\\mathrm{env}}^{(\\mathrm{pSer})}(\\psi; k_{\\mathrm{el}}, \\psi_{0}) \\;=\\; - k_{\\mathrm{el}} \\exp\\!\\left(-\\tfrac{1}{2}\\left(\\tfrac{\\psi - \\psi_{0}}{\\sigma_{\\psi,\\mathrm{el}}}\\right)^{2}\\right)\n$$\n宽度是 $\\sigma_{\\psi,\\mathrm{el}}=25$。参数 $k_{\\mathrm{el}}$ 和 $\\psi_{0}$ 由测试用例指定。对于丝氨酸，或者如果 $k_{\\mathrm{el}}=0$，此项为 $0$。\n\n为了找到最低能量构象，我们将执行网格搜索。搜索空间是一个由 $\\phi, \\psi \\in \\{-180, -175, \\ldots, 180\\}$ 定义的离散网格。对于三个测试用例中的每一个，我们将执行两次独立的网格搜索：一次是为丝氨酸找到 $(\\phi^{\\star}_{\\mathrm{Ser}},\\psi^{\\star}_{\\mathrm{Ser}})$ 和 $E_{\\min}^{(\\mathrm{Ser})}$，另一次是为具有指定环境参数 $(k_{\\mathrm{el}}, \\psi_{0})$ 的磷酸化丝氨酸找到 $(\\phi^{\\star}_{\\mathrm{pSer}},\\psi^{\\star}_{\\mathrm{pSer}})$ 和 $E_{\\min}^{(\\mathrm{pSer})}$。\n\n根据这些结果，我们为每种情况计算所需的输出：\n- 二面角的变化，$\\Delta \\phi = \\phi^{\\star}_{\\mathrm{pSer}} - \\phi^{\\star}_{\\mathrm{Ser}}$ 和 $\\Delta \\psi = \\psi^{\\star}_{\\mathrm{pSer}} - \\psi^{\\star}_{\\mathrm{Ser}}$。这些差异使用映射 $\\Delta \\theta \\mapsto ((\\Delta \\theta + 180) \\pmod{360}) - 180$ 被折叠到区间 $(-180, 180]$ 内。这确保了报告的是最短的角距离。\n- 最小能量的变化，$\\Delta E = E_{\\min}^{(\\mathrm{pSer})} - E_{\\min}^{(\\mathrm{Ser})}$。\n\n对所有三个测试用例重复此过程，并将得到的 9 个值（每种情况的 $\\Delta\\phi, \\Delta\\psi, \\Delta E$）收集、四舍五入到指定的精度（角度为 1 位小数，能量为 3 位小数）并呈现在一个单一的扁平列表中。该实现将使用数据结构来表示丝氨酸的基础“参数 (params)”和磷酸化的“补丁 (Patch)”，以模仿模块化建模框架的逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the conformational search and scoring problem for Serine and phospho-Serine.\n    \"\"\"\n\n    # --- Data Structures for Parameters (\"Params\" and \"Patch\") ---\n    \n    # Shared parameters for backbone statistical potential\n    bb_shared_params = {\n        'mu_phi_alpha': -60.0, 'mu_psi_alpha': -45.0,\n        'mu_phi_beta': -120.0, 'mu_psi_beta': 130.0,\n        'sigma_phi': 25.0, 'sigma_psi': 25.0,\n    }\n\n    # Base \"params\" file for Serine\n    serine_params = {\n        'type': 'Ser',\n        **bb_shared_params,\n        'd_alpha': 3.0,\n        'd_beta': 2.0,\n        # Patch-related flags are off by default\n        'has_steric_penalty': False,\n        'has_env_interaction': False,\n    }\n\n    # \"Patch\" for phosphorylation\n    pser_patch = {\n        'd_alpha': 1.2,\n        'd_beta': 3.2,\n        'has_steric_penalty': True,\n        's0_steric': 0.8,\n        'mu_phi_steric': -60.0,\n        'sigma_phi_steric': 15.0,\n        'has_env_interaction': True,\n        'sigma_psi_el': 25.0,\n    }\n\n    def apply_patch(base_params, patch):\n        \"\"\"Applies a patch to base parameters to create modified parameters.\"\"\"\n        patched_params = base_params.copy()\n        patched_params['type'] = 'pSer'\n        patched_params.update(patch)\n        return patched_params\n\n    # Create phospho-Serine parameters by applying the patch\n    pser_base_params = apply_patch(serine_params, pser_patch)\n\n    # --- Energy Functions ---\n\n    def E_bb(phi, psi, params):\n        \"\"\"Calculates backbone statistical energy.\"\"\"\n        term_alpha = -params['d_alpha'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_alpha']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_alpha']) / params['sigma_psi'])**2\n        )\n        term_beta = -params['d_beta'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_beta']) / params['sigma_phi'])**2\n            -0.5 * ((psi - params['mu_psi_beta']) / params['sigma_psi'])**2\n        )\n        return term_alpha + term_beta\n\n    def E_steric(phi, params):\n        \"\"\"Calculates steric penalty for pSer.\"\"\"\n        if not params['has_steric_penalty']:\n            return 0.0\n        return params['s0_steric'] * np.exp(\n            -0.5 * ((phi - params['mu_phi_steric']) / params['sigma_phi_steric'])**2\n        )\n\n    def E_env(psi, params, k_el, psi_0):\n        \"\"\"Calculates environmental interaction for pSer.\"\"\"\n        if not params['has_env_interaction'] or k_el == 0.0:\n            return 0.0\n        return -k_el * np.exp(-0.5 * ((psi - psi_0) / params['sigma_psi_el'])**2)\n\n    def total_energy(phi, psi, params, env_params):\n        \"\"\"Calculates the total energy for a given conformation.\"\"\"\n        k_el, psi_0 = env_params\n        energy = E_bb(phi, psi, params) + \\\n                 E_steric(phi, params) + \\\n                 E_env(psi, params, k_el, psi_0)\n        return energy\n        \n    # --- Grid Search and Calculation ---\n\n    def find_minimum_energy_conformation(params, env_params):\n        \"\"\"Performs a grid search to find the minimum energy conformation.\"\"\"\n        phi_grid = np.arange(-180.0, 180.1, 5.0)\n        psi_grid = np.arange(-180.0, 180.1, 5.0)\n        \n        min_energy = float('inf')\n        min_angles = (None, None)\n\n        for phi in phi_grid:\n            for psi in psi_grid:\n                E = total_energy(phi, psi, params, env_params)\n                if E  min_energy:\n                    min_energy = E\n                    min_angles = (phi, psi)\n        \n        return min_angles, min_energy\n\n    def wrap_angle(delta_theta):\n        \"\"\"Wraps an angular difference to the range (-180, 180].\"\"\"\n        return (delta_theta + 180.0) % 360.0 - 180.0\n\n    # --- Test Suite ---\n    test_cases = [\n        # (k_el, psi_0)\n        (1.5, -60.0),  # Case 1\n        (0.0, 0.0),    # Case 2\n        (0.9, 130.0),  # Case 3\n    ]\n\n    all_results = []\n    \n    # Find Serine minimum once (it's environment-independent)\n    ser_env_params = (0.0, 0.0) # k_el=0 for Serine\n    ser_min_angles, ser_min_energy = find_minimum_energy_conformation(serine_params, ser_env_params)\n    phi_star_ser, psi_star_ser = ser_min_angles\n\n    for case_env_params in test_cases:\n        # Find pSerine minimum for current environment\n        pser_min_angles, pser_min_energy = find_minimum_energy_conformation(pser_base_params, case_env_params)\n        phi_star_pser, psi_star_pser = pser_min_angles\n        \n        # Calculate differences\n        delta_phi = wrap_angle(phi_star_pser - phi_star_ser)\n        delta_psi = wrap_angle(psi_star_pser - psi_star_ser)\n        delta_E = pser_min_energy - ser_min_energy\n\n        # Round and append results\n        all_results.append(np.round(delta_phi, 1))\n        all_results.append(np.round(delta_psi, 1))\n        all_results.append(np.round(delta_E, 3))\n\n    # --- Final Output ---\n    # Convert all numbers to strings for joining, handling -0.0\n    # The format 'g' prevents scientific notation for small numbers.\n    results_str = [f\"{x:.1f}\" if i % 3 != 2 else f\"{x:.3f}\" for i, x in enumerate(all_results)]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2381408"}]}