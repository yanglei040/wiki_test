{"hands_on_practices": [{"introduction": "在深入研究无标度网络的复杂特性之前，我们必须首先掌握其最基本的构成要素。网络中一个节点最核心的属性是它的“度”，即该节点拥有的连接数。这个练习将引导你通过一个假设的小型蛋白质相互作用网络，亲手计算每个蛋白质（节点）的度，并进一步分析网络连接的异质性，为你理解更高级的网络概念（如“枢纽节点”）打下坚实的基础。", "problem": "一位系统生物学家正在研究一个由七种蛋白质组成的新近表征的小型调控网络，我们将其标记为 P1 至 P7。来自酵母双杂交筛选的实验数据已经确定了这些蛋白质之间的一系列物理相互作用。这些相互作用被认为是无向的，意味着蛋白质 A 和蛋白质 B 之间的相互作用是两者共享的单个连接。观测到的完整相互作用列表如下：\n\nP1 与 P2 相互作用\nP1 与 P3 相互作用\nP1 与 P4 相互作用\nP2 与 P5 相互作用\nP3 与 P4 相互作用\nP3 与 P6 相互作用\nP4 与 P7 相互作用\nP5 与 P6 相互作用\nP6 与 P7 相互作用\n\n在网络分析中，一个基本属性是节点的度，即它拥有的连接数。为了表征网络的异质性，我们可以将连接最多的节点（中心节点）与平均连接度进行比较。计算该网络中发现的最大度与该网络平均度的比率。请将您的答案以一个四舍五入到三位有效数字的单一数字形式报告。", "solution": "该网络有七个节点，标记为 $P1$ 至 $P7$，且相互作用是无向边。根据给定的相互作用，通过计算每个节点的关联边数来确定其度：\n$\\deg(P1)=3$, $\\deg(P2)=2$, $\\deg(P3)=3$, $\\deg(P4)=3$, $\\deg(P5)=2$, $\\deg(P6)=3$, $\\deg(P7)=2$。\n因此，最大度为\n$$d_{\\max}=3.$$\n总边数是 $m=9$。根据握手引理，度数之和等于 $2m$，所以 $n=7$ 个节点的平均度为\n$$\\bar{d}=\\frac{1}{n}\\sum_{i=1}^{n}\\deg(P_{i})=\\frac{2m}{n}=\\frac{2\\times 9}{7}=\\frac{18}{7}.$$\n因此，所要求的最大度与平均度的比率是\n$$r=\\frac{d_{\\max}}{\\bar{d}}=\\frac{3}{18/7}=\\frac{7}{6}\\approx 1.166\\ldots$$\n四舍五入到三位有效数字，结果是 $1.17$。", "answer": "$$\\boxed{1.17}$$", "id": "1464939"}, {"introduction": "理解了节点的度（degree）之后，下一个关键问题是：网络是如何演化并形成其结构的？此练习将向你介绍无标度网络增长的核心机制——“优先连接”（preferential attachment），也常被称为“富者愈富”现象。通过计算一个新节点连接到现有网络中不同节点的概率，你将直观地感受到为何网络中会自然涌现出少数拥有极高连接数的“枢纽”节点。", "problem": "在网络理论的研究中，许多现实世界网络（例如引文网络或万维网）的增长可以通过优先连接过程来建模。考虑一个由五篇基础论文组成的小型、孤立的引文网络。每篇论文的重要性由其度数来量化，度数代表其在该网络中的连接数。这五篇论文的度数分别为 $4, 3, 2, 2,$ 和 $1$。\n\n一篇新的研究论文正在撰写中，它将引用这五篇基础论文中的一篇。该引文过程的模型指出，新论文连接到任何一篇给定基础论文的概率与该基础论文的度数成正比。\n\n计算新论文将引用现有网络中最具影响力的论文（即度数为4的那篇）的概率。请将您的答案表示为最简分数。", "solution": "在优先连接模型下，新论文引用某一篇给定基础论文的概率与该论文的度数成正比。设度数分别为 $k_{1}=4$, $k_{2}=3$, $k_{3}=2$, $k_{4}=2$, 和 $k_{5}=1$。总度数是各项度数之和\n$$\n\\sum_{i=1}^{5} k_{i} = 4+3+2+2+1 = 12.\n$$\n引用度数为 $4$ 的论文的概率为\n$$\nP = \\frac{k_{1}}{\\sum_{i=1}^{5} k_{i}} = \\frac{4}{12} = \\frac{1}{3}.\n$$\n因此，所求的概率为最简分数 $\\frac{1}{3}$。", "answer": "$$\\boxed{\\frac{1}{3}}$$", "id": "1705406"}, {"introduction": "现在，让我们将理论付诸实践。在真实的生物信息学研究中，我们获得的实验数据（如蛋白质相互作用网络）往往是不完整的。这个练习要求你扮演一名计算生物学家的角色，利用你刚刚学到的优先连接原理来开发一个“链接预测”算法。通过对一个不完整的蛋白质相互作用网络中缺失的连接进行评分和排序，你将模拟计算系统生物学中的一项关键任务，并体会到理论模型如何转化为强大的预测工具。", "problem": "给定一个表示不完整的蛋白质-蛋白质相互作用（PPI）网络的无向简单图。假设其底层的完整网络是无标度的，其度分布可由幂律近似。在此假设下，使用一个基于度的连接可能性模型。对于任意未被观察到是边的无序节点对 $\\{u,v\\}$，定义一个链接可能性分数 $S(u,v) = k_u \\cdot k_v$，其中 $k_u$ 和 $k_v$ 是从观察到的（不完整的）图中计算出的度。该图没有自环，也没有多重边。节点由从 $0$ 到 $N-1$（含）的整数标记。对未观察到的节点对进行排序时，首先按 $S(u,v)$ 的降序排序；若分数相同，则必须按 $(u,v)$（其中 $u  v$）的字典序升序对它们进行排序。您的任务是编写一个程序，该程序给定一个观察到的网络 $E_{\\text{obs}}$、一个真实（完整）网络 $E_{\\text{true}}$，以及一个整数 $L$，通过计算由您的链接预测算法预测的前 $L$ 个最有可能的缺失边中有多少是真正的缺失边（即 $E_{\\text{true}}$ 中存在但在 $E_{\\text{obs}}$ 中不存在的边），来评估该算法的准确性。", "solution": "该解决方案旨在通过实现一个链接预测算法来解决问题，该算法基于观察到的图的度来计算未观察到的节点对之间的链接可能性。其核心逻辑遵循以下步骤，并应用于每个测试用例：\n\n1.  **计算度数**：首先，我们遍历所有观察到的边 $E_{obs}$，为图中的每个节点 $u$ 计算其度 $k_u$。\n\n2.  **识别候选对并评分**：接下来，我们枚举所有可能的节点对 $(u, v)$（其中 $u  v$ 以避免重复），并检查该对是否不在 $E_{obs}$ 中。对于每个这样的“未观察到的”对，我们根据给定的公式 $S(u,v) = k_u \\cdot k_v$ 计算其链接可能性分数。\n\n3.  **对候选对进行排序**：我们根据问题中指定的双重排序标准对所有未观察到的对进行排序：\n    a.  主要按分数 $S(u,v)$ **降序**排序。\n    b.  对于分数相同的对，次要按节点对 $(u,v)$ 的**字典序升序**排序。\n\n4.  **选择最高预测**：从排序后的列表中，我们选择前 $L$ 个对作为最有可能缺失的链接。\n\n5.  **评估预测**：我们通过将预测的链接集与真实的缺失链接集 $E_{miss}$（定义为 $E_{true}$ 和 $E_{obs}$ 之间的差集）进行比较来评估我们的预测。正确预测的数量就是这两个集合的交集的大小。\n\n**以测试用例 A 为例：**\n\n*   **输入**: $N=6$, $L=2$, $E_{obs} = \\{(0, 1), (0, 2), (0, 3), (1, 2), (4, 5)\\}$, $E_{true} = \\{(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (2, 3), (4, 5)\\}$.\n*   **1. 计算度数**: 从 $E_{obs}$ 我们得到度数: $k_0=3, k_1=2, k_2=2, k_3=1, k_4=1, k_5=1$。\n*   **2. 候选对和分数**: 未观察到的对中，分数较高的包括：\n    *   $S(0,4) = k_0 \\cdot k_4 = 3 \\cdot 1 = 3$\n    *   $S(0,5) = k_0 \\cdot k_5 = 3 \\cdot 1 = 3$\n    *   $S(1,3) = k_1 \\cdot k_3 = 2 \\cdot 1 = 2$\n    *   $S(2,3) = k_2 \\cdot k_3 = 2 \\cdot 1 = 2$\n*   **3. 排序**:\n    *   分数最高的对是 $S=3$ 的 $(0,4)$ 和 $(0,5)$。按字典序排序为 $(0,4)$ 在前。\n    *   接下来是分数 $S=2$ 的对。\n    *   排序后的列表开头为：$[(0,4), (0,5), (1,3), \\dots]$。\n*   **4. 预测**: 选择前 $L=2$ 的预测：$\\{(0,4), (0,5)\\}$。\n*   **5. 评估**: 真实的缺失链接是 $E_{miss} = E_{true} \\setminus E_{obs} = \\{(0,4), (2,3)\\}$。我们的预测 $\\{(0,4), (0,5)\\}$ 与 $E_{miss}$ 的交集是 $\\{(0,4)\\}$。因此，正确预测的数量是 1。\n\n对所有三个测试用例应用此逻辑，我们得到的结果分别是 $1, 0, 1$。因此，最终输出为 `[1,0,1]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the link prediction problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Edges are represented as sorted tuples (u, v) with u  v for consistency.\n    test_cases = [\n        # Test Case A\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (0, 2), (0, 3), (1, 2), (4, 5)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (0, 4), (1, 2), (2, 3), (4, 5)]),\n            \"L\": 2,\n        },\n        # Test Case B\n        {\n            \"N\": 6,\n            \"E_obs\": set([(0, 1), (1, 2), (3, 4)]),\n            \"E_true\": set([(0, 1), (1, 2), (2, 3), (3, 4), (4, 5)]),\n            \"L\": 3,\n        },\n        # Test Case C\n        {\n            \"N\": 5,\n            \"E_obs\": set([(0, 1), (0, 2), (1, 2)]),\n            \"E_true\": set([(0, 1), (0, 2), (0, 3), (1, 2), (2, 3)]),\n            \"L\": 4,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case[\"N\"]\n        E_obs = case[\"E_obs\"]\n        E_true = case[\"E_true\"]\n        L = case[\"L\"]\n\n        # 1. Compute the degree k_u for each node u from E_obs.\n        degrees = np.zeros(N, dtype=int)\n        for u, v in E_obs:\n            degrees[u] += 1\n            degrees[v] += 1\n        \n        # 2. Enumerate all non-observed pairs and compute S(u,v).\n        non_observed_pairs = []\n        for u in range(N):\n            for v in range(u + 1, N):\n                if (u, v) not in E_obs:\n                    score = degrees[u] * degrees[v]\n                    # Store as a tuple for sorting: (score, u, v)\n                    non_observed_pairs.append((score, u, v))\n        \n        # 3. Rank all non-observed pairs.\n        # Sort by decreasing S(u,v) (score), then ascending (u,v).\n        # We achieve this by sorting on (-score, u, v).\n        non_observed_pairs.sort(key=lambda x: (-x[0], x[1], x[2]))\n        \n        # 4. Select the top L pairs as predicted edges.\n        # The number of predictions cannot exceed the number of available candidate pairs.\n        num_predictions = min(L, len(non_observed_pairs))\n        predicted_edges = set()\n        for i in range(num_predictions):\n            score, u, v = non_observed_pairs[i]\n            predicted_edges.add((u, v))\n            \n        # 5. Count how many predicted pairs are in E_miss.\n        E_miss = E_true.difference(E_obs)\n        correct_predictions = len(predicted_edges.intersection(E_miss))\n        \n        results.append(correct_predictions)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428013"}]}