{"hands_on_practices": [{"introduction": "ATAC-seq 数据提供了近乎单碱基对分辨率的染色质可及性信息，使得我们能够精细地研究 DNA 上的蛋白质结合模式。转座酶切割位点的特定模式，例如经典的“足迹”（即切割信号的减弱区域），是蛋白质结合的有力证据。本练习将引导您构建并比较两个定量模型，以区分转录因子（TF）的不同结合模式（协同结合与独立结合），从而磨练您在生物信息学中进行基于似然的模型选择和假设检验的关键技能 [@problem_id:2378307]。", "problem": "考虑一个一维基因组窗口，建模为整数位置 $i \\in \\{0,1,\\dots,L-1\\}$，其中 $L$ 是一个正整数。在每个位置 $i$，从 ATAC-seq（转座酶可及染色质测序）实验中观测到一个整数切割计数 $c_i \\ge 0$。给定两个假定的基序中心，其整数位置为 $m_1$ 和 $m_2$（单位为碱基对）。对于每个提供的测试用例，您必须判断观测到的计数是更符合跨越两个基序之间区域的单个协同转录因子（TF）结合足迹，还是更符合两个基序附近的两个独立TF足迹。该决策必须仅基于下文定义的概率生成模型，并以纯数学术语表达。\n\n模型假设和定义。在任一假设下，不同位置的切割是独立的，并遵循具有位置特异性速率的泊松分布。设背景切割速率为 $b > 0$，足迹衰减因子为 $f \\in (0,1)$，侧翼增强振幅为 $a \\ge 0$，高斯扩展为 $s > 0$（单位为碱基对），足迹半宽度为正整数 $w$。对于任意实数 $x$，定义离散高斯形状 $G(x) = \\exp\\!\\left(-\\dfrac{x^2}{2 s^2}\\right)$。\n\n定义内部集合。令 $I_1 = \\{i \\in \\mathbb{Z} : m_1 - w \\le i \\le m_1 + w\\}$ 且 $I_2 = \\{i \\in \\mathbb{Z} : m_2 - w \\le i \\le m_2 + w\\}$。在协同假设 $H_C$ 下，足迹内部是单个区间 $I_C = \\{i \\in \\mathbb{Z} : \\min(m_1,m_2) - w \\le i \\le \\max(m_1,m_2) + w\\}$，其两个外边缘位于 $e_1 = \\min(m_1,m_2) - w$ 和 $e_2 = \\max(m_1,m_2) + w$。在独立假设 $H_I$ 下，足迹内部是集合的并集 $I_I = I_1 \\cup I_2$，其四个边缘位于 $e_{1a} = m_1 - w$、$e_{1b} = m_1 + w$、$e_{2a} = m_2 - w$ 和 $e_{2b} = m_2 + w$。\n\n定义位置特异性泊松速率。对于每个位置 $i \\in \\{0,1,\\dots,L-1\\}$，\n- 在 $H_C$ 下，\n$$\n\\lambda_i^{(C)} \\;=\\; b \\cdot \\left( f \\cdot \\mathbf{1}_{\\{i \\in I_C\\}} \\;+\\; 1 \\cdot \\mathbf{1}_{\\{i \\notin I_C\\}} \\right) \\;+\\; b\\,a \\left[ G(i - e_1) + G(i - e_2) \\right],\n$$\n- 在 $H_I$ 下，\n$$\n\\lambda_i^{(I)} \\;=\\; b \\cdot \\left( f \\cdot \\mathbf{1}_{\\{i \\in I_I\\}} \\;+\\; 1 \\cdot \\mathbf{1}_{\\{i \\notin I_I\\}} \\right) \\;+\\; b\\,a \\left[ G(i - e_{1a}) + G(i - e_{1b}) + G(i - e_{2a}) + G(i - e_{2b}) \\right].\n$$\n\n对于观测到的计数 $\\{c_i\\}_{i=0}^{L-1}$，每种假设下数据的概率为\n$$\n\\mathbb{P}(\\{c_i\\}\\mid H) \\;=\\; \\prod_{i=0}^{L-1} \\frac{\\left(\\lambda_i^{(H)}\\right)^{c_i} e^{-\\lambda_i^{(H)}}}{c_i!},\n$$\n其中 $H \\in \\{H_C, H_I\\}$。对于每个测试用例，您必须判断对于给定的计数和参数，$H_C$ 是否比 $H_I$ 产生更大的概率。\n\n要求的输出格式。对于整套测试用例，您的程序应生成单行输出，其中包含一个由方括号括起来、逗号分隔的布尔值结果列表（例如，“[True,False,True]”）。对于每个测试用例，如果协同假设 $H_C$ 比独立假设 $H_I$ 更可能，则输出布尔值 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n所有位置都是以碱基对为单位的整数，计数是无量纲的整数。不涉及其他物理单位。\n\n参数和测试套件。对所有测试用例使用相同的全局参数：$L = 41$，$b = 5.0$，$f = 0.2$，$a = 1.2$，$s = 1.0$，以及 $w = 3$。测试用例如下：\n\n测试用例1：\n- 基序中心：$m_1 = 15$, $m_2 = 25$。\n- 观测计数 $\\{c_i\\}_{i=0}^{40}$：\n[$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$12$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$1$,$12$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$]。\n\n测试用例2：\n- 基序中心：$m_1 = 15$, $m_2 = 25$。\n- 观测计数 $\\{c_i\\}_{i=0}^{40}$：\n[$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$11$,$1$,$1$,$1$,$1$,$1$,$11$,$5$,$5$,$5$,$11$,$1$,$1$,$1$,$1$,$1$,$11$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$]。\n\n测试用例3：\n- 基序中心：$m_1 = 20$, $m_2 = 23$。\n- 观测计数 $\\{c_i\\}_{i=0}^{40}$：\n[$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$9$,$3$,$3$,$3$,$3$,$3$,$3$,$3$,$3$,$9$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$,$5$]。\n\n您的程序必须使用上述模型实现决策，并为这三个测试用例生成符合所描述的确切输出格式的单行布尔值列表。", "solution": "所呈现的问题是计算生物学领域中一个定义明确且科学有效的任务。它要求在两种竞争性假设——$H_C$（协同结合）和 $H_I$（独立结合）——之间做出决策，以解释特定基因组窗口内的 ATAC-seq 切割计数观测数据 $\\{c_i\\}$。决策将通过比较每种假设下数据的后验概率来做出。假设 $H_C$ 和 $H_I$ 的先验概率相等，这等同于比较似然 $\\mathbb{P}(\\{c_i\\}\\mid H_C)$ 和 $\\mathbb{P}(\\{c_i\\}\\mid H_I)$。\n\n该模型的核心假设是：每个位置 $i$ 的切割计数 $c_i$ 是一个独立的随机变量，从具有位置依赖速率参数 $\\lambda_i$ 的泊松分布中抽取。$\\lambda_i$ 的具体函数形式在两种假设 $H_C$ 和 $H_I$ 之间有所不同，以捕捉不同的生物物理情景。\n\n在假设 $H \\in \\{H_C, H_I\\}$ 下，观测到整个数据集 $\\{c_i\\}_{i=0}^{L-1}$ 的似然由各个泊松概率的乘积给出：\n$$\n\\mathbb{P}(\\{c_i\\}\\mid H) = \\prod_{i=0}^{L-1} \\frac{\\left(\\lambda_i^{(H)}\\right)^{c_i} e^{-\\lambda_i^{(H)}}}{c_i!}\n$$\n直接计算和比较这些似然可能会因许多小概率的乘积而导致数值不稳定，从而可能导致浮点数下溢。一种标准的、数学上等效的方法是比较对数似然。由于自然对数是严格单调函数，不等式 $\\mathbb{P}(\\{c_i\\}\\mid H_C) > \\mathbb{P}(\\{c_i\\}\\mid H_I)$ 等价于 $\\log\\mathbb{P}(\\{c_i\\}\\mid H_C) > \\log\\mathbb{P}(\\{c_i\\}\\mid H_I)$。\n\n对数似然 $\\mathcal{L}(H)$ 为：\n$$\n\\mathcal{L}(H) = \\log \\mathbb{P}(\\{c_i\\}\\mid H) = \\sum_{i=0}^{L-1} \\left( c_i \\log(\\lambda_i^{(H)}) - \\lambda_i^{(H)} - \\log(c_i!) \\right)\n$$\n在比较 $\\mathcal{L}(H_C)$ 和 $\\mathcal{L}(H_I)$ 时，$\\sum_{i=0}^{L-1} \\log(c_i!)$ 项对两者是共同的，可以消去。决策规则简化为比较简化对数似然分数，我们可将其表示为 $S_H$：\n$$\nS_H = \\sum_{i=0}^{L-1} \\left( c_i \\log(\\lambda_i^{(H)}) - \\lambda_i^{(H)} \\right)\n$$\n如果 $S_C > S_I$，则协同假设 $H_C$ 被认为更可能。\n\n因此，解决方案要求对每个测试用例系统地计算速率向量 $\\{\\lambda_i^{(C)}\\}$ 和 $\\{\\lambda_i^{(I)}\\}$，然后计算并比较它们各自的分数 $S_C$ 和 $S_I$。\n\n每个测试用例的逐步过程：\n\n1.  **定义常量和位置向量**：全局参数 $L=41, b=5.0, f=0.2, a=1.2, s=1.0, w=3$ 是固定的。整数位置由向量 $i \\in \\{0, 1, ..., 40\\}$ 表示。高斯形状函数是 $G(x) = \\exp(-x^2 / (2s^2))$。\n\n2.  **计算假设 $H_C$ 下的速率**：\n    - 对于给定的基序中心 $m_1$ 和 $m_2$，确定协同足迹的边界：$e_1 = \\min(m_1, m_2) - w$ 和 $e_2 = \\max(m_1, m_2) + w$。\n    - 协同足迹的内部是整数集合 $I_C = [e_1, e_2]$。\n    - 对于每个位置 $i$，计算速率 $\\lambda_i^{(C)}$。该速率由基础部分和增强部分组成。\n        - 基础部分对足迹本身进行建模：对于 $i \\in I_C$，它是 $b \\cdot f$（衰减）；对于 $i \\notin I_C$，它是 $b$（背景）。\n        - 增强部分对足迹边缘处增加的切割概率进行建模：$b \\cdot a \\cdot [G(i - e_1) + G(i - e_2)]$。\n    - 总速率为 $\\lambda_i^{(C)} = b \\cdot (f \\cdot \\mathbf{1}_{\\{i \\in I_C\\}} + \\mathbf{1}_{\\{i \\notin I_C\\}}) + b \\cdot a \\cdot [G(i - e_1) + G(i - e_2)]$。\n\n3.  **计算假设 $H_I$ 下的速率**：\n    - 独立结合假设对两个独立的足迹进行建模。四个边缘是 $e_{1a} = m_1 - w$、$e_{1b} = m_1 + w$、$e_{2a} = m_2 - w$ 和 $e_{2b} = m_2 + w$。\n    - 独立足迹的内部是两个集合的并集，$I_I = [m_1-w, m_1+w] \\cup [m_2-w, m_2+w]$。\n    - 对于每个位置 $i$，计算速率 $\\lambda_i^{(I)}$。\n        - 基础部分对于 $i \\in I_I$ 是 $b \\cdot f$，对于 $i \\notin I_I$ 是 $b$。\n        - 增强部分源自所有四个边缘：$b \\cdot a \\cdot [G(i - e_{1a}) + G(i - e_{1b}) + G(i - e_{2a}) + G(i - e_{2b})]$。\n    - 总速率为 $\\lambda_i^{(I)} = b \\cdot (f \\cdot \\mathbf{1}_{\\{i \\in I_I\\}} + \\mathbf{1}_{\\{i \\notin I_I\\}}) + b \\cdot a \\cdot [G(i - e_{1a}) + G(i - e_{1b}) + G(i - e_{2a}) + G(i - e_{2b})]$。\n\n4.  **计算分数并得出结论**：\n    - 使用观测到的计数 $\\{c_i\\}$ 和计算出的速率向量 $\\{\\lambda_i^{(C)}\\}$ 和 $\\{\\lambda_i^{(I)}\\}$，计算两个分数：\n      $S_C = \\sum_{i=0}^{L-1} (c_i \\log(\\lambda_i^{(C)}) - \\lambda_i^{(C)})$\n      $S_I = \\sum_{i=0}^{L-1} (c_i \\log(\\lambda_i^{(I)}) - \\lambda_i^{(I)})$\n    - 该测试用例的结果是表达式 $S_C > S_I$ 的布尔值。\n\n对提供的三个测试用例中的每一个都实施此过程，并将得到的布尔值收集到一个列表中以供最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the chromatin accessibility model comparison problem.\n    \"\"\"\n    # Global parameters\n    L = 41\n    b = 5.0\n    f = 0.2\n    a = 1.2\n    s = 1.0\n    w = 3\n\n    # Test cases\n    test_cases = [\n        {\n            \"m1\": 15, \"m2\": 25,\n            \"counts\": np.array([5,5,5,5,5,5,5,5,5,5,5,5,12,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,12,5,5,5,5,5,5,5,5,5,5,5,5])\n        },\n        {\n            \"m1\": 15, \"m2\": 25,\n            \"counts\": np.array([5,5,5,5,5,5,5,5,5,5,5,5,11,1,1,1,1,1,11,5,5,5,11,1,1,1,1,1,11,5,5,5,5,5,5,5,5,5,5,5,5])\n        },\n        {\n            \"m1\": 20, \"m2\": 23,\n            \"counts\": np.array([5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,9,3,3,3,3,3,3,3,3,9,5,5,5,5,5,5,5,5,5,5,5,5,5,5])\n        }\n    ]\n\n    results = []\n    \n    # Position vector\n    i_vals = np.arange(L)\n    \n    # Gaussian shape function\n    def G(x):\n        return np.exp(-x**2 / (2 * s**2))\n\n    for case in test_cases:\n        m1 = case[\"m1\"]\n        m2 = case[\"m2\"]\n        counts = case[\"counts\"]\n\n        # -----------------------------------------------\n        # Hypothesis H_C: Cooperative Binding\n        # -----------------------------------------------\n        m_min, m_max = min(m1, m2), max(m1, m2)\n        e1 = m_min - w\n        e2 = m_max + w\n        \n        # Indicator for points inside the cooperative footprint\n        is_in_Ic = (i_vals >= e1)  (i_vals = e2)\n        \n        # Base rate for H_C\n        base_rate_C = np.where(is_in_Ic, b * f, b)\n        \n        # Enhancement for H_C\n        enhancement_C = b * a * (G(i_vals - e1) + G(i_vals - e2))\n        \n        # Total rate vector for H_C\n        lambda_C = base_rate_C + enhancement_C\n        \n        #\n        # Log-likelihood score for H_C (ignoring constant log(c_i!) term)\n        # Note: We must handle cases where lambda is zero, though the model ensures lambda > 0.\n        # Likewise for counts being zero, 0 * log(lambda) = 0.\n        log_likelihood_C = np.sum(counts * np.log(lambda_C) - lambda_C)\n\n        # -----------------------------------------------\n        # Hypothesis H_I: Independent Binding\n        # -----------------------------------------------\n        e1a = m1 - w\n        e1b = m1 + w\n        e2a = m2 - w\n        e2b = m2 + w\n        \n        # Indicator for points inside either independent footprint\n        is_in_I1 = (i_vals >= e1a)  (i_vals = e1b)\n        is_in_I2 = (i_vals >= e2a)  (i_vals = e2b)\n        is_in_Ii = is_in_I1 | is_in_I2\n        \n        # Base rate for H_I\n        base_rate_I = np.where(is_in_Ii, b * f, b)\n\n        # Enhancement for H_I\n        enhancement_I = b * a * (G(i_vals - e1a) + G(i_vals - e1b) + G(i_vals - e2a) + G(i_vals - e2b))\n        \n        # Total rate vector for H_I\n        lambda_I = base_rate_I + enhancement_I\n\n        # Log-likelihood score for H_I\n        log_likelihood_I = np.sum(counts * np.log(lambda_I) - lambda_I)\n\n        # -----------------------------------------------\n        # Decision\n        # -----------------------------------------------\n        results.append(log_likelihood_C > log_likelihood_I)\n\n    # Final output as per specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2378307"}, {"introduction": "在能够解释局部信号特征之后，一个更宏大的目标是对整个基因组进行功能性状态的注释。不同的染色质状态，如开放染色质、核小体阵列或异染色质，会产生独特的 ATAC-seq 信号特征（例如，片段长度和信号密度）。隐马尔可夫模型（HMM）是对此类具有潜在隐藏状态的序列数据进行建模的经典且强大的工具。本练习将要求您实现维特比（Viterbi）算法——一种生物信息学中的基础动态规划方法——来从观测数据中解码最可能的染色质状态序列 [@problem_id:2378334]。这个练习将理论与实用的基因组分析紧密联系起来。", "problem": "给定一个简化的生成模型，用于描述沿一维基因组坐标系的“使用测序技术的转座酶可及性染色质分析 (ATAC-seq)”片段特征。目标是使用隐马尔可夫模型 (HMM)，基于在每个基因组位置观察到的两个特征：以碱基对为单位的片段长度和局部片段密度（固定宽度窗口内的计数），将基因组分割成离散的染色质可及性状态。三个隐藏状态是：开放染色质、核小体阵列染色质和不可及染色质。每个状态都发射一个由一对值组成的观测值：片段长度（以碱基对为单位）和计数（无量纲）。您的任务是在给定固定 HMM 参数的情况下，实现 Viterbi 解码算法，为一系列观测值推断出最可能的隐藏状态序列。\n\n从隐马尔可夫模型的核心定义以及在每个位置给定隐藏状态的条件下观测值是独立生成的假设出发。假设片段长度由高斯（正态）分布建模，计数由泊松分布建模，并且在给定隐藏状态的条件下，这两个特征是独立的，因此联合发射概率是这两个分布的乘积。在您的设计中，仅使用高斯密度和泊松概率质量函数的定义以及转移的马尔可夫性质来推导所需的动态规划递推关系。不要使用任何外部训练或参数估计；所有模型参数都在下面提供。\n\n模型规格：\n- 隐藏状态：开放染色质、核小体阵列染色质、不可及染色质，分别索引为 $0$、$1$ 和 $2$。\n- 初始状态概率：$\\pi = \\left[\\tfrac{1}{3}, \\tfrac{1}{3}, \\tfrac{1}{3}\\right]$。\n- 状态转移矩阵 $A$（行是当前状态，列是下一个状态）：\n  - 从状态 $0$：到 $0$ 的概率为 $0.96$，到 $1$ 的概率为 $0.02$，到 $2$ 的概率为 $0.02$。\n  - 从状态 $1$：到 $0$ 的概率为 $0.02$，到 $1$ 的概率为 $0.96$，到 $2$ 的概率为 $0.02$。\n  - 从状态 $2$：到 $0$ 的概率为 $0.02$，到 $1$ 的概率为 $0.02$，到 $2$ 的概率为 $0.96$。\n- 每个状态 $s \\in \\{0,1,2\\}$ 的发射参数：\n  - 片段长度 $x$（以碱基对为单位）遵循均值为 $\\mu_s$、标准差为 $\\sigma_s$ 的正态分布：\n    - 状态 $0$：$\\mu_0 = 50$，$\\sigma_0 = 15$。\n    - 状态 $1$：$\\mu_1 = 200$，$\\sigma_1 = 25$。\n    - 状态 $2$：$\\mu_2 = 300$，$\\sigma_2 = 40$。\n  - 计数 $k$ 遵循速率为 $\\lambda_s$ 的泊松分布：\n    - 状态 $0$：$\\lambda_0 = 8$。\n    - 状态 $1$：$\\lambda_1 = 3$。\n    - 状态 $2$：$\\lambda_2 = 0.3$。\n- 给定隐藏状态下特征的条件独立性：对于给定的状态 $s$，观测值 $(x,k)$ 的联合发射密度为 $p(x,k \\mid s) = p_{\\text{Normal}}(x \\mid \\mu_s,\\sigma_s) \\cdot p_{\\text{Poisson}}(k \\mid \\lambda_s)$。\n\n测试套件：\n- 测试用例 $1$（正常路径，长度 $8$；片段长度单位为碱基对，计数无单位）：\n  - 观测值：$[(55, 9), (48, 7), (60, 8), (195, 3), (210, 4), (185, 3), (330, 0), (345, 1)]$。\n- 测试用例 $2$（边界条件，长度 $1$）：\n  - 观测值：$[(52, 8)]$。\n- 测试用例 $3$（转移行为，长度 $5$）：\n  - 观测值：$[(50, 8), (62, 7), (70, 6), (205, 4), (198, 3)]$。\n\n您的程序必须：\n- 仅使用正态密度和泊松概率质量函数的定义以及马尔可夫性质，为所提供的具有上述参数的 HMM 在对数空间中实现数值稳定的 Viterbi 解码。\n- 将每个观测序列解码为最可能的状态序列，使用状态索引 $0$ 代表开放，$1$ 代表核小体阵列，$2$ 代表不可及。\n- 生成单行输出，其中包含所有测试用例的已解码状态序列，格式为方括号括起来的逗号分隔列表。例如，格式必须像 $[\\,[s_{1,1}, s_{1,2}, \\dots],\\,[s_{2,1}, \\dots],\\,[s_{3,1}, \\dots]\\,]$，其中 $s_{i,j}$ 是整数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例表示为一个整数列表，且不含任何附加文本。例如：$[[0,0,1],[1],[2,2,2]]$。\n\n所有片段长度必须解释为碱基对，计数是无量纲的，概率是无单位的。最终输出是表示状态索引的无量纲整数。", "solution": "所呈现的问题是隐马尔可夫模型 (HMM) 的一个典型应用，即将一系列观测值分割成一个生成这些观测值的隐藏状态序列。具体来说，我们必须根据简化的 ATAC-seq 实验的一系列观测值，找到最可能的染色质可及性状态序列。完成此任务的合适算法是 Viterbi 算法，它通过动态规划找到这个最可能的状态序列。对数值稳定性的要求规定所有计算都必须在对数空间中进行，以防止因多个小概率值相乘而导致的算术下溢。\n\n首先，我们形式化指定的隐马尔可夫模型的组件。\n设隐藏状态集合为 $S = \\{s_0, s_1, s_2\\}$，分别对应于“开放”、“核小体阵列”和“不可及”染色质，由 $i, j \\in \\{0, 1, 2\\}$ 索引。\n观测序列为 $O = (o_1, o_2, \\ldots, o_T)$，其中 $T$ 是序列的长度。每个观测值 $o_t$ 是一对 $(x_t, k_t)$，其中 $x_t$ 是片段长度，$k_t$ 是局部片段计数。\n\nHMM 由以下参数定义：\n1.  **初始状态概率 ($\\pi$)**：在状态 $s_i$ 开始的概率是 $\\pi_i = P(q_1 = s_i)$。问题指定了均匀的初始分布：$\\pi = [\\frac{1}{3}, \\frac{1}{3}, \\frac{1}{3}]$。在对数空间中，对于所有 $i$，$\\log(\\pi_i) = -\\log(3)$。\n\n2.  **状态转移概率 ($A$)**：从状态 $s_i$ 转移到状态 $s_j$ 的概率是 $A_{ij} = P(q_{t+1} = s_j | q_t = s_i)$。给定的转移矩阵是：\n    $$\n    A = \\begin{pmatrix} 0.96  0.02  0.02 \\\\ 0.02  0.96  0.02 \\\\ 0.02  0.02  0.96 \\end{pmatrix}\n    $$\n    我们将使用对数概率矩阵 $\\log(A_{ij})$。\n\n3.  **发射概率 ($b$)**：给定系统处于状态 $s_j$ 时，观测到 $o_t = (x_t, k_t)$ 的概率是 $b_j(o_t) = P(o_t | q_t = s_j)$。问题陈述，在给定状态的条件下，片段长度 $x_t$ 和计数 $k_t$ 是条件独立的。因此，联合发射概率是各个概率的乘积：\n    $$\n    b_j(o_t) = P(x_t | q_t=s_j) \\cdot P(k_t | q_t=s_j)\n    $$\n    片段长度 $x_t$ 由正态（高斯）分布 $p_{\\text{Normal}}(x_t | \\mu_j, \\sigma_j)$ 建模，计数 $k_t$ 由泊松分布 $p_{\\text{Poisson}}(k_t | \\lambda_j)$ 建模。参数是状态相关的：\n    -   状态 $s_0$：$\\mu_0 = 50$，$\\sigma_0 = 15$，$\\lambda_0 = 8$。\n    -   状态 $s_1$：$\\mu_1 = 200$，$\\sigma_1 = 25$，$\\lambda_1 = 3$。\n    -   状态 $s_2$：$\\mu_2 = 300$，$\\sigma_2 = 40$，$\\lambda_2 = 0.3$。\n\n发射概率的对数是两个分布的对数概率之和：\n$$\n\\log(b_j(x_t, k_t)) = \\log(p_{\\text{Normal}}(x_t | \\mu_j, \\sigma_j)) + \\log(p_{\\text{Poisson}}(k_t | \\lambda_j))\n$$\n正态分布的对数概率密度函数是：\n$$\n\\log(p_{\\text{Normal}}(x | \\mu, \\sigma)) = -\\log(\\sigma\\sqrt{2\\pi}) - \\frac{(x - \\mu)^2}{2\\sigma^2} = -\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi) - \\frac{(x - \\mu)^2}{2\\sigma^2}\n$$\n泊松分布的对数概率质量函数是：\n$$\n\\log(p_{\\text{Poisson}}(k | \\lambda)) = \\log\\left(\\frac{\\lambda^k e^{-\\lambda}}{k!}\\right) = k\\log(\\lambda) - \\lambda - \\log(k!)\n$$\n项 $\\log(k!)$ 通过数值计算为 $\\log(\\Gamma(k+1))$，其中 $\\Gamma$ 是伽马函数。\n\nViterbi 算法通过在状态-时间格子图中找到一条使联合概率 $P(O, Q)$ 最大化的路径，来找出最可能的状态序列 $Q^* = (q_1^*, q_2^*, \\ldots, q_T^*)$。在对数空间中，这等同于最大化对数概率之和。我们定义两个动态规划表：\n-   $V_t(j)$：结束于状态 $s_j$ 的长度为 $t$ 的最可能状态序列的对数概率。\n-   $\\psi_t(j)$：回溯指针，存储在时间 $t$ 结束于状态 $s_j$ 的路径的最可能前驱状态的索引。\n\n该算法分三步进行：\n1.  **初始化 ($t=1$)**：对于每个状态 $j \\in \\{0, 1, 2\\}$，我们计算第一个观测值的对数概率：\n    $$\n    V_1(j) = \\log(\\pi_j) + \\log(b_j(o_1))\n    $$\n    第一步不需要回溯指针 $\\psi_1(j)$，可以初始化为 $0$。\n\n2.  **递推 ($t=2, \\ldots, T$)**：我们遍历每个时间步和每个状态，从时间 $t-1$ 延伸最可能的路径。对于每个状态 $j \\in \\{0, 1, 2\\}$：\n    $$\n    V_t(j) = \\log(b_j(o_t)) + \\max_{i \\in \\{0,1,2\\}} \\left( V_{t-1}(i) + \\log(A_{ij}) \\right)\n    $$\n    $$\n    \\psi_t(j) = \\arg\\max_{i \\in \\{0,1,2\\}} \\left( V_{t-1}(i) + \\log(A_{ij}) \\right)\n    $$\n    这里，$\\max$ 函数内的和对应于概率的乘法：$P(\\text{path to } i) \\cdot P(\\text{transition } i \\to j)$。最大化操作找到了在时间 $t$ 导向状态 $j$ 的唯一最可能路径。\n\n3.  **终止和路径回溯**：完成直到时间 $T$ 的表格后，最优路径的对数概率为 $P^* = \\max_{j \\in \\{0,1,2\\}} (V_T(j))$。路径的最终状态是：\n    $$\n    q_T^* = \\arg\\max_{j \\in \\{0,1,2\\}} (V_T(j))\n    $$\n    然后我们从这个最终状态回溯以重建整个路径。对于 $t = T-1$ 降到 $1$：\n    $$\n    q_t^* = \\psi_{t+1}(q_{t+1}^*)\n    $$\n    这样就得到了最优状态序列 $Q^* = (q_1^*, \\ldots, q_T^*)$。对每个提供的测试用例都执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef solve():\n    \"\"\"\n    Implements the Viterbi algorithm in log-space to decode HMM state sequences\n    for chromatin accessibility from ATAC-seq features.\n    \"\"\"\n    # HMM parameters defined in the problem statement.\n    # States: 0: accessible, 1: nucleosome-array, 2: inaccessible\n    \n    # Initial probabilities (log-space)\n    pi = np.array([1/3, 1/3, 1/3])\n    log_pi = np.log(pi)\n\n    # Transition matrix (log-space)\n    A = np.array([\n        [0.96, 0.02, 0.02],\n        [0.02, 0.96, 0.02],\n        [0.02, 0.02, 0.96]\n    ])\n    log_A = np.log(A)\n\n    # Emission parameters\n    mus = np.array([50.0, 200.0, 300.0])      # Means for Gaussian (fragment length)\n    sigmas = np.array([15.0, 25.0, 40.0])    # Stds for Gaussian\n    lambdas = np.array([8.0, 3.0, 0.3])      # Rates for Poisson (counts)\n\n    # Test cases from the problem statement\n    test_cases = [\n        # Test case 1 (happy path, length 8)\n        [(55, 9), (48, 7), (60, 8), (195, 3), (210, 4), (185, 3), (330, 0), (345, 1)],\n        # Test case 2 (boundary condition, length 1)\n        [(52, 8)],\n        # Test case 3 (transition behavior, length 5)\n        [(50, 8), (62, 7), (70, 6), (205, 4), (198, 3)]\n    ]\n\n    def log_emission_prob(obs, state_idx):\n        \"\"\"\n        Calculates the log-probability of an observation given a state.\n        The observation is a tuple (fragment_length, count).\n        \"\"\"\n        x, k = obs\n        \n        # Log-PDF of Normal distribution for fragment length x\n        mu = mus[state_idx]\n        sigma = sigmas[state_idx]\n        log_p_normal = -np.log(sigma) - 0.5 * np.log(2 * np.pi) - ((x - mu)**2) / (2 * sigma**2)\n        \n        # Log-PMF of Poisson distribution for count k\n        lambda_ = lambdas[state_idx]\n        # Use gammaln(k + 1) for log(k!) which is numerically stable\n        log_p_poisson = k * np.log(lambda_) - lambda_ - gammaln(k + 1)\n        \n        return log_p_normal + log_p_poisson\n\n    results = []\n    for observations in test_cases:\n        T = len(observations)\n        N = len(pi)  # Number of states\n        \n        # Dynamic programming tables\n        # Viterbi table V stores log-probabilities\n        V = np.zeros((T, N))\n        # Backpointer table psi stores the previous state index\n        psi = np.zeros((T, N), dtype=int)\n        \n        # Initialization step (t=0)\n        for j in range(N):\n            V[0, j] = log_pi[j] + log_emission_prob(observations[0], j)\n        \n        # Recursion step (t=1 to T-1)\n        for t in range(1, T):\n            for j in range(N):\n                # Calculate the log-probabilities of reaching state j from any previous state i\n                prev_log_probs = V[t-1, :] + log_A[:, j]\n                \n                # Find the maximum log-probability and the originating state\n                max_log_prob = np.max(prev_log_probs)\n                argmax_state = np.argmax(prev_log_probs)\n                \n                # Update tables with the maximum probability and backpointer\n                V[t, j] = max_log_prob + log_emission_prob(observations[t], j)\n                psi[t, j] = argmax_state\n        \n        # Termination and Backtracking\n        path = np.zeros(T, dtype=int)\n        \n        # Find the last state of the most likely path\n        path[T-1] = np.argmax(V[T-1, :])\n        \n        # Backtrack to reconstruct the full path\n        for t in range(T-2, -1, -1):\n            path[t] = psi[t+1, path[t+1]]\n            \n        results.append(path.tolist())\n\n    # Format the final output to match the specified format \"[[i,j,...],[k,...]]\"\n    output_str = '[' + ','.join(str(r) for r in results) + ']'\n    final_output_str = output_str.replace(\" \", \"\")\n    print(final_output_str)\n\nsolve()\n\n```", "id": "2378334"}, {"introduction": "在染色质可及性分析中，最终目标通常是通过整合多种数据类型来预测复杂的生物功能。转录因子的结合既取决于底层的 DNA 序列（结合基序），也受到局部染色质可及性的调控。现代深度学习模型，特别是卷积神经网络（CNN），能够有效地学习并整合这些信号。本练习将带您手动完成一个简化的双分支 CNN 模型的前向传播计算，通过这个过程，您将具体理解 CNN 如何从序列和信号数据中提取特征并进行功能性预测 [@problem_id:2378286]。", "problem": "给定一个关于转录因子（TF）结合的双分支预测模型的形式化描述，该模型使用ATAC-seq（使用测序技术的转座酶可及性染色质分析）数据。该模型作用于一个固定长度的基因组位点，并结合了一个序列基序检测器和一个可及性峰值检测器。任务是根据下文的数学规范，为一组固定的输入计算预测的TF结合概率，并以指定的单一格式输出结果。\n\n输入和编码。设位点长度为 $L=8$。DNA序列是一个长度为 $L$ 的字符串，其字母表为 $\\{\\text{A},\\text{C},\\text{G},\\text{T}\\}$。它被编码为一个 one-hot 矩阵 $S \\in \\{0,1\\}^{L \\times 4}$，使用列序 $(\\text{A},\\text{C},\\text{G},\\text{T})$。具体来说，如果位置 $i$ 处的碱基是 $\\text{A}$，则 $S_{i,1}=1$ 且 $S_{i,2}=S_{i,3}=S_{i,4}=0$，对于 $\\text{C},\\text{G},\\text{T}$ 也类似。ATAC-seq信号是一个实值向量 $A \\in \\mathbb{R}_{\\ge 0}^{L}$，其条目为非负数，表示无单位的归一化可及性值。\n\nDNA分支（基序检测器）。定义对one-hot序列的单滤波器一维卷积，滤波器长度为 $k_d=4$，无偏置。滤波器权重张量由一个位置权重矩阵 $W_d \\in \\mathbb{R}^{4 \\times 4}$ 表示，其中行 $j \\in \\{0,1,2,3\\}$ 对应于卷积核位置 $j$，列对应于碱基顺序 $(\\text{A},\\text{C},\\text{G},\\text{T})$。$W_d$ 的条目是：\n- 对于 $j=0$: $(-1,-1,-1,2)$,\n- 对于 $j=1$: $(-1,-1,2,-1)$,\n- 对于 $j=2$: $(-1,2,-1,-1)$,\n- 对于 $j=3$: $(2,-1,-1,-1)$.\n对于每个有效的起始索引 $i \\in \\{0,1,\\dots,L-k_d\\}$，计算预激活分数\n$$\nu_d(i) \\;=\\; \\sum_{j=0}^{k_d-1} \\sum_{b=1}^{4} W_d[j,b] \\, S_{i+j,b}.\n$$\n通过 $f_d(i)=\\max\\{0,u_d(i)\\}$ 定义整流特征图，并通过 $h_d = \\max_{i} f_d(i)$ 定义池化DNA特征。\n\nATAC分支（峰值检测器）。定义对ATAC-seq信号的单滤波器一维卷积，滤波器长度为 $k_a=3$，无偏置。滤波器权重向量为 $w_a = (-0.5,\\,1.0,\\,-0.5) \\in \\mathbb{R}^{3}$。对于每个有效的起始索引 $i \\in \\{0,1,\\dots,L-k_a\\}$，计算\n$$\nu_a(i) \\;=\\; \\sum_{j=0}^{k_a-1} w_a[j] \\, A_{i+j}.\n$$\n通过 $f_a(i)=\\max\\{0,u_a(i)\\}$ 定义整流特征图，并通过 $h_a = \\max_{i} f_a(i)$ 定义池化ATAC特征。\n\n输出层（结合概率）。将池化特征通过权重为 $w_d=0.6$、$w_a=0.4$ 和偏置为 $b=-2.0$ 的线性形式组合，以获得logit\n$$\nz \\;=\\; w_d \\, h_d \\;+\\; w_a \\, h_a \\;+\\; b \\;=\\; 0.6\\,h_d \\;+\\; 0.4\\,h_a \\;-\\; 2.0.\n$$\n使用logistic函数将logit映射为概率\n$$\n\\hat{p} \\;=\\; \\sigma(z) \\;=\\; \\frac{1}{1+\\exp(-z)}.\n$$\n所有概率必须以小数形式报告，并精确到 $6$ 位小数。\n\n测试套件。对于以下每种情况，使用 $L=8$ 并根据上述定义计算 $\\hat{p}$。\n- 情况1：序列 $\\text{\"AACTGCAA\"}$；ATAC向量 $[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- 情况2：序列 $\\text{\"AACTGCAA\"}$；ATAC向量 $[\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\,]$。\n- 情况3：序列 $\\text{\"AAAAAAAA\"}$；ATAC向量 $[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- 情况4：序列 $\\text{\"CCCCCCCC\"}$；ATAC向量 $[\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$。\n- 情况5：序列 $\\text{\"ATGTAAAA\"}$；ATAC向量 $[\\,1.0,\\,2.0,\\,3.0,\\,3.0,\\,3.0,\\,2.0,\\,1.0,\\,1.0\\,]$。\n\n最终输出格式。您的程序应生成单行输出，其中包含从情况1到情况5的5个结果，以逗号分隔列表的形式包含在方括号中，每个值都精确到 $6$ 位小数（例如，$[x_1,x_2,x_3,x_4,x_5]$）。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在计算生物学领域具有科学依据，具体而言，它使用简化的卷积神经网络架构进行转录因子结合预测，这是一项标准任务。该问题定义明确，所有参数、公式和输入数据都得到了明确且一致的定义。它为数学计算提供了一套完整而明确的指令。不存在逻辑矛盾、科学不准确或定义不清的术语。因此，我将继续提供完整的解决方案。\n\n该问题要求为五个不同的测试用例计算预测的TF结合概率 $\\hat{p}$。该模型包括两个并行分支——一个处理DNA序列，另一个处理ATAC-seq信号——其后是一个整合它们输出的输出层。\n\n该模型由以下参数定义：\n- 位点长度：$L=8$。\n- DNA分支卷积滤波器长度：$k_d=4$。\n- ATAC分支卷积滤波器长度：$k_a=3$。\n- DNA滤波器权重，$W_d \\in \\mathbb{R}^{4 \\times 4}$，列对应于碱基 $(\\text{A},\\text{C},\\text{G},\\text{T})$：\n$$W_d = \\begin{pmatrix} -1  -1  -1  2 \\\\ -1  -1  2  -1 \\\\ -1  2  -1  -1 \\\\ 2  -1  -1  -1 \\end{pmatrix}$$\n- ATAC滤波器权重，$w_a \\in \\mathbb{R}^{3}$：$w_a = (-0.5, 1.0, -0.5)$。\n- 输出层权重：DNA分支特征的权重 $w_d=0.6$，ATAC分支特征的权重 $w_a=0.4$，以及偏置 $b=-2.0$。\n\n计算分三个阶段进行：DNA分支、ATAC分支和输出层。\n\n**1. DNA分支（基序检测器）**\n该分支处理一个one-hot编码的DNA序列 $S \\in \\{0,1\\}^{L \\times 4}$。应用一个带滤波器 $W_d$ 的一维卷积。对于每个起始位置 $i \\in \\{0, \\dots, L-k_d\\}$，预激活分数计算如下：\n$$u_d(i) \\;=\\; \\sum_{j=0}^{k_d-1} \\sum_{b=1}^{4} W_d[j,b] \\, S_{i+j,b}$$\n这实际上是一个滑动窗口操作，对于序列的每个窗口，我们对该窗口中存在的碱基所对应的滤波器权重求和。我们将位置 $k$ 处的碱基表示为 $\\text{seq}[k]$。分数为 $u_d(i) = \\sum_{j=0}^{k_d-1} W_d[j, \\text{base\\_map}(\\text{seq}[i+j])]$，其中 $\\text{base\\_map}$ 将碱基字符转换为其对应的列索引 $(\\text{A}\\to1, \\text{C}\\to2, \\text{G}\\to3, \\text{T}\\to4)$。应用整流线性单元（ReLU）激活函数 $f_d(i)=\\max\\{0,u_d(i)\\}$，然后对所有位置进行最大池化，得到最终的DNA特征 $h_d = \\max_{i} f_d(i)$。\n\n**2. ATAC分支（峰值检测器）**\n该分支处理ATAC-seq信号向量 $A \\in \\mathbb{R}_{\\ge 0}^{L}$。应用一个带滤波器 $w_a$ 的一维卷积。对于每个起始位置 $i \\in \\{0, \\dots, L-k_a\\}$，预激活分数为：\n$$u_a(i) \\;=\\; \\sum_{j=0}^{k_a-1} w_a[j] \\, A_{i+j}$$\n此操作是滤波器 $w_a$ 与 $A$ 的子向量之间的滑动点积。与DNA分支类似，应用ReLU激活函数 $f_a(i)=\\max\\{0,u_a(i)\\}$，然后进行最大池化，得到最终的ATAC特征 $h_a = \\max_{i} f_a(i)$。\n\n**3. 输出层（结合概率）**\n来自两个分支的特征 $h_d$ 和 $h_a$ 被线性组合以产生一个logit分数 $z$：\n$$z \\;=\\; 0.6\\,h_d \\;+\\; 0.4\\,h_a \\;-\\; 2.0$$\n然后使用logistic（sigmoid）函数将此logit转换为概率 $\\hat{p}$：\n$$\\hat{p} \\;=\\; \\sigma(z) \\;=\\; \\frac{1}{1+\\exp(-z)}$$\n\n我们现在将此过程应用于五个测试用例中的每一个。\n\n**情况1：**\n- 序列：$\\text{\"AACTGCAA\"}$，ATAC：$[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- DNA分支：卷积窗口为 $\\text{AACT}, \\text{ACTG}, \\text{CTGC}, \\text{TGCA}, \\text{GCAA}$。对于 $i \\in \\{0, \\dots, 4\\}$，预激活分数 $u_d(i)$ 为 $[-1, -4, -4, 8, -1]$。经过ReLU后，特征图为 $f_d = [0, 0, 0, 8, 0]$。最大池化得出 $h_d=8$。\n- ATAC分支：对于 $i \\in \\{0, \\dots, 5\\}$，预激活分数 $u_a(i)$ 为 $[-2.35, 0.4, 4.0, 0.4, -2.35, -0.05]$。经过ReLU后，特征图为 $f_a = [0, 0.4, 4.0, 0.4, 0, 0]$。最大池化得出 $h_a=4.0$。\n- 输出：$z = 0.6(8) + 0.4(4.0) - 2.0 = 4.8 + 1.6 - 2.0 = 4.4$。$\\hat{p} = \\sigma(4.4) \\approx 0.987870$。\n\n**情况2：**\n- 序列：$\\text{\"AACTGCAA\"}$，ATAC：$[\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1,\\,0.1\\,]$。\n- DNA分支：与情况1相同，所以 $h_d=8$。\n- ATAC分支：平坦的ATAC信号导致所有 $i \\in \\{0, \\dots, 5\\}$ 的预激活分数 $u_a(i)=0$，因为 $\\sum w_a[j] = -0.5+1.0-0.5=0$。因此，$h_a=0$。\n- 输出：$z = 0.6(8) + 0.4(0) - 2.0 = 4.8 - 2.0 = 2.8$。$\\hat{p} = \\sigma(2.8) \\approx 0.942676$。\n\n**情况3：**\n- 序列：$\\text{\"AAAAAAAA\"}$，ATAC：$[\\,0.1,\\,0.2,\\,5.0,\\,9.0,\\,5.0,\\,0.2,\\,0.1,\\,0.1\\,]$。\n- DNA分支：所有卷积窗口都是 $\\text{AAAA}$。对于所有 $i$，预激活分数为 $u_d(i) = -1-1-1+2 = -1$。经过ReLU后，所有特征值均为 $0$，所以 $h_d=0$。\n- ATAC分支：与情况1相同，所以 $h_a=4.0$。\n- 输出：$z = 0.6(0) + 0.4(4.0) - 2.0 = 1.6 - 2.0 = -0.4$。$\\hat{p} = \\sigma(-0.4) \\approx 0.401312$。\n\n**情况4：**\n- 序列：$\\text{\"CCCCCCCC\"}$，ATAC：$[\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0\\,]$。\n- DNA分支：所有卷积窗口都是 $\\text{CCCC}$。对于所有 $i$，预激活分数为 $u_d(i) = -1-1+2-1 = -1$。经过ReLU后，所有特征值均为 $0$，所以 $h_d=0$。\n- ATAC分支：零值的ATAC信号导致所有 $i$ 的预激活分数 $u_a(i)=0$。因此，$h_a=0$。\n- 输出：$z = 0.6(0) + 0.4(0) - 2.0 = -2.0$。$\\hat{p} = \\sigma(-2.0) \\approx 0.119203$。\n\n**情况5：**\n- 序列：$\\text{\"ATGTAAAA\"}$，ATAC：$[\\,1.0,\\,2.0,\\,3.0,\\,3.0,\\,3.0,\\,2.0,\\,1.0,\\,1.0\\,]$。\n- DNA分支：卷积窗口为 $\\text{ATGT}, \\text{TGTA}, \\text{GTAA}, \\text{TAAA}, \\text{AAAA}$。预激活分数为 $u_d = [-4, 5, -1, 2, -1]$。经过ReLU后，$f_d = [0, 5, 0, 2, 0]$。最大池化得出 $h_d=5$。\n- ATAC分支：预激活分数为 $u_a = [0, 0.5, 0, 0.5, 0, -0.5]$。经过ReLU后，$f_a = [0, 0.5, 0, 0.5, 0, 0]$。最大池化得出 $h_a=0.5$。\n- 输出：$z = 0.6(5) + 0.4(0.5) - 2.0 = 3.0 + 0.2 - 2.0 = 1.2$。$\\hat{p} = \\sigma(1.2) \\approx 0.768525$。\n\n最终概率，四舍五入到6位小数，是：\n- 情况1：$0.987870$\n- 情况2：$0.942676$\n- 情况3：$0.401312$\n- 情况4：$0.119203$\n- 情况5：$0.768525$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the TF-binding probabilities for a set of test cases\n    based on the specified two-branch predictive model.\n    \"\"\"\n\n    # --- Model Parameters ---\n    L = 8\n    \n    # DNA Branch Parameters\n    k_d = 4\n    W_d = np.array([\n        [-1, -1, -1, 2],  # j=0, for (A, C, G, T)\n        [-1, -1, 2, -1],  # j=1\n        [-1, 2, -1, -1],  # j=2\n        [2, -1, -1, -1]   # j=3\n    ])\n    base_map = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # ATAC Branch Parameters\n    k_a = 3\n    w_a_filter = np.array([-0.5, 1.0, -0.5])\n\n    # Output Layer Parameters\n    w_d_out = 0.6\n    w_a_out = 0.4\n    b_out = -2.0\n\n    # --- Test Suite ---\n    test_cases = [\n        (\"AACTGCAA\", [0.1, 0.2, 5.0, 9.0, 5.0, 0.2, 0.1, 0.1]),\n        (\"AACTGCAA\", [0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1]),\n        (\"AAAAAAAA\", [0.1, 0.2, 5.0, 9.0, 5.0, 0.2, 0.1, 0.1]),\n        (\"CCCCCCCC\", [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]),\n        (\"ATGTAAAA\", [1.0, 2.0, 3.0, 3.0, 3.0, 2.0, 1.0, 1.0]),\n    ]\n\n    results = []\n\n    for seq, atac_signal in test_cases:\n        # --- DNA Branch Computation ---\n        u_d = []\n        num_dna_windows = L - k_d + 1\n        for i in range(num_dna_windows):\n            window_seq = seq[i : i + k_d]\n            score = 0\n            for j in range(k_d):\n                base = window_seq[j]\n                base_idx = base_map[base]\n                score += W_d[j, base_idx]\n            u_d.append(score)\n        \n        f_d = np.maximum(0, np.array(u_d))\n        h_d = np.max(f_d)\n\n        # --- ATAC Branch Computation ---\n        atac_signal_np = np.array(atac_signal)\n        u_a = []\n        num_atac_windows = L - k_a + 1\n        for i in range(num_atac_windows):\n            window_atac = atac_signal_np[i : i + k_a]\n            score = np.dot(window_atac, w_a_filter)\n            u_a.append(score)\n\n        f_a = np.maximum(0, np.array(u_a))\n        h_a = np.max(f_a) if len(f_a) > 0 else 0\n\n        # --- Output Layer Computation ---\n        z = w_d_out * h_d + w_a_out * h_a + b_out\n        p_hat = 1 / (1 + np.exp(-z))\n        \n        # Format result and append\n        results.append(f\"{p_hat:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2378286"}]}