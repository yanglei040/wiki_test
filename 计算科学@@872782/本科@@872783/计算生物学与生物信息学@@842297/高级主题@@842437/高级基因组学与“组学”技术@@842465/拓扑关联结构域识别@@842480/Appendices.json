{"hands_on_practices": [{"introduction": "在从理论转向实践的过程中，理解实验设计选择的深远影响至关重要。本练习探讨了Hi-C实验中的一个基本决策：限制性内切酶的选择。通过比较“4-cutter”和“6-cutter”酶，您将从第一性原理出发，推断这对TAD边界的最终分辨率和准确性意味着什么，这培养了连接分子生物学、测序统计和数据解读的综合思维能力。[@problem_id:2437228]", "problem": "一个实验室计划在同一种哺乳动物细胞系上进行两次原位高通量染色体构象捕获（Hi-C）实验，以鉴定拓扑关联结构域（TAD）的边界。在实验X中，他们使用一种识别 $k = 4$ 核苷酸位点的限制性内切酶（一种“4碱基切割酶”）；在实验Y中，他们使用一种识别 $k = 6$ 核苷酸位点的限制性内切酶（一种“6碱基切割酶”）。两次实验均采用相同的文库构建方案、相同数量的唯一比对读段对（$N = 5\\times 10^8$ 个接触）和可比的重复率。基因组大小约为 $G = 3\\times 10^9$ 碱基对 (bp)。该研究小组将使用一种绝缘分数法来识别TAD边界，该方法在对称窗口内聚合接触，并寻找局部绝缘的最小值。\n\n从核酸序列统计学和Hi-C接触采样的第一性原理出发，推断限制性内切酶的选择如何影响TAD边界定位可达到的分辨率和准确性。作为一级近似，假设碱基是独立同分布的，每个核苷酸出现的概率相等，识别位点之间的期望间距与其出现概率成反比，并且边界检测需要每个基因组区间内有足够的接触密度。以下哪个/哪些陈述最准确？\n\nA. 使用“4碱基切割酶”可以提高边界定位的潜在精度，因为平均限制性片段长度更短，从而在边界附近产生更密集的接触采样；然而，为了在没有过多噪声的情况下实现更精细的区间识别，与“6碱基切割酶”相比，需要每个碱基对有更高的测序深度。\n\nB. 使用“6碱基切割酶”可以提高边界分辨率，因为更长的片段能更有效地跨越边界，即使在相同的读段深度下也能产生更尖锐的绝缘分数最小值。\n\nC. 限制性内切酶的选择对边界分辨率没有实际影响，因为TAD是在兆碱基尺度上定义的，并且对限制性片段的大小不敏感。\n\nD. 在相同的读段深度下，“6碱基切割酶”通常会在整个基因组产生更均一的覆盖度，因此比“4碱基切割酶”得到更准确的边界位置。\n\nE. 如果边界附近的识别位点稀疏，“6碱基切割酶”可能会错过狭窄的边界特征，导致识别出的边界位置偏向最近的可用的限制性位点，与“4碱基切割酶”相比，实际上加宽了边界的估计范围。\n\n选择所有适用的选项。", "solution": "问题陈述具有科学依据，提法得当，并包含足够的信息以进行严谨的分析。它描述了染色体构象捕获领域中的一个标准实验设计选择，并就其后果提出了一个有效的问题。所提供的参数和假设对于进行第一性原理评估是合理的。因此，该问题是有效的，并将推导出解答。\n\n问题的核心是比较使用识别 $k=4$ 核苷酸位点的限制性内切酶（“4碱基切割酶”）的高通量染色体构象捕获（Hi-C）实验与使用识别 $k=6$ 位点的酶（“6碱基切割酶”）的实验。\n\n根据序列统计学的第一性原理，假设序列是独立同分布（i.i.d.）的，且每个核苷酸出现的概率相等（$P(A) = P(C) = P(G) = P(T) = 1/4$），那么找到一个特定的k-mer识别位点的概率 $P_k$ 为：\n$$P_k = \\left(\\frac{1}{4}\\right)^k$$\n位点之间的期望距离，即平均限制性片段长度 $L_k$，是这个概率的倒数。\n\n对于实验X（“4碱基切割酶”）：\n$$k = 4$$\n$$P_4 = \\left(\\frac{1}{4}\\right)^4 = \\frac{1}{256}$$\n$$L_4 = \\frac{1}{P_4} = 256 \\text{ bp}$$\n\n对于实验Y（“6碱基切割酶”）：\n$$k = 6$$\n$$P_6 = \\left(\\frac{1}{4}\\right)^6 = \\frac{1}{4096}$$\n$$L_6 = \\frac{1}{P_6} = 4096 \\text{ bp}$$\n\n在大小为 $G \\approx 3 \\times 10^9$ bp的基因组中，限制性位点的数量约为 $G/L_k$。\n-   对于“4碱基切割酶”：$N_{sites,4} \\approx (3 \\times 10^9) / 256 \\approx 1.17 \\times 10^7$ 个位点。\n-   对于“6碱基切割酶”：$N_{sites,6} \\approx (3 \\times 10^9) / 4096 \\approx 7.3 \\times 10^5$ 个位点。\n\n评估这些实验的基本原则如下：\n1.  **分辨率极限**：Hi-C实验的最终空间分辨率受限于限制性位点的密度。接触是在两个片段之间检测到的。因此，接触的位置只能被解析到所涉及的片段水平。较短的片段可以更精确地定位相互作用的端点。\n2.  **采样密度**：两次实验具有相同总数的读段对，$N = 5 \\times 10^8$。这些读段分布在所有可能的限制性片段对之间。“4碱基切割酶”实验产生数量多得多的片段，这意味着这 $N$ 个读段是从一个大得多的潜在相互作用池中采样的。\n3.  **覆盖均一性**：来自“4碱基切割酶”的更密集的限制性位点集提供了更均匀的全基因组覆盖。而来自“6碱基切割酶”的稀疏位点集可能导致大的基因组区域没有切割位点，从而产生“盲点”和不均匀的覆盖。\n4.  **信噪比**：对于固定的基因组区间大小，每个区间的读段数是一个关键因素。要实现高分辨率，必须使用小的区间。在总读段数 $N$ 固定的情况下，较小的区间将包含较少的读段，从而增加了统计噪声。\n\n基于这些原则，我们来评估每个陈述。\n\n**A. 使用“4碱基切割酶”可以提高边界定位的潜在精度，因为平均限制性片段长度更短，从而在边界附近产生更密集的接触采样；然而，为了在没有过多噪声的情况下实现更精细的区间识别，与“6碱基切割酶”相比，需要每个碱基对有更高的测序深度。**\n-   陈述的第一部分是正确的，它声称由于片段更短（$L_4 \\approx 256$ bp），“4碱基切割酶”提高了潜在的精度。较短的片段就像更精细的“尺子”，用于映射相互作用的位置。从字面意义上讲，这会产生更密集的采样：相互作用的潜在锚点彼此更靠近。\n-   第二部分讨论了其中的权衡。为了利用这种更高的潜在精度，必须使用更小的基因组区间来分析数据。在总读段数 $N$ 固定的情况下，更小的区间意味着每个区间的计数更少，从而降低了信噪比。为了用统计上显著数量的接触来填充这些更精细的区间，就需要成比例地增加总读段数（即更高的测序深度）。这是基于测序的基因组学分析中一个经典的分辨率与深度的权衡。\n-   结论：**正确**。\n\n**B. 使用“6碱基切割酶”可以提高边界分辨率，因为更长的片段能更有效地跨越边界，即使在相同的读段深度下也能产生更尖锐的绝缘分数最小值。**\n-   这个陈述声称“6碱基切割酶”*提高*了分辨率。这根本上是错误的。分辨率与可解析的最小特征的大小成反比。来自“6碱基切割酶”的较大片段（$L_6 \\approx 4096$ bp）提供了对基因组更粗粒度的视图，因此与“4碱基切割酶”相比，理论分辨率*降低*了。\n-   “更长的片段能更有效地跨越边界”的推理是具有误导性的。绝缘分数的目的是检测*跨越*边界的相互作用的减少。单个片段可能跨越边界这一事实是模糊性的来源，而不是一个有用的特征，因为它模糊了边界的表观位置。\n-   因此，“6碱基切割酶”会产生*更宽*而非更尖锐的绝缘分数最小值，因为信号是在更长的片段长度上平均的。\n-   结论：**不正确**。\n\n**C. 限制性内切酶的选择对边界分辨率没有实际影响，因为TAD是在兆碱基尺度上定义的，并且对限制性片段的大小不敏感。**\n-   虽然拓扑关联结构域（TAD）是大的结构，通常在数百千碱基到兆碱基的范围内，但它们的边界通常是尖锐、明确界定的区域。精确地定位这些边界是一个关键目标，并且已知与特定的基因组元件（如CTCF结合位点）相关联。\n-   “4碱基切割酶”（$256$ bp）和“6碱基切割酶”（$4096$ bp）的平均片段长度之差有一个数量级。当试图精确定位一个可能只有几千碱基宽的边界区域时，这种差异是高度相关的。因此，酶的选择对边界定位的精度有显著的实际影响。\n-   结论：**不正确**。\n\n**D. 在相同的读段深度下，“6碱基切割酶”通常会在整个基因组产生更均一的覆盖度，因此比“4碱基切割酶”得到更准确的边界位置。**\n-   这个陈述声称“6碱基切割酶”提供更均一的覆盖度。这与实际情况相反。“4碱基切割酶”大约每 $256$ bp有一个位点，而“6碱基切割酶”每 $4096$ bp才有一个位点。“6碱基切割酶”位点的更稀疏分布意味着存在不含限制性位点的大片基因组区域的可能性要高得多。这导致了间隙和高度不均一的覆盖。“4碱基切割酶”提供了对基因组更均匀得多的采样。\n-   因为更均一覆盖度的前提是错误的，所以更准确边界位置的结论是没有依据且不正确的。有偏倚的、不均一的覆盖会导致结果的准确性降低，而不是提高。\n-   结论：**不正确**。\n\n**E. 如果边界附近的识别位点稀疏，“6碱基切割酶”可能会错过狭窄的边界特征，导致识别出的边界位置偏向最近的可用的限制性位点，与“4碱基切割酶”相比，实际上加宽了边界的估计范围。**\n-   这个陈述正确地指出了使用切割频率低的酶的一个关键问题。如果一个真实的生物学边界位于远离任何“6碱基切割酶”识别位点的区域，那么Hi-C实验根本无法检测到精确起源于该边界的相互作用。\n-   被检测到的相互作用将被锚定在边界两侧最近的可用限制性位点上。例如，如果这些位点相距 $5$ kb，那么绝缘分数的最小值将反映这些遥远片段之间的相互作用下降，而不是在真实边界处的下降。这将使识别出的边界位置发生错位，并使信号在可用位点之间的整个区域内弥散开来。\n-   而“4碱基切割酶”由于其位点密集，更有可能在非常靠近真实边界的位置拥有位点，从而允许更准确和更精确（即更窄）的边界识别。\n-   结论：**正确**。", "answer": "$$\\boxed{AE}$$", "id": "2437228"}, {"introduction": "识别出潜在的TAD结构后，一个关键的计算生物学任务是评估其统计显著性。本练习通过一个思想实验，让您直面基因组学中普遍存在的多重检验问题。您将计算在一个无真实结构（零假设）的随机染色质模型中，一个典型的TAD识别算法预期会发现多少个“假”的TAD，从而深刻理解假阳性率的概念以及控制它的重要性。[@problem_id:2437207]", "problem": "考虑一个从高通量染色体构象捕获 (Hi-C) 数据中分箱得到的接触矩阵，该矩阵代表一个染色体片段。通过标准的观测值/期望值归一化，已经消除了距离依赖性衰减，因此，在没有域结构的原假设下，任何与给定基因组距离一致的接触子集的期望值都为1。一个拓扑关联域 (TAD) 识别器评估总共 $B=200$ 个箱中，长度在 $L_{\\min}=5$ 和 $L_{\\max}=20$ 之间（含两端）的每个连续区间。对于每个候选区间，该识别器执行一个有效的统计检验，以检测区间内的接触富集情况。当原假设为真时，其 $p$-值在 $[0,1]$ 区间上均匀分布。如果一个区间的 $p$-值小于固定的单个区间显著性阈值 $\\alpha=0.01$，则该识别器将其声明为一个 TAD。\n\n假设该 Hi-C 矩阵是由一个完全随机的、没有真实域结构的聚合物模型生成的。在这些条件下，确定该识别器会声明为 TAD 的区间的期望数量。将您的答案四舍五入到四位有效数字。以纯数字（计数）形式报告您的答案，不带任何单位。", "solution": "问题陈述需要进行验证。\n\n步骤1：提取给定条件\n-   系统是一个由 $B = 200$ 个箱的 Hi-C 接触矩阵表示的染色体片段。\n-   该矩阵已经过归一化（观测值/期望值），因此在没有域结构的原假设下，接触的期望为1。\n-   一个 TAD 识别器评估所有长度为 $L$ 的连续染色质箱区间，其中 $L_{\\min} \\le L \\le L_{\\max}$，$L_{\\min} = 5$，$L_{\\max} = 20$。\n-   对于每个候选区间，执行一次统计检验，其 $p$-值在原假设下于区间 $[0,1]$ 上均匀分布。\n-   如果一个区间的 $p$-值小于显著性阈值 $\\alpha = 0.01$，则该区间被声明为 TAD。\n-   假设系统遵循一个没有真实域结构的随机聚合物模型，这意味着原假设对所有检验都成立。\n-   目标是找到被声明为 TAD 的区间的期望数量。\n-   最终答案应四舍五入到四位有效数字。\n\n步骤2：使用提取的给定条件进行验证\n-   **科学依据：** 该问题基于分析 Hi-C 数据的计算生物学和生物信息学标准实践。Hi-C 接触矩阵、观测值/期望值归一化、拓扑关联域 (TAD)、p-值和原假设等概念都是基础性的，并且描述正确。原假设下 p-值均匀分布的假设是一个有效统计检验的定义性属性。\n-   **适定性：** 该问题是适定的。它提供了所有必要的参数（$B$, $L_{\\min}$, $L_{\\max}$, $\\alpha$）和一个明确的目标。问题没有歧义，并且有一个唯一的、可计算的解。\n-   **客观性：** 该问题以精确、客观的语言陈述，没有任何主观论断或歧义。\n\n步骤3：结论与行动\n该问题是有效的，因为它具有科学合理性、适定性和客观性。将提供解答。\n\n任务是计算在全局原假设下假阳性 TAD 发现的期望数量。这个期望值是执行的统计检验总数与单个检验显著的概率的乘积。\n\n首先，我们必须确定 TAD 识别器评估的候选区间总数 $N$。识别器检查长度为 $L$ 的所有连续区间，其中 $L$ 在 $[L_{\\min}, L_{\\max}]$ 范围内。对于一个有 $B$ 个箱的染色体，固定长度为 $L$ 的可能连续区间的数量由 $B - L + 1$ 给出。\n测试的区间总数 $N$ 是从 $L_{\\min} = 5$ 到 $L_{\\max} = 20$ 的每个长度的区间数量之和。\n$$N = \\sum_{L=L_{\\min}}^{L_{\\max}} (B - L + 1)$$\n代入给定值 $B = 200$，$L_{\\min} = 5$ 和 $L_{\\max} = 20$：\n$$N = \\sum_{L=5}^{20} (200 - L + 1) = \\sum_{L=5}^{20} (201 - L)$$\n这是一个等差数列的和。求和中的项数是 $k = L_{\\max} - L_{\\min} + 1 = 20 - 5 + 1 = 16$。\n该数列的第一项（当 $L=5$ 时）是 $a_1 = 201 - 5 = 196$。\n该数列的最后一项（当 $L=20$ 时）是 $a_k = 201 - 20 = 181$。\n等差数列的和由公式 $S_k = \\frac{k}{2}(a_1 + a_k)$ 给出。\n$$N = \\frac{16}{2} (196 + 181) = 8 \\cdot (377) = 3016$$\n因此，总共执行了 $N=3016$ 次统计检验。\n\n接下来，我们考虑单个检验导致 TAD 判定的概率。设随机变量 $P_i$ 表示第 $i$ 次检验的 $p$-值，其中 $i \\in \\{1, 2, \\dots, N\\}$。问题陈述，在原假设下（假设对整个矩阵成立），$p$-值在区间 $[0,1]$ 上均匀分布。\n$$P_i \\sim U(0,1)$$\n如果一个区间的 $p$-值小于显著性阈值 $\\alpha = 0.01$，它就被声明为 TAD。单个检验发生此事件的概率是：\n$$\\mathbb{P}(P_i  \\alpha) = \\int_0^\\alpha 1 \\,dx = \\alpha = 0.01$$\n这是单次检验的第一类错误概率。\n\n设 $X_i$ 是一个指示随机变量，表示第 $i$ 个区间是否被声明为 TAD。\n如果 $P_i  \\alpha$，则 $X_i = 1$；否则 $X_i = 0$。\n这个指示随机变量的期望值是：\n$$E[X_i] = 1 \\cdot \\mathbb{P}(X_i = 1) + 0 \\cdot \\mathbb{P}(X_i = 0) = \\mathbb{P}(P_i  \\alpha) = \\alpha$$\n被声明为 TAD 的区间总数是所有检验的这些指示随机变量之和：$Y = \\sum_{i=1}^{N} X_i$。\n我们被要求找到被声明的 TAD 的期望数量，即 $E[Y]$。\n\n根据期望的线性性质，随机变量之和的期望等于它们各自期望之和。无论这些变量是否独立，此性质都成立。在这个问题中，重叠的区间会导致相关的检验统计量，但这不影响期望值的计算。\n$$E[Y] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]$$\n由于对于所有的 $i=1, \\dots, N$ 都有 $E[X_i] = \\alpha$：\n$$E[Y] = \\sum_{i=1}^{N} \\alpha = N \\cdot \\alpha$$\n代入计算出的 $N$ 值和给定的 $\\alpha$ 值：\n$$E[Y] = 3016 \\cdot 0.01 = 30.16$$\n问题要求答案保留四位有效数字。计算出的值 $30.16$ 已经有四位有效数字。因此，不需要进一步的四舍五入。该值表示将此 TAD 识别程序应用于一个零假设数据集时，假阳性的期望数量。", "answer": "$$\\boxed{30.16}$$", "id": "2437207"}, {"introduction": "为了将TAD识别从手动检查和简单统计提升为自动化、可扩展的分析流程，我们需要强大的计算模型。本练习将指导您使用一种在生物信息学中广泛应用的强大工具——隐马尔可夫模型（HMM）——来构建一个TAD识别器。通过完成这个编码挑战，您将亲手实现Viterbi算法，从模拟的染色质接触数据中解码最可能的基因组状态序列，真正体验计算建模在基因组分割中的应用。[@problem_id:2437210]", "problem": "给定一个形式化概率模型，用于将染色体一维分割为与拓扑关联域 (TADs) 相关的区域。该模型是一个隐马尔可夫模型 (HMM)，具有三个隐状态，分别代表片段类型：结构域、边界和域间。设位置 $t$ 处的隐状态为 $z_t \\in \\{0,1,2\\}$，其中映射关系为：结构域 $\\rightarrow$ $0$，边界 $\\rightarrow$ $1$，域间 $\\rightarrow$ $2$。设位置 $t$ 处的观测数据为单个实数 $x_t \\in \\mathbb{R}$，代表从染色体接触矩阵中导出的归一化摘要统计量；此统计量是无量纲的，没有物理单位。该 HMM 由以下部分定义：\n\n- 初始状态分布 $\\boldsymbol{\\pi}$，作用于状态 $\\{0,1,2\\}$：\n  - $\\pi_0 = 0.6$\n  - $\\pi_1 = 0.1$\n  - $\\pi_2 = 0.3$\n\n- 状态转移概率矩阵 $\\mathbf{A}$，其中 $A_{ij} = \\Pr(z_t=j \\mid z_{t-1}=i)$，对于 $i,j \\in \\{0,1,2\\}$：\n  - 从状态 $0$：$A_{00} = 0.80$, $A_{01} = 0.10$, $A_{02} = 0.10$\n  - 从状态 $1$：$A_{10} = 0.45$, $A_{11} = 0.10$, $A_{12} = 0.45$\n  - 从状态 $2$：$A_{20} = 0.10$, $A_{21} = 0.10$, $A_{22} = 0.80$\n\n- 发射分布：对于每个状态 $s \\in \\{0,1,2\\}$，观测值 $x_t$ 根据均值为 $\\mu_s$、方差为 $\\sigma_s^2$ 的单变量正态（高斯）分布生成，在给定 $z_t$ 的条件下，在时间 $t$ 上是独立的：\n  - 对于状态 0 (结构域)：$\\mu_0 = 0.8$, $\\sigma_0^2 = 0.25$\n  - 对于状态 1 (边界)：$\\mu_1 = 2.0$, $\\sigma_1^2 = 0.25$\n  - 对于状态 2 (域间)：$\\mu_2 = 0.0$, $\\sigma_2^2 = 0.25$\n\n给定一个观测序列 $\\mathbf{x} = (x_1, x_2, \\dots, x_T)$，目标是找到状态序列 $\\mathbf{z}^\\star = (z_1, z_2, \\dots, z_T)$，使得在指定的 HMM 下联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 最大化。如果多个状态序列达到相同的最大 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 值，您必须在最大化过程中的每个位置 $t$，选择达到最大值的 $\\{0,1,2\\}$ 中最小的状态索引，以此来确定性地打破平局。\n\n您的任务是编写一个程序，对于下面的每个测试用例，使用状态索引映射：结构域 $\\rightarrow$ $0$，边界 $\\rightarrow$ $1$，域间 $\\rightarrow$ $2$，返回最大化状态序列 $\\mathbf{z}^\\star$ 作为整数列表。\n\n测试套件（每个测试用例都是一个实值观测列表，无量纲）：\n\n- 测试用例 1：$\\left[0.9,\\, 0.7,\\, 0.8,\\, 1.9,\\, 2.2,\\, 0.2,\\, 0.1,\\, 0.0\\right]$\n- 测试用例 2：$\\left[2.1\\right]$\n- 测试用例 3：$\\left[0.1,\\, 0.0,\\, 0.9,\\, 0.8,\\, 0.7,\\, 0.2\\right]$\n- 测试用例 4：$\\left[0.75,\\, 0.85,\\, 0.95,\\, 0.05,\\, -0.1,\\, 0.0,\\, 1.8,\\, 2.1,\\, 1.9,\\, 0.6\\right]$\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是对应测试用例的推断状态索引列表，顺序与上面列出的一致。例如，打印的行应类似于“[[a1,a2,...],[b1,...],[c1,...],[d1,...]]”，其中每个符号都是 $\\{0,1,2\\}$ 中的一个整数。\n\n每个测试用例的答案必须是一个整数列表。不涉及物理单位，除了标准的整数表示外，不需要进行四舍五入。", "solution": "在尝试提供解决方案之前，将根据所需标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n该问题为染色体分割的隐马尔可夫模型 (HMM) 提供了完整的规范。明确的已知条件如下：\n-   **隐状态**：一组三个隐状态，$z_t \\in \\{0, 1, 2\\}$，对应于片段类型：结构域 ($0$)、边界 ($1$) 和域间 ($2$)。\n-   **观测值**：一系列无量纲实值标量 $x_t \\in \\mathbb{R}$。\n-   **初始状态分布 $\\boldsymbol{\\pi}$**：一个定义第一个状态概率的向量，$\\Pr(z_1=i) = \\pi_i$。\n    -   $\\pi_0 = 0.6$\n    -   $\\pi_1 = 0.1$\n    -   $\\pi_2 = 0.3$\n-   **状态转移概率矩阵 $\\mathbf{A}$**：一个矩阵，其中 $A_{ij} = \\Pr(z_t=j \\mid z_{t-1}=i)$。\n    -   $A_{0,*} = [0.80, 0.10, 0.10]$\n    -   $A_{1,*} = [0.45, 0.10, 0.45]$\n    -   $A_{2,*} = [0.10, 0.10, 0.80]$\n-   **发射分布**：对于每个状态 $s \\in \\{0, 1, 2\\}$，观测值 $x_t$ 从正态分布 $\\mathcal{N}(\\mu_s, \\sigma_s^2)$ 中抽取。\n    -   状态 0 (结构域)：$\\mu_0 = 0.8$, $\\sigma_0^2 = 0.25$\n    -   状态 1 (边界)：$\\mu_1 = 2.0$, $\\sigma_1^2 = 0.25$\n    -   状态 2 (域间)：$\\mu_2 = 0.0$, $\\sigma_2^2 = 0.25$\n-   **目标**：找到使联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 最大化的状态序列 $\\mathbf{z}^\\star = (z_1, z_2, \\dots, z_T)$。\n-   **平局打破规则**：当最大值不唯一时，必须选择索引最小的状态 ($0  1  2$)。\n-   **测试套件**：提供了四个特定的观测序列用于评估。\n-   **输出格式**：一个单行字符串，表示一个整数列表的列表，不含空格。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题进行评估。\n-   **科学依据**：该问题具有充分的科学依据。隐马尔可夫模型是生物信息学中用于序列分析的标准而强大的工具，包括表观遗传学和染色质结构研究（如 TAD 识别）。所提出的模型是此类系统的一个简化但概念上合理的表示。所有参数都是物理上合理的无量纲量或概率。\n-   **适定性**：该问题是适定的。它要求在完全指定的 HMM 下，给定一个观测序列，找出最可能的隐状态序列。这是计算统计学中的一个经典问题，保证存在唯一且稳定的解。明确的平局打破规则消除了任何歧义。\n-   **客观性**：该问题是客观的。它使用精确的数学语言和形式化方法进行定义，没有主观解释的余地。\n-   **缺陷检查清单**：该问题没有表现出任何列出的缺陷。它科学合理、可形式化、完整、一致、现实且可通过算法验证。\n\n**步骤 3：结论与行动**\n\n此问题是**有效的**。将提供一个严谨的解决方案。\n\n### 解决方案\n\n该问题要求在指定的隐马尔可夫模型中，给定一个观测序列 $\\mathbf{x} = (x_1, \\dots, x_T)$，找到最可能的隐状态序列 $\\mathbf{z}^\\star = (z_1, \\dots, z_T)$。这等同于找到使联合概率 $\\Pr(\\mathbf{z}, \\mathbf{x})$ 最大化的序列 $\\mathbf{z}$。为避免数值下溢，标准做法是最大化此概率的对数：\n$$ \\mathbf{z}^\\star = \\arg\\max_{\\mathbf{z}} \\Pr(\\mathbf{z}, \\mathbf{x}) = \\arg\\max_{\\mathbf{z}} \\log \\Pr(\\mathbf{z}, \\mathbf{x}) $$\n特定路径 $\\mathbf{z}=(z_1, \\dots, z_T)$ 的联合对数概率由下式给出：\n$$ \\log \\Pr(\\mathbf{z}, \\mathbf{x}) = \\log \\pi_{z_1} + \\sum_{t=2}^{T} \\log A_{z_{t-1}, z_t} + \\sum_{t=1}^{T} \\log p(x_t | z_t) $$\n其中 $\\pi_{z_1}$ 是状态 $z_1$ 的初始概率，$A_{z_{t-1}, z_t}$ 是从状态 $z_{t-1}$ 到 $z_t$ 的转移概率，而 $p(x_t | z_t)$ 是在给定状态 $z_t$ 的情况下观测到 $x_t$ 的发射概率。\n\n完成此任务的权威算法是 **Viterbi 算法**，这是一种动态规划方法。它通过迭代构建路径来高效地计算最可能的状态序列。我们定义 $v_t(j)$ 为在观测到 $(x_1, \\dots, x_t)$ 的情况下，任何长度为 $t$ 且以状态 $j$ 结尾的状态序列的最大对数概率。\n\n该算法分四个步骤进行：\n\n**1. 初始化 ($t=1$)**\n对于每个状态 $j \\in \\{0, 1, 2\\}$，我们计算初始对数概率。这是初始概率的对数与第一次观测 $x_1$ 的发射概率对数之和。\n$$ v_1(j) = \\log \\pi_j + \\log p(x_1 | z_1=j) $$\n发射概率 $p(x|z=j)$ 服从正态分布 $\\mathcal{N}(\\mu_j, \\sigma_j^2)$。其对数概率密度函数为：\n$$ \\log p(x | z=j) = -\\frac{(x - \\mu_j)^2}{2\\sigma_j^2} - \\frac{1}{2}\\log(2\\pi\\sigma_j^2) $$\n\n**2. 递归 ($t=2, \\dots, T$)**\n对于每个后续时间步 $t$ 和每个状态 $j \\in \\{0, 1, 2\\}$，我们找到从上一步最可能转移到状态 $j$ 的路径。对数概率 $v_t(j)$ 是截至时间 $t-1$ 的最佳路径的对数概率，加上转移概率的对数，再加上当前观测 $x_t$ 的发射概率的对数。\n$$ v_t(j) = \\log p(x_t | z_t=j) + \\max_{i \\in \\{0,1,2\\}} \\left( v_{t-1}(i) + \\log A_{ij} \\right) $$\n为了稍后重建路径，我们还必须存储达到此最大值的状态 $i$。令其为 $\\text{ptr}_t(j):$\n$$ \\text{ptr}_t(j) = \\arg\\max_{i \\in \\{0,1,2\\}} \\left( v_{t-1}(i) + \\log A_{ij} \\right) $$\n问题的平局打破规则（选择最小的状态索引）由标准的 `argmax` 函数处理，该函数返回最大值的第一个索引。\n\n**3. 终止**\n在计算了截至最终时间步 $T$ 的概率格之后，最终位置的最优状态 $z_T^\\star$ 是具有最高总对数概率的状态：\n$$ z_T^\\star = \\arg\\max_{j \\in \\{0,1,2\\}} v_T(j) $$\n同样，平局打破规则适用。\n\n**4. 路径回溯**\n最可能的状态序列 $\\mathbf{z}^\\star$ 是通过从 $z_T^\\star$ 开始，并使用存储的指针向后回溯来重建的：\n$$ z_{t-1}^\\star = \\text{ptr}_t(z_t^\\star) \\quad \\text{for } t = T, T-1, \\dots, 2 $$\n此过程产生问题陈述所要求的唯一最优状态序列。实现将精确遵循此逻辑，对所有概率计算使用数值对数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Solves the HMM decoding problem for the given test cases using the Viterbi algorithm.\n    \"\"\"\n    \n    # HMM parameters as specified in the problem\n    pi = np.array([0.6, 0.1, 0.3])\n    A = np.array([\n        [0.80, 0.10, 0.10],\n        [0.45, 0.10, 0.45],\n        [0.10, 0.10, 0.80]\n    ])\n    mus = np.array([0.8, 2.0, 0.0])\n    # The problem provides variance (sigma^2), scipy.stats.norm requires standard deviation (sigma)\n    sigmas_sq = np.array([0.25, 0.25, 0.25])\n    sigmas = np.sqrt(sigmas_sq)\n    \n    # Convert probabilities to log-space to prevent underflow and for numerical stability\n    log_pi = np.log(pi)\n    log_A = np.log(A)\n    \n    n_states = len(pi)\n\n    def viterbi(obs_seq):\n        \"\"\"\n        Implements the Viterbi algorithm to find the most likely state sequence.\n\n        Args:\n            obs_seq (list or np.ndarray): The sequence of observations.\n\n        Returns:\n            list: The most likely sequence of state indices.\n        \"\"\"\n        T = len(obs_seq)\n        if T == 0:\n            return []\n\n        # viterbi_trellis[t, j] stores the max log-prob of a path ending in state j at time t\n        viterbi_trellis = np.zeros((T, n_states))\n        # backpointers[t, j] stores the best previous state that leads to state j at time t\n        backpointers = np.zeros((T, n_states), dtype=int)\n\n        # 1. Initialization Step (t=0)\n        log_emissions_t0 = np.array([norm.logpdf(obs_seq[0], loc=mu, scale=sigma) \n                                     for mu, sigma in zip(mus, sigmas)])\n        viterbi_trellis[0, :] = log_pi + log_emissions_t0\n\n        # 2. Recursion Step (t=1 to T-1)\n        for t in range(1, T):\n            log_emissions_t = np.array([norm.logpdf(obs_seq[t], loc=mu, scale=sigma) \n                                        for mu, sigma in zip(mus, sigmas)])\n            \n            # Vectorized computation for all current states j\n            # scores[i, j] = viterbi_trellis[t-1, i] + log_A[i, j]\n            scores = viterbi_trellis[t-1, :].reshape(-1, 1) + log_A\n            \n            # For each current state j, find the best previous state i.\n            # np.argmax correctly implements the tie-breaking rule (smallest index first).\n            viterbi_trellis[t, :] = np.max(scores, axis=0) + log_emissions_t\n            backpointers[t, :] = np.argmax(scores, axis=0)\n        \n        # 3. Termination Step\n        # Find the best final state. np.argmax handles tie-breaking.\n        best_last_state = np.argmax(viterbi_trellis[T-1, :])\n\n        # 4. Backtracking Step\n        path = [best_last_state]\n        current_state = best_last_state\n        for t in range(T - 1, 0, -1):\n            current_state = backpointers[t, current_state]\n            path.insert(0, current_state)\n            \n        return path\n\n    test_cases = [\n        [0.9, 0.7, 0.8, 1.9, 2.2, 0.2, 0.1, 0.0],\n        [2.1],\n        [0.1, 0.0, 0.9, 0.8, 0.7, 0.2],\n        [0.75, 0.85, 0.95, 0.05, -0.1, 0.0, 1.8, 2.1, 1.9, 0.6]\n    ]\n\n    results = []\n    for case in test_cases:\n        result_path = viterbi(case)\n        results.append(result_path)\n\n    # Format the output string as specified: [[...],[...],...] with no spaces\n    outer_parts = []\n    for res_list in results:\n        inner_str = '[' + ','.join(map(str, res_list)) + ']'\n        outer_parts.append(inner_str)\n    final_output = '[' + ','.join(outer_parts) + ']'\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2437210"}]}