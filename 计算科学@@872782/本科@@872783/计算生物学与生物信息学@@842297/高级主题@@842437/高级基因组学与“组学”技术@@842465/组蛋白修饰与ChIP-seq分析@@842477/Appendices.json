{"hands_on_practices": [{"introduction": "在深入分析任何ChIP-seq数据之前，首要任务是评估其质量。一个成功的实验应该在预期的信号区域（“峰”，peaks）富集大量的测序读数（reads），同时在已知的假信号或背景噪音区域（“黑名单”，blacklists）读数很少。这项练习 [@problem_id:2397933] 将这一概念具体化，要求您计算一个量化的信噪比，这是数据质量控制中的一项基本技能。", "problem": "给定一个针对组蛋白修饰染色质免疫共沉淀测序 (ChIP-seq) 实验的质量控制的数学形式化描述。基因组被建模为一个长度为 $L$ 个碱基对 (bp) 的一维坐标轴，所有坐标均为整数。每个比对上的读段 (read) 表示为一个半开基因组区间 $[s_i, e_i)$，其中 $0 \\le s_i < e_i \\le L$。候选峰 (peak) 表示为一个有限的半开区间集合 $\\{P_j\\}$，共识黑名单区域表示为一个有限的半开区间集合 $\\{B_k\\}$。所有区间都以碱基对为单位。\n\n定义读段 $i$ 与区间集合 $S$ 相交的指示符如下：读段 $i$ 与 $S$ 相交，当且仅当 $[s_i, e_i)$ 与 $S$ 中区间的并集的交集在半开语义下长度非零，即对于至少一个区间 $[a,b) \\in S$，满足\n$$\n\\max(s_i, a) < \\min(e_i, b)\n$$\n一个读段，无论其与集合内多少个区间相交，对于每个集合（峰或黑名单）最多只计数一次。同时与峰和黑名单相交的读段在两边的计数中都计入。\n\n设 $R_{\\mathrm{peaks}}$ 为与至少一个峰区间相交的读段数，设 $R_{\\mathrm{blacklist}}$ 为与至少一个黑名单区间相交的读段数。对于给定的伪计数 $\\epsilon > 0$，定义质量控制指标\n$$\nQ \\;=\\; \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}.\n$$\n该比率量化了峰区域中的读段富集 (RiP) 相对于共识黑名单区域中读段的情况，并使用伪计数进行稳定化。\n\n您的任务是为以下每个测试用例计算 $Q$。所有用例均使用相同的伪计数 $\\epsilon = 0.5$。所有坐标均为以碱基对为单位的整数，所有区间均为半开区间 $[x,y)$。\n\n测试套件（每个用例提供 $L$、读段列表、峰列表和黑名单区间列表）：\n- 用例 $1$：\n  - $L = 1000$，$\\epsilon = 0.5$。\n  - 读段：$[(90,110),(140,170),(180,210),(300,320),(405,415),(495,505),(800,820),(850,870),(880,920),(0,10)]$。\n  - 峰：$[(100,200),(400,500)]$。\n  - 黑名单：$[(150,160),(800,900)]$。\n- 用例 $2$：\n  - $L = 1000$，$\\epsilon = 0.5$。\n  - 读段：$[(110,115),(150,160),(90,95),(300,310)]$。\n  - 峰：$[(100,200)]$。\n  - 黑名单：$[(600,700)]$。\n- 用例 $3$：\n  - $L = 1000$，$\\epsilon = 0.5$。\n  - 读段：$[(805,815),(810,830),(200,210)]$。\n  - 峰：$[(400,450)]$。\n  - 黑名单：$[(800,820)]$。\n- 用例 $4$（半开语义下的边界条件）：\n  - $L = 500$，$\\epsilon = 0.5$。\n  - 读段：$[(80,100),(200,220),(199,200),(250,260),(150,200)]$。\n  - 峰：$[(100,200)]$。\n  - 黑名单：$[(200,250)]$。\n- 用例 $5$（与峰和黑名单均有重叠，包括重复的读段）：\n  - $L = 1000$，$\\epsilon = 0.5$。\n  - 读段：$[(240,260),(620,630),(610,615),(660,670),(0,50),(295,305),(620,630)]$。\n  - 峰：$[(100,300),(600,650)]$。\n  - 黑名单：$[(250,350),(620,700)]$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用例 1 到 5 的 $Q$ 值结果，按顺序以逗号分隔，并用方括号括起来。每个 $Q$ 值必须四舍五入到恰好 $6$ 位小数。例如，一个包含三个值的输出应类似于 $[0.500000,1.250000,2.000000]$。", "solution": "该问题要求为一系列染色质免疫共沉淀测序 (ChIP-seq) 实验计算一个质量控制指标 $Q$。该指标定义为指定峰区域中的读段计数与黑名单区域中读段计数的比率，并通过伪计数 $\\epsilon$ 进行稳定化。\n\n其基本的几何对象是代表基因组位置的一维半开区间 $[s, e)$。我们给定一个读段集合 $\\{[s_i, e_i)\\}$，一个峰区间集合 $\\{P_j\\}$，以及一个黑名单区间集合 $\\{B_k\\}$。问题为读段区间与区间集合的相交提供了精确的定义。如果存在至少一个区间 $[a, b) \\in S$ 使得它们交集的长度非零，那么一个读段 $[s_i, e_i)$ 就被认为与区间集合 $S$ 相交。该条件被正式表述为 $\\max(s_i, a) < \\min(e_i, b)$。\n\n我们的目标是为每个测试用例计算两个量：\n$1$. $R_{\\mathrm{peaks}}$，即与峰区间集合 $\\{P_j\\}$ 相交的读段总数。\n$2$. $R_{\\mathrm{blacklist}}$，即与黑名单区间集合 $\\{B_k\\}$ 相交的读段总数。\n\n如果一个读段与给定集合中的至少一个区间相交，则该读段被计数。无论它与该集合内的多少个区间重叠，它对该集合的计数只贡献一次。如果一个读段同时与峰集合中的一个区间和黑名单集合中的一个区间相交，它将对 $R_{\\mathrm{peaks}}$ 和 $R_{\\mathrm{blacklist}}$ 的计数都有贡献。\n\n然后使用以下公式计算质量控制指标 $Q$：\n$$\nQ = \\frac{R_{\\mathrm{peaks}} + \\epsilon}{R_{\\mathrm{blacklist}} + \\epsilon}\n$$\n对于所有测试用例，伪计数给定为 $\\epsilon = 0.5$。\n\n算法流程如下：\n对于每个测试用例：\n初始化计数 $R_{\\mathrm{peaks}} = 0$ 和 $R_{\\mathrm{blacklist}} = 0$。\n遍历读段列表中的每个读段区间 $[s_i, e_i)$。\n对于当前读段，我们执行两个独立的检查：\n首先，我们检查与峰集合的相交情况。我们遍历每个峰区间 $[p_s, p_e) \\in \\{P_j\\}$。如果对于任何一个峰区间，条件 $\\max(s_i, p_s) < \\min(e_i, p_e)$ 满足，则该读段与峰集合相交。我们将 $R_{\\mathrm{peaks}}$ 的值加 1，并停止对该读段与该集合中其他峰区间的检查。\n其次，我们检查与黑名单集合的相交情况。我们遍历每个黑名单区间 $[b_s, b_e) \\in \\{B_k\\}$。如果对于任何一个黑名单区间，条件 $\\max(s_i, b_s) < \\min(e_i, b_e)$ 满足，则该读段与黑名单集合相交。我们将 $R_{\\mathrm{blacklist}}$ 的值加 1，并停止对该读段与该集合中其他黑名单区间的检查。\n遍历完所有读段后，我们使用最终的计数 $R_{\\mathrm{peaks}}$ 和 $R_{\\mathrm{blacklist}}$，通过给定公式计算 $Q$。\n\n我们将此过程应用于每个测试用例。\n\n用例 $1$：$R_{\\mathrm{peaks}} = 5$，$R_{\\mathrm{blacklist}} = 4$。\n$$Q = \\frac{5 + 0.5}{4 + 0.5} = \\frac{5.5}{4.5} \\approx 1.222222$$\n\n用例 $2$：$R_{\\mathrm{peaks}} = 2$，$R_{\\mathrm{blacklist}} = 0$。\n$$Q = \\frac{2 + 0.5}{0 + 0.5} = \\frac{2.5}{0.5} = 5.0$$\n\n用例 $3$：$R_{\\mathrm{peaks}} = 0$，$R_{\\mathrm{blacklist}} = 2$。\n$$Q = \\frac{0 + 0.5}{2 + 0.5} = \\frac{0.5}{2.5} = 0.2$$\n\n用例 $4$：$R_{\\mathrm{peaks}} = 2$，$R_{\\mathrm{blacklist}} = 1$。在这里，半开区间的定义至关重要。例如，读段 $[80, 100)$ 不与峰 $[100, 200)$ 相交，因为 $\\max(80, 100) = 100$ 且 $\\min(100, 200) = 100$，而条件 $100 < 100$ 为假。\n$$Q = \\frac{2 + 0.5}{1 + 0.5} = \\frac{2.5}{1.5} \\approx 1.666667$$\n\n用例 $5$：$R_{\\mathrm{peaks}} = 5$，$R_{\\mathrm{blacklist}} = 5$。读段列表包含一个重复的条目 (620, 630)，它被视为两个独立的读段，并都按照规则进行处理。该读段的两个实例都与峰集合和黑名单集合相交。\n$$Q = \\frac{5 + 0.5}{5 + 0.5} = \\frac{5.5}{5.5} = 1.0$$\n\n收集最终结果并按规定格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the ChIP-seq quality control metric Q for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"L\": 1000,\n            \"reads\": [(90, 110), (140, 170), (180, 210), (300, 320), (405, 415), (495, 505), (800, 820), (850, 870), (880, 920), (0, 10)],\n            \"peaks\": [(100, 200), (400, 500)],\n            \"blacklist\": [(150, 160), (800, 900)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(110, 115), (150, 160), (90, 95), (300, 310)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(600, 700)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(805, 815), (810, 830), (200, 210)],\n            \"peaks\": [(400, 450)],\n            \"blacklist\": [(800, 820)],\n        },\n        {\n            \"L\": 500,\n            \"reads\": [(80, 100), (200, 220), (199, 200), (250, 260), (150, 200)],\n            \"peaks\": [(100, 200)],\n            \"blacklist\": [(200, 250)],\n        },\n        {\n            \"L\": 1000,\n            \"reads\": [(240, 260), (620, 630), (610, 615), (660, 670), (0, 50), (295, 305), (620, 630)],\n            \"peaks\": [(100, 300), (600, 650)],\n            \"blacklist\": [(250, 350), (620, 700)],\n        },\n    ]\n\n    epsilon = 0.5\n    results = []\n\n    def intersects_set(read_interval, interval_set):\n        \"\"\"\n        Checks if a read interval intersects with any interval in a given set.\n        Intersection of [s, e) and [a, b) is non-empty if max(s, a)  min(e, b).\n        \"\"\"\n        s_i, e_i = read_interval\n        for a_j, b_j in interval_set:\n            if max(s_i, a_j)  min(e_i, b_j):\n                return True\n        return False\n\n    for case in test_cases:\n        reads = case[\"reads\"]\n        peaks = case[\"peaks\"]\n        blacklist = case[\"blacklist\"]\n\n        r_peaks = 0\n        r_blacklist = 0\n\n        for read in reads:\n            # Check for intersection with peaks\n            if intersects_set(read, peaks):\n                r_peaks += 1\n            \n            # Check for intersection with blacklist\n            if intersects_set(read, blacklist):\n                r_blacklist += 1\n        \n        # Calculate the quality metric Q\n        Q = (r_peaks + epsilon) / (r_blacklist + epsilon)\n        results.append(f\"{Q:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2397933"}, {"introduction": "当我们对数据质量有信心后，下一个关键步骤是识别基因组中读数显著富集的区域，即“峰”（peaks）。这项练习 [@problem_id:2397925] 将指导您从零开始构建一个基础的peak识别程序（peak caller）。您将学习如何使用泊松分布来模拟背景噪音，并应用统计检验与多重检验校正，从而将真实的信号从随机波动中区分出来。", "problem": "您的任务是通过将基因组区间上的测序片段到达模拟为均匀泊松点过程，为染色质免疫沉淀-DNA测序 (ChIP-seq) 的测序片段堆积设计并实现一个简单的富集区域识别程序。其科学依据是均匀泊松点过程的定义：不相交区间中的事件计数是独立的，任何长度为 $w$ 的区间中的计数遵循均值为 $\\lambda w$ 的泊松分布，其中 $\\lambda$ 是单位长度的恒定事件率。在这种背景下，根据无富集的零模型，ChIP-seq 测序片段被理想化为长度为 $L$ 的基因组片段上均匀泊松点过程的事件，其背景率为每碱基对 $\\lambda_0$ 个测序片段。宽度为 $w$ 个碱基对的扫描窗口产生的测序片段计数的零分布是均值为 $\\mu = \\lambda_0 w$ 的泊松分布。为检测富集，将每个窗口中的观测计数与此零分布进行比较，使用单侧尾部概率来计算观测到至少该测量计数的概率，然后使用 Benjamini–Hochberg 步进程序在所有测试窗口上控制假发现率 (FDR)。\n\n您的任务是编写一个完整的程序，该程序：\n- 在代码中以内部常量的形式，接受每个测试用例的以下参数：一个测序片段位置列表（以整数表示，从 $0$ 到 $L-1$ 的碱基对），基因组区间长度 $L$（以碱基对为单位），窗口宽度 $w$（以碱基对为单位），扫描步长 $s$（以碱基对为单位），背景率 $\\lambda_0$（以每碱基对的测序片段数为单位），以及目标 FDR 水平 $q$（以小数而非百分比表示）。\n- 扫描起始位置为 $t \\in \\{0, s, 2s, \\ldots\\}$ 且满足 $t + w \\le L$ 的窗口 $[t, t+w)$。\n- 计数每个窗口中的测序片段，计算在均值为 $\\mu = \\lambda_0 w$ 的泊松零分布下，“观测计数至少为测量计数”事件的单侧尾部概率，并在测试用例内的所有扫描窗口上应用目标水平为 $q$ 的 Benjamini–Hochberg 步进程序。\n- 为每个测试用例返回经过多重检验校正后被判定为显著的窗口起始坐标（以碱基对为单位）列表。该列表必须按基因组坐标升序排序。\n\n科学和算法约束：\n- 使用均匀泊松点过程作为背景测序片段到达的零模型，其恒定率为 $\\lambda_0$；在宽度为 $w$ 的窗口中，零计数分布是均值为 $\\mu = \\lambda_0 w$ 的泊松分布。\n- 对每个窗口使用单侧富集检验，评估在泊松零分布下观测到至少为测量计数的尾部概率。\n- 在测试用例中的所有窗口上，使用 Benjamini–Hochberg 步进程序将假发现率控制在水平 $q$。\n- 位置以碱基对为单位进行测量；以整数形式报告窗口的起始坐标（以碱基对为单位）。\n\n在您的程序中实现的测试套件（每个都是独立的测试用例）：\n- 用例 A（仅背景；预期无峰）：$L = 1000$，$w = 100$，$s = 100$，$\\lambda_0 = 0.01$ 每碱基对的测序片段数，$q = 0.1$，测序片段位置 $[50, 250, 750]$。预期行为：无显著窗口。\n- 用例 B（一个清晰的内部峰）：$L = 1000$，$w = 100$，$s = 100$，$\\lambda_0 = 0.01$ 每碱基对的测序片段数，$q = 0.1$，测序片段位置 $[20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]$。预期行为：起始位置为 $400$ 碱基对的窗口是显著的。\n- 用例 C（末端边界峰）：$L = 500$，$w = 100$，$s = 100$，$\\lambda_0 = 0.01$ 每碱基对的测序片段数，$q = 0.05$，测序片段位置 $[401, 402, 415, 420, 430, 440, 450, 460, 480]$。预期行为：起始位置为 $400$ 碱基对的窗口是显著的。\n- 用例 D（多个中等峰；多重检验相互作用）：$L = 800$，$w = 100$，$s = 100$，$\\lambda_0 = 0.01$ 每碱基对的测序片段数，$q = 0.1$，测序片段位置 $[110, 115, 120, 130, 180, 505, 510, 530, 540, 590]$。预期行为：起始位置为 $100$ 和 $500$ 碱基对的窗口是显著的。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含所有四个用例的结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是代表相应案例中显著窗口起始坐标的整数列表。例如，一个有效的格式是 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不带任何额外文本。所有坐标必须是整数形式的碱基对（bp）。", "solution": "我们的任务是设计一个计算流程，用于识别染色质免疫沉淀测序 (ChIP-seq) 数据中的信号富集区域。这是计算基因组学中的一个典型问题，被称为“峰检测”。所给定的问题陈述在科学上是合理的，在算法上是明确定义的，并且基于已确立的生物统计学原理。因此，它是有效的，我们着手构建解决方案。\n\n基本前提是使用一个随机过程来模拟测序片段的背景分布。在没有特定蛋白质-脱氧核糖核酸结合的零假设下，假定测序片段在基因组上是随机分布的。均匀泊松点过程为这种随机背景提供了一个简单而强大的零模型。\n\n我们方法的核心包括三个阶段：首先，对基因组进行分区并量化测序片段计数；其次，根据零模型评估观测计数的统计显著性；第三，对在整个基因组上执行的多重检验进行校正。\n\n首先，我们处理基因组平铺和测序片段计数的任务。使用宽度为 $w$ 和步长为 $s$ 的滑动窗口扫描长度为 $L$ 的基因组区间。这些窗口的起始坐标由集合 $\\{t_i = i \\cdot s \\mid i \\in \\mathbb{Z}_{\\ge 0}, i \\cdot s + w \\le L\\}$ 给出。窗口总数，也就是统计检验的总数，为 $M = \\lfloor \\frac{L-w}{s} \\rfloor + 1$。对于每个跨越基因组区间 $[t_i, t_i+w)$ 的窗口 $i$，我们计算其位置落在此区间内的观测测序片段数量，记为 $k_i$。\n\n其次，我们构建用于富集分析的统计检验。零假设 $H_0$ 指出，测序片段的到达遵循一个均匀泊松过程，其恒定率为每碱基对 $\\lambda_0$ 个测序片段。因此，任何宽度为 $w$ 的窗口中的测序片段数 $X$ 遵循均值参数为 $\\mu = \\lambda_0 w$ 的泊松分布。其概率质量函数为 $P(X=k | H_0) = \\frac{e^{-\\mu}\\mu^k}{k!}$。为了检验富集，我们为每个窗口 $i$ 计算一个单侧 p 值。这个 p 值是在零分布下观测到至少 $k_i$ 个测序片段的概率。这对应于泊松分布的生存函数（或互补累积分布函数）：\n$$p_i = P(X \\ge k_i) = \\sum_{j=k_i}^{\\infty} \\frac{e^{-\\mu}\\mu^j}{j!} = 1 - \\sum_{j=0}^{k_i-1} \\frac{e^{-\\mu}\\mu^j}{j!}$$\n一个小的 p 值表明，在随机背景的假设下，观测到的计数 $k_i$ 是极不可能的高，从而为拒绝该特定窗口的零假设提供了证据。\n\n第三，我们必须解决多重假设检验问题。由于我们对每个窗口都进行一次检验，总共进行 $M$ 次独立或相关的检验，使用一个朴素的 p 值阈值（例如，$p \\le 0.05$）会增加假阳性发现的比例。为了控制这一点，我们采用 Benjamini–Hochberg (BH) 程序，将假发现率 (FDR) 控制在指定的水平 $q$。FDR 是被错误拒绝的零假设所占的期望比例。BH 程序如下：\n1.  收集所有 $M$ 个 p 值组成的集合 $\\{p_1, p_2, \\ldots, p_M\\}$。\n2.  将这些 p 值按升序排序：$p_{(1)} \\le p_{(2)} \\le \\ldots \\le p_{(M)}$。\n3.  找到最大的整数秩 $k$，使得第 $k$ 个有序 p 值满足条件：\n    $$p_{(k)} \\le \\frac{k}{M}q$$\n4.  如果存在这样的 $k$，我们拒绝所有对应于 p 值 $p_{(1)}, p_{(2)}, \\ldots, p_{(k)}$ 的窗口的零假设。这些窗口被宣布为“显著的”。\n5.  如果不存在这样的 $k$（即 $p_{(1)}  \\frac{1}{M}q$），则不拒绝任何零假设，也没有窗口被宣布为显著。\n\n这个程序保证了对于独立的检验，期望的 FDR 小于或等于 $q$。最终输出是按此程序确定为显著的所有窗口的起始坐标 $t_i$ 的排序列表。\n\n因此，算法实现将系统地执行以下步骤：\n1.  根据 $L$，$w$ 和 $s$ 生成所有窗口的起始坐标。\n2.  对于每个窗口，高效地计算落在其边界内的测序片段数。首先对测序片段位置进行排序，可以使用二分搜索进行快速计数。\n3.  计算泊松参数 $\\mu = \\lambda_0 w$。\n4.  对于每个窗口计数 $k_i$，使用泊松($\\mu$)分布的生存函数计算相应的 p 值。\n5.  将 Benjamini-Hochberg 程序应用于所有 p 值的集合，以识别显著发现的子集。\n6.  返回显著窗口的起始坐标，并按升序排序。\n这为所提出的问题提供了一个严谨而完整的框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import poisson\n\ndef solve():\n    \"\"\"\n    Main function to run the ChIP-seq peak calling analysis for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A (background only; no peaks expected)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [50, 250, 750]\n        },\n        # Case B (one clear internal peak)\n        {\n            \"L\": 1000, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [20, 120, 405, 410, 420, 431, 440, 455, 460, 495, 800]\n        },\n        # Case C (boundary peak at the end)\n        {\n            \"L\": 500, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.05,\n            \"read_positions\": [401, 402, 415, 420, 430, 440, 450, 460, 480]\n        },\n        # Case D (multiple moderate peaks; multiple-testing interaction)\n        {\n            \"L\": 800, \"w\": 100, \"s\": 100, \"lambda_0\": 0.01, \"q\": 0.1,\n            \"read_positions\": [110, 115, 120, 130, 180, 505, 510, 530, 540, 590]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        w = case[\"w\"]\n        s = case[\"s\"]\n        lambda_0 = case[\"lambda_0\"]\n        q = case[\"q\"]\n        read_positions = np.array(sorted(case[\"read_positions\"]))\n\n        # Step 1: Generate window starts and count reads\n        window_starts = np.arange(0, L - w + 1, s, dtype=int)\n        \n        # Efficiently count reads in each window using pre-sorted positions\n        window_counts = np.zeros_like(window_starts, dtype=int)\n        for i, start in enumerate(window_starts):\n            end = start + w\n            left_idx = np.searchsorted(read_positions, start, side='left')\n            right_idx = np.searchsorted(read_positions, end, side='left')\n            window_counts[i] = right_idx - left_idx\n        \n        # Step 2: Calculate p-values based on Poisson null model\n        mu = lambda_0 * w\n        \n        # Calculate p-value: P(X >= k) = 1 - P(X = k-1). \n        # This is the survival function (sf).\n        # We use k-1 because sf(k, mu) calculates P(X > k). So sf(k-1, mu) is P(X > k-1) = P(X >= k).\n        # For k=0, k-1=-1. scipy.stats.poisson.sf handle this correctly and return 1.0.\n        p_values = poisson.sf(window_counts - 1, mu)\n        \n        # Step 3: Apply Benjamini-Hochberg procedure\n        num_tests = len(p_values)\n        significant_windows = []\n\n        if num_tests > 0:\n            # Get original indices sorted by p-value\n            sorted_indices = np.argsort(p_values)\n            sorted_p_values = p_values[sorted_indices]\n            \n            # Calculate BH thresholds\n            ranks = np.arange(1, num_tests + 1)\n            bh_thresholds = (ranks / num_tests) * q\n            \n            # Find p-values that are below the BH threshold\n            significant_mask = sorted_p_values = bh_thresholds\n            \n            if np.any(significant_mask):\n                # Find the largest rank k for which p_(k) = (k/m)*q\n                max_significant_rank_idx = np.where(significant_mask)[0][-1]\n                \n                # All hypotheses up to this rank are rejected\n                significant_original_indices = sorted_indices[:max_significant_rank_idx + 1]\n                \n                # Get the window start coordinates for the significant windows\n                significant_starts = window_starts[significant_original_indices]\n                significant_windows = sorted(significant_starts.tolist())\n\n        results.append(significant_windows)\n\n    # Final print statement in the exact required format.\n    # The default str() representation of a list is what's needed for the inner elements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397925"}, {"introduction": "ChIP-seq分析的最终目标是从peak数据中获得生物学洞见。这通常需要整合来自多个实验的数据，例如寻找不同组蛋白修饰的共现模式。这项练习 [@problem_id:2397930] 模拟了一个经典的生物学问题：识别“双价启动子”（bivalent promoters），这些启动子同时被激活型修饰（如H3K4me3）和抑制型修饰（如H3K27me3）所标记。通过这个练习，您将实践整合并解释多源peak信息所需的几何与逻辑运算。", "problem": "给定两种组蛋白修饰——组蛋白H3赖氨酸4三甲基化（H3K4me3）和组蛋白H3赖氨酸27三甲基化（H3K27me3）——的染色质免疫沉淀测序（ChIP-seq）peak检出结果的抽象表示，以及单条染色体上的一系列启动子区间。每个区间表示为整数坐标轴上的一个半开区间 $[s,e)$，单位为碱基对（base pairs），其中 $s$ 和 $e$ 是整数且 $s  e$。区间 $[s,e)$ 的长度为 $e - s$ 个碱基对。两个区间之间的重叠长度定义为它们共享的整数位置的数量；根据半开区间的约定，如果两个区间仅在一个边界点接触（例如 $[100,200)$ 和 $[200,300)$），它们的重叠长度为 $0$。\n\n定义一个启动子是双价的（bivalent），当且仅当存在至少一个H3K4me3 peak，其与该启动子的重叠长度大于或等于给定阈值 $t_{4}$（单位为碱基对），并且存在至少一个H3K27me3 peak，其与该启动子的重叠长度大于或等于给定阈值 $t_{27}$（单位为碱基对）。重叠标准对每个peak独立应用；对于给定的修饰，不要合并或累加来自多个peak的重叠长度。如果某个修饰的peak列表为空，则没有启动子能满足该修饰的存在性条件。\n\n对于下面的每个测试用例，您必须计算双价启动子的数量。所有坐标都是以碱基对为单位的整数，所有阈值 $t_{4}$ 和 $t_{27}$ 都是以碱基对为单位的非负整数。将所有结果表示为整数计数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[a,b,c]$），列表中的每个条目按所列顺序对应相应测试用例的双价启动子数量。\n\n测试套件：\n\n- 测试用例 $1$（一般情况）：\n  - 启动子 (ID, $[s,e)$): $(1,[1000,1500))$, $(2,[2000,2300))$, $(3,[3000,3300))$.\n  - H3K4me3 peaks $[s,e)$: $[1100,1400)$, $[1950,2100)$, $[3100,3120)$, $[5000,5100)$.\n  - H3K27me3 peaks $[s,e)$: $[1200,1600)$, $[2250,2350)$, $[3150,3290)$.\n  - 阈值: $t_{4} = 100$, $t_{27} = 100$.\n- 测试用例 $2$（边界接触和最小正重叠）：\n  - 启动子 (ID, $[s,e)$): $(1,[100,200))$, $(2,[400,500))$, $(3,[700,800))$.\n  - H3K4me3 peaks $[s,e)$: $[200,300)$, $[350,400)$, $[700,701)$.\n  - H3K27me3 peaks $[s,e)$: $[50,100)$, $[500,600)$, $[799,900)$.\n  - 阈值: $t_{4} = 1$, $t_{27} = 1$.\n- 测试用例 $3$（每种修饰有多个peak，各peak的阈值不累加）：\n  - 启动子 (ID, $[s,e)$): $(1,[1000,1100))$, $(2,[2000,2100))$, $(3,[3000,3100))$.\n  - H3K4me3 peaks $[s,e)$: $[950,980)$, $[1070,1120)$, $[1990,2060)$, $[2900,3000)$, $[3000,3050)$.\n  - H3K27me3 peaks $[s,e)$: $[1005,1050)$, $[2090,2150)$, $[2050,2105)$, $[3050,3100)$.\n  - 阈值: $t_{4} = 50$, $t_{27} = 50$.\n- 测试用例 $4$（空peak列表的边界情况）：\n  - 启动子 (ID, $[s,e)$): $(1,[100,200))$, $(2,[300,400))$.\n  - H3K4me3 peaks $[s,e)$: 空列表.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - 阈值: $t_{4} = 0$, $t_{27} = 0$.\n- 测试用例 $5$（当peak存在时，零阈值允许非重叠）：\n  - 启动子 (ID, $[s,e)$): $(1,[100,200))$.\n  - H3K4me3 peaks $[s,e)$: $[0,50)$.\n  - H3K27me3 peaks $[s,e)$: $[500,600)$.\n  - 阈值: $t_{4} = 0$, $t_{27} = 0$.\n\n您的程序必须确定性地计算每个测试用例中满足所述规则和阈值下双价定义的启动子ID的整数数量，然后以 $[a,b,c,d,e]$ 的精确格式输出单行结果，该结果按顺序对应五个测试用例。", "solution": "问题陈述经过了严格验证，被认为是有效的。它以计算基因组学原理为科学基础，在数学上是适定的，并以客观、无歧义的语言表达。确定性求解所需的所有数据和定义均已提供。\n\n问题的核心是根据一系列涉及基因组区间重叠的精确标准，识别并计数“双价启动子”。一个启动子被定义为双价的，如果它同时满足两个独立的条件：一个与组蛋白修饰H3K4me3有关，另一个与H3K27me3有关。\n\n设一个启动子区间表示为 $P = [s_p, e_p)$，一个（任一修饰的）peak区间表示为 $K = [s_k, e_k)$。这两个半开区间之间的重叠长度 $L_{overlap}$ 是它们交集的长度，计算公式如下：\n$$L_{overlap}(P, K) = \\max(0, \\min(e_p, e_k) - \\max(s_p, s_k))$$\n此公式能正确计算两个区间共享的整数位置数量。使用 $\\max(0, \\dots)$ 确保了不重叠区间的重叠长度为 $0$。\n\n根据所提供的定义，一个启动子 $P$ 是双价的，当且仅当以下两个逻辑条件都得到满足：\n$1.$ 在提供的H3K4me3 peak列表中，存在至少一个H3K4me3 peak $K_4$，使得其与启动子 $P$ 的重叠长度大于或等于指定阈值 $t_4$。形式上：\n$$\\exists K_4 \\in \\{\\text{H3K4me3 peaks}\\} \\text{ 使得 } L_{overlap}(P, K_4) \\ge t_4$$\n$2.$ 在提供的H3K27me3 peak列表中，存在至少一个H3K27me3 peak $K_{27}$，使得其与启动子 $P$ 的重叠长度大于或等于指定阈值 $t_{27}$。形式上：\n$$\\exists K_{27} \\in \\{\\text{H3K27me3 peaks}\\} \\text{ 使得 } L_{overlap}(P, K_{27}) \\ge t_{27}$$\n\n问题明确指出，这些条件是针对每个peak独立评估的。来自同一修饰的多个peak的重叠长度不应被累加。\n\n解决此问题的算法是该定义的直接实现：首先，我们将双价启动子的计数器初始化为 $0$。然后，我们遍历给定列表中的每个启动子。对于每个启动子，我们必须验证这两个存在性条件。\n\n为验证给定启动子的H3K4me3条件，我们首先检查H3K4me3 peak列表是否为空。如果为空，则存在性条件无法满足，该启动子不能是双价的。如果列表不为空，我们遍历每个H3K4me3 peak，计算其与启动子的重叠长度，并将其与阈值 $t_4$进行比较。如果我们找到任何满足条件 $L_{overlap} \\ge t_4$ 的peak，则该启动子的H3K4me3条件即被满足，我们可以立即停止检查此启动子的其他H3K4me3 peak。\n\n如果H3K4me3条件被满足，我们以类似的方式继续验证H3K27me3条件。我们检查H3K27me3 peak列表是否为空。如果不为空，我们遍历这些peak，计算它们与启动子的重叠长度，直到找到一个满足 $L_{overlap} \\ge t_{27}$ 的peak。如果找到这样的peak，则H3K27me3条件也被满足。\n\n一个启动子当且仅当H3K4M3和H3K27me3两个条件都成功验证时，才被计为双价的。对所有启动子重复此过程，计数器的最终值即为该测试用例的结果。\n\n当阈值为零时（例如 $t_4 = 0$）会出现一个特殊情况。由于重叠长度 $L_{overlap}$ 根据定义总是非负的（$L_{overlap} \\ge 0$），因此条件 $L_{overlap} \\ge 0$ 对任何一对区间都始终成立。因此，对于 $0$ 阈值，某个修饰的存在性条件被满足，当且仅当其对应的peak列表不为空。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bivalent promoter counting problem for all specified test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1 (general case)\n        {\n            \"promoters\": [(1000, 1500), (2000, 2300), (3000, 3300)],\n            \"h3k4me3_peaks\": [(1100, 1400), (1950, 2100), (3100, 3120), (5000, 5100)],\n            \"h3k27me3_peaks\": [(1200, 1600), (2250, 2350), (3150, 3290)],\n            \"t4\": 100,\n            \"t27\": 100,\n        },\n        # Test case 2 (boundary-touching and minimal positive overlaps)\n        {\n            \"promoters\": [(100, 200), (400, 500), (700, 800)],\n            \"h3k4me3_peaks\": [(200, 300), (350, 400), (700, 701)],\n            \"h3k27me3_peaks\": [(50, 100), (500, 600), (799, 900)],\n            \"t4\": 1,\n            \"t27\": 1,\n        },\n        # Test case 3 (multiple peaks per modification, per-peak thresholds not summed)\n        {\n            \"promoters\": [(1000, 1100), (2000, 2100), (3000, 3100)],\n            \"h3k4me3_peaks\": [(950, 980), (1070, 1120), (1990, 2060), (2900, 3000), (3000, 3050)],\n            \"h3k27me3_peaks\": [(1005, 1050), (2090, 2150), (2050, 2105), (3050, 3100)],\n            \"t4\": 50,\n            \"t27\": 50,\n        },\n        # Test case 4 (empty peak list edge case)\n        {\n            \"promoters\": [(100, 200), (300, 400)],\n            \"h3k4me3_peaks\": [],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n        # Test case 5 (zero thresholds admit non-overlaps when peaks exist)\n        {\n            \"promoters\": [(100, 200)],\n            \"h3k4me3_peaks\": [(0, 50)],\n            \"h3k27me3_peaks\": [(500, 600)],\n            \"t4\": 0,\n            \"t27\": 0,\n        },\n    ]\n\n    def calculate_overlap(interval1, interval2):\n        \"\"\"\n        Calculates the overlap length between two half-open intervals [s, e).\n        \n        Args:\n            interval1 (tuple): A tuple (start, end) for the first interval.\n            interval2 (tuple): A tuple (start, end) for the second interval.\n            \n        Returns:\n            int: The non-negative integer overlap length.\n        \"\"\"\n        s1, e1 = interval1\n        s2, e2 = interval2\n        \n        overlap_start = max(s1, s2)\n        overlap_end = min(e1, e2)\n        \n        return max(0, overlap_end - overlap_start)\n\n    def analyze_case(promoters, h3k4me3_peaks, h3k27me3_peaks, t4, t27):\n        \"\"\"\n        Counts the number of bivalent promoters for a single test case.\n        \"\"\"\n        bivalent_promoter_count = 0\n\n        for p_interval in promoters:\n            # Check for H3K4me3 mark\n            has_h3k4me3_mark = False\n            if h3k4me3_peaks:\n                for k4_peak in h3k4me3_peaks:\n                    if calculate_overlap(p_interval, k4_peak) >= t4:\n                        has_h3k4me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n            \n            # If K4 condition fails, the promoter cannot be bivalent. Continue to next promoter.\n            if not has_h3k4me3_mark:\n                continue\n\n            # Check for H3K27me3 mark\n            has_h3k27me3_mark = False\n            if h3k27me3_peaks:\n                for k27_peak in h3k27me3_peaks:\n                    if calculate_overlap(p_interval, k27_peak) >= t27:\n                        has_h3k27me3_mark = True\n                        break  # Found a qualifying peak, no need to check others\n\n            # If both conditions are met, increment the counter\n            if has_h3k4me3_mark and has_h3k27me3_mark:\n                bivalent_promoter_count += 1\n                \n        return bivalent_promoter_count\n\n    results = []\n    for case in test_cases:\n        result = analyze_case(\n            case[\"promoters\"],\n            case[\"h3k4me3_peaks\"],\n            case[\"h3k27me3_peaks\"],\n            case[\"t4\"],\n            case[\"t27\"]\n        )\n        results.append(result)\n\n    # Final output must be a single line in the specified format [a,b,c,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397930"}]}