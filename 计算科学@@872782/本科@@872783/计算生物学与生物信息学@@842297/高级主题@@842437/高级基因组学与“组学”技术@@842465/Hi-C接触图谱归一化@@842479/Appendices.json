{"hands_on_practices": [{"introduction": "在深入研究复杂的迭代算法之前，理解矩阵平衡的根本数学目标至关重要。本练习 ([@problem_id:2397239]) 要求您为一个简单的 $3 \\times 3$ 矩阵推导出一个精确的解析平衡解。通过手动求解这个方程组，您将从第一性原理的层面理解缩放因子如何消除系统性偏差，从而确保行与行之间可以进行公平的比较。", "problem": "高通量染色体构象捕获（Hi-C）接触图谱是一个对称矩阵，其元素表示基因组位点之间的相互作用计数。一个常见的归一化目标是通过对角缩放来平衡接触矩阵，使得缩放后矩阵的所有行（并因此，通过对称性，所有列）具有相同的和。考虑以下大小为 $3 \\times 3$ 的对称 Hi-C 接触子矩阵：\n$$\nA \\;=\\;\n\\begin{pmatrix}\n1  1  0 \\\\\n1  2  1 \\\\\n0  1  1\n\\end{pmatrix}.\n$$\n设 $D = \\mathrm{diag}(x_1, x_2, x_3)$，其中 $x_1, x_2, x_3 \\in \\mathbb{R}_{>0}$，并定义缩放后的矩阵 $B = D A D$。确定唯一的正对角缩放因子 $x_1, x_2, x_3$，使得 $B$ 的每一行之和都等于 $1$，即：\n$$\n\\sum_{j=1}^{3} B_{ij} \\;=\\; 1 \\quad \\text{对于每个 } i \\in \\{1,2,3\\}.\n$$\n请以单行矩阵 $\\begin{pmatrix} x_1  x_2  x_3 \\end{pmatrix}$ 的形式给出您的最终答案，并使用精确形式（无近似，无四舍五入）。", "solution": "所述问题具有科学依据，提法恰当且客观。它描述了一种在计算生物学中用于分析 Hi-C 数据的标准矩阵平衡程序。所提供的矩阵是一个有效的、对称的、非负的、不可约的矩阵，已知其存在唯一的正对角缩放解。因此，该问题是有效的，我们可以继续进行求解。\n\n问题要求找到一个对角矩阵 $D = \\mathrm{diag}(x_1, x_2, x_3)$，其中 $x_1, x_2, x_3 > 0$，使得缩放后的矩阵 $B = DAD$ 的所有行和都等于 $1$。给定的矩阵是\n$$\nA =\n\\begin{pmatrix}\n1  1  0 \\\\\n1  2  1 \\\\\n0  1  1\n\\end{pmatrix}\n$$\n缩放后的矩阵 $B$ 计算为 $B = DAD$。其元素 $B_{ij}$ 由公式 $B_{ij} = x_i A_{ij} x_j$ 给出。\n$$\nB =\n\\begin{pmatrix}\nx_1  0  0 \\\\\n0  x_2  0 \\\\\n0  0  x_3\n\\end{pmatrix}\n\\begin{pmatrix}\n1  1  0 \\\\\n1  2  1 \\\\\n0  1  1\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1  0  0 \\\\\n0  x_2  0 \\\\\n0  0  x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\cdot x_1 x_1  1 \\cdot x_1 x_2  0 \\cdot x_1 x_3 \\\\\n1 \\cdot x_2 x_1  2 \\cdot x_2 x_2  1 \\cdot x_2 x_3 \\\\\n0 \\cdot x_3 x_1  1 \\cdot x_3 x_2  1 \\cdot x_3 x_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nx_1^2  x_1 x_2  0 \\\\\nx_1 x_2  2x_2^2  x_2 x_3 \\\\\n0  x_2 x_3  x_3^2\n\\end{pmatrix}\n$$\n$B$ 的所有行和都等于 $1$ 的条件，即对 $i \\in \\{1, 2, 3\\}$ 都有 $\\sum_{j=1}^{3} B_{ij} = 1$，产生了以下非线性方程组：\n$$\n\\begin{cases}\n    x_1^2 + x_1 x_2 = 1  (1) \\\\\n    x_1 x_2 + 2x_2^2 + x_2 x_3 = 1  (2) \\\\\n    x_2 x_3 + x_3^2 = 1  (3)\n\\end{cases}\n$$\n我们必须求解这个方程组，得到正实数 $x_1, x_2, x_3$。\n从方程 $(1)$ 中，我们可以提出因子 $x_1$：\n$$\nx_1(x_1 + x_2) = 1\n$$\n由于 $x_1 > 0$，我们可以表示为 $x_1 + x_2 = \\frac{1}{x_1}$，这导致 $x_2 = \\frac{1}{x_1} - x_1 = \\frac{1-x_1^2}{x_1}$。\n为使 $x_2$ 为正，必须有 $1-x_1^2 > 0$，这意味着 $0  < x_1 < 1$。\n\n类似地，从方程 $(3)$ 中，我们提出因子 $x_3$：\n$$\nx_3(x_2 + x_3) = 1\n$$\n由于 $x_3 > 0$，我们有 $x_2 + x_3 = \\frac{1}{x_3}$，这导致 $x_2 = \\frac{1}{x_3} - x_3 = \\frac{1-x_3^2}{x_3}$。\n为使 $x_2$ 为正，必须有 $1-x_3^2 > 0$，这意味着 $0 < x_3 < 1$。\n\n通过令 $x_2$ 的两个表达式相等，我们得到了 $x_1$ 和 $x_3$ 之间的一个关键关系：\n$$\n\\frac{1}{x_1} - x_1 = \\frac{1}{x_3} - x_3\n$$\n$$\n\\frac{1}{x_1} - \\frac{1}{x_3} = x_1 - x_3\n$$\n$$\n\\frac{x_3 - x_1}{x_1 x_3} = -(x_3 - x_1)\n$$\n该方程有两个可能的解。\n情况1：$x_3 - x_1 = 0$，这意味着 $x_1 = x_3$。\n情况2：如果 $x_3 - x_1 \\neq 0$，我们可以两边同时除以 $(x_3 - x_1)$，得到 $\\frac{1}{x_1 x_3} = -1$，或 $x_1 x_3 = -1$。这是不可能的，因为问题规定 $x_1$ 和 $x_3$ 必须是正实数。\n因此，唯一有效的可能性是 $x_1 = x_3$。\n\n我们现在将 $x_3 = x_1$ 代入原始方程组。方程 $(3)$ 变得与方程 $(1)$ 相同。方程 $(2)$ 简化为：\n$$\nx_1 x_2 + 2x_2^2 + x_2 x_1 = 1\n$$\n$$\n2x_1 x_2 + 2x_2^2 = 1\n$$\n$$\n2x_2(x_1 + x_2) = 1\n$$\n我们现在得到一个简化的两方程系统：\n$$\n\\begin{cases}\n    x_1(x_1 + x_2) = 1  (A) \\\\\n    2x_2(x_1 + x_2) = 1  (B)\n\\end{cases}\n$$\n由于右边都等于 $1$，我们可以令左边相等：\n$$\nx_1(x_1 + x_2) = 2x_2(x_1 + x_2)\n$$\n由于 $x_1 > 0$ 和 $x_2 > 0$，项 $(x_1 + x_2)$ 严格为正。我们可以无损一般性地将其除掉：\n$$\nx_1 = 2x_2\n$$\n现在将此关系代入方程 $(A)$：\n$$\n(2x_2)(2x_2 + x_2) = 1\n$$\n$$\n(2x_2)(3x_2) = 1\n$$\n$$\n6x_2^2 = 1\n$$\n$$\nx_2^2 = \\frac{1}{6}\n$$\n由于 $x_2 > 0$，我们取正平方根：\n$$\nx_2 = \\sqrt{\\frac{1}{6}} = \\frac{1}{\\sqrt{6}} = \\frac{\\sqrt{6}}{6}\n$$\n利用我们导出的关系，我们找到 $x_1$ 和 $x_3$：\n$$\nx_1 = 2x_2 = 2 \\left( \\frac{\\sqrt{6}}{6} \\right) = \\frac{2\\sqrt{6}}{6} = \\frac{\\sqrt{6}}{3}\n$$\n并且由于 $x_3 = x_1$：\n$$\nx_3 = \\frac{\\sqrt{6}}{3}\n$$\n因此，唯一的正对角缩放因子是 $x_1 = \\frac{\\sqrt{6}}{3}$，$x_2 = \\frac{\\sqrt{6}}{6}$ 和 $x_3 = \\frac{\\sqrt{6}}{3}$。这些值满足约束条件和原始方程组。最终答案必须以单行矩阵的形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{6}}{3} & \\frac{\\sqrt{6}}{6} & \\frac{\\sqrt{6}}{3}\n\\end{pmatrix}\n}\n$$", "id": "2397239"}, {"introduction": "现实世界中的Hi-C数据通常包含一些需要被预先排除的低覆盖度“坏”行或“坏”列。本练习 ([@problem_id:2397206]) 将从解析理论转向实际的计算场景，要求您实现一个迭代平衡算法。您将探讨生物信息学中的一个关键问题：最终的归一化结果对初始数据筛选决策的敏感度有多高？", "problem": "您的任务是评估在高通量染色体构象捕获 (Hi-C) 接触图谱的背景下，矩阵平衡对于初始排除行和列选择的敏感性。设 $A \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$ 是一个非负项对称矩阵，表示 $n$ 个基因组区间之间的接触计数。对于一个初始排除集 $B \\subseteq \\{1,2,\\ldots,n\\}$，定义一个缩放向量 $x \\in \\mathbb{R}_{\\ge 0}^{n}$，使得对于所有 $i \\in B$ 有 $x_i = 0$，对于所有 $i \\notin B$ 有 $x_i > 0$，并设平衡后的矩阵为 $N = \\mathrm{diag}(x) \\, A \\, \\mathrm{diag}(x)$。平衡条件要求对于每一个 $i \\notin B$，都有\n$$\n\\sum_{j \\notin B} N_{ij} = \\sum_{j \\notin B} x_i \\, A_{ij} \\, x_j = 1.\n$$\n假设对于下面提供的矩阵和指定的排除集，存在满足上述约束的唯一向量 $x$。\n\n对于同一矩阵 $A$，定义两个初始排除集 $B^{(1)}$ 和 $B^{(2)}$ 之间的敏感性为，在保留索引的交集上，相应缩放向量之间的平均绝对差。更准确地说，设 $x^{(1)}$ 和 $x^{(2)}$ 分别是从 $B^{(1)}$ 和 $B^{(2)}$ 获得的缩放向量，并设 $S = \\{ i \\mid i \\notin B^{(1)}, \\, i \\notin B^{(2)} \\}$。敏感性为\n$$\n\\Delta(A,B^{(1)},B^{(2)}) \\;=\\; \\frac{1}{|S|} \\sum_{i \\in S} \\left| x^{(1)}_i - x^{(2)}_i \\right|.\n$$\n您的程序必须为下面测试套件中的每个测试用例计算 $\\Delta(A,B^{(1)},B^{(2)})$。\n\n该测试套件包含两个具有近对角富集的类 Hi-C 对称接触矩阵和五对排除集。索引是基于 1 的。矩阵如下：\n$$\nA^{(1)} \\;=\\; \\begin{bmatrix}\n10 & 6 & 3 & 1 & 0.5 \\\\\n6 & 9 & 5 & 2 & 1 \\\\\n3 & 5 & 8 & 4 & 2 \\\\\n1 & 2 & 4 & 7 & 3 \\\\\n0.5 & 1 & 2 & 3 & 6\n\\end{bmatrix},\n\\qquad\nA^{(2)} \\;=\\; \\begin{bmatrix}\n20 & 10 & 5 & 2 & 1 \\\\\n10 & 18 & 7 & 3 & 1.5 \\\\\n5 & 7 & 15 & 6 & 2 \\\\\n2 & 3 & 6 & 12 & 4 \\\\\n1 & 1.5 & 2 & 4 & 10\n\\end{bmatrix}.\n$$\n计算以下五种情况的 $\\Delta(A,B^{(1)},B^{(2)})$：\n- 情况 1: $A = A^{(1)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\varnothing$。\n- 情况 2: $A = A^{(1)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\{5\\}$。\n- 情况 3: $A = A^{(1)}$, $B^{(1)} = \\{1\\}$, $B^{(2)} = \\{5\\}$。\n- 情况 4: $A = A^{(2)}$, $B^{(1)} = \\varnothing$, $B^{(2)} = \\{3\\}$。\n- 情况 5: $A = A^{(2)}$, $B^{(1)} = \\{2,4\\}$, $B^{(2)} = \\{2,5\\}$。\n\n您的程序必须生成单行输出，其中包含五个结果，以逗号分隔的列表形式用方括号括起来，顺序与上述情况一致，每个值四舍五入到 6 位小数，即 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 是情况 $k$ 的 $\\Delta(A,B^{(1)},B^{(2)})$。不涉及物理单位。", "solution": "所提出的问题是计算生物学中一个定义明确的任务，具体涉及 Hi-C 接触图谱的归一化。在进行求解之前，需要对问题陈述进行验证。\n\n**问题验证**\n\n**步骤 1：提取的已知条件**\n- 一个输入的非负项对称矩阵 $A \\in \\mathbb{R}_{\\ge 0}^{n \\times n}$。\n- 一个基于 1 的索引的初始排除集 $B \\subseteq \\{1, 2, \\ldots, n\\}$。\n- 一个缩放向量 $x \\in \\mathbb{R}_{\\ge 0}^{n}$，其中对于 $i \\in B$ 有 $x_i = 0$，对于 $i \\notin B$ 有 $x_i > 0$。\n- 一个平衡后的矩阵 $N = \\mathrm{diag}(x) \\, A \\, \\mathrm{diag}(x)$。\n- 对每个 $i \\notin B$ 的平衡条件：$\\sum_{j \\notin B} N_{ij} = \\sum_{j \\notin B} x_i \\, A_{ij} \\, x_j = 1$。\n- 一个假设，即对于给定的矩阵和排除集，存在唯一的缩放向量 $x$。\n- 对于矩阵 $A$，两个排除集 $B^{(1)}$ 和 $B^{(2)}$ 之间的敏感性度量：$\\Delta(A,B^{(1)},B^{(2)}) = \\frac{1}{|S|} \\sum_{i \\in S} | x^{(1)}_i - x^{(2)}_i |$，其中 $x^{(1)}$ 和 $x^{(2)}$ 是 $B^{(1)}$ 和 $B^{(2)}$ 的缩放向量，且 $S = \\{ i \\mid i \\notin B^{(1)}, \\, i \\notin B^{(2)} \\}$。\n- 提供了两个特定矩阵 $A^{(1)}$ 和 $A^{(2)}$。\n- 给出了五个测试用例，为这些矩阵指定了排除集对。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题描述了矩阵平衡，这是 Hi-C 数据分析中一个标准且关键的步骤，用于消除实验偏差。指定的平衡条件是 Knight-Ruiz (KR) 平衡算法的一种形式，这是该领域中一种成熟的算法。该表述在科学上是合理的。\n- **适定性**：问题陈述断言了解向量 $x$ 的存在性和唯一性。对于与 Hi-C 数据相关的矩阵类别（非负、对称且通常不可约），此属性成立。因此，该问题在数学上是适定的。\n- **客观性和完整性**：所有术语都以数学精度进行了定义。输入数据和测试用例已完全指定。该问题是客观且自足的。\n\n**步骤 3：结论与行动**\n问题陈述被认为是有效的。它具有科学依据，数学上适定且完整。现在将推导并实现一个解决方案。\n\n**解决方案推导**\n\n核心任务是为给定的对称矩阵 $A$ 和排除集 $B$ 确定缩放向量 $x$。设 $I = \\{1, 2, \\ldots, n\\} \\setminus B$ 表示保留索引的集合。限制在这些索引上的平衡条件是\n$$\nx_i \\sum_{j \\in I} A_{ij} x_j = 1 \\quad \\forall i \\in I.\n$$\n这构成了一个关于 $x$ 的正分量的非线性方程组。设 $y$ 是由 $i \\in I$ 的元素 $x_i$ 组成的向量，设 $A_I$ 是通过选择索引在 $I$ 中的行和列而形成的 $A$ 的子矩阵。该系统可以写成：\n$$\ny_k \\left( \\sum_{l} (A_I)_{kl} y_l \\right) = 1\n$$\n对于 $y$ 的每个分量 $y_k$。这种结构表明可以采用不动点迭代法。我们可以重排方程来定义一个映射 $F(y)$：\n$$\ny_k = \\frac{1}{\\sum_{l} (A_I)_{kl} y_l} \\equiv F(y)_k.\n$$\n解 $y$ 是此映射的一个不动点，即 $y = F(y)$。这引出以下迭代算法：\n1. 将保留索引的缩放向量 $y^{(0)}$ 初始化，所有元素都等于 $1$。\n2. 对于每次迭代 $k = 0, 1, 2, \\ldots$，使用更新规则计算下一个近似值 $y^{(k+1)}$：\n   $$\n   y^{(k+1)} = F(y^{(k)}).\n   $$\n   按分量表示，即 $y_i^{(k+1)} = 1 / \\sum_{j} (A_I)_{ij} y_j^{(k)}$。\n3. 迭代持续进行，直到连续向量之间的变化可以忽略不计，例如，当差的无穷范数 $\\|y^{(k+1)} - y^{(k)}\\|_\\infty$ 小于预设的容差 $\\epsilon$ 时。问题对唯一解的保证确保了此过程会收敛。\n\n计算敏感性 $\\Delta(A, B^{(1)}, B^{(2)})$ 的总体流程如下：\n1. 对于排除集 $B^{(1)}$，对矩阵 $A$ 应用迭代算法以找到相应的缩放向量 $x^{(1)}$。对于 $B^{(1)}$ 中的索引，$x^{(1)}$ 的分量为零。\n2. 对排除集 $B^{(2)}$ 重复此过程，以找到向量 $x^{(2)}$。\n3. 识别公共保留索引集 $S = \\{ i \\mid i \\notin B^{(1)}, i \\notin B^{(2)} \\}$。\n4. 通过计算所有索引 $i \\in S$ 的绝对差 $|x^{(1)}_i - x^{(2)}_i|$ 的平均值来计算敏感性。\n\n这种方法是系统化且计算高效的。它将被实现以解决提供的测试用例。问题陈述中使用的基于 1 的索引需要在像使用 NumPy 的 Python 这样的编程环境中实现时，仔细转换为基于 0 的索引。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_scaling_vector(A, B_one_based, tol=1e-12, max_iter=2000):\n    \"\"\"\n    Computes the scaling vector x for a given matrix A and exclusion set B.\n    \n    The balancing condition is that for the submatrix of retained indices A_I,\n    diag(x_I) @ A_I @ x_I = 1 (vector of ones). This is solved iteratively.\n    \"\"\"\n    n = A.shape[0]\n    # Convert 1-based exclusion set to 0-based list of retained indices\n    I_zero_based = [i for i in range(n) if (i + 1) not in B_one_based]\n    \n    # If all indices are excluded, return a zero vector.\n    if not I_zero_based:\n        return np.zeros(n)\n        \n    # Extract the submatrix corresponding to retained indices.\n    A_sub = A[np.ix_(I_zero_based, I_zero_based)]\n    m = len(I_zero_based)\n    \n    # Initialize the scaling vector for the subproblem.\n    y = np.ones(m, dtype=float)\n    \n    # Iteratively solve for y using the fixed-point method.\n    for _ in range(max_iter):\n        y_prev = y\n        c = A_sub @ y\n        \n        # Guard against division by zero, though not expected for the given problem.\n        # The input matrices are positive, so for positive y, c will be positive.\n        if np.any(c == 0):\n           c[c == 0] = 1e-20\n\n        y = 1.0 / c\n        \n        # Check for convergence using the infinity norm.\n        if np.linalg.norm(y - y_prev, ord=np.inf) < tol:\n            break\n            \n    # Construct the full scaling vector x.\n    x = np.zeros(n, dtype=float)\n    x[I_zero_based] = y\n    \n    return x\n\ndef compute_delta(A, B1_one_based, B2_one_based):\n    \"\"\"\n    Computes the sensitivity between two exclusion sets B1 and B2 for matrix A.\n    \"\"\"\n    # Compute the scaling vectors for each exclusion set.\n    x1 = get_scaling_vector(A, B1_one_based)\n    x2 = get_scaling_vector(A, B2_one_based)\n    \n    n = A.shape[0]\n    U_one_based = set(range(1, n + 1))\n    \n    # Determine the set of common retained indices.\n    I1 = U_one_based - B1_one_based\n    I2 = U_one_based - B2_one_based\n    S_one_based = I1.intersection(I2)\n    \n    # If the intersection is empty, the mean difference is 0.\n    if not S_one_based:\n        return 0.0\n        \n    # Convert to 0-based indices for numpy array access.\n    S_zero_based = [s - 1 for s in S_one_based]\n    \n    # Compute the mean absolute difference over the common indices.\n    abs_diff = np.abs(x1[S_zero_based] - x2[S_zero_based])\n    delta = np.mean(abs_diff)\n    \n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and compute results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    A1 = np.array([\n        [10, 6, 3, 1, 0.5],\n        [6, 9, 5, 2, 1],\n        [3, 5, 8, 4, 2],\n        [1, 2, 4, 7, 3],\n        [0.5, 1, 2, 3, 6]\n    ], dtype=float)\n    \n    A2 = np.array([\n        [20, 10, 5, 2, 1],\n        [10, 18, 7, 3, 1.5],\n        [5, 7, 15, 6, 2],\n        [2, 3, 6, 12, 4],\n        [1, 1.5, 2, 4, 10]\n    ], dtype=float)\n\n    test_cases = [\n        (A1, set(), set()),             # Case 1\n        (A1, set(), {5}),               # Case 2\n        (A1, {1}, {5}),                 # Case 3\n        (A2, set(), {3}),               # Case 4\n        (A2, {2, 4}, {2, 5})            # Case 5\n    ]\n\n    results = []\n    for A, B1, B2 in test_cases:\n        result = compute_delta(A, B1, B2)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2397206"}, {"introduction": "修正系统性偏差的原理并不仅限于基因组学。这个高级练习 ([@problem_id:2397168]) 将Hi-C归一化概念的普适性展示在一个完全不同的领域中：分析计算机系统中的文件共访模式。您将构建一个复杂的两步归一化流程，首先使用回归模型来处理协变量（如文件大小和创建时间）引入的偏差，然后应用矩阵平衡来揭示潜在的功能关联。", "problem": "给定一个对称的非负整数矩阵，该矩阵编码了在固定观察窗口内计算机系统上文件之间的协同访问次数。每个对角线项是单个文件的自访问事件次数。此外，对于每个文件，还给定了两个协变量：文件大小和文件存在时间。任务是构建一个程序，通过消除协变量驱动的偏差来归一化协同访问矩阵，以识别功能关联，其使用的原理类似于计算生物学中的高通量染色体构象捕获（Hi-C）接触图谱归一化。\n\n假设以下基本依据：\n- 文件间的协同访问事件是独立的，并且可以通过泊松过程建模，因此观测到的计数来自于一个泊松分布，其强度取决于潜在的关联强度和每节点的偏差。\n- 每节点的偏差在文件对之间是乘性的，并通过对数线性模型依赖于文件协变量。\n- 一种平衡的对称归一化，类似于矩阵论中的双随机平衡，通过对非零行和列强制相等的行和与列和来消除剩余的节点特定偏差。\n\n设观测到的计数矩阵为 $C \\in \\mathbb{N}_0^{n \\times n}$，其中 $C_{ij} = C_{ji} \\ge 0$，文件大小为 $\\{s_i\\}_{i=1}^n$，其中 $s_i > 0$，文件存在时间为 $\\{a_i\\}_{i=1}^n$，其中 $a_i > 0$。潜在模型是对于每对 $(i,j)$，期望强度 $E[C_{ij}]$ 可分解为\n$$\nE[C_{ij}] = \\theta_{ij} \\cdot b_i \\cdot b_j,\n$$\n其中 $\\theta_{ij}$ 编码了协变量无关的关联倾向，$b_i$ 是文件 $i$ 的一个正偏差因子。该偏差因子遵循对数线性关系\n$$\n\\log b_i = \\beta_0 + \\beta_1 \\log s_i + \\beta_2 a_i,\n$$\n其中 $\\beta_0, \\beta_1, \\beta_2 \\in \\mathbb{R}$ 是未知系数。\n\n你的程序必须实现基于上述假设的以下归一化流程：\n1. 通过对 $C$ 的行和的对数拟合一个线性模型，来估计每个文件的总协同访问对协变量的依赖性。对于每个文件 $i$，定义边际值 $m_i = \\sum_{j=1}^n C_{ij}$。在拟合形式为\n$$\n\\log m_i \\approx \\gamma_0 + \\gamma_1 \\log s_i + \\gamma_2 a_i,\n$$\n的线性模型时，仅使用 $m_i > 0$ 的索引，并采用最小二乘法。使用拟合出的系数为所有 $i \\in \\{1,\\dots,n\\}$ 计算偏差估计 $\\hat{b}_i = \\exp(\\gamma_0 + \\gamma_1 \\log s_i + \\gamma_2 a_i)$。\n2. 通过乘性重加权形成一个协变量加权矩阵 $W$：\n$$\nW_{ij} = \\frac{C_{ij}}{\\hat{b}_i \\hat{b}_j}.\n$$\n3. 应用一个对称迭代比例拟合（平衡）过程，找到一个向量 $x \\in \\mathbb{R}_{\\ge 0}^n$，使得平衡矩阵\n$$\nB = \\operatorname{diag}(x) \\, W \\, \\operatorname{diag}(x)\n$$\n对于所有 $\\sum_{j=1}^n W_{ij} > 0$ 的行 $i$，其行和等于 $1$，而对于任何全为零的行，其行和等于 $0$。使用不动点迭代\n$$\nx_i^{(t+1)} = \\begin{cases}\n\\displaystyle \\frac{1}{\\sum_{j=1}^n W_{ij} x_j^{(t)}} & \\text{如果 } \\sum_{j=1}^n W_{ij} > 0, \\\\[1.25em]\n0 & \\text{其他情况},\n\\end{cases}\n$$\n初始化时，如果 $\\sum_{j=1}^n W_{ij} > 0$，则 $x_i^{(0)} = 1$，否则 $x_i^{(0)} = 0$。迭代直至收敛，即最大绝对变化 $\\max_i \\left| x_i^{(t+1)} - x_i^{(t)} \\right|$ 低于一个容差，或达到预设的最大迭代次数。\n\n实现要求：\n- 精确实现上述步骤。你可以为平衡步骤选择一个合理的较小容差（例如，$10^{-9}$）和一个最大迭代次数（例如，$10^4$）。\n- 为了回归步骤的数值稳定性，从拟合中排除 $m_i = 0$ 的文件。不要为了回归向 $m_i$ 添加任意伪计数。拟合后，使用拟合的系数为所有 $i$ 计算 $\\hat{b}_i$。\n- 计算出 $B$ 后，计算行和 $r_i = \\sum_{j=1}^n B_{ij}$。\n\n你的程序必须处理以下测试套件，并为每个案例输出行和列表：\n\n测试用例 A（正常路径，异构计数和协变量）：\n- 矩阵\n$$\nC^{(A)} =\n\\begin{bmatrix}\n100 & 10 & 5 & 0\\\\\n10 & 80 & 20 & 5\\\\\n5 & 20 & 60 & 15\\\\\n0 & 5 & 15 & 40\n\\end{bmatrix}\n$$\n- 大小\n$$\ns^{(A)} = \\begin{bmatrix} 1000 & 500 & 200 & 100 \\end{bmatrix}\n$$\n- 存在时间\n$$\na^{(A)} = \\begin{bmatrix} 5 & 2 & 1 & 0.5 \\end{bmatrix}\n$$\n\n测试用例 B（边缘情况，存在一个协同访问为零的孤立文件）：\n- 矩阵\n$$\nC^{(B)} =\n\\begin{bmatrix}\n30 & 5 & 0 & 0 & 0\\\\\n5 & 25 & 5 & 0 & 0\\\\\n0 & 5 & 20 & 10 & 0\\\\\n0 & 0 & 10 & 15 & 0\\\\\n0 & 0 & 0 & 0 & 0\n\\end{bmatrix}\n$$\n- 大小\n$$\ns^{(B)} = \\begin{bmatrix} 300 & 200 & 150 & 100 & 50 \\end{bmatrix}\n$$\n- 存在时间\n$$\na^{(B)} = \\begin{bmatrix} 1 & 2 & 3 & 4 & 5 \\end{bmatrix}\n$$\n\n测试用例 C（边界情况，计数均匀但协变量异构）：\n- 矩阵\n$$\nC^{(C)} =\n\\begin{bmatrix}\n10 & 10 & 10\\\\\n10 & 10 & 10\\\\\n10 & 10 & 10\n\\end{bmatrix}\n$$\n- 大小\n$$\ns^{(C)} = \\begin{bmatrix} 10^6 & 10^3 & 10 \\end{bmatrix}\n$$\n- 存在时间\n$$\na^{(C)} = \\begin{bmatrix} 10 & 5 & 1 \\end{bmatrix}\n$$\n\n最终输出规范：\n- 对于每个测试用例，计算平衡矩阵 $B$，然后计算行和向量 $r = \\left(r_1, \\dots, r_n\\right)$。\n- 将 $r$ 的每个条目四舍五入到 6 位小数。\n- 你的程序应生成单行输出，其中包含结果，形式为一个逗号分隔的列表，包含三个行和向量，每个向量都用方括号括起来。例如，输出格式必须是\n$$\n\\big[ [r_1^{(A)}, r_2^{(A)}, r_3^{(A)}, r_4^{(A)}], [r_1^{(B)}, \\dots, r_5^{(B)}], [r_1^{(C)}, r_2^{(C)}, r_3^{(C)}] \\big],\n$$\n其中每个 $r_i^{(\\cdot)}$ 显示为小数点后恰好有 6 位的小数。不要打印任何其他文本。", "solution": "该问题具有科学依据，定义明确且客观。它提出了一个计算任务，类似于生物信息学中的Hi-C接触图谱归一化，并将其应用于一个新颖的“文件协同访问”场景。其底层模型假设计数服从泊松分布，且其乘性偏差由对协变量的对数线性依赖关系决定，这是该领域的标准且可靠的方法。规定的归一化流程，涉及使用线性回归估计偏差，然后进行迭代矩阵平衡，是一个定义明确且算法上具体的过程。提供具体的测试用例、参数和要求的输出格式使问题陈述完整且明确无误。\n\n解决方案通过为每个测试用例实现指定的三个步骤来进行：\n\n**步骤 1：通过线性回归估计协变量偏差**\n\n对于每个文件 $i \\in \\{1, \\dots, n\\}$，我们首先计算其总协同访问计数，或称边际值，$m_i = \\sum_{j=1}^n C_{ij}$。模型假设文件 $i$ 的偏差 $b_i$ 与其大小 $s_i$ 和存在时间 $a_i$ 通过对数线性模型 $\\log b_i = \\beta_0 + \\beta_1 \\log s_i + \\beta_2 a_i$ 相关。期望边际值能反映这些偏差。我们通过拟合线性模型来估计一组相关的系数 $(\\gamma_0, \\gamma_1, \\gamma_2)$：\n$$\n\\log m_i \\approx \\gamma_0 + \\gamma_1 \\log s_i + \\gamma_2 a_i\n$$\n该模型使用普通最小二乘法进行拟合，但仅限于边际计数为非零的文件子集，即 $\\{i \\mid m_i > 0\\}$。这避免了对零取对数，并确保回归是在可观察的数据上进行的。如果我们设 $I = \\{i \\mid m_i > 0\\}$，我们构建一个设计矩阵 $X$，其中每一行是 $(1, \\log s_i, a_i)$（对于 $i \\in I$），以及一个响应向量 $y$，其元素为 $\\log m_i$（对于 $i \\in I$）。系数向量 $\\gamma = [\\gamma_0, \\gamma_1, \\gamma_2]^T$ 通过使用 `numpy.linalg.lstsq` 以最小二乘意义求解线性系统 $X\\gamma=y$ 来找到。\n\n一旦确定了系数 $\\gamma$，*每个* 文件 $i \\in \\{1, \\dots, n\\}$ 的偏差估计 $\\hat{b}_i$ 计算如下：\n$$\n\\hat{b}_i = \\exp(\\gamma_0 + \\gamma_1 \\log s_i + \\gamma_2 a_i)\n$$\n\n**步骤 2：构建协变量校正矩阵**\n\n然后，对原始计数矩阵 $C$ 进行校正，以消除估计出的协变量驱动的偏差。通过将每个元素 $C_{ij}$ 除以相应偏差估计的乘积 $\\hat{b}_i$ 和 $\\hat{b}_j$ 来形成一个新矩阵 $W$：\n$$\nW_{ij} = \\frac{C_{ij}}{\\hat{b}_i \\hat{b}_j}\n$$\n此操作可以用矩阵形式表示为 $W = \\operatorname{diag}(\\hat{b}^{-1}) \\, C \\, \\operatorname{diag}(\\hat{b}^{-1})$，其中 $\\hat{b}^{-1}$ 是 $\\hat{b}$ 的逐元素倒数向量。该矩阵 $W$ 代表了在移除协变量效应后的相互作用倾向。\n\n**步骤 3：对称迭代平衡**\n\n最后一步通过应用迭代平衡算法来解决任何剩余的潜在节点特定偏差。目标是找到一个对角缩放矩阵 $\\operatorname{diag}(x)$，使得得到的平衡矩阵 $B = \\operatorname{diag}(x) \\, W \\, \\operatorname{diag}(x)$ 的行（和列）和对于所有非全零的行/列都等于 $1$。问题指定了以下不动点迭代来找到缩放向量 $x \\in \\mathbb{R}_{\\ge 0}^n$：\n$$\nx_i^{(t+1)} = \\begin{cases}\n\\displaystyle \\frac{1}{\\sum_{j=1}^n W_{ij} x_j^{(t)}} & \\text{如果 } \\sum_{j=1}^n W_{ij} > 0, \\\\[1.25em]\n0 & \\text{其他情况}\n\\end{cases}\n$$\n对于所有非零行 $i$（其中 $\\sum_j W_{ij} > 0$），迭代以 $x_i^{(0)} = 1$ 初始化，对于零行则以 $x_i^{(0)} = 0$ 初始化。该过程持续进行，直到向量 $x$ 的最大绝对变化 $\\max_i |x_i^{(t+1)} - x_i^{(t)}|$ 小于指定的容差 $10^{-9}$，或完成最大 $10^4$ 次迭代。\n\n对于测试用例 A 和 B，连通分量的矩阵 $W$ 是不可约的，并且迭代过程预计会收敛，产生一个平衡矩阵，其非零行的行和等于 $1$。对于测试用例 C，由于矩阵 $C$ 中的计数是均匀的，回归正确地识别出偏差与协变量无关，从而产生一个秩为 1 的矩阵 $W$。规定的迭代方案会振荡，并且不会收敛到行和为 $1$ 的解。它会在达到最大迭代次数（$10^4$）时终止。我们严格遵循指令，使用此次最终迭代时的 $x$ 值。\n\n最后，对于每个测试用例，计算平衡矩阵 $B$，并计算其行和 $r_i = \\sum_{j=1}^n B_{ij}$，并报告至 6 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the file co-access matrix normalization problem for the given test cases.\n    \"\"\"\n\n    def normalize_matrix(C, s, a, tol=1e-9, max_iter=10000):\n        \"\"\"\n        Implements the complete 3-step normalization pipeline.\n        \n        Args:\n            C (np.ndarray): The symmetric co-access count matrix.\n            s (np.ndarray): The vector of file sizes.\n            a (np.ndarray): The vector of file ages.\n            tol (float): Convergence tolerance for the balancing step.\n            max_iter (int): Maximum number of iterations for the balancing step.\n\n        Returns:\n            np.ndarray: The vector of row sums of the final balanced matrix B.\n        \"\"\"\n        n = C.shape[0]\n\n        # Step 1: Estimate covariate dependence via linear regression\n        m = C.sum(axis=1)\n        valid_indices = np.where(m > 0)[0]\n        \n        # We need at least as many data points as parameters for a determined or over-determined system.\n        # The number of parameters is 3 (gamma_0, gamma_1, gamma_2).\n        if len(valid_indices) < 3:\n            # This case is not in the test suite but is a potential issue.\n            # A simple assumption might be no bias, but we follow the spec.\n            # `lstsq` will handle this by finding a least-norm solution.\n            pass\n\n        log_s_valid = np.log(s[valid_indices])\n        a_valid = a[valid_indices]\n        log_m_valid = np.log(m[valid_indices])\n\n        # Design matrix X for regression: [1, log(s_i), a_i]\n        X = np.vstack([np.ones(len(valid_indices)), log_s_valid, a_valid]).T\n        \n        # Solve for gamma = [gamma_0, gamma_1, gamma_2]\n        gamma, _, _, _ = np.linalg.lstsq(X, log_m_valid, rcond=None)\n        \n        # Compute bias estimates for all files\n        log_b_hat = gamma[0] + gamma[1] * np.log(s) + gamma[2] * a\n        b_hat = np.exp(log_b_hat)\n\n        # Step 2: Form the covariate-weighted matrix W\n        # Using np.outer for efficient calculation of the denominator\n        W = C / np.outer(b_hat, b_hat)\n\n        # Step 3: Apply symmetric iterative proportional fitting (balancing)\n        is_nonzero_row = W.sum(axis=1) > 0\n        x = is_nonzero_row.astype(float)\n        \n        for _ in range(max_iter):\n            x_old = x.copy()\n            \n            # Compute v = W @ x\n            v = W @ x_old\n            \n            # Update x for non-zero rows. \n            # For irreducible non-negative matrices W and positive x, v will be positive.\n            # No special handling for v[i]=0 needed for the given test cases.\n            x[is_nonzero_row] = 1.0 / v[is_nonzero_row]\n\n            # Check for convergence\n            if np.max(np.abs(x - x_old)) < tol:\n                break\n        \n        # Compute the final balanced matrix B and its row sums\n        B = np.diag(x) @ W @ np.diag(x)\n        row_sums = B.sum(axis=1)\n        \n        return row_sums\n\n    # Test cases from the problem statement\n    test_cases = [\n        {\n            \"C\": np.array([\n                [100, 10, 5, 0],\n                [10, 80, 20, 5],\n                [5, 20, 60, 15],\n                [0, 5, 15, 40]\n            ], dtype=float),\n            \"s\": np.array([1000, 500, 200, 100], dtype=float),\n            \"a\": np.array([5, 2, 1, 0.5], dtype=float)\n        },\n        {\n            \"C\": np.array([\n                [30, 5, 0, 0, 0],\n                [5, 25, 5, 0, 0],\n                [0, 5, 20, 10, 0],\n                [0, 0, 10, 15, 0],\n                [0, 0, 0, 0, 0]\n            ], dtype=float),\n            \"s\": np.array([300, 200, 150, 100, 50], dtype=float),\n            \"a\": np.array([1, 2, 3, 4, 5], dtype=float)\n        },\n        {\n            \"C\": np.array([\n                [10, 10, 10],\n                [10, 10, 10],\n                [10, 10, 10]\n            ], dtype=float),\n            \"s\": np.array([1e6, 1e3, 10], dtype=float),\n            \"a\": np.array([10, 5, 1], dtype=float)\n        }\n    ]\n\n    results_formatted = []\n    for case in test_cases:\n        row_sums = normalize_matrix(case[\"C\"], case[\"s\"], case[\"a\"])\n        # Format each row sum to 6 decimal places and join into a string representation of a list\n        formatted_sums = f\"[{','.join([f'{rs:.6f}' for rs in row_sums])}]\"\n        results_formatted.append(formatted_sums)\n\n    # Print the final output in the exact required format\n    print(f\"[{','.join(results_formatted)}]\")\n\nsolve()\n```", "id": "2397168"}]}