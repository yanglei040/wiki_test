{"hands_on_practices": [{"introduction": "在物种形成之后，基因家族的进化并非一成不变，差异性基因丢失是一个常见现象。当一个祖先基因在物种形成前发生重复时，会产生两对直系同源基因。然而，如果新形成的两个物种各自丢失了这对基因中的不同成员，就会导致一种误导性的“一对一”关系，使得本质上的旁系同源基因被误判为直系同源基因。这个思想实验 ([@problem_id:2405912]) 将帮助你通过计算这一现象发生所需的最少基因丢失事件数，来加深对基因谱系和进化历史重要性的理解。", "problem": "两个姐妹谱系，物种$A$和物种$B$，在一次物种形成事件中从一个共同祖先分化而来。在这个物种形成之前，共同祖先中的一个祖先基因$G$复制了一次，产生了两个不同的旁系同源拷贝$G_{1}$和$G_{2}$。物种形成之后，基因丢失事件可能会在每个谱系中独立发生。根据定义，直系同源基因是不同物种中因物种形成事件而分化的基因，而旁系同源基因是因复制事件而相关的基因。一个简陋的直系同源推断程序，当且仅当在物种$A$中恰好有一个可检测的拷贝，并且在物种$B$中恰好有一个可检测的拷贝（一对一关系）时，才会将一对基因标记为直系同源。\n\n假设所有复制都发生在物种形成之前，并且在物种形成之后没有发生进一步的复制。从祖先的基因复制和随后的物种形成开始，两个姐妹谱系中总共需要发生多少次独立的物种形成后基因丢失事件（最小总数$k$），才能使得目前在物种$A$中恰好有一个可检测的拷贝，在物种$B$中也恰好有一个可检测的拷贝，但这两个现存的拷贝不是直系同源基因，而是会被简陋程序错误地标记为一对一直系同源基因的旁系同源基因？\n\n请以整数形式给出答案。无需四舍五入。", "solution": "该问题要求分析基因谱系的进化，特别是在基因复制事件和随后的物种形成事件之后，涉及直系同源和旁系同源的概念。我们必须确定，为了给一个简陋的直系同源检测方法制造一个特定的误导性场景，所需的最少物种形成后基因丢失事件数量。\n\n让我们首先形式化地描述给定事件发生后基因家族的状态。\n\n$1$. **祖先状态**：在物种形成之前，共同祖先中的一个基因$G$发生复制，产生两个旁系同源基因拷贝，我们将其表示为$G_{1}$和$G_{2}$。根据定义，$G_{1}$和$G_{2}$是旁系同源基因。因此，共同祖先的基因组包含$\\{G_{1}, G_{2}\\}$。\n\n$2$. **物种形成事件**：共同祖先分裂成两个新的谱系，这两个谱系将演化为物种$A$和物种$B$。在物种形成的那一刻，祖先的全部基因组内容，包括两个旁系同源基因，都被每个新生谱系所继承。\n\n$3$. **物种形成后状态（初始）**：在物种形成事件之后，但在任何基因丢失之前，基因内容如下：\n- 导致物种$A$的谱系包含两个基因，我们将其标记为$G_{1A}$和$G_{2A}$。\n- 导致物种$B$的谱系包含两个基因，我们将其标记为$G_{1B}$和$G_{2B}$。\n\n$G_{1A}$是祖先基因$G_1$在物种$A$中的后代，依此类推。\n\n$4$. **基因关系**：根据直系同源和旁系同源的标准定义：\n- **直系同源基因**（Orthologs）是不同物种中通过物种形成事件从一个共同祖先基因演化而来的基因。因此，直系同源对是$(G_{1A}, G_{1B})$和$(G_{2A}, G_{2B})$。\n- **旁系同源基因**（Paralogs）是因复制事件而相关的基因。\n  - 复制发生在共同祖先中，物种形成之前。因此，$G_1$和$G_2$是旁系同源基因。它们的所有后代都继承了这种旁系同源关系。\n  - 在物种$A$内部，$(G_{1A}, G_{2A})$这对基因是旁系同源的。\n  - 在物种$B$内部，$(G_{1B}, G_{2B})$这对基因是旁系同源的。\n  - 跨物种来看，$(G_{1A}, G_{2B})$和$(G_{2A}, G_{1B})$这两对基因也是旁系同源的。它们被特别称为“远源旁系同源基因”（out-paralogs），因为它们的复制事件早于将它们所在物种分开的物种形成事件。\n\n问题描述了一个简陋的直系同源推断程序，该程序当且仅当在物种$A$中有一个拷贝且在物种$B$中有一个拷贝时，才将一对基因分类为直系同源。我们的任务是找到物种形成后最少的基因丢失事件数$k$，使得系统达到以下状态：\na) 物种$A$中恰好有一个基因拷贝。\nb) 物种$B$中恰好有一个基因拷贝。\nc) 这对基因是旁系同源基因，而不是直系同源基因。\n\n这种具有一对一基因数量的配置，会被简陋程序错误地标记为一对“直系同源基因”。\n\n让我们分析所需的基因丢失次数。初始状态下，两个物种总共包含四个基因：物种$A$中有$\\{G_{1A}, G_{2A}\\}$，物种$B$中有$\\{G_{1B}, G_{2B}\\}$。目标状态是每个物种中必须只有一个基因。\n\n为了满足剩下的两个基因是旁系同源基因的条件，最终的基因对必须是$(G_{1A}, G_{2B})$或$(G_{2A}, G_{1B})$。\n\n让我们考虑第一种情况：最终的基因对是$(G_{1A}, G_{2B})$。\n- 为了使物种$A$中只剩下$G_{1A}$，基因$G_{2A}$必须丢失。这构成**一次**基因丢失事件。\n- 为了使物种$B$中只剩下$G_{2B}$，基因$G_{1B}$必须丢失。这构成**第二次**基因丢失事件。\n这种情况所需的独立基因丢失事件总数为$1 + 1 = 2$。\n\n现在，让我们考虑第二种情况：最终的基因对是$(G_{2A}, G_{1B})$。\n- 为了使物种$A$中只剩下$G_{2A}$，基因$G_{1A}$必须丢失。这是**一次**基因丢失事件。\n- 为了使物种$B$中只剩下$G_{1B}$，基因$G_{2B}$必须丢失。这是**第二次**基因丢失事件。\n这种情况所需的独立基因丢失事件总数也是$1 + 1 = 2$。\n\n在满足问题所有条件的两种情景中，都需要恰好两次基因丢失事件。我们现在必须验证是否可以用少于2次事件达到这种状态。\n\n- **$k=0$次丢失的情况**：物种$A$有$\\{G_{1A}, G_{2A}\\}$，物种$B$有$\\{G_{1B}, G_{2B}\\}$。这是一个二对二的关系，违反了每个物种中只有一个基因的条件。\n\n- **$k=1$次丢失的情况**：假设只有一个基因丢失。例如，假设$G_{1A}$丢失了。\n  - 物种$A$现在有$\\{G_{2A}\\}$（一个拷贝）。\n  - 物种$B$仍然有$\\{G_{1B}, G_{2B}\\}$（两个拷贝）。\n  这导致了一对二的关系，违反了物种$B$中只有一个基因的条件。对于任何其他单个基因的丢失事件，结果都是类似的。因此，一次丢失事件是不够的。\n\n由于期望的配置无法通过0次或1次丢失事件实现，而我们已经证明它可以通过2次丢失事件实现，因此基因丢失事件的最小总数是2。这种在物种形成后，旁系同源基因的差异性丢失导致旁系同源基因之间形成一对一关系的现象，是“隐藏的旁系同源性”的一个经典例子，它会迷惑简单的直系同源检测方法。", "answer": "$$\\boxed{2}$$", "id": "2405912"}, {"introduction": "仅仅依靠序列相似性来推断直系同源关系可能并不可靠，因为基因的演化速率并非恒定。在某些情况下，一个基因（如 $G_A$）与其真正的直系同源基因（$G\\alpha_B$）之间的序列差异，可能大于其与一个旁系同源基因（$G\\beta_B$）的差异。这个练习 ([@problem_id:2405969]) 提供了一个具体的案例研究，在其中，广泛使用的相互最佳匹配（Reciprocal Best Hit, RBH）方法因不对称演化而失效，而基于保守基因邻接关系（即基因组共线性）的分析却能得出正确的结论。", "problem": "两个物种，表示为 $S_A$ 和 $S_B$，各自含有一个古老酶基因的同源基因。在 $S_A$ 和 $S_B$ 的共同祖先中，这个酶基因发生复制，产生了两个拷贝，我们将其表示为 $G\\alpha$ 和 $G\\beta$。在随后产生 $S_A$ 和 $S_B$ 的物种形成事件之后，物种 $S_A$ 丢失了拷贝 $G\\beta$，而物种 $S_B$ 则保留了 $G\\alpha$ 和 $G\\beta$。因此，现今 $S_A$ 有一个酶基因 $G_A$，$S_B$ 有两个酶基因 $G\\alpha_B$ 和 $G\\beta_B$。\n\n这两个物种中的局部基因邻域如下：\n- 在 $S_A$ 中，一条染色体上三个相邻基因的顺序是 $X_A$ — $G_A$ — $Y_A$。\n- 在 $S_B$ 中，有两个包含 $G\\alpha_B$ 和 $G\\beta_B$ 的基因座：\n  - 基因座 $1$：$X_B$ — $G\\alpha_B$ — $Y_B$\n  - 基因座 $2$：$U_B$ — $G\\beta_B$ — $V_B$\n\n使用基本局部比对搜索工具 (BLAST) 在 $S_A$ 和 $S_B$ 的全蛋白质组中进行了成对蛋白质序列相似性搜索。与这些基因相关的最佳比对结果如下：\n- $G_A$ 与 $G\\beta_B$：在 $900$ 个比对位置上有 $93\\%$ 的氨基酸一致性，E值为 $1\\times 10^{-150}$。\n- $G_A$ 与 $G\\alpha_B$：在 $900$ 个比对位置上有 $85\\%$ 的氨基酸一致性，E值为 $1\\times 10^{-120}$。\n- 当用 $G\\beta_B$ 对 $S_A$ 进行查询时，其最佳匹配是 $G_A$（即上述比对）。当用 $G\\alpha_B$ 对 $S_A$ 进行查询时，其最佳匹配也是 $G_A$，一致性为 $85\\%$，如上所示。\n\n对于侧翼基因，$S_A$ 和 $S_B$ 之间的最佳匹配如下：\n- $X_A$ 与 $X_B$：$88\\%$ 一致性，高度显著；$X_A$ 与 $G\\beta_B$ 附近的基因之间没有显著相似性。\n- $Y_A$ 与 $Y_B$：$90\\%$ 一致性，高度显著；$Y_A$ 与 $G\\beta_B$ 附近的基因之间没有显著相似性。\n\n假设直系同源基因 (orthologs) 定义为最近的分化事件是物种形成的同源基因，而旁系同源基因 (paralogs) 定义为最近的分化事件是基因复制的同源基因。相互最佳匹配 (RBH) 在此定义为来自 $S_A$ 和 $S_B$ 的一对基因，它们在对方各自的蛋白质组中互为唯一的最高分 BLAST 匹配。基于基因共线性 (synteny) 的推断依赖于局部基因顺序和内容的保守性，以推断跨越物种形成事件的共同祖先关系。\n\n仅根据所提供的信息和这些定义，哪个选项最能确定 $G_A$ 与 $S_B$ 中基因拷贝之间的直系同源关系，并解释为何在这种情况下，相互最佳匹配方法会失败，而基于基因共线性的方法会成功？\n\nA. $G\\alpha_B$ 是 $G_A$ 的唯一一个直系同源基因；基因复制发生在物种形成之前，因此 $G\\beta_B$ 是一个远源旁系同源基因 (out-paralog)。尽管其序列一致性较低，$G\\alpha_B$ 位于 $X_B$ 和 $Y_B$ 之间，而它们的直系同源基因 $X_A$ 和 $Y_A$ 位于 $G_A$ 的两侧，这表明了保守的基因共线性以及跨物种形成的共同祖先关系。$G_A$ 和 $G\\beta_B$ 之间的相互最佳匹配因 $G\\beta_B$ 较近期的序列同质化而具有误导性。\n\nB. $G\\beta_B$ 是 $G_A$ 的唯一一个直系同源基因；相互最佳匹配和更高的序列一致性明确地确立了直系同源关系，使得基因共线性无关紧要。\n\nC. $G\\alpha_B$ 和 $G\\beta_B$ 都不是 $G_A$ 的直系同源基因；$G_A$ 在 $S_B$ 中没有直系同源基因，因为基因复制和随后的丢失切断了直系同源关系。\n\nD. $G\\alpha_B$ 和 $G\\beta_B$ 都是 $G_A$ 的直系同源基因（共直系同源基因 co-orthologs），因为基因复制发生在 $S_A$ 和 $S_B$ 的物种形成之后，所以序列和基因共线性无法将它们区分开来。", "solution": "首先将对问题陈述进行严格验证。\n\n**步骤1：提取已知条件**\n\n1.  **物种和基因**：\n    -   两个物种：`$S_A$` 和 `$S_B$`。\n    -   共同祖先拥有一个酶基因。\n    -   共同祖先中的基因复制产生了两个旁系同源拷贝：`$G\\alpha$` 和 `$G\\beta$`。\n    -   随后的物种形成产生了通往 `$S_A$` 和 `$S_B$` 的谱系。\n    -   物种形成后，`$S_A$` 丢失了拷贝 `$G\\beta$`。`$S_B$` 保留了 `$G\\alpha$` 和 `$G\\beta$`。\n    -   现今基因：`$S_A$` 拥有 `$G_A$`；`$S_B$` 拥有 `$G\\alpha_B$` 和 `$G\\beta_B$`。\n\n2.  **基因邻域 (基因共线性)**：\n    -   在 `$S_A$` 中：`$X_A$ — $G_A$ — $Y_A$`。\n    -   在 `$S_B$` 中，基因座 1：`$X_B$ — $G\\alpha_B$ — $Y_B$`。\n    -   在 `$S_B$` 中，基因座 2：`$U_B$ — $G\\beta_B$ — $V_B$`。\n\n3.  **BLAST 序列相似性**：\n    -   `$G_A$` 与 `$G\\beta_B$`：在 `$900$` 个比对位置上有 `$93\\%$` 的氨基酸一致性，E值为 `$1\\times 10^{-150}$`。\n    -   `$G_A$` 与 `$G\\alpha_B$`：在 `$900$` 个比对位置上有 `$85\\%$` 的氨基酸一致性，E值为 `$1\\times 10^{-120}$`。\n    -   当用 `$G\\beta_B$` 对 `$S_A$` 进行查询时，其最佳匹配是 `$G_A$`。\n    -   当用 `$G\\alpha_B$` 对 `$S_A$` 进行查询时，其最佳匹配是 `$G_A$`。\n\n4.  **侧翼基因相似性**：\n    -   `$X_A$` 与 `$X_B$`：`$88\\%$` 一致性，高度显著。\n    -   `$Y_A$` 与 `$Y_B$`：`$90\\%$` 一致性，高度显著。\n    -   `$X_A$` 或 `$Y_A$` 与 `$G\\beta_B$` 附近的基因之间无显著相似性。\n\n5.  **定义**：\n    -   **直系同源基因 (Orthologs)**：最近的分化事件是物种形成的同源基因。\n    -   **旁系同源基因 (Paralogs)**：最近的分化事件是基因复制的同源基因。\n    -   **相互最佳匹配 (RBH)**：来自 `$S_A$` 和 `$S_B$` 的一对基因，它们互为对方的唯一最高分 BLAST 匹配。\n    -   **基于基因共线性的推断**：依赖于局部基因顺序的保守性。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学上成立**：该情景描述了基因复制、物种形成和差异性基因丢失，这些是分子进化中的基本过程。所描述的方法——用于序列相似性比较的 BLAST、相互最佳匹配和基因共线性分析——是计算生物学中推断同源关系的标准化、已确立的技术。所提供的数据（一致性、E值）是合理的。该问题牢固地建立在科学原理之上。\n-   **定义明确**：该问题提供了清晰的进化历史和足够的数据（序列相似性、基因共线性）来推断基因之间的关系。然后，它要求根据这一已知的历史来评估不同的推断方法。可以从这些前提中得出一个唯一的、有意义的解。\n-   **客观性**：问题陈述是用定量数据和形式化定义来呈现的。它没有主观或模糊的语言。\n-   **一致性和完整性**：问题陈述是内部一致的。所描述的进化历史是一个经典的案例研究，用于说明直系同源基因分配的复杂性。所有必要的定义和数据都已提供。\n\n**步骤3：结论和行动**\n\n问题陈述在科学上是合理的、定义明确的、客观的并且是自洽的。这是计算生物学中的一个有效问题。我将继续进行解答。\n\n**解题推导**\n\n问题的核心是根据提供的进化历史确定正确的进化关系，然后评估两种常见的生物信息学方法——相互最佳匹配 (RBH) 和基因共线性分析——在这种情景下的表现。\n\n1.  **进化历史和关系的重建**：\n    让我们将所描述的进化历史形式化。\n    -   **事件1 (复制)**：在 `$S_A$` 和 `$S_B$` 的共同祖先中，一个基因 `$G_{anc}$` 发生复制，产生了 `$G\\alpha$` 和 `$G\\beta$`。根据定义，`$G\\alpha$` 和 `$G\\beta$` 是旁系同源基因。这次复制发生在物种形成之前。相对于随后的物种形成事件，通过此类复制产生的相关基因被称为“远源旁系同源基因”(out-paralogs)。\n    -   **事件2 (物种形成)**：祖先物种分裂成两个谱系，一个通向 `$S_A$`，另一个通向 `$S_B$`。两个谱系都继承了 `$G\\alpha$` 和 `$G\\beta$` 这两个基因拷贝。`$S_A$` 的祖先拥有 `$G\\alpha_{ancA}$` 和 `$G\\beta_{ancA}$`。`$S_B$` 的祖先拥有 `$G\\alpha_{ancB}$` 和 `$G\\beta_{ancB}$`。`$G\\alpha_{ancA}$` 和 `$G\\alpha_{ancB}$` 之间的分化是物种形成事件，这使它们成为直系同源基因。同样地，`$G\\beta_{ancA}$` 和 `$G\\beta_{ancB}$` 是直系同源基因。\n    -   **事件3 (基因丢失)**：通向 `$S_A$` 的谱系丢失了其 `$G\\beta_{ancA}$` 拷贝。通向 `$S_B$` 的谱系保留了两个拷贝。\n    -   **现今**：`$G\\alpha_{ancA}$` 在物种 `$S_A$` 中演变成了 `$G_A$`。`$G\\alpha_{ancB}$` 在物种 `$S_B$` 中演变成了 `$G\\alpha_B$`。`$G\\beta_{ancB}$` 在物种 `$S_B$` 中演变成了 `$G\\beta_B$`。\n\n    基于这个因果链，我们确定正确的关系：\n    -   `$G_A$` 和 `$G\\alpha_B$` 之间的分化可以追溯到物种形成事件。因此，**`$G_A$` 和 `$G\\alpha_B$` 是直系同源基因。**\n    -   `$G_A$` (源自 `$G\\alpha$`) 和 `$G\\beta_B$` (源自 `$G\\beta$`) 之间的分化可以追溯到共同祖先中的基因复制事件。因此，**`$G_A$` 和 `$G\\beta_B$` 是旁系同源基因（具体来说是远源旁系同源基因）。**\n\n2.  **推断方法的分析**：\n    -   **相互最佳匹配 (RBH) 方法**：\n        - 用 `$G_A$` 对 `$S_B$` 的蛋白质组进行 BLAST 搜索，会比较 `$G\\alpha_B$` 和 `$G\\beta_B$` 的比对得分。根据给定的数据，`$G_A$` vs `$G\\beta_B$` 显示 `$93\\%$` 的一致性和 E值 `$1\\times 10^{-150}$`，而 `$G_A$` vs `$G\\alpha_B$` 显示 `$85\\%$` 的一致性和 E值 `$1\\times 10^{-120}$`。与 `$G\\beta_B$` 的比对显著更优。因此，`$G_A$` 在 `$S_B$` 中的最佳匹配是 `$G\\beta_B$`。\n        - 问题陈述指出，`$G\\beta_B$` 在 `$S_A$` 中的最佳匹配是 `$G_A$`。\n        - 由于它们互为最佳匹配，`$G_A$` 和 `$G\\beta_B$` 构成一个相互最佳匹配对。因此，RBH 方法会错误地将旁系同源基因 `$G_A$` 和 `$G\\beta_B$` 识别为直系同源基因。\n        - **结论**：RBH 方法在这种情景下会失败。这是 RBH 的一个已知陷阱，当物种形成后出现不对称序列分化时会发生，即一个旁系同源基因与另一物种中某个基因保留了比其真正直系同源基因更高的序列相似性。\n\n    -   **基于基因共线性的方法**：\n        - 基因共线性指的是染色体上基因顺序的保守性。\n        - `$S_A$` 中的基因邻域是 `$X_A$ — $G_A$ — $Y_A$`。\n        - 在 `$S_B$` 中，基因 `$G\\alpha_B$` 位于邻域 `$X_B$ — $G\\alpha_B$ — $Y_B$` 中。\n        - 问题陈述指出 `$X_A$` 和 `$X_B$` 高度相似，`$Y_A$` 和 `$Y_B$` 也是如此。这表明整个基因组位点 `$X-G-Y$` 在 `$S_A$` 和 `$S_B$` 中含有 `$G\\alpha_B$` 的基因座之间是保守的。这样一个保守的基因块是强有力的证据，表明这两个区域是直系同源的，即它们源于共同祖先的同一区域。\n        - 相反，在 `$S_A$` 中的 `$G_A$` 基因座和 `$S_B$` 中的 `$G\\beta_B$` 基因座（`$U_B$ — $G\\beta_B$ — $V_B$`）之间没有保守的基因共线性。\n        - 因此，基因共线性分析正确地推断出，位于直系同源基因组环境中的 `$G_A$` 和 `$G\\alpha_B$` 是真正的直系同源基因。\n        - **结论**：基于基因共线性的方法成功了。\n\n**逐项分析**\n\n-   **A. `$G\\alpha_B$ 是 $G_A$ 的唯一一个直系同源基因；基因复制发生在物种形成之前，因此 $G\\beta_B$ 是一个远源旁系同源基因 (out-paralog)。尽管其序列一致性较低，$G\\alpha_B$ 位于 $X_B$ 和 $Y_B$ 之间，而它们的直系同源基因 $X_A$ 和 $Y_A$ 位于 $G_A$ 的两侧，这表明了保守的基因共线性以及跨物种形成的共同祖先关系。$G_A$ 和 $G\\beta_B$ 之间的相互最佳匹配因 $G\\beta_B$ 较近期的序列同质化而具有误导性。`**\n    -   该选项基于对进化历史（复制先于物种形成）的正确理解，正确地将 `$G\\alpha_B$` 识别为直系同源基因，将 `$G\\beta_B$` 识别为远源旁系同源基因。\n    -   它正确地使用基因共线性数据（`$X_A$/$X_B$`, `$Y_A$/$Y_B$`）来支持其直系同源关系的主张。\n    -   它正确地指出了 RBH 方法具有误导性。给出的原因（“同质化”）是不对称分化速率的一个可能原因（尽管没有明确证明），但总体陈述是对所呈现事实最准确和最完整的描述。\n    -   **结论：正确。**\n\n-   **B. `$G\\beta_B$ 是 $G_A$ 的唯一一个直系同源基因；相互最佳匹配和更高的序列一致性明确地确立了直系同源关系，使得基因共线性无关紧要。`**\n    -   该选项错误地将 `$G\\beta_B$` 识别为直系同源基因。根据推导，它是一个旁系同源基因。\n    -   它错误地声称 RBH 和序列一致性是“决定性的”。它们是启发式方法，在这个定义明确的案例中显然是失败的。\n    -   它错误地排除了基因共线性，而后者是正确分配关系的关键证据。\n    -   **结论：错误。**\n\n-   **C. `$G\\alpha_B$ 和 $G\\beta_B$ 都不是 $G_A$ 的直系同源基因；$G_A$ 在 $S_B$ 中没有直系同源基因，因为基因复制和随后的丢失切断了直系同源关系。`**\n    -   这个陈述从根本上误解了直系同源的定义。`$G_A$` 和 `$G\\alpha_B$` 之间的关系是直系同源的，因为它们的最后一个共同祖先基因存在于物种形成事件之前。一个谱系中的基因丢失并不会消除幸存基因之间的直系同源关系。\n    -   **结论：错误。**\n\n-   **D. `$G\\alpha_B$ 和 $G\\beta_B$ 都是 $G_A$ 的直系同源基因（共直系同源基因 co-orthologs），因为基因复制发生在 $S_A$ 和 $S_B$ 的物种形成之后，所以序列和基因共线性无法将它们区分开来。`**\n    -   该选项的前提，即复制发生在物种形成*之后*，直接与问题陈述相矛盾：“在 `$S_A$` 和 `$S_B$` 的共同祖先中，这个酶基因发生了复制”。如果这个前提为真，那么关于共直系同源的结论就是正确的，但由于前提是错误的，所以该选项无效。\n    -   **结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "2405969"}, {"introduction": "现代生物信息学方法通常超越了单一标准的“是”或“否”判断，而是通过整合多种独立的证据来更稳健地推断直系同源关系。这种综合方法能够有效克服单一证据来源（如序列相似性）的局限性。本练习 ([@problem_id:2405931]) 将指导你如何将序列相似性、基因组共线性以及功能关联性数据（如基因共表达）结合起来，通过计算一个加权调和平均数，最终得到一个量化的“直系同源置信度分数”。", "problem": "给定两个物种之间的一组候选基因对。对于每一对，提供了三种独立的证据类型：归一化的序列相似性得分 $s \\in [0,1]$，代表保守邻居比例的归一化同线性保守性得分 $y \\in [0,1]$，以及在匹配条件下测量的作为 Pearson 相关系数 (PCC) 的共表达相关性 $r \\in [-1,1]$。通过线性映射 $c = \\dfrac{r + 1}{2}$ 定义一个非负的相关性衍生证据 $c$，使得 $c \\in [0,1]$ 且 $c$ 随 $r$ 单调递增。使用固定的、总和为 $1$ 的非负权重 $w_s$、$w_y$、$w_c$，为每个候选对定义一个加权证据整合得分（直系同源置信度得分）$S$ 如下：\n1. 如果 $s = 0$ 或 $y = 0$ 或 $c = 0$，则 $S = 0$。\n2. 否则，\n$$\nS \\;=\\; \\dfrac{w_s + w_y + w_c}{\\dfrac{w_s}{s} + \\dfrac{w_y}{y} + \\dfrac{w_c}{c}}.\n$$\n使用权重 $w_s = 0.5$，$w_y = 0.3$ 和 $w_c = 0.2$。您的任务是为以下每个测试用例计算 $S$，其中每个用例是一个三元组 $(s,y,r)$：\n- 用例 $1$：$(0.9, 0.7, 0.6)$\n- 用例 $2$：$(1.0, 1.0, 1.0)$\n- 用例 $3$：$(0.0, 1.0, 1.0)$\n- 用例 $4$：$(1.0, 0.0, 0.2)$\n- 用例 $5$：$(0.5, 0.5, 0.0)$\n- 用例 $6$：$(0.8, 0.2, -1.0)$\n- 用例 $7$：$(0.95, 0.85, -0.2)$\n您的程序必须输出一行，其中包含按上述用例顺序排列的 $7$ 个 $S$ 值列表，四舍五入到小数点后恰好 $6$ 位。要求的格式是单行，用方括号括起来的逗号分隔列表，例如 $[x_1,x_2,\\dots,x_7]$，其中每个 $x_i$ 是用例 $i$ 的 $S$ 值的四舍五入结果。", "solution": "该问题已经过严格验证，并被证实是有效的。它具有科学依据，定义明确且客观。它在计算生物学和生物信息学领域内提出了一个清晰、可形式化的任务。所有必要的参数和定义都已提供，不存在矛盾或歧义。\n\n该问题要求计算一个加权证据整合得分 $S$，用于识别直系同源基因对。该得分基于三个独立的证据来源：序列相似性 $s$、同线性保守性 $y$ 和共表达相关性 $r$。\n\n首先，通过线性映射将共表达相关性 $r \\in [-1, 1]$ 转换为一个非负得分 $c \\in [0, 1]$：\n$$\nc = \\dfrac{r + 1}{2}\n$$\n这种转换确保了所有三个证据得分 $s$、$y$ 和 $c$ 都在相同的 $[0, 1]$ 范围内，并随着证据强度的增加而单调递增。\n\n置信度得分 $S$ 被定义为这三个得分的加权调和平均值。给定的权重为 $w_s = 0.5$，$w_y = 0.3$ 和 $w_c = 0.2$。请注意，权重是非负的，并且总和为 $1$：$w_s + w_y + w_c = 0.5 + 0.3 + 0.2 = 1.0$。\n\n$S$ 的计算遵循一个两部分的规则：\n1.  一个严格的否决条件：如果任何一个证据得分为零，则组合得分也为零。也就是说，如果 $s = 0$ 或 $y = 0$ 或 $c = 0$，则 $S = 0$。这反映了这样一个原则：任何一个关键来源完全缺乏证据就足以取消一个候选对的资格。\n2.  对于所有其他 $s > 0$，$y > 0$ 和 $c > 0$ 的情况，得分 $S$ 使用加权调和平均值的公式计算：\n    $$\n    S = \\dfrac{w_s + w_y + w_c}{\\dfrac{w_s}{s} + \\dfrac{w_y}{y} + \\dfrac{w_c}{c}}\n    $$\n    由于权重总和为 $1$，该表达式可简化为：\n    $$\n    S = \\left(\\dfrac{w_s}{s} + \\dfrac{w_y}{y} + \\dfrac{w_c}{c}\\right)^{-1}\n    $$\n    此处使用调和平均值是合适的，因为它对最小值很敏感，确保任何一个维度的低分都会严重惩罚整体置信度得分。\n\n我们现在继续为所提供的七个测试用例中的每一个计算 $S$。\n\n用例 1：$(s, y, r) = (0.9, 0.7, 0.6)$\n首先，计算 $c$：$c = \\dfrac{0.6 + 1}{2} = 0.8$。\n由于 $s, y, c$ 均不为零，我们应用调和平均值公式：\n$$\nS_1 = \\left(\\dfrac{0.5}{0.9} + \\dfrac{0.3}{0.7} + \\dfrac{0.2}{0.8}\\right)^{-1} = \\left(0.555555... + 0.428571... + 0.25\\right)^{-1} = \\left(1.23412698...\\right)^{-1} \\approx 0.81029255\n$$\n四舍五入到 $6$ 位小数，$S_1 = 0.810293$。\n\n用例 2：$(s, y, r) = (1.0, 1.0, 1.0)$\n计算 $c$：$c = \\dfrac{1.0 + 1}{2} = 1.0$。\n所有得分均为最大值。\n$$\nS_2 = \\left(\\dfrac{0.5}{1.0} + \\dfrac{0.3}{1.0} + \\dfrac{0.2}{1.0}\\right)^{-1} = \\left(0.5 + 0.3 + 0.2\\right)^{-1} = \\left(1.0\\right)^{-1} = 1.0\n$$\n四舍五入到 $6$ 位小数，$S_2 = 1.000000$。\n\n用例 3：$(s, y, r) = (0.0, 1.0, 1.0)$\n这里，$s = 0$。根据否决条件，得分立即被设为零。\n$$\nS_3 = 0\n$$\n四舍五入到 $6$ 位小数，$S_3 = 0.000000$。\n\n用例 4：$(s, y, r) = (1.0, 0.0, 0.2)$\n这里，$y = 0$。否决条件适用。\n$$\nS_4 = 0\n$$\n四舍五入到 $6$ 位小数，$S_4 = 0.000000$。\n\n用例 5：$(s, y, r) = (0.5, 0.5, 0.0)$\n计算 $c$：$c = \\dfrac{0.0 + 1}{2} = 0.5$。\n由于 $s, y, c$ 均不为零：\n$$\nS_5 = \\left(\\dfrac{0.5}{0.5} + \\dfrac{0.3}{0.5} + \\dfrac{0.2}{0.5}\\right)^{-1} = \\left(1.0 + 0.6 + 0.4\\right)^{-1} = \\left(2.0\\right)^{-1} = 0.5\n$$\n四舍五入到 $6$ 位小数，$S_5 = 0.500000$。\n\n用例 6：$(s, y, r) = (0.8, 0.2, -1.0)$\n计算 $c$：$c = \\dfrac{-1.0 + 1}{2} = 0.0$。\n这里，$c = 0$。否决条件适用。\n$$\nS_6 = 0\n$$\n四舍五入到 $6$ 位小数，$S_6 = 0.000000$。\n\n用例 7：$(s, y, r) = (0.95, 0.85, -0.2)$\n计算 $c$：$c = \\dfrac{-0.2 + 1}{2} = \\dfrac{0.8}{2} = 0.4$。\n由于 $s, y, c$ 均不为零：\n$$\nS_7 = \\left(\\dfrac{0.5}{0.95} + \\dfrac{0.3}{0.85} + \\dfrac{0.2}{0.4}\\right)^{-1} = \\left(0.5263157... + 0.3529411... + 0.5\\right)^{-1} = \\left(1.3792569...\\right)^{-1} \\approx 0.72502693\n$$\n四舍五入到 $6$ 位小数，$S_7 = 0.725027$。\n\n最终结果按要求编译成一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the weighted evidence integration score (S) for several candidate\n    gene pairs based on sequence similarity (s), synteny conservation (y),\n    and co-expression correlation (r).\n    \"\"\"\n\n    # Define the weights for the evidence scores.\n    # ws: weight for sequence similarity\n    # wy: weight for synteny conservation\n    # wc: weight for co-expression correlation\n    ws = 0.5\n    wy = 0.3\n    wc = 0.2\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (s, y, r).\n    test_cases = [\n        (0.9, 0.7, 0.6),   # Case 1\n        (1.0, 1.0, 1.0),   # Case 2\n        (0.0, 1.0, 1.0),   # Case 3\n        (1.0, 0.0, 0.2),   # Case 4\n        (0.5, 0.5, 0.0),   # Case 5\n        (0.8, 0.2, -1.0),  # Case 6\n        (0.95, 0.85, -0.2) # Case 7\n    ]\n\n    results = []\n    for case in test_cases:\n        s, y, r = case\n\n        # Transform the Pearson correlation r from [-1, 1] to a score c in [0, 1].\n        c = (r + 1.0) / 2.0\n\n        # Rule 1: If any evidence score is 0, the total score S is 0.\n        # This handles division-by-zero for the harmonic mean and enforces a\n        # strict veto on any candidate pair lacking one type of evidence.\n        if s == 0.0 or y == 0.0 or c == 0.0:\n            S = 0.0\n        else:\n            # Rule 2: Otherwise, calculate S as the weighted harmonic mean.\n            # Since the weights sum to 1, S = 1 / (ws/s + wy/y + wc/c).\n            weighted_inverse_sum = (ws / s) + (wy / y) + (wc / c)\n            S = 1.0 / weighted_inverse_sum\n        \n        # Format the result to exactly 6 decimal places.\n        results.append(f\"{S:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2405931"}]}