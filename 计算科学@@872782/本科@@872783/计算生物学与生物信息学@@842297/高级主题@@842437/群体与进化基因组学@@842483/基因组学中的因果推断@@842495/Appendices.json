{"hands_on_practices": [{"introduction": "在进行因果推断时，首要任务是识别并控制混杂因素。有向无环图（DAGs）为我们提供了一种严谨的图形化语言来描绘变量间的因果关系。本练习将引导你应用后门准则（backdoor criterion）和d-分离（d-separation）规则，在一个模拟的基因调控网络中，系统地找出所有能够消除混杂、从而准确估计因果效应的协变量组合。[@problem_id:2377421]", "problem": "在一项关于调控机制的基因组学研究中，请考虑以下由有向无环图（DAG）表示的因果系统。遗传变异 $Z_1$ 和 $Z_2$ 是作用于基因调控上游的单核苷酸多态性。变量 $X$ 表示转录因子的信使RNA表达量，$M$ 表示由 $X$ 调控的下游靶标模块的表达水平，$Y$ 表示在稳态下测量的细胞表型。该DAG的结构为：\n$$Z_1 \\rightarrow X \\rightarrow M \\rightarrow Y \\leftarrow Z_2 \\rightarrow X.$$\n假设所有变量 $\\{Z_1, Z_2, X, M, Y\\}$ 均为观测变量，并且您的目标是仅使用基于给定DAG中d-分离的协变量调整方法，从纯观测数据中识别 $X$ 对 $Y$ 的总因果效应。调整仅限于非 $X$ 后代的暴露前变量。\n\n使用上述DAG和d-分离，在调整集中不得包含 $X$ 的任何后代的限制下，确定从变量 $\\{Z_1, Z_2, M\\}$ 中可以抽取出多少个不同的协变量调整集，足以通过后门准则识别 $X$ 对 $Y$ 的总因果效应。\n\n请以单个整数形式提供您的答案。无需四舍五入。", "solution": "该问题要求根据一个给定的有向无环图（DAG）和一系列约束条件，识别出足以估计变量 $X$ 对变量 $Y$ 的总因果效应的不同协变量调整集的数量。我将首先验证问题陈述的有效性，如果问题被认为是有效的，我将进行严谨的推导。\n\n给定条件如下：\n- 一组五个观测变量：遗传变异 $Z_1$ 和 $Z_2$、转录因子表达量 $X$、靶标模块表达量 $M$ 以及表型 $Y$。\n- 一个由DAG表示的因果结构：$Z_1 \\rightarrow X \\rightarrow M \\rightarrow Y \\leftarrow Z_2 \\rightarrow X$。这个表示法指定了以下有向边：$Z_1 \\rightarrow X$、$X \\rightarrow M$、$M \\rightarrow Y$、$Z_2 \\rightarrow Y$ 和 $Z_2 \\rightarrow X$。\n- 目标是识别 $X$ 对 $Y$ 的总因果效应。\n- 方法是基于d-分离推导出的后门准则进行协变量调整。\n- 用于调整的潜在协变量集是 $\\{Z_1, Z_2, M\\}$。\n- 一个关键限制是调整集不能包含 $X$ 的任何后代。\n\n该问题在基因组学中的因果推断领域有科学依据，问题设定良好、客观且内部一致。没有违反科学原理或逻辑谬误。该问题是有效的。\n\n为了使用协变量调整来识别 $X$ 对 $Y$ 的总因果效应，我们必须找到所有满足后门准则的协变量集 $\\mathcal{S}$。对于一个有序变量对 $(X, Y)$，如果一个变量集 $\\mathcal{S}$ 满足后门准则，它必须符合两个条件：\n1. $\\mathcal{S}$ 中没有任何变量是 $X$ 的后代。\n2. $\\mathcal{S}$ 阻断了 $X$ 和 $Y$ 之间的每一条后门路径。后门路径是 $X$ 和 $Y$ 之间的一条非因果路径，其起始于一个指向 $X$ 的箭头。\n\n让我们系统地应用这些条件。\n\n首先，我们必须在给定的DAG中识别出 $X$ 的后代。从 $X$ 出发的有向路径是 $X \\rightarrow M$ 和 $X \\rightarrow M \\rightarrow Y$。因此，$X$ 的后代是变量 $\\{M, Y\\}$。问题明确禁止在调整集中包含 $X$ 的后代。可用的协变量集是 $\\{Z_1, Z_2, M\\}$。这个约束立即排除了 $M$ 成为任何有效调整集 $\\mathcal{S}$ 的一部分的可能性。因此，任何有效的调整集 $\\mathcal{S}$ 都必须是 $\\{Z_1, Z_2\\}$ 的一个子集。\n\n其次，我们必须识别出 $X$ 和 $Y$ 之间的所有后门路径。后门路径是以一条指向 $X$ 的边开始的路径。在给定的DAG中，指向 $X$ 的边是 $Z_1 \\rightarrow X$ 和 $Z_2 \\rightarrow X$。\n- 考虑以 $X \\leftarrow Z_1$ 开始的路径。要使其成为后门路径，必须存在一条从 $Z_1$ 到 $Y$ 且不经过 $X$ 的路径。检查DAG，不存在这样的路径。从 $Z_1$ 到任何其他变量的唯一路径都经过 $X$。因此，没有涉及 $Z_1$ 的后门路径。变量 $Z_1$ 充当的是 $X$ 对 $Y$ 效应的工具变量，而不是混杂因素。\n- 考虑以 $X \\leftarrow Z_2$ 开始的路径。要使其成为后门路径，必须存在一条从 $Z_2$ 到 $Y$ 且不经过 $X$ 的路径。DAG中包含了边 $Z_2 \\rightarrow Y$。因此，路径 $X \\leftarrow Z_2 \\rightarrow Y$ 存在。这是一个由共同原因 $Z_2$ 造成的后门路径，它混淆了 $X$ 和 $Y$ 之间的关系。这是图中唯一的后门路径。\n\n第三，调整集 $\\mathcal{S}$ 必须阻断这条后门路径 $X \\leftarrow Z_2 \\rightarrow Y$。这条路径是一个“分叉”结构，当且仅当中间变量 $Z_2$ 被包含在条件集 $\\mathcal{S}$ 中时，它才会被d-分离（阻断）。因此，任何有效的调整集都必须包含 $Z_2$。\n\n第四，我们必须确保对集合 $\\mathcal{S}$ 进行条件化不会打开任何先前被阻断的路径。新的路径可以通过对碰撞节点或其后代进行条件化而打开。DAG中的碰撞节点是 $X$（见于结构 $Z_1 \\rightarrow X \\leftarrow Z_2$）和 $Y$（见于 $M \\rightarrow Y \\leftarrow Z_2$）。我们潜在的条件变量是 $Z_1$ 和 $Z_2$。它们都不是碰撞节点，也不是碰撞节点的后代。因此，对 $\\{Z_1, Z_2\\}$ 的任何子集进行条件化都不会打开任何伪路径。\n\n综合我们的发现：\n1. 调整集 $\\mathcal{S}$ 必须是 $\\{Z_1, Z_2\\}$ 的一个子集。\n2. 调整集 $\\mathcal{S}$ 必须包含 $Z_2$。\n\n$\\{Z_1, Z_2\\}$ 的可能子集是 $\\emptyset$、$\\{Z_1\\}$、$\\{Z_2\\}$ 和 $\\{Z_1, Z_2\\}$。我们根据我们的标准逐一评估：\n- $\\mathcal{S} = \\emptyset$：无效。它不包含 $Z_2$。\n- $\\mathcal{S} = \\{Z_1\\}$：无效。它不包含 $Z_2$。\n- $\\mathcal{S} = \\{Z_2\\}$：有效。它包含 $Z_2$ 并且是 $\\{Z_1, Z_2\\}$ 的子集。它阻断了唯一的后门路径，并且没有打开新的路径。\n- $\\mathcal{S} = \\{Z_1, Z_2\\}$：有效。它包含 $Z_2$，因此阻断了后门路径。包含 $Z_1$ 对于满足后门准则而言是多余的，但并非不正确。该集合仍然满足后门准则的两个条件。\n\n因此，在给定的约束条件下，恰好有两个不同的协变量调整集足以识别 $X$ 对 $Y$ 的总因果效应。这些集合是 $\\{Z_2\\}$ 和 $\\{Z_1, Z_2\\}$。这样的集合数量是 $2$。", "answer": "$$ \\boxed{2} $$", "id": "2377421"}, {"introduction": "孟德尔随机化（MR）是一种利用遗传变异作为工具变量来推断暴露对结局因果效应的强大方法。然而，当工具变量通过连锁不平衡（LD）与影响结局的其他遗传位点相关时，就会产生一种称为水平多效性（horizontal pleiotropy）的偏倚。本练习通过一个量化模型，让你亲手计算和观察连锁不平衡如何扭曲孟德尔随机化分析的结果，从而加深对工具变量核心假设的理解。[@problem_id:2377409]", "problem": "考虑两个双等位基因单核苷酸多态性（SNP），记为 $G$ 和 $Z$，每个都经过加性编码，并标准化为均值 $0$ 和方差 $1$。设它们的相关性为带符号的连锁不平衡（LD）相关系数 $r \\in [-1,1]$，LD 度量为 $r^2 \\in [0,1]$。假设存在暴露 $E$ 和结局 $Y$，根据以下线性结构方程生成：\n$E = \\gamma G + \\xi$ 和 $Y = \\beta E + \\delta Z + \\varepsilon$，\n其中 $\\gamma, \\beta, \\delta \\in \\mathbb{R}$ 是固定常数，噪声项 $\\xi$ 和 $\\varepsilon$ 均值为零，且与 $(G,Z)$ 联合独立。假设 $Z$ 对 $E$ 没有因果效应，而 $G$ 除了通过 $E$ 之外，对 $Y$ 没有直接影响。考虑一项双样本孟德尔随机化（MR）研究（Mendelian randomization (MR)），其中，在一个样本中估计 $E$ 对 $G$ 的大样本边际关联，在另一个独立样本中估计 $Y$ 对 $G$ 的大样本边际关联。MR 估计量定义为这两个大样本边际关联的比值。\n\n通过 $r^2$ 和一个符号参数 $s \\in \\{-1,+1\\}$ 间接给出了带符号的 LD 相关性，其中 $r = s \\sqrt{r^2}$。对于每个指定的参数元组 $(\\gamma, \\beta, \\delta, r^2, s)$，计算：\n1) 使用 $G$ 作为工具变量，对 $E$ 对 $Y$ 的因果效应的大样本 MR 估计值，\n2) 该估计值相对于真实因果效应 $\\beta$ 的绝对偏差，\n3) 一个布尔值，指示 MR 估计值的符号是否与 $\\beta$ 的符号相反。\n\n所有计算都是无量纲的；不适用任何物理单位。您的程序必须使用以下参数元组的测试套件 $(\\gamma, \\beta, \\delta, r^2, s)$：\n- 案例 $1$：$(0.2, 0.5, 0.3, 0.25, +1)$。\n- 案例 $2$：$(0.2, 0.5, 0.3, 0.0, +1)$。\n- 案例 $3$：$(0.4, 0.5, 0.3, 0.36, -1)$。\n- 案例 $4$：$(0.05, 0.1, 0.2, 0.81, -1)$。\n- 案例 $5$：$(-0.3, 0.4, 0.2, 1.0, +1)$。\n\n对于每个案例，输出一个三元列表 $[\\widehat{\\beta}_{\\mathrm{MR}}, \\mathrm{bias}, \\mathrm{flip}]$，其中 $\\widehat{\\beta}_{\\mathrm{MR}}$ 是大样本 MR 估计值，$\\mathrm{bias}$ 是绝对偏差 $|\\widehat{\\beta}_{\\mathrm{MR}} - \\beta|$，如果 $\\widehat{\\beta}_{\\mathrm{MR}}$ 和 $\\beta$ 的符号相反，则 $\\mathrm{flip}$ 为布尔值 $\\mathrm{True}$，否则为 $\\mathrm{False}$。将所有浮点数四舍五入到 $6$ 位小数。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个元素本身是对应于一个测试案例的三元列表，例如，按给定案例的顺序为 $[[a,b, \\mathrm{False}],[c,d,\\mathrm{True}],\\dots]$。", "solution": "提交分析的问题陈述被认为是有效的。它在统计遗传学和因果推断领域，特别是在孟德尔随机化（MR）方面，具有科学依据。该问题是适定的，为获得唯一解提供了所有必要的参数和假设。它是客观的，没有歧义。因此，我们可以进行形式化求解。\n\n该问题要求基于一个已定义的线性结构模型，计算一个大样本双样本 MR 估计值、其偏差以及一个符号变化指示器。我们已知两个标准化的单核苷酸多态性（SNP）$G$ 和 $Z$，其均值为 $0$，方差为 $1$。因此，它们的协方差等于其相关性，即 $\\mathrm{Cov}(G, Z) = r = s \\sqrt{r^2}$。该系统由以下方程描述：\n$$ E = \\gamma G + \\xi $$\n$$ Y = \\beta E + \\delta Z + \\varepsilon $$\n其中 $G$ 是暴露 $E$ 对结局 $Y$ 效应的工具变量。$E$ 对 $Y$ 的真实因果效应是 $\\beta$。SNP $Z$ 是水平多效性的一个来源，因为它直接影响 $Y$（$\\delta \\neq 0$）并且与工具变量 $G$ 处于连锁不平衡（LD）状态（$r \\neq 0$）。\n\nMR 估计量 $\\widehat{\\beta}_{\\mathrm{MR}}$ 定义为结局 $Y$ 对工具变量 $G$ 的大样本关联与暴露 $E$ 对 $G$ 的关联之比。在大样本中，这些估计的关联收敛于它们的总体对应值。对于 $\\mathrm{Var}(G) = 1$ 的标准化工具变量 $G$，关联系数等于协方差。\n\n首先，我们推导 SNP-暴露关联，记为 $\\gamma_{G,E}$。\n$$ \\gamma_{G,E} = \\frac{\\mathrm{Cov}(E, G)}{\\mathrm{Var}(G)} = \\mathrm{Cov}(E, G) $$\n代入 $E$ 的模型：\n$$ \\gamma_{G,E} = \\mathrm{Cov}(\\gamma G + \\xi, G) = \\gamma \\mathrm{Cov}(G, G) + \\mathrm{Cov}(\\xi, G) $$\n鉴于 $\\mathrm{Var}(G) = 1$ 且噪声项 $\\xi$ 与 $G$ 独立（$\\mathrm{Cov}(\\xi, G) = 0$），这可以简化为：\n$$ \\gamma_{G,E} = \\gamma \\cdot 1 + 0 = \\gamma $$\n\n其次，我们推导 SNP-结局关联，$\\Gamma_{G,Y}$。\n$$ \\Gamma_{G,Y} = \\frac{\\mathrm{Cov}(Y, G)}{\\mathrm{Var}(G)} = \\mathrm{Cov}(Y, G) $$\n我们代入 $Y$ 的模型，然后再代入 $E$ 的模型：\n$$ Y = \\beta E + \\delta Z + \\varepsilon = \\beta (\\gamma G + \\xi) + \\delta Z + \\varepsilon = \\beta\\gamma G + \\beta\\xi + \\delta Z + \\varepsilon $$\n现在，我们计算与 $G$ 的协方差：\n$$ \\Gamma_{G,Y} = \\mathrm{Cov}(\\beta\\gamma G + \\beta\\xi + \\delta Z + \\varepsilon, G) $$\n利用协方差的线性和噪声项的独立性（$\\mathrm{Cov}(\\xi, G)=0, \\mathrm{Cov}(\\varepsilon, G)=0$）：\n$$ \\Gamma_{G,Y} = \\beta\\gamma \\mathrm{Cov}(G, G) + \\beta \\mathrm{Cov}(\\xi, G) + \\delta \\mathrm{Cov}(Z, G) + \\mathrm{Cov}(\\varepsilon, G) = \\beta\\gamma(1) + \\beta(0) + \\delta r + 0 = \\beta\\gamma + \\delta r $$\n\n大样本 MR 估计值 $\\widehat{\\beta}_{\\mathrm{MR}}$ 是这两个量的比值：\n$$ \\widehat{\\beta}_{\\mathrm{MR}} = \\frac{\\Gamma_{G,Y}}{\\gamma_{G,E}} = \\frac{\\beta\\gamma + \\delta r}{\\gamma} = \\beta + \\delta \\frac{r}{\\gamma} $$\n使用给定关系 $r = s\\sqrt{r^2}$，估计的最终表达式为：\n$$ \\widehat{\\beta}_{\\mathrm{MR}} = \\beta + \\delta \\frac{s\\sqrt{r^2}}{\\gamma} $$\n该表达式在 $\\gamma \\neq 0$ 的条件下有效，所有测试案例均满足此条件。\n\n绝对偏差是估计值与真实效应 $\\beta$ 之间的绝对差值：\n$$ \\mathrm{bias} = |\\widehat{\\beta}_{\\mathrm{MR}} - \\beta| = \\left| \\left(\\beta + \\delta \\frac{r}{\\gamma}\\right) - \\beta \\right| = \\left| \\delta \\frac{r}{\\gamma} \\right| = \\frac{|\\delta| \\sqrt{r^2}}{|\\gamma|} $$\n\n符号翻转指示器 $\\mathrm{flip}$ 是一个布尔值，如果 $\\widehat{\\beta}_{\\mathrm{MR}}$ 和 $\\beta$ 的符号相反，则为真。这等同于检验条件 $\\widehat{\\beta}_{\\mathrm{MR}} \\cdot \\beta < 0$，因为所提供的 $\\beta$ 值均不为零。\n\n我们现在将这些公式应用于每个测试案例。\n\n**案例 1：** $(\\gamma, \\beta, \\delta, r^2, s) = (0.2, 0.5, 0.3, 0.25, +1)$\n$r = +1 \\cdot \\sqrt{0.25} = 0.5$。\n$\\widehat{\\beta}_{\\mathrm{MR}} = 0.5 + 0.3 \\cdot \\frac{0.5}{0.2} = 0.5 + 0.75 = 1.25$。\n$\\mathrm{bias} = |1.25 - 0.5| = 0.75$。\n$\\mathrm{flip}$：$1.25 \\cdot 0.5 > 0$，所以为 $\\mathrm{False}$。\n结果：$[1.250000, 0.750000, \\mathrm{False}]$。\n\n**案例 2：** $(\\gamma, \\beta, \\delta, r^2, s) = (0.2, 0.5, 0.3, 0.0, +1)$\n$r = +1 \\cdot \\sqrt{0.0} = 0.0$。\n$\\widehat{\\beta}_{\\mathrm{MR}} = 0.5 + 0.3 \\cdot \\frac{0.0}{0.2} = 0.5$。\n$\\mathrm{bias} = |0.5 - 0.5| = 0.0$。\n$\\mathrm{flip}$：$0.5 \\cdot 0.5 > 0$，所以为 $\\mathrm{False}$。\n结果：$[0.500000, 0.000000, \\mathrm{False}]$。这是 LD 为零的无偏情况。\n\n**案例 3：** $(\\gamma, \\beta, \\delta, r^2, s) = (0.4, 0.5, 0.3, 0.36, -1)$\n$r = -1 \\cdot \\sqrt{0.36} = -0.6$。\n$\\widehat{\\beta}_{\\mathrm{MR}} = 0.5 + 0.3 \\cdot \\frac{-0.6}{0.4} = 0.5 - 0.45 = 0.05$。\n$\\mathrm{bias} = |0.05 - 0.5| = |-0.45| = 0.45$。\n$\\mathrm{flip}$：$0.05 \\cdot 0.5 > 0$，所以为 $\\mathrm{False}$。\n结果：$[0.050000, 0.450000, \\mathrm{False}]$。\n\n**案例 4：** $(\\gamma, \\beta, \\delta, r^2, s) = (0.05, 0.1, 0.2, 0.81, -1)$\n$r = -1 \\cdot \\sqrt{0.81} = -0.9$。\n$\\widehat{\\beta}_{\\mathrm{MR}} = 0.1 + 0.2 \\cdot \\frac{-0.9}{0.05} = 0.1 - 3.6 = -3.5$。\n$\\mathrm{bias} = |-3.5 - 0.1| = |-3.6| = 3.6$。\n$\\mathrm{flip}$：$-3.5 \\cdot 0.1 < 0$，所以为 $\\mathrm{True}$。\n由于弱工具变量（$\\gamma=0.05$），强烈的偏差导致了符号翻转。\n结果：$[-3.500000, 3.600000, \\mathrm{True}]$。\n\n**案例 5：** $(\\gamma, \\beta, \\delta, r^2, s) = (-0.3, 0.4, 0.2, 1.0, +1)$\n$r = +1 \\cdot \\sqrt{1.0} = 1.0$。\n$\\widehat{\\beta}_{\\mathrm{MR}} = 0.4 + 0.2 \\cdot \\frac{1.0}{-0.3} = 0.4 - \\frac{2}{3} \\approx -0.266667$。\n$\\mathrm{bias} = |(-0.266667) - 0.4| = |-0.666667| \\approx 0.666667$。\n$\\mathrm{flip}$：$(-0.266667) \\cdot 0.4 < 0$，所以为 $\\mathrm{True}$。\n结果：$[-0.266667, 0.666667, \\mathrm{True}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Mendelian randomization estimate, bias, and sign flip\n    for a series of parameter sets.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (gamma, beta, delta, r_squared, s)\n    test_cases = [\n        (0.2, 0.5, 0.3, 0.25, 1),\n        (0.2, 0.5, 0.3, 0.0, 1),\n        (0.4, 0.5, 0.3, 0.36, -1),\n        (0.05, 0.1, 0.2, 0.81, -1),\n        (-0.3, 0.4, 0.2, 1.0, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, beta, delta, r_squared, s = case\n\n        # Calculate the signed LD correlation r\n        r = s * np.sqrt(r_squared)\n\n        # Calculate the large-sample MR estimate beta_mr\n        # The formula is derived as beta_mr = beta + delta * r / gamma\n        # This is valid as gamma is non-zero in all test cases.\n        beta_mr = beta + (delta * r) / gamma\n\n        # Calculate the absolute bias of the estimate\n        bias = abs(beta_mr - beta)\n\n        # Determine if the estimate's sign is opposite to the true effect's sign.\n        # This condition is equivalent to beta_mr * beta  0, assuming beta is not 0.\n        # In all test cases, beta is positive, so this check simplifies to beta_mr  0.\n        flip = (beta_mr * beta)  0\n\n        results.append([beta_mr, bias, flip])\n\n    # Format the results into the required string format.\n    # Each result is a list [beta_mr, bias, flip].\n    # Floating point numbers are formatted to 6 decimal places.\n    # Booleans are converted to their string representation ('True' or 'False').\n    formatted_results = []\n    for res in results:\n        # Format: [float_val, float_val, Boolean]\n        # Example: [-3.500000, 3.600000, True]\n        formatted_res_str = f\"[{res[0]:.6f}, {res[1]:.6f}, {str(res[2])}]\"\n        formatted_results.append(formatted_res_str)\n\n    # Final print statement in the exact required format.\n    # Example: [[result1], [result2], ...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2377409"}, {"introduction": "在现实世界的生物学研究中，一个结局往往受到多个相互关联的暴露因素的共同影响。多变量孟德尔随机化（MVMR）扩展了传统MR框架，能够同时估计多个暴露对一个结局的直接因果效应。本练习将带你实践MVMR的核心算法，通过解决一个广义最小二乘问题，从汇总数据中分解出不同暴露（如BMI和受教育年限）对结局的独立贡献。[@problem_id:2377474]", "problem": "您会得到一个在孟德尔随机化（Mendelian Randomization, MR）中出现的多变量工具变量问题的摘要级（summary-level）公式。目标是使用多变量孟德尔随机化（MVMR）估计两种暴露——身体质量指数（BMI）和受教育年限——对收入结局的直接因果效应向量。假设您有 $L$ 个遗传变异用作工具变量，索引为 $l \\in \\{1,\\dots,L\\}$。对于每个变异 $l$，您会得到：\n- 与两种暴露的关联估计值，按行收集到一个矩阵 $A_{x} \\in \\mathbb{R}^{L \\times 2}$ 中。\n- 与结局的关联估计值，收集到一个向量 $b_{y} \\in \\mathbb{R}^{L}$ 中。\n- 结局关联的标准误，收集到一个对角矩阵 $S_{y} = \\mathrm{diag}(s_{1,y},\\dots,s_{L,y}) \\in \\mathbb{R}^{L \\times L}$ 中。\n- 一个对称正定工具变量相关矩阵 $R \\in \\mathbb{R}^{L \\times L}$。\n\n假设 $b_{y}$ 的渐近协方差为 $\\Sigma_{y} = S_{y} R S_{y}$。将 MVMR 估计量 $\\hat{\\beta} \\in \\mathbb{R}^{2}$ 定义为加权二次型\n$$\nQ(\\beta) = (b_{y} - A_{x} \\beta)^{\\top} \\Sigma_{y}^{-1} (b_{y} - A_{x} \\beta),\n$$\n的最小值点，其中 $\\beta = [\\beta_{\\mathrm{BMI}}, \\beta_{\\mathrm{Schooling}}]^{\\top}$ 是直接因果效应的向量。为以下每个测试用例计算 $\\hat{\\beta}$。\n\n下面所有数组均以行主序提供，每个数字都为实数值。对于每个用例，请严格使用给定的矩阵和向量，其中 $S_{y} = \\mathrm{diag}(s_{1,y},\\dots,s_{L,y})$ 且 $\\Sigma_{y} = S_{y} R S_{y}$。\n\n测试用例 1（独立工具变量，良态）：\n- $L = 5$。\n- $A_{x} = \\begin{bmatrix}\n0.08  0.02\\\\\n0.06  0.01\\\\\n0.07  0.03\\\\\n0.05  0.02\\\\\n0.09  0.01\n\\end{bmatrix}$。\n- $b_{y} = \\begin{bmatrix} 0.044\\\\ 0.028\\\\ 0.0445\\\\ 0.0295\\\\ 0.041 \\end{bmatrix}$。\n- $s_{y} = \\begin{bmatrix} 0.02\\\\ 0.02\\\\ 0.02\\\\ 0.02\\\\ 0.02 \\end{bmatrix}$，因此 $S_{y} = \\mathrm{diag}(0.02, 0.02, 0.02, 0.02, 0.02)$。\n- $R = I_{5}$，即 $5 \\times 5$ 单位矩阵。\n\n测试用例 2（相关工具变量，异方差标准误）：\n- $L = 4$。\n- $A_{x} = \\begin{bmatrix}\n0.05  0.04\\\\\n0.045  0.035\\\\\n0.06  0.05\\\\\n0.055  0.045\n\\end{bmatrix}$。\n- $b_{y} = \\begin{bmatrix} 0.04\\\\ 0.0333\\\\ 0.0488\\\\ 0.0429 \\end{bmatrix}$。\n- $s_{y} = \\begin{bmatrix} 0.015\\\\ 0.02\\\\ 0.018\\\\ 0.022 \\end{bmatrix}$，因此 $S_{y} = \\mathrm{diag}(0.015, 0.02, 0.018, 0.022)$。\n- $R = \\begin{bmatrix}\n1  0.25  0.0625  0.015625\\\\\n0.25  1  0.25  0.0625\\\\\n0.0625  0.25  1  0.25\\\\\n0.015625  0.0625  0.25  1\n\\end{bmatrix}$。\n\n测试用例 3（近似共线性的暴露，弱工具变量）：\n- $L = 3$。\n- $A_{x} = \\begin{bmatrix}\n0.02  0.0204\\\\\n0.018  0.01836\\\\\n0.017  0.01751\n\\end{bmatrix}$。\n- $b_{y} = \\begin{bmatrix} -0.0002\\\\ 0.00032\\\\ -0.000555 \\end{bmatrix}$。\n- $s_{y} = \\begin{bmatrix} 0.02\\\\ 0.02\\\\ 0.02 \\end{bmatrix}$，因此 $S_{y} = \\mathrm{diag}(0.02, 0.02, 0.02)$。\n- $R = I_{3}$，即 $3 \\times 3$ 单位矩阵。\n\n您的任务：对于每个测试用例，计算使上述定义的 $Q(\\beta)$ 最小化的二维估计量 $\\hat{\\beta} = [\\hat{\\beta}_{\\mathrm{BMI}}, \\hat{\\beta}_{\\mathrm{Schooling}}]^{\\top}$。将每个分量报告为实数。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有测试用例的结果，形式为单个扁平列表，顺序为 $[\\hat{\\beta}_{\\mathrm{BMI}}^{(1)}, \\hat{\\beta}_{\\mathrm{Schooling}}^{(1)}, \\hat{\\beta}_{\\mathrm{BMI}}^{(2)}, \\hat{\\beta}_{\\mathrm{Schooling}}^{(2)}, \\hat{\\beta}_{\\mathrm{BMI}}^{(3)}, \\hat{\\beta}_{\\mathrm{Schooling}}^{(3)}]$，其中上标表示测试用例索引。每个数字必须四舍五入到六位小数。列表必须用方括号括起来，并用逗号分隔，例如 $[0.123456,0.654321, \\dots]$。", "solution": "问题陈述经审慎核查，被认定为有效。这是一个适定的统计估计问题，基于多变量孟德尔随机化（MVMR）的既定原则。获得唯一解所需的所有数据和定义均已提供，不存在科学或逻辑上的矛盾。我现在开始求解。\n\n目标是找到使二次型最小化的因果效应向量 $\\hat{\\beta} \\in \\mathbb{R}^{2}$：\n$$\nQ(\\beta) = (b_{y} - A_{x} \\beta)^{\\top} \\Sigma_{y}^{-1} (b_{y} - A_{x} \\beta)\n$$\n其中 $b_{y} \\in \\mathbb{R}^{L}$ 是工具变量-结局关联的向量，$A_{x} \\in \\mathbb{R}^{L \\times 2}$ 是工具变量-暴露关联的矩阵，$\\Sigma_{y}^{-1}$ 是 $b_{y}$ 协方差矩阵的逆矩阵。这是一个标准的广义最小二乘（GLS）问题。\n\n为求最小值点 $\\hat{\\beta}$，我们必须计算 $Q(\\beta)$ 关于 $\\beta$ 的梯度，并将其设为零向量。首先，我们展开二次型：\n$$\nQ(\\beta) = b_{y}^{\\top}\\Sigma_{y}^{-1}b_{y} - b_{y}^{\\top}\\Sigma_{y}^{-1}A_{x}\\beta - \\beta^{\\top}A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y} + \\beta^{\\top}A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x}\\beta\n$$\n$b_{y}^{\\top}\\Sigma_{y}^{-1}A_{x}\\beta$ 和 $\\beta^{\\top}A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y}$ 这两项是标量。由于标量的转置是其自身，且注意到 $\\Sigma_{y}^{-1}$ 是对称的，我们有 $(\\beta^{\\top}A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y})^{\\top} = b_{y}^{\\top}(\\Sigma_{y}^{-1})^{\\top}(A_{x}^{\\top})^{\\top}\\beta = b_{y}^{\\top}\\Sigma_{y}^{-1}A_{x}\\beta$。因此，这两项相等。表达式简化为：\n$$\nQ(\\beta) = b_{y}^{\\top}\\Sigma_{y}^{-1}b_{y} - 2 b_{y}^{\\top}\\Sigma_{y}^{-1}A_{x}\\beta + \\beta^{\\top}(A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x})\\beta\n$$\n这是一个关于 $\\beta$ 的二次函数。根据向量微积分的标准法则，其关于 $\\beta$ 的梯度为：\n$$\n\\frac{\\partial Q(\\beta)}{\\partial \\beta} = -2 A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y} + 2 (A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x})\\beta\n$$\n为求最小值，将梯度设为零向量 $\\frac{\\partial Q(\\beta)}{\\partial \\beta} = 0$，得到 GLS 估计量的所谓正规方程：\n$$\n(A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x})\\hat{\\beta} = A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y}\n$$\n如果矩阵 $A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x}$ 可逆（这要求工具变量-暴露关联矩阵 $A_x$ 具有满列秩），我们便可以解出 $\\hat{\\beta}$：\n$$\n\\hat{\\beta} = (A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x})^{-1} A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y}\n$$\n协方差矩阵 $\\Sigma_{y}$ 由 $\\Sigma_{y} = S_{y} R S_{y}$ 给出，其中 $S_{y}$ 是标准误的对角矩阵，$R$ 是工具变量相关矩阵。$S_y$ 和 $R$ 都被指定为可逆的，因此 $\\Sigma_y$ 也是可逆的。\n\n该公式提供了解析解。实现将为每个测试用例计算此解。为了数值稳定性，我们不显式计算 $2 \\times 2$ 矩阵 $C = A_{x}^{\\top}\\Sigma_{y}^{-1}A_{x}$ 的逆，而是求解线性系统 $C\\hat{\\beta} = d$，其中 $d = A_{x}^{\\top}\\Sigma_{y}^{-1}b_{y}$。\n\n对于测试用例 1 和测试用例 3，工具变量相关矩阵 $R$ 是单位矩阵 $I$，且标准误是一致的，即对所有 $l$ 都有 $s_{l,y} = s$。在这种特殊情况下，$\\Sigma_{y} = \\mathrm{diag}(s, \\dots, s) \\cdot I \\cdot \\mathrm{diag}(s, \\dots, s) = s^2 I$。其逆矩阵为 $\\Sigma_{y}^{-1} = (1/s^2)I$。估计量简化为：\n$$\n\\hat{\\beta} = (A_{x}^{\\top}(\\frac{1}{s^2}I)A_{x})^{-1} A_{x}^{\\top}(\\frac{1}{s^2}I)b_{y} = (\\frac{1}{s^2}A_{x}^{\\top}A_{x})^{-1} (\\frac{1}{s^2}A_{x}^{\\top}b_{y}) = (s^2(A_{x}^{\\top}A_{x})^{-1}) (\\frac{1}{s^2}A_{x}^{\\top}b_{y}) = (A_{x}^{\\top}A_{x})^{-1}A_{x}^{\\top}b_{y}\n$$\n这是普通最小二乘（OLS）估计量。对于测试用例 2，由于存在非对角的 $R$ 和异方差的标准误，必须使用完整的 GLS 公式。\n\n每个测试用例的计算过程如下：\n1. 定义矩阵 $A_x$、$R$ 以及向量 $b_y$、$s_y$。\n2. 根据向量 $s_y$ 构建对角矩阵 $S_y$。\n3. 计算协方差矩阵 $\\Sigma_y = S_y R S_y$。\n4. 计算权重矩阵 $W = \\Sigma_y^{-1}$。\n5. 计算矩阵 $C = A_x^{\\top} W A_x$。\n6. 计算向量 $d = A_x^{\\top} W b_y$。\n7. 求解 $2 \\times 2$ 线性系统 $C\\hat{\\beta} = d$ 以获得 $\\hat{\\beta} = [\\hat{\\beta}_{\\mathrm{BMI}}, \\hat{\\beta}_{\\mathrm{Schooling}}]^{\\top}$。\n8. 收集所有测试用例的结果，并按规定格式化。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Multivariable Mendelian Randomization (MVMR) estimator\n    for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"L\": 5,\n            \"Ax\": np.array([\n                [0.08, 0.02],\n                [0.06, 0.01],\n                [0.07, 0.03],\n                [0.05, 0.02],\n                [0.09, 0.01]\n            ]),\n            \"by\": np.array([0.044, 0.028, 0.0445, 0.0295, 0.041]),\n            \"sy\": np.array([0.02, 0.02, 0.02, 0.02, 0.02]),\n            \"R\": np.identity(5)\n        },\n        {\n            \"L\": 4,\n            \"Ax\": np.array([\n                [0.05, 0.04],\n                [0.045, 0.035],\n                [0.06, 0.05],\n                [0.055, 0.045]\n            ]),\n            \"by\": np.array([0.04, 0.0333, 0.0488, 0.0429]),\n            \"sy\": np.array([0.015, 0.02, 0.018, 0.022]),\n            \"R\": np.array([\n                [1.0, 0.25, 0.0625, 0.015625],\n                [0.25, 1.0, 0.25, 0.0625],\n                [0.0625, 0.25, 1.0, 0.25],\n                [0.015625, 0.0625, 0.25, 1.0]\n            ])\n        },\n        {\n            \"L\": 3,\n            \"Ax\": np.array([\n                [0.02, 0.0204],\n                [0.018, 0.01836],\n                [0.017, 0.01751]\n            ]),\n            \"by\": np.array([-0.0002, 0.00032, -0.000555]),\n            \"sy\": np.array([0.02, 0.02, 0.02]),\n            \"R\": np.identity(3)\n        }\n    ]\n\n    all_betas = []\n\n    for case in test_cases:\n        Ax = case[\"Ax\"]\n        by = case[\"by\"]\n        sy = case[\"sy\"]\n        R = case[\"R\"]\n        L = case[\"L\"]\n\n        # 1. Construct the diagonal matrix S_y from the standard error vector s_y.\n        Sy = np.diag(sy)\n\n        # 2. Compute the covariance matrix of the outcome associations, Sigma_y.\n        # Sigma_y = S_y * R * S_y\n        Sigma_y = Sy @ R @ Sy\n        \n        # 3. Compute the weight matrix W, which is the inverse of Sigma_y.\n        # This is the precision matrix.\n        W = np.linalg.inv(Sigma_y)\n\n        # The MVMR estimator is the solution to the generalized least squares problem.\n        # beta_hat = (Ax^T * W * Ax)^-1 * Ax^T * W * by\n        \n        # 4. Compute the matrix C = Ax^T * W * Ax.\n        C = Ax.T @ W @ Ax\n        \n        # 5. Compute the vector d = Ax^T * W * by.\n        d = Ax.T @ W @ by\n        \n        # 6. Solve the linear system C * beta_hat = d for beta_hat.\n        # This is more numerically stable than computing the inverse of C directly.\n        beta_hat = np.linalg.solve(C, d)\n        \n        all_betas.extend(beta_hat)\n\n    # Format the results as specified: a flat list with numbers rounded to 6 decimal places.\n    formatted_results = [f\"{x:.6f}\" for x in all_betas]\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2377474"}]}