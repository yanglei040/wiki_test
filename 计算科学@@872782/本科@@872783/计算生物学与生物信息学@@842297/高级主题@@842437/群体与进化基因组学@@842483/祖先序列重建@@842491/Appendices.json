{"hands_on_practices": [{"introduction": "祖先序列重建最直观的方法之一是最大简约法（Maximum Parsimony），它遵循奥卡姆剃刀原则，即选择需要最少进化事件（如替换）的进化历史。虽然这个方法很简单，但它有时会产生模糊的推断，即多个祖先状态同样“简约”。这个练习将帮助你通过构建一个具体的场景，来深入理解简约法的内在属性及其局限性。[@problem_id:2099385]", "problem": "在进化生物学领域，祖先序列重建是一种计算方法，用于推断已灭绝祖先的蛋白质或核酸序列。完成此任务最简单和最基本的方法之一是最大简约原则。该原则指出，首选的进化历史是需要最少进化变化（例如，氨基酸替换）来解释在现存生物体中观察到的序列的那一个。\n\n考虑一组四个同源蛋白：P1、P2、P3 和 P4。它们的进化关系由系统发育树 `((P1, P2)Anc1, (P3, P4)Anc2)Anc-Root` 描述。这种表示法意味着 P1 和 P2 共享一个近期共同祖先 Anc1。同样，P3 和 P4 共享一个近期共同祖先 Anc2。而 Anc1 和 Anc2 又都源自这四个蛋白质的最后一个共同祖先 Anc-Root。\n\n我们正在检查这四个蛋白质序列比对中的一个单一位置。对于树中的任何给定祖先，如果单个氨基酸状态能使其到其后代的总替换数最小化，则该位置上氨基酸的重建被认为是“无歧义的”。相反，如果两种或更多种不同的氨基酸状态同等简约，即它们导致相同的最小替换数，则重建是“有歧义的”。\n\n以下选项列出了在四个现代蛋白质（P1、P2、P3、P4）的这个特定位置上发现的氨基酸，使用它们的标准单字母代码。下列哪种情况会导致根祖先 Anc-Root 的重建是有歧义的，同时确保*两个*中间祖先 Anc1 和 Anc2 的重建都是无歧义的？\n\nA. P1：丙氨酸(A)，P2：丙氨酸(A)，P3：甘氨酸(G)，P4：甘氨酸(G)\n\nB. P1：半胱氨酸(C)，P2：半胱氨酸(C)，P3：半胱氨酸(C)，P4：半胱氨酸(C)\n\nC. P1：亮氨酸(L)，P2：亮氨酸(L)，P3：亮氨酸(L)，P4：缬氨酸(V)\n\nD. P1：脯氨酸(P)，P2：丝氨酸(S)，P3：脯氨酸(P)，P4：丝氨酸(S)\n\nE. P1：苏氨酸(T)，P2：天冬氨酸(D)，P3：谷氨酸(E)，P4：苯丙氨酸(F)", "solution": "我们在有根二叉树 $((P1,P2)\\,\\text{Anc1},\\,(P3,P4)\\,\\text{Anc2})\\,\\text{Anc-Root}$ 上使用 Fitch 简约法。对于任何具有子节点状态集 $S_{L}$ 和 $S_{R}$ 的节点，其最小状态集为\n$$\nS=\\begin{cases}\nS_{L}\\cap S_{R},  & \\text{if } S_{L}\\cap S_{R}\\neq \\varnothing,\\\\\nS_{L}\\cup S_{R},  & \\text{if } S_{L}\\cap S_{R}=\\varnothing.\n\\end{cases}\n$$\n如果一个节点的状态集大小为 $1$，则该节点是无歧义的；如果其状态集大小至少为 $2$，则该节点是有歧义的。\n\n选项 A：P1=A, P2=A, P3=G, P4=G。\nAnc1: $S_{1}=\\{A\\}\\cap\\{A\\}=\\{A\\}$ (无歧义)。\nAnc2: $S_{2}=\\{G\\}\\cap\\{G\\}=\\{G\\}$ (无歧义)。\n根节点: $S_{R}=\\{A\\}\\cap\\{G\\}=\\varnothing \\Rightarrow S_{R}=\\{A,G\\}$ (有歧义)。\n这满足要求。\n\n选项 B：全部为 C。\nAnc1: $\\{C\\}$；Anc2: $\\{C\\}$；根节点: $\\{C\\}\\cap\\{C\\}=\\{C\\}$ (无歧义)。不满足要求。\n\n选项 C：P1=L, P2=L; P3=L, P4=V。\nAnc1: $\\{L\\}$ (无歧义)。\nAnc2: $\\{L\\}\\cap\\{V\\}=\\varnothing \\Rightarrow \\{L,V\\}$ (有歧义)。\n根节点: $\\{L\\}\\cap\\{L,V\\}=\\{L\\}$ (无歧义)。不满足要求。\n\n选项 D：P1=P, P2=S; P3=P, P4=S。\nAnc1: $\\{P,S\\}$ (有歧义)。\nAnc2: $\\{P,S\\}$ (有歧义)。\n根节点: $\\{P,S\\}\\cap\\{P,S\\}=\\{P,S\\}$ (有歧义)。不满足要求。\n\n选项 E：P1=T, P2=D; P3=E, P4=F。\nAnc1: $\\{T,D\\}$ (有歧义)。\nAnc2: $\\{E,F\\}$ (有歧义)。\n根节点: $\\{T,D\\}\\cap\\{E,F\\}=\\varnothing \\Rightarrow \\{T,D,E,F\\}$ (有歧义)。不满足要求。\n\n因此，只有选项 A 能在 Anc1 和 Anc2 均无歧义的情况下，得到一个有歧义的根节点。", "answer": "$$\\boxed{A}$$", "id": "2099385"}, {"introduction": "与简约法相比，概率方法通过计算后验概率为我们提供了量化不确定性的强大框架。然而，概率推断的结果有时可能与直觉相悖。这个练习设计了一个精巧的场景，在其中增加更多的物种（即更多的观测数据）反而会降低我们对某一特定祖先状态的置信度，这揭示了概率模型是如何权衡和处理相互冲突的进化信号的。[@problem_id:2372309]", "problem": "考虑一个单一的同源二态性状，在一个有根系统发育树上，遵循状态空间为 $\\{0,1\\}$ 的 Cavender-Farris-Neyman (CFN) 双态对称连续时间马尔可夫链 (CTMC) 模型进行演化。其无穷小生成元为\n$$\nQ \\;=\\; \\begin{pmatrix} -1 & 1 \\\\[4pt] 1 & -1 \\end{pmatrix},\n$$\n分支长度 $b$ 以每个位点的预期替换数来衡量，因此沿长度为 $b$ 的边的转移概率矩阵为 $\\exp(Qb)$。假设根节点的平稳先验是均匀分布，即 $\\Pr(\\text{根节点}=0)=\\Pr(\\text{根节点}=1)=\\tfrac{1}{2}$，并且给定其父节点的状态，叶节点的观测值在各条边上是条件独立的。\n\n考虑两种情景，两者中所有边的长度均为 $b=\\tfrac{1}{2}\\ln 3$。\n\n情景 $(i)$：一个有根的2-分类单元树，其中根节点 $R$ 通过长度为 $b$ 的边直接连接到叶节点 $A$ 和 $B$。在叶节点观测到的状态为 $A=0$ 和 $B=0$。\n\n情景 $(ii)$：一个有根的4-分类单元平衡树，其中根节点 $R$ 有两个子节点，即内部节点 $X$ 和 $Y$，每个节点都通过长度为 $b$ 的边与 $R$ 相连。节点 $X$ 有两个子节点，即叶节点 $A$ 和 $B$，每个节点都通过长度为 $b$ 的边与 $X$ 相连。节点 $Y$ 有两个子节点，即叶节点 $C$ 和 $D$，每个节点都通过长度为 $b$ 的边与 $Y$ 相连。在叶节点观测到的状态为 $A=0$、$B=0$、$C=1$ 和 $D=1$。\n\n令 $\\rho$ 表示在这两种情景下，根节点处于状态0的后验概率之比，\n$$\n\\rho \\;=\\; \\frac{\\Pr(R=0 \\mid \\text{情景 }(ii) \\text{中的数据})}{\\Pr(R=0 \\mid \\text{情景 }(i) \\text{中的数据})}.\n$$\n精确计算 $\\rho$。将最终答案表示为单个实数或单个精确分数。无需四舍五入，也无需单位。", "solution": "用户已提交一个问题以供验证和求解。\n\n**步骤1：提取已知条件**\n\n*   **模型：** Cavender-Farris-Neyman (CFN) 双态对称连续时间马尔可夫链 (CTMC)。\n*   **状态空间：** $\\{0,1\\}$。\n*   **无穷小生成元：** $Q = \\begin{pmatrix} -1  & 1 \\\\ 1  & -1 \\end{pmatrix}$。\n*   **分支长度：** $b$ 是每个位点的预期替换数。\n*   **转移概率矩阵：** $P(b) = \\exp(Qb)$。\n*   **根节点先验：** 均匀分布，$\\Pr(\\text{根节点}=0) = \\Pr(\\text{根节点}=1) = \\frac{1}{2}$。\n*   **条件独立性：** 给定父节点的状态，叶节点的观测值在各条边上是条件独立的。\n*   **分支长度值：** 所有边的长度均为 $b = \\frac{1}{2}\\ln 3$。\n*   **情景 (i)：** 一个有根的2-分类单元树。根节点 $R$ 有两个子节点，即叶节点 $A$ 和 $B$。边 $(R,A)$ 和 $(R,B)$ 的长度为 $b$。叶节点状态为 $A=0$ 和 $B=0$。\n*   **情景 (ii)：** 一个有根的4-分类单元平衡树。根节点 $R$ 的子节点为 $X$ 和 $Y$。$X$ 的子节点为 $A$ 和 $B$。$Y$ 的子节点为 $C$ 和 $D$。所有六条边的长度均为 $b$。叶节点状态为 $A=0$、$B=0$、$C=1$、$D=1$。\n*   **目标量：** 比率 $\\rho = \\frac{\\Pr(R=0 \\mid \\text{情景 }(ii) \\text{中的数据})}{\\Pr(R=0 \\mid \\text{情景 }(i) \\text{中的数据})}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据指定标准对问题进行验证。\n\n*   **科学依据：** 该问题基于CFN模型，这是分子进化和系统发育学的基石。所有概念，包括CTMC、无穷小生成元、转移概率、用于似然计算的Felsenstein剪枝算法以及贝叶斯后验推断，都是计算生物学和生物信息学中的标准且成熟的概念。该问题具有科学合理性。\n*   **良态性：** 该问题指明了所有必要组成部分：系统发育模型、树拓扑结构、分支长度以及叶节点的性状状态。目标是计算一个特定、明确定义的后验概率比率。可以从所提供的信息中推导出一个唯一、稳定且有意义的解。\n*   **客观性：** 问题陈述使用精确、无歧义的数学和生物学术语进行阐述。没有主观或基于观点的元素。\n*   **完整性与一致性：** 所提供的数据是自足的，足以得出一个完整的解。没有缺失的参数或矛盾的约束。在均匀平稳分布下，将分支长度定义为每个位点的预期替换数与所提供的生成元矩阵是一致的。\n\n**步骤3：结论与行动**\n\n该问题有效。它具有科学依据，是良态的、客观的且自洽的。我将继续提供完整的解。\n\n**求解推导**\n\n问题的核心是计算两种不同情景下根节点状态的后验概率。对于给定的根节点状态 $s \\in \\{0, 1\\}$ 和观测数据 $D$，根据贝叶斯定理，后验概率为：\n$$\n\\Pr(R=s \\mid D) = \\frac{\\Pr(D \\mid R=s)\\Pr(R=s)}{\\Pr(D)}\n$$\n数据的总概率为 $\\Pr(D) = \\sum_{s' \\in \\{0,1\\}} \\Pr(D \\mid R=s')\\Pr(R=s')$。给定均匀先验 $\\Pr(R=0) = \\Pr(R=1) = \\frac{1}{2}$，这可以简化为：\n$$\n\\Pr(R=0 \\mid D) = \\frac{\\Pr(D \\mid R=0) \\cdot \\frac{1}{2}}{\\Pr(D \\mid R=0) \\cdot \\frac{1}{2} + \\Pr(D \\mid R=1) \\cdot \\frac{1}{2}} = \\frac{L(0)}{L(0) + L(1)}\n$$\n其中 $L(s) = \\Pr(D \\mid R=s)$ 是在根节点处于状态 $s$ 的条件下数据的似然。\n\n首先，我们必须确定转移概率矩阵 $P(b) = \\exp(Qb)$。生成元为 $Q = \\begin{pmatrix} -1  & 1 \\\\ 1  & -1 \\end{pmatrix}$。$Q$ 的特征值 $\\lambda$ 由 $\\det(Q - \\lambda I) = (-1-\\lambda)^2 - 1 = \\lambda^2 + 2\\lambda = 0$ 给出，解得 $\\lambda_1 = 0$ 和 $\\lambda_2 = -2$。矩阵指数运算给出在长度为 $b$ 的分支上的转移概率：\n$$\nP(b) = \\begin{pmatrix} P_{00}(b)  & P_{01}(b) \\\\ P_{10}(b)  & P_{11}(b) \\end{pmatrix} = \\frac{1}{2} \\begin{pmatrix} 1+\\exp(-2b)  & 1-\\exp(-2b) \\\\ 1-\\exp(-2b)  & 1+\\exp(-2b) \\end{pmatrix}\n$$\n问题指定 $b = \\frac{1}{2}\\ln 3$。我们将其代入指数项：\n$$\n\\exp(-2b) = \\exp\\left(-2 \\cdot \\frac{1}{2}\\ln 3\\right) = \\exp(-\\ln 3) = 3^{-1} = \\frac{1}{3}\n$$\n因此，转移概率为：\n$P_{00}(b) = P_{11}(b) = \\frac{1}{2}(1 + \\frac{1}{3}) = \\frac{1}{2}(\\frac{4}{3}) = \\frac{2}{3}$。\n$P_{01}(b) = P_{10}(b) = \\frac{1}{2}(1 - \\frac{1}{3}) = \\frac{1}{2}(\\frac{2}{3}) = \\frac{1}{3}$。\n\n**情景 (i) 分析**\n该树有根节点 $R$ 和叶节点 $A, B$。数据为 $D_i = \\{A=0, B=0\\}$。分支 $(R,A)$ 和 $(R,B)$ 的长度均为 $b$。\n似然计算如下，利用了从 $R$ 派生的子树的条件独立性：\n$$\nL_i(0) = \\Pr(A=0, B=0 \\mid R=0) = \\Pr(A=0 \\mid R=0) \\Pr(B=0 \\mid R=0) = P_{00}(b) \\cdot P_{00}(b) = \\frac{2}{3} \\cdot \\frac{2}{3} = \\frac{4}{9}\n$$\n$$\nL_i(1) = \\Pr(A=0, B=0 \\mid R=1) = \\Pr(A=0 \\mid R=1) \\Pr(B=0 \\mid R=1) = P_{10}(b) \\cdot P_{10}(b) = \\frac{1}{3} \\cdot \\frac{1}{3} = \\frac{1}{9}\n$$\n根节点处于状态0的后验概率为：\n$$\n\\Pr(R=0 \\mid D_i) = \\frac{L_i(0)}{L_i(0) + L_i(1)} = \\frac{\\frac{4}{9}}{\\frac{4}{9} + \\frac{1}{9}} = \\frac{\\frac{4}{9}}{\\frac{5}{9}} = \\frac{4}{5}\n$$\n\n**情景 (ii) 分析**\n该树有根节点 $R$，其子节点为 $X, Y$。$X$ 的子节点为 $A, B$，$Y$ 的子节点为 $C, D$。数据为 $D_{ii} = \\{A=0, B=0, C=1, D=1\\}$。所有分支的长度均为 $b$。\n我们使用Felsenstein的剪枝算法来计算似然。令 $L_K(s)$ 为在节点 $K$ 处于状态 $s$ 的条件下，以节点 $K$ 为根的子树中数据的条件似然。\n叶节点的似然是δ函数：$L_A=(1,0)$，$L_B=(1,0)$，$L_C=(0,1)$，$L_D=(0,1)$。\n\n首先，我们计算内部节点 $X$ 和 $Y$ 的条件似然向量。\n对于节点 $X$ (子节点为 $A=0, B=0$)：\n$L_X(0) = P_{00}(b)L_A(0) \\cdot P_{00}(b)L_B(0) = \\frac{2}{3} \\cdot 1 \\cdot \\frac{2}{3} \\cdot 1 = \\frac{4}{9}$\n$L_X(1) = P_{10}(b)L_A(0) \\cdot P_{10}(b)L_B(0) = \\frac{1}{3} \\cdot 1 \\cdot \\frac{1}{3} \\cdot 1 = \\frac{1}{9}$\n所以，$L_X = (\\frac{4}{9}, \\frac{1}{9})$。\n\n对于节点 $Y$ (子节点为 $C=1, D=1$)：\n$L_Y(0) = P_{01}(b)L_C(1) \\cdot P_{01}(b)L_D(1) = \\frac{1}{3} \\cdot 1 \\cdot \\frac{1}{3} \\cdot 1 = \\frac{1}{9}$\n$L_Y(1) = P_{11}(b)L_C(1) \\cdot P_{11}(b)L_D(1) = \\frac{2}{3} \\cdot 1 \\cdot \\frac{2}{3} \\cdot 1 = \\frac{4}{9}$\n所以，$L_Y = (\\frac{1}{9}, \\frac{4}{9})$。\n\n接下来，我们通过从其子节点 $X$ 和 $Y$ 传播似然来计算根节点 $R$ 的似然。\n$$\nL_{ii}(s) = \\left( \\sum_{s_X=0}^1 P_{s,s_X}(b) L_X(s_X) \\right) \\left( \\sum_{s_Y=0}^1 P_{s,s_Y}(b) L_Y(s_Y) \\right)\n$$\n对于 $R=0$：\n$$\nL_{ii}(0) = \\left( P_{00}(b)L_X(0) + P_{01}(b)L_X(1) \\right) \\left( P_{00}(b)L_Y(0) + P_{01}(b)L_Y(1) \\right)\n$$\n$$\nL_{ii}(0) = \\left( \\frac{2}{3} \\cdot \\frac{4}{9} + \\frac{1}{3} \\cdot \\frac{1}{9} \\right) \\left( \\frac{2}{3} \\cdot \\frac{1}{9} + \\frac{1}{3} \\cdot \\frac{4}{9} \\right) = \\left( \\frac{8}{27} + \\frac{1}{27} \\right) \\left( \\frac{2}{27} + \\frac{4}{27} \\right) = \\left( \\frac{9}{27} \\right) \\left( \\frac{6}{27} \\right) = \\frac{1}{3} \\cdot \\frac{2}{9} = \\frac{2}{27}\n$$\n对于 $R=1$：\n$$\nL_{ii}(1) = \\left( P_{10}(b)L_X(0) + P_{11}(b)L_X(1) \\right) \\left( P_{10}(b)L_Y(0) + P_{11}(b)L_Y(1) \\right)\n$$\n$$\nL_{ii}(1) = \\left( \\frac{1}{3} \\cdot \\frac{4}{9} + \\frac{2}{3} \\cdot \\frac{1}{9} \\right) \\left( \\frac{1}{3} \\cdot \\frac{1}{9} + \\frac{2}{3} \\cdot \\frac{4}{9} \\right) = \\left( \\frac{4}{27} + \\frac{2}{27} \\right) \\left( \\frac{1}{27} + \\frac{8}{27} \\right) = \\left( \\frac{6}{27} \\right) \\left( \\frac{9}{27} \\right) = \\frac{2}{9} \\cdot \\frac{1}{3} = \\frac{2}{27}\n$$\n似然相等：$L_{ii}(0) = L_{ii}(1)$。根节点处于状态0的后验概率为：\n$$\n\\Pr(R=0 \\mid D_{ii}) = \\frac{L_{ii}(0)}{L_{ii}(0) + L_{ii}(1)} = \\frac{\\frac{2}{27}}{\\frac{2}{27} + \\frac{2}{27}} = \\frac{\\frac{2}{27}}{\\frac{4}{27}} = \\frac{1}{2}\n$$\n似然的相等表明，在这种对称模型和树结构下，观测数据没有提供任何信息来区分根节点的状态，因此后验分布恢复到先验分布。\n\n**比率 $\\rho$ 的最终计算**\n问题要求计算比率 $\\rho$：\n$$\n\\rho = \\frac{\\Pr(R=0 \\mid D_{ii})}{\\Pr(R=0 \\mid D_i)} = \\frac{\\frac{1}{2}}{\\frac{4}{5}} = \\frac{1}{2} \\cdot \\frac{5}{4} = \\frac{5}{8}\n$$\n结果是一个精确分数。", "answer": "$$\n\\boxed{\\frac{5}{8}}\n$$", "id": "2372309"}, {"introduction": "理论计算是基础，但最终目标是能够分析真实的序列数据。这个练习将指导你从单一位点的计算过渡到完整的序列重建，并编写一个实用的算法。由于真实的测序数据常常包含缺失或不确定的部分（通常用 'N' 表示），正确处理这些缺失数据是至关重要的，本练习将重点关注这一点，带你实现基于Felsenstein剪枝算法的祖先序列推断程序。[@problem_id:2372378]", "problem": "给定一棵具有枝长的固定、有根的系统发育树，以及其叶节点上的一组脱氧核糖核酸（DNA）序列。目标是在 Jukes–Cantor 核苷酸替换模型下，重建根节点的最大后验（MAP）祖先序列，即使当某个现存序列包含由字符 'N' 表示的大段连续缺失数据时也是如此。\n\n假设采用称为 Jukes–Cantor 的连续时间马尔可夫链（CTMC）模型，其速率参数 $\\mu = 1$ 次替换/单位时间，平稳分布为 $\\pi = (\\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4})$，字母表为 $\\mathcal{A} = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$。将核苷酸映射为整数：$\\text{A} \\mapsto 0$，$\\text{C} \\mapsto 1$，$\\text{G} \\mapsto 2$，$\\text{T} \\mapsto 3$。将叶节点上的 'N' 视为缺失数据，它与任何核苷酸都同等兼容。\n\n基本原理：在字母表 $\\mathcal{A}$ 上的一个 CTMC 中，转移概率矩阵为 $P(t) = e^{Qt}$，其中 $Q$ 是速率矩阵。在 Jukes–Cantor 模型中，$Q$ 的非对角线元素为 $\\tfrac{1}{3}$，对角线元素为 $-1$。因此，转移概率满足 $P_{ii}(t) = \\tfrac{1}{4} + \\tfrac{3}{4} e^{- \\tfrac{4}{3} t}$ 以及当 $i \\neq j$ 时，$P_{ij}(t) = \\tfrac{1}{4} - \\tfrac{1}{4} e^{- \\tfrac{4}{3} t}$。对于一棵具有独立位点演化的有根树，在给定位置，根节点处于状态 $k \\in \\{0,1,2,3\\}$ 的似然与所有子节点贡献的乘积成正比，其中每个子节点的贡献是通过对子节点所有可能状态求和（转移概率乘以子节点条件似然）得到的。而根节点的后验概率则与 $\\pi_k$ 乘以该似然成正比。叶节点上的缺失数据被建模为在所有状态上均匀的条件似然。\n\n实现一个程序，对下方的每个测试用例，使用树上的动态规划（例如，基于条件似然的剪枝算法）在该模型下逐位点计算 MAP 根序列。当某个位点的后验概率出现相同时，根据固定的映射顺序 $\\text{A} \\to \\text{C} \\to \\text{G} \\to \\text{T}$ 选择最小的整数来打破平局，即在最大化项中选择最小的 $k \\in \\{0,1,2,3\\}$。\n\n每个测试用例包含：\n- 一棵有根树，由从父节点到子节点的有向边指定，带有枝长 $t \\ge 0$，其时间单位与上文相同。\n- 一个叶序列字典，所有序列长度相等 $L \\in \\mathbb{N}$，基于字母表 $\\{\\text{A}, \\text{C}, \\text{G}, \\text{T}, \\text{N}\\}$。\n\n你的程序必须硬编码以下测试套件并产生所需的输出：\n\n测试用例 1（平衡树，其中一个现存序列有大块缺失）：\n- 带枝长的树边：\n  - $\\text{R} \\to \\text{I1}$，枝长 $t = 0.1$；$\\text{R} \\to \\text{I2}$，枝长 $t = 0.1$\n  - $\\text{I1} \\to \\text{S1}$，枝长 $t = 0.1$；$\\text{I1} \\to \\text{S2}$，枝长 $t = 0.1$\n  - $\\text{I2} \\to \\text{S3}$，枝长 $t = 0.1$；$\\text{I2} \\to \\text{S4}$，枝长 $t = 0.1$\n- 长度为 $L = 8$ 的叶序列：\n  - $\\text{S1}$: ACGTTGCA\n  - $\\text{S2}$: ACGTCGCA\n  - $\\text{S3}$: NNNNNNNN\n  - $\\text{S4}$: ACGTTGTA\n\n测试用例 2（星状树，带有零长度枝的边界条件）：\n- 带枝长的树边：\n  - $\\text{R} \\to \\text{S1}$，枝长 $t = 0.0$；$\\text{R} \\to \\text{S2}$，枝长 $t = 0.001$；$\\text{R} \\to \\text{S3}$，枝长 $t = 0.001$\n- 长度为 $L = 4$ 的叶序列：\n  - $\\text{S1}$: AAAA\n  - $\\text{S2}$: AAAA\n  - $\\text{S3}$: ANNN\n\n测试用例 3（接近平稳分布的深层分支）：\n- 带枝长的树边：\n  - $\\text{R} \\to \\text{S1}$，枝长 $t = 2.0$；$\\text{R} \\to \\text{I}$，枝长 $t = 2.0$\n  - $\\text{I} \\to \\text{S2}$，枝长 $t = 2.0$；$\\text{I} \\to \\text{S3}$，枝长 $t = 2.0$\n- 长度为 $L = 6$ 的叶序列：\n  - $\\text{S1}$: GGGGGG\n  - $\\text{S2}$: GGGGGA\n  - $\\text{S3}$: CCCGGA\n\n测试用例 4（所有叶节点数据缺失，为平局打破场景）：\n- 带枝长的树边：\n  - $\\text{R} \\to \\text{S1}$，枝长 $t = 0.5$；$\\text{R} \\to \\text{S2}$，枝长 $t = 0.5$；$\\text{R} \\to \\text{S3}$，枝长 $t = 0.5$\n- 长度为 $L = 3$ 的叶序列：\n  - $\\text{S1}$: NNN\n  - $\\text{S2}$: NNN\n  - $\\text{S3}$: NNN\n\n输出规范：\n- 对每个测试用例，使用映射 $\\text{A} \\mapsto 0$、$\\text{C} \\mapsto 1$、$\\text{G} \\mapsto 2$、$\\text{T} \\mapsto 3$ 计算 MAP 根序列，结果为长度为 $L$ 的整数列表。\n- 你的程序应生成一行输出，其中包含四个结果，格式为用方括号括起来的逗号分隔列表，每个结果本身也是一个用方括号括起来的逗号分隔列表。例如，整体格式必须类似于 $[ [\\dots], [\\dots], [\\dots], [\\dots] ]$，但不含空格，即精确地为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$。", "solution": "该问题要求确定给定系统发育树根节点的最大后验（MAP）祖先序列。此问题是适定的，在分子演化原理上具有坚实的科学基础，并为获得唯一解提供了所有必要的参数。因此，我将给出一个完整且论证充分的解决方案。\n\n问题的核心在于应用 Felsenstein 剪枝算法，这是一种用于计算系统发育树上序列数据似然的动态规划方法。假设序列中每个位点的核苷酸演化都遵循一个连续时间马尔可夫链（CTMC），并且是独立同分布的。\n\n指定的模型是 Jukes–Cantor 模型，该模型假设任意两种不同核苷酸之间的替换速率相等，且在字母表 $\\mathcal{A} = \\{\\text{A}, \\text{C}, \\text{G}, \\text{T}\\}$ 上具有均匀的平稳分布 $\\pi = (\\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4}, \\tfrac{1}{4})$。核苷酸分别映射为整数 $0, 1, 2, 3$。速率矩阵 $Q$ 的非对角线元素为 $Q_{ij} = \\tfrac{1}{3}$（当 $i \\neq j$），对角线元素为 $Q_{ii} = -1$。对于长度为 $t$ 的分支，其转移概率矩阵为 $P(t) = e^{Qt}$，其元素由以下公式给出：\n$$ P_{ii}(t) = \\frac{1}{4} + \\frac{3}{4} e^{- \\frac{4}{3} t} $$\n$$ P_{ij}(t) = \\frac{1}{4} - \\frac{1}{4} e^{- \\frac{4}{3} t} \\quad (\\text{当 } i \\neq j) $$\n对于长度为 $t=0$ 的分支，$P(0)$ 成为单位矩阵，正确地模拟了没有发生变化的情况。\n\n对于根节点 $R$ 上的一个给定位置，其 MAP 状态是使后验概率 $P(\\text{state}_R=k | \\text{Data})$ 最大化的状态 $k \\in \\mathcal{A}$。根据贝叶斯定理，该概率与似然和先验的乘积成正比：\n$$ \\underset{k}{\\arg\\max} \\, P(\\text{state}_R=k | \\text{Data}) = \\underset{k}{\\arg\\max} \\, P(\\text{Data} | \\text{state}_R=k) \\cdot P(\\text{state}_R=k) $$\n先验概率 $P(\\text{state}_R=k)$ 由平稳分布 $\\pi_k$ 给出。由于对所有 $k$ 都有 $\\pi_k = \\tfrac{1}{4}$，先验是均匀的，不影响最大化过程。因此，MAP 估计等价于最大似然估计，我们只需计算并最大化每个状态 $k$ 的似然 $L_R(k) = P(\\text{Data} | \\text{state}_R=k)$。\n\n剪枝算法通过对树进行从叶节点到根节点的后序遍历来计算这些似然。对于比对中的每个位点，算法按以下步骤进行：\n\n1.  **叶节点初始化**：对于每个叶节点 $u$，我们定义一个大小为 4 的条件似然向量 $L_u$。如果当前位点观察到的核苷酸是 $c$，对应整数为 $c_{int}$，则该向量为 $L_u(k) = \\delta_{k, c_{int}}$（一个在位置 $c_{int}$ 处为 1、其余位置为 0 的向量）。如果数据缺失（'N'），则所有状态被认为是等可能的，因此 $L_u$ 是一个全为 1 的向量，即对于所有 $k \\in \\{0, 1, 2, 3\\}$，$L_u(k) = 1$。\n\n2.  **内部节点递归**：对于一个有子节点 $v_1, \\dots, v_m$ 的内部节点 $u$，设从 $u$ 到 $v_j$ 的分支长度为 $t_j$。在计算完其所有子节点的向量后，计算似然向量 $L_u$。给定节点 $u$ 处于状态 $k$ 时，其子节点子树中数据的似然，是来自每个子节点子树贡献的乘积。来自子节点 $v_j$ 的贡献是通过对节点 $v_j$ 的所有可能状态 $s$ 求和得到的：\n    $$ L_u(k) = \\prod_{j=1}^{m} \\left( \\sum_{s=0}^{3} P_{ks}(t_j) \\cdot L_{v_j}(s) \\right) $$\n    该求和 $\\sum_{s=0}^{3} P_{ks}(t_j) \\cdot L_{v_j}(s)$ 是矩阵-向量乘积 $P(t_j) L_{v_j}$ 的第 $k$ 个元素。最终向量 $L_u$ 是所有子节点产生的这些结果向量的逐元素乘积。\n\n3.  **根节点最终计算**：遍历在根节点 $R$ 处终止。得到的结果向量 $L_R$ 包含每个 $k \\in \\{0, 1, 2, 3\\}$ 的似然 $P(\\text{Data} | \\text{state}_R=k)$。\n\n4.  **MAP 状态确定**：通过找到使 $L_R(k)$ 最大化的索引 $k$ 来确定该位点的 MAP 状态。如果出现平局，则根据问题说明选择最小的整数索引。\n\n对序列比对中的每个位点重复此完整过程，以构建完整的祖先序列。实现时将表示树结构，按需预计算转移矩阵，并对每个位点执行后序遍历以找到 MAP 根状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main function to solve the ancestral sequence reconstruction problem for all test cases.\n    \"\"\"\n    \n    # Mapping for nucleotides to integers.\n    NUC_MAP = {'A': 0, 'C': 1, 'G': 2, 'T': 3}\n\n    # Memoization cache for the transition probability matrix P(t).\n    p_matrix_cache = {}\n\n    def get_p_matrix(t):\n        \"\"\"\n        Computes the Jukes-Cantor transition probability matrix P(t).\n        Uses a cache to avoid recomputing for the same branch length t.\n        P_ii(t) = 1/4 + 3/4 * exp(-4/3 * t)\n        P_ij(t) = 1/4 - 1/4 * exp(-4/3 * t) for i != j\n        \"\"\"\n        if t in p_matrix_cache:\n            return p_matrix_cache[t]\n        \n        if t  1e-9: # Treat very small t as 0 to avoid precision issues\n            P = np.identity(4)\n        else:\n            val = np.exp(-4.0 / 3.0 * t)\n            p_diag = 0.25 + 0.75 * val\n            p_offdiag = 0.25 - 0.25 * val\n            P = np.full((4, 4), p_offdiag)\n            np.fill_diagonal(P, p_diag)\n        \n        p_matrix_cache[t] = P\n        return P\n\n    def get_map_root_sequence(edges, leaf_seqs):\n        \"\"\"\n        Computes the MAP ancestral sequence for a single phylogenetic tree and sequence set.\n        \"\"\"\n        # Build tree representation from edge list\n        all_nodes = set()\n        children_map = defaultdict(list)\n        branch_length_map = {} # Maps a child node to the length of the branch from its parent\n\n        for parent, child, blen in edges:\n            all_nodes.add(parent)\n            all_nodes.add(child)\n            children_map[parent].append(child)\n            branch_length_map[child] = blen\n        \n        root = list(all_nodes - set(branch_length_map.keys()))[0]\n        leaves = [node for node in all_nodes if not children_map[node]]\n\n        # Generate a post-order traversal of the tree nodes.\n        # This is done by a non-recursive pre-order traversal followed by a reverse.\n        post_order_traversal = []\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            post_order_traversal.append(node)\n            stack.extend(children_map.get(node, []))\n        post_order_traversal.reverse()\n\n        seq_len = len(list(leaf_seqs.values())[0])\n        map_root_seq = []\n\n        # Perform site-by-site reconstruction using the pruning algorithm\n        for i in range(seq_len):\n            likelihoods = {}\n            for node in post_order_traversal:\n                if node in leaves:\n                    char = leaf_seqs[node][i]\n                    if char == 'N':\n                        L = np.ones(4)\n                    else:\n                        L = np.zeros(4)\n                        L[NUC_MAP[char]] = 1.0\n                    likelihoods[node] = L\n                else: # Internal node\n                    L_node = np.ones(4)\n                    for child in children_map[node]:\n                        blen = branch_length_map[child]\n                        P = get_p_matrix(blen)\n                        L_child = likelihoods[child]\n                        child_contribution = P @ L_child\n                        L_node *= child_contribution\n                    likelihoods[node] = L_node\n            \n            # The posterior at the root is proportional to the likelihoods\n            # because the prior (stationary distribution) is uniform.\n            root_likelihoods = likelihoods[root]\n            \n            # Find the MAP state. np.argmax breaks ties by choosing the first index,\n            # which corresponds to the problem's tie-breaking rule.\n            map_state = np.argmax(root_likelihoods)\n            map_root_seq.append(map_state)\n            \n        return map_root_seq\n\n    # Hard-coded test cases from the problem statement\n    test_cases = [\n        {\n            \"edges\": [\n                ('R', 'I1', 0.1), ('R', 'I2', 0.1),\n                ('I1', 'S1', 0.1), ('I1', 'S2', 0.1),\n                ('I2', 'S3', 0.1), ('I2', 'S4', 0.1)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"ACGTTGCA\", 'S2': \"ACGTCGCA\",\n                'S3': \"NNNNNNNN\", 'S4': \"ACGTTGTA\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 0.0), ('R', 'S2', 0.001), ('R', 'S3', 0.001)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"AAAA\", 'S2': \"AAAA\", 'S3': \"ANNN\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 2.0), ('R', 'I', 2.0),\n                ('I', 'S2', 2.0), ('I', 'S3', 2.0)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"GGGGGG\", 'S2': \"GGGGGA\", 'S3': \"CCCGGA\"\n            }\n        },\n        {\n            \"edges\": [\n                ('R', 'S1', 0.5), ('R', 'S2', 0.5), ('R', 'S3', 0.5)\n            ],\n            \"leaf_seqs\": {\n                'S1': \"NNN\", 'S2': \"NNN\", 'S3': \"NNN\"\n            }\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = get_map_root_sequence(case[\"edges\"], case[\"leaf_seqs\"])\n        results.append(result)\n\n    # Format the final output string exactly as specified\n    inner_strings = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2372378"}]}