{"hands_on_practices": [{"introduction": "通过水平基因转移（HGT）获得的基因通常带有与其新宿主基因组不同的核苷酸“方言”，即它们的核苷酸组成（如四核苷酸频率）存在差异。本练习将介绍一种强大的统计学方法——主成分分析（PCA），用于自动检测在核苷酸组成上表现为异常值的基因。通过这个动手编码练习，你将学习如何将多元数据分析技术应用于基因组学数据，以识别潜在的HGT事件。[@problem_id:2385117]", "problem": "给定一个来自单一原核生物基因组的脱氧核糖核酸（DNA）编码区集合。对于每个编码区（基因），我们已经统计了一组固定的四核苷酸（四个核苷酸组成的词）的数量。生物学上的假说是，通过水平基因转移获得的基因，其组成模式会偏离基因组典型的四核苷酸使用方式。您的任务是，将此假说形式化为一个纯粹应用于所提供计数数据的数学检测规则，并将其实现为一个完整的程序，用以标记异常基因。\n\n数学设定。假设有 $n_g$ 个基因和 $n_k$ 个四核苷酸类别。对于基因 $i \\in \\{0,\\dots,n_g-1\\}$，令 $\\mathbf{c}_i \\in \\mathbb{N}_0^{n_k}$ 表示指定的四核苷酸类别的计数向量，并令 $N_i = \\sum_{j=0}^{n_k-1} c_{i,j}$ 为基因 $i$ 的总计数。定义频率向量 $\\mathbf{f}_i \\in \\mathbb{R}^{n_k}$，其中对所有 $j$，$f_{i,j} = c_{i,j} / N_i$。令平均频率向量为 $\\boldsymbol{\\mu} = \\frac{1}{n_g}\\sum_{i=0}^{n_g-1} \\mathbf{f}_i$。定义中心化向量 $\\mathbf{z}_i = \\mathbf{f}_i - \\boldsymbol{\\mu}$。令经验协方差矩阵为\n$$\n\\boldsymbol{\\Sigma} = \\frac{1}{n_g - 1} \\sum_{i=0}^{n_g-1} \\mathbf{z}_i \\mathbf{z}_i^\\top \\in \\mathbb{R}^{n_k \\times n_k}.\n$$\n令 $\\boldsymbol{\\Sigma}$ 的特征分解为 $\\boldsymbol{\\Sigma} = \\mathbf{V}\\boldsymbol{\\Lambda}\\mathbf{V}^\\top$，其中 $\\boldsymbol{\\Lambda} = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_{n_k})$ 且 $\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_{n_k} \\ge 0$，$\\mathbf{V} = [\\mathbf{v}_1,\\dots,\\mathbf{v}_{n_k}]$ 包含标准正交的特征向量。对于一个选定的整数 $m$（$1 \\le m \\le n_k$），令 $\\mathbf{V}_m = [\\mathbf{v}_1,\\dots,\\mathbf{v}_m]$ 和 $\\boldsymbol{\\Lambda}_m = \\mathrm{diag}(\\lambda_1,\\dots,\\lambda_m)$。定义基因 $i$ 的投影坐标（得分）为 $\\mathbf{y}_i = \\mathbf{V}_m^\\top \\mathbf{z}_i \\in \\mathbb{R}^m$。定义距离的平方\n$$\nd_i^2 = \\sum_{j=1}^{m} \\frac{y_{i,j}^2}{\\lambda_j},\n$$\n约定任何 $\\lambda_j = 0$ 的项对总和的贡献为 $0$。当且仅当 $d_i^2$ 严格大于给定的正阈值 $\\tau$ 时，基因 $i$ 被标记为异常。\n\n数据。使用 $n_g = 10$ 个基因和 $n_k = 8$ 个四核苷酸类别，固定顺序为\n$$\n[\\text{AAAA}, \\text{AAAT}, \\text{AATA}, \\text{ATAA}, \\text{TAAA}, \\text{GCGC}, \\text{CGCG}, \\text{CCGG}].\n$$\n对于 $i \\in \\{0,\\dots,9\\}$，计数向量 $\\mathbf{c}_i$ 如下：\n- $i=0$: $[120, 110, 95, 105, 115, 4, 3, 2]$,\n- $i=1$: $[130, 100, 100, 110, 120, 3, 2, 2]$,\n- $i=2$: $[115, 120, 90, 95, 125, 5, 4, 3]$,\n- $i=3$: $[125, 115, 85, 100, 110, 6, 4, 5]$,\n- $i=4$: $[140, 105, 100, 100, 100, 8, 5, 4]$,\n- $i=5$: $[118, 112, 98, 108, 118, 7, 5, 4]$,\n- $i=6$: $[122, 118, 89, 102, 120, 6, 5, 4]$,\n- $i=7$: $[128, 107, 92, 106, 112, 5, 4, 4]$,\n- $i=8$: $[15, 12, 10, 9, 8, 160, 150, 155]$,\n- $i=9$: $[12, 9, 8, 7, 10, 155, 165, 150]$.\n\n测试套件。您的程序必须对以下每个参数案例执行上述检测规则，每个案例由一对参数 $(m,\\tau)$ 指定：\n- 案例 1：$(m,\\tau) = (2, 10.0)$，\n- 案例 2：$(m,\\tau) = (2, 10^{-6})$，\n- 案例 3：$(m,\\tau) = (2, 10^{9})$。\n\n数值细节。所有计算均在实数算术中进行。对于特征值 $\\lambda_j$，在计算 $d_i^2$ 时，仅使用那些严格大于绝对容差 $\\varepsilon = 10^{-12}$ 的值；任何 $\\lambda_j \\le \\varepsilon$ 对总和的贡献为 $0$。报告被标记基因的索引时必须使用从零开始的索引，并且在每个案例中必须按严格递增的顺序排序。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素对应一个案例，是该案例中被标记基因索引的列表。格式必须是严格的单行，不含空格，例如，\"[[a,b],[c,d,e],[]]\"，其中 $a,b,c,d,e$ 是整数。", "solution": "所提出的问题是计算生物学领域，特别是比较基因组学子领域中一个有效且定义明确的练习。它要求实现一个统计异常检测算法，以识别可能通过水平基因转移获得的基因。其基本前提——与宿主基因组的本地基因相比，水平转移的基因表现出非典型的核苷酸组成——是生物信息学中用于此目的的既定原则。指定的方法是主成分分析（PCA）的标准应用，这是一种用于分析多变量数据的稳健技术。问题提供了所有必要的数据、参数和一个清晰、明确的数学公式。因此，直接求解是可行且合理的。\n\n求解过程遵循以下正式步骤：\n\n1.  **数据归一化**：每个基因的四核苷酸原始计数（由向量 $\\mathbf{c}_i \\in \\mathbb{N}_0^{n_k}$ 表示第 $i$ 个基因）与基因长度有关。为了分析独立于长度的组成特性，需将计数转换为频率。基因 $i$ 的总计数为 $N_i = \\sum_{j=0}^{n_k-1} c_{i,j}$。然后计算频率向量 $\\mathbf{f}_i \\in \\mathbb{R}^{n_k}$，其元素为 $f_{i,j} = c_{i,j} / N_i$。这确保每个基因都由一个分量之和为1的向量表示，从而将所有基因置于可比较的尺度上。\n\n2.  **数据中心化**：通过减去平均频率向量 $\\boldsymbol{\\mu} = \\frac{1}{n_g}\\sum_{i=0}^{n_g-1} \\mathbf{f}_i$，对频率向量数据集 $\\{\\mathbf{f}_i\\}_{i=0}^{n_g-1}$ 进行中心化处理。此变换产生一组中心化向量 $\\mathbf{z}_i = \\mathbf{f}_i - \\boldsymbol{\\mu}$。现在，每个向量 $\\mathbf{z}_i$ 代表基因 $i$ 的组成与整个基因组样本平均组成的偏差。集合 $\\{\\mathbf{z}_i\\}$ 的均值为零向量。\n\n3.  **主成分分析**：该方法的核心是识别中心化数据中的主要变异轴。这通过计算经验样本协方差矩阵 $\\boldsymbol{\\Sigma} = \\frac{1}{n_g - 1} \\sum_{i=0}^{n_g-1} \\mathbf{z}_i \\mathbf{z}_i^\\top$ 来实现。对此实对称矩阵进行特征分解 $\\boldsymbol{\\Sigma} = \\mathbf{V}\\boldsymbol{\\Lambda}\\mathbf{V}^\\top$，得到主成分。正交矩阵 $\\mathbf{V}$ 的列是特征向量 $\\mathbf{v}_j$，它们定义了主轴的方向。$\\boldsymbol{\\Lambda}$ 的对角线元素，即特征值 $\\lambda_j$，表示数据在相应特征向量上投影的方差。特征值按降序排列，$\\lambda_1 \\ge \\lambda_2 \\ge \\dots \\ge \\lambda_{n_k} \\ge 0$，因此 $\\mathbf{v}_1$ 对应于最大方差的方向。\n\n4.  **降维**：分析集中于由前 $m$ 个主成分张成的子空间，这些主成分捕获了数据集中最显著的方差。每个中心化数据向量 $\\mathbf{z}_i$ 被投影到这个子空间上，以获得一个得分向量 $\\mathbf{y}_i = \\mathbf{V}_m^\\top \\mathbf{z}_i \\in \\mathbb{R}^m$，其中 $\\mathbf{V}_m = [\\mathbf{v}_1, \\dots, \\mathbf{v}_m]$。得分向量的第 $j$ 个分量 $y_{i,j} = \\mathbf{v}_j^\\top \\mathbf{z}_i$ 量化了基因 $i$ 与均值的偏差在第 $j$ 个主变异轴上的一致程度。\n\n5.  **异常得分计算**：为了量化每个基因的异常程度，在降维后的 $m$ 维空间中计算一个距离度量。指定的平方距离为 $d_i^2 = \\sum_{j=1}^{m} \\frac{y_{i,j}^2}{\\lambda_j}$。这是投影点到原点的马氏距离的平方。通过将每个平方得分 $y_{i,j}^2$ 除以其对应的方差 $\\lambda_j$，该距离被归一化。这创建了一个尺度不变的度量，衡量一个基因沿每个主轴偏离组成均值的标准差倍数。对于特征值 $\\lambda_j$ 实际上为零（即 $\\le \\varepsilon=10^{-12}$）的项，会从总和中排除，以防止数值不稳定，并承认在这些维度上没有变异。\n\n6.  **分类规则**：最后，如果一个基因 $i$ 的异常得分 $d_i^2$ 严格大于预定义的正阈值 $\\tau$，则该基因被标记为异常。这为识别具有与基因组范式在统计上存在显著差异的组成模式的基因提供了一个清晰、量化的标准。对每一对指定的参数 $(m, \\tau)$ 执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the HGT detection problem by implementing the specified\n    multivariate statistical analysis.\n    \"\"\"\n    # Define constants and data from the problem statement.\n    n_g = 10\n    n_k = 8\n    epsilon = 1e-12\n\n    # Gene count vectors c_i\n    counts = np.array([\n        [120, 110, 95, 105, 115, 4, 3, 2],    # Gene 0\n        [130, 100, 100, 110, 120, 3, 2, 2],    # Gene 1\n        [115, 120, 90, 95, 125, 5, 4, 3],    # Gene 2\n        [125, 115, 85, 100, 110, 6, 4, 5],    # Gene 3\n        [140, 105, 100, 100, 100, 8, 5, 4],    # Gene 4\n        [118, 112, 98, 108, 118, 7, 5, 4],    # Gene 5\n        [122, 118, 89, 102, 120, 6, 5, 4],    # Gene 6\n        [128, 107, 92, 106, 112, 5, 4, 4],    # Gene 7\n        [15, 12, 10, 9, 8, 160, 150, 155], # Gene 8\n        [12, 9, 8, 7, 10, 155, 165, 150]  # Gene 9\n    ], dtype=float)\n\n    # Test cases (m, tau)\n    test_cases = [\n        (2, 10.0),\n        (2, 1e-6),\n        (2, 1e9)\n    ]\n\n    # --- Step 1: Calculate Frequency Vectors ---\n    # N_i: total counts for each gene\n    total_counts = counts.sum(axis=1)\n    # f_i,j = c_i,j / N_i\n    frequencies = counts / total_counts[:, np.newaxis]\n\n    # --- Step 2: Center the Data ---\n    # mu: mean frequency vector\n    mean_freq = frequencies.mean(axis=0)\n    # z_i = f_i - mu\n    centered_vectors = frequencies - mean_freq\n\n    # --- Step 3: P.C.A. - Covariance and Eigendecomposition ---\n    # Sigma: sample covariance matrix. ddof=1 for division by (n_g - 1).\n    # rowvar=False because observations (genes) are rows, variables are columns.\n    cov_matrix = np.cov(frequencies, rowvar=False, ddof=1)\n    \n    # Eigendecomposition of the symmetric covariance matrix\n    eigenvalues, eigenvectors = np.linalg.eigh(cov_matrix)\n\n    # Sort eigenvalues and eigenvectors in descending order\n    sorted_indices = np.argsort(eigenvalues)[::-1]\n    sorted_eigenvalues = eigenvalues[sorted_indices]\n    sorted_eigenvectors = eigenvectors[:, sorted_indices]\n\n    all_results = []\n    \n    for m, tau in test_cases:\n        # --- Step 4: Project Data onto Principal Components ---\n        # V_m: matrix of first m eigenvectors\n        V_m = sorted_eigenvectors[:, :m]\n        \n        # y_i = V_m^T * z_i, calculated for all genes at once\n        # Resulting 'scores' matrix has shape (n_g, m)\n        scores = centered_vectors @ V_m\n\n        # --- Step 5: Calculate Anomaly Distances ---\n        # lambdas_m: first m eigenvalues\n        lambdas_m = sorted_eigenvalues[:m]\n        \n        # Calculate inverse eigenvalues, handling values below epsilon\n        inv_lambdas_m = np.array([1.0/val if val > epsilon else 0.0 for val in lambdas_m])\n\n        # d_i^2 = sum_{j=1 to m} (y_i,j^2 / lambda_j)\n        # This is a dot product of squared scores with inverse eigenvalues\n        d_squared = (scores**2) @ inv_lambdas_m\n\n        # --- Step 6: Flag Anomalous Genes ---\n        # Find indices where d_i^2 > tau\n        flagged_indices = np.where(d_squared > tau)[0].tolist()\n        \n        # The problem requires indices to be sorted, which np.where guarantees.\n        all_results.append(flagged_indices)\n        \n    # Final print statement in the exact required format: [[...],[...],[...]]\n    # Manually construct the string to avoid spaces introduced by str() or repr().\n    inner_parts = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output_string = f\"[{','.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2385117"}, {"introduction": "仅依赖序列组成的方法有时会失效，尤其是当供体和受体生物关系密切时。本练习介绍了一种基于系统发育学的方法，该方法不依赖于序列组成，而是分析基因在不同物种中的存在与否模式（即谱系分布）。通过应用最大简约原则，我们可以推断是单个基因获得事件（HGT）还是多次独立的基因丢失事件，更能合理解释当前观察到的基因分布模式。[@problem_id:2385158]", "problem": "考虑一个包含分类单元 $A,B,C,D,E,F,G,H$ 的有根、二分叉的物种树，其拓扑结构如下：根节点分裂为两个进化支，$X$ 和 $Y$。进化支 $X$ 进一步分裂为带有叶节点 $(A,B)$ 和 $(C,D)$ 的两个子进化支，进化支 $Y$ 进一步分裂为带有叶节点 $(E,F)$ 和 $(G,H)$ 的两个子进化支。因此，该拓扑结构是与 Newick 描述 $(((A,B),(C,D)),((E,F),(G,H)))$ 相对应的已解析二叉树，其根节点位于 $X$ 和 $Y$ 的分叉处。\n\n您调查了一个参与芳香族化合物降解的、由 $m$ 个基因组成的操纵子，发现在分类单元 $E$ 和 $F$ 中存在该操纵子（所有 $m$ 个基因共线且共现），而在分类单元 $A,B,C,D,G,H$ 中缺失（未检测到操縱子基因）。假设以下兩種假說：\n\n- 假说 $\\mathrm{L}$（以丢失为主的垂直遗传）：该操纵子存在于所有八个分类单元的最近共同祖先中，此后只能在任何分支上作为一个整体模块丢失（不允许水平获得）。在此假说下，简约性分数是解释给定有根物种树上观察到的存在/缺失模式所需的最少模块丢失事件数。\n\n- 假说 $\\mathrm{T}$（单次水平基因转移事件）：该操纵子在所有八个分类单元的最近共同祖先中缺失，它可以通过最多一次水平基因转移事件被引入到物种树的单个分支中；引入后，它被垂直遗传，并可能在任何分支上作为一个整体模块丢失。在此假说下，简约性分数是事件的总数，将单次水平转移计为一个事件，每次后续的模块丢失也计为一个事件。\n\n使用最大简约性（MP）原则，选择在每个假说的约束条件下使进化事件总数最小化的情景，计算 $\\mathrm{T}$ 相对于 $\\mathrm{L}$ 的简约性优势，定义为\n$$\n\\Delta \\;=\\; E_{\\mathrm{L}} \\;-\\; E_{\\mathrm{T}},\n$$\n其中 $E_{\\mathrm{L}}$ 和 $E_{\\mathrm{T}}$ 分别是假说 $\\mathrm{L}$ 和 $\\mathrm{T}$ 下的最小事件数。请用一个整数表示您的最终答案。无需四舍五入。", "solution": "该问题要求计算两个相互竞争的进化假说的简约性分数，然后确定其中一个相对于另一个的简约性优势。研究对象是一个性状状态（操縱子的存在/缺失）在给定的固定物种树上的分布。最大简约性原则规定，最优的进化情景是需要最少事件数的情景。让我们进行系统的验证和分析。\n\n首先，提取并验证问题的已知条件。\n物种树的拓扑结构由 Newick 字符串 $(((A,B),(C,D)),((E,F),(G,H)))$ 给出。这代表一个有根的二分叉树。我们将根节点表示为 $R$。根节点分裂成两个进化支，我们标记为 $X$ 和 $Y$。进化支 $X$ 是 $\\{A,B,C,D\\}$ 的最近共同祖先 (MRCA)，进化支 $Y$ 是 $\\{E,F,G,H\\}$ 的 MRCA。内部节点是其各自后代叶节点的 MRCA：节点 $AB$ 对应 $\\{A,B\\}$，节点 $CD$ 对应 $\\{C,D\\}$，节点 $EF$ 对应 $\\{E,F\\}$，节点 $GH$ 对应 $\\{G,H\\}$。\n\n性状状态是操縱子的存在或缺失。我们用状态 $1$ 表示存在，用状态 $0$ 表示缺失。\n在葉節點（分類單元）觀察到的狀態是：\n- $S(A)=0, S(B)=0, S(C)=0, S(D)=0$\n- $S(E)=1, S(F)=1$\n- $S(G)=0, S(H)=0$\n\n该问题具有科学依据，提法明确且客观。它利用了计算系统发育学中的标准概念，如简约性、水平基因转移和在特定树结构上的基因丢失。每个假说的约束条件都清晰定义，并提供了足够的信息来为每个假说计算唯一的得分。因此，该问题是有效的，我们可以着手求解。\n\n我们将分别分析每个假说，以找出解释观察到的操纵子存在/缺失模式所需的最少进化事件数。\n\n对假说 $\\mathrm{L}$（以丢失为主的垂直遗传）的分析：\n在此假说下，操縱子存在于所有八个分类单元的最近共同祖先中。这意味着树的根节点状态为 $1$，即 $S(R)=1$。只允许丢失事件（$1 \\to 0$）；不允许获得事件（$0 \\to 1$）。简约性分数 $E_{\\mathrm{L}}$ 是所需的最少丢失事件数。\n\n为了重建内部节点的状态，我们使用 Fitch 算法，并受“无获得”规则的约束。\n1. 操纵子存在于分类单元 $E$ 和 $F$ 中，所以 $S(E)=1$ 且 $S(F)=1$。为了使该状态从根节点遗传而来，从根到 $E$ 和 $F$ 的路径上的所有节点都必须是状态 $1$。该路径为 $R \\to Y \\to EF$。因此，我们必须有 $S(R)=1$、$S(Y)=1$ 和 $S(EF)=1$。前提 $S(R)=1$ 得到满足。这条路径上没有发生事件。\n\n2. 操纵子在分类单元 $A,B,C,D$ 中缺失。这些分类单元的 MRCA 是节点 $X$。由于根节点 $R$ 的状态是 $1$，而 $X$ 的所有后代的状态都是 $0$，因此在连接 $R$ 和 $X$ 的分支上必然发生了一次丢失事件。这构成了一个事件。节点 $X$ 的状态变为 $0$，即 $S(X)=0$。然后，这个状态 $0$ 被节点 $AB$、$CD$ 以及叶节点 $A,B,C,D$ 继承，没有发生更多事件。这是对该进化支中缺失现象的最简约解释。到目前为止的事件数：$1$。\n\n3. 操纵子在分类单元 $G$ 和 $H$ 中缺失。这些分类单元的 MRCA 是节点 $GH$。我们已经确定节点 $Y$（$GH$ 的父节点）的状态为 $1$。为了解释 $G$ 和 $H$ 中的缺失，在连接 $Y$ 和 $GH$ 的分支上必然发生了一次丢失事件。这构成了第二个事件。节点 $GH$ 的状态变为 $0$，即 $S(GH)=0$。然后，这个状态 $0$ 被叶节点 $G$ 和 $H$ 继承，没有发生更多事件。新增事件数：$1$。\n\n将假说 $\\mathrm{L}$ 下的事件相加，我们在分支 $R \\to X$ 上有一次丢失，在分支 $Y \\to GH$ 上有一次丢失。\n因此，最小事件数为 $E_{\\mathrm{L}} = 1 + 1 = 2$。\n\n对假说 $\\mathrm{T}$（单次水平基因转移事件）的分析：\n在此假说下，操縱子在最近共同祖先中缺失，所以 $S(R)=0$。在单个分支上只允许发生一次水平基因转移（HGT）事件（$0 \\to 1$）。随后的进化允许垂直遗传和模块丢失事件（$1 \\to 0$）。简约性分数 $E_{\\mathrm{T}}$ 是 HGT 事件和任何后续丢失事件的总和。\n\n操纵子存在于 $E$ 和 $F$ 中。必须用一次 HGT 事件来解释这种存在。为了使 $E$ 和 $F$ 在一次 HGT 后都能垂直遗传该操縱子，转移必须发生在一个作为进化支 $(E,F)$ 祖先的分支上。HGT 事件可能发生的分支有：\n- 通往节点 $EF$（$E$ 和 $F$ 的 MRCA）的分支。\n- 通往节点 $Y$（$EF$ 的父节点）的分支。\n向末端分支（例如，通往 $E$ 的分支）进行 HGT 无法用单次 HGT 事件解释 $F$ 中的存在，因此不予考虑。\n\n让我们评估每种可能的 HGT 位置的简约性分数：\n\n情况 1：HGT 发生在通往节点 $EF$ 的分支上。\n节点 $EF$ 的父节点是节点 $Y$。从根开始的节点状态如下：$S(R)=0$。这个状态被其子节点继承，所以 $S(X)=0$ 且 $S(Y)=0$。HGT 发生在分支 $Y \\to EF$ 上。这将以 $EF$ 为根的子树的状态从 $0$ 变为 $1$。所以，$S(EF)=1$。这是一个事件（HGT）。然后状态 $1$ 被叶节点 $E$ 和 $F$ 继承。不需要丢失事件。\n在树的其他部分，状态 $0$ 从根向下继承。$S(X)=0$ 导致 $S(A)=S(B)=S(C)=S(D)=0$。$S(Y)=0$ 导致 $S(GH)=0$，进而导致 $S(G)=S(H)=0$。所有观察到的状态都得到了解释。\n此情景中的总事件数为 $1$（HGT）。\n\n情况 2：HGT 发生在通往节点 $Y$ 的分支上。\n节点 $Y$ 的父节点是根节点 $R$。HGT 发生在分支 $R \\to Y$ 上。$Y$ 的状态变为 $1$，即 $S(Y)=1$。这是一个事件（HGT）。\n由于 $S(R)=0$，根的另一个子节点 $X$ 继承了状态 $0$，因此其所有后代（$A,B,C,D$）也都是状态 $0$。树的这部分没有事件发生。\n现在考虑以 $Y$ 为根的子树，其中 $S(Y)=1$。\n- 为了解释 $S(E)=1$ 和 $S(F)=1$，节点 $EF$ 的状态必须为 $1$。该状态从 $Y$ 继承而来，没有发生丢失事件。\n- 为了解释 $S(G)=0$ 和 $S(H)=0$，必须在从 $Y$ 到它们 MRCA (节点 $GH$) 的分支上发生一次丢失事件。所以，$S(GH)$ 变为 $0$。这是第二个事件（一次丢失）。\n此情景中的总事件数为 $1$（HGT）$+ 1$（丢失）$= 2$。\n\n根据最大简约性原则，我们必须为假说 $\\mathrm{T}$ 选择使事件数最小化的情景。比较情况 1（分数 $1$）和情况 2（分数 $2$），最小分数为 $1$。\n因此，假说 $\\mathrm{T}$ 的简约性分数为 $E_{\\mathrm{T}} = 1$。这对应于一次单一的 HGT 事件，进入到通往分类单元 $E$ 和 $F$ 共同祖先的分支上。\n\n最后，我们计算假说 $\\mathrm{T}$相对于假说 $\\mathrm{L}$ 的简约性优势，定义为 $\\Delta = E_{\\mathrm{L}} - E_{\\mathrm{T}}$。\n代入计算出的值：\n$$\n\\Delta = 2 - 1 = 1\n$$\n简约性优势为 $1$。这表明，涉及单次定向水平转移事件的假说，比祖先存在然后经历多次丢失来解释观察到的操纵子分布的假说更为简约。", "answer": "$$\\boxed{1}$$", "id": "2385158"}, {"introduction": "在生物信息学实践中，最可靠的HGT预测往往来自于整合多种独立的证据。这个高级练习将向你展示如何使用贝叶斯框架来量化地实现这种整合。你将推导并计算一个对数优势比分数，该分数综合考量了来自序列组成、系统发育和基因组位置（共线性）的证据，从而对一个基因是否为HGT做出更稳健的判断。[@problem_id:2385114]", "problem": "您正在设计一个原则性的综合评分，用于检测原核生物基因组中的水平基因转移（HGT）。对于一个给定的基因，您观察到三种独立的、以假设为条件的证据类型：一个成分偏差幅度 $x \\in [0,\\infty)$（例如，鸟嘌呤-胞嘧啶（GC）含量和寡核苷酸使用频率的偏差），一个系统发育不一致性得分 $y \\in (0,1)$（例如，一个标准化的 Robinson–Foulds (RF) 距离），以及一个同线性破坏计数 $k \\in \\{0,1,2,\\dots\\}$（例如，保守邻域中的断裂次数）。\n\n假设存在以下生成模型。令 $H$ 表示基因是水平转移的假设，令 $N$ 表示基因不是水平转移的假设。先验概率为 $\\Pr(H)=\\pi_{H}$ 和 $\\Pr(N)=\\pi_{N}$，且 $\\pi_{H}+\\pi_{N}=1$。在以 $H$ 或 $N$ 为条件下，这些证据变量是独立的，其分布如下：\n- 成分偏差 $x$ 在假设 $H$ 下服从速率为 $\\lambda_{H}$ 的指数分布，在假设 $N$ 下服从速率为 $\\lambda_{N}$ 的指数分布，其密度函数为 $f(x\\mid\\lambda)=\\lambda \\exp(-\\lambda x)$，其中 $x\\ge 0$。\n- 系统发育不一致性 $y$ 在假设 $H$ 下服从参数为 $(\\alpha_{H},\\beta_{H})$ 的 Beta 分布，在假设 $N$ 下服从参数为 $(\\alpha_{N},\\beta_{N})$ 的 Beta 分布，其密度函数为 $g(y\\mid\\alpha,\\beta)=\\dfrac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)}\\, y^{\\alpha-1}(1-y)^{\\beta-1}$，其中 $y\\in(0,1)$，$\\Gamma(\\cdot)$ 是伽马函数。\n- 同线性破坏计数 $k$ 在假设 $H$ 下服从均值为 $\\mu_{H}$ 的泊松分布，在假设 $N$ 下服从均值为 $\\mu_{N}$ 的泊松分布，其概率质量函数为 $h(k\\mid\\mu)=\\exp(-\\mu)\\mu^{k}/k!$，其中 $k\\in\\{0,1,2,\\dots\\}$。\n\n将得分 $S_{HGT}(x,y,k)$ 定义为在给定 $(x,y,k)$ 的情况下，支持 $H$ 而非 $N$ 的后验对数优势比，即\n$$\nS_{HGT}(x,y,k) \\equiv \\ln\\!\\left(\\frac{\\Pr(H\\mid x,y,k)}{\\Pr(N\\mid x,y,k)}\\right).\n$$\n在上述模型下，根据 $(x,y,k)$ 和各项参数，推导 $S_{HGT}(x,y,k)$ 的闭式解析表达式。然后，使用参数值 $\\pi_{H}=0.1$, $\\pi_{N}=0.9$, $\\lambda_{H}=0.8$, $\\lambda_{N}=2.0$, $(\\alpha_{H},\\beta_{H})=(5,2)$, $(\\alpha_{N},\\beta_{N})=(2,5)$, $\\mu_{H}=3.5$, $\\mu_{N}=0.8$ 和观测到的证据 $(x,y,k)=(1.2,0.7,4)$，计算 $S_{HGT}(x,y,k)$ 的值。\n\n提供您计算的 $S_{HGT}(1.2,0.7,4)$ 的最终数值结果，四舍五入到四位有效数字。不需要单位，答案是一个实数。", "solution": "问题陈述经验证有效。它具有科学依据，问题设定良好，客观、完整且一致。它描述了一个标准的贝叶斯分类问题，应用于检测水平基因转移——这是计算生物学中一个成熟的课题。所有必需的定义、分布和参数均已提供，从而可以得出直接而明确的解决方案。我们将继续进行推导和计算。\n\n问题要求推导后验对数优势比得分 $S_{HGT}(x,y,k)$，并针对一组特定证据进行评估。该得分定义为：\n$$\nS_{HGT}(x,y,k) \\equiv \\ln\\left(\\frac{\\Pr(H\\mid x,y,k)}{\\Pr(N\\mid x,y,k)}\\right)\n$$\n其中 $H$ 是水平转移的假设，$N$ 是零假设。\n\n我们首先将贝叶斯定理应用于后验概率 $\\Pr(H\\mid x,y,k)$ 和 $\\Pr(N\\mid x,y,k)$。\n$$\n\\Pr(H\\mid x,y,k) = \\frac{\\Pr(x,y,k\\mid H)\\Pr(H)}{\\Pr(x,y,k)}\n$$\n$$\n\\Pr(N\\mid x,y,k) = \\frac{\\Pr(x,y,k\\mid N)\\Pr(N)}{\\Pr(x,y,k)}\n$$\n将这些代入 $S_{HGT}$ 的定义中，分母中的证据项 $\\Pr(x,y,k)$ 会被消去：\n$$\nS_{HGT}(x,y,k) = \\ln\\left(\\frac{\\Pr(x,y,k\\mid H)\\Pr(H)}{\\Pr(x,y,k\\mid N)\\Pr(N)}\\right)\n$$\n利用对数的性质，我们可以将其分离为对数似然比和先验对数优势比：\n$$\nS_{HGT}(x,y,k) = \\ln\\left(\\frac{\\Pr(x,y,k\\mid H)}{\\Pr(x,y,k\\mid N)}\\right) + \\ln\\left(\\frac{\\Pr(H)}{\\Pr(N)}\\right)\n$$\n问题陈述指出，证据变量 $x$、$y$ 和 $k$ 在给定假设的条件下是独立的。这使我们能够对联合条件概率进行因式分解：\n$$\n\\Pr(x,y,k\\mid H) = \\Pr(x\\mid H)\\Pr(y\\mid H)\\Pr(k\\mid H) = f(x\\mid H)g(y\\mid H)h(k\\mid H)\n$$\n$$\n\\Pr(x,y,k\\mid N) = \\Pr(x\\mid N)\\Pr(y\\mid N)\\Pr(k\\mid N) = f(x\\mid N)g(y\\mid N)h(k\\mid N)\n$$\n因此，对数似然比项可以分解为每个证据的对数似然比之和：\n$$\n\\ln\\left(\\frac{\\Pr(x,y,k\\mid H)}{\\Pr(x,y,k\\mid N)}\\right) = \\ln\\left(\\frac{f(x\\mid H)}{f(x\\mid N)}\\right) + \\ln\\left(\\frac{g(y\\mid H)}{g(y\\mid N)}\\right) + \\ln\\left(\\frac{h(k\\mid H)}{h(k\\mid N)}\\right)\n$$\n我们现在推导这三项中的每一项。\n\n1.  **成分偏差 ($x$)**: 分布为指数分布。\n    $f(x\\mid H) = \\lambda_{H} \\exp(-\\lambda_{H} x)$ 且 $f(x\\mid N) = \\lambda_{N} \\exp(-\\lambda_{N} x)$。\n    对数似然比为：\n    $$\n    \\ln\\left(\\frac{\\lambda_{H} \\exp(-\\lambda_{H} x)}{\\lambda_{N} \\exp(-\\lambda_{N} x)}\\right) = \\ln\\left(\\frac{\\lambda_{H}}{\\lambda_{N}}\\right) - \\lambda_{H}x + \\lambda_{N}x = \\ln\\left(\\frac{\\lambda_{H}}{\\lambda_{N}}\\right) - (\\lambda_{H} - \\lambda_{N})x\n    $$\n\n2.  **系统发育不一致性 ($y$)**: 分布为 Beta 分布。令 Beta 函数为 $B(\\alpha,\\beta) = \\frac{\\Gamma(\\alpha)\\Gamma(\\beta)}{\\Gamma(\\alpha+\\beta)}$。密度函数为 $g(y\\mid\\alpha,\\beta) = \\frac{1}{B(\\alpha,\\beta)} y^{\\alpha-1}(1-y)^{\\beta-1}$。\n    $g(y\\mid H)$ 是 Beta$(\\alpha_{H},\\beta_{H})$ 分布，$g(y\\mid N)$ 是 Beta$(\\alpha_{N},\\beta_{N})$ 分布。\n    对数似然比为：\n    $$\n    \\ln\\left(\\frac{\\frac{1}{B(\\alpha_{H},\\beta_{H})} y^{\\alpha_{H}-1}(1-y)^{\\beta_{H}-1}}{\\frac{1}{B(\\alpha_{N},\\beta_{N})} y^{\\alpha_{N}-1}(1-y)^{\\beta_{N}-1}}\\right) = \\ln\\left(\\frac{B(\\alpha_{N},\\beta_{N})}{B(\\alpha_{H},\\beta_{H})}\\right) + (\\alpha_{H}-1)\\ln(y) + (\\beta_{H}-1)\\ln(1-y) - [(\\alpha_{N}-1)\\ln(y) + (\\beta_{N}-1)\\ln(1-y)]\n    $$\n    $$\n    = \\ln\\left(\\frac{B(\\alpha_{N},\\beta_{N})}{B(\\alpha_{H},\\beta_{H})}\\right) + (\\alpha_{H}-\\alpha_{N})\\ln(y) + (\\beta_{H}-\\beta_{N})\\ln(1-y)\n    $$\n\n3.  **同线性破坏计数 ($k$)**: 分布为泊松分布。\n    $h(k\\mid H) = \\frac{\\exp(-\\mu_{H})\\mu_{H}^{k}}{k!}$ 且 $h(k\\mid N) = \\frac{\\exp(-\\mu_{N})\\mu_{N}^{k}}{k!}$。\n    对数似然比为：\n    $$\n    \\ln\\left(\\frac{\\frac{\\exp(-\\mu_{H})\\mu_{H}^{k}}{k!}}{\\frac{\\exp(-\\mu_{N})\\mu_{N}^{k}}{k!}}\\right) = \\ln\\left(\\frac{\\exp(-\\mu_{H})\\mu_{H}^{k}}{\\exp(-\\mu_{N})\\mu_{N}^{k}}\\right) = (-\\mu_{H} + k\\ln(\\mu_{H})) - (-\\mu_{N} + k\\ln(\\mu_{N}))\n    $$\n    $$\n    = -(\\mu_{H}-\\mu_{N}) + k\\ln\\left(\\frac{\\mu_{H}}{\\mu_{N}}\\right)\n    $$\n\n结合所有项，得分 $S_{HGT}(x,y,k)$ 的完整解析表达式为：\n$$\nS_{HGT}(x,y,k) = \\ln\\left(\\frac{\\pi_{H}}{\\pi_{N}}\\right) + \\ln\\left(\\frac{\\lambda_{H}}{\\lambda_{N}}\\right) - (\\lambda_{H} - \\lambda_{N})x + \\ln\\left(\\frac{B(\\alpha_{N},\\beta_{N})}{B(\\alpha_{H},\\beta_{H})}\\right) + (\\alpha_{H}-\\alpha_{N})\\ln(y) + (\\beta_{H}-\\beta_{N})\\ln(1-y) - (\\mu_{H}-\\mu_{N}) + k\\ln\\left(\\frac{\\mu_{H}}{\\mu_{N}}\\right)\n$$\n这就是所求的闭式表达式。\n\n现在，我们使用给定的参数和数据来评估这个表达式。\n参数：$\\pi_{H}=0.1, \\pi_{N}=0.9, \\lambda_{H}=0.8, \\lambda_{N}=2.0, (\\alpha_{H},\\beta_{H})=(5,2), (\\alpha_{N},\\beta_{N})=(2,5), \\mu_{H}=3.5, \\mu_{N}=0.8$。\n数据：$(x,y,k)=(1.2,0.7,4)$。\n\n我们计算得分的每个组成部分：\n- **先验对数优势比**：\n  $$ \\ln\\left(\\frac{\\pi_{H}}{\\pi_{N}}\\right) = \\ln\\left(\\frac{0.1}{0.9}\\right) = \\ln\\left(\\frac{1}{9}\\right) = -\\ln(9) \\approx -2.1972 $$\n- **成分项**：\n  $$ \\ln\\left(\\frac{0.8}{2.0}\\right) - (0.8 - 2.0) \\times 1.2 = \\ln(0.4) - (-1.2) \\times 1.2 = \\ln(0.4) + 1.44 \\approx -0.9163 + 1.44 = 0.5237 $$\n- **系统发育项**：首先，我们计算常数部分。\n  $B(\\alpha_{H},\\beta_{H}) = B(5,2) = \\frac{\\Gamma(5)\\Gamma(2)}{\\Gamma(5+2)} = \\frac{4!1!}{6!} = \\frac{24}{720} = \\frac{1}{30}$。\n  $B(\\alpha_{N},\\beta_{N}) = B(2,5) = \\frac{\\Gamma(2)\\Gamma(5)}{\\Gamma(2+5)} = \\frac{1!4!}{6!} = \\frac{24}{720} = \\frac{1}{30}$。\n  因此，$\\ln\\left(\\frac{B(\\alpha_{N},\\beta_{N})}{B(\\alpha_{H},\\beta_{H})}\\right) = \\ln(1) = 0$。\n  变量部分为：\n  $$ (\\alpha_{H}-\\alpha_{N})\\ln(y) + (\\beta_{H}-\\beta_{N})\\ln(1-y) = (5-2)\\ln(0.7) + (2-5)\\ln(1-0.7) = 3\\ln(0.7) - 3\\ln(0.3) = 3\\ln\\left(\\frac{0.7}{0.3}\\right) = 3\\ln\\left(\\frac{7}{3}\\right) \\approx 3 \\times 0.8473 = 2.5419 $$\n- **同线性项**：\n  $$ -(\\mu_{H}-\\mu_{N}) + k\\ln\\left(\\frac{\\mu_{H}}{\\mu_{N}}\\right) = -(3.5 - 0.8) + 4\\ln\\left(\\frac{3.5}{0.8}\\right) = -2.7 + 4\\ln(4.375) \\approx -2.7 + 4 \\times 1.4760 = -2.7 + 5.9040 = 3.2040 $$\n\n最后，我们将所有分量相加，得到总分：\n$$\nS_{HGT}(1.2, 0.7, 4) \\approx -2.1972 + 0.5237 + 2.5419 + 3.2040\n$$\n$$\nS_{HGT}(1.2, 0.7, 4) \\approx 4.0724\n$$\n使用更高精度进行计算得出：\n$\\ln(1/9) \\approx -2.19722$\n$\\ln(0.4) + 1.44 \\approx 0.52371$\n$3\\ln(7/3) \\approx 2.54189$\n$-2.7 + 4\\ln(4.375) \\approx 3.20385$\n总和：$-2.19722 + 0.52371 + 2.54189 + 3.20385 = 4.07223$。\n四舍五入到四位有效数字，得到 $4.072$。", "answer": "$$\n\\boxed{4.072}\n$$", "id": "2385114"}]}