{"hands_on_practices": [{"introduction": "在群体遗传学研究中，我们获得的原始数据通常是二倍体个体的非定相（unphased）基因型数据。这意味着我们虽然知道某个位点上的两个等位基因，却不清楚它们如何排列在两条同源染色体上。例如，对于一个双杂合子（Aa, Bb），我们无法直接判断其单倍型组合是 $AB/ab$ 还是 $Ab/aB$。[@problem_id:2401311] 这个实践将指导你从第一性原理出发，实现经典的期望最大化（EM）算法，以从这些非定相的基因型数据中推断出潜在的单倍型频率，这是后续连锁不平衡分析的基础。", "problem": "给定一个包含多个个体样本的、关于两个双等位基因座的未定相二倍体基因型计数数据。这两个基因座分别有等位基因 $A/a$ 和 $B/b$。单倍型是指同一条染色体上两个基因座的等位基因的有序组合（例如，$AB$、$Ab$、$aB$、$ab$）。每个个体携带两个单倍型（构成一个二倍单倍型），而每个基因座的未定相基因型仅记录无序的等位基因计数：第一个基因座为 $AA$、$Aa$ 或 $aa$，第二个基因座为 $BB$、$Bb$ 或 $bb$。$3 \\times 3$ 的基因型计数表 $g_{ij}$ 中，使用 $i \\in \\{0,1,2\\}$ 表示第一个基因座上等位基因 $A$ 的计数（$aa$、$Aa$、$AA$），使用 $j \\in \\{0,1,2\\}$ 表示第二个基因座上等位基因 $B$ 的计数（$bb$、$Bb$、$BB$）。$(1,1)$ 单元格是双杂合子 $(Aa,Bb)$，其相位不明确。\n\n从以下基本假设出发：(i) 在一个随机交配的二倍体群体中，单倍型被独立抽样以形成二倍单倍型；(ii) 该样本是一组独立的个体。观测到的 $3 \\times 3$ 基因型计数表的似然是四个单倍型频率 $p_{AB}$、$p_{Ab}$、$p_{aB}$、$p_{ab}$ 的函数，这些频率为非负数且总和为 $1$。实现期望最大化（EM）算法，以根据未定相计数找到这些单倍型频率的最大似然估计。估算出单倍型频率后，计算连锁不平衡（LD）摘要统计量 $D = p_{AB} - p_A p_B$，其中 $p_A = p_{AB} + p_{Ab}$ 且 $p_B = p_{AB} + p_{aB}$，然后计算 $r^2 = D^2 / \\left(p_A (1 - p_A) p_B (1 - p_B)\\right)$。如果 $r^2$ 的分母为零，则定义 $r^2 = 0$。\n\n您的程序必须：\n- 根据上述假设从头开始实现 EM 算法，不依赖于针对不明确相位的封闭形式捷径。\n- 对迭代间单倍型频率的变化使用收敛容差 $\\epsilon$（例如 $\\epsilon = 10^{-10}$），并设置合理的最大迭代次数以保证终止。\n- 对于每个测试用例，返回一个包含五个浮点数的列表，顺序为 $[p_{AB}, p_{Ab}, p_{aB}, p_{ab}, r^2]$，每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件（每个用例是一个 $3 \\times 3$ 的非负整数矩阵 $g_{ij}$，按行主序排列：行 $i \\in \\{0,1,2\\}$ 对应 $aa, Aa, AA$，列 $j \\in \\{0,1,2\\}$ 对应 $bb, Bb, BB$）：\n- 用例 1（存在不明确性的一般“理想路径”）：\n  - 第 0 行：$[7, 2, 8]$\n  - 第 1 行：$[6, 20, 4]$\n  - 第 2 行：$[5, 3, 10]$\n- 用例 2（无不明确性：双杂合子数量为零）：\n  - 第 0 行：$[3, 1, 1]$\n  - 第 1 行：$[1, 0, 0]$\n  - 第 2 行：$[1, 0, 3]$\n- 用例 3（连锁平衡网格，含大量双杂合子，$N = 64$）：\n  - 第 0 行：$[4, 8, 4]$\n  - 第 1 行：$[8, 16, 8]$\n  - 第 2 行：$[4, 8, 4]$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个方括号括起来的、针对一个测试用例的逗号分隔列表，不含空格。例如：$[[x_{11},x_{12},x_{13},x_{14},x_{15}],[x_{21},x_{22},x_{23},x_{24},x_{25}],[x_{31},x_{32},x_{33},x_{34},x_{35}]]$，其中每个 $x_{ij}$ 是一个四舍五入到 $6$ 位小数的浮点数。所有概率必须以小数形式表示，而不是百分比。", "solution": "所提出的问题是计算群体遗传学中的一个标准且良构的任务：使用期望最大化（EM）算法从未定相的二倍体基因型计数中估计单倍型频率。该问题有科学依据、内部一致，并为计算唯一解提供了所有必要信息。因此，该问题被认为是有效的。\n\n问题的核心是找到四种单倍型（$AB, Ab, aB, ab$）频率的最大似然估计（MLE），我们分别将其表示为 $p_{AB}, p_{Ab}, p_{aB}, p_{ab}$。这些频率为非负数，总和为 $1$。输入数据是一个 $3 \\times 3$ 的基因型计数矩阵 $g_{ij}$，其中 $i \\in \\{0, 1, 2\\}$ 是第一个基因座上等位基因 $A$ 的计数，$j \\in \\{0, 1, 2\\}$ 是第二个基因座上等位基因 $B$ 的计数。\n\n观测到基因型计数 $\\mathbf{g} = \\{g_{ij}\\}$ 的似然由一个多项概率分布给出，其中九种双基因座基因型中每一种的概率都是单倍型频率的函数。在随机交配（即二倍单倍型水平上的 Hardy-Weinberg 平衡）的假设下，每个基因型的期望频率 $P_{ij}$ 由单倍型频率决定。例如，对应于单元格 $g_{22}$ 的基因型 $(AA,BB)$ 只能由二倍单倍型 $AB/AB$ 产生，其期望频率为 $p_{AB}^2$。大多数基因型频率可以表示为单倍型频率的简单乘积或平方项。\n\n九种基因型概率 $P_{ij}(\\mathbf{p})$ 如下：\n$$ P_{00} = p_{ab}^2 $$\n$$ P_{01} = 2 p_{aB} p_{ab} $$\n$$ P_{02} = p_{aB}^2 $$\n$$ P_{10} = 2 p_{Ab} p_{ab} $$\n$$ P_{11} = 2 p_{AB} p_{ab} + 2 p_{Ab} p_{aB} $$\n$$ P_{12} = 2 p_{AB} p_{aB} $$\n$$ P_{20} = p_{Ab}^2 $$\n$$ P_{21} = 2 p_{AB} p_{Ab} $$\n$$ P_{22} = p_{AB}^2 $$\n\n观测数据的对数似然则为：\n$$ \\ln L(\\mathbf{p} | \\mathbf{g}) = \\text{const} + \\sum_{i=0}^{2} \\sum_{j=0}^{2} g_{ij} \\ln P_{ij}(\\mathbf{p}) $$\n直接最大化此函数是复杂的，因为 $P_{11}$ 项中存在一个和，该和对应于相位不明确的双杂合子 $(Aa,Bb)$。这种基因型可由两种不同的二倍单倍型形成：$AB/ab$（连锁相或顺式相）和 $Ab/aB$（排斥相或反式相）。EM 算法非常适合处理这类涉及缺失数据的问题，此处的缺失信息是 $g_{11}$ 个体的相位。\n\nEM 算法是一个包含两个步骤的迭代过程：\n1.  **初始化**：从单倍型频率的初始估计值 $\\mathbf{p}^{(0)}$ 开始。一个稳健的选择是假设连锁平衡，此时单倍型频率是等位基因频率的乘积。等位基因频率 $p_A$ 和 $p_B$ 可以通过基因型表中的等位基因计数直接估算：\n    $$ p_A = \\frac{2\\sum_j g_{2j} + \\sum_j g_{1j}}{2N} \\quad \\text{和} \\quad p_B = \\frac{2\\sum_i g_{i2} + \\sum_i g_{i1}}{2N} $$\n    其中 $N = \\sum_{i,j} g_{ij}$ 是个体总数。初始的单倍型频率则为 $p_{AB}^{(0)} = p_A p_B$，$p_{Ab}^{(0)} = p_A(1-p_B)$，$p_{aB}^{(0)} = (1-p_A)p_B$ 和 $p_{ab}^{(0)} = (1-p_A)(1-p_B)$。\n\n2.  **期望（E-步）**：在第 $t+1$ 次迭代中，使用当前的单倍型频率估计值 $\\mathbf{p}^{(t)}$，我们计算构成 $g_{11}$ 个双杂合子的两种未观测到的二倍单倍型的期望计数。一个双杂合子具有顺式相 ($AB/ab$) 的条件概率是：\n    $$ \\pi_{cis} = P(AB/ab | AaBb, \\mathbf{p}^{(t)}) = \\frac{2 p_{AB}^{(t)} p_{ab}^{(t)}}{2 p_{AB}^{(t)} p_{ab}^{(t)} + 2 p_{Ab}^{(t)} p_{aB}^{(t)}} = \\frac{p_{AB}^{(t)} p_{ab}^{(t)}}{p_{AB}^{(t)} p_{ab}^{(t)} + p_{Ab}^{(t)} p_{aB}^{(t)}} $$\n    顺式相个体的期望计数是 $E[g_{11,cis}] = g_{11} \\times \\pi_{cis}$。类似地，反式相个体 ($Ab/aB$) 的期望计数是 $E[g_{11,trans}] = g_{11} \\times (1 - \\pi_{cis})$。\n\n3.  **最大化（M-步）**：有了 E 步的期望计数，我们实际上就有了“完整”数据。新的单倍型频率最大似然估计 $\\mathbf{p}^{(t+1)}$ 通过简单地计算每种单倍型的期望数量并除以单倍型总数 $2N$ 来获得。期望的单倍型计数 ($h$) 为：\n    $$ h_{AB} = 2g_{22} + g_{21} + g_{12} + E[g_{11,cis}] $$\n    $$ h_{Ab} = 2g_{20} + g_{21} + g_{10} + E[g_{11,trans}] $$\n    $$ h_{aB} = 2g_{02} + g_{12} + g_{01} + E[g_{11,trans}] $$\n    $$ h_{ab} = 2g_{00} + g_{10} + g_{01} + E[g_{11,cis}] $$\n    更新后的频率为 $p_{XY}^{(t+1)} = h_{XY} / (2N)$。\n\n4.  **收敛**：重复 E 步和 M 步，直到单倍型频率向量收敛。当连续迭代之间的频率变化小于指定的容差 $\\epsilon$（例如 $\\epsilon = 10^{-10}$）时，即达到收敛。\n\n在 EM 算法收敛到单倍型频率的最终 MLE $\\mathbf{p}^* = (p_{AB}, p_{Ab}, p_{aB}, p_{ab})$ 之后，计算连锁不平衡（LD）指标。\n从估算的单倍型频率重新计算等位基因频率：\n$$ p_A = p_{AB} + p_{Ab} $$\n$$ p_B = p_{AB} + p_{aB} $$\nLD 系数 $D$ 衡量了与连锁平衡的偏差：\n$$ D = p_{AB} - p_A p_B $$\n最后，计算平方相关系数 $r^2$，这是一种常见的标准化 LD 度量：\n$$ r^2 = \\frac{D^2}{p_A (1-p_A) p_B (1-p_B)} $$\n如果分母为零（即至少一个基因座是单态的），则 $r^2$ 定义为 $0$。最终输出包括四个单倍型频率和 $r^2$ 的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_mle(g: np.ndarray, tol: float = 1e-10, max_iter: int = 10000) - list[float]:\n    \"\"\"\n    Calculates maximum-likelihood estimates of haplotype frequencies using the EM algorithm.\n\n    Args:\n        g: A 3x3 numpy array of genotype counts.\n           Rows correspond to allele counts for locus A (0: aa, 1: Aa, 2: AA).\n           Cols correspond to allele counts for locus B (0: bb, 1: Bb, 2: BB).\n        tol: Convergence tolerance for the EM algorithm.\n        max_iter: Maximum number of iterations for the EM algorithm.\n\n    Returns:\n        A list of five floats: [p_AB, p_Ab, p_aB, p_ab, r^2].\n    \"\"\"\n    g = g.astype(np.float64)\n    N = np.sum(g)\n\n    if N == 0:\n        return [0.0, 0.0, 0.0, 0.0, 0.0]\n\n    # Step 1: Initialization\n    # Estimate allele frequencies from observed genotype counts\n    n_A = 2 * np.sum(g[2, :]) + np.sum(g[1, :])\n    n_B = 2 * np.sum(g[:, 2]) + np.sum(g[:, 1])\n\n    p_A_init = n_A / (2 * N)\n    p_B_init = n_B / (2 * N)\n\n    # Initialize haplotype frequencies assuming linkage equilibrium\n    p = np.array([\n        p_A_init * p_B_init,             # p_AB\n        p_A_init * (1 - p_B_init),       # p_Ab\n        (1 - p_A_init) * p_B_init,       # p_aB\n        (1 - p_A_init) * (1 - p_B_init)  # p_ab\n    ])\n\n    # Step 2: EM Iteration\n    for _ in range(max_iter):\n        p_old = p.copy()\n\n        # E-step: Estimate expected counts of ambiguous diplotypes\n        # Denominator for cis/trans probability\n        # p[0]=p_AB, p[1]=p_Ab, p[2]=p_aB, p[3]=p_ab\n        d = p[0] * p[3] + p[1] * p[2]\n\n        g11_cis = 0.0\n        g11_trans = 0.0\n        if d > 0:\n            g11_cis = g[1, 1] * (p[0] * p[3]) / d\n            g11_trans = g[1, 1] * (p[1] * p[2]) / d\n\n        # M-step: Update haplotype frequencies based on expected counts\n        h_AB = 2 * g[2, 2] + g[2, 1] + g[1, 2] + g11_cis\n        h_Ab = 2 * g[2, 0] + g[2, 1] + g[1, 0] + g11_trans\n        h_aB = 2 * g[0, 2] + g[1, 2] + g[0, 1] + g11_trans\n        h_ab = 2 * g[0, 0] + g[1, 0] + g[0, 1] + g11_cis\n\n        p = np.array([h_AB, h_Ab, h_aB, h_ab]) / (2 * N)\n\n        # Check for convergence\n        if np.sum(np.abs(p - p_old))  tol:\n            break\n            \n    # Step 3: Final calculations after convergence\n    p_AB, p_Ab, p_aB, p_ab = p\n\n    p_A = p_AB + p_Ab\n    p_B = p_AB + p_aB\n\n    D = p_AB - p_A * p_B\n\n    denom_r2 = p_A * (1 - p_A) * p_B * (1 - p_B)\n    r2 = 0.0\n    if denom_r2 > 1e-12: # Use a small epsilon for floating point safety\n        r2 = D**2 / denom_r2\n\n    return [p_AB, p_Ab, p_aB, p_ab, r2]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        np.array([[7, 2, 8], [6, 20, 4], [5, 3, 10]]),\n        np.array([[3, 1, 1], [1, 0, 0], [1, 0, 3]]),\n        np.array([[4, 8, 4], [8, 16, 8], [4, 8, 4]])\n    ]\n\n    results = []\n    for g_matrix in test_cases:\n        result_floats = calculate_mle(g_matrix)\n        rounded_res = [f\"{x:.6f}\" for x in result_floats]\n        results.append(f\"[{','.join(rounded_res)}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2401311"}, {"introduction": "获得了定相的单倍型数据后，我们便可以探索基因组的结构特征，其中最重要的就是单倍型块（haplotype block）。这些块是基因组上重组率极低的区域，其中的等位基因倾向于作为一个整体被遗传。[@problem_id:2401326] 这个实践的核心是实现一个基于“四配子法则”（Four-Gamete Rule）的算法。该法则是一个简洁而有效的准则，通过检测是否存在全部四种可能的配子类型来推断两个位点间是否发生过重组，从而帮助我们划分出这些连锁的基因块。", "problem": "实现一个程序，给定一组连续基因座的分阶段双等位基因单倍型数据，使用四配子法则将这些基因座划分为候选的单倍型块。该程序必须从基本原理开始编写，并且不得依赖于预构建的群体遗传学库。算法基础应从单倍型、重组和无限位点模型下的四配子法则的核心定义出发，不使用快捷公式。数据表示为一个整数矩阵，其中行是单倍型，列是基因座。每个条目都在集合 $\\{0,1\\}$ 中，可选的缺失值用 $-1$ 表示。一个块被定义为一个最大的连续基因座集合，在该集合中，任何一对基因座在所有观察到的单倍型中都不会表现出全部四种双等位基因组合，同时忽略在任一基因座上存在缺失数据的行。任务是实现一个从左到右的贪心算法，以产生这些块的最粗糙划分。\n\n定义和约束：\n- 一个单倍型矩阵 $H$ 的形状为 $n \\times m$，其中有 $n \\ge 1$ 个单倍型（行）和 $m \\ge 1$ 个基因座（列）。条目在 $\\{0,1\\}$ 或缺失符号 $-1$ 中。\n- 对于两个基因座 $i$ 和 $j$，枚举在所有行 $r \\in \\{0,\\dots,n-1\\}$ 中观察到的等位基因对 $(H_{r,i}, H_{r,j})$，忽略任何其中一个值为 $-1$ 的行。如果观察到的对的集合等于 $\\{(0,0),(0,1),(1,0),(1,1)\\}$，则称基因座 $i$ 和 $j$ 表现出四种配子（在无限位点模型下，这是历史重组或复发突变的证据）。\n- 一个有效的块是一个最大的连续索引范围 $[s,e]$，其中 $0 \\le s \\le e \\le m-1$，使得对于每一对 $(i,j)$（其中 $s \\le i  j \\le e$），观察到的对不包含所有四种配子。\n- 贪心划分算法必须从左到右扫描基因座，通过尝试添加下一个基因座来扩展当前块。如果添加基因座 $j$ 会与块中已有的某个基因座 $i$ 形成具有四种配子的配对 $(i,j)$，则当前块在 $j-1$ 处结束，并在 $j$ 处开始一个新块。继续此过程，直到所有基因座都被分配到块中。结果必须是作为索引区间 $[s,e]$（使用基于 $0$ 的包含性索引）的块列表。\n\n作为测试套件嵌入到程序中的输入：\n- 完全按照规定使用缺失数据符号 $-1$。\n- 所有索引都是基于 $0$ 的且包含边界。\n- 测试矩阵按行列出；每个内部列表代表一行（一个单倍型）。\n\n测试套件（五个案例）：\n1. 案例 T$1$（无四配子证据，单个块）：\n   - $H_1$ 是 $4 \\times 4$：\n     - 行 $0$: $[0,0,0,0]$\n     - 行 $1$: $[1,1,1,1]$\n     - 行 $2$: $[0,0,0,0]$\n     - 行 $3$: $[1,1,1,1]$\n   - 预期产生一个跨越索引 $[0,3]$ 的单个块。\n\n2. 案例 T$2$（扩展时因四配子而产生一个内边界）：\n   - $H_2$ 是 $6 \\times 5$：\n     - 行 $0$: $[0,0,0,0,0]$\n     - 行 $1$: $[0,0,0,1,1]$\n     - 行 $2$: $[1,1,1,0,0]$\n     - 行 $3$: $[1,1,1,1,1]$\n     - 行 $4$: $[0,0,0,0,0]$\n     - 行 $5$: $[1,1,1,1,1]$\n   - 添加索引为 $3$ 的基因座会与之前的基因座产生全部四种配子，从而在索引 $2$ 和 $3$ 之间创建一个边界。第二个块跨越索引 $[3,4]$。\n\n3. 案例 T$3$（缺失数据阻止了四配子检测，形成更大的块）：\n   - $H_3$ 是 $6 \\times 4$：\n     - 行 $0$: $[0,0,0,0]$\n     - 行 $1$: $[0,0,0,1]$\n     - 行 $2$: $[1,1,1,0]$\n     - 行 $3$: $[1,1,1,-1]$\n     - 行 $4$: $[0,0,0,0]$\n     - 行 $5$: $[1,1,1,-1]$\n   - 由于最后一列存在缺失值 $-1$，任何基因座对都未观察到全部四种配子，因此产生一个单个块 $[0,3]$。\n\n4. 案例 T$4$（每次尝试扩展都会触发边界，形成单基因座块）：\n   - $H_4$ 是 $4 \\times 5$：\n     - 行 $0$: $[0,0,0,0,0]$\n     - 行 $1$: $[0,1,0,1,0]$\n     - 行 $2$: $[1,0,1,0,1]$\n     - 行 $3$: $[1,1,1,1,1]$\n   - 交替模式确保在尝试扩展时，相邻基因座之间会出现四种配子，从而产生块 $[0,0]$、$[1,1]$、$[2,2]$、$[3,3]$、$[4,4]$。\n\n5. 案例 T$5$（块内的单态基因座）：\n   - $H_5$ 是 $6 \\times 5$：\n     - 行 $0$: $[0,0,0,0,0]$\n     - 行 $1$: $[0,0,0,0,0]$\n     - 行 $2$: $[1,1,1,0,1]$\n     - 行 $3$: $[1,1,1,0,1]$\n     - 行 $4$: $[0,0,0,0,0]$\n     - 行 $5$: $[1,1,1,0,1]$\n   - 第四列是等位基因 $0$ 的单态位点，所有其他列完全一致，从而形成一个单个块 $[0,4]$。\n\n最终输出格式：\n- 对于每个测试案例，将块区间列表输出为一个由两个整数组成的列表 $[s,e]$ 的列表。\n- 将五个案例的结果按 T$1$、T$2$、T$3$、T$4$、T$5$ 的顺序汇总到一个顶级列表中。\n- 您的程序应生成单行输出，其中包含此汇总结果，形式为用方括号括起来的逗号分隔列表，且不含空格，例如：$[[[0,3]],[[0,2],[3,4]],\\dots]$。\n- 每个 $s$ 和 $e$ 都必须是基于 $0$ 的且包含边界的索引。\n\n该程序必须使用指定的算法计算这些分区，并精确打印一行符合上述格式的输出。不涉及物理单位或角度单位。如果需要，将任何分数或比例表示为小数（此处不需要）。", "solution": "问题陈述已经过严格验证，并被认定为有效。它具有科学依据，定义明确，客观且内部一致。它提出了一个基于群体遗传学和生物信息学既定原则的清晰计算任务。因此，我们可以着手解决该问题。\n\n该问题要求实现一个贪心算法，将一组遗传基因座划分为单倍型块。划分的标准是四配子法则，这是一个源自无限位点突变模型的基本概念。\n\n首先，我们必须将其背后的科学原理形式化。无限位点模型假定，每一次新突变都发生在染色体上的一个独特位点，该位点在抽样群体中此前未曾发生过突变。考虑位于位置 $i$ 和 $j$ 的两个双等位基因座，其等位基因为 $\\{0,1\\}$。如果在观察到的单倍型的演化历史中，这两个基因座之间没有发生过重组，那么四种可能的双基因座配子——$(0,0)$、$(0,1)$、$(1,0)$ 和 $(1,1)$——中最多只能存在三种。第四种配子的出现只能通过基因座之间的重组事件或其中一个位点的复发突变来解释，而后者在无限位点模型中是不被允许的。因此，所有四种配子的存在（被称为“四配子对”）是基因座之间至少发生过一次历史重组事件的强有力证据。\n\n算法的核心是用于测试此条件的函数。设输入的单倍型数据由一个大小为 $n \\times m$ 的矩阵 $H$ 表示，其中 $n$ 是单倍型数量，$m$ 是基因座数量。一个条目 $H_{r,k}$ 表示单倍型 $r$ 在基因座 $k$ 处的等位基因，其中 $k \\in \\{0, \\dots, m-1\\}$ 且 $r \\in \\{0, \\dots, n-1\\}$。等位基因在 $\\{0,1\\}$ 中，$-1$ 表示缺失数据。\n\n要确定两个基因座 $i$ 和 $j$ 是否构成一个四配子对，我们执行以下检查：\n1. 初始化一个空集合 $S_{i,j}$，用于存储唯一的、有效的等位基因对。\n2. 遍历每个单倍型 $r$，从 $0$ 到 $n-1$。\n3. 对于每个单倍型 $r$，考虑等位基因对 $(H_{r,i}, H_{r,j})$。\n4. 如果 $H_{r,i} = -1$ 或 $H_{r,j} = -1$，则该对包含缺失数据，必须被忽略。\n5. 如果该对有效，则将其添加到集合 $S_{i,j}$ 中。\n6. 在遍历所有 $n$ 个单倍型后，当且仅当集合 $S_{i,j}$ 等于 $\\{(0,0), (0,1), (1,0), (1,1)\\}$ 时，四配子对的测试为阳性。对于双等位基因数据，这等同于检查集合的基数 $|S_{i,j}|$ 是否等于 $4$。\n\n建立了这个测试后，我们就可以按规定构建贪心块划分算法。该算法从左到右遍历基因座，尽可能地扩展一个块。\n\n设总基因座数量为 $m$，索引从 $0$ 到 $m-1$。\n1. 初始化一个空列表 $\\mathcal{B}$，用于存储最终的块划分。\n2. 初始化当前块的起始索引 $s$ 为 $0$。\n3. 使用一个预期的基因座索引 $j$ 从 $1$ 迭代到 $m-1$。对于每个 $j$，我们测试基因座 $j$ 是否可以被包含在从索引 $s$ 开始的当前块中。\n4. 为执行此测试，我们必须检查基因座 $j$ 与当前块中已有的每个基因座 $i$（其中 $i$ 的范围从 $s$ 到 $j-1$）之间是否存在四配子违例。\n5. 如果在此范围内任何一对基因座 $(i,j)$ 的四配子测试为阳性，则发生违例。\n6. 如果对于某个基因座 $i \\in [s, j-1]$ 发现了违例：\n   a. 当前块被最终确定。其区间为 $[s, j-1]$。此区间被添加到列表 $\\mathcal{B}$ 中。\n   b. 必须在当前基因座 $j$ 处开始一个新块。起始索引 $s$ 更新为 $j$。\n   c. 对其他基因座 $i$ 的内部检查终止，算法继续处理下一个预期的基因座 $j+1$。\n7. 如果遍历所有 $i \\in [s, j-1]$ 的内部循环完成而没有发现任何四配子违例，则基因座 $j$ 成功添加到当前块中。然后算法继续评估下一个基因座 $j+1$，而不改变块的起始点 $s$。\n8. 在关于 $j$ 的主循环完成后，必须将从当前 $s$ 值开始并延伸到最后一个基因座 $m-1$ 的最终块最终确定并添加到 $\\mathcal{B}$ 中。其区间为 $[s, m-1]$。\n\n这个确定性的贪心过程为任何给定的单倍型矩阵 $H$ 生成一个唯一的基因座到连续块的划分。每个块在某种意义上是最大的，即它不能在不违反四配子法则的情况下向右进一步扩展。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the block partitioning algorithm.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case T1\n        [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1]],\n        # Case T2\n        [[0, 0, 0, 0, 0], [0, 0, 0, 1, 1], [1, 1, 1, 0, 0], [1, 1, 1, 1, 1], [0, 0, 0, 0, 0], [1, 1, 1, 1, 1]],\n        # Case T3\n        [[0, 0, 0, 0], [0, 0, 0, 1], [1, 1, 1, 0], [1, 1, 1, -1], [0, 0, 0, 0], [1, 1, 1, -1]],\n        # Case T4\n        [[0, 0, 0, 0, 0], [0, 1, 0, 1, 0], [1, 0, 1, 0, 1], [1, 1, 1, 1, 1]],\n        # Case T5\n        [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1], [1, 1, 1, 0, 1], [0, 0, 0, 0, 0], [1, 1, 1, 0, 1]],\n    ]\n\n    def check_four_gametes(locus1_col, locus2_col):\n        \"\"\"\n        Checks if two loci exhibit all four gametic types.\n        Missing data (-1) are ignored.\n        \n        Args:\n            locus1_col (np.ndarray): A 1D array representing allele data for the first locus.\n            locus2_col (np.ndarray): A 1D array representing allele data for the second locus.\n        \n        Returns:\n            bool: True if four gametes are observed, False otherwise.\n        \"\"\"\n        observed_pairs = set()\n        for i in range(len(locus1_col)):\n            allele1 = locus1_col[i]\n            allele2 = locus2_col[i]\n            \n            # Ignore haplotypes with missing data at either locus\n            if allele1 != -1 and allele2 != -1:\n                observed_pairs.add((allele1, allele2))\n        \n        # The condition is met if the number of unique pairs is exactly 4\n        return len(observed_pairs) == 4\n\n    def find_blocks(haplotype_matrix):\n        \"\"\"\n        Partitions loci into blocks using the greedy Four-Gamete Rule algorithm.\n        \n        Args:\n            haplotype_matrix (list of lists): The input matrix of haplotypes.\n            \n        Returns:\n            list of lists: A list of [start, end] intervals for each block.\n        \"\"\"\n        H = np.array(haplotype_matrix, dtype=np.int8)\n        _n_haplotypes, n_loci = H.shape\n\n        if n_loci == 0:\n            return []\n        if n_loci == 1:\n            return [[0, 0]]\n\n        blocks = []\n        block_start = 0\n\n        # Iterate through loci to decide where blocks end\n        for j in range(1, n_loci):\n            violation_found = False\n            # Check current locus j against all previous loci in the current block\n            for i in range(block_start, j):\n                if check_four_gametes(H[:, i], H[:, j]):\n                    # Violation found, end the current block here\n                    blocks.append([block_start, j - 1])\n                    # Start a new block at the current locus\n                    block_start = j\n                    violation_found = True\n                    break\n            if violation_found:\n                continue\n        \n        # Add the last block, which extends to the end of the loci\n        blocks.append([block_start, n_loci - 1])\n        \n        return blocks\n\n    results = []\n    for case in test_cases:\n        result = find_blocks(case)\n        results.append(result)\n\n    # Final print statement in the exact required format without spaces.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2401326"}, {"introduction": "识别出单倍型块提供了基因组的宏观结构视图，但我们还需要一个精确的量化指标来衡量任意两个变异位点之间的关联强度，即连锁不平衡（LD）的程度。连锁不平衡最常用的度量标准是 $r^2$，即两个位点等位基因计数之间的皮尔逊相关系数的平方。[@problem_id:2401344] 这项实践将让你处理生物信息学中标准的VCF（Variant Call Format）文件，并从零开始编写程序计算 $r^2$ 值，这是进行全基因组关联研究（GWAS）和其他群体遗传学分析的核心技能。", "problem": "您的任务是编写一个完整的程序，该程序为若干个代表单条染色体的变异调用格式 (VCF) 文本，识别出指定目标变体的所有“连锁不平衡 (LD) 伙伴”。如果一个变体与目标变体在二倍体个体间的等位基因备择计数的 Pearson 相关系数平方（记为 $r^2$）严格超过给定的阈值 $\\tau$，则该变体被视为目标的 LD 伙伴。所有计算必须根据下文规定的第一性原理推导，并且所有输出必须符合本说明末尾定义的格式。\n\n定义。考虑一组 $S$ 个二倍体个体和一条染色体上的 $M$ 个双等位基因单核苷酸变体。对于变体 $j \\in \\{1,\\dots,M\\}$ 和个体 $s \\in \\{1,\\dots,S\\}$，设 VCF 字段 GT 中的基因型标注为标准形式之一：$0/0$、$0/1$、$1/0$、$1/1$、$0|0$、$0|1$、$1|0$、$1|1$，或缺失（例如 $./.$）。定义等位基因备择计数\n$$\nx^{(j)}_s \\in \\{0,1,2\\}\n$$\n为变体 $j$ 和个体 $s$ 的基因型标注中的备择等位基因数量，其中缺失的基因型被视为未定义。对于一对变体 $(j,k)$，将在两个变体上基因型均非缺失的个体集合定义为\n$$\n\\mathcal{I}_{jk} = \\{ s \\in \\{1,\\dots,S\\} \\mid x^{(j)}_s \\text{ 和 } x^{(k)}_s \\text{ 均已定义} \\},\n$$\n并令\n$$\nn_{jk} = |\\mathcal{I}_{jk}|.\n$$\n若 $n_{jk}  2$，则 $(j,k)$ 的 $r^2$ 未定义。否则，定义群体均值\n$$\n\\mu_j = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(j)}_s, \\qquad \\mu_k = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} x^{(k)}_s,\n$$\n群体方差\n$$\n\\sigma_j^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)^2, \\qquad \\sigma_k^2 = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(k)}_s - \\mu_k\\right)^2,\n$$\n以及群体协方差\n$$\n\\operatorname{Cov}_{jk} = \\frac{1}{n_{jk}} \\sum_{s \\in \\mathcal{I}_{jk}} \\left(x^{(j)}_s - \\mu_j\\right)\\left(x^{(k)}_s - \\mu_k\\right).\n$$\n若 $\\sigma_j^2 = 0$ 或 $\\sigma_k^2 = 0$，则 $(j,k)$ 的 $r^2$ 未定义。否则，定义 Pearson 相关系数\n$$\nr_{jk} = \\frac{\\operatorname{Cov}_{jk}}{\\sqrt{\\sigma_j^2 \\sigma_k^2}}\n$$\n和连锁不平衡度量\n$$\nr_{jk}^2 = \\left(r_{jk}\\right)^2.\n$$\n固定一个目标变体索引 $t$ 和一个阈值 $\\tau \\in (0,1)$。一个变体 $j \\neq t$ 是 $t$ 的 LD 伙伴，当且仅当 $r_{tj}^2 > \\tau$。$r_{tj}^2$ 未定义的变体对不是 LD 伙伴。\n\n输入表示。每个测试用例包含：\n- 用于选择行的单个染色体标识符（字符串）。\n- 一个 VCF 文本，其标题行以字段 CHROM、POS、ID、REF、ALT、QUAL、FILTER、INFO、FORMAT 开头，后跟 $S$ 个样本列。只有 FORMAT 中的 GT 子字段是相关的。所有变体都是双等位基因的，并且一个测试用例中的所有行都属于同一条染色体。\n- 一个目标变体位置（给定染色体上的一个整数碱基对坐标）。\n- 一个阈值 $\\tau$，以 $(0,1)$ 范围内的十进制数给出。\n\n您的程序必须使用下面测试套件中提供的 VCF 文本和参数作为其内部数据，并且不得要求任何用户输入或外部文件。\n\n测试套件。共有三个测试用例。对于每个用例，请使用指定的染色体字符串、目标位置、阈值 $\\tau = 0.8$ 以及提供的 VCF 内容。\n\n测试用例 A:\n- 染色体: \"1\"\n- 目标位置: 200\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4\"\n  - \"1 100 rs100 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 200 rs200 A G . . . GT 0/0 0/1 1/1 0/1\"\n  - \"1 300 rs300 A G . . . GT 0/0 0/0 1/1 1/1\"\n\n测试用例 B:\n- 染色体: \"1\"\n- 目标位置: 1000\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3 S4 S5 S6\"\n  - \"1 1000 rs1000 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1010 rs1010 A G . . . GT 0/0 0/1 1/1 0/1 0/0 1/1\"\n  - \"1 1020 rs1020 A G . . . GT 0/0 0/0 0/0 0/0 0/0 0/0\"\n  - \"1 1030 rs1030 A G . . . GT 0/0 ./. 1/1 ./. 0/0 ./.\"\n  - \"1 1040 rs1040 A G . . . GT 0/0 0/0 1/1 1/1 0/0 1/1\"\n\n测试用例 C:\n- 染色体: \"2\"\n- 目标位置: 5000\n- 阈值: $0.8$\n- VCF 行:\n  - \"##fileformat=VCFv4.2\"\n  - \"#CHROM POS ID REF ALT QUAL FILTER INFO FORMAT S1 S2 S3\"\n  - \"2 5000 rs5000 A G . . . GT 0/0 0/0 0/0\"\n  - \"2 5010 rs5010 A G . . . GT 0/0 1/1 0/1\"\n  - \"2 5020 rs5020 A G . . . GT 0/1 1/1 0/0\"\n\n输出规范。对于每个测试用例，输出作为目标 LD 伙伴的所有变体位置的排序列表（按位置升序）。将这三个测试用例的列表汇总成单行输出，格式为一个包含逗号分隔列表的方括号列表，不含空格，例如：\"[[a,b],[c],[]]\"。内部列表中的元素必须是整数。您的程序应生成一行输出，其中仅包含此格式的汇总结果。", "solution": "该问题是有效的。它在群体遗传学方面有科学依据，数学上定义明确，并且为提供完整解决方案提供了所有必要的数据和定义。\n\n目标是从变异调用格式 (VCF) 数据中，为指定的目标变体识别“连锁不平衡 (LD) 伙伴”。如果一个变体 $j$ 与目标变体 $t$ 在二倍体个体群体间的等位基因备择计数的 Pearson 相关系数平方（$r_{tj}^2$）超过给定的阈值 $\\tau$，则变体 $j$ 是目标 $t$ 的 LD 伙伴。解决方案必须根据问题陈述中定义的第一性原理推导得出。\n\n算法方法分为三个主要阶段：数据解析与准备、$r^2$ 统计量的计算，以及结果的识别与格式化。\n\n首先，我们必须为每个测试用例解析所提供的 VCF 文本。VCF 格式代表遗传变异。就我们的目的而言，我们关心的是双等位基因单核苷酸变体。关键信息位于 `POS`（位置）列以及 `FORMAT` 和样本列中的 `GT`（基因型）子字段中。我们遍历 VCF 文本的每个非标题行。对于每个变体，我们记录其染色体位置（一个整数）。基因型标注，如 `$0/0$`、`$0/1$`、`$1/0$` 和 `$1/1$`，必须转换为数值形式的等位基因备择计数 $x_s^{(j)} \\in \\{0, 1, 2\\}$。具体来说，`$0/0$` 和 `$0|0$` 映射为 0，`$0/1$`、`$1/0$`、`$0|1$` 和 `$1|0$` 映射为 1，而 `$1/1$` 和 `$1|1$` 映射为 2。缺失的基因型，表示为 `$./.$`，被视为未定义，并用一个特殊值（如 `np.nan`）表示，以方便数值计算。这个过程产生一组位置向量和一个对应的维度为 $M \\times S$ 的基因型矩阵，其中 $M$ 是变体数量，$S$ 是个体数量。\n\n问题的核心是正确计算目标变体 $t$ 与每个其他候选变体 $j$ 之间的 $r^2$ 统计量。计算必须精确遵循所提供的定义。对于任何一对变体 $(t, j)$，我们首先识别出在两个变体上都有可用基因型数据的个体集合 $\\mathcal{I}_{tj}$。令 $n_{tj} = |\\mathcal{I}_{tj}|$。问题规定，如果 $n_{tj}  2$，$r_{tj}^2$ 是未定义的。在这种情况下，该变体对被舍弃。\n\n如果 $n_{tj} \\ge 2$，我们继续使用仅来自 $\\mathcal{I}_{tj}$ 中个体的数据来计算必要的统计量。设过滤后的等位基因计数向量为 $\\mathbf{x}^{(t)}$ 和 $\\mathbf{x}^{(j)}$。群体均值计算如下：\n$$\n\\mu_t = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(t)}_s, \\qquad \\mu_j = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} x^{(j)}_s\n$$\n群体方差为：\n$$\n\\sigma_t^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)^2, \\qquad \\sigma_j^2 = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(j)}_s - \\mu_j\\right)^2\n$$\n如果一个变体在所考虑的子群体 $\\mathcal{I}_{tj}$ 中是单态的（即所有个体具有相同的等位基因计数），就会出现一个关键的边界情况。在这种情况下，方差为零。问题陈述中指出，如果 $\\sigma_t^2 = 0$ 或 $\\sigma_j^2 = 0$，$r_{tj}^2$ 是未定义的，该变体对不被考虑为 LD 伙伴。\n\n如果两个方差都非零，我们计算群体协方差：\n$$\n\\operatorname{Cov}_{tj} = \\frac{1}{n_{tj}} \\sum_{s \\in \\mathcal{I}_{tj}} \\left(x^{(t)}_s - \\mu_t\\right)\\left(x^{(j)}_s - \\mu_j\\right)\n$$\n最后，Pearson 相关系数的平方计算如下：\n$$\nr_{tj}^2 = \\left( \\frac{\\operatorname{Cov}_{tj}}{\\sqrt{\\sigma_t^2 \\sigma_j^2}} \\right)^2 = \\frac{(\\operatorname{Cov}_{tj})^2}{\\sigma_t^2 \\sigma_j^2}\n$$\n对目标变体 $t$ 和每个其他变体 $j \\neq t$ 执行此计算。如果计算出的 $r_{tj}^2$ 是一个有效数字且 $r_{tj}^2 > \\tau$（其中 $\\tau$ 是给定的阈值），则变体 $j$ 是 $t$ 的一个 LD 伙伴。变体 $j$ 的位置被添加到当前测试用例的结果列表中。\n\n总体算法流程如下：\n1.  初始化一个空列表，用于存储所有测试用例的最终结果。\n2.  对于每个测试用例，解析 VCF 文本，以创建从变体位置到其在所有样本中的等位基因计数向量的映射。\n3.  识别与给定目标位置对应的目标变体的等位基因计数向量。\n4.  遍历所有其他变体。对于每个候选变体：\n    a. 应用成对删除来处理缺失数据，为目标和候选变体创建过滤后的向量。\n    b. 检查有效性条件：$n_{tj} \\ge 2$，$\\sigma_t^2 > 0$ 和 $\\sigma_j^2 > 0$。\n    c. 如果有效，使用群体统计公式计算 $r_{tj}^2$。\n    d. 如果 $r_{tj}^2 > \\tau$，将候选变体的位置添加到当前测试用例的临时列表中。\n5.  在检查完一个测试用例的所有候选变体后，按升序对 LD 伙伴位置列表进行排序。\n6.  将此排序后的列表附加到主结果列表中。\n7.  处理完所有测试用例后，按规定将汇总结果格式化为嵌套列表的单个字符串，例如 `[[pos1,pos2],[pos3],[]]`，并输出此字符串。这确保了符合所要求的严格输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linkage disequilibrium buddy problem for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 200,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\n1\t100\trs100\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t200\trs200\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\n1\t300\trs300\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"1\",\n            \"target_pos\": 1000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\tS4\tS5\tS6\n1\t1000\trs1000\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1010\trs1010\tA\tG\t.\t.\t.\tGT\t0/0\t0/1\t1/1\t0/1\t0/0\t1/1\n1\t1020\trs1020\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\t0/0\t0/0\t0/0\n1\t1030\trs1030\tA\tG\t.\t.\t.\tGT\t0/0\t./.\t1/1\t./.\t0/0\t./.\n1\t1040\trs1040\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t1/1\t1/1\t0/0\t1/1\n\"\"\"\n        },\n        {\n            \"chrom\": \"2\",\n            \"target_pos\": 5000,\n            \"tau\": 0.8,\n            \"vcf_text\": \"\"\"##fileformat=VCFv4.2\n#CHROM\tPOS\tID\tREF\tALT\tQUAL\tFILTER\tINFO\tFORMAT\tS1\tS2\tS3\n2\t5000\trs5000\tA\tG\t.\t.\t.\tGT\t0/0\t0/0\t0/0\n2\t5010\trs5010\tA\tG\t.\t.\t.\tGT\t0/0\t1/1\t0/1\n2\t5020\trs5020\tA\tG\t.\t.\t.\tGT\t0/1\t1/1\t0/0\n\"\"\"\n        }\n    ]\n\n    aggregated_results = []\n    \n    for case in test_cases:\n        vcf_text = case[\"vcf_text\"]\n        target_pos = case[\"target_pos\"]\n        tau = case[\"tau\"]\n\n        # Parse VCF text\n        positions = []\n        genotypes_list = []\n        lines = vcf_text.strip().split('\\n')\n        \n        header_line = \"\"\n        data_lines = []\n        for line in lines:\n            if line.startswith('#CHROM'):\n                header_line = line\n            elif not line.startswith('##'):\n                data_lines.append(line)\n\n        header_fields = header_line.split('\\t')\n        format_col_idx = header_fields.index('FORMAT')\n        sample_cols_start_idx = format_col_idx + 1\n\n        for line in data_lines:\n            parts = line.split('\\t')\n            positions.append(int(parts[1]))\n            \n            format_str = parts[format_col_idx]\n            try:\n                gt_subfield_idx = format_str.split(':').index('GT')\n            except ValueError:\n                # This case implies GT field is missing, which is a malformed VCF for this problem.\n                # We assume valid VCFs as per problem context.\n                continue\n\n            allele_counts = []\n            for sample_gt_field in parts[sample_cols_start_idx:]:\n                gt_str = sample_gt_field.split(':')[gt_subfield_idx]\n                \n                if gt_str in ('0/0', '0|0'):\n                    allele_counts.append(0)\n                elif gt_str in ('0/1', '1/0', '0|1', '1|0'):\n                    allele_counts.append(1)\n                elif gt_str in ('1/1', '1|1'):\n                    allele_counts.append(2)\n                else: # Missing, e.g., './.'\n                    allele_counts.append(np.nan)\n            \n            genotypes_list.append(allele_counts)\n        \n        genotypes = np.array(genotypes_list, dtype=float)\n\n        # Identify target variant\n        try:\n            target_idx = positions.index(target_pos)\n        except ValueError:\n            aggregated_results.append([])\n            continue # Target not found, no buddies\n\n        target_vec = genotypes[target_idx, :]\n        \n        ld_buddies = []\n\n        # Find LD buddies\n        for j in range(len(positions)):\n            if j == target_idx:\n                continue\n            \n            candidate_pos = positions[j]\n            candidate_vec = genotypes[j, :]\n\n            # Filter for individuals with non-missing genotypes for both variants\n            valid_indices = ~np.isnan(target_vec)  ~np.isnan(candidate_vec)\n            \n            x_t_j_valid = target_vec[valid_indices]\n            x_k_j_valid = candidate_vec[valid_indices]\n            \n            n_jk = len(x_t_j_valid)\n\n            if n_jk  2:\n                continue\n\n            var_t = np.var(x_t_j_valid) # ddof=0 is default for population variance\n            var_k = np.var(x_k_j_valid)\n\n            if var_t == 0 or var_k == 0:\n                continue\n\n            # Calculate population covariance\n            # np.cov with ddof=0 ensures population covariance calculation\n            cov_matrix = np.cov(x_t_j_valid, x_k_j_valid, ddof=0)\n            cov_tk = cov_matrix[0, 1]\n\n            r_squared = (cov_tk ** 2) / (var_t * var_k)\n            \n            # Since floating point arithmetic can sometimes result in values slightly > 1.0, clip it.\n            # e.g. for identical vectors.\n            if r_squared > 1.0:\n                r_squared = 1.0\n\n            if r_squared > tau:\n                ld_buddies.append(candidate_pos)\n\n        ld_buddies.sort()\n        aggregated_results.append(ld_buddies)\n\n    # Format and print the final output\n    inner_lists_str = [f\"[{','.join(map(str, lst))}]\" for lst in aggregated_results]\n    print(f\"[{','.join(inner_lists_str)}]\")\n\nsolve()\n```", "id": "2401344"}]}