{"hands_on_practices": [{"introduction": "这个入门练习将带你掌握孟德尔随机化分析的基石：Wald比率估计。我们将利用单个遗传工具变量的汇总统计数据，来计算暴露对结局的因果效应，并评估其统计显著性。通过这个练习，你将清晰地理解孟德尔随机化（Mendelian Randomization, MR）如何利用遗传变异来推断因果关系的核心逻辑 ([@problem_id:2854802])。", "problem": "一个单核苷酸多态性 (SNP) $G$ 作为某个基因调控网络中转录调控因子表达水平 $E$ 的顺式表达数量性状位点 (cis-eQTL)，并且也与一个复杂性状 $Y$ 相关。考虑一个双样本设定，其中样本无重叠，因此 $Y$ 对 $G$ 和 $E$ 对 $G$ 的汇总关联估计在统计上是独立的。假设存在线性关系、在适当尺度上的可加性、关联估计值的大样本正态性，以及孟德尔随机化 (Mendelian Randomization, MR) 的标准工具变量假设：工具变量相关性、工具变量独立于混杂因素、以及除通过 $E$ 的路径外，不存在其他从 $G$ 到 $Y$ 的路径。您已获得以下来自回归分析的汇总估计值：$Y$ 对 $G$ 的关联效应为 $\\hat{\\beta}_{YG} = 0.10$，标准误为 $\\mathrm{SE}(\\hat{\\beta}_{YG}) = 0.03$；$E$ 对 $G$ 的关联效应为 $\\hat{\\beta}_{EG} = 0.25$，标准误为 $\\mathrm{SE}(\\hat{\\beta}_{EG}) = 0.05$。\n\n仅使用上述假设，计算：\n- $E$ 对 $Y$ 的 MR 因果效应估计值，\n- 其标准误，\n- 以及在显著性水平 $\\alpha = 0.05$ 下，检验因果效应为零的原假设的双侧 $p$ 值。\n\n将您的结果以行向量 $\\left[\\hat{\\beta}_{\\mathrm{MR}}, \\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}}), p\\right]$ 的形式报告。将每个分量四舍五入到三位有效数字。无需单位。", "solution": "该问题要求在双样本设定下计算孟德尔随机化 (MR) 的因果效应估计值、其标准误以及相应的 p 值。我们首先验证问题陈述的有效性。\n\n已知条件如下：\n- 单核苷酸多态性 (SNP) $G$ 是一个工具变量 (IV)。\n- 暴露是转录调控因子的表达水平 $E$。\n- 结局是一个复杂性状 $Y$。\n- 使用了双样本设计，样本无重叠，确保了汇总估计值的统计独立性。\n- 声明标准的 MR 假设成立：\n    1. 工具变量相关性：$G$ 与 $E$ 相关。\n    2. 工具变量独立于混杂因素：$G$ 独立于 $E-Y$ 关系中的任何未测量的混杂因素。\n    3. 排除限制：$G$ 仅通过 $E$ 影响 $Y$。\n- $Y$ 对 $G$ 的关联估计值为 $\\hat{\\beta}_{YG} = 0.10$。\n- 该估计值的标准误为 $\\mathrm{SE}(\\hat{\\beta}_{YG}) = 0.03$。\n- $E$ 对 $G$ 的关联估计值为 $\\hat{\\beta}_{EG} = 0.25$。\n- 该估计值的标准误为 $\\mathrm{SE}(\\hat{\\beta}_{EG}) = 0.05$。\n- 假设了可加性、线性和估计值的大样本正态性。\n- 检验的显著性水平为 $\\alpha = 0.05$。\n\n该问题具有科学依据，提法明确，客观且内部一致。它描述了双样本孟德尔随机化中 Wald ratio estimator 的标准应用，这是遗传流行病学和系统遗传学中的一种基石方法。所有必要的数据和假设都已提供，可以推导出一个唯一且有意义的解。因此，该问题是有效的。\n\n我们开始求解。\n\n首先，我们计算 $E$ 对 $Y$ 的 MR 因果效应估计值，记为 $\\beta_{EY}$。在给定假设下，该效应可以通过 SNP-结局关联与 SNP-暴露关联的比率来估计。这就是 Wald ratio estimator，对于我们的汇总数据，其形式为：\n$$ \\hat{\\beta}_{\\mathrm{MR}} = \\frac{\\hat{\\beta}_{YG}}{\\hat{\\beta}_{EG}} $$\n代入所提供的值：\n$$ \\hat{\\beta}_{\\mathrm{MR}} = \\frac{0.10}{0.25} = 0.4 $$\n\n第二，我们计算该估计值的标准误，$\\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}})$。由于 $\\hat{\\beta}_{YG}$ 和 $\\hat{\\beta}_{EG}$ 来自无重叠的样本，它们是独立的随机变量。它们的比率的方差可以使用一阶泰勒级数展开（Delta method）来近似。对于函数 $f(x, y) = x/y$，方差近似为：\n$$ \\mathrm{Var}\\left(\\frac{X}{Y}\\right) \\approx \\left(\\frac{\\mu_X}{\\mu_Y}\\right)^2 \\left( \\frac{\\mathrm{Var}(X)}{\\mu_X^2} + \\frac{\\mathrm{Var}(Y)}{\\mu_Y^2} \\right) $$\n将此应用于我们的估计值，其中 $\\mathrm{Var}(\\hat{\\beta}) = \\mathrm{SE}(\\hat{\\beta})^2$：\n$$ \\mathrm{Var}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx \\left(\\frac{\\hat{\\beta}_{YG}}{\\hat{\\beta}_{EG}}\\right)^2 \\left( \\frac{\\mathrm{SE}(\\hat{\\beta}_{YG})^2}{\\hat{\\beta}_{YG}^2} + \\frac{\\mathrm{SE}(\\hat{\\beta}_{EG})^2}{\\hat{\\beta}_{EG}^2} \\right) $$\n从 Delta method 推导出的一个更直接、更常用的形式是：\n$$ \\mathrm{Var}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx \\frac{\\mathrm{SE}(\\hat{\\beta}_{YG})^2}{\\hat{\\beta}_{EG}^2} + \\frac{\\hat{\\beta}_{YG}^2 \\mathrm{SE}(\\hat{\\beta}_{EG})^2}{\\hat{\\beta}_{EG}^4} $$\n我们将使用这个公式。代入给定值：\n$$ \\mathrm{Var}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx \\frac{(0.03)^2}{(0.25)^2} + \\frac{(0.10)^2 (0.05)^2}{(0.25)^4} $$\n$$ \\mathrm{Var}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx \\frac{0.0009}{0.0625} + \\frac{(0.01)(0.0025)}{0.00390625} $$\n$$ \\mathrm{Var}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx 0.0144 + \\frac{0.000025}{0.00390625} = 0.0144 + 0.0064 = 0.0208 $$\n标准误是方差的平方根：\n$$ \\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}}) = \\sqrt{0.0208} \\approx 0.144222051... $$\n\n第三，我们计算原假设 $H_0: \\beta_{\\mathrm{MR}} = 0$ 的双侧 p 值。在假定大样本正态性的前提下，检验统计量 $Z$ 在原假设下服从标准正态分布 $\\mathcal{N}(0, 1)$。\n$$ Z = \\frac{\\hat{\\beta}_{\\mathrm{MR}} - 0}{\\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}})} = \\frac{\\hat{\\beta}_{\\mathrm{MR}}}{\\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}})} $$\n代入计算出的值：\n$$ Z \\approx \\frac{0.4}{0.144222051...} \\approx 2.77350098... $$\n双侧 p 值是观察到至少与 $|Z|$ 一样极端的检验统计量的概率：\n$$ p = 2 \\times P(Z_{std} \\ge |Z|) = 2 \\times (1 - \\Phi(|Z|)) $$\n其中 $\\Phi$ 是标准正态分布的累积分布函数。\n$$ p \\approx 2 \\times (1 - \\Phi(2.7735)) \\approx 2 \\times (1 - 0.99723) \\approx 2 \\times 0.00277 = 0.00554 $$\n\n最后，我们将结果四舍五入到三位有效数字，并以行向量 $[\\hat{\\beta}_{\\mathrm{MR}}, \\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}}), p]$ 的形式报告。\n- $\\hat{\\beta}_{\\mathrm{MR}} = 0.4$ 四舍五入到三位有效数字是 $0.400$。\n- $\\mathrm{SE}(\\hat{\\beta}_{\\mathrm{MR}}) \\approx 0.14422...$ 四舍五入到三位有效数字是 $0.144$。\n- $p \\approx 0.00554$（已经有三位有效数字，即 $5, 5, 4$）。\n\n最终结果是向量 $[0.400, 0.144, 0.00554]$。", "answer": "$$\\boxed{\\begin{pmatrix} 0.400  0.144  0.00554 \\end{pmatrix}}$$", "id": "2854802"}, {"introduction": "现实世界中的MR研究通常会使用多个遗传工具变量以增强统计功效。这个编程练习将指导你实现最常用的多工具变量方法，即逆方差加权（Inverse-Variance Weighted, IVW）和MR-Egger回归。你还将计算关键的诊断统计量，如Cochran's $Q$ 统计量，并生成散点图和漏斗图的必要数据，这些都是可视化评估工具变量间多效性和异质性的关键步骤 ([@problem_id:2404096])。", "problem": "给定来自全基因组关联研究 (GWAS) 的汇总关联数据，这些数据来自作为工具变量的单核苷酸多态性 (SNP)，应用场景为孟德尔随机化 (MR)。对于每个 SNP，您拥有其与暴露的关联效应值，记为 $ \\beta_{GX,i} $，以及与结局的关联效应值，记为 $ \\beta_{GY,i} $，同时还有结局关联效应值的标准误 $ \\sigma_{GY,i} $。假设以下基本前提：(i) 暴露-结局关系遵循线性因果模型；(ii) 除了任何潜在的水平多效性外，工具变量仅通过暴露影响结局；(iii) $ \\beta_{GY,i} $ 的抽样变异性由 $ \\sigma_{GY,i} $ 量化，并且为了加权目的，$ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可以忽略不计；(iv) 因果效应可以通过使用加权最小二乘法汇总每个变异体的信息来估计。\n\n任务是编写一个完整的程序，针对下述的每个测试用例，计算生成以下图形所需的数值对象：(a) 一个 $ \\beta_{GY} $ 对 $ \\beta_{GX} $ 的散点图，图中包含截距约束的逆方差加权 (IVW) 回归线和孟德尔随机化 Egger (MR-Egger) 回归线；(b) 一个比率估计值对其标准误的漏斗图，用于直观地检查异质性和多效性。程序不必绘制任何图形，但必须返回定义这些图形的精确数值。\n\n仅从上述基本原则出发，为每个测试用例实现以下计算：\n- 使用由结局方差的倒数定义的权重 $ w_i $，即 $ w_i $ 正比于 $ 1 / \\sigma_{GY,i}^2 $。\n- 通过求解截距固定为零的加权最小二乘问题，即最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2 $（对 $ b $ 进行最小化），计算截距约束的 IVW 因果斜率估计值。\n- 通过最小化 $ \\sum_i w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2 $（对 $ a $ 和 $ b $ 进行最小化），计算带有无约束截距的 MR-Egger 加权回归线。\n- 计算 IVW 模型下的异质性 Cochran $ Q $ 统计量以及相应的 $ I^2 $ 异质性度量，其中 $ Q $ 比较了加权残差的离散度与其在同质性假设下的期望值。\n- 对于漏斗图，假设 $ \\beta_{GX,i} $ 的不确定性相对于 $ \\sigma_{GY,i} $ 可以忽略不计，计算每个变异体的比率估计值 $ \\theta_i $ 及其近似标准误 $ s_i $。然后，围绕合并的 IVW 效应，计算每个变异体的伪 $ 95\\% $ 漏斗界限，公式为 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $。\n\n程序必须将这些计算应用于以下测试套件。每个测试用例由三个等长的列表定义：$ \\beta_{GX} $，$ \\beta_{GY} $ 和 $ \\sigma_{GY} $。\n\n测试用例A（理想情况；一致的工具变量）：\n- $ \\beta_{GX} = [\\, 0.08, \\, 0.12, \\, 0.10, \\, 0.15, \\, 0.07, \\, 0.11 \\,] $\n- $ \\beta_{GY} = [\\, 0.040, \\, 0.060, \\, 0.051, \\, 0.072, \\, 0.033, \\, 0.057 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.018, \\, 0.022, \\, 0.019, \\, 0.021, \\, 0.020 \\,] $\n\n测试用例B（方向性多效性；预期截距非零）：\n- $ \\beta_{GX} = [\\, 0.05, \\, -0.04, \\, 0.09, \\, 0.12, \\, 0.03, \\, 0.07 \\,] $\n- $ \\beta_{GY} = [\\, 0.037, \\, 0.007, \\, 0.048, \\, 0.054, \\, 0.029, \\, 0.042 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.021, \\, 0.019, \\, 0.018, \\, 0.022, \\, 0.020 \\,] $\n\n测试用例C（异质性和弱工具变量）：\n- $ \\beta_{GX} = [\\, 0.20, \\, 0.15, \\, 0.10, \\, 0.05, \\, 0.004 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.070, \\, 0.045, \\, 0.050, \\, 0.010 \\,] $\n- $ \\sigma_{GY} = [\\, 0.015, \\, 0.015, \\, 0.016, \\, 0.020, \\, 0.020 \\,] $\n\n测试用例D（平衡多效性；异质性但截距近似为零）：\n- $ \\beta_{GX} = [\\, 0.10, \\, 0.12, \\, 0.09, \\, 0.11, \\, 0.08 \\,] $\n- $ \\beta_{GY} = [\\, 0.080, \\, 0.052, \\, 0.064, \\, 0.056, \\, 0.048 \\,] $\n- $ \\sigma_{GY} = [\\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020, \\, 0.020 \\,] $\n\n实现和数值要求：\n- 将所有权重视为 $ w_i = 1 / \\sigma_{GY,i}^2 $。\n- 对于漏斗图，计算 $ \\theta_i = \\beta_{GY,i} / \\beta_{GX,i} $ 和 $ s_i = \\sigma_{GY,i} / \\lvert \\beta_{GX,i} \\rvert $。\n- 在漏斗图界限 $ \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i $ 中，使用 IVW 斜率作为合并效应。\n- 对于 IVW 模型下的 Cochran 异质性统计量，计算 $ Q $，然后计算 $ I^2 = \\max \\left( 0, \\, \\dfrac{Q - (M - 1)}{Q} \\right) $，其中 $ M $ 是变异体的数量。如果 $ Q = 0 $，则设 $ I^2 = 0 $。\n- 程序必须按以下顺序输出一个包含九个元素的列表：\n  1. IVW 斜率（浮点数），\n  2. MR-Egger 斜率（浮点数），\n  3. MR-Egger 截距（浮点数），\n  4. IVW Cochran $ Q $ 统计量（浮点数），\n  5. IVW $ I^2 $（浮点数），\n  6. 比率估计值列表 $ [ \\theta_i ] $，\n  7. 比率标准误列表 $ [ s_i ] $，\n  8. 漏斗图下界列表 $ [ \\theta_{\\text{IVW}} - 1.96 \\, s_i ] $，\n  9. 漏斗图上界列表 $ [ \\theta_{\\text{IVW}} + 1.96 \\, s_i ] $。\n- 将所有浮点数四舍五入至六位小数。\n- 最终输出格式：程序应生成单行输出，其中包含四个测试用例的结果，这些结果聚合为一个用方括号括起来的逗号分隔列表，且无空格。即，形式为 $ [r_A, r_B, r_C, r_D] $ 的单行，其中每个 $ r_\\cdot $ 是上述的九元素列表。\n\n边界条件和科学真实性：\n- 确保 $ \\lvert \\beta_{GX,i} \\rvert $ 不为零，以避免在比率计算中出现除以零的情况。所提供的测试套件满足此条件；一般而言，如果任何 $ \\lvert \\beta_{GX,i} \\rvert $ 低于某个小阈值 $ \\varepsilon $，则应在比率和漏斗图相关计算中排除该变异体，同时如果处理得当，在回归拟合中保持一致性。在此测试套件中，无需进行任何排除。", "solution": "该问题陈述经评估有效。它在科学上基于孟德尔随机化（MR）的既定原则，这是遗传流行病学中的一种标准方法。该问题定义明确，为所需的计算提供了所有必要的数据和明确的数学定义。其语言客观、正式，没有歧义或主观论断。它提出了一个基于可验证的统计学和数学原理的可解计算任务。\n\n我们现在将系统地推导所需的量。背景是使用遗传变异作为工具变量来估计暴露对结局的因果效应。对于 $M$ 个遗传变异（SNP）中的每一个，我们都给出了其与暴露的估计关联效应值 $\\beta_{GX,i}$、其与结局的估计关联效应值 $\\beta_{GY,i}$，以及后者的标准误 $\\sigma_{GY,i}$。\n\n所有加权计算的权重由结局方差的倒数定义，假设为此目的 $\\beta_{GX,i}$ 的不确定性可以忽略不计：\n$$\nw_i = \\frac{1}{\\sigma_{GY,i}^2}\n$$\n\n**1. 截距约束的逆方差加权 (IVW) 斜率**\n\nIVW 方法通过求解一个加权最小二乘问题来估计因果效应 $b$，该问题强制回归线通过原点。这对应于无水平多效性的假设。目标是最小化加权残差平方和：\n$$\nS(b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right)^2\n$$\n为求最小值，我们将关于 $b$ 的导数设为零：\n$$\n\\frac{dS}{db} = -2 \\sum_{i=1}^{M} w_i \\beta_{GX,i} \\left( \\beta_{GY,i} - b \\, \\beta_{GX,i} \\right) = 0\n$$\n求解 $b$ 可得 IVW 估计值，我们将其表示为 $\\theta_{\\text{IVW}}$：\n$$\n\\theta_{\\text{IVW}} = \\frac{\\sum_{i=1}^{M} w_i \\beta_{GX,i} \\beta_{GY,i}}{\\sum_{i=1}^{M} w_i \\beta_{GX,i}^2}\n$$\n\n**2. 孟德尔随机化 Egger (MR-Egger) 回归**\n\nMR-Egger 方法放宽了 IVW 方法的无多效性假设，允许在 $\\beta_{GY,i}$ 对 $\\beta_{GX,i}$ 的回归中存在非零截距。截距 $a$ 可被解释为平均方向性多效性效应的估计值，而斜率 $b$ 仍然是因果效应的估计值。我们对 $a$ 和 $b$ 最小化以下目标函数：\n$$\nS(a, b) = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - a - b \\, \\beta_{GX,i} \\right)^2\n$$\n这是一个标准的加权线性回归问题。MR-Egger 斜率（$b_{\\text{Egger}}$）和截距（$a_{\\text{Egger}}$）的解由正规方程给出：\n$$\nb_{\\text{Egger}} = \\frac{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i} \\beta_{GY,i}\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right) \\left(\\sum w_i \\beta_{GY,i}\\right) }{ \\left(\\sum w_i\\right) \\left(\\sum w_i \\beta_{GX,i}^2\\right) - \\left(\\sum w_i \\beta_{GX,i}\\right)^2 }\n$$\n$$\na_{\\text{Egger}} = \\frac{\\sum w_i \\beta_{GY,i}}{\\sum w_i} - b_{\\text{Egger}} \\frac{\\sum w_i \\beta_{GX,i}}{\\sum w_i}\n$$\n这些公式对应于加权最小二乘回归系数的标准解。\n\n**3. Cochran Q 统计量和 I² 异质性度量**\n\n工具变量特异性因果估计值之间的异质性可能表明 MR 假设（如多效性）被违反，或者真实因果效应对不同工具变量所针对的人群子集有所不同。IVW 模型的 Cochran $Q$ 统计量通过对单个比率估计值与合并 IVW 估计值之间的加权平方差求和来量化这种异质性。其计算公式为：\n$$\nQ = \\sum_{i=1}^{M} w_i \\left( \\frac{\\beta_{GY,i}}{\\beta_{GX,i}} - \\theta_{\\text{IVW}} \\right)^2 \\beta_{GX,i}^2 = \\sum_{i=1}^{M} w_i \\left( \\beta_{GY,i} - \\theta_{\\text{IVW}} \\beta_{GX,i} \\right)^2\n$$\n在同质性的零假设下（即所有工具变量估计相同的因果效应），$Q$ 服从自由度为 $M-1$ 的卡方分布。\n\n$I^2$ 统计量描述了由异质性而非抽样误差导致的工具变量间变异的百分比。它由 $Q$ 导出：\n$$\nI^2 = \\max\\left(0, \\frac{Q - (M-1)}{Q}\\right)\n$$\n如果 $Q=0$（这在实践中极不可能），$I^2$ 定义为 $0$。\n\n**4. 漏斗图组成部分**\n\n漏斗图是一种用于研究异质性和发表偏倚的可视化工具。它绘制了每个工具变量的效应大小与其精确度的度量。\n\n-   **每个变异体的比率估计值 ($\\theta_i$)：**这是从单个工具变量 $i$ 估计的因果效应：\n    $$\n    \\theta_i = \\frac{\\beta_{GY,i}}{\\beta_{GX,i}}\n    $$\n-   **比率估计值的标准误 ($s_i$)：**使用 delta 方法并假设 $\\beta_{GX,i}$ 的测量误差可忽略不计，$\\theta_i$ 的标准误近似为：\n    $$\n    s_i = \\text{SE}(\\theta_i) \\approx \\frac{\\sigma_{GY,i}}{\\lvert \\beta_{GX,i} \\rvert}\n    $$\n-   **漏斗图界限：**漏斗图围绕合并的 IVW 因果估计值 $\\theta_{\\text{IVW}}$ 构建。对于伪 95% 置信区间，每个变异体 $i$ 的界限为：\n    $$\n    \\text{Bounds}_i = \\theta_{\\text{IVW}} \\pm 1.96 \\, s_i\n    $$\n    下界和上界分别为 $\\theta_{\\text{IVW}} - 1.96 \\, s_i$ 和 $\\theta_{\\text{IVW}} + 1.96 \\, s_i$。\n\n实现将为每个提供的测试用例计算这九个量：IVW 斜率、MR-Egger 斜率和截距、IVW 拟合的 Cochran Q 和 $I^2$ 统计量，以及比率估计值列表、它们的标准误以及相应的漏斗图下界和上界。所有浮点数将按要求四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef calculate_mr_metrics(beta_gx: list[float], beta_gy: list[float], sigma_gy: list[float]) -> list:\n    \"\"\"\n    Computes Mendelian randomization metrics for a given set of summary statistics.\n\n    Args:\n        beta_gx: List of SNP-exposure associations.\n        beta_gy: List of SNP-outcome associations.\n        sigma_gy: List of standard errors for SNP-outcome associations.\n\n    Returns:\n        A list containing nine elements as specified in the problem description.\n    \"\"\"\n    # Convert lists to NumPy arrays for vectorized operations\n    bgx = np.array(beta_gx)\n    bgy = np.array(beta_gy)\n    sgy = np.array(sigma_gy)\n    \n    # 1. Weights\n    # w_i = 1 / sigma_GY,i^2\n    w = 1.0 / (sgy**2)\n    \n    # 2. IVW Slope (Intercept-constrained)\n    # theta_ivw = (sum w_i * beta_gx_i * beta_gy_i) / (sum w_i * beta_gx_i^2)\n    ivw_numerator = np.sum(w * bgx * bgy)\n    ivw_denominator = np.sum(w * bgx**2)\n    ivw_slope = ivw_numerator / ivw_denominator\n    \n    # 3. MR-Egger Slope and Intercept\n    # Weighted least squares regression of bgy on bgx with weights w\n    W = np.sum(w)\n    Swx = np.sum(w * bgx)\n    Swy = np.sum(w * bgy)\n    Swxx = np.sum(w * bgx**2)\n    Swxy = np.sum(w * bgx * bgy)\n    \n    egger_denominator = (W * Swxx - Swx**2)\n    if egger_denominator == 0:\n        # This case is unlikely with real data but handle for robustness\n        mr_egger_slope = np.nan\n        mr_egger_intercept = np.nan\n    else:\n        mr_egger_slope = (W * Swxy - Swx * Swy) / egger_denominator\n        mr_egger_intercept = (Swy / W) - mr_egger_slope * (Swx / W)\n\n    # 4. Cochran's Q for IVW\n    # Q = sum w_i * (beta_gy_i - theta_ivw * beta_gx_i)^2\n    cochran_q = np.sum(w * (bgy - ivw_slope * bgx)**2)\n    \n    # 5. I^2 for IVW\n    M = len(bgx)\n    df = M - 1\n    if cochran_q == 0:\n        i_squared = 0.0\n    else:\n        i_squared = max(0.0, (cochran_q - df) / cochran_q)\n\n    # 6. Ratio estimates (theta_i)\n    # theta_i = beta_gy_i / beta_gx_i\n    theta_i = bgy / bgx\n    \n    # 7. Ratio standard errors (s_i)\n    # s_i = sigma_gy_i / |beta_gx_i|\n    s_i = sgy / np.abs(bgx)\n    \n    # 8.  9. Funnel plot bounds\n    # lower/upper = theta_ivw +/- 1.96 * s_i\n    z_score = 1.96\n    funnel_lower_bounds = ivw_slope - z_score * s_i\n    funnel_upper_bounds = ivw_slope + z_score * s_i\n    \n    # Assemble results and round to 6 decimal places\n    results = [\n        round(ivw_slope, 6),\n        round(mr_egger_slope, 6),\n        round(mr_egger_intercept, 6),\n        round(cochran_q, 6),\n        round(i_squared, 6),\n        [round(val, 6) for val in theta_i],\n        [round(val, 6) for val in s_i],\n        [round(val, 6) for val in funnel_lower_bounds],\n        [round(val, 6) for val in funnel_upper_bounds],\n    ]\n    \n    return results\n\ndef format_result_list(res_list: list) -> str:\n    \"\"\"Formats a single test case result list into the required string format.\"\"\"\n    str_parts = []\n    for item in res_list:\n        if isinstance(item, list):\n            formatted_list = f\"[{','.join([f'{x:.6f}' for x in item])}]\"\n            str_parts.append(formatted_list)\n        else:\n            str_parts.append(f\"{item:.6f}\")\n    return f\"[{','.join(str_parts)}]\"\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = {\n        'A': {\n            \"beta_gx\": [0.08, 0.12, 0.10, 0.15, 0.07, 0.11],\n            \"beta_gy\": [0.040, 0.060, 0.051, 0.072, 0.033, 0.057],\n            \"sigma_gy\": [0.020, 0.018, 0.022, 0.019, 0.021, 0.020]\n        },\n        'B': {\n            \"beta_gx\": [0.05, -0.04, 0.09, 0.12, 0.03, 0.07],\n            \"beta_gy\": [0.037, 0.007, 0.048, 0.054, 0.029, 0.042],\n            \"sigma_gy\": [0.020, 0.021, 0.019, 0.018, 0.022, 0.020]\n        },\n        'C': {\n            \"beta_gx\": [0.20, 0.15, 0.10, 0.05, 0.004],\n            \"beta_gy\": [0.080, 0.070, 0.045, 0.050, 0.010],\n            \"sigma_gy\": [0.015, 0.015, 0.016, 0.020, 0.020]\n        },\n        'D': {\n            \"beta_gx\": [0.10, 0.12, 0.09, 0.11, 0.08],\n            \"beta_gy\": [0.080, 0.052, 0.064, 0.056, 0.048],\n            \"sigma_gy\": [0.020, 0.020, 0.020, 0.020, 0.020]\n        }\n    }\n\n    all_results_str = []\n    # Process cases in alphabetical order to match output format\n    for key in sorted(test_cases.keys()):\n        case = test_cases[key]\n        result = calculate_mr_metrics(case[\"beta_gx\"], case[\"beta_gy\"], case[\"sigma_gy\"])\n        all_results_str.append(format_result_list(result))\n\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2404096"}, {"introduction": "在完成MR分析后，评估结果的稳健性至关重要。本练习将介绍“留一法”（Leave-One-Out）敏感性分析，这是一种强有力的技术，用以检验总体因果效应估计是否被某单个遗传工具变量过度影响。通过系统地逐一移除每个工具变量并重新计算效应值，你可以识别出那些可能存在多效性且需要进一步研究的、具有强影响力的遗传变异 ([@problem_id:2404032])。", "problem": "给定多组单核苷酸多态性（SNP）工具变量的摘要级遗传关联数据，用于通过孟德尔随机化（MR）估计因果效应。对于一组 $K$ 个工具变量中的每个 SNP $i$，为您提供了四个实数：其与暴露的关联 $b_{X,i}$、其标准误 $s_{X,i}$、其与结局的关联 $b_{Y,i}$ 以及其标准误 $s_{Y,i}$。考虑以下模型：因果效应参数 $\\beta$ 被定义为加权残差平方和的唯一最小化子\n$$\nQ(\\beta) \\equiv \\sum_{i=1}^{K} w_i \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right)^2,\n$$\n其中工具变量 $i$ 的权重为 $w_i = 1/s_{Y,i}^2$。将完整数据估计量 $\\hat{\\beta}$ 定义为 $Q(\\beta)$ 的最小化子。对于每个索引 $j \\in \\{0,1,\\dots,K-1\\}$，将留一法子集估计量 $\\hat{\\beta}_{(-j)}$ 定义为在排除索引为 $j$ 的工具变量后的所有工具变量子集上计算的类似目标的最小化子。将工具变量 $j$ 的绝对影响定义为\n$$\nI_j \\equiv \\left|\\hat{\\beta}_{(-j)} - \\hat{\\beta}\\right|.\n$$\n令 $j^\\star$ 为实现最大绝对影响的索引，即 $j^\\star \\in \\arg\\max_{0 \\le j \\le K-1} I_j$。如果出现平局，选择最小的索引。\n\n任务是编写一个完整的、可运行的程序，为下面提供的测试套件中的每个工具变量集计算：\n- 索引 $j^\\star$，作为一个从零开始的整数，\n- 完整数据估计值 $\\hat{\\beta}$，\n- 有序列表 $\\left[\\hat{\\beta}_{(-0)}, \\hat{\\beta}_{(-1)}, \\dots, \\hat{\\beta}_{(-(K-1))}\\right]$。\n\n所有浮点输出必须四舍五入到小数点后恰好六位。最终的程序输出必须将所有测试用例的结果聚合到单行列表中，其中每个测试用例贡献一个形式为 $[j^\\star, \\hat{\\beta}, [\\hat{\\beta}_{(-0)}, \\dots, \\hat{\\beta}_{(-(K-1))}]]$ 的列表。因此，确切的输出格式为单行：\n\"[ [case1_jstar,case1_beta,[case1_loo_list]], [case2_jstar,case2_beta,[case2_loo_list]], ... ]\"\n除了默认逗号分隔符所显示的空格外，不添加任何额外的空格。\n\n测试套件（每个用例指定 $K$，后跟对齐的 $b_X$、$s_X$、$b_Y$、$s_Y$ 数组）：\n\n- 用例 A:\n  - $K = 6$\n  - $b_X = [0.10, 0.08, 0.12, 0.15, 0.09, 0.11]$\n  - $s_X = [0.01, 0.01, 0.01, 0.01, 0.01, 0.01]$\n  - $b_Y = [0.052, 0.039, 0.063, 0.073, 0.045, 0.125]$\n  - $s_Y = [0.02, 0.02, 0.02, 0.02, 0.02, 0.02]$\n\n- 用例 B:\n  - $K = 2$\n  - $b_X = [0.10, 0.12]$\n  - $s_X = [0.01, 0.01]$\n  - $b_Y = [0.050, 0.150]$\n  - $s_Y = [0.02, 0.02]$\n\n- 用例 C:\n  - $K = 5$\n  - $b_X = [0.07, 0.05, 0.005, 0.06, 0.08]$\n  - $s_X = [0.01, 0.01, 0.02, 0.01, 0.01]$\n  - $b_Y = [0.022, 0.014, 0.002, 0.018, 0.054]$\n  - $s_Y = [0.015, 0.015, 0.015, 0.015, 0.015]$\n\n- 用例 D:\n  - $K = 4$\n  - $b_X = [0.10, 0.10, 0.10, 0.10]$\n  - $s_X = [0.01, 0.01, 0.01, 0.01]$\n  - $b_Y = [0.050, 0.050, 0.110, -0.010]$\n  - $s_Y = [0.02, 0.02, 0.02, 0.02]$\n\n最终输出格式：\n- 程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个测试用例贡献一个如上所述形式的列表。例如（仅为示例）： \"[[0,0.123456,[0.120000,0.130000]], [1,0.500000,[0.600000,0.400000]]\"。\n- 不要打印任何额外的文本或空格。", "solution": "该问题要求实现一种算法，使用孟德尔随机化（MR）中的逆方差加权（IVW）方法计算因果效应估计值，并执行留一法（LOO）敏感性分析以识别最具影响力的工具变量。该问题在科学上是有效的、定义明确的，并且基于计算生物学中既定的统计学原理。\n\n问题的核心是找到最小化加权残差平方和的参数 $\\beta$，这是一个标准的加权最小二乘问题。目标函数为：\n$$\nQ(\\beta) \\equiv \\sum_{i=0}^{K-1} w_i \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right)^2\n$$\n这里，索引 $i$ 从 $0$ 到 $K-1$ 运行，以与从零开始的数组索引对齐。$K$ 个工具变量中每一个的输入是其与暴露的关联 $b_{X,i}$ 和与结局的关联 $b_{Y,i}$。每个工具变量对平方和的贡献权重由其结局关联方差的倒数给出，即 $w_i = 1/s_{Y,i}^2$。提供了暴露关联的标准误 $s_{X,i}$，但在本特定 IVW 模型中并未使用，该模型假设暴露关联中没有测量误差。\n\n为了找到最小化 $Q(\\beta)$ 的完整数据估计量 $\\hat{\\beta}$，我们对 $Q(\\beta)$ 关于 $\\beta$ 求导并将其设为零：\n$$\n\\frac{dQ(\\beta)}{d\\beta} = \\sum_{i=0}^{K-1} w_i \\cdot 2 \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right) \\cdot (-b_{X,i}) = 0\n$$\n$$\n\\sum_{i=0}^{K-1} w_i b_{X,i} \\left(b_{Y,i} - \\beta\\, b_{X,i}\\right) = 0\n$$\n$$\n\\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i} - \\beta \\sum_{i=0}^{K-1} w_i b_{X,i}^2 = 0\n$$\n求解 $\\beta$ 可得完整数据估计量 $\\hat{\\beta}$ 的封闭式解：\n$$\n\\hat{\\beta} = \\frac{\\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i}}{\\sum_{i=0}^{K-1} w_i b_{X,i}^2}\n$$\n该表达式等价于将 $b_Y$ 对 $b_X$ 进行加权线性回归且截距约束为零时的斜率。\n\n下一步是为每个工具变量 $j \\in \\{0, 1, \\dots, K-1\\}$ 计算留一法（LOO）估计量 $\\hat{\\beta}_{(-j)}$。估计量 $\\hat{\\beta}_{(-j)}$ 使用与 $\\hat{\\beta}$ 相同的公式计算，但求和是在除第 $j$ 个之外的所有工具变量上进行的。一种高效的计算方法是首先计算完整数据估计量的总和，然后减去第 $j$ 个工具变量的贡献。\n令 $S_{XY} = \\sum_{i=0}^{K-1} w_i b_{X,i} b_{Y,i}$ 和 $S_{XX} = \\sum_{i=0}^{K-1} w_i b_{X,i}^2$。完整数据估计量为 $\\hat{\\beta} = S_{XY} / S_{XX}$。\n那么，留一法估计量 $\\hat{\\beta}_{(-j)}$ 为：\n$$\n\\hat{\\beta}_{(-j)} = \\frac{\\sum_{i \\neq j} w_i b_{X,i} b_{Y,i}}{\\sum_{i \\neq j} w_i b_{X,i}^2} = \\frac{S_{XY} - w_j b_{X,j} b_{Y,j}}{S_{XX} - w_j b_{X,j}^2}\n$$\n\n工具变量 $j$ 的绝对影响，记为 $I_j$，定义为移除该工具变量时估计值的变化幅度：\n$$\nI_j = \\left|\\hat{\\beta}_{(-j)} - \\hat{\\beta}\\right|\n$$\n\n最后的任务是找到与最大绝对影响相对应的工具变量的索引 $j^\\star$。\n$$\nj^\\star = \\arg\\max_{0 \\le j \\le K-1} I_j\n$$\n如果影响值出现平局，问题规定应选择最小的索引 $j$。\n\n每个测试用例的总体算法如下：\n1.  接收输入数据：$K$，数组 $b_X$，$s_X$，$b_Y$ 和 $s_Y$。\n2.  为每个工具变量 $i$ 计算权重 $w_i = 1/s_{Y,i}^2$。\n3.  计算完整数据集的充分统计量：分子 $S_{XY} = \\sum w_i b_{X,i} b_{Y,i}$ 和分母 $S_{XX} = \\sum w_i b_{X,i}^2$。\n4.  计算完整数据估计值 $\\hat{\\beta} = S_{XY} / S_{XX}$。\n5.  从 $j=0$ 迭代到 $K-1$：\n    a. 通过从总和中减去第 $j$ 个工具变量的贡献来计算留一法估计值 $\\hat{\\beta}_{(-j)}$：$\\hat{\\beta}_{(-j)} = (S_{XY} - w_j b_{X,j} b_{Y,j}) / (S_{XX} - w_j b_{X,j}^2)$。\n    b. 将每个 $\\hat{\\beta}_{(-j)}$ 存储在一个有序列表中。\n6.  计算所有 $j$ 的绝对影响 $I_j = |\\hat{\\beta}_{(-j)} - \\hat{\\beta}|$。\n7.  找到使 $I_j$ 最大化的索引 $j^\\star$，若有平局则使用最小的索引。\n8.  将浮点值（$\\hat{\\beta}$ 和所有 $\\hat{\\beta}_{(-j)}$）四舍五入到小数点后六位。\n9.  将该测试用例的结果格式化为 $[j^\\star, \\hat{\\beta}, [\\hat{\\beta}_{(-0)}, \\dots, \\hat{\\beta}_{(-(K-1))}]]$，并将所有测试用例的结果按规定聚合到单行输出中。\n此过程将使用 `numpy` 库在 Python 中实现，以进行高效的数组计算。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Mendelian Randomization problem for a suite of test cases.\n\n    For each case, it computes the full-data causal effect estimate (`beta_hat`),\n    the leave-one-out estimates (`loo_betas`), and the index of the most\n    influential instrument (`j_star`).\n    \"\"\"\n    test_cases = [\n        {\n            \"K\": 6,\n            \"b_X\": [0.10, 0.08, 0.12, 0.15, 0.09, 0.11],\n            \"s_X\": [0.01, 0.01, 0.01, 0.01, 0.01, 0.01],\n            \"b_Y\": [0.052, 0.039, 0.063, 0.073, 0.045, 0.125],\n            \"s_Y\": [0.02, 0.02, 0.02, 0.02, 0.02, 0.02],\n        },\n        {\n            \"K\": 2,\n            \"b_X\": [0.10, 0.12],\n            \"s_X\": [0.01, 0.01],\n            \"b_Y\": [0.050, 0.150],\n            \"s_Y\": [0.02, 0.02],\n        },\n        {\n            \"K\": 5,\n            \"b_X\": [0.07, 0.05, 0.005, 0.06, 0.08],\n            \"s_X\": [0.01, 0.01, 0.02, 0.01, 0.01],\n            \"b_Y\": [0.022, 0.014, 0.002, 0.018, 0.054],\n            \"s_Y\": [0.015, 0.015, 0.015, 0.015, 0.015],\n        },\n        {\n            \"K\": 4,\n            \"b_X\": [0.10, 0.10, 0.10, 0.10],\n            \"s_X\": [0.01, 0.01, 0.01, 0.01],\n            \"b_Y\": [0.050, 0.050, 0.110, -0.010],\n            \"s_Y\": [0.02, 0.02, 0.02, 0.02],\n        },\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        b_x = np.array(case[\"b_X\"])\n        b_y = np.array(case[\"b_Y\"])\n        s_y = np.array(case[\"s_Y\"])\n\n        # Calculate weights w_i = 1/s_{Y,i}^2\n        w = 1.0 / (s_y**2)\n\n        # Calculate terms for the full-data estimator\n        num_full = np.sum(w * b_x * b_y)\n        den_full = np.sum(w * b_x**2)\n\n        # Handle division by zero if all b_x are zero, though not expected\n        if den_full == 0:\n            beta_hat = np.nan\n        else:\n            beta_hat = num_full / den_full\n\n        # Calculate leave-one-out (LOO) estimators\n        # Individual contributions to numerator and denominator\n        num_i = w * b_x * b_y\n        den_i = w * b_x**2\n\n        # Subtract individual contributions from the full sums\n        loo_nums = num_full - num_i\n        loo_dens = den_full - den_i\n        \n        # Avoid division by zero in LOO calculation\n        # If loo_den is 0, the corresponding beta is undefined. This can happen\n        # if after removing one instrument, all remaining b_x are zero.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            loo_betas = np.divide(loo_nums, loo_dens)\n            loo_betas[np.isinf(loo_betas)] = np.nan\n\n        # Calculate absolute influence I_j = |beta_{(-j)} - beta|\n        influences = np.abs(loo_betas - beta_hat)\n\n        # Find index j_star with max influence.\n        # np.argmax returns the first occurrence in case of a tie, satisfying the rule.\n        j_star = np.nanargmax(influences) if not np.all(np.isnan(influences)) else -1\n\n        # Format results for this case.\n        # Rounding is handled by string formatting to 6 decimal places.\n        beta_hat_str = f\"{beta_hat:.6f}\"\n        loo_betas_str_list = [f\"{b:.6f}\" for b in loo_betas]\n        loo_list_str = f\"[{','.join(loo_betas_str_list)}]\"\n        case_result_str = f\"[{j_star},{beta_hat_str},{loo_list_str}]\"\n        \n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2404032"}]}