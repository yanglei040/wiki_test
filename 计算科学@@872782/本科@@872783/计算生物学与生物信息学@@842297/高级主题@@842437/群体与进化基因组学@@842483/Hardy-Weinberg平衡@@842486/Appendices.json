{"hands_on_practices": [{"introduction": "哈代-温伯格定律为不发生演化的种群提供了一个数学基准。一项基本技能是从已知的等位基因频率计算预期的基因型频率。第一个练习 [@problem_id:1852915] 将在一个不完全显性的场景中引导你完成这一核心过程，其中每种基因型都有独特的表型。通过首先根据观测到的种群计数计算等位基因频率，你将接着预测杂合子的预期比例，从而掌握哈代-温伯格平衡模型的基本计算方法。", "problem": "一个由保护生物学家组成的团队正在监测一个大型、孤立的稀有天瓣兰 (*Orchis caelestis*) 种群。该物种的花色由一对表现为不完全显性的等位基因决定。蓝色花瓣的等位基因用 $C^B$ 表示，白色花瓣的等位基因用 $C^W$ 表示。基因型为 $C^B C^B$ 的植株开蓝色花，基因型为 $C^W C^W$ 的植株开白色花，而杂合子植株（$C^B C^W$）开浅蓝色花。\n\n在最近的一次野外调查中，生物学家们统计了每种表型植株的数量。他们的普查数据显示：\n- 721 株开蓝色花\n- 438 株开浅蓝色花\n- 71 株开白色花\n\n假设该种群符合 Hardy-Weinberg 平衡的条件（即随机交配，且没有突变、选择、基因流或遗传漂变），请计算下一代中杂合子个体的预期频率。报告你的答案，结果保留三位有效数字。", "solution": "设 $p$ 为等位基因 $C^{B}$ 的频率，$q$ 为等位基因 $C^{W}$ 的频率，且 $p+q=1$。在 Hardy-Weinberg 平衡下，基因型频率分别为 $C^{B}C^{B}$（蓝色）为 $p^{2}$，$C^{B}C^{W}$（浅蓝色）为 $2pq$，$C^{W}C^{W}$（白色）为 $q^{2}$。\n\n根据普查数据：\n- $N_{BB}=721$,\n- $N_{BW}=438$,\n- $N_{WW}=71$,\n- $N=N_{BB}+N_{BW}+N_{WW}=721+438+71=1230$.\n\n等位基因频率可通过基因型计数计算得出：\n$$\np=\\frac{2N_{BB}+N_{BW}}{2N}, \\quad q=\\frac{2N_{WW}+N_{BW}}{2N}=1-p.\n$$\n代入计数值，\n$$\np=\\frac{2\\cdot 721+438}{2\\cdot 1230}=\\frac{1880}{2460}=\\frac{94}{123}, \\quad q=1-\\frac{94}{123}=\\frac{29}{123}.\n$$\n在 Hardy-Weinberg 平衡下，下一代中杂合子的预期频率为\n$$\n2pq=2\\left(\\frac{94}{123}\\right)\\left(\\frac{29}{123}\\right)=\\frac{5452}{15129}\\approx 0.360367\\ldots\n$$\n保留三位有效数字，结果为 $0.360$。", "answer": "$$\\boxed{0.360}$$", "id": "1852915"}, {"introduction": "一旦我们能够预测预期频率，我们如何确定观测到的种群数据是否显著偏离了这一预期？本练习 [@problem_id:2396513] 介绍了卡方 ($\\chi^2$) 拟合优度检验，这是群体遗传学中统计分析的基石。本练习不仅是简单地执行检验，你还将分解 $\\chi^2$ 统计量，以查明哪种基因型的偏差对总体结果的贡献最大。这种诊断性方法对于形成关于潜在演化动力的假说至关重要。", "problem": "在一个由 $n$ 个二倍体个体组成的队列中，对一个双等位基因的常染色体基因座进行了基因分型。观察到的基因型计数为 $O_{AA}=150$，$O_{Aa}=300$ 和 $O_{aa}=50$，因此 $n=500$。在哈代-温伯格平衡 (HWE) 的零假设下，使用该样本估计等位基因 $A$ 的频率，然后得出相应的预期基因型计数。基于这些预期计数，使用 HWE 的卡方 ($\\chi^{2}$) 拟合优度检验框架，计算每个基因型 $g\\in\\{AA,Aa,aa\\}$ 的贡献 $\\left(O_{g}-E_{g}\\right)^{2}/E_{g}$，并确定最大的单个贡献值。仅报告此最大单基因型贡献的数值。将您的答案四舍五入至三位有效数字。", "solution": "第一步是从观察到的样本数据中估计等位基因频率。设 $\\hat{p}$ 为等位基因 $A$ 的估计频率，$\\hat{q}$ 为等位基因 $a$ 的估计频率。在 $n=500$ 个二倍体个体的样本中，等位基因总数为 $2n = 1000$。等位基因 $A$ 的频率通过计算所有 $A$ 等位基因的数量并除以等位基因总数来得出。\n\n$A$ 等位基因的数量由 $2 \\times O_{AA} + O_{Aa}$ 给出。\n$$ \\text{数量}(A) = 2 \\times 150 + 300 = 300 + 300 = 600 $$\n因此，等位基因 $A$ 的估计频率为：\n$$ \\hat{p} = \\frac{2 \\times O_{AA} + O_{Aa}}{2n} = \\frac{600}{1000} = 0.6 $$\n\n同样地，$a$ 等位基因的数量由 $2 \\times O_{aa} + O_{Aa}$ 给出。\n$$ \\text{数量}(a) = 2 \\times 50 + 300 = 100 + 300 = 400 $$\n等位基因 $a$ 的估计频率为：\n$$ \\hat{q} = \\frac{2 \\times O_{aa} + O_{Aa}}{2n} = \\frac{400}{1000} = 0.4 $$\n作为必要的检查，等位基因频率之和必须为 1：$\\hat{p} + \\hat{q} = 0.6 + 0.4 = 1.0$。这是正确的。\n\n接下来，在哈代-温伯格平衡的零假设下，我们使用这些估计的等位基因频率计算预期基因型计数 ($E_{g}$)。预期的基因型频率为 $P(AA) = \\hat{p}^2$、$P(Aa) = 2\\hat{p}\\hat{q}$ 和 $P(aa) = \\hat{q}^2$。预期计数是这些频率乘以总样本量 $n$。\n\n基因型 $AA$ 的预期计数为：\n$$ E_{AA} = n \\times \\hat{p}^2 = 500 \\times (0.6)^2 = 500 \\times 0.36 = 180 $$\n\n基因型 $Aa$ 的预期计数为：\n$$ E_{Aa} = n \\times 2\\hat{p}\\hat{q} = 500 \\times 2 \\times 0.6 \\times 0.4 = 500 \\times 0.48 = 240 $$\n\n基因型 $aa$ 的预期计数为：\n$$ E_{aa} = n \\times \\hat{q}^2 = 500 \\times (0.4)^2 = 500 \\times 0.16 = 80 $$\n作为检查，预期计数之和必须等于总样本量：$E_{AA} + E_{Aa} + E_{aa} = 180 + 240 + 80 = 500 = n$。这也是正确的。\n\n最后，我们使用公式 $\\frac{(O_{g}-E_{g})^{2}}{E_{g}}$ 计算每个基因型对卡方统计量的贡献。\n\n对于基因型 $AA$：\n$$ \\chi_{AA}^2 = \\frac{(O_{AA} - E_{AA})^2}{E_{AA}} = \\frac{(150 - 180)^2}{180} = \\frac{(-30)^2}{180} = \\frac{900}{180} = 5 $$\n\n对于基因型 $Aa$：\n$$ \\chi_{Aa}^2 = \\frac{(O_{Aa} - E_{Aa})^2}{E_{Aa}} = \\frac{(300 - 240)^2}{240} = \\frac{(60)^2}{240} = \\frac{3600}{240} = 15 $$\n\n对于基因型 $aa$：\n$$ \\chi_{aa}^2 = \\frac{(O_{aa} - E_{aa})^2}{E_{aa}} = \\frac{(50 - 80)^2}{80} = \\frac{(-30)^2}{80} = \\frac{900}{80} = 11.25 $$\n\n每个基因型的贡献分别为 $5$、$15$ 和 $11.25$。问题要求找出最大的单个贡献值。\n$$ \\max(\\chi_{AA}^2, \\chi_{Aa}^2, \\chi_{aa}^2) = \\max(5, 15, 11.25) = 15 $$\n该值为整数。问题指定四舍五入到三位有效数字。数字 $15$ 有两位有效数字。要用三位有效数字表示，必须写成 $15.0$。", "answer": "$$\\boxed{15.0}$$", "id": "2396513"}, {"introduction": "当一个种群表现出对哈代-温伯格平衡的显著偏离时——例如杂合子缺失——我们的分析可以从单纯的检验转向对潜在原因进行建模。这个高级练习 [@problem_id:2396508] 通过引入赖特（Wright）的近交系数 $F$ 来探讨近亲繁殖这一导致此类偏离的常见原因。你将运用强大的计算统计学方法，特别是最大似然估计（MLE）和似然比置信区间，从基因型数据中估计 $F$ 的值。这个练习代表了一次飞跃，使我们能够量化作用于种群的特定演化或婚配系统过程。", "problem": "给定一个双等位基因座上的基因型计数数据，其等位基因表示为 $A$ 和 $a$。设 $n_{\\mathrm{AA}}$、$n_{\\mathrm{Aa}}$ 和 $n_{\\mathrm{aa}}$ 分别表示在样本量为 $N = n_{\\mathrm{AA}} + n_{\\mathrm{Aa}} + n_{\\mathrm{aa}}$ 的样本中，三种基因型 $AA$、$Aa$ 和 $aa$ 的观测计数。假设采用 Wright 近交模型，其中近交系数为 $F \\in [0,1]$，等位基因 $A$ 的频率为 $p \\in (0,1)$，等位基因 $a$ 的频率为 $q = 1 - p$。在此模型下，基因型概率为\n$$\n\\Pr(AA) = p^2 + F p q,\\quad \\Pr(Aa) = 2 p q (1 - F),\\quad \\Pr(aa) = q^2 + F p q.\n$$\n假设在给定 $N$ 的情况下，$(n_{\\mathrm{AA}}, n_{\\mathrm{Aa}}, n_{\\mathrm{aa}})$ 服从多项分布抽样模型，请编写一个程序，为每个提供的测试用例计算：\n- 在约束条件 $p \\in (0,1)$ 和 $F \\in [0,1]$ 下，通过联合最大化 $(p,F)$ 的对数似然，得到近交系数 $F$ 的最大似然估计 (MLE)，记为 $\\hat F$。\n- $F$ 的一个置信水平为 $0.95$ 的双侧置信区间，定义为满足以下条件的 $F$ 值集合\n$$\n2\\bigl(\\ell(\\hat p,\\hat F) - \\ell(\\hat p_F, F)\\bigr) \\le \\chi^2_{1,\\,0.95},\n$$\n其中 $\\ell(p,F)$ 是多项对数似然（相差一个可加常数），$(\\hat p,\\hat F)$ 是 $\\ell$ 的联合最大化者，对于每个固定的 $F$，$\\hat p_F$ 是在 $p \\in (0,1)$ 上使 $\\ell(p,F)$ 最大化的值。此处 $\\chi^2_{1,\\,0.95}$ 表示自由度为 $1$ 的卡方分布的 $0.95$ 分位数。将区间报告为其下界和上界，当似然比接受域触及边界时，将端点截断到可行参数空间 $[0,1]$。\n\n您的程序必须硬编码并评估以下基因型计数 $(n_{\\mathrm{AA}}, n_{\\mathrm{Aa}}, n_{\\mathrm{aa}})$ 的测试套件：\n- 测试用例 1：$(82, 77, 41)$。\n- 测试用例 2：$(0, 100, 0)$。\n- 测试用例 3：$(40, 0, 60)$。\n- 测试用例 4：$(45, 210, 245)$。\n- 测试用例 5：$(99, 1, 0)$。\n\n对于每个测试用例，输出一个三元组 $[\\hat F, L, U]$，其中 $\\hat F$ 是 $F$ 的最大似然估计，$[L,U]$ 是上述定义的 $F$ 的 $0.95$ 置信水平的置信区间。所有三个值都必须是四舍五入到恰好 $6$ 位小数的实数。\n\n您的程序应生成单行输出，其中包含结果，格式为一个由五个三元组组成的逗号分隔列表，该列表被方括号括起，并保留内部的方括号。例如，一个包含两个假设用例的输出应如下所示\n$[[0.123456,0.000000,0.345678],[0.000000,0.000000,0.456789]]$\n但应包含与上述五个测试用例相对应的五个三元组。输出中不允许有任何额外的文本或空白字符。", "solution": "该问题要求计算 Wright 近交模型参数的最大似然估计 (MLEs)，并构建近交系数 $F$ 的置信区间。这是统计遗传学中的一个标准问题，可以使用数值优化和似然比理论来解决。\n\n该问题具有科学依据，是良定的，并且提供了获得唯一解所需的所有信息。我们继续进行推导。\n\n模型的参数是等位基因 $A$ 的频率 $p \\in (0,1)$ 和近交系数 $F \\in [0,1]$。令 $q = 1-p$。基因型概率给出如下：\n$$ \\Pr(AA) = P_{AA} = p^2 + Fpq $$\n$$ \\Pr(Aa) = P_{Aa} = 2pq(1-F) $$\n$$ \\Pr(aa) = P_{aa} = q^2 + Fpq $$\n\n给定从样本量为 $N = n_{\\mathrm{AA}} + n_{\\mathrm{Aa}} + n_{\\mathrm{aa}}$ 的样本中观测到的基因型计数 $(n_{\\mathrm{AA}}, n_{\\mathrm{Aa}}, n_{\\mathrm{aa}})$，抽样过程服从多项分布。对数似然函数（相差一个可加常数）为：\n$$ \\ell(p, F) = n_{\\mathrm{AA}} \\log(P_{AA}) + n_{\\mathrm{Aa}} \\log(P_{Aa}) + n_{\\mathrm{aa}} \\log(P_{aa}) $$\n我们的任务是找到联合最大化该函数的最大似然估计 $(\\hat p, \\hat F)$，然后为 $F$ 构建置信区间。\n\n**1. 最大似然估计**\n\n联合最大似然估计 $(\\hat p, \\hat F)$ 是在约束条件 $p \\in (0,1)$ 和 $F \\in [0,1]$ 下使 $\\ell(p,F)$ 最大化的 $(p,F)$ 值。这是一个二维优化问题。由于 $\\ell(p,F)$ 的偏导数形式复杂，不易获得闭式解。因此，我们必须使用数值方法。\n\n其过程是在指定的参数空间上最小化负对数似然函数 $-\\ell(p,F)$。我们将采用一种能够处理箱式约束的数值优化算法，例如 L-BFGS-B。\n\n为了给优化器提供一个好的起始点，我们可以计算初始估计值。样本等位基因频率 $\\tilde{p} = (2n_{\\mathrm{AA}} + n_{\\mathrm{Aa}})/(2N)$ 是 $\\hat p$ 的一个极佳初始猜测。$F$ 的矩估计量由 $F_{mom} = 1 - H_{obs}/H_{exp}$ 给出，其中 $H_{obs} = n_{\\mathrm{Aa}}/N$ 且 $H_{exp} = 2\\tilde{p}(1-\\tilde{p})$，可以作为 $\\hat F$ 的初始猜测。这个对 $F$ 的初始猜测值会被裁剪到有效范围 $[0,1]$ 内。\n\n优化过程将得出最大似然估计 $(\\hat p, \\hat F)$ 和对数似然的最大值 $\\ell_{max} = \\ell(\\hat p, \\hat F)$。\n\n**2. F 的置信区间**\n\n问题要求基于似然比检验 (LRT) 构建 $F$ 的 $95\\%$ 置信区间。用于检验原假设 $H_0: F = F_0$ 的 LRT 统计量由下式给出：\n$$ LR(F_0) = 2 \\left( \\ell(\\hat p, \\hat F) - \\sup_{p \\in (0,1)} \\ell(p, F_0) \\right) $$\n在原假设下，该统计量渐近服从自由度为 $1$（自由参数数量之差）的卡方随机变量。项 $\\sup_{p \\in (0,1)} \\ell(p, F_0)$ 表示 $F_0$ 的剖面对数似然，其中对于一个固定的 $F_0$，我们找到使似然最大化的 $p$ 值，记为 $\\hat p_{F_0}$。我们将剖面对数似然表示为 $\\ell_{profile}(F) = \\ell(\\hat p_F, F)$。\n\n$F$ 的 $95\\%$ 置信区间是所有在显著性水平 $\\alpha = 0.05$ 下不会被 LRT 拒绝的 $F_0$ 值的集合。这是满足以下条件的 $F_0$ 集合：\n$$ LR(F_0) \\le \\chi^2_{1, 1-\\alpha} $$\n其中 $\\chi^2_{1, 0.95} \\approx 3.841459$ 是自由度为 $1$ 的卡方分布的 $0.95$ 分位数。\n\n为了找到这个区间的端点，我们必须求解方程 $LR(F) = \\chi^2_{1, 0.95}$ 来得到 $F$。这等价于找到以下函数的根：\n$$ h(F) = 2 \\left( \\ell_{max} - \\ell_{profile}(F) \\right) - \\chi^2_{1, 0.95} = 0 $$\n函数 $h(F)$ 在 $F=\\hat F$ 处有最小值，其中 $h(\\hat F) = -\\chi^2_{1, 0.95}  0$。对应于置信区间下界 $L$ 和上界 $U$ 的 $h(F)=0$ 的根位于 $\\hat F$ 的两侧。\n\n找到置信区间 $[L, U]$ 的算法如下：\n1.  计算 $\\hat F$ 和 $\\ell_{max} = \\ell(\\hat p, \\hat F)$。\n2.  定义目标常数 $C = \\chi^2_{1, 0.95}$。\n3.  定义函数 $h(F) = 2(\\ell_{max} - \\ell_{profile}(F)) - C$。\n4.  为了找到下界 $L$：\n    - 计算 $h(0)$。如果 $h(0) \\le 0$，则接受域的下半部分超出了 $0$。问题规定将区间截断到可行空间，因此我们设 $L=0$。\n    - 如果 $h(0)  0$，则在 $[0, \\hat F]$ 中存在一个根。我们用数值方法（例如，使用 Brent 方法）找到这个根。这个根就是 $L$。\n5.  为了找到上界 $U$：\n    - 计算 $h(1)$。如果 $h(1) \\le 0$，则接受域的上半部分超出了 $1$。我们设 $U=1$。\n    - 如果 $h(1)  0$，则在 $[\\hat F, 1]$ 中存在一个根。我们用数值方法找到这个根，即为 $U$。\n\n这个过程正确处理了 MLE $\\hat F$ 位于参数空间 $[0,1]$ 边界上的情况。例如，如果 $\\hat F = 0$，那么 $h(0) = h(\\hat F) = -C  0$，这正确地导致 $L=0$。\n\n实现将利用 `scipy.optimize` 库中的函数进行所需的数值优化和求根。必须注意处理潜在的数值问题，例如对零取对数，这可能在参数空间的边界上发生，特别是当某些基因型计数为零时。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\nfrom scipy.optimize import minimize, minimize_scalar, brentq\n\ndef solve():\n    \"\"\"\n    Computes the MLE of the inbreeding coefficient F and its 95% likelihood-ratio\n    confidence interval for a series of genotype count datasets.\n    \"\"\"\n    test_cases = [\n        (82, 77, 41),\n        (0, 100, 0),\n        (40, 0, 60),\n        (45, 210, 245),\n        (99, 1, 0),\n    ]\n\n    results = []\n    \n    # Critical value for the chi-squared distribution\n    CHI2_CRIT = chi2.ppf(0.95, 1)\n\n    for case in test_cases:\n        n_AA, n_Aa, n_aa = case\n        N = n_AA + n_Aa + n_aa\n\n        # Define the negative log-likelihood function\n        def neg_log_likelihood(params, n_AA, n_Aa, n_aa):\n            p, F = params\n            # Constraints are handled by the optimizer's bounds\n            q = 1.0 - p\n\n            # Initialize log-probabilities\n            log_L = 0.0\n\n            # Term for AA\n            if n_AA  0:\n                prob_AA = p**2 + F * p * q\n                if prob_AA = 0: return np.inf\n                log_L += n_AA * np.log(prob_AA)\n            \n            # Term for Aa\n            if n_Aa  0:\n                if F = 1.0: return np.inf\n                prob_Aa = 2.0 * p * q * (1.0 - F)\n                if prob_Aa = 0: return np.inf\n                log_L += n_Aa * np.log(prob_Aa)\n\n            # Term for aa\n            if n_aa  0:\n                prob_aa = q**2 + F * p * q\n                if prob_aa = 0: return np.inf\n                log_L += n_aa * np.log(prob_aa)\n\n            return -log_L\n\n        # --- Part 1: MLE Calculation ---\n        \n        # Initial guesses for p and F\n        p_tilde = (2 * n_AA + n_Aa) / (2 * N) if N  0 else 0.5\n        p_tilde = np.clip(p_tilde, 1e-9, 1 - 1e-9)\n        \n        h_exp = 2 * p_tilde * (1 - p_tilde)\n        if h_exp  0:\n            f_mom = 1 - (n_Aa / N) / h_exp\n        else: # p_tilde is 0 or 1\n            f_mom = 1.0 if n_Aa == 0 else 0.0\n        f_init = np.clip(f_mom, 0.0, 1.0)\n\n        # 2D optimization to find joint MLE (p_hat, f_hat)\n        opt_res = minimize(\n            neg_log_likelihood,\n            x0=[p_tilde, f_init],\n            args=(n_AA, n_Aa, n_aa),\n            method='L-BFGS-B',\n            bounds=[(1e-9, 1 - 1e-9), (0, 1)]\n        )\n\n        p_hat, f_hat = opt_res.x\n        max_log_L = -opt_res.fun\n\n        # --- Part 2: Confidence Interval ---\n\n        # Function to compute profile log-likelihood for a fixed F\n        def get_profile_log_L(F_val):\n            # 1D optimization to find p_hat for the given F\n            def profile_neg_log_L_p(p):\n                return neg_log_likelihood([p, F_val], n_AA, n_Aa, n_aa)\n\n            # Handle F=1 case where n_Aa  0 - log-L = -inf\n            if F_val = 1.0 and n_Aa  0:\n                 return -np.inf\n            \n            p_start = (2 * n_AA + n_Aa) / (2 * N) if N  0 else 0.5\n\n            res_p = minimize_scalar(\n                profile_neg_log_L_p,\n                bounds=(1e-9, 1 - 1e-9),\n                method='bounded',\n                options={'xatol': 1e-10}\n            )\n            return -res_p.fun\n\n        # Function h(F) = 2*(l_max - l_profile(F)) - C = 0\n        def h_func(F_val):\n            return 2 * (max_log_L - get_profile_log_L(F_val)) - CHI2_CRIT\n\n        # Find lower bound L\n        lower_bound = 0.0\n        # If f_hat is effectively 0, L is 0. Otherwise check root.\n        if f_hat  1e-9:\n            try:\n                # If h(0)  0, L is truncated to 0.\n                if h_func(0)  0:\n                    lower_bound = brentq(h_func, 0, f_hat, xtol=1e-10, rtol=1e-10)\n            except ValueError:\n                # Can happen if h(0) and h(f_hat) have same sign, means L=0\n                pass\n        \n        # Find upper bound U\n        upper_bound = 1.0\n        # If f_hat is effectively 1, U is 1. Otherwise check root.\n        if f_hat  1.0 - 1e-9:\n            try:\n                # If h(1)  0, U is truncated to 1.\n                if h_func(1.0)  0:\n                     upper_bound = brentq(h_func, f_hat, 1.0, xtol=1e-10, rtol=1e-10)\n            except ValueError:\n                # Can happen if h(1) and h(f_hat) have same sign, means U=1\n                pass\n        \n        results.append([f_hat, lower_bound, upper_bound])\n\n    # Format output\n    formatted_results = []\n    for res in results:\n        formatted_results.append(f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\")\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2396508"}]}