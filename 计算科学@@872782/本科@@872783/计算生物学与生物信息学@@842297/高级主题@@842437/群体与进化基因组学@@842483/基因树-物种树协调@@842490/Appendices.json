{"hands_on_practices": [{"introduction": "这项入门练习是理解基因树-物种树调和中事件计数的绝佳起点[@problem_id:2394119]。通过一个简化的场景，你将运用重复-丢失（Duplication-Loss）模型来寻找能够解释当前物种基因拷贝数的最简约演化路径。这个过程会让你熟悉简约性原则，并理解在祖先节点的不同假设是如何影响推断出的重复与丢失事件数量的。", "problem": "考虑一个单基因家族沿着一棵有根二叉物种树 $\\left(A,B\\right)$ 演化，其中 $A$ 和 $B$ 是仅有的现存物种。假设该基因家族在标准的复制-丢失（Duplication–Loss, DL）模型下演化，并满足以下条件：（i）基因复制事件使其发生所在的谱系中的拷贝数增加 $1$，（ii）基因丢失事件使其发生所在的谱系中移除一个拷贝，（iii）不存在水平基因转移和不完全谱系分选，以及（iv）该基因家族在 $A$ 和 $B$ 的最近共同祖先中以单拷贝形式存在。您观察到一个基因树，其叶节点通过序列标签映射到物种：三个叶节点来自物种 $A$，一个叶节点来自物种 $B$（即，在 $A$ 中有 $3$ 个现存拷贝，在 $B$ 中有 $1$ 个现存拷贝）。该基因树的内部拓扑结构是未指定的。在所有与这些观察结果和DL模型一致的调和方案中，确定解释所观察到的现今拷贝数所需的最少基因复制事件数 $d$ 和最少基因丢失事件数 $\\ell$。将您的答案以两个整数 $d$ 和 $\\ell$ 的形式报告。无需四舍五入。", "solution": "所陈述的问题定义明确，并基于计算生物学的标准原理。我们可以进行形式化的求解。\n\n设 $S$ 为有根二叉物种树。$S$ 的叶节点是现存物种 $A$ 和 $B$。设 $R$ 表示 $S$ 的根节点，即 $A$ 和 $B$ 的最近共同祖先（LCA）。因此，该物种树的结构由根节点 $R$ 及其下的两个分支确定，一个分支通向叶节点 $A$，另一个通向叶节点 $B$。\n\n我们已知该基因家族在现存物种中的拷贝数：$c(A) = 3$ 和 $c(B) = 1$。该基因家族的演化遵循复制-丢失（DL）模型，没有水平基因转移。问题陈述该基因家族“在 $A$ 和 $B$ 的最近共同祖先中以单拷贝形式存在”。这为拷贝数演化确立了根节点的条件。一个关键步骤是通过考虑在节点 $R$ 发生分化时存在的基因拷贝数，来确定最简约的情景。\n\n设 $k$ 为物种分化事件发生前，祖先物种 $R$ 中存在的基因拷贝数。单个祖先基因的初始条件意味着，从一个拷贝的初始状态（在 $R$ 的某个祖先处）达到 $k$ 个拷贝，在通向 $R$ 的分支上至少需要 $\\max(0, k-1)$ 次复制事件和 $\\max(0, 1-k)$ 次丢失事件。由于我们寻求最少的事件数，我们可以假设 $k \\ge 1$，因此达到 $k$ 个拷贝的代价是 $k-1$ 次复制。\n\n在节点 $R$ 的物种分化事件中，所有 $k$ 个基因拷贝都传递给了两个子谱系。因此，通向物种 $A$ 的谱系以 $k$ 个拷贝开始，通向物种 $B$ 的谱系也以 $k$ 个拷贝开始。\n\n我们现在分析每个分支上为匹配叶节点处观察到的拷贝数所需的事件数量。在单个谱系上，将拷贝数从起始值 $c_{start}$ 变为结束值 $c_{end}$ 所需的最小事件数是 $|c_{end} - c_{start}|$。这包括 $\\max(0, c_{end} - c_{start})$ 次复制和 $\\max(0, c_{start} - c_{end})$ 次丢失。\n\n对于通向 $A$ 的谱系：\n拷贝数从 $k$ 变为 $c(A) = 3$。\n复制次数为 $d_A(k) = \\max(0, 3-k)$。\n丢失次数为 $\\ell_A(k) = \\max(0, k-3)$。\n\n对于通向 $B$ 的谱系：\n拷贝数从 $k$ 变为 $c(B) = 1$。\n复制次数为 $d_B(k) = \\max(0, 1-k)$。\n丢失次数为 $\\ell_B(k) = \\max(0, k-1)$。\n\n对于给定的物种分化时的拷贝数 $k$，总复制次数 $d(k)$ 和总丢失次数 $\\ell(k)$ 是根分支上和其下分支上事件数的总和：\n$d(k) = (k-1) + d_A(k) + d_B(k) = (k-1) + \\max(0, 3-k) + \\max(0, 1-k)$\n$\\ell(k) = \\ell_A(k) + \\ell_B(k) = \\max(0, k-3) + \\max(0, k-1)$\n这里假设 $k \\ge 1$。\n\n我们必须找到使总事件数 $d(k) + \\ell(k)$ 最小化的 $k$ 值。让我们针对 $k \\ge 1$ 的较小整数值进行评估：\n\n情况 $k=1$：\n$d(1) = (1-1) + \\max(0, 3-1) + \\max(0, 1-1) = 0 + 2 + 0 = 2$。\n$\\ell(1) = \\max(0, 1-3) + \\max(0, 1-1) = 0 + 0 = 0$。\n总事件数为 $d(1) + \\ell(1) = 2$。\n\n情况 $k=2$：\n$d(2) = (2-1) + \\max(0, 3-2) + \\max(0, 1-2) = 1 + 1 + 0 = 2$。\n$\\ell(2) = \\max(0, 2-3) + \\max(0, 2-1) = 0 + 1 = 1$。\n总事件数为 $d(2) + \\ell(2) = 3$。\n\n情况 $k=3$：\n$d(3) = (3-1) + \\max(0, 3-3) + \\max(0, 1-3) = 2 + 0 + 0 = 2$。\n$\\ell(3) = \\max(0, 3-3) + \\max(0, 3-1) = 0 + 2 = 2$。\n总事件数为 $d(3) + \\ell(3) = 4$。\n\n对于 $k > 3$：\n$d(k) = (k-1) + 0 + 0 = k-1$。\n$\\ell(k) = (k-3) + (k-1) = 2k-4$。\n总事件数 $d(k) + \\ell(k) = 3k-5$，这是一个关于 $k$ 的增函数。\n\n比较总事件数，最小值在 $k=1$ 时取得，总事件数为 $2$。这个最简约的情景对应于在物种分化节点 $R$ 处恰好有一个基因拷贝，这与问题陈述的最直接解释相符。\n\n对于这个最优情景（$k=1$），所需的复制和丢失次数为：\n最少复制次数 $d = d(1) = 2$。\n最少丢失次数 $\\ell = \\ell(1) = 0$。\n\n这一结果对应于以下演化历史：根节点 $R$ 处的单个基因拷贝被传递到 $A$ 和 $B$ 的谱系中。在通向 $B$ 的谱系中，没有事件发生。在通向 $A$ 的谱系中，发生了两次基因复制事件，使拷贝数从 $1$ 增加到 $3$。", "answer": "$$\\boxed{\\begin{pmatrix} 2  0 \\end{pmatrix}}$$", "id": "2394119"}, {"introduction": "根据基因序列数据构建的基因树常常存在未完全解析的节点，即包含两个以上分支的多歧点（polytomies）。这个概念性问题[@problem_id:2394172]将挑战你思考：当一个未解析的基因树与一个完全二分的物种树进行调和时，它究竟意味着什么。这项练习揭示了一个关键洞见：对于一个看似模糊的基因树，其最简约的解释可能是一个完全没有基因重复或丢失的简单演化历史。", "problem": "考虑一个包含四个物种 $S_1, S_2, S_3, S_4$ 的有根、完全二分的物种树 $T$，其拓扑结构为 $T = ((S_1,S_2),(S_3,S_4))$。对于一个单一基因家族，假设每个物种恰好有一个观察到的基因拷贝，由叶节点 $g_{S_1}, g_{S_2}, g_{S_3}, g_{S_4}$ 表示。从基因序列推断出的有根基因树 $G$ 是一个完美的星状系统发育：$G$ 只有一个内部节点（根节点），该节点直接连接到所有四个叶节点 $g_{S_1}, g_{S_2}, g_{S_3}, g_{S_4}$，并且没有其他内部边。假设使用标准的基因树-物种树协调框架，不考虑水平基因转移（HGT），并采用重复-丢失简约法：在所有将 $G$ 的每个节点映射到 $T$ 的一个节点并遵守祖先约束的协调方案 $r$ 中，优先选择那些使基因重复和基因丢失事件总数最小化的方案。在这里，一个协调方案根据每个内部基因节点的像在 $T$ 中是否等于其子节点物种映射在 $T$ 中的最低共同祖先（LCA）或位于其下方，来为该基因节点标记为物种形成或重复。基因丢失是根据映射所暗示的物种树分支上进行计数的。\n\n鉴于 $G$ 是一个完美的星状树，以下哪个陈述最能描述协调对该基因家族演化所做的推断？\n\nA. 最简约协调推断出 $0$ 次重复和 $0$ 次丢失；因为 $G$ 是未解析的，所以存在许多同样最优的协调方案，任何与 $T$ 拓扑一致的 $G$ 的二分细化都能得到最小值。\n\nB. 一个星状基因树对于 $4$ 个叶节点必然需要至少 $3$ 次重复，因为超过 $2$ 个的每个额外叶节点都必须通过基因树根部的重复产生。\n\nC. 必须推断出至少 $1$ 次丢失，因为一个星状基因树无法在不引入缺失谱系的情况下嵌入到一个完全二分的物种树中。\n\nD. 对星状基因树唯一可行的协调需要引入水平基因转移（HGT），因为垂直遗传与多歧分叉不兼容。", "solution": "我们从重复-丢失协调的基本原理出发进行推理。设 $G$ 为基因树，$T$ 为物种树。一个协调方案 $r$ 将 $G$ 的每个节点映射到 $T$ 的一个节点，使得：\n- 对于一个叶节点 $g_{S_i}$，$r(g_{S_i}) = S_i$。\n- 对于 $G$ 的一个有子节点 $u_1, \\dots, u_k$ 的内部节点 $u$，$r(u)$ 被约束在 $T$ 中 $\\mathrm{LCA}_T(r(u_1), \\dots, r(u_k))$ 或其上方，以遵守时间和包含约束。\n- 如果 $r(u) = \\mathrm{LCA}_T(r(u_1), \\dots, r(u_k))$，则节点 $u$ 被标记为物种形成；否则，它被标记为重复。当映射的基因谱系未能在映射所暗示的物种形成事件中持续存在时，基因丢失会沿着 $T$ 的分支进行计数。\n\n在重复-丢失简约法中，我们寻求在所有有效的协调方案中最小化重复和丢失的总数。当每个物种恰好有一个观察到的基因拷贝时（不是先验地假设一对一直系同源，但后验地可能是），当且仅当存在一个 $G$ 的二分细化，其拓扑结构与 $T$ 相同时，才存在一个具有 $0$ 次重复和 $0$ 次丢失的协调方案。因为 $G$ 是一个完美的星状树（一个有 $4$ 个子节点的多歧分叉），它在拓扑上是未解析的：在相同叶节点集上的所有二分树都是 $G$ 的细化。特别地，拓扑结构为 $((g_{S_1}, g_{S_2}), (g_{S_3}, g_{S_4}))$ 的二分树是 $G$ 的一个细化，在叶节点到物种的识别下，它与 $T$ 同构。将这个细化后的 $G$ 的每个内部节点映射到 $T$ 相应的内部节点，会产生一个协调方案，其中每个内部基因节点都是物种形成事件。并且因为每个物种恰好有一个基因，没有暗示额外的谱系，所以不需要任何丢失事件。因此，最简约成本是 $0$ 次重复和 $0$ 次丢失。此外，由于 $G$ 是未解析的，在相同的最小成本下存在许多同样有效的协调方案：任何与 $T$ 拓扑一致的 $G$ 的细化（在这里，正是那个在同构意义下匹配 $T$ 的细化）都能达到最小值；更一般地说，将 $G$ 的多歧分叉根节点映射到 $T$ 的根节点，并配合一个一致的细化，会得到相同的最小事件数。因此，协调方案不是唯一的。\n\n我们现在分析每个选项：\n\nA. 该选项指出，最简约协调推断出 $0$ 次重复和 $0$ 次丢失，并且由于 $G$ 是未解析的，存在许多同样最优的协调方案，任何与 $T$ 一致的 $G$ 的二分细化都能达到最小值。如上所示，存在一个与 $T$ 匹配的 $G$ 的细化，从而产生一个没有重复或丢失的协调方案。$G$ 的未解析特性通常意味着存在多个同样最优的映射，特别是，任何一致的细化都能达到最小值。这是正确的。\n\nB. 该选项声称 $4$ 个叶节点至少需要 $3$ 次重复。这种推理错误地将超过 $2$ 个的每个额外叶节点都视为必须由重复产生。在我们的设定中，每个物种有一个拷贝，并且物种树可以被 $G$ 的一个细化所匹配，因此不需要重复：$T$ 中的物种形成可以解释 $4$ 个叶节点的存在。这是不正确的。\n\nC. 该选项断言必须推断出至少 $1$ 次丢失，因为星状树无法在没有丢失的情况下嵌入到二分的物种树中。星状树反映的是 $G$ 缺乏解析度，而不是缺失的谱系。由于 $G$ 的一个细化可以匹配 $T$，因此不需要任何丢失来协调观察到的一对一存在。这是不正确的。\n\nD. 该选项说需要水平基因转移（HGT）。假设明确排除了 HGT，即使不排除，这里也不需要 HGT：沿着 $T$ 的垂直遗传，加上一个与 $G$ 一致的细化，可以在没有任何额外事件的情况下解释数据。这是不正确的。", "answer": "$$\\boxed{A}$$", "id": "2394172"}, {"introduction": "在上一题的概念基础上，这个动手编程任务[@problem_id:2394108]要求你实现一个算法，以找到基因树多歧点的最优二分解析方案。你需要将简约性原则转化为一个动态规划算法，这正是生物信息学中解决复杂优化问题的核心技术之一。通过这个练习，你将亲身体验调和算法的计算核心，并将理论知识付诸实践。", "problem": "您的任务是在重复-丢失简约模型下，将一个有根基因树与一个有根二叉物种树进行调和。在该基因树中，恰好有一个节点是具有 $k>2$ 个子节点（其中 $k>2$）的多歧分枝，而基因树的所有其他内部分支节点都是严格二叉的。基因树的叶节点通过一个已知的满射映射到物种树中的物种。您的目标是找到该多歧分枝的二叉解析，以最小化调和成本。\n\n从以下基础定义开始，这些定义在计算生物学和生物信息学中是标准的：\n\n- 一个有根基因树 $G$ 和一个有根物种树 $S$ 都是具有从根节点出发的有向边的树，其中内部节点至少有两个子节点，叶节点没有子节点，且物种树 $S$ 是严格二叉的。\n- 每个基因叶节点通过一个已知的映射 $\\sigma$ 映射到一个唯一的物种叶节点。\n- 最低共同祖先（LCA）映射为每个基因节点 $u$ 分配一个物种节点 $s(u)$，该节点定义为 $S$ 中所有源自 $u$ 的基因叶节点的物种标签的最低共同祖先。\n- 一个基因内部节点 $u$（其子节点为 $v_1$ 和 $v_2$）如果 $s(u)=s(v_1)$ 或 $s(u)=s(v_2)$，则被分类为一次重复事件，否则为一次物种形成事件。\n- 每条基因边 $(u\\to v)$ 被嵌入到 $S$ 中从 $s(u)$到 $s(v)$ 的唯一向下路径上（这是良定义的，因为在LCA映射下，$s(v)$ 始终是 $s(u)$ 的后代）。此路径上产生的丢失数量等于基因谱系缺失的中间物种分支的数量，也就是该路径上物种树边的数量，但不包括进入 $s(v)$ 的最后一条边。如果以边数计算的路径长度为 $\\mathrm{dist}_S\\!\\left(s(u),s(v)\\right)$，那么由 $(u\\to v)$ 产生的丢失计数为 $\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v)\\right)-1\\right\\}$。\n- 调和的重复-丢失成本是所有内部基因节点 $u$ 的重复指示符与 $u$ 的两条子边上引发的丢失数量之和。\n\n您必须编写一个程序，给定一个固定的物种树 $S$ 和一个基因树 $G$（该基因树包含一个且仅一个具有 $k>2$ 个子节点的多歧节点 $P$），该程序需评估多歧分枝的所有二叉细化方案，并返回在LCA映射下可能的最小重复-丢失成本。$G$ 的其余部分是固定的二叉树，且固定部分不能以任何方式更改。成本是单位权重的：每次重复计为1，每次丢失计为1。\n\n您的程序必须实现以下直接从定义中推导出的内容：\n- 对于任何具有子节点 $v_1$ 和 $v_2$ 的二叉基因节点 $u$，计算 $s(u)=\\mathrm{LCA}_S\\!\\big(s(v_1),s(v_2)\\big)$。\n- 在 $u$ 处的重复指示符是 $\\mathbf{1}\\!\\left[s(u)=s(v_1)\\ \\lor\\ s(u)=s(v_2)\\right]$。\n- 在 $u$ 处产生的丢失是\n$$\n\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v_1)\\right)-1\\right\\}+\\max\\!\\left\\{0,\\mathrm{dist}_S\\!\\left(s(u),s(v_2)\\right)-1\\right\\}.\n$$\n- 总成本是所有内部基因节点上的重复指示符和丢失之和。当多歧分枝被解析为二叉树时，最终得到的完全二叉基因树的成本是通过将这些规则应用于每个内部基因节点来计算的。\n\n测试套件。使用以下三个测试用例，每个用例都由一个Newick格式的物种树和一个基因树描述指定。基因树的唯一多歧分枝位于根节点。除了多歧分枝，任何指定的二叉子树都是固定的，不得更改。所有基因叶节点都用其映射的物种叶节点进行了注释。\n\n- 测试用例1（理想情况，$k=3$）：\n  - 物种树 $S_1$：$((A,B),(C,D));$\n  - 基因树 $G_1$：根节点为多歧分枝，子节点为 $[a{:}A]$、$[b{:}B]$、$[c{:}C]$。\n- 测试用例2（边界情况，可实现零成本，$k=3$）：\n  - 物种树 $S_2$：$(((A,B),C),D);$\n  - 基因树 $G_2$：根节点为多歧分枝，子节点为 $[a{:}A]$、$[b{:}B]$、$[c{:}C]$。\n- 测试用例3（边缘情况，包含一个非叶子节点的子树，$k=3$）：\n  - 物种树 $S_3$：$((A,B),(C,D));$\n  - 基因树 $G_3$：根节点为多歧分枝，子节点为 $[a{:}A]$、$[Y=(b{:}B,c{:}C)]$ 和 $[d{:}D]$，其中 $Y$ 是一个固定的二叉基因子树，其两个叶节点分别映射到 $B$ 和 $C$。\n\n要求的输出。您的程序应生成一行输出，其中包含每个测试用例的最小调和成本（整数），按顺序聚合为一个用方括号括起来的逗号分隔列表。例如，输出必须具有 $[x_1,x_2,x_3]$ 的形式，其中每个 $x_i$ 是测试用例 $i$ 的最小整数成本。输出行中不允许有额外的空白或文本。\n\n此任务中没有物理单位或角度。所有要求的数值答案都是整数，因此不需要四舍五入或单位转换。", "solution": "该问题断言了一个计算生物学中的场景，涉及基因树 $G$ 与物种树 $S$ 的调和。基因树 $G$ 具有一种特定结构：除了一个具有 $k > 2$ 个子节点的多歧节点 $P$ 外，它完全是二叉的。任务是确定该多歧分枝的二叉解析，以产生最小的总重复-丢失调和成本。\n\n首先验证该问题。\n**已知条件提取**：\n- 一个有根的严格二叉物种树 $S$。\n- 一个有根基因树 $G$，其中有一个度为 $k > 2$ 的多歧节点 $P$；所有其他内部节点都是二叉的。\n- 从基因叶节点到物种叶节点的满射叶映射 $\\sigma$。\n- LCA映射 $s(u) = \\mathrm{LCA}_S(\\{\\sigma(l) \\mid l \\text{ 是 } u \\text{ 的一个叶后代}\\})$。\n- 一个具有子节点 $v_1, v_2$ 的内部基因节点 $u$，如果 $s(u)=s(v_1)$ 或 $s(u)=s(v_2)$，则为一次重复；此事件对总成本贡献 1。\n- 基因边 $(u \\to v)$ 导致 $\\max\\{0, \\mathrm{dist}_S(s(u), s(v)) - 1\\}$ 次丢失，每次对总成本贡献 1。$\\mathrm{dist}_S$ 是路径长度（边的数量）。\n- 总成本是整个基因树上所有重复和丢失事件的总和。\n- 目标是找到多歧节点 $P$ 的一个二叉解析，以最小化此总成本。$G$ 中任何预先存在的二叉子树的成本是固定的。\n\n**验证结论**：\n该问题具有科学依据，阐述清晰且客观。它精确描述了系统发育学中使用的标准重复-丢失简约模型。所有术语都是标准的，其定义也正确。输入是充分且一致的，足以保证唯一解的存在。因此，该问题被认定为**有效**。\n\n**求解推导**：\n\n完全解析后的基因树的总调和成本由两部分成本之和构成：（1）来自多歧分枝的任何预先存在的二叉子树的固定成本，以及（2）解析多歧分枝本身所产生的可变成本。我们的目标是最小化总成本，这等同于最小化可变成本，因为固定成本是恒定的。\n\n设多歧节点 $P$ 的子节点集合为 $\\mathcal{C} = \\{g_1, g_2, \\dots, g_k\\}$。此多歧分枝的任何二叉解析都会产生一个以 $\\mathcal{C}$ 为叶、有 $k-1$ 个新创建的内部节点的有根二叉树。解析的成本是在这 $k-1$ 个新节点上计算的调和成本之和。\n\n这个问题可以用动态规划来解决。设 $A \\subseteq \\mathcal{C}$ 为多歧分枝子节点的一个子集。我们定义 $C(A)$ 为从 $A$ 的元素构建一个单一有根二叉树的最小成本。我们的目标是计算 $C(\\mathcal{C})$。\n\n对于任何子集 $A \\subseteq \\mathcal{C}$，构建在其上的任何二叉树的根（设为 $u_A$）都将具有相同的物种映射，无论树的拓扑结构如何。这是因为 $s(u_A)$ 是由其后代子树中的全部叶节点决定的，而这些叶节点正是 $A$ 中子树的基因叶节点。我们定义 $s[A] = \\mathrm{LCA}_S(\\{s(g) \\mid g \\in A\\})$。\n\n我们递推的基准情况是单例集：\n$$C(\\{g_i\\}) = 0 \\quad \\text{对于每个 } g_i \\in \\mathcal{C}$$\n因为单个节点不会产生任何成本。\n\n对于任何大小 $|A| \\ge 2$ 的子集 $A \\subseteq \\mathcal{C}$，以 $u_A$ 为根的二叉树必须通过将 $A$ 划分为两个非空的、不相交的子集 $A_1$ 和 $A_2$（即 $A=A_1 \\cup A_2, A_1 \\cap A_2 = \\emptyset$）来形成。根节点 $u_A$ 将有两个子节点，它们分别是 $A_1$ 和 $A_2$ 的最优子解析的根，我们称之为 $u_{A_1}$ 和 $u_{A_2}$。此特定划分的总成本是子问题的最优成本之和，再加上在新根节点 $u_A$ 处产生的额外成本：\n$$C(A_1) + C(A_2) + \\Delta C(u_A, u_{A_1}, u_{A_2})$$\n节点 $u_A$ 处的成本 $\\Delta C$ 是其重复指示符与其出边上的丢失之和：\n$$ \\Delta C = \\mathbf{1}[s[A]=s[A_1] \\lor s[A]=s[A_2]] + \\max\\{0, \\mathrm{dist}_S(s[A], s[A_1]) - 1\\} + \\max\\{0, \\mathrm{dist}_S(s[A], s[A_2]) - 1\\} $$\n注意，根据LCA的性质，$s[A] = \\mathrm{LCA}_S(s[A_1], s[A_2])$。此外，$s[A_1]$ 和 $s[A_2]$ 在物种树 $S$ 中始终是 $s[A]$ 的后代（或与之相等），因此距离函数 $\\mathrm{dist}_S$ 作为从祖先到后代的路径长度是良定义的。\n\n要找到子集 $A$ 的最小成本，我们必须检查 $A$ 的所有可能的二分划分：\n$$ C(A) = \\min_{\\substack{A_1 \\cup A_2 = A \\\\ A_1, A_2 \\neq \\emptyset, A_1 \\cap A_2 = \\emptyset}} \\left\\{ C(A_1) + C(A_2) + \\Delta C \\right\\} $$\n\n算法流程如下：\n1.  **预处理**：\n    a. 对多歧分枝的每个子节点 $g_i \\in \\mathcal{C}$，确定其物种映射 $s(g_i)$。如果 $g_i$ 是映射到物种 $X$ 的叶节点，则 $s(g_i)$ 是 $S$ 中的叶节点 $X$。如果 $g_i$ 是一个预先存在的二叉子树，其映射 $s(g_i)$ 是其所有叶节点的物种映射的LCA。\n    b. 计算任何此类固定子树的调和成本。这是总成本的固定部分。\n    c. 为物种树 $S$ 预计算数据结构，以便高效计算LCA和距离。具体来说，对于 $S$ 中的任意两个节点，我们需要它们的LCA和路径距离。为每个节点存储父指针和深度就足够了。对于祖先 $u$ 和后代 $v$，$\\mathrm{dist}_S(u, v)$ 就是 $\\text{depth}(v) - \\text{depth}(u)$。\n\n2.  **动态规划**：\n    a. 初始化一个表 `dp[subset]`，用于存储每个 $A \\subseteq \\mathcal{C}$ 的 $C(A)$。\n    b. 初始化一个表 `s_map[subset]`，用于存储 $s[A]$。\n    c. 设置基准情况：对于每个单例 $\\{g_i\\}$，`dp[{g_i}]`$=0$ 且 `s_map[{g_i}]`$=s(g_i)$。\n    d. 从 2 到 $k$ 遍历子集大小 $m$。对于每个大小为 $m$ 的子集 $A$：i. 计算并存储 $s[A] = \\mathrm{LCA}_S(\\{s(g) \\mid g \\in A\\})$。ii. 遍历 $A$ 到 $A_1$ 和 $A_2$ 的所有非平凡划分。iii. 对于每个划分，使用递推关系计算总成本，并用找到的最小值更新 `dp[A]`。\n\n3.  **最终结果**：解析多歧分枝的最小成本是 `dp[C]`。总的最小调和成本是该值加上任何固定子树的成本总和。\n\n将实现此算法来解决所提供的测试用例。使用位掩码来表示子集提供了一种实现DP表以及遍历子集及其划分的高效方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries outside the standard library or specified ones are permitted.\nimport collections\nfrom itertools import chain, combinations\n\nclass Node:\n    \"\"\"A simple class for representing tree nodes.\"\"\"\n    def __init__(self, name=None):\n        self.name = name\n        self.children = []\n        self.parent = None\n        self.depth = 0\n\ndef parse_newick_recursive(s):\n    \"\"\"Recursively parses a Newick string component.\"\"\"\n    s = s.strip()\n    # Find the main label if it exists (e.g., from '(A,B)label')\n    if s.endswith(';'):\n        s = s[:-1]\n    \n    label_start = s.rfind(')')\n    name = None\n    if label_start != -1 and label_start  len(s) - 1:\n        name = s[label_start+1:]\n        s = s[:label_start+1]\n\n    if s.startswith('(') and s.endswith(')'):\n        # Internal node\n        node = Node(name=name)\n        content = s[1:-1]\n        \n        balance = 0\n        split_indices = [-1]\n        for i, char in enumerate(content):\n            if char == '(':\n                balance += 1\n            elif char == ')':\n                balance -= 1\n            elif char == ',' and balance == 0:\n                split_indices.append(i)\n        \n        split_indices.append(len(content))\n        \n        for i in range(len(split_indices) - 1):\n            child_str = content[split_indices[i]+1:split_indices[i+1]]\n            child_node = parse_newick_recursive(child_str)\n            node.children.append(child_node)\n        return node\n    else:\n        # Leaf node\n        return Node(name=s)\n\ndef build_tree_properties(root):\n    \"\"\"Traverses tree to set parent pointers, depths, and builds a name->node map.\"\"\"\n    name_to_node = {}\n    q = collections.deque([(root, 0, None)])\n    nodes_in_order = []\n    \n    while q:\n        node, depth, parent = q.popleft()\n        node.depth = depth\n        node.parent = parent\n        nodes_in_order.append(node)\n        if node.name:\n            name_to_node[node.name] = node\n        \n        for child in node.children:\n            q.append((child, depth + 1, node))\n            \n    return name_to_node, nodes_in_order\n\ndef get_path_to_root(node):\n    \"\"\"Returns the path from a node to the root.\"\"\"\n    path = []\n    curr = node\n    while curr is not None:\n        path.append(curr)\n        curr = curr.parent\n    return path\n\ndef get_lca(node1, node2):\n    \"\"\"Finds the Lowest Common Ancestor of two nodes.\"\"\"\n    path1 = get_path_to_root(node1)\n    path2_nodes = {n for n in get_path_to_root(node2)}\n    for node in path1:\n        if node in path2_nodes:\n            return node\n    return None # Should not happen in a rooted tree\n\ndef get_dist(ancestor, descendant):\n    \"\"\"Calculates distance from an ancestor to a descendant.\"\"\"\n    return descendant.depth - ancestor.depth\n\ndef solve():\n    \"\"\"Main function to solve the problem for all test cases.\"\"\"\n\n    test_cases = [\n        {\n            \"s_tree_str\": \"((A,B),(C,D));\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"leaf\", \"species\": \"B\"},\n                {\"type\": \"leaf\", \"species\": \"C\"}\n            ]\n        },\n        {\n            \"s_tree_str\": \"(((A,B),C),D);\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"leaf\", \"species\": \"B\"},\n                {\"type\": \"leaf\", \"species\": \"C\"}\n            ]\n        },\n        {\n            \"s_tree_str\": \"((A,B),(C,D));\",\n            \"g_children_desc\": [\n                {\"type\": \"leaf\", \"species\": \"A\"},\n                {\"type\": \"subtree\", \"leaves\": [\"B\", \"C\"]},\n                {\"type\": \"leaf\", \"species\": \"D\"}\n            ]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        s_root = parse_newick_recursive(case[\"s_tree_str\"])\n        s_name_to_node, _ = build_tree_properties(s_root)\n\n        g_children = []\n        fixed_cost = 0\n\n        # Process gene tree composition\n        for i, desc in enumerate(case[\"g_children_desc\"]):\n            if desc[\"type\"] == \"leaf\":\n                s_node = s_name_to_node[desc[\"species\"]]\n                g_children.append({\"id\": i, \"s_map_node\": s_node})\n            elif desc[\"type\"] == \"subtree\":\n                leaf_nodes = [s_name_to_node[sp] for sp in desc[\"leaves\"]]\n                \n                #\n                # Calculate properties of the fixed subtree\n                #\n                # 1. LCA mapping of the subtree's root\n                subtree_lca = leaf_nodes[0]\n                for j in range(1, len(leaf_nodes)):\n                    subtree_lca = get_lca(subtree_lca, leaf_nodes[j])\n                \n                g_children.append({\"id\": i, \"s_map_node\": subtree_lca})\n\n                # 2. Reconciliation cost of the fixed subtree.\n                # All test cases have subtrees with 2 leaves.\n                # Cost is at the single internal node of the subtree.\n                u, v_1_node, v_2_node = subtree_lca, leaf_nodes[0], leaf_nodes[1]\n                \n                dup = 1 if u == v_1_node or u == v_2_node else 0\n                loss1 = max(0, get_dist(u, v_1_node) - 1)\n                loss2 = max(0, get_dist(u, v_2_node) - 1)\n                fixed_cost += dup + loss1 + loss2\n\n        k = len(g_children)\n        dp = {}  # Using dict for sparse bitmask representation\n        s_map = {}\n\n        # DP Initialization (subsets of size 1)\n        for i in range(k):\n            mask = 1  i\n            dp[mask] = 0\n            s_map[mask] = g_children[i][\"s_map_node\"]\n\n        # DP for subsets of size > 1\n        for m in range(2, k + 1):\n            for subset_indices in combinations(range(k), m):\n                mask = 0\n                for i in subset_indices:\n                    mask |= (1  i)\n\n                # Compute LCA map for the current subset\n                current_nodes = [g_children[i][\"s_map_node\"] for i in subset_indices]\n                subset_lca = current_nodes[0]\n                for i in range(1, len(current_nodes)):\n                    subset_lca = get_lca(subset_lca, current_nodes[i])\n                s_map[mask] = subset_lca\n\n                min_cost = float('inf')\n\n                # Iterate through non-trivial partitions\n                # Generate submasks of the current mask\n                for i in range(1, 1  m):\n                    submask_indices_relative = [idx for idx, bit in enumerate(bin(i)[2:].zfill(m)) if bit == '1']\n                    # Skip full set and empty set\n                    if not submask_indices_relative or len(submask_indices_relative) == m:\n                        continue\n\n                    mask1 = 0\n                    for rel_idx in submask_indices_relative:\n                        mask1 |= (1  subset_indices[rel_idx])\n\n                    mask2 = mask ^ mask1\n                    \n                    # To avoid double counting A|B and B|A partitions\n                    if mask1 > mask2:\n                        continue\n\n                    s1 = s_map[mask1]\n                    s2 = s_map[mask2]\n                    s_top = s_map[mask]\n\n                    dup_cost = 1 if s_top == s1 or s_top == s2 else 0\n                    loss_cost1 = max(0, get_dist(s_top, s1) - 1)\n                    loss_cost2 = max(0, get_dist(s_top, s2) - 1)\n                    \n                    delta_cost = dup_cost + loss_cost1 + loss_cost2\n                    \n                    current_partition_cost = dp[mask1] + dp[mask2] + delta_cost\n                    min_cost = min(min_cost, current_partition_cost)\n                \n                dp[mask] = min_cost\n        \n        final_mask = (1  k) - 1\n        min_polytomy_cost = dp[final_mask]\n        total_cost = min_polytomy_cost + fixed_cost\n        results.append(total_cost)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2394108"}]}