{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。要真正掌握浮点数的表示方法，最基础的技能就是将一个给定的二进制位模式解码为其对应的十进制数值。这个练习将引导你分解一个 32 位的 IEEE 754 标准浮点数，通过分析其符号、指数和尾数，确定其数值类型，并最终计算出其精确值。通过这个基础练习 [@problem_id:3642294]，你将熟练掌握浮点数编码的核心规则，为理解更复杂的浮点数运算打下坚实的基础。", "problem": "一个 $32$ 位字使用电气与电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ binary32 格式存储。其原始位模式，从最高有效位到最低有效位书写，为\n$$11000010001010100000000000000000.$$\n请仅以 IEEE $754$ binary32 的规范布局和语义为出发点，解码这个字。请从基本原理推导其字段分解、值的类别（规格化数、非规格化数、$0$、 $+\\infty$、 $-\\infty$ 或非数 (Not a Number, NaN)），以及在它是有限数的情况下，它所表示的精确实数。请在你的推理过程中报告其类别，但对于最终的数值结果，请将解码后的实数值表示为最简形式的精确有理数。请勿四舍五入。如果该值为非有限数，那么你的最终结果应为相应的符号值 $+\\infty$、 $-\\infty$ 或 $\\mathrm{NaN}$。", "solution": "该问题陈述是关于应用 IEEE $754$ binary32 标准的一个适定且自洽的练习。它提供了一个特定的 $32$ 位模式，并要求根据该标准的规则将其解码为一个实数。该问题有科学依据、客观，并包含所有必要信息。因此，该问题是有效的，并且可以推导出解答。\n\nIEEE $754$ 标准对于 $32$ 位二进制浮点数 (binary32) 定义了一个 $32$ 位字中各位的特定布局。该字被划分为三个字段，从最高有效位 (MSB) 读到最低有效位 (LSB)：\n1.  符号位 ($S$)：$1$ 位 (第 $31$ 位)。\n2.  指数位 ($E$)：$8$ 位 (第 $30$ 位到第 $23$ 位)。\n3.  小数部分 ($F$)：$23$ 位 (第 $22$ 位到第 $0$ 位)。\n\n给定的 $32$ 位字是：\n$$\n11000010001010100000000000000000\n$$\n我们根据 binary32 格式对此位模式进行划分：\n$$\n\\underset{S}{\\underbrace{1}} \\quad \\underset{E}{\\underbrace{10000100}} \\quad \\underset{F}{\\underbrace{01010100000000000000000}}\n$$\n从这个分解中，我们提取出三个字段的值：\n-   符号位 $S$ 是 MSB，为 $1$。\n-   指数场 $E$ 由 $8$ 位 `10000100` 组成。我们将这个二进制整数转换为其十进制等价值：\n    $$\n    E = (10000100)_2 = 1 \\cdot 2^7 + 0 \\cdot 2^6 + 0 \\cdot 2^5 + 0 \\cdot 2^4 + 0 \\cdot 2^3 + 1 \\cdot 2^2 + 0 \\cdot 2^1 + 0 \\cdot 2^0 = 128 + 4 = 132.\n    $$\n-   小数场 $F$ 由剩下的 $23$ 位组成：`01010100000000000000000`。\n\n接下来，我们确定该浮点数的类别。这由指数场 $E$ 的值决定。对于 binary32 格式，指数偏移量为 $B = 2^{8-1} - 1 = 127$。$E$ 的特殊值是 $0$ 和 $255$。\n-   如果 $E = 255$，该数是无穷大或 NaN (非数)。\n-   如果 $E = 0$，该数是零或非规格化数。\n-   如果 $0  E  255$，该数是规格化数。\n\n在本例中，指数场的值为 $E=132$。由于 $0  132  255$，该数是一个 **规格化数**。\n\n对于一个规格化数，它所表示的值 $V$ 由以下公式给出：\n$$\nV = (-1)^S \\times 2^{E-B} \\times M\n$$\n其中 $M$ 是有效数，它是通过在小数场 $F$ 前面加上一个隐含的前导 $1$ 位来构造的。也就是说，$M = (1.F)_2$。\n\n让我们计算这个公式的各个组成部分。\n-   符号由 $S=1$ 决定，所以 $(-1)^S = (-1)^1 = -1$。\n-   真实指数为 $e = E - B = 132 - 127 = 5$。\n-   有效数 $M$ 由小数场 $F = (010101000...)_2$ 形成。尾部的零不影响其值。\n    $$\n    M = (1.F)_2 = (1.010101)_2\n    $$\n    我们将这个二进制表示转换为一个有理数：\n    $$\n    M = 1 \\cdot 2^0 + 0 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4} + 0 \\cdot 2^{-5} + 1 \\cdot 2^{-6}\n    $$\n    $$\n    M = 1 + \\frac{1}{2^2} + \\frac{1}{2^4} + \\frac{1}{2^6} = 1 + \\frac{1}{4} + \\frac{1}{16} + \\frac{1}{64}\n    $$\n    为了对这些分数求和，我们找到一个公分母，即 $64$：\n    $$\n    M = \\frac{64}{64} + \\frac{16}{64} + \\frac{4}{64} + \\frac{1}{64} = \\frac{64+16+4+1}{64} = \\frac{85}{64}\n    $$\n\n最后，我们将这些组成部分代回到 $V$ 的公式中：\n$$\nV = (-1) \\times 2^5 \\times \\frac{85}{64}\n$$\n由于 $2^5 = 32$，我们得到：\n$$\nV = -32 \\times \\frac{85}{64} = - \\frac{32 \\times 85}{64}\n$$\n我们可以通过约掉因子 $32$ 来简化这个分数：\n$$\nV = - \\frac{85}{2}\n$$\n数字 $85$ 和 $2$ 是互质的 ($85 = 5 \\times 17$)，所以这个分数是最简形式。由给定 位模式表示的精确实数是 $-\\frac{85}{2}$。", "answer": "$$\n\\boxed{-\\frac{85}{2}}\n$$", "id": "3642294"}, {"introduction": "理解了浮点数的表示方法后，我们来看一个在实际计算中至关重要的现象：灾难性抵消（catastrophic cancellation）。当两个非常相近的数字相减时，其有效数字会大量丢失，导致结果的相对误差急剧增大。这个问题 [@problem_id:3642283] 模拟了将两个非常接近的十进制数转换为二进制浮点数，然后进行减法运算的过程，揭示了初始的表示误差是如何在计算中被放大，并最终产生一个与直觉相悖却在计算上完全正确的结果。", "problem": "考虑在电子电气工程师协会 (IEEE $754$) 浮点数算术标准中执行的算术，具体为 binary$32$ 格式，该格式包含1个符号位、8个指数位（偏置值为 $127$）以及23个小数位（对于规格化数，含有一个隐藏的前导$1$）。两个十进制输入 $x = 123456.78$ 和 $y = 123456.77$ 首先使用“向最接近的值舍入，若与两侧距离相等则取偶数”(round-to-nearest, ties-to-even)的规则转换为 binary$32$ 格式，然后执行减法 $x - y$，并根据相同的规则将结果正确舍入到 binary$32$ 格式。仅从 binary$32$ 的结构定义和规格化出发，确定硬件为该减法运算返回的精确十进制值。\n\n将最终答案表示为一个精确的十进制数。不需要单位。", "solution": "该问题要求我们模拟遵循 IEEE $754$ binary$32$ 标准的硬件所执行的浮点数转换和减法过程。\n\n**1. 确定相关的浮点数精度 (ULP)**\n\n首先，我们必须确定输入数值 $x = 123456.78$ 和 $y = 123456.77$ 的量级。我们可以找到界定它们的2的幂：\n$$2^{16} = 65536$$\n$$2^{17} = 131072$$\n由于 $2^{16}  x, y  2^{17}$，这些数的任何规格化 binary$32$ 表示都将具有一个未偏置的指数 $E=16$。\n在此格式中，一个规格化数的值由 $v = (-1)^s \\times (1.f)_2 \\times 2^E$ 给出，其中 $s$ 是符号位，$f$ 是23位小数部分。存储在8位指数域中的偏置指数是 $e = E + 127 = 16 + 127 = 143$。\n\n在这个范围内的数的精度由其有效数（significand）的最低有效位的值决定。这被称为最后一位的单位 (Unit in the Last Place, ULP)。\n$$\\text{ULP} = 2^E \\times 2^{-23} = 2^{16} \\times 2^{-23} = 2^{-7}$$\n作为十进制数，ULP是：\n$$\\text{ULP} = \\frac{1}{128} = 0.0078125$$\n在 $[2^{16}, 2^{17})$ 范围内的每个实数都会被映射到这个ULP值的最接近的倍数。\n\n**2. 将输入 `x` 转换为 binary32 格式**\n\n为了找到 $x = 123456.78$ 的 binary$32$ 表示，我们将 $x$ 除以 ULP，以确定它最接近哪个倍数。\n$$\\frac{x}{\\text{ULP}} = \\frac{123456.78}{0.0078125} = 123456.78 \\times 128 = 15802467.84$$\n这个数字代表了由 $2^{23}$ 缩放后的有效数。根据“向最接近的值舍入，若与两侧距离相等则取偶数”的规则，我们必须将其舍入到最近的整数。由于小数部分 $0.84$ 大于 $0.5$，我们向上舍入。\n$$N_x = \\text{round}(15802467.84) = 15802468$$\n$x$ 的存储值，我们称之为 $x_{b32}$，是 ULP 的这个整数倍。\n$$x_{b32} = N_x \\times \\text{ULP} = 15802468 \\times 0.0078125 = 123456.78125$$\n\n**3. 将输入 `y` 转换为 binary32 格式**\n\n我们对 $y = 123456.77$ 重复同样的过程。\n$$\\frac{y}{\\text{ULP}} = \\frac{123456.77}{0.0078125} = 123456.77 \\times 128 = 15802466.56$$\n小数部分 $0.56$ 大于 $0.5$，所以我们向上舍入。注意，这不是一个与两侧等距的情况，所以规则中“取偶数”的部分不会被触发。\n$$N_y = \\text{round}(15802466.56) = 15802467$$\n$y$ 的存储值，我们称之为 $y_{b32}$，是：\n$$y_{b32} = N_y \\times \\text{ULP} = 15802467 \\times 0.0078125 = 123456.7734375$$\n\n**4. 执行减法并确定最终结果**\n\n硬件对存储的表示 $x_{b32}$ 和 $y_{b32}$ 执行减法。该减法的精确结果是：\n$$d = x_{b32} - y_{b32} = 123456.78125 - 123456.7734375 = 0.0078125$$\n最后一步是确保结果 $d$ 被正确地存储在一个 binary$32$ 寄存器中，这可能涉及另一次舍入步骤。我们必须检查 $d$ 是否可以被精确表示。\n$$d = 0.0078125 = \\frac{1}{128} = 2^{-7}$$\n这个值可以写成规格化浮点数形式 $1.0_2 \\times 2^{-7}$。\n- 符号为正 ($s=0$)。\n- 有效数是 $1.0_2$，所以小数部分 $f$ 全为零。\n- 未偏置的指数是 $E = -7$。\n该指数在 binary$32$ 规格化数的有效范围 $[-126, 127]$ 内。由于该值是2的幂，它可以被二进制浮点格式精确表示。因此，最终结果不需要舍入。\n\n硬件返回的值是存储值相减的精确结果。", "answer": "$$\n\\boxed{0.0078125}\n$$", "id": "3642283"}, {"introduction": "浮点数系统不仅要处理常规大小的数值，还必须为接近零的极小数值设计特殊的规则。本练习将带你探索浮点数表示范围的边界——非规格化数（subnormal numbers）和下溢（underflow）处理。通过比较两种不同的硬件处理策略——渐进下溢（gradual underflow）和清零（flush-to-zero）——你将深入理解 IEEE 754 标准在精度和性能之间所做的权衡 [@problem_id:3642263]。这个练习清晰地展示了，对于一个微小的计算结果，不同的处理模式会如何产生截然不同的误差。", "problem": "考虑符合电气与电子工程师协会（IEEE）浮点数算术标准（IEEE 754）的 `binary32` 格式（单精度）的算术运算。该格式使用 $1$ 个符号位、$8$ 个指数位和 $23$ 个尾数位，对于规格化数，其尾数有一个隐含的前导 $1$。\n\n在此格式中，当指数场全为零时，会出现次规格化（非规格化）数；它们没有隐含的前导 $1$，且其间距是均匀的。最小的正次规格化数的值为 $2^{-149}$，下一个更大的可表示值（次规格化或规格化数）是通过加上 $2^{-149}$ 得到的。\n\n一个处理器对实数操作数 $y$ 和 $z$ 的运算 $x = y - z$ 支持两种下溢处理模式：\n- 渐进下溢：精确的实数差值将使用“向最近舍入，偶数优先”的规则，舍入到最接近的可表示的 `binary32` 值。\n- 刷零：任何非零的次规格化结果都将被替换为 $0$，否则使用正常的舍入规则。\n\n假设 $y  z  0$ 是实数，使得其精确差值为\n$$d = y - z = \\frac{101}{200}\\cdot 2^{-149},$$\n且 $|d|  2^{-149}$。定义标量\n$$R = \\frac{\\text{刷零模式下的绝对误差}}{\\text{渐进下溢模式下的绝对误差}},$$\n其中“绝对误差”指计算结果与精确实数结果 $d$ 之差的绝对值。\n\n仅使用 IEEE 754 `binary32` 的基本属性（格式结构、次规格化数间距和“向最近舍入，偶数优先”规则），确定 $R$ 的精确值，表示为单个实数。无需单位。不要四舍五入；请以精确形式给出答案。", "solution": "目标是计算比率 $R = \\frac{E_{flush}}{E_{grad}}$，其中 $E_{flush}$ 和 $E_{grad}$ 分别是刷零模式和渐进下溢模式下的绝对误差。\n精确差值给定为 $d = \\frac{101}{200} \\cdot 2^{-149}$。\n\n首先，我们分析接近零的可表示的 `binary32` 数集。次规格化数是最小正次规格化数值 $s_{min} = 2^{-149}$ 的整数倍。接近零的正可表示数为 $\\{0, 1 \\cdot 2^{-149}, 2 \\cdot 2^{-149}, 3 \\cdot 2^{-149}, \\dots\\}$。\n\n精确结果为 $d = \\frac{101}{200} \\cdot 2^{-149} = 0.505 \\cdot 2^{-149}$。该值不是 $2^{-149}$ 的整数倍，因此它不是一个可表示的 `binary32` 数。它必须被舍入。\n\n**1. 渐进下溢的计算**\n\n在渐进下溢模式下，精确结果 $d$ 被舍入到最接近的可表示数。指定的规则是“向最近舍入，偶数优先”。值 $d$ 位于两个连续的可表示数之间：$0$ 和 $s_{min} = 1 \\cdot 2^{-149}$。\n\n为了确定最接近的可表示数，我们将 $d$ 与 $0$ 和 $s_{min}$ 之间的中点进行比较。\n中点 $m$ 为：\n$$m = \\frac{0 + s_{min}}{2} = \\frac{1}{2} s_{min} = \\frac{1}{2} \\cdot 2^{-149} = 0.5 \\cdot 2^{-149}$$\n\n我们将 $d$ 与 $m$ 比较：\n$$d = 0.505 \\cdot 2^{-149}$$\n$$m = 0.5 \\cdot 2^{-149}$$\n由于 $0.505 > 0.5$，我们有 $d > m$。这意味着 $d$ 比起 $0$ 更接近 $s_{min}$。因为这不是一个平局（tie）情况，所以规则中的“偶数优先”部分不相关。结果被舍入到最近的值，即 $s_{min}$。\n\n渐进下溢模式下的计算结果为 $x_{grad}$：\n$$x_{grad} = s_{min} = 2^{-149}$$\n\n渐进下溢模式下的绝对误差 $E_{grad}$ 是计算结果与精确结果之间的绝对差：\n$$E_{grad} = |x_{grad} - d| = |2^{-149} - \\frac{101}{200} \\cdot 2^{-149}|$$\n提出公因子 $2^{-149}$：\n$$E_{grad} = |1 - \\frac{101}{200}| \\cdot 2^{-149} = |\\frac{200 - 101}{200}| \\cdot 2^{-149} = \\frac{99}{200} \\cdot 2^{-149}$$\n\n**2. 刷零模式的计算**\n\n在刷零模式下，任何将成为非零次规格化数的结果都被强制为零。精确结果 $d = 0.505 \\cdot 2^{-149}$ 处于次规格化范围内，因为其值小于最小正规格化数（$2^{-126}$）但大于零。IEEE 754 标准规定，当下溢发生时，即精确结果极小（在次规格化范围内）且会导致精度损失时，在刷零模式下，这样的结果将被替换为零。\n\n刷零模式下的计算结果为 $x_{flush}$：\n$$x_{flush} = 0$$\n\n刷零模式下的绝对误差 $E_{flush}$ 为：\n$$E_{flush} = |x_{flush} - d| = |0 - \\frac{101}{200} \\cdot 2^{-149}|$$\n$$E_{flush} = \\frac{101}{200} \\cdot 2^{-149}$$\n\n**3. 比率 R 的计算**\n\n比率 $R$ 定义为两个绝对误差的商：\n$$R = \\frac{E_{flush}}{E_{grad}}$$\n代入我们导出的表达式：\n$$R = \\frac{\\frac{101}{200} \\cdot 2^{-149}}{\\frac{99}{200} \\cdot 2^{-149}}$$\n分子和分母中的公因子 $\\frac{1}{200} \\cdot 2^{-149}$ 被约去。\n$$R = \\frac{101}{99}$$\n这就是所要求的最终精确值。", "answer": "$$\\boxed{\\frac{101}{99}}$$", "id": "3642263"}]}