{"hands_on_practices": [{"introduction": "虽然数字逻辑设计中存在多种类型的触发器，如 $D$ 型、$T$ 型、和 $JK$ 型，但它们的功能通常是可以通过组合逻辑相互转换的。本练习将向您展示如何使用一个基本的 $D$ 型触发器和一些逻辑门来构建一个 $T$ (翻转) 型触发器，这是数字设计中的一项基本技能。通过这个实践，您可以深入理解如何结合时序元件和组合逻辑来改变电路的行为。[@problem_id:1931871]", "problem": "边沿触发T触发器是一种基本的时序逻辑元件。它有一个单个数据输入 T（代表“Toggle”，即翻转），以及一个输出 Q。其行为定义如下：在有效时钟沿上，如果 T=0，输出 Q 保持其当前状态；如果 T=1，输出 Q 翻转到其反相状态。\n\n您的任务是构建一个上升沿触发的T触发器。然而，您只能使用一个上升沿触发的D触发器和一些标准的双输入逻辑门。D触发器（代表“Data”数据或“Delay”延迟）有一个单个数据输入 D 和一个输出 Q。在有效时钟沿上，其输出 Q 简单地取其输入 D 的值。\n\n令 Q 代表触发器输出的当前状态。以下哪个关于 D 输入的逻辑表达式能正确地将 D 触发器转换为具有翻转输入 T 的 T 触发器？\n\nA. $D = T \\cdot Q$ (T 与 Q)\n\nB. $D = T + \\overline{Q}$ (T 或 非Q)\n\nC. $D = \\overline{T \\oplus Q}$ (T 同或 Q)\n\nD. $D = T \\oplus Q$ (T 异或 Q)\n\nE. $D = \\overline{T} + Q$ (非T 或 Q)", "solution": "一个T触发器具有以下次态行为：在时钟上升沿，如果 $T=0$，则输出保持（$Q^{+}=Q$）；如果 $T=1$，则输出翻转（$Q^{+}=\\overline{Q}$）。这可以写成一个布尔方程，使用 T作为选择器在 $Q$ 和 $\\overline{Q}$ 之间进行选择：\n$$\nQ^{+}=\\overline{T}\\,Q+T\\,\\overline{Q}.\n$$\n一个D触发器在时钟上升沿输出 $Q^{+}=D$。因此，为了使D触发器表现得像一个T触发器，我们必须设置\n$$\nD=Q^{+}=\\overline{T}\\,Q+T\\,\\overline{Q}.\n$$\n根据异或的定义，\n$$\nT\\oplus Q=\\overline{T}\\,Q+T\\,\\overline{Q},\n$$\n所以所需的输入是\n$$\nD=T\\oplus Q.\n$$\n与选项核对，这对应于选项 D。为完整起见，请注意其他选项在 $T=0$ 或 $T=1$ 时不满足所要求的行为（例如，当 $T=0$ 时，$D=T\\cdot Q$ 给出 $D=0$，而不是 $Q$；当 $T=0$ 时，$D=\\overline{T\\oplus Q}$ 给出 $D=\\overline{Q}$，而不是 $Q$）。", "answer": "$$\\boxed{D}$$", "id": "1931871"}, {"introduction": "在学会了如何修改单个触发器的行为之后，下一步自然是使用它们作为构建模块来设计更复杂的状态机。本练习将指导您设计一个2位同步格雷码计数器，这是许多数字系统中的核心组件。这个过程将加深您对状态转换图的理解，并让您实践如何通过激励表为触发器推导出必要的控制逻辑。[@problem_id:3641646]", "problem": "考虑一个使用理想的触发（$T$）触发器实现的同步 $2$ 位格雷码加/减计数器。该计数器有两个状态位 $Q_1$ 和 $Q_0$，一个边沿触发时钟，以及一个方向控制输入 $U$，其中 $U=1$ 选择格雷码递增序列，$U=0$ 选择格雷码递减序列。无论计数方向如何，格雷码都必须满足邻接特性，即连续状态之间仅有一位不同。递增方向使用标准的 $2$ 位格雷码周期 $00 \\rightarrow 01 \\rightarrow 11 \\rightarrow 10 \\rightarrow 00$，递减方向则使用其逆序。每个 $T$ 触发器在其输入为 $1$ 时翻转其对应的状态位，在输入为 $0$ 时保持不变。\n\n严格从这些定义出发，推导触发输入 $T_0$ 和 $T_1$ 作为 $U$、$Q_1$ 和 $Q_0$ 的函数的闭式代数表达式，以保证在递增和递减方向上都满足格雷码的邻接特性。请仅使用异或 (XOR) 运算 $\\oplus$ 以及（如果需要）常数 $0$ 和 $1$ 来表示最终的 $T_0$ 和 $T_1$。不要在最终表达式中引入任何其他逻辑运算符。你的最终答案必须是单一的解析表达式；如果需要多个表达式，请将它们表示为单个行向量。无需进行数值舍入。", "solution": "用户希望为一个 2 位同步格雷码加/减计数器找到激励逻辑。\n\n### 第一步：提取已知条件\n-   **系统**：同步 $2$ 位计数器。\n-   **触发器**：理想的触发（$T$）触发器。\n-   **状态位**：$Q_1$（最高有效位），$Q_0$（最低有效位）。\n-   **控制输入**：$U$。$U=1$ 用于递增计数，$U=0$ 用于递减计数。\n-   **递增序列 ($U=1$)**：$00 \\rightarrow 01 \\rightarrow 11 \\rightarrow 10 \\rightarrow 00$。\n-   **递减序列 ($U=0$)**：递增序列的逆序，即 $00 \\rightarrow 10 \\rightarrow 11 \\rightarrow 01 \\rightarrow 00$。\n-   **$T$ 触发器行为**：如果输入 $T$ 为 $1$，输出翻转；如果 $T$ 为 $0$，则保持其值。其特征方程为 $Q_{\\text{next}} = Q \\oplus T$。\n-   **输出要求**：推导触发输入 $T_1$ 和 $T_0$ 作为 $U$、$Q_1$ 和 $Q_0$ 的函数的闭式代数表达式。\n-   **表达式约束**：最终表达式必须仅使用异或 ($\\oplus$) 运算符和常数 $0$ 和 $1$。\n\n### 第二步：使用提取的已知条件进行验证\n-   **科学性基础**：该问题是数字逻辑设计中的一个标准练习，是计算机工程和电子学中的一个基础课题。所有组件（触发器、计数器、格雷码）和概念都是公认的。该问题在科学上是合理的。\n-   **适定性**：该问题明确了状态变量、控制输入、两种操作模式下期望的状态转换以及要使用的触发器类型。这些信息足以唯一地确定触发器输入所需的逻辑函数。存在唯一解。\n-   **客观性**：问题以精确、无歧义的技术语言陈述。没有主观或基于意见的元素。\n-   **完整性和一致性**：问题提供了所有必要信息，并且不包含内部矛盾。指定的格雷码序列 ($00, 01, 11, 10$) 及其逆序都是有效的格雷码，满足邻接特性。\n\n### 第三步：结论与行动\n问题有效。将提供完整解答。\n\n### 解题推导\n\n设计过程首先构建一个状态转换表，以捕捉计数器的行为。该表列出了当前状态 ($Q_1$, $Q_0$) 和控制输入 ($U$) 的每一种可能组合，并指定了相应的次态 ($Q_1^+$, $Q_0^+$)。\n\n根据问题陈述：\n-   当 $U=1$ (递增) 时：$00 \\rightarrow 01 \\rightarrow 11 \\rightarrow 10 \\rightarrow 00$。\n-   当 $U=0$ (递减) 时：$00 \\rightarrow 10 \\rightarrow 11 \\rightarrow 01 \\rightarrow 00$。\n\n$T$ 触发器的激励方程决定了实现从状态 $Q$ 到 $Q^+$ 转换所需的输入 $T$。它源自特征方程 $Q^+ = Q \\oplus T$，由此可得 $T = Q \\oplus Q^+$。因此，我们两个触发器所需的输入为：\n$$T_1 = Q_1 \\oplus Q_1^+$$\n$$T_0 = Q_0 \\oplus Q_0^+$$\n\n现在我们可以构建完整的状态转换和激励表。\n\n| 控制输入 | 当前状态 | 次态  | 触发输入（计算方式为 $T_i = Q_i \\oplus Q_i^+$） |\n|---------------|---------------|-------------|-------------------------------------------------------|\n| $U$           | $Q_1 Q_0$     | $Q_1^+ Q_0^+$ | $T_1$                                                 | $T_0$                                                 |\n| $0$           | $0\\;0$        | $1\\;0$      | $1$                                                   | $0$                                                   |\n| $0$           | $0\\;1$        | $0\\;0$      | $0$                                                   | $1$                                                   |\n| $0$           | $1\\;0$        | $1\\;1$      | $0$                                                   | $1$                                                   |\n| $0$           | $1\\;1$        | $0\\;1$      | $1$                                                   | $0$                                                   |\n| $1$           | $0\\;0$        | $0\\;1$      | $0$                                                   | $1$                                                   |\n| $1$           | $0\\;1$        | $1\\;1$      | $1$                                                   | $0$                                                   |\n| $1$           | $1\\;0$        | $0\\;0$      | $1$                                                   | $0$                                                   |\n| $1$           | $1\\;1$        | $1\\;0$      | $0$                                                   | $1$                                                   |\n\n接下来，我们推导 $T_1$ 和 $T_0$ 作为 $U$、$Q_1$ 和 $Q_0$ 的函数的布尔表达式。我们可以使用卡诺图或代数运算。\n\n**$T_0$ 的推导：**\n从表中可知，当输入组合 ($U$, $Q_1$, $Q_0$) 为 $(0,0,1)$、$(0,1,0)$、$(1,0,0)$ 和 $(1,1,1)$ 时，$T_0$ 为 $1$。这些是对应的最小项。\n其积之和形式为：\n$$T_0 = (\\bar{U}\\bar{Q_1}Q_0) \\lor (\\bar{U}Q_1\\bar{Q_0}) \\lor (U\\bar{Q_1}\\bar{Q_0}) \\lor (UQ_1Q_0)$$\n这种最小项的模式对应于三输入异或函数。\n$$T_0 = U \\oplus Q_1 \\oplus Q_0$$\n此表达式满足题目的约束条件。\n\n**$T_1$ 的推导：**\n从表中可知，当输入组合 ($U$, $Q_1$, $Q_0$) 为 $(0,0,0)$、$(0,1,1)$、$(1,0,1)$ 和 $(1,1,0)$ 时，$T_1$ 为 $1$。这些是对应的最小项。\n其积之和形式为：\n$$T_1 = (\\bar{U}\\bar{Q_1}\\bar{Q_0}) \\lor (\\bar{U}Q_1Q_0) \\lor (U\\bar{Q_1}Q_0) \\lor (UQ_1\\bar{Q_0})$$\n这可以因式分解为：\n$$T_1 = \\bar{U}(\\bar{Q_1}\\bar{Q_0} \\lor Q_1Q_0) \\lor U(\\bar{Q_1}Q_0 \\lor Q_1\\bar{Q_0})$$\n识别出同或 ($\\odot$) 和异或 ($\\oplus$) 的表达式：\n$$T_1 = \\bar{U}(Q_1 \\odot Q_0) \\lor U(Q_1 \\oplus Q_0)$$\n由于 $A \\odot B = \\overline{A \\oplus B}$，我们可以写作：\n$$T_1 = \\bar{U}(\\overline{Q_1 \\oplus Q_0}) \\lor U(Q_1 \\oplus Q_0)$$\n如果第一项是 $\\bar{U}(Q_1 \\oplus Q_0)$，那么这就是异或函数 $U \\oplus (Q_1 \\oplus Q_0)$ 的定义。而当前这个表达式定义了 $U$ 和 $(Q_1 \\oplus Q_0)$ 的同或 (XNOR) 函数：\n$$T_1 = U \\odot (Q_1 \\oplus Q_0)$$\n这等价于对两个项进行异或运算后再取反：\n$$T_1 = \\overline{U \\oplus (Q_1 \\oplus Q_0)}$$\n另一种分析表明，$T_1$ 的最小项是那些输入 ($U$, $Q_1$, $Q_0$) 中有偶数个 $1$ 的项。这正是三输入同或 (XNOR) 函数的定义。\n$$T_1 = \\overline{U \\oplus Q_1 \\oplus Q_0}$$\n问题要求表达式只使用异或运算符和常数。我们使用恒等式 $\\bar{A} = A \\oplus 1$：\n$$T_1 = (U \\oplus Q_1 \\oplus Q_0) \\oplus 1$$\n此表达式满足题目的约束条件。\n\n触发输入的最终表达式为：\n$$T_0 = U \\oplus Q_1 \\oplus Q_0$$\n$$T_1 = (U \\oplus Q_1 \\oplus Q_0) \\oplus 1$$", "answer": "$$ \\boxed{ \\begin{pmatrix} U \\oplus Q_1 \\oplus Q_0 & (U \\oplus Q_1 \\oplus Q_0) \\oplus 1 \\end{pmatrix} } $$", "id": "3641646"}, {"introduction": "理想的逻辑设计与电路的物理实现之间存在着重要的鸿沟，实际电路会受到传播延迟、时钟偏移和功耗等物理限制。这个问题将您带入现实世界的设计挑战，要求您解决一个常见的时序违规——保持时间 ($t_{\\text{hold}}$) 违规。通过分析和比较两种实际的修复策略（插入缓冲器与重定时），您将学习如何量化评估时序裕量 (slack) 和功耗之间的权衡。[@problem_id:3641571]", "problem": "一个单时钟域内的同步流水线使用了两个边沿触发D触发器（DFF），分别称为发射DFF和捕获DFF。它们之间的组合逻辑由标准单元门实现。发射DFF和捕获DFF之间存在非零的时钟偏斜。在从发射DFF到捕获DFF的路径上检测到了保持时间违例，并考虑了两种替代的缓解策略：在数据路径上插入延迟缓冲器，或者移动触发器边界（将下一流水线阶段的一个门集群重定时到当前阶段）。您必须计算每种策略下的最终保持时间裕量，以及相对于修复前原始设计的动态功耗变化。\n\n假设器件和路径具有以下特性：\n- 发射DFF的时钟到输出最小延迟为 $t_{\\text{cq,min}} = 30\\,\\mathrm{ps}$，最大延迟为 $t_{\\text{cq,max}} = 80\\,\\mathrm{ps}$。\n- 捕获DFF的保持时间要求为 $t_{\\text{hold}} = 60\\,\\mathrm{ps}$，建立时间要求为 $t_{\\text{setup}} = 100\\,\\mathrm{ps}$。\n- 两个DFF之间的组合逻辑的最小延迟为 $t_{\\text{pd,min}} = 15\\,\\mathrm{ps}$，最大延迟为 $t_{\\text{pd,max}} = 220\\,\\mathrm{ps}$。\n- 时钟到达捕获DFF的时间比到达发射DFF的时间晚，偏斜为 $t_{\\text{skew}} = +20\\,\\mathrm{ps}$。\n- 时钟周期为 $T = 1\\,\\mathrm{ns}$。\n\n评估了两种缓解策略：\n1) 在数据路径中插入 $n$ 个相同的延迟缓冲器。每个缓冲器贡献的最小延迟和最大延迟均为 $12\\,\\mathrm{ps}$。在数据路径活动因子为 $\\alpha_{b} = 0.25$ 的情况下，每个缓冲器表现出 $C_{b} = 100\\,\\mathrm{fF}$ 的有效开关电容。电源电压为 $V = 0.8\\,\\mathrm{V}$，时钟频率为 $f = 1\\,\\mathrm{GHz}$。选择能产生严格为正且裕度至少为 $10\\,\\mathrm{ps}$ 的保持时间裕量的最小整数 $n$。\n2) 将一个门集群移动到捕获DFF边界的另一侧（重定时），使其现在包含在发射DFF和捕获DFF之间的数据路径中。移动的集群使数据路径的最小延迟增加 $46\\,\\mathrm{ps}$，最大延迟增加 $50\\,\\mathrm{ps}$。重定时使发射阶段逻辑驱动的有效导线电容增加了 $\\Delta C_{\\mathrm{wire}} = 60\\,\\mathrm{fF}$。这条导线之前在下一阶段以 $\\alpha_{\\mathrm{after}} = 0.15$ 的活动因子翻转，但在重定时后，它在当前阶段以 $\\alpha_{\\mathrm{before}} = 0.25$ 的活动因子翻转。电源电压和频率与上述相同。忽略被移动的门本身任何其他的功耗变化。\n\n使用保持和建立时间约束的基本定义，以及基于活动因子、电容、电源电压和频率的经过充分检验的动态功耗关系。计算：\n- 插入缓冲器后的新保持时间裕量。\n- 重定时后的新保持时间裕量。\n- 相对于原始设计，因插入缓冲器而产生的总增量动态功耗。\n- 相对于原始设计，因重定时而产生的总增量动态功耗。\n\n将两个裕量均以 $\\mathrm{s}$ 表示，两个功耗均以 $\\mathrm{W}$ 表示。将所有四个量四舍五入到四位有效数字。以单行矩阵的形式提供您的最终答案，顺序为：[插入缓冲器后的保持时间裕量, 重定时后的保持时间裕量, 使用缓冲器的增量功耗, 使用重定时的增量功耗]。", "solution": "首先通过剖析其背后的物理和数学原理来验证该问题。该问题是数字逻辑时序和功耗分析中的一个标准练习，基于时序电路的建立和保持时间约束以及CMOS技术中的动态功耗等成熟概念。所有给定的参数在物理上都是现实的，并且该问题是自洽且定义良好的。验证成功，下面是完整的解决方案。\n\n时序分析的核心在于两个触发器之间同步路径的保持和建立时间约束。\n\n保持时间约束确保数据信号在捕获时钟边沿之后保持稳定的最小持续时间为 $t_{\\text{hold}}$。这可以防止当前周期由第一个触发器（发射DFF）发射的数据过早到达，从而在第二个触发器（捕获DFF）成功捕获前一个周期的数据之前破坏它。保持时间约束是针对最短可能路径延迟的检查。假设发射时钟边沿发生在时间 $0$。捕获时钟边沿被偏斜 $t_{\\text{skew}}$ 延迟，在时间 $t_{\\text{skew}}$ 到达。来自发射DFF的最快数据信号在时间 $t_{\\text{cq,min}} + t_{\\text{pd,min}}$ 到达捕获DFF的输入端。这个到达时间不得早于保持窗口关闭的时间 $t_{\\text{skew}} + t_{\\text{hold}}$。因此，保持时间约束为：\n$$t_{\\text{cq,min}} + t_{\\text{pd,min}} \\ge t_{\\text{skew}} + t_{\\text{hold}}$$\n保持时间裕量 $t_{\\text{slack,hold}}$ 是满足此约束的裕度：\n$$t_{\\text{slack,hold}} = (t_{\\text{cq,min}} + t_{\\text{pd,min}}) - (t_{\\text{skew}} + t_{\\text{hold}})$$\n\n一个充/放电电容 $C$ 的动态功耗 $P_{\\text{dyn}}$ 由以下公式给出：\n$$P_{\\text{dyn}} = \\alpha C V^2 f$$\n\n首先，我们计算原始设计的保持时间裕量以确认违例。使用给定的值：$t_{\\text{cq,min}} = 30\\,\\mathrm{ps}$，$t_{\\text{pd,min}} = 15\\,\\mathrm{ps}$，$t_{\\text{skew}} = 20\\,\\mathrm{ps}$，以及 $t_{\\text{hold}} = 60\\,\\mathrm{ps}$。\n$$t_{\\text{slack,hold,orig}} = (30\\,\\mathrm{ps} + 15\\,\\mathrm{ps}) - (20\\,\\mathrm{ps} + 60\\,\\mathrm{ps}) = 45\\,\\mathrm{ps} - 80\\,\\mathrm{ps} = -35\\,\\mathrm{ps}$$\n$-35\\,\\mathrm{ps}$ 的负裕量确认了保持时间违例。\n\n现在，我们评估两种缓解策略。\n\n策略1：插入缓冲器\n\n1.  计算新的保持时间裕量。\n    该策略涉及插入 $n$ 个延迟缓冲器，每个缓冲器为数据路径增加 $t_{\\text{buf,min}} = 12\\,\\mathrm{ps}$ 的最小延迟。组合逻辑的新的最小传播延迟为 $t'_{\\text{pd,min}} = t_{\\text{pd,min}} + n \\cdot t_{\\text{buf,min}}$。新的保持时间裕量 $t'_{\\text{slack,hold}}$ 为：\n    $$t'_{\\text{slack,hold}} = (t_{\\text{cq,min}} + t_{\\text{pd,min}} + n \\cdot t_{\\text{buf,min}}) - (t_{\\text{skew}} + t_{\\text{hold}}) = t_{\\text{slack,hold,orig}} + n \\cdot t_{\\text{buf,min}}$$\n    要求是保持时间裕量为严格正值，且裕度至少为 $10\\,\\mathrm{ps}$，因此 $t'_{\\text{slack,hold}} \\ge 10\\,\\mathrm{ps}$。\n    $$-35\\,\\mathrm{ps} + n \\cdot 12\\,\\mathrm{ps} \\ge 10\\,\\mathrm{ps}$$\n    $$n \\cdot 12\\,\\mathrm{ps} \\ge 45\\,\\mathrm{ps}$$\n    $$n \\ge \\frac{45}{12} = 3.75$$\n    由于 $n$ 必须是整数，所以最小值是 $n=4$。使用 $n=4$ 个缓冲器，得到的保持时间裕量是：\n    $$t'_{\\text{slack,hold}} = -35\\,\\mathrm{ps} + 4 \\cdot 12\\,\\mathrm{ps} = -35\\,\\mathrm{ps} + 48\\,\\mathrm{ps} = 13\\,\\mathrm{ps} = 1.3 \\times 10^{-11}\\,\\mathrm{s}$$\n    四舍五入到四位有效数字得到 $1.300 \\times 10^{-11}\\,\\mathrm{s}$。\n\n2.  计算增量动态功耗。\n    增量功耗是 $n=4$ 个新增缓冲器消耗的动态功耗之和。\n    $$\\Delta P_{\\text{buf}} = n \\cdot (\\alpha_b C_b V^2 f)$$\n    使用给定的值：$n=4$，$\\alpha_b = 0.25$，$C_b = 100\\,\\mathrm{fF} = 100 \\times 10^{-15}\\,\\mathrm{F}$，$V = 0.8\\,\\mathrm{V}$，以及 $f = 1\\,\\mathrm{GHz} = 1 \\times 10^9\\,\\mathrm{Hz}$。\n    $$\\Delta P_{\\text{buf}} = 4 \\cdot (0.25) \\cdot (100 \\times 10^{-15}\\,\\mathrm{F}) \\cdot (0.8\\,\\mathrm{V})^2 \\cdot (1 \\times 10^9\\,\\mathrm{Hz})$$\n    $$\\Delta P_{\\text{buf}} = 1 \\cdot (100 \\times 10^{-15}) \\cdot (0.64) \\cdot (10^9)\\,\\mathrm{W} = 64 \\times 10^{-6}\\,\\mathrm{W} = 6.4 \\times 10^{-5}\\,\\mathrm{W}$$\n    四舍五入到四位有效数字得到 $6.400 \\times 10^{-5}\\,\\mathrm{W}$。\n\n策略2：重定时\n\n1.  计算新的保持时间裕量。\n    重定时为数据路径增加了 $\\Delta t_{\\text{pd,min}} = 46\\,\\mathrm{ps}$ 的最小延迟。新的最小路径延迟变为 $t''_{\\text{pd,min}} = t_{\\text{pd,min}} + \\Delta t_{\\text{pd,min}} = 15\\,\\mathrm{ps} + 46\\,\\mathrm{ps} = 61\\,\\mathrm{ps}$。新的保持时间裕量为：\n    $$t''_{\\text{slack,hold}} = (t_{\\text{cq,min}} + t''_{\\text{pd,min}}) - (t_{\\text{skew}} + t_{\\text{hold}})$$\n    $$t''_{\\text{slack,hold}} = (30\\,\\mathrm{ps} + 61\\,\\mathrm{ps}) - (20\\,\\mathrm{ps} + 60\\,\\mathrm{ps}) = 91\\,\\mathrm{ps} - 80\\,\\mathrm{ps} = 11\\,\\mathrm{ps} = 1.1 \\times 10^{-11}\\,\\mathrm{s}$$\n    四舍五入到四位有效数字得到 $1.100 \\times 10^{-11}\\,\\mathrm{s}$。\n\n2.  计算增量动态功耗。\n    功耗增加来自于一段电容为 $\\Delta C_{\\mathrm{wire}} = 60\\,\\mathrm{fF}$ 的导线段，它从一个活动因子为 $\\alpha_{\\mathrm{after}} = 0.15$ 的流水线阶段移动到当前活动因子为 $\\alpha_{\\mathrm{before}} = 0.25$ 的阶段。\n    增量功耗是这条导线新旧功耗之间的差值。\n    $$\\Delta P_{\\text{ret}} = P_{\\text{new}} - P_{\\text{old}} = (\\alpha_{\\mathrm{before}} \\Delta C_{\\mathrm{wire}} V^2 f) - (\\alpha_{\\mathrm{after}} \\Delta C_{\\mathrm{wire}} V^2 f)$$\n    $$\\Delta P_{\\text{ret}} = (\\alpha_{\\mathrm{before}} - \\alpha_{\\mathrm{after}}) \\Delta C_{\\mathrm{wire}} V^2 f$$\n    使用给定的值：$\\alpha_{\\mathrm{before}}=0.25$，$\\alpha_{\\mathrm{after}}=0.15$，$\\Delta C_{\\mathrm{wire}} = 60 \\times 10^{-15}\\,\\mathrm{F}$，$V=0.8\\,\\mathrm{V}$，$f=1 \\times 10^9\\,\\mathrm{Hz}$。\n    $$\\Delta P_{\\text{ret}} = (0.25 - 0.15) \\cdot (60 \\times 10^{-15}\\,\\mathrm{F}) \\cdot (0.8\\,\\mathrm{V})^2 \\cdot (1 \\times 10^9\\,\\mathrm{Hz})$$\n    $$\\Delta P_{\\text{ret}} = (0.10) \\cdot (60 \\times 10^{-15}) \\cdot (0.64) \\cdot (10^9)\\,\\mathrm{W} = 3.84 \\times 10^{-6}\\,\\mathrm{W}$$\n    四舍五入到四位有效数字得到 $3.840 \\times 10^{-6}\\,\\mathrm{W}$。\n\n四个计算结果按要求的顺序呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.300 \\times 10^{-11} & 1.100 \\times 10^{-11} & 6.400 \\times 10^{-5} & 3.840 \\times 10^{-6}\n\\end{pmatrix}\n}\n$$", "id": "3641571"}]}