{"hands_on_practices": [{"introduction": "数字设计的核心任务之一是将抽象的逻辑功能转化为高效的门级电路。本练习将引导你使用经典的卡诺图（Karnaugh map）方法，为给定的布尔函数寻找最简的“与或式”（SOP）和“或与式”（POS）表达。通过这个过程，你将亲身体会到，逻辑上等价的两种形式在物理实现上可能意味着不同的成本，包括所用逻辑门的总数和电路的响应速度（逻辑深度）。[@problem_id:3622497]", "problem": "考虑布尔函数 $f(A,B,C,D)$，其最小项由二进制代码 $ABCD$ 索引，其中 $A$ 是最高有效位。on-set（$f=1$ 的最小项集合）为 $\\{4,5,8,9,10,11,12,13,14,15\\}$，无关项集为 $\\{2,3\\}$，而 off-set（$f=0$ 的最小项集合）由其余最小项组成。\n\n使用一个 $4$ 变量卡诺图（Karnaugh map (K-map)）和标准的相邻规则，推导出 $f$ 的一个最小积之和（SOP）和一个最小和之积（POS）形式，并遵循给定的无关项条件。\n\n然后，在以下门级约束和定义下实现每种形式：\n- 仅可使用 $2$ 输入 $\\land$ (AND) 门、$2$ 输入 $\\lor$ (OR) 门和 $1$ 输入 $\\lnot$ (NOT) 门。\n- 原始输入仅以原变量形式提供；任何反变量 $X'$ 都必须通过一个作用于 $X$ 的独立 $\\lnot$ 门来实现。\n- 一个反转信号（例如 $\\lnot C$）可以在其所有使用位置共享；不要不必要地重复使用反相器。\n- SOP 严格实现为乘积项的 $\\lor$ 运算，其中每个乘积项由 $2$ 输入 $\\land$ 门的树形结构构成；POS 严格实现为和项的 $\\land$ 运算，其中每个和项由 $2$ 输入 $\\lor$ 门的树形结构构成。\n- 门数量是所使用的 $\\land$、$\\lor$ 和 $\\lnot$ 门的总数。\n- 逻辑深度定义为从任一原始输入到输出的路径上的最大门级数，路径上遇到的每个 $\\lnot$ 门计为深度 $1$，每个 $\\land$ 或 $\\lor$ 门计为深度 $1$。导线深度为零。\n\n对于每种实现（SOP 和 POS），计算 $\\land$、$\\lor$ 和 $\\lnot$ 门的总数以及最坏情况下的逻辑深度。最后，报告以下单一量值\n$$\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}},$$\n其中 $N_{\\text{gates}}$ 表示门的总数（$\\land+\\lor+\\lnot$）。无需四舍五入；提供一个精确的整数作为最终答案。", "solution": "用户希望找到一个给定布尔函数的最小积之和 (SOP) 和最小和之积 (POS) 实现之间的门数量差异。\n\n### 步骤 1：问题验证\n\n首先，我将验证问题陈述。\n\n**1.1. 提取给定条件**\n- **函数**：一个 $4$ 变量布尔函数 $f(A,B,C,D)$。\n- **索引**：最小项由二进制代码 $ABCD$ 索引，其中 $A$ 为最高有效位 (MSB)。\n- **On-Set (f=1 的最小项)**: $S_m = \\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$。\n- **无关项集**：$S_d = \\{2, 3\\}$。\n- **Off-Set (f=0 的最小项)**: $\\{0, 1, \\dots, 15\\}$ 中的其余最小项。\n- **任务**：使用 $4$ 变量卡诺图 (K-map) 推导出 $f$ 的最小 SOP 和 POS 形式。\n- **实现约束**：\n  - 可用门：$2$ 输入 $\\land$ (AND)，$2$ 输入 $\\lor$ (OR)，$1$ 输入 $\\lnot$ (NOT)。\n  - 原始输入 ($A,B,C,D$) 为原变量形式。反变量 ($\\lnot X$) 需要一个 $\\lnot$ 门。\n  - 反相器可以共享。\n  - SOP 实现：乘积项的 $\\lor$ 运算。每个乘积项是一个由 $2$ 输入 $\\land$ 门构成的树。\n  - POS 实现：和项的 $\\land$ 运算。每个和项是一个由 $2$ 输入 $\\lor$ 门构成的树。\n- **度量指标**：\n  - $N_{\\text{gates}}$: $\\land$、$\\lor$ 和 $\\lnot$ 门的总数。\n  - 逻辑深度：任何输入到输出路径上的最大门数。\n- **最终目标**：计算 $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$。\n\n**1.2. 使用提取的给定条件进行验证**\n- **科学依据**：该问题植根于数字逻辑设计的基本原理，特别是布尔代数、卡诺图化简和门级实现。它是计算机工程中一种标准的、成熟的问题类型。该问题在科学上是合理的。\n- **适定性**：通过 on-set、off-set 和无关项集，函数被完全指定。化简过程是标准的，可以得到最小形式（在本例中是唯一的）。门级实现的约束是精确的。最终目标是一个明确定义的计算。该问题是适定的。\n- **客观性**：问题使用形式化、客观的语言陈述，没有歧义或主观因素。\n\n**1.3. 结论与行动**\n问题有效。我将继续解决它。\n\n### 步骤 2：卡诺图构建与化简\n\n首先，我们确定 off-set。所有最小项的集合是 $\\{0, 1, ..., 15\\}$。off-set $S_f$ 是 $\\{0, 1, ..., 15\\} \\setminus (S_m \\cup S_d) = \\{0, 1, 6, 7\\}$。\n\n我们为 $f(A,B,C,D)$ 构建一个 $4$ 变量卡诺图。该图的结构是：变量 $AB$ 代表行，$CD$ 代表列，两者均按格雷码顺序 ($00, 01, 11, 10$)排列。\n\n卡诺图填充如下：\n- on-set中的最小项填 `1`：$\\{4, 5, 8, 9, 10, 11, 12, 13, 14, 15\\}$\n- 无关项集中的最小项填 `X`：$\\{2, 3\\}$\n- off-set中的最小项填 `0`：$\\{0, 1, 6, 7\\}$\n\n得到的卡诺图是：\n$$\n\\begin{array}{c|c|c|c|c|}\n\\multicolumn{1}{r}{CD}  \\multicolumn{4}{c}{AB} \\\\\n\\multicolumn{1}{r}{}  00  01  11  \\multicolumn{1}{c}{10} \\\\\n\\cline{2-5}\n00  0_{0}  1_{4}  1_{12}  1_{8} \\\\\n\\cline{2-5}\n01  0_{1}  1_{5}  1_{13}  1_{9} \\\\\n\\cline{2-5}\n11  X_{3}  0_{7}  1_{15}  1_{11} \\\\\n\\cline{2-5}\n10  X_{2}  0_{6}  1_{14}  1_{10} \\\\\n\\cline{2-5}\n\\end{array}\n$$\n\n**2.1. 最小积之和 (SOP) 形式**\n我们圈出所有的 $1$，必要时使用 $X$，以形成大小为 $2$ 的幂的最大可能矩形分组。\n\n1.  可以通过合并最右边的两列（$AB=11$ 和 $AB=10$）形成一个包含 $8$ 个项的组，这对应于所有 $A=1$ 的最小项。该组覆盖了最小项 $\\{8,9,10,11,12,13,14,15\\}$。对应的乘积项是 $A$。\n\n2.  剩余未被覆盖的 $1$ 位于最小项 $4$ 和 $5$。我们可以通过包含已覆盖的最小项 $12$ 和 $13$ 来形成一个包含 $4$ 个项的组。该组覆盖了 $\\{4,5,12,13\\}$。这对应于 $B=1$ 和 $C=0$。乘积项是 $B \\land (\\lnot C)$，或写作 $B C'$。\n\n这两项覆盖了 on-set 中的所有最小项。`A` 是覆盖最小项如 $10, 11, 14, 15$ 的本质主蕴含项。`BC'` 是覆盖最小项 $4$ 和 $5$ 的本质主蕴含项。因此，最小 SOP 表达式是唯一的。\n\n$$f_{\\text{SOP}}(A,B,C,D) = A \\lor (B \\land C')$$\n\n**2.2. 最小和之积 (POS) 形式**\n为了找到 $f$ 的最小 POS 形式，我们首先通过在卡诺图中圈出 $0$（必要时使用 $X$）来找到其补函数 $\\lnot f$ 的最小 SOP 形式。\n\n1.  可以由最小项 $\\{0,1\\}$ 和无关项 $\\{2,3\\}$ 组成一个包含 $4$ 个项的组。这对应于 $A=0$ 和 $B=0$ 的区域。乘积项是 $(\\lnot A) \\land (\\lnot B)$，或写作 $A'B'$。这是 $\\lnot f$ 的一个本质主蘊含项，因为它是唯一覆盖最小项 $0$ 和 $1$ 的项。\n\n2.  可以由最小项 $\\{6,7\\}$ 和无关项 $\\{2,3\\}$ 组成另一个包含 $4$ 个项的组。这对应于 $A=0$ 和 $C=1$ 的区域。乘积项是 $(\\lnot A) \\land C$，或写作 $A'C$。这是 $\\lnot f$ 的一个本质主蘊含项，覆盖了最小项 $6$ 和 $7$。\n\n$\\lnot f$ 的最小 SOP 形式是：\n$$(\\lnot f)(A,B,C,D) = (A' \\land B') \\lor (A' \\land C)$$\n\n应用德摩根定律来找到 $f$ 的 POS 形式：\n$$f = \\lnot(\\lnot f) = \\lnot((A' \\land B') \\lor (A' \\land C))$$\n$$f = \\lnot(A' \\land B') \\land \\lnot(A' \\land C)$$\n$$f = (\\lnot(A') \\lor \\lnot(B')) \\land (\\lnot(A') \\lor \\lnot(C))$$\n$$f_{\\text{POS}}(A,B,C,D) = (A \\lor B) \\land (A \\lor C')$$\n\n### 步骤 3：门级实现分析\n\n我们现在根据给定的约束条件，分析每种最小形式的门数量和逻辑深度。\n\n**3.1. SOP 实现: $f = A \\lor (B \\land C')$**\n- **变量**：表达式使用变量 $A$、$B$ 和 $C'$。\n- **NOT 门**：需要一个 $\\lnot$ 门从 $C$ 生成 $C'$。$N_{\\lnot}^{\\text{SOP}} = 1$。\n- **AND 门**：需要一个 $2$ 输入 $\\land$ 门来实现乘积项 $B \\land C'$。$N_{\\land}^{\\text{SOP}} = 1$。\n- **OR 门**：需要一个 $2$ 输入 $\\lor$ 门来实现最终的和 $A \\lor (B \\land C')$。注意 $A$ 是一个单变量项，直接输入到 $\\lor$ 门。$N_{\\lor}^{\\text{SOP}} = 1$。\n- **总门数量**：$N_{\\text{gates}}^{\\text{SOP}} = N_{\\lnot}^{\\text{SOP}} + N_{\\land}^{\\text{SOP}} + N_{\\lor}^{\\text{SOP}} = 1 + 1 + 1 = 3$。\n- **逻辑深度**：从输入到输出的最长路径是输入 $C$ 的路径。路径($C$): $C \\to \\lnot \\to \\land \\to \\lor \\to f$。深度为 $1 (\\lnot) + 1 (\\land) + 1 (\\lor) = 3$。\n\n**3.2. POS 实现: $f = (A \\lor B) \\land (A \\lor C')$**\n- **变量**：表达式使用变量 $A$、$B$ 和 $C'$。\n- **NOT 门**：需要一个 $\\lnot$ 门来生成 $C'$。该门被共享。$N_{\\lnot}^{\\text{POS}} = 1$。\n- **OR 门**：需要两个 $2$ 输入 $\\lor$ 门来实现和项 $(A \\lor B)$ 和 $(A \\lor C')$。$N_{\\lor}^{\\text{POS}} = 2$。\n- **AND 门**：需要一个 $2$ 输入 $\\land$ 门来实现两个和项的最终乘积。$N_{\\land}^{\\text{POS}} = 1$。\n- **总门数量**：$N_{\\text{gates}}^{\\text{POS}} = N_{\\lnot}^{\\text{POS}} + N_{\\lor}^{\\text{POS}} + N_{\\land}^{\\text{POS}} = 1 + 2 + 1 = 4$。\n- **逻辑深度**：最长路径同样是输入 $C$ 的路径。路径($C$): $C \\to \\lnot \\to \\lor \\to \\land \\to f$。深度为 $1 (\\lnot) + 1 (\\lor) + 1 (\\land) = 3$。\n\n### 步骤 4：最终计算\n\n问题要求计算量 $\\Delta \\equiv N_{\\text{gates}}^{\\text{POS}} - N_{\\text{gates}}^{\\text{SOP}}$。\n使用计算出的门数量：\n$$N_{\\text{gates}}^{\\text{SOP}} = 3$$\n$$N_{\\text{gates}}^{\\text{POS}} = 4$$\n$$\\Delta = 4 - 3 = 1$$", "answer": "$$\\boxed{1}$$", "id": "3622497"}, {"introduction": "在单个函数优化的基础上，我们进一步探讨真实世界中更常见的情形：如何优化一个包含多个相关输出的逻辑系统。独立地优化每一个函数并非总是最高效的策略。本练习将向你展示如何运用布尔代数中的因式分解技巧，从多个逻辑表达式中提取出“公共核”（common kernel），并通过逻辑共享显著减少硬件资源消耗和优化电路性能。[@problem_id:3622449]", "problem": "考虑一个同步数据通路中的控制输出 $F_{1}$ 和 $F_{2}$，每个输出都由主输入 $p,q,r,s,t$ 通过布尔算子 $\\land$ (逻辑与)、$\\lor$ (逻辑或) 和 $\\lnot$ (逻辑非) 表示如下：\n$$\nF_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s), \\quad\nF_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t).\n$$\n你将仅使用双输入 $\\land$ 和 $\\lor$ 门以及单输入 $\\lnot$ 门来实现这些输出。任何信号的扇出不产生门成本。定义逻辑深度为从主输入到给定输出的任何路径上的最大门级数，其中一个 $\\lnot$ 门计为一级，每个双输入 $\\land$ 或 $\\lor$ 门也计为一级。基准实现以给定的积之和形式独立构建 $F_{1}$ 和 $F_{2}$，并遵循以下约束：在单个函数内，像 $\\lnot p$ 这样的文字可以无需额外门即可扇出，但任何重复的非文字子表达式（例如 $(\\lnot p \\land q)$）在每个乘积项内都需单独重新计算。在基准实现中，不同输出之间不发生共享。\n\n从 $\\land$ 和 $\\lor$ 的结合律、交换律和分配律等基本定律出发，使用布尔代数执行代数除法，以分解出任何公共核，并重构网络，使得共享核只计算一次，并被复用于实现 $F_{1}$ 和 $F_{2}$。在相同的门和深度模型下，计算：\n- 从基准实现转到分解后的共享核实现时，门总数的减少量，以及\n- 两个输出的最大逻辑深度的减少量。\n\n将最终答案表示为一个含两个元素的行矩阵，其中第一个元素等于门数的减少量，第二个元素等于最大逻辑深度的减少量。无需四舍五入。", "solution": "用户希望分析一个逻辑电路的基准实现和优化实现，并计算门数和逻辑深度的减少量。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**步骤1：提取已知条件**\n- 控制输出为 $F_{1}$ 和 $F_{2}$。\n- 主输入为 $p, q, r, s, t$。\n- 布尔算子为 $\\land$ (与)、$\\lor$ (或) 和 $\\lnot$ (非)。\n- 逻辑函数：\n  $$F_{1} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land s)$$\n  $$F_{2} \\;=\\; (\\lnot p \\land q \\land r) \\;\\lor\\; (\\lnot p \\land q \\land t)$$\n- 可用门：双输入 $\\land$ 门、双输入 $\\lor$ 门和单输入 $\\lnot$ 门。\n- 任何信号的扇出成本为0个门。\n- 逻辑深度定义为从主输入到输出的任何路径上的最大门级数。\n- 基准实现约束：\n  1. $F_1$ 和 $F_2$ 独立构建。\n  2. 实现遵循给定的积之和形式。\n  3. 在一个函数内，文字（例如 $\\lnot p$）可以扇出。\n  4. 任何重复的非文字子表达式（例如 $(\\lnot p \\land q)$）在每个乘积项中为每次使用重新计算。\n  5. 两个不同输出（$F_1$ 和 $F_2$）之间不共享逻辑。\n- 优化任务：\n  1. 使用布尔代数（结合律、交换律、分配律）执行代数除法。\n  2. 分解出公共核。\n  3. 重构网络，使共享核只计算一次，并为 $F_1$ 和 $F_2$ 复用。\n- 要求输出：\n  1. 门总数的减少量。\n  2. 两个输出的最大逻辑深度的减少量。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**：该问题植根于数字逻辑设计和布尔代数的基本原理，这些是计算机工程和计算机科学的核心课题。逻辑门、积之和形式、逻辑深度和因式分解等概念都是标准内容。\n- **适定性**：该问题提供了明确的布尔函数、对门和成本度量（门数和深度）的清晰定义，以及对基准实现和优化实现的具体约束。这种结构确保可以推导出一个唯一的、稳定的、有意义的解。\n- **客观性**：该问题使用精确的数学符号和形式化语言陈述，没有歧义或主观性陈述。\n\n**步骤3：结论与行动**\n问题是有效的。这是一个定义明确的标准逻辑综合练习。我将继续进行解答。\n\n### 解题过程\n\n解题过程涉及分析基准实现和优化实现，以确定它们的门数和逻辑深度。\n\n**1. 基准实现分析**\n\n在基准实现中，$F_1$ 和 $F_2$ 是独立综合的。\n\n**对 $F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s)$ 的分析**：\n两个乘积项是 $T_1 = \\lnot p \\land q \\land r$ 和 $T_2 = \\lnot p \\land q \\land s$。\n- 为了实现 $T_1$，我们需要使用双输入与门来计算一个三输入与。这需要两个 $\\land$ 门，例如，实现为 $((\\lnot p \\land q) \\land r)$。\n  - $\\lnot p$ 需要一个 $\\lnot$ 门。\n  - $(\\lnot p \\land q)$ 需要一个 $\\land$ 门。\n  - $((\\lnot p \\land q) \\land r)$ 需要第二个 $\\land$ 门。\n- 为了实现 $T_2$，根据问题约束，非文字子表达式 $(\\lnot p \\land q)$ 必须重新计算。文字 $\\lnot p$ 可以从第一次计算中扇出。\n  - $(\\lnot p \\land q)$ 需要一个 $\\land$ 门（重新计算）。\n  - $((\\lnot p \\land q) \\land s)$ 需要第二个 $\\land$ 门。\n- 最后，需要一个 $\\lor$ 门来组合这两个乘积项：$F_1 = T_1 \\lor T_2$。\n\n$F_1$ 的门数：\n- $\\lnot$ 门：$1$个（用于 $\\lnot p$）\n- $\\land$ 门：$2$个（用于 $T_1$） + $2$个（用于 $T_2$） = $4$个\n- $\\lor$ 门：$1$个\n- $F_1$ 的总门数：$1 + 4 + 1 = 6$个。\n\n$F_1$ 的逻辑深度：\n逻辑深度是从任何主输入到输出的最长路径。我们追踪从输入 $p$ 开始的路径：\n- 第1级：$p \\to \\lnot p$（$\\lnot$ 门）\n- 第2级：$(\\lnot p, q) \\to (\\lnot p \\land q)$（$\\land$ 门）\n- 第3级：$((\\lnot p \\land q), r) \\to ((\\lnot p \\land q) \\land r)$（$\\land$ 门）\n- 第4级：$((\\lnot p \\land q \\land r), (\\lnot p \\land q \\land s)) \\to F_1$（$\\lor$ 门）\n$F_1$ 的最大深度为 $4$。\n\n**对 $F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t)$ 的分析**：\n$F_2$ 的结构与 $F_1$ 相同，只是输入 $s$ 被 $t$ 替换。由于在基准实现中 $F_1$ 和 $F_2$ 之间没有逻辑共享，因此 $F_2$ 的门数和深度与 $F_1$ 相同。\n- $F_2$ 的总门数：$6$个。\n- $F_2$ 的最大深度：$4$。\n\n**基准实现总计**：\n- 总门数 = ($F_1$ 的门数) + ($F_2$ 的门数) = $6 + 6 = 12$个。\n- 最大逻辑深度 = $\\max(F_1 \\text{的深度}, F_2 \\text{的深度}) = \\max(4, 4) = 4$。\n\n**2. 分解（共享核）实现分析**\n\n我们首先应用布尔代数的分配律 $A \\land B \\lor A \\land C = A \\land (B \\lor C)$ 来分解 $F_1$ 和 $F_2$ 的表达式。\n- 对于 $F_1$：令 $A = (\\lnot p \\land q)$。\n  $F_1 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land s) = (\\lnot p \\land q) \\land (r \\lor s)$。\n- 对于 $F_2$：类似地，\n  $F_2 = (\\lnot p \\land q \\land r) \\lor (\\lnot p \\land q \\land t) = (\\lnot p \\land q) \\land (r \\lor t)$。\n\n要共享的公共核是子表达式 $K = \\lnot p \\land q$。网络被重构以计算一次 $K$ 并复用它。\n\n**共享网络的实现**：\n1. 计算文字 $\\lnot p$：\n   - 一个 $\\lnot$ 门。\n2. 计算共享核 $K = \\lnot p \\land q$：\n   - 一个 $\\land$ 门。该信号被扇出到用于 $F_1$ 和 $F_2$ 的逻辑。\n3. 计算 $F_1 = K \\land (r \\lor s)$：\n   - 一个 $\\lor$ 门用于 $(r \\lor s)$。\n   - 一个 $\\land$ 门用于组合 $K$ 和 $(r \\lor s)$。\n4. 计算 $F_2 = K \\land (r \\lor t)$：\n   - 一个 $\\lor$ 门用于 $(r \\lor t)$。\n   - 一个 $\\land$ 门用于组合 $K$ 和 $(r \\lor t)$。\n\n分解实现的门数：\n- $\\lnot$ 门：$1$个（用于 $\\lnot p$）\n- $\\land$ 门：$1$个（用于 $K$） + $1$个（用于 $F_1$） + $1$个（用于 $F_2$） = $3$个\n- $\\lor$ 门：$1$个（用于 $F_1$） + $1$个（用于 $F_2$） = $2$个\n- 共享实现的总门数：$1 + 3 + 2 = 6$个。\n\n分解实现的逻辑深度：\n- 核 $K$ 的深度：从 $p$ 开始的路径是 $p \\to \\lnot p \\to K$。这条路径有 $2$ 个门级。\n- $F_1 = K \\land (r \\lor s)$ 的深度是 $\\max(K \\text{的深度}, (r \\lor s) \\text{的深度}) + 1$。\n  - $(r \\lor s)$ 的深度为 $1$。\n  - $F_1$ 的深度是 $\\max(2, 1) + 1 = 3$。\n- $F_2 = K \\land (r \\lor t)$ 的深度是 $\\max(K \\text{的深度}, (r \\lor t) \\text{的深度}) + 1$。\n  - $(r \\lor t)$ 的深度为 $1$。\n  - $F_2$ 的深度是 $\\max(2, 1) + 1 = 3$。\n\n**分解实现总计**：\n- 总门数 = $6$个。\n- 最大逻辑深度 = $\\max(F_1 \\text{的深度}, F_2 \\text{的深度}) = \\max(3, 3) = 3$。\n\n**3. 计算减少量**\n\n我们现在比较基准实现和分解实现。\n\n**门数减少量**：\n- 基准门数：$12$个。\n- 分解后门数：$6$个。\n- 减少量 = (基准门数) - (分解后门数) = $12 - 6 = 6$。\n\n**最大逻辑深度减少量**：\n- 基准最大深度：$4$。\n- 分解后最大深度：$3$。\n- 减少量 = (基准深度) - (分解后深度) = $4 - 3 = 1$。\n\n最终答案是一个含两个元素的行矩阵，分别包含门数减少量和深度减少量。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n6  1\n\\end{pmatrix}\n}\n$$", "id": "3622449"}, {"introduction": "现在，让我们将前面学到的逻辑设计与优化技巧应用于计算机体系结构的核心部件——算术逻辑单元（ALU）。本练习要求你为一个N位加法器设计溢出检测逻辑，这在确保算术运算正确性方面至关重要。通过分析和比较有符号数与无符号数加法中溢出检测电路的延迟差异，你将更深刻地理解基本逻辑门是如何构建起复杂运算功能并处理关键异常的。[@problem_id:3622512]", "problem": "考虑一个完全由2输入逻辑门 $\\land$ (AND)、$\\lor$ (OR) 和 $\\lnot$ (NOT) 构成的 $N$ 位行波进位加法器。每个门的单位延迟为1个门级，并且只允许使用2输入门。假设扇出不受限制且无额外延迟。该加法器接收输入 $\\{A_{i}\\}_{i=0}^{N-1}$ 和 $\\{B_{i}\\}_{i=0}^{N-1}$，以及一个初始进位 $C_{0}$，并产生进位 $\\{C_{i}\\}_{i=1}^{N}$ 和和 $\\{S_{i}\\}_{i=0}^{N-1}$。您只能使用以下事实作为基本依据：\n- 全加器的进位输出条件：$C_{i+1}=1$ 当且仅当 $A_{i}$、$B_{i}$ 和 $C_{i}$ 中至少有两个为 $1$。\n- 二补码有符号溢出发生当且仅当两个同符号操作数相加产生的结果的符号与操作数符号不同。\n\n任务：\n- 仅使用上述基本依据和允许的门，将无符号溢出检测合成为最终进位输出 $C_{N}$，并确定从主输入 $\\{A_{i},B_{i},C_{0}\\}$ 到溢出输出的最坏情况逻辑深度（以门级为单位）。\n- 仅使用上述基本依据和允许的门，合成一个最小的有符号溢出检测器，并确定其从相同输入出发的最坏情况逻辑深度（以门级为单位）。\n- 令 $L_{\\text{u}}(N)$ 表示无符号溢出检测的最坏情况逻辑深度，$L_{\\text{s}}(N)$ 表示有符号溢出检测的最坏情况逻辑深度。计算差值 $\\Delta L(N) \\equiv L_{\\text{s}}(N) - L_{\\text{u}}(N)$，并以 $N$ 的闭式表达式表示。\n\n仅提供 $\\Delta L(N)$ 的值作为最终答案。无需四舍五入。", "solution": "用户希望找到一个 $N$ 位行波进位加法器中，有符号和无符号溢出检测的最坏情况逻辑深度之差。\n\n### 第1步：问题验证\n\n**1.1. 提取已知条件：**\n- 一个 $N$ 位行波进位加法器由2输入逻辑门 $\\land$ (AND)、$\\lor$ (OR) 和 $\\lnot$ (NOT) 构成。\n- 每个门的单位延迟为1个门级。\n- 扇出不受限制且无额外延迟。\n- 输入为 $\\{A_{i}\\}_{i=0}^{N-1}$、$\\{B_{i}\\}_{i=0}^{N-1}$ 和一个初始进位 $C_{0}$。\n- 输出为进位 $\\{C_{i}\\}_{i=1}^{N}$ 和和 $\\{S_{i}\\}_{i=0}^{N-1}$。\n- 基本依据1：进位输出条件是“$C_{i+1}=1$ 当且仅当 $A_{i}, B_{i}$ 和 $C_{i}$ 中至少有两个为 $1$”。\n- 基本依据2：“二补码有符号溢出发生当且仅当两个同符号操作数相加产生的结果的符号与操作数符号不同。”\n- 无符号溢出检测是最终的进位输出 $C_{N}$。\n- 任务：\n    1. 合成无符号溢出检测，确定其最坏情况逻辑深度 $L_{\\text{u}}(N)$。\n    2. 合成一个最小的有符号溢出检测器，确定其最坏情况逻辑深度 $L_{\\text{s}}(N)$。\n    3. 计算差值 $\\Delta L(N) \\equiv L_{\\text{s}}(N) - L_{\\text{u}}(N)$。\n\n**1.2. 使用提取的已知条件进行验证：**\n- **科学依据：** 该问题是数字逻辑设计和计算机体系结构中的一个标准练习，基于二进制算术和布尔代数的基本原理。它是科学合理的。\n- **适定性：** 该问题提供了明确的目标和足够的约束（门类型、延迟、定义），以确定逻辑深度的唯一解析解。\n- **客观性：** 该问题使用正式、精确的语言陈述，没有主观性或歧义。\n- **完整性和一致性：** 该问题是自洽和一致的。进位生成和溢出的定义是标准的，可以导出一个可解的模型。\n- **其他缺陷：** 该问题没有清单中的任何其他缺陷。它不是微不足道的、不切实际的或无法验证的。\n\n**1.3. 结论和行动：**\n该问题是**有效的**。将提供完整的解决方案。\n\n### 第2步：无符号溢出检测逻辑深度，$L_{\\text{u}}(N)$\n\n$N$ 位加法的无符号溢出由最终进位输出 $C_{N}$ 指示。任务是找到计算 $C_{N}$ 的最坏情况逻辑深度，我们将其表示为 $L_{\\text{u}}(N)$。\n\n从第 $i$ 级产生的进位 $C_{i+1}$ 的逻辑定义为：当 $A_{i}$、$B_{i}$ 和 $C_{i}$ 中至少有两个为 $1$ 时，$C_{i+1}$ 为 $1$。这可以转化为布尔表达式：\n$$C_{i+1} = (A_{i} \\land B_{i}) \\lor (A_{i} \\land C_{i}) \\lor (B_{i} \\land C_{i})$$\n该表达式在逻辑上等价于更优化的进位输出公式：\n$$C_{i+1} = (A_{i} \\land B_{i}) \\lor ((A_{i} \\lor B_{i}) \\land C_{i})$$\n我们将使用后一种结构来分析行波进位链的延迟，因为它为每级提供了更小的延迟。令 $L(X)$ 为信号 $X$ 的逻辑深度（以门级为单位的到达时间）。主输入 $A_{i}$、$B_{i}$（对于 $i \\in \\{0, \\dots, N-1\\}$）和 $C_{0}$ 在 $L=0$ 时可用。\n\n$C_{i+1}$ 的逻辑深度取决于 $A_i$、$B_i$ 和 $C_i$ 的深度。我们可以建立一个关于 $L(C_{i})$ 的递推关系。\n\n首先，让我们计算第一个进位输出 $C_{1}$ 的深度。它的输入 $A_{0}$、$B_{0}$ 和 $C_{0}$ 都是主输入，在 $L=0$ 时可用。\n$$C_{1} = (A_{0} \\land B_{0}) \\lor ((A_{0} \\lor B_{0}) \\land C_{0})$$\n- 项 $T_{1} = A_{0} \\land B_{0}$ 和 $T_{2} = A_{0} \\lor B_{0}$ 是并行计算的。它们的深度是 $L(T_1) = L(T_2) = 1$。\n- 项 $T_{3} = T_{2} \\land C_{0}$ 取决于 $T_{2}$ 和 $C_{0}$。其深度为 $L(T_3) = \\max(L(T_2), L(C_0)) + 1 = \\max(1, 0) + 1 = 2$。\n- 最后的或运算结合了 $T_{1}$ 和 $T_{3}$。$C_{1}$ 的深度为 $L(C_{1}) = \\max(L(T_1), L(T_3)) + 1 = \\max(1, 2) + 1 = 3$。\n\n现在，我们来建立当 $i \\geq 1$ 时 $L(C_{i+1})$ 的递推关系。第 $i$ 级的输入是 $A_{i}$、$B_{i}$（主输入，$L=0$）和 $C_{i}$（前一级的输出，$L(C_i)$）。\n$$C_{i+1} = (A_{i} \\land B_{i}) \\lor ((A_{i} \\lor B_{i}) \\land C_{i})$$\n- $T_{1} = A_{i} \\land B_{i}$：$L(T_1) = 1$。\n- $T_{2} = A_{i} \\lor B_{i}$：$L(T_2) = 1$。\n- $T_{3} = T_{2} \\land C_{i}$：$L(T_3) = \\max(L(T_2), L(C_i)) + 1 = \\max(1, L(C_i)) + 1$。因为 $L(C_i) \\geq L(C_1) = 3$，这可以简化为 $L(C_i) + 1$。\n- $L(C_{i+1}) = \\max(L(T_1), L(T_3)) + 1 = \\max(1, L(C_i) + 1) + 1$。因为 $L(C_i)+1 > 1$，这可以简化为 $(L(C_i)+1) + 1 = L(C_i) + 2$。\n\n因此，我们得到了递推关系 $L(C_{i+1}) = L(C_i) + 2$（对于 $i \\geq 1$），基例为 $L(C_{1}) = 3$。这是一个等差数列。其解为：\n$L(C_{i}) = L(C_{1}) + (i-1) \\times 2 = 3 + 2i - 2 = 2i + 1$。\n\n无符号溢出的深度 $L_{\\text{u}}(N)$ 是 $C_{N}$ 的深度：\n$$L_{\\text{u}}(N) = L(C_{N}) = 2N + 1$$\n\n### 第3步：有符号溢出检测逻辑深度，$L_{\\text{s}}(N)$\n\n有符号溢出（$V$）的基本依据是：当操作数符号相同时，结果的符号 $S_{N-1}$ 与操作数 $A_{N-1}$ 和 $B_{N-1}$ 的符号不同。\n这可以表示为：\n$$V = (A_{N-1} \\land B_{N-1} \\land \\lnot S_{N-1}) \\lor (\\lnot A_{N-1} \\land \\lnot B_{N-1} \\land S_{N-1})$$\n数字逻辑中的一个标准结论是，有符号溢出也可以由以下公式给出，该结论可以从上述基本依据以及和位 $S_{N-1} = A_{N-1} \\oplus B_{N-1} \\oplus C_{N-1}$ 的逻辑推导出来：\n$$V = C_{N} \\oplus C_{N-1}$$\n这种实现通常是最小的。我们需要找到其最坏情况逻辑深度 $L_{\\text{s}}(N)$。计算 $V$ 需要信号 $C_{N}$ 和 $C_{N-1}$。使用我们上一节的公式：\n- $L(C_{N}) = 2N+1$。\n- $L(C_{N-1}) = 2(N-1) + 1 = 2N - 1$。\n\n使用允许的门实现的 $X \\oplus Y$ 的表达式是 $(X \\land \\lnot Y) \\lor (\\lnot X \\land Y)$。我们将其应用于 $V = C_{N} \\oplus C_{N-1}$。\n$$V = (C_{N} \\land \\lnot C_{N-1}) \\lor (\\lnot C_{N} \\land C_{N-1})$$\n总深度 $L_{\\text{s}}(N) = L(V)$ 由关键路径决定，关键路径取决于到达最终门的输入的到达时间。让我们追踪信号的到达时间：\n- $L(C_{N}) = 2N+1$\n- $L(C_{N-1}) = 2N-1$\n- $L(\\lnot C_{N}) = L(C_{N}) + 1 = (2N+1)+1 = 2N+2$\n- $L(\\lnot C_{N-1}) = L(C_{N-1}) + 1 = (2N-1)+1 = 2N$\n\n现在我们计算两个与项的深度：\n- 项 1：$\\lnot C_{N} \\land C_{N-1}$。深度为 $\\max(L(\\lnot C_{N}), L(C_{N-1})) + 1 = \\max(2N+2, 2N-1) + 1 = (2N+2)+1 = 2N+3$。\n- 项 2：$C_{N} \\land \\lnot C_{N-1}$。深度为 $\\max(L(C_{N}), L(\\lnot C_{N-1})) + 1 = \\max(2N+1, 2N) + 1 = (2N+1)+1 = 2N+2$。\n\n最后，结合这两个项的或门的深度是：\n$L_{\\text{s}}(N) = L(V) = \\max(\\text{项 1 的深度, 项 2 的深度}) + 1 = \\max(2N+3, 2N+2) + 1 = (2N+3)+1 = 2N+4$。\n$$L_{\\text{s}}(N) = 2N+4$$\n\n### 第4步：计算差值 $\\Delta L(N)$\n\n最后的任务是计算有符号和无符号溢出检测深度之间的差值。\n$$\\Delta L(N) = L_{\\text{s}}(N) - L_{\\text{u}}(N)$$\n代入我们推导出的表达式：\n$$\\Delta L(N) = (2N+4) - (2N+1)$$\n$$\\Delta L(N) = 3$$\n逻辑深度的差值是一个常数 $3$，与位数 $N$ 无关。这是因为有符号溢出的计算依赖于最终进位 $C_N$，而 $C_N$ 本身就是无符号溢出信号。计算 $C_N \\oplus C_{N-1}$ 的额外逻辑在 $C_N$ 到达之后增加了一个固定的3个门级的延迟。关键路径是 $C_N \\to \\lnot \\to \\land \\to \\lor$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3622512"}]}