{"hands_on_practices": [{"introduction": "“存储程序”概念的核心思想是，指令和数据一样，必须先加载到内存中才能由 CPU 执行。本练习将这一抽象原理具体化，要求你计算一个系统的启动时间，即从非易失性存储器将程序镜像复制到主内存所需的时间。通过这个计算，你将亲身体会到启动性能如何直接受限于内存带宽和传输协议等物理因素，从而深刻理解将指令视为数据加载所带来的实际影响。[@problem_id:3682329]", "problem": "存储程序系统实现了一种思想，即指令是驻留在内存中的数据，中央处理器（CPU）从内存中获取指令并执行。考虑这样一个系统的最小化引导加载程序，它在CPU开始从RAM获取指令之前，通过同步总线将一个指令镜像从非易失性存储器（NVM）复制到随机存取存储器（RAM）中。该总线宽度为 $W=128$ 位，CPU时钟频率为 $f=800 \\times 10^{6}$ 周/秒，引导加载程序以每次突发读取 $B=16$ 个总线字的方式发出连续的突发读取请求。每次突发读取会产生 $L=12$ 个周期的固定建立延迟，之后每个周期到达一个总线字，直到突发传输完成。指令镜像大小为 $N=64\\,\\text{MiB}$，其中 $1\\,\\text{MiB}=2^{20}\\,\\text{字节}$。假设引导加载程序发出覆盖 $N$ 字节所需的最小突发次数；如果最后一次突发是不完整的，它仍然会被发出并产生相同的建立延迟。\n\n仅从核心定义（例如，每个总线字的字节数由 $W$ 决定，每秒的周期数由 $f$ 决定，时间等于周期数除以 $f$）出发，推导出总启动时间作为 $N$、$W$、$B$、$L$ 和 $f$ 的函数，然后根据给定的参数进行数值计算。以秒为单位表示最终启动时间，并将答案四舍五入到四位有效数字。在您的推导中，请阐明存储程序概念是如何在不借助任何预设快捷公式的情况下，使启动时间依赖于内存带宽和传输粒度的。", "solution": "该问题是有效的，因为它科学地基于计算机体系结构的原理，问题设定良好，信息充分且一致，并且是客观的。所描述的场景是一个标准的引导加载过程，所提供的参数也是符合实际的。\n\n解决方案首先建立存储程序概念与加载指令镜像这一物理任务之间的联系。存储程序概念是现代计算机体系结构的基石，它指出指令和数据一样，都存储在内存中。为了让中央处理器（CPU）能够执行一个程序，该程序的指令必须首先驻留在CPU可以从中获取它们的内存类型中，通常是随机存取存储器（RAM）。本问题描述了引导过程，其中一个初始指令镜像从非易失性存储器（NVM）源复制到RAM中。这种传输是执行的强制性先决条件，其持续时间——即启动时间——因此是一个关键的性能指标。这个时间直接依赖于内存子系统的物理特性，例如数据路径宽度和传输协议，我们现在将从第一性原理出发对这些特性进行建模。\n\n首先，我们必须确定需要传输的总数据量，并以比特为基本单位表示。指令镜像大小为 $N = 64\\,\\text{MiB}$。根据提供的定义 $1\\,\\text{MiB} = 2^{20}\\,\\text{字节}$ 以及1字节等于8比特的核心定义，我们计算出以比特为单位的总镜像大小 $N_{bits}$：\n$$N_{bits} = N \\times (2^{20}\\ \\text{bytes/MiB}) \\times (8\\ \\text{bits/byte}) = 64 \\times 2^{20} \\times 8\\ \\text{bits}$$\n\n数据通过宽度为 $W=128$ 比特的同步总线进行传输。总线上的每次传输移动一个大小为 $W$ 比特的“总线字”。为了复制整个镜像而必须传输的总线字总数 $T_{words}$ 是总大小（以比特计）除以总线宽度（以比特计）：\n$$T_{words} = \\frac{N_{bits}}{W} = \\frac{N \\times 2^{20} \\times 8}{W}$$\n代入给定值 $N=64$ 和 $W=128$：\n$$T_{words} = \\frac{64 \\times 2^{20} \\times 8}{128} = \\frac{512 \\times 2^{20}}{128} = 4 \\times 2^{20} = 4 \\times 1048576 = 4194304\\ \\text{words}$$\n\n引导加载程序以每次突发读取 $B = 16$ 个总线字的方式进行连续读取。为了计算所需的突发传输总次数 $N_{bursts}$，我们将总字数 $T_{words}$ 除以每次突发传输的字数 $B$。由于问题指明即使最后一次突发是不完整的，也作为一个完整的操作发出（产生相同的建立延迟），我们必须对这个除法结果取上整：\n$$N_{bursts} = \\left\\lceil \\frac{T_{words}}{B} \\right\\rceil$$\n代入计算出的 $T_{words}$ 值和给定的 $B=16$ 值：\n$$N_{bursts} = \\left\\lceil \\frac{4194304}{16} \\right\\rceil = \\lceil 262144 \\rceil = 262144\\ \\text{bursts}$$\n在这个特定情况下，总字数是突发大小的整数倍，因此没有不完整的突发。然而，通用公式必须包含上取整函数。\n\n接下来，我们计算以时钟周期为单位的总时间。总时间是两部分之和：数据传输所花费的时间，以及所有突发传输的建立延迟累积时间。\n每次突发传输，无论是完整的还是部分的，都会产生 $L = 12$ 个周期的建立延迟。总共有 $N_{bursts}$ 次突发，因此用于建立的总时间是：\n$$C_{latency} = N_{bursts} \\times L$$\n在一次突发传输的初始延迟之后，每个周期到达一个总线字。因此，传输实际数据所花费的总时间等于要传输的总字数 $T_{words}$。\n$$C_{transfer} = T_{words}$$\n以时钟周期为单位的总时间 $C_{total}$ 是这两个部分之和：\n$$C_{total} = C_{latency} + C_{transfer} = (N_{bursts} \\times L) + T_{words}$$\n\n代入我们已计算出的数值：$N_{bursts} = 262144$，$L=12$ 和 $T_{words} = 4194304$：\n$$C_{total} = (262144 \\times 12) + 4194304 = 3145728 + 4194304 = 7340032\\ \\text{cycles}$$\n\n为了计算以秒为单位的总启动时间 $T_{boot}$，我们将总周期数 $C_{total}$ 除以CPU时钟频率 $f = 800 \\times 10^{6}$ 周/秒。\n$$T_{boot} = \\frac{C_{total}}{f}$$\n代入数值：\n$$T_{boot} = \\frac{7340032}{800 \\times 10^{6}} = \\frac{7340032}{8 \\times 10^{8}} = 0.00917504\\ \\text{seconds}$$\n\n问题要求答案四舍五入到四位有效数字。\n$$T_{boot} \\approx 0.009175\\ \\text{seconds}$$\n这可以用科学记数法表示为 $9.175 \\times 10^{-3}$ 秒。\n\n最后，我们将总启动时间表示为给定参数 $N$、$W$、$B$、$L$ 和 $f$ 的函数。\n$$T_{boot}(N, W, B, L, f) = \\frac{C_{total}}{f} = \\frac{1}{f} \\left( L \\cdot N_{bursts} + T_{words} \\right)$$\n代入 $N_{bursts}$ 和 $T_{words}$ 的表达式：\n$$T_{words} = \\frac{8 \\cdot N \\cdot 2^{20}}{W}$$\n$$N_{bursts} = \\left\\lceil \\frac{T_{words}}{B} \\right\\rceil = \\left\\lceil \\frac{8 \\cdot N \\cdot 2^{20}}{W \\cdot B} \\right\\rceil$$\n因此，启动时间的通用符号表达式为：\n$$T_{boot} = \\frac{1}{f} \\left( L \\cdot \\left\\lceil \\frac{8 \\cdot N \\cdot 2^{20}}{W \\cdot B} \\right\\rceil + \\frac{8 \\cdot N \\cdot 2^{20}}{W} \\right)$$\n该公式明确地展示了启动时间——作为实现存储程序概念的直接后果——是如何由镜像大小（$N$）、内存总线带宽（与 $W$ 和 $f$ 相关）以及传输粒度/开销（与 $B$ 和 $L$ 相关）决定的。", "answer": "$$\\boxed{9.175 \\times 10^{-3}}$$", "id": "3682329"}, {"introduction": "将程序加载到内存是第一步，但如果想让程序能在内存的任意位置运行，该怎么做呢？这对于现代操作系统和共享库至关重要。本练习将带你探索实现这一目标的关键技术——位置无关代码（PIC）。你将学习代码如何通过计算相对于程序计数器（$PC$）的偏移量来实现跳转，而不是依赖于固定的绝对地址，从而确保代码在内存中被移动后依然能正确执行。[@problem_id:3682297]", "problem": "一个精简指令集计算处理器实现了存储程序概念：指令和数据共享一个单一的线性字节寻址内存，处理器使用程序计数器（PC）来获取下一条指令。考虑位置无关代码（PIC），其中控制流目标是相对于程序计数器（PC）表示的，而不是作为绝对内存地址。\n\n仅从以下基本事实和定义出发：存储程序概念，程序计数器（PC）作为存放下一条待取指令地址的寄存器的定义，通过一个常数地址增量 $\\Delta$ 进行的平移（重定位）的概念（该增量统一应用于所有代码和数据地址），以及指令中嵌入一个以一条指令为单位表示的有符号位移字段的存在。不要假设任何预先推导出的PC相对目标的公式。\n\n给定一个特定的顺序执行流水线和编码模型：\n- 该流水线有 $n=7$ 个阶段，编号从 $1$ 到 $7$，其中阶段 $1$ 是指令获取，阶段 $4$ 是算术/逻辑执行阶段，在该阶段形成控制流的有效地址。\n- 指令宽度为 $w=4$ 字节。\n- 程序计数器（PC）在每个周期的阶段 $1$（获取）增加 $w$。当一条指令处于阶段 $4$（执行）时，阶段 $4$ 观察到的 PC 值对应于取指单元已经比执行阶段中的指令地址提前了整整 $\\kappa$ 条指令。在这个微体系结构中，执行阶段是阶段 $4$，所以 $\\kappa=3$。\n- 一条控制流指令包含一个有符号位移 $\\delta$，以一条指令为单位进行编码，这意味着位移是以 $w$ 字节的倍数来度量的。\n\nA 部分（概念性）：仅使用上述基本事实，论证为什么从程序计数器（PC）和嵌入的有符号位移形成控制流目标，在通过任何常数 $\\Delta$ 进行重定位时会产生平移不变性。也就是说，如果所有代码在内存中被移动了 $\\Delta$，解释为什么在不修改指令编码的情况下，给定指令计算出的目标地址会精确地移动相同的 $\\Delta$，正如位置无关代码（PIC）所要求的那样。\n\nB 部分（计算）：考虑一条重定位后的控制流指令，其自身地址为 $A = L + o$，其中加载基地址为 $L = 0x400000$，指令在其代码段内的偏移量为 $o = 0x160$。有符号位移字段为 $\\delta=-5$。在上述流水线语义下，确定执行阶段观察到的控制流目标的确切字节地址，并以十进制整数表示。无需四舍五入；给出确切的整数值。在最终的数值答案中不要包含任何单位符号。", "solution": "所陈述的问题是有效的。它在科学上基于计算机组成和体系结构的原理，特别是存储程序概念、流水线执行和位置无关代码（PIC）。该问题提法恰当，为得出唯一解提供了所有必要的定义、约束和数据。语言客观而精确。\n\n本解答分为两部分，对应问题陈述的两个部分。\n\n### A 部分：平移不变性的概念性论证\n\n位置无关代码（PIC）的核心原则是，控制流目标和数据访问的内存地址是相对于当前执行位置计算的，而不是被硬编码为绝对地址。这允许一个代码块在不经修改的情况下，从内存的任何位置加载和执行。我们将演示 PC 相对寻址方案如何实现这种平移不变性的特性。\n\n设 $A_{instr}$ 为给定控制流指令的绝对内存地址。\n根据问题的流水线模型，当这条指令处于执行阶段（阶段 $i=4$）时，程序计数器（PC）已经被更新了多次。PC 始终持有*下一条待取*（在阶段 1）指令的地址。鉴于地址为 $A_{instr}$ 的指令处于阶段 $4$，自其被取指以来，流水线已经前进了 $4-1=3$ 个周期。问题将此提前量定义为 $\\kappa = 3$ 条指令。\n指令宽度给定为 $w$ 字节。因此，执行阶段观察到的 PC 值，记作 $PC_{exec}$，是比当前执行指令提前 $\\kappa$ 条指令的指令地址。\n$$PC_{exec} = A_{instr} + \\kappa \\cdot w$$\n\n控制流指令包含一个嵌入的有符号位移 $\\delta$，它以一条指令为单位表示。为了计算字节偏移量，该位移必须乘以指令宽度 $w$。然后，通过将此字节偏移量加到执行阶段观察到的 PC 值上来计算目标地址 $A_{target}$。\n$$A_{target} = PC_{exec} + \\delta \\cdot w$$\n代入 $PC_{exec}$ 的表达式，我们得到：\n$$A_{target} = (A_{instr} + \\kappa \\cdot w) + \\delta \\cdot w$$\n\n现在，让我们考虑内存重定位的影响。假设整个代码和数据块在内存中被一个常数地址增量 $\\Delta$ 平移（重定位）。每个原始地址 $X$ 都被映射到一个新地址 $X' = X + \\Delta$。\n\n我们的控制流指令的新地址变为：\n$$A'_{instr} = A_{instr} + \\Delta$$\n\n指令本身未被修改；其二进制编码，包括位移字段 $\\delta$，保持不变。当这条重定位后的指令处于执行阶段时，处理器使用与之前相同的逻辑计算目标地址，但基于新的、重定位后的地址。在执行阶段观察到的 PC 值 $PC'_{exec}$ 将相对于新的指令地址 $A'_{instr}$：\n$$PC'_{exec} = A'_{instr} + \\kappa \\cdot w = (A_{instr} + \\Delta) + \\kappa \\cdot w$$\n\n新的目标地址 $A'_{target}$ 是使用这个新的 PC 值和未改变的位移计算出来的：\n$$A'_{target} = PC'_{exec} + \\delta \\cdot w = ((A_{instr} + \\Delta) + \\kappa \\cdot w) + \\delta \\cdot w$$\n通过重新排列各项，我们可以分离出重定位偏移量 $\\Delta$：\n$$A'_{target} = (A_{instr} + \\kappa \\cdot w + \\delta \\cdot w) + \\Delta$$\n括号中的表达式正是原始目标地址 $A_{target}$。因此，我们有：\n$$A'_{target} = A_{target} + \\Delta$$\n\n这个结果表明，代码通过一个常数 $\\Delta$ 的重定位，导致计算出的目标地址也被重定位了完全相同的常数 $\\Delta$。这是在不修改指令编码的位移 $\\delta$ 的情况下实现的。目标地址与指令自身地址之间的差值，$A_{target} - A_{instr} = (\\kappa + \\delta)w$，是一个由指令编码和流水线体系结构决定的常数，而不是由指令的绝对位置决定的。这就是平移不变性的本质以及位置无关代码的功能。\n\n### B 部分：控制流目标地址的计算\n\n我们将使用 A 部分推导出的公式来计算控制流目标的确切字节地址。公式是：\n$$A_{target} = A_{instr} + (\\kappa + \\delta) \\cdot w$$\n\n首先，我们必须确定控制流指令的绝对地址 $A_{instr}$。问题指出它位于地址 $A = L + o$ 处，其中加载基地址为 $L = 0x400000$，偏移量为 $o = 0x160$。我们必须将这些十六进制值转换为十进制。\n\n加载基地址 $L$ 是：\n$$L = 0x400000 = 4 \\times 16^{5} = 4 \\times 1048576 = 4194304$$\n\n偏移量 $o$ 是：\n$$o = 0x160 = 1 \\times 16^{2} + 6 \\times 16^{1} + 0 \\times 16^{0} = 256 + 96 + 0 = 352$$\n\n指令的绝对地址 $A_{instr}$ 是这两个值的和：\n$$A_{instr} = L + o = 4194304 + 352 = 4194656$$\n\n接下来，我们整理问题陈述中提供的其余参数：\n- 流水线提前指令数：$\\kappa = 3$。\n- 指令中的有符号位移：$\\delta = -5$。\n- 指令宽度（字节）：$w = 4$。\n\n现在，我们将这些值代入目标地址 $A_{target}$ 的公式中：\n$$A_{target} = 4194656 + (3 + (-5)) \\cdot 4$$\n$$A_{target} = 4194656 + (-2) \\cdot 4$$\n$$A_{target} = 4194656 - 8$$\n$$A_{target} = 4194648$$\n\n因此，控制流目标的确切字节地址是 $4194648$。", "answer": "$$\\boxed{4194648}$$", "id": "3682297"}, {"introduction": "“存储程序”概念在现代计算中催生了动态代码生成等高级应用，例如即时（JIT）编译器，它会在运行时创建并执行新的机器指令。本练习将你置于一个多核处理器的前沿场景中：一个核心生成代码（数据），另一个核心执行它。你将面临因指令缓存与数据缓存分离而引发的复杂同步问题，并需要从给定的原子操作中选择正确的序列，以确保新生成的代码能够被正确无误地执行。[@problem_id:3682322]", "problem": "考虑一个对称多处理器系统，该系统在一个中央处理器 (CPU) 内包含 $2$ 个核心，即核心 $0$ 和核心 $1$。该系统为共享物理内存实现了缓存一致性，但每个核心使用独立的指令缓存 (I-cache) 和数据缓存 (D-cache)，且没有自动的指令-数据一致性。也就是说，在没有显式操作的情况下，通过 D-cache 执行的写入不保证会使任何 I-cache 失效或更新。在此场景中，转译后备缓冲器 (TLB) 的映射保持不变。核心 $0$ 通过将 $N$ 字节写入一个共享的、页面对齐的区域 $[P, P+N)$ 来为函数 $F$ 生成机器码，然后通过向地址 $Q$ 写入一个就绪标志值来发信号通知其可用性。核心 $1$ 稍后跳转到地址 $P$ 以执行 $F$。\n\n可用的原语及其语义：\n- `flushD(R)`: 确保调用核心先前对区域 $R$ 执行的所有存储操作都已从 D-cache 写回到一致性点，并对其他核心的内存层次结构可见。\n- `mb_full()`: 一个完整的、系统范围的内存屏障。它将在所有后续的内存操作之前对所有先前的内存操作进行排序（跨核心），当与通过标志进行的核间同步结合使用时，建立一个先行发生（happens-before）关系。\n- `invalidateI(R)`: 使调用核心中覆盖区域 $R$ 的 I-cache 行失效，因此后续的指令提取将从一致性点重新获取。\n- `isync()`: 一个指令同步屏障，确保任何后续的指令提取和解码都能观察到先前的 I-cache 失效和内存排序操作的效果。\n\n假设：\n- 在核心 $1$ 执行 $F$ 之前，核心 $1$ 可能有针对 $[P, P+N)$ 的过时 I-cache 行。\n- 核心 $0$ 的写入最初驻留在核心 $0$ 的 D-cache 中，并且在显式刷新之前可能不是全局可见的。\n- 核心 $1$ 轮询位于 $Q$ 的就绪标志，并用它来协调何时继续。\n\n在这些假设和存储程序概念（即指令是存储在内存中并作为字节序列提取的数据）下，选择唯一能保证核心 $1$ 在第一次尝试时正确且确定性地执行新生成的函数 $F$ 的操作序列。\n\n选项：\n\nA. 核心 $0$：将 $F$ 写入 $[P,P+N)$；`flushD([P,P+N))`；`mb_full()`；向 $Q$ 存储就绪标志值 $1$。核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`invalidateI([P,P+N))`；`isync()`；跳转到 $P$。\n\nB. 核心 $0$：将 $F$ 写入 $[P,P+N)$；向 $Q$ 存储就绪标志值 $1$。核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`mb_full()`；跳转到 $P$。\n\nC. 核心 $0$：`invalidateI([P,P+N))`；将 $F$ 写入 $[P,P+N)$；`mb_full()`；向 $Q$ 存储就绪标志值 $1$。核心 $1$：自旋直到从 $Q$ 加载返回 $1$；跳转到 $P$。\n\nD. 核心 $0$：将 $F$ 写入 $[P,P+N)$；`flushD([P,P+N))`；向 $Q$ 存储就绪标志值 $1$。核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`isync()`；跳转到 $P$。\n\n选择通过正确排序 `flush` 和 `barrier` 原语来保证核心 $1$ 执行由核心 $0$ 生成的代码的正确性的选项。", "solution": "问题描述了多核系统编程中一个涉及动态代码生成的经典场景，这在即时 (JIT) 编译中经常遇到。核心挑战源于指令缓存 (I-caches) 和数据缓存 (D-caches) 的分离，且它们之间没有硬件自动管理的一致性。这需要一个显式的软件操作序列，以确保一个核心作为数据写入的代码能被另一个核心作为指令正确执行。\n\n该问题被判定为有效，因为它在科学上植根于计算机组成和体系结构的原理，问题设定良好且客观。它准确地模拟了现代处理器在缓存一致性和内存排序方面的复杂性。\n\n为确保核心 $1$ 正确执行由核心 $0$ 生成的函数 $F$，必须强制执行一个精确的事件序列。让我们从第一性原理推导出这个序列。\n\n**核心 $0$ (写入者/生产者):**\n1.  **代码生成：** 核心 $0$ 将函数 $F$ 的机器码写入内存区域 $[P, P+N)$。这些写操作修改了核心 $0$ 的私有 D-cache 中的行。此时，新代码对核心 $1$ 甚至主内存系统都不可见。\n2.  **数据可见性：** 新写入的代码必须从核心 $0$ 的私有 D-cache 传播到一致性点（例如，共享的末级缓存或主内存），核心 $1$ 可以从那里获取它。原语 `flushD([P, P+N))` 完成了此任务，确保数据被“写回”。\n3.  **内存排序：** 现代处理器可能会为了性能而重排序内存操作。至关重要的是，函数代码的写入（通过刷新使其可见）必须在地址 $Q$ 处的就绪标志更新*之前*被全局观察到。如果核心 $1$ 在代码可用之前看到了标志，它将尝试执行过时或垃圾指令。需要一个完整的内存屏障 `mb_full()` 来强制执行此排序。它保证所有先前的内存操作（包括 `flushD` 的效果）在任何后续的内存操作（对 $Q$ 的存储）执行之前完成并变为全局可见。\n4.  **同步信号：** 在确保代码可见且有序之后，核心 $0$ 向地址 $Q$ 的就绪标志写入数据。此存储操作充当给核心 $1$ 的信号。\n\n因此，核心 $0$ 的正确、确定性序列是：\n- 将 $F$ 写入 $[P,P+N)$\n- `flushD([P,P+N))`\n- `mb_full()`\n- 向 $Q$ 存储就绪标志值 $1$\n\n**核心 $1$ (执行者/消费者):**\n1.  **同步等待：** 核心 $1$ 自旋，重复从地址 $Q$ 加载值，直到读取到就绪值 ($1$)。系统的基本数据缓存一致性确保核心 $0$ 的存储最终会被核心 $1$ 观察到。\n2.  **指令缓存一致性：** 读取到就绪标志后，核心 $1$ 知道函数 $F$ 的正确机器码在一致性点是可用的。但是，它自己的 I-cache 可能持有针对地址范围 $[P, P+N)$ 的过时指令。问题指出没有自动的 I-D 一致性。因此，核心 $1$ 必须显式地使这些过时的 I-cache 条目失效。原语 `invalidateI([P,P+N))` 在调用核心的 I-cache 上执行此操作。\n3.  **指令流水线同步：** 仅仅使 I-cache 行失效本身是不够的。处理器的指令提取流水线可能在失效操作完成*之前*就已经从过时的 I-cache 中提取并解码了指令。需要一个指令同步屏障 `isync()` 来刷新流水线，并确保在屏障之后执行的任何指令都是从内存层次结构中重新获取的（现在将在 I-cache 中未命中并获取正确的代码）。\n4.  **执行：** 在其 I-cache 和指令流水线正确同步后，核心 $1$现在可以安全地跳转到地址 $P$ 并开始执行正确的、新生成的函数 $F$。\n\n因此，核心 $1$ 的正确、确定性序列是：\n- 自旋直到从 $Q$ 加载返回 $1$\n- `invalidateI([P,P+N))`\n- `isync()`\n- 跳转到 $P$\n\n将这两个序列结合起来，就得到了完整、正确的协议。让我们根据这个推导来评估各个选项。\n\n**选项 A：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；`flushD([P,P+N))`；`mb_full()`；向 $Q$ 存储就绪标志值 $1$。\n- 核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`invalidateI([P,P+N))`；`isync()`；跳转到 $P$。\n这个序列与从第一性原理推导出的序列完全匹配。核心 $0$ 正确地确保了数据可见性和排序。核心 $1$ 正确地确保了指令缓存一致性和流水线同步。\n**结论：正确**\n\n**选项 B：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；向 $Q$ 存储就绪标志值 $1$。\n这是有缺陷的。它省略了 `flushD()`，因此代码可能永远不会离开核心 $0$ 的 D-cache。它还省略了 `mb_full()`，允许标志存储被重排序到代码写入可见之前，从而产生竞争条件。\n- 核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`mb_full()`；跳转到 $P$。\n这是有缺陷的。它省略了关键的 `invalidateI()` 和 `isync()` 步骤，这意味着核心 $1$ 很可能会执行其 I-cache 中的过时指令。\n**结论：不正确**\n\n**选项 C：**\n- 核心 $0$：`invalidateI([P,P+N))`；将 $F$ 写入 $[P,P+N)$；`mb_full()`；向 $Q$ 存储就绪标志值 $1$。\n这是有缺陷的。在核心 $0$ 上执行 `invalidateI()` 是无关紧要的，因为核心 $0$ 并不执行该代码。关键的 `flushD()` 操作缺失，因此不保证核心 $0$ 写入的代码对核心 $1$ 可见。\n- 核心 $1$：自旋直到从 $Q$ 加载返回 $1$；跳转到 $P$。\n这是有缺陷的。它省略了 `invalidateI()` 和 `isync()`，未能解决核心 $1$ 上的过时 I-cache 问题。\n**结论：不正确**\n\n**选项 D：**\n- 核心 $0$：将 $F$ 写入 $[P,P+N)$；`flushD([P,P+N))`；向 $Q$ 存储就绪标志值 $1$。\n这是有缺陷的。它省略了数据刷新和标志存储之间的 `mb_full()`。在弱序架构上，这允许标志在已刷新的代码数据保证可见之前对核心 $1$ 可见，从而导致竞争条件。\n- 核心 $1$：自旋直到从 $Q$ 加载返回 $1$；`isync()`；跳转到 $P$。\n这是有缺陷的。它省略了 `invalidateI()`。`isync()` 原语是相对于先前的缓存维护操作来同步流水线；如果没有在它之前的 `invalidateI()`，它对 I-cache 内容没有相关影响。核心 $1$ 仍然有使用过时缓存指令的风险。\n**结论：不正确**\n\n基于严谨的分析，只有选项 A 提供了完整且正确排序的原语集，以保证在指定的体系结构约束下实现确定性和正确的执行。", "answer": "$$\\boxed{A}$$", "id": "3682322"}]}