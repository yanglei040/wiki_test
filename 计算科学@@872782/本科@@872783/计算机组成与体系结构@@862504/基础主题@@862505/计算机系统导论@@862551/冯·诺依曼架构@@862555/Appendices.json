{"hands_on_practices": [{"introduction": "冯·诺依曼架构将指令和数据存储在统一的内存中，这虽然带来了巨大的灵活性，但也引入了所谓的“冯·诺依曼瓶颈”。本练习将通过一个简化的性能模型，帮助你量化这一瓶颈。我们将为一个常见的计算任务（点积）推导其执行时间，以此揭示在一个内存访问与算术运算无法重叠的系统中，总时间是如何由内存带宽 $BW$ 和算术单元速率 $R$ 共同决定的 [@problem_id:3688062]。", "problem": "一个单核冯·诺依曼机拥有一个共享数据内存总线，并执行两个长度为 $n$ 的数组的流式点积运算。每个数组元素为 $b$ 字节。该微架构是顺序执行的，并施加了以下约束：\n\n- 数组的所有数据访问都通过单一的数据内存总线，在流式访问下，该总线可维持 $BW$ 字节/秒的峰值带宽。\n- 加载是阻塞式的，数据传输与算术运算不重叠。也就是说，当内存系统传输操作数时，算术逻辑单元（ALU）不能执行算术运算，反之亦然。\n- 算术核心在每次循环迭代中对标量操作数执行一次融合乘加（FMA）运算，并且每秒最多可以完成 $R$ 次融合乘加运算。\n- 与流式数据流量相比，指令获取成本和累加结果的最终标量存储成本可以忽略不计。\n\n仅从以下定义出发：(i) 带宽 $BW$ 的单位是字节/秒，(ii) 时间等于功除以速率，以及 (iii) 点积运算为每个元素执行一次融合乘加（FMA）并从内存中为每个元素读取两个操作数，推导在上述无重叠约束下，总执行时间 $T$ 作为 $n$、$b$、$BW$ 和 $R$ 的函数的封闭形式表达式。\n\n然后，使用 $n=5 \\times 10^{7}$，$b=8$ 字节，$BW=25 \\times 10^{9}$ 字节/秒，以及 $R=5 \\times 10^{9}$ 次融合乘加/秒对您的表达式进行求值。将您最终的 $T$ 的数值答案四舍五入到四位有效数字，并以秒为单位表示。", "solution": "首先将对问题进行严格的验证过程，以确保其科学和逻辑的完整性。\n\n### 步骤1：提取已知条件\n\n问题陈述中提供了以下数据和约束：\n- **系统架构**：具有一个共享数据内存总线的单核冯·诺依曼机。\n- **任务**：执行两个长度为 $n$ 的数组的流式点积运算。\n- **数据大小**：每个数组元素为 $b$ 字节。\n- **执行模型**：微架构是顺序执行的。\n- **内存访问**：数组的所有数据访问都通过单一的数据内存总线。\n- **内存带宽**：在流式访问下，总线的峰值带宽为 $BW$ 字节/秒。\n- **执行约束**：加载是阻塞式的，数据传输与算术运算不重叠。ALU和内存系统串行操作，而非并行。\n- **算术运算**：核心对标量操作数每次循环迭代执行一次融合乘加（FMA）运算。\n- **算术吞吐量**：核心每秒最多可以完成 $R$ 次融合乘加运算。\n- **简化**：指令获取成本和累加结果的最终标量存储成本可以忽略不计。\n- **基本原则**：(i) 带宽 $BW$ 的单位是字节/秒，(ii) 时间等于功除以速率，以及 (iii) 点积运算为每个元素执行一次FMA并从内存中为每个元素读取两个操作数。\n- **用于求值的数值**：$n = 5 \\times 10^7$，$b = 8$ 字节，$BW = 25 \\times 10^9$ 字节/秒，以及 $R = 5 \\times 10^9$ 次融合乘加/秒。\n- **最终答案要求**：将总时间 $T$ 的数值结果四舍五入到四位有效数字。\n\n### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准对问题陈述进行评估。\n\n- **科学基础**：该问题很好地基于计算机组织与架构的原理。它为执行内存密集型或计算密集型任务的处理器提供了一个简化但有效的性能模型。内存带宽（$BW$）、算术吞吐量（$R$）和冯·诺依曼瓶颈等概念是该领域的基础。“无重叠”约束是简单的顺序执行流水线模型的关键特征。\n- **适定性**：该问题是适定的。目标是推导总执行时间的表达式。“无重叠”规则等约束条件定义清晰，足以确定唯一解。问题是自包含的，不需要外部信息。\n- **客观性**：问题陈述使用了精确、客观和技术性的语言，没有歧义或主观论断。\n\n该问题没有缺陷。它在科学上不是不健全、不完整、矛盾或不适定的。该模型是用于性能分析的标准简化模型，所提供的数值对于现代硬件是现实的。\n\n### 步骤3：结论与行动\n\n问题陈述有效。将推导完整的解决方案。\n\n### 执行时间的推导\n\n总执行时间 $T$ 由内存操作所花费的时间和算术运算所花费的时间之和确定。关键约束“数据传输与算术运算不重叠”决定了这两个时间分量是相加的。\n$$T = T_{\\text{mem}} + T_{\\text{arith}}$$\n\n我们将根据时间等于总功除以完成工作的速率这一原则，分别推导每个分量。\n\n**1. 内存时间 ($T_{\\text{mem}}$)**\n\n- **功**：必须通过内存总线传输的总数据量。点积运算是对两个长度为 $n$ 的数组进行的。问题陈述指出，对于 $n$ 个元素中的每一个，从内存中读取两个操作数。每个操作数（数组元素）的大小为 $b$ 字节。\n传输的总数据 = (元素数量) $\\times$ (每个元素的操作数) $\\times$ (每个操作数的字节数)。\n$$W_{\\text{mem}} = n \\times 2 \\times b = 2nb \\text{ 字节}$$\n- **速率**：数据传输的速率是内存带宽，给定为 $BW$ 字节/秒。\n- **时间**：应用公式 时间 = 功 / 速率：\n$$T_{\\text{mem}} = \\frac{W_{\\text{mem}}}{BW} = \\frac{2nb}{BW}$$\n\n**2. 算术时间 ($T_{\\text{arith}}$)**\n\n- **功**：浮点运算的总次数。问题明确指出，核心在每次循环迭代中执行一次融合乘加（FMA）运算。对于长度为 $n$ 的点积，有 $n$ 次迭代。\n总算术运算次数 = (元素数量) $\\times$ (每个元素的FMA次数)。\n$$W_{\\text{arith}} = n \\times 1 = n \\text{ FMAs}$$\n- **速率**：算术运算的速率是核心的FMA吞吐量，给定为 $R$ 次融合乘加/秒。\n- **时间**：应用公式 时间 = 功 / 速率：\n$$T_{\\text{arith}} = \\frac{W_{\\text{arith}}}{R} = \\frac{n}{R}$$\n\n**3. 总执行时间 ($T$)**\n\n将内存时间和算术时间的表达式相结合，得到总执行时间 $T$ 的封闭形式表达式：\n$$T(n, b, BW, R) = T_{\\text{mem}} + T_{\\text{arith}} = \\frac{2nb}{BW} + \\frac{n}{R}$$\n这个表达式可以因式分解以分离出对 $n$ 的依赖：\n$$T(n, b, BW, R) = n \\left( \\frac{2b}{BW} + \\frac{1}{R} \\right)$$\n这就是所要求的总执行时间的封闭形式表达式。\n\n### 数值计算\n\n现在我们将给定的数值代入推导出的表达式中：\n- $n = 5 \\times 10^7$\n- $b = 8$ 字节\n- $BW = 25 \\times 10^9$ 字节/秒\n- $R = 5 \\times 10^9$ FMAs/秒\n\n$$T = (5 \\times 10^7) \\left( \\frac{2 \\times 8}{25 \\times 10^9} + \\frac{1}{5 \\times 10^9} \\right)$$\n为了简化括号内的表达式，我们找到两个分数的公分母，即 $25 \\times 10^9$。\n$$T = (5 \\times 10^7) \\left( \\frac{16}{25 \\times 10^9} + \\frac{5}{25 \\times 10^9} \\right)$$\n$$T = (5 \\times 10^7) \\left( \\frac{16 + 5}{25 \\times 10^9} \\right)$$\n$$T = (5 \\times 10^7) \\left( \\frac{21}{25 \\times 10^9} \\right)$$\n现在，我们进行乘法运算：\n$$T = \\frac{5 \\times 21 \\times 10^7}{25 \\times 10^9}$$\n$$T = \\frac{105 \\times 10^7}{25 \\times 10^9}$$\n将数值部分 ($105 / 25 = 4.2$) 和10的幂次 ($10^7 / 10^9 = 10^{-2}$) 相除：\n$$T = 4.2 \\times 10^{-2} \\text{ 秒}$$\n$$T = 0.042 \\text{ 秒}$$\n问题要求答案四舍五入到四位有效数字。\n$$T = 0.04200 \\text{ 秒}$$\n用标准科学记数法表示，这是 $4.200 \\times 10^{-2}$ 秒。\n让我们分析每个部分的贡献：\n$T_{\\text{mem}} = \\frac{2 \\times (5 \\times 10^7) \\times 8}{25 \\times 10^9} = \\frac{80 \\times 10^7}{25 \\times 10^9} = \\frac{8 \\times 10^8}{25 \\times 10^9} = 3.2 \\times 10^{-2} \\text{ s} = 0.032 \\text{ s}$。\n$T_{\\text{arith}} = \\frac{5 \\times 10^7}{5 \\times 10^9} = 1 \\times 10^{-2} \\text{ s} = 0.01 \\text{ s}$。\n总时间 $T = 0.032 \\text{ s} + 0.01 \\text{ s} = 0.042 \\text{ s}$。\n计算是一致的。在这种情况下，执行更多地受内存带宽限制，而不是算术吞吐量。最终值四舍五入到四位有效数字为 $0.04200$ 秒。", "answer": "$$\\boxed{4.200 \\times 10^{-2}}$$", "id": "3688062"}, {"introduction": "在真实的冯·诺依曼系统中，指令获取和数据读写请求会同时竞争唯一的共享总线。本练习将引入排队论这一强大的性能分析工具，来对此类资源竞争进行建模。你将分析并比较两种不同的总线仲裁策略（轮询与指令优先），从而理解不同的硬件设计决策如何影响不同类型内存请求的等待时间，并深化对系统性能权衡的认识 [@problem_id:3688053]。", "problem": "一台单核 von Neumann 计算机对指令提取和数据加载/存储使用一个共享内存和一个共享总线。在任何时刻，总线上只能有一个内存事务。假设以下具有科学依据的建模假设。\n\n- 核心产生两个独立的请求流：指令提取 (IF) 请求和数据加载/存储请求。IF 请求以速率 $\\lambda_{I}$ 的泊松过程到达，数据加载/存储请求以速率 $\\lambda_{D}$ 的泊松过程到达。这两个过程是独立的，因此它们的叠加是速率为 $\\lambda=\\lambda_{I}+\\lambda_{D}$ 的泊松过程。\n- 每个内存事务（IF或数据）占用总线的时间是固定的、确定性的时间 $c$（恒定服务时间）。一旦事务在总线上开始，就不会有抢占。\n- 系统是功保守且稳定的，即利用率 $\\rho=\\lambda c$ 满足 $\\rho<1$。\n\n在总线变为空闲的每个总线授权时刻，考虑两种仲裁策略：\n\n1.  跨两类（IF与数据）进行轮询，无开销，非抢占式，每次授权仅一个事务。\n2.  对IF采用严格的非抢占式优先级：每当IF和数据都在等待时，总线总是将下一次授权给IF；服务中的作业绝不会被抢占。\n\n给定参数 $\\lambda_{I}=5.0\\times 10^{6}\\,\\mathrm{s}^{-1}$、$\\lambda_{D}=3.0\\times 10^{6}\\,\\mathrm{s}^{-1}$ 和 $c=100\\,\\mathrm{ns}$，使用标准的排队论基础将共享总线建模为单服务台队列，并从第一性原理推导出在每种仲裁策略下，数据加载/存储请求所经历的稳态平均队列等待时间（不包括服务时间）。仅使用关于单服务台队列和优先级队列的科学既有结果作为基础。将您的两个数值答案以 $\\mathrm{ns}$ 表示，并各自四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它在排队论中有科学依据，所有必要参数都已定义，问题表述客观。该系统可以建模为一个单服务台队列，其中服务台是共享总线。\n\n首先，我们确定排队系统的基本参数。问题陈述IF请求以速率 $\\lambda_{I} = 5.0 \\times 10^{6} \\, \\mathrm{s}^{-1}$ 的泊松过程到达，数据加载/存储 (Data) 请求以速率 $\\lambda_{D} = 3.0 \\times 10^{6} \\, \\mathrm{s}^{-1}$ 的独立泊松过程到达。这两个独立泊松过程的叠加形成的总到达过程也是泊松过程，总速率 $\\lambda$ 由下式给出：\n$$ \\lambda = \\lambda_{I} + \\lambda_{D} = (5.0 \\times 10^{6} + 3.0 \\times 10^{6}) \\, \\mathrm{s}^{-1} = 8.0 \\times 10^{6} \\, \\mathrm{s}^{-1} $$\n任何事务的服务时间都是一个恒定值 $c = 100 \\, \\mathrm{ns} = 1.0 \\times 10^{-7} \\, \\mathrm{s}$。由于到达是泊松过程（马尔可夫），服务时间是确定性的，因此该系统是一个 M/D/1 队列。\n\n服务台（总线）的利用率是其繁忙时间的比例。我们可以计算每类请求贡献的利用率以及总利用率 $\\rho$。\n由IF请求引起的利用率是 $\\rho_{I}$：\n$$ \\rho_{I} = \\lambda_{I} c = (5.0 \\times 10^{6} \\, \\mathrm{s}^{-1}) \\times (1.0 \\times 10^{-7} \\, \\mathrm{s}) = 0.5 $$\n由数据请求引起的利用率是 $\\rho_{D}$：\n$$ \\rho_{D} = \\lambda_{D} c = (3.0 \\times 10^{6} \\, \\mathrm{s}^{-1}) \\times (1.0 \\times 10^{-7} \\, \\mathrm{s}) = 0.3 $$\n总线总利用率 $\\rho$ 是这些利用率的总和：\n$$ \\rho = \\rho_{I} + \\rho_{D} = 0.5 + 0.3 = 0.8 $$\n由于 $\\rho = 0.8 < 1$，系统是稳定的，进行稳态分析是有意义的。\n\n现在，我们推导在两种仲裁策略下数据请求的平均等待时间。\n\n**策略1：跨类别轮询**\n\n该策略被描述为功保守、非抢占式，并且每次授权一个事务。对于一个具有多个作业类别且所有类别的服务时间分布相同的系统（如此处情况，服务时间为恒定时间 $c$），任何不使用服务时间进行决策的功保守、非抢占式调度策略（如FCFS或轮询）都会导致任意作业在队列中的平均等待时间相同。因此，我们可以通过计算聚合的 M/D/1 队列的总体平均等待时间来找到数据请求的平均等待时间。\n\n对于一个通用的 M/G/1 队列，队列中的平均等待时间 $W_q$ 由 Pollaczek-Khinchine 公式给出：\n$$ W_q = \\frac{\\lambda \\mathbb{E}[S^2]}{2(1-\\rho)} $$\n其中 $S$ 是服务时间随机变量，$\\mathbb{E}[S^2]$ 是其二阶矩。对于我们的 M/D/1 队列，服务时间是常数 $c$，所以 $\\mathbb{E}[S] = c$ 且 $\\mathbb{E}[S^2] = c^2$。公式变为：\n$$ W_{q,D}^{(\\text{RR})} = \\frac{\\lambda c^2}{2(1-\\rho)} $$\n我们可以代入 $\\rho = \\lambda c$ 来得到一个更简单的计算形式：\n$$ W_{q,D}^{(\\text{RR})} = \\frac{(\\lambda c)c}{2(1-\\rho)} = \\frac{\\rho c}{2(1-\\rho)} $$\n代入数值：\n$$ W_{q,D}^{(\\text{RR})} = \\frac{0.8 \\times (100 \\, \\mathrm{ns})}{2(1-0.8)} = \\frac{80 \\, \\mathrm{ns}}{2(0.2)} = \\frac{80 \\, \\mathrm{ns}}{0.4} = 200 \\, \\mathrm{ns} $$\n四舍五入到四位有效数字，平均等待时间是 $200.0 \\, \\mathrm{ns}$。\n\n**策略2：对IF采用严格的非抢占式优先级**\n\n在此策略下，IF请求具有比数据请求（第2类）更高的优先级（第1类）。这是一个非抢占式优先级 M/D/1 队列。优先级为 $k$ 的请求的平均等待时间，记为 $W_{q,k}$，由 Cobham-Priou 公式给出：\n$$ W_{q,k} = \\frac{W_0}{(1 - \\sigma_{k-1})(1 - \\sigma_k)} $$\n其中：\n- $W_0$ 是一个到达请求发现服务台中的事务所具有的平均剩余服务时间。对于 M/G/1 系统，$W_0 = \\frac{\\lambda \\mathbb{E}[S^2]}{2}$。在我们的案例中，$W_0 = \\frac{\\lambda c^2}{2}$。\n- $\\sigma_k = \\sum_{j=1}^{k} \\rho_j$ 是从第1类到第 $k$ 类的累积利用率。按照惯例，$\\sigma_0 = 0$。\n\n我们需要找到数据请求的平均等待时间，即第2类。所以我们设 $k=2$。\n累积利用率是：\n$$ \\sigma_1 = \\rho_1 = \\rho_{I} = 0.5 $$\n$$ \\sigma_2 = \\rho_1 + \\rho_2 = \\rho_{I} + \\rho_{D} = \\rho = 0.8 $$\n首先，我们计算 $W_0$：\n$$ W_0 = \\frac{\\lambda c^2}{2} = \\frac{(8.0 \\times 10^6 \\, \\mathrm{s}^{-1}) (1.0 \\times 10^{-7} \\, \\mathrm{s})^2}{2} = \\frac{8.0 \\times 10^{-8} \\, \\mathrm{s}}{2} = 4.0 \\times 10^{-8} \\, \\mathrm{s} = 40 \\, \\mathrm{ns} $$\n现在我们可以计算 $W_{q,2}$，即严格优先级策略下数据请求的平均等待时间 $W_{q,D}^{(\\text{SP})}$：\n$$ W_{q,D}^{(\\text{SP})} = W_{q,2} = \\frac{W_0}{(1 - \\sigma_1)(1 - \\sigma_2)} = \\frac{40 \\, \\mathrm{ns}}{(1 - \\rho_I)(1 - \\rho)} $$\n代入利用率值：\n$$ W_{q,D}^{(\\text{SP})} = \\frac{40 \\, \\mathrm{ns}}{(1 - 0.5)(1 - 0.8)} = \\frac{40 \\, \\mathrm{ns}}{(0.5)(0.2)} = \\frac{40 \\, \\mathrm{ns}}{0.1} = 400 \\, \\mathrm{ns} $$\n四舍五入到四位有效数字，平均等待时间是 $400.0 \\, \\mathrm{ns}$。\n\n在轮询和严格优先级策略下，数据请求的平均等待时间分别为 $200.0 \\, \\mathrm{ns}$ 和 $400.0 \\, \\mathrm{ns}$。", "answer": "$$ \\boxed{ \\begin{pmatrix} 200.0 & 400.0 \\end{pmatrix} } $$", "id": "3688053"}, {"introduction": "从理论模型转向实际测量，我们如何确定一个程序是受限于指令获取还是数据访问？本练习将带你扮演性能分析工程师的角色，在一个更接近现代处理器的缓存系统中，设计硬件性能计数器来精确追踪内存流量。通过区分与指令和数据相关的内存访问，你将学会计算一个关键指标——瓶颈比率 $R$ ——从而量化地诊断系统性能瓶颈的来源 [@problem_id:3688132]。", "problem": "一个实现冯·诺依曼架构的中央处理器（CPU）对指令和数据使用统一的主存储器。往返主存储器的内存流量是最终的吞吐量瓶颈，因为同一个物理接口必须同时服务于指令提取和数据访问。为了实时监控此共享接口所承受的压力，您需要设计两个字节精确的硬件性能计数器：一个用于指令提取（IF）流量，另一个用于数据内存（MEM）流量，然后使用它们来计算一个测量窗口内的瓶颈比率。\n\n假设采用以下广泛使用的一级缓存组织和策略：一个一级指令缓存和一个一级数据缓存，它们的行大小相同，均为 $L$ 字节，数据行采用写回策略，并在存储未命中时采用写分配策略。在这一级，主内存流量的唯一来源是：\n- 指令缓存未命中时的指令缓存行填充，\n- 加载未命中时的数据缓存行填充，\n- 存储写分配时的数据缓存行填充，以及\n- 驱逐时脏数据缓存行的写回。\n\n每次行填充或写回都会在内存接口上传输恰好 $L$ 字节。在某个测量窗口内，性能监控单元报告了以下事件计数：\n- 指令缓存行填充次数 $N_{I} = 750$，\n- 因加载未命中导致的数据缓存行填充次数 $N_{DL} = 500$，\n- 因存储写分配导致的数据缓存行填充次数 $N_{DS} = 300$，\n- 脏数据缓存行写回次数 $N_{WB} = 420$，\n并且缓存行大小为 $L = 64$ 字节。\n\n仅从上述架构定义和关于在统一内存接口上引起流量的事件的事实出发，指定计数器更新规则，以累加窗口期间的总IF字节数 $B_{IF}$ 和总MEM字节数 $B_{MEM}$。然后，使用 $R$（定义为同一窗口内指令提取字节数与数据内存字节数的比率），推导一个用 $N_{I}$、$N_{DL}$、$N_{DS}$、$N_{WB}$ 和 $L$ 表示 $R$ 的表达式，并根据所提供的值对其进行数值计算。将您最终的 $R$ 数值答案四舍五入到四位有效数字，并将其报告为一个无单位的纯数。", "solution": "该问题是有效的。这是一个在计算机体系结构性能分析领域中定义明确的问题，基于标准的定义和原则。所有必要的信息都已提供，问题没有矛盾或模糊之处。\n\n目标是指定用于测量指令提取流量和数据内存流量的硬件计数器更新规则，然后计算这两种流量的比率。该分析基于一组特定的事件，这些事件在冯·诺依曼架构机器的统一内存接口上引起流量。\n\n设 $B_{IF}$ 为由指令提取引起的内存总流量（字节），设 $B_{MEM}$ 为由数据访问（加载和存储）引起的内存总流量（字节）。问题完整列举了在一级缓存中导致主内存流量的事件。每个此类事件都涉及传输一个大小为 $L$ 字节的缓存行。\n\n首先，我们必须将给定的事件分类，确定它们是贡献于 $B_{IF}$ 还是 $B_{MEM}$。\n\n指令提取（IF）流量：\n与指令流相关的唯一流量来源是在指令缓存未命中时从主内存填充指令缓存行。\n问题指出，此类事件有 $N_{I}$ 次。由于每次事件传输 $L$ 字节，总的指令提取流量为：\n$$B_{IF} = N_{I} \\times L$$\n\n数据内存（MEM）流量：\n与数据流相关的流量是由在数据缓存中未命中的加载和存储引起的。问题指出了三种对数据内存流量有贡献的不同事件：\n1.  加载未命中时的数据缓存行填充：加载指令在数据缓存中未命中，需要从主内存中提取一个行。这类事件的数量是 $N_{DL}$。这会产生 $N_{DL} \\times L$ 字节的内存流量。这是一次内存读取。\n2.  存储写分配时的数据缓存行填充：存储指令在数据缓存中未命中。“写分配”策略规定，在写入操作继续之前，必须将相应的内存行提取到缓存中。这类事件的数量是 $N_{DS}$。这会产生 $N_{DS} \\times L$ 字节的内存流量。这也是一次内存读取。\n3.  脏数据缓存行的写回：数据缓存中一个被修改过（脏）的行被驱逐，以便为新的行腾出空间。“写回”策略要求将这个脏行的内容写回主内存。这类事件的数量是 $N_{WB}$。这会产生 $N_{WB} \\times L$ 字节的内存流量。这是一次内存写入。\n\n总的数据内存流量 $B_{MEM}$ 是这三种事件类型传输的总字节数之和：\n$$B_{MEM} = (N_{DL} \\times L) + (N_{DS} \\times L) + (N_{WB} \\times L)$$\n通过提取公因子 $L$，我们得到：\n$$B_{MEM} = (N_{DL} + N_{DS} + N_{WB}) \\times L$$\n\n基于此分析，我们可以指定计数器更新规则。\n\n计数器更新规则：\n-   **$B_{IF}$ 计数器**：用于总指令提取字节数的硬件性能计数器 $B_{IF}$，在每次检测到指令缓存行填充事件时，应增加 $L$。在测量窗口内，其最终值为 $B_{IF} = N_{I} \\times L$。\n-   **$B_{MEM}$ 计数器**：用于总数据内存字节数的硬件性能计数器 $B_{MEM}$，在每次检测到以下任一事件时，应增加 $L$：因加载未命中导致的数据缓存行填充、因存储写分配导致的数据缓存行填充、或脏数据缓存行的写回。在测量窗口内，其最终值为 $B_{MEM} = (N_{DL} + N_{DS} + N_{WB}) \\times L$。\n\n瓶颈比率 $R$ 的推导：\n问题将比率 $R$ 定义为指令提取字节数与数据内存字节数的比率。\n$$R = \\frac{B_{IF}}{B_{MEM}}$$\n将上面推导出的 $B_{IF}$ 和 $B_{MEM}$ 的表达式代入：\n$$R = \\frac{N_{I} \\times L}{(N_{DL} + N_{DS} + N_{WB}) \\times L}$$\n缓存行大小 $L$ 作为分子和分母的公因子出现，因此可以消去。这就得出了用事件计数表示 $R$ 的最终表达式：\n$$R = \\frac{N_{I}}{N_{DL} + N_{DS} + N_{WB}}$$\n值得注意的是，流量体积的比率等于内存事务数量的比率，因为每次事务都传输相同数量的数据，即 $L$ 字节。\n\n数值计算：\n我们被给予以下事件计数：\n-   $N_{I} = 750$\n-   $N_{DL} = 500$\n-   $N_{DS} = 300$\n-   $N_{WB} = 420$\n\n$L = 64$ 字节的值对于计算比率 $R$ 不是必需的。\n将数值代入 $R$ 的表达式中：\n$$R = \\frac{750}{500 + 300 + 420}$$\n$$R = \\frac{750}{1220}$$\n$$R = \\frac{75}{122}$$\n现在，我们计算其小数值并四舍五入到四位有效数字。\n$$R \\approx 0.614754098...$$\n前四位有效数字是 $6$、$1$、$4$ 和 $7$。第五位有效数字是 $5$，这要求将第四位有效数字向上取整。\n$$R \\approx 0.6148$$\n该值表示在测量窗口内，由指令提取产生的内存流量与由数据访问产生的内存流量之比。", "answer": "$$\\boxed{0.6148}$$", "id": "3688132"}]}