{"hands_on_practices": [{"introduction": "流水线是提高处理器吞吐量的核心技术，它通过将复杂的组合逻辑路径分割成多个更小的、时钟同步的阶段来实现。本练习将带你亲手重构一个纯组合逻辑的加法器链，通过插入流水线寄存器将其改造为多级流水线结构。通过这个过程，你将学习如何根据基本时序参数（如寄存器延迟和逻辑延迟）计算流水线所能达到的最大时钟频率，并量化其对吞吐量和延迟的影响。", "problem": "一个同步累加器单元中的数据路径通过级联三个使用互补金属氧化物半导体（CMOS）逻辑实现的$64$位加法器模块，对四个$64$位操作数求和。在其原始形式中，该设计在输入寄存器和输出寄存器之间是纯组合逻辑：三个加法器通过两个加法器间的互连段串联，加法器之间没有寄存器。您的任务是通过插入中间寄存器，将这个长组合路径重构为一个时序流水线，使得每个加法器都位于其自己的流水线级中。该设备使用具有指定时序特性的上升沿触发D触发器（DFF）。\n\n假设在目标工艺和电压下，测得以下最坏情况延迟和寄存器参数：\n- 每个$64$位加法器的最坏情况传播延迟为$1.80 \\, \\text{ns}$。\n- 每个加法器间的互连段会产生$0.20 \\, \\text{ns}$的额外最坏情况传播延迟。\n- 每个DFF的时钟到Q端延迟为$0.08 \\, \\text{ns}$，建立时间为$0.12 \\, \\text{ns}$。\n- 从发射寄存器到捕获寄存器的路径上，最坏情况时钟偏斜为$0.05 \\, \\text{ns}$。\n- 保持时间约束已通过现有缓冲满足，可以忽略。\n\n您在三个加法器模块之间插入两个中间寄存器，以便重构后的流水线有三个级，每个级包含一个加法器及其紧随的互连。假设重构后每级的互连延迟仍为$0.20 \\, \\text{ns}$，并且寄存器参数和时钟偏斜适用于每一级。\n\n从第一性原理出发，使用组合逻辑与时序逻辑的定义以及同步流水线的时序约束，确定重构后流水线的潜伏期和吞吐量。报告：\n- 流水线潜伏期，以周期数表示（一个整数周期数）。\n- 稳态下的最大吞吐量，以每秒操作数表示，并使用科学记数法。\n\n将吞吐量四舍五入到四位有效数字。吞吐量以每秒操作数表示。此问题不涉及角度单位。", "solution": "该问题要求计算同步数字流水线的潜伏期和吞吐量。分析始于对这两个性能指标以及同步电路基本时序约束的精确定义。\n\n同步流水线是由多个级组成的串行电路，各级之间由寄存器（本例中为D触发器或DFF）分隔。状态转换由全局时钟信号同步。\n\n**1. 流水线潜伏期**\n\n潜伏期是单个操作从输入到输出传播通过整个流水线所需的总时间。在一个有$N$级的流水线中，一个操作需要一个时钟周期来被每个级处理并由后续寄存器锁存其结果。因此，操作的最终结果在$N$个完整的时钟周期后，在最后一级的输出端可用。\n\n问题陈述，通过插入中间寄存器将原有的三个加法器的组合路径重构为时序流水线，以使“每个加法器都位于其自己的流水线级中”。这创建了一个三级流水线。\n\n设$N$为流水线级数。\n$$N = 3$$\n因此，以时钟周期数衡量的潜伏期$L$等于级数。\n$$L = N = 3 \\, \\text{个周期}$$\n\n**2. 流水线吞吐量**\n\n吞吐量是流水线在稳态下完成操作的速率。一旦流水线满载（即每个级都在处理不同的操作），在每个时钟的上升沿，输出端都会产生一个新结果。因此，吞吐量$\\Theta$是最小可能时钟周期$T_{\\text{min}}$的倒数。\n\n$$\\Theta = \\frac{1}{T_{\\text{min}}}$$\n\n最小时钟周期由流水线中最慢（最长延迟）级的时序约束决定。对于发射寄存器和捕获寄存器之间的同步路径，时钟周期$T_{\\text{clk}}$必须足够长，以允许数据从发射寄存器的输出端传播，通过组合逻辑，并在下一个时钟沿到达之前，在捕获寄存器的输入端稳定至少一个建立时间。这种关系，称为建立时间约束，由以下不等式给出：\n\n$$T_{\\text{clk}} \\ge t_{\\text{clk-q}} + t_{\\text{comb}} + t_{\\text{setup}} + t_{\\text{skew}}$$\n\n其中：\n- $t_{\\text{clk-q}}$是发射寄存器的时钟到Q端延迟。\n- $t_{\\text{comb}}$是单个流水线级内组合逻辑的最坏情况传播延迟。\n- $t_{\\text{setup}}$是捕获寄存器的建立时间要求。\n- $t_{\\text{skew}}$是发射寄存器和捕获寄存器之间的最坏情况时钟偏斜。\n\n为了找到最大吞吐量，我们必须计算最小时钟周期$T_{\\text{min}}$，它是满足该不等式的$T_{\\text{clk}}$的最小值。\n\n$$T_{\\text{min}} = t_{\\text{clk-q}} + t_{\\text{comb}} + t_{\\text{setup}} + t_{\\text{skew}}$$\n\n首先，我们确定每级的组合延迟$t_{\\text{comb}}$。问题陈述，重构后的流水线各级“每个级包含一个加法器及其紧随的互连”，并且“每级的互连延迟仍为$0.20 \\, \\text{ns}$”。这为每个级建立了统一的组合延迟，即加法器延迟和互连延迟之和。\n\n给定的值为：\n- 加法器传播延迟, $t_{\\text{adder}} = 1.80 \\, \\text{ns}$。\n- 互连传播延迟, $t_{\\text{interconnect}} = 0.20 \\, \\text{ns}$。\n\n因此，每级的组合延迟为：\n$$t_{\\text{comb}} = t_{\\text{adder}} + t_{\\text{interconnect}} = 1.80 \\, \\text{ns} + 0.20 \\, \\text{ns} = 2.00 \\, \\text{ns}$$\n\n接下来，我们将所有给定的时序参数代入$T_{\\text{min}}$的方程中：\n- DFF时钟到Q端延迟, $t_{\\text{clk-q}} = 0.08 \\, \\text{ns}$。\n- DFF建立时间, $t_{\\text{setup}} = 0.12 \\, \\text{ns}$。\n- 最坏情况时钟偏斜, $t_{\\text{skew}} = 0.05 \\, \\text{ns}$。\n\n$$T_{\\text{min}} = 0.08 \\, \\text{ns} + 2.00 \\, \\text{ns} + 0.12 \\, \\text{ns} + 0.05 \\, \\text{ns}$$\n$$T_{\\text{min}} = 2.25 \\, \\text{ns}$$\n\n这是流水线能够可靠运行的最小-态时钟周期。最大吞吐量是该周期的倒数。\n\n$$\\Theta = \\frac{1}{T_{\\text{min}}} = \\frac{1}{2.25 \\, \\text{ns}} = \\frac{1}{2.25 \\times 10^{-9} \\, \\text{s}}$$\n$$\\Theta = \\frac{4}{9} \\times 10^9 \\, \\frac{\\text{操作}}{\\text{s}} \\approx 0.44444... \\times 10^9 \\, \\frac{\\text{操作}}{\\text{s}}$$\n按要求以科学记数法表示并四舍五入到四位有效数字：\n$$\\Theta \\approx 4.444 \\times 10^8 \\, \\frac{\\text{操作}}{\\text{s}}$$\n\n两个要求的量是潜伏期（以周期数计）和最大吞吐量（以每秒操作数计）。\n- 潜伏期：$3$个周期。\n- 吞吐量：$4.444 \\times 10^8$ 操作/秒。", "answer": "$$\\boxed{\\begin{pmatrix} 3  4.444 \\times 10^{8} \\end{pmatrix}}$$", "id": "3628087"}, {"introduction": "CPU 设计充满了权衡，一个典型的例子就是在流水线深度和时钟频率之间做出选择。更深的流水线可以实现更高的时钟频率，从而可能获得更高的峰值吞吐量，但同时也增加了单条指令的延迟和分支预测失败时的惩罚。本练习 [@problem_id:3673527] 模拟了一个真实的微架构设计决策，要求你基于给定的工作负载特性（分支预测错误率 $p$），从理论上分析何时一个高频、深流水线的设计在批处理吞吐量上胜出，但在单次请求响应时间上却表现更差。", "problem": "一个微架构团队正在比较两种顺序执行中央处理器（CPU）设计，这两种设计用于一个对延迟敏感的服务，该服务偶尔会以批处理模式运行。设计A使用一个 $20$ 级流水线，时钟频率为 $f_1 = 3.3 \\text{ GHz}$，分支预测错误的惩罚为 $P_1 = 20$ 个时钟周期。设计B使用一个 $12$ 级流水线，时钟频率为 $f_2 = 3.0 \\text{ GHz}$，分支预测错误的惩罚为 $P_2 = 10$ 个时钟周期。对于两种设计，假设每条指令的基础周期为1（没有缓存未命中或其他停顿）、完美的数据前推，并且一次分支预测错误会给设计 $i \\in \\{1,2\\}$ 带来额外的 $P_i$ 个周期的停顿。\n\n考虑一个工作负载，其中单个请求包含 $L = 100$ 条顺序指令，其中恰好包含一个条件分支，每个请求执行一次。分支预测器以概率 $p \\in [0,1]$ 错误预测此分支，且每个请求的预测是独立的。一个大批量任务由 $T \\gg 1$ 个背靠背执行的独立请求组成；在批量处理的规模下，请求之间的流水线填充和排空可以忽略不计。\n\n仅使用以下基本定义：\n- 吞吐量是单位时间内完成的请求数，等于CPU频率除以大批量任务在稳态下每个请求的期望周期数。\n- 单请求响应时间是完成一个独立请求的时间，等于该请求的期望周期数除以CPU频率。对于一个在 $D_i$ 级流水线上处理的独立请求，需要包括 $D_i - 1$ 个周期的流水线填充成本。\n\n令 $D_1 = 20$ 和 $D_2 = 12$ 分别表示设计A和设计B的流水线深度。从第一性原理出发，推导设计A的批处理吞吐量严格高于设计B，同时其单请求响应时间也严格大于设计B的条件，这些条件应是关于 $p$ 的函数。然后，确定使得这两个条件同时成立的最小预测错误概率 $p^{\\star} \\in [0,1]$。将 $p^{\\star}$ 的最终答案表示为最简精确分数。最终答案中不要包含单位。", "solution": "该问题陈述已经过严格验证，并被认为是有效的。它在科学上基于计算机体系结构的原理，问题设定良好，提供了所有必要的参数和定义，并且措辞客观。数据是一致的，该任务可以形式化为一组可解的数学不等式。因此，我们可以着手求解。\n\n问题要求找到最小的分支预测错误概率 $p^{\\star}$，使得设计A的批处理吞吐量严格高于设计B，同时其单请求响应时间也严格大于设计B。我们将为每个设计推导这两个性能指标的表达式，建立两个不等式，并求解概率 $p$。\n\n令下标 $i \\in \\{1, 2\\}$ 分别代表设计A和设计B。给定的参数是：\n- 流水线深度：$D_1 = 20$, $D_2 = 12$\n- 时钟频率：$f_1 = 3.3 \\text{ GHz}$, $f_2 = 3.0 \\text{ GHz}$\n- 分支预测错误惩罚：$P_1 = 20$ 个周期, $P_2 = 10$ 个周期\n- 每个请求的指令数：$L = 100$\n\n首先，我们确定执行单个请求中指令所需的期望周期数。一个请求包含 $L$ 条指令，在基础CPI为1的情况下需要 $L$ 个周期。每个请求有一个分支，其被错误预测的概率为 $p$。一次预测错误会增加 $P_i$ 个停顿周期。因此，设计 $i$ 用于指令执行的期望周期数为：\n$$ C_{exec, i} = L + p \\cdot P_i + (1 - p) \\cdot 0 = L + p P_i $$\n\n接下来，我们根据所提供的定义对两个所需的性能指标进行建模。\n\n**1. 批处理吞吐量**\n吞吐量 ($Th_i$) 定义为CPU频率除以大批量任务中每个请求的期望周期数。问题指出，对于大批量任务，流水线填充和排空的影响可以忽略不计。因此，每个请求的周期数就是执行周期数 $C_{exec, i}$。\n$$ Th_i = \\frac{f_i}{C_{exec, i}} = \\frac{f_i}{L + p P_i} $$\n第一个条件是设计A的吞吐量严格高于设计B：\n$$ Th_1  Th_2 \\implies \\frac{f_1}{L + p P_1}  \\frac{f_2}{L + p P_2} $$\n由于 $L$, $P_i$ 和 $f_i$ 均为正数，且 $p \\ge 0$，分母总是正的。我们可以进行交叉相乘而不改变不等号的方向：\n$$ f_1 (L + p P_2)  f_2 (L + p P_1) $$\n$$ f_1 L + p f_1 P_2  f_2 L + p f_2 P_1 $$\n$$ p (f_1 P_2 - f_2 P_1)  L (f_2 - f_1) $$\n让我们代入给定值：$f_1 = 3.3$, $f_2 = 3.0$, $P_1 = 20$, $P_2 = 10$ 和 $L = 100$。\n$p$ 的系数是 $f_1 P_2 - f_2 P_1 = (3.3)(10) - (3.0)(20) = 33 - 60 = -27$。\n不等式右边是 $L(f_2 - f_1) = 100(3.0 - 3.3) = 100(-0.3) = -30$。\n不等式变为：\n$$ -27p  -30 $$\n两边同除以 $-27$ 并反转不等号，得到：\n$$ p  \\frac{-30}{-27} \\implies p  \\frac{10}{9} $$\n由于预测错误概率 $p$ 定义在区间 $[0, 1]$ 内，条件 $p  \\frac{10}{9}$ 总是成立的。因此，对于所有有效的 $p$ 值，设计A的吞吐量都高于设计B。\n\n**2. 单请求响应时间**\n单请求响应时间 ($RT_i$) 是完成一个独立请求的时间。这包括 $D_i - 1$ 个周期的流水线填充成本。单个请求的总期望周期数 $C_{single, i}$ 为：\n$$ C_{single, i} = C_{exec, i} + (D_i - 1) = L + p P_i + D_i - 1 $$\n设计 $i$ 的响应时间则为：\n$$ RT_i = \\frac{C_{single, i}}{f_i} = \\frac{L + p P_i + D_i - 1}{f_i} $$\n第二个条件是设计A的响应时间严格大于设计B：\n$$ RT_1  RT_2 \\implies \\frac{L + p P_1 + D_1 - 1}{f_1}  \\frac{L + p P_2 + D_2 - 1}{f_2} $$\n由于频率是正数，我们可以进行交叉相乘：\n$$ f_2 (L + p P_1 + D_1 - 1)  f_1 (L + p P_2 + D_2 - 1) $$\n展开并按 $p$ 合并项：\n$$ p f_2 P_1 - p f_1 P_2  L(f_1 - f_2) + f_1(D_2 - 1) - f_2(D_1 - 1) $$\n$$ p (f_2 P_1 - f_1 P_2)  L(f_1 - f_2) + f_1(D_2 - 1) - f_2(D_1 - 1) $$\n让我们代入给定值：$D_1 = 20, D_2 = 12$。\n$p$ 的系数是 $f_2 P_1 - f_1 P_2 = (3.0)(20) - (3.3)(10) = 60 - 33 = 27$。\n右手边（RHS）是：\n$$ \\text{RHS} = 100(3.3 - 3.0) + 3.3(12 - 1) - 3.0(20 - 1) $$\n$$ \\text{RHS} = 100(0.3) + 3.3(11) - 3.0(19) $$\n$$ \\text{RHS} = 30 + 36.3 - 57 $$\n$$ \\text{RHS} = 66.3 - 57 = 9.3 $$\n不等式变为：\n$$ 27p  9.3 $$\n由于 $p$ 的系数是正数，除法后不等号方向保持不变：\n$$ p  \\frac{9.3}{27} $$\n为了将其表示为精确分数，我们将 $9.3$ 写成 $\\frac{93}{10}$：\n$$ p  \\frac{93/10}{27} = \\frac{93}{270} $$\n分子和分母都可以被 $3$ 整除：\n$$ p  \\frac{31}{90} $$\n数字 $31$ 是素数，所以这个分数是最简形式。\n\n**寻找 $p^{\\star}$**\n我们需要找到最小的概率 $p^{\\star} \\in [0, 1]$，使得两个条件同时成立。\n条件1：$p  \\frac{10}{9}$\n条件2：$p  \\frac{31}{90}$\n这些条件与定义域 $p \\in [0, 1]$ 的交集定义了 $p$ 的解集：\n$$ p \\in \\left(\\frac{31}{90}, 1\\right] $$\n问题要求找到使两个条件都成立的最小概率 $p^{\\star}$。由于不等式是严格的，解集中没有 $p$ 的最小值。因此，问题可以解释为要求该集合的下确界（最大下界）。这个边界值是第二个条件从假变为真的转换点。\n这个值就是区间的下界。\n$$ p^{\\star} = \\frac{31}{90} $$\n对于任何严格大于 $p^{\\star}$（且小于等于 $1$）的 $p$ 值，两个条件都将满足。", "answer": "$$\\boxed{\\frac{31}{90}}$$", "id": "3673527"}, {"introduction": "现代高性能处理器之所以能够实现高吞吐量，关键在于其能够并行处理多项任务，从而“隐藏”单个操作（尤其是访存）的漫长延迟。这个练习 [@problem_id:3673535] 通过一个巧妙的思想实验，对比了数据相关的“指针追逐”和数据独立的并发加载两种场景。它旨在揭示数据独立性对于实现内存级别并行（Memory Level Parallelism, MLP）的决定性作用，并深刻地区分了单个操作的响应时间（latency）与整个系统的吞吐量（throughput）这两个核心性能指标。", "problem": "一个单路超标量乱序执行核心被用于研究数据依赖如何影响内存加载的响应时间和吞吐量。以下机器特性是相关的，并可假定在实验期间保持不变：\n- 核心可以跟踪多达 $M=16$ 个从末级缓存到动态随机存取存储器（DRAM）的在途未命中，而不会阻塞前端。\n- 加载发射宽度为每个周期 $W_{\\mathrm{ld}}=2$ 次加载。\n- 每次DRAM访问的服务时间（延迟）约为 $D=200$ 个周期，从高速缓存未命中被发送到内存控制器开始，直到数据返回核心为止。\n- 时钟频率为 $f=3\\,\\mathrm{GHz}$。内存系统带宽足够高，在下面预测的并发水平下，它不是瓶颈。\n- 每次加载传输 $8\\,\\mathrm{B}$。\n\n设计了两个微基准测试来量化响应时间，并演示吞吐量何时以及为何能从增加内存级并行度（MLP）中受益。MLP定义为在时间上重叠的独立内存操作的数量。\n\n- 依赖型基准测试（指针追逐）：在一个远大于末级缓存的数据区域上构建一个随机排列的单向链表。循环从当前节点重复加载下一个指针，并将指针推进 $N$ 步，其中 $N$ 是一个大数。因为每个地址只有在前一个加载完成后才能获得，所以存在一个单一的依赖链。\n- 独立型基准测试（许多独立加载）：准备 $K$ 个基地址，指向 $K$ 个独立的数组，这些数组的元素间隔开，以确保访问在末级缓存中未命中，并映射到不同的存储体。在每次循环迭代中，对彼此独立的元素发射 $K$ 次加载，并推迟使用它们的值，直到所有 $K$ 次加载都已发射。选择 $K$ 的值，以试图在不超出硬件限制的情况下最大化MLP。\n\n使用基本定义，即响应时间是每个操作的耗时，吞吐量是单位时间内完成的操作数。假设两个基准测试中的所有访问都在私有缓存中未命中，并由具有上述延迟 $D$ 的DRAM提供服务，并且重排序缓冲不是其他方面的限制因素。\n\n关于预期的测量结果及其解读，以下哪些陈述是正确的？\n\nA. 在依赖型基准测试中，对于较大的 $N$，除了很小的循环开销外，平均每次加载的周期数近似趋向于 $D$。\n\nB. 在独立型基准测试中，当 $K \\ge M$ 时，稳态加载吞吐量近似趋向于每周期 $M/D$ 次加载，因此以总周期数除以总加载数测得的平均每次加载周期数近似趋向于 $D/M$。\n\nC. 将 $K$ 增加到超过 $M$ 会进一步按比例减少测得的每次加载周期数，因为更多独立的加载会无限制地增加MLP。\n\nD. 如果修改依赖型基准测试，插入软件预取指令，尝试预取前方 $P=8$ 个节点，那么在完美预取的情况下，即使指针链在概念上是依赖的，测得的每次加载周期数也应接近 $D/M$。\n\nE. 如果 $K=8", "solution": "用户提供了一个来自计算机体系结构领域的问题，重点关注内存系统性能。我将首先验证问题陈述，然后对每个选项进行详细分析。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n-   核心类型：单路超标量乱序。\n-   最大在途末级缓存（LLC）未命中数：$M=16$。\n-   加载发射宽度：$W_{\\mathrm{ld}}=2$ 次加载/周期。\n-   DRAM访问服务时间（延迟）：$D=200$ 个周期。\n-   时钟频率：$f=3\\,\\mathrm{GHz}$。\n-   内存系统带宽：不是瓶颈。\n-   加载传输大小：$8\\,\\mathrm{B}$。\n-   依赖型基准测试：对一个单向链表进行指针追逐，共 $N$ 步，$N$ 是一个大数。\n-   独立型基准测试：在一个循环中发射 $K$ 个独立加载，选择 $K$ 以最大化内存级并行度（MLP）。\n-   定义：响应时间是每个操作的耗时。吞吐量是单位时间内完成的操作数。\n-   假设：所有访问都在缓存中未命中，并由DRAM服务。重排序缓冲除了跟踪 $M$ 个未命中这一隐含限制外，不是限制因素。\n\n**步骤2：使用提取的已知条件进行验证**\n\n-   **科学依据充分**：该问题在计算机体系结构基本原理方面有充分的依据，包括乱序执行、内存延迟、内存级并行度（MLP）以及数据依赖对性能的影响。参数（$M=16$，$D=200$ 周期，$W_{\\mathrm{ld}}=2$）对于现代处理器是现实的。\n-   **问题定义明确**：问题定义清晰。它指定了必要的硬件参数并描述了两个实验性基准测试。选项中提出的问题可以使用标准的性能建模技术（例如，对内存系统应用利特尔法则）来回答。\n-   **客观性**：语言精确且技术性强，没有主观性。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。这是一个计算机体系结构性能分析领域中形式良好的问题。我现在将着手解决。\n\n### 推导与选项分析\n\n这个问题的核心在于理解延迟、吞吐量和并发性（MLP）之间的关系。源自利特尔法则的关键公式将这些量联系起来：\n$$\n\\text{吞吐量} = \\frac{\\text{MLP}}{D}\n$$\n其中吞吐量以“加载/周期”为单位，MLP是在途并发加载的数量，D是以周期为单位的加载延迟。平均每次加载周期数（CPL）是吞吐量的倒数：\n$$\n\\text{CPL} = \\frac{1}{\\text{吞吐量}} = \\frac{D}{\\text{MLP}}\n$$\n硬件有两个关键限制：\n1.  它可以跟踪的在途未命中数：$\\text{MLP} \\le M = 16$。\n2.  它每个周期可以发射的加载数：$\\text{吞吐量}_{\\text{发射}} \\le W_{\\mathrm{ld}} = 2$ 次加载/周期。\n\n整个系统的吞吐量将是加载发射速率和内存系统完成加载速率中的较小者。\n\n#### 分析选项\n\n**A. 在依赖型基准测试中，对于较大的 $N$，除了很小的循环开销外，平均每次加载的周期数近似趋向于 $D$。**\n在依赖型指针追逐基准测试中，加载 $i+1$ 的地址是从加载 $i$ 返回的数据中获得的。这是一个真正的数据依赖 `(p = p-next)`。乱序执行引擎无法打破这种依赖。因此，加载必须串行处理。处理器发射一次加载，等待大约 $D=200$ 个周期以使数据返回，计算下一个地址（一个很小的开销），然后发射下一次加载。对于这个依赖链，任何时候只能有一个内存访问“在途”。因此，有效的MLP为1。每次加载的耗时主要由内存延迟 $D$ 决定。每次加载的周期数（CPL）是：\n$$\n\\text{CPL} = \\frac{D}{\\text{MLP}} = \\frac{D}{1} = D = 200 \\text{ 周期}\n$$\n该陈述与此分析一致。\n**A的结论：正确**\n\n**B. 在独立型基准测试中，当 $K \\ge M$ 时，稳态加载吞吐量近似趋向于每周期 $M/D$ 次加载，因此以总周期数除以总加载数测得的平均每次加载周期数近似趋向于 $D/M$。**\n在独立型基准测试中，核心有 $K$ 个独立加载可供使用。硬件最多可以跟踪 $M=16$ 个在途未命中。如果可用的独立加载数 $K$ 大于或等于 $M$，核心可以使其内存跟踪资源饱和。持续的MLP将受到硬件的限制，因此 $\\text{MLP} = M = 16$。内存系统的吞吐量则为：\n$$\n\\text{吞吐量} = \\frac{\\text{MLP}}{D} = \\frac{M}{D} = \\frac{16}{200} = 0.08 \\text{ 次加载/周期}\n$$\n核心的发射宽度是 $W_{\\mathrm{ld}}=2$ 次加载/周期。由于 $0.08  2$，瓶颈在于内存系统服务并发请求的能力，而不是核心的发射速率。平均每次加载的周期数是吞吐量的倒数：\n$$\n\\text{CPL} = \\frac{1}{\\text{吞吐量}} = \\frac{D}{M} = \\frac{200}{16} = 12.5 \\text{ 周期/加载}\n$$\n该陈述的主张与此推导相符。\n**B的结论：正确**\n\n**C. 将 $K$ 增加到超过 $M$ 会进一步按比例减少测得的每次加载周期数，因为更多独立的加载会无限制地增加MLP。**\n问题明确指出，核心最多可以跟踪 $M=16$ 个在途未命中。这是一个硬性的硬件限制。一旦在途未命中的数量达到 $M$，加载发射机制必须暂停，直到现有的一次未命中完成，从而释放一个跟踪槽位。因此，无论 $K$（可用独立加载的数量）变得多大，MLP都不能超过 $M$。MLP是有上限的：$\\text{MLP}_{\\text{max}} = M$。由于 $\\text{CPL} = D/\\text{MLP}$，最小的CPL是 $D/M$。将 $K$ 增加到超过 $M$ 不会为吞吐量或CPL带来进一步的好处。声称MLP“无限制地”增加是错误的。\n**C的结论：不正确**\n\n**D. 如果修改依赖型基准测试，插入软件预取指令，尝试预取前方 $P=8$ 个节点，那么在完美预取的情况下，即使指针链在概念上是依赖的，测得的每次加载周期数也应接近 $D/M$。**\n这个陈述在多个层面上都有缺陷。在一个链表中，每个节点的地址都存储在前一个节点中，软件不可能在不先访问节点 $i, i+1, \\dots, i+P-1$ 的情况下知道节点 $i+P$ 的地址。软件预取指令需要一个地址，而这正是串行依赖的信息。因此，在这种情况下，软件预取无法创造并行性。即使假设存在一个特殊的硬件指针追逐预取器，可以“向前看” $P=8$ 个节点，它最多也只能创造 $P=8$ 的MLP。由此产生的CPL将是 $D/P = D/8$。该陈述声称CPL应接近 $D/M = D/16$。这与给定的预取距离 $P=8$ 在数值上不一致。\n**D的结论：不正确**\n\nE. 如果 $K=8", "answer": "$$\\boxed{ABFG}$$", "id": "3673535"}]}