{"hands_on_practices": [{"introduction": "理论知识最终要应用于实践。内存带宽的优化始于对数据在内存中如何组织的深刻理解。本练习将引导你分析一个核心的性能问题：数据布局。通过比较“结构数组”(AoS)和“数组结构”(SoA)这两种常见的数据组织方式，你将亲手计算由于数据在缓存行内非连续存放而导致的带宽浪费[@problem_id:3621491]。这个计算过程将揭示，高效的内存访问不仅仅关乎你访问什么数据，更关乎这些数据在内存中的排列方式。", "problem": "一个流式内核遍历一个结构体数组，对于每个结构体，它精确地读取两个 $4$ 字节的标量字段：一个在结构体内部字节偏移量为 $0$ 的位置，另一个在字节偏移量为 $32$ 的位置。该数组包含 $N = 4096$ 个结构体，每个结构体的总大小为 $48$ 字节，并且数组的基地址与 $64$ 字节边界对齐。内存系统使用 $64$ 字节的缓存行，在发生缓存未命中时，会从主内存传输整个缓存行；缓存行传输与 $64$ 字节边界对齐，并且不能跨行合并。该循环足够长并且其调度方式使得内存子系统的持续读取带宽饱和，达到 $S = 51.2$ GB/s（十进制千兆字节每秒）。\n\n考虑针对相同访问模式的两种数据布局变体：\n1. 结构体数组 (AoS)：单个数组按照上述 $48$ 字节记录的顺序，在内存中连续存储每个结构体的所有字段。内核只读取每个结构体偏移量为 $0$ 和 $32$ 的两个字段，从不触及其他字节。\n2. 数组结构 (SoA)：两个独立的数组分别存储这两个字段，每个数组都是一个由 $4$ 字节元素组成的连续数组；内核以流式方式遍历这两个数组，每个元素读取一次。两个数组都与 $64$ 字节对齐。\n\n从内存带宽（单位时间内传输的字节数）和缓存行填充行为的核心定义出发，并且不使用任何预先推导的捷径结果，确定在所述假设下，AoS 布局中两个字段的非连续放置相对于 SoA 布局所导致的浪费带宽 $B$（以 GB/s 为单位）。以 GB/s 为单位表示最终值，并将答案四舍五入到四位有效数字。", "solution": "基本量是持续内存带宽 $S$（单位时间内的字节数），以及程序实际需要的字节数与由于 $64$ 字节缓存行粒度而必须传输的字节数。浪费的带宽定义为计算中未使用的传输字节数所占的比例，再乘以 $S$。\n\n我们分析两种布局。\n\nAoS 分析。每个结构体大小为 $48$ 字节，被访问的两个字段位于偏移量 $0$ 和 $32$ 处。基地址与 $64$ 字节边界对齐。设结构体索引为 $k \\in \\{0,1,\\dots,N-1\\}$。结构体 $k$ 的两个字段的字节地址为\n$$\na_k = 48k + 0,\\qquad b_k = 48k + 32.\n$$\n设缓存行大小为 $L = 64$ 字节。包含地址 $x$ 的缓存行索引为 $\\ell(x) = \\left\\lfloor \\frac{x}{L} \\right\\rfloor$。对于任何被访问地址所落入的每个不同缓存行索引，内存系统都会传输 $L$ 字节，并与 $64$ 字节边界对齐。\n\n因此，对于 AoS 遍历，所触及的不同缓存行的总数是以下集合并集的大小\n$$\n\\mathcal{A} = \\left\\{ \\ell(a_k) : k = 0,1,\\dots,N-1 \\right\\},\\qquad \\mathcal{B} = \\left\\{ \\ell(b_k) : k = 0,1,\\dots,N-1 \\right\\}.\n$$\n我们首先描述 $\\mathcal{A}$ 和 $\\mathcal{B}$ 的特征。考虑 $a_k$ 对 $L$ 取模的余数：\n$$\na_k \\bmod L = (48k) \\bmod 64.\n$$\n由于 $\\gcd(48,64) = 16$，余数以 $4$ 为周期循环，$0,48,32,16,0,48,32,16,\\dots$。连续的 $k$ 值对应的缓存行索引演变如下\n$$\n\\ell(a_0) = 0,\\ \\ell(a_1) = 0,\\ \\ell(a_2) = 1,\\ \\ell(a_3) = 2,\\ \\ell(a_4) = 3,\\ \\ell(a_5) = 3,\\ \\ell(a_6) = 4,\\ \\ell(a_7) = 5,\\ \\dots\n$$\n这个序列在每一步都增加 $1$，除非余数为 $0$（对于 $k \\equiv 0 \\ (\\text{mod }4)$），此时下一个 $a_{k+1}$ 仍位于同一缓存行中。在 $N-1$ 次转换中计算增量，零增量转换的次数是满足 $k \\equiv 0 \\ (\\text{mod }4)$ 的 $k \\in \\{0,\\dots,N-2\\}$ 的数量，其等于 $\\left\\lfloor \\frac{N-2}{4} \\right\\rfloor + 1$。因此，总增量计数为\n$$\n(N-1) - \\left( \\left\\lfloor \\frac{N-2}{4} \\right\\rfloor + 1 \\right) = N - 2 - \\left\\lfloor \\frac{N-2}{4} \\right\\rfloor,\n$$\n$\\mathcal{A}$ 访问的最大行索引就是这个计数值；因此 $\\mathcal{A}$ 中不同行的数量是\n$$\n|\\mathcal{A}| = \\left( N - 2 - \\left\\lfloor \\frac{N-2}{4} \\right\\rfloor \\right) + 1 = N - 1 - \\left\\lfloor \\frac{N-2}{4} \\right\\rfloor.\n$$\n\n类似地，对于 $b_k = 48k + 32$，对 $64$ 取模的余数以 $4$ 为周期循环，$32,16,0,48,32,16,0,48,\\dots$。行索引序列在每一步都增加 $1$，除非余数为 $0$（当 $k \\equiv 2 \\ (\\text{mod }4)$ 时发生），此时下一个 $b_{k+1}$ 仍位于同一行中。在 $N-1$ 次转换中，零增量转换的次数是满足 $k \\equiv 2 \\ (\\text{mod }4)$ 的 $k \\in \\{0,\\dots,N-2\\}$ 的数量，其等于\n$$\n\\left\\lfloor \\frac{N-4}{4} \\right\\rfloor + 1 = \\left\\lfloor \\frac{N}{4} \\right\\rfloor.\n$$\n因此，\n$$\n|\\mathcal{B}| = \\left( (N-1) - \\left\\lfloor \\frac{N}{4} \\right\\rfloor \\right) + 1 = N - \\left\\lfloor \\frac{N}{4} \\right\\rfloor.\n$$\n\n我们现在求并集。观察到 $\\mathcal{A}$ 和 $\\mathcal{B}$ 都是从 $0$ 开始并延伸到各自最大值的连续缓存行索引集（存在重复但没有跳跃）。因此，并集 $\\mathcal{A} \\cup \\mathcal{B}$ 也是一个索引上的连续集 $[0, M]$，其中 $M = \\max\\{\\max \\mathcal{A}, \\max \\mathcal{B}\\}$。因此，\n$$\n|\\mathcal{A} \\cup \\mathcal{B}| = \\max\\{|\\mathcal{A}|, |\\mathcal{B}|\\}.\n$$\n对于 $N \\equiv 0$ 或 $1 \\ (\\text{mod }4)$，我们发现 $|\\mathcal{A}| = |\\mathcal{B}|$；对于 $N \\equiv 2$ 或 $3 \\ (\\text{mod }4)$， $|\\mathcal{B}| = |\\mathcal{A}| + 1$。在所有情况下，\n$$\n|\\mathcal{A} \\cup \\mathcal{B}| = N - \\left\\lfloor \\frac{N}{4} \\right\\rfloor.\n$$\n\n因此，AoS 遍历传输的总字节数（每次完整遍历 $N$ 个结构体）是\n$$\nT_{\\text{AoS}} = L \\cdot |\\mathcal{A} \\cup \\mathcal{B}| = 64 \\left( N - \\left\\lfloor \\frac{N}{4} \\right\\rfloor \\right).\n$$\n计算实际使用的字节数是每个结构体两个 $4$ 字节字段的总和：\n$$\nU = 8N.\n$$\n那么 AoS 的浪费比例是\n$$\nw_{\\text{AoS}} = 1 - \\frac{U}{T_{\\text{AoS}}} = 1 - \\frac{8N}{64 \\left( N - \\left\\lfloor \\frac{N}{4} \\right\\rfloor \\right)} = 1 - \\frac{N}{8 \\left( N - \\left\\lfloor \\frac{N}{4} \\right\\rfloor \\right)}.\n$$\n\nSoA 分析。在数组结构 (SoA) 布局中，这两个字段位于两个独立的连续数组中，每个数组由 $4$ 字节元素组成，并与 $64$ 字节对齐。以流式方式遍历每个数组所触及的缓存行数等于覆盖 $N$ 个 $4$ 字节元素所需的 $64$ 字节块的数量，即，\n$$\n|\\mathcal{S}| = \\left\\lceil \\frac{4N}{64} \\right\\rceil = \\left\\lceil \\frac{N}{16} \\right\\rceil\n$$\n对于每个数组，这些行中的所有字节都对应于被循环读取的元素。对于 $N$ 是 $16$ 的倍数的情况，每个缓存行都被完全利用，因此两个数组的浪费均为零。因此，SoA 的浪费比例是\n$$\nw_{\\text{SoA}} = 0 \\quad \\text{对于 } N \\text{ 可被 } 16 \\text{ 整除}.\n$$\n\n由于内核使内存带宽饱和在 $S$，相对于 SoA，专门由非连续 AoS 布局导致的浪费带宽是\n$$\nB = S \\cdot \\left( w_{\\text{AoS}} - w_{\\text{SoA}} \\right) = S \\cdot w_{\\text{AoS}}.\n$$\n\n数值计算。这里 $N = 4096$ 是 $16$ 的倍数，所以 $\\left\\lfloor \\frac{N}{4} \\right\\rfloor = \\left\\lfloor \\frac{4096}{4} \\right\\rfloor = 1024$。因此，\n$$\nT_{\\text{AoS}} = 64 \\left( 4096 - 1024 \\right) = 64 \\cdot 3072 = 196608,\n$$\n$$\nU = 8 \\cdot 4096 = 32768,\n$$\n和\n$$\nw_{\\text{AoS}} = 1 - \\frac{32768}{196608} = 1 - \\frac{1}{6} = \\frac{5}{6}.\n$$\n当 $S = 51.2$ GB/s 时，\n$$\nB = 51.2 \\cdot \\frac{5}{6} = 42.\\overline{6} \\ \\text{GB/s}.\n$$\n四舍五入到四位有效数字并以 GB/s 表示，结果是 $42.67$ GB/s。", "answer": "$$\\boxed{42.67}$$", "id": "3621491"}, {"introduction": "现代处理器并不仅仅被动地响应内存请求，它们会通过硬件预取器主动预测未来的数据需求，以隐藏内存延迟。然而，预取是一种推测性行为，当预测错误时，它会获取无用的数据，这不仅污染了缓存，也浪费了宝贵的内存带宽。本练习将带你量化这种“预取器污染”所造成的带宽损失[@problem_id:3621496]。通过运用预取器准确率和覆盖率这两个关键性能指标，你将学会如何从系统层面评估一项硬件优化功能的实际开销。", "problem": "一个多核处理器使用一个流预取器，该预取器受到内存控制器的节流，以限制在动态随机存取存储器（DRAM）子系统中的干扰。内存控制器强制执行一个标称预取带宽预算 $B_{\\text{pref}}$（单位为 GB/s）。对于单个正在运行的应用程序，在一个长的稳态时间间隔内，硬件性能计数器报告了两个预取器质量指标：\n- 准确率 $a$：被预取的缓存行在被驱逐前，随后被请求指令访问的比例。\n- 覆盖率 $c$：在该时间间隔内，预取器以其预算速率主动发出预取的比例。\n\n假设以下基于第一性原理的操作模型：\n- 带宽是每单位时间的数据量。\n- 当预取器活跃时，它以强制执行的预算 $B_{\\text{pref}}$ 发出预取请求。\n- 每个预取的字节要么是有用的（最终被请求指令访问），要么是无用的（从未被请求指令访问）。\n- 准确率 $a$ 可以被解释为一个预取的字节是有用的条件概率；因此，一个预取的字节是无用的概率是 $1 - a$。\n\n在此模型下，从这些定义中推导出一个表达式，用于表示在整个时间间隔内因不正确的预取（被预取器获取但从未被请求使用的字节）而浪费的平均 DRAM 带宽，然后计算当 $a = 0.72$，$c = 0.60$ 和 $B_{\\text{pref}} = 24$ GB/s 时的值。最终浪费的带宽以 GB/s 表示，并将你的答案四舍五入到四位有效数字。", "solution": "我们的目标是找出因不正确的预取而浪费的平均带宽，我们将其记为 $B_{\\text{wasted}}$。我们可以通过考虑数据被预取的平均速率以及其中无用数据的比例来进行推理。\n\n预取器并非一直活跃。根据定义，它只在总时间间隔的一部分 $c$ 内活跃。当它活跃时，它以 $B_{\\text{pref}}$ 的速率消耗带宽。当它不活跃时（在 $1-c$ 的时间比例内），它消耗零预取带宽。\n\n为了找出整个时间间隔内的平均预取带宽，我们可以对瞬时带宽进行时间加权平均。令 $\\bar{B}_{\\text{pref\\_total}}$ 为预取消耗的平均总带宽。\n$$\n\\bar{B}_{\\text{pref\\_total}} = (c \\times B_{\\text{pref}}) + ((1-c) \\times 0) = c \\cdot B_{\\text{pref}}\n$$\n这个表达式 $c \\cdot B_{\\text{pref}}$ 表示在长的稳态时间间隔内，预取器获取数据的时间平均速率。\n\n接下来，我们必须确定这些被获取的数据中有多少比例是浪费的。问题将准确率 $a$ 定义为预取数据中有用（即最终被使用）的比例。因此，预取数据中无用（即浪费）的比例必须是 $1 - a$。\n\n根据定义，浪费的带宽是无用数据被传输的速率。这可以通过将平均总预取带宽乘以无用数据的比例来得到。\n$$\nB_{\\text{wasted}} = (\\text{无用预取的比例}) \\times (\\text{平均总预取带宽})\n$$\n代入我们推导出的表达式：\n$$\nB_{\\text{wasted}} = (1 - a) \\cdot \\bar{B}_{\\text{pref\\_total}}\n$$\n$$\nB_{\\text{wasted}} = (1 - a) \\cdot c \\cdot B_{\\text{pref}}\n$$\n这就是平均浪费的预取带宽的最终解析表达式。\n\n现在，我们使用提供的数据计算数值：\n-   $a = 0.72$\n-   $c = 0.60$\n-   $B_{\\text{pref}} = 24$ GB/s\n\n将这些值代入推导出的表达式中：\n$$\nB_{\\text{wasted}} = (1 - 0.72) \\cdot (0.60) \\cdot (24 \\frac{\\text{GB}}{\\text{s}})\n$$\n$$\nB_{\\text{wasted}} = (0.28) \\cdot (0.60) \\cdot (24 \\frac{\\text{GB}}{\\text{s}})\n$$\n进行乘法运算：\n$$\n0.28 \\times 0.60 = 0.168\n$$\n$$\n0.168 \\times 24 = 4.032\n$$\n因此，平均浪费带宽的数值是 $4.032$ GB/s。问题要求答案四舍五入到四位有效数字。计算结果 $4.032$ 已经正好是四位有效数字。", "answer": "$$\n\\boxed{4.032}\n$$", "id": "3621496"}, {"introduction": "在多核处理器时代，带宽的消耗不仅来自CPU与主存之间的数据传输，还来自于维持多个核心缓存数据一致性所产生的核间流量。本练习将深入探讨一个经典的多线程性能陷阱——“伪共享”(False Sharing)[@problem_id:3621446]。当多个线程更新位于同一缓存行内的不同数据时，即使这些数据在逻辑上是独立的，缓存一致性协议也会强制该缓存在核心之间频繁传输。你将通过逐步追踪MESI协议的状态变迁，精确计算出这种伪共享所引发的额外数据传输量，从而深刻理解并发编程中数据对齐的重要性。", "problem": "一个共享内存多处理器有 $n$ 个对称核心，每个核心都有一个私有的L1（Level 1）写回式缓存，该缓存实现了具有写失效（write-invalidate）语义和存储时请求所有权（Read For Ownership, RFO）的MESI（Modified, Exclusive, Shared, Invalid）协议。缓存行大小为 $64$ 字节。考虑 $n=8$ 个线程，一对一地固定到 $8$ 个核心上。每个线程重复更新一个共享结构体中属于自己的 $8$ 字节字段，该结构体的 $8$ 个字段连续布局且对齐，使得所有 $8$ 个字段都位于同一个缓存行内。一个全局屏障确保了确定的更新顺序：在每次迭代中，线程 $1$ 对其字段执行一次存储，然后线程 $2$ 对其字段执行一次存储，依此类推，直到线程 $8$，之后该序列无限重复。假设缓存行一旦首次被访问后就不会被驱逐，并忽略除了一致性事件导致的整行数据传输之外的所有流量（将失效消息的数据量视为可忽略不计）。作为基准，考虑相同的计算，但每个线程的字段被放置在不同的缓存行上，因此没有伪共享（false sharing）；在预热（warm-up）后，此基准每次更新引起的核间数据移动为零。\n\n从MESI协议中缓存一致性和所有权的基本定义出发，不要使用任何预先推导的快捷公式，确定在所述场景中，与无伪共享的基准相比，完全由伪共享导致的每次更新的稳态平均额外互连数据量。以每次更新的字节数（bytes per update）表示您的最终答案。", "solution": "问题要求计算由伪共享导致的每次更新的稳态平均额外互连数据量。我们被要求从MESI（修改、独占、共享、无效）缓存一致性协议的基本原理出发进行推导。\n\n设 $L_s$ 为缓存行大小，给定为 $L_s = 64$ 字节。\n设 $N$ 为核心数和线程数，给定为 $N=8$。\n每个线程 $i$（$i \\in \\{1, 2, \\dots, 8\\}$）都固定到相应的核心上，该核心拥有一个私有L1缓存，记为 $C_i$。\n$N$ 个线程重复地对其各自的 $8$ 字节字段执行存储操作，这些字段都位于同一个 $64$ 字节的缓存行上，我们称之为 $CL$。\n\n执行模式是一个严格的序列：线程 $1$ 存储，然后是线程 $2$，依此类推，直到线程 $8$。这构成一个完整的迭代，然后重复。我们关心的是稳态行为。\n\n首先，我们分析没有伪共享的基准情况。在这种场景下，每个线程的数据位于一个单独的缓存行上。经过一次初始的“预热”存储后，核心 $i$ 将以**修改（M）**状态持有其数据的缓存行。由于没有其他核心会访问该行，因此线程 $i$ 的任何后续存储都将是对处于**M**状态缓存行的本地缓存命中。对**M**状态行的写入不会产生任何互连流量。因此，如问题中所述，基准情况下的互连数据量为每次更新 $0$ 字节。\n\n现在，我们来分析伪共享的场景。我们需要追踪单个共享缓存行 $CL$ 在所有 $N=8$ 个缓存中的状态。MESI协议的行为是关键。只有当核心对缓存行拥有独占所有权时，才能执行存储操作。这对应于该行在该核心的缓存中处于**修改（M）**或**独占（E）**状态。对处于**共享（S）**或**无效（I）**状态的行进行存储将触发一个一致性事件以获得所有权。具体来说，核心将在互连上发出一个请求所有权（RFO）的请求。\n\n让我们追踪一个完整的稳态迭代，从线程 $1$ 执行其存储操作之前开始。在前一次迭代中，线程 $8$ 是最后一个执行存储的线程。为此，它必须已经获得了行 $CL$ 的所有权。此操作会使其缓存 $C_8$ 中的 $CL$ 进入**M**状态，并同时使所有其他副本失效。因此，在我们观察的迭代开始时：\n-   $CL$ 在 $C_8$ 中的状态是**M**。\n-   $CL$ 在 $C_1, C_2, \\dots, C_7$ 中的状态是**I**。\n\n现在，更新序列开始：\n1.  **线程 1 执行存储：**\n    -   核心 $1$ 在其缓存 $C_1$ 中发现 $CL$ 处于**I**状态。这是一次写未命中。\n    -   为满足存储操作，核心 $1$ 必须获得所有权。它在互连上发出一个RFO请求。\n    -   核心 $8$ 监听到互连上的RFO请求，该请求针对它以**M**状态持有的 $CL$。\n    -   根据MESI协议，核心 $8$ 必须响应RFO。它将其修改过的 $CL$ 版本刷新到互连上。这构成了一次整个缓存行的数据传输。在提供数据后，它将其本地对 $CL$ 的状态更改为**I**。\n    -   核心 $1$ 接收到 $64$ 字节的缓存行，执行其存储操作，并将其对 $CL$ 的状态设置为**M**。\n    -   **本次更新的数据量：** 一次完整的缓存行传输，即 $L_s = 64$ 字节。\n    -   在此步骤结束时，$C_1$ 中 $CL$ 的状态为**M**。所有其他缓存（$C_2, \\dots, C_8$）中 $CL$ 的状态为**I**。\n\n2.  **线程 2 执行存储：**\n    -   情况与上一步类似。核心 $2$ 发现 $CL$ 处于**I**状态。\n    -   核心 $2$ 发出RFO请求。\n    -   核心 $1$ 监听到RFO请求，发现它持有**M**状态的 $CL$，并响应，通过互连发送其 $64$ 字节的 $CL$ 副本。然后它将其状态转换为**I**。\n    -   核心 $2$ 接收到缓存行，执行其存储操作，并将其状态转换为**M**。\n    -   **本次更新的数据量：** 一次完整的缓存行传输，$L_s = 64$ 字节。\n    -   在此步骤结束时，$C_2$ 中 $CL$ 的状态为**M**。所有其他缓存（$C_1, C_3, \\dots, C_8$）中 $CL$ 的状态为**I**。\n\n这种模式对序列中的每个线程都持续发生。对于任何线程 $i \\in \\{1, 2, \\dots, 8\\}$，其存储操作都会发现行 $CL$ 处于**I**状态。它会发出一个RFO请求，该请求将由前一个所有者（核心 $i-1$，如果 $i=1$ 则是核心 $8$）来满足，该所有者以**M**状态持有该行。此服务总是涉及整个 $64$ 字节行的缓存到缓存传输。\n\n一次迭代包含 $N=8$ 次更新。这 $8$ 次更新中的每一次都会导致整个缓存行从前一个写入者迁移到当前写入者。\n-   更新 $1$ 的数据传输：$64$ 字节（从 $C_8$ 到 $C_1$）\n-   更新 $2$ 的数据传输：$64$ 字节（从 $C_1$ 到 $C_2$）\n-   ...\n-   更新 $8$ 的数据传输：$64$ 字节（从 $C_7$ 到 $C_8$）\n\n一次完整迭代（包含 $8$ 次更新）的总互连数据量是：\n$$V_{\\text{iteration}} = N \\times L_s = 8 \\times 64 \\text{ 字节} = 512 \\text{ 字节}$$\n\n问题要求*每次更新*的*平均*数据量。我们可以通过将每次迭代的总数据量除以该迭代中的更新次数来得到：\n$$V_{\\text{avg}} = \\frac{V_{\\text{iteration}}}{N} = \\frac{N \\times L_s}{N} = L_s$$\n代入 $L_s$ 的值：\n$$V_{\\text{avg}} = 64 \\text{ 字节/更新}$$\n\n最后，我们需要确定与无伪共享基准相比的*额外*数据量。\n伪共享情况下的流量为 $V_{\\text{avg}} = 64$ 字节/更新。\n基准情况下的流量给定为 $V_{\\text{baseline}} = 0$ 字节/更新。\n\n每次更新的额外互连数据量是：\n$$V_{\\text{additional}} = V_{\\text{avg}} - V_{\\text{baseline}} = 64 - 0 = 64 \\text{ 字节/更新}$$\n\n这个结果直接源于具有RFO语义的写失效协议的基本行为：每当一个核心要写入一个它并不以修改状态拥有的共享缓存行时，它必须获取整个缓存行，导致 $L_s$ 的数据传输。在这种特定的病态场景中，每一次更新都会发生这种情况。", "answer": "$$\n\\boxed{64}\n$$", "id": "3621446"}]}