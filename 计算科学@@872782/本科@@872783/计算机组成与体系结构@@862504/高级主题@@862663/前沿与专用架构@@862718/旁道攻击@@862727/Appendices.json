{"hands_on_practices": [{"introduction": "在时序侧信道攻击中，一个核心的实际挑战是，由单个事件（如一次缓存未命中）引起的微小时间差 $\\delta$ 通常远小于可用计时器的分辨率 $\\Delta$。本练习将指导你推导一个基本而强大的技术：通过重复执行一个操作来放大这个微弱的信号，直到它变得可以被明确地测量。理解这种信号放大原理是成功实施时序攻击的第一步。[@problem_id:3676151]", "problem": "攻击者正在对中央处理器（CPU）发起计时侧信道攻击，通过测量一段可能包含恰好一次额外的末级缓存（LLC）未命中的代码路径的时间。相对于无未命中的基准情况，这一次未命中会给执行时间增加一个大小为 $\\delta$ 的微小真实时间增量，其中 $\\delta \\ll \\Delta$。可用的计时器具有有限分辨率 $\\Delta$：任何真实的经过时间 $T$ 将返回不超过 $T$ 的 $\\Delta$ 的最大倍数。\n\n攻击者可以通过连续重复相同的对测量敏感的操作 $R$ 次，然后读取一次计时器来放大时间差异，这对基准路径和每次操作产生一次额外未命中的路径都适用。假设与计时器分辨率引起的量化误差相比，所有其他噪声源都可以忽略不计，并且每次操作的真实未命中惩罚 $\\delta$ 在重复中是恒定且独立的。\n\n仅从以下基本依据出发：\n- 如果单个操作在两种情况下表现出 $\\delta$ 的真实时间差异，那么 $R$ 次相同的连续重复将在这些情况下表现出 $R \\delta$ 的真实时间差异。\n- 对于真实时间 $T$，计时器返回的测量时间为 $M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$，其中 $\\left\\lfloor \\cdot \\right\\rfloor$ 是向下取整函数。\n\n推导出一个关于 $R$ 的条件，该条件保证两种测量时间（基准情况与每次操作一次未命中的情况）对于量化区间内真实时间的任何可能对齐方式都将是不同的。然后，确定满足此条件的最小整数 $R$。请用一个关于 $\\Delta$ 和 $\\delta$ 的单一封闭形式解析表达式来表示您的最终答案。", "solution": "问题要求推导出一个关于重复次数 $R$ 的条件，以保证可测量的计时差异，并由此得出 $R$ 的最小整数值。分析将从提供的基本定义出发。\n\n首先，我们来定义真实执行时间。设 $T_{0}$ 为基准（无未命中）操作的真实执行时间。\n$R$ 次重复基准路径的真实执行时间为：\n$$T_{base} = R T_{0}$$\n\n每次操作有一次额外未命中的路径，其单次操作的真实执行时间为 $T_{0} + \\delta$。对于 $R$ 次连续重复，其真实执行时间为：\n$$T_{miss} = R (T_{0} + \\delta) = R T_{0} + R \\delta$$\n\n计时器具有有限分辨率 $\\Delta$。对于真实时间 $T$，测量时间 $M$ 由以下函数给出：\n$$M(T) = \\Delta \\left\\lfloor \\frac{T}{\\Delta} \\right\\rfloor$$\n其中 $\\lfloor \\cdot \\rfloor$ 是向下取整函数。\n\n将此应用于我们的两种情况，基准路径的测量时间为：\n$$M_{base} = M(T_{base}) = \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor$$\n\n有未命中路径的测量时间为：\n$$M_{miss} = M(T_{miss}) = \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor$$\n\n目标是找到一个关于 $R$ 的条件，以保证对于任何可能的 $T_{0}$ 值，都有 $M_{miss} \\neq M_{base}$。由于未命中惩罚 $\\delta$ 是一个正的时间增量，所以 $T_{miss} > T_{base}$。因此，测量时间不会减少，即 $M_{miss} \\ge M_{base}$。因此，测量时间不同的条件等价于要求 $M_{miss} > M_{base}$。\n\n$$ \\Delta \\left\\lfloor \\frac{R T_{0} + R \\delta}{\\Delta} \\right\\rfloor > \\Delta \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\n两边同除以 $\\Delta$（一个正的时间量）不改变不等式方向：\n$$ \\left\\lfloor \\frac{R T_{0}}{\\Delta} + \\frac{R \\delta}{\\Delta} \\right\\rfloor > \\left\\lfloor \\frac{R T_{0}}{\\Delta} \\right\\rfloor $$\n\n让我们引入无量纲变量 $x = \\frac{R T_{0}}{\\Delta}$ 和 $y = \\frac{R \\delta}{\\Delta}$。所需条件变为：\n$$ \\lfloor x + y \\rfloor > \\lfloor x \\rfloor $$\n这个不等式必须对任何 $x \\ge 0$ 的值都成立，因为基准时间 $T_{0}$ 是未知的，可能导致“量化区间内真实时间的任何对齐方式”。变量 $x$ 代表了这种对齐方式，并按重复次数 $R$ 进行了缩放。\n\n不等式 $\\lfloor x + y \\rfloor > \\lfloor x \\rfloor$ 不成立，当且仅当区间 $(x, x+y]$ 中没有整数。这种情况，即 $\\lfloor x+y \\rfloor = \\lfloor x \\rfloor$，对攻击者构成了最大的挑战。我们需要找到一个关于 $y$（并因此关于 $R$）的条件，以防止对于任何 $x$ 这个等式都有可能成立。\n\n区分时间的最坏情况发生在基准真实时间 $T_{base}$（即 $x$）的位置使得增加的放大惩罚 $R\\delta$（即 $y$）最不可能跨越计时器分辨率的整数边界。这种情况发生在基准时间 $T_{base}$ 恰好略大于 $\\Delta$ 的某个倍数时。\n\n让我们将其形式化。设 $k = \\lfloor x \\rfloor$ 为一个整数。$x$ 的值可以写成 $x = k + \\epsilon$，其中 $0 \\le \\epsilon  1$。变量 $\\epsilon$ 代表 $x$ 的小数部分，对应于计时器量化区间内的对齐方式。问题陈述这必须对*任何*可能的对齐方式都成立，因此我们必须考虑所有可能的值 $\\epsilon \\in [0, 1)$。\n\n不等式变为：\n$$ \\lfloor k + \\epsilon + y \\rfloor > \\lfloor k + \\epsilon \\rfloor $$\n由于 $k$ 是整数且 $0 \\le \\epsilon  1$，我们有 $\\lfloor k + \\epsilon \\rfloor = k$。条件是：\n$$ \\lfloor k + \\epsilon + y \\rfloor > k $$\n这等价于要求：\n$$ k + \\epsilon + y \\ge k+1 $$\n$$ \\epsilon + y \\ge 1 $$\n\n这个不等式，$y \\ge 1 - \\epsilon$，必须对所有可能的值 $\\epsilon \\in [0, 1)$ 都满足。为了保证这一点，我们必须为“最坏情况”下的 $\\epsilon$ 值满足该不等式，即那个使条件最难满足的值。右侧的 $1-\\epsilon$ 在 $\\epsilon$ 最小时最大化。$\\epsilon$ 的下界是 $0$。为了确保条件对于任意小的正 $\\epsilon$ 都成立，我们必须考虑当 $\\epsilon \\to 0^{+}$ 时的极限。\n在此极限下，条件变为：\n$$ y \\ge 1 $$\n\n代回 $y = \\frac{R\\delta}{\\Delta}$：\n$$ \\frac{R\\delta}{\\Delta} \\ge 1 $$\n$$ R\\delta \\ge \\Delta $$\n\n这就是保证无论初始计时对齐方式如何，测量时间都将不同的关于 $R$ 的通用条件。总的放大时间差 $R\\delta$ 必须至少与单个计时器分辨率区间 $\\Delta$ 一样大。\n\n最后一步是确定满足此条件的最小*整数* $R$。从不等式 $R\\delta \\ge \\Delta$，我们可以分离出 $R$：\n$$ R \\ge \\frac{\\Delta}{\\delta} $$\n由于 $R$ 必须是整数，满足此不等式的最小整数 $R$ 值是比率 $\\frac{\\Delta}{\\delta}$ 的向上取整。向上取整函数 $\\lceil z \\rceil$ 给出大于或等于 $z$ 的最小整数。\n\n因此，最小整数重复次数是：\n$$ R_{min} = \\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil $$\n此表达式是最小整数 $R$ 的完整且最终的解析解。问题陈述中的初始条件 $\\delta \\ll \\Delta$ 意味着 $\\frac{\\Delta}{\\delta} \\gg 1$，这证实了攻击要成功确实需要大量的重复，这与放大微小信号的前提是一致的。", "answer": "$$\\boxed{\\left\\lceil \\frac{\\Delta}{\\delta} \\right\\rceil}$$", "id": "3676151"}, {"introduction": "既然我们知道了如何测量微小的时间差，下一个问题是这些时间差从何而来。本练习将带你探究一个最常见的侧信道信息来源：CPU 缓存。你将分析一个经典的攻击场景，其中一个密钥 $k$ 被用来索引一个密码学替换盒（S-box），从而产生依赖于密钥的缓存访问模式，并最终量化这种模式泄露了多少关于密钥的信息。[@problem_id:3676164]", "problem": "一个含有 $256$ 个条目的单字节替换盒（S-box）在内存中连续存储，并按 $64$ 字节边界对齐。每个条目的大小为 $e$ 字节，其中 $e$ 是 2 的幂且满足 $1 \\leq e \\leq 64$，该表总共占用 $256e$ 字节。中央处理器（CPU）的缓存行大小为 $64$ 字节。假设每次 S-box 查找恰好访问一个缓存行，并且没有硬件特性（如预取）会获取不相关的缓存行。\n\n一个单字节的密钥 $k \\in \\{0,1,\\dots,255\\}$ 被用来构成 S-box 索引 $i = p \\oplus k$，其中 $\\oplus$ 表示按位异或，而 $p$ 是攻击者提供的一个已知明文字节。攻击者可以执行 $m \\geq 1$ 次选择明文查询，使用明文字节 $p_{1},\\dots,p_{m}$，并且对于每次查询，只能观察到 S-box 查找所访问的缓存行索引 $\\ell \\in \\{0,1,\\dots,L-1\\}$，其中 $L$ 是该表所跨越的缓存行数量。\n\n从计算机组成中与缓存和内存寻址相关的基本原理出发，回答以下问题：\n\n1. 推导映射到给定缓存行索引 $\\ell$ 的 S-box 索引 $i$ 的集合。请用 $e$、$64$ 和 $\\ell$ 表示你的推导过程，不使用任何快捷公式。\n\n2. 在 $k$ 于 $\\{0,\\dots,255\\}$ 上服从均匀先验分布，并假设通过已知的 $p_{j}$ 进行了 $m \\geq 1$ 次观测的条件下，通过计算后验分布的香农熵（以比特为单位）来量化这些观测后关于 $k$ 的剩余不确定性。将最终结果表示为关于 $e$ 的封闭形式表达式。不要四舍五入，结果以比特为单位表示。", "solution": "这个问题分为两个部分。首先，我们必须推导 S-box 索引与其对应的缓存行索引之间的关系。其次，我们必须利用这种关系，使用香农熵来量化关于密钥泄露的信息。\n\n### 第 1 部分：每个缓存行的 S-box 索引推导\n\n我们给定一个含有 $256$ 个条目的 S-box 表，它在内存中连续存储。该表的起始地址按 $64$ 字节边界对齐。设 S-box 表的基地址为 $A_{\\text{base}}$。对齐条件意味着 $A_{\\text{base}}$ 是 $64$ 的倍数。数学上表示为 $A_{\\text{base}} \\pmod{64} = 0$。\n\nS-box 中的每个条目大小为 $e$ 字节。S-box 的索引为 $i \\in \\{0, 1, \\dots, 255\\}$。索引为 $i$ 的条目的第一个字节的内存地址由下式给出：\n$$A_i = A_{\\text{base}} + i \\cdot e$$\nCPU 缓存的行大小为 $C_S = 64$ 字节。一个内存地址 $A$ 映射到一个物理缓存行。包含地址 $A$ 的缓存行的索引是 $\\lfloor A / C_S \\rfloor = \\lfloor A / 64 \\rfloor$。\n\n问题陈述攻击者观察到一个相对缓存行索引 $\\ell$。这是相对于 S-box 表起始位置的缓存行索引。该表占用的第一个缓存行的绝对索引为 $\\lfloor A_{\\text{base}} / 64 \\rfloor$。由于 $A_{\\text{base}}$ 是 $64$ 的倍数，假设 $A_{\\text{base}} = 64 \\cdot N$（其中 $N$ 为某个整数），则此索引就是 $N$。\n\n内存地址 $A_i$ 的绝对缓存行索引是 $\\lfloor A_i / 64 \\rfloor$。相对索引 $\\ell$ 是该索引与基索引之差：\n$$\\ell = \\lfloor \\frac{A_i}{64} \\rfloor - \\lfloor \\frac{A_{\\text{base}}}{64} \\rfloor$$\n代入 $A_i$ 和 $A_{\\text{base}}$ 的表达式：\n$$\\ell = \\left\\lfloor \\frac{64 \\cdot N + i \\cdot e}{64} \\right\\rfloor - \\left\\lfloor \\frac{64 \\cdot N}{64} \\right\\rfloor$$\n对于任意整数 $k$，使用向下取整函数（floor function）的属性 $\\lfloor x+k \\rfloor = \\lfloor x \\rfloor + k$：\n$$\\ell = \\left\\lfloor \\frac{i \\cdot e}{64} + N \\right\\rfloor - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor + N - N = \\left\\lfloor \\frac{i \\cdot e}{64} \\right\\rfloor$$\n这个方程给出了从 S-box 索引 $i$ 到观察到的相对缓存行索引 $\\ell$ 的映射关系。\n\n为了找出映射到给定缓存行索引 $\\ell$ 的 S-box 索引 $i$ 的集合，我们必须解这个关于 $i$ 的方程。根据向下取整函数的定义，方程 $\\ell = \\lfloor x \\rfloor$ 等价于不等式 $\\ell \\le x  \\ell + 1$。将此应用于我们的方程：\n$$\\ell \\le \\frac{i \\cdot e}{64}  \\ell + 1$$\n为了分离出 $i$，我们将不等式两边乘以 $64/e$：\n$$\\frac{64\\ell}{e} \\le i  \\frac{64(\\ell+1)}{e}$$\n由于 $i$ 必须是整数并且被限制在范围 $\\{0, 1, \\dots, 255\\}$ 内，映射到特定缓存行索引 $\\ell$ 的 S-box 索引集合 $S_\\ell$ 是：\n$$S_\\ell = \\left\\{ i \\in \\{0, 1, \\dots, 255\\} \\, \\middle| \\, \\frac{64\\ell}{e} \\le i  \\frac{64(\\ell+1)}{e} \\right\\}$$\n每个缓存行的 S-box 索引数量对于所有 $\\ell$ 都是恒定的，等于 $\\frac{64(\\ell+1)}{e} - \\frac{64\\ell}{e} = \\frac{64}{e}$。我们用 $N_C = \\frac{64}{e}$ 表示这个量。由于 $e$ 是 2 的幂且 $1 \\le e \\le 64$，$N_C$ 也是 2 的幂且 $1 \\le N_C \\le 64$。因此，索引集可以写成 $\\{i \\mid \\ell N_C \\le i  (\\ell+1)N_C\\}$。\n\n### 第 2 部分：量化剩余不确定性\n\n攻击者执行选择明文攻击。对于一个选定的明文 $p$，S-box 索引为 $i = p \\oplus k$，其中 $k$ 是密钥。攻击者观察到缓存行索引 $\\ell = \\lfloor (p \\oplus k) \\cdot e / 64 \\rfloor$。这个观测揭示了值 $p \\oplus k$ 属于哪个集合 $S_\\ell$。\n\n条件 $i \\in S_\\ell$ 等价于 $\\lfloor i/N_C \\rfloor = \\ell$，其中 $N_C = 64/e$。如前所述，$N_C$ 是 2 的幂。设 $N_C = 2^n$。操作 $i \\to \\lfloor i/2^n \\rfloor$ 等价于将 8 位整数 $i$ 进行 $n$ 位的算术右移。这个操作有效地提取了 $i$ 的最高有效 $8-n$ 位。$i$ 的最低有效 $n$ 位被丢弃。\n\n因此，对索引 $i=p \\oplus k$ 观测到 $\\ell$ 等价于获知了值 $p \\oplus k$ 的最高有效 $8-n$ 位。\n按位异或操作没有进位，这意味着结果 $p \\oplus k$ 的每一位仅取决于 $p$ 和 $k$ 的对应位。设 $x_{MSB}$ 和 $x_{LSB}$ 分别表示一个 8 位值 $x$ 的最高有效 $8-n$ 位和最低有效 $n$ 位。那么：\n$$(p \\oplus k)_{MSB} = p_{MSB} \\oplus k_{MSB}$$\n$$(p \\oplus k)_{LSB} = p_{LSB} \\oplus k_{LSB}$$\n攻击者观察到 $(p \\oplus k)_{MSB}$。由于攻击者选择了 $p$，他们知道 $p_{MSB}$。因此，他们可以计算出密钥的最高有效 $8-n$ 位：\n$$k_{MSB} = (p \\oplus k)_{MSB} \\oplus p_{MSB}$$\n对于任何已知的 $p$ 进行单次观测就足以确定 $k_{MSB}$。使用其他明文 $p_j$ 进行的任何进一步观测只会再次确认关于 $k_{MSB}$ 的相同信息。\n\n关键在于，该观测完全没有提供关于密钥最低有效 $n$ 位 $k_{LSB}$ 的任何信息。$k$ 的先验分布在所有 $256$ 种可能性上是均匀的，这意味着 $k$ 的 8 个比特位中的每一位都是一个独立的、均匀随机的二进制数字。攻击之后，最高 $8-n$ 位是已知的，但最低的 $n$ 位仍然完全未知，并且仍然是均匀分布的。\n\n可能的密钥集合被缩减为那些共享已确定的 $k_{MSB}$ 的密钥。由于 $k_{LSB}$ 中有 $n$ 个未知位，因此还剩下 $2^n$ 个可能的密钥。后验概率分布在这个包含 $2^n$ 个密钥的集合上是均匀的。这些剩余密钥中每一个的概率都是 $P(k) = 1/2^n$。\n\n密钥 $K$ 的后验分布的香Shannon熵由 $H(K) = -\\sum_{k} P(k) \\log_2 P(k)$ 给出。对于我们在 $2^n$ 个结果上的均匀分布：\n$$H(K) = - \\sum_{j=1}^{2^n} \\frac{1}{2^n} \\log_2\\left(\\frac{1}{2^n}\\right) = - 2^n \\cdot \\frac{1}{2^n} \\log_2(2^{-n}) = - (-n) = n$$\n剩余不确定性是 $n$ 比特。我们必须用给定的参数 $e$ 来表示它。我们有关系式 $N_C = 2^n$ 和 $N_C=64/e$。\n$$2^n = \\frac{64}{e}$$\n对等式两边取以 2 为底的对数：\n$$n = \\log_2\\left(\\frac{64}{e}\\right) = \\log_2(64) - \\log_2(e) = \\log_2(2^6) - \\log_2(e) = 6 - \\log_2(e)$$\n因此，由其后验分布的香Shannon熵量化的关于密钥 $k$ 的剩余不确定性为 $6 - \\log_2(e)$ 比特。", "answer": "$$\n\\boxed{6 - \\log_{2}(e)}\n$$", "id": "3676164"}, {"introduction": "前面的练习让我们直观地感受了信息泄露，但要进行严谨的安全性评估，我们需要一个形式化的度量标准。信息论为此提供了完美的工具，让我们能够以“比特”为单位精确量化泄露。在这个练习中，你将使用一个简化的概率模型来计算密钥 $S$ 与可观测的缓存未命中次数 $K$ 之间的互信息 $I(S; K)$，从而具体理解“信息泄露了 $X$ 比特”的含义。[@problem_id:3676146]", "problem": "一个在中央处理器（CPU）上运行的密码学实现存在一个缓存侧信道：在每次执行中，单次内存访问会发生缓存命中或未命中。以秘密 $S \\in \\{s_{0}, s_{1}\\}$ 为条件，每次运行中的未命中事件被建模为一个独立的伯努利随机变量，其参数为 $p(S)$，其中 $p(s_{0}) = 0.2$ 且 $p(s_{1}) = 0.8$。秘密的先验概率是均匀的，因此 $P(S = s_{0}) = P(S = s_{1}) = 0.5$。攻击者在固定的 $S$ 下执行该实现 $n = 3$ 次，并只观察到这些运行中未命中的总次数 $K \\in \\{0,1,2,3\\}$（而非其发生的顺序）。\n\n从香Shannon熵和互信息以2为底的基本定义出发，并仅使用给定的独立性和伯努利模型假设，推导秘密 $S$ 和可观察量 $K$ 之间的互信息（以比特为单位），即计算此模型的 $I(S; K)$。将最终数值以比特表示，并四舍五入到四位有效数字。", "solution": "秘密 $S$ 和可观察量 $K$ 之间的互信息 $I(S; K)$ 衡量了在观察到 $K$ 之后关于 $S$ 的不确定性的减少量。它用香Shannon熵定义为：\n$$I(S; K) = H(S) - H(S|K)$$\n其中所有对数均以2为底，以得出以比特为单位的结果。\n\n首先，我们计算秘密的熵 $H(S)$。秘密 $S$ 在两个结果 $s_0$ 和 $s_1$ 上具有均匀的先验分布：\n$$P(S = s_0) = 0.5$$\n$$P(S = s_1) = 0.5$$\n熵 $H(S)$ 由下式给出：\n$$H(S) = -\\sum_{i \\in \\{s_0, s_1\\}} P(S=i) \\log_2(P(S=i))$$\n$$H(S) = -(0.5 \\log_2(0.5) + 0.5 \\log_2(0.5)) = - \\log_2(0.5) = - \\log_2(2^{-1}) = 1 \\text{ bit}$$\n\n接下来，我们计算条件熵 $H(S|K)$，它是在观察到 $K$ 后关于 $S$ 的平均剩余不确定性：\n$$H(S|K) = \\sum_{k=0}^{3} P(K=k) H(S|K=k)$$\n为此，我们需要确定所涉及的概率分布。\n\n在 $n=3$ 次独立运行中，以秘密 $S$ 为条件的未命中次数 $K$ 服从二项分布。设 $p_0 = p(s_0) = 0.2$ 和 $p_1 = p(s_1) = 0.8$。\n条件概率 $P(K=k | S=s_i)$ 由二项概率质量函数给出，$P(K=k) = \\binom{n}{k} p^k (1-p)^{n-k}$。\n\n对于 $S=s_0$，其中 $p=p_0=0.2$ 且 $n=3$：\n-   $P(K=0|S=s_0) = \\binom{3}{0}(0.2)^0(0.8)^3 = 1 \\cdot 1 \\cdot 0.512 = 0.512$\n-   $P(K=1|S=s_0) = \\binom{3}{1}(0.2)^1(0.8)^2 = 3 \\cdot 0.2 \\cdot 0.64 = 0.384$\n-   $P(K=2|S=s_0) = \\binom{3}{2}(0.2)^2(0.8)^1 = 3 \\cdot 0.04 \\cdot 0.8 = 0.096$\n-   $P(K=3|S=s_0) = \\binom{3}{3}(0.2)^3(0.8)^0 = 1 \\cdot 0.008 \\cdot 1 = 0.008$\n\n对于 $S=s_1$，其中 $p=p_1=0.8$ 且 $n=3$：\n-   $P(K=0|S=s_1) = \\binom{3}{0}(0.8)^0(0.2)^3 = 1 \\cdot 1 \\cdot 0.008 = 0.008$\n-   $P(K=1|S=s_1) = \\binom{3}{1}(0.8)^1(0.2)^2 = 3 \\cdot 0.8 \\cdot 0.04 = 0.096$\n-   $P(K=2|S=s_1) = \\binom{3}{2}(0.8)^2(0.2)^1 = 3 \\cdot 0.64 \\cdot 0.2 = 0.384$\n-   $P(K=3|S=s_1) = \\binom{3}{3}(0.8)^3(0.2)^0 = 1 \\cdot 0.512 \\cdot 1 = 0.512$\n\n使用全概率定律，我们求出边际概率 $P(K=k)$：\n$P(K=k) = P(K=k|S=s_0)P(S=s_0) + P(K=k|S=s_1)P(S=s_1)$\n因为 $P(S=s_0) = P(S=s_1) = 0.5$：\n-   $P(K=0) = 0.5(0.512) + 0.5(0.008) = 0.256 + 0.004 = 0.260$\n-   $P(K=1) = 0.5(0.384) + 0.5(0.096) = 0.192 + 0.048 = 0.240$\n-   $P(K=2) = 0.5(0.096) + 0.5(0.384) = 0.048 + 0.192 = 0.240$\n-   $P(K=3) = 0.5(0.008) + 0.5(0.512) = 0.004 + 0.256 = 0.260$\n\n接下来，我们使用贝叶斯定理求出后验概率 $P(S=s_i|K=k)$：\n$P(S=s_i|K=k) = \\frac{P(K=k|S=s_i)P(S=s_i)}{P(K=k)}$\n-   对于 $k=0$：\n    $P(S=s_0|K=0) = \\frac{0.5 \\cdot 0.512}{0.260} = \\frac{0.256}{0.260} = \\frac{64}{65}$。因此 $P(S=s_1|K=0) = 1 - \\frac{64}{65} = \\frac{1}{65}$。\n-   对于 $k=1$：\n    $P(S=s_0|K=1) = \\frac{0.5 \\cdot 0.384}{0.240} = \\frac{0.192}{0.240} = 0.8 = \\frac{4}{5}$。因此 $P(S=s_1|K=1) = 0.2 = \\frac{1}{5}$。\n-   对于 $k=2$：\n    $P(S=s_0|K=2) = \\frac{0.5 \\cdot 0.096}{0.240} = \\frac{0.048}{0.240} = 0.2 = \\frac{1}{5}$。因此 $P(S=s_1|K=2) = 0.8 = \\frac{4}{5}$。\n-   对于 $k=3$：\n    $P(S=s_0|K=3) = \\frac{0.5 \\cdot 0.008}{0.260} = \\frac{0.004}{0.260} = \\frac{1}{65}$。因此 $P(S=s_1|K=3) = \\frac{64}{65}$。\n\n现在我们可以为每个 $k$ 计算条件熵 $H(S|K=k)$。我们使用二元熵函数 $h_2(p) = -p \\log_2(p) - (1-p) \\log_2(1-p)$。\n-   $H(S|K=0) = h_2(\\frac{1}{65})$\n-   $H(S|K=1) = h_2(\\frac{1}{5})$\n-   $H(S|K=2) = h_2(\\frac{1}{5})$\n-   $H(S|K=3) = h_2(\\frac{1}{65})$\n\n我们将这些结合起来求 $H(S|K)$：\n$$H(S|K) = P(K=0)H(S|K=0) + P(K=1)H(S|K=1) + P(K=2)H(S|K=2) + P(K=3)H(S|K=3)$$\n由于对称性（$P(K=0)=P(K=3)$ 和 $H(S|K=0)=H(S|K=3)$ 等），这可以简化为：\n$$H(S|K) = 2 P(K=0) H(S|K=0) + 2 P(K=1) H(S|K=1)$$\n$$H(S|K) = 2(0.260) h_2(\\frac{1}{65}) + 2(0.240) h_2(\\frac{1}{5})$$\n$$H(S|K) = 0.52 \\cdot h_2(\\frac{1}{65}) + 0.48 \\cdot h_2(\\frac{1}{5})$$\n\n现在，我们计算二元熵函数的数值：\n$$h_2(\\frac{1}{5}) = -(\\frac{1}{5}\\log_2(\\frac{1}{5}) + \\frac{4}{5}\\log_2(\\frac{4}{5})) \\approx - (0.2(-2.321928) + 0.8(-0.321928)) \\approx 0.721928 \\text{ bits}$$\n$$h_2(\\frac{1}{65}) = -(\\frac{1}{65}\\log_2(\\frac{1}{65}) + \\frac{64}{65}\\log_2(\\frac{64}{65})) \\approx - (\\frac{1}{65}(-6.022369) + \\frac{64}{65}(-0.022369)) \\approx 0.114712 \\text{ bits}$$\n将这些值代回 $H(S|K)$ 的表达式中：\n$$H(S|K) \\approx 0.52(0.114712) + 0.48(0.721928)$$\n$$H(S|K) \\approx 0.059650 + 0.346525 = 0.406175 \\text{ bits}$$\n\n最后，我们计算互信息：\n$$I(S; K) = H(S) - H(S|K) \\approx 1 - 0.406175 = 0.593825 \\text{ bits}$$\n将结果四舍五入到四位有效数字得到 $0.5938$。", "answer": "$$\\boxed{0.5938}$$", "id": "3676146"}]}