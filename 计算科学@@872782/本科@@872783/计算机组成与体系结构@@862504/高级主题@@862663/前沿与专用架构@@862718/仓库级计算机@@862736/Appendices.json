{"hands_on_practices": [{"introduction": "现代大规模服务通常由许多相互协作的微服务构成。要理解这类系统的端到端性能，首先需要分析它们之间的依赖关系。本练习将一个微服务系统建模为一个有向无环图（DAG），旨在训练你识别决定整体延迟的关键路径的核心技能，这是性能分析和优化的第一步。[@problem_id:3688299]", "problem": "一个仓库级计算机 (WSC) 中的微服务部署被建模为一个有向无环图 (DAG)，其节点集为 $V = \\{A,B,C,D,E,F\\}$，边集为 $E = \\{(A,B),(A,C),(B,D),(B,E),(C,F)\\}$。每个节点 $i \\in V$ 代表一个微服务，该微服务在被调用时，会执行时长为 $t_i$ 的本地处理，然后，如果它有出边，则会并发地向所有直接后继节点发出调用，并等待所有这些调用完成后才返回。假设每个节点的处理时间（单位：毫秒）如下：$t_A = 12$, $t_B = 8$, $t_C = 15$, $t_D = 40$, $t_E = 20$, $t_F = 30$。调用扇出分别为 $f_A = 2$, $f_B = 2$, $f_C = 1$, 以及 $f_D = f_E = f_F = 0$。该 DAG 的根节点是 $A$，叶节点是 $D$、$E$ 和 $F$。假设网络延迟可忽略不计，且资源充足，因此所有并行调用运行时没有排队干扰。\n\n请仅使用适用于计算机组成与体系结构中并行组合性能建模的第一性原理——即并发发出独立调用并等待所有调用完成，所产生的有效下游等待时间等于各分支完成时间的最大值——来推导从根节点 $A$ 开始到完成的端到端延迟。然后，在假设存在唯一的关键路径，且单个 $t_i$ 的无穷小减少不会改变该路径的构成的前提下，确定灵敏度向量 $\\mathbf{s}$。其中，分量 $s_i$ 等于 $t_i$ 每减少一个单位，根节点 $A$ 的端到端延迟的一阶变化量，其中 $i$ 的顺序为 $(A,B,C,D,E,F)$。报告的延迟需四舍五入到四位有效数字，并以毫秒为单位表示。您的最终答案必须是一个单行矩阵，其第一个条目是延迟值，其余条目是按 $(A,B,C,D,E,F)$ 顺序排列的 $\\mathbf{s}$ 的六个分量。", "solution": "用户要求我解决一个关于仓库级计算机 (WSC) 中微服务部署的性能建模问题。\n\n### 第一步：问题验证\n\n首先，我必须验证问题陈述的有效性。\n\n#### 步骤 1.1：提取给定条件\n- **节点集**：$V = \\{A,B,C,D,E,F\\}$。\n- **边集**：$E = \\{(A,B),(A,C),(B,D),(B,E),(C,F)\\}$，表示一个有向无环图 (DAG)。\n- **执行模型**：节点 $i$ 执行时长为 $t_i$ 的本地处理。如果它有后继节点，它会并发调用它们，并等待所有调用完成。一个节点的总延迟是其本地处理时间加上等待其下游调用的时间。\n- **下游等待原则**：并发调用的等待时间是并行分支完成时间的最大值。\n- **节点处理时间（单位：毫秒）**：$t_A = 12$, $t_B = 8$, $t_C = 15$, $t_D = 40$, $t_E = 20$, $t_F = 30$。\n- **图结构**：根节点是 $A$；叶节点是 $D$、$E$ 和 $F$。\n- **假设**：网络延迟可忽略。资源充足，因此不会发生排队干扰。存在唯一的关键路径，且单个 $t_i$ 的无穷小减少不会改变其构成。\n- **任务**：\n  1. 推导从根节点 $A$ 开始的端到端延迟。\n  2. 确定灵敏度向量 $\\mathbf{s} = (s_A, s_B, s_C, s_D, s_E, s_F)$，其中 $s_i$ 是端到端延迟相对于 $t_i$ 每减少一个单位的一阶变化量。\n- **报告格式**：\n  1. 延迟必须四舍五入到四位有效数字，并以毫秒为单位表示。\n  2. 最终答案是一个单行矩阵，包含延迟值和 $\\mathbf{s}$ 的六个分量。\n\n#### 步骤 1.2：使用提取的给定条件进行验证\n- **科学依据**：该问题在并行与分布式系统的性能分析原理方面有坚实的基础，这是计算机组成与体系结构的核心课题。使用 DAG 建模依赖关系和使用关键路径法寻找延迟是标准技术。\n- **适定性**：该问题是适定的。图、处理时间以及计算规则都已明确给出，可以得到唯一的延迟和灵敏度解。\n- **客观性**：问题陈述是客观、定量的，没有主观或模糊的语言，除了“灵敏度”的措辞略有含糊，这将在解决方案中通过基于学科惯例的合理解释来解决。\n- **缺陷分析**：\n  - 问题没有违反科学原理。\n  - 它是可形式化的，并且与指定领域直接相关。\n  - 给定条件是完整且一致的。扇出数据虽然是多余的，但与提供的边集相匹配。\n  - 假设（例如，可忽略的延迟）是一阶建模中的标准简化，不会使问题无效。\n  - 结构保证了唯一、稳定的解。\n\n#### 步骤 1.3：结论与行动\n问题是有效的。我现在将进行完整解答。\n\n### 第二步：求解推导\n\n#### 第一部分：端到端延迟计算\n\n服务调用图的端到端延迟由关键路径决定，关键路径是图中从根节点到叶节点的总执行时间最长的路径。设 $L(i)$ 为以节点 $i$ 为根的子图的总延迟。根据问题描述，这可以递归地定义。\n\n对于任何叶节点 $i$（没有后继节点的节点），其延迟就是其自身的处理时间：\n$$L(i) = t_i$$\n\n对于任何非叶节点 $i$，其延迟是其自身的处理时间加上其后继分支延迟的最大值，因为调用是并发的，并且该节点必须等待所有调用完成：\n$$L(i) = t_i + \\max_{j \\in \\text{succ}(i)} \\{L(j)\\}$$\n其中 $\\text{succ}(i)$ 是节点 $i$ 的直接后继节点集合。\n\n我们通过从 DAG 的叶节点 $D$、$E$ 和 $F$ 开始反向计算来求解延迟。\n\n1.  **叶节点的延迟**：\n    $L(D) = t_D = 40 \\, \\text{ms}$\n    $L(E) = t_E = 20 \\, \\text{ms}$\n    $L(F) = t_F = 30 \\, \\text{ms}$\n\n2.  **内部节点的延迟**：\n    -   节点 $C$ 有一个后继节点 $F$。\n        $$L(C) = t_C + L(F) = 15 + 30 = 45 \\, \\text{ms}$$\n    -   节点 $B$ 有两个后继节点 $D$ 和 $E$。\n        $$L(B) = t_B + \\max\\{L(D), L(E)\\} = 8 + \\max\\{40, 20\\} = 8 + 40 = 48 \\, \\text{ms}$$\n\n3.  **根节点的延迟**：\n    -   节点 $A$ 有两个后继节点 $B$ 和 $C$。端到端延迟为 $L(A)$。\n        $$L(A) = t_A + \\max\\{L(B), L(C)\\} = 12 + \\max\\{48, 45\\} = 12 + 48 = 60 \\, \\text{ms}$$\n\n端到端延迟为 $60 \\, \\text{ms}$。问题要求此值四舍五入到四位有效数字，即 $60.00 \\, \\text{ms}$。\n\n#### 第二部分：灵敏度向量计算\n\n灵敏度 $s_i$ 被定义为“$t_i$ 每减少一个单位，根节点 $A$ 的端到端延迟的一阶变化量”。设总延迟为 $L_{total} = L(A)$。由 $t_i$ 的一个微小变化 $\\Delta t_i$ 引起的一阶总延迟变化 $\\Delta L_{total}$ 由 $\\Delta L_{total} \\approx \\frac{\\partial L_{total}}{\\partial t_i} \\Delta t_i$ 给出。对于“$t_i$ 减少一个单位”，我们有 $\\Delta t_i = -1$。因此，变化量为 $-\\frac{\\partial L_{total}}{\\partial t_i}$。\n\n在性能工程中，将灵敏度定义为直接的偏导数 $\\frac{\\partial L_{total}}{\\partial t_i}$ 是一种标准惯例，它表示总延迟相对于某个组件延迟的变化率。该值为非负数，表示影响的大小。我们将采用此标准定义，即 $s_i = \\frac{\\partial L_{total}}{\\partial t_i}$。$s_i=1$ 表示 $t_i$ 的变化会导致 $L_{total}$ 发生相同的变化，而 $s_i=0$ 表示 $t_i$ 的变化对 $L_{total}$ 没有一阶影响。\n\n为了计算这些导数，我们首先确定关键路径。关键路径是在每个分叉点决定最大值的节点序列：\n- 在节点 $A$ 处，选择了通过 $B$ 的分支，因为 $L(B) = 48  L(C) = 45$。\n- 在节点 $B$ 处，选择了通过 $D$ 的分支，因为 $L(D) = 40  L(E) = 20$。\n因此，唯一的关键路径是 $A \\rightarrow B \\rightarrow D$。\n\n问题陈述指出，我们可以假设无穷小的变化不会改变关键路径。这使我们能够将总延迟 $L_{total}$ 表示为该关键路径上节点处理时间的简单总和：\n$$L_{total}(t_A, t_B, t_C, t_D, t_E, t_F) = t_A + t_B + t_D$$\n\n现在我们可以为每个节点 $i \\in V$ 计算灵敏度分量 $s_i = \\frac{\\partial L_{total}}{\\partial t_i}$：\n\n-   $s_A = \\frac{\\partial}{\\partial t_A}(t_A + t_B + t_D) = 1$\n-   $s_B = \\frac{\\partial}{\\partial t_B}(t_A + t_B + t_D) = 1$\n-   $s_C = \\frac{\\partial}{\\partial t_C}(t_A + t_B + t_D) = 0$ (节点 $C$ 不在关键路径上)\n-   $s_D = \\frac{\\partial}{\\partial t_D}(t_A + t_B + t_D) = 1$\n-   $s_E = \\frac{\\partial}{\\partial t_E}(t_A + t_B + t_D) = 0$ (节点 $E$ 不在关键路径上)\n-   $s_F = \\frac{\\partial}{\\partial t_F}(t_A + t_B + t_D) = 0$ (节点 $F$ 不在关键路径上)\n\n因此，灵敏度向量 $\\mathbf{s}$，其分量按 $(A,B,C,D,E,F)$ 顺序排列，为：\n$$\\mathbf{s} = (1, 1, 0, 1, 0, 0)$$\n\n#### 第三部分：最终答案构建\n\n最终答案必须是一个单行矩阵，包含延迟（四舍五入到四位有效数字）和灵敏度向量 $\\mathbf{s}$ 的六个分量。\n\n-   延迟：$60.00$\n-   灵敏度向量：$(1, 1, 0, 1, 0, 0)$\n\n最终矩阵为 $(60.00, 1, 1, 0, 1, 0, 0)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n60.00  1  1  0  1  0  0\n\\end{pmatrix}\n}\n$$", "id": "3688299"}, {"introduction": "在确定了系统的关键组件后，我们需要为它们分配合理的计算资源。然而，现实世界中的请求负载是动态变化的，这可能导致请求排队，从而影响用户体验。本练习将引导你应用排队论中的$M/M/k$模型，来量化分析请求到达率、服务能力和等待时间之间的关系，从而为服务层分配合适的资源以满足服务等级目标（SLO）。[@problem_id:3688262]", "problem": "一个仓库级计算机 (WSC) 运行一个微服务层，该层接收外部请求并将其分派给一个由相同的中央处理器 (CPU) 核心组成的池。为了对容量规划进行推理，请使用以下科学标准假设：请求到达形成一个泊松过程，速率为每秒 $\\lambda$ 个请求；任何给定核心上的单个服务时间是独立的，并服从指数分布，每个核心的平均服务速率为每秒 $\\mu$ 个请求；核心在先到先服务 (FCFS) 调度下为请求提供服务。在这些条件下，通用请求通道可以建模为一个 $\\mathrm{M}/\\mathrm{M}/k$ 排队，其中 $k$ 是活动的通用核心数量。\n\nWSC 对预期排队延迟 $W_q$ 强制执行服务水平目标 (SLO)，$W_q$ 定义为请求在服务开始前在队列中等待的预期时间（不包括服务时间）。SLO 要求 $W_q \\leq W_0$，其中 $W_0$ 是一个指定的上限，单位为秒。\n\n基线配置：\n- 到达速率为 $\\lambda = 800$ 请求/秒。\n- 每个通用核心的平均服务速率为 $\\mu = 150$ 请求/秒。\n- SLO 上限为 $W_0 = 0.040$ 秒。\n\n专用快速通道配置：\n- 一部分比例为 $p = 0.25$ 的到达请求被识别为简单请求，并被路由到一个由专用加速器组成的独立池（快速通道），剩下的 $(1-p)$ 的到达请求留给通用核心。\n- 有 $m = 2$ 个相同的加速器，每个加速器的平均服务速率为 $\\mu_s = 500$ 请求/秒。\n- 通用池仍然是一个 $\\mathrm{M}/\\mathrm{M}/k$ 排队，为剩余的到达请求服务，而快速通道则形成一个 $\\mathrm{M}/\\mathrm{M}/m$ 排队，为分流的到达请求服务。\n- SLO 要求两个通道都必须单独满足 $W_q \\leq W_0$。\n\n仅使用上述假设和定义，确定：\n1. 在基线配置中，为使预期排队延迟满足 $W_q \\leq W_0$ 所需的最小整数通用核心数 $k_{\\mathrm{base}}$。\n2. 在专用快速通道配置中，为使通用通道和快速通道都单独满足 $W_q \\leq W_0$ 所需的最小整数通用核心数 $k_{\\mathrm{spec}}$。\n\n最后，计算因专用快速通道而减少的通用核心数，定义为 $\\Delta k = k_{\\mathrm{base}} - k_{\\mathrm{spec}}$。请将您的最终答案表示为单个整数。在您的推理中，所有中间量的时间单位必须是秒，速率单位必须是请求/秒。最终整数无需舍入说明。", "solution": "问题陈述已经过验证，被认为是具有科学依据、提法明确且客观的。它使用已建立的排队论原理，提出了一个计算机系统架构中标准的性能分析场景。所有必要的参数均已提供，问题没有矛盾或含糊之处。\n\n该问题需要分析两个基于 $\\mathrm{M}/\\mathrm{M}/k$ 模型的排队系统。一个 $\\mathrm{M}/\\mathrm{M}/k$ 排队模型用于描述一个具有泊松到达（第一个 M）、指数服务时间（第二个 M）和 $k$ 个并行服务器的系统。分析此类系统的核心公式是：\n1.  服务负载 $A$ 是到达速率 $\\lambda$ 与单个服务器服务速率 $\\mu$ 的比值：$A = \\frac{\\lambda}{\\mu}$。这表示在有无限多服务器的情况下，预期的繁忙服务器数量。\n2.  仅当总服务能力超过到达速率时，系统才是稳定的，即 $k\\mu  \\lambda$。这等同于流量强度 $\\rho = \\frac{\\lambda}{k\\mu} = \\frac{A}{k}$ 必须小于 1 的条件。\n3.  一个到达的请求必须在队列中等待的概率 $P_q$ 由爱尔兰C公式给出，记为 $C(k, A)$:\n    $$P_q = C(k, A) = \\frac{\\frac{A^k}{k!(1-\\rho)}}{\\sum_{n=0}^{k-1} \\frac{A^n}{n!} + \\frac{A^k}{k!(1-\\rho)}}$$\n4.  预期排队延迟 $W_q$ 可以使用排队概率计算得出：\n    $$W_q = \\frac{P_q}{k\\mu - \\lambda}$$\n    为使系统可行，我们必须找到最小的整数 $k$，使得稳定性条件得到满足，并且服务水平目标 (SLO) $W_q \\leq W_0$ 得到满足。\n\n**1. 确定基线配置所需的最小核心数 $k_{\\mathrm{base}}$**\n\n在基线配置中，我们有：\n-   到达速率：$\\lambda = 800$ 请求/秒。\n-   每个核心的平均服务速率：$\\mu = 150$ 请求/秒。\n-   SLO 上限：$W_0 = 0.040$ 秒。\n\n首先，我们确定维持稳定性所需的最小核心数：\n$k \\mu  \\lambda \\implies k \\times 150  800 \\implies k  \\frac{800}{150} = \\frac{16}{3} \\approx 5.333$。\n确保稳定性的最小整数核心数是 $k=6$。\n\n现在，我们必须验证 $k=6$ 是否满足 SLO，$W_q \\leq 0.040$ s。我们计算 $k=6$ 时的 $W_q$。\n服务负载是 $A = \\frac{\\lambda}{\\mu} = \\frac{800}{150} = \\frac{16}{3}$。\n流量强度是 $\\rho = \\frac{A}{k} = \\frac{16/3}{6} = \\frac{16}{18} = \\frac{8}{9}$。\n\n我们计算爱尔兰C公式 $C(6, 16/3)$ 的各项。\n分母中的和是：\n$$S = \\sum_{n=0}^{k-1} \\frac{A^n}{n!} = \\sum_{n=0}^{5} \\frac{(16/3)^n}{n!} = 1 + \\frac{16}{3} + \\frac{(16/3)^2}{2!} + \\frac{(16/3)^3}{3!} + \\frac{(16/3)^4}{4!} + \\frac{(16/3)^5}{5!}$$\n$$S = 1 + \\frac{16}{3} + \\frac{128}{9} + \\frac{2048}{81} + \\frac{8192}{243} + \\frac{131072}{3645} = \\frac{3645 + 19440 + 51840 + 92160 + 122880 + 131072}{3645} = \\frac{421037}{3645}$$\n公式中的排队项是：\n$$Q = \\frac{A^k}{k!(1-\\rho)} = \\frac{(16/3)^6}{6!(1 - 8/9)} = \\frac{16^6 / 3^6}{720(1/9)} = \\frac{16777216 / 729}{80} = \\frac{16777216}{58320} = \\frac{1048576}{3645}$$\n排队概率是：\n$$P_q = C(6, 16/3) = \\frac{Q}{S+Q} = \\frac{1048576/3645}{421037/3645 + 1048576/3645} = \\frac{1048576}{1469613}$$\n现在我们计算预期排队延迟 $W_q$:\n$$W_q = \\frac{P_q}{k\\mu - \\lambda} = \\frac{1048576 / 1469613}{6 \\times 150 - 800} = \\frac{1048576 / 1469613}{100} = \\frac{1048576}{146961300} \\approx 0.00714 \\text{ s}$$\n由于 $W_q \\approx 0.00714 \\text{ s} \\leq 0.040 \\text{ s}$，SLO 对于 $k=6$ 是满足的。由于对于稳定系统，$W_q$ 是 $k$ 的单调递减函数，且 $k=6$ 是满足稳定性的最小整数值，因此它也是满足 SLO 的最小核心数。\n因此，$k_{\\mathrm{base}} = 6$。\n\n**2. 确定专用配置所需的最小通用核心数 $k_{\\mathrm{spec}}$**\n\n在此配置中，流量被分流。\n\n**快速通道（加速器）：**\n一部分比例为 $p=0.25$ 的到达请求被路由到这里。\n-   到达速率：$\\lambda_s = p \\lambda = 0.25 \\times 800 = 200$ 请求/秒。\n-   服务器数量：$m=2$。\n-   每个服务器的服务速率：$\\mu_s = 500$ 请求/秒。\n-   SLO 为 $W_{q,s} \\leq W_0 = 0.040$ s。\n\n首先，检查稳定性：$m \\mu_s = 2 \\times 500 = 1000  \\lambda_s = 200$。系统是稳定的。\n服务负载：$A_s = \\lambda_s / \\mu_s = 200 / 500 = 0.4$。\n流量强度：$\\rho_s = A_s / m = 0.4 / 2 = 0.2$。\n使用 $m=2$ 的爱尔兰C公式：\n$$P_{q,s} = C(2, 0.4) = \\frac{\\frac{0.4^2}{2!(1-0.2)}}{ \\frac{0.4^0}{0!} + \\frac{0.4^1}{1!} + \\frac{0.4^2}{2!(1-0.2)}} = \\frac{\\frac{0.16}{1.6}}{1 + 0.4 + \\frac{0.16}{1.6}} = \\frac{0.1}{1.4+0.1} = \\frac{0.1}{1.5} = \\frac{1}{15}$$\n预期排队延迟是：\n$$W_{q,s} = \\frac{P_{q,s}}{m\\mu_s - \\lambda_s} = \\frac{1/15}{1000 - 200} = \\frac{1/15}{800} = \\frac{1}{12000} \\approx 0.000083 \\text{ s}$$\n由于 $W_{q,s} \\ll 0.040$ s，快速通道满足 SLO。\n\n**通用通道：**\n剩余的比例为 $(1-p) = 0.75$ 的到达请求被路由到这里。\n-   到达速率：$\\lambda_g = (1-p) \\lambda = 0.75 \\times 800 = 600$ 请求/秒。\n-   每个核心的服务速率：$\\mu = 150$ 请求/秒。\n-   核心数量为 $k_{\\mathrm{spec}}$，这是我们需要找到的。\n-   SLO 为 $W_{q,g} \\leq W_0 = 0.040$ s。\n\n稳定性要求：$k_{\\mathrm{spec}} \\mu  \\lambda_g \\implies k_{\\mathrm{spec}} \\times 150  600 \\implies k_{\\mathrm{spec}}  4$。\n维持稳定性的最小整数核心数是 $k_{\\mathrm{spec}}=5$。\n\n我们检查 $k_{\\mathrm{spec}}=5$ 是否满足 SLO。\n服务负载：$A_g = \\lambda_g / \\mu = 600 / 150 = 4$。\n流量强度：$\\rho_g = A_g / k_{\\mathrm{spec}} = 4 / 5 = 0.8$。\n\n我们计算爱尔兰C公式 $C(5, 4)$ 的各项。\n分母中的和：\n$$S_g = \\sum_{n=0}^{4} \\frac{4^n}{n!} = 1 + 4 + \\frac{4^2}{2} + \\frac{4^3}{6} + \\frac{4^4}{24} = 1 + 4 + 8 + \\frac{32}{3} + \\frac{32}{3} = 13 + \\frac{64}{3} = \\frac{103}{3}$$\n排队项：\n$$Q_g = \\frac{A_g^{k_{\\mathrm{spec}}}}{k_{\\mathrm{spec}}!(1-\\rho_g)} = \\frac{4^5}{5!(1-4/5)} = \\frac{1024}{120(1/5)} = \\frac{1024}{24} = \\frac{128}{3}$$\n排队概率：\n$$P_{q,g} = C(5, 4) = \\frac{Q_g}{S_g+Q_g} = \\frac{128/3}{103/3 + 128/3} = \\frac{128}{231}$$\n预期排队延迟是：\n$$W_{q,g} = \\frac{P_{q,g}}{k_{\\mathrm{spec}}\\mu - \\lambda_g} = \\frac{128/231}{5 \\times 150 - 600} = \\frac{128/231}{150} = \\frac{128}{34650} \\approx 0.00369 \\text{ s}$$\n由于 $W_{q,g} \\approx 0.00369 \\text{ s} \\leq 0.040 \\text{ s}$，SLO 对于 $k_{\\mathrm{spec}}=5$ 是满足的。这是满足稳定性的最小整数，因此是所需的核心数。\n因此，$k_{\\mathrm{spec}} = 5$。\n\n**3. 计算通用核心的减少量 $\\Delta k$**\n\n核心的减少量是基线需求和专用配置需求之间的差值。\n$$\\Delta k = k_{\\mathrm{base}} - k_{\\mathrm{spec}} = 6 - 5 = 1$$\n引入专用快速通道可以在满足所有 SLO 的同时，减少 1 个通用核心。", "answer": "$$\\boxed{1}$$", "id": "3688262"}, {"introduction": "许多真实世界的工作负载并非均匀分布，一小部分“热点”数据或用户可能占据了绝大部分请求，这种现象被称为“负载偏斜”。本练习将探讨一种名为“微切片”（microsharding）的高级优化技术，它通过分解热点键来缓解负载集中，但同时也会引入额外的协调开销。你需要通过数学建模来解决这个权衡问题，找到最优的切片粒度，以最小化对用户体验至关重要的尾延迟。[@problem_id:3688302]", "problem": "部署在仓库级计算机 (WSC) 中的一个大规模在线键值存储服务采用微切分技术来减轻跨键的请求偏斜。存在 $K$ 个不同的键，一个传入请求指向键 $i \\in \\{1,\\dots,K\\}$ 的概率遵循指数为 $\\zeta > 0$ 的 Zipf 分布，即 $p_i = \\frac{i^{-\\zeta}}{H_{K,\\zeta}}$，其中 $H_{K,\\zeta} = \\sum_{j=1}^{K} j^{-\\zeta}$ 是广义调和数。总请求到达过程是速率为 $\\lambda$ 请求/秒的泊松过程。为了进行微切分，每个键被平均分配到 $s$ 个相同的微分片上，因此对键 $i$ 的请求被均匀随机地分配到其 $s$ 个微分片上。每个微分片都是一个独立的服务率为 $\\mu$ 请求/秒（即平均服务时间为 $1/\\mu$）的指数服务时间的单服务器队列，服务规则是先到先服务。每个请求都会产生一个与微分片扇出成正比的确定性协调开销，建模为一个附加时间惩罚 $o s$，其中 $o$ 的单位是秒/分片。\n\n假设在偏斜情况下，尾延迟主要由最热键的微分片决定，并且端到端的 $0.99$-分位数延迟可以保守地近似为最热微分片处排队延迟的高分位数界限与确定性协调开销之和。仅使用泊松到达、指数服务和 Zipf 分布的基本性质，推导并最小化一个关于微分片数量 $s$ 的函数，该函数是 $0.99$-分位数延迟的易于处理的解析代理。将最小化此代理的 $s^\\*$ 表示为包含 $\\lambda$、$\\mu$、$o$、$K$ 和 $\\zeta$ 的闭式解析表达式。\n\n您的最终答案必须是 $s^\\*$ 的单一闭式表达式（无量纲）。不要对诸如 $\\ln(100)$ 之类的常数进行四舍五入或近似；请以精确的符号形式保留它们。最终答案中不需要单位。", "solution": "将首先根据指定标准验证问题陈述。\n\n### 第 1 步：提取已知条件\n-   不同键的数量：$K$\n-   请求键 $i$ 的概率：$p_i = \\frac{i^{-\\zeta}}{H_{K,\\zeta}}$，对于 $i \\in \\{1, \\dots, K\\}$\n-   Zipf 指数：$\\zeta  0$\n-   广义调和数：$H_{K,\\zeta} = \\sum_{j=1}^{K} j^{-\\zeta}$\n-   总请求到达过程：速率为 $\\lambda$ 的泊松过程\n-   每个键的微分片数量（扇出）：$s$\n-   每个键的请求分配：均匀随机地分配到 $s$ 个微分片上\n-   微分片模型：独立的 M/M/1 队列（单服务器，指数服务）\n-   每个微分片的服务率：$\\mu$\n-   服务规则：先到先服务\n-   协调开销：附加时间惩罚 $o \\cdot s$\n-   $o$ 的单位：秒/分片（解释为每单位扇出 $s$ 的秒数，使得 $o$ 的单位实际上是秒，以确保总延迟表达式的量纲一致性）。\n-   延迟近似：端到端的 $0.99$-分位数延迟近似为最热微分片上的排队延迟的高分位数界限与确定性协调开销之和。\n-   目标：找到最优的微分片数量 $s^*$，以最小化此延迟代理。\n\n### 第 2 步：使用提取的已知条件进行验证\n该问题有科学依据、良定且客观。它使用排队论（M/M/1 队列、泊松过程）和概率论（Zipf 分布）中的标准、无争议模型来表示大规模计算机系统 (WSC) 中一个常见的性能优化问题。该设置是分析并行性（通过增加 $s$ 来减少排队延迟）与开销（协调成本随 $s$ 增加）之间权衡的典型例子。该问题是自洽的，并提供了构建和最小化延迟函数所需的所有必要信息。使用“易于处理的解析代理”和“保守近似”的要求为应用性能建模中标准的、合理的简化（例如使用逗留时间分位数作为排队延迟分位数的上界）提供了明确的指导。该问题是可形式化的，与指定主题相关，并且不包含任何使其无效的科学缺陷、矛盾或歧义。对于 $o$ 的单位描述中的一个微小歧义，通过采用唯一能产生量纲一致模型的解释来解决，这是应用数学建模中的标准做法。\n\n### 第 3 步：结论与行动\n该问题有效。将提供一个完整、合理的解决方案。\n\n目标是找到微分片数量 $s$ 的值，以最小化 $0.99$-分位数端到端延迟的代理 $L(s)$。问题陈述指出，此延迟可以近似为两个组成部分之和：最热微分片上的排队延迟的高分位数界限 $L_{\\text{queue}}(s)$，以及协调开销 $L_{\\text{overhead}}(s)$。\n$$L(s) = L_{\\text{queue}}(s) + L_{\\text{overhead}}(s)$$\n协调开销是 $s$ 的线性函数：\n$$L_{\\text{overhead}}(s) = o \\cdot s$$\n现在，我们必须确定排队延迟部分。\n\n首先，我们识别“最热”的键。请求目标为键 $i$ 的概率是 $p_i = \\frac{i^{-\\zeta}}{H_{K,\\zeta}}$。由于指数 $\\zeta  0$，函数 $i^{-\\zeta}$ 随 $i$ 单调递减。因此，最热的键是概率最高的那个，对应于最小的索引 $i=1$。\n\n到达系统的总请求到达率是一个速率为 $\\lambda$ 的泊松过程。对键 1 的请求到达率是 $\\lambda_1$：\n$$\\lambda_1 = \\lambda \\cdot p_1 = \\lambda \\cdot \\frac{1^{-\\zeta}}{H_{K,\\zeta}} = \\frac{\\lambda}{H_{K,\\zeta}}$$\n这每秒 $\\lambda_1$ 个请求被均匀随机地分配到 $s$ 个相同的微分片上。由于泊松过程的性质，到达这 $s$ 个微分片中每一个的到达过程也是泊松过程，其速率为 $\\lambda_{\\text{shard}}$：\n$$\\lambda_{\\text{shard}} = \\frac{\\lambda_1}{s} = \\frac{\\lambda}{s H_{K,\\zeta}}$$\n每个微分片被建模为到达率为 $\\lambda_{\\text{shard}}$ 和服务率为 $\\mu$ 的 M/M/1 队列。最热键的微分片的利用率 $\\rho$ 由下式给出：\n$$\\rho(s) = \\frac{\\lambda_{\\text{shard}}}{\\mu} = \\frac{\\lambda}{s \\mu H_{K,\\zeta}}$$\n为了使队列稳定，其利用率必须小于 1，即 $\\rho  1$，这施加了约束 $s > \\frac{\\lambda}{\\mu H_{K,\\zeta}}$。\n\n接下来，我们为 $0.99$-分位数排队延迟建立一个易于处理的代理。对于一个 M/M/1 队列，在系统中的总时间（逗留时间）$T_{sys}$ 的累积分布函数由 $P(T_{sys} \\le t) = 1 - \\exp(-(\\mu-\\lambda_{\\text{shard}})t)$ 给出。逗留时间的 $p$-分位数 $t_p$ 通过求解 $P(T_{sys} \\le t_p) = p$ 得到，即 $t_p = \\frac{-\\ln(1-p)}{\\mu - \\lambda_{\\text{shard}}} = \\frac{-\\ln(1-p)}{\\mu(1-\\rho)}$。使用逗留时间分位数是排队延迟分位数的一个标准保守近似。对于 $0.99$-分位数，我们设置 $p=0.99$，因此 $1-p=0.01$。\n$$L_{\\text{queue}}(s) = \\frac{-\\ln(0.01)}{\\mu(1-\\rho(s))} = \\frac{\\ln(100)}{\\mu(1-\\rho(s))}$$\n代入 $\\rho(s)$ 的表达式：\n$$L_{\\text{queue}}(s) = \\frac{\\ln(100)}{\\mu \\left(1 - \\frac{\\lambda}{s \\mu H_{K,\\zeta}}\\right)}$$\n\n现在我们可以写出总延迟代理 $L(s)$ 的完整表达式：\n$$L(s) = \\frac{\\ln(100)}{\\mu \\left(1 - \\frac{\\lambda}{s \\mu H_{K,\\zeta}}\\right)} + o s$$\n为了简化最小化过程，我们定义一个常数 $C = \\frac{\\lambda}{\\mu H_{K,\\zeta}}$。这个常数是无量纲的，代表队列稳定性的最小扇出。延迟函数变为：\n$$L(s) = \\frac{\\ln(100)}{\\mu \\left(1 - \\frac{C}{s}\\right)} + o s = \\frac{s \\ln(100)}{\\mu (s-C)} + o s$$\n为了找到最小化 $L(s)$ 的最优扇出 $s^*$，我们计算 $L(s)$ 关于 $s$ 的导数并将其设为零。\n对第一项使用商法则：\n$$\\frac{d}{ds} \\left( \\frac{s \\ln(100)}{\\mu (s-C)} \\right) = \\frac{\\ln(100)[\\mu(s-C)] - [s \\ln(100)]\\mu}{[\\mu(s-C)]^2} = \\frac{\\mu \\ln(100)(s-C-s)}{\\mu^2 (s-C)^2} = \\frac{-C \\ln(100)}{\\mu(s-C)^2}$$\n第二项的导数就是 $o$。\n$$\\frac{dL}{ds} = \\frac{-C \\ln(100)}{\\mu(s-C)^2} + o$$\n将导数设为零以找到临界点 $s^*$：\n$$o = \\frac{C \\ln(100)}{\\mu(s^*-C)^2}$$\n$$(s^*-C)^2 = \\frac{C \\ln(100)}{o \\mu}$$\n$$s^* - C = \\sqrt{\\frac{C \\ln(100)}{o \\mu}}$$\n我们取正根，因为稳定性条件要求 $s > C$。\n$$s^* = C + \\sqrt{\\frac{C \\ln(100)}{o \\mu}}$$\n最后，我们将 $C = \\frac{\\lambda}{\\mu H_{K,\\zeta}}$ 的表达式代回，以获得以原始问题参数表示的最优扇出 $s^*$：\n$$s^* = \\frac{\\lambda}{\\mu H_{K,\\zeta}} + \\sqrt{\\frac{\\left(\\frac{\\lambda}{\\mu H_{K,\\zeta}}\\right) \\ln(100)}{o \\mu}} = \\frac{\\lambda}{\\mu H_{K,\\zeta}} + \\sqrt{\\frac{\\lambda \\ln(100)}{o \\mu^2 H_{K,\\zeta}}}$$\n为了清晰起见，可以对这个表达式进行轻微的因式分解：\n$$s^* = \\frac{\\lambda}{\\mu H_{K,\\zeta}} + \\frac{1}{\\mu} \\sqrt{\\frac{\\lambda \\ln(100)}{o H_{K,\\zeta}}}$$\n这是最小化指定延迟代理的最优微分片数量的闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\lambda}{\\mu H_{K,\\zeta}} + \\frac{1}{\\mu} \\sqrt{\\frac{\\lambda \\ln(100)}{o H_{K,\\zeta}}}}$$", "id": "3688302"}]}