{"hands_on_practices": [{"introduction": "在构建了像FIFO这样的数据缓冲模块后，下一步是建立一个可靠的机制来控制模块间的数据流动。`valid` (有效) 和 `ready` (就绪) 握手协议是流式数据处理系统中最常用的接口标准。本练习 [@problem_id:3671177] 通过剖析两种典型的设计错误，生动地揭示了不严格遵守握手协议可能导致的严重后果，例如数据丢失或重复，从而加深你对数据流控制重要性的理解。", "problem": "现场可编程门阵列 (FPGA) 上的单时钟同步流式接口通过双信号握手协议连接一个生产者和一个消费者：来自生产者的 `valid` 信号和来自消费者的 `ready` 信号。系统时钟周期为 $T$，所有寄存器在整数 $k \\ge 0$ 的时刻 $t_k = kT$ 的上升沿采样输入。标准的握手语义是：传输事件仅在满足 $valid(t_k) = 1$ 和 $ready(t_k) = 1$ 的上升沿 $t_k$ 发生，并且当 $valid = 1$ 且 $ready = 0$ 时，生产者必须保持数据总线 $D$ 稳定。假设 $D$ 是一个由生产者驱动、由消费者采样的寄存器。\n\n考虑一个包含 $N = 8$ 个不同字 $w_i$（其中 $w_i = i$，对于 $i \\in \\{0,1,\\dots,7\\}$）的突发传输，按顺序进行。在 $k = 1,2,\\dots,8$ 期间，生产者连续断言 $valid(t_k) = 1$，即在整个突发传输过程中每个时钟周期提供一个字。在从 $k = 3$ 到 $k = 5$ 的本地暂停期间，消费者撤销断言 $ready(t_k)$，即对于 $k \\in \\{3,4,5\\}$，$ready(t_k) = 0$，而在其他时间 $ready(t_k) = 1$。\n\n现在分析两种不同的违反握手协议的实现：\n\n电路 X（生产者侧违规）：生产者完全忽略消费者的 `ready` 信号（如同 `ready` 总是为 $1$），并在每个 $valid = 1$ 的周期将 $D$ 更新为下一个 $w_i$，而不考虑 `ready`。\n\n电路 Y（消费者侧违规）：生产者遵守正确的握手语义，在 $valid = 1$ 且 $ready = 0$ 时保持 $D$ 不变，但消费者的输入寄存器被错误地实现为“如果 `valid` 则采样 $D$”，即消费者在每个 $valid = 1$ 的周期都采样 $D$，而不考虑 `ready`。\n\n使用上述关于同步采样和握手语义的基本定义，确定每种电路在消费者处可观察到的后果。哪些陈述是正确的？\n\nA. 在电路 X 中，消费者最终存储 $w_0, w_1, w_5, w_6, w_7$；字 $w_2, w_3, w_4$ 丢失了。\n\nB. 在电路 X 中，由于 $valid = 1$ 持续为真，没有数据丢失；消费者最终将捕获所有 $8$ 个字。\n\nC. 在电路 Y 中，发生数据重复：在暂停窗口期间，由于 $D$ 在 $valid = 1$ 时保持不变，消费者多次记录了同一个字。\n\nD. 在电路 Y 中，在单时钟同步域中不可能发生重复；只有可能发生丢失。", "solution": "首先将验证问题陈述的科学合理性、一致性和完整性。\n\n### 步骤 1：提取已知条件\n- **系统：** FPGA 上的单时钟同步流式接口。\n- **时钟：** 所有寄存器在周期为 $T$ 的时钟上升沿采样输入。采样时间为 $t_k = kT$，其中 $k$ 为整数且 $k \\ge 0$。\n- **握手信号：**\n    - `valid`：从生产者到消费者。\n    - `ready`：从消费者到生产者。\n- **标准握手语义：**\n    - 传输事件当且仅当在 $valid(t_k) = 1$ 和 $ready(t_k) = 1$ 的上升沿 $t_k$ 发生。\n    - 当 $valid = 1$ 且 $ready = 0$ 时，生产者必须保持数据总线 $D$ 稳定。\n- **数据总线：** $D$ 是一个由生产者驱动、由消费者采样的寄存器。\n- **数据突发：** 一个包含 $N = 8$ 个不同字 $w_i = i$（其中 $i \\in \\{0, 1, \\dots, 7\\}$）的序列，按顺序传输。\n- **生产者时序（`valid` 信号）：** 对于 $k \\in \\{1, 2, \\dots, 8\\}$，$valid(t_k) = 1$。\n- **消费者时序（`ready` 信号）：** 对于 $k \\in \\{3, 4, 5\\}$，$ready(t_k) = 0$，对于所有其他 $k$，$ready(t_k) = 1$。\n- **电路 X（生产者违规）：** 生产者忽略 `ready`。在每个 $valid=1$ 的周期，它将 $D$ 更新为下一个字 $w_i$。\n- **电路 Y（消费者违规）：** 生产者正确遵守握手协议。消费者的输入寄存器在每个 $valid(t_k) = 1$ 的时钟周期 $k$ 采样 $D$，忽略 `ready`。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n- **科学上是否成立：** 是。该问题描述了一个标准的 `valid`/`ready` 握手协议，这是数字逻辑设计、计算机体系结构中的一个基本概念，尤其与基于 FPGA 的系统相关。所描述的故障模式（忽略 `ready`，不正确的采样条件）是常见的设计错误。\n- **是否适定：** 是。所有信号（`valid`, `ready`）、组件（生产者，消费者）和数据（`D`）的行为在两种不同场景（电路 X 和电路 Y）中都有明确定义。给出了初始条件和信号波形，可以为每个电路推导出唯一的、确定性的结果。\n- **是否客观：** 是。语言是技术性的且无歧义。术语如“上升沿”、“寄存器”、“断言”和“撤销断言”在此上下文中具有精确的含义。\n\n该问题没有表现出任何使其无效的缺陷：\n1.  **科学上不合理：** 无。它遵循同步数字逻辑的原理。\n2.  **不可形式化：** 无。该问题是数字电路行为的一个形式化模型。\n3.  **不完整/矛盾：** 无。信号时序和行为规则已完全指定。\n4.  **不切实际：** 无。这些场景代表了可能的设计缺陷。\n5.  **不适定：** 无。通过逐周期分析可以确定唯一的解。\n6.  **微不足道/同义反复：** 无。该问题需要对时序和状态进行仔细的、非平凡的分析。\n7.  **无法验证：** 无。所描述的行为可以使用标准硬件描述语言（例如，Verilog，VHDL）进行建模和仿真。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将对每个电路进行逐步分析，以确定在消费者端的后果。\n\n### 推导与分析\n\n电路 X 和电路 Y 都需要进行逐周期分析。相关的时间步是 $k \\ge 1$ 时 $t_k$ 的上升沿。生产者试图发送序列 $w_0, w_1, ..., w_7$。根据问题陈述，字 $w_i$ 在周期 $k=i+1$ 被首次提供。\n\n输入信号波形如下：\n- $valid(t_k) = 1$ 对于 $k \\in \\{1, 2, 3, 4, 5, 6, 7, 8\\}$，否则为 $0$。\n- $ready(t_k) = 1$ 对于 $k \\in \\{1, 2, 6, 7, 8, \\dots\\}$，而对于 $k \\in \\{3, 4, 5\\}$ 为 $0$。\n\n#### 电路 X 的分析（生产者侧违规）\n- **生产者行为：** 忽略 `ready`。在每个周期 $k \\in \\{1, ..., 8\\}$，它将下一个字 $w_{k-1}$ 放到数据总线 $D$ 上。\n- **消费者行为：** 仅在 $valid(t_k) = 1$ 且 $ready(t_k) = 1$ 的上升沿 $t_k$ 正确采样 $D$。\n\n下表追踪了电路 X 的接口状态。“传输”发生在消费者采样数据时。\n\n| 周期 $k$ | 总线上的字 $D(t_k)$ | $valid(t_k)$ | $ready(t_k)$ | 传输？ ($valid \\land ready$) | 消费者存储的字 |\n| :---: | :---: | :---: | :---: | :---: | :---: |\n| $1$ | $w_0$ | $1$ | $1$ | **是** | $w_0$ |\n| $2$ | $w_1$ | $1$ | $1$ | **是** | $w_1$ |\n| $3$ | $w_2$ | $1$ | $0$ | 否 | -- |\n| $4$ | $w_3$ | $1$ | $0$ | 否 | -- |\n| $5$ | $w_4$ | $1$ | $0$ | 否 | -- |\n| $6$ | $w_5$ | $1$ | $1$ | **是** | $w_5$ |\n| $7$ | $w_6$ | $1$ | $1$ | **是** | $w_6$ |\n| $8$ | $w_7$ | $1$ | $1$ | **是** | $w_7$ |\n\n**电路 X 的结论：** 消费者存储了字的序列：$w_0, w_1, w_5, w_6, w_7$。在消费者暂停期间（$k=3, 4, 5$），不合规的生产者继续用 $w_2, w_3, w_4$ 更新数据总线。由于消费者未准备好，它没有采样这些字。当消费者在 $t_6$ 再次准备好时，生产者已经转而提供 $w_5$。因此，字 $w_2, w_3, w_4$ 被永久丢失。\n\n#### 电路 Y 的分析（消费者侧违规）\n- **生产者行为：** 合规。它仅在成功传输（`valid`$=1$ 且 `ready`$=1$）后才前进到下一个数据字。如果 `valid`$=1$ 但 `ready`$=0$，它会在总线 $D$ 上保持当前的数据字。设 $p_{ptr}$ 为生产者当前提供的字的索引。\n- **消费者行为：** 不正确。它在每个 $valid(t_k) = 1$ 的上升沿 $t_k$ 采样 $D$，忽略 `ready`。\n\n下表追踪了电路 Y 的状态。`Trans_prev` 指示前一个周期是否发生了有效传输，这决定了生产者是否推进其数据指针。\n\n| 周期 $k$ | `Trans_prev`? | $p_{ptr}$ | 总线上的字 $D(t_k)$ | $valid(t_k)$ | $ready(t_k)$ | 消费者采样？ (`valid`$=1$) | 消费者存储的字 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| $1$ | -- | $0$ | $w_0$ | $1$ | $1$ | **是** | $w_0$ |\n| $2$ | 是 | $1$ | $w_1$ | $1$ | $1$ | **是** | $w_1$ |\n| $3$ | 是 | $2$ | $w_2$ | $1$ | $0$ | **是** | $w_2$ |\n| $4$ | 否 | $2$ | $w_2$ | $1$ | $0$ | **是** | $w_2$ (重复) |\n| $5$ | 否 | $2$ | $w_2$ | $1$ | $0$ | **是** | $w_2$ (重复) |\n| $6$ | 否 | $2$ | $w_2$ | $1$ | $1$ | **是** | $w_2$ (重复) |\n| $7$ | 是 | $3$ | $w_3$ | $1$ | $1$ | **是** | $w_3$ |\n| $8$ | 是 | $4$ | $w_4$ | $1$ | $1$ | **是** | $w_4$ |\n\n**电路 Y 的结论：** 消费者存储了序列 $w_0, w_1, w_2, w_2, w_2, w_2, w_3, w_4$。\n- 在 $t_3$，消费者未准备好（`ready`$=0$）。合规的生产者正确地将数据 $w_2$ 保持在总线上，用于后续周期（$t_4, t_5, t_6$），直到在 $t_6$ 确认传输。\n- 然而，有故障的消费者忽略 `ready`，并在每个 `valid`$=1$ 的周期继续采样。由于在 $k=3, 4, 5, 6$ 时 `valid`$=1$，消费者总共采样了四次被保持的数据 $w_2$。这导致了数据重复。\n- 此外，由于生产者被额外暂停了 $3$ 个周期（$t_4, t_5, t_6$ 被 $w_2$ 消耗），到 $t_8$ 之后 `valid` 信号撤销断言时，它只来得及传输到 $w_4$。字 $w_5, w_6, w_7$ 从未被传输。\n\n### 逐项评估\n\n- **A. 在电路 X 中，消费者最终存储 $w_0, w_1, w_5, w_6, w_7$；字 $w_2, w_3, w_4$ 丢失了。**\n  - 我们对电路 X 的分析表明，消费者捕获了字集 {$w_0, w_1, w_5, w_6, w_7$}，并且 {$w_2, w_3, w_4$} 确实丢失了。该陈述是对结果的精确描述。\n  - **结论：正确。**\n\n- **B. 在电路 X 中，由于 $valid = 1$ 持续为真，没有数据丢失；消费者最终将捕获所有 $8$ 个字。**\n  - 我们对电路 X 的分析清楚地显示了数据丢失。生产者未能等待 `ready` 导致它覆盖了消费者尚未采样的数据。\n  - **结论：不正确。**\n\n- **C. 在电路 Y 中，发生数据重复：在暂停窗口期间，由于 $D$ 在 $valid = 1$ 时保持不变，消费者多次记录了同一个字。**\n  - 我们对电路 Y 的分析表明，字 $w_2$ 被记录了四次。这正是因为合规的生产者由于消费者暂停（`ready`$=0$）而将 $D$ 上的数据 $w_2$ 保持不变，而有故障的消费者则因为 `valid`$=1$ 而继续采样。该陈述准确地描述了故障的机制。\n  - **结论：正确。**\n\n- **D. 在电路 Y 中，在单时钟同步域中不可能发生重复；只有可能发生丢失。**\n  - 这是一个错误的普遍性论断。我们对电路 Y 的具体分析表明，在这种同步系统中，数据重复是这种特定故障模式的直接且必然的结果。当消费者基于不完整的握手条件（例如，仅 `valid`）进行采样时，重复是一个典型问题。\n  - **结论：不正确。**", "answer": "$$\\boxed{AC}$$", "id": "3671177"}, {"introduction": "许多FPGA设计的最终目标是加速计算密集型任务。这需要将算法有效地映射到FPGA的基本逻辑单元——查找表（LUT）上，而延迟是衡量其性能的关键指标。本练习 [@problem_id:3671168] 以一个内容可寻址过滤器为例，教你如何在实现前分析组合逻辑电路的性能，通过计算关键路径延迟来预估设计的运行速度，并理解其如何随问题规模扩展。", "problem": "您正在现场可编程门阵列（FPGA）上设计一个简单的内容可寻址过滤器，以检测$N$条存储的规则中是否有任何一条与传入的数据包头匹配。每条规则是在宽度为$W$位的数据包头上进行掩码相等匹配，其中，如果掩码位$m_i$为1（无关位）或数据位$x_i$等于存储位$p_i$，则第$i$位匹配。一条规则的整体匹配要求所有$W$位都匹配，并且如果$N$条规则中任何一条匹配，则过滤器的输出为有效。\n\n实现必须仅使用查找表（LUT），具体如下：\n- FPGA结构提供6输入查找表（LUT），每个LUT可实现最多6个输入的任意布尔函数，并带有一个逻辑级的延迟。\n- 每位的掩码比较被视为3个输入$\\{x_i, p_i, m_i\\}$的布尔函数，并且必须在每个位上使用恰好一个6输入LUT实现。\n- 单个规则的$W$个逐位比较结果通过一个由实现6输入与（AND）功能的6输入LUT组成的平衡树，归约为一个规则匹配位。\n- $N$个规则匹配位通过一个由实现6输入或（OR）功能的6输入LUT组成的平衡树，归约为最终输出。\n- 没有流水线；考虑从数据包头输入到最终输出的纯组合逻辑路径。\n\n假设$W = 36$且$N$是$6$的整数次幂，即$N = 6^{m}$（对于某个整数$m \\ge 0$）。仅使用以下原则：(i) 当$M$是$K$的幂时，一个对$M$个输入进行归约的$K$元平衡归约树的深度为$\\log_{K}(M)$，以及 (ii) 组合逻辑关键路径延迟（以逻辑级为单位）是沿最长串行路径的逻辑级数之和，推导出从数据包头输入到最终过滤器输出的关键路径上的6-LUT逻辑级的确切数量，并将其表示为$N$的函数。\n\n请以仅包含$N$的、使用以6为底的对数的单一闭式解析表达式形式提供您的最终答案。不要包含单位，也不要四舍五入。", "solution": "我们从两个基本观察点开始：\n\n1. 在一个由查找表（LUT）组成的组合逻辑网络中，以逻辑级衡量的关键路径延迟等于从输入到输出的最长串行路径上的LUT级数。\n\n2. 一个使用扇入为$K$的节点将$M$个输入归约为一个输出的平衡$K$元归约树，当$M$是$K$的幂时，其深度为$\\log_{K}(M)$。这是因为每级将$K$个输入分组，直到只剩下一个输出。\n\n给定一条宽度为$W$的规则，每个比特级的掩码比较是三元组$\\{x_i, p_i, m_i\\}$的布尔函数。根据约束，每个这样的比特级比较恰好占用一个6输入LUT。因此，产生$W$个逐位匹配结果需要恰好1个逻辑级。\n\n然后，这$W$个逐位比较结果通过一个由实现6输入与（AND）功能的6输入LUT组成的平衡6元树，归约为一个规则匹配位。当$W$是6的幂时，此归约树的深度为$\\log_{6}(W)$。由于$W=36$且$36 = 6^2$，我们有\n$$\n\\log_{6}(W) = \\log_{6}(36) = \\log_{6}\\!\\left(6^{2}\\right) = 2.\n$$\n因此，从数据包头输入位到单个规则匹配输出的每规则计算包含\n$$\n1 \\text{ (bit-level masked compare)} + \\log_{6}(W) \\text{ (AND-reduction over } W \\text{ bits)} = 1 + 2 = 3\n$$\n个逻辑级。\n\n在所有规则之间，$N$个规则匹配位通过一个由实现6输入或（OR）功能的6输入LUT组成的平衡6元树，归约为一个最终输出。因为给定$N$是6的幂，所以这棵树的深度是\n$$\n\\log_{6}(N).\n$$\n\n因为没有流水线，这些阶段是纯组合逻辑，并串行排列在关键路径上：首先是比特级比较，然后是规则内的与（AND）归约，最后是跨规则的或（OR）归约。因此，从输入到输出的总6-LUT逻辑级数是以下各项之和\n$$\n1 + \\log_{6}(W) + \\log_{6}(N).\n$$\n代入$W = 36$得到\n$$\n1 + \\log_{6}(36) + \\log_{6}(N) = 1 + 2 + \\log_{6}(N) = 3 + \\log_{6}(N).\n$$\n\n这个表达式表明，关键路径的逻辑级延迟随规则数量$N$呈$\\log_{6}(N)$比例增长，其中附加了一个常数，该常数来自于每条规则的掩码比较以及在$W=36$位上的规则内归约。", "answer": "$$\\boxed{3+\\log_{6}(N)}$$", "id": "3671168"}]}