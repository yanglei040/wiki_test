{"hands_on_practices": [{"introduction": "GPU 提供高速的片上共享内存以加速数据重用，但其性能取决于能否避免存储体冲突（bank conflicts）。当一个线程束（warp）中的多个线程访问映射到同一存储体的不同地址时，这些访问将被串行化，从而抵消了并行带来的优势。本练习将指导您通过一个经典的矩阵转置场景，推导出如何通过数据布局填充（padding）来消除共享内存的 bank conflicts，这是保证高效内存访问的一项基本优化技巧 ([@problem_id:3644845])。", "problem": "图形处理单元 (GPU) 遵循单指令多线程 (SIMT) 模型以组的形式执行线程，其中一个线程束 (warp) 由 $32$ 个访问片上共享内存的线程组成。共享内存被组织成 $B=32$ 个存储体 (bank)，每个存储体在每个周期无冲突地服务一个4字节的字。给定字地址为 $a$ 的一个4字节字的存储体索引由基本映射规则 $a \\bmod B$ 给出。如果在同一条指令中，同一个线程束中的两个或多个线程访问了映射到同一存储体的不同地址，则会发生存储体冲突。考虑一个使用共享内存实现的分块矩阵转置，其分块 (tile) 声明为一个维度为 $T \\times (T+p)$ 的行主序数组，其中 $T$ 是分块大小，$p$ 是一个整型列填充。每个元素都是一个4字节的字。在转置的第二阶段，一个包含32个线程的完整线程束从共享内存中读取分块的一列（即线程 $t$ 读取行索引为 $t$ 且列索引固定的元素）。\n\n从存储体映射规则和存储体冲突的定义出发，推导保证完整线程束进行的列读取对分块的所有列都无存储体冲突的最小非负整数填充 $p$（表示为关于 $T$ 的符号表达式）。假设分块的共享内存基地址与存储体边界对齐，使得分块的第一个元素的存储体索引为 $0$。将您的最终答案表示为关于 $T$ 的单个解析表达式。无需取整。", "solution": "用户希望我扮演一位严谨的STEM教授。我的第一步是验证问题陈述的有效性。\n\n### 第一步：提取已知条件\n- GPU执行模型：单指令多线程 (SIMT)。\n- 线程束大小：$32$ 个线程。一个线程束中的线程索引为 $t \\in \\{0, 1, \\dots, 31\\}$。\n- 共享内存存储体数量：$B=32$。\n- 存储体性能：每个存储体每个周期处理一个4字节的字。\n- 字大小：4字节。\n- 存储体索引映射规则：地址为 $a$ 的字的存储体索引为 $a \\bmod B$。\n- 存储体冲突：当一个线程束中的两个或多个线程在同一条指令中访问映射到同一存储体的不同内存地址时发生。\n- 数据结构：一个以行主序存储的块，维度为 $T \\times (T+p)$，其中 $T$ 是块大小，$p$ 是整型列填充。\n- 元素大小：每个元素是一个4字节的字。\n- 内存访问模式：一个包含32个线程的完整线程束读取一列。线程 $t$ 读取行索引为 $t$、列索引固定（设为 $j$）的元素。对于任意列 $j$（其中 $0 \\le j  T$），此访问模式必须无冲突。\n- 基地址对齐：块的基地址已对齐，使得块的第一个元素（位于第0行第0列）映射到0号存储体。\n- 目标：推导最小非负整数填充 $p$（表示为关于 $T$ 的解析表达式），以保证列读取无冲突。\n\n### 第二步：使用提取的已知条件进行验证\n该问题具有科学依据，描述了GPU计算（特别是NVIDIA CUDA架构）中一个标准的内存访问优化问题。SIMT、线程束、共享内存和存储体冲突等概念是计算机组成和体系结构的基础。该问题定义明确、目标清晰且信息自洽，提供了推导唯一解所需的所有信息。给定的参数（32个存储体，32个线程/线程束）是符合实际的。该问题需要基于数论（模运算）进行逻辑推导，这是一种有效且可验证的方法。在其领域内，该问题既不简单也不过于复杂。\n\n### 第三步：结论与行动\n问题是**有效的**。我将进行详细的解答。\n\n### 解题推导\n问题要求找出最小的非负整数填充 $p$，以确保一个完整的线程束从共享内存块中按列读取数据时不会发生存储体冲突。\n\n共享内存块被声明为一个维度为 $T \\times (T+p)$ 的行主序数组。元素是4字节的字。内存存储体的数量为 $B=32$。\n\n设块在共享内存中的基地址为 $A_{base}$。位于第 $i$ 行第 $j$ 列的元素的地址由行主序布局公式给出。每行的元素（字）数量是步长 (stride)，即 $T+p$。\n位于 $(i, j)$ 的元素的字地址 $a(i, j)$ 为：\n$$a(i, j) = A_{base} + i \\cdot (T+p) + j$$\n\n该地址的存储体索引 $b(i, j)$ 由规则 $a \\bmod B$ 给出：\n$$b(i, j) = (A_{base} + i \\cdot (T+p) + j) \\bmod B$$\n\n题目说明基地址已对齐，使得第一个元素 $(0, 0)$ 映射到0号存储体。这意味着 $b(0, 0) = 0$。\n$$b(0, 0) = (A_{base} + 0 \\cdot (T+p) + 0) \\bmod B = A_{base} \\bmod B = 0$$\n这简化了任意元素 $(i, j)$ 的存储体索引计算：\n$$b(i, j) = (i \\cdot (T+p) + j) \\bmod B$$\n\n我们考虑的操作是一个包含32个线程的完整线程束读取块的某一单列 $j$。一个线程束包含32个线程，我们可以将其索引为 $t=0$ 到 $t=31$。线程 $t$ 读取第 $t$ 行的元素。因此，线程 $t$ 访问位于 $(t, j)$ 的元素。\n\n线程 $t$ 访问的存储体索引为：\n$$b_t = b(t, j) = (t \\cdot (T+p) + j) \\bmod B$$\n这里，$B=32$，所以：\n$$b_t = (t \\cdot (T+p) + j) \\bmod 32$$\n\n如果任意两个不同的线程 $t_1$ 和 $t_2$（其中 $t_1 \\ne t_2$ 且两者都在 $\\{0, 1, \\dots, 31\\}$ 中）访问了同一个存储体，就会发生存储体冲突。即 $b_{t_1} = b_{t_2}$。\n为了保证读取无冲突，我们必须确保对于所有 $t_1 \\ne t_2$，都有 $b_{t_1} \\ne b_{t_2}$。这意味着32个存储体索引的集合 $\\{b_0, b_1, \\dots, b_{31}\\}$ 中的所有元素必须互不相同。由于只有 $B=32$ 个存储体，这个集合必须是 $\\{0, 1, \\dots, 31\\}$ 的一个排列。\n\n无存储体冲突的条件是：\n$$(t_1 \\cdot (T+p) + j) \\bmod 32 \\ne (t_2 \\cdot (T+p) + j) \\bmod 32 \\quad \\text{for } t_1 \\ne t_2$$\n这等价于：\n$$(t_1 - t_2) \\cdot (T+p) \\not\\equiv 0 \\pmod{32}$$\n令 $\\Delta t = t_1 - t_2$。因为 $t_1, t_2 \\in \\{0, 1, \\dots, 31\\}$ 且 $t_1 \\ne t_2$，所以 $\\Delta t$ 可以取-31到31之间除0外的任何整数值。该条件必须对所有这样的 $\\Delta t$ 都成立。另外，请注意此条件与列索引 $j$ 无关，因此如果它对某一列成立，则对所有列都成立。\n\n存储体索引集合 $\\{ (t \\cdot (T+p) + j) \\bmod 32 \\}_{t=0}^{31}$ 构成一个模32的等差数列，其公差为 $(T+p)$。要使这样一个序列的所有元素都互不相同，公差必须与模数互质（coprime）。\n因此，无冲突访问的条件是：\n$$\\gcd(T+p, 32) = 1$$\n\n$32$ 的质因数分解是 $2^5$。一个数要与 $32$ 互质，它必须不能被 $2$ 整除。换句话说，$T+p$ 必须是一个奇数。\n$$T+p \\equiv 1 \\pmod{2}$$\n\n我们需要找到满足此条件的最小非负整数 $p$。我们根据 $T$ 的奇偶性分两种情况进行分析。\n\n情况1：$T$ 是偶数。\n如果 $T$ 是偶数，则 $T \\equiv 0 \\pmod{2}$。条件变为：\n$$0 + p \\equiv 1 \\pmod{2}$$\n这意味着 $p$ 必须是奇数。最小的非负奇数是 $1$。所以，当 $T$ 为偶数时，最小填充为 $p=1$。\n\n情况2：$T$ 是奇数。\n如果 $T$ 是奇数，则 $T \\equiv 1 \\pmod{2}$。条件变为：\n$$1 + p \\equiv 1 \\pmod{2}$$\n这意味着 $p$ 必须是偶数 ($p \\equiv 0 \\pmod{2}$)。最小的非负偶数是 $0$。所以，当 $T$ 为奇数时，最小填充为 $p=0$。\n\n我们可以将这两种情况合并成一个关于 $T$ 的单一解析表达式来表示 $p$。\n- 如果 $T$ 是偶数，$T \\bmod 2 = 0$，我们需要 $p=1$。\n- 如果 $T$ 是奇数，$T \\bmod 2 = 1$，我们需要 $p=0$。\n\n这个关系可以表示为 $p = 1 - (T \\bmod 2)$。另一个等价且简洁的表达式是：\n$$p = (T+1) \\bmod 2$$\n我们来验证这个表达式：\n- 如果 $T$ 是偶数，$T+1$ 是奇数，所以 $(T+1) \\bmod 2 = 1$。这是正确的。\n- 如果 $T$ 是奇数，$T+1$ 是偶数，所以 $(T+1) \\bmod 2 = 0$。这是正确的。\n\n因此，保证列读取无冲突的最小非负整数填充 $p$ 由 $(T+1) \\bmod 2$ 给出。", "answer": "$$\n\\boxed{(T+1) \\bmod 2}\n$$", "id": "3644845"}, {"introduction": "内核融合（Kernel fusion）是一种强大的优化技术，它通过将多个连续的内核合并为一个，显著减少了与高延迟全局内存之间的数据传输。然而，这种融合是以增加单次内核的资源消耗（特别是寄存器）为代价的，这可能会降低占用率（occupancy），从而影响延迟隐藏能力。本练习将量化这种权衡，要求您确定在保持足够占用率以隐藏延迟的前提下，最多可以融合多少个操作 ([@problem_id:3644777])。", "problem": "一个使用单指令多线程（SIMT）的图形处理单元（GPU）处理器执行逐元素（elementwise）内核，这些内核流式处理大于缓存的数组。考虑一个由 $k$ 个逐元素操作组成的流水线，作用于一个包含 $N$ 个元素的数组，其中每个操作对每个元素读取一个 $4$ 字节的输入值并写入一个 $4$ 字节的输出值。当这些操作作为 $k$ 个独立的内核执行时，每个元素的总内存流量与内核数量成正比；而当它们融合成一个单一内核时，数组只被读取一次和写入一次，从而使总内存流量减少了一个约等于 $k$ 的系数。\n\n然而，内核融合会增加每线程的寄存器使用量。假设单个流式多处理器（SM）具有以下特性：\n- SM 的寄存器文件大小为 $R_{\\mathrm{SM}} = 65536$ 个寄存器（每个寄存器为 $32$ 位）。\n- 每个 SM 的硬件线程数上限为 $T_{\\max} = 2048$。\n- 每个 SM 的最大驻留线程块数为 $B_{\\max} = 8$。\n- 每个线程块包含 $t_b = 256$ 个线程。\n- 每个线程的硬件寄存器数上限为 $r_{\\mathrm{thr\\_max}} = 255$。\n- 基础的未融合内核（$k=1$）每个线程使用 $r_0 = 20$ 个寄存器。\n- 由于活跃的临时变量和指令级并行，每增加一个融合的逐元素操作，每线程的寄存器使用量会增加 $\\alpha = 8$ 个寄存器，因此融合 $k$ 个操作时每线程的寄存器使用量为 $r(k) = r_0 + \\alpha(k - 1)$。\n- 忽略除寄存器、线程数和线程块数之外的所有资源限制。假设寄存器是精确地按线程分配的，没有粒度效应。\n\n占用率（Occupancy）定义为每个 SM 上的驻留线程数除以 $T_{\\max}$。为了维持延迟隐藏（latency hiding），要求占用率至少为 $0.5$。每个 SM 上的驻留线程块数受寄存器、线程数和线程块数的限制，其值为 $\\min\\!\\left(B_{\\max}, \\left\\lfloor \\dfrac{R_{\\mathrm{SM}}}{r(k)\\, t_b} \\right\\rfloor, \\left\\lfloor \\dfrac{T_{\\max}}{t_b} \\right\\rfloor \\right)$。\n\n在这些假设下，确定能使融合内核的占用率保持至少 $0.5$ 的最大整数 $k$。你的最终答案只提供 $k$ 的最大整数值。", "solution": "用户希望找到能维持最低 GPU 占用率的融合操作的最大整数数量 $k$。该解决方案需要逐步应用给定的约束条件。\n\n首先，我们将占用率的要求形式化。占用率（以 $O$ 表示）定义为一个流式多处理器（SM）上的驻留线程数与每个 SM 可能的最大线程数 $T_{\\max}$ 的比率。驻留线程数是驻留线程块数 $B_{\\mathrm{res}}$ 与每线程块的线程数 $t_b$ 的乘积。约束条件是 $O \\ge 0.5$。\n\n$$O = \\frac{B_{\\mathrm{res}} \\times t_b}{T_{\\max}} \\ge 0.5$$\n\n我们已知 $T_{\\max} = 2048$ 和 $t_b = 256$。代入这些值，我们可以求解所需的最小驻留线程块数 $B_{\\mathrm{res}}$：\n\n$$\\frac{B_{\\mathrm{res}} \\times 256}{2048} \\ge 0.5$$\n$$\\frac{B_{\\mathrm{res}}}{8} \\ge 0.5$$\n$$B_{\\mathrm{res}} \\ge 4$$\n\n由于线程块的数量必须是整数，这个不等式意味着 SM 上必须至少驻留 $4$ 个线程块。\n\n每个 SM 上的驻留线程块数 $B_{\\mathrm{res}}$ 受三个因素限制：每个 SM 的最大线程块数（$B_{\\max}$）、总寄存器文件大小（$R_{\\mathrm{SM}}$）和每个 SM 的最大线程数（$T_{\\max}$）。提供的公式为：\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(B_{\\max}, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor, \\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor \\right)$$\n\n我们来计算这个表达式中的常数项。已知 $B_{\\max} = 8$。由线程数施加的限制是：\n\n$$\\left\\lfloor \\frac{T_{\\max}}{t_b} \\right\\rfloor = \\left\\lfloor \\frac{2048}{256} \\right\\rfloor = \\lfloor 8 \\rfloor = 8$$\n\n因此，$B_{\\mathrm{res}}$ 的公式简化为：\n\n$$B_{\\mathrm{res}} = \\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right)$$\n\n现在，我们将其与我们推导出的条件 $B_{\\mathrm{res}} \\ge 4$ 结合起来：\n\n$$\\min\\!\\left(8, \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\right) \\ge 4$$\n\n要使两个量的最小值至少为 $4$，这两个量都必须至少为 $4$。第一个条件 $8 \\ge 4$ 显然成立。第二个条件给出了系统的主要约束：\n\n$$\\left\\lfloor \\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\right\\rfloor \\ge 4$$\n\n对于表达式 $\\lfloor x \\rfloor$ 大于或等于整数 $n$ 的情况， $x$ 的值必须大于或等于 $n$。因此：\n\n$$\\frac{R_{\\mathrm{SM}}}{r(k) \\cdot t_b} \\ge 4$$\n\n这个不等式为每线程的寄存器数 $r(k)$ 设定了一个上限。我们可以解出 $r(k)$：\n\n$$r(k) \\le \\frac{R_{\\mathrm{SM}}}{4 \\cdot t_b}$$\n\n代入给定值 $R_{\\mathrm{SM}} = 65536$ 和 $t_b = 256$：\n\n$$r(k) \\le \\frac{65536}{4 \\times 256} = \\frac{65536}{1024} = 64$$\n\n所以，为了保持所需的占用率，每线程的寄存器使用量不能超过 $64$。我们注意到这个值远低于每线程 $r_{\\mathrm{thr\\_max}} = 255$ 个寄存器的硬件上限，因此该上限不是决定性约束。\n\n问题提供了一个关于寄存器使用量随融合操作数 $k$ 变化的模型：\n\n$$r(k) = r_0 + \\alpha(k - 1)$$\n\n我们已知基础寄存器使用量 $r_0 = 20$ 以及每个融合操作的增量 $\\alpha = 8$。对于 $k \\ge 1$，我们有：\n\n$$r(k) = 20 + 8(k - 1)$$\n\n现在我们应用推导出的约束条件 $r(k) \\le 64$：\n\n$$20 + 8(k - 1) \\le 64$$\n\n我们对这个不等式求解 $k$：\n\n$$8(k - 1) \\le 64 - 20$$\n$$8(k - 1) \\le 44$$\n$$k - 1 \\le \\frac{44}{8}$$\n$$k - 1 \\le 5.5$$\n$$k \\le 6.5$$\n\n问题要求 $k$ 的最大整数值。由于 $k$ 必须是整数且 $k \\le 6.5$，所以 $k$ 的最大可能整数值为 $6$。\n\n为了验证，如果 $k = 6$，$r(6) = 20 + 8(6-1) = 20 + 40 = 60$。那么 $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{60 \\times 256} \\rfloor) = \\min(8, \\lfloor \\frac{65536}{15360} \\rfloor) = \\min(8, \\lfloor 4.26\\dots \\rfloor) = \\min(8, 4) = 4$。占用率为 $\\frac{4 \\times 256}{2048} = \\frac{1024}{2048} = 0.5$，满足要求。\n如果 $k = 7$，$r(7) = 20 + 8(7-1) = 20 + 48 = 68$。那么 $B_{\\mathrm{res}} = \\min(8, \\lfloor \\frac{65536}{68 \\times 256} \\rfloor) = \\min(8, \\lfloor \\frac{65536}{17408} \\rfloor) = \\min(8, \\lfloor 3.76\\dots \\rfloor) = \\min(8, 3) = 3$。占用率为 $\\frac{3 \\times 256}{2048} = \\frac{768}{2048} = 0.375$，低于要求的 $0.5$。\n因此，最大的整数 $k$ 是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3644777"}, {"introduction": "占用率（Occupancy）是衡量 GPU 流式多处理器（SM）繁忙程度的关键指标，它直接影响 GPU 隐藏内存访问延迟的能力。然而，最大化占用率并非总是最优策略，它受到寄存器、共享内存、线程数等多重硬件资源的复杂制约。本练习模拟了一个真实世界的内核调优过程，要求您通过调整线程块（thread block）的大小，在满足指令级并行需求的同时，平衡各项资源消耗，以找到实现最大占用率的最佳配置 ([@problem_id:3644790])。", "problem": "图形处理器（GPU）中的流式多处理器（SM）以称为线程束（warp）的线程组形式执行单指令多线程（SIMT）任务。SM 的占用率定义为活跃线程束数量与 SM 可支持的最大线程束数量之比。考虑一个具有以下特征的 GPU：线程束大小 $W=32$，每个 SM 的最大线程束数 $W_{\\max}=64$，每个 SM 的最大线程数 $T_{\\mathrm{SM}}^{\\max}=2048$，每个 SM 的最大线程块数 $B_{\\mathrm{SM}}^{\\max}=32$，每个 SM 的寄存器文件大小 $R_{\\mathrm{SM}}=65536$（32 位寄存器），每个 SM 的共享内存大小 $S_{\\mathrm{SM}}=65536$ 字节，以及每个线程块的最大线程数 $T_{\\mathrm{blk}}^{\\max}=1024$。\n\n一个内核（kernel）以线程块大小 $T$（每个线程块的线程数）启动，其中 $T$ 必须是 $W$ 的正整数倍。对于此内核，每个线程的寄存器使用量建模为 $r(T)=r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right)$，其中 $r_{0}=28$ 且 $\\alpha=4$；每个线程块的共享内存使用量建模为 $S(T)=s_{0}+\\beta T$，其中 $s_{0}=2048\\,\\text{bytes}$ 且 $\\beta=16\\,\\text{bytes/thread}$。如果 $r(T)", "solution": "所述问题在科学上基于 GPU 架构的原理，是一个定义明确的优化问题，具有完整且一致的给定条件。所有参数对于现代流式多处理器都是物理上现实的。因此，我们可以进行形式化求解。\n\n我们的目标是找到整数线程块大小 $T^{*}$，以最大化流式多处理器（SM）的占用率。占用率 $\\mathcal{O}$ 定义为活跃线程束数量 $W_{\\text{active}}$ 与 SM 可支持的最大线程束数量 $W_{\\max}$ 之比。\n$$\n\\mathcal{O} = \\frac{W_{\\text{active}}}{W_{\\max}}\n$$\n最大化占用率等同于在硬件和内核约束下最大化活跃线程束的数量 $W_{\\text{active}}$。活跃线程束的数量是 SM 上并发驻留的线程块数 $B_{\\text{active}}$ 与每块的线程束数 $W_{\\text{blk}}$ 的乘积。\n\n每个线程块的线程数 $T$ 被约束为线程束大小 $W=32$ 的正整数倍。因此，每个线程块的线程束数是一个整数，由下式给出：\n$$\nW_{\\text{blk}} = \\frac{T}{W} = \\frac{T}{32}\n$$\n那么，活跃线程束的总数为：\n$$\nW_{\\text{active}}(T) = B_{\\text{active}}(T) \\times W_{\\text{blk}} = B_{\\text{active}}(T) \\times \\frac{T}{32}\n$$\n活跃线程块的数量 $B_{\\text{active}}(T)$ 受到 SM 有限资源的限制。对于给定的线程块大小 $T$，可以同时活跃的线程块数是最大线程块数、线程数、寄存器数和共享内存所施加的限制中的最小值。\n\n让我们从每种资源确定对 $B_{\\text{active}}$ 的限制：\n1.  **每个 SM 的最大线程块数：** 硬件最多支持 $B_{\\mathrm{SM}}^{\\max}$ 个线程块。\n    $$B_{\\text{active}} \\le B_{\\mathrm{SM}}^{\\max} = 32$$\n\n2.  **每个 SM 的最大线程数：** 所有活跃线程块的总线程数不能超过 $T_{\\mathrm{SM}}^{\\max}$。\n    $$B_{\\text{active}} \\times T \\le T_{\\mathrm{SM}}^{\\max} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\right\\rfloor = \\left\\lfloor \\frac{2048}{T} \\right\\rfloor$$\n    请注意，此约束等同于最大线程束约束，因为 $W_{\\text{active}} = B_{\\text{active}} \\frac{T}{W} \\le \\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor \\frac{T}{W} \\le \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\frac{T}{W} = \\frac{T_{\\mathrm{SM}}^{\\max}}{W} = \\frac{2048}{32} = 64 = W_{\\max}$。\n\n3.  **每个 SM 的寄存器文件大小：** 所有活跃线程块使用的总寄存器数不能超过 $R_{\\mathrm{SM}}$。每个线程块的寄存器数是每块线程数 $T$ 与每线程寄存器数 $r(T)$ 的乘积。\n    $$r(T) = r_{0}+\\alpha \\log_{2}\\!\\left(\\frac{T}{W}\\right) = 28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)$$\n    $$B_{\\text{active}} \\times T \\times r(T) \\le R_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{T \\left(28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right)\\right)} \\right\\rfloor$$\n\n4.  **每个 SM 的共享内存：** 所有活跃线程块使用的总共享内存不能超过 $S_{\\mathrm{SM}}$。每个线程块的共享内存由 $S(T)$ 给出。\n    $$S(T) = s_{0}+\\beta T = 2048 + 16T$$\n    $$B_{\\text{active}} \\times S(T) \\le S_{\\mathrm{SM}} \\implies B_{\\text{active}} \\le \\left\\lfloor \\frac{S_{\\mathrm{SM}}}{S(T)} \\right\\rfloor = \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor$$\n\n综合这些，对于给定的 $T$，活跃线程块的数量为：\n$$\nB_{\\text{active}}(T) = \\min\\left(32, \\left\\lfloor \\frac{2048}{T} \\right\\rfloor, \\left\\lfloor \\frac{65536}{T \\cdot r(T)} \\right\\rfloor, \\left\\lfloor \\frac{65536}{2048 + 16T} \\right\\rfloor\\right)\n$$\n我们现在必须确定线程块大小 $T$ 的有效范围。问题规定了对 $T$ 的三个约束：\n1.  $T$ 必须是 $W=32$ 的正整数倍。\n2.  $T \\le T_{\\mathrm{blk}}^{\\max} = 1024$。\n3.  必须满足指令级并行（ILP）约束：$r(T) \\ge r_{\\min} = 32$。\n    $$28+4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 32 \\implies 4 \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 4 \\implies \\log_{2}\\!\\left(\\frac{T}{32}\\right) \\ge 1 \\implies \\frac{T}{32} \\ge 2 \\implies T \\ge 64$$\n因此，可行的线程块大小 $T$ 的集合是 $\\{64, 96, 128, 160, \\dots, 1024\\}$。我们将对这个离散的值集合评估 $W_{\\text{active}}(T)$ 以找到最大值。\n\n让我们为几个可行的 $T$ 值计算 $B_{\\text{active}}(T)$ 和 $W_{\\text{active}}(T)$。\n\n当 $T=64$ 时：\n$r(64) = 28+4\\log_2(2) = 32$。$S(64) = 2048+16(64) = 3072$。\n$B_{\\text{active}}(64) = \\min\\left(32, \\lfloor\\frac{2048}{64}\\rfloor, \\lfloor\\frac{65536}{64 \\cdot 32}\\rfloor, \\lfloor\\frac{65536}{3072}\\rfloor\\right) = \\min(32, 32, 32, 21) = 21$。\n$W_{\\text{active}}(64) = 21 \\times \\frac{64}{32} = 21 \\times 2 = 42$。\n\n当 $T=96$ 时：\n$r(96) = 28+4\\log_2(3) \\approx 34.34$。$S(96) = 2048+16(96) = 3608$。\n$B_{\\text{active}}(96) = \\min\\left(32, \\lfloor\\frac{2048}{96}\\rfloor, \\lfloor\\frac{65536}{96 \\cdot (28+4\\log_2(3))}\\rfloor, \\lfloor\\frac{65536}{3608}\\rfloor\\right) = \\min(32, 21, 19, 18) = 18$。\n$W_{\\text{active}}(96) = 18 \\times \\frac{96}{32} = 18 \\times 3 = 54$。\n\n当 $T=128$ 时：\n$r(128) = 28+4\\log_2(4) = 36$。$S(128) = 2048+16(128) = 4096$。\n$B_{\\text{active}}(128) = \\min\\left(32, \\lfloor\\frac{2048}{128}\\rfloor, \\lfloor\\frac{65536}{128 \\cdot 36}\\rfloor, \\lfloor\\frac{65536}{4096}\\rfloor\\right) = \\min(32, 16, 14, 16) = 14$。\n$W_{\\text{active}}(128) = 14 \\times \\frac{128}{32} = 14 \\times 4 = 56$。\n\n当 $T=160$ 时：\n$r(160) = 28+4\\log_2(5) \\approx 37.29$。$S(160) = 2048+16(160) = 4608$。\n$B_{\\text{active}}(160) = \\min\\left(32, \\lfloor\\frac{2048}{160}\\rfloor, \\lfloor\\frac{65536}{160 \\cdot (28+4\\log_2(5))}\\rfloor, \\lfloor\\frac{65536}{4608}\\rfloor\\right) = \\min(32, 12, 10, 14) = 10$。\n$W_{\\text{active}}(160) = 10 \\times \\frac{160}{32} = 10 \\times 5 = 50$。\n\n当 $T=192$ 时：\n$r(192) = 28+4\\log_2(6) \\approx 38.34$。$S(192) = 2048+16(192) = 5120$。\n$B_{\\text{active}}(192) = \\min\\left(32, \\lfloor\\frac{2048}{192}\\rfloor, \\lfloor\\frac{65536}{192 \\cdot (28+4\\log_2(6))}\\rfloor, \\lfloor\\frac{65536}{5120}\\rfloor\\right) = \\min(32, 10, 8, 12) = 8$。\n$W_{\\text{active}}(192) = 8 \\times \\frac{192}{32} = 8 \\times 6 = 48$。\n\n计算出的活跃线程束数量为 $42, 54, 56, 50, 48, \\dots$。由于向下取整函数以及不同约束之间的相互作用，函数 $W_{\\text{active}}(T)$ 不是单调的。然而，趋势表明峰值在 $T=128$ 附近。对于 $T > 128$，寄存器限制 $\\lfloor \\frac{R_{\\mathrm{SM}}}{T \\cdot r(T)} \\rfloor$ 和线程限制 $\\lfloor \\frac{T_{\\mathrm{SM}}^{\\max}}{T} \\rfloor$ 变得越来越严格，导致 $B_{\\text{active}}(T)$ 和随后的 $W_{\\text{active}}(T)$ 都减小。对 $T=192$ 的计算证实了这一下降趋势。\n\n找到的最大活跃线程束数量是 $56$，它出现在线程块大小为 $T=128$ 时。这对应的占用率为 $\\mathcal{O} = 56/64 = 0.875$。\n\n因此，在所有给定约束下最大化占用率的整数线程块大小 $T^{*}$ 是 $128$。", "answer": "$$\n\\boxed{128}\n$$", "id": "3644790"}]}