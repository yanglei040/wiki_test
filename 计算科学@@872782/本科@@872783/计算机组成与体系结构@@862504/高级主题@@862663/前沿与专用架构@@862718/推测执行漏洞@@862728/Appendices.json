{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。现代处理器中分支预测的准确率极高，但这是否意味着旁路攻击的威胁可以忽略不计？本练习 [@problem_id:3679344] 将通过一个简化的概率模型，帮助你量化一个高精度分支预测器在执行大量指令时产生的错误预测的期望数量。通过这个计算，你将直观地理解为何即使是微小的失误率，在现代CPU巨大的执行通量下，也会转化为一个不可忽视的攻击窗口。", "problem": "现代的乱序执行中央处理器（CPU）使用动态分支预测来推测性地执行代码路径。在 Spectre 类型的瞬态执行攻击中，错误预测的分支可被利用来执行未经授权的瞬态内存访问，从而调制微体系结构侧信道（例如，缓存），进而泄露信息。考虑一个简化的统计模型，其中遇到的每个条件分支都是一个独立的伯努利试验，其预测正确的概率为 $a$，预测错误的概率（即错误预测）为 $1-a$。假设预测器具有平穩性，使得 $a$ 在所考虑的范围内保持不变。\n\n给定分支预测器准确率 $a = 0.99$ 和一个由攻击者控制的循环执行的 $N = 10^{6}$ 条分支指令的范围。仅使用概率论的基本定义和性质（例如，指示随机变量和期望的线性性），推导在 $N$ 个分支上发生错误预测的期望数量，并计算其数值。无需四舍五入。\n\n然后，基于瞬态执行和基于缓存的侧信道的第一性原理，定性地讨论在每个错误预测都可以在侧信道中驱动至少一个可靠的比特级信号的合理假设下，每 $10^{6}$ 个分支的预期错误预测次数是否足以在 Spectre 风格的攻击中维持有意义的泄露带宽。您的讨论应基于科学推理，但不会改变所要求的数值答案。\n\n请提供预期的错误预测次数作为您的最终答案。", "solution": "该问题被认为是有效的，因为它在计算机体系结构和概率论方面有科学依据，是自洽的，并且是适定问题。我们开始求解。\n\n问题要求计算在一系列 $N$ 个条件分支指令中发生错误预测的期望数量。每个分支的预测被建模为独立的伯努利试验。\n\n设 $N$ 是该范围内的分支指令总数。给定 $N = 10^{6}$。\n设 $a$ 是分支预测正确的概率。给定 $a = 0.99$。\n因此，任何给定分支发生错误预测的概率是 $1 - a$。\n\n为了找到错误预测的总期望数量，我们将遵循指定的方法，使用指示随机变量和期望的线性性。\n\n让我们定义一组指示随机变量 $\\{X_1, X_2, \\dots, X_N\\}$。对于每个分支 $i \\in \\{1, 2, \\dots, N\\}$，随机变量 $X_i$ 定义如下：\n$$\nX_i = \n\\begin{cases} \n1  \\text{如果第 } i\\text{ 个分支被错误预测} \\\\\n0  \\text{如果第 } i\\text{ 个分支被正确预测}\n\\end{cases}\n$$\n根据定义，错误预测的概率为 $P(X_i = 1) = 1 - a$。正确预测的概率为 $P(X_i = 0) = a$。\n\n指示随机变量的期望值是它所指示事件的概率。对于任何 $i$， $X_i$ 的期望是：\n$$\nE[X_i] = (1 \\cdot P(X_i=1)) + (0 \\cdot P(X_i=0))\n$$\n$$\nE[X_i] = (1 \\cdot (1-a)) + (0 \\cdot a) = 1-a\n$$\n这对所有从 $1$ 到 $N$ 的 $i$ 都成立，因为假设分支预测的准确率是平穩的。\n\n设 $M$ 是 $N$ 个分支上发生错误预测的总次数。$M$ 是各个指示随机变量之和：\n$$\nM = \\sum_{i=1}^{N} X_i\n$$\n我们要求解 $M$ 的期望值，记为 $E[M]$。期望的一个基本性质是其线性性。随机变量之和的期望等于它们各自期望之和。无论这些随机变量是否独立，此性质都成立。\n$$\nE[M] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i]\n$$\n因为对于所有的 $i$，$E[X_i] = 1-a$ ，我们可以将其代入求和式中：\n$$\nE[M] = \\sum_{i=1}^{N} (1-a)\n$$\n这是 $N$ 个相同项的和，所以可以简化为：\n$$\nE[M] = N(1-a)\n$$\n该表达式给出了以分支总数 $N$ 和预测器准确率 $a$表示的预期错误预测次数。\n\n现在，我们代入给定的数值：$N = 10^{6}$ 和 $a = 0.99$。\n错误预测的概率是 $1 - a = 1 - 0.99 = 0.01$。\n预期错误预测的次数是：\n$$\nE[M] = 10^{6} \\times (1 - 0.99) = 10^{6} \\times 0.01 = 10000\n$$\n因此，在一个包含 $10^{6}$ 条已执行分支指令的范围内，攻击者可以预期引发 $10000$ 次错误预测。\n\n问题的第二部分要求定性讨论这个数字是否足以在 Spectre 风格的攻击中维持有意义的泄露带宽。\n每百万次分支的预期错误预测次数是 $10000$ 次。Spectre 攻击的原理是利用错误预测后瞬态执行的指令来访问机密数据，并将该数据编码到微体系结构侧信道中，例如数据缓存的状态。问题给出的假设是，每次错误预测可以驱动至少一个可靠的比特级信号。\n\n$10000$ 个瞬态执行窗口的预期次数对攻击者来说是相当可观的资源。即使泄露一个秘密比特（例如，一个加密密钥的一位）需要多次错误预测来放大信号并克服系统噪声，这个数字也足够大。例如，如果一个攻击者需要 $100$ 条错误预测的瞬态路径才能高置信度地泄露一位信息，他们仍然可以预期泄露 $10000 / 100 = 100$ 比特的信息。这足以窃取像 $128$ 位或 $256$ 位加密密钥这样的敏感数据的全部或大部分。\n\n此外，现代处理器每秒执行数十亿条指令。一个包含 $10^{6}$ 个分支的循环可以在非常短的时间内（毫秒级别，取决于时钟频率和循环体复杂度）执行完毕。因此，每 $10^{6}$ 个分支预期有 $10000$ 次泄露机会，这可以转化为每秒比特数很高的数据窃取率。例如，如果该循环在 $100$ 毫秒（$0.1$ 秒）内运行，在此时间内成功泄露 $100$ 比特，将对应于 $100 \\text{ 比特} / 0.1 \\text{ 秒} = 1000$ 比特/秒，即 $1$ kbps的泄露带宽。在安全领域，这是一个非常显著的泄露带宽，远远超过从内存中窃取密钥、密码和其他敏感数据结构所必需的带宽。\n\n总之，即使有非常准确的分支预测器（$99\\%$），现代CPU处理的指令量巨大，这意味着错误预测的绝对数量仍然很大。$10000$ 次预期错误预测的值，足以维持 Spectre 类攻击的有意义且危险的泄露带宽。", "answer": "$$\n\\boxed{10000}\n$$", "id": "3679344"}, {"introduction": "理解了漏洞的来源后，下一步是探索如何从根本上防御。此练习 [@problem_id:3679377] 关注一种常见的Spectre变体1的软件缓解技术：无分支边界检查。你将分析一段使用数据依赖（而非控制依赖）来约束内存访问的代码，并深入探讨其为何能在微架构层面有效阻止错误的推测性执行，从而巩固对处理器内部数据流和依赖关系的理解。", "problem": "一个在现代乱序中央处理器（CPU）上运行的程序，使用无分支钳位的方式对一个由攻击者控制的索引进行数组访问。考虑以下理想化的三地址序列，其中 $A$ 是一个长度为 $L$ 的字节数组的基地址，$I$ 是攻击者控制的索引，$P$ 是一个探针数组的基地址，并且所有寄存器都是架构性的（在微架构层面进行寄存器重命名）。存在一级（L1）数据缓存和地址生成单元（AGU）。假设没有实现硬件值预测，并且微架构强制执行真数据依赖（写后读）。\n\n- $R_I \\leftarrow I$\n- $R_L \\leftarrow L$\n- $R_C \\leftarrow \\min(R_I, R_L - 1)$\n- $R_V \\leftarrow \\mathrm{load}(A + R_C)$\n- $\\mathrm{store}(P + 4096 \\cdot R_V) \\leftarrow 1$\n\n一个常规的 Spectre 变体 1（边界检查绕过）攻击依赖于处理器瞬态地使用一个越界的 $I$ 来读取秘密数据，并通过探針存储将其编码到缓存中。相比之下，上述代码使用了 $\\min/\\max$ 风格的钳位来消除显式的条件分支。\n\n仅使用以下基本原则：\n\n- 乱序执行尊重真数据依赖；也就是说，如果操作 $B$ 使用操作 $A$ 的结果，那么在 $A$ 的值可用之前，机器不会在架构上或瞬态地提交 $B$ 的数据消耗所带来的影响。这是通过寄存器重命名和操作数就绪来强制执行的。\n- 内存操作的有效地址必须在向缓存层次结构发出内存请求之前已知；AGU 在没有所需操作数值的情况下无法发出请求。\n- 控制推测（例如，分支预测）可以消除控制依赖，但不能移除真数据依赖。\n- 微架构侧信道源于数据相关的资源使用（例如，访问的缓存行），即使架构状态被回滚。\n- Meltdown 类攻击利用延迟的权限错误处理来瞬态地跨越权限边界转发数据，并且与用户空间中的边界检查是正交的。\n\n以下哪些陈述是正确的？选择所有适用项。\n\nA. 在上述序列中，数组加载的有效地址直到 $\\min$ 操作产生 $R_C$ 后才能形成；因此，在没有值预测的处理器上，地址为 $A + R_I$ 的瞬态越界读取不会发生，因为 AGU 在 $R_C$ 就绪之前无法发出依赖于 $R_C$ 的请求。\n\nB. 即使有 $\\min$ 钳位，AGU 也可能在 $R_C$ 仍未就绪时，推测性地使用未钳位的索引 $A + R_I$ 发出内存请求，因为地址计算推测足以绕过真数据依赖。\n\nC. 尽管钳位访问在这种模式下可以防止瞬态越界读取，但由特权错误加载引起的 Meltdown 类泄漏并未通过此类钳位得到缓解，因为 Meltdown 涉及的是延迟的权限检查，而不是数组边界。\n\nD. 将无分支钳位替换为显式条件分支对于 Spectre 变体 1 来说绝对更安全，因为分支预测错误不会导致处理器瞬态地使用 $A + R_I$ 进行加载。", "solution": "在进行解答之前，需对问题陈述进行验证。\n\n### 步骤 1：提取已知信息\n\n问题提供了以下信息：\n- **执行环境：** 一个现代乱序中央处理器（CPU），带有一级（L1）数据缓存、一个地址生成单元（AGU）和寄存器重命名。\n- **假设：** 没有实现硬件值预测。强制执行真数据依赖（写后读）。\n- **代码序列：**\n    1. $R_I \\leftarrow I$\n    2. $R_L \\leftarrow L$\n    3. $R_C \\leftarrow \\min(R_I, R_L - 1)$\n    4. $R_V \\leftarrow \\mathrm{load}(A + R_C)$\n    5. $\\mathrm{store}(P + 4096 \\cdot R_V) \\leftarrow 1$\n- **变量定义：**\n    - $A$：字节数组的基地址。\n    - $L$：字节数组的长度。\n    - $I$：攻击者控制的索引。\n    - $P$：探针数组的基地址。\n    - $R_I, R_L, R_C, R_V$：架构寄存器。\n- **基本原则：**\n    1. 乱序执行尊重真数据依赖。\n    2. 内存操作的有效地址在 AGU 发出内存请求之前必须已知。\n    3. 控制推测可以消除控制依赖，但不能消除真数据依赖。\n    4. 微架构侧信道源于数据相关的资源使用。\n    5. Meltdown 类攻击利用延迟的权限错误处理，与用户空间边界检查是正交的。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n对问题陈述的有效性进行分析。\n- **科学依据：** 该问题基于计算机体系结构中公认的概念，特别是乱序执行、推测执行、数据依赖以及像 Spectre 和 Meltdown 这样的侧信道攻击。描述是科学合理的。\n- **定义明确：** 该问题提供了一个特定的代码序列、一组硬件特性以及一串用于推理的基本原则。问题要求基于这些前提评估给定的陈述，这使得可以得出一组唯一且稳定的正确答案。\n- **客观性：** 语言技术性强、精确，且没有主观或模糊的术语。\n- **完整性与一致性：** 问题是自包含的。所提供的假设（例如，无值预测）和原则是明确的，并且彼此之间以及与对该主题的标准理解是一致的。\n- **其他缺陷：** 该问题没有表现出任何其他缺陷，如不切实际、定义不清、过于简单或无法验证。该场景描述了一种针对 Spectre 变体 1 的常见软件缓解模式。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将根据所述原则分析所提供的代码序列来推导出解决方案。\n\n### 解答推导\n\n问题的核心在于内存访问指令 $R_V \\leftarrow \\mathrm{load}(A + R_C)$ 的数据依赖链。让我们来追踪这些依赖关系：\n1. 指令 $R_C \\leftarrow \\min(R_I, R_L - 1)$ 计算钳位后的索引。其结果 $R_C$ 对输入寄存器 $R_I$ 和 $R_L$ 存在**真数据依赖**。在处理器的执行单元计算出 $\\min$ 操作的结果之前，$R_C$ 的值是不可用的。\n2. 指令 $R_V \\leftarrow \\mathrm{load}(A + R_C)$ 执行一次内存加载。这次加载的地址是 $A + R_C$。AGU 对这个有效地址的计算依赖于 $R_C$ 的值。这构成了另一个**真数据依赖**：地址计算依赖于 $\\min$ 操作的结果。\n\n根据原则 1 和原则 2，乱序执行尊重真数据依赖，并且 AGU 在有效地址已知之前无法发出内存请求。因此，AGU 必须等待 $R_C$ 的值变得可用后，才能计算地址 $A + R_C$ 并向内存系统发出加载请求。\n\n问题明确指出没有实现硬件值预测。值预测是一种推测机制，处理器可能在一条指令（如 $R_C$）实际计算完成之前猜测其结果。在没有此功能的情况下，处理器没有机制可以推测性地绕过对 $R_C$ 的真数据依赖。处理器不能任意决定使用 $R_I$ 来代替 $R_C$ 进行地址计算，因为指令语义明确规定了使用 $R_C$。\n\n这与 Spectre 变体 1 的场景形成对比，后者利用的是**控制依赖**。一个典型的易受攻击的代码模式涉及一个条件分支，例如 `if (I  L) { load(A + I); }`。在这种情况下，处理器可能会错误预测分支的结果，并使用越界索引 $I$ 推测性地执行加载操作。所提供的代码序列将这种易受攻击的控制依赖替换为一个数据依赖，而这种数据依赖（在没有值预测的情况下）是无法被推测性地绕过的。\n\n基于以上理解，我们可以评估每个选项。\n\n### 逐项分析\n\n**A. 在上述序列中，数组加载的有效地址直到 $\\min$ 操作产生 $R_C$ 后才能形成；因此，在没有值预测的处理器上，地址为 $A + R_I$ 的瞬态越界读取不会发生，因为 AGU 在 $R_C$ 就绪之前无法发出依赖于 $R_C$ 的请求。**\n- **理由：** 这个陈述准确地反映了我们的推导。加载操作 `load(A + R_C)` 对寄存器 $R_C$ 有真数据依赖。根据原则 1 和原则 2，处理器的 AGU 必须等待 `min` 操作的结果写入 $R_C$ 后，才能计算有效地址。因为明确排除了值预测，所以没有指定的机制让处理器推测性地使用来自 $R_I$ 的未钳位值。因此，防止了在越界地址 $A+R_I$ 上的瞬态读取。\n- **结论：** **正确**。\n\n**B. 即使有 $\\min$ 钳位，AGU 也可能在 $R_C$ 仍未就绪时，推测性地使用未钳位的索引 $A + R_I$ 发出内存请求，因为地址计算推测足以绕过真数据依赖。**\n- **理由：** 这个陈述的说法与所提供的原则直接矛盾。绕过真数据依赖的“地址计算推测”是一种数据推测（如值预测）。原则 1 指出真数据依赖是必须尊重的。原则 3 阐明了通常通过推测（例如分支预测）消除的是控制依赖，而非数据依赖。如果 AGU 使用 $R_I$ 而不是 $R_C$，将违反指令定义的数据流图。\n- **结论：** **不正确**。\n\n**C. 尽管钳位访问在这种模式下可以防止瞬态越界读取，但由特权错误加载引起的 Meltdown 类泄漏并未通过此类钳位得到缓解，因为 Meltdown 涉及的是延迟的权限检查，而不是数组边界。**\n- **理由：** 这个陈述正确地区分了两类不同的漏洞。钳位机制 `min(R_I, R_L - 1)`旨在在给定的内存区域（数组 $A$）内强制执行数组边界。如原则 5 所述，Meltdown 攻击利用了处理器可能在权限违规错误被引发和处理之前，瞬态执行一条访问特权内存地址（例如内核地址）的指令这一事实。将索引钳位在*用户空间*数组的边界内，并不能防止*基地址* $A$ 本身指向特权位置，也不能防止其他形式的特权内存访问。这两种漏洞是正交的，针对一种漏洞（Spectre 风格的边界检查绕过）的缓解措施并不能缓解另一种漏洞（Meltdown）。\n- **结论：** **正确**。\n\n**D. 将无分支钳位替换为显式条件分支对于 Spectre 变体 1 来说绝对更安全，因为分支预测错误不会导致处理器瞬态地使用 $A + R_I$ 进行加载。**\n- **理由：** 这个陈述在事实上是错误的，并且歪曲了 Spectre 变体 1 的本质。典型的 Spectre 变体 1（边界检查绕过）漏洞恰恰源于用于边界检查的显式条件分支。攻击者训练分支预测器使其预期一个界内索引，然后提供一个越界索引。处理器在分支条件被解析*之前*，推测性地执行了界内索引的代码路径，导致了瞬态的越界内存访问。无分支钳位方法是针对此漏洞的一种广泛使用的*缓解*措施，因为它将可被推测绕过的控制依赖替换为更稳健的数据依赖。该陈述声称的恰恰相反，因此是错误的。\n- **结论：** **不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3679377"}, {"introduction": "安全性的提升往往伴随着性能的代价，这是一个在系统设计中无法回避的权衡。本练习 [@problem_id:3679423] 将引导你对一种硬件层面的缓解措施——推测栅栏（speculation fence）——进行性能建模。通过推导其对处理器指令吞吐率（IPC）影响的解析表达式，你将能够量化这种安全机制所带来的性能损失，从而更深刻地理解在设计和部署安全解决方案时所面临的现实挑战。", "problem": "考虑一个简化的乱序 (OoO) 超标量处理器核心，该核心用于缓解 Spectre 类推测执行漏洞。该核心的最大提交宽度为每周期 $w$ 条指令。一次分支预测错误会产生 $p$ 个周期的恢复开销，在此期间没有指令退役。作为一种缓解措施，系统在每次加载之后立即插入一个推测栅栏（例如，加载栅栏），以防止较新的指令越过该加载指令进行推测执行。假设每个栅栏都是一个串行化屏障，它会排空推测性工作并产生一个等效于 $p$ 个停顿周期的退役气泡。\n\n设动态指令流的栅栏频率为 $\\phi$，定义为每条指令的平均栅栏数。在这些假设下：\n- 不存在其他来源的停顿或缓存未命中。\n- 在不受栅栏停顿影响时，流水线能维持最大提交宽度。\n- 栅栏本身不执行有效工作，并作为普通指令退役，遵循上述停顿模型。\n\n仅使用每周期指令数 (IPC) 的基本定义（即已退役指令数除以总周期数），推导 IPC 下降量 $\\Delta \\text{IPC}$（定义为 $\\Delta \\text{IPC} = \\text{IPC}_{\\text{baseline}} - \\text{IPC}_{\\text{with fences}}$）的闭式解析表达式，使其为 $w$、$p$ 和 $\\phi$ 的函数。你的最终答案必须是仅包含 $w$、$p$ 和 $\\phi$ 的单个闭式表达式。无需进行数值近似。", "solution": "首先对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n- 最大提交宽度：每周期 $w$ 条指令。\n- 栅栏引起的停顿持续时间：每个栅栏 $p$ 个周期。\n- 栅栏频率：$\\phi$，定义为动态流中每条指令的平均栅栏数。\n- 假设：不存在其他来源的停顿或缓存未命中。\n- 假设：在没有停顿时，流水线能维持最大提交宽度 $w$。\n- 假设：栅栏作为普通指令退役。\n- IPC 的定义：$\\text{IPC} = \\frac{\\text{已退役指令数}}{\\text{总周期数}}$。\n- 待推导量：IPC 下降量 $\\Delta \\text{IPC} = \\text{IPC}_{\\text{baseline}} - \\text{IPC}_{\\text{with fences}}$。\n- 最终表达式必须是 $w$、$p$ 和 $\\phi$ 的函数。\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题在计算机体系结构原理方面有充分的依据，特别是在处理器流水线的性能建模方面。每周期指令数 (IPC)、提交宽度、推测执行和串行化栅栏等概念是该领域的标准概念。该模型是一个简化模型，这是进行一阶性能分析的一种有效且常用的技术。\n- **适定性**：问题陈述清晰，提供了推导唯一解析表达式所需的所有变量（$w$、$p$、$\\phi$）和假设。目标明确。\n- **客观性**：语言技术性强且精确，没有任何主观或非科学的陈述。\n\n### 第 3 步：结论与行动\n该问题有效。这是一个在计算机体系结构性能分析领域中适定且有科学依据的问题。继续进行求解。\n\n目标是推导 IPC 下降量 $\\Delta \\text{IPC}$ 的表达式，其定义为基线 IPC 与带有推测栅栏的 IPC 之间的差值。\n$$\n\\Delta \\text{IPC} = \\text{IPC}_{\\text{baseline}} - \\text{IPC}_{\\text{with fences}}\n$$\n\n首先，我们确定基线 IPC，即 $\\text{IPC}_{\\text{baseline}}$。在基线场景中，没有栅栏，并且根据问题陈述，没有其他停顿来源。处理器维持其每周期 $w$ 条指令的最大提交宽度。因此，基线 IPC 就是：\n$$\n\\text{IPC}_{\\text{baseline}} = w\n$$\n\n接下来，我们确定带有推测栅栏的系统的 IPC，即 $\\text{IPC}_{\\text{with fences}}$。我们使用 IPC 的基本定义。让我们考虑一个大的、具有统计代表性的执行窗口，总时间为 $T$ 个周期。这个总时间由两部分组成：有效周期（$T_{\\text{active}}$），期间指令正在退役；以及由栅栏引起的停顿周期（$T_{\\text{stall}}$）。\n$$\nT = T_{\\text{active}} + T_{\\text{stall}}\n$$\n在有效周期内，处理器以其最大速率 $w$ 退役指令。因此，退役的指令总数 $I$ 为：\n$$\nI = w T_{\\text{active}}\n$$\n问题将 $\\phi$ 定义为栅栏频率，即已退役指令中栅栏指令所占的比例。因此，在已退役指令总数 $I$ 中，栅栏指令的数量 $I_{\\text{fence}}$ 为：\n$$\nI_{\\text{fence}} = \\phi I\n$$\n每个栅栏指令引入 $p$ 个周期的停顿。总停顿时间是栅栏数量乘以每个栅栏的开销：\n$$\nT_{\\text{stall}} = I_{\\text{fence}} \\cdot p = (\\phi I) p\n$$\n现在我们可以在不同的时间分量之间建立关系。我们将 $I$ 的表达式代入 $T_{\\text{stall}}$ 的方程中：\n$$\nT_{\\text{stall}} = \\phi (w T_{\\text{active}}) p = w \\phi p T_{\\text{active}}\n$$\n我们现在可以仅用有效时间 $T_{\\text{active}}$ 来表示总时间 $T$：\n$$\nT = T_{\\text{active}} + T_{\\text{stall}} = T_{\\text{active}} + w \\phi p T_{\\text{active}} = T_{\\text{active}}(1 + w \\phi p)\n$$\n带有栅栏的 IPC 是已退役的指令总数 $I$ 除以所花费的总时间 $T$：\n$$\n\\text{IPC}_{\\text{with fences}} = \\frac{I}{T} = \\frac{w T_{\\text{active}}}{T_{\\text{active}}(1 + w \\phi p)}\n$$\n项 $T_{\\text{active}}$ 被消去，得到缓解后系统的 IPC 表达式：\n$$\n\\text{IPC}_{\\text{with fences}} = \\frac{w}{1 + w \\phi p}\n$$\n最后，我们可以通过从基线 IPC 中减去这个结果来计算 IPC 下降量 $\\Delta \\text{IPC}$：\n$$\n\\Delta \\text{IPC} = \\text{IPC}_{\\text{baseline}} - \\text{IPC}_{\\text{with fences}} = w - \\frac{w}{1 + w \\phi p}\n$$\n为了简化这个表达式，我们进行通分：\n$$\n\\Delta \\text{IPC} = \\frac{w(1 + w \\phi p)}{1 + w \\phi p} - \\frac{w}{1 + w \\phi p}\n$$\n$$\n\\Delta \\text{IPC} = \\frac{w + w^2 \\phi p - w}{1 + w \\phi p}\n$$\n$$\n\\Delta \\text{IPC} = \\frac{w^2 \\phi p}{1 + w \\phi p}\n$$\n这就是作为指定参数函数的 IPC 下降量的最终闭式解析表达式。", "answer": "$$\n\\boxed{\\frac{w^{2} \\phi p}{1 + w \\phi p}}\n$$", "id": "3679423"}]}