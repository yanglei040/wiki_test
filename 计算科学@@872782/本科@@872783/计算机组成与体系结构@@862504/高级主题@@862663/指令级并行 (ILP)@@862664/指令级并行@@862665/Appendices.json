{"hands_on_practices": [{"introduction": "本练习旨在阐明一个核心概念：即使在理想的处理器上，真实的指令数据依赖关系也会形成“关键路径”，从而从根本上限制执行速度。通过模拟调度来自不同依赖链的指令，你将亲手计算总执行周期和最终的每周期指令数（$IPC$），这是衡量指令级并行（ILP）的关键指标。这项练习能帮助你直观地理解超标量处理器如何并行执行多个依赖链以利用$ILP$ [@problem_id:3651239]。", "problem": "考虑一个在利用指令级并行（ILP）的超标量处理器上调度的基本块。该处理器每个周期最多可以发射 $w=3$ 条指令，具有完美的分支预测，执行寄存器重命名以消除命名冒险，并且没有内存停顿或缓存未命中。假设所有功能单元的延迟都是一个周期，并且依赖于前驱指令的指令只能在前驱指令被发射之后的一个周期内严格地发射。\n\n该基本块由三个不相交的真数据依赖链组成：\n- 链 $\\mathcal{A}$：指令 $A_1 \\rightarrow A_2 \\rightarrow A_3 \\rightarrow A_4 \\rightarrow A_5$，\n- 链 $\\mathcal{B}$：指令 $B_1 \\rightarrow B_2 \\rightarrow B_3 \\rightarrow B_4$，\n- 链 $\\mathcal{C}$：指令 $C_1 \\rightarrow C_2 \\rightarrow C_3 \\rightarrow C_4 \\rightarrow C_5 \\rightarrow C_6$，\n\n以及一条最终指令 $X$，它依赖于每个链的最后一条指令，即 $X$ 对 $A_5$、$B_4$ 和 $C_6$ 有真数据依赖。没有其他链间依赖。\n\n定义“并行阶段”为处理器恰好发射 $w$ 条指令的任何周期。在一个遵循所述约束的理想乱序调度器下，确定：\n1. 在基本块执行期间的并行阶段数。\n2. 预期的每周期指令数（IPC），定义为基本块中动态指令总数与发射整个块所需的总周期数之比。\n\n将IPC表示为精确值。无需四舍五入。最终答案应以纯数字形式给出，不带单位。", "solution": "基本块中的动态指令总数是三个链的长度之和加上最终指令 $X$：\n$$ N_{instr} = 5 + 4 + 6 + 1 = 16 $$\n\n为了确定以周期为单位的总执行时间以及并行阶段的数量，我们模拟了在一个理想的乱序处理器上指令的调度过程。该处理器每个周期可以从可用指令集中发射最多 $w=3$ 条指令。一条指令在其所有父依赖项被发射的周期之后的下一个周期变为可用。\n\n- **周期 $1$**：每个链的第一条指令，$A_1$、$B_1$ 和 $C_1$，在基本块内没有前驱，因此已准备好被发射。处理器可以发射所有 $3$ 条。\n  - 已发射：$\\{A_1, B_1, C_1\\}$。发射的指令数：$3$。\n  - 这是一个并行阶段。\n\n- **周期 $2$**：指令 $A_2$、$B_2$ 和 $C_2$ 变为可用，因为它们各自的前驱在周期 $1$ 被发射。处理器可以发射所有 $3$ 条。\n  - 已发射：$\\{A_2, B_2, C_2\\}$。发射的指令数：$3$。\n  - 这是一个并行阶段。\n\n- **周期 $3$**：指令 $A_3$、$B_3$ 和 $C_3$ 变为可用。处理器发射所有 $3$ 条。\n  - 已发射：$\\{A_3, B_3, C_3\\}$。发射的指令数：$3$。\n  - 这是一个并行阶段。\n\n- **周期 $4$**：指令 $A_4$、$B_4$ 和 $C_4$ 变为可用。处理器发射所有 $3$ 条。\n  - 已发射：$\\{A_4, B_4, C_4\\}$。发射的指令数：$3$。\n  - 链 $\\mathcal{B}$ 现在已完全发射。\n  - 这是一个并行阶段。\n\n- **周期 $5$**：链 $\\mathcal{B}$ 已完成。可用的指令是 $A_5$ (来自 $A_4$) 和 $C_5$ (来自 $C_4$)。处理器发射这两条指令。\n  - 已发射：$\\{A_5, C_5\\}$。发射的指令数：$2$。\n  - 链 $\\mathcal{A}$ 现在已完全发射。\n\n- **周期 $6$**：链 $\\mathcal{A}$ 已完成。唯一可用的指令是 $C_6$ (来自 $C_5$)。\n  - 已发射：$\\{C_6\\}$。发射的指令数：$1$。\n  - 链 $\\mathcal{C}$ 现在已完全发射。\n\n- **周期 $7$**：最终指令 $X$ 依赖于 $A_5$、$B_4$ 和 $C_6$。这些指令分别在周期 $5$、$4$ 和 $6$ 被发射。$X$ 只能在其最晚的依赖项 $C_6$ 被发射后才能发射。因此，$X$ 在周期 $6+1 = 7$ 变为可用。\n  - 已发射：$\\{X\\}$。发射的指令数：$1$。\n\n所有 $16$ 条指令都已被发射。执行在周期 $7$ 的末尾完成。\n执行的总周期数为 $N_{cycles} = 7$。\n\n**1. 并行阶段的数量：**\n并行阶段是恰好发射 $w=3$ 条指令的周期。根据我们的模拟，周期 $1$、$2$、$3$ 和 $4$ 符合此标准。\n因此，并行阶段的数量为 $4$。\n\n**2. 预期的每周期指令数（IPC）：**\nIPC 定义为总指令数与总周期数的比率。\n$$ \\text{IPC} = \\frac{N_{instr}}{N_{cycles}} = \\frac{16}{7} $$\n\n执行的关键路径由最长的依赖路径决定，即链 $\\mathcal{C}$ 后跟指令 $X$。该路径为 $C_1 \\rightarrow C_2 \\rightarrow C_3 \\rightarrow C_4 \\rightarrow C_5 \\rightarrow C_6 \\rightarrow X$。此路径包含 $7$ 条指令。由于一周期依赖延迟，该路径至少需要 $7$ 个周期来执行，这证实了我们的逐周期分析。", "answer": "$$\\boxed{\\begin{pmatrix} 4  \\frac{16}{7} \\end{pmatrix}}$$", "id": "3651239"}, {"introduction": "并非所有指令依赖都是生而平等的。此实践将带你区分真实的“读后写”（RAW）数据依赖与因寄存器复用而产生的“伪”名称依赖（“写后读”WAR和“写后写”WAW）。你将分析一段代码在有和没有寄存器重命名两种处理器上的表现，从而量化这一关键架构特性如何通过打破伪依赖来显著提升指令级并行度（$ILP$）[@problem_id:3651255]。", "problem": "您正在分析一个基本块在两台其他方面完全相同的乱序（OoO）处理器上的指令级并行（ILP）。机器 $\\mathcal{M}_0$ 没有寄存器重命名，因此必须遵守所有名称相关（写后写和读后写），而机器 $\\mathcal{M}_1$ 具有完美的寄存器重命名，可以消除所有名称相关，同时保留真正的数据相关（写后读）。假设一个理想化的流水线，具有无限的发射宽度、无限的功能单元、完美的分支预测，并且没有缓存或结构性停顿。每条算术指令的延迟为 $1$ 个周期。在这些假设下，指令级并行（ILP）被定义为该基本块每个周期完成的平均指令数。\n\n考虑以下由 $8$ 个整数加法组成的按给定静态程序顺序排列的基本块，其中 $R_x$ 表示体系结构寄存器，每行是一条指令：\n- $I_1$: $R_1 \\leftarrow R_2 + R_3$\n- $I_2$: $R_4 \\leftarrow R_1 + R_5$\n- $I_3$: $R_4 \\leftarrow R_4 + R_7$\n- $I_4$: $R_8 \\leftarrow R_4 + R_9$\n- $I_5$: $R_1 \\leftarrow R_{10} + R_{11}$\n- $I_6$: $R_4 \\leftarrow R_1 + R_{13}$\n- $I_7$: $R_4 \\leftarrow R_4 + R_{15}$\n- $I_8$: $R_{16} \\leftarrow R_4 + R_{17}$\n\n任务：\n- 仅使用动态调度中相关类型的核心定义，识别此块中哪些指令间边缘是真正的数据相关（写后读，RAW），哪些是伪名称相关（读后写，WAR；写后写，WAW）在 $\\mathcal{M}_0$ 上。\n- 基于这些相关性，确定在 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上执行该块所需的最短完成时间（以周期为单位）。对于 $\\mathcal{M}_1$，假设完美的寄存器重命名，通过为逻辑上独立的结果分配不同的物理寄存器来消除所有 WAR 和 WAW 约束，同时保留所有 RAW 相关。\n- 令 $ILP_0$ 和 $ILP_1$ 分别表示 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上的指令级并行，计算公式为 $ILP = \\dfrac{N}{T}$，其中 $N$ 是块中的指令数，T 是在所述模型下完成该块所需的最少周期数。\n\n数值增量 $\\Delta ILP = ILP_1 - ILP_0$ 是多少？请用一个精确的既约分数表示您的答案。不需要四舍五入，也不需要单位。", "solution": "该问题要求分析一个给定的基本块在两种不同的乱序处理器 $\\mathcal{M}_0$ 和 $\\mathcal{M}_1$ 上的指令级并行（ILP）。ILP 定义为 $ILP = \\frac{N}{T}$，其中 $N$ 是指令数，T 是以周期为单位的最短执行时间。该块包含 $N=8$ 条指令，每条指令的延迟为 1 个周期。在周期 $c$ 开始的指令的结果，在周期 $c+1$ 开始时对相关指令可用。\n\n首先，我们必须识别没有寄存器重命名的处理器 $\\mathcal{M}_0$ 的所有指令间相关。这些相关被分为真正的数据相关（写后读，RAW）、反相关（读后写，WAR）和输出相关（写后写，WAW）。\n\n指令序列如下：\n$I_1: R_1 \\leftarrow R_2 + R_3$\n$I_2: R_4 \\leftarrow R_1 + R_5$\n$I_3: R_4 \\leftarrow R_4 + R_7$\n$I_4: R_8 \\leftarrow R_4 + R_9$\n$I_5: R_1 \\leftarrow R_{10} + R_{11}$\n$I_6: R_4 \\leftarrow R_1 + R_{13}$\n$I_7: R_4 \\leftarrow R_4 + R_{15}$\n$I_8: R_{16} \\leftarrow R_4 + R_{17}$\n\n**1. 机器 $\\mathcal{M}_0$ 的相关性分析（无寄存器重命名）**\n\n我们识别所有具有相关的指令对 $(I_i, I_j)$，其中 $j > i$。\n\n- **真正的数据相关 (RAW):** $I_i$ 写入一个寄存器，而 $I_j$ 读取该寄存器。\n  - $(I_1, I_2)$ 在 $R_1$ 上：$I_1$ 写入 $R_1$，$I_2$ 读取 $R_1$。\n  - $(I_2, I_3)$ 在 $R_4$ 上：$I_2$ 写入 $R_4$，$I_3$ 读取 $R_4$。\n  - $(I_3, I_4)$ 在 $R_4$ 上：$I_3$ 写入 $R_4$，$I_4$ 读取 $R_4$。\n  - $(I_5, I_6)$ 在 $R_1$ 上：$I_5$ 写入 $R_1$，$I_6$ 读取 $R_1$。\n  - $(I_6, I_7)$ 在 $R_4$ 上：$I_6$ 写入 $R_4$，$I_7$ 读取 $R_4$。\n  - $(I_7, I_8)$ 在 $R_4$ 上：$I_7$ 写入 $R_4$，$I_8$ 读取 $R_4$。\n\n- **反相关 (WAR):** $I_i$ 读取一个寄存器，而 $I_j$ 写入该寄存器。\n  - $(I_2, I_5)$ 在 $R_1$ 上：$I_2$ 读取 $R_1$，$I_5$ 写入 $R_1$。\n  - $(I_3, I_6)$ 在 $R_4$ 上：$I_3$ 读取 $R_4$，$I_6$ 写入 $R_4$。\n  - $(I_3, I_7)$ 在 $R_4$ 上：$I_3$ 读取 $R_4$，$I_7$ 写入 $R_4$。\n  - $(I_4, I_6)$ 在 $R_4$ 上：$I_4$ 读取 $R_4$，$I_6$ 写入 $R_4$。\n  - $(I_4, I_7)$ 在 $R_4$ 上：$I_4$ 读取 $R_4$，$I_7$ 写入 $R_4$。\n\n- **输出相关 (WAW):** $I_i$ 和 $I_j$ 都写入同一个寄存器。处理器必须确保寄存器中的最终值与程序顺序中的最后一次写入相对应。\n  - $(I_1, I_5)$ 在 $R_1$ 上。\n  - 在 $R_4$ 上，指令 $I_2, I_3, I_6, I_7$ 都会写入。这产生了以下 WAW 相关：$(I_2, I_3)$、$(I_2, I_6)$、$(I_2, I_7)$、$(I_3, I_6)$、$(I_3, I_7)$ 和 $(I_6, I_7)$。注意，其中一些对也存在 RAW 相关（例如，$(I_2,I_3)$），这是一个更强的约束。\n\n**2. 在机器 $\\mathcal{M}_0$ 上的执行时间**\n\n最小执行时间由完整相关图中的关键路径决定。从 $I_i$ 到 $I_j$ 的一条边意味着 $I_j$ 可以在 $I_i$ 完成的周期或之后开始。令 $S(I_k)$ 为指令 $I_k$ 的开始周期（从 $S=0$ 开始），$C(I_k) = S(I_k) + 1$ 为其完成周期。\n\n- $S(I_1) = 0$。$C(I_1) = 1$。\n- $S(I_2) \\geq C(I_1)$ (RAW)。$\\implies S(I_2) = 1, C(I_2) = 2$。\n- $S(I_3) \\geq C(I_2)$ (RAW)。$\\implies S(I_3) = 2, C(I_3) = 3$。\n- $S(I_4) \\geq C(I_3)$ (RAW)。$\\implies S(I_4) = 3, C(I_4) = 4$。\n- $S(I_5) \\geq C(I_2)$ (在 $R_1$ 上的 WAR)。并且 $S(I_5) \\geq C(I_1)$ (在 $R_1$ 上的 WAW)。由于 $C(I_2) > C(I_1)$，WAR 相关是约束性条件。$\\implies S(I_5) = 2, C(I_5) = 3$。\n- $S(I_6)$ 依赖于多个前驱指令：\n    - $S(I_6) \\geq C(I_5)$ (在 $R_1$ 上的 RAW)。所以 $S(I_6) \\geq 3$。\n    - $S(I_6) \\geq C(I_4)$ (在 $R_4$ 上的 WAR)。所以 $S(I_6) \\geq 4$。\n    - $S(I_6) \\geq C(I_3)$ (在 $R_4$ 上的 WAW 和 WAR)。所以 $S(I_6) \\geq 3$。\n    最严格的约束来自 $I_4$，所以 $S(I_6) \\geq \\max(3, 4, 3) = 4$。$\\implies S(I_6) = 4, C(I_6) = 5$。\n- $S(I_7) \\geq C(I_6)$ (RAW)。$\\implies S(I_7) = 5, C(I_7) = 6$。\n- $S(I_8) \\geq C(I_7)$ (RAW)。$\\implies S(I_8) = 6, C(I_8) = 7$。\n\n最后一条指令 $I_8$ 在周期 7 完成。在 $\\mathcal{M}_0$ 上执行该块的总时间为 $T_0 = 7$ 个周期。\nILP 为 $ILP_0 = \\frac{N}{T_0} = \\frac{8}{7}$。\n\n**3. 在机器 $\\mathcal{M}_1$ 上的执行时间（完美寄存器重命名）**\n\n在机器 $\\mathcal{M}_1$ 上，完美的寄存器重命名消除了所有 WAR 和 WAW 相关。只有 RAW 相关保留下来。\nRAW 相关将指令划分为两个独立的链：\n- 链 A: $I_1 \\rightarrow_{RAW} I_2 \\rightarrow_{RAW} I_3 \\rightarrow_{RAW} I_4$。\n- 链 B: $I_5 \\rightarrow_{RAW} I_6 \\rightarrow_{RAW} I_7 \\rightarrow_{RAW} I_8$。\n\n在无限资源的情况下，这两个链并行执行。总执行时间由较长链的长度决定。\n- 链 A 的长度是其 4 条指令的延迟之和，即 $1+1+1+1 = 4$ 个周期。\n- 链 B 的长度是其 4 条指令的延迟之和，即 $1+1+1+1 = 4$ 个周期。\n\n两个链的长度相等。执行过程如下：\n- 周期 1：$I_1$ 和 $I_5$ 执行。\n- 周期 2：$I_2$ 和 $I_6$ 执行。\n- 周期 3：$I_3$ 和 $I_7$ 执行。\n- 周期 4：$I_4$ 和 $I_8$ 执行。\n\n所有指令在周期 4 结束时完成。总执行时间为 $T_1 = 4$ 个周期。\nILP 为 $ILP_1 = \\frac{N}{T_1} = \\frac{8}{4} = 2$。\n\n**4. $\\Delta ILP$ 的计算**\n\nILP 的数值增量为 $\\Delta ILP = ILP_1 - ILP_0$。\n$\\Delta ILP = 2 - \\frac{8}{7}$\n为了进行减法，我们找到一个公分母：\n$\\Delta ILP = \\frac{14}{7} - \\frac{8}{7} = \\frac{14 - 8}{7} = \\frac{6}{7}$。\n结果是所要求的精确既约分数。", "answer": "$$\\boxed{\\frac{6}{7}}$$", "id": "3651255"}, {"introduction": "即使消除了所有伪依赖，处理器的性能仍然受限于其物理硬件资源。这个最终练习模拟了一个更贴近现实的场景，你必须在一个功能单元（如整数算术逻辑单元和浮点运算单元）数量有限的处理器上调度指令。通过这个练习，你将学会如何在数据依赖和资源可用性之间进行权衡，以找出最佳执行方案和最短完成时间[@problem_id:3651272]。", "problem": "超标量处理器通过在同一个时钟周期内发射多个独立操作来利用指令级并行（ILP），但这受限于功能单元的可用性和数据依赖约束。考虑在一个具有以下属性的处理器上调度一个基本块：\n- 有 $2$ 个相同的整数算术逻辑单元（ALU）和 $1$ 个浮点（FP）单元。\n- 所有单元都是完全流水线化的，因此每个单元每周期最多能接收一个新操作。\n- 整数ALU操作的延迟为 $1$ 个周期。\n- 浮点加法延迟为 $3$ 个周期，浮点乘法延迟为 $4$ 个周期。\n- 一个操作产生的操作数在该操作发射后恰好 $d$ 个周期变为可用，其中 $d$ 是该操作的延迟。一个依赖的消费者可以在其最后一个操作数变为可用的同一周期内发射。\n- 不存在内存操作和控制依赖，并且寄存器被完全重命名，从而消除了伪依赖（无读后写或写后写冲突）。只有真数据依赖适用。\n\n该基本块包含以下操作。每行列出操作标签、操作类型及其显式真依赖：\n- $I_1$：整数加法，不依赖于任何先前的操作。\n- $I_2$：整数加法，不依赖于任何先前的操作。\n- $I_3$：整数加法，依赖于 $I_1$。\n- $I_4$：整数加法，依赖于 $I_1$ 和 $I_2$。\n- $I_5$：整数加法，依赖于 $I_3$ 和 $I_4$。\n- $F_1$：浮点乘法，不依赖于任何先前的操作。\n- $F_2$：浮点加法，不依赖于任何先前的操作。\n- $F_3$：浮点加法，依赖于 $F_1$ 和 $F_2$。\n- $F_4$：浮点乘法，依赖于 $F_3$。\n- $F_5$：浮点加法，依赖于 $F_4$ 和 $F_1$。\n\n假设在所述约束下允许乱序发射，并且整数操作必须分配给整数ALU，而浮点操作必须分配给FP单元。从周期 $0$ 开始，在满足给定约束并最大化ILP的最优调度下，确定最小完工时间 $M$。$M$ 定义为基本块中所有操作都已完成（所有结果都已就绪）的最早周期。请用一个表示周期的整数作答，不带单位。", "solution": "该问题要求确定一组指令在具有特定功能单元和延迟特性的超标量处理器上执行的最小完工时间。完工时间 $M$ 定义为所有操作都已完成（即它们的结果都已可用）的最早周期。调度必须同时遵守真数据依赖和资源约束。\n\n首先，让我们将问题形式化。给定一组操作及其数据依赖关系，这些关系可以用一个有向无环图（DAG）表示。对于每个操作 $O$，我们知道其类型（整数或浮点）、延迟 $d(O)$，以及它所依赖的操作集合 $Dependencies(O)$。\n\n处理器具有以下资源：\n- $2$ 个整数算术逻辑单元（ALU）。\n- $1$ 个浮点（FP）单元。\n\n操作延迟如下：\n- 整数加法（$d_{int}$）：$1$ 个周期。\n- 浮点加法（$d_{fp\\_add}$）：$3$ 个周期。\n- 浮点乘法（$d_{fp\\_mult}$）：$4$ 个周期。\n\n令 $Issue(O)$ 为操作 $O$ 被发射的时钟周期。操作 $O$ 的结果在周期 $Ready(O)$ 变为可用，定义为：\n$$Ready(O) = Issue(O) + d(O)$$\n\n调度的约束条件是：\n1.  **数据依赖约束**：一个操作 $O$ 必须等到它所依赖的所有操作的结果都可用后才能发射。\n    $$Issue(O) \\ge \\max_{P \\in Dependencies(O)} \\{Ready(P)\\}$$\n    如果一个操作没有依赖项，它可以从周期 $0$ 开始发射。\n\n2.  **资源约束**：在任何给定的周期 $c$ 中，发射的整数操作数量不能超过 $2$ 个，发射的浮点操作数量不能超过 $1$ 个。\n\n目标是找到一个最优调度，以最小化完工时间 $M$，其中：\n$$M = \\max_{O} \\{Ready(O)\\}$$\n\n完工时间的一个下界是数据依赖图中的关键路径长度。关键路径是从任何初始操作（无依赖）到任何最终操作的最长路径，路径长度是该路径上所有操作延迟的总和。我们来计算最长数据依赖链的长度，它代表了在假设资源无限的情况下每条指令的最早完成时间。这也被称为关键路径分析。\n\n令 $C(O)$ 为仅基于数据依赖关系的操作 $O$ 的最早可能完成时间（就绪时间）。如果 $O$ 没有依赖项，则假设其在周期 $0$ 发射，$C(O) = d(O)$。否则，$C(O) = \\left( \\max_{P \\in Dependencies(O)} \\{C(P)\\} \\right) + d(O)$。\n\n让我们为所有指令计算这些值。\n对于整数操作（所有操作的 $d_{int} = 1$）：\n- $Dependencies(I_1) = \\emptyset \\implies C(I_1) = 0 + d(I_1) = 1$。\n- $Dependencies(I_2) = \\emptyset \\implies C(I_2) = 0 + d(I_2) = 1$。\n- $Dependencies(I_3) = \\{I_1\\} \\implies C(I_3) = C(I_1) + d(I_3) = 1 + 1 = 2$。\n- $Dependencies(I_4) = \\{I_1, I_2\\} \\implies C(I_4) = \\max(C(I_1), C(I_2)) + d(I_4) = \\max(1, 1) + 1 = 2$。\n- $Dependencies(I_5) = \\{I_3, I_4\\} \\implies C(I_5) = \\max(C(I_3), C(I_4)) + d(I_5) = \\max(2, 2) + 1 = 3$。\n\n对于浮点操作：\n- $Dependencies(F_1) = \\emptyset \\implies C(F_1) = 0 + d(F_1) = 0 + 4 = 4$。\n- $Dependencies(F_2) = \\emptyset \\implies C(F_2) = 0 + d(F_2) = 0 + 3 = 3$。\n- $Dependencies(F_3) = \\{F_1, F_2\\} \\implies C(F_3) = \\max(C(F_1), C(F_2)) + d(F_3) = \\max(4, 3) + 3 = 4 + 3 = 7$。\n- $Dependencies(F_4) = \\{F_3\\} \\implies C(F_4) = C(F_3) + d(F_4) = 7 + 4 = 11$。\n- $Dependencies(F_5) = \\{F_4, F_1\\} \\implies C(F_5) = \\max(C(F_4), C(F_1)) + d(F_5) = \\max(11, 4) + 3 = 11 + 3 = 14$。\n\n这些最早完成时间的最大值是 $C(F_5) = 14$。这就为完工时间建立了一个下界：$M \\ge 14$。现在，我们必须确定是否存在一个能够达到此完工时间同时又遵守资源约束的调度。我们将使用贪心列表调度算法来构建一个调度，优先处理已准备好发射的操作。\n\n让我们从周期 $0$ 开始，逐周期地跟踪调度。\n\n**周期 0：**\n- 可发射：$\\{I_1, I_2, F_1, F_2\\}$（无依赖）。\n- 资源：$2$ 个ALU， $1$ 个FP单元。\n- 调度：发射 $I_1$ (ALU1)、$I_2$ (ALU2)、$F_1$ (FP单元)。$F_2$ 必须等待。\n- 已发射操作的完成时间：\n  - $Ready(I_1) = Issue(I_1) + d(I_1) = 0 + 1 = 1$。\n  - $Ready(I_2) = Issue(I_2) + d(I_2) = 0 + 1 = 1$。\n  - $Ready(F_1) = Issue(F_1) + d(F_1) = 0 + 4 = 4$。\n\n**周期 1：**\n- 可发射：$\\{I_3, I_4, F_2\\}$。\n  - $I_3$ 已就绪，因为其依赖 $I_1$ 在周期 $1$ 就绪。\n  - $I_4$ 已就绪，因为其依赖 $I_1, I_2$ 在周期 $1$ 就绪。\n  - $F_2$ 在周期 $0$ 时已就绪，但由于资源争用而未被发射。\n- 资源：$2$ 个ALU， $1$ 个FP单元。\n- 调度：发射 $I_3$ (ALU1)、$I_4$ (ALU2)、$F_2$ (FP单元)。\n- 已发射操作的完成时间：\n  - $Ready(I_3) = Issue(I_3) + d(I_3) = 1 + 1 = 2$。\n  - $Ready(I_4) = Issue(I_4) + d(I_4) = 1 + 1 = 2$。\n  - $Ready(F_2) = Issue(F_2) + d(F_2) = 1 + 3 = 4$。\n\n**周期 2：**\n- 可发射：$\\{I_5\\}$。\n  - $I_5$ 已就绪，因为其依赖 $I_3, I_4$ 在周期 $2$ 就绪。\n- 资源：$2$ 个ALU， $1$ 个FP单元。\n- 调度：发射 $I_5$ (ALU1)。\n- 已发射操作的完成时间：\n  - $Ready(I_5) = Issue(I_5) + d(I_5) = 2 + 1 = 3$。\n\n**周期 3：**\n- 可发射：$\\emptyset$。没有指令的所有数据依赖都已满足。\n  - $F_3$ 需要 $F_1$ （在周期 $4$ 就绪）和 $F_2$ （在周期 $4$ 就绪）。\n\n**周期 4：**\n- 可发射：$\\{F_3\\}$。\n  - $F_3$ 已就绪，因为 $\\max(Ready(F_1), Ready(F_2)) = \\max(4, 4) = 4$。\n- 资源：$1$ 个FP单元。\n- 调度：发射 $F_3$ (FP单元)。\n- 已发射操作的完成时间：\n  - $Ready(F_3) = Issue(F_3) + d(F_3) = 4 + 3 = 7$。\n\n**周期 5, 6：**\n- 可发射：$\\emptyset$。\n  - $F_4$ 需要 $F_3$，它将在周期 $7$ 就绪。\n\n**周期 7：**\n- 可发射：$\\{F_4\\}$。\n  - $F_4$ 已就绪，因为 $Ready(F_3) = 7$。\n- 资源：$1$ 个FP单元。\n- 调度：发射 $F_4$ (FP单元)。\n- 已发射操作的完成时间：\n  - $Ready(F_4) = Issue(F_4) + d(F_4) = 7 + 4 = 11$。\n\n**周期 8, 9, 10：**\n- 可发射：$\\emptyset$。\n  - $F_5$ 需要 $F_4$ (在周期 $11$ 就绪) 和 $F_1$ (在周期 $4$ 就绪)。\n\n**周期 11：**\n- 可发射：$\\{F_5\\}$。\n  - $F_5$ 已就绪，因为 $\\max(Ready(F_4), Ready(F_1)) = \\max(11, 4) = 11$。\n- 资源：$1$ 个FP单元。\n- 调度：发射 $F_5$ (FP单元)。\n- 已发射操作的完成时间：\n  - $Ready(F_5) = Issue(F_5) + d(F_5) = 11 + 3 = 14$。\n\n所有操作现已调度完毕。我们可以通过找到所有操作中的最大就绪时间来确定总完工时间。\n各操作的就绪时间为：\n- $Ready(I_1) = 1$\n- $Ready(I_2) = 1$\n- $Ready(I_3) = 2$\n- $Ready(I_4) = 2$\n- $Ready(I_5) = 3$\n- $Ready(F_1) = 4$\n- $Ready(F_2) = 4$\n- $Ready(F_3) = 7$\n- $Ready(F_4) = 11$\n- $Ready(F_5) = 14$\n\n完工时间是 $M = \\max(1, 1, 2, 2, 3, 4, 4, 7, 11, 14) = 14$。\n\n此调度满足所有资源和数据依赖约束。由于所达到的 $14$ 个周期的完工时间等于关键路径分析确定的下界，因此该调度是最优的，最小完工时间为 $14$ 个周期。", "answer": "$$\n\\boxed{14}\n$$", "id": "3651272"}]}