{"hands_on_practices": [{"introduction": "在多发射处理器的世界里，性能的提升本质上是在两个限制之间寻求平衡：程序固有的数据依赖链（即关键路径）的长度，以及可供利用的指令级并行度（ILP）。本练习通过一个理想化的场景，帮助你建立起对这一核心思想的直观理解。你将亲手计算一个纯粹的依赖链的执行时间，并探索如何通过插入独立的指令[@problem_id:3661275]来“隐藏”其延迟，从而有效提升处理器的指令执行效率（$IPC$）。", "problem": "考虑一个超标量多发射处理器，其发射宽度为 $W=4$，在满足依赖关系的前提下，每个周期最多可发射 $W$ 条指令。假设有一个完全流水线化的算术逻辑单元 (ALU)，每条 ALU 指令的延迟为一个周期，并且前递机制确保了依赖于前一条指令结果的指令可以在紧接着的下一个周期内发射，无需停顿。该处理器实现了乱序执行 (OoOE)，具有完美的寄存器重命名、完美的分支预测，并且没有缓存或内存停顿，因此只有真数据依赖和有限的发射宽度会限制指令调度。\n\n给定一个微内核，它由一个包含 $D=10$ 条 ALU 指令的纯依赖链组成，其中每条指令都依赖于其前一条指令的结果。在第一部分中，内核中没有其他指令。在第二部分中，假设我们额外有 $k$ 条 ALU 指令，这些指令与所有其他指令完全独立，并且可以在相同的硬件假设下任意交错以最大化吞吐量。\n\n- 根据第一性原理以及发射宽度和指令级并行度的核心定义，推导在该 $W=4$ 处理器上完成这个包含 $D=10$ 条指令的依赖链所需的最少周期数。\n- 然后，推导每周期指令数 (IPC) 的最佳可实现提升的闭式表达式，该提升定义为 $D+k$ 条指令混合情况下的 IPC 与仅有 $D$ 条指令的基准情况下的 IPC 之比，并表示为 $k$ 的函数。\n\n第一部分的结果请提供一个整数，表示最少周期数；第二部分的结果请提供一个关于 $k$ 的闭式解析表达式，表示 IPC 的提升。无需四舍五入，且不涉及物理单位。请按指定格式表达最终答案。", "solution": "题目要求关于超标量处理器性能的两个结果。首先是执行一个严格依赖链所需的时间。其次是当加入独立指令时 IPC 的提升。我们首先分析题目所描述的处理器的约束和能力。\n\n该处理器的发射宽度为 $W=4$，意味着每个周期最多可以发射 4 条指令。执行是乱序的，并具有完美的寄存器重命名，这消除了除真数据依赖（写后读）之外的所有依赖关系。题目通过假设完美的分支预测和无内存停顿来简化环境，因此性能仅受指令依赖和有限的发射宽度限制。ALU 指令具有 1 个周期的延迟，并且完全前递允许依赖于某条指令的后续指令在该指令发射后的紧邻周期内发射。\n\n### 第一部分：D 条指令链的最小周期数\n\n设这个由 $D=10$ 条指令组成的纯依赖链表示为 $I_1, I_2, \\dots, I_{10}$。其依赖结构为，对于 $j \\in \\{1, 2, \\dots, 9\\}$，指令 $I_{j+1}$ 需要 $I_j$ 的结果。\n\n处理器处理依赖关系的能力是关键。题目规定，1 个周期的延迟加上完全前递意味着“依赖于前一条指令结果的指令可以在紧接着的下一个周期内发射”。让我们根据这条规则追踪该链的执行过程：\n\n- 在周期 $c=1$，指令 $I_1$ 可以被发射。\n- 在周期 $c=2$，由于 $I_2$ 依赖于 $I_1$，它可以被发射。处理器的乱序能力和前递逻辑使得 $I_1$ 的结果可用于 $I_2$ 的执行。\n- 这个模式会持续下去。对于链中的任何指令 $I_j$，它可以在周期 $c=j$ 被发射。\n\n因此，指令的发射情况如下：\n- $I_1$ 在周期 1 发射。\n- $I_2$ 在周期 2 发射。\n- ...\n- $I_{10}$ 在周期 10 发射。\n\n发射宽度 $W=4$ 并不能加速这个序列，因为链本身内部没有指令级并行 (ILP)。在任何给定的周期，序列中只有一条指令准备好被发射。该周期中其他 $W-1=3$ 个发射槽将保持未使用状态。\n\n题目要求的是*完成*该链所需的周期数。一条 ALU 指令有 1 个周期的延迟。假设这意味着在周期 $c$ 发射的指令在周期 $c$ 结束时完成执行，那么整个序列的完成时间由最后一条指令 $I_{10}$ 的完成时间决定。\n\n由于 $I_{10}$ 在周期 10 发射，它在周期 10 结束时完成。因此，完成这个包含 $D=10$ 条指令的链所需的最少周期数是 10。\n\n通常来说，对于一个长度为 $D$ 的依赖链，其中每个依赖环节的发射延迟为 1 个周期，总时间为 $D$ 个周期。\n对于此部分，当 $D=10$ 时，周期数为 10。\n\n### 第二部分：增加 k 条独立指令后的 IPC 提升\n\n首先，我们建立仅有 $D=10$ 条指令链的基准性能。\n- 指令数，$N_{\\text{base}} = D = 10$。\n- 周期数，$C_{\\text{base}} = D = 10$（来自第一部分）。\n- 基准每周期指令数，$\\text{IPC}_{\\text{base}} = \\frac{N_{\\text{base}}}{C_{\\text{base}}} = \\frac{10}{10} = 1$。\n\n接下来，我们分析增加了 $k$ 条完全独立的 ALU 指令的新场景。\n- 指令总数，$N_{\\text{new}} = D+k = 10+k$。\n- 我们必须找到执行这 $D+k$ 条指令混合所需的最小周期数 $C_{\\text{new}}$。\n\n在超标量处理器上执行一段代码的执行时间基本上受两个因素制约：关键路径长度（深度/跨度）和所需的总工作量（work）。\n1.  **深度约束：** 执行时间必须至少是最长依赖计算链的长度。在这种情况下，关键路径是 $D$ 条指令的依赖链，根据第一部分的分析，这需要 $D$ 个周期。因此，$C_{\\text{new}} \\ge D$。\n2.  **工作量约束：** 处理器每个周期最多可以执行 $W$ 条指令。要执行总共 $N_{\\text{new}} = D+k$ 条指令，周期数必须至少是总指令数除以发射宽度。因此，$C_{\\text{new}} \\ge \\lceil \\frac{D+k}{W} \\rceil$。\n\n结合这两个下界，可能的最小周期数是这两者中的最大值：\n$$C_{\\text{new}} \\ge \\max\\left(D, \\left\\lceil \\frac{D+k}{W} \\right\\rceil\\right)$$\n对于一个理想的乱序调度器，这个下界是可以达到的。调度器可以优先处理关键路径上的指令 ($I_j$)，同时利用剩余的发射槽来执行独立指令。\n- 在每个周期 $j \\in \\{1, \\dots, D\\}$，调度器发射 $I_j$。这会消耗一个发射槽。\n- 在这 $D$ 个周期中，每个周期剩余的 $W-1$ 个发射槽可用于执行 $k$ 条独立指令。\n- 如果 $D \\ge \\lceil \\frac{D+k}{W} \\rceil$，可简化为 $k \\le D(W-1)$，那么在前 $D$ 个周期内有足够的“空闲”槽来执行所有 $k$ 条独立指令。执行在 $I_D$ 完成时结束，因此 $C_{\\text{new}} = D$。\n- 如果 $D  \\lceil \\frac{D+k}{W} \\rceil$，可简化为 $k > D(W-1)$，那么指令总数是限制因素。所有 $D$ 条关键路径指令和 $D(W-1)$ 条独立指令会在前 $D$ 个周期内发射。剩余的 $k - D(W-1)$ 条独立指令会在后续周期中使用所有 $W$ 个发射槽发射。总时间由工作量约束决定。因此，$C_{\\text{new}} = \\lceil \\frac{D+k}{W} \\rceil$。\n\n这两种情况可以完美地由以下表达式概括：\n$$C_{\\text{new}}(k) = \\max\\left(D, \\left\\lceil \\frac{D+k}{W} \\right\\rceil\\right)$$\n现在，我们可以计算 $D+k$ 条指令混合情况下的新 IPC：\n$$\\text{IPC}_{\\text{new}}(k) = \\frac{N_{\\text{new}}}{C_{\\text{new}}(k)} = \\frac{D+k}{\\max\\left(D, \\left\\lceil \\frac{D+k}{W} \\right\\rceil\\right)}$$\n题目要求 IPC 的提升，定义为比率 $\\frac{\\text{IPC}_{\\text{new}}}{\\text{IPC}_{\\text{base}}}$。\n由于 $\\text{IPC}_{\\text{base}}=1$，提升量 $I(k)$ 就是 $\\text{IPC}_{\\text{new}}(k)$。\n$$I(k) = \\frac{D+k}{\\max\\left(D, \\left\\lceil \\frac{D+k}{W} \\right\\rceil\\right)}$$\n代入给定的值 $D=10$ 和 $W=4$，我们得到 IPC 提升关于 $k$ 的闭式表达式：\n$$I(k) = \\frac{10+k}{\\max\\left(10, \\left\\lceil \\frac{10+k}{4} \\right\\rceil\\right)}$$\n这个表达式是问题第二部分的答案。\n\n最终结果总结：\n- 第一部分：最少周期数 = $10$。\n- 第二部分：IPC 提升 $I(k) = \\frac{10+k}{\\max\\left(10, \\left\\lceil \\frac{10+k}{4} \\right\\rceil\\right)}$。", "answer": "$$\\boxed{\\begin{pmatrix} 10  \\frac{10+k}{\\max\\left(10, \\left\\lceil \\frac{10+k}{4} \\right\\rceil\\right)} \\end{pmatrix}}$$", "id": "3661275"}, {"introduction": "在上一个练习的理想模型基础上，我们现在引入真实乱序执行处理器中的关键硬件限制：重排序缓存（$ROB$）和物理寄存器堆（$PRF$）。这些有限的资源决定了处理器能够观察和调度指令的“窗口”大小，直接限制了其发掘和利用ILP的能力。通过这个练习[@problem_id:3661308]，你将分析一个循环程序的性能如何被这些具体的硬件结构所制约，并量化这些限制对最终$IPC$的影响。", "problem": "考虑一个乱序、多发射处理器正在执行一个紧凑循环。该核心拥有一个大小为 $Q=64$ 个条目的重排序缓存（ROB）和一个大小为 $R=128$ 个整数寄存器的物理寄存器重命名文件。循环体由 $10$ 个独立的累加器更新（每次更新是对一个不同累加器寄存器的单周期整数加法）、一次循环计数器递增和一次检查循环计数器的条件分支组成。假设具有以下微体系结构特性：\n- 流水线在译码、发射和提交阶段每周期最多支持 $8$ 条指令。\n- 整数加法的延迟为 $1$ 个周期，并且有足够的功能单元以避免除宽度限制之外的结构性冒险。\n- 分支预测器的每次动态分支误预测率为 $m=0.02$，一次误预测会带来 $F=12$ 个周期的恢复惩罚，在此期间没有指令被提交。\n- 内存系统不会引入停顿，也没有缓存未命中。\n- 寄存器重命名为每个目标寄存器分配一个物理寄存器，直到相应的指令提交，之后旧的物理寄存器被释放。\n- 分支指令本身不产生目标寄存器。\n\n利用ROB和重命名文件施加的基本约束，确定可以同时在执行中的循环迭代次数。然后，使用指令级并行（ILP）和每周期指令数（IPC）的定义，确定当ROB饱和时持续的 $IPC$。将最终的 $IPC$ 四舍五入到四位有效数字。将最终答案表示为一个不带单位的纯数字。", "solution": "第一步是确定可以同时在执行中的最大循环迭代次数。这个量，用 $K$ 表示，受到重排序缓存（ROB）和物理寄存器文件（PRF）大小的限制。\n\n给定的参数是：\n- ROB大小：$Q = 64$ 个条目\n- PRF大小：$R = 128$ 个寄存器\n- 处理器宽度（译码、发射、提交）：$W = 8$ 指令/周期\n- 分支误预测率：$m = 0.02$\n- 分支误预测惩罚：$F = 12$ 周期\n\n循环体由以下部分组成：\n- $10$ 个独立的累加器更新（整数加法）。\n- $1$ 次循环计数器递增（整数加法）。\n- $1$ 个条件分支。\n\n首先，我们分析每次循环迭代的资源需求。\n每次迭代的总指令数是 $N_{inst} = 10 + 1 + 1 = 12$。\n写入目标寄存器的指令数量是累加器更新和循环计数器递增的总和，所以 $N_{reg} = 10 + 1 = 11$。分支指令没有目标寄存器。\n\n接下来，我们评估在执行中的迭代次数 $K$ 的约束。\n\n1.  **ROB 约束**：ROB必须为每条在执行中的指令保留一个条目。对于 $K$ 次迭代，总指令数为 $K \\times N_{inst}$。这不能超过ROB的大小 $Q$。\n    $$K \\times N_{inst} \\le Q$$\n    $$K \\times 12 \\le 64$$\n    $$K \\le \\frac{64}{12} \\approx 5.333$$\n    由于 $K$ 必须是整数，受ROB约束的最大迭代次数为 $K_{ROB} = \\lfloor 5.333 \\rfloor = 5$。\n\n2.  **PRF 约束**：PRF必须包含用于已提交的体系结构状态和在执行中的指令的推测性结果的寄存器。问题指明循环修改了 $N_{reg} = 11$ 个不同的体系结构寄存器（10个累加器和1个循环计数器）。所需物理寄存器的数量是最后一次提交状态所需的寄存器和新推测值所需的寄存器之和。对于 $N_{reg}$ 个体系结构寄存器中的每一个，都有一个已提交的值和来自 $K$ 个在执行中的迭代的 $K$ 个推测性未来值。一个计算所需物理寄存器数量的标准模型是 $N_{reg} \\times (K+1)$。一个更常见且更简单的模型指出，PRF大小 $R$ 必须能容纳体系结构寄存器加上推测性寄存器，其中推测性寄存器的数量等于具有目标寄存器的在执行中的指令数量。我们假设相关的体系结构状态空间仅由循环操作的 $N_{reg}$ 个寄存器组成，因此需要跟踪的体系结构寄存器数量为 $N_{AR} = 11$。因此，所需的总物理寄存器数量为 $N_{AR} + K \\times N_{reg}$。\n    $$N_{AR} + K \\times N_{reg} \\le R$$\n    $$11 + K \\times 11 \\le 128$$\n    $$11 \\times (K + 1) \\le 128$$\n    $$K + 1 \\le \\frac{128}{11} \\approx 11.636$$\n    $$K \\le 10.636$$\n    由于 $K$ 必须是整数，受PRF约束的最大迭代次数为 $K_{PRF} = \\lfloor 10.636 \\rfloor = 10$。\n\n同时在执行中的总迭代次数受这两个约束中更严格的一个限制：\n$$K = \\min(K_{ROB}, K_{PRF}) = \\min(5, 10) = 5$$\n因此，处理器受ROB大小的限制，可以维持 $5$ 次迭代在执行中。每次迭代有 $N_{inst}=12$ 条指令，这对应于ROB中有 $5 \\times 12 = 60$ 条指令，这证实了“ROB饱和”的条件。\n\n在ROB饱和的情况下，处理器的性能受限于指令可以被提交的速率，提交指令会释放ROB条目以供新指令使用。这是一个提交受限的场景。持续的每周期指令数（IPC）由提交宽度和任何导致提交暂停的停顿决定。\n\n提交宽度为每周期 $W = 8$ 条指令。在没有任何停顿的情况下，提交一次迭代的指令（$N_{inst} = 12$）所需的平均周期数为：\n$$C_{commit} = \\frac{N_{inst}}{W} = \\frac{12}{8} = 1.5 \\text{ 周期/迭代}$$\n然而，处理器也会因分支误预测而经历停顿。问题指出，一次误预测会带来 $F = 12$ 个周期的惩罚，在此期间没有指令被提交。每次迭代包含一个分支，误预测率为 $m = 0.02$。每次迭代的平均惩罚周期数为：\n$$C_{penalty} = m \\times F = 0.02 \\times 12 = 0.24 \\text{ 周期/迭代}$$\n每次迭代的总平均周期数 $C_{iter}$ 是提交所需周期数和平均惩罚周期数的总和。\n$$C_{iter} = C_{commit} + C_{penalty} = 1.5 + 0.24 = 1.74 \\text{ 周期/迭代}$$\n持续IPC是每次迭代的指令数除以每次迭代的平均周期数。\n$$IPC = \\frac{N_{inst}}{C_{iter}} = \\frac{12}{1.74}$$\n$$IPC = \\frac{12}{1.5 + 0.24} = \\frac{1}{\\frac{1.5}{12} + \\frac{0.24}{12}} = \\frac{1}{\\frac{1}{8} + 0.02} = \\frac{1}{0.125 + 0.02} = \\frac{1}{0.145}$$\n$$IPC \\approx 6.8965517...$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$IPC \\approx 6.897$$\n这个值表示在给定的体系结构约束下，处理器执行此特定循环时的持续吞吐量。计算出 $K=5$ 是至关重要的，它确认了处理器有足够的在执行中的工作量，从而达到提交受限状态，这为基于吞吐量的分析提供了依据。", "answer": "$$\\boxed{6.897}$$", "id": "3661308"}, {"introduction": "最后的练习将理论付诸实践，让你扮演处理器调度器的角色，解决一个具体的指令调度难题。你将面对一个由依赖关系图（DAG）表示的程序片段，并需要将其有效地映射到一个拥有多种不同功能单元（算术逻辑单元和内存单元）的处理器上。这个动手任务[@problem_id:3661333]要求你同时满足数据依赖和资源限制，以最小化总执行时间，从而深化你对关键路径分析和资源管理的理解。", "problem": "一个多发射处理器每个周期最多能启动 $W=3$ 个操作，并包含两个算术逻辑单元 (ALU) 和一个内存单元 (MEM)。考虑一个程序片段，它被表示为一个包含 $25$ 个节点 $v_1, v_2, \\dots, v_{25}$ 的有向无环图 (DAG)，其中每个节点是一个单一操作，在其所需资源上恰好占用一个周期，并在该周期结束时产生其输出。边 $v_i \\to v_j$ 表示一个写后读 (RAW) 依赖关系：节点 $v_j$ 只能在严格晚于 $v_i$ 的周期中被调度。该机器在任何周期内都可以发射最多两个 ALU 操作和一个 MEM 操作；不存在其他结构性冒险。\n\n每个节点 $v_i$ 有一个操作类型 $T(v_i) \\in \\{\\mathrm{ALU}, \\mathrm{MEM}\\}$，如下所示：\n- 链上节点及其类型：$T(v_1)=\\mathrm{MEM}$，$T(v_2)=\\mathrm{ALU}$，$T(v_3)=\\mathrm{ALU}$，$T(v_4)=\\mathrm{MEM}$，$T(v_5)=\\mathrm{ALU}$，$T(v_6)=\\mathrm{MEM}$，$T(v_7)=\\mathrm{ALU}$，$T(v_8)=\\mathrm{ALU}$，$T(v_9)=\\mathrm{MEM}$，$T(v_{10})=\\mathrm{ALU}$，$T(v_{11})=\\mathrm{MEM}$，$T(v_{12})=\\mathrm{ALU}$。\n- 链外节点及其类型：$T(v_{13})=\\mathrm{ALU}$，$T(v_{14})=\\mathrm{ALU}$，$T(v_{15})=\\mathrm{ALU}$，$T(v_{16})=\\mathrm{ALU}$，$T(v_{17})=\\mathrm{MEM}$，$T(v_{18})=\\mathrm{ALU}$，$T(v_{19})=\\mathrm{ALU}$，$T(v_{20})=\\mathrm{MEM}$，$T(v_{21})=\\mathrm{ALU}$，$T(v_{22})=\\mathrm{ALU}$，$T(v_{23})=\\mathrm{MEM}$，$T(v_{24})=\\mathrm{ALU}$，$T(v_{25})=\\mathrm{ALU}$。\n\nRAW 依赖关系（有向边）如下：\n- 链上边：$v_1 \\to v_2 \\to v_3 \\to v_4 \\to v_5 \\to v_6 \\to v_7 \\to v_8 \\to v_9 \\to v_{10} \\to v_{11} \\to v_{12}$。\n- 链外边：$v_1 \\to v_{13}$，$v_1 \\to v_{14}$，$v_2 \\to v_{15}$，$v_2 \\to v_{16}$，$v_2 \\to v_{17}$，$v_4 \\to v_{21}$，$v_5 \\to v_{24}$，$v_8 \\to v_{22}$，$v_9 \\to v_{23}$，$v_{11} \\to v_{25}$。节点 $v_{18}$、$v_{19}$ 和 $v_{20}$ 没有入边。\n\n所有操作都具有一周期的执行延迟，在该周期结束时产生结果，并且在该周期内仅占用其类型对应的资源。任何操作都不能与其任何前驱节点在同一周期内被调度。\n\n任务：在这些约束条件下，构建一个有效的调度以最小化完成时间 (makespan)，然后计算：\n- 完成所有 $25$ 个节点所需的总周期数。\n- ALU 和 MEM 资源的利用率，分别定义为已执行的 ALU 操作周期总数与总 ALU 容量（整个调度期间每个周期 $2$ 个单元）的比率，以及已执行的 MEM 操作周期总数与总 MEM 容量（整个调度期间每个周期 $1$ 个单元）的比率。\n将利用率值表示为小数或分数，不带百分号。按顺序 $(\\text{总周期数}, \\text{ALU 利用率}, \\text{MEM 利用率})$ 报告您的最终答案。", "solution": "### **解题过程**\n\n目标是为这 $25$ 个操作找到一个在数据依赖和资源约束下最小化总执行时间 (makespan) 的调度。解决方案包括三个主要部分：计算 makespan 的下界，构建一个最优调度，然后计算所需的指标。\n\n**1. Makespan 的下界**\n\nMakespan $T$ 受几个因素限制：关键路径长度、资源限制和发射宽度。Makespan 必须大于或等于这些下界中的最大值。\n\n-   **依赖下界（关键路径）**：依赖 DAG 中最长路径的长度决定了由数据依赖决定的最短时间。\n    -   主链是 $v_1 \\to v_2 \\to \\dots \\to v_{12}$。这条路径涉及 $12$ 个节点。由于每个操作需要一个周期，且依赖的操作只能在下一个周期开始，所以这条路径的长度是 $12$ 个周期。\n    -   我们必须检查是否有涉及链外节点的路径更长。例如，路径 $v_1 \\to v_2 \\to \\dots \\to v_{11} \\to v_{25}$ 的长度也是 $12$ 个节点。\n    -   没有其他路径比 $12$ 个节点更长。例如，$v_1 \\to \\dots \\to v_9 \\to v_{23}$ 的长度是 $10$ 个节点。\n    -   因此，关键路径长度为 $12$ 个周期。这给出了一个下界 $T \\ge 12$。\n\n-   **资源下界**：\n    -   操作类型计数：\n        -   ALU 操作：$v_2, v_3, v_5, v_7, v_8, v_{10}, v_{12}, v_{13}, v_{14}, v_{15}, v_{16}, v_{18}, v_{19}, v_{21}, v_{22}, v_{24}, v_{25}$。ALU 操作总数 = $17$。\n        -   MEM 操作：$v_1, v_4, v_6, v_9, v_{11}, v_{17}, v_{20}, v_{23}$。MEM 操作总数 = $8$。\n    -   ALU 资源下界：有 $17$ 个 ALU 操作和 $2$ 个 ALU 单元，最短时间为 $\\lceil \\frac{17}{2} \\rceil = \\lceil 8.5 \\rceil = 9$ 个周期。\n    -   MEM 资源下界：有 $8$ 个 MEM 操作和 $1$ 个 MEM 单元，最短时间为 $\\lceil \\frac{8}{1} \\rceil = 8$ 个周期。\n\n-   **发射宽度下界**：对于总共 $25$ 个操作和 $3$ 的发射宽度，最短时间为 $\\lceil \\frac{25}{3} \\rceil = \\lceil 8.33 \\rceil = 9$ 个周期。\n\n综合这些，makespan 必须至少为 $T \\ge \\max(12, 9, 8, 9) = 12$ 个周期。挑战在于找到一个能达到这个下界的调度。\n\n**2. 调度构建**\n\n我们使用列表调度算法逐周期构建调度，优先调度关键路径上的操作。如果一个节点的所有前驱节点都已完成，则该节点“就绪”。\n\n-   **周期 1**：\n    -   就绪节点：$v_1$ (MEM)，$v_{18}$ (ALU)，$v_{19}$ (ALU)，$v_{20}$ (MEM)。\n    -   可用资源：$2$ ALU，$1$ MEM。\n    -   调度：$\\{ v_1, v_{18}, v_{19} \\}$。（$v_1$ 在关键路径上）。\n\n-   **周期 2**：\n    -   就绪节点：$v_2$ (ALU)，$v_{13}$ (ALU)，$v_{14}$ (ALU)（因 $v_1$ 完成），以及 $v_{20}$ (MEM)。\n    -   调度：$\\{ v_2, v_{13}, v_{20} \\}$。（$v_2$ 在关键路径上；我们用 $1$ 个 ALU 槽位给 $v_2$，第二个给 $v_{13}$，MEM 槽位给 $v_{20}$）。\n\n-   **周期 3**：\n    -   就绪节点：$v_3$ (ALU)，$v_{15}$ (ALU)，$v_{16}$ (ALU)，$v_{17}$ (MEM)（因 $v_2$ 完成），以及 $v_{14}$ (ALU)（来自上一周期）。\n    -   调度：$\\{ v_3, v_{14}, v_{17} \\}$。（$v_3$ 在关键路径上）。\n\n-   **周期 4**：\n    -   就绪节点：$v_4$ (MEM)（因 $v_3$ 完成），以及 $v_{15}$ (ALU)，$v_{16}$ (ALU)（来自上一周期）。\n    -   调度：$\\{ v_4, v_{15}, v_{16} \\}$。（$v_4$ 在关键路径上）。\n\n-   **周期 5**：\n    -   就绪节点：$v_5$ (ALU)，$v_{21}$ (ALU)（因 $v_4$ 完成）。\n    -   调度：$\\{ v_5, v_{21} \\}$。（$v_5$ 在关键路径上）。\n\n-   **周期 6**：\n    -   就绪节点：$v_6$ (MEM)，$v_{24}$ (ALU)（因 $v_5$ 完成）。\n    -   调度：$\\{ v_6, v_{24} \\}$。（$v_6$ 在关键路径上）。\n\n-   **周期 7**：\n    -   就绪节点：$v_7$ (ALU)（因 $v_6$ 完成）。\n    -   调度：$\\{ v_7 \\}$。\n\n-   **周期 8**：\n    -   就绪节点：$v_8$ (ALU)（因 $v_7$ 完成）。\n    -   调度：$\\{ v_8 \\}$。\n\n-   **周期 9**：\n    -   就绪节点：$v_9$ (MEM)，$v_{22}$ (ALU)（因 $v_8$ 完成）。\n    -   调度：$\\{ v_9, v_{22} \\}$。\n\n-   **周期 10**：\n    -   就绪节点：$v_{10}$ (ALU)，$v_{23}$ (MEM)（因 $v_9$ 完成）。\n    -   调度：$\\{ v_{10}, v_{23} \\}$。\n\n-   **周期 11**：\n    -   就绪节点：$v_{11}$ (MEM)（因 $v_{10}$ 完成）。\n    -   调度：$\\{ v_{11} \\}$。\n\n-   **周期 12**：\n    -   就绪节点：$v_{12}$ (ALU)，$v_{25}$ (ALU)（因 $v_{11}$ 完成）。\n    -   调度：$\\{ v_{12}, v_{25} \\}$。\n\n所有 $25$ 个操作都在 $12$ 个周期内完成。由于这与关键路径下界相匹配，因此该调度是最优的。\n\n**3. 指标计算**\n\n-   **总周期数 (Makespan)**：\n    最优调度的 makespan 为 $12$ 个周期。\n\n-   **ALU 利用率**：\n    -   执行的 ALU 操作总数 = $17$。\n    -   调度期间的总 ALU 容量 = (ALU 单元数) $\\times$ (Makespan) = $2 \\times 12 = 24$ ALU-周期。\n    -   ALU 利用率 = $\\frac{\\text{执行的 ALU 操作总数}}{\\text{总 ALU 容量}} = \\frac{17}{24}$。\n\n-   **MEM 利用率**：\n    -   执行的 MEM 操作总数 = $8$。\n    -   调度期间的总 MEM 容量 = (MEM 单元数) $\\times$ (Makespan) = $1 \\times 12 = 12$ MEM-周期。\n    -   MEM 利用率 = $\\frac{\\text{执行的 MEM 操作总数}}{\\text{总 MEM 容量}} = \\frac{8}{12} = \\frac{2}{3}$。\n\n最终结果是：makespan 为 $12$ 个周期，ALU 利用率为 $\\frac{17}{24}$，MEM 利用率为 $\\frac{2}{3}$。", "answer": "$$\\boxed{\\begin{pmatrix} 12  \\frac{17}{24}  \\frac{2}{3} \\end{pmatrix}}$$", "id": "3661333"}]}