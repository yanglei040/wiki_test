{"hands_on_practices": [{"introduction": "为了实现高效的乱序执行，现代处理器需要一种机制来预测访存指令之间是否存在依赖关系。这个练习将带你深入了解一个内存依赖预测器的实际硬件实现，要求你根据给定的关键架构参数计算其存储成本。通过这个计算，你将能更好地理解在预测器的历史深度、精度与硬件预算之间的权衡。[@problem_id:3657211]", "problem": "一个微体系结构使用乱序 (OoO) 执行，并带有一个为加载和存储执行内存消歧的内存依赖性预测器。当观察到某个加载（表示为 $L$）与一个较早的存储（表示为 $S$）发生冲突，其程序顺序距离为 $d$（在 $L$ 分派时，$S$ 和 $L$ 之间正在执行的较早存储的数量）时，预测器会更新 $L$ 的相关性状态，以便在未来的执行中，保守地将 $L$ 视为依赖于所有距离 $d$ 以内的较早存储。为了跨动态上下文关联依赖行为，对于每个静态加载程序计数器 (PC)，预测器会为每个加载维护一个包含最近 $H$ 个观测到的冲突距离的循环历史记录，并预测下一个依赖距离为该窗口内的最大值。为了在硬件中支持此行为，预测器必须存储这 $H$ 个距离本身。\n\n该预测器实现为一个具有 $E$ 个条目的直接映射表，通过加载 PC $PC_L$ 的低位比特进行寻址。每个条目包含：一个有效位，一个由未用于索引表的 PC 高位比特组成的标签，一个 $c$ 位的饱和置信度计数器，以及该加载的 $H$ 个最近的冲突距离。该机器有一个容量为 $Q$ 个条目的存储队列 (SQ)；因此，任何冲突距离 $d$ 都在集合 $\\{1,\\dots,Q\\}$ 中。为了能够表示历史记录位置中尚未观察到冲突的情况，该设计使用一个额外的代码来编码距离，因此距离字段必须能编码 $Q+1$ 个不同的值。地址宽度为 $A$ 位。\n\n假设以下具体参数：$A = 48$，$E = 512$，$Q = 56$，以及 $c = 2$。标签存储 $PC_L$ 的 $A - \\log_{2}(E)$ 个高位比特，并且由于表是直接映射的，除了有效位之外没有替换元数据。请推导出一个精确的闭式表达式，以比特为单位，表示整个预测器表所需的总存储容量，该表达式是历史长度 $H$ 的函数。将您的最终答案表示为关于 $H$ 的单一闭式表达式，不带单位。无需取整。", "solution": "用户希望我扮演一个严谨、苛刻的 STEM 领域教授的角色。我必须首先验证问题陈述，如果有效，则提供解决方案。\n\n### 步骤 1：问题验证\n\n**1. 提取已知条件：**\n- 预测器类型：具有 $E$ 个条目的直接映射表。\n- 表索引：加载程序计数器 ($PC_L$) 的低位比特。\n- 地址宽度：$A = 48$ 位。\n- 条目数：$E = 512$。\n- 存储队列容量：$Q = 56$。\n- 冲突距离范围：$d \\in \\{1, 2, \\dots, Q\\}$。\n- 每个距离需要编码的值的数量：$Q+1$（包括一个表示无冲突的代码）。\n- 每个条目的组成部分：\n    - 一个有效位。\n    - 一个标签：$PC_L$ 的 $A - \\log_2(E)$ 个高位比特。\n    - 一个置信度计数器：$c$ 位饱和计数器，其中 $c = 2$。\n    - 一个距离历史记录：$H$ 个最近的冲突距离。\n- 替换策略：除了用于直接映射结构的有效位外，没有指定其他替换策略。\n\n**2. 使用提取的已知条件进行验证：**\n- **科学性**：该问题描述了一个内存依赖性预测器，这是高性能计算机体系结构中的一个标准组件。所有使用的概念（直接映射表、程序计数器、标签、存储队列、乱序执行）都是计算机组成和体系结构的基础。该设计是合理的。\n- **良构性**：该问题要求计算一个硬件结构的总存储容量（以比特为单位）。它提供了计算该结构大小所需的所有必要参数和定义。可以推导出一个唯一的、精确的解。\n- **客观性**：该问题使用精确的技术语言陈述，没有主观或含糊的术语。\n- **一致性**：问题陈述是自洽且内部一致的。例如，它明确给出了标签大小为 $A - \\log_2(E)$，这与由 $A$ 位地址索引的 $E$ 个条目的直接映射表的描述是一致的。\n- **可行性**：给定的参数（$A=48$, $E=512$, $Q=56$, $c=2$）对于现代处理器设计是现实的。\n\n**3. 结论与行动：**\n问题有效。这是一个定义明确、科学上合理的计算机体系结构问题。我将继续进行解答。\n\n### 步骤 2：推导解决方案\n\n预测器表的总存储容量（表示为 $S_{total}$）是条目数 $E$ 与单个条目大小 $S_{entry}$ 的乘积。\n$$S_{total} = E \\times S_{entry}$$\n表中的单个条目由四个不同的字段组成：一个有效位、一个标签、一个置信度计数器和用于存储 $H$ 个冲突距离的空间。一个条目的大小是这些字段大小的总和：\n$$S_{entry} = S_{valid} + S_{tag} + S_{confidence} + S_{distances}$$\n我们现在将确定每个组件的大小（以比特为单位）。\n\n1.  **有效位的大小 ($S_{valid}$)**：该条目包含一个单独的有效位。\n    $$S_{valid} = 1$$\n\n2.  **标签的大小 ($S_{tag}$)**：问题陈述指出，标签存储 $A$ 位程序计数器 ($PC_L$) 中未用于索引表的高位比特。该表有 $E$ 个条目并且是直接映射的，因此索引所需的比特数是 $\\log_2(E)$。问题明确给出了标签大小为：\n    $$S_{tag} = A - \\log_2(E)$$\n    代入给定值 $A=48$ 和 $E=512$：\n    $$\\log_2(E) = \\log_2(512) = \\log_2(2^9) = 9$$\n    $$S_{tag} = 48 - 9 = 39 \\text{ 比特}$$\n\n3.  **置信度计数器的大小 ($S_{confidence}$)**：问题指定了一个 $c$ 位的饱和计数器，参数 $c=2$。\n    $$S_{confidence} = c = 2 \\text{ 比特}$$\n\n4.  **距离历史记录的大小 ($S_{distances}$)**：每个条目存储 $H$ 个冲突距离。首先，我们必须确定存储单个距离值所需的比特数，我们将其表示为 $S_{dist\\_field}$。冲突距离 $d$ 是范围在 $[1, Q]$ 内的整数。问题陈述指出，使用一个额外的代码来表示未发生冲突的情况。因此，单个距离的字段必须能够编码 $Q+1$ 个不同的值。表示 $N$ 个值所需的比特数是 $\\lceil\\log_2(N)\\rceil$。\n    对于我们的情况，有 $N = Q+1$ 和 $Q=56$：\n    $$S_{dist\\_field} = \\lceil \\log_2(Q+1) \\rceil = \\lceil \\log_2(56+1) \\rceil = \\lceil \\log_2(57) \\rceil$$\n    为了计算该值，我们观察到 $2^5 = 32$ 且 $2^6 = 64$。因为 $32  57  64$，所以 $5  \\log_2(57)  6$。该值的向上取整为：\n    $$S_{dist\\_field} = 6 \\text{ 比特}$$\n    一个条目中 $H$ 个距离的总存储大小是 $H$ 与单个距离字段大小的乘积：\n    $$S_{distances} = H \\times S_{dist\\_field} = H \\times 6 = 6H \\text{ 比特}$$\n\n现在，我们可以通过将各组件大小相加来计算单个条目的总大小 $S_{entry}$：\n$$S_{entry} = S_{valid} + S_{tag} + S_{confidence} + S_{distances} = 1 + 39 + 2 + 6H$$\n$$S_{entry} = 42 + 6H \\text{ 比特}$$\n\n最后，整个预测器表的总存储容量 $S_{total}$，是通过将单个条目的大小乘以总条目数 $E=512$ 得出的。\n$$S_{total}(H) = E \\times S_{entry} = 512 \\times (42 + 6H)$$\n展开此表达式，得到作为 $H$ 的函数的最终闭式方程：\n$$S_{total}(H) = 512 \\times 42 + 512 \\times 6H$$\n$$S_{total}(H) = 21504 + 3072H$$\n该表达式给出了预测器表的总存储容量（以比特为单位）。", "answer": "$$\n\\boxed{21504 + 3072H}\n$$", "id": "3657211"}, {"introduction": "理解了预测器的构造后，让我们来看看内存解引用机制如何直接影响指令的执行性能。本题模拟了一个复杂但贴近真实的场景：一个加载指令恰好跨越了两个虚拟页。你需要逐字节地分析其与先前存储指令的依赖关系，并结合存储转发、缓存访问和TLB查询的延迟，精确计算出该加载指令的总执行时间。[@problem_id:3657275]", "problem": "一个超标量乱序核通过一个用于单个硬件线程的存储队列来实现内存消歧。虚拟内存使用大小为 $P$ 字节的页面，其中 $P = 4096$。一个位于虚拟地址 $A$、宽度为 $w$ 字节的加载指令，当且仅当 $A \\bmod P  P - w$ 时，它会跨越页面边界。考虑一个加载指令的动态实例，其 $w = 16$ 且 $A \\bmod P = 4092$，因此该加载从地址 $A$ 跨越到 $A + w - 1$，横跨两个连续的虚拟页面，我们将其表示为页面 $p$ 和页面 $p+1$。根据定义，在页面 $p$ 上访问的字节的偏移量为 $4092, 4093, 4094, 4095$，在页面 $p+1$ 上的偏移量为 $0, 1, \\dots, 11$。\n\n存储队列中有四个更早的存储指令，它们的虚拟地址和大小已知，全部来自同一个线程，并按以下从最旧到最新的程序顺序列出：$S_3$, $S_1$, $S_4$, $S_2$。它们相对于该加载指令所触及页面的虚拟地址偏移量和长度如下：\n- $S_3$：页面 $p$，地址偏移量 $4088$，长度 $4$ 字节，\n- $S_1$：页面 $p$，地址偏移量 $4094$，长度 $2$ 字节，\n- $S_4$：页面 $p+1$，地址偏移量 $0$，长度 $4$ 字节，\n- $S_2$：页面 $p+1$，地址偏移量 $8$，长度 $8$ 字节。\n\n内存消歧和数据供应规则如下：\n- 对于加载指令中被一个或多个更早的存储指令覆盖的每个字节，其值从覆盖该字节的最新存储指令中转发。如果一个加载指令总共必须从 $k$ 个不同的更早存储指令中转发数据，合并这些转发的数据片会产生额外的 $k$ 个周期的延迟。\n- 对于加载指令必须从一级数据缓存 (L1) 中获取任何字节的每个页面，访问延迟为 $L_c = 4$ 个周期，并且每个此类页面只计算一次。如果一个页面的所有字节都从存储队列转发，则对该页面的一级数据缓存 (L1) 访问将被抑制，不产生延迟。\n- 转译后备缓冲器 (TLB) 行为：数据侧转译后备缓冲器 (TLB) 只有一个查找端口，并且必须在访问该页面的一级数据缓存 (L1) 之前为该页面提供地址转换。一个页面的 TLB 命中需要 $t_h = 1$ 个周期；一个页面的 TLB 未命中需要 $t_m = 13$ 个周期（这是为该页面生成转换所需的总时间）。如果一个页面完全通过存储转发来满足，其 TLB 查找将被推迟到引退阶段，并且不计入此加载指令的执行延迟。\n- 如果此加载指令的执行需要对两个页面都进行查找，则这些查找将通过单个 TLB 端口串行进行，它们的延迟会相加。如果需要访问两个页面的一级数据缓存 (L1)，其访问延迟也会相加。转发字节的合并延迟在 TLB 和一级数据缓存 (L1) 延迟之后相加。对于本问题，假设这些组件之间在时间上没有重叠。\n\n假设对于此动态实例发生以下事件：\n- 页面 $p$ 的 TLB 查找命中。\n- 页面 $p+1$ 的 TLB 查找未命中。\n- 任何所需的一级数据缓存 (L1) 访问都在缓存中命中。\n\n从内存消歧的范围相交基本定义和给定的执行规则出发，确定此加载指令的总执行延迟（以周期为单位），包括由两个页面上的部分重叠决定的 TLB、一级数据缓存 (L1) 和存储转发合并成本。报告一个等于总周期的实数值。在最终的方框答案中不要包含单位。", "solution": "问题陈述经评估是有效的。它在科学上基于计算机体系结构的原理，特别是乱序执行和内存消歧。问题是良构的，提供了一套自洽且一致的规则和数据，从而可以推导出唯一且有意义的解。所有术语都有明确定义，并且在所建立的假设处理器模型内，其前提在事实上是合理的。\n\n任务是计算特定加载指令的总执行延迟。根据问题定义，此延迟是三个组成部分的总和：转译后备缓冲器 (TLB) 延迟、一级 (L1) 数据缓存访问延迟和存储转发合并延迟。我们将分析在两个受影响的虚拟页面上的内存访问，以确定对每个延迟分量的贡献。\n\n首先，我们确定加载指令和存储指令的地址范围。\n页面大小为 $P = 4096$ 字节。\n该加载指令宽度为 $w = 16$ 字节，起始于虚拟地址 $A$，使得 $A \\bmod P = 4092$。\n该加载指令访问从地址 $A$ 到 $A + w - 1 = A + 15$ 的字节。\n此访问跨越两个页面，我们表示为 $p$ 和 $p+1$。\n- 在页面 $p$ 上，加载指令访问偏移量为 $[4092, 4095]$ 的字节。总共 $4$ 个字节。\n- 在页面 $p+1$ 上，加载指令访问偏移量为 $[0, 11]$ 的字节。总共 $12$ 个字节。\n总字节数为 $4 + 12 = 16$，与加载宽度 $w$ 一致。\n\n四个更早的存储指令按程序顺序（从最旧到最新）为 $S_3, S_1, S_4, S_2$。它们的地址范围是：\n- $S_3$：页面 $p$，偏移量 $4088$，长度 $4$。偏移量范围：$[4088, 4091]$。\n- $S_1$：页面 $p$，偏移量 $4094$，长度 $2$。偏移量范围：$[4094, 4095]$。\n- $S_4$：页面 $p+1$，偏移量 $0$，长度 $4$。偏移量范围：$[0, 3]$。\n- $S_2$：页面 $p+1$，偏移量 $8$，长度 $8$。偏移量范围：$[8, 15]$。\n\n现在，我们分析每个页面的数据来源。\n\n**页面 $p$ 的分析**\n加载指令需要页面 $p$ 中偏移量为 $[4092, 4095]$ 的字节。我们检查与此页面上更早的存储指令的重叠情况。\n- 存储指令 $S_3$ 占据偏移量 $[4088, 4091]$。与加载指令的范围 $[4092, 4095]$ 的交集为空：$[4092, 4095] \\cap [4088, 4091] = \\emptyset$。\n- 存储指令 $S_1$ 占据偏移量 $[4094, 4095]$。与加载指令的范围的交集为 $[4092, 4095] \\cap [4094, 4095] = [4094, 4095]$。\n根据存储转发规则，偏移量为 $4094$ 和 $4095$ 的字节的值将从存储指令 $S_1$ 转发。\n偏移量为 $4092$ 和 $4093$ 的字节没有被存储队列中任何更早的存储指令覆盖。因此，这些字节必须从内存层次结构中获取，具体来说是从 L1 数据缓存。\n由于页面 $p$ 的所有字节并非都通过存储转发完全满足，因此需要对页面 $p$ 进行 L1 缓存访问和之前的 TLB 查找。\n\n**页面 $p+1$ 的分析**\n加载指令需要页面 $p+1$ 中偏移量为 $[0, 11]$ 的字节。我们检查与此页面上更早的存储指令的重叠情况。\n- 存储指令 $S_4$ 占据偏移量 $[0, 3]$。与加载指令的范围的交集为 $[0, 11] \\cap [0, 3] = [0, 3]$。\n- 存储指令 $S_2$ 占据偏移量 $[8, 15]$。与加载指令的范围的交集为 $[0, 11] \\cap [8, 15] = [8, 11]$。\n程序顺序是 $S_4$ 之后是 $S_2$（即 $S_2$ 更新）。受影响的字节范围 $[0, 3]$ 和 $[8, 11]$ 是不相交的，因此不存在一个字节被多个存储指令覆盖的冲突。\n- 偏移量为 $[0, 3]$ 的字节将从存储指令 $S_4$ 转发。\n- 偏移量为 $[8, 11]$ 的字节将从存储指令 $S_2$ 转发。\n偏移量为 $[4, 7]$ 的字节没有被任何更早的存储指令覆盖。这些字节必须从 L1 数据缓存中获取。\n由于页面 $p+1$ 的所有字节并非都通过存储转发完全满足，因此也需要对页面 $p+1$ 进行 L1 缓存访问和之前的 TLB 查找。\n\n通过此分析，我们可以计算总延迟。\n\n**1. 总 TLB 延迟**\n页面 $p$ 和页面 $p+1$ 都需要进行 TLB 查找。这些查找是串行化的。\n- 页面 $p$ 的查找是命中，耗时 $t_h = 1$ 个周期。\n- 页面 $p+1$ 的查找是未命中，耗时 $t_m = 13$ 个周期。\n总 TLB 延迟 = $t_h + t_m = 1 + 13 = 14$ 个周期。\n\n**2. 总 L1 数据缓存延迟**\n页面 $p$ 和页面 $p+1$ 都需要进行 L1 缓存访问。问题陈述表明这些访问在缓存中命中，并且它们的延迟相加。\n- 访问页面 $p$ 产生 $L_c = 4$ 个周期的延迟。\n- 访问页面 $p+1$ 产生 $L_c = 4$ 个周期的延迟。\n总 L1 缓存延迟 = $L_c + L_c = 4 + 4 = 8$ 个周期。\n\n**3. 存储转发合并延迟**\n合并延迟为 $k$ 个周期，其中 $k$ 是加载指令从中转发数据的不同更早存储指令的总数。\n- 从页面 $p$ 中，数据从存储指令 $S_1$ 转发。\n- 从页面 $p+1$ 中，数据从存储指令 $S_4$ 和 $S_2$ 转发。\n不同的转发存储指令集合是 $\\{S_1, S_2, S_4\\}$。\n不同的存储指令数量为 $k = 3$。\n存储转发合并延迟 = $k = 3$ 个周期。\n\n**4. 总执行延迟**\n总延迟是这些非重叠组件的总和。\n总延迟 = (总 TLB 延迟) + (总 L1 缓存延迟) + (存储转发合并延迟)\n总延迟 = $14 + 8 + 3 = 25$ 个周期。\n\n此加载指令的总执行延迟为 $25$ 个周期。", "answer": "$$\\boxed{25}$$", "id": "3657275"}, {"introduction": "推测执行虽然强大，但并非万无一失，因此必须有相应的恢复机制来纠正错误。这个练习聚焦于推测失败后的关键恢复过程，当一个内存排序违例被检测到时，硬件必须采取行动以保证程序的正确性。通过分析一个具体的违例场景，你将应用一个给定的硬件恢复策略，以确定哪些指令需要被清除和重新执行，从而加深对维持执行正确性的理解。[@problem_id:3664944]", "problem": "一个超标量乱序核强制按序引退，并实现了一个加载-存储队列 (Load-Store Queue, LSQ) 来维持加载和存储之间的内存顺序。LSQ 的深度为 $D=16$。该机器允许推测性内存消歧：即使存在地址未解析的较旧存储，较新的加载也可以发射。当加载的有效地址与较旧存储的地址匹配时，核心会使用来自存储缓冲区的存储到加载前向传递。在内存依赖性错误预测时（例如，尽管一个较旧的未解析存储实际上与其地址重叠，一个较新的加载仍被允许发射），核心采用全局加载重放策略：当违规的较旧存储的地址解析并检测到冲突时，所有比该存储新且已执行其内存访问的加载都将被清空并重新发射。\n\n考虑以下程序顺序的内存操作序列，在某个较旧存储解析其地址并检测到冲突的瞬间，这些操作正驻留在加载-存储队列 (LSQ) 中。索引随程序顺序增加；索引 $0$ 是最旧的条目，索引 $13$ 是最新的条目。因此，LSQ 的占用数为 $14$，在深度 $D=16$ 的范围内。每个操作都用其类型和有效地址符号进行注释。在检测到冲突的瞬间，列表中所有的加载都已执行了其内存访问。\n\n索引 $0$：$S_{0}$ 写入 $A$（$S_{0}$ 的地址在插入时已解析）。\n索引 $1$：$L_{1}$ 读取 $A$（已执行；从 $S_{0}$ 正确前向传递）。\n索引 $2$：$L_{2}$ 读取 $B$（已执行；与 $S_{0}$ 无地址重叠）。\n索引 $3$：$S_{1}$ 写入一个初始未解析的地址，该地址后来解析为 $A$（此为违规存储）。\n索引 $4$：$L_{3}$ 读取 $A$（推测性发射；内存依赖性预测器声称与 $S_{1}$ “无地址重叠”；从 $S_{0}$ 前向传递，这是不正确的，因为 $S_{1}$ 更旧，应由其提供值）。\n索引 $5$：$L_{4}$ 读取 $C$（已执行）。\n索引 $6$：$S_{2}$ 写入 $D$。\n索引 $7$：$L_{5}$ 读取 $E$（已执行）。\n索引 $8$：$L_{6}$ 读取 $F$（已执行）。\n索引 $9$：$S_{3}$ 写入 $G$。\n索引 $10$：$L_{7}$ 读取 $H$（已执行）。\n索引 $11$：$L_{8}$ 读取 $I$（已执行）。\n索引 $12$：$S_{4}$ 写入 $J$。\n索引 $13$：$L_{9}$ 读取 $K$（已执行）。\n\n定义重放窗口 $W_{r}$ 为当检测到索引 $3$ 处的 $S_{1}$ 发生错误预测时，必须被清空并重新发射的较新加载的数量。使用提供的 LSQ 深度 $D$ 和程序顺序的内存序列计算 $W_{r}$。答案以无单位的精确整数表示。", "solution": "首先将对问题的科学合理性、自洽性和清晰性进行验证。\n\n### 步骤 1：提取已知条件\n- **核心架构**：超标量、乱序执行、按序引退。\n- **加载-存储队列 (LSQ)**：深度 $D=16$。\n- **内存消歧**：推测性；较新的加载可以在地址未解析的较旧存储解析之前发射。\n- **前向传递**：实现了存储到加载的前向传递。\n- **错误预测恢复策略**：使用全局加载重放策略。在检测到内存依赖性错误预测时（即，一个较新的加载在与之地址重叠的较旧存储的地址已知之前错误地执行了），核心将清空并重新发射**所有比违规存储新**且已执行其内存访问的加载。\n- **违规存储**：索引为 $3$ 的 $S_{1}$。它最初有一个未解析的地址，现在已解析为地址 $A$，从而揭示了与推测性执行的加载 $L_3$ 的冲突。\n- **LSQ 状态**：LSQ 中存在一个包含 $14$ 个内存操作（索引 $0$ 到 $13$）的序列。\n- **执行状态**：在检测到错误预测的时刻，所有列出的加载都已执行了其内存访问。\n- **内存操作序列**：\n    - 索引 $0$：存储 $S_{0}$ 到地址 $A$。\n    - 索引 $1$：加载 $L_{1}$ 从地址 $A$。\n    - 索引 $2$：加载 $L_{2}$ 从地址 $B$。\n    - 索引 $3$：存储 $S_{1}$ 到地址 $A$（此为违规存储）。\n    - 索引 $4$：加载 $L_{3}$ 从地址 $A$。\n    - 索引 $5$：加载 $L_{4}$ 从地址 $C$。\n    - 索引 $6$：存储 $S_{2}$ 到地址 $D$。\n    - 索引 $7$：加载 $L_{5}$ 从地址 $E$。\n    - 索引 $8$：加载 $L_{6}$ 从地址 $F$。\n    - 索引 $9$：存储 $S_{3}$ 到地址 $G$。\n    - 索引 $10$：加载 $L_{7}$ 从地址 $H$。\n    - 索引 $11$：加载 $L_{8}$ 从地址 $I$。\n    - 索引 $12$：存储 $S_{4}$ 到地址 $J$。\n    - 索引 $13$：加载 $L_{9}$ 从地址 $K$。\n- **目标**：计算重放窗口 $W_{r}$，定义为必须被清空和重新发射的较新加载的数量。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题有效。\n- **科学上成立**：所描述的场景是高性能乱序微处理器设计中的一个标准和基本问题。诸如加载-存储队列 (LSQ)、推测性内存消歧、存储到加载前向传递以及内存顺序违规检测与恢复等概念都是计算机体系结构的核心主题。“全局加载重放”策略是一种有效但简单的硬件恢复实现策略。\n- **定义明确**：问题定义清晰。它明确了要应用的恢复策略，并提供了错误预测检测时刻相关 LSQ 部分的完整状态。问题要求根据这些精确条件计算一个单一的可计算整数值 $W_{r}$。\n- **目标**：问题使用计算机体系结构领域的精确技术术语陈述，没有主观或模糊的语言。\n\n该问题要求将陈述的规则直接应用于给定的数据集。它是自包含的、一致的且科学上合理的。\n\n### 步骤 3：开始解题\n问题有效，将提供解答。\n\n问题的核心在于严格应用指定的内存依赖性错误预测恢复策略。该策略被明确定义为**全局加载重放**。它指出：“……当违规的较旧存储的地址解析并检测到冲突时，所有比该存储新且已执行其内存访问的加载都将被清空并重新发射。”\n\n让我们剖析这个策略，并将其应用于给定的 LSQ 状态。\n\n1.  **识别违规存储**：问题将索引为 $3$ 的存储操作 $S_{1}$ 识别为“违规存储”。该指令作为程序顺序中的参考点。\n\n2.  **识别较新的指令**：该策略涉及“所有比该存储新的加载”。在维持程序顺序的 LSQ 上下文中，“较新”的指令是那些具有更高索引的指令。因此，我们必须考虑所有索引大于 $3$ 的指令。这些是从索引 $4$ 到索引 $13$ 的指令。\n\n3.  **筛选加载指令**：该策略明确仅适用于“加载”操作。我们必须列出在已识别的较新指令窗口（索引 $4$ 到 $13$）内所有的 `Load` 操作。\n    - 索引 $4$：$L_{3}$（加载）\n    - 索引 $5$：$L_{4}$（加载）\n    - 索引 $6$：$S_{2}$（存储）- 排除\n    - 索引 $7$：$L_{5}$（加载）\n    - 索引 $8$：$L_{6}$（加载）\n    - 索引 $9$：$S_{3}$（存储）- 排除\n    - 索引 $10$：$L_{7}$（加载）\n    - 索引 $11$：$L_{8}$（加载）\n    - 索引 $12$：$S_{4}$（存储）- 排除\n    - 索引 $13$：$L_{9}$（加载）\n\n4.  **确认执行状态**：该策略适用于“已执行其内存访问”的加载。问题陈述明确确认了此条件：“在检测到冲突的瞬间，列表中所有的加载都已执行了其内存访问。”因此，上一步中识别出的所有加载都满足此条件，必须被清空。\n\n5.  **计算重放窗口 $W_{r}$**：重放窗口 $W_{r}$ 是必须被清空和重新发射的加载总数。根据步骤 3 中的枚举，这些加载是 $L_{3}$、$L_{4}$、$L_{5}$、$L_{6}$、$L_{7}$、$L_{8}$ 和 $L_{9}$。\n\n计算这些加载的数量得出：\n$$W_{r} = 7$$\n\n加载 $L_{3}$ 是其推测性执行不正确的特定指令（它从 $S_{0}$ 获得了前向传递的值，而它本应接收来自 $S_{1}$ 的新值）。然而，重放策略的“全局”性质意味着恢复操作不仅限于 $L_{3}$。所有在程序顺序上比违规存储 $S_{1}$ 新的其他加载也被卷入重放，无论它们本身是否对 $S_{1}$ 有数据依赖。加载 $L_{1}$ 和 $L_{2}$ 比 $S_{1}$ 旧，因此不受影响。LSQ 深度 $D=16$ 是无关信息，因为占用情况和状态已完全指定。", "answer": "$$\\boxed{7}$$", "id": "3664944"}]}