{"hands_on_practices": [{"introduction": "在并发编程中，实现一个线程安全的共享计数器是一项基本任务。虽然看似简单，但其实现方式对性能有着天壤之别。本练习将引导你通过一个理想化的多核模型，从理论上分析和量化两种不同原子操作策略——基于软件的“比较并交换”（CAS）循环与基于硬件的“取而加”（FAA）指令——在高度竞争环境下的吞吐量差异。通过这个练习[@problem_id:3621231]，你将深刻理解专用硬件原子指令相对于通用原子原语在解决特定问题时的巨大性能优势。", "problem": "一个具有 $N$ 个相同核心的多核处理器，对存储在单个缓存行中的共享热点计数器进行增量操作。考虑两种设计：\n\n- 使用比较并交换 (CAS) 的循环，即 Compare-and-Swap (CAS)，其中每个核心重复读取计数器，在本地计算增量后的值，然后发出一个CAS指令，试图用增量后的值替换旧值。没有退避机制；所有 $N$ 个核心都运行紧密循环，并持续竞争同一个缓存行。\n- 硬件的读取并加 (FAA) 指令，即 Fetch-and-Add (FAA)，其中每个核心对计数器发出一个原子加法指令。\n\n假设有一个一致性内存系统，该系统将对该缓存行的所有原子操作尝试（无论最终成功或失败）进行串行化处理。每个到达一致性/互联队列头部的原子操作尝试都需要对该缓存行的独占所有权，并占用串行化点整整 $L$ 个周期，之后该行被释放。在饱和稳态下，队列中始终至少有一个待处理的原子请求。假设竞争者是对称的，本地计算时间与 $L$ 相比可以忽略不计，且一致性仲裁是公平的。\n\n仅从原子性（在串行化点上一次一个可见）的定义以及上述串行化和对称性假设出发，推导以下两种情况的稳态吞吐量（以每周期完成的增量次数为单位）：\n\n- 在所述的紧密循环竞争下的基于CAS的计数器。\n- 在相同内存系统下的基于FAA的设计。\n\n然后，将吞吐量比率 $R$ 定义为FAA吞吐量除以CAS吞吐量，并用 $N$ 的封闭形式表达式表示 $R$。只需提供 $R$ 的最终表达式作为答案。无需四舍五入。", "solution": "问题要求计算在一个具有 $N$ 个核心的多核处理器上，使用两种不同方法增加共享计数器的吞吐量之比：一种是使用硬件的读取并加 (FAA) 指令，另一种是使用带有比较并交换 (CAS) 指令的软件循环。吞吐量定义为稳态下每周期完成的增量次数。\n\n系统模型规定，所有的原子操作尝试（无论成功与否）都会被串行化。每次由内存系统处理的尝试都会占用串行化点，时长为 $L$ 个周期。系统处于饱和稳态，意味着总有一个待处理请求队列，并且在 $N$ 个对称核心之间的仲裁是公平的。\n\n我们来推导每种情况下的吞吐量。\n\n**1. 读取并加 (FAA) 的吞吐量**\n\n读取并加 (FAA) 指令是一个单一的原子操作，它读取一个内存位置的值，给它加上一个值，然后将结果写回。根据其定义，一个 FAA 操作在执行时，总是能成功完成增量操作。\n\n根据问题描述，内存系统串行化处理原子操作尝试，每次处理的尝试需要 $L$ 个周期。在基于 FAA 的设计中，每次原子操作尝试都是一个 FAA 指令。由于每个被串行化的 FAA 指令都能完成一次成功的增量，系统在每个 $L$ 周期的时隙内恰好执行一次增量操作。\n\n完成的增量速率，即吞吐量，是增量次数除以周期数。\n$$\n\\text{Throughput}_{\\text{FAA}} = \\frac{1 \\text{ increment}}{L \\text{ cycles}} = \\frac{1}{L}\n$$\n这个吞吐量与核心数 $N$ 无关，因为瓶颈在于内存系统中的单个串行化点，该点一次只能服务一个请求。饱和假设保证了该瓶颈始终处于繁忙状态。\n\n**2. 比较并交换 (CAS) 的吞吐量**\n\n基于 CAS 的方法涉及一个循环，其中每个核心首先读取计数器的当前值，在本地计算新值，然后使用 CAS 指令尝试原子地更新计数器。一个 `CAS(address, expected_value, new_value)` 操作仅当 `address` 处的值等于 `expected_value` 时才会成功。\n\n考虑系统处于稳态，此时计数器的值为 $v$。根据“紧密循环”和“持续竞争”的设定，所有 $N$ 个核心都将读取值 $v$ 并准备执行 `CAS(address, v, v+1)`。然后，所有 $N$ 个核心在互联队列中都会有一个待处理的 CAS 请求。\n\n公平的仲裁器将从这 $N$ 个请求中选择一个进行服务。假设核心 $C_1$ 的请求被选中。由于内存中的值仍然是 $v$，这个 CAS 将会成功。这次成功的原子操作尝试需要 $L$ 个周期，计数器的值被更新为 $v+1$。\n\n现在，考虑剩下的 $N-1$ 个核心。它们待处理的 CAS 尝试都基于旧的、过时的期望值 $v$。当公平的仲裁器逐一服务这 $N-1$ 个请求时，每个 CAS 都会失败，因为内存中的值现在是 $v+1$，与期望值 $v$ 不匹配。根据问题描述，每次失败的原子操作尝试也会占用串行化点 $L$ 个周期。\n\n因此，为了发生一次成功的增量操作，系统必须处理一次成功的 CAS 尝试，以及随后的 $N-1$ 次失败的 CAS 尝试。一次成功增量所需的串行化尝试总数为 $1 + (N-1) = N$。\n\n完成一次增量所花费的总时间是这 $N$ 次串行化尝试的时间：\n$$\n\\text{Total time per increment} = N \\text{ attempts} \\times L \\frac{\\text{cycles}}{\\text{attempt}} = NL \\text{ cycles}\n$$\n因此，基于 CAS 的设计的吞吐量为：\n$$\n\\text{Throughput}_{\\text{CAS}} = \\frac{1 \\text{ increment}}{NL \\text{ cycles}} = \\frac{1}{NL}\n$$\n这个结果也可以从概率的角度来理解。在任何多个核心以相同的 `expected_value` 进行竞争的时刻，任何一个给定核心的尝试有 $\\frac{1}{N}$ 的概率成功。在成功概率为 $p$ 的几何分布中，获得一次成功所需的期望试验次数是 $\\frac{1}{p}$。在这里，“试验”是指串行化的 $L$ 周期时隙，而在任何给定槽中成功的有效概率是 $\\frac{1}{N}$（一个成功的结果分布在 $N$ 个竞争尝试中）。因此，每次增量所需的期望时隙数（也就是尝试次数）是 $N$，从而导致期望时间为 $NL$ 个周期。\n\n**3. 吞吐量比率 R**\n\n问题将吞吐量比率 $R$ 定义为 FAA 吞吐量除以 CAS 吞吐量。\n$$\nR = \\frac{\\text{Throughput}_{\\text{FAA}}}{\\text{Throughput}_{\\text{CAS}}}\n$$\n代入上面推导出的表达式：\n$$\nR = \\frac{\\frac{1}{L}}{\\frac{1}{NL}}\n$$\n简化表达式可得：\n$$\nR = \\frac{1}{L} \\times \\frac{NL}{1} = N\n$$\n吞吐量比率 $R$ 等于核心数 $N$。这表明，对于这种无退避的高竞争模型，就利用内存串行化点来完成此特定任务而言，硬件 FAA 原语的效率是基于软件的 CAS 循环的 $N$ 倍。", "answer": "$$\n\\boxed{N}\n$$", "id": "3621231"}, {"introduction": "原子操作确保了单个操作的不可分割性，但这并不足以解决无锁编程中的所有逻辑难题。ABA问题便是一个典型的例子，即使每次操作都是原子的，一个值在被读取后、CAS操作执行前，可能被改变（$A \\rightarrow B$）然后又变回原值（$B \\rightarrow A$），从而导致陈旧的CAS操作意外成功。这个练习[@problem_id:3621915]将帮助你具体地识别一个无锁栈实现中ABA问题的发生过程，并从根本上推导出需要多少位的“版本标签”才能有效规避此类风险。", "problem": "一个无锁的后进先出 (LIFO) 空闲列表被实现为一个单向链式栈，其头部使用原子比较并交换 (CAS) 指令进行更新。比较并交换 (CAS) 接受三个参数：一个地址、一个期望值和一个新值；它原子地将该地址的当前内容与期望值进行比较，并且仅当它们按位相等时，才写入新值，并返回操作是否成功。在基本设计中，头部是一个指向栈顶节点的单字长指针。考虑两个线程，每个线程执行入栈或出栈操作，所有更新都在成功的 CAS 操作时刻线性化。\n\nA部分。请阐释经典的 ABA 异常如何在没有任何标签或版本控制的此空闲列表中发生，方法是指定一个可能的交错执行：一个线程读取头指针为一个标记为 $A$ 的节点，另一个线程将 $A$ 出栈，执行一系列入栈和出栈操作，并最终将头指针恢复为 $A$，导致第一个线程的过时 CAS 操作成功，尽管逻辑上的栈已经改变。\n\n为了缓解 ABA 问题，头部被扩展为一个封装在单个机器字中的值对 $\\left(p, t\\right)$，其中 $p$ 是指针，$t$ 是一个 $b$ 位标签。在每次成功的头部更新时，该实现将 $t$ 的值加 1（模 $2^{b}$），并使用对该封装字的单次 CAS 操作写入新的值对。任何线程执行的 CAS 操作都会将 $p$ 和 $t$ 与其先前读取的过时值对进行比较。\n\nB部分。假设对于任何线程，在其读取 $\\left(p, t\\right)$ 的时刻和执行其 CAS 的时刻之间，所有线程组合起来最多可以有 $n$ 次成功的头部更新。请从第一性原理出发，推导最小标签宽度 $b$ 作为 $n$ 的函数，以保证在该时间窗口内，没有任何过时的值对 $\\left(p, t\\right)$ 能够再次与当前的头部值对匹配（即使指针 $p$ 被重用），从而使得过时的 CAS 操作不会因标签回绕而成功。请用一个关于 $n$ 的单一闭式解析表达式表示你的最终答案。不要假设任何特定的数据字长，并将 $n$ 视为任意正整数。最终答案必须是一个没有单位的表达式。", "solution": "我们从比较并交换 (CAS) 的操作性定义开始：对一个地址执行 CAS 会原子地将当前值与一个期望值进行比较，并且当且仅当它们按位相等时，才写入一个新值。在一个实现为栈的无锁空闲列表中，入栈和出栈操作都使用 CAS 来更新头指针。线性一致性要求一个操作的逻辑效果在其 CAS 成功的那一刻发生。\n\nA部分要求演示 ABA 异常。考虑头部初始指向标记为 $A$ 的节点。一个典型的交错执行如下：\n- 线程 $T_{1}$ 读取头指针并观察到 $A$。它基于此观察计算一个新的头部，但在执行其 CAS 操作前被延迟。\n- 线程 $T_{2}$ 从栈中将 $A$ 出栈。头部现在指向某个其他节点（比如 $B$），或者如果栈的大小为 1，则变为 $\\text{null}$。\n- 线程 $T_{2}$ 继续按某种顺序入栈和出栈其他节点。特别是，它可能将 $A$ 重新压入栈顶，从而将头指针恢复为 $A$。\n- 线程 $T_{1}$ 恢复执行并执行其 CAS 操作，该操作仅比较指针值。因为头指针再次变为 $A$，CAS 看到了期望的指针并成功执行，尽管在 $T_{1}$ 读取和执行 CAS 之间，栈的逻辑内容已发生了任意改变。这就是 ABA 异常：观察到的值从 $A$ 变为某个 $X$ 再回到 $A$，掩盖了中间的变更。\n\nB部分通过增加一个版本标签来扩展头部，以区分同一指针值的不同实例。头部是一个值对 $\\left(p, t\\right)$，其中 $t$ 是一个 $b$ 位计数器，在每次成功的头部更新时，其值会加 1（模 $2^{b}$）。线程执行的 CAS 操作现在会将 $p$ 和 $t$ 都与其先前读取的值对进行比较。目标是选择合适的 $b$，使得在任何线程读取 $\\left(p, t\\right)$ 后尝试执行 CAS 的时间窗口内，标签的回绕次数不足以使同一指针的标签值再次变回原来的值，即使指针 $p$ 被重用。\n\n我们将该要求形式化：设一个线程在时间 $\\tau$ 读取头部为 $\\left(p_{0}, t_{0}\\right)$。在 $\\tau$ 和该线程于时间 $\\tau'$ 执行 CAS 之间，假设所有线程共有 $k$ 次成功的头部更新，其中 $k$ 满足 $1 \\leq k \\leq n$。每次成功的更新都将标签加 1（模 $2^{b}$）。因此，在时间 $\\tau'$，与头部关联的当前标签值为\n$$\nt' \\equiv t_{0} + k \\pmod{2^{b}}.\n$$\n为防止过时的 CAS 因标签回绕而成功，我们必须确保在 $1 \\leq k \\leq n$ 范围内的任何 $k$ 都不会导致 $t' = t_{0} \\pmod{2^{b}}$。也就是说，我们要求\n$$\n\\forall k \\in \\{1, 2, \\dots, n\\}, \\quad k \\not\\equiv 0 \\pmod{2^{b}}.\n$$\n等价地，我们要求模数 $2^{b}$ 超过该时间窗口内可能的最大增量次数，以使 $2^{b}$ 的任何倍数都不在集合 $\\{1, \\dots, n\\}$ 中。此条件为\n$$\n2^{b} > n.\n$$\n满足此严格不等式的最小整数 $b$ 可通过对 $n+1$ 取以 2 为底的对数并使用上取整函数得到：\n$$\nb = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil.\n$$\n为了验证其最小性，假设 $b' = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil - 1$。那么 $2^{b'} \\leq n$，因此存在某个 $k = 2^{b'}$，满足 $1 \\leq k \\leq n$ 且 $k \\equiv 0 \\pmod{2^{b'}}$，这意味着标签可能回绕到相同的值。因此，任何更小的 $b$ 都无法保证在该时间窗口内标签不被重用。故所推导的表达式既是必要的也是充分的。\n\n此推导仅依赖于 CAS 的原子性定义、每次成功头部变更时标签加一的更新规则，以及基本的模运算。它确保了即使指针 $p$ 重新出现（例如，由于内存重用），在最多 $n$ 次更新的任何窗口内，标签部分也会不同，从而防止过时的 CAS 在遇到相同的 $\\left(p, t\\right)$ 值对时成功。", "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil}$$", "id": "3621915"}, {"introduction": "正确的并发编程不仅需要原子操作，还需要对内存模型的深刻理解，特别是内存操作在不同线程间的排序和可见性。双重检查锁定（Double-Checked Locking）是一个经典的优化模式，它试图在保证线程安全的同时减少同步开销，但其朴素的实现方式在现代弱内存模型处理器上存在严重缺陷。本练习[@problem_id:3621227]要求你仔细分析该模式的多种实现，辨别出为何简单的原子读写不足以保证正确性，并理解为何必须使用如“释放-获取”（release-acquire）这样的内存排序语义来构建可靠的、高性能的并发代码。", "problem": "一个并发程序使用双重检查初始化模式来发布一个堆分配的单例对象。有一个共享的原子指针 $P$ 指向一个结构体 $S$，该结构体有两个整数字段 $a$ 和 $b$。指针 $P$ 初始为 $\\text{null}$。目标是确保一旦任何线程观察到 $P \\neq \\text{null}$，它随后将观察到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$，其中 $r = P$。\n\n线程执行以下高级逻辑：\n- 读线程中的快速路径检查：以内存顺序 $mo_R$ 读取 $P$。如果结果不是 $\\text{null}$，则从 $P$ 指向的对象中读取字段 $a$ 和 $b$。\n- 慢速路径（初始化）在 $P$ 为 $\\text{null}$ 时由恰好一个线程执行：\n  1. 分配一个 $S$ 类型的新对象 $t$。\n  2. 按程序顺序使用普通（非原子）存储写入 $t \\rightarrow a \\leftarrow 1$ 和 $t \\rightarrow b \\leftarrow 2$。\n  3. 使用具有内存顺序 $mo_W$ 的原子原语将 $t$ 发布到 $P$。\n\n假设一个弱序多处理器（例如，一个在没有排序约束的情况下硬件可能会重排独立内存操作的系统）。同时假设原子操作的标准释放/获取公理：具有释放语义的存储可以与读取该存储所写值的具有获取语义的加载建立“同步于”（synchronizes-with）关系，从而创建一个“先行发生”（happens-before）边，使得先前的写入在观察线程中排序于后续的读取之前。具有松散内存顺序的操作对该位置强制原子性，但本身不会对跨线程的其他内存操作进行排序。\n\n在步骤3和读线程中可以使用以下机制：\n- 比较并交换（Compare-And-Swap, CAS）：一种原子性的读-修改-写操作，成功时写入新值并返回成功；失败时返回观察到的旧值。其成功和失败的内存顺序可以选择。\n- 链接加载/条件存储（Load-Linked/Store-Conditional, LL/SC）：一个原子对，加载一个值（LL）并在没有中间冲突写入发生的情况下有条件地存储一个新值（SC）。\n- 测试并设置（Test-and-Set, TAS）：一种原子原语，写入一个值（例如，设置一个锁）并返回旧值。\n\n考虑以下关于双重检查初始化的正确性以及当 $mo$ 为松散时在弱内存模型下可能结果的五个论断。选择所有正确的论断。\n\nA. 使用比较并交换（CAS）将 $t$ 发布到 $P$，其中成功的 CAS 对 $mo_W$ 具有释放语义，并且读线程通过以获取语义加载 $P$ 来执行快速路径检查（$mo_R$），这保证了任何观察到 $P \\neq \\text{null}$ 的读线程随后都将观察到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。\n\nB. 如果步骤3中的发布操作和读线程的快速路径加载都使用松散内存顺序（即 $mo_W = \\text{relaxed}$ 和 $mo_R = \\text{relaxed}$），那么在弱序架构上，读线程有可能观察到 $P \\neq \\text{null}$，但仍然读到 $r \\rightarrow a = 0$ 和 $r \\rightarrow b = 0$。\n\nC. 用链接加载/条件存储（LL/SC）对替换 CAS 来将 $t$ 发布到 $P$，不使用任何显式内存屏障，并且读线程仍然使用对 $P$ 的松散加载，这足以保证一旦观察到 $P \\neq \\text{null}$，随后的读取将看到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。\n\nD. 使用以测试并设置（TAS）实现的自旋锁来保护初始化，该自旋锁提供互斥但加锁时没有获取语义，解锁时没有释放语义，而读线程在快速路径上仍然使用对 $P$ 的松散加载，这足以防止任何读线程在 $P$ 变为非 $\\text{null}$ 后观察到部分初始化的对象。\n\nE. 使用显式内存屏障代替释放/获取原子操作，具体如下：初始化线程在发布 $t$ 到 $P$ 的松散存储操作之前立即执行一个释放屏障，而任何发现 $P \\neq \\text{null}$ 的读线程在松散加载 $P$ 之后、读取 $r \\rightarrow a$ 和 $r \\rightarrow b$ 之前立即执行一个获取屏障，这是充分的。\n\n答案选项是：\n- A\n- B\n- C\n- D\n- E", "solution": "用户需要对一个关于弱序多处理器上双重检查初始化模式的并发编程问题进行批判性分析。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 一个并发程序使用双重检查初始化模式实现单例。\n- 有一个共享的原子指针 `$P$` 指向一个结构体 `$S$`。\n- 结构体 `$S$` 有两个整数字段 `$a$` 和 `$b$`。\n- `$P$` 的初始值是 `$\\text{null}$`。\n- 正确性目标是：如果任何线程观察到 `$P \\neq \\text{null}$`，它必须随后观察到 `$r \\rightarrow a = 1$` 和 `$r \\rightarrow b = 2$`，其中 `$r = P$`。\n- 读线程快速路径逻辑：以内存顺序 `$mo_R$` 读取 `$P$`。如果不是 `$\\text{null}$`，则读取字段 `$a$` 和 `$b$`。\n- 初始化慢速路径逻辑（由一个线程执行）：\n  1. 分配一个 `$S$` 类型的新对象 `$t$`。\n  2. 使用普通（非原子）存储按程序顺序写入 `$t \\rightarrow a \\leftarrow 1$` 和 `$t \\rightarrow b \\leftarrow 2$`。\n  3. 使用具有内存顺序 `$mo_W$` 的原子原语将 `$t$` 发布到 `$P$`。\n- 系统假设：\n  - 弱序多处理器（硬件可能重排独立内存操作）。\n  - 标准的释放/获取公理：一个 `release` 存储 `synchronizes-with` (同步于)一个读取其值的 `acquire` 加载，从而创建一个 `happens-before` (先行发生)关系。\n  - `relaxed` 内存顺序提供原子性，但不提供跨线程的其他内存操作的排序。\n- 可用原语：比较并交换 (`$\\text{CAS}$`), 链接加载/条件存储 (`$\\text{LL/SC}$`), 测试并设置 (`$\\text{TAS}$`)。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学基础：** 该问题牢固地植根于计算机体系结构和并发编程的原理。它涉及标准且定义明确的概念，如内存一致性模型、原子操作（`$\\text{CAS}$`、`$\\text{LL/SC}$`）、内存排序语义（`release`、`acquire`、`relaxed`）以及 `happens-before` 关系。这些都是系统级计算机科学的核心主题。\n- **定义明确：** 该问题定义明确。它提出了一个清晰的场景（双重检查锁定）、一个精确的目标（对象的安全发布）以及一组明确的假设（弱内存模型、原子操作的语义）。任务是根据这个形式化背景评估五个具体论断，每个论断都有唯一、正确的分析结果。\n- **客观性：** 问题陈述是客观的，并使用了精确、标准的术语。诸如“release semantics”（释放语义）、“acquire semantics”（获取语义）或“weakly ordered”（弱序）等术语没有歧义。\n\n**步骤3：结论与行动**\n问题陈述是有效的。这是一个标准且不平凡的并发编程问题，具有科学合理性、定义明确且客观。解决方案将基于内存一致性模型的原理，逐一分析每个论断。\n\n### 解决方案推导\n\n核心挑战是防止对字段 `$a$` 和 `$b$` 的数据竞争。在弱序架构上，如果没有明确的排序约束，初始化 `$a$` 和 `$b$` 的写入操作不保证与发布指针 `$P$` 的写入操作同时对另一个线程可见。一个读线程可能看到 `$P$` 的非 `$\\text{null}$` 值，但读到 `$a$` 和 `$b$` 的未初始化（默认，例如 `$0$`）值。\n\n为保证正确性，必须在对象字段的初始化与另一线程对这些字段的后续读取之间建立一个 `happens-before` (先行发生)关系。实现这一点的标准机制是在写线程中对同一原子变量(`$P$`)使用 `release` (释放)操作，在读线程中使用 `acquire` (获取)操作。\n\n对 `$P$` 进行带有 `release` 语义的存储，可以确保在程序顺序中所有先于它的内存写入（即对 `$a$` 和 `$b$` 的写入）对其他线程可见。从 `$P$` 进行带有 `acquire` 语义的加载，可以确保在程序顺序中所有后于它的内存读取（即对 `$a$` 和 `$b$` 的读取）将看到由相应 `release` 操作可见的写入效果。`release` 和 `acquire` 的配对 `synchronizes-with` (同步于)，从而建立了必要的 `happens-before` 边。\n\n现在，我们评估每个论断。\n\n**A. 使用比较并交换（CAS）将 $t$ 发布到 $P$，其中成功的 CAS 对 $mo_W$ 具有释放语义，并且读线程通过以获取语义加载 $P$ 来执行快速路径检查（$mo_R$），这保证了任何观察到 $P \\neq \\text{null}$ 的读线程随后都将观察到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。**\n\n- **分析：** 这描述了使用现代原子操作实现双重检查锁定模式的规范正确方法。\n  - 初始化线程执行写入 `$t \\rightarrow a \\leftarrow 1$` 和 `$t \\rightarrow b \\leftarrow 2$`。这些写入在对 `$P$` 的 `release` `$\\text{CAS}$` 操作之前发生。\n  - 读线程对 `$P$` 执行 `acquire` 加载。\n  - 如果读线程的加载读取了写线程的 `$\\text{CAS}$` 所写入的值，则 `release` `$\\text{CAS}$` 与 `acquire` 加载 `synchronizes-with`（同步于）。\n  - 这种 `synchronizes-with` 关系建立了一个 `happens-before` 边。通过传递性，对 `$a$` 和 `$b$` 的写入在读线程中先于对 `$a$` 和 `$b$` 的读取。\n  - 因此，任何通过 `acquire` 加载看到非 `$\\text{null}$` 指针的读线程都保证能看到 `$a$` 和 `$b$` 的正确初始化值。\n- **结论：** **正确**。\n\n**B. 如果步骤3中的发布操作和读线程的快速路径加载都使用松散内存顺序（即 $mo_W = \\text{relaxed}$ 和 $mo_R = \\text{relaxed}$），那么在弱序架构上，读线程有可能观察到 $P \\neq \\text{null}$，但仍然读到 $r \\rightarrow a = 0$ 和 $r \\rightarrow b = 0$。**\n\n- **分析：** `Relaxed` (松散)内存排序仅保证对 `$P$` 本身操作的原子性。它不提供与其他内存操作相关的排序约束。\n  - 在写线程中，CPU或编译器可以自由地将对 `$P$` 的 `relaxed` 原子存储重排到对 `$t \\rightarrow a$` 和 `$t \\rightarrow b$` 的非原子存储之前。\n  - 即使在写线程中写入没有被重排，它们向内存系统和其他缓存的传播也不是同步的。一个读线程可能观察到 `$P$` 的更新值（因为该写入已到达其缓存），而对 `$a$` 和 `$b$` 的写入尚未传播且不可见。读线程会加载一个有效的指针，但从对象中读到未初始化或陈旧的数据。这是朴素双重检查锁定的典型失败模式。\n- **结论：** **正确**。该论断准确描述了一种可能且众所周知的失败场景。\n\n**C. 用链接加载/条件存储（LL/SC）对替换 CAS 来将 $t$ 发布到 $P$，不使用任何显式内存屏障，并且读线程仍然使用对 $P$ 的松散加载，这足以保证一旦观察到 $P \\neq \\text{null}$，随后的读取将看到 $r \\rightarrow a = 1$ 和 $r \\rightarrow b = 2$。**\n\n- **分析：** 一次成功的 `$\\text{Store-Conditional}$` (`$\\text{SC}$`) 操作在许多架构上通常具有隐式的 `release` 语义。然而，为了使同步完整，读线程必须使用 `acquire` 语义。该论断指出读线程使用 `relaxed` 加载。一个 `release` 存储（即使是通过 `$\\text{SC}$` 隐式实现的）不会与一个 `relaxed` 加载 `synchronize-with`。在写线程的字段初始化和读线程的字段访问之间没有创建 `happens-before` 边。因此，情况并不比使用 `release` 存储和 `relaxed` 加载更好，这是不正确的，并且会遇到与选项B中相同的潜在数据竞争。\n- **结论：** **不正确**。\n\n**D. 使用以测试并设置（TAS）实现的自旋锁来保护初始化，该自旋锁提供互斥但加锁时没有获取语义，解锁时没有释放语义，而读线程在快速路径上仍然使用对 $P$ 的松散加载，这足以防止任何读线程在 $P$ 变为非-$\\text{null}$ 后观察到部分初始化的对象。**\n\n- **分析：** 锁保证了临界区的互斥，确保只有一个线程可以执行初始化。然而，锁的排序保证仅适用于获取和释放同一个锁的线程之间。快速路径上的读线程根本不与锁交互。它们对 `$P$` 执行 `relaxed` 加载。由于锁的 `unlock` 操作被指定为没有 `release` 语义，且对 `$P$` 的写入也未指定具有 `release` 语义，因此写线程中没有任何操作可以与读线程 `synchronize-with`。读线程的 `relaxed` 加载无法建立一个 `acquire` 屏障。因此，不存在 `happens-before` 关系，读线程仍然可能观察到部分初始化的对象。\n- **结论：** **不正确**。\n\n**E. 使用显式内存屏障代替释放/获取原子操作，具体如下：初始化线程在发布 $t$ 到 $P$ 的松散存储操作之前立即执行一个释放屏障，而任何发现 $P \\neq \\text{null}$ 的读线程在松散加载 $P$ 之后、读取 $r \\rightarrow a$ 和 $r \\rightarrow b$ 之前立即执行一个获取屏障，这是充分的。**\n\n- **分析：** 这描述了使用内存屏障实现所需排序的另一种方法。\n  - **写线程：** 顺序是：（对 `$a, b$` 的写入）；`release_fence()`；`relaxed_store(P, t)`。`release_fence`（释放屏障）防止任何先前的内存访问（对 `$a$` 和 `$b$` 的写入）被重排到任何后续的存储操作（对 `$P$` 的存储）之后。\n  - **读线程：** 顺序是：`r = relaxed_load(P)`；`acquire_fence()`；（对 `$r \\rightarrow a, r \\rightarrow b$` 的读取）。`acquire_fence`（获取屏障）防止任何后续的内存访问（对 `$a$` 和 `$b$` 的读取）被重排到任何先前的加载操作（对 `$P$` 的加载）之前。\n  - 在一个线程中 `release fence` 后跟一个存储，以及在另一个线程中一个加载后跟一个 `acquire fence` 的组合，会创建一个 `synchronizes-with` 关系，前提是加载读取了存储所写的值。这建立了必要的 `happens-before` 边。其效果等同于使用 `release` 存储和 `acquire` 加载。\n- **结论：** **正确**。", "answer": "$$\\boxed{ABE}$$", "id": "3621227"}]}