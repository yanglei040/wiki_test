{"hands_on_practices": [{"introduction": "我们将从一个经典的“石蕊测试”开始，它直观地揭示了当从理想化的顺序一致性（Sequential Consistency, SC）模型过渡到更现实的宽松模型时，可能出现的令人意外的程序结果。这个练习将并排比较顺序一致性（SC）、完全存储定序（Total Store Order, TSO）和释放-获取（Release-Acquire）模型，以突显它们在内存操作排序保证上的根本差异，并引出内存栅栏（memory fences）作为恢复程序执行顺序的工具。通过这个练习，你将理解为什么需要比简单地编写代码更深入地思考并发问题 [@problem_id:3656650]。", "problem": "考虑一个在共享内存多处理器上运行的双线程程序，该程序在不同的内存一致性模型下执行。共享变量为 $x$ 和 $y$，初始值均为 $0$。线程 $T_1$ 执行程序片段 $x := 1; \\ r_1 := y$，线程 $T_2$ 执行 $y := 1; \\ r_2 := x$。假设 $T_1$ 和 $T_2$ 并发运行。您将分析在三种内存模型下出现 $r_1 = r_2 = 0$ 这一结果的可能性，并确定需要什么样的操作系统（OS）级别的内存屏障（fence）来禁止此结果。这三种模型是顺序一致性（Sequential Consistency, SC）、全存储定序（Total Store Order, TSO）和释放/获取（release/acquire, RA）。\n\n使用以下基本原则：\n- 顺序一致性（SC）的定义：所有操作的执行看起来遵循一个单一的全序关系，该全序与每个独立线程的程序顺序一致。\n- 全存储定序（TSO）的核心属性：一个线程自身的写操作可以被缓冲，允许后续的读操作绕过（bypass）先前对不同位置的写操作，同时保留写-写程序顺序和读-读程序顺序。\n- 释放/获取（RA）的语义：一个释放存储（release store）操作会使其所在线程中所有先前的操作排在它之前，而一个获取加载（acquire load）操作会使其自身排在所在线程中所有后续操作之前；线程间的顺序关系仅在获取操作读取了由释放操作写入的值时才会产生，从而建立一个“同步于”（synchronizes-with）的边。\n\n对于每种模型，基于这些原则进行推理，以确定 $r_1 = r_2 = 0$ 是否可能发生。然后，确定需要放置什么样的最小化OS级别内存屏障（如果有的话）来禁止 $r_1 = r_2 = 0$ 这一结果。一个OS级别的内存屏障是任何根据规范能够阻止同一线程中后续的加载操作观察到如同它被重排到先前的存储操作之前一样的内存状态，并确保先前的存储操作在该线程的后续加载操作继续进行前对全局可见的屏障。\n\n哪个选项正确地描述了各种结果和所需的内存屏障？\n\nA. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 TSO 和 RA 下禁止 $r_1 = r_2 = 0$，在每个线程的存储操作和随后的加载操作之间放置一个完整的内存屏障就足够了。\n\nB. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是不可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是不可能的；在任何模型下都不需要内存屏障。\n\nC. 在顺序一致性（SC）和全存储定序（TSO）下，$r_1 = r_2 = 0$ 都是不可能的，但在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 RA 下禁止它，在每个线程中使用一个释放存储后跟一个获取加载就足够了，无需额外的内存屏障。\n\nD. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是不可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 RA 下禁止它，仅在每个线程的存储操作前放置一个释放屏障就足够了。\n\nE. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是不可能的；为了在 TSO 上禁止它，在每个线程的存储操作前放置一个只写屏障就足够了。", "solution": "对问题陈述的有效性进行分析。\n\n### 步骤 1：提取已知条件\n- **线程与共享内存：** 两个线程 $T_1$ 和 $T_2$，运行在共享内存多处理器上。\n- **共享变量与初始状态：** $x$ 和 $y$，初始值均为 $0$。\n- **线程程序：**\n    - $T_1$：执行 $x := 1; \\ r_1 := y$。\n    - $T_2$：执行 $y := 1; \\ r_2 := x$。\n    - $r_1$ 和 $r_2$ 是线程本地寄存器。\n- **待分析的结果：** $r_1 = 0$ 且 $r_2 = 0$ 的最终状态。\n- **内存模型与定义：**\n    1. **顺序一致性 (SC):** 所有操作的执行看起来遵循一个单一的全序关系，该全序与每个独立线程的程序顺序一致。\n    2. **全存储定序 (TSO):** 一个线程自身的写操作可以被缓冲，允许后续的读操作绕过先前对不同位置的写操作，同时保留写-写程序顺序和读-读程序顺序。\n    3. **释放/获取 (RA):** 一个释放存储操作会使其所有先前的操作排在它之前，而一个获取加载操作会使其自身排在所有后续操作之前。线程间的顺序关系（一个“同步于”关系）仅在一个获取加载读取了由一个释放存储写入的值时才建立。基线操作是普通的存储和加载，在松散内存上下文（RA 的领域）中，默认情况下它们之间不保证顺序。\n- **内存屏障定义：** 一个OS级别的内存屏障可以阻止同一线程中后续的加载操作被重排到先前的存储操作之前，并确保先前的存储操作在该线程的后续加载操作继续进行前对全局可见。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述在科学上是合理的、定义明确的且客观的。\n- **科学依据：** 问题使用了一个经典例子（一个简化的互斥进入协议，也称为存储缓冲石蕊测试）来区分基本的内存一致性模型（SC、TSO、RA）。所提供的定义是这些模型的标准且准确的描述。\n- **定义明确：** 问题提供了所有必要信息：初始条件、线程程序和内存模型的定义。问题是精确的，询问在每种模型下特定结果是否可能，以及如何阻止它。可以从这些前提中推导出一个唯一且有意义的解。\n- **客观性：** 问题以形式化、无歧义的术语陈述。没有主观或模糊的元素。\n\n### 步骤 3：结论与行动\n问题是有效的。将推导出一个完整的解决方案。\n\n### 推导与分析\n\n让我们将操作表示如下：\n- $S_1$：$T_1$ 的存储操作，$x := 1$。\n- $L_1$：$T_1$ 的加载操作，$r_1 := y$。\n- $S_2$：$T_2$ 的存储操作，$y := 1$。\n- $L_2$：$T_2$ 的加载操作，$r_2 := x$。\n\n初始状态为 $x=0, y=0$。被评估的结果是 $r_1 = 0$ 和 $r_2 = 0$。这个结果要求 $L_1$ 观察到 $y$ 的初始值，而 $L_2$ 观察到 $x$ 的初始值。\n\n**1. 在顺序一致性（SC）下的分析**\n在 SC 模型下，所有操作必须呈现为一个单一的全局全序，并且这个顺序必须尊重每个线程内部的程序顺序。程序顺序为 $S_1$ 在 $L_1$ 之前（表示为 $S_1 \\rightarrow_p L_1$）和 $S_2$ 在 $L_2$ 之前（表示为 $S_2 \\rightarrow_p L_2$）。\n为了使 $r_1 = 0$ 和 $r_2 = 0$ 的结果发生：\n- $L_1$ 必须在 $S_2$ 全局可见之前执行。在一个全序中，这意味着 $L_1$ 在 $S_2$ 之前。\n- $L_2$ 必须在 $S_1$ 全局可见之前执行。在一个全序中，这意味着 $L_2$ 在 $S_1$ 之前。\n将这些与程序顺序约束结合起来，我们得到了全序的一个依赖循环：\n$S_1 \\rightarrow_p L_1$（$T_1$ 中的程序顺序）\n$L_1 \\rightarrow S_2$（为了 $r_1 = 0$）\n$S_2 \\rightarrow_p L_2$（$T_2$ 中的程序顺序）\n$L_2 \\rightarrow S_1$（为了 $r_2 = 0$）\n这构成了循环：$S_1 \\rightarrow L_1 \\rightarrow S_2 \\rightarrow L_2 \\rightarrow S_1$。一个全序不能包含循环。因此，不可能构造出一个有效的 SC 执行来导致 $r_1 = 0$ 和 $r_2 = 0$ 的结果。至少有一个加载操作必须观察到另一个线程写入的新值。\n**SC 的结论：** 结果 $r_1 = r_2 = 0$ 是**不可能的**。不需要内存屏障。\n\n**2. 在全存储定序（TSO）下的分析**\nTSO 模型允许一个线程自己的写操作被缓冲。后续对一个*不同*内存位置的加载操作可以绕过已缓冲的存储操作。这等效于当存储和加载针对不同地址时，允许存储-加载重排（Store-Load reordering）。\n- 在 $T_1$ 中，存储操作是对 $x$ 进行，加载操作是从 $y$ 读取。由于 $x \\neq y$，这些操作可以被有效地重排。执行过程可能看起来像是 $L_1$ 在 $S_1$ 之前发生。\n- 在 $T_2$ 中，存储操作是对 $y$ 进行，加载操作是从 $x$ 读取。由于 $y \\neq x$，这些操作可以被有效地重排。执行过程可能看起来像是 $L_2$ 在 $S_2$ 之前发生。\n这导致了重排后操作的一种可能的交错执行方式：\n1. $T_1$ 执行其加载操作：$L_1 (r_1 := y)$。$y$ 的值是其初始值 $0$。所以，$r_1$ 变为 $0$。\n2. $T_2$ 执行其加载操作：$L_2 (r_2 := x)$。$x$ 的值是其初始值 $0$。所以，$r_2$ 变为 $0$。\n3. $T_1$ 从其缓冲区提交存储操作：$S_1 (x := 1)$。共享内存中 $x$ 的值变为 $1$。\n4. $T_2$ 从其缓冲区提交存储操作：$S_2 (y := 1)$。共享内存中 $y$ 的值变为 $1$。\n这个执行在 TSO 模型下是有效的，并导致 $r_1=0, r_2=0$。\n**TSO 的结论：** 结果 $r_1 = r_2 = 0$ 是**可能的**。为了禁止它，必须阻止存储-加载重排。在每个线程的存储和加载操作之间放置一个如问题中所定义的内存屏障（$S_1; \\text{fence}; L_1$ 和 $S_2; \\text{fence}; L_2$），可以强制存储操作在加载操作进行之前全局可见，从而禁止该结果。\n\n**3. 在释放/获取（RA）下的分析**\nRA 模型为 `release` 存储和 `acquire` 加载提供了特定的语义。问题陈述给出的代码是普通的存储和加载操作（$x := 1; r_1 := y; \\dots$）。在提供 RA 语义的架构（例如 ARM、RISC-V）的上下文中，普通的内存操作是“松散的”（relaxed）或“弱顺序的”（weakly ordered）。这意味着，默认情况下，对不同地址的内存操作可以被硬件重排。\n因此，这种情况类似于 TSO，但可能允许更多的重排（尽管对于这个特定问题，只有存储-加载重排是相关的）。\n- 在 $T_1$ 中：$S_1$ 和 $L_1$ 针对不同地址，因此可以被重排。\n- 在 $T_2$ 中：$S_2$ 和 $L_2$ 针对不同地址，因此可以被重排。\n在 TSO 下可能的相同执行轨迹在这里也是可能的，导致结果 $r_1=0, r_2=0$。\n**RA 的结论：** 结果 $r_1 = r_2 = 0$ 是**可能的**。与 TSO 一样，禁止此结果需要阻止存储-加载重排。在每个线程的存储和加载之间放置一个完整的内存屏障是实现此目的的充分机制。或者，也可以使用特定的 RA 操作（例如，`store-release` 后跟 `load-acquire`，或一个 `release` 屏障），但选项中描述的最通用的解决方案是一个完整的内存屏障。\n\n### 逐项分析选项\n\n**A. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 TSO 和 RA 下禁止 $r_1 = r_2 = 0$，在每个线程的存储操作和随后的加载操作之间放置一个完整的内存屏障就足够了。**\n- SC 结果：“不可能”。正确。\n- TSO 结果：“可能”。正确。\n- RA 结果：“可能”。正确，在松散内存模型中对普通操作的标准解释下。\n- 内存屏障解决方案：“在每个线程的存储操作和随后的加载操作之间放置一个完整的内存屏障就足够了”。正确。这个屏障明确地阻止了导致该结果的存储-加载重排。\n**结论：正确。**\n\n**B. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是不可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是不可能的；在任何模型下都不需要内存屏障。**\n- SC 结果：“可能”。不正确。\n- TSO 结果：“不可能”。不正确。\n- RA 结果：“不可能”。不正确。\n**结论：不正确。**\n\n**C. 在顺序一致性（SC）和全存储定序（TSO）下，$r_1 = r_2 = 0$ 都是不可能的，但在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 RA 下禁止它，在每个线程中使用一个释放存储后跟一个获取加载就足够了，无需额外的内存屏障。**\n- TSO 结果：“不可能”。不正确。TSO 是一个典型模型的例子（比完全松散模型强），但由于存储缓冲，它仍然允许这种结果。\n**结论：不正确。**\n\n**D. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是不可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是可能的；为了在 RA 下禁止它，仅在每个线程的存储操作前放置一个释放屏障就足够了。**\n- TSO 结果：“不可能”。不正确。\n- 为 RA 提议的内存屏障也不是阻止存储-加载重排的标准或正确方法。一个释放屏障主要对其*之前*的操作相对于其*之后*的操作进行排序。一个 `fence_release; store; load` 序列不保证 `store` 和 `load` 之间的顺序。\n**结论：不正确。**\n\n**E. 在顺序一致性（SC）下，$r_1 = r_2 = 0$ 是不可能的；在全存储定序（TSO）下，$r_1 = r_2 = 0$ 是可能的；在释放/获取（RA）下，$r_1 = r_2 = 0$ 是不可能的；为了在 TSO 上禁止它，在每个线程的存储操作前放置一个只写屏障就足够了。**\n- RA 结果：“不可能”。不正确。这假设在 RA 模型中普通操作以某种方式被隐式排序，这不是标准的解释。\n- 为 TSO 提议的内存屏障是不正确的。一个写屏障（或存储屏障）通常对写操作相对于其他写操作进行排序；它不阻止后续的加载操作绕过先前的写操作。需要一个存储-加载屏障。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3656650"}, {"introduction": "在了解到 TSO 模型允许 SC 模型所禁止的执行结果后，本练习将带你深入探究其背后的“为什么”。通过模拟每个核心私有的存储缓冲区（store buffer）的行为，你将学会如何精确预测一个程序在 TSO 模型下所有可能的最终状态。这个练习将帮助你建立对这种常见硬件模型机理的扎实理解，并解释那些初看起来违反直觉的程序行为是如何产生的 [@problem_id:3656554]。", "problem": "一个双核系统实现了全局存储定序 (Total Store Order, TSO)。在TSO模型下，每个核心都有一个私有的先进先出 (FIFO) 存储缓冲区；一次存储操作会先进入本地缓冲区，然后才到达共享内存，并在按程序顺序从缓冲区排出时变得全局可见。当一个核心对地址 $a$ 进行加载操作时，如果该核心的存储缓冲区中存在对 $a$ 的写入，则会从中读取最近一次写入的值（存储到加载前向）；否则，它会从共享内存中读取当前值。程序中未使用显式内存屏障。\n\n两个共享变量 $x$ 和 $y$ 初始化为 $x=0$ 和 $y=0$。考虑以下双线程程序，其中 $W(v) \\leftarrow b$ 表示将值 $b$ 写入地址 $v$，$r \\leftarrow R(v)$ 表示从地址 $v$ 读取值到寄存器 $r$：\n\n- 线程 $P_0$：$W(x) \\leftarrow 1$；然后 $r_1 \\leftarrow R(y)$。\n- 线程 $P_1$：$W(y) \\leftarrow 1$；然后 $r_2 \\leftarrow R(x)$。\n\n仅使用上述TSO的基本操作规则（每个核心的FIFO存储缓冲区、对相同地址的存储到加载前向、以及加载操作可以不等待对不同地址的旧存储操作而直接读取内存），确定在程序结束时，TSO模型所允许的所有不同可观察结果对 $(r_1,r_2)$ 的集合 $S$ 的基数。\n\n将你的最终答案表示为给出 $|S|$ 的单个整数。无需四舍五入。", "solution": "该问题要求我们确定在全局存储定序 (TSO) 内存一致性模型下，寄存器对 $(r_1, r_2)$ 的所有可能结果集。我们将根据所提供的规则来分析执行过程。\n\n共享内存的初始状态为 $x=0$ 和 $y=0$。\n两个线程执行以下指令：\n- 线程 $P_0$：$W(x) \\leftarrow 1$；然后 $r_1 \\leftarrow R(y)$。\n- 线程 $P_1$：$W(y) \\leftarrow 1$；然后 $r_2 \\leftarrow R(x)$。\n\nTSO的操作规则如下：\n1.  一个核心的存储操作 $W(v) \\leftarrow b$ 首先被放入该核心的私有FIFO存储缓冲区。此时该存储对其他核心尚不可见。\n2.  该核心可以继续按程序顺序执行后续指令。\n3.  当存储操作从存储缓冲区头部出队并写入共享内存时，它变得全局可见。存储操作按FIFO顺序排出。\n4.  一个核心的加载操作 $r \\leftarrow R(v)$ 会首先检查其自身的存储缓冲区。如果存在对同一地址 $v$ 的存储，则将最近一次此类存储的值前向传递给寄存器 $r$（存储到加载前向）。\n5.  如果本地存储缓冲区中没有对地址 $v$ 的存储，则加载操作从共享内存中读取值。\n6.  关键在于，即使存储缓冲区中存在对 *不同* 地址的、更早的待处理存储，对地址 $v$ 的加载操作也可以执行。\n\n让我们分析 $(r_1, r_2)$ 的可能结果。寄存器只能保存值 $0$ 或 $1$。我们将研究四种可能的结果对——$(0,0)$, $(0,1)$, $(1,0)$ 和 $(1,1)$——是否都是允许的。在下文中，设 $SB_0$ 和 $SB_1$ 分别为 $P_0$ 和 $P_1$ 的存储缓冲区，并设 $Mem[v]$ 表示共享内存中变量 $v$ 的值。\n\n1.  **结果能否为 $(r_1, r_2) = (0, 1)$？**\n    可以。这种情况可能按以下顺序发生：\n    - $P_0$ 执行 $W(x) \\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$ 队列。$Mem[x]=0$, $Mem[y]=0$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。$SB_0$ 中包含对 $x$ 的存储，而非 $y$。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $0$。因此 $r_1=0$。\n    - 来自 $SB_0$ 的存储被排到内存。现在 $Mem[x]=1$。\n    - $P_1$ 执行 $W(y) \\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$ 队列。$Mem[y]$ 仍为 $0$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。$SB_1$ 中没有对 $x$ 的存储。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $1$。因此 $r_2=1$。\n    此执行轨迹产生结果 $(0, 1)$。\n\n2.  **结果能否为 $(r_1, r_2) = (1, 0)$？**\n    可以。这与前一种情况对称。\n    - $P_1$ 执行 $W(y) \\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$ 队列。$Mem[x]=0$, $Mem[y]=0$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。$SB_1$ 中没有对 $x$ 的存储。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $0$。因此 $r_2=0$。\n    - 来自 $SB_1$ 的存储被排到内存。现在 $Mem[y]=1$。\n    - $P_0$ 执行 $W(x) \\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$ 队列。$Mem[x]$ 仍为 $0$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。$SB_0$ 中没有对 $y$ 的存储。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $1$。因此 $r_1=1$。\n    此执行轨迹产生结果 $(1, 0)$。\n\n3.  **结果能否为 $(r_1, r_2) = (1, 1)$？**\n    可以。如果两个写入操作都在任一读取操作发生前变得全局可见，就可能发生这种情况。\n    - $P_0$ 执行 $W(x) \\leftarrow 1$。将 $(x,1)$ 放入 $SB_0$ 队列。\n    - $P_1$ 执行 $W(y) \\leftarrow 1$。将 $(y,1)$ 放入 $SB_1$ 队列。\n    - 来自 $SB_0$ 的存储被排到内存。$Mem[x]$ 变为 $1$。\n    - 来自 $SB_1$ 的存储被排到内存。$Mem[y]$ 变为 $1$。\n    - $P_0$ 执行 $r_1 \\leftarrow R(y)$。加载操作从内存中读取：$r_1 \\leftarrow Mem[y]$，其值为 $1$。因此 $r_1=1$。\n    - $P_1$ 执行 $r_2 \\leftarrow R(x)$。加载操作从内存中读取：$r_2 \\leftarrow Mem[x]$，其值为 $1$。因此 $r_2=1$。\n    此执行轨迹产生结果 $(1, 1)$。\n\n4.  **结果能否为 $(r_1, r_2) = (0, 0)$？**\n    可以。这是像TSO这样的宽松内存模型的特征性结果，而在顺序一致性模型下是不允许的。这是可能的，因为加载操作可以绕过（bypass）指向不同地址的、更早的存储操作。\n    - $P_0$ 执行 $W(x) \\leftarrow 1$。这将 $(x,1)$ 放入 $SB_0$ 队列。共享内存未变：$Mem[x]=0, Mem[y]=0$。\n    - $P_1$ 执行 $W(y) \\leftarrow 1$。这将 $(y,1)$ 放入 $SB_1$ 队列。共享内存仍未变：$Mem[x]=0, Mem[y]=0$。\n    - $P_0$ 继续执行其下一条指令 $r_1 \\leftarrow R(y)$。它的存储缓冲区 $SB_0$ 包含一个待处理的对 $x$ 的存储。由于加载操作是针对一个不同的地址（$y$），加载被允许绕过该存储并直接从共享内存读取。$r_1 \\leftarrow Mem[y]$，其值为 $0$。因此 $r_1=0$。\n    - $P_1$ 继续执行其下一条指令 $r_2 \\leftarrow R(x)$。它的存储缓冲区 $SB_1$ 包含一个待处理的对 $y$ 的存储。这个对 $x$ 的加载操作也被允许绕过该存储并从共享内存读取。$r_2 \\leftarrow Mem[x]$，其值为 $0$。因此 $r_2=0$。\n    - 稍后，来自 $SB_0$ 和 $SB_1$ 的存储将被排到内存，但寄存器 $r_1$ 和 $r_2$ 已经捕获了 $(0, 0)$ 的状态。\n    此执行轨迹产生结果 $(0, 0)$。\n\n在所描述的TSO模型下，$(r_1, r_2)$ 的所有四种可能值对都是允许的。可观察的不同结果对集合是 $S = \\{(0,0), (0,1), (1,0), (1,1)\\}$。\n该集合的基数是不同结果的总数。\n$$|S| = 4$$", "answer": "$$\\boxed{4}$$", "id": "3656554"}, {"introduction": "本章的最后一个练习将引导你从分析转向设计，像一名系统程序员一样思考。面对一个复杂的、由依赖关系构成的并发任务，你必须使用现代编程语言中常见的释放-获取（Release-Acquire）同步原语，来构建一个既正确又高效的解决方案。这个练习旨在展示如何在宽松内存模型的基础上，利用 happens-before 关系来设计和实现可靠的并发数据结构和算法 [@problem_id:3656597]。", "problem": "考虑一个在 Release–Acquire (RA) 内存模型下运行的共享内存程序。在 RA 模型中，当一个标注为 acquire 的加载操作在同一个原子变量上读取自一个标注为 release 的存储操作时，这个 release 存储会创建一个潜在的线程间顺序。先行发生 (happens-before, hb) 关系被定义为每个线程内部的程序顺序 (program order, po) 与由匹配的 release–acquire 对所引发的同步于 (synchronizes-with, sw) 边的传递闭包；宽松的加载和存储不产生线程间的 hb 关系。全局 hb 关系必须是无环的。\n\n给定一个有向有根依赖树，其节点为变量 $x_{1},\\dots,x_{10}$，其有向边编码了形式为“对父节点变量的写入应先行发生于对其子节点变量的首次读取”的期望。具体来说，该树的结构如下：\n- 根节点 $x_{1}$ 有子节点 $x_{2}$、$x_{3}$ 和 $x_{4}$。\n- 节点 $x_{2}$ 有子节点 $x_{5}$ 和 $x_{6}$。\n- 节点 $x_{3}$ 有子节点 $x_{7}$。\n- 节点 $x_{4}$ 有子节点 $x_{8}$、$x_{9}$ 和 $x_{10}$。\n\n每个变量 $x_{i}$ 由一个独立的线程 $T_{i}$ 所拥有。对于每条有向边 $x_{u} \\rightarrow x_{v}$，线程 $T_{u}$ 对 $x_{u}$ 执行一次写入，之后线程 $T_{v}$ 将对 $x_{v}$ 执行其首次读取。边 $x_{u} \\rightarrow x_{v}$ 上的期望是，在全局 hb 关系中，对 $x_{u}$ 的写入必须先行发生于对 $x_{v}$ 的首次读取。\n\n你只被允许以 RA 标注的形式放置“栅栏（fences）”：即在某个原子同步变量上的存储操作上标注 release，以及在其加载操作上标注 acquire。假设每个内部节点 $x_{u}$ 可以使用一个专用的原子标志 $f_{u}$ 与其所有子节点通信；子节点 $x_{v}$ 可以执行对 $f_{u}$ 的 acquire 加载，以观察到 $T_{u}$ 已完成其写入操作。在同一个标志上，一个被观察到的 release–acquire 对（即 acquire 操作读取自 release 操作）会引发一条从 $T_{u}$ 到 $T_{v}$ 的 synchronizes-with 边。任何不由 release–acquire 对支持的顺序要求必须仅由线程内的 po 满足，并且不产生线程间的 hb 关系。你可以选择哪些存储是 release 存储，哪些加载是 acquire 加载；每个 RA 标注（存储上的 release 或加载上的 acquire）计为一个栅栏。\n\n计算所需的此类栅栏的最小总数，以确保对于树中的所有边 $x_{u} \\rightarrow x_{v}$，预期的“对 $x_{u}$ 的写入先行发生于对 $x_{v}$ 的首次读取”顺序在全局 hb 关系中成立，并且全局 hb 关系保持无环。将你的答案表示为单个整数。无需四舍五入，也无需报告单位。", "solution": "该问题要求找到满足共享内存程序中一组顺序约束所需的“栅栏”（Release-Acquire 标注）的最小数量。这些约束源于一个涉及 10 个变量 $x_1, \\dots, x_{10}$ 的依赖树结构，每个变量分别由一个独立的线程 $T_1, \\dots, T_{10}$ 所拥有。\n\n核心要求是，对于给定树中的每条有向边 $x_u \\rightarrow x_v$，操作“对 $x_u$ 的写入”必须先行发生于“对 $x_v$ 的首次读取”。我们将线程 $T_u$ 对变量 $x_u$ 的写入操作表示为 $W(x_u)$，线程 $T_v$ 对变量 $x_v$ 的首次读取操作表示为 $R(x_v)$。要求是确保对于所有边 $x_u \\rightarrow x_v$ 都有 $W(x_u) \\text{ hb } R(x_v)$。\n\n先行发生关系 ($hb$) 定义为程序顺序 ($po$) 和同步于 ($sw$) 的传递闭包。\n一条 $sw$ 边在同一个原子变量上的 release 存储和 acquire 加载之间建立，其中加载操作读取由存储操作写入的值。由于 $W(x_u)$ 和 $R(x_v)$ 发生在不同的线程（$T_u$ 和 $T_v$）中，它们之间的 $hb$ 关系不能仅通过 $po$ 建立。它必须依赖于一个包含至少一条 $sw$ 边的关系链。\n\n让我们分析单个父子依赖关系 $x_u \\rightarrow x_v$ 的机制。为确保 $W(x_u) \\text{ hb } R(x_v)$，线程 $T_u$ 和 $T_v$ 可以使用一个专用的原子标志，如问题中所述的 $f_u$。\n操作顺序如下：\n1.  在线程 $T_u$ 中：写入操作 $W(x_u)$ 必须在对标志 $f_u$ 的 release 存储之前排序。设此存储为 $S(f_u)$。这给出了程序顺序关系 $W(x_u) \\text{ po } S(f_u)$。为了使其成为一个同步点，$S(f_u)$ 必须是一个 release 存储。这需要一个 `release` 标注，计为一个栅栏。\n2.  在线程 $T_v$ 中：从标志 $f_u$ 进行的 acquire 加载（我们称之为 $L(f_u)$）必须在读取操作 $R(x_v)$ 之前排序。这给出了程序顺序关系 $L(f_u) \\text{ po } R(x_v)$。为了同步，$L(f_u)$ 必须是一个 acquire 加载。这需要一个 `acquire` 标注，这是另一个栅栏。\n\n如果线程 $T_v$ 中的 acquire 加载 $L(f_u)$ 读取了线程 $T_u$ 中的 release 存储 $S(f_u)$ 写入的值，就会创建一条同步于边：$S(f_u) \\text{ sw } L(f_u)$。\n根据 $hb$ 关系的传递性，我们有：\n$$W(x_u) \\xrightarrow{po} S(f_u) \\xrightarrow{sw} L(f_u) \\xrightarrow{po} R(x_v)$$\n这个复合关系意味着 $W(x_u) \\text{ hb } R(x_v)$，满足了边 $x_u \\rightarrow x_v$ 的约束。这个针对一条边的最小方案需要一个 release 栅栏和一个 acquire 栅栏，总共 2 个栅栏。\n\n问题指出，一个内部节点 $x_u$ 可以使用单个标志 $f_u$ 与其*所有*子节点通信。让我们考虑一个有 $k$ 个子节点 $\\{x_{v_1}, x_{v_2}, \\dots, x_{v_k}\\}$ 的父节点 $x_u$。为了满足所有 $k$ 个依赖关系 $W(x_u) \\text{ hb } R(x_{v_i})$（对于 $i=1, \\dots, k$）：\n-   线程 $T_u$ 在其写入 $W(x_u)$ 之后，对其标志 $f_u$ 执行一次 `release` 存储。这消耗 1 个栅栏。\n-   每个子线程 $T_{v_i}$ 必须在其读取 $R(x_{v_i})$ 之前，对标志 $f_u$ 执行一次 `acquire` 加载。由于每个子节点都在一个独立的线程中，这需要 $k$ 个独立的 acquire 加载，每个子节点一个。这消耗 $k$ 个栅栏。\n满足一个拥有 $k$ 个子节点的父节点的所有依赖关系所需的栅栏总数为 $1+k$。这是最小数量，因为父节点的 release 是必需的，并且每个子节点必须独立执行 acquire 以与父节点建立同步。\n\n为了找到最小栅栏总数，我们可以根据每个节点在树中的角色，将所需栅栏数量相加。一个栅栏是对一个操作的标注。\n-   任何作为**父节点**（非叶节点）的节点都必须执行一次 `release` 存储来通知其子节点。这需要每个父节点一个 release 栅栏。\n-   任何作为**子节点**（非根节点）的节点都必须执行一次 `acquire` 加载来与其父节点同步。这需要每个子节点一个 acquire 栅栏。\n\n让我们从给定的树结构中识别出父节点和子节点：\n-   该树有节点 $x_1, \\dots, x_{10}$。\n-   $x_1$ 有子节点 $x_2, x_3, x_4$。\n-   $x_2$ 有子节点 $x_5, x_6$。\n-   $x_3$ 有子节点 $x_7$。\n-   $x_4$ 有子节点 $x_8, x_9, x_{10}$。\n\n**父节点**（非叶节点）的集合是 $P = \\{x_1, x_2, x_3, x_4\\}$。父节点的数量是 $|P| = 4$。这些节点中的每一个都对应一个必须执行一次 release 存储的线程。因此，release 栅栏的总数是 4。\n\n**子节点**（非根节点）的集合是 $C = \\{x_2, x_3, x_4, x_5, x_6, x_7, x_8, x_9, x_{10}\\}$。子节点的数量是 $|C| = 9$。这些节点中的每一个都对应一个必须执行一次 acquire 加载的线程。因此，acquire 栅栏的总数是 9。\n\n最小栅栏总数是所有必需的 release 和 acquire 栅栏的总和。\n总栅栏数 = (release 栅栏数) + (acquire 栅栏数) = $|P| + |C| = 4 + 9 = 13$。\n\n节点 $x_2, x_3, x_4$ 既是父节点也是子节点。例如，线程 $T_2$ 必须对标志 $f_1$ 执行一次 acquire 加载以与其父节点 $T_1$ 同步，并对其自己的标志 $f_2$ 执行一次 release 存储以通知其子节点 $T_5$ 和 $T_6$。这在线程 $T_2$ 内部需要两个栅栏。这与我们的计数方法一致。\n\n最后，问题要求全局 `hb` 关系是无环的。我们方案建立的线程间 `hb` 关系都遵循依赖树中边的方向（$T_{parent} \\rightarrow T_{child}$）。由于依赖结构是一棵树，它本身就是无环的。因此，线程间同步的图也是一个有向无环图，这保证了全局 `hb` 关系保持无环。\n\n所需的最小栅栏总数为 13。", "answer": "$$\\boxed{13}$$", "id": "3656597"}]}