{"hands_on_practices": [{"introduction": "虚假共享的根源在于一个简单的机制：内存地址如何映射到缓存行。这个练习将通过编写一个确定性程序，将这个抽象概念具体化。你将构建一个模型，仅根据内存布局来预测虚假共享何时发生，这有助于你直观地理解缓存行边界附近的“危险区域”，并为分析其性能影响打下基础。[@problem_id:3684583]", "problem": "您的任务是构建一个完全确定性的、自包含的程序，该程序从第一性原理出发，建模缓存行边界对一个简单的双线程写入模式的影响，并预测由伪共享引起的吞吐量周期性下降的模式。您的模型必须严格基于以下计算机组成和体系结构中的基本事实和定义：\n\n- 在一个由广泛实现的协议（如 Modified-Exclusive-Shared-Invalid (MESI) 协议）管理的一致性缓存层次结构中，内存以称为缓存行的固定大小块来维护。设缓存行大小为 $L$ 字节。\n- 一对 CPU 核心即使在修改不同的变量，当它们写入位于同一缓存行内的不同地址时，也会由于缓存一致性而导致重复的相互失效和状态转换。这种现象称为伪共享 (false sharing)。由此产生的一致性流量会降低吞吐量。\n- 内存地址根据整数除法和取模运算映射到缓存行，字节地址 $a$ 的行索引由 $\\left\\lfloor a / L \\right\\rfloor$ 给出。行内偏移量由 $a \\bmod L$ 给出。\n\n考虑以下抽象实验。有两个热点变量位于字节地址 $a_{0} = o$ 和 $a_{1} = o + d$ 处，其中 $o$ 是一个对齐偏移参数，您将在集合 $\\{0, 1, \\dots, B-1\\}$ 上对其进行扫描（对于某个窗口大小 $B$），而 $d$ 是一个固定的变量间字节距离。您不需要模拟时间；相反，您将对每个 $o$ 解析地确定这两个地址是否映射到同一个缓存行，并以此来建模吞吐量下降。\n\n您的程序必须为每个测试用例实现以下内容：\n\n1. 对于每个偏移量 $o \\in \\{0, 1, \\dots, B-1\\}$，确定两个地址 $a_{0} = o$ 和 $a_{1} = o + d$ 是否位于大小为 $L$ 的同一缓存行中。如果是，则在 $o$ 处声明一个预测的“伪共享下降”；否则，不预测有下降。\n2. 形成长度为 $B$ 的二进制序列 $f[o]$，其中 $f[o] = 1$ 表示预测有下降， $f[o] = 0$ 表示没有下降。\n3. 计算序列 $f$ 在长度为 $B$ 的观测窗口内的最小周期 $p_{\\min}$，其定义为满足以下条件的最小正整数 $p$：对于所有索引 $i$（其中 $0 \\le i + p \\le B - 1$），都有 $f[i] = f[i + p]$ 成立。\n4. 令 $c = \\sum_{o=0}^{B-1} f[o]$ 为窗口内预测的下降次数。定义一个归一化吞吐量模型为 $R(o) = R_{0} \\cdot (1 - \\alpha \\cdot f[o])$，其中基线 $R_{0} = 1$，惩罚因子 $\\alpha$ 按每个测试用例指定。计算窗口内的平均归一化吞吐量 $\\overline{R} = \\frac{1}{B} \\sum_{o=0}^{B-1} R(o)$。注意，在此模型下 $\\overline{R} = 1 - \\alpha \\cdot \\frac{c}{B}$。这是一个无单位的比率。\n5. 对于每个测试用例，输出三元组 $(p_{\\min}, c, \\overline{R})$。\n\n您必须使用以下测试套件，它涵盖了一般情况、边界条件和重要的边缘情况。每个元组 $(L, B, d, \\alpha)$ 中的 $L$、$B$、$d$ 以字节为单位，$ \\alpha $ 是一个无单位的惩罚因子：\n\n- 测试用例 1：$(L, B, d, \\alpha) = (64, 256, 16, 0.5)$。\n- 测试用例 2：$(L, B, d, \\alpha) = (64, 256, 0, 0.5)$。\n- 测试用例 3：$(L, B, d, \\alpha) = (64, 128, 63, 0.5)$。\n- 测试用例 4：$(L, B, d, \\alpha) = (64, 100, 90, 0.5)$。\n- 测试用例 5：$(L, B, d, \\alpha) = (64, 32, 16, 0.5)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，将所有测试用例的结果按顺序聚合，每个测试用例贡献其 $(p_{\\min}, c, \\overline{R})$ 三元组。整数 $p_{\\min}$ 和 $c$ 必须打印为整数，平均吞吐量 $\\overline{R}$ 必须打印为小数点后恰好有六位的小数。例如，输出格式必须完全是\n$[p_{\\min}^{(1)},c^{(1)},\\overline{R}^{(1)},p_{\\min}^{(2)},c^{(2)},\\overline{R}^{(2)},\\dots,p_{\\min}^{(5)},c^{(5)},\\overline{R}^{(5)}]$，\n除了分隔元素的逗号外，不含任何额外的文本或空白。", "solution": "该问题定义明确，并在计算机体系结构原理（特别是缓存组织和一致性）方面有坚实的科学基础。解决方案首先形式化伪共享的条件，然后为每个测试用例实现所需的计算。\n\n问题的核心在于确定两个内存地址 $a_0$ 和 $a_1$ 是否位于同一缓存行中。总大小为 $C$ 的缓存被组织成大小为 $L$ 的缓存行。一个字节地址 $a$ 被映射到索引为 $\\left\\lfloor a / L \\right\\rfloor$ 的唯一缓存行。因此，两个地址 $a_0$ 和 $a_1$ 在同一缓存行中的充要条件是它们映射到相同的行索引。\n\n1.  **伪共享的条件**：问题将两个地址定义为 $a_0 = o$ 和 $a_1 = o + d$，其中 $o$ 是一个偏移参数，$d$ 是一个固定距离。这两个地址位于大小为 $L$ 的同一缓存行中的条件是：\n    $$\n    \\left\\lfloor \\frac{a_0}{L} \\right\\rfloor = \\left\\lfloor \\frac{a_1}{L} \\right\\rfloor \\implies \\left\\lfloor \\frac{o}{L} \\right\\rfloor = \\left\\lfloor \\frac{o + d}{L} \\right\\rfloor\n    $$\n    这个等式是判断“伪共享下降”的决定因素。这个条件可以进一步分析。令 $d = q_d L + r_d$，其中 $q_d = \\lfloor d/L \\rfloor$ 是距离 $d$ 所跨越的完整缓存行数，$r_d = d \\pmod L$ 是余数。类似地，令 $o = q_o L + r_o$。该条件变为 $q_o = \\lfloor (q_o L + r_o + q_d L + r_d)/L \\rfloor = q_o + q_d + \\lfloor (r_o + r_d)/L \\rfloor$。这可以简化为 $q_d + \\lfloor (r_o + r_d)/L \\rfloor = 0$。由于当 $d \\ge 0$ 和 $o \\ge 0$ 时，两项都是非负的，因此这要求两项都为零。即，$q_d = \\lfloor d/L \\rfloor = 0$（意味着 $d  L$）并且 $\\lfloor (o \\pmod L + d \\pmod L)/L \\rfloor = 0$（意味着 $(o \\pmod L) + d  L$）。如果 $d \\ge L$，该条件永远不会满足。\n\n2.  **二进制序列和下降计数**：对于每个参数为 $(L, B, d, \\alpha)$ 的测试用例，我们为 $o \\in \\{0, 1, \\dots, B-1\\}$ 生成一个长度为 $B$ 的二进制序列 $f[o]$。\n    $$\n    f[o] = \\begin{cases} 1  \\text{ if } \\left\\lfloor o/L \\right\\rfloor = \\left\\lfloor (o+d)/L \\right\\rfloor \\\\ 0  \\text{ otherwise} \\end{cases}\n    $$\n    预测的总下降次数 $c$ 是此序列元素的总和：\n    $$\n    c = \\sum_{o=0}^{B-1} f[o]\n    $$\n\n3.  **最小周期计算**：序列 $f[o]$ 是周期性的，其基本周期与 $L$ 相关，因为条件 $\\left\\lfloor o/L \\right\\rfloor = \\left\\lfloor (o+d)/L \\right\\rfloor$ 取决于 $o \\pmod L$。长度为 $B$ 的有限序列 $f$ 的最小周期 $p_{\\min}$ 是满足 $f[i] = f[i+p]$（对于所有满足 $0 \\le i$ 和 $i+p \\le B-1$ 的整数 $i$）的最小正整数 $p$。为了找到 $p_{\\min}$，我们测试候选周期 $p=1, 2, \\dots, B-1$。第一个满足周期性条件的 $p$ 就是最小周期。\n\n4.  **平均吞吐量计算**：对于给定的偏移量 $o$，归一化吞吐量模型为 $R(o) = R_0 (1 - \\alpha \\cdot f[o])$。在基线 $R_0=1$ 的情况下，大小为 $B$ 的窗口上的平均吞吐量 $\\overline{R}$ 是：\n    $$\n    \\overline{R} = \\frac{1}{B} \\sum_{o=0}^{B-1} (1 - \\alpha \\cdot f[o]) = \\frac{1}{B} \\left( \\sum_{o=0}^{B-1} 1 - \\alpha \\sum_{o=0}^{B-1} f[o] \\right) = \\frac{1}{B} (B - \\alpha c) = 1 - \\alpha \\frac{c}{B}\n    $$\n    这提供了一个一旦知道总下降次数 $c$ 就可以计算 $\\overline{R}$ 的直接公式。\n\n实现了一个 C 程序来为每个指定的测试用例执行这些计算。它遍历每个偏移量 $o$ 以生成序列 $f$，计算总和 $c$，通过直接搜索找到最小周期 $p_{\\min}$，并计算 $\\overline{R}$。然后将所有测试用例的结果汇总并以指定格式打印。对地址和行索引使用整数算术确保了根据问题定义的正确性。对序列 $f$ 使用动态内存分配以确保稳健性。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3684583"}, {"introduction": "从理论上预测虚假共享之后，下一步是在真实硬件上检测它。现代CPU提供了性能计数器，可以揭示底层硬件事件的真相。这项练习要求你像性能工程师一样思考，设计一个对照实验，并识别由虚假共享引起的缓存行“乒乓效应”的特定“症状”（即性能计数器特征）。[@problem_id:3684650]", "problem": "考虑一个共享内存多处理器，它有 $k$ 个对称的中央处理器 (CPU) 核心，每个核心都有一个私有的一级 (L1) 写回式缓存和一个共享的末级缓存。该机器实现了修改-独占-共享-无效 (MESI) 缓存一致性协议。两个线程，表示为 $T_1$ 和 $T_2$，在不同的核心上并发运行。伪共享现象被定义为多个线程同时访问位于同一缓存行内的不同内存位置，从而在没有实际数据依赖的情况下导致一致性流量。\n\n基本原理：在监听 MESI 协议下，当一个核心对其缓存中当前不处于独占或修改状态的地址执行存储操作时，会触发一次请求所有权读取（Read For Ownership），即一级请求所有权读取（$\\mathrm{L1\\_RFO}$），以获得该缓存行的独占状态。如果另一个核心以修改状态持有该缓存行，该请求会观察到一个修改状态命中（$\\mathrm{HITM}$）响应，并且修改后的数据由对等核心提供。监听响应（$\\mathrm{SNOOP\\_RESP}$）计数器对一致性响应进行分类，例如失效、命中或修改状态命中事件。伪共享通常会导致缓存行在核心之间产生乒乓效应：频繁的失效、重复地转换到修改状态，以及相对于有效内存操作而言高频率的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 事件。\n\n你的任务是选择一种实验方法和预期的计数器特征，以使用性能计数器（包括 $\\mathrm{L1\\_RFO}$、$\\mathrm{HITM}$ 和 $\\mathrm{SNOOP\\_RESP}$）来最好地隔离和检测伪共享。该实验应该将伪共享场景与一个消除了伪共享的对照组进行对比。假设缓存行大小为 $L = 64$ 字节。假设工作负载执行 $N$ 次迭代，每次迭代中每个线程写入一个 $8$ 字节的字。\n\n哪个选项最能描述一个科学上合理的实验以及指示伪共享的预期计数器行为？\n\nA. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配一个数组 $A$，并为每次迭代 $i$ 分配 $T_1$ 更新 $A[i]$、$T_2$ 更新 $A[i+1]$，其中 $A$ 的布局使得 $A[i]$ 和 $A[i+1]$ 是大小为 $L = 64$ 的同一缓存行内不同的 $8$ 字节字。运行 $N$ 次迭代。然后运行一个填充版本，其中 $A[i]$ 和 $A[i+1]$ 被分离开，以便它们落在不同的缓存行上（例如，使用步幅或至少 $L$ 字节的显式填充）。预期伪共享运行将表现出每次存储操作的 $\\mathrm{L1\\_RFO}$ 大幅增加、许多与失效相关的 $\\mathrm{SNOOP\\_RESP}$ 事件，以及相对于填充对照组而言更高的 $\\mathrm{HITM}$ 响应。填充对照组应显示出每次存储操作的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 事件显著减少，以及较低的与失效相关的 $\\mathrm{SNOOP\\_RESP}$，且两次运行之间的末级缓存未命中率应相似。\n\nB. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配两个数组 $A$ 和 $B$，并对齐它们，使得由 $T_1$ 和 $T_2$ 更新的每个元素都位于不同的缓存行上。在两个线程中仅执行读取操作（无存储操作），共进行 $N$ 次迭代。预期在只读运行期间 $\\mathrm{HITM}$ 事件会激增，从而证明伪共享，并预期填充对照组会显示出更高的末级缓存 (LLC) 未命中率但更低的 $\\mathrm{L1\\_RFO}$。\n\nC. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。使用一个共享计数器，让两个线程执行 $N$ 次迭代的原子增量操作。预期 $\\mathrm{HITM}$ 和 $\\mathrm{L1\\_RFO}$ 会极高，并由此断定为伪共享。作为对照，将原子增量操作替换为对同一共享计数器的松散加载，并预期计数器值会急剧下降，从而验证升高的 $\\mathrm{HITM}$ 是由伪共享引起的。\n\nD. 将 $T_1$ 和 $T_2$ 绑定到同一物理核心上的同步多线程 (SMT)。在每个线程中使用映射到同一缓存行的两个局部变量。预期伪共享主要可以通过相对于填充对照组的末级缓存 (LLC) 未命中增加和 $\\mathrm{HITM}$ 减少来检测，因为 SMT 线程共享 L1 缓存，从而使一致性流量最小化。如果在未填充的运行中末级缓存未命中率上升，则断定为伪共享。\n\nE. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配一个共享数据结构，使得两个线程频繁地写入完全相同的 $8$ 字节字。预期在此运行中会有大量的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 计数，并断定这些计数器的升高证明了伪共享。使用一个对照组，其中每个线程写入同一缓存行内各自独立的字；预期 $\\mathrm{HITM}$ 和 $\\mathrm{L1\\_RFO}$ 几乎没有变化，从而确认仅在第一次运行中存在伪共享。\n\n选择唯一最佳选项。", "solution": "用户要求对问题陈述进行细致的验证，然后提供详细的解决方案和选项评估。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- **系统配置**：一个共享内存多处理器，拥有 $k$ 个对称的中央处理器 (CPU) 核心。\n- **缓存层次结构**：每个核心拥有一个私有的一级 (L1) 写回式缓存。一个末级缓存由所有核心共享。\n- **一致性协议**：该机器实现了修改-独占-共享-无效 (MESI) 协议。\n- **执行上下文**：两个线程 $T_1$ 和 $T_2$ 在不同的核心上并发运行。\n- **伪共享的定义**：“多个线程同时访问位于同一缓存行内的不同内存位置，从而在没有实际数据依赖的情况下导致一致性流量。”\n- **协议机制（基本原理）**：\n    - 对一个不处于独占或修改状态的地址执行的存储操作会触发一次请求所有权读取，具体来说是一级请求所有权读取（$\\mathrm{L1\\_RFO}$）。\n    - 如果另一个核心以修改状态持有该缓存行，该请求会观察到一个修改状态命中（$\\mathrm{HITM}$）响应，并且修改后的数据由对等核心提供。\n    - 一致性响应由监听响应（$\\mathrm{SNOOP\\_RESP}$）计数器进行分类。\n    - 伪共享的典型特征包括缓存行的“乒乓效应”、频繁的失效、重复转换到修改状态，以及相对于有效内存操作而言高频率的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$。\n- **实验参数**：\n    - 缓存行大小：$L = 64$ 字节。\n    - 工作负载：$N$ 次迭代，每次迭代中每个线程写入一个 $8$ 字节的字。\n- **任务**：确定用于隔离和检测伪共享的最佳实验方法及相应的性能计数器特征。\n\n**步骤2：使用提取的已知条件进行验证**\n根据既定标准对问题陈述进行评估：\n\n1.  **科学或事实合理性**：该问题在科学上是合理的。关于共享内存多处理器、MESI 协议、伪共享的定义，以及像 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 这类性能计数器行为的描述，都是计算机体系结构领域的标准和事实性概念。\n2.  **非形式化或不相关**：该问题与其陈述的主题（*缓存一致性问题和伪共享*）直接相关，并且完全可以形式化。\n3.  **设置不完整或矛盾**：设置是自洽且完整的。它提供了所有必要的定义、背景和参数（$L=64$ 字节，$8$ 字节的字，基于写的工作负载）来推理实验设计。没有内部矛盾。\n4.  **不切实际或不可行**：所描述的硬件架构和编程场景在现代多核系统中很常见。参数是现实的。伪共享现象是一个有据可查的、实际存在的性能问题。\n5.  **问题不适定或结构不良**：问题提得很好，要求从一组选项中选择*最佳*方法。术语在问题上下文中是精确且定义明确的。\n6.  **伪深刻、琐碎或同义反复**：问题并不琐碎。它需要对缓存一致性机制和实验设计有细致的理解，以便区分真共享、伪共享和无共享，并正确解释性能计数器数据。\n7.  **超出科学可验证性**：所提议的实验可以在带有性能监控单元（PMU）的实际硬件上或通过周期精确模拟器进行验证，这些都是计算机体系结构研究中的标准方法。\n\n**步骤3：结论与行动**\n问题陈述是**有效的**。它具有科学依据，问题提得很好，并为评估所提议的选项提供了清晰的基础。现在开始解决方案推导过程。\n\n### 解决方案推导\n\n任务的核心是设计一个能够隔离伪共享的实验。一个合理的科学实验需要一个测试用例和一个对照用例。\n- **测试用例（诱导伪共享）**：要制造伪共享，两个位于不同核心上的线程必须重复写入位于同一缓存行上的不同内存地址。\n- **对照用例（消除伪共享）**：要创建一个有效的对照组，实验应在所有方面（例如，写入次数、线程数、核心绑定）与测试用例相同，除了导致伪共享的特定条件。这通过确保线程访问的不同内存地址现在位于不同的缓存行上来实现。这通常通过数据结构填充来完成。\n\nMESI 协议决定了预期的特征：\n- **在伪共享期间**：假设核心 $C_1$ 上的线程 $T_1$ 写入地址 $x$，核心 $C_2$ 上的线程 $T_2$ 写入地址 $y$，其中 $x$ 和 $y$ 位于同一缓存行上。\n    1.  $T_1$ 写入 $x$。$C_1$ 发出 $\\mathrm{L1\\_RFO}$ 以获取该缓存行的**修改 (M)** 状态。\n    2.  $T_2$ 写入 $y$。$C_2$ 发出 $\\mathrm{L1\\_RFO}$。\n    3.  $C_1$ 的监听逻辑检测到对其持有的**M**状态缓存行的 $\\mathrm{L1\\_RFO}$。从 $C_2$ 的角度来看，这是一个 $\\mathrm{HITM}$ 事件。$C_1$ 必须提供数据并使其副本失效（转换为**无效 (I)** 状态）。\n    4.  $C_2$ 接收该缓存行，执行其写入操作，并以**M**状态持有该行。\n    5.  $T_1$ 再次写入 $x$。其副本是**I**状态。它发出另一个 $\\mathrm{L1\\_RFO}$。\n    6.  这会在 $C_2$ 上触发一个 $\\mathrm{HITM}$，$C_2$ 必须使其副本失效并将该行发送给 $C_1$。\n    这种缓存行的“乒乓效应”几乎为核心之间每一次交替写入都产生一个 $\\mathrm{L1\\_RFO}$ 和一个 $\\mathrm{HITM}$（以及一次失效）。这导致这些与一致性相关的事件计数极高。\n\n- **在对照用例期间（填充数据）**：\n    1.  $C_1$ 上的 $T_1$ 写入 $x$。$C_1$ 发出 $\\mathrm{L1\\_RFO}$ 并以**M**状态获取 $x$ 所在的缓存行。\n    2.  $C_2$ 上的 $T_2$ 写入 $y$。因为 $y$ 在不同的缓存行上，$C_2$ 为其自己的缓存行发出 $\\mathrm{L1\\_RFO}$ 并以**M**状态获取它。\n    3.  $T_1$ 后续对 $x$ 的写入将是 $C_1$ 上的 L1 缓存命中（因为其缓存行处于**M**状态）。$T_2$ 在 $C_2$ 上也是如此。不会再发生核心间的一致性流量。\n    因此，对照用例应该只表现出极少数的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 事件（来自最初的冷未命中），然后以低成本的 L1 写入继续进行。事件总数应远低于伪共享的情况。\n\n### 逐项分析\n\n**A. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配一个数组 $A$，并为每次迭代 $i$ 分配 $T_1$ 更新 $A[i]$、$T_2$ 更新 $A[i+1]$，其中 $A$ 的布局使得 $A[i]$ 和 $A[i+1]$ 是大小为 $L = 64$ 的同一缓存行内不同的 $8$ 字节字。运行 $N$ 次迭代。然后运行一个填充版本，其中 $A[i]$ 和 $A[i+1]$ 被分离开，以便它们落在不同的缓存行上（例如，使用步幅或至少 $L$ 字节的显式填充）。预期伪共享运行将表现出每次存储操作的 $\\mathrm{L1\\_RFO}$ 大幅增加、许多与失效相关的 $\\mathrm{SNOOP\\_RESP}$ 事件，以及相对于填充对照组而言更高的 $\\mathrm{HITM}$ 响应。填充对照组应显示出每次存储操作的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 事件显著减少，以及较低的与失效相关的 $\\mathrm{SNOOP\\_RESP}$，且两次运行之间的末级缓存未命中率应相似。**\n\n这个选项描述了一个方法论上完美的实验。\n- **测试用例**：让 $T_1$ 写入 $A[i]$ 而 $T_2$ 写入 $A[i+1]$，其中两者都是 64 字节缓存行内的 8 字节元素，这是伪共享的典型例子。例如，如果 $A[i]$ 在地址 `addr`，那么 $A[i+1]$ 就在 `addr+8`，两者都在一个 64 字节的边界内。\n- **对照用例**：使用填充将元素分隔到不同的缓存行上，正确地消除了伪共享的原因，同时保持了计算工作量相同。\n- **预期结果**：根据 MESI 协议分析，对伪共享运行中高 $\\mathrm{L1\\_RFO}$、$\\mathrm{HITM}$ 和失效事件的预测，以及对填充对照组中低计数的预测，是完全正确的。关于末级缓存未命中率应相似的观察也很敏锐，因为伪共享是私有缓存之间的一致性问题，通常不是共享 LLC 中的容量问题。\n**结论：正确。**\n\n**B. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配两个数组 $A$ 和 $B$，并对齐它们，使得由 $T_1$ 和 $T_2$ 更新的每个元素都位于不同的缓存行上。在两个线程中仅执行读取操作（无存储操作），共进行 $N$ 次迭代。预期在只读运行期间 $\\mathrm{HITM}$ 事件会激增，从而证明伪共享，并预期填充对照组会显示出更高的末级缓存 (LLC) 未命中率但更低的 $\\mathrm{L1\\_RFO}$。**\n\n这个选项存在根本性缺陷。\n- **实验**：它从位于不同缓存行上的数据开始，这是一种用于*避免*伪共享的设置。此外，它使用只读工作负载。伪共享及相关的高成本一致性流量（RFO、HITM）是由需要独占所有权的写入引起的。多个核心可以为读取操作而在**共享 (S)** 状态下持有同一缓存行，而不会发生冲突或失效。\n- **预期结果**：期望只读工作负载会产生“$\\mathrm{HITM}$ 事件激增”是不正确的。读取未命中会触发读取请求，而不是请求所有权读取（$\\mathrm{L1\\_RFO}$）。$\\mathrm{HITM}$ 事件专门响应于一个所有权请求（如 RFO）在别处发现缓存行处于修改状态。这两个条件都未满足。\n**结论：不正确。**\n\n**C. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。使用一个共享计数器，让两个线程执行 $N$ 次迭代的原子增量操作。预期 $\\mathrm{HITM}$ 和 $\\mathrm{L1\\_RFO}$ 会极高，并由此断定为伪共享。作为对照，将原子增量操作替换为对同一共享计数器的松散加载，并预期计数器值会急剧下降，从而验证升高的 $\\mathrm{HITM}$ 是由伪共享引起的。**\n\n这个选项误判了现象。\n- **实验**：让两个线程更新*完全相同*的内存位置（一个共享计数器）是**真共享**或高争用的例子，而不是伪共享。虽然性能特征（高 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$）相似，但根本原因不同——线程之间存在合法的数据依赖。伪共享的定义要求访问*不同*的内存位置。\n- **对照组**：提议的对照组（松散加载）是无效的，因为它将程序的根本操作从一个正确的并行计数器改变为一个更新会丢失的错误程序。对照组必须执行相同的逻辑工作。\n**结论：不正确。**\n\n**D. 将 $T_1$ 和 $T_2$ 绑定到同一物理核心上的同步多线程 (SMT)。在每个线程中使用映射到同一缓存行的两个局部变量。预期伪共享主要可以通过相对于填充对照组的末级缓存 (LLC) 未命中增加和 $\\mathrm{HITM}$ 减少来检测，因为 SMT 线程共享 L1 缓存，从而使一致性流量最小化。如果在未填充的运行中末级缓存未命中率上升，则断定为伪共享。**\n\n这个选项误解了 SMT 的硬件背景。\n- **实验**：同一物理核心上的 SMT 线程通常共享 L1 数据缓存。如果两个变量位于同一缓存行上，并且同一核心上的两个 SMT 线程访问它们，数据交换发生在共享的 L1 缓存内。这不会触发核心间的 MESI 一致性协议。因此，核心之间不会有相关的 $\\mathrm{L1\\_RFO}$ 或 $\\mathrm{HITM}$。在单个核心上使用 SMT 在很大程度上*避免*了伪共享问题。\n- **预期结果**：通过 LLC 未命中来检测的预测是错误的，而关于一致性流量最小化的陈述是正确的，但这恰恰说明了这是一个错误的设置，无法用来检测核心间的伪共享。\n**结论：不正确。**\n\n**E. 将 $T_1$ 和 $T_2$ 绑定到不同的核心。分配一个共享数据结构，使得两个线程频繁地写入完全相同的 $8$ 字节字。预期在此运行中会有大量的 $\\mathrm{L1\\_RFO}$ 和 $\\mathrm{HITM}$ 计数，并断定这些计数器的升高证明了伪共享。使用一个对照组，其中每个线程写入同一缓存行内各自独立的字；预期 $\\mathrm{HITM}$ 和 $\\mathrm{L1\\_RFO}$ 几乎没有变化，从而确认仅在第一次运行中存在伪共享。**\n\n这个选项是错误的，并且颠倒了概念。\n- **实验**：初始运行（写入相同的字）描述的是**真共享**。该选项错误地将其标记为演示伪共享的方式。\n- **对照组**：“对照”用例（写入同一缓存行内的独立字）是**伪共享**的典型定义。\n- **预期结果**：对对照组的预测是灾难性错误的。它预期伪共享场景中“$\\mathrm{HITM}$ 和 $\\mathrm{L1\\_RFO}$ 几乎没有变化”。正如已经确立的，伪共享场景恰恰是导致乒乓效应和这些计数器急剧飙升的原因。这个选项显示了对该主题的完全误解。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3684650"}, {"introduction": "既然我们能够预测和检测虚假共享，最后一步就是解决它。填充（Padding）是消除虚假共享最直接的策略。本练习不仅是关于应用一个修复方法，更是关于寻求一个最优解：你将需要推导出精确的填充量，以在保证消除虚假共享的同时，最大限度地减少内存浪费。[@problem_id:3684636]", "problem": "考虑一个共享内存多处理器，其拥有私有缓存和一个以缓存行粒度运行的、基于总线的缓存一致性协议。每个缓存行的大小为 $B$ 字节，一致性操作（如失效或更新）作用于整个缓存行。当两个线程写入位于同一缓存行内的不同内存位置时，就会产生伪共享，即使这两个线程在语义层面上并未真正共享数据，这也会触发一致性流量。为了消除一个元素数组的伪共享，只需确保任意两个不同的元素永远不会位于同一个缓存行中。\n\n假设一个数组由连续的元素组成，每个元素是一个大小为 $s$ 字节的结构体。为防止伪共享，我们为每个元素附加 $p$ 字节的填充，使得连续元素起始地址之间的步幅 $t$ 为 $t = s + p$。假设分配器返回的基地址与缓存行大小对齐，即基地址是 $B$ 的倍数。目标是选择最小的填充 $p$，使得对于任何缓存行大小 $B$，任意两个不同的元素都不会共享任何缓存行。\n\n从“缓存一致性以缓存行粒度运行”以及“与 $B$ 的倍数对齐可将元素起始地址置于缓存行边界上”这两个基本定义出发，推导出一个关于最小填充 $p$ 的闭式表达式（用 $s$ 和 $B$ 表示），该表达式保证任意两个不同元素不共享任何缓存行。然后计算由 $\\rho = (s + p)/s$ 定义的内存开销比 $\\rho$。\n\n将您的最终结果表示为关于 $s$ 和 $B$ 的闭式解析表达式。不需要数值近似或四舍五入。", "solution": "问题要求推导为防止元素数组产生伪共享所需的最小填充 $p$ 的闭式表达式，以及相应的内存开销比 $\\rho$。大小为 $s$ 字节的元素需要被填充，使得连续元素之间的步幅 $t$ 变为 $t = s + p$。缓存行大小为 $B$ 字节，且数组的基地址与 $B$ 的倍数对齐。消除伪共享的条件是任意两个不同的元素不共享任何缓存行。\n\n设数组的基地址为 $A_{base}$。问题陈述 $A_{base}$ 是 $B$ 的倍数，因此 $A_{base} = k_0 B$（对于某个整数 $k_0$）。我们可以使用相对于 $A_{base}$ 的地址来分析内存布局，这相当于在不失一般性的前提下将数组的起始地址设为 $0$。\n\n一个大小为 $s$ 的元素被填充 $p$ 字节，导致连续元素起始地址之间的总占用空间或步幅为 $t = s+p$ 字节。第 $i$ 个元素（0-索引）的起始地址由 $a_i = i \\cdot t$ 给出。第 $i$ 个元素本身（不包括填充）占用的内存是字节范围 $[a_i, a_i + s - 1]$。\n\n缓存一致性作用于大小为 $B$ 的缓存行。一个内存地址 $x$ 位于覆盖地址范围 $[B \\cdot \\lfloor x/B \\rfloor, B \\cdot \\lfloor x/B \\rfloor + B - 1]$ 的缓存行中。\n\n任意两个不同元素不共享一个缓存行的条件必须对所有元素对都成立。为任意两个连续元素（例如元素 $i$ 和元素 $i+1$）强制执行此条件就足够了。如果这对所有 $i$ 都成立，那么通过传递性，它对任意两个不同元素都成立。\n\n保证每个元素位于与其他所有元素不相交的缓存行集合中的最稳健和直接的方法是，确保每个元素都从一个缓存行边界开始。由于数组的基地址已经在缓存行边界上，这可以通过使步幅 $t$ 成为缓存行大小 $B$ 的倍数来实现。\n\n让我们将步幅 $t$ 设置为 $B$ 的整数倍，即 $t = mB$（对于某个正整数 $m$）。元素 $i$ 的起始地址是 $a_i = i \\cdot t = i \\cdot mB$。由于 $i$ 和 $m$ 是整数，$a_i$ 始终是 $B$ 的倍数。因此，每个元素都恰好从一个缓存行的起始处开始。\n\n现在我们必须确保元素 $i$ 的数据不会延伸到元素 $i+1$ 开始的缓存行中。\n元素 $i$ 占据地址范围 $[a_i, a_i + s - 1]$。元素 $i+1$ 从地址 $a_{i+1} = a_i + t$ 开始。元素 $i$ 的最后一个字节的地址必须严格小于元素 $i+1$ 的起始地址。这一点由构造保证，因为 $a_i + s - 1  a_i + s \\le a_i + t = a_{i+1}$ (由于 $p \\ge 0$) 。\n\n关键条件是元素 $i$ 占用的缓存行不与元素 $i+1$ 的缓存行重叠。\n要保证任意两个不同的元素不共享任何缓存行，最简单的方法是确保每个元素都包含在自己的、不与其他元素重叠的一组缓存行中。鉴于数组基地址已对齐，最直接的策略是使每个填充后元素的大小，即步幅 $t=s+p$，成为缓存行大小 $B$ 的整数倍。\n具体来说，我们需要找到最小的步幅 $t$，使得 $t \\ge s$ 且 $t$ 是 $B$ 的倍数。\n这相当于将 $s$ 向上舍入到 $B$ 的下一个倍数。\n这个值可以用天花板函数（ceiling function）来表示。我们需要的最小步幅 $t_{min}$ 是：\n$$t_{min} = B \\cdot \\left\\lceil \\frac{s}{B} \\right\\rceil$$\n这个步幅也必须至少是元素本身的大小，即 $t_{min} \\ge s$。由于 $\\lceil s/B \\rceil \\ge s/B$，两边乘以 $B$ 得到 $B \\cdot \\lceil s/B \\rceil \\ge s$。所以，$t_{min} \\ge s$ 总是满足的。\n\n所需的最小填充 $p$ 是这个最小步幅与元素大小 $s$ 之间的差：\n$$p = t_{min} - s = B \\cdot \\left\\lceil \\frac{s}{B} \\right\\rceil - s$$\n\n问题的第二部分是计算内存开销比 $\\rho$，定义为 $\\rho = (s+p)/s$。代入 $s+p = t_{min}$：\n$$\\rho = \\frac{t_{min}}{s} = \\frac{B \\cdot \\lceil s/B \\rceil}{s}$$\n\n推导出的 $p$ 和 $\\rho$ 的表达式是用 $s$ 和 $B$ 表示的，并且是所要求的闭式形式。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nB \\left\\lceil \\frac{s}{B} \\right\\rceil - s,  \\frac{B \\left\\lceil \\frac{s}{B} \\right\\rceil}{s}\n\\end{pmatrix}\n}\n$$", "id": "3684636"}]}