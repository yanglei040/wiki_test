{"hands_on_practices": [{"introduction": "本练习将带你深入协议机制的核心。我们将分析一个经典的双核“乒乓”写模式，在这种模式下，两个核心交替写入同一缓存行。通过为 MESI 和 MOESI 协议细致地追踪状态转换和消息传递 [@problem_id:3635489]，你将具体理解所有权是如何转移的，并发现 MOESI 协议中高级的“Owned”状态在何种特定条件下才能（或不能）带来性能优势。", "problem": "考虑一个基于目录的缓存一致性系统，该系统带有一个中心化目录，为每个缓存行维护一个共享者向量以及（如果适用）一个单一的所有者标识符。互连是可靠且有序的，目录通过向节点发送消息并接收相应的确认或数据来发布一致性操作。我们考虑两种协议：修改-独占-共享-无效 (MESI) 和修改-持有-独占-共享-无效 (MOESI)，其中 MOESI 协议增加了“持有”(Owned) 状态，以允许脏行在不写回内存的情况下被提供给共享者。假设有两个核心，表示为 $C_0$ 和 $C_1$，从冷状态（即缓存行 $x$ 未被任何核心缓存，且目录将其标记为未缓存）开始，以背靠背的方式交替地对同一个缓存行 $x$ 执行写操作。具体来说，总共有 $10$ 次写操作：$C_0$ 写入，然后 $C_1$ 写入，这个过程重复进行，直到每个核心都写入了 $5$ 次。\n\n将一次“往返”视为由目录向任一节点（即内存控制器或核心）发起的一个请求-响应对。因此，一次往返包含一条从目录到节点的一致性操作消息，以及完成该操作所需的从节点到目录的相应确认或数据消息。只计算由目录发起的往返；不计算核心到目录的请求、目录到核心的数据响应或任何本地缓存命中处理。忽略容量驱逐，并假设所有必要的缓存间传输都由目录协调，除非在冷未命中时从内存获取数据，否则不涉及内存控制器。\n\n使用 MESI 和 MOESI 协议的基本定义以及基于目录的所有权转移语义，分析完整的 $10$ 次背靠背写操作序列，并计算在 MESI 协议下（表示为 $R_{\\text{MESI}}$）和 MOESI 协议下（表示为 $R_{\\text{MOESI}}$）目录发起的总往返次数。然后，通过评估相对改进 $$I \\equiv \\frac{R_{\\text{MESI}} - R_{\\text{MOESI}}}{R_{\\text{MESI}}}$$ 来量化“持有”状态是否能减少写乒乓效应。将 $I$ 报告为单个实数，无需四舍五入。假设系统具有以下属性：对于处于“修改”或“持有”状态的缓存行，目录通过向当前所有者发送转发/无效化请求来进行所有者干预，所有者直接用所需的确认或数据响应目录，并且共享者无效化（如有）在完成前需要向目录发送确认。在此工作负载中，除了 $C_0$ 和 $C_1$ 之外，没有并发的第三方共享者。", "solution": "该问题要求在基于目录的缓存一致性系统上分析一个特定的工作负载，以比较 MESI 和 MOESI 协议的性能。性能指标是在两个核心 $C_0$ 和 $C_1$ 对同一缓存行 $x$ 进行 $10$ 次交替写操作的序列中，由目录发起的总往返次数 $R$。然后必须计算 MOESI 相对于 MESI 的相对改进 $I$。\n\n首先，我们必须根据问题陈述精确定义何为一次“往返”。一次往返是由目录向另一个节点（核心或内存控制器）发起的一个请求-响应对。具体来说，它是一条从目录到节点的消息，以及随后的从节点到目录的相应确认或数据消息。核心到目录的请求和目录到核心的纯数据响应被明确排除在计数之外。\n\n该工作负载包含对单个缓存行 $x$ 的总共 $10$ 次写操作。序列是：$C_0$ 写入，$C_1$ 写入，$C_0$ 写入，等等，每个核心共写入 $5$ 次。初始时，该行未被任何核心缓存（两个核心都将其保持在无效 (I) 状态），并且目录将其标记为未缓存 (Uncached)。\n\n让我们首先分析 MESI 协议下的序列以确定 $R_{\\text{MESI}}$。\n\n**MESI 协议分析**\n\n*   **写操作 1 ($C_0$ 写入 $x$):**\n    1.  $C_0$ 中该缓存行处于 I 状态，导致写未命中。它向目录发送一个获取独占 (GetX) 请求。这不计入次数。\n    2.  目录收到 GetX 请求。它看到该行为未缓存 (Uncached) 状态。为服务此未命中，目录必须从主存中获取数据。\n    3.  目录向内存控制器发送一个“获取数据”请求。内存控制器响应并返回数据块。这构成一次由目录发起的请求和相应的响应，因此计为 $1$ 次往返。\n    4.  目录更新其内部状态，将 $C_0$ 标记为修改 (M) 状态的所有者。然后它将数据发送给 $C_0$（不计入次数）。\n    5.  $C_0$ 接收数据，将该行缓存为 M 状态，并执行写操作。\n    *   此步骤的往返次数: $1$。\n    *   写操作 1 之后的状态: 目录=(M, Owner=$C_0$, Sharers={}), $C_0$=(M), $C_1$=(I)。\n\n*   **写操作 2 ($C_1$ 写入 $x$):**\n    1.  $C_1$ 中该缓存行处于 I 状态，导致写未命中。它向目录发送一个 GetX 请求（不计入次数）。\n    2.  目录收到 GetX 请求。它看到该行处于 M 状态，所有者是 $C_0$。为了授予 $C_1$ 独占访问权，目录必须从 $C_0$ 检索最新数据并使 $C_0$ 的副本无效。\n    3.  目录向当前所有者 $C_0$ 发送一个“转发/无效化”请求。$C_0$ 收到此请求，使其副本无效（从 M 转换到 I），并将数据块发送回目录。这个由目录发起的请求-响应对计为 $1$ 次往返。\n    4.  目录从 $C_0$ 接收数据，更新其状态以将 $C_1$ 标记为新的 M 状态所有者，并将数据转发给 $C_1$（不计入次数）。\n    5.  $C_1$ 将该行缓存为 M 状态并执行写操作。\n    *   此步骤的往返次数: $1$。\n    *   写操作 2 之后的状态: 目录=(M, Owner=$C_1$, Sharers={}), $C_0$=(I), $C_1$=(M)。\n\n*   **后续写操作 (3 到 10):**\n    在写操作 2 中建立的模式在随后的每次写操作中都会重复。每次写操作都来自当前不拥有该行的核心。该核心中该行将处于 I 状态，从而导致写未命中。目录将识别另一个核心为 M 状态的所有者，并向该所有者发起一次“转发/无效化”往返，以检索数据并强制实现独占性。例如，对于写操作 3，$C_0$ 发送 GetX，目录向 $C_1$ 发送“转发/无效化”请求，$C_1$ 响应目录。这花费 $1$ 次往返。这种“乒乓”行为在所有剩余的写操作中持续存在。\n\n*   **MESI 的总往返次数 ($R_{\\text{MESI}}$):**\n    有 $1$ 次写操作是冷未命中，还有 $10-1 = 9$ 次写操作导致两个核心之间的所有权转移。\n    $$R_{\\text{MESI}} = \\underbrace{1}_{\\text{写操作 1}} + \\underbrace{9 \\times 1}_{\\text{写操作 2-10}} = 10$$\n    在 MESI 协议下，目录发起的总往返次数为 $R_{\\text{MESI}} = 10$。\n\n现在，我们分析 MOESI 协议下的序列以确定 $R_{\\text{MOESI}}$。\n\n**MOESI 协议分析**\n\nMOESI 协议增加了持有 (O) 状态。O 状态是一种*共享脏*状态，它允许一个核心持有一个缓存行的修改副本，同时其他核心持有只读（共享，S）副本。这对于具有脏数据读共享的工作负载是有益的，因为它允许所有者向其他读取者提供数据，而无需先将其写回内存。\n\n然而，指定的工作负载完全由写操作组成。核心的写操作需要对缓存行的独占所有权。为获得此权限，核心发送一个获取独占 (GetX) 请求。在收到 GetX 请求后，目录的主要职责是确保没有其他核心保留该行的副本，从而将独占权授予请求者。\n\n让我们检查在 MOESI 下给定工作负载的状态转换：\n*   **写操作 1 ($C_0$ 写入 $x$):** 行为与 MESI 相同。一次冷未命中由内存服务。$C_0$ 以 M 状态获得该行。这花费 $1$ 次往返 (目录 $\\leftrightarrow$ 内存)。\n*   **写操作 2 ($C_1$ 写入 $x$):** $C_1$ 发送一个 GetX 请求。目录看到 $C_0$ 以 M 状态拥有该行。为满足 GetX 请求，目录必须使 $C_0$ 的副本无效。此处不适用 M $\\rightarrow$ O 的转换，因为那将意味着共享，这与 $C_1$ 的写操作所需的独占访问权相悖。因此，目录向 $C_0$ 发送一个转发/无效化请求，$C_0$ 用数据响应并将自己的状态从 M 转换为 I。这与 MESI 的情况完全相同，花费 $1$ 次往返。\n*   **后续写操作 (3 到 10):** 同样的逻辑适用。每次写操作都是来自一个没有有效副本的核心的 GetX 请求。目录必须使当前的 M 状态所有者无效以转移独占所有权。永远不会进入“持有”状态，因为从来没有对脏行的获取共享 (GetS) 请求来触发 M $\\rightarrow$ O 的转换。\n\n对于这种特定的纯写、乒乓式工作负载，MOESI 下的操作和消息序列与 MESI 下的完全相同。\n\n*   **MOESI 的总往返次数 ($R_{\\text{MOESI}}$):**\n    计算与 MESI 的情况完全相同。\n    $$R_{\\text{MOESI}} = \\underbrace{1}_{\\text{写操作 1}} + \\underbrace{9 \\times 1}_{\\text{写操作 2-10}} = 10$$\n    在 MOESI 协议下，目录发起的总往返次数为 $R_{\\text{MOESI}} = 10$。\n\n最后，我们计算相对改进 $I$。\n\n**相对改进 ($I$) 的计算**\n\n相对改进定义为：\n$$I = \\frac{R_{\\text{MESI}} - R_{\\text{MOESI}}}{R_{\\text{MESI}}}$$\n代入计算出的值：\n$$I = \\frac{10 - 10}{10} = \\frac{0}{10} = 0$$\n结果 $I=0$ 表明，对于这种背靠背写操作的特定工作负载，就目录发起的往返次数而言，MOESI 协议相对于 MESI 协议没有任何改进。“持有”状态是 MOESI 的关键特性，但它没有被一个不涉及脏数据读共享的工作负载所利用。", "answer": "$$\\boxed{0}$$", "id": "3635489"}, {"introduction": "一致性协议并非在真空中运行；它们与内存层次结构的其他部分（如私有 L1 缓存）相互作用。本练习探讨一个常见的生产者-消费者工作负载，以量化 L1 写策略（写回 vs. 写通）如何影响目录流量。通过这项练习 [@problem_id:3635552]，你将看到一个局部的设计选择如何对整个系统性能产生重大的影响。", "problem": "一个计算机系统实现了一个集中式、基于目录的缓存一致性协议，其状态（修改-独占-共享-无效，MESI）在一个共享的末级缓存中进行跟踪，该缓存也容纳了目录。考虑一个在共享内存中作为环形缓冲区实现的单生产者/单消费者队列。生产者核心每个队列槽位写入一个标量值，消费者核心按程序顺序精确地读取每个产生的值一次。将行复用率 $u$ 定义为：在消费者首次读取某个缓存行之前，生产者映射并写入到该同一缓存行中的连续项目（产生的值）的期望数量；假设 $u \\ge 1$ 且 $u$ 可被视为一个表示平均值的实值参数。假设以下微架构和协议条件，这些条件都是标准且科学上现实的：\n\n- 目录是包容性的，并与末级缓存位于同一位置。除非某个私有缓存以“修改”（Modified）状态持有该行，否则末级缓存向请求者提供数据。\n- 生产者和消费者核心是唯一接触队列行的缓存。没有其他共享者。\n- 消费者完成读取一个缓存行后，两个缓存都可以以“共享”（Shared）状态保留该行。在生产者再次写入该行之前，它以“共享”状态持有该行，并且必须升级到“修改”（Modified）状态。在所考虑的时间间隔内，没有因容量不足而发生的驱逐，也没有预取。\n- 消费者对生产者刚刚更新的行的首次读取，会在消费者的私有缓存中导致一次读未命中（read miss）。消费者后续对同一行的读取将在本地命中，不产生一致性流量。\n- 只计算在私有缓存和目录之间，或目录和私有缓存之间传输的点对点一致性消息。末级缓存内部的内存阵列访问不单独计数。每个不同的一致性或数据消息都精确地计为 1 条消息。\n\n在保持目录协议不变的情况下，私有的一级缓存可以配置为以下两种策略之一：\n\n- 写回策略 (WB)：对处于“修改”状态的行的存储操作，在一致性协议要求降级或写回之前，不会将数据发送到目录。\n- 写通策略 (WT)：对处于“修改”状态的行的存储操作，会立即将更新后的数据发送到目录/末级缓存。假设采用写分配（write-allocate），并且每次存储操作都恰好向目录产生 1 条写通数据消息。\n\n在这些假设下，对于单个缓存行的生产者-消费者“交接”周期（生产者写入该行，然后消费者读取一次），会发生以下一致性操作：\n\n- 在新周期中，生产者在对该行进行首次存储之前，从“共享”升级到“修改”状态：生产者向目录发送恰好 $1$ 条升级请求，目录向消费者发送恰好 $1$ 条作废（invalidate）消息，消费者向目录发送恰好 $1$ 条确认（acknowledgment）消息。由于生产者已持有有效的“共享”副本，升级时没有数据发送给生产者。\n- 消费者在该周期内对该行的首次读未命中：\n  - 在 WB 策略下：消费者向目录发送恰好 $1$ 条读取请求；由于生产者以“修改”状态持有最新数据，目录向生产者发送恰好 $1$ 条召回（recall）消息，从生产者接收恰好 $1$ 条写回数据消息，然后向消费者发送恰好 $1$ 条数据响应，这同时也将生产者的状态降级为“共享”。\n  - 在 WT 策略下：消费者向目录发送恰好 $1$ 条读取请求；由于写通机制，末级缓存已持有最新数据，因此目录向消费者发送恰好 $1$ 条数据响应，并同时向生产者发送恰好 $1$ 条降级消息，生产者回复恰好 $1$ 条确认消息。\n\n设计一个微基准测试，包含此类交接周期的长时间稳态运行，并根据第一性原理和上述定义，推导出一个封闭形式的表达式，用于计算在写回和写通两种策略下，每个生产出的项目所对应的目录可见消息的期望总数，该表达式是行复用率 $u$ 的函数。您的推导必须：\n\n- 从 MESI 状态的定义、目录介导的状态转换以及上述规定的消息序列开始。\n- 考虑到消费者在首次未命中后对同一行的后续读取不产生一致性消息。\n- 在 WT 策略下，考虑到生产者的 $u$ 次行内存储每次都会向目录产生一条写通数据消息，而在 WB 策略下，稳态时没有每次存储都发消息的情况。\n\n将您的最终结果以单行矩阵的形式报告，其第一个条目是在写回策略下每个项目的期望消息数，第二个条目是在写通策略下每个项目的期望消息数。不需要进行数值四舍五入，最终结果应为关于 $u$ 的精确解析表达式。", "solution": "目标是为一个单生产者/单消费者队列推导出每个生产出的项目所对应的目录可见消息的期望数量的封闭形式表达式。该推导将针对两种私有缓存策略进行：写回（WB）和写通（WT）。分析基于单个缓存行的稳态交接周期，该周期对应于 $u$ 个项目的生产，其中 $u$ 是行复用率。\n\n问题将一个交接周期定义为从生产者准备写入共享缓存行开始，写入 $u$ 个项目，然后消费者相继读取这 $u$ 个项目的一系列事件。我们将计算这样一个周期的总一致性消息数，然后除以 $u$ 来得到每个项目的平均消息数。\n\n让我们按照问题陈述中的描述，将周期分解为不同阶段进行分析。一个周期开始时，生产者和消费者的缓存都从前一个周期继承，以“共享”（Shared, S）状态持有该行。\n\n阶段1：生产者升级\n为了写入缓存行，生产者必须首先通过将其状态从“共享”（S）升级到“修改”（M）来获得独占所有权。根据问题描述，此操作需要：\n- 1 条从生产者到目录的升级请求消息。\n- 1 条从目录到消费者缓存的作废消息。\n- 1 条从消费者到目录的确认消息。\n升级阶段的总消息数 $N_{upg}$ 对两种策略都是恒定的：\n$$N_{upg} = 1 + 1 + 1 = 3$$\n\n阶段2：生产者存储\n获得“修改”状态后，生产者将 $u$ 个不同的标量值写入缓存行。这些存储操作的消息成本取决于缓存策略。\n\n阶段3：消费者读取\n消费者读取生产出的 $u$ 个项目。由于其副本在阶段1中被作废，消费者对更新后的行的首次读取将导致读未命中。对同一行中其他 $u-1$ 个项目的后续读取将是本地命中，并且如前所述，不产生一致性流量。我们只需要计算由初始读未命中产生的消息。\n\n现在，我们来为每种策略计算每个周期和每个项目的总消息数。\n\n**写回（WB）策略**\n\n在 WB 策略中，对处于“修改”状态的行的存储操作在生产者的私有缓存中本地处理，不产生网络流量。\n- 阶段2（生产者存储）：$u$ 次存储不产生任何消息。\n$$N_{stores, WB} = 0$$\n- 阶段3（消费者的首次读取）：处理消费者的读未命中。问题指明了 WB 的序列：目录必须从生产者那里召回数据，因为生产者以“修改”状态持有唯一最新的副本。\n  - 1 条从消费者到目录的读取请求。\n  - 1 条从目录到生产者的召回消息。\n  - 1 条从生产者到目录的写回数据消息。\n  - 1 条从目录到消费者的数据响应消息。\n在 WB 策略下，消费者读未命中产生的总消息数为：\n$$N_{read, WB} = 1 + 1 + 1 + 1 = 4$$\n\n一个完整交接周期的总消息数 ($N_{cycle, WB}$) 是所有阶段消息数的总和：\n$$N_{cycle, WB} = N_{upg} + N_{stores, WB} + N_{read, WB} = 3 + 0 + 4 = 7$$\n这个周期对应于 $u$ 个项目的生产。每个项目的期望消息数 $M_{item, WB}$ 是每个周期的总消息数除以 $u$：\n$$M_{item, WB} = \\frac{N_{cycle, WB}}{u} = \\frac{7}{u}$$\n\n**写通（WT）策略**\n\n在 WT 策略中，每次对处于“修改”状态的行的存储操作也会将数据发送到目录。\n- 阶段2（生产者存储）：$u$ 次存储中的每一次都会向目录产生一条写通数据消息。\n$$N_{stores, WT} = u \\times 1 = u$$\n- 阶段3（消费者的首次读取）：处理消费者的读未命中。对于 WT 策略，目录/L3 已经拥有最新数据。问题指明了以下序列：\n  - 1 条从消费者到目录的读取请求。\n  - 1 条从目录到消费者的数据响应。\n  - 1 条从目录到生产者的降级消息（将其状态从 M 更改为 S）。\n  - 1 条从生产者到目录的确认消息。\n在 WT 策略下，消费者读未命中产生的总消息数为：\n$$N_{read, WT} = 1 + 1 + 1 + 1 = 4$$\n\n一个完整交接周期的总消息数 ($N_{cycle, WT}$) 是所有阶段消息数的总和：\n$$N_{cycle, WT} = N_{upg} + N_{stores, WT} + N_{read, WT} = 3 + u + 4 = u + 7$$\n这个周期也对应于 $u$ 个项目的生产。每个项目的期望消息数 $M_{item, WT}$ 是每个周期的总消息数除以 $u$：\n$$M_{item, WT} = \\frac{N_{cycle, WT}}{u} = \\frac{u + 7}{u} = 1 + \\frac{7}{u}$$\n\n最终结果是一个行矩阵，分别包含 WB 和 WT 策略下每个项目的期望消息数的表达式。", "answer": "$$ \\boxed{ \\begin{pmatrix} \\frac{7}{u}  1 + \\frac{7}{u} \\end{pmatrix} } $$", "id": "3635552"}, {"introduction": "现实世界中的系统设计需要在相互竞争的因素之间取得平衡，以找到最佳配置。本练习将分析提升到系统层面，要求你将空间局部性和伪共享之间的权衡建模为缓存行大小的函数。通过推导最佳缓存行大小 [@problem_id:3635600]，你将练习这种对设计高性能多核处理器至关重要的分析建模方法。", "problem": "考虑一个共享内存多处理器，它运行一个基于目录的缓存一致性协议，该协议在写入时进行无效化（例如，修改–独占–共享–无效，MESI）。系统中有 $T$ 个硬件线程，每个线程都有一个私有的回写式一级数据缓存，其缓存行大小为 $\\ell$ 字节。所有数组均以行主序存储。一个并行的分块矩阵乘法计算 $C \\leftarrow A \\times B$，其中涉及三个稠密的 $M \\times M$ 矩阵，矩阵元素大小为 $s$ 字节。计算的调度方式如下：\n- 每个线程拥有一块 $C$ 矩阵中连续的垂直列条带；这些条带将 $M$ 列在 $T$ 个线程间均匀划分，无重叠。\n- 每个线程使用寄存器累加来计算其分配到的 $C$ 矩阵元素，并在计算结束时将每个 $C$ 的元素仅写入一次。\n- 在乘法计算期间，数组 $A$ 和 $B$ 是只读的。\n\n为了在不枚举细粒度重用的情况下捕捉大规模下的一致性和目录开销，我们采用以下具有科学依据的简化目录流量模型：\n1. 对于 $A$ 和 $B$ 的读未命中，整个乘法计算过程中不同读未命中缓存行的总数被建模为 $\\alpha \\frac{M^{3} s}{\\ell}$，其中 $\\alpha$ 是一个反映算法分块和重用的无量纲常数。每次此类读未命中平均产生 $c_{r}$ 字节的目录控制流量（请求、目录回复和一致性簿记的总和），该流量与数据负载大小无关。\n2. 对于向 $C$ 的写入，线程间的伪共享可能沿着垂直条带的边界发生。在每一行中，相邻条带之间有 $T-1$ 个这样的边界。对于给定的行边界和缓存行大小 $\\ell$，我们将边界相对于缓存行对齐的偏移量建模为在一个缓存行内的 $\\ell/s$ 个元素位置上均匀分布。在此模型下，边界正好落在一个缓存行内部（因此两个不同的线程会写入同一缓存行内的不同字）的概率为 $p_{\\mathrm{fs}}(\\ell) = 1 - \\frac{s}{\\ell}$（对于 $\\ell \\ge s$）。当在某行的边界上发生伪共享时，两个线程之间会发生一次精确的缓存行缓存到缓存传输，这会产生 $\\ell$ 字节的数据移动加上 $c_{w}$ 字节的目录控制流量（写未命中请求、对前一个所有者的无效化以及确认），之后第二个写入者才能获得独占所有权。\n\n假设边界相对于缓存行边界的对齐在各行之间是独立的，并且缓存驱逐不会抑制发生伪共享的边界上发生的这一次传输。将总预期目录流量 $D(\\ell)$ 定义为 $A$ 和 $B$ 的读未命中 control 流量与 $C$ 的伪共享流量之和。你可以忽略任何与 $\\ell$ 无关的恒定数据负载流量（例如为读未命中从内存中获取的强制性数据），因为它不影响对 $\\ell$ 的优化。\n\n仅从上述定义和模型假设出发，并将 $\\ell$ 视为满足 $\\ell \\ge s$ 的连续变量，推导出一个使 $D(\\ell)$ 最小化的缓存行大小 $\\ell^{\\star}$ 的封闭形式表达式。陈述你所要求的使内部最小值存在的任何正则性条件。将你的最终答案表示为参数 $T$、$M$、$s$、$\\alpha$、$c_{r}$ 和 $c_{w}$ 的符号函数。不需要进行数值代入，也不需要四舍五入。最终答案必须是一个单一的解析表达式。", "solution": "目标是找到最优的缓存行大小，记为 $\\ell^{\\star}$，以最小化总预期目录流量 $D(\\ell)$。问题指定 $\\ell$ 是一个连续变量，满足 $\\ell \\ge s$，其中 $s$ 是矩阵元素的字节大小。我们假设线程数 $T  1$，因为一致性流量的概念仅在多处理器环境中才有意义。\n\n首先，我们必须构建总预期目录流量 $D(\\ell)$ 的函数。根据问题定义，$D(\\ell)$ 是两个部分的和：矩阵 $A$ 和 $B$ 的读未命中控制流量，我们记为 $D_{\\text{read}}(\\ell)$，以及矩阵 $C$ 的伪共享流量，记为 $D_{\\text{write}}(\\ell)$。\n$$ D(\\ell) = D_{\\text{read}}(\\ell) + D_{\\text{write}}(\\ell) $$\n\n让我们根据所提供的模型推导每个部分的表达式。\n\n1.  **读未命中控制流量，$D_{\\text{read}}(\\ell)$**\n模型指出，在整个计算过程中，矩阵 $A$ 和 $B$ 的不同读未命中缓存行的总数为 $\\alpha \\frac{M^3 s}{\\ell}$。每次此类读未命中平均产生 $c_r$ 字节的目录控制流量。因此，总读未命中控制流量是这两个量的乘积：\n$$ D_{\\text{read}}(\\ell) = \\left(\\alpha \\frac{M^3 s}{\\ell}\\right) c_r = \\frac{\\alpha c_r M^3 s}{\\ell} $$\n问题允许忽略与 $\\ell$ 无关的数据负载流量。这些读未命中的数据负载将与 $(\\alpha \\frac{M^3 s}{\\ell}) \\times \\ell = \\alpha M^3 s$ 成正比，该值与 $\\ell$ 无关，因此可以正确地从优化函数中省略。\n\n2.  **伪共享流量，$D_{\\text{write}}(\\ell)$**\n矩阵 $C$ 上的伪共享发生在分配给不同线程的列条带之间的垂直边界处。矩阵 $C$ 中有 $M$ 行，每行有 $T-1$ 个这样的边界。因此，可能发生伪共享的位置总数为 $M(T-1)$。\n\n对于每个边界，模型给出了伪共享的概率 $p_{\\mathrm{fs}}(\\ell)$ 为：\n$$ p_{\\mathrm{fs}}(\\ell) = 1 - \\frac{s}{\\ell} $$\n当在边界处发生伪共享时，它会产生 $\\ell + c_w$ 字节的流量成本，其中包括 $\\ell$ 字节的缓存到缓存数据传输和 $c_w$ 字节的目录控制流量。\n\n单个边界的预期流量是事件发生的概率与其成本的乘积：\n$$ E[\\text{traffic per boundary}] = p_{\\mathrm{fs}}(\\ell) \\times (\\ell + c_w) = \\left(1 - \\frac{s}{\\ell}\\right)(\\ell + c_w) $$\n展开此表达式，我们得到：\n$$ E[\\text{traffic per boundary}] = \\ell + c_w - s - \\frac{sc_w}{\\ell} $$\n总预期伪共享流量 $D_{\\text{write}}(\\ell)$ 是每个边界的预期流量乘以总边界数 $M(T-1)$，因为假设对齐在各行之间是独立的。\n$$ D_{\\text{write}}(\\ell) = M(T-1) \\left(\\ell + c_w - s - \\frac{sc_w}{\\ell}\\right) $$\n\n3.  **总预期目录流量，$D(\\ell)$**\n结合这两个部分，总流量函数 $D(\\ell)$ 是：\n$$ D(\\ell) = D_{\\text{read}}(\\ell) + D_{\\text{write}}(\\ell) = \\frac{\\alpha c_r M^3 s}{\\ell} + M(T-1) \\left(\\ell + c_w - s - \\frac{sc_w}{\\ell}\\right) $$\n为了便于最小化，我们根据各项对 $\\ell$ 的依赖关系进行分组：\n$$ D(\\ell) = M(T-1)\\ell + \\left( \\alpha c_r M^3 s - M(T-1)sc_w \\right)\\frac{1}{\\ell} + M(T-1)(c_w - s) $$\n项 $M(T-1)(c_w - s)$ 是一个关于 $\\ell$ 的常数，不会影响最小值的位置。\n\n4.  **$D(\\ell)$ 的最小化**\n为了找到使 $D(\\ell)$ 最小的 $\\ell$ 值，我们计算 $D(\\ell)$ 关于 $\\ell$ 的一阶导数并将其设为零。\n$$ \\frac{dD}{d\\ell} = \\frac{d}{d\\ell} \\left( M(T-1)\\ell + \\frac{\\alpha c_r M^3 s - M(T-1)sc_w}{\\ell} + \\text{constant} \\right) $$\n$$ \\frac{dD}{d\\ell} = M(T-1) - \\frac{\\alpha c_r M^3 s - M(T-1)sc_w}{\\ell^2} $$\n将导数设为零以求最优行大小 $\\ell^{\\star}$：\n$$ M(T-1) - \\frac{\\alpha c_r M^3 s - M(T-1)sc_w}{(\\ell^{\\star})^2} = 0 $$\n$$ M(T-1) = \\frac{\\alpha c_r M^3 s - M(T-1)sc_w}{(\\ell^{\\star})^2} $$\n求解 $(\\ell^{\\star})^2$：\n$$ (\\ell^{\\star})^2 = \\frac{\\alpha c_r M^3 s - M(T-1)sc_w}{M(T-1)} = \\frac{\\alpha c_r M^3 s}{M(T-1)} - \\frac{M(T-1)sc_w}{M(T-1)} $$\n$$ (\\ell^{\\star})^2 = \\frac{\\alpha c_r M^2 s}{T-1} - sc_w $$\n取平方根得到 $\\ell^{\\star}$ 的表达式：\n$$ \\ell^{\\star} = \\sqrt{\\frac{\\alpha c_r M^2 s}{T-1} - sc_w} $$\n\n5.  **内部最小值的正则性条件**\n为了使此表达式表示一个有效的内部最小值，必须满足某些条件。\n-   首先，二阶导数必须为正。\n    $$ \\frac{d^2D}{d\\ell^2} = \\frac{2(\\alpha c_r M^3 s - M(T-1)sc_w)}{\\ell^3} $$\n    对于 $\\ell  0$，我们需要分子为正：$\\alpha c_r M^3 s - M(T-1)sc_w  0$，可简化为 $\\alpha c_r M^2  (T-1)c_w$。这也确保了 $\\ell^{\\star}$ 平方根内的项为正，因此 $\\ell^{\\star}$ 是一个实数。\n-   其次，问题域指定 $\\ell \\ge s$。推导出的 $\\ell^{\\star}$ 仅在 $\\ell^{\\star}  s$ 时才是一个内部最小值。这要求：\n    $$ \\sqrt{\\frac{\\alpha c_r M^2 s}{T-1} - sc_w}  s $$\n    $$ \\frac{\\alpha c_r M^2 s}{T-1} - sc_w  s^2 $$\n    $$ \\frac{\\alpha c_r M^2}{T-1}  s + c_w $$\n这是存在内部最小值的正则性条件。如果不满足此条件，则假设函数是凸的，$D(\\ell)$ 在定义域 $[\\_s, \\infty)$ 上的最小值出现在边界 $\\ell = s$ 处。\n\n问题要求在假设存在内部最小值的情况下，给出 $\\ell^{\\star}$ 的封闭形式表达式。推导出的表达式就是在此条件下的答案。\n最终表达式可以写为：\n$$ \\ell^{\\star} = \\sqrt{s \\left( \\frac{\\alpha c_r M^2}{T-1} - c_w \\right)} $$\n这种形式清楚地显示了对模型参数的依赖性。", "answer": "$$\\boxed{\\sqrt{\\frac{\\alpha c_r M^2 s}{T-1} - sc_w}}$$", "id": "3635600"}]}