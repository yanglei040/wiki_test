{"hands_on_practices": [{"introduction": "MOESI 协议中的“Owned”状态旨在通过允许一个缓存直接向另一个缓存提供脏数据来减少对主内存的写回操作，从而降低延迟。本练习提供了一个具体的场景，通过概率分析来量化这种优化带来的性能增益。通过计算，你将能更深刻地理解 MOESI 相对于 MESI 的优势所在，并学会如何将协议层面的差异转化为可衡量的延迟节省。[@problem_id:3658472]", "problem": "考虑一个具有 $N=8$ 个核心的对称多处理器，该处理器使用基于监听的缓存一致性协议。有两种一致性协议可用：修改、独占、共享、无效 (MESI) 和修改、拥有、独占、共享、无效 (MOESI)。在修改、独占、共享、无效 (MESI) 协议中，当一个核心对另一个核心中当前处于修改 (Modified) 状态的缓存行执行读取操作时，持有修改后数据的核心必须先将该行写回内存，然后请求者才能获取数据，因此该读取操作实际上由主存提供服务。在修改、拥有、独占、共享、无效 (MOESI) 协议中，拥有 (Owned) 状态允许持有修改行的缓存直接向请求者提供数据，而无需立即写回内存。\n\n假设延迟如下：\n- 缓存到缓存传输延迟 $t_{cc} = 20\\,\\text{ns}$。\n- 主存（动态随机存取存储器）延迟 $t_{\\text{dram}} = 80\\,\\text{ns}$。\n\n假设核心发出了 $k=1000$ 个读请求，每个请求都针对一个当前在 $N$ 个缓存之一中处于修改 (Modified) 状态的缓存行。将请求核心和拥有者核心（持有修改行的核心）的选择建模为在 $N$ 个核心上的独立均匀随机选择。在这些假设下，从第一性原理推导，由于拥有者服务的传输，修改、拥有、独占、共享、无效 (MOESI) 协议相对于修改、独占、共享、无效 (MESI) 协议所实现的预期总延迟节省，然后使用上述参数值对表达式进行数值计算。以纳秒为单位表示最终的延迟节省，并将您的答案四舍五入到四位有效数字。", "solution": "用户希望我解决以下问题：\n考虑一个具有 $N=8$ 个核心的对称多处理器，该处理器使用基于监听的缓存一致性协议。有两种一致性协议可用：修改、独占、共享、无效 (MESI) 和修改、拥有、独占、共享、无效 (MOESI)。在修改、独占、共享、无效 (MESI) 协议中，当一个核心对另一个核心中当前处于修改 (Modified) 状态的缓存行执行读取操作时，持有修改后数据的核心必须先将该行写回内存，然后请求者才能获取数据，因此该读取操作实际上由主存提供服务。在修改、拥有、独占、共享、无效 (MOESI) 协议中，拥有 (Owned) 状态允许持有修改行的缓存直接向请求者提供数据，而无需立即写回内存。\n\n假设延迟如下：\n- 缓存到缓存传输延迟 $t_{cc} = 20\\,\\text{ns}$。\n- 主存（动态随机存取存储器）延迟 $t_{\\text{dram}} = 80\\,\\text{ns}$。\n\n假设核心发出了 $k=1000$ 个读请求，每个请求都针对一个当前在 $N$ 个缓存之一中处于修改 (Modified) 状态的缓存行。将请求核心和拥有者核心（持有修改行的核心）的选择建模为在 $N$ 个核心上的独立均匀随机选择。在这些假设下，从第一性原理推导，由于拥有者服务的传输，修改、拥有、独占、共享、无效 (MOESI) 协议相对于修改、独占、共享、无效 (MESI) 协议所实现的预期总延迟节省，然后使用上述参数值对表达式进行数值计算。以纳秒为单位表示最终的延迟节省，并将您的答案四舍五入到四位有效数字。\n\n### 步骤 1：提取已知条件\n- 核心数：$N = 8$。\n- 协议：MESI 和 MOESI。\n- MESI 对读取另一个核心中修改行的行为：写回内存，然后请求者从内存中读取。\n- MOESI 对读取另一个核心中修改行的行为：直接缓存到缓存供应。\n- 缓存到缓存传输延迟：$t_{cc} = 20\\,\\text{ns}$。\n- 主存延迟：$t_{\\text{dram}} = 80\\,\\text{ns}$。\n- 总读请求数：$k = 1000$。\n- 请求目标：在一个缓存中处于修改状态的缓存行。\n- 概率模型：请求核心和拥有者核心是从 $N$ 个核心中独立均匀随机选择的。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为 MESI 和 MOESI 是计算机体系结构中的标准缓存一致性协议，其描述的用于处理对修改后数据的读取行为是准确的表述。该问题是适定 (well-posed) 的，提供了所有必需的参数（$N$、$k$、$t_{cc}$、$t_{\\text{dram}}$）和一个清晰、可形式化的概率模型。语言客观而精确。该问题是自洽的、一致的，不违反任何科学原理，也不包含不切实际的数据。它要求基于概率论和计算机体系结构原理知识进行实质性推导。\n\n### 步骤 3：结论与行动\n问题有效。我将继续提供完整解答。\n\n### 解答推导\n目标是求出对于 $k$ 个读请求，MOESI 协议相对于 MESI 协议的预期总延迟节省。总节省量将是请求数量与每次请求的预期节省量的乘积。让我们首先分析单个读请求的延迟。\n\n设 $C_r$ 为发出读请求的核心，$C_o$ 为拥有处于修改 (Modified) 状态的缓存行的核心。$C_r$ 和 $C_o$ 都是从 $N$ 个核心的集合中独立均匀地抽取的。对于任何单个请求，有两种不同的情况：\n1.  请求核心与拥有者核心相同，即 $C_r = C_o$。\n2.  请求核心与拥有者核心不同，即 $C_r \\neq C_o$。\n\n我们首先确定这两个事件的概率。由于选择是在 $N$ 种可能性上独立且均匀的，因此有 $N \\times N = N^2$ 个同样可能的 $(C_r, C_o)$ 对。\n$C_r = C_o$ 的对数为 $N$（即 $(1,1), (2,2), \\dots, (N,N)$）。此事件的概率是：\n$$ P(C_r = C_o) = \\frac{N}{N^2} = \\frac{1}{N} $$\n其互补事件 $C_r \\neq C_o$ 的概率是：\n$$ P(C_r \\neq C_o) = 1 - P(C_r = C_o) = 1 - \\frac{1}{N} = \\frac{N-1}{N} $$\n\n现在，让我们根据这些情况分析每种协议的延迟。\n在 $C_r = C_o$ 的情况下，核心正在读取它已经拥有的处于可修改状态的缓存行。这是一个本地缓存命中。本地命中的延迟（我们称之为 $t_{\\text{hit}}$）与一致性协议（MESI 或 MOESI）无关，因为不需要核心间通信。\n\n在 $C_r \\neq C_o$ 的情况下，读请求是一致性未命中。延迟取决于协议：\n-   **MESI 协议：** 根据问题描述，拥有者核心 $C_o$ 必须首先将修改后的数据写回主存。然后，请求核心 $C_r$ 从主存读取数据。此操作的延迟主要由访问主存决定，即 $t_{\\text{dram}}$。\n-   **MOESI 协议：** 该协议允许拥有者核心 $C_o$ 通过缓存到缓存的传输将数据直接转发给请求核心 $C_r$。此操作的延迟为 $t_{cc}$。\n\n设 $L_{MESI}$ 和 $L_{MOESI}$ 分别为两种协议下单个请求延迟的随机变量。使用全期望定律，我们可以写出预期延迟：\n$$ E[L_{MESI}] = P(C_r = C_o) \\cdot t_{\\text{hit}} + P(C_r \\neq C_o) \\cdot t_{\\text{dram}} $$\n$$ E[L_{MOESI}] = P(C_r = C_o) \\cdot t_{\\text{hit}} + P(C_r \\neq C_o) \\cdot t_{cc} $$\n\n代入概率：\n$$ E[L_{MESI}] = \\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{\\text{dram}} $$\n$$ E[L_{MOESI}] = \\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{cc} $$\n\n单个请求的预期延迟节省 $\\Delta L$ 是预期延迟之间的差值：\n$$ \\Delta L = E[L_{MESI}] - E[L_{MOESI}] $$\n$$ \\Delta L = \\left(\\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{\\text{dram}}\\right) - \\left(\\frac{1}{N} t_{\\text{hit}} + \\frac{N-1}{N} t_{cc}\\right) $$\n包含 $t_{\\text{hit}}$ 的项被消去，这是预料之中的，因为延迟节省只发生在 $C_r \\neq C_o$ 的情况下。\n$$ \\Delta L = \\frac{N-1}{N} t_{\\text{dram}} - \\frac{N-1}{N} t_{cc} $$\n$$ \\Delta L = \\frac{N-1}{N} (t_{\\text{dram}} - t_{cc}) $$\n\n这个表达式代表了每次请求的预期延迟节省。对于 $k$ 个独立请求，总预期延迟节省 $\\Delta L_{\\text{total}}$ 是每次请求节省量的 $k$ 倍：\n$$ \\Delta L_{\\text{total}} = k \\cdot \\Delta L = k \\frac{N-1}{N} (t_{\\text{dram}} - t_{cc}) $$\n\n现在我们代入给定的数值：$k = 1000$，$N=8$，$t_{\\text{dram}} = 80\\,\\text{ns}$，以及 $t_{cc} = 20\\,\\text{ns}$。\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot \\frac{8-1}{8} (80 - 20) $$\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot \\frac{7}{8} (60) $$\n$$ \\Delta L_{\\text{total}} = 1000 \\cdot 0.875 \\cdot 60 $$\n$$ \\Delta L_{\\text{total}} = 875 \\cdot 60 $$\n$$ \\Delta L_{\\text{total}} = 52500 $$\n结果的单位是纳秒，因为输入的延迟是以纳秒为单位的。问题要求答案四舍五入到四位有效数字。用科学记数法表示，这是 $5.250 \\times 10^4$。", "answer": "$$\n\\boxed{5.250 \\times 10^{4}}\n$$", "id": "3658472"}, {"introduction": "在多核系统中，一个常见的性能陷阱是“伪共享”（false sharing），即逻辑上不相关的多个数据项由于位于同一个缓存行而引发不必要的缓存一致性流量。本练习将通过一个典型的例子，让你亲手计算在伪共享情况下产生的大量缓存失效事件。通过对比数据填充前后的差异，你将直观地感受到数据布局对性能的巨大影响，并理解为什么 MOESI 的优势在某些特定访问模式下并不总能体现。[@problem_id:3658524]", "problem": "一个对称多处理器拥有 $4$ 个相同的核心，每个核心都有一个私有的一级数据缓存。该缓存是写回、写分配的，并通过监听协议来强制实现一致性，该协议为修改-独占-共享-无效（MESI）或修改-拥有-独占-共享-无效（MOESI）中的一种。缓存行大小为 $64$ 字节。所有缓存最初都是空的。\n\n考虑一个由 $4$ 个不相关的 $8$ 字节计数器组成的数据结构，这些计数器在内存中连续布局，地址为 $A_0 + 8k$，$k \\in \\{0,1,2,3\\}$，其中 $A_0$ 与一个 $64$ 字节的缓存行边界对齐。因此，所有 $4$ 个计数器都占用同一个缓存行。核心 $k$ 重复执行一个紧凑循环，将其位于地址 $A_0 + 8k$ 的计数器精确地增加 $W$ 次，其中 $W = 10^{6}$。没有对这些地址的其他内存访问。执行是按照严格的循环顺序在核心之间调度的，每个时间片每个核心执行一次存储操作，因此共享缓存行的所有权在每次存储操作时都在核心之间交替。将失效事件定义为：由于另一个核心的请求，某个核心中的缓存行发生由一致性引起的转换，从一个有效状态（$M$、$E$、$S$ 或 $O$）转变为无效状态（$I$）。\n\n仅使用 MESI 和 MOESI 状态的标准语义、写分配行为以及“两个地址当且仅当它们落在同一个 $64$ 字节块内时才映射到同一个缓存行”这一事实，回答以下问题：\n\n- 在 MESI 协议下，对于给定的布局和调度，推导由对 $4$ 个计数器的 $4W$ 次存储操作引起的总失效事件数。\n- 论证对于这种特定的写-写模式，在 MOESI 协议下该总数是否会改变，并从基本原理出发证明你的结论。\n- 提出一种变换，将这 $4$ 个不相关的计数器分置到不同的缓存行中（例如，通过填充使每个计数器都以 $64$ 字节对齐方式从一个独立的 $64$ 字节行的开头开始），并推导在应用此变换后，在相同的调度和 $W$ 值下，总的失效事件数。\n\n设 $D$ 表示变换前的总失效事件数与变换后的总失效事件数之差。计算 $D$ 的值，结果为一个整数。请以不带单位的整数形式表达你的最终答案。不要四舍五入。", "solution": "本题要求在对称多处理器系统中，针对两种不同的数据布局，分析由缓存一致性引起的失效事件。问题的核心是理解在“伪共享”场景和具有适当数据对齐的场景中，缓存行在 MESI 和 MOESI 协议下的状态转换。\n\n首先，我们确定与问题相关的基本状态和转换。MESI 协议为缓存行定义了四种状态：\n- **修改（$M$）**：缓存行仅存在于当前缓存中，是脏的（已修改），并且其在主存中的值是过时的。\n- **独占（$E$）**：缓存行仅存在于当前缓存中，是干净的，并且与主存中的值匹配。\n- **共享（$S$）**：缓存行存在于此缓存以及至少一个其他缓存中，是干净的，并且与主存匹配。\n- **无效（$I$）**：缓存行不存在于缓存中。\n\nMOESI 协议增加了第五种状态：\n- **拥有（$O$）**：缓存行存在于此缓存中，并可能以 $S$ 状态存在于其他缓存中。该行是脏的，此缓存负责将其写回内存。主存的副本是过时的。$O$ 状态允许共享脏数据而无需写回内存。\n\n失效事件被定义为由另一个核心的总线请求触发的，从任何有效状态（$M$、$E$、$S$ 或 $O$）到 $I$ 状态的转换。核心的写未命中会导致其发出一个带修改意图的读取（RWITM）总线请求，通常表示为 `BusRdX`。当一个持有状态为 $M$ 或 $O$ 的缓存行的缓存监听到来自另一个核心对同一行的 `BusRdX` 请求时，它必须放弃所有权并使其副本失效。\n\n系统有 $4$ 个核心，每个核心执行 $W = 10^6$ 次增量操作。总存储次数为 $4W$。调度是严格的存储循环：$C_0, C_1, C_2, C_3, C_0, C_1, \\ldots$。\n\n**第一部分：变换前分析（伪共享）**\n\n在这种情况下，所有 $4$ 个计数器（每个大小为 $8$ 字节）都位于一个 $64$ 字节的缓存行中，因为基地址 $A_0$ 是对齐的，且 $4 \\times 8 = 32  64$。这是一个典型的伪共享情况，其中逻辑上独立的数据项因为物理上共享一个缓存行而导致一致性流量。\n\n**MESI 协议下失效事件的推导：**\n我们来追踪共享缓存行在 $4$ 个核心 $P_0, P_1, P_2, P_3$ 中的状态。最初，该行在所有缓存中都处于 $I$ 状态。\n\n1.  **存储 1（核心 $P_0$）：** $P_0$ 发生写未命中。它为该行发出一个 `BusRdX` 请求。由于所有其他缓存中该行都处于 $I$ 状态，主存提供数据。$P_0$ 的缓存加载该行并将其状态设置为 $M$。没有其他核心持有有效副本。\n    - 状态：$P_0:M, P_1:I, P_2:I, P_3:I$。\n    - 失效事件：$0$。\n\n2.  **存储 2（核心 $P_1$）：** $P_1$ 发生写未命中并发出一个 `BusRdX` 请求。$P_0$ 监听到此请求，并发现自己持有该行的状态为 $M$。为保持一致性，$P_0$ 必须将数据提供给 $P_1$（或者先让数据写入内存，同时写回自己的版本），然后使其自己的副本失效。$P_0$ 的行状态从 $M \\to I$ 转换。$P_1$ 加载该行并将其状态设置为 $M$。\n    - 状态：$P_0:I, P_1:M, P_2:I, P_3:I$。\n    - 失效事件：$1$（在 $P_0$ 中）。\n\n3.  **存储 3（核心 $P_2$）：** $P_2$ 发生写未命中并发出一个 `BusRdX` 请求。$P_1$ 监听到此请求，发现自己持有该行的状态为 $M$，于是提供数据并使其副本失效（$M \\to I$）。$P_2$ 将其行状态设置为 $M$。\n    - 状态：$P_0:I, P_1:I, P_2:M, P_3:I$。\n    - 失效事件：$1$（在 $P_1$ 中）。\n\n这个模式会重复。从第二次存储开始，每次存储操作时，执行前一次存储的核心都以 $M$ 状态独占该行。当前核心的 `BusRdX` 请求会强制前一个所有者使其副本失效。\n\n总存储次数为 $4W$。第一次存储导致 $0$ 次失效。随后的每一次存储（共 $4W-1$ 次）都导致恰好一次失效。\n因此，变换前的总失效事件数 $N_{before}$ 为：\n$$N_{before} = 0 + (4W-1) \\times 1 = 4W-1$$\n\n**MOESI 协议下的论证：**\n我们必须论证在 MOESI 协议下这个总数是否会改变。MOESI 协议引入了 $O$ 状态来优化脏行的读共享。当一个持有 $M$ 状态行的核心监听到一个读请求（`BusRd`）时，会发生从 $M$ 到 $O$ 的转换。所有者向请求者提供数据（请求者进入 $S$ 状态），并将其自身状态转换为 $O$。\n\n然而，本题中描述的工作负载*完全*由写操作组成（增量操作是读-修改-写操作，最终以一次存储告终，并且从一致性的角度来看，被视为需要独占所有权的写操作）。写未命中总是会生成一个 `BusRdX` 请求。当一个处于 $M$（或 $O$）状态的核心监听到一个 `BusRdX` 请求时，它必须使其副本失效。$O$ 状态永远不会被进入，因为没有来自其他核心的简单读请求来触发 $M \\to O$ 的转换。因此，事件序列与 MESI 协议下完全相同。缓存行总是在恰好一个缓存中处于 $M$ 状态，而在所有其他缓存中处于 $I$ 状态。对于这种特定的纯写、迁移式访问模式，在 MOESI 协议下，总失效次数仍然是 $4W-1$。\n\n**第二部分：变换后分析**\n\n所提出的变换涉及对数据结构进行填充，以便 $4$ 个计数器中的每一个都驻留在其自己独立的、专用的 $64$ 字节缓存行上。我们将这些行表示为 $L_0, L_1, L_2, L_3$。核心 $P_k$ 只访问行 $L_k$。\n\n我们来分析单个核心的访问，比如核心 $P_0$ 访问行 $L_0$。\n1.  **$P_0$ 的第一次存储：** $P_0$ 对行 $L_0$ 发生写未命中。它为 $L_0$ 发出一个 `BusRdX` 请求。由于这是一个独立的行，没有其他核心拥有其副本。该行从内存中获取，$P_0$ 的缓存将 $L_0$ 的状态设置为 $M$。\n    - 失效事件：$0$。\n\n2.  **$P_0$ 的后续 $W-1$ 次存储：** 对于所有后续的增量操作，$P_0$ 都会在其缓存中找到处于 $M$ 状态的行 $L_0$。这些都是写命中。写操作在本地执行，不产生任何总线流量。\n\n关键在于，没有其他核心（$P_1, P_2, P_3$）会访问行 $L_0$。$P_0$ 缓存中 $L_0$ 的失效只会在另一个核心为 $L_0$ 发出 `BusRd` 或 `BusRdX` 请求时发生。由于这种情况从未发生，行 $L_0$ 在 $P_0$ 的 $W$ 次写操作期间，在初次未命中之后，一直保持在 $P_0$ 缓存的 $M$ 状态。\n\n同样的逻辑独立地适用于核心 $P_1, P_2,$ 和 $P_3$ 及其各自专用的行 $L_1, L_2,$ 和 $L_3$。每个核心加载其缓存行一次，之后该行在其核心的缓存中保持 $M$ 状态。在每个核心初次的强制性未命中之后，这些行不会再产生一致性流量。\n\n因此，由一致性引起的失效事件为零。变换后的总失效数 $N_{after}$ 为：\n$$N_{after} = 0$$\n这个结果与协议是 MESI 还是 MOESI 无关。\n\n**第三部分：最终计算**\n\n题目要求计算变换前后的总失效事件数之差 $D$。我们已知 $W = 10^6$。\n\n$$D = N_{before} - N_{after}$$\n$$D = (4W - 1) - 0$$\n$$D = 4 \\times 10^6 - 1$$\n$$D = 4,000,000 - 1$$\n$$D = 3,999,999$$\n\n这个巨大的差异凸显了伪共享带来的严重性能损失，以及数据填充作为一种缓解策略的有效性。", "answer": "$$\\boxed{3999999}$$", "id": "3658524"}, {"introduction": "现实世界的多处理器系统必须能正确处理多个核心同时请求同一缓存行的竞争情况。这个练习将带你深入了解一个基于总线仲裁的系统如何通过串行化请求和协议状态转换来确保 MESI 协议的正确性。通过追踪竞争的解决过程，你将理解维持一致性所需的底层机制，包括总线事务、失效和重试。[@problem_id:3658513]", "problem": "一个共享内存多处理器使用一种监听写无效缓存一致性协议，该协议实现了“修改–独占–共享–无效”（MESI）。其互连是一个基于单一仲裁的总线，该总线对事务进行串行化：在任何时刻，总线上只能有一个一致性事务，仲裁器将总线授予一个请求者，同时使任何竞争的请求者收到一个否定应答（NACK），从而强制其稍后重试。缓存执行写回操作，并且该协议支持以下一致性请求：BusRd（读取）、BusRdX（为获取所有权而读取）和 BusUpgr（当请求者已在共享状态下持有该行时，升级到独占状态）。为获取所有权而读取（RFO）的操作实现如下：如果请求者在共享状态下持有该行，则通过 BusUpgr 实现；否则通过 BusRdX 实现。\n\n初始时，核心 $\\mathrm{C}0$ 和 $\\mathrm{C}1$ 均以共享状态 $S$ 持有缓存行 $X$。在 $t_0$ 时刻，两个核心同时对 $X$ 执行存储操作，导致它们都在 $X$ 上发出一个 RFO。\n\n仅从 MESI 状态的核心定义和写无效规则出发——即：\n- 不变式：在任何时候，最多只有一个缓存可以以修改状态 $M$ 持有某个行，并且任何写入操作都需要独占所有权（没有其他有效副本）。\n- 语义：BusUpgr 会使所有其他共享者无效，并将请求者的 $S$ 状态升级到 $M$ 状态，而无需获取数据；BusRdX 会获取该行并使所有其他副本无效，从而授予请求者 $M$ 状态。\n\n假设采用典型的监听响应，并且其请求被 NACK 的核心必须在监听到并处理任何介入的总线事务后稍后重试。\n\n预测当两个 RFO “同时”发生时在 MESI 协议下的竞争解决方法，并计算在总线上广播的总无效化次数以及直到两个存储操作都完成（即每个核心都对 $X$ 完成了一次写入）所需的重试次数。哪个选项最符合正确的机制和计数？\n\nA. 一个 RFO 首先赢得仲裁并发起 BusUpgr，使另一个共享者无效（到目前为止总无效化次数 $=1$）。失败者监听到此操作并使其自身副本无效；其未决的请求被 NACK，并且必须稍后作为 BusRdX 重试一次（因为它现在持有 $I$ 状态）。第二次事务使当前的 M 状态所有者无效（增加 $1$ 次无效化）并转移所有权。总计：无效化次数 $=2$，重试次数 $=1$。\n\nB. 监听结构合并了两个升级请求；两个缓存同时进入 M 状态，无需进一步的通信。总计：无效化次数 $=0$，重试次数 $=0$。\n\nC. 仲裁将两个升级请求背靠背地处理，没有 NACK；第一个请求使第二个请求者无效，但第二个请求仍然继续并成功，因为已没有其他共享者。总计：无效化次数 $=1$，重试次数 $=0$。\n\nD. 第一个请求者的 BusUpgr 使另一个共享者无效（无效化次数 $=1$）。失败者必须回退并重试两次才能成功，并且当它最终重试时，当前的所有者仅降级到共享状态而未被无效化。总计：无效化次数 $=1$，重试次数 $=2$。", "solution": "我们从 MESI 的核心定义和写无效准则出发进行分析。\n\n基本事实：\n- MESI 状态：修改（$M$）、独占（$E$）、共享（$S$）、无效（$I$）。一致性不变式要求在任何时候，最多只有一个缓存可以以 $M$ 状态持有给定的缓存行。任何写入操作都需要独占所有权，意味着其他地方不存在有效的副本。\n- 写无效规则：希望写入的请求者必须确保所有其他共享者都被无效化。如果请求者持有 $S$ 状态，它可以发出 BusUpgr 来无效化其他共享者而无需获取数据，然后从 $S \\rightarrow M$ 转换。如果请求者持有 $I$ 状态，它会发出 BusRdX 来获取数据行并无效化其他共享者，从而从 $I \\rightarrow M$ 转换。\n- 总线串行化和 NACK：对于基于单一仲裁的监听总线，同时发出的请求会被串行化处理。一个请求者被授予总线使用权；任何竞争的请求者都会被 NACK 并必须稍后重试。与此同时，所有缓存都会监听总线事务并相应地更新自己的状态。\n\n初始条件（$t_0$ 时刻）：核心 $\\mathrm{C}0$ 和 $\\mathrm{C}1$ 都以 $S$ 状态持有 $X$，并且都发出了 RFO。因为它们都持有 $S$ 状态，所以每个核心都将尝试发起 BusUpgr。\n\n竞争解决的推导过程：\n- 步骤 1：在 $t_0$ 时刻，总线仲裁选择一个请求者（假设为 $\\mathrm{C}0$）。$\\mathrm{C}0$ 的 BusUpgr 出现在总线上。根据写无效规则，BusUpgr 会向所有其他共享者广播一个无效化消息。这里只有一个其他共享者（$\\mathrm{C}1$），所以此步骤中的无效化次数为 $1$。\n- 步骤 2：$\\mathrm{C}1$ 监听到该 BusUpgr 并使其副本无效，状态从 $S \\rightarrow I$ 转换。由于总线是串行化的，$\\mathrm{C}1$ 同时发出的 BusUpgr 不可能在同一时刻也出现在总线上；它要么没有被发出，要么因失去仲裁而被 NACK。根据题目假设，失败者的未决请求会被 NACK，并且必须稍后重试。因此，到目前为止所需的重试次数为 $1$（针对 $\\mathrm{C}1$）。\n- 步骤 3：在 $\\mathrm{C}0$ 的 BusUpgr 完成后，$\\mathrm{C}0$ 的状态从 $S \\rightarrow M$ 转换并执行其写入操作。此时，$\\mathrm{C}0$ 是 $X$ 的唯一 $M$ 状态所有者；$\\mathrm{C}1$ 持有 $I$ 状态。\n- 步骤 4：当 $\\mathrm{C}1$ 重试时，它不再持有 $S$ 状态。为了写入 $X$，它必须发出 BusRdX（一个从 $I$ 状态发出的 RFO）。BusRdX 会使所有其他有效副本无效。这里只有一个这样的副本，由 $\\mathrm{C}0$ 以 $M$ 状态持有。因此，此步骤会产生 $1$ 次针对 $\\mathrm{C}0$ 副本的无效化。当前的 $M$ 状态所有者（$\\mathrm{C}0$）提供或转发数据，并转换到 $I$ 状态，而 $\\mathrm{C}1$ 则从 $I \\rightarrow M$ 转换并执行其写入操作。\n\n计算直到两个存储操作都完成（即 $\\mathrm{C}0$ 和 $\\mathrm{C}1$ 都对 $X$ 完成了一次写入）所发生的事件：\n- 总无效化次数：$1$（来自第一个 BusUpgr 使另一个共享者无效） $+ 1$（来自后来的 BusRdX 使当前的 $M$ 状态所有者无效） $= 2$。\n- 总重试次数：失败者的初始 RFO 被 NACK 一次，并且必须在稍后重试一次。在所述的公平仲裁和标准监听行为下，不需要进一步的重试。因此，重试次数 $= 1$。\n\n关于其他结果为何不正确的说明：\n- 在 MESI 的单一写入者不变式下，两个缓存不可能同时处于 $M$ 状态。因此，任何授予两者 $M$ 状态的“合并”操作（或让两个升级请求在没有串行化的情况下都成功）都违反了基本的一致性不变式。\n- 在失败者被无效化后，它不能再执行“升级”，因为它不再持有有效副本；它必须执行 BusRdX，该操作必然会使当前的所有者无效，以便为写入获取独占权。\n\n逐个选项分析：\n- 选项 A：与推导的序列相匹配。第一个 BusUpgr 使另一个共享者无效（到目前为止无效化次数 $=1$）。失败者的初始请求被 NACK，必须重试一次；从 $I$ 状态重试时，它使用 BusRdX，这会使当前的 $M$ 状态所有者无效（增加 $1$ 次无效化）。总计：无效化次数 $=2$，重试次数 $=1$。结论：正确。\n- 选项 B：声称通过合并使两者都成功进入 $M$ 状态，且不产生无效化或重试。这与 MESI 的单一写入者不变式和总线串行化假设相矛盾；在写入之前必须至少发生一次无效化以消除其他共享者，并且两者不能同时持有 $M$ 状态。结论：不正确。\n- 选项 C：提出两个升级请求在没有 NACK 的情况下背靠背进行，第二个请求在被第一个请求无效化后立即成功。这在内部是不一致的：第二个请求者会因为监听到第一个升级请求而使自己的副本无效，因此它不能再从 $S$ 状态执行“升级”；它必须稍后发出 BusRdX，这既需要重试，又会使当前的所有者无效。此外，在给定的模型下，没有 NACK 的情况下，两个事务不能同时占用总线。结论：不正确。\n- 选项 D：假设需要两次重试，并且在第二个请求时所有者不会被无效化，而仅仅是降级到 $S$ 状态。在 MESI 协议下，写入需要独占权；当前的所有者必须被无效化，而不仅仅是降级到 $S$ 状态，请求者才能获得 $M$ 状态。在所述的公平仲裁器假设下，额外的重试次数也是不合理的。结论：不正确。\n\n关于“修改-拥有-独占-共享-无效”（MOESI）协议的附加说明：如果第二次访问是读取而不是写入，MOESI 的拥有（$O$）状态可以允许先前的 $M$ 状态所有者提供数据并保持为指定的所有者，而无需立即写回。然而，在这种情况下，两次访问都是写入（RFO），因此独占性仍然需要使另一个持有者无效；上述计数与为 MESI 推导的结果保持一致。", "answer": "$$\\boxed{A}$$", "id": "3658513"}]}