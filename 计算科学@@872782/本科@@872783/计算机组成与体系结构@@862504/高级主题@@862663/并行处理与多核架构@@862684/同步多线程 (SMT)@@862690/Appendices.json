{"hands_on_practices": [{"introduction": "同时多线程（Simultaneous Multithreading, SMT）并非“免费的午餐”。它通过隐藏延迟（如缓存未命中造成的停顿）来提高处理器吞吐量，但同时也会因资源竞争而引入性能开销。本练习将引导您使用经典的 CPU 性能公式，量化分析 SMT 在实际应用中的根本性权衡，即其带来的收益（减少停顿周期）与成本（增加指令数）之间的平衡关系 [@problem_id:3631114]。通过这个计算，您将更深刻地理解 SMT 对单线程执行时间产生的净效应。", "problem": "一个单核中央处理器（CPU）以 $f = 3.2~\\text{GHz}$ 的固定时钟频率执行程序A。当程序以单线程模式运行时，测得的每线程基准每指令周期数（CPI）分解为一个 $CPI_{\\text{base}} = 0.90$ 的非停顿部分和一个 $CPI_{\\text{stall},0} = 0.60$ 的停顿部分。基准的每线程指令数为 $IC_{0} = 1.80 \\times 10^{9}$ 条指令。\n\n现在考虑启用同步多线程（SMT），也称为超线程，让两个硬件线程共享该核心。由于长延迟事件的重叠，每线程的CPI停顿部分相对于其单线程值减少了 $30\\%$。然而，共享资源争用使每线程的指令数相对于其单线程值增加了 $1\\%$。假设在SMT下，每线程的非停顿部分 $CPI_{\\text{base}}$ 保持不变，且时钟频率不发生变化。\n\n计算程序A在SMT下的每线程执行时间 $T$。最终答案以秒为单位，并四舍五入到四位有效数字。", "solution": "在尝试给出解答之前，首先对问题进行验证。\n\n### 步骤1：提取已知条件\n-   时钟频率：$f = 3.2~\\text{GHz}$\n-   单线程非停顿每指令周期数（CPI）：$CPI_{\\text{base}} = 0.90$\n-   单线程停顿CPI：$CPI_{\\text{stall},0} = 0.60$\n-   单线程基准指令数：$IC_{0} = 1.80 \\times 10^{9}$ 条指令\n-   同步多线程（SMT）硬件线程数：$2$\n-   SMT下每线程停顿CPI的减少量：$30\\%$\n-   SMT下每线程指令数的增加量：$1\\%$\n-   恒定的每线程非停顿CPI：$CPI_{\\text{base}}$ 保持不变。\n-   恒定的时钟频率：$f$ 保持不变。\n-   目标：计算程序A在SMT下的每线程执行时间 $T$。\n\n### 步骤2：使用提取的已知条件进行验证\n评估问题的有效性。\n-   **科学依据**：该问题利用了基本的CPU性能方程以及来自计算机组成和体系结构的标准概念，包括CPI、指令数、时钟频率和SMT。所描述的SMT效应——通过延迟隐藏减少停顿周期以及由于资源争用而增加指令数——是有据可查且现实的现象。所提供的数值对于现代处理器是合理的。\n-   **问题适定性**：该问题给出了计算唯一解所需的所有必要数据和约束条件。目标陈述清晰。\n-   **客观性**：该问题以精确、定量和无偏见的语言表述。\n\n该问题不违反任何无效性标准。它在科学上是合理的，问题是适定的，并且是客观的。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。将推导出解决方案。\n\n程序在CPU上的执行时间由CPU性能方程确定：\n$$T = \\frac{IC \\times CPI}{f}$$\n其中 $IC$ 是指令数，$CPI$ 是平均每指令周期数，$f$ 是时钟频率。$CPI$ 可以分解为一个非停顿部分 $CPI_{\\text{base}}$ 和一个停顿部分 $CPI_{\\text{stall}}$：\n$$CPI = CPI_{\\text{base}} + CPI_{\\text{stall}}$$\n\n首先，我们确定单线程执行模式的参数。此模式下的总CPI，$CPI_{0}$，为：\n$$CPI_{0} = CPI_{\\text{base}} + CPI_{\\text{stall},0} = 0.90 + 0.60 = 1.50$$\n给定的时钟频率为 $f = 3.2~\\text{GHz} = 3.2 \\times 10^{9}~\\text{Hz}$。\n\n接下来，我们确定在SMT下运行的单个线程的参数。我们用下标 $SMT$ 来表示这些参数。\n\n在SMT下，每线程的指令数 $IC_{SMT}$ 相对于基准指令数 $IC_{0}$ 增加了 $1\\%$：\n$$IC_{SMT} = IC_{0} \\times (1 + 0.01) = 1.01 \\times IC_{0}$$\n代入 $IC_{0}$ 的值：\n$$IC_{SMT} = 1.01 \\times (1.80 \\times 10^{9}) = 1.818 \\times 10^{9}~\\text{条指令}$$\n\n在SMT下，每线程的CPI停顿部分 $CPI_{\\text{stall},SMT}$ 相对于其单线程值 $CPI_{\\text{stall},0}$ 减少了 $30\\%$：\n$$CPI_{\\text{stall},SMT} = CPI_{\\text{stall},0} \\times (1 - 0.30) = 0.70 \\times CPI_{\\text{stall},0}$$\n代入 $CPI_{\\text{stall},0}$ 的值：\n$$CPI_{\\text{stall},SMT} = 0.70 \\times 0.60 = 0.42$$\n\nCPI的非停顿部分 $CPI_{\\text{base}}$ 保持不变。因此，在SMT下，每线程的总CPI，$CPI_{SMT}$，为：\n$$CPI_{SMT} = CPI_{\\text{base}} + CPI_{\\text{stall},SMT} = 0.90 + 0.42 = 1.32$$\n\n现在，我们可以使用CPU性能方程计算在SMT下的每线程执行时间 $T_{SMT}$。时钟频率 $f$ 保持不变。\n$$T_{SMT} = \\frac{IC_{SMT} \\times CPI_{SMT}}{f}$$\n代入计算出的值：\n$$T_{SMT} = \\frac{(1.818 \\times 10^{9}) \\times 1.32}{3.2 \\times 10^{9}~\\text{Hz}}$$\n分子和分母中的因子 $10^{9}$ 相互抵消：\n$$T_{SMT} = \\frac{1.818 \\times 1.32}{3.2}~\\text{s}$$\n$$T_{SMT} = \\frac{2.39976}{3.2}~\\text{s}$$\n$$T_{SMT} = 0.749925~\\text{s}$$\n\n问题要求最终答案四舍五入到四位有效数字。\n第五位有效数字是 $2$，小于 $5$，因此我们向下舍入。\n$$T_{SMT} \\approx 0.7499~\\text{s}$$", "answer": "$$\n\\boxed{0.7499}\n$$", "id": "3631114"}, {"introduction": "在理解了 SMT 在宏观性能上的权衡之后，我们需深入探究其核心工作机制：SMT究竟是如何提升性能的？答案在于它能从多个线程上下文中寻找就绪指令，从而填补单个线程执行时本会闲置的执行单元槽位。本练习通过一个简明的概率模型，让“提高资源利用率”这一抽象概念变得具体可感 [@problem_id:3677167]。通过计算单线程与 SMT 模式下执行端口的期望占用率，您可以直观地看到增加第二个线程是如何有效填补空闲资源，进而实现更高总吞吐量的。", "problem": "一个支持同步多线程 (SMT) 的超标量核心拥有 $3$ 个不相交的单发射执行端口：整数算术端口 $p_{0}$、整数算术端口 $p_{1}$ 和一个内存端口 $p_{M}$。每个端口每周期最多可以发射 $1$ 个微操作，并且每个已发射的微操作都需要且仅需要这些端口中的一个。硬件在每个端口的容量限制下发射所有就绪的微操作；如果在某一周期内，来自不同线程的多个就绪微操作同时需要同一个端口，则通过公平仲裁精确选择一个，但该周期内该端口最多只能发射一个。考虑以下两个线程：\n- 线程 A：在任意周期内，它有就绪微操作的概率为 $0.92$；在就绪的条件下，该微操作需要端口 $p_{0}$ 的概率为 $0.50$，需要端口 $p_{1}$ 的概率为 $0.30$，需要端口 $p_{M}$ 的概率为 $0.20$。\n- 线程 B：在任意周期内，它有就绪微操作的概率为 $0.85$；在就绪的条件下，该微操作需要端口 $p_{0}$ 的概率为 $0.20$，需要端口 $p_{1}$ 的概率为 $0.60$，需要端口 $p_{M}$ 的概率为 $0.20$。\n\n假设在就绪状态和操作类型选择上，线程之间以及周期之间都是独立的。将一个端口的每周期期望占用率定义为该端口在任意周期内发射一个微操作的长期概率。计算在单线程执行 $T=1$（只有线程 A 存在）和双线程 SMT $T=2$（线程 A 和 B 都存在）两种情况下，每个端口的期望占用率。将您的最终答案表示为一个行向量\n$$\n\\big[\\,O_{p_{0}}^{(T=1)},\\,O_{p_{1}}^{(T=1)},\\,O_{p_{M}}^{(T=1)},\\,O_{p_{0}}^{(T=2)},\\,O_{p_{1}}^{(T=2)},\\,O_{p_{M}}^{(T=2)}\\,\\big]\n$$\n并四舍五入到四位有效数字。不需要单位。", "solution": "问题要求计算三个执行端口（$p_0$, $p_1$, $p_M$）在两种情况下的每周期期望占用率：单线程执行（$T=1$），只有线程 A；以及双线程同步多线程（SMT）执行（$T=2$），有线程 A 和 B。期望占用率定义为一个端口在给定周期内发射一个微操作的概率。\n\n首先，我们使用概率符号来形式化给定的信息。\n设 $R_A$ 表示线程 A 在一个周期内有就绪微操作的事件，设 $R_B$ 表示线程 B 在一个周期内有就绪微操作的事件。给出的概率如下：\n$$P(R_A) = 0.92$$\n$$P(R_B) = 0.85$$\n\n设 $C_{A,i}$ 表示线程 A 的一个就绪微操作需要端口 $p_i$ 的事件，其中 $i \\in \\{0, 1, M\\}$。条件概率如下：\n$$P(C_{A,0} | R_A) = 0.50$$\n$$P(C_{A,1} | R_A) = 0.30$$\n$$P(C_{A,M} | R_A) = 0.20$$\n注意，这些概率之和为 $1$，符合预期：$0.50 + 0.30 + 0.20 = 1.0$。\n\n类似地，设 $C_{B,i}$ 表示线程 B 的一个就绪微操作需要端口 $p_i$ 的事件。条件概率如下：\n$$P(C_{B,0} | R_B) = 0.20$$\n$$P(C_{B,1} | R_B) = 0.60$$\n$$P(C_{B,M} | R_B) = 0.20$$\n这些概率之和也为 $1$：$0.20 + 0.60 + 0.20 = 1.0$。\n\n设 $U_{A,i}$ 为线程 A 在一个周期内需要端口 $p_i$ 的事件。此事件发生当且仅当线程 A 有一个就绪微操作并且该操作需要端口 $p_i$。因此，$U_{A,i} = R_A \\cap C_{A,i}$。这个联合事件的概率是：\n$$P(U_{A,i}) = P(R_A \\cap C_{A,i}) = P(C_{A,i} | R_A) P(R_A)$$\n类似地，设 $U_{B,i}$ 为线程 B 需要端口 $p_i$ 的事件。其概率为：\n$$P(U_{B,i}) = P(R_B \\cap C_{B,i}) = P(C_{B,i} | R_B) P(R_B)$$\n\n问题陈述，所有事件在线程间和周期内都是独立的。\n\n让我们为每个端口 $p_i$ 计算概率 $P(U_{A,i})$ 和 $P(U_{B,i})$：\n对于线程 A：\n$$P(U_{A,0}) = 0.50 \\times 0.92 = 0.46$$\n$$P(U_{A,1}) = 0.30 \\times 0.92 = 0.276$$\n$$P(U_{A,M}) = 0.20 \\times 0.92 = 0.184$$\n\n对于线程 B：\n$$P(U_{B,0}) = 0.20 \\times 0.85 = 0.17$$\n$$P(U_{B,1}) = 0.60 \\times 0.85 = 0.51$$\n$$P(U_{B,M}) = 0.20 \\times 0.85 = 0.17$$\n\n现在我们可以计算两种情况下的端口占用率。设 $O_{p_i}^{(T)}$ 为有 $T$ 个线程时端口 $p_i$ 的占用率。\n\n情况 1：单线程执行（$T=1$，仅线程 A）\n在这种情况下，一个端口 $p_i$ 被占用当且仅当线程 A 需要它。因此，占用率就是概率 $P(U_{A,i})$。\n$$O_{p_0}^{(T=1)} = P(U_{A,0}) = 0.46$$\n$$O_{p_1}^{(T=1)} = P(U_{A,1}) = 0.276$$\n$$O_{p_M}^{(T=1)} = P(U_{A,M}) = 0.184$$\n\n情况 2：双线程 SMT 执行（$T=2$，线程 A 和 B）\n在 SMT 情况下，如果至少有一个线程需要端口 $p_i$，那么该端口就被占用。也就是说，如果线程 A 需要它，或者线程 B 需要它。端口 $p_i$ 被占用的事件是并集 $U_{A,i} \\cup U_{B,i}$。占用率是这个并集的概率。\n$$O_{p_i}^{(T=2)} = P(U_{A,i} \\cup U_{B,i})$$\n使用容斥原理，并考虑到两个线程的独立性（这意味着 $P(U_{A,i} \\cap U_{B,i}) = P(U_{A,i}) P(U_{B,i})$），我们有：\n$$O_{p_i}^{(T=2)} = P(U_{A,i}) + P(U_{B,i}) - P(U_{A,i}) P(U_{B,i})$$\n或者，如果端口不空闲，则它被占用。一个端口空闲当且仅当两个线程都不需要它。\n$$O_{p_i}^{(T=2)} = 1 - P(\\text{端口 } p_i \\text{ 空闲}) = 1 - P(\\neg U_{A,i} \\cap \\neg U_{B,i})$$\n根据独立性，可得：\n$$O_{p_i}^{(T=2)} = 1 - P(\\neg U_{A,i}) P(\\neg U_{B,i}) = 1 - (1 - P(U_{A,i}))(1 - P(U_{B,i}))$$\n这个公式是等价的，并且在计算上是稳定的。\n\n对于端口 $p_0$：\n$$O_{p_0}^{(T=2)} = 1 - (1 - 0.46)(1 - 0.17) = 1 - (0.54)(0.83) = 1 - 0.4482 = 0.5518$$\n\n对于端口 $p_1$：\n$$O_{p_1}^{(T=2)} = 1 - (1 - 0.276)(1 - 0.51) = 1 - (0.724)(0.49) = 1 - 0.35476 = 0.64524$$\n\n对于端口 $p_M$：\n$$O_{p_M}^{(T=2)} = 1 - (1 - 0.184)(1 - 0.17) = 1 - (0.816)(0.83) = 1 - 0.67728 = 0.32272$$\n\n问题要求最终答案四舍五入到四位有效数字。\n$O_{p_0}^{(T=1)} = 0.46 \\rightarrow 0.4600$\n$O_{p_1}^{(T=1)} = 0.276 \\rightarrow 0.2760$\n$O_{p_M}^{(T=1)} = 0.184 \\rightarrow 0.1840$\n$O_{p_0}^{(T=2)} = 0.5518 \\rightarrow 0.5518$\n$O_{p_1}^{(T=2)} = 0.64524 \\rightarrow 0.6452$\n$O_{p_M}^{(T=2)} = 0.32272 \\rightarrow 0.3227$\n\n最终结果是这六个值按指定顺序组成的行向量。\n$$\n\\big[\\,O_{p_{0}}^{(T=1)},\\,O_{p_{1}}^{(T=1)},\\,O_{p_{M}}^{(T=1)},\\,O_{p_{0}}^{(T=2)},\\,O_{p_{1}}^{(T=2)},\\,O_{p_{M}}^{(T=2)}\\,\\big]\n$$\n$$\n\\big[\\,0.4600,\\,0.2760,\\,0.1840,\\,0.5518,\\,0.6452,\\,0.3227\\,\\big]\n$$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0.4600  0.2760  0.1840  0.5518  0.6452  0.3227\n\\end{pmatrix}\n}\n$$", "id": "3677167"}, {"introduction": "SMT 与内存系统的交互方式，尤其是与“伪共享”（false sharing）等缓存一致性概念的关联，常常是学习中的一个困惑点。在单个核心上运行的两个线程，如果它们写入内存中相邻的位置，是否会像两个独立的物理核心那样引发严重的伪共享惩罚？本练习旨在澄清这一关键区别 [@problem_id:3641063]。它构建了一个看似典型的伪共享场景，但引导您认识到，对于共享同一个 L1 缓存的同级 SMT 线程而言，性能瓶颈是核内资源的竞争（如存储端口），而非核间缓存一致性流量。", "problem": "考虑一个支持同步多线程（SMT）的单一物理处理器核心，该核心拥有2个逻辑线程，一个在逻辑线程之间共享的一级数据缓存（L1D），以及一个修改-独占-共享-无效（MESI）缓存一致性协议。假设以下经过充分验证的事实和定义为基本前提：\n\n- 缓存行是一致性的单位，MESI协议按缓存行而非按线程跟踪状态。只有当多个物理核心以冲突的方式访问同一缓存行时，才需要进行一致性失效处理；同一物理核心上的逻辑线程共享相同的私有一级数据缓存内容。\n- 该核心使用写回（write-back）、写分配（write-allocate）策略。对已存在于L1D中且可写的数据的存储操作会在该缓存中命中，并且不会立即传播到更低级别的缓存。\n- 该核心有一个通向L1D的存储数据执行端口，在稳态下每周期最多能退役（retire）1个对齐的$w$字节存储操作。设每次存储的大小$w = 8$字节。\n- L1D缓存行大小为$\\ell = 64$字节。\n- 核心频率为$f = 3.0 \\times 10^{9}$周期/秒。\n\n两个兄弟逻辑线程（线程0和线程1）在同一个物理核心上执行。每个线程无限循环，对其自己的内存位置执行存储操作，不进行读取、内存屏障或系统调用，且该内存区域不被任何其他物理核心或设备访问。考虑两种情况：\n\n- 情况S（相同行）：线程0和线程1各自重复地向位于同一个$\\ell$字节缓存行内的不同$8$字节字进行存储（例如，同一行内偏移量为$0$和$8$的位置）。每个线程在每次迭代中都存储到相同的字，因此工作集保持为一个缓存行。\n- 情况D（不同行）：线程0和线程1各自重复地向位于不同缓存行中的不同$8$字节字进行存储。每个线程的工作集保持为一个缓存行，且这两个缓存行是不同的。\n\n在任何初始行分配后的稳态下，根据上述资源和一致性约束，预测情况S与情况D下两个线程的总持续存储吞吐量$T$。选择最佳选项。\n\nA. $T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx f \\times w = 3.0 \\times 10^{9} \\times 8 \\approx 24 \\,\\text{千兆字节/秒}$，因为两种情况都是在单个核心上的L1D存储命中，没有一致性失效，并且SMT线程共享同一个存储数据端口。\n\nB. $T_{\\mathrm{S}} \\ll T_{\\mathrm{D}}$（例如，$T_{\\mathrm{S}}$低于$1 \\,\\text{千兆字节/秒}$），因为对同一缓存行中的不同字进行存储会引发兄弟线程之间的伪共享（false sharing），导致共享L1D上频繁的一致性失效和缓存行乒乓（ping-pong）。\n\nC. $T_{\\mathrm{D}}  T_{\\mathrm{S}}$，大约为2倍（例如，$T_{\\mathrm{D}} \\approx 48 \\,\\text{千兆字节/秒}$，$T_{\\mathrm{S}} \\approx 24 \\,\\text{千兆字节/秒}$），因为写入不同的行允许L1D并行使用多个写入端口或存储体（bank），而当两个线程都针对同一行时，这些资源不可用。\n\nD. $T_{\\mathrm{S}}  T_{\\mathrm{D}}$（例如，$T_{\\mathrm{S}} \\approx 30 \\,\\text{千兆字节/秒}$，$T_{\\mathrm{D}} \\approx 24 \\,\\text{千兆字节/秒}$），因为两个线程写入同一行可以实现跨线程的写合并（write-combining），从而有效地将每周期存储退役率提高到超出单端口限制。", "solution": "问题要求预测在两种不同的内存访问模式下，运行在单个支持SMT的物理核心上的两个逻辑线程的总持续存储吞吐量。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- 核心：单个支持同步多线程（SMT）的物理处理器核心。\n- 逻辑线程：2个（线程0，线程1）。\n- 一级数据缓存（L1D）：在两个逻辑线程之间共享。\n- 缓存一致性协议：修改-独占-共享-无效（MESI）。\n- 一致性范围：一致性失效发生在多个物理核心之间；同一核心上的逻辑线程共享L1D内容，无需此类失效处理。\n- 缓存策略：写回、写分配。\n- 执行资源：一个通向L1D的存储数据执行端口。\n- 存储端口吞吐量：在稳态下每周期最多退役1个对齐的$w$字节存储操作。\n- 存储大小：$w = 8$字节。\n- L1D缓存行大小：$\\ell = 64$字节。\n- 核心频率：$f = 3.0 \\times 10^{9}$周期/秒。\n- 情况S（相同行）：两个线程都向同一个$\\ell=64$字节缓存行内的不同8字节字进行存储。\n- 情况D（不同行）：两个线程向位于不同缓存行中的8字节字进行存储。\n- 场景约束：线程无限循环执行存储操作；内存区域不被其他核心访问；分析针对初始行分配后的稳态。\n\n**第二步：使用提取的已知条件进行验证**\n- **科学性**：该问题在现代计算机体系结构原理方面有很好的基础。它准确地描述了一种常见的配置：一个带有共享L1D缓存的SMT核心、一个特定的存储流水线限制和一个标准的一致性协议（MESI）。核心间一致性与核心内资源共享之间的区别是一个关键且陈述正确的概念。\n- **问题定义明确**：该问题定义明确。它提供了计算理论最大吞吐量所需的所有参数（$f, w$, 存储端口限制）。两种情况（情况S和情况D）定义清晰，允许进行比较分析。可以根据给定的条件推导出理论吞吐量的唯一稳定解。\n- **客观性**：问题以精确的技术语言和定量数据客观陈述，不含主观论断。\n- **完整性与一致性**：问题陈述是自包含且一致的。它提供了一个简化但连贯的处理器核心模型。“一个存储数据执行端口”的明确约束是主要瓶颈，提供的其他细节与此模型一致。\n\n**第三步：结论与行动**\n问题陈述有效。它提出了一个清晰、一致且科学合理的分析场景。我将继续进行解答。\n\n### 解题推导\n\n这个问题的核心在于识别所描述工作负载的主要性能瓶颈。问题指出，物理核心拥有**一个存储数据执行端口**，该端口每周期最多能退役**1个对齐的$w$字节存储操作**。\n\n由于两个逻辑线程（线程0和线程1）都在同一个物理核心上执行，它们必须共享这单个存储数据端口。同步多线程允许两个线程的指令同时存在于处理器的流水线中，但它们仍然必须竞争有限的物理执行资源。在这种情况下，关键的共享资源就是存储端口。\n\n因此，两个线程的总存储吞吐量$T$受限于这单个端口能够处理存储操作的最大速率。这个最大速率给定为每周期1次存储。\n\n以字节/秒为单位的吞吐量可以计算如下：\n$$T = (\\text{每周期存储次数}) \\times (\\text{每次存储的字节数}) \\times (\\text{每秒周期数})$$\n\n使用给定的值：\n- 每周期存储次数：1\n- 每次存储的字节数：$w = 8$字节\n- 每秒周期数：$f = 3.0 \\times 10^{9} \\text{ s}^{-1}$\n\n因此，理论上的最大总吞吐量为：\n$$T_{\\text{max}} = 1 \\frac{\\text{存储}}{\\text{周期}} \\times 8 \\frac{\\text{字节}}{\\text{存储}} \\times 3.0 \\times 10^{9} \\frac{\\text{周期}}{\\text{s}} = 24.0 \\times 10^{9} \\frac{\\text{字节}}{\\text{s}} = 24 \\text{ GB/s}$$\n\n现在我们必须分析情况S和情况D是否与此基准不同。\n\n**情况D（不同行）：**\n线程0存储到缓存行$L_A$中的一个位置，线程1存储到缓存行$L_B$中的一个位置，其中$L_A \\neq L_B$。在稳态下，两个存储操作都在共享的L1D缓存中命中。两个线程将发出存储指令，这些指令将被单个存储数据执行端口交错和串行化处理。总吞吐量将受此端口限制，因此我们预期$T_{\\mathrm{D}} \\approx T_{\\text{max}} = 24 \\text{ GB/s}$。\n\n**情况S（相同行）：**\n线程0和线程1存储到同一缓存行$L_C$内的不同字。在此，“伪共享”的分析至关重要。\n- 问题明确指出，“一致性失效仅在多个物理核心访问同一缓存行时才需要……同一物理核心上的逻辑线程共享相同的私有一级数据缓存内容。”\n- 这意味着MESI协议不会被调用来在兄弟线程之间使缓存行失效，因为它们访问的是*完全相同*的物理缓存和*完全相同*的缓存行副本。缓存行不会在不同缓存之间“乒乓”传送。伪共享现象——因*不同核心*之间的一致性流量导致的严重性能下降——在这里不适用。\n\n情况S中的争用纯粹是针对核心内部资源的。两个线程的存储操作都必须通过单个存储数据端口退役。从端口的角度来看，它接收一个存储请求流。这些请求针对同一缓存行（但不同的字）这一事实，并不会改变它每周期只能处理一个请求的基本约束。虽然可能存在像存储体冲突这样复杂的微体系结构效应，但问题中明确指出的主要限制是单个退役端口。因此，总吞吐量仍然受限于该端口的最大速率。我们预期$T_{\\mathrm{S}} \\approx T_{\\text{max}} = 24 \\text{ GB/s}$。\n\n**结论：**\n基于所提供的模型，单个存储数据端口是两种情况下的限制因素。核心间伪共享（inter-core false sharing）所特有的一致性失效争用并不存在。因此，两种情况下的总吞吐量应该大致相同。\n$$T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx 24 \\text{ GB/s}$$\n\n### 逐项分析选项\n\n**A. $T_{\\mathrm{S}} \\approx T_{\\mathrm{D}} \\approx f \\times w = 3.0 \\times 10^{9} \\times 8 \\approx 24 \\,\\text{千兆字节/秒}$，因为两种情况都是在单个核心上的L1D存储命中，没有一致性失效，并且SMT线程共享同一个存储数据端口。**\n该选项正确地指出了单个存储数据端口是SMT核心上两个线程的瓶颈。它正确地计算出由此产生的吞吐量为$f \\times w = (3.0 \\times 10^9) \\times 8 = 24 \\times 10^9$字节/秒，即$24$ GB/s。它还正确地指出没有一致性失效，排除了将“伪共享”概念错误地应用于单个核心上的兄弟线程的情况。其推理是合理的，并且与推导过程完全一致。\n**结论：正确**\n\n**B. $T_{\\mathrm{S}} \\ll T_{\\mathrm{D}}$（例如，$T_{\\mathrm{S}}$低于$1 \\,\\text{千兆字节/秒}$），因为对同一缓存行中的不同字进行存储会引发兄弟线程之间的伪共享（false sharing），导致共享L1D上频繁的一致性失效和缓存行乒乓（ping-pong）。**\n这个选项有根本性错误。它误解了“伪共享”。正如问题陈述中明确说明的，以及对于SMT体系结构的实际情况，同一核心上的兄弟线程共享L1D缓存。缓存行只有一个副本，因此它们之间不可能发生MESI级别的一致性失效或“乒乓”现象。该论点的基本前提是错误的。\n**结论：错误**\n\n**C. $T_{\\mathrm{D}}  T_{\\mathrm{S}}$，大约为2倍（例如，$T_{\\mathrm{D}} \\approx 48 \\,\\text{千兆字节/秒}$，$T_{\\mathrm{S}} \\approx 24 \\,\\text{千兆字节/秒}$），因为写入不同的行允许L1D并行使用多个写入端口或存储体（bank），而当两个线程都针对同一行时，这些资源不可用。**\n这个选项与问题的一个关键前提相矛盾。问题明确指出，核心拥有“一个存储数据执行端口”，能够“每周期最多退役1个对齐的$w$字节存储操作”。$48$ GB/s的吞吐量将需要每周期2次存储，这在给定的约束条件下是不可能的。存在多个写入端口的说法是问题陈述不支持的臆造。\n**结论：错误**\n\n**D. $T_{\\mathrm{S}}  T_{\\mathrm{D}}$（例如，$T_{\\mathrm{S}} \\approx 30 \\,\\text{千兆字节/秒}$，$T_{\\mathrm{D}} \\approx 24 \\,\\text{千兆字节/秒}$），因为两个线程写入同一行可以实现跨线程的写合并（write-combining），从而有效地将每周期存储退役率提高到超出单端口限制。**\n这个选项也是错误的。$30$ GB/s的吞吐量将需要每周期退役$30 / (8 \\times 3) = 1.25$次存储，这超出了单个存储端口每周期1次存储的硬性限制。虽然先进的微体系结构可能具有写合并等功能，但它们不能违反退役指令的执行单元的基本吞吐量限制。声称退役率可以“提高到超出单端口限制”与给定的约束条件相矛盾。\n**结论：错误**", "answer": "$$\\boxed{A}$$", "id": "3641063"}]}