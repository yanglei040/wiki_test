{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解源于实践。在设计任何中断驱动的系统时，首要任务是量化其性能边界。本练习将引导你解决一个核心的现实问题：在满足硬实时截止期限和长期 CPU 使用率预算的双重约束下，中断服务例程（ISR）可以执行多少计算工作。通过这个计算，你将学会如何在系统响应速度和整体效率之间做出权衡，这是嵌入式和实时系统设计中的一项基本技能。[@problem_id:3653028]", "problem": "一个微控制器为一个周期性传感器执行中断驱动的输入/输出。中央处理器 (CPU) 的时钟频率为 $100\\,\\mathrm{MHz}$。一个硬件定时器以 $1\\,\\mathrm{kHz}$ 的频率触发一个传感器采样的中断服务程序 (ISR)，使得两次中断之间的周期为 $1\\,\\mathrm{ms}$。系统施加了两个约束：\n- 长期 CPU 时间预算：在任何时间间隔内，传感器 ISR（包括其固定的进入/退出开销）最多只能消耗总 CPU 时间的 $B$ 部分。此处，$B = 0.18$。\n- 硬实时截止期限：每次 ISR 调用都必须在其 $1\\,\\mathrm{ms}$ 的周期结束前完成，即使在最坏情况下，系统中其他地方的中断被暂时禁用了长达 $120\\,\\mu\\mathrm{s}$。\n\n假设每次中断有 800 个时钟周期的固定开销，用于中断进入/退出以及必要的寄存器保存/恢复，这部分时间必须计入 ISR 的时间使用中。ISR 中所有剩余的时钟周期都可用于应用程序的传感器处理计算。\n\n仅从 CPU 利用率（某时间间隔内 CPU 时间的占比）、截止期限可行性（在最坏情况延迟下于周期结束前完成执行）以及时间与时钟周期通过 CPU 频率转换的关系这些核心定义出发，确定每次中断中，ISR 计算主体（不包括固定的 800 时钟周期开销）可以花费的最大时钟周期数 $C_{\\max}$，同时满足预算和截止期限两个约束。\n\n用时钟周期数表示每次中断允许的最终计算量 $C_{\\max}$。在你的答案中报告一个精确的整数时钟周期数。最终答案中不要包含任何单位。", "solution": "该问题要求找出中断服务程序 (ISR) 的最大计算时钟周期数，记为 $C_{\\max}$，该程序需要满足两个约束：长期 CPU 利用率预算和硬实时截止期限。我们首先形式化地定义系统参数和约束。\n\n给定的参数如下：\n- CPU 时钟频率：$f_{CPU} = 100\\,\\mathrm{MHz} = 100 \\times 10^6\\,\\mathrm{Hz}$\n- 中断频率：$f_{ISR} = 1\\,\\mathrm{kHz} = 1 \\times 10^3\\,\\mathrm{Hz}$\n- CPU 时间预算比例：$B = 0.18$\n- 最坏情况中断延迟：$T_{latency} = 120\\,\\mu\\mathrm{s} = 120 \\times 10^{-6}\\,\\mathrm{s}$\n- 固定 ISR 开销：$C_{overhead} = 800$ 个时钟周期\n\n根据中断频率，我们可以确定中断之间的周期：\n$$ T_{ISR} = \\frac{1}{f_{ISR}} = \\frac{1}{1 \\times 10^3\\,\\mathrm{Hz}} = 10^{-3}\\,\\mathrm{s} = 1\\,\\mathrm{ms} $$\n\n设 $C_{comp}$ 为 ISR 内可用于应用程序计算的时钟周期数。单次 ISR 调用消耗的总时钟周期数是开销和计算时钟周期数之和：\n$$ C_{total} = C_{overhead} + C_{comp} $$\n\n一次 ISR 调用的总执行时间与总时钟周期数通过 CPU 频率相关联：\n$$ T_{exec} = \\frac{C_{total}}{f_{CPU}} = \\frac{C_{overhead} + C_{comp}}{f_{CPU}} $$\n\n我们现在将分析这两个约束，以找出 $C_{comp}$ 的最大允许值。最终答案 $C_{\\max}$ 将是这两个限制中最严格的一个。\n\n约束1：长期 CPU 时间预算\nISR 的长期 CPU 利用率不得超过预算比例 $B$。CPU 利用率 $U$ 是 CPU 忙于执行 ISR 的时间所占的比例。在一个周期 $T_{ISR}$ 内，这是 ISR 的执行时间 $T_{exec}$ 与周期 $T_{ISR}$ 的比率。\n$$ U = \\frac{T_{exec}}{T_{ISR}} \\le B $$\n\n代入 $T_{exec}$ 和 $T_{ISR}$ 的表达式：\n$$ \\frac{\\left(\\frac{C_{overhead} + C_{comp}}{f_{CPU}}\\right)}{\\left(\\frac{1}{f_{ISR}}\\right)} \\le B $$\n$$ \\frac{(C_{overhead} + C_{comp}) \\cdot f_{ISR}}{f_{CPU}} \\le B $$\n\n我们求解这个不等式，以得到预算允许的最大 $C_{comp}$，我们称之为 $C_{comp, budget}$。\n$$ C_{overhead} + C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} $$\n$$ C_{comp, budget} \\le \\frac{B \\cdot f_{CPU}}{f_{ISR}} - C_{overhead} $$\n\n代入给定的数值：\n$$ C_{comp, budget} \\le \\frac{0.18 \\cdot (100 \\times 10^6\\,\\mathrm{Hz})}{1 \\times 10^3\\,\\mathrm{Hz}} - 800 $$\n$$ C_{comp, budget} \\le \\frac{18 \\times 10^6}{1 \\times 10^3} - 800 $$\n$$ C_{comp, budget} \\le 18000 - 800 $$\n$$ C_{comp, budget} \\le 17200\\,\\text{时钟周期} $$\n\n约束2：硬实时截止期限\n截止期限要求每次 ISR 调用在下一次中断发生之前完成，即在周期 $T_{ISR}$ 内完成。即使在最坏情况下，即 ISR 的开始被最大中断延迟 $T_{latency}$ 所推迟，这个要求也必须成立。\n\n从 ISR 实际开始执行的时刻算起，可供其执行的时间是周期时长减去延迟时间：\n$$ T_{available} = T_{ISR} - T_{latency} $$\n\nISR 的总执行时间 $T_{exec}$ 必须小于或等于这个可用时间：\n$$ T_{exec} \\le T_{available} $$\n$$ \\frac{C_{overhead} + C_{comp}}{f_{CPU}} \\le T_{ISR} - T_{latency} $$\n\n我们求解这个不等式，以得到截止期限允许的最大 $C_{comp}$，我们称之为 $C_{comp, deadline}$。\n$$ C_{overhead} + C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} $$\n$$ C_{comp, deadline} \\le (T_{ISR} - T_{latency}) \\cdot f_{CPU} - C_{overhead} $$\n\n代入给定的数值：\n$$ T_{ISR} - T_{latency} = (1 \\times 10^{-3}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = (1000 \\times 10^{-6}\\,\\mathrm{s}) - (120 \\times 10^{-6}\\,\\mathrm{s}) = 880 \\times 10^{-6}\\,\\mathrm{s} $$\n现在，我们可以计算出时钟周期的限制：\n$$ C_{comp, deadline} \\le (880 \\times 10^{-6}\\,\\mathrm{s}) \\cdot (100 \\times 10^6\\,\\mathrm{Hz}) - 800 $$\n$$ C_{comp, deadline} \\le (880 \\times 100) - 800 $$\n$$ C_{comp, deadline} \\le 88000 - 800 $$\n$$ C_{comp, deadline} \\le 87200\\,\\text{时钟周期} $$\n\n最终确定\n计算时钟周期数 $C_{comp}$ 必须同时满足两个约束。因此，最大允许时钟周期数 $C_{\\max}$ 是从每个约束导出的限制中的最小值。\n$$ C_{\\max} = \\min(C_{comp, budget}, C_{comp, deadline}) $$\n$$ C_{\\max} = \\min(17200, 87200) $$\n$$ C_{\\max} = 17200 $$\n\n因此，在满足预算和截止期限两个约束的前提下，ISR 计算主体中可以花费的最大时钟周期数是 $17200$。在此系统中，预算约束是更具限制性的约束。", "answer": "$$\\boxed{17200}$$", "id": "3653028"}, {"introduction": "在确保 ISR 足够快之后，我们必须保证它的行为是正确的，尤其是在与复杂的硬件交互时。这个实践聚焦于设计一个健壮的 ISR，以处理带有副作用的内存映射 I/O（MMIO）和电平触发中断，这些都是现实世界设备驱动程序中常见的挑战。你的任务是设计一个能够保证“精确一次”处理每个设备事件的 ISR，避免因时序问题、重入或不当的内存操作顺序而导致的数据丢失或重复。[@problem_id:3653019]", "problem": "一个计算机系统使用中断服务例程 (ISR) 调度来处理来自一个暴露了内存映射输入/输出 (MMIO) 寄存器的外设的事件。该外设实现了以下具有科学真实性行为的内存映射寄存器：\n\n- 一个位于地址 $A_D$ 的数据寄存器，每次 MMIO 读取时返回下一个事件的有效负载，并具有读取副作用：每次读取都会精确地消费一个事件，并将待处理计数 $N$ 减 1。如果 $N=0$，对 $A_D$ 的读取在架构上是未定义的，必须避免。\n- 一个位于地址 $A_S$ 的状态寄存器，其位 $RDY$ 被设置当且仅当 $N>0$；读取 $A_S$ 没有副作用。\n- 一个位于地址 $A_M$ 的中断屏蔽寄存器，向其写入值 $1$ 会屏蔽设备的中断，写入值 $0$ 则会取消屏蔽。\n- 一个位于地址 $A_E$ 的中断结束寄存器，向其写入值 $1$ 会向中断控制器发送中断结束 (EOI) 信号。\n\n当 $RDY=1$ 时，设备会触发一条电平触发中断线。中央处理器 (CPU) 运行一个单生产者/单消费者驱动程序，其中 ISR 是生产者，将有效负载入队到一个带有头指针索引 $h$ 和尾指针索引 $t$ 的环形缓冲区 $Q$ 中，而一个用户线程是消费者。发布步骤定义为将有效负载写入 $Q[h]$，随后是对 $h$ 进行的具有释放语义的原子增量操作。\n\n该架构的内存模型是松散的：在没有显式屏障的情况下，普通内存操作和MMIO 操作可能会被重排序。存在一个屏障 $B()$，它能保证所有之前的 MMIO 读取在任何后续的普通内存存储对其他核心或线程可见之前完成。对 $h$ 的原子增量操作对普通内存具有释放语义，但在没有显式 $B()$ 的情况下，并不意味着相对于 MMIO 的排序。\n\n精确一次消费被定义为设备事件与软件入队操作之间随时间的一一映射：对于在时间 $t$ 对 $N$ 贡献了 $+1$ 的每一个设备事件，ISR 最终会将一个且仅一个对应的有效负载入队到 $Q$ 中并发布一次，没有重复也没有丢失，即使在 ISR 执行期间有事件到达。\n\n您需要从关于中断、MMIO、读取副作用、电平触发和内存排序的第一性原理出发进行推理。请考虑以下以有序步骤表示的候选 ISR，并选择能保证精确一次消费且避免竞争、可重入性风险和排序违规的设计。\n\n选项 A:\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 当 $\\text{mmio\\_read}(A_S)$ 指示 $RDY=1$ 时循环：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 调用 $B()$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子地增加 $h$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n选项 B:\n- 立即向 $A_E$ 写入 $1$ 以发送 EOI。\n- 不屏蔽设备；当 $\\text{mmio\\_read}(A_S)$ 指示 $RDY=1$ 时循环：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子地增加 $h$。\n  - 调用 $B()$。\n- 在整个过程中保持设备不被屏蔽。\n\n选项 C:\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 读取 $\\text{mmio\\_read}(A_S)$ 一次；如果 $RDY=1$：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子地增加 $h$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n选项 D:\n- 向 $A_M$ 写入 $1$ 以屏蔽设备中断。\n- 从 $\\text{mmio\\_read}(A_S)$ 读取一个就绪计数的近似值 $c$（假设 $c$ 反映了那一刻待处理事件的数量）。\n- 对于从 $1$ 到 $c$ 的 $i$：\n  - 令 $d \\leftarrow \\text{mmio\\_read}(A_D)$。\n  - 将 $d$ 写入 $Q[h]$。\n  - 以释放语义原子地增加 $h$。\n- 在循环后调用一次 $B()$。\n- 向 $A_E$ 写入 $1$ 以发送 EOI。\n- 向 $A_M$ 写入 $0$ 以取消屏蔽设备中断。\n\n在所述假设下，哪个选项能确保精确一次消费并防止竞争和排序违规？请选择唯一的最佳答案。\n\nA. 选项 A\nB. 选项 B\nC. 选项 C\nD. 选项 D", "solution": "本题要求为一种具有特殊行为（MMIO读取副作用、电平触发中断、松散内存模型）的外设设计一个正确且健壮的中断服务例程（ISR）。核心目标是确保“精确一次”消费每个设备事件，同时避免中断风暴、数据竞争和内存排序错误。\n\n我们从第一性原理分析每个选项：\n\n*   **电平触发中断的行为**：只要中断条件（本例中为 $RDY=1$）为真，中断信号就保持有效。如果ISR在清除该条件之前就向中断控制器发送了“中断结束”（EOI）信号，控制器会立即重新触发中断，导致“中断风暴”。因此，一个正确的ISR必须在发送EOI之前，处理掉所有待处理的事件，直到中断条件（$RDY$）变为假。\n*   **重入（Reentrancy）问题**：如果ISR在执行期间被自身的另一次调用所抢占（例如，在EOI之后，中断条件再次满足），就可能发生数据竞争。防止这种特定于设备的重入的标准方法是在ISR的开头屏蔽来自该设备的中断，并在ISR完全结束时再取消屏蔽。\n*   **MMIO读取副作用**：$\\text{mmio\\_read}(A_D)$ 会消耗一个事件。因此，在没有事件（$N=0$）时读取是致命错误。ISR必须总是在读取数据寄存器$A_D$之前，先检查状态寄存器$A_S$以确认$RDY=1$。\n*   **内存排序**：在松散内存模型下，MMIO操作和普通内存操作的顺序是不保证的。消费者线程可能在看到生产者ISR写入队列的数据之前，就看到了更新后的头指针$h$。为了防止这种情况，必须在MMIO读取（获取数据）和普通内存写入（将数据放入队列）之间放置一个内存屏障$B()$。这个屏障确保了设备的数据在对消费者可见之前已经被CPU完全读取。\n\n现在我们来评估每个选项：\n\n**A. 选项 A**：\n1.  **屏蔽中断** (`向 $A_M$ 写入 $1$`)：正确。这能有效防止ISR被自身重入，避免了竞争条件。\n2.  **循环处理** (`当 $\\text{mmio\\_read}(A_S)$ 指示 $RDY=1$ 时循环`)：正确。这个循环确保了在ISR退出前，所有待处理的事件都被消耗掉，从而清除了电平触发中断的条件。这能防止中断风暴。\n3.  **屏障位置** (`调用 $B()$`)：正确。屏障位于MMIO读取`$\\text{mmio\\_read}(A_D)$`之后和普通内存写入`将 $d$ 写入 $Q[h]$`之前，这保证了MMIO读取操作在队列写入对消费者可见之前完成，解决了内存排序问题。\n4.  **EOI 和取消屏蔽**：正确。EOI在中断条件被完全清除后发送，取消屏蔽则在最后进行。\n此选项正确地处理了所有关键问题：电平触发、重入、副作用和内存排序。\n\n**B. 选项 B**：\n1.  **立即发送 EOI**：错误。对于电平触发中断，如果此时仍有事件待处理（$RDY=1$），这会立即导致中断风暴。\n2.  **不屏蔽中断**：错误。这使得ISR容易受到重入的影响，如果一个事件在处理另一个事件期间到达，可能会导致数据竞争或逻辑错误。\n3.  **屏障位置**：错误。屏障$B()$在发布步骤（原子增加$h$）之后被调用，无法保证MMIO读取在普通内存写入之前完成。\n此选项在多个方面都存在根本性缺陷。\n\n**C. 选项 C**：\n1.  **仅处理一次** (`读取 $\\text{mmio\\_read}(A_S)$ 一次`)：错误。此设计只处理一个事件。如果在ISR执行期间，设备又产生了一个新事件，那么当ISR发送EOI时，$RDY$位仍然为1，这将导致中断风暴。它没有完全清除电平触发的条件。\n此选项未能正确处理电平触发中断的“清场”要求。\n\n**D. 选项 D**：\n1.  **读取计数值 $c$**：错误。这是一个典型的竞争条件。在读取计数值$c$和循环处理$c$个事件之间，可能有新的事件到达。这意味着ISR结束时可能仍有事件待处理（$RDY=1$），导致中断風暴。反之，如果事件被其他方式消耗，读取$c$个事件可能导致读取一个空的FIFO，行为未定义。\n2.  **单个屏障**：在循环后调用一次$B()$在理论上是可行的（批处理屏障），但这并不能弥补其逻辑上的根本缺陷。\n此选项的逻辑是不可靠的，并且容易受到时序变化的影响。\n\n综上所述，只有选项A提供了一个完全正确和健壮的实现，能够确保在所有给定约束下实现“精确一次”的事件消费。", "answer": "$$\\boxed{A}$$", "id": "3653019"}, {"introduction": "一个专业的设计不仅要考虑正常运行，还必须为异常情况做好准备。本练习将带你进入系统可靠性设计的领域，探讨如何使用看门狗定时器（WDT）来防止 ISR 锁死等致命故障。你将学习如何通过严谨的时序分析，计算出一个安全的看门狗超时时间，以避免在正常操作下发生误报，同时设计一个安全有效的恢复策略，从而在不导致整个系统崩溃的情况下恢复正常运行。[@problem_id:3652973]", "problem": "一个嵌入式控制器使用中断驱动的输入/输出，其中一个硬件传感器产生周期性中断，这些中断由一个中断服务程序（ISR）来服务。一个看门狗定时器（WDT）必须被周期性地服务（“喂狗”）以表明系统处于活动状态；如果WDT在超时时间内未被服务，它会触发一个不可屏蔽事件。当前的设计在每次ISR成功执行结束时服务WDT。您需要选择一个WDT超时时间和一种安全的恢复路径，以在不产生误报的情况下捕获ISR锁定。\n\n在正常操作期间，该系统表现出以下经过充分测试的行为边界：\n- 传感器生成中断的标称周期为 $T_{irq} = 4.8\\,\\mathrm{ms}$，正向抖动最高可达 $\\Delta = 0.4\\,\\mathrm{ms}$，因此正常情况下的最长到达间隔为 $T_{irq}^{\\max} = T_{irq} + \\Delta$。\n- 在原子临界区期间，全局中断可能被屏蔽长达 $B = 12\\,\\mathrm{ms}$。\n- 中断解除屏蔽后，更高优先级的活动可能会使ISR调度延迟最多 $P = 3.0\\,\\mathrm{ms}$，并且调度器开销会增加 $S = 0.2\\,\\mathrm{ms}$。\n- ISR的最坏情况执行时间为 $W = 1.1\\,\\mathrm{ms}$。\n- 系统定时器的分辨率为 $R_t = 0.1\\,\\mathrm{ms}$，在推算时间间隔时应将其作为裕量包含在内。\n\n安全性和可用性要求规定，任何ISR锁定必须在 $T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$ 内被检测和处理，并且恢复过程必须避免完整的系统复位、使设备静默以防止进一步的数据损坏、保留诊断日志，并重新建立正常的中断驱动操作。假设看门狗定时器可以配置为在第一次超时时引发一个不可屏蔽中断（NMI），而不是立即执行系统复位。\n\n根据基本原理，WDT超时时间 $T_{wd}$ 必须严格大于在非故障条件下可能出现的连续两次WDT服务之间的最长间隔，并且小于或等于 $T_{\\text{detect}}^{\\max}$。哪个选项最符合这些约束？\n\nA. 设置 $T_{wd} = 8\\,\\mathrm{ms}$；超时后，立即复位整个系统。\n\nB. 设置 $T_{wd} = 15\\,\\mathrm{ms}$；超时后，仅重新启用全局中断并从故障处理程序返回以继续正常操作。\n\nC. 设置 $T_{wd} = 22\\,\\mathrm{ms}$；超时后，引发一个不可屏蔽中断（NMI），该中断调用一个故障处理程序，该程序记录故障、清空出站I/O队列、停止任何直接内存访问（DMA）引擎并将设备置于文档化的静默状态，仅对I/O子系统执行有针对性的软复位，重新安装并重新启用ISR，在恢复前发出内存屏障，然后返回正常操作。\n\nD. 设置 $T_{wd} = 30\\,\\mathrm{ms}$；超时后，屏蔽中断，忙等待设备清除其状态，然后解除中断屏蔽。", "solution": "用户要求我验证并解决一个关于为中断驱动的嵌入式系统选择看门狗定时器（WDT）超时时间和恢复策略的问题。\n\n### 问题验证\n\n首先，我必须仔细验证问题陈述。\n\n#### 步骤1：提取已知条件\n从问题陈述中逐字提取的数据：\n- **标称中断周期**：$T_{irq} = 4.8\\,\\mathrm{ms}$\n- **正向中断抖动**：$\\Delta = 0.4\\,\\mathrm{ms}$\n- **最长到达间隔时间**：$T_{irq}^{\\max} = T_{irq} + \\Delta$\n- **最大中断屏蔽时间**：$B = 12\\,\\mathrm{ms}$\n- **更高优先级任务造成的最大抢占延迟**：$P = 3.0\\,\\mathrm{ms}$\n- **调度器开销**：$S = 0.2\\,\\mathrm{ms}$\n- **ISR最坏情况执行时间**：$W = 1.1\\,\\mathrm{ms}$\n- **系统定时器分辨率（裕量）**：$R_t = 0.1\\,\\mathrm{ms}$\n- **允许的锁定检测最长时间**：$T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$\n- **WDT服务点**：在每次ISR成功执行结束时。\n- **WDT机制**：可配置为引发不可屏蔽中断（NMI）。\n- **恢复要求**：必须 (1) 避免完整系统复位，(2) 使设备静默，(3) 保留诊断日志，以及 (4) 重新建立正常操作。\n- **核心约束**：WDT超时时间 $T_{wd}$ 必须严格大于WDT服务之间的最长非故障间隔，并且小于或等于 $T_{\\text{detect}}^{\\max}$。\n\n#### 步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题基于实时系统分析的基本和标准原则，包括中断响应时间计算和看门狗定时器等容错机制。所有概念在计算机工程中都是标准的，并且内部一致。\n- **问题定义明确**：该问题定义明确。它提供了计算WDT服务之间最坏情况时间所需的所有定量数据。恢复路径的定性要求清晰具体，允许对选项进行客观评估。\n- **客观性**：语言精确、技术性强，没有主观性。\n\n该问题通过了所有验证检查。没有发现缺陷。这是一个嵌入式系统设计中的标准、可解决的问题。\n\n#### 步骤3：结论与行动\n问题是 **有效的**。我将继续推导解决方案。\n\n### 解决方案推导\n\n主要任务是确定WDT超时时间 $T_{wd}$ 的有效范围。该范围由一个下界和一个上界定义。\n\n1.  **$T_{wd}$ 的上界**：\n    问题陈述指出，任何ISR锁定必须在 $T_{\\text{detect}}^{\\max} = 25\\,\\mathrm{ms}$ 内被检测到。WDT超时是实现此检测的机制。因此，超时值必须小于或等于这个最大允许时间。\n    $$T_{wd} \\le 25\\,\\mathrm{ms}$$\n\n2.  **$T_{wd}$ 的下界**：\n    超时时间 $T_{wd}$ 必须严格大于在正常（非故障）条件下连续两次服务WDT之间的最大可能时间间隔。这可以防止误报，即尽管系统运行正常，WDT仍然触发。设这个最大间隔为 $T_{interval}^{\\max}$。\n\n    WDT在每次ISR完成时被服务。我们需要找到一个ISR（例如 $ISR_n$）的完成与下一个ISR（$ISR_{n+1}$）的完成之间的最大可能时间。设 $A_k$ 是中断 $IRQ_k$ 的到达时间， $C_k$ 是 $ISR_k$ 的完成时间。该间隔为 $C_{n+1} - C_n$。\n\n    为了最大化这个间隔，我们构建一个最坏情况的场景：\n    $$T_{interval}^{\\max} = (A_{n+1} - A_n)_{\\max} + (C_{n+1} - A_{n+1})_{\\max} - (C_n - A_n)_{\\min}$$\n\n    让我们计算每一项：\n    - **最大到达间隔时间**：问题明确定义了此值为 $T_{irq}^{\\max} = T_{irq} + \\Delta$。\n      $$T_{irq}^{\\max} = 4.8\\,\\mathrm{ms} + 0.4\\,\\mathrm{ms} = 5.2\\,\\mathrm{ms}$$\n    - **最大ISR响应时间 ($T_{resp}^{\\max}$)**：这是最大调度延迟和最坏情况执行时间的总和。最大延迟发生在中断被屏蔽最长时间（$B$），然后被更高优先级任务延迟（$P$），再加上调度器开销（$S$）。\n      $$T_{resp}^{\\max} = B + P + S + W$$\n      $$T_{resp}^{\\max} = 12\\,\\mathrm{ms} + 3.0\\,\\mathrm{ms} + 0.2\\,\\mathrm{ms} + 1.1\\,\\mathrm{ms} = 16.3\\,\\mathrm{ms}$$\n    - **最小ISR响应时间 ($T_{resp}^{\\min}$)**：这发生在最小延迟（仅调度器开销 $S$）和最小执行时间的情况下。对此分析，一个标准且安全的假设是它可忽略不计 ($W_{\\min} \\approx 0$)，只考虑固定开销。\n      $$T_{resp}^{\\min} = S + W_{\\min} \\approx 0.2\\,\\mathrm{ms} + 0\\,\\mathrm{ms} = 0.2\\,\\mathrm{ms}$$\n\n    现在，我们计算WDT服务之间的最大间隔：\n    $$T_{interval}^{\\max} = T_{irq}^{\\max} + T_{resp}^{\\max} - T_{resp}^{\\min}$$\n    $$T_{interval}^{\\max} = 5.2\\,\\mathrm{ms} + 16.3\\,\\mathrm{ms} - 0.2\\,\\mathrm{ms} = 21.3\\,\\mathrm{ms}$$\n\n    最后，我们必须将定时器分辨率裕量 $R_t = 0.1\\,\\mathrm{ms}$ 加到这个值上，以为量化误差创造一个安全边际。WDT超时时间必须严格大于这个结果。\n    $$T_{wd} > T_{interval}^{\\max} + R_t = 21.3\\,\\mathrm{ms} + 0.1\\,\\mathrm{ms} = 21.4\\,\\mathrm{ms}$$\n\n3.  **$T_{wd}$ 的有效范围**：\n    结合下界和上界，我们得到：\n    $$21.4\\,\\mathrm{ms}  T_{wd} \\le 25\\,\\mathrm{ms}$$\n\n### 逐项分析\n\n现在我将根据推导出的超时范围和问题的恢复要求来评估每个选项。\n\n**A. 设置 $T_{wd} = 8\\,\\mathrm{ms}$；超时后，立即复位整个系统。**\n- **超时值**：$T_{wd} = 8\\,\\mathrm{ms}$。这不在有效范围 $(21.4\\,\\mathrm{ms}, 25\\,\\mathrm{ms}]$ 内。$8\\,\\mathrm{ms}$ 的超时时间远短于 $21.4\\,\\mathrm{ms}$ 的最大正常间隔，这保证会产生虚假的WDT事件和系统不稳定。\n- **恢复路径**：完整的系统复位违反了“避免完整系统复位”的明确要求。\n- **结论**：**不正确**。\n\n**B. 设置 $T_{wd} = 15\\,\\mathrm{ms}$；超时后，仅重新启用全局中断并从故障处理程序返回以继续正常操作。**\n- **超时值**：$T_{wd} = 15\\,\\mathrm{ms}$。这不在有效范围 $(21.4\\,\\mathrm{ms}, 25\\,\\mathrm{ms}]$ 内。这个超时时间太短，会导致误报。\n- **恢复路径**：此路径根本上是不安全的。如果ISR真的被锁定（例如，在一个无限循环中），从NMI处理程序返回将会恢复被锁定的ISR，导致WDT立即再次触发。它没有解决根本问题。\n- **结论**：**不正确**。\n\n**C. 设置 $T_{wd} = 22\\,\\mathrm{ms}$；超时后，引发一个不可屏蔽中断（NMI），该中断调用一个故障处理程序，该程序记录故障、清空出站I/O队列、停止任何直接内存访问（DMA）引擎并将设备置于文档化的静默状态，仅对I/O子系统执行有针对性的软复位，重新安装并重新启用ISR，在恢复前发出内存屏障，然后返回正常操作。**\n- **超时值**：$T_{wd} = 22\\,\\mathrm{ms}$。该值满足推导出的约束 $21.4\\,\\mathrm{ms}  22\\,\\mathrm{ms} \\le 25\\,\\mathrm{ms}$。这是一个安全且有效的超时时间。\n- **恢复路径**：此路径是恢复要求的一个全面且稳健的实现。它正确地记录诊断信息（“保留诊断日志”），将I/O带到安全状态（“使设备静默”），避免了灾难性故障（“避免完整系统复位”），并正确地采取步骤恢复功能（“重新建立正常……操作”）。此恢复策略的所有方面都是合理的，并符合容错嵌入式系统的最佳实践。\n- **结论**：**正确**。\n\n**D. 设置 $T_{wd} = 30\\,\\mathrm{ms}$；超时后，屏蔽中断，忙等待设备清除其状态，然后解除中断屏蔽。**\n- **超时值**：$T_{wd} = 30\\,\\mathrm{ms}$。这违反了上界要求 $T_{wd} \\le 25\\,\\mathrm{ms}$。系统将无法满足其指定的故障最大检测时间。\n- **恢复路径**：此路径考虑不周。在一个高优先级的NMI处理程序中屏蔽中断并进入忙等待，很可能会冻结整个系统，从而阻止任何恢复的机会。这是安全恢复路径的对立面。\n- **结论**：**不正确**。", "answer": "$$\\boxed{C}$$", "id": "3652973"}]}