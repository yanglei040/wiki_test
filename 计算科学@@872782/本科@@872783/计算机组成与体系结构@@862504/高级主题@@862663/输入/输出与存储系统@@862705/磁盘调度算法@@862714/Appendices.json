{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本次练习将带你初步探索不同磁盘调度算法的核心机制，重点关注它们如何影响磁头移动的总距离。通过在一个简化的场景中手动推演 FCFS、SSTF、SCAN 和 LOOK 算法的执行过程 [@problem_id:3635792]，你将直观地理解它们各自的决策逻辑和效率差异，并学会分析请求队列的构成如何决定最佳算法的选择。", "problem": "考虑一个单旋转磁盘，其磁道由整数 $0$ 到 $9$（含）索引。磁头初始位于磁道 $H=5$ 处，并向磁道号增加的方向移动。一批输入/输出请求到达，并按先到先服务（First-Come, First-Served）的顺序排队，形成有限序列 $Q=\\langle 3,4,7,9\\rangle$。假设采用寻道时间成本模型，其中总磁头移动量是连续服务的请求之间磁道索引的绝对差之和（包括从初始位置 $H$ 到第一个服务请求的移动），并且一旦给定批次中的所有请求都已服务，处理即终止。\n\n使用以下基于磁头移动模型的算法定义：\n- 先到先服务 (FCFS): 严格按照请求的到达顺序 $Q$ 进行服务。\n- 最短寻道时间优先 (SSTF): 在每一步中，选择其磁道索引与当前磁头位置最接近（绝对差最小）的待处理请求，若距离相同则选择磁道号较小的请求。\n- 扫描 (SCAN) 算法（电梯算法）: 磁头沿当前方向继续移动至该方向的最远端磁道（此处为 $9$），途中服务遇到的任何请求，然后反转方向并继续移向相反的最远端磁道（此处为 $0$），途中服务遇到的任何剩余请求。\n- LOOK 算法: 与 SCAN 类似，但磁头在当前方向上只移动到最远的未完成请求处便反转方向，而不会在没有请求的情况下继续移动到最远端磁道。\n\n任务：\n1. 从 $H=5$ 开始，对每个算法 (FCFS, SSTF, SCAN, LOOK)，确定服务队列 $Q=\\langle 3,4,7,9\\rangle$ 的确切服务顺序，并计算相应的总磁头移动量（以磁道数表示）。仅根据上述定义和寻道时间成本模型，提供服务序列和总磁头移动量。\n2. 现在，在到达序列的末尾追加一个位于整数磁道 $x$ 的额外请求，得到 $Q'=\\langle 3,4,7,9,x\\rangle$，其中 $x\\in\\{0,1,\\ldots,9\\}\\setminus\\{3,4,7,9\\}$。使用相同的初始磁头位置 $H=5$ 和初始方向，确定最小的数值 $x$，使得当调度 $Q'$ 时，SCAN 和 LOOK 产生的总磁头移动量都严格小于 FCFS 和 SSTF。报告这个最小的 $x$ 作为你的最终答案。所有磁头移动量都应以磁道数表示。无需四舍五入。", "solution": "该问题提出了一个经典的磁盘调度场景，并分为两部分。第一部分要求计算给定请求队列下四种标准算法 (FCFS, SSTF, SCAN, LOOK) 的总磁头移动量。第二部分要求找出要追加到队列中的最小整数磁道请求 $x$，使得 SCAN 和 LOOK 算法在总磁头移动量方面严格优于 FCFS 和 SSTF。\n\n该问题定义明确。磁盘参数（磁道 $0$ 到 $9$）、初始磁头位置（$H=5$）、初始磁头方向（增加）、请求队列（$Q=\\langle 3,4,7,9\\rangle$）和成本模型（总寻道距离）都已清楚定义。这些算法由其标准定义描述，包括 SSTF 的平局打破规则。未知请求 $x$ 的定义域明确指定为 $x\\in\\{0,1,\\ldots,9\\}\\setminus\\{3,4,7,9\\}$。\n\n### 第 1 部分：使用队列 $Q = \\langle 3, 4, 7, 9 \\rangle$ 进行分析\n\n初始状态为磁头在磁道 $H=5$，向磁道号增加的方向移动。请求集为 $\\{3, 4, 7, 9\\}$。\n\n**1. 先到先服务 (FCFS)**\n请求按其在队列中出现的顺序进行服务：$\\langle 3, 4, 7, 9 \\rangle$。\n磁头沿路径 $5 \\to 3 \\to 4 \\to 7 \\to 9$ 移动。\n总磁头移动量是绝对差之和：\n$$ M_{FCFS} = |3-5| + |4-3| + |7-4| + |9-7| = 2 + 1 + 3 + 2 = 8 $$\n服务顺序为 $\\langle 3, 4, 7, 9 \\rangle$，总移动量为 $8$ 个磁道。\n\n**2. 最短寻道时间优先 (SSTF)**\n在每一步中，服务与当前磁头位置最近的请求。\n- 初始位置：$H=5$。请求：$\\{3, 4, 7, 9\\}$。距离：$|3-5|=2$, $|4-5|=1$, $|7-5|=2$, $|9-5|=4$。最近的是磁道 $4$。\n- 当前位置：$4$。剩余请求：$\\{3, 7, 9\\}$。距离：$|3-4|=1$, $|7-4|=3$, $|9-4|=5$。最近的是磁道 $3$。\n- 当前位置：$3$。剩余请求：$\\{7, 9\\}$。距离：$|7-3|=4$, $|9-3|=6$。最近的是磁道 $7$。\n- 当前位置：$7$。剩余请求：$\\{9\\}$。服务磁道 $9$。\n服务顺序为 $\\langle 4, 3, 7, 9 \\rangle$。磁头沿路径 $5 \\to 4 \\to 3 \\to 7 \\to 9$ 移动。\n总磁头移动量为：\n$$ M_{SSTF} = |4-5| + |3-4| + |7-3| + |9-7| = 1 + 1 + 4 + 2 = 8 $$\n服务顺序为 $\\langle 4, 3, 7, 9 \\rangle$，总移动量为 $8$ 个磁道。\n\n**3. 扫描 (SCAN) 算法（电梯算法）**\n磁头从 $H=5$ 开始，沿增加方向向最远端磁道 $9$ 移动。途中服务遇到的请求。\n- 向磁道 $9$ 移动：服务请求 $7$ 和 $9$。\n- 在磁道 $9$ 处，磁头反转方向，向另一最远端磁道 $0$ 移动。途中服务剩余的请求。\n- 向磁道 $0$ 移动：服务请求 $4$ 和 $3$。\n服务顺序为 $\\langle 7, 9, 4, 3 \\rangle$。磁头沿路径 $5 \\to 7 \\to 9 \\to 4 \\to 3$ 移动。\n总磁头移动量为：\n$$ M_{SCAN} = |7-5| + |9-7| + |4-9| + |3-4| = 2 + 2 + 5 + 1 = 10 $$\n服务顺序为 $\\langle 7, 9, 4, 3 \\rangle$，总移动量为 $10$ 个磁道。\n\n**4. LOOK 算法**\n此算法与 SCAN 类似，但磁头在每个方向上只移动到最后一个请求所在的位置。\n- 初始方向为增加。此方向上最远的请求在磁道 $9$。磁头从 $5$ 移动到 $9$，服务 $7$ 和 $9$。\n- 在磁道 $9$ 处，磁头反转。剩余请求中最远的在磁道 $3$。磁头从 $9$ 移动到 $3$，服务 $4$ 和 $3$。\n对于这个特定的队列，最外层的请求（$9$）也是最远端的磁道，所以 LOOK 的行为与 SCAN 完全相同。\n服务顺序为 $\\langle 7, 9, 4, 3 \\rangle$。磁头路径为 $5 \\to 7 \\to 9 \\to 4 \\to 3$。\n总磁头移动量为：\n$$ M_{LOOK} = |7-5| + |9-7| + |4-9| + |3-4| = 2 + 2 + 5 + 1 = 10 $$\n服务顺序为 $\\langle 7, 9, 4, 3 \\rangle$，总移动量为 $10$ 个磁道。\n\n### 第 2 部分：寻找 $x$ 的最小值\n\n我们得到一个新队列 $Q'=\\langle 3,4,7,9,x\\rangle$，其中 $x \\in \\{0,1,2,5,6,8\\}$。我们必须找到最小的 $x$，使得 SCAN 和 LOOK 的总磁头移动量（分别表示为 $M_{SCAN}(x)$ 和 $M_{LOOK}(x)$）都严格小于 FCFS 和 SSTF 的移动量（分别表示为 $M_{FCFS}(x)$ 和 $M_{SSTF}(x)$）。条件是：\n1. $M_{SCAN}(x)  M_{FCFS}(x)$\n2. $M_{SCAN}(x)  M_{SSTF}(x)$\n3. $M_{LOOK}(x)  M_{FCFS}(x)$\n4. $M_{LOOK}(x)  M_{SSTF}(x)$\n\n我们按升序测试 $x$ 的可能值，从最小的 $x=0$ 开始。\n\n**对 $x=0$ 的分析**\n请求集变为 $\\{0, 3, 4, 7, 9\\}$。初始状态保持为 $H=5$，向增加方向移动。\n\n**1. FCFS, $x=0$**\n服务顺序为 $\\langle 3, 4, 7, 9, 0 \\rangle$。磁头沿路径 $5 \\to 3 \\to 4 \\to 7 \\to 9 \\to 0$ 移动。\n$$ M_{FCFS}(0) = |3-5| + |4-3| + |7-4| + |9-7| + |0-9| = 2 + 1 + 3 + 2 + 9 = 17 $$\n\n**2. SSTF, $x=0$**\n请求集为 $\\{0, 3, 4, 7, 9\\}$。\n- 从 $H=5$ 开始：最近的请求是 $4$（距离 $1$）。移动 $5 \\to 4$。\n- 在 $4$ 处：剩余 $\\{0, 3, 7, 9\\}$。最近的是 $3$（距离 $1$）。移动 $4 \\to 3$。\n- 在 $3$ 处：剩余 $\\{0, 7, 9\\}$。最近的是 $0$（距离 $3$）。移动 $3 \\to 0$。\n- 在 $0$ 处：剩余 $\\{7, 9\\}$。最近的是 $7$（距离 $7$）。移动 $0 \\to 7$。\n- 在 $7$ 处：剩余 $\\{9\\}$。服务 $9$。移动 $7 \\to 9$。\n路径为 $5 \\to 4 \\to 3 \\to 0 \\to 7 \\to 9$。\n$$ M_{SSTF}(0) = |4-5| + |3-4| + |0-3| + |7-0| + |9-7| = 1 + 1 + 3 + 7 + 2 = 14 $$\n\n**3. SCAN, $x=0$**\n磁头从 $H=5$ 向磁道 $9$ 移动，服务 $7$ 和 $9$。然后在磁道 $9$ 处反转，向磁道 $0$ 移动，服务 $4, 3, 0$。\n路径为 $5 \\to 7 \\to 9 \\to 4 \\to 3 \\to 0$。\n$$ M_{SCAN}(0) = |7-5| + |9-7| + |4-9| + |3-4| + |0-3| = 2 + 2 + 5 + 1 + 3 = 13 $$\n\n**4. LOOK, $x=0$**\n磁头从 $H=5$ 向增加方向上最远的请求（即 $9$）移动。它服务 $7$ 和 $9$。在 $9$ 处，它反转方向。剩余请求中最远的是 $0$。磁头向 $0$ 移动，服务 $4, 3, 0$。对于此请求集，其路径和行为与 SCAN 完全相同。\n$$ M_{LOOK}(0) = 13 $$\n\n**对 $x=0$ 的验证**\n我们用计算出的移动量来检查条件：\n- $M_{FCFS}(0) = 17$\n- $M_{SSTF}(0) = 14$\n- $M_{SCAN}(0) = 13$\n- $M_{LOOK}(0) = 13$\n\n1. $M_{SCAN}(0)  M_{FCFS}(0)$ 是否成立？$13  17$。成立。\n2. $M_{SCAN}(0)  M_{SSTF}(0)$ 是否成立？$13  14$。成立。\n3. $M_{LOOK}(0)  M_{FCFS}(0)$ 是否成立？$13  17$。成立。\n4. $M_{LOOK}(0)  M_{SSTF}(0)$ 是否成立？$13  14$。成立。\n\n对于 $x=0$，所有四个条件都满足。由于 $x=0$ 是 $x$ 的可能选择集合中的最小值，因此它是满足问题要求的最小数值。无需进一步研究更大的 $x$ 值。", "answer": "$$ \\boxed{0} $$", "id": "3635792"}, {"introduction": "在掌握了基本原理后，我们来挑战一个更贴近现实的综合性问题。这次练习不再局限于磁头移动距离，而是引入了包含寻道时间、旋转延迟和传输时间在内的完整服务时间模型，要求你计算六种主流算法的平均响应时间 [@problem_id:3635884]。通过对 FCFS、SSTF、SCAN、LOOK 及其循环变体 C-SCAN 和 C-LOOK 进行细致的性能评估，你将更深刻地理解这些算法在吞吐量和公平性之间的权衡，并能定量分析它们的表现。", "problem": "一个磁盘有从 $0$ 到 $199$ 编号的磁道。磁盘磁头在时间 $t=0$ 时从 $75$ 号磁道开始，初始扫描方向为磁道号增加的方向。在 $t=0$ 时刻，有八个读取请求同时到达，其磁道号按提交给操作系统的顺序列出如下：$40$, $150$, $10$, $90$, $15$, $180$, $60$, $20$。考虑六种磁盘调度算法：先来先服务 (FCFS)、最短寻道时间优先 (SSTF)、扫描算法 (SCAN)、LOOK 算法、循环扫描算法 (C-SCAN) 和循环 LOOK 算法 (C-LOOK)。假设：\n- 所有请求都在 $t=0$ 时到达（因此响应时间等于完成时间）。\n- 寻道时间被线性地建模为 $t_{\\text{seek}}(d)=\\alpha+\\beta d$，其中 $d$ 是移动的绝对磁道距离，$\\alpha=0.2\\,\\mathrm{ms}$，$\\beta=0.01\\,\\mathrm{ms}/\\text{cylinder}$。\n- 平均旋转延迟是半圈。磁盘转速为 $7200$ 转/分钟，因此平均旋转延迟为 $T_{\\text{rot}}=\\frac{1}{2}\\times\\frac{60\\times 1000}{7200}\\,\\mathrm{ms}=\\frac{25}{6}\\,\\mathrm{ms}$。\n- 每个请求传输一个扇区，传输时间恒定为 $T_{\\text{xfer}}=0.5\\,\\mathrm{ms}$。\n- 因此，在磁头移动了距离 $d$ 之后，一个请求的服务时间为 $t(d)=\\alpha+\\beta d+T_{\\text{rot}}+T_{\\text{xfer}}=\\frac{73}{15}+\\frac{d}{100}\\,\\mathrm{ms}$。\n- 对于 SCAN 和 C-SCAN，如果在当前扫描方向上没有更远的请求，磁头会继续移动到物理末端（$0$ 或 $199$），然后反转方向（SCAN）或回绕（C-SCAN）；任何这种不立即服务请求的重定位移动所消耗的时间纯粹模型化为 $\\beta d$，没有 $\\alpha$，没有旋转，也没有传输时间。\n- 对于 LOOK 和 C-LOOK，磁头仅在当前方向的最后一个请求处反转方向或回绕（不移动到物理末端），因此没有超出最后一个请求磁道的重定位移动。\n- SSTF 中的平局通过选择编号较小的磁道来打破；对于 SCAN 和 C-SCAN，初始方向是朝磁道号增加的方向；对于 LOOK 和 C-LOOK，初始扫描方向也是朝磁道号增加的方向。\n\n任务：\n1. 对于每种算法（FCFS, SSTF, SCAN, LOOK, C-SCAN, C-LOOK），根据给定的起始位置和上述规则，确定确切的服务顺序。\n2. 对于每种算法，计算总的磁头移动磁道数（包括所有移动，以及任何 SCAN 或 C-SCAN 的重定位移动）。\n3. 对于每种算法，使用服务时间模型 $t(d)=\\frac{73}{15}+\\frac{d}{100}$ 计算平均响应时间（八个请求完成时间的平均值），并在适用时包括任何重定位时间。\n4. 从局部性和公平性的角度，解释不同算法在总磁头移动量和平均响应时间上的差异。\n\n最后，定义总结性指标 $R$ 为这六种算法中最大总磁头移动量与最小总磁头移动量之比。计算 $R$。将您的最终 $R$ 值四舍五入到四位有效数字。报告最终的 $R$ 值，不带单位。", "solution": "该问题是一个定义明确且自成体系的练习，旨在分析磁盘调度算法，这是计算机组成和操作系统中的一个标准主题。所有必要的数据、模型和约束都已提供，并且在科学和数学上都是合理的。因此，可以推导出一个完整的解决方案。\n\n已知条件如下：\n- 磁道范围：$[0, 199]$。\n- 初始磁头位置：$C_{\\text{start}}=75$。\n- 初始时间：$t=0$。\n- 初始扫描方向：朝磁道号增加的方向。\n- 请求队列（在 $t=0$ 同时到达）：一组 $N=8$ 个请求，针对磁道 $\\{10, 15, 20, 40, 60, 90, 150, 180\\}$。\n- FCFS 的到达顺序是：$40, 150, 10, 90, 15, 180, 60, 20$。\n- 在磁头移动了距离 $d$ 之后，一个请求的服务时间是 $t(d) = T_{\\text{const}} + \\beta d$，其中常数时间分量是 $T_{\\text{const}} = \\alpha + T_{\\text{rot}} + T_{\\text{xfer}} = \\frac{73}{15}\\,\\mathrm{ms}$，寻道时间系数是 $\\beta = 0.01\\,\\mathrm{ms}/\\text{cylinder} = \\frac{1}{100}\\,\\mathrm{ms}/\\text{cylinder}$。\n- SCAN 和 C-SCAN 的重定位时间模型化为 $t_{\\text{repo}}(d) = \\beta d = \\frac{d}{100}\\,\\mathrm{ms}$。\n\n由于所有请求都在 $t=0$ 时到达，请求的响应时间等于其完成时间。平均响应时间是所有 $N=8$ 个请求的完成时间的平均值。设 $S = (c_1, c_2, \\dots, c_8)$ 为给定算法的磁道服务顺序。磁头从 $c_0=75$ 开始。第 $i$ 个请求的移动距离是 $d_i = |c_i - c_{i-1}|$。第 $i$ 个请求的服务时间是 $T_i$。第 $i$ 个请求的完成时间是 $C_i = \\sum_{j=1}^{i} T_j$。\n\n我们逐一分析这六种算法。\n\n**1. 先来先服务 (FCFS)**\n请求按其到达的顺序被服务。\n- 服务顺序: $40, 150, 10, 90, 15, 180, 60, 20$。\n- 移动路径: $75 \\to 40 \\to 150 \\to 10 \\to 90 \\to 15 \\to 180 \\to 60 \\to 20$。\n- 磁头移动距离 ($d_i$): $d_1=|40-75|=35$, $d_2=|150-40|=110$, $d_3=|10-150|=140$, $d_4=|90-10|=80$, $d_5=|15-90|=75$, $d_6=|180-15|=165$, $d_7=|60-180|=120$, $d_8=|20-60|=40$。\n- 总磁头移动量: $\\sum d_i = 35+110+140+80+75+165+120+40 = 765$ 个磁道。\n- 平均响应时间: 完成时间的总和是 $\\sum_{i=1}^{8} C_i = \\sum_{i=1}^{8} (8-i+1) T_i$。\n  $T_i = \\frac{73}{15} + \\frac{d_i}{100}$。\n  $\\sum C_i = \\frac{73}{15}\\sum_{i=1}^{8}(8-i+1) + \\frac{1}{100}\\sum_{i=1}^{8}(8-i+1)d_i$。第一个和是 $\\frac{8 \\times 9}{2} = 36$。\n  $\\sum(8-i+1)d_i = 8(35)+7(110)+6(140)+5(80)+4(75)+3(165)+2(120)+1(40) = 3365$。\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{3365}{100} = 175.2 + 33.65 = 208.85\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{208.85}{8} = 26.10625\\,\\mathrm{ms}$。\n\n**2. 最短寻道时间优先 (SSTF)**\n接下来选择与当前磁头位置寻道距离最小的请求。\n- 磁头在 $75$。到 $60$ 和 $90$ 的距离都是 $15$。平局规则选择编号较小的磁道 $60$。\n- 路径: $75 \\to 60 \\to 40 \\to 20 \\to 15 \\to 10 \\to 90 \\to 150 \\to 180$。\n- 服务顺序: $60, 40, 20, 15, 10, 90, 150, 180$。\n- 磁头移动距离 ($d_i$): $15, 20, 20, 5, 5, 80, 60, 30$。\n- 总磁头移动量: $\\sum d_i = 15+20+20+5+5+80+60+30 = 235$ 个磁道。\n- 平均响应时间:\n  $\\sum(8-i+1)d_i = 8(15)+7(20)+6(20)+5(5)+4(5)+3(80)+2(60)+1(30) = 815$。\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{815}{100} = 175.2 + 8.15 = 183.35\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{183.35}{8} = 22.91875\\,\\mathrm{ms}$。\n\n**3. 扫描算法 (SCAN，电梯算法)**\n磁头在磁盘上来回扫描。\n- 从 $75$ 开始，方向为增加。\n- 服务顺序: $90, 150, 180$。然后移动到末端 $199$，反转方向，服务 $60, 40, 20, 15, 10$。\n- 总移动路径: $75 \\to 199 \\to 10$。\n- 总磁头移动量: $(199-75) + (199-10) = 124 + 189 = 313$ 个磁道。\n- 平均响应时间:\n  - $C_{90}: t(15)$。\n  - $C_{150}: C_{90} + t(60)$。\n  - $C_{180}: C_{150} + t(30)$。\n  - 服务完 $180$ 后，磁头移动到 $199$。$d_{\\text{repo1}}=19$。花费时间为 $t_{\\text{repo1}} = \\frac{19}{100} = 0.19\\,\\mathrm{ms}$。\n  - 到达 $199$ 的时间是 $C_{180} + t_{\\text{repo1}}$。\n  - 下一个服务是磁道 $60$。磁头从 $199$ 移动到 $60$，距离为 $d_4=139$。\n  - $C_{60}: (C_{180} + t_{\\text{repo1}}) + t(139)$。\n  - 后续服务: $C_{40} = C_{60}+t(20)$, $C_{20}=C_{40}+t(20)$, $C_{15}=C_{20}+t(5)$, $C_{10}=C_{15}+t(5)$。\n  - 对单个完成时间求和：\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+2.63) + (5T_0+2.83) + (6T_0+3.03) + (7T_0+3.08) + (8T_0+3.13) = 36T_0 + 16.65$。（其中 $T_0=\\frac{73}{15}$）\n  $\\sum C_i = 175.2 + 16.65 = 191.85\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{191.85}{8} = 23.98125\\,\\mathrm{ms}$。\n\n**4. LOOK 算法**\n与 SCAN 类似，但磁头在当前方向的最后一个请求处反转方向。\n- 服务顺序: $90, 150, 180$。在 $180$ 处反转，然后服务 $60, 40, 20, 15, 10$。\n- 总移动路径: $75 \\to 180 \\to 10$。\n- 总磁头移动量: $(180-75) + (180-10) = 105 + 170 = 275$ 个磁道。\n- 平均响应时间: 没有重定位时间。服务完 $180$ 后，下一个服务是 $60$。移动距离是 $|60-180|=120$。\n  - $C_{90}: t(15)$, $C_{150}: C_{90}+t(60)$, $C_{180}: C_{150}+t(30)$。\n  - $C_{60}: C_{180}+t(120)$。\n  - 对完成时间求和：\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+2.25) + (5T_0+2.45) + (6T_0+2.65) + (7T_0+2.70) + (8T_0+2.75) = 36T_0 + 14.75$。\n  $\\sum C_i = 175.2 + 14.75 = 189.95\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{189.95}{8} = 23.74375\\,\\mathrm{ms}$。\n\n**5. 循环扫描算法 (C-SCAN)**\n磁头只朝一个方向扫描。到达末端后，它返回到起始端并再次扫描。\n- 从 $75$ 开始，方向为增加。\n- 服务顺序: $90, 150, 180$。移动到末端 $199$，回绕到 $0$，然后服务 $10, 15, 20, 40, 60$。\n- 总移动路径: $75 \\to 199$（服务），$199 \\to 0$（重定位），$0 \\to 60$（服务）。\n- 总磁头移动量: $(199-75) + (199-0) + (60-0) = 124 + 199 + 60 = 383$ 个磁道。\n- 平均响应时间:\n  - 重定位移动是从 $180 \\to 199$（$d=19$）和 $199 \\to 0$（$d=199$）。总重定位距离是 $218$。\n  - 总重定位时间是 $t_{\\text{repo}} = \\frac{218}{100} = 2.18\\,\\mathrm{ms}$。\n  - 逻辑与 SCAN 类似。\n  - 对完成时间求和：\n  $\\sum C_i = (T_0+0.15) + (2T_0+0.75) + (3T_0+1.05) + (4T_0+3.33) + (5T_0+3.38) + (6T_0+3.43) + (7T_0+3.63) + (8T_0+3.83) = 36T_0 + 19.55$。\n  $\\sum C_i = 175.2 + 19.55 = 194.75\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{194.75}{8} = 24.34375\\,\\mathrm{ms}$。\n\n**6. 循环 LOOK 算法 (C-LOOK)**\n与 C-SCAN 类似，但磁头从最后一个请求回绕到下一轮的第一个请求。\n- 服务顺序: $90, 150, 180$。然后回绕到 $10$，并服务 $10, 15, 20, 40, 60$。\n- 磁头移动都是服务寻道的一部分。路径: $75 \\to 90 \\to \\dots \\to 180 \\to 10 \\to \\dots \\to 60$。\n- 磁头移动距离 ($d_i$): $15, 60, 30, |10-180|=170, 5, 5, 20, 20$。\n- 总磁头移动量: $15+60+30+170+5+5+20+20 = 325$ 个磁道。\n- 平均响应时间:\n  $\\sum(8-i+1)d_i = 8(15)+7(60)+6(30)+5(170)+4(5)+3(5)+2(20)+1(20) = 1665$。\n  $\\sum C_i = \\frac{73}{15}(36) + \\frac{1665}{100} = 175.2 + 16.65 = 191.85\\,\\mathrm{ms}$。\n  平均响应时间 = $\\frac{191.85}{8} = 23.98125\\,\\mathrm{ms}$。\n\n**结果总结**\n\n| 算法      | 总磁头移动量 | 平均响应时间 (ms) |\n|-----------|------------------:|----------------------:|\n| FCFS      | $765$             | $26.10625$            |\n| SSTF      | $235$             | $22.91875$            |\n| SCAN      | $313$             | $23.98125$            |\n| LOOK      | $275$             | $23.74375$            |\n| C-SCAN    | $383$             | $24.34375$            |\n| C-LOOK    | $325$             | $23.98125$            |\n\n**解释**\n- **局部性与磁头移动**：SSTF 通过利用空间局部性，总是选择最近的请求，从而使总磁头移动量最小化（$235$ 个磁道）。FCFS 完全忽略局部性，因此表现最差（$765$ 个磁道）。SCAN/LOOK 变体介于两者之间。LOOK（$275$）和 C-LOOK（$325$）通过避免不必要地移动到磁盘的物理末端，性能优于其对应的 SCAN（$313$）和 C-SCAN（$383$）算法。\n- **公平性与响应时间**：就防止饥饿而言，FCFS 在定义上是公平的，但由于其效率低下，平均响应时间最高。SSTF 提供了最低的平均响应时间，最大化了吞吐量，但可能导致远处请求的饥饿（在这个静态批处理中不明显的公平性问题）。SCAN/LOOK 系列提供了一种折衷。C-SCAN 和 C-LOOK 通常比 SCAN 和 LOOK 提供更均匀的等待时间，因为请求只等待一个扫描方向。在这个特定案例中，LOOK 在基于扫描的算法中提供了最佳的响应时间，而 SCAN 和 C-LOOK 的平均响应时间由于请求位置和时间的特定组合而恰好相同。\n\n**最终指标计算**\n总结性指标 $R$ 是最大总磁头移动量与最小总磁头移动量之比。\n- 最大总磁头移动量, $H_{\\text{max}} = 765$ (来自 FCFS)。\n- 最小总磁头移动量, $H_{\\text{min}} = 235$ (来自 SSTF)。\n\n该比率为：\n$$R = \\frac{H_{\\text{max}}}{H_{\\text{min}}} = \\frac{765}{235} = \\frac{153}{47}$$\n其数值为：\n$$R \\approx 3.25531914...$$\n四舍五入到四位有效数字，我们得到 $R = 3.255$。", "answer": "$$ \\boxed{3.255} $$", "id": "3635884"}, {"introduction": "从理论计算到动手实现是掌握一个算法的关键一步。这个练习要求你将 C-SCAN 算法的抽象规则转化为具体的计算机程序 [@problem_id:3221175]。你将使用循环队列这一经典数据结构来管理磁盘请求，并精确模拟 C-SCAN 单向扫描和回环移动的整个过程。通过编程实践，你不仅能加深对算法操作细节的理解，还能体会到数据结构在实现高效系统策略中的重要作用。", "problem": "您需要设计并实现一个程序，使用循环队列来模拟循环扫描（C-SCAN）磁盘调度策略。目标是在精确定义的单向扫描和回绕行为下，计算磁道请求的服务顺序和以磁道数为单位表示的总寻道距离。\n\n将使用的基本依据和定义：\n- 队列是一种具有入队（enqueue）和出队（dequeue）操作的先进先出（FIFO）抽象数据类型。循环队列是在固定大小的数组上实现的队列，其中队头和队尾索引通过模运算前进，以便在回绕后重用存储空间。形式上，对于容量为 $m$ 的缓冲区，索引前进按模 $m$ 计算，即 $(i + 1) \\bmod m$。\n- 在 C-SCAN 策略中，磁盘磁头严格沿一个方向扫过所有柱面，按柱面索引的非递减顺序为符合条件的请求提供服务。到达磁盘末端后，它会执行一次回绕到起始位置，并继续沿相同方向移动。反向遍历不服务任何请求。\n\n问题设定：\n- 磁盘柱面由从 $0$ 到 $C$（含）的整数标记，其中 $C$ 是一个正整数。\n- 存在一个初始磁头位置 $H$，满足 $0 \\le H \\le C$。\n- 请求序列是一个有序列表 $R = [r_1, r_2, \\dots, r_n]$，其中每个 $r_i \\in \\{0,1,\\dots,C\\}$。允许重复请求，且必须视为不同请求；对于值相同的请求，在服务顺序中应保持其原始相对顺序。\n- 磁头仅沿柱面索引递增的方向移动。C-SCAN 的行为表示如下：首先按柱面索引的非递减顺序为每个满足 $r_i \\ge H$ 的请求 $r_i$ 提供服务（在值相等时保持稳定性），然后经由 $C$ 回绕到 $0$，并继续按非递减顺序为每个满足 $r_i  H$ 的剩余请求 $r_i$ 提供服务（同样在值相等时保持稳定性）。\n- 使用循环队列来管理服务顺序：将递增方向扫描段入队，当且仅当存在至少一个请求 $r_i  H$ 时，插入一个回绕标记，然后将剩余段入队。当回绕标记出队时，会触发一次回绕移动，该移动包括从当前磁头位置遍历到 $C$，然后从 $C$ 跳转到 $0$。\n- 寻道距离是在 C-SCAN 策略下为完成所有请求而实际遍历的连续位置之间磁头移动的绝对值之和。形式上，定义一个序列 $S = [s_1, s_2, \\dots, s_k]$，它由 $\\{0,1,\\dots,C\\}$ 中的柱面索引或特殊的回绕标记 $\\bot$ 组成，按上述方式构建。设 $p_0 = H$。对于 $j = 1,2,\\dots,k$：\n  - 如果 $s_j \\in \\{0,1,\\dots,C\\}$，则设 $p_j = s_j$，并对总距离贡献 $|p_j - p_{j-1}|$。\n  - 如果 $s_j = \\bot$，则对总距离贡献 $|C - p_{j-1}| + C$，并设 $p_j = 0$。\n最终服务顺序是序列 $S$ 中移除了所有 $\\bot$ 标记后的子序列。如果没有请求 $r_i  H$，则不存在回绕标记，也不包含回绕移动。如果 $n = 0$，则总距离为 $0$，服务顺序为空。\n- 程序必须将队列实现为一个真正的循环队列，其队头和队尾索引使用模运算。\n\n您的程序必须处理一个固定的测试套件，并生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个形如 $[D, L]$ 的列表，其中 $D$ 是等于总寻道距离（以磁道数为单位）的整数，$L$ 是按确切服务顺序列出的已服务磁道索引列表。\n\n需要实现的测试套件：\n1. $C = 199$, $H = 50$, $R = [82, 170, 43, 140, 24, 16, 190]$。\n2. $C = 10$, $H = 0$, $R = [0, 0, 10, 5, 5, 2]$。\n3. $C = 199$, $H = 180$, $R = [10, 20, 30]$。\n4. $C = 100$, $H = 50$, $R = []$。\n5. $C = 100$, $H = 99$, $R = [100, 100, 0, 0, 50, 99, 1]$。\n\n您的程序应生成单行输出，其中包含这五个测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。每个元素必须是对应测试的由两个元素组成的列表 $[D, L]$，顺序与上面列出的一致。例如，一个语法上相似的格式是 $[[D_1, L_1],[D_2, L_2],\\dots,[D_5, L_5]]$。", "solution": "该问题要求设计并实现一个程序来模拟循环扫描（C-SCAN）磁盘调度算法，并遵循非常具体的数据结构和计算规则。\n\n### 问题验证与逻辑拆解\n\n1.  **科学依据**：问题基于计算机科学中成熟的磁盘调度算法主题。C-SCAN 是一种标准算法，使用队列实现是常规方法。所有定义和数学公式在此背景下均有效。\n2.  **良构性**：问题规定了精确的参数（$C, H, R$）、服务顺序确定规则（分区、稳定排序）以及总寻道距离的计算方法。回绕距离的公式 $|C - p_{j-1}| + C$ 被清晰陈述，无歧义。\n3.  **算法实现步骤**：\n    *   **初始化**：处理空请求列表 $R$ 的情况。若 $R$ 为空，则距离为 $0$，服务顺序为空列表。\n    *   **分区与稳定排序**：为保证稳定性（对于值相同的请求，保持其原始相对顺序），将请求 $R$ 与其原始索引配对。然后，根据请求的柱面索引是否大于等于 $H$，将它们划分为两个子列表：`ge_H` 和 `lt_H`。分别对这两个子列表按柱面索引进行稳定排序。\n    *   **构建处理序列**：创建一个将要入队的序列。它由排序后的 `ge_H` 列表中的柱面索引组成。如果 `lt_H` 列表不为空，则在此之后添加一个特殊的回绕标记（例如 `None`）。最后，添加排序后的 `lt_H` 列表中的柱面索引。\n    *   **构建最终服务顺序**：最终的服务顺序 $L$ 是排序后的 `ge_H` 和 `lt_H` 列表的简单串联（不含回绕标记）。\n    *   **队列处理与距离计算**：\n        1. 创建一个循环队列实例，并将上述构建的处理序列全部入队。\n        2. 初始化当前磁头位置 `current_pos = H` 和总距离 `total_distance = 0`。\n        3. 循环出队，直到队列为空：\n           *   如果出队项是回绕标记，则按公式 `total_distance += abs(C - current_pos) + C` 累加回绕距离，并将 `current_pos` 更新为 `0`。\n           *   如果出队项是柱面索引 `req`，则按公式 `total_distance += abs(req - current_pos)` 累加寻道距离，并将 `current_pos` 更新为 `req`。\n    *   **输出**：循环结束后，累积的总距离 $D$ 和已构建的服务顺序 $L$ 即为该测试用例的结果。\n\n### 手动推演测试用例\n\n**测试用例 1: $C=199, H=50, R=[82, 170, 43, 140, 24, 16, 190]$**\n1.  `ge_H` (排序后): `[82, 140, 170, 190]`。\n2.  `lt_H` (排序后): `[16, 24, 43]`。\n3.  服务顺序 $L$: `[82, 140, 170, 190, 16, 24, 43]`。\n4.  路径与距离：\n    -   $50 \\to 82 \\to 140 \\to 170 \\to 190$ (距离: $|82-50|+|140-82|+|170-140|+|190-170| = 32+58+30+20 = 140$)\n    -   回绕 (从 190): $|199-190| + 199 = 9 + 199 = 208$。新位置为 $0$。\n    -   $0 \\to 16 \\to 24 \\to 43$ (距离: $|16-0|+|24-16|+|43-24| = 16+8+19 = 43$)\n    -   总距离 $D = 140 + 208 + 43 = 391$。\n5.  结果: `[391, [82,140,170,190,16,24,43]]`。\n\n**测试用例 3: $C=199, H=180, R=[10, 20, 30]$**\n1.  `ge_H`: `[]`。\n2.  `lt_H` (排序后): `[10, 20, 30]`。\n3.  服务顺序 $L$: `[10, 20, 30]`。\n4.  路径与距离：\n    -   初始扫描段为空。直接回绕。\n    -   回绕 (从 180): $|199-180| + 199 = 19 + 199 = 218$。新位置为 $0$。\n    -   $0 \\to 10 \\to 20 \\to 30$ (距离: $|10-0|+|20-10|+|30-20| = 10+10+10 = 30$)\n    -   总距离 $D = 218 + 30 = 248$。\n5.  结果: `[248, [10,20,30]]`。\n\n其他测试用例的逻辑类似，并且该实现方法能够正确处理所有情况。提供的 Python 代码是此逻辑的直接实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass CircularQueue:\n    \"\"\"\n    A circular queue implementation based on a fixed-size numpy array,\n    using modular arithmetic for head and tail indices.\n    \"\"\"\n    def __init__(self, capacity):\n        if capacity  1:\n            raise ValueError(\"Capacity must be at least 1\")\n        self.capacity = capacity\n        # Use object dtype to store mixed types (integers and a sentinel object)\n        self.buffer = np.full(capacity, None, dtype=object)\n        self.head = 0\n        self.tail = 0\n        self.size = 0\n\n    def is_empty(self):\n        \"\"\"Returns True if the queue is empty.\"\"\"\n        return self.size == 0\n\n    def is_full(self):\n        \"\"\"Returns True if the queue is full.\"\"\"\n        return self.size == self.capacity\n\n    def enqueue(self, item):\n        \"\"\"Adds an item to the end of the queue.\"\"\"\n        if self.is_full():\n            raise OverflowError(\"CircularQueue is full\")\n        self.buffer[self.tail] = item\n        self.tail = (self.tail + 1) % self.capacity\n        self.size += 1\n\n    def dequeue(self):\n        \"\"\"Removes and returns the item from the front of the queue.\"\"\"\n        if self.is_empty():\n            raise IndexError(\"dequeue from empty CircularQueue\")\n        item = self.buffer[self.head]\n        self.buffer[self.head] = None # Optional: clear dequeued slot\n        self.head = (self.head + 1) % self.capacity\n        self.size -= 1\n        return item\n\ndef c_scan_simulation(C, H, R):\n    \"\"\"\n    Simulates the C-SCAN disk scheduling algorithm as specified in the problem.\n\n    Args:\n        C (int): The maximum cylinder index.\n        H (int): The initial head position.\n        R (list): A list of track requests.\n\n    Returns:\n        list: A list [D, L] where D is the total seek distance and L is the service order.\n    \"\"\"\n    if not R:\n        return [0, []]\n\n    # Associate each request with its original index to handle stability\n    requests_with_indices = list(enumerate(R))\n\n    # Partition requests into two groups: r >= H and r  H\n    ge_H_pairs = [item for item in requests_with_indices if item[1] >= H]\n    lt_H_pairs = [item for item in requests_with_indices if item[1]  H]\n\n    # Sort each group stably based on the cylinder index\n    # Python's default sort/sorted is stable\n    ge_H_sorted = sorted(ge_H_pairs, key=lambda x: x[1])\n    lt_H_sorted = sorted(lt_H_pairs, key=lambda x: x[1])\n\n    # Construct the processing sequence\n    processing_sequence = [val for _, val in ge_H_sorted]\n    final_service_order_L = list(processing_sequence)\n    \n    # Use a unique sentinel object for the wrap marker\n    wrap_marker = object()\n\n    if lt_H_sorted:\n        processing_sequence.append(wrap_marker)\n        lt_H_values = [val for _, val in lt_H_sorted]\n        processing_sequence.extend(lt_H_values)\n        final_service_order_L.extend(lt_H_values)\n    \n    # Populate and process using the circular queue\n    queue_capacity = len(processing_sequence)\n    cq = CircularQueue(queue_capacity)\n    for item in processing_sequence:\n        cq.enqueue(item)\n    \n    total_distance_D = 0\n    current_pos = H\n\n    while not cq.is_empty():\n        item = cq.dequeue()\n        if item is wrap_marker:\n            # Apply wrap-around rule: move to C, then from C to 0\n            total_distance_D += abs(C - current_pos) + C\n            current_pos = 0\n        else:\n            # Process a regular request\n            request_val = item\n            total_distance_D += abs(request_val - current_pos)\n            current_pos = request_val\n            \n    return [total_distance_D, final_service_order_L]\n\ndef solve():\n    \"\"\"\n    Runs the C-SCAN simulation on the provided test suite and prints the results.\n    \"\"\"\n    test_cases = [\n        (199, 50, [82, 170, 43, 140, 24, 16, 190]),\n        (10, 0, [0, 0, 10, 5, 5, 2]),\n        (199, 180, [10, 20, 30]),\n        (100, 50, []),\n        (100, 99, [100, 100, 0, 0, 50, 99, 1]),\n    ]\n\n    results = []\n    for C, H, R in test_cases:\n        result = c_scan_simulation(C, H, R)\n        results.append(result)\n\n    # Custom formatting to produce output string without spaces, e.g., [[D,L],[D,L]]\n    def format_list_no_spaces(lst):\n        return '[' + ','.join(map(str, lst)) + ']'\n    \n    formatted_results = []\n    for D, L in results:\n        formatted_results.append(f\"[{D},{format_list_no_spaces(L)}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3221175"}]}