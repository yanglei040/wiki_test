{"hands_on_practices": [{"introduction": "要真正理解一个概念，最好的方法之一就是亲手实现它。本练习将带领你跨越从奇偶校验的抽象数学定义（一个异或（XOR）和）到其具体物理实现（使用基本逻辑门）的鸿沟。[@problem_id:3640130] 这个练习旨在挑战你从第一性原理出发，思考硬件效率和实现方式，将布尔代数应用到实际的数字逻辑设计中。", "problem": "一个内存子系统使用偶校验位来检测每个传输数据字上的单位错误。对于长度为 $n$ 的数据字，偶校验位 $p$ 由模-$2$和定义：$p = d_{1} \\oplus d_{2} \\oplus \\cdots \\oplus d_{n}$，其中 $\\oplus$ 表示布尔变量的异或（XOR）运算，且 $d_{i} \\in \\{0,1\\}$。你需要设计一个组合逻辑奇偶校验生成器，该生成器仅使用双输入与非门，并假设扇出无限，且只有非反相的初级输入 $d_{i}$ 可用。\n\n仅从与非门和异或门的布尔代数定义以及标准恒等式出发，执行以下步骤：\n\n- 仅使用双输入与非门构建一个双输入异或子电路，并通过布尔表达式的代数变换证明其正确性。\n- 使用一个由相同的双输入异或子电路组成的平衡二叉归约树来实现 $p = d_{1} \\oplus \\cdots \\oplus d_{n}$。\n- 推导整个奇偶校验生成器所需双输入与非门的确切总数 $G(n)$，作为 $n$ 的函数。\n\n为了提供背景和进行比较（不必将此包含在所要求的最终值中），在你的推理中也说明仅使用与非门的门数与一个基准设计（该设计在相同的平衡树中使用双输入异或门作为原语，并将每个异或原语计为一个门）相比如何。\n\n以单一封闭形式表达式 $G(n)$（以 $n$ 表示）提供你的最终答案。不需要数值近似或四舍五入。", "solution": "问题要求推导构建一个 $n$ 位偶校验生成器所需的双输入与非门的总数 $G(n)$。该设计被限制为仅使用双输入与非门，输入为非反相的初级输入，并且必须构造成一个由相同的双输入异或子电路组成的平衡二叉归约树。\n\n推导将按问题陈述的要求分三步进行。首先，我们将仅使用双输入与非门构建一个双输入异或子电路并证明其正确性。其次，我们将分析平衡二叉树的结构，以确定需要多少个这样的异或子电路。最后，我们将结合这些结果来推导总门数 $G(n)$。\n\n**第一步：用双输入与非门构建双输入异或子电路**\n\n设异或函数的输入为 $A$ 和 $B$。异或的布尔表达式为：\n$$A \\oplus B = A'B + AB'$$\n双输入与非门的布尔表达式为：\n$$A \\uparrow B = (A \\cdot B)' = A' + B'$$\n其中我们使用运算符 $\\uparrow$ 来表示与非运算。\n\n我们必须仅使用 $\\uparrow$ 运算符来构建一个等效于 $A \\oplus B$ 的电路。虽然存在多种实现方式，但一个著名且高效的电路使用四个双输入与非门。其结构由以下布尔表达式给出：\n$$F = (A \\uparrow (A \\uparrow B)) \\uparrow (B \\uparrow (A \\uparrow B))$$\n\n为了证明这种构造的正确性，我们将对这个表达式进行代数变换，以证明它等效于 $A \\oplus B$。让我们定义一个中间信号 $G_1 = A \\uparrow B$。输出 $F$ 的表达式变为：\n$$F = (A \\uparrow G_1) \\uparrow (B \\uparrow G_1)$$\n使用与非运算的定义展开此表达式：\n$$F = ( (A \\uparrow G_1) \\cdot (B \\uparrow G_1) )'$$\n$$F = ( (A \\cdot G_1)' \\cdot (B \\cdot G_1)' )'$$\n应用德摩根定律，即 $(X' \\cdot Y')' = X + Y$，我们可以简化这个表达式。令 $X = A \\cdot G_1$ 且 $Y = B \\cdot G_1$。\n$$F = (A \\cdot G_1) + (B \\cdot G_1)$$\n使用分配律，我们可以提出 $G_1$：\n$$F = (A+B) \\cdot G_1$$\n现在，我们代入 $G_1 = A \\uparrow B = (A \\cdot B)'$ 的表达式：\n$$F = (A+B) \\cdot (A \\cdot B)'$$\n对 $(A \\cdot B)'$ 应用德摩根定律得到 $A' + B'$：\n$$F = (A+B) \\cdot (A' + B')$$\n我们使用分配律展开此表达式：\n$$F = A \\cdot (A' + B') + B \\cdot (A' + B')$$\n$$F = (A \\cdot A') + (A \\cdot B') + (B \\cdot A') + (B \\cdot B')$$\n根据布尔代数公理，$X \\cdot X' = 0$。因此，$A \\cdot A' = 0$ 且 $B \\cdot B' = 0$。表达式简化为：\n$$F = 0 + A \\cdot B' + A' \\cdot B + 0$$\n$$F = A'B + AB'$$\n这个最终表达式是异或函数 $A \\oplus B$ 的定义。因此，由四个双输入与非门构建的电路正确地实现了一个双输入异或函数。构建一个这样的子电路所需的门数量为 $4$。该设计直接接收输入 $A$ 和 $B$，因此满足了问题中仅能使用非反相输入的约束。\n\n**第二步：平衡二叉归约树的分析**\n\n校验位 $p$ 被定义为 $n$ 个数据位的异或和：\n$$p = d_{1} \\oplus d_{2} \\oplus \\cdots \\oplus d_{n}$$\n异或运算满足结合律，即 $(A \\oplus B) \\oplus C = A \\oplus (B \\oplus C)$。这使我们能够通过级联双输入异或运算，以树形结构计算 $n$ 输入的异或和。指定使用平衡二叉归约树是为了最小化传播延迟。\n\n要使用双输入门计算 $n$ 个输入的异或和，我们总共需要 $n-1$ 个这样的门。我们可以通过归纳法证明这一点。令 $N_{\\text{XOR}}(n)$ 为 $n$ 个输入所需的双输入异或子电路的数量。\n- 对于 $n=2$，我们需要 $1$ 个子电路，所以 $N_{\\text{XOR}}(2) = 1 = 2-1$。\n- 对于 $n=3$，我们计算 $(d_1 \\oplus d_2) \\oplus d_3$，这需要 $2$ 个子电路。所以 $N_{\\text{XOR}}(3) = 2 = 3-1$。\n- 对于一个通用的 $n$，一个平衡树结构将 $n$ 个输入划分为大小为 $\\lceil n/2 \\rceil$ 和 $\\lfloor n/2 \\rfloor$ 的两组。这两组的异或和被递归地计算，然后它们的结果通过最后一个异或门组合起来。递推关系为：\n$$N_{\\text{XOR}}(n) = N_{\\text{XOR}}(\\lceil n/2 \\rceil) + N_{\\text{XOR}}(\\lfloor n/2 \\rfloor) + 1$$\n基例为 $N_{\\text{XOR}}(1) = 0$。\n假设对于所有 $k  n$，归纳假设 $N_{\\text{XOR}}(k) = k-1$ 成立：\n$$N_{\\text{XOR}}(n) = (\\lceil n/2 \\rceil - 1) + (\\lfloor n/2 \\rfloor - 1) + 1$$\n$$N_{\\text{XOR}}(n) = \\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor - 1$$\n对于任何整数 $n$，恒等式 $\\lceil n/2 \\rceil + \\lfloor n/2 \\rfloor = n$ 均成立。因此：\n$$N_{\\text{XOR}}(n) = n - 1$$\n这证明了实现 $n$ 位奇偶校验生成器总共需要 $n-1$ 个相同的双输入异或子电路。\n\n**第三步：总与非门数量 $G(n)$ 的推导**\n\n我们已经确定了以下几点：\n1.  每个双输入异或子电路是用 $4$ 个双输入与非门实现的。\n2.  整个 $n$ 位奇偶校验生成器需要 $n-1$ 个这样相同的、以平衡树形式排列的异或子电路。\n\n树中的每个异或子电路接收的输入要么是初级输入 $d_i$，要么是前一级异或子电路的非反相输出。由于每个子电路都是一个独立的模块，它们之间没有门共享的机会。\n\n因此，双输入与非门的总数 $G(n)$ 是异或子电路数量与每个子电路中与非门数量的乘积：\n$$G(n) = (\\text{异或子电路数量}) \\times (\\text{每个异或子电路的与非门数量})$$\n$$G(n) = (n-1) \\times 4$$\n$$G(n) = 4(n-1)$$\n\n根据要求，为了提供背景和进行比较，一个使用基本双输入异或门作为原语的基准设计总共需要 $n-1$ 个门。我们仅使用与非门的实现需要 $4(n-1)$ 个门，是其 4 倍。这个因子直接反映了在给定约束下，从仅有与非门的逻辑族合成异或函数的门复杂度。\n\n最终推导出的 $n$ 位奇偶校验生成器所需的双输入与非门总数的表达式为 $G(n) = 4(n-1)$。", "answer": "$$\\boxed{4(n-1)}$$", "id": "3640130"}, {"introduction": "在构建了奇偶校验器之后，下一步是理解其局限性。本练习提供了一个数据总线上串扰的真实场景，这是高速数字设计中的一个常见问题。[@problem_id:3640110] 通过对这种物理现象进行建模，我们可以量化未被检测到的错误的概率，并从物理层面理解为何简单的奇偶校验对于高可靠性系统来说是不够的，因为它对偶数个比特的错误是“视而不见”的。", "problem": "一个包含 $32$ 根数据线和一根奇偶校验线的并行数据总线实现了偶校验错误检测，这意味着奇偶校验生成器设置奇偶校验位，使得在 $33$ 个传输比特中逻辑“1”的总数为偶数。接收器对接收到的数据重新计算奇偶校验，并与接收到的奇偶校验位进行比较，以检测差异。每次数据传输都是一个字（$32$ 个数据位加一个奇偶校验位），通过印刷电路板上物理相邻的微带线同时发送。由于这些线路长且间距小，电容耦合会在相邻导线之间引起串扰。\n\n在单次字传输过程中，物理错误机制建模如下：\n- 由于随机噪声，每根导线每次传输发生独立单线比特翻转的概率为 $p$，且这些事件在各导线间是独立的。\n- 此外，对于每对物理上相邻的导线，发生耦合的双线同时翻转（两根导线一起反转）的概率为每对相邻导线每次传输 $q$，且这些事件在各导线对之间独立，也与单线翻转事件独立。\n\n假设 $33$ 根导线的物理排列是线性的：$D_{0}, D_{1}, \\ldots, D_{31}, P$，其中 $D_{i}$ 是数据线，$P$ 是奇偶校验线。在这种排列中，有 $32$ 对相邻导线：$(D_{0},D_{1}), (D_{1},D_{2}), \\ldots, (D_{30},D_{31}), (D_{31},P)$。在本案例研究中，取 $p = 1.2 \\times 10^{-6}$ 和 $q = 3.0 \\times 10^{-8}$。\n\n从偶校验的定义和基本概率公理出发，并使用忽略所有 $p^{2}$、$pq$ 和 $q^{2}$ 阶项的稀有事件近似（即，假设每次传输最多发生一个错误事件），推导并计算发生错误但未被奇偶校验检测到的概率。请用科学记数法表示您的最终概率，并将答案四舍五入到四位有效数字。", "solution": "问题要求计算在给定错误模型下，发生错误但未被偶校验检测到的概率。\n\n首先，我们分析错误检测的条件。系统采用偶校验，这意味着一个有效的码字（32个数据位 + 1个校验位，共33位）包含偶数个“1”。当接收到的码字中“1”的个数为奇数时，错误被检测到。反之，如果发生了错误（即接收码字与发送码字不同），但接收码字中“1”的个数仍为偶数，则错误未被检测到。这等价于说，一个未被检测到的错误必然由偶数个比特位的翻转引起。\n\n接下来，我们分析问题中定义的两种错误机制及其对奇偶性的影响：\n1.  **独立单线比特翻转**：此事件导致单个比特（1位）发生翻转。由于1是奇数，这将改变码字中“1”总数的奇偶性（偶数变为奇数）。因此，任何单线比特翻转错误**总是会被检测到**。\n2.  **耦合的双线同时翻转**：此事件导致一对相邻导线上的两个比特（2位）同时翻转。由于2是偶数，这将保持码字中“1”总数的奇偶性不变（偶数仍然是偶数）。因此，任何耦合的双线翻转错误**总是不会被检测到**。\n\n问题要求使用稀有事件近似，即忽略所有 $p^2$、$pq$ 和 $q^2$ 阶及更高阶的项。这相当于假设在一次传输中最多只发生一个错误事件（要么是一个单线翻转，要么是一个双线翻转）。\n\n在此近似下，一个未被检测到的错误只可能由一个耦合的双线翻转事件引起。因此，我们需要计算发生任意一个此类事件的总概率。\n\n总线上有33根导线，呈线性排列：$D_{0}, D_{1}, \\ldots, D_{31}, P$。这构成了32对物理上相邻的导线：$(D_{0},D_{1}), (D_{1},D_{2}), \\ldots, (D_{31},P)$。\n\n对于每一对相邻导线，发生耦合双线翻转的概率为 $q$。由于这些事件在各导线对之间是独立的，并且根据稀有事件近似，我们可以忽略两个或多个此类事件同时发生的概率（其概率为 $q^2$ 阶或更高）。因此，发生未被检测到错误的总概率 $P_{\\text{undetected}}$ 是所有32个可能发生的、在近似下可视为互斥的双线翻转事件的概率之和。\n$$\nP_{\\text{undetected}} \\approx \\sum_{i=1}^{32} (\\text{第 } i \\text{ 对发生双线翻转的概率})\n$$\n$$\nP_{\\text{undetected}} \\approx 32 \\times q\n$$\n现在，我们代入给定的数值：$q = 3.0 \\times 10^{-8}$。\n$$\nP_{\\text{undetected}} = 32 \\times (3.0 \\times 10^{-8})\n$$\n$$\nP_{\\text{undetected}} = 96 \\times 10^{-8}\n$$\n$$\nP_{\\text{undetected}} = 9.6 \\times 10^{-7}\n$$\n根据要求，我们将结果用科学记数法表示，并四舍五入到四位有效数字。\n$$\nP_{\\text{undetected}} = 9.600 \\times 10^{-7}\n$$", "answer": "$$\\boxed{9.600 \\times 10^{-7}}$$", "id": "3640110"}, {"introduction": "错误检测只是故事的一半；系统还必须能正确地响应。最后一个练习将讨论从比特和导线层面提升到完整的处理器架构层面。[@problem_id:3640136] 它要求你设计一个用于错误恢复的微代码例程，并分析其对性能的影响，从而将罕见的比特翻转事件与整个系统的吞吐量联系起来，揭示可靠性措施的性能成本。", "problem": "一个中央处理器 (CPU) 在每条一级数据缓存 (L1 DC) 行上实现了奇偶校验错误检测。当在数据读取期间检测到奇偶校验错误时，控制权将转移到一个微码例程。请仅使用关于性能指标和期望的核心定义与经过充分检验的事实，为奇偶校验错误提出一个科学上现实的微码服务序列，并推导其对吞吐量的影响。以下条件得到保证：\n\n- 数据缓存访问会触发对与缓存行一同存储的奇偶校验位进行的奇偶校验；该校验可检测任何单位比特错误。\n- 在读取时检测到错误后，微码必须防止架构上可见的数据损坏，从较低级别恢复一个干净的缓存行，并通过重放故障指令来恢复执行。\n- 流水线支持刷新和重放，并且缓存层次结构拥有一个二级 (L2) 缓存和主内存。\n\n对于您的序列，假设处理奇偶校验错误的每个阶段具有以下周期成本：\n\n- 流水线刷新成本为 $F = 15$ 个周期。\n- 缓存行重新填充是各来源的平均值：有 $q = 0.9$ 的概率，该行由 L2 缓存提供，延迟为 $\\ell_{2} = 12$ 个周期；有 $1 - q = 0.1$ 的概率，必须从主内存获取，延迟为 $\\ell_{m} = 200$ 个周期。\n- 微码中的异常记录和状态管理成本为 $E = 40$ 个周期。\n- 重放故障指令的成本为 $X = 4$ 个周期。\n\n假设在固定时钟频率的稳态下，基准的每指令周期数 (CPI) 为 $CPI_{0} = 1.2$，并且一条指令访问数据缓存的概率为 $p = 0.35$（为进行此估算，每条指令最多一次数据访问）。设 $r$ 表示每次数据缓存访问的奇偶校验错误率，其中 $0 \\le r \\ll 1$。使用定义 $\\text{每周期指令数 (IPC)} = \\frac{\\text{指令数}}{\\text{周期数}}$ 和 $\\text{每指令周期数 (CPI)} = \\frac{\\text{周期数}}{\\text{指令数}}$，在固定频率下 $IPC = \\frac{1}{CPI}$，以及每指令开销的期望线性性质。\n\n任务：\n\n- 提出一个逻辑上有序的微码例程，该例程刷新流水线、重新填充缓存行、执行异常处理并重放指令，其方式可防止损坏数据的传播并保留架构状态。\n- 使用给定的周期成本和上述定义，推导归一化吞吐量 $T(r)$ 的闭式表达式，其定义为存在奇偶校验错误时的有效 $IPC$ 与无错误时的基准 $IPC$ 之比，并且仅是 $r$ 的函数。将最终答案表示为关于 $r$ 的单个解析表达式。\n\n无需四舍五入。最终表达式中不包含任何单位。", "solution": "首先验证该问题是科学合理的、提法明确的、客观的和完整的。有效问题的所有条件均已满足，因此可以推导出完整的解决方案。\n\n根据要求，解决方案分两部分进行：首先，为奇偶校验错误提出一个逻辑微码服务序列；其次，推导归一化吞吐量作为错误率 $r$ 的函数。\n\n**第 1 部分：微码服务序列**\n\n在从一级数据缓存 (L1 DC) 读取数据期间检测到奇偶校验错误后，微码必须协调一个恢复序列以满足三个主要目标：防止损坏数据的传播、恢复数据的正确副本以及恢复正常执行。一个逻辑上合理且最简的操作序列如下：\n\n1.  **流水线刷新**：一旦检测到错误，必须立即刷新处理器流水线。此操作会丢弃故障指令和任何后续的推测性执行指令。这是关键的第一步，以防止从缓存中读取的损坏数据被写入架构寄存器或以其他方式影响处理器的架构状态。此操作的成本为 $F = 15$ 个周期。\n\n2.  **异常记录和状态管理**：在停止推测执行后，微码例程接管控制。它必须记录奇偶校验错误的发生，通常记录在机器检查寄存器中。这为系统可靠性分析提供了诊断信息。该阶段还包括为数据恢复做准备所需的任何状态管理。此操作的成本为 $E = 40$ 个周期。\n\n3.  **缓存行重新填充**：微码使包含损坏数据的 L1 DC 行无效。然后，它向内存层次结构的下一级发起读取请求，以获取该行的干净副本。该请求由二级 (L2) 缓存或主内存服务。系统在等待数据返回并写入 L1 DC 期间会停顿。此操作确保数据完整性得到恢复。延迟是概率性的。\n\n4.  **指令重放**：一旦 L1 DC 中有了正确的数据，微码通过重新启动最初导致故障的指令将控制权交还给程序。由于流水线已被刷新，该指令被重新获取并重新开始执行。这一次，数据缓存访问将使用正确的数据成功完成。与重放机制相关的成本为 $X = 4$ 个周期。\n\n处理单个奇偶校验错误的总周期惩罚，记为 $C_{\\text{penalty}}$，是这些顺序阶段成本的总和。缓存行重新填充阶段的延迟是一个必须计算的平均值 $\\bar{\\ell}$。\n\n**第 2 部分：归一化吞吐量 $T(r)$ 的推导**\n\n推导过程首先计算每次错误的总周期惩罚，然后确定其对有效每指令周期数 (CPI) 的影响，最后表示出归一化吞吐量。\n\n首先，我们使用全期望定律以及给定的概率和延迟来计算平均缓存行重新填充延迟 $\\bar{\\ell}$。\n该行由 L2 缓存提供的概率为 $q = 0.9$，延迟为 $\\ell_{2} = 12$ 个周期。\n该行由主内存提供的概率为 $1 - q = 0.1$，延迟为 $\\ell_{m} = 200$ 个周期。\n$$\n\\bar{\\ell} = q \\cdot \\ell_{2} + (1 - q) \\cdot \\ell_{m}\n$$\n代入给定值：\n$$\n\\bar{\\ell} = (0.9)(12) + (0.1)(200) = 10.8 + 20 = 30.8 \\text{ 周期}\n$$\n一次奇偶校验错误事件的总周期惩罚 $C_{\\text{penalty}}$，是顺序恢复阶段成本的总和：\n$$\nC_{\\text{penalty}} = F + E + \\bar{\\ell} + X\n$$\n代入已知值：\n$$\nC_{\\text{penalty}} = 15 + 40 + 30.8 + 4 = 89.8 \\text{ 周期}\n$$\n接下来，我们确定有效 CPI，记为 $CPI_{\\text{eff}}$。无错误时的基准 CPI 为 $CPI_{0} = 1.2$。有效 CPI 是基准 CPI 加上由奇偶校验错误引起的每指令平均周期开销。\n\n一条指令只有在访问数据缓存并且该访问发生奇偶校验错误时，才会招致此惩罚。\n给定指令访问数据缓存的概率为 $p = 0.35$。\n每次数据缓存访问发生奇偶校验错误的概率为 $r$。\n假设这些事件是独立的，任何给定指令触发奇偶校验错误的概率是乘积 $p \\cdot r$。\n\n每指令的预期周期开销是单次错误的总结点惩罚乘以每条指令发生错误的概率：\n$$\n\\text{Overhead}_{\\text{cycles/instruction}} = C_{\\text{penalty}} \\cdot (p \\cdot r)\n$$\n那么，有效 CPI 为：\n$$\nCPI_{\\text{eff}}(r) = CPI_{0} + \\text{Overhead}_{\\text{cycles/instruction}} = CPI_{0} + C_{\\text{penalty}} \\cdot p \\cdot r\n$$\n归一化吞吐量 $T(r)$ 定义为有效每周期指令数 ($IPC_{\\text{eff}}$) 与基准 IPC ($IPC_{0}$) 的比率。使用关系式 $IPC = \\frac{1}{CPI}$：\n$$\nT(r) = \\frac{IPC_{\\text{eff}}}{IPC_{0}} = \\frac{1/CPI_{\\text{eff}}(r)}{1/CPI_{0}} = \\frac{CPI_{0}}{CPI_{\\text{eff}}(r)}\n$$\n代入 $CPI_{\\text{eff}}(r)$ 的表达式：\n$$\nT(r) = \\frac{CPI_{0}}{CPI_{0} + C_{\\text{penalty}} \\cdot p \\cdot r}\n$$\n可以重排此表达式以分离出对 $r$ 的依赖关系：\n$$\nT(r) = \\frac{1}{1 + \\left(\\frac{C_{\\text{penalty}} \\cdot p}{CPI_{0}}\\right) r}\n$$\n现在，我们将数值代入 $r$ 的系数中：\n$CPI_{0} = 1.2 = \\frac{6}{5}$\n$p = 0.35 = \\frac{7}{20}$\n$C_{\\text{penalty}} = 89.8 = \\frac{898}{10} = \\frac{449}{5}$\n该系数为：\n$$\n\\frac{C_{\\text{penalty}} \\cdot p}{CPI_{0}} = \\frac{\\left(\\frac{449}{5}\\right) \\cdot \\left(\\frac{7}{20}\\right)}{\\frac{6}{5}} = \\frac{449 \\cdot 7}{5 \\cdot 20} \\cdot \\frac{5}{6} = \\frac{449 \\cdot 7}{20 \\cdot 6} = \\frac{3143}{120}\n$$\n因此，归一化吞吐量 $T(r)$ 的最终闭式表达式为：\n$$\nT(r) = \\frac{1}{1 + \\frac{3143}{120} r}\n$$", "answer": "$$\n\\boxed{\\frac{1}{1 + \\frac{3143}{120} r}}\n$$", "id": "3640136"}]}