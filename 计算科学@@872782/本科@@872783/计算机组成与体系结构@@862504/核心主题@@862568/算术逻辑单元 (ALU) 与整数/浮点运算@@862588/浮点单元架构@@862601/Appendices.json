{"hands_on_practices": [{"introduction": "浮点运算的理论知识只有在实践中才能真正巩固。本节的第一个练习将引导我们直面浮点算术的一个核心挑战：灾难性抵消。通过从第一性原理出发，构造一对几乎相等但符号相反的浮点数，我们能够揭示浮点加法（在此为减法）过程中的细节，并量化其对结果精度的极端影响。这个练习将挑战你的直觉，并加深你对浮点数表示和运算局限性的理解 [@problem_id:3643224]。", "problem": "一个遵循电气与电子工程师协会 (IEEE) 754 (IEEE 754) 标准的二进制浮点单元，以 $2$ 为基数运行，精度为 $p \\ge 2$（意味着尾数有 $p$ 位，包括隐含的前导 $1$），采用规格化编码和“舍入到最近，偶数优先”的舍入模式。考虑其加法单元，该单元会对齐指数，形成尾数的精确未规格化中间和（当操作数符号不同时进行减法），通过将尾数左移一个非负整数 $s$ 同时将指数减去相同的 $s$ 来规格化结果，最后将尾数舍入到 $p$ 位。\n\n你需要构造两个可表示的输入 $x$ 和 $y$，以在此浮点加法中引发最大可能的抵消。该构造必须满足：\n- $x$ 和 $y$ 是规格化的，符号相反，并共享相同的无偏指数 $e$，且 $e$ 的选择需足够大以确保在规格化过程中不发生下溢。\n- $x \\ne -y$，使得精确和非零，但在所有此类数对中其绝对值尽可能小。\n\n令 $r = x + y$ 表示精确的实数和。将在实数大小 $z$ 处的单位末位 (ulp) 定义为在 $z$ 的指数处，相邻可表示的规格化浮点数之间的距离，即，如果 $\\operatorname{expo}(z) = E$，则 $\\operatorname{ulp}(z) = 2^{E-(p-1)}$。\n\n任务：\n1. 从规格化二进制表示和指数对齐的基本原理出发，推导在添加此类 $x$ 和 $y$ 时，加法单元必须对未规格化尾数应用的最大可能再规格化左移位数 $s(p)$。\n2. 使用“舍入到最近，偶数优先”的定义和上述 ulp 的定义，为你所构造的 $x$ 和 $y$ 确定最终的舍入误差大小，该误差以 $\\operatorname{ulp}(r)$ 为单位度量，记为 $E(p)$。\n\n以精确封闭形式的单行矩阵 $\\bigl[s(p)\\ \\ E(p)\\bigr]$ 提供你的最终答案。无需舍入。", "solution": "用户提供了一个科学上合理、定义明确且客观的问题陈述。这是计算机算术领域中的一个有效问题，具体涉及在灾难性抵消条件下对浮点加法的分析。因此，我们可以进行完整的解答。\n\n问题要求推导两个量 $s(p)$ 和 $E(p)$，它们与两个特殊构造的数 $x$ 和 $y$ 的浮点加法有关。我们先根据所给约束构造这两个数，然后利用这个构造来推导所需的量。\n\n**1. 操作数 $x$ 和 $y$ 的构造**\n\n浮点系统是二进制的（基数 $B=2$），有一个 $p$ 位的尾数，包括隐含的前导位。一个规格化数的形式为 $\\pm S \\times 2^e$，其中 $S$ 是尾数，$e$ 是无偏指数。尾数 $S$ 的形式为 $(1.f_1f_2...f_{p-1})_2$，其中 $f_i \\in \\{0, 1\\}$。因此，尾数 $S$ 的值在范围 $[1, 2 - 2^{-(p-1)}]$ 内。尾数值是量化的，形式为 $1 + k \\cdot 2^{-(p-1)}$，其中整数 $k \\in [0, 2^{p-1}-1]$。\n\n问题指定输入 $x$ 和 $y$ 必须是：\n- 规格化的和可表示的。\n- 符号相反。\n- 共享相同的无偏指数 $e$。\n- 不是彼此的相反数，即 $x \\ne -y$。\n- 精确和 $r = x+y$ 必须非零且绝对值尽可能小。\n\n设 $x > 0$ 且 $y  0$。我们可以将它们写为 $x = S_x \\cdot 2^e$ 和 $y = -S_y \\cdot 2^e$，其中 $S_x$ 和 $S_y$ 是它们各自的尾数。$S_x$ 和 $S_y$ 都是可表示的 $p$ 位尾数。精确和为 $r = x+y = (S_x - S_y) \\cdot 2^e$。\n\n为了使 $|r|$ 尽可能小但非零，我们必须选择 $S_x$ 和 $S_y$，使它们的差 $|S_x - S_y|$ 最小化且非零。由于尾数的值以 $2^{-(p-1)}$ 为间隔，两个不同尾数之间可能的最小非零差正好是 $2^{-(p-1)}$。\n\n我们可以构造这样一对数。例如，我们选择：\n- $S_y = 1.00...0_2 = 1$。\n- $S_x = 1.00...01_2 = 1 + 2^{-(p-1)}$。\n对于 $p \\ge 2$，两者都是有效的 $p$ 位尾数。\n\n通过这个选择，我们的操作数是：\n- $x = (1 + 2^{-(p-1)}) \\cdot 2^e$\n- $y = -1 \\cdot 2^e$\n\n这些操作数满足所有给定的约束。精确和是：\n$r = x+y = \\left( (1 + 2^{-(p-1)}) - 1 \\right) \\cdot 2^e = 2^{-(p-1)} \\cdot 2^e = 2^{e-(p-1)}$。\n\n**2. 再规格化移位数 $s(p)$ 的推导**\n\n浮点加法单元首先计算尾数的差，因为它们的指数相同。这个减法的未规格化结果是 $S_{unnorm} = S_x - S_y = 2^{-(p-1)}$。在二进制中，这表示为 $0.0...01$，在小数点和最后的 $1$ 之间有 $p-2$ 个零。\n\n下一步是规格化。中间结果 $r = S_{unnorm} \\cdot 2^e$ 必须转换为规格化形式 $S_{norm} \\cdot 2^{e_{new}}$，其中 $1 \\le S_{norm}  2$。这是通过将未规格化的尾数 $S_{unnorm}$ 左移 $s$ 位并同时将指数减去相同的值来实现的。\n$$ S_{norm} = S_{unnorm} \\cdot 2^s $$\n$$ e_{new} = e - s $$\n\n我们需要找到整数 $s$ 使得 $1 \\le S_{unnorm} \\cdot 2^s  2$。\n代入 $S_{unnorm} = 2^{-(p-1)}$：\n$$ 1 \\le 2^{-(p-1)} \\cdot 2^s  2 $$\n$$ 2^0 \\le 2^{s-(p-1)}  2^1 $$\n这意味着指数必须为 $0$：\n$$ s-(p-1) = 0 \\implies s = p-1 $$\n得到的规格化尾数是 $S_{norm} = 2^{-(p-1)} \\cdot 2^{p-1} = 1$，在二进制中是 $1.00...0_2$。\n\n$x$ 和 $y$ 的构造是为了最大化抵消，这等同于最大化所需的左移位数 $s$。这是通过最小化中间结果的绝对值来实现的，我们已经这样做了。任何其他相邻尾数的选择都会导致差的绝对值相同，即 $|S_x - S_y| = 2^{-(p-1)}$，因此移位数也相同。因此，在给定约束下，可能的最大移位数是 $p-1$。\n\n$$ s(p) = p-1 $$\n\n**3. 舍入误差 $E(p)$ 的确定**\n\n舍入误差是计算出的浮点结果 $\\operatorname{fl}(x+y)$ 与精确实数和 $r=x+y$ 之间差的绝对值。该误差将以 $\\operatorname{ulp}(r)$ 为单位进行度量。\n\n精确和是 $r = 2^{e-p+1}$。该和的规格化表示是 $1.0 \\times 2^{e-p+1}$。\n尾数正好是 $1.0$，指数是 $e-p+1$。这是一个可以精确表示的浮点数，前提是指数在范围内（问题陈述保证了这一点）。\n最终舍入步骤之前的中间结果是 $S_{norm} = 1.0$。这个尾数可以用 $p$ 位完美表示（一个整数位，$p-1$ 个零的小数位）。在第 $(p-1)$ 个小数位之后没有需要舍入的非零位。因此，舍入步骤不改变其值。\n最终计算结果是 $\\operatornamefl(x+y) = 1.0 \\times 2^{e-p+1} = r$。\n\n绝对舍入误差是 $|\\operatorname{fl}(x+y) - r| = |r-r| = 0$。\n\n量 $E(p)$ 是以 $\\operatorname{ulp}(r)$ 为单位度量的这个误差。\n首先，我们求 $\\operatorname{ulp}(r)$。$r$ 的指数是 $\\operatorname{expo}(r) = e-p+1$。\n使用给定的定义，$\\operatorname{ulp}(z) = 2^{\\operatorname{expo}(z)-(p-1)}$：\n$$ \\operatorname{ulp}(r) = 2^{(e-p+1) - (p-1)} = 2^{e-2p+2} $$\n由于 $e$ 足够大，$\\operatorname{ulp}(r)$ 是一个明确定义的正值。\n\n以 $\\operatorname{ulp}(r)$ 为单位的误差大小是：\n$$ E(p) = \\frac{|\\operatorname{fl}(x+y) - r|}{\\operatorname{ulp}(r)} = \\frac{0}{\\operatorname{ulp}(r)} = 0 $$\n\n这个结果可以通过 Sterbenz 引理来证实，该引理指出，如果 $x$ 和 $y$ 是浮点数，使得 $\\frac{1}{2} \\le \\frac{|x|}{|y|} \\le 2$，那么它们的差 $\\operatorname{fl}(|x|-|y|)$ 是精确计算的。在我们的例子中，$x$ 和 $y$ 具有相同的指数 $e$。设它们的尾数分别为 $S_x$ 和 $S_y$。如前所示，$1 \\le S_x, S_y  2$。因此，$\\frac{1}{2}  \\frac{S_x}{S_y}  2$，这意味着 $\\frac{1}{2}  \\frac{|x|}{|y|}  2$。引理的条件得到满足，保证了减法的结果是精确的。舍入误差必然为零。\n\n最终答案由推导出的两个量 $s(p)$ 和 $E(p)$ 组成。\n$$ s(p) = p-1 $$\n$$ E(p) = 0 $$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\np-1  0\n\\end{pmatrix}\n}\n$$", "id": "3643224"}, {"introduction": "在理解了浮点运算的极端情况后，下一步是深入其硬件实现的复杂性。FPU的正确性高度依赖于对舍入逻辑（如保护位、舍入位和粘滞位）的精确实现。这个实践练习将让你扮演硬件设计验证工程师的角色，通过编程模拟一个有缺陷的加法器，并设计测试来捕捉由这个微妙错误导致的计算偏差。这是一个真正的动手练习，它将理论与FPU验证的实际挑战联系起来 [@problem_id:3643233]。", "problem": "您需要实现、分析并实证测试浮点运算单元（FPU）中加法流水线的舍入和对齐阶段，重点关注在向最近偶数舍入（round-to-nearest-even）模式下，基数为$2$的 IEEE-754 单精度加法中的保护位、舍入位和粘滞位的逻辑。考虑两个严格为正的 IEEE-754 单精度浮点数 $x$ 和 $y$，其无偏指数分别为 $e_x$ 和 $e_y$。设小数域的精度为 $p=23$，因此包括隐藏位在内的有效尾数宽度为 $p+1=24$。您的任务是构造并检测一个故障模式，其中未对齐的粘滞位生成会在 $\\lvert e_x - e_y \\rvert  p$ 的条件下，导致 $x+y$ 的加法运算产生 $1$-ulp 的误差。\n\n您的推导和实现应基于经过充分测试的、关于 IEEE-754 二进制浮点加法和向最近偶数舍入的规范事实：\n- 电气和电子工程师协会（IEEE）754 单精度格式使用 1 位符号位、8 位偏置指数（偏置值为 127）和 23 位小数域。正规数的尾数为 $1.f$，其中 $f$ 是小数域。在最小指数 $e_{\\min}=-126$ 时，次正规数的尾数为 $0.f$。\n- 为了计算 $x$ 和 $y$ 的和，其中 $\\lvert e_x - e_y \\rvert = k \\ge 0$，将较小的尾数右移 $k$ 位进行对齐。设 $m_x$ 和 $m_y$ 表示 24 位的尾数（对于正规数包含隐藏位，对于次正规数仅为小数部分）。对齐后，定义保护位 $G$ 为对齐后较大尾数最低有效位紧邻的下一位，舍入位 $R$ 为 $G$ 紧邻的下一位，粘滞位 $S$ 为 $R$ 之后所有剩余位的逻辑或。向最近偶数舍入的规则为：如果 $G=0$，则向下舍入；如果 $G=1$ 且 $S=1$（严格大于一半）或舍入前的最低有效位为 $1$（平局则向偶数舍入），则向上舍入。\n- 如果对齐后的加法产生进位，则通过将和右移 1 位并增加指数来进行重新规格化；使用移出的位和先前收集的小数余数重新计算新的保护位和粘滞位。\n\n需要实现的故障模式：一个未对齐的粘滞位，在计算粘滞位时，保护位紧邻的下一位（即舍入位）被错误地从逻辑或累加中省略。具体来说，定义正确的粘滞位 $S_{\\text{corr}} = R \\lor S_{\\text{tail}}$ 和错误的粘滞位 $S_{\\text{bug}} = S_{\\text{tail}}$；在产生进位和重新规格化后，定义 $S'_{\\text{corr}} = G_{\\text{prev}} \\lor S_{\\text{corr}}$ 但 $S'_{\\text{bug}} = S_{\\text{corr}}$（错误地忽略了之前的保护位）。当 $\\lvert e_x - e_y \\rvert  p$ 且特别是当 $k=p+1=24$ 时，这可能导致 $1$-ulp 误差，因为此时保护位源自较小正规操作数的隐藏位，而 $R$ 是该操作数小数域的最高有效位，这使得错误的省略会产生影响。\n\n编程任务：\n- 为严格为正的 IEEE-754 单精度输入 $x$ 和 $y$ 实现一个参考加法例程，该例程模拟上述的保护/舍入/粘滞逻辑，并使用向最近偶数舍入进行舍入。此例程必须是正确的。\n- 实现第二个有意的错误例程，其中粘滞位按故障模式中所述的方式计算（在重新规格化前后均从粘滞累加中省略保护位紧邻的下一位）。\n- 生成满足 $\\lvert e_x - e_y \\rvert  p$ 的随机测试数对 $(x,y)$，并使用两个例程对它们进行相加。每个数对必须严格为正，并且您可以仅限于加法（无减法）。排除包含非数字（Not-a-Number）或无穷大的数对。当两个结果在正 IEEE-754 单精度数的单调位模式排序中恰好相差最后一个单位（ulp）时，计为一次失败。就本问题而言，将 $1$-ulp 差异定义为两个正的、有限的结果，当它们的 32 位 IEEE-754 编码被视为无符号整数时，其差值恰好为 $1$。\n- 在条件 $\\lvert e_x - e_y \\rvert  p$ 中使用无偏指数，并约定次正规数的 $e_y=e_{\\min}$。\n\n测试套件：\n- 程序必须运行四个测试用例，每个用例由一个确定的伪随机种子 $s$、试验次数 $N$ 和一个间距范围 $[g_{\\min},g_{\\max}]$ 指定，用于在每次试验中从该范围均匀随机地选择 $k=\\lvert e_x - e_y \\rvert$。一个测试用例必须注入一小部分特殊值（零、次正规数、无穷大）以验证对无效输入的稳健跳过。需要实现的四个测试用例是：\n  1. $s=123456789$, $N=100000$, $g_{\\min}=24$, $g_{\\max}=24$（理想路径，此时未对齐最可能产生影响）。\n  2. $s=987654321$, $N=100000$, $g_{\\min}=25$, $g_{\\max}=25$（边界之外，来自较小操作数的保护位消失；预期失败次数会少得多或没有）。\n  3. $s=13579$, $N=150000$, $g_{\\min}=24$, $g_{\\max}=30$（混合了边界和非边界间距）。\n  4. $s=24680$, $N=50000$, $g_{\\min}=24$, $g_{\\max}=24$，并注入特殊值（跳过无效值；仅对有效加法计数）。\n- 对于每个测试用例，输出一个整数：在满足 $\\lvert e_x - e_y \\rvert  p$ 且产生有限、正结果的数对中观察到的 $1$-ulp 失败次数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是测试用例 $i$ 的 $1$-ulp 失败次数的整数计数。不应打印任何其他文本。\n\n不涉及物理单位或角度；所有量都是无量纲的。确保完全遵守上述指定的格式和约束。程序必须完全自包含，不需要任何输入。", "solution": "用户提供了一个问题，要求对浮点加法流水线中的一个特定故障模式进行仿真和分析。任务是为 IEEE-754 单精度数实现一个正确的和一个有故障的加法例程，并在特定条件下统计两者之间的差异。\n\n### 问题验证\n\n**步骤 1：提取给定信息**\n\n- **领域**：浮点运算单元（FPU）架构，IEEE-754 单精度加法。\n- **输入**：两个严格为正的单精度浮点数，$x$ 和 $y$。\n- **精度 ($p$)**：小数部分为 $p=23$ 位，有效尾数宽度为 $p+1=24$。\n- **约束**：无偏指数之差 $k = \\lvert e_x - e_y \\rvert$ 必须大于 $p$。\n- **舍入模式**：向最近偶数舍入 (Round-to-nearest-even)。\n- **舍入逻辑**：如果保护位 $G=0$，向下舍入。如果 $G=1$，且粘滞位 $S=1$ 或舍入前的最低有效位为 $1$，则向上舍入。这在逻辑上等同于如果 $G \\land (S \\lor \\text{LSB})$ 为真则向上舍入。\n- **保护位、舍入位、粘滞位 (GRS)**：\n    - $G$：对齐过程中移出的第一位。\n    - $R$：移出的第二位。\n    - $S_{\\text{tail}}$：在 $R$ 之后移出的所有位的逻辑或。\n- **正确的粘滞位 ($S_{\\text{corr}}$)**：问题定义了一个复合粘滞位 $S_{\\text{corr}} = R \\lor S_{\\text{tail}}$。这个复合位在舍入逻辑中用作 $S$。\n- **错误的粘滞位 ($S_{\\text{bug}}$)**：错误是一种遗漏。$S_{\\text{bug}} = S_{\\text{tail}}$，错误地忽略了舍入位 $R$。\n- **重新规格化错误**：提供了一个关于加法后重新规格化的次要错误描述。正确的新粘滞位：$S'_{\\text{corr}} = G_{\\text{prev}} \\lor S_{\\text{corr}}$。错误的新粘滞位：$S'_{\\text{bug}} = S_{\\text{corr}}$。这个描述存在轻微的歧义，因为一个有错误的单元不应期望能计算出正确的值 ($S_{\\text{corr}}$)。对该错误性质（“遗漏”）更一致的解释是，错误的重新规格化也忽略了进入粘滞区域的最高位（即旧的保护位）。然而，分析表明，对于主要测试用例 ($k=24$)，不会触发重新规格化，使得这个歧义不那么关键。\n- **失败条件**：当正确和错误的加法结果相差恰好一个最低有效单位（ULP）时，计为一次失败。ULP 差异定义为它们的 32 位整数表示相差 1。\n- **测试用例**：指定了四个测试用例，具有不同的伪随机种子 ($s$)、试验次数 ($N$) 和指数差值范围 ($[g_{\\min}, g_{\\max}]$)。\n\n**步骤 2：使用提取的给定信息进行验证**\n\n1.  **科学严谨性**：问题在计算机算术和 IEEE-754 浮点标准原理方面基础扎实。所描述的舍入逻辑、GRS 位和对齐过程是 FPU 设计中的标准概念。指定的错误是一个合理的硬件故障。\n2.  **良构性**：问题是良构的。给定一个确定的种子，测试对的生成是可复现的，并且正确和错误加法的逻辑都已指定，从而可以为每个测试用例计算出唯一的、可计算的失败次数。\n3.  **客观性**：问题以客观、形式化的术语陈述。\n4.  **完整性和一致性**：问题基本上是自包含的。重新规格化错误描述中的轻微歧义是一个小瑕疵，但它不影响解决方案，因为测试用例所针对的主要故障模式 ($k=24$) 不涉及重新规格化。指定的舍入规则 `$G \\land (S \\lor \\text{LSB})$`，其中 $S=R \\lor S_{\\text{tail}}$，是向最近偶数舍入的一个逻辑上紧凑且正确的表述。\n\n**步骤 3：结论与行动**\n\n问题被判定为**有效**。问题描述次要部分中的轻微歧义，并不妨碍基于对主要描述故障的一致解释，实现一个稳健且正确的解决方案。\n\n### 基于原则的设计与解决方案\n\n该解决方案涉及在位级别上模拟浮点加法，以捕捉舍入的细微差别。一个正确的实现将作为参考，而第二个实现将包含指定的粘滞位错误。\n\n**1. 数据表示**\n一个浮点数被分解为其符号、指数和尾数。为了方便计算，我们将对正规数和次正规数使用统一的内部表示：一个整数尾数 $s$ 和一个二的幂指数 $e$，使得数值为 $s \\times 2^e$。\n- 对于一个无偏指数为 $e_{\\text{unbiased}}$、小数部分为 $f$ 的正规数，其尾数为 $1.f$。我们将其表示为一个整数 $s = (1 \\ll 23) | f$（一个 24 位整数），指数为 $e = e_{\\text{unbiased}} - 23$。\n- 对于一个次正规数，其值为 $0.f \\times 2^{-126}$。我们将其表示为 $s = f$，指数为 $e = -126 - 23 = -149$。\n这个方案确保数值始终为 $s \\times 2^e$，并且指数差能正确决定对齐所需的移位数。\n\n**2. 加法算法仿真**\n`add` 函数将执行以下步骤：\n- **解包**：将两个输入的 `unsigned int`（代表 `float`）值转换为我们的内部 `{尾数, 指数}` 表示。根据问题要求处理特殊情况，如零、无穷大和 NaN（跳过无效数对）。\n- **对齐操作数**：确定指数较大的操作数。设其为 $x$，另一个为 $y$。移位量为 $k = e_x - e_y$，其中 $e_x, e_y$ 是 IEEE 无偏指数。将 $y$ 的尾数 $s_y$ 右移 $k$ 位。\n- **计算 GRS 和粘滞位**：从 $s_y$ 中移出的 $k$ 位用于计算保护位 ($G$)、舍入位 ($R$) 和粘滞尾部 ($S_{\\text{tail}}$)。\n    - $G$ 是移出的最高有效位。\n    - $R$ 是移出的次高有效位。\n    - $S_{\\text{tail}}$ 是在 $R$ 之后移出的所有剩余位的逻辑或。\n- **计算复合粘滞位**：错误在此处注入。\n    - **正确**：$S_{\\text{composite}} = R \\lor S_{\\text{tail}}$。\n    - **错误**：$S_{\\text{composite}} = S_{\\text{tail}}$。\n- **尾数求和**：将 $y$ 的对齐后尾数加到 $x$ 的尾数上。$s_{\\text{sum}} = s_x + (s_y \\gg k)$。我们使用 64 位整数以防止中间计算溢出。\n- **规格化（加法后）**：如果尾数和溢出（即需要超过 24 位），则必须将和右移一位，并增加指数。相应地更新 GRS 位。从和中移出的最低有效位成为新的 $G$，旧的 $G$ 成为新的 $R$，旧的 $R$ 和 $S_{\\text{tail}}$ 组成新的粘滞部分。错误被一致地传播：新的错误复合粘滞位将再次忽略其最高位分量（即旧的 $R$）。\n- **舍入**：根据计算出的 $G$ 和 $S_{\\text{composite}}$ 位对和进行舍入。如果 $G \\land (S_{\\text{composite}} \\lor \\text{LSB}_{\\text{sum}})$ 为真，则向上舍入。如果向上舍入导致再次溢出，则执行最终的规格化。\n- **打包**：将最终的尾数和指数转换回 IEEE-754 单精度 `unsigned int` 格式，处理潜在的上溢（到无穷大）或下溢（到零）。\n\n**3. 故障检测**\n当错误的逻辑由于不正确的舍入决策而产生与正确逻辑不同的结果时，就会发生故障。问题所针对的特定情况发生在：\n- $k=24$。\n- 较小的操作数 $y$ 的尾数隐藏位为 $1$，其小数部分的最高有效位为 $1$，所有其他小数位为 $0$。这使得 $G=1$, $R=1$, 且 $S_{\\text{tail}}=0$。\n- 较大的操作数 $x$ 的尾数最低有效位为 $0$。\n\n在这种情景下：\n- **正确路径**：$S_{\\text{composite}} = R \\lor S_{\\text{tail}} = 1 \\lor 0 = 1$。条件是严格大于一半 ($G=1, S_{\\text{composite}}=1$)，所以向上舍入。\n- **错误路径**：$S_{\\text{composite}} = S_{\\text{tail}} = 0$。条件是恰好一半 ($G=1, S_{\\text{composite}}=0$)。由于 $x$ 的最低有效位为 $0$，它会向偶数舍入，即向下舍入（截断）。\n\n这种舍入决策上的分歧导致最终结果产生 $1$-ULP 的差异。实现将生成满足测试用例约束的随机数对，并统计这种特定故障模式的发生次数。", "answer": "[0, 0, 0, 0]", "id": "3643233"}, {"introduction": "一个功能正确的FPU同样需要高性能。最后一个练习将我们的关注点从“计算是否正确”转移到“计算需要多长时间”。通过构建一个简化的周期级性能模型，我们将量化浮点加法操作的延迟如何受输入数据特征的影响。这个练习 [@problem_id:3643299] 揭示了，由于数据相关的操作（如对阶和规格化），并非所有加法指令的执行时间都相同，这有助于我们理解FPU流水线中的性能瓶颈。", "problem": "要求您为浮点单元 (FPU) 中的浮点加/减法数据通路设计并实现一个周期级时序模型。该模型需要分离出规格化延迟，并将其与阶码差和前导零预测 (LZA) 关联起来。您的程序必须为一组类似微基准测试的测试用例计算预测的周期数，这些测试用例的绝对阶码差 $|E_x - E_y|$ 和有效数中的相消程度各不相同。目标是建模对齐移位器和规格化硬件如何影响总周期数。\n\n请基于以下基础和架构事实开始：\n- 算术运算遵循 IEEE $754$ 单精度二进制格式，其字段包括：符号 $S \\in \\{0,1\\}$、无偏阶码 $E \\in \\mathbb{Z}$ 和小数部分 $F \\in \\{0,1,\\dots,2^{23}-1\\}$。规格化的操作数在其有效数中有一个隐含的前导1。将操作数的 $24$ 位整数有效数表示为 $M = 2^{23} + F$。\n- 浮点加/减法在对对齐后的数值执行有符号加/减法之前，通过将较小阶码的有效数右移 $d = |E_x - E_y|$ 位来对其进行对齐。\n- 加法后规格化要求在因相消产生前导零时将结果左移，或在有进位溢出时右移一位，以恢复前导1。前导零预测 (LZA) 是一种用于预测前导零数量以驱动规格化的逻辑；实际需要的左移位数等于加法后数值中的前导零数量。\n- 用于对齐的实际桶形移位器每周期吞吐量有限。假设对齐硬件每周期可以移位 $w_a = 8$ 位。流水线包含一个对齐周期；当 $d$ 超过 $w_a$ 时，会产生额外的对齐停顿周期。\n- 规格化硬件同样具有有限的每周期吞吐量。假设规格化硬件每周期可以左移 $w_n = 4$ 位。流水线不包含用于可变左规格化的专用周期；任何需要的左规格化都会导致停顿周期。\n- 加/减法操作的基准流水线深度（不包括停顿）为 $C_0 = 4$ 个周期（比较/准备、对齐、加/减、舍入/打包）。停顿是累加的。\n\n基于以上信息，定义用于计算预测周期数 $C_{\\text{total}}$ 的时序模型：\n1. 计算 $d = |E_x - E_y|$。\n2. 令 $M_x = 2^{23} + F_x$ 和 $M_y = 2^{23} + F_y$ 为 $24$ 位有效数整数。将阶码较大的操作数确定为参考操作数；如果阶码相等，则将 $M$ 较大的操作数确定为参考操作数。将阶码较小的有效数右移 $d$ 位以进行对齐。\n3. 执行数值操作：如果 $S_x = S_y$，则对齐后的数值为 $R = M_{\\text{large}} + M_{\\text{small, aligned}}$；否则，$R = |M_{\\text{large}} - M_{\\text{small, aligned}}|$。\n4. 确定所需的规格化：\n   - 如果 $R = 0$，则设 $L = 24$。\n   - 否则，如果 $R \\ge 2^{24}$ (进位溢出)，则设 $L = 0$。\n   - 否则，$L$ 是 $R$ 的 $24$ 位表示中的前导零数量（最高有效位之前的零位数）。\n5. 对齐停顿周期：$S_a = \\max\\left(0, \\left\\lceil \\frac{d}{w_a} \\right\\rceil - 1\\right)$。\n6. 规格化停顿周期：$S_n = \\left\\lceil \\frac{L}{w_n} \\right\\rceil$。\n7. 总预测周期数：$C_{\\text{total}} = C_0 + S_a + S_n$。\n\n请实现一个程序，根据上述模型为下面的每个测试用例计算 $C_{\\text{total}}$。所有操作数均为 IEEE $754$ 单精度规格化值，由其字段 $(S, E, F)$ 指定，其中 $S$ 是符号位，$E$ 是无偏阶码，$F$ 是 $23$ 位小数部分的整数。在您的模型中使用整数算术，并将 $E$ 视为抽象整数字段；您无需重构浮点数。\n\n测试套件：\n- 用例 $1$ (理想路径，阶码相等，无相消，有进位溢出): $(S_x, E_x, F_x) = (0, 100, 0x000000)$, $(S_y, E_y, F_y) = (0, 100, 0x400000)$。\n- 用例 $2$ (大范围对齐，最小化规格化): $(S_x, E_x, F_x) = (0, 120, 0x200000)$, $(S_y, E_y, F_y) = (0, 90, 0x100000)$。\n- 用例 $3$ (符号相反，中度相消): $(S_x, E_x, F_x) = (0, 100, 0x010000)$, $(S_y, E_y, F_y) = (1, 100, 0x00F000)$。\n- 用例 $4$ (符号相反，极端相消): $(S_x, E_x, F_x) = (0, 100, 0x000001)$, $(S_y, E_y, F_y) = (1, 100, 0x000000)$。\n- 用例 $5$ (对齐超出有效数宽度): $(S_x, E_x, F_x) = (0, 150, 0x000000)$, $(S_y, E_y, F_y) = (0, 110, 0x000000)$。\n- 用例 $6$ (阶码相等，大小数部分，有进位溢出，无规格化左移): $(S_x, E_x, F_x) = (0, 10, 0x7FFFFF)$, $(S_y, E_y, F_y) = (0, 10, 0x7FFFFF)$。\n\n所需输出：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$），其中每个 $result_i$ 是按上述顺序列出的相应测试用例的整数 $C_{\\text{total}}$。", "solution": "该问题要求为浮点加/减法单元设计一个周期级时序模型。为确保问题是可解的，首先执行验证过程。\n\n### 问题验证\n\n**步骤 1：提取的已知条件**\n- **算术标准：** IEEE $754$ 单精度二进制格式。\n- **操作数字段：** 符号 $S \\in \\{0,1\\}$、无偏阶码 $E \\in \\mathbb{Z}$、小数部分 $F \\in \\{0,1,\\dots,2^{23}-1\\}$。\n- **有效数表示：** 对于规格化操作数，其 $24$ 位有效数整数为 $M = 2^{23} + F$。\n- **对齐移位：** 阶码较小的操作数的有效数右移 $d = |E_x - E_y|$ 位。\n- **硬件吞吐量：**\n    - 对齐移位器宽度：$w_a = 8$ 位/周期。\n    - 规格化移位器宽度：$w_n = 4$ 位/周期。\n- **基准周期：** $C_0 = 4$ 周期。\n- **总周期 ($C_{\\text{total}}$) 的时序模型：**\n    1.  计算阶码差 $d = |E_x - E_y|$。\n    2.  定义有效数 $M_x = 2^{23} + F_x$ 和 $M_y = 2^{23} + F_y$。阶码较大的操作数是参考操作数。如果阶码相等，有效数 $M$ 较大的操作数是参考操作数。另一个操作数的有效数通过右移 $d$ 位进行对齐。\n    3.  计算对齐后的数值 $R$。如果 $S_x = S_y$，则 $R = M_{\\text{large}} + M_{\\text{small, aligned}}$。如果 $S_x \\neq S_y$，则 $R = |M_{\\text{large}} - M_{\\text{small, aligned}}|$。\n    4.  确定规格化左移量 $L$：如果 $R = 0$，则 $L = 24$；如果 $R \\ge 2^{24}$，则 $L = 0$；否则，$L$ 是 $R$ 的 $24$ 位表示中的前导零数量。\n    5.  对齐停顿周期为 $S_a = \\max\\left(0, \\left\\lceil \\frac{d}{w_a} \\right\\rceil - 1\\right)$。\n    6.  规格化停顿周期为 $S_n = \\left\\lceil \\frac{L}{w_n} \\right\\rceil$。\n    7.  总周期为 $C_{\\text{total}} = C_0 + S_a + S_n$。\n- **测试套件：** 六个由 $(S, E, F)$ 三元组定义的测试用例。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于计算机体系结构的原理，特别是浮点单元的设计。所描述的流水线阶段（对齐、ALU操作、规格化）以及由可变延迟操作（移位）引起的流水线停顿的概念都是标准且符合实际的。\n- **适定性：** 问题陈述为计算总周期数提供了一个完整、明确且确定性的算法。所有必需的常量（$C_0, w_a, w_n$）、停顿公式（$S_a, S_n$）和输入数据都已明确定义。每个测试用例都存在唯一的解。\n- **客观性：** 问题以精确、量化和客观的语言陈述，不含任何主观性或意见。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个应用微体系结构性能模型的明确定义的练习。解决方案将通过将给定的模型应用于每个测试用例来继续进行。\n\n### 求解推导\n\n每个测试用例的总周期数 $C_{\\text{total}}$ 是通过遵循指定的时序模型来计算的。常量为 $C_0 = 4$，$w_a = 8$ 和 $w_n = 4$。\n\n**用例 1：** $(S_x, E_x, F_x) = (0, 100, 0x0)$, $(S_y, E_y, F_y) = (0, 100, 0x400000)$\n1.  $d = |100 - 100| = 0$。\n2.  $M_x = 2^{23} + 0x0 = 0x800000$。$M_y = 2^{23} + 0x400000 = 0xC00000$。\n3.  阶码相等，且 $M_y  M_x$，因此操作数 $y$ 是参考操作数。$M_{\\text{large}} = M_y$，$M_{\\text{small}} = M_x$。\n4.  符号相等 ($S_x = S_y = 0$)。由于 $d=0$，$M_{\\text{small, aligned}} = M_x$。\n5.  $R = M_y + M_x = 0xC00000 + 0x800000 = 0x1400000$。\n6.  $R \\ge 2^{24}$，表示有进位溢出。因此，$L=0$。\n7.  $S_a = \\max(0, \\lceil 0/8 \\rceil - 1) = 0$。\n8.  $S_n = \\lceil 0/4 \\rceil = 0$。\n9.  $C_{\\text{total}} = 4 + 0 + 0 = 4$。\n\n**用例 2：** $(S_x, E_x, F_x) = (0, 120, 0x200000)$, $(S_y, E_y, F_y) = (0, 90, 0x100000)$\n1.  $d = |120 - 90| = 30$。\n2.  $M_x = 2^{23} + 0x200000 = 0xA00000$。$M_y = 2^{23} + 0x100000 = 0x900000$。\n3.  $E_x  E_y$，因此操作数 $x$ 是参考操作数。$M_{\\text{large}} = M_x$，$M_{\\text{small}} = M_y$。\n4.  符号相等。较小操作数的有效数被对齐：$M_{\\text{small, aligned}} = M_y \\gg 30 = 0$。\n5.  $R = M_x + 0 = 0xA00000$。\n6.  结果 $R$ 是一个 $24$ 位值，其最高有效位在位置 $23$。它已经被规格化。因此，$L=0$。\n7.  $S_a = \\max(0, \\lceil 30/8 \\rceil - 1) = \\max(0, 4 - 1) = 3$。\n8.  $S_n = \\lceil 0/4 \\rceil = 0$。\n9.  $C_{\\text{total}} = 4 + 3 + 0 = 7$。\n\n**用例 3：** $(S_x, E_x, F_x) = (0, 100, 0x010000)$, $(S_y, E_y, F_y) = (1, 100, 0x00F000)$\n1.  $d = |100 - 100| = 0$。\n2.  $M_x = 2^{23} + 0x010000 = 0x810000$。$M_y = 2^{23} + 0x00F000 = 0x80F000$。\n3.  阶码相等，且 $M_x  M_y$，因此 $x$ 是参考操作数。$M_{\\text{large}} = M_x$，$M_{\\text{small}} = M_y$。\n4.  符号不同。由于 $d=0$，$M_{\\text{small, aligned}} = M_y$。\n5.  $R = |M_x - M_y| = |0x810000 - 0x80F000| = 0x1000$。\n6.  $R = 0x1000 = 2^{12}$。作为一个 $24$ 位数，其最高有效位在索引 $12$ 处。前导零的数量为 $L = 23 - 12 = 11$。\n7.  $S_a = \\max(0, \\lceil 0/8 \\rceil - 1) = 0$。\n8.  $S_n = \\lceil 11/4 \\rceil = 3$。\n9.  $C_{\\text{total}} = 4 + 0 + 3 = 7$。\n\n**用例 4：** $(S_x, E_x, F_x) = (0, 100, 0x000001)$, $(S_y, E_y, F_y) = (1, 100, 0x000000)$\n1.  $d = |100 - 100| = 0$。\n2.  $M_x = 2^{23} + 0x1 = 0x800001$。$M_y = 2^{23} + 0x0 = 0x800000$。\n3.  阶码相等，$M_x  M_y$，因此 $x$ 是参考操作数。$M_{\\text{large}} = M_x$，$M_{\\text{small}} = M_y$。\n4.  符号不同。$M_{\\text{small, aligned}} = M_y$。\n5.  $R = |M_x - M_y| = |0x800001 - 0x800000| = 1$。\n6.  结果 $R=1$。作为一个 $24$ 位数，其最高有效位在索引 $0$ 处。前导零的数量为 $L = 23 - 0 = 23$。\n7.  $S_a = \\max(0, \\lceil 0/8 \\rceil - 1) = 0$。\n8.  $S_n = \\lceil 23/4 \\rceil = 6$。\n9.  $C_{\\text{total}} = 4 + 0 + 6 = 10$。\n\n**用例 5：** $(S_x, E_x, F_x) = (0, 150, 0x0)$, $(S_y, E_y, F_y) = (0, 110, 0x0)$\n1.  $d = |150 - 110| = 40$。\n2.  $M_x = 2^{23} + 0x0 = 0x800000$。$M_y = 2^{23} + 0x0 = 0x800000$。\n3.  $E_x  E_y$，因此 $x$ 是参考操作数。$M_{\\text{large}} = M_x$，$M_{\\text{small}} = M_y$。\n4.  符号相等。$M_{\\text{small, aligned}} = M_y \\gg 40 = 0$。\n5.  $R = M_x + 0 = 0x800000$。\n6.  结果已经被规格化。因此，$L=0$。\n7.  $S_a = \\max(0, \\lceil 40/8 \\rceil - 1) = \\max(0, 5 - 1) = 4$。\n8.  $S_n = \\lceil 0/4 \\rceil = 0$。\n9.  $C_{\\text{total}} = 4 + 4 + 0 = 8$。\n\n**用例 6：** $(S_x, E_x, F_x) = (0, 10, 0x7FFFFF)$, $(S_y, E_y, F_y) = (0, 10, 0x7FFFFF)$\n1.  $d = |10 - 10| = 0$。\n2.  $M_x = 2^{23} + 0x7FFFFF = 0xFFFFFF$。$M_y = 2^{23} + 0x7FFFFF = 0xFFFFFF$。\n3.  阶码相等，且 $M_x = M_y$。我们可以选择 $x$ 作为参考操作数。$M_{\\text{large}} = M_x$，$M_{\\text{small}} = M_y$。\n4.  符号相等。$M_{\\text{small, aligned}} = M_y$。\n5.  $R = M_x + M_y = 0xFFFFFF + 0xFFFFFF = 0x1FFFFFE$。\n6.  $R \\ge 2^{24}$，表示有进位溢出。因此，$L=0$。\n7.  $S_a = \\max(0, \\lceil 0/8 \\rceil - 1) = 0$。\n8.  $S_n = \\lceil 0/4 \\rceil = 0$。\n9.  $C_{\\text{total}} = 4 + 0 + 0 = 4$。\n\n六个用例的最终计算出的周期数是 $[4, 7, 7, 10, 8, 4]$。", "answer": "[4, 7, 7, 10, 8, 4]", "id": "3643299"}]}