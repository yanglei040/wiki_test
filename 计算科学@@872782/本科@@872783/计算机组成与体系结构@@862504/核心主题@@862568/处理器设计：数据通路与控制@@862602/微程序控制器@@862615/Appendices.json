{"hands_on_practices": [{"introduction": "微程序控制单元的核心是控制存储器，它是一块存放微指令的专用存储器。本练习旨在将处理器数据通路的抽象控制需求转化为具体的物理实现。通过这个练习，你将亲手确定这个关键存储部件所需的尺寸——包括其宽度（每个微指令的位数）和深度（微指令的总数），从而为设计一个完整的控制单元打下坚实的基础。[@problem_id:3660292]", "problem": "要求您为一个实现了$32$条指令的指令集架构（ISA）的多周期处理器数据通路设计一个微程序控制存储器。微码编码必须确保所有多路选择器的选择都采用独热控制，并且加载和写入操作采用显式的单比特选通。请使用以下关于微程序控制和多周期数据通路的科学基础假设：一条微指令是一个固定宽度的字，其比特位直接门控控制信号；一个$k$路选择器的独热编码使用$k$条不同的控制线，其中有且仅有一条被置为有效以选择一个源；控制存储器的深度等于在所选微码组织下实现指令序列所需的不同微指令的数量。\n\n该数据通路具有以下控制点，每个控制点都必须按照指定的独热或选通约定在微指令中表示：\n\n- 内存地址源选择器 $\\mathrm{IorD}$：$2$个选项$\\{ \\mathrm{PC}, \\mathrm{ALUOut} \\}$，使用$2$条线进行独热编码。\n- 算术逻辑单元（ALU）输入A选择器 $\\mathrm{ALUSrcA}$：$2$个选项$\\{ \\mathrm{PC}, \\mathrm{A} \\}$，使用$2$条线进行独热编码。\n- 算术逻辑单元（ALU）输入B选择器 $\\mathrm{ALUSrcB}$：$4$个选项$\\{ \\mathrm{B}, \\mathrm{const}\\ 4, \\mathrm{Imm}, \\mathrm{Imm}\\ll 2 \\}$，使用$4$条线进行独热编码。\n- 程序计数器源选择器 $\\mathrm{PCSource}$：$3$个选项$\\{ \\mathrm{ALUResult}, \\mathrm{ALUOut}, \\mathrm{JumpAddr} \\}$，使用$3$条线进行独热编码。\n- 寄存器目标选择器 $\\mathrm{RegDst}$：$3$个选项$\\{ rt, rd, r_{31} \\}$，使用$3$条线进行独热编码。\n- 寄存器写回数据选择器 $\\mathrm{MemtoReg}$：$3$个选项$\\{ \\mathrm{ALUResult}, \\mathrm{MDR}, \\mathrm{PC}+4 \\}$，使用$3$条线进行独热编码。\n- ALU操作控制 $\\mathrm{ALUOp}$：$8$条独热编码线，用于已实现的ALU功能。\n- 立即数扩展选择器 $\\mathrm{ExtOp}$：$2$个选项$\\{ \\mathrm{sign\\ extend}, \\mathrm{zero\\ extend} \\}$，使用$2$条线进行独热编码。\n- 单比特选通：$\\mathrm{IRWrite}$、$\\mathrm{PCWrite}$、$\\mathrm{PCWriteCond}$、$\\mathrm{MemRead}$、$\\mathrm{MemWrite}$、$\\mathrm{RegWrite}$、$\\mathrm{MDRWrite}$、$\\mathrm{AWrite}$、$\\mathrm{BWrite}$、$\\mathrm{ALUOutWrite}$，每个都是单个控制位，共计$10$位。\n\n假设采用一种简单的微程序组织，其中每条指令都有其自己的微序列，包括其取指和译码步骤（无子程序共享或压缩）。该ISA按类别划分，各类别指令的数量和每条指令的周期要求如下：\n\n- $10$条寄存器型ALU指令：每条$4$个周期。\n- $6$条立即数型ALU指令：每条$3$个周期。\n- $5$条加载指令：每条$5$个周期。\n- $3$条存储指令：每条$4$个周期。\n- $4$条条件分支指令：每条$3$个周期。\n- $3$条跳转指令（无链接）：每条$2$个周期。\n- $1$条跳转并链接指令：$3$个周期。\n\n任务：\n\n1. 根据上述控制点和独热要求，通过列出字段及其位宽，提出一个具体的微指令格式。\n2. 运用微程序控制的基本原理，确定控制存储器的宽度（以比特为单位）和深度（以微指令为单位）。\n3. 将宽度和深度相乘，计算控制存储器中存储的总比特数。\n\n将最终的控制存储器总大小表示为单个比特数。无需四舍五入。最终答案必须是单个实数值。在$...$内陈述任何符号，并确保每个数字都以LaTeX格式出现。不要在加框的最终答案中包含单位；但是，该值应解释为比特。", "solution": "在尝试解答之前，对问题陈述进行验证。\n\n### 第1步：提取已知条件\n-   指令集架构（ISA）大小：$32$条指令。\n-   控制信号编码：所有多路选择器选择采用独热编码，加载和写入采用单比特选通。\n-   微程序组织：每条指令都有其自己的微序列，包括取指和译码。无子程序共享或压缩。\n-   控制存储器深度是不同微指令的总数。\n-   控制点和编码：\n    -   $\\mathrm{IorD}$（内存地址选择器）：$2$个选项，独热（$2$比特）。\n    -   $\\mathrm{ALUSrcA}$（ALU输入A选择器）：$2$个选项，独热（$2$比特）。\n    -   $\\mathrm{ALUSrcB}$（ALU输入B选择器）：$4$个选项，独热（$4$比特）。\n    -   $\\mathrm{PCSource}$（PC源选择器）：$3$个选项，独热（$3$比特）。\n    -   $\\mathrm{RegDst}$（寄存器目标选择器）：$3$个选项，独热（$3$比特）。\n    -   $\\mathrm{MemtoReg}$（寄存器写回数据选择器）：$3$个选项，独热（$3$比特）。\n    -   $\\mathrm{ALUOp}$（ALU操作控制）：$8$条独热线（$8$比特）。\n    -   $\\mathrm{ExtOp}$（立即数扩展选择器）：$2$个选项，独热（$2$比特）。\n    -   选通信号：$\\mathrm{IRWrite}$、$\\mathrm{PCWrite}$、$\\mathrm{PCWriteCond}$、$\\mathrm{MemRead}$、$\\mathrm{MemWrite}$、$\\mathrm{RegWrite}$、$\\mathrm{MDRWrite}$、$\\mathrm{AWrite}$、$\\mathrm{BWrite}$、$\\mathrm{ALUOutWrite}$。总共$10$个单比特选通信号（$10$比特）。\n-   ISA划分和周期计数：\n    -   $10$条寄存器型ALU指令，每条$4$个周期。\n    -   $6$条立即数型ALU指令，每条$3$个周期。\n    -   $5$条加载指令，每条$5$个周期。\n    -   $3$条存储指令，每条$4$个周期。\n    -   $4$条条件分支指令，每条$3$个周期。\n    -   $3$条跳转指令，每条$2$个周期。\n    -   $1$条跳转并链接指令，$3$个周期。\n-   指令总数为$10 + 6 + 5 + 3 + 4 + 3 + 1 = 32$，与所述的ISA大小一致。\n\n### 第2步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n-   **科学基础**：该问题是计算机组成与体系结构中的一个标准练习，涉及为多周期数据通路设计微程序控制器。所有概念，如独热编码、控制存储器和多周期执行，都是该领域的基础。该设定在科学和技术上是合理的。\n-   **良构性**：该问题提供了一套完整且一致的规范，可以唯一地确定控制存储器的宽度、深度和总大小。任务定义清晰，可以从已知条件中推导出唯一解。\n-   **客观性**：该问题以精确、技术性的语言陈述，没有主观性或歧义。编码方案和数据通路组件都得到了明确定义。\n-   **完整性**：所有必要信息都已提供。每个多路选择器的选项数量、编码方案、所有控制信号的列表以及带有周期计数的指令分解都已明确给出。除了明确提供的作为设计基础的假设外，该问题不需要任何外部信息或未声明的假设。“不共享”微码序列的假设虽然是一种简化，但已明确说明，并使问题易于处理。\n\n### 第3步：结论与行动\n该问题是**有效的**。这是一个定义明确、自成体系且在计算机体系结构领域具有科学合理性的问题。可以继续进行求解过程。\n\n### 求解推导\n\n通过按顺序完成三个任务来推导出解决方案：计算微指令宽度、控制存储器深度，最后是它们的乘积。\n\n**任务1和2：控制存储器宽度和深度**\n\n首先，确定控制存储器的宽度，这等于单条微指令的宽度。问题规定微指令字的比特位直接门控数据通路控制信号。总宽度是每个控制字段所需比特数的总和。\n\n-   $\\mathrm{IorD}$（2路MUX，独热）：$2$比特\n-   $\\mathrm{ALUSrcA}$（2路MUX，独热）：$2$比特\n-   $\\mathrm{ALUSrcB}$（4路MUX，独热）：$4$比特\n-   $\\mathrm{PCSource}$（3路MUX，独热）：$3$比特\n-   $\\mathrm{RegDst}$（3路MUX，独热）：$3$比特\n-   $\\mathrm{MemtoReg}$（3路MUX，独热）：$3$比特\n-   $\\mathrm{ALUOp}$（8个功能，独热）：$8$比特\n-   $\\mathrm{ExtOp}$（2路MUX，独热）：$2$比特\n-   选通信号（$10$个独立信号）：$10 \\times 1 = 10$比特\n\n一条微指令的总宽度$W$是这些位宽的总和：\n$$W = 2 + 2 + 4 + 3 + 3 + 3 + 8 + 2 + 10 = 37 \\text{ 比特}$$\n\n接下来，确定控制存储器的深度。深度是唯一微指令的总数。问题规定了“一种简单的微程序组织，其中每条指令都有其自己的微序列，包括其取指和译码步骤（无子程序共享或压缩）”。这意味着状态（微指令）的总数是ISA中每条指令的周期计数之和。\n\n-   寄存器型ALU指令：$10 \\text{ 条指令} \\times 4 \\text{ 周期/指令} = 40$ 条微指令。\n-   立即数型ALU指令：$6 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 18$ 条微指令。\n-   加载指令：$5 \\text{ 条指令} \\times 5 \\text{ 周期/指令} = 25$ 条微指令。\n-   存储指令：$3 \\text{ 条指令} \\times 4 \\text{ 周期/指令} = 12$ 条微指令。\n-   条件分支指令：$4 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 12$ 条微指令。\n-   跳转指令：$3 \\text{ 条指令} \\times 2 \\text{ 周期/指令} = 6$ 条微指令。\n-   跳转并链接指令：$1 \\text{ 条指令} \\times 3 \\text{ 周期/指令} = 3$ 条微指令。\n\n控制存储器的总深度$D$是这些微指令数量的总和：\n$$D = 40 + 18 + 25 + 12 + 12 + 6 + 3 = 116 \\text{ 条微指令}$$\n\n**任务3：控制存储器总大小**\n\n控制存储器中的总比特数是其宽度（$W$）和深度（$D$）的乘积。\n\n$$ \\text{总大小} = W \\times D $$\n$$ \\text{总大小} = 37 \\text{ 比特} \\times 116 $$\n$$ \\text{总大小} = 4292 \\text{ 比特} $$\n\n因此，控制存储器总共需要$4292$比特。\n微指令格式包括用于`IorD`（$2$比特）、`ALUSrcA`（$2$比特）、`ALUSrcB`（$4$比特）、`PCSource`（$3$比特）、`RegDst`（$3$比特）、`MemtoReg`（$3$比特）、`ALUOp`（$8$比特）、`ExtOp`（$2$比特）的字段以及$10$个选通位，总宽度为$37$比特。控制存储器深度为$116$条微指令。总大小是这两个值的乘积。", "answer": "$$ \\boxed{4292} $$", "id": "3660292"}, {"introduction": "设计好控制存储器之后，下一个挑战便是编写高效的微码。本练习将探讨循环展开这一强大的优化技术，它能显著减少循环控制带来的开销。你将分析在执行速度（更少的动态周期）和存储空间消耗（更大的静态微码）之间的经典权衡，并在给定的硬件预算约束下，找到实现最佳性能的优化方案。[@problem_id:3659448]", "problem": "一个微程序控制器实现了一条复制固定大小内存块的复杂指令集计算机（CISC）机器指令，该指令使用一个微操作（micro-op）循环。控制存储器包含一系列由控制器执行的微指令，每条微指令恰好消耗一个处理器时钟周期。因此，该机器指令的每指令周期数（CPI）等于该指令单次运行时动态执行的微指令总数。此微码的静态控制存储器大小等于微指令字宽乘以存储的微指令数量。\n\n考虑基于循环的微码实现的以下基准：\n- 微指令字宽为 $w = 64$ 位。\n- 每次迭代，循环体为数据移动和地址更新工作执行 $p = 5$ 条微指令。\n- 每次迭代的循环控制开销（递减计数器、测试和分支）为 $h = 3$ 条微指令。\n- 循环前的固定设置开销为 $s = 12$ 条微指令，循环后的固定清理开销为 $f = 8$ 条微指令。\n- 完成块移动所需的总迭代次数为 $T = 240$。\n\n为了减少动态循环控制开销，微操作循环被展开了因子 $u$，这意味着循环体的 $u$ 个副本在控制存储器中连续排列，并在每次循环控制检查时执行。在这种展开下：\n- 每 $u$ 个连续的循环体副本产生一次循环控制开销 $h$。\n- 展开的循环组的静态代码大小等于 $u$ 个复制的循环体副本加上一组循环控制微指令。\n\n假设该指令的微码必须适应专用的控制存储器预算 $M_{\\max} = 64 \\times 83$ 位。展开因子 $u$ 必须是一个正整数，并且必须能整除 $T$，以便循环执行整数个展开组，没有剩余迭代。\n\n从上述定义和每条微指令一个周期的模型出发，推导出执行一次该指令的动态微指令数 $D(u)$ 和静态控制存储器大小 $M(u)$（以位为单位）。然后，在约束条件 $M(u) \\leq M_{\\max}$ 和 $u \\mid T$ 下，选择使 $D(u)$ 最小化的 $u$，并计算：\n- 选定的展开因子 $u$，\n- 指令的最终 CPI（等于 $D(u)$），\n- 最终的控制存储器大小 $M(u)$。\n\n以位表示控制存储器大小。无需四舍五入。按 $u$、CPI 和控制存储器大小 $M(u)$ 的顺序提供三个值作为最终答案。", "solution": "该问题是适定的，其科学基础在于计算机体系结构原理，并包含了获得唯一解所需的所有信息。因此，它是有效的。\n\n目标是找到最佳循环展开因子 $u$，以最小化块移动指令的动态微指令数 $D(u)$，同时满足对静态控制存储器大小 $M(u)$ 和 $u$ 属性的约束。\n\n首先，我们推导动态微指令数 $D(u)$ 和静态控制存储器大小 $M(u)$ 的表达式。\n\n动态微指令数，等同于每指令周期数（CPI），是设置、循环执行和清理的微指令之和。\n给定的参数如下：\n- 设置开销：$s = 12$ 条微指令\n- 清理开销：$f = 8$ 条微指令\n- 原始总迭代次数：$T = 240$\n- 每个循环体的微操作数：$p = 5$\n- 循环控制的微操作数：$h = 3$\n- 展开因子：$u$\n\n动态微指令总数 $D(u)$ 由下式给出：\n$$D(u) = s + (\\text{loop execution}) + f$$\n循环按因子 $u$ 展开。这意味着循环体被复制 $u$ 次，而循环控制逻辑（递减、测试、分支）每 $u$ 次数据移动仅执行一次。由于总的数据移动次数为 $T$，因此展开的循环组执行的次数为 $\\frac{T}{u}$。每次执行展开的循环组包含 $u$ 份循环体工作和一次循环控制开销。\n一个展开组的微指令数为 $(u \\cdot p + h)$。\n因此，循环执行部分的总微指令数为：\n$$(\\text{loop execution}) = \\left(\\frac{T}{u}\\right) \\cdot (u \\cdot p + h)$$\n展开此项，我们得到：\n$$(\\text{loop execution}) = \\frac{T}{u} \\cdot u \\cdot p + \\frac{T \\cdot h}{u} = T \\cdot p + \\frac{T \\cdot h}{u}$$\n将此代入 $D(u)$ 的表达式中：\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\n为了最小化 $D(u)$，我们观察到 $s$、$f$、$T$、$p$ 和 $h$ 都是正常数。项 $(s + f + T \\cdot p)$ 相对于 $u$ 是一个常数。因此，最小化 $D(u)$ 等价于最小化项 $\\frac{T \\cdot h}{u}$，这需要最大化展开因子 $u$。\n\n接下来，我们推导静态控制存储器大小 $M(u)$ 的表达式。该大小是静态微指令总数乘以字宽 $w = 64$ 位。整个指令的静态微码包括设置代码、单个展开的循环体和清理代码。\n静态微指令的数量是以下各项之和：\n- 设置微指令：$s$\n- 展开的循环微指令：$u \\cdot p + h$\n- 清理微指令：$f$\n静态微指令总数 = $s + f + u \\cdot p + h$。\n静态控制存储器大小 $M(u)$（以位为单位）是：\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\n这是 $u$ 的一个线性函数。\n\n问题对 $u$ 规定了两个约束：\n1. $u$ 必须是一个能整除总迭代次数 $T=240$ 的正整数。因此，$u \\in \\{1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 16, 20, 24, 30, 40, 48, 60, 80, 120, 240\\}$。\n2. 静态控制存储器大小 $M(u)$ 不得超过预算 $M_{\\max} = 64 \\times 83$ 位。\n$$M(u) \\leq M_{\\max}$$\n$$w \\cdot (s + f + u \\cdot p + h) \\leq M_{\\max}$$\n我们代入给定值：$w=64$, $s=12$, $f=8$, $p=5$, $h=3$, 以及 $M_{\\max} = 64 \\times 83 = 5312$。\n$$64 \\cdot (12 + 8 + u \\cdot 5 + 3) \\leq 5312$$\n$$64 \\cdot (23 + 5u) \\leq 5312$$\n两边同除以 $64$：\n$$23 + 5u \\leq 83$$\n$$5u \\leq 83 - 23$$\n$$5u \\leq 60$$\n$$u \\leq 12$$\n\n为了最小化 $D(u)$，我们必须找到满足两个约束的 $u$ 的最大可能值：\n1. $u$ 是 $240$ 的一个因数。\n2. $u \\leq 12$。\n\n从 $240$ 的因数列表中，小于或等于 $12$ 的最大值是 $u=12$。\n所以，选定的展开因子是 $u = 12$。\n\n现在我们为 $u=12$ 计算最终的 CPI ($D(u)$) 和控制存储器大小 ($M(u)$)。\n\nCPI 是 $D(12)$:\n$$D(u) = s + f + T \\cdot p + \\frac{T \\cdot h}{u}$$\n$$D(12) = 12 + 8 + 240 \\cdot 5 + \\frac{240 \\cdot 3}{12}$$\n$$D(12) = 20 + 1200 + \\frac{720}{12}$$\n$$D(12) = 1220 + 60 = 1280$$\n最终的 CPI 是 $1280$。\n\n控制存储器大小是 $M(12)$:\n$$M(u) = w \\cdot (s + f + u \\cdot p + h)$$\n$$M(12) = 64 \\cdot (12 + 8 + 12 \\cdot 5 + 3)$$\n$$M(12) = 64 \\cdot (20 + 60 + 3)$$\n$$M(12) = 64 \\cdot (83)$$\n$$M(12) = 5312$$\n最终的控制存储器大小是 $5312$ 位。\n\n所要求的三个值是展开因子 $u$、CPI 和控制存储器大小 $M(u)$。\n- 选定的展开因子 $u = 12$。\n- 指令的最终 CPI $D(12) = 1280$。\n- 最终的控制存储器大小 $M(12) = 5312$ 位。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n12  1280  5312\n\\end{pmatrix}\n}\n$$", "id": "3659448"}, {"introduction": "微编程的真正威力在于其管理复杂处理器行为的灵活性。最后的这个练习将在控制单元和流水线数据通路之间架起一座桥梁。你将运用微码来实现延迟转移（delayed branch）这一特性，这要求你精确地处理流水线中的冒险问题。通过量化分析不同实现策略对性能的影响，你将更深刻地理解微码在现代处理器设计中的实际应用价值。[@problem_id:3659432]", "problem": "一个微程序控制单元管理一个经典的$5$级流水线（取指令、指令译码、执行、访存、写回）。在当前的微码中（该微码实现的分支没有延迟槽），条件分支在“执行”阶段被解析；当分支被采纳时，位于“取指令”和“指令译码”阶段的接下来两条较新的指令会被清空，导致每次采纳分支产生$2$个浪费周期的分支惩罚。系统没有分支预测，未被采纳的分支不产生惩罚。基础（无冒险）的每指令周期数（CPI）为$1$。\n\n一项软件需求强制要求支持单个延迟分支槽：紧跟在分支指令后的那条指令必须总是执行，无论分支是否被采纳。硬件不能修改，只能更改微码。您必须选择一种微码变通方案，以在保持正确性的前提下，最小化期望的 CPI：\n\n- 策略 $\\mathrm{S1}$（延迟）：在分支微码中，抑制程序计数器重定向和流水线清空，时间刚好足够让下一条顺序指令继续执行并作为所需的延迟槽指令完成。这需要施加一个微码互锁，仅当分支被采纳时增加$1$个额外周期；当分支未被采纳时，没有额外成本。\n- 策略 $\\mathrm{S2}$（重放）：保留原有的分支采纳时的清空行为，然后通过微码编写一个槽重放子程序，重新注入并执行被清空的延迟槽指令。该子程序仅当分支被采纳时增加$3$个额外周期；当分支未被采纳时，没有额外成本。\n\n假设以下指令组合和分支行为能代表该工作负载：\n- 分支指令的动态比例为 $f_{b} = 0.18$。\n- 条件分支的采纳概率为 $p_{t} = 0.55$。\n\n仅使用基本定义（例如，每指令周期数 (CPI) 定义为每条完成指令的平均周期数，以及惩罚是按其事件概率加权的期望周期数），选择成本最低的微码变通方案，推导出由此产生的新 CPI，然后计算 CPI 的净变化\n$$\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}.$$\n将您最终的 $\\Delta \\mathrm{CPI}$ 数值答案四舍五入到四位有效数字，并以纯数字（无单位）形式表示。", "solution": "该问题要求在三种不同的微码实现下（一个原始配置和两种为支持延迟分支指令而提出的变通方案 S1 和 S2），对一个$5$级流水线的性能进行分析，性能以每指令周期数（CPI）衡量。目标是选择更优的变通方案，并量化由此带来的 CPI 变化。\n\n流水线处理器的总 CPI 可以表示为基础 CPI（假设没有冒险或停顿）与各种流水线惩罚所贡献的每指令额外周期数之和。通用公式为：\n$$\n\\mathrm{CPI} = \\mathrm{CPI}_{\\text{base}} + \\sum_{i} (\\text{Penalty}_{i} \\times \\text{Frequency}_{i})\n$$\n其中，$\\text{Penalty}_{i}$ 是事件 $i$ 浪费的周期数，$\\text{Frequency}_{i}$ 是事件 $i$ 平均每条指令发生的概率。\n\n本问题的给定条件是：\n- 基础（无冒险）CPI：$\\mathrm{CPI}_{\\text{base}} = 1$。\n- 分支指令的动态比例：$f_{b} = 0.18$。\n- 条件分支采纳概率：$p_{t} = 0.55$。\n\n首先，我们计算原始系统的 CPI，记为 $\\mathrm{CPI}_{\\text{old}}$。在该系统中，没有分支预测，条件分支在“执行”阶段解析。被采纳的分支通过清空“取指令”（IF）和“指令译码”（ID）阶段的指令，产生$2$个周期的惩罚。未被采纳的分支惩罚为$0$个周期。\n\n唯一的惩罚来源是被采纳的分支。平均每条指令中分支被采纳的频率是分支指令比例与分支被采纳概率的乘积：$f_b \\times p_{t}$。\n$$\n\\mathrm{Frequency}_{\\text{taken branch}} = f_{b} \\times p_{t} = 0.18 \\times 0.55 = 0.099\n$$\n因此，原始系统的 CPI 为：\n$$\n\\mathrm{CPI}_{\\text{old}} = \\mathrm{CPI}_{\\text{base}} + (\\text{被采纳分支的惩罚}) \\times (\\text{被采纳分支的频率})\n$$\n$$\n\\mathrm{CPI}_{\\text{old}} = 1 + 2 \\times (f_{b} p_{t}) = 1 + 2 \\times (0.099) = 1 + 0.198 = 1.198\n$$\n\n接下来，我们分析两种为实现单个延迟分支槽而提出的策略。延迟槽中的指令（紧跟在分支指令之后的那条）必须总是执行。我们必须选择能使期望 CPI 最小化的策略。\n\n策略 S1（延迟）：该策略引入一个微码互锁，仅当分支被采纳时增加$1$个额外周期。未被采纳的分支惩罚为$0$。\n策略 S1 的 CPI 为：\n$$\n\\mathrm{CPI}_{\\text{S1}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S1, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1 + 1 \\times (f_{b} p_{t}) = 1 + 1 \\times (0.099) = 1.099\n$$\n\n策略 S2（重放）：该策略保留原有的清空操作，但使用一个子程序重新执行被清空的延迟槽指令。此过程仅当分支被采纳时增加$3$个额外周期。未被采纳的分支惩罚为$0$。\n策略 S2 的 CPI 为：\n$$\n\\mathrm{CPI}_{\\text{S2}} = \\mathrm{CPI}_{\\text{base}} + (\\text{Penalty}_{\\text{S2, taken}}) \\times (f_{b} p_{t})\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1 + 3 \\times (f_{b} p_{t}) = 1 + 3 \\times (0.099) = 1 + 0.297 = 1.297\n$$\n\n为了选择成本最低的微码变通方案，我们比较得到的 CPI 值：\n$$\n\\mathrm{CPI}_{\\text{S1}} = 1.099\n$$\n$$\n\\mathrm{CPI}_{\\text{S2}} = 1.297\n$$\n由于 $1.099  1.297$，策略 S1 产生的期望 CPI 更低。因此，S1 是最优选择。系统的新 CPI 将是 $\\mathrm{CPI}_{\\text{new}} = \\mathrm{CPI}_{\\text{S1}} = 1.099$。\n\n最后，我们计算 CPI 的净变化 $\\Delta \\mathrm{CPI}$，其定义为新 CPI 与旧 CPI 之差。\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{new}} - \\mathrm{CPI}_{\\text{old}}\n$$\n代入推导出的值：\n$$\n\\Delta \\mathrm{CPI} = \\mathrm{CPI}_{\\text{S1}} - \\mathrm{CPI}_{\\text{old}} = 1.099 - 1.198 = -0.099\n$$\n从符号上讲，这个变化可以表示为：\n$$\n\\Delta \\mathrm{CPI} = (1 + 1 \\cdot f_{b} p_{t}) - (1 + 2 \\cdot f_{b} p_{t}) = -f_{b} p_{t}\n$$\n问题要求将最终数值答案四舍五入到四位有效数字。计算值为 $-0.099$。为了用四位有效数字表示，我们在后面添加两个零。\n$$\n\\Delta \\mathrm{CPI} = -0.09900\n$$", "answer": "$$\n\\boxed{-0.09900}\n$$", "id": "3659432"}]}