{"hands_on_practices": [{"introduction": "控制单元是处理器的“大脑”，它通过生成一系列控制信号来指挥数据在数据通路中的流动。这项练习将引导你为不同类型的指令（如R型、I型和J型）确定关键控制信号的正确值，从而将静态的模块图转化为对处理器动态执行过程的深刻理解。通过追踪每条指令的数据流，你将掌握单周期设计的核心操作原理。[@problem_id:3677903]", "problem": "一个用于类 MIPS 指令集的单周期数据通路使用以下选择信号来控制其多路复用器（Multiplexer (MUX)）、算术逻辑单元（Arithmetic Logic Unit (ALU)）和程序计数器（Program Counter (PC)）：\n\n- 第二个 ALU 操作数的输入选择由 $ALUSrc$ 控制：$ALUSrc = 0$ 选择寄存器堆的第二个读端口（$rt$ 操作数），$ALUSrc = 1$ 选择符号扩展的立即数。\n- 寄存器写回数据 MUX 由 $MemtoReg$ 控制：$MemtoReg = 0$ 选择 ALU 结果，$MemtoReg = 1$ 选择数据存储器输出。\n- 寄存器目标 MUX 由 $RegDst$ 控制：$RegDst = 0$ 选择 $rt$ 字段，$RegDst = 1$ 选择 $rd$ 字段。\n- 下一 PC MUX 分两个阶段选择：$PCSrc$ 控制在 $PC + 4$ 和分支目标之间进行选择，$Jump$ 控制在该 PC MUX 的输出和跳转目标之间进行选择。因此，$PCSrc = 0$ 选择 $PC + 4$，$PCSrc = 1$ 选择分支目标；$Jump = 0$ 保持所选值不变，$Jump = 1$ 选择跳转目标。\n\n假设一个传统的教科书式单周期控制器，其中，对于功能上不使用某个给定选择信号的指令（例如，没有寄存器写回意味着写回 MUX 是无关的），控制器仍将该未使用的选择信号驱动为 $0$。\n\n考虑以下按顺序执行的指令序列，并给定了寄存器状态，以便在运行时确定条件分支的结果：\n\n- $I_1$: add $t0, t1, t2$\n- $I_2$: lw $t3, 8(t0)$\n- $I_3$: sw $t3, 12(t0)$\n- $I_4$: beq $t1, t2, L$    初始寄存器值为 $t1 = 5$，$t2 = 5$（因此分支被采纳）\n- $I_5$: j $K$\n\n对于每条指令 $I_k$，在上述假设下，形成该指令执行期间实际驱动的位值的 $5$-元组 $\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$。哪个选项按 $I_1$ 到 $I_5$ 的顺序列出了每条 $I_k$ 的正确 $5$-元组？\n\nA.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(0, 0, 0, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 0, 1\\right)$\n\nB.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(1, 0, 1, 0, 0\\right)$\n- $I_3$: $\\left(0, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 1, 1\\right)$\n\nC.\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: $\\left(0, 1, 1, 0, 0\\right)$\n- $I_3$: $\\left(0, 0, 1, 0, 0\\right)$\n- $I_4$: $\\left(0, 0, 1, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 1, 0, 1\\right)$\n\nD.\n- $I_1$: $\\left(0, 0, 0, 0, 0\\right)$\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: $\\left(1, 0, 0, 1, 0\\right)$\n- $I_5$: $\\left(0, 0, 0, 1, 1\\right)$", "solution": "对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n\n- **数据通路**：一个用于类 MIPS 指令集的单周期数据通路。\n- **控制信号定义**：\n    - `$ALUSrc$`：控制第二个 ALU 操作数的 MUX。$ALUSrc = 0$ 选择寄存器堆的第二个读端口（`$rt$` 操作数）。$ALUSrc = 1$ 选择符号扩展的立即数。\n    - `$MemtoReg$`：控制寄存器写回数据 MUX。$MemtoReg = 0$ 选择 ALU 结果。$MemtoReg = 1$ 选择数据存储器输出。\n    - `$RegDst$`：控制寄存器目标 MUX。$RegDst = 0$ 选择 `$rt$` 字段。$RegDst = 1$ 选择 `$rd$` 字段。\n    - 下一 PC 选择：一个两阶段过程。\n        - `$PCSrc$`：控制第一个 MUX。$PCSrc = 0$ 选择 `$PC + 4$`。$PCSrc = 1$ 选择分支目标。\n        - `$Jump$`：控制第二个 MUX。$Jump = 0$ 传递第一个 MUX 的输出。$Jump = 1$ 选择跳转目标。\n- **控制器约定**：对于任何指令，如果一个选择信号在功能上不是必需的（即，它是一个“无关”条件），控制器会将该信号驱动为 $0$。\n- **指令序列和状态**：\n    - $I_1$: `add $t0, $t1, $t2`\n    - $I_2$: `lw $t3, 8($t0)`\n    - $I_3$: `sw $t3, 12($t0)`\n    - $I_4$: `beq $t1, $t2, L`，初始寄存器值为 `$t1 = 5$` 和 `$t2 = 5$`，因此分支被采纳。\n    - $I_5$: `j K`\n- **目标**：确定每条指令 $I_1$ 到 $I_5$ 的控制信号值 $5$-元组 $\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$。\n\n### 步骤2：使用提取的已知条件进行验证\n\n问题陈述在科学上基于计算机组成与体系结构的既定原则，特别是单周期类 MIPS 处理器的设计。问题表述清晰，提供了所有必要的控制信号定义、一组特定的指令，以及处理“无关项”条件的明确规则。语言客观且无歧义。该问题没有违反任何基本原则，不是不完整或矛盾的，并且可以使用数据通路控制的标准分析技术直接解决。\n\n### 步骤3：结论与行动\n\n问题陈述是**有效的**。将推导解决方案。\n\n### 控制信号元组的推导\n\n我们将分析每条指令，以确定 $5$ 个指定控制信号的值：$\\left(ALUSrc, MemtoReg, RegDst, PCSrc, Jump\\right)$。分析将遵循所提供的定义和“无关项为 $0$”的规则。\n\n**指令 $I_1$: `add $t0, $t1, $t2`**\n这是一条 R 型指令，执行 `$t0 \\leftarrow$ $t1 + $t2`。\n- `$ALUSrc$`：ALU 对两个寄存器值（`$t1` 和 `$t2`）进行相加。第二个操作数来自寄存器堆的第二个读端口，对应于 `$rt$` 字段。因此，$ALUSrc = 0$。\n- `$MemtoReg$`：ALU 操作（`$t1 + $t2`）的结果被写入目标寄存器。数据不来自存储器。因此，$MemtoReg = 0$。\n- `$RegDst$`：目标寄存器由指令的 `$rd$` 字段（`$t0`）指定。因此，$RegDst = 1$。\n- `$PCSrc$`：这不是一条分支指令。程序计数器更新为 `$PC + 4$`。因此，$PCSrc = 0$。\n- `$Jump$`：这不是一条跳转指令。因此，$Jump = 0$。\n$I_1$ 的元组是 $\\left(0, 0, 1, 0, 0\\right)$。\n\n**指令 $I_2$: `lw $t3, 8($t0)`**\n这是一条 I 型指令，将一个字从内存加载到寄存器中：`$t3 \\leftarrow Memory[$t0 + 8]`。\n- `$ALUSrc$`：ALU 通过将寄存器值（`$t0`）和符号扩展的立即数（`$8`）相加来计算内存地址。第二个 ALU 操作数是立即数。因此，$ALUSrc = 1$。\n- `$MemtoReg$`：写回寄存器堆的值是从内存加载的数据。因此，$MemtoReg = 1$。\n- `$RegDst$`：目标寄存器（`$t3`）由指令的 `$rt$` 字段指定。因此，$RegDst = 0$。\n- `$PCSrc$`：这不是一条分支指令。程序计数器更新为 `$PC + 4$`。因此，$PCSrc = 0$。\n- `$Jump$`：这不是一条跳转指令。因此，$Jump = 0$。\n$I_2$ 的元组是 $\\left(1, 1, 0, 0, 0\\right)$。\n\n**指令 $I_3$: `sw $t3, 12($t0)`**\n这是一条 I 型指令，将寄存器中的一个字存入内存：`$Memory[$t0 + 12] \\leftarrow $t3`。\n- `$ALUSrc$`：ALU 通过将寄存器值（`$t0`）和符号扩展的立即数（`$12`）相加来计算内存地址。第二个 ALU 操作数是立即数。因此，$ALUSrc = 1$。\n- `$MemtoReg$`：这条指令不写入寄存器堆（`$RegWrite$` 信号将为 $0$）。`$MemtoReg$` 信号控制一个 MUX，其输出仅在有寄存器写入时才被使用。因此，`$MemtoReg$` 是一个“无关项”。根据题目规则，它被设为 $0$。因此，$MemtoReg = 0$。\n- `$RegDst$`：与 `$MemtoReg$` 类似，此指令不写入寄存器，因此 `$RegDst$` 是一个“无关项”。根据规则，它被设为 $0$。因此，$RegDst = 0$。\n- `$PCSrc$`：这不是一条分支指令。程序计数器更新为 `$PC + 4$`。因此，$PCSrc = 0$。\n- `$Jump$`：这不是一条跳转指令。因此，$Jump = 0$。\n$I_3$ 的元组是 $\\left(1, 0, 0, 0, 0\\right)$。\n\n**指令 $I_4$: `beq $t1, $t2, L` (分支被采纳)**\n这是一条条件分支指令。如果 `$t1 == $t2`，它会跳转到标签 `$L$`。题目说明分支被采纳。\n- `$ALUSrc$`：ALU 比较两个寄存器的值（`$t1` 和 `$t2`），通常通过减法实现。第二个操作数来自寄存器堆（`$t2`，即 `$rt$` 字段）。因此，$ALUSrc = 0$。\n- `$MemtoReg$`：此指令不写入寄存器堆。`$MemtoReg$` 是一个“无关项”，并被设为 $0$。\n- `$RegDst$`：此指令不写入寄存器堆。`$RegDst$` 是一个“无关项”，并被设为 $0$。\n- `$PCSrc$`：分支被采纳。`PCSrc` MUX 必须选择分支目标地址。因此，$PCSrc = 1$。\n- `$Jump$`：这不是一条跳转指令。因此，$Jump = 0$。\n$I_4$ 的元组是 $\\left(0, 0, 0, 1, 0\\right)$。\n\n**指令 $I_5$: `j K`**\n这是一条 J 型指令，无条件跳转到标签 `$K$`。\n- `$ALUSrc$`：在跳转指令中，ALU 不用于任何功能性目的。其控制信号 `$ALUSrc$` 是一个“无关项”，并被设为 $0$。\n- `$MemtoReg$`：此指令不写入寄存器堆。`$MemtoReg$` 是一个“无关项”，并被设为 $0$。\n- `$RegDst$`：此指令不写入寄存器堆。`$RegDst$` 是一个“无关项”，并被设为 $0$。\n- `$PCSrc$`：下一个 PC 由跳转目标决定，而不是分支目标。与分支相关的控制信号将处于非活动状态。`$PCSrc$` 是一个“无关项”，并被设为 $0$。`$PC+4$`/分支 MUX 的输出是无关紧要的，因为下一个 MUX 将选择跳转目标。\n- `$Jump$`：这是一条跳转指令。最终的 PC 选择 MUX 必须选择跳转目标地址。因此，$Jump = 1$。\n$I_5$ 的元组是 $\\left(0, 0, 0, 0, 1\\right)$。\n\n### 推导元组总结\n- $I_1$: `add` $\\rightarrow \\left(0, 0, 1, 0, 0\\right)$\n- $I_2$: `lw`  $\\rightarrow \\left(1, 1, 0, 0, 0\\right)$\n- $I_3$: `sw`  $\\rightarrow \\left(1, 0, 0, 0, 0\\right)$\n- $I_4$: `beq` (采纳) $\\rightarrow \\left(0, 0, 0, 1, 0\\right)$\n- $I_5$: `j`   $\\rightarrow \\left(0, 0, 0, 0, 1\\right)$\n\n### 逐选项分析\n\n**A.**\n- $I_1$: $\\left(0, 0, 1, 0, 0\\right)$ - 与我们的推导相符。\n- $I_2$: $\\left(1, 1, 0, 0, 0\\right)$ - 与我们的推导相符。\n- $I_3$: $\\left(1, 0, 0, 0, 0\\right)$ - 与我们的推导相符。\n- $I_4$: $\\left(0, 0, 0, 1, 0\\right)$ - 与我们的推导相符。\n- $I_5$: $\\left(0, 0, 0, 0, 1\\right)$ - 与我们的推导相符。\n结论：**正确**。\n\n**B.**\n- $I_2$: $\\left(1, 0, 1, 0, 0\\right)$ - 不正确。对于 `lw`，`$MemtoReg$` 必须为 $1$ 以从内存写入，`$RegDst$` 必须为 $0$ 以选择 `$rt$` 寄存器。\n- $I_3$: $\\left(0, 0, 0, 0, 0\\right)$ - 不正确。对于 `sw`，`$ALUSrc$` 必须为 $1$ 以使用立即数偏移量进行地址计算。\n结论：**不正确**。\n\n**C.**\n- $I_2$: $\\left(0, 1, 1, 0, 0\\right)$ - 不正确。对于 `lw`，`$ALUSrc$` 必须为 $1$ 以使用立即数偏移量，`$RegDst$` 必须为 $0$ 以选择 `$rt$` 寄存器。\n- $I_3$: $\\left(0, 0, 1, 0, 0\\right)$ - 不正确。对于 `sw`，`$ALUSrc$` 是 $1$，`$RegDst$` 是无关项，因此是 $0$。\n结论：**不正确**。\n\n**D.**\n- $I_1$: $\\left(0, 0, 0, 0, 0\\right)$ - 不正确。对于 `add`（一条 R 型指令），`$RegDst$` 必须为 $1$ 以选择 `$rd$` 字段作为目标寄存器。\n- $I_4$: $\\left(1, 0, 0, 1, 0\\right)$ - 不正确。对于 `beq`，`$ALUSrc$` 必须为 $0$ 以比较两个寄存器的值。\n结论：**不正确**。\n\n基于详尽的分析，只有选项 A 正确列出了所有五条指令的控制信号元组。", "answer": "$$\\boxed{A}$$", "id": "3677903"}, {"introduction": "计算机的“快”与“慢”并非抽象概念，而是由其物理实现的延迟精确决定的。在单周期设计中，时钟周期必须足够长，以容纳最慢指令的执行时间，这条最长路径被称为“关键路径”。本练习将让你亲手计算不同指令（如加载和分支指令）的路径延迟，从而确定处理器的最小可行时钟周期，深刻理解结构设计如何直接影响性能。[@problem_id:3677808]", "problem": "考虑一个支持条件分支和加载指令的同步单周期处理器数据通路。该数据通路包括以下组件：程序计数器 (PC) 寄存器、指令存储器、寄存器文件、符号扩展器、左移两位器、一个计算 $PC+4$ 的加法器、一个分支目标加法器、一个评估分支条件的比较器、一个 PC 多路选择器 (MUX)、一个算术逻辑单元 (ALU) 和数据存储器。假设时钟偏斜可忽略不计。\n\n使用以下时序参数，所有参数均为组合逻辑块的传播延迟（单位：纳秒）和寄存器的时序参数：\n- PC 寄存器 clock-to-$q$ 延迟：$0.12\\,\\mathrm{ns}$。\n- PC 寄存器建立时间：$0.09\\,\\mathrm{ns}$。\n- 指令存储器：$0.98\\,\\mathrm{ns}$。\n- 寄存器文件读取：$0.64\\,\\mathrm{ns}$。\n- 符号扩展器：$0.19\\,\\mathrm{ns}$。\n- 左移两位器：$0.11\\,\\mathrm{ns}$。\n- $PC+4$ 加法器：$0.26\\,\\mathrm{ns}$。\n- 分支目标加法器：$0.31\\,\\mathrm{ns}$。\n- 比较器：$0.21\\,\\mathrm{ns}$。\n- PC 多路选择器 (MUX)：$0.13\\,\\mathrm{ns}$。\n- 算术逻辑单元 (ALU)：$0.37\\,\\mathrm{ns}$。\n- 数据存储器：$1.45\\,\\mathrm{ns}$。\n- 寄存器文件建立时间：$0.08\\,\\mathrm{ns}$。\n\n基本原理：在同步时序电路中，最小可行时钟周期由最坏情况下的寄存器到寄存器路径决定，且必须不小于源寄存器的 clock-to-$q$ 延迟、路径上所有中间组合逻辑的传播延迟以及目标寄存器的建立时间之和。\n\n任务：\n1. 确定在一条正确识别的分支路径上，由 $PC+4$ 加法器、分支目标加法器、比较器和 PC MUX 共同贡献的总延迟。\n2. 使用同步电路的基本时序规则，确定从 PC 寄存器开始，经过指令获取和操作数准备、分支决策和目标计算，再回到 PC 寄存器的总分支路径延迟。\n3. 使用相同的规则，确定从 PC 寄存器开始，经过指令获取、寄存器读取、ALU 中的地址计算、数据存储器访问，最终到寄存器文件写入阶段的总加载指令路径延迟。\n4. 将两个总路径延迟中较大者确定为该单周期实现的最小可行时钟周期。\n\n仅报告以纳秒为单位的最小可行时钟周期，并将最终答案四舍五入到四位有效数字。最终答案以 $\\mathrm{ns}$ 表示。", "solution": "该问题是有效的。这是一个计算机组成与体系结构领域中定义明确的问题，其基础是同步时序电路时序的基本原理。所提供的数据是自洽的，足以确定指定单周期数据通路的最小可行时钟周期。\n\n单周期处理器的最小可行时钟周期 ($T_{clk}$) 由最长路径（即关键路径）的传播延迟决定，该路径是从一个寄存器的输出到另一个寄存器的输入。时钟周期必须足够长，以容纳该路径上所有组件的累积延迟，再加上源寄存器的初始 clock-to-q 延迟和目标寄存器的最终建立时间。任何给定路径的总延迟公式为：\n$$T_{path} = T_{clk-q} + \\sum T_{comb} + T_{setup}$$\n其中 $T_{clk-q}$ 是源状态元件的 clock-to-q 延迟，$\\sum T_{comb}$ 是路径上所有组合逻辑块的传播延迟之和，而 $T_{setup}$ 是目标状态元件的建立时间。\n\n问题要求我们找到一个支持至少一条条件分支指令和一条加载指令的处理器的最小可行时钟周期。因此，我们必须计算这两种指令类型的总路径延迟，并取其最大值，因为时钟周期必须足够长以使最慢的指令能够完成。\n\n让我们分析两条主要路径：加载指令路径和条件分支指令路径。\n\n路径 1：加载指令 (`lw`)\n加载指令从数据存储器中获取一个字并将其写入寄存器文件。该指令的关键路径始于时钟沿触发的 PC 输出，经过指令存储器、寄存器堆读取、ALU地址计算、数据存储器读取，并最终在下一个时钟沿之前满足寄存器堆的建立时间要求。\n\n操作序列及其延迟如下：\n1.  周期开始，PC 输出在 clock-to-q 延迟后稳定：$T_{PC, clk-q} = 0.12\\,\\mathrm{ns}$。\n2.  指令存储器输出指令：$T_{IM} = 0.98\\,\\mathrm{ns}$。\n3.  寄存器堆读取基址寄存器：$T_{RF, read} = 0.64\\,\\mathrm{ns}$。\n4.  ALU 计算有效内存地址：$T_{ALU} = 0.37\\,\\mathrm{ns}$。\n5.  数据存储器读取数据：$T_{DM} = 1.45\\,\\mathrm{ns}$。\n6.  数据必须在周期结束前满足寄存器堆的建立时间：$T_{RF, setup} = 0.08\\,\\mathrm{ns}$。\n\n加载路径的总延迟 $T_{load}$ 是从时钟沿触发 PC 到数据在目标寄存器建立起来的所有延迟之和。\n$$T_{load} = T_{PC, clk-q} + T_{IM} + T_{RF, read} + T_{ALU} + T_{DM} + T_{RF, setup}$$\n$$T_{load} = 0.12 + 0.98 + 0.64 + 0.37 + 1.45 + 0.08\\,\\mathrm{ns}$$\n$$T_{load} = 3.64\\,\\mathrm{ns}$$\n\n路径 2：条件分支指令 (`beq`)\n条件分支指令计算一个目标地址并比较两个寄存器。如果条件满足，PC 将更新为目标地址；否则，它将更新为 $PC+4$。该指令的关键路径是决定下一个 PC 值的最长组合逻辑链，最终结果必须在下一个时钟沿之前满足 PC 的建立时间要求。该路径的关键部分是分支决策逻辑。\n\n操作序列及其延迟如下：\n1.  周期开始，PC 输出稳定：$T_{PC, clk-q} = 0.12\\,\\mathrm{ns}$。\n2.  指令存储器输出指令：$T_{IM} = 0.98\\,\\mathrm{ns}$。\n3.  寄存器堆读取要比较的两个寄存器：$T_{RF, read} = 0.64\\,\\mathrm{ns}$。\n4.  比较器评估条件并生成 PC MUX 的选择信号：$T_{Comp} = 0.21\\,\\mathrm{ns}$。\n5.  PC MUX 根据比较结果选择下一个 PC 地址：$T_{PC, MUX} = 0.13\\,\\mathrm{ns}$。\n6.  选定的地址必须在周期结束前满足 PC 的建立时间：$T_{PC, setup} = 0.09\\,\\mathrm{ns}$。\n\n分支路径的总延迟 $T_{branch}$ 是决定分支结果并选择下一个 PC 的路径。\n$$T_{branch} = T_{PC, clk-q} + T_{IM} + T_{RF, read} + T_{Comp} + T_{PC, MUX} + T_{PC, setup}$$\n$$T_{branch} = 0.12 + 0.98 + 0.64 + 0.21 + 0.13 + 0.09\\,\\mathrm{ns}$$\n$$T_{branch} = 2.17\\,\\mathrm{ns}$$\n\n（注意：计算分支目标地址的路径 ($T_{PC, clk-q} + T_{IM} + T_{SignExt} + T_{Shift} + T_{Br, add}$) 与决策路径并行发生，其延迟较短，因此不构成关键路径。）\n\n最小可行时钟周期\n最小可行时钟周期必须大于或等于数据通路中的最长路径延迟。\n$$T_{clk, min} = \\max(T_{load}, T_{branch})$$\n$$T_{clk, min} = \\max(3.64\\,\\mathrm{ns}, 2.17\\,\\mathrm{ns}) = 3.64\\,\\mathrm{ns}$$\n\n关键路径是加载指令的路径。最小可行时钟周期为 $3.64\\,\\mathrm{ns}$。问题要求答案四舍五入到四位有效数字。\n\n$$T_{clk, min} = 3.640\\,\\mathrm{ns}$$", "answer": "$$\\boxed{3.640}$$", "id": "3677808"}, {"introduction": "一个优秀的架构师不仅要懂得如何设计，更要懂得设计的边界和权衡。本练习将挑战你为现有数据通路添加一条新指令，这会迫使你直面单周期模型“一拍一令”的根本局限性。通过分析可行性与时序影响，你将学会评估硬件原生支持与软件模拟（伪指令）之间的利弊，这是体系结构设计中至关重要的实践智慧。[@problem_id:3677867]", "problem": "考虑一个面向高等本科教育水平的经典单周期数据通路，该数据通路用于精简指令集计算机（RISC）风格的处理器。该数据通路包括指令存储器、寄存器堆、算术逻辑单元（$ALU$）、一个能够进行逻辑左移（$SLL$）、逻辑右移（$SRL$）和算术右移（$SRA$）的桶形移位器、数据存储器以及用于控制操作数选择和写回的标准多路选择器（$MUX$）。未使用微编程或多周期执行；每条指令必须在恰好一个时钟周期内完成。时钟周期受最长组合逻辑路径（关键路径）的限制。对于基准设计，假定最长路径为加载字（$lw$）路径。\n\n您需要添加一条新指令 $SEXT$。对于一个源寄存器值 $x \\in \\{0,1\\}^{32}$，该指令生成 $x$ 的低位字节的 $32$ 位二进制补码符号扩展。形式上，将低位字节表示为 $x_{7:0}$，$SEXT$ 计算\n$$\ny \\triangleq \\operatorname{sext8}(x) = \\text{唯一一个低位字节等于 } x_{7:0} \\text{ 且其比特位 } y_{31:8} \\text{ 全部等于 } x_7 \\text{ 的 } 32 \\text{ 位二进制补码整数。}\n$$\n等效地（纯粹作为一种规范），可以将 $\\operatorname{sext8}(x)$ 描述为\n$$\n\\operatorname{sext8}(x) = \\big((x \\ll 24) \\ggg 24\\big),\n$$\n其中 $\\ll$ 表示逻辑左移，$\\ggg$ 表示算术右移。\n\n您必须判断 $SEXT$ 是否可以仅使用现有的单元（$ALU$、移位器、$MUX$）而不引入新模块来实现，以及这种实现是否能保持单周期时序（即不增加所需的时钟周期）。基准组件的传播延迟如下：\n- 指令存储器：$t_{\\mathrm{IMEM}} = 250\\,\\mathrm{ps}$，\n- 寄存器堆读取：$t_{\\mathrm{RF}} = 150\\,\\mathrm{ps}$，\n- $ALU$（非移位操作）：$t_{\\mathrm{ALU}} = 180\\,\\mathrm{ps}$，\n- 移位器（$SLL$、$SRL$、$SRA$）：$t_{\\mathrm{SH}} = 220\\,\\mathrm{ps}$，\n- 数据存储器：$t_{\\mathrm{DMEM}} = 280\\,\\mathrm{ps}$，\n- 每个 $MUX$：$t_{\\mathrm{MUX}} = 30\\,\\mathrm{ps}$，\n- 写回建立时间（寄存器堆输入建立时间和时钟到Q端开销的总和）：$t_{\\mathrm{WB}} = 20\\,\\mathrm{ps}$。\n\n假设基准关键路径是 $lw$ 路径，其时钟周期为\n$$\nT_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}}.\n$$\n数据通路将移位器作为 $ALU$ 的功能选项之一，没有内部循环允许移位器的输出在同一周期内立即作为其自身的输入；也就是说，在未经修改的数据通路中，每条指令最多只遍历一次移位器。\n\n哪个选项最能描述一种使用现有单元而不添加新模块来增加 $SEXT$ 指令的正确流程，并给出正确的可行性和时序结论？\n\nA. 增加一个控制设置，在同一周期内将源寄存器 $x$ 两次通过移位器，首先进行 $24$ 位的 $SLL$，然后进行 $24$ 位的 $SRA$，利用现有的 $MUX$ 将移位器输出循环回其输入。这保留了单周期执行，并且能够满足 $T_{\\mathrm{clk}}^{\\mathrm{base}}$ 的要求，因为增加的移位器遍历延迟仍然低于基准 $lw$ 关键路径。\n\nB. 通过掩码操作实现 $SEXT$：使用 $ALU$ 计算 $y = x \\,\\&\\, 255$ 并写回结果。这仅使用现有的 $ALU$ 和 $MUX$ 路径，在一个周期内执行，并且满足时序要求，因为它完全避免了使用移位器，同时仍然对字节进行符号扩展。\n\nC. 不改变硬件。在指令集架构中将 $SEXT$ 定义为一条伪指令，由汇编器将其展开为两条现有指令：先进行 $24$ 位的 $SLL$，后进行 $24$ 位的 $SRA$。每条构成指令都使用现有单元在一个周期内执行。这保留了基准时钟周期，并产生了与 $SEXT$ 完全相同的语义，而无需引入新模块，但 $SEXT$ 本身不是一条单周期硬件指令。\n\nD. 复用立即数符号扩展单元（该单元对来自指令的 $16$ 位立即数字段进行符号扩展），通过现有的 $MUX$ 将寄存器 $x$ 导向该单元，以对 $x$ 的低位字节进行符号扩展。这在一个周期内执行，并且满足时序要求，因为立即数符号扩展单元已经存在且速度很快。\n\n选择最准确的选项。", "solution": "用户希望我分析在一个单周期RISC数据通路中添加一条新指令 `SEXT` 的可行性。\n\n### 第一步：提取已知条件\n\n*   **处理器架构**：单周期RISC数据通路。\n*   **数据通路组件**：指令存储器、寄存器堆、ALU、桶形移位器（`SLL`、`SRL`、`SRA`）、数据存储器、MUX。\n*   **执行模型**：每条指令在一个时钟周期内完成。\n*   **新指令 `SEXT`**：对源寄存器 $x$ 的低位字节执行 $32$ 位二进制补码符号扩展。\n    *   **规范1**：输出 $y$ 满足 $y_{7:0} = x_{7:0}$ 并且 $y_{31:8}$ 的所有位都等于 $x_7$。\n    *   **规范2**：一个等效的描述是 $y = ((x \\ll 24) \\ggg 24)$，其中 $\\ll$ 是逻辑左移，$\\ggg$ 是算术右移。\n*   **约束条件**：\n    1. 实现必须只使用现有的功能单元和多路选择器。不能添加新模块。\n    2. 实现不能增加所需的时钟周期。\n*   **数据通路结构约束**：“没有内部循环允许移位器的输出在同一周期内立即作为其自身的输入；也就是说，每条指令最多只遍历一次移位器”。\n*   **组件延迟**：\n    *   $t_{\\mathrm{IMEM}} = 250\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{RF}} = 150\\,\\mathrm{ps}$ (读取)\n    *   $t_{\\mathrm{ALU}} = 180\\,\\mathrm{ps}$ (非移位操作)\n    *   $t_{\\mathrm{SH}} = 220\\,\\mathrm{ps}$ (移位器)\n    *   $t_{\\mathrm{DMEM}} = 280\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{MUX}} = 30\\,\\mathrm{ps}$\n    *   $t_{\\mathrm{WB}} = 20\\,\\mathrm{ps}$ (写回建立时间)\n*   **基准关键路径**：加载字（$lw$）指令，其时钟周期由以下公式给出：\n    $$ T_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}} $$\n\n### 第二步：使用提取的已知条件进行验证\n\n该问题陈述描述了一个关于数据通路修改和性能分析的标准计算机体系结构学术问题。\n*   **科学上成立**：单周期数据通路、关键路径时序、指令集扩展以及符号扩展等特定操作的概念都是计算机组成与体系结构中的基础和公认内容。\n*   **问题明确**：新指令 `SEXT` 的定义清晰明确。实现上的约束（无新模块，不增加时钟周期）也很清楚。所有必要的数据（组件延迟、关键路径公式）都已提供。\n*   **客观性**：问题以精确的技术语言陈述，没有主观元素。\n*   **一致性检查**：提供的基准关键路径公式是问题的明确前提。虽然它简化了真实的 `lw` 路径（该路径还涉及立即数符号扩展器），但我们必须接受它作为给定条件。关于“最多只遍历一次移位器”和“没有内部循环”的约束是关于数据通路结构的一个关键且无矛盾的信息。\n\n问题是有效的。这是一个表述清晰、内容完整且科学上合理的练习。我现在将进行求解。\n\n### 第三步：推导与选项分析\n\n首先，我们计算基准时钟周期，这是新指令可以占用的最长时间。\n$$ T_{\\mathrm{clk}}^{\\mathrm{base}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{ALU}} + t_{\\mathrm{DMEM}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}} $$\n$$ T_{\\mathrm{clk}}^{\\mathrm{base}} = 250\\,\\mathrm{ps} + 150\\,\\mathrm{ps} + 180\\,\\mathrm{ps} + 280\\,\\mathrm{ps} + 30\\,\\mathrm{ps} + 20\\,\\mathrm{ps} = 910\\,\\mathrm{ps} $$\n任何新的单周期硬件指令的总路径延迟必须小于或等于 $910\\,\\mathrm{ps}$。\n\n`SEXT` 的定义是 $y = ((x \\ll 24) \\ggg 24)$。这个操作需要对源寄存器的数据进行两次连续的移位操作。一个标准的单周期数据通路被设计为每个周期只执行一次ALU或移位器操作。这些单元的输出通常被路由到数据存储器或寄存器堆的写端口，并在时钟周期结束时被锁存。它们在同一周期内不能作为同一功能单元的输入。问题陈述明确确认了这一结构限制：“没有内部循环允许移位器的输出在同一周期内立即作为其自身的输入”。\n\n这个基本约束意味着，在不进行重大修改（即增加一个用于循环的路径和控制）的情况下，不可能在所述数据通路上的单个时钟周期内执行两次连续的移位。\n\n现在，基于这一理解来评估每个选项。\n\n**A. 增加一个控制设置，在同一周期内将源寄存器 $x$ 两次通过移位器，首先进行 $24$ 位的 $SLL$，然后进行 $24$ 位的 $SRA$，利用现有的 $MUX$ 将移位器输出循环回其输入。这保留了单周期执行，并且能够满足 $T_{\\mathrm{clk}}^{\\mathrm{base}}$ 的要求，因为增加的移位器遍历延迟仍然低于基准 $lw$ 关键路径。**\n\n此选项建议创建一个循环来两次使用移位器。\n1.  **可行性**：这直接违反了问题中明确的约束条件，“没有内部循环允许移位器的输出在同一周期内立即作为其自身的输入”。因此，在**给定**的数据通路上，这个过程是不可能的。\n2.  **时序**：即使这样的循环是可能的，我们来计算其路径延迟。数据必须从寄存器堆流出，通过移位器，通过一个新的MUX路径，再返回通过移位器，然后到达寄存器堆写端口。\n    路径延迟至少为：\n    $T_{\\mathrm{A}} = t_{\\mathrm{IMEM}} + t_{\\mathrm{RF}} + t_{\\mathrm{SH}} + t_{\\mathrm{MUX}} + t_{\\mathrm{SH}} + t_{\\mathrm{MUX}} + t_{\\mathrm{WB}}$\n    $T_{\\mathrm{A}} = 250 + 150 + 220 + 30 + 220 + 30 + 20 = 920\\,\\mathrm{ps}$\n    这个 $920\\,\\mathrm{ps}$ 的延迟大于 $910\\,\\mathrm{ps}$ 的基准时钟周期。因此，这将需要增加时钟周期。该选项声称它“能够满足 $T_{\\mathrm{clk}}^{\\mathrm{base}}$ 的要求”是错误的。\n**结论：不正确。**\n\n**B. 通过掩码操作实现 $SEXT$：使用 $ALU$ 计算 $y = x \\,\\&\\, 255$ 并写回结果。这仅使用现有的 $ALU$ 和 $MUX$ 路径，在一个周期内执行，并且满足时序要求，因为它完全避免了使用移位器，同时仍然对字节进行符号扩展。**\n\n此选项提出了一个不同的实现方法：与常数 $255$（十六进制 `0x000000FF`）进行按位与操作。\n1.  **功能性**：这个操作，$y = x \\,\\&\\, 0x000000FF$，隔离了 $x$ 的低位字节，并将所有高 $24$ 位置为 $0$。这被称为*零扩展*。`SEXT` 指令要求的是*符号扩展*，即将高 $24$ 位置为该字节的符号位（$x_7$）的值。对于任何低位字节为负数（即 $x_7 = 1$）的 $x$ 值，此实现将产生错误的结果。例如，如果 $x_{7:0} = 1000\\,0000_2$，符号扩展产生 $11...1000\\,0000_2$，而掩码操作产生 $00...01000\\,0000_2$。\n所提出的逻辑在功能上是不正确的。\n**结论：不正确。**\n\n**C. 不改变硬件。在指令集架构中将 $SEXT$ 定义为一条伪指令，由汇编器将其展开为两条现有指令：先进行 $24$ 位的 $SLL$，后进行 $24$ 位的 $SRA$。每条构成指令都使用现有单元在一个周期内执行。这保留了基准时钟周期，并产生了与 $SEXT$ 完全相同的语义，而无需引入新模块，但 $SEXT$ 本身不是一条单周期硬件指令。**\n\n此选项提出了一个基于软件的解决方案，使用了伪指令的概念。\n1.  **功能性**：`sll $t0, $rs, 24` 后跟 `sra $rd, $t0, 24` 的序列正确地实现了 $((x \\ll 24) \\ggg 24)$ 操作。第一条指令将低位字节移动到最高字节位置，使其符号位（$x_7$）成为整个字的最高有效位。第二条指令，算术右移，将该字节移回低位位置，同时将符号位复制到所有高 $24$ 位。这个序列正确地执行了符号扩展。\n2.  **可行性与约束**：\n    *   这种方法不需要对数据通路硬件进行任何更改（“不改变硬件”）。它使用了现有移位器支持的现有指令（`SLL`、`SRA`）。\n    *   由于硬件未变，关键路径仍然是 `lw` 指令，时钟周期 $T_{\\mathrm{clk}}^{\\mathrm{base}}$ 得以保留。\n    *   它正确地指出了其中的权衡：`SEXT` 不是一条新的、在一个周期内执行的*硬件*指令。它是一个汇编器约定，会展开为两条机器指令，因此需要两个时钟周期来执行。\n此选项提供了一个正确、实用且遵守所有既定约束的解决方案。\n**结论：正确。**\n\n**D. 复用立即数符号扩展单元（该单元对来自指令的 $16$ 位立即数字段进行符号扩展），通过现有的 $MUX$ 将寄存器 $x$ 导向该单元，以对 $x$ 的低位字节进行符号扩展。这在一个周期内执行，并且满足时序要求，因为立即数符号扩展单元已经存在且速度很快。**\n\n此选项建议使用专用于扩展立即数的硬件。\n1.  **可行性**：在标准的RISC数据通路中，立即数符号扩展单元的输入是硬连接到指令寄存器的某些位（例如，位 $15:0$）。没有MUX可以选择来自寄存器堆的值作为该单元的输入。添加这样的MUX及其控制信号将构成硬件修改，这可能违反“仅使用现有单元”的约束，具体取决于如何解释。\n2.  **功能性**：标准的符号扩展单元被设计用来通过复制其最高有效位（$I_{15}$）来扩展一个 $16$ 位的值。`SEXT` 指令需要通过复制其符号位（$x_7$）来扩展一个 $8$ 位的值。简单地将寄存器的低位字节馈送到一个 $16$ 位的符号扩展器中是行不通的。该单元被硬连接以查看第 $15$ 位作为符号位，而不是第 $7$ 位。因此，现有的单元无法执行所需的操作，除非重新设计。这将是一个“新模块”或一次修改，违反了问题的约束。\n“复用”现有立即数符号扩展器来达到此目的的前提从根本上就是错误的。\n**结论：不正确。**\n\n### 结论\n\n选项 C 是唯一一个提出了功能正确、架构合理且遵守问题所有约束的解决方案。它正确地指出，在指定的、未经修改的数据通路上，所需的操作无法在单个硬件周期内实现，并准确地描述了标准的基于软件的替代方案（伪指令）。", "answer": "$$\\boxed{C}$$", "id": "3677867"}]}