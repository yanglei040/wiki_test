{"hands_on_practices": [{"introduction": "上下文切换是现代操作系统实现多任务处理的基石，但它并非没有开销。本练习旨在量化一次上下文切换的总延迟，通过建立一个综合模型，将保存和恢复寄存器状态的内存操作时间，以及处理器流水线刷新和内存管理单元（MMU）重配置等固定开销囊括在内。通过这个计算[@problem_id:3629511]，你将深入理解构成上下文切换成本的各个基本组成部分。", "problem": "一个单线程微内核在中央处理器（CPU）上执行两个用户进程之间的上下文切换。上下文切换需要将当前的体系结构状态保存到内存中，然后再恢复它。对于该处理器，体系结构状态包括 $M$ 个通用寄存器、$V$ 个向量寄存器和 $F$ 个浮点寄存器。这些寄存器的宽度是固定的：每个通用寄存器为 $8$ 字节，每个向量寄存器为 $32$ 字节，每个浮点寄存器为 $16$ 字节。内存管理单元（MMU）在每次切换时都会重新配置，产生一个以周期为单位的固定停顿。\n\n一份性能研究报告指出，当内核在保存和恢复期间使用流式存储和加载时，持续内存带宽为 $BW$ 字节/秒，并报告CPU时钟频率为 $f$ 周期/秒。在上下文切换期间，CPU的流水线必须刷新一次，这会导致一个以周期为单位的停顿。同样，还有一个以周期为单位的MMU上下文切换停顿。假设如下：\n- 保存寄存器状态会将整个体系结构寄存器组写入内存，而恢复则会使用饱和测量带宽的流式访问读回相同数量的数据。\n- 保存和恢复阶段彼此不重叠，也不与流水线刷新或MMU停顿重叠。\n- 忽略指定寄存器之外的任何额外微体系结构状态。\n- 将流水线刷新停顿和MMU停顿视为固定的周期计数，必须使用CPU频率将其转换为时间。\n\n给定参数 $M=32$、$V=32$、$F=32$、$BW=20 \\times 10^{9}$、$f=3.2 \\times 10^{9}$、流水线刷新停顿为 $160$ 个周期、MMU停顿为 $800$ 个周期，计算总上下文切换延迟。将您的最终答案四舍五入到四位有效数字。以微秒为单位表示您的最终延迟。", "solution": "问题陈述提供了一个清晰、自洽且具有科学依据的模型来计算上下文切换延迟。所有参数都定义明确，并且这些假设在计算机体系结构领域内构成了一个适定问题。所提供的寄存器数量、大小、时钟频率和内存带宽值对于现代高性能计算系统是符合实际的。因此，该问题被认为是有效的，可以推导出解决方案。\n\n上下文切换的总延迟 $T_{total}$ 是其顺序组件延迟的总和。如问题所述，这些组件是：将体系结构状态保存到内存的时间（$T_{save}$）、从内存中恢复状态的时间（$T_{restore}$）、流水线刷新停顿的时间惩罚（$T_{flush}$）以及内存管理单元（MMU）重新配置停顿的时间惩罚（$T_{mmu}$）。\n\n$$T_{total} = T_{save} + T_{restore} + T_{flush} + T_{mmu}$$\n\n首先，我们计算必须传入和传出内存的体系结构状态的总大小 $S_{state}$。该状态由 $M$ 个通用寄存器、$V$ 个向量寄存器和 $F$ 个浮点寄存器组成。\n\n通用寄存器文件的大小是寄存器数量 $M$ 乘以其宽度 $W_{GPR} = 8$ 字节。\n$$S_{GPR} = M \\times W_{GPR}$$\n向量寄存器文件的大小是寄存器数量 $V$ 乘以其宽度 $W_{VR} = 32$ 字节。\n$$S_{VR} = V \\times W_{VR}$$\n浮点寄存器文件的大小是寄存器数量 $F$ 乘以其宽度 $W_{FPR} = 16$ 字节。\n$$S_{FPR} = F \\times W_{FPR}$$\n\n总状态大小是这些组件的总和：\n$$S_{state} = S_{GPR} + S_{VR} + S_{FPR} = M \\cdot W_{GPR} + V \\cdot W_{VR} + F \\cdot W_{FPR}$$\n\n代入给定值 $M=32$、$V=32$ 和 $F=32$：\n$$S_{state} = (32 \\times 8) + (32 \\times 32) + (32 \\times 16) \\text{ bytes}$$\n$$S_{state} = 256 + 1024 + 512 \\text{ bytes}$$\n$$S_{state} = 1792 \\text{ bytes}$$\n\n接下来，我们计算内存操作所需的时间。问题陈述指出，上下文保存操作向内存写入 $S_{state}$ 字节，恢复操作从内存读出 $S_{state}$ 字节，两者均以持续带宽 $BW$ 进行。\n$$T_{save} = \\frac{S_{state}}{BW}$$\n$$T_{restore} = \\frac{S_{state}}{BW}$$\n内存操作的总时间为：\n$$T_{mem} = T_{save} + T_{restore} = \\frac{2 \\cdot S_{state}}{BW}$$\n\n使用给定值 $BW = 20 \\times 10^{9}$ 字节/秒和计算出的 $S_{state}$：\n$$T_{mem} = \\frac{2 \\times 1792}{20 \\times 10^{9}} \\text{ seconds} = \\frac{3584}{20 \\times 10^{9}} \\text{ seconds} = 179.2 \\times 10^{-9} \\text{ seconds}$$\n\n现在，我们计算CPU停顿的时间惩罚。停顿以时钟周期为单位给出，必须使用CPU频率 $f$ 转换为时间。单个时钟周期的时间是 $T_{cycle} = 1/f$。\n流水线刷新停顿为 $C_{flush} = 160$ 个周期。相关的时间惩罚是：\n$$T_{flush} = C_{flush} \\times T_{cycle} = \\frac{C_{flush}}{f}$$\nMMU重新配置停顿为 $C_{mmu} = 800$ 个周期。相关的时间惩罚是：\n$$T_{mmu} = C_{mmu} \\times T_{cycle} = \\frac{C_{mmu}}{f}$$\n\n使用给定值 $f = 3.2 \\times 10^{9}$ 周期/秒（赫兹）：\n$$T_{flush} = \\frac{160}{3.2 \\times 10^{9}} \\text{ seconds} = 50 \\times 10^{-9} \\text{ seconds}$$\n$$T_{mmu} = \\frac{800}{3.2 \\times 10^{9}} \\text{ seconds} = 250 \\times 10^{-9} \\text{ seconds}$$\n\n最后，我们将所有时间分量相加，以求得总上下文切换延迟：\n$$T_{total} = T_{mem} + T_{flush} + T_{mmu}$$\n$$T_{total} = (179.2 \\times 10^{-9}) + (50 \\times 10^{-9}) + (250 \\times 10^{-9}) \\text{ seconds}$$\n$$T_{total} = (179.2 + 50 + 250) \\times 10^{-9} \\text{ seconds}$$\n$$T_{total} = 479.2 \\times 10^{-9} \\text{ seconds}$$\n\n问题要求最终答案以微秒（$\\mu s$）表示，并四舍五入到四位有效数字。\n$1 \\mu s = 10^{-6} s$。\n要将秒转换为微秒，我们乘以 $10^{6}$。\n$$T_{total} = 479.2 \\times 10^{-9} \\times 10^{6} \\mu s = 479.2 \\times 10^{-3} \\mu s = 0.4792 \\mu s$$\n值 $0.4792$ 正好有四位有效数字（$4$、$7$、$9$、$2$），因此不需要进一步四舍五入。", "answer": "$$\\boxed{0.4792}$$", "id": "3629511"}, {"introduction": "并非所有的上下文切换都“生而平等”。本练习将引导你探讨切换重量级进程（processes）和轻量级线程（threads）之间的关键性能差异。通过精确计算与切换地址空间相关的额外开销（如页表切换和TLB刷新）[@problem_id:3629564]，你将明白为何基于线程的并发模型在许多场景下效率更高，并能体会调度策略（如时间片大小）与底层硬件成本之间的权衡。", "problem": "一个单处理器系统对 $N$ 个可运行的任务采用轮询调度（round-robin scheduling），这些任务都是计算密集型（compute-bound）且从不主动阻塞，时间量子（time quantum）固定为 $Q$。一次上下文切换（context switch）会引入纯粹的开销，并假设在连续的时间片之间恰好发生一次；首次调度的成本可以忽略不计。当任务作为独立的进程实现时，上下文切换时间建模为 $t_{cs}^{proc} = t_{regs} + t_{pt} + t_{TLB}$，其中 $t_{regs}$ 是保存和恢复通用寄存器的时间，$t_{pt}$ 是切换活动页表的时间，$t_{TLB}$ 是刷新和重填翻译后备缓冲器（TLB）的时间。当任务作为同一地址空间内的线程实现时，上下文切换时间建模为 $t_{cs}^{thread} = t_{regs}$。假设除了这些时间所包含的内容外，没有其他开销，也没有缓存效应。\n\n仅使用以下基本依据：根据定义，完成一个调度时间片序列的墙上时钟时间（wall-clock time）等于有效执行时间与操作系统开销（如上下文切换）之和；在轮询调度中，一个完整的轮次（round）包含 $N$ 个时间量子和 $N$ 次上下文切换（忽略首次调度）。\n\n将盈亏平衡量子（break-even quantum） $Q_{b}$ 定义为这样一个 $Q$ 的值：在一个包含 $N$ 个时间片的完整轮次中，使用进程而非线程所产生的额外墙上时钟时间，恰好等于一个有效执行时间量子 $Q$。\n\n给定 $N = 16$，$t_{regs} = 1.2\\,\\mu\\text{s}$，$t_{pt} = 2.8\\,\\mu\\text{s}$，以及 $t_{TLB} = 3.5\\,\\mu\\text{s}$，计算 $Q_{b}$ 并以微秒（microseconds）为单位表示您的答案。将您的答案四舍五入到 $4$ 位有效数字。", "solution": "首先对问题进行验证，以确保其科学性、良构性（well-posed）和客观性。\n\n**步骤1：提取给定信息**\n- 调度算法：轮询调度\n- 时间量子：$Q$\n- 可运行任务数量：$N$\n- 任务行为：计算密集型，从不主动阻塞\n- 上下文切换频率：在连续的时间片之间恰好一次\n- 进程的上下文切换时间：$t_{cs}^{proc} = t_{regs} + t_{pt} + t_{TLB}$\n- 线程的上下文切换时间：$t_{cs}^{thread} = t_{regs}$\n- 墙上时钟时间的定义：有效执行时间与操作系统开销之和\n- 一个完整轮次的定义：$N$ 个时间量子和 $N$ 次上下文切换\n- 盈亏平衡量子 $Q_{b}$ 的定义：在一个完整轮次中，使用进程而非线程所产生的额外墙上时钟时间恰好等于一个时间量子 $Q$ 的 $Q$ 值。\n- 给定数值：$N = 16$，$t_{regs} = 1.2\\,\\mu\\text{s}$，$t_{pt} = 2.8\\,\\mu\\text{s}$，以及 $t_{TLB} = 3.5\\,\\mu\\text{s}$。\n\n**步骤2：使用提取的信息进行验证**\n问题被认定为有效。\n- 它在科学上基于操作系统和计算机体系结构的原理，特别是关于进程/线程上下文切换和调度开销的原理。所提供的 $t_{cs}^{proc}$ 和 $t_{cs}^{thread}$ 模型准确地反映了开销的根本差异，即为进程管理独立地址空间。\n- 它是良构的。盈亏平衡量子 $Q_b$ 的定义提供了一个清晰明确的条件，可以形式化为一个可解的方程。所有必要的参数都已提供。\n- 它是客观的，并使用了精确、正式的语言。\n- 问题是自包含的，且提供的数据是一致的。所做的简化（例如，忽略 TLB 模型之外的缓存效应，固定的上下文切换时间）被明确说明，并且是此类分析的标准做法。\n\n**步骤3：结论与行动**\n问题有效。将提供完整的解法。\n\n**求解过程**\n目标是计算盈亏平衡量子 $Q_{b}$。我们首先根据所提供的定义，将一个完整调度轮次的总墙上时钟时间形式化，分别针对进程和线程两种情况。\n\n设 $T_{round}^{proc}$ 为任务作为进程实现时完成一个完整轮次的总墙上时钟时间。根据问题陈述，一个完整轮次包含 $N$ 个时间量子的有效执行时间和 $N$ 次上下文切换。\n一个轮次中的总有效执行时间是 $N$ 个时间量子持续时间之和，即 $N \\cdot Q$。\n一个轮次中由上下文切换产生的总开销是进程上下文切换时间的 $N$ 倍，即 $N \\cdot t_{cs}^{proc}$。\n因此，总墙上时钟时间为：\n$$T_{round}^{proc} = N \\cdot Q + N \\cdot t_{cs}^{proc}$$\n代入给定的 $t_{cs}^{proc}$ 模型：\n$$T_{round}^{proc} = N \\cdot Q + N \\cdot (t_{regs} + t_{pt} + t_{TLB})$$\n\n类似地，设 $T_{round}^{thread}$ 为任务作为线程实现时一个完整轮次的总墙上时钟时间。有效执行时间仍然是 $N \\cdot Q$。此时的开销基于线程上下文切换时间 $t_{cs}^{thread}$。\n$$T_{round}^{thread} = N \\cdot Q + N \\cdot t_{cs}^{thread}$$\n代入给定的 $t_{cs}^{thread}$ 模型：\n$$T_{round}^{thread} = N \\cdot Q + N \\cdot t_{regs}$$\n\n问题根据“使用进程而非线程所产生的额外墙上时钟时间”来定义盈亏平衡量子 $Q_b$。这个额外时间，我们称之为 $\\Delta T_{overhead}$，是进程和线程的总轮次时间之差。\n$$\\Delta T_{overhead} = T_{round}^{proc} - T_{round}^{thread}$$\n代入上面推导出的表达式：\n$$\\Delta T_{overhead} = [N \\cdot Q + N \\cdot (t_{regs} + t_{pt} + t_{TLB})] - [N \\cdot Q + N \\cdot t_{regs}]$$\n$N \\cdot Q$ 和 $N \\cdot t_{regs}$ 项相互抵消：\n$$\\Delta T_{overhead} = N \\cdot (t_{pt} + t_{TLB})$$\n这个结果是合乎逻辑的：在此模型中，使用进程相对于线程的额外开销完全来自于管理页表和TLB的每次切换成本，而对于同一进程内的线程切换，这些成本是不需要的。\n\n盈亏平衡量子 $Q_b$ 被定义为使这个额外开销时间恰好等于一个时间量子的特定 $Q$ 值。\n$$Q_b = \\Delta T_{overhead}$$\n因此，我们得到 $Q_b$ 的确定性方程：\n$$Q_b = N \\cdot (t_{pt} + t_{TLB})$$\n\n现在，我们代入给定的数值来计算 $Q_b$ 的值。\n给定：\n- $N = 16$\n- $t_{pt} = 2.8\\,\\mu\\text{s}$\n- $t_{TLB} = 3.5\\,\\mu\\text{s}$\n\n页表和TLB开销之和为：\n$$t_{pt} + t_{TLB} = 2.8\\,\\mu\\text{s} + 3.5\\,\\mu\\text{s} = 6.3\\,\\mu\\text{s}$$\n现在，我们计算 $Q_b$：\n$$Q_b = 16 \\cdot (6.3\\,\\mu\\text{s})$$\n$$Q_b = 100.8\\,\\mu\\text{s}$$\n\n问题要求答案四舍五入到 $4$ 位有效数字。计算出的值 $100.8$ 已经恰好包含四位有效数字（$1$、$0$、$0$、$8$）。因此，无需进一步四舍五入。结果的单位是微秒，符合要求。", "answer": "$$\\boxed{100.8}$$", "id": "3629564"}, {"introduction": "既然上下文切换的开销如此重要，系统设计师们便不断寻求优化之道。本练习将探讨一种基于硬件的优化技术：通过为每个寄存器设置“脏位”（dirty bit）来减少保存寄存器状态时的数据传输量。你将通过计算[@problem_id:3629491]，量化这种优化所带来的预期时间节省，从而体会到精准的硬件支持如何能够显著提升系统性能。", "problem": "一种微架构设计引入了按寄存器“脏”状态跟踪，以减少在中央处理器（CPU）上进行操作系统（OS）上下文切换时的上下文保存流量。假设在传统的完整保存模式下，每次上下文切换都必须保留以下体系结构可见的寄存器集：$64$个宽度为$64$位的通用寄存器，$32$个宽度为$128$位的浮点寄存器，以及$16$个宽度为$256$位的向量寄存器。假设一种硬件支持的部分保存方式，在写入内存前会查询每个寄存器的脏位图。脏位图的获取和准备有$16$个CPU周期的固定开销，之后保存逻辑只写入被标记为脏的寄存器。\n\n假设如下：\n- CPU频率为$2.0$吉赫兹，因此周期时间为$0.5$纳秒。\n- 主内存接口维持$32 \\times 10^{9}$字节/秒的写入带宽（使用直接内存访问（DMA）在内存控制器处测量）。\n- 每个寄存器是脏的概率独立，为$p_{\\text{dirty}} = 0.35$，并且寄存器为脏意味着整个寄存器都将被写出。\n- 忽略缓存和写合并效应；将数据传输时间建模为写入的总字节数除以持续带宽，并将脏位图处理建模为固定的周期开销。\n- 为了计算上下文保存时间的减少量，假设任何与寄存器数据移动无关的额外操作系统簿记工作在完整保存和部分保存中是相同的，在比较两者时可以抵消。\n\n仅使用概率论和吞吐量的第一性原理（期望的线性性质以及时间等于工作量除以速率），推导：\n1. 在部分保存模式下，预期保存到内存的字节数，记为 $B_{\\text{dirty}}$。\n2. 上下文保存时间的减少量，记为 $\\Delta t_{\\text{cs}}$，定义为完整保存的数据移动时间减去部分保存的数据移动时间及脏位图处理时间。\n\n将最终数值结果四舍五入到四位有效数字。将$B_{\\text{dirty}}$以字节表示，$\\Delta t_{\\text{cs}}$以纳秒表示。你的最终答案必须是包含这两个值的单行矩阵，并按此顺序排列。", "solution": "该问题经评估有效，因为它在科学上基于计算机体系结构原理，问题陈述清晰，数据充分且一致，并以客观方式表达。因此，我们可以进行形式化的求解。\n\n求解过程需要计算在部分上下文保存期间写入的预期字节数，以及与完整保存相比所节省的时间。推导将遵循概率论的第一性原理，特别是期望的线性性质，以及时间、工作量（数据量）和速率（带宽）之间的基本关系。\n\n首先，我们定义并量化必须保留的寄存器状态的总大小。该状态由三组不同的寄存器组成。\n\n1.  通用寄存器（GPR）：有 $N_{gpr} = 64$ 个寄存器，每个宽度为 $W_{gpr} = 64$ 位。GPR的总大小（以字节为单位）为：\n    $$ B_{gpr} = N_{gpr} \\times \\frac{W_{gpr}}{8} = 64 \\times \\frac{64}{8} \\text{ bytes} = 64 \\times 8 \\text{ bytes} = 512 \\text{ bytes} $$\n\n2.  浮点（FP）寄存器：有 $N_{fp} = 32$ 个寄存器，每个宽度为 $W_{fp} = 128$ 位。FP寄存器的总大小（以字节为单位）为：\n    $$ B_{fp} = N_{fp} \\times \\frac{W_{fp}}{8} = 32 \\times \\frac{128}{8} \\text{ bytes} = 32 \\times 16 \\text{ bytes} = 512 \\text{ bytes} $$\n\n3.  向量寄存器：有 $N_{vec} = 16$ 个寄存器，每个宽度为 $W_{vec} = 256$ 位。向量寄存器的总大小（以字节为单位）为：\n    $$ B_{vec} = N_{vec} \\times \\frac{W_{vec}}{8} = 16 \\times \\frac{256}{8} \\text{ bytes} = 16 \\times 32 \\text{ bytes} = 512 \\text{ bytes} $$\n\n体系结构可见的寄存器状态的总大小 $B_{total}$ 是这些单独部分的总和：\n$$ B_{total} = B_{gpr} + B_{fp} + B_{vec} = 512 + 512 + 512 = 1536 \\text{ bytes} $$\n\n这是在传统的完整上下文保存期间写入内存的数据量。\n\n接下来，我们计算在部分保存方案下写入内存的预期字节数，记为 $B_{\\text{dirty}}$。每个寄存器被独立标记为脏的概率为 $p_{\\text{dirty}} = 0.35$。设 $X$ 为表示写入总字节数的随机变量。设 $B_i$ 为寄存器 $i$ 的大小（以字节为单位），其中 $i$ 遍历所有寄存器。设 $D_i$ 为一个指示随机变量，如果寄存器 $i$ 是脏的，则 $D_i = 1$，否则 $D_i = 0$。已知 $P(D_i=1) = p_{\\text{dirty}}$。写入的总字节数为 $X = \\sum_i B_i D_i$。\n\n根据期望的线性性质，写入的预期字节数为：\n$$ E[X] = B_{\\text{dirty}} = E\\left[\\sum_i B_i D_i\\right] = \\sum_i E[B_i D_i] = \\sum_i B_i E[D_i] $$\n指示随机变量 $D_i$ 的期望为 $E[D_i] = 1 \\cdot P(D_i=1) + 0 \\cdot P(D_i=0) = p_{\\text{dirty}}$。\n因此，预期的写入字节数为：\n$$ B_{\\text{dirty}} = \\sum_i (B_i \\cdot p_{\\text{dirty}}) = p_{\\text{dirty}} \\sum_i B_i = p_{\\text{dirty}} \\cdot B_{total} $$\n代入数值：\n$$ B_{\\text{dirty}} = 0.35 \\times 1536 \\text{ bytes} = 537.6 \\text{ bytes} $$\n这是第一个所需的值。四舍五入到四位有效数字，结果是 $537.6$ 字节。\n\n现在，我们计算上下文保存时间的减少量 $\\Delta t_{\\text{cs}}$。这被定义为完整保存时间减去部分保存时间。让我们分别计算这些时间。给定的内存写入带宽为 $BW_{mem} = 32 \\times 10^{9}$ 字节/秒。\n\n完整保存的时间 $t_{full}$ 纯粹是移动 $B_{total}$ 数据所需的时间：\n$$ t_{full} = \\frac{B_{total}}{BW_{mem}} = \\frac{1536 \\text{ bytes}}{32 \\times 10^9 \\text{ bytes/s}} = 48 \\times 10^{-9} \\text{ s} = 48 \\text{ ns} $$\n\n部分保存的时间 $t_{partial}$ 有两个组成部分：处理脏位图的固定开销和移动脏寄存器数据的时间。\n开销时间 $t_{overhead}$ 是固定周期成本 $C_{map} = 16$ 个周期与周期时间 $T_{cycle} = 0.5$ 纳秒的乘积。\n$$ t_{overhead} = C_{map} \\times T_{cycle} = 16 \\times 0.5 \\text{ ns} = 8 \\text{ ns} $$\n\n部分保存的数据移动时间基于预期的写入字节数 $B_{\\text{dirty}}$。让我们将预期的数据移动时间表示为 $E[t_{data\\_partial}]$：\n$$ E[t_{data\\_partial}] = \\frac{B_{\\text{dirty}}}{BW_{mem}} = \\frac{537.6 \\text{ bytes}}{32 \\times 10^9 \\text{ bytes/s}} = 16.8 \\times 10^{-9} \\text{ s} = 16.8 \\text{ ns} $$\n\n部分保存的总预期时间 $E[t_{partial}]$ 是开销和预期数据移动时间之和：\n$$ E[t_{partial}] = t_{overhead} + E[t_{data\\_partial}] = 8 \\text{ ns} + 16.8 \\text{ ns} = 24.8 \\text{ ns} $$\n\n最后，上下文保存时间的减少量 $\\Delta t_{cs}$ 是完整保存时间与总预期部分保存时间之间的差值。\n$$ \\Delta t_{cs} = t_{full} - E[t_{partial}] = 48 \\text{ ns} - 24.8 \\text{ ns} = 23.2 \\text{ ns} $$\n这是第二个所需的值。四舍五入到四位有效数字，得到 $23.20$ 纳秒。\n\n另外，我们可以用符号表示 $\\Delta t_{cs}$：\n$$ \\Delta t_{cs} = \\frac{B_{total}}{BW_{mem}} - \\left( C_{map} T_{cycle} + \\frac{p_{\\text{dirty}} B_{total}}{BW_{mem}} \\right) = \\frac{B_{total}(1-p_{\\text{dirty}})}{BW_{mem}} - C_{map} T_{cycle} $$\n这显示了因不写入干净寄存器 $(1-p_{\\text{dirty}})B_{total}$ 而节省的时间，被脏位图的新开销成本所抵消。\n$$ \\Delta t_{cs} = \\frac{1536 \\times (1-0.35)}{32 \\times 10^9} - (16 \\times 0.5 \\times 10^{-9}) = \\frac{1536 \\times 0.65}{32 \\times 10^9} - 8 \\times 10^{-9} $$\n$$ \\Delta t_{cs} = \\frac{998.4}{32 \\times 10^9} - 8 \\times 10^{-9} = 31.2 \\times 10^{-9} - 8 \\times 10^{-9} = 23.2 \\times 10^{-9} \\text{ s} = 23.2 \\text{ ns} $$\n结果是一致的。\n\n总结四舍五入到四位有效数字的最终数值结果：\n1.  预期保存到内存的字节数，$B_{\\text{dirty}}$：$537.6$ 字节。\n2.  上下文保存时间的减少量，$\\Delta t_{\\text{cs}}$：$23.20$ 纳秒。", "answer": "$$ \\boxed{\\begin{pmatrix} 537.6 & 23.20 \\end{pmatrix}} $$", "id": "3629491"}]}