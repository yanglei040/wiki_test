{"hands_on_practices": [{"introduction": "在计算机中，移位操作是基本但功能强大的运算之一，但右移操作分为两种：逻辑右移和算术右移。这两种移位操作的区别在于它们如何处理操作数的最高位（符号位），这直接关系到数据是被解释为无符号数还是有符号数。本练习 [@problem_id:3662568] 将引导你设计一个巧妙的测试，通过选择一个特殊的负数作为操作数，来区分一个“黑盒”算术逻辑单元（ALU）执行的是哪种右移，从而深刻理解二进制补码表示法下有符号数运算的精髓。", "problem": "一个黑盒算术逻辑单元 (ALU) 对一个 $n$ 位操作数执行一次右移操作。你不知道这个移位是算术右移（符号扩展）还是逻辑右移（零填充）。你可以提供一个以标准二进制补码形式编码的任意 $n$ 位操作数，以及一个移位计数 $k$（满足 $1 \\leq k  n$）。ALU 返回 $n$ 位的结果，并设置一个等于结果最高有效位 (MSB) 的符号标志位。设计一个单次测试，通过选择一个操作数，使其在移位后的符号行为在这两种可能性之间产生符号标志位的差异，从而区分这两种移位。然后，仅使用二进制补码编码以及算术和逻辑右移的标准定义，推导在此测试中逻辑右移结果与算术右移结果之间的精确有符号整数差值，并以 $n$ 和 $k$ 的函数形式表示为闭合表达式。你的最终答案必须是关于 $n$ 和 $k$ 的单一解析表达式。不需要进行舍入。", "solution": "要设计一个能够区分逻辑右移（LSR）和算术右移（ASR）的单次测试，关键在于找到一个操作数，使得两种移位操作对高位的填充方式不同。\n\n- **逻辑右移**：总是在最高位填充 $0$。\n- **算术右移**：用原始操作数的符号位（最高有效位，MSB）进行填充。\n\n对于任何非负数（MSB为 $0$），两种右移操作的结果是完全相同的，因为它们都用 $0$ 来填充高位。因此，为了区分它们，我们必须选择一个负数（MSB为 $1$）。在这种情况下，LSR 会填充 $0$，而 ASR 会填充 $1$。这将导致不同的结果和不同的符号标志位，从而实现区分。\n\n一个理想的测试用例是 $n$ 位二进制补码能表示的最小负数，$X = -2^{n-1}$。其二进制表示为 $1$ 后面跟着 $n-1$ 个 $0$，即 $(100...0)_2$。我们将这个数右移 $k$ 位（其中 $1 \\le k  n$）。\n\n**1. 计算逻辑右移的结果 ($V_{LSR}$)**\n对 $X = (100...0)_2$ 执行逻辑右移 $k$ 位，原先在第 $n-1$ 位的 $1$ 会被移到第 $n-1-k$ 位。空出的最高 $k$ 位全部用 $0$ 填充。结果的二进制模式将是：\n$$ R_{LSR} = (\\underbrace{00...0}_{k \\text{ 个}}1\\underbrace{00...0}_{n-k-1 \\text{ 个}})_2 $$\n这个结果的MSB是 $0$，所以它是一个正数。其值由 $1$ 所在的位置决定，即 $2^{n-1-k}$。\n$$ V_{LSR} = 2^{n-1-k} $$\n\n**2. 计算算术右移的结果 ($V_{ASR}$)**\n对 $X = (100...0)_2$ 执行算术右移 $k$ 位，空出的最高 $k$ 位将用原始符号位 $1$ 来填充。原先在第 $n-1$ 位的 $1$ 同样移到第 $n-1-k$ 位。结果的二进制模式将是：\n$$ R_{ASR} = (\\underbrace{11...1}_{k \\text{ 个}}1\\underbrace{00...0}_{n-k-1 \\text{ 个}})_2 $$\n这个结果的MSB是 $1$，所以它是一个负数。在二进制补码中，这个值的计算等同于对有符号整数做除以 $2^k$ 并向负无穷取整。\n$$ V_{ASR} = \\left\\lfloor \\frac{-2^{n-1}}{2^k} \\right\\rfloor = \\lfloor -2^{n-1-k} \\rfloor = -2^{n-1-k} $$\n\n**3. 计算差值**\n现在，我们计算两个结果之间的有符号整数差值：\n$$ V_{LSR} - V_{ASR} = (2^{n-1-k}) - (-2^{n-1-k}) $$\n$$ V_{LSR} - V_{ASR} = 2^{n-1-k} + 2^{n-1-k} = 2 \\cdot 2^{n-1-k} = 2^1 \\cdot 2^{n-k-1} = 2^{n-k} $$\n因此，逻辑右移结果与算术右移结果之间的精确差值为 $2^{n-k}$。", "answer": "$$\n\\boxed{2^{n-k}}\n$$", "id": "3662568"}, {"introduction": "掌握了基本的位运算后，我们便可以应用它们来解决实际的工程问题，例如在有限的内存空间中高效地组织数据。位域（Bitfield）打包是一种关键技术，它允许我们将多个小数据字段紧凑地存放在一个单独的字中，这在网络协议、硬件寄存器配置和嵌入式系统中至关重要。本练习 [@problem_id:3662512] 将让你扮演一名系统设计师，通过精确的位掩码和移位操作，将多个不同大小的字段组合成一个32位字，并探讨不同字节序（endianness）对数据存储的影响。", "problem": "一个计算机系统使用大小为 $32$ 位的固定宽度无符号字。位的编号从 $0$（最低有效位，LSB）到 $31$（最高有效位，MSB）。要求您为四个大小分别为 $3$、$5$、$6$ 和 $10$ 位的无符号字段，以及其余的保留位（设置为零）设计一个紧凑布局。该布局必须满足以下约束条件：\n\n- $3$ 位字段占据位 $[2:0]$。\n- $5$ 位字段紧随其后，占据位 $[7:3]$。\n- $6$ 位字段紧随其后，占据位 $[13:8]$。\n- $10$ 位字段紧随其后，占据位 $[23:14]$。\n- 位 $[31:24]$ 是保留位，必须设置为零。\n\n从二进制位置表示法的第一性原理以及位掩码和逻辑移位的定义出发，推导出每个字段和保留区域的位掩码。然后，使用您推导出的掩码和移位操作，将以下无符号字段值打包到一个遵循上述布局的单个 $32$ 位字中：\n- $3$ 位字段值 $= 5$，\n- $5$ 位字段值 $= 17$，\n- $6$ 位字段值 $= 42$，\n- $10$ 位字段值 $= 777$。\n\n最后，请解释生成的 $32$ 位字如何在大端序和小端序机器上序列化为一个连续的 $4$ 字节内存缓冲区，并明确说明每种情况下序列化后的四个字节值。将最终打包的字表示为十进制无符号整数。无需四舍五入，提供确切值。", "solution": "将数据打包到位域结构中的过程依赖于位置计数法和位逻辑运算的原理。一个无符号的 $32$ 位整数 $W$ 可以表示为和 $W = \\sum_{i=0}^{31} b_i 2^i$，其中 $b_i \\in \\{0, 1\\}$ 是位置 $i$ 的位值。打包的核心操作是按位左移 (``) 和按位或 (`|`)。\n\n**1. 位掩码的推导**\n\n对于一个宽度为 $w$ 位、起始于位位置 $s$（字段的LSB）的字段，其位掩码可以通过表达式 `((1  w) - 1)  s` 生成。项 `(1  w) - 1` 创建一个由 $w$ 个 1 组成的序列。左移 `s` 位将此序列移动到正确的位位置。\n\n- **字段1掩码 ($[2:0]$)**：宽度 $w=3$，起始位置 $s=0$。\n  掩码 $= ((1  3) - 1)  0 = 7  0 = 7$。\n  十六进制表示：$0x7$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0111_2$。\n\n- **字段2掩码 ($[7:3]$)**：宽度 $w=5$，起始位置 $s=3$。\n  掩码 $= ((1  5) - 1)  3 = 31  3 = 248$。\n  十六进制表示：$0xF8$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 1111\\ 1000_2$。\n\n- **字段3掩码 ($[13:8]$)**：宽度 $w=6$，起始位置 $s=8$。\n  掩码 $= ((1  6) - 1)  8 = 63  8 = 16128$。\n  十六进制表示：$0x3F00$。\n  二进制表示：$0000\\ 0000\\ 0000\\ 0000\\ 0011\\ 1111\\ 0000\\ 0000_2$。\n\n- **字段4掩码 ($[23:14]$)**：宽度 $w=10$，起始位置 $s=14$。\n  掩码 $= ((1  10) - 1)  14 = 1023  14 = 16760832$。\n  十六进制表示：$0xFFC000$。\n  二进制表示：$0000\\ 0000\\ 1111\\ 1111\\ 1100\\ 0000\\ 0000\\ 0000_2$。\n\n- **保留字段掩码 ($[31:24]$)**：宽度 $w=8$，起始位置 $s=24$。\n  掩码 $= ((1  8) - 1)  24 = 255  24 = 4278190080$。\n  十六进制表示：$0xFF000000$。\n  二进制表示：$1111\\ 1111\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000\\ 0000_2$。\n\n**2. 打包字段值**\n\n为了打包这些值，每个字段值都需左移到其起始位位置。由于字段不重叠且输入值保证能容纳，最终打包的字 $W$ 是所有移位后分量的按位或。\n\n要打包的值是：\n- $v_1 = 5$ ($101_2$) 用于字段1（起始位 $s_1=0$）。\n- $v_2 = 17$ ($10001_2$) 用于字段2（起始位 $s_2=3$）。\n- $v_3 = 42$ ($101010_2$) 用于字段3（起始位 $s_3=8$）。\n- $v_4 = 777$ ($1100001001_2$) 用于字段4（起始位 $s_4=14$）。\n- $v_5 = 0$ ($0_2$) 用于保留字段（起始位 $s_5=24$）。\n\n打包后的字 $W$ 计算如下：\n$W = (v_1  s_1) | (v_2  s_2) | (v_3  s_3) | (v_4  s_4) | (v_5  s_5)$\n$W = (5  0) | (17  3) | (42  8) | (777  14) | (0  24)$\n\n让我们计算每个分量：\n- $(5  0) = 5$\n- $(17  3) = 136$\n- $(42  8) = 10752$\n- $(777  14) = 12730368$\n- $(0  24) = 0$\n\n将这些值相加（或按位或）得到最终打包字的十进制表示：\n$W = 5 + 136 + 10752 + 12730368 + 0 = 12741261$\n\n为了验证，我们通过在其各自位置连接字段的二进制值来构造 $W$ 的二进制表示：\n- 位 $[31:24]$ (保留): $00000000_2$\n- 位 $[23:14]$ (字段 4): $1100001001_2$\n- 位 $[13:8]$ (字段 3): $101010_2$\n- 位 $[7:3]$ (字段 2): $10001_2$\n- 位 $[2:0]$ (字段 1): $101_2$\n\n组合成一个 $32$ 位的字（从MSB到LSB）：\n$W_{bin} = \\underbrace{00000000}_{[31:24]} \\underbrace{1100001001}_{[23:14]} \\underbrace{101010}_{[13:8]} \\underbrace{10001}_{[7:3]} \\underbrace{101}_{[2:0]}$\n\n为清晰起见，按字节分组：\n$W_{bin} = 00000000\\ 11000010\\ 01101010\\ 10001101_2$\n\n通过按半字节（4位组）分组转换为十六进制：\n$W_{hex} = \\underbrace{0000}_0 \\underbrace{0000}_0\\ \\underbrace{1100}_C \\underbrace{0010}_2\\ \\underbrace{0110}_6 \\underbrace{1010}_A\\ \\underbrace{1000}_8 \\underbrace{1101}_D$\n所以，$W = 0x00C26A8D$。\n\n将此十六进制值转换为十进制以确认我们的结果：\n$W = 12 \\times 16^5 + 2 \\times 16^4 + 6 \\times 16^3 + 10 \\times 16^2 + 8 \\times 16^1 + 13 \\times 16^0 = 12741261$。\n\n**3. 字节序与内存序列化**\n\n$32$ 位的打包字 $W = 0x00C26A8D$ 由四个 $8$ 位字节组成。我们从最高有效字节到最低有效字节对其进行标记：\n- 最高有效字节 (MSB): $0x00$\n- 字节 2: $0xC2$\n- 字节 1: $0x6A$\n- 最低有效字节 (LSB): $0x8D$\n\n字节序决定了这些字节在连续内存缓冲区中的存储顺序。\n\n- **大端序序列化**：“大端”（最高有效字节）首先存储在最低的内存地址。对于从地址 $A$ 开始的缓冲区，字节顺序是：\n  - 地址 $A$: $0x00$\n  - 地址 $A+1$: $0xC2$\n  - 地址 $A+2$: $0x6A$\n  - 地址 $A+3$: $0x8D$\n  $4$ 字节的序列化序列是：$00, C2, 6A, 8D$。\n\n- **小端序序列化**：“小端”（最低有效字节）首先存储在最低的内存地址。对于从地址 $A$ 开始的缓冲区，字节顺序是：\n  - 地址 $A$: $0x8D$\n  - 地址 $A+1$: $0x6A$\n  - 地址 $A+2$: $0xC2$\n  - 地址 $A+3$: $0x00$\n  $4$ 字节的序列化序列是：$8D, 6A, C2, 00$。\n\n要求的最终结果是将打包的字表示为十进制无符号整数。\n$W = 12741261$。", "answer": "$$\\boxed{12741261}$$", "id": "3662512"}, {"introduction": "操作数的大小是有限的，这意味着算术运算可能会超出其可表示的范围，即发生“溢出”。处理器如何处理溢出是一个核心的设计决策，它直接影响程序的正确性和可靠性。本练习 [@problem_id:3662498] 探讨了两种截然不同的溢出处理策略：在通用计算中常见的“回绕”（wrap-around）算术和在数字信号处理（DSP）中首选的“饱和”（saturating）算术。通过分析对一个特殊值——最小负数——求反时的不同行为，你将深入理解这两种算术模式的根本差异及其适用场景。", "problem": "考虑在处理器的算术逻辑单元 (ALU) 中实现的一种有符号整数数据类型，该类型使用固定宽度为 $n$ 位的补码表示法。其可表示范围为 $[-2^{n-1}, 2^{n-1} - 1]$。在此数据类型上定义两种求反运算符：\n\n- 回环求反 $N_{\\mathrm{w}}(x)$，它在模 $2^{n}$ 算术中计算 $-x$，并将结果解释为补码有符号值。\n- 饱和求反 $N_{\\mathrm{s}}(x)$，它在无界算术中计算 $-x$，然后通过以下公式将结果钳位 (clamp) 到可表示区间：\n\n$$\nN_{\\mathrm{s}}(x) = \\max\\left(-2^{n-1}, \\min\\left(-x, 2^{n-1}-1\\right)\\right)\n$$\n\n\n仅使用关于补码编码、模算术和饱和算术的基本事实，从第一性原理推导对于 $n$ 位操作数，$N_{\\mathrm{s}}(x)$ 和 $N_{\\mathrm{w}}(x)$ 在何种条件下会有所不同，并解释为什么最小可表示值的饱和求反与回环求反不同。\n\n然后，假设输入 $x$ 在所有 $2^{n}$ 个可表示的 $n$ 位补码值上均匀分布。将两种求反模式之间的平均绝对偏差定义为\n\n$$\nD(n) = \\frac{1}{2^{n}} \\sum_{x = -2^{n-1}}^{2^{n-1}-1} \\big| N_{\\mathrm{s}}(x) - N_{\\mathrm{w}}(x) \\big|\n$$\n\n将 $D(n)$ 精确计算为关于 $n$ 的封闭形式表达式。无需四舍五入，且不涉及任何单位。", "solution": "设 $n$ 位补码整数的可表示范围为区间 $I = [x_{\\min}, x_{\\max}]$，其中 $x_{\\min} = -2^{n-1}$ 且 $x_{\\max} = 2^{n-1}-1$。我们必须找出两种求反运算符 $N_{\\mathrms}(x)$ 和 $N_{\\mathrmw}(x)$ 产生不同结果的条件。\n\n我们分析在范围 $I$ 内的 $x$ 值的求反行为。$x$ 的数学求反是 $-x$。\n\n情况 1：$x \\in [-2^{n-1}+1, 2^{n-1}-1]$。\n对于此子区间中的任何 $x$，其求反结果 $-x$ 也落在可表示范围 $I$ 内。\n如果 $x \\in [1, 2^{n-1}-1]$，则 $-x \\in [-2^{n-1}+1, -1]$，在 $I$ 内。\n如果 $x \\in [-2^{n-1}+1, -1]$，则 $-x \\in [1, 2^{n-1}-1]$，在 $I$ 内。\n如果 $x=0$，则 $-x=0$，在 $I$ 内。\n在所有这些子情况中，数学求反 $-x$ 不会引起溢出。\n\n对于饱和求反，$N_{\\mathrms}(x) = \\max(x_{\\min}, \\min(-x, x_{\\max}))$。由于 $-x$ 已经在 $[x_{\\min}, x_{\\max}]$ 区间内，min 和 max 操作没有效果，因此 $N_{\\mathrms}(x) = -x$。\n\n对于回环求反，$N_{\\mathrmw}(x)$ 是使用模 $2^n$ 算术计算 $-x$ 的结果。对于补码数，当算术运算的结果在可表示范围内（即没有溢出）时，其结果与无界整数算术的结果相同。因此，对于所有 $x \\in [-2^{n-1}+1, 2^{n-1}-1]$，我们有 $N_{\\mathrmw}(x) = -x$。\n\n因此，对于任何满足 $x \\neq -2^{n-1}$ 的 $x$，我们有 $N_{\\mathrms}(x) = N_{\\mathrmw}(x) = -x$。\n\n情况 2：$x = -2^{n-1}$（最小可表示值）。\n数学求反为 $-x = -(-2^{n-1}) = 2^{n-1}$。此值超出了可表示范围 $I$，因为它比 $x_{\\max} = 2^{n-1}-1$ 大 1。这是唯一发生溢出的情况。\n\n我们来计算 $x = -2^{n-1}$ 时的 $N_{\\mathrms}(x)$：\n$N_{\\mathrms}(-2^{n-1}) = \\max( -2^{n-1}, \\min( -(-2^{n-1}), 2^{n-1}-1 ) )$\n$N_{\\mathrms}(-2^{n-1}) = \\max( -2^{n-1}, \\min( 2^{n-1}, 2^{n-1}-1 ) )$\n因为 $\\min( 2^{n-1}, 2^{n-1}-1 ) = 2^{n-1}-1$，\n$N_{\\mathrms}(-2^{n-1}) = \\max( -2^{n-1}, 2^{n-1}-1 ) = 2^{n-1}-1$。\n结果被饱和到最大可表示值。\n\n现在，我们来计算 $x = -2^{n-1}$ 时的 $N_{\\mathrmw}(x)$：\n回环求反依赖于模 $2^n$ 算术。一个数 $x$ 的负数由 $2^n-x$ 的位模式表示（对于 $x \\neq 0$）。对于补码，求反也可以看作是按位取反再加 1。\n$x = -2^{n-1}$ 的位模式是 $100...0$（一个 1 后面跟着 $n-1$ 个 0）。\n计算 $N_{\\mathrmw}(-2^{n-1})$：\n1. $100...0$ 按位取反是 $011...1$。\n2. 将 $1$ 加到 $011...1$ 上得到 $100...0$。\n得到的位模式与原始模式相同。这个模式，$100...0$，在补码中表示值 $-2^{n-1}$。\n因此，$N_{\\mathrmw}(-2^{n-1}) = -2^{n-1}$。\n另外，使用模算术，我们要表示的值是 $-(-2^{n-1}) = 2^{n-1}$。整数 $2^{n-1}$ 与 $-2^{n-1}$ 模 $2^n$ 同余，因为 $2^{n-1} - (-2^{n-1}) = 2 \\cdot 2^{n-1} = 2^n$，它是 $2^n$ 的倍数。无符号整数 $2^{n-1}$ 的位模式所代表的值在补码系统中确实是 $-2^{n-1}$。\n\n差异总结：\n运算符 $N_{\\mathrms}(x)$ 和 $N_{\\mathrmw}(x)$ 仅当 $x = -2^{n-1}$ 时不同。\n对于这个值：\n$N_{\\mathrms}(-2^{n-1}) = 2^{n-1}-1$\n$N_{\\mathrmw}(-2^{n-1}) = -2^{n-1}$\n差异的产生是因为最负数的负数，即 $-(-2^{n-1}) = 2^{n-1}$，超出了可表示范围。饱和算术将此结果钳位到最近的边界，即最大值 $2^{n-1}-1$。回环算术执行模 $2^n$ 的运算，导致结果 $2^{n-1}$ 回环并被解释为 $-2^{n-1}$。\n\n现在我们计算平均绝对偏差 $D(n)$。\n$$\nD(n) = \\frac{1}{2^{n}} \\sum_{x = -2^{n-1}}^{2^{n-1}-1} \\big| N_{\\mathrms}(x) - N_{\\mathrmw}(x) \\big|\n$$\n根据我们的分析，仅当 $x = -2^{n-1}$ 时，项 $| N_{\\mathrms}(x) - N_{\\mathrmw}(x) |$ 才不为零。对于求和范围内的所有其他 $2^n-1$ 个 $x$ 值，该项为 $0$。\n因此，求和简化为单项：\n$$\n\\sum_{x = -2^{n-1}}^{2^{n-1}-1} \\big| N_{\\mathrms}(x) - N_{\\mathrmw}(x) \\big| = \\big| N_{\\mathrms}(-2^{n-1}) - N_{\\mathrmw}(-2^{n-1}) \\big|\n$$\n代入我们找到的值：\n$$\n\\text{Sum} = \\big| (2^{n-1}-1) - (-2^{n-1}) \\big| = \\big| 2^{n-1} - 1 + 2^{n-1} \\big| = \\big| 2 \\cdot 2^{n-1} - 1 \\big| = |2^n - 1|\n$$\n由于位宽 $n$ 是大于或等于 $1$ 的整数，$2^n-1 \\ge 1$。因此，$|2^n - 1| = 2^n - 1$。\n\n最后，我们将总和除以点的总数 $2^n$ 来计算 $D(n)$：\n$$\nD(n) = \\frac{1}{2^n} (2^n - 1)\n$$\n这可以写作：\n$$\nD(n) = \\frac{2^n}{2^n} - \\frac{1}{2^n} = 1 - \\frac{1}{2^n}\n$$\n这就是平均绝对偏差的封闭形式表达式。", "answer": "$$\n\\boxed{1 - \\frac{1}{2^n}}\n$$", "id": "3662498"}]}