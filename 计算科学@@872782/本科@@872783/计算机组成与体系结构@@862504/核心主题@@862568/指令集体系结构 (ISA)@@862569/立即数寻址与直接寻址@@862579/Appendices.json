{"hands_on_practices": [{"introduction": "立即数寻址是将常量直接编码在指令中的一种高效方式，但其表示范围受限于指令中有限的立即数字段。本练习 [@problem_id:3648996] 旨在通过一个假设的指令集，探索如何利用符号扩展和零扩展的不同特性，组合指令来生成超出单个立即数字段范围的常量。通过这个实践，你将更深刻地理解立即数寻址的能力边界，并明确在何种情况下必须采用直接寻址从内存中加载常量。", "problem": "一个假设的精简指令集计算机的简化加载与算术子集使用两种操作数指定机制：立即寻址和直接寻址。该机器拥有宽度为 $w=32$ 位的通用寄存器，采用二进制补码整数运算，并包含以下指令，这些指令接受嵌入在指令字中宽度为 $k=8$ 位的立即数字段。\n\n定义与语义：\n- 立即寻址：操作数是编码在指令中的常量。指令 $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}\\_8$ 将 $k=8$ 位字段 $\\mathrm{imm}\\_8$ 进行二进制补码符号扩展到 $w=32$ 位后，写入寄存器 $r_d$。指令 $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}\\_8$ 计算 $r_d$ 与 $k=8$ 位字段 $\\mathrm{imm}\\_8$ 零扩展到 $w=32$ 位后的值的按位 $\\mathrm{OR}$，结果写回 $r_d$。没有其他带立即数的指令可用。\n- 直接寻址：操作数位于内存中，其绝对地址编码在指令中。指令 $\\mathrm{LDRI}\\;r_d,\\; \\mathrm{addr}\\_{16}$ 将存储在绝对内存地址 $\\mathrm{addr}\\_{16}$ 处的 $w=32$ 位字加载到 $r_d$ 中。假设内存中有一个只读常量池，因此任何 $w=32$ 位的常量都可以放置在那里，并在需要时通过直接寻址获取。\n\n你需要针对具体的目标常量集合\n$$S=\\{-200,\\,-129,\\,-128,\\,-1,\\,0,\\,42,\\,100,\\,127,\\,128,\\,200,\\,255,\\,256,\\,300\\},$$\n来判断哪些常量必须通过直接寻址加载（即，不能仅通过单条立即寻址指令，也不能通过任何不访问内存的、由给定带立即数指令组成的有限序列将其放入寄存器中）。除了对 $S$ 中的常量进行分类，你的答案还必须正确陈述使用给定的 $k=8$ 立即数字段，哪些常量是可合成的，哪些是不可合成的一般模式，并列出在可能的情况下避免直接寻址的合理变通方法。\n\n哪个选项是正确的？\n\nA. 唯一能由单个立即数直接表示的常量是那些满足 $c\\in[-128,127]$ 的常量 $c$；除此之外，一个两指令的变通方法恰好覆盖了 $c\\in[128,255]$，通过先执行 $\\mathrm{MOVI}\\;r_d,\\,0$，再执行 $\\mathrm{ORI}\\;r_d,\\,c$，因为从零开始的零扩展和按位 $\\mathrm{OR}$ 可以产生任何其低8位等于 $c$ 的非负数 $c$。所有其他 $c$ 都需要直接寻址。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,256,\\,300\\}$ 必须通过直接寻址加载。\n\nB. 任何满足 $c\\in[0,65535]$ 的 $32$ 位常量 $c$ 都可以通过使用零扩展的两指令序列在不访问内存的情况下构建，因此 $\\{128,\\,200,\\,255\\}$ 都不需要直接寻址，但 $c\\in\\{-200,\\,-129,\\,-128,\\,-1\\}$ 必须从内存中获取，因为负常量不能通过位运算从零构建。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,-128,\\,-1\\}$ 需要直接寻址；所有其他常量则不需要。\n\nC. 因为重复使用 $\\mathrm{ORI}$ 可以逐步将高位字节设置为任何期望的模式，所以集合 $S$ 中的每个常量都可以在不访问内存的情况下合成；如果允许足够多的立即数 $\\mathrm{ORI}$ 操作，则无需直接寻址。\n\nD. 由于立即数只有 $k=8$ 位宽，任何绝对值超过 $255$ 的常量都必须从内存加载，但任何绝对值至多为 $255$ 的常量（包括所有 $|c|\\le 255$ 的负数）由于符号扩展都可以在一条指令中直接表示。因此，在集合 $S$ 中，恰好 $\\{256,\\,300\\}$ 需要直接寻址；所有其他常量则不需要。", "solution": "首先，我们确定所有可以仅使用 $\\mathrm{MOVI}$ 和 $\\mathrm{ORI}$ 指令合成的 $32$ 位整数常量的集合。如果一个常量可以是一系列这些指令执行后寄存器中的最终值，那么它就是可合成的。\n\n1.  **$\\mathrm{MOVI}$ 指令分析：**\n    指令 $\\mathrm{MOVI}\\;r_d,\\; \\mathrm{imm}\\_8$ 接受一个 $8$ 位二进制补码立即数，并将其符号扩展到 $32$ 位。一个 $8$ 位二进制补码整数的范围是从 $-2^{8-1}$ 到 $2^{8-1}-1$，即 $[-128, 127]$。因此，单条 $\\mathrm{MOVI}$ 指令可以生成任何整数常量 $c$，使得 $c \\in [-128, 127]$。\n\n2.  **$\\mathrm{ORI}$ 指令分析：**\n    指令 $\\mathrm{ORI}\\;r_d,\\; \\mathrm{imm}\\_8$ 计算 $r_d \\leftarrow r_d \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_8)$。字段 $\\mathrm{imm}\\_8$ 被零扩展，意味着它被视为一个 $8$ 位无符号值，可以表示从 $0$ 到 $255$ 的任何整数。$\\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_8)$ 产生一个 $32$ 位值，其中高24位全为 $0$，低8位对应于 $\\mathrm{imm}\\_8$。\n\n3.  **指令序列分析：**\n    任何合成序列都必须以一条 $\\mathrm{MOVI}$ 指令开始以加载初始值，后跟任意数量的 $\\mathrm{ORI}$ 指令（或不跟）。我们根据初始值的符号分析两种情况。\n\n    **情况1：合成非负常量。**\n    要合成一个非负常量，寄存器的高位必须为 $0$。这要求初始的 $\\mathrm{MOVI}$ 使用一个非负立即数，$\\mathrm{imm}\\_A \\in [0, 127]$。在这种情况下，寄存器的高24位被设置为 $0$。随后的 $\\mathrm{ORI}$ 操作与一个零扩展的8位立即数进行或运算，该立即数的高24位也为 $0$。因此，结果的高24位将保持为 $0$，这意味着结果常量 $C$ 必须是非负的，并且小于 $2^8=256$。\n    -   对于 $c \\in [0, 127]$，我们可以使用单条指令：$\\mathrm{MOVI}\\;r_d,\\; c$。\n    -   对于 $c \\in [128, 255]$，我们可以使用一个两指令序列：先用 $\\mathrm{MOVI}\\;r_d,\\;0$ 将寄存器清零，然后用 $\\mathrm{ORI}\\;r_d,\\;c$ 将所需的值置入低8位。\n    因此，整个整数范围 $[0, 255]$ 都是可合成的。\n\n    **情况2：合成负常量。**\n    要合成一个负常量，寄存器的高位必须是 $1$。这要求初始的 $\\mathrm{MOVI}$ 使用一个负立即数，$\\mathrm{imm}\\_A \\in [-128, -1]$。这会将寄存器的高24位设置为 $1$。随后的 $\\mathrm{ORI}$ 操作与一个零扩展的立即数进行或运算。由于零扩展立即数的高24位全为 $0$，与它们进行或运算不会改变寄存器已经设置为 $1$ 的高位。因此，任何可合成的负数的高24位都必须是 $1$，这意味着它们必须在 $[-2^{24}, -1]$ 的范围内，同时其低8位也受限于 $\\mathrm{MOVI}$ 和 $\\mathrm{ORI}$ 的组合。\n    具体来说，合成的值为 $C = \\mathrm{SEXT}_{32}(\\mathrm{imm}\\_A) \\lor \\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$。如果 $\\mathrm{imm}\\_A$ 是负数，则 $\\mathrm{SEXT}_{32}(\\mathrm{imm}\\_A)$ 的高24位为1。$\\mathrm{ZEXT}_{32}(\\mathrm{imm}\\_B)$ 的高24位为0。因此 $C$ 的高24位仍为1。$C$ 的低8位是 $(\\mathrm{imm}\\_A \\text{ 的低8位}) \\lor \\mathrm{imm}\\_B$。这可以生成 $[-128, -1]$ 范围内的任何负数。例如，要生成-1 (0xFFFFFFFF)，可以 `MOVI r, -1`。要生成-128 (0xFFFFFF80)，可以 `MOVI r, -128`。$\\mathrm{ORI}$ 操作无法将值的范围扩展到比 $[-128, -1]$ 更负的数。\n\n4.  **关于可合成常量的结论：**\n    由给定指令可合成的所有整数的集合是情况1和情况2范围的并集：\n    $$ \\{\\text{可合成整数}\\} = [-128, -1] \\cup [0, 255] = [-128, 255] $$\n    任何在此范围之外的整数常量都无法合成，必须使用 $\\mathrm{LDRI}$ 指令从内存中加载。\n\n5.  **对集合 $S$ 中常量的分类：**\n    我们将 $S$ 中的每个常量与可合成范围 $[-128, 255]$ 进行比较。\n    -   $-200$：不在范围内。必须加载。\n    -   $-129$：不在范围内。必须加载。\n    -   $-128$：在范围内。可合成。\n    -   $-1$：在范围内。可合成。\n    -   $0$：在范围内。可合成。\n    -   $42$：在范围内。可合成。\n    -   $100$：在范围内。可合成。\n    -   $127$：在范围内。可合成。\n    -   $128$：在范围内。可合成。\n    -   $200$：在范围内。可合成。\n    -   $255$：在范围内。可合成。\n    -   $256$：不在范围内。必须加载。\n    -   $300$：不在范围内。必须加载。\n\n    $S$ 中必须通过直接寻址加载的常量集合是 $\\{-200, -129, 256, 300\\}$。\n\n### 逐项分析选项\n\n**A. 唯一能由单个立即数直接表示的常量是那些满足 $c\\in[-128,127]$ 的常量 $c$；除此之外，一个两指令的变通方法恰好覆盖了 $c\\in[128,255]$，通过先执行 $\\mathrm{MOVI}\\;r_d,\\,0$，再执行 $\\mathrm{ORI}\\;r_d,\\,c$，因为从零开始的零扩展和按位 $\\mathrm{OR}$ 可以产生任何其低8位等于 $c$ 的非负数 $c$。所有其他 $c$ 都需要直接寻址。因此，在集合 $S$ 中，恰好 $\\{-200,\\,-129,\\,256,\\,300\\}$ 必须通过直接寻址加载。**\n-   **分析：** 该推理正确地确定了可合成的常量范围为 $[-128, 255]$。将此规则应用于集合 $S$ 得出的列表 $\\{-200, -129, 256, 300\\}$ 与我们的推导相符。整个陈述是一致且正确的。\n-   **结论：** **正确**。\n\n**B. 任何满足 $c\\in[0,65535]$ 的 $32$ 位常量 $c$ 都可以通过使用零扩展的两指令序列在不访问内存的情况下构建...**\n-   **分析：** 这是错误的。$\\mathrm{ORI}$ 指令只影响最低的8位，不可能设置位范围 $[15:8]$ 来生成像 $256$ ($0x100$) 这样的数字。\n-   **结论：** **不正确**。\n\n**C. 因为重复使用 $\\mathrm{ORI}$ 可以逐步将高位字节设置为任何期望的模式...**\n-   **分析：** 这个陈述基于一个错误的前提。$\\mathrm{ORI}$ 指令被定义为使用一个零扩展的8位立即数。这样的操作永远不能设置高位字节（位 $31$ 到 $8$）中的任何位。\n-   **结论：** **不正确**。\n\n**D. 由于立即数只有 $k=8$ 位宽，任何绝对值超过 $255$ 的常量都必须从内存加载，但任何绝对值至多为 $255$ 的常量...都可以在一条指令中直接表示。**\n-   **分析：** “任何绝对值至多为 $255$ 的常量...都可以在一条指令中直接表示”是错误的。$\\mathrm{MOVI}$ 只能产生 $[-128, 127]$ 范围内的常量。此外，声称任何绝对值至多为 $255$ 的常量都是可合成的是错误的。例如，$c = -200$ 的 $|c|=200 \\le 255$，但它不是可合成的。\n-   **结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "3648996"}, {"introduction": "在程序设计中，我们经常需要使用小的常量，例如循环的步长。此时，架构师和程序员面临一个选择：是使用立即数寻址将常量硬编码到指令中，还是通过直接寻址从内存中加载它？这个选择会对程序的性能和大小产生直接影响。本练习 [@problem_id:3648974] 通过分析一个简单的数组求和循环，让你亲手计算和比较这两种寻址方式在执行周期和代码空间上的差异，从而直观地体验它们各自的优劣。", "problem": "考虑一个玩具级的加载-存储指令集架构，其字长为$32$位，地址为$32$位。处理器顺序执行指令，无重叠；每条指令在下一条指令开始前完成。所有数据加载均在一级（L1）数据缓存中命中。以下基本定义适用：\n- 立即数寻址模式：指令在指令字中编码一个常量操作数；使用立即数操作数不执行数据内存读取。\n- 直接寻址模式：指令在指令字中编码一个绝对数据内存地址；使用直接内存操作数会从编码的地址执行一次数据内存读取。\n- 带比例索引的寄存器间接寻址：加载指令通过将基址寄存器与一个比例索引（此处按元素大小缩放）相加来计算有效地址。\n\n假设此玩具架构有以下经过充分测试的事实：\n- 整数寄存器到寄存器加法需要$1$个周期，占用$4$字节的代码。\n- 带立即数操作数的整数加法（例如，按常数递增）需要$1$个周期，占用$4$字节的代码。\n- 立即数移动到寄存器（例如，将寄存器初始化为常数）需要$1$个周期，占用$4$字节的代码。\n- 使用带比例索引的寄存器间接寻址从内存加载（例如，加载数组元素）需要$3$个周期，占用$4$字节的代码。\n- 使用直接寻址从内存加载（绝对地址编码在指令中）需要$3$个周期，占用$8$字节的代码（用于存放$32$位地址）。\n- 带两个寄存器集成比较的条件分支需要$1$个周期，占用$4$字节的代码。在下面的程序中，该分支在每次循环迭代时执行一次，且分支预测是完美的（没有额外惩罚）。\n\n给定一个程序，用于对位于寄存器$r_{\\mathrm{base}}$中基地址处的$N$个连续$32$位整数数组求和。两个变体仅在处理循环步长的方式上有所不同：\n\n变体 I（立即数步长）：循环索引$r_{i}$在每次迭代中通过立即数常量$1$递增。\n- 循环前初始化：\n  - 使用立即数移动指令设置 $r_{i} \\leftarrow 0$。\n  - 使用立即数移动指令设置 $r_{\\mathrm{sum}} \\leftarrow 0$。\n  - 使用立即数移动指令设置 $r_{N} \\leftarrow N$。\n- 每次迭代的循环体：\n  - 使用带比例索引的寄存器间接寻址将元素加载到$r_{t}$：$[r_{\\mathrm{base}} + r_{i} \\times 4]$。\n  - 执行加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$。\n  - 通过立即数增加索引：$r_{i} \\leftarrow r_{i} + 1$。\n  - 条件分支：如果 $r_{i}  r_{N}$ 则继续。\n\n变体 II（直接寻址步长）：循环索引$r_{i}$在每次迭代中增加一个步长值，该值通过直接寻址从一个固定的绝对地址 $\\alpha$ 获取，该地址存放着常量$1$。\n- 循环前初始化：与变体 I 相同。\n- 每次迭代的循环体：\n  - 使用带比例索引的寄存器间接寻址将元素加载到$r_{t}$：$[r_{\\mathrm{base}} + r_{i} \\times 4]$。\n  - 使用直接寻址从绝对地址 $\\alpha$ 将步长加载到$r_{\\mathrm{step}}$。\n  - 执行加法 $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$。\n  - 执行加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$。\n  - 条件分支：如果 $r_{i}  r_{N}$ 则继续。\n\n仅使用上述定义以及给定的时序和代码大小事实，推导出总周期数 $C_{\\mathrm{I}}(N)$ 和 $C_{\\mathrm{II}}(N)$，以及静态代码大小 $\\mathrm{size}_{\\mathrm{I}}$ 和 $\\mathrm{size}_{\\mathrm{II}}$，作为 $N$ 的函数。然后计算：\n- 变体 I相对于变体 II的加速比，定义为 $S(N) = \\dfrac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)}$。\n- 静态代码大小比率，定义为 $R = \\dfrac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}}$。\n\n将你的最终答案表示为包含 $S(N)$ 和 $R$ 的行矩阵。不需要四舍五入，你应该给出精确的闭式表达式。最终答案中不应包含单位。", "solution": "我们通过枚举执行的指令并加总它们的周期和大小来进行计算。\n\n对于变体 I（立即数步长）：\n\n循环前初始化包括三条立即数移动指令：\n- 设置 $r_{i} \\leftarrow 0$：$1$个周期，$4$字节。\n- 设置 $r_{\\mathrm{sum}} \\leftarrow 0$：$1$个周期，$4$字节。\n- 设置 $r_{N} \\leftarrow N$：$1$个周期，$4$字节。\n\n因此，循环前的周期数为\n$$\nC_{\\mathrm{I,init}} = 1 + 1 + 1 = 3,\n$$\n循环前的代码大小为\n$$\n\\mathrm{size}_{\\mathrm{I,init}} = 4 + 4 + 4 = 12.\n$$\n\n每次循环迭代执行：\n- 通过带比例索引的寄存器间接寻址加载元素：$3$个周期，$4$字节。\n- 执行加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$：$1$个周期，$4$字节。\n- 执行立即数增量加法 $r_{i} \\leftarrow r_{i} + 1$：$1$个周期，$4$字节。\n- 条件分支：$1$个周期，$4$字节。\n\n因此，每次迭代的周期数为\n$$\nC_{\\mathrm{I,iter}} = 3 + 1 + 1 + 1 = 6,\n$$\n循环体的静态代码大小为\n$$\n\\mathrm{size}_{\\mathrm{I,loop}} = 4 + 4 + 4 + 4 = 16.\n$$\n\n因为有$N$次迭代，变体 I 的总周期数和静态代码大小为\n$$\nC_{\\mathrm{I}}(N) = C_{\\mathrm{I,init}} + N \\cdot C_{\\mathrm{I,iter}} = 3 + 6N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{I}} = \\mathrm{size}_{\\mathrm{I,init}} + \\mathrm{size}_{\\mathrm{I,loop}} = 12 + 16 = 28.\n$$\n\n对于变体 II（直接寻址步长）：\n\n循环前初始化与变体 I 相同，得出\n$$\nC_{\\mathrm{II,init}} = 3, \\quad \\mathrm{size}_{\\mathrm{II,init}} = 12.\n$$\n\n每次循环迭代执行：\n- 通过带比例索引的寄存器间接寻址加载元素：$3$个周期，$4$字节。\n- 通过直接寻址从绝对地址 $\\alpha$ 加载步长：$3$个周期，$8$字节。\n- 执行加法 $r_{i} \\leftarrow r_{i} + r_{\\mathrm{step}}$：$1$个周期，$4$字节。\n- 执行加法 $r_{\\mathrm{sum}} \\leftarrow r_{\\mathrm{sum}} + r_{t}$：$1$个周期，$4$字节。\n- 条件分支：$1$个周期，$4$字节。\n\n因此，每次迭代的周期数为\n$$\nC_{\\mathrm{II,iter}} = 3 + 3 + 1 + 1 + 1 = 9,\n$$\n循环体的静态代码大小为\n$$\n\\mathrm{size}_{\\mathrm{II,loop}} = 4 + 8 + 4 + 4 + 4 = 24.\n$$\n\n因此，变体 II 的总周期数和静态代码大小为\n$$\nC_{\\mathrm{II}}(N) = C_{\\mathrm{II,init}} + N \\cdot C_{\\mathrm{II,iter}} = 3 + 9N,\n$$\n$$\n\\mathrm{size}_{\\mathrm{II}} = \\mathrm{size}_{\\mathrm{II,init}} + \\mathrm{size}_{\\mathrm{II,loop}} = 12 + 24 = 36.\n$$\n\n现在计算所要求的比较值。\n\n变体 I 相对于变体 II 的加速比定义为\n$$\nS(N) = \\frac{C_{\\mathrm{II}}(N)}{C_{\\mathrm{I}}(N)} = \\frac{3 + 9N}{3 + 6N} = \\frac{3(1 + 3N)}{3(1 + 2N)} = \\frac{1 + 3N}{1 + 2N}.\n$$\n\n静态代码大小比率为\n$$\nR = \\frac{\\mathrm{size}_{\\mathrm{I}}}{\\mathrm{size}_{\\mathrm{II}}} = \\frac{28}{36} = \\frac{7}{9}.\n$$\n\n这些是关于 $N$（对于 $S(N)$）和常数（对于 $R$）的精确闭式表达式。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{1+3N}{1+2N}  \\frac{7}{9}\\end{pmatrix}}$$", "id": "3648974"}, {"introduction": "对于无法用单个立即数表示的大常量，直接从内存加载似乎是显而易见的解决方案。然而，这是否总是最高效的方法？本练习 [@problem_id:3649029] 将挑战这一直觉，探讨一种通过指令序列“合成”大常量的技术，即使用一系列快速的移位和立即数加法指令来逐步构建目标值。你将计算并比较这种合成方法的延迟与考虑了缓存命中概率的直接内存加载的期望延迟，从而揭示在现代复杂的内存体系结构下，指令级优化与数据访问策略之间的深刻权衡。", "problem": "一个中央处理器 (CPU) 实现两种相关的寻址机制：立即寻址和直接寻址。立即寻址将一个常数直接编码在指令的立即数字段中，而直接寻址则编码一个内存地址，常数从该地址中获取。考虑在一个具有以下指令集和时序模型的 CPU 上，在通用寄存器中生成一个特定的 $64$ 位常数 $K$ 的任务：\n\n- 该指令集提供三种相关操作，每种操作在 $1$ 个周期内完成，其产生的结果只能在下一个周期被后续的依赖指令使用：\n    - $ \\mathrm{LOAD\\_IMM12}(r, u) $ 将无符号 $12$ 位立即数 $u \\in [0, 2^{12}-1]$ 写入寄存器 $r$。\n    - $ \\mathrm{SLL12}(r) $ 将寄存器 $r$ 逻辑左移 $12$ 位。\n    - $ \\mathrm{ADD\\_IMM12}(r, u) $ 将无符号 $12$ 位立即数 $u \\in [0, 2^{12}-1]$ 加到寄存器 $r$。\n  假设真数据依赖强制这些操作严格串行化；在构建 $K$ 的序列中不存在重叠执行。\n\n- 直接寻址使用 $ \\mathrm{LD\\_DIRECT}(r, A) $，该指令将绝对地址 $A$ 处的 $64$ 位字加载到寄存器 $r$ 中。其延迟，从指令发射到数据在寄存器 $r$ 中可用（包括地址生成和写回），取决于缓存/内存级别的命中情况：\n    - 一级 (L1) 缓存命中延迟 $=4$ 个周期，概率为 $P_{\\mathrm{L1}}=0.93$。\n    - 二级 (L2) 缓存命中延迟 $=12$ 个周期，概率为 $P_{\\mathrm{L2}}=0.05$。\n    - 三级 (L3) 缓存命中延迟 $=36$ 个周期，概率为 $P_{\\mathrm{L3}}=0.015$。\n    - 主存延迟 $=200$ 个周期，概率为 $P_{\\mathrm{Mem}}=0.005$。\n  这些概率满足 $P_{\\mathrm{L1}}+P_{\\mathrm{L2}}+P_{\\mathrm{L3}}+P_{\\mathrm{Mem}}=1$。\n\nCPU 运行频率为 $f = 3.0 \\times 10^{9} \\, \\mathrm{Hz}$。\n\n给定常数\n$$K = \\mathrm{0xABCDEF123456789}.$$\n\n- 仅使用 $ \\mathrm{LOAD\\_IMM12} $、$ \\mathrm{SLL12} $ 和 $ \\mathrm{ADD\\_IMM12} $，从基本原理出发，设计一种通过将 $12$ 位立即数与左移 $12$ 位操作相结合，在寄存器中合成 $K$ 的方法。你的设计必须解释如何分解 $K$ 以及如何对操作进行排序，并对在给定约束下指令数的最少化给出明确的论证。\n- 确定在此 CPU 上使用立即寻址生成 $K$ 所需的最少周期数。\n- 计算在此 CPU 上使用直接寻址生成 $K$ 的期望周期数。\n- 最后，计算立即寻址合成和直接寻址加载之间的延迟差（以纳秒为单位），定义为\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}},$$\n其中 $T_{\\mathrm{imm}}$ 和 $T_{\\mathrm{direct}}$ 分别是各自的延迟（以纳秒为单位）。将你最终的 $\\Delta T$ 四舍五入到四位有效数字，并以纳秒表示。", "solution": "首先，我们解决使用立即寻址合成常数 $K$ 的问题。常数 $K = \\mathrm{0xABCDEF123456789}$ 是一个60位的数值（由15个十六进制数字组成），当加载到64位寄存器时，高4位为零。\n\n可用的指令 $\\mathrm{LOAD\\_IMM12}$、$\\mathrm{ADD\\_IMM12}$ 和 $\\mathrm{SLL12}$ 操作12位立即数并移位12位。这表明可以将这个60位的常数自然地分解为五个12位的块（每个块3个十六进制数字）。我们将 $K$ 分解为五个12位的块，从最高有效位 ($k_4$) 到最低有效位 ($k_0$)：\n$K = \\mathrm{0xABC\\ DEF\\ 123\\ 456\\ 789}$\n这些块是：\n- $k_4 = \\mathrm{0xABC}$\n- $k_3 = \\mathrm{0xDEF}$\n- $k_2 = \\mathrm{0x123}$\n- $k_1 = \\mathrm{0x456}$\n- $k_0 = \\mathrm{0x789}$\n\n$K$ 的值可以表示为以 $2^{12}$ 为底的多项式，可以使用霍纳法则（Horner's method）高效地合成：\n$$K = ((((k_4 \\cdot 2^{12} + k_3) \\cdot 2^{12} + k_2) \\cdot 2^{12} + k_1) \\cdot 2^{12} + k_0)$$\n这对应于在寄存器 $r$ 中的以下操作序列：\n1. 用最高有效块 $k_4$ 初始化寄存器 $r$。\n2. 将 $r$ 左移 $12$ 位（乘以 $2^{12}$）。\n3. 加上下一个块 $k_3$。\n4. 对剩余的块 $k_2$、$k_1$ 和 $k_0$ 重复步骤 2 和 3。\n\n在寄存器（例如 $r0$）中生成 $K$ 的具体指令序列是：\n1. $\\mathrm{LOAD\\_IMM12}(r0, \\mathrm{0xABC})$\n2. $\\mathrm{SLL12}(r0)$\n3. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0xDEF})$\n4. $\\mathrm{SLL12}(r0)$\n5. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x123})$\n6. $\\mathrm{SLL12}(r0)$\n7. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x456})$\n8. $\\mathrm{SLL12}(r0)$\n9. $\\mathrm{ADD\\_IMM12}(r0, \\mathrm{0x789})$\n\n该序列包含 $1$ 条 $\\mathrm{LOAD\\_IMM12}$ 指令、$4$ 条 $\\mathrm{SLL12}$ 指令 和 $4$ 条 $\\mathrm{ADD\\_IMM12}$ 指令，总共 $9$ 条指令。要构造这个 $60$ 位的常数，我们必须指定其五个非零的 $12$ 位块，这至少需要 $5$ 条提供立即数值的指令。为了将这五个块放置在它们正确的比特位置上，我们需要 $4$ 次 $12$ 位的相对移位。因此，最少需要 $5 + 4 = 9$ 条指令。所提出的序列达到了这个下限。\n\n接下来，我们确定这种立即寻址方法的周期数 $C_{\\mathrm{imm}}$。问题陈述中指出，每条指令需要 $1$ 个周期，并且序列中每条连续指令之间存在真数据依赖，强制了严格的串行化。因此，总周期数等于指令数。\n$$C_{\\mathrm{imm}} = 9 \\text{ cycles}$$\n\n现在，我们计算直接寻址方法的期望周期数 $E[C_{\\mathrm{direct}}]$。这种方法使用单条指令 $\\mathrm{LD\\_DIRECT}$，其延迟是各种可能延迟按其概率加权的总和：\n$$E[C_{\\mathrm{direct}}] = C_{\\mathrm{L1}}P_{\\mathrm{L1}} + C_{\\mathrm{L2}}P_{\\mathrm{L2}} + C_{\\mathrm{L3}}P_{\\mathrm{L3}} + C_{\\mathrm{Mem}}P_{\\mathrm{Mem}}$$\n代入给定值：\n$$E[C_{\\mathrm{direct}}] = (4 \\cdot 0.93) + (12 \\cdot 0.05) + (36 \\cdot 0.015) + (200 \\cdot 0.005)$$\n$$E[C_{\\mathrm{direct}}] = 3.72 + 0.60 + 0.54 + 1.00 = 5.86 \\text{ cycles}$$\n\n最后，我们计算延迟差 $\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}}$（以纳秒为单位）。首先，我们从 CPU 频率 $f = 3.0 \\times 10^9 \\, \\mathrm{Hz}$ 计算出其时钟周期 $T_{\\mathrm{cycle}}$：\n$$T_{\\mathrm{cycle}} = \\frac{1}{f} = \\frac{1}{3.0 \\times 10^{9} \\, \\mathrm{Hz}} = \\frac{1}{3} \\times 10^{-9} \\, \\mathrm{s} = \\frac{1}{3} \\, \\mathrm{ns}$$\n每种方法的总延迟是其周期数乘以时钟周期。对于直接寻址方法，我们使用期望周期数。\n$$T_{\\mathrm{imm}} = C_{\\mathrm{imm}} \\cdot T_{\\mathrm{cycle}} = 9 \\cdot \\frac{1}{3} \\, \\mathrm{ns} = 3 \\, \\mathrm{ns}$$\n$$T_{\\mathrm{direct}} = E[C_{\\mathrm{direct}}] \\cdot T_{\\mathrm{cycle}} = 5.86 \\cdot \\frac{1}{3} \\, \\mathrm{ns} \\approx 1.9533... \\, \\mathrm{ns}$$\n延迟差为：\n$$\\Delta T = T_{\\mathrm{imm}} - T_{\\mathrm{direct}} = 3 \\, \\mathrm{ns} - \\frac{5.86}{3} \\, \\mathrm{ns} = \\frac{9 - 5.86}{3} \\, \\mathrm{ns} = \\frac{3.14}{3} \\, \\mathrm{ns}$$\n$$\\Delta T \\approx 1.04666... \\, \\mathrm{ns}$$\n根据要求四舍五入到四位有效数字，我们得到：\n$$\\Delta T \\approx 1.047 \\, \\mathrm{ns}$$", "answer": "$$\\boxed{1.047}$$", "id": "3649029"}]}