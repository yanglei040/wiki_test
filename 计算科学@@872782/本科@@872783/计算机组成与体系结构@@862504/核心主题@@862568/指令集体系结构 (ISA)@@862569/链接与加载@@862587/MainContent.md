## 引言
在软件开发的生命周期中，从人类可读的源代码到计算机可执行的机器码，经历了一系列复杂的转换。编译只是这个过程的开端。一个现代程序通常由多个独立编写和编译的模块构成，它们如何被“粘合”在一起，并最终被[操作系统](@entry_id:752937)加载到内存中运行？这正是链接与加载所要解决的核心问题。它们是连接编译时静态世界与运行时动态世界的关键桥梁，对程序的性能、安全性、模块化乃至整个系统的效率都产生着深远影响。

本篇文章将系统性地剖析链接与加载的全过程。我们将首先在“原理与机制”章节中，深入探讨其底层工作方式。您将学习到[静态链接](@entry_id:755373)如何通过[符号解析](@entry_id:755711)和重定位，将分散的目标文件构建成一个单一的可执行文件；以及[动态链接](@entry_id:748735)如何利用位置无关代码（PIC）和[延迟绑定](@entry_id:751189)等技术，实现高效的内存共享和现代安全策略。接下来，在“应用与跨学科连接”章节中，我们将视野扩展到真实世界的应用场景，探究这些原理是如何在[性能优化](@entry_id:753341)、系统安全加固以及构建可扩展插件架构和实现多语言[互操作性](@entry_id:750761)中发挥关键作用的。最后，通过“动手实践”章节提供的一系列练习，您将有机会亲手解决链接与加载过程中遇到的典型问题，从而将理论知识转化为扎实的工程能力。

## 原理与机制

在“引言”章节中，我们概述了从源代码到可执行程序的整个生命周期，强调了链接和加载是连接编译时世界和运行时世界的关键桥梁。本章将深入探讨这些过程的核心原理与内部机制。我们将首先剖析[静态链接](@entry_id:755373)，即如何在程序执行前将多个独立编译的模块组合成一个单一的可执行文件。随后，我们将转向更为现代和复杂的[动态链接](@entry_id:748735)，分析其如何实现代码共享、[延迟绑定](@entry_id:751189)以及它在现代[操作系统安全](@entry_id:753017)策略中的核心作用。

### [静态链接](@entry_id:755373)：构建可执行文件的基石

[静态链接](@entry_id:755373)是将一组可重定位目标文件（通常是编译器生成的 `.o` 文件）和静态库（`.a` 文件）组合成一个完全链接的、可以加载运行的可执行文件的过程。链接器的两个主要任务是**[符号解析](@entry_id:755711) (symbol resolution)** 和**重定位 (relocation)**。

#### [符号解析](@entry_id:755711)

在编写模块化的程序时，代码和数据通常[分布](@entry_id:182848)在多个源文件中。一个文件可能会定义一个函数或变量，而其他文件则会引用它。编译器在处理单个文件时，无法知道其他文件中定义的函数或变量的最终内存地址。因此，它会生成一个**符号表 (symbol table)** 来记录这些定义和引用。符号大致可分为三类：

1.  **全局符号 (Global symbols)**：由当前模块定义并能被其他模块引用的符号（例如，非 `static` 的C函数和全局变量）。
2.  **外部符号 (External symbols)**：由其他模块定义并被当前模块引用的全局符号。
3.  **局部符号 (Local symbols)**：仅在当前模块内部可见的符号（例如，用 `static` 关键字定义的C函数和全局变量）。这些符号在链接期间不参与模块间的[符号解析](@entry_id:755711)。

链接器的首要任务——[符号解析](@entry_id:755711)，就是遍历所有输入的目标文件，为每个引用找到其唯一的定义。这个过程遵循一套严格的规则，尤其是当多个模块定义了同名全局符号时。

##### 强符号与弱符号

为了解决多重定义问题，链接器引入了**强符号 (strong symbols)** 和**弱符号 (weak symbols)** 的概念。函数和已初始化的全局变量是强符号，而未初始化的全局变量是弱符号。链接器使用以下规则来处理同名全局符号：

1.  不允许出现多个同名的强符号。如果链接器在输入文件中发现多个强符号定义，例如，两个目标文件 $O_1$ 和 $O_2$ 都包含了一个名为 `foo` 的已初始化全局变量或函数定义，它将报告一个“多重定义”错误。这个错误与文件在链接命令中的顺序无关。[@problem_id:3654651]

2.  如果一个强符号和多个弱符号同名，链接器会选择强符号的定义。所有对该符号的引用都会被解析到这个强符号的地址。例如，如果 $O_1$ 中 `foo` 是一个强定义（如一个函数），而 $O_2$ 中 `foo` 是一个弱定义（如通过特定编译器属性声明的弱符号），链接会成功。链接器会选用 $O_1$ 中的 `foo`，并将 $O_1$ 和 $O_2$ 中所有对 `foo` 的引用都指向 $O_1$ 的版本。这个解析过程在链接时完成，不会引入额外的运行时开销。[@problem_id:3654651]

3.  如果所有同名符号都是弱符号，链接器会从中任选一个作为最终定义。标准并未规定具体选择哪一个，但通常是基于链接顺序或符号大小。

在C语言的传统实践中，未初始化的全局变量被视为一种特殊的弱符号，称为**公共符号 (common symbols)**。如果链接器遇到一个强定义和多个同名的公共符号，它会选择强定义。如果只有多个同名的公共符号，链接器会为它们分配空间，空间大小等于这些符号中尺寸最大的那个。然而，这种行为可以通过编译器标志来改变。例如，使用 `-fcommon` 标志（通常是默认设置）会产生公共符号。但如果使用 `-fno-common` 标志，未初始化的全局变量会被当作强符号放入 `.bss` 节（存放未初始化数据的段）。在这种情况下，如果两个文件都以这种方式定义了同名的未初始化全局变量，链接器将看到两个强符号，从而导致多重定义错误。[@problem_id:3654651]

解决符号冲突最干净的方法是使用**内部链接 (internal linkage)**。在C/C++中，使用 `static` 关键字修饰的全局变量或函数，其符号在目标文件中会被标记为局部（`STB_LOCAL`），而非全局（`STB_GLOBAL`）。这意味着该符号对其他目标文件不可见，也就不会参与跨模块的[符号解析](@entry_id:755711)。如果 $O_2$ 中的 `foo` 被声明为 `static`，那么它与 $O_1$ 中的全局符号 `foo` 就不会发生冲突，因为链接器在全局符号表中只会看到一个名为 `foo` 的符号。[@problem_id:3654651]

#### 静态库与链接顺序

为了方便管理和分发标准函数（如 `printf`），大量的目标文件被捆绑到**静态库 (static libraries)** 或**归档文件 (archives)**（通常是 `.a` 文件）中。链接器在处理静态库时，并不会将库中所有的目标文件都链接进来。它采用一种更高效的按需提取策略。

链接器从左到右依次处理命令行上的输入文件。它维护一个当前未解析的外部符号引用集合。

-   当遇到一个普通目标文件时，链接器会将其所有代码和数据节都合并到最终的可执行文件中，并更新未解析符号集。
-   当遇到一个归档文件时，链接器会扫描该归档中的成员（即，`.o` 文件）。如果某个成员定义了一个当前未解析符号集中的符号，链接器就会将这个成员目标文件“提取”出来，像处理普通目标文件一样将其链接进来。这个过程可能会为未解析符号集引入新的引用。链接器会持续扫描归档中的所有成员，直到没有成员能够解析当前未解析符号集中的任何符号为止。

这个算法一个至关重要的特性是：链接器通常只对归档文件进行**单次遍历**。一旦扫描完一个库，它不会因为后续链接的文件引入了新的符号引用而回头重新扫描该库。

这个机制导致了**链接顺序**的极端重要性，尤其是在库之间存在[循环依赖](@entry_id:273976)时。考虑一个场景：程序 `m.o` 调用了函数 `x`；静态库 `libA.a` 定义了 `x` 并调用了函数 `y`；静态库 `libB.a` 定义了 `y` 并调用了函数 `x`。[@problem_id:3654596] [@problem_id:3654589]

1.  **命令 `ld m.o -lA -lB`**：
    -   链接器处理 `m.o`，将 `x` 加入未解析符号集。
    -   链接器扫描 `libA.a`。因为它定义了 `x`，所以包含 `x` 定义的目标文件被提取并链接。这个过程又将 `y` 加入未解析符号集。
    -   链接器扫描 `libB.a`。因为它定义了 `y`，所以包含 `y` 定义的目标文件被提取并链接。这个文件对 `x` 的引用已经被 `libA.a` 中的定义满足了。
    -   最终，所有符号都得到解析，链接成功。

2.  **命令 `ld m.o -lB -lA`**：
    -   链接器处理 `m.o`，将 `x` 加入未解析符号集。
    -   链接器扫描 `libB.a`。它定义了 `y`，但 `y` 此时不在未解析符号集中。因此，`libB.a` 中没有任何成员被提取。
    -   链接器扫描 `libA.a`。它定义了 `x`，所以其成员被提取。但这又引入了对 `y` 的未解析引用。
    -   此时，所有输入文件都已处理完毕，但 `y` 仍然未被解析。链接器报告“未定义的符号 `y`”错误。

这个例子清晰地表明，在存在依赖关系时，定义符号的库必须放在引用该符号的文件或库之后。对于[循环依赖](@entry_id:273976)，一个常见的解决方法是在命令行上重复库，例如 `ld m.o -lB -lA -lB`。在第二次扫描 `libB.a` 时，对 `y` 的引用已经存在，从而可以成功提取并完成链接。[@problem_id:3654596]

#### 重定位

在[符号解析](@entry_id:755711)完成后，链接器知道了所有代码和数据节的大小，并将它们合并成一个大的可执行文件。此时，它也确定了每个符号的最终运行时内存地址。链接器的第二个主要任务——重定位——就是修改代码和数据节中的引用，使其指向正确的运行时地址。

编译器在生成目标文件时，并不知道符号的最终地址。因此，它会生成**重定位条目 (relocation entries)**。每当它遇到一个对未知地址的引用时，就会产生一个条目，告诉链接器：“当最终地址确定后，请回来修改这个地方”。

重定位条目通常包含以下信息：
-   **偏移 (Offset)**：需要被修改的位置，相对于节起始地址的偏移。
-   **符号 (Symbol)**：被引用的符号。
-   **类型 (Type)**：告诉链接器如何修改，这取决于[CPU架构](@entry_id:747999)和[寻址模式](@entry_id:746273)。

让我们通过一个具体的例子来理解这个过程。考虑一个32位ISA，它有一个PC相对分支指令。该指令包含一个有符号的[立即数](@entry_id:750532)字段，用于计算分支目标。硬件计算目标地址的公式为 $\text{PC}_{\text{next}} + (\text{imm} \ll s)$，其中 $\text{PC}_{\text{next}}$ 是紧随分支指令之后的指令地址，$\text{imm}$ 是[立即数](@entry_id:750532)，而 $s$ 是一个缩放因子（例如，$s=2$ 表示[立即数](@entry_id:750532)以4字节为单位）。[@problem_id:3654593]

链接器计算这个[立即数](@entry_id:750532)的标准公式是 $R = S + A - P$：
-   $S$ (Symbol)：目标符号的运行时地址。
-   $A$ (Addend)：一个在重定位条目中指定的附加值，通常用于处理复杂寻址。
-   $P$ (Place)：需要被重定位的位置的地址。对于[PC相对寻址](@entry_id:753265)，这通常就是 $\text{PC}_{\text{next}}$。

整个重定位值 $R$ 必须等于硬件所使用的缩放后的[立即数](@entry_id:750532)，即 $R = \text{imm} \times 2^s$。因此，链接器需要计算的[立即数](@entry_id:750532)是 $\text{imm} = R / 2^s = (S + A - P) / 2^s$。

假设一个分支指令位于地址 $B = 0x00028000$，指令长度为4字节，因此 $P = \text{PC}_{\text{next}} = 0x00028004$。目标符号 $S$ 的地址是 $0x00021F10$。加数 $A=0$，缩放因子 $s=2$。

1.  **计算重定位值 $R$**：
    $R = S - P = 0x00021F10 - 0x00028004 = -24820$ (十[进制](@entry_id:634389))。

2.  **计算[立即数](@entry_id:750532) $\text{imm}$**：
    $\text{imm} = R / 2^s = -24820 / 4 = -6205$。

3.  **验证范围**：链接器还必须检查计算出的[立即数](@entry_id:750532)是否在[指令编码](@entry_id:750679)允许的范围内。如果该指令的[立即数](@entry_id:750532)字段宽度为 $k=18$ 位（有符号），其范围是 $[-2^{17}, 2^{17}-1]$，即 $[-131072, 131071]$。由于 $-6205$ 在此范围内，重定位可以成功。链接器会将 $-6205$ 的二[进制](@entry_id:634389)补码形式写入指令的[立即数](@entry_id:750532)字段。[@problem_id:3654593]

### [动态链接](@entry_id:748735)：[延迟绑定](@entry_id:751189)与代码共享

[静态链接](@entry_id:755373)的主要缺点是缺乏灵活性和效率。库代码被复制到每个可执行文件中，浪费磁盘空间。更重要的是，当库被加载到内存时，每个进程都有自己的一份私有副本，浪费了宝贵的RAM。对库的任何更新（如安全补丁）都需要重新链接所有依赖它的应用程序。

**[动态链接](@entry_id:748735)**通过将链接过程的一部分推迟到程序加载时甚至运行时来解决这些问题。代码和数据不再被静态地复制到可执行文件中，而是以**[共享库](@entry_id:754739) (shared libraries)**（或[动态链接](@entry_id:748735)库，DLLs）的形式存在。当程序启动时，一个称为**动态加载器 (dynamic loader)** 的[操作系统](@entry_id:752937)组件介入，将程序和其所需的[共享库](@entry_id:754739)映射到进程的地址空间，并执行[符号解析](@entry_id:755711)和重定位。

#### [动态链接](@entry_id:748735)的动机：从内存共享到现代安全

[动态链接](@entry_id:748735)的核心优势在于代码共享。[操作系统](@entry_id:752937)的[虚拟内存管理](@entry_id:756522)器可以将一个[共享库](@entry_id:754739)的物理内存页面映射到多个进程的[虚拟地址空间](@entry_id:756510)中，从而极大地节省了内存。

然而，在现代系统中，[动态链接](@entry_id:748735)的另一个关键驱动力是安全性。**地址空间布局[随机化](@entry_id:198186) (Address Space Layout Randomization, ASLR)** 是一种安全技术，它在每次程序运行时，将可执行文件、[共享库](@entry_id:754739)、栈和堆的基地址[随机化](@entry_id:198186)。这使得攻击者难以预测目标函数或数据的地址，从而增加了利用内存损坏漏洞的难度。[@problem_id:3654625]

ASLR与**[写时复制](@entry_id:636568) (Copy-on-Write)** 和 **W^X (Write XOR Execute)** 策略共同构成了现代[内存安全](@entry_id:751881)的基础。W^X策略规定内存页要么是可写的，要么是可执行的，但不能同时两者都是。这可以防止攻击者将恶意[代码注入](@entry_id:747437)数据区（如栈）并执行它。

这种安全模型对链接和加载提出了严峻的挑战。如果一个[共享库](@entry_id:754739)的代码包含了硬编码的绝对地址，那么当它被ASLR加载到随机地址时，这些地址就都错了。动态加载器必须在加载时修复它们，这个过程称为**文本重定位 (text relocation)**。但这需要修改代码（`.text`）段，意味着代码页必须是可写的，这直接违反了W^X策略。此外，一旦代码页被修改，它就变成了进程私有的，无法在多个进程间共享，从而丧失了[动态链接](@entry_id:748735)的主要优势。因此，现代[共享库](@entry_id:754739)必须以**位置无关代码 (Position-Independent Code, PIC)** 的形式编译。[@problem_id:3654625]

#### 位置无关代码（PIC）

PIC的生成遵循一个简单而强大的原则：代码段中不能包含任何绝对地址；所有对内存的引用都必须是相对于[程序计数器](@entry_id:753801)（PC）的。

让我们通过一个例子来理解位置依赖和位置无关寻址的区别。假设一个模块在编译时被假定加载到地址 `0x1000`。[@problem_id:3649041]

-   **位置依赖的[绝对寻址](@entry_id:746193)**：一条指令需要加载位于地址 `0x120C` 的全局变量。该指令可能直接将 `0x120C` 硬编码为操作数。如果加载器后来将整个模块移动到 `0x3000` 开始的新基址（偏移量为 `0x2000`），那么该全局变量的新地址是 `0x320C`。但指令仍然试图从旧地址 `0x120C` 加载，导致错误。

-   **位置无关的[PC相对寻址](@entry_id:753265)**：一条指令需要加载位于地址 `0x1018` 的数据。假设该指令本身位于 `0x1004`，且下一条指令位于 `0x1008` (P[C值](@entry_id:272975))。编译器可以计算出目标地址相对于PC的偏移量：`0x1018 - 0x1008 = 0x10`。指令中存储这个偏移量 `0x10`。当模块被重定位到 `0x3000` 时，该指令的新地址是 `0x3004`，PC的新值是 `0x3008`，目标数据的新地址是 `0x3018`。在执行时，CPU计算 `新PC + 偏移量 = 0x3008 + 0x10 = 0x3018`，这正是正确的新地址。

[PC相对寻址](@entry_id:753265)之所以可行，是因为代码和数据在模块内的相对距离在重定位后保持不变。基地址在 $(S+\text{offset}) - (P+\text{offset}) = S - P$ 的计算中被抵消了。[@problem_id:3654625]

然而，[PC相对寻址](@entry_id:753265)只能解决对模块**内部**符号的引用。当代码需要引用另一个[共享库](@entry_id:754739)中的函数或变量时，它们的相对距离在链接时是未知的，并且在运行时会因为ASLR而变化。PIC通过引入一个间接层来解决这个问题。

##### PIC的核心机制：GOT与PLT

PIC将所有与绝对地址相关的部分从代码段中分离出来，集中到一个位于数据段的可写区域，称为**全局偏移量表 (Global Offset Table, GOT)**。

-   **数据引用**：当PIC代码需要访问一个外部全局变量时，它不直接引用该变量。相反，它使用[PC相对寻址](@entry_id:753265)来访问GOT中的一个条目。这个GOT条目本身是一个指针，动态加载器在加载时会负责将该外部变量的真实地址填入这个GOT条目。代码段保持不变，所有修改都发生在可写的数据段（GOT）中。

-   **函数调用**：对外部函数的调用则通过GOT和**过程链接表 (Procedure Linkage Table, PLT)** 协同完成。PLT是代码段中的一小块代码，由一系列“桩” (stubs) 组成，每个外部函数对应一个桩。当代码调用外部函数 `foo` 时，它实际上是调用了 `foo@plt`。
    1.  第一次调用时，`foo@plt` 桩的第一条指令会跳转到GOT中的一个特定条目。
    2.  这个GOT条目此时并不包含 `foo` 的真实地址，而是指向PLT中一段用于调用动态加载器[解析函数](@entry_id:139584)的代码。
    3.  动态加载器被调用，查找 `foo` 的真实地址，然后用这个真实地址覆盖GOT中的条目。
    4.  最后，跳转到 `foo` 的真实地址。
    5.  此后任何对 `foo` 的调用，都会通过 `foo@plt` 直接跳转到GOT中的地址，此时GOT中已存有 `foo` 的真实地址，从而直接调用函数，无需再通过动态加载器。这个过程也称为**[延迟绑定](@entry_id:751189) (lazy binding)**。

这个GOT/PLT机制优雅地实现了位置无关性：代码段只包含对PLT的PC相对调用和对GOT的PC相对访问，本身无需修改。所有地址相关的重定位都被集中到了数据段的GOT中，从而与W^X策略和代码共享兼容。[@problem_id:3654625]

#### 动态加载与重定位过程

动态加载器（如Linux中的 `ld-linux.so`）在程序启动时执行以下任务：
1.  **加载**：读取可执行文件的动态段，找到其依赖的[共享库](@entry_id:754739)。
2.  **映射**：将[共享库](@entry_id:754739)的代码和数据段映射到进程的地址空间，可能会因为ASLR而使用随机的基地址。
3.  **重定位**：遍历每个加载模块的重定位表，修复GOT中的地址。

让我们看一些具体的ELF重定位类型及其计算方法。ELF支持两种重定位记录格式：`REL`（不含显式加数）和`RELA`（包含显式加数）。[@problem_id:3654597]

-   **`R_X86_64_RELATIVE`**：用于重定位一个指向模块内部的指针。这通常用于修复由PIC代码产生的、指向数据段中某个位置的指针。
    -   对于 `RELA` 记录，最终地址 = `基地址 + 加数`。加数在重定位条目中明确给出。
    -   对于 `REL` 记录，最终地址 = `基地址 + 初始值`。加数隐含在需要被重定位的位置的初始内容中。
    -   例如，一个[共享库](@entry_id:754739)被加载到基地址 $B = 0x7f200000$。一个 `RELA` 类型的 `R_RELATIVE` 重定位，其显式加数为 $A_2 = 0x00007000$，则最终写入该位置的值为 $0x7f200000 + 0x00007000 = 0x7f207000$。

-   **`R_X86_64_JUMP_SLOT`**：用于填充PLT使用的GOT条目。它将该条目设置为外部函数的最终解析地址。
    -   最终地址 = `符号的解析地址 S`。
    -   例如，一个外部函数 `ext_func` 被解析到地址 $S = 0x7f411234$。动态加载器会将 `0x7f411234` 这个值写入对应的`JUMP_SLOT`重定位指定的位置（即GOT条目）。这里的加数通常被忽略。[@problem_id:3654597]

#### 符号介入与可见性控制

[动态链接](@entry_id:748735)的一个强大（有时也是危险）的特性是**符号介入 (symbol interposition)**。由于[符号解析](@entry_id:755711)是在运行时进行的，加载器在查找符号时会遵循一个预设的搜索顺序（例如，主程序 -> `[LD_PRELOAD](@entry_id:751203)` 指定的库 -> 依赖库）。如果一个库（如通过 `[LD_PRELOAD](@entry_id:751203)` 预加载的库）定义了一个与后续库中同名的全局符号，那么预加载库中的定义会“介入”并取代原始定义。这对于调试和性能分析非常有用（例如，替换 `malloc` 函数来追踪[内存分配](@entry_id:634722)），但也会带来安全风险。[@problem_id:3654648]

为了提供更细粒度的控制，ELF引入了**符号可见性 (symbol visibility)** 属性，可以在编译时指定：

-   **`default`**：默认可见性。符号被导出到动态符号表，可以被其他模块引用和介入。
-   **`hidden`**：符号不被导出到动态符号表。它仅在定义它的[共享库](@entry_id:754739)内部可见。其他模块无法直接引用它，自然也无法介入。从外部看，这个符号仿佛不存在。
-   **`protected`**：一个折衷方案。符号被导出到动态符号表，因此其他模块**可以**引用它。但是，对于定义该符号的模块**内部**的引用，链接器会保证其总是解析到模块内部的这个定义，而**不能**被外部的定义介入。这既允许外部使用，又保证了内部调用的稳定性和性能（可以避免PLT跳转）。

例如，如果库 $B$ 中的函数 $g$ 调用了同一库中定义的函数 $f$，且 $f$ 的可见性为 `protected`。即使使用 `[LD_PRELOAD](@entry_id:751203)` 加载了一个也定义了 `f` 的库 $P$， $g$ 对 $f$ 的调用仍然会绑定到 $B$ 内部的 $f$ 版本，而不会被 $P$ 中的版本介入。[@problem_id:3654648]

### 高级与比较主题

#### 部分链接

在构建大型软件项目（如[操作系统内核](@entry_id:752950)）时，有时需要将许多目标文件组合成一个更大的中间目标文件，而不是直接生成可执行文件。这个过程称为**部分链接 (partial linking)**，通过 `ld -r` 命令完成。[@problem_id:3654632]

`ld -r` 的工作原理是：
1.  **合并节区 (Merge Sections)**：链接器将输入目标文件中所有同名且属性兼容的节区（如 `.text`, `.data`）合并成一个更大的节区。
2.  **解析局部符号**：它会解析输入文件之间的符号引用。例如，如果 `A.o` 引用了 `B.o` 中定义的符号，这个引用在输出的 `ABCs.o` 中就得到了解析。
3.  **保留并更新重定位信息**：由于输出仍然是一个可重定位文件，最终的内存地址仍是未知的。因此，链接器必须保留重定位信息。它会更新重定位条目的偏移量，以反映其在新的、合并后的节区中的位置。对于那些已经被解析的符号引用，重定位条目会被更新为相对于新节区基准的重定位，而不是相对于外部符号。

**节区名称**在此过程中至关重要。链接器严格根据节区名称来决定是否合并。如果一个目标文件使用了非标准的节区名，如 `.fastcode` 而不是 `.text`，那么它的内容将不会与 `.text` 节区合并，而是在输出文件中成为一个独立的 `.fastcode` 节区。这会影响后续最终链接阶段的行为，因为标准的链接器脚本可能只会处理 `*(.text)`，从而忽略 `.fastcode` 中的内容，除非有自定义脚本来处理它。[@problem_id:3654632]

#### 可执行文件格式比较：ELF, PE, 和 Mach-O

虽然链接和加载的根本目标一致，但不同的[操作系统](@entry_id:752937)和平台采用了不同的可执行文件格式，其设计哲学和机制也各有侧重。[@problem_id:3654603]

-   **映射单元**：
    -   **ELF (Linux)** 和 **Mach-O (macOS)** 以**段 (Segment)** 为运行时加载的基本单元。段由程序头部（Program Header）定义，通常包含一个或多个属性相似的节（Section），例如一个可执行的段可能包含 `.text` 和 `.rodata` 节。加载器只关心段。
    -   **PE (Windows)** 以**节 (Section)** 为加载单元。PE文件的节区头部直接描述了内存的布局和属性，加载器直接映射这些节。

-   **重定位机制**：
    -   **ELF** 使用通用的 `.rel` 或 `.rela` 节来存储重定位条目，每种重定位类型（如 `R_X86_64_RELATIVE`, `R_X86_64_64`）定义了一种计算规则（如 `B+A` 或 `S+A`）。
    -   **PE** 将内部重定位和外部[符号解析](@entry_id:755711)分开处理。对于内部指针，如果模块被重定位（加载地址不等于其首选基地址），加载器会遍历 `.reloc` 节中的**基址重定位表**，计算出加载地址与首选地址的差值，并将其加到所有需要修正的地址上。对于外部符号，PE使用**导入地址表 (Import Address Table, IAT)**。加载器在加载时解析所有导入函数的地址，并直接将这些地址写入IAT。代码中的调用都间接通过IAT进行。
    -   **Mach-O** 使用一种更紧凑的重定位方案。`dyld`（[动态链接](@entry_id:748735)器）解释存储在 `__LINKEDIT` 段中的一系列[操作码](@entry_id:752930)。**Rebase** [操作码](@entry_id:752930)用于修正指向模块内部的指针，通过将一个“滑块”（实际加载地址与首选地址的差值）加到指针上。**Bind** [操作码](@entry_id:752930)用于将外部符号的地址写入模块内的指定位置。

这些差异反映了不同生态系统的设计演化和权衡。ELF的机制较为通用和灵活，PE的IAT机制清晰地分离了导入符号，而Mach-O的压缩[操作码](@entry_id:752930)则旨在优化加载时间和内存占用。理解这些差异对于跨平台开发和系统底层分析至关重要。最后，值得一提的是，为了使主程序也能受益于ASLR，现代系统广泛采用**位置无关可执行文件 (Position-Independent Executable, PIE)**。PIE本质上是使用与[共享库](@entry_id:754739)相同的PIC技术编译的主程序，允许加载器将其代码也放置在随机的内存地址，从而全面提升了程序的安全性。[@problem_id:3654625]