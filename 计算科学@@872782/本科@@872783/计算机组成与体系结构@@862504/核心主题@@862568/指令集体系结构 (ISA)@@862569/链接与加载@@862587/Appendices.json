{"hands_on_practices": [{"introduction": "链接器的核心任务之一是在内存中高效地排布代码和数据。本练习将带你扮演链接器的角色，通过一个具体的计算任务，学习如何通过优化节（section）的顺序来满足对齐约束，同时最小化内存浪费。这个实践将帮助你理解可执行文件布局背后的优化原理，这是性能优化的基础。[@problem_id:3654643]", "problem": "静态链接器接收多个输入节，这些节必须被连续地打包到内存中的单个可加载段中。对于每个节，链接器必须遵守其对齐约束：该节在内存中的起始地址必须是其对齐值的倍数（即，起始地址模节的对齐值同余于零）。段的基加载地址由操作系统（OS）加载器选择，并与页面边界对齐。在此场景中，假设可执行与可链接格式（ELF）的段基地址 $A_{0}$ 为 $0$，且 $A_{0}$ 对齐到 $2^{12}$ 字节（即 $4096$ 字节）。链接器可以任意重排这些节的顺序。\n\n此背景下的基本定义和事实：\n- 一个对齐值为 $a$ 的节必须从满足 $x \\equiv 0 \\pmod{a}$ 的地址 $x$ 开始。\n- 如果当前段末尾的偏移量是 $o$，并且下一个节的对齐值为 $a$，链接器可以插入 $p \\ge 0$ 字节的填充，使得 $o + p \\equiv 0 \\pmod{a}$；然后该节从 $o + p$ 处开始放置，新的段末尾偏移量变为 $o + p + s$，其中 $s$ 是该节的大小。\n- 本问题中所有的对齐值都是2的幂，并且都能整除 $4096$，因此对于所有给定的对齐值，$A_{0} \\equiv 0 \\pmod{a}$。\n\n给定以下六个节；每个节 $i$ 都有一个大小 $s_{i}$ 和一个对齐要求 $a_{i}$，单位均为字节：\n- 节 $\\mathsf{X}$: $a_{\\mathsf{X}} = 1024$, $s_{\\mathsf{X}} = 1500$。\n- 节 $\\mathsf{Y}$: $a_{\\mathsf{Y}} = 512$, $s_{\\mathsf{Y}} = 2048$。\n- 节 $\\mathsf{Z}$: $a_{\\mathsf{Z}} = 256$, $s_{\\mathsf{Z}} = 700$。\n- 节 $\\mathsf{U}$: $a_{\\mathsf{U}} = 128$, $s_{\\mathsf{U}} = 512$。\n- 节 $\\mathsf{V}$: $a_{\\mathsf{V}} = 64$, $s_{\\mathsf{V}} = 1300$。\n- 节 $\\mathsf{W}$: $a_{\\mathsf{W}} = 32$, $s_{\\mathsf{W}} = 1100$。\n\n从 $A_{0} = 0$ 开始，计算一个最终的段布局，该布局在满足对齐约束的条件下，最小化插入的总填充量。您必须确定一个节的排序以及该排序所对应的偏移量和填充量。然后计算最小可能总填充量（所有插入在节之间的填充字节的总和）。最终答案以字节为单位表示。无需四舍五入。最终答案必须是单个数字。", "solution": "问题是确定一组内存节的顺序，以最小化满足对齐约束所需的总填充量。目标是找到最小的可能总填充量。\n\n假设有 $n$ 个节。对于每个节 $i \\in \\{1, 2, \\dots, n\\}$，我们给定其大小 $s_i$ 和对齐值 $a_i$。节 $i$ 必须被放置在内存地址 $addr_i$ 处，使得 $addr_i \\equiv 0 \\pmod{a_i}$。段的初始基地址是 $A_0 = 0$。\n\n在按顺序布局这些节时，假设当前偏移量（前一个放置的节的末尾地址）为 $o_{k-1}$。要放置下一个节，即第 $k$ 个节，我们必须找到最小的起始地址 $addr_k$，使得 $addr_k \\ge o_{k-1}$ 且 $addr_k \\equiv 0 \\pmod{a_k}$。所需的填充量 $p_k$ 为 $p_k = addr_k - o_{k-1}$。新的偏移量变为 $o_k = addr_k + s_k = o_{k-1} + p_k + s_k$。填充量可以使用模运算计算：\n$$p_k = (a_k - (o_{k-1} \\pmod{a_k})) \\pmod{a_k}$$\n对于给定的 $n$ 个节的排序，总填充量为 $P_{\\text{total}} = \\sum_{k=1}^{n} p_k$。\n\n问题要求找到一个使 $P_{\\text{total}}$ 最小化的排序。由于所有对齐值 $a_i$ 都是2的幂，一个已知的最优解是使用贪心算法。该算法按对齐值的降序对节进行排序。其背后的直觉是，具有更严格对齐要求（即更大的 $a_i$）的节应首先放置。这样做是有利的，因为初始偏移量为 $0$，它满足任何对齐约束，而后续的偏移量更有可能“自然地”与较小的对齐值对齐，从而最小化填充。一个对齐到 $2^N$ 的地址对于任何 $M \\le N$ 也必然对齐到 $2^M$。\n\n给定的节是：\n- 节 $\\mathsf{X}$: $a_{\\mathsf{X}} = 1024$, $s_{\\mathsf{X}} = 1500$。\n- 节 $\\mathsf{Y}$: $a_{\\mathsf{Y}} = 512$, $s_{\\mathsf{Y}} = 2048$。\n- 节 $\\mathsf{Z}$: $a_{\\mathsf{Z}} = 256$, $s_{\\mathsf{Z}} = 700$。\n- 节 $\\mathsf{U}$: $a_{\\mathsf{U}} = 128$, $s_{\\mathsf{U}} = 512$。\n- 节 $\\mathsf{V}$: $a_{\\mathsf{V}} = 64$, $s_{\\mathsf{V}} = 1300$。\n- 节 $\\mathsf{W}$: $a_{\\mathsf{W}} = 32$, $s_{\\mathsf{W}} = 1100$。\n\n按对齐值降序排列这些节，得到的顺序是：$\\mathsf{X}$, $\\mathsf{Y}$, $\\mathsf{Z}$, $\\mathsf{U}$, $\\mathsf{V}$, $\\mathsf{W}$。我们现在来计算这个最优排序的总填充量。初始偏移量为 $o_0 = A_0 = 0$。总填充量初始化为 $P = 0$。\n\n1.  **放置节 $\\mathsf{X}$**:\n    -   当前偏移量 $o_{\\text{prev}} = 0$。\n    -   对齐值 $a_{\\mathsf{X}} = 1024$。大小 $s_{\\mathsf{X}} = 1500$。\n    -   填充量 $p_{\\mathsf{X}} = (1024 - (0 \\pmod{1024})) \\pmod{1024} = 0$。\n    -   节 $\\mathsf{X}$ 的起始地址是 $0 + 0 = 0$。\n    -   新偏移量 $o_1 = 0 + 0 + 1500 = 1500$。\n    -   总填充量 $P = 0 + 0 = 0$。\n\n2.  **放置节 $\\mathsf{Y}$**:\n    -   当前偏移量 $o_{\\text{prev}} = o_1 = 1500$。\n    -   对齐值 $a_{\\mathsf{Y}} = 512$。大小 $s_{\\mathsf{Y}} = 2048$。\n    -   $1500 \\pmod{512} = 476$。\n    -   填充量 $p_{\\mathsf{Y}} = (512 - 476) \\pmod{512} = 36$。\n    -   节 $\\mathsf{Y}$ 的起始地址是 $1500 + 36 = 1536$。（$1536 = 3 \\times 512$）。\n    -   新偏移量 $o_2 = 1536 + 2048 = 3584$。\n    -   总填充量 $P = 0 + 36 = 36$。\n\n3.  **放置节 $\\mathsf{Z}$**:\n    -   当前偏移量 $o_{\\text{prev}} = o_2 = 3584$。\n    -   对齐值 $a_{\\mathsf{Z}} = 256$。大小 $s_{\\mathsf{Z}} = 700$。\n    -   $3584 \\pmod{256} = 0$ 因为 $3584 = 14 \\times 256$。\n    -   填充量 $p_{\\mathsf{Z}} = (256 - 0) \\pmod{256} = 0$。\n    -   节 $\\mathsf{Z}$ 的起始地址是 $3584 + 0 = 3584$。\n    -   新偏移量 $o_3 = 3584 + 700 = 4284$。\n    -   总填充量 $P = 36 + 0 = 36$。\n\n4.  **放置节 $\\mathsf{U}$**:\n    -   当前偏移量 $o_{\\text{prev}} = o_3 = 4284$。\n    -   对齐值 $a_{\\mathsf{U}} = 128$。大小 $s_{\\mathsf{U}} = 512$。\n    -   $4284 \\pmod{128} = 60$ 因为 $4284 = 33 \\times 128 + 60$。\n    -   填充量 $p_{\\mathsf{U}} = (128 - 60) \\pmod{128} = 68$。\n    -   节 $\\mathsf{U}$ 的起始地址是 $4284 + 68 = 4352$。（$4352 = 34 \\times 128$）。\n    -   新偏移量 $o_4 = 4352 + 512 = 4864$。\n    -   总填充量 $P = 36 + 68 = 104$。\n\n5.  **放置节 $\\mathsf{V}$**:\n    -   当前偏移量 $o_{\\text{prev}} = o_4 = 4864$。\n    -   对齐值 $a_{\\mathsf{V}} = 64$。大小 $s_{\\mathsf{V}} = 1300$。\n    -   $4864 \\pmod{64} = 0$ 因为 $4864 = 76 \\times 64$。\n    -   填充量 $p_{\\mathsf{V}} = (64 - 0) \\pmod{64} = 0$。\n    -   节 $\\mathsf{V}$ 的起始地址是 $4864 + 0 = 4864$。\n    -   新偏移量 $o_5 = 4864 + 1300 = 6164$。\n    -   总填充量 $P = 104 + 0 = 104$。\n\n6.  **放置节 $\\mathsf{W}$**:\n    -   当前偏移量 $o_{\\text{prev}} = o_5 = 6164$。\n    -   对齐值 $a_{\\mathsf{W}} = 32$。大小 $s_{\\mathsf{W}} = 1100$。\n    -   $6164 \\pmod{32} = 20$ 因为 $6164 = 192 \\times 32 + 20$。\n    -   填充量 $p_{\\mathsf{W}} = (32 - 20) \\pmod{32} = 12$。\n    -   节 $\\mathsf{W}$ 的起始地址是 $6164 + 12 = 6176$。（$6176 = 193 \\times 32$）。\n    -   新偏移量 $o_6 = 6176 + 1100 = 7276$。\n    -   总填充量 $P = 104 + 12 = 116$。\n\n最终布局的总大小为 $7276$ 字节。所有节的大小之和为 $1500+2048+700+512+1300+1100 = 7160$ 字节。总填充量为 $7276 - 7160 = 116$ 字节，这与单独计算的填充值之和相符：$0 + 36 + 0 + 68 + 0 + 12 = 116$。\n\n最小可能总填充量为 $116$ 字节。", "answer": "$$\\boxed{116}$$", "id": "3654643"}, {"introduction": "从静态链接的世界转向动态链接，我们将探讨程序启动时最常见的挑战之一：符号解析失败。本练习模拟了一个由于缺少依赖而导致的“未定义符号”运行时错误。通过分析依赖图并评估不同的修复方案，你将学会如何诊断和解决这类问题，并深刻理解“链接你所使用的库”这一核心工程原则。[@problem_id:3654570]", "problem": "一个应用程序是为可执行与可链接格式（ELF）构建的，并且运行时动态链接器在加载时用于解析外部符号。设 $G(V,E)$ 是可加载对象的有向依赖图，其中 $V$ 是顶点集合，$E$ 是有向边集合。每个顶点表示一个可加载对象：主可执行文件 $X$ 和共享库 $L\\_A$、$L\\_B$、$L\\_C$。一条边 $(u,v) \\in E$ 表示对象 $u$ 包含一个名为 $v$ 的动态表（DT）条目 $DT\\_NEEDED$。当前的图是\n$$\nV = \\{X, L\\_A, L\\_B, L\\_C\\}, \\quad E = \\{(X, L\\_A), (X, L\\_B)\\}.\n$$\n库 $L\\_A$ 包含一个针对符号 $s$ 的未定义重定位，而 $s$ 仅在 $L\\_C$ 中定义。在运行时，动态加载器通过加载 $X$ 并递归加载所有由 $DT\\_NEEDED$ 指定的对象来构建链接映射（link map）。然后，加载器通过搜索已加载对象的全局作用域来解析未定义符号；它不会仅仅为了满足一个引用而打开额外的库，除非是通过已存在于 $DT\\_NEEDED$ 中的条目或通过诸如环境变量 $LD\\_PRELOAD$ 之类的机制。\n\n系统在加载时失败，出现归因于 $L\\_A$ 的错误“未定义符号：$s$”（undefined symbol: $s$）。假设包含 $L\\_A$、$L\\_B$ 和 $L\\_C$ 的目录是可访问的（例如，通过适当的环境变量 $LD\\_LIBRARY\\_PATH$），并且没有符号版本不匹配的问题；问题源于依赖结构。\n\n哪项更改最直接地修复了依赖关系，使得动态加载器能够确定性地解析 $s$，同时符合“链接你所使用的库”（link against what you use）的规则，并且不依赖于非确定性的环境覆盖？选择最佳选项。\n\n- A. 通过重新链接 $L\\_A$ 以包含对 $L\\_C$ 的 $DT\\_NEEDED$ 条目（例如，在生成 $L\\_A$ 时传递 $-lC$），添加缺失的边 $(L\\_A, L\\_C)$，从而使得每当加载 $L\\_A$ 时，$L\\_C$ 也会被加载。\n\n- B. 在 $L\\_A$ 中添加一个运行时库搜索路径（RPATH）$RPATH$ 条目，指向 $L\\_C$ 的目录，而不修改任何对象的 $DT\\_NEEDED$。\n\n- C. 通过重新链接 $L\\_B$ 以包含对 $L\\_C$ 的 $DT\\_NEEDED$ 条目，添加边 $(L\\_B, L\\_C)$，依赖 $L\\_B$ 来使 $L\\_C$ 被传递性地加载。\n\n- D. 重新排序 $X$ 的 $DT\\_NEEDED$ 条目，使 $L\\_B$ 在 $L\\_A$ 之前，期望通过已加载库之间的搜索顺序效应来找到 $s$。", "solution": "问题陈述描述了在使用可执行与可链接格式（ELF）的系统中一个常见的运行时链接失败。在提供解决方案之前，必须确定问题陈述的有效性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 系统涉及一个可执行文件 $X$ 和三个共享库 $L\\_A$、$L\\_B$ 和 $L\\_C$。它们在一个依赖图 $G(V,E)$ 中构成了顶点集合 $V = \\{X, L\\_A, L\\_B, L\\_C\\}$。\n- 一条有向边 $(u,v) \\in E$ 表示对象 $u$ 有一个指向对象 $v$ 的 `DT_NEEDED` 条目。\n- 初始依赖图的边为 $E = \\{(X, L\\_A), (X, L\\_B)\\}$。这意味着 $X$ 依赖于 $L\\_A$ 和 $L\\_B$。没有指定其他 `DT_NEEDED` 依赖关系。\n- 库 $L\\_A$ 需要一个符号 $s$（它包含一个对 $s$ 的未定义重定位）。\n- 符号 $s$ 仅在库 $L\\_C$ 中定义。\n- 动态加载器从可执行文件 $X$ 开始，并递归加载 `DT_NEEDED` 条目中指定的所有库以形成一个链接映射（link map）。它通过搜索此链接映射中所有对象的全局作用域来解析未定义符号。\n- 系统在加载时失败，并报告错误“未定义符号：$s$”（undefined symbol: $s$）。\n- 假定所有库的文件系统位置对加载器是已知的（例如，通过 `LD_LIBRARY_PATH`）。\n- 问题要求找出最能直接修复依赖关系、遵守“链接你所使用的库”规则且具有确定性的更改。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于现代类 Unix 操作系统上动态链接和加载的既定原则。ELF、`DT_NEEDED` 表、依赖图、符号解析和运行时错误等概念是计算机组成和操作系统理论与实践中的标准且事实正确的组成部分。\n- **适定性：** 这个问题是适定的（well-posed）。初始状态、过程（动态加载）和结果（失败）都得到了清晰的描述，并且相互一致。目标是找到一种修改方法，既能解决失败问题，又满足一个特定、客观的软件工程原则（“链接你所使用的库”）。\n- **客观性：** 该问题以精确、客观的技术术语陈述。没有主观或模糊的语言。\n\n**步骤 3：结论与行动**\n问题陈述是有效的。它提出了一个软件工程和系统编程中现实、技术上合理且定义明确的场景。我将继续提供完整的解决方案。\n\n### 基于原则的推导与解决方案\n\n问题的核心在于 ELF 加载器（例如 Linux 系统上的 `ld.so`）进行动态符号解析的过程。\n\n1.  **加载阶段：** 加载器从主可执行文件 $X$ 开始。它解析 $X$ 动态表中的 `DT_NEEDED` 条目。根据给定的边 $E = \\{(X, L\\_A), (X, L\\_B)\\}$，加载器识别出对 $L\\_A$ 和 $L\\_B$ 的直接依赖。它继续将这两个库加载到内存中。然后，加载器会递归地检查 $L\\_A$ 和 $L\\_B$ 的 `DT_NEEDED` 条目。由于没有指定从 $L\\_A$ 或 $L\\_B$ 出发的此类边，加载过程终止。最终加载的对象集合，即链接映射（link map），是 $\\{X, L\\_A, L\\_B\\}$。关键在于，库 $L\\_C$ 没有被加载，因为没有从 $X$ 到 $L\\_C$ 的依赖路径。\n\n2.  **重定位阶段：** 在所有必要的对象被加载后，加载器会解析符号引用。库 $L\\_A$ 包含一个对符号 $s$ 的未解析引用。加载器试图通过搜索链接映射中所有已加载到全局作用域的对象的符号表来找到 $s$ 的定义。这个搜索范围包括 $X$、$L\\_A$ 和 $L\\_B$。\n\n3.  **失败分析：** 问题陈述指出 $s$ 仅在 $L\\_C$ 中定义。由于 $L\\_C$ 不在链接映射中，加载器对 $s$ 的搜索失败。这正确地解释了观察到的运行时错误：“未定义符号：$s$”（undefined symbol: $s$）。\n\n为了解决这个问题，必须修改依赖结构以确保 $L\\_C$ 被加载到进程的链接映射中。解决方案还必须满足“链接你所使用的库”原则，该原则要求对象应明确声明其依赖关系。由于 $L\\_A$ 使用了来自 $L\\_C$ 的符号 $s$，因此 $L\\_A$ 应该声明对 $L\\_C$ 的依赖。\n\n### 逐项分析选项\n\n**A. 通过重新链接 $L\\_A$ 以包含对 $L\\_C$ 的 $DT\\_NEEDED$ 条目（例如，在生成 $L\\_A$ 时传递 $-lC$），添加缺失的边 $(L\\_A, L\\_C)$，从而使得每当加载 $L\\_A$ 时，$L\\_C$ 也会被加载。**\n此操作通过添加边 $(L\\_A, L\\_C)$ 来修改依赖图。\n- **加载效果：** 当加载器处理 $X$ 时，它会加载 $L\\_A$。然后它会递归地检查 $L\\_A$ 的依赖项，并找到新的指向 $L\\_C$ 的 `DT_NEEDED` 条目。因此，加载器会加载 $L\\_C$。最终的链接映射变为 $\\{X, L\\_A, L\\_B, L\\_C\\}$。\n- **解析效果：** 在解析来自 $L\\_A$ 的对 $s$ 的引用时，加载器将搜索链接映射并在 $L\\_C$ 中找到 $s$ 的定义。解析成功。\n- **原则遵从性：** 使用该符号的对象（$L\\_A$）被修改以声明对提供该符号的对象（$L\\_C$）的依赖。这是“链接你所使用的库”原则的教科书式应用。这创建了一个健壮且自文档化的依赖结构。\n**结论：** **正确**。这是最直接、正确且健壮的解决方案，符合最佳实践。\n\n**B. 在 $L\\_A$ 中添加一个运行时库搜索路径（RPATH）$RPATH$ 条目，指向 $L\\_C$ 的目录，而不修改任何对象的 $DT\\_NEEDED$。**\n此操作修改了 $L\\_A$ 的元数据，该元数据影响加载器*在何处*搜索库，但不影响它搜索*哪些*库。\n- **加载效果：** 对象的 `RPATH`（或 `RUNPATH`）用于查找其 `DT_NEEDED` 条目对应的文件。它不会引入新的依赖关系。依赖图保持为 $E = \\{(X, L\\_A), (X, L\\_B)\\}$。由于从 $X$ 开始的依赖链中没有指向 $L\\_C$ 的 `DT_NEEDED` 条目，$L\\_C$ 不会被加载。\n- **解析效果：** 链接映射保持为 $\\{X, L\\_A, L\\_B\\}$。符号 $s$ 仍然未定义。错误仍然存在。\n**结论：** **不正确**。此选项从根本上误解了 `RPATH` 与 `DT_NEEDED` 的用途。\n\n**C. 通过重新链接 $L\\_B$ 以包含对 $L\\_C$ 的 $DT\\_NEEDED$ 条目，添加边 $(L\\_B, L\\_C)$，依赖 $L\\_B$ 来使 $L\\_C$ 被传递性地加载。**\n此操作通过添加边 $(L\\_B, L\\_C)$ 来修改依赖图。\n- **加载效果：** 加载器加载 $X$，然后加载其依赖项 $L\\_A$ 和 $L\\_B$。在处理 $L\\_B$ 时，它找到指向 $L\\_C$ 的 `DT_NEEDED` 条目并加载它。最终的链接映射是 $\\{X, L\\_A, L\\_B, L\\_C\\}$。\n- **解析效果：** 符号 $s$ 现在可从 $L\\_C$ 获得，因此来自 $L\\_A$ 的引用将成功解析。程序将运行。\n- **原则遵从性：** 这个解决方案违反了“链接你所使用的库”原则。对 $L\\_C$ 的依赖是 $L\\_A$ 需要的，但它却由一个不相关的对象 $L\\_B$ 声明。这创建了一个脆弱的、间接的依赖关系。如果将来可执行文件 $X$ 的某个版本不再需要 $L\\_B$，应用程序将再次崩溃，因为引入 $L\\_C$ 的传递性依赖将消失，即使 $L\\_A$ 对 $L\\_C$ 的需求没有改变。\n**结论：** **不正确**。虽然它在技术上解决了崩溃问题，但它通过违反指定的设计原则来实现，导致系统变得脆弱且难以维护。\n\n**D. 重新排序 $X$ 的 $DT\\_NEEDED$ 条目，使 $L\\_B$ 在 $L\\_A$ 之前，期望通过已加载库之间的搜索顺序效应来找到 $s$。**\n此操作更改了加载器可能处理 $X$ 的直接依赖项的顺序。\n- **加载效果：** 加载的库集合保持不变：$\\{X, L\\_A, L\\_B\\}$。它们被添加到链接映射的顺序可能会改变，这会影响符号搜索顺序。然而，根本问题是 $L\\_C$ 根本没有被加载。\n- **解析效果：** 无论在 $X$、$L\\_A$ 和 $L\\_B$ 之间的搜索顺序如何，符号 $s$ 的定义都不存在于其中任何一个。加载器仍然会找不到 $s$。\n**结论：** **不正确**。这个解决方案与问题的根本原因无关，根本原因是链接映射中缺少一个库，而不是其中的搜索顺序问题。", "answer": "$$\\boxed{A}$$", "id": "3654570"}, {"introduction": "最后一个练习将深入探讨动态加载器在程序运行期间的复杂行为。你将通过编写一个模拟程序，实现基于引用计数的共享对象生命周期管理机制，从而精确追踪 `dlopen` 和 `dlclose` 等函数调用如何影响库的加载与卸载。这个实践将为你揭示构建模块化和可扩展应用程序背后，操作系统管理动态库的精密算法。[@problem_id:3654574]", "problem": "您需要为共享对象建立一个简化的动态加载器模型，并以数学精度计算出，由于关闭动态加载的句柄，每个共享对象的代码被卸载的确切时刻。此环境特意禁止调用任何操作系统接口；您将使用纯粹的算法模型来实现和模拟其语义。您的程序必须是确定性的、自包含的，并且必须按照下面指定的精确格式生成单行输出。\n\n基本基础与模型。请使用以下基本定义和事实作为您推导的基础。\n\n- 一组有限的共享对象被建模为有向无环图 (DAG) 的顶点。从顶点 $u$ 到顶点 $v$ 的一条有向边意味着“对象 $u$ 依赖于对象 $v$”。设此图表示为 $G = (V, E)$，其中 $V$ 是一个有限的顶点集，$E \\subseteq V \\times V$ 是一个有向边集，并且 $G$ 是无环的。\n\n- 一个操作序列由对指定根顶点的一系列“打开”和“关闭”动作组成。下面的语义定义了每个动作的精确效果。\n\n- 对于任何对象 $o \\in V$，将其引用计数 $R(o)$ 定义为包含 $o$ 的所有打开句柄贡献的总和。我们定义，在根 $r$ 上的单个打开句柄对每个可从 $r$ 通过 $G$ 中的零条或多条边到达的顶点 $o$（包括 $r$ 本身），恰好贡献 $+1$ 到 $R(o)$。这通过集合可达性而非底层加载器内部机制来定义 $R(o)$，在保持科学合理性的同时，也使其可以被严格计算。\n\n- 卸载语义：当且仅当 $R(o) \\ge 1$ 时，一个对象的代码被视为“已映射”。一个对象 $o$ 在其 $R(o)$ 因关闭动作而从 $1$ 变为 $0$ 的那一刻，恰好变为“已卸载”。$R(o) \\ge 1$ 的对象仍然是已映射状态。\n\n- 需要模拟的操作效果：\n  - 对根 $r$ 打开：对于每个可从 $r$ 到达的 $o$（包括 $r$），将 $R(o)$ 增加 $1$。\n  - 对根 $r$ 关闭：对于每个可从 $r$ 到达的 $o$（包括 $r$），将 $R(o)$ 减少 $1$。执行此减少操作后，在此刻变为已卸载的对象集合恰好是 $\\{\\, o \\mid R_{\\text{before}}(o) \\ge 1 \\text{ and } R_{\\text{after}}(o) = 0 \\,\\}$。\n\n- 正确性约束：在单个打开或关闭动作中，如果一个顶点可以从根通过多条不同路径到达，那么在该动作中它最多只能被计数一次。这强制规定了每个打开句柄对每个可达顶点贡献 $+1$（而不是每条路径），同样，每次关闭对每个可达顶点移除 $-1$（而不是每条路径）。\n\n- 初始条件：在时间 $t=0$ 时，在任何操作之前，对于所有 $o \\in V$，$R(o) = 0$（即，没有任何对象被映射）。\n\n您的任务。实现一个程序，给定一组固定的测试用例，使用上述模型模拟打开和关闭动作序列，并为每个关闭动作输出在该步骤中哪些对象变为已卸载。\n\n数据表示。对象由整数 ID 标识。所有 ID、计数和列表条目都是整数。所有图都是无环的。\n\n输出要求。您的程序必须生成单行输出，包含一个顶级列表，其中每个元素对应一个测试用例。每个测试用例的结果本身也是一个列表，其元素按顺序对应于该测试用例中的每个关闭动作。每个关闭动作由一个在该步骤中恰好变为已卸载的对象 ID 列表表示，按升序排列。打开动作不产生输出元素。整个输出必须是程序打印的单行，不含任何无关字符。\n\n测试套件。使用以下测试用例，它们共同涵盖了共享依赖、传递依赖、重复打开以及由关闭引发的级联卸载。\n\n- 测试用例 1：\n  - 对象：ID $0, 1, 2$。\n  - 边：$0 \\to 1$，$1 \\to 2$。\n  - 操作（按顺序）：打开 $0$，打开 $0$，关闭 $0$，关闭 $0$。\n  - 理由：测试链上的重复打开以及最终的级联卸载。\n\n- 测试用例 2：\n  - 对象：ID $0, 1, 2$。\n  - 边：$0 \\to 2$，$1 \\to 2$。\n  - 操作（按顺序）：打开 $0$，打开 $1$，关闭 $0$，关闭 $1$。\n  - 理由：测试在关闭一个根后保留的共享依赖。\n\n- 测试用例 3：\n  - 对象：ID $0, 1$。\n  - 边：$0 \\to 1$。\n  - 操作（按顺序）：打开 $0$，打开 $1$，关闭 $0$，关闭 $1$。\n  - 理由：测试将依赖项作为根显式打开，与其父对象并存的情况。\n\n- 测试用例 4：\n  - 对象：ID $0, 1, 2, 3$。\n  - 边：$0 \\to 1$，$1 \\to 2$，$3 \\to 1$。\n  - 操作（按顺序）：打开 $0$，打开 $3$，关闭 $0$，关闭 $3$。\n  - 理由：测试跨不同根的传递性共享依赖。\n\n待实现的数学规范。设 $G = (V, E)$ 是一个测试用例的 DAG，并设 $\\mathrm{Reach}(r)$ 是从 $r \\in V$ 可达的顶点集合（包括 $r$）。维护一个数组 $R: V \\to \\mathbb{N}$，初始化为对所有 $o$ 都有 $R(o) = 0$。对于每个对 $r$ 的打开操作，对所有 $o \\in \\mathrm{Reach}(r)$ 执行 $R(o) \\leftarrow R(o) + 1$。对于每个对 $r$ 的关闭操作，首先记录所有 $o$ 的先前计数 $R_{\\text{before}}(o)$，然后对所有 $o \\in \\mathrm{Reach}(r)$ 执行 $R(o) \\leftarrow R(o) - 1$，并报告集合 $\\{\\, o \\in V \\mid R_{\\text{before}}(o) \\ge 1 \\land R(o) = 0 \\,\\}$，按升序排序，作为该关闭操作的输出列表。在遍历期间使用已访问集合，确保每个顶点在每个动作中最多贡献一次。所有遍历必须遵循 DAG 的边。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个以方括号括起来的逗号分隔列表形式的结果，每个元素是如上所述的按测试用例的列表（例如，一个类似 $[ [\\ldots], [\\ldots], \\ldots ]$ 的嵌套方括号列表结构）。所有列表中的所有条目都必须是整数，内部列表必须按升序排列整数。不需要空格。\n\n您的程序必须是一个完整的、可运行的程序，对固定的测试套件精确执行上述模拟，并打印单行的聚合结果。", "solution": "我们从有向无环图、可达性和引用计数的基本定义中推导出算法。\n\n设该有向无环图为 $G = (V, E)$。对于一个根 $r \\in V$，定义其可达集为\n$$\n\\mathrm{Reach}(r) = \\{\\, o \\in V \\mid \\text{存在一条（可能为空的）有向路径 } r \\to o \\,\\}。\n$$\n该模型定义，每个对 $r$ 的“打开”操作对每个 $o \\in \\mathrm{Reach}(r)$ 的引用计数贡献 $+1$，而每个相应的“关闭”操作则精确地移除该贡献，即对每个 $o \\in \\mathrm{Reach}(r)$ 的引用计数贡献 $-1$。因此，总引用计数为\n$$\nR(o) = \\sum_{h \\in H} \\mathbf{1}\\!\\left[o \\in \\mathrm{Reach}(r_h)\\right],\n$$\n其中 $H$ 是当前打开句柄的多重集，$r_h$ 是与句柄 $h$ 关联的根。此处 $\\mathbf{1}[\\cdot]$ 表示指示函数。\n\n在对根 $r$ 的任何单个打开或关闭动作中，如果一个节点 $o$ 可以通过多条不同的路径从 $r$ 到达，它也必须只被计数一次。因为 $G$ 是一个有向无环图，从 $r$ 开始进行深度优先搜索 (DFS) 或广度优先搜索 (BFS)，并使用一个已访问集合，足以确保 $\\mathrm{Reach}(r)$ 中的每个顶点都恰好被处理一次。这产生了正确的单次动作更新：\n- 对于对 $r$ 的打开操作，我们从 $r$ 进行遍历，并为遇到的每个顶点 $o$ 设置 $R(o) \\leftarrow R(o) + 1$。\n- 对于对 $r$ 的关闭操作，我们首先快照计数 $R_{\\text{before}}(o)$，然后从 $r$ 开始遍历，并为遇到的每个 $o$ 设置 $R(o) \\leftarrow R(o) - 1$。\n\n一个对象恰好在其引用计数从 $1$ 变为 $0$ 时被卸载。因此，在对 $r$ 进行关闭操作后，变为已卸载的对象集合恰好是\n$$\nU = \\{\\, o \\in V \\mid R_{\\text{before}}(o) \\ge 1 \\land R_{\\text{after}}(o) = 0 \\,\\}。\n$$\n然后我们按升序对 $U$ 进行排序，以提供一个规范的输出顺序。\n\n每个测试用例的算法步骤：\n1. 对所有 $o \\in V$ 初始化 $R(o) \\leftarrow 0$。\n2. 对于序列中的每个操作：\n   - 如果是打开 $r$，则执行带已访问集合的图遍历，为每个 $o \\in \\mathrm{Reach}(r)$ 将 $R(o)$ 增加 $1$。\n   - 如果是关闭 $r$，则将当前的 $R$ 复制到 $R_{\\text{before}}$，然后进行遍历为每个 $o \\in \\mathrm{Reach}(r)$ 将 $R(o)$ 减少 $1$，并计算满足 $R_{\\text{before}}(o) \\ge 1$ 和 $R(o) = 0$ 的顶点集合 $U$。为此次关闭操作输出 $U$ 中已排序的 ID 列表。打开操作不产生输出。\n\n因为 $G$ 是无环的，所以每次遍历的终止性都得到保证。已访问集合确保每个顶点在每次操作中最多被更新一次。该模型是对动态加载器行为的忠实抽象，该行为使用引用计数和依赖闭包加载，并将卸载事件精确定义为 $R(o)$ 从 $1 \\to 0$ 的转变。\n\n现在我们手动计算给定测试套件的预期输出，以验证实现。\n\n- 测试用例 1：\n  - 图：$0 \\to 1$，$1 \\to 2$。\n  - 操作：\n    - 打开 $0$：$R(0,1,2)$ 变为 $(1,1,1)$。\n    - 打开 $0$：$R(0,1,2)$ 变为 $(2,2,2)$。\n    - 关闭 $0$：沿 $\\mathrm{Reach}(0)=\\{0,1,2\\}$ 递减，$R(0,1,2)$ 变为 $(1,1,1)$。没有 $1 \\to 0$ 的转变，因此输出 $[\\,]$。\n    - 关闭 $0$：再次沿 $\\{0,1,2\\}$ 递减，$R(0,1,2)$ 变为 $(0,0,0)$。三个都发生了 $1 \\to 0$ 的转变，因此输出 $[0,1,2]$。\n  - 结果：$[\\,[],[0,1,2]\\,]$。\n\n- 测试用例 2：\n  - 图：$0 \\to 2$，$1 \\to 2$。\n  - 操作：\n    - 打开 $0$：$R(0,1,2)=(1,0,1)$。\n    - 打开 $1$：$R(0,1,2)=(1,1,2)$。\n    - 关闭 $0$：对 $\\{0,2\\}$ 递减得到 $R=(0,1,1)$，卸载集合 $[0]$。\n    - 关闭 $1$：对 $\\{1,2\\}$ 递减得到 $R=(0,0,0)$，卸载集合 $[1,2]$。\n  - 结果：$[[0],[1,2]]$。\n\n- 测试用例 3：\n  - 图：$0 \\to 1$。\n  - 操作：\n    - 打开 $0$：$R(0,1)=(1,1)$。\n    - 打开 $1$：$R(0,1)=(1,2)$。\n    - 关闭 $0$：对 $\\{0,1\\}$ 递减得到 $R=(0,1)$，卸载集合 $[0]$。\n    - 关闭 $1$：对 $\\{1\\}$ 递减得到 $R=(0,0)$，卸载集合 $[1]$。\n  - 结果：$[[0],[1]]$。\n\n- 测试用例 4：\n  - 图：$0 \\to 1$，$1 \\to 2$，$3 \\to 1$。\n  - 操作：\n    - 打开 $0$：$R(0,1,2,3)=(1,1,1,0)$。\n    - 打开 $3$：$R(0,1,2,3)=(1,2,2,1)$。\n    - 关闭 $0$：对 $\\{0,1,2\\}$ 递减得到 $R=(0,1,1,1)$，卸载集合 $[0]$。\n    - 关闭 $3$：对 $\\{3,1,2\\}$ 递减得到 $R=(0,0,0,0)$，卸载集合 $[1,2,3]$。\n  - 结果：$[[0],[1,2,3]]$。\n\n根据要求的格式进行汇总，因此单行的总体输出应为：\n[[[],[0,1,2]],[[0],[1,2]],[[0],[1]],[[0],[1,2,3]]]\n程序将实现所描述的基于遍历和已访问集合的更新，计算每次关闭的卸载集合，对每个卸载集合进行排序，并按规定格式在单行上精确打印聚合的嵌套列表。", "answer": "$$\\boxed{[[[],[0,1,2]],[[0],[1,2]],[[0],[1]],[[0],[1,2,3]]]}$$", "id": "3654574"}]}