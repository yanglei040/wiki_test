{"hands_on_practices": [{"introduction": "现代指令集架构（ISA）通常提供丰富的算术指令，但理解如何从更简单的操作构建复杂操作是计算机组成与体系结构的核心技能。本练习将指导你仅使用逻辑移位和位运算来模拟算术右移，这对于有符号数除法至关重要。通过这个实践[@problem_id:3620381]，你将深化对二进制补码表示法和符号扩展的理解。", "problem": "一台 $w$ 位二进制补码计算机缺少算术右移指令，但支持逻辑右移、按位与、按位或以及二进制补码求反，所有这些操作都以 $2^{w}$ 为模，结果截断为 $w$ 位。考虑仅使用这些操作来模拟对一个值 $x$ 进行 $k$ 位的算术右移，通过以下表达式\n$$\nY(x,k,w) \\;=\\; \\left(x \\gg_{\\mathrm{logic}} k\\right) \\;\\lor\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\; \\ll\\; (w-k)\\right),\n$$\n其中 $x$ 是一个以二进制补码解释的 $w$ 位字，$\\gg_{\\mathrm{logic}}$ 表示逻辑右移（零填充），$\\ll$ 表示左移（零填充），$\\land$ 表示按位与，$\\lor$ 表示按位或，一元运算符 $-$ 表示以 $2^{w}$ 为模的二进制补码求反。\n\n仅使用二进制补码表示法、逻辑和算术移位以及按位运算的基本定义，完成以下任务：\n- 从第一性原理出发，推导并证明项\n$$\nM(x,k,w) \\;=\\; \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)\n$$\n是一个 $w$ 位掩码，当 $x$ 的符号位为 $0$ 时，该掩码等于 $0$；当 $x$ 的符号位为 $1$ 时，该掩码等于一个在最高有效 $k$ 位上全为 $1$ 的掩码。\n- 总结出对于任何 $w$ 位二进制补码输入 $x$ 和满足 $0 \\le k  w$ 的整数 $k$，$Y(x,k,w)$ 等于将 $x$ 进行 $k$ 位算术右移的结果。\n\n然后，对于一个具体实例，其中 $w = 16$，$x$ 等于 $-10000$ 的二进制补码表示，且 $k = 5$，计算 $Y(x,k,w)$ 产生的带符号十进制值。将最终结果表示为一个带符号的十进制整数。", "solution": "首先验证问题，以确保其科学性、良定性和客观性。\n\n### 步骤 1：提取已知条件\n- 一台 $w$ 位二进制补码计算机。\n- 支持的操作：逻辑右移 ($\\gg_{\\mathrm{logic}}$)、按位与 ($\\land$)、按位或 ($\\lor$)、二进制补码求反 (一元运算符 $-$), 和左移 ($\\ll$)。所有操作都以 $2^w$ 为模，结果截断为 $w$ 位。\n- 模拟算术右移的表达式：$Y(x,k,w) = \\left(x \\gg_{\\mathrm{logic}} k\\right) \\lor M(x,k,w)$。\n- 掩码项的定义：$M(x,k,w) = \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)$。\n- $x$ 是一个 $w$ 位的二进制补码字。\n- $k$ 是一个满足 $0 \\le k  w$ 的整数。\n- 任务 1：证明 $M(x,k,w)$ 根据 $x$ 的符号位创建一个特定的掩码。\n- 任务 2：总结出 $Y(x,k,w)$ 等价于将 $x$ 进行 $k$ 位算术右移。\n- 任务 3：对于 $w = 16$，$x$ 是 $-10000$ 的二进制补码，以及 $k = 5$ 的情况，计算 $Y(x,k,w)$ 的带符号十进制值。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学性：** 该问题基于计算机组成和体系结构中的基本标准概念，特别是整数表示（二进制补码）和位级操作（移位、按位逻辑）。使用逻辑移位和其他基本指令来模拟算术移位是该领域的一个经典且实际的问题。\n- **良定性：** 该问题提供了所有必要的定义和约束。函数 $Y(x,k,w)$ 和 $M(x,k,w)$ 都有明确的定义。任务具体，能够导出一个唯一、可验证的解。\n- **客观性：** 该问题以精确、正式的语言陈述，没有歧义或主观性陈述。\n\n### 步骤 3：结论与行动\n该问题是有效的。这是一个关于计算机算术的严谨练习。将提供完整的解法。\n\n### 解法推导\n\n我们首先陈述证明所需的基本定义。\n一个由比特串 $x_{w-1}x_{w-2}...x_0$ 表示的 $w$ 位整数 $x$，其二进制补码的值为 $V(x) = -x_{w-1}2^{w-1} + \\sum_{i=0}^{w-2} x_i 2^i$。比特 $x_{w-1}$ 是符号位；对于非负数，$x_{w-1}=0$，对于负数，$x_{w-1}=1$。\n\n一次 $k$ 位的 **算术右移**，表示为 $x \\gg_{\\mathrm{arith}} k$，将所有比特向右移动 $k$ 个位置。最高有效的 $k$ 个比特 (MSBs) 用原始符号位 $x_{w-1}$ 的副本填充。此操作等效于整数除以 $2^k$ 并向负无穷大取整：$\\lfloor V(x) / 2^k \\rfloor$。\n\n一次 $k$ 位的 **逻辑右移**，表示为 $x \\gg_{\\mathrm{logic}} k$，也将所有比特向右移动 $k$ 个位置，但最高有效的 $k$ 个比特总是用 $0$ 填充。\n\n目标是证明 $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$ 正确地模拟了 $x \\gg_{\\mathrm{arith}} k$。项 $x \\gg_{\\mathrm{logic}} k$ 执行移位操作，在最高有效位引入零。掩码 $M(x,k,w)$ 旨在修正这些最高有效位，当且仅当原始数 $x$ 为负数时，将它们更改为 $1$。\n\n**第一部分：分析掩码项 $M(x,k,w)$**\n\n掩码定义为 $M(x,k,w) = \\left(\\,-\\left(\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right) \\land 1\\right)\\right) \\ll (w-k)$。让我们从内到外分析这个表达式。\n\n1.  **分离符号位：** 项 $\\left(x \\gg_{\\mathrm{logic}} (w-1)\\right)$ 将 $w$ 位字 $x$ 向右逻辑移动 $w-1$ 位，并用零填充。这将原始符号位 $x_{w-1}$ 移动到最低有效位 (LSB) 位置（第 $0$ 位）。所有其他 $w-1$ 位都变为 $0$。得到的 $w$ 位字是 $00...0x_{w-1}$。\n\n2.  **转换为整数 $0$ 或 $1$：** 执行按位与运算 `... $\\land$ 1`。值 $1$ 作为 $w$ 位字是 $00...01$。运算 $(00...0x_{w-1}) \\land (00...01)$ 的结果是，如果 $x_{w-1}=1$，则得到字 $00...01$；如果 $x_{w-1}=0$，则得到字 $00...00$。我们可以将此结果的整数值表示为 $S$，其中 $S=x_{w-1}$。\n\n3.  **二进制补码求反：** 表达式现在变为 $-S$。\n    - **情况 A：$x$ 为非负数。** 符号位 $x_{w-1}=0$，所以 $S=0$。$0$ 的二进制补码是 $0$。得到的 $w$ 位字是一个全零序列：$00...0$。\n    - **情况 B：$x$ 为负数。** 符号位 $x_{w-1}=1$，所以 $S=1$。$1$ 的二进制补码（表示为 $00...01$）通过将比特取反（$11...10$）再加 $1$ 得到，结果是 $11...11$。这是 $-1$ 的 $w$ 位表示。\n\n4.  **最终左移：** 上一步的结果向左移动 $(w-k)$ 位：`... $\\ll (w-k)$`。\n    - **情况 A（来自上述）：** 如果字是全零，将其向左移动任意位数，结果仍然是全零的字。因此，如果 $x$ 是非负数，$M(x,k,w)$ 是全零字。\n    - **情况 B（来自上述）：** 如果字是全一（$11...11$），将其向左移动 $(w-k)$ 位会导致最右边的 $(w-k)$ 位被零填充。最高有效的 $k$ 个比特由原先在位置 $w-1, w-2, ..., k$ 的比特填充。由于源字的所有比特都是 $1$，这 $k$ 个最高有效位都变为 $1$。得到的掩码是一个其最高有效 $k$ 位等于 $1$、其余 $w-k$ 位等于 $0$ 的字。\n\n推导到此完成。$M(x,k,w)$ 是一个 $w$ 位字，如果 $x$ 的符号位为 $0$，它就是 $0$；如果 $x$ 的符号位为 $1$，它就是一个在最高有效位位置有 $k$ 个 $1$ 的掩码。\n\n**第二部分：证明与算术右移的等价性**\n\n现在我们分析 $Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor M(x,k,w)$。\n\n- **情况 1：$x$ 为非负数。** 符号位 $x_{w-1}=0$。\n    - 算术右移 $x \\gg_{\\mathrm{arith}} k$ 会用 $0$ 填充最高有效的 $k$ 位。\n    - 逻辑右移 $x \\gg_{\\mathrm{logic}} k$ 也会用 $0$ 填充最高有效的 $k$ 位。\n    - 如上所示，对于非负数 $x$，掩码 $M(x,k,w)$ 是全零字。\n    - 因此，$Y(x,k,w) = (x \\gg_{\\mathrm{logic}} k) \\lor (\\text{全零字}) = (x \\gg_{\\mathrm{logic}} k)$。\n    - 在这种情况下，$Y(x,k,w)$ 与 $x \\gg_{\\mathrm{arith}} k$ 完全相同。\n\n- **情况 2：$x$ 为负数。** 符号位 $x_{w-1}=1$。\n    - 算术右移 $x \\gg_{\\mathrm{arith}} k$ 会将 $x$ 的比特右移 $k$ 位，并用 $1$ 填充最高有效的 $k$ 位。\n    - 项 $x \\gg_{\\mathrm{logic}} k$ 将比特右移，但用 $0$ 填充最高有效的 $k$ 位。\n    - 如上所示，对于负数 $x$，掩码 $M(x,k,w)$ 的最高有效 $k$ 位设为 $1$，其最低有效 $w-k$ 位设为 $0$。\n    - 让我们执行按位或运算：\n        - 对于最高有效的 $k$ 个比特位置：来自 $(x \\gg_{\\mathrm{logic}} k)$ 的比特是 $0$。来自 $M(x,k,w)$ 的比特是 $1$。或运算的结果是 $1$。\n        - 对于最低有效的 $w-k$ 个比特位置：来自 $(x \\gg_{\\mathrm{logic}} k)$ 的比特包含 $x$ 移位后的内容。来自 $M(x,k,w)$ 的比特是 $0$。或运算的结果保留了来自 $(x \\gg_{\\mathrm{logic}} k)$ 的比特。\n    - 最终结果的最高有效 $k$ 位被设为 $1$，其最低有效 $w-k$ 位被正确地设置为 $x$ 移位后的比特。这正是负数算术右移的定义。\n    - 在这种情况下，$Y(x,k,w)$ 也与 $x \\gg_{\\mathrm{arith}} k$ 完全相同。\n\n由于该等式对非负数和负数都成立，我们得出结论：对于任何 $w$ 位输入 $x$ 和 $0 \\le k  w$，$Y(x,k,w)$ 是对 $x$ 进行 $k$ 位算术右移的有效模拟。\n\n**第三部分：具体计算**\n\n给定 $w=16$, $k=5$，输入值为 $-10000$。我们需要计算 $Y(x,k,w)$ 的带符号十进制值。\n从我们的证明中，我们知道这等价于一次算术右移。\n$$ Y(x,k,w) = \\left\\lfloor \\frac{-10000}{2^k} \\right\\rfloor $$\n当 $k=5$ 时，我们有 $2^5 = 32$。\n$$ \\text{值} = \\left\\lfloor \\frac{-10000}{32} \\right\\rfloor $$\n执行除法：\n$$ \\frac{-10000}{32} = -312.5 $$\n这个值的底函数是：\n$$ \\lfloor -312.5 \\rfloor = -313 $$\n产生的带符号十进制值为 $-313$。\n\n为了通过位级别操作来验证，我们首先找到 $x=-10000$ 的 $16$ 位二进制补码表示。$10000$ 的二进制是 `0010 0111 0001 0000`。取其补码得到 $x$ 的表示为 `1101 1000 1111 0000`。将其算术右移 $5$ 位，意味着向右移动比特串，并将左侧空出的 $5$ 位用符号位（$1$）填充。结果是 `1111 1110 1100 0111`。为了计算这个负数的十进制值，我们再次取其补码：先取反得到 `0000 0001 0011 1000`，再加一得到 `0000 0001 0011 1001`。这个二进制数的值是 $2^8 + 2^5 + 2^4 + 2^3 + 2^0 = 256 + 32 + 16 + 8 + 1 = 313$。因此，移位结果的十进制值是 $-313$。位级别的验证证实了整数除法的结果。", "answer": "$$\\boxed{-313}$$", "id": "3620381"}, {"introduction": "在掌握了基本操作的构建方法后，我们进一步探索如何运用这些操作来实现核心的算术算法。本练习[@problem_id:3620502]将带你实现“移位-相加”算法，这是处理器实现乘法运算的历史和概念基础。你需要在不使用乘法指令的情况下，计算一个整数的平方，从而体会硬件层面是如何完成复杂计算的。", "problem": "考虑一个非负整数 $x$，它以 $w$ 位的定宽二进制形式表示，满足 $0 \\le x  2^w$。在标准二进制展开中，$x$ 可以写作 $x = \\sum_{i=0}^{w-1} b_i \\cdot 2^i$，其中每个系数 $b_i \\in \\{0,1\\}$ 是位置 $i$ 处的比特。逻辑左移 $i$ 位，记作 $x \\ll i$，当结果在目标类型中可表示时，等同于将 $x$ 乘以 $2^i$。仅使用整数加法和位运算，根据这些基本定义推导出一个算法，通过计算由 $x$ 中置位的比特所决定的、经过移位的 $x$ 的副本之和，来求得其平方 $x^2$。然后在一个程序中实现这个算法，在平方计算中避免使用乘法运算符。为确保累加过程中的算术运算保持在可表示范围内，使用一个宽度为 $2w$ 位的累加器来存放 $x^2$。\n\n你的程序必须：\n- 将 $x$ 视为一个 $w = 32$ 的无符号整数。\n- 仅对 $x$ 中比特 $b_i$ 为 $1$ 的索引 $i$ 求和 $x \\ll i$ 来计算 $x^2$；此计算中不得使用乘法运算符。\n- 将计算出的 $x^2$ 与一个在 $2w$ 位无符号整数类型中计算的参考值 $x \\cdot x$ 进行验证。\n- 对每个测试用例，生成一个布尔结果 $r \\in \\{0,1\\}$，其中如果验证通过则 $r = 1$，否则 $r = 0$。\n\n测试套件：\n使用以下 $10$ 个 $x$ 值（每个值都可存放在 $32$ 位中）来测试稀疏和密集的比特模式、边界情况以及混合模式：\n- 稀疏和边界情况：$x = 0$，$x = 1$，$x = 2^{31}$，$x = 2^{16} + 1$。\n- 密集情况：$x = 2^{32} - 1$，$x = 2^{32} - 2$，$x = 2^{31} - 1$。\n- 混合模式：$x = 305419896$，$x = 2863311530$，$x = 1431655765$。\n\n形式上，测试值为：\n- $x_1 = 0$\n- $x_2 = 1$\n- $x_3 = 2^{31}$\n- $x_4 = 2^{16} + 1$\n- $x_5 = 2^{32} - 1$\n- $x_6 = 2^{32} - 2$\n- $x_7 = 2^{31} - 1$\n- $x_8 = 305419896$\n- $x_9 = 2863311530$\n- $x_{10} = 1431655765$\n\n最终输出格式：\n你的程序应生成一行输出，其中包含按顺序排列的 $10$ 个布尔验证结果，格式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6,r7,r8,r9,r10]”）。每个 $r_k$ 必须是 $0$ 或 $1$。", "solution": "该问题要求仅使用整数加法和位运算，根据非负整数 $x$ 的二进制表示来计算其平方 $x^2$。其基本原理是将乘法表示为一系列的移位和加法，这种方法通常被称为“移位-相加”算法。\n\n设整数 $x$ 由 $w$ 位表示，其中 $0 \\le x  2^w$。其标准二进制展开式由下式给出：\n$$x = \\sum_{i=0}^{w-1} b_i \\cdot 2^i$$\n其中每个系数 $b_i \\in \\{0,1\\}$ 代表位置 $i$ 上的比特。\n\n$x$ 的平方，记作 $x^2$，是 $x$ 与自身的乘积。我们可以用二进制展开式替换其中一个因子：\n$$x^2 = x \\cdot x = x \\cdot \\left(\\sum_{i=0}^{w-1} b_i \\cdot 2^i\\right)$$\n\n通过应用乘法对加法的分配律，我们展开该表达式：\n$$x^2 = \\sum_{i=0}^{w-1} (x \\cdot b_i \\cdot 2^i)$$\n\n由于每个比特 $b_i$ 只能是 $0$ 或 $1$，因此项 $x \\cdot b_i \\cdot 2^i$ 得以简化。如果 $b_i=0$，则该项为 $0$。如果 $b_i=1$，则该项为 $x \\cdot 2^i$。因此，求和仅需包含比特 $b_i$ 为 $1$ 的项：\n$$x^2 = \\sum_{i \\text{ such that } b_i=1} (x \\cdot 2^i)$$\n\n这个数学公式为我们的算法提供了基础。在二进制计算机算术中，将一个整数乘以 2 的幂 $2^i$，在计算上等同于逻辑左移 $i$ 个位置的操作，记作 $x \\ll i$。这使我们能够将该公式直接转化为一系列计算机指令。\n\n计算 $x^2$ 的算法如下：\n1. 初始化一个宽度为 $2w$ 位的累加器为 $0$。这个宽度确保了和不会溢出，因为两个 $w$ 位数的最大乘积需要最多 $2w$ 位。对于 $w=32$，使用一个 $64$ 位的累加器。\n2. 遍历数字 $x$ 的每个比特位置 $i$，从 $i=0$ 到 $w-1$。\n3. 对于每个位置 $i$，测试比特 $b_i$ 是否被设置为 $1$。这可以通过右移后的按位与操作完成：`(x >> i)  1`。\n4. 如果 $b_i$ 为 $1$，则计算 $x$ 逻辑左移 $i$ 个位置的值 ($x \\ll i$)。为防止移位操作本身期间发生中间溢出，$x$ 必须在移位操作前提升为累加器的 $2w$ 位类型。\n5. 将移位操作的结果加到累加器中。\n6. 遍历完所有 $w$ 个比特位置后，累加器将包含最终结果 $x^2$。\n\n该算法在不使用乘法运算符的情况下计算平方，仅依赖于位移、按位与和加法，正如题目要求。验证步骤涉及将此结果与直接乘法得到的结果进行比较，两种计算都使用 $64$ 位整数算术以确保正确性。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n```", "id": "3620502"}, {"introduction": "最后，我们来看一个更高级也更精妙的应用。即使拥有完备的指令集，一些看似简单的实现也可能因整数溢出等硬件限制而出错。本练习[@problem_id:3620404]挑战你分析为何一个朴素的平均值计算会产生错误结果，并利用位运算恒等式推导出一个巧妙且不会溢出的替代方案。这个实践突显了编写稳健、数值精确代码的重要性。", "problem": "要求你仅使用算术和逻辑指令，在机器指令层面推理并实现两个有符号整数平均值的下取整。底层机器模型是一个宽度为 $w = 32$ 位的二补数定宽算术单元，具有以下语义：\n\n- 二补数表示法使用第 $31$ 位作为符号位，表示的整数范围为 $[-2^{31}, 2^{31}-1]$。\n- 加法、减法和所有按位运算都对位模式进行模 $2^{32}$ 运算。也就是说，两个 $32$ 位值相加会丢弃超出第 $31$ 位的进位。\n- 有符号值的右移是算术右移（即符号扩展），无符号值的右移是逻辑右移（即补零）。\n- 按位逻辑运算符在每个位位置上独立操作。\n\n作为出发点需要假定的基础事实：\n\n- 二进制加法可分解为无进位的和位与进位位：对于所有表示整数的位模式，$a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$，其中 $\\oplus$ 是按位异或，$\\land$ 是按位与。这个恒等式在整数环中成立；它描述了加法中进位的传播方式。\n- 对二补数值进行 $1$ 位的算术右移等价于除以 $2$ 的下取整：对于任何可用 $32$ 位二补数表示的 $x$，$\\operatorname{ashr}(x, 1)$ 等于 $\\left\\lfloor x / 2 \\right\\rfloor$。\n\n你的任务：\n\n1) 定义一个函数，该函数尝试通过先相加再右移一位来计算两个有符号 $32$ 位整数 $a$ 和 $b$ 的平均值的下取整，即通过在 $32$ 位二补数算术中计算 $(a + b)$，然后应用算术右移 $1$ 位来计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$。分析并举例说明这种方法在 $(a + b)$ 中因回绕溢出而失败的情况。\n\n2) 从恒等式 $a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$ 以及算术右移作为除以 $2$ 的下取整的语义出发，推导一个仅由运算符 $\\land$、$\\oplus$、整数加法和算术右移 $1$ 位构成的表达式，该表达式对所有 $a, b \\in [-2^{31}, 2^{31}-1]$ 计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$，且当中间结果限制在 $32$ 位内时绝不会溢出。证明为什么在所述模型下该表达式不会溢出。\n\n3) 在上述 $w = 32$ 位的二补数模型下，实现以下三个函数，且不调用 C 编程语言中的任何未定义行为：\n- 一个“朴素”的平均值下取整函数 $\\mathrm{avg\\_naive}(a, b)$，返回先对 $a$ 和 $b$ 执行 $32$ 位模加法，然后应用算术右移 $1$ 位的结果。\n- 一个“修正”的平均值下取整函数 $\\mathrm{avg\\_correct}(a, b)$，仅在 $32$ 位值上使用 $\\land$、$\\oplus$、整数加法和算术右移 $1$ 位来计算 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$ 而不发生溢出，如第 $2$ 部分所推导。\n- 一个“参考”的平均值下取整函数 $\\mathrm{avg\\_ref}(a, b)$，使用一个更宽的整数类型计算真实数学值 $\\left\\lfloor (a + b) / 2 \\right\\rfloor$，该类型可证明对于 $[-2^{31}, 2^{31}-1]$ 内的输入不会溢出。\n\n为保证正确性和可移植性的重要实现要求：\n- 你必须显式地模拟 $32$ 位二补数算术。特别地，不要依赖 C 的有符号溢出或右移负有符号整数的实现定义行为。使用掩码限制到 $32$ 位和显式符号扩展来实现算术右移。\n- 将所有中间的 $32$ 位值视为模 $2^{32}$ 的位模式，并且仅在每个返回有符号结果的函数的最后一步才将其转换为有符号整数。\n\n测试套件：\n你的程序必须计算以下六个测试用例，每个用例是一对有符号 $32$ 位整数 $(a, b)$：\n- 情况 1：$(a, b) = (5, 2)$。\n- 情况 2：$(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}647)$。\n- 情况 3：$(a, b) = (-2{,}147{,}483{,}648, -2{,}147{,}483{,}648)$。\n- 情况 4：$(a, b) = (2{,}147{,}483{,}647, -2{,}147{,}483{,}648)$。\n- 情况 5：$(a, b) = (2{,}147{,}483{,}647, 2{,}147{,}483{,}646)$。\n- 情况 6：$(a, b) = (-7, -2)$。\n\n对于每种情况，计算：\n- $N = \\mathrm{avg\\_naive}(a, b)$，\n- $C = \\mathrm{avg\\_correct}(a, b)$，\n- $R = \\mathrm{avg\\_ref}(a, b)$，\n- $n\\_ok$，如果 $N = R$ 则等于 $1$，否则等于 $0$，\n- $c\\_ok$，如果 $C = R$ 则等于 $1$，否则等于 $0$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个由六个子列表组成的列表，每个子列表对应一个测试用例，顺序与上述相同。每个子列表必须是五元组 $[N,C,R,n\\_ok,c\\_ok]$，所有条目均为十进制整数且无空格。整个输出的格式应严格为一个由这些子列表组成的、用括号括起并以逗号分隔的列表，例如 $[[\\cdots],[\\cdots],\\ldots]$。", "solution": "该问题经评估是有效的。它以二补数算术原理为科学基础，问题提出得当，具有明确的目标和约束，并以精确、客观的语言表述。它是自洽且内部一致的。因此，我们可以着手解决。\n\n该问题要求在一个受限的二补数机器模型内，分析并实现计算两个有符号 $32$ 位整数平均值下取整 $\\lfloor (a + b) / 2 \\rfloor$ 的方法。该模型宽度为 $w=32$ 位，加法使用模算术，并将算术右移 $\\operatorname{ashr}(x, 1)$ 定义为等价于 $\\lfloor x / 2 \\rfloor$。\n\n### 1. 朴素方法分析\n\n朴素方法通过首先使用机器原生的 $32$ 位加法计算和 $a+b$，然后执行算术右移 $1$ 位来计算 $\\lfloor (a + b) / 2 \\rfloor$。设 $a$ 和 $b$ 的机器加法表示为 $a +_{32} b$。因此，计算过程为 $\\operatorname{ashr}(a +_{32} b, 1)$。\n\n这种方法的根本缺陷在于初始加法过程中的溢出。数学上的和 $a+b$ 可能会超出 $32$ 位有符号整数的表示范围，即 $[-2^{31}, 2^{31}-1]$。在二补数算术中，这种溢出会导致结果“回绕”，产生一个与真实和在模 $2^{32}$ 下同余，但大小可能不同、符号也可能不同的值。\n\n我们用两个例子来证明这种失败：\n\n**情况 1：正溢出**\n设 $a = 2^{31}-1$ 且 $b = 2^{31}-1$。\n真实的数学和是 $S = (2^{31}-1) + (2^{31}-1) = 2^{32}-2$。\n正确的平均值是 $\\lfloor S/2 \\rfloor = \\lfloor (2^{32}-2)/2 \\rfloor = 2^{31}-1$。\n在 $32$ 位机器模型中，和 $a +_{32} b$ 的计算如下：\n$(2^{31}-1) + (2^{31}-1) \\equiv (2^{32}-2) \\pmod{2^{32}} \\equiv -2$。\n$2^{31}-1$ 的位模式是 `0x7FFFFFFF`。`0x7FFFFFFF + 0x7FFFFFFF` 的和结果为 `0xFFFFFFFE`，这是 $-2$ 的二补数表示。\n朴素方法接着计算 $\\operatorname{ashr}(-2, 1) = \\lfloor -2/2 \\rfloor = -1$。\n结果 $-1$ 与正确值 $2^{31}-1$ 大相径庭。\n\n**情况 2：负溢出**\n设 $a = -2^{31}$ 且 $b = -2^{31}$。\n真实的数学和是 $S = (-2^{31}) + (-2^{31}) = -2^{32}$。\n正确的平均值是 $\\lfloor S/2 \\rfloor = \\lfloor -2^{32}/2 \\rfloor = -2^{31}$。\n在 $32$ 位机器模型中，和 $a +_{32} b$ 的计算如下：\n$(-2^{31}) + (-2^{31}) \\equiv (-2^{32}) \\pmod{2^{32}} \\equiv 0$。\n$-2^{31}$ 的位模式是 `0x80000000`。`0x80000000 + 0x80000000` 的和结果为 `0x100000000`。由于在 $32$ 位算术中从第 $31$ 位产生的进位被丢弃，结果是 `0x00000000`，表示 $0$。\n朴素方法接着计算 $\\operatorname{ashr}(0, 1) = \\lfloor 0/2 \\rfloor = 0$。\n这个结果 $0$ 是不正确的；真实的平均值是 $-2^{31}$。\n\n这些例子表明，由于加法运算中的中间溢出，朴素方法是不可靠的。\n\n### 2. 推导一个正确的、无溢出的表达式\n\n为了推导一个鲁棒的表达式，我们从提供的基础事实出发，该事实关联了整数加法与按位运算：\n$$a + b = (a \\oplus b) + 2 \\cdot (a \\land b)$$\n其中 $\\oplus$ 是按位异或（XOR），$\\land$ 是按位与（AND）。这个恒等式对任意大小的整数都成立。\n\n我们的目标是计算 $\\lfloor (a+b)/2 \\rfloor$。我们将该恒等式代入此表达式：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{(a \\oplus b) + 2 \\cdot (a \\land b)}{2} \\right\\rfloor $$\n我们可以将除法分配到下取整函数内部：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + \\frac{2 \\cdot (a \\land b)}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} + (a \\land b) \\right\\rfloor $$\n由于 $(a \\land b)$ 的结果是一个整数值，我们可以对任意实数 $z$ 和整数 $k$ 使用属性 $\\lfloor z+k \\rfloor = \\lfloor z \\rfloor + k$：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\left\\lfloor \\frac{a \\oplus b}{2} \\right\\rfloor + (a \\land b) $$\n问题陈述中指出，对于任何 $32$ 位二补数整数 $x$，操作 $\\operatorname{ashr}(x, 1)$ 等价于 $\\lfloor x/2 \\rfloor$。将此应用于项 $\\lfloor (a \\oplus b)/2 \\rfloor$，我们得到最终表达式：\n$$ \\left\\lfloor \\frac{a+b}{2} \\right\\rfloor = \\operatorname{ashr}(a \\oplus b, 1) + (a \\land b) $$\n该表达式完全由允许的运算符组成。\n\n**无溢出的证明：**\n我们现在必须证明，使用 $32$ 位模算术计算该表达式不会在最终的加法步骤中导致溢出。设 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 和 $T_2 = a \\land b$。我们分析和 $T_1 + T_2$ 中操作数 $T_1$ 和 $T_2$ 的符号。二补数加法的溢出只可能在两个同号数相加且结果符号相反时发生。\n\n- **情况 A：$a$ 和 $b$ 符号相同。**\n  $a$ 和 $b$ 的符号位相同 ($a_{31} = b_{31}$)。\n  - $(a \\oplus b)$ 的符号位是 $a_{31} \\oplus b_{31} = 0$。因此，$(a \\oplus b)$ 是一个非负整数。它的算术右移 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 也是非负的。\n  - $(a \\land b)$ 的符号位是 $a_{31} \\land b_{31} = a_{31}$。因此，$T_2 = a \\land b$ 的符号与 $a$ 和 $b$ 相同。\n  - 如果 $a, b \\ge 0$，那么 $T_1 \\ge 0$ 且 $T_2 \\ge 0$。真实的平均值也必须是非负的，并且可以用 $32$ 位表示。和 $T_1 + T_2$ 不会溢出。例如，如果 $a=b=2^{31}-1$，$T_1=\\operatorname{ashr}(0,1)=0$ 且 $T_2=2^{31}-1$。和是 $2^{31}-1$，这是正确的且不会溢出。\n  - 如果 $a, b  0$，那么 $T_1 \\ge 0$ 且 $T_2  0$。我们正在将一个非负数与一个负数相加。这个和保证位于两个操作数之间，因此绝不会溢出。\n\n- **情况 B：$a$ 和 $b$ 符号不同。**\n  $a$ 和 $b$ 的符号位不同 ($a_{31} \\neq b_{31}$)。\n  - $(a \\oplus b)$ 的符号位是 $a_{31} \\oplus b_{31} = 1$。因此，$(a \\oplus b)$ 是一个负整数。它的算术右移 $T_1 = \\operatorname{ashr}(a \\oplus b, 1)$ 也是负的。\n  - $(a \\land b)$ 的符号位是 $a_{31} \\land b_{31} = 0$。因此，$T_2 = a \\land b$ 是一个非负整数。\n  - 我们再次将一个负数 ($T_1$) 与一个非负数 ($T_2$) 相加。与情况 A 一样，这个操作不会溢出。\n\n在所有可能的情况下，最终加法的操作数符号不同（除非其中一个为零），而有符号溢出仅可能在两个符号相同的数相加时发生。因此，表达式 $\\operatorname{ashr}(a \\oplus b, 1) + (a \\land b)$ 可以使用 $32$ 位模算术进行计算，没有任何中间溢出的风险。\n\n### 3. 实现计划\n\n问题要求用 C 语言实现三个函数，严格模拟 $32$ 位二补数模型，并避免 C 语言中对有符号整数的未定义或实现定义行为。我们将假设 `int` 是一个 $32$ 位类型，`long long` 是一个 $64$ 位类型，这是 C23 环境中的标准配置。\n\n- **`avg_ref(a, b)`**: 这个参考函数会将输入 $a$ 和 $b$ 转换为一个更宽的类型 `long long`，它保证能容纳它们的和而不会溢出。然后使用算术右移运算符 `>>` 对 `long long` 类型的和进行运算，从而计算平均值的下取整。根据 C23 标准，对有符号整数进行右移保证是算术移位，从而得到 $\\lfloor (a+b)/2 \\rfloor$。\n\n- **`ashr_s32_by_1(x)`**: 为了遵守显式模拟的要求，将创建一个辅助函数来执行算术右移 $1$ 位。它会将有符号输入转换为 `unsigned int` 以执行逻辑右移（这是行为明确的），然后在原数为负时手动恢复符号位。\n\n- **`avg_naive(a, b)`**: 该函数将模拟有缺陷的方法。它将使用 `unsigned int` 来执行 $a$ 和 $b$ 的模加法。得到的位模式将被重新解释为有符号 `int`，并传递给我们的 `ashr_s32_by_1` 辅助函数。\n\n- **`avg_correct(a, b)`**: 该函数将实现推导出的无溢出公式。它将使用 `unsigned int` 类型来执行按位 `` 和 `^` 操作以及最终的 `+` 操作，从而确保所有算术都是模运算。`^` 操作的中间结果将被转换为有符号 `int` 以调用 `ashr_s32_by_1` 函数，因为 `ashr` 操作是定义在有符号值上的。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n```", "id": "3620404"}]}