## 引言
在数字世界的最深处，驱动所有现代计算的是中央处理单元（CPU）执行的一系列二[进制](@entry_id:634389)指令，即**机器语言**。它是硬件能够直接理解的唯一语言，但对人类来说却极其晦涩。为了架起人类思维与机器执行之间的桥梁，**[汇编语言](@entry_id:746532)**应运而生，为这些二[进制](@entry_id:634389)指令提供了符号化的、更易于理解的表示。对于任何渴望超越表面抽象、深入理解计算机工作原理的程序员或工程师而言，掌握机器与汇编层面的概念是不可或缺的一步。它揭示了程序性能瓶颈的根源，解释了系统为何会发生某些诡异的错误，并赋予我们编写极致高效与健壮代码的能力。

本文旨在系统地揭开机器语言与汇编概念的神秘面纱，填补高级语言编程与底层硬件实现之间的知识鸿沟。我们将直面那些在日常编程中被编译器和[操作系统](@entry_id:752937)隐藏起来的复杂细节，为你构建一个坚实的底层知识框架。

在接下来的内容中，我们将分三个章节逐步深入：
*   **原理与机制**：我们将从单个机器指令的剖析入手，探索[指令集架构](@entry_id:172672)（ISA）的设计哲学，理解数据在内存中的表示与对齐规则，并揭示[函数调用](@entry_id:753765)和程序控制流背后的栈机制。
*   **应用与跨学科联系**：我们将展示这些基础原理如何在[高性能计算](@entry_id:169980)、系统编程、[编译器设计](@entry_id:271989)以及虚拟机等多个领域中发挥关键作用，连接理论与现实世界的挑战。
*   **动手实践**：通过一系列精心设计的编程练习，你将亲手实践[指令编码](@entry_id:750679)、[地址计算](@entry_id:746276)和ABI应用等核心技能，将理论知识转化为解决实际问题的能力。

让我们一同开启这段深入计算机底层的探索之旅，从最基本的“0”和“1”开始，逐步构建起对整个计算体系的深刻理解。

## 原理与机制

计算机的中央处理单元（CPU）执行的指令，本质上是被称为 **机器语言** 的一串串二[进制](@entry_id:634389)数字。这些二[进制](@entry_id:634389)序列对人类来说晦涩难懂，但它们是处理器能够直接理解和执行的唯一语言。为了弥补人类可读性与机器可执行性之间的鸿沟，我们使用 **[汇编语言](@entry_id:746532)**，它为机器指令提供了符号化的表示。本章旨在揭开机器语言的神秘面纱，系统地阐述其组织、表示和执行背后的核心原理与机制。我们将从单个指令的编码剖析入手，逐步扩展到数据在内存中的表示、程序[控制流](@entry_id:273851)的实现，最终探讨程序如何与[操作系统](@entry_id:752937)及链接器交互。

### 指令的剖析

每一条机器指令都是一个固定或可变长度的比特串，其内部被划分为多个字段，每个字段都承载着特定的含义。最核心的字段是 **[操作码](@entry_id:752930)（opcode）**，它指定了处理器需要执行的操作类型，例如加法、数据加载或分支。其余字段则提供了执行该操作所需的 **操作数（operands）**，这些操作数可以是寄存器的编号，也可以是嵌入指令中的常数值，即 **[立即数](@entry_id:750532)（immediate）**。

为了具体理解这一概念，我们以广泛应用于现代计算领域的精简指令集计算机（RISC-V）架构为例。RISC-V 的一个设计哲学是[指令格式](@entry_id:750681)规整、简洁。我们来考察一条具体的汇编指令，并逐步构建其32位二[进制](@entry_id:634389)表示。

考虑指令 `SLLI x5, x6, 23`，其含义是将寄存器 `x6` 中的值逻辑左移 $23$ 位，并将结果存入寄存器 `x5`。在 RISC-V RV32I 指令集中，这条指令属于 I-type（[立即数](@entry_id:750532)类型）指令的一种变体，用于[立即数](@entry_id:750532)移位操作。其32位指令字的布局如下（从高位到低位）：

- **imm[11:0]**（位 31-20）：一个12位的[立即数](@entry_id:750532)。对于[移位](@entry_id:145848)指令，该字段被特殊构造成 `funct7` 和 `shamt`。
- **rs1**（位 19-15）：第一个源寄存器的5位索引。
- **funct3**（位 14-12）：一个3位的功能码，用于与[操作码](@entry_id:752930)一起区分具体指令。
- **rd**（位 11-7）：目标寄存器的5位索引。
- **opcode**（位 6-0）：一个7位的[操作码](@entry_id:752930)。

[@problem_id:3655213] 让我们依据此格式对 `SLLI x5, x6, 23` 进行编码：

1.  **[操作码](@entry_id:752930) (opcode)**: `SLLI` 属于 "OP-IMM"（[立即数](@entry_id:750532)操作）类别，其[操作码](@entry_id:752930)为 `0010011`。
2.  **目标寄存器 (rd)**: 目标寄存器是 `x5`。其索引为 $5$，编码为5位二进制数是 `00101`。
3.  **功能码 (funct3)**: 对于 `SLLI` 指令，`funct3` 字段的值被定义为 `001`。
4.  **源寄存器 (rs1)**: 源寄存器是 `x6`。其索引为 $6$，编码为5位二进制数是 `00110`。
5.  **[立即数](@entry_id:750532) (imm)**: 这是一个12位字段。对于 `SLLI` 指令，此字段的高7位（`imm[11:5]`）用作一个额外的功能码 `funct7`，而低5位（`imm[4:0]`）则表示 **移位量 (shamt)**。
    -   `shamt` 是 $23$，其5位二[进制](@entry_id:634389)表示为 `10111`。
    -   标准 `SLLI` 指令的 `funct7` 被定义为 `0000000`。
    -   因此，整个12位[立即数](@entry_id:750532)字段为 `0000000` + `10111`，即 `000000010111`。

将这些字段按从高位到低位的顺序拼接起来，我们得到完整的32位机器指令：

`000000010111` (imm) | `00110` (rs1) | `001` (funct3) | `00101` (rd) | `0010011` (opcode)

即二[进制](@entry_id:634389)串 `00000001011100110001001010010011_2`。这个数值对应的十[进制](@entry_id:634389)整数是 $24,318,611$。当 CPU 的指令获取单元读入这个32位的数字时，其解码硬件会精确地反向执行上述过程：解析出[操作码](@entry_id:752930)和各个字段，识别出这是一条 `SLLI` 指令，并命令[算术逻辑单元](@entry_id:178218)（ALU）对寄存器 `x6` 的内容执行左移23位的操作，最后将结果写入寄存器 `x5`。这个从符号到二[进制](@entry_id:634389)，再从二[进制](@entry_id:634389)到硬件操作的转换过程，是计算机执行程序的基础。

### ISA 设计的权衡：指令、寄存器与[立即数](@entry_id:750532)

设计一个[指令集架构](@entry_id:172672)（ISA）本身就是一门充满权衡的艺术。在固定长度的[指令格式](@entry_id:750681)中，分配给不同字段的位数直接决定了架构的能力和局限性。一个核心的冲突在于 **寄存器数量** 和 **[立即数](@entry_id:750532)范围** 之间的权衡。

[@problem_id:3655226] 设想我们正在设计一个指令宽度固定为32位的极简 ISA。我们规定6位用于[操作码](@entry_id:752930)，以支持至少64种不同的指令。剩下的26位必须分配给两个寄存器操作数和一个[立即数](@entry_id:750532)。如果我们希望支持 $N$ 个寄存器，那么每个寄存器字段需要 $\lceil \log_2 N \rceil$ 位。因此，留给[立即数](@entry_id:750532)字段的位数 $m$ 为：

$m = 32 - 6 - 2 \times \lceil \log_2 N \rceil = 26 - 2 \lceil \log_2 N \rceil$

这个简单的公式揭示了一个深刻的权衡：

-   如果我们选择支持更多的寄存器（例如，$N=256$），那么每个寄存器字段需要 $\lceil \log_2 256 \rceil = 8$ 位。留给[立即数](@entry_id:750532)的位数将是 $m = 26 - 2 \times 8 = 10$ 位。一个10位的有符号[立即数](@entry_id:750532)所能表示的范围是 $[-512, 511]$。
-   如果我们选择支持较少的寄存器（例如，$N=128$），那么每个寄存器字段需要 $\lceil \log_2 128 \rceil = 7$ 位。留给[立即数](@entry_id:750532)的位数将是 $m = 26 - 2 \times 7 = 12$ 位。一个12位的有符号[立即数](@entry_id:750532)所能表示的范围是 $[-2048, 2047]$。

这个选择对编译器能够生成的代码质量有直接影响。例如，一个需要调整[栈指针](@entry_id:755333) $\pm 2000$ 字节的程序，在 $N=128$ 的架构上可以用一条指令完成，因为 $2000$ 在 $[-2048, 2047]$ 范围内。但在 $N=256$ 的架构上，由于[立即数](@entry_id:750532)范围仅为 $[-512, 511]$，一条指令无法完成此操作，编译器必须生成多条指令来合成这个较大的偏移量，这会增加代码大小和执行时间。

那么，当一个常量太大以至于无法放入单条指令的[立即数](@entry_id:750532)字段时，我们该怎么办？现代 RISC 架构提供了一种标准解决方案：**合成大常数**。

[@problem_id:3655223] 典型的做法是使用两条指令。例如，为了将一个32位的常数加载到寄存器中，可以使用一条 **LUI (Load Upper Immediate)** 指令来加载该常数的高位部分，然后使用一条 **ADDI (Add Immediate)** 指令来叠加其低位部分。假设我们要生成常量 $K_2 = 500000$（[十六进制](@entry_id:176613)为 `0x0007A120`）。这个32位的数可以分为高20位 `0x0007A` 和低12位 `0x120`。
1.  执行 `LUI Rt, 0x7A`。这条指令会将 `0x7A` 加载到寄存器 `Rt` 的高20位，并将低12位清零，得到 `Rt = 0x0007A000`。
2.  接着执行 `ADDI Rt, Rt, 0x120`。这条指令将 `Rt` 的当前值与[立即数](@entry_id:750532) `0x120` 相加，得到 `Rt = 0x0007A000 + 0x120 = 0x0007A120`。

通过这两步，我们成功地在寄存器中构建了无法用单条指令表示的大常数。这种技术在处理大地址偏移或大常量时至关重要，它展示了 ISA 设计者如何通过提供基本构建块，使得软件（编译器和汇编器）能够克服硬件的内在限制。

### 内存中的[数据表示](@entry_id:636977)与访问

指令和寄存器构成了计算的核心，但程序还需要处理存储在主内存中的大量数据。数据的存取涉及三个基本概念：[字节序](@entry_id:747028)、[内存对齐](@entry_id:751842)和[寻址模式](@entry_id:746273)。

#### [字节序](@entry_id:747028) (Endianness)

当一个大于一字节的数据类型（如一个32位整数）存储在内存中时，其 constituent bytes 的[排列](@entry_id:136432)顺序有两种约定：**[大端序](@entry_id:746790) (Big-endian)** 和 **[小端序](@entry_id:751365) (Little-endian)**。

-   **[大端序](@entry_id:746790)**：最高有效字节（Most Significant Byte, MSB）存储在最低的内存地址。这类似于我们书写数字的方式（从左到右，高位在前）。
-   **[小端序](@entry_id:751365)**：最低有效字节（Least Significant Byte, LSB）存储在最低的内存地址。

[@problem_id:3655191] 假设内存地址 `0x2002` 到 `0x2005` 依次存储着字节 `0x6D`, `0xB2`, `0x59`, `0xC7`。如果我们从地址 `0x2002` 读取一个32位字：
-   在一个 **[小端序](@entry_id:751365)** 系统中，字节会按照地址增加的方向从低位到高位重组。因此，32位的值是 `0xC759B26D`。
-   在一个 **[大端序](@entry_id:746790)** 系统中，字节会按照地址增加的方向从高位到低位重组。因此，32位的值是 `0x6DB259C7`。

[字节序](@entry_id:747028)的差异对于需要跨平台或通过网络交换二进制数据的程序至关重要。如果发送方和接收方使用不同的[字节序](@entry_id:747028)约定而未进行转换，数据将被完全错误地解释。例如，如果一个包含多个位字段的32位报头从一个[小端序](@entry_id:751365)机器发送到一个[大端序](@entry_id:746790)机器，所有字段的值都会被解析错误，可能导致灾难性的后果。

#### [内存对齐](@entry_id:751842) (Memory Alignment)

许多[处理器架构](@entry_id:753770)要求或强烈建议多字节数据的访问地址是 **对齐的**。一个大小为 $S$ 字节的数据对象的地址 $A$ 被认为是自然对齐的，如果 $A$ 是 $S$ 的倍数。例如：
-   一个4字节（32位）的字，其地址应该是4的倍数。
-   一个2字节（16位）的半字，其地址应该是2的倍数。
-   字节（8位）访问没有对齐要求。

这种要求源于硬件设计。内存系统通常以字（如4字节或8字节）为单位进行读写。访问一个跨越两个字边界的未对齐数据，可能需要两次内存操作，降低了效率。在某些架构上，如问题 [@problem_id:3655191] 中描述的假设系统，尝试进行未对齐的访问甚至会触发一个 **硬件异常 (trap)**，立即中止程序的正常执行。例如，从地址 `0x2002`（不是4的倍数）加载一个字，或从地址 `0x2003`（不是2的倍数）加载一个半字，都会导致对齐故障。

#### [寻址模式](@entry_id:746273)与汇编器指令

**[寻址模式](@entry_id:746273)** 定义了指令如何指定其操作数的地址。一种非常普遍且强大的[寻址模式](@entry_id:746273)是 **基址加偏移量 (base-plus-offset)**，其中有效地址由一个基址寄存器和一个有符号[立即数](@entry_id:750532)偏移量相加得到。这对于访问数组元素或结构体字段非常有用。

**PC 相对寻址 (PC-relative addressing)** 是另一种关键的[寻址模式](@entry_id:746273)，主要用于[控制流指令](@entry_id:747834)，如条件分支。目标地址不是一个[绝对值](@entry_id:147688)，而是相对于当前[程序计数器](@entry_id:753801)（PC）的偏移量。通常，PC 被定义为 *下一条* 指令的地址。这种寻址方式使得代码可以被加载到内存的任何位置而无需修改，即 **位置无关代码 (Position-Independent Code, PIC)**。

汇编器在将汇编[代码转换](@entry_id:747446)为机器码时扮演着关键角色，尤其是在计算分支偏移量时。汇编器维护一个 **位置计数器 (location counter)** 来跟踪当前正在生成的代码或数据的地址。当遇到一个分支指令时，它会计算目标标签与当前 PC 之间的距离（以字节或指令为单位），并将这个偏移量编码到指令中。

[@problem_id:3655247] 考虑一段代码，其中一条 `BEQ`（相等则分支）指令位于地址 `0x1008`，其目标是标签 `LABEL_L`。假设该分支指令后是几条其他指令，然后是一个数据表。如果我们在数据表之前插入一个 `.align 4` 汇编指令，它会强制 subsequent data to start at an address that is a multiple of $2^4 = 16$ bytes。这可能会在数据表之前插入一些填充字节，从而推后 `LABEL_L` 的地址。因此，`BEQ` 指令需要编码的 PC 相对偏移量就必须由汇编器重新计算。这个例子生动地说明了代码布局的微小变化如何影响机器码的最终内容，以及汇编器在处理符号引用时的重要性。

### 程序控制流的机制

程序不仅仅是顺序执行的指令列表；它包含分支、循环和[函数调用](@entry_id:753765)，这些共同构成了其 **控制流**。

#### [函数调用](@entry_id:753765)与栈

[函数调用](@entry_id:753765)是[结构化编程](@entry_id:755574)的基石。当一个函数（**调用者 (caller)**）调用另一个函数（**被调用者 (callee)**）时，系统需要一种机制来：
1.  传递参数。
2.  保存调用者的返回地址，以便被调用者完成后可以返回。
3.  为被调用者的局部变量分配空间。
4.  保存调用者在调用期间需要保持不变的寄存器状态。

这种机制通过 **栈 (stack)** 来实现。栈是一个后进先出（LIFO）的数据结构，通常从高地址向低地址增长。每次函数调用都会在栈顶创建一个新的 **[栈帧](@entry_id:635120) (stack frame)**。

为了确保函数间的[互操作性](@entry_id:750761)，编译器和程序员必须遵守一套严格的规则，称为 **[应用程序二进制接口](@entry_id:746491) (Application Binary Interface, ABI)** 或 **[调用约定](@entry_id:753766) (calling convention)**。ABI 定义了参数如何传递（通过寄存器还是栈）、哪些寄存器是 **调用者保存 (caller-saved)**（如果调用者需要，自己负责保存）以及哪些是 **被调用者保存 (callee-saved)**（如果被调用者使用，必须在返回前恢复其原始值）。

一个典型的函数 **序言 (prologue)** 负责建立[栈帧](@entry_id:635120)：
1.  保存调用者的[帧指针](@entry_id:749568)。
2.  建立自己的[帧指针](@entry_id:749568)。
3.  保存任何它将要修改的[被调用者保存寄存器](@entry_id:747091)。
4.  为局部变量在栈上分配空间。

相应的，函数 **尾声 (epilogue)** 则负责拆除[栈帧](@entry_id:635120)并返回：
1.  释放局部变量空间。
2.  恢复[被调用者保存寄存器](@entry_id:747091)。
3.  恢复调用者的[帧指针](@entry_id:749568)。
4.  执行[返回指令](@entry_id:754323)。

[@problem_id:3655281] 违反[调用约定](@entry_id:753766)会带来灾难性后果。考虑一个有缺陷的尾声，它忘记了恢复一个被调用者保存的寄存器 `RBX`，并且以错误的顺序恢复栈上的值。具体来说，序言的压栈顺序是 `push rbp` 然后 `push rbx`。正确的尾声应该以相反的顺序 `pop rbx` 然后 `pop rbp` 来恢复。如果尾声错误地只执行了 `pop rbp`，那么栈顶（本应是 `rbx` 的保存值）将被错误地加载到 `rbp` 寄存器中，从而破坏了[帧指针](@entry_id:749568)。更糟糕的是，接下来的 `ret` 指令会把栈上的下一个值（本应是 `rbp` 的保存值）当作返回地址加载到指令指针中。这会导致程序跳转到一个无效的地址，或者在递归调用的情况下，无法正确地从递归中返回，导致栈帧无限累积，最终引发 **[栈溢出](@entry_id:637170) (stack overflow)**。这个例子强调了遵循 ABI 既定协议的绝对必要性。

### 与[操作系统](@entry_id:752937)和链接器的接口

单个程序并非孤立存在，它需要与[操作系统](@entry_id:752937)协作以获取服务，并依赖链接器来组合来自不同源文件的代码。

#### 系统调用

当程序需要执行特权操作时，例如文件 I/O 或[内存分配](@entry_id:634722)，它不能直接访问硬件，而必须请求 **[操作系统](@entry_id:752937) (OS)** 的服务。这种请求机制被称为 **[系统调用](@entry_id:755772) (system call)**。从 CPU 的角度看，[系统调用](@entry_id:755772)是一条特殊的指令（例如 x86-64 上的 `syscall`），它会触发一次从[用户模式](@entry_id:756388)到[内核模式](@entry_id:755664)的受控转换。

[@problem_id:3655242] 应用程序通常不直接发起[系统调用](@entry_id:755772)，而是通过标准库（如 C 语言的 `libc`）提供的 **包装函数 (wrapper function)**。这层抽象提供了几个好处：
1.  **可移植性**: `libc` 包装器隐藏了不同[操作系统](@entry_id:752937)或同一[操作系统](@entry_id:752937)不同版本之间[系统调用接口](@entry_id:755774)的差异。
2.  **易用性**: 包装器提供了标准的 C 函数接口，并处理了内核期望的错误报告约定。例如，Linux 内核通过在 `rax` 寄存器中返回一个小的负数（如 `-EINTR`）来表示错误，而 `libc` 包装器会捕获这个返回值，将其转换为一个正的错误码并存储在线程局部的 `errno` 变量中，同时函数本身返回 `-1`。直接使用 `syscall` 指令的程序则必须自己处理内核返回的原始错误码。

#### 链接、重定位与位置无关代码

当编译器编译一个源文件时，如果它遇到对外部函数或全局变量的引用（即定义在其他文件中的符号），它无法知道这些符号的最终内存地址。它只能在生成的目标文件中留下一个占位符，并附上一条 **重定位记录 (relocation record)**。

**链接器 (linker)** 的任务就是读取所有相关的目标文件，将它们的代码和数据段布局到一个最终的可执行文件中，并解析这些符号引用。**重定位** 就是链接器根据符号的最终地址，回头修正（“patch”）代码或数据中占位符的过程。

[@problem_id:3655303] 两种常见的重定位类型揭示了链接器的工作方式：
-   **R_X86_64_64 (绝对地址重定位)**: 用于填充一个需要包含符号绝对地址的数据指针。链接器只需将符号的最终虚拟地址写入该指针的位置。
-   **R_X86_64_PC32 (PC相对重定位)**: 用于修正一个 PC 相对的 `call` 或 `jmp` 指令的32位位移。链接器使用公式 `value = S + A - P` 来计算位移，其中 `S` 是符号的地址，`A` 是一个加数（addend），`P` 是位移字段本身的地址。

在现代[操作系统](@entry_id:752937)中，为了安全（通过地址空间布局[随机化](@entry_id:198186) ASLR）和效率（允许多个进程[共享库](@entry_id:754739)的单个物理内存副本），可执行文件和[共享库](@entry_id:754739)通常被编译成 **位置无关代码 (Position-Independent Code, PIC)**。PIC 可以在内存中的任意基地址加载并正确执行。

[@problem_id:3655234] 在 x86-64 架构上，PIC 严重依赖于 **RIP 相对寻址**。对于模块内部的引用，可以直接使用 RIP 相对的 `load` 或 `lea` 指令，链接器在链接时就能计算出正确的相对偏移。然而，对于外部模块（如另一个[共享库](@entry_id:754739)）中的符号，其相对位置在链接时是未知的。这里的解决方案是引入一层 **间接寻址**，通过 **[全局偏移表](@entry_id:749926) (Global Offset Table, GOT)** 实现。代码不直接访问外部符号，而是使用 RIP 相对寻址来访问 GOT 中的一个条目。GOT 就像一个指针数组，在程序启动时由 **动态加载器 (dynamic loader)** 负责填入外部符号的实际运行时地址。因此，指令首先加载 GOT 中的指针，然后通过该指针访问最终的目标数据。这个机制是现代[动态链接](@entry_id:748735)系统的基石。

### 从 ISA 到[微架构](@entry_id:751960)：性能一瞥

[指令集架构](@entry_id:172672)（ISA）定义了软件与硬件之间的契约，但实际性能还取决于底层的 **[微架构](@entry_id:751960) (microarchitecture)** 实现。RISC（精简指令集）和 CISC（复杂指令集）是两种对立的 ISA 设计哲学。

-   **RISC**: 倡导简单、固定长度、加载/存储分离的指令集。这简化了处理器解码和[流水线设计](@entry_id:154419)。
-   **CISC**: 支持强大、可变长度、能够直接在内存上操作的复杂指令。这使得代码更紧凑。

现代高性能处理器，即使是像 x86-64 这样的 CISC 架构，其内部也常常采用类似 RISC 的执行核心。它们的前端解码器会将复杂的 CISC 指令分解成一个或多个简单的内部操作，称为 **[微操作](@entry_id:751957) (micro-operations, µops)**。

[@problem_id:3655227] 为了弥合 RISC 和 CISC 之间的差距，现代 CPU 采用了一种称为 **宏操作融合 (macro-op fusion)** 的技术。解码器可以识别出频繁出现的特定 CISC 指令序列（例如，`load` 后紧跟使用该数据的算术指令，或 `compare` 后紧跟条件分支），并将它们融合为单个 µop。

这种融合对性能有显著影响：
-   **[代码密度](@entry_id:747433)与获取带宽**: CISC 指令通常比 RISC 指令更紧凑。在获取带宽有限的情况下，更高密度的 CISC 代码意味着每周期可以获取更多的有效操作，从而减轻 **获取带宽瓶颈**。相比之下，功能相同但更冗长的 RISC 代码可能更快地耗尽获取带宽。
-   **µop 缓存效率**: 许多处理器包含一个 **µop 缓存**，用于存储已解码的 µops，从而在下次执行相同代码时绕过慢速的解码阶段。融合技术减少了生成和需要存储的 µops 数量（例如，将两个 µops 融合为一个），这使得 µop 缓存能够容纳更多有效的程序逻辑，提高了缓存命中率和前端吞吐量。

通过这些机制，现代处理器巧妙地结合了 CISC ISA 的高[代码密度](@entry_id:747433)和 RISC 核心的高效执行特性，从而在各种工作负载下实现卓越的性能。这表明，对机器语言的理解，不仅关乎程序如何正确执行，也关乎它如何高效执行。