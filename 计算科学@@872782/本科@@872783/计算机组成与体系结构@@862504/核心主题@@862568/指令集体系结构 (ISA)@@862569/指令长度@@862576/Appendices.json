{"hands_on_practices": [{"introduction": "指令编码的效率是指令集架构(ISA)设计的核心问题之一。正如摩尔斯电码为常用字母分配较短的编码一样，我们可以根据操作码(opcode)的使用频率来优化其二进制表示，从而提高代码密度。通过这个练习[@problem_id:3650084]，你将应用信息论中的霍夫曼编码原理，为一组给定的操作码设计最优的前缀码，并量化可变长度编码相对于定长编码的优势。", "problem": "考虑一个在中央处理器 (CPU) 上执行的指令集架构 (ISA)，该架构有 $N=12$ 个操作码。借鉴可变长度摩尔斯电码的思想，假设该 ISA 允许使用可变长度的二进制编码，条件是这些编码是前缀码（即没有任何码字是另一个码字的前缀）。给定一个在 $64$ 条动态指令窗口上测得的操作码频率表。每 $64$ 条指令的相对频率为：$O_{1}:16$，$O_{2}:12$，$O_{3}:8$，$O_{4}:6$，$O_{5}:6$，$O_{6}:4$，$O_{7}:4$，$O_{8}:2$，$O_{9}:2$，$O_{10}:1$，$O_{11}:1$，$O_{12}:2$。\n\n从唯一可解码二进制编码和前缀码的基本原理出发，为这些操作码构建一个最优二进制前缀码（类似霍夫曼编码）。根据此构造，确定可变长度编码中每个操作码的平均位数（表示为 $L_{\\text{var}}$），并将其与固定长度基准进行比较。固定长度基准使用为所有 $N$ 个不同操作分配唯一固定宽度操作码所需的最小位数 $w$。\n\n将代码密度提升定义为，与固定长度基准相比，可变长度编码实现的每个操作码平均位数的比例减少量 $\\delta$。计算 $\\delta$ 并以小数形式报告其值。将最终答案四舍五入至四位有效数字。", "solution": "用户希望针对一组给定的操作码及其执行频率，分析可变长度指令编码相对于固定长度方案的效率。这包括构建一个最优前缀码，计算两种方案中每个操作码的平均位数，并确定比例减少量。\n\n### 步骤 1：问题验证\n\n问题陈述提供了一组 $N=12$ 个操作码及其在 $64$ 条指令样本中的频率。频率总和为 $16+12+8+6+6+4+4+2+2+1+1+2 = 64$，与样本大小一致。任务是将信息论中的一个标准且定义明确的算法——霍夫曼编码，应用于计算机体系结构中的一个实际问题（操作码编码）。其概念具有科学依据，数据完整且一致，目标明确。因此，该问题是有效的。\n\n### 步骤 2：固定长度编码基准\n\n对于固定长度编码方案，必须为 $N=12$ 个不同的操作码中的每一个分配一个长度相同的唯一二进制码字 $w$。$w$ 的最小值必须满足条件 $2^w \\ge N$。\n\n我们有 $N=12$。\n当 $w=3$ 时，$2^3 = 8  12$，这不够。\n当 $w=4$ 时，$2^4 = 16 \\ge 12$，这足够了。\n因此，固定长度编码所需的最小位数为 $w=4$。此基准方案中每个操作码的平均位数，表示为 $L_{\\text{fixed}}$，就是每个操作码的固定宽度。\n$$L_{\\text{fixed}} = w = 4$$\n\n### 步骤 3：最优可变长度编码（霍夫曼编码）\n\n为了构建一个最优前缀码，我们采用霍夫曼算法。该算法通过自底向上的方式构建一棵二叉树，它迭代地合并两个频率（或概率）最低的节点，直到只剩下一个根节点。每个操作码的码字长度是其在最终树中的深度。我们将直接使用给定的频率。\n\n操作码及其频率 $f_i$ 如下：\n- $O_1: f_1=16$\n- $O_2: f_2=12$\n- $O_3: f_3=8$\n- $O_4, O_5: f_4=f_5=6$\n- $O_6, O_7: f_6=f_7=4$\n- $O_8, O_9, O_{12}: f_8=f_9=f_{12}=2$\n- $O_{10}, O_{11}: f_{10}=f_{11}=1$\n\n让我们来构建霍夫曼树。我们维护一个按频率排序的节点（叶节点或子树）列表。\n1.  初始叶节点列表（频率, 操作码）：`[(1, O10), (1, O11), (2, O8), (2, O9), (2, O12), (4, O6), (4, O7), (6, O4), (6, O5), (8, O3), (12, O2), (16, O1)]`\n2.  合并 `(1, O10)` 和 `(1, O11)` 形成一个频率为 $1+1=2$ 的新节点 `N1`。\n3.  合并 `(2, O8)` 和 `(2, O9)` 形成一个频率为 $2+2=4$ 的新节点 `N2`。\n4.  合并 `(2, O12)` 和 `(2, N1)` 形成一个频率为 $2+2=4$ 的新节点 `N3`。\n5.  合并 `(4, O6)` 和 `(4, O7)` 形成一个频率为 $4+4=8$ 的新节点 `N4`。\n6.  合并 `(4, N2)` 和 `(4, N3)` 形成一个频率为 $4+4=8$ 的新节点 `N5`。\n7.  合并 `(6, O4)` 和 `(6, O5)` 形成一个频率为 $6+6=12$ 的新节点 `N6`。\n8.  合并 `(8, O3)` 和 `(8, N4)` 形成一个频率为 $8+8=16$ 的新节点 `N7`。\n9.  合并 `(8, N5)` 和 `(12, O2)` 形成一个频率为 $8+12=20$ 的新节点 `N8`。\n10. 合并 `(12, N6)` 和 `(16, O1)` 形成一个频率为 $12+16=28$ 的新节点 `N9`。\n11. 合并 `(16, N7)` 和 `(20, N8)` 形成一个频率为 $16+20=36$ 的新节点 `N10`。\n12. 合并 `(28, N9)` 和 `(36, N10)` 形成频率为 $28+36=64$ 的根节点。\n\n最终树中每个叶节点的深度给出了其码字的长度 $l_i$。从根节点回溯：\n- 深度为 1 的节点：`N9`, `N10`。\n- 深度为 2 的节点：`N6`, `O1` (来自 `N9`)；`N7`, `N8` (来自 `N10`)。$O_1$ 的长度是 $l_1=2$。\n- 深度为 3 的节点：`O4`, `O5` (来自 `N6`)；`O3`, `N4` (来自 `N7`)；`N5`, `O2` (来自 `N8`)。长度为 $l_4=3$，$l_5=3$，$l_3=3$，$l_2=3$。\n- 深度为 4 的节点：`O6`, `O7` (来自 `N4`)；`N2`, `N3` (来自 `N5`)。长度为 $l_6=4$，$l_7=4$。\n- 深度为 5 的节点：`O8`, `O9` (来自 `N2`)；`O12`, `N1` (来自 `N3`)。长度为 $l_8=5$，$l_9=5$，$l_{12}=5$。\n- 深度为 6 的节点：`O10`, `O11` (来自 `N1`)。长度为 $l_{10}=6$，$l_{11}=6$。\n\n每个操作码最终的码字长度 $l_i$ 如下：\n- $O_1 (f_1=16) \\rightarrow l_1=2$ 位\n- $O_2 (f_2=12) \\rightarrow l_2=3$ 位\n- $O_3 (f_3=8) \\rightarrow l_3=3$ 位\n- $O_4 (f_4=6) \\rightarrow l_4=3$ 位\n- $O_5 (f_5=6) \\rightarrow l_5=3$ 位\n- $O_6 (f_6=4) \\rightarrow l_6=4$ 位\n- $O_7 (f_7=4) \\rightarrow l_7=4$ 位\n- $O_8 (f_8=2) \\rightarrow l_8=5$ 位\n- $O_9 (f_9=2) \\rightarrow l_9=5$ 位\n- $O_{12} (f_{12}=2) \\rightarrow l_{12}=5$ 位\n- $O_{10} (f_{10}=1) \\rightarrow l_{10}=6$ 位\n- $O_{11} (f_{11}=1) \\rightarrow l_{11}=6$ 位\n\n### 步骤 4：可变长度编码的平均位数\n\n每个操作码的平均位数 $L_{\\text{var}}$ 是码字长度的加权平均值，其中权重是操作码的概率（或相对频率）。\n$$L_{\\text{var}} = \\sum_{i=1}^{N} p_i l_i = \\frac{1}{\\sum f_i} \\sum_{i=1}^{N} f_i l_i$$\n总指令数为 $\\sum f_i = 64$。\n这 $64$ 条指令的总位数为 $\\sum f_i l_i$：\n$$ \\sum_{i=1}^{12} f_i l_i = (16 \\times 2) + (12 \\times 3) + (8 \\times 3) + (6 \\times 3) + (6 \\times 3) + (4 \\times 4) + (4 \\times 4) + (2 \\times 5) + (2 \\times 5) + (2 \\times 5) + (1 \\times 6) + (1 \\times 6) $$\n$$ \\sum f_i l_i = 32 + 36 + 24 + 18 + 18 + 16 + 16 + 10 + 10 + 10 + 6 + 6 = 202 \\text{ 位} $$\n每个操作码的平均位数为：\n$$ L_{\\text{var}} = \\frac{202}{64} = \\frac{101}{32} = 3.15625 $$\n\n### 步骤 5：代码密度提升\n\n代码密度提升 $\\delta$ 是指与固定长度基准相比，每个操作码平均位数的比例减少量。\n$$ \\delta = \\frac{L_{\\text{fixed}} - L_{\\text{var}}}{L_{\\text{fixed}}} $$\n代入计算出的值：\n$$ \\delta = \\frac{4 - 3.15625}{4} = \\frac{0.84375}{4} = 0.2109375 $$\n\n### 步骤 6：最终答案\n\n问题要求以小数形式报告 $\\delta$ 的值，并四舍五入到四位有效数字。\n$$ \\delta = 0.2109375 $$\n前四位有效数字是 $2$、$1$、$0$ 和 $9$。第五位有效数字是 $3$，小于 $5$，因此我们舍去。\n$$ \\delta \\approx 0.2109 $$", "answer": "$$\\boxed{0.2109}$$", "id": "3650084"}, {"introduction": "指令长度不仅影响代码大小，还直接制约着处理器前端的吞吐率。处理器流水线中的不同阶段有不同的处理能力——取指单元按字节获取数据，而译码单元按指令处理。这个练习[@problem_id:3650071]让你通过一个简化的前端模型，分析和比较定长与可变长度指令集在特定取指带宽和译码宽度下的指令吞吐率($IPC$)，从而揭示平均指令长度是如何成为性能瓶颈的。", "problem": "一个处理器的流水线前端由一个指令获取引擎和一个译码阶段组成。获取引擎每个周期最多可提供 $F$ 字节，而译码阶段每个周期最多可接收 $D$ 条指令。假设处于一个具有深指令队列、完美指令缓存、无控制冒险（完美分支预测）的稳态状态，并且在一个周期内获取的字节可以被带到后续周期进行译码（在获取块边界处没有损失）。设前端是唯一的吞吐量限制因素，因此后端可以退役前端所提供的任何指令。\n\n考虑两种指令集架构（ISA）风格：\n\n- 定长指令集：每条指令的长度恰好为 $4$ 字节。\n- 变长指令集：指令长度在 $1$ 到 $15$ 字节之间。指令长度 $L$ 是一个独立同分布的随机变量，其概率质量函数 $\\Pr(L=\\ell)$ 对于 $\\ell \\in \\{1,2,\\dots,15\\}$ 如下：\n  - $\\Pr(L=1)=0.05$\n  - $\\Pr(L=2)=0.10$\n  - $\\Pr(L=3)=0.15$\n  - $\\Pr(L=4)=0.20$\n  - $\\Pr(L=5)=0.15$\n  - $\\Pr(L=6)=0.10$\n  - $\\Pr(L=7)=0.08$\n  - $\\Pr(L=8)=0.06$\n  - $\\Pr(L=9)=0.04$\n  - $\\Pr(L=10)=0.03$\n  - $\\Pr(L=11)=0.024$\n  - $\\Pr(L=12)=0.008$\n  - $\\Pr(L=13)=0.004$\n  - $\\Pr(L=14)=0.003$\n  - $\\Pr(L=15)=0.001$\n\n使用基于吞吐量和每周期指令数（IPC）定义的第一性原理进行推理，估算在每种指令集架构风格下，前端提供的稳态IPC。取 $F=16$ 和 $D=4$。将您的最终答案表示为一个行向量 $\\left(\\text{IPC}_{\\text{fixed}},\\ \\text{IPC}_{\\text{variable}}\\right)$，并四舍五入到四位有效数字。不需要物理单位。", "solution": "该问题要求在两种不同的指令集架构（ISA）下——定长和变长——估算处理器前端的稳态每周期指令数（IPC）。分析将基于所提供的流水线参数和指令长度特性。\n\n### 步骤 1：提取已知条件\n\n- 获取引擎供应速率：$F$ 字节/周期。\n- 译码阶段接收速率：$D$ 指令/周期。\n- 参数具体值：$F=16$, $D=4$。\n- 假设：\n    - 具有深指令队列的稳态状态。\n    - 完美的指令缓存。\n    - 无控制冒险（完美分支预测）。\n    - 一个周期内获取的字节可以被带到后续周期。\n    - 前端是唯一的吞吐量限制因素。\n- 定长指令集架构（ISA）：\n    - 指令长度恒为 $4$ 字节。\n- 变长指令集架构（ISA）：\n    - 指令长度 $L$ 是一个独立同分布的随机变量，其中 $L \\in \\{1, 2, \\dots, 15\\}$ 字节。\n    - 概率质量函数（PMF），$\\Pr(L=\\ell)$，如下：\n        - $\\Pr(L=1)=0.05$\n        - $\\Pr(L=2)=0.10$\n        - $\\Pr(L=3)=0.15$\n        - $\\Pr(L=4)=0.20$\n        - $\\Pr(L=5)=0.15$\n        - $\\Pr(L=6)=0.10$\n        - $\\Pr(L=7)=0.08$\n        - $\\Pr(L=8)=0.06$\n        - $\\Pr(L=9)=0.04$\n        - $\\Pr(L=10)=0.03$\n        - $\\Pr(L=11)=0.024$\n        - $\\Pr(L=12)=0.008$\n        - $\\Pr(L=13)=0.004$\n        - $\\Pr(L=14)=0.003$\n        - $\\Pr(L=15)=0.001$\n\n### 步骤 2：使用提取的已知条件进行验证\n\n该问题是计算机体系结构性能建模中一个明确定义的问题。\n- **科学依据**：获取带宽、译码宽度、IPC和指令长度分布等概念是处理器设计的基础。该问题使用一个标准的简化模型，其中性能受限于顺序流水线阶段的最小吞吐量。\n- **良态问题**：所有必要的参数（$F$, $D$）和分布都已提供。这些假设（完美缓存，无分支）用于隔离前端的获取/译码瓶颈，这是一种标准的分析技术。所提供概率的总和为 $\\sum_{\\ell=1}^{15} \\Pr(L=\\ell) = 0.05 + 0.10 + 0.15 + 0.20 + 0.15 + 0.10 + 0.08 + 0.06 + 0.04 + 0.03 + 0.024 + 0.008 + 0.004 + 0.003 + 0.001 = 1.000$，证实了概率质量函数（PMF）的有效性。\n- **客观性**：问题以精确、量化的方式陈述，没有主观性。\n\n问题有效。\n\n### 步骤 3：结论与行动\n\n问题有效且可以解决。将继续进行求解过程。\n\n### 解题推导\n\n前端的总吞吐量，以每周期指令数（IPC）衡量，受到指令获取阶段和译码阶段之间瓶颈的限制。我们必须计算每个阶段的最大可持续IPC，而总IPC将是这两个值的最小值。\n\n译码阶段的吞吐量 $IPC_{\\text{decode}}$ 直接由其每个周期接收指令的能力给出。\n$$IPC_{\\text{decode}} = D$$\n\n指令获取阶段的吞吐量 $IPC_{\\text{fetch}}$ 取决于字节获取的速率（$F$）和指令的平均大小。在稳态下，每个周期获取的指令数是每个周期获取的总字节数除以期望的指令长度（以字节为单位），即 $E[L]$。\n$$IPC_{\\text{fetch}} = \\frac{F}{E[L]}$$\n\n前端的总吞吐量是其组成阶段吞吐量的最小值。\n$$IPC = \\min(IPC_{\\text{decode}}, IPC_{\\text{fetch}}) = \\min\\left(D, \\frac{F}{E[L]}\\right)$$\n给定 $F=16$ 字节/周期和 $D=4$ 指令/周期。\n\n#### 情况 1：定长指令集架构（ISA）\n\n对于定长指令集架构，每条指令的长度恰好为 $4$ 字节。因此，指令长度是一个确定性值，而不是一个随机变量。期望长度就是这个值。\n$$E[L_{\\text{fixed}}] = 4 \\text{ bytes}$$\n现在，我们可以计算定长情况下的IPC，$IPC_{\\text{fixed}}$。\n$$IPC_{\\text{fixed}} = \\min\\left(D, \\frac{F}{E[L_{\\text{fixed}}]}\\right) = \\min\\left(4, \\frac{16}{4}\\right)$$\n$$IPC_{\\text{fixed}} = \\min(4, 4) = 4$$\n对于定长指令集架构，前端是完美平衡的，实现了 $4$ IPC 的吞吐量。\n\n#### 情况 2：变长指令集架构（ISA）\n\n对于变长指令集架构，我们必须首先使用提供的概率质量函数 $\\Pr(L=\\ell)$ 计算期望指令长度 $E[L_{\\text{variable}}]$。期望值的计算方法是，将每个可能的长度乘以其概率，然后求和。\n$$E[L_{\\text{variable}}] = \\sum_{\\ell=1}^{15} \\ell \\cdot \\Pr(L=\\ell)$$\n代入给定值：\n$$\n\\begin{align*}\nE[L_{\\text{variable}}] =  (1)(0.05) + (2)(0.10) + (3)(0.15) + (4)(0.20) + (5)(0.15) + (6)(0.10) \\\\\n + (7)(0.08) + (8)(0.06) + (9)(0.04) + (10)(0.03) + (11)(0.024) \\\\\n + (12)(0.008) + (13)(0.004) + (14)(0.003) + (15)(0.001)\n\\end{align*}\n$$\n$$\n\\begin{align*}\nE[L_{\\text{variable}}] =  \\, 0.05 + 0.20 + 0.45 + 0.80 + 0.75 + 0.60 + 0.56 + 0.48 + 0.36 + 0.30 \\\\\n + 0.264 + 0.096 + 0.052 + 0.042 + 0.015\n\\end{align*}\n$$\n将这些乘积相加得到期望长度：\n$$E[L_{\\text{variable}}] = 5.019 \\text{ bytes}$$\n现在，我们计算变长情况下的IPC，$IPC_{\\text{variable}}$。\n$$IPC_{\\text{variable}} = \\min\\left(D, \\frac{F}{E[L_{\\text{variable}}]}\\right) = \\min\\left(4, \\frac{16}{5.019}\\right)$$\n受获取限制的吞吐量是：\n$$\\frac{16}{5.019} \\approx 3.187886033$$\n将其与受译码限制的吞吐量进行比较：\n$$IPC_{\\text{variable}} = \\min(4, 3.187886033) = 3.187886033$$\n在这种情况下，由于平均指令尺寸较大，指令获取阶段成为瓶颈。\n\n#### 最终答案的形成\n\n问题要求两个IPC值，$(\\text{IPC}_{\\text{fixed}}, \\text{IPC}_{\\text{variable}})$，并四舍五入到四位有效数字。\n- $IPC_{\\text{fixed}} = 4$。保留四位有效数字，即为 $4.000$。\n- $IPC_{\\text{variable}} \\approx 3.187886$。保留四位有效数字，即为 $3.188$。\n\n最终结果是行向量 $(4.000, 3.188)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n4.000  3.188\n\\end{pmatrix}\n}\n$$", "id": "3650071"}, {"introduction": "拥有更高代码密度（即更短的指令）的深远好处体现在整个存储器层次结构中，尤其是在指令高速缓存（I-cache）的性能和功耗上。当一个频繁执行的代码区域能够完全放入缓存时，它会极大地减少代价高昂的缓存未命中事件。这个基于真实世界ISA（ARM与Thumb）的练习[@problem_id:3650038]将指导你分析代码大小如何影响缓存未命中率($MPKI$)，并进一步量化其对处理器前端能耗的巨大影响。", "problem": "一个程序的热点区域作为一个紧凑的、顺序流式的循环被重复执行。考虑同一程序的两种编码：高级RISC机器（Advanced RISC Machines, ARM）的$32$位定长编码（ARM32），其指令长度为 $s_{32} = 4\\,\\mathrm{B}$，以及ARM Thumb的$16$位定长编码（Thumb），其指令长度为 $s_{16} = 2\\,\\mathrm{B}$。指令缓存（I-cache）是全相联的，采用最近最少使用（least-recently-used）替换策略，总容量为 $C = 4\\,\\mathrm{KiB}$，缓存行大小为 $L = 64\\,\\mathrm{B}$。当使用ARM32编码时，热点区域的静态占用空间为 $F_{32} = 6\\,\\mathrm{KiB}$，而使用Thumb编码时为 $F_{16} = 3\\,\\mathrm{KiB}$。假设该区域经过多次传递后达到稳态执行，从而强制性冷未命中被分摊，容量行为占主导地位。每千条指令的未命中次数（Misses per thousand instructions, MPKI）定义为总的I-cache未命中次数除以总的执行指令数，再乘以$1000$。\n\n假设每个已提交指令的前端动态能耗模型如下：\n- 每次在I-cache中命中的指令获取成本为 $E_{\\mathrm{hit}} = 2\\,\\mathrm{pJ}$。\n- 每次I-cache未命中事件会产生额外的 $E_{\\mathrm{miss}} = 200\\,\\mathrm{pJ}$ 成本。\n- 指令获取和解码的能耗与指令长度 $s$（以字节为单位）成线性关系，即 $k \\cdot s$，其中 $k = 0.5\\,\\mathrm{pJ/byte}$。\n\n忽略所有其他能量分量（例如，分支预测、指令转换后备缓冲器）。\n\n仅使用代码密度、缓存容量、缓存行、顺序流下全相联最近最少使用行为的含义以及MPKI的定义，推导每种编码的稳态MPKI，然后推导每种编码的平均每个已提交指令的前端动态能耗。最后，计算比率\n$$R \\equiv \\frac{E_{\\mathrm{front\\text{-}end/instr}}(\\text{ARM32})}{E_{\\mathrm{front\\text{-}end/instr}}(\\text{Thumb})}.$$\n将 $R$ 报告为一个无单位的数字。将你的答案四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它科学地基于计算机体系结构的既定原则，包括指令集设计、缓存行为和处理器能耗建模。这是一个定义明确的问题，具有清晰的目标和充分、一致的数据，可以得出一个唯一的解。简化假设（稳态、顺序流）是用于隔离和分析特定体系结构效应的标准方法，在本例中，是分析代码密度对指令缓存性能和能耗的影响。\n\n解决方案需要计算ARM32和Thumb两种编码的每千条指令未命中次数（MPKI），然后计算每条指令的平均前端动态能耗。\n\n首先，我们必须分析每种编码的指令缓存（I-cache）行为。I-cache的容量为 $C = 4\\,\\mathrm{KiB}$，缓存行大小为 $L = 64\\,\\mathrm{B}$。该缓存是全相联的，采用最近最少使用（Least-Recently-Used, LRU）替换策略。\n\n对于ARM32编码，静态代码占用空间为 $F_{32} = 6\\,\\mathrm{KiB}$。由于 $F_{32} > C$ （$6\\,\\mathrm{KiB} > 4\\,\\mathrm{KiB}$），整个热点循环无法完全装入缓存。问题指定了“紧凑的、顺序流式的循环”和“稳态执行”。在这种情况下，当程序计数器顺序流过代码时，会获取新的缓存行。因为占用空间大于缓存，LRU策略确保当循环回到其开头时，最初的缓存行已经被逐出。因此，每次对新缓存行的获取都会导致容量未命中。\n\n每轮循环的未命中次数是占用空间所占据的缓存行总数，即 $\\frac{F_{32}}{L}$。一轮循环中的指令数是占用空间大小除以指令大小，即 $\\frac{F_{32}}{s_{32}}$，其中 $s_{32} = 4\\,\\mathrm{B}$。\n\nMPKI定义为每 $1000$ 条指令的未命中次数。对于ARM32情况：\n$$\n\\mathrm{MPKI}_{32} = \\frac{\\text{每轮未命中次数}}{\\text{每轮指令数}} \\times 1000 = \\frac{F_{32} / L}{F_{32} / s_{32}} \\times 1000 = \\frac{s_{32}}{L} \\times 1000\n$$\n代入给定值：\n$$\n\\mathrm{MPKI}_{32} = \\frac{4\\,\\mathrm{B}}{64\\,\\mathrm{B}} \\times 1000 = \\frac{1}{16} \\times 1000 = 62.5\n$$\n\n对于ARM Thumb编码，静态占用空间为 $F_{16} = 3\\,\\mathrm{KiB}$。由于 $F_{16}  C$ （$3\\,\\mathrm{KiB}  4\\,\\mathrm{KiB}$），整个热点循环可以完全装入I-cache。问题说明要假设稳态执行，其中强制性（冷）未命中被分摊。这意味着在初始预热阶段（第一轮）之后，循环的全部代码都驻留在缓存中。对于所有后续的循环，每次指令获取都将是命中。因此，在稳态下，未命中次数为零。\n$$\n\\mathrm{MPKI}_{16} = 0\n$$\n\n接下来，我们建立每个已提交指令的平均前端动态能耗模型，$E_{\\mathrm{front\\text{-}end/instr}}$。问题指定了三个能量分量。我们建立一个加法模型，其中每条指令都会产生基础能耗，未命中事件的惩罚能耗则分摊到所有指令上。\n每条指令的基础能耗包括获取/解码成本 $k \\cdot s$ 和缓存命中访问成本 $E_{\\mathrm{hit}}$。额外的未命中惩罚 $E_{\\mathrm{miss}}$ 在每次未命中事件时产生。每条指令的未命中事件数是 $\\frac{\\mathrm{MPKI}}{1000}$。\n因此，每条指令的总平均能耗为：\n$$\nE_{\\mathrm{front\\text{-}end/instr}} = (k \\cdot s + E_{\\mathrm{hit}}) + \\frac{\\mathrm{MPKI}}{1000} \\cdot E_{\\mathrm{miss}}\n$$\n\n现在我们使用给定的常数计算每种编码的能耗：$k = 0.5\\,\\mathrm{pJ/B}$，$E_{\\mathrm{hit}} = 2\\,\\mathrm{pJ}$，以及 $E_{\\mathrm{miss}} = 200\\,\\mathrm{pJ}$。\n\n对于ARM32编码（$s_{32} = 4\\,\\mathrm{B}$，$\\mathrm{MPKI}_{32} = 62.5$）：\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{ARM32}) = (0.5\\,\\mathrm{pJ/B} \\cdot 4\\,\\mathrm{B} + 2\\,\\mathrm{pJ}) + \\frac{62.5}{1000} \\cdot 200\\,\\mathrm{pJ}\n$$\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{ARM32}) = (2\\,\\mathrm{pJ} + 2\\,\\mathrm{pJ}) + 0.0625 \\cdot 200\\,\\mathrm{pJ}\n$$\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{ARM32}) = 4\\,\\mathrm{pJ} + 12.5\\,\\mathrm{pJ} = 16.5\\,\\mathrm{pJ}\n$$\n\n对于Thumb编码（$s_{16} = 2\\,\\mathrm{B}$，$\\mathrm{MPKI}_{16} = 0$）：\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{Thumb}) = (0.5\\,\\mathrm{pJ/B} \\cdot 2\\,\\mathrm{B} + 2\\,\\mathrm{pJ}) + \\frac{0}{1000} \\cdot 200\\,\\mathrm{pJ}\n$$\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{Thumb}) = (1\\,\\mathrm{pJ} + 2\\,\\mathrm{pJ}) + 0\\,\\mathrm{pJ}\n$$\n$$\nE_{\\mathrm{front\\text{-}end/instr}}(\\text{Thumb}) = 3.0\\,\\mathrm{pJ}\n$$\n\n最后，我们计算比率 $R$：\n$$\nR = \\frac{E_{\\mathrm{front\\text{-}end/instr}}(\\text{ARM32})}{E_{\\mathrm{front\\text{-}end/instr}}(\\text{Thumb})} = \\frac{16.5\\,\\mathrm{pJ}}{3.0\\,\\mathrm{pJ}} = 5.5\n$$\n问题要求答案报告为四位有效数字。\n$$\nR = 5.500\n$$", "answer": "$$\\boxed{5.500}$$", "id": "3650038"}]}