{"hands_on_practices": [{"introduction": "有效地址的计算不仅仅是一个固定的公式，它揭示了不同组件之间的灵活性。本练习探讨了变址（index）和位移（displacement）之间的基本权衡关系，这是理解编译器如何优化地址计算的关键。通过分析地址别名（aliasing）——即两个不同的地址表达式指向同一内存位置——你将推导出当变址值改变时，位移量需要如何相应调整以保持地址不变 [@problem_id:3636086]。", "problem": "一种具有位移和变址寻址的指令集架构（ISA）根据其定义计算内存操作数的有效地址，该有效地址等于基址寄存器内容、乘以一个与元素大小相关的因子的变址寄存器，以及一个立即数位移之和。形式上，对于一个引用定长元素数组的内存操作数，其有效地址由基址寄存器值 $R_b$、乘以元素大小因子 $S$ 的变址寄存器值 $R_i$，以及位移 $d$ 相加得出。其中，$R_b$ 表示基址寄存器值，$R_i$ 表示变址寄存器值，$S$ 表示由元素大小（以字节为单位）决定的伸缩因子，$d$ 表示位移（以字节为单位）。考虑一个 $32$ 位整数数组，因此伸缩因子为 $S = 4$。两个不同的地址表达式指向该数组中的同一位置，但使用不同的变址和位移值：第一个使用变址寄存器 $R_i$ 和位移 $d_1$，第二个使用变址寄存器 $R_i + 1$ 和位移 $d_2$，两者都使用相同的基址寄存器 $R_b$。仅使用上述有效地址的基本定义以及“当两个表达式计算出相同的有效地址时发生别名”这一概念，推导出当 $S=4$ 时，对于任意的 $R_b$ 和 $R_i$，使得这两个不同的地址表达式产生别名的关于位移的充要条件，并计算 $d_2 - d_1$ 的值（以字节为单位）。你的最终答案只需报告 $d_2 - d_1$ 的值，该值为字节数的整数。", "solution": "问题陈述被评估为有效且适定的。它在科学上基于计算机组成与体系结构的原理，特别是关于内存寻址模式的原理。所有必要的数据和条件都已提供，足以推导出唯一且有意义的解。\n\n问题将使用位移和变址寻址的内存操作数的有效地址（$EA$）定义为基址寄存器值（$R_b$）、乘以元素大小因子（$S$）的变址寄存器值（$R_i$）以及位移（$d$）之和。其公式为：\n$$ EA = R_b + S \\cdot R_i + d $$\n问题指明内存操作数是 $32$ 位整数。由于 1 字节有 $8$ 位，一个 $32$ 位整数占据 $\\frac{32}{8} = 4$ 字节。伸缩因子 $S$ 由元素大小（以字节为单位）决定，因此在这种情况下，$S = 4$。\n\n我们已知两个不同的地址表达式产生别名，这意味着它们计算出相同的有效地址。我们将第一个和第二个表达式的有效地址分别记为 $EA_1$ 和 $EA_2$。\n\n对于第一个地址表达式：\n变址寄存器值指定为 $R_i$。\n位移为 $d_1$。\n基址寄存器为 $R_b$，伸缩因子为 $S=4$。\n因此，第一个有效地址 $EA_1$ 由下式给出：\n$$ EA_1 = R_b + 4 \\cdot R_i + d_1 $$\n\n对于第二个地址表达式：\n变址寄存器值指定为 $R_i + 1$。这被解释为变址寄存器 $R_i$ 的值增加了 1。\n位移为 $d_2$。\n基址寄存器相同，为 $R_b$，伸缩因子也为 $S=4$。\n因此，第二个有效地址 $EA_2$ 由下式给出：\n$$ EA_2 = R_b + 4 \\cdot (R_i + 1) + d_2 $$\n\n别名条件要求这两个表达式产生相同的地址：\n$$ EA_1 = EA_2 $$\n代入 $EA_1$ 和 $EA_2$ 的表达式：\n$$ R_b + 4 R_i + d_1 = R_b + 4(R_i + 1) + d_2 $$\n\n问题指出，该条件必须对基址寄存器 $R_b$ 和变址寄存器 $R_i$ 的任意值都成立。我们可以化简该方程，以找到满足此要求的 $d_1$ 和 $d_2$ 之间的关系。\n\n首先，将方程右侧的伸缩因子 $4$ 分配进去：\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 \\cdot 1 + d_2 $$\n$$ R_b + 4 R_i + d_1 = R_b + 4 R_i + 4 + d_2 $$\n\n项 $R_b$ 出现在两侧，可以通过从两侧减去 $R_b$ 来消掉。这与该条件对任意 $R_b$ 都成立是一致的。\n$$ 4 R_i + d_1 = 4 R_i + 4 + d_2 $$\n\n类似地，项 $4 R_i$ 出现在两侧。从两侧减去 $4 R_i$ 表明该条件对任意 $R_i$ 都成立。\n$$ d_1 = 4 + d_2 $$\n\n该方程 $d_1 = 4 + d_2$ 是使得两个地址表达式产生别名的关于位移 $d_1$ 和 $d_2$ 的充要条件，且与 $R_b$ 和 $R_i$ 的值无关。\n\n问题要求计算 $d_2 - d_1$ 的值。我们可以重新整理推导出的条件来解出这个差值。\n从 $d_1 = 4 + d_2$ 开始，我们从两侧减去 $d_1$ 和 $4$：\n$$ d_1 - d_1 - 4 = 4 - 4 + d_2 - d_1 $$\n$$ -4 = d_2 - d_1 $$\n\n因此，$d_2 - d_1$ 的值为 $-4$。位移以字节为单位，所以结果是 $-4$ 字节。这个结果是合乎逻辑的：将数组索引增加 1 会使地址前进 $S = 4$ 字节；为了保持最终地址不变，位移必须减少 4 字节，即 $d_2 = d_1 - 4$。", "answer": "$$ \\boxed{-4} $$", "id": "3636086"}, {"introduction": "计算出有效地址只是第一步；更重要的是理解该地址对系统性能的实际影响。本练习将抽象的地址计算与具体的硬件行为联系起来，展示了有效地址的属性（特别是奇偶性）如何在有内存对齐要求的系统中触发严重的性能损失 [@problem_id:3636147]。通过计算一系列加载操作因地址不对齐而产生的总周期惩罚，你将亲身体会到地址模式与系统性能之间的密切联系。", "problem": "一个64位中央处理器（CPU）中的加载/存储单元实现了位移寻址和变址寻址。对于一次字访问，该单元首先通过基址寄存器 $b$ 和一个乘以比例因子 $\\sigma$ 的变址寄存器 $i$ 形成基址-变址和 $s$，然后再加上一个位移量 $d$ 来计算有效地址（EA）。具体来说，该单元计算 $$EA = s + d,$$ 其中 $$s = b + \\sigma \\cdot i.$$ 在这台机器中，一个字是2个字节，内存系统要求字访问与2字节边界对齐，这意味着一次访问是对齐的当且仅当 $$EA \\bmod 2 = 0.$$\n\n考虑一个包含14次字加载的循环，该循环使用此寻址模式，其基址-变址和 $s$ 固定，每次迭代的位移量 $d$ 可变。给定的基址-变址和为 $$s = 16384,$$ 它是一个偶数。每次迭代的位移序列为 $$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}。$$\n\n该CPU使用一种对齐陷阱模型：当一次字访问未对齐时，会触发一个对齐陷阱，并由操作系统（OS）处理。对齐陷阱会引入以下周期成本：\n- 陷阱进入成本 $t_{e} = 20$ 个周期，\n- 处理程序模拟成本 $t_{h} = 12$ 个周期，\n- 陷阱退出成本 $t_{x} = 10$ 个周期，\n- 流水线重填成本 $t_{p} = 6$ 个周期。\n\n相比之下，一次对齐的字加载在 $c_{a} = 3$ 个周期内完成，并且不会产生任何陷阱成本。对于本问题，将一次未对齐访问的惩罚定义为相对于对齐情况，由陷阱造成的额外周期数，即 $$P = t_{e} + t_{h} + t_{x} + t_{p}.$$\n\n假设没有其他停顿或冒险，确定该序列中14次加载所产生的总惩罚（以周期为单位）。将最终结果表示为精确的整数周期数；无需四舍五入。此外，请使用 $s$ 和 $d$ 的奇偶性以及对齐规则，简要论证为什么当 $d$ 为奇数且 $s$ 为偶数时，字访问会出现有效地址未对齐的情况。", "solution": "经评估，本问题是有效的，因为其科学依据植根于计算机体系结构的原理，问题提法得当，数据充分且一致，并且语言客观。我们可以继续进行正式解答。\n\n问题要求做两件事：首先，论证内存访问在何种条件下会变得未对齐；其次，计算给定内存加载序列的总惩罚周期数。\n\n首先，我们来论证未对齐的原因。在此架构中，一个字是2个字节。字内存访问必须与2字节边界对齐。这意味着访问的有效地址（$EA$）必须是2的倍数。数学上，这个条件表示为：\n$$EA \\bmod 2 = 0$$\n如果不满足此条件，即 $EA \\bmod 2 \\neq 0$，则访问是未对齐的，对于整数而言，这等同于 $EA \\bmod 2 = 1$。这意味着未对齐的有效地址必须是一个奇数。\n\n有效地址计算公式为 $EA = s + d$，其中 $s$ 是基址-变址和，$d$ 是位移量。我们已知 $s = 16384$。为了确定 $s$ 的奇偶性，我们可以检查它是否能被2整除。由于 $16384 = 2 \\times 8192$，所以 $s$ 是一个偶数。\n\n我们现在可以使用模运算来分析 $EA$ 的奇偶性。一个和的奇偶性由其操作数的奇偶性决定。\n让我们考虑 $EA$ 对2取模的方程：\n$$EA \\pmod 2 = (s + d) \\pmod 2$$\n使用模运算的性质，这可以写成：\n$$EA \\pmod 2 = (s \\pmod 2 + d \\pmod 2) \\pmod 2$$\n因为 $s$ 是偶数，所以 $s \\pmod 2 = 0$。将此代入方程，得到：\n$$EA \\pmod 2 = (0 + d \\pmod 2) \\pmod 2 = d \\pmod 2$$\n这个结果表明，有效地址 $EA$ 的奇偶性与位移量 $d$ 的奇偶性相同。因此，一次访问是未对齐的（$EA$ 为奇数，所以 $EA \\pmod 2 = 1$）当且仅当位移量 $d$ 也为奇数（$d \\pmod 2 = 1$）。这就完成了所要求的论证。\n\n接下来，我们计算这14次加载序列所产生的总惩罚。\n单次未对齐访问的惩罚 $P$ 定义为与对齐陷阱相关的周期成本之和：\n$$P = t_{e} + t_{h} + t_{x} + t_{p}$$\n代入给定值：\n$t_{e} = 20$ 个周期\n$t_{h} = 12$ 个周期\n$t_{x} = 10$ 个周期\n$t_{p} = 6$ 个周期\n$$P = 20 + 12 + 10 + 6 = 48 \\text{ cycles}$$\n这是每次未对齐访问的惩罚。对齐的访问没有这种惩罚。\n\n现在，我们必须确定这14次加载操作中有多少次是未对齐的。根据我们之前的分析，如果对应的位移量 $d$ 是奇数，那么访问就是未对齐的。位移序列如下：\n$$D = \\{1, 4, 5, 8, 11, 14, 15, 18, 21, 22, 25, 30, 31, 34\\}$$\n我们找出这个序列中的奇数：\n- $1$ （奇数）\n- $4$ （偶数）\n- $5$ （奇数）\n- $8$ （偶数）\n- $11$ （奇数）\n- $14$ （偶数）\n- $15$ （奇数）\n- $18$ （偶数）\n- $21$ （奇数）\n- $22$ （偶数）\n- $25$ （奇数）\n- $30$ （偶数）\n- $31$ （奇数）\n- $34$ （偶数）\n\n奇数位移量的集合是 $\\{1, 5, 11, 15, 21, 25, 31\\}$。通过计算该集合中元素的数量，我们得到未对齐访问的总次数 $N_{\\text{misaligned}}$。\n$$N_{\\text{misaligned}} = 7$$\n总惩罚是未对齐访问的次数与每次访问的惩罚的乘积。\n$$\\text{Total Penalty} = N_{\\text{misaligned}} \\times P$$\n代入我们找到的值：\n$$\\text{Total Penalty} = 7 \\times 48$$\n进行乘法运算：\n$$7 \\times 48 = 7 \\times (40 + 8) = 280 + 56 = 336$$\n因此，这14次加载序列产生的总惩罚是 $336$ 个周期。", "answer": "$$\\boxed{336}$$", "id": "3636147"}, {"introduction": "复杂的寻址模式是硬件直接提供还是由软件模拟？本练习将带你探索硬件和软件之间的界限。你将面临的挑战是，在一台仅支持简单位移寻址的机器上，通过一系列基本指令来模拟功能更强大的变址加比例因子寻址模式 [@problem_id:3636068]。这个过程不仅能加深你对编译器如何为复杂操作生成代码的理解，还能让你量化分析这种软件模拟相对于硬件直接实现的性能成本。", "problem": "考虑一个加载指令，它概念上需要一个由基址寄存器、变址缩放和位移构成的有效地址（EA），而这台机器只实现了位移寻址。位移寻址的基本定义是有效地址计算为 $EA = R_{b} + d$，其中 $R_{b}$ 是任意通用寄存器，$d$ 是一个符号扩展的立即数位移。形式为 $EA = R_{b} + R_{i} \\cdot 8 + d$ 的变址缩放寻址在这台机器上不被硬件直接支持。您必须依赖算术逻辑单元（ALU）提供的整数运算和位移寻址模式来达到同样的效果。\n\n假设存在以下经过良好测试的标准执行时间模型和指令集：\n- 该机器可以按程序顺序每个周期发射一条指令，且不存在冒险或重叠；一个序列的总周期数等于每条指令的周期数之和。\n- ALU 支持寄存器到寄存器传送（$\\mathrm{MOV}$）、加法（$\\mathrm{ADD}$）和按立即数进行的逻辑左移（$\\mathrm{SHL}$）。这些 ALU 指令均在 $1$ 个周期内完成。\n- 加载指令 $\\mathrm{LD}\\ R_{x}, [R + d]$ 使用位移寻址（$EA = R + d$），并在 $4$ 个周期内完成，其中包括地址生成和内存访问。\n- 如果硬件支持变址缩放寻址，相应的单指令加载 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 也将在 $4$ 个周期内完成。\n\n给定条件是，寄存器 $R_{i}$ 的值在序列执行过程中不得被修改（其值必须被保留），并且有一个可用的暂存寄存器 $R_{t}$，其初始值未指定。请设计一个仅使用 $\\mathrm{MOV}$、$\\mathrm{SHL}$、$\\mathrm{ADD}$ 和 $\\mathrm{LD}$ 的最小指令序列，以在不破坏 $R_{i}$ 的前提下，执行与 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 等效的操作。然后，计算您的序列相对于假设的单指令变址缩放加载所需的额外周期数。将最终答案表示为单个整数周期数。无需四舍五入，最终答案不应包含单位。", "solution": "首先对问题进行验证过程。\n\n### 步骤1：提取已知条件\n- **目标操作**：使用定义为 $EA = R_{b} + R_{i} \\cdot 8 + d$ 的有效地址（EA）进行加载。\n- **硬件寻址模式**：仅限位移寻址，$EA = R_{\\text{base}} + d$，其中 $R_{\\text{base}}$ 是一个通用寄存器，$d$ 是一个符号扩展的立即数位移。\n- **不支持的寻址模式**：不支持变址缩放寻址，$EA = R_{b} + R_{i} \\cdot 8 + d$。\n- **执行模型**：单发射、顺序执行，无冒险。总周期数是各个指令周期数的总和。\n- **指令集和延迟**：\n  - $\\mathrm{MOV}$（寄存器到寄存器）：$1$ 个周期。\n  - $\\mathrm{ADD}$（寄存器到寄存器）：$1$ 个周期。\n  - $\\mathrm{SHL}$（按立即数逻辑左移）：$1$ 个周期。\n  - $\\mathrm{LD}\\ R_{x}, [R + d]$（使用位移寻址加载）：$4$ 个周期。\n- **假设的指令延迟**：一个假设的 $\\mathrm{LD}\\ R_{x}, [R_{b} + R_{i} \\cdot 8 + d]$ 指令将耗时 $4$ 个周期。\n- **约束条件**：\n  1. 寄存器 $R_{i}$ 中的值必须被保留。\n  2. 有一个可用的暂存寄存器 $R_{t}$。\n  3. 解决方案必须仅使用提供的指令：$\\mathrm{MOV}$、$\\mathrm{SHL}$、$\\mathrm{ADD}$ 和 $\\mathrm{LD}$。\n- **目标**：\n  1. 构建一个最小指令序列，以执行与目标加载操作等效的操作。\n  2. 计算此序列相比于假设的单指令实现所需的额外周期数。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题是计算机组成与体系结构中的一个经典练习，涉及指令集架构（ISA）、寻址模式和性能分析（周期计数）。这些概念是该领域的基础。简化的执行模型（无冒险）是一种标准的教学简化方法。\n- **定义明确**：目标清晰，可用资源（$\\mathrm{MOV}$、$\\mathrm{ADD}$、$\\mathrm{SHL}$、$\\mathrm{LD}$、一个暂存寄存器）明确列出，约束条件（保留 $R_{i}$）明确无误。客观指标（额外周期数）陈述精确。可以逻辑推导出一个最小序列，从而得到唯一解。\n- **客观性**：该问题使用计算机体系结构领域的标准、客观术语进行陈述。没有使用主观或模糊的语言。\n- **缺陷分析**：问题陈述没有科学上的不严谨、不完整、矛盾以及验证标准中列出的其他缺陷。它提出了一个可解的、自包含的场景，与计算机体系结构的主题直接相关。\n\n### 步骤3：结论与行动\n问题被判定为**有效**。将构建一个解决方案。\n\n### 解题推导\n\n目标是从有效地址 $EA = R_{b} + R_{i} \\cdot 8 + d$ 执行加载操作。硬件的原生加载指令 $\\mathrm{LD}\\ R_{x}, [R + d]$ 只能通过将单个寄存器 $R$ 的内容与一个立即数位移 $d$ 相加来计算有效地址。\n\n为了实现目标寻址模式，我们必须首先计算出硬件无法处理的地址部分，即基址与变址缩放之和，$R_{b} + R_{i} \\cdot 8$。这个计算出的值必须被放入一个寄存器中，该寄存器将作为最终 $\\mathrm{LD}$ 指令的基址寄存器。题目为此提供了一个暂存寄存器 $R_{t}$。\n\n计算必须使用可用的 ALU 指令按步骤序列执行，同时要遵守寄存器 $R_{i}$ 不得被修改的约束。\n\n1.  **保留寄存器 $R_{i}$**：由于计算需要 $R_{i}$ 的值，但寄存器本身不得被修改，我们必须首先将其内容复制到暂存寄存器 $R_{t}$ 中。\n    - 指令：$\\mathrm{MOV}\\ R_{t}, R_{i}$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 持有 $R_{i}$ 的初始值。\n\n2.  **计算变址缩放**：必须计算 $R_{i} \\cdot 8$ 这一项。乘以 $8$（等于 $2^3$）等效于逻辑左移 $3$ 个比特位。我们在当前持有 $R_{i}$ 值的 $R_{t}$ 上执行此操作。\n    - 指令：$\\mathrm{SHL}\\ R_{t}, 3$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 包含值 $(R_{i} \\cdot 8)$。\n\n3.  **加上基址寄存器**：必须将基址寄存器 $R_{b}$ 的内容加到变址缩放值上。\n    - 指令：$\\mathrm{ADD}\\ R_{t}, R_{b}$\n    - 此操作需要 $1$ 个周期。此后，$R_{t}$ 包含值 $(R_{b} + R_{i} \\cdot 8)$。\n\n4.  **执行加载**：现在，寄存器 $R_{t}$ 持有地址的基址加变址缩放部分。我们可以将 $R_{t}$ 用作原生位移模式加载指令中的基址寄存器。硬件将计算最终有效地址为 $EA = R_{t} + d$，这解析为 $(R_{b} + R_{i} \\cdot 8) + d$，正是目标地址。\n    - 指令：$\\mathrm{LD}\\ R_{x}, [R_{t} + d]$\n    - 此操作需要 $4$ 个周期。\n\n最终的最小指令序列是：\n- $\\mathrm{MOV}\\ R_{t}, R_{i}$\n- $\\mathrm{SHL}\\ R_{t}, 3$\n- $\\mathrm{ADD}\\ R_{t}, R_{b}$\n- $\\mathrm{LD}\\ R_{x}, [R_{t} + d]$\n\n该序列是最小的，因为前三条指令中的每一条都是在不违反 $R_{i}$ 保留约束的情况下，在 $R_{t}$ 中计算所需地址分量 $(R_{b} + R_{i} \\cdot 8)$ 所必需的，而最后的 `LD` 指令是执行内存访问所必需的。\n\n这个合成操作的总周期数 $C_{\\text{sequence}}$ 是序列中每条指令的周期数之和：\n$$C_{\\text{sequence}} = C_{\\text{MOV}} + C_{\\text{SHL}} + C_{\\text{ADD}} + C_{\\text{LD}}$$\n$$C_{\\text{sequence}} = 1 + 1 + 1 + 4 = 7 \\text{ 个周期}$$\n\n题目指出，如果存在用于变址缩放寻址的假设性单指令，它将在 $C_{\\text{hypothetical}} = 4$ 个周期内完成。\n\n合成指令序列所需的额外周期数是这两个周期计数的差值：\n$$\\text{Extra Cycles} = C_{\\text{sequence}} - C_{\\text{hypothetical}}$$\n$$\\text{Extra Cycles} = 7 - 4 = 3$$\n\n因此，与假设的硬件实现相比，该合成方法需要额外 $3$ 个周期。", "answer": "$$\n\\boxed{3}\n$$", "id": "3636068"}]}