{"hands_on_practices": [{"introduction": "指令集架构（ISA）不仅定义了处理器可以执行哪些操作，还精确规定了如何处理不同大小的数据。一个常见的例子是将一个字节（8位）加载到一个更宽的寄存器（例如32位）中。这个练习 [@problem_id:3650307] 将探讨符号扩展和零扩展之间的关键区别，并展示错误地使用加载指令（例如 `lb` 与 `lbu`）如何导致难以察觉的程序错误，从而强调了为保持数据值的正确性而选择正确指令的重要性。", "problem": "一个实现$32$位指令集架构（ISA）的处理器使用两种标准的字节加载指令：$lb$（加载字节，将加载的$8$位值符号扩展到$32$位）和$lbu$（无符号加载字节，将加载的$8$位值零扩展到$32$位）。内存是字节可寻址的，有符号整数以二进制补码表示。考虑一个转换例程，旨在通过加载每个输入字节然后将其存储为$32$位整数，将一个有符号$8$位整数序列转换为有符号$32$位整数序列。\n\n假设地址为$A$、$A+1$和$A+2$的输入缓冲区分别包含字节$0x80$、$0x7F$和$0xFF$。由于一个错误，该例程对地址$A$的第一个字节使用了$lbu$，对地址$A+1$和$A+2$的其余两个字节使用了$lb$。哪个由有符号$32$位整数组成的三元组将被写入输出数组？\n\nA. $(-128, 127, -1)$\n\nB. $(128, 127, -1)$\n\nC. $(-128, 127, 255)$\n\nD. $(128, 127, 255)$", "solution": "首先将验证问题陈述，以确保其科学上合理、定义明确且完整。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- 处理器架构：$32$位指令集架构（ISA）。\n- 加载指令：\n    - `lb`（加载字节）：加载一个$8$位值并将其符号扩展到$32$位。\n    - `lbu`（无符号加载字节）：加载一个$8$位值并将其零扩展到$32$位。\n- 内存：字节可寻址。\n- 数据表示：有符号整数使用二进制补码。\n- 输入数据：\n    - 地址 $A$ 处的字节：$0x80$。\n    - 地址 $A+1$ 处的字节：$0x7F$。\n    - 地址 $A+2$ 处的字节：$0xFF$。\n- 错误的执行：\n    - 地址 $A$ 处的字节使用 `lbu` 加载。\n    - 地址 $A+1$ 处的字节使用 `lb` 加载。\n    - 地址 $A+2$ 处的字节使用 `lb` 加载。\n- 问题：确定得到的有符号$32$位整数三元组。\n\n**第2步：使用提取的已知条件进行验证**\n- **科学基础**：该问题很好地基于计算机组成和体系结构的基本原理。诸如ISA、加载指令、符号扩展、零扩展、二进制补码表示和内存寻址等概念都是标准的，并且描述正确。\n- **适定性**：该问题是适定的。它提供了所有必要的信息——输入字节值、每个字节使用的具体指令以及数据表示标准——以计算出一个唯一且确定的结果。\n- **客观性**：问题以精确、客观和技术性的语言陈述，没有歧义或主观因素。\n\n**第3步：结论与行动**\n问题陈述被认定为有效。这是一个计算机体系结构中的标准、定义明确的问题。可以继续进行求解过程。\n\n### 解题推导\n\n任务是确定通过使用特定指令加载三个$8$位字节后得到的三个有符号$32$位整数的十进制值。我们将逐个分析每种情况。\n\n**1. 地址 $A$ 处的字节**\n\n- 输入字节值：$0x80$。在$8$位二进制中，这是$10000000_2$。\n- 指令：`lbu`（无符号加载字节）。\n- `lbu` 指令将$8$位字节加载到$32$位寄存器的最低有效字节，并用零填充高$24$位（零扩展）。\n- 寄存器中得到的$32$位值为：\n$$ 00000000\\;00000000\\;00000000\\;10000000_2 $$\n- 在十六进制中，这是 $0x00000080$。\n- 这个$32$位值被解释为二进制补码形式的有符号整数。最高有效位（MSB，第$31$位）是 $0$，表示一个正数。\n- 其十进制值是对这个正数进行标准的二进制到十进制转换：\n$$ 1 \\times 2^7 = 128_{10} $$\n- 因此，第一个整数是 $128$。\n\n**2. 地址 $A+1$ 处的字节**\n\n- 输入字节值：$0x7F$。在$8$位二进制中，这是$01111111_2$。\n- 指令：`lb`（加载字节）。\n- `lb` 指令加载$8$位字节并将其符号位扩展以填充高$24$位。一个$8$位值的符号位是其最高有效位（第$7$位）。\n- $01111111_2$ 的最高有效位是 $0$。因此，高$24$位用零填充。\n- 寄存器中得到的$32$位值为：\n$$ 00000000\\;00000000\\;00000000\\;01111111_2 $$\n- 在十六进制中，这是 $0x0000007F$。\n- 这个$32$位值的最高有效位是 $0$，表示一个正数。\n- 其十进制值为：\n$$ 1 \\times 2^6 + 1 \\times 2^5 + 1 \\times 2^4 + 1 \\times 2^3 + 1 \\times 2^2 + 1 \\times 2^1 + 1 \\times 2^0 = 64 + 32 + 16 + 8 + 4 + 2 + 1 = 127_{10} $$\n- 因此，第二个整数是 $127$。\n\n**3. 地址 $A+2$ 处的字节**\n\n- 输入字节值：$0xFF$。在$8$位二进制中，这是$11111111_2$。\n- 指令：`lb`（加载字节）。\n- `lb` 指令执行符号扩展。字节 $11111111_2$ 的最高有效位（第$7$位）是 $1$。\n- 因此，$32$位寄存器的高$24$位用一填充。\n- 寄存器中得到的$32$位值为：\n$$ 11111111\\;11111111\\;11111111\\;11111111_2 $$\n- 在十六进制中，这是 $0xFFFFFFFF$。\n- 这个$32$位值被解释为二进制补码形式的有符号整数。最高有效位（第$31$位）是 $1$，表示一个负数。\n- 在二进制补码中，所有位都为 $1$ 表示的值是 $-1$。\n- 为了正式验证，我们求这个数的二进制补码以得到其绝对值。将所有位取反得到 $0x00000000$，再加 $1$ 得到 $0x00000001$。所以其绝对值为 $1$。由于这个数是负数，其值为 $-1$。\n- 因此，第三个整数是 $-1$。\n\n**结论**\n\n得到的有符号$32$位整数三元组是 $(128, 127, -1)$。\n\n### 逐项分析\n\n- **A. $(-128, 127, -1)$**: 错误。第一个值 $-128$ 是对 $0x80$ 使用 `lb` 的结果。由于 $0x80$ 的最高有效位是 $1$，`lb` 会将其符号扩展为 $0xFFFFFF80$，这在$32$位二进制补码中是 $-128$。然而，题目指定使用了 `lbu`，其结果是 $128$。\n\n- **B. $(128, 127, -1)$**: 正确。该选项与所有三个操作的推导值相匹配：\n  - $0x80$ 使用 `lbu` $\\rightarrow$ 零扩展 $\\rightarrow$ $0x00000080$ $\\rightarrow$ $128$。\n  - $0x7F$ 使用 `lb` $\\rightarrow$ 最高有效位 $0$ 的符号扩展 $\\rightarrow$ $0x0000007F$ $\\rightarrow$ $127$。\n  - $0xFF$ 使用 `lb` $\\rightarrow$ 最高有效位 $1$ 的符号扩展 $\\rightarrow$ $0xFFFFFFFF$ $\\rightarrow$ $-1$。\n\n- **C. $(-128, 127, 255)$**: 错误。第一个值不正确的原因与选项A相同。第三个值 $255$ 是对 $0xFF$ 使用 `lbu` 的结果。`lbu` 会将 $0xFF$ 零扩展为 $0x000000FF$，作为一个有符号整数其值为 $255$。题目指定使用 `lb`。\n\n- **D. $(128, 127, 255)$**: 错误。第三个值不正确的原因与选项C相同。对 $0xFF$ 使用 `lb` 的结果是 $-1$，而不是 $255$。", "answer": "$$\\boxed{B}$$", "id": "3650307"}, {"introduction": "在程序中，条件逻辑（如 if-then-else 语句）的实现方式对性能有显著影响。这个练习 [@problem_id:3650337] 探讨了两种实现条件赋值的ISA机制：传统的控制流分支指令和基于数据流的条件传送指令（`cmov`）。通过建立一个简单的性能模型，你将学会量化这两种方法之间的权衡——即高延迟的数据依赖与潜在高成本的分支误预测之间的较量，并推导出选择最优策略的临界点。", "problem": "在现代乱序执行中央处理器 (CPU) 的指令集架构 (ISA) 背景下，考虑一个简单的条件赋值：一个程序必须根据一个布尔条件计算目的寄存器的值，然后立即在一个相关指令中使用该值。该条件可以通过控制流条件分支或谓词传送（也称为条件传送，CMOV）来实现。\n\n假设采用以下经典流水线成本模型，该模型仅分离出两种实现之间的区别性影响，并将所有其他共同成本视为一个公共基线。设两种实现的公共基线成本（包括计算条件、取指、译码以及在没有额外惩罚的情况下消费者指令的延迟）为 $B$ 个周期。对于基于分支的实现，设此特定条件的稳态预测错误概率为 $p$，并且每次预测错误都会因流水线清空和重新取指而产生 $C_m$ 个周期的惩罚。对于基于 CMOV 的实现，假设消除控制相关会引入对两个候选源操作数的数据相关，从而相对于理想单源就绪情况下的同一消费者指令，为相关消费者指令制造了 $L_d$ 个周期的关键路径延迟。\n\n在这些假设下，从第一性原理出发，为基于分支的实现和基于 CMOV 的实现建立期望执行时间（以周期为单位）的模型。然后，推导当两种实现的期望执行时间相等时的盈亏平衡预测错误概率 $p^{\\star}$（作为 $C_m$ 和 $L_d$ 的函数）。\n\n将最终答案表示为关于 $C_m$ 和 $L_d$ 的单个闭式解析表达式。无需进行数值计算。只需陈述 $p^{\\star}$ 的表达式作为最终答案。", "solution": "该问题要求的是盈亏平衡分支预测错误概率 $p^{\\star}$，在该概率下，使用控制流分支实现的条件赋值与使用条件传送（CMOV）指令实现的条件赋值具有相同的期望执行时间。为此，我们必须首先根据所提供的参数为每种实现建立期望执行时间的模型。\n\n设 $E[T_{branch}]$ 为基于分支的实现的期望执行时间。执行时间取决于分支是被正确预测还是错误预测。\n正确预测的概率为 $1-p$。在这种情况下，执行继续而没有惩罚，成本为基线成本 $B$。\n预测错误的概率为 $p$。在这种情况下，流水线必须被清空，产生 $C_m$ 个周期的惩罚。成本为基线成本加上惩罚，即 $B + C_m$。\n\n期望执行时间是每种结果的成本按其各自概率加权的总和：\n$$E[T_{branch}] = (1-p)(B) + p(B+C_m)$$\n我们可以通过展开各项来简化这个表达式：\n$$E[T_{branch}] = B - pB + pB + pC_m$$\n项 $-pB$ 和 $+pB$ 相互抵消，得到：\n$$E[T_{branch}] = B + pC_m$$\n\n接下来，设 $T_{cmov}$ 为基于 CMOV 的实现的执行时间。问题指出，CMOV 指令避免了控制流冒险，但引入了数据相关冒险。这导致了相关指令产生 $L_d$ 个周期的确定性关键路径延迟。此延迟是在基线成本 $B$ 之上的额外成本。因此，在这个模型中，CMOV 实现的执行时间不是概率性的。\n$$T_{cmov} = B + L_d$$\n\n盈亏平衡预测错误概率 $p^{\\star}$ 是使得两种实现的期望执行时间相等的 $p$ 值。我们通过令 $E[T_{branch}]$ 等于 $T_{cmov}$ 并求解 $p = p^{\\star}$ 来找到这个值。\n$$E[T_{branch}] = T_{cmov}$$\n$$B + p^{\\star}C_m = B + L_d$$\n我们可以从方程两边减去公共基线成本 $B$：\n$$p^{\\star}C_m = L_d$$\n最后，为了求得 $p^{\\star}$，我们在假设 $C_m \\neq 0$ 的情况下，将方程两边同时除以预测错误惩罚 $C_m$。鉴于 $C_m$ 代表一个惩罚，从物理意义上讲它应为正值，所以 $C_m > 0$。\n$$p^{\\star} = \\frac{L_d}{C_m}$$\n这个表达式代表了盈亏平衡预测错误概率。如果实际预测错误概率 $p$ 大于 $p^{\\star}$，那么 CMOV 实现预期会更快。如果 $p$ 小于 $p^{\\star}$，那么基于分支的实现预期会更快。该表达式是关于 $C_m$ 和 $L_d$ 的闭式解析函数，符合题目要求。", "answer": "$$\\boxed{\\frac{L_d}{C_m}}$$", "id": "3650337"}, {"introduction": "设计指令集架构如同在有限的空间里进行精密的规划，指令中的每一个比特都至关重要。本练习 [@problem_id:3650299] 将你置于计算机架构师的角色，你需要决定为算术和分支指令中的立即数分配多少比特位。通过分析典型程序的统计数据模型，你将学习如何做出量化的设计决策，这些决策不仅影响指令格式，还直接关系到代码密度和需要额外加载操作的频率。", "problem": "一种精简指令集计算机 (RISC) 的指令集架构 (ISA) 使用在二进制补码中编码的符号扩展立即数。一条立即数加法指令有一个 $k_{\\text{add}}$ 位的立即数字段，该字段必须能编码一个在 $[-2^{k_{\\text{add}}-1},\\,2^{k_{\\text{add}}-1}-1]$ 范围内的有符号整数 $C$。一条条件分支指令有一个 $k_{\\text{br}}$ 位的有符号偏移量，以完整的指令字为单位进行度量（也就是说，偏移量 $d$ 编码了 $d$ 个指令字的位移）。假设指令为大小为 $4$ 字节的定长指令，但分支位移如上定义，以指令字为单位度量。\n\n全程序剖析产生了以下统计上稳定的模型。\n\n1.  对于立即数加法，绝对值 $X := |C|$ 服从一个混合分布，对于 $C$ 而言符号对称，并具有以下条件分布：\n    -   以 $0.50$ 的概率，$X$ 在 $[0,\\,31]$ 上均匀分布。\n    -   以 $0.35$ 的概率，$X$ 在 $(31,\\,255]$ 上均匀分布。\n    -   以 $0.15$ 的概率，$X$ 在 $(255,\\,4095]$ 上均匀分布。\n\n    $C$ 的符号是独立且对称的。\n\n2.  对于以指令字为单位的分支位移，位移 $D$ 被建模为一个零均值拉普拉斯分布，其参数为 $\\lambda = 1/20$（因此概率密度函数为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $d$ 以指令字为单位）。为了进行覆盖率估计，将 $D$ 视为连续变量。\n\n设计目标如下：\n-   选择最小的整数 $k_{\\text{add}}$，使得从该模型中抽取的立即数加法常量 $C$ 能够被编码的概率至少为 $0.97$。\n-   选择最小的整数 $k_{\\text{br}}$，使得从该模型中抽取的分支位移 $D$ 能够被编码的概率至少为 $0.999$。\n\n现在假设立即数加法指令的立即数字段必须减少 $\\Delta = 2$ 位，变为 $k_{\\text{add}}' = k_{\\text{add}} - 2$。在相同的常量模型下，估计立即数加法指令的字面量池溢出 (literal-pool spills) 的期望频率，该频率定义为 $C$ 无法用缩减后的宽度 $k_{\\text{add}}'$ 编码的概率。\n\n将 $k_{\\text{add}}$ 和 $k_{\\text{br}}$ 报告为整数（单位为位），并将溢出频率报告为一个十进制小数（不带百分号）。将溢出频率四舍五入到四位有效数字。", "solution": "用户提供了一个关于计算机体系结构中指令集架构 (ISA) 设计的问题。在进行求解之前，我将首先验证问题陈述。\n\n### 第 1 步：提取已知条件\n-   **ISA 类型**：精简指令集计算机 (RISC)。\n-   **指令格式**：大小为 $4$ 字节的定长指令。\n-   **立即数加法指令**：\n    -   有一个 $k_{\\text{add}}$ 位的立即数字段，用于表示一个有符号整数 $C$。\n    -   值 $C$ 以二进制补码编码，有效范围为 $[-2^{k_{\\text{add}}-1}, 2^{k_{\\text{add}}-1}-1]$。\n-   **条件分支指令**：\n    -   有一个 $k_{\\text{br}}$ 位的有符号偏移量字段，用于表示一个整数位移 $d$。\n    -   位移以指令字（即 $4$ 字节的倍数）为单位度量。\n    -   $d$ 的有效范围为 $[-2^{k_{\\text{br}}-1}, 2^{k_{\\text{br}}-1}-1]$。\n-   **立即数加法常量 $C$ 的模型**：\n    -   绝对值 $X := |C|$ 服从一个混合分布。$C$ 的符号是独立且对称的。\n    -   以概率 $p_1 = 0.50$，$X$ 在整数集合 $[0, 31]$ 上均匀分布。\n    -   以概率 $p_2 = 0.35$，$X$ 在整数集合 $(31, 255]$（即 $[32, 255]$）上均匀分布。\n    -   以概率 $p_3 = 0.15$，$X$ 在整数集合 $(255, 4095]$（即 $[256, 4095]$）上均匀分布。\n-   **分支位移 $D$ 的模型**：\n    -   位移 $D$（以指令字为单位）被建模为一个连续随机变量，服从零均值拉普拉斯分布。\n    -   概率密度函数 (PDF) 为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $\\lambda = 1/20$。\n-   **设计目标**：\n    1.  找出最小的整数 $k_{\\text{add}}$，使得立即数加法常量 $C$ 可被编码的概率至少为 $0.97$。\n    2.  找出最小的整数 $k_{\\text{br}}$，使得分支位移 $D$ 可被编码的概率至少为 $0.999$。\n-   **场景**：\n    1.  立即数加法字段的宽度减少到 $k_{\\text{add}}' = k_{\\text{add}} - \\Delta$，其中 $\\Delta = 2$。\n    2.  估计溢出频率，定义为 $C$ 无法用宽度 $k_{\\text{add}}'$ 编码的概率。\n-   **报告要求**：\n    -   将 $k_{\\text{add}}$ 和 $k_{\\text{br}}$ 报告为整数。\n    -   将溢出频率报告为一个四舍五入到四位有效数字的十进制小数。\n\n### 第 2 步：使用提取的已知条件进行验证\n-   **科学依据**：该问题在计算机体系结构和 ISA 设计领域有充分的理论基础。使用有符号立即数、二进制补码、分支偏移量以及操作数值的统计模型（混合均匀分布、拉普拉斯分布）都是该领域的标准概念和实践。\n-   **问题的适定性**：问题是适定的。所有必需的分布、参数和设计约束都已提供。目标定义清晰，可以导出唯一的、可计算的解。\n-   **客观性**：问题以精确、技术性的语言陈述，没有任何主观性或歧义。\n-   **结论**：没有发现可识别的缺陷（例如，科学上不健全、信息缺失、矛盾）。问题是有效的。\n\n### 第 3 步：判断与行动\n问题是有效的。我将继续进行详细解答。\n\n### 解答\n\n问题分为三个部分：确定 $k_{\\text{add}}$，确定 $k_{\\text{br}}$，以及计算溢出频率。\n\n**第 1 部分：确定立即数加法字段宽度 $k_{\\text{add}}$**\n\n一个常量 $C$ 如果在 $[-2^{k_{\\text{add}}-1}, 2^{k_{\\text{add}}-1}-1]$ 范围内，就可以用一个 $k_{\\text{add}}$ 位的二进制补码字段进行编码。令 $X = |C|$。\n$C$ 可被编码的概率 $P(\\text{可编码})$ 由下式给出：\n$P(\\text{可编码}) = P(-2^{k_{\\text{add}}-1} \\le C \\le 2^{k_{\\text{add}}-1}-1)$。\n\n鉴于 $C$ 的符号是对称的（对于 $C \\neq 0$，$P(C>0) = P(C<0)$），我们可以用 $X$ 来表示这个概率。假设 $P(C \\ge 0) = P(C \\le 0) = 0.5$：\n$P(\\text{可编码}) = 0.5 \\cdot P(X \\le 2^{k_{\\text{add}}-1}-1) + 0.5 \\cdot P(X \\le 2^{k_{\\text{add}}-1})$。\n\n$X$ 的分布是三个离散均匀分布的混合：\n1.  在 $\\{0, \\dots, 31\\}$ 上的 $U_1$（$32$ 个点），混合权重 $p_1=0.50$。\n2.  在 $\\{32, \\dots, 255\\}$ 上的 $U_2$（$224$ 个点），混合权重 $p_2=0.35$。\n3.  在 $\\{256, \\dots, 4095\\}$ 上的 $U_3$（$3840$ 个点），混合权重 $p_3=0.15$。\n\n$X$ 的累积分布函数 (CDF) 为 $F_X(x) = P(X \\le x) = \\sum_{i=1}^3 p_i P(X \\le x | U_i)$。\n对于一个整数 $x$，在 $\\{a, \\dots, b\\}$ 上的离散均匀分布的 CDF 为 $P(X \\le x) = (\\lfloor x \\rfloor - a + 1) / (b - a + 1)$，其中 $a \\le x \\le b$。\n\n我们需要找到最小的整数 $k_{\\text{add}}$，使得 $P(\\text{可编码}) \\ge 0.97$。我们来测试 $k_{\\text{add}}$ 的整数值。\n\n我们来测试 $k_{\\text{add}} = 12$：\n范围是 $[-2^{11}, 2^{11}-1] = [-2048, 2047]$。\n我们需要 $P(X \\le 2047)$ 和 $P(X \\le 2048)$。\n$P(X \\le 2047) = 0.50 \\cdot P(X \\le 2047 | U_1) + 0.35 \\cdot P(X \\le 2047 | U_2) + 0.15 \\cdot P(X \\le 2047 | U_3)$。\n$P(X \\le 2047 | U_1) = 1$ (因为 $2047 > 31$)。\n$P(X \\le 2047 | U_2) = 1$ (因为 $2047 > 255$)。\n$P(X \\le 2047 | U_3) = \\frac{2047 - 256 + 1}{3840} = \\frac{1792}{3840} = \\frac{7}{15}$。\n$P(X \\le 2047) = 0.50(1) + 0.35(1) + 0.15(\\frac{7}{15}) = 0.85 + 0.07 = 0.92$。\n\n$P(X \\le 2048) = 0.50(1) + 0.35(1) + 0.15 \\cdot P(X \\le 2048 | U_3)$。\n$P(X \\le 2048 | U_3) = \\frac{2048 - 256 + 1}{3840} = \\frac{1793}{3840}$。\n$P(X \\le 2048) = 0.85 + 0.15 \\left(\\frac{1793}{3840}\\right) = 0.85 + \\frac{1793}{25600} \\approx 0.85 + 0.070039 = 0.920039$。\n\n$P(\\text{可编码对于 } k_{\\text{add}}=12) = 0.5(0.92) + 0.5(0.920039) \\approx 0.92002$。\n因为 $0.92002 < 0.97$，所以 $k_{\\text{add}}=12$ 不足够。\n\n我们来测试 $k_{\\text{add}} = 13$：\n范围是 $[-2^{12}, 2^{12}-1] = [-4096, 4095]$。\n模型中 $X$ 的最大值是 $4095$。\n$P(X \\le 4095) = 1$。\n$P(X \\le 4096) = 1$。\n$P(\\text{可编码对于 } k_{\\text{add}}=13) = 0.5(1) + 0.5(1) = 1$。\n因为 $1 \\ge 0.97$，所以 $k_{\\text{add}}=13$ 足够。\n因此，最小的整数值是 $k_{\\text{add}} = 13$。\n\n**第 2 部分：确定分支偏移字段宽度 $k_{\\text{br}}$**\n\n一个分支位移 $d$ 如果在 $[-2^{k_{\\text{br}}-1}, 2^{k_{\\text{br}}-1}-1]$ 范围内，则可被编码。位移 $D$ 是一个连续变量，其 PDF 为 $f_{D}(d) = (\\lambda/2)\\exp(-\\lambda |d|)$，其中 $\\lambda=1/20$。我们需要 $P(-2^{k_{\\text{br}}-1} \\le D \\le 2^{k_{\\text{br}}-1}-1) \\ge 0.999$。\n\n一个常见且合理的简化是检查最大对称范围的覆盖率，即 $|D| \\le 2^{k_{\\text{br}}-1}-1$。\n$|D|$ 的 CDF 是 $F_{|D|}(y) = P(|D| \\le y) = \\int_{-y}^y f_D(d)dd = 1 - \\exp(-\\lambda y)$，其中 $y \\ge 0$。\n我们需要 $1 - \\exp(-\\lambda (2^{k_{\\text{br}}-1}-1)) \\ge 0.999$。\n$\\exp(-\\lambda(2^{k_{\\text{br}}-1}-1)) \\le 0.001$。\n$-\\lambda(2^{k_{\\text{br}}-1}-1) \\le \\ln(0.001) = -3\\ln(10)$。\n$2^{k_{\\text{br}}-1}-1 \\ge \\frac{3\\ln(10)}{\\lambda} = \\frac{3\\ln(10)}{1/20} = 60\\ln(10)$。\n使用 $\\ln(10) \\approx 2.3026$，我们得到 $2^{k_{\\text{br}}-1}-1 \\ge 60 \\times 2.3026 = 138.156$。\n$2^{k_{\\text{br}}-1} \\ge 139.156$。\n因为 $k_{\\text{br}}$ 必须是整数，所以 $k_{\\text{br}}-1$ 也必须是整数。我们必须找到最小的整数 $k_{\\text{br}}-1$ 使得 $2^{k_{\\text{br}}-1} \\ge 139.156$。\n我们知道 $2^7=128$ 和 $2^8=256$。\n所以，我们必须有 $k_{\\text{br}}-1 \\ge 8$，这意味着 $k_{\\text{br}} \\ge 9$。最小的整数值是 $k_{\\text{br}}=9$。\n\n我们来验证这个结果。\n对于 $k_{\\text{br}}=8$，范围是 $[-128, 127]$。对称范围是 $|D| \\le 127$。\n$P(|D| \\le 127) = 1 - \\exp(-127/20) = 1 - \\exp(-6.35) \\approx 1 - 0.001747 = 0.998253$。\n因为 $0.998253 < 0.999$，所以 $k_{\\text{br}}=8$ 不足够。\n\n对于 $k_{\\text{br}}=9$，范围是 $[-256, 255]$。对称范围是 $|D| \\le 255$。\n$P(|D| \\le 255) = 1 - \\exp(-255/20) = 1 - \\exp(-12.75) \\approx 1 - 2.895 \\times 10^{-6} = 0.999997$。\n因为 $0.999997 \\ge 0.999$，所以 $k_{\\text{br}}=9$ 足够。\n因此，最小的整数值是 $k_{\\text{br}} = 9$。\n\n**第 3 部分：计算溢出频率**\n\n原始宽度是 $k_{\\text{add}}=13$。新的宽度是 $k_{\\text{add}}' = k_{\\text{add}} - 2 = 13 - 2 = 11$。\n溢出频率是一个常量 $C$ *不可*用 11 位字段编码的概率。\n$P(\\text{溢出}) = 1 - P(\\text{可编码对于 } k_{\\text{add}}'=11)$。\n对于 $k_{\\text{add}}'=11$，可编码范围是 $[-2^{10}, 2^{10}-1] = [-1024, 1023]$。\n$P(\\text{可编码对于 } k_{\\text{add}}'=11) = 0.5 \\cdot P(X \\le 1023) + 0.5 \\cdot P(X \\le 1024)$。\n\n首先，计算 $P(X \\le 1023)$：\n$P(X \\le 1023) = 0.50 \\cdot P(X \\le 1023 | U_1) + 0.35 \\cdot P(X \\le 1023 | U_2) + 0.15 \\cdot P(X \\le 1023 | U_3)$。\n$P(X \\le 1023 | U_1) = 1$。\n$P(X \\le 1023 | U_2) = 1$。\n$P(X \\le 1023 | U_3) = \\frac{1023 - 256 + 1}{3840} = \\frac{768}{3840} = \\frac{1}{5} = 0.2$。\n$P(X \\le 1023) = 0.50(1) + 0.35(1) + 0.15(0.2) = 0.85 + 0.03 = 0.88$。\n\n接下来，计算 $P(X \\le 1024)$：\n$P(X \\le 1024) = 0.85 + 0.15 \\cdot P(X \\le 1024 | U_3) = 0.85 + 0.15 \\left(\\frac{1024 - 256 + 1}{3840}\\right) = 0.85 + 0.15 \\left(\\frac{769}{3840}\\right)$。\n$P(X \\le 1024) = 0.85 + \\frac{115.35}{3840} = 0.85 + 0.0300390625 = 0.8800390625$。\n\n现在，计算总的可编码概率：\n$P(\\text{可编码}) = 0.5(0.88) + 0.5(0.8800390625) = 0.44 + 0.44001953125 = 0.88001953125$。\n\n溢出频率是：\n$P(\\text{溢出}) = 1 - P(\\text{可编码}) = 1 - 0.88001953125 = 0.11998046875$。\n\n问题要求四舍五入到四位有效数字。\n$0.11998046875 \\approx 0.1200$。\n\n所需的三个值是 $k_{\\text{add}}=13$，$k_{\\text{br}}=9$ 和溢出频率 $0.1200$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n13 & 9 & 0.1200\n\\end{pmatrix}\n}\n$$", "id": "3650299"}]}