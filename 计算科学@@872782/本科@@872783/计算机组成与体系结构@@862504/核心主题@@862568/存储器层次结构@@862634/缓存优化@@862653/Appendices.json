{"hands_on_practices": [{"introduction": "这项实践探讨了存储器级并行（Memory-Level Parallelism, $MLP$）的基本概念。通过分析处理器设计中一个经典的挑战——指针追逐（pointer-chasing）工作负载，你将理解真数据依赖（true data dependencies）如何限制性能，以及非阻塞缓存（non-blocking caches）和内容导向预取器（content-directed prefetchers）等硬件特性如何克服这些限制。这个练习对于培养对内存密集型应用性能瓶颈的直观理解至关重要。[@problem_id:3625656]", "problem": "一个单线程程序在一个包含 $N$ 个节点的单向链表上执行指针追逐。每个节点位于其自己的缓存行中，其地址数据依赖于前一个节点中的指针值，并且程序以没有空间局部性的对抗性顺序访问节点。在每次迭代中，程序从同一缓存行加载指向下一个节点的指针和一个值，每个节点最多导致一次行填充。处理器是一个乱序（OoO）核心，其发射宽度为 $W$，具有足够大的重排序缓冲，以及一个可以为阻塞式或非阻塞式的一级（L1）数据缓存。非阻塞式L1缓存有 $M$ 个缺失状态保持寄存器（MSHR）。对于此工作负载，二级（L2）缓存是冷的，所有L1缓存缺失都将访问动态随机存取存储器（DRAM）。假设命中延迟与缺失服务时间相比可以忽略不计，因此执行时间主要由缓存缺失决定。将内存级并行（MLP）定义为在稳态执行期间，并发未完成的（outstanding）不同缓存缺失请求的平均数量。\n\n考虑三种配置：\n- 基准阻塞式L1缓存（无MSHR）。\n- 非阻塞式L1缓存，具有 $M \\ge 2$ 个MSHR，无预取。\n- 非阻塞式L1缓存，具有 $M \\ge 4$ 个MSHR和一个内容导向预取器，该预取器在收到节点的缓存行后，会读取下一指针字段，并通过递归地跟随下一指针，为未来的节点维持最多 $P$ 个未完成的预取（假设预取是准确和及时的，并且可以分配MSHR）。\n\n下列哪些陈述是正确的？\n\nA. 在具有 $M \\ge 2$ 的非阻塞、无预取配置中，指针追逐循环期间的最大稳态MLP为 $1$。\n\nB. 在具有内容导向预取器和 $M \\ge 4$ 的非阻塞配置中，如果预取器可以保持最多 $3$ 个未来节点在处理中（即 $P=3$），则最大稳态MLP可以超过 $1$。\n\nC. 对于此工作负载，一个简单的下一行预取器（顺序行预读）通常会提供与内容导向预取器相同的MLP提升。\n\nD. 在没有任何预取的情况下，从阻塞式L1缓存切换到具有 $M \\ge 8$ 的非阻塞式L1缓存，会严格增加此指针追逐工作负载的稳态MLP。\n\nE. 对于一个可以维持最多 $P$ 个未完成预取的准确、及时的内容导向预取器和具有 $M$ 个MSHR的非阻塞缓存，稳态MLP的上限为 $\\min(M, P+1)$。", "solution": "该问题陈述经审慎分析后被认定为有效。它在科学上基于计算机组成和体系结构的原理，问题提出得当，并包含足够的信息以进行严谨的分析。所描述的工作负载——指针追逐，是用于研究内存级并行（MLP）以及先进处理器和内存系统特性有效性的经典案例。\n\n问题的核心在于一个真数据依赖：第 $i+1$ 次迭代中加载操作的内存地址是第 $i$ 次迭代中加载操作的结果。假设当前节点的地址存储在寄存器（例如 `r0`）中。程序执行像 `ld r1, [r0]` 这样的指令来获取指向下一个节点的指针。下一次迭代将使用 `r1` 中的值作为其加载操作的地址。这创建了一个串行依赖链：$\\text{load}(\\text{Node}_i) \\to \\text{Address}(\\text{Node}_{i+1}) \\to \\text{load}(\\text{Node}_{i+1}) \\to \\dots$。\n\n一个乱序（OoO）处理器本身无法打破这种依赖关系。它可以执行其他独立的指令，但在包含 $\\text{Node}_i$ 的缓存行被取回并且用于获取指针的加载指令完成之前，它无法开始对 $\\text{Node}_{i+1}$ 的内存访问。\n\n我们将内存级并行（MLP）定义为并发未完成的缓存缺失的平均数量。我们将基于这些原则分析每种配置的MLP。\n\n### 选项评估\n\n**A. 在具有 $M \\ge 2$ 的非阻塞、无预取配置中，指针追逐循环期间的最大稳态MLP为 $1$。**\n\n在此配置中，处理器有一个非阻塞式一级（L1）缓存，它有 $M \\ge 2$ 个缺失状态保持寄存器（MSHR），但没有预取器。当对 $\\text{Node}_i$ 的加载发生缓存缺失时，会分配一个MSHR并将请求发送到内存。因为处理器是非阻塞式的，它不必完全停顿。然而，由于指针链的真数据依赖，处理器无法计算出 $\\text{Node}_{i+1}$ 的地址，因此无法发出链中的下一个加载指令。它必须等待当前对 $\\text{Node}_i$ 的缺失得到服务。因此，对于此依赖链，在任何给定时间只能有一个缓存缺失在处理中。多个MSHR（$M \\ge 2$）的可用性是无关紧要的，因为处理器的指令流一次只能为指针链生成一个缺失请求。因此，MLP被限制为 $1$。\n\n结论：**正确**。\n\n**B. 在具有内容导向预取器和 $M \\ge 4$ 的非阻塞配置中，如果预取器可以保持最多 $3$ 个未来节点在处理中（即 $P=3$），则最大稳态MLP可以超过 $1$。**\n\n内容导向预取器规避了处理器的依赖限制。这个硬件单元可以在缓存行从内存到达时检查其内容。在收到 $\\text{Node}_i$ 的缓存行后，预取器提取指向 $\\text{Node}_{i+1}$ 的指针，并为其发出一个预取请求。这可以递归地进行。凭借维持 $P=3$ 个未完成预取的能力，预取器可以在处理器仍在等待或处理 $\\text{Node}_i$ 的同时，为 $\\text{Node}_{i+1}$、$\\text{Node}_{i+2}$ 和 $\\text{Node}_{i+3}$ 发出请求。除了这 $3$ 个预取请求之外，还有处理器自身对当前节点的按需请求。这意味着最多可以有 $1+P = 1+3=4$ 个不同的缓存缺失并发未完成。这种并行级别需要至少 $4$ 个MSHR，这一条件由给定的 $M \\ge 4$ 满足。由于最高可达到 $4$ 的MLP是可能的，所以MLP肯定可以超过 $1$。\n\n结论：**正确**。\n\n**C. 对于此工作负载，一个简单的下一行预取器（顺序行预读）通常会提供与内容导向预取器相同的MLP提升。**\n\n下一行预取器基于空间局部性的假设进行操作。它在访问地址 $A$ 之后预取地址为 $A+L$ 的缓存行，其中 $L$ 是缓存行大小。问题陈述指明链表节点是以“没有空间局部性的对抗性顺序”被访问的。这意味着 $\\text{Node}_{i+1}$ 的内存位置相对于 $\\text{Node}_i$ 的位置没有一个固定的、可预测的偏移量。因此，下一行预取器会持续预取不正确和无用的数据，无法提供性能增益，并可能通过缓存污染和带宽浪费造成损害。相比之下，内容导向预取器是专门为这种基于指针的结构设计的，并且会非常有效。关于它们的MLP提升会相同的陈述是错误的。\n\n结论：**不正确**。\n\n**D. 在没有任何预取的情况下，从阻塞式L1缓存切换到具有 $M \\ge 8$ 的非阻塞式L1缓存，会严格增加此指针追逐工作负载的稳态MLP。**\n\n在具有阻塞式L1缓存的基准配置中，任何缺失都会使处理器完全停顿。只有一个内存请求可以处于未完成状态。MLP恰好为 $1$。正如在对选项A的分析中确定的，在*没有预取器*的非阻塞配置中，指针追逐的真数据依赖同样将MLP限制为 $1$。在当前的缺失请求解决之前，处理器无法生成下一个缺失请求。因此，对于这个特定的工作负载，从阻塞式缓存（MLP = $1$）切换到非阻塞式缓存（MLP = $1$）不会导致MLP的增加。该陈述声称有*严格*增加，这是错误的。\n\n结论：**不正确**。\n\n**E. 对于一个可以维持最多 $P$ 个未完成预取的准确、及时的内容导向预取器和具有 $M$ 个MSHR的非阻塞缓存，稳态MLP的上限为 $\\min(M, P+1)$。**\n\n最大可实现的MLP受到两个因素的制约：可以生成的请求数量和可用于跟踪这些请求的硬件资源数量。\n1.  **请求生成限制**：处理器本身为其正在处理的当前节点发出一个按需请求。内容导向预取器可以向前看，并为后续节点发出最多 $P$ 个额外的预取请求。总共，系统最多可以为指针链生成 $P+1$ 个并发缺失请求。因此，$\\text{MLP} \\le P+1$。\n2.  **资源限制**：每个未完成的缓存缺失都需要一个MSHR来跟踪其状态。有 $M$ 个MSHR可用，系统物理上最多可以处理 $M$ 个并发缺失。因此，$\\text{MLP} \\le M$。\n\n结合这两个约束，实际的MLP受限于两者中的较小值。MLP既不能超过系统可以生成的请求数量，也不能超过硬件可以跟踪的请求数量。因此，稳态MLP的上限为 $\\min(M, P+1)$。\n\n结论：**正确**。", "answer": "$$\\boxed{ABE}$$", "id": "3625656"}, {"introduction": "在理解了存储器级并行（$MLP$）的概念之后，本练习提供了一种量化方法来配置必要的硬件资源。你将运用排队论中的利特尔法则（Little's Law），计算为支持目标内存带宽所需的缺失状态保持寄存器（Miss Status Holding Registers, MSHRs）的数量。这项实践连接了理论性能目标与具体的硬件设计参数。[@problem_id:3625723]", "problem": "一个单核处理器，其配有一个非阻塞一级（L1）数据缓存，使用一个未命中状态保持寄存器（MSHR）阵列来跟踪在途的缓存未命中。它还包括一个连接到 L1 的小型受害者缓存以减少冲突未命中，以及一个发出推测性读取请求的基于步长的预取器。下层存储系统是位于二级（L2）缓存之后的动态随机存取存储器（DRAM），端到端的平均未命中服务时间为 $L$。\n\n当访问大小为 $S$ 字节的连续缓存行时，内存控制器提供持续读取带宽 $B$。为确保 L1 缓存能够产生足够的并发未命中，以维持等于带宽限制速率的目标缓存行完成率，系统必须配置足够多的 MSHR，使得平均未完成的未命中数量等于或超过由目标到达率和服务时间所隐含的并发性。\n\n从排队论中针对稳定系统的第一性原理结果（利特尔法则）出发，推导一个关系式，将平均未完成的缓存未命中数量（即有效的内存级并行，MLP）与未命中的到达率以及平均未命中服务时间联系起来。然后，使用此关系式计算必须配置的 MSHR 的最小整数数量，记为 $N$，以使 L1 能够维持带宽限制的目标到达率。\n\n假设以下参数：\n- 平均端到端未命中服务时间 $L = 110 \\,\\text{ns}$，\n- 持续 DRAM 读取带宽 $B = 51.2 \\,\\text{GB/s}$，\n- 缓存行大小 $S = 64 \\,\\text{B}$。\n\n忽略排队引起的延迟膨胀，并假设由于对同一缓存行的同时请求而发生的请求合并不会改变维持目标吞吐量所需的并发性，因为 MSHR 跟踪的是不同的在途缓存行。精确计算 $N$ 为满足带宽限制的目标到达率所隐含的并发性的最小整数。最终答案以一个无单位的整数表示。", "solution": "非阻塞一级（L1）缓存使用一个未命中状态保持寄存器（MSHR）阵列来跟踪那些缓存对下层存储系统有未完成未命中的在途缓存行。有效的内存级并行（MLP）是这类在途未命中的平均数量。\n\n我们从利特尔法则开始，这是排队论中一个基础且被广泛验证的结果。对于一个稳定系统，若进入服务设施的到达率为 $\\lambda$，在设施中的平均时间为 $W$，则设施中的平均任务数由下式给出\n$$\nN_{\\text{avg}} = \\lambda W.\n$$\n在缓存未命中的背景下，“任务”是流向更低层级内存并花费平均时间 $L$ 被服务的缓存行未命中。平均未完成的未命中数量等于有效的 MLP。因此，\n$$\n\\text{MLP} = \\lambda L.\n$$\n一个非阻塞缓存需要至少与平均未完成的不同缓存未命中数量一样多的未命中状态保持寄存器（MSHR），以避免因跟踪资源不足而导致的停顿。因此，所需的 MSHR 的最小整数数量为\n$$\nN = \\left\\lceil \\lambda L \\right\\rceil.\n$$\n\n问题指出目标到达率受带宽限制。如果持续内存带宽为 $B$，每次未命中传输 $S$ 字节，则以“行/秒”为单位的目标到达率为\n$$\n\\lambda_{\\text{target}} = \\frac{B}{S}.\n$$\n我们现在代入给定的参数：\n- $B = 51.2 \\,\\text{GB/s} = 51.2 \\times 10^{9} \\,\\text{B/s}$，\n- $S = 64 \\,\\text{B}$，\n- $L = 110 \\,\\text{ns} = 110 \\times 10^{-9} \\,\\text{s}$。\n\n计算目标到达率：\n$$\n\\lambda_{\\text{target}} = \\frac{51.2 \\times 10^{9}}{64} = 0.8 \\times 10^{9} = 8.0 \\times 10^{8} \\,\\text{lines/s}.\n$$\n应用利特尔法则以获得所需的平均并发性：\n$$\n\\lambda_{\\text{target}} L = \\left(8.0 \\times 10^{8}\\right)\\left(110 \\times 10^{-9}\\right) = 8.0 \\times 110 \\times 10^{8-9} = 880 \\times 10^{-1} = 88.\n$$\n因为 $N$ 必须是整数，且在这种情况下我们计算出了一个精确值，所以所需的 MSHR 的最小整数数量是\n$$\nN = 88.\n$$\n\n最后，关于请求合并：当多个处理器侧的请求针对同一缓存行时，合并会减少未完成的不同缓存行的数量，但维持每秒 $\\lambda_{\\text{target}}$ 行的吞吐量所需的并发性，严格由不同内存操作的数量及其服务时间 $L$ 决定。因此，结果 $N = \\left\\lceil \\lambda_{\\text{target}} L \\right\\rceil$ 正确地捕捉了维持目标带宽限制到达率所需的最小 MSHR 数量。", "answer": "$$\\boxed{88}$$", "id": "3625723"}, {"introduction": "在理解了如何启用和支持并行性之后，下一步是评估一项优化的质量及其整体影响。本练习将指导你为一个带有预取器的系统推导一个详细的平均内存访问时间（Average Memory Access Time, $AMAT$）模型，该模型会考虑预取器的准确率和覆盖率。然后，你将使用这个模型来确定最优的预取策略，这是性能分析和系统调优中的一项关键技能。[@problem_id:3625661]", "problem": "一个单发射处理器使用一个非阻塞一级数据缓存 (L1)，该缓存具有八个缺失状态处理寄存器 (MSHRs) 和一个小型全相联牺牲缓存。设平均内存访问时间 (AMAT) 定义为每次内存访问的期望延迟，根据基本原理计算，其值为命中延迟加上缺失率乘以期望缺失服务时间。非阻塞特性确保了独立的命中可以继续进行，而无需等待未完成的缺失，因此命中和缺失的贡献在期望上可以被视为可加的。\n\n假设如下：\n- L1 命中时间为 $t_{hit}$。\n- L1 命中率为 $h_{1}$，因此 L1 缺失率为 $1 - h_{1}$。\n- 在发生 L1 缺失的条件下，没有任何预取辅助时的平均服务时间（在考虑了牺牲缓存避免某些主存访问的效果后）为 $t_{miss}$。\n- 一个流预取器发出预取，这些预取有两个质量参数：预取覆盖率 $c \\in [0,1]$ 和预取准确率 $a \\in [0,1]$。覆盖率 $c$ 是 L1 缺失中，针对该缓存行的预取被足够早地发出以产生作用的比例；准确率 $a$ 是在这些被覆盖的情况中，对应缓存在被驱逐前实际被使用的比例。\n- 当一次缺失被覆盖且预取是准确的，由于该缓存行已驻留在邻近的层级（例如，牺牲缓存或二级缓存），该缺失平均在 $t_{pf\\_hit}$ 时间内被服务。\n- 当一次缺失被覆盖但预取不准确时，错误的预取会造成干扰，表现为请求缺失服务路径中的一个额外污染代价 $t_{pf\\_pollute}$（例如，由于有用的缓存行被替换或带宽争用）。在这种情况下，请求缺失仍然会产生 $t_{miss}$ 的延迟，再加上额外的代价 $t_{pf\\_pollute}$。\n\n从上述定义出发，不使用任何预先推导的性能公式，通过对由覆盖率和准确率参数所隐含的互斥缺失结果求取适当的期望，推导出用 $t_{hit}$、$h_{1}$、$t_{miss}$、$t_{pf\\_hit}$、$t_{pf\\_pollute}$、$a$ 和 $c$ 表示的 $AMAT$ 表达式。然后，使用您推导出的表达式，确定在 $[0,1]$ 范围内的 $a$ 和 $c$ 的值，以最小化以下测量延迟下的 $AMAT$：\n- $t_{hit} = 4$ 周期，\n- $h_{1} = 0.92$，\n- $t_{miss} = 50$ 周期，\n- $t_{pf\\_hit} = 12$ 周期，\n- $t_{pf\\_pollute} = 8$ 周期。\n\n将您的最终 $(a, c)$ 答案四舍五入到四位有效数字。$a$ 和 $c$ 是在 $[0,1]$ 范围内的无量纲概率，因此不需要单位。", "solution": "首先根据指定标准对问题进行验证。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 处理器：单发射，非阻塞一级数据缓存 (L1)。\n- 缺失状态处理寄存器 (MSHRs)：$8$ 个。\n- 存在一个小型全相联牺牲缓存。\n- 平均内存访问时间 (AMAT) 定义：$AMAT = \\text{命中延迟} + (\\text{缺失率} \\times \\text{期望缺失服务时间})$。\n- L1 命中时间：$t_{hit}$。\n- L1 命中率：$h_{1}$。\n- L1 缺失率：$1 - h_{1}$。\n- 无预取辅助时的平均缺失服务时间：$t_{miss}$。\n- 预取覆盖率：$c \\in [0,1]$。\n- 预取准确率：$a \\in [0,1]$。\n- 被覆盖且准确的预取的缺失服务时间：$t_{pf\\_hit}$。\n- 被覆盖但不准确的预取的缺失服务时间：$t_{miss} + t_{pf\\_pollute}$，其中 $t_{pf\\_pollute}$ 是一个额外的代价。\n- 用于最小化的数值：\n    - $t_{hit} = 4$ 周期\n    - $h_1 = 0.92$\n    - $t_{miss} = 50$ 周期\n    - $t_{pf\\_hit} = 12$ 周期\n    - $t_{pf\\_pollute} = 8$ 周期\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学性：** 该问题使用了计算机体系结构中用于缓存性能分析的标准术语和模型，包括 AMAT、非阻塞缓存、预取、覆盖率和准确率。该模型是一个用于性能估计的有效且常见的简化模型。\n- **适定性：** 该问题提供了一个明确的目标：首先，推导 AMAT 的公式；其次，找到最小化该公式的参数。所有必需的符号和数值数据都已提供。关于 MSHR 数量和牺牲缓存类型的信息为非阻塞特性和基线 $t_{miss}$ 提供了背景，但这些值并非推导所直接需要，这是可以接受的。\n- **客观性：** 问题使用精确、无偏见的技术语言陈述。\n- **其他缺陷：** 该问题没有违反任何其他列出的无效性标准。它是一致的、可形式化的，并提出了一个基于所推导模型的、重要但可解的优化任务。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将提供解答。\n\n### 推导与求解\n\n平均内存访问时间 ($AMAT$) 根据基本原理定义为 L1 命中时间与缺失代价之和。缺失的代价是 L1 缺失率乘以服务一次缺失的有效平均时间。\n\n$$AMAT = t_{hit} + (1 - h_1) \\cdot T_{miss\\_effective}$$\n\n推导的核心是确定 $T_{miss\\_effective}$ 的表达式，即考虑预取器影响下 L1 缺失的平均服务时间。根据所提供的覆盖率 ($c$) 和准确率 ($a$) 的定义，一个 L1 缺失事件可以划分为三个互斥的结果：\n\n1.  **未覆盖的缺失：** 预取器没有为缺失的缓存行发出预取。在发生 L1 缺失的条件下，这种情况发生的概率为 $(1 - c)$。此情况的服务时间为 $t_{miss}$。\n2.  **被覆盖且准确的缺失：** 预取器足够早地发出了正确的预取。一次缺失被覆盖的概率是 $c$，在被覆盖的条件下，预取准确的概率是 $a$。此结果的联合概率是 $c \\cdot a$。此情况的服务时间为 $t_{pf\\_hit}$。\n3.  **被覆盖但不准确的缺失：** 预取器发出了不正确的预取。一次缺失被覆盖的概率是 $c$，预取不准确的概率（在被覆盖的条件下）是 $(1 - a)$。联合概率是 $c \\cdot (1 - a)$。此情况的服务时间包括基本缺失时间和污染代价，总计为 $t_{miss} + t_{pf\\_pollute}$。\n\n根据全期望定律，$T_{miss\\_effective}$ 是这三个不相交结果的服务时间的加权平均值：\n\n$$T_{miss\\_effective} = P(\\text{uncovered}) \\cdot t_{miss} + P(\\text{covered, accurate}) \\cdot t_{pf\\_hit} + P(\\text{covered, inaccurate}) \\cdot (t_{miss} + t_{pf\\_pollute})$$\n\n代入概率和延迟：\n\n$$T_{miss\\_effective} = (1 - c)t_{miss} + (c \\cdot a)t_{pf\\_hit} + c(1 - a)(t_{miss} + t_{pf\\_pollute})$$\n\n现在，我们将 $T_{miss\\_effective}$ 的这个表达式代回 AMAT 方程，以获得用给定参数表示的 $AMAT$ 的完整表达式：\n\n$$AMAT(a, c) = t_{hit} + (1 - h_1) \\left[ (1 - c)t_{miss} + cat_{pf\\_hit} + c(1 - a)(t_{miss} + t_{pf\\_pollute}) \\right]$$\n\n这就完成了问题的第一部分。为了简化最小化步骤，我们可以通过提出因子 $c$ 来重新整理 $T_{miss\\_effective}$ 的表达式：\n\n$$T_{miss\\_effective} = t_{miss} - c \\cdot t_{miss} + cat_{pf\\_hit} + c(t_{miss} + t_{pf\\_pollute}) - ca(t_{miss} + t_{pf\\_pollute})$$\n$$T_{miss\\_effective} = t_{miss} + c[-t_{miss} + at_{pf\\_hit} + (t_{miss} + t_{pf\\_pollute}) - a(t_{miss} + t_{pf\\_pollute})]$$\n$$T_{miss\\_effective} = t_{miss} + c[at_{pf\\_hit} + t_{pf\\_pollute} - at_{miss} - at_{pf\\_pollute}]$$\n$$T_{miss\\_effective} = t_{miss} + c[t_{pf\\_pollute} + a(t_{pf\\_hit} - t_{miss} - t_{pf\\_pollute})]$$\n\n问题的第二部分要求找到使 $AMAT$ 最小化的 $a \\in [0,1]$ 和 $c \\in [0,1]$ 的值。由于 $t_{hit}$ 和 $(1-h_1)$ 是正常数，最小化 $AMAT$ 等价于最小化 $T_{miss\\_effective}$。又因为 $t_{miss}$ 是一个常数，这又等价于最小化以下项：\n\n$$f(a, c) = c[t_{pf\\_pollute} + a(t_{pf\\_hit} - t_{miss} - t_{pf\\_pollute})]$$\n\n我们现在代入给定的数值：$t_{miss} = 50$, $t_{pf\\_hit} = 12$, 以及 $t_{pf\\_pollute} = 8$。\n\n$$t_{pf\\_hit} - t_{miss} - t_{pf\\_pollute} = 12 - 50 - 8 = -46$$\n\n需要最小化的表达式变为：\n\n$$f(a, c) = c[8 + a(-46)] = c(8 - 46a)$$\n\n我们需要在单位正方形域 $(a,c) \\in [0,1] \\times [0,1]$ 上找到 $f(a, c)$ 的最小值。\n\n函数 $f(a,c)$ 关于 $a$ 和 $c$ 都是线性的。为了找到它的最小值，我们分析它的行为。让我们分析 $(8 - 46a)$ 这一项。这是关于 $a$ 的一个严格递减函数。\n-   当 $a=0$ 时，该项为 $8$。\n-   当 $a=1$ 时，该项为 $8 - 46 = -38$。\n\n$f(a,c)$ 的值取决于 $(8 - 46a)$ 的符号：\n-   如果 $(8 - 46a) > 0$（即 $a  8/46$），该项为正。为了最小化乘积 $c(8-46a)$，我们必须为 $c$ 选择最小可能的值，即 $c=0$。在这种情况下，$f(a,0) = 0$。\n-   如果 $(8 - 46a)  0$（即 $a > 8/46$），该项为负。为了通过使其尽可能地负来最小化乘积，我们必须为 $c$ 选择最大可能的值，即 $c=1$。在这种情况下，$f(a,1) = 8 - 46a$。当 $a$ 最大化时，即在 $a=1$ 时，此函数最小化，得到 $f(1,1) = 8 - 46 = -38$。\n\n比较在每个区域可达到的最小值，我们得到当 $a \\le 8/46$ 时最小值为 $0$（通过 $c=0$ 实现），当 $a > 8/46$ 时最小值为 $-38$（在点 $(a,c)=(1,1)$ 处实现）。因此，整个域上的全局最小值是 $-38$，它在 $a=1$ 和 $c=1$ 时出现。\n\n这意味着当预取器的准确率完美 ($a=1$) 并且它覆盖了每一次缺失 ($c=1$) 时，预取器最有效。考虑到给定的参数，这在直觉上是合理的；一次准确预取的收益（$t_{miss} - t_{pf\\_hit} = 50-12=38$ 周期）远大于一次不准确预取的代价（$t_{pf\\_pollute}=8$ 周期），这使得激进的、高质量的预取变得非常可取。\n\n问题要求将 $a$ 和 $c$ 的值四舍五入到四位有效数字。\n$a = 1.000$\n$c = 1.000$", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n1.000  1.000\n\\end{pmatrix}\n}\n$$", "id": "3625661"}]}