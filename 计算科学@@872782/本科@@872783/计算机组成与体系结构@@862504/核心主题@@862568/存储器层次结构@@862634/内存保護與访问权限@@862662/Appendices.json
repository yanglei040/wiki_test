{"hands_on_practices": [{"introduction": "要真正理解内存保护，我们必须从硬件的视角开始。这个练习模拟了内存管理单元（MMU）的核心功能：检查每次内存操作的访问权限（读、写、执行），并在违反规则时触发故障。通过追踪随时间变化的权限，您将计算由此产生的故障，从而对这一基本机制获得具体的理解。[@problem_id:3658221]", "problem": "一个计算机系统中的单个虚拟内存页面由页表项中维护的三个权限位保护：读位 $r$、写位 $w$ 和执行位 $x$。内存管理单元（MMU）强制执行这些权限：当且仅当 $r$ 被设置时，才允许内存读取；当且仅当 $w$ 被设置时，才允许内存写入；当且仅当 $x$ 被设置时，才允许指令获取（执行）。任何未被当前权限位允许的尝试操作都会导致保护异常（故障）。假设权限更改是原子的，并在指定时间立即生效，没有缓存延迟。\n\n在时间 $t_0$，权限设置为 $(r, w, x)$，并尝试了 $5$ 次读取、$9$ 次写入和 $7$ 次指令获取。\n在时间 $t_1$，权限更新为 $(r, \\neg w, \\neg x)$，并尝试了 $11$ 次读取、$4$ 次写入和 $6$ 次指令获取。\n在时间 $t_2$，权限更新为 $(\\neg r, \\neg w, \\neg x)$，并尝试了 $3$ 次读取、$2$ 次写入和 $1$ 次指令获取。\n\n计算从 $t_0$ 到 $t_2$ 产生的保护故障总数。", "solution": "问题陈述内部一致，科学上基于计算机体系结构原理，且问题定义明确。提供了解答唯一解所需的所有数据和条件。因此，该问题是有效的，我们可以进行分析。\n\n问题要求计算在一系列由变化的权限集控制的内存访问尝试中产生的保护故障总数。问题的核心在于内存管理单元（MMU）强制执行的逻辑规则。\n\n让我们形式化权限位的状态。我们可以将权限集表示为一个向量 $(r, w, x)$，其中如果权限被授予（设置），则该位为 $1$，如果被拒绝（未设置，或 $\\neg$），则为 $0$。三种操作类型是读取、写入和指令获取（执行）。\n\n执行规则如下：\n1.  当且仅当 $r=1$ 时，读取操作被允许。当 $r=0$ 时尝试读取会导致故障。\n2.  当且仅当 $w=1$ 时，写入操作被允许。当 $w=0$ 时尝试写入会导致故障。\n3.  当且仅当 $x=1$ 时，执行操作（指令获取）被允许。当 $x=0$ 时尝试执行会导致故障。\n\n问题指出，在每个时间点 $t_i$（其中 $i \\in \\{0, 1, 2\\}$），权限会被更新，并尝试一批操作。对于给定的操作类型，如果相应的权限位为 $0$，则故障数等于尝试次数；如果权限位为 $1$，则故障数为零。\n\n设 $F_i$ 为时间 $t_i$ 的故障总数。设 $(r_i, w_i, x_i)$ 为时间 $t_i$ 的权限状态。设 $A_i, B_i, C_i$ 分别为在时间 $t_i$ 尝试的读取、写入和执行次数。\n\n在时间 $t_i$ 每种操作类型的故障数可以表示为：\n- 读取故障: $F_{read, i} = A_i \\cdot (1 - r_i)$\n- 写入故障: $F_{write, i} = B_i \\cdot (1 - w_i)$\n- 执行故障: $F_{exec, i} = C_i \\cdot (1 - x_i)$\n\n在时间 $t_i$ 的总故障数是 $F_i = F_{read, i} + F_{write, i} + F_{exec, i}$。所有时间点的总故障数是 $F_{total} = F_0 + F_1 + F_2$。\n\n我们现在将分析每个时间点的事件。\n\n**时间 $t_0$ 的分析：**\n- 权限被设置为 $(r, w, x)$。在我们的二进制表示法中，这是状态 $(r_0, w_0, x_0) = (1, 1, 1)$。\n-\n  - 读取权限被授予 ($r_0=1$)。\n  - 写入权限被授予 ($w_0=1$)。\n  - 执行权限被授予 ($x_0=1$)。\n- 尝试的操作是 $A_0=5$ 次读取，$B_0=9$ 次写入，以及 $C_0=7$ 次指令获取。\n- 我们计算在 $t_0$ 时的故障：\n  - 读取故障: $F_{read, 0} = A_0 (1-r_0) = 5(1-1) = 5 \\cdot 0 = 0$。\n  - 写入故障: $F_{write, 0} = B_0 (1-w_0) = 9(1-1) = 9 \\cdot 0 = 0$。\n  - 执行故障: $F_{exec, 0} = C_0 (1-x_0) = 7(1-1) = 7 \\cdot 0 = 0$。\n- 在 $t_0$ 时的故障总数为 $F_0 = 0 + 0 + 0 = 0$。\n\n**时间 $t_1$ 的分析：**\n- 权限更新为 $(r, \\neg w, \\neg x)$。在我们的二进制表示法中，这是状态 $(r_1, w_1, x_1) = (1, 0, 0)$。\n-\n  - 读取权限被授予 ($r_1=1$)。\n  - 写入权限被拒绝 ($w_1=0$)。\n  - 执行权限被拒绝 ($x_1=0$)。\n- 尝试的操作是 $A_1=11$ 次读取，$B_1=4$ 次写入，以及 $C_1=6$ 次指令获取。\n- 我们计算在 $t_1$ 时的故障：\n  - 读取故障: $F_{read, 1} = A_1 (1-r_1) = 11(1-1) = 11 \\cdot 0 = 0$。\n  - 写入故障: $F_{write, 1} = B_1 (1-w_1) = 4(1-0) = 4 \\cdot 1 = 4$。\n  - 执行故障: $F_{exec, 1} = C_1 (1-x_1) = 6(1-0) = 6 \\cdot 1 = 6$。\n- 在 $t_1$ 时的故障总数为 $F_1 = 0 + 4 + 6 = 10$。\n\n**时间 $t_2$ 的分析：**\n- 权限更新为 $(\\neg r, \\neg w, \\neg x)$。在我们的二进制表示法中，这是状态 $(r_2, w_2, x_2) = (0, 0, 0)$。\n-\n  - 读取权限被拒绝 ($r_2=0$)。\n  - 写入权限被拒绝 ($w_2=0$)。\n  - 执行权限被拒绝 ($x_2=0$)。\n- 尝试的操作是 $A_2=3$ 次读取，$B_2=2$ 次写入，以及 $C_2=1$ 次指令获取。\n- 我们计算在 $t_2$ 时的故障：\n  - 读取故障: $F_{read, 2} = A_2 (1-r_2) = 3(1-0) = 3 \\cdot 1 = 3$。\n  - 写入故障: $F_{write, 2} = B_2 (1-w_2) = 2(1-0) = 2 \\cdot 1 = 2$。\n  - 执行故障: $F_{exec, 2} = C_2 (1-x_2) = 1(1-0) = 1 \\cdot 1 = 1$。\n- 在 $t_2$ 时的故障总数为 $F_2 = 3 + 2 + 1 = 6$。\n\n**总故障计算：**\n为了求出故障总数，我们将每个时间点的故障数相加：\n$$F_{total} = F_0 + F_1 + F_2$$\n$$F_{total} = 0 + 10 + 6 = 16$$\n因此，在三个时间点内，总共将产生 $16$ 个保护故障。", "answer": "$$\n\\boxed{16}\n$$", "id": "3658221"}, {"introduction": "内存保护的范畴超越了单个页面；操作系统必须强制执行系统级的策略以确保安全性和稳定性。本实践将系统状态抽象为一个权限矩阵，并引入了关键的安全不变量，如“单一写入者”和“写异或执行”（W^X）。您的任务是以事务方式修改权限，这将挑战您思考为维护系统完整性所需的操作顺序。[@problem_id:3658191]", "problem": "考虑一个通过权限矩阵 $M \\in \\mathbb{Z}^{n \\times m}$ 来实施进程-页面内存保护的系统，其中条目 $M_{ij}$ 编码了进程 $i$ 对页面 $j$ 的访问权限。每个条目是集合 $\\{r,w,x\\}$ 上的一个位掩码，其中 $r \\mapsto 1$，$w \\mapsto 2$，$x \\mapsto 4$。权限通过按位加法进行组合，因此，例如，$r \\wedge w$ 编码为 $3$，$r \\wedge x$ 编码为 $5$。该矩阵当前为\n$$\nM=\n\\begin{pmatrix}\n5  1  0 \\\\\n1  3  4 \\\\\n0  0  0 \\\\\n1  1  0\n\\end{pmatrix},\n$$\n行由进程 $i \\in \\{1,2,3,4\\}$ 索引，列由页面 $j \\in \\{1,2,3\\}$ 索引。两个系统不变量必须始终保持：\n\n1. 每页单写入者：对于每个页面 $j$，\n$$\n\\sum_{i=1}^{n} \\mathbf{1}_{\\{w \\in M_{ij}\\}} \\leq 1,\n$$\n其中，如果 $M_{ij}$ 中存在 $w$，则 $\\mathbf{1}_{\\{w \\in M_{ij}\\}}$ 等于 $1$，否则为 $0$。\n\n2. 写异或执行 (W^X) 策略：如果对于页面 $j$ 存在任何进程 $i$ 使得 $x \\in M_{ij}$，那么对于所有进程 $k$，\n$$\nw \\notin M_{kj}.\n$$\n\n一个工作流要求进程 $p=3$ 仅在一次事务处理期间，在页面 $q=2$ 上获得 $(r,w)$ 访问权限。访问权限可以通过切换条目 $M_{ij}$ 中的单个权限位来更改；一次单位切换会将单个 $M_{ij}$ 中的一个权限 $\\{r,w,x\\}$ 从存在变为不存在，反之亦然。事务完成后，必须恢复原始矩阵。确定所需的最小总位切换次数，以 (i) 达到一个状态，在该状态下进程 $3$ 在页面 $2$ 上具有 $(r,w)$ 权限，同时两个不变量都保持成立，然后 (ii) 将矩阵恢复到其原始状态，并确保在整个变化序列中两个不变量始终保持成立。请以位切换的整数计数形式提供最终答案。无需四舍五入。", "solution": "用户想要解决一个关于计算机系统中内存保护的问题。\n\n### 步骤1：提取已知条件\n- **权限矩阵**：一个矩阵 $M \\in \\mathbb{Z}^{n \\times m}$，其中 $n=4$ 且 $m=3$。行索引为进程 $i \\in \\{1,2,3,4\\}$，列索引为页面 $j \\in \\{1,2,3\\}$。\n- **初始矩阵状态**：\n$$\nM=\n\\begin{pmatrix}\n5  1  0 \\\\\n1  3  4 \\\\\n0  0  0 \\\\\n1  1  0\n\\end{pmatrix}\n$$\n- **权限编码**：访问权限是集合 $\\{r,w,x\\}$ 上的位掩码。\n  - $r \\mapsto 1$ (读)\n  - $w \\mapsto 2$ (写)\n  - $x \\mapsto 4$ (执行)\n  - 权限通过按位加法组合。例如：$r \\wedge w \\rightarrow 1+2=3$。\n- **不变量1 (每页单写入者)**：对于每个页面 $j$，$\\sum_{i=1}^{n} \\mathbf{1}_{\\{w \\in M_{ij}\\}} \\leq 1$，其中 $\\mathbf{1}_{\\{w \\in M_{ij}\\}}$ 是一个指示函数，如果进程 $i$ 对页面 $j$ 有写权限，则为 $1$，否则为 $0$。\n- **不变量2 (写异或执行, W^X)**：对于任何页面 $j$，如果任何进程 $i$ 具有执行权限 ($x \\in M_{ij}$)，那么任何进程 $k$ 都不能有写权限 (对于所有 $k$，$w \\notin M_{kj}$)。\n- **任务**：一个工作流要求进程 $p=3$ 在页面 $q=2$ 上获得 $(r,w)$ 访问权限。\n- **操作**：通过在单个条目 $M_{ij}$ 中切换单个权限位（$r$、$w$ 或 $x$）来更改访问权限。\n- **要求**：该过程包括两个阶段：(i) 达到目标状态，即进程 $3$ 在页面 $2$ 上拥有 $(r,w)$ 权限，以及 (ii) 将矩阵恢复到其原始状态。\n- **约束**：在整个变化序列中，两个不变量必须始终保持。\n- **目标**：确定两个阶段合共的最小总位切换次数。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学性**：该问题使用了计算机组成和体系结构的基础概念，特别是操作系统的内存管理。权限矩阵、读/写/执行位、单写入者策略和 W^X 安全策略都是标准的、成熟的概念。该问题在科学上是合理的。\n2.  **良构性**：该问题提供了一个清晰的初始状态、一个明确定义的目标条件、一组特定的允许操作（位切换）和明确的约束（不变量）。目标是找到最小值，这使得该问题成为一个定义明确的优化任务。\n3.  **客观性**：问题陈述使用了精确的数学和技术语言，没有主观性或歧义。\n4.  **完整性与一致性**：问题是自洽的。所有必要的数据和规则都已提供。已知条件中没有明显的矛盾。矩阵 $M$ 的初始状态与不变量一致，这将在解题过程中得到验证。\n5.  **可行性**：该设置是对真实世界系统的一个简化但现实的抽象。操作和约束在逻辑上是一致的。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它具有科学性、良构性、客观性和自洽性。我将继续进行解答。\n\n### 详细解法\n\n首先，我们将初始权限矩阵 $M$ 从其整数表示解码为权限集合。权限对应于矩阵条目二进制表示中的位：$x \\leftrightarrow 2^2=4$，$w \\leftrightarrow 2^1=2$，$r \\leftrightarrow 2^0=1$。\n初始矩阵为：\n$$\nM=\n\\begin{pmatrix}\n5  1  0 \\\\\n1  3  4 \\\\\n0  0  0 \\\\\n1  1  0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\{r,x\\}  \\{r\\}  \\{\\} \\\\\n\\{r\\}  \\{r,w\\}  \\{x\\} \\\\\n\\{\\}  \\{\\}  \\{\\} \\\\\n\\{r\\}  \\{r\\}  \\{\\}\n\\end{pmatrix}\n$$\n我们验证初始状态是否满足两个不变量。\n- **不变量1 (单写入者)**：\n  - 页面 $j=1$：没有进程拥有写 ($w$) 权限。写入者总数为 $0 \\leq 1$。成立。\n  - 页面 $j=2$：只有进程 $i=2$ 拥有写 ($w$) 权限 ($M_{22}=3$)。写入者总数为 $1 \\leq 1$。成立。\n  - 页面 $j=3$：没有进程拥有写 ($w$) 权限。写入者总数为 $0 \\leq 1$。成立。\n- **不变量2 (W^X)**：\n  - 页面 $j=1$：进程 $i=1$ 拥有执行 ($x$) 权限。我们检查此页面的写权限。没有进程对页面 $1$ 有写权限。成立。\n  - 页面 $j=2$：没有进程拥有执行 ($x$) 权限。该不变量不证自明地成立。成立。\n  - 页面 $j=3$：进程 $i=2$ 拥有执行 ($x$) 权限。我们检查此页面的写权限。没有进程对页面 $3$ 有写权限。成立。\n\n初始配置是有效的。问题包括两部分：获取新权限，然后恢复原始权限。\n\n#### 第 (i) 部分：为进程3获取权限\n\n目标是让进程 $p=3$ 在页面 $q=2$ 上获得 $(r,w)$ 访问权限。这意味着条目 $M_{32}$ 必须更改为表示 $\\{r,w\\}$，对应整数值 $1+2=3$。\n- 初始值为 $M_{32}=0$。要将其更改为 $3$，必须切换两个位：读位（'r'）必须开启，写位（'w'）必须开启。这至少需要在 $M_{32}$ 上进行 $2$ 次位切换。\n\n我们必须分析这些切换对不变量的后果，这些不变量必须始终保持。\n- 对 $M_{32}$ 进行 'r' 位切换不影响任何一个不变量。\n- 对 $M_{32}$ 进行 'w' 位切换是关键。最初，进程 $2$ 对页面 $2$ 拥有写权限 ($w \\in M_{22}$)。如果我们也要授予进程 $3$ 写权限 ($w \\in M_{32}$)，页面 $2$ 将有两个写入者（进程 $2$ 和 $3$）。这将违反不变量1 ($\\sum \\mathbf{1}_{w} = 2  1$)。\n- 为了“始终”满足不变量1，当进程 $2$ 仍持有写权限时，不能将写权限授予进程 $3$。因此，在为 $M_{32}$ 开启 'w' 位之前，我们必须先为 $M_{22}$ 关闭 'w' 位。\n- $M_{22}$ 的初始值为 $3$ ($\\{r,w\\}$)。关闭 'w' 位会将其更改为 $1$ ($\\{r\\}$)。这是 $1$ 次额外的位切换。\n\n因此，达到满足请求的有效状态所需的最小切换集合是：\n1.  为 $M_{32}$ 开启 'r' 位。\n2.  为 $M_{32}$ 开启 'w' 位。\n3.  为 $M_{22}$ 关闭 'w' 位。\n\n这总共是 $3$ 次切换。让我们验证是否存在一个有效的序列。设矩阵 $M$ 经过 $k$ 次切换后的状态为 $M^{(k)}$。\n- $M^{(0)} = M$。有效状态。\n- **切换1**：为 $M_{22}$ 关闭 'w' 位。$M_{22}$ 从 $3$ 变为 $1$。现在，没有进程对页面 $2$ 有写访问权限。两个不变量都成立。\n- **切换2**：为 $M_{32}$ 开启 'r' 位。$M_{32}$ 从 $0$ 变为 $1$。页面 $2$ 上仍然没有写入者。两个不变量都成立。\n- **切换3**：为 $M_{32}$ 开启 'w' 位。$M_{32}$ 从 $1$ 变为 $3$。现在，进程 $3$ 是页面 $2$ 的唯一写入者。两个不变量都成立。\n这部分的目标状态在 $3$ 次切换后有效达成。这是可能的最小值，因为所有 $3$ 次切换都被证明是必需的。\n\n第 (i) 部分的最小切换次数 = $3$。\n\n#### 第 (ii) 部分：恢复原始状态\n\n进程 $3$ 的事务现已完成，矩阵必须恢复到其原始状态。这部分的起始状态是第 (i) 部分产生的矩阵，其中 $M_{22}=1$ 和 $M_{32}=3$。目标是原始矩阵 $M$，其中 $M_{22}=3$ 和 $M_{32}=0$。\n\n所需的变化与第 (i) 部分相反：\n- 对于 $M_{32}$：从 $3$ ($\\{r,w\\}$) 变为 $0$ ($\\{\\}$) 。这需要关闭 'r' 位和 'w' 位。（$2$ 次切换）。\n- 对于 $M_{22}$：从 $1$ ($\\{r\\}$) 变为 $3$ ($\\{r,w\\}$)。这需要开启 'w' 位。（$1$ 次切换）。\n\n这同样至少需要 $3$ 次切换。关于不变量1的相同逻辑适用。\n- 当前，进程 $3$ 对页面 $2$ 有写权限 ($w \\in M_{32}$)。要将写权限交还给进程 $2$ ($w \\in M_{22}$)，我们不能有存在两个写入者的中间状态。\n- 因此，我们必须先从进程 $3$ 撤销写权限，然后再授予进程 $2$。为 $M_{32}$ 关闭 'w' 位的操作必须在为 $M_{22}$ 开启 'w' 位的操作之前。\n\n这 $3$ 次最小切换的一个有效序列是：\n- 这部分的初始状态：$M_{22}=1$, $M_{32}=3$。有效状态。\n- **切换1**：为 $M_{32}$ 关闭 'w' 位。$M_{32}$ 从 $3$ 变为 $1$。现在，没有进程对页面 $2$ 有写访问权限。不变量成立。\n- **切换2**：为 $M_{22}$ 开启 'w' 位。$M_{22}$ 从 $1$ 变为 $3$。现在，进程 $2$ 是页面 $2$ 的唯一写入者。不变量成立。\n- **切换3**：为 $M_{32}$ 关闭 'r' 位。$M_{32}$ 从 $1$ 变为 $0$。矩阵现在恢复到其原始状态 $M$。不变量成立。\n恢复过程在 $3$ 次切换后完成。这是最小的。\n\n第 (ii) 部分的最小切换次数 = $3$。\n\n#### 总切换次数\n\n最小总位切换次数是两部分切换次数之和。\n总切换次数 = (第 i 部分的切换次数) + (第 ii 部分的切换次数) = $3 + 3 = 6$。", "answer": "$$\\boxed{6}$$", "id": "3658191"}]}