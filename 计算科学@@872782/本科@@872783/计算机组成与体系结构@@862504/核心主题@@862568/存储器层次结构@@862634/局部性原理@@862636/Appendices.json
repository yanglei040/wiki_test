{"hands_on_practices": [{"introduction": "理解数据在内存中的排列方式是利用空间局部性的第一步。本练习对遍历二维数组的两种常见方式进行了清晰的量化比较，展示了忽视底层行主序存储的访问模式如何导致缓存未命中率的急剧增加。通过解决这个问题[@problem_id:3668437]，你将对不良数据访问策略的性能成本建立起基本直觉。", "problem": "一个二维标量元素数组以行主序存储在主内存中。该数组有 $W$ 列和 $H$ 行，每个元素占用 $E$ 字节。数组的基地址与缓存行边界对齐。\n\n系统有一个单级、直接映射的数据缓存，有 $S$ 个组，行大小为 $B$ 字节，因此总缓存容量为 $S B$ 字节。缓存初始为空，且没有硬件预取。考虑只读遍历，每个元素恰好访问一次。\n\n考虑两种遍历顺序：\n1. 按行遍历：对于从 $0$ 到 $H-1$ 的每一行 $r$，访问从 $0$ 到 $W-1$ 的列 $c$。\n2. 按列遍历：对于从 $0$ 到 $W-1$ 的每一列 $c$，访问从 $0$ 到 $H-1$ 的行 $r$。\n\n假设以下现实约束成立：\n- $E$ 整除 $B$，因此 $L \\equiv B/E$ 是每个缓存行中的整数个元素。\n- $W \\geq L$ 且 $W$ 是 $L$ 的倍数。\n- $W E$ 是 $S B$ 的倍数。\n- $H \\geq 2$。\n\n从行主序布局和直接映射缓存索引的基本定义出发，确定按列遍历所产生的缓存未命中总数与按行遍历所产生的缓存未命中总数的比率，用 $B$ 和 $E$ 以最简闭式形式表示。将你的最终答案表示为单个简化的符号表达式，不带单位。无需四舍五入。", "solution": "用户提供的问题经评估是有效的。它在科学上基于计算机体系结构的原理，问题提出得很好，有唯一且可确定的解，并以客观、正式的语言陈述。所提供的约束虽然创建了一个特定场景，但内部一致且物理上合理。因此，我将进行正式的解答。\n\n设数组的基地址为 $A_0$。问题陈述该数组以行主序存储，其基地址与缓存行边界对齐。单个元素的大小为 $E$ 字节。数组有 $H$ 行和 $W$ 列。位于行 $r$ 和列 $c$ 的元素的地址（使用基于 $0$ 的索引，因此 $0 \\le r  H$ 且 $0 \\le c  W$）由下式给出：\n$$\n\\text{Addr}(r, c) = A_0 + (r \\times W + c) \\times E\n$$\n缓存是直接映射的，有 $S$ 个组，行大小为 $B$ 字节。单个缓存行能容纳的元素数量为 $L = B/E$，已知这是一个整数。一个内存地址 $\\text{addr}$ 被映射到一个缓存组索引，如下所示：\n$$\n\\text{Index}(\\text{addr}) = \\left\\lfloor \\frac{\\text{addr}}{B} \\right\\rfloor \\pmod{S}\n$$\n由于基地址 $A_0$ 与缓存行边界对齐，因此 $A_0$ 是 $B$ 的倍数。设 $A_0 = m \\times B$，其中 $m$ 是某个非负整数。\n\n首先，我们分析按行遍历的缓存未命中数，记为 $M_{\\text{row}}$。访问模式是顺序通过内存，在移动到下一行之前扫描给定行的所有列。\n$$\n\\text{for } r = 0 \\text{ to } H-1 \\\\\n\\quad \\text{for } c = 0 \\text{ to } W-1 \\\\\n\\qquad \\text{access element at } (r, c)\n$$\n缓存初始为空。第一次访问 $\\text{Addr}(0,0)$ 是一次强制性未命中（compulsory miss）。这次未命中导致包含第 $0$ 行前 $L$ 个元素（即元素 $(0,0)$ 到 $(0,L-1)$）的缓存行被加载到缓存中。随后的 $L-1$ 次对元素 $(0,1)$ 到 $(0,L-1)$ 的访问都将是命中，因为它们现在存在于缓存中。这是空间局部性（spatial locality）的直接结果。\n\n对元素 $(0,L)$ 的访问是下一个数据块的第一个元素，它将导致另一次未命中。这种模式会重复。每访问 $L$ 个连续的元素，第一次访问导致一次未命中，随后的 $L-1$ 次访问导致命中。\n数组中的元素总数为 $H \\times W$。由于遍历是完全顺序的，并且每次未命中都会带入 $L$ 个元素，因此未命中总数是元素总数除以每个缓存行的元素数。\n$$\nM_{\\text{row}} = \\frac{H \\times W}{L}\n$$\n给定的约束确保了这个简单模型成立，并且不会因行之间的冲突未命中（conflict misses）而复杂化。$W$ 是 $L$ 的倍数的约束保证了行不会共享缓存行。\n\n接下来，我们分析按列遍历的缓存未命中数，记为 $M_{\\text{col}}$。访问模式是：\n$$\n\\text{for } c = 0 \\text{ to } W-1 \\\\\n\\quad \\text{for } r = 0 \\text{to } H-1 \\\\\n\\qquad \\text{access element at } (r, c)\n$$\n为了分析未命中，我们必须确定每次访问映射到哪个缓存组。元素 $(r,c)$ 的地址索引为：\n$$\n\\text{Index}(r, c) = \\left\\lfloor \\frac{A_0 + (rW + c)E}{B} \\right\\rfloor \\pmod{S} = \\left\\lfloor \\frac{mB + (rW+c)E}{B} \\right\\rfloor \\pmod{S} = \\left( m + \\left\\lfloor \\frac{(rW+c)E}{B} \\right\\rfloor \\right) \\pmod{S}\n$$\n使用 $L = B/E$，这变为：\n$$\n\\text{Index}(r, c) = \\left( m + \\left\\lfloor \\frac{rW+c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n现在，我们应用给定的约束，即 $W \\times E$ 是 $S \\times B$ 的倍数。设 $W \\times E = q \\times S \\times B$，其中 $q \\ge 1$ 是某个整数。\n代入 $E=B/L$，我们得到 $W \\times (B/L) = q \\times S \\times B$。两边除以 $B$（非零），得到 $W/L = qS$。这意味着每行的缓存行数 $W/L$ 是缓存组数 $S$ 的整数倍。\n设 $n = W/L=qS$。我们可以写成 $W = nL = (qS)L$。\n将此代入索引公式：\n$$\n\\text{Index}(r, c) = \\left( m + \\left\\lfloor \\frac{r(qS)L+c}{L} \\right\\rfloor \\right) \\pmod{S} = \\left( m + \\left\\lfloor rqS + \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n由于 $r$、$q$ 和 $S$ 都是整数，所以 $rqS$ 是一个整数。因此：\n$$\n\\text.Index}(r, c) = \\left( m + rqS + \\left\\lfloor \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n由于 $rqS$ 是 $S$ 的倍数，它对模 $S$ 的和的贡献为 $0$。因此，索引简化为：\n$$\n\\text.Index}(r, c) = \\left( m + \\left\\lfloor \\frac{c}{L} \\right\\rfloor \\right) \\pmod{S}\n$$\n这是一个关键结果：元素 $(r,c)$ 的缓存组索引只取决于其列 $c$，而与行 $r$ 无关。同一列中的所有元素 $\\text{A}[0][c], \\text{A}[1][c], \\dots, \\text{A}[H-1][c]$ 都映射到完全相同的缓存组。\n\n现在，考虑按列遍历。外层循环固定一列 $c$，内层循环遍历行 $r = 0, 1, \\dots, H-1$。\n对于固定的列 $c$，所有 $H$ 次访问都映射到同一个组。让我们追踪内层循环：\n1.  访问 $\\text{A}[0][c]$：这次访问是一次未命中。（缓存要么是空的，要么包含来自前一个外层循环迭代的不同行和列块的行）。一个包含来自第 $0$ 行元素的缓存行被加载到确定的组中。\n2.  访问 $\\text{A}[1][c]$：这次访问映射到同一个组。然而，元素 $\\text{A}[1][c]$ 位于一个不同的缓存行中（对应于第 $1$ 行的行）。因为缓存是直接映射的，这个新行必须替换刚刚加载的第 $0$ 行的行。这是一次冲突未命中（conflict miss）。\n3.  访问 $\\text{A}[2][c]$：这次访问也映射到同一个组，需要来自第 $2$ 行的行，因此会驱逐来自第 $1$ 行的行。这是另一次冲突未命中。\n\n这种驱逐模式对内层循环中的所有 $H$ 次访问都持续存在。对于任何给定的列 $c$， $H$ 次访问中的每一次都会导致一次缓存未命中。由于有 $W$ 列，未命中总数为：\n$$\nM_{\\text{col}} = H \\times W\n$$\n问题要求按列遍历所产生的缓存未命中总数与按行遍历所产生的缓存未命中总数的比率。\n$$\n\\text{Ratio} = \\frac{M_{\\text{col}}}{M_{\\text{row}}} = \\frac{H \\times W}{\\frac{H \\times W}{L}} = L\n$$\n最后，我们使用定义 $L=B/E$，用 $B$ 和 $E$ 来表示这个结果。\n$$\n\\text{Ratio} = \\frac{B}{E}\n$$\n这个结果量化了与内存存储布局相悖的访问模式的性能影响，特别是在引发严重缓存冲突的条件下。", "answer": "$$\\boxed{\\frac{B}{E}}$$", "id": "3668437"}, {"introduction": "优秀的软件设计常常需要在权衡中优化性能。本实践将从分析现有访问模式转向主动构建数据结构以实现更好的缓存利用。你将探索一种通过填充数据结构来将关键的“热”字段对齐到单个缓存行内的技术，并量化其性能增益和内存开销[@problem_id:3668467]，这是一个在系统编程中常见的权衡问题。", "problem": "一位系统设计师正在优化一个记录数组，以利用单级缓存中的局部性原理。该缓存以大小为 $64$ 字节的固定大小缓存行来获取和存储数据。考虑一种记录类型，其字段按以下顺序占用内存：一个 $24$ 字节的非热点数据块，一个 $8$ 字节的热点字段 $H_{1}$，一个 $8$ 字节的热点字段 $H_{2}$，一个 $4$ 字节的热点字段 $H_{3}$，以及一个 $4$ 字节的非热点字段。假设这种排序已经满足了标准的对齐约束，因此没有额外填充的记录大小恰好是 $48$ 字节，并且三个热点字段在每个记录内连续布局，跨度为 $20$ 字节。\n\n数组的基地址与 $64$ 字节边界对齐。应用程序在一个大型数组上均匀地执行随机元素访问，并且对于每个被访问的元素，都会读取所有三个热点字段 $H_{1}$、$H_{2}$ 和 $H_{3}$。在这些条件下，由于记录大小 $48$ 和缓存行大小 $64$ 的最大公约数为 $16$，记录的起始偏移量模 $64$ 以相等的频率在集合 $\\{0,16,32,48\\}$ 中取值。\n\n设计师考虑对记录进行填充以增加空间局部性，通过添加 $16$ 字节的填充，使得每个记录的大小恰好变为 $64$ 字节，同时保持热点字段的相对位置连续。数组的分配方式使得每个记录都从一个缓存行边界开始。\n\n将此工作负载的空间局部性利用率定义为：对于被访问的记录，能够通过单次缓存行获取来满足的热点字段读取操作的比例。将内存开销分数定义为每个记录增加的填充与原始记录大小的比率。\n\n仅使用上述事实以及时间和空间局部性的定义，推导填充前和填充后的期望空间局部性利用率，计算由填充引入的内存开销分数，然后计算每开销效益指标\n$$\\eta=\\frac{\\text{(填充后的空间局部性利用率)}-\\text{(填充前的空间局部性利用率)}}{\\text{内存开销分数}}。$$\n将 $\\eta$ 的最终值四舍五入到四位有效数字。将最终答案表示为无量纲数。", "solution": "用户请求对所提供的问题陈述进行验证，如果问题被认为是有效的，则随后提供一个完整的解决方案。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 缓存行大小: $64$ 字节\n- 原始记录布局:\n  - 非热点数据块: $24$ 字节\n  - 热点字段 $H_{1}$: $8$ 字节\n  - 热点字段 $H_{2}$: $8$ 字节\n  - 热点字段 $H_{3}$: $4$ 字节\n  - 非热点字段: $4$ 字节\n- 原始记录大小: $48$ 字节\n- 热点字段 ($H_{1}$, $H_{2}$, $H_{3}$) 是连续的，跨度为 $20$ 字节。\n- 数组基地址与 $64$ 字节边界对齐。\n- 对于一个被访问的元素，所有三个热点字段都被读取。\n- 记录的起始偏移量模 $64$ 以相等的频率为 $\\{0, 16, 32, 48\\}$。\n- 建议的修改：为每个记录添加 $16$ 字节的填充。\n- 新的记录大小: $64$ 字节。\n- 新布局：每个记录从一个缓存行边界开始。\n- 空间局部性利用率的定义：能够通过单次缓存行获取满足的热点字段读取操作的比例。\n- 内存开销分数的定义：每个记录增加的填充与原始记录大小的比率。\n- 要计算的指标: $\\eta=\\frac{\\text{(填充后的空间局部性利用率)}-\\text{(填充前的空间局部性利用率)}}{\\text{内存开销分数}}$。\n- 最终答案精度：四舍五入到四位有效数字。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于计算机体系结构的原理，特别是存储器层次结构、缓存性能和数据结构对齐。空间局部性、缓存行、填充和性能权衡等概念是标准的，并且得到了准确的表述。\n- **良构性：** 所有必要的参数都已定义（缓存行大小、记录大小、数据布局、工作负载）。要计算的指标的定义清晰，并允许唯一的解。\n- **客观性：** 该问题以精确的技术语言陈述，没有歧义或主观声明。\n- **完整性和一致性：** 所提供的数据是自洽的。关于记录起始偏移量模 $64$ 为 $\\{0, 16, 32, 48\\}$ 的陈述，是一个从 $64$ 字节边界开始的 $48$ 字节记录数组的正确推论，因为 $\\text{gcd}(48, 64) = 16$ 且偏移量的周期长度为 $64/16 = 4$。问题是明确规定的。\n- **现实性和可行性：** 缓存行和数据字段的字节大小在现代计算系统中是典型的。该优化场景是系统设计师面临的一个实际问题。\n\n**步骤 3：结论和行动**\n问题是有效的。它在科学上是合理的、良构的、客观的和完整的。将提供详细的解决方案。\n\n### 解答\n\n目标是计算每开销效益指标 $\\eta$，其定义为：\n$$\n\\eta = \\frac{U_{after} - U_{before}}{O_{mem}}\n$$\n其中 $U_{before}$ 是填充前的空间局部性利用率，$U_{after}$ 是填充后的利用率，而 $O_{mem}$ 是内存开销分数。我们将分别计算这三个量。\n\n**1. 内存开销分数 ($O_{mem}$)**\n内存开销分数定义为每个记录增加的填充与原始记录大小的比率。\n原始记录大小为 $48$ 字节。\n增加的填充为 $16$ 字节。\n因此，内存开销分数为：\n$$\nO_{mem} = \\frac{\\text{增加的填充}}{\\text{原始记录大小}} = \\frac{16}{48} = \\frac{1}{3}\n$$\n\n**2. 填充后的空间局部性利用率 ($U_{after}$)**\n填充后，记录大小变为 $48 + 16 = 64$ 字节。问题陈述指出，数组的分配方式使得每个记录都从一个缓存行边界开始。由于缓存行大小也是 $64$ 字节，每个记录恰好完美地占用一个缓存行。\n热点字段（$H_{1}$、$H_{2}$ 和 $H_{3}$）形成一个 $8+8+4 = 20$ 字节的连续块。由于这个块是 $64$ 字节记录的一个内部部分，它必须完全包含在存放该记录的单个缓存行内。\n因此，对记录热点字段的任何访问都将通过单次缓存行获取来满足。\n所以，所有访问的空间局部性利用率均为 $1$。\n$$\nU_{after} = 1\n$$\n\n**3. 填充前的空间局部性利用率 ($U_{before}$)**\n填充前，记录大小为 $48$ 字节。热点字段形成一个 $20$ 字节的块。在记录内部，这些字段之前是一个 $24$ 字节的非热点数据块。因此，一个记录的热点数据从记录开始处的偏移量 $24$ 字节开始，到偏移量 $24 + 20 - 1 = 43$ 字节结束。\n\n问题陈述指出，由于 $48$ 字节的记录大小和 $64$ 字节的数组对齐，记录的起始地址模缓存行大小 $64$，可以以相等的概率取四个值之一：$S \\in \\{0, 16, 32, 48\\}$。每个值出现的概率为 $\\frac{1}{4}$。\n\n如果整个 $20$ 字节的热点块都落入一个 $64$ 字节的缓存行内，则实现了空间局部性利用。这种情况发生在热点块不跨越缓存行边界时。假设一个记录从地址 $A$ 开始。热点数据位于绝对地址范围 $[A+24, A+43]$。这个范围跨越边界当且仅当 $\\lfloor \\frac{A+24}{64} \\rfloor \\neq \\lfloor \\frac{A+43}{64} \\rfloor$。\n让我们为每个可能的起始偏移量 $S = A \\pmod{64}$ 分析这种情况。\n相对于一个缓存行边界，热点数据从相对偏移量 $S+24$ 开始，到相对偏移量 $S+43$ 结束。如果 $\\lfloor \\frac{S+24}{64} \\rfloor = \\lfloor \\frac{S+43}{64} \\rfloor$，则使用单个缓存行。\n\n- **情况 1：$S = 0$**\n  热点数据在缓存行内占据字节偏移量 $[0+24, 0+43] = [24, 43]$。\n  $\\lfloor \\frac{24}{64} \\rfloor = 0$ 且 $\\lfloor \\frac{43}{64} \\rfloor = 0$。数据在一个行内。利用率为 $1$。\n\n- **情况 2：$S = 16$**\n  热点数据在缓存行内占据字节偏移量 $[16+24, 16+43] = [40, 59]$。\n  $\\lfloor \\frac{40}{64} \\rfloor = 0$ 且 $\\lfloor \\frac{59}{64} \\rfloor = 0$。数据在一个行内。利用率为 $1$。\n\n- **情况 3：$S = 32$**\n  热点数据占据字节偏移量 $[32+24, 32+43] = [56, 75]$。\n  $\\lfloor \\frac{56}{64} \\rfloor = 0$ 但是 $\\lfloor \\frac{75}{64} \\rfloor = 1$。数据跨越了第一个缓存行（偏移量 $0-63$）和下一个缓存行（偏移量 $64-127$）之间的边界。需要两次缓存行获取。利用率为 $0$。\n\n- **情况 4：$S = 48$**\n  热点数据占据字节偏移量 $[48+24, 48+43] = [72, 91]$。\n  $\\lfloor \\frac{72}{64} \\rfloor = 1$ 且 $\\lfloor \\frac{91}{64} \\rfloor = 1$。虽然数据与记录的起始不在同一个缓存行中，但整个热点块都包含在*下一个*缓存行内。单次缓存行获取（针对下一个行）就足够了。利用率为 $1$。\n\n期望利用率 $U_{before}$ 是这四种等可能情况的平均值：\n$$\nU_{before} = \\frac{1}{4} \\times (1) + \\frac{1}{4} \\times (1) + \\frac{1}{4} \\times (0) + \\frac{1}{4} \\times (1) = \\frac{3}{4}\n$$\n\n**4. 指标 $\\eta$ 的计算**\n现在我们可以将计算出的值代入 $\\eta$ 的公式中：\n$$\n\\eta = \\frac{U_{after} - U_{before}}{O_{mem}} = \\frac{1 - \\frac{3}{4}}{\\frac{1}{3}} = \\frac{\\frac{1}{4}}{\\frac{1}{3}} = \\frac{1}{4} \\times 3 = \\frac{3}{4}\n$$\n将其转换为小数，$\\eta = 0.75$。问题要求答案四舍五入到四位有效数字。\n$$\n\\eta = 0.7500\n$$", "answer": "$$\\boxed{0.7500}$$", "id": "3668467"}, {"introduction": "虽然LRU（最近最少使用）策略通常是利用时间局部性的良好默认选择，但它并非在所有情况下都是最优的。这个思想实验将挑战你分析一个特定的访问模式，在该模式下LRU策略表现不佳，而看似违反直觉的MRU（最近最常使用）策略却表现出色。通过比较这两种极端情况[@problem_id:3668494]，你将更深刻地理解工作负载与替换策略之间的相互作用是如何决定缓存性能的。", "problem": "一个容量为 $M$ 个块（$M \\geq 2$）、块大小为 $1$ 个项目的全相联缓存被一个单线程程序访问。缓存初始为空。考虑两种替换策略：最近最少使用 (LRU) 和最近最多使用 (MRU)。最近最少使用 (LRU) 策略在发生未命中时，会替换掉自上次访问以来时间最长的块，而最近最多使用 (MRU) 策略在发生未命中时，会替换掉最近访问的块。局部性原理指出，程序倾向于重用时间距离短的数据和指令（时间局部性），并访问邻近的地址（空间局部性）。\n\n构造一个表现出流式传输和轻微时间重用的访问模式，使得 MRU 的性能优于 LRU，然后计算在该模式下，两种策略在一个宏周期内的总未命中次数。使用以下访问模式：\n$$\nS = \\underbrace{(1,2,\\dots,M,A)}_{\\text{cycle}}, \\text{ repeated exactly } (M+1) \\text{ times},\n$$\n其中符号 $1,2,\\dots,M,A$ 表示不同的缓存块，该表示法意味着循环 $(1,2,\\dots,M,A)$ 被连接 $(M+1)$ 次，总共有 $(M+1)^2$ 次访问。符号 $A$ 是一个单一的干扰块，它破坏了在对 $1,2,\\dots,M$ 进行流式处理遍时完美的重用性。\n\n从时间局部性、空间局部性的核心定义以及 LRU 和 MRU 在未命中和命中时的行为出发，首先论证为什么序列 $S$ 体现了流式传输和轻微的时间重用，以及为什么可以预期 MRU 在序列 $S$ 上的性能会优于 LRU。然后，从基本原理出发，不使用任何未经证明的快捷公式，推导出 LRU 和 MRU 在整个序列 $S$ 上发生的确切总缓存未命中次数。\n\n以“LRU 总未命中次数, MRU 总未命中次数”对的形式提供最终答案。无需四舍五入。将最终答案表示为关于 $M$ 的精确符号表达式。", "solution": "该问题是有效的。它在科学上基于计算机体系结构的原理，特别是缓存存储器的组织和性能分析。问题陈述清晰，所有必要的参数（缓存大小、块大小、替换策略、初始状态、访问模式）都已明确定义。目标明确，问题没有歧义或矛盾。\n\n问题的核心是分析两种缓存替换策略——最近最少使用（LRU）和最近最多使用（MRU）——在特定访问模式 $S$ 下的性能。缓存容量为 $M$ 个块，块大小为 $1$ 个项目，且缓存初始为空。策略定义如下：\n- **LRU**：发生缓存未命中时，替换掉最长时间未被访问的块。\n- **MRU**：发生缓存未命中时，替换掉最近被访问的块。\n\n访问模式由序列 $S = (1, 2, \\dots, M, A)$ 精确重复 $(M+1)$ 次给出。这构成了总共 $(M+1) \\times (M+1) = (M+1)^2$ 次内存访问。符号 $1, 2, \\dots, M, A$ 代表 $M+1$ 个不同的内存块。\n\n首先，我们在局部性原理的背景下分析该访问模式。该序列重复访问块集合 $\\{1, 2, \\dots, M, A\\}$。这种重复构成了时间局部性，因为每个块都会随着时间的推移被重用。对于任何给定的块，其重用距离为 $M$ 次访问（例如，块 $1$ 被访问后，接着是 $M$ 个其他不同的块，然后 $1$ 才被再次访问）。子序列 $(1, 2, \\dots, M)$ 是对数据的线性扫描或“流”。干扰块 $A$ 的存在以及循环中唯一块的总数 $M+1$ 大于缓存容量 $M$ 这一事实，造成了缓存争用的情况。这种模式，即一个略大于缓存的循环，是用来展示不同替换策略性能差异的经典例子。由于“抖动”，LRU 预计表现不佳，而 MRU 替换最近项的策略预计能保护较旧的、即将被重用的循环项。\n\n我们现在将从基本原理出发，推导每种策略的总缓存未命中次数。\n\n**最近最少使用 (LRU) 策略分析**\n\nLRU 策略替换访问时间最旧的块。我们追踪序列 $S$ 的执行过程。总访问次数为 $(M+1)^2$。\n\n1.  **初始访问**：前 $M$ 次访问是不同的块 $1, 2, \\dots, M$。由于缓存初始为空，这些都是强制性未命中。\n    -   访问 $1$ 后：缓存 = $\\{1\\}$。未命中次数 = $1$。\n    -   访问 $2$ 后：缓存 = $\\{1, 2\\}$。未命中次数 = $2$。\n    -   ...\n    -   访问 $M$ 后：缓存 = $\\{1, 2, \\dots, M\\}$。未命中次数 = $M$。块按新近度排序，$M$ 是最近的，$1$ 是最旧的。\n\n2.  **首次容量未命中**：第 $(M+1)$ 次访问是块 $A$。块 $A$ 不在缓存中，因此这是一次未命中。缓存已满，必须进行替换。LRU 替换最近最少使用的块，即 $1$。\n    -   访问 $A$ 后：缓存 = $\\{2, 3, \\dots, M, A\\}$。未命中次数 = $M+1$。此时 LRU 块是 $2$。\n\n3.  **抖动行为**：让我们考虑在缓存填满后，访问任意块 $X$ 时缓存的状态。大小为 $M$ 的缓存将包含紧接在 $X$ 之前访问的 $M$ 个块。在我们这个包含 $M+1$ 个不同块的循环模式中，任何给定块 $X$ 之前访问的 $M$ 个块恰好是集合 $\\{1, 2, \\dots, M, A\\} \\setminus \\{X\\}$。因此，在访问块 $X$ 时，它永远不会在缓存中。这对于第一次 $M$ 次强制性未命中之后的所有访问都成立。\n    -   第 $(M+2)$ 次访问是块 $1$（第二个循环的开始）。缓存中包含 $\\{2, 3, \\dots, M, A\\}$。块 $1$ 不存在。这是一次未命中。LRU 块 $2$ 被替换。缓存变为 $\\{3, \\dots, M, A, 1\\}$。\n    -   下一次访问是块 $2$。缓存中包含 $\\{3, \\dots, M, A, 1\\}$。块 $2$ 不存在。这是一次未命中。\n\n这种称为抖动的模式会无限持续下去。每一次访问都会导致一次缓存未命中。由于序列 $S$ 中总共有 $(M+1)^2$ 次访问，因此 LRU 策略的总未命中次数等于总访问次数。\n\nLRU 总未命中次数 = $(M+1)^2 = M^2 + 2M + 1$。\n\n**最近最多使用 (MRU) 策略分析**\n\nMRU 策略替换访问时间最新的块。我们逐个循环地追踪执行过程。\n\n1.  **循环 1**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   前 $M$ 次访问（$1, 2, \\dots, M$）是强制性未命中。此后，缓存包含 $\\{1, 2, \\dots, M\\}$。最近使用的块是 $M$。未命中计数为 $M$。\n    -   第 $(M+1)$ 次访问是块 $A$。这是一次未命中。MRU 替换最近使用的块，即 $M$。缓存变为 $\\{1, 2, \\dots, M-1, A\\}$。新的 MRU 块是 $A$。\n    -   循环 1 的总未命中次数：$M+1$。\n\n2.  **循环 2**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   缓存开始时包含 $\\{1, 2, \\dots, M-1, A\\}$。MRU 块是 $A$。\n    -   访问 $1$：命中。缓存内容不变。新的 MRU 块是 $1$。\n    -   访问 $2$：命中。 ... 新的 MRU 是 $2$。\n    -   ...\n    -   访问 $M-1$：命中。新的 MRU 变为 $M-1$。\n    -   访问 $M$：未命中。块 $M$ 不在缓存中。MRU 替换当前最近使用的块，即 $M-1$。缓存变为 $\\{1, 2, \\dots, M-2, A, M\\}$。新的 MRU 是 $M$。\n    -   访问 $A$：命中。新的 MRU 是 $A$。\n    -   循环 2 的总未命中次数：$1$。\n\n3.  **循环 3**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   缓存开始时包含 $\\{1, 2, \\dots, M-2, A, M\\}$。MRU 块是 $A$。\n    -   访问 $1, ..., M-2$：全部命中。这些访问后，MRU 块是 $M-2$。\n    -   访问 $M-1$：未命中。替换 MRU 块 $M-2$。缓存变为 $\\{1, \\dots, M-3, A, M, M-1\\}$。新的 MRU 是 $M-1$。\n    -   访问 $M$：命中。新的 MRU 是 $M$。\n    -   访问 $A$：命中。新的 MRU 是 $A$。\n    -   循环 3 的总未命中次数：$1$。\n\n一个模式出现了：对于从 $k=2$ 到 $k=M$ 的每个循环 $k$，都恰好有一次未命中。这次未命中发生在对块 $M-(k-2)$ 的访问上。\n\n4.  **循环 2 到 M**：共有 $M-1$ 个这样的循环（从 $k=2$ 到 $k=M$）。每个循环贡献 1 次未命中。\n    -   循环 2 到 M 的总未命中次数：$M-1$。\n    -   我们检查一下循环 $M$ 结束时的状态。未命中的块是 $M-(M-2)=2$。被替换的块是 $1$。缓存将包含 $\\{2, 3, \\dots, M, A\\}$。\n\n5.  **循环 M+1**：访问序列为 $(1, 2, \\dots, M, A)$。\n    -   缓存开始时包含 $\\{2, 3, \\dots, M, A\\}$。前一个循环的 MRU 块是 $A$。\n    -   访问 $1$：未命中。替换 MRU 块 $A$。缓存变为 $\\{2, 3, \\dots, M, 1\\}$。新的 MRU 是 $1$。\n    -   访问 $2$：命中。 ... 新的 MRU 是 $2$。\n    -   ...\n    -   访问 $M$：命中。新的 MRU 是 $M$。\n    -   访问 $A$：未命中。替换 MRU 块 $M$。缓存变为 $\\{2, 3, \\dots, M-1, 1, A\\}$。新的 MRU 是 $A$。\n    -   循环 M+1 的总未命中次数：$2$。\n\n为了得到 MRU 的总未命中次数，我们将所有循环的未命中次数相加。\n-   循环 1 的未命中次数：$M+1$。\n-   循环 2 到 M（共 $M-1$ 个循环）的未命中次数：$(M-1) \\times 1 = M-1$。\n-   循环 M+1 的未命中次数：$2$。\n\nMRU 总未命中次数 = $(M+1) + (M-1) + 2 = 2M + 2$。\n\n比较这两种策略，对于 $M \\geq 2$，LRU 有 $M^2+2M+1$ 次未命中，而 MRU 有 $2M+2$ 次未命中。不等式 $M^2+2M+1 > 2M+2$ 可简化为 $M^2-1 > 0$，即 $(M-1)(M+1) > 0$，这对所有 $M>1$ 都成立。因此，MRU 在此访问模式下的性能明显优于 LRU。\n\n总未命中计数的最终结果是：\n-   LRU 总未命中次数：$M^2+2M+1 = (M+1)^2$\n-   MRU 总未命中次数：$2M+2$", "answer": "$$\n\\boxed{((M+1)^2, 2M+2)}\n$$", "id": "3668494"}]}