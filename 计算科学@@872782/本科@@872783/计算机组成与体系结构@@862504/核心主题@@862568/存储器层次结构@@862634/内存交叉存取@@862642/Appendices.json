{"hands_on_practices": [{"introduction": "这个练习为理解内存交错提供了一个具体的起点。通过追踪单个内存请求从其逻辑地址到特定内存体中的最终目的地的过程，您将练习控制低位交错的基本计算。这有助于巩固核心的地址映射机制。[@problem_id:1941843]", "problem": "一个32位计算机系统实现了一个基于分段的简化内存管理单元 (MMU)。在此方案中，一个逻辑地址由一个段号和一个偏移量组成。物理地址通过将偏移量加到指定段的基地址上来计算。系统的主存采用4路低位交叉编址架构构建，其中内存体被索引为0、1、2和3。对于任意给定的物理地址 `P`，服务该请求的内存体 `B` 由公式 $B = P \\pmod 4$ 确定。\n\n系统的段表部分定义如下：\n- 段0基地址：$2C00A000_{16}$\n- 段1基地址：$A1B2C000_{16}$\n- 段2基地址：$F01D3000_{16}$\n\n一个进程需要访问数据，该数据位于逻辑地址，对应段号为1，偏移量为 $0000F7A6_{16}$。\n\n确定將服务此请求的内存体的索引。请以单个整数形式提供你的答案。", "solution": "在这种分段方案中，逻辑地址通过将偏移量加到所选段的基地址上来转换为物理地址。因此，对于基地址为 $A1B2C000_{16}$、偏移量为 $0000F7A6_{16}$ 的段1，物理地址 $P$ 为\n$$\nP = A1B2C000_{16} + 0000F7A6_{16}.\n$$\n使用16位部分进行相加，以明确显示进位：\n$$\n\\text{low }16\\text{-bit: } C000_{16} + F7A6_{16} = 1B7A6_{16} \\Rightarrow \\text{low }16\\text{-bit of }P = B7A6_{16},\\; \\text{carry } c=1,\n$$\n$$\n\\text{high }16\\text{-bit: } A1B2_{16} + 0000_{16} + c = A1B3_{16}.\n$$\n因此，\n$$\nP = A1B3B7A6_{16}.\n$$\n对于4路低位交叉编址，服务请求的内存体索引由 $B = P \\bmod 4$ 给出。由于模4运算仅取决于最后两位（等效于最后一位十六进制数），而 $P$ 的最后一位十六进制数是 $6$，我们有\n$$\nB = 6 \\bmod 4 = 2.\n$$\n因此，内存体索引为 $2$。", "answer": "$$\\boxed{2}$$", "id": "1941843"}, {"introduction": "除了映射单个地址，交错的真正威力在于提升整体系统吞吐量。这个问题探讨了一个基本的设计权衡：确定维持目标内存请求率所需的最小内存体数量。这个练习揭示了内存体延迟、内存体数量与可实现的最大内存带宽之间的关键联系。[@problem_id:3657527]", "problem": "一个共享主存被组织成 $N$ 个相同的存储体（bank），使用完美的低位交叉编址（low-order interleaving）。从请求发出到准备好接受对该存储体的下一个新请求，每个存储体有固定的服务时间，为 $t_b$ 个处理器周期。假设以下基本事实和条件：\n- 在稳态下，一个独立服务器的最大完成率等于其确定性服务时间的倒数，因此单个存储体每周期最多能完成 $1/t_b$ 个请求。\n- 完美的低位交叉编址将连续的内存块地址均匀分布到 $N$ 个存储体中，只要目标存储体不是正忙的存储体，内存控制器就能每周期调度一个新请求。\n- 不存在其他瓶颈：只要存在可用的存储体，互连和控制器每周期最多可以发出1个请求；除了每个存储体的服务时间外，没有其他存储体冲突；也没有额外的周转或总线开销。\n\n在这些条件下，您希望维持一个稳定的请求到达率，即每周期 $r$ 个请求，并且队列不会无限增长。设每个存储体的服务时间 $t_b = 4$ 个周期。在完美交叉编址和上述假设下，请确定维持速率 $r$ 所需的最小整数存储体数量 $N$，并以 $r$ 的闭式表达式给出。您的最终答案必须是一个解析表达式。不要包含单位。如果需要取整，请确保结果反映了满足要求的最小整数。", "solution": "问题要求在给定每个存储体固定服务时间为 $t_b = 4$ 个周期的情况下，为维持每周期 $r$ 个请求的稳定到达率所需的最小整数存储体数量 $N$。\n\n分析始于系统稳定性的基本条件：为防止队列无限增长，内存系统的最大可持续服务率（我们称之为吞吐量 $T$）必须大于或等于到达率 $r$。\n$$\nT \\ge r\n$$\n\n接下来，我们为系统的最大吞吐量 $T$ 建立一个模型。根据问题描述，吞吐量受到两个主要因素的限制：\n1.  **内存控制器瓶颈**：问题陈述，内存控制器每周期最多可以发出1个请求。这为系统的吞吐量设定了一个上限，无论存储体的数量或其速度如何。\n    $$\n    T \\le 1 \\text{ request/cycle}\n    $$\n    这也意味着，要使问题可解，目标到达率 $r$ 不能超过这个限制，因此我们必须有 $r \\le 1$。\n\n2.  **存储体总带宽**：内存系统由 $N$ 个相同的存储体组成。每个存储体的服务时间为 $t_b$ 个周期。如前所述，单个存储体的最大完成率是其服务时间的倒数，即每周期 $1/t_b$ 个请求。在 $N$ 个存储体并行工作且假设完美交叉编址允许它们独立操作的情况下，它们能提供的理论最大总带宽是它们各自最大速率的总和。\n    $$\n    T \\le N \\times \\frac{1}{t_b} = \\frac{N}{t_b}\n    $$\n\n系统的实际最大吞吐量 $T_{max}$ 是这两个限制因素中的较小者。\n$$\nT_{max} = \\min\\left(1, \\frac{N}{t_b}\\right)\n$$\n\n现在，我们应用稳定性条件，$T_{max} \\ge r$。\n$$\n\\min\\left(1, \\frac{N}{t_b}\\right) \\ge r\n$$\n这个不等式必须成立。它可以分解为两个独立的条件：\n1.  $1 \\ge r$，这是前面提到的对输入速率的约束。\n2.  $\\frac{N}{t_b} \\ge r$。\n\n第二个条件给出了我们需要求解的存储体数量 $N$ 和速率 $r$ 之间的关系。\n$$\n\\frac{N}{t_b} \\ge r\n$$\n两边同乘以 $t_b$（一个正量），我们得到对 $N$ 的最小要求。\n$$\nN \\ge r \\cdot t_b\n$$\n\n问题给出了存储体服务时间的具体值，$t_b = 4$ 个周期。将此值代入不等式：\n$$\nN \\ge r \\cdot 4\n$$\n$$\nN \\ge 4r\n$$\n\n问题要求满足此条件的最小**整数**存储体数量 $N$。对于给定的 $r$ 值，大于或等于实数 $4r$ 的最小整数 $N$，根据定义，是 $4r$ 的上取整（ceiling）。\n因此，所需的最小存储体数量为：\n$$\nN_{min} = \\lceil 4r \\rceil\n$$\n该表达式为任何有效的持续请求速率 $r$（其中 $0  r \\le 1$）提供了最小整数 $N$。例如，如果 $r=0.5$，则 $N_{min}=\\lceil 4 \\times 0.5 \\rceil = \\lceil 2 \\rceil = 2$。如果 $r=1$，则 $N_{min}=\\lceil 4 \\times 1 \\rceil = \\lceil 4 \\rceil = 4$。这与经典结论一致，即存储体数量必须至少等于以周期为单位的存储体延迟，才能完全隐藏延迟并实现每周期1个请求的吞吐量。该公式正确地将此结论推广到速率小于1的情况。", "answer": "$$\n\\boxed{\\lceil 4r \\rceil}\n$$", "id": "3657527"}, {"introduction": "交错内存系统的性能高度依赖于内存访问的模式。这个练习让您扮演性能工程师的角色，任务是找到一个能保证无冲突内存操作的访问步长。这种实践突出了精心的编程如何能够充分利用交错内存体提供的并行性以最大化性能。[@problem_id:3632697]", "problem": "一个中央处理器 (CPU) 执行一个向量 $LOAD$ 指令，该指令从存储在 $n$ 路交叉主存中的一维数组中取回元素。该存储系统的组织方式如下。\n\n- 有 $n$ 个独立的存储体，按连续字的循环交叉方式排列，其中 $n = 12$。\n- 交叉单位是一个大小为 $w$ 字节的字，其中 $w = 8$。\n- 根据跨 $n$ 个存储体的连续字循环交叉的定义，字被依次存放在存储体 0、存储体 1、…、存储体 $n-1$ 中，然后回绕，重复此模式。\n- 向量 $LOAD$ 指令以 $s$ 个字为步长访问元素，从与字大小 $w$ 对齐的基地址 $A_0$ 开始。\n- CPU 为该 $LOAD$ 指令每个周期发出 $W$ 个内存请求，其中 $W = 4$。\n- 每个存储体每个周期最多能接受一个请求，在接受一个请求后，该存储体将保持忙碌 $t_b$ 个周期（包括请求到达的周期），其中 $t_b = 3$。在其忙碌期间，存储体不能接受另一个请求。\n\n从跨存储体字循环交叉的定义和步长寻址的含义出发，首先推导出用 $A$、$w$ 和 $n$ 表示的地址到存储体的映射函数 $b(A)$。然后，仅使用这些基本定义和模运算的标准性质进行推理，确定最小的正整数步长 $s  1$（以字为单位），该步长能保证此向量 $LOAD$ 操作在任何基地址 $A_0$ 下都无存储体冲突。零存储体冲突意味着，在任何 $t_b$ 个连续周期的窗口内，$W \\cdot t_b$ 个同时或最近发出的请求中没有任何两个请求访问同一个存储体。\n\n将最终答案表示为一个整数。无需四舍五入。", "solution": "该问题要求两个结果：首先，推导地址到存储体的映射函数；其次，确定最小的正整数步长 $s  1$，该步长能保证在交叉存储系统上特定的向量加载操作无存储体冲突。\n\n首先，让我们将给定的条件形式化：\n- 存储体数量：$n = 12$。\n- 字大小：$w = 8$ 字节。\n- 交叉方案：连续字的循环交叉。\n- 每个周期发出的内存请求数：$W = 4$。\n- 存储体忙碌时间：$t_b = 3$ 个周期。\n- 向量访问步长：$s$ 个字，其中 $s$ 是一个大于 $1$ 的整数。\n- 基地址 $A_0$ 是字对齐的。\n\n第 1 部分：地址到存储体映射函数 $b(A)$ 的推导\n\n内存是按字交叉的。内存位置的字节地址 $A$ 必须首先转换为字索引。由于字大小为 $w$ 字节且寻址是字对齐的，任何有效的字起始字节地址 $A$ 都是 $w$ 的倍数。与字节地址 $A$ 对应的字索引（我们记作 $i$）由整数除法给出：\n$$ i = \\frac{A}{w} $$\n问题陈述了内存使用跨 $n$ 个存储体的连续字循环交叉。这意味着索引为 $i=0$ 的字存储在存储体 $0$ 中，索引为 $i=1$ 的字在存储体 $1$ 中，...，索引为 $i=n-1$ 的字在存储体 $n-1$ 中。然后该模式重复，所以索引为 $i=n$ 的字在存储体 $0$ 中，依此类推。这种映射由模运算描述。字索引为 $i$ 的字的存储体号 $b(i)$ 是：\n$$ b(i) = i \\pmod{n} $$\n为了找到用字节地址 $A$ 表示的映射函数 $b(A)$，我们将字索引 $i$ 的表达式代入存储体映射函数：\n$$ b(A) = \\left(\\frac{A}{w}\\right) \\pmod{n} $$\n这就是所要求的地址到存储体的映射函数。\n\n第 2 部分：确定实现零存储体冲突的最小步长 $s  1$\n\n向量 $LOAD$ 操作以 $s$ 个字的步长访问元素。CPU 每个周期发出 $W=4$ 个请求。这意味着一个流水线化或并行的访问模式，其中在单个周期内发出的请求对应于以步长 $s$ 分隔的 $W$ 个向量元素。例如，在第一个周期（周期 0），请求的字索引为 $i_0, i_0+s, i_0+2s, \\dots, i_0+(W-1)s$，其中 $i_0 = A_0/w$ 是与基地址 $A_0$ 对应的字索引。在周期 1，请求的字索引为 $i_0+Ws, \\dots, i_0+(2W-1)s$，依此类推。\n\n“零存储体冲突”的条件陈述为：“在任何 $t_b$ 个连续周期的窗口内，$W \\cdot t_b$ 个同时或最近发出的请求中没有任何两个请求访问同一个存储体。”\n让我们分析在 $t_b$ 个周期的窗口内发出的请求，例如，从周期 $0$ 到周期 $t_b-1$。\n- 在周期 $0$，请求的字索引为 $i_0+k \\cdot s$，其中 $k \\in \\{0, 1, \\dots, W-1\\}$。\n- 在周期 $1$，请求的字索引为 $i_0+k \\cdot s$，其中 $k \\in \\{W, W+1, \\dots, 2W-1\\}$。\n- ...\n- 在周期 $t_b-1$，请求的字索引为 $i_0+k \\cdot s$，其中 $k \\in \\{(t_b-1)W, \\dots, t_b W-1\\}$。\n\n此窗口内的总请求数为 $W \\cdot t_b$。在这 $t_b$ 个周期内访问的字的索引相对于访问模式形成了一个连续序列：\n$$ i_k' = i_0 + k \\cdot s \\quad \\text{for } k = 0, 1, 2, \\dots, W \\cdot t_b - 1 $$\n这些请求中每一个的目标存储体号由 $b(i_k') = i_k' \\pmod n$ 给出。\n$$ b_k = (i_0 + k \\cdot s) \\pmod n \\quad \\text{for } k = 0, 1, 2, \\dots, W \\cdot t_b - 1 $$\n零存储体冲突的条件意味着所有这 $W \\cdot t_b$ 个存储体号 $\\{b_0, b_1, \\dots, b_{Wt_b-1}\\}$ 必须是不同的。\n\n让我们代入给定的值：$n = 12$, $W = 4$ 以及 $t_b = 3$。\n窗口内的请求数量为 $W \\cdot t_b = 4 \\times 3 = 12$。\n因此，我们需要 $k = 0, 1, \\dots, 11$ 的 $12$ 个存储体号 $b_k$ 是不同的。\n存储体号由以下序列给出：\n$$ (i_0 \\pmod{12}), ((i_0+s) \\pmod{12}), ((i_0+2s) \\pmod{12}), \\dots, ((i_0+11s) \\pmod{12}) $$\n可用存储体的总数是 $n=12$。因为我们需要访问 $12$ 个不同的存储体，所以被访问的存储体集合必须是所有可用存储体的完整集合，即 $\\{0, 1, 2, \\dots, 11\\}$。\n\n问题要求这个条件在不考虑基地址 $A_0$ 的情况下成立，这意味着它必须对任何起始字索引 $i_0$ 都成立。\n我们正在寻找关于步长 $s$ 的一个条件，使得余数集合 $\\{ (i_0 + k \\cdot s) \\pmod{12} \\mid k = 0, 1, \\dots, 11 \\}$ 对任何整数 $i_0$ 都等于模 12 的所有余数的集合，即 $\\{0, 1, \\dots, 11\\}$。\n\n这是模算术中的一个标准结果。一个长度为 $m$、公差为 $d$ 的算术级数，即 $\\{a, a+d, a+2d, \\dots, a+(m-1)d\\}$，会覆盖模 $m$ 的所有余数，当且仅当公差 $d$ 与模 $m$ 互质。也就是说，$\\gcd(d, m) = 1$。起始值 $a$ 不影响是否生成完整的余数集。\n\n在我们的问题中，起始值是 $a=i_0$，公差是 $d=s$，模是 $m=n=12$。\n因此，无论起始地址如何，保证零存储体冲突的条件是：\n$$ \\gcd(s, n) = 1 $$\n代入 $n=12$，该条件变为：\n$$ \\gcd(s, 12) = 1 $$\n我们被要求找到满足此条件的最小正整数步长 $s > 1$。我们需要找到与 $12$ 互质的最小整数 $s > 1$。$12$ 的质因数分解是 $2^2 \\cdot 3$。一个整数与 $12$ 互质，当且仅当它既不能被 $2$ 整除也不能被 $3$ 整除。让我们测试大于 $1$ 的整数 $s$：\n- 对于 $s=2$: $\\gcd(2, 12) = 2 \\neq 1$。无效。\n- 对于 $s=3$: $\\gcd(3, 12) = 3 \\neq 1$。无效。\n- 对于 $s=4$: $\\gcd(4, 12) = 4 \\neq 1$。无效。\n- 对于 $s=5$：$5$ 是一个质数且不能整除 $12$。所以，$\\gcd(5, 12) = 1$。这是一个有效的步长。\n\n因为我们正在寻找最小的整数 $s > 1$，并且我们已经发现 $s=2, 3, 4$ 无效，所以 $s=5$ 是满足条件的、大于 $1$ 的最小整数。", "answer": "$$\\boxed{5}$$", "id": "3632697"}]}