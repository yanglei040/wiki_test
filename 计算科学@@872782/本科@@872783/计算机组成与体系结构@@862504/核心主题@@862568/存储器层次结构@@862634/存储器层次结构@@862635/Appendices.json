{"hands_on_practices": [{"introduction": "直接映射缓存虽然设计简单、速度快，但可能会遭受“冲突未命中”（conflict miss）的困扰，即多个常用数据项映射到同一缓存行而相互驱逐。本实践练习 [@problem_id:3684789] 展示了一个经典的病态案例，其中特定的内存布局导致了这种“乒乓效应”，从而造成灾难性的性能下降。通过分析内存地址并应用简单的填充技术，你将学会如何识别和解决此类冲突，并深刻体会到数据布局对缓存效率的决定性影响。", "problem": "一个字节寻址系统使用直接映射高速缓存，其总容量为 $C$ 字节，块大小为 $B$ 字节，其中 $C$ 是 $B$ 的整数倍。设缓存行数为 $L = \\frac{C}{B}$。两个数组 $A$ 和 $D$ 各占用恰好 $C$ 字节，并按如下方式布局在主存中：$A$ 的基地址为 $A_{\\mathrm{base}} = 0$，$D$ 的基地址为 $D_{\\mathrm{base}} = C$。每个数组每元素存储一个字节，因此数组 $A$ 的第 $i$ 个元素的地址为 $A_{\\mathrm{base}} + i$，数组 $D$ 的第 $i$ 个元素的地址为 $D_{\\mathrm{base}} + i$。考虑一种交替访问模式，对于所有 $i \\in \\{0, 1, \\dots, C-1\\}$，执行一次对 $A[i]$ 的读取，然后执行一次对 $D[i]$ 的读取。假设高速缓存初始为空。\n\n仅使用直接映射索引的基本定义——即字节地址 $x$ 的缓存行索引由 $\\left\\lfloor \\frac{x}{B} \\right\\rfloor \\bmod L$ 给出——以及强制性未命中的概念，首先推理在给定布局下，上述交替访问模式所导致的高速缓存未命中总数。接下来，提出一种通过仅将 $D$ 的基地址更改为 $D_{\\mathrm{base}}' = C + B$（即在 $A$ 和 $D$ 之间填充 $B$ 字节）来消除病态冲突的重新映射方案，并重新分析在相同交替访问模式下的未命中总数。\n\n由于这种重新映射，总未命中次数的乘法缩减因子是多少？请用一个仅含 $B$ 的封闭形式表达式表示。请以单个符号表达式的形式提供最终答案。无需四舍五入。", "solution": "该问题被认为是有效的，因为它在科学上基于计算机体系结构原理，提法得当且提供了所有必要信息，并且陈述客观。\n\n我们用 $C$ 字节表示高速缓存容量，用 $B$ 字节表示块大小，用 $L = \\frac{C}{B}$ 表示缓存行数。该系统是字节寻址的，并且高速缓存是直接映射的。对于给定的字节地址 $x$，其缓存行索引由公式 $I(x) = \\left\\lfloor \\frac{x}{B} \\right\\rfloor \\pmod L$ 给出。\n\n首先，我们将分析初始内存布局下的高速缓存未命中总数，然后分析重新映射后的布局。\n\n**情况1：初始内存布局**\n\n在初始配置中，数组 $A$ 的基地址为 $A_{\\mathrm{base}} = 0$，数组 $D$ 的基地址为 $D_{\\mathrm{base}} = C$。每个数组的大小为 $C$ 字节。访问模式是对 $A$ 和 $D$ 中相应元素的交替读取：对于所有 $i \\in \\{0, 1, \\dots, C-1\\}$，系统读取 $A[i]$，然后读取 $D[i]$。\n\n数组 $A$ 的第 $i$ 个元素（表示为 $A[i]$）的地址是 $x_A(i) = A_{\\mathrm{base}} + i = i$。此次访问的缓存行索引是：\n$$I_A(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n数组 $D$ 的第 $i$ 个元素（表示为 $D[i]$）的地址是 $x_D(i) = D_{\\mathrm{base}} + i = C + i$。由于 $C=LB$，此次访问的缓存行索引是：\n$$I_D(i) = \\left\\lfloor \\frac{C+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor \\frac{LB+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor L + \\frac{i}{B} \\right\\rfloor \\pmod L$$\n利用向下取整函数的性质，对于整数 $n$，有 $\\lfloor n+y \\rfloor = n + \\lfloor y \\rfloor$：\n$$I_D(i) = \\left( L + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L$$\n由于 $L \\pmod L = 0$，这可以简化为：\n$$I_D(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n我们观察到，对于所有的 $i$，$I_A(i) = I_D(i)$。这意味着对于任何给定的 $i$，对 $A[i]$ 的访问和对 $D[i]$ 的访问都映射到完全相同的缓存行。\n\n现在，考虑交替访问序列（`读取 $A[i]$`，`读取 $D[i]$`）。\n让我们追踪一个缓存行的状态。假设发生了对 $A[i]$ 的访问。如果包含 $A[i]$ 的块不在高速缓存中，它将被取出，导致一次未命中。紧接着，发生对 $D[i]$ 的访问。由于 $D[i]$ 映射到同一个缓存行，并且它属于一个不同的内存块，因此必须取出它的块。这个操作会替换掉刚刚加载的 $A[i]$ 的块。这是一种冲突未命中。\n对于下一次迭代 $i+1$，会发生对 $A[i+1]$ 的访问。如果 $A[i+1]$ 与 $A[i]$ 在同一个块中，那么它的块已经不在高速缓存中了，因为它被对 $D[i]$ 的访问所替换。因此，这次对 $A[i+1]$ 的访问也是一次未命中。\n这种“乒乓”效应在整个循环中持续存在。对 $A$ 中一个元素的访问会加载一个块，这个块立即被对 $D$ 中相应元素的访问所替换，然后又被下一次对 $A$ 的访问所替换，依此类推。\n\n因此，这个序列中的每一次内存访问都会导致一次高速缓存未命中。循环从 $i=0$ 到 $C-1$ 运行，对于每个 $i$，都有两次访问（$A[i]$ 和 $D[i]$）。\n总访问次数是 $2 \\times C$。\n因此，在这种初始配置中，未命中的总数 $M_1$ 是：\n$$M_1 = 2C$$\n\n**情况2：重新映射的内存布局**\n\n在重新映射的配置中，$A$ 的基地址保持为 $A_{\\mathrm{base}} = 0$，但 $D$ 的基地址更改为 $D_{\\mathrm{base}}' = C + B$。\n\n对 $A[i]$ 访问的缓存行索引保持不变：\n$$I_A(i) = \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\pmod L$$\n\n数组 $D$ 的第 $i$ 个元素 $D[i]$ 的地址现在是 $x_D'(i) = D_{\\mathrm{base}}' + i = C + B + i$。此次访问的缓存行索引是：\n$$I_D'(i) = \\left\\lfloor \\frac{C+B+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor \\frac{LB+B+i}{B} \\right\\rfloor \\pmod L = \\left\\lfloor L + 1 + \\frac{i}{B} \\right\\rfloor \\pmod L$$\n$$I_D'(i) = \\left( L + 1 + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L = \\left( 1 + \\left\\lfloor \\frac{i}{B} \\right\\rfloor \\right) \\pmod L$$\n\n我们现在有 $I_D'(i) = (I_A(i) + 1) \\pmod L$。对相应元素 $A[i]$ 和 $D[i]$ 的访问现在映射到不同（相邻，并在 $L-1$ 处回绕）的缓存行。这种重新映射消除了在第一种情况下观察到的病态冲突。\n\n让我们用这种新布局来分析未命中模式。我们可以按内存块对访问进行分组。循环变量 $i$ 的范围是从 $0$ 到 $C-1$。数组内的块索引可以定义为 $k = \\lfloor i/B \\rfloor$，其范围是从 $k=0$ 到 $k = \\lfloor (C-1)/B \\rfloor = L-1$。\n\n对于每个块索引 $k \\in \\{0, 1, \\dots, L-1\\}$，循环遍历 $i$ 从 $kB$ 到 $(k+1)B-1$。\n- 在此范围内的所有对 $A[i]$ 的访问都落在 $A$ 的第 $k$ 个块中。该块映射到缓存行 $I_A = k \\pmod L = k$。\n- 在此范围内的所有对 $D[i]$ 的访问都落在 $D$ 的第 $k$ 个块中（就数组结构而言，而非内存）。该块映射到缓存行 $I_D' = (k+1) \\pmod L$。\n\n考虑给定块索引 $k$ 的访问：\n- 对 $A$ 的第 $k$ 个块的第一次访问（例如，在 $i=kB$ 处对 $A[kB]$ 的访问）将导致一次未命中，因为该块之前从未被访问过（或已被替换）。这可能是一次强制性未命中（如果缓存行为空或持有我们不再需要的块）或一次冲突未命中。这次未命中将 $A$ 的第 $k$ 个块带入缓存行 $k$。\n- 对 $A$ 的这个块的后续 $B-1$ 次访问（即 $A[kB+1], \\dots, A[(k+1)B-1]$）都将是命中，因为该块现在在高速缓存中。\n- 类似地，对 $D$ 的第 $k$ 个块的第一次访问（例如，在 $i=kB$ 处对 $D[kB]$ 的访问）将导致一次未命中，将其带入缓存行 $(k+1) \\pmod L$。\n- 对 $D$ 的这个块的后续 $B-1$ 次访问都将是命中。\n\n对于从 $0$ 到 $L-1$ 的每个块索引 $k$，$A$ 的相应块有一次未命中，$D$ 的相应块也有一次未命中。这使得在 $L$ 次块迭代中，每次迭代有 $2$ 次未命中。\n在重新映射的配置中，未命中的总数 $M_2$ 是：\n$$M_2 = 2 \\times L$$\n由于 $L=C/B$，我们可以将其写为 $M_2 = \\frac{2C}{B}$。\n\n**乘法缩减因子**\n\n问题要求计算总未命中次数的乘法缩减因子。这是原始未命中数与新的未命中数的比率。\n$$\\text{缩减因子} = \\frac{M_1}{M_2}$$\n代入 $M_1$ 和 $M_2$ 的表达式：\n$$\\text{缩减因子} = \\frac{2C}{2L} = \\frac{2C}{2C/B} = B$$\n乘法缩减因子是 $B$。此表达式按要求仅取决于 $B$。", "answer": "$$\\boxed{B}$$", "id": "3684789"}, {"introduction": "利用缓存最有效的方式是设计“缓存友好”（cache-aware）的算法。最后的这项实践练习 [@problem_id:3684821] 介绍了一种极为强大的技术：分块（blocking），或称为“平铺”（tiling）。以经典的矩阵乘法为例，你将确定一个最佳的块大小，以确保计算所需的工作集能够完全置于缓存之中，从而最大化数据复用并最小化对慢速主存的访问。", "problem": "一个矩阵乘法核心使用分块算法计算大型方阵的 $\\mathbf{C} \\leftarrow \\mathbf{C} + \\mathbf{A}\\mathbf{B}$。在分块版本中，该核心重复地将来自 $\\mathbf{A}$ 和 $\\mathbf{B}$ 的两个大小为 $b \\times b$ 的分块相乘，并累加到 $\\mathbf{C}$ 的一个 $b \\times b$ 分块中，同时将这三个分块都驻留在一级 (L1) 数据缓存中以最大化数据复用。假设如下：\n\n- L1 数据缓存的容量为 $C = 192 \\,\\text{KiB}$。\n- 每个元素是大小为 $s = 8 \\,\\text{bytes}$ 的双精度浮点数。\n- 缓存使用写回和写分配策略，并且在此计算中，相对于 $C$ 而言，标签和元数据的开销可以忽略不计。\n- 您可以假设一个理想的全相联容量模型，使得三个 $b \\times b$ 的分块为了能同时驻留，其共同占用的空间不得超过可用容量 $C$。\n\n从内存层次结构的核心定义（容量以字节为单位，数据足迹计算为元素数量乘以元素大小）出发，确定最大的理论分块大小 $b$，使得三个 $b \\times b$ 分块的总足迹不超过 $C$。将最终的 $b$ 表示为实数，并将您的答案四舍五入到四位有效数字。最终数字中不包含任何单位。", "solution": "这个问题的核心原理是，必须同时驻留在缓存中的数据的总内存足迹不能超过缓存的容量。问题陈述，三个分块——一个来自矩阵 $\\mathbf{A}$，一个来自 $\\mathbf{B}$，一个来自 $\\mathbf{C}$——必须驻留在 L1 数据缓存中。\n\n设 $b$ 为方形分块（或瓦片）的维度。\n每个分块有 $b \\times b = b^2$ 个元素。\n每个元素是双精度浮点数，大小为 $s = 8 \\,\\text{bytes}$。\n\n单个 $b \\times b$ 分块的内存足迹，记为 $F_{tile}$，是元素数量乘以每个元素的大小：\n$$F_{tile} = b^2 \\cdot s$$\n\n分块算法要求同时在缓存中保留三个这样的分块。因此，算法内循环所需的总内存足迹 $F_{total}$ 为：\n$$F_{total} = 3 \\cdot F_{tile} = 3 \\cdot b^2 \\cdot s$$\n\n这个总足迹不能超过 L1 数据缓存的容量 $C$。这给出了我们的控制不等式：\n$$3 \\cdot b^2 \\cdot s \\le C$$\n\n为了找到最大的理论分块大小 $b$，我们求解足迹恰好等于容量的情况：\n$$3 \\cdot b^2 \\cdot s = C$$\n\n现在我们可以解出 $b$：\n$$b^2 = \\frac{C}{3s}$$\n$$b = \\sqrt{\\frac{C}{3s}}$$\n\n给定的值为 $C = 192 \\,\\text{KiB}$ 和 $s = 8 \\,\\text{bytes}$。\n首先，我们必须将缓存容量 $C$ 以字节为单位表示，以与元素大小 $s$ 保持一致。在计算机科学中，千字节 (KiB) 定义为 $2^{10}$ 字节。\n$$C = 192 \\,\\text{KiB} = 192 \\times 2^{10} \\,\\text{bytes} = 192 \\times 1024 \\,\\text{bytes} = 196608 \\,\\text{bytes}$$\n\n现在，我们将 $C$ 和 $s$ 的数值代入 $b$ 的方程中：\n$$b = \\sqrt{\\frac{196608}{3 \\times 8}}$$\n$$b = \\sqrt{\\frac{196608}{24}}$$\n$$b = \\sqrt{8192}$$\n\n为了简化根式，我们可以将 $8192$ 表示为 $2$ 的幂。$8192 = 2^{13}$。\n$$b = \\sqrt{2^{13}} = \\sqrt{2^{12} \\times 2^1} = \\sqrt{(2^6)^2 \\times 2} = 2^6 \\sqrt{2} = 64\\sqrt{2}$$\n\n问题要求一个四舍五入到四位有效数字的实数。我们计算其数值：\n$$b = 64\\sqrt{2} \\approx 64 \\times 1.41421356... \\approx 90.509667...$$\n\n将此值四舍五入到四位有效数字，得到：\n$$b \\approx 90.51$$\n这代表了分块大小的最大理论维度。虽然在实践中 $b$ 必须是整数（例如，$\\lfloor 90.51 \\rfloor = 90$），但问题明确要求用实数表示。", "answer": "$$\n\\boxed{90.51}\n$$", "id": "3684821"}]}