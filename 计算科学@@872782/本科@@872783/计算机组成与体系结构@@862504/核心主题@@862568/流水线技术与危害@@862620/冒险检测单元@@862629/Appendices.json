{"hands_on_practices": [{"introduction": "为了掌握流水线中的冒险检测，我们首先需要量化数据冒险造成的性能损失以及转发技术带来的提升。这个练习通过一个“病态”的场景——一长串相互依赖的指令——来让你从第一性原理出发，推导出在有和没有转发的情况下，所需的总暂停周期数[@problem_id:3647250]。通过这个练习，你将能深刻理解数据冒险的核心代价以及转发的巨大价值。", "problem": "考虑一个顺序执行的五级流水线，它由指令提取（IF）、指令解码与寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB）组成。该流水线包含一个冒险检测单元（HDU），它会暂停前端以防止写后读（RAW）数据冒险。假设每个阶段恰好占用一个时钟周期，并且没有控制冒险和结构冒险。假设本问题中的所有指令都是算术逻辑指令，它们读取一个源寄存器并写入一个目的寄存器。\n\n给定一个参数，称为生产者-消费者数据延迟，记为 $L \\in \\mathbb{Z}_{\\ge 1}$。将 $L$ 理解为在没有结果前递的情况下（即消费者只能在值被写回寄存器文件后才能看到它们），为了观察到正确的值，消费者指令必须相对于其所依赖的紧邻的前一个生产者指令延迟的时钟周期数。通过完全的单周期结果前递（也称为旁路），消费者可以比仅依赖寄存器文件写回路径提前一个流水线阶段捕获生产者的结果，从而使每个生产者-消费者对所需的延迟恰好减少 $1$ 个周期。\n\n按如下方式构造一个长度为 $N \\in \\mathbb{Z}_{\\ge 1}$、依赖距离为 $1$ 的病态相关指令流。设该序列为 $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$，其中对于固定的体系结构寄存器 $R$ 和某个纯函数 $g$，每个指令的形式为\n$I_{k}: R \\leftarrow g(R)$\n因此对于每个 $k \\in \\{1,2,\\ldots,N-1\\}$，指令 $I_{k+1}$ 是指令 $I_{k}$ 所产生的值的消费者，并且在程序顺序上紧邻其后（依赖距离为 $1$）。\n\n从流水线分段和写后读顺序的核心定义出发，推导以下各项的闭式表达式：\n1) 在没有前递的情况下，冒险检测单元在整个指令流中插入的总暂停周期数，\n2) 在有完全单周期前递的情况下，冒险检测单元在整个指令流中插入的总暂停周期数，以及\n3) 前递所带来的总暂停周期数的绝对减少量。\n\n用 $N$ 和 $L$ 表示你的最终答案，形式为一个单行向量 $\\big[T_{\\text{no fwd}}, T_{\\text{fwd}}, \\Delta\\big]$。不需要数值近似；请提供一个闭式解析表达式。", "solution": "我们从与流水线执行和数据冒险相关的基本定义开始：\n- 当一条指令（消费者）需要读取由较早的指令（生产者）产生但尚未在消费者的使用点提供其结果的操作数时，就会发生写后读（RAW）冒险。\n- 在顺序流水线中，冒险检测单元（HDU）通过暂停消费者来强制执行正确的顺序，直到生产者的值在消费者的操作数输入端可用为止。\n- 在没有前递的情况下，消费者只有在值被写回寄存器文件后才能观察到该值。通过前递，消费者可以直接从比写回提前一个阶段的流水线寄存器中捕获生产者的结果，从而使生产者到消费者的等待时间减少一个周期。\n\n根据构造，指令流 $\\{I_{1}, I_{2}, \\ldots, I_{N}\\}$ 是一个依赖距离为 $1$ 的依赖链：对于每个 $k \\in \\{1,\\ldots,N-1\\}$，指令 $I_{k+1}$ 消费由指令 $I_{k}$ 产生的值。让我们用 $L \\in \\mathbb{Z}_{\\ge 1}$ 表示在没有前递的情况下给定的生产者-消费者数据延迟。根据问题中的定义，当没有前递可用时，这个 $L$ 是 HDU 必须延迟每个消费者的周期数，以使其在指令解码（ID）阶段的读取以及随后的执行（EX）阶段能通过寄存器文件路径观察到正确的值。\n\n我们现在来推断 HDU 在整个指令流中引入的总暂停周期数。\n\n1) 无前递。因为每对 $\\big(I_{k}, I_{k+1}\\big)$ 的依赖距离为 $1$，在没有冒险的情况下，消费者 $I_{k+1}$ 将在 $I_{k}$ 之后一个周期进入其 ID 阶段。然而，根据 $L$ 在这种无前递的流水线配置中的含义，HDU 必须将 $I_{k+1}$ 延迟恰好 $L$ 个周期，以使消费者的操作数读取与生产者的值通过寄存器文件可用时的周期对齐。因此，对于每个相邻的生产者-消费者对，HDU 会插入 $L$ 个暂停周期。\n\n在 $N$ 条指令的链中，恰好有 $N-1$ 个这样的相邻依赖对，因为 $I_{1}$ 在序列中没有前驱，而其后的每条指令都依赖于其紧邻的前驱。由于随着流水线在链上推进，每对所需的暂停发生在不同的时间点，因此总暂停周期数是所有对的总和：\n$$\nT_{\\text{no fwd}} \\;=\\; L \\cdot (N - 1).\n$$\n\n2) 完全单周期前递。通过完全单周期前递，消费者可以比依赖寄存器文件写回路径提前一个流水线阶段捕获生产者的结果。这使得每个生产者-消费者对所需的等待时间恰好减少一个周期。因此，对于每个相邻的依赖对，所需的暂停从 $L$ 减少到 $L - 1$。对 $N-1$ 个对求和得出\n$$\nT_{\\text{fwd}} \\;=\\; (L - 1) \\cdot (N - 1).\n$$\n\n3) 绝对减少量。由于前递而导致的总暂停周期数的绝对减少量是无前递和有前递情况下的总数之差：\n$$\n\\Delta \\;=\\; T_{\\text{no fwd}} - T_{\\text{fwd}} \\;=\\; \\big[L \\cdot (N - 1)\\big] - \\big[(L - 1) \\cdot (N - 1)\\big] \\;=\\; (N - 1).\n$$\n\n因此，用 $N$ 和 $L$ 表示的闭式表达式为\n$$\nT_{\\text{no fwd}} = L(N-1), \\quad T_{\\text{fwd}} = (L-1)(N-1), \\quad \\Delta = (N-1).\n$$\n\n我们按要求将最终答案以单行向量的形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} L(N-1) & (L-1)(N-1) & (N-1) \\end{pmatrix}}\n$$", "id": "3647250"}, {"introduction": "理解了暂停周期的基本计算后，下一步是将其转化为具体的硬件逻辑。本练习将挑战你为一个常见的“加载-使用”冒险设计冒险检测单元所需的精确布尔逻辑表达式。然后，你将通过手动追踪一段简短的代码序列来应用这个逻辑，计算实际产生的暂停周期，从而将高层架构规则与底层硬件现实联系起来[@problem_id:3647216]。", "problem": "考虑一个经典的五级、顺序、单发射流水线，其阶段包括指令获取（IF）、指令译码与寄存器读取（ID）、执行（EX）、内存访问（MEM）和写回（WB）。该处理器为算术逻辑单元的输出实现了完整的旁路（前递）路径，以便在执行阶段结束时产生的算术结果可以被前递到下一条指令的执行阶段，而无需引入停顿。加载指令在内存访问阶段从内存读取数据，并在写回阶段将值写入目标寄存器。定义加载-使用延迟 $L$ 为生产者指令的执行阶段开始，到加载的值可以通过前递提供给消费者指令的执行阶段输入的最早周期之间的周期数；假设此流水线中加载指令的 $L=2$。\n\n当指令译码与寄存器读取阶段的指令读取的源寄存器 $rs$ 或源寄存器 $rt$ 等于执行阶段指令的目标寄存器 $rd$ 时，且执行阶段的指令是加载指令，冒险检测单元必须置位一个停顿信号。零寄存器 $r0$ 在架构上硬连线为零，对 $r0$ 的写入无效；冒险检测单元应忽略作为目标的 $r0$。\n\n仅使用关于结果何时可用以及加载-使用延迟 $L$ 定义的、经过充分验证的流水线知识，完成以下任务：\n\n1. 根据信号 $EX\\_\\mathrm{isLoad}$、$EX\\_rd$、$ID\\_rs$ 和 $ID\\_rt$ 推导停顿信号的最小布尔表达式，包括 $r0$ 的特殊情况。您的表达式必须是相对于当前周期流水线寄存器内容的纯组合逻辑（没有计数器或计时器）。\n\n2. 然后，从一个空流水线开始，在上述假设和算术逻辑单元结果完全前递的情况下，估算执行以下连续三条相关指令序列时将插入的总停顿周期数：\n   - $I1$: $\\mathrm{LW}\\ r1,\\ 0(r2)$\n   - $I2$: $\\mathrm{LW}\\ r3,\\ 0(r1)$\n   - $I3$: $\\mathrm{ADD}\\ r4,\\ r3,\\ r5$\n\n将最终答案以一个实数值的形式给出，该值等于为这三条指令序列插入的总停顿周期数。无需四舍五入。最终答案中无需单位。", "solution": "该问题被评估为有效，因为它在科学上基于计算机体系结构的原理，问题提出得当，且内部一致。因此，我们可以着手解决。\n\n问题分为两部分。首先，我们推导停顿信号的布尔表达式。其次，我们计算给定指令序列的总停顿周期数。\n\n**第一部分：布尔停顿信号表达式的推导**\n\n问题指明了冒险检测单元必须置位停顿信号的条件。如果指令译码（ID）阶段的指令对当前处于执行（EX）阶段的加载指令存在源寄存器依赖，则需要停顿。让我们将这些条件形式化。\n\n逻辑表达式的已知条件是：\n- $EX\\_\\mathrm{isLoad}$：如果EX阶段的指令是加载指令，则该信号为真（$1$）。\n- $EX\\_rd$：EX阶段指令的目标寄存器索引。\n- $ID\\_rs$：ID阶段指令的第一个源寄存器索引。\n- $ID\\_rt$：ID阶段指令的第二个源寄存器索引。\n\n停顿的条件是：\n1. EX阶段的指令是加载指令。这对应于条件 $EX\\_\\mathrm{isLoad} = 1$。\n2. EX阶段加载指令的目标寄存器不是零寄存器 $r0$。寄存器 $r0$ 对应索引 $0$。因此，此条件为 $EX\\_rd \\neq 0$。\n3. ID阶段的指令使用加载的结果。这意味着它的至少一个源寄存器（$ID\\_rs$ 或 $ID\\_rt$）与EX阶段加载指令的目标寄存器（$EX\\_rd$）相同。这表示为 $(ID\\_rs = EX\\_rd) \\lor (ID\\_rt = EX\\_rd)$。\n\n将这三个条件用逻辑与（AND）运算结合起来，得到停顿信号的完整表达式，我们将其表示为 $S$。当且仅当所有三个条件都满足时，才会发生停顿。\n\n因此，停顿信号 $S$ 的最小布尔表达式为：\n$$S = EX\\_\\mathrm{isLoad} \\land (EX\\_rd \\neq 0) \\land ((ID\\_rs = EX\\_rd) \\lor (ID\\_rt = EX\\_rd))$$\n此表达式是最小的，因为它直接表示了问题陈述中描述的必要和充分条件，没有冗余项。\n\n**第二部分：总停顿周期数的计算**\n\n我们需要计算以下指令序列的总停顿周期数：\n- $I1: \\mathrm{LW}\\ r1, 0(r2)$\n- $I2: \\mathrm{LW}\\ r3, 0(r1)$\n- $I3: \\mathrm{ADD}\\ r4, r3, r5$\n\n该流水线对ALU结果具有完全前递功能，这意味着ALU-ALU依赖导致 $0$ 个停顿周期。问题定义了加载-使用延迟 $L=2$。加载-使用依赖的停顿周期数为 $L-1$。在这种情况下，$L-1 = 2-1 = 1$ 个停顿周期。我们可以通过追踪流水线执行来验证这一点。\n\n让我们分析指令之间的依赖关系。\n\n**依赖1：$I1 \\rightarrow I2$**\n- $I1$ 是 $\\mathrm{LW}\\ r1, 0(r2)$，它写入寄存器 $r1$。\n- $I2$ 是 $\\mathrm{LW}\\ r3, 0(r1)$，它读取寄存器 $r1$ 来计算其内存地址。\n这是一个经典的加载-使用数据冒险。我们追踪流水线以查看何时检测到冒险并插入停顿。\n\n| 周期 | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | 注释 |\n|---:|:---|:---|:---|:---|\n| $1$ | IF | | | $I1$ 被获取。 |\n| $2$ | ID | IF | | $I2$ 被获取。 |\n| $3$ | EX | ID | IF | $I3$ 被获取。检测到冒险：$I2$ 需要 $r1$，而 $I1$ 将产生 $r1$。 |\n| $4$ | MEM | ID (停顿) | IF (停顿) | $I1$（加载指令）在EX阶段，其目标是 $r1$。$I2$ 在ID阶段，其源之一是 $r1$。停顿信号被置位。插入一个气泡。 |\n| $5$ | WB | EX | ID | 停顿结束。$I1$ 的结果从MEM/WB寄存器前递到$I2$的EX阶段。 |\n\n在周期 $3$，$I1$ 处于EX阶段，$I2$ 处于ID阶段。冒险检测逻辑适用：\n- $I1$ 的 $EX\\_\\mathrm{isLoad}$ 为真。\n- $EX\\_rd$ 是 $r1$（不是 $r0$）。\n- $I2$ 的 $ID\\_rs$ 是 $r1$。\n条件 $(ID\\_rs = EX\\_rd)$ 为真。\n因此，停顿信号 $S$ 被置位。这引入了一个 $1$ 周期的停顿。流水线插入一个气泡，因此 $I2$ 在周期 $4$ 停留在ID阶段，而 $I1$ 进入MEM阶段。\n\n**依赖2：$I2 \\rightarrow I3$**\n- $I2$ 是 $\\mathrm{LW}\\ r3, 0(r1)$，它写入寄存器 $r3$。\n- $I3$ 是 $\\mathrm{ADD}\\ r4, r3, r5$，它读取寄存器 $r3$ 用于加法运算。\n这是另一个加载-使用数据冒险。我们从上次中断的地方继续追踪流水线。\n\n| 周期 | $I1: \\mathrm{LW}\\ r1,..$ | $I2: \\mathrm{LW}\\ r3, 0(r1)$ | $I3: \\mathrm{ADD}\\ r4, r3,..$ | 注释 |\n|---:|:---|:---|:---|:---|\n| $5$ | WB | EX | ID | 检测到冒险：$I3$ 需要 $r3$，而 $I2$ 将产生 $r3$。 |\n| $6$ | | MEM | ID (停顿) | $I2$（加载指令）在EX阶段，其目标是 $r3$。$I3$ 在ID阶段，其源之一是 $r3$。停顿信号被置位。插入一个气泡。 |\n| $7$ | | WB | EX | 停顿结束。$I2$ 的结果从MEM/WB寄存器前递到$I3$的EX阶段。 |\n| $8$ | | | MEM | $I3$ 继续执行。 |\n| $9$ | | | WB | $I3$ 完成。 |\n\n在周期 $5$，$I2$ 处于EX阶段，$I3$ 处于ID阶段。冒险检测逻辑再次被触发：\n- $I2$ 的 $EX\\_\\mathrm{isLoad}$ 为真。\n- $EX\\_rd$ 是 $r3$（不是 $r0$）。\n- $I3$ 的 $ID\\_rs$ 是 $r3$。\n条件 $(ID\\_rs = EX\\_rd)$ 为真。\n停顿信号 $S$ 被置位，导致第二个 $1$ 周期的停顿。\n\n总停顿周期数是每次检测到的冒险所导致的停顿之和。\n- 依赖 $I1 \\rightarrow I2$ 导致 $1$ 个停顿周期。\n- 依赖 $I2 \\rightarrow I3$ 导致 $1$ 个停顿周期。\n\n总停顿周期 = $1 + 1 = 2$。", "answer": "$$\\boxed{2}$$", "id": "3647216"}, {"introduction": "现实世界中的代码常常呈现出复杂的依赖模式。本练习探讨了一个关键场景：当多个正在执行的指令写入同一个寄存器时，冒险检测单元该如何决策[@problem_id:3647243]。你需要确定正确的处理策略，以确保后续的消费者指令从正确的生产者那里获取数据，这会加深你对程序顺序和冒险检测单元优先级的理解。", "problem": "考虑一个单发射、按序执行的五级流水线，其流水线阶段包括：指令提取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。该机器实现了从生产者阶段到后续周期中更年轻指令的 EX 阶段的完全转发（也称为旁路）。以下基本事实成立：\n\n- EX 阶段在其执行周期的开始时需要源操作数。\n- 算术或逻辑生产者在 EX 阶段计算其结果，该值在该 EX 周期结束时可用于转发。\n- 加载生产者在 MEM 周期结束时获取其数据，并且该值只能在下一周期中更年轻指令的 EX 阶段用于转发。\n- 寄存器文件写入发生在 WB 阶段，读取发生在 ID 阶段；按序完成保证了程序顺序的写入可见性，寄存器文件中没有写后写冲突。\n\nID 阶段的冲突检测单元 (HDU) 通过将 ID 阶段指令的源寄存器与流水线中更早的在执行指令的目标寄存器进行比较，来决定是否停顿当前在 ID 阶段的指令，以避免写后读 (RAW) 冲突。当多个更早的在执行指令将写入同一个目标寄存器 $rd$ 时，只有程序顺序中最新的（最年轻的）生产者才能决定消费者必须接收的正确值。\n\n假设有以下指令序列：\n- $I_1$: $LW\\; r_d, 0(r_a)$\n- $I_2$: $LW\\; r_d, 8(r_a)$\n- $I_3$: $ADD\\; r_t, r_d, r_b$\n\n这三条指令在程序顺序中是连续的。当 $I_3$ 首次进入 $ID$ 阶段的那个周期，流水线各阶段包含：\n- $I_1$ 在 $MEM$ 阶段，\n- $I_2$ 在 $EX$ 阶段，\n- $I_3$ 在 $ID$ 阶段。\n\n假设实现了从 $MEM$ 和 $WB$ 到后续周期的 $EX$ 阶段的转发，但在一个阶段结束时产生的值不能被另一条指令在同一周期开始时的 $EX$ 阶段使用。\n\n对于上述场景，HDU 应采用哪种策略来正确防止冲突并对多个 $rd$ 匹配进行优先级排序？\n\nA. 停顿 $I_3$ 直到 $I_1$ 完成，因为 $I_1$ 是 $r_d$ 的最早匹配生产者。为安全起见，优先考虑在执行的最旧的匹配 $rd$。\n\nB. 仅基于 $I_2$ 停顿 $I_3$，因为它是 $r_d$ 的最新匹配生产者。优先考虑最年轻的匹配 $rd$（程序顺序上最接近的），并精确插入 $1$ 个周期的停顿，以便 $I_3$ 的 $EX$ 发生在 $I_2$ 的 $MEM$ 数据变为可转发之后。\n\nC. 停顿 $I_3$ 直到 $I_1$ 和 $I_2$ 都已写回到寄存器文件，以保证在 $ID$ 阶段获得最新的值。当存在多个生产者写入同一个 $rd$ 时，要求两者都完成后才允许消费者继续执行。\n\nD. 不停顿 $I_3$，因为从 $MEM$ 的转发允许 $I_3$ 在 $I_2$ 处于 $MEM$ 阶段的同一周期接收 $r_d$。优先考虑任何可用的匹配 $rd$，并依靠同周期转发来避免停顿。", "solution": "首先验证问题陈述的科学合理性、一致性和完整性。\n\n### 第 1 步：提取已知条件\n\n- 流水线架构：单发射、按序执行的 $5$ 级流水线，阶段包括指令提取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)。\n- 转发：从生产者阶段到更年轻指令的 EX 阶段的完全转发。\n- 操作数时序：EX 阶段在周期开始时需要源操作数。\n- ALU 生产者时序：算术/逻辑生产者在 EX 阶段计算其结果，该值在该 EX 周期结束时可用于转发。\n- 加载生产者时序：加载生产者在 MEM 周期结束时获取其数据，该值只能在下一周期中更年轻指令的 EX 阶段用于转发。\n- 寄存器文件时序：写入发生在 WB 阶段；读取发生在 ID 阶段。\n- 冲突处理：ID 阶段的冲突检测单元 (HDU) 会停顿当前在 ID 阶段的指令，以避免写后读 (RAW) 冲突。\n- 多生产者规则：对于多个写入同一目标寄存器 $r_d$ 的更旧指令，消费者必须使用来自最新的（最年轻的）生产者的值。\n- 指令序列：\n    - $I_1$: $LW\\; r_d, 0(r_a)$\n    - $I_2$: $LW\\; r_d, 8(r_a)$\n    - $I_3$: $ADD\\; r_t, r_d, r_b$\n- 流水线状态快照：在 $I_3$ 首次进入 ID 阶段的周期，$I_1$ 在 MEM 阶段，$I_2$ 在 EX 阶段，$I_3$ 在 ID 阶段。\n- 转发约束：在一个阶段结束时产生的值不能被另一条指令在同一周期开始时的 EX 阶段使用。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n该问题陈述在科学上是成立且表述清晰的。它描述了一个经典的 $5$ 级 RISC 流水线，这是计算机组成与结构中的一个经典模型。所有给定的规则——数据转发路径、冲突检测和指令时序——都是标准的且内部一致。所呈现的场景是一个典型的加载-使用数据冲突示例，并因输出依赖而变得复杂，这是流水线设计中常见且实际的问题。问题的规定足够详细和清晰，可以得出一个唯一的逻辑解。给定的流水线状态与按序流水线执行给定指令序列的行为一致。语言客观且明确。该问题没有违反任何基本原则，也不是不完整或矛盾的。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。将推导出解决方案。\n\n### 基于原理的推导\n\n冲突检测单元 (HDU) 的核心任务是通过强制执行数据依赖来确保正确执行。我们必须分析给定指令序列的依赖关系，并应用流水线时序规则。\n\n1.  **数据依赖分析**：\n    指令 $I_3: ADD\\; r_t, r_d, r_b$ 使用寄存器 $r_d$ 作为源操作数。前面的两条指令 $I_1$ 和 $I_2$ 都写入同一个寄存器 $r_d$。这造成了写后读 (RAW) 冲突。问题明确规定了解决这种多生产者场景的规则：“只有程序顺序中最新的（最年轻的）生产者才能决定消费者必须接收的正确值。”在序列 $I_1$、$I_2$、$I_3$ 中，相对于消费者 $I_3$，$r_d$ 的最年轻生产者是 $I_2$。因此，$I_3$ 对 $I_2$ 有真正的数据依赖。$I_1$ 的结果在 $I_3$ 执行之前被 $I_2$ 覆盖，所以 HDU 必须强制执行 $I_2 \\rightarrow I_3$ 依赖，并且可以忽略 $I_1 \\rightarrow I_3$ 依赖。HDU 的逻辑必须基于为 $I_2$ 停顿。\n\n2.  **流水线时序与停顿计算**：\n    让我们将给定流水线状态发生的周期表示为周期 $k$。\n    - **周期 $k$ 的状态**：\n        - $I_1$ (LW)：MEM\n        - $I_2$ (LW)：EX\n        - $I_3$ (ADD)：ID\n    ID 阶段的 HDU 检测到 $I_3$ 读取 $r_d$，并且处于 EX 阶段的 $I_2$ 写入 $r_d$。由于 $I_2$ 是一条加载指令 (LW)，适用于加载-使用冲突的特定时序规则。\n\n    为了确定是否需要停顿，我们追踪如果不插入停顿，流水线的进展情况。\n    - **周期 $k+1$ 开始时（无停顿）**：\n        - $I_2$ 前进到 MEM 阶段。\n        - $I_3$ 前进到 EX 阶段。\n        - 根据问题规则，$I_3$ 在其 EX 阶段的*开始*时需要 $r_d$ 的值，即在周期 $k+1$ 的开始时。\n    - **来自 $I_2$ 的数据可用性**：\n        - $I_2$ 是一条加载指令。其数据在其 MEM 阶段（周期 $k+1$）从内存中获取。\n        - 根据规则，“加载生产者在 MEM 周期结束时获取其数据”。因此，来自 $I_2$ 的 $r_d$ 值仅在周期 $k+1$ 的*结束*时才可用。\n\n    这里存在一个冲突：$I_3$ 在周期 $k+1$ 的开始时需要该值，但 $I_2$ 在周期 $k+1$ 的结束时才提供它。这是一个经典的加载-使用冲突。转发硬件无法在没有停顿的情况下解决这个问题，正如明确指出的：“在一个阶段结束时产生的值不能被另一条指令在同一周期开始时的 EX 阶段使用。”\n\n    因此，HDU 必须停顿 $I_3$。让我们确定所需的停顿持续时间。$1$ 个周期的停顿是标准解决方案。我们来验证一下。\n    - **在周期 $k$**：HDU 检测到冲突并使流水线停顿 $1$ 个周期。这意味着 $I_3$ 被保持在 ID 阶段，一个气泡 (no-op) 被注入到 EX 阶段。\n    - **周期 $k+1$ 的状态（有 $1$ 个停顿周期）**：\n        - $I_1$ 前进到 WB 阶段。\n        - $I_2$ 前进到 MEM 阶段。\n        - $I_3$ 保持在 ID 阶段。\n        - 一个气泡进入 EX  stage。\n    - **周期 $k+2$ 的状态**：停顿完成，流水线正常推进。\n        - $I_2$ 前进到 WB 阶段。\n        - $I_3$ 前进到 EX 阶段。\n        - 气泡前进到 MEM 阶段。\n    - **周期 $k+2$ 中 $I_3$ 的数据可用性**：\n        - $I_3$ 在其 EX 阶段（周期 $k+2$）的开始时需要 $r_d$ 的值。\n        - 来自 $I_2$ 的值在其 MEM 阶段结束时（周期 $k+1$ 结束时）变得可用。\n        - 规则规定：“该值只能在下一周期……的 EX 阶段用于转发”。$I_2$ 的 MEM 阶段（周期 $k+1$）之后的周期是周期 $k+2$。因此，MEM 到 EX 的转发路径可以将周期 $k+1$ 结束时的值提供给周期 $k+2$ 的开始。\n\n    通过精确的 $1$ 个停顿周期，执行是正确的。HDU 的策略必须是优先考虑最年轻的生产者 ($I_2$) 并插入一个 $1$ 周期的停顿。\n\n### 逐项分析选项\n\n**A. 停顿 $I_3$ 直到 $I_1$ 完成，因为 $I_1$ 是 $r_d$ 的最早匹配生产者。为安全起见，优先考虑在执行的最旧的匹配 $rd$。**\n这个策略是错误的。它违反了顺序一致性的基本要求，问题中明确指出：“只有程序顺序中最新的（最年轻的）生产者才能决定正确的值”。优先考虑最旧的生产者 $I_1$ 会导致 $I_3$ 接收到错误的 $r_d$ 值（由 $I_1$ 加载的值，该值本应被 $I_2$ 覆盖）。\n**结论：错误。**\n\n**B. 仅基于 $I_2$ 停顿 $I_3$，因为它是 $r_d$ 的最新匹配生产者。优先考虑最年轻的匹配 $rd$（程序顺序上最接近的），并精确插入 $1$ 个周期的停顿，以便 $I_3$ 的 $EX$ 发生在 $I_2$ 的 $MEM$ 数据变为可转发之后。**\n这个策略与我们的推导完全一致。\n1.  它正确地识别了对最新生产者 $I_2$ 的依赖。\n2.  它正确地确定了需要停顿来解决加载-使用冲突。\n3.  它正确地计算出停顿持续时间为精确的 $1$ 个周期。\n4.  给出的理由——允许 $I_3$ 的 EX 阶段延迟到 $I_2$ 来自 MEM 阶段的数据可用于转发之后——是解决这类流水线中加载-使用冲突的精确逻辑。\n**结论：正确。**\n\n**C. 停顿 $I_3$ 直到 $I_1$ 和 $I_2$ 都已写回到寄存器文件，以保证在 $ID$ 阶段获得最新的值。当存在多个生产者写入同一个 $rd$ 时，要求两者都完成后才允许消费者继续执行。**\n这个策略极其低效且不正确。它描述了一个没有任何数据转发的流水线，其中消费者必须等待生产者完成 WB 阶段。问题明确指出实现了“完全转发”。等待两个生产者也是错误的；只需要来自 $I_2$ 的值。这个策略会引入许多不必要的停顿周期，并违背了带转发的流水线架构的目的。\n**结论：错误。**\n\n**D. 不停顿 $I_3$，因为从 $MEM$ 的转发允许 $I_3$ 在 $I_2$ 处于 $MEM$ 阶段的同一周期接收 $r_d$。优先考虑任何可用的匹配 $rd$，并依靠同周期转发来避免停顿。**\n这个策略是错误的，因为它误解了数据可用性的时序。如推导所示，如果 $I_2$ 在周期 $k+1$ 处于 MEM 阶段，其数据仅在该周期结束时才可用。如果 $I_3$ 不停顿地继续执行，它将在周期 $k+1$ 处于其 EX 阶段，并在该周期开始时就需要数据。这种“同周期”转发是不可能的，并且被问题的约束明确禁止：“在一个阶段结束时产生的值不能被另一条指令在同一周期开始时的 EX 阶段使用。” 停顿是绝对必要的。此外，优先考虑“任何可用的”生产者是错误的；为了正确性，必须是最年轻的那个。\n**结论：错误。**", "answer": "$$\\boxed{B}$$", "id": "3647243"}]}