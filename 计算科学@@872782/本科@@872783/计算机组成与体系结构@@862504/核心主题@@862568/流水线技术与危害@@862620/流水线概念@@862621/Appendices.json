{"hands_on_practices": [{"introduction": "数据冒险是流水线设计中的一个核心挑战。如果没有专门的硬件来解决这个问题会怎么样？本练习将通过对比两种不同情景，来具体展示“写后读”（RAW）数据冒险：一种是通过编译器插入空操作指令（NOPs）的纯软件方案，另一种是依赖硬件进行数据前推和停顿。通过亲手追踪指令在流水线中的流动并计算执行周期，您将直观地理解数据前推的工作原理，并体会其对现代处理器性能为何至关重要 [@problem_id:3629331]。", "problem": "一个加载/存储精简指令集计算 (RISC) 设计中的五级流水线包含指令获取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)，每个阶段恰好占用一个周期。寄存器文件在 ID 阶段被读取，在 WB 阶段被写入。当一条指令需要一个尚未被前序指令写入的寄存器值时，就会发生写后读 (RAW) 冒险。假设存在以下两种硬件配置：\n\n1. 无转发：流水线不转发中间结果。消费者指令只有在其 ID 阶段严格晚于生产者指令的 WB 阶段完成时，才能读取生产者的目的寄存器。\n2. 完全转发与硬件冒险检测：算术结果可以在紧随的周期中从生产者指令的 EX 阶段转发到消费者指令的 EX 阶段。加载结果可以在紧随的周期中从生产者指令的 MEM 阶段转发到消费者指令的 EX 阶段。冒险检测单元在需要时，对加载-使用依赖自动停顿正好一个周期；否则，它不会停顿。\n\n考虑以下指令序列：\n- $I_1$: $LW\\ R_1,\\ 0(R_2)$\n- $I_2$: $ADD\\ R_3,\\ R_1,\\ R_4$\n- $I_3$: $SUB\\ R_5,\\ R_3,\\ R_6$\n\n不存在缓存未命中或控制冒险，流水线从空开始，在周期 $1$ 获取 $I_1$。在无转发配置下，编译器可以插入空操作 (NOP) 指令以避免冒险；每个 NOP 像普通指令一样占用流水线。\n\n使用上述定义，确定：\n- 在无转发配置下，为防止所有 RAW 冒险，编译器必须在 $I_1$ 和 $I_2$ 之间以及 $I_2$ 和 $I_3$ 之间插入的最小 NOP 指令数量。\n- 在无转发配置下，并插入了您找到的最小数量的 NOP 指令后，完成这三条指令序列所需的总周期数。\n- 在完全转发配置下，带有硬件冒险检测且没有编译器插入的 NOP 指令时，完成相同序列所需的总周期数。\n\n最后，计算无转发配置（插入了最小 NOPs）下的总周期数与完全转发配置（带有硬件冒险检测）下的总周期数的比率。将您的最终答案表示为单个最简分数。无需四舍五入。", "solution": "该问题要求在两种不同的硬件配置下，分析一个三指令序列在一个五级 RISC 流水线上的执行情况。流水线阶段包括指令获取 (IF)、指令解码与寄存器读取 (ID)、执行 (EX)、内存访问 (MEM) 和写回 (WB)，每个阶段占用一个周期。该指令序列存在写后读 (RAW) 数据冒险。\n\n指令序列如下：\n- $I_1$: $LW\\ R_1,\\ 0(R_2)$（$R_1$ 的生产者）\n- $I_2$: $ADD\\ R_3,\\ R_1,\\ R_4$（$R_1$ 的消费者，$R_3$ 的生产者）\n- $I_3$: $SUB\\ R_5,\\ R_3,\\ R_6$（$R_3$ 的消费者）\n\n我们分别分析这两种硬件配置。\n\n### 配置 1：无转发\n在此配置中，只有当值在寄存器文件中可用时，RAW 冒险才能得到解决。生产者指令在其 WB 阶段写入的值，只有当消费者指令的 ID 阶段严格晚于生产者指令的 WB 阶段完成时，才能被其读取。冒险通过编译器插入空操作 (NOP) 指令来解决。\n\n**$I_1$ 和 $I_2$ 之间的冒险：**\n$I_1$ ($LW$) 为寄存器 $R_1$ 生成一个值。$I_2$ ($ADD$) 消费这个值。\n让我们确定 $I_1$ 的时间线，它在周期 $1$ 被获取。\n- $I_1$ IF: 周期 $1$\n- $I_1$ ID: 周期 $2$\n- $I_1$ EX: 周期 $3$\n- $I_1$ MEM: 周期 $4$\n- $I_1$ WB: 周期 $5$\n$R_1$ 的值在周期 $5$ 结束时被写入寄存器文件。因此，任何读取 $R_1$ 的指令的 ID 阶段必须不早于周期 $6$ 开始。\n\n如果没有任何 NOP，$I_2$ 将在周期 $2$ 被获取，并在周期 $3$ 进入其 ID 阶段。这太早了，会读取到 $R_1$ 的旧值。为了将 $I_2$ 的 ID 阶段延迟到周期 $6$，我们必须延迟它的获取。ID 阶段是流水线的第二个阶段，因此要使 $ID(I_2)$ 处于周期 $6$，则 $IF(I_2)$ 必须处于周期 $5$。\n由于指令是每个周期顺序获取的，且 $I_1$ 在周期 $1$ 获取，那么在周期 $5$ 获取 $I_2$ 意味着必须在周期 $2$、$3$ 和 $4$ 获取另外三条指令。这些就是编译器插入的 NOP。\n- 周期 $1$: 获取 $I_1$\n- 周期 $2$: 获取 $NOP_1$\n- 周期 $3$: 获取 $NOP_2$\n- 周期 $4$: 获取 $NOP_3$\n- 周期 $5$: 获取 $I_2$\n因此，在 $I_1$ 和 $I_2$ 之间必须插入至少 $3$ 个 NOP。\n\n**$I_2$ 和 $I_3$ 之间的冒险：**\n$I_2$ ($ADD$) 为寄存器 $R_3$ 生成一个值。$I_3$ ($SUB$) 消费这个值。\n在 $I_1$ 和 $I_2$ 之间插入 $3$ 个 NOP 后，$I_2$ 的时间线是：\n- $I_2$ IF: 周期 $5$\n- $I_2$ ID: 周期 $6$\n- $I_2$ EX: 周期 $7$\n- $I_2$ MEM: 周期 $8$\n- $I_2$ WB: 周期 $9$\n$R_3$ 的值在周期 $9$ 结束时被写入寄存器文件。因此，$I_3$ 的 ID 阶段必须不早于周期 $10$ 开始。\n\n要使 $ID(I_3)$ 处于周期 $10$，则 $IF(I_3)$ 必须处于周期 $9$。我们知道 $I_2$ 是在周期 $5$ 获取的。在周期 $9$ 获取 $I_3$ 意味着必须在周期 $6$、$7$ 和 $8$ 获取另外三条指令。\n- 周期 $5$: 获取 $I_2$\n- 周期 $6$: 获取 $NOP_4$\n- 周期 $7$: 获取 $NOP_5$\n- 周期 $8$: 获取 $NOP_6$\n- 周期 $9$: 获取 $I_3$\n因此，在 $I_2$ 和 $I_3$ 之间必须插入至少 $3$ 个 NOP。\n\n**无转发配置的总周期数：**\n流水线执行的完整指令序列是：$I_1, NOP, NOP, NOP, I_2, NOP, NOP, NOP, I_3$。这总共有 $N=9$ 条指令。对于一个 $k=5$ 级的流水线，执行 $N$ 条指令所需的总周期数为 $k + (N-1)$。\n总周期数 = $5 + (9-1) = 5 + 8 = 13$。\n另一种计算方法是，最后一条指令 $I_3$ 在周期 $9$ 被获取。它的 WB 阶段将在 $4$ 个周期后完成。\n- $I_3$ IF: 周期 $9$\n- $I_3$ ID: 周期 $10$\n- $I_3$ EX: 周期 $11$\n- $I_3$ MEM: 周期 $12$\n- $I_3$ WB: 周期 $13$\n整个序列在周期 $13$ 结束时完成。\n\n### 配置 2：完全转发与硬件冒险检测\n在此配置中，不插入 NOP。硬件通过转发和停顿来处理冒险。指令在连续的周期中获取：$I_1$ 在周期 $1$，$I_2$ 在周期 $2$，$I_3$ 在周期 $3$。\n\n**$I_1$ 和 $I_2$ 之间的冒险（加载-使用）：**\n- $I_1$ ($LW$) 的数据在其 MEM 阶段结束时从内存中可用。\n- $I_2$ ($ADD$) 在其 EX 阶段需要 $R_1$ 的值。\n让我们画出未停顿的流水线图：\n| 周期 | 1    | 2    | 3    | 4    | 5    |\n|-------|------|------|------|------|------|\n| $I_1$   | IF   | ID   | EX   | MEM  | WB   |\n| $I_2$   |      | IF   | ID   | EX   | MEM  |\n$I_1$ 的数据在周期 $4$ 结束时准备好。$I_2$ 在其 EX 阶段的开始，即周期 $4$ 的开始，就需要它。数据可用得太晚了。\n加载的转发规则是从生产者指令的 MEM 阶段到 *下一个* 周期消费者指令的 EX 阶段（即，周期 $t$ 的 MEM 可以转发到周期 $t+1$ 的 EX）。为了使其工作， $I_2$ 的 EX 阶段必须延迟到周期 $5$。这需要一个周期的停顿。\n题目陈述证实了这一点：“冒险检测单元在需要时，对加载-使用依赖自动停顿正好一个周期”。\n停顿是在周期 $3$ 检测到冒险时引入的（此时 $I_2$ 处于 ID 阶段）。流水线停顿一个周期（周期 $4$），然后继续执行。\n\n**$I_2$ 和 $I_3$ 之间的冒险（ALU-ALU）：**\n- $I_2$ ($ADD$) 的结果在其 EX 阶段结束时可用。\n- $I_3$ ($SUB$) 在其 EX 阶段需要这个结果。\n算术运算的转发规则是从生产者指令的 EX 阶段到 *下一个* 周期消费者指令的 EX 阶段（周期 $t$ 的 EX 到周期 $t+1$ 的 EX）。\n让我们构建完整的流水线图，包括第一个冒险导致的一周期停顿。\n| 周期 | 1    | 2    | 3    | 4 (停顿) | 5    | 6    | 7    | 8    |\n|-------|------|------|------|-----------|------|------|------|------|\n| $I_1$   | IF   | ID   | EX   | MEM       | WB   |      |      |      |\n| $I_2$   |      | IF   | ID   | ID        | EX   | MEM  | WB   |      |\n| $I_3$   |      |      | IF   | IF        | ID   | EX   | MEM  | WB   |\n\n在周期 $4$，$I_2$ 和 $I_3$ 在它们各自的当前阶段（分别为 ID 和 IF）停顿，而 $I_1$ 继续前进。一个气泡被有效地插入到流水线中。\n- $I_2$ 的 EX 阶段现在处于周期 $5$。从 $I_1$（周期 $4$ 的 MEM）到 $I_2$ 的 EX 阶段的 MEM-to-EX 转发按要求工作。\n- $I_3$ 的 EX 阶段在周期 $6$。\n- $I_2$（生产者）的 EX 阶段在周期 $5$。$I_3$（消费者）的 EX 阶段在周期 $6$。EX-to-EX 转发路径完美工作，因此不需要额外的停顿。\n\n**完全转发配置的总周期数：**\n最后一条指令 $I_3$ 在周期 $8$ 结束时完成其 WB 阶段。\n因此，完成该序列所需的总周期数为 $8$。\n\n### 最终计算：周期比率\n问题要求计算无转发配置下的总周期数与完全转发配置下的总周期数的比率。\n\n- 总周期数（无转发），$C_{NF} = 13$\n- 总周期数（完全转发），$C_{F} = 8$\n\n比率为 $\\frac{C_{NF}}{C_{F}} = \\frac{13}{8}$。\n这是一个最简分数。\n无转发情况下，在 $I_1$ 和 $I_2$ 之间以及 $I_2$ 和 $I_3$ 之间所需的最小 NOP 数量均为 $3$。无转发的总周期数为 $13$，完全转发的总周期数为 $8$。最终比率为 $\\frac{13}{8}$。", "answer": "$$\\boxed{\\frac{13}{8}}$$", "id": "3629331"}, {"introduction": "真实处理器的性能并非由单一类型的冒险决定，而是多种因素共同作用的结果。本练习将引导您运用一种标准方法，通过综合考虑各类流水线停顿的统计影响来计算整体的每指令周期数（CPI）。您将学习如何根据程序特征（指令混合）和微架构参数（缓存、分支预测器等），对数据冒险、内存停顿和控制冒险造成的性能惩罚进行加权，从而建立一个量化的处理器性能模型 [@problem_id:3629296]。", "problem": "一个五级、顺序、单发射流水线执行一个由四种指令类别组成的指令流：算术逻辑单元 (ALU) 操作、加载、存储和条件分支。这些阶段是取指、译码、执行、访存和写回。该处理器使用独立的指令和数据存储器，从而消除了取指和数据访问之间的结构性冒险。为 ALU 结果实现了完全数据前推，但从内存加载的值只有在访存阶段之后才可用，因此一条紧跟在加载指令之后并使用其结果的指令无法通过前推完全解决冲突。分支在执行阶段被解析，并且一个动态预测器在每个周期提供一个方向预测。指令混合比例为 $f_{ALU}$、$f_{LOAD}$、$f_{STORE}$ 和 $f_{BR}$，且 $f_{ALU} + f_{LOAD} + f_{STORE} + f_{BR} = 1$。\n\n假设以下经过充分测试、广泛使用的事实和建模假设：\n- 在一个没有冒险的完全流水线化、单发射机器中，理想的每指令周期数 (CPI) 为 $1$，因为在稳态下每个周期完成一条指令。\n- 平均 CPI 等于理想基线加上由冒险引起的每条指令的预期停顿周期数，其中期望值是基于整个指令流计算的。假设冒险事件在不同指令类别之间是独立的，并且不同类型冒险导致的停顿在时间上不重叠。\n- ALU 操作不引起停顿，因为在此设计中数据前推消除了它们的互锁。\n- 一条加载指令如果紧跟着一条消费其结果的指令，会引起恰好 $1$ 个停顿周期。设 $r$ 表示一条加载指令紧跟着一条依赖它的消费者指令的概率。\n- 一级 (L1) 数据缓存对于加载指令的未命中率为 $m$，每次加载未命中都会使流水线在命中情况之外额外停顿 $L$ 个周期。\n- 存储指令使用一个写缓冲器，对于此工作负载，该缓冲器完全隐藏了写命中和写未命中，因此存储指令不会使流水线停顿。\n- 动态分支预测器对条件分支的错误预测率为 $b$，每次错误预测都会冲刷流水线，造成恰好 $C$ 个周期的惩罚，而正确预测的分支不引起惩罚。\n\n对于一个特定的工作负载，指令混合和微架构参数如下：\n- $f_{ALU} = 0.45$, $f_{LOAD} = 0.25$, $f_{STORE} = 0.10$, $f_{BR} = 0.20$。\n- $r = 0.30$。\n- $m = 0.04$, $L = 12$。\n- $b = 0.10$, $C = 2$。\n\n仅使用上述定义和期望的第一性原理，计算在此假设下该流水线的预期每指令周期数。将最终答案表示为一个无单位的实数，并四舍五入到四位有效数字。", "solution": "问题要求计算一个五级流水线处理器的预期每指令周期数 (CPI)。解决方案将通过将期望原理应用于所提供的流水线执行模型来推导，该模型包括了各种冒险的惩罚。\n\n所提供的计算平均 CPI 的基本方程是理想 CPI 与由冒险引起的每指令平均停顿周期数之和。\n$$\n\\text{CPI} = \\text{CPI}_{\\text{ideal}} + \\Delta\\text{CPI}_{\\text{hazards}}\n$$\n问题陈述，对于一个没有冒险的完全流水线化的机器，理想 CPI 为 $1$。\n$$\n\\text{CPI}_{\\text{ideal}} = 1\n$$\n每指令的总停顿周期数 $\\Delta\\text{CPI}_{\\text{hazards}}$ 是每种冒险贡献的总和。问题明确指出，由不同类型冒险引起的停顿在时间上不重叠，因此它们的贡献可以直接相加。已确定的潜在停顿来源是加载-使用数据冒险、数据缓存未命中和分支错误预测。其他指令类型（ALU 和存储）被陈述为不引起停顿。\n\n因此，每指令的总停顿周期数为：\n$$\n\\Delta\\text{CPI}_{\\text{hazards}} = \\Delta\\text{CPI}_{\\text{load-use}} + \\Delta\\text{CPI}_{\\text{cache-miss}} + \\Delta\\text{CPI}_{\\text{branch-mispredict}}\n$$\n我们现在将计算停顿惩罚的每个组成部分。由特定事件贡献的惩罚是可能导致该事件的指令的频率、该事件对该指令发生的概率以及该事件引起的停顿周期数的乘积。\n\n1.  **加载-使用数据冒险停顿 ($\\Delta\\text{CPI}_{\\text{load-use}}$)**\n    加载-使用冒险发生于一条依赖于前一条加载指令结果的指令紧随其后执行时。问题陈述此类事件会引起恰好 $1$ 个停顿周期。\n    - 作为加载指令的指令比例是 $f_{\\text{LOAD}}$。\n    - 一条加载指令紧跟着一条依赖它的指令的概率是 $r$。\n    - 此事件的惩罚是 $1$ 个周期。\n    由此冒险引起的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{load-use}} = f_{\\text{LOAD}} \\times r \\times 1\n    $$\n    使用给定值 $f_{\\text{LOAD}} = 0.25$ 和 $r = 0.30$：\n    $$\n    \\Delta\\text{CPI}_{\\text{load-use}} = 0.25 \\times 0.30 \\times 1 = 0.075\n    $$\n\n2.  **数据缓存未命中停顿 ($\\Delta\\text{CPI}_{\\text{cache-miss}}$)**\n    当加载指令在一级 (L1) 数据缓存中未命中时，会发生停顿。\n    - 作为加载指令的指令比例是 $f_{\\text{LOAD}}$。\n    - 加载指令的 L1 数据缓存未命中率为 $m$。\n    - 缓存未命中的惩罚是额外的 $L$ 个周期。\n    由数据缓存未命中引起的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{cache-miss}} = f_{\\text{LOAD}} \\times m \\times L\n    $$\n    使用给定值 $f_{\\text{LOAD}} = 0.25$、$m = 0.04$ 和 $L = 12$：\n    $$\n    \\Delta\\text{CPI}_{\\text{cache-miss}} = 0.25 \\times 0.04 \\times 12 = 0.01 \\times 12 = 0.12\n    $$\n\n3.  **分支错误预测停顿 ($\\Delta\\text{CPI}_{\\text{branch-mispredict}}$)**\n    当动态分支预测器做出错误预测，导致流水线被冲刷时，会发生停顿。\n    - 作为条件分支的指令比例是 $f_{\\text{BR}}$。\n    - 分支错误预测率为 $b$。\n    - 错误预测的惩罚是 $C$ 个周期。\n    由分支错误预测引起的每指令预期停顿周期数为：\n    $$\n    \\Delta\\text{CPI}_{\\text{branch-mispredict}} = f_{\\text{BR}} \\times b \\times C\n    $$\n    使用给定值 $f_{\\text{BR}} = 0.20$、$b = 0.10$ 和 $C = 2$：\n    $$\n    \\Delta\\text{CPI}_{\\text{branch-mispredict}} = 0.20 \\times 0.10 \\times 2 = 0.02 \\times 2 = 0.04\n    $$\n\n最后，我们将理想 CPI 与所有停顿分量相加，以求得总的预期 CPI。\n$$\n\\text{CPI} = \\text{CPI}_{\\text{ideal}} + \\Delta\\text{CPI}_{\\text{load-use}} + \\Delta\\text{CPI}_{\\text{cache-miss}} + \\Delta\\text{CPI}_{\\text{branch-mispredict}}\n$$\n代入计算出的值：\n$$\n\\text{CPI} = 1 + 0.075 + 0.12 + 0.04\n$$\n$$\n\\text{CPI} = 1 + 0.235\n$$\n$$\n\\text{CPI} = 1.235\n$$\n问题要求答案四舍五入到四位有效数字。计算出的值 $1.235$ 已经有四位有效数字。", "answer": "$$\\boxed{1.235}$$", "id": "3629296"}, {"introduction": "我们如何才能让处理器变得更快？答案通常在于两个方面：减少每条指令所需的时钟周期数（CPI），或者缩短每个时钟周期的时长（提高时钟频率）。本练习将探讨一个真实的工程优化场景：通过拆分流水线中最慢的阶段，我们不仅可能缩短时钟周期，还能消除停顿周期，这完美地诠释了流水线设计中的权衡。这个最终练习将指导您应用处理器性能的“铁律”——它将 CPI、时钟频率和总执行时间联系在一起——来计算真实的性能提升（加速比），从而将理论分析与设计评估联系起来 [@problem_id:3629255]。", "problem": "一个由指令获取 (IF)、指令译码和寄存器读取 (ID)、执行 (EX)、访存 (MEM) 和写回 (WB) 组成的五级顺序流水线，实现了完全的数据旁路，但经典的加载-使用情况除外。每个阶段的逻辑延迟如下：IF 延迟为 $180\\,\\text{ps}$，ID 延迟为 $170\\,\\text{ps}$，EX 延迟为 $160\\,\\text{ps}$，MEM 延迟为 $360\\,\\text{ps}$，WB 延迟为 $140\\,\\text{ps}$。每个流水线寄存器会给周期时间增加 $40\\,\\text{ps}$ 的锁存器开销。假设一级数据存储器总是命中，且分支惩罚可以忽略不计。\n\n一个工作负载是以冒险为主的：在一个包含 $N \\gg 1$ 条指令的长动态指令流中，比例为 $f = 0.70$ 的指令边界是加载-使用冒险，其中一条加载指令紧跟着一条依赖它的指令。在基准流水线中，即使有完全旁路，每个这样的加载-使用冒险也会导致恰好一个周期的停顿，因为加载的数据仅在 MEM 阶段结束时才可用，如果没有气泡，就无法满足相关指令 EX 阶段的时序要求。\n\n一个增强型设计通过将 MEM 阶段拆分为两个相等的逻辑阶段 MEM1 和 MEM2，增加了一个额外的流水线阶段，每个新阶段的逻辑延迟是原 MEM 阶段的一半。每个阶段的锁存器开销保持 $40\\,\\text{ps}$ 不变。存储器的组织方式使得加载的值在 MEM1 结束时就可用，从而可以在下一个周期正确地将数据前推到相关指令的 EX 阶段，而没有任何停顿。机器和工作负载的所有其他方面保持不变，并且没有新的结构性冒险。\n\n仅使用第一性原理，例如每指令周期数 (CPI) 的定义、执行时间、CPI 和时钟周期之间的关系，以及加速比作为执行时间之比的定义，推导并计算对于此工作负载，增强型设计相对于基准设计的整体加速比。将最终加速比表示为单个实数，并将答案四舍五入到四位有效数字。", "solution": "该问题被认为是有效的，因为它在科学上基于计算机体系结构的原理，问题提法清晰，数据充分，可得出唯一解，并且以客观、正式的语言表述。我们可以进行分析。\n\n增强型设计相对于基准设计的整体加速比定义为其各自执行时间之比。程序的执行时间（$T_{exec}$）由处理器性能的铁律给出：\n$$T_{exec} = N \\times \\text{CPI} \\times T_{clk}$$\n其中 $N$ 是动态指令数，CPI 是每条指令的平均时钟周期数，$T_{clk}$ 是时钟周期时间（或周期）。\n\n因此，加速比（$S$）可以表示为：\n$$S = \\frac{T_{exec, base}}{T_{exec, enh}} = \\frac{N \\times \\text{CPI}_{base} \\times T_{clk, base}}{N \\times \\text{CPI}_{enh} \\times T_{clk, enh}}$$\n由于两种设计的工作负载相同，指令数 $N$ 是恒定的，可以消掉：\n$$S = \\frac{\\text{CPI}_{base} \\times T_{clk, base}}{\\text{CPI}_{enh} \\times T_{clk, enh}}$$\n为了计算加速比，我们必须首先确定每种设计的时钟周期和 CPI。\n\n首先，我们分析基准设计。\n流水线处理器的时钟周期（$T_{clk}$）由其最慢阶段的延迟加上流水线寄存器（锁存器）的开销决定。基准五级流水线的阶段延迟如下：\n$T_{IF} = 180\\,\\text{ps}$\n$T_{ID} = 170\\,\\text{ps}$\n$T_{EX} = 160\\,\\text{ps}$\n$T_{MEM} = 360\\,\\text{ps}$\n$T_{WB} = 140\\,\\text{ps}$\n锁存器开销为 $T_{latch} = 40\\,\\text{ps}$。\n\n基准设计的时钟周期 $T_{clk, base}$ 为：\n$$T_{clk, base} = \\max(T_{IF}, T_{ID}, T_{EX}, T_{MEM}, T_{WB}) + T_{latch}$$\n$$T_{clk, base} = \\max(180, 170, 160, 360, 140)\\,\\text{ps} + 40\\,\\text{ps}$$\n$$T_{clk, base} = 360\\,\\text{ps} + 40\\,\\text{ps} = 400\\,\\text{ps}$$\n\n接下来，我们确定基准设计的 CPI，即 $\\text{CPI}_{base}$。CPI 是理想 CPI（对于流水线来说是 $1$）与每条指令的停顿周期数之和。\n$$\\text{CPI} = 1 + \\text{每指令停顿周期数}$$\n停顿是由加载-使用冒险引起的。比例为 $f = 0.70$ 的指令依赖于紧邻的前一条加载指令，每个这样的冒险导致 $1$ 个周期的停顿。\n$$\\text{每指令停顿周期数} = (\\text{导致停顿的指令比例}) \\times (\\text{每次发生时的停顿周期数})$$\n$$\\text{每指令停顿周期数}_{base} = f \\times 1 = 0.70 \\times 1 = 0.70$$\n因此，基准设计的 CPI 为：\n$$\\text{CPI}_{base} = 1 + 0.70 = 1.70$$\n\n现在，我们分析增强型设计。\nMEM 阶段被拆分为两个相等的阶段，MEM1 和 MEM2。新的流水线有六个阶段：IF、ID、EX、MEM1、MEM2、WB。各阶段延迟为：\n$T_{IF} = 180\\,\\text{ps}$\n$T_{ID} = 170\\,\\text{ps}$\n$T_{EX} = 160\\,\\text{ps}$\n$T_{MEM1} = \\frac{T_{MEM}}{2} = \\frac{360}{2}\\,\\text{ps} = 180\\,\\text{ps}$\n$T_{MEM2} = \\frac{T_{MEM}}{2} = \\frac{360}{2}\\,\\text{ps} = 180\\,\\text{ps}$\n$T_{WB} = 140\\,\\text{ps}$\n\n增强型设计的时钟周期 $T_{clk, enh}$ 由新的阶段延迟集合和相同的锁存器开销 $T_{latch} = 40\\,\\text{ps}$ 决定。\n$$T_{clk, enh} = \\max(180, 170, 160, 180, 180, 140)\\,\\text{ps} + 40\\,\\text{ps}$$\n$$T_{clk, enh} = 180\\,\\text{ps} + 40\\,\\text{ps} = 220\\,\\text{ps}$$\n\n接下来，我们确定增强型设计的 CPI，即 $\\text{CPI}_{enh}$。在这种设计中，存储器的组织方式使得加载的值在 MEM1 阶段结束时就可用，这解决了加载-使用冒险，无需任何停顿。\n$$\\text{每指令停顿周期数}_{enh} = f \\times 0 = 0.70 \\times 0 = 0$$\n因此，增强型设计的 CPI 是理想的：\n$$\\text{CPI}_{enh} = 1 + 0 = 1.00$$\n\n最后，我们可以计算整体加速比 $S$。\n$$S = \\frac{\\text{CPI}_{base} \\times T_{clk, base}}{\\text{CPI}_{enh} \\times T_{clk, enh}} = \\frac{1.70 \\times 400\\,\\text{ps}}{1.00 \\times 220\\,\\text{ps}}$$\n$$S = \\frac{680}{220} = \\frac{68}{22} = \\frac{34}{11}$$\n$$S \\approx 3.090909...$$\n将结果四舍五入到四位有效数字，得到：\n$$S = 3.091$$", "answer": "$$\\boxed{3.091}$$", "id": "3629255"}]}