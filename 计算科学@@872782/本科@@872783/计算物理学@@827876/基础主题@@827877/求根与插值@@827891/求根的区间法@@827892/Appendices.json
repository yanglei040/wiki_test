{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。此练习旨在帮助你理解两种基础的区间套方法——二分法和试位法——在寻找方程根时的核心差异。通过计算并比较两种方法在第一次迭代后得到的近似值，你将直观地体会到它们各自逼近真值的不同策略。[@problem_id:2157489]", "problem": "考虑求解函数 $f(x) = x^3 - 5$ 在区间 $[1, 2]$ 内的根。\n\n用于此任务的两种常见迭代区间法是二分法和试位法（也称为伪位法）。\n\n设 $c_B$ 是对初始区间 $[1, 2]$ 应用一次二分法迭代所得到的根的第一次近似值。\n设 $c_{RF}$ 是对相同的初始区间 $[1, 2]$ 应用一次试位法迭代所得到的根的第一次近似值。\n\n该函数的真实根是 $x_{true} = \\sqrt[3]{5}$。为便于本题计算，您可以使用值 $x_{true} \\approx 1.709976$。\n\n计算这两种方法近似误差之间的绝对差。即，计算 $| |c_B - x_{true}| - |c_{RF} - x_{true}| |$ 的值。将您的最终答案四舍五入到四位有效数字。", "solution": "给定函数 $f(x) = x^{3} - 5$ 在区间 $[1,2]$ 上，有 $f(1) = -4$ 和 $f(2) = 3$，因此根位于 $[1,2]$ 内。\n\n对于一步二分法，中点是\n$$\nc_{B} = \\frac{1 + 2}{2} = \\frac{3}{2}.\n$$\n\n对于从点 $(a,f(a)) = (1,-4)$ 和 $(b,f(b)) = (2,3)$ 出发的一步试位法，线性插值的根是\n$$\nc_{RF} = a - f(a)\\,\\frac{b - a}{f(b) - f(a)} = 1 - (-4)\\,\\frac{2 - 1}{3 - (-4)} = 1 + \\frac{4}{7} = \\frac{11}{7}.\n$$\n\n由于函数 $f$ 在 $[1,2]$ 上是严格递增的，且 $x_{true} \\in [1,2]$，我们有 $c_{B}  x_{true}$ 和 $c_{RF}  x_{true}$，因此\n$$\n|c_{B} - x_{true}| = x_{true} - \\frac{3}{2}, \\quad |c_{RF} - x_{true}| = x_{true} - \\frac{11}{7}.\n$$\n因此，误差的绝对差为\n$$\n\\left||c_{B} - x_{true}| - |c_{RF} - x_{true}|\\right| = \\left|(x_{true} - \\tfrac{3}{2}) - (x_{true} - \\tfrac{11}{7})\\right| = \\left|\\frac{11}{7} - \\frac{3}{2}\\right| = \\left|\\frac{22 - 21}{14}\\right| = \\frac{1}{14}.\n$$\n\n数值上，\n$$\n\\frac{1}{14} \\approx 0.071428571\\ldots,\n$$\n四舍五入到四位有效数字为 $0.07143$。", "answer": "$$\\boxed{0.07143}$$", "id": "2157489"}, {"introduction": "二分法最强大的特性之一是其可预测的、有保证的收敛性。这个练习将带你量化这一特性，计算达到特定精度要求所需的最少迭代次数。掌握这种估算能力对于在实际工程和科学计算中规划计算资源和时间至关重要。[@problem_id:2157533]", "problem": "一位工程师的任务是找到一个复杂的非线性函数 $f(x)=0$ 的一个根，该函数模拟了一个控制系统的行为。根据物理约束可知，所求的根位于区间 $[a, b]$ 内，且区间长度 $L = b - a$ 正好为 $128$。该工程师决定使用二分法来近似求解这个根。为使控制系统正常工作，根的最终近似值的绝对误差必须不大于 $\\epsilon = 0.1$。\n\n为保证近似根满足此误差容限，二分法所需的最小迭代次数 $n$ 是多少？", "solution": "对于二分法，从一个长度为 $L = b - a$ 的初始含根区间开始，经过 $n$ 次迭代后，区间长度为\n$$\nL_{n} = \\frac{L}{2^{n}}.\n$$\n使用该区间的中点作为近似值 $x_{n}$，并且由于真根 $r$ 仍在当前区间内，绝对误差的上界为区间长度的一半：\n$$\n|x_{n} - r| \\le \\frac{L_{n}}{2} = \\frac{L}{2^{n+1}}.\n$$\n为保证误差容限 $|x_{n} - r| \\le \\epsilon$，需要满足\n$$\n\\frac{L}{2^{n+1}} \\le \\epsilon \\quad \\Longleftrightarrow \\quad 2^{n+1} \\ge \\frac{L}{\\epsilon}.\n$$\n当 $L = 128$ 且 $\\epsilon = 0.1$ 时，\n$$\n2^{n+1} \\ge \\frac{128}{0.1} = 1280.\n$$\n由于 $2^{10} = 1024  1280$ 且 $2^{11} = 2048 \\ge 1280$，满足该不等式的最小整数 $n+1$ 是 $11$，因此最小迭代次数 $n$ 是 $10$。", "answer": "$$\\boxed{10}$$", "id": "2157533"}, {"introduction": "在真实世界的科学计算中，我们很少单独使用一种算法，而是常常构建结合多种方法优点的混合算法。这个高级实践挑战你从头开始设计并实现一个混合求根求解器。它将二分法的稳健性（保证收敛）与牛顿-拉弗森法的速度（快速局部收敛）相结合，这正是许多专业数值库中求解器的设计思路。[@problem_id:2377926]", "problem": "您需要实现一种混合区间求根算法，该算法结合了区间二分法保证收敛的特性和牛顿-拉夫逊方法局部快速收敛的特性。该算法必须从一个严格的区间 $\\left[a,b\\right]$ 开始，对于一个连续函数 $f(x)$，该区间满足 $f(a)\\,f(b)  0$，从而应用介值定理。算法必须保持区间不变性，直到满足一个明确定义的切换准则。\n\n从基本原理出发，区间划分阶段基于连续函数 $f(x)$ 在 $\\left[a,b\\right]$ 上的介值定理，通过重复选择符号变化得以保持的子区间来更新区间。牛顿-拉夫逊阶段基于 $f(x)$ 在当前迭代点 $x$ 附近的一阶泰勒线性化，当 $f'(x)$ 非零且初始猜测足够接近时，该迭代会趋近于根。\n\n混合方法的设计要求：\n- 使用一个始终保持 $f(a)\\,f(b)  0$ 的区间划分阶段。持续此阶段，直到当前区间宽度满足 $(b-a) \\le \\delta$，其中 $\\delta  0$ 是一个预设阈值。\n- 一旦 $(b-a) \\le \\delta$，则切换到区间内牛顿-拉夫逊阶段，使用中点 $x=\\frac{a+b}{2}$ 作为初始猜测。仅当 $x_{\\text{new}} \\in (a,b)$ 且 $f'(x)$ 是有限的非零值时，牛顿步 $x_{\\text{new}} = x - \\frac{f(x)}{f'(x)}$ 才可被接受。如果接受条件不满足，则执行二分步骤。在产生候选点 $x_{\\text{new}}$ 后，通过选择保留符号变化的子区间来更新区间 $\\left[a,b\\right]$，然后继续。\n- 终止条件：当 $|f(x)| \\le \\tau_f$ 或 $(b-a) \\le \\tau_x$ 时停止，其中 $\\tau_f  0$ 和 $\\tau_x  0$ 是绝对容差。\n- 任何三角函数的角度必须以弧度为单位。\n- 您的实现必须是确定性的，不得使用随机性。\n\n对所有测试用例，使用以下绝对容差：$\\tau_f = 10^{-12}$ 和 $\\tau_x = 10^{-12}$。为防止无限循环，最多使用 $N_{\\max} = 1000$ 次总迭代。\n\n测试套件规范。实现您的求解器并将其应用于以下五个案例。对于每个案例，请完全按照给定的方式定义 $f(x)$ 及其导数 $f'(x)$。确保初始端点如所述满足 $f(a)\\,f(b)  0$。\n\n- 案例1（多项式，单实根）：\n  - $f_1(x) = x^3 - 2x - 5$\n  - $f_1'(x) = 3x^2 - 2$\n  - $\\left[a,b\\right] = \\left[2,3\\right]$, $\\delta = 10^{-3}$\n\n- 案例2（超越函数，不动点类型，角度以弧度为单位）：\n  - $f_2(x) = \\cos(x) - x$\n  - $f_2'(x) = -\\sin(x) - 1$\n  - $\\left[a,b\\right] = \\left[0,1\\right]$, $\\delta = 10^{-8}$\n\n- 案例3（奇数重根，导数在根处为零）：\n  - $f_3(x) = (x - 1)^3$\n  - $f_3'(x) = 3(x - 1)^2$\n  - $\\left[a,b\\right] = \\left[0.5,2.0\\right]$, $\\delta = 10^{-4}$\n\n- 案例4（初始宽度等于阈值的立即切换边界）：\n  - $f_4(x) = e^x - 3$\n  - $f_4'(x) = e^x$\n  - $\\left[a,b\\right] = \\left[1.0,1.1\\right]$, $\\delta = 10^{-1}$\n\n- 案例5（根在中点，在区间划分阶段精确检测）：\n  - $f_5(x) = x^3$\n  - $f_5'(x) = 3x^2$\n  - $\\left[a,b\\right] = \\left[-10^{-1},10^{-1}\\right]$, $\\delta = 10^{-6}$\n\n所有函数在各自的区间上都是连续的，对于案例1、2、3和5，端点满足 $f(a)\\,f(b)  0$。对于案例4，初始区间宽度恰好等于 $\\delta$。\n\n要求的输出：\n- 对每个案例，以浮点数形式输出计算出的根的近似值。在适用情况下，角度以弧度表示。不涉及物理单位。\n- 使用定点格式将每个根四舍五入到小数点后恰好 $12$ 位。\n- 您的程序应生成单行输出，其中包含按案例1到5顺序排列的结果，格式为方括号括起来的逗号分隔列表（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$）。", "solution": "所提出的问题是计算物理学领域一个适定且有科学依据的任务。它要求实现一种混合求根算法，该算法协同了二分法保证收敛的特性与牛顿-拉夫逊方法二次收敛的特性。问题陈述完整、一致，并为一组测试案例提供了所有必要的参数、初始条件、函数及其导数。因此，该问题被认为是有效的。\n\n问题的核心是设计一种算法，在初始区间 $[a, b]$ 内定位连续函数 $f(x)$ 的一个根，其中条件 $f(a)f(b)  0$ 成立。根据介值定理，此条件保证了该区间内至少存在一个根。该算法必须分两个阶段运行，由当前区间宽度 $(b-a)$ 相对于指定阈值 $\\delta  0$ 的大小决定。\n\n让我们逐步形式化该算法。\n\n1.  **初始化**：\n    算法始于一个初始区间 $[a, b]$、一个连续函数 $f(x)$ 及其导数 $f'(x)$、一个切换阈值 $\\delta$、收敛容差 $\\tau_f$ 和 $\\tau_x$，以及最大迭代次数 $N_{\\max}$。我们首先计算端点处的函数值 $f_a = f(a)$ 和 $f_b = f(b)$，并确认根在区间内，即 $f_a f_b  0$。如果 $f_a$ 或 $f_b$ 为零，则立即找到根。\n\n2.  **迭代求精循环**：\n    该过程进行迭代，不断缩小区间 $[a, b]$，直到满足终止条件或达到最大迭代次数 $N_{\\max}$。在每次迭代开始时，我们根据区间宽度检查终止条件：如果 $(b-a) \\le \\tau_x$，则过程停止，根的最佳估计值为最终区间的中点 $\\frac{a+b}{2}$。\n\n3.  **阶段确定与选点**：\n    混合策略的核心在于下一个候选点的选择，这取决于当前的区间宽度。\n    -   **阶段1：二分法 ($ (b-a)  \\delta $)**\n        如果区间较宽，我们处于区间划分阶段。收敛是保证的但速度较慢。我们使用二分法，选择区间的中点作为下一个候选点：\n        $$x_{\\text{next}} = \\frac{a+b}{2}$$\n    -   **阶段2：混合牛顿-拉夫逊/二分法 ($ (b-a) \\le \\delta $)**\n        一旦区间足够窄，我们切换到一种更激进的策略以加速收敛。\n        a. 牛顿-拉夫逊方法的初始猜测取为当前区间的中点 $x_k = \\frac{a+b}{2}$。\n        b. 我们计算导数 $f'(x_k)$。为使牛顿-拉夫逊步有效，导数必须是有限且非零的。\n        c. 如果导数有效，我们计算牛顿-拉夫逊更新：\n        $$x_{\\text{Newton}} = x_k - \\frac{f(x_k)}{f'(x_k)}$$\n        d. 这个新点 $x_{\\text{Newton}}$ 仅在它严格位于当前区间内时才被接受，即 $x_{\\text{Newton}} \\in (a, b)$。这一保障措施防止迭代跳出已知存在根的区域。\n        e. 如果牛顿-拉夫逊步被接受，我们设置 $x_{\\text{next}} = x_{\\text{Newton}}$。\n        f. 如果牛顿-拉夫逊步的任何条件失败（导数为零或非有限，或新点越界），算法必须在当前迭代回退到安全的二分步骤。在这种情况下，我们设置 $x_{\\text{next}} = \\frac{a+b}{2}$。\n\n4.  **区间更新与终止检查**：\n    在确定 $x_{\\text{next}}$（通过二分法或牛顿-拉夫逊法）后，我们计算 $f_{\\text{next}} = f(x_{\\text{next}})$。\n    - 我们根据函数值检查终止条件：如果 $|f_{\\text{next}}| \\le \\tau_f$，则认为找到了根，并返回 $x_{\\text{next}}$。\n    - 如果过程尚未终止，我们更新区间。我们使用 $f_{\\text{next}}$ 的符号来确定哪个子区间 $[a, x_{\\text{next}}]$ 或 $[x_{\\text{next}}, b]$ 包含根。\n        - 如果 $f(a)f(x_{\\text{next}})  0$，根位于前半部分，因此我们将新区间设为 $[a, x_{\\text{next}}]$，即更新 $b = x_{\\text{next}}$。\n        - 否则，根必位于后半部分（因为最初 $f(a)f(b)$ 为负），因此我们将新区间设为 $[x_{\\text{next}}, b]$，即更新 $a = x_{\\text{next}}$。\n    然后循环使用新的、更窄的区间继续进行。\n\n5.  **最终处理**：\n    如果循环完成 $N_{\\max}$ 次迭代仍未满足 $\\tau_f$ 或 $\\tau_x$ 容差，算法终止并返回最后计算区间的中点 $\\frac{a+b}{2}$，作为可用的最佳根近似值。\n\n这种设计确保了鲁棒性和效率。初始的二分阶段可靠地缩小了搜索空间，随后切换到带有保障措施的牛顿-拉夫逊方法，在迭代点足够接近根时提供了快速收敛。回退到二分法是一个关键的安全机制，即使在牛顿法会失败的情况下（例如，在导数为零的根附近，如案例3中 $f_3'(1)=0$），或步长过大时，也能保持收敛的保证。该实现将应用于指定的五个测试案例。", "answer": "```python\nimport numpy as np\n\ndef hybrid_root_finder(f, df, a, b, delta, tau_f, tau_x, n_max):\n    \"\"\"\n    Finds a root of a function using a hybrid bisection-Newton-Raphson method.\n\n    Args:\n        f (callable): The function for which to find a root.\n        df (callable): The derivative of the function f.\n        a (float): The lower bound of the initial bracket.\n        b (float): The upper bound of the initial bracket.\n        delta (float): The bracket width threshold to switch to Newton's method.\n        tau_f (float): The absolute tolerance for the function value.\n        tau_x (float): The absolute tolerance for the bracket width.\n        n_max (int): The maximum number of iterations.\n\n    Returns:\n        float: The approximation of the root.\n    \"\"\"\n    fa = f(a)\n    fb = f(b)\n\n    if np.sign(fa) == np.sign(fb):\n        # As per problem specification, initial brackets are valid.\n        # This check is for general robustness.\n        raise ValueError(\"Root not bracketed or multiple roots in bracket.\")\n\n    if abs(fa) = tau_f:\n        return a\n    if abs(fb) = tau_f:\n        return b\n\n    for _ in range(n_max):\n        # Termination condition 1: Bracket width is smaller than tolerance.\n        if (b - a) = tau_x:\n            return (a + b) / 2\n\n        x_next = None\n\n        # Check for switching condition to attempt Newton-Raphson.\n        if (b - a) = delta:\n            # Candidate for Newton's method is the midpoint.\n            x_mid = (a + b) / 2\n            f_mid = f(x_mid)\n\n            # Termination condition 2: Function value at midpoint is small enough.\n            if abs(f_mid) = tau_f:\n                return x_mid\n\n            df_mid = df(x_mid)\n\n            # Check if Newton step is valid and safe.\n            if df_mid != 0 and np.isfinite(df_mid):\n                x_newton = x_mid - f_mid / df_mid\n                # Accept step only if it's within the current bracket.\n                if a  x_newton  b:\n                    x_next = x_newton\n\n        # If Newton step was not attempted or failed, fall back to bisection.\n        if x_next is None:\n            x_next = (a + b) / 2\n\n        f_next = f(x_next)\n\n        # Termination condition 3: Function value at the new point is small enough.\n        if abs(f_next) = tau_f:\n            return x_next\n\n        # Update the bracket to maintain the sign change.\n        if np.sign(fa) * np.sign(f_next)  0:\n            b = x_next\n            fb = f_next\n        else:\n            a = x_next\n            fa = f_next\n    \n    # If max iterations reached, return the midpoint of the final bracket.\n    return (a + b) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define global tolerances and maximum iterations.\n    tau_f = 1e-12\n    tau_x = 1e-12\n    n_max = 1000\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda x: x**3 - 2*x - 5,\n            \"df\": lambda x: 3*x**2 - 2,\n            \"a\": 2.0, \"b\": 3.0, \"delta\": 1e-3\n        },\n        {\n            \"f\": lambda x: np.cos(x) - x,\n            \"df\": lambda x: -np.sin(x) - 1,\n            \"a\": 0.0, \"b\": 1.0, \"delta\": 1e-8\n        },\n        {\n            \"f\": lambda x: (x - 1)**3,\n            \"df\": lambda x: 3*(x - 1)**2,\n            \"a\": 0.5, \"b\": 2.0, \"delta\": 1e-4\n        },\n        {\n            \"f\": lambda x: np.exp(x) - 3,\n            \"df\": lambda x: np.exp(x),\n            \"a\": 1.0, \"b\": 1.1, \"delta\": 1e-1\n        },\n        {\n            \"f\": lambda x: x**3,\n            \"df\": lambda x: 3*x**2,\n            \"a\": -1e-1, \"b\": 1e-1, \"delta\": 1e-6\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        root = hybrid_root_finder(\n            f=case[\"f\"],\n            df=case[\"df\"],\n            a=case[\"a\"],\n            b=case[\"b\"],\n            delta=case[\"delta\"],\n            tau_f=tau_f,\n            tau_x=tau_x,\n            n_max=n_max\n        )\n        # Format result to 12 decimal places as a fixed-point string.\n        results.append(f\"{root:.12f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2377926"}]}