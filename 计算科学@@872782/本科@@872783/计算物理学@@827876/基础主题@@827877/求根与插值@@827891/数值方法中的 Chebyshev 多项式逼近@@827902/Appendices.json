{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式莫过于动手实践。本节的第一个练习将从一个直观的信号处理问题入手，我们将探索如何将任何一维信号——比如图像中的一行像素——分解为由切比雪夫多项式表示的基本“振动”模式。通过这个练习，你将亲身体会到切比雪夫近似对于平滑函数的强大效率，并理解它如何捕捉函数的变化特征。[@problem_id:2379175]", "problem": "构建一个程序，对于给定的一维像素强度序列，计算其在第一类 Chebyshev 多项式基下的展开，并量化截断级数的影响。令 $M$ 表示单行中的像素数量，像素索引为 $i \\in \\{0,1,\\dots,M-1\\}$。通过 $x_i = -1 + \\frac{2 i}{M-1}$ 对所有 $i$ 将像素位置映射到 Chebyshev 区间。令 $\\{T_k(x)\\}_{k \\ge 0}$ 表示在区间 $[-1,1]$ 上由递推关系 $T_0(x) = 1$，$T_1(x) = x$，以及当 $k \\ge 1$ 时 $T_{k+1}(x) = 2 x T_k(x) - T_{k-1}(x)$ 定义的第一类 Chebyshev 多项式。对于给定的整数截断阶数 $N \\ge 0$，用多项式 $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$ 来近似一个像素行，其系数 $\\{c_k\\}_{k=0}^{N}$ 使得关于给定像素强度 $\\{y_i\\}_{i=0}^{M-1}$ 的离散平方误差 $\\sum_{i=0}^{M-1} (p_N(x_i) - y_i)^2$ 最小化。通过由 $\\mathrm{RMSE}(N) = \\sqrt{\\frac{1}{M} \\sum_{i=0}^{M-1} (p_N(x_i) - y_i)^2}$ 定义的均方根误差 (RMSE) 来量化近似质量。所有三角函数的参数都应理解为弧度。\n\n使用以下测试套件。在每个测试用例中，令 $M = 64$ 并如上定义 $x_i$。对于每个测试用例，计算截断阶数 $N \\in \\{0,1,3,7,15,31\\}$ 时的 $\\mathrm{RMSE}(N)$。\n\n测试用例 $1$（平滑，中低频内容）：\n- 像素强度：对所有 $i$，有 $y_i = 0.5 + 0.4 \\cos(\\pi x_i) + 0.1 \\cos(5 \\pi x_i)$。\n\n测试用例 $2$（阶跃边缘）：\n- 像素强度：对所有 $i$，如果 $x_i < 0$，则 $y_i = 0.1$；如果 $x_i \\ge 0$，则 $y_i = 0.9$。\n\n测试用例 $3$（高频振荡）：\n- 像素强度：对所有 $i$，有 $y_i = 0.5 + 0.45 \\cos(15 \\pi x_i)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，其顺序和结构如下：一个长度为 $3$ 的外层列表，按上文给出的顺序对应三个测试用例，其中每个元素是一个长度为 $6$ 的内层列表，按 $N \\in \\{0,1,3,7,15,31\\}$ 的顺序包含 $6$ 个 $\\mathrm{RMSE}(N)$ 值。例如，格式必须严格为 $[[r_{1,1},r_{1,2},r_{1,3},r_{1,4},r_{1,5},r_{1,6}],[r_{2,1},\\dots,r_{2,6}],[r_{3,1},\\dots,r_{3,6}]]$ 的形式，其中每个 $r_{j,\\ell}$ 是一个实数。", "solution": "所述问题具有科学依据、提法恰当且客观。它构成了数值逼近理论中的一个标准问题，而数值逼近理论是计算物理学的一个基本组成部分。所有参数和目标都已足够严谨地定义。因此，我们着手推导解决方案。\n\n目标是用一个 $N$ 阶截断 Chebyshev 级数来近似在网格点 $\\{x_i\\}_{i=0}^{M-1}$ 上定义的离散信号 $\\{y_i\\}_{i=0}^{M-1}$。该近似是一个多项式 $p_N(x) = \\sum_{k=0}^{N} c_k T_k(x)$，其中 $T_k(x)$ 是 $k$ 阶的第一类 Chebyshev 多项式。必须选择系数 $\\{c_k\\}_{k=0}^{N}$ 以最小化离散平方误差 $S$：\n$$\nS = \\sum_{i=0}^{M-1} \\left(p_N(x_i) - y_i\\right)^2 = \\sum_{i=0}^{M-1} \\left(\\left(\\sum_{k=0}^{N} c_k T_k(x_i)\\right) - y_i\\right)^2\n$$\n这是一个经典的线性最小二乘问题。我们可以用矩阵-向量表示法来表达它。令 $\\mathbf{y} \\in \\mathbb{R}^M$ 为像素强度的列向量，$\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$。令 $\\mathbf{c} \\in \\mathbb{R}^{N+1}$ 为未知系数的列向量，$\\mathbf{c} = [c_0, c_1, \\dots, c_N]^T$。我们定义一个矩阵 $\\mathbf{A} \\in \\mathbb{R}^{M \\times (N+1)}$，其元素由基函数在网格点上的值给出：\n$$\nA_{ik} = T_k(x_i) \\quad \\text{for } i \\in \\{0, \\dots, M-1\\}, k \\in \\{0, \\dots, N\\}\n$$\n在网格点上的近似值向量则由矩阵-向量乘积 $\\mathbf{p}_N = \\mathbf{A}\\mathbf{c}$ 给出。平方误差和 $S$ 是残差向量 $\\mathbf{r} = \\mathbf{A}\\mathbf{c} - \\mathbf{y}$ 的欧几里得范数的平方：\n$$\nS = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2\n$$\n使该量最小化的系数向量 $\\mathbf{c}$ 是最小二乘解。它由正规方程组的解正式给出：\n$$\n(\\mathbf{A}^T \\mathbf{A}) \\mathbf{c} = \\mathbf{A}^T \\mathbf{y}\n$$\n为了数值稳定性，尤其是在 $\\mathbf{A}$ 的列向量近似线性相关时，不建议构造和求逆矩阵 $\\mathbf{A}^T \\mathbf{A}$。相反，应该采用如 QR 分解或奇异值分解 (SVD) 等稳健的数值方法。标准的数值库提供了实现这些稳定算法的求解器。\n\n指定的网格点 $x_i = -1 + \\frac{2i}{M-1}$ 是均匀分布的。它们不是 Chebyshev 节点（$T_M(x)$ 的根或极值点）。因此，基向量 $\\{ \\mathbf{v}_k \\}_{k=0}^N$（其中 $(\\mathbf{v}_k)_i = T_k(x_i)$）关于标准点积不是正交的。这需要求解一个一般的最小二乘系统，而不是简单地将数据投影到基向量上（如果基是正交的，这才是可行的）。\n\n计算每个测试用例所需均方根误差 (RMSE) 的算法如下：\n$1$. 设置像素数 $M=64$。定义截断阶数集合 $N \\in \\{0, 1, 3, 7, 15, 31\\}$。\n$2$. 构建网格点向量 $\\mathbf{x} = [x_0, x_1, \\dots, x_{M-1}]^T$，其中 $x_i = -1 + \\frac{2i}{M-1}$。\n$3$. 对于每个测试用例，根据其指定的函数生成像素强度向量 $\\mathbf{y} = [y_0, y_1, \\dots, y_{M-1}]^T$。\n$4$. 对于指定集合中的每个截断阶数 $N$：\n    a. 构建 $M \\times (N+1)$ 矩阵 $\\mathbf{A}$。$\\mathbf{A}$ 的列是在网格点上求值的 Chebyshev 多项式。它们是使用递推关系生成的：\n    $$\n    T_0(x) = 1\n    $$\n    $$\n    T_1(x) = x\n    $$\n    $$\n    T_{k+1}(x) = 2x T_k(x) - T_{k-1}(x) \\quad \\text{for } k \\ge 1\n    $$\n    $\\mathbf{A}$ 的第 $k$ 列是向量 $[T_k(x_0), T_k(x_1), \\dots, T_k(x_{M-1})]^T$。\n    b. 求解线性最小二乘问题 $\\mathbf{A}\\mathbf{c} \\approx \\mathbf{y}$ 以找到最优系数向量 $\\mathbf{c}$。这将得到最小残差平方和，$S_{min} = \\|\\mathbf{A}\\mathbf{c} - \\mathbf{y}\\|_2^2$。\n    c. 使用均方根误差计算近似质量：\n    $$\n    \\mathrm{RMSE}(N) = \\sqrt{\\frac{1}{M} \\sum_{i=0}^{M-1} (p_N(x_i) - y_i)^2} = \\sqrt{\\frac{S_{min}}{M}}\n    $$\n$5$. 收集每个测试用例的 $\\mathrm{RMSE}(N)$ 值，并按规定格式化输出。\n\n预计 $\\mathrm{RMSE}(N)$ 的行为在不同测试用例之间会有显著差异。对于测试用例 $1$ 中的平滑低频函数，Chebyshev 级数应非常迅速地收敛，导致 $\\mathrm{RMSE}(N)$ 随着 $N$ 的增加而快速减小。对于测试用例 $2$ 中的阶跃函数，不连续点的存在将导致 Gibbs 现象和缓慢收敛；$\\mathrm{RMSE}(N)$ 的减小速度会慢得多。对于测试用例 $3$ 中的高频函数，当 $N$ 较小时，近似效果会很差，但一旦 $N$ 大到足以分辨振荡（即当 $N$ 与余弦函数参数除以 $\\pi$ 的结果相当时），近似效果应会显著改善。现在将实施此过程。", "answer": "```python\nimport numpy as np\n\ndef build_chebyshev_matrix(x, n_degree):\n    \"\"\"\n    Constructs the design matrix A_ik = T_k(x_i) for k=0...n_degree.\n    \n    Args:\n        x (np.ndarray): Array of points of shape (M,).\n        n_degree (int): The maximum degree N of the Chebyshev polynomials.\n\n    Returns:\n        np.ndarray: The design matrix A of shape (M, N+1).\n    \"\"\"\n    m_pixels = len(x)\n    A = np.zeros((m_pixels, n_degree + 1))\n    \n    # T_0(x) = 1\n    A[:, 0] = 1.0\n    \n    if n_degree > 0:\n        # T_1(x) = x\n        A[:, 1] = x\n    \n    # T_{k+1}(x) = 2*x*T_k(x) - T_{k-1}(x)\n    for k in range(1, n_degree):\n        A[:, k + 1] = 2 * x * A[:, k] - A[:, k - 1]\n        \n    return A\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute RMSE values.\n    \"\"\"\n    M = 64\n    N_degrees = [0, 1, 3, 7, 15, 31]\n    \n    x = -1.0 + 2.0 * np.arange(M) / (M - 1.0)\n    \n    # Define test case functions\n    def case1_func(x_pts):\n        return 0.5 + 0.4 * np.cos(np.pi * x_pts) + 0.1 * np.cos(5 * np.pi * x_pts)\n        \n    def case2_func(x_pts):\n        y = np.full_like(x_pts, 0.9)\n        y[x_pts  0] = 0.1\n        return y\n        \n    def case3_func(x_pts):\n        return 0.5 + 0.45 * np.cos(15 * np.pi * x_pts)\n\n    test_cases = [\n        case1_func,\n        case2_func,\n        case3_func\n    ]\n\n    all_results = []\n    \n    for case_func in test_cases:\n        y = case_func(x)\n        case_results = []\n        for N in N_degrees:\n            A = build_chebyshev_matrix(x, N)\n            \n            # Solve the least-squares problem.\n            # `lstsq` returns coefficients, residuals, rank, and singular values.\n            # The 'residuals' is a one-element array containing the sum of squared errors.\n            _coeffs, residuals, _rank, _s = np.linalg.lstsq(A, y, rcond=None)\n            \n            # If the system is full rank, `residuals` contains the sum of squared errors.\n            if residuals.size > 0:\n                sum_sq_res = residuals[0]\n            else:\n                # If no solution or system is rank deficient, calculate manually.\n                p_N = A @ _coeffs\n                sum_sq_res = np.sum((p_N - y)**2)\n\n            rmse = np.sqrt(sum_sq_res / M)\n            case_results.append(rmse)\n        \n        all_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    outer_list_str = []\n    for res_list in all_results:\n      # Use a general format specifier to avoid trailing zeros and ensure precision.\n      inner_list_str = \",\".join(format(n, 'g') for n in res_list)\n      outer_list_str.append(f\"[{inner_list_str}]\")\n    final_output = f\"[{','.join(outer_list_str)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "2379175"}, {"introduction": "在掌握了函数近似的基础后，我们可以更进一步，利用近似来求解未知量。这个练习将带领我们解决一个现代物理学的基石问题：通过求解普朗克定律导出的一个复杂方程来确定黑体辐射的峰值波长。通过用切比雪夫多项式近似这个超越方程，我们可以将其转化为一个容易求解的代数问题，从而揭示维恩位移定律背后的常数，这展示了一种解决无解析解问题的强大数值策略。[@problem_id:2379178]", "problem": "您将实现一个完整的程序，该程序通过构建和求解一个由最大化光谱辐射率（相对于波长）而产生的超越平稳性条件的根的切比雪夫多项式近似，来模拟黑体辐射的峰值波长 $\\lambda_{\\max}(T)$（单位为米）作为绝对温度 $T$（单位为开尔文）的函数。请仅从以下基础出发：黑体的普朗克单位波长光谱辐射率，由下式给出\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1},\n$$\n其中 $h$ 是普朗克常数（单位为焦耳-秒），$c$ 是真空中的光速（单位为米/秒），$k_{\\mathrm{B}}$ 是玻尔兹曼常数（单位为焦耳/开尔文）。峰值波长 $\\lambda_{\\max}(T)$ 是在固定温度 $T$ 下使 $B_{\\lambda}(\\lambda, T)$ 最大化的 $\\lambda$ 值。\n\n您的任务是：\n- 从平稳性条件 $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda}(\\lambda, T) = 0$ 出发，并使用一个合适的正无量纲变量 $x$ 进行无量纲化，推导出一个关于 $x$ 的超越方程。该方程的唯一正根通过 $\\lambda_{\\max}(T) = \\frac{b}{T}$ 决定峰值，其中 $b$ 是一个仅依赖于基本常数和根 $x$ 的常数。\n- 为超越方程的左侧构建一个在闭区间 $[x_{\\min}, x_{\\max}]$ 上的 $n$ 次切比雪夫多项式近似 $p_{n}(x)$，该区间包含唯一的正根。您必须使用 $[-1,1]$ 上的切比雪夫多项式，并通过仿射映射转换到 $[x_{\\min}, x_{\\max}]$。选择一个多项式次数 $n \\geq 12$ 和一个与切比雪夫近似一致的采样策略（例如，映射的切比雪夫节点）。然后通过求解 $p_{n}(x) = 0$ 来近似根 $x^{\\star}$，并选择在 $[x_{\\min}, x_{\\max}]$ 内具有物理意义的实根。\n- 使用得到的近似根 $x^{\\star}$，计算常数 $b$，然后为每个测试温度计算 $\\lambda_{\\max}(T)$。\n\n物理单位和角度规定：\n- 所有波长必须以米表示。\n- 所有温度均为开尔文。\n- 此任务不涉及角度。\n\n测试套件：\n- 使用以下温度（开尔文）：$[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$。\n- 对于列表中的每个温度 $T$，计算 $\\lambda_{\\max}(T)$（单位为米）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个值均以科学记数法表示，并保留 $12$ 位有效数字。例如：`[1.23456789012e-03,2.34567890123e-04,...]`。\n- 最终输出必须与测试套件温度的顺序相同。\n\n您的解决方案必须是一个单一、自包含、可运行的程序，它执行推导的计算结果、构建切比雪夫近似、求解近似根，并以指定格式打印最终列表。不允许用户输入。所有常数必须在程序中使用国际公认的国际单位制 (SI) 值进行定义。", "solution": "所述问题是有效的。它在科学上基于量子力学和统计物理学的原理，特别是普朗克的黑体辐射定律。该问题定义明确、客观，并提供了一条清晰、可形式化的路径，以使用计算物理学中的标准数值方法获得唯一解。其中没有矛盾、歧义或事实不准确之处。因此，我们可以着手解决。\n\n目标是确定在给定绝对温度 $T$ 下黑体的峰值发射波长 $\\lambda_{\\max}(T)$。该波长使普朗克光谱辐射率函数 $B_{\\lambda}(\\lambda, T)$ 最大化。起点是给定的 $B_{\\lambda}(\\lambda, T)$ 表达式：\n$$\nB_{\\lambda}(\\lambda, T) = \\frac{2 h c^{2}}{\\lambda^{5}} \\cdot \\frac{1}{\\exp\\left(\\frac{h c}{\\lambda k_{\\mathrm{B}} T}\\right) - 1}\n$$\n其中 $h$ 是普朗克常数， $c$ 是光速， $k_{\\mathrm{B}}$ 是玻尔兹曼常数。\n\n为了找到最大值，我们必须求解平稳性条件 $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = 0$。为方便起见，我们定义一个常数 $A = 2hc^2$ 和一个无量纲变量 $x = \\frac{hc}{\\lambda k_{\\mathrm{B}} T}$。辐射率函数可以写成：\n$$\nB_{\\lambda}(\\lambda, T) = A \\lambda^{-5} \\left(e^{x} - 1\\right)^{-1}\n$$\n我们对 $\\lambda$ 应用乘积法则求导。注意 $x$ 是 $\\lambda$ 的函数。\n$$\n\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = A \\left[ \\left(\\frac{d}{d\\lambda}\\lambda^{-5}\\right) \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\left(\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1}\\right) \\right] = 0\n$$\n各项导数分别为：\n$$\n\\frac{d}{d\\lambda}\\lambda^{-5} = -5\\lambda^{-6}\n$$\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = -1 \\left(e^{x} - 1\\right)^{-2} e^{x} \\frac{dx}{d\\lambda}\n$$\n$x$ 对 $\\lambda$ 的导数为：\n$$\n\\frac{dx}{d\\lambda} = \\frac{d}{d\\lambda} \\left(\\frac{hc}{\\lambda k_{\\mathrm{B}} T}\\right) = \\frac{hc}{k_{\\mathrm{B}} T} \\left(-\\frac{1}{\\lambda^2}\\right) = -\\frac{x}{\\lambda}\n$$\n将此代回，我们得到：\n$$\n\\frac{d}{d\\lambda}\\left(e^{x} - 1\\right)^{-1} = - \\left(e^{x} - 1\\right)^{-2} e^{x} \\left(-\\frac{x}{\\lambda}\\right) = \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2}\n$$\n现在我们组合平稳性条件：\n$$\nA \\left[ -5\\lambda^{-6} \\left(e^{x} - 1\\right)^{-1} + \\lambda^{-5} \\frac{x e^{x}}{\\lambda (e^{x} - 1)^2} \\right] = 0\n$$\n将整个方程乘以非零因子 $\\frac{\\lambda^6 (e^x - 1)^2}{A}$ 可简化表达式：\n$$\n-5(e^x - 1) + \\lambda \\frac{x e^x}{\\lambda} = 0\n$$\n$$\n-5e^x + 5 + x e^x = 0\n$$\n这可以重写为我们必须求解 $x$ 的超越方程的最终形式：\n$$\nf(x) = (x-5)e^x + 5 = 0\n$$\n该方程的根，我们称之为 $x^{\\star}$，决定了 $\\lambda_{\\max}$ 和 $T$ 之间的关系。根据 $x$ 的定义，我们有 $\\lambda_{\\max} = \\frac{hc}{x^{\\star} k_{\\mathrm{B}} T}$。这正是维恩位移定律，$\\lambda_{\\max}(T) = \\frac{b}{T}$，其中常数 $b$ 由 $b = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}$ 给出。\n\n为了找到 $x^{\\star}$，我们首先对根进行定位。在简单的整数值处评估函数 $f(x)$：\n$f(4) = (4-5)e^4 + 5 = -e^4 + 5 \\approx -54.6 + 5  0$。\n$f(5) = (5-5)e^5 + 5 = 5  0$。\n导数为 $f'(x) = e^x + (x-5)e^x = (x-4)e^x$。对于 $x  4$，$f'(x)  0$，因此函数在区间 $[4, 5]$ 上是连续且严格递增的。这保证了在该区间内存在唯一的根。因此，我们选择 $[x_{\\min}, x_{\\max}] = [4, 5]$ 作为近似域。\n\n按照问题要求，我们为函数 $f(x)$ 在区间 $[4, 5]$ 上构建一个切比雪夫多项式近似 $p_n(x)$。我们选择次数 $n = 20$，这大于要求的最小值 $n=12$。该近似是通过插值构建的。具体来说，我们在区间 $[4, 5]$ 上的 $N = n+1 = 21$ 个第一类切比雪夫节点处评估 $f(x)$。这些节点 $x_k$ 是通过从 $[-1, 1]$ 上的规范节点 $z_k$ 进行仿射映射得到的：\n$$\nz_k = \\cos\\left(\\frac{2k+1}{2N}\\pi\\right), \\quad k = 0, 1, \\dots, n\n$$\n$$\nx_k = \\frac{x_{\\max} - x_{\\min}}{2} z_k + \\frac{x_{\\max} + x_{\\min}}{2} = 0.5 z_k + 4.5\n$$\n切比雪夫插值多项式 $p_n(x)$ 是次数最多为 $n$ 的唯一多项式，它对所有 $k=0, \\dots, n$ 满足 $p_n(x_k) = f(x_k)$。现代数值库提供了稳健的例程来计算该多项式的系数。\n然后通过求解多项式方程 $p_n(x) = 0$ 来找到近似根 $x^{\\star}$。这是一个标准的代数过程。从得到的根中，我们选择位于我们所选区间 $[4, 5]$ 内的实根。\n\n利用数值方法得到的高精度 $x^{\\star}$ 值，我们计算维恩常数：\n$$\nb = \\frac{hc}{x^{\\star} k_{\\mathrm{B}}}\n$$\n使用 2018 年 CODATA 值的物理常数 $h$、$c$ 和 $k_{\\mathrm{B}}$。最后，对于测试套件 $[\\,2.7255,\\;300.0,\\;1000.0,\\;3000.0,\\;5772.0,\\;10000.0\\,]$ 中的每个温度 $T$，我们计算峰值波长：\n$$\n\\lambda_{\\max}(T) = \\frac{b}{T}\n$$\n实现过程将以计算方式执行这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the peak wavelength of black-body radiation using a Chebyshev approximation.\n\n    The method involves:\n    1. Defining the transcendental equation derived from Planck's law's stationarity condition.\n    2. Constructing a Chebyshev polynomial approximation of the function in this equation.\n    3. Finding the relevant root of the polynomial to approximate the true root x_star.\n    4. Using x_star to compute Wien's displacement constant, b.\n    5. Calculating the peak wavelength lambda_max = b/T for a set of test temperatures.\n    \"\"\"\n\n    # Physical constants (2018 CODATA values, SI units)\n    # h: Planck's constant in J·s\n    # c: Speed of light in vacuum in m/s\n    # k_B: Boltzmann constant in J/K\n    h = 6.62607015e-34\n    c = 299792458.0\n    k_B = 1.380649e-23\n\n    # Test suite temperatures in Kelvin\n    temperatures = np.array([2.7255, 300.0, 1000.0, 3000.0, 5772.0, 10000.0])\n\n    # Transcendental function f(x) = (x-5)exp(x) + 5, whose root we need to find.\n    def f(x):\n        return (x - 5.0) * np.exp(x) + 5.0\n\n    # Step 1: Set up Chebyshev approximation\n    # Degree of the polynomial (n >= 12)\n    degree = 20\n    # Interval [xmin, xmax] known to contain the root\n    xmin, xmax = 4.0, 5.0\n    \n    # Step 2: Construct the Chebyshev polynomial interpolant\n    # We interpolate f(x) at the Chebyshev nodes of the first kind.\n    # We need degree + 1 points to define a polynomial of degree `degree`.\n    num_points = degree + 1\n    \n    # Generate Chebyshev nodes of the first kind in the canonical interval [-1, 1]\n    # These are the roots of the Chebyshev polynomial T_{num_points}(z).\n    z_nodes = np.cos(np.pi * (2 * np.arange(num_points) + 1) / (2 * num_points))\n    \n    # Map nodes to the approximation interval [xmin, xmax]\n    x_nodes = (xmax - xmin) / 2.0 * z_nodes + (xmax + xmin) / 2.0\n    \n    # Evaluate the function at these nodes\n    y_values = f(x_nodes)\n    \n    # Use numpy's Chebyshev.fit to create the polynomial approximation.\n    # The `domain` parameter correctly maps the problem domain to the canonical window [-1, 1].\n    p_cheb = np.polynomial.chebyshev.Chebyshev.fit(x_nodes, y_values, degree, domain=[xmin, xmax])\n\n    # Step 3: Find the approximate root x_star\n    # Find all roots of the polynomial approximation.\n    roots = p_cheb.roots()\n    \n    # Filter the roots to find the unique real root within our interval [xmin, xmax].\n    x_star = None\n    for r in roots:\n        # We are only interested in real roots.\n        if np.isreal(r):\n            real_r = np.real(r)\n            # Check if the root is within the physically meaningful interval.\n            if xmin = real_r = xmax:\n                x_star = real_r\n                break\n    \n    if x_star is None:\n        # This guard is for robustness; with a good approximation, a root must be found.\n        raise RuntimeError(\"Could not find the root in the specified interval.\")\n\n    # Step 4: Compute Wien's displacement constant, b\n    b = (h * c) / (x_star * k_B)\n    \n    # Step 5: Compute lambda_max for each temperature in the test suite\n    results = []\n    for T in temperatures:\n        lambda_max = b / T\n        results.append(lambda_max)\n    \n    # Final print statement in the exact required format.\n    # Format each result to scientific notation with 12 significant digits.\n    # The format code \"{:.11e}\" provides 1 digit before the decimal point and 11 after.\n    formatted_results = [f\"{val:.11e}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2379178"}, {"introduction": "最后，我们将把所学技能应用于一个更真实的物理建模场景。亥姆霍兹线圈是实验室中用于产生均匀磁场的常用设备，本练习要求你基于毕奥-萨伐尔定律为其轴线上方的磁场建立模型。你将使用切比雪夫近似来创建一个高效且精确的场模型，甚至能够分析当线圈参数存在微小差异（例如半径或电流不匹配）等真实世界的不完美情况时，磁场会如何变化。[@problem_id:2379180]", "problem": "您的任务是开发、论证并实现一种数值方法，使用切比雪夫多项式近似来计算轻微非理想亥姆霍兹线圈对的轴上磁场。物理模型基于静磁学和 Biot–Savart 定律，近似方法必须使用第一类 Chebyshev 多项式。您的程序必须计算 Chebyshev 多项式近似（在指定区间上）相对于精确轴上磁场的最大绝对一致误差，并报告一组测试用例的这些误差。\n\n假设与基本原理：\n- Biot–Savart 定律决定了由稳恒电流产生的磁场，通过对称性，单个圆形线圈的轴上磁场可以简化为沿对称轴的标量函数。对于一个半径为 $R$、载有电流 $I$、匝数为 $N$、中心位于 $z$ 轴上 $z=z_0$ 处的线圈，其轴上磁场大小是一个函数 $B_{\\text{loop}}(z)$，仅依赖于 $z$, $R$, $I$, $N$ 和磁常数 $\\mu_0$，在国际单位制 (SI) 中 $\\mu_0 = 4\\pi \\times 10^{-7}\\ \\text{N}\\,\\text{A}^{-2}$。\n- 一对类亥姆霍兹线圈由两个这样的线圈组成，它们的中心分别位于 $z=+s/2$ 和 $z=-s/2$，其中 $s$ 是中心间距。如果两个线圈可能具有不同的半径和电流，则总轴上磁场是每个线圈产生磁场的叠加。\n- 在区间 $x\\in[-1,1]$ 上的第一类 Chebyshev 多项式 $\\{T_k(x)\\}_{k=0}^\\infty$ 构成一个关于权重 $(1-x^2)^{-1/2}$ 的正交基。任何在 $[-1,1]$ 上足够光滑的函数都有一个收敛的 Chebyshev 级数。为了在有限区间 $z\\in[-L,L]$ 上近似函数 $f(z)$，定义仿射映射 $x = z/L$ 以获得在 $[-1,1]$ 上的函数 $g(x)=f(Lx)$，然后用一个 $n$ 次的截断 Chebyshev 级数来近似 $g(x)$。\n\n任务：\n1) 从 Biot–Savart 定律和对称性出发，推导单个线圈的显式轴上表达式 $B_{\\text{loop}}(z)$，以及位于 $z=\\pm s/2$、可能具有不同半径和电流的两个线圈的叠加总磁场 $B_{\\text{pair}}(z)$。\n2) 通过映射到 $x\\in[-1,1]$ 并在第一类 Chebyshev 基中进行拟合，构建 $B_{\\text{pair}}(z)$ 在 $z\\in[-L,L]$ 上的 $n$ 次 Chebyshev 近似 $\\tilde B(z)$。系数必须使用适用于 Chebyshev 多项式的稳定数值方法获得。\n3) 在 $[-L,L]$ 上的一个包含 $M$ 个点的均匀网格上，计算精确磁场和近似值，并计算最大绝对误差 $\\max_{z\\in[-L,L]} |B_{\\text{pair}}(z) - \\tilde B(z)|$。以特斯拉（SI 单位）报告此误差。\n\n角度单位：如果在您的推导中出现任何反三角函数，应理解为使用弧度。\n\n您的程序必须实现上述内容，并为以下测试套件输出结果。所有物理常数和参数均采用国际单位制 (SI) 单位。在每个案例中，区间为 $[-L,L]$，用于误差计算的均匀网格有 $M=2001$ 个点，输出是以特斯拉为单位的最大绝对误差。\n\n测试套件：\n- 案例1 (近理想亥姆霍兹线圈):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.300\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - 次数 $n = 8$。\n- 案例2 (半径轻微不匹配):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.305\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = (R_1 + R_2)/2 = 0.3025\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - 次数 $n = 10$。\n- 案例3 (电流轻微不匹配):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 1.95\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.300\\ \\text{m}$,\n  - $L = 0.150\\ \\text{m}$,\n  - 次数 $n = 10$。\n- 案例4 (非亥姆霍兹间距和更宽的区间):\n  - $R_1 = 0.300\\ \\text{m}$, $R_2 = 0.300\\ \\text{m}$,\n  - $I_1 = 2.0\\ \\text{A}$, $I_2 = 2.0\\ \\text{A}$,\n  - $N_1 = 200$, $N_2 = 200$,\n  - $s = 0.250\\ \\text{m}$,\n  - $L = 0.300\\ \\text{m}$,\n  - 次数 $n = 12$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个以特斯拉为单位的最大绝对误差，格式为用方括号括起来的逗号分隔列表（例如，“[e1,e2,e3,e4]”）。每个条目必须是浮点数。不应打印任何额外文本。", "solution": "我们从静磁学中的 Biot–Savart 定律开始。由稳恒电流 $I$ 在导线微元 $d\\boldsymbol{\\ell}$ 中流动所产生的磁场 $\\mathbf{B}(\\mathbf{r})$ 由下式给出：\n$$\n\\mathbf{B}(\\mathbf{r}) = \\frac{\\mu_0 I}{4\\pi} \\int \\frac{d\\boldsymbol{\\ell} \\times \\hat{\\mathbf{R}}}{R^2},\n$$\n其中 $\\mathbf{R} = \\mathbf{r} - \\mathbf{r}'$ 从导线上的源点 $\\mathbf{r}'$ 指向场点 $\\mathbf{r}$，$R = \\|\\mathbf{R}\\|$，且 $\\hat{\\mathbf{R}} = \\mathbf{R}/R$。对于一个以原点为中心、位于 $xy$ 平面内、半径为 $R$ 的圆形线圈，根据对称性，$z$ 轴上的磁场方向沿 $\\hat{\\mathbf{z}}$ 方向，其大小仅依赖于 $z$。计算该积分（这是一个可通过对称性和直接积分得到的、经过充分验证的教科书结果），可得中心位于 $z=z_0$、匝数为 $N$、电流为 $I$ 的单个线圈的轴上磁场：\n$$\nB_{\\text{loop}}(z; R, I, N, z_0) = \\frac{\\mu_0 N I R^2}{2 \\left(R^2 + (z - z_0)^2 \\right)^{3/2}}.\n$$\n对于两个中心位于 $z = \\pm s/2$、可能具有不同半径和电流的共轴线圈（类亥姆霍兹线圈对），通过叠加可得总磁场：\n$$\nB_{\\text{pair}}(z) = \\frac{\\mu_0 N_1 I_1 R_1^2}{2 \\left(R_1^2 + \\left(z - \\frac{s}{2}\\right)^2 \\right)^{3/2}} + \\frac{\\mu_0 N_2 I_2 R_2^2}{2 \\left(R_2^2 + \\left(z + \\frac{s}{2}\\right)^2 \\right)^{3/2}}.\n$$\n该磁场对所有实数 $z$ 都是光滑的，因此适合在任何有限区间 $z \\in [-L, L]$ 上进行多项式近似。\n\n为了构建 Chebyshev 近似，我们通过仿射变换将物理变量 $z \\in [-L, L]$ 映射到标准域 $x \\in [-1, 1]$：\n$$\nx = \\frac{z}{L}, \\quad z = Lx.\n$$\n定义函数 $g(x) = B_{\\text{pair}}(Lx)$。第一类 Chebyshev 多项式 $\\{T_k(x)\\}$ 定义为：\n$$\nT_k(x) = \\cos\\left(k \\arccos x \\right), \\quad x \\in [-1,1], \\quad k = 0, 1, 2, \\dots,\n$$\n并且满足以下正交关系：\n$$\n\\int_{-1}^{1} \\frac{T_j(x) T_k(x)}{\\sqrt{1 - x^2}}\\, dx = \n\\begin{cases}\n0,  j \\neq k, \\\\\n\\pi,  j = k = 0, \\\\\n\\frac{\\pi}{2},  j = k \\ge 1.\n\\end{cases}\n$$\n一个 $n$ 次的 Chebyshev 级数近似具有以下形式：\n$$\ng(x) \\approx \\sum_{k=0}^{n} c_k T_k(x).\n$$\n理想的 Chebyshev 系数 $\\{c_k\\}$ 由加权投影给出：\n$$\nc_0 = \\frac{1}{\\pi} \\int_{-1}^{1} \\frac{g(x)}{\\sqrt{1-x^2}}\\, dx, \\quad\nc_k = \\frac{2}{\\pi} \\int_{-1}^{1} \\frac{g(x) T_k(x)}{\\sqrt{1-x^2}}\\, dx \\quad (k \\ge 1).\n$$\n在实践中，我们通过在 $[-L, L]$ 区间的一组采样点上，在 Chebyshev 基中进行最小二乘拟合，来计算这些系数的一个数值稳定的近似值。这就构建了在所选区间上、在 Chebyshev 基中近似 $B_{\\text{pair}}(z)$ 的 $n$ 次多项式 $\\tilde B(z)$。拟合和求值可以方便且稳健地使用 Numerical Python (NumPy) 库中的 Chebyshev 基工具来实现，该工具库内部处理了 $z$ 和 $x$ 之间的缩放以及 Vandermonde 系统的条件数问题。\n\n算法设计：\n1) 对于给定的物理参数 $(R_1, R_2, I_1, I_2, N_1, N_2, s)$ 和区间半宽度 $L$，如上定义精确磁场 $B_{\\text{pair}}(z)$，其中 $\\mu_0 = 4\\pi \\times 10^{-7}\\ \\text{N}\\,\\text{A}^{-2}$。\n2) 选择一个多项式次数 $n$。在 $[-L, L]$ 中生成一个足够密集的采样点集 $\\{z_j\\}$，例如 $M_{\\text{fit}}$ 个均匀间隔的点，其中 $M_{\\text{fit}} \\gg n$，并计算 $y_j = B_{\\text{pair}}(z_j)$。\n3) 在域 $[-L, L]$ 上，将一个 $n$ 次 Chebyshev 多项式拟合到采样数据 $\\{(z_j, y_j)\\}$，得到 Chebyshev 级数表示 $\\tilde B(z) = \\sum_{k=0}^{n} \\tilde c_k T_k(z/L)$。\n4) 在 $[-L, L]$ 区间上一个包含 $M$ 个点（其中 $M=2001$）的均匀求值网格上，计算精确磁场和多项式近似，然后计算最大绝对误差：\n$$\nE_{\\max} = \\max_{z \\in [-L, L]} \\left| B_{\\text{pair}}(z) - \\tilde B(z) \\right|.\n$$\n5) 对每个测试用例重复以上步骤。\n\n边界情况与数值考量讨论：\n- 当在理想亥姆霍兹配置中 $s$ 等于半径时，磁场在 $z=0$ 附近特别平坦，因此在适中的区间 $[-L, L]$ 上使用一个适中的 $n$ 会产生非常小的误差。\n- 半径或电流的不匹配会引入不对称性和曲率，需要在相同区间上使用稍高的 $n$ 才能达到相同的一致误差。\n- 在保持 $n$ 不变的情况下增大 $L$ 会增加一致近似的难度，通常会导致 $E_{\\max}$ 增大。\n\n下面的程序使用 Numerical Python (NumPy) 的 Chebyshev 多项式工具实现了上述算法，为每个测试用例计算最大绝对误差，并以方括号括起来的逗号分隔列表形式打印单行输出，其中包含四个以特斯拉为单位的误差。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial import Chebyshev as Cheb\n\n# Physical constant (SI)\nMU0 = 4.0 * np.pi * 1e-7  # N/A^2, equivalent T·m/A\n\ndef B_loop_on_axis(z, R, I, N, z0):\n    # On-axis magnetic field of a circular loop with N turns, current I, radius R, centered at z0.\n    # B(z) = mu0 N I R^2 / (2 (R^2 + (z - z0)^2)^(3/2))\n    denom = (R*R + (z - z0)**2)**1.5\n    return MU0 * N * I * (R*R) / (2.0 * denom)\n\ndef B_pair_on_axis(z, R1, R2, I1, I2, N1, N2, s):\n    # Two loops centered at z = +/- s/2\n    return (B_loop_on_axis(z, R1, I1, N1, +0.5*s) +\n            B_loop_on_axis(z, R2, I2, N2, -0.5*s))\n\ndef chebyshev_approximation(B_fun, L, deg, fit_points=2049):\n    \"\"\"\n    Fit a Chebyshev polynomial of degree 'deg' to the function B_fun over z in [-L, L].\n    Returns a Chebyshev object representing the approximation on the given domain.\n    \"\"\"\n    # Sample densely for a robust least-squares fit\n    z_samples = np.linspace(-L, L, fit_points)\n    y_samples = B_fun(z_samples)\n    # Fit Chebyshev polynomial on the domain [-L, L]\n    cheb_poly = Cheb.fit(z_samples, y_samples, deg=deg, domain=[-L, L])\n    return cheb_poly\n\ndef max_uniform_error(B_exact_fun, B_approx_poly, L, eval_points=2001):\n    z_eval = np.linspace(-L, L, eval_points)\n    exact = B_exact_fun(z_eval)\n    approx = B_approx_poly(z_eval)\n    return float(np.max(np.abs(exact - approx)))\n\ndef solve():\n    # Define test cases as tuples:\n    # (R1, R2, I1, I2, N1, N2, s, L, deg)\n    test_cases = [\n        (0.300, 0.300, 2.0, 2.0, 200, 200, 0.300, 0.150, 8),     # Case 1\n        (0.300, 0.305, 2.0, 2.0, 200, 200, 0.3025, 0.150, 10),   # Case 2\n        (0.300, 0.300, 2.0, 1.95, 200, 200, 0.300, 0.150, 10),   # Case 3\n        (0.300, 0.300, 2.0, 2.0, 200, 200, 0.250, 0.300, 12),    # Case 4\n    ]\n\n    results = []\n    for (R1, R2, I1, I2, N1, N2, s, L, deg) in test_cases:\n        # Define exact function for this case\n        exact_fun = lambda z: B_pair_on_axis(z, R1, R2, I1, I2, N1, N2, s)\n        # Build Chebyshev approximation\n        cheb_poly = chebyshev_approximation(exact_fun, L=L, deg=deg, fit_points=4097)\n        # Compute maximum uniform error over the interval\n        err = max_uniform_error(exact_fun, cheb_poly, L=L, eval_points=2001)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2379180"}]}