{"hands_on_practices": [{"introduction": "理论是灰色的，而实践之树常青。本章将通过一系列动手实践，带你深入探索插值误差和龙格现象的实际影响。我们将从一个量子力学中的经典例子开始：粒子隧穿矩形势垒的透射概率。这个函数在势垒高度 $V_0$ 处虽然连续，但其导数不连续（非解析），这使其成为检验多项式插值不稳定性的绝佳试验场。通过这个练习 ([@problem_id:2436011])，你将亲眼见证在等距节点上高阶多项式插值的振荡问题，并理解为何切比雪夫节点能够有效抑制这种灾难性的龙格现象。", "problem": "编写一个完整、可运行的程序，用于量化插值误差，并说明在使用全局多项式插值近似量子力学隧穿概率函数时，龙格现象的出现或减缓。考虑一个质量为 $m$ 的非相对论性粒子，入射到一个高度为 $V_0$、宽度为 $a$ 的一维矩形势垒上。透射概率作为动能 $E \\ge 0$ 的函数，由以下分段函数定义，并以国际单位制（SI）表示：\n\n对于 $0 \\le E  V_0$，\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}.\n$$\n\n对于 $E = V_0$，\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}.\n$$\n\n对于 $E > V_0$，\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}.\n$$\n\n如果 $E = 0$，取 $T(0) = 0$。此处 $\\hbar$ 是约化普朗克常数。函数 $T(E)$ 是无量纲的。这些公式内的所有计算都必须以国际单位制（SI）进行。以电子伏特为单位的能量必须使用 $1\\ \\text{electronvolt} = 1.602176634 \\times 10^{-19}\\ \\text{joule}$ 转换为焦耳，以纳米为单位的长度必须使用 $1\\ \\text{nanometer} = 1.0 \\times 10^{-9}\\ \\text{meter}$ 转换为米，约化普朗克常数和电子质量必须取值为\n$$\n\\hbar = 1.054571817 \\times 10^{-34}\\ \\text{joule}\\cdot\\text{second}, \\quad m_e = 9.1093837015 \\times 10^{-31}\\ \\text{kilogram}.\n$$\n\n对于下文套件中的每个测试用例，执行以下操作：\n\n1. 使用 $m = m_e$。\n2. 将能量区间定义为 $[0, E_{\\max}]$，其中 $E_{\\max} = \\alpha V_0$，$\\alpha$ 是测试用例中提供的无量纲因子，并且在 $T(E)$ 内部，$E_{\\max}$ 和 $V_0$ 都必须使用焦耳单位。\n3. 构建一个次数至多为 $N-1$ 的唯一多项式插值，该插值在 $[0, E_{\\max}]$ 区间内的 $N$ 个节点上对 $T(E)$ 进行插值，其中节点集由一个节点类型标志指定：\n   - 如果节点类型为“equispaced”，节点为 $x_i = \\dfrac{i}{N-1} E_{\\max}$，其中 $i = 0, 1, \\ldots, N-1$。\n   - 如果节点类型为“Chebyshev”，节点为 $N$ 个从 $[-1,1]$ 映射到 $[0, E_{\\max}]$ 的第一类Chebyshev点，即 $x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{2 i + 1}{2 N} \\pi\\right)\\right)$，其中 $i = 0, 1, \\ldots, N-1$。\n4. 在一个包含 $[0, E_{\\max}]$ 区间内 $1001$ 个点的均匀评估网格上，即集合 $\\left\\{ 0, \\dfrac{E_{\\max}}{1000}, \\dfrac{2 E_{\\max}}{1000}, \\ldots, E_{\\max} \\right\\}$，通过将插值与这些网格点上的精确 $T(E)$ 值进行比较，评估最大绝对插值误差。将最大绝对误差报告为一个无量纲的十进制数。\n\n您的程序必须计算并单行输出下列测试套件的最大绝对误差列表，顺序如下：\n\n- 测试用例 1：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 11$，节点类型 = \"equispaced\"。\n- 测试用例 2：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 11$，节点类型 = \"Chebyshev\"。\n- 测试用例 3：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 41$，节点类型 = \"equispaced\"。\n- 测试用例 4：$V_0 = 0.6\\ \\text{electronvolt}$，$a = 1.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 41$，节点类型 = \"Chebyshev\"。\n- 测试用例 5：$V_0 = 0.8\\ \\text{electronvolt}$，$a = 2.0\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 21$，节点类型 = \"equispaced\"。\n- 测试用例 6：$V_0 = 0.3\\ \\text{electronvolt}$，$a = 0.3\\ \\text{nanometer}$，$\\alpha = 1.2$，$N = 21$，节点类型 = \"equispaced\"。\n\n要求的最终输出格式是单行包含一个由方括号括起来的、逗号分隔的六个最大绝对误差列表，例如，“[e1,e2,e3,e4,e5,e6]”，其中每个 $e_k$ 是一个四舍五入到六位有效数字的十进制数。误差是无量纲的，因此输出中无需指定物理单位。不得打印任何额外文本。", "solution": "所提供的问题陈述经过了严格验证，被认定为有效。它在科学上是合理的，问题定义清晰，并包含所有必要信息以获得唯一、可验证的解。该物理模型基于粒子隧穿矩形势垒的标准量子力学处理，这是入门量子力学的基石。这个数值任务涉及多项式插值和龙格现象的分析，是计算物理和数值分析中的一个典型问题。所有参数、常数和程序步骤都以足够的精度被指定。\n\n问题的核心是使用一个次数至多为 $N-1$ 的单项式插值 $P_{N-1}(E)$ 来近似给定的函数，即量子隧穿概率 $T(E)$。然后量化此近似的误差。函数 $T(E)$ 是为质量为 $m$、动能为 $E \\ge 0$ 的粒子入射到高度为 $V_0$、宽度为 $a$ 的势垒上而定义的。该函数是分段的，其解析形式取决于能量 $E$ 是小于、等于还是大于势垒高度 $V_0$。定义如下：\n对于 $0 \\le E  V_0$：\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sinh^2\\!\\big(\\kappa a\\big)}{4 E (V_0 - E)}}, \\quad \\text{其中} \\quad \\kappa = \\frac{\\sqrt{2 m (V_0 - E)}}{\\hbar}\n$$\n对于 $E = V_0$：\n$$\nT(E) = \\frac{1}{1 + \\dfrac{m V_0 a^2}{2 \\hbar^2}}\n$$\n对于 $E > V_0$：\n$$\nT(E) = \\frac{1}{1 + \\dfrac{V_0^2 \\sin^2\\!\\big(k_2 a\\big)}{4 E (E - V_0)}}, \\quad \\text{其中} \\quad k_2 = \\frac{\\sqrt{2 m (E - V_0)}}{\\hbar}\n$$\n给出了 $E=0$ 时的特例，此时 $T(0)=0$。这里，$\\hbar$ 是约化普朗克常数。分析表明，函数 $T(E)$ 对于所有 $E \\ge 0$ 都是连续的。然而，从双曲正弦（对于 $E  V_0$）到三角正弦（对于 $E > V_0$）的过渡表明该函数在 $E=V_0$ 处不解析。当使用等距节点的高次多项式插值时，这种缺乏解析性是导致龙格现象出现的关键条件。\n\n插值在能量区间 $[0, E_{\\max}]$ 上进行，其中 $E_{\\max} = \\alpha V_0$。构建多项式 $P_{N-1}(E)$ 以匹配精确函数 $T(E)$ 在 $N$ 个指定点（或节点）$\\{x_i\\}_{i=0}^{N-1}$ 上的值。考虑两种类型的节点分布：\n1. 等距节点：$x_i = \\dfrac{i}{N-1} E_{\\max}$，对于 $i=0, 1, \\ldots, N-1$。已知这些节点对于非解析函数会在区间端点附近导致剧烈振荡，这种行为被称为龙格现象。\n2. 切比雪夫节点：$x_i = \\dfrac{E_{\\max}}{2}\\left(1 + \\cos\\!\\left(\\dfrac{(2i+1)\\pi}{2N}\\right)\\right)$，对于 $i=0, 1, \\ldots, N-1$。这些节点是第一类切比雪夫多项式 $T_N(x)$ 的根，经过缩放和平移以适应区间 $[0, E_{\\max}]$。这些节点在端点附近密度更高，这被证明可以抑制或减缓龙格现象，从而为连续函数带来更优的收敛性质。\n\n该解决方案按如下算法实现。对于每个测试用例，使用参数 $V_0$、$a$、$\\alpha$、$N$ 和节点类型。所有以非国际单位制（电子伏特、纳米）给出的物理量，首先使用提供的转换因子转换为其对应的国际单位制单位（焦耳、米）。粒子质量 $m$ 设置为电子质量 $m_e$。\n\n首先，根据指定的类型生成 $N$ 个插值节点集 $\\{x_i\\}$。然后，在每个节点上计算精确函数值 $y_i = T(x_i)$，创建数据集 $\\{(x_i, y_i)\\}_{i=0}^{N-1}$。接着，构建一个通过这 $N$ 个点的单项式插值 $P_{N-1}(E)$。为了数值稳定性和效率，特别是对于大的 $N$，重心插值公式是首选方法。`scipy.interpolate.BarycentricInterpolator` 类提供了这种技术的鲁棒实现。\n\n为了量化近似的质量，在区间 $[0, E_{\\max}]$ 上估计最大绝对误差 $\\|T - P_{N-1}\\|_{\\infty}$。这是通过在一个由 $1001$ 个评估点组成的精细、均匀的网格 $\\{E_j\\}_{j=0}^{1000}$ 上计算误差来完成的，其中 $E_j = j \\cdot E_{\\max} / 1000$。最大绝对误差计算如下：\n$$\n\\text{Error} = \\max_{j} | T(E_j) - P_{N-1}(E_j) |\n$$\n对问题陈述中指定的六个测试用例中的每一个重复此过程。收集得到的最大误差值，并格式化为六位有效数字。最终输出是单行文本形式的这些误差值列表。等距节点和切比雪夫节点之间的比较，以及增加多项式次数 $N-1$ 的效果，将直接说明数值分析中关于插值误差和龙格现象的理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef t_prob(E_J, V0_J, a_m):\n    \"\"\"\n    Calculates the quantum tunneling transmission probability T(E).\n    All inputs must be in SI units.\n    \"\"\"\n    # Physical constants in SI units\n    hbar = 1.054571817e-34  # J*s\n    m_e = 9.1093837015e-31  # kg\n\n    # Ensure E_J is a numpy array for vectorized operations\n    E = np.atleast_1d(E_J).astype(float)\n    T = np.zeros_like(E)\n\n    # Define condition masks for the piecewise function\n    mask_zero = (E == 0)\n    mask_tunnel = (E > 0)  (E  V0_J)\n    mask_barrier_top = (E == V0_J)\n    mask_above_barrier = (E > V0_J)\n\n    # Case 1: T(0) = 0\n    T[mask_zero] = 0.0\n\n    # Case 2: 0  E  V0 (tunneling)\n    if np.any(mask_tunnel):\n        E_sub = E[mask_tunnel]\n        kappa = np.sqrt(2 * m_e * (V0_J - E_sub)) / hbar\n        sinh_term = np.sinh(kappa * a_m)\n        denom_term = (V0_J**2 * sinh_term**2) / (4 * E_sub * (V0_J - E_sub))\n        T[mask_tunnel] = 1.0 / (1.0 + denom_term)\n\n    # Case 3: E = V0\n    if np.any(mask_barrier_top):\n        denom_term = (m_e * V0_J * a_m**2) / (2 * hbar**2)\n        T[mask_barrier_top] = 1.0 / (1.0 + denom_term)\n\n    # Case 4: E > V0 (above-barrier transmission)\n    if np.any(mask_above_barrier):\n        E_sup = E[mask_above_barrier]\n        k2 = np.sqrt(2 * m_e * (E_sup - V0_J)) / hbar\n        sin_term = np.sin(k2 * a_m)\n        denom_term = (V0_J**2 * sin_term**2) / (4 * E_sup * (E_sup - V0_J))\n        T[mask_above_barrier] = 1.0 / (1.0 + denom_term)\n\n    # Return scalar if input was scalar\n    return T[0] if np.isscalar(E_J) else T\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Unit conversion factors\n    eV_to_J = 1.602176634e-19\n    nm_to_m = 1.0e-9\n\n    # Test cases from the problem statement\n    test_cases = [\n        # (V0_eV, a_nm, alpha, N, node_type)\n        (0.6, 1.0, 1.2, 11, \"equispaced\"),\n        (0.6, 1.0, 1.2, 11, \"Chebyshev\"),\n        (0.6, 1.0, 1.2, 41, \"equispaced\"),\n        (0.6, 1.0, 1.2, 41, \"Chebyshev\"),\n        (0.8, 2.0, 1.2, 21, \"equispaced\"),\n        (0.3, 0.3, 1.2, 21, \"equispaced\"),\n    ]\n\n    results = []\n    for V0_eV, a_nm, alpha, N, node_type in test_cases:\n        # Convert parameters to SI units\n        V0_J = V0_eV * eV_to_J\n        a_m = a_nm * nm_to_m\n\n        # Define the interpolation interval\n        E_max = alpha * V0_J\n\n        # Generate interpolation nodes based on type\n        if node_type == \"equispaced\":\n            x_nodes = np.linspace(0, E_max, N)\n        elif node_type == \"Chebyshev\":\n            # Chebyshev nodes of the first kind mapped to [0, E_max]\n            i = np.arange(N)\n            # The formula produces nodes in descending order, which is acceptable\n            cos_term = np.cos((2 * i + 1) * np.pi / (2 * N))\n            x_nodes = 0.5 * E_max * (1 + cos_term)\n        \n        # Compute exact function values at interpolation nodes\n        y_nodes = t_prob(x_nodes, V0_J, a_m)\n\n        # Construct the barycentric polynomial interpolant\n        poly_interpolant = BarycentricInterpolator(x_nodes, y_nodes)\n\n        # Create a fine grid for error evaluation\n        eval_grid = np.linspace(0, E_max, 1001)\n\n        # Evaluate the exact function and the interpolant on the grid\n        T_exact = t_prob(eval_grid, V0_J, a_m)\n        T_interp = poly_interpolant(eval_grid)\n        \n        # Find the maximum absolute error\n        max_error = np.max(np.abs(T_exact - T_interp))\n        \n        # Format result to six significant digits and store\n        results.append(\"{:.6g}\".format(max_error))\n\n    # Print the final list of errors in the required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2436011"}, {"introduction": "在处理了非解析函数的挑战之后，我们可能会好奇：对于像正弦函数这样无限光滑的解析函数，高阶多项式插值是否就万无一失了呢？这个练习 ([@problem_id:2436069]) 将通过研究一维无限深方势阱中的定态波函数 $\\psi_{n}(x)$ 来回答这个问题。你将探索插值误差如何随着量子数 $n$（代表了波函数的振荡频率）的增加而变化，并再次比较等距节点和切比雪夫节点的效果。这个实践将揭示，即便对于“表现良好”的函数，不恰当的节点选择在高频情况下同样会导致严重的精度损失。", "problem": "考虑宽度为 $L$ 的一维无限深方势阱中的一维 (1D) 不含时薛定谔方程，其定态在闭区间 $[0,L]$ 上由 $\\psi_{n}(x)=\\sin\\!\\left(\\dfrac{n\\pi x}{L}\\right)$ 给出，其中 $n$ 是一个正整数，且正弦函数的参数以弧度为单位。对于给定的整数 $M\\geq 2$，定义一个插值节点集 $\\{x_{j}\\}_{j=0}^{M-1}\\subset[0,L]$ 和一个次数至多为 $M-1$ 的唯一多项式 $p(x)$，该多项式对所有 $j$ 满足 $p(x_{j})=\\psi_{n}(x_{j})$。对于下文测试套件中的每种情况，您的任务是在一个由 $Q$ 个点组成的均匀评估网格上计算最大绝对插值误差，其定义为\n$$E=\\max_{0\\leq k \\leq Q-1}\\left|\\psi_{n}(x_{k})-p(x_{k})\\right|,\\quad x_{k}=\\frac{k\\,L}{Q-1},$$\n其中 $Q=10001$。所有量均为无量纲量，所有角度均以弧度为单位。\n\n将使用两种节点集类型：\n- 等距节点：$x_{j}=\\dfrac{j\\,L}{M-1}$，其中 $j=0,1,\\dots,M-1$。\n- 映射到 $[0,L]$ 的 Chebyshev–Lobatto (CL) 节点：$x_{j}=\\dfrac{L}{2}\\left(1-\\cos\\!\\left(\\dfrac{j\\pi}{M-1}\\right)\\right)$，其中 $j=0,1,\\dots,M-1$。\n\n对于测试套件中的每个参数元组 $(L,n,M,\\text{node\\_type})$，构建相应的多项式插值函数 $p(x)$ 并计算如上定义的 $E$。\n\n测试套件（按输出时使用的确切顺序）：\n1. $(L=\\;1,\\;n=\\;3,\\;M=\\;9,\\;\\text{node\\_type}=\\text{等距})$,\n2. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{等距})$,\n3. $(L=\\;1,\\;n=\\;15,\\;M=\\;9,\\;\\text{node\\_type}=\\text{CL})$,\n4. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{等距})$,\n5. $(L=\\;1,\\;n=\\;20,\\;M=\\;21,\\;\\text{node\\_type}=\\text{CL})$,\n6. $(L=\\;2,\\;n=\\;15,\\;M=\\;21,\\;\\text{node\\_type}=\\text{等距})$,\n7. $(L=\\;1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{等距})$,\n8. $(L=\\;1,\\;n=\\;50,\\;M=\\;51,\\;\\text{node\\_type}=\\text{CL})$。\n\n您的程序应生成单行输出，其中包含 8 个结果，形式为用方括号括起来的逗号分隔列表，顺序与测试套件中的顺序相同。每个结果必须是与相应情况下的 $E$ 相等的浮点数，并四舍五入到小数点后恰好 8 位（例如，$[0.12345679,0.00000001,\\dots]$）。", "solution": "所提出的问题是计算物理学和数值分析中一个定义明确的练习，具体涉及多项式插值的误差分析。该问题要求计算在使用多项式插值函数逼近一个给定函数时的最大绝对误差，该给定函数源自一维量子无限深方势阱的定态。问题的核心是比较两种不同插值节点集的有效性：等距节点和 Chebyshev-Lobatto 节点。\n\n该问题在科学上和数学上都是合理的。待插值的函数是 $\\psi_{n}(x) = \\sin\\left(\\frac{n\\pi x}{L}\\right)$，这是一个在整个实轴上的解析函数，因此它无限可微，非常适合进行此类分析。任务是构造一个次数至多为 $M-1$ 的唯一多项式 $p(x)$，该多项式经过 $M$ 个给定点 $(x_j, \\psi_{n}(x_j))$。此类多项式的存在性和唯一性是数值分析的基石。\n\n解决此问题的方法包括以下步骤：\n$1$。对于由参数 $(L, n, M, \\text{node\\_type})$ 指定的每个测试用例，在区间 $[0, L]$ 内生成 $M$ 个插值节点的集合 $\\{x_j\\}_{j=0}^{M-1}$。\n    - 对于等距节点，公式为 $x_j = j \\frac{L}{M-1}$。\n    - 对于 Chebyshev-Lobatto (CL) 节点，公式为 $x_j = \\frac{L}{2}\\left(1 - \\cos\\left(\\frac{j\\pi}{M-1}\\right)\\right)$。这种分布将第一类 Chebyshev 多项式 $T_{M-1}(t)$ 的极值点从规范区间 $[-1, 1]$ 映射到 $[0, L]$。\n\n$2$。计算相应的函数值 $\\{y_j = \\psi_n(x_j)\\}_{j=0}^{M-1}$。\n\n$3$。构造插值多项式 $p(x)$。虽然 Lagrange 公式提供了 $p(x)$ 的理论定义，但其直接实现对于高次数而言是数值不稳定的。一种更优越的求值方法是重心插值公式。给定节点 $x_j$ 和值 $y_j$，该多项式在任意点 $x$ 的值可以计算为：\n$$ p(x) = \\frac{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j} y_j}{\\sum_{j=0}^{M-1} \\frac{w_j}{x - x_j}} $$\n其中 $w_j$ 是重心权重。这种形式数值稳定且高效。`scipy.interpolate.BarycentricInterpolator` 类提供了此方法的稳健实现。\n\n$4$。为了找到最大插值误差 $E$，在 $[0, L]$ 上创建一个由 $Q=10001$ 个评估点组成的精细均匀网格 $\\{x_k\\}_{k=0}^{Q-1}$。\n\n$5$。在每个评估点 $x_k$ 处计算绝对误差 $|\\psi_n(x_k) - p(x_k)|$。这些值的最大值即为结果 $E$：\n$$ E = \\max_{k} |\\psi_n(x_k) - p(x_k)| $$\n\n这个问题旨在阐明逼近论中的一个关键概念：插值节点的选择深刻地影响逼近的精度。多项式插值的误差由一个项界定，该项取决于函数的 M 阶导数和节点多项式 $\\omega(x) = \\prod_{j=0}^{M-1}(x - x_j)$。Chebyshev-Lobatto 节点最小化了区间上 $|\\omega(x)|$ 的最大值，与等距节点相比，这导致了更小的理论误差界。对于等距节点，随着 $M$ 的增加，插值误差可能在区间边界附近不可控地增长，这种行为被称为龙格现象。当被插值函数具有大的导数时（例如对于大的 $k$ 的 $\\sin(k x)$），这种现象尤其明显。问题的测试用例旨在凸显这种确切的行为。对于具有大的 n 与 M 之比和使用等距节点的情况，预计会产生巨大的误差，而使用 Chebyshev-Lobatto 节点将显著减轻这些误差。\n\n该算法使用 Python 实现，利用 `numpy` 库的向量化方法进行高效的数组计算，并使用 `scipy.interpolate.BarycentricInterpolator` 进行稳定的多项式构建和求值。对八个测试用例中的每一个都执行该程序，收集并按指定格式化所得的最大误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\n\ndef solve():\n    \"\"\"\n    Solves the interpolation error problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, n, M, node_type)\n        (1.0, 3, 9, '等距'),\n        (1.0, 15, 9, '等距'),\n        (1.0, 15, 9, 'CL'),\n        (1.0, 20, 21, '等距'),\n        (1.0, 20, 21, 'CL'),\n        (2.0, 15, 21, '等距'),\n        (1.0, 50, 51, '等距'),\n        (1.0, 50, 51, 'CL'),\n    ]\n\n    results = []\n    Q = 10001 # Number of evaluation points\n\n    for L, n, M, node_type in test_cases:\n        # 1. Define the function to be interpolated\n        # psi_n(x) = sin(n*pi*x/L)\n        psi_n = lambda x: np.sin(n * np.pi * x / L)\n\n        # 2. Generate M interpolation nodes\n        if node_type == '等距':\n            x_interp = np.linspace(0.0, L, M)\n        elif node_type == 'CL':\n            j = np.arange(M)\n            # Chebyshev-Lobatto nodes mapped from [-1, 1] to [0, L]\n            x_interp = L / 2.0 * (1.0 - np.cos(j * np.pi / (M - 1)))\n        \n        # 3. Compute function values at interpolation nodes\n        y_interp = psi_n(x_interp)\n\n        # 4. Construct the barycentric interpolant\n        poly = BarycentricInterpolator(x_interp, y_interp)\n\n        # 5. Define the fine evaluation grid\n        x_eval = np.linspace(0.0, L, Q)\n\n        # 6. Evaluate the true function and the polynomial on the grid\n        y_true = psi_n(x_eval)\n        y_poly = poly(x_eval)\n\n        # 7. Compute the maximum absolute error\n        max_error = np.max(np.abs(y_true - y_poly))\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is rounded to exactly 8 digits after the decimal point.\n    print(f\"[{','.join(f'{r:.8f}' for r in results)}]\")\n\nsolve()\n```", "id": "2436069"}, {"introduction": "前面的练习主要关注插值误差的大小，但这种误差在实际应用中会带来怎样的后果？最后一个练习 ([@problem_id:2436095]) 将这个问题置于统计和数据分析的核心：从分箱数据中重建概率密度函数（PDF）。你将使用多项式插值来拟合一个PDF的平均值，并检查重建的函数是否满足两个基本物理约束：非负性和归一性。这个练习将清晰地展示，龙格现象所引起的振荡不仅仅是数值上的不精确，它甚至可能导致物理上荒谬的结论（例如负概率），从而凸显了在科学计算中选择稳健插值方法的极端重要性。", "problem": "你的任务是使用全局多项式插值从分箱的直方图数据中重建一个概率密度函数 (PDF)，并评估重建结果是否满足两个基本属性：在其支撑集上的非负性以及归一化为1。本练习将插值误差和龙格现象与 PDF 的物理约束联系起来。使用的基本依据是概率密度函数 (PDF) $f(x)$ 的定义，即在其支撑集内的所有 $x$ 上都非负，并且积分值为 1（即 $\\int_{a}^{b} f(x)\\,dx = 1$）；以及将直方图描述为 $f(x)$ 的分段常数近似，其箱平均值近似于 $f(x)$ 在每个箱上的局部平均值。目标是理解当使用高次多项式时，插值误差（特别是由龙格现象在等距节点处凸显的振荡行为）会如何违反这些约束。\n\n从基本原理出发构建以下算法：\n1. 设分布的支撑集为闭区间 $[a,b]$，并将其划分为 $m$ 个等距的箱，边界为 $x_0=a, x_1, \\ldots, x_m=b$，箱宽为 $\\Delta x = (b-a)/m$。设箱中心为 $c_i = (x_i + x_{i+1})/2$，$i=0,\\ldots,m-1$。\n2. 给定定义在 $[a,b]$ 上的已知目标密度 $f(x)$（以下每个案例都定义了 $f(x)$ 并确保 $\\int_a^b f(x)\\,dx = 1$），使用精确的数值积分计算每个箱的精确箱概率 $p_i = \\int_{x_i}^{x_{i+1}} f(x)\\,dx$，然后计算箱平均密度 $\\bar{f}_i = p_i / \\Delta x$。\n3. 构建一个次数为 $n$ 的全局多项式 $P_n(x)$，该多项式在箱中心处对箱平均数据进行插值，即对所有 $i$ 都有 $P_n(c_i) = \\bar{f}_i$。使用等距中心点 $\\{c_i\\}$，而非任何特殊节点。\n4. 评估该插值多项式是否满足两个 PDF 约束：\n   - 非负性：检查对于所有 $x \\in [a,b]$，是否有 $P_n(x) \\ge 0$（在指定的容差 $T_{\\mathrm{pos}}$ 范围内）。将此实现为 $ \\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$，其中 $\\mathcal{G}$ 是 $[a,b]$ 上一个足够精细的均匀网格。\n   - 归一化：通过解析地对多项式进行积分，精确计算 $P_n(x)$ 在 $[a,b]$ 上的积分，并检查是否满足 $|\\int_a^b P_n(x)\\,dx - 1| \\le T_{\\mathrm{int}}$。\n5. 使用容差值 $T_{\\mathrm{pos}} = 10^{-6}$ 和 $T_{\\mathrm{int}} = 10^{-3}$，两者均为无量纲。\n\n使用以下包含三个案例的测试套件，它们共同探讨一个理想路径、一个容易出现振荡的高次等距节点场景，以及一个边界集中的平滑密度：\n- 案例 1（$[-1,1]$ 上的类龙格密度，多箱）：设在 $[a,b]=[-1,1]$ 上 $f(x) = C_{\\mathrm{R}} \\, \\frac{1}{1 + 25 x^2}$，其中 $C_{\\mathrm{R}}$ 的选择使得 $\\int_{-1}^{1} f(x)\\,dx = 1$。精确积分为 $\\int_{-1}^{1} \\frac{dx}{1+25x^2} = \\frac{2}{5}\\arctan(5)$；因此 $C_{\\mathrm{R}} = \\frac{5}{2\\arctan(5)}$。使用 $m=21$ 个箱和多项式次数 $n=20$。\n- 案例 2（$[-3,3]$ 上的截断高斯分布，中等数量箱）：设在 $[a,b]=[-3,3]$ 上 $f(x) = C_{\\mathrm{G}} \\exp\\!\\left(-\\frac{x^2}{2}\\right)$，其中 $C_{\\mathrm{G}}$ 对 $[-3,3]$ 上的积分进行归一化。精确积分为 $\\int_{-3}^{3} \\exp\\!\\left(-\\frac{x^2}{2}\\right)\\,dx = \\sqrt{2\\pi}\\,\\mathrm{erf}\\!\\left(\\frac{3}{\\sqrt{2}}\\right)$，所以 $C_{\\mathrm{G}} = \\left[\\sqrt{2\\pi}\\,\\mathrm{erf}\\!\\left(\\frac{3}{\\sqrt{2}}\\right)\\right]^{-1}$。使用 $m=11$ 个箱和多项式次数 $n=10$。\n- 案例 3（$[0,1]$ 上中等偏度的 Beta 密度，少量箱）：设在 $[a,b]=[0,1]$ 上 $f(x)= \\mathrm{BetaPDF}_{\\alpha,\\beta}(x)$，其中 $\\alpha=2$ 且 $\\beta=5$，即 $f(x) = C_{\\mathrm{B}}\\, x^{\\alpha-1}(1-x)^{\\beta-1}$，其中 $C_{\\mathrm{B}} = \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)} = \\frac{\\Gamma(7)}{\\Gamma(2)\\Gamma(5)} = 30$。使用 $m=6$ 个箱和多项式次数 $n=5$。\n\n角度单位不适用。物理单位不适用。将所有容差和误差表示为无量纲量。\n\n程序要求：\n- 使用足够精确的确定性方法实现 $p_i$ 的数值积分；例如，每个箱使用至少有 $64$ 个节点的 Gauss–Legendre 积分。\n- 构建插值多项式 $P_n(x)$，使其在等距的箱中心处精确匹配箱平均值。\n- 在 $[a,b]$ 内至少 $20001$ 个点的均匀网格上评估非负性。\n- 通过解析求反导数来精确积分多项式。\n- 对于每个测试案例，生成两个布尔值：\n  - 第一个布尔值，如果 $P_n(x)$ 在 $[a,b]$ 上于容差 $T_{\\mathrm{pos}}$ 内非负，则为 true，否则为 false。\n  - 第二个布尔值，如果积分误差在 $T_{\\mathrm{int}}$ 内，则为 true，否则为 false。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。聚合输出必须按顺序罗列案例 1 的非负性布尔值和归一化布尔值，然后是案例 2 的相同布尔值对，接着是案例 3。例如，包含三个案例的输出可能看起来像“[True,False,True,True,False,True]”，其中每对布尔值按顺序对应一个案例。", "solution": "对所述问题进行验证。\n\n**步骤 1：提取已知条件**\n- **域和分箱：** 概率密度函数 (PDF) 的支撑集是一个闭区间 $[a,b]$。该区间被划分为 $m$ 个等距的箱，箱宽为 $\\Delta x = (b-a)/m$。箱边界为 $x_i = a + i\\Delta x$，$i=0, \\ldots, m$，箱中心为 $c_i = (x_i + x_{i+1})/2$，$i=0, \\ldots, m-1$。\n- **目标 PDF 和箱平均密度：** 每个案例都给定一个目标 PDF $f(x)$，其已归一化，使得 $\\int_a^b f(x)\\,dx = 1$。精确的箱概率为 $p_i = \\int_{x_i}^{x_{i+1}} f(x)\\,dx$，箱平均密度为 $\\bar{f}_i = p_i / \\Delta x$。\n- **插值：** 构建一个次数为 $n$ 的全局多项式 $P_n(x)$，用于在箱中心处对箱平均数据进行插值，满足 $P_n(c_i) = \\bar{f}_i$ 对所有 $i=0, \\ldots, m-1$ 成立。次数指定为 $n=m-1$。\n- **约束和容差：**\n    - 非负性：$\\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$，其中 $\\mathcal{G}$ 是 $[a,b]$ 上的一个均匀网格。容差 $T_{\\mathrm{pos}} = 10^{-6}$。\n    - 归一化：$|\\int_a^b P_n(x)\\,dx - 1| \\le T_{\\mathrm{int}}$。容差 $T_{\\mathrm{int}} = 10^{-3}$。\n- **测试案例：**\n    - **案例 1：** 在 $[a,b]=[-1,1]$ 上，$f(x) = C_{\\mathrm{R}} \\, \\frac{1}{1 + 25 x^2}$，其中 $C_{\\mathrm{R}} = \\frac{5}{2\\arctan(5)}$。参数：$m=21$ 个箱，次数 $n=20$。\n    - **案例 2：** 在 $[a,b]=[-3,3]$ 上，$f(x) = C_{\\mathrm{G}} \\exp(-\\frac{x^2}{2})$，其中 $C_{\\mathrm{G}} = [\\sqrt{2\\pi}\\,\\mathrm{erf}(3/\\sqrt{2})]^{-1}$。参数：$m=11$ 个箱，次数 $n=10$。\n    - **案例 3：** 在 $[a,b]=[0,1]$ 上，$f(x)= 30 x(1-x)^4$。这是一个参数为 $\\alpha=2, \\beta=5$ 的 Beta 分布 PDF。参数：$m=6$ 个箱，次数 $n=5$。\n- **实现要求：**\n    - $p_i$ 的积分：每个箱使用至少 64 个节点的 Gauss-Legendre 积分。\n    - 插值多项式 $P_n(x)$ 必须在箱中心处精确匹配箱平均值。\n    - 非负性网格：至少 20001 个点。\n    - 多项式积分：必须是精确的（解析的）。\n    - 输出：每个案例输出一对关于非负性和归一化的布尔值。最终输出是这些布尔值的扁平化列表，格式为特定的字符串。\n\n**步骤 2：问题陈述的验证**\n对问题进行有效性检查。\n- **科学依据：** 该问题牢固地植根于数值分析的原理，特别是多项式插值和数值积分。将其应用于概率密度函数的物理约束，是计算物理学中一个有效且富有启发性的练习。所涉及的数学概念——龙格现象、PDF 的性质、多项式插值——都是标准的，并且描述正确。\n- **适定性：** 该问题是适定的。对每个案例，都有 $m$ 个不同的插值节点（箱中心 $c_i$）和 $m$ 个对应的值（$\\bar{f}_i$）。任务是找到一个次数为 $n=m-1$ 的多项式，该多项式穿过这 $m$ 个点。根据多项式插值基本定理，这样的多项式存在且唯一。\n- **客观性：** 问题使用精确、无歧义的数学语言陈述。所有参数和成功标准都是客观定义的。\n- **完整性和一致性：** 问题提供了所有必要信息：函数、它们的定义域、归一化常数、箱数、多项式次数，以及精确的容差和评估标准。规范是一致的。点数 ($m$) 和多项式次数 ($n=m-1$) 正确地定义了一个唯一的插值多项式。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是合理的、适定的和自洽的。没有可识别的缺陷。因此，该问题被判定为 **有效**，我将继续构建解决方案。\n\n---\n\n目标是使用全局插值多项式从分箱表示中重建概率密度函数，并评估此重建是否保持了 PDF 的基本物理性质：非负性和单位归一化。该分析突显了在等距节点上的高次多项式插值如何可能失败，这一现象以龙格的发现为典型代表。该过程是系统性的。\n\n**步骤 1：插值数据的生成**\n用于插值的原始数据不是特定点上的函数值，而是有限区间（箱）上的平均值。对于一个划分为 $m$ 个宽度为 $\\Delta x = (b-a)/m$ 的箱的域 $[a,b]$，第 $i$ 个箱占据区间 $[x_i, x_{i+1}]$，其中 $x_i = a + i\\Delta x$。在箱中心 $c_i = (x_i + x_{i+1})/2$ 处要插值的值是箱平均密度 $\\bar{f}_i$。其计算方式如下：\n$$\n\\bar{f}_i = \\frac{1}{\\Delta x} p_i = \\frac{1}{\\Delta x} \\int_{x_i}^{x_{i+1}} f(x) \\, dx\n$$\n箱概率 $p_i$ 的积分必须以高精度计算，以确保插值数据的可靠性。问题指定了使用至少 64 个节点的 Gauss-Legendre 积分。这是一种高阶方法，适用于所考虑的平滑函数，可确保数值积分误差与正在研究的插值误差和模型误差相比可以忽略不计。\n\n**步骤 2：插值多项式的构建**\n给定 $m$ 个数据点集 $\\{(c_i, \\bar{f}_i)\\}_{i=0}^{m-1}$，我们寻找唯一的次数为 $n=m-1$ 的多项式 $P_n(x)$，使其满足插值条件 $P_n(c_i) = \\bar{f}_i$。我们可以用单项式基来表示该多项式：\n$$\nP_n(x) = \\sum_{k=0}^{n} a_k x^k\n$$\n系数 $\\{a_k\\}$ 通过求解 $m$ 个线性方程组来确定：\n$$\n\\sum_{k=0}^{n} a_k c_i^k = \\bar{f}_i, \\quad \\text{for } i = 0, 1, \\ldots, n\n$$\n这是一个 Vandermonde 线性系统，$\\mathbf{V}\\mathbf{a} = \\mathbf{\\bar{f}}$。尽管对于高次多项式而言，这在数值上是敏感的，但对于指定的次数（$n=5, 10, 20$），标准的数值线性代数程序，例如封装在 `numpy.polyfit` 中的程序，可以稳健地确定系数 $a_k$。\n\n**步骤 3：PDF 属性的验证**\n生成的多项式 $P_n(x)$ 是一个候选的 PDF。必须根据两个基本属性对其进行检验。\n\n首先，**非负性**：对于所有 $x \\in [a,b]$，必须满足 $P_n(x) \\ge 0$。已知在等距节点上的高次多项式插值在区间边界附近表现出振荡行为（龙格现象）。这些振荡可能导致多项式值低于零，违反了概率论的核心原则。通过在 $[a,b]$ 的一个密集点网格 $\\mathcal{G}$ 上评估 $P_n(x)$，并验证其最小值不小于一个小的负容差，即 $\\min_{x \\in \\mathcal{G}} P_n(x) \\ge -T_{\\mathrm{pos}}$，来对此进行数值检查。\n\n其次，**归一化**：总概率必须为 1，即 $\\int_a^b P_n(x) \\, dx = 1$。多项式 $P_n(x)$ 的积分可以解析计算，从而为模型得出一个精确值。$P_n(x)$ 的反导数是：\n$$\n\\int P_n(x) \\, dx = \\sum_{k=0}^{n} a_k \\frac{x^{k+1}}{k+1} + C\n$$\n因此，定积分为：\n$$\n\\int_a^b P_n(x) \\, dx = \\sum_{k=0}^{n} a_k \\left( \\frac{b^{k+1} - a^{k+1}}{k+1} \\right)\n$$\n然后将计算出的积分与 1 进行比较，其绝对偏差必须在指定的容差 $T_{\\mathrm{int}}$ 之内。\n\n**测试案例分析**\n- **案例 1（类龙格）：** 函数 $f(x) \\propto 1/(1+25x^2)$ 是展示龙格现象的典型例子。对于 $n=20$ 个等距节点，预计在 $x=-1$ 和 $x=1$ 附近会出现大的振荡。这些振荡几乎肯定会导致 $P_{20}(x)$ 变为负值，从而无法通过非负性测试。由于边界处的近似效果差，归一化测试也可能失败。\n- **案例 2（截断高斯）：** 高斯函数异常平滑且衰减迅速。即使次数为 $n=10$，插值多项式预计也会表现良好，因为函数值在 $[-3,3]$ 边界附近非常小，这减轻了龙格现象特有的边界振荡。非负性和归一化性质很可能都会得到保持。\n- **案例 3（Beta 密度）：** 目标函数 $f(x)=30x(1-x)^4$ 本身就是一个 5 次多项式。我们正在用一个相同次数的多项式 $P_5(x)$ 对从它派生出的数据进行插值。尽管插值数据是箱平均值而不是点值，但得到的插值多项式预计将是真实函数的一个极好近似。可以预见，两个 PDF 属性都将轻易满足。\n\n提供的代码将对每个案例执行此协议。", "answer": "```python\nimport numpy as np\nfrom scipy import special\nfrom scipy.integrate import fixed_quad\n\ndef solve():\n    \"\"\"\n    Solves the problem of validating a polynomial PDF reconstruction for three test cases.\n    \"\"\"\n\n    def solve_case(f_target, a, b, m, T_pos, T_int):\n        \"\"\"\n        Processes a single test case according to the problem description.\n\n        Args:\n            f_target (callable): The target probability density function.\n            a (float): The lower bound of the support.\n            b (float): The upper bound of the support.\n            m (int): The number of bins.\n            T_pos (float): The tolerance for non-negativity.\n            T_int (float): The tolerance for normalization.\n\n        Returns:\n            tuple[bool, bool]: A pair of booleans indicating if the non-negativity\n                               and normalization constraints are met, respectively.\n        \"\"\"\n        n = m - 1  # Polynomial degree\n        delta_x = (b - a) / m\n        \n        # 1. Define bin edges and centers\n        bin_edges = np.linspace(a, b, m + 1)\n        bin_centers = (bin_edges[:-1] + bin_edges[1:]) / 2.0\n\n        # 2. Compute bin-averaged densities\n        f_bar = np.zeros(m)\n        quad_nodes = 64  # As per problem requirement\n        for i in range(m):\n            x_i, x_i_plus_1 = bin_edges[i], bin_edges[i+1]\n            \n            # Use high-order Gauss-Legendre quadrature for bin probability\n            p_i, _ = fixed_quad(f_target, x_i, x_i_plus_1, n=quad_nodes)\n            f_bar[i] = p_i / delta_x\n\n        # 3. Form the global interpolating polynomial\n        # np.polyfit with degree m-1 on m points gives the interpolating polynomial\n        poly_coeffs = np.polyfit(bin_centers, f_bar, n)\n\n        # 4. Assess PDF constraints\n        # 4.a Non-negativity check\n        grid_points = 20001 # As per problem requirement\n        x_grid = np.linspace(a, b, grid_points)\n        poly_values = np.polyval(poly_coeffs, x_grid)\n        \n        is_non_negative = np.min(poly_values) >= -T_pos\n\n        # 4.b Normalization check\n        # Integrate the polynomial analytically\n        integral_poly = np.polyint(poly_coeffs)\n        integral_value = np.polyval(integral_poly, b) - np.polyval(integral_poly, a)\n        \n        is_normalized = abs(integral_value - 1.0) = T_int\n\n        return is_non_negative, is_normalized\n\n    # Tolerances\n    T_pos = 1e-6\n    T_int = 1e-3\n\n    # --- Test Case 1: Runge-like density ---\n    C_R = 5.0 / (2.0 * np.arctan(5.0))\n    def f_runge(x):\n        return C_R / (1.0 + 25.0 * x**2)\n    case1_params = {'f_target': f_runge, 'a': -1.0, 'b': 1.0, 'm': 21}\n\n    # --- Test Case 2: Truncated Gaussian ---\n    norm_const = np.sqrt(2.0 * np.pi) * special.erf(3.0 / np.sqrt(2.0))\n    C_G = 1.0 / norm_const\n    def f_gauss(x):\n        return C_G * np.exp(-x**2 / 2.0)\n    case2_params = {'f_target': f_gauss, 'a': -3.0, 'b': 3.0, 'm': 11}\n    \n    # --- Test Case 3: Beta density ---\n    # Beta(alpha=2, beta=5) PDF is C_B * x^(alpha-1) * (1-x)^(beta-1)\n    # C_B = Gamma(alpha+beta) / (Gamma(alpha)*Gamma(beta))\n    # For alpha=2, beta=5, C_B = Gamma(7)/(Gamma(2)*Gamma(5)) = 6!/(1!*4!) = 720/24 = 30\n    def f_beta(x):\n        return 30.0 * x**1 * (1.0 - x)**4\n    case3_params = {'f_target': f_beta, 'a': 0.0, 'b': 1.0, 'm': 6}\n\n    test_cases = [case1_params, case2_params, case3_params]\n    \n    results = []\n    for case_params in test_cases:\n        res_pair = solve_case(**case_params, T_pos=T_pos, T_int=T_int)\n        results.extend(res_pair)\n\n    # Format the final output string\n    # The output must be lowercase 'true' or 'false' for boolean values.\n    # In Python, str(True) is 'True', so we need to convert to lowercase.\n    print(f\"[{','.join(map(lambda b: str(b).lower(), results))}]\")\n\nsolve()\n```", "id": "2436095"}]}