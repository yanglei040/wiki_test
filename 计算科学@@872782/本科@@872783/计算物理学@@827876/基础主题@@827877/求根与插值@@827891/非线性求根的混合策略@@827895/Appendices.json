{"hands_on_practices": [{"introduction": "在构建我们自己的复杂求解器之前，培养对不同求根方法行为的直观理解至关重要。本练习将挑战你扮演“侦探”的角色，通过分析一系列给定的计算结果来识别其背后的算法。通过这项练习，你将加深对二分法和牛顿法等方法独特“指纹”的理解，为你未来的算法设计与调试打下坚实基础。[@problem_id:2402250]", "problem": "考虑非线性方程 $f(x)=x^3-x-1=0$，它在区间 $[a_0,b_0]=[1,2]$ 上有唯一的实数根。一个黑盒求解器以初始括号区间 $[1,2]$ 运行，并报告了以下根的估计值序列 $\\{x_k\\}$：\n$x_0=1.5,\\;\\; x_1=1.25,\\;\\; x_2=1.375,\\;\\; x_3=1.3125,\\;\\; x_4=1.32486,\\;\\; x_5=1.32472.$\n求解器没有透露任何其他内部状态。仅根据观察到的迭代值和 $f(x)$ 的定义，选择最合理的混合策略以及方法切换其更新规则时的迭代索引。对于本问题，“切换迭代”是指第一个与非区间限定步骤一致的迭代值出现的索引 $k$。\n\n哪个选项最能解释观察到的序列？\n\nA. 一种混合方法，在 $k=0,1,2,3$ 时执行二分法，然后在 $k=4$ 时切换到应用于 $f(x)$ 的牛顿法，并且仅当牛顿步长位于当前括号区间内时才接受该步。\n\nB. 一种混合方法，在 $k=0,1,2,3$ 时执行经典试位法（伪位置法），然后在 $k=4$ 时切换到割线法。\n\nC. 从一开始就使用纯割线法，初始猜测值为 $x_0=1$ 和 $x_1=2$。\n\nD. 无切换的纯二分法；所有 $x_k$ 都是当前括号区间的中点。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 非线性方程：$f(x) = x^3 - x - 1 = 0$。\n- 初始括号区间：$[a_0, b_0] = [1, 2]$。\n- 根的估计值序列：$\\{x_k\\}$。\n  $x_0 = 1.5$\n  $x_1 = 1.25$\n  $x_2 = 1.375$\n  $x_3 = 1.3125$\n  $x_4 = 1.32486$\n  $x_5 = 1.32472$\n- “切换迭代”的定义：第一个与非区间限定步骤一致的迭代值出现的索引 $k$。\n- 任务：从给定选项中确定最合理的混合策略和切换索引。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据：**该问题将标准的数值求根算法（二分法、牛顿法、试位法、割线法）应用于一个简单的多项式函数。这些主题是计算物理和数值分析的基础。该问题的前提是科学合理的。\n- **适定性：**该问题提供了一个数值结果序列，并要求从一组固定的选项中识别生成该序列的算法。这是一个定义明确的演绎问题。\n- **客观性：**该问题使用精确的数值数据和标准术语进行陈述。它没有歧义和主观论断。\n- 该问题是自洽的、一致的，并且可通过计算进行科学验证。未发现任何缺陷。\n\n步骤3：结论与行动\n问题有效。将推导解答。\n\n主方程为 $f(x) = x^3 - x - 1 = 0$。其导数为 $f'(x) = 3x^2 - 1$。\n初始区间为 $[a_0, b_0] = [1, 2]$。我们计算函数在端点处的值：\n$f(1) = 1^3 - 1 - 1 = -1$。\n$f(2) = 2^3 - 2 - 1 = 5$。\n由于 $f(1)  0$ 且 $f(2) > 0$，在区间 $[1, 2]$ 中至少存在一个根。由于对于所有 $x \\in [1, 2]$，$f'(x) = 3x^2 - 1 > 0$，函数在该区间上是单调递增的，所以根是唯一的。\n\n我们现在将分析迭代序列 $\\{x_k\\}$ 以确定所使用的算法。\n\n对 $k=0, 1, 2, 3$ 的迭代值进行分析：\n1.  **k=0**: 第一个迭代值是 $x_0 = 1.5$。这是初始区间 $[1, 2]$ 的中点，因为 $\\frac{1+2}{2} = 1.5$。这与二分法一致。\n    我们为区间法找到新的区间。$f(x_0) = f(1.5) = (1.5)^3 - 1.5 - 1 = 3.375 - 2.5 = 0.875$。由于 $f(1)  0$ 且 $f(1.5) > 0$，新的区间是 $[a_1, b_1] = [1, 1.5]$。\n\n2.  **k=1**: 第二个迭代值是 $x_1 = 1.25$。这是新区间 $[1, 1.5]$ 的中点，因为 $\\frac{1+1.5}{2} = 1.25$。这也与二分法一致。\n    我们找到下一个区间。$f(x_1) = f(1.25) = (1.25)^3 - 1.25 - 1 = 1.953125 - 2.25 = -0.296875$。由于 $f(1.25)  0$ 且 $f(1.5) > 0$，新的区间是 $[a_2, b_2] = [1.25, 1.5]$。\n\n3.  **k=2**: 第三个迭代值是 $x_2 = 1.375$。这是区间 $[1.25, 1.5]$ 的中点，因为 $\\frac{1.25+1.5}{2} = 1.375$。这与二分法一致。\n    我们找到下一个区间。$f(x_2) = f(1.375) = (1.375)^3 - 1.375 - 1 \\approx 2.599609 - 2.375 = 0.224609$。由于 $f(1.25)  0$ 且 $f(1.375) > 0$，新的区间是 $[a_3, b_3] = [1.25, 1.375]$。\n\n4.  **k=3**: 第四个迭代值是 $x_3 = 1.3125$。这是区间 $[1.25, 1.375]$ 的中点，因为 $\\frac{1.25+1.375}{2} = 1.3125$。这也与二分法一致。\n    我们找到下一个区间。$f(x_3) = f(1.3125) = (1.3125)^3 - 1.3125 - 1 \\approx 2.260986 - 2.3125 = -0.051514$。由于 $f(1.3125)  0$ 且 $f(1.375) > 0$，新的区间是 $[a_4, b_4] = [1.3125, 1.375]$。\n\n迭代值 $x_0, x_1, x_2, x_3$ 完全可以用二分法来解释。\n\n现在我们评估每个选项。\n\n**D. 无切换的纯二分法；所有 $x_k$ 都是当前括号区间的中点。**\n要通过二分法获得 $x_4$，我们需要取最后一个区间 $[1.3125, 1.375]$ 的中点。\n$x_4^{\\text{bisect}} = \\frac{1.3125 + 1.375}{2} = 1.34375$。\n给定的迭代值是 $x_4 = 1.32486$。由于 $1.34375 \\neq 1.32486$，该方法不是纯二分法。\n结论：**错误**。\n\n**C. 从一开始就使用纯割线法，初始猜测值为 $x_0=1$ 和 $x_1=2$。**\n基于 $x_n$ 和 $x_{n-1}$ 计算下一个迭代值 $x_{n+1}$ 的割线法公式是 $x_{n+1} = x_n - f(x_n) \\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$。\n使用初始猜测值 $p_0=1$ 和 $p_1=2$，计算出的第一个迭代值是：\n$p_2 = p_1 - f(p_1) \\frac{p_1 - p_0}{f(p_1) - f(p_0)} = 2 - f(2) \\frac{2-1}{f(2)-f(1)} = 2 - 5 \\frac{1}{5 - (-1)} = 2 - \\frac{5}{6} = \\frac{7}{6} \\approx 1.16667$。\n给定序列中的第一个迭代值是 $x_0=1.5$。这两者不匹配。\n结论：**错误**。\n\n**B. 一种混合方法，在 $k=0,1,2,3$ 时执行经典试位法（伪位置法），然后在 $k=4$ 时切换到割线法。**\n试位法将下一个迭代值计算为连接当前括号区间 $[a_k, b_k]$ 端点的割线的根：$x_{k+1} = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$。\n对于第一步，$[a_0, b_0] = [1, 2]$。$f(1)=-1, f(2)=5$。\n$x_0^{\\text{RF}} = \\frac{1 \\cdot 5 - 2 \\cdot (-1)}{5 - (-1)} = \\frac{5+2}{6} = \\frac{7}{6} \\approx 1.16667$。\n给定序列中的第一个迭代值是 $x_0=1.5$。这两者不匹配。\n结论：**错误**。\n\n**A. 一种混合方法，在 $k=0,1,2,3$ 时执行二分法，然后在 $k=4$ 时切换到应用于 $f(x)$ 的牛顿法，并且仅当牛顿步长位于当前括号区间内时才接受该步。**\n如前所述，$k=0,1,2,3$ 的迭代值与二分法完全一致。这意味着该陈述的第一部分是正确的。\n该选项提出在 $k=4$ 时进行切换。这意味着迭代值 $x_4$ 是使用新规则——牛顿法计算的。牛顿法的更新规则是 $x_{n+1} = x_n - \\frac{f(x_n)}{f'(x_n)}$。\n混合方法中的一个常见策略是从当前最佳估计值（即 $x_3 = 1.3125$）开始牛顿步。\n让我们从 $x_3$ 开始，用一步牛顿法计算 $x_4$：\n$x_4^{\\text{Newton}} = x_3 - \\frac{f(x_3)}{f'(x_3)} = 1.3125 - \\frac{(1.3125)^3 - 1.3125 - 1}{3(1.3125)^2 - 1}$。\n$f(1.3125) = -0.051513671875$。\n$f'(1.3125) = 3(1.72265625) - 1 = 5.16796875 - 1 = 4.16796875$。\n$x_4^{\\text{Newton}} = 1.3125 - \\frac{-0.051513671875}{4.16796875} \\approx 1.3125 + 0.012359434 \\approx 1.324859434$。\n将此结果四舍五入到小数点后5位，得到 $1.32486$，这与给定的 $x_4$ 完全匹配。\n根据问题定义，切换发生在 $k=4$ 时，这是第一个不遵循初始（二分法）规则的迭代值（$x_4$）的索引。这是相符的。\n该选项还声明了一个条件：只有当牛顿步长位于当前括号区间内时才接受它。在计算 $x_4$ 之前的括号区间是 $[a_4, b_4] = [1.3125, 1.375]$。计算出的迭代值 $x_4 \\approx 1.32486$ 确实在此区间内，因此满足此条件。\n现在让我们检查下一个迭代值 $x_5$。如果该方法继续使用牛顿法，则下一步将是：\n$x_5^{\\text{Newton}} = x_4 - \\frac{f(x_4)}{f'(x_4)}$，从 $x_4 = 1.32486$ 开始。\n$f(1.32486) \\approx (1.32486)^3 - 1.32486 - 1 \\approx 2.325376 - 1.32486 - 1 = 0.000516$。\n$f'(1.32486) \\approx 3(1.32486)^2 - 1 \\approx 3(1.75525) - 1 = 4.26575$。\n$x_5^{\\text{Newton}} \\approx 1.32486 - \\frac{0.000516}{4.26575} \\approx 1.32486 - 0.000121 \\approx 1.324739$。\n给定值为 $x_5 = 1.32472$。我们计算出的值为 $1.32474$（四舍五入后）。这是一个非常小的差异，很可能归因于问题提供的序列中的舍入误差。事实上，给定的 $x_5$ 是比从四舍五入的 $x_4$ 计算出的值更好的对真根（$r \\approx 1.324717957...$）的近似。\n鉴于前5个迭代值（$x_0$ 到 $x_4$）的完美匹配，以及一旦根被定位就从安全的二分法切换到快速收敛的牛顿法的合理机制，这个选项是迄今为止最合理的解释。其他选项在第一步就失败了。\n结论：**正确**。", "answer": "$$\\boxed{A}$$", "id": "2402250"}, {"introduction": "现在，让我们从分析转向构建。混合算法的优势在于其鲁棒性，但这完全依赖于一个有效的初始区间。本练习将引导你寻找一个高阶多项式的所有根，其核心挑战在于如何系统性地确定一组互不重叠的、能将每个根分离开来的区间。这项实践将教会你如何利用函数本身的性质（例如根与极值的交错特性）来保证算法的全局收敛性。[@problem_id:2402261]", "problem": "给定第一类 Chebyshev 多项式，对于任意整数阶 $n \\ge 0$ 和所有实数 $\\theta$，其定义关系为 $T_n(\\cos \\theta) = \\cos(n \\theta)$。对于任意给定的 $n \\ge 1$，多项式 $T_n(x)$ 在开区间 $(-1,1)$ 内恰好有 $n$ 个单根。这 $n$ 个根的明确位置由集合 $\\left\\{\\cos\\left(\\dfrac{(2k-1)\\pi}{2n}\\right) : k = 1,2,\\dots,n \\right\\}$ 给出。角度必须以弧度解释。\n\n编写一个完整的、可运行的程序，对于每个指定的测试值 $n$，通过对每个根数值求解标量非线性方程 $T_n(x)=0$ 来计算 $T_n(x)$ 在区间 $[-1,1]$ 上的所有 $n$ 个根，然后将数值计算出的根与上述解析集进行比较。您的数值求解器产生的根在 $x$ 上的绝对精度目标必须最多为 $10^{-10}$。为了进行数值求解，您不能假设预先知道根的位置；相反，应直接根据 $T_n(x)$ 的定义性质来确定它们。计算出根集后，按升序对其进行排序，并计算数值根与解析值 $\\cos\\left(\\dfrac{(2k-1)\\pi}{2n}\\right)$（$k=1,\\dots,n$）之间的最大绝对差异。\n\n使用以下阶数的测试套件：\n- $n = 1$\n- $n = 17$\n- $n = 50$\n- $n = 100$\n- $n = 200$\n\n对于测试套件中的每个 $n$，您的程序必须输出一个实数，该实数等于计算出的根与解析集之间的最大绝对差值（在 $x$ 上），并由您的编程环境的默认格式进行四舍五入。最终输出必须是单行，其中包含一个用方括号括起来的、由逗号分隔的这五个数字的列表。例如，输出形式必须为“[r1,r2,r3,r4,r5]”，其中每个 $rj$ 是对应测试用例的实值最大绝对差异。所有角度必须以弧度解释。此问题不涉及任何物理单位，所有数值答案均为不带单位的纯数。", "solution": "所提出的问题是数值分析中的一个标准练习，特别是在特殊函数求根领域。该问题是有效的、自洽的，且在科学上是合理的。它要求对第一类 Chebyshev 多项式 $T_n(x)$ 在几个阶数 $n$ 下的根进行数值确定，并随后与已知的解析解进行比较，以量化数值误差。求解器不得使用解析根位置进行初始化的约束是一项关键且恰当的指令，它强制要求基于多项式本身的基本性质来寻找解决方案。\n\n我们的方法将是系统性的，并基于第一性原理。\n\n首先，我们必须有一种方法来计算任意整数 $n \\ge 0$ 和实数参数 $x \\in [-1, 1]$ 下的 $T_n(x)$。虽然定义 $T_n(x) = \\cos(n \\arccos(x))$ 在数学上是精确的，但在数值求根的上下文中直接使用它并不理想，因为其计算依赖于反三角函数。一个更实用的工具是 Chebyshev 多项式满足的三项递推关系：\n$$\nT_0(x) = 1 \\\\\nT_1(x) = x \\\\\nT_{k+1}(x) = 2xT_k(x) - T_{k-1}(x) \\quad \\text{for } k \\ge 1\n$$\n该递推关系提供了一种计算上稳定且高效的方法，通过简单的迭代过程来计算任意 $n$ 的 $T_n(x)$。这将是我们函数求值的核心。\n\n其次，为了满足在不预知根位置的情况下找到根的约束，我们必须设计一种策略，将 $n$ 个根中的每一个都隔离到一个唯一的包围区间内。我们利用的基本性质是根与极值的交错特性。$T_n(x)$ 在区间 $[-1, 1]$ 上的极值点是众所周知的，出现在以下 $n+1$ 个点上：\n$$\nx_k^{\\text{ext}} = \\cos\\left(\\frac{k\\pi}{n}\\right) \\quad \\text{for } k = 0, 1, \\dots, n\n$$\n在这些点上，多项式取值为：\n$$\nT_n(x_k^{\\text{ext}}) = T_n\\left(\\cos\\left(\\frac{k\\pi}{n}\\right)\\right) = \\cos\\left(n \\cdot \\frac{k\\pi}{n}\\right) = \\cos(k\\pi) = (-1)^k\n$$\n由于在任意两个连续极值点上，函数值在 $+1$ 和 $-1$ 之间交替，因此 $T_n(x_{k}^{\\text{ext}}) \\cdot T_n(x_{k+1}^{\\text{ext}}) = -1$。根据介值定理，在由连续极值点定义的 $n$ 个开区间中的每一个区间 $(\\cos(\\frac{(k+1)\\pi}{n}), \\cos(\\frac{k\\pi}{n}))$（$k=0, 1, \\dots, n-1$）内，必定至少存在一个根。因为 $T_n(x)$ 是一个 $n$ 次多项式，所以它最多有 $n$ 个实根。因此，我们已经确定了 $n$ 个不相交的区间，每个区间恰好包含一个根。这些区间可作为数值求根算法的严格包围区间。\n\n第三，对于每个根的包围区间 $[a, b]$，我们需要一个稳健的数值求解器。虽然二分法保证收敛，但其线性收敛速度较慢。一个更优越的选择是 Brent 方法，它结合了二分法的保证收敛性与割线法和逆二次插值的更快收敛速度。我们将采用 Brent 方法的标准实现，例如 `scipy.optimize.brentq`，以远优于所要求的 $10^{-10}$ 绝对精度的容差来找到每个根。对于根的位置 $x$，绝对容差取 $10^{-12}$ 是一个合适的选择。\n\n最后，验证步骤涉及将 $n$ 个数值计算出的根集 $\\{x_k^{\\text{num}}\\}$ 与 $n$ 个解析根集 $\\{x_k^{\\text{ana}}\\}$ 进行比较。$T_n(x)$ 的根的解析公式由下式给出：\n$$\nx_k^{\\text{ana}} = \\cos\\left(\\frac{(2k-1)\\pi}{2n}\\right) \\quad \\text{for } k = 1, 2, \\dots, n\n$$\n为确保正确比较，数值根集和解析根集都将按升序排序。误差的度量将是排序后列表中相应根之间的最大绝对差异：\n$$\n\\Delta_{\\text{max}} = \\max_{k=1,\\dots,n} |x_k^{\\text{num}} - x_k^{\\text{ana}}|\n$$\n此过程将对指定测试套件中的每个 $n$ 值执行：$n \\in \\{1, 17, 50, 100, 200\\}$。每个 $n$ 产生的 $\\Delta_{\\text{max}}$ 值将构成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute discrepancy between numerically found roots and\n    analytic roots of Chebyshev polynomials T_n(x) for a suite of n values.\n    \"\"\"\n\n    def calculate_T_n(n, x):\n        \"\"\"\n        Computes the Chebyshev polynomial T_n(x) using the three-term recurrence relation.\n        This is numerically stable and efficient.\n\n        Args:\n            n (int): The order of the polynomial.\n            x (float): The point at which to evaluate the polynomial.\n\n        Returns:\n            float: The value of T_n(x).\n        \"\"\"\n        if n == 0:\n            return 1.0\n        if n == 1:\n            return x\n\n        # Iterative calculation using the recurrence relation\n        # T_{k+1}(x) = 2xT_k(x) - T_{k-1}(x)\n        T_k_minus_2 = 1.0\n        T_k_minus_1 = x\n        for _ in range(2, n + 1):\n            T_k = 2.0 * x * T_k_minus_1 - T_k_minus_2\n            T_k_minus_2 = T_k_minus_1\n            T_k_minus_1 = T_k\n        return T_k_minus_1\n\n    # Define the test cases from the problem statement.\n    test_cases = [1, 17, 50, 100, 200]\n    \n    results = []\n    \n    # Absolute accuracy target for the root finding algorithm in x.\n    # Set to a value stricter than the problem's requirement of 1e-10.\n    solver_tolerance = 1e-12\n\n    for n in test_cases:\n        # Define the function whose roots we seek for the current n.\n        # Lambda function captures the current value of n.\n        T_n_func = lambda x: calculate_T_n(n, x)\n\n        numerical_roots = []\n\n        # Find the locations of the extrema of T_n(x), which serve to bracket the roots.\n        # Extrema are at cos(k*pi/n) for k = 0, 1, ..., n.\n        # These points are naturally sorted in descending order from 1 to -1.\n        extrema_points = np.cos(np.arange(n + 1) * np.pi / n)\n\n        # Iterate through the n intervals defined by consecutive extrema.\n        for k in range(n):\n            # The bracket for a single root is [extrema_points[k+1], extrema_points[k]].\n            a = extrema_points[k + 1]\n            b = extrema_points[k]\n            \n            # Use Brent's method to find the root within the bracket [a, b].\n            # brentq is robust and fast, ideal for this task.\n            root = brentq(T_n_func, a, b, xtol=solver_tolerance)\n            numerical_roots.append(root)\n\n        # Convert to a numpy array for vectorized operations.\n        numerical_roots = np.array(numerical_roots)\n        \n        # Sort the numerically found roots in ascending order for consistent comparison.\n        numerical_roots.sort()\n\n        # Compute the analytical roots for comparison.\n        # The formula is cos((2k-1)*pi/(2n)) for k = 1, 2, ..., n.\n        k_vals = np.arange(1, n + 1)\n        analytical_roots = np.cos((2 * k_vals - 1) * np.pi / (2 * n))\n        \n        # The analytic formula produces roots in descending order, so we sort them ascending.\n        analytical_roots.sort()\n        \n        # Compute the maximum absolute difference between the numerical and analytical roots.\n        max_discrepancy = np.max(np.abs(numerical_roots - analytical_roots))\n        results.append(max_discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402261"}, {"introduction": "当我们掌握了可靠的混合策略后，自然会探索如何对其进行优化。一个更复杂、收敛阶数更高的方法（如三阶的哈雷方法）是否总比标准的牛顿法更优越？本练习将指导你推导一个三阶方法，并实现一个混合求解器，以深入分析在迭代次数和每次迭代的计算成本之间的权衡。这有助于你理解在实际问题中如何根据计算成本来做出明智的算法设计选择。[@problem_id:2402194]", "problem": "您的任务是设计并评估一种全局收敛的混合求根算法，其中的开放方法部分为一种三阶方法。核心设定是在一个保证有根的区间 $[a,b]$（满足 $f(a)f(b)  0$）内，求解一个光滑非线性标量函数 $f(x)$ 的一个单根 $x^\\star$。您的设计必须基于以下广为接受的原则：(i) 介值定理，该定理保证了如果 $f(a)f(b)  0$，则在 $[a,b]$ 中至少存在一个根；以及 (ii) 光滑函数的泰勒展开，它为在根附近使用高阶开放方法步骤提供了理论依据。三角函数的角度单位必须是弧度。\n\n您的任务是：\n\n- 从泰勒展开推导，并且不使用任何预先提供的迭代公式，得出一个在标准光滑性和非退化条件下对单根达到三阶局部收敛的开放步更新。此开放步必须仅使用在当前迭代点计算的 $f(x)$、$f'(x)$ 和 $f''(x)$。\n- 实现一个鲁棒的混合方法，该方法：\n  - 在每次迭代 $k$ 中都维持一个隔根区间 $[a_k,b_k]$，满足 $f(a_k)f(b_k) \\le 0$。\n  - 从当前点 $x_k$ 使用您的三阶更新提出一个开放步。\n  - 仅当开放步保持在 $(a_k,b_k)$ 内部并且严格减小残差的绝对值时，才接受该开放步。否则，必须退回到二分法步骤。\n  - 使用在接受的新点处的函数符号来更新隔根区间。\n  - 当绝对残差低于规定的容差或区间宽度足够小时终止。\n- 作为比较，也实现一个基准混合方法，其中开放步是经典的Newton更新（二阶局部收敛），并采用与上述相同的保障措施和回退策略。\n- 将计算成本建模为求值次数的加权和，其中一次 $f(x)$ 求值的成本是 $c_0$，一次 $f'(x)$ 的成本是 $c_1$，一次 $f''(x)$ 的成本是 $c_2$。计算您的算法执行的每一次求值，并计算每种方法的总加权成本。\n\n使用绝对残差容差 $\\lvert f(x) \\rvert \\le \\varepsilon$（其中 $\\varepsilon = 10^{-12}$）和区间宽度容差 $\\lvert b-a \\rvert \\le \\varepsilon$，并强制执行最多 $100$ 次迭代。角度必须以弧度为单位。最终答案不涉及物理单位。\n\n测试套件规范。为以下每个测试案例（每个案例都包含隔根区间 $[a,b]$ 和求值成本 $(c_0,c_1,c_2)$），解析地实现 $f(x)$、$f'(x)$ 和 $f''(x)$：\n\n- 案例 1：$f(x) = \\cos(x) - x$，$[a,b] = [0,1]$，$(c_0,c_1,c_2) = (1.0,1.0,1.0)$。\n- 案例 2：$f(x) = \\cos(x) - x$，$[a,b] = [0,1]$，$(c_0,c_1,c_2) = (1.0,1.0,10.0)$。\n- 案例 3：$f(x) = x^3 - 2x - 5$，$[a,b] = [2,3]$，$(c_0,c_1,c_2) = (1.0,1.0,1.0)$。\n- 案例 4：$f(x) = \\mathrm{e}^x - 3$，$[a,b] = [0,2]$，$(c_0,c_1,c_2) = (1.0,1.0,5.0)$。\n- 案例 5：$f(x) = \\tanh(x) - 0.5$，$[a,b] = [0,2]$，$(c_0,c_1,c_2) = (1.0,2.0,4.0)$。\n- 案例 6：$f(x) = x^5 - x - 1$，$[a,b] = [1,2]$，$(c_0,c_1,c_2) = (1.0,1.0,3.0)$。\n\n对于每个案例，从区间中点 $x_0 = (a+b)/2$ 开始运行两种混合求解器（您推导的三阶求解器和基于Newton法的基准求解器），应用相同的接受标准和回退策略，并计算函数和导数求值的总加权成本。\n\n最终输出要求。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个条目必须是一个布尔值，表示在该案例指定的成本下，采用三阶开放步的混合方法的总加权成本是否严格低于采用Newton开放步的混合方法。例如，一个有效的输出可能形如“[True,False,True,True,False,True]”。", "solution": "所提出的问题是数值分析中一个明确定义的练习，涉及混合求根算法的设计和比较评估。其前提在科学上是合理的，目标是清晰和定量的，并且所有必要的数据和约束都已提供。因此，该问题被认为是有效的，并将给出一个完整的解决方案。\n\n任务是构建一个全局收敛的求根算法，通过将鲁棒的区间套方法（二分法）与快速的、具有三阶收敛性的开放方法相结合。这种混合策略旨在利用开放方法的快速局部收敛性，同时保留区间套方法的保证收敛性。\n\n首先，需要基于泰勒级数展开，并仅使用函数 $f(x)$ 及其前两个导数 $f'(x)$ 和 $f''(x)$，来推导三阶开放步更新。设 $x_k$ 是单根 $x^\\star$（其中 $f(x^\\star) = 0$）的当前近似值。$f(x)$ 在 $x_k$ 附近的泰勒级数展开为：\n$$ f(x^\\star) = f(x_k) + (x^\\star - x_k)f'(x_k) + \\frac{(x^\\star-x_k)^2}{2!}f''(x_k) + O\\left((x^\\star-x_k)^3\\right) $$\n设 $f(x^\\star) = 0$，并令 $h = x_{k+1} - x_k$ 为到下一个迭代点的步长，我们使用 $x_{k+1}$ 作为 $x^\\star$ 的改进近似值。因此，我们有近似 $x^\\star - x_k \\approx h$。将此代入截断的级数，得到关于步长 $h$ 的二次方程：\n$$ 0 \\approx f(x_k) + h f'(x_k) + \\frac{h^2}{2} f''(x_k) $$\n为避免解二次方程，我们可以通过对二次项中的一个 $h$ 因子使用低阶近似来线性化此表达式。构成Newton法基础的一阶泰勒近似提供了估计值 $h \\approx -f(x_k)/f'(x_k)$。将此代入上述方程可得：\n$$ 0 \\approx f(x_k) + h f'(x_k) + \\frac{h}{2} \\left( -\\frac{f(x_k)}{f'(x_k)} \\right) f''(x_k) $$\n从此方程求解 $h$ 可得更新步长：\n$$ h \\left( f'(x_k) - \\frac{f(x_k) f''(x_k)}{2 f'(x_k)} \\right) \\approx -f(x_k) $$\n$$ h = -\\frac{f(x_k)}{f'(x_k) - \\frac{f(x_k) f''(x_k)}{2 f'(x_k)}} $$\n下一个迭代点则是 $x_{k+1} = x_k + h$。此公式即为Halley方法，在标准光滑性条件下，它对单根表现出三次（三阶）局部收敛性。\n\n作为比较，需要一个使用经典的二阶Newton法的基准混合方法。Newton步长由一阶泰勒展开推导得出：\n$$ 0 \\approx f(x_k) + (x^\\star - x_k)f'(x_k) $$\n这直接产生步长 $h = x_{k+1} - x_k \\approx -f(x_k)/f'(x_k)$，以及更新规则：\n$$ x_{k+1} = x_k - \\frac{f(x_k)}{f'(x_k)} $$\n\n整合这些开放步的混合算法设计如下。它从一个隔根区间 $[a_0, b_0]$（其中 $f(a_0)f(b_0)  0$）和一个初始猜测 $x_0 = (a_0+b_0)/2$ 开始。在每次迭代 $k$ 中，给定当前区间 $[a_k, b_k]$ 和迭代点 $x_k$：\n1. 从 $x_k$ 提出一个到新点 $x_{open}$ 的开放步，该步长使用Halley方法或Newton方法计算。此步骤本身需要对 $f(x_k)$、$f'(x_k)$ 进行求值，对于Halley方法，还需要对 $f''(x_k)$ 求值。\n2. 对提议的步骤根据两个保障条件进行验证：\n   a. 区间条件：点 $x_{open}$ 必须严格位于当前隔根区间内，即 $x_{open} \\in (a_k, b_k)$。\n   b. 进展条件：新点的函数绝对值必须严格小于当前点的函数绝对值，即 $|f(x_{open})|  |f(x_k)|$。这需要对 $f$ 在 $x_{open}$ 处进行一次额外的求值。\n3. 如果两个保障条件都通过，则接受开放步，并将下一个迭代点设置为 $x_{k+1} = x_{open}$。\n4. 如果开放步被拒绝（由于未通过保障条件，或由于数值问题如除以零），算法将退回到二分法步骤。下一个迭代点被设置为区间的中点，$x_{k+1} = (a_k + b_k) / 2$。\n5. 更新隔根区间。根据 $f(x_{k+1})$ 的符号，新区间 $[a_{k+1}, b_{k+1}]$ 变为 $[a_k, x_{k+1}]$ 或 $[x_{k+1}, b_k]$，以保持属性 $f(a_{k+1})f(b_{k+1}) \\le 0$。\n6. 当区间宽度 $|b_k - a_k|$ 或函数绝对残差 $|f(x_k)|$ 小于或等于容差 $\\varepsilon = 10^{-12}$ 时，或者在达到最大迭代次数 $100$ 次后，过程停止。\n\n计算成本通过函数和导数求值次数的加权和来评估。如果一个算法完成时，对 $f(x)$ 的求值次数为 $N_0$，对 $f'(x)$ 的求值次数为 $N_1$，对 $f''(x)$ 的求值次数为 $N_2$，每次求值的成本分别为 $c_0, c_1, c_2$，则总成本 $C$ 计算如下：\n$$ C = N_0 c_0 + N_1 c_1 + N_2 c_2 $$\n这个成本模型使得二阶和三阶混合方法之间可以进行公平的比较。问题在于，三阶方法可能减少的迭代次数是否足以抵消每次尝试开放步时计算二阶导数 $f''(x)$ 的额外成本。", "answer": "```python\nimport numpy as np\n\nclass FuncWithCounter:\n    \"\"\"A wrapper class for a function and its derivatives to count evaluations.\"\"\"\n    def __init__(self, f_def, df_def, d2f_def, costs):\n        self._f = f_def\n        self._df = df_def\n        self._d2f = d2f_def\n        self.costs = costs\n        self.f_evals = 0\n        self.df_evals = 0\n        self.d2f_evals = 0\n\n    def f(self, x):\n        self.f_evals += 1\n        return self._f(x)\n\n    def df(self, x):\n        self.df_evals += 1\n        return self._df(x)\n\n    def d2f(self, x):\n        self.d2f_evals += 1\n        return self._d2f(x)\n\n    def reset(self):\n        \"\"\"Resets all evaluation counters to zero.\"\"\"\n        self.f_evals = 0\n        self.df_evals = 0\n        self.d2f_evals = 0\n\n    def total_cost(self):\n        \"\"\"Computes the total weighted cost of all evaluations.\"\"\"\n        c0, c1, c2 = self.costs\n        return self.f_evals * c0 + self.df_evals * c1 + self.d2f_evals * c2\n\ndef hybrid_solver(f_obj, a_start, b_start, tol, max_iter, open_step_type):\n    \"\"\"\n    Globally convergent hybrid root-finding algorithm.\n\n    Args:\n        f_obj (FuncWithCounter): The function object with evaluation counters.\n        a_start (float): The start of the bracketing interval.\n        b_start (float): The end of the bracketing interval.\n        tol (float): The tolerance for termination.\n        max_iter (int): The maximum number of iterations.\n        open_step_type (str): The type of open step ('newton' or 'halley').\n\n    Returns:\n        float: The total computational cost.\n    \"\"\"\n    a, b = float(a_start), float(b_start)\n    f_obj.reset()\n\n    f_a = f_obj.f(a)\n    f_b = f_obj.f(b)\n\n    if np.sign(f_a) == np.sign(f_b):\n        return float('inf')\n\n    x_cur = (a + b) / 2.0\n    f_cur = f_obj.f(x_cur)\n\n    for _ in range(max_iter):\n        if abs(f_cur) = tol or (b - a) = tol:\n            break\n\n        # Propose an open step from the current point\n        open_step_valid = False\n        try:\n            df_cur = f_obj.df(x_cur)\n            if abs(df_cur)  1e-15: # Avoid division by zero\n                raise ValueError(\"Derivative is too small.\")\n            \n            if open_step_type == 'newton':\n                x_open = x_cur - f_cur / df_cur\n                open_step_valid = True\n            elif open_step_type == 'halley':\n                d2f_cur = f_obj.d2f(x_cur)\n                denom = df_cur - (f_cur * d2f_cur) / (2.0 * df_cur)\n                if abs(denom)  1e-15: # Avoid division by zero\n                    raise ValueError(\"Halley denominator is too small.\")\n                x_open = x_cur - f_cur / denom\n                open_step_valid = True\n        except (ValueError, ZeroDivisionError):\n            open_step_valid = False\n\n        accepted = False\n        if open_step_valid and (a  x_open  b):\n            f_open = f_obj.f(x_open)\n            if abs(f_open)  abs(f_cur):\n                x_next = x_open\n                f_next = f_open\n                accepted = True\n\n        if not accepted:\n            x_next = (a + b) / 2.0\n            if x_next == x_cur: # Interval is at machine precision limit\n                f_next = f_cur\n            else:\n                f_next = f_obj.f(x_next)\n\n        # Update current point and function value\n        x_cur = x_next\n        f_cur = f_next\n        \n        # Update bracket\n        if np.sign(f_cur) == np.sign(f_a):\n            a = x_cur\n            f_a = f_cur\n        else:\n            b = x_cur\n            f_b = f_cur\n\n    return f_obj.total_cost()\n\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {'func': lambda x: np.cos(x) - x, 'df': lambda x: -np.sin(x) - 1.0, 'd2f': lambda x: -np.cos(x),\n         'interval': (0.0, 1.0), 'costs': (1.0, 1.0, 1.0)},\n        {'func': lambda x: np.cos(x) - x, 'df': lambda x: -np.sin(x) - 1.0, 'd2f': lambda x: -np.cos(x),\n         'interval': (0.0, 1.0), 'costs': (1.0, 1.0, 10.0)},\n        {'func': lambda x: x**3 - 2.0*x - 5.0, 'df': lambda x: 3.0*x**2 - 2.0, 'd2f': lambda x: 6.0*x,\n         'interval': (2.0, 3.0), 'costs': (1.0, 1.0, 1.0)},\n        {'func': lambda x: np.exp(x) - 3.0, 'df': lambda x: np.exp(x), 'd2f': lambda x: np.exp(x),\n         'interval': (0.0, 2.0), 'costs': (1.0, 1.0, 5.0)},\n        {'func': lambda x: np.tanh(x) - 0.5, 'df': lambda x: 1.0 / (np.cosh(x)**2), 'd2f': lambda x: -2.0 * np.tanh(x) / (np.cosh(x)**2),\n         'interval': (0.0, 2.0), 'costs': (1.0, 2.0, 4.0)},\n        {'func': lambda x: x**5 - x - 1.0, 'df': lambda x: 5.0*x**4 - 1.0, 'd2f': lambda x: 20.0*x**3,\n         'interval': (1.0, 2.0), 'costs': (1.0, 1.0, 3.0)}\n    ]\n\n    results = []\n    TOL = 1e-12\n    MAX_ITER = 100\n\n    for case in test_cases:\n        a, b = case['interval']\n        f_obj = FuncWithCounter(case['func'], case['df'], case['d2f'], case['costs'])\n\n        cost_newton = hybrid_solver(f_obj, a, b, TOL, MAX_ITER, 'newton')\n        cost_halley = hybrid_solver(f_obj, a, b, TOL, MAX_ITER, 'halley')\n        \n        results.append(cost_halley  cost_newton)\n\n    # Convert boolean to lowercase string for Python-like output\n    bool_to_str = [str(r) for r in results]\n    print(f\"[{','.join(bool_to_str)}]\")\n\nsolve()\n```", "id": "2402194"}]}