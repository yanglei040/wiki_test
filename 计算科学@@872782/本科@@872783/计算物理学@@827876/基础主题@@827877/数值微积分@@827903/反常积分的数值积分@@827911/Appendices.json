{"hands_on_practices": [{"introduction": "我们以一个物理学中的基本守恒定律作为起点。本练习将通过数值方法验证一维和二维热方程的基本解（格林函数）在全空间上的积分等于1，这代表了总能量或总概率的守恒 [@problem_id:2419418]。这个练习不仅能帮助你掌握在无穷大区间（从 $-\\infty$ 到 $\\infty$）上进行数值积分的基本技能，还将通过二维情形下的计算，展示如何利用坐标变换（如此处的极坐标）将一个看似复杂的多维反常积分问题简化为易于处理的一维积分。", "problem": "考虑一维和二维空间中扩散（热）方程的基本解（格林函数）。对于正的扩散系数 $D>0$ 和时间 $t>0$，一维格林函数为\n$$\nG_{1}(x,t;D)=\\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right),\n$$\n其定义域为 $x\\in\\mathbb{R}$，二维格林函数为\n$$\nG_{2}(\\mathbf{r},t;D)=\\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right),\n$$\n其定义域为 $\\mathbf{r}\\in\\mathbb{R}^{2}$。对于这些基本解，总“能量”（总概率质量）守恒的数学表述是，其在整个空间域上的对应反常积分等于 $1$，即\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx,\n\\quad\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r},\n$$\n守恒定律要求对于所有 $D>0$ 和 $t>0$ 都有 $I_{1}(D,t)=1$ 和 $I_{2}(D,t)=1$。\n\n您的任务是编写一个完整、可运行的程序，分别对给定的一维和二维空间参数值 $(D,t)$ 数值计算这些反常积分，并返回计算结果。程序必须通过在整个定义域 $\\mathbb{R}$ 和 $\\mathbb{R}^{2}$ 上进行数值积分来计算 $I_{1}(D,t)$ 和 $I_{2}(D,t)$，不得使用任何闭式反导数。\n\n测试套件：\n- 情况 1（一维）：$D=0.5$, $t=2.0$；计算 $I_{1}(D,t)$。\n- 情况 2（二维）：$D=1.0$, $t=0.1$；计算 $I_{2}(D,t)$。\n- 情况 3（二维，短时间）：$D=1.0$, $t=10^{-4}$；计算 $I_{2}(D,t)$。\n- 情况 4（一维，大时间和扩散）：$D=3.0$, $t=100.0$；计算 $I_{1}(D,t)$。\n- 情况 5（二维，小扩散）：$D=10^{-3}$, $t=5.0$；计算 $I_{2}(D,t)$。\n\n您的程序必须生成单行输出，其中包含按上述情况顺序排列的结果，形式为方括号内用逗号分隔的列表。每个结果必须是精确到小数点后 $10$ 位的浮点数。例如，输出必须具有以下形式\n$[r_{1},r_{2},r_{3},r_{4},r_{5}]$,\n其中 $r_{k}$ 是情况 $k$ 的四舍五入后的数值。", "solution": "该问题要求对两个反常积分 $I_1$ 和 $I_2$ 进行数值计算，它们分别代表一维和二维扩散方程基本解的总概率质量。这是一个适定、科学上合理且完整的问题。扩散过程中固有的守恒定律规定，对于任何有效的参数 $D>0$ 和 $t>0$，这些积分的解析值都精确为 $1$。我们的任务是数值验证这一性质。\n\n数值方法将依赖于 `scipy.integrate.quad` 函数，该函数实现了一种适用于反常积分的稳健自适应求积算法。\n\n对于一维情况，需要计算的积分是\n$$\nI_{1}(D,t)=\\int_{-\\infty}^{\\infty} G_{1}(x,t;D)\\,dx = \\int_{-\\infty}^{\\infty} \\frac{1}{\\sqrt{4\\pi D t}}\\exp\\!\\left(-\\frac{x^{2}}{4Dt}\\right) dx\n$$\n通过将被积函数 $G_1(x, t; D)$ 和定义域 $(-\\infty, \\infty)$ 传递给数值求积程序，可以直接计算该积分。\n\n对于二维情况，直接对下式进行数值积分\n$$\nI_{2}(D,t)=\\iint_{\\mathbb{R}^{2}} G_{2}(\\mathbf{r},t;D)\\,d^{2}\\mathbf{r} = \\iint_{\\mathbb{R}^{2}} \\frac{1}{4\\pi D t}\\exp\\!\\left(-\\frac{\\|\\mathbf{r}\\|^{2}}{4Dt}\\right) d^{2}\\mathbf{r}\n$$\n效率低下。一种更优的方法是将积分变换到极坐标 $(r, \\theta)$，其中 $\\|\\mathbf{r}\\| = r$，面积元为 $d^{2}\\mathbf{r} = r\\,dr\\,d\\theta$。积分域 $\\mathbb{R}^2$ 对应于 $r \\in [0, \\infty)$ 和 $\\theta \\in [0, 2\\pi)$。积分变换为\n$$\nI_{2}(D, t) = \\int_0^{2\\pi} \\int_0^{\\infty} \\frac{1}{4\\pi D t}\\exp\\left(-\\frac{r^2}{4Dt}\\right) r\\,dr\\,d\\theta\n$$\n由于被积函数不依赖于 $\\theta$，角向积分是平凡的，结果为一个因子 $2\\pi$。这将问题简化为单个一维积分：\n$$\nI_{2}(D, t) = \\frac{2\\pi}{4\\pi D t} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr = \\frac{1}{2Dt} \\int_0^{\\infty} r \\exp\\left(-\\frac{r^2}{4Dt}\\right) dr\n$$\n然后在定义域 $[0, \\infty)$ 上的这个简化积分便可以高效且高精度地进行数值计算。\n\n程序将处理提供的全部 5 个测试用例：\n1.  一维：$D=0.5$, $t=2.0$\n2.  二维：$D=1.0$, $t=0.1$\n3.  二维：$D=1.0$, $t=10^{-4}$\n4.  一维：$D=3.0$, $t=100.0$\n5.  二维：$D=10^{-3}$, $t=5.0$\n\n它将为每种情况选择适当的积分方法（一维或极坐标简化后的二维）。最终的数值结果将四舍五入到小数点后恰好 $10$ 位，并以指定的列表格式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Numerically evaluates the improper integrals for the Green's functions\n    of the 1D and 2D diffusion equations for specified test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (dimensionality, D, t)\n    test_cases = [\n        (1, 0.5, 2.0),\n        (2, 1.0, 0.1),\n        (2, 1.0, 1e-4),\n        (1, 3.0, 100.0),\n        (2, 10**-3, 5.0)\n    ]\n\n    # Define the integrand for the 1D case, G_1(x, t; D).\n    def g1_integrand(x, D, t):\n        \"\"\"Integrand for the 1D Green's function G_1.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = 1.0 / np.sqrt(np.pi * denominator)\n        return prefactor * np.exp(-x**2 / denominator)\n\n    # Define the integrand for the 2D case after reduction to 1D via polar coordinates.\n    # This corresponds to f(r) = (r / (2*D*t)) * exp(-r^2 / (4*D*t)).\n    def g2_integrand_polar(r, D, t):\n        \"\"\"Integrand for the 2D Green's function in polar coordinates.\"\"\"\n        denominator = 4.0 * D * t\n        prefactor = r / (2.0 * D * t)\n        return prefactor * np.exp(-r**2 / denominator)\n\n    results = []\n    for case in test_cases:\n        dim, D, t = case\n        \n        integral_value = 0.0\n        if dim == 1:\n            # Perform the 1D improper integral from -inf to +inf.\n            integral_value, _ = quad(g1_integrand, -np.inf, np.inf, args=(D, t))\n        else:  # dim == 2\n            # Perform the 1D improper integral from 0 to +inf for the polar-reduced problem.\n            integral_value, _ = quad(g2_integrand_polar, 0, np.inf, args=(D, t))\n        \n        results.append(integral_value)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to 10 decimal places.\n    print(f\"[{','.join(f'{res:.10f}' for res in results)}]\")\n\nsolve()\n```", "id": "2419418"}, {"introduction": "在处理了无穷积分域之后，我们将面临另一类常见的挑战：在有限点处存在奇点的被积函数。本练习要求计算伽马分布随机变量对数的期望值，其积分形式为 $\\int_0^\\infty \\ln(x) f(x;k) dx$ [@problem_id:2419387]。这个积分不仅积分区间是无穷的，而且在积分下限 $x=0$ 处还有一个对数奇点。通过这个练习，你将了解到现代数值积分程序是如何稳健地处理这类可积奇点的，这在统计物理和量子力学的许多问题中都至关重要。", "problem": "给定一个无量纲随机变量 $X$，它服从形状参数为 $k>0$ 且单位尺度的伽马分布。其概率密度函数为\n$$\nf(x;k)=\\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x>0,\n$$\n其中 $\\Gamma(k)$ 是伽马函数，定义为\n$$\n\\Gamma(k)=\\int_0^{\\infty} x^{k-1}e^{-x}\\,dx.\n$$\n你的任务是编写一个完整的程序，对每个指定的 $k$ 值，数值计算其期望\n$$\n\\mathbb{E}[\\ln X]=\\int_0^{\\infty} \\ln(x)\\, f(x;k)\\,dx\n$$\n由于其无穷定义域和在 $x=0$ 处的对数奇异点，这是一个反常积分。计算每个值时，绝对数值误差不得超过 $10^{-10}$，然后将最终报告的值四舍五入到 $12$ 位小数。\n\n测试套件（需要计算的形状参数 $k$）：\n- $k=\\tfrac{1}{2}$\n- $k=1$\n- $k=\\tfrac{3}{2}$\n- $k=10$\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与上面列出的一致。每个条目必须四舍五入到 $12$ 位小数。例如，一个包含四个结果的输出应如下所示：\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4].\n$$", "solution": "该问题要求数值计算期望值 $\\mathbb{E}[\\ln X]$，其中 $X$ 是一个随机变量，服从给定形状参数为 $k>0$ 和单位尺度参数的伽马分布。其概率密度函数（PDF）为\n$$\nf(x;k) = \\frac{x^{k-1}e^{-x}}{\\Gamma(k)}, \\quad x > 0.\n$$\n该期望由以下积分定义\n$$\n\\mathbb{E}[\\ln X] = \\int_0^{\\infty} \\ln(x) f(x;k) \\,dx = \\frac{1}{\\Gamma(k)} \\int_0^{\\infty} \\ln(x) x^{k-1} e^{-x} \\,dx.\n$$\n必须对指定的 $k$ 值（$k=\\frac{1}{2}$、$k=1$、$k=\\frac{3}{2}$ 和 $k=10$）计算此积分。\n\n首先，我们分析该积分。这是一个反常积分，原因有两个：积分的上限为无穷大，以及在下限 $x=0$ 处存在潜在的奇异点。被积函数分子的行为，我们记为 $g(x;k) = \\ln(x) x^{k-1} e^{-x}$，在 $x=0$ 附近主要由项 $\\ln(x) x^{k-1}$ 决定。已知对于某个小的 $\\epsilon > 0$，积分 $\\int_0^{\\epsilon} \\ln(x) x^{k-1} dx$ 收敛当且仅当 $x$ 的幂大于 $-1$，即 $k-1 > -1$，化简为 $k>0$。由于问题陈述保证了 $k>0$，因此在 $x=0$ 处的奇异点是可积的。在积分上限，当 $x \\to \\infty$ 时，指数项 $e^{-x}$ 衰减到零的速度比任何多项式或对数项 $\\ln(x) x^{k-1}$ 的增长速度都快。这确保了积分在区间 $[0, \\infty)$ 上的收敛性。\n\n因此，该问题是一个适定的数值积分任务。需要一个鲁棒的数值求积算法来以所需的精度处理这些特性。`scipy.integrate.quad` 函数是 FORTRAN 库 QUADPACK 的 Python 接口，非常适合此目的。它专门用于计算定积分，包括那些具有无穷限和在积分区间边界有可积奇异点的积分。\n\n计算策略如下：\n1. 对于每个给定的 $k$ 值，我们定义对应于期望公式分子的被积函数，$I_{\\text{num}}(x, k) = \\ln(x) x^{k-1} e^{-x}$。先积分这个函数，然后再除以 $\\Gamma(k)$，在数值上更为稳定。\n2. 我们使用 `scipy.integrate.quad` 计算积分值 $J(k) = \\int_0^{\\infty} I_{\\text{num}}(x, k) \\,dx$。为确保最终绝对误差不超过所需的 $10^{-10}$ 容差，为 `quad` 函数指定了更严格的容差，例如 `epsabs`=$10^{-13}$。\n3. 我们使用 `scipy.special.gamma` 提供的高精度实现来计算伽马函数 $\\Gamma(k)$ 的值。\n4. 最终的期望值通过除法 $\\mathbb{E}[\\ln X] = \\frac{J(k)}{\\Gamma(k)}$ 获得。\n\n一个已确立的数学恒等式表明，此期望等于双伽马函数 $\\psi(k)$，其定义为伽马函数的对数导数：\n$$\n\\psi(k) = \\frac{d}{dk} \\ln\\Gamma(k) = \\frac{\\Gamma'(k)}{\\Gamma(k)}.\n$$\n此恒等式通过对 $\\Gamma(k)$ 的积分定义关于 $k$ 求导得出，这一操作由控制收敛定理保证其合理性：\n$$\n\\Gamma'(k) = \\frac{d}{dk} \\int_0^{\\infty} x^{k-1} e^{-x} \\,dx = \\int_0^{\\infty} \\frac{\\partial}{\\partial k} (x^{k-1} e^{-x}) \\,dx = \\int_0^{\\infty} (\\ln x) x^{k-1} e^{-x} \\,dx.\n$$\n将此结果除以 $\\Gamma(k)$ 证实了 $\\mathbb{E}[\\ln X] = \\psi(k)$。这个在 `scipy.special.psi` 中可用的解析解，可作为检验我们数值积分正确性的明确基准。例如，对于 $k=1$，期望为 $\\psi(1) = -\\gamma$，其中 $\\gamma \\approx 0.5772156649$ 是欧拉-马歇罗尼常数。对于 $k=\\frac{1}{2}$，期望为 $\\psi(\\frac{1}{2}) = -\\gamma - 2\\ln 2 \\approx -1.9635100260$。所开发的程序必须通过直接积分高精度地再现这些值，而不是仅仅调用预定义的 `psi` 函数。\n\n程序将遍历测试用例列表 $k \\in \\{\\frac{1}{2}, 1, \\frac{3}{2}, 10\\}$。对于每个 $k$，它将执行如上所述的数值积分。在格式化输出之前，每个用例的最终计算值将按照问题陈述的要求四舍五入到 $12$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\nfrom scipy import special\n\ndef solve():\n    \"\"\"\n    Computes the expectation E[ln X] for a Gamma-distributed random variable X\n    with shape parameter k and unit scale.\n    \"\"\"\n    # Define the test cases for the shape parameter k.\n    test_cases = [0.5, 1.0, 1.5, 10.0]\n\n    results = []\n    \n    # The expectation is given by the integral of ln(x) * f(x;k) over (0, inf),\n    # where f(x;k) is the Gamma PDF. This is equivalent to:\n    # (1 / Gamma(k)) * integral[ln(x) * x**(k-1) * exp(-x) dx].\n    # We will numerically integrate the numerator and then divide by Gamma(k).\n\n    for k in test_cases:\n        # Define the numerator of the integrand as a function of x and k.\n        # This function is passed to the quadrature routine.\n        def numerator_integrand(x, k_val):\n            # This expression is singular at x=0 for k=1, but the singularity\n            # is integrable, and `scipy.integrate.quad` is designed to handle this.\n            return np.log(x) * x**(k_val - 1) * np.exp(-x)\n            \n        # Compute the integral of the numerator from 0 to infinity.\n        # A high precision is requested for the integration routine to ensure\n        # the final absolute error is below the required 1e-10.\n        integral_numerator, _ = integrate.quad(\n            numerator_integrand,\n            0,\n            np.inf,\n            args=(k,),\n            epsabs=1e-13,\n            epsrel=1e-13\n        )\n        \n        # Compute the value of the Gamma function for the denominator.\n        gamma_val = special.gamma(k)\n        \n        # Calculate the final expectation value.\n        expectation = integral_numerator / gamma_val\n        \n        # Round the result to 12 decimal places as per the problem specification.\n        rounded_result = round(expectation, 12)\n        results.append(rounded_result)\n        \n    # The final output must be a single line containing a comma-separated\n    # list of results enclosed in square brackets.\n    # The str() conversion of the rounded floats provides the required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419387"}, {"introduction": "本练习将引导你进入一个更高级的领域，它建立在我们在第一个练习 [@problem_id:2419418] 中引入的坐标变换思想之上。虽然像极坐标这样的标准变换非常有用，但某些问题，特别是那些在多维积分域的顶点或角落处出现奇点的问题，需要更专门的技巧来解决。本练习 [@problem_id:2419422] 介绍了一种强大的方法——Duffy变换，用于处理二维积分中的顶点奇点。它通过巧妙的坐标重构使被积函数变得“正则化”，从而将一个棘手的数值问题转化为一个可以直接进行高效计算的常规问题，深刻体现了在计算物理中“先解析处理，后数值计算”的核心思想。", "problem": "要求您实现一种数值方法，用于计算一类在单位正方形上具有顶点奇异性的二维反常积分。数学目标是计算以下形式的积分：\n$$\nI[g] = \\int_{0}^{1}\\int_{0}^{1} \\frac{g(x,y)}{\\sqrt{x^2 + y^2}} \\, \\mathrm{d}y \\, \\mathrm{d}x,\n$$\n其中 $g(x,y)$ 在 $[0,1]^2$ 上是光滑的。由于在顶点 $(x,y) = (0,0)$ 处存在可积奇异点，该被积函数是反常的。从反常积分作为正常积分的极限的定义以及带有雅可比行列式的变量代换定理出发，推导出一个奇异性消除坐标变换，该变换能在一对划分单位正方形的子域上使被积函数正则化。您的推导必须从第一性原理开始：即反常积分作为极限的定义以及包括雅可比行列式绝对值在内的多重积分的变量代换公式。您不能假设任何预先指定的变换；相反，您的方法必须通过沿奇异对角线方向对齐一个坐标以消除 $1/\\sqrt{x^2 + y^2}$ 奇异性来证明其合理性。\n\n一旦推导出了有效的变换及其雅可比行列式，请实现一个基于 $[0,1]^2$ 上的张量积高斯-勒让德法则的确定性数值求积方法来计算正则化后的积分。您的实现必须：\n- 将单位正方形划分为两个不重叠的直角三角形，它们覆盖 $[0,1]^2$，除了在测度为零的边界上外没有间隙或重叠。\n- 对每个三角形应用一个与奇异性对齐的变量代换，将原始被积函数转化为新坐标单位正方形上的一个有界、连续且可积的函数。\n- 在新变量的 $[0,1]^2$ 上使用张量积高斯-勒让德求积，每个维度使用固定的偶数个节点 $n$（选择任意 $n \\ge 64$），以在不使用自适应性的情况下产生高精度结果。\n- 确保您的实现是自包含的，并且只使用确定性操作。\n\n测试套件：\n对于以下四个光滑的分子函数 $g_k(x,y)$，计算 $I[g_k]$：\n- $g_1(x,y) = 1$。\n- $g_2(x,y) = 1 + x + y$。\n- $g_3(x,y) = e^{x+y}$。\n- $g_4(x,y) = x^2 + y^2$。\n\n所有量都是无量纲的，因此不需要物理单位。不使用角度。您的程序必须计算并打印出四个值 $I[g_1], I[g_2], I[g_3], I[g_4]$ 作为浮点数。\n\n最终输出格式：\n您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到 $12$ 位小数，顺序为 $[I[g_1], I[g_2], I[g_3], I[g_4]]$。例如：\"[1.234567890123,2.345678901234,3.456789012345,4.567890123456]\"。", "solution": "我们的任务是数值计算一类二维反常积分，其形式为\n$$\nI[g] = \\int_{0}^{1}\\int_{0}^{1} \\frac{g(x,y)}{\\sqrt{x^2 + y^2}} \\, \\mathrm{d}y \\, \\mathrm{d}x\n$$\n其中函数 $g(x,y)$ 在积分域单位正方形 $D = [0,1] \\times [0,1]$ 上是光滑的。被积函数在原点 $(x,y) = (0,0)$ 处有一个可积奇异点。直接应用标准求积法则（如高斯求积）是不可取的，因为在靠近原点的节点上计算被积函数会导致巨大的数值误差和较差的收敛性。该问题要求基于第一性原理推导出一个消除奇异性的坐标变换。\n\n在一个域 $D$ 上，对于在点 $P_0$ 处有奇异点的二维反常积分，其定义由以下极限给出：\n$$\n\\iint_D f(x,y) \\, \\mathrm{d}A = \\lim_{\\epsilon \\to 0^+} \\iint_{D \\setminus D_\\epsilon} f(x,y) \\, \\mathrm{d}A\n$$\n其中 $D_\\epsilon$ 是围绕 $P_0$ 的一个小区域，例如半径为 $\\epsilon$ 的圆盘。我们的目标是找到一个变量代换 $(x,y) \\mapsto (u,v)$，将 $D$ 上的积分转换为一个新域（比如 $D'$）上的积分，使得变换后的被积函数是正则的，即有界且光滑。变量代换定理指出：\n$$\n\\iint_D f(x,y) \\, \\mathrm{d}x \\, \\mathrm{d}y = \\iint_{D'} f(x(u,v), y(u,v)) \\left| \\det\\left( \\frac{\\partial(x,y)}{\\partial(u,v)} \\right) \\right| \\, \\mathrm{d}u \\, \\mathrm{d}v\n$$\n其中 $\\left| \\det\\left( \\frac{\\partial(x,y)}{\\partial(u,v)} \\right) \\right|$ 是变换的雅可比行列式的绝对值。我们的策略是构建一个变换，使其雅可比行列式恰好抵消被积函数的奇异部分。\n\n积分域是单位正方形 $D = [0,1] \\times [0,1]$。我们将这个正方形沿对角线 $y=x$ 划分为两个不重叠的直角三角形 $T_1$ 和 $T_2$。\n$$\nT_1 = \\{ (x,y) \\in D \\mid y \\le x \\} = \\{ (x,y) \\mid 0 \\le x \\le 1, 0 \\le y \\le x \\}\n$$\n$$\nT_2 = \\{ (x,y) \\in D \\mid x \\le y \\} = \\{ (x,y) \\mid 0 \\le y \\le 1, 0 \\le x \\le y \\}\n$$\n总积分是这两个子域上积分的和：\n$$\nI[g] = \\iint_{T_1} \\frac{g(x,y)}{\\sqrt{x^2+y^2}} \\, \\mathrm{d}A + \\iint_{T_2} \\frac{g(x,y)}{\\sqrt{x^2+y^2}} \\, \\mathrm{d}A = I_1[g] + I_2[g]\n$$\n我们现在为每个三角形域推导一个合适的坐标变换，将其从新坐标系中的一个单位正方形映射过来。\n\n对于第一个三角形 $T_1$，我们提出以下变换：\n$$\nx = u, \\quad y = uv\n$$\n我们必须验证这个变换将 $(u,v)$ 平面上的单位正方形（我们记为 $D' = [0,1] \\times [0,1]$）映射到三角形 $T_1$。对于 $(u,v) \\in D'$，我们有 $u \\in [0,1]$ 和 $v \\in [0,1]$。这意味着 $x = u \\in [0,1]$ 和 $y = uv \\in [0,u]$。条件 $y \\le u$ 等价于 $y \\le x$。因此，点 $(x,y)$ 位于由 $0 \\le x \\le 1$ 和 $0 \\le y \\le x$ 定义的区域内，这正是三角形 $T_1$。该变换是 $D'$ 内部到 $T_1$ 内部的一个双射。奇异点 $(x,y)=(0,0)$ 对应于新域的整个边 $u=0$。\n\n接下来，我们计算这个变换的雅可比行列式。雅可比矩阵是：\n$$\nJ_1 = \\frac{\\partial(x,y)}{\\partial(u,v)} = \\begin{pmatrix} \\frac{\\partial x}{\\partial u}  \\frac{\\partial x}{\\partial v} \\\\ \\frac{\\partial y}{\\partial u}  \\frac{\\partial y}{\\partial v} \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ v  u \\end{pmatrix}\n$$\n行列式为 $\\det(J_1) = (1)(u) - (0)(v) = u$。由于 $u \\in [0,1]$，其绝对值就是 $|\\det(J_1)| = u$。\n\n现在我们变换积分 $I_1[g]$。分母变为：\n$$\n\\sqrt{x^2 + y^2} = \\sqrt{u^2 + (uv)^2} = \\sqrt{u^2(1+v^2)} = u\\sqrt{1+v^2}\n$$\n面积元变换为 $\\mathrm{d}x \\, \\mathrm{d}y = |\\det(J_1)| \\, \\mathrm{d}u \\, \\mathrm{d}v = u \\, \\mathrm{d}u \\, \\mathrm{d}v$。将这些代入积分 $I_1[g]$，我们得到：\n$$\nI_1[g] = \\iint_{D'} \\frac{g(u, uv)}{u\\sqrt{1+v^2}} \\cdot u \\, \\mathrm{d}u \\, \\mathrm{d}v = \\int_{0}^{1}\\int_{0}^{1} \\frac{g(u, uv)}{\\sqrt{1+v^2}} \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\n奇异因子 $1/u$ 已被雅可比行列式抵消。由于 $g$ 是光滑的，且对于 $v \\in [0,1]$，$\\sqrt{1+v^2} \\ge 1$，因此新的被积函数在单位正方形 $D'$ 上是正则的。\n\n对于第二个三角形 $T_2$，我们通过交换 $x$ 和 $y$ 的角色来使用一个对称的变换：\n$$\nx = uv, \\quad y = u\n$$\n对于 $(u,v) \\in D'$，我们有 $y=u \\in [0,1]$ 和 $x=uv \\in [0,u]$，这等价于 $x \\le y$。这将单位正方形 $D'$ 映射到三角形 $T_2$。这个二次变换的雅可比矩阵是：\n$$\nJ_2 = \\frac{\\partial(x,y)}{\\partial(u,v)} = \\begin{pmatrix} v  u \\\\ 1  0 \\end{pmatrix}\n$$\n行列式为 $\\det(J_2) = (v)(0) - (u)(1) = -u$。其绝对值为 $|\\det(J_2)| = u$。分母项与前一种情况相同：$\\sqrt{x^2+y^2} = u\\sqrt{1+v^2}$。\n代入积分 $I_2[g]$：\n$$\nI_2[g] = \\iint_{D'} \\frac{g(uv, u)}{u\\sqrt{1+v^2}} \\cdot u \\, \\mathrm{d}u \\, \\mathrm{d}v = \\int_{0}^{1}\\int_{0}^{1} \\frac{g(uv, u)}{\\sqrt{1+v^2}} \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\n这个积分也是正则的。总积分 $I[g]$ 是这两个正则化积分的和：\n$$\nI[g] = I_1[g] + I_2[g] = \\int_{0}^{1}\\int_{0}^{1} \\left( \\frac{g(u, uv)}{\\sqrt{1+v^2}} + \\frac{g(uv, u)}{\\sqrt{1+v^2}} \\right) \\, \\mathrm{d}v \\, \\mathrm{d}u\n$$\n这个表达式可以更紧凑地写成：\n$$\nI[g] = \\int_{0}^{1} \\int_{0}^{1} F(u,v; g) \\, \\mathrm{d}u \\, \\mathrm{d}v \\quad \\text{其中} \\quad F(u,v; g) = \\frac{g(u, uv) + g(uv, u)}{\\sqrt{1+v^2}}\n$$\n问题因此简化为在单位正方形 $[0,1]^2$ 上数值计算一个正则的二维积分。我们将采用张量积高斯-勒让德求积法则。对于 $[0,1]^2$ 上的积分，公式为：\n$$\n\\int_{0}^{1}\\int_{0}^{1} F(u,v) \\, \\mathrm{d}u \\, \\mathrm{d}v \\approx \\sum_{i=1}^{n} \\sum_{j=1}^{n} w'_i w'_j F(u'_i, v'_j)\n$$\n其中 $\\{u'_i, w'_i\\}_{i=1}^n$ 和 $\\{v'_j, w'_j\\}_{j=1}^n$ 分别是高斯-勒让德节点和权重，它们从标准区间 $[-1,1]$ 缩放到 $[0,1]$。如果 $\\{t_k, w_k\\}_{k=1}^n$ 是在 $[-1,1]$ 上的标准节点和权重，那么缩放后的对应项由仿射变换 $z = (t+1)/2$ 给出：\n$$\nu'_k = v'_k = \\frac{t_k+1}{2}, \\quad w'_k = \\frac{w_k}{2}\n$$\n我们将按照规定使用一个固定的节点数 $n \\ge 64$。我们选择 $n=100$ 以获得高精度。实现将为每个给定的函数 $g_k(x,y)$ 计算这个双重求和。", "answer": "```python\n# The final answer must be a single, complete, standalone program.\n# Execution Environment: Python 3.12, numpy 1.23.5, scipy 1.11.4\n\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a numerical method to evaluate 2D improper integrals\n    with a vertex singularity on the unit square.\n\n    The method is based on a singularity-resolving coordinate transformation\n    and tensor-product Gauss-Legendre quadrature.\n    \"\"\"\n\n    # 1. Define the test functions g_k(x, y)\n    g1 = lambda x, y: 1.0\n    g2 = lambda x, y: 1.0 + x + y\n    g3 = lambda x, y: np.exp(x + y)\n    g4 = lambda x, y: x**2 + y**2\n    \n    test_cases = [g1, g2, g3, g4]\n\n    # 2. Set up the Gauss-Legendre quadrature\n    # Use n=100 nodes, which satisfies the condition n = 64 (even).\n    # Using an even number as stipulated is respected, though not strictly\n    # necessary for the method's correctness.\n    n_nodes = 100\n    \n    # Get standard Gauss-Legendre nodes and weights for the interval [-1, 1]\n    # using numpy.polynomial.legendre.leggauss.\n    nodes_std, weights_std = np.polynomial.legendre.leggauss(n_nodes)\n\n    # Scale nodes and weights from [-1, 1] to the integration interval [0, 1].\n    # Transformation: t_new = 0.5 * (t_std + 1.0)\n    # Weight scaling: w_new = 0.5 * w_std\n    nodes_01 = 0.5 * (nodes_std + 1.0)\n    weights_01 = 0.5 * weights_std\n\n    # 3. Define the transformed integrand derived in the solution.\n    # The original integral is split into two parts, and each is transformed\n    # to the unit square in (u, v) coordinates. The final integrand is the\n    # sum of the two transformed parts.\n    # F(u, v; g) = (g(u, u*v) + g(u*v, u)) / sqrt(1 + v^2)\n    def transformed_integrand(u, v, g):\n        return (g(u, u * v) + g(u * v, u)) / np.sqrt(1.0 + v**2)\n\n    # 4. Perform numerical integration for each test case\n    results = []\n    \n    # Pre-calculate sqrt(1 + v^2) for efficiency\n    sqrt_1_plus_v2 = np.sqrt(1.0 + nodes_01**2)\n\n    for g_func in test_cases:\n        integral_value = 0.0\n        \n        # Create a meshgrid of nodes for vectorized evaluation\n        u_mesh, v_mesh = np.meshgrid(nodes_01, nodes_01, indexing='ij')\n        \n        # Vectorize the transformed integrand evaluation\n        integrand_values = (g_func(u_mesh, u_mesh * v_mesh) + g_func(u_mesh * v_mesh, u_mesh)) / np.sqrt(1.0 + v_mesh**2)\n        \n        # Create a meshgrid of weights for the tensor product\n        w_u_mesh, w_v_mesh = np.meshgrid(weights_01, weights_01, indexing='ij')\n        \n        # Compute the integral using the double summation\n        # This is equivalent to weights_u.T @ integrand_values @ weights_v\n        integral_value = np.sum(w_u_mesh * w_v_mesh * integrand_values)\n\n        results.append(integral_value)\n\n    # 5. Format and print the final output as specified.\n    # The output must be a single line with comma-separated values\n    # rounded to 12 decimal places, enclosed in square brackets.\n    formatted_results = [f\"{res:.12f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver\nsolve()\n\n```", "id": "2419422"}]}