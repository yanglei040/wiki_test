{"hands_on_practices": [{"introduction": "第一个实践是基础。在使用任何数值方法之前，我们必须能够信任它们。本练习让你能够通过实验来验证从泰勒级数推导出的有限差分公式的理论精度。通过实现中心差分格式，并观察当步长 $h$ 减小时误差是如何减小的，你将对“二阶精度” ($O(h^2)$) 的真正含义有一个具体的理解，并对这些基本的计算工具建立起信心。[@problem_id:2391581]", "problem": "设计并实现一个完全可复现的数值实验，以经验性地验证导数的对称有限差分近似的精度阶。仅使用以下基础理论：一个充分光滑函数在某点周围的泰勒级数展开，以及一阶和二阶导数的极限定义。您的任务是：\n\n1. 对光滑函数 $f(x)$ 在点 $x_0$ 处，使用步长 $h$ 构建其一阶导数和二阶导数的对称中心有限差分近似。这些近似必须使用在 $x_0 \\pm h$（对于二阶导数，可选择性地使用 $x_0$）处求得的 $f$ 的值。不要假设或引用任何已有的误差公式；相反，应基于在 $x_0$ 点的泰勒级数展开进行推理，以证明预期的截断误差行为。\n\n2. 对于一个具有已知导数的给定函数 $f(x)$，定义其在 $x_0$ 点的真实一阶导数 $f'(x)$ 和真实二阶导数 $f''(x)$。对于一系列步长 $h_k = h_0/2^k$，$k = 0,1,\\dots,n-1$，计算绝对误差 $e_k = \\lvert A(h_k) - T \\rvert$，其中 $A(h_k)$ 是使用步长 $h_k$ 在 $x_0$ 点对目标导数的数值近似，而 $T$ 是相应的真实导数值。对于每对连续的误差，计算观测到的精度阶\n$$\np_k = \\log_2\\left( \\frac{e_k}{e_{k+1}} \\right).\n$$\n将细化序列中最后一个可用的 $p_k$（即对应于两个最小步长的那个）作为测试案例的标量结果报告，该值经验性地逼近了渐近阶。\n\n3. 将上述过程实现为一个完整的程序，运行以下测试套件。每个测试案例指定了目标导数阶数、函数 $f(x)$、求值点 $x_0$、初始步长 $h_0$ 和细化次数 $n$。函数及其真实导数必须严格按照下文规定处理。\n\n- 测试案例 1（常规路径，一阶导数）：目标导数为 $f'(x)$，函数为 $f(x) = \\sin(x)$，$x_0 = 0.37$（以弧度为单位），$h_0 = 0.2$，$n = 5$。\n- 测试案例 2（不同平滑度特性，一阶导数）：目标导数为 $f'(x)$，函数为 $f(x) = \\exp(\\sin(x))$，$x_0 = -0.8$（以弧度为单位），$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f'(x) = \\exp(\\sin(x)) \\cos(x)$。\n- 测试案例 3（常规路径，二阶导数）：目标导数为 $f''(x)$，函数为 $f(x) = \\sin(x)$，$x_0 = 0.37$（以弧度为单位），$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f''(x) = -\\sin(x)$。\n- 测试案例 4（非平凡有理函数，二阶导数）：目标导数为 $f''(x)$，函数为 $f(x) = \\frac{1}{1+x^2}$，$x_0 = 0.9$，$h_0 = 0.2$，$n = 5$。使用精确恒等式 $f''(x) = \\frac{6x^2 - 2}{(1+x^2)^3}$。\n- 测试案例 5（函数值数量级大的边缘情况，一阶导数）：目标导数为 $f'(x)$，函数为 $f(x) = \\exp(x)$，$x_0 = 5.0$，$h_0 = 0.4$，$n = 5$。使用精确恒等式 $f'(x) = \\exp(x)$。\n\n4. 您的实现必须：\n- 对于目标 $f'(x)$，使用仅基于 $x_0 \\pm h$ 的对称中心模板。\n- 对于目标 $f''(x)$，使用仅基于 $x_0 \\pm h$ 和 $x_0$ 的对称中心模板。\n- 使用细化策略 $h_k = h_0/2^k$，$k = 0,1,\\dots,n-1$。\n- 计算绝对误差和观测到的精度阶序列 $p_k$。\n- 每个测试案例返回序列中最后一个 $p_k$ 作为最终标量结果。\n- 如果在最小尺度上误差差值为零，则使用最近的非零相邻对来计算 $p_k$。\n\n5. 最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔的浮点数列表（例如，“[r1,r2,r3,r4,r5]”）。每个数字必须是相应测试案例的最终观测阶数，四舍五入到六位小数。\n\n角度必须以弧度为单位进行解释。本问题不涉及物理单位。预期结果是，一阶导数和二阶导数对称格式的观测阶数都接近于 $2$，这与截断误差与 $h^2$ 成正比的结论一致。", "solution": "问题陈述是一个有效且适定的数值分析练习。它在科学上基于泰勒级数和有限差分法的理论，不包含任何矛盾，并提供了构建唯一、可验证解所需的所有必要信息。因此，我们将着手进行推导和实现。\n\n目标是为一个足够光滑的函数 $f(x)$ 推导其一阶和二阶导数的对称有限差分公式，分析它们的截断误差，并通过数值实验来经验性地验证其理论精度阶。\n\n首先，我们推导一阶导数 $f'(x)$ 的有限差分近似。假设 $f(x)$ 至少是三阶连续可微的。$f(x)$ 在点 $x_0$ 附近，对于步长 $+h$ 和 $-h$ 的泰勒级数展开式由以下公式给出：\n$$\nf(x_0 + h) = f(x_0) + h f'(x_0) + \\frac{h^2}{2!} f''(x_0) + \\frac{h^3}{3!} f'''(x_0) + O(h^4) \\quad (1)\n$$\n$$\nf(x_0 - h) = f(x_0) - h f'(x_0) + \\frac{h^2}{2!} f''(x_0) - \\frac{h^3}{3!} f'''(x_0) + O(h^4) \\quad (2)\n$$\n从方程 $(1)$ 中减去方程 $(2)$，可以消去 $h$ 的偶数次幂项：\n$$\nf(x_0 + h) - f(x_0 - h) = 2h f'(x_0) + \\frac{2h^3}{6} f'''(x_0) + O(h^5)\n$$\n求解 $f'(x_0)$ 可得：\n$$\nf'(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} - \\frac{h^2}{6} f'''(x_0) + O(h^4)\n$$\n这就给出了一阶导数的对称中心有限差分近似：\n$$\nA_{f'}(h) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h}\n$$\n因此，截断误差（定义为近似值与真实值之差，$E_{trunc} = A_{f'}(h) - f'(x_0)$）为：\n$$\nE_{trunc} = -\\frac{h^2}{6} f'''(x_0) + O(h^4)\n$$\n误差的主导项与 $h^2$ 成正比，这意味着该近似是二阶精度的。\n\n接下来，我们推导二阶导数 $f''(x)$ 的近似。假设 $f(x)$ 至少是四阶连续可微的。将方程 $(1)$ 和 $(2)$ 相加，可以消去 $h$ 的奇数次幂项：\n$$\nf(x_0 + h) + f(x_0 - h) = 2f(x_0) + h^2 f''(x_0) + \\frac{2h^4}{24} f''''(x_0) + O(h^6)\n$$\n求解 $f''(x_0)$ 可得：\n$$\nf''(x_0) = \\frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2} - \\frac{h^2}{12} f''''(x_0) + O(h^4)\n$$\n这就给出了二阶导数的对称中心有限差分近似：\n$$\nA_{f''}(h) = \\frac{f(x_0 + h) - 2f(x_0) + f(x_0 - h)}{h^2}\n$$\n此近似的截断误差为：\n$$\nE_{trunc} = -\\frac{h^2}{12} f''''(x_0) + O(h^4)\n$$\n误差的主导项同样与 $h^2$ 成正比，所以该近似也是二阶精度的。\n\n为了经验性地验证精度阶，我们分析了当步长 $h$ 被细化时绝对误差的行为。对于一个 $p$ 阶近似，绝对误差 $e(h) = |A(h) - T|$（其中 $T$ 是真实导数值）在 $h$ 足够小时，其行为类似于 $e(h) \\approx C h^p$，其中 $C$ 为某个常数。\n考虑一个步长序列 $h_k = h_0 / 2^k$，$k=0, 1, 2, \\dots$。对应的误差为 $e_k = e(h_k)$ 和 $e_{k+1} = e(h_{k+1})$。连续误差的比值为：\n$$\n\\frac{e_k}{e_{k+1}} \\approx \\frac{C h_k^p}{C h_{k+1}^p} = \\frac{C (h_0/2^k)^p}{C (h_0/2^{k+1})^p} = \\frac{(1/2^k)^p}{(1/2^{k+1})^p} = \\left(\\frac{2^{k+1}}{2^k}\\right)^p = 2^p\n$$\n通过取以 2 为底的对数，我们可以计算出观测到的精度阶 $p_k$：\n$$\np_k = \\log_2\\left(\\frac{e_k}{e_{k+1}}\\right)\n$$\n随着 $k$ 的增加，$h_k$ 减小，$p_k$ 应收敛于理论阶数 $p$。对于我们推导出的二阶格式，我们期望 $p_k \\to 2$。\n\n数值实验按如下方式实现。对于每个测试案例：\n1.  生成一个包含 $n$ 个步长的序列：$h_k = h_0 / 2^k$，$k=0, \\dots, n-1$。\n2.  在点 $x_0$ 处计算导数的真实值 $T$。\n3.  对于每个步长 $h_k$，使用一阶或二阶导数公式计算相应的数值近似值 $A(h_k)$。\n4.  计算一个绝对误差序列：$e_k = |A(h_k) - T|$。\n5.  计算一个观测阶数序列：$p_k = \\log_2(e_k / e_{k+1})$，$k=0, \\dots, n-2$。\n6.  结果是最后一个有效计算出的阶数 $p_{n-2}$，它对应于两个最小步长 $h_{n-2}$ 和 $h_{n-1}$ 之间的比较。这提供了一个对渐近精度阶的经验估计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Designs and implements a numerical experiment to verify the order of accuracy\n    of symmetric finite difference approximations for first and second derivatives.\n    \"\"\"\n\n    # Define the functions, their true derivatives, and parameters for each test case.\n    test_cases = [\n        {\n            # Test case 1: f'(x) for sin(x)\n            \"target_order\": 1,\n            \"f\": lambda x: np.sin(x),\n            \"true_deriv_func\": lambda x: np.cos(x),\n            \"x0\": 0.37,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 2: f'(x) for exp(sin(x))\n            \"target_order\": 1,\n            \"f\": lambda x: np.exp(np.sin(x)),\n            \"true_deriv_func\": lambda x: np.exp(np.sin(x)) * np.cos(x),\n            \"x0\": -0.8,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 3: f''(x) for sin(x)\n            \"target_order\": 2,\n            \"f\": lambda x: np.sin(x),\n            \"true_deriv_func\": lambda x: -np.sin(x),\n            \"x0\": 0.37,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 4: f''(x) for 1/(1+x^2)\n            \"target_order\": 2,\n            \"f\": lambda x: 1.0 / (1.0 + x**2),\n            \"true_deriv_func\": lambda x: (6.0 * x**2 - 2.0) / (1.0 + x**2)**3,\n            \"x0\": 0.9,\n            \"h0\": 0.2,\n            \"n\": 5,\n        },\n        {\n            # Test case 5: f'(x) for exp(x) with large function magnitude\n            \"target_order\": 1,\n            \"f\": lambda x: np.exp(x),\n            \"true_deriv_func\": lambda x: np.exp(x),\n            \"x0\": 5.0,\n            \"h0\": 0.4,\n            \"n\": 5,\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        target_order = case[\"target_order\"]\n        f = case[\"f\"]\n        true_deriv_func = case[\"true_deriv_func\"]\n        x0 = case[\"x0\"]\n        h0 = case[\"h0\"]\n        n = case[\"n\"]\n\n        # Calculate the true value of the derivative\n        true_value = true_deriv_func(x0)\n\n        # Generate step sizes and compute errors\n        errors = []\n        for k in range(n):\n            h = h0 / (2**k)\n            \n            if target_order == 1:\n                # Symmetric centered difference for the first derivative\n                approx_val = (f(x0 + h) - f(x0 - h)) / (2.0 * h)\n            elif target_order == 2:\n                # Symmetric centered difference for the second derivative\n                approx_val = (f(x0 + h) - 2.0 * f(x0) + f(x0 - h)) / (h**2)\n            else:\n                # This case should not be reached based on the problem statement\n                raise ValueError(\"Invalid target derivative order.\")\n\n            # Compute and store the absolute error\n            errors.append(np.abs(approx_val - true_value))\n\n        # Compute observed orders of accuracy\n        observed_orders = []\n        for k in range(n - 1):\n            e_k = errors[k]\n            e_k_plus_1 = errors[k + 1]\n            \n            # Ensure errors are non-zero to avoid division by zero\n            # or log of zero. This also handles the specified edge case.\n            if e_k > 0 and e_k_plus_1 > 0:\n                p_k = np.log2(e_k / e_k_plus_1)\n                observed_orders.append(p_k)\n\n        # The result for the test case is the last available observed order\n        if observed_orders:\n            final_p = observed_orders[-1]\n        else:\n            # Handle case where no valid order could be computed (e.g., all errors are zero)\n            # For this problem set, this fallback is not expected to be needed.\n            final_p = np.nan\n            \n        results.append(final_p)\n\n    # Format the final output as a comma-separated list of numbers rounded to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2391581"}, {"introduction": "在现实世界中，数值微分很少应用于完美的平滑函数；更多时候，我们处理的是来自实验的含噪声数据。本实践探讨了一个关键挑战：噪声放大效应。你会发现，将有限差分公式应用于含噪声数据会显著增加计算出的导数中的噪声水平。通过这个练习，你将从理论和实验两方面量化这一效应，理解为何数值微分被视为一个“不适定”问题，以及步长 $\\Delta t$ 的选择如何在截断误差和噪声放大之间进行关键的权衡。[@problem_id:2392343]", "problem": "给定一个一维位置作为时间函数的含加性测量噪声的时间序列模型。该位置是一个光滑的、已知的时间函数，并在每个样本点上叠加了零均值、独立的噪声。你的任务是设计并实现一个程序，该程序针对一组测试用例，构建带噪声的位置数据，使用有限差分法估计速度和加速度，并定量分析微分算子对测量噪声的放大效应。\n\n你的推理必须仅基于以下基本定义和事实：函数的导数是差商的极限；作用于独立随机变量的线性算子，其输出的方差根据算子权重的平方进行加和；泰勒级数展开可用于推导有限差分格式的局部截断误差阶。除这些原则外，不得使用任何其他现成公式。\n\n使用以下信号模型。无噪声位置为\n$$\nx(t) = A \\sin(2\\pi f_1 t) + C \\sin(2\\pi f_2 t) + D t^2,\n$$\n参数为\n$$\nA = 1.0\\ \\text{m},\\quad C = 0.5\\ \\text{m},\\quad f_1 = 1.0\\ \\text{Hz},\\quad f_2 = 3.0\\ \\text{Hz},\\quad D = 0.05\\ \\text{m/s}^2.\n$$\n三角函数中的角度以弧度为单位。精确的速度和加速度分别为\n$$\nv(t) = \\frac{dx}{dt} = 2\\pi f_1 A \\cos(2\\pi f_1 t) + 2\\pi f_2 C \\cos(2\\pi f_2 t) + 2 D t,\n$$\n$$\na(t) = \\frac{d^2 x}{dt^2} = - (2\\pi f_1)^2 A \\sin(2\\pi f_1 t) - (2\\pi f_2)^2 C \\sin(2\\pi f_2 t) + 2 D.\n$$\n\n采样和噪声模型。对于每个测试用例，在以下时间点上均匀采样\n$$\nt_n = n \\,\\Delta t,\\quad n=0,1,\\dots,N-1,\\quad N = \\left\\lfloor \\frac{T}{\\Delta t}\\right\\rfloor + 1,\\quad T = 10\\ \\text{s},\n$$\n并形成带噪声的测量值\n$$\nx_n^{\\text{noisy}} = x(t_n) + \\eta_n,\\quad \\eta_n \\sim \\mathcal{N}(0,\\sigma_x^2)\\ \\text{i.i.d.},\n$$\n为保证可复现性，使用固定的随机种子 $12345$。所有距离单位为米，时间单位为秒。\n\n有限差分要求。从第一性原理出发，推导并实现如下用于一阶和二阶导数的二阶精度有限差分格式：\n- 对于内部点，使用中心、二阶精度格式。\n- 在两个边界处，使用单边、二阶精度格式。\n你的实现必须生成与输入 $x_n$ 长度相同的数组 $v_n^{\\text{FD}}$ 和 $a_n^{\\text{FD}}$。\n\n噪声放大分析。设索引 $i$ 处的有限差分导数为线性组合\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $y_i$ 代表一阶或二阶导数的估计值，$w_{i,j}$ 是有限差分权重除以 $\\Delta t$ 的适当次幂。仅使用期望的线性性质和噪声样本的独立性，推导并计算：\n- 一阶导数的经验均方根 (RMS) 噪声放大，\n$$\ng_v^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 },\n$$\n和二阶导数的经验均方根 (RMS) 噪声放大，\n$$\ng_a^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a_i^{\\text{FD}}[x^{\\text{clean}}]\\right)^2 }.\n$$\n- 由权重预测的理论 RMS 噪声放大，\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{ \\frac{1}{N} \\sum_{i=0}^{N-1} \\left( \\sum_{j} w_{i,j}^2 \\right) }.\n$$\n使用在每个索引处（包括边界格式）使用的实际权重计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$。\n\n性能指标。对每个测试用例，计算：\n- 速度估计值相对于精确速度的 RMS 误差，\n$$\nE_v = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( v_i^{\\text{FD}}[x^{\\text{noisy}}] - v(t_i) \\right)^2 } \\ \\text{in m/s}.\n$$\n- 加速度估计值相对于精确加速度的 RMS 误差，\n$$\nE_a = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( a_i^{\\text{FD}}[x^{\\text{noisy}}] - a(t_i) \\right)^2 } \\ \\text{in m/s}^2.\n$$\n- 比率\n$$\nR_v = \\frac{ g_v^{\\text{emp}} }{ g_v^{\\text{theory}} },\\qquad R_a = \\frac{ g_a^{\\text{emp}} }{ g_a^{\\text{theory}} },\n$$\n该比率表明经验噪声放大与理论预测的匹配程度。\n\n测试套件。在以下四个改变了采样间隔和噪声水平的测试用例上运行你的程序：\n- 用例 1：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例 2：$\\Delta t = 0.1\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n- 用例 3：$\\Delta t = 0.01\\ \\text{s}$，$\\sigma_x = 0.01\\ \\text{m}$。\n- 用例 4：$\\Delta t = 0.001\\ \\text{s}$，$\\sigma_x = 0.001\\ \\text{m}$。\n\n最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于从 1 到 4 的每个用例，按以下顺序追加四个浮点数：$E_v$ (单位 m/s)、$E_a$ (单位 m/s$^2$)、$R_v$ (无量纲)、$R_a$ (无量纲)。每个数字必须以科学记数法打印，且恰好有六位有效数字。例如，总体输出格式为\n$$\n[\\ E_{v,1},\\ E_{a,1},\\ R_{v,1},\\ R_{a,1},\\ E_{v,2},\\ E_{a,2},\\ R_{v,2},\\ R_{a,2},\\ E_{v,3},\\ E_{a,3},\\ R_{v,3},\\ R_{a,3},\\ E_{v,4},\\ E_{a,4},\\ R_{v,4},\\ R_{a,4}\\ ].\n$$", "solution": "我们从第一性原理开始。函数 $x(t)$ 在时间 $t$ 的一阶导数由以下极限定义\n$$\n\\frac{dx}{dt}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - x(t-\\Delta t)}{2\\Delta t},\n$$\n这表明对于有限但小的 $\\Delta t$ 可以使用对称（中心）差商。二阶导数由以下极限定义\n$$\n\\frac{d^2x}{dt^2}(t) = \\lim_{\\Delta t \\to 0} \\frac{x(t+\\Delta t) - 2x(t) + x(t-\\Delta t)}{\\Delta t^2}.\n$$\n在 $t_i = i \\Delta t$ 附近使用泰勒级数展开，\n$$\nx(t_{i\\pm 1}) = x(t_i) \\pm \\Delta t\\, x'(t_i) + \\frac{\\Delta t^2}{2} x''(t_i) \\pm \\frac{\\Delta t^3}{6} x^{(3)}(t_i) + \\frac{\\Delta t^4}{24} x^{(4)}(t_i) + \\mathcal{O}(\\Delta t^5),\n$$\n我们可以推导出用于内部点的二阶精度中心格式：\n$$\nx'(t_i) = \\frac{x_{i+1} - x_{i-1}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2), \\quad\nx''(t_i) = \\frac{x_{i+1} - 2 x_i + x_{i-1}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2),\n$$\n其中 $x_i = x(t_i)$。在边界处，无法构造对称差分；作为替代，使用前向点的泰勒展开可以得到单边、二阶精度的格式。对于左边界 $i=0$ 处的一阶导数，\n$$\nx'(t_0) = \\frac{-3 x_0 + 4 x_1 - x_2}{2\\Delta t} + \\mathcal{O}(\\Delta t^2),\n$$\n类似地，对于右边界 $i=N-1$ 处，\n$$\nx'(t_{N-1}) = \\frac{3 x_{N-1} - 4 x_{N-2} + x_{N-3}}{2\\Delta t} + \\mathcal{O}(\\Delta t^2).\n$$\n对于二阶导数，前向和后向二阶精度单边格式为\n$$\nx''(t_0) = \\frac{2 x_0 - 5 x_1 + 4 x_2 - x_3}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2), \\quad\nx''(t_{N-1}) = \\frac{2 x_{N-1} - 5 x_{N-2} + 4 x_{N-3} - x_{N-4}}{\\Delta t^2} + \\mathcal{O}(\\Delta t^2).\n$$\n这些公式是通过求解方程组得到的，该方程组通过逐项匹配泰勒展开来消去低阶误差项，从而确保二阶精度。\n\n噪声放大分析基于线性性质。令将 $\\{x_j\\}$ 映射到导数估计值 $\\{y_i\\}$ 的有限差分算子是线性的：\n$$\ny_i = \\sum_{j} w_{i,j} x_j,\n$$\n其中 $w_{i,j}$ 是算子权重，包括由导数阶数决定的、除以 $\\Delta t$ 适当次幂的归一化。假设测量值包含加性零均值独立噪声 $\\eta_j$，其方差为 $\\mathbb{V}[\\eta_j] = \\sigma_x^2$。由于线性和独立性，\n$$\n\\mathbb{E}[y_i] = \\sum_{j} w_{i,j} \\mathbb{E}[x_j], \\quad\n\\mathbb{V}[y_i] = \\sum_{j} w_{i,j}^2 \\,\\mathbb{V}[\\eta_j] = \\sigma_x^2 \\sum_{j} w_{i,j}^2.\n$$\n因此，索引 $i$ 处噪声分量的均方根 (RMS) 等于\n$$\n\\sqrt{\\mathbb{V}[y_i]} = \\sigma_x \\sqrt{\\sum_{j} w_{i,j}^2}.\n$$\n与实践中使用的经验 RMS 一致的、遍历所有索引的全局 RMS 是\n$$\ng^{\\text{theory}} = \\sigma_x \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left(\\sum_{j} w_{i,j}^2\\right)}.\n$$\n这个表达式通过依赖于索引的权重自然地包含了边界效应。\n\n由此可得两个推论：\n- 对于一阶导数，权重与 $1/\\Delta t$ 成比例，所以 $g_v^{\\text{theory}} \\propto \\sigma_x/\\Delta t$；也就是说，如果每个样本的位置噪声水平固定，减小 $\\Delta t$ 会增加速度估计中的噪声放大。\n- 对于二阶导数，权重与 $1/\\Delta t^2$ 成比例，所以 $g_a^{\\text{theory}} \\propto \\sigma_x/\\Delta t^2$，这意味着噪声的放大效应更强。\n\n经验均方根 (RMS) 噪声放大可以通过比较微分算子应用于带噪声数据和干净数据时的结果来分离出来，这样做可以消除确定性的截断误差：\n$$\ng^{\\text{emp}} = \\sqrt{\\frac{1}{N}\\sum_{i=0}^{N-1} \\left( y_i[x^{\\text{noisy}}] - y_i[x^{\\text{clean}}] \\right)^2 }.\n$$\n因为 $y_i[\\cdot]$ 是线性的，且 $x^{\\text{noisy}} = x^{\\text{clean}} + \\eta$，所以差值等于 $y_i[\\eta]$，其 RMS 在大样本极限下与上面推导的理论表达式相匹配。因此，当经验平均值具有代表性时，比率\n$$\nR_v = \\frac{g_v^{\\text{emp}}}{g_v^{\\text{theory}}},\\qquad R_a = \\frac{g_a^{\\text{emp}}}{g_a^{\\text{theory}}},\n$$\n应接近于 $1$。\n\n算法设计：\n- 构建时间样本 $t_i = i \\Delta t$，对于 $i=0,\\dots,N-1$，$T=10$ s。\n- 根据给定的解析表达式，计算干净的位置 $x(t_i)$、精确的速度 $v(t_i)$ 和加速度 $a(t_i)$。\n- 使用固定的种子生成加性噪声 $\\eta_i \\sim \\mathcal{N}(0,\\sigma_x^2)$ 以确保可复现性，并构成 $x^{\\text{noisy}}_i = x(t_i) + \\eta_i$。\n- 实现用于一阶和二阶导数的二阶精度有限差分估计器，其在内部应用中心格式，在边界应用单边格式，从而对干净和带噪声的输入都得到 $v^{\\text{FD}}$ 和 $a^{\\text{FD}}$。\n- 计算性能指标：$E_v$ 和 $E_a$ 作为与精确导数相比的 RMS 误差。计算 $g_v^{\\text{emp}}$ 和 $g_a^{\\text{emp}}$ 作为在带噪声和干净数据上有限差分输出之间的 RMS 差异。通过在每个索引处对权重平方求和并取平均值来计算 $g_v^{\\text{theory}}$ 和 $g_a^{\\text{theory}}$，然后乘以 $\\sigma_x$ 并开方。最后，计算 $R_v$ 和 $R_a$ 作为经验放大与理论放大的比率。\n- 对四个指定的测试用例重复上述步骤。以要求的单行、括号内、逗号分隔的列表形式打印合并后的结果，使用科学记数法并保留六位有效数字。\n\n预期趋势：\n- 将 $\\sigma_x$ 增加 10 倍，应使 $g^{\\text{emp}}$ 以及 $E_v$ 和 $E_a$ 中由噪声主导的分量增加 10 倍。\n- 增加 $\\Delta t$ 应使 $g_v^{\\text{theory}}$ 大致按 $1/\\Delta t$ 的比例减小，$g_a^{\\text{theory}}$ 大致按 $1/\\Delta t^2$ 的比例减小；然而，截断误差以 $\\mathcal{O}(\\Delta t^2)$ 的速度增长，因此由于截断误差和噪声放大之间的权衡，$E_v$ 和 $E_a$ 可能不会随 $\\Delta t$ 的增加而单调减小。\n- 比率 $R_v$ 和 $R_a$ 应接近 1，从而验证线性噪声放大分析的正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef position(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # x(t) in meters\n    return A * np.sin(2*np.pi*f1*t) + C * np.sin(2*np.pi*f2*t) + D * t**2\n\ndef velocity_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # v(t) in m/s\n    return 2*np.pi*f1*A * np.cos(2*np.pi*f1*t) + 2*np.pi*f2*C * np.cos(2*np.pi*f2*t) + 2*D*t\n\ndef acceleration_true(t, A=1.0, C=0.5, f1=1.0, f2=3.0, D=0.05):\n    # a(t) in m/s^2\n    return -(2*np.pi*f1)**2 * A * np.sin(2*np.pi*f1*t) - (2*np.pi*f2)**2 * C * np.sin(2*np.pi*f2*t) + 2*D\n\ndef fd_first_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for first derivative.\n    - One-sided 3-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  3:\n        raise ValueError(\"Need at least 3 points for second-order first derivative\")\n    # Left boundary: (-3 x0 + 4 x1 - x2)/(2 dt)\n    y[0] = (-3.0*x[0] + 4.0*x[1] - 1.0*x[2]) / (2.0*dt)\n    # Interior\n    y[1:-1] = (x[2:] - x[:-2]) / (2.0*dt)\n    # Right boundary: (3 xN-1 - 4 xN-2 + xN-3)/(2 dt)\n    y[-1] = (3.0*x[-1] - 4.0*x[-2] + 1.0*x[-3]) / (2.0*dt)\n    return y\n\ndef fd_second_derivative(x, dt):\n    \"\"\"\n    Second-order accurate finite difference for second derivative.\n    - One-sided 4-point at boundaries (order 2).\n    - Centered 3-point in interior (order 2).\n    Returns y of same length as x.\n    \"\"\"\n    n = x.size\n    y = np.empty_like(x, dtype=float)\n    if n  4:\n        raise ValueError(\"Need at least 4 points for second derivative with second-order accuracy\")\n    # Left boundary: (2 x0 - 5 x1 + 4 x2 - x3)/dt^2\n    y[0] = (2.0*x[0] - 5.0*x[1] + 4.0*x[2] - 1.0*x[3]) / (dt*dt)\n    # Interior\n    y[1:-1] = (x[2:] - 2.0*x[1:-1] + x[:-2]) / (dt*dt)\n    # Right boundary: (2 xN-1 - 5 xN-2 + 4 xN-3 - xN-4)/dt^2\n    y[-1] = (2.0*x[-1] - 5.0*x[-2] + 4.0*x[-3] - 1.0*x[-4]) / (dt*dt)\n    return y\n\ndef weights_sqsum_first(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the first derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv = 1.0 / (2.0*dt)\n    # Left boundary: (-3, 4, -1)/(2 dt)\n    coeffs = np.array([-3.0, 4.0, -1.0]) * inv\n    s[0] = np.sum(coeffs**2)\n    # Interior: [-1, +1] at i-1 and i+1\n    c = np.array([-1.0, 1.0]) * inv\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (1, -4, 3)/(2 dt) applied to (i-2, i-1, i)\n    coeffs = np.array([1.0, -4.0, 3.0]) * inv\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef weights_sqsum_second(n, dt):\n    \"\"\"\n    For each index i, compute sum_j w_{i,j}^2 for the second derivative operator.\n    Returns an array s of length n with s[i] = sum_j w_{i,j}^2.\n    \"\"\"\n    s = np.zeros(n, dtype=float)\n    inv2 = 1.0 / (dt*dt)\n    # Left boundary: (2, -5, 4, -1)/dt^2\n    coeffs = np.array([2.0, -5.0, 4.0, -1.0]) * inv2\n    s[0] = np.sum(coeffs**2)\n    # Interior: (1, -2, 1)/dt^2\n    c = np.array([1.0, -2.0, 1.0]) * inv2\n    val = np.sum(c**2)\n    s[1:-1] = val\n    # Right boundary: (-1, 4, -5, 2)/dt^2 applied to (i-3, i-2, i-1, i)\n    coeffs = np.array([-1.0, 4.0, -5.0, 2.0]) * inv2\n    s[-1] = np.sum(coeffs**2)\n    return s\n\ndef rms(x):\n    return np.sqrt(np.mean(np.square(x)))\n\ndef format_float(x):\n    # Scientific notation with exactly six significant figures\n    return f\"{x:.6e}\"\n\ndef run_case(dt, sigma_x, rng):\n    T = 10.0\n    N = int(np.floor(T/dt)) + 1\n    t = np.linspace(0.0, dt*(N-1), N)\n    x_clean = position(t)\n    # Generate noise with given sigma\n    noise = rng.normal(loc=0.0, scale=sigma_x, size=N)\n    x_noisy = x_clean + noise\n\n    # True derivatives\n    v_true = velocity_true(t)\n    a_true = acceleration_true(t)\n\n    # Finite difference estimates\n    v_fd_clean = fd_first_derivative(x_clean, dt)\n    a_fd_clean = fd_second_derivative(x_clean, dt)\n    v_fd_noisy = fd_first_derivative(x_noisy, dt)\n    a_fd_noisy = fd_second_derivative(x_noisy, dt)\n\n    # RMS errors against exact\n    E_v = rms(v_fd_noisy - v_true)\n    E_a = rms(a_fd_noisy - a_true)\n\n    # Empirical noise amplification (difference noisy-clean)\n    g_v_emp = rms(v_fd_noisy - v_fd_clean)\n    g_a_emp = rms(a_fd_noisy - a_fd_clean)\n\n    # Theoretical noise amplification from weights\n    s1 = weights_sqsum_first(N, dt)\n    s2 = weights_sqsum_second(N, dt)\n    g_v_theory = sigma_x * np.sqrt(np.mean(s1))\n    g_a_theory = sigma_x * np.sqrt(np.mean(s2))\n\n    # Ratios (avoid division by zero, though here not zero)\n    R_v = g_v_emp / g_v_theory if g_v_theory > 0 else np.nan\n    R_a = g_a_emp / g_a_theory if g_a_theory > 0 else np.nan\n\n    return E_v, E_a, R_v, R_a\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (dt [s], sigma_x [m])\n    test_cases = [\n        (0.01, 0.001),   # Case 1\n        (0.1, 0.001),    # Case 2\n        (0.01, 0.01),    # Case 3\n        (0.001, 0.001),  # Case 4\n    ]\n\n    rng = np.random.default_rng(12345)\n\n    results = []\n    for dt, sigma_x in test_cases:\n        E_v, E_a, R_v, R_a = run_case(dt, sigma_x, rng)\n        results.extend([E_v, E_a, R_v, R_a])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(format_float(x) for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2392343"}, {"introduction": "在对导数近似及其局限性有了扎实的理解之后，我们现在可以将它们作为基本构件，来求解由偏微分方程(PDE)描述的复杂物理问题。本实践将处理平流-扩散方程，这是输运现象的基石。你将研究对流项（一阶导数）的不同近似方法——中心差分、上风差分和下风差分——如何影响解的稳定性和准确性，从而亲身体验像人工耗散这样的重要数值现象。[@problem_id:2392370]", "problem": "考虑一维线性平流-扩散偏微分方程（PDE）\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = \\nu\\,\\partial_{xx} u(x,t),\n$$\n在周期性域 $x \\in [0,1)$ 上，周期为 $1$。其中 $a0$ 为常数平流速度，$\\nu \\ge 0$ 为常数扩散系数。设初始条件为\n$$\nu(x,0) = \\sin\\!\\big(2\\pi k\\,x\\big),\n$$\n其中波数 $k \\ge 1$ 为整数，角度以弧度为单位。\n\n使用包含 $N$ 个点的均匀周期性网格对空间进行离散化，网格间距为 $\\Delta x = 1/N$，网格节点为 $x_i = i\\,\\Delta x$，其中 $i \\in \\{0,1,\\dots,N-1\\}$。对于网格函数 $\\mathbf{u} = (u_0,\\dots,u_{N-1})^\\top$，定义一阶和二阶空间导数的周期性有限差分算子如下：\n$$\n(\\mathrm{D}^{\\mathrm{C}} \\mathbf{u})_i = \\frac{u_{i+1} - u_{i-1}}{2\\,\\Delta x},\\quad\n(\\mathrm{D}^{\\mathrm{U}} \\mathbf{u})_i = \\frac{u_i - u_{i-1}}{\\Delta x},\\quad\n(\\mathrm{D}^{\\mathrm{D}} \\mathbf{u})_i = \\frac{u_{i+1} - u_i}{\\Delta x},\n$$\n和\n$$\n(\\mathrm{D}^{(2)} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2},\n$$\n采用周期性索引，使得 $u_{-1} \\equiv u_{N-1}$ 且 $u_{N} \\equiv u_0$。对于每种平流近似 $\\mathrm{D}^{\\bullet} \\in \\{\\mathrm{D}^{\\mathrm{C}}, \\mathrm{D}^{\\mathrm{U}}, \\mathrm{D}^{\\mathrm{D}}\\}$，定义相应的半离散空间算子\n$$\n\\mathbf{L}^{(\\bullet)} = -a\\,\\mathrm{D}^{\\bullet} + \\nu\\,\\mathrm{D}^{(2)}.\n$$\n通过矩阵指数对半离散系统进行精确的时间演化，使得\n$$\n\\mathbf{u}^{(\\bullet)}(T) = \\exp\\!\\big( T\\,\\mathbf{L}^{(\\bullet)} \\big)\\,\\mathbf{u}(0),\n$$\n其中 $\\mathbf{u}(0)$ 是采样得到的初始条件 $\\big(\\sin(2\\pi k x_i)\\big)_{i=0}^{N-1}$，$\\exp$ 表示矩阵指数。该偏微分方程在网格节点上的精确解为\n$$\nu_{\\text{exact}}(x_i,T) = \\exp\\!\\big( -\\nu\\,(2\\pi k)^2\\,T \\big)\\,\\sin\\!\\big( 2\\pi k\\,(x_i - a\\,T) \\big).\n$$\n对于每种平流近似，计算在时间 $T$ 时的离散 $\\ell^2$ 误差，\n$$\nE^{(\\bullet)} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\big(u^{(\\bullet)}_i(T) - u_{\\text{exact}}(x_i,T)\\big)^2 \\right)^{1/2}.\n$$\n\n您的程序必须对以下四个测试用例（角度以弧度为单位）中的每一个计算三元组 $\\big(E^{(\\mathrm{C})}, E^{(\\mathrm{U})}, E^{(\\mathrm{D})}\\big)$：\n\n- 用例 1：$N=64$, $a=1$, $\\nu=0.01$, $T=0.1$, $k=1$。\n- 用例 2：$N=64$, $a=1$, $\\nu=0.0005$, $T=0.05$, $k=1$。\n- 用例 3：$N=32$, $a=1$, $\\nu=0.1$, $T=0.1$, $k=1$。\n- 用例 4：$N=64$, $a=1$, $\\nu=0.01$, $T=0.1$, $k=3$。\n\n所要求的最终输出格式是包含12个浮点数的单行扁平列表，其顺序为\n$$\n\\big[E^{(\\mathrm{C})}_{1}, E^{(\\mathrm{U})}_{1}, E^{(\\mathrm{D})}_{1}, E^{(\\mathrm{C})}_{2}, E^{(\\mathrm{U})}_{2}, E^{(\\mathrm{D})}_{2}, E^{(\\mathrm{C})}_{3}, E^{(\\mathrm{U})}_{3}, E^{(\\mathrm{D})}_{3}, E^{(\\mathrm{C})}_{4}, E^{(\\mathrm{U})}_{4}, E^{(\\mathrm{D})}_{4}\\big],\n$$\n其中下标表示测试用例的索引。每个数字必须四舍五入到小数点后恰好 $8$ 位，并以十进制小数表示。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$\\big[0.12345678,0.00000000,\\dots\\big]$）。", "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个在计算物理学领域内关于偏微分方程数值解的适定、有科学依据的问题。所有常数、变量、边界条件和方法都得到了精确定义并且相互一致。\n\n该问题要求计算一维线性平流-扩散方程中平流项的三种不同有限差分近似的数值误差：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = \\nu\\,\\partial_{xx} u(x,t)\n$$\n空间域为 $x \\in [0,1)$，带有周期性边界条件。求解过程首先是在一个包含 $N$ 个点 $x_i = i\\,\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$，$\\Delta x = 1/N$）的均匀网格上对空间导数进行离散化。这种半离散化方法将偏微分方程转化为一个包含 $N$ 个耦合常微分方程（ODEs）的系统：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}^{(\\bullet)}\\mathbf{u}(t)\n$$\n其中 $\\mathbf{u}(t)$ 是网格点上解值的向量，而 $\\mathbf{L}^{(\\bullet)}$ 是给定平流格式 $(\\bullet) \\in \\{\\mathrm{C}, \\mathrm{U}, \\mathrm{D}\\}$ 的空间算子的矩阵表示。该问题要求对此常微分方程系统进行精确的时间积分，这通过使用矩阵指数来实现：\n$$\n\\mathbf{u}(T) = \\exp(T\\,\\mathbf{L}^{(\\bullet)})\\,\\mathbf{u}(0)\n$$\n任务的核心是为算子构建矩阵，计算在时间 $T$ 的解，并根据提供的解析解评估离散 $\\ell^2$ 误差。\n\n每个测试用例的处理流程如下：\n\n1.  **算子的矩阵表示**：有限差分算子被表示为作用于网格函数向量 $\\mathbf{u} = (u_0, \\dots, u_{N-1})^\\top$ 的 $N \\times N$ 矩阵。由于周期性边界条件，这些矩阵是循环矩阵。\n\n    - 二阶导数算子 $(\\mathrm{D}^{(2)} \\mathbf{u})_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{\\Delta x^2}$ 由一个矩阵 $\\mathbf{M}^{(2)}$ 表示，其元素为：\n      $$\n      \\mathbf{M}^{(2)}_{i,j} = \\frac{1}{\\Delta x^2} \\begin{cases} -2  \\text{if } j=i \\\\ 1  \\text{if } j = (i \\pm 1) \\pmod N \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n\n    - 中心差分一阶导数算子 $(\\mathrm{D}^{\\mathrm{C}} \\mathbf{u})_i = \\frac{u_{i+1} - u_{i-1}}{2\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{C})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{C})}_{i,j} = \\frac{1}{2\\Delta x} \\begin{cases} 1  \\text{if } j = (i+1) \\pmod N \\\\ -1  \\text{if } j = (i-1) \\pmod N \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n\n    - 迎风差分算子 $(\\mathrm{D}^{\\mathrm{U}} \\mathbf{u})_i = \\frac{u_i - u_{i-1}}{\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{U})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{U})}_{i,j} = \\frac{1}{\\Delta x} \\begin{cases} 1  \\text{if } j=i \\\\ -1  \\text{if } j = (i-1) \\pmod N \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n\n    - 顺风差分算子 $(\\mathrm{D}^{\\mathrm{D}} \\mathbf{u})_i = \\frac{u_{i+1} - u_i}{\\Delta x}$ 由一个矩阵 $\\mathbf{M}^{(\\mathrm{D})}$ 表示：\n      $$\n      \\mathbf{M}^{(\\mathrm{D})}_{i,j} = \\frac{1}{\\Delta x} \\begin{cases} -1  \\text{if } j=i \\\\ 1  \\text{if } j = (i+1) \\pmod N \\\\ 0  \\text{otherwise} \\end{cases}\n      $$\n\n2.  **半离散系统的构建**：对于每种平流格式 $(\\bullet)$，组装完整的半离散算子矩阵 $\\mathbf{L}^{(\\bullet)}$：\n    $$\n    \\mathbf{L}^{(\\bullet)} = -a\\,\\mathbf{M}^{(\\bullet)} + \\nu\\,\\mathbf{M}^{(2)}\n    $$\n    其中 $\\mathbf{M}^{(\\bullet)}$ 是 $\\mathbf{M}^{(\\mathrm{C})}$、$\\mathbf{M}^{(\\mathrm{U})}$ 或 $\\mathbf{M}^{(\\mathrm{D})}$ 之一。\n\n3.  **数值解和误差计算**：对于由参数 $(N, a, \\nu, T, k)$ 定义的每个测试用例：\n    - 定义网格点 $x_i = i/N$，其中 $i \\in \\{0, \\dots, N-1\\}$。\n    - 从初始函数 $u(x,0) = \\sin(2\\pi k x)$ 形成初始条件向量 $\\mathbf{u}(0)$，其元素为 $(\\mathbf{u}(0))_i = \\sin(2\\pi k x_i)$。\n    - 在时间 $T$ 的数值解向量通过 $\\mathbf{u}^{(\\bullet)}(T) = \\exp(T\\,\\mathbf{L}^{(\\bullet)})\\,\\mathbf{u}(0)$ 计算。矩阵指数使用一个鲁棒的数值算法计算，例如 `scipy.linalg.expm` 中提供的算法。\n    - 在网格点上计算精确解向量 $\\mathbf{u}_{\\text{exact}}(T)$：$(\\mathbf{u}_{\\text{exact}}(T))_i = \\exp(-\\nu(2\\pi k)^2 T) \\sin(2\\pi k(x_i - aT))$。\n    - 然后根据给定公式计算离散 $\\ell^2$ 误差：\n      $$\n      E^{(\\bullet)} = \\left( \\Delta x \\sum_{i=0}^{N-1} \\big(u^{(\\bullet)}_i(T) - u_{\\text{exact}}(x_i,T)\\big)^2 \\right)^{1/2}\n      $$\n\n此过程被系统地应用于所有四个测试用例，并将得到的十二个误差值按规定格式收集和格式化。该实现将利用 `numpy` 库进行高效的数组和矩阵运算，并利用 `scipy` 计算矩阵指数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import expm\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection-diffusion equation using finite differences\n    and matrix exponentiation for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: N=64, a=1, nu=0.01, T=0.1, k=1\n        (64, 1.0, 0.01, 0.1, 1),\n        # Case 2: N=64, a=1, nu=0.0005, T=0.05, k=1\n        (64, 1.0, 0.0005, 0.05, 1),\n        # Case 3: N=32, a=1, nu=0.1, T=0.1, k=1\n        (32, 1.0, 0.1, 0.1, 1),\n        # Case 4: N=64, a=1, nu=0.01, T=0.1, k=3\n        (64, 1.0, 0.01, 0.1, 3),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        N, a, nu, T, k = case\n        \n        # Grid setup\n        dx = 1.0 / N\n        x = np.arange(N) * dx\n        \n        # Initial condition vector\n        u0 = np.sin(2 * np.pi * k * x)\n        \n        # Exact solution at time T\n        decay_factor = np.exp(-nu * (2 * np.pi * k)**2 * T)\n        u_exact_T = decay_factor * np.sin(2 * np.pi * k * (x - a * T))\n        \n        # Construct matrix for the second derivative (D^2)\n        dx2 = dx**2\n        M2 = (np.diag(np.full(N, -2.0)) + \n              np.diag(np.full(N - 1, 1.0), 1) + \n              np.diag(np.full(N - 1, 1.0), -1)) / dx2\n        M2[0, -1] = 1.0 / dx2\n        M2[-1, 0] = 1.0 / dx2\n\n        # Construct matrices for the first derivative (D^C, D^U, D^D)\n        # Central difference (D^C)\n        M1_C = (np.diag(np.full(N - 1, 1.0), 1) + \n                np.diag(np.full(N - 1, -1.0), -1)) / (2 * dx)\n        M1_C[0, -1] = -1.0 / (2 * dx)\n        M1_C[-1, 0] = 1.0 / (2 * dx)\n\n        # Upwind difference (D^U)\n        M1_U = (np.diag(np.full(N, 1.0)) + \n                np.diag(np.full(N - 1, -1.0), -1)) / dx\n        M1_U[0, -1] = -1.0 / dx\n        \n        # Downwind difference (D^D)\n        M1_D = (np.diag(np.full(N, -1.0)) + \n                np.diag(np.full(N - 1, 1.0), 1)) / dx\n        M1_D[-1, 0] = 1.0 / dx\n        \n        M1_schemes = {'C': M1_C, 'U': M1_U, 'D': M1_D}\n        case_errors = []\n        \n        for scheme_key in ['C', 'U', 'D']:\n            M1 = M1_schemes[scheme_key]\n            \n            # Assemble the semi-discrete operator matrix L\n            L = -a * M1 + nu * M2\n            \n            # Compute numerical solution using matrix exponential\n            u_T_numerical = expm(T * L) @ u0\n            \n            # Compute the discrete l^2 error\n            error = np.sqrt(dx * np.sum((u_T_numerical - u_exact_T)**2))\n            case_errors.append(error)\n\n        results.extend(case_errors)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2392370"}]}