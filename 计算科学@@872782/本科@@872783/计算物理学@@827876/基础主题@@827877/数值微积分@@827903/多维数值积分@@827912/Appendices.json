{"hands_on_practices": [{"introduction": "在物理学中，许多教科书里的理想模型都有简洁的解析解，但在现实世界中，情况往往更为复杂，需要借助数值方法。亥姆霍兹线圈就是一个很好的例子：理想的无限细线圈的磁场可以精确计算，但具有有限矩形截面的真实线圈则需要积分。这个实践将引导你通过数值积分来计算更真实模型下的磁场，从而弥合理想模型与实际应用之间的差距。[@problem_id:2414964]", "problem": "一对相同的同轴圆形线圈（亥姆霍兹线圈）在其几何中心产生一个磁场。每个线圈都以共同的对称轴（$z$轴）为中心，位于 $z=\\pm R/2$ 的位置，其中 $R$ 是每个线圈的平均半径。每个线圈由 $N$ 匝紧密缠绕的导线组成，载有沿相同方位角方向的稳定电流 $I$。匝数均匀分布在一个有限的矩形截面上，该截面以半径为 $R$ 的圆为中心，径向半宽为 $w_r \\ge 0$，轴向半高为 $w_z \\ge 0$。在每个线圈的局部圆柱坐标系中，该矩形截面在径向上的范围为 $\\rho \\in [R-w_r,\\, R+w_r]$，在相对于线圈中心平面的轴向上的范围为 $\\zeta \\in [-w_z,\\, w_z]$。假设电流密度对应于整个截面积上均匀的匝数密度。磁场将在原点 $\\mathbf{r}=\\mathbf{0}$ 处进行评估。\n\n设 $\\mu_0$ 为磁常数（真空磁导率）。对于一个半径为 $\\rho$、载有电流 $I$ 的薄圆环，在距离环平面轴向距离为 $z$ 的对称轴上，磁场的大小为\n$$\nB_{\\text{loop}}(\\rho,z) \\;=\\; \\frac{\\mu_0\\, I\\, \\rho^2}{2\\left(\\rho^2+z^2\\right)^{3/2}}.\n$$\n对于具有有限矩形截面的线圈，将线圈建模为在矩形上以匝数密度 $n_A$（单位面积的匝数）均匀分布的无穷小匝数的连续体。一个线圈的总匝数为 $N$。如果 $w_r0$ 且 $w_z0$，则 $n_A = \\dfrac{N}{(2w_r)(2w_z)}$。如果 $w_r=0$ 且 $w_z=0$，则将线圈解释为位于线圈中心平面、半径为 $R$ 的具有 $N$ 匝的薄环。\n\n将两个线圈在原点产生的总磁场大小定义为 $B(0)$，它是位于 $z=+R/2$ 和 $z=-R/2$ 的两个相同线圈的轴向分量之和。所有距离以米为单位，电流以安培为单位，磁场以特斯拉为单位表示。\n\n你的任务是编写一个完整、可运行的程序，为以下测试套件中的每组参数计算 $B(0)$。如果 $w_r=0$ 且 $w_z=0$，则将线圈视为具有 $N$ 匝的薄环。在下面提供的所有其他情况中，$w_r0$ 且 $w_z0$。使用 $\\mu_0 = 4\\pi\\times 10^{-7}\\,\\text{N}\\,\\text{A}^{-2}$。\n\n测试套件（每个元组为 $(N, I, R, w_r, w_z)$）：\n- 情况 $1$（边界情况，薄线圈）：$(200,\\;1.5,\\;0.25,\\;0.0,\\;0.0)$\n- 情况 $2$（有限截面，小厚度）：$(200,\\;1.5,\\;0.25,\\;0.01,\\;0.01)$\n- 情况 $3$（有限截面，较厚）：$(100,\\;2.0,\\;0.30,\\;0.03,\\;0.02)$\n\n你的程序必须生成单行输出，其中包含三个结果 $[B_1,B_2,B_3]$（单位为特斯拉），其中 $B_k$ 是情况 $k$ 的 $B(0)$ 值。每个 $B_k$ 必须以十进制浮点数形式打印（单位为特斯拉），并四舍五入到 $10$ 位有效数字。此问题不涉及角度。最终输出格式必须是严格的单行，用方括号括起来的逗号分隔列表，例如：$[0.001234567,0.001111111,0.0009876543]$（此处显示的值仅为例）。", "solution": "问题陈述已经过严格评估，并被确定为**有效**。它构成了一个计算物理学领域中的适定问题，特别是在静磁学领域。该问题具有科学依据，内部一致，并为计算唯一解提供了所有必要信息。任务是通过积分载流细丝连续分布的贡献，来计算亥姆霍兹线圈系统中心的磁场，其中线圈具有有限的矩形截面。\n\n解决此问题的基本原理是毕奥-萨伐尔定律。一个半径为 $\\rho$、载有电流 $I_{\\text{loop}}$ 的单圆环，在距离环平面轴向距离为 $z'$ 的轴线上产生的磁场由下式给出：\n$$\nB_{\\text{loop}}(\\rho, z') = \\frac{\\mu_0 I_{\\text{loop}} \\rho^2}{2\\left(\\rho^2 + (z')^2\\right)^{3/2}}\n$$\n磁场方向沿对称轴。对于指定的亥姆霍兹线圈配置，两个线圈都在原点产生轴向磁场，并且这些贡献相长叠加。\n\n为了考虑线圈的有限截面，每个线圈被建模为无穷小电流环的连续体。线圈总共有 $N$ 匝，载有电流 $I$。对于由径向半宽 $w_r  0$ 和轴向半高 $w_z  0$ 定义的非零截面，其截面积为 $A = (2w_r)(2w_z) = 4w_r w_z$。匝数均匀分布，单位面积的匝数密度为 $n_A = N/A = N/(4w_r w_z)$。\n\n截面内半径为 $\\rho$、轴向位置为 $z'$ 的无穷小面积元 $d\\rho dz'$ 对应一个包含 $n_A d\\rho dz'$ 匝的无穷小环。这个环路携带的有效电流为 $dI_{\\text{loop}} = I \\cdot (n_A d\\rho dz')$。该元件在原点产生的微分磁场 $dB_z$ 为：\n$$\ndB_z(\\rho, z') = \\frac{\\mu_0 (I n_A d\\rho dz') \\rho^2}{2\\left(\\rho^2 + (z')^2\\right)^{3/2}} = \\frac{\\mu_0 I N}{8 w_r w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} d\\rho dz'\n$$\n单个线圈产生的总磁场可以通过对其截面积分此表达式得到。第一个线圈中心位于 $z_c = +R/2$，因此其截面范围为 $\\rho \\in [R-w_r, R+w_r]$ 和 $z' \\in [R/2-w_z, R/2+w_z]$。其贡献 $B_1$ 为：\n$$\nB_1 = \\frac{\\mu_0 I N}{8 w_r w_z} \\int_{R-w_r}^{R+w_r} \\int_{R/2-w_z}^{R/2+w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} dz' d\\rho\n$$\n第二个线圈中心位于 $z_c = -R/2$，其截面范围为 $z' \\in [-R/2-w_z, -R/2+w_z]$。其贡献为 $B_2$。由于被积函数是 $z'$ 的偶函数，通过简单的变量替换可知，第二个线圈的积分与第一个相同。因此，$B_2 = B_1$。\n\n原点的总磁场是两个线圈贡献之和：\n$$\nB(0) = B_1 + B_2 = 2 B_1 = \\frac{\\mu_0 I N}{4 w_r w_z} \\int_{R-w_r}^{R+w_r} \\int_{R/2-w_z}^{R/2+w_z} \\frac{\\rho^2}{\\left(\\rho^2 + (z')^2\\right)^{3/2}} dz' d\\rho\n$$\n此表达式对有限截面（$w_r  0$, $w_z  0$）有效，并且需要进行数值评估。\n\n当 $w_r=0$ 且 $w_z=0$ 时，出现一个特殊情况。此时，线圈被视为一个半径为 $R$、有 $N$ 匝的理想薄环。这样一个位于轴向位置 $z=R/2$ 的线圈产生的磁场为：\n$$\nB_1 = \\frac{\\mu_0 (NI) R^2}{2\\left(R^2 + (R/2)^2\\right)^{3/2}} = \\frac{\\mu_0 N I R^2}{2\\left(5R^2/4\\right)^{3/2}} = \\frac{\\mu_0 N I R^2}{2(5\\sqrt{5}/8)R^3} = \\frac{4\\mu_0 N I}{5\\sqrt{5}R}\n$$\n因此，理想亥姆霍兹线圈在原点产生的总磁场为：\n$$\nB(0) = 2 B_1 = \\frac{8\\mu_0 N I}{5\\sqrt{5}R} = \\left(\\frac{4}{5}\\right)^{3/2} \\frac{\\mu_0 N I}{R}\n$$\n此解析公式用于情况 $1$。对于情况 $2$ 和 $3$，有限截面的二重积分使用标准的二维求积程序进行数值计算。以下程序实现了这一逻辑，以确定每个指定测试用例的磁场。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import dblquad\nfrom scipy.constants import mu_0\n\ndef solve():\n    \"\"\"\n    Computes the magnetic field at the center of a Helmholtz coil system\n    for different coil cross-section geometries.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (N, I, R, w_r, w_z) corresponding to:\n    # N: number of turns per coil\n    # I: current in amperes\n    # R: mean radius in meters\n    # w_r: radial half-width in meters\n    # w_z: axial half-height in meters\n    test_cases = [\n        (200, 1.5, 0.25, 0.0, 0.0),    # Case 1 (boundary, thin coils)\n        (200, 1.5, 0.25, 0.01, 0.01), # Case 2 (finite cross-section, small thickness)\n        (100, 2.0, 0.30, 0.03, 0.02), # Case 3 (finite cross-section, thicker)\n    ]\n\n    results = []\n\n    # The integrand is derived from the Biot-Savart law for a circular loop.\n    # integrand(z', rho) = rho^2 / (rho^2 + z'^2)^(3/2)\n    integrand = lambda z_prime, rho: rho**2 / (rho**2 + z_prime**2)**1.5\n\n    for case in test_cases:\n        N, I, R, w_r, w_z = case\n        \n        B0 = 0.0\n        \n        # Case 1: Ideal thin loop (w_r=0, w_z=0)\n        # This case has a simple analytical solution for an ideal Helmholtz coil.\n        if w_r == 0 and w_z == 0:\n            # B(0) = (4/5)^(3/2) * mu_0 * N * I / R\n            # This is equivalent to B(0) = 8 * mu_0 * N * I / (5 * sqrt(5) * R)\n            B0 = (8 * mu_0 * N * I) / (5 * np.sqrt(5) * R)\n        \n        # Cases 2  3: Finite rectangular cross-section (w_r > 0, w_z > 0)\n        # This requires numerical integration.\n        else:\n            # The total field at the origin is B(0) = 2 * B_coil_1 due to symmetry.\n            # B_coil_1 is the field from the coil at z > 0, given by an integral\n            # over its cross-section.\n            # B(0) = 2 * (mu_0 * I * N) / (4 * w_r * w_z) * Integral[... d_rho d_z']\n            prefactor = (mu_0 * I * N) / (2 * w_r * w_z)\n            \n            # Integration limits for one coil (the one at z > 0)\n            rho_min, rho_max = R - w_r, R + w_r\n            # z_prime represents the absolute axial coordinate of the differential loop\n            z_prime_min, z_prime_max = R / 2 - w_z, R / 2 + w_z\n\n            # Perform the double integral over one coil's cross-section.\n            # dblquad calculates integral(rho_min to rho_max) of\n            # [integral(g(rho) to h(rho)) of integrand(z', rho) dz'] d_rho.\n            # The order of arguments to the lambda is (y, x), which we map to (z_prime, rho).\n            integral_val, _ = dblquad(\n                integrand,\n                rho_min,\n                rho_max,\n                lambda rho: z_prime_min,\n                lambda rho: z_prime_max\n            )\n            \n            # The total B(0) is the sum of fields from two identical coils.\n            # Due to the way the integral is set up for one coil, and the symmetry,\n            # B(0) = 2 * integral_result.\n            # However, my derivation in the solution text had a small confusion.\n            # Let's re-derive carefully here.\n            # dB_z_total = dB_z(coil_1) + dB_z(coil_2). For an element at (rho, zeta) in local coords.\n            # Coil 1 is at z=R/2, so global z' = R/2 + zeta.\n            # Coil 2 is at z=-R/2, so global z' = -R/2 + zeta.\n            # dB_z(rho, z') = C * rho^2 / (rho^2 + z'^2)^1.5.\n            # d_B_total = C * [rho^2 / (rho^2 + (R/2+zeta)^2)^1.5 + rho^2 / (rho^2 + (-R/2+zeta)^2)^1.5]\n            # This is more complex. Let's stick to the problem solution text's approach, which is simpler and correct.\n            # B(0) = B_1 + B_2. B_1 is for coil at +R/2, B_2 is for coil at -R/2.\n            # B_1 = Integral over rho in [R-wr, R+wr], z' in [R/2-wz, R/2+wz]\n            # B_2 = Integral over rho in [R-wr, R+wr], z' in [-R/2-wz, -R/2+wz]\n            # By symmetry z' -> -z', the integral for B_2 is the same as for B_1.\n            # B(0) = 2 * B_1.\n            # B_1 = (mu_0 * I * N / (4 * w_r * w_z)) * integral_val\n            # B(0) = (mu_0 * I * N / (2 * w_r * w_z)) * integral_val.\n            # Wait, the solution formula has a different prefactor: mu_0*I*N / (4*wr*wz).\n            # dBz = C * d_rho * dz'. dI_loop = I * n_A * d_rho * dz_local = I * (N/(4wrwz)) * d_rho * dz_local.\n            # B_1_element = (mu_0 * dI_loop * rho^2) / (2 * (rho^2+z_global^2)^1.5)\n            # B_1 = integral over rho, z_local of B_1_element.\n            # B_1 = mu_0 * I * N / (8*wr*wz) * integral(rho, z_local) of [rho^2 / (rho^2 + (R/2+z_local)^2)^1.5]\n            # B_total = B_1 + B_2 = 2*B_1 by symmetry.\n            # B_total = mu_0 * I * N / (4*wr*wz) * Integral[...].\n            # Ah, the solution text is correct. My code prefactor was `mu_0*I*N/(2*wr*wz)`, which is wrong. It should be `/ (4*wr*wz)`.\n            # Let me re-check the solution text derivation.\n            # B1 = ... \\int \\int ...\n            # B(0) = 2 * B1 = mu_0*I*N/(4wrwz) * \\int \\int ...\n            # The code `prefactor = (mu_0 * I * N) / (2 * w_r * w_z)` seems to have a bug.\n            # `B0 = prefactor * integral_val`. The code does `B0 = (mu_0*I*N)/(2*wr*wz) * integral`.\n            # The solution states `B(0) = (mu_0*I*N)/(4*wr*wz) * integral`.\n            # A factor of 2 difference.\n            # Let's trust the solution derivation text, as it seems more careful.\n            # I will correct the python code to match the solution text.\n            prefactor = (mu_0 * I * N) / (4 * w_r * w_z) # Corrected prefactor\n            \n            # The total magnetic field is the sum of contributions from both coils.\n            # The integral below is for the coil at z > 0.\n            integral_val_coil1, _ = dblquad(\n                integrand,\n                R - w_r, R + w_r,\n                lambda rho: R/2 - w_z, lambda rho: R/2 + w_z\n            )\n            \n            # The integral for the coil at z  0 is identical by symmetry (z' -> -z').\n            # The integration range is [-R/2-w_z, -R/2+w_z].\n            integral_val_coil2, _ = dblquad(\n                integrand,\n                R - w_r, R + w_r,\n                lambda rho: -R/2 - w_z, lambda rho: -R/2 + w_z\n            )\n            # The solution text's logic B1=B2 is based on the integrand being an even function of z',\n            # which is true, but the integration domains are [R/2-wz, R/2+wz] and [-R/2-wz, -R/2+wz].\n            # These are not symmetric around 0, so the integrals are not necessarily equal unless z'->-z'\n            # maps one domain to another, which it doesn't.\n            # The code implementation is `B0 = prefactor * integral_val`, where integral_val is only for one coil.\n            # This is confusing. Let's re-read the solution logic.\n            # B(0) = 2 * B1. B1 is the integral over one coil.\n            # B1 = const * Integral[...].\n            # B(0) = (2*const) * Integral[...] = (mu_0*I*N)/(4wrwz) * Integral[...]. This is what the solution says.\n            # My corrected python code implements this. The original python code seems to have had a bug.\n            # Let's stick with the most rigorous derivation.\n            # Total B = Integral_coil1(E_element) + Integral_coil2(E_element)\n            # Let's use the full prefactor for a single differential loop.\n            # B_total = integral_section1(B_loop) + integral_section2(B_loop)\n            # B_loop contribution from a d_rho*dz' element carrying current dI = I * N / (4wrwz) * drho * dz' is\n            # dB = (mu_0 * dI * rho^2) / (2*(rho^2+z'^2)^1.5)\n            # B_total = mu_0*I*N/(8*wr*wz) * [ integral_sec1(integrand) + integral_sec2(integrand) ]\n            # sec1: z' in [R/2-wz, R/2+wz]. sec2: z' in [-R/2-wz, -R/2+wz]. rho for both is [R-wr, R+wr].\n            # This seems the most solid derivation.\n            # Let's implement this in the code.\n            \n            coeff = mu_0 * I * N / (8 * w_r * w_z)\n            \n            integral1, _ = dblquad(integrand, R-w_r, R+w_r, lambda r: R/2-w_z, lambda r: R/2+w_z)\n            integral2, _ = dblquad(integrand, R-w_r, R+w_r, lambda r: -R/2-w_z, lambda r: -R/2+w_z)\n\n            B0 = coeff * (integral1 + integral2)\n\n        results.append(f\"{B0:.10g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2414964"}, {"introduction": "将数值计算应用到物理学的另一个核心领域——静电学，是一种增强对计算方法信心的强大方式。本练习要求你通过对一个立方体表面的六个面分别进行积分，来数值验证高斯定律这一基本物理法则。这个过程不仅能让你在实际编程中巩固对曲面积分概念的理解，还能让你体会到理论物理定律在计算中的具体体现。[@problem_id:2415017]", "problem": "题目要求您编写一个完整的、可运行的程序，该程序通过数值方法计算由点电荷产生的、穿过一个闭合立方体表面的总电通量，并将结果与高斯定律的预测进行比较。在真空环境下，使用国际单位制（SI）进行计算。所有涉及通量的物理答案必须以 $\\mathrm{N \\cdot m^2/C}$ 为单位表示。\n\n在真空中，一个位于位置 $\\mathbf{r}_0 = (x_q,y_q,z_q)$、电荷量为 $q$ 的点电荷产生的电场由库仑定律给出：\n$$\n\\mathbf{E}(\\mathbf{r}) = \\frac{1}{4\\pi \\varepsilon_0}\\,\\frac{q\\,(\\mathbf{r}-\\mathbf{r}_0)}{\\lVert \\mathbf{r}-\\mathbf{r}_0\\rVert^3},\n$$\n其中 $\\varepsilon_0$ 是真空介电常数。通过闭合曲面 $S$ 的总电通量 $\\Phi$ 定义为\n$$\n\\Phi = \\iint_S \\mathbf{E}\\cdot d\\mathbf{A},\n$$\n其中 $d\\mathbf{A}$ 是向外的面积元。高斯定律指出，对于一个点电荷，通过任何闭合曲面的精确通量为\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0},\n$$\n其中，如果电荷严格位于闭合曲面内部，则 $q_{\\text{enclosed}}=q$；如果严格位于外部，则 $q_{\\text{enclosed}}=0$。此处不考虑电荷恰好位于曲面上的情况。\n\n设闭合曲面为一个坐标轴对齐的立方体，其边长为 $L0$，中心位于 $\\mathbf{c}=(c_x,c_y,c_z)$，因此其六个面是平面 $x=c_x\\pm L/2$，$y=c_y\\pm L/2$ 和 $z=c_z\\pm L/2$，法线朝外。\n\n您的程序必须：\n- 通过对六个面进行积分，数值计算曲面积分 $\\Phi=\\iint_S \\mathbf{E}\\cdot d\\mathbf{A}$。不要假设任何对称性简化。\n- 通过测试 $(x_q,y_q,z_q)$ 是否严格位于开立方体 $(c_x-L/2,c_x+L/2)\\times(c_y-L/2,c_y+L/2)\\times(c_z-L/2,c_z+L/2)$ 内部来确定 $q_{\\text{enclosed}}$。\n- 计算每个测试用例的绝对误差 $\\Delta=\\lvert \\Phi-\\Phi_{\\text{exact}}\\rvert$。\n- 在最终输出中，将每个 $\\Delta$ 以 $\\mathrm{N \\cdot m^2/C}$ 为单位表示，并将每个值四舍五入到六位有效数字的科学记数法。\n\n使用真空介电常数 $\\varepsilon_0=8.8541878128\\times 10^{-12}\\ \\mathrm{F/m}$，并假设所有量均采用标准国际单位制（SI）值。如果您的数值方法中使用到角度，则必须以弧度为单位。\n\n测试套件：您的程序必须评估以下情况，其中 $L$ 的单位是 $\\mathrm{m}$，位置的单位是 $\\mathrm{m}$，$q$ 的单位是 $\\mathrm{C}$。\n- 情况 1：$\\mathbf{c}=(0,0,0)$，$L=2$，$\\mathbf{r}_0=(0,0,0)$，$q=1.0\\times 10^{-6}$。\n- 情况 2：$\\mathbf{c}=(0,0,0)$，$L=2$，$\\mathbf{r}_0=(3,0,0)$，$q=1.0\\times 10^{-6}$。\n- 情况 3：$\\mathbf{c}=(0.2,-0.1,0.3)$，$L=1.4$，$\\mathbf{r}_0=(0.8,-0.1,0.3)$，$q=-2.0\\times 10^{-6}$。\n- 情况 4：$\\mathbf{c}=(1.0,1.0,1.0)$，$L=0.5$，$\\mathbf{r}_0=(1.1,1.1,1.1)$，$q=5.0\\times 10^{-7}$。\n\n最终输出格式：您的程序应产生单行输出，其中包含用方括号括起来的逗号分隔列表，第 $k$ 个条目是情况 $k$ 的绝对误差 $\\Delta$，以 $\\mathrm{N \\cdot m^2/C}$ 为单位，并四舍五入到六位有效数字的科学记数法。例如，一个包含四个结果的输出行必须如下所示\n$$\n[\\text{d}_1,\\text{d}_2,\\text{d}_3,\\text{d}_4]\n$$\n其中每个 $\\text{d}_k$ 都以六位有效数字的科学记数法打印。", "solution": "问题陈述已经过严格验证，被认为是有效的。它构成了一个适定的计算物理学练习，具有科学合理性，并提供了一套完整的参数和明确的目标。因此，我们将提供一个完整的解决方案。目标是数值计算通过一个闭合立方体表面的电通量，并将此结果与高斯定律给出的精确理论值进行比较。\n\n位于位置 $\\mathbf{r}_0 = (x_q, y_q, z_q)$ 的点电荷 $q$ 产生的电场 $\\mathbf{E}$ 由库仑定律给出：\n$$\n\\mathbf{E}(\\mathbf{r}) = k_e q \\frac{\\mathbf{r} - \\mathbf{r}_0}{\\lVert \\mathbf{r} - \\mathbf{r}_0 \\rVert^3}\n$$\n其中 $\\mathbf{r}=(x,y,z)$ 是观察点，$k_e = \\frac{1}{4\\pi\\varepsilon_0}$ 是库仑常数，$\\varepsilon_0$ 是真空介电常数。\n\n通过闭合曲面 $S$ 的总电通量 $\\Phi$ 是电场的曲面积分：\n$$\n\\Phi = \\iint_S \\mathbf{E} \\cdot d\\mathbf{A}\n$$\n在此问题中，曲面 $S$ 是一个边长为 $L$、中心位于 $\\mathbf{c} = (c_x, c_y, c_z)$ 的坐标轴对齐立方体。这个闭合曲面由六个平面组成。总通量是穿过这六个面的通量之和：\n$$\n\\Phi = \\sum_{i=1}^{6} \\Phi_i = \\sum_{i=1}^{6} \\iint_{S_i} \\mathbf{E} \\cdot d\\mathbf{A}_i\n$$\n其中 $S_i$ 是第 $i$ 个面的曲面。\n\n要计算通过单个面的通量，我们必须定义被积函数 $\\mathbf{E} \\cdot d\\mathbf{A}$ 和积分限。让我们考虑一个通用面。对于坐标轴对齐的立方体，每个面都由一个恒定坐标（例如，$x = c_x + L/2$）定义，并有一个与某个坐标轴平行的向外法向量 $\\mathbf{\\hat{n}}$。微分面积元为 $d\\mathbf{A} = \\mathbf{\\hat{n}} \\, du \\, dv$，其中 $u$ 和 $v$ 是跨越该平面的两个积分变量。那么，通过这个面的通量是：\n$$\n\\Phi_i = \\iint_{S_i} (\\mathbf{E} \\cdot \\mathbf{\\hat{n}}) \\, du \\, dv\n$$\n被积函数 $\\mathbf{E} \\cdot \\mathbf{\\hat{n}}$ 可以更明确地表示。代入 $\\mathbf{E}(\\mathbf{r})$ 的表达式：\n$$\n\\mathbf{E}(\\mathbf{r}(u,v)) \\cdot \\mathbf{\\hat{n}} = k_e q \\frac{(\\mathbf{r}(u,v) - \\mathbf{r}_0) \\cdot \\mathbf{\\hat{n}}}{\\lVert \\mathbf{r}(u,v) - \\mathbf{r}_0 \\rVert^3}\n$$\n其中 $\\mathbf{r}(u,v)$ 是面 $S_i$ 上一点的位置矢量。例如，对于位于 $x = c_x + L/2$ 的面，法线是 $\\mathbf{\\hat{n}}=(1,0,0)$，积分变量是 $(u,v)=(y,z)$，位置矢量是 $\\mathbf{r}(y,z) = (c_x + L/2, y, z)$。$y$ 和 $z$ 的积分限分别为 $[c_y - L/2, c_y + L/2]$ 和 $[c_z - L/2, c_z + L/2]$。这个公式被系统地应用于所有六个面。\n\n每个二维积分 $\\Phi_i$ 的计算都是使用自适应求积算法进行数值计算的。`scipy.integrate.dblquad` 函数适合此目的。该函数通过迭代地细化网格，以在矩形域上对给定的二维函数积分达到期望的精度。由于问题陈述保证电荷 $q$ 绝不会恰好位于曲面 $S$ 上，因此被积函数在每个面 $S_i$ 上都是连续且行为良好的，从而确保了数值积分的可靠性。\n\n总通量的数值结果 $\\Phi_{\\text{numerical}} = \\sum_i \\Phi_i$，然后与高斯定律给出的精确理论值 $\\Phi_{\\text{exact}}$ 进行比较：\n$$\n\\Phi_{\\text{exact}} = \\frac{q_{\\text{enclosed}}}{\\varepsilon_0}\n$$\n为了确定 $q_{\\text{enclosed}}$，我们执行一个简单的几何包含测试。当且仅当电荷 $q$ 的坐标 $(x_q, y_q, z_q)$ 严格位于立方体体积内时，该电荷被包围，因此 $q_{\\text{enclosed}} = q$。该条件可正式表示为：\n$$\n(c_x - L/2  x_q  c_x + L/2) \\land (c_y - L/2  y_q  c_y + L/2) \\land (c_z - L/2  z_q  c_z + L/2)\n$$\n如果不满足此条件，则电荷在立方体外部，且 $q_{\\text{enclosed}} = 0$。\n\n最后，计算数值计算通量与精确通量之间的绝对误差 $\\Delta$，以评估我们数值方法的准确性：\n$$\n\\Delta = \\lvert \\Phi_{\\text{numerical}} - \\Phi_{\\text{exact}} \\rvert\n$$\n对问题中指定的每个测试用例都应用此过程。所得误差 $\\Delta$ 量化了我们对通量基本定义的数值积分与高斯定律强大而简洁的陈述的吻合程度。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import dblquad\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    # Physical constants in SI units\n    EPSILON_0 = 8.8541878128e-12  # Vacuum permittivity in F/m\n    K_E = 1.0 / (4.0 * np.pi * EPSILON_0)  # Coulomb's constant\n\n    # Test suite: (center, side_length, charge_position, charge_magnitude)\n    test_cases = [\n        # Case 1: Charge at center, inside\n        ((0.0, 0.0, 0.0), 2.0, (0.0, 0.0, 0.0), 1.0e-6),\n        # Case 2: Charge outside\n        ((0.0, 0.0, 0.0), 2.0, (3.0, 0.0, 0.0), 1.0e-6),\n        # Case 3: Charge inside, off-center\n        ((0.2, -0.1, 0.3), 1.4, (0.8, -0.1, 0.3), -2.0e-6),\n        # Case 4: Charge inside, near corner\n        ((1.0, 1.0, 1.0), 0.5, (1.1, 1.1, 1.1), 5.0e-7),\n    ]\n\n    results = []\n    for c_tuple, L, r0_tuple, q in test_cases:\n        c = np.array(c_tuple)\n        r0 = np.array(r0_tuple)\n        \n        # Calculate numerical flux by integrating over the six faces\n        numerical_flux = calculate_numerical_flux(c, L, r0, q, K_E)\n        \n        # Determine exact flux from Gauss's Law\n        h = L / 2.0\n        is_inside = (\n            (c[0] - h  r0[0]  c[0] + h) and\n            (c[1] - h  r0[1]  c[1] + h) and\n            (c[2] - h  r0[2]  c[2] + h)\n        )\n        q_enclosed = q if is_inside else 0.0\n        exact_flux = q_enclosed / EPSILON_0\n        \n        # Compute the absolute error\n        error = abs(numerical_flux - exact_flux)\n        \n        # Format result to 6 significant figures in scientific notation\n        # Precision p-1 for p significant digits, so 5 for 6 sig figs.\n        results.append(f\"{error:.5e}\")\n\n    # Print an output line in the required format\n    print(f\"[{','.join(results)}]\")\n\ndef calculate_numerical_flux(c, L, r0, q, K_E):\n    \"\"\"\n    Numerically computes the total electric flux through a cubical surface.\n\n    Args:\n        c (np.ndarray): Center of the cube (cx, cy, cz).\n        L (float): Side length of the cube.\n        r0 (np.ndarray): Position of the point charge (xq, yq, zq).\n        q (float): Magnitude of the point charge.\n        K_E (float): Coulomb's constant.\n\n    Returns:\n        float: The total numerical flux.\n    \"\"\"\n    h = L / 2.0\n    total_flux = 0.0\n\n    # Define the six faces of the cube.\n    # Each tuple contains: (fixed_dim_idx, sign, integration_dims_indices)\n    # fixed_dim_idx: 0 for x, 1 for y, 2 for z\n    # sign: +1 for positive-side face, -1 for negative-side face\n    # integration_dims: indices of the two integration variables\n    faces = [\n        (0,  1, (1, 2)),  # Right face (x = cx + h)\n        (0, -1, (1, 2)),  # Left face  (x = cx - h)\n        (1,  1, (0, 2)),  # Top face   (y = cy + h)\n        (1, -1, (0, 2)),  # Bottom face(y = cy - h)\n        (2,  1, (0, 1)),  # Front face (z = cz + h)\n        (2, -1, (0, 1)),  # Back face  (z = cz - h)\n    ]\n\n    for fixed_dim, sign, int_dims in faces:\n        fixed_coord_val = c[fixed_dim] + sign * h\n        u_idx, v_idx = int_dims\n        \n        u_min, u_max = c[u_idx] - h, c[u_idx] + h\n        v_min, v_max = c[v_idx] - h, c[v_idx] + h\n\n        def integrand(v, u):\n            # `u` and `v` are the integration variables on the face.\n            # dblquad expects the function signature func(inner_var, outer_var)\n            # Here, v is inner, u is outer.\n            r_surf = np.zeros(3)\n            r_surf[fixed_dim] = fixed_coord_val\n            r_surf[u_idx] = u\n            r_surf[v_idx] = v\n            \n            vec_r = r_surf - r0\n            dist_sq = vec_r @ vec_r\n\n            # When the charge is inside the cube, for case 1 it's at the center.\n            # The numerical integrator might try to evaluate at r_surf = r0 on\n            # one of the faces if the charge lies on a face. Problem states this is excluded.\n            # However, for case 1, r0 is (0,0,0) and the faces are at +/-1. No issue.\n            # But if r0 were (1,0,0), it would be on a face. Since this is excluded,\n            # dist_sq on the integration domain is always > 0.\n            if dist_sq  1e-12: # Avoid division by zero for points very close to charge\n                return 0.0\n            \n            dist = np.sqrt(dist_sq)\n\n            # The integrand is the component of E normal to the surface: E . n_hat\n            # E . n_hat = (K_E * q * vec_r / dist^3) . n_hat\n            # vec_r . n_hat is simply the component of vec_r along the normal.\n            vec_r_dot_n_hat = vec_r[fixed_dim] * sign\n            \n            return K_E * q * vec_r_dot_n_hat / (dist**3)\n\n        flux_face, _ = dblquad(\n            integrand,\n            u_min, u_max,       # outer integration limits (u)\n            lambda u: v_min,    # inner integration lower limit (v)\n            lambda u: v_max     # inner integration upper limit (v)\n        )\n        total_flux += flux_face\n\n    return total_flux\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415017"}, {"introduction": "当我们从低维积分转向高维积分时，简单的数值方法会遇到“维度灾难”的挑战，这催生了如VEGAS这样的高级算法。这个练习将挑战你对这类高级算法进行批判性思考，特别是它所依赖的可分离近似。通过分析一个精心设计的思想实验，你将揭示为何不能简单地利用为积分设计的自适应网格来寻找高维非耦合函数的最大值，从而深刻理解算法假设的重要性。[@problem_id:2415025]", "problem": "考虑一个4维空间中的非可分被积函数的积分，\n$$\nI \\;=\\; \\int_{[0,1]^4} f(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}, \\quad \\mathbf{x}=(x_1,x_2,x_3,x_4),\n$$\n其中\n$$\nf(\\mathbf{x}) \\;=\\; \\exp\\!\\left(-\\alpha\\big[(x_1-0.2)^2+(x_2-0.8)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.7)^2+(x_4-0.3)^2\\big]\\right) \\;+\\; \\exp\\!\\left(-\\alpha\\big[(x_1-0.8)^2+(x_2-0.2)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.3)^2+(x_4-0.7)^2\\big]\\right),\n$$\n$\\alpha0$ 和 $\\beta0$ 是固定的常数。一个团队使用 VEGAS 算法（一种采用自适应、可分采样密度的重要性采样蒙特卡洛方法）来估计 $I$。具体来说，VEGAS 通过迭代地构建一维直方图来调整一个可分的采样密度 $g(\\mathbf{x})=\\prod_{i=1}^{4} g_i(x_i)$，这些直方图旨在近似 $|f|$ 沿每个坐标的边缘分布，并在这些边缘分布值较大的地方分配更精细的网格区间。\n\n一名学生建议利用最终的 VEGAS 自适应网格来“定位” $f$ 的“最大值点”，方法是在每个坐标 $x_i$ 上识别出估计权重最大的区间，然后将这4个一维区间中心的笛卡尔积作为 $f$ 在 $[0,1]^4$ 上的最大值点的估计。\n\n下列哪个/哪些陈述是正确的？选择所有适用的选项。\n\nA. 对于一个一般的4维非可分被积函数，一个基于边缘分布的自适应可分网格通常不能仅从网格信息中确定 $f$ 的全局最大值点。\n\nB. 如果 $f(\\mathbf{x})=\\prod_{i=1}^{4} f_i(x_i)$ 并且每个 $f_i$ 在 $[0,1]$ 上是单峰的，那么 $f$ 的全局最大值点是各个 $f_i$ 的逐坐标最大值点构成的元组，并且在有足够多的 VEGAS 样本时，沿每个坐标最密集的区间会收敛到这些坐标。\n\nC. 对于 $[0,1]^4$ 上的任何连续函数 $f$，选择权重最大的一维区间并取其笛卡尔积的任意一个角点，可以得到 $f$ 的最大值点的一个一致估计量。\n\nD. 对于上面给出的特定非可分函数 $f$，组合 $|f|$ 的一维边缘分布的最大值位置可以产生一个点，在该点上 $f$ 不是局部最大值并且其值可能很小，这说明了可分自适应方法的一种失效模式。\n\nE. 在 VEGAS 运行期间从样本中观察到的 $f$ 的最大值是 $f$ 在 $[0,1]^4$ 上真实最大值的一个无偏估计量。", "solution": "对问题陈述进行验证。\n\n**步骤1：提取已知条件**\n- 积分: $I = \\int_{[0,1]^4} f(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$\n- 定义域: $[0,1]^4$，$\\mathbf{x}=(x_1,x_2,x_3,x_4)$ 在4维空间中。\n- 被积函数: $f(\\mathbf{x}) = \\exp\\!\\left(-\\alpha\\big[(x_1-0.2)^2+(x_2-0.8)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.7)^2+(x_4-0.3)^2\\big]\\right) + \\exp\\!\\left(-\\alpha\\big[(x_1-0.8)^2+(x_2-0.2)^2\\big]\\right)\\,\\exp\\!\\left(-\\beta\\big[(x_3-0.3)^2+(x_4-0.7)^2\\big]\\right)$。\n- 常数: $\\alpha0$ 和 $\\beta0$。\n- 算法: VEGAS，它使用一个自适应、可分的采样密度 $g(\\mathbf{x})=\\prod_{i=1}^{4} g_i(x_i)$。\n- 自适应规则: 网格细化基于近似 $|f(\\mathbf{x})|$ 沿每个坐标的一维边缘分布的直方图。\n- 学生的提议: 为了找到 $f$ 的最大值点，应该在4个坐标维度中的每一个维度上识别出权重最大的区间，并取这些区间中心的笛卡尔积。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据**: 该问题在计算物理和数值方法领域有充分的依据。VEGAS 算法是多维积分的标准技术。被积函数虽然是为本问题构造的，但它是一个完全有效、连续的函数。可分性、边缘分布和重要性采样的概念是该领域的基础。\n- **适定性**: 该问题是适定的。它要求对几个关于从 VEGAS 算法派生的信息的特定应用的陈述进行评估。问题清晰，并且基于算法和函数的性质有明确的、逻辑的解答。\n- **客观性**: 问题以精确的数学和算法语言陈述，没有主观性或模糊性。\n\n**步骤3：结论与行动**\n问题陈述在科学上是合理的、自洽的且无歧义的。这是一个有效的问题，需要分析 VEGAS 算法的局限性。我们继续解决它。\n\n核心问题是学生试图使用一个为积分设计的算法来执行优化。具体来说，学生将边缘分布的属性与完整多维函数的属性混为一谈。VEGAS 算法调整一个可分的概率密度 $g(\\mathbf{x}) = \\prod_{i=1}^4 g_i(x_i)$，作为蒙特卡洛积分的重要性函数。自适应过程根据被积函数的边缘投影 $P_i(x_i) = \\int_{[0,1]^3} |f(\\mathbf{x})| \\prod_{j \\neq i} \\mathrm{d}x_j$ 的近似值来细化每个坐标 $x_i$ 的网格。对于非可分函数，在进行这种投影时，变量之间的相关性信息会丢失，而这些信息对于定位最大值点至关重要。\n\n我们来分析给定的被积函数 $f(\\mathbf{x})$。由于 $\\alpha  0$ 和 $\\beta  0$，函数 $f(\\mathbf{x})$ 总是正的，所以 $|f(\\mathbf{x})| = f(\\mathbf{x})$。该函数是两项之和。第一项是一个类高斯函数，在 $\\mathbf{p}_1 = (0.2, 0.8, 0.7, 0.3)$ 处达到峰值。第二项是一个类似的函数，在 $\\mathbf{p}_2 = (0.8, 0.2, 0.3, 0.7)$ 处达到峰值。如果 $\\alpha$ 和 $\\beta$ 足够大，$f(\\mathbf{x})$ 将在 $\\mathbf{p}_1$ 和 $\\mathbf{p}_2$ 处有两个明显且分离良好的最大值。\n\n例如，$x_1$ 的边缘分布将是 $P_1(x_1) = \\int_0^1 \\int_0^1 \\int_0^1 f(x_1, x_2, x_3, x_4) \\mathrm{d}x_2 \\mathrm{d}x_3 \\mathrm{d}x_4$。由于 $f(\\mathbf{x})$ 的结构，这个边缘分布将是双峰的，峰值分别在 $x_1=0.2$（来自第一项）和 $x_1=0.8$（来自第二项）附近。类似地，边缘分布 $P_2(x_2)$ 将是双峰的，峰值在 $x_2=0.2$ 和 $x_2=0.8$ 附近。边缘分布 $P_3(x_3)$ 的峰值在 $x_3=0.3$ 和 $x_3=0.7$ 附近，而 $P_4(x_4)$ 的峰值在 $x_4=0.3$ 和 $x_4=0.7$ 附近。VEGAS 网格将在各自维度上的这八个位置附近变得密集。学生的方法建议组合这些边缘“最大值”的坐标。这将导致 $2^4 = 16$ 个可能的点。其中，只有两个是真正的最大值点：$(0.2, 0.8, 0.7, 0.3)$ 和 $(0.8, 0.2, 0.3, 0.7)$。其他组合，例如 $(0.2, 0.2, 0.3, 0.3)$，对应于 $f(\\mathbf{x})$ 值很小的区域，因为指数的参数不会同时趋于零。\n\n现在我们来评估每个陈述。\n\n**A. 对于一个一般的4维非可分被积函数，一个基于边缘分布的自适应可分网格通常不能仅从网格信息中确定 $f$ 的全局最大值点。**\n这个陈述是正确的。可分网格只考虑了被积函数在每个轴上的投影。它忽略了变量之间的相关性。非可分函数的全局最大值点的位置是完整联合分布的属性，而不是其边缘分布的属性。学生的提议之所以失败，正是因为它假设全局最大值点的坐标是边缘分布的最大值点，这在一般的非可分情况下是错误的。\n**结论：正确。**\n\n**B. 如果 $f(\\mathbf{x})=\\prod_{i=1}^{4} f_i(x_i)$ 并且每个 $f_i$ 在 $[0,1]$ 上是单峰的，那么 $f$ 的全局最大值点是各个 $f_i$ 的逐坐标最大值点构成的元组，并且在有足够多的 VEGAS 样本时，沿每个坐标最密集的区间会收敛到这些坐标。**\n这个陈述是正确的。如果 $f(\\mathbf{x})$ 是可分的，$f(\\mathbf{x}) = \\prod_i f_i(x_i)$，那么寻找 $f$ 的最大值等价于最大化 $\\ln f(\\mathbf{x}) = \\sum_i \\ln f_i(x_i)$。当每一项都单独最大化时，这个和达到最大。因此，$f$ 的最大值点是 $(\\arg\\max_{x_1} f_1(x_1), \\dots, \\arg\\max_{x_4} f_4(x_4))$。对于给定坐标 $x_i$ 的边缘投影是 $P_i(x_i) = \\int f(\\mathbf{x}) \\prod_{j \\neq i} \\mathrm{d}x_j = f_i(x_i) \\prod_{j \\neq i} \\int f_j(x_j) \\mathrm{d}x_j$。由于 $\\prod_{j \\neq i} \\int f_j(x_j) \\mathrm{d}x_j$ 是一个正常数，$P_i(x_i)$ 与 $f_i(x_i)$ 成正比。因此，边缘分布 $P_i(x_i)$ 的最大值与 $f_i(x_i)$ 的最大值出现在相同的坐标上。VEGAS 调整其网格，使其在边缘分布值大的地方变得密集，因此其最密集的区间确实会收敛到 $f_i$ 的最大值点的位置。在这种特殊的可分情况下，学生的方法是可行的。\n**结论：正确。**\n\n**C. 对于 $[0,1]^4$ 上的任何连续函数 $f$，选择权重最大的一维区间并取其笛卡尔积的任意一个角点，可以得到 $f$ 的最大值点的一个一致估计量。**\n这个陈述是错误的。它做出了一个普遍性的声明（“对于任何连续函数 $f$”），这很容易被证伪。正如问题中给出的非可分函数所证明的那样，该方法会失败。从边缘分布的最大值构造出的点通常不是函数本身的最大值点。“一致估计量”必须依概率收敛到真实值。该方法收敛到一个由边缘分布决定的值，而这个值通常不是真正的最大值点。这个说法是公然错误的。\n**结论：错误。**\n\n**D. 对于上面给出的特定非可分函数 $f$，组合 $|f|$ 的一维边缘分布的最大值位置可以产生一个点，在该点上 $f$ 不是局部最大值并且其值可能很小，这说明了可分自适应方法的一种失效模式。**\n这个陈述是正确的。如前所述，边缘分布是双峰的。例如，$P_1(x_1)$ 在 $x_1=0.2$ 和 $x_1=0.8$ 附近有峰值，而 $P_2(x_2)$ 在 $x_2=0.2$ 和 $x_2=0.8$ 附近有峰值。我们通过组合这些峰值位置来构造一个点，例如 $\\mathbf{x}_{\\text{test}} = (0.2, 0.2, 0.7, 0.3)$。在该点计算 $f$ 的值：\n$f(\\mathbf{x}_{\\text{test}}) = \\exp(-\\alpha[0^2 + (-0.6)^2])\\exp(-\\beta[0^2+0^2]) + \\exp(-\\alpha[(-0.6)^2+0^2])\\exp(-\\beta[0.4^2+(-0.4)^2])$\n$f(\\mathbf{x}_{\\text{test}}) = \\exp(-0.36\\alpha) + \\exp(-0.36\\alpha)\\exp(-0.32\\beta)$。\n对于任何显著大于0的 $\\alpha$，这个值都很小。相比之下，在真正的最大值点 $\\mathbf{p}_1=(0.2, 0.8, 0.7, 0.3)$ 处，$f$ 的第一项是 $1$。点 $\\mathbf{x}_{\\text{test}}$ 显然不是一个最大值点，其函数值也很小，这完美地说明了可分方法在非可分问题上的失败。\n**结论：正确。**\n\n**E. 在 VEGAS 运行期间从样本中观察到的 $f$ 的最大值是 $f$ 在 $[0,1]^4$ 上真实最大值的一个无偏估计量。**\n这个陈述是错误的。设 $M = \\sup_{\\mathbf{x} \\in [0,1]^4} f(\\mathbf{x})$。设 $\\mathbf{X}_1, \\dots, \\mathbf{X}_N$ 是从采样分布中抽取的 $N$ 个随机样本。所提出的估计量是 $\\hat{M}_N = \\max_{k=1,\\dots,N} f(\\mathbf{X}_k)$。对于任何样本 $\\mathbf{X}_k$，都有 $f(\\mathbf{X}_k) \\leq M$。因此，$\\hat{M}_N \\leq M$。如果一个估计量的期望等于真实值，即 $E[\\hat{M}_N] = M$，那么它是无偏的。然而，由于 $\\hat{M}_N \\leq M$，我们有 $E[\\hat{M}_N] \\leq M$。等式成立的唯一情况是 $\\hat{M}_N = M$ 的概率为1，但这要求从连续分布中抽取的随机样本恰好命中精确的最大值点，这是一个概率为零的事件。因此，$E[\\hat{M}_N]  M$，这意味着该估计量是有偏的（它系统地低估了最大值）。这是一个被称为最大化偏差的著名现象。\n**结论：错误。**", "answer": "$$\\boxed{ABD}$$", "id": "2415025"}]}