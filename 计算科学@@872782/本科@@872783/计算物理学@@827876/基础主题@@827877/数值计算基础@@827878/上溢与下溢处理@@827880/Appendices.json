{"hands_on_practices": [{"introduction": "高斯分布在科学中无处不在，从量子力学到数据分析都有其身影。然而，直接计算其概率密度函数（PDF）涉及一个指数项 $\\exp(-x^2)$，当 $x$ 较大时，该项会迅速趋近于零，导致数值下溢。本练习将指导您使用对数空间（log-space）这一基本技巧，将乘法和除法转换为加法和减法，从而极大地扩展可计算范围，防止数值错误。[@problem_id:2423348]", "problem": "要求您实现一个数值稳健的程序，用于计算给定参数下的高斯（正态）概率密度函数，同时处理在有限精度算术中可能导致数值下溢或上溢的极端情况。\n\n设高斯概率密度函数为实数 $x$、实数 $\\mu$ 和严格为正的 $\\sigma$ 定义，其公式为\n$$\n\\operatorname{pdf}(x,\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\right).\n$$\n所有计算必须采用电气与电子工程师协会（IEEE）$754$ 标准指定的标准双精度浮点格式。您必须确保以下关于可表示性的输出策略：\n- 如果 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的精确数学值严格小于最小的严格为正的可表示双精度数 $2^{-1074}$，您的程序必须为该测试用例输出浮点值 $0.0$。\n- 如果 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的精确数学值严格大于最大的有限可表示双精度数 $(2-2^{-52})\\times 2^{1023}$，您的程序必须为该测试用例输出对应于正无穷大的浮点值。\n- 否则，您的程序必须以标准双精度输出 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的有限浮点值。\n\n此问题不涉及物理单位。也不使用角度。\n\n测试套件及要求的输出格式：\n- 为以下有序的参数三元组 $(x,\\mu,\\sigma)$ 列表计算 $\\operatorname{pdf}(x,\\mu,\\sigma)$：\n  1. $(0,0,1)$,\n  2. $(8,0,1)$,\n  3. $(38,0,1)$,\n  4. $(40,0,1)$,\n  5. $(0,0,10^{-320})$,\n  6. $(0,0,10^{50})$,\n  7. $\\left(-10^{308},\\,10^{308},\\,1\\right)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与测试套件中的顺序相同，例如 $[r_1,r_2,\\dots,r_7]$，其中每个 $r_k$ 是一个符合上述可表示性策略的浮点数。不要打印任何额外的字符或行。", "solution": "如题所述，问题是实现高斯概率密度函数 $\\operatorname{pdf}(x,\\mu,\\sigma)$ 的数值稳健计算，其公式如下\n$$\n\\operatorname{pdf}(x,\\mu,\\sigma) = \\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^{2}\\right),\n$$\n其中参数 $x$ 和 $\\mu$ 为实值，$\\sigma$ 为严格为正的实数参数。该实现必须正确处理在使用标准双精度浮点算术进行朴素的直接计算时会导致数值上溢或下溢的情况。\n\n该问题具有科学依据，定义明确，客观，并包含了唯一解所需的所有必要信息。这是计算科学中的一个经典问题，展示了维持数值稳定性的基本技术。因此，该问题是有效的，我们着手解决它。\n\n开发稳健算法的基本原则是避免在浮点数范围的极限处可能发生灾难性失败的运算。一个朴素的公式实现会涉及几种这样的潜在失败：\n$1$. 如果 $\\sigma$ 非常小（接近于零），前置因子 $\\frac{1}{\\sigma\\sqrt{2\\pi}}$ 可能会上溢。\n$2$. 如果 $\\sigma$ 非常大，前置因子可能会下溢到 $0.0$，从而丢失所有精度。\n$3$. 如果 $|x-\\mu|$ 很大而 $\\sigma$ 很小，标准化变量 $z = \\frac{x-\\mu}{\\sigma}$ 本身可能会上溢。\n$4$. 如果 $|z|$ 很大，即使 $z$ 本身是可表示的，$z^2$ 项也可能会上溢。\n$5$. 如果 $|z|$ 很大，指数项 $\\exp(-0.5 z^2)$ 可能会下溢到 $0.0$。\n\n为缓解这些问题，我们在对数空间中重新表述计算。这是数值方法中一种标准且强大的技术。我们不直接计算 $\\operatorname{pdf}$，而是先计算其自然对数，我们将其表示为 $L$：\n$$\nL = \\log(\\operatorname{pdf}(x,\\mu,\\sigma)) = \\log\\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{1}{2}z^2\\right)\\right)\n$$\n利用对数的性质，此表达式可简化为各项之和：\n$$\nL = \\log\\left(\\frac{1}{\\sigma\\sqrt{2\\pi}}\\right) + \\log\\left(\\exp\\!\\left(-\\frac{1}{2}z^2\\right)\\right) \\\\\nL = -\\log(\\sigma\\sqrt{2\\pi}) - \\frac{1}{2}z^2 \\\\\nL = -\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi) - \\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2\n$$\n这种表述方式用对数相加代替了前置因子与指数项的相乘。与乘法相比，加法远不容易发生虚假的上溢和下溢，从而扩展了可以计算出有意义结果的输入动态范围。\n\n算法流程如下：\n$1$. 对于给定的参数集 $(x, \\mu, \\sigma)$，我们首先计算对数概率密度函数（log-PDF）$L$ 的各项。常数项 $\\frac{1}{2}\\log(2\\pi)$ 可以预先计算。\n$2$. 我们计算 $\\log(\\sigma)$ 和标准化变量 $z = \\frac{x-\\mu}{\\sigma}$。需要特别注意的是，对于极端值（如测试用例 7），$x-\\mu$ 的中间计算可能会上溢。然而，在 `numpy` 中实现的 IEEE $754$ 算术通过传播无穷大（`inf`）来正确处理这种情况。例如，如果 $x-\\mu$ 上溢到 $-\\infty$，那么 $z$ 会变成 $-\\infty$，$z^2$ 会变成 $+\\infty$，指数项 $-0.5z^2$ 会变成 $-\\infty$，总的对数概率密度函数 $L$ 也会变成 $-\\infty$。这导致最终结果为 $\\exp(-\\infty) = 0.0$，这是数学上正确的极限。因此，不需要对 $z^2$ 的上溢进行特殊检查，因为标准的 `inf` 传播会正确处理它。\n$3$. 然后我们计算总的对数概率密度函数：$L = (-\\log(\\sigma) - \\frac{1}{2}\\log(2\\pi)) - \\frac{1}{2}z^2$。\n$4$. 在通过指数运算计算最终结果之前，我们必须将 $L$ 与同样转换到对数空间的指定阈值进行比较。问题根据双精度数的限制定义了上溢和下溢的边界。\n    - **上溢条件**：如果结果严格大于最大的有限双精度数 $D_{\\text{max}} = (2-2^{-52})\\times 2^{1023}$，则发生上溢。这等效于检查 $L  \\log(D_{\\text{max}})$。如果满足此条件，函数必须返回正无穷大。\n    - **下溢条件**：如果结果严格小于最小的正（非规格化）双精度数 $D_{\\text{min\\_sub}} = 2^{-1074}$，则发生下溢。这等效于检查 $L  \\log(D_{\\text{min\\_sub}}) = -1074\\log(2)$。如果满足此条件，函数必须返回 $0.0$。\n$5$. 如果 $L$ 落在两个对数阈值之间，则结果是数值上可表示且计算稳定的。然后我们计算最终的 PDF 值为 $\\exp(L)$。\n\n这种基于对数计算原理的设计，确保了实现是稳健、准确的，并遵守了处理极端数值的指定策略。它能正确处理所有测试用例，从标准输入到那些旨在导致朴素实现中发生上溢或下溢的用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef robust_gaussian_pdf(x: float, mu: float, sigma: float) - float:\n    \"\"\"\n    Computes the Gaussian probability density function in a numerically robust way.\n\n    Args:\n        x: The point at which to evaluate the PDF.\n        mu: The mean of the distribution.\n        sigma: The standard deviation of the distribution (must be  0).\n\n    Returns:\n        The value of the PDF, handling overflow and underflow per IEEE 754 spec.\n    \"\"\"\n    # Pre-calculated constant for efficiency and clarity.\n    # log(sqrt(2*pi))\n    LOG_SQRT_2PI = 0.5 * np.log(2.0 * np.pi)\n\n    # Thresholds for overflow and underflow in log-space, as per the problem.\n    # log(DBL_MAX)\n    LOG_MAX_FLOAT = np.log(np.finfo(np.double).max)\n    # log(2**-1074)\n    LOG_MIN_SUBNORMAL = -1074.0 * np.log(2.0)\n\n    # Per the problem statement, sigma is strictly positive. A check for sigma = 0\n    # would be good practice in a general-purpose library, but it is not\n    # required for the given test suite.\n    \n    # Standardized variable z. Numpy's handling of large numbers will correctly\n    # propagate 'inf' if (x - mu) overflows, which leads to the correct\n    # final result of 0.0.\n    z = (x - mu) / sigma\n    \n    # Calculate the PDF in log-space to prevent intermediate over/underflow.\n    # log(pdf) = -log(sigma) - log(sqrt(2*pi)) - 0.5 * z**2\n    log_pdf = -np.log(sigma) - LOG_SQRT_2PI - 0.5 * z**2\n    \n    # Check against the specified representability thresholds.\n    if log_pdf  LOG_MAX_FLOAT:\n        return np.inf\n    \n    if log_pdf  LOG_MIN_SUBNORMAL:\n        return 0.0\n        \n    # If within representable range, compute the final value.\n    return np.exp(log_pdf)\n\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.0, 1.0),\n        (8.0, 0.0, 1.0),\n        (38.0, 0.0, 1.0),\n        (40.0, 0.0, 1.0),\n        (0.0, 0.0, 1e-320),\n        (0.0, 0.0, 1e50),\n        (-1e308, 1e308, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        x_val, mu_val, sigma_val = case\n        result = robust_gaussian_pdf(x_val, mu_val, sigma_val)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The default string conversion for floats, including 'inf', is correct here.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solution.\nsolve()\n```", "id": "2423348"}, {"introduction": "在模拟随机过程（如随机游走）时，我们常常需要计算组合概率。这其中涉及的二项式系数，如 $\\binom{N}{k}$，会随着 $N$ 的增大而急剧增长，迅速超出标准浮点数的表示范围，导致数值上溢。本练习将扩展对数空间的概念，介绍对数伽马函数（log-gamma function），这是一个在处理大规模模拟中的阶乘和组合问题时，确保计算稳健性的强大工具。[@problem_id:2423389]", "problem": "您需要编写一个完整的程序，用于计算在一维离散时间格点随机游走中，经过给定步数后位于指定位置的概率。在每个时间步，位置以概率 $p$ 变化 $+1$，以概率 $1-p$ 变化 $-1$。设 $X_N$ 表示从第 $0$ 步的原点开始，经过 $N$ 步后的位置。对于给定的三元组 $(N,x,p)$，其中 $N \\in \\mathbb{Z}_{\\ge 0}$，$x \\in \\mathbb{Z}$ 且 $p \\in [0,1]$，计算概率 $\\mathbb{P}(X_N = x)$。您的程序必须能稳健地处理在计算组合项和幂时出现的上溢和下溢，并且当最终概率在双精度浮点运算中发生下溢时，必须返回 $0.0$。\n\n必须根据第一性原理强制执行以下条件：\n- 如果 $|x|  N$，则该事件不可能发生，概率必须为 $0.0$。\n- 如果 $N + x$ 为奇数，则该事件不可能发生，概率必须为 $0.0$。\n- 对于边界情况 $p = 0$ 和 $p = 1$，确切的概率是明确定义的：当 $p = 0$ 时，当且仅当 $x = -N$ 时概率为 $1.0$，否则为 $0.0$；当 $p = 1$ 时，当且仅当 $x = +N$ 时概率为 $1.0$，否则为 $0.0$。\n\n不涉及物理单位。所有答案都必须以无量纲实数的形式返回。不使用角度。\n\n您的程序必须为以下每个测试用例评估概率，并汇总结果：\n- $(N,x,p) = (\\,10,\\,2,\\,0.5\\,)$\n- $(N,x,p) = (\\,9,\\,2,\\,0.5\\,)$\n- $(N,x,p) = (\\,1000,\\,1000,\\,0.5\\,)$\n- $(N,x,p) = (\\,5000,\\,5000,\\,0.5\\,)$\n- $(N,x,p) = (\\,1000000,\\,0,\\,0.5\\,)$\n- $(N,x,p) = (\\,200000,\\,200,\\,0.501\\,)$\n- $(N,x,p) = (\\,1000,\\, -1000,\\, 1.0\\times 10^{-12}\\,)$\n- $(N,x,p) = (\\,1000,\\, 1000,\\, 1.0\\times 10^{-12}\\,)$\n- $(N,x,p) = (\\,50,\\, 50,\\, 1.0\\,)$\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的列表，包含与上述顺序相同的 $9$ 个概率值。\n- 每个概率值都必须采用科学记数法格式，小数点后恰好有 $12$ 位有效数字，例如：$[\\,1.234000000000e-02,\\ldots\\,]$。\n- 输出中不允许有额外的文本或换行。", "solution": "所述问题是有效的。它在科学上基于概率论和统计力学的原理，特别是支配离散时间随机游走的二项分布。该问题是适定的、客观的，并包含获得唯一解所需的所有信息。其核心挑战在于计算，涉及处理数值上溢和下溢，这是计算物理学中的一个标准课题。\n\n我们的任务是计算一维随机游走从原点 $X_0 = 0$ 开始，经过 $N$ 步后到达位置 $x$ 的概率 $\\mathbb{P}(X_N = x)$。在每一步中，位置以概率 $p$ 变化 $+1$，以概率 $q = 1-p$ 变化 $-1$。\n\n设 $N_+$ 为向右的步数（位置增加 $1$），$N_-$ 为向左的步数（位置减少 $1$）。总步数为 $N$。\n$$N_+ + N_- = N$$\n最终位置 $x$ 由向右和向左的步数之差给出。\n$$N_+ - N_- = x$$\n这个二元线性方程组可以求解 $N_+$ 和 $N_-$。将两个方程相加得到 $2N_+ = N+x$，用第一个方程减去第二个方程得到 $2N_- = N-x$。因此，我们有：\n$$N_+ = \\frac{N+x}{2}$$\n$$N_- = \\frac{N-x}{2}$$\n为使 $N_+$ 和 $N_-$ 成为有效的计数，它们必须是非负整数。这带来了两个基本约束：\n1.  奇偶性约束：和 $N+x$（以及差 $N-x$）必须是偶数。如果 $N+x$ 是奇数，则不可能在 $N$ 步内到达位置 $x$，因此概率为 $0$。这等价于 $N$ 和 $x$ 必须具有相同的奇偶性。\n2.  边界约束：任一方向的步数都不能为负。这要求 $N+x \\ge 0$ 和 $N-x \\ge 0$，这等价于 $|x| \\le N$。如果目标位置 $x$ 距离原点的距离超过步数 $N$，则这是一个不可能事件，概率为 $0$。\n\n如果满足这些条件，问题就等同于在 $N$ 次伯努利试验中获得恰好 $N_+$ 次成功的概率，其中成功（向右一步）的概率为 $p$。这由二项分布描述。导致到达位置 $x$ 的不同路径数是从总共 $N$ 步中选择 $N_+$ 步向右的方式数，由二项式系数 $\\binom{N}{N_+}$ 给出。任何一条这样的路径的概率是 $p^{N_+} (1-p)^{N_-}$。\n\n因此，总概率为：\n$$\\mathbb{P}(X_N = x) = \\binom{N}{N_+} p^{N_+} (1-p)^{N_-}$$\n代入 $N_+$ 和 $N_-$ 的表达式：\n$$\\mathbb{P}(X_N = x) = \\binom{N}{(N+x)/2} p^{(N+x)/2} (1-p)^{(N-x)/2}$$\n\n对于大的 $N$，直接计算该公式在数值上是不稳定的。二项式系数中的阶乘项（例如 $N!$）和幂项（例如 $p^{N_+}$）会迅速超过标准浮点表示的极限，导致上溢或下溢。\n\n正确且稳健的计算策略是处理概率的对数。设 $P = \\mathbb{P}(X_N = x)$。我们计算 $\\ln(P)$：\n$$\\ln(P) = \\ln\\left(\\binom{N}{N_+}\\right) + N_+\\ln(p) + N_-\\ln(1-p)$$\n二项式系数的对数可以使用对数伽马函数 $\\ln(\\Gamma(z))$ 来表示，因为 $\\Gamma(k+1) = k!$。\n$$\\ln\\left(\\binom{N}{k}\\right) = \\ln(N!) - \\ln(k!) - \\ln((N-k)!) = \\ln(\\Gamma(N+1)) - \\ln(\\Gamma(k+1)) - \\ln(\\Gamma(N-k+1))$$\n这是一个数值稳定的计算，由标准科学库提供，例如 `scipy.special.gammaln`。\n\n对数概率的最终表达式是：\n$$\\ln(P) = \\ln(\\Gamma(N+1)) - \\ln(\\Gamma(N_++1)) - \\ln(\\Gamma(N_-+1)) + N_+\\ln(p) + N_-\\ln(1-p)$$\n为了在 $p$ 非常小时提高数值精度，项 $\\ln(1-p)$ 应使用 `log1p` 函数计算，即 `log1p(-p)`。\n\n总体算法如下：\n1.  验证输入 $(N, x, p)$。检查基本条件：如果 $|x|  N$ 或 $(N+x)$ 为奇数，则概率恰好为 $0$。\n2.  处理 $p$ 的边界情况。\n    - 如果 $p=0$，则游走是确定性地向左。如果 $x = -N$，概率为 $1$，否则为 $0$。\n    - 如果 $p=1$，则游走是确定性地向右。如果 $x = N$，概率为 $1$，否则为 $0$。\n3.  如果 $0  p  1$，计算 $N_+ = (N+x)/2$ 和 $N_- = (N-x)/2$。\n4.  使用对数伽马公式计算对数概率 $\\ln(P)$。\n5.  通过对结果取指数来获得最终概率：$P = \\exp(\\ln(P))$。此操作能正确处理下溢：如果 $\\ln(P)$ 是一个大的负数，$\\exp(\\ln(P))$ 将在双精度算术中正确地计算为 $0.0$。\n\n此过程确保了对各种参数（包括那些会导致朴素实现失败的参数）进行数值稳定和正确的评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import gammaln\n\ndef calculate_probability(N, x, p):\n    \"\"\"\n    Computes the probability of being at position x after N steps of a 1D random walk.\n\n    Args:\n        N (int): The total number of steps.\n        x (int): The final position.\n        p (float): The probability of stepping to the right (+1).\n\n    Returns:\n        float: The probability P(X_N = x).\n    \"\"\"\n    # Step 1: Validate inputs and check for impossible events.\n    # The parity of position x must match the parity of the number of steps N.\n    # This is equivalent to N+x (and N-x) being even.\n    if (N + x) % 2 != 0:\n        return 0.0\n    \n    # The final position cannot be further from the origin than the number of steps.\n    if abs(x)  N:\n        return 0.0\n\n    # Step 2: Handle boundary cases for probability p.\n    if p == 0.0:\n        return 1.0 if x == -N else 0.0\n    \n    if p == 1.0:\n        return 1.0 if x == N else 0.0\n\n    # Step 3: Calculate the number of right (+) and left (-) steps.\n    # These are guaranteed to be integers due to the parity check above.\n    n_plus = (N + x) // 2\n    n_minus = N - n_plus\n\n    # Step 4: Compute the log-probability to avoid overflow/underflow.\n    # The formula is: log(P) = log(C(N, n_plus)) + n_plus*log(p) + n_minus*log(1-p)\n    # The log-combinatorial term log(C(N, k)) is calculated using log-gamma functions:\n    # log(C(N, k)) = gammaln(N+1) - gammaln(k+1) - gammaln(N-k+1)\n    \n    log_comb_term = gammaln(N + 1) - gammaln(n_plus + 1) - gammaln(n_minus + 1)\n    \n    # The log-probability term is calculated using np.log and np.log1p for accuracy.\n    # np.log1p(y) calculates log(1+y) accurately for small y.\n    # Here, log(1-p) is log1p(-p).\n    log_p_term = n_plus * np.log(p) + n_minus * np.log1p(-p)\n    \n    log_prob = log_comb_term + log_p_term\n\n    # Step 5: Exponentiate to get the final probability.\n    # np.exp will handle underflow by returning 0.0 for very negative inputs.\n    return np.exp(log_prob)\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (10, 2, 0.5),\n        (9, 2, 0.5),\n        (1000, 1000, 0.5),\n        (5000, 5000, 0.5),\n        (1000000, 0, 0.5),\n        (200000, 200, 0.501),\n        (1000, -1000, 1.0e-12),\n        (1000, 1000, 1.0e-12),\n        (50, 50, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, x, p = case\n        result = calculate_probability(int(N), int(x), float(p))\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # e.g., [1.234000000000e-02,...]\n    formatted_results = [f'{r:.12e}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2423389"}, {"introduction": "现代统计力学允许我们将非平衡过程与平衡性质联系起来，例如在单分子拉伸实验中。Jarzynski 等式涉及对功（work）的指数进行平均，这种计算极易被最小的功值所主导，并且容易发生数值下溢。这个高级实践介绍了“log-sum-exp”技巧，这是一种至关重要的数值稳定技术，用于对指数分布进行统计平均，确保所有数据点都能对结果做出有意义的贡献。[@problem_id:2935883]", "problem": "给定从重复的快速拉伸实验中收集的、用于解折叠单个蛋白质结构域的独立非平衡机械功样本集合。每个功样本以皮牛顿-纳米（picoNewton-nanometer）为单位，按每分子报告。温度以开尔文（Kelvin）为单位给出。你的任务是实现一个程序，从平衡态统计力学的第一性原理和微观可逆性出发，使用连接功的指数平均值与平衡自由能差的非平衡功关系，推导出折叠态和解折叠态之间平衡亥姆霍兹自由能差的估计量。然后，你必须将此估计量应用于提供的测试套件，并报告数值答案。\n\n你可以使用的基本原理：\n- 正则系综：对于一个温度为 $T$ 的系统，其亥姆霍兹自由能为 $F=-k_{\\mathrm{B}} T \\ln Z$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$Z$ 是正则配分函数。\n- 微观可逆性与已建立的非平衡功关系：在固定协议下，对多次实现的非平衡功进行指数平均，其结果与初始态和末态之间的平衡自由能差相关。\n- 功是路径依赖的，但平衡自由能差是一个状态函数。\n\n实现约束：\n- 使用 $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $N_{\\mathrm{A}}=6.02214076\\times 10^{23}\\ \\mathrm{mol^{-1}}$。\n- 使用 $1\\ \\mathrm{pN\\cdot nm}=10^{-21}\\ \\mathrm{J}$ 将每个功 $W$ 从皮牛顿-纳米（picoNewton-nanometer）转换为焦耳（Joule）。\n- 温度 $T$ 以开尔文（Kelvin）为单位给出。\n- 为在平均指数时保证数值稳定性，请设计你的计算，通过在取对数前对指数进行适当的重标度，来避免当 $W$ 为大的正数时发生下溢；不要直接对大的负参数进行朴素的指数计算。\n- 对于每个测试用例，使用你的估计量计算每摩尔的平衡解折叠自由能差 $\\Delta F$（单位为千焦每摩尔），并报告一个四舍五入到三位小数的浮点数。\n\n角度单位不适用。如果在你的内部推导中出现任何分数，你的程序仍应按规定输出一个浮点数。\n\n测试套件：\n- 案例 $1$：$T=298\\ \\mathrm{K}$，功样本（单位：$\\mathrm{pN\\cdot nm}$）：\n  $[247.0,255.3,260.1,241.5,252.8,249.2,258.9,243.6,251.0,246.8,262.4,239.7,254.1,248.5,257.3,244.9,250.6,263.0,242.1,256.0]$。\n- 案例 $2$：$T=310\\ \\mathrm{K}$，功样本（单位：$\\mathrm{pN\\cdot nm}$）：\n  $[124.0,126.1,122.5,125.3,127.0,123.8,124.7,125.9,126.4,123.2,124.5,125.1,126.0,123.9,124.8]$。\n- 案例 $3$：$T=298\\ \\mathrm{K}$，功样本（单位：$\\mathrm{pN\\cdot nm}$）：\n  $[420.5,395.2,410.1,505.3,460.7,442.8,487.6,378.4,455.9,468.2,499.1,389.3,472.5,361.7,435.0,481.2,352.6,460.3,341.9,492.7,227.8,243.5,269.1,312.4,285.0,301.6,520.3,476.9,458.7,440.2,355.5,330.8,290.4,275.2,261.9,240.3,510.8,497.0,482.6,466.4]$。\n- 案例 $4$：$T=298\\ \\mathrm{K}$，功样本（单位：$\\mathrm{pN\\cdot nm}$）：\n  $[260.0,310.0,280.0]$。\n\n答案所需单位：\n- 以 $\\mathrm{kJ\\,mol^{-1}}$ 为单位报告每摩尔的 $\\Delta F$，每个结果四舍五入到三位小数。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表，按上述案例的顺序排列结果，例如 $[\\text{结果}_1,\\text{结果}_2,\\text{结果}_3,\\text{结果}_4]$，其中每个 $\\text{结果}_i$ 是一个单位为 $\\mathrm{kJ\\,mol^{-1}}$ 且小数点后有三位数字的浮点数。", "solution": "我们从正则系综开始，其中亥姆霍兹自由能为 $F=-k_{\\mathrm{B}} T \\ln Z$，其中 $k_{\\mathrm{B}}$ 是玻尔兹曼常数，$T$ 是绝对温度，$Z$ 是正则配分函数。对于一个通过驱动协议将初始平衡态转变为末态平衡态的解折叠过程，其平衡自由能差为 $\\Delta F=F_{\\text{final}}-F_{\\text{initial}}$。\n\n微观可逆性和哈密顿动力学是一类非平衡功关系的基础，这些关系将不可逆功的测量值与平衡自由能差联系起来。对于从同一初始平衡态开始并重复多次的固定协议，对各次实现的功进行指数平均，即可得到平衡自由能差。具体来说，如果 $W$ 表示某次实现过程中的机械功，且 $\\beta=(k_{\\mathrm{B}} T)^{-1}$，那么非平衡功关系表明，$W$ 的指数平均值包含了 $\\Delta F$ 的信息。根据此关系以及期望作为样本平均极限的定义，通过将系综平均替换为指数的样本均值，然后取适当的对数并乘以 $k_{\\mathrm{B}} T$，可以得到一个基于 $N$ 个观测功 $\\{W_i\\}_{i=1}^N$ 的一致性有限样本估计量。\n\n具体来说，对于给定的集合 $\\{W_i\\}_{i=1}^N$、温度 $T$ 以及 $\\beta=(k_{\\mathrm{B}} T)^{-1}$，其估计量为\n$$\n\\hat{\\Delta F}=-k_{\\mathrm{B}} T \\ln\\left(\\frac{1}{N}\\sum_{i=1}^N e^{-\\beta W_i}\\right).\n$$\n该公式是通过结合以下几点得出的：(i) 自由能的正则定义，(ii) 微观可逆性导出连接 $W$ 的指数平均与 $\\Delta F$ 的非平衡功关系，以及 (iii) 用样本平均替换系综平均以生成一个可计算的估计量。当 $N \\to \\infty$ 时，该估计量是渐近无偏的，尽管对于有限的 $N$，它可能表现出偏差，这种偏差会随着低功值实现的出现而减小。\n\n数值稳定性：当 $W_i$ 以 $k_{\\mathrm{B}} T$ 为单位是大的正数时，直接计算 $e^{-\\beta W_i}$ 可能会导致下溢。为避免下溢，我们使用一种重标度的对数-求和-指数（log-sum-exp）计算方法。定义 $a_i=-\\beta W_i$，并令 $a_{\\max}=\\max_i a_i$。那么\n$$\n\\frac{1}{N}\\sum_{i=1}^N e^{a_i}=e^{a_{\\max}} \\cdot \\frac{1}{N}\\sum_{i=1}^N e^{a_i-a_{\\max}},\n$$\n于是\n$$\n\\ln\\left(\\frac{1}{N}\\sum_{i=1}^N e^{a_i}\\right)=a_{\\max}+\\ln\\left(\\frac{1}{N}\\sum_{i=1}^N e^{a_i-a_{\\max}}\\right).\n$$\n因此，\n$$\n\\hat{\\Delta F}=-k_{\\mathrm{B}} T \\left[a_{\\max}+\\ln\\left(\\frac{1}{N}\\sum_{i=1}^N e^{a_i-a_{\\max}}\\right)\\right].\n$$\n由于 $a_i-a_{\\max}\\le 0$，内部的指数项有界（不大于1），因而在数值上是安全的。\n\n单位与转换：\n- 输入的功以皮牛顿-纳米（picoNewton-nanometer）为单位，按每分子计算。使用 $1\\ \\mathrm{pN\\cdot nm}=10^{-21}\\ \\mathrm{J}$ 将其转换为焦耳/分子。\n- 使用 $k_{\\mathrm{B}}=1.380649\\times 10^{-23}\\ \\mathrm{J\\,K^{-1}}$ 和 $N_{\\mathrm{A}}=6.02214076\\times 10^{23}\\ \\mathrm{mol^{-1}}$。\n- 在以焦耳/分子为单位计算出 $\\hat{\\Delta F}$ 后，通过以下方式转换为千焦/摩尔：\n$$\n\\hat{\\Delta F}\\ (\\mathrm{kJ\\,mol^{-1}})=\\frac{\\hat{\\Delta F}\\ (\\mathrm{J\\ per\\ molecule})\\times N_{\\mathrm{A}}}{1000}.\n$$\n\n每个测试用例的算法：\n1. 读取温度 $T$（开尔文）和功样本 $\\{W_i^{\\mathrm{(pN\\cdot nm)}}\\}$。\n2. 将 $W_i$ 转换为焦耳：$W_i^{\\mathrm{(J)}}=W_i^{\\mathrm{(pN\\cdot nm)}}\\times 10^{-21}$。\n3. 计算 $\\beta=(k_{\\mathrm{B}} T)^{-1}$。\n4. 构建 $a_i=-\\beta W_i^{\\mathrm{(J)}}$。\n5. 计算 $a_{\\max}=\\max_i a_i$。\n6. 计算 $\\ln M = a_{\\max}+\\ln\\left(\\frac{1}{N}\\sum_{i=1}^N e^{a_i-a_{\\max}}\\right)$。\n7. 计算 $\\hat{\\Delta F}^{\\mathrm{(J)}}=-k_{\\mathrm{B}} T \\cdot \\ln M$。\n8. 使用 $N_{\\mathrm{A}}$ 转换为 $\\mathrm{kJ\\,mol^{-1}}$ 并除以 $1000$。\n9. 四舍五入到三位小数。\n10. 按案例顺序，将四个结果以单行、方括号括起、逗号分隔的形式输出。\n\n测试套件包括：\n- 一个在 $T=298\\ \\mathrm{K}$ 下的典型近可逆集合，其功值约为几十倍 $k_{\\mathrm{B}} T$。\n- 一个在 $T=310\\ \\mathrm{K}$ 下的更高温度、近平衡集合。\n- 一个在 $T=298\\ \\mathrm{K}$ 下的高耗散集合，其分布较宽且包含罕见的低功事件，以确保指数平均的正常收敛。\n- 一个在 $T=298\\ \\mathrm{K}$ 下的小样本边缘案例，用以说明有限样本偏差以及使用最少数据时的数值处理。\n\n程序实现了此过程，并按要求打印结果。", "answer": "```python\nimport numpy as np\n\n# Constants (CODATA exact values where defined)\nk_B = 1.380649e-23          # Boltzmann constant in J/K\nN_A = 6.02214076e23         # Avogadro constant in 1/mol\nPNM_TO_J = 1e-21            # 1 pN*nm in Joule\nJ_TO_KJMOL = N_A / 1000.0   # Convert J per molecule to kJ/mol\n\ndef jarzynski_deltaF_kJ_per_mol(work_pNnm, T_K):\n    \"\"\"\n    Compute Jarzynski estimator of DeltaF from work samples (per molecule) given in pN*nm at temperature T_K.\n    Returns DeltaF in kJ/mol using a numerically stable log-sum-exp computation.\n    \"\"\"\n    W_J = np.array(work_pNnm, dtype=np.float64) * PNM_TO_J  # per molecule in Joule\n    beta = 1.0 / (k_B * T_K)\n    a = -beta * W_J  # exponents\n    a_max = np.max(a)\n    # Compute log of mean exp(a) stably\n    # ln(mean(exp(a))) = a_max + ln(mean(exp(a - a_max)))\n    exp_shifted = np.exp(a - a_max)\n    ln_mean_exp = a_max + np.log(np.mean(exp_shifted))\n    deltaF_J = - (k_B * T_K) * ln_mean_exp  # per molecule in Joule\n    deltaF_kJ_per_mol = deltaF_J * J_TO_KJMOL\n    return float(deltaF_kJ_per_mol)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        {\n            \"T_K\": 298.0,\n            \"work_pNnm\": [\n                247.0, 255.3, 260.1, 241.5, 252.8, 249.2, 258.9, 243.6, 251.0, 246.8,\n                262.4, 239.7, 254.1, 248.5, 257.3, 244.9, 250.6, 263.0, 242.1, 256.0\n            ],\n        },\n        # Case 2\n        {\n            \"T_K\": 310.0,\n            \"work_pNnm\": [\n                124.0, 126.1, 122.5, 125.3, 127.0, 123.8, 124.7, 125.9, 126.4, 123.2,\n                124.5, 125.1, 126.0, 123.9, 124.8\n            ],\n        },\n        # Case 3\n        {\n            \"T_K\": 298.0,\n            \"work_pNnm\": [\n                420.5, 395.2, 410.1, 505.3, 460.7, 442.8, 487.6, 378.4, 455.9, 468.2,\n                499.1, 389.3, 472.5, 361.7, 435.0, 481.2, 352.6, 460.3, 341.9, 492.7,\n                227.8, 243.5, 269.1, 312.4, 285.0, 301.6, 520.3, 476.9, 458.7, 440.2,\n                355.5, 330.8, 290.4, 275.2, 261.9, 240.3, 510.8, 497.0, 482.6, 466.4\n            ],\n        },\n        # Case 4\n        {\n            \"T_K\": 298.0,\n            \"work_pNnm\": [260.0, 310.0, 280.0],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        T_K = case[\"T_K\"]\n        work = case[\"work_pNnm\"]\n        deltaF_kJmol = jarzynski_deltaF_kJ_per_mol(work, T_K)\n        results.append(deltaF_kJmol)\n\n    # Format each result to three decimal places and print as a single line list without spaces\n    formatted = [f\"{x:.3f}\" for x in results]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2935883"}]}