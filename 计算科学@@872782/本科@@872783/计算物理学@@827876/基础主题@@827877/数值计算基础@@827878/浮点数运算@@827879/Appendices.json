{"hands_on_practices": [{"introduction": "我们都熟悉的一元二次方程求根公式在理想的数学世界中是完美的，但在有限精度的计算机中，它的直接应用可能会导致灾难性的精度损失。这个练习将引导你手动模拟浮点运算，亲身体验当两个几乎相等的数字相减时发生的“灾难性抵消”现象，并学习如何通过一个简单的代数变换来稳定计算结果。这项实践对于培养识别和解决数值不稳定性问题的直觉至关重要 ([@problem_id:2393691])。", "problem": "考虑具有实系数的二次多项式 $p(x) = x^2 - 10^8 x + 1$。本问题中的所有算术运算都将在一个标准化的10进制浮点系统中进行，该系统精度为 $t=8$ 位有效数字，舍入规则为“舍入到最近，偶数优先”，并且指数范围足够大，以至于遇到的数值不会发生上溢或下溢。每个基本运算（加、减、乘、除和平方根）都先被精确执行，然后根据所述规则舍入到最接近的可表示浮点数，之后才能用于任何后续计算。\n\n(a) 在此浮点系统中应用标准二次方程求根公式，计算将作为 $p(x)=0$ 的根返回的两个浮点数。\n\n(b) 然后，仅使用对于首一二次方程精确成立的恒等式（特别是，两根之积等于 $c/a$ 这一事实），通过首先在此浮点系统中使用标准二次方程求根公式计算绝对值较大的根，然后使用精确的乘积关系在此浮点系统中获得绝对值较小的根，从而计算出数值稳定的绝对值较小的根的值。\n\n仅报告(b)部分中得到的数值稳定的绝对值较小的根作为你的最终答案，并保留八位有效数字。将你的最终答案表示为科学记数法形式 $a \\times 10^b$，其中 $1 \\leq |a|  10$。", "solution": "该问题要求在一个指定的浮点算术系统内计算一个二次多项式的根。在进行求解之前，我们必须验证问题陈述的有效性。\n\n已知条件如下：\n1.  二次多项式为 $p(x) = x^2 - 10^8 x + 1$。由此，我们确定系数为 $a=1$，$b=-10^8$ 和 $c=1$。\n2.  算术框架是一个标准化的10进制浮点系统。\n3.  精度为 $t=8$ 位有效数字。\n4.  舍入规则为舍入到最近，偶数优先。\n5.  不会发生上溢或下溢。\n6.  每个基本算术运算（$+, -, *, /, \\sqrt{\\cdot}$）都单独进行舍入。\n\n该问题具有科学依据，是数值分析中关于有效数字损失的一个标准练习。它是适定的，所有必要的参数都已定义。它是客观的，其结构是合理的。因此，该问题被认为是有效的。我们开始求解。\n\n二次方程 $ax^2 + bx + c = 0$ 的根由标准二次求根公式给出：\n$$x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n所有计算都在指定的浮点系统中进行，我们用 $fl(\\cdot)$ 表示。\n\n首先，我们计算判别式 $D = b^2 - 4ac$。\n系数为 $a = 1.0000000 \\times 10^0$，$b = -1.0000000 \\times 10^8$ 和 $c = 1.0000000 \\times 10^0$。\n项 $b^2$ 是 $(-10^8)^2 = 10^{16}$。这可以精确表示为 $1.0000000 \\times 10^{16}$。\n项 $4ac$ 是 $4 \\times 1 \\times 1 = 4$。这可以精确表示为 $4.0000000 \\times 10^0$。\n\n我们现在必须计算减法 $fl(b^2 - 4ac) = fl(10^{16} - 4)$。为了执行此操作，较小的数必须移位以匹配较大数的指数。\n$$10^{16} - 4 = (1.0000000 \\times 10^{16}) - (0.0000000000000004 \\times 10^{16})$$\n$10^{16}$ 的尾数是 $1.0000000$。该系统存储 $t=8$ 位有效数字。减去 $4$ 所影响的数字远远超出了系统的精度范围。尾数的减法是 $1.0000000 - 0.0000000000000004$，当舍入回8位有效数字时，结果仍然是 $1.0000000$。这是一个典型的吸收（absorption）例子。\n因此，计算出的判别式是：\n$$\\hat{D} = fl(b^2 - 4ac) = 1.0000000 \\times 10^{16}$$\n接下来，我们计算 $\\hat{D}$ 的平方根。\n$$fl(\\sqrt{\\hat{D}}) = fl(\\sqrt{1.0000000 \\times 10^{16}}) = 1.0000000 \\times 10^8$$\n这是一个精确计算。我们记此结果为 $\\hat{S} = 1.0000000 \\times 10^8$。\n\n现在，我们按照(a)部分的要求计算两个根。\n绝对值较大的根 $\\hat{x}_1$ 使用分子中的“+”号计算，因为 $-b = 10^8$ 是正数。\n$$\\hat{x}_1 = fl\\left(\\frac{-b + \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 + 10^8}{2}\\right) = fl\\left(\\frac{2 \\times 10^8}{2}\\right) = 1.0000000 \\times 10^8$$\n这个计算是数值稳定的，因为它涉及两个数量级相似的正数相加。\n\n绝对值较小的根 $\\hat{x}_2$ 使用“-”号计算。\n$$\\hat{x}_2 = fl\\left(\\frac{-b - \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 - 10^8}{2}\\right) = fl\\left(\\frac{0}{2}\\right) = 0$$\n这个计算会遭受灾难性抵消（catastrophic cancellation）。两个几乎相等的数 $-b$ 和 $\\hat{S}$ 相减，导致有效数字完全丢失。计算出的根 $\\hat{x}_2=0$ 非常不准确。真实的绝对值较小的根约等于 $10^{-8}$。\n\n对于(b)部分，我们被要求使用一种数值稳定的方法。对于一个首一二次方程 $x^2 + \\frac{b}{a}x + \\frac{c}{a} = 0$，韦达定理（Vieta's formulas）指出，两根之积为 $x_1 x_2 = \\frac{c}{a}$。\n在我们的例子中，$a=1$ 且 $c=1$，所以 $x_1 x_2 = 1$。\n\n稳定的步骤是首先计算绝对值较大的根 $\\hat{x}_1$，我们已经发现它是准确的：\n$$\\hat{x}_1 = 1.0000000 \\times 10^8$$\n然后，我们使用乘积关系来找到绝对值较小的根 $\\hat{x}'_2$：\n$$\\hat{x}'_2 = fl\\left(\\frac{c/a}{\\hat{x}_1}\\right)$$\n代入数值：\n$$\\hat{x}'_2 = fl\\left(\\frac{1}{1.0000000 \\times 10^8}\\right) = fl(1.0000000 \\times 10^{-8})$$\n数值 $1.0000000 \\times 10^{-8}$ 在指定的浮点系统中可以被精确表示。因此，计算得出该值，没有任何舍入误差。\n数值稳定的绝对值较小的根是：\n$$\\hat{x}'_2 = 1.0000000 \\times 10^{-8}$$\n此值即为最终答案，要求用科学记数法表示，并保留八位有效数字。", "answer": "$$\\boxed{1.0000000 \\times 10^{-8}}$$", "id": "2393691"}, {"introduction": "在对大量数字进行求和时，尤其是当这些数字的量级差异巨大时，简单的累加方法会遇到一个被称为“大数吃小数”（swamping）的问题，导致微小但重要的值被忽略。这个练习将通过对比朴素求和与 Kahan 补偿求和算法，来展示如何有效减少累积的舍入误差。通过编程实现这两种算法，你将直观地看到补偿求和在保持高精度方面的巨大优势 ([@problem_id:2393714])。", "problem": "本题要求您通过对比朴素递加求和与一种补偿求和方法，来研究浮点数加法中舍入误差的累积。您必须实现一个完整的、可运行的程序。该程序针对一个固定的测试集，计算朴素浮点和与使用 Kahan 求和算法的补偿和，并将两者与使用精确有理数算术计算的高精度参考值进行比较。您的程序不得读取任何输入，且必须按照下述格式打印单行输出。\n\n所使用的基本原理是采用“四舍五入到最近值”的浮点运算标准舍入误差模型：对于任意两个实数 $a$ 和 $b$，其计算出的浮点加法满足 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta|\\le u$，$u$ 是所选格式的单位舍入误差。您也可以利用以下事实：对 $n$ 个项进行朴素求和，在最坏情况下会累积 $O(nu)$ 数量级的舍入误差，而补偿求和技术旨在通过显式地处理因舍入而丢失的低位比特来减少主阶误差的累积。\n\n要求：\n- 实现两个对双精度实数列表进行操作的求和例程：\n  - 一个朴素求和，对每一项 $x_i$ 通过 $s \\leftarrow s + x_i$ 迭代更新一个累加和。\n  - 一个 Kahan 补偿求和，使用一个补偿变量来结转每次加法中丢失的低位信息。\n- 为了得到高精度参考值，请使用精确有理数算术计算每个列表的精确和（例如，使用一种有理数类型，将每一项 $x_i$ 表示为一个分数并进行精确求和）。该参考值作为实数算术中的“真实值”。\n\n测试集：\n- 使用以下四个测试用例，每个用例都指定为一个有序列表。每个列表都包含大数量级的项和小数量级的项，以暴露灾难性抵消和有效位损失问题。\n  1. $[\\,10^{16},\\,1,\\,-10^{16}\\,]$。\n  2. $[\\,10^{16},\\,\\underbrace{1,\\,1,\\,\\dots,\\,1}_{100000\\ \\text{次}},\\,-10^{16}\\,]$。其精确数学和为 $100000$。\n  3. $[\\,1,\\underbrace{10^{-16},\\,10^{-16},\\,\\dots,\\,10^{-16}}_{100000\\ \\text{次}},\\,-1\\,]$。其精确数学和为 $100000\\cdot 10^{-16}=10^{-11}$。\n  4. $[\\,10^{16},\\,\\underbrace{10^{-6},\\,10^{-6},\\,\\dots,\\,10^{-6}}_{100000\\ \\text{次}},\\,-10^{16}\\,]$。其精确数学和为 $100000\\cdot 10^{-6}=10^{-1}$。\n\n计算与比较：\n- 对每个测试用例，计算：\n  - 朴素浮点和 $s_{\\text{naive}}\\in\\mathbb{R}$。\n  - Kahan 浮点和 $s_{\\text{kahan}}\\in\\mathbb{R}$。\n  - 使用精确有理数算术的精确参考和 $s_{\\star}\\in\\mathbb{R}$。\n- 对每个测试用例，计算绝对误差 $e_{\\text{naive}}=\\lvert s_{\\text{naive}}-s_{\\star}\\rvert$ 和 $e_{\\text{kahan}}=\\lvert s_{\\text{kahan}}-s_{\\star}\\rvert$，并确定一个布尔标志 $\\text{better}$，当且仅当 $e_{\\text{kahan}}  e_{\\text{naive}}$ 时为真。", "solution": "所述问题是有效的。它在科学上基于数值分析（特别是浮点运算）的既定原则。问题陈述清晰，为待实现的算法提供了明确的定义，提供了完整的测试数据和无歧义的输出格式。问题是客观的，没有矛盾或信息缺失。我们可以着手解决。\n\n所要解决的根本问题是，计算机浮点加法不满足结合律，并且会产生舍入误差。对于两个实数 $a$ 和 $b$，它们的浮点和模型为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中相对误差 $\\lvert\\delta\\rvert$ 以单位舍入误差 $u$ 为界。在对一个数列求和时，这些微小的误差会累积。本分析将对比一种朴素求和方法与一种旨在减轻这种误差累积的补偿方法。\n\n**1. 朴素求和**\n\n最直接的方法是遍历数字列表 $\\{x_i\\}_{i=1}^n$，并将和累加到一个单一的浮点变量 $s$ 中。更新规则是 $s \\leftarrow \\operatorname{fl}(s + x_i)$。该方法的主要弱点是**大数吞小数（swamping）**。如果累加和 $s$ 的量级远大于待加项 $x_i$，那么 $x_i$ 的贡献可能会在舍入过程中部分或完全丢失。例如，在标准双精度算术中，如果 $s \\approx 10^{16}$ 而 $x_i = 1$，则操作 $\\operatorname{fl}(10^{16} + 1)$ 的计算结果为 $10^{16}$，因为精度不足以精确表示结果。项 $x_i$ 被有效丢弃了。\n\n**2. Kahan 补偿求和**\n\nKahan 求和算法是一种能显著减少舍入误差累积的技术。它维护第二个变量，即一个补偿量 $c$，用于累积每一步产生的误差。对于输入序列中的每一项 $x_i$，该算法执行以下操作：\n1.  校正当前项：$y \\leftarrow x_i - c$。此步骤从当前项中减去先前加法累积的误差。\n2.  加到总和中：$t \\leftarrow s + y$。这是一个标准的浮点加法，如果 $s$ 很大， $y$ 的低位比特可能会丢失。\n3.  恢复误差：$c \\leftarrow (t - s) - y$。这是关键步骤。项 $(t - s)$ 表示 $y$ 中被成功加到 $s$ 的部分。通过减去原始的（校正过的）项 $y$，我们分离出加法 $s+y$ 中舍入误差的负值。这个误差存储在 $c$ 中。\n4.  更新总和：$s \\leftarrow t$。\n\n这个迭代过程将每次加法中丢失的“零头”结转到下一次，并将其并入计算，从而确保最终累积的误差远小于朴素求和的情况。Kahan 求和的误差界为 $O(u + N\\epsilon u)$ 数量级，其中 $\\epsilon$ 与机器精度有关，这相比朴素求和最坏情况下的 $O(Nu)$ 误差是一个巨大的改进。\n\n**3. 精确有理数算术**\n\n为了建立一个权威的真实值（记为 $s_{\\star}$），我们必须在没有任何浮点误差的情况下计算总和。这可以通过使用精确有理数算术来实现。每个作为浮点值给出的输入数，首先被转换为其精确的有理数表示，即一个分数 $p/q$，其中 $p, q \\in \\mathbb{Z}$。所有后续的加法都使用精确的分数运算法则进行，例如 $\\frac{a}{b} + \\frac{c}{d} = \\frac{ad+bc}{bd}$。此过程没有浮点系统的表示和计算误差，从而得出输入值的真实数学和。\n\n**评估过程**\n\n对于四个指定的测试用例中的每一个，我们计算朴素和 $s_{\\text{naive}}$、Kahan 和 $s_{\\text{kahan}}$ 以及精确参考和 $s_{\\star}$。这些测试用例经过专门设计，通过混合不同数量级的数字，以暴露朴素求和的失效模式，特别是大数吞小数和灾难性抵消。然后我们计算绝对误差 $e_{\\text{naive}} = \\lvert s_{\\text{naive}} - s_{\\star} \\rvert$ 和 $e_{\\text{kahan}} = \\lvert s_{\\text{kahan}} - s_{\\star} \\rvert$。当且仅当 $e_{\\text{kahan}}  e_{\\text{naive}}$ 时，布尔标志 $\\text{better}$ 被设置为 $\\text{True}$，这定量地证明了 Kahan 算法对于给定输入的卓越准确性。最终输出的结构是一个记录列表，每条记录包含 $[s_{\\text{naive}}, s_{\\text{kahan}}, s_{\\star}, \\text{better}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy\nfrom fractions import Fraction\n\ndef naive_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the sum of a list of numbers using a naive iterative approach.\n    \"\"\"\n    s = 0.0\n    for x in numbers:\n        s += x\n    return s\n\ndef kahan_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the sum of a list of numbers using the Kahan summation algorithm\n    to reduce the accumulation of floating-point error.\n    \"\"\"\n    s = 0.0  # The running sum.\n    c = 0.0  # The compensation for lost low-order bits.\n    for x in numbers:\n        y = x - c    # c is the error from the previous sum.\n        t = s + y    # s is large, y is small, so low-order digits of y are lost.\n        c = (t - s) - y  # (t - s) recovers the high-order part of y.\n                         # Subtracting y recovers the low part, negated.\n        s = t        # Algebraically, c should be 0. But with rounding, it's not.\n    return s\n\ndef exact_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the exact sum of a list of floating-point numbers by\n    converting them to Fractions and using rational arithmetic.\n    \"\"\"\n    s = Fraction(0)\n    for x in numbers:\n        s += Fraction(x)\n    return float(s)\n\ndef solve():\n    \"\"\"\n    Runs the full test suite, comparing naive and Kahan summation against\n    an exact rational arithmetic reference, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: A simple case of catastrophic cancellation.\n        [1e16, 1.0, -1e16],\n        # Case 2: Summing many small numbers in the presence of a large one.\n        [1e16] + [1.0] * 100000 + [-1e16],\n        # Case 3: Summing many tiny numbers that are smaller than machine epsilon\n        # relative to the initial sum.\n        [1.0] + [1e-16] * 100000 + [-1.0],\n        # Case 4: A similar case to #2, but with smaller additions.\n        [1e16] + [1e-6] * 100000 + [-1e16],\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Compute the sum using all three methods.\n        s_naive = naive_sum(case_data)\n        s_kahan = kahan_sum(case_data)\n        s_star = exact_sum(case_data)\n        \n        # Calculate the absolute errors for both floating-point methods.\n        e_naive = abs(s_naive - s_star)\n        e_kahan = abs(s_kahan - s_star)\n        \n        # Determine if Kahan's method produced a smaller error.\n        better = e_kahan  e_naive\n        \n        # Store the record for this test case.\n        record = [s_naive, s_kahan, s_star, better]\n        results.append(record)\n\n    # Final print statement in the exact required format.\n    # The format template from the prompt is used: print(f\"[{','.join(map(str, results))}]\")\n    # str(list) in Python automatically includes spaces, which matches the example\n    # format diagram '[ [ . , . , . , . ], ... ]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393714"}, {"introduction": "浮点数的表示和运算误差意味着，在代码中直接使用相等性测试（例如 `a == b`）来比较两个浮点数是极其危险的，常常会导致逻辑错误。本练习通过一个简单的恒温器模拟，生动地展示了这种“天真”比较的失败之处，并将其与使用容差的“稳健”方法进行对比。这项实践将帮助你掌握在实际编程中处理浮点数比较的正确方法，避免难以追踪的程序缺陷 ([@problem_id:2395285])。", "problem": "你将编写一个完整的、可运行的程序，通过一个简单的恒温器模拟，来演示为何朴素的浮点数比较模式 `if (a/b == c)` 是危险的。该场景是一个离散时间恒温控制器，它以步进方式将一个系统加热到设定点，并通过将最近传感器读数的平均值与设定点进行比较来决定何时关闭加热器。你的程序必须模拟两种控制器：一个使用精确相等比较 `a == c` 的朴素控制器，以及一个使用容差来判断是否达到目标的鲁棒控制器。\n\n从以下基本前提开始：\n\n1. 电气和电子工程师协会 (IEEE) 754 浮点数算术以二进制表示实数，并在每次运算后四舍五入到最接近的可表示数。许多十进制小数，如 $0.1$、$0.2$ 和 $19.95$，无法在二进制中精确表示，因此加法和除法等运算会产生舍入误差。\n2. 一个离散时间控制器在步长 $n = 0,1,2,\\dots$ 处进行采样，并计算有限窗口内的平均值，其形式为 $a/b$，其中 $a$ 是浮点读数的滚动总和，$b$ 是窗口大小（或窗口大小内可用样本的数量）。然后将此平均值与目标设定点 $c$ 进行比较。\n\n恒温器模拟模型：在每个离散步骤 $n$，当加热器开启时，温度 $T_n$ 会通过一个恒定的加热增量 $\\Delta$ 进行更新。我们忽略冷却和噪声以隔离浮点行为。因此，当加热器开启时，更新规则为 $T_{n+1} = T_n + \\Delta$，初始温度 $T_0$ 为给定值。步骤 $n$ 的传感器读数记为 $r_n = T_n$（单位为摄氏度）。\n\n控制逻辑定义：\n\n- 朴素控制器：维护一个最近读数的列表，并计算最后 $m$ 个读数的平均值 $\\bar{r} = a/b$（如果可用读数少于 $m$ 个，则计算所有可用读数的平均值）。加热器在浮点运算中满足 $\\bar{r} = c$ 的第一个步骤 $n$ 关闭。\n- 鲁棒控制器：在满足 $\\bar{r} \\ge c - \\tau$（其中 $\\tau > 0$ 是一个很小的容差）的第一个步骤 $n$ 关闭。你必须使用 $\\tau = 10^{-12}$。\n\n你的任务是实现一个程序，对每个测试用例，模拟两种控制器最多达 $N_{\\text{max}}$ 步，并返回每个控制器关闭加热器所需的步数。如果一个控制器在 $N_{\\text{max}}$ 步内没有关闭，则为该控制器报告 $-1$。\n\n所有温度单位均为摄氏度；然而，输出是整数（步数），因此没有单位。不涉及角度。不涉及百分比。\n\n测试套件（每个用例指定为一个元组 $(T_0, c, \\Delta, m, N_{\\text{max}})$）：\n\n1. 用例 A（使用精确二进制分数的理想情况）：$(19.0, 20.0, 0.5, 1, 20)$。\n2. 用例 B（三个读数的平均值为不精确十进制小数）：$(20.0, 20.1, 0.1, 3, 20)$。\n3. 用例 C（目标值在十进制下等于一个简单平均值，但在二进制中可能无法精确表示）：$(19.8, 19.95, 0.05, 2, 20)$。\n4. 用例 D（三数平均值在精确十进制算术中等于目标值，着重于舍入问题）：$(17.2, 17.3, 0.1, 3, 20)$。\n5. 用例 E（边界条件：已达到设定点）：$(21.5, 21.5, 0.1, 4, 10)$。\n\n关于模拟和输出的精确要求：\n\n1. 用读数 $r_0 = T_0$ 进行初始化，并在步骤 $n=0$ 检查两种控制器。\n2. 在加热器开启的每个步骤 $n \\to n+1$ 中，更新 $T_{n+1} = T_n + \\Delta$，追加 $r_{n+1} = T_{n+1}$, 并重新计算最后 $m$ 个读数的平均值 $\\bar{r}$（如果可用读数少于 $m$ 个，则计算所有可用读数的平均值）。在该步骤计算出新的平均值后，立即检查控制器条件。\n3. 记录每个控制器关闭的第一个步骤 $n$。如果在 $N_{\\text{max}}$ 步内没有发生关闭事件，则记录 $-1$。\n4. 对于每个测试用例，输出两个整数：朴素控制器的步数，后跟鲁棒控制器的步数。\n\n最终输出格式：你的程序应生成一行输出，其中包含所有结果，以扁平化的逗号分隔列表形式，并用方括号括起来。因此，对于上述五个用例，你将按顺序输出一个长度为 $10$ 的列表：$[\\text{naive}_A, \\text{robust}_A, \\text{naive}_B, \\text{robust}_B, \\dots, \\text{naive}_E, \\text{robust}_E]$。", "solution": "该问题要求实现一个恒温器的离散时间模拟，以证明使用浮点数进行直接相等比较的不可靠性。这是计算科学中的一个经典问题，其根源在于数字表示的原理。\n\n其基本原理是 IEEE 754 浮点数算术标准。实数以有限位数的二进制格式存储。因此，没有有限二进制表示的十进制分数，例如 $0.1$（在二进制中是 $0.0001100110011...$），无法被精确存储。每次算术运算都可能引入微小的舍入误差。当这些运算链接在一起时，例如在计算平均值的求和过程中，这些误差会累积。结果是，一个在纯数学中应得出精确值的计算，例如 $\\sum_{i=1}^{3} (x + (i-1)\\Delta) / 3 = x+\\Delta$，在计算机中可能会产生一个与真实数学结果有极微小差异的值。这使得直接比较 `a/b == c` 变得脆弱且很可能失败。\n\n该模拟将对一个系统的温度 $T_n$ 在离散时间步长 $n=0, 1, 2, \\dots$ 上进行建模。系统从初始温度 $T_0$ 开始。在每个步骤中，加热器增加一个恒定的增量 $\\Delta$，因此温度根据规则 $T_{n+1} = T_n + \\Delta$ 演变。步骤 $n$ 的传感器读数就是 $r_n = T_n$。\n\n模拟了两种控制器策略来决定何时关闭加热器：\n\n1.  **朴素控制器**：该控制器计算最近读数的平均值。设 $S_n = \\{r_i | \\max(0, n-m+1) \\le i \\le n\\}$ 为在步骤 $n$ 时大小为 $m$ 的平均窗口中的读数集合。窗口大小为 $\\min(n+1, m)$。平均值为 $\\bar{r}_n = \\frac{1}{|S_n|} \\sum_{r \\in S_n} r$。该控制器的逻辑是在满足条件 $\\bar{r}_n = c$ 的第一个步骤 $n$ 关闭加热器，其中 $c$ 是目标设定点。这是一种直接的浮点数比较。\n\n2.  **鲁棒控制器**：该控制器使用相同的平均值计算 $\\bar{r}_n$。然而，其停用条件是 $\\bar{r}_n \\ge c - \\tau$，其中 $\\tau$ 是一个给定的很小的正容差，为 $\\tau = 10^{-12}$。这种方法承认由于离散化和舍入，计算出的平均值可能不完全等于设定点。一旦平均值“足够接近”或略微超过设定点，它就会关闭加热器。\n\n对于每个测试用例 $(T_0, c, \\Delta, m, N_{\\text{max}})$，模拟算法如下进行：\n\n1.  初始化温度 $T_{\\text{current}} = T_0$ 和一个包含初始值 $r_0 = T_0$ 的读数列表。\n2.  将两个控制器的停止步骤初始化为 $-1$。\n3.  **步骤 $n=0$**：使用初始平均值 $\\bar{r}_0 = r_0$ 检查两个控制器的条件。如果条件满足，则将停止步骤记录为 $0$。\n4.  **步骤 $n=1, \\dots, N_{\\text{max}}$**：\n    a. 更新温度：$T_{\\text{current}} \\leftarrow T_{\\text{current}} + \\Delta$。\n    b. 将新读数 $r_n = T_{\\text{current}}$ 添加到读数列表中。\n    c. 计算最后 $\\min(n+1, m)$ 个读数的平均值 $\\bar{r}_n$。\n    d. 对于每个尚未停止的控制器，检查其条件。如果条件满足，则将当前步骤 $n$ 记录为其停止步骤。\n5.  如果在迭代到 $N_{\\text{max}}$ 之后，任何控制器的停止步骤仍为 $-1$，则意味着其条件从未被满足。\n\n让我们分析一个例子，用例 D：$(T_0, c, \\Delta, m) = (17.2, 17.3, 0.1, 3)$。在理想算术中：\n-   在 $n=0$ 时， $T_0 = 17.2$。平均值为 $17.2$。\n-   在 $n=1$ 时， $T_1 = 17.2 + 0.1 = 17.3$。$\\{17.2, 17.3\\}$ 的平均值为 $17.25$。\n-   在 $n=2$ 时， $T_2 = 17.3 + 0.1 = 17.4$。$\\{17.2, 17.3, 17.4\\}$ 的平均值为 $\\frac{17.2+17.3+17.4}{3} = \\frac{51.9}{3} = 17.3$。所以，从数学上讲，在步骤 $n=2$ 时，平均值等于设定点 $c=17.3$。\n\n然而，在浮点数算术中，值 $0.1$ 无法精确表示。重复加上这个不精确的值会导致累积误差。温度 $T_1$ 和 $T_2$ 及其后续的总和将不是精确的数学值。计算出的平均值 $\\bar{r}_2$ 将是一个非常接近但并不等于 $17.3$ 的值。一个典型的浮点结果可能是 $17.300000000000004$。\n\n-   **朴素控制器**：检查 $\\bar{r}_2 == 17.3$ 将评估为假。随着温度继续升高，平均值将进一步偏离 $17.3$，因此朴素控制器将永远不会关闭。\n-   **鲁棒控制器**：检查 $\\bar{r}_2 \\ge 17.3 - 10^{-12}$ 将评估为真，因为 $17.300000000000004 \\ge 17.299999999999$。鲁棒控制器在步骤 $n=2$ 正确关闭。\n\n这种差异说明了为什么基于容差的比较对于可靠的控制系统以及其他涉及浮点数的应用至关重要。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the thermostat simulations and print the results.\n    \"\"\"\n    # Test suite defined in the problem statement.\n    # Each case is a tuple: (T_0, c, Delta, m, N_max)\n    test_cases = [\n        (19.0, 20.0, 0.5, 1, 20),      # Case A\n        (20.0, 20.1, 0.1, 3, 20),      # Case B\n        (19.8, 19.95, 0.05, 2, 20),    # Case C\n        (17.2, 17.3, 0.1, 3, 20),      # Case D\n        (21.5, 21.5, 0.1, 4, 10),      # Case E\n    ]\n\n    results = []\n    for case in test_cases:\n        naive_steps, robust_steps = simulate_thermostat(*case)\n        results.extend([naive_steps, robust_steps])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef simulate_thermostat(T_0, c, delta, m, N_max):\n    \"\"\"\n    Simulates naive and robust thermostat controllers for a given set of parameters.\n\n    Args:\n        T_0 (float): Initial temperature.\n        c (float): Setpoint temperature.\n        delta (float): Heating increment per step.\n        m (int): Averaging window size.\n        N_max (int): Maximum number of simulation steps.\n\n    Returns:\n        tuple[int, int]: A tuple containing the turn-off step for the naive\n                         and robust controllers, respectively. Returns -1 if\n                         a controller does not turn off within N_max steps.\n    \"\"\"\n    # Use floating-point numbers for all a-priori known physical quantities\n    T_0_f = float(T_0)\n    c_f = float(c)\n    delta_f = float(delta)\n    tau = 1e-12\n\n    # --- Naive Controller Simulation ---\n    naive_stop_step = -1\n    T_current_naive = T_0_f\n    readings_naive = [T_0_f]\n    \n    # Step n=0 check\n    if np.mean([T_0_f]) == c_f:\n        naive_stop_step = 0\n    else:\n        for n in range(1, N_max + 1):\n            T_current_naive += delta_f\n            readings_naive.append(T_current_naive)\n            \n            window_size = min(len(readings_naive), m)\n            readings_to_average = readings_naive[-window_size:]\n            avg_reading = np.mean(readings_to_average)\n\n            if avg_reading == c_f:\n                naive_stop_step = n\n                break\n    \n    # --- Robust Controller Simulation ---\n    robust_stop_step = -1\n    T_current_robust = T_0_f\n    readings_robust = [T_0_f]\n\n    # Step n=0 check\n    if np.mean([T_0_f]) = c_f - tau:\n        robust_stop_step = 0\n    else:\n        for n in range(1, N_max + 1):\n            T_current_robust += delta_f\n            readings_robust.append(T_current_robust)\n\n            window_size = min(len(readings_robust), m)\n            readings_to_average = readings_robust[-window_size:]\n            avg_reading = np.mean(readings_to_average)\n            \n            if avg_reading = c_f - tau:\n                robust_stop_step = n\n                break\n\n    return naive_stop_step, robust_stop_step\n\nsolve()\n```", "id": "2395285"}]}