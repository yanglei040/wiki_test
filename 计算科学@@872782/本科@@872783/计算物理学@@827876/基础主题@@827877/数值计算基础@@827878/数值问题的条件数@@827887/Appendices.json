{"hands_on_practices": [{"introduction": "条件数分析不仅用于诊断数值问题，也帮助我们理解物理模型对其参数的敏感性。这个练习将从物理学的基石之一——普朗克黑体辐射定律出发，探讨峰值发射波长与普朗克常数 $h$ 之间的关系。通过计算条件数，我们可以量化这个基本常数的不确定性如何传播到维恩位移定律的预测中 [@problem_id:2382057]。", "problem": "考虑一个绝对温度为 $T$ 的黑体，其 Planck 单位波长光谱辐射率由下式给出\n$$\nB_{\\lambda}(\\lambda, T; h) = \\frac{2 h c^{2}}{\\lambda^{5}} \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{B} T}\\right) - 1},\n$$\n其中 $h$ 是 Planck 常数，$c$ 是真空中的光速，$k_{B}$ 是 Boltzmann 常数。对于固定的 $T$ 以及物理常数 $c$ 和 $k_{B}$，仅使用基础微积分和该物理定律，完成以下任务：\n\n1. 确定使 $B_{\\lambda}(\\lambda, T; h)$ 关于 $\\lambda$ 最大化的波长 $\\lambda^{\\star}(h)$，并由此推导出形式为 $\\lambda^{\\star} T = b$ 的 Wien 位移定律，用 $h$、$c$、$k_{B}$ 以及一个来自最大化过程的无量纲数来表示 $b$。\n\n2. 将最大化问题视为以 $h$ 为参数的参数化优化问题，通过计算关于 $h$ 的相对条件数来分析 argmax 映射 $h \\mapsto \\lambda^{\\star}(h)$ 的条件，其定义为\n$$\n\\kappa_{h} = \\left| \\frac{d \\ln \\lambda^{\\star}(h)}{d \\ln h} \\right|.\n$$\n\n给出你的最终答案，即 $\\kappa_{h}$ 的值，表示为一个无单位的纯数。如果需要任何中间数值计算，请勿四舍五入；最终报告的量 $\\kappa_{h}$ 必须是精确且无单位的。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n-   Planck 的光谱辐射率：$B_{\\lambda}(\\lambda, T; h) = \\frac{2 h c^{2}}{\\lambda^{5}} \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{B} T}\\right) - 1}$。\n-   变量：$\\lambda$ (波长)，$T$ (绝对温度)，$h$ (Planck 常数)。\n-   常数：$c$ (光速)，$k_{B}$ (Boltzmann 常数)。\n-   任务1：对于固定的 $T$、$c$ 和 $k_B$，找到使 $B_{\\lambda}(\\lambda, T; h)$ 关于 $\\lambda$ 最大化的波长 $\\lambda^{\\star}(h)$。推导 Wien 位移定律 $\\lambda^{\\star} T = b$，并确定常数 $b$。\n-   任务2：计算映射 $h \\mapsto \\lambda^{\\star}(h)$ 的相对条件数 $\\kappa_{h} = \\left| \\frac{d \\ln \\lambda^{\\star}(h)}{d \\ln h} \\right|$。\n\n步骤2：验证\n该问题具有科学依据，它基于现代物理学的基本理论——Planck 的黑体辐射定律。问题是适定的，因为函数 $B_{\\lambda}$ 对于正波长有唯一最大值，从而得到唯一解。语言客观、精确。问题是自洽的，没有矛盾或歧义。\n\n步骤3：结论\n该问题有效。将提供完整解答。\n\n第1部分：Wien 位移定律的推导\n\n为了找到使光谱辐射率 $B_{\\lambda}(\\lambda, T; h)$ 最大化的波长 $\\lambda^{\\star}$，我们必须求解 $\\frac{\\partial B_{\\lambda}}{\\partial \\lambda} = 0$。该函数由下式给出：\n$$\nB_{\\lambda}(\\lambda, T; h) = \\frac{2 h c^{2}}{\\lambda^{5}} \\frac{1}{\\exp\\!\\left(\\frac{h c}{\\lambda k_{B} T}\\right) - 1}\n$$\n为了简化最大化过程，我们引入一个无量纲变量 $x$，定义为：\n$$\nx = \\frac{h c}{\\lambda k_{B} T}\n$$\n由此，我们可以将 $\\lambda$ 表示为 $\\lambda = \\frac{h c}{x k_{B} T}$。将此代入 $B_{\\lambda}$ 的表达式中得到：\n$$\nB_{\\lambda} = 2 h c^{2} \\left(\\frac{x k_{B} T}{h c}\\right)^{5} \\frac{1}{\\exp(x) - 1} = 2 h c^{2} \\left(\\frac{k_{B} T}{h c}\\right)^{5} \\frac{x^5}{\\exp(x) - 1}\n$$\n对于固定的温度 $T$ 和常数 $h, c, k_B$，使 $B_{\\lambda}$ 关于 $\\lambda$ 最大化等价于使函数 $f(x) = \\frac{x^5}{\\exp(x) - 1}$ 关于 $x$ 最大化。注意，当 $\\lambda$ 从 $0$ 变化到 $\\infty$ 时，$x$ 从 $\\infty$ 变化到 $0$。我们计算 $f(x)$ 的导数并令其为零。\n$$\n\\frac{df}{dx} = \\frac{d}{dx} \\left( \\frac{x^5}{\\exp(x) - 1} \\right) = \\frac{5x^4(\\exp(x) - 1) - x^5 \\exp(x)}{(\\exp(x) - 1)^2} = 0\n$$\n对于一个非平凡的最大值 ($x > 0$)，分子必须为零：\n$$\n5x^4(\\exp(x) - 1) - x^5 \\exp(x) = 0\n$$\n除以 $x^4$ (因为 $x \\neq 0$)：\n$$\n5(\\exp(x) - 1) - x \\exp(x) = 0\n$$\n这是一个关于使函数最大化的 $x$ 值的超越方程。设该方程的非零根为无量纲常数 $\\alpha$。关于 $\\alpha$ 的方程是：\n$$\n5(\\exp(\\alpha) - 1) - \\alpha \\exp(\\alpha) = 0\n$$\n最大化波长 $\\lambda^{\\star}$ 对应于这个值 $\\alpha$。根据 $x$ 的定义：\n$$\n\\alpha = \\frac{h c}{\\lambda^{\\star} k_{B} T}\n$$\n重排此方程得到 Wien 位移定律：\n$$\n\\lambda^{\\star} T = \\frac{h c}{\\alpha k_{B}}\n$$\n这具有 $\\lambda^{\\star} T = b$ 的形式，其中常数 $b$ 被确定为：\n$$\nb = \\frac{h c}{\\alpha k_{B}}\n$$\n\n第2部分：条件分析\n\n我们被要求计算映射 $h \\mapsto \\lambda^{\\star}(h)$ 的相对条件数 $\\kappa_{h}$，其定义为：\n$$\n\\kappa_{h} = \\left| \\frac{d \\ln \\lambda^{\\star}(h)}{d \\ln h} \\right|\n$$\n根据第1部分的结果，我们有 $\\lambda^{\\star}$ 作为 $h$ 的函数的显式表达式：\n$$\n\\lambda^{\\star}(h) = \\frac{h c}{\\alpha k_{B} T}\n$$\n在这里，$c$、$k_B$ 和 $T$ 被视为固定常数。关键的是，$\\alpha$ 是一个普适的数学常数，它是一个不依赖于任何物理参数的方程的解。因此，我们可以将 $\\lambda^{\\star}(h)$ 写为：\n$$\n\\lambda^{\\star}(h) = C h\n$$\n其中 $C = \\frac{c}{\\alpha k_{B} T}$ 是一个关于 $h$ 的常数。\n\n为计算 $\\kappa_h$，我们对 $\\lambda^{\\star}(h)$ 取自然对数：\n$$\n\\ln(\\lambda^{\\star}(h)) = \\ln(C h) = \\ln(C) + \\ln(h)\n$$\n现在，我们对 $\\ln(h)$ 求导：\n$$\n\\frac{d \\ln(\\lambda^{\\star}(h))}{d \\ln(h)} = \\frac{d}{d \\ln(h)} (\\ln(C) + \\ln(h)) = 0 + 1 = 1\n$$\n条件数是这个导数的绝对值：\n$$\n\\kappa_{h} = |1| = 1\n$$\n这个结果表明，对于 Planck 常数，寻找最大化波长的问题是完全良态的。$h$ 的一个相对误差会在 $\\lambda^\\star$ 中产生相同的相对误差。\n\n为完整起见，我们使用一个更通用的方法来验证这一结果，该方法基于隐函数定理，这是参数化优化问题灵敏度分析的标准工具。最大值的一阶条件可以写成一个隐函数 $F(\\lambda, h) = 0$：\n$$\nF(\\lambda, h) = 5\\left(\\exp\\left(\\frac{hc}{\\lambda k_B T}\\right) - 1\\right) - \\frac{hc}{\\lambda k_B T} \\exp\\left(\\frac{hc}{\\lambda k_B T}\\right) = 0\n$$\n设 $x(\\lambda, h) = \\frac{hc}{\\lambda k_B T}$。那么 $F(\\lambda, h) = 5(\\exp(x) - 1) - x\\exp(x) = 0$。根据隐函数定理，解 $\\lambda^\\star(h)$ 的导数由 $\\frac{d\\lambda^\\star}{dh} = - \\frac{\\partial F / \\partial h}{\\partial F / \\partial \\lambda}$ 给出。\n偏导数通过链式法则计算。在最优点 $\\lambda = \\lambda^\\star$ 处，$x = \\alpha$。\n$$\n\\frac{\\partial F}{\\partial \\lambda} = \\frac{dF}{dx} \\frac{\\partial x}{\\partial \\lambda} = \\left[5e^x - (e^x + xe^x)\\right] \\left(-\\frac{hc}{\\lambda^2 k_B T}\\right) = (4-x)e^x \\left(-\\frac{x}{\\lambda}\\right)\n$$\n$$\n\\frac{\\partial F}{\\partial h} = \\frac{dF}{dx} \\frac{\\partial x}{\\partial h} = \\left[(4-x)e^x\\right] \\left(\\frac{c}{\\lambda k_B T}\\right) = (4-x)e^x \\left(\\frac{x}{h}\\right)\n$$\n在最优点 $\\lambda^\\star$ 处，只要分母不为零（事实也的确如此，因为 $\\alpha \\approx 4.965 \\neq 4$），我们有：\n$$\n\\frac{d\\lambda^\\star}{dh} = - \\frac{(4-\\alpha)e^\\alpha ( \\alpha / h )}{(4-\\alpha)e^\\alpha ( -\\alpha / \\lambda^\\star )} = \\frac{\\alpha / h}{\\alpha / \\lambda^\\star} = \\frac{\\lambda^\\star}{h}\n$$\n现在我们用这个导数计算条件数：\n$$\n\\kappa_{h} = \\left| \\frac{h}{\\lambda^\\star(h)} \\frac{d\\lambda^\\star}{dh} \\right| = \\left| \\frac{h}{\\lambda^\\star} \\left(\\frac{\\lambda^\\star}{h}\\right) \\right| = |1| = 1\n$$\n两种方法都得出了相同的结果，证实了分析的正确性。最终答案是一个精确的纯数。", "answer": "$$\\boxed{1}$$", "id": "2382057"}, {"introduction": "许多物理系统表现出急剧的相变或过渡，这些区域往往是数值病态问题的根源。本实践将探索机翼的空气动力学失速现象，此时迎角的微小变化可能导致升力的急剧下降。你将实现一个升力系数模型，并计算其条件数，从而用数值方式证明在临界失速角附近，系统的敏感性是如何急剧增加的 [@problem_id:2382100]。", "problem": "考虑从攻角到单个翼型的二维定常升力系数的映射，该映射由以下平滑失速起始函数建模：\n$$\nC_L(\\alpha; a,\\alpha_s,\\Delta C,\\delta) \\;=\\; a\\,\\alpha \\;-\\; \\Delta C\\; S(\\alpha), \\quad\\text{with}\\quad S(\\alpha) \\;=\\; \\tfrac{1}{2}\\Big(1+\\tanh\\Big(\\frac{\\alpha-\\alpha_s}{\\delta}\\Big)\\Big),\n$$\n其中，$a>0$ 是小角度升力斜率，单位为 弧度$^{-1}$；$\\alpha_s$ 是特征失速起始角；$\\Delta C>0$ 是跨越失速过渡区的升力系数净损失；$\\delta>0$ 控制过渡的急剧程度。角度必须以弧度表示。\n\n设问题“给定 $\\alpha$ 求 $C_L$”的绝对条件数定义为\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) \\;=\\; \\left|\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|,\n$$\n相对条件数（当 $C_L(\\alpha)\\neq 0$ 时）定义为\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) \\;=\\; \\left|\\frac{\\alpha}{C_L(\\alpha)}\\,\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|.\n$$\n您必须为下面列出的参数集计算这两个条件数。如果在某个情况下 $C_L(\\alpha)=0$，则将相对条件数报告为 NaN (Not-a-Number)。\n\n攻角必须以弧度为单位，并且您计算的最终数值是无量纲的。\n\n测试套件（每个案例是一个有序的 5 元组 $(a,\\alpha_s,\\Delta C,\\delta,\\alpha)$，按所述顺序排列）：\n- 案例 1（代表性失速前）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.10)$。\n- 案例 2（接近失速且过渡急剧）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.35)$。\n- 案例 3（失速后，仍受失速起始影响）：$(6.2,\\;0.35,\\;0.8,\\;0.015,\\;0.42)$。\n- 案例 4（接近失速且过渡平缓）：$(6.2,\\;0.35,\\;0.8,\\;0.10,\\;0.35)$。\n- 案例 5（无失速下降，纯线性模型）：$(6.2,\\;0.35,\\;0.0,\\;0.020,\\;0.30)$。\n\n您的程序必须：\n- 对于每个测试案例，根据上述模型评估 $C_L(\\alpha)$ 及其关于 $\\alpha$ 的导数，然后计算定义的 $\\kappa_{\\mathrm{abs}}(\\alpha)$ 和 $\\kappa_{\\mathrm{rel}}(\\alpha)$。\n- 所有角度均使用弧度。\n- 生成单行输出，其中包含按测试套件顺序排列的逗号分隔的配对列表。每个配对必须是该案例的一个双元素列表 $[\\kappa_{\\mathrm{abs}},\\kappa_{\\mathrm{rel}}]$。因此，完整的输出行必须如下所示\n$[[\\kappa_{\\mathrm{abs}}^{(1)},\\kappa_{\\mathrm{rel}}^{(1)}],[\\kappa_{\\mathrm{abs}}^{(2)},\\kappa_{\\mathrm{rel}}^{(2)}],\\dots]$\n用数值代替符号，并对“非数值”使用标准浮点表示法 (NaN)。\n\n程序不得读取任何输入。", "solution": "我们对问题陈述进行了审查，并认定其有效。该问题具有科学依据，提法恰当，客观且自成体系。所提供的升力系数 $C_L$ 作为攻角 $\\alpha$ 函数的模型，是包含平滑失速过渡的空气动力升力的标准唯象表示。绝对和相对条件数的定义是数值分析中的正确标准形式。参数和测试案例在物理上是合理的，在数学上是可处理的。我们将继续进行求解。\n\n目标是计算评估升力系数 $C_L(\\alpha)$ 问题的绝对条件数 $\\kappa_{\\mathrm{abs}}(\\alpha)$ 和相对条件数 $\\kappa_{\\mathrm{rel}}(\\alpha)$。$C_L$ 的模型由下式给出：\n$$\nC_L(\\alpha; a, \\alpha_s, \\Delta C, \\delta) = a\\alpha - \\Delta C S(\\alpha)\n$$\n其中 $S(\\alpha)$ 是失速起始函数：\n$$\nS(\\alpha) = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)\n$$\n参数包括升力曲线斜率 $a$、失速角 $\\alpha_s$、升力下降量 $\\Delta C$ 以及过渡锐度 $\\delta$。所有角度均以弧度为单位。\n\n条件数定义为：\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) = \\left|\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) = \\left|\\frac{\\alpha}{C_L(\\alpha)}\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}(\\alpha)\\right|\n$$\n\n第一步是推导导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$ 的解析表达式。我们对包含 $S(\\alpha)$ 的项应用链式法则。设双曲正切的参数为 $u(\\alpha) = \\frac{\\alpha - \\alpha_s}{\\delta}$。$u$ 关于 $\\alpha$ 的导数是 $\\frac{\\mathrm{d}u}{\\mathrm{d}\\alpha} = \\frac{1}{\\delta}$。双曲正切函数的导数是 $\\frac{\\mathrm{d}}{\\mathrm{d}u}\\tanh(u) = \\mathrm{sech}^2(u)$。应用链式法则求 $S(\\alpha)$ 的导数：\n$$\n\\frac{\\mathrm{d}S}{\\mathrm{d}\\alpha} = \\frac{\\mathrm{d}}{\\mathrm{d}\\alpha}\\left[\\frac{1}{2}\\left(1 + \\tanh(u(\\alpha))\\right)\\right] = \\frac{1}{2} \\cdot \\frac{\\mathrm{d}}{\\mathrm{d}u}\\tanh(u) \\cdot \\frac{\\mathrm{d}u}{\\mathrm{d}\\alpha} = \\frac{1}{2} \\cdot \\mathrm{sech}^2(u) \\cdot \\frac{1}{\\delta} = \\frac{1}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\n$$\n现在，我们可以对 $C_L(\\alpha)$ 的完整表达式进行微分：\n$$\n\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha} = \\frac{\\mathrm{d}}{\\mathrm{d}\\alpha}(a\\alpha) - \\Delta C \\frac{\\mathrm{d}S}{\\mathrm{d}\\alpha} = a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\n$$\n其中 $\\mathrm{sech}(x) = 1/\\cosh(x)$。\n\n有了 $C_L(\\alpha)$ 及其导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$ 的表达式，我们就可以写出条件数的显式公式。\n绝对条件数为：\n$$\n\\kappa_{\\mathrm{abs}}(\\alpha) = \\left|a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right|\n$$\n相对条件数（对于 $C_L(\\alpha) \\neq 0$）为：\n$$\n\\kappa_{\\mathrm{rel}}(\\alpha) = \\left|\\frac{\\alpha}{a\\alpha - \\frac{\\Delta C}{2}\\left(1 + \\tanh\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)} \\left(a - \\frac{\\Delta C}{2\\delta}\\mathrm{sech}^2\\left(\\frac{\\alpha - \\alpha_s}{\\delta}\\right)\\right)\\right|\n$$\n如果 $C_L(\\alpha) = 0$，相对条件数未定义，根据指示我们应将其报告为“非数值 (NaN)”。\n\n计算过程是在一个程序中实现这些公式。对于所提供的 5 个测试案例中的每一个，每个案例由一个元组 $(a, \\alpha_s, \\Delta C, \\delta, \\alpha)$ 指定，执行以下步骤：\n1. 评估参数 $u = (\\alpha - \\alpha_s) / \\delta$。\n2. 使用给定模型计算 $C_L(\\alpha)$。\n3. 使用推导出的公式计算导数 $\\frac{\\mathrm{d}C_L}{\\mathrm{d}\\alpha}$。\n4. 通过取导数的绝对值来计算 $\\kappa_{\\mathrm{abs}}(\\alpha)$。\n5. 计算 $\\kappa_{\\mathrm{rel}}(\\alpha)$。如果 $C_L(\\alpha)$ 的计算结果为 $0.0$，则结果为 NaN。否则，使用其定义进行计算。\n对于每个案例，记录所得的数值对 $[\\kappa_{\\mathrm{abs}}, \\kappa_{\\mathrm{rel}}]$。最终输出是这些数值对聚合成的单个列表结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the absolute and relative condition numbers for a given aerodynamic\n    lift coefficient model for a series of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is an ordered 5-tuple (a, alpha_s, delta_C, delta, alpha).\n    test_cases = [\n        (6.2, 0.35, 0.8, 0.015, 0.10),  # Case 1 (pre-stall)\n        (6.2, 0.35, 0.8, 0.015, 0.35),  # Case 2 (near stall, sharp transition)\n        (6.2, 0.35, 0.8, 0.015, 0.42),  # Case 3 (post-stall)\n        (6.2, 0.35, 0.8, 0.10, 0.35),   # Case 4 (near stall, gentle transition)\n        (6.2, 0.35, 0.0, 0.020, 0.30),  # Case 5 (linear model)\n    ]\n\n    results = []\n    for case in test_cases:\n        a, alpha_s, delta_c, delta, alpha = case\n        \n        # Argument for the hyperbolic functions\n        u = (alpha - alpha_s) / delta\n        \n        # Lift coefficient C_L(alpha)\n        # C_L = a*alpha - delta_C * S(alpha)\n        # S(alpha) = 0.5 * (1 + tanh(u))\n        c_l = a * alpha - (delta_c / 2.0) * (1.0 + np.tanh(u))\n        \n        # Derivative d(C_L)/d(alpha)\n        # d(C_L)/d(alpha) = a - (delta_C / (2*delta)) * sech^2(u)\n        # sech(u) = 1/cosh(u)\n        cosh_u = np.cosh(u)\n        # Avoid division by zero if cosh_u is somehow zero, though it's always >= 1.\n        sech_u_sq = (1.0 / cosh_u)**2 if cosh_u != 0 else 0.0\n        dcl_dalpha = a - (delta_c / (2.0 * delta)) * sech_u_sq\n        \n        # Absolute condition number\n        k_abs = np.abs(dcl_dalpha)\n        \n        # Relative condition number\n        # Handle the case where C_L(alpha) is zero\n        if c_l == 0.0:\n            k_rel = np.nan\n        else:\n            k_rel = np.abs((alpha / c_l) * dcl_dalpha)\n            \n        results.append([k_abs, k_rel])\n\n    # Final print statement in the exact required format.\n    # The format is a list of lists, with no spaces after commas.\n    result_strings = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2382100"}, {"introduction": "在识别出病态问题后，下一步通常是重新构造问题或对其进行“预处理”，以改善其数值稳定性。这个练习将深入探讨病态线性系统的一个常见来源：具有高度变化系数的微分方程的离散化。你将为一个泊松型方程构建系统矩阵，然后应用雅可比预处理器，亲眼见证这项技术如何显著降低条件数，从而使问题更易于迭代求解器处理 [@problem_id:2382055]。", "problem": "给定一个线性系统族，该系统族源于在单位区间上带有齐次狄利克雷边界条件的一维稳态扩散（泊松型）方程。设 $k(x) > 0$ 为一个标量电导率函数，并考虑在 $x \\in [0,1]$ 上的边值问题，其中 $u(0) = 0$ 且 $u(1) = 0$：\n$$\n-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = f(x).\n$$\n使用 $n$ 个内部点和均匀网格间距 $h = \\frac{1}{n+1}$ 对该算子进行离散化。将内部节点位置表示为 $x_i = i h$（对于 $i = 1,2,\\dots,n$），将界面位置表示为 $x_{i+\\frac{1}{2}} = \\left(i+\\frac{1}{2}\\right) h$（对于 $i = 0,1,\\dots,n$）。构造对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其元素为\n$$\nA_{i,i} = \\frac{k\\!\\left(x_{i-\\frac{1}{2}}\\right) + k\\!\\left(x_{i+\\frac{1}{2}}\\right)}{h^2}, \\quad\nA_{i,i-1} = -\\frac{k\\!\\left(x_{i-\\frac{1}{2}}\\right)}{h^2}, \\quad\nA_{i,i+1} = -\\frac{k\\!\\left(x_{i+\\frac{1}{2}}\\right)}{h^2},\n$$\n其中 $A_{i,i-1}$ 仅在 $i \\ge 2$ 时存在，$A_{i,i+1}$ 仅在 $i \\le n-1$ 时存在。此模板对应于使用在界面处采样的电导率对通量进行的一致中心化离散。\n\n设雅可比预条件子定义为对角矩阵 $D = \\mathrm{diag}(A)$，对称预处理算子为\n$$\nS = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}.\n$$\n对于任何对称正定矩阵 $X$，将谱条件数定义为\n$$\n\\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)},\n$$\n其中 $\\lambda_{\\max}(X)$ 和 $\\lambda_{\\min}(X)$ 分别是 $X$ 的最大和最小特征值。\n\n任务：对于下述每个测试用例，构造定义的 $A$，构造 $D$ 和 $S$，并计算三元实数组\n$$\n\\Big(\\kappa_2(A), \\ \\kappa_2(S), \\ \\frac{\\kappa_2(A)}{\\kappa_2(S)}\\Big).\n$$\n将这三个数中的每一个都四舍五入到六位小数。\n\n测试套件（照常使用以弧度为单位的 $x$；由于在此设置中所有量都是无量纲的，因此不需要物理单位）：\n- 测试 1（均匀介质，中等规模）：$n = 50$，$k(x) = 1$ 对所有 $x \\in [0,1]$。\n- 测试 2（分段高对比度介质）：$n = 50$，$k(x) = 1$ 当 $x  0.5$ 时，$k(x) = 100$ 当 $x \\ge 0.5$ 时。\n- 测试 3（边界规模）：$n = 1$，$k(x) = 1 + x$ 对 $x \\in [0,1]$。\n- 测试 4（振荡高对比度介质）：$n = 51$，如果 $\\lfloor 20 x \\rfloor$ 为偶数，则 $k(x) = 100$；如果 $\\lfloor 20 x \\rfloor$ 为奇数，则 $k(x) = 1$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表形式的结果，顺序如上所述，每个内部列表是该测试的三个四舍五入后的浮点数，例如：\n[[a1,b1,c1],[a2,b2,c2],[a3,b3,c3],[a4,b4,c4]]\n其中每个 $a_j$、$b_j$ 和 $c_j$ 是一个小数点后有六位数的小数。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件。\n- 方程：$-\\frac{d}{dx}\\left(k(x)\\frac{du}{dx}\\right) = f(x)$ 对于 $x \\in [0,1]$。\n- 边界条件：$u(0) = 0$，$u(1) = 0$。\n- 离散化：$n$ 个内部点，均匀网格间距 $h = \\frac{1}{n+1}$。\n- 节点：$x_i = i h$ 对于 $i = 1,2,\\dots,n$。\n- 界面：$x_{i+\\frac{1}{2}} = \\left(i+\\frac{1}{2}\\right) h$ 对于 $i = 0,1,\\dots,n$。\n- 矩阵 $A \\in \\mathbb{R}^{n \\times n}$：对称正定，元素为 $A_{i,i} = \\frac{k(x_{i-\\frac{1}{2}}) + k(x_{i+\\frac{1}{2}})}{h^2}$，$A_{i,i-1} = -\\frac{k(x_{i-\\frac{1}{2}})}{h^2}$，$A_{i,i+1} = -\\frac{k(x_{i+\\frac{1}{2}})}{h^2}$。\n- 预条件子：$D = \\mathrm{diag}(A)$。\n- 预处理矩阵：$S = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}$。\n- 条件数：$\\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)}$。\n- 任务：为四个测试用例计算 $(\\kappa_2(A), \\kappa_2(S), \\frac{\\kappa_2(A)}{\\kappa_2(S)})$，四舍五入到六位小数。\n- 测试用例：\n    1.  $n = 50$，$k(x) = 1$。\n    2.  $n = 50$，$k(x) = 1$ 当 $x  0.5$ 时，$k(x) = 100$ 当 $x \\ge 0.5$ 时。\n    3.  $n = 1$，$k(x) = 1 + x$。\n    4.  $n = 51$，如果 $\\lfloor 20 x \\rfloor$ 为偶数，则 $k(x) = 100$；如果 $\\lfloor 20 x \\rfloor$ 为奇数，则 $k(x) = 1$。\n\n步骤 2：验证。\n该问题具有科学依据，是适定的、客观的。它描述了一维泊松型方程的标准有限差分格式，这是计算物理学中的一个基本问题。已知当 $k(x)  0$ 时，此方法生成的矩阵 $A$ 是对称正定的，这确保其特征值为正实数，因此其条件数 $\\kappa_2(A)$ 是良定义且大于等于 $1$。雅可比预条件子 $D$ 是 $A$ 的对角线，其元素将严格为正，这使得其逆平方根 $D^{-1/2}$ 是实数且良定义的。得到的对称预处理矩阵 $S$ 也是对称正定的。所有的定义和测试用例都足够精确，可以得到一个唯一的、可验证的解。因此，该问题是有效的。\n\n步骤 3：行动。\n问题有效。我们继续进行求解。\n\n解决方案需要实现一个程序，为每个指定的测试用例计算矩阵 $A$ 及其雅可比预处理后的对应矩阵 $S$ 的谱条件数。方法如下。\n\n对于每个由内部点数 $n$ 和电导率函数 $k(x)$ 定义的测试用例：\n1.  首先，计算网格间距 $h$ 为 $h = \\frac{1}{n+1}$。\n\n2.  接下来，构造 $n \\times n$ 矩阵 $A$。在实现中，我们可以使用从零开始的索引，其中数组索引 $i, j$ 的范围是从 $0$ 到 $n-1$。数学索引 $i$ 从 $1$ 到 $n$ 对应于编程索引 $i-1$。\n    - 对角线元素为 $A_{i,i} = \\frac{k(x_{i-\\frac{1}{2}}) + k(x_{i+\\frac{1}{2}})}{h^2}$。在程序术语中，对于从 $0$ 到 $n-1$ 的索引 `i`，这是 `A[i,i] = (k_func((i + 0.5)*h) + k_func((i + 1.5)*h)) / h**2`。\n    - 非对角线元素由 $A_{i,i+1} = -\\frac{k(x_{i+\\frac{1}{2}})}{h^2}$ 和 $A_{i,i-1} = -\\frac{k(x_{i-\\frac{1}{2}})}{h^2}$ 定义。根据问题公式的对称性，$A_{i, j} = A_{j, i}$。对于从 $0$ 到 $n-2$ 的索引 `i`，上对角线元素是 `A[i,i+1] = -k_func((i + 1.5)*h) / h**2`。下对角线通过对称性填充，`A[i+1,i] = A[i,i+1]`。\n\n3.  雅可比预条件子 $D$ 是一个包含 $A$ 的对角线元素的对角矩阵。我们提取这个对角线，$D_{ii} = A_{ii}$。\n\n4.  构造对称预处理矩阵 $S = D^{-\\frac{1}{2}} A D^{-\\frac{1}{2}}$。其元素由 $S_{ij} = \\frac{A_{ij}}{\\sqrt{D_{ii} D_{jj}}}$ 给出。在计算上，这是通过首先计算 $D^{-1/2}$ 的对角线元素向量（即 $1/\\sqrt{A_{ii}}$），然后缩放矩阵 $A$ 来实现的。$S$ 的对角线元素都等于 $1$。\n\n5.  对 $X=A$ 和 $X=S$ 计算谱条件数 $\\kappa_2(X)$。由于 $A$ 和 $S$ 是对称正定的，它们的特征值是正实数。我们使用可靠的数值方法（例如 `numpy.linalg.eigh` 中实现的方法）为每个矩阵计算完整的特征值谱。条件数是最大特征值 $\\lambda_{\\max}$ 与最小特征值 $\\lambda_{\\min}$ 的比值。\n    $$\n    \\kappa_2(X) = \\frac{\\lambda_{\\max}(X)}{\\lambda_{\\min}(X)}\n    $$\n\n6.  最后，组装分析三元组 $(\\kappa_2(A), \\kappa_2(S), \\frac{\\kappa_2(A)}{\\kappa_2(S)})$。比率 $\\frac{\\kappa_2(A)}{\\kappa_2(S)}$ 衡量雅可比预条件子在减小条件数方面的有效性。大于 $1$ 的值表示有所改进。三元组中的三个值均按要求四舍五入到六位小数。\n\n此过程被系统地应用于四个测试用例。\n- 测试 1 ($n=50$, $k(x)=1$)：对于常数 $k(x)$，矩阵 $A$ 是标准离散拉普拉斯算子的一个倍数。其对角线 $D$ 是单位矩阵的一个倍数。因此，$S$ 是 $A$ 的一个缩放，它们的条件数相同，得出 $\\kappa_2(A) / \\kappa_2(S) = 1$。\n- 测试 2 ($n=50$, 高对比度跳跃)：$k(x)$ 的大跳跃导致 $A$ 元素量级的大变化，从而导致大的 $\\kappa_2(A)$。雅可比预条件子通过缩放每一行来减轻这种变化。我们预期 $\\kappa_2(S) \\ll \\kappa_2(A)$ 并且有很大的改进比。\n- 测试 3 ($n=1$)：这是一个 $1 \\times 1$ 矩阵的平凡情况。对于任何标量矩阵 $A = [c]$ 且 $c \\ne 0$，$\\lambda_{\\max} = \\lambda_{\\min} = c$，因此 $\\kappa_2(A) = 1$。对于 $S$ 也是如此，因此结果预期为 $(1, 1, 1)$。\n- 测试 4 ($n=51$, 振荡对比度)：$k(x)$ 在 $1$ 和 $100$ 之间的快速振荡是一个困难的情况。$A$ 的元素及其对角线 $D$ 显著波动，导致大的条件数。预计雅可比预处理会带来一些好处，但其局部性可能不足以完全解决由不同长度尺度上的振荡引起的病态问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for all test cases and prints the result.\n    \"\"\"\n\n    def k_func_1(x):\n        return 1.0\n\n    def k_func_2(x):\n        return 1.0 if x  0.5 else 100.0\n\n    def k_func_3(x):\n        return 1.0 + x\n\n    def k_func_4(x):\n        # The floor of 20*x is an integer. Check if it's even or odd.\n        return 100.0 if np.floor(20.0 * x) % 2 == 0 else 1.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, k_func_1),\n        (50, k_func_2),\n        (1, k_func_3),\n        (51, k_func_4),\n    ]\n\n    results = []\n    for n, k_func in test_cases:\n        result_triplet = calculate_condition_numbers(n, k_func)\n        results.append(result_triplet)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{r[0]:.6f},{r[1]:.6f},{r[2]:.6f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef calculate_condition_numbers(n, k_func):\n    \"\"\"\n    Builds matrices A and S, and computes their condition numbers.\n    \n    Args:\n        n (int): The number of interior grid points.\n        k_func (function): The conductivity function k(x).\n\n    Returns:\n        tuple: A triplet of floats (kappa_A, kappa_S, ratio).\n    \"\"\"\n\n    # For n=0, matrices are empty. Problem constraints imply n=1.\n    # For n=1, matrix is 1x1, condition number is 1, a special case.\n    if n == 1:\n        # For a 1x1 matrix, lambda_max = lambda_min, so kappa = 1.\n        # This holds for A and S.\n        return (1.0, 1.0, 1.0)\n\n    h = 1.0 / (n + 1.0)\n    \n    # Construct the matrix A\n    A = np.zeros((n, n))\n    h2 = h * h\n\n    # Vectorized calculation of k values at interfaces\n    # Interfaces are at (i + 0.5) * h for i = 0, ..., n\n    interface_x = (np.arange(n + 1) + 0.5) * h\n    k_at_interfaces = np.array([k_func(x) for x in interface_x])\n\n    for i in range(n):\n        # In mathematical notation, this is row i+1\n        # Interface indices are i and i+1, corresponding to x_{i+1/2} and x_{i+3/2}\n        k_imhalf = k_at_interfaces[i]\n        k_iphalf = k_at_interfaces[i+1]\n\n        # Diagonal entry\n        A[i, i] = (k_imhalf + k_iphalf) / h2\n        # Off-diagonal entries\n        if i  n - 1:\n            A[i, i + 1] = -k_iphalf / h2\n            A[i + 1, i] = -k_iphalf / h2 # By symmetry argument in problem description\n\n    # Eigenvalues and condition number of A\n    eigvals_A = np.linalg.eigh(A)[0]\n    kappa_A = eigvals_A[-1] / eigvals_A[0]\n\n    # Construct the symmetrically preconditioned matrix S\n    D_diag = np.diag(A)\n    D_inv_sqrt_diag = 1.0 / np.sqrt(D_diag)\n    \n    # Efficiently compute S = D^{-1/2} A D^{-1/2} using element-wise multiplication\n    # with an outer product of the scaling vector.\n    S = A * np.outer(D_inv_sqrt_diag, D_inv_sqrt_diag)\n    \n    # Eigenvalues and condition number of S\n    eigvals_S = np.linalg.eigh(S)[0]\n    kappa_S = eigvals_S[-1] / eigvals_S[0]\n    \n    # Ratio\n    ratio = kappa_A / kappa_S\n\n    return (round(kappa_A, 6), round(kappa_S, 6), round(ratio, 6))\n\nsolve()\n```", "id": "2382055"}]}