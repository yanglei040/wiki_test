{"hands_on_practices": [{"introduction": "在数值计算中，即便是看似直接的代数表达式也可能隐藏着陷阱。一个典型的例子是“灾难性抵消”，即两个几乎相等的数相减，会导致相对精度的灾难性损失。本练习将通过一个源自狭义相对论的著名例子，让你亲手实践如何通过代数重构来规避这一问题，从而保证计算结果的准确性 [@problem_id:2439862]。", "problem": "一个狭义相对论动力学模拟将动能计算为 $K = mc^{2}(\\gamma - 1)$，其中洛伦兹因子定义为 $\\gamma = 1/\\sqrt{1 - v^{2}/c^{2}}$。对于一个速率为 $v \\ll c$ 的粒子，直接计算 $\\gamma$ 然后再计算 $\\gamma - 1$ 会因相消误差而引入巨大的相对数值误差。\n\n考虑一个以速率 $v = 3.0$ $\\mathrm{m\\,s^{-1}}$ 运动的粒子。光速为 $c = 299{,}792{,}458$ $\\mathrm{m\\,s^{-1}}$ (由定义确定的精确值)。\n\n在不使用任何预先制表的近似值的情况下，推导一个用 $v$ 和 $c$ 表示的 $\\gamma - 1$ 的代数表达式，该表达式在 $v \\ll c$ 时能避免相消误差。然后使用该表达式计算当 $v = 3.0$ 和 $c = 299{,}792{,}458$ 时 $\\gamma - 1$ 的数值。将你的答案四舍五入到六位有效数字。将最终结果表示为一个无量纲数。", "solution": "狭义相对论中的洛伦兹因子定义为\n$$\n\\gamma = \\frac{1}{\\sqrt{1 - \\beta^{2}}}, \\quad \\text{其中} \\quad \\beta \\equiv \\frac{v}{c}.\n$$\n对于动能，我们关心的量是 $\\gamma - 1$。当 $\\beta \\ll 1$ 时，直接计算 $\\gamma - 1 = \\frac{1}{\\sqrt{1 - \\beta^{2}}} - 1$ 会存在相消误差问题，因为它是在减去两个都非常接近于 $1$ 的数。\n\n通过有理化可以得到一个避免减去几乎相等数的代数变换：\n$$\n\\gamma - 1 \\;=\\; \\frac{1}{\\sqrt{1 - \\beta^{2}}} - 1 \\;=\\; \\frac{1 - \\sqrt{1 - \\beta^{2}}}{\\sqrt{1 - \\beta^{2}}}\n\\;=\\; \\frac{(1 - \\sqrt{1 - \\beta^{2}})(1 + \\sqrt{1 - \\beta^{2}})}{\\sqrt{1 - \\beta^{2}}(1 + \\sqrt{1 - \\beta^{2}})}\n$$\n$$\n=\\; \\frac{1 - (1 - \\beta^{2})}{\\sqrt{1 - \\beta^{2}}\\bigl(1 + \\sqrt{1 - \\beta^{2}}\\bigr)}\n\\;=\\; \\frac{\\beta^{2}}{\\sqrt{1 - \\beta^{2}}\\bigl(1 + \\sqrt{1 - \\beta^{2}}\\bigr)}.\n$$\n该表达式避免了在分子中减去几乎相等的量；当 $\\beta \\ll 1$ 时，它是数值稳定的。\n\n对于 $\\beta \\ll 1$，根据二项式定理进行级数展开可以得到另一个同样是数值稳定的解析近似：\n$$\n\\gamma \\;=\\; (1 - \\beta^{2})^{-1/2} \\;=\\; 1 + \\frac{1}{2}\\beta^{2} + \\frac{3}{8}\\beta^{4} + \\cdots,\n$$\n所以\n$$\n\\gamma - 1 \\;=\\; \\frac{1}{2}\\beta^{2} + \\frac{3}{8}\\beta^{4} + \\cdots.\n$$\n因为在这种情况下 $\\beta \\equiv v/c$ 极小，所以在要求的精度下，$\\beta^{4}$ 和更高阶项是可忽略不计的。具体来说，当 $\\beta \\sim 10^{-8}$ 时，有 $\\beta^{4} \\sim 10^{-32}$，所以项 $\\frac{3}{8}\\beta^{4}$ 是 $\\mathcal{O}(10^{-32})$，与首项 $\\frac{1}{2}\\beta^{2} \\sim 10^{-17}$ 相比，它比六位有效数字的精度低了许多个数量级。\n\n因此，对于所要求的数值计算，我们可以使用稳定的首项表达式\n$$\n\\gamma - 1 \\approx \\frac{1}{2}\\beta^{2} = \\frac{1}{2}\\left(\\frac{v}{c}\\right)^{2}.\n$$\n\n现在代入给定的数值（因为要求一个数值答案，所以这个代入是合理的）：\n$$\nv = 3.0 \\ \\mathrm{m\\,s^{-1}}, \\qquad c = 299{,}792{,}458 \\ \\mathrm{m\\,s^{-1}}.\n$$\n计算\n$$\n\\beta^{2} = \\left(\\frac{v}{c}\\right)^{2} = \\frac{v^{2}}{c^{2}} = \\frac{9}{(299{,}792{,}458)^{2}}.\n$$\n由于 $c$ 是精确值，$c^{2}$ 是精确整数\n$$\nc^{2} = 89{,}875{,}517{,}873{,}681{,}764,\n$$\n所以\n$$\n\\gamma - 1 \\approx \\frac{1}{2}\\beta^{2} = \\frac{9}{2\\,c^{2}} = \\frac{9}{179{,}751{,}035{,}747{,}363{,}528}.\n$$\n将这个精确有理数转换为科学记数法，\n$$\n\\gamma - 1 \\approx 5.006925252241283 \\times 10^{-17}.\n$$\n四舍五入到六位有效数字得到\n$$\n\\gamma - 1 \\approx 5.00693 \\times 10^{-17}.\n$$\n这个值是无量纲的，符合题目要求。被忽略的下一项 $\\frac{3}{8}\\beta^{4}$ 的量级是 $10^{-32}$，不影响所报告的六位有效数字。", "answer": "$$\\boxed{5.00693 \\times 10^{-17}}$$", "id": "2439862"}, {"introduction": "求解微分方程时，离散化是常用方法，但它会引入截断误差，并可能导致数值不稳定。本练习将让你通过编写代码，模拟一个基本的一维扩散过程，并探索前向时间中心空间（FTCS）格式的稳定性 [@problem_id:2439914]。你将直观地看到，当时间步长取得不合适，违反了稳定性条件时，计算结果如何会产生剧烈的、非物理的振荡，从而深刻理解数值稳定性在模拟中的核心地位。", "problem": "考虑在有限区间上具有齐次狄利克雷边界条件的一维扩散方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = D\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x\\in[0,L], \\quad t\\ge 0,\n$$\n初始条件为\n$$\nu(x,0) = \\exp\\!\\left(-\\frac{(x - L/2)^2}{2\\sigma^2}\\right),\n$$\n其中 $D$ 是扩散系数，$L$ 是区域长度，且 $\\sigma = L/20$。边界条件为\n$$\nu(0,t)=0, \\quad u(L,t)=0 \\quad \\text{for all } t\\ge 0.\n$$\n使用包含 $N_x$ 个点的均匀空间网格，因此 $\\Delta x = L/(N_x-1)$，并用恒定的时间步长 $\\Delta t$ 对时间进行离散化。内部网格点 $i=1,2,\\dots,N_x-2$ 的更新由前向时间中心空间（FTCS）格式定义\n$$\nu_i^{n+1} = u_i^{n} + r\\left(u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}\\right),\n$$\n其中 $r = D\\,\\Delta t/\\Delta x^2$，$n$ 是时间步的索引，且边界值对于所有 $n$ 满足 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$。对于下面的每个参数集，通过以下方式从指定的 $r$ 值选择 $\\Delta t$：\n$$\n\\Delta t = r\\,\\frac{\\Delta x^2}{D},\n$$\n并将解演化到最终时间 $T$，时间步数取为 $N_t = \\lceil T/\\Delta t \\rceil$。定义布尔诊断量 $b$：如果在任何时间步（包括任何更新后），任何内部网格点的值严格小于 $-10^{-12}$，则 $b$ 为真，否则为假。所有物理量均采用国际单位制（SI）：$x$ 单位为米，$t$ 单位为秒，$D$ 单位为 $\\mathrm{m^2/s}$。诊断量 $b$ 是无量纲的。\n\n测试套件（每个案例指定一套完整的参数）：\n- 案例 A：$D = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$N_x = 101$，$r = 0.25$，$T = 0.01\\,\\mathrm{s}$。\n- 案例 B：$D = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$N_x = 101$，$r = 0.5$，$T = 0.01\\,\\mathrm{s}$。\n- 案例 C：$D = 1.0\\,\\mathrm{m^2/s}$，$L = 1.0\\,\\mathrm{m}$，$N_x = 101$，$r = 0.6$，$T = 0.01\\,\\mathrm{s}$。\n\n您的程序必须按 A、B、C 的顺序计算每个案例的诊断量 $b$。您的程序应生成单行输出，其中包含三个布尔结果，以逗号分隔并用方括号括起来（例如，$[b_A,b_B,b_C]$）。", "solution": "该问题要求数值求解一维扩散方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = D\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n其空间域为 $x \\in [0,L]$，边界条件为齐次狄利克雷条件 $u(0,t) = u(L,t) = 0$。初始条件是一个高斯分布，\n$$\nu(x,0) = \\exp\\!\\left(-\\frac{(x - L/2)^2}{2\\sigma^2}\\right),\n$$\n其中 $\\sigma = L/20$。解将使用前向时间中心空间（FTCS）有限差分格式获得。主要目标是评估一个布尔诊断量 $b$，该诊断量指示在时间演化过程中，任何内部网格点的数值解是否低于一个小的负阈值 $-10^{-12}$。这个诊断量是对此格式数值稳定性的测试。\n\nFTCS 格式在具有空间步长 $\\Delta x$ 和时间步长 $\\Delta t$ 的均匀网格上离散化扩散方程。在内部网格点 $i$ 处，解 $u_i^n \\approx u(i\\Delta x, n\\Delta t)$ 的更新规则由下式给出：\n$$\nu_i^{n+1} = u_i^{n} + r\\left(u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}\\right),\n$$\n其中 $r = D\\Delta t/\\Delta x^2$ 是无量纲扩散数，在此背景下通常称为 Courant-Friedrichs-Lewy (CFL) 数。\n\n这种显式格式的稳定性由 $r$ 的值决定。冯·诺依曼稳定性分析揭示了稳定性的条件。将一个通用的傅里叶模式 $u_j^n = G^n e^{ikx_j}$ 代入有限差分方程，其中 $k$ 是波数，$G$ 是每个时间步的放大因子，我们得到：\n$$\nG = 1 + r(e^{ik\\Delta x} - 2 + e^{-ik\\Delta x}) = 1 + 2r(\\cos(k\\Delta x) - 1).\n$$\n使用三角恒等式 $1 - \\cos\\theta = 2\\sin^2(\\theta/2)$，放大因子变为：\n$$\nG = 1 - 4r\\sin^2(k\\Delta x/2).\n$$\n对于一个稳定的格式，放大因子的模长必须小于或等于 1，即 $|G| \\le 1$，这对所有可能的波数 $k$ 都成立。由于 $r  0$，条件 $G \\le 1$ 总是满足的。非平凡的条件来自 $G \\ge -1$：\n$$\n1 - 4r\\sin^2(k\\Delta x/2) \\ge -1,\n$$\n$$\n2 \\ge 4r\\sin^2(k\\Delta x/2),\n$$\n$$\nr \\le \\frac{1}{2\\sin^2(k\\Delta x/2)}.\n$$\n为确保这对所有模式都成立，我们必须考虑最坏情况，这对应于网格上可表示的最高频率模式，此时 $k\\Delta x = \\pi$，因此 $\\sin^2(k\\Delta x/2) = \\sin^2(\\pi/2) = 1$。这导出了用于扩散方程的 FTCS 格式的著名稳定性条件：\n$$\nr \\le \\frac{1}{2}.\n$$\n当此条件被违反时（$r  1/2$），数值解的高频分量会以负号被放大（$G  -1$），导致随时间呈指数增长的振荡，这是数值不稳定的一个标志。\n\n初始条件 $u(x,0)$ 在 $x \\in (0,L)$ 上严格为正，并在边界处为零。连续扩散方程遵循极值原理，该原理保证解 $u(x,t)$ 将保持非负。一个遵守此属性的离散格式是理想的。FTCS 更新可以重写为：\n$$\nu_i^{n+1} = (1 - 2r)u_i^{n} + r u_{i+1}^{n} + r u_{i-1}^{n}.\n$$\n如果 $r \\le 1/2$，则系数 $(1-2r)$ 是非负的。更新规则中的所有系数都是非负的。因此，如果时间 $n$ 的解是非负的（对于所有 $j$，$u_j^n \\ge 0$），那么在时间 $n+1$ 的更新解也将是非负的。这提供了一个离散极值原理。当 $r  1/2$ 时，系数 $(1-2r)$ 变为负数，这使得 $u_i^n$ 处的正值可以对 $u_i^{n+1}$ 产生负贡献，从而可能导致非物理的负值（下冲）。\n\n现在，我们基于这一理论基础分析三个指定的测试案例。\n- **案例 A：$r = 0.25$**。由于 $0.25  0.5$，稳定性条件得到满足。该格式是稳定的，并且离散极值原理成立。数值解预计在整个模拟过程中保持非负。因此，诊断量 $b$ 应为 `false`。\n- **案例 B：$r = 0.5$**。这是临界情况，恰好处于稳定性的极限。该格式被认为是稳定的。更新规则简化为 $u_i^{n+1} = 0.5(u_{i+1}^n + u_{i-1}^n)$。这是对邻近点的简单平均。对于非负的初始和边界数据，解将保持非负。诊断量 $b$ 应为 `false`。\n- **案例 C：$r = 0.6$**。由于 $0.6  0.5$，稳定性条件被违反。该格式是不稳定的。高频模式的放大因子其模长将大于 1。这将导致数值误差呈指数增长，从而产生大的、非物理的振荡。这些振荡将产生远超诊断阈值 $-10^{-12}$ 的负值。诊断量 $b$ 应为 `true`。\n\n实现过程将为每个案例设置网格和初始条件，计算所需的时间步数 $N_t = \\lceil T/\\Delta t \\rceil$，并迭代 FTCS 更新。在每个时间步之后，对所有内部网格点进行检查，看是否有任何值小于 $-10^{-12}$。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the 1D diffusion equation using the FTCS scheme for three\n    different parameter sets and checks for numerical instability.\n    \"\"\"\n    # Test cases defined as (D, L, Nx, r, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.25, 0.01),  # Case A\n        (1.0, 1.0, 101, 0.5, 0.01),   # Case B\n        (1.0, 1.0, 101, 0.6, 0.01),   # Case C\n    ]\n\n    results = []\n    diagnostic_threshold = -1.0e-12\n\n    for D, L, Nx, r, T in test_cases:\n        # Spatial discretization\n        dx = L / (Nx - 1)\n        x = np.linspace(0, L, Nx)\n\n        # Temporal discretization\n        dt = r * dx**2 / D\n        Nt = math.ceil(T / dt)\n\n        # Initial condition\n        sigma = L / 20.0\n        u_current = np.exp(-((x - L / 2.0)**2) / (2.0 * sigma**2))\n\n        # Enforce boundary conditions on the initial state\n        u_current[0] = 0.0\n        u_current[-1] = 0.0\n\n        diagnostic_b = False\n        \n        # Time evolution loop\n        for n in range(Nt):\n            u_next = np.copy(u_current)\n\n            # Update interior points using FTCS scheme (vectorized)\n            u_next[1:-1] = u_current[1:-1] + r * (\n                u_current[2:] - 2 * u_current[1:-1] + u_current[:-2]\n            )\n\n            # Boundary conditions are already handled as u_next[0] and u_next[-1]\n            # are not updated from their initial zero values.\n\n            # Check diagnostic condition on interior points\n            if np.any(u_next[1:-1]  diagnostic_threshold):\n                diagnostic_b = True\n                break  # Exit time loop for this case\n\n            u_current = u_next\n        \n        results.append(diagnostic_b)\n\n    # Format the output as a string e.g., \"[False,False,True]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2439914"}, {"introduction": "理论上完美的初始条件在计算世界中是不存在的。本练习将带你探索一个处于不稳定平衡状态的经典物理系统——倒立摆 [@problem_id:2439859]。你将通过模拟发现，即使初始条件在理论上是完美的平衡，计算机中不可避免的浮点舍入误差和积分器带来的截断误差，也会像一个微小的“扰动”，最终使摆“倒下”。这个实践将生动地揭示数值噪声与系统内在动力学之间微妙而关键的相互作用。", "problem": "考虑一个平面单摆，其点质量为 $m$，附着在长度为 $l$ 的无质量刚性杆上，处于大小为 $g$ 的均匀引力场中。设 $\\theta(t)$ 表示从向下垂直方向测量的角位置，因此竖直向上（倒置）的平衡位置在 $\\theta = \\pi$。设 $\\omega(t) = d\\theta/dt$ 为角速度。从牛顿第二转动定律 $\\sum \\tau = I\\, d^2\\theta/dt^2$ 出发，其中点质量在半径 $l$ 处的转动惯量为 $I = m l^2$。考虑一个与运动方向相反的线性粘性力矩，其阻尼系数为 $c$。因此，控制常微分方程和初始条件为\n$$\nm l^2 \\,\\frac{d^2\\theta}{dt^2} + c\\,\\frac{d\\theta}{dt} + m g l\\,\\sin(\\theta) = 0,\\quad \\theta(0)=\\pi,\\quad \\omega(0)=0.\n$$\n等价地，\n$$\n\\frac{d\\theta}{dt} = \\omega,\\qquad\n\\frac{d\\omega}{dt} = -\\frac{c}{m l^2}\\,\\omega - \\frac{g}{l}\\,\\sin(\\theta).\n$$\n在精确算术下，使用上述初始条件，解将在所有 $t \\ge 0$ 时保持在不稳定平衡点 $\\theta(t) \\equiv \\pi$。然而，在浮点计算中，舍入误差（例如，$\\sin(\\pi)$ 无法表示为精确的零）和时间离散化带来的截断误差可以充当有效扰动，导致系统偏离并最终从竖直向上的位置翻倒。\n\n你的任务是编写一个程序，对该系统进行数值积分，并报告在几个指定的测试用例下的翻倒时间。这些测试用例在数值精度、时间步长和积分器方面有所不同。将翻倒时间 $t_{\\mathrm{tip}}$ 定义为第一个满足以下条件的时刻 $t \\ge 0$：与最近的竖直向上构型的缠绕角偏差满足\n$$\nd_{\\mathrm{upright}}(\\theta(t)) \\equiv \\min_{k \\in \\mathbb{Z}} \\left| \\theta(t) - (2k+1)\\pi \\right| \\ge \\varphi_{\\mathrm{tip}},\n$$\n其中 $\\varphi_{\\mathrm{tip}}$ 是一个固定的阈值。在代码中，这可以通过以下变换将 $\\theta$ 映射到其相对于 $\\pi$ 的最近表示来实现：\n$$\n\\phi = \\left((\\theta - \\pi) + \\pi \\bmod 2\\pi\\right) - \\pi,\n$$\n然后取 $d_{\\mathrm{upright}}(\\theta) = |\\phi|$。使用以下物理参数：$m = 1\\,\\mathrm{kg}$，$l = 1\\,\\mathrm{m}$，$g = 9.81\\,\\mathrm{m/s}^2$，$c = 0\\,\\mathrm{kg\\,m^2/s}$。角度必须以弧度为单位，时间必须以秒为单位。在每个测试用例中，使用所选浮点精度下的精确初始条件 $\\theta(0)=\\pi$ 和 $\\omega(0)=0$。将翻倒阈值设为 $\\varphi_{\\mathrm{tip}} = 0.1$，有限时间范围设为 $T_{\\max} = 10.0$；如果在此时间范围内未发生翻倒，则该用例报告的时间即为 $T_{\\max}$。\n\n实现三种单步显式时间积分器：\n- 前向（显式）欧拉法，源于对 $\\frac{d\\mathbf{y}}{dt}$ 的有限差分近似，其中 $\\mathbf{y} = (\\theta,\\omega)$，步长为 $\\Delta t$：\n  $$\n  \\theta_{n+1} = \\theta_{n} + \\Delta t\\,\\omega_{n},\\qquad\n  \\omega_{n+1} = \\omega_{n} + \\Delta t\\left(-\\frac{c}{m l^2}\\,\\omega_{n} - \\frac{g}{l}\\,\\sin(\\theta_n)\\right).\n  $$\n- 辛（半隐式）欧拉法，用于无阻尼情况 $c=0$：\n  $$\n  \\omega_{n+1} = \\omega_{n} + \\Delta t\\left(- \\frac{g}{l}\\,\\sin(\\theta_n)\\right),\\qquad\n  \\theta_{n+1} = \\theta_{n} + \\Delta t\\,\\omega_{n+1}.\n  $$\n- 经典四阶龙格-库塔法（4阶），应用于系统 $\\frac{d\\theta}{dt}=\\omega$，$\\frac{d\\omega}{dt} = -\\frac{c}{m l^2}\\,\\omega - \\frac{g}{l}\\,\\sin(\\theta)$。\n\n对于每个积分器，以大小为 $\\Delta t$ 的步长向前推进，直到检测到翻倒或时间达到 $T_{\\max}$。在每次模拟中全程使用指定精度的浮点运算。\n\n测试套件。使用以下四个用例来探究不同来源的计算误差：\n- 用例 1：积分器 = Runge–Kutta 4，精度 = 64位浮点数，$\\Delta t = 0.001$。\n- 用例 2：积分器 = Runge–Kutta 4，精度 = 32位浮点数，$\\Delta t = 0.001$。\n- 用例 3：积分器 = 前向欧拉法，精度 = 32位浮点数，$\\Delta t = 0.005$。\n- 用例 4：积分器 = 辛欧拉法，精度 = 64位浮点数，$\\Delta t = 0.01$。\n\n所有其他参数在各个用例中均相同：$m = 1$，$l = 1$，$g = 9.81$，$c = 0$，$\\varphi_{\\mathrm{tip}} = 0.1$，$T_{\\max} = 10.0$。角度以弧度为单位；时间以秒为单位。\n\n要求的最终输出。您的程序应生成单行输出，其中包含上述四个用例的翻倒时间（单位为秒），每个时间都四舍五入到6位小数，并按上述用例的顺序聚合到一个单独的、用逗号分隔且无空格的Python风格列表中。例如，输出行的格式为 $[\\text{t1},\\text{t2},\\text{t3},\\text{t4}]$，其中每个 $\\text{t\\#}$ 是一个以秒为单位的浮点数。如果一个用例在 $T_{\\max}$ 之前没有翻倒，则该条目输出精确的 $10.000000$。", "solution": "所提出的问题是有效的。这是一个计算物理学中适定的初值问题，其科学基础是经典力学和数值分析。为得到唯一且有意义的解所需的所有必要参数、条件和定义均已提供。该任务旨在探究计算误差——特别是舍入误差和截断误差——对处于不稳定平衡点的摆的数值模拟稳定性的影响。\n\n单摆的控制方程以二阶常微分方程（ODE）的形式给出，为了进行数值积分，它被转换为一个包含两个一阶ODE的方程组。设状态向量为 $\\mathbf{y}(t) = [\\theta(t), \\omega(t)]^T$。系统动力学由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$ 描述，其中：\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{pmatrix} \\omega \\\\ -\\frac{g}{l}\\sin(\\theta) \\end{pmatrix}\n$$\n问题指定了初始条件 $\\mathbf{y}(0) = [\\pi, 0]^T$，这对应于摆在其最高点上完美平衡的状态。在一个具有精确算术的完美数学世界中，系统将无限期地保持在这种不稳定平衡状态，因为 $\\mathbf{f}([\\pi, 0]^T) = [0, -(g/l)\\sin(\\pi)]^T = [0, 0]^T$。\n\n然而，数字计算机无法执行精确算术。与精确解的偏差由两种主要的计算误差来源驱动：\n\n1.  **舍入误差**：计算机使用有限数量的比特来表示实数，这导致了浮点近似。例如，超越数 $\\pi$ 无法被精确表示。当我们初始化 $\\theta(0) = \\pi$ 时，实际上是将其设置为一个邻近的机器可表示数 $\\pi_{fp}$。因此，项 $\\sin(\\theta(0))$ 的计算结果并非精确的零。对于 IEEE 754 双精度（64位），$\\sin(\\pi_{64}) \\approx 1.22 \\times 10^{-16}$，而对于单精度（32位），$\\sin(\\pi_{32}) \\approx -8.74 \\times 10^{-8}$。这个非零值充当了初始扰动，提供了一个非零的角加速度，将系统推离平衡点。对于较低精度的算术，这种初始舍入误差的量级要大得多。\n\n2.  **截断误差**：数值积分方案使用大小为 $\\Delta t$ 的离散时间步来近似系统的连续演化。这种离散化在每一步都会引入一个误差，称为局部截断误差。在许多步之后累积的全局误差取决于积分器的阶数。对于像前向或辛欧拉法这样的一阶方法，全局误差与 $\\mathcal{O}(\\Delta t)$ 成正比。对于像经典龙格-库塔法（RK4）这样的四阶方法，全局误差要小得多，与 $\\mathcal{O}(\\Delta t^4)$ 成正比。这种误差在每个时间步都充当持续的扰动。\n\n在不稳定平衡点 $\\theta = \\pi$ 附近，设 $\\theta(t) = \\pi + \\epsilon(t)$，其中 $\\epsilon(t)$ 是一个小的角偏差。线性化运动方程得到 $\\sin(\\theta) = \\sin(\\pi + \\epsilon) = -\\sin(\\epsilon) \\approx -\\epsilon$。扰动的ODE变为：\n$$\n\\frac{d^2\\epsilon}{dt^2} - \\frac{g}{l}\\epsilon = 0\n$$\n该方程的通解是 $\\epsilon(t) = C_1 e^{\\sqrt{g/l} t} + C_2 e^{-\\sqrt{g/l} t}$。带有正指数的项表明，任何初始扰动 $\\epsilon_{eff}$ 都会随时间指数级增长。当偏差达到阈值 $\\varphi_{\\mathrm{tip}}$ 时的翻倒时间 $t_{\\mathrm{tip}}$ 可估计为：\n$$\nt_{\\mathrm{tip}} \\approx \\frac{1}{\\sqrt{g/l}} \\ln\\left(\\frac{\\varphi_{\\mathrm{tip}}}{\\epsilon_{eff}}\\right)\n$$\n这表明翻倒时间取决于有效初始扰动 $\\epsilon_{eff}$ 的对数，而 $\\epsilon_{eff}$ 是舍入误差和截断误差的综合结果。\n\n算法上的方法是实现一个通用的数值模拟框架。摆的状态存储在一个包含2个元素的NumPy数组 $\\mathbf{y} = [\\theta, \\omega]$ 中。算法的核心是一个时间步进循环，用于模拟从 $t=0$ 到 $T_{\\max}=10.0$ 的动力学过程。对于四个测试用例中的每一个，我们都使用特定的积分器、浮点精度和时间步长 $\\Delta t$ 来配置模拟。\n\n**精度控制**：浮点精度（32位或64位）通过为状态向量以及计算中使用的所有物理和数值常数（例如 $g, l, \\pi, \\Delta t$）指定 `dtype` 来管理。这确保了在给定用例的模拟中，所有算术运算都在指定的精度下执行，从而正确地模拟了预期的舍入误差源。\n\n**积分器实现**：三种显式单步积分器被实现为函数，这些函数接受当前状态 $\\mathbf{y}_n$ 并返回下一个时间步的状态 $\\mathbf{y}_{n+1}$：\n- **前向欧拉法**：一种简单的一阶方法：$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\Delta t \\, \\mathbf{f}(\\mathbf{y}_n)$。\n- **辛欧拉法**：一种一阶方法，对于哈密顿系统具有良好的长期能量守恒特性。对于我们的系统，更新方式是：先更新 $\\omega_{n+1} = \\omega_n + \\Delta t f_{\\omega}(\\theta_n)$，然后更新 $\\theta_{n+1} = \\theta_n + \\Delta t f_{\\theta}(\\omega_{n+1}) = \\theta_n + \\Delta t \\, \\omega_{n+1}$。\n- **龙格-库塔 4 (RK4)**：一种提供更高精度的四阶方法：$\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$，其中 $\\mathbf{k}_i$ 是导数函数 $\\mathbf{f}$ 的中间评估值。\n\n**翻倒条件**：在每个时间步之后，计算与最近的竖直向上平衡点的角偏差 $d_{\\mathrm{upright}}(\\theta)$。所提供的变换 $\\phi = \\left((\\theta - \\pi) + \\pi \\bmod 2\\pi\\right) - \\pi$ 将总角度 $\\theta$ 正确地映射到与形式为 $(2k+1)\\pi$ 的最近平衡点的偏差。当 $|\\phi| \\ge \\varphi_{\\mathrm{tip}} = 0.1$ 时，该用例的模拟停止，并将当前时间报告为 $t_{\\mathrm{tip}}$。如果在 $T_{\\max}$ 之前未满足此条件，则报告 $T_{\\max}$。\n\n相对翻倒时间预计将取决于误差的量级。用例3（前向欧拉法，32位）结合了大的舍入误差和大的截断误差，预计将最快翻倒。用例2（RK4，32位）有大的舍入误差但截断误差小，翻倒速度比用例3慢。用例4（辛欧拉法，64位）舍入误差小，但由于其一阶性质和较大的 $\\Delta t$，截断误差较大，翻倒速度比32位用例慢。用例1（RK4，64位）的舍入误差和截断误差都非常小，预计将是最稳定的，很可能在时间范围内不会翻倒。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the pendulum tipping problem for the four specified test cases.\n    \"\"\"\n\n    test_cases = [\n        {'integrator': 'Runge-Kutta 4', 'precision': 64, 'dt': 0.001},\n        {'integrator': 'Runge-Kutta 4', 'precision': 32, 'dt': 0.001},\n        {'integrator': 'Forward Euler', 'precision': 32, 'dt': 0.005},\n        {'integrator': 'Symplectic Euler', 'precision': 64, 'dt': 0.01},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Set up precision for the current case\n        dtype = np.float32 if case['precision'] == 32 else np.float64\n\n        # Define numerical and physical parameters with the specified precision\n        g = dtype(9.81)\n        l = dtype(1.0)\n        phi_tip = dtype(0.1)\n        T_max = 10.0  # Loop control, does not need to be typed\n        dt = dtype(case['dt'])\n        pi = dtype(np.pi)\n        \n        g_over_l = g / l\n\n        # Initial state vector [theta, omega]\n        state = np.array([pi, dtype(0.0)], dtype=dtype)\n        \n        # --- Integrator definitions ---\n        \n        def f_ode(y_vec, g_l_const):\n            \"\"\"ODE function dy/dt = f(y).\"\"\"\n            theta, omega = y_vec[0], y_vec[1]\n            return np.array([omega, -g_l_const * np.sin(theta)], dtype=dtype)\n\n        def rk4_step(y, dt_val, g_l_const):\n            \"\"\"Performs one step of the RK4 method.\"\"\"\n            dt_half = dt_val / dtype(2.0)\n            dt_sixth = dt_val / dtype(6.0)\n            \n            k1 = f_ode(y, g_l_const)\n            k2 = f_ode(y + dt_half * k1, g_l_const)\n            k3 = f_ode(y + dt_half * k2, g_l_const)\n            k4 = f_ode(y + dt_val * k3, g_l_const)\n            \n            return y + dt_sixth * (k1 + dtype(2.0) * k2 + dtype(2.0) * k3 + k4)\n\n        def forward_euler_step(y, dt_val, g_l_const):\n            \"\"\"Performs one step of the Forward Euler method.\"\"\"\n            return y + dt_val * f_ode(y, g_l_const)\n        \n        def symplectic_euler_step(y, dt_val, g_l_const):\n            \"\"\"Performs one step of the Symplectic Euler method.\"\"\"\n            theta, omega = y[0], y[1]\n            # Update omega first using old theta\n            omega_next = omega - dt_val * g_l_const * np.sin(theta)\n            # Update theta using new omega\n            theta_next = theta + dt_val * omega_next\n            return np.array([theta_next, omega_next], dtype=dtype)\n\n        integrators = {\n            'Runge-Kutta 4': rk4_step,\n            'Forward Euler': forward_euler_step,\n            'Symplectic Euler': symplectic_euler_step,\n        }\n        integrator_func = integrators[case['integrator']]\n\n        # --- Simulation loop ---\n        \n        tip_time = T_max\n        num_steps = int(np.ceil(T_max / case['dt']))\n        \n        for i in range(num_steps):\n            state = integrator_func(state, dt, g_over_l)\n            current_time = (i + 1) * case['dt']\n            \n            # Check for tipping condition\n            theta = state[0]\n            # Calculate deviation from the nearest upright equilibrium\n            # The formula phi = ( (theta - pi) + pi ) mod 2*pi - pi can be implemented as:\n            dev_from_initial_pi = theta - pi\n            phi = np.mod(dev_from_initial_pi + pi, dtype(2.0) * pi) - pi\n            \n            if np.abs(phi) = phi_tip:\n                tip_time = current_time\n                break\n        \n        results.append(tip_time)\n\n    # Format and print the final output\n    formatted_results = [f\"{t:.6f}\" for t in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2439859"}]}