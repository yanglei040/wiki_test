{"hands_on_practices": [{"introduction": "理论算法通常运行在理想化的精确算术之上，但计算机在实践中使用有限精度的浮点数，这会引入舍入误差。本练习将让你亲手体验一个看似微不足道的主元如何导致这些误差灾难性地放大，从而得到完全错误的答案。通过对比使用和不使用部分主元法的结果，你将清楚地看到，主元法不仅是一种优化，更是保证数值稳定性的必要手段。[@problem_id:2193047]", "problem": "考虑以下线性方程组：\n$$\n\\begin{align*}\n(2.00 \\times 10^{-4}) x_1 + 2.00 x_2 = 4.00 \\\\\n1.00 x_1 + 3.00 x_2 = 5.00\n\\end{align*}\n$$\n你需要使用高斯消元法解这个方程组，但所有计算都必须使用一种简化的浮点表示法，称为**三位数截断算术**。在这种算术系统中，数字首先被写成规格化十进制形式，$\\pm 0.d_1d_2d_3d_4... \\times 10^n$，其中 $d_1 \\in \\{1, 2, \\dots, 9\\}$。然后通过“截断”第三位之后的所有数字来存储该数，得到形式 $\\pm 0.d_1d_2d_3 \\times 10^n$。这种截断发生在每次独立的算术运算（加、减、乘、除）之后。\n\n使用**部分主元法**的高斯消元法计算解向量 $\\mathbf{x} = [x_1, x_2]^T$。将你的最终答案表示为解向量的两个分量。", "solution": "我们应用带有部分主元法的高斯消元法，并采用三位数截断算术（每次操作后以三位有效数字的规格化形式存储数字）。\n\n从增广矩阵开始\n$$\n\\left[\\begin{array}{cc|c}\n2.00\\times 10^{-4} & 2.00 & 4.00\\\\\n1.00 & 3.00 & 5.00\n\\end{array}\\right].\n$$\n对第1列进行部分主元选取，比较 $|2.00\\times 10^{-4}|$ 和 $|1.00|$，因此我们交换两行：\n$$\n\\left[\\begin{array}{cc|c}\n1.00 & 3.00 & 5.00\\\\\n2.00\\times 10^{-4} & 2.00 & 4.00\n\\end{array}\\right].\n$$\n消元乘子\n$$\n\\ell_{21}=\\text{chop}_{3}\\left(\\frac{2.00\\times 10^{-4}}{1.00}\\right)=2.00\\times 10^{-4}.\n$$\n每次运算后进行截断，更新第2行的元素：\n- 新的 $a_{21}$：\n$$\n\\text{chop}_{3}\\left(2.00\\times 10^{-4}-\\ell_{21}\\cdot 1.00\\right)=\\text{chop}_{3}\\left(2.00\\times 10^{-4}-2.00\\times 10^{-4}\\right)=0.\n$$\n- 新的 $a_{22}$：\n$$\n\\ell_{21}\\cdot a_{12}=\\text{chop}_{3}\\left((2.00\\times 10^{-4})\\cdot 3.00\\right)=6.00\\times 10^{-4},\n$$\n$$\na_{22}^{(new)}=\\text{chop}_{3}\\left(2.00-6.00\\times 10^{-4}\\right)=\\text{chop}_{3}(1.9994)=1.99.\n$$\n- 新的 $b_{2}$：\n$$\n\\ell_{21}\\cdot b_{1}=\\text{chop}_{3}\\left((2.00\\times 10^{-4})\\cdot 5.00\\right)=1.00\\times 10^{-3},\n$$\n$$\nb_{2}^{(new)}=\\text{chop}_{3}\\left(4.00-1.00\\times 10^{-3}\\right)=\\text{chop}_{3}(3.999)=3.99.\n$$\n因此上三角系统为\n$$\n\\begin{cases}\n1.00\\,x_{1}+3.00\\,x_{2}=5.00,\\\\\n1.99\\,x_{2}=3.99.\n\\end{cases}\n$$\n每次运算后进行截断，进行回代：\n$$\nx_{2}=\\text{chop}_{3}\\left(\\frac{3.99}{1.99}\\right)=\\text{chop}_{3}(2.005025\\ldots)=2.00.\n$$\n然后\n$$\na_{12}\\,x_{2}=\\text{chop}_{3}(3.00\\cdot 2.00)=6.00,\\quad\nb_{1}-a_{12}x_{2}=\\text{chop}_{3}(5.00-6.00)=-1.00,\n$$\n$$\nx_{1}=\\text{chop}_{3}\\left(\\frac{-1.00}{1.00}\\right)=-1.00.\n$$\n因此，在带有部分主元法的三位数截断算术下，解向量为 $x_{1}=-1.00$ 和 $x_{2}=2.00$。", "answer": "$$\\boxed{\\begin{pmatrix}-1.00 & 2.00\\end{pmatrix}}$$", "id": "2193047"}, {"introduction": "在理解了主元法的重要性之后，我们将其应用于更具挑战性的场景。现实世界的物理模型常常包含尺度差异巨大的方程，这给数值求解带来了困难。本练习提供了一系列精心设计的线性系统，它们模拟了在物理建模中可能遇到的病态情况。你的任务是使用专业的线性代数库来解决这些问题，这将展示内置了稳健主元策略的算法在处理复杂问题时的强大能力和可靠性。[@problem_id:2397351]", "problem": "考虑三个独立的线性系统，它们是在将异构物理模型转换为国际单位制（SI）后得到的。系数已经包含了所有必要的单位转换，并且每个系统的未知数都具有指定的国际单位制（SI）单位。由于方程和系数之间的数量级差异巨大，必须精确地获得数值解。对于每个系统，给定矩阵 $\\mathbf{A}$ 和右侧向量 $\\mathbf{b}$，求解未知向量 $\\mathbf{x} = [x_1, x_2, x_3]^{\\mathsf{T}}$，并将解的分量以指定SI单位的实数形式报告（输出中不包含单位符号；数值应按每个系统所述的单位进行解释）。您的程序必须处理以下测试套件，并按规定格式生成汇总输出。\n\n系统A（异构单位，理想情况）：\n- 未知数：$x_1$ 单位为 $\\mathrm{W}\\,\\mathrm{m}^{-1}\\,\\mathrm{K}^{-1}$，$x_2$ 单位为 $\\mathrm{C}$，$x_3$ 单位为 $\\mathrm{m}$。\n- 系数矩阵\n$$\n\\mathbf{A}_A =\n\\begin{bmatrix}\n10^{9} & 3 & -2\\times 10^{-6} \\\\\n2\\times 10^{-3} & -5\\times 10^{6} & 7 \\\\\n4 & 10^{-9} & 3\\times 10^{3}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_A =\n\\begin{bmatrix}\n1999999990.999998 \\\\\n15000007.004 \\\\\n3007.999999997\n\\end{bmatrix}\n$$\n\n系统B（具有不同尺度的近奇异结构）：\n- 未知数：$x_1, x_2, x_3$ 为无量纲。\n- 系数矩阵\n$$\n\\mathbf{A}_B =\n\\begin{bmatrix}\n10^{-12} & 1 & 1 \\\\\n1 & 1 & 1 \\\\\n1 & 1 & 1+10^{-12}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_B =\n\\begin{bmatrix}\n10^{-12} \\\\\n1 \\\\\n1+10^{-12}\n\\end{bmatrix}\n$$\n\n系统C（主对角线首项为零且系数变化极大）：\n- 未知数：$x_1$ 单位为 $\\mathrm{m}$，$x_2$ 单位为 $\\mathrm{Pa}$，$x_3$ 单位为 $\\mathrm{s}$。\n- 系数矩阵\n$$\n\\mathbf{A}_C =\n\\begin{bmatrix}\n0 & 10^{5} & 1 \\\\\n10^{-10} & 1 & 1 \\\\\n1 & 0 & 10^{-5}\n\\end{bmatrix}\n$$\n- 右侧向量\n$$\n\\mathbf{b}_C =\n\\begin{bmatrix}\n200003 \\\\\n5.0000000001 \\\\\n1.00003\n\\end{bmatrix}\n$$\n\n要求的输出格式：\n- 对于每个系统，计算解向量 $\\mathbf{x}$ 并将每个分量四舍五入到 $8$ 位有效数字。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个条目是对应系统（按A、B、C的顺序）的三个四舍五入后的解分量列表。例如，输出必须如下所示\n$$\n[\\,[x_{1,A},x_{2,A},x_{3,A}],\\,[x_{1,B},x_{2,B},x_{3,B}],\\,[x_{1,C},x_{2,C},x_{3,C}]\\,]\n$$\n其中每个 $x$ 是一个四舍五入到 $8$ 位有效数字的实数。", "solution": "所提出的问题是有效的。它是一组适定（well-posed）的线性代数问题，这些问题植根于数值分析并与计算物理相关。所有必要的数据都已提供，并且没有科学或逻辑上的矛盾。问题的核心是求解三个不同系统的矩阵方程 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$，每个系统都旨在测试所用数值方法的稳健性。这些矩阵表现出对朴素算法具有挑战性的特征，例如系数数量级的巨大变化、近奇异性以及主对角线上存在零。这些正是数值稳定算法不仅是可取的，而且是必需的条件。\n\n解决此类系统的基本原理是高斯消元法（Gaussian elimination）。然而，如果主元（用于归一化的对角元素）为零或相对于矩阵中的其他元素非常小，那么高斯消元法的朴素实现是数值不稳定的。这可能导致除以零或舍入误差的灾难性放大。确保数值稳定性的标准且正确的方法是带主元选择策略（pivoting strategy）的高斯消元法。\n\n最常见的策略是部分主元法（partial pivoting）。在消元过程的第 $k$ 步，算法在第 $k$ 列中从第 $k$ 行到最后一行搜索绝对值最大的元素。然后将包含此元素的行与第 $k$ 行交换。这确保了主元在数量级上尽可能大，从而最小化了消元步骤中使用的乘数，进而控制了数值误差的增长。系统 $\\mathbf{A}_C$ 在位置 $(1,1)$ 处有一个 $0$，这使得主元选择成为必须；如果不进行行交换，算法会立即因除以零而失败。系统 $\\mathbf{A}_A$ 和 $\\mathbf{A}_B$ 的系数数量级差异巨大，使它们成为病态（ill-conditioned）矩阵。对于此类矩阵，主元选择对于获得精确解至关重要。\n\n在现代计算实践中，人们不会从头开始实现此算法。相反，人们依赖于标准科学计算库中提供的高度优化、经过严格测试且数值稳定的实现。这些库，例如 LAPACK (Linear Algebra PACKage)，构成了像 NumPy 这样的环境中线性代数例程的基础。函数 `numpy.linalg.solve` 内部使用一个 LAPACK 求解器（通常是 `_gesv` 的一个变体），该求解器实现了带部分主元法的 LU 分解。这是完成此项任务的合适且专业的工具。\n\n解决每个系统的步骤如下：\n$1$. 对于每个系统（A、B、C），将系数矩阵 $\\mathbf{A}$ 和右侧向量 $\\mathbf{b}$ 定义为 `float64` 类型的数值数组，以获得最大精度。\n$2$. 调用 `numpy.linalg.solve(A, b)` 函数来计算解向量 $\\mathbf{x}$。该函数通过其底层的主元选择策略自动处理矩阵带来的数值挑战。\n$3$. 问题要求将所得解向量 $\\mathbf{x}$ 的每个分量四舍五入到 $8$ 位有效数字。这需要一个特定的舍入函数，该函数要考虑数值的数量级。对于一个非零数 $x$，为达到 $n$ 位有效数字而必须四舍五入到的小数位数 $d$ 由公式 $d = n - 1 - \\lfloor\\log_{10}|x|\\rfloor$ 给出。\n$4$. 收集所有三个系统的四舍五入后的解向量，并按照问题陈述中指定的格式将其格式化为单个字符串。分析检查表明，精确解是整数向量：$\\mathbf{x}_A = [2, -3, 1]^{\\mathsf{T}}$，$\\mathbf{x}_B = [1, -1, 1]^{\\mathsf{T}}$ 和 $\\mathbf{x}_C = [1, 2, 3]^{\\mathsf{T}}$。一个稳健的数值求解器应该能高精度地恢复这些解，并且在四舍五入后，结果应与这些精确值相匹配。因此，输出将是一个包含这些浮点数的列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef round_to_significant_digits(x, n):\n    \"\"\"\n    Rounds a number x to n significant digits.\n    \"\"\"\n    if x == 0 or not np.isfinite(x):\n        return float(x) if isinstance(x, (int, float)) else x\n    \n    power = n - 1 - math.floor(math.log10(abs(x)))\n    factor = 10**power\n    \n    return round(x * factor) / factor\n\ndef solve():\n    \"\"\"\n    Solves the three linear systems defined in the problem statement\n    using a robust numerical solver and formats the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([\n                [1e9, 3, -2e-6],\n                [2e-3, -5e6, 7],\n                [4, 1e-9, 3e3]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                1999999990.999998,\n                15000007.004,\n                3007.999999997\n            ], dtype=np.float64)\n        },\n        {\n            \"A\": np.array([\n                [1e-12, 1, 1],\n                [1, 1, 1],\n                [1, 1, 1 + 1e-12]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                1e-12,\n                1,\n                1 + 1e-12\n            ], dtype=np.float64)\n        },\n        {\n            \"A\": np.array([\n                [0, 1e5, 1],\n                [1e-10, 1, 1],\n                [1, 0, 1e-5]\n            ], dtype=np.float64),\n            \"b\": np.array([\n                200003,\n                5.0000000001,\n                1.00003\n            ], dtype=np.float64)\n        }\n    ]\n\n    results = []\n    num_significant_digits = 8\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        \n        # Solve the linear system using numpy's robust solver, which\n        # employs LU decomposition with partial pivoting.\n        x = np.linalg.solve(A, b)\n        \n        # Round each component of the solution vector to 8 significant digits.\n        x_rounded = [round_to_significant_digits(val, num_significant_digits) for val in x]\n        \n        results.append(x_rounded)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a Python list is used for the inner lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397351"}, {"introduction": "作为本章的收尾，我们将对数值误差进行更深层次的探索。虽然主元法可以有效地抑制浮点运算中的舍入误差，但如果我们能够完全消除这种误差呢？这项高级练习将挑战你使用精确的有理数算术来实现一个求解器。通过精确求解像希尔伯特矩阵（Hilbert matrix）这样的著名病态系统，你将对矩阵的内在属性（如病态性）与有限精度计算所带来的影响（如舍入误差）之间的区别有更深刻的理解。[@problem_id:2397350]", "problem": "您需要设计并实现一个健壮的求解器，该求解器使用在精确有理数算术中执行的、带有部分主元法（PP）的高斯消元法（GE），用于求解方形线性系统。目标是通过将每个条目表示为有理数来完全消除舍入误差，并使用主元法来确保正确的行选择以及对病态系统进行可靠的奇异性检测。您必须从线性系统的基本定义以及解集在初等行变换下的不变性出发。在消元或回代阶段，不要引入任何浮点近似；所有计算都必须使用有理数精确执行。\n\n基本原理与设定：一个方形线性系统由 $A \\, x = b$ 给出，其中 $A \\in \\mathbb{Q}^{n \\times n}$ 且 $b \\in \\mathbb{Q}^{n}$。通过初等行变换关联的两个系统具有相同的解集。高斯消元法应用一系列有限的行交换、行缩放和行加法操作，将系统简化为上三角形式，之后如果系统非奇异，则通过回代法恢复解。部分主元法在每一列 $k$ 中，从索引 $i \\in \\{k, k+1, \\dots, n-1\\}$ 中选择在该列具有最大绝对值主元项的一行，并在消元前将其交换到位置 $k$，这可以避免除以零并减轻小主元的影响。在精确有理数算术中，主元法还提供了一种通过计算非零主元数量来检测奇异性的原则性方法。\n\n您的实现要求：\n- 对所有矩阵和向量条目使用精确有理数算术，实现带有部分主元法的高斯消元法。将所有数字表示为有理数，并确保在域 $\\mathbb{Q}$ 中的每次除法都是精确的。\n- 在每一步 $k$，对于 $i \\ge k$，选择具有最大 $|A_{ik}|$ 的主元行。如果最大值为 $0$，则声明列 $k$ 没有主元，并继续处理下一列以进行秩计算。跟踪非零主元的数量以获得秩。\n- 如果系统是满秩 $n$，则执行精确回代以计算唯一解 $x \\in \\mathbb{Q}^{n}$。如果系统是秩亏的，则报告计算出的秩 $r < n$，并且不要尝试生成一个特解。\n\n测试套件：\n实现您的求解器并在以下四个测试用例上运行它。所有矩阵 $A$ 和向量 $b$ 都必须在 $\\mathbb{Q}$ 上精确构造，并且所有右侧项 $b$ 都必须按照指定的方式精确形成。\n\n- 测试用例 $1$（理想情况，病态但非奇异）：设 $n = 5$，设 $A$ 为希尔伯特（Hilbert）矩阵，其条目为 $A_{ij} = 1/(i+j-1)$，其中 $i,j \\in \\{1,2,3,4,5\\}$，并设精确解为 $x^{\\star} = [1,1,1,1,1]^{\\top}$。在 $\\mathbb{Q}^{n}$ 中精确构造 $b = A \\, x^{\\star}$。\n- 测试用例 $2$（更难的病态情况，非奇异）：设 $n = 7$，设 $A$ 为希尔伯特（Hilbert）矩阵，其条目为 $A_{ij} = 1/(i+j-1)$，其中 $i,j \\in \\{1,2,3,4,5,6,7\\}$，并设精确解为 $x^{\\star} = [1,-1,1,-1,1,-1,1]^{\\top}$。精确构造 $b = A \\, x^{\\star}$。\n- 测试用例 $3$（奇异但相容）：设 $A$ 为 $3 \\times 3$ 矩阵，其行为 $[1,2,3]$、$[2,4,6]$、$[1,2,3]$，并设 $b = [6,12,6]^{\\top}$。该系统有无穷多解；您的求解器必须检测到奇异性并报告其秩。\n- 测试用例 $4$（边界奇异情况）：设 $A$ 为 $1 \\times 1$ 矩阵 $[0]$，并设 $b = [0]$。该系统相容且有无穷多解；您的求解器必须报告其秩。\n\n每个测试用例的所需输出：\n- 对于测试用例 $1$ 和 $2$：生成一个包含三个项目的列表 $[\\text{ok}, r_{\\infty}, e_{\\infty}]$，其中 $\\text{ok}$ 是一个布尔值，当且仅当计算出的精确解 $x$ 在 $\\mathbb{Q}$ 中与 $x^{\\star}$ 的每个条目完全匹配时为真， $r_{\\infty} = \\max_{i} |(A x - b)_{i}|$ 是最大绝对残差，以浮点数形式报告，而 $e_{\\infty} = \\max_{i} |(x - x^{\\star})_{i}|$ 是最大绝对误差，以浮点数形式报告。\n- 对于测试用例 $3$ 和 $4$：生成矩阵 $A$ 的整数秩 $r$，该秩是通过在带有部分主元法的消元过程中计算非零主元的数量得到的。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该行必须按顺序包含四个条目，分别对应于测试用例 $1$ 到 $4$。前两个条目必须是如上所述的列表，后两个条目必须是整数。例如，一个可接受的格式是 $[[\\text{True}, 0.0, 0.0],[\\text{True}, 0.0, 0.0],1,0]$。此问题不涉及任何物理单位，也不使用任何角度。\n\n约束条件：\n- 在消元或回代逻辑的任何地方都不能使用浮点数算术。求解器中的所有算术运算都必须在 $\\mathbb{Q}$ 上完成。\n- 您必须按照描述实现部分主元法和秩检测。您不能依赖外部的线性代数求解器或符号代数系统。", "solution": "该问题要求设计并实现一个用于求解方形线性系统 $A x = b$ 的求解器，其中矩阵 $A \\in \\mathbb{Q}^{n \\times n}$ 和向量 $b \\in \\mathbb{Q}^{n}$ 定义在有理数域上。解决方案必须采用带有部分主元法（GE-PP）的高斯消元法，并且所有算术运算都在 $\\mathbb{Q}$ 中精确执行，以排除任何舍入误差。\n\n其基本原理是线性系统的解集在初等行变换下保持不变。高斯消元法系统地应用这些操作——行交换、行缩放以及将一行的倍数加到另一行——以将原始系统转换为一个等价但更易于求解的上三角形式。\n\n我们的方法论如下：\n\n首先，我们将所有数值表示为有理数。Python 的 `fractions.Fraction` 类很适合此目的，因为它对表示分数 $\\frac{p}{q}$（其中 $p$ 和 $q$ 是整数）的对象执行精确算术。这种方法完全规避了浮点数算术固有的精度和稳定性问题，这对于测试套件中的病态希尔伯特（Hilbert）矩阵尤为关键。\n\n该算法对增广矩阵 $[A|b]$ 进行操作。它通过两个主要阶段进行：前向消元和回代。\n\n前向消元阶段旨在将矩阵 $A$ 简化为行阶梯形。该过程遍历列 $k$（从 $0$ 到 $n-1$）。在每一步中，我们确定到目前为止已处理矩阵的秩，用变量 `rank` 表示。\n$1$. **主元选择**：对于当前列 $k$，我们在行 $i \\ge \\text{rank}$ 中搜索具有最大绝对值的条目。设该主元条目为 $A_{p,k}$。然后我们将整个第 $p$ 行与第 `rank` 行交换。这就是部分主元法。在精确算术中，其目的是系统地处理零主元，并为秩的确定提供一种一致的方法。\n$2$. **秩的确定**：如果选定的主元元素为零，则意味着列 $k$ 线性依赖于前面的主元列。在这种情况下，不对该列执行消元，秩不增加，算法继续处理下一列 $k+1$。\n$3$. **消元**：如果主元 $A_{\\text{rank},k}$ 非零，我们用它来消去同一列中其下方的所有条目。对于每一行 $i > \\text{rank}$，我们计算一个乘数 $m_{i,k} = A_{i,k} / A_{\\text{rank},k}$。这个除法是精确的。然后我们通过操作 $R_i \\leftarrow R_i - m_{i,k} R_{\\text{rank}}$ 来更新该行。这个操作应用于整个增广行，从列 $k$ 到末尾。在列 $k$ 的消元完成后，我们增加秩，`rank` $\\leftarrow$ `rank` $+ 1$。\n\n在前向消元过程结束后，变量 `rank` 保存了矩阵 $A$ 的秩。\n\n求解阶段取决于计算出的秩。\n- **奇异情况**：如果 $\\text{rank} < n$，矩阵 $A$ 是奇异的。系统可能无解或有无穷多解。根据问题规范，我们不尝试求解，而是报告计算出的秩 $r = \\text{rank}$。这是测试用例 $3$ 和 $4$ 的结果。\n- **非奇异情况**：如果 $\\text{rank} = n$，矩阵是满秩的。前向消元产生了一个等价系统，其中矩阵是具有非零对角线的上三角矩阵。存在唯一解 $x \\in \\mathbb{Q}^{n}$，可通过回代法求得。从最后一个变量 $x_{n-1}$ 开始，我们迭代地求解每个 $x_i$：\n$$x_{n-1} = \\frac{b_{n-1}}{A_{n-1,n-1}}$$\n$$x_i = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j=i+1}^{n-1} A_{ij} x_j \\right) \\quad \\text{for } i = n-2, n-3, \\dots, 0$$\n此阶段的所有计算也都是精确的。测试用例 $1$ 和 $2$ 将遵循此路径。\n\n对于非奇异的测试用例，我们必须验证计算出的解。问题提供了精确解 $x^{\\star}$。我们通过逐项检查 $x = x^{\\star}$ 是否成立来验证我们计算出的解 $x$。由于所有算术都是精确的，两者必须完全相同。然后我们计算两个度量指标：最大绝对残差 $r_{\\infty} = \\max_{i} |(A x - b)_{i}|$ 和最大绝对误差 $e_{\\infty} = \\max_{i} |(x - x^{\\star})_{i}|$。这些量以有理数形式精确计算，然后转换为浮点数用于最终报告。鉴于求解器的精确性，我们预期 $r_{\\infty}$ 和 $e_{\\infty}$ 均为 $0.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nimport copy\n\ndef GEPP_rational(A_in, b_in):\n    \"\"\"\n    Solves a linear system Ax=b using Gaussian elimination with partial pivoting\n    in exact rational arithmetic.\n\n    Args:\n        A_in (list of lists): The matrix A.\n        b_in (list): The vector b.\n\n    Returns:\n        tuple: A tuple containing a status string ('nonsingular' or 'singular')\n               and a payload (the solution vector x or the rank).\n    \"\"\"\n    n = len(A_in)\n    # Create an augmented matrix with Fraction objects.\n    # A deep copy is used to avoid modifying inputs.\n    Ab = []\n    for i in range(n):\n        row = [Fraction(x) for x in A_in[i]] + [Fraction(b_in[i])]\n        Ab.append(row)\n\n    rank = 0\n    # Forward elimination phase\n    for k in range(n):  # Iterate through columns\n        if rank == n:\n            break\n\n        # Find pivot in column k, from row 'rank' downwards\n        i_max = rank\n        v_max = abs(Ab[rank][k])\n        for i in range(rank + 1, n):\n            if abs(Ab[i][k]) > v_max:\n                v_max = abs(Ab[i][k])\n                i_max = i\n\n        # If maximal pivot in this column (in the active submatrix) is zero,\n        # the column is linearly dependent. We move to the next column.\n        if Ab[i_max][k] == 0:\n            continue\n\n        # Swap the found pivot row with the current rank row\n        Ab[rank], Ab[i_max] = Ab[i_max], Ab[rank]\n        \n        pivot_val = Ab[rank][k]\n\n        # Eliminate entries below the pivot\n        for i in range(rank + 1, n):\n            factor = Ab[i][k] / pivot_val\n            # Apply row operation to the rest of the row\n            for j in range(k, n + 1):\n                Ab[i][j] -= factor * Ab[rank][j]\n        \n        rank += 1\n    \n    # Solution phase\n    if rank  n:\n        return (\"singular\", rank)\n\n    # Nonsingular case: perform back substitution\n    x = [Fraction(0)] * n\n    for i in range(n - 1, -1, -1):\n        # We know pivots are on the diagonal because rank == n for a square matrix\n        sum_ax = sum(Ab[i][j] * x[j] for j in range(i + 1, n))\n        x[i] = (Ab[i][n] - sum_ax) / Ab[i][i]\n    \n    return (\"nonsingular\", x)\n\ndef mat_vec_mul(A, x):\n    \"\"\"Matrix-vector multiplication with Fraction objects.\"\"\"\n    n = len(A)\n    b = [Fraction(0)] * n\n    for i in range(n):\n        for j in range(n):\n            b[i] += A[i][j] * x[j]\n    return b\n\ndef solve():\n    \"\"\"\n    Defines, runs, and formats the results for the four test cases.\n    \"\"\"\n    # Test Case 1: Hilbert matrix n=5\n    n1 = 5\n    A1 = [[Fraction(1, i + j + 1) for j in range(n1)] for i in range(n1)]\n    x1_star = [Fraction(1)] * n1\n    b1 = mat_vec_mul(A1, x1_star)\n\n    # Test Case 2: Hilbert matrix n=7\n    n2 = 7\n    A2 = [[Fraction(1, i + j + 1) for j in range(n2)] for i in range(n2)]\n    x2_star = [Fraction(-1) if i % 2 else Fraction(1) for i in range(n2)]\n    b2 = mat_vec_mul(A2, x2_star)\n\n    # Test Case 3: Singular consistent system\n    A3 = [[1, 2, 3], [2, 4, 6], [1, 2, 3]]\n    b3 = [6, 12, 6]\n\n    # Test Case 4: Boundary singular case\n    A4 = [[0]]\n    b4 = [0]\n\n    test_cases = [\n        {'A': A1, 'b': b1, 'x_star': x1_star},\n        {'A': A2, 'b': b2, 'x_star': x2_star},\n        {'A': A3, 'b': b3, 'x_star': None},\n        {'A': A4, 'b': b4, 'x_star': None},\n    ]\n\n    all_results = []\n    for case in test_cases:\n        A, b, x_star = case['A'], case['b'], case['x_star']\n        status, payload = GEPP_rational(A, b)\n        \n        if status == \"singular\":\n            all_results.append(payload) # Payload is the rank\n        else: # \"nonsingular\"\n            x_computed = payload\n            n = len(A)\n            \n            # Verify solution correctness\n            ok = all(x_computed[i] == x_star[i] for i in range(n))\n\n            # Compute residual r = Ax - b\n            Ax = mat_vec_mul(A, x_computed)\n            # The input b may not be Fraction objects, so convert\n            b_frac = [Fraction(val) for val in b]\n            residual = [Ax[i] - b_frac[i] for i in range(n)]\n            r_inf = float(max(abs(v) for v in residual))\n\n            # Compute error e = x - x_star\n            error = [x_computed[i] - x_star[i] for i in range(n)]\n            e_inf = float(max(abs(v) for v in error))\n\n            all_results.append([ok, r_inf, e_inf])\n    \n    # Custom string formatting to avoid spaces after comma in lists\n    formatted_results = []\n    for res in all_results:\n        if isinstance(res, list):\n            # Format list as [True,0.0,0.0] without spaces\n            list_str = f\"[{str(res[0])},{str(res[1])},{str(res[2])}]\"\n            formatted_results.append(list_str)\n        else:\n            formatted_results.append(str(res))\n    \n    # Final print statement must match the exact specified format.\n    # The default str() for a list has spaces, which might be undesirable.\n    # The example format `[[True, 0.0, 0.0],[True, 0.0, 0.0],1,0]` has spaces\n    # inside the sublists but not between elements of the main list.\n    # `str(list)` gives spaces. `','.join(map(str, list))` also gives spaces\n    # when an element is a list itself. Let's build the string manually for precision.\n    result_str = f\"[{','.join(str(r) for r in all_results)}]\"\n    # Python's str([True, 0.0, 0.0]) is '[True, 0.0, 0.0]', which has spaces.\n    # The prompt's example format is `[[True, 0.0, 0.0],[True, 0.0, 0.0],1,0]`\n    # This implies str(list) is acceptable for sublists. Let's use the simplest\n    # correct method.\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2397350"}]}