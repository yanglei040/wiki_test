{"hands_on_practices": [{"introduction": "理解刚性问题最好的方法之一就是亲眼见证一个显式求解器如何失效。这个练习将时间步长的选择变成一个“稳定性游戏”，你需要亲自尝试并找到前向欧拉法的稳定性边界。通过这个动手实践，条件稳定性的抽象概念将变得具体而难忘。[@problem_id:2442901]", "problem": "设计并实现一个完整的、可运行的程序，该程序将针对一个常微分方程（ODE）的刚性初值问题的稳定性问题，转化为一个选择时间步长的“博弈”。您的任务是利用第一性原理，将以下挑战形式化。\n\n考虑自治线性常微分方程\n$$\n\\frac{dy}{dt} = -\\lambda\\, y,\n$$\n其初始条件为\n$$\ny(0) = y_0,\n$$\n其中 $\\lambda \\gt 0$ 是一个大参数，使得该问题是刚性的。在无量纲变量下进行计算，因此不涉及物理单位。\n\n仅从数值分析和微积分的基本定义出发，完成以下任务。\n\n1) 使用导数的定义和在 $t_n$ 处的一阶有限差分，推导前向（显式）欧拉更新。使用相同的基础和在 $t_{n+1}$ 处的一阶有限差分，推导后向（隐式）欧拉更新。不要假定任何预先给定的更新规则；从 $\\frac{dy}{dt}$ 的定义和步长关系 $t_{n+1} = t_n + \\Delta t$ 出发进行推导。\n\n2) 对于这两种积分器中的每一种，当右侧项为 $-\\lambda y$ 时，找出推导出的更新式所蕴含的单步放大因子。使用绝对稳定性的概念：当且仅当此单步放大因子的绝对值严格小于 1 时，离散轨迹是绝对稳定的；否则它是不稳定的。在本博弈中，绝对值等于 1 的临界情况必须被视为不稳定。\n\n3) 将两种方法作为在区间 $[0,T]$ 上使用均匀步长 $\\Delta t$ 的时间步进算法来实现。精确推进 $N$ 步，其中 $N = T/\\Delta t$（所有提供的 $\\Delta t$ 值都能被 $T$ 整除）。除了根据放大因子计算稳定性分类外，还要模拟轨迹 $y_n$ 并记录在步进过程中达到的最大绝对值，作为行为的诊断。\n\n4) 博弈的目标是选择一个 $\\Delta t$ 使得显式欧拉法保持绝对稳定。对于下面的每个测试用例，您必须根据第 2 项中的绝对稳定性准则，报告显式欧拉法是否不稳定（一个“失败”状态）。\n\n测试套件：\n- 刚性参数：$\\lambda = 1000$。\n- 初始值：$y_0 = 1$。\n- 终止时间：$T = 1$。\n- 时间步长：$\\Delta t \\in \\{\\, 0.0005,\\ 0.0020,\\ 0.0025 \\,\\}$。\n\n对于测试套件中的每个 $\\Delta t$，在 $[0,T]$ 上运行显式和隐式欧拉法，并确定一个标量输出 $r$，其定义如下：\n- 如果根据第 2 项中的绝对稳定性准则，显式欧拉法是不稳定的（即，其放大因子的绝对值大于或等于 1），则 $r = 1$。\n- 其他情况则 $r = 0$。\n\n最终输出格式：\n你的程序应该生成单行输出，其中包含按所提供的时间步长顺序排列的结果，结果为用逗号分隔并用方括号括起来的列表。例如，打印的行应类似于\n$$\n[ r_1, r_2, r_3 ]\n$$\n但不含空格，即，精确地像 $[r_1,r_2,r_3]$，其中每个 $r_k$ 是一个整数 0 或 1，分别对应于 $\\Delta t = 0.0005$、$\\Delta t = 0.0020$ 和 $\\Delta t = 0.0025$。", "solution": "所述问题是有效的。这是一个关于常微分方程（ODE）数值分析的适定、有科学依据的练习，重点关注刚性和数值稳定性这两个关键概念。其前提在事实上是正确的，术语是精确的，目标是明确定义的。我们将从第一性原理出发，进行严谨的推导和求解。\n\n控制方程为线性自治常微分方程：\n$$\n\\frac{dy}{dt} = -\\lambda y, \\quad y(0) = y_0\n$$\n其中 $\\lambda  0$ 是一个大常数，这是刚性系统的特征。其精确解为 $y(t) = y_0 e^{-\\lambda t}$，该解会迅速衰减到零。一个数值方法必须能够在不引入伪振荡或发散的情况下重现这种衰减。\n\n**1. 从第一性原理推导欧拉积分器**\n\n我们用均匀步长 $\\Delta t$ 对时间连续体进行离散化，使得 $t_n = n \\Delta t$。在 $t_n$ 处的解的数值近似值记为 $y_n$。导数 $\\frac{dy}{dt}$ 由以下极限定义：\n$$\n\\frac{dy}{dt} = \\lim_{\\Delta t \\to 0} \\frac{y(t+\\Delta t) - y(t)}{\\Delta t}\n$$\n\n**前向（显式）欧拉法：**\n为了推导前向欧拉更新，我们用一阶前向有限差分来近似 $t_n$ 时刻的导数，这通过从导数定义中移除极限得到：\n$$\n\\frac{dy}{dt}\\bigg|_{t=t_n} \\approx \\frac{y(t_{n+1}) - y(t_n)}{\\Delta t}\n$$\n将此近似代入 ODE $\\frac{dy}{dt} = -\\lambda y$，并在已知时间步 $t_n$ 处计算所有项，得到：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = -\\lambda y_n\n$$\n重新整理以求解未知值 $y_{n+1}$，得到显式更新规则：\n$$\ny_{n+1} = y_n + \\Delta t (-\\lambda y_n) = (1 - \\lambda \\Delta t) y_n\n$$\n该方法被称为“显式”，因为 $y_{n+1}$ 可以直接使用在第 $n$ 步已知的值计算出来。\n\n**后向（隐式）欧拉法：**\n为了推导后向欧拉更新，我们使用一阶后向有限差分来近似导数，但在下一个时间步 $t_{n+1}$ 处进行计算：\n$$\n\\frac{dy}{dt}\\bigg|_{t=t_{n+1}} \\approx \\frac{y(t_{n+1}) - y(t_n)}{\\Delta t}\n$$\n为保持一致性，ODE 的右侧也必须在 $t_{n+1}$ 处计算：\n$$\n\\frac{y_{n+1} - y_n}{\\Delta t} = -\\lambda y_{n+1}\n$$\n为了求出 $y_{n+1}$，我们必须对该方程进行代数求解。\n$$\ny_{n+1} + \\lambda \\Delta t y_{n+1} = y_n \\implies y_{n+1}(1 + \\lambda \\Delta t) = y_n\n$$\n分离出 $y_{n+1}$，得到隐式更新规则：\n$$\ny_{n+1} = \\frac{1}{1 + \\lambda \\Delta t} y_n\n$$\n该方法是“隐式”的，因为 $y_{n+1}$ 出现在初始方程的两边，需要一个求解步骤来推进解。\n\n**2. 放大因子与绝对稳定性分析**\n\n对于这两种方法，更新规则都具有 $y_{n+1} = G y_n$ 的形式，其中标量 $G$ 是单步放大因子。当且仅当误差不随每一步增长时，数值解保持稳定。绝对稳定性的条件是放大因子的绝对值必须严格小于 1：$|G|  1$。问题规定边界情况 $|G| = 1$ 必须被视为不稳定。\n\n**前向欧拉稳定性：**\n放大因子为 $G_{FE} = 1 - \\lambda \\Delta t$。稳定性条件是：\n$$\n|1 - \\lambda \\Delta t|  1\n$$\n由于 $\\lambda > 0$ 和 $\\Delta t > 0$，我们有 $\\lambda \\Delta t > 0$。不等式变为：\n$$\n-1  1 - \\lambda \\Delta t  1\n$$\n右边，$1 - \\lambda \\Delta t  1$，意味着 $-\\lambda \\Delta t  0$，这总是满足的。左边，$-1  1 - \\lambda \\Delta t$，得出 $ \\lambda \\Delta t  2$。\n因此，前向欧拉法是条件稳定的，要求 $\\Delta t  \\frac{2}{\\lambda}$。对于不稳定情况，标准是 $\\Delta t \\ge \\frac{2}{\\lambda}$。\n\n**后向欧拉稳定性：**\n放大因子为 $G_{BE} = \\frac{1}{1 + \\lambda \\Delta t}$。稳定性条件是：\n$$\n\\left| \\frac{1}{1 + \\lambda \\Delta t} \\right|  1\n$$\n由于 $\\lambda > 0$ 和 $\\Delta t > 0$，分母 $1 + \\lambda \\Delta t$ 总是大于 $1$。因此，对于所有正的 $\\Delta t$，都有 $0  G_{BE}  1$。稳定性条件总是满足的。因此，对于这个问题，后向欧拉法是无条件稳定的，这个性质被称为 A-稳定性。\n\n**3. 实现与博弈目标**\n\n这个“博弈”要求我们确定给定的时间步长 $\\Delta t$ 是否使显式欧拉法不稳定。结果 $r$ 在不稳定时为 1，稳定时为 0。参数为 $\\lambda=1000$，$y_0 = 1$ 和 $T=1$。\n$\\Delta t$ 的稳定性阈值为：\n$$\n\\Delta t  \\frac{2}{\\lambda} = \\frac{2}{1000} = 0.002\n$$\n如果 $\\Delta t \\ge 0.002$，该方法是不稳定的。我们将把这个条件应用于每个测试用例。\n\n- **测试用例 1：$\\Delta t = 0.0005$**\n  由于 $0.0005  0.002$，满足稳定性条件。该方法是稳定的。\n  $|G_{FE}| = |1 - 1000 \\times 0.0005| = |1 - 0.5| = 0.5  1$。\n  结果：$r_1 = 0$。\n\n- **测试用例 2：$\\Delta t = 0.0020$**\n  此处 $\\Delta t = 0.002$，正好落在边界上。根据问题的严格规定，这种情况是不稳定的。\n  $|G_{FE}| = |1 - 1000 \\times 0.0020| = |1 - 2.0| = 1.0$。\n  条件 $|G_{FE}| \\ge 1$ 得到满足。\n  结果：$r_2 = 1$。\n\n- **测试用例 3：$\\Delta t = 0.0025$**\n  此处 $0.0025 > 0.002$，违反了稳定性条件。该方法是不稳定的。\n  $|G_{FE}| = |1 - 1000 \\times 0.0025| = |1 - 2.5| = 1.5 > 1$。\n  条件 $|G_{FE}| \\ge 1$ 得到满足。\n  结果：$r_3 = 1$。\n\n最终的结果序列是 $[0, 1, 1]$。所提供的代码将实现这一逻辑，包括按要求模拟轨迹以展示稳定和不稳定的后果，尽管最终的打印输出仅依赖于放大因子分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stability game for a stiff ODE using Euler methods.\n\n    The program performs the following steps as required:\n    1. For each test case (time step), it calculates the amplification factor for\n       the explicit Euler method.\n    2. It determines if the method is unstable based on the condition that the\n       magnitude of the amplification factor is greater than or equal to 1.\n    3. It implements both explicit and implicit Euler methods to simulate the\n       trajectory, demonstrating adherence to the full problem statement, although\n       the final output depends only on the stability criterion.\n    4. It collects the stability results (0 for stable, 1 for unstable) and\n       prints them in the specified format.\n    \"\"\"\n\n    # Define problem parameters from the statement.\n    lambda_val = 1000.0\n    y0 = 1.0\n    T = 1.0\n\n    # Define the test suite of time steps.\n    delta_t_values = [0.0005, 0.0020, 0.0025]\n\n    results = []\n\n    for delta_t in delta_t_values:\n        # --- Part 4: The Game Objective ---\n        # Determine stability for explicit Euler based on the amplification factor.\n        # The amplification factor for explicit Euler is G_FE = 1 - lambda * delta_t.\n        # Stability requires |G_FE|  1. Unstable if |G_FE| >= 1.\n        \n        amp_factor_mag = abs(1.0 - lambda_val * delta_t)\n\n        # The result r is 1 if unstable, 0 otherwise.\n        if amp_factor_mag >= 1.0:\n            r = 1\n        else:\n            r = 0\n        results.append(r)\n\n        # --- Part 3: Simulation (for completeness as requested) ---\n        # Although not needed for the final output 'r', the problem requires\n        # implementing the time-stepping to simulate the trajectories.\n        \n        # Ensure N is an integer, as guaranteed by the problem statement.\n        N = int(round(T / delta_t))\n        \n        # Explicit Euler Simulation\n        y_explicit = np.zeros(N + 1)\n        y_explicit[0] = y0\n        amp_factor_explicit = 1.0 - lambda_val * delta_t\n        for n in range(N):\n            y_explicit[n+1] = amp_factor_explicit * y_explicit[n]\n        # max_abs_explicit = np.max(np.abs(y_explicit)) # Diagnostic\n\n        # Implicit Euler Simulation\n        y_implicit = np.zeros(N + 1)\n        y_implicit[0] = y0\n        amp_factor_implicit = 1.0 / (1.0 + lambda_val * delta_t)\n        for n in range(N):\n            y_implicit[n+1] = amp_factor_implicit * y_implicit[n]\n        # max_abs_implicit = np.max(np.abs(y_implicit)) # Diagnostic\n        \n        # The diagnostics max_abs_explicit and max_abs_implicit could be\n        # inspected to observe the blow-up or decay, confirming the theory.\n        # For example, for delta_t = 0.0025 (unstable), max_abs_explicit\n        # would be a very large number, while max_abs_implicit would be 1.0.\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442901"}, {"introduction": "在看到显式方法存在稳定性限制后，下一个自然而然的问题是：在实践中，隐式方法的效率究竟高出多少？本练习使用工业标准的自适应求解器，来比较求解同一个刚性问题所需的函数求值次数。你将亲眼看到，随着问题刚性的增加，显式求解器的计算成本会急剧飙升，从而证明在真实世界应用中，隐式方法是必不可少的。[@problem_id:2442926]", "problem": "考虑由线性刚性常微分方程定义的标量初值问题\n$$\n\\frac{dy}{dt} = -\\lambda\\, y, \\quad y(0)=1,\n$$\n在一个有限时间区间上。其精确解为\n$$\ny(t) = e^{-\\lambda t}.\n$$\n当动力学系统包含快速衰减的模态时，该系统被称为刚性的。因此，显式求解器必须采用极小的步长来维持数值稳定性，而隐式求解器在更大的步长下仍能保持稳定。在自适应时间步长方案中，步长会被调整，以使局部截断误差的估计值保持在用户指定的容差之下。\n\n您的任务是编写一个完整的程序，对下文的每个测试用例，分别使用自适应显式 Runge–Kutta 方法和自适应隐式多步法对问题进行积分，然后比较所使用的函数求值次数。请遵循以下要求。\n\n- 使用自适应显式方法 “RK45”（一种带有嵌入式误差估计器的经典显式 Runge–Kutta 方法）和自适应隐式方法 “BDF”（后向差分公式），两者都采用由用户指定容差控制的自动步长控制。\n- 对于隐式求解器，请提供精确的雅可比矩阵\n$$\nJ(t,y) = \\frac{\\partial f}{\\partial y} = -\\lambda,\n$$\n这样隐式方法就无需通过有限差分来近似它。\n- 对每个测试用例，两种求解器都使用相同的绝对和相对容差。设 $rtol$ 表示相对容差，$atol$ 表示绝对容差。\n- 对每个测试用例，记录每个求解器报告的右端项函数求值次数 $N_{\\mathrm{fev}}$，显式方法记为 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$，隐式方法记为 $N_{\\mathrm{fev}}^{\\mathrm{imp}}$。计算比率\n$$\nR = \\frac{N_{\\mathrm{fev}}^{\\mathrm{exp}}}{N_{\\mathrm{fev}}^{\\mathrm{imp}}}.\n$$\n- 每个测试用例返回一个 $R$。\n\n测试套件：\n- 用例 1（基准，轻度刚性）：$\\lambda = 50$，在 $t \\in [0, 2.0]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n- 用例 2（刚性）：$\\lambda = 5000$，在 $t \\in [0, 1.0]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n- 用例 3（非常刚性）：$\\lambda = 50000$，在 $t \\in [0, 0.5]$ 上积分，其中 $rtol = 10^{-6}$，$atol = 10^{-12}$。\n\n重要实现说明：\n- 右端项为 $f(t,y) = -\\lambda y$。\n- 所有计算均采用无量纲单位；不需要物理单位。\n- 所有用例的初值均为 $y(0)=1$。\n- 不要通过计算精确解来指导时间步长；仅依赖求解器的自适应控制。\n- 为保证可比性，不提供任何 $t_{\\mathrm{eval}}$ 网格；允许每个求解器选择其自身的内部步长。\n\n输出规范：\n- 对每个测试用例，输出比率 $R$，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含按上述测试用例顺序列出的结果，结果为逗号分隔的列表，并用方括号括起。例如，包含三个结果的输出行必须如下所示：\n$$\n[\\text{R}_{1},\\text{R}_{2},\\text{R}_{3}],\n$$\n其中每个 $\\text{R}_{k}$ 是一个小数点后保留六位的小数。\n\n您的程序必须是一个完整的、可运行的程序，不需要用户输入，并且只使用指定的库。", "solution": "所述问题是有效的。这是一个在计算物理学中定义明确、有科学依据的练习，旨在探讨常微分方程（ODE）中刚性的基本概念。参数已明确指定，任务也很清晰。我们将继续进行求解。\n\n该问题研究了由以下线性常微分方程（ODE）给出的标量初值问题（IVP）：\n$$\n\\frac{dy}{dt} = -\\lambda y, \\quad y(0) = 1\n$$\n对于正参数 $\\lambda$。其精确解已知为 $y(t) = e^{-\\lambda t}$。该方程是刚性系统的典型模型。\n\n当一个常微分方程组的雅可比矩阵的特征值在量级上差异很大时，该方程组被定义为“刚性”的。对于此标量问题，雅可比矩阵就是右端项关于 $y$ 的导数，即 $J = \\frac{\\partial}{\\partial y}(-\\lambda y) = -\\lambda$。唯一的特征值是 $-\\lambda$。当 $\\lambda$ 为大的正数时，相应的解分量 $e^{-\\lambda t}$ 会极快地衰减。这种快速衰减的模态对显式数值积分方法施加了严格的稳定性约束。\n\n显式方法，例如指定的 Runge-Kutta \"RK45\" 方法，仅使用当前状态 $y_n$ 的信息来计算下一个状态 $y_{n+1}$。它们的稳定性是有限的。对于该模型问题，显式方法的时间步长 $\\Delta t$ 通常必须满足 $\\Delta t \\cdot \\lambda \\lesssim C$ 形式的条件，其中 $C$ 是一个取决于具体方法的数量级为 1 的常数。这意味着，为了维持数值稳定性，即使在快速瞬态衰减很久之后且解变化平滑时，步长也必须与系统中最快的时间尺度 $\\sim \\frac{1}{\\lambda}$ 处于同一数量级。对于大的 $\\lambda$，这会迫使求解器采取大量极小的步长，从而导致高昂的计算成本。“RK45”中的自适应步长控制会自动减小步长以满足此稳定性要求，从而导致大量的函数求值次数 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$。\n\n隐式方法，如后向差分公式（\"BDF\"），为刚性问题提供了一种更优越的替代方案。隐式方法通过求解一个包含 $y_{n+1}$ 本身的方程来确定新状态 $y_{n+1}$，例如 $y_{n+1} = y_n + \\Delta t f(t_{n+1}, y_{n+1})$。对于非线性的 $f$，这需要在每个时间步求解一个方程组，通常使用类似 Newton-Raphson 的迭代方法。此迭代求解器的收敛性取决于 $f$ 的雅可比矩阵。通过提供精确的雅可比矩阵 $J = -\\lambda$，我们能辅助求解器完成此任务，避免了有限差分近似的计算开销和潜在的不准确性。像 BDF 这样的隐式方法的主要优点是其宽广的稳定域。它们是“A-稳定”或“刚性稳定”的，这意味着它们可以采用大的时间步长，步长的限制仅来自于解析解的缓变分量所需的精度，而非快速衰减模态带来的稳定性约束。\n\n在本实验中，我们将比较对于递增的 $\\lambda$ 值，“RK45” ($N_{\\mathrm{fev}}^{\\mathrm{exp}}$) 和 “BDF” ($N_{\\mathrm{fev}}^{\\mathrm{imp}}$) 的函数求值次数。对于轻度刚性的用例 1 ($\\lambda=50$)，显式方法可能效率尚可。然而，当 $\\lambda$ 增加到数千（用例 2 和 3）时，问题变得非常刚性。“RK45” 求解器将被迫进入稳定性受限的区域，执行大量的步长。而 “BDF” 求解器不受稳定性约束，将能够采取大得多的步长（仅由指定的容差决定），以在初始快速瞬态后追踪平滑的解。因此，我们预计 $N_{\\mathrm{fev}}^{\\mathrm{imp}}$ 将远小于 $N_{\\mathrm{fev}}^{\\mathrm{exp}}$，并且比率 $R = N_{\\mathrm{fev}}^{\\mathrm{exp}} / N_{\\mathrm{fev}}^{\\mathrm{imp}}$ 会随着 $\\lambda$ 的增大而显著增长，这表明了显式方法在处理刚性问题时效率极低。\n\n实现将利用 SciPy 库中的 `solve_ivp` 函数。对每个测试用例，我们将配置并运行这两个求解器，使用相同的容差和积分区间，从求解器的输出结构中检索函数求值次数，并计算指定的比率 $R$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the stiff ODE y' = -lambda*y for different lambda values,\n    comparing the performance of an explicit (RK45) and an implicit (BDF) solver.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (lambda_val, t_span, rtol, atol)\n    test_cases = [\n        (50.0, [0.0, 2.0], 1e-6, 1e-12),\n        (5000.0, [0.0, 1.0], 1e-6, 1e-12),\n        (50000.0, [0.0, 0.5], 1e-6, 1e-12)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        lambda_val, t_span, rtol, atol = case\n\n        # The right-hand side of the ODE dy/dt = f(t, y)\n        # Using a lambda function to capture the current lambda_val\n        fun = lambda t, y: -lambda_val * y\n\n        # The Jacobian of the right-hand side, d(f)/d(y)\n        # solve_ivp expects the Jacobian as a 2-D array-like structure.\n        jac = lambda t, y: [[-lambda_val]]\n        \n        # Initial condition y(0) = 1.\n        # solve_ivp expects a 1-D array for the initial state.\n        y0 = [1.0]\n\n        # Integrate using the explicit \"RK45\" method\n        sol_exp = solve_ivp(\n            fun=fun,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol\n        )\n        n_fev_exp = sol_exp.nfev\n\n        # Integrate using the implicit \"BDF\" method, providing the exact Jacobian\n        sol_imp = solve_ivp(\n            fun=fun,\n            t_span=t_span,\n            y0=y0,\n            method='BDF',\n            rtol=rtol,\n            atol=atol,\n            jac=jac\n        )\n        n_fev_imp = sol_imp.nfev\n        \n        # Compute the ratio of function evaluations\n        if n_fev_imp > 0:\n            ratio = n_fev_exp / n_fev_imp\n        else:\n            # Handle the unlikely case of zero evaluations to avoid division by zero\n            ratio = np.inf\n\n        # Format the result to six decimal places and add to the list\n        results.append(f\"{ratio:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2442926"}, {"introduction": "数值稳定性虽然至关重要，但它并不能保证解在物理上是有意义的。本练习将探讨一种更微妙的显式方法失效模式：即使解保持有界（即稳定），它也可能违反基本的物理约束（例如，浓度不能为负）。你会发现，即便显式方法没有“爆炸”，它也可能产生定性上错误的结果，而一个合适的隐式方法则能正确地保持系统的物理特性。[@problem_id:2442899]", "problem": "考虑一个由以下常微分方程（ODE）组建模的线性常系数双物种动力学链\n$$\n\\frac{d}{dt}\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}\n=\n\\begin{bmatrix}\n- k_1  0 \\\\\nk_1  - k_2\n\\end{bmatrix}\n\\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix},\n\\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix},\n$$\n其中速率常数 $k_1 = 1000\\,\\text{s}^{-1}$ 且 $k_2 = 1\\,\\text{s}^{-1}$。自变量是时间 $t$，单位为秒。该系统是刚性的，因为系统矩阵的特征值相差几个数量级。\n\n你的任务是通过推导和计算来论证，对于一个刚性问题，显式单步法如何在数值稳定（有界）的情况下产生定性上错误的轨迹，而隐式单步法如何保持其定性特征。\n\n从以下基本原理出发：\n- 时间导数的定义，$\\frac{dy}{dt} = \\lim_{h\\to 0} \\frac{y(t+h)-y(t)}{h}$。\n- 前向（显式）Euler 方法通过将导数替换为在当前时间点计算的前向有限差分得到。\n- 后向（隐式）Euler 方法通过将导数替换为在下一时间点计算的后向有限差分得到。\n- 单步法的线性稳定性通过标量测试方程 $\\frac{dy}{dt} = \\lambda y$ 进行评估，检验其放大因子 $R(z)$，其中 $z = h\\lambda$。对于线性系统 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，稳定性由放大矩阵的谱半径确定。\n\n要求：\n1) 从第一性原理出发，推导应用于给定 $2\\times 2$ 线性系统的显式 Euler 和后向 Euler 方法的离散时间更新映射。用时间步长 $h$ 和系统矩阵 $A$ 来表示这两种更新。\n\n2) 使用标量测试方程分析，推导显式 Euler 放大因子 $R(z)$ 及其稳定区域。解释这如何导出线性系统的稳定性条件，该条件用矩阵 $I + hA$ 的谱半径表示，其中 $I$ 是单位矩阵。对于此问题，如果矩阵 $I + hA$ 的谱半径小于或等于 $1$，则将一个显式步长归类为“数值稳定（有界）”。\n\n3) 实现这两种方法，用几个固定的时间步长 $h$ 将系统从 $t=0$ 演化到 $t = T$（$T = 0.95\\,\\text{s}$）。对于每种方法和每个时间步长，记录在任何离散时间层上是否有任何分量变为负值。浓度为负是定性上的违规。\n\n4) 对于每个时间步长 $h$，通过计算 $I + hA$ 的谱半径并检查其是否小于或等于 $1$ 来确定显式 Euler 方法是否数值稳定（有界）。\n\n5) 使用以下时间步长（单位：秒）测试集：$h \\in \\{0.0005,\\ 0.0019,\\ 0.0020\\}$。对于每个 $h$，将两种方法演化到 $T = 0.95\\,\\text{s}$（对于每个列出的 $h$，这恰好是整数步数），并按以下顺序报告三个布尔值：\n- 显式方法的有界稳定性标志（如第4项所定义），\n- 显式方法是否曾产生负分量，\n- 隐式方法是否曾产生负分量。\n\n最终输出规范：\n- 你的程序应产生单行输出，其中包含一个由三个列表组成的列表（每个测试用例一个，按上面给出的 $h$ 的顺序）。每个内部列表必须为 $[\\text{explicit\\_bounded},\\ \\text{explicit\\_has\\_negative},\\ \\text{implicit\\_has\\_negative}]$ 的形式，其中每个条目都是一个布尔值。例如，输出可能看起来像 $[[\\text{True},\\text{False},\\text{False}],[\\dots],[\\dots]]$。\n- 输出的布尔值中无需报告额外的单位。时间必须在内部以秒为单位处理。", "solution": "该问题要求论证显式和隐式单步数值方法在应用于刚性常微分方程（ODE）组时表现出的不同定性和定量行为。我们将首先验证该问题，然后进行所需的推导和计算。\n\n该问题是有效的。它提出了一个基于线性化学动力学标准模型的适定初值问题，这是一个在计算物理和计算化学中根基深厚的主题。所有必需的常数、初始条件和定义均已提供，问题没有科学谬误、歧义或主观论断。我们开始求解。\n\n该系统由线性 ODE $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$ 给出，其中状态向量为 $\\mathbf{y}(t) = \\begin{bmatrix} y_1(t) \\\\ y_2(t) \\end{bmatrix}$，初始条件为 $\\mathbf{y}(0) = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$，系统矩阵 $A$ 为\n$$\nA = \\begin{bmatrix} -k_1  0 \\\\ k_1  -k_2 \\end{bmatrix} = \\begin{bmatrix} -1000  0 \\\\ 1000  -1 \\end{bmatrix}.\n$$\n自变量是时间 $t$，速率常数为 $k_1 = 1000\\,\\text{s}^{-1}$ 和 $k_2 = 1\\,\\text{s}^{-1}$。\n\n1) 离散时间更新映射的推导\n\n设 $\\mathbf{y}_n$ 是 $\\mathbf{y}(t_n)$ 在时间 $t_n = n h$ 的数值近似，其中 $h$ 是时间步长。\n\n显式（前向）Euler 方法使用前向有限差分来近似时间 $t_n$ 处的导数 $\\frac{d\\mathbf{y}}{dt}$：\n$$\n\\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} \\approx A\\mathbf{y}_n.\n$$\n求解 $\\mathbf{y}_{n+1}$ 得到显式更新映射：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h A\\mathbf{y}_n = (I + hA)\\mathbf{y}_n,\n$$\n其中 $I$ 是 $2 \\times 2$ 单位矩阵。\n\n隐式（后向）Euler 方法使用后向有限差分来近似时间 $t_{n+1}$ 处的导数，并在未来时间点 $t_{n+1}$ 计算右侧项：\n$$\n\\frac{\\mathbf{y}_{n+1} - \\mathbf{y}_n}{h} \\approx A\\mathbf{y}_{n+1}.\n$$\n为了找到 $\\mathbf{y}_{n+1}$，我们必须求解一个线性系统：\n$$\n\\mathbf{y}_n = \\mathbf{y}_{n+1} - hA\\mathbf{y}_{n+1} = (I - hA)\\mathbf{y}_{n+1}.\n$$\n通过对矩阵 $(I - hA)$ 求逆来求解 $\\mathbf{y}_{n+1}$，得到隐式更新映射：\n$$\n\\mathbf{y}_{n+1} = (I - hA)^{-1}\\mathbf{y}_n.\n$$\n\n2) 显式 Euler 方法的稳定性分析\n\n单步法的稳定性使用标量测试方程 $\\frac{dy}{dt} = \\lambda y$（其中 $\\lambda \\in \\mathbb{C}$）进行分析。应用显式 Euler 方法得到递推关系：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1 + h\\lambda)y_n.\n$$\n项 $R(z) = 1 + h\\lambda = 1+z$（其中 $z = h\\lambda$）是放大因子。数值解保持有界的充要条件是 $|R(z)| \\le 1$。对于显式 Euler 方法，该条件 $|1+z| \\le 1$ 定义了稳定区域为复平面上以 $(-1, 0)$ 为中心、半径为 $1$ 的圆盘。\n\n对于线性系统 $\\frac{d\\mathbf{y}}{dt} = A\\mathbf{y}$，如果该条件对矩阵 $A$ 的每个特征值 $\\lambda_i$ 对应的 $z=h\\lambda_i$ 都成立，则该方法是稳定的。这等价于要求放大矩阵 $I+hA$ 的所有特征值的模都不大于 $1$。这些特征值的最大模即为谱半径 $\\rho(I+hA)$。因此，显式 Euler 方法数值稳定（有界）的条件是：\n$$\n\\rho(I + hA) \\le 1.\n$$\n\n3, 4, 5) 在具体问题上的应用和计算分析\n\n矩阵 $A = \\begin{bmatrix} -1000  0 \\\\ 1000  -1 \\end{bmatrix}$ 是下三角矩阵，因此其特征值为其对角线元素：$\\lambda_1 = -1000$ 和 $\\lambda_2 = -1$。显式 Euler 放大矩阵 $I+hA$ 的特征值为 $1+h\\lambda_1 = 1 - 1000h$ 和 $1+h\\lambda_2 = 1 - h$。谱半径为 $\\rho(I+hA) = \\max(|1 - 1000h|, |1 - h|)$。为保证稳定性，我们要求 $|1 - 1000h| \\le 1$ 和 $|1 - h| \\le 1$。第一个不等式 $-1 \\le 1 - 1000h \\le 1$ 意味着 $-2 \\le -1000h \\le 0$，可简化为 $0 \\le h \\le \\frac{2}{1000} = 0.002\\,\\text{s}$。第二个不等式给出 $0 \\le h \\le 2\\,\\text{s}$。这两个条件中更严格的一个决定了整个系统的稳定性。因此，显式方法有界的充要条件是 $h \\le 0.002\\,\\text{s}$。\n\n然而，数值稳定性（有界性）并不保证定性上的正确性。在此动力学模型中，浓度 $y_1$ 和 $y_2$ 必须保持非负。让我们检验一下从 $\\mathbf{y}_0 = [1, 0]^T$ 开始的显式 Euler 方法的第一步：\n$$\n\\begin{bmatrix} y_{1,1} \\\\ y_{2,1} \\end{bmatrix} = \\begin{bmatrix} 1 - 1000h  0 \\\\ 1000h  1 - h \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 - 1000h \\\\ 1000h \\end{bmatrix}.\n$$\n为了使各分量保持非负，我们需要 $y_{1,1} \\ge 0$，这意味着 $1 - 1000h \\ge 0$，即 $h \\le \\frac{1}{1000} = 0.001\\,\\text{s}$。这个条件比稳定性条件 $h \\le 0.002\\,\\text{s}$ 更严格。对于 $0.001  h \\le 0.002$ 范围内的任何步长 $h$，显式 Euler 方法在数值上是有界的，但会为分量 $y_1$ 产生一个不符合物理意义的负值。\n\n对于后向 Euler 方法，更新矩阵为 $(I - hA)^{-1} = \\left(\\begin{bmatrix} 1+1000h  0 \\\\ -1000h  1+h \\end{bmatrix}\\right)^{-1} = \\frac{1}{(1+1000h)(1+h)}\\begin{bmatrix} 1+h  0 \\\\ 1000h  1+1000h \\end{bmatrix}$。由于 $h  0$，该矩阵的所有元素都是非负的。因为初始状态 $\\mathbf{y}_0$ 是非负的，通过归纳法可知，所有后续状态 $\\mathbf{y}_{n+1} = (I - hA)^{-1}\\mathbf{y}_n$ 也将保持非负。因此，对于任何步长 $h  0$，后向 Euler 方法都是保正的。\n\n现在我们评估测试用例：$h \\in \\{0.0005, 0.0019, 0.0020\\}$。\n\n$h=0.0005\\,\\text{s}$ 的情况：\n- `explicit_bounded`：$h = 0.0005 \\le 0.002$，因此方法是有界的。$\\rho(I+hA) = \\max(|1-0.5|,|1-0.0005|) = 0.9995 \\le 1$。真。\n- `explicit_has_negative`：$h = 0.0005 \\le 0.001$，因此非负性得以保持。假。\n- `implicit_has_negative`：该方法始终保正。假。\n结果: `[True, False, False]`\n\n$h=0.0019\\,\\text{s}$ 的情况：\n- `explicit_bounded`：$h = 0.0019 \\le 0.002$，因此方法是有界的。$\\rho(I+hA) = \\max(|1-1.9|,|1-0.0019|) = \\max(0.9, 0.9981) = 0.9981 \\le 1$。真。\n- `explicit_has_negative`：$h = 0.0019 > 0.001$，因此 $y_1$ 变为负值。真。\n- `implicit_has_negative`：始终保正。假。\n结果: `[True, True, False]`\n\n$h=0.0020\\,\\text{s}$ 的情况：\n- `explicit_bounded`：$h = 0.0020$，处于稳定边界上。$\\rho(I+hA) = \\max(|1-2.0|,|1-0.0020|) = \\max(1.0, 0.998) = 1.0 \\le 1$。真。\n- `explicit_has_negative`：$h = 0.0020 > 0.001$，因此 $y_1$ 变为负值。真。\n- `implicit_has_negative`：始终保正。假。\n结果: `[True, True, False]`\n\n最终的编译结果与这些推导相符。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stiff ODE problem, demonstrating the difference between\n    explicit and implicit Euler methods.\n    \"\"\"\n    # Define problem parameters\n    k1 = 1000.0\n    k2 = 1.0\n    T_final = 0.95\n    y0 = np.array([1.0, 0.0])\n    \n    # System matrix\n    A = np.array([[-k1, 0.0], [k1, -k2]])\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.0005, 0.0019, 0.0020]\n\n    results = []\n    \n    # Process each test case (each time step h)\n    for h in test_cases:\n        # Requirement 4: Determine if explicit Euler is boundedly stable\n        # Eigenvalues of A are its diagonal entries since it is triangular\n        lambda1 = -k1\n        lambda2 = -k2\n        # Eigenvalues of the amplification matrix I + hA\n        eig_val1_amp = 1.0 + h * lambda1\n        eig_val2_amp = 1.0 + h * lambda2\n        # Spectral radius is the maximum of the absolute values of the eigenvalues\n        spectral_radius = max(abs(eig_val1_amp), abs(eig_val2_amp))\n        \n        # The problem defines stability as spectral radius = 1.\n        # A small tolerance accounts for potential floating-point inaccuracies\n        # when h=0.002 (where spectral radius is exactly 1).\n        explicit_bounded = spectral_radius = 1.0 + 1e-9\n\n        # Requirement 3  5: Check for negative components\n        num_steps = int(round(T_final / h))\n\n        # --- Explicit Euler Simulation ---\n        y_exp = np.copy(y0)\n        M_exp = np.eye(2) + h * A\n        explicit_has_negative = False\n        for _ in range(num_steps):\n            y_exp = M_exp @ y_exp\n            # Check if any component of the state vector is negative\n            if np.any(y_exp  0):\n                explicit_has_negative = True\n                break\n        \n        # --- Implicit Euler Simulation ---\n        y_imp = np.copy(y0)\n        # Pre-compute the inverse of (I - hA) for efficiency\n        M_imp_inv = np.linalg.inv(np.eye(2) - h * A)\n        implicit_has_negative = False\n        for _ in range(num_steps):\n            y_imp = M_imp_inv @ y_imp\n            # Check if any component is negative (theoretically will not happen)\n            if np.any(y_imp  0):\n                implicit_has_negative = True\n                break\n        \n        # Append the list of booleans for the current case\n        results.append([explicit_bounded, explicit_has_negative, implicit_has_negative])\n\n    # Final print statement in the exact required format.\n    # The output format requires no spaces, e.g., [[True,False,False],...].\n    # str(results) would produce spaces, so we remove them.\n    final_output_string = str(results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2442899"}]}