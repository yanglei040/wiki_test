{"hands_on_practices": [{"introduction": "理论是重要的，但真正的理解来自于实践。本节将通过一系列动手练习，带你深入探索 Adams-Moulton 方法的实际应用。在第一个练习 ([@problem_id:2187830]) 中，我们将揭示隐式方法的核心特征。通过将二阶 Adams-Moulton 方法应用于经典的逻辑斯谛增长模型，你将亲手推导出一个必须在每个时间步求解的代数方程，从而直面“隐式”这一概念的真正含义。", "problem": "逻辑斯谛微分方程是描述在有限制条件下种群增长的基本模型。其形式为\n$$\ny'(t) = r y(t) \\left(1 - \\frac{y(t)}{K}\\right)\n$$\n其中 $y(t)$ 是时间 $t$ 时的种群数量，$r$ 是内禀增长率，$K$ 是环境承载力。$r$ 和 $K$ 均为正常数。\n\n为了数值求解此方程，可以使用多种方法。两步 Adams-Moulton 方法是一种隐式多步法，其公式定义为：\n$$\ny_{n+1} = y_n + \\frac{h}{12}(5f_{n+1} + 8f_n - f_{n-1})\n$$\n此处，$h$ 是固定步长，$y_k$ 是在时间 $t_k = t_0 + kh$ 时 $y(t_k)$ 的数值近似值，$f_k$ 是 $f(t_k, y_k)$ 的简写，其中 $f(t, y) = y'(t)$。\n\n由于项 $f_{n+1}$ 依赖于未知值 $y_{n+1}$，将此方法应用于非线性微分方程会导致在每一步都必须求解一个关于 $y_{n+1}$ 的非线性代数方程。对于逻辑斯谛方程，这个代数方程是关于 $y_{n+1}$ 的二次方程，可以写成标准形式：\n$$\nA y_{n+1}^2 + B y_{n+1} + C = 0\n$$\n你的任务是确定系数 $A$、$B$ 和 $C$ 的表达式。你的最终答案应该是用步长 $h$、逻辑斯谛模型参数 $r$ 和 $K$ 以及先前步骤的已知值 $y_n$、$f_n$ 和 $f_{n-1}$ 表示的 $A$、$B$ 和 $C$ 的表达式。", "solution": "我们从逻辑斯谛微分方程 $f(t,y)=r y\\left(1-\\frac{y}{K}\\right)=r y-\\frac{r}{K}y^{2}$ 和两步 Adams-Moulton 方法开始\n$$\ny_{n+1}=y_{n}+\\frac{h}{12}\\left(5 f_{n+1}+8 f_{n}-f_{n-1}\\right).\n$$\n代入 $f_{n+1}=f(t_{n+1},y_{n+1})=r y_{n+1}-\\frac{r}{K}y_{n+1}^{2}$ 得到\n$$\ny_{n+1}=y_{n}+\\frac{h}{12}\\left(5\\left(r y_{n+1}-\\frac{r}{K}y_{n+1}^{2}\\right)+8 f_{n}-f_{n-1}\\right).\n$$\n将所有项移到左边，写成一个关于 $y_{n+1}$ 的二次方程：\n$$\ny_{n+1}-y_{n}-\\frac{h}{12}\\left(5 r y_{n+1}-5\\frac{r}{K}y_{n+1}^{2}+8 f_{n}-f_{n-1}\\right)=0.\n$$\n合并同类项可得\n$$\n\\frac{5 h r}{12 K}y_{n+1}^{2}+\\left(1-\\frac{5 h r}{12}\\right)y_{n+1}-y_{n}-\\frac{h}{12}\\left(8 f_{n}-f_{n-1}\\right)=0.\n$$\n将其与 $A y_{n+1}^{2}+B y_{n+1}+C=0$ 进行匹配，我们确定\n$$\nA=\\frac{5 h r}{12 K},\\quad B=1-\\frac{5 h r}{12},\\quad C=-y_{n}-\\frac{h}{12}\\left(8 f_{n}-f_{n-1}\\right).\n$$\n这些表达式是用 $h$、$r$、$K$ 以及已知量 $y_{n}$、$f_{n}$ 和 $f_{n-1}$ 表示的。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{5 h r}{12 K}  1-\\frac{5 h r}{12}  -y_{n}-\\frac{h}{12}\\left(8 f_{n}-f_{n-1}\\right)\\end{pmatrix}}$$", "id": "2187830"}, {"introduction": "物理和工程中的许多问题都涉及多个相互作用的变量，需要用常微分方程组来描述。这个练习 ([@problem_id:2187866]) 将我们的技能从单个方程扩展到方程组。我们将二阶 Adams-Moulton 方法应用于著名的 Lotka-Volterra 捕食者-猎物模型，你将看到该方法如何自然地生成一个耦合的非线性代数方程组，这让你为解决更复杂的真实世界动力学系统做好准备。", "problem": "Lotka-Volterra方程是用于描述捕食者-猎物种群动态的经典模型。设$x(t)$表示时间$t$时猎物物种的种群数量，$y(t)$表示捕食者物种的种群数量。该模型由以下耦合非线性常微分方程组描述：\n$$\n\\frac{dx}{dt} = \\alpha x - \\beta xy\n$$\n$$\n\\frac{dy}{dt} = \\delta xy - \\gamma y\n$$\n其中 $\\alpha, \\beta, \\delta, \\gamma$ 是代表相互作用率的正常数。\n\n我们希望找到该系统的一个近似数值解。设 $h$ 为一个恒定的时间步长，并设 $(x_k, y_k)$ 表示在离散时间点 $t_k = kh$ 处种群 $(x(t_k), y(t_k))$ 的数值近似。\n\n两步Adams-Moulton方法是用于求解一般一阶系统 $\\mathbf{y}'(t) = \\mathbf{f}(t, \\mathbf{y}(t))$ 的一种隐式多步法。将解从第 $n$ 步推进到第 $n+1$ 步的公式为：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{12} \\left( 5 \\mathbf{f}_{n+1} + 8 \\mathbf{f}_n - \\mathbf{f}_{n-1} \\right)\n$$\n其中 $\\mathbf{y}_k$ 是 $\\mathbf{y}(t_k)$ 的近似，且 $\\mathbf{f}_k = \\mathbf{f}(t_k, \\mathbf{y}_k)$。\n\n当此方法应用于Lotka-Volterra系统时，在每个时间步长，它会产生一个关于未知状态 $(x_{n+1}, y_{n+1})$ 的耦合非线性代数方程组。假设状态 $(x_n, y_n)$ 和 $(x_{n-1}, y_{n-1})$ 已知，以下哪个选项正确表示了必须为 $(x_{n+1}, y_{n+1})$ 求解的该代数系统？\n\nA.\n$$\n\\begin{cases}\nx_{n+1} - x_n - \\frac{h}{12} [5(\\alpha x_{n+1} - \\beta x_{n+1}y_{n+1}) + 8(\\alpha x_n - \\beta x_n y_n) - (\\alpha x_{n-1} - \\beta x_{n-1} y_{n-1})] = 0 \\\\\ny_{n+1} - y_n - \\frac{h}{12} [5(\\delta x_{n+1}y_{n+1} - \\gamma y_{n+1}) + 8(\\delta x_n y_n - \\gamma y_n) - (\\delta x_{n-1} y_{n-1} - \\gamma y_{n-1})] = 0\n\\end{cases}\n$$\n\nB.\n$$\n\\begin{cases}\nx_{n+1} - x_n - \\frac{h}{12} [5(\\alpha x_{n+1} - \\beta x_{n+1}y_{n+1}) + 8(\\alpha x_n - \\beta x_n y_n) + (\\alpha x_{n-1} - \\beta x_{n-1} y_{n-1})] = 0 \\\\\ny_{n+1} - y_n - \\frac{h}{12} [5(\\delta x_{n+1}y_{n+1} - \\gamma y_{n+1}) + 8(\\delta x_n y_n - \\gamma y_n) + (\\delta x_{n-1} y_{n-1} - \\gamma y_{n-1})] = 0\n\\end{cases}\n$$\n\nC.\n$$\n\\begin{cases}\nx_{n+1} - x_n - \\frac{h}{2} [3(\\alpha x_n - \\beta x_n y_n) - (\\alpha x_{n-1} - \\beta x_{n-1} y_{n-1})] = 0 \\\\\ny_{n+1} - y_n - \\frac{h}{2} [3(\\delta x_n y_n - \\gamma y_n) - (\\delta x_{n-1} y_{n-1} - \\gamma y_{n-1})] = 0\n\\end{cases}\n$$\n\nD.\n$$\n\\begin{cases}\nx_{n+1} - x_n - \\frac{h}{12} [5(\\alpha x_{n+1} - \\beta x_{n+1}y_{n+1}) - (\\alpha x_n - \\beta x_n y_n) + 8(\\alpha x_{n-1} - \\beta x_{n-1} y_{n-1})] = 0 \\\\\ny_{n+1} - y_n - \\frac{h}{12} [5(\\delta x_{n+1}y_{n+1} - \\gamma y_{n+1}) - (\\delta x_n y_n - \\gamma y_n) + 8(\\delta x_{n-1} y_{n-1} - \\gamma y_{n-1})] = 0\n\\end{cases}\n$$", "solution": "给定用于求解一般一阶系统 $\\mathbf{y}'(t)=\\mathbf{f}(t,\\mathbf{y}(t))$ 的两步Adams-Moulton方法：\n$$\n\\mathbf{y}_{n+1}=\\mathbf{y}_{n}+\\frac{h}{12}\\left(5\\mathbf{f}_{n+1}+8\\mathbf{f}_{n}-\\mathbf{f}_{n-1}\\right),\n$$\n其中 $\\mathbf{f}_{k}=\\mathbf{f}(t_{k},\\mathbf{y}_{k})$。对于Lotka-Volterra系统，其中 $\\mathbf{y}=(x,y)^{T}$ 且\n$$\n\\mathbf{f}(t,(x,y)^{T})=\\begin{pmatrix}\\alpha x-\\beta xy\\\\ \\delta xy-\\gamma y\\end{pmatrix},\n$$\n该方法按分量应用。由于该系统是自治的，$\\mathbf{f}_{k}$ 仅取决于 $(x_{k},y_{k})$。将 $\\mathbf{f}$ 代入Adams-Moulton公式，得到\n$$\nx_{n+1}=x_{n}+\\frac{h}{12}\\left[5\\left(\\alpha x_{n+1}-\\beta x_{n+1}y_{n+1}\\right)+8\\left(\\alpha x_{n}-\\beta x_{n}y_{n}\\right)-\\left(\\alpha x_{n-1}-\\beta x_{n-1}y_{n-1}\\right)\\right],\n$$\n$$\ny_{n+1}=y_{n}+\\frac{h}{12}\\left[5\\left(\\delta x_{n+1}y_{n+1}-\\gamma y_{n+1}\\right)+8\\left(\\delta x_{n}y_{n}-\\gamma y_{n}\\right)-\\left(\\delta x_{n-1}y_{n-1}-\\gamma y_{n-1}\\right)\\right].\n$$\n将每个方程改写为残差等于零的形式，得到\n$$\nx_{n+1}-x_{n}-\\frac{h}{12}\\left[5\\left(\\alpha x_{n+1}-\\beta x_{n+1}y_{n+1}\\right)+8\\left(\\alpha x_{n}-\\beta x_{n}y_{n}\\right)-\\left(\\alpha x_{n-1}-\\beta x_{n-1}y_{n-1}\\right)\\right]=0,\n$$\n$$\ny_{n+1}-y_{n}-\\frac{h}{12}\\left[5\\left(\\delta x_{n+1}y_{n+1}-\\gamma y_{n+1}\\right)+8\\left(\\delta x_{n}y_{n}-\\gamma y_{n}\\right)-\\left(\\delta x_{n-1}y_{n-1}-\\gamma y_{n-1}\\right)\\right]=0,\n$$\n这与选项A相匹配。选项B中 $\\mathbf{f}_{n-1}$ 项的符号错误，选项C是显式两步Adams-Bashforth方法，而选项D的系数位置不正确。", "answer": "$$\\boxed{A}$$", "id": "2187866"}, {"introduction": "一个数值方法的价值不仅在于其单步的准确性，更在于其长期积分下的定性行为。这个高级练习 ([@problem_id:2410042]) 将引导你从单步的实现转向对累积效应的批判性分析。通过对一个保守物理系统（如谐振子）应用 Adams-Bashforth-Moulton 预估-校正格式，你将通过编程数值地发现其一个基本缺陷：能量不守恒，出现长期漂移。这个实践揭示了在模拟物理系统时选择保持几何结构（辛性）的积分方法的重要性。", "problem": "本题要求您从基本原理出发，研究一个标准的 Adams–Bashforth/Adams–Moulton 线性多步法在应用于形如 $y''=f(y)$ 的二阶保守系统时，是否能保持其辛结构。在此类系统的精确动力学中，总能量是守恒的，而一个辛数值积分器会保持辛2-形式，通常表现为有界的、振荡的能量误差，而没有长期漂移。您的任务是通过数值方法证明，将一个二阶 Adams–Bashforth 方法与一个二阶 Adams–Moulton 方法的标准预测-校正对（常记作 AB$2$/AM$2$），以朴素的方式应用于 $y''=f(y)$ 的一阶形式，无法保持辛结构，并表现出长期能量漂移。\n\n从以下基本依据开始：\n- 通过引入 $x=y$ 和 $v=y'$，将二阶常微分方程 $y''=f(y)$ 表示为一个一阶系统，使得 $x'=v$ 和 $v'=f(x)$。对于势能为 $U(x)$ 的保守力 $f(x)=-\\partial U/\\partial x$，该系统具有一个哈密顿量（总能量）$H(x,v)$，它在精确流下是守恒的。\n- 将总能量定义为 $H(x,v)=\\tfrac{1}{2}v^{2}+U(x)$，其中 $U(x)$ 由 $f(x)=-U'(x)$ 决定。\n- 线性多步 Adams 方法是通过对右端项的插值多项式近似在单个步长上进行积分来构造的，该插值使用了等间距的过去节点。\n\n在这些基础上推导：\n- 使用右端项的过去评价值来推进一个步长的二阶 Adams–Bashforth 预测格式。\n- 用于同一步长的二阶 Adams–Moulton 校正格式，以及将标准的单步预测-求值-校正-求值 (PECE) 方案逐分量地应用于一阶系统 $(x',v')=(v,f(x))$。\n- 在多步迭代开始之前，从初始条件获得第一个额外状态的一种单步自启动方法。\n\n为该一阶系统实现所得到的 AB$2$/AM$2$ PECE 算法，并用它在一个长时间区间上进行积分。通过最小二乘法将直线 $H(t)\\approx \\alpha t+\\beta$ 拟合到数值计算出的能量序列，并报告估计的斜率 $\\alpha$，以此来量化能量漂移的存在与否。\n\n使用以下测试用例集，所有用例的初始条件均为 $x(0)=y(0)=1$ 和 $v(0)=y'(0)=0$：\n- 用例 A（简谐振子）：$f(y)=-y$，势能 $U(x)=\\tfrac{1}{2}x^{2}$，时间步长 $h=0.1$（无量纲），总模拟时间 $T=1000$（无量纲）。\n- 用例 B（简谐振子）：$f(y)=-y$，势能 $U(x)=\\tfrac{1}{2}x^{2}$，时间步长 $h=0.05$（无量纲），总模拟时间 $T=1000$（无量纲）。\n- 用例 C（数学摆）：$f(y)=-\\sin(y)$，势能 $U(x)=1-\\cos(x)$，时间步长 $h=0.05$（无量纲），总模拟时间 $T=1000$（无量纲），其中角度 $x$ 以弧度为单位。\n\n实现要求：\n- 将 $y''=f(y)$ 重构为一阶系统 $(x',v')=(v,f(x))$，并逐分量地应用您的 AB$2$/AM$2$ PECE 方法。\n- 使用您选择的单步、显式、自启动方法来生成多步法所需的第一个额外值；例如，一个经典的四阶龙格－库塔步是可以接受的。\n- 在每个时间 $t_{n}$ 计算离散能量 $H_{n}=H(x_{n},v_{n})$，并通过在整个模拟窗口内对 $H_{n}$ 与 $t_{n}$ 进行最小二乘拟合来估计漂移斜率 $\\alpha$。\n- 对于每个用例，将标量斜率 $\\alpha$ 报告为一个四舍五入到 $6$ 位有效数字的浮点数。本问题不需要物理单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [用例 A, 用例 B, 用例 C]。例如，您的程序必须打印一行格式为 $[a,b,c]$ 的内容，其中 $a$、$b$ 和 $c$ 是三个用例所要求的斜率，每个都四舍五入到 $6$ 位有效数字。\n\n需要精确实现的测试用例总结：\n- 用例 A：$(f(y)=-y,\\,h=0.1,\\,T=1000)$。\n- 用例 B：$(f(y)=-y,\\,h=0.05,\\,T=1000)$。\n- 用例 C：$(f(y)=-\\sin(y),\\,h=0.05,\\,T=1000)$，角度单位为弧度。\n\n您的程序必须是自包含的，不需要任何输入，并严格遵循指定的输出格式。", "solution": "我们首先通过引入 $x=y$ 和 $v=y'$，将二阶常微分方程 $y''=f(y)$ 重构为一个一阶系统。这得到系统：\n$$\nx'=v,\\qquad v'=f(x).\n$$\n对于保守力 $f(x)=-U'(x)$，其哈密顿量（总能量）为：\n$$\nH(x,v)=\\tfrac{1}{2}v^{2}+U(x),\n$$\n它在精确解下是守恒的。辛积分器保持典范辛2-形式，尽管它们通常不会在每一步都精确地保持 $H$ 守恒，但它们通常会在长时间内产生有界的、振荡的能量误差，而没有长期漂移。相比之下，非辛方法通常在拟合的能量趋势中表现出长期的增长或衰减。\n\nAdams 线性多步法族是通过将右端项替换为通过过去数据点（显式 Adams–Bashforth）或包含新数据点（隐式 Adams–Moulton）的多项式插值，并在一个步长上进行积分而得出的。对于均匀步长 $h$，令 $t_{n+1}=t_{n}+h$ 且 $y_{n}\\approx y(t_{n})$。二阶 Adams–Bashforth 方法是通过对穿过 $(t_{n},f_{n})$ 和 $(t_{n-1},f_{n-1})$ 的1次拉格朗日插值多项式进行积分得到的，从而得出：\n$$\ny_{n+1}=y_{n}+h\\left(\\tfrac{3}{2}f_{n}-\\tfrac{1}{2}f_{n-1}\\right).\n$$\n二阶 Adams–Moulton 方法（梯形法则）对穿过 $(t_{n},f_{n})$ 和 $(t_{n+1},f_{n+1})$ 的1次插值多项式进行积分，得到：\n$$\ny_{n+1}=y_{n}+h\\left(\\tfrac{1}{2}f_{n+1}+\\tfrac{1}{2}f_{n}\\right).\n$$\n当应用于向量一阶系统 $z' = G(z)$（其中 $z=[x,v]^{\\top}$ 且 $G(z)=[v,\\,f(x)]^{\\top}$）时，这些公式以分量方式成立，其中 $f_{n}$ 被替换为 $G(z_{n})$。\n\n一个标准的预测-求值-校正-求值 (PECE) 方案，它将 AB$2$（预测）和 AM$2$（校正）配对使用，执行如下操作：\n- 预测（AB$2$）：\n$$\nz_{n+1}^{\\mathrm{p}}=z_{n}+h\\left(\\tfrac{3}{2}G(z_{n})-\\tfrac{1}{2}G(z_{n-1})\\right).\n$$\n- 在预测值处求值：计算 $G(z_{n+1}^{\\mathrm{p}})$。\n- 校正（AM$2$ 在预测值处进行一次求值）：\n$$\nz_{n+1}=z_{n}+h\\left(\\tfrac{1}{2}G(z_{n+1}^{\\mathrm{p}})+\\tfrac{1}{2}G(z_{n})\\right).\n$$\n这是 AB/AM 对的一种常见的实际实现方式，它避免了求解一个完全隐式的系统。然而，对于一般的哈密顿系统，这种 PECE 变体不是辛的。\n\n因为线性多步法需要初始条件之外的起始值，我们采用一种单步显式方法从 $z_{0}$ 计算 $z_{1}$。使用一个步长为 $h$ 的经典的四阶龙格－库塔 (RK$4$) 步即可：\n$$\n\\begin{aligned}\nk_{1}=G(z_{0}),\\\\\nk_{2}=G\\!\\left(z_{0}+\\tfrac{h}{2}k_{1}\\right),\\\\\nk_{3}=G\\!\\left(z_{0}+\\tfrac{h}{2}k_{2}\\right),\\\\\nk_{4}=G\\!\\left(z_{0}+h\\,k_{3}\\right),\\\\\nz_{1}=z_{0}+\\tfrac{h}{6}\\left(k_{1}+2k_{2}+2k_{3}+k_{4}\\right).\n\\end{aligned}\n$$\n\n为了诊断能量漂移，我们在区间 $[0,T]$ 上（其中 $N=T/h$）计算在时间 $t_{n}=n\\,h$ 的能量序列 $H_{n}=H(x_{n},v_{n})$（对于 $n=0,1,\\dots,N$）。我们通过最小二乘法拟合一条直线 $H_{n}\\approx \\alpha t_{n}+\\beta$。最小二乘斜率为：\n$$\n\\alpha=\\frac{\\sum_{n=0}^{N}(t_{n}-\\bar{t})(H_{n}-\\bar{H})}{\\sum_{n=0}^{N}(t_{n}-\\bar{t})^{2}},\n$$\n其中 $\\bar{t}$ 和 $\\bar{H}$ 分别是 $\\{t_{n}\\}$ 和 $\\{H_{n}\\}$ 的样本均值。在长区间上非零的 $\\alpha$ 表明存在长期能量漂移，这与精确的辛结构保持不相容。\n\n我们定义测试系统及其能量：\n- 对于简谐振子，$f(y)=-y$，其势能为 $U(x)=\\tfrac{1}{2}x^{2}$，因此\n$$\nH(x,v)=\\tfrac{1}{2}v^{2}+\\tfrac{1}{2}x^{2}.\n$$\n- 对于数学摆，$f(y)=-\\sin(y)$，其势能为 $U(x)=1-\\cos(x)$，因此\n$$\nH(x,v)=\\tfrac{1}{2}v^{2}+1-\\cos(x),\n$$\n其中 $x$ 的单位是弧度。\n\n各用例的算法总结：\n- 设置 $z_{0}=[x_{0},v_{0}]^{\\top}$，其中 $x_{0}=1$ 且 $v_{0}=0$。\n- 使用步长为 $h$ 的 RK$4$ 方法计算 $z_{1}$。\n- 对于 $n=1,2,\\dots,N-1$，迭代 AB$2$/AM$2$ PECE 更新以获得 $z_{n+1}$。\n- 在每一步计算 $H_{n}$，然后通过最小二乘法估计 $\\alpha$。\n- 报告四舍五入到 $6$ 位有效数字的 $\\alpha$。\n\n预期的定性结果：\n- 对于简谐振子，像 Störmer–Verlet 格式这样的辛方法会产生一个非常接近 $0$ 的 $\\alpha$，且 $H_{n}$ 具有有界振荡。而 AB$2$/AM$2$ PECE 方法在此应用中是非辛的，会产生一个非零的 $\\alpha$，其大小随 $h$ 增长。\n- 对于摆，会发生同样的现象；拟合的斜率 $\\alpha$ 非零，表明存在漂移。\n\n程序实现了以上算法，并按要求的顺序和格式 $[a,b,c]$ 打印三个斜率，每个斜率都精确到 $6$ 位有效数字。", "answer": "```python\nimport numpy as np\n\ndef rk4_step(G, z, h):\n    k1 = G(z)\n    k2 = G(z + 0.5 * h * k1)\n    k3 = G(z + 0.5 * h * k2)\n    k4 = G(z + h * k3)\n    return z + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\ndef ab2_am2_pece(G, z0, h, T):\n    N = int(round(T / h))\n    t = np.linspace(0.0, N * h, N + 1)\n    z = np.zeros((N + 1, 2), dtype=float)\n    z[0] = z0\n    # Self-start with RK4 to obtain z[1]\n    z[1] = rk4_step(G, z[0], h)\n    # Precompute G at steps 0 and 1\n    G_prev = G(z[0])\n    G_curr = G(z[1])\n    for n in range(1, N):\n        # Predictor: AB2\n        z_pred = z[n] + h * (1.5 * G_curr - 0.5 * G_prev)\n        G_pred = G(z_pred)\n        # Corrector: AM2 with one evaluation (PECE)\n        z_next = z[n] + 0.5 * h * (G_pred + G_curr)\n        # Shift for next iteration\n        z[n + 1] = z_next\n        G_prev, G_curr = G_curr, G(z_next)\n    return t, z\n\ndef make_system(system_name):\n    if system_name == \"sho\":\n        # f(x) = -x\n        def G(z):\n            x, v = z\n            return np.array([v, -x], dtype=float)\n        def energy(z):\n            x, v = z\n            return 0.5 * v * v + 0.5 * x * x\n        return G, energy\n    elif system_name == \"pendulum\":\n        # f(x) = -sin(x), x in radians\n        def G(z):\n            x, v = z\n            return np.array([v, -np.sin(x)], dtype=float)\n        def energy(z):\n            x, v = z\n            return 0.5 * v * v + (1.0 - np.cos(x))\n        return G, energy\n    else:\n        raise ValueError(\"Unknown system\")\n\ndef energy_drift_slope(t, H):\n    # Least-squares slope of H versus t\n    t_mean = np.mean(t)\n    H_mean = np.mean(H)\n    num = np.sum((t - t_mean) * (H - H_mean))\n    den = np.sum((t - t_mean) ** 2)\n    return num / den if den != 0.0 else 0.0\n\ndef run_case(system_name, h, T):\n    G, energy = make_system(system_name)\n    z0 = np.array([1.0, 0.0], dtype=float)\n    t, z = ab2_am2_pece(G, z0, h, T)\n    H = np.array([energy(zi) for zi in z])\n    slope = energy_drift_slope(t, H)\n    return slope\n\ndef solve():\n    # Define the test cases as per the problem statement:\n    # Case A: (sho, h=0.1, T=1000)\n    # Case B: (sho, h=0.05, T=1000)\n    # Case C: (pendulum, h=0.05, T=1000), angle in radians\n    test_cases = [\n        (\"sho\", 0.1, 1000.0),\n        (\"sho\", 0.05, 1000.0),\n        (\"pendulum\", 0.05, 1000.0),\n    ]\n\n    results = []\n    for system_name, h, T in test_cases:\n        slope = run_case(system_name, h, T)\n        results.append(slope)\n\n    # Format each result to 6 significant digits\n    formatted = [f\"{v:.6g}\" for v in results]\n    print(f\"[{','.join(formatted)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410042"}]}