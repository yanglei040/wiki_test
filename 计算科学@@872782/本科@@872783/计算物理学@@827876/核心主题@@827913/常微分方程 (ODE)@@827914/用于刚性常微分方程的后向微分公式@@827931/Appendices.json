{"hands_on_practices": [{"introduction": "要精通一个工具，我们必须首先理解它的构造原理。第一个练习将带你回到基本原理，指导你从第一性原理出发，推导四阶后向差分公式（BDF-4）。通过应用待定系数法，你将亲眼见证这些公式如何被精确设计以达到特定的精度阶数，从而巩固你对这些强大求解器的基础知识。[@problem_id:2372656]", "problem": "一种称为后向差分格式 (BDF) 的隐式线性多步法被广泛用于求解刚性常微分方程 (ODE)。考虑在步长为 $h0$ 的均匀网格上，一个4阶的后向差分格式 (BDF)。假设它具有如下的线性多步形式：\n$$\n\\sum_{j=0}^{4} \\alpha_{j}\\, y_{n+1-j} \\;=\\; h\\, f\\!\\left(t_{n+1},y_{n+1}\\right),\n$$\n其中 $y_{k}$ 是 $y(t_{k})$ 的近似值，并且该方法仅使用后向值 $y_{n+1},y_{n},y_{n-1},y_{n-2},y_{n-3}$。目标是通过将待定系数法应用于后向插值多项式来确定系数 $\\alpha_{0},\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}$。\n\n仅从核心定义出发，即一个4阶BDF方法在 $y$ 求解 $y^{\\prime}=f(t,y)$ 时，对于次数至多为4的所有多项式必须精确成立，请通过对单项式施加精确性条件来推导唯一的系数 $\\alpha_{0},\\dots,\\alpha_{4}$。此过程需先进行换元 $p(s)=y(t_{n+1}+s h)$，这将后向节点置于 $s=0,-1,-2,-3,-4$，并将 $h\\, y^{\\prime}(t_{n+1})$ 转换为 $p^{\\prime}(0)$。\n\n请以行向量 $\\left(\\alpha_{0},\\alpha_{1},\\alpha_{2},\\alpha_{3},\\alpha_{4}\\right)$ 的精确有理数形式报告您的最终结果。无需四舍五入，不涉及单位。", "solution": "问题要求推导4阶后向差分格式 (BDF) 的系数 $\\alpha_j$，其形式如下：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} y_{n+1-j} = h f(t_{n+1}, y_{n+1})\n$$\n该方法的阶数为4，这意味着对于任意次数至多为4的多项式 $y(t)$，该方法必须是精确的。当 $y(t)$ 是一个多项式时，其导数 $y'(t)$ 也是一个多项式，微分方程 $y' = f(t,y)$ 变为 $y'(t) = f(t, y(t))$。因此，精确性条件为：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} y(t_{n+1-j}) = h y'(t_{n+1})\n$$\n此式对任意次数 $k \\le 4$ 的多项式 $y(t)$ 成立。\n\n按照提示，我们引入一个经过缩放的无量纲时间变量 $s = \\frac{t - t_{n+1}}{h}$。通过此代换，时间点 $t_{n+1-j} = t_{n+1} - jh$ 对应于 $s = -j$，其中 $j=0, 1, 2, 3, 4$。令 $p(s) = y(t_{n+1} + sh)$。则 $y(t_{n+1-j}) = p(-j)$。\n导数变换为 $y'(t) = \\frac{dp}{ds}\\frac{ds}{dt} = p'(s) \\frac{1}{h}$。在 $t=t_{n+1}$ 处，我们有 $s=0$，所以 $y'(t_{n+1}) = \\frac{1}{h} p'(0)$。\n将这些代入精确性条件，得到：\n$$\n\\sum_{j=0}^{4} \\alpha_{j} p(-j) = h \\left( \\frac{1}{h} p'(0) \\right) = p'(0)\n$$\n这个方程必须对任意次数至多为4的多项式 $p(s)$ 成立。我们可以对次数至多为4的多项式空间的一组基施加此条件，我们选择单项式 $p(s) = s^k$ 作为基，其中 $k \\in \\{0, 1, 2, 3, 4\\}$。\n\n对于每个 $k$ 值，我们得到一个关于系数 $\\alpha_j$ 的线性方程：\n1. 对于 $k=0$：$p(s) = s^0 = 1$。则 $p'(s) = 0$，所以 $p'(0)=0$。\n   条件变为 $\\sum_{j=0}^{4} \\alpha_j (1) = 0$，即：\n   $$\n   \\alpha_0 + \\alpha_1 + \\alpha_2 + \\alpha_3 + \\alpha_4 = 0\n   $$\n\n2. 对于 $k=1$：$p(s) = s^1 = s$。则 $p'(s) = 1$，所以 $p'(0)=1$。\n   条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j) = 1$，即：\n   $$\n   0\\alpha_0 - 1\\alpha_1 - 2\\alpha_2 - 3\\alpha_3 - 4\\alpha_4 = 1\n   $$\n\n3. 对于 $k=2$：$p(s) = s^2$。则 $p'(s) = 2s$，所以 $p'(0)=0$。\n   条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^2 = 0$，即：\n   $$\n   0\\alpha_0 + 1\\alpha_1 + 4\\alpha_2 + 9\\alpha_3 + 16\\alpha_4 = 0\n   $$\n\n4. 对于 $k=3$：$p(s) = s^3$。则 $p'(s) = 3s^2$，所以 $p'(0)=0$。\n   条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^3 = 0$，即：\n   $$\n   0\\alpha_0 - 1\\alpha_1 - 8\\alpha_2 - 27\\alpha_3 - 64\\alpha_4 = 0\n   $$\n\n5. 对于 $k=4$：$p(s) = s^4$。则 $p'(s) = 4s^3$，所以 $p'(0)=0$。\n   条件变为 $\\sum_{j=0}^{4} \\alpha_j (-j)^4 = 0$，即：\n   $$\n   0\\alpha_0 + 1\\alpha_1 + 16\\alpha_2 + 81\\alpha_3 + 256\\alpha_4 = 0\n   $$\n\n我们得到了一个包含5个未知系数 $(\\alpha_0, \\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4)$ 的5元线性方程组。注意 $\\alpha_0$ 没有出现在方程(2)到(5)中。我们可以先解出由 $\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4$ 组成的 $4 \\times 4$ 方程组，然后从方程(1)中求出 $\\alpha_0$。\n\n关于 $\\alpha_1, \\dots, \\alpha_4$ 的方程组是：\n(A) $-\\alpha_1 - 2\\alpha_2 - 3\\alpha_3 - 4\\alpha_4 = 1$\n(B) $\\alpha_1 + 4\\alpha_2 + 9\\alpha_3 + 16\\alpha_4 = 0$\n(C) $-\\alpha_1 - 8\\alpha_2 - 27\\alpha_3 - 64\\alpha_4 = 0$\n(D) $\\alpha_1 + 16\\alpha_2 + 81\\alpha_3 + 256\\alpha_4 = 0$\n\n我们通过消元法求解该方程组。\n将(A)和(B)相加：\n$$ (2\\alpha_2 + 6\\alpha_3 + 12\\alpha_4 = 1) \\quad (\\text{E}) $$\n将(B)和(C)相加：\n$$ -4\\alpha_2 - 18\\alpha_3 - 48\\alpha_4 = 0 \\implies (2\\alpha_2 + 9\\alpha_3 + 24\\alpha_4 = 0) \\quad (\\text{F}) $$\n将(C)和(D)相加：\n$$ 8\\alpha_2 + 54\\alpha_3 + 192\\alpha_4 = 0 \\implies (4\\alpha_2 + 27\\alpha_3 + 96\\alpha_4 = 0) \\quad (\\text{G}) $$\n\n现在我们得到一个关于 $\\alpha_2, \\alpha_3, \\alpha_4$ 的 $3 \\times 3$ 方程组。\n从(F)中减去(E)：\n$$ (3\\alpha_3 + 12\\alpha_4 = -1) \\quad (\\text{H}) $$\n从(G)中减去 $2 \\times (\\text{F})$：\n$$ (4\\alpha_2 + 27\\alpha_3 + 96\\alpha_4) - 2(2\\alpha_2 + 9\\alpha_3 + 24\\alpha_4) = 0 - 0 $$\n$$ 9\\alpha_3 + 48\\alpha_4 = 0 \\implies (3\\alpha_3 + 16\\alpha_4 = 0) \\quad (\\text{I}) $$\n\n现在我们得到一个关于 $\\alpha_3, \\alpha_4$ 的 $2 \\times 2$ 方程组。\n从(I)中减去(H)：\n$$ (3\\alpha_3 + 16\\alpha_4) - (3\\alpha_3 + 12\\alpha_4) = 0 - (-1) $$\n$$ 4\\alpha_4 = 1 \\implies \\alpha_4 = \\frac{1}{4} $$\n\n将 $\\alpha_4 = \\frac{1}{4}$ 代入(I)：\n$$ 3\\alpha_3 + 16\\left(\\frac{1}{4}\\right) = 0 \\implies 3\\alpha_3 + 4 = 0 \\implies \\alpha_3 = -\\frac{4}{3} $$\n\n将 $\\alpha_3$ 和 $\\alpha_4$ 代入(E)：\n$$ 2\\alpha_2 + 6\\left(-\\frac{4}{3}\\right) + 12\\left(\\frac{1}{4}\\right) = 1 $$\n$$ 2\\alpha_2 - 8 + 3 = 1 \\implies 2\\alpha_2 - 5 = 1 \\implies 2\\alpha_2 = 6 \\implies \\alpha_2 = 3 $$\n\n将 $\\alpha_2, \\alpha_3, \\alpha_4$ 代入(A)：\n$$ -\\alpha_1 - 2(3) - 3\\left(-\\frac{4}{3}\\right) - 4\\left(\\frac{1}{4}\\right) = 1 $$\n$$ -\\alpha_1 - 6 + 4 - 1 = 1 \\implies -\\alpha_1 - 3 = 1 \\implies \\alpha_1 = -4 $$\n\n最后，使用方程(1)求 $\\alpha_0$：\n$$ \\alpha_0 + (-4) + 3 + \\left(-\\frac{4}{3}\\right) + \\frac{1}{4} = 0 $$\n$$ \\alpha_0 - 1 - \\frac{4}{3} + \\frac{1}{4} = 0 $$\n$$ \\alpha_0 = 1 + \\frac{4}{3} - \\frac{1}{4} = \\frac{12}{12} + \\frac{16}{12} - \\frac{3}{12} = \\frac{25}{12} $$\n\n这些系数是：\n$\\alpha_0 = \\frac{25}{12}$\n$\\alpha_1 = -4$\n$\\alpha_2 = 3$\n$\\alpha_3 = -\\frac{4}{3}$\n$\\alpha_4 = \\frac{1}{4}$\n\n这些系数定义了具有所要求归一化的BDF4格式，该归一化对应于 $h f(t_{n+1}, y_{n+1})$ 的系数为1。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{25}{12}  -4  3  -\\frac{4}{3}  \\frac{1}{4}\n\\end{pmatrix}\n}\n$$", "id": "2372656"}, {"introduction": "数值方法虽然功能强大，但有时也会在模拟中引入非物理行为。这个练习将从纯理论转向一个具体的数值实验，你将把最简单的一阶后向差分公式（BDF-1，即隐式欧拉法）应用于一个无摩擦的谐振子——一个机械能理应守恒的系统。通过解析推导和数值验证其人为的能量耗散率，你将对BDF方法固有的“数值阻尼”特性获得关键的直观理解。[@problem_id:2374983]", "problem": "考虑由常微分方程 (ODE) $y'' + y = 0$ 控制的无摩擦谐振子。引入状态向量 $\\mathbf{z}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，其中 $v(t) = y'(t)$，从而动力学可以写成一阶线性系统 $\\,\\mathbf{z}'(t) = A \\mathbf{z}(t)$，其中 $A = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$。阶数为一的后向差分公式 (BDF)（即隐式欧拉法），步长为 $h  0$，其定义为应用于 $\\mathbf{z}' = f(t, \\mathbf{z})$ 的隐式更新 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + h f(t_{n+1}, \\mathbf{z}_{n+1})$。将第 $n$ 步的离散机械能定义为 $E_n = \\tfrac{1}{2}\\left(y_n^2 + v_n^2\\right)$。\n\n您的任务是：\n\n1) 仅从 BDF1（隐式欧拉）格式的定义和上述状态空间公式出发，推导出形如 $\\mathbf{z}_{n+1} = G(h)\\,\\mathbf{z}_n$ 的单步更新。其中 $G(h)$ 是一个仅依赖于 $h$ 的 $2\\times 2$ 矩阵。然后，仅使用代数操作和 $E_n$ 的定义，推导出由 $E_{n+1} = r(h)\\,E_n$ 定义的常数单步能量衰减因子 $r(h)$ 的精确表达式。您的推导必须证明 $r(h)$ 与步数 $n$ 以及具体的状态 $\\mathbf{z}_n$ 无关。\n\n2) 实现一个程序，该程序：\n- 以 $y(0) = 1$ 和 $v(0) = 0$ 进行初始化，因此 $E_0 = \\tfrac{1}{2}$。\n- 使用 BDF1 更新，以固定步长 $h$ 推进解 $N$ 步，得到 $(y_N, v_N)$ 和 $E_N$。\n- 计算测得的单步衰减因子 $\\hat{r}(h,N) = \\left(\\dfrac{E_N}{E_0}\\right)^{1/N}$。\n- 计算第 1 部分中解析推导出的 $r(h)$。\n- 对每个测试用例，返回绝对误差 $\\left|\\hat{r}(h,N) - r(h)\\right|$，结果为浮点数。\n\n您的程序必须运行以下测试套件：\n- 测试用例 1: $h = 0.1$, $N = 100$。\n- 测试用例 2: $h = 0.5$, $N = 40$。\n- 测试用例 3: $h = 1.0$, $N = 20$。\n- 测试用例 4: $h = 2.0$, $N = 10$。\n- 测试用例 5: $h = 10^{-6}$, $N = 100000$。\n\n所有数值均为无量纲。若有任何角度隐式出现，应理解为弧度。\n\n最终输出格式要求：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述测试用例顺序排列的结果（例如，$[x_1,x_2,x_3,x_4,x_5]$）。\n- 每个 $x_i$ 必须是上文定义的绝对误差 $\\left|\\hat{r}(h_i,N_i) - r(h_i)\\right|$，表示为浮点数。", "solution": "该问题是有效的，将按要求分两部分解决：首先是形式推导，然后是数值实现。\n\n无摩擦谐振子的动力学由一阶线性系统 $\\mathbf{z}'(t) = A \\mathbf{z}(t)$ 描述，其中状态向量为 $\\mathbf{z}(t) = \\begin{bmatrix} y(t) \\\\ v(t) \\end{bmatrix}$，系统矩阵为 $A = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}$。阶数为一的后向差分公式 (BDF1)，即隐式欧拉法，根据隐式关系 $\\mathbf{z}_{n+1} = \\mathbf{z}_n + hf(t_{n+1}, \\mathbf{z}_{n+1})$，使用步长 $h  0$ 将解从第 $n$ 步推进到第 $n+1$ 步。对于此线性系统，$f(t, \\mathbf{z}) = A\\mathbf{z}$。\n\n首先，我们推导变换 $\\mathbf{z}_{n+1} = G(h)\\mathbf{z}_n$ 的单步更新矩阵 $G(h)$。将系统的右侧代入 BDF1 公式可得：\n$$ \\mathbf{z}_{n+1} = \\mathbf{z}_n + h A \\mathbf{z}_{n+1} $$\n为了找到 $\\mathbf{z}_{n+1}$ 的显式表达式，我们必须重新整理此方程。将包含 $\\mathbf{z}_{n+1}$ 的项归到左侧，得到：\n$$ \\mathbf{z}_{n+1} - h A \\mathbf{z}_{n+1} = \\mathbf{z}_n $$\n通过提出因子 $\\mathbf{z}_{n+1}$ 并使用 $2 \\times 2$ 单位矩阵 $I$，我们得到：\n$$ (I - hA) \\mathbf{z}_{n+1} = \\mathbf{z}_n $$\n假设矩阵 $(I - hA)$ 非奇异，我们用其逆矩阵左乘，解出 $\\mathbf{z}_{n+1}$：\n$$ \\mathbf{z}_{n+1} = (I - hA)^{-1} \\mathbf{z}_n $$\n这就是所要求的形式，其中单步更新矩阵被确定为 $G(h) = (I - hA)^{-1}$。现在我们计算这个矩阵。矩阵 $(I - hA)$ 为：\n$$ I - hA = \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} - h \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} = \\begin{bmatrix} 1  -h \\\\ h  1 \\end{bmatrix} $$\n其行列式为 $\\det(I - hA) = (1)(1) - (-h)(h) = 1 + h^2$。由于 $h$ 是实数，$1 + h^2  0$，所以逆矩阵存在。使用 $2 \\times 2$ 矩阵的逆矩阵公式，我们得到：\n$$ G(h) = (I - hA)^{-1} = \\frac{1}{1+h^2} \\begin{bmatrix} 1  h \\\\ -h  1 \\end{bmatrix} $$\n这样就完成了更新矩阵 $G(h)$ 的推导。\n\n其次，我们推导单步能量衰减因子 $r(h)$。第 $n$ 步的离散能量是 $E_n = \\frac{1}{2}(y_n^2 + v_n^2)$，可以用向量表示为 $E_n = \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n$。第 $n+1$ 步的能量是 $E_{n+1} = \\frac{1}{2} \\mathbf{z}_{n+1}^T \\mathbf{z}_{n+1}$。我们将更新规则 $\\mathbf{z}_{n+1} = G(h)\\mathbf{z}_n$ 代入此表达式：\n$$ E_{n+1} = \\frac{1}{2} (G(h)\\mathbf{z}_n)^T (G(h)\\mathbf{z}_n) $$\n使用转置的性质 $(AB)^T = B^T A^T$，上式变为：\n$$ E_{n+1} = \\frac{1}{2} \\mathbf{z}_n^T G(h)^T G(h) \\mathbf{z}_n $$\n该方程的结构表明我们应该分析矩阵乘积 $G(h)^T G(h)$。$G(h)$ 的转置是：\n$$ G(h)^T = \\left( \\frac{1}{1+h^2} \\begin{bmatrix} 1  h \\\\ -h  1 \\end{bmatrix} \\right)^T = \\frac{1}{1+h^2} \\begin{bmatrix} 1  -h \\\\ h  1 \\end{bmatrix} $$\n那么乘积为：\n$$ G(h)^T G(h) = \\left( \\frac{1}{1+h^2} \\right)^2 \\begin{bmatrix} 1  -h \\\\ h  1 \\end{bmatrix} \\begin{bmatrix} 1  h \\\\ -h  1 \\end{bmatrix} = \\frac{1}{(1+h^2)^2} \\begin{bmatrix} 1+h^2  0 \\\\ 0  1+h^2 \\end{bmatrix} $$\n从矩阵中提出标量因子 $(1+h^2)$ 得到：\n$$ G(h)^T G(h) = \\frac{1+h^2}{(1+h^2)^2} \\begin{bmatrix} 1  0 \\\\ 0  1 \\end{bmatrix} = \\frac{1}{1+h^2} I $$\n这表明 $G(h)^T G(h)$ 是单位矩阵的一个标量倍。将此结果代回 $E_{n+1}$ 的表达式中：\n$$ E_{n+1} = \\frac{1}{2} \\mathbf{z}_n^T \\left( \\frac{1}{1+h^2} I \\right) \\mathbf{z}_n = \\frac{1}{1+h^2} \\left( \\frac{1}{2} \\mathbf{z}_n^T I \\mathbf{z}_n \\right) = \\frac{1}{1+h^2} \\left( \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n \\right) $$\n注意到 $E_n = \\frac{1}{2} \\mathbf{z}_n^T \\mathbf{z}_n$，我们得到所需的关系：\n$$ E_{n+1} = \\frac{1}{1+h^2} E_n $$\n这就是 $E_{n+1} = r(h)E_n$ 的形式，其中能量衰减因子为：\n$$ r(h) = \\frac{1}{1+h^2} $$\n此表达式仅依赖于步长 $h$，从而证明了对于固定的 $h$，它是一个常数，并且与步数 $n$或状态 $\\mathbf{z}_n$ 无关。至此完成了所要求的推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the specified test suite for the BDF1 method\n    applied to a harmonic oscillator.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, N)\n        (0.1, 100),\n        (0.5, 40),\n        (1.0, 20),\n        (2.0, 10),\n        (1e-6, 100000),\n    ]\n\n    results = []\n    for h, N in test_cases:\n        # Main logic to calculate the result for one case goes here.\n\n        # 1. Initialization\n        # Initial state vector z_0 = [y(0), v(0)]^T\n        z_0 = np.array([1.0, 0.0])\n        # Initial energy E_0 = 0.5 * (y(0)^2 + v(0)^2)\n        E_0 = 0.5 * (z_0[0]**2 + z_0[1]**2)\n\n        # 2. Analytical damping factor from the derivation\n        r_analytic = 1.0 / (1.0 + h**2)\n\n        # 3. Numerical Simulation\n        # Construct the one-step update matrix G(h)\n        G_h = (1.0 / (1.0 + h**2)) * np.array([[1.0, h], [-h, 1.0]])\n\n        # Advance the solution for N steps\n        z_current = z_0\n        for _ in range(N):\n            z_current = G_h @ z_current\n        z_N = z_current\n\n        # Compute the final energy E_N\n        E_N = 0.5 * (z_N[0]**2 + z_N[1]**2)\n\n        # 4. Compute measured damping factor and discrepancy\n        # Measured per-step damping factor r_hat\n        if E_0 == 0.0:\n            # Avoid division by zero, though not possible with given initial state.\n            # If E_0 is 0, E_N will also be 0, so r_hat is indeterminate.\n            # In this problem context, E_0 is always 0.5.\n            r_hat = 0.0 # Placeholder, won't be reached\n        else:\n            # Using np.power for robust floating point exponentiation.\n            r_hat = np.power(E_N / E_0, 1.0 / N)\n\n        # Absolute discrepancy between measured and analytical factors\n        discrepancy = np.abs(r_hat - r_analytic)\n        results.append(discrepancy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2374983"}, {"introduction": "尽管BDF方法是解决刚性问题的主力，但在处理剧烈瞬变时，并非所有阶数的表现都同样出色。最后一个练习将直面高阶BDF方法（$k2$）的一个关键限制：“振铃”或过冲伪影。通过模拟一个刚性系统对阶跃输入的响应，你将亲眼观察到这种振荡行为并理解其发生的原因，从而揭示精度阶数与定性稳定性之间的权衡。[@problem_id:2374956]", "problem": "给定一个带阶跃函数强迫项的标量、线性、刚性常微分方程的初值问题：\n$$\n\\frac{d y}{d t} = -\\lambda\\, y(t) + \\lambda\\, u(t), \\quad y(0)=0,\n$$\n其中 $u(t)$ 是亥维赛阶跃函数，当 $t0$ 时等于 $0$，当 $t\\ge 0$ 时等于 $1$，而 $\\lambda0$ 是一个常数，单位为 $\\mathrm{s}^{-1}$。对于 $t\\ge 0$，该方程可以写成\n$$\n\\frac{d y}{d t} = -\\lambda\\,(y(t)-1), \\quad y(0)=0.\n$$\n设均匀计算网格为 $t_n = n h$，其中 $n=0,1,\\dots,N$，$h0$，且 $N$ 的选择使得对于给定的最终时间 $T0$ 满足 $T = N h$。考虑由 $k$ 阶后向差分公式 (BDF) 定义的线性多步法，其递推形式为\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h\\, f(t_n,y_n),\n$$\n其中 $\\alpha_0=1$ 且 $f(t,y) = -\\lambda\\,y + \\lambda$。对于指定的阶数，使用以下归一化系数 $\\{\\alpha_j\\}_{j=0}^k$：\n- 对于 $k=2$：$\\alpha_0=1$, $\\alpha_1=-\\frac{4}{3}$, $\\alpha_2=\\frac{1}{3}$。\n- 对于 $k=3$：$\\alpha_0=1$, $\\alpha_1=-\\frac{18}{11}$, $\\alpha_2=\\frac{9}{11}$, $\\alpha_3=-\\frac{2}{11}$。\n- 对于 $k=4$：$\\alpha_0=1$, $\\alpha_1=-\\frac{48}{25}$, $\\alpha_2=\\frac{36}{25}$, $\\alpha_3=-\\frac{16}{25}$, $\\alpha_4=\\frac{3}{25}$。\n\n通过将起始值设置为网格点上的精确解来初始化多步递推，\n$$\ny(t) = 1 - e^{-\\lambda t}, \\quad \\text{so that} \\quad y_n = 1 - e^{-\\lambda t_n},\n$$\n对于 $n=0,1,\\dots,k-1$。然后，对于 $n=k,k+1,\\dots,N$，通过在每一步求解上述递推关系来计算 $y_n$。\n\n将过冲幅度定义为非负量\n$$\n\\Delta(k,\\lambda,h,T) = \\max\\left\\{\\,0,\\, \\max_{0\\le n\\le N} \\left(y_n - 1\\right)\\,\\right\\},\n$$\n它衡量在模拟时间间隔内，计算出的解超过渐近值 $1$ 的最大量。\n\n您的程序必须为下面测试套件中的每个参数集计算 $\\Delta(k,\\lambda,h,T)$，并生成一行输出，其中包含所有结果，形式为方括号括起来的逗号分隔列表，顺序与所列顺序相同。每个结果必须报告为四舍五入到六位小数的十进制浮点数。过冲幅度是无量纲的。\n\n测试套件：\n- 案例 1 (基准)：$k=2$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 案例 2 (更高阶，中等步长)：$k=3$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 案例 3 (更高阶，中等步长)：$k=4$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.001\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 案例 4 (更高阶，较大步长)：$k=3$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.002\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n- 案例 5 (更高阶，较小步长)：$k=4$，$\\lambda=1000\\,\\mathrm{s}^{-1}$，$h=0.0002\\,\\mathrm{s}$，$T=0.02\\,\\mathrm{s}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表 (例如，\"[r1,r2,r3,r4,r5]\")，其中每个 $r_i$ 是相应案例的过冲幅度，四舍五入到六位小数。", "solution": "该问题要求计算应用于刚性常微分方程的 $k$ 阶后向差分公式 (BDF) 格式的过冲幅度，记为 $\\Delta(k,\\lambda,h,T)$。\n\n控制初值问题由下式给出：\n$$\n\\frac{d y}{d t} = -\\lambda (y(t) - 1), \\quad y(0)=0\n$$\n其中 $\\lambda  0$。对于 $t \\ge 0$ 的精确解是 $y(t) = 1 - e^{-\\lambda t}$。当 $t \\to \\infty$ 时，解的渐近值为 $1$。\n\nBDF-$k$ 格式是一种线性多步法，由以下递推关系定义：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h\\, f(t_n,y_n)\n$$\n其中 $y_n$ 是在时间 $t_n = n h$ 时 $y(t_n)$ 的数值近似值，$h$ 是时间步长，系数 $\\{\\alpha_j\\}$ 是为 $k=2,3,4$ 给出的。对于此问题，函数 $f(t,y)$ 为 $f(t_n,y_n) = -\\lambda (y_n - 1) = -\\lambda y_n + \\lambda$。\n\n要实现该格式，必须推导出 $y_n$ 的显式更新规则。我们从 BDF 递推关系开始，并代入 $f(t_n,y_n)$ 的表达式：\n$$\n\\sum_{j=0}^{k} \\alpha_j\\, y_{n-j} = h (-\\lambda y_n + \\lambda)\n$$\n我们展开求和并分离出含 $y_n$ 的项。给定 $\\alpha_0=1$，左侧为：\n$$\n\\alpha_0 y_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j} = y_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}\n$$\n令两个表达式相等：\n$$\ny_n + \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j} = -h \\lambda y_n + h \\lambda\n$$\n我们将所有包含 $y_n$ 的项移到左侧，所有其他项移到右侧：\n$$\ny_n + h \\lambda y_n = h \\lambda - \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}\n$$\n提出 $y_n$ 因子，得到每一步的最终显式公式：\n$$\ny_n = \\frac{h \\lambda - \\sum_{j=1}^{k} \\alpha_j\\, y_{n-j}}{1 + h \\lambda}\n$$\n该方程允许根据前 $k$ 个值 $y_{n-1}, y_{n-2}, \\dots, y_{n-k}$ 直接计算 $y_n$。\n\n计算过程如下：\n1.  定义计算网格。给定最终时间 $T$ 和步长 $h$，步数 $N = \\text{round}(T/h)$。离散时间点为 $t_n = n h$，其中 $n=0, 1, \\dots, N$。\n2.  初始化解向量。一个 $k$ 步法需要 $k$ 个起始值 $y_0, y_1, \\dots, y_{k-1}$。问题指定为此目的使用精确解：\n    $$\n    y_n = 1 - e^{-\\lambda t_n} \\quad \\text{for } n = 0, 1, \\dots, k-1\n    $$\n3.  迭代计算解。对于从 $n=k$ 到 $N$ 的每个时间步，使用推导出的递推关系计算 $y_n$。历史值 $y_{n-1}, \\dots, y_{n-k}$ 从之前的步骤中已知。\n4.  计算过冲幅度。在计算出完整的数值解向量 $\\{y_n\\}_{n=0}^N$ 后，首先确定解超过其渐近极限 $1$ 的最大值来找到最大过冲：\n    $$\n    \\max_{0 \\le n \\le N} (y_n - 1)\n    $$\n    过冲幅度 $\\Delta$ 被定义为该量与零的最大值，以确保其为非负值：\n    $$\n    \\Delta(k,\\lambda,h,T) = \\max\\left\\{0, \\max_{0\\le n\\le N} (y_n - 1)\\right\\}\n    $$\n\n所提供的代码实现了这一精确算法。定义了一个函数，用于为给定的一组参数 $(k, \\lambda, h, T)$ 执行模拟，该函数计算序列 $\\{y_n\\}$，然后确定过冲幅度 $\\Delta$。对于问题陈述中指定的每个测试用例，都会调用此函数，并按要求收集和格式化结果。", "answer": "```python\nimport numpy as np\n\ndef calculate_overshoot(k, lam, h, T, coeffs):\n    \"\"\"\n    Computes the overshoot amplitude for a BDF-k scheme on a stiff ODE.\n\n    Args:\n        k (int): Order of the BDF method.\n        lam (float): Stiffness parameter lambda.\n        h (float): Time step size.\n        T (float): Final time.\n        coeffs (list): List of BDF coefficients [alpha_0, ..., alpha_k].\n\n    Returns:\n        float: The computed overshoot amplitude.\n    \"\"\"\n    # Determine the number of steps and create the solution array\n    # Using round() to handle potential floating point inaccuracies in T/h\n    N = int(round(T / h))\n    y = np.zeros(N + 1)\n\n    # Step 1: Initialize the first k values using the exact solution\n    # y_n = 1 - exp(-lambda * t_n) for n = 0, ..., k-1\n    for n in range(k):\n        t_n = n * h\n        y[n] = 1.0 - np.exp(-lam * t_n)\n\n    # Step 2: Time-stepping loop from n=k to N\n    # The recurrence is y_n = (h*lambda - sum_{j=1 to k} alpha_j*y_{n-j}) / (1 + h*lambda)\n    z = lam * h\n    denominator = 1.0 + z\n\n    for n in range(k, N + 1):\n        # Compute the summation term from historical values\n        historical_sum = 0.0\n        for j in range(1, k + 1):\n            historical_sum += coeffs[j] * y[n - j]\n\n        # Apply the update rule to find y_n\n        y[n] = (z - historical_sum) / denominator\n\n    # Step 3: Calculate the overshoot amplitude\n    # Delta = max{0, max_{0=n=N} (y_n - 1)}\n    max_overshoot = 0.0\n    if len(y)  0:\n        max_y = np.max(y)\n        max_overshoot = max(0.0, max_y - 1.0)\n    \n    return max_overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement\n    # Each tuple is (k, lambda, h, T)\n    test_cases = [\n        (2, 1000.0, 0.001, 0.02),\n        (3, 1000.0, 0.001, 0.02),\n        (4, 1000.0, 0.001, 0.02),\n        (3, 1000.0, 0.002, 0.02),\n        (4, 1000.0, 0.0002, 0.02),\n    ]\n\n    # BDF coefficients {alpha_j} for j=0 to k, with alpha_0 = 1\n    bdf_coeffs = {\n        2: [1.0, -4.0/3.0, 1.0/3.0],\n        3: [1.0, -18.0/11.0, 9.0/11.0, -2.0/11.0],\n        4: [1.0, -48.0/25.0, 36.0/25.0, -16.0/25.0, 3.0/25.0]\n    }\n\n    results = []\n    for k, lam, h, T in test_cases:\n        # Run simulation for each case\n        overshoot = calculate_overshoot(k, lam, h, T, bdf_coeffs[k])\n        results.append(overshoot)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2374956"}]}