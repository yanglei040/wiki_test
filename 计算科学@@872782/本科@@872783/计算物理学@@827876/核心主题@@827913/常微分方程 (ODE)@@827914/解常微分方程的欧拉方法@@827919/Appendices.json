{"hands_on_practices": [{"introduction": "理论是指导，但实践是检验真理的唯一标准。我们的第一个动手实践将通过一个常见的物理系统——RC电路——来探索前向欧拉法的基本稳定性和局限性。通过这个练习[@problem_id:2390244]，你将亲手验证一个看似合理的数值选择（时间步长）如何导致完全不符合物理现实的结果，从而深刻理解在应用任何数值方法之前对其特性进行分析的重要性。", "problem": "一个电阻-电容（RC）电路由一个电阻为 $R$（单位 $\\Omega$）的电阻器和一个电容为 $C$（单位 $\\mathrm{F}$）的电容器连接到一个电压源 $V_{\\text{in}}(t)$（单位 $\\mathrm{V}$）组成。电容器电压 $V(t)$（单位 $\\mathrm{V}$）满足一阶常微分方程\n$$\n\\frac{dV}{dt} = \\frac{1}{RC}\\big(V_{\\text{in}}(t)-V(t)\\big),\n$$\n初始条件为 $V(0)=V_{\\text{init}}$。考虑 $V_{\\text{in}}(t)$ 恒定等于 $V_0$（直流阶跃）和 $V_{\\text{in}}(t)$ 恒定等于 $0$ 这两种情况。使用均匀步长 $h$（单位 $\\mathrm{s}$）将时间离散化，形成时间序列 $t_n = nh$，其中 $n\\in\\{0,1,2,\\dots,N\\}$，$N=\\lfloor T_{\\text{end}}/h \\rfloor$，并通过由步长为 $h$ 的显式单步更新生成的序列 $V_n$ 来近似 $V(t_n)$。对于下面的每个参数集，从 $t=0$ 模拟到 $t=T_{\\text{end}}$ 并计算以下量：\n\n1. 一个布尔值 $b_{\\text{osc}}$，当且仅当误差序列 $e_n$（当使用 $V_{\\text{in}}(t)=V_0$ 时定义为 $e_n = V_n - V_0$，或当使用 $V_{\\text{in}}(t)=0$ 时定义为 $e_n = V_n$，其中 $n\\in\\{0,1,\\dots,N\\}$）中存在至少一次符号变化时，该布尔值为 $\\text{True}$。在检测符号变化时，将值 $|e_n|\\le \\varepsilon$ 视为零，其中 $\\varepsilon=10^{-12}$（单位 $\\mathrm{V}$）。\n2. 一个布尔值 $b_{\\text{conv}}$，当且仅当序列在模拟结束时数值收敛时，该布尔值为 $\\text{True}$，此处定义为同时满足 $|V_N - V_{N-1}| \\le \\tau$ 和 $\\max_{0\\le n\\le N} |V_n| \\le V_{\\max}$，其中 $\\tau=10^{-6}$（单位 $\\mathrm{V}$）和 $V_{\\max}=10^{6}$（单位 $\\mathrm{V}$）。\n3. 一个浮点数 $V_{\\text{final}}$，等于 $V_N$（单位 $\\mathrm{V}$），四舍五入到六位小数。如果在模拟过程中的任何时刻 $\\max_{0\\le n\\le N} |V_n| > V_{\\max}$，则将 $V_{\\text{final}}$ 报告为特殊浮点值 $\\mathrm{NaN}$。\n\n物理常数和单位必须一致使用：$R$ 单位为 $\\Omega$，$C$ 单位为 $\\mathrm{F}$，时间单位为 $\\mathrm{s}$，电压单位为 $\\mathrm{V}$。不涉及角度。所有布尔值必须是字面逻辑值，所有浮点数必须是定义的小数。不报告百分比。\n\n测试套件（每个元组列出 $(R,C,V_0,V_{\\text{init}},h,T_{\\text{end}})$）：\n\n- 情况 $1$（基准线，单调逼近）：$(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=0.1\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$。\n- 情况 $2$（边界因子）：$(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.0\\,\\mathrm{s},\\; T_{\\text{end}}=5\\,\\mathrm{s})$。\n- 情况 $3$（振荡但衰减）：$(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$。\n- 情况 $4$（在时间范围内振荡且不收敛）：$(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=5\\,\\mathrm{V},\\; V_{\\text{init}}=0\\,\\mathrm{V},\\; h=2.5\\,\\mathrm{s},\\; T_{\\text{end}}=20\\,\\mathrm{s})$。\n- 情况 $5$（从已充电电容器自由衰减）：$(R=10^3\\,\\Omega,\\; C=10^{-3}\\,\\mathrm{F},\\; V_0=0\\,\\mathrm{V},\\; V_{\\text{init}}=5\\,\\mathrm{V},\\; h=1.5\\,\\mathrm{s},\\; T_{\\text{end}}=40\\,\\mathrm{s})$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个案例按 $[b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}]$ 的顺序贡献一个括号括起来的三元组。整体输出格式必须为\n$[ [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], [b_{\\text{osc}},b_{\\text{conv}},V_{\\text{final}}], \\dots ]$\n无附加文本。例如，一个包含两个假设案例的有效输出将是 $[[\\text{True},\\text{False},3.000000],[\\text{False},\\text{True},5.000000]]$。", "solution": "所呈现的问题是模拟 RC 电路的一阶线性常微分方程（ODE）的良态初值问题（IVP）。该问题具有科学依据、形式化规定且客观。它要求使用规定的离散化方案对 ODE 进行数值求解，并计算与数值解行为相关的特定指标。该问题是有效的，并将提供一个解决方案。\n\n电容器电压 $V(t)$ 的控制 ODE 为：\n$$\n\\frac{dV}{dt} = \\frac{1}{RC} \\left( V_{\\text{in}}(t) - V(t) \\right)\n$$\n初始条件为 $V(0) = V_{\\text{init}}$。\n\n问题指定了“显式单步更新”，对于一阶 ODE，这对应于前向欧拉法。时域被离散化为大小为 $h$ 的步长，使得 $t_n = nh$。时间 $t_n$ 的电压，记为 $V(t_n)$，由序列 $V_n$ 近似。对于 ODE $\\frac{dy}{dt} = f(t,y)$，前向欧拉更新规则是 $y_{n+1} = y_n + h f(t_n, y_n)$。\n\n对于给定的 RC 电路 ODE，函数为 $f(t, V) = \\frac{1}{RC}(V_{\\text{in}}(t) - V)$。在每个测试用例中，输入电压 $V_{\\text{in}}(t)$ 是一个常数，我们记为 $V_{\\text{in,const}}$（等于 $V_0$ 或 $0$）。因此，$V_n$ 的更新规则是：\n$$\nV_{n+1} = V_n + h \\left( \\frac{1}{RC} (V_{\\text{in,const}} - V_n) \\right)\n$$\n令电路的时间常数为 $\\tau_{RC} = RC$。该方程可以重排以突出其作为线性递推关系的结构：\n$$\nV_{n+1} = V_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n为了分析该数值方案的稳定性和振荡行为，我们研究误差 $e_n$ 的演化，定义为与稳态电压 $V_{\\text{in,const}}$ 的偏差。\n$$\ne_n = V_n - V_{\\text{in,const}}\n$$\n将 $V_n = e_n + V_{\\text{in,const}}$ 代入更新规则：\n$$\ne_{n+1} + V_{\\text{in,const}} = (e_n + V_{\\text{in,const}}) \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) + V_{\\text{in,const}} \\left( 1 - \\frac{h}{\\tau_{RC}} \\right) - V_{\\text{in,const}} + V_{\\text{in,const}} \\left( \\frac{h}{\\tau_{RC}} \\right)\n$$\n$$\ne_{n+1} = e_n \\left( 1 - \\frac{h}{\\tau_{RC}} \\right)\n$$\n这是误差的等比数列，$e_n = e_0 \\alpha^n$，其中初始误差为 $e_0 = V_{\\text{init}} - V_{\\text{in,const}}$，稳定因子为 $\\alpha = 1 - h/\\tau_{RC}$。数值解的行为由 $\\alpha$ 的值决定：\n1.  $0  \\alpha  1$（即 $0  h/\\tau_{RC}  1$）：误差 $e_n$ 单调衰减至零，不改变符号。数值解单调地逼近稳态。这意味着 $b_{\\text{osc}} = \\text{False}$。\n2.  $-1  \\alpha \\le 0$（即 $1 \\le h/\\tau_{RC}  2$）：误差 $e_n$ 在每一步都交替符号，而其幅值衰减。数值解在收敛时围绕稳态振荡。这意味着 $b_{\\text{osc}} = \\text{True}$。\n3.  $\\alpha \\le -1$（即 $h/\\tau_{RC} \\ge 2$）：误差的幅值 $|e_n|$ 不衰减。如果 $\\alpha = -1$，幅值恒定。如果 $\\alpha  -1$，幅值指数增长。数值解是不稳定的。这意味着 $b_{\\text{osc}} = \\text{True}$（因为符号交替），但解不会收敛。\n\n解决每个参数集问题的算法如下：\n1.  计算模拟的常数：时间常数 $\\tau_{RC} = R \\times C$，以及总步数 $N = \\lfloor T_{\\text{end}}/h \\rfloor$。\n2.  确定恒定输入电压 $V_{\\text{in,const}}$。\n3.  初始化一个大小为 $N+1$ 的数组 `voltages`，初始条件为 `voltages[0]` $= V_{\\text{init}}$。\n4.  从 $n=0$ 到 $N-1$ 迭代，使用更新规则 $V_{n+1} = V_n(1 - h/\\tau_{RC}) + V_{\\text{in,const}}(h/\\tau_{RC})$ 生成序列 $V_n$。\n5.  在模拟期间，跟踪最大绝对电压 $\\max_{0\\le n\\le N} |V_n|$，以对照发散阈值 $V_{\\max} = 10^6\\,\\mathrm{V}$ 进行检查。\n6.  模拟结束后，计算所需的量：\n    a.  **$b_{\\text{osc}}$**：创建误差序列 $e_n = V_n - V_{\\text{in,const}}$（如果 $V_{\\text{in,const}}=0$，则为 $e_n=V_n$）。遍历误差。如果任何两个连续的非零误差（非零定义为 $|e_n| > \\varepsilon = 10^{-12}\\,\\mathrm{V}$）的符号相反，则记录一次符号变化。\n    b.  **$b_{\\text{conv}}$**：检查是否满足发散条件。如果 $\\max|V_n| > V_{\\max}$，则收敛为假。否则，检查最终电压变化是否在容差范围内：$|V_N - V_{N-1}| \\le \\tau = 10^{-6}\\,\\mathrm{V}$。两个条件都必须满足，才能使 $b_{\\text{conv}}$ 为 $\\text{True}$。\n    c.  **$V_{\\text{final}}$**：如果解已发散（$\\max|V_n| > V_{\\max}$），则该值为特殊浮点数 $\\mathrm{NaN}$。否则，它是最终电压 $V_N$。打印时将结果格式化为六位小数。\n\n该过程应用于五个测试用例中的每一个，以产生最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the RC circuit problem for all test cases using the Forward Euler method.\n    \"\"\"\n    \n    # Each tuple lists (R, C, V0, V_init, h, T_end)\n    test_cases = [\n        (1e3, 1e-3, 5.0, 0.0, 0.1, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.0, 5.0),\n        (1e3, 1e-3, 5.0, 0.0, 1.5, 40.0),\n        (1e3, 1e-3, 5.0, 0.0, 2.5, 20.0),\n        (1e3, 1e-3, 0.0, 5.0, 1.5, 40.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(simulate_rc_circuit(case))\n    \n    # Format the final output string as a list of lists.\n    # The str() representation of a list is already '[...]'.\n    # For floats, format to 6 decimal places. NaN is handled correctly.\n    formatted_results = []\n    for res in results:\n        b_osc, b_conv, v_final = res\n        if np.isnan(v_final):\n            v_final_str = 'nan'\n        else:\n            v_final_str = f\"{v_final:.6f}\"\n        # Python's str(True) is 'True', which is what we need.\n        formatted_results.append(f\"[{str(b_osc)},{str(b_conv)},{v_final_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef simulate_rc_circuit(params):\n    \"\"\"\n    Simulates one RC circuit case and calculates the required metrics.\n    \"\"\"\n    R, C, V0, V_init, h, T_end = params\n    \n    # Physical and numerical constants from the problem statement\n    RC = R * C\n    N = int(T_end / h)\n    eps = 1e-12\n    tau = 1e-6\n    V_max = 1e6\n    \n    # The constant input voltage is V0, unless V0=0, then it's a free decay.\n    V_in_const = V0\n\n    voltages = np.zeros(N + 1)\n    voltages[0] = V_init\n    \n    max_abs_V = abs(V_init)\n    is_diverged = False\n    \n    # Stability factor and terms for the recurrence relation\n    alpha = 1.0 - h / RC\n    beta = V_in_const * (h / RC)\n\n    # Simulation loop using the Forward Euler method\n    for n in range(N):\n        voltages[n+1] = voltages[n] * alpha + beta\n        \n        # Track maximum absolute voltage for divergence check\n        current_abs_v = abs(voltages[n+1])\n        if current_abs_v > max_abs_V:\n            max_abs_V = current_abs_v\n    \n    # Check for divergence after the simulation is complete\n    if max_abs_V > V_max:\n        is_diverged = True\n        \n    # --- 1. Oscillation Check (b_osc) ---\n    b_osc = False\n    errors = voltages - V_in_const\n\n    def get_sign(val):\n        if val > eps:\n            return 1\n        if val  -eps:\n            return -1\n        return 0\n\n    last_sign = get_sign(errors[0])\n    for i in range(1, N + 1):\n        current_sign = get_sign(errors[i])\n        if last_sign * current_sign  0:\n            b_osc = True\n            break\n        if current_sign != 0:\n            last_sign = current_sign\n\n    # --- 2. Convergence Check (b_conv) ---\n    b_conv = False\n    if not is_diverged:\n        # Check if the final step size is within the convergence tolerance\n        if abs(voltages[N] - voltages[N-1]) = tau:\n            b_conv = True\n\n    # --- 3. Final Voltage (V_final) ---\n    if is_diverged:\n        V_final = np.nan\n    else:\n        V_final = voltages[N]\n        \n    return [b_osc, b_conv, V_final]\n\n# The solve function must be called to produce output.\nsolve()\n```", "id": "2390244"}, {"introduction": "在理解了前向欧拉法在耗散系统中的稳定性问题之后，我们转向另一类重要的物理系统：保守系统。本练习[@problem_id:2390251]以经典的一维谐振子为例，揭示前向欧拉法一个更为隐蔽但致命的缺陷：即使在数值上保持稳定，它也无法在长时间积分中保持能量守恒。通过追踪相空间中一个微小区域面积的演化，你将直观地看到该方法如何违背了哈密顿系统的基本物理规律，为后续学习更高级的辛积分方法奠定基础。", "problem": "考虑一维谐振子，其哈密顿量为 $H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$，其中 $q$ 是广义坐标，$p$ 是共轭动量。相空间 $(q,p)$ 中的精确哈密顿流满足哈密顿方程 $\\dot{q}=\\dfrac{\\partial H}{\\partial p}$ 和 $\\dot{p}=-\\dfrac{\\partial H}{\\partial q}$，这组方程定义了一个常微分方程（ODE）系统。\n\n通过对哈密顿方程进行时间步长为 $h$ 的前向（显式）时间离散化，定义一个离散时间映射 $(q_n,p_n)\\mapsto(q_{n+1},p_{n+1})$：\n- $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$，\n- $p_{n+1}=p_n-h\\,k\\,q_n$。\n\n设相空间中的初始区域是一个以 $(q_0,p_0)$ 为中心、边长为 $\\delta q$ 和 $\\delta p$ 的轴对齐矩形。其四个角点按逆时针顺序列出如下：\n- $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$，\n- $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$，\n- $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$，\n- $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$，\n初始面积为 $A_0=\\delta q\\,\\delta p$。\n\n对于下面的每一组参数，将四个角点在离散时间映射下演化 $N$ 步，以获得它们在 $(q,p)$ 平面上的像点，这些像点构成一个四边形。使用演化后与上述相同的逆时针顺序的顶点，计算该四边形的面积 $A_N$，并报告面积比 $R=A_N/A_0$（无量纲）。所有测试用例使用相同的 $(q_0,p_0,\\delta q,\\delta p)$：\n- $q_0=0.3$，\n- $p_0=-0.5$，\n- $\\delta q=10^{-3}$，\n- $\\delta p=10^{-3}$。\n\n测试套件（每种情况为 $(m,k,h,N)$）：\n- 情况 1：$(m,k,h,N)=(1,\\;1,\\;0.1,\\;100)$。\n- 情况 2：$(m,k,h,N)=(1,\\;1,\\;0.0,\\;10)$。\n- 情况 3：$(m,k,h,N)=(2,\\;8,\\;0.05,\\;400)$。\n- 情况 4：$(m,k,h,N)=(1,\\;4,\\;0.45,\\;5)$。\n\n您的程序必须计算每种情况下的 $R$，并生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，每个 $R$ 值四舍五入到六位小数（例如，$[2.000000,1.500000]$）。所有报告的值都是无量纲的；不要包含单位、角度单位或百分号。最终输出必须是指定格式的单行文本。", "solution": "对问题陈述进行验证。\n\n步骤 1：提取已知条件\n- 哈密顿量：$H(q,p)=\\dfrac{p^2}{2m}+\\dfrac{k q^2}{2}$\n- 哈密顿方程：$\\dot{q}=\\dfrac{\\partial H}{\\partial p} = \\dfrac{p}{m}$ 和 $\\dot{p}=-\\dfrac{\\partial H}{\\partial q} = -kq$\n- 离散时间映射（前向欧拉法）：\n  - $q_{n+1}=q_n+h\\,\\dfrac{p_n}{m}$\n  - $p_{n+1}=p_n-h\\,k\\,q_n$\n- 初始相空间区域：一个以 $(q_0,p_0)$ 为中心、边长为 $\\delta q$ 和 $\\delta p$ 的轴对齐矩形。\n- 初始角点（逆时针）：\n  - $(q_0-\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0-\\delta p/2)$\n  - $(q_0+\\delta q/2,\\;p_0+\\delta p/2)$\n  - $(q_0-\\delta q/2,\\;p_0+\\delta p/2)$\n- 初始面积：$A_0=\\delta q\\,\\delta p$\n- 任务：将四个角点演化 $N$ 步，计算所得四边形的面积 $A_N$，并报告面积比 $R=A_N/A_0$。\n- 固定的初始参数：$q_0=0.3$，$p_0=-0.5$，$\\delta q=10^{-3}$，$\\delta p=10^{-3}$。\n- $(m,k,h,N)$ 的测试用例：\n  - 情况 1：$(1,\\;1,\\;0.1,\\;100)$\n  - 情况 2：$(1,\\;1,\\;0.0,\\;10)$\n  - 情况 3：$(2,\\;8,\\;0.05,\\;400)$\n  - 情况 4：$(1,\\;4,\\;0.45,\\;5)$\n\n步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题描述了谐振子，这是经典力学中的一个基本系统。它采用了哈密顿方程，这是经典动力学的一种标准表述。所用的数值方法，显式（前向）欧拉法，是一种众所周知（尽管简单）的求解常微分方程的技术。问题的前提是科学合理的。\n- **适定性**：所有必需的参数（$m, k, h, N, q_0, p_0, \\delta q, \\delta p$）都已提供。计算结果的说明是明确且无歧义的。对于每个测试用例，都存在唯一且有意义的解。\n- **客观性**：问题以精确的数学和算法术语陈述，没有主观性或歧义。\n\n步骤 3：结论与行动\n该问题是有效的。这是一个计算物理中定义明确的练习，具体涉及应用于哈密顿系统的数值积分器的性质。将提供一个解决方案。\n\n该问题要求通过跟踪四个顶点进行数值计算。然而，更根本的分析揭示了其内在原理。该离散时间映射是一个线性变换。设状态向量为 $\\mathbf{x}_n = \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}$。该映射可以写成矩阵形式：\n$$\n\\mathbf{x}_{n+1} = \\begin{pmatrix} q_{n+1} \\\\ p_{n+1} \\end{pmatrix} = \\begin{pmatrix} q_n + h \\frac{p_n}{m} \\\\ p_n - h k q_n \\end{pmatrix} = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix} \\begin{pmatrix} q_n \\\\ p_n \\end{pmatrix}\n$$\n设这个单步演化矩阵为 $M = \\begin{pmatrix} 1  h/m \\\\ -hk  1 \\end{pmatrix}$。这是一个线性映射。线性代数的一个基本定理指出，线性变换会以一个常数因子缩放平面中的所有面积，该因子等于变换矩阵的行列式的绝对值。\n\n单步矩阵 $M$ 的行列式是：\n$$\n\\det(M) = (1)(1) - \\left(\\frac{h}{m}\\right)(-hk) = 1 + \\frac{h^2 k}{m}\n$$\n由于 $h \\ge 0$、$k > 0$ 且 $m > 0$（除了情况 2 中 $h=0$），我们有 $\\det(M) \\ge 1$。相空间中任何区域的面积在每一步都会乘以这个因子。\n\n经过 $N$ 步后，总变换由矩阵 $M^N$ 给出。总面积缩放因子是 $\\det(M^N)$。利用矩阵乘积的行列式是行列式的乘积这一性质，我们有：\n$$\n\\det(M^N) = (\\det(M))^N\n$$\n最终面积 $A_N$ 与初始面积 $A_0$ 之比恰好是这个缩放因子。因此，面积比 $R$ 由以下精确的解析表达式给出：\n$$\nR = \\frac{A_N}{A_0} = \\left(1 + \\frac{h^2 k}{m}\\right)^N\n$$\n这个结果与初始形状、其面积 $A_0$ 或其位置 $(q_0, p_0)$ 无关，只要变换是线性的。面积不守恒（即 $\\det(M) \\neq 1$）是显式欧拉法应用于哈密顿系统时的一个已知缺陷。一个合格的辛积分器会保持相空间面积，这意味着其行列式将恰好为 $1$。\n\n问题要求通过演化四个角点进行数值模拟。虽然这不如解析推导优雅，但必须按照指示来实现。步骤如下：\n\n1. 初始化矩形的四个角点 $(q, p)$：\n    - $P_1 = (q_0 - \\delta q/2, p_0 - \\delta p/2)$\n    - $P_2 = (q_0 + \\delta q/2, p_0 - \\delta p/2)$\n    - $P_3 = (q_0 + \\delta q/2, p_0 + \\delta p/2)$\n    - $P_4 = (q_0 - \\delta q/2, p_0 + \\delta p/2)$\n\n2. 对每个角点，迭代映射 $N$ 次。对于从 $0$ 到 $N-1$ 的 $n$：\n    - $q_{n+1} = q_n + \\frac{h}{m} p_n$\n    - $p_{n+1} = p_n - h k q_n$\n    关键是在更新 $p_{n+1}$ 时使用 $q_n$，而不是新计算出的 $q_{n+1}$。\n\n3. 经过 $N$ 步后，我们得到一个平行四边形的四个最终顶点：$P'_1=(q'_1, p'_1)$、$P'_2=(q'_2, p'_2)$、$P'_3=(q'_3, p'_3)$ 和 $P'_4=(q'_4, p'_4)$。\n\n4. 这个变换后的四边形的面积 $A_N$ 可以使用鞋带公式计算，对于按顺序列出的顶点 $(q_i, p_i)$ 的多边形：\n    $$\n    A_N = \\frac{1}{2} \\left| \\sum_{i=1}^{4} (q_i p_{i+1} - q_{i+1} p_i) \\right|\n    $$\n    其中索引 $i+1$ 对 $4$ 取模（因此 $(q_5, p_5) = (q_1, p_1)$）。因为变换是线性的，最终的四边形是一个平行四边形，其面积也可以通过代表相邻边的向量的叉积的模长来计算，例如 $|\\det(P'_2 - P'_1, P'_4 - P'_1)|$。\n\n5. 初始面积为 $A_0 = \\delta q \\cdot \\delta p = (10^{-3}) \\cdot (10^{-3}) = 10^{-6}$。\n\n6. 所需的比率为 $R = A_N / A_0$。此过程得到的数值结果必须与上面推导的解析公式一致。这证实了实现的正确性。\n\n我们现在将此应用于给定的测试用例。\n\n- **情况 1**：$(m,k,h,N) = (1, 1, 0.1, 100)$\n  $R = \\left(1 + \\frac{(0.1)^2 (1)}{1}\\right)^{100} = (1.01)^{100} \\approx 2.704814$\n\n- **情况 2**：$(m,k,h,N) = (1, 1, 0.0, 10)$\n  当 $h=0.0$ 时，映射为单位映射：$q_{n+1}=q_n$ 和 $p_{n+1}=p_n$。点不移动。面积不改变。\n  $R = \\left(1 + \\frac{(0.0)^2 (1)}{1}\\right)^{10} = (1)^{10} = 1.0$\n\n- **情况 3**：$(m,k,h,N) = (2, 8, 0.05, 400)$\n  $R = \\left(1 + \\frac{(0.05)^2 (8)}{2}\\right)^{400} = (1 + \\frac{0.0025 \\cdot 8}{2})^{400} = (1 + 0.01)^{400} \\approx 53.593453$\n\n- **情况 4**：$(m,k,h,N) = (1, 4, 0.45, 5)$\n  $R = \\left(1 + \\frac{(0.45)^2 (4)}{1}\\right)^{5} = (1 + 0.2025 \\cdot 4)^{5} = (1 + 0.81)^{5} = (1.81)^{5} \\approx 19.344930$\n\n实现将遵循指定的数值计算步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the phase space area ratio for a harmonic oscillator\n    evolved with the explicit Euler method.\n    \"\"\"\n\n    # Define the fixed initial parameters for the phase space patch.\n    q0 = 0.3\n    p0 = -0.5\n    dq = 1e-3\n    dp = 1e-3\n\n    # The initial area of the rectangle.\n    A0 = dq * dp\n\n    # Define the four initial corner points of the rectangle in counterclockwise order.\n    # The shape is (4, 2) where each row is a (q, p) coordinate.\n    initial_corners = np.array([\n        [q0 - dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 - dp / 2],\n        [q0 + dq / 2, p0 + dp / 2],\n        [q0 - dq / 2, p0 + dp / 2]\n    ])\n\n    test_cases = [\n        # Case 1: (m, k, h, N)\n        (1.0, 1.0, 0.1, 100),\n        # Case 2\n        (1.0, 1.0, 0.0, 10),\n        # Case 3\n        (2.0, 8.0, 0.05, 400),\n        # Case 4\n        (1.0, 4.0, 0.45, 5)\n    ]\n\n    results = []\n    for m, k, h, N in test_cases:\n        # Start with a fresh copy of the initial corners for each test case.\n        corners = np.copy(initial_corners)\n\n        # Evolve the four corner points for N steps.\n        for _ in range(N):\n            q_n = corners[:, 0]\n            p_n = corners[:, 1]\n            \n            # Apply the explicit Euler update rules.\n            # It's crucial to use the old q_n and p_n for both updates.\n            q_np1 = q_n + h * p_n / m\n            p_np1 = p_n - h * k * q_n\n            \n            # Update the corners for the next iteration.\n            corners[:, 0] = q_np1\n            corners[:, 1] = p_np1\n        \n        final_corners = corners\n        \n        # Calculate the area of the final quadrilateral using the Shoelace formula.\n        # This formula works for any simple polygon.\n        # Area = 0.5 * |(x1y2 + x2y3 + ... + xny1) - (y1x2 + y2x3 + ... + ynx1)|\n        # A vectorized implementation using np.roll is efficient.\n        q = final_corners[:, 0]\n        p = final_corners[:, 1]\n        \n        # We use np.roll to get the next vertex in the sequence.\n        # np.roll(p, -1) gets [p2, p3, p4, p1]\n        term1 = np.sum(q * np.roll(p, -1))\n        # np.roll(q, -1) gets [q2, q3, q4, q1]\n        term2 = np.sum(p * np.roll(q, -1))\n        \n        A_N = 0.5 * np.abs(term1 - term2)\n        \n        # Calculate the area ratio R.\n        # For h=0, A_N might be extremely close but not exactly A0 due to float precision.\n        # However, A0 is also very small, so division is safe.\n        if A0 == 0:\n            area_ratio = 1.0 if A_N == 0 else np.inf\n        else:\n            area_ratio = A_N / A0\n            \n        results.append(f\"{area_ratio:.6f}\")\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2390251"}, {"introduction": "认识到问题是解决问题的第一步。上一个练习暴露了标准欧拉法在处理保守系统时的内在缺陷，而这个实践[@problem_id:2390259]将为你提供一个优雅而简单的解决方案。我们将引入一种对标准欧拉法的微小改进——半隐式欧拉法（或称欧拉-克罗默法），并以经典的开普勒二体问题为背景，对比两种方法在长期轨道模拟中的表现。你将通过计算发现，这个简单的修改如何显著改善能量的长期守恒性，展示了辛积分器在计算物理中的强大威力。", "problem": "考虑一个牛顿二体系统，该系统模拟一个质量可忽略的彗星绕一个中心大质量天体运行。在无量纲引力单位制下进行计算，其中引力常数与中心天体质量的乘积被归一化为 $G M = 1$，彗星质量为 $m = 1$。运动被限制在一个平面内，位置矢量为 $\\mathbf{x}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) = d\\mathbf{x}/dt$。需要使用的基本定律是牛顿第二定律和平方反比引力定律，它们构成以下一阶系统\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\n在这些单位下，总机械能（哈密顿量）为\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\n对于连续动力学，该量不随时间变化。\n\n您的任务是为这个常微分方程（ODE）设计并实现两种一阶时间步进积分器，仅基于核心定义 $d\\mathbf{x}/dt = \\mathbf{v}$ 和 $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$：\n- 一种标准的显式欧拉积分器，它使用在当前时间层级计算的速度来推进位置。\n- 一种半隐式欧拉积分器（也称为欧拉-克罗默方法），它使用当前位置的加速度来推进速度，然后在同一步内使用更新后的速度来推进位置。\n\n从第一性原理出发，通过将时间以步长 $\\Delta t$ 离散化，并一致地应用上述定义来构建步进更新逻辑，推导出每种方法的更新逻辑。除了这种显式的时间离散化之外，不要引入任何额外的近似，并确保两种方法在每一步开始时都使用相同的力计算公式 $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$。\n\n使用以下测试套件。对于每种情况，使用固定的时间步长 $\\Delta t$ 对指定的轨道周期数 $P$ 进行积分。在这些单位中，半长轴为 $a$ 的开普勒椭圆的轨道周期是 $T = 2\\pi a^{3/2}$。初始状态被选为在圆形轨道上或在椭圆轨道的远日点上，初始速度垂直于半径矢量，方向为顺行运动。在这些单位中，所有量都是无量纲的。\n\n- 测试用例1（圆形“理想情况”）：$a = 1$, $e = 0$, 初始状态 $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.01$, $P = 50$。\n- 测试用例2（中等偏心率彗星）：$a = 1$, $e = 0.6$, 在远日点的初始状态 $\\mathbf{x}_0 = (1.6, 0)$, $\\mathbf{v}_0 = (0, 0.5)$, $\\Delta t = 0.001$, $P = 20$。\n- 测试用例3（高偏心率彗星）：$a = 1$, $e = 0.9$, 在远日点的初始状态 $\\mathbf{x}_0 = (1.9, 0)$, $\\mathbf{v}_0 \\approx (0, 0.22941573387)$, $\\Delta t = 0.0005$, $P = 5$。\n- 测试用例4（边界时间步长，圆形）：$a = 1$, $e = 0$, 初始状态 $\\mathbf{x}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$, $\\Delta t = 0.05$, $P = 5$。\n\n对于每个测试用例，计算每个积分器的相对末端能量漂移，\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\n其中 $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ 是所采取的步数，然后返回比率\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\n这个比率 $r$ 是无量纲的。$r  1$ 的值表示在相同的时间内，半隐式欧拉（欧拉-克罗默）方法比标准显式欧拉方法表现出更小的绝对能量漂移。\n\n最终输出格式：您的程序应生成单行输出，其中包含测试用例1-4的 $r$ 值，按顺序以逗号分隔的列表形式，并用方括号括起来，例如 $[r_1,r_2,r_3,r_4]$。条目必须是浮点数。输出中不出现物理单位，因为根据设计，所有量都是无量纲的。\n\n您的实现必须是完全自包含的，并且不得读取任何输入。每个测试用例的答案是一个浮点数 $r$。这四个输出的集合必须按照上述格式出现在一行上。通过在整个过程中使用标准的双精度算术，并忠实地实现根据所述基本定律和定义推导出的两种所要求的积分器，来确保数值稳定性。", "solution": "问题陈述已经过严格验证，并被证实是有效的。它在科学上基于经典力学原理，特别是开普勒问题，并且在数学上是一个适定的常微分方程组初值问题。参数和目标定义精确，不含矛盾、歧义或事实错误。该任务是计算物理学中的一个标准练习，要求推导和比较两种基本的数值积分器。\n\n我们继续进行推导和求解。\n\n该系统由一组关于位置矢量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 和速度矢量 $\\mathbf{v}(t) \\in \\mathbb{R}^2$ 的一阶常微分方程 (ODE) 描述：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\n此处，$\\mathbf{a}(\\mathbf{x})$ 是由引力引起的加速度，引力参数 $G M$ 设为 $1$。\n\n我们将使用一个恒定的时间步长 $\\Delta t$ 对时间进行离散化。设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}_n, \\mathbf{v}_n)$。我们寻求在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$。\n\n**标准显式欧拉积分器的推导**\n\n显式（或前向）欧拉方法使用当前时间层级 $t_n$ 的值来近似导数。\n第一个常微分方程的离散近似是：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\n类似地，对于第二个常微分方程：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\n重新整理这些表达式可得到显式欧拉方法的更新规则。首先，根据当前位置 $\\mathbf{x}_n$ 计算加速度 $\\mathbf{a}_n$。然后，使用时间 $t_n$ 的状态来推进位置和速度。\n\n单步更新逻辑如下：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\n关键特征是新位置 $\\mathbf{x}_{n+1}$ 是使用旧速度 $\\mathbf{v}_n$ 计算的，而不是新计算出的速度 $\\mathbf{v}_{n+1}$。\n\n**半隐式欧拉（欧拉-克罗默）积分器的推导**\n\n半隐式欧拉方法，也称为欧拉-克罗默方法，引入了一个微小但至关重要的修改。首先执行速度更新，然后立即使用这个新计算出的速度来更新位置。在单步内这种时间层级的“混合”定义了其半隐式的特性。\n\n速度的更新与显式方法保持相同：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\n然而，位置更新使用新的速度 $\\mathbf{v}_{n+1}$：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\n单步更新逻辑如下：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\n该方法是一种简单的辛积分器。对于像开普勒问题这样的哈密顿系统，这类积分器表现出卓越的长期稳定性，特别是在能量守恒方面。它们不完全守恒能量，但能量误差通常保持有界，在真实值附近振荡，而显式欧拉方法通常会导致能量的长期漂移。\n\n**模拟与评估方法**\n\n对于每个测试用例，我们进行两次模拟，每种积分器一次。\n初始状态为 $(\\mathbf{x}_0, \\mathbf{v}_0)$。\n总积分时间由轨道周期数 $P$ 指定。半长轴为 $a$ 的开普勒轨道的周期是 $T = 2\\pi a^{3/2}$。\n所需的总步数是 $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$。\n\n连续系统的守恒量是机械能，或哈密顿量：\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\n我们计算初始能量 $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$。经过 $N$ 步后，我们得到最终状态 $(\\mathbf{x}_N, \\mathbf{v}_N)$ 并计算最终能量 $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$。\n\n每个积分器的性能通过相对末端能量漂移 $\\delta$ 来量化：\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\n问题要求计算两种方法的这些漂移的比率 $r$：\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\n$r  1$ 的值表示对于给定的参数，半隐式欧拉-克罗默方法比标准显式欧拉方法提供了更好的长期能量守恒性。实现将精确遵循这些推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        if r_norm == 0:\n            return np.inf\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            if r_norm == 0:\n                # Catastrophic failure, return non-finite values\n                return np.array([np.inf, np.inf]), np.array([np.inf, np.inf])\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            if r_norm == 0:\n                return np.array([np.inf, np.inf]), np.array([np.inf, np.inf])\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nsolve()\n```", "id": "2390259"}]}