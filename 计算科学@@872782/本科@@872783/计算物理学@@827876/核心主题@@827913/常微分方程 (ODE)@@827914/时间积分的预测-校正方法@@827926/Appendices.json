{"hands_on_practices": [{"introduction": "数值离散化过程有时会引入原始连续系统中不存在的人为行为，例如虚假的稳定状态。本练习通过一个简单的线性常微分方程，从解析上揭示了这一令人惊讶但重要的现象 ([@problem_id:2429768])。这强调了批判性地评估数值结果的必要性，并提醒我们数值方法并非是能完美再现物理现实的“黑箱”。", "problem": "设计一个独立的计算物理任务，该任务演示一个标准的预估-校正方法如何引入原连续时间系统中不存在的伪不动点。仅使用以下基本依据：常微分方程的定义，连续动力系统平衡点（不动点）的定义，以及由显式欧拉预估和梯形法则校正构建的单步预估-校正方法的显式公式。\n\n考虑由 $\\dfrac{dx}{dt} = f(x)$ 给出的一维标量常微分方程，其中 $x \\in \\mathbb{R}$ 且 $t \\in \\mathbb{R}$ 表示时间。连续系统的一个平衡点（不动点）是任何满足 $f(x^\\ast)=0$ 的 $x^\\ast$。一个采用显式欧拉预估和梯形法则校正的单步预估-校正方法，使用以下两个阶段从时间 $t_n$ 处的 $x_n$ 推进到时间 $t_{n+1}=t_n+h$ 处的 $x_{n+1}$：\n- 预估步：$x_{\\mathrm{p}} = x_n + h\\, f(x_n)$。\n- 校正步：$x_{n+1} = x_n + \\dfrac{h}{2}\\,\\big(f(x_n) + f(x_{\\mathrm{p}})\\big)$。\n\n你的任务是：\n1. 通过取 $f(x)=\\lambda\\,x$（其中 $\\lambda \\in \\mathbb{R}$ 为常数参数）构建一个具体例子。将 $\\lambda$ 解释为具有反比于时间的单位，即 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$，并使用一个以 $\\mathrm{s}$ 为单位的均匀时间步长 $h0$。对于这个线性 $f(x)$，从第一性原理出发，推导上述预估-校正方法产生的离散单步映射 $x_{n+1} = \\Phi_{h,\\lambda}(x_n)$。\n2. 仅使用映射不动点和微分方程平衡点的定义，确定参数 $(\\lambda,h)$ 满足何种条件时，离散映射 $\\Phi_{h,\\lambda}$ 会拥有非零不动点 $x^\\ast \\neq 0$，尽管当 $\\lambda \\neq 0$ 时连续系统仅有平衡点 $x^\\ast=0$。解释为什么相对于原始连续系统，离散映射的这些非零不动点是伪的和非物理的。\n3. 实现一个程序，对于每个给定的测试用例 $(\\lambda,h)$，判断离散映射 $\\Phi_{h,\\lambda}$ 是否具有伪非零不动点。在比较实数以确定相等条件时，必须使用 $\\varepsilon=10^{-12}$ 的数值容差。该判断应以布尔值（Boolean）的形式报告：如果存在伪非零不动点，则返回 $\\text{True}$，否则返回 $\\text{False}$，此判断在 $\\lambda \\neq 0$ 的假设下进行。如果 $\\lambda=0$，回想一下，连续系统已经将每个 $x$ 都作为平衡点，因此没有引入伪的非物理不动点；在这种情况下，你的判断必须是 $\\text{False}$。\n\n物理单位：\n- 时间步长 $h$ 必须以 $\\mathrm{s}$ 为单位指定。\n- 参数 $\\lambda$ 必须以 $\\mathrm{s}^{-1}$ 为单位指定。\n- 此问题中没有角度量。\n- 无需输出单位；输出为布尔值。\n\n测试套件：\n对以下参数对 $(\\lambda,h)$ 评估你的判断函数：\n- 情况 1：$(\\lambda,h)=(-1,\\;0.1)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 2：$(\\lambda,h)=(-1,\\;2.0)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 3：$(\\lambda,h)=(-4,\\;0.5)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 4：$(\\lambda,h)=(3,\\;0.5)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n- 情况 5：$(\\lambda,h)=(-2.5,\\;0.8)$，其中 $\\lambda$ 单位为 $\\mathrm{s}^{-1}$，$\\,h$ 单位为 $\\mathrm{s}$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个逗号分隔的布尔值列表，用方括号括起来，没有空格，并按上述测试套件的顺序排列。例如，一个有效的输出形如 $[\\text{False},\\text{True},\\ldots]$。你的程序不得读取任何输入，也不得打印任何其他内容。", "solution": "所述问题是有效的。它在科学上基于数值分析和动力系统的原理，是适定的，并且其所有组成部分都得到了客观和严格的定义。我们将着手解决。\n\n任务是分析一个特定的预估-校正数值积分格式如何引入原始连续时间动力系统中不存在的、伪的、非物理的不动点。我们考虑由 $\\frac{dx}{dt} = f(x)$ 给出的标量常微分方程（ODE），其具体线性形式为 $f(x) = \\lambda x$，其中 $\\lambda \\in \\mathbb{R}$ 是一个常数参数。\n\n首先，我们确定连续系统的平衡点。一个平衡点或不动点 $x^\\ast$ 是系统不演化的状态，在数学上对应于 $\\frac{dx}{dt} = 0$。对于我们的系统，这个条件是 $f(x^\\ast) = \\lambda x^\\ast = 0$。对于任何非零参数 $\\lambda \\neq 0$，连续系统唯一存在的平衡点是零解 $x^\\ast = 0$。如果 $\\lambda=0$，常微分方程变为 $\\frac{dx}{dt} = 0$，此时每个点 $x \\in \\mathbb{R}$ 都是一个平衡点。\n\n接下来，我们推导将指定的预估-校正方法应用于此常微分方程所生成的离散单步映射 $x_{n+1} = \\Phi_{h,\\lambda}(x_n)$。该方法使用一个时间步长 $h  0$。\n\n预估步是显式欧拉法：\n$$x_{\\mathrm{p}} = x_n + h f(x_n)$$\n代入 $f(x_n) = \\lambda x_n$，我们获得预估值 $x_{\\mathrm{p}}$：\n$$x_{\\mathrm{p}} = x_n + h (\\lambda x_n) = x_n(1 + h\\lambda)$$\n\n校正步基于梯形法则，该法则对区间开始处和预估结束处的斜率进行平均：\n$$x_{n+1} = x_n + \\frac{h}{2} \\big(f(x_n) + f(x_{\\mathrm{p}})\\big)$$\n代入 $f(x_n) = \\lambda x_n$ 和 $f(x_{\\mathrm{p}}) = \\lambda x_{\\mathrm{p}}$：\n$$x_{n+1} = x_n + \\frac{h}{2} (\\lambda x_n + \\lambda x_{\\mathrm{p}})$$\n现在，我们将 $x_{\\mathrm{p}}$ 替换为预估步得到的表达式：\n$$x_{n+1} = x_n + \\frac{h\\lambda}{2} \\big(x_n + x_n(1 + h\\lambda)\\big)$$\n从括号项中提出因子 $x_n$：\n$$x_{n+1} = x_n + \\frac{h\\lambda}{2} \\big(x_n(1 + (1 + h\\lambda))\\big) = x_n + \\frac{h\\lambda}{2} \\big(x_n(2 + h\\lambda)\\big)$$\n最后，从整个表达式中提出因子 $x_n$，得到离散映射：\n$$x_{n+1} = x_n \\left(1 + \\frac{h\\lambda}{2}(2 + h\\lambda)\\right) = x_n \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)$$\n因此，单步映射为 $\\Phi_{h,\\lambda}(x_n) = x_n \\left(1 + h\\lambda + \\frac{1}{2}(h\\lambda)^2\\right)$。这是一个线性映射，其中第 $n+1$ 步的状态只是第 $n$ 步状态的一个倍数。\n\n我们现在寻找此离散映射的不动点。映射的一个不动点 $x^\\ast$ 必须满足条件 $x^\\ast = \\Phi_{h,\\lambda}(x^\\ast)$：\n$$x^\\ast = x^\\ast \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)$$\n为了找到满足此方程的 $x^\\ast$ 值，我们对其进行整理：\n$$x^\\ast - x^\\ast \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right) = 0$$\n$$x^\\ast \\left(1 - \\left(1 + h\\lambda + \\frac{h^2\\lambda^2}{2}\\right)\\right) = 0$$\n$$x^\\ast \\left(-h\\lambda - \\frac{h^2\\lambda^2}{2}\\right) = 0$$\n$$-x^\\ast h\\lambda \\left(1 + \\frac{h\\lambda}{2}\\right) = 0$$\n如果其中任一因子为零，则该方程有解。\n1. 第一种可能性是 $x^\\ast = 0$。这个不动点对所有 $h$ 和 $\\lambda$ 的值都存在，并对应于原始常微分方程的真实平衡点。\n2. 第二种可能性是另一个因子为零：$-h\\lambda \\left(1 + \\frac{h\\lambda}{2}\\right) = 0$。因为给定 $h  0$ 且我们寻找的伪点仅在 $\\lambda \\neq 0$ 时有意义，所以项 $-h\\lambda$ 非零。因此，这个条件简化为：\n$$1 + \\frac{h\\lambda}{2} = 0$$\n$$h\\lambda = -2$$\n\n如果满足条件 $h\\lambda = -2$，不动点方程变为 $-x^\\ast \\cdot 0 = 0$，这对*任何* $x^\\ast \\in \\mathbb{R}$ 的值都成立。这意味着在条件 $h\\lambda = -2$ 下，实线上的每个点都是该离散映射的不动点。该映射本身变成了恒等映射：$x_{n+1} = x_n(1 - 2 + \\frac{(-2)^2}{2}) = x_n(1 - 2 + 2) = x_n$。\n\n这些不动点被认为是伪的，因为对于 $\\lambda \\neq 0$，连续系统仅拥有一个平衡点 $x^\\ast = 0$。然而，数值方法在满足 $h\\lambda = -2$ 的特定参数组合下，错误地暗示*任何*初始状态 $x_0$ 都是一个静态解，因为对所有 $n \\ge 0$ 都有 $x_n = x_0$。这是一个严重的定性误差。例如，如果 $\\lambda  0$，真实解 $x(t) = x_0 e^{\\lambda t}$ 会指数衰减到 $0$。而使用 $h\\lambda=-2$ 的数值方法错误地预测了一个静态系统。因此，这些无穷多个非零不动点是离散化产生的非物理假象。\n\n基于此分析，存在伪非零不动点（对于 $\\lambda \\neq 0$）的判据恰好是 $h\\lambda = -2$。$\\lambda = 0$ 的情况被排除，因为问题陈述正确地指出，此时连续系统和离散映射都将所有点作为平衡点/不动点，因此没有引入伪不动点。\n\n为了实现，我们必须使用 $\\varepsilon = 10^{-12}$ 的数值容差。判断逻辑如下：\n- 如果 $|\\lambda| \\le \\varepsilon$，我们认为 $\\lambda=0$。结果是 $\\text{False}$。\n- 否则，我们计算乘积 $p = h\\lambda$。\n- 当且仅当 $|p - (-2)| \\le \\varepsilon$（即 $|p + 2| \\le \\varepsilon$）时，存在伪非零不动点。如果此条件成立，结果是 $\\text{True}$；否则，是 $\\text{False}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef has_spurious_fixed_points(lambda_val: float, h: float, epsilon: float = 1e-12) -> bool:\n    \"\"\"\n    Determines if the discrete map has spurious nonzero fixed points.\n\n    Args:\n        lambda_val: The parameter lambda from the ODE dx/dt = lambda * x.\n        h: The time step for the numerical method.\n        epsilon: The numerical tolerance for equality checks.\n\n    Returns:\n        True if spurious nonzero fixed points exist, False otherwise.\n    \"\"\"\n    # According to the problem statement, if lambda is 0, the continuous system\n    # already has every point as an equilibrium. Thus, the fixed points of the\n    # discrete map are not considered spurious.\n    if abs(lambda_val) = epsilon:\n        return False\n\n    # The condition for the existence of spurious nonzero fixed points is derived\n    # to be h * lambda = -2. We check this condition using the provided tolerance.\n    product = h * lambda_val\n    if abs(product + 2.0) = epsilon:\n        return True\n    else:\n        return False\n\ndef solve():\n    \"\"\"\n    Runs the analysis for the test cases provided in the problem statement\n    and prints the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),    # Case 1\n        (-1.0, 2.0),    # Case 2\n        (-4.0, 0.5),    # Case 3\n        (3.0, 0.5),     # Case 4\n        (-2.5, 0.8)     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        lambda_val, h = case\n        result = has_spurious_fixed_points(lambda_val, h)\n        results.append(result)\n\n    # Final print statement in the exact required format: [Boolean,Boolean,...]\n    # The str() of a Python bool ('True', 'False') matches the implicitly desired format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2429768"}, {"introduction": "了解了数值方法可能存在的定性缺陷后，我们将进一步探讨其定量性能。本练习研究一个预估-校正格式在求解一个具有已知有限时间奇点的常微分方程时的收敛阶 ([@problem_id:2429754])。通过这个实践，你将亲手验证当解不够光滑时，理论误差估计会如何退化，并掌握数值收敛性分析这一基本技能。", "problem": "考虑自治常微分方程 (ODE) $y' = y^2$ 的初值问题，其初始条件为 $y(0) = 1$。其唯一解析解为 $y(t) = \\frac{1}{1 - t}$ (对于 $t \\in [0,1)$)，该解在 $t = 1$ 处表现出有限时间奇异性。设 $f(t,y) = y^2$。考虑在均匀网格 $t_n = t_0 + n h$（$n = 0,1,\\dots,N$，$N h = t_{\\text{end}} - t_0$，$t_0 = 0$）上应用以下两步预测-校正时间步进格式，其中步长 $h  0$ 为常数：\n1. 预测步（显式欧拉法）：$y^{\\text{pred}}_{n+1} = y_n + h\\, f(t_n, y_n)$。\n2. 校正步（使用预测值的梯形更新）：$y_{n+1} = y_n + \\dfrac{h}{2}\\,\\left[f(t_n, y_n) + f(t_{n+1}, y^{\\text{pred}}_{n+1})\\right]$。\n对于下方的每个测试用例，您必须：\n- 使用上述格式和指定的步长列表 $h$（每个 $h$ 的选择都使得 $t_{\\text{end}} / h$ 为正整数），从 $t = 0$ 积分到 $t = t_{\\text{end}}$。\n- 对于列表中的每个 $h$，计算在 $t = t_{\\text{end}}$ 处的绝对全局误差，其定义为 $E(h) = \\left|y_{\\text{num}}(t_{\\text{end}};h) - \\dfrac{1}{1 - t_{\\text{end}}}\\right|$，其中 $y_{\\text{num}}(t_{\\text{end}};h)$ 是使用步长 $h$ 的格式所产生的数值近似解。\n- 在一个测试用例中，使用所有的 $(h, E(h))$ 对，通过对点集 $\\left(\\log(h), \\log(E(h))\\right)$ 进行最小二乘线性拟合，将拟合直线的斜率作为观测收敛阶 $p$ 的估计值，即拟合 $\\log(E(h)) \\approx C + p \\log(h)$ 并报告该测试用例的 $p$ 值。\n- 将报告的每个 $p$ 值四舍五入至三位小数，并报告无量纲值。\n\n测试组：\n- 用例 A：$t_{\\text{end}} = 0.1$，步长 $h \\in \\{0.02, 0.01, 0.005, 0.0025\\}$。\n- 用例 B：$t_{\\text{end}} = 0.5$，步长 $h \\in \\{0.1, 0.05, 0.025, 0.0125\\}$。\n- 用例 C：$t_{\\text{end}} = 0.9$，步长 $h \\in \\{0.1, 0.05, 0.025, 0.0125\\}$。\n- 用例 D：$t_{\\text{end}} = 0.95$，步长 $h \\in \\{0.05, 0.025, 0.0125\\}$。\n\n您的程序应产生单行输出，其中包含四个四舍五入后的估计值 $[p_A, p_B, p_C, p_D]$，形式为用方括号括起来的逗号分隔列表，例如 $[2.000,2.000,1.950,1.700]$。不应打印任何额外文本。所有角度、单位和量均为无量纲；请将最终的四个值报告为四舍五入到小数点后三位的小数。", "solution": "所给问题是计算物理学中一个关于常微分方程（ODE）数值解的明确定义的练习。它具有科学依据，逻辑上一致，并包含了获得唯一解所需的所有信息。因此，该问题是有效的，我们着手进行求解。\n\n该问题要求分析一种应用于由以下自治常微分方程给出的初值问题（IVP）的数值方法：\n$$\ny'(t) = y(t)^2, \\quad y(0) = 1\n$$\n该方程是 Riccati 方程的一个特例。其解析解可通过分离变量法求得：\n$$\n\\frac{dy}{y^2} = dt \\implies \\int \\frac{dy}{y^2} = \\int dt \\implies -\\frac{1}{y} = t + C\n$$\n使用初始条件 $y(0)=1$，我们可以求出积分常数 $C$：\n$$\n-\\frac{1}{1} = 0 + C \\implies C = -1\n$$\n因此，唯一的解析解是：\n$$\ny(t) = \\frac{1}{1 - t}\n$$\n该解在 $t \\in [0, 1)$ 上存在，并在 $t=1$ 处表现出有限时间奇异性。根据问题定义，待积分的函数是 $f(t,y) = y^2$。由于该常微分方程是自治的，函数 $f$ 不显式依赖于 $t$。\n\n所使用的数值格式是以下两步预测-校正方法：\n1.  **预测步（显式欧拉法）：** 在时间 $t_{n+1} = t_n + h$ 的预测值 $y^{\\text{pred}}_{n+1}$ 是使用显式欧拉法计算的：\n    $$\n    y^{\\text{pred}}_{n+1} = y_n + h\\, f(t_n, y_n) = y_n + h\\, y_n^2\n    $$\n2.  **校正步（梯形更新）：** 最终值 $y_{n+1}$ 是通过对区间起点的斜率 $f(t_n, y_n)$ 和区间终点的斜率进行平均来计算的，其中终点斜率是在预测值 $y^{\\text{pred}}_{n+1}$ 处对函数求值得到的，即 $f(t_{n+1}, y^{\\text{pred}}_{n+1})$：\n    $$\n    y_{n+1} = y_n + \\frac{h}{2} \\left[ f(t_n, y_n) + f(t_{n+1}, y^{\\text{pred}}_{n+1}) \\right] = y_n + \\frac{h}{2} \\left[ y_n^2 + (y^{\\text{pred}}_{n+1})^2 \\right]\n    $$\n这种格式被广泛称为 Heun 方法或改进欧拉法。它属于二阶 Runge-Kutta 方法族。对于足够光滑的解，该方法的局部截断误差为 $\\mathcal{O}(h^3)$ 阶，这导致在固定时间 $t_{\\text{end}}$ 的全局误差 $E(h)$ 为 $\\mathcal{O}(h^2)$ 阶。\n\n问题要求估计观测收敛阶 $p$。对于一个全局误差为 $E(h) \\approx K h^p$（其中 $K$ 为某个常数）的方法，我们可以对等式两边取自然对数：\n$$\n\\log(E(h)) \\approx \\log(K) + p \\log(h)\n$$\n这个方程具有线性关系 $Y = C + pX$ 的形式，其中 $Y = \\log(E(h))$，$X = \\log(h)$，截距为 $C = \\log(K)$。收敛阶 $p$ 就是这条直线的斜率。我们通过对数据点集 $(\\log(h_i), \\log(E_i))$ 进行线性最小二乘回归来计算 $p$，其中对于给定测试用例中的每个步长 $h_i$，$E_i = E(h_i)$ 是在 $t=t_{\\text{end}}$ 处的绝对全局误差。\n\n获取每个测试用例结果的算法如下：\n1.  定义积分终点 $t_{\\text{end}}$ 和步长集合 $\\{h_i\\}$。\n2.  计算在终点处的精确解 $y_{\\text{exact}} = (1 - t_{\\text{end}})^{-1}$。\n3.  对于集合中的每个步长 $h_i$：\n    a. 确定步数 $N_i = \\text{integer}(t_{\\text{end}} / h_i)$。\n    b. 在 $t_0=0$ 处用 $y_0=1$ 初始化数值解。\n    c. 使用预测-校正公式迭代 $N_i$ 次，以找到数值解 $y_{\\text{num}}(t_{\\text{end}}; h_i) = y_{N_i}$。\n    d. 计算绝对全局误差 $E_i = |y_{\\text{num}}(t_{\\text{end}}; h_i) - y_{\\text{exact}}|$。\n    e. 存储数据对 $(\\log(h_i), \\log(E_i))$。\n4.  使用该测试用例中所有存储的数据对，计算通过这些点的最佳拟合线的斜率 $p$。\n5.  报告 $p$ 的值，四舍五入到三位小数。\n\nHeun 方法的理论收敛阶为 $p=2$。在 $t_{\\text{end}}$ 远离 $t=1$ 处奇点的测试用例中，预计会观测到这个结果。当 $t_{\\text{end}}$ 接近 $1$ 时，解 $y(t)$ 的高阶导数变得非常大，这会增加主导误差项的量级。这可能导致方法性能下降，对于给定的步长范围，观测到的收敛阶 $p$ 可能会低于理论值 $2$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by calculating the observed convergence order\n    for a predictor-corrector method on a specific ODE for four test cases.\n    \"\"\"\n    \n    # Define the four test cases from the problem statement.\n    test_cases = [\n        {\"t_end\": 0.1, \"h_values\": [0.02, 0.01, 0.005, 0.0025]},\n        {\"t_end\": 0.5, \"h_values\": [0.1, 0.05, 0.025, 0.0125]},\n        {\"t_end\": 0.9, \"h_values\": [0.1, 0.05, 0.025, 0.0125]},\n        {\"t_end\": 0.95, \"h_values\": [0.05, 0.025, 0.0125]}\n    ]\n\n    # The ODE function y' = f(t, y) = y^2. It is autonomous.\n    def f_ode(y):\n        return y * y\n\n    def integrate_ode(t_end, h):\n        \"\"\"\n        Integrates the ODE y'=y^2 from t=0 to t_end using the specified\n        predictor-corrector scheme (Heun's method).\n        \n        Args:\n            t_end (float): The final integration time.\n            h (float): The constant step size.\n\n        Returns:\n            float: The numerical approximation of y(t_end).\n        \"\"\"\n        y = 1.0  # Initial condition y(0) = 1\n        num_steps = int(round(t_end / h))\n\n        for _ in range(num_steps):\n            # Predictor step (Explicit Euler)\n            f_yn = f_ode(y)\n            y_pred = y + h * f_yn\n            \n            # Corrector step (Trapezoidal update)\n            f_y_pred = f_ode(y_pred)\n            y = y + 0.5 * h * (f_yn + f_y_pred)\n            \n        return y\n\n    results = []\n    for case in test_cases:\n        t_end = case[\"t_end\"]\n        h_values = case[\"h_values\"]\n        \n        # Calculate the exact solution at t_end\n        y_exact = 1.0 / (1.0 - t_end)\n        \n        log_h_vals = []\n        log_E_vals = []\n        \n        for h in h_values:\n            # Compute numerical solution\n            y_num = integrate_ode(t_end, h)\n            \n            # Compute absolute global error\n            error = np.abs(y_num - y_exact)\n            \n            # Store log of step size and log of error\n            log_h_vals.append(np.log(h))\n            log_E_vals.append(np.log(error))\n            \n        # Perform a linear least-squares fit to find the convergence order p (the slope)\n        # log(E) = p * log(h) + C\n        p, _ = np.polyfit(log_h_vals, log_E_vals, 1)\n        \n        results.append(f\"{p:.3f}\")\n\n    # Format and print the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2429754"}, {"introduction": "认识到固定步长方法的局限性后，我们现在转向一个强大的解决方案：自适应步长控制。本练习将一个预估-校正对应用于著名的混沌系统——洛伦兹系统，并利用预估值和校正值之间的差异作为误差估计，来自动调整步长 ([@problem_id:2429776])。这是现代常微分方程求解器中用于平衡效率与精度的核心技术之一，通过这个练习你将获得实现它的实践经验。", "problem": "编写一个完整、可运行的程序，该程序使用基于预测状态和校正状态之间差异的自适应步长控制的单步预测-校正方法，来推进洛伦兹初值问题的解。洛伦兹系统是一个三维自治系统\n$$\n\\frac{d}{dt}\\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix} = \\begin{bmatrix}\n\\sigma \\left(y - x\\right) \\\\\nx \\left(\\rho - z\\right) - y \\\\\nx y - \\beta z\n\\end{bmatrix},\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是无量纲参数，$t$ 是无量纲时间，状态向量为 $\\vec{y}(t) = \\begin{bmatrix}x(t) \\\\ y(t) \\\\ z(t)\\end{bmatrix}$。本问题中所有量均为无量纲。\n\n在从 $\\left(t_n,\\vec{y}_n\\right)$ 开始、步长为 $h$ 的每一步中，使用以下显式预测-校正对计算预测状态 $\\vec{y}_p$ 和校正状态 $\\vec{y}_c$：\n$$\n\\vec{y}_p = \\vec{y}_n + h\\,\\vec{f}\\!\\left(\\vec{y}_n\\right), \\quad\n\\vec{y}_c = \\vec{y}_n + \\frac{h}{2}\\left(\\vec{f}\\!\\left(\\vec{y}_n\\right) + \\vec{f}\\!\\left(\\vec{y}_p\\right)\\right),\n$$\n其中 $\\vec{f}(\\vec{y})$ 表示洛伦兹系统的右侧项。定义局部差异\n$$\ne = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2.\n$$\n使用以下自适应步长控制：\n- 如果 $e \\le \\text{tol}$，则接受该步，此时推进到 $\\left(t_{n+1},\\vec{y}_{n+1}\\right) = \\left(t_n + h,\\vec{y}_c\\right)$。\n- 如果该步被拒绝 $(e  \\text{tol})$，则不推进时间，并用一个更小的 $h$ 重新计算该步。\n- 在每次尝试时（无论前一次尝试是接受还是拒绝），根据以下公式更新试验步长：\n$$\nh \\leftarrow h \\cdot \\operatorname{clip}\\!\\left(s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}, g_{\\min}, g_{\\max}\\right),\n$$\n其中 $s$ 是一个安全因子，$g_{\\min}$ 和 $g_{\\max}$ 限制了每次尝试的乘法变化范围，$\\epsilon$ 是一个用于避免除以零的正数，而 $\\operatorname{clip}(u,a,b)$ 表示将 $u$ 的值限制在区间 $\\left[a,b\\right]$ 内。步长被接受时，强制 $h \\le h_{\\max}$。在所有尝试中，强制 $h \\ge h_{\\min}$。如果 $t + h  t_f$，则在该次尝试中将 $h$ 替换为 $t_f - t$，以确保在 $t_f$ 精确结束。\n\n实现上述方法，对以下每个测试用例，从给定的初始步长 $h_0$ 开始，将解从 $t_0$ 推进到 $t_f$，并只统计接受的步数。对 $e$ 使用欧几里得范数 $\\left\\|\\cdot\\right\\|_2$。在步长更新中使用 $\\epsilon = 10^{-30}$。所有计算都必须以双精度执行。\n\n测试套件：\n- 测试用例 A（典型的混沌参数，中等容差）：\n  - $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$；$\\vec{y}_0 = \\begin{bmatrix}1 \\\\ 1 \\\\ 1\\end{bmatrix}$；$t_0 = 0$，$t_f = 2$；$\\text{tol} = 10^{-5}$；$h_0 = 10^{-2}$；$h_{\\min} = 10^{-6}$；$h_{\\max} = 5 \\times 10^{-2}$；$s = 0.9$；$g_{\\min} = 0.2$；$g_{\\max} = 2.0$。\n- 测试用例 B（较宽松的容差，较大的最大步长）：\n  - $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$；$\\vec{y}_0 = \\begin{bmatrix}1 \\\\ 1 \\\\ 1\\end{bmatrix}$；$t_0 = 0$，$t_f = 2$；$\\text{tol} = 10^{-2}$；$h_0 = 10^{-2}$；$h_{\\min} = 10^{-6}$；$h_{\\max} = 1/2$；$s = 0.9$；$g_{\\min} = 0.2$；$g_{\\max} = 2.0$。\n- 测试用例 C（更严格的容差，不同的初始状态，更短的时间范围）：\n  - $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$；$\\vec{y}_0 = \\begin{bmatrix}0 \\\\ 1 \\\\ 1\\end{bmatrix}$；$t_0 = 0$，$t_f = 1/2$；$\\text{tol} = 10^{-7}$；$h_0 = 10^{-3}$；$h_{\\min} = 10^{-7}$；$h_{\\max} = 5 \\times 10^{-3}$；$s = 0.9$；$g_{\\min} = 0.2$；$g_{\\max} = 2.0$。\n- 测试用例 D（非混沌参数，向原点收敛）：\n  - $\\sigma = 10$，$\\rho = 0$，$\\beta = 8/3$；$\\vec{y}_0 = \\begin{bmatrix}5 \\\\ 5 \\\\ 5\\end{bmatrix}$；$t_0 = 0$，$t_f = 1$；$\\text{tol} = 10^{-6}$；$h_0 = 10^{-2}$；$h_{\\min} = 10^{-7}$；$h_{\\max} = 10^{-1}$；$s = 0.9$；$g_{\\min} = 0.2$；$g_{\\max} = 2.0$。\n\n要求的最终输出格式：\n- 对于每个测试用例，按 A、B、C、D 的顺序，生成最终状态 $\\vec{y}(t_f) = \\begin{bmatrix}x(t_f) \\\\ y(t_f) \\\\ z(t_f)\\end{bmatrix}$ 的三个分量，四舍五入到小数点后六位，然后是到达 $t_f$ 所用的已接受步数的整数值。\n- 将所有结果按以下顺序聚合为单行，形式为用方括号括起来的逗号分隔列表：\n$$\n\\left[x_A, y_A, z_A, N_A, x_B, y_B, z_B, N_B, x_C, y_C, z_C, N_C, x_D, y_D, z_D, N_D\\right],\n$$\n其中 $x_\\bullet$、$y_\\bullet$、$z_\\bullet$ 是小数点后六位的浮点数，$N_\\bullet$ 是整数。精确地将此单行作为程序的唯一输出打印。", "solution": "洛伦兹系统是一个一阶自治系统，定义为 $\\vec{f}(\\vec{y}) = \\begin{bmatrix}\\sigma(y-x) \\\\ x(\\rho - z) - y \\\\ xy - \\beta z\\end{bmatrix}$，其状态为 $\\vec{y}(t) = \\begin{bmatrix}x(t) \\\\ y(t) \\\\ z(t)\\end{bmatrix}$。为了使用预测-校正方法和自适应步长控制来执行从 $t_0$ 到 $t_f$ 的时间积分，我们使用显式欧拉步作为预测子，并与显式梯形法则（也称为改进欧拉法或 Heun 方法）作为校正子配对。在每一步中，给定时间 $t_n$ 时的 $\\vec{y}_n$ 和一个试验步长 $h$，预测子和校正子定义为\n$$\n\\vec{y}_p = \\vec{y}_n + h\\,\\vec{f}(\\vec{y}_n), \\qquad\n\\vec{y}_c = \\vec{y}_n + \\frac{h}{2}\\big(\\vec{f}(\\vec{y}_n) + \\vec{f}(\\vec{y}_p)\\big).\n$$\n步长控制器需要一个局部误差的度量。对于单步法，一种标准方法是使用嵌入式估计，该估计源于将两个不同阶的近似应用于同一步所产生的差异。在这里，差值 $\\vec{y}_c - \\vec{y}_p$ 提供了一个估计，其大小与局部截断误差成正比。要理解这一点，可将 $\\vec{y}(t_n + h)$ 展开为泰勒级数：\n$$\n\\vec{y}(t_n + h) = \\vec{y}_n + h \\vec{f}(\\vec{y}_n) + \\frac{h^2}{2} \\vec{J}(\\vec{y}_n)\\,\\vec{f}(\\vec{y}_n) + \\mathcal{O}(h^3),\n$$\n其中 $\\vec{J}(\\vec{y})$ 是 $\\vec{f}$ 的雅可比矩阵。显式欧拉预测子 $\\vec{y}_p$ 匹配到 $\\mathcal{O}(h)$ 阶项，而梯形校正子 $\\vec{y}_c$ 匹配到 $\\mathcal{O}(h^2)$ 阶项，这使得校正后的值具有二阶精度。差值 $\\vec{y}_c - \\vec{y}_p$ 的量级为 $\\mathcal{O}(h^2)$，因此其欧几里得范数\n$$\ne = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2\n$$\n可作为局部误差的代理。\n\n为了使局部误差相对于用户定义的容差 $\\text{tol}$ 得到控制，当 $e \\le \\text{tol}$ 时我们接受该步，否则拒绝。经典的步长控制方法使用关系 $e \\propto h^2$ 来推导下一个试验步长 $h_{\\text{new}}$ 的更新公式：\n$$\nh_{\\text{new}} = h \\cdot \\left(\\frac{\\text{tol}}{e}\\right)^{1/2}.\n$$\n为了使该方法在实践中更加稳健，我们添加一个安全因子 $s \\in (0,1)$，并通过 $g_{\\min} \\le \\frac{h_{\\text{new}}}{h} \\le g_{\\max}$ 限制乘法变化，得到：\n$$\nh \\leftarrow h \\cdot \\operatorname{clip}\\!\\left(s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}, g_{\\min}, g_{\\max}\\right),\n$$\n其中 $\\epsilon  0$ 是一个非常小的数，用于在 $e=0$ 时避免除以零。在每次尝试中，我们强制 $h \\ge h_{\\min}$，并且在接受步长后不超过 $h_{\\max}$。我们还通过在 $t + h  t_f$ 时缩短最后一次尝试的步长来确保最后一步精确地落在 $t_f$。\n\n从算法上讲，对于每个测试用例：\n1. 初始化 $t \\leftarrow t_0$，$\\vec{y} \\leftarrow \\vec{y}_0$，$h \\leftarrow h_0$ 以及已接受步数计数器 $N \\leftarrow 0$。\n2. 当 $t  t_f$ 时循环：\n   - 设置 $h \\leftarrow \\min\\left(h, t_f - t\\right)$ 以避免超过最终时间。\n   - 计算预测子 $\\vec{y}_p = \\vec{y} + h\\,\\vec{f}(\\vec{y})$。\n   - 计算校正子 $\\vec{y}_c = \\vec{y} + \\frac{h}{2}\\left(\\vec{f}(\\vec{y}) + \\vec{f}(\\vec{y}_p)\\right)$。\n   - 计算 $e = \\left\\|\\vec{y}_c - \\vec{y}_p\\right\\|_2$。\n   - 计算乘法因子 $\\phi = s \\left(\\frac{\\text{tol}}{\\max(e,\\epsilon)}\\right)^{1/2}$，然后限制其范围：$\\phi \\leftarrow \\operatorname{clip}(\\phi, g_{\\min}, g_{\\max})$。\n   - 如果 $e \\le \\text{tol}$：\n     - 接受：设置 $\\vec{y} \\leftarrow \\vec{y}_c$，$t \\leftarrow t + h$，$N \\leftarrow N + 1$。\n     - 更新 $h \\leftarrow \\min\\left(h \\cdot \\phi, h_{\\max}\\right)$ 并强制 $h \\ge h_{\\min}$。\n   - 否则：\n     - 拒绝：更新 $h \\leftarrow \\max\\left(h \\cdot \\phi, h_{\\min}\\right)$ 并在不推进 $t$ 或 $\\vec{y}$ 的情况下重试。\n3. 终止后，报告 $\\vec{y}(t_f)$ 和 $N$。\n\n洛伦兹系统的右侧项计算如下：\n$$\n\\vec{f}\\!\\left(\\begin{bmatrix}x \\\\ y \\\\ z\\end{bmatrix}\\right) = \\begin{bmatrix}\n\\sigma\\left(y - x\\right) \\\\\nx\\left(\\rho - z\\right) - y \\\\\nx y - \\beta z\n\\end{bmatrix}.\n$$\n测试套件中的所有用例都使用这个带有指定参数、初始条件、容差和步长控制器常数的 $\\vec{f}$。要求的输出是 $t_f$ 时最终状态的分量（四舍五入到小数点后六位），其后是已接受的步数的整数值，四个用例的结果按顺序连接。程序将这些值打印为单个用方括号括起来的逗号分隔列表。\n\n这种方法基于预测-校正对的局部误差行为，并提供了一种系统化的方法来调整步长以满足指定的容差，同时遵守步长的上下限并确保在 $t_f$ 精确终止。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lorenz_rhs(y, sigma, rho, beta):\n    x, yv, z = y\n    return np.array([\n        sigma * (yv - x),\n        x * (rho - z) - yv,\n        x * yv - beta * z\n    ], dtype=np.float64)\n\ndef integrate_lorenz_pc_adaptive(y0, t0, tf, sigma, rho, beta,\n                                 tol, h0, hmin, hmax,\n                                 safety=0.9, gmin=0.2, gmax=2.0,\n                                 eps=1e-30):\n    y = np.array(y0, dtype=np.float64)\n    t = float(t0)\n    h = float(h0)\n    accepted_steps = 0\n\n    # Ensure bounds are sensible\n    hmin = float(hmin)\n    hmax = float(hmax)\n    safety = float(safety)\n    gmin = float(gmin)\n    gmax = float(gmax)\n\n    # Main adaptive loop\n    while t  tf:\n        # Prevent overshooting the final time\n        if t + h > tf:\n            h = tf - t\n        # Enforce min/max bounds on h for this attempt\n        if h  hmin:\n            h = hmin\n        if h > hmax:\n            h = hmax\n\n        f_n = lorenz_rhs(y, sigma, rho, beta)\n        y_pred = y + h * f_n\n        f_pred = lorenz_rhs(y_pred, sigma, rho, beta)\n        y_corr = y + 0.5 * h * (f_n + f_pred)\n\n        # Error estimate: Euclidean norm of difference\n        err = np.linalg.norm(y_corr - y_pred, ord=2)\n\n        # Compute multiplicative factor for next h\n        # Avoid division by zero using eps\n        ratio = tol / max(err, eps)\n        phi = safety * (ratio ** 0.5)\n        # Clip by growth/shrinkage limits\n        if phi  gmin:\n            phi = gmin\n        elif phi > gmax:\n            phi = gmax\n\n        if err = tol:\n            # Accept step\n            y = y_corr\n            t = t + h\n            accepted_steps += 1\n            # Update h for next attempt, enforce bounds\n            h = h * phi\n            if h > hmax:\n                h = hmax\n            if h  hmin:\n                h = hmin\n        else:\n            # Reject step: shrink h and retry\n            h = h * phi\n            if h  hmin:\n                h = hmin\n            # Do not advance t or y\n\n        # Safety net to avoid pathological infinite loops:\n        # if h becomes effectively zero and cannot advance time, break.\n        if h = 0.0:\n            break\n\n    return y, accepted_steps\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (sigma, rho, beta, y0, t0, tf, tol, h0, hmin, hmax, safety, gmin, gmax)\n    test_cases = [\n        # Case A\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 0.0, 2.0, 1e-5, 1e-2, 1e-6, 5e-2, 0.9, 0.2, 2.0),\n        # Case B\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 0.0, 2.0, 1e-2, 1e-2, 1e-6, 5e-1, 0.9, 0.2, 2.0),\n        # Case C\n        (10.0, 28.0, 8.0/3.0, (0.0, 1.0, 1.0), 0.0, 0.5, 1e-7, 1e-3, 1e-7, 5e-3, 0.9, 0.2, 2.0),\n        # Case D\n        (10.0, 0.0, 8.0/3.0, (5.0, 5.0, 5.0), 0.0, 1.0, 1e-6, 1e-2, 1e-7, 1e-1, 0.9, 0.2, 2.0),\n    ]\n\n    results_str = []\n    for case in test_cases:\n        sigma, rho, beta, y0, t0, tf, tol, h0, hmin, hmax, safety, gmin, gmax = case\n        y_final, n_acc = integrate_lorenz_pc_adaptive(\n            y0=y0, t0=t0, tf=tf,\n            sigma=sigma, rho=rho, beta=beta,\n            tol=tol, h0=h0, hmin=hmin, hmax=hmax,\n            safety=safety, gmin=gmin, gmax=gmax, eps=1e-30\n        )\n        # Append formatted floats and integer as specified\n        results_str.append(f\"{y_final[0]:.6f}\")\n        results_str.append(f\"{y_final[1]:.6f}\")\n        results_str.append(f\"{y_final[2]:.6f}\")\n        results_str.append(str(int(n_acc)))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2429776"}]}