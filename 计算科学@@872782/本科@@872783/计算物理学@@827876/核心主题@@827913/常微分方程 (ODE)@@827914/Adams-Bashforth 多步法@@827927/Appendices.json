{"hands_on_practices": [{"introduction": "数值方法中的“神奇数字”并非凭空而来。本练习将揭示高阶Adams-Bashforth方法的系数是如何从多项式插值这一基本原理中直接推导出来的。通过亲手推导五阶方法的系数，你将对该方法的构造及其与数值分析基本概念的联系有更深刻的理解。[@problem_id:2371218]", "problem": "在计算物理学中，多步积分器是通过近似常微分方程 (ODE) 右端项的时间积分来构建的。考虑一个标量状态变量的初值问题，该问题由常微分方程 $y^{\\prime}(t)=f(t,y(t))$ 在具有恒定步长 $h0$ 的均匀网格 $t_{n}=t_{0}+n h$ 上所支配。显式亚当斯–巴什福斯 (Adams–Bashforth) 方法族通过近似积分\n$$\ny_{n+1} = y_{n} + \\int_{t_{n}}^{t_{n+1}} f(t, y(t)) \\, dt\n$$\n来将 $y_{n}$ 推进到 $y_{n+1}$，其中使用了一个根据先前计算的值为 $f$ 构建的插值多项式。请通过以下第一性原理步骤构建一个 $5$ 阶显式亚当斯–巴什福斯方法：\n\n1. 在区间 $[t_{n}, t_{n+1}]$ 上，将 $f(t, y(t))$ 替换为唯一的 4 次多项式 $p_{4}(t)$，该多项式对数据点 $\\{(t_{n-k}, f_{n-k})\\}_{k=0}^{4}$ 进行插值，其中 $f_{n-k} \\equiv f(t_{n-k}, y_{n-k})$。\n\n2. 使用积分表示 $y_{n+1}=y_{n}+\\int_{t_{n}}^{t_{n+1}} p_{4}(t)\\,dt$ 来获得已知值 $f_{n}, f_{n-1}, f_{n-2}, f_{n-3}, f_{n-4}$ 的显式线性组合，其系数仅依赖于插值几何结构（而不依赖于 $f$ 本身）。\n\n您的任务是推导此 5 阶亚当斯–巴什福斯更新方法中分别乘以 $f_{n}, f_{n-1}, f_{n-2}, f_{n-3}, f_{n-4}$ 的 5 个系数。将您的最终答案表示为精确的有理数，形式为一个行矩阵，顺序为 $\\bigl(w_{0}, w_{1}, w_{2}, w_{3}, w_{4}\\bigr)$，其中\n$$\ny_{n+1} \\;=\\; y_{n} \\;+\\; h \\sum_{k=0}^{4} w_{k}\\, f_{n-k}.\n$$\n无需四舍五入，且不涉及单位。", "solution": "该问题陈述具有科学依据、提法恰当且客观。它描述了推导亚当斯-巴什福斯方法系数的标准过程，这是数值分析中的一个基本主题。该问题是有效的，我们将着手解决它。\n\n任务是为常微分方程 $y'(t) = f(t, y(t))$ 推导 5 阶显式亚当斯-巴什福斯方法的系数。该方法由以下更新规则给出：\n$$\ny_{n+1} = y_{n} + \\int_{t_{n}}^{t_{n+1}} f(t, y(t)) \\, dt\n$$\n其中被积函数 $f(t, y(t))$ 由一个唯一的 4 次插值多项式 $p_4(t)$ 近似，该多项式穿过最近的五个数据点 $\\{(t_{n-k}, f_{n-k})\\}_{k=0}^{4}$，其中 $f_{n-k} \\equiv f(t_{n-k}, y_{n-k})$。步长 $h=t_{n+1}-t_n$ 是恒定的。\n\n为了简化积分，我们通过变换 $t = t_n + sh$ 引入一个无量纲变量 $s$。积分区间 $[t_n, t_{n+1}]$ 对应于 $s \\in [0, 1]$。插值节点 $t_{n-k}$ 变为 $s = -k$（对于 $k=0, 1, 2, 3, 4$）。积分变为：\n$$\n\\int_{t_{n}}^{t_{n+1}} p_4(t) \\, dt = \\int_{0}^{1} p_4(t_n+sh) \\, h \\, ds = h \\int_{0}^{1} P(s) \\, ds\n$$\n其中 $P(s)$ 是 $s$ 坐标系中的插值多项式。\n\n我们使用牛顿后向差分公式来构造 $P(s)$，该公式特别适用于这种等距数据。对点 $(-k, f_{n-k})$（其中 $k=0, \\dots, 4$）进行插值的多项式由下式给出：\n$$\nP(s) = \\sum_{j=0}^{4} (-1)^j \\binom{-s}{j} \\nabla^j f_n\n$$\n其中 $\\binom{-s}{j} = \\frac{(-s)(-s-1)\\cdots(-s-j+1)}{j!}$ 是广义二项式系数，而 $\\nabla^j f_n$ 是以 $t_n$ 为中心的 $f$ 的 $j$ 阶后向差分。\n\n积分项则为 $h \\sum_{j=0}^{4} \\gamma_j \\nabla^j f_n$，其中系数 $\\gamma_j$ 定义为：\n$$\n\\gamma_j = \\int_{0}^{1} (-1)^j \\binom{-s}{j} \\, ds\n$$\n我们计算 $j=0, 1, 2, 3, 4$ 时的这些系数：\n\n$\\gamma_0 = \\int_0^1 (-1)^0 \\binom{-s}{0} ds = \\int_0^1 1 \\, ds = 1$。\n$\\gamma_1 = \\int_0^1 (-1)^1 \\binom{-s}{1} ds = \\int_0^1 s \\, ds = \\left[\\frac{s^2}{2}\\right]_0^1 = \\frac{1}{2}$。\n$\\gamma_2 = \\int_0^1 (-1)^2 \\binom{-s}{2} ds = \\int_0^1 \\frac{s(s+1)}{2} \\, ds = \\frac{1}{2} \\left[\\frac{s^3}{3} + \\frac{s^2}{2}\\right]_0^1 = \\frac{1}{2}\\left(\\frac{1}{3} + \\frac{1}{2}\\right) = \\frac{5}{12}$。\n$\\gamma_3 = \\int_0^1 (-1)^3 \\binom{-s}{3} ds = \\int_0^1 \\frac{s(s+1)(s+2)}{6} \\, ds = \\frac{1}{6}\\int_0^1 (s^3+3s^2+2s) \\, ds = \\frac{1}{6}\\left[\\frac{s^4}{4}+s^3+s^2\\right]_0^1 = \\frac{1}{6}\\left(\\frac{1}{4}+1+1\\right) = \\frac{1}{6}\\left(\\frac{9}{4}\\right) = \\frac{3}{8}$。\n$\\gamma_4 = \\int_0^1 (-1)^4 \\binom{-s}{4} ds = \\int_0^1 \\frac{s(s+1)(s+2)(s+3)}{24} \\, ds = \\frac{1}{24}\\int_0^1(s^4+6s^3+11s^2+6s) \\, ds = \\frac{1}{24}\\left[\\frac{s^5}{5}+\\frac{6s^4}{4}+\\frac{11s^3}{3}+3s^2\\right]_0^1 = \\frac{1}{24}\\left(\\frac{1}{5}+\\frac{3}{2}+\\frac{11}{3}+3\\right) = \\frac{1}{24}\\left(\\frac{6+45+110+90}{30}\\right) = \\frac{251}{720}$。\n\n更新规则为 $y_{n+1} = y_n + h\\sum_{j=0}^4 \\gamma_j \\nabla^j f_n$。为了得到所需的形式 $y_{n+1} = y_n + h \\sum_{k=0}^4 w_k f_{n-k}$，我们必须用函数值 $f_{n-k}$ 来表示后向差分 $\\nabla^j f_n$：\n$\\nabla^0 f_n = f_n$\n$\\nabla^1 f_n = f_n - f_{n-1}$\n$\\nabla^2 f_n = \\nabla(f_n - f_{n-1}) = (f_n - f_{n-1}) - (f_{n-1} - f_{n-2}) = f_n - 2f_{n-1} + f_{n-2}$\n$\\nabla^3 f_n = f_n - 3f_{n-1} + 3f_{n-2} - f_{n-3}$\n$\\nabla^4 f_n = f_n - 4f_{n-1} + 6f_{n-2} - 4f_{n-3} + f_{n-4}$\n\n总增量为 $h (\\gamma_0 f_n + \\gamma_1(f_n - f_{n-1}) + \\gamma_2(f_n - 2f_{n-1} + f_{n-2}) + \\gamma_3(f_n - 3f_{n-1} + 3f_{n-2} - f_{n-3}) + \\gamma_4(f_n - 4f_{n-1} + 6f_{n-2} - 4f_{n-3} + f_{n-4}))$。我们收集每个 $f_{n-k}$ 的系数 $w_k$：\n\n$w_0$ ($f_n$ 的系数)：\n$w_0 = \\gamma_0 + \\gamma_1 + \\gamma_2 + \\gamma_3 + \\gamma_4 = 1 + \\frac{1}{2} + \\frac{5}{12} + \\frac{3}{8} + \\frac{251}{720} = \\frac{720+360+300+270+251}{720} = \\frac{1901}{720}$。\n\n$w_1$ ($f_{n-1}$ 的系数)：\n$w_1 = -\\gamma_1 - 2\\gamma_2 - 3\\gamma_3 - 4\\gamma_4 = -\\frac{1}{2} - 2\\left(\\frac{5}{12}\\right) - 3\\left(\\frac{3}{8}\\right) - 4\\left(\\frac{251}{720}\\right) = -\\frac{1}{2} - \\frac{5}{6} - \\frac{9}{8} - \\frac{251}{180} = \\frac{-180-300-405-502}{360} = -\\frac{1387}{360}$。\n\n$w_2$ ($f_{n-2}$ 的系数)：\n$w_2 = \\gamma_2 + 3\\gamma_3 + 6\\gamma_4 = \\frac{5}{12} + 3\\left(\\frac{3}{8}\\right) + 6\\left(\\frac{251}{720}\\right) = \\frac{5}{12} + \\frac{9}{8} + \\frac{251}{120} = \\frac{50+135+251}{120} = \\frac{436}{120} = \\frac{109}{30}$。\n\n$w_3$ ($f_{n-3}$ 的系数)：\n$w_3 = -\\gamma_3 - 4\\gamma_4 = -\\frac{3}{8} - 4\\left(\\frac{251}{720}\\right) = -\\frac{3}{8} - \\frac{251}{180} = \\frac{-135-502}{360} = -\\frac{637}{360}$。\n\n$w_4$ ($f_{n-4}$ 的系数)：\n$w_4 = \\gamma_4 = \\frac{251}{720}$。\n\n因此，5 阶亚当斯-巴什福斯方法的系数为：\n$w_0 = \\frac{1901}{720}$，$w_1 = -\\frac{1387}{360}$，$w_2 = \\frac{109}{30}$，$w_3 = -\\frac{637}{360}$，$w_4 = \\frac{251}{720}$。\n我们可以通过检查 $\\sum w_k = 1$ 是否成立来验证该方法是否是一致的：\n$\\frac{1901}{720} - \\frac{2774}{720} + \\frac{2616}{720} - \\frac{1274}{720} + \\frac{251}{720} = \\frac{1901-2774+2616-1274+251}{720} = \\frac{4768 - 4048}{720} = \\frac{720}{720} = 1$。\n一致性检验通过。推导完成且正确。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1901}{720}  -\\frac{1387}{360}  \\frac{109}{30}  -\\frac{637}{360}  \\frac{251}{720} \\end{pmatrix}}$$", "id": "2371218"}, {"introduction": "将理论转化为实践是计算科学的核心。一个健壮的数值求解器是解决复杂问题的有力工具。本练习将指导你构建一个可重用的Python类，用于实现不同阶数的Adams-Bashforth方法。它还解决了多步法实际应用中必需的“启动”程序问题，从而加深对实际编程中需周全设计的理解。[@problem_id:2371225]", "problem": "构建一个完整、可运行的程序，该程序定义一个用于显式 Adams–Bashforth 多步法的基于类的求解器，并用它来对几个初值问题进行积分。该求解器必须维护一个内部状态，该状态包含最新的右端项函数求值，顺序为 $\\left[f_n,f_{n-1},\\dots\\right]$，其中 $f_n=f\\left(t_n,y_n\\right)$。该求解器必须支持恒定步长和阶数 $k \\in \\{1,2,3,4\\}$。所有变量都应视为无量纲。角度（如果出现）必须以弧度为单位进行解释。\n\n对于下述每个测试用例，程序必须使用固定的步长 $h$ 和指定的 Adams–Bashforth 阶数 $k$，对给定的初值问题从 $t=t_0$ 到 $t=t_{\\mathrm{final}}$ 进行数值积分。对于每个测试用例，按如下方式计算一个标量误差：对于标量问题，误差为绝对值 $|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)|$；对于矢量问题，误差为欧几里得范数 $\\left\\|y\\left(t_{\\mathrm{final}}\\right)-y_{\\mathrm{exact}}\\left(t_{\\mathrm{final}}\\right)\\right\\|_2$。然后，您的程序必须输出单行，该行是按下面测试用例顺序排列的四个误差值的逗号分隔的 Python 风格列表。\n\n测试套件规范：\n\n- 测试用例 1（标量，线性，阶数 $k=1$）：\n  - 微分方程：$\\dfrac{dy}{dt}=-y$。\n  - 初始条件：在 $t_0=0$ 时，$y(0)=1$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.1$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=e^{-t}$。\n  - 需要计算的误差：$|y(1)-e^{-1}|$。\n\n- 测试用例 2（标量，线性，阶数 $k=2$）：\n  - 微分方程：$\\dfrac{dy}{dt}=-y$。\n  - 初始条件：在 $t_0=0$ 时，$y(0)=1$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.1$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=e^{-t}$。\n  - 需要计算的误差：$|y(1)-e^{-1}|$。\n\n- 测试用例 3（标量，非线性，阶数 $k=3$）：\n  - 微分方程：$\\dfrac{dy}{dt}=-y^3$。\n  - 初始条件：在 $t_0=0$ 时，$y(0)=1$。\n  - 最终时间：$t_{\\mathrm{final}}=1$。\n  - 步长：$h=0.05$。\n  - 精确解：$y_{\\mathrm{exact}}(t)=\\dfrac{1}{\\sqrt{1+2t}}$。\n  - 需要计算的误差：$|y(1)-1/\\sqrt{3}|$。\n\n- 测试用例 4（矢量，线性旋转，阶数 $k=4$）：\n  - 微分方程：$\\dfrac{d}{dt}\\begin{bmatrix}u\\\\v\\end{bmatrix}=\\begin{bmatrix}0  -\\omega\\\\ \\omega  0\\end{bmatrix}\\begin{bmatrix}u\\\\v\\end{bmatrix}$，其中 $\\omega=1$。\n  - 初始条件：在 $t_0=0$ 时，$\\begin{bmatrix}u(0)\\\\v(0)\\end{bmatrix}=\\begin{bmatrix}1\\\\0\\end{bmatrix}$。\n  - 最终时间：$t_{\\mathrm{final}}=\\dfrac{\\pi}{2}$。\n  - 步长：$h=\\dfrac{\\pi}{400}$。\n  - 精确解：$\\begin{bmatrix}u_{\\mathrm{exact}}(t)\\\\v_{\\mathrm{exact}}(t)\\end{bmatrix}=\\begin{bmatrix}\\cos(t)\\\\\\sin(t)\\end{bmatrix}$。\n  - 需要计算的误差：$\\left\\|\\begin{bmatrix}u\\left(\\frac{\\pi}{2}\\right)\\\\v\\left(\\frac{\\pi}{2}\\right)\\end{bmatrix}-\\begin{bmatrix}0\\\\1\\end{bmatrix}\\right\\|_2$。\n\n最终输出格式规范：\n\n- 您的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果，并按测试用例 $\\left[1,2,3,4\\right]$ 的固定顺序排列。例如，一个语法上有效的行形式应为 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是一个浮点数。此行前后请勿打印任何额外文本。", "solution": "问题陈述已经过严格验证。所有给定条件，包括四个不同测试用例的微分方程、初始条件、积分参数和精确解，都已被提取和核实。其数学和物理前提是可靠的。指定的常微分方程是标准的，其提供的精确解是正确的。任务是为阶数 $k \\in \\{1,2,3,4\\}$ 实现一个显式 Adams–Bashforth 多步求解器，这在数值分析中是一个定义明确的问题。\n\n问题陈述中关于多步法（其中 $k  1$）的启动过程存在一个微小的歧义。一个 $k$ 步法需要 $k$ 个导数的历史值 $f_{n}, f_{n-1}, \\dots, f_{n-k+1}$ 来计算下一步 $y_{n+1}$。为了开始积分，前 $k-1$ 个点 $(t_1, y_1), \\dots, (t_{k-1}, y_{k-1})$ 必须由另一种自启动方法生成。问题没有指定此方法。这种遗漏是此类问题的常见特征，通常期望实现者选择一种标准的、科学上合理的方法。对于此解决方案，选择经典的四阶龙格-库塔（RK4）方法用于启动阶段。其单步性质和 $O(h^4)$ 的精度使其成为为高达4阶的 Adams–Bashforth 方法生成初始历史的稳健且合适的选择。经过这一澄清，该问题被认为是完整、一致且适定的。我们继续进行求解。\n\n用于求解初值问题 $\\frac{dy}{dt} = f(t,y)$（其中 $y(t_0) = y_0$）的显式 $k$ 步 Adams–Bashforth 方法由以下迭代公式定义：\n$$\ny_{n+1} = y_n + h \\sum_{i=0}^{k-1} b_{k,i} f(t_{n-i}, y_{n-i})\n$$\n其中 $h$ 是恒定步长，$y_n$ 是在时间 $t_n = t_0 + nh$ 时 $y(t_n)$ 的数值近似，而 $f_{n-i} = f(t_{n-i}, y_{n-i})$。所需阶数 $k=1, 2, 3, 4$ 的系数 $b_{k,i}$ 如下：\n\n对于 $k=1$（前向欧拉法）：\n$$\ny_{n+1} = y_n + h f_n\n$$\n单个系数为 $b_{1,0} = 1$。\n\n对于 $k=2$：\n$$\ny_{n+1} = y_n + h \\left( \\frac{3}{2} f_n - \\frac{1}{2} f_{n-1} \\right)\n$$\n系数为 $b_{2,0} = \\frac{3}{2}$ 和 $b_{2,1} = -\\frac{1}{2}$。\n\n对于 $k=3$：\n$$\ny_{n+1} = y_n + \\frac{h}{12} \\left( 23 f_n - 16 f_{n-1} + 5 f_{n-2} \\right)\n$$\n系数为 $b_{3,0} = \\frac{23}{12}$，$b_{3,1} = -\\frac{16}{12}$ 和 $b_{3,2} = \\frac{5}{12}$。\n\n对于 $k=4$：\n$$\ny_{n+1} = y_n + \\frac{h}{24} \\left( 55 f_n - 59 f_{n-1} + 37 f_{n-2} - 9 f_{n-3} \\right)\n$$\n系数为 $b_{4,0} = \\frac{55}{24}$，$b_{4,1} = -\\frac{59}{24}$，$b_{4,2} = \\frac{37}{24}$ 和 $b_{4,3} = -\\frac{9}{24}$。\n\n该实现将封装在 `AdamsBashforthSolver` 类中。求解器的构造函数 `__init__` 将初始化状态（$t$，$y$）并处理启动过程。对于给定的阶数 $k1$，它将执行 $k-1$ 步 RK4 方法来计算点 $(y_1, y_2, \\ldots, y_{k-1})$ 并填充所需的函数求值历史 $[f_{k-1}, f_{k-2}, \\ldots, f_0]$。从 $(t_n, y_n)$ 进行单步 RK4 的公式为：\n$$\n\\begin{align*}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1) \\\\\nk_3 = f(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2) \\\\\nk_4 = f(t_n + h, y_n + h k_3) \\\\\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{align*}\n$$\n启动阶段后，求解器的状态将包括当前时间 $t_{k-1}$、当前解 $y_{k-1}$ 和导数求值历史 $[f_{k-1}, f_{k-2}, \\ldots, f_0]$。`step` 方法将使用相应的 Adams–Bashforth 公式将解推进一个时间步。这涉及计算历史 $f$ 值的加权和。`integrate` 方法将协调整个过程，重复调用 `step` 方法，直到达到最终积分时间 $t_{\\mathrm{final}}$。\n\n程序将定义四个右端函数，为每个测试用例设置参数，并为每个用例实例化求解器。将调用 `integrate` 方法以获得最终数值解 $y(t_{\\mathrm{final}})$。然后将按规定计算误差：对于标量问题，为绝对差 $|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})|$；对于矢量问题，为欧几里得范数 $\\|y(t_{\\mathrm{final}}) - y_{\\mathrm{exact}}(t_{\\mathrm{final}})\\|_2$。四个用例的计算误差将被收集并以所需格式打印出来。", "answer": "```python\nimport numpy as np\n\nclass AdamsBashforthSolver:\n    \"\"\"\n    A class-based solver for explicit Adams–Bashforth multistep methods.\n    \"\"\"\n    AB_COEFFS = {\n        1: np.array([1.0]),\n        2: np.array([3.0/2.0, -1.0/2.0]),\n        3: np.array([23.0/12.0, -16.0/12.0, 5.0/12.0]),\n        4: np.array([55.0/24.0, -59.0/24.0, 37.0/24.0, -9.0/24.0])\n    }\n\n    def __init__(self, f, y0, t0, h, k):\n        \"\"\"\n        Initializes the Adams-Bashforth solver.\n\n        Args:\n            f (callable): The right-hand side function f(t, y) of the ODE.\n            y0 (float or np.ndarray): The initial condition y(t0).\n            t0 (float): The initial time.\n            h (float): The step size.\n            k (int): The order of the Adams-Bashforth method (1, 2, 3, or 4).\n        \"\"\"\n        if k not in self.AB_COEFFS:\n            raise ValueError(\"Order k must be in {1, 2, 3, 4}\")\n\n        self.f = f\n        self.y0 = np.array(y0, dtype=float)\n        self.t0 = float(t0)\n        self.h = float(h)\n        self.k = int(k)\n        \n        self.coeffs = self.AB_COEFFS[self.k]\n        \n        # Initialize state\n        self.t = self.t0\n        self.y = self.y0\n        \n        # f_history stores [f_n, f_{n-1}, ..., f_{n-k+1}]\n        self.f_history = []\n        \n        # Startup procedure to generate initial history for k>1\n        self._startup()\n\n    def _rk4_step(self, t, y):\n        \"\"\"Performs a single RK4 step.\"\"\"\n        k1 = self.f(t, y)\n        k2 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k1)\n        k3 = self.f(t + 0.5 * self.h, y + 0.5 * self.h * k2)\n        k4 = self.f(t + self.h, y + self.h * k3)\n        y_next = y + (self.h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n        t_next = t + self.h\n        return t_next, y_next\n\n    def _startup(self):\n        \"\"\"\n        Generates the first k-1 points using RK4 to populate f_history.\n        \"\"\"\n        # First evaluation at (t0, y0)\n        f0 = self.f(self.t0, self.y0)\n        self.f_history.insert(0, f0)\n        \n        # If k > 1, perform k-1 RK4 steps\n        if self.k > 1:\n            for _ in range(self.k - 1):\n                t_next, y_next = self._rk4_step(self.t, self.y)\n                self.t = t_next\n                self.y = y_next\n                f_next = self.f(self.t, self.y)\n                self.f_history.insert(0, f_next)\n\n    def step(self):\n        \"\"\"\n        Advances the solution by one step using the Adams-Bashforth formula.\n        \"\"\"\n        # Ensure f_history has the correct size\n        f_hist_array = np.array(self.f_history)\n        \n        # Calculate the weighted sum for the AB step\n        # For scalar y, f_hist_array is (k,), for vector y it is (k, dim)\n        # We need to dot coeffs with f_hist_array.\n        # np.dot handles this if f_hist_array is (dim, k)\n        if self.y.ndim > 0: # Vector case\n            ab_sum = np.dot(f_hist_array.T, self.coeffs)\n        else: # Scalar case\n            ab_sum = np.dot(self.coeffs, f_hist_array)\n\n        y_next = self.y + self.h * ab_sum\n        t_next = self.t + self.h\n        \n        # Update state\n        self.y = y_next\n        self.t = t_next\n        \n        # Update history\n        f_next = self.f(self.t, self.y)\n        self.f_history.insert(0, f_next)\n        if len(self.f_history) > self.k:\n            self.f_history.pop()\n\n    def integrate(self, t_final):\n        \"\"\"\n        Integrates the ODE from the current time to t_final.\n        \"\"\"\n        num_total_steps = int(round((t_final - self.t0) / self.h))\n        # Startup phase performed k-1 steps.\n        num_ab_steps = num_total_steps - (self.k - 1)\n        \n        for _ in range(num_ab_steps):\n            self.step()\n            \n        return self.y\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    \n    # --- Define RHS functions for the test cases ---\n    def f_case12(t, y):\n        # dy/dt = -y\n        return -y\n\n    def f_case3(t, y):\n        # dy/dt = -y^3\n        return -y**3\n\n    def f_case4(t, y):\n        # d/dt [u,v] = [0,-1; 1,0] * [u,v]\n        omega = 1.0\n        A = np.array([[0, -omega], [omega, 0]])\n        return A @ y\n\n    # --- Test suite specification ---\n    test_cases = [\n        # Case 1\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 1,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 2\n        {\n            'f': f_case12, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.1, 'k': 2,\n            'y_exact_final': np.exp(-1.0)\n        },\n        # Case 3\n        {\n            'f': f_case3, 'y0': 1.0, 't0': 0.0, 't_final': 1.0, 'h': 0.05, 'k': 3,\n            'y_exact_final': 1.0 / np.sqrt(3.0)\n        },\n        # Case 4\n        {\n            'f': f_case4, 'y0': np.array([1.0, 0.0]), 't0': 0.0, 't_final': np.pi / 2.0, \n            'h': np.pi / 400.0, 'k': 4,\n            'y_exact_final': np.array([0.0, 1.0])\n        }\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        solver = AdamsBashforthSolver(\n            f=case['f'],\n            y0=case['y0'],\n            t0=case['t0'],\n            h=case['h'],\n            k=case['k']\n        )\n        \n        y_final = solver.integrate(case['t_final'])\n        \n        y_exact = case['y_exact_final']\n        \n        if i == 3: # Vector case\n            error = np.linalg.norm(y_final - y_exact)\n        else: # Scalar cases\n            error = np.abs(y_final - y_exact)\n            \n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2371225"}, {"introduction": "现在，让我们将新获得的技能应用于一个物理问题。本练习以物理学的基石——谐振子为模型，探究数值方法如何与哈密顿系统的相空间面积守恒这类的基本守恒律相互作用。通过计算“数值熵”，你可以直观地看到像Adams-Bashforth这样的非辛方法如何引入人为的耗散或增长，这对任何计算物理学家来说都是一个至关重要的洞察。[@problem_id:2371247]", "problem": "考虑由常微分方程 (ODE) 定义的二维哈密顿系统 $$\\frac{d}{dt}\\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix}.$$ 该系统的精确流是相平面中角度为 $t$ (以弧度为单位) 的旋转，根据刘维尔定理，该旋转保持相空间面积不变。设初始基向量为 $$\\mathbf{e}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad \\mathbf{e}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}.$$ 将数值方法定义为四阶显式四步 Adams–Bashforth 方法 (AB4)，该方法在时间步长 $n$ 处使用以下公式将状态 $\\mathbf{y}_n \\in \\mathbb{R}^2$推进到 $\\mathbf{y}_{n+1}$：$$\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\left( \\frac{55}{24}\\,\\mathbf{f}_n - \\frac{59}{24}\\,\\mathbf{f}_{n-1} + \\frac{37}{24}\\,\\mathbf{f}_{n-2} - \\frac{9}{24}\\,\\mathbf{f}_{n-3} \\right),$$ 其中 $h  0$ 是步长，$\\mathbf{f}_k = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix} \\mathbf{y}_k$，且 $n \\ge 3$。为启动该多步法，对每个初始条件，使用在时间 $t=0$, $t=h$, $t=2h$ 和 $t=3h$ 处的精确解析解。时间 $t$ 处的精确解由以下旋转给出：$$\\mathbf{y}(t) = \\begin{bmatrix} \\cos t  \\sin t \\\\ -\\sin t  \\cos t \\end{bmatrix} \\mathbf{y}(0),$$ 其中 $t$ 以弧度为单位。\n\n对于给定的总演化时间 $T$，将时间 $T$ 处的数值相空间面积定义为在数值流作用下由 $\\mathbf{e}_1$ 和 $\\mathbf{e}_2$ 的像所张成的平行四边形的面积，即 $$A(T) = \\left| \\det \\left( \\begin{bmatrix} \\mathbf{y}^{(1)}(T)  \\mathbf{y}^{(2)}(T) \\end{bmatrix} \\right) \\right|,$$ 其中 $\\mathbf{y}^{(1)}(T)$ 和 $\\mathbf{y}^{(2)}(T)$ 分别是从 $\\mathbf{y}(0)=\\mathbf{e}_1$ 和 $\\mathbf{y}(0)=\\mathbf{e}_2$ 开始的在时间 $T$ 处的数值解。数值熵定义为 $$S(T) = \\ln\\!\\left(\\frac{A(T)}{A(0)}\\right),$$ 其中 $A(0)=1$。\n\n对所有计算采用以下约定：\n- 所有角度均使用弧度。\n- 对于给定的步长 $h$ 和指定的周期数 $P$，将步数定义为 $$N = \\operatorname{round}\\!\\left(\\frac{2\\pi P}{h}\\right),$$ 从而总积分时间为 $T = N h$。\n- 如果 $N \\le 3$，则对每个初始条件使用时间 $T$ 处的精确解来计算 $A(T)$。\n- 期望的输出是作为实数的 $S(T)$ 值。\n\n测试套件：\n- 情况 1：$h = 0.10$，$P = 10$。\n- 情况 2：$h = 0.05$，$P = 10$。\n- 情况 3：$h = 0.20$，$P = 5$。\n- 情况 4：$h = 0.10$，$P = 0$。\n- 情况 5：$h = 0.10$，$P = 100$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含测试用例的数值熵，形式为一个用方括号括起来的逗号分隔列表，每个数字格式化为小数点后有 $12$ 位数字的定点小数，且不含空格。例如，$$[\\text{S}_1,\\text{S}_2,\\text{S}_3,\\text{S}_4,\\text{S}_5].$$", "solution": "所提出的问题是有效的。它具有科学依据，是适定的、客观的，并包含了唯一解所需的所有必要信息。我们将进行形式化的推导并制定计算策略。\n\n该问题要求我们使用四步 Adams–Bashforth 方法 (AB4) 来分析简谐振子相空间面积的数值演化。该系统由线性常微分方程 (ODE) 描述：\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{J} \\mathbf{y}(t), \\quad \\text{其中} \\quad \\mathbf{y}(t) = \\begin{bmatrix} q(t) \\\\ p(t) \\end{bmatrix} \\quad \\text{且} \\quad \\mathbf{J} = \\begin{bmatrix} 0  1 \\\\ -1  0 \\end{bmatrix}.\n$$\n考虑初始基向量 $\\mathbf{e}_1 = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}$ 和 $\\mathbf{e}_2 = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$ 的演化。设从这些初始条件出发的解分别为 $\\mathbf{y}^{(1)}(t)$ 和 $\\mathbf{y}^{(2)}(t)$。由于 ODE 的线性性，我们可以通过考虑一个 $2 \\times 2$ 矩阵 $\\mathbf{Y}(t) = [ \\mathbf{y}^{(1)}(t) \\, \\mathbf{y}^{(2)}(t) ]$ 来同时表示这两个向量的演化。矩阵 $\\mathbf{Y}(t)$ 满足相同的 ODE：\n$$\n\\frac{d\\mathbf{Y}}{dt} = \\mathbf{J} \\mathbf{Y}(t),\n$$\n初始条件为 $\\mathbf{Y}(0) = [ \\mathbf{e}_1 \\, \\mathbf{e}_2 ] = \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $2 \\times 2$ 单位矩阵。\n\n时间 $T$ 处的相空间面积由 $A(T) = \\left| \\det(\\mathbf{Y}(T)) \\right|$ 给出。精确解析解为 $\\mathbf{Y}(t) = \\mathbf{R}(t)\\mathbf{Y}(0)$，其中 $\\mathbf{R}(t) = \\begin{bmatrix} \\cos t  \\sin t \\\\ -\\sin t  \\cos t \\end{bmatrix}$ 是旋转矩阵。由于对所有 $t$ 都有 $\\det(\\mathbf{R}(t)) = 1$，精确流保持面积不变：$A(t) = |\\det(\\mathbf{R}(t)\\mathbf{I})| = 1$。数值熵定义为 $S(T) = \\ln(A(T)/A(0))$。由于 $A(0) = |\\det(\\mathbf{Y}(0))| = |\\det(\\mathbf{I})| = 1$，这可以简化为 $S(T) = \\ln(A(T))$。对于精确解，$S(t) = \\ln(1) = 0$，这与哈密顿系统的刘维尔定理一致。\n\n我们将使用 AB4 数值方法来近似 $\\mathbf{Y}(T)$。设 $\\mathbf{Y}_n$ 是在时间 $t_n = n h$ 处对 $\\mathbf{Y}(t_n)$ 的数值近似，其中 $h$ 是步长。对于我们的矩阵方程，AB4 更新规则为：\n$$\n\\mathbf{Y}_{n+1} = \\mathbf{Y}_n + h \\left( \\frac{55}{24}\\,\\mathbf{F}_n - \\frac{59}{24}\\,\\mathbf{F}_{n-1} + \\frac{37}{24}\\,\\mathbf{F}_{n-2} - \\frac{9}{24}\\,\\mathbf{F}_{n-3} \\right),\n$$\n其中 $\\mathbf{F}_k = \\mathbf{J} \\mathbf{Y}_k$。该公式在 $n \\ge 3$ 时有效。为了开始积分，我们需要前四个步长的状态矩阵，即 $\\mathbf{Y}_0, \\mathbf{Y}_1, \\mathbf{Y}_2, \\mathbf{Y}_3$。问题规定必须使用精确解析解来初始化它们：\n$$\n\\mathbf{Y}_k = \\mathbf{R}(kh) = \\begin{bmatrix} \\cos(kh)  \\sin(kh) \\\\ -\\sin(kh)  \\cos(kh) \\end{bmatrix} \\quad \\text{对于} \\quad k \\in \\{0, 1, 2, 3\\}。\n$$\n由此，可以计算出相应的导数矩阵 $\\mathbf{F}_k = \\mathbf{J} \\mathbf{Y}_k$，以为 AB4 迭代提供初始值。\n\n总步数 $N$ 由周期数 $P$ 和步长 $h$ 决定，即 $N = \\operatorname{round}(2\\pi P / h)$，得出总积分时间为 $T = N h$。\n\n如果 $N \\le 3$，则适用一个特殊条件。在这种情况下，数值解被定义为时间 $T$ 处的精确解。因此，状态矩阵为 $\\mathbf{Y}(T) = \\mathbf{R}(T)$。面积为 $A(T) = |\\det(\\mathbf{R}(T))| = 1$，数值熵为 $S(T) = \\ln(1) = 0$。\n\n对于 $N  3$ 的一般情况，计算算法如下：\n1.  使用精确旋转矩阵 $\\mathbf{R}(t)$ 初始化前四个状态矩阵 $\\mathbf{Y}_0, \\mathbf{Y}_1, \\mathbf{Y}_2, \\mathbf{Y}_3$。\n2.  计算相应的导数矩阵 $\\mathbf{F}_0, \\mathbf{F}_1, \\mathbf{F}_2, \\mathbf{F}_3$。\n3.  从 $n = 3$ 迭代到 $N-1$。在每一步中，使用最近的四个导数矩阵，通过 AB4 公式计算 $\\mathbf{Y}_{n+1}$。\n4.  计算出 $\\mathbf{Y}_{n+1}$ 后，计算新的导数矩阵 $\\mathbf{F}_{n+1} = \\mathbf{J} \\mathbf{Y}_{n+1}$ 并更新导数历史记录以用于下一步。\n5.  循环完成后，最终的矩阵是 $\\mathbf{Y}_N$。\n6.  数值面积为 $A(T) = |\\det(\\mathbf{Y}_N)|$。\n7.  最终的数值熵是 $S(T) = \\ln(A(T))$。\n\n此过程将对每个测试用例实施，以计算所需的 $S(T)$ 值。所有计算均使用双精度浮点运算执行，以确保为指定的输出格式提供足够的精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (h, P)\n        (0.10, 10),\n        (0.05, 10),\n        (0.20, 5),\n        (0.10, 0),\n        (0.10, 100),\n    ]\n\n    results = []\n    for h, P in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        result = calculate_numerical_entropy(h, P)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef calculate_numerical_entropy(h, P):\n    \"\"\"\n    Calculates the numerical entropy S(T) for a given step size h and number of periods P.\n    \"\"\"\n    # Define the constant matrix J for the ODE dy/dt = J*y\n    J = np.array([[0., 1.], [-1., 0.]])\n    \n    # Calculate the total number of steps N and total time T\n    N = int(np.round((2. * np.pi * P) / h))\n    T = N * h\n    \n    # Handle the special case where N = 3\n    if N = 3:\n        # Per the problem statement, the numerical solution is the exact solution.\n        # The exact solution is area-preserving, so the determinant of the evolution\n        # matrix is 1. The logarithm of 1 is 0.\n        return 0.0\n        \n    # --- General case for N > 3 ---\n    \n    # Function to compute the exact rotation matrix R(t)\n    def get_rotation_matrix(t):\n        c, s = np.cos(t), np.sin(t)\n        return np.array([[c, s], [-s, c]])\n        \n    # 1. Initialization\n    # The first four state matrices (Y_0, Y_1, Y_2, Y_3) are from the exact solution.\n    # We also need the corresponding derivative matrices (F_0, F_1, F_2, F_3).\n    # F_hist will store F_{n-3}, F_{n-2}, F_{n-1}, F_n in a deque.\n    \n    Y_3 = get_rotation_matrix(3. * h)\n    \n    F_0 = J @ get_rotation_matrix(0. * h)\n    F_1 = J @ get_rotation_matrix(1. * h)\n    F_2 = J @ get_rotation_matrix(2. * h)\n    F_3 = J @ get_rotation_matrix(3. * h)\n    \n    F_hist = deque([F_0, F_1, F_2, F_3])\n    Y_curr = Y_3 # This is Y_n at the start of each iteration\n    \n    # AB4 coefficients for f_n, f_{n-1}, f_{n-2}, f_{n-3}\n    b = [55./24., -59./24., 37./24., -9./24.]\n    \n    # 2. Iteration loop\n    # The loop runs from n = 3 to N-1 to compute Y_4 through Y_N.\n    for n in range(3, N):\n        # Retrieve the historical derivatives for the AB4 step\n        F_n, F_nm1, F_nm2, F_nm3 = F_hist[3], F_hist[2], F_hist[1], F_hist[0]\n        \n        # Calculate the update term using the AB4 formula\n        F_update = b[0] * F_n + b[1] * F_nm1 + b[2] * F_nm2 + b[3] * F_nm3\n        \n        # Compute the next state matrix Y_{n+1}\n        Y_next = Y_curr + h * F_update\n        \n        # Compute the derivative at the new state for the next iteration\n        F_next = J @ Y_next\n        \n        # Update the state and history for the next step\n        Y_curr = Y_next\n        F_hist.popleft()\n        F_hist.append(F_next)\n        \n    # After the loop, Y_curr is the final state matrix Y_N\n    Y_N = Y_curr\n    \n    # 3. Final calculation\n    # Compute the area A(T) from the determinant of the final state matrix\n    area_T = np.abs(np.linalg.det(Y_N))\n    \n    # Compute the numerical entropy S(T) = ln(A(T)) since A(0)=1\n    entropy_T = np.log(area_T)\n    \n    return entropy_T\n\n# Run the simulation\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2371247"}]}