{"hands_on_practices": [{"introduction": "我们的第一个练习将直接挑战一个专门设计的“敌对”常微分方程（ODE）。该方程包含快速变化的振荡，这对求解器的自适应能力构成了严峻考验。通过亲手实现一个自适应求解器，并观察它为了保持精度而“奋力挣扎”——频繁地拒绝步长并缩小步长——您将对步长控制机制的实际工作方式，以及它为何是解决复杂问题的关键，获得一个具体而直观的理解。[@problem_id:2388548]", "problem": "构建、论证并测试一个一维对抗性常微分方程（ODE）初值问题，该问题能够在一个类刚性参数趋于零时，可靠地在自适应嵌入式龙格-库塔（ERK）求解器中引发频繁的步长拒绝。从基本概念入手：一个初值问题由 $y^{\\prime} = f(t,y,\\epsilon)$ 和 $y(0)=y_0$ 给出，其中对于固定的 $\\epsilon>0$，$f$ 在其参数上足够光滑。一个显式ERK方法在每一步内使用 $f$ 的多个阶段求值，以产生两个不同形式阶的近似解，它们的差值用作自适应步长控制的局部误差估计。一个 $p$ 阶方法的局部截断误差随步长 $h$ 按 $O(h^{p+1})$ 比例缩放，但当右侧项包含快速变化的分量时，精确解的更高阶导数会放大此缩放效应。\n\n你必须遵循以下说明。\n\n1) 对抗性ODE的设计与论证。通过结合一个稳定的线性耗散分量和一个随时间加速且在 $\\epsilon \\to 0$ 时集中在小尺度上的快速变化的平滑强迫项来设计 $f$。为了使任务具体且可测试，请使用以下典型的对抗性模型：\n- 定义ODE\n$$\ny^{\\prime}(t) \\;=\\; f(t,y,\\epsilon) \\;=\\; -\\,y \\;+\\; \\sin\\!\\Big(\\frac{t^2}{\\epsilon}\\Big)\\;+\\;0.3\\,\\exp\\!\\Big(-\\frac{(t-0.7)^2}{2\\,(2\\epsilon)^2}\\Big)\\,\\sin\\!\\Big(\\frac{t}{\\epsilon}\\Big).\n$$\n- 在区间 $t\\in[0,1]$ 上使用初始条件 $y(0)=0$。\n- 从第一性原理出发，解释为什么当 $\\epsilon\\to 0$ 时，这个 $f$ 对于带有自适应控制的显式ERK是“对抗性”的：耗散项 $-y$ 产生一个唯一的稳定解；啁啾正弦波 $\\sin(t^2/\\epsilon)$ 产生的瞬时频率与 $2t/\\epsilon$ 成正比，随 $t$ 增加而增加；局部高斯因子乘以一个快速振荡 $\\sin(t/\\epsilon)$，其中心位于 $t=0.7$，宽度为 $O(\\epsilon)$ 量级。随着 $\\epsilon$ 减小，解的更高阶时间导数的量级大致按 $\\epsilon^{-1}$ 的幂次增长，迫使 $h$ 必须急剧缩小以满足局部误差控制，这反过来又在控制器对步长的预测在快速变化区域过于乐观时，导致频繁的步长拒绝。\n\n2) 数值方法与自适应控制器。实现一个阶数为 $p=3$ 和 $\\hat{p}=2$ 的显式嵌入式龙格-库塔对（Bogacki–Shampine $3(2)$ 对），使用以下接受和步长自适应策略，所有这些都用适用于一维状态的加权标量范数表示：\n- 使用相对容差 $\\mathrm{rtol}$ 和绝对容差 $\\mathrm{atol}$，以及误差比\n$$\nE \\;=\\; \\frac{|y_{\\text{high}}-y_{\\text{low}}|}{\\mathrm{atol}+\\mathrm{rtol}\\,\\max\\{|y_n|,|y_{\\text{high}}|\\}},\n$$\n其中 $y_{\\text{high}}$ 是高阶更新，而 $y_{\\text{low}}$ 是低阶嵌入式更新。\n- 如果 $E\\le 1$，则接受该步，否则拒绝。拒绝时，减小步长并在不推进时间的情况下重试。\n- 通过控制器更新步长 $h$\n$$\nh_{\\text{new}} \\;=\\; h \\cdot \\mathrm{clip}\\!\\Big(\\gamma\\,E^{-1/3},\\,\\eta_{\\min},\\,\\eta_{\\max}\\Big),\n$$\n其中安全因子 $\\gamma=0.9$，最小因子 $\\eta_{\\min}=0.2$，最大因子 $\\eta_{\\max}=5$。如果 $E=0$，则取最大增长因子。\n\n3) 实现约束。编写一个完整的程序，该程序：\n- 实现具有“首步即末步”（First Same As Last, FSAL）属性的 Bogacki–Shampine $3(2)$ 方法。\n- 从 $t=0$ 积分到 $t=1$，初始步长为 $h_0=10^{-1}$，最小允许步长为 $h_{\\min}=10^{-12}$ 以避免无限循环。\n- 对每个测试案例，计算并返回被拒绝的步数。\n- 仅使用最终答案中指定的允许环境和库。\n\n4) 测试套件。在以下五个测试案例上评估求解器，这些案例探测了不同的机制和边界条件。每个案例都是一个三元组 $(\\epsilon,\\mathrm{rtol},\\mathrm{atol})$：\n- 案例A（良性基准）：$(1,\\;10^{-5},\\;10^{-8})$。\n- 案例B（中度振荡）：$(10^{-1},\\;10^{-5},\\;10^{-8})$。\n- 案例C（强振荡）：$(10^{-2},\\;10^{-5},\\;10^{-8})$。\n- 案例D（极端振荡）：$(10^{-3},\\;10^{-5},\\;10^{-8})$。\n- 案例E（更严格的容差边界）：$(10^{-2},\\;10^{-7},\\;10^{-10})$。\n\n5) 要求的最终输出格式。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按案例A到E的顺序排列，每个条目是该案例被拒绝的步数的整数值。例如，打印的行必须具有以下形式\n$[r_A,r_B,r_C,r_D,r_E]$\n其中每个 $r_\\cdot$ 都是一个整数。不得打印任何额外文本。\n\n所有数值都必须解释为无量纲的。角度以弧度为单位。不涉及物理单位。程序必须是自包含的，并且不需要用户输入或外部文件。", "solution": "该问题陈述经评估为**有效**。这是一个在计算物理领域，特别是关于常微分方程（ODE）数值解的适定初值问题。该问题具有科学依据，使用了成熟的数值方法（嵌入式龙格-库塔）和标准的自适应步长控制技术。所有参数、方程和约束都以足够的精度定义，以允许一个唯一、可验证的解。其目标清晰且可形式化。\n\n### 1. 对抗性ODE的设计与论证\n\n指定的ODE为\n$$\ny^{\\prime}(t) = f(t,y,\\epsilon) = -y + \\sin\\Big(\\frac{t^2}{\\epsilon}\\Big) + 0.3\\,\\exp\\Big(-\\frac{(t-0.7)^2}{8\\epsilon^2}\\Big)\\sin\\Big(\\frac{t}{\\epsilon}\\Big)\n$$\n初始条件为 $y(0)=0$，积分区间为 $t \\in [0,1]$。这个ODE被设计为在参数 $\\epsilon > 0$ 值很小时，对显式自适应求解器具有对抗性。原因如下。\n\n该ODE是一个形式为 $y' + y = g(t, \\epsilon)$ 的线性一阶方程，其中 $g(t, \\epsilon)$ 是由正弦项和高斯调制项组成的强迫函数。项 $-y$ 代表线性耗散，它保证解 $y(t)$ 是稳定的且保持有界，跟随强迫项 $g(t, \\epsilon)$ 的行为。其精确解由 $y(t) = e^{-t} \\int_0^t e^\\tau g(\\tau, \\epsilon) d\\tau$ 给出。\n\n对抗性源于强迫函数 $g(t, \\epsilon)$ 在 $\\epsilon \\to 0$ 时的性质：\n1.  **啁啾频率分量**：项 $\\sin(t^2/\\epsilon)$ 的瞬时角频率为 $\\omega(t) = \\frac{d}{dt}(t^2/\\epsilon) = 2t/\\epsilon$。振荡频率随时间线性增加，迫使自适应求解器在积分区间上前进时不断减小其步长 $h$。\n2.  **局部化高频脉冲**：项 $0.3\\,\\exp(-\\frac{(t-0.7)^2}{2\\,(2\\epsilon)^2})\\sin(t/\\epsilon)$ 引入了一个高频振荡 $\\sin(t/\\epsilon)$，该振荡由一个中心在 $t=0.7$ 的高斯包络调制。高斯函数的标准差为 $\\sigma = 2\\epsilon$，意味着此特征在空间上集中于一个宽度为 $O(\\epsilon)$ 的狭窄区域。这为求解器制造了一个突然的、局部化的挑战。\n\n一个 $p$ 阶龙格-库塔方法的局部截断误差（LTE）形式为 $LTE = C h^{p+1} y^{(p+1)}(\\xi)$，其中 $C$ 是一个常数，$\\xi$ 在步长区间内。解 $y(t)$ 的高阶导数由强迫项 $g(t, \\epsilon)$ 的导数决定。我们有：\n$$\ny'(t) = -y + g(t, \\epsilon) \\\\\ny''(t) = -y' + g' = y - g + g' \\\\\ny^{(k)}(t) = (-1)^k y + \\sum_{j=0}^{k-1} (-1)^{k-1-j} g^{(j)}(t, \\epsilon)\n$$\n因此，$y^{(k)}(t)$ 的量级主要由强迫函数的最高阶可用导数 $g^{(k-1)}(t, \\epsilon)$ 决定。$g(t, \\epsilon)$ 各分量的导数与 $\\epsilon$ 成反比。例如，对于啁啾项 $g_1(t) = \\sin(t^2/\\epsilon)$，其 $k$ 阶导数满足 $g_1^{(k)}(t) = O(\\epsilon^{-k})$。\n\n对于Bogacki-Shampine对，误差估计基于一个三阶（$p=3$）和一个二阶（$\\hat{p}=2$）近似解之差。这个差值是嵌入（低阶）方法局部截断误差的估计，其行为如 $O(h^{\\hat{p}+1} y^{(\\hat{p}+1)}) = O(h^3 y^{(3)})$。由于 $y^{(3)}$ 的尺度与 $g^{(2)}$ 相同，且 $g^{(2)}(t, \\epsilon) = O(\\epsilon^{-2})$，误差估计 $\\Delta$ 满足：\n$$\n\\Delta \\approx C' h^3 \\epsilon^{-2}\n$$\n自适应控制器旨在将误差比 $E = |\\Delta| / (\\text{atol} + \\text{rtol} \\cdot \\text{scale})$ 保持在1以下。这意味着步长 $h$ 必须满足 $h^3 \\lesssim (\\text{atol} + \\dots) \\epsilon^2$，或大致为 $h = O(\\epsilon^{2/3})$。随着 $\\epsilon$ 减小，所需的步长会显著缩小。一个基于当前误差来预测下一步长的自适应控制器，在遇到频率急剧增加的区域时，很可能会做出过于乐观的预测。这会导致误差估计 $E > 1$，引发步长拒绝，并强制使用更小的步长重试。这个过程在高振荡区域频繁重复，导致被拒绝的步数很高。\n\n### 2. 数值方法：Bogacki–Shampine 3(2) 对\n\nBogacki–Shampine方法是一个阶数为3和2的显式龙格-库塔对。其布彻表（Butcher tableau）如下：\n$$\n\\begin{array}{c|cccc}\n0  & 0  & 0  & 0  & 0 \\\\\n1/2 & 1/2 & 0  & 0  & 0 \\\\\n3/4 & 0  & 3/4 & 0  & 0 \\\\\n1  & 2/9 & 1/3 & 4/9 & 0 \\\\\n\\hline\ny_{\\text{high}} & 2/9 & 1/3 & 4/9 & 0 \\\\\ny_{\\text{low}} & 7/24 & 1/4 & 1/3 & 1/8\n\\end{array}\n$$\n对于从 $(t_n, y_n)$ 开始、步长为 $h$ 的一步，阶段计算如下：\n$$\n\\begin{aligned}\nk_1 &= f(t_n, y_n, \\epsilon) \\\\\nk_2 &= f\\left(t_n + \\frac{1}{2}h, y_n + \\frac{1}{2}h k_1, \\epsilon\\right) \\\\\nk_3 &= f\\left(t_n + \\frac{3}{4}h, y_n + \\frac{3}{4}h k_2, \\epsilon\\right)\n\\end{aligned}\n$$\n然后计算三阶解，这将作为下一步的候选解 $y_{n+1}$：\n$$\ny_{\\text{high}} = y_n + h\\left(\\frac{2}{9}k_1 + \\frac{1}{3}k_2 + \\frac{4}{9}k_3\\right)\n$$\n第四个阶段使用这个在时间 $t_n+h$ 的新近似解进行评估：\n$$\nk_4 = f(t_n + h, y_{\\text{high}}, \\epsilon)\n$$\n嵌入的二阶解则为：\n$$\ny_{\\text{low}} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{3}k_3 + \\frac{1}{8}k_4\\right)\n$$\n该方法具有“首步即末步”（First Same As Last, FSAL）特性。如果步长被接受，状态前进到 $(t_{n+1}, y_{n+1}) = (t_n+h, y_{\\text{high}})$。后续步骤的第一个阶段求值将是 $k'_1 = f(t_{n+1}, y_{n+1}, \\epsilon)$，这与刚刚计算出的 $k_4$ 相同。这允许重用 $k_4$ 的求值结果，每个接受的步长可节省一次函数求值。\n\n### 3. 自适应控制算法\n\n自适应步长控制基于局部误差的估计。\n\n**误差估计**：局部误差通过高阶解和低阶解之差来估计。对于这个标量问题，误差为 $\\Delta = y_{\\text{high}} - y_{\\text{low}}$。计算一个加权误差比 $E$ 以根据解的量级和指定的容差对误差进行归一化：\n$$\nE = \\frac{|\\Delta|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\{|y_n|, |y_{\\text{high}}|\\}}\n$$\n其中 `atol` 是绝对容差，`rtol` 是相对容差。如果 $E \\le 1$，则接受该步。\n\n**步长控制**：在完成一步（无论接受与否）后，使用一个标准的比例-积分（PI）控制器逻辑（此处简化为比例控制器）提出一个新的步长 $h_{\\text{new}}$：\n$$\nh_{\\text{new}} = h \\cdot \\text{clip}\\left(\\gamma E^{-1/(\\hat{p}+1)}, \\eta_{\\min}, \\eta_{\\max}\\right)\n$$\n对于我们的 $\\hat{p}=2$ 方法，指数为 $-1/3$。参数为：\n-   安全因子 $\\gamma = 0.9$，以提供一个保守的估计。\n-   最小步长变化因子 $\\eta_{\\min} = 0.2$。\n-   最大步长变化因子 $\\eta_{\\max} = 5$。\n`clip` 函数将乘法因子限制在 $[\\eta_{\\min}, \\eta_{\\max}]$ 范围内，以防止步长变化过快或过慢。如果 $E=0$，则使用最大因子 $\\eta_{\\max}$。如果一个步长为 $h$ 的步骤被拒绝（$E>1$），则提出的 $h_{\\text{new}}$ 将小于 $h$，并且从同一点 $(t_n, y_n)$ 用这个新的、更小的步长重试。如果步骤被接受（$E \\le 1$），则状态前进，并使用 $h_{\\text{new}}$ 进行下一步。最终的步长始终受下界 $h_{\\min} = 10^{-12}$ 的限制。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test cases as tuples of (epsilon, rtol, atol)\n    test_cases = [\n        (1.0, 1e-5, 1e-8),        # Case A: Benign baseline\n        (1e-1, 1e-5, 1e-8),       # Case B: Moderate oscillations\n        (1e-2, 1e-5, 1e-8),       # Case C: Strong oscillations\n        (1e-3, 1e-5, 1e-8),       # Case D: Extreme oscillations\n        (1e-2, 1e-7, 1e-10)       # Case E: Tighter tolerance edge\n    ]\n\n    results = []\n    for epsilon, rtol, atol in test_cases:\n        rejected_steps = solve_ode(epsilon, rtol, atol)\n        results.append(rejected_steps)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef f(t, y, epsilon):\n    \"\"\"\n    Defines the right-hand side of the adversarial ODE y' = f(t, y, epsilon).\n    \"\"\"\n    term1 = -y\n    term2 = np.sin(t**2 / epsilon)\n    # The denominator is 2 * (2*epsilon)^2 = 8 * epsilon^2\n    term3 = 0.3 * np.exp(-(t - 0.7)**2 / (8 * epsilon**2)) * np.sin(t / epsilon)\n    return term1 + term2 + term3\n\ndef solve_ode(epsilon, rtol, atol):\n    \"\"\"\n    Integrates the ODE using an adaptive Bogacki-Shampine 3(2) method.\n\n    Args:\n        epsilon (float): The stiffness-like parameter in the ODE.\n        rtol (float): Relative tolerance for step-size control.\n        atol (float): Absolute tolerance for step-size control.\n\n    Returns:\n        int: The total number of rejected steps during integration.\n    \"\"\"\n    t_start, t_end = 0.0, 1.0\n    y_start = 0.0\n\n    # Controller parameters\n    gamma = 0.9      # Safety factor\n    eta_min = 0.2    # Minimum step-size scaling factor\n    eta_max = 5.0    # Maximum step-size scaling factor\n    \n    # Integration parameters\n    h0 = 1e-1\n    h_min = 1e-12\n    \n    # Butcher tableau coefficients for Bogacki-Shampine 3(2)\n    c2, c3 = 1/2, 3/4\n    a21 = 1/2\n    a32 = 3/4\n    \n    b1_high, b2_high, b3_high = 2/9, 1/3, 4/9\n    b1_low, b2_low, b3_low, b4_low = 7/24, 1/4, 1/3, 1/8\n\n    # Initial conditions\n    t = t_start\n    y = y_start\n    h = h0\n    rejected_steps = 0\n    use_fsal = False\n    k1 = 0.0 # Will be properly initialized inside the loop\n\n    while t  t_end:\n        # Ensure the final step lands exactly on t_end\n        if t + h > t_end:\n            h = t_end - t\n            use_fsal = False  # FSAL is invalid for a step of modified length\n\n        # Calculate stages for the RK method\n        if not use_fsal:\n            k1 = f(t, y, epsilon)\n        # if use_fsal is True, k1 has been set to the previous step's k4\n\n        k2 = f(t + c2 * h, y + a21 * h * k1, epsilon)\n        k3 = f(t + c3 * h, y + a32 * h * k2, epsilon)\n        \n        # Calculate the higher-order (3rd order) approximation\n        y_high = y + h * (b1_high * k1 + b2_high * k2 + b3_high * k3)\n\n        # Use the FSAL property: calculate k4 using y_high\n        k4 = f(t + h, y_high, epsilon)\n\n        # Calculate the lower-order (2nd order) embedded approximation\n        y_low = y + h * (b1_low * k1 + b2_low * k2 + b3_low * k3 + b4_low * k4)\n\n        # Estimate the error and the error ratio E\n        error = abs(y_high - y_low)\n        scale = atol + rtol * max(abs(y), abs(y_high))\n        error_ratio = error / scale if scale > 1e-30 else 0.0\n\n        # Decide whether to accept or reject the step\n        if error_ratio = 1.0:  # Accept the step\n            t += h\n            y = y_high\n            \n            # Prepare for the next step using FSAL\n            use_fsal = True\n            k1 = k4  # k4 of this step is k1 of the next\n\n            # Update step size for the next step\n            if error_ratio == 0.0:\n                factor = eta_max\n            else:\n                factor = gamma * (error_ratio ** (-1.0 / 3.0))\n            \n            h_new = h * np.clip(factor, eta_min, eta_max)\n            h = max(h_min, h_new)\n\n        else:  # Reject the step\n            rejected_steps += 1\n            use_fsal = False  # Must re-evaluate k1 for the retried step\n\n            # Reduce step size for the retry\n            factor = gamma * (error_ratio ** (-1.0 / 3.0))\n            h_new = h * np.clip(factor, eta_min, eta_max)\n            h = max(h_min, h_new)\n            \n            if h = h_min and t  t_end:\n                # To prevent infinite loops in pathological cases where h must be = h_min\n                # we are forced to take a step at h_min. This may violate tolerance.\n                # Continuing with h=h_min as per problem interpretation.\n                pass\n\n    return rejected_steps\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2388548"}, {"introduction": "既然您已经见识了自适应求解器的实际运作，我们将剖析其最关键的组成部分：局部误差估算器。这个练习要求您比较一个正确实现的控制器和一个我们故意引入错误的控制器。通过观察估算器实现中一个看似微小的错误如何导致最终全局精度的显著下降，您将体会到可靠自适应方法背后理论的严谨性，并理解局部误差控制与全局解保真度之间的关键联系。[@problem_id:2388676]", "problem": "设计并实现一个基于嵌入式龙格-库塔对的自适应步长积分器，以研究不正确的局部误差估计如何影响全局误差。纯粹在常微分方程初值问题的数学背景下进行研究。您必须使用的基本依据是初值问题、局部截断误差以及显式龙格-库塔方法结构的定义。\n\n问题要求：\n- 考虑一个标量常微分方程的初值问题，由 $y'(t) = f(t,y(t))$ 和 $y(t_{0}) = y_{0}$ 给出。目标是从 $t_{0}$ 积分到最终时间 $T$。\n- 使用一个显式嵌入式龙格-库塔对，其中两个不同阶数的公式共享相同的内部阶段，以在每一步提供两个近似值 $y_{n+1}$ 和 $\\hat{y}_{n+1}$。高阶近似值 $y_{n+1}$ 用作步长结果，而差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$ 用作步长控制的局部误差估计。\n- 实现一对特定的、广泛使用的阶数 $p$ 和 $\\hat{p}$（$p  \\hat{p}$）；为了具体性和可复现性，使用 Bogacki–Shampine 阶数对 $p = 3$ 和 $\\hat{p} = 2$。当一个步长被接受时，使用高阶近似值来推进解。\n- 实现两个版本的自adaptive控制器：\n  1. 正确的控制器使用正确的低阶公式嵌入系数来计算局部误差估计 $e_{n+1}$。\n  2. 有缺陷的控制器通过以下方式有意改变嵌入的低阶权重来计算一个有缺陷的局部误差估计 $\\tilde{e}_{n+1}$：在形成差值之前，交换低阶方法的最后两个权重。换句话说，如果低阶权重为 $\\{b_{1}^{(\\hat{p})}, b_{2}^{(\\hat{p})}, b_{3}^{(\\hat{p})}, b_{4}^{(\\hat{p})}\\}$，则有缺陷的控制器在构建 $\\tilde{y}_{n+1}$ 时使用 $\\{b_{1}^{(\\hat{p})}, b_{2}^{(\\hat{p})}, b_{4}^{(\\hat{p})}, b_{3}^{(\\hat{p})}\\}$，因此 $\\tilde{e}_{n+1} = y_{n+1} - \\tilde{y}_{n+1}$。仅将此有缺陷的估计用于步长接受和步长选择，而在接受步长后，仍使用高阶近似值 $y_{n+1}$ 推进解。\n- 对标量状态使用标准误差范数：\n  $$\\mathrm{err\\_norm} = \\frac{|e_{n+1}|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|)}.$$\n  如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步。\n- 使用一个从低阶方法（阶数为 $\\hat{p}$）的局部截断误差缩放推导出的步长控制器。如果一个步长被接受或拒绝，提出一个新的步长\n  $$h_{\\mathrm{new}} = h \\cdot s \\cdot \\mathrm{err\\_norm}^{-1/(\\hat{p}+1)},$$\n  其中 $s$ 是一个安全因子。将 $h_{\\mathrm{new}}$ 限制在 $[\\alpha_{\\min} h, \\alpha_{\\max} h]$ 范围内，以避免不稳定的变化。使用 $\\hat{p} = 2$，$s = 0.9$，$\\alpha_{\\min} = 0.2$ 和 $\\alpha_{\\max} = 5$。\n- 在接受的步长上，使用 Bogacki–Shampine 对的高阶公式来推进解。对两个控制器使用相同的初始步长和控制器参数。\n\n测试问题和精确解：\n- 设 $f(t,y) = \\lambda y$，其中 $\\lambda  0$，$y(0) = 1$，精确解为 $y(t) = \\exp(\\lambda t)$。\n- 将最终时间 $T$ 处的全局误差定义为\n  $$E = |y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)|.$$\n\n测试套件：\n为以下参数集提供结果，这些参数集构成了测试套件（以下所有数字均为无量纲）：\n- 情况 A（顺利路径）：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-3}$，$\\mathrm{atol} = 10^{-12}$。\n- 情况 B（更严格的容差）：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n- 情况 C（衰减更快的动力学）：$\\lambda = -5$，$T = 2$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n\n每种情况需要计算什么：\n- 计算两个浮点数：\n  - $E_{\\mathrm{correct}}$：使用正确控制器得到的最终时间绝对误差。\n  - $E_{\\mathrm{flawed}}$：使用有缺陷的控制器得到的最终时间绝对误差。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，本身是一个双元素列表 $[E_{\\mathrm{correct}}, E_{\\mathrm{flawed}}]$。例如：[[EcA,EfA],[EcB,EfB],[EcC,EfC]]。以一致、紧凑的十进制格式打印数值。", "solution": "所提供的问题经过了严格的验证。\n\n**第1步：提取已知条件**\n- **初值问题 (IVP)**：一个标量常微分方程 (ODE) $y'(t) = f(t,y(t))$，初始条件为 $y(t_{0}) = y_{0}$，将从 $t_{0}$ 积分到最终时间 $T$。\n- **数值方法**：一个阶数为 $p=3$ 和 $\\hat{p}=2$ 的显式嵌入式龙格-库塔对，具体为 Bogacki–Shampine 对。高阶 ($p=3$) 近似值 $y_{n+1}$ 用于推进解。\n- **局部误差估计**：高阶近似值 ($y_{n+1}$) 和低阶近似值 ($\\hat{y}_{n+1}$) 之间的差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$ 作为局部截断误差的估计。\n- **控制器**：\n    1.  **正确控制器**：使用标准的局部误差估计 $e_{n+1}$。\n    2.  **有缺陷的控制器**：使用一个有缺陷的估计 $\\tilde{e}_{n+1} = y_{n+1} - \\tilde{y}_{n+1}$，其中 $\\tilde{y}_{n+1}$ 是通过交换低阶权重的最后两个元素来计算的。此有缺陷的估计仅用于步长控制。\n- **误差范数与接受条件**：缩放后的误差范数定义为 $\\mathrm{err\\_norm} = |e_{n+1}| / (\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|))$。如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步。\n- **步长控制律**：新的步长建议为 $h_{\\mathrm{new}} = h \\cdot s \\cdot \\mathrm{err\\_norm}^{-1/(\\hat{p}+1)}$，其中 $s = 0.9$ 且 $\\hat{p} = 2$。结果被限制在 $[\\alpha_{\\min} h, \\alpha_{\\max} h]$ 范围内，其中 $\\alpha_{\\min} = 0.2$ 和 $\\alpha_{\\max} = 5$。\n- **测试问题**：$f(t,y) = \\lambda y$，其中 $y(0) = 1$。精确解为 $y(t) = \\exp(\\lambda t)$。\n- **全局误差度量**：$E = |y_{\\mathrm{num}}(T) - y_{\\mathrm{exact}}(T)|$。\n- **测试用例**：\n    - 情况 A：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-3}$，$\\mathrm{atol} = 10^{-12}$。\n    - 情况 B：$\\lambda = -1$，$T = 10$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n    - 情况 C：$\\lambda = -5$，$T = 2$，$y_{0} = 1$，$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-12}$。\n- **所需计算**：对于每种情况，计算正确控制器 ($E_{\\mathrm{correct}}$) 和有缺陷的控制器 ($E_{\\mathrm{flawed}}$) 的最终时间全局误差。\n\n**第2步：使用提取的已知条件进行验证**\n该问题定义明确且科学上合理。它涉及计算工程中的一个基本主题：常微分方程的自适应数值方法的设计与分析。所有参数和过程都已足够精确地指定，以允许唯一的实现。唯一未指定的参数是初始步长 $h_0$。这是一个小疏忽。为了在两个控制器之间进行可复现的比较，为两者使用相同的合理初始步长就足够了。我将假设对所有模拟使用一个小的、固定的初始步长 $h_0$，这是一种标准方法。因此，该问题被认为是有效的。\n\n**第3步：结论与行动**\n该问题是**有效的**。将提供一个完整的、合理的解决方案。\n\n**基本原理与方法**\n\n该问题要求对初值问题 $y'(t) = f(t,y(t))$, $y(t_0) = y_0$ 进行数值积分。这是通过自适应步长龙格-库塔方法实现的。\n\n一个显式龙格-库塔方法通过一系列中间阶段的计算，从 $t_n$ 处的解计算出 $t_{n+1} = t_n + h_n$ 处的解。对于一个 $s$ 级方法，我们有：\n$$k_i = f\\left(t_n + c_i h_n, y_n + h_n \\sum_{j=1}^{i-1} a_{ij} k_j\\right), \\quad i=1, \\dots, s$$\n$$y_{n+1} = y_n + h_n \\sum_{i=1}^s b_i k_i$$\n系数 $c_i$、$a_{ij}$ 和 $b_i$ 定义了具体的方法。\n\n一个嵌入式对使用相同的阶段值 $k_i$ 集合，提供两个解，阶数为 $p$ 的 $y_{n+1}$ 和阶数为 $\\hat{p}  p$ 的 $\\hat{y}_{n+1}$。\n$$y_{n+1} = y_n + h_n \\sum_{i=1}^s b_i k_i \\quad (\\text{阶数 } p)$$\n$$\\hat{y}_{n+1} = y_n + h_n \\sum_{i=1}^s \\hat{b}_i k_i \\quad (\\text{阶数 } \\hat{p})$$\n差值 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1} = h_n \\sum_{i=1}^s (b_i - \\hat{b}_i)k_i$ 提供了低阶方法局部截断误差的估计。此误差估计用于控制步长 $h_n$。\n\n**Bogacki–Shampine 3(2) 对**\n\n指定的 Bogacki–Shampine 方法是一种 3 阶段方法，可产生一个 3 阶解和一个 2 阶解。它具有首步即末步 (First Same As Last, FSAL) 特性，意味着一步的最终阶段计算可以作为后续步骤的第一阶段重复使用，从而提高效率。其结构如下：\n\n1.  计算三个中间阶段：\n    $$k_1 = f(t_n, y_n)$$\n    $$k_2 = f(t_n + \\frac{1}{2}h, y_n + \\frac{1}{2}h k_1)$$\n    $$k_3 = f(t_n + \\frac{3}{4}h, y_n + \\frac{3}{4}h k_2)$$\n2.  计算用于推进解的 3 阶近似值：\n    $$y_{n+1} = y_n + h\\left(\\frac{2}{9}k_1 + \\frac{1}{3}k_2 + \\frac{4}{9}k_3\\right)$$\n3.  使用推进后的解 $y_{n+1}$ 计算第四个阶段。这是 FSAL 阶段。\n    $$k_4 = f(t_n + h, y_{n+1})$$\n4.  计算用于误差估计的 2 阶近似值：\n    $$\\hat{y}_{n+1} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{3}k_3 + \\frac{1}{8}k_4\\right)$$\n局部误差估计为 $e_{n+1} = y_{n+1} - \\hat{y}_{n+1}$。\n\n**自适应步长控制**\n\n控制器的目标是调整步长 $h$，使局部误差估计满足给定的容差。误差相对于解的幅度进行缩放：\n$$\\mathrm{err\\_norm} = \\frac{|e_{n+1}|}{\\mathrm{atol} + \\mathrm{rtol} \\cdot \\max(|y_{n}|, |y_{n+1}|)}$$\n其中 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 分别是绝对和相对误差容差。\n\n如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步。如果接受，则推进解：$t_{n+1} = t_n + h$，$y_{n+1} = y_{n+1}$。如果拒绝，则用更小的 $h$ 重新尝试该步。\n\n在任何一种情况下，都会提出一个新的步长 $h_{\\mathrm{new}}$。基于局部误差行为类似于 $C \\cdot h^{\\hat{p}+1}$ 的假设，从当前误差推导出最优步长：\n$$h_{\\mathrm{new}} = h \\cdot s \\cdot \\left(\\frac{1}{\\mathrm{err\\_norm}}\\right)^{1/(\\hat{p}+1)}$$\n这里，$\\hat{p}=2$ 是用于步长预测的误差估计对应的阶数，$s=0.9$ 是确保鲁棒性的安全因子。新的步长被限制以避免过大或过小的变化：$h_{\\mathrm{new}}$ 被约束在 $[\\alpha_{\\min} h, \\alpha_{\\max} h] = [0.2h, 5.0h]$ 范围内。\n\n**有缺陷的控制器**\n\n问题要求研究一个有缺陷的控制器。缺陷被引入局部误差估计中。2 阶方法的正确权重为 $\\hat{\\mathbf{b}} = [7/24, 1/4, 1/3, 1/8]$。缺陷在于交换最后两个权重：\n$$\\hat{\\mathbf{b}}_{\\text{flawed}} = [7/24, 1/4, 1/8, 1/3]$$\n这导致了一个有缺陷的 2 阶近似值：\n$$\\tilde{y}_{n+1} = y_n + h\\left(\\frac{7}{24}k_1 + \\frac{1}{4}k_2 + \\frac{1}{8}k_3 + \\frac{1}{3}k_4\\right)$$\n有缺陷的误差估计是 $\\tilde{e}_{n+1} = y_{n+1} - \\tilde{y}_{n+1}$。然后将这个 $\\tilde{e}_{n+1}$ 用于误差范数计算和随后的步长调整。需要注意的是，即使使用有缺陷的控制器，解仍然是使用正确的 3 阶公式 $y_{n+1}$ 来推进的。该缺陷仅影响自适应机制，而不影响传播公式本身。\n\n**算法与实现**\n\n实现的核心将是一个 `adaptive_integrator` 函数，它执行以下循环：\n1.  初始化 $t=t_0$，$y=y_0$，以及一个初始步长 $h=h_0$。我们将使用 $h_0 = 10^{-2}$。计算第一步的第一个阶段 $k_1 = f(t_0, y_0)$。\n2.  开始主循环，只要 $t  T$ 就继续。\n3.  在循环内部，开始一个用于步长接受的子循环。\n4.  在子循环中，计算阶段 $k_2, k_3$、3 阶解 $y_{n+1}$ 和最终阶段 $k_4$。\n5.  根据控制器类型（正确的或有缺陷的），计算适当的局部误差估计（$e_{n+1}$ 或 $\\tilde{e}_{n+1}$）。\n6.  计算误差范数 $\\mathrm{err\\_norm}$。\n7.  如果 $\\mathrm{err\\_norm} \\le 1$，则接受该步。推进时间和解（$t \\leftarrow t+h, y \\leftarrow y_{n+1}$）。该步的阶段 $k_4$ 成为下一步的新 $k_1$（FSAL）。退出子循环。\n8.  如果 $\\mathrm{err\\_norm}  1$，则拒绝该步。当前的 $y_{n+1}$ 被丢弃。子循环以一个新的、更小的步长 $h$ 继续。\n9.  在接受和拒绝两种情况下，都使用控制律和裁剪来计算一个新的建议步长 $h_{\\mathrm{new}}$，并更新 $h$。\n10. 当 $t \\ge T$ 时主循环终止。对最后一步的步长进行最终调整，以确保积分恰好在 $T$ 处停止。\n\n此过程将为每个测试用例执行，一次使用正确的控制器，另一次使用有缺陷的控制器。然后计算并报告最终的全局误差 $E = |y_{\\mathrm{num}}(T) - \\exp(\\lambda T)|$。有缺陷的控制器的行为（它比正确的控制器更激进还是更保守）将决定最终的全局误差是更大还是更小。该实验展示了全局误差对局部误差估计器正确性的敏感性，而局部误差估计器的正确性是自适应求解器可靠性的基础。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_integrator(f, t0, y0, T, rtol, atol, h0, flawed_controller):\n    \"\"\"\n    Integrates an ODE using the adaptive Bogacki-Shampine 3(2) method.\n    \"\"\"\n    # Bogacki-Shampine coefficients and controller parameters\n    # The method structure:\n    # k1 = f(t, y)\n    # k2 = f(t + 1/2 h, y + 1/2 h k1)\n    # k3 = f(t + 3/4 h, y + 3/4 h k2)\n    # y_next = y + h * (2/9 k1 + 1/3 k2 + 4/9 k3)  (order 3 solution)\n    # k4 = f(t + h, y_next)                          (FSAL stage)\n    # error = y_next - y_hat_next, where y_hat_next is the order 2 solution.\n    # The error is computed using a difference of weights for better numerical stability.\n    \n    b3_weights = np.array([2/9, 1/3, 4/9, 0])      # Order 3 weights\n    b2_weights_correct = np.array([7/24, 1/4, 1/3, 1/8]) # Order 2 weights\n    b2_weights_flawed = np.array([7/24, 1/4, 1/8, 1/3])  # Flawed order 2 weights\n\n    if flawed_controller:\n        err_weights = b3_weights - b2_weights_flawed\n    else:\n        err_weights = b3_weights - b2_weights_correct\n\n    s = 0.9\n    # The order of the embedded (lower-order) method is p_hat = 2.\n    # The exponent for step-size control is 1/(p_hat + 1) = 1/3.\n    p_hat = 2\n    alpha_min = 0.2\n    alpha_max = 5.0\n\n    t = t0\n    y = y0\n    h = h0\n\n    # First stage evaluation (k1) for the first step\n    k1 = f(t, y)\n\n    while t  T:\n        if t + h > T:\n            h = T - t  # Adjust last step to hit T exactly\n\n        step_accepted = False\n        while not step_accepted:\n            # Prevent infinitely small step size\n            if abs(h)  1e-15 * T:\n                raise RuntimeError(\"Step size has become excessively small.\")\n\n            # Compute stages for BS(3,2)\n            k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n            k3 = f(t + 0.75 * h, y + 0.75 * h * k2)\n            y_next = y + h * (b3_weights[0] * k1 + b3_weights[1] * k2 + \n                               b3_weights[2] * k3)\n            k4 = f(t + h, y_next)\n\n            # Calculate local error estimate\n            local_error = h * (err_weights[0] * k1 + err_weights[1] * k2 + \n                               err_weights[2] * k3 + err_weights[3] * k4)\n\n            # Calculate scaled error norm\n            y_scale = atol + rtol * max(abs(y), abs(y_next))\n            err_norm = abs(local_error) / y_scale if y_scale > 0 else 0\n\n            # Step acceptance logic\n            if err_norm = 1.0:\n                step_accepted = True\n                t += h\n                y = y_next\n                # FSAL: k4 of this step is k1 of the next\n                k1 = k4\n                \n                # Update step size for the next step\n                if err_norm == 0:\n                    # Avoid division by zero and propose max increase\n                    h_new = h * alpha_max\n                else:\n                    h_new = h * s * (err_norm ** (-1.0 / (p_hat + 1.0)))\n            else:\n                # Step rejected, reduce step size and retry\n                h_new = h * s * (err_norm ** (-1.0 / (p_hat + 1.0)))\n\n            # Clip the new step size\n            h = max(h * alpha_min, min(h * alpha_max, h_new))\n\n    return y\n\ndef solve():\n    \"\"\"\n    Runs the simulation for the specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {'lambda': -1.0, 'T': 10.0, 'y0': 1.0, 'rtol': 1e-3, 'atol': 1e-12},\n        # Case B\n        {'lambda': -1.0, 'T': 10.0, 'y0': 1.0, 'rtol': 1e-6, 'atol': 1e-12},\n        # Case C\n        {'lambda': -5.0, 'T': 2.0, 'y0': 1.0, 'rtol': 1e-6, 'atol': 1e-12},\n    ]\n\n    results = []\n    h0 = 1e-2  # Fixed initial step size for all runs for fair comparison\n\n    for case in test_cases:\n        lambda_val = case['lambda']\n        T = case['T']\n        y0 = case['y0']\n        rtol = case['rtol']\n        atol = case['atol']\n\n        # Define the ODE and its exact solution\n        f = lambda t, y: lambda_val * y\n        y_exact_func = lambda t: np.exp(lambda_val * t)\n        \n        y_exact_T = y_exact_func(T)\n\n        # Run with correct controller\n        y_num_correct = adaptive_integrator(f, 0, y0, T, rtol, atol, h0, flawed_controller=False)\n        E_correct = abs(y_num_correct - y_exact_T)\n\n        # Run with flawed controller\n        y_num_flawed = adaptive_integrator(f, 0, y0, T, rtol, atol, h0, flawed_controller=True)\n        E_flawed = abs(y_num_flawed - y_exact_T)\n\n        results.append([E_correct, E_flawed])\n\n    # Format the output string as specified\n    output_str = '[' + ','.join([f'[{r[0]:.5e},{r[1]:.5e}]' for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2388676"}, {"introduction": "我们最后的练习旨在探索，即使是一个表现良好的自适应龙格-库塔方法，在处理具有内在物理守恒律的问题时也存在其局限性。您将模拟天体力学的基石——开普勒问题，并分别使用自适应RK求解器和专门的辛积分器。通过比较能量和角动量在长期积分中的守恒情况，您会发现，仅仅控制局部截断误差并不能自动保证系统几何或物理结构的保持，这揭示了计算物理学中一个深刻的概念。[@problem_id:2388495]", "problem": "考虑无量纲单位下的平面二体（开普勒）问题，引力参数 $ \\mu = 1 $。设状态矢量为 $ \\mathbf{y}(t) = (x(t), y(t), z(t), v_x(t), v_y(t), v_z(t)) \\in \\mathbb{R}^6 $，其中运动被限制在平面 $ z = 0 $ 上。运动方程为以下一阶常微分方程（ODE）\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\n\\mathbf{r}(t) \\\\\n\\mathbf{v}(t)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{v}(t) \\\\\n- \\frac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert^3}\n\\end{pmatrix},\n$$\n其中 $ \\mathbf{r}(t) = (x(t), y(t), z(t)) $ 且 $ \\mathbf{v}(t) = (v_x(t), v_y(t), v_z(t)) $。总比机械能为\n$$\nE(t) = \\frac{1}{2} \\lVert \\mathbf{v}(t) \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r}(t) \\rVert},\n$$\n比角动量矢量为\n$$\n\\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t), \\quad L(t) = \\lVert \\mathbf{L}(t) \\rVert.\n$$\n\n你的任务是使用两种不同的数值时间积分器，对下述每个测试用例的这些常微分方程进行积分：\n- 一种通过使用嵌入式单步公式对来自适应地控制局部截断误差的方法，以及\n- 一种保持规范辛形式并使用固定步长的方法。\n\n对于每种方法和每个测试用例，计算守恒量 $ E(t) $ 和 $ L(t) $ 在整个仿真区间内的最大相对漂移。具体来说，如果 $ Q(t) $ 是一个关注量（$ E(t) $ 或 $ L(t) $），初始值为 $ Q(0) = Q_0 $，请报告\n$$\n\\max_{0 \\le t \\le T} \\frac{\\lvert Q(t) - Q_0 \\rvert}{\\lvert Q_0 \\rvert}.\n$$\n所有量都是无量纲的。输出必须是实数（小数），而非百分比。\n\n使用以下测试套件。每个测试用例指定了初始条件 $ \\mathbf{r}(0) $ 和 $ \\mathbf{v}(0) $（其中 $ z(0) = v_z(0) = 0 $）、最终时间 $ T $、自适应方法的绝对和相对容差 $ (\\text{atol}, \\text{rtol}) $，以及辛方法的固定步长 $ \\Delta t $。令 $ P = 2\\pi $ 表示在这些单位中对应于半长轴 $ a = 1 $ 的轨道周期。\n\n- 测试用例1（正常路径，中等偏心率）：\n  - $ \\mathbf{r}(0) = (0.7, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 1.363818169698585, 0) $\n  - $ T = 10 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-9} $，$ \\text{atol} = 10^{-12} $\n  - 辛方法固定步长：$ \\Delta t = P/200 $\n\n- 测试用例2（边界，圆形轨道）：\n  - $ \\mathbf{r}(0) = (1, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 1, 0) $\n  - $ T = 10 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-6} $，$ \\text{atol} = 10^{-9} $\n  - 辛方法固定步长：$ \\Delta t = P/50 $\n\n- 测试用例3（边缘，高偏心率）：\n  - $ \\mathbf{r}(0) = (0.2, 0, 0) $\n  - $ \\mathbf{v}(0) = (0, 3.0, 0) $\n  - $ T = 5 P $\n  - 自适应方法容差：$ \\text{rtol} = 10^{-7} $，$ \\text{atol} = 10^{-10} $\n  - 辛方法固定步长：$ \\Delta t = P/400 $\n\n对于每个测试用例，生成四个数字：\n- 自适应方法中 $ E(t) $ 的最大相对漂移，\n- 自适应方法中 $ L(t) $ 的最大相对漂移，\n- 辛方法中 $ E(t) $ 的最大相对漂移，\n- 辛方法中 $ L(t) $ 的最大相对漂移。\n\n将报告的每个浮点数四舍五入到八位有效数字。您的程序应生成单行输出，其中包含一个包含三个条目（每个测试用例一个）的列表。每个条目必须是按上述顺序排列的四个浮点数的列表。确切的输出格式必须为单行：\n`[ [eA1,lA1,eS1,lS1], [eA2,lA2,eS2,lS2], [eA3,lA3,eS3,lS3] ]`。", "solution": "对提供的问题进行验证。\n\n**步骤1：提取给定信息**\n- **系统：**无量纲单位下的平面二体（开普勒）问题。\n- **引力参数：**$ \\mu = 1 $。\n- **状态矢量：**$ \\mathbf{y}(t) = (x(t), y(t), z(t), v_x(t), v_y(t), v_z(t)) \\in \\mathbb{R}^6 $。\n- **约束：**平面运动，$ z(t) = 0 $。\n- **运动方程（ODE）：**\n$$\n\\frac{d}{dt}\n\\begin{pmatrix}\n\\mathbf{r}(t) \\\\\n\\mathbf{v}(t)\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\mathbf{v}(t) \\\\\n- \\frac{\\mathbf{r}(t)}{\\lVert \\mathbf{r}(t) \\rVert^3}\n\\end{pmatrix}\n$$\n- **守恒量：**\n  - 比机械能：$ E(t) = \\frac{1}{2} \\lVert \\mathbf{v}(t) \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r}(t) \\rVert} $。\n  - 比角动量矢量：$ \\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{v}(t) $，大小 $ L(t) = \\lVert \\mathbf{L}(t) \\rVert $。\n- **任务：**使用两种方法对常微分方程进行积分：一种是自适应步长的嵌入式单步公式，另一种是固定步长的规范辛积分器。\n- **分析指标：**计算 $ Q \\in \\{E, L\\} $ 的最大相对漂移， $ \\max_{0 \\le t \\le T} \\frac{\\lvert Q(t) - Q_0 \\rvert}{\\lvert Q_0 \\rvert} $。\n- **轨道周期参考：**对于半长轴 $ a = 1 $ 的圆形轨道，$ P = 2\\pi $。\n- **测试用例：**提供了三个测试用例，每个用例都有初始条件 $ (\\mathbf{r}(0), \\mathbf{v}(0)) $、最终时间 $ T $、自适应方法的容差 $ (\\text{rtol}, \\text{atol}) $以及辛方法的固定步长 $ \\Delta t $。\n\n**步骤2：使用提取的给定信息进行验证**\n- **科学依据：**该问题基于开普勒问题，这是经典力学和天体力学中的一个基本课题。方程和定义都是标准且正确的。它在科学上是合理的。\n- **适定性：**该问题是一个常微分方程组的初值问题。矢量场在远离奇点 $ \\mathbf{r} = \\mathbf{0} $ 的地方是光滑且表现良好的。由于初始条件非奇异且描述的是束缚轨道，因此在所有时间都存在唯一的稳定解。\n- **客观性：**问题陈述使用精确的数学语言编写，没有任何主观或模棱两可的术语。\n- **完整性与一致性：**提供了数值方法所需的所有必要参数、初始条件和规范。问题是自包含的，没有矛盾。术语`embedded Runge-Kutta formulas for adaptive control`在其标准的自适应步长控制的数值分析上下文中被理解。\n- **主题相关性：**该问题是计算物理学中的一个经典应用，比较了不同类别的数值积分器在一个哈密顿系统上的表现，这直接相关。\n\n**步骤3：结论与行动**\n该问题是有效的。将提供一个合理的解决方案。\n\n**基于原理的解决方案**\n\n该问题要求对开普勒问题进行数值积分，这是天体力学的基石。该系统是一个保守的哈密顿系统，拥有对于评估数值积分器质量至关重要的守恒量。我们将比较一个通用的自适应积分器与一个专门的几何积分器。\n\n**系统动力学与守恒量**\n开普勒问题由哈密顿函数描述：\n$$\nH(\\mathbf{r}, \\mathbf{p}) = \\frac{1}{2} \\lVert \\mathbf{p} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{r} \\rVert}\n$$\n其中 $ \\mathbf{r} $ 是位置矢量，$ \\mathbf{p} = \\mathbf{v} $ 是正则动量（由于质量是单位1，它等于速度）。运动方程由哈密顿方程给出，$ \\dot{\\mathbf{r}} = \\partial H / \\partial \\mathbf{p} = \\mathbf{p} $ 和 $ \\dot{\\mathbf{p}} = -\\partial H / \\partial \\mathbf{r} = -\\mathbf{r} / \\lVert\\mathbf{r}\\rVert^3 $，这与所提供的常微分方程组相符。\n\n对于这样的系统，在精确的解析解中有两个基本量是守恒的：\n$1$. 总比机械能 $ E(t) $，它与哈密顿量 $ H(\\mathbf{r}(t), \\mathbf{p}(t)) $ 相同。其守恒性源于 $ H $ 的时间无关性。\n$2$. 比角动量矢量 $ \\mathbf{L}(t) = \\mathbf{r}(t) \\times \\mathbf{p}(t) $。其守恒是引力势 $ V(\\mathbf{r}) = -1/\\lVert\\mathbf{r}\\rVert $ 的旋转对称性（中心力性质）的结果。因此，其大小 $ L(t) = \\lVert\\mathbf{L}(t)\\rVert $ 也是恒定的。\n\n数值积分器通常不能完美地保持这些守恒量。它们未能保持这些量的方式是区分其性能的关键。\n\n**数值积分方法1：自适应龙格-库塔**\n第一种指定的方法是用于自适应步长控制的嵌入式单步公式。对此的标准选择是 Dormand-Prince $5(4)$ 对，通常称为 `RK45`。在每一步，该方法产生两个解：一个四阶精度的解 $ y_{n+1}^{(4)} $ 和一个五阶精度的解 $ y_{n+1}^{(5)} $。这两者之间的差异可作为低阶方法局部截断误差的估计。然后将此误差估计与用户定义的容差进行比较，该容差是绝对容差 $ \\text{atol} $ 和相对容差 $ \\text{rtol} $ 的函数。步长 $ h $ 会被连续调整，以使估计误差低于此容差阈值。虽然这些方法在达到指定局部精度水平方面非常高效，但它们并非为保持哈密顿系统的几何结构而设计。因此，对于长期积分，即使容差非常小，它们也通常会在能量上表现出长期（单调）漂移。\n\n**数值积分方法2：辛积分器**\n第二种方法是固定步长的规范辛积分器。这些是专门为哈密顿系统设计的几何积分器。它们通常不完全守恒哈密顿量（能量）。但是，它们确实保持了辛二形式 $ d\\mathbf{r} \\wedge d\\mathbf{p} $，这是哈密顿流的一个基本性质。一个实际的结果是，数值解位于一个附近的“影子”哈密顿量上，该哈密顿量被积分器精确守恒。这导致能量误差 $ E(t) - E_0 $ 在指数级长的时间内保持有界和振荡，与非辛方法的长期漂移形成鲜明对比。\n\n对于一个可分离的哈密顿量 $ H = T(\\mathbf{p}) + V(\\mathbf{r}) $，一个简单且广泛使用的二阶辛积分器是蛙跳法，此处以其速度-Verlet形式实现。对于步长 $ \\Delta t $，算法的一步过程如下：\n$$\n\\mathbf{v}_{n+1/2} = \\mathbf{v}_n + \\frac{\\Delta t}{2} \\mathbf{a}(\\mathbf{r}_n)\n$$\n$$\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + \\Delta t \\, \\mathbf{v}_{n+1/2}\n$$\n$$\n\\mathbf{v}_{n+1} = \\mathbf{v}_{n+1/2} + \\frac{\\Delta t}{2} \\mathbf{a}(\\mathbf{r}_{n+1})\n$$\n其中 $ \\mathbf{a}(\\mathbf{r}) = -\\mathbf{r}/\\lVert\\mathbf{r}\\rVert^3 $ 是加速度。由于其时间可逆性和对称性，对于中心力问题，该积分器还能非常精确地守恒角动量，通常能达到机器精度。\n\n**分析流程**\n对于三个测试用例中的每一个，执行以下流程：\n$1$. 使用初始状态 $ \\mathbf{y}_0 = (\\mathbf{r}(0), \\mathbf{v}(0)) $ 计算初始能量 $ E_0 $ 和角动量大小 $ L_0 $。\n$2$. 使用 `RK45` 自适应积分器（通过 `scipy.integrate.solve_ivp`）和辛蛙跳积分器的自定义实现，将系统从 $ t=0 $ 积分到指定的最终时间 $ T $。\n$3$. 在每次积分期间，在每个时间步记录 $ E(t) $ 和 $ L(t) $ 的值。\n$4$. 每个量的最大相对漂移计算为 $ \\max_t \\frac{|Q(t) - Q_0|}{|Q_0|} $。\n$5$. 对于每个测试用例，收集四个产生的漂移值（两种方法的能量和角动量），并报告至八位有效数字。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the Kepler problem for three test cases using two different\n    numerical integration methods and calculates the drift in conserved quantities.\n    \"\"\"\n\n    # Helper function to format a number to 8 significant digits.\n    def format_sig(num):\n        return float('{:.8g}'.format(num))\n\n    # --- Problem Definition ---\n\n    def kepler_ode(t, y):\n        \"\"\"ODE system for the Kepler problem: dy/dt = f(t, y).\"\"\"\n        r_vec = y[:3]\n        r_norm = np.linalg.norm(r_vec)\n        \n        if r_norm == 0:\n            accel = np.zeros(3)\n        else:\n            accel = -r_vec / r_norm**3\n            \n        return np.concatenate((y[3:], accel))\n\n    def kepler_accel(r_vec):\n        \"\"\"Acceleration function a(r) for the symplectic integrator.\"\"\"\n        r_norm = np.linalg.norm(r_vec)\n        if r_norm == 0:\n            return np.zeros(3)\n        return -r_vec / r_norm**3\n\n    # --- Conserved Quantities ---\n\n    def calculate_energy(state):\n        \"\"\"Calculates the specific mechanical energy.\"\"\"\n        r_vec = state[:3]\n        v_vec = state[3:]\n        r_norm = np.linalg.norm(r_vec)\n        v_norm_sq = np.dot(v_vec, v_vec)\n        if r_norm == 0:\n            return np.inf\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def calculate_angular_momentum_magnitude(state):\n        \"\"\"Calculates the magnitude of the specific angular momentum.\"\"\"\n        r_vec = state[:3]\n        v_vec = state[3:]\n        L_vec = np.cross(r_vec, v_vec)\n        return np.linalg.norm(L_vec)\n\n    # --- Integrators ---\n\n    def solve_adaptive(y0, T, rtol, atol):\n        \"\"\"Integrates using an adaptive-step Runge-Kutta method (RK45).\"\"\"\n        sol = solve_ivp(\n            kepler_ode,\n            (0, T),\n            y0,\n            method='RK45',\n            rtol=rtol,\n            atol=atol,\n            dense_output=False\n        )\n        \n        E0 = calculate_energy(y0)\n        L0 = calculate_angular_momentum_magnitude(y0)\n        \n        energies = np.array([calculate_energy(sol.y[:, i]) for i in range(sol.y.shape[1])])\n        angular_momenta = np.array([calculate_angular_momentum_magnitude(sol.y[:, i]) for i in range(sol.y.shape[1])])\n        \n        max_rel_E_drift = np.max(np.abs(energies - E0)) / np.abs(E0) if E0 != 0 else 0\n        max_rel_L_drift = np.max(np.abs(angular_momenta - L0)) / np.abs(L0) if L0 != 0 else 0\n\n        return format_sig(max_rel_E_drift), format_sig(max_rel_L_drift)\n\n    def solve_symplectic(y0, T, dt):\n        \"\"\"Integrates using a fixed-step symplectic leapfrog (Velocity-Verlet) method.\"\"\"\n        r = y0[:3].copy()\n        v = y0[3:].copy()\n        \n        E0 = calculate_energy(y0)\n        L0 = calculate_angular_momentum_magnitude(y0)\n        \n        num_steps = int(np.ceil(T / dt))\n        \n        max_rel_E_drift = 0.0\n        max_rel_L_drift = 0.0\n        \n        # Velocity-Verlet implementation\n        accel = kepler_accel(r)\n        \n        for _ in range(num_steps):\n            # Kick (half step)\n            v_half = v + 0.5 * dt * accel\n            # Drift (full step)\n            r = r + dt * v_half\n            # New acceleration\n            accel = kepler_accel(r)\n            # Kick (half step)\n            v = v_half + 0.5 * dt * accel\n            \n            # Calculate conserved quantities at the new state\n            current_state = np.concatenate((r, v))\n            E = calculate_energy(current_state)\n            L = calculate_angular_momentum_magnitude(current_state)\n            \n            rel_E_drift = np.abs(E - E0) / np.abs(E0) if E0 != 0 else 0\n            rel_L_drift = np.abs(L - L0) / np.abs(L0) if L0 != 0 else 0\n            \n            if rel_E_drift > max_rel_E_drift:\n                max_rel_E_drift = rel_E_drift\n            if rel_L_drift > max_rel_L_drift:\n                max_rel_L_drift = rel_L_drift\n                \n        return format_sig(max_rel_E_drift), format_sig(max_rel_L_drift)\n\n    # --- Main Execution Logic ---\n\n    P = 2 * np.pi\n    \n    test_cases = [\n        # Case 1: Moderate eccentricity\n        {\n            \"y0\": np.array([0.7, 0, 0, 0, 1.363818169698585, 0]),\n            \"T\": 10 * P,\n            \"rtol\": 1e-9, \"atol\": 1e-12,\n            \"dt\": P / 200\n        },\n        # Case 2: Circular orbit\n        {\n            \"y0\": np.array([1, 0, 0, 0, 1, 0]),\n            \"T\": 10 * P,\n            \"rtol\": 1e-6, \"atol\": 1e-9,\n            \"dt\": P / 50\n        },\n        # Case 3: High eccentricity\n        {\n            \"y0\": np.array([0.2, 0, 0, 0, 3.0, 0]),\n            \"T\": 5 * P,\n            \"rtol\": 1e-7, \"atol\": 1e-10,\n            \"dt\": P / 400\n        }\n    ]\n    \n    all_results = []\n    \n    for case in test_cases:\n        y0 = case[\"y0\"]\n        \n        eA, lA = solve_adaptive(y0, case[\"T\"], case[\"rtol\"], case[\"atol\"])\n        eS, lS = solve_symplectic(y0, case[\"T\"], case[\"dt\"])\n        \n        all_results.append([eA, lA, eS, lS])\n        \n    case_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    print(f\"[{','.join(case_strings)}]\")\n\nsolve()\n```", "id": "2388495"}]}