{"hands_on_practices": [{"introduction": "在将数值方法应用于我们无法解析求解的复杂问题之前，验证代码的正确性是至关重要的一步。“人造解方法”是一种强大的验证技术。通过构建一个已知精确解的常微分方程，我们可以量化我们实现的数值方法的误差，并验证其是否达到了理论预期的收敛阶数。这个练习将指导你完成这一基本过程，为更复杂的计算任务奠定坚实的基础。[@problem_id:2413529]", "problem": "考虑以下基于常微分方程人工解法的验证任务。设精确解为标量函数 $y(t)$，定义在 $t \\in [0, T]$ 上，其表达式为：\n$$\ny(t) = e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big),\n$$\n其中三角函数中的所有角度均以弧度为单位。通过将右端项取为精确解的时间导数，并将初始条件设为初始时刻的精确值来定义初值问题：\n$$\n\\frac{dy}{dt} = \\frac{d}{dt}\\Big[e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big)\\Big], \\quad y(0) = y(0).\n$$\n对于此初值问题，使用中点法在区间 $[0, T]$ 上以均匀时间步长 $h$ 近似计算 $y(T)$，其中 $T = 2$，且 $h$ 能整除 $T$，因此步数 $N = T/h$ 为整数。对于给定的 $h$，全局误差是绝对差 $|y_{\\text{num}}(T) - y(T)|$，其中 $y_{\\text{num}}(T)$ 是由中点法产生的数值近似值，$y(T)$ 是精确值。\n\n您的程序必须为以下步长测试集计算全局误差，所有步长的单位与 $t$ 相同：\n- $h = 1.0$ (在 $[0, 2]$ 上的单个粗略步长)，\n- $h = 0.5$ (一次中等程度的细化)，\n- $h = 0.2$ (一次更精细的细化)，\n- $h = 0.05$ (一次非常精细的细化)。\n\n要求：\n- 使用上面指定的精确解 $y(t)$ 通过其时间导数来定义右端项，并使用 $y(0)$ 作为初始条件。\n- 为测试集中的每个 $h$ 计算全局误差 $|y_{\\text{num}}(T) - y(T)|$。\n- 报告每个误差，四舍五入到12位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为测试结果，顺序与测试集一致，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_i$ 是一个四舍五入到12位小数的浮点数。", "solution": "问题陈述已经过验证，被认为是合理的。它提出了一个基于人工解法的适定验证任务，这是一种计算科学中用于评估数值格式精度的标准技术。所有提供的信息都是完整、一致且有科学依据的。\n\n该任务是为给定的步长集，计算中点法在固定区间上求解一个特定常微分方程（ODE）的全局误差。\n\n首先，我们定义初值问题（IVP）的组成部分。精确解由下式给出：\n$$\ny(t) = e^{-2 t}\\,\\big(\\sin(3 t) + t^2\\big)\n$$\n对于时间区间 $t \\in [0, T]$，其中最终时间为 $T=2$。\n\nIVP 是根据此解构建的。初始条件是精确解在 $t=0$ 处的值：\n$$\ny(0) = e^{-2(0)}\\big(\\sin(3(0)) + 0^2\\big) = 1 \\cdot (0 + 0) = 0\n$$\nODE 的右端项，我们记为 $f(t, y)$，是精确解的时间导数。由于 $y(t)$ 的导数仅依赖于 $t$，我们可以将 ODE 写为 $\\frac{dy}{dt} = f(t)$。我们使用乘法法则计算这个导数：\n$$\n\\frac{d}{dt} \\left( u(t) v(t) \\right) = u'(t)v(t) + u(t)v'(t)\n$$\n令 $u(t) = e^{-2t}$ 和 $v(t) = \\sin(3t) + t^2$。它们的导数是：\n$$\nu'(t) = -2e^{-2t}\n$$\n$$\nv'(t) = 3\\cos(3t) + 2t\n$$\n应用乘法法则，我们得到函数 $f(t)$：\n$$\nf(t) = \\frac{dy}{dt} = (-2e^{-2t})\\big(\\sin(3t) + t^2\\big) + (e^{-2t})\\big(3\\cos(3t) + 2t\\big)\n$$\n$$\nf(t) = e^{-2t}\\big(-2\\sin(3t) - 2t^2 + 3\\cos(3t) + 2t\\big)\n$$\n这个函数 $f(t)$ 定义了我们 ODE 的右端项，即 $\\frac{dy}{dt} = f(t)$。\n\n接下来，我们定义数值方法。中点法是一种二阶 Runge-Kutta 方法。对于一个一般的 ODE $\\frac{dy}{dt} = F(t, y)$，从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步计算由下式给出：\n$$\nk_1 = F(t_n, y_n)\n$$\n$$\nk_2 = F(t_n + h/2, y_n + (h/2)k_1)\n$$\n$$\ny_{n+1} = y_n + h k_2\n$$\n在我们的特定情况下，右端项 $F(t, y)$ 与 $y$ 无关，即 $F(t, y) = f(t)$。该公式显著简化为：\n$$\nk_1 = f(t_n)\n$$\n$$\nk_2 = f(t_n + h/2)\n$$\n$$\ny_{n+1} = y_n + h f(t_n + h/2)\n$$\n这就是我们将用来近似求解的迭代格式。\n\n寻找数值解 $y_{\\text{num}}(T)$ 的算法如下。给定区间 $[0, T] = [0, 2]$ 和一组步长 $h \\in \\{1.0, 0.5, 0.2, 0.05\\}$。对于每个 $h$：\n1.  计算步数 $N = T/h$。对于给定的值，这将是一个整数。\n2.  在起始时间初始化解：$t_0 = 0$，$y_0 = y(0) = 0$。\n3.  对于 $n = 0, 1, 2, \\ldots, N-1$ 进行迭代：\n    -   当前时间是 $t_n = n \\cdot h$。\n    -   当前步的时间中点是 $t_{n+1/2} = t_n + h/2$。\n    -   解的下一个值计算为 $y_{n+1} = y_n + h \\cdot f(t_{n+1/2})$。\n4.  经过 $N$ 步后，在最终时间 $T=2$ 处的数值近似值为 $y_{\\text{num}}(T) = y_N$。\n\n最后，我们计算全局误差。在最终时间 $T=2$ 处的精确值为：\n$$\ny(2) = e^{-2(2)}\\big(\\sin(3 \\cdot 2) + 2^2\\big) = e^{-4}\\big(\\sin(6) + 4\\big)\n$$\n对于给定的步长 $h$，全局误差 $E_h$ 是数值近似值与精确值之间的绝对差：\n$$\nE_h = |y_{\\text{num}}(T) - y(T)| = |y_N - y(2)|\n$$\n对每个指定的 $h$ 值重复此过程。然后按要求将所得误差四舍五入到12位小数。实现将使用数值库来计算指数函数和三角函数，其中角度按规定使用弧度单位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the verification task for the midpoint method.\n\n    This function implements the method of manufactured solutions to test the\n    midpoint method for a given ordinary differential equation. It computes\n    the global error at T=2 for a suite of step sizes.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # The step sizes h are given in the problem.\n    test_cases = [1.0, 0.5, 0.2, 0.05]\n\n    # Final time T.\n    T = 2.0\n\n    # 1. Define the exact solution y(t)\n    def y_exact(t):\n        \"\"\"\n        The exact manufactured solution.\n        y(t) = exp(-2t) * (sin(3t) + t^2)\n        \"\"\"\n        return np.exp(-2.0 * t) * (np.sin(3.0 * t) + t**2)\n\n    # 2. Define the right-hand side f(t) = dy/dt\n    def f(t):\n        \"\"\"\n        The time derivative of the exact solution, dy/dt.\n        f(t) = exp(-2t) * (3*cos(3t) - 2*sin(3t) + 2t - 2t^2)\n        \"\"\"\n        return np.exp(-2.0 * t) * (\n            3.0 * np.cos(3.0 * t) - 2.0 * np.sin(3.0 * t) + 2.0 * t - 2.0 * t**2\n        )\n\n    # Calculate the exact value at the final time T.\n    y_T_exact = y_exact(T)\n\n    results = []\n    # Loop over each step size h in the test suite.\n    for h in test_cases:\n        # 3. Apply the midpoint method.\n        \n        # Number of steps. Using int(round(...)) to avoid float precision issues.\n        N = int(round(T / h))\n        \n        # Initialize the numerical solution with the exact initial condition.\n        y_num = y_exact(0.0)\n        t = 0.0\n\n        # Iterate N times to reach T.\n        for n in range(N):\n            # Midpoint in time for the current interval [t, t+h]\n            t_mid = t + h / 2.0\n            \n            # Update the solution using the midpoint method for dy/dt = f(t)\n            # y_{n+1} = y_n + h * f(t_n + h/2)\n            y_num = y_num + h * f(t_mid)\n            \n            # Update the current time for the next step.\n            t = (n + 1) * h\n\n        # 4. Compute the global error.\n        # The global error is the absolute difference at the final time T.\n        error = abs(y_num - y_T_exact)\n        \n        # Append the rounded error to the results list.\n        results.append(round(error, 12))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413529"}, {"introduction": "一个经过验证的求解器是可靠的，但这并不意味着它能完美地复现物理系统的所有特性。许多物理系统拥有守恒量，例如能量或本练习中的一个特殊不变量，而数值方法可能会引入导致这些量漂移的误差。通过将中点法应用于经典的 Lotka-Volterra 捕食者-被捕食者模型，你将亲手研究数值积分如何影响一个非哈密顿系统的守恒量，并计算误差的收敛阶。[@problem_id:2413563]", "problem": "考虑相互作用种群的二维Lotka–Volterra模型，该模型由以下自治常微分方程组（ODEs）描述：\n$$\n\\frac{dx}{dt} = x\\,(a - b\\,y), \\quad \\frac{dy}{dt} = y\\,(-c + d\\,x),\n$$\n其中参数 $a0$、$b0$、$c0$、$d0$，初始条件为 $(x(0),y(0)) = (x_0,y_0)$，且 $x_00$ 和 $y_00$。该系统有一个光滑的非哈密顿守恒量\n$$\nI(x,y) = d\\,x - c\\,\\ln(x) + b\\,y - a\\,\\ln(y),\n$$\n其中 $\\ln$ 表示自然对数。对于精确解 $(x(t),y(t))$，只要 $x(t)0$ 且 $y(t)0$，守恒量 $I(x(t),y(t))$ 在所有时间 $t$ 上都保持不变。\n\n任务：编写一个完整、可运行的程序，使用显式中点法（两阶段龙格-库塔中点格式）和一个固定的时间步长 $h$，从时间 $t=0$ 到时间 $t=T$ 对解进行数值推进。对于每个指定的测试用例，计算最终时刻守恒量的绝对漂移，\n$$\n\\Delta I = \\bigl|\\,I\\bigl(x(T),y(T)\\bigr) - I(x_0,y_0)\\,\\bigr|.\n$$\n此外，对于一组指定的步长，计算由以下公式定义的守恒量漂移误差的观测阶 $p$\n$$\np = \\frac{\\ln\\!\\bigl(\\Delta I(h_2)/\\Delta I(h_1)\\bigr)}{\\ln\\!\\bigl(h_2/h_1\\bigr)}.\n$$\n\n请使用以下测试套件。在所有情况下，参数均为 $a=1.0$、$b=0.5$、$c=0.75$、$d=0.25$，并且在 $I(x,y)$ 中使用自然对数。所有时间单位都是任意但一致的，不涉及角度。\n\n- 测试用例A（一般情况，中等步长）：$(x_0,y_0)=(1.5,1.0)$，$T=20.0$，$h=0.1$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例B（一般情况，较小步长）：$(x_0,y_0)=(1.5,1.0)$，$T=20.0$，$h=0.05$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例C（使用A和B计算观测误差阶）：设 $h_1=0.1$ 和 $h_2=0.05$，初始条件为 $(x_0,y_0)=(1.5,1.0)$ 且 $T=20.0$。使用在这些相同参数下，由 $h_1$ 和 $h_2$ 得到的 $\\Delta I$ 值来计算 $p$。以浮点数形式输出标量 $p$。\n- 测试用例D（平衡点初始条件）：$(x_0,y_0)=(c/d,\\,a/b)$，$T=9.0$，$h=0.3$。以浮点数形式输出标量 $\\Delta I$。\n- 测试用例E（时间边界条件）：$(x_0,y_0)=(1.2,0.8)$，$T=0.0$，$h=0.1$。以浮点数形式输出标量 $\\Delta I$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [A,B,C,D,E]。列表中的每个浮点数在打印前必须四舍五入到 $10$ 位小数，例如 $[0.1234567890,0.0000000000,2.0000000000,0.0000000000,0.0000000000]$。", "solution": "所呈现的问题是计算物理学中一个适定的初值问题，要求对Lotka-Volterra方程进行数值积分。该问题在科学上是合理的，内部一致，并包含了获得唯一解所需的所有必要信息。验证标准已满足。\n\n该系统由描述两个相互作用种群 $x(t)$ 和 $y(t)$ 的一对自治常微分方程（ODEs）定义：\n$$\n\\frac{dx}{dt} = x(a - by)\n$$\n$$\n\\frac{dy}{dt} = y(-c + dx)\n$$\n其中 $a, b, c, d$ 是正实数参数。该系统可以写成向量形式 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(\\mathbf{u})$，其中 $\\mathbf{u}(t) = [x(t), y(t)]^T$，向量场 $\\mathbf{f}$ 由下式给出：\n$$\n\\mathbf{f}(\\mathbf{u}) = \\begin{pmatrix} x(a - by) \\\\ y(-c + dx) \\end{pmatrix}\n$$\n问题要求使用显式中点法和一个固定的时间步长 $h$，将解从时间 $t=0$ 时的初始状态 $\\mathbf{u}_0 = (x_0, y_0)$ 推进到最终时间 $t=T$。显式中点法是一种二阶龙格-库塔格式，其将解从时间 $t_n$ 时的 $\\mathbf{u}_n$ 推进到时间 $t_{n+1} = t_n + h$ 时的 $\\mathbf{u}_{n+1}$ 的步骤如下：\n\n1. 计算第一阶段，即当前点 $\\mathbf{u}_n$ 处的斜率：\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{u}_n)\n$$\n2. 使用 $\\mathbf{k}_1$ 估计时间中点 $t_n + h/2$ 处的状态：\n$$\n\\mathbf{u}_{\\text{mid}} = \\mathbf{u}_n + \\frac{h}{2} \\mathbf{k}_1\n$$\n3. 计算第二阶段，即估计的中点状态 $\\mathbf{u}_{\\text{mid}}$ 处的斜率：\n$$\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{u}_{\\text{mid}})\n$$\n4. 使用中点斜率 $\\mathbf{k}_2$ 计算最终状态 $\\mathbf{u}_{n+1}$：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n$$\n重复此过程共 $N = T/h$ 步，以获得 $\\mathbf{u}(T) = [x(T),y(T)]^T$ 的数值近似解。\n\n问题指出Lotka-Volterra系统拥有一个守恒量：\n$$\nI(x,y) = dx - c\\ln(x) + by - a\\ln(y)\n$$\n对于一个精确解 $(x(t), y(t))$，$I(x(t), y(t))$ 保持不变。然而，诸如显式中点法之类的数值方法通常不能精确地保持这类不变量。数值不变量随时间的变化是衡量该方法误差的一个指标。我们被要求计算最终时间 $T$ 时的绝对漂移 $\\Delta I$：\n$$\n\\Delta I = |I(x(T), y(T)) - I(x_0, y_0)|\n$$\n对于一个 $p$ 阶方法，其全局误差预计按 $O(h^p)$ 的比例变化。对于非辛积分器，守恒量的漂移 $\\Delta I(h)$ 也应表现出这种缩放行为。观测到的收敛阶 $p$ 可以通过两个不同步长 $h_1$ 和 $h_2$ 的结果，使用以下公式计算：\n$$\np = \\frac{\\ln(\\Delta I(h_2) / \\Delta I(h_1))}{\\ln(h_2 / h_1)}\n$$\n\n所提供的测试用例分析如下：\n- **用例A和B**：这是使用不同步长（$h=0.1$ 和 $h=0.05$）的标准数值积分。$\\Delta I$ 的结果将为非零值。\n- **用例C**：这需要根据用例A和B的结果计算观测阶 $p$。由于显式中点法是二阶方法（$p_{theory}=2$），结果应接近于 $2$。\n- **用例D**：初始条件 $(x_0, y_0) = (c/d, a/b)$ 对应于系统的非平凡不动点（或平衡点），在该点处 $dx/dt = 0$ 且 $dy/dt = 0$。对于一个相容的数值方法，如果模拟从一个不动点开始，它应该在所有时间内都保持在该点（在机器精度范围内）。因此，$(x(T), y(T)) = (x_0, y_0)$，我们期望 $\\Delta I = 0$。\n- **用例E**：积分的时间区间长度为零（$T=0$）。没有进行时间步进，因此最终状态与初始状态相同。因此，$(x(T), y(T)) = (x_0, y_0)$，我们期望 $\\Delta I = 0$。\n\n将实现以下算法：\n1. 对于每个测试用例，获取参数 $a, b, c, d$ 和初始/最终条件 $x_0, y_0, T, h$。\n2. 实现一个函数 `run_simulation`，该函数使用显式中点法执行时间步进循环。\n3. 实现一个函数 `I(x, y, ...)` 来计算守恒量。\n4. 对于用例A、B、D和E，通过首先计算初始值 $I(x_0, y_0)$，然后运行模拟以找到 $(x_T, y_T)$，计算最终值 $I(x_T, y_T)$，并取其绝对差来计算 $\\Delta I$。\n5. 对于用例C，使用从用例A和B计算出的 $\\Delta I$ 值来计算 $p$。\n6. 收集所有结果，将它们格式化为 $10$ 位小数，并以指定的列表格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra problem for the given test cases.\n    \"\"\"\n    \n    # Define problem parameters\n    a, b, c, d = 1.0, 0.5, 0.75, 0.25\n\n    # Define the test cases from the problem statement.\n    # Format: (x0, y0, T, h)\n    test_cases = [\n        (1.5, 1.0, 20.0, 0.1),        # Case A\n        (1.5, 1.0, 20.0, 0.05),       # Case B\n        # Case C is derived from A and B\n        (c / d, a / b, 9.0, 0.3),     # Case D\n        (1.2, 0.8, 0.0, 0.1),         # Case E\n    ]\n\n    def conserved_quantity(x, y, a, b, c, d):\n        \"\"\"Computes the conserved quantity I(x, y).\"\"\"\n        return d * x - c * np.log(x) + b * y - a * np.log(y)\n\n    def run_simulation(x0, y0, T, h, a, b, c, d):\n        \"\"\"\n        Advances the Lotka-Volterra system using the explicit midpoint method.\n        \"\"\"\n        if T == 0.0:\n            return float(x0), float(y0)\n\n        num_steps = int(np.round(T / h))\n        x, y = float(x0), float(y0)\n\n        for _ in range(num_steps):\n            # Stage 1: Slope at current point\n            k1x = x * (a - b * y)\n            k1y = y * (-c + d * x)\n            \n            # State at midpoint\n            x_mid = x + 0.5 * h * k1x\n            y_mid = y + 0.5 * h * k1y\n\n            # Stage 2: Slope at midpoint\n            k2x = x_mid * (a - b * y_mid)\n            k2y = y_mid * (-c + d * x_mid)\n\n            # Update step using midpoint slope\n            x += h * k2x\n            y += h * k2y\n            \n        return x, y\n\n    # List to store final computed values for [A, B, C, D, E]\n    results = []\n    \n    # Store delta_I for cases A and B to use for C\n    delta_I_ab = []\n\n    # Process cases A and B\n    for params in test_cases[:2]:\n        x0, y0, T, h = params\n        I0 = conserved_quantity(x0, y0, a, b, c, d)\n        xT, yT = run_simulation(x0, y0, T, h, a, b, c, d)\n        IT = conserved_quantity(xT, yT, a, b, c, d)\n        delta_I = np.abs(IT - I0)\n        results.append(delta_I)\n        delta_I_ab.append(delta_I)\n\n    # Process case C (Observed order p)\n    h1 = test_cases[0][3]  # h from Case A\n    h2 = test_cases[1][3]  # h from Case B\n    delta_I_h1 = delta_I_ab[0]\n    delta_I_h2 = delta_I_ab[1]\n    \n    # The order p is calculated using the drift values from A and B\n    p = np.log(delta_I_h2 / delta_I_h1) / np.log(h2 / h1)\n    results.append(p)\n    \n    # Process cases D and E\n    for params in test_cases[2:]:\n        x0, y0, T, h = params\n        I0 = conserved_quantity(x0, y0, a, b, c, d)\n        xT, yT = run_simulation(x0, y0, T, h, a, b, c, d)\n        IT = conserved_quantity(xT, yT, a, b, c, d)\n        delta_I = np.abs(IT - I0)\n        results.append(delta_I)\n    \n    # Final print statement in the exact required format.\n    # Each float is rounded to 10 decimal places.\n    formatted_results = [f\"{val:.10f}\" for val in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2413563"}, {"introduction": "固定步长的求解器在简单问题上表现良好，但对于解在不同区域变化速度差异很大的问题，其效率低下。自适应步长控制是现代数值求解器的基石，它能动态调整步长以在满足精度要求的同时最小化计算成本。在这个练习中，你将通过比较单步和双步（步长减半）的结果来估计局部误差，并实现一个控制器来自动调整步长，从而将你的中点法求解器升级为一个更智能、更高效的工具。[@problem_id:2413547]", "problem": "您的任务是编写一个完整的、可运行的程序，该程序使用显式中点法和一个自适应步长控制器来积分一个标量常微分方程（ODE）。该控制器基于比较大小为 $h$ 的一个步长与大小为 $h/2$ 的两个步长的结果。考虑一个标量ODE，其形式为 $y'(t) = f(t,y)$，初始条件为 $y(t_0) = y_0$，其中 $t$ 是时间，$y$ 是状态变量。\n\n您的程序必须实现以下数学规范：\n\n- 对于步长 $h$，显式中点法的单步更新为\n$$\n\\Phi_h(t,y) \\equiv y + h \\, f\\!\\left(t + \\frac{h}{2},\\, y + \\frac{h}{2} f(t,y)\\right).\n$$\n\n- 将单次全步长近似定义为 $y_h = \\Phi_h(t,y)$。通过首先计算 $y_{h/2}^{(1)} = \\Phi_{h/2}(t,y)$，然后计算 $y_{h/2}^{(2)} = \\Phi_{h/2}(t + h/2,\\, y_{h/2}^{(1)})$ 来定义两次半步长的组合。使用 $y_{h/2}^{(2)}$ 作为该步结束时更高质量的近似值。\n\n- 对于大小为 $h$ 的步长，局部误差估计由下式给出\n$$\n\\mathrm{err} = \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{2^2 - 1}.\n$$\n\n- 对于给定的绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$，定义标量接受阈值\n$$\n\\tau = \\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\!\\big(\\lvert y_h \\rvert,\\, \\lvert y_{h/2}^{(2)} \\rvert\\big).\n$$\n如果 $\\mathrm{err} \\le \\tau$，则接受该步。当一个步被接受时，推进 $(t,y) \\leftarrow (t+h,\\, y_{h/2}^{(2)})$。\n\n- 在每次尝试步进后（无论接受或拒绝），根据控制器更新步长\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left(s \\left(\\frac{\\tau}{\\mathrm{err}}\\right)^{1/3},\\, \\alpha_{\\min},\\, \\alpha_{\\max}\\right),\n$$\n其中 $s$ 是一个安全因子，指数 $1/3$ 源于二阶方法的主局部误差阶数为 $h^3$，而 $\\mathrm{clip}(x, a, b)$ 将 $x$ 约束在区间 $[a,b]$ 内。如果 $\\mathrm{err} = 0$，则使用最大增长因子，即将乘法项设置为 $\\alpha_{\\max}$。通过在必要时截断最后一步，确保 $h$ 永远不会越过目标最终时间，从而精确到达最终时间 $t_{\\mathrm{end}}$。任何三角函数中出现的角度都必须解释为弧度。\n\n- 使用固定的控制器参数 $s = 0.9$，$\\alpha_{\\min} = 0.2$，$\\alpha_{\\max} = 5.0$，以及最小步长 $h_{\\min} = 10^{-16}$。如果在到达 $t_{\\mathrm{end}}$ 之前 $h$ 小于 $h_{\\min}$，则终止积分并返回当前的近似值。\n\n实现该积分器，并将其应用于以下测试套件。每个测试用例都指定了 $f(t,y)$、$t_0$、$y_0$、$t_{\\mathrm{end}}$、初始步长 $h_0$、$\\mathrm{rtol}$ 和 $\\mathrm{atol}$。所有数值都是无单位的。所有角度都以弧度为单位。\n\n- 测试用例 1（指数衰减）：\n  - $f(t,y) = -2\\, y$,\n  - $t_0 = 0$,\n  - $y_0 = 1$,\n  - $t_{\\mathrm{end}} = 1$,\n  - $h_0 = 0.1$,\n  - $\\mathrm{rtol} = 10^{-8}$,\n  - $\\mathrm{atol} = 10^{-12}$.\n\n- 测试用例 2（单位承载能力的逻辑斯谛增长）：\n  - $f(t,y) = y \\, (1 - y)$,\n  - $t_0 = 0$,\n  - $y_0 = 0.2$,\n  - $t_{\\mathrm{end}} = 5$,\n  - $h_0 = 0.2$,\n  - $\\mathrm{rtol} = 10^{-7}$,\n  - $\\mathrm{atol} = 10^{-12}$.\n\n- 测试用例 3（带三角函数强迫项的线性方程）：\n  - $f(t,y) = \\cos(t) - y$,\n  - $t_0 = 0$,\n  - $y_0 = 0$,\n  - $t_{\\mathrm{end}} = 4$,\n  - $h_0 = 0.1$,\n  - $\\mathrm{rtol} = 10^{-9}$,\n  - $\\mathrm{atol} = 10^{-12}$.\n\n- 测试用例 4（快速指数衰减）：\n  - $f(t,y) = -50\\, y$,\n  - $t_0 = 0$,\n  - $y_0 = 1$,\n  - $t_{\\mathrm{end}} = 0.1$,\n  - $h_0 = 0.05$,\n  - $\\mathrm{rtol} = 10^{-6}$,\n  - $\\mathrm{atol} = 10^{-12}$.\n\n您的程序必须按所列顺序运行所有四个测试用例，并对每个用例返回 $y(t_{\\mathrm{end}})$ 的数值近似值。最终输出必须是单行，包含一个 Python 风格的列表，其中包含四个结果的小数值，每个值四舍五入到恰好 $10$ 位小数，并按测试套件的顺序排列，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个小数点后有 $10$ 位数字的浮点数。您的程序必须以这种格式精确地产生一行输出，并且不得读取任何输入。", "solution": "所述问题是有效的。它提出了一个在计算物理学中明确定义的任务：使用带有自适应步长控制器的显式中点法对标量常微分方程（ODE）进行数值积分。该问题在科学上是合理的、自洽的，并且所有参数和数学关系都得到了明确的规定。我现在将提供解决方案。\n\n求解形式为 $y'(t) = f(t,y)$ 且初始条件为 $y(t_0) = y_0$ 的 ODE 的基本挑战是使用离散的点序列来近似 $y(t)$ 的连续轨迹。自适应步长积分器优于固定步长积分器，因为它会调整步长 $h$ 以保持所需的精度水平，同时最小化计算量，在解变化迅速的区域采用小步长，在解平滑的区域采用大步长。\n\n该积分器的核心是显式中点法，一种二阶 Runge-Kutta 方法。对于从时间 $t$到 $t+h$ 的一步，状态 $y$ 使用单步更新函数 $\\Phi_h(t,y)$ 进行推进：\n$$\n\\Phi_h(t,y) = y + h \\, f\\!\\left(t + \\frac{h}{2},\\, y + \\frac{h}{2} f(t,y)\\right)\n$$\n这个公式可以解释为一个两阶段过程。首先，在区间的中点 $t+h/2$ 处估计一个中间状态。其次，使用这个中点的斜率在整个区间 $h$ 上进行外推。\n\n为了自适应地控制步长，我们需要一个局部截断误差的估计——即单步中产生的误差。问题指定了一种步长加倍的方法。在这种方法中，我们用两种方式计算在 $t+h$ 处的解：\n1. 大小为 $h$ 的单步，得到 $y_h = \\Phi_h(t,y)$。\n2. 两个连续的大小为 $h/2$ 的步长，得到 $y_{h/2}^{(2)} = \\Phi_{h/2}(t + h/2, \\Phi_{h/2}(t,y))$。\n\n由于显式中点法的局部截断误差为 $O(h^3)$ 阶，精确解 $y(t+h)$ 可以与我们的数值近似相关联：\n$$\ny_h = y(t+h) + C h^3 + O(h^4)\n$$\n$$\ny_{h/2}^{(2)} = y(t+h) + 2 C (h/2)^3 + O(h^4) = y(t+h) + \\frac{1}{4} C h^3 + O(h^4)\n$$\n其中 $C$ 是一个与解的导数相关的常数。通过将这两个方程相减，我们可以消除未知的真值 $y(t+h)$，并解出误差项 $\\frac{1}{4} C h^3$，这正是更精确的两步近似 $y_{h/2}^{(2)}$ 的误差。该误差的量级估计为：\n$$\n\\mathrm{err} = \\lvert y(t+h) - y_{h/2}^{(2)} \\rvert \\approx \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{2^p - 1} = \\frac{\\lvert y_{h/2}^{(2)} - y_h \\rvert}{3}\n$$\n其中 $p=2$ 是方法的阶数。\n\n然后将此误差估计与期望的容差阈值 $\\tau$ 进行比较，该阈值是绝对容差 $\\mathrm{atol}$ 和相对容差 $\\mathrm{rtol}$ 的组合：\n$$\n\\tau = \\mathrm{atol} + \\mathrm{rtol} \\cdot \\max\\!\\big(\\lvert y_h \\rvert,\\, \\lvert y_{h/2}^{(2)} \\rvert\\big)\n$$\n如果 $\\mathrm{err} \\le \\tau$，则接受该步，并使用更精确的近似将状态推进到 $(t+h, y_{h/2}^{(2)})$。如果 $\\mathrm{err}  \\tau$，则拒绝该步，并从同一点 $(t,y)$ 用更小的步长重新尝试该步。\n\n下一次尝试的步长（无论当前步是否被接受或拒绝）由一个比例-积分（PI）控制器公式确定：\n$$\nh_{\\mathrm{new}} = h \\cdot \\mathrm{clip}\\!\\left(s \\left(\\frac{\\tau}{\\mathrm{err}}\\right)^{1/(p+1)},\\, \\alpha_{\\min},\\, \\alpha_{\\max}\\right)\n$$\n这里，$s=0.9$ 是一个旨在提高稳定性的安全因子。对于我们的二阶方法，指数为 $1/(p+1)=1/3$。比率 $\\tau/\\mathrm{err}$ 用于缩放步长：如果误差小于容差，则增加步长；如果误差大于容差，则减小步长。$\\mathrm{clip}$ 函数，其最小和最大因子分别为 $\\alpha_{\\min}=0.2$ 和 $\\alpha_{\\max}=5.0$，可防止步长发生过于剧烈的变化。如果 $\\mathrm{err}=0$，则将步长乘以最大因子 $\\alpha_{\\max}$。\n\n完整的积分算法流程如下：\n初始化 $t=t_0$，$y=y_0$，以及初始步长 $h=h_0$。循环直到 $t$ 到达 $t_{\\mathrm{end}}$：\n1.  检查当前步是否会超过 $t_{\\mathrm{end}}$。如果是，则设置 $h = t_{\\mathrm{end}} - t$。\n2.  进入当前步尝试的内循环。\n3.  检查当前 $h$ 是否低于最小阈值 $h_{\\min}$。如果是，则终止积分。\n4.  计算 $y_h$ 和 $y_{h/2}^{(2)}$。\n5.  计算误差 $\\mathrm{err}$ 和容差 $\\tau$。\n6.  如果步被接受 ($\\mathrm{err} \\le \\tau$)：\n    a. 推进状态：$t \\leftarrow t+h$，$y \\leftarrow y_{h/2}^{(2)}$。\n    b. 使用控制器公式计算下一步的步长 $h_{\\mathrm{new}}$。更新 $h \\leftarrow h_{\\mathrm{new}}$。\n    c. 退出内循环，继续进行下一个积分步。\n7.  如果步被拒绝 ($\\mathrm{err}  \\tau$)：\n    a. 计算一个新的、更小的步长 $h_{\\mathrm{new}}$。更新 $h \\leftarrow h_{\\mathrm{new}}$。\n    b. 重复内循环，从同一点 $(t,y)$ 使用更小的 $h$ 重新尝试该步。\n\n重复此过程直到 $t=t_{\\mathrm{end}}$，此时 $y$ 的最终值即为所需的数值解。该算法将为四个指定的测试用例中的每一个实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_midpoint_integrator(f, t0, y0, t_end, h0, rtol, atol):\n    \"\"\"\n    Integrates a scalar ODE y'(t) = f(t,y) using an adaptive explicit midpoint method.\n\n    Args:\n        f (callable): The function f(t, y).\n        t0 (float): Initial time.\n        y0 (float): Initial state.\n        t_end (float): Final time.\n        h0 (float): Initial step size.\n        rtol (float): Relative tolerance.\n        atol (float): Absolute tolerance.\n\n    Returns:\n        float: The numerical approximation of y(t_end).\n    \"\"\"\n    \n    # --- Controller parameters ---\n    S = 0.9          # Safety factor\n    ALPHA_MIN = 0.2  # Minimum step size scaling factor\n    ALPHA_MAX = 5.0  # Maximum step size scaling factor\n    H_MIN = 1e-16    # Minimum allowed step size\n\n    # --- One-step explicit midpoint update function ---\n    def phi(t_n, y_n, h_n, func):\n        \"\"\"Computes one step of the explicit midpoint method.\"\"\"\n        k1 = func(t_n, y_n)\n        y_mid = y_n + 0.5 * h_n * k1\n        t_mid = t_n + 0.5 * h_n\n        k2 = func(t_mid, y_mid)\n        return y_n + h_n * k2\n\n    # --- Initial conditions ---\n    t = float(t0)\n    y = float(y0)\n    h = float(h0)\n    \n    # --- Main integration loop ---\n    while t  t_end:\n        # Ensure the final step lands exactly on t_end\n        if t + h > t_end:\n            h = t_end - t\n\n        # --- Adaptive step control loop (accept/reject) ---\n        while True:\n            # Check for termination due to excessively small step size\n            if h  H_MIN:\n                return y \n\n            # Calculate one full step\n            y_h = phi(t, y, h, f)\n\n            # Calculate two half steps\n            h_half = h / 2.0\n            y_half_1 = phi(t, y, h_half, f)\n            y_half_2 = phi(t + h_half, y_half_1, h_half, f)\n\n            # Estimate local error\n            # Denominator is (2^p - 1) where p=2 for midpoint method\n            error_diff = abs(y_half_2 - y_h)\n            err = error_diff / 3.0\n\n            # Calculate tolerance threshold\n            y_scale = max(abs(y_h), abs(y_half_2))\n            tau = atol + rtol * y_scale\n\n            # Check for step acceptance\n            if err = tau:\n                # --- Step accepted ---\n                t += h\n                y = y_half_2  # Use the more accurate result\n                \n                # Calculate step size for the next step\n                if err == 0.0:\n                    factor = ALPHA_MAX\n                else:\n                    factor = S * (tau / err)**(1.0/3.0)\n                \n                # Clip factor and update h\n                h = h * min(ALPHA_MAX, max(ALPHA_MIN, factor))\n                \n                # Exit the inner loop to proceed to the next t\n                break\n            else:\n                # --- Step rejected ---\n                # Calculate a new, smaller step size and retry this step\n                if err == 0.0:\n                    # Should not be reached if err > tau, but for robustness\n                    factor = ALPHA_MIN\n                else:\n                    factor = S * (tau / err)**(1.0/3.0)\n                \n                # Clip the reducing factor and update h for the retry\n                h_new = h * min(ALPHA_MAX, max(ALPHA_MIN, factor))\n                h = h_new\n\n    return y\n\ndef solve():\n    \"\"\"\n    Runs the adaptive midpoint integrator on a suite of test cases and\n    prints the results in the specified format.\n    \"\"\"\n    test_cases = [\n        # Test case 1 (exponential decay)\n        {\n            \"f\": lambda t, y: -2.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"t_end\": 1.0,\n            \"h0\": 0.1,\n            \"rtol\": 1e-8,\n            \"atol\": 1e-12,\n        },\n        # Test case 2 (logistic growth)\n        {\n            \"f\": lambda t, y: y * (1.0 - y),\n            \"t0\": 0.0,\n            \"y0\": 0.2,\n            \"t_end\": 5.0,\n            \"h0\": 0.2,\n            \"rtol\": 1e-7,\n            \"atol\": 1e-12,\n        },\n        # Test case 3 (linear equation with trigonometric forcing)\n        {\n            \"f\": lambda t, y: np.cos(t) - y,\n            \"t0\": 0.0,\n            \"y0\": 0.0,\n            \"t_end\": 4.0,\n            \"h0\": 0.1,\n            \"rtol\": 1e-9,\n            \"atol\": 1e-12,\n        },\n        # Test case 4 (fast exponential decay)\n        {\n            \"f\": lambda t, y: -50.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"t_end\": 0.1,\n            \"h0\": 0.05,\n            \"rtol\": 1e-6,\n            \"atol\": 1e-12,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        final_y = adaptive_midpoint_integrator(\n            f=case[\"f\"],\n            t0=case[\"t0\"],\n            y0=case[\"y0\"],\n            t_end=case[\"t_end\"],\n            h0=case[\"h0\"],\n            rtol=case[\"rtol\"],\n            atol=case[\"atol\"],\n        )\n        results.append(final_y)\n\n    # Format the final output string as required\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2413547"}]}