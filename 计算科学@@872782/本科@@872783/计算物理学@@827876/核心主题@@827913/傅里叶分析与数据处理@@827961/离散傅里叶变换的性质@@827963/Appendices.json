{"hands_on_practices": [{"introduction": "在信号处理中，理解时域中的操作（如信号的拉伸或压缩）如何影响频域是至关重要的。这项练习提供了一种动手实践的方式，通过数值方法验证离散傅里叶变换（DFT）的这些重要尺度变换性质[@problem_id:2431109]。通过亲手实现并测试这些关系，你将加深对时域-频域对偶性的理解。", "problem": "你的任务是验证一个序列的离散傅里叶变换（DFT）与该序列在离散时间意义上被压缩或拉伸后的版本的DFT之间的精确关系。只处理有限长度序列和如下定义的DFT。所有索引均为整数，所有变换都作为有限和精确计算。\n\n离散傅里叶变换（DFT）的定义：对于一个长度为 $N$ 的序列 $x[n]$，其DFT $X[k]$ 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-j \\, 2\\pi \\, k \\, n / N}, \\quad k=0,1,\\dots,N-1,\n$$\n逆DFT为\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{j \\, 2\\pi \\, k \\, n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n\n定义序列上的以下三种操作：\n\n1. 离散时间扩展（$L$ 倍上采样）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个整数 $L \\ge 1$，定义一个长度为 $N' = L N$ 的序列 $y_{\\text{exp}}[n]$ 如下\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx\\!\\left[\\dfrac{n}{L}\\right],  \\text{如果 } n \\text{ 是 } L \\text{ 的倍数}, \\\\\n0,  \\text{否则},\n\\end{cases}\n\\quad n=0,1,\\dots,N'-1.\n$$\n\n2. 离散时间压缩（$M$ 倍下采样）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个能整除 $N$ 的整数 $M \\ge 1$，定义一个长度为 $Q = N/M$ 的序列 $y_{\\text{comp}}[n]$ 如下\n$$\ny_{\\text{comp}}[n] = x[M n], \\quad n=0,1,\\dots,Q-1.\n$$\n\n3. 模 $N$ 循环索引缩放（$a$ 与 $N$ 互质）：给定一个长度为 $N$ 的序列 $x[n]$ 和一个整数 $a$ 使得 $\\gcd(a,N)=1$，定义一个长度为 $N$ 的序列 $y_{\\text{circ}}[n]$ 如下\n$$\ny_{\\text{circ}}[n] = x[(a n) \\bmod N], \\quad n=0,1,\\dots,N-1.\n$$\n\n你的程序必须直接根据上述定义验证以下性质，复数值相等的数值绝对容差为 $\\varepsilon = 10^{-9}$：\n\n- 扩展性质：如果 $Y_{\\text{exp}}[k]$ 是长度为 $N' = L N$ 的 $y_{\\text{exp}}[n]$ 的DFT，而 $X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，那么\n$$\nY_{\\text{exp}}[k] = X[k \\bmod N], \\quad k=0,1,\\dots,N'-1.\n$$\n\n- 压缩性质：如果 $Y_{\\text{comp}}[k]$ 是长度为 $Q = N/M$ 的 $y_{\\text{comp}}[n]$ 的DFT，而 $X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，那么\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + r Q], \\quad k=0,1,\\dots,Q-1,\n$$\n其中 $X[\\cdot]$ 的所有索引都取在 $0$ 到 $N-1$ 的范围内，且 $Q = N/M$ 是一个整数。\n\n- 循环索引缩放性质：如果 $Y_{\\text{circ}}[k]$ 是长度为 $N$ 的 $y_{\\text{circ}}[n]$ 的DFT，而 $X[k]$ 是长度为 $N$ 的 $x[n]$ 的DFT，那么\n$$\nY_{\\text{circ}}[k] = X[(k \\, a^{-1}) \\bmod N], \\quad k=0,1,\\dots,N-1,\n$$\n其中 $a^{-1}$ 是 $a$ 模 $N$ 的乘法逆元（即 $a \\, a^{-1} \\equiv 1 \\pmod{N}$）。\n\n测试套件。对于每个测试，计算必要的DFT，并通过检查两边的最大绝对差值最多为 $\\varepsilon = 10^{-9}$ 来验证相应的性质。为每个测试用例生成一个布尔结果。\n\n- 测试 1 (扩展，一般情况): $N=8$，$L=3$，$x[n] = \\cos\\!\\left(2\\pi \\cdot 1 \\cdot n / 8\\right) + \\tfrac{1}{2}\\sin\\!\\left(2\\pi \\cdot 2 \\cdot n / 8\\right)$，对于 $n=0,1,\\dots,7$。\n\n- 测试 2 (压缩，一般情况): $N=12$，$M=3$，$x[n] = (-1)^n + \\tfrac{1}{4} n$，对于 $n=0,1,\\dots,11$。\n\n- 测试 3 (边界，单位缩放): $N=10$，$a=1$。定义 $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$，对于 $n=0,1,\\dots,9$。同时验证 $L=1$ 的扩展性质和 $M=1$ 的压缩性质；当且仅当两个验证都在容差 $\\varepsilon$ 内成功时，测试结果为真。\n\n- 测试 4 (循环缩放，互质因子): $N=10$，$a=3$ 且 $\\gcd(3,10)=1$。定义 $x[n] = \\cos\\!\\left(2\\pi \\cdot 4 \\cdot n / 10\\right) + \\sin\\!\\left(2\\pi \\cdot 3 \\cdot n / 10\\right)$，对于 $n=0,1,\\dots,9$。\n\n最终输出格式。你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,result4]\"）。每个结果必须是与上面列出的测试顺序相对应的布尔值。输出行中不允许有额外的文本或空白。此问题不涉及物理单位；所有量都是无量纲的实数或复数。三角函数中的角度以弧度为单位。", "solution": "问题陈述已经过验证，并被认定为有效。它具有科学依据，问题定义良好，客观且自洽。该问题涉及在数字信号处理和计算物理学背景下，验证离散傅里叶变换（DFT）的标准、既定性质。定义、操作和声称的性质都以数学精度陈述，并且在理论上是健全的。我们现在开始解答。\n\n问题的核心是验证与时域缩放操作相关的三个DFT性质：扩展（上采样）、压缩（下采样）和循环索引缩放。根据严谨性要求，我们将首先为每个性质提供简要的分析证明，然后概述数值验证的步骤。\n\n设 $x[n]$ 为一个长度为 $N$ 的序列，其DFT为 $X[k] = \\sum_{n=0}^{N-1} x[n] e^{-j 2\\pi k n / N}$，其中 $j = \\sqrt{-1}$。\n\n**1. 扩展性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$，长度为 $N' = LN$ 的扩展序列 $y_{\\text{exp}}[n]$ 定义为：\n$$\ny_{\\text{exp}}[n] = \n\\begin{cases}\nx[n/L],  \\text{如果 } n \\text{ 是 } L \\text{ 的倍数}, \\\\\n0,  \\text{否则}.\n\\end{cases}\n$$\n需要验证的性质是 $Y_{\\text{exp}}[k] = X[k \\bmod N]$，对于 $k=0, 1, \\dots, N'-1$。\n\n**推导：**\n$y_{\\text{exp}}[n]$ 的DFT由下式给出：\n$$\nY_{\\text{exp}}[k] = \\sum_{n=0}^{N'-1} y_{\\text{exp}}[n] e^{-j 2\\pi k n / N'}\n$$\n由于 $y_{\\text{exp}}[n]$ 仅在 $n$ 是 $L$ 的倍数时非零，我们可以代入 $n = mL$，其中 $m$ 的范围是从 $0$ 到 $N-1$：\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} y_{\\text{exp}}[mL] e^{-j 2\\pi k (mL) / (LN)}\n$$\n根据 $y_{\\text{exp}}$ 的定义，$y_{\\text{exp}}[mL] = x[m]$。将此代入方程中：\n$$\nY_{\\text{exp}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k m / N}\n$$\n右边是 $x[n]$ 的DFT的定义，我们记为 $X[\\cdot]$ 在频率索引 $k$ 处的值。DFT $X[k]$ 天然具有周期性，周期为 $N$，意味着对于任何整数 $a$，都有 $X[k] = X[k+aN]$。因此，对于任何 $k$，该表达式等价于 $X[k \\bmod N]$。所以，性质 $Y_{\\text{exp}}[k] = X[k \\bmod N]$ 是正确的。\n\n**2. 压缩性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$ 和一个能整除 $N$ 的整数 $M$，长度为 $Q = N/M$ 的压缩序列 $y_{\\text{comp}}[n]$ 定义为 $y_{\\text{comp}}[n] = x[Mn]$，对于 $n=0, 1, \\dots, Q-1$。\n需要验证的性质是 $Y_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k + rQ]$，对于 $k=0, 1, \\dots, Q-1$。\n\n**推导：**\n我们从 $x[n]$ 的逆DFT表达式开始，并将其代入 $y_{\\text{comp}}[n]$ 的定义中：\n$$\ny_{\\text{comp}}[n] = x[Mn] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p (Mn) / N}\n$$\n因为 $N = MQ$，这可以简化为：\n$$\ny_{\\text{comp}}[n] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q}\n$$\n现在，我们计算 $y_{\\text{comp}}[n]$ 的DFT：\n$$\nY_{\\text{comp}}[k] = \\sum_{n=0}^{Q-1} y_{\\text{comp}}[n] e^{-j 2\\pi k n / Q} = \\sum_{n=0}^{Q-1} \\left( \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] e^{j 2\\pi p n / Q} \\right) e^{-j 2\\pi k n / Q}\n$$\n重排求和顺序：\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{p=0}^{N-1} X[p] \\left( \\sum_{n=0}^{Q-1} e^{j 2\\pi (p-k) n / Q} \\right)\n$$\n内层和是一个几何级数和，如果 $p-k$ 是 $Q$ 的倍数（即，对于某个整数 $r$，$p-k = rQ$），其值为 $Q$，否则为 $0$。因此，我们只需要对满足 $p = k + rQ$ 的 $p$ 值求和。由于 $0 \\le p  N$， $r$ 的可能取值为 $0, 1, \\dots, M-1$。\n$$\nY_{\\text{comp}}[k] = \\frac{1}{N} \\sum_{r=0}^{M-1} X[k+rQ] \\cdot Q\n$$\n由于 $Q/N = 1/M$，我们得到所求的性质：\n$$\nY_{\\text{comp}}[k] = \\frac{1}{M} \\sum_{r=0}^{M-1} X[k+rQ]\n$$\n这证实了压缩性质的正确性。\n\n**3. 循环索引缩放性质**\n\n给定一个长度为 $N$ 的序列 $x[n]$ 和一个与 $N$ 互质的整数 $a$，缩放后的序列是 $y_{\\text{circ}}[n] = x[(an) \\bmod N]$。\n需要验证的性质是 $Y_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]$，其中 $a a^{-1} \\equiv 1 \\pmod{N}$。\n\n**推导：**\n$y_{\\text{circ}}[n]$ 的DFT是：\n$$\nY_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} y_{\\text{circ}}[n] e^{-j 2\\pi k n / N} = \\sum_{n=0}^{N-1} x[(an) \\bmod N] e^{-j 2\\pi k n / N}\n$$\n由于 $\\gcd(a,N)=1$，映射 $m = (an) \\bmod N$ 是集合 $\\{0, 1, \\dots, N-1\\}$ 的一个置换。我们可以进行求和变量的替换，从 $n$ 变为 $m$。逆映射是 $n = (a^{-1}m) \\bmod N$，其中 $a^{-1}$ 是 $a$ 模 $N$ 的乘法逆元。\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k ((a^{-1}m) \\bmod N) / N}\n$$\n由于复指数的周期性，$e^{-j 2\\pi \\theta} = e^{-j 2\\pi (\\theta \\bmod 1)}$，如果我们让 $a^{-1}_{int}$ 是逆元在 $\\{1, \\dots, N-1\\}$ 中的整数表示，我们就可以移除指数分子中的模运算：\n$$\nY_{\\text{circ}}[k] = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi k (a^{-1}_{int} m) / N} = \\sum_{m=0}^{N-1} x[m] e^{-j 2\\pi (k a^{-1}_{int}) m / N}\n$$\n这个表达式正是在频率索引 $k' = (k a^{-1}_{int}) \\bmod N$ 处求值的 $x[m]$ 的DFT。\n$$\nY_{\\text{circ}}[k] = X[(k a^{-1}) \\bmod N]\n$$\n因此，该性质在分析上是正确的。\n\n**数值验证步骤：**\n对于每个测试用例，验证遵循一致的步骤：\n1.  根据给定公式生成长度为 $N$ 的基础信号 $x[n]$。\n2.  使用标准的快速傅里叶变换（FFT）算法（如 `numpy.fft.fft` 提供的那样）计算其DFT $X[k]$。\n3.  根据其定义构造变换后的信号（$y_{\\text{exp}}$、$y_{\\text{comp}}$ 或 $y_{\\text{circ}}$）。\n4.  计算变换后信号的DFT（$Y_{\\text{exp}}$、$Y_{\\text{comp}}$ 或 $Y_{\\text{circ}}$）。这构成了恒等式的左侧（LHS）。\n5.  使用预先计算的 $X[k]$ 和指定公式构造恒等式的右侧（RHS）。\n6.  计算复数值LHS和RHS数组之间的最大绝对差值：$\\max_k | \\text{LHS}[k] - \\text{RHS}[k] |$。\n7.  如果此差值小于或等于指定的容差 $\\varepsilon = 10^{-9}$，则认为该性质已得到验证。\n\n此过程应用于问题陈述中描述的四个测试用例中的每一个。对于测试3，对于平凡情况（$L=1$, $M=1$），扩展和压缩性质的验证必须都成功，整个测试才为真。测试4所需的模乘法逆元使用 `pow(a, -1, N)` 计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT properties verification problem.\n    \"\"\"\n    epsilon = 1e-9\n    results = []\n\n    # Test 1: Expansion property\n    def test_1():\n        N = 8\n        L = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 1 * n / N) + 0.5 * np.sin(2 * np.pi * 2 * n / N)\n        X = np.fft.fft(x)\n\n        N_prime = L * N\n        y_exp = np.zeros(N_prime, dtype=np.float64)\n        for n_prime in range(N_prime):\n            if n_prime % L == 0:\n                y_exp[n_prime] = x[n_prime // L]\n        \n        # LHS: DFT of the expanded sequence\n        Y_exp_lhs = np.fft.fft(y_exp)\n\n        # RHS: Periodically repeated original DFT\n        Y_exp_rhs = np.zeros(N_prime, dtype=np.complex128)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        \n        max_diff = np.max(np.abs(Y_exp_lhs - Y_exp_rhs))\n        return max_diff = epsilon\n\n    results.append(test_1())\n\n    # Test 2: Compression property\n    def test_2():\n        N = 12\n        M = 3\n        n = np.arange(N)\n        x = (-1)**n + 0.25 * n\n        X = np.fft.fft(x)\n\n        Q = N // M\n        y_comp = x[::M]\n        \n        # LHS: DFT of the compressed sequence\n        Y_comp_lhs = np.fft.fft(y_comp)\n        \n        # RHS: Sum of aliased components\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        \n        max_diff = np.max(np.abs(Y_comp_lhs - Y_comp_rhs))\n        return max_diff = epsilon\n\n    results.append(test_2())\n\n    # Test 3: Boundary cases (L=1, M=1)\n    def test_3():\n        N = 10\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n\n        # Part A: Expansion with L=1\n        L = 1\n        N_prime = L * N\n        y_exp = x # y_exp is just x\n        Y_exp_lhs = np.fft.fft(y_exp)\n        k_prime = np.arange(N_prime)\n        Y_exp_rhs = X[k_prime % N]\n        check_L1 = np.max(np.abs(Y_exp_lhs - Y_exp_rhs)) = epsilon\n\n        # Part B: Compression with M=1\n        M = 1\n        Q = N // M\n        y_comp = x # y_comp is just x\n        Y_comp_lhs = np.fft.fft(y_comp)\n        Y_comp_rhs = np.zeros(Q, dtype=np.complex128)\n        for k in range(Q):\n            for r in range(M):\n                Y_comp_rhs[k] += X[k + r * Q]\n        Y_comp_rhs /= M\n        check_M1 = np.max(np.abs(Y_comp_lhs - Y_comp_rhs)) = epsilon\n        \n        return check_L1 and check_M1\n\n    results.append(test_3())\n\n    # Test 4: Circular index scaling property\n    def test_4():\n        N = 10\n        a = 3\n        n = np.arange(N)\n        x = np.cos(2 * np.pi * 4 * n / N) + np.sin(2 * np.pi * 3 * n / N)\n        X = np.fft.fft(x)\n        \n        # In Python 3.8+, pow(a, -1, m) computes modular inverse\n        a_inv = pow(a, -1, N)\n\n        y_circ = np.zeros(N, dtype=np.float64)\n        for n_val in range(N):\n            y_circ[n_val] = x[(a * n_val) % N]\n\n        # LHS: DFT of the circularly scaled sequence\n        Y_circ_lhs = np.fft.fft(y_circ)\n\n        # RHS: Permuted original DFT\n        Y_circ_rhs = np.zeros(N, dtype=np.complex128)\n        for k in range(N):\n            Y_circ_rhs[k] = X[(k * a_inv) % N]\n        \n        max_diff = np.max(np.abs(Y_circ_lhs - Y_circ_rhs))\n        return max_diff = epsilon\n\n    results.append(test_4())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431109"}, {"introduction": "在快速傅里叶变换（FFT）分析中，时域补零是一种获得更高“分辨率”频谱的常用技巧。本练习将通过编程实践揭示，这一过程在数学上等同于对原始DFT样本进行狄利克雷核（Dirichlet kernel）插值[@problem_id:2431114]。完成这项练习有助于你深刻理解补零操作的真正作用，避免对结果产生误读。", "problem": "给定一个长度为 $N$ 的有限长度离散时间信号 $x_n$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。定义其长度为 $N$ 的离散傅里叶变换 (DFT) $X^{(N)}_k$ 为\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k \\in \\{0,1,\\dots,N-1\\}。\n$$\n定义长度为 $M$ 的补零序列 $\\tilde{x}_n$ 为\n$$\n\\tilde{x}_n = \\begin{cases}\nx_n,  0 \\le n \\le N-1,\\\\\n0,  N \\le n \\le M-1,\n\\end{cases}\n$$\n及其长度为 $M$ 的离散傅里叶变换 $X^{(M)}_r$ 为\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M}, \\quad r \\in \\{0,1,\\dots,M-1\\}。\n$$\n你的程序必须仅使用第一性原理（离散傅里叶变换及其逆变换的定义），来展示时域补零所引起的 $X^{(M)}_r$ 与 $N$ 点谱 $X^{(N)}_k$ 之间的精确关系。对于下面的每个测试用例，针对同一对 $(N,M)$ 和序列 $x_n$ 计算两个量：\n(1) 通过离散傅里叶变换的定义，直接从补零序列中获得的长度为 $M$ 的谱；以及\n(2) 完全用 $X^{(N)}_k$ 以及离散傅里叶变换及其逆变换所蕴含的基本有限和来表示的长度为 $M$ 的谱。\n然后，为每个测试用例返回这两个谱在所有索引 $r \\in \\{0,1,\\dots,M-1\\}$ 上的最大绝对差，以浮点小数形式表示。\n\n测试套件：\n- 情况 A (一般复合实正弦波)：$N=16$， $M=128$，以及对于所有满足 $0 \\le n \\le 15$ 的整数 $n$，$x_n = \\cos\\!\\left(2\\pi \\cdot 3.5 \\, n / 16\\right) + 0.6 \\, \\sin\\!\\left(2\\pi \\cdot 5 \\, n / 16\\right)$。\n- 情况 B (克罗内克δ函数)：$N=9$，$M=27$，当 $n=0$ 时 $x_n=1$，否则 $x_n=0$，其中 $0 \\le n \\le 8$。\n- 情况 C (谱箱中心的复指数)：$N=10$，$M=100$，以及对于 $0 \\le n \\le 9$，$x_n = e^{i 2\\pi \\cdot 3 \\, n / 10}$。\n- 情况 D (非正弦，含交变分量)：$N=12$，$M=50$，以及对于 $0 \\le n \\le 11$，$x_n = (n+1)/12 + 0.1\\,(-1)^n$。\n\n不涉及物理单位。角度以弧度为单位。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[resultA,resultB,resultC,resultD]”）。每个条目必须是对应情况下的最大绝对差，以浮点数表示。", "solution": "设给定 $x_n$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。其长度为 $N$ 的离散傅里叶变换 (DFT) 是\n$$\nX^{(N)}_k = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi k n / N}, \\quad k=0,1,\\dots,N-1.\n$$\n在此约定下，逆离散傅里叶变换 (IDFT) 是\n$$\nx_n = \\frac{1}{N}\\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}, \\quad n=0,1,\\dots,N-1.\n$$\n定义长度为 $M \\ge N$ 的补零序列 $\\tilde{x}_n$，当 $0 \\le n \\le N-1$ 时 $\\tilde{x}_n=x_n$，当 $N \\le n \\le M-1$ 时 $\\tilde{x}_n=0$。其长度为 $M$ 的 DFT 是\n$$\nX^{(M)}_r = \\sum_{n=0}^{M-1} \\tilde{x}_n \\, e^{-i 2\\pi r n / M} = \\sum_{n=0}^{N-1} x_n \\, e^{-i 2\\pi r n / M}, \\quad r=0,1,\\dots,M-1,\n$$\n因为当 $n \\ge N$ 时 $\\tilde{x}_n=0$。代入 $x_n$ 的逆 DFT 表达式：\n$$\nX^{(M)}_r = \\sum_{n=0}^{N-1} \\left(\\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, e^{i 2\\pi k n / N}\\right) e^{-i 2\\pi r n / M}\n= \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\sum_{n=0}^{N-1} e^{i 2\\pi n \\left(\\frac{k}{N} - \\frac{r}{M}\\right)}.\n$$\n内部的有限几何和是复指数形式的狄利克雷核：\n$$\nD_N(\\alpha) \\equiv \\sum_{n=0}^{N-1} e^{i 2\\pi n \\alpha}\n= e^{i \\pi \\alpha (N-1)} \\, \\frac{\\sin(\\pi N \\alpha)}{\\sin(\\pi \\alpha)},\n$$\n其连续性扩展为 $D_N(0)=N$，这是通过取极限 $\\alpha \\to 0$ 得到的。因此，\n$$\nX^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right).\n$$\n这表明 $X^{(M)}_r$ 是通过使用狄利克雷核（即周期sinc函数）对长度为 $N$ 的 DFT 采样值 $X^{(N)}_k$ 进行插值得到的。换句话说，对时域序列进行补零，会在频域中产生更精细的采样，这等同于对粗略的 DFT 采样值进行狄利克雷（周期sinc）插值。对于所有整数 $N \\ge 1$ 和 $M \\ge N$ 以及所有序列 $x_n$，该恒等式都是精确成立的。\n\n基于上述原理的算法计划：\n- 通过离散傅里叶变换的定义，直接从补零的时域序列计算 $X^{(M)}_r$（可通过标准的快速傅里叶变换实现，其在计算上与定义等价）。\n- 另外，为原始的长度为 $N$ 的序列计算 $X^{(N)}_k$，然后构造\n$$\n\\widehat{X}^{(M)}_r = \\frac{1}{N} \\sum_{k=0}^{N-1} X^{(N)}_k \\, D_N\\!\\left(\\frac{k}{N}-\\frac{r}{M}\\right),\n$$\n其中 $D_N(\\alpha)$ 可以通过有限和定义或上述带有在 $\\alpha=0$ 处的连续性扩展的闭合形式进行求值。\n- 对于每个测试用例，报告\n$$\n\\max_{0 \\le r \\le M-1} \\left| X^{(M)}_r - \\widehat{X}^{(M)}_r \\right|\n$$\n以浮点小数形式。\n\n由于该恒等式是精确的，所报告的最大绝对差预计将处于浮点舍入误差的水平（对于双精度计算，其量级通常在 $10^{-15}$ 到 $10^{-13}$ 左右，与机器精度相当），包括在 $\\frac{k}{N}-\\frac{r}{M}=0$ 的索引处，此时必须使用极限 $D_N(0)=N$。该测试套件涵盖：\n- 一般复合实正弦波（情况 A），\n- 克罗内克δ函数（情况 B），\n- 谱箱中心的复指数（情况 C），\n- 带有交变分量的非正弦序列（情况 D）。\n在所有情况下，最大差异在数值上应可忽略不计，从而验证时域补零对应于频域中的狄利克雷（周期sinc）插值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dirichlet_kernel(N: int, alpha: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute D_N(alpha) = sum_{n=0}^{N-1} exp(i 2π n alpha)\n    using the closed-form expression with robust handling at alpha=0.\n\n    Parameters:\n        N: int, sequence length\n        alpha: ndarray of floats, same shape as output\n\n    Returns:\n        ndarray of complex128 with same shape as alpha\n    \"\"\"\n    alpha = np.asarray(alpha, dtype=np.float64)\n    # Compute using closed-form: e^{iπ alpha (N-1)} * sin(π N alpha) / sin(π alpha)\n    numer = np.sin(np.pi * N * alpha)\n    denom = np.sin(np.pi * alpha)\n\n    # General case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        kernel = np.exp(1j * np.pi * alpha * (N - 1)) * (numer / denom)\n\n    # Handle alpha near integer multiples (here only near 0 under our alpha range) where denom ~ 0\n    # Limit as alpha - 0 is N.\n    mask = np.isclose(denom, 0.0, atol=1e-12)\n    if np.any(mask):\n        kernel = kernel.astype(np.complex128, copy=False)\n        kernel[mask] = N + 0j\n    return kernel\n\ndef zero_padded_spectrum_direct(x: np.ndarray, M: int) - np.ndarray:\n    \"\"\"\n    Compute the M-point DFT of x zero-padded to length M.\n    \"\"\"\n    N = x.shape[0]\n    padded = np.zeros(M, dtype=np.complex128)\n    padded[:N] = x.astype(np.complex128)\n    return np.fft.fft(padded, n=M)\n\ndef spectrum_interpolated_from_XN(x: np.ndarray, M: int) - np.ndarray:\n    \"\"\"\n    Compute the M-point spectrum from the N-point spectrum X^{(N)}_k\n    using the Dirichlet-kernel interpolation identity:\n        X^{(M)}_r = (1/N) sum_k X^{(N)}_k D_N(k/N - r/M)\n    \"\"\"\n    N = x.shape[0]\n    XN = np.fft.fft(x, n=N)  # X^{(N)}_k\n    # Build alpha grid: shape (M, N) for r in [0..M-1], k in [0..N-1]\n    r = np.arange(M, dtype=np.float64).reshape(-1, 1)  # (M,1)\n    k = np.arange(N, dtype=np.float64).reshape(1, -1)  # (1,N)\n    alpha = k / N - r / M                              # (M,N)\n    D = dirichlet_kernel(N, alpha)                     # (M,N)\n    X_interp = (D @ XN) / N                            # (M,)\n    return X_interp\n\ndef max_abs_diff_between_methods(x: np.ndarray, M: int) - float:\n    \"\"\"\n    Compute max_r |X_zp(r) - X_interp(r)| as a float.\n    \"\"\"\n    X_direct = zero_padded_spectrum_direct(x, M)\n    X_interp = spectrum_interpolated_from_XN(x, M)\n    diff = np.abs(X_direct - X_interp)\n    return float(np.max(diff))\n\ndef make_test_cases():\n    \"\"\"\n    Construct the test cases as specified in the problem statement.\n    Returns a list of tuples (x, M) with x as np.ndarray (complex128) of length N.\n    \"\"\"\n    cases = []\n\n    # Case A: N=16, M=128, x_n = cos(2π*3.5*n/16) + 0.6*sin(2π*5*n/16)\n    N_A, M_A = 16, 128\n    nA = np.arange(N_A, dtype=np.float64)\n    xA = np.cos(2.0 * np.pi * 3.5 * nA / N_A) + 0.6 * np.sin(2.0 * np.pi * 5.0 * nA / N_A)\n    cases.append((xA.astype(np.complex128), M_A))\n\n    # Case B: N=9, M=27, Kronecker delta at n=0\n    N_B, M_B = 9, 27\n    xB = np.zeros(N_B, dtype=np.complex128)\n    xB[0] = 1.0 + 0.0j\n    cases.append((xB, M_B))\n\n    # Case C: N=10, M=100, x_n = exp(i 2π*3*n/10)\n    N_C, M_C = 10, 100\n    nC = np.arange(N_C, dtype=np.float64)\n    xC = np.exp(1j * 2.0 * np.pi * 3.0 * nC / N_C)\n    cases.append((xC.astype(np.complex128), M_C))\n\n    # Case D: N=12, M=50, x_n = (n+1)/12 + 0.1*(-1)^n\n    N_D, M_D = 12, 50\n    nD = np.arange(N_D, dtype=np.float64)\n    xD = (nD + 1.0) / 12.0 + 0.1 * ((-1.0) ** nD)\n    cases.append((xD.astype(np.complex128), M_D))\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = make_test_cases()\n\n    results = []\n    for x, M in test_cases:\n        result = max_abs_diff_between_methods(x, M)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2431114"}, {"introduction": "在许多物理应用中，我们处理的信号都是实数信号，其离散傅里叶变换具有一种特殊的对称性。本练习旨在挑战你利用这种埃尔米特对称性（Hermitian symmetry）来构建一个计算效率更高的实数信号FFT算法[@problem_id:2431155]。掌握这种优化技巧是实用科学计算中的一项关键能力。", "problem": "给定一个长度为偶数 $N$ 的实值离散时间信号 $x[n]$。$x[n]$ 的离散傅里叶变换 (DFT) 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi i\\, kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n其中 $i$ 表示虚数单位，所有角度均以弧度为单位。对于实数 $x[n]$，DFT 满足埃尔米特对称性，因此其信息内容完全由唯一的半谱所捕获\n$$\nH[k] = X[k],\\quad k=0,1,\\dots,N/2,\n$$\n其中 $N$ 为偶数。\n\n编写一个完整的程序，针对下面列出的每个测试用例，通过两种独立的方式计算给定长度为 $N$ 的实数输入序列 $x[n]$ 的半谱 $H[k]$：\n- 通过您选择的任何正确算法计算实数输入的唯一半谱。\n- 通过直接应用离散傅里叶变换的定义求和来计算 $k=0,1,\\dots,N/2$ 的 $X[k]$。\n\n对于每个测试用例，您的程序必须输出一个浮点数，该数等于两个半谱在所有 $k \\in \\{0,1,\\dots,N/2\\}$ 上的最大绝对差。\n\n角度必须以弧度为单位进行解释。每个结果在打印前必须四舍五入到 $10^{-12}$。\n\n测试套件（每个用例指定一个偶数长度 $N$ 和一个实数序列 $x[n]$）：\n- 用例 1: $N=8$, $x[n] = \\cos\\!\\big(2\\pi\\cdot 2\\, n/N\\big)$ for $n=0,1,\\dots,N-1$。\n- 用例 2: $N=10$, $x[n] = \\sin\\!\\big(2\\pi\\cdot 3\\, n/N\\big) + 0.5\\,\\cos\\!\\big(2\\pi\\cdot 1\\, n/N\\big)$ for $n=0,1,\\dots,N-1$。\n- 用例 3: $N=16$, $x[n] = \\delta_{n,0}$ (克罗内克 delta)，即 $x[0]=1$ 且对于 $n=1,2,\\dots,N-1$ 有 $x[n]=0$。\n- 用例 4: $N=16$, 对于所有 $n=0,1,\\dots,N-1$，有 $x[n] = 1$。\n- 用例 5: $N=2$, $x[0]=1$, $x[1]=-1$。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到 $10^{-12}$ 并以小数点后有 $12$ 位的科学记数法打印，例如，“[a,b,c]”，其中 a,b,c 均遵循此数值格式。", "solution": "对于长度为偶数 $N$ 的输入序列 $x[n]$，其离散傅里叶变换 (DFT) 定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi i\\, kn/N},\\quad k=0,1,\\dots,N-1.\n$$\n当 $x[n]$ 为实值时，DFT 表现出埃尔米特对称性，即对于所有 $k$，$X[N-k] = \\overline{X[k]}$，其中上划线表示复共轭。因此，唯一的光谱信息包含在半谱中\n$$\nH[k] = X[k],\\quad k=0,1,\\dots,N/2.\n$$\n问题要求对每个测试用例进行两次独立的 $H[k]$ 计算：\n- 一种是通过对 $\\{0,1,\\dots,N/2\\}$ 中的每个 $k$ 求和，直接从上述定义推导。\n- 另一种是通过对实数输入产生相同 $H[k]$ 的正确算法获得。\n\n一种有原则且高效的构造方法可以从第一性原理推导得出，即通过将 DFT 分解为偶数和奇数索引部分。设 $N$ 为偶数，定义 $M=N/2$。将 $x[n]$ 分割为偶数和奇数子序列 $x_e[n]=x[2n]$ 和 $x_o[n]=x[2n+1]$，其中 $n=0,1,\\dots,M-1$。定义 $M$ 点 DFT\n$$\nE[k] = \\sum_{n=0}^{M-1} x_e[n]\\, e^{-2\\pi i\\, kn/M},\\quad\nO[k] = \\sum_{n=0}^{M-1} x_o[n]\\, e^{-2\\pi i\\, kn/M},\\quad k=0,1,\\dots,M-1.\n$$\n通过代入 DFT 定义，$x[n]$ 的 $N$ 点 DFT 满足以下条件，对于 $k=0,1,\\dots,M-1$：\n$$\nX[k] = E[k] + W_N^k O[k] \\quad \\text{和} \\quad X[k+M] = E[k] - W_N^k O[k],\n$$\n其中 $W_N = e^{-2\\pi i / N}$ 是第 $N$ 个本原单位根。半谱是 $X[k]$，对于 $k=0,1,\\dots,M$，其中端点 $k=M$ 由周期性得出，如下所示：\n$$\nX[M] = E[0] - O[0],\n$$\n因为 $W_N^M = e^{-\\pi i} = -1$，并且根据这些 $M$ 点 DFT 的 $M$ 周期性，有 $E[M]=E[0]$，$O[M]=O[0]$。\n\n为了将变换次数减少到一次 $M$ 点变换，将偶数和奇数部分组合成一个单一的复数序列\n$$\ny[n] = x_e[n] + i\\, x_o[n],\\quad n=0,1,\\dots,M-1,\n$$\n并计算其 $M$ 点 DFT\n$$\nY[k] = \\sum_{n=0}^{M-1} y[n]\\, e^{-2\\pi i\\, kn/M} = E[k] + i\\, O[k].\n$$\n利用离散傅里叶变换的性质和实数输入的共轭对称性，我们还有\n$$\n\\overline{Y[(M-k)\\bmod M]} = E[k] - i\\, O[k],\\quad k=0,1,\\dots,M-1.\n$$\n求解 $E[k]$ 和 $O[k]$ 可得\n$$\nE[k] = \\tfrac{1}{2}\\big(Y[k] + \\overline{Y[(M-k)\\bmod M]}\\big),\\qquad\nO[k] = -\\tfrac{i}{2}\\big(Y[k] - \\overline{Y[(M-k)\\bmod M]}\\big).\n$$\n因此，对于 $k=1,2,\\dots,M-1$，\n$$\nX[k] = E[k] + W_N^k\\, O[k] = \\tfrac{1}{2}\\big(Y[k] + \\overline{Y[M-k]}\\big) - \\tfrac{i}{2} W_N^k \\big(Y[k] - \\overline{Y[M-k]}\\big).\n$$\n端点由 $Y[0] = E[0] + i\\, O[0]$ 得出：\n$$\nX[0] = E[0] + O[0] = \\operatorname{Re}\\{Y[0]\\} + \\operatorname{Im}\\{Y[0]\\},\\qquad\nX[M] = E[0] - O[0] = \\operatorname{Re}\\{Y[0]\\} - \\operatorname{Im}\\{Y[0]\\}.\n$$\n这种构造通过单次 $M$ 点复数 DFT 和代数后处理来计算精确的半谱，完全从 DFT 定义和实数数据的对称性推导而来。\n\n为了验证，直接从定义计算参考半谱：\n$$\nH_{\\text{ref}}[k] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2\\pi i\\, kn/N},\\quad k=0,1,\\dots,M.\n$$\n对每个测试用例，计算\n$$\n\\varepsilon = \\max_{0\\le k\\le M} \\left| H[k] - H_{\\text{ref}}[k] \\right|,\n$$\n将 $\\varepsilon$ 四舍五入到 $10^{-12}$，并报告它。\n\n测试套件涵盖了几个重要的行为：单个频率仓的余弦信号 ($N=8$)、多个频率仓的正弦分量之和 ($N=10$)、一个脉冲信号 ($N=16$)、一个常数信号 ($N=16$)，以及最小的偶数长度情况 ($N=2$)。这些用例测试了埃尔米特对称性的端点、内部频率仓和边界条件。最终程序构造每个 $x[n]$，按所述计算两种半谱，评估最大绝对偏差，四舍五入到 $10^{-12}$，并以指定的单个带括号列表格式打印结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef r2c_half_spectrum_via_half_fft(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the unique half-spectrum H[k] = X[k], k=0..N/2, for real x of even length N,\n    using a single complex FFT of length N/2 and post-processing.\n    \"\"\"\n    x = np.asarray(x, dtype=np.float64)\n    N = x.size\n    if N % 2 != 0 or N == 0:\n        raise ValueError(\"Input length must be a positive even integer.\")\n    M = N // 2\n\n    # Pack even and odd samples into a complex sequence y[n] = x[2n] + i x[2n+1]\n    y = x[0::2] + 1j * x[1::2]  # length M\n\n    # Compute M-point complex FFT\n    Y = np.fft.fft(y)\n\n    # Allocate half-spectrum H[0..M] (complex-valued)\n    H = np.empty(M + 1, dtype=np.complex128)\n\n    # Endpoints from Y[0] = E0 + i O0\n    E0 = Y[0].real\n    O0 = Y[0].imag\n    H[0] = (E0 + O0) + 0j\n    H[M] = (E0 - O0) + 0j\n\n    # Interior bins 1..M-1\n    # Twiddle factor W_N^k = exp(-2π i k / N)\n    for k in range(1, M):\n        a = Y[k]\n        b = np.conj(Y[M - k])\n        E = 0.5 * (a + b)\n        O = (-0.5j) * (a - b)\n        W = np.exp(-2j * np.pi * k / N)\n        H[k] = E + W * O\n\n    return H\n\ndef dft_half_spectrum_direct(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the unique half-spectrum directly from the DFT definition:\n    H[k] = sum_{n=0}^{N-1} x[n] * exp(-2π i k n / N), for k = 0..N/2.\n    \"\"\"\n    x = np.asarray(x, dtype=np.float64)\n    N = x.size\n    if N % 2 != 0 or N == 0:\n        raise ValueError(\"Input length must be a positive even integer.\")\n    M = N // 2\n    n = np.arange(N, dtype=np.float64)\n    H = np.empty(M + 1, dtype=np.complex128)\n    for k in range(M + 1):\n        H[k] = np.sum(x * np.exp(-2j * np.pi * k * n / N))\n    return H\n\ndef max_abs_diff_half(x: np.ndarray) - float:\n    \"\"\"\n    Compute the maximum absolute difference between the half-spectrum computed via\n    the half-length complex FFT method and the direct DFT definition.\n    \"\"\"\n    H_fft = r2c_half_spectrum_via_half_fft(x)\n    H_dir = dft_half_spectrum_direct(x)\n    diff = np.max(np.abs(H_fft - H_dir))\n    # Round to 1e-12 as required\n    return float(np.round(diff, 12))\n\ndef build_test_cases():\n    cases = []\n\n    # Case 1: N=8, x[n] = cos(2π * 2 n / N)\n    N1 = 8\n    n1 = np.arange(N1, dtype=np.float64)\n    x1 = np.cos(2.0 * np.pi * 2.0 * n1 / N1)\n    cases.append(x1)\n\n    # Case 2: N=10, x[n] = sin(2π * 3 n / N) + 0.5*cos(2π * 1 n / N)\n    N2 = 10\n    n2 = np.arange(N2, dtype=np.float64)\n    x2 = np.sin(2.0 * np.pi * 3.0 * n2 / N2) + 0.5 * np.cos(2.0 * np.pi * 1.0 * n2 / N2)\n    cases.append(x2)\n\n    # Case 3: N=16, impulse at n=0\n    N3 = 16\n    x3 = np.zeros(N3, dtype=np.float64)\n    x3[0] = 1.0\n    cases.append(x3)\n\n    # Case 4: N=16, constant ones\n    N4 = 16\n    x4 = np.ones(N4, dtype=np.float64)\n    cases.append(x4)\n\n    # Case 5: N=2, [1, -1]\n    x5 = np.array([1.0, -1.0], dtype=np.float64)\n    cases.append(x5)\n\n    return cases\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = build_test_cases()\n\n    results = []\n    for x in test_cases:\n        result = max_abs_diff_half(x)\n        results.append(result)\n\n    # Final print statement in the exact required format:\n    # comma-separated floats in scientific notation with 12 digits after the decimal.\n    formatted = \",\".join(f\"{v:.12e}\" for v in results)\n    print(f\"[{formatted}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2431155"}]}