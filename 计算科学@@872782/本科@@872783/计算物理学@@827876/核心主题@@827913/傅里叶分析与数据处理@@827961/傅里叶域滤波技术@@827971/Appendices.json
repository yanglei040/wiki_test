{"hands_on_practices": [{"introduction": "许多真实世界的时间序列，如金融数据或物理实验读数，都包含缓慢变化的趋势，这些趋势可能会掩盖我们感兴趣的高频波动。傅里叶域滤波提供了一种优雅的方法来分离这些不同的成分。本练习将通过一个高通滤波器来移除信号的低频趋势，从而让你亲手实践信号处理中的一个核心应用。[@problem_id:2395589]", "problem": "考虑一个在 $N$ 个等间隔采样点上定义的实值离散时间信号\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right), \\quad n = 0,1,\\dots,N-1,\n$$\n其中所有角度均以弧度为单位。设 $N = 1024$，$a_0 = 2.0$，$a_1 = 0.5$，$a_2 = -1.0$，$A_1 = 1.0$，$A_2 = 0.5$，$m_1 = 40$，$m_2 = 160$。定义 $N$ 个采样点的离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT) 如下\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}, \\quad k = 0,1,\\dots,N-1,\n$$\n$$\nx[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}, \\quad n = 0,1,\\dots,N-1.\n$$\n设索引 $k$ 对应的频率（单位为周/采样点）为\n$$\nf[k] = \\begin{cases}\n\\frac{k}{N}, & 0 \\le k \\le \\frac{N}{2},\\\\\n-\\frac{N-k}{N}, & \\frac{N}{2}  k \\le N-1.\n\\end{cases}\n$$\n一个截止频率为 $f_c$ （单位为周/采样点）的理想高通滤波器在傅里叶域中由以下掩模指定\n$$\nM[k] = \\begin{cases}\n1,  |f[k]| \\ge f_c,\\\\\n0,  |f[k]|  f_c,\n\\end{cases}\n\\quad k = 0,1,\\dots,N-1.\n$$\n将此滤波器应用于 $x[n]$，通过以下方式产生滤波后的信号 $y[n]$\n$$\nY[k] = M[k] \\, X[k], \\quad y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}.\n$$\n将滤波后信号 $y[n]$ 的波动性度量定义为总体标准差\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n].\n$$\n您的任务是为以下五个测试截止频率计算 $\\sigma$：\n- 测试 $1$：$f_c = 0$，\n- 测试 $2$：$f_c = 0.02$，\n- 测试 $3$：$f_c = 0.10$，\n- 测试 $4$：$f_c = 0.50$，\n- 测试 $5$：$f_c = \\frac{m_1}{N}$。\n\n所有量均为无量纲。所有三角函数中的角度必须以弧度为单位进行解释。每个测试中 $\\sigma$ 的最终数值答案必须四舍五入到恰好 $6$ 位小数。\n\n您的程序应生成单行输出，其中包含五个四舍五入后的值，形式为方括号括起来的逗号分隔列表（例如，$\"[v_1,v_2,v_3,v_4,v_5]\"$），其中每个 $v_j$ 是按上述顺序排列的测试 $j$ 的四舍五入值。", "solution": "问题陈述已解析和验证。\n\n### 步骤 1：提取已知条件\n- **信号定义**：$x[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)$，对于 $n = 0,1,\\dots,N-1$。\n- **参数**：$N = 1024$，$a_0 = 2.0$，$a_1 = 0.5$，$a_2 = -1.0$，$A_1 = 1.0$，$A_2 = 0.5$，$m_1 = 40$，$m_2 = 160$。\n- **离散傅里叶变换 (DFT)**：$X[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}$。\n- **离散傅里叶逆变换 (IDFT)**：$x[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} X[k] \\, e^{i 2\\pi \\frac{k n}{N}}$。\n- **频率映射**：$f[k] = \\frac{k}{N}$ 对于 $0 \\le k \\le \\frac{N}{2}$，以及 $f[k] = -\\frac{N-k}{N}$ 对于 $\\frac{N}{2}  k \\le N-1$。\n- **滤波器掩模**：如果 $|f[k]| \\ge f_c$ 则 $M[k] = 1$，如果 $|f[k]|  f_c$ 则 $M[k] = 0$。\n- **滤波操作**：$Y[k] = M[k] \\, X[k]$，然后是 $y[n] = \\text{IDFT}(Y[k])$。\n- **波动性度量**：$\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}$，其中 $\\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]$。这是滤波后信号 $y[n]$ 的总体标准差。\n- **截止频率 $f_c$ 的测试用例**：\n  1. $f_c = 0$\n  2. $f_c = 0.02$\n  3. $f_c = 0.10$\n  4. $f_c = 0.50$\n  5. $f_c = \\frac{m_1}{N}$\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定且客观的。它描述了数字信号处理中的一个标准流程：对离散信号应用频域滤波器。所有常数和函数都定义清晰。DFT/IDFT 的定义和频率映射是计算库中使用的标准约定。任务是数值实现此流程。不存在违反科学原理、矛盾或歧义之处。\n\n### 步骤 3：结论与行动\n该问题是有效的。将提供一个解决方案。\n\n### 解题推导\n该问题要求计算滤波后信号 $y[n]$ 在几个高通滤波器截止频率 $f_c$ 下的波动性，波动性定义为总体标准差 $\\sigma$。该过程涉及数字信号处理中的一系列标准操作。\n\n**1. 信号生成**\n首先，在 $N=1024$ 个采样点上合成离散时间信号 $x[n]$。该信号是一个二次多项式和两个正弦波的叠加：\n$$\nx[n] = a_0 + a_1 \\left(\\frac{n}{N}\\right) + a_2 \\left(\\frac{n}{N}\\right)^2 + A_1 \\sin\\!\\left(2\\pi \\frac{m_1 n}{N}\\right) + A_2 \\sin\\!\\left(2\\pi \\frac{m_2 n}{N}\\right)\n$$\n多项式分量代表低频内容，而正弦分量对应于离散频率 $f_1 = m_1/N = 40/1024 \\approx 0.039$ 周/采样点和 $f_2 = m_2/N = 160/1024 \\approx 0.156$ 周/采样点。\n\n**2. 傅里叶变换**\n使用离散傅里叶变换 (DFT) 将信号变换到频域，以获得其频谱 $X[k]$。\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i 2\\pi \\frac{k n}{N}}\n$$\n在数值上，这可以使用快速傅里叶变换 (FFT) 算法高效计算。\n\n**3. 频域滤波**\n在频域中应用高通滤波器。这是通过将信号的频谱 $X[k]$ 与滤波器掩模 $M[k]$ 进行逐元素相乘来实现的。\n$$\nY[k] = M[k] \\, X[k]\n$$\n掩模 $M[k]$ 是基于频率向量 $f[k]$ 和截止频率 $f_c$ 定义的。$f[k]$ 的定义对应于 FFT 输出中频率排序的标准约定，其中正频率之后是负频率。该掩模设计用于通过绝对值大于或等于 $f_c$ 的频率：\n$$\nM[k] = \\begin{cases}\n1,  |f[k]| \\ge f_c \\\\\n0,  |f[k]|  f_c\n\\end{cases}\n$$\n此操作会衰减或消除低于截止频率 $f_c$ 的频率分量。\n\n**4. 傅里叶逆变换**\n通过对滤波后的频谱 $Y[k]$ 应用离散傅里叶逆变换 (IDFT)，在时域中恢复滤波后的信号 $y[n]$。\n$$\ny[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] \\, e^{i 2\\pi \\frac{k n}{N}}\n$$\n这可以使用快速傅里叶逆变换 (IFFT) 算法进行数值计算。由于原始信号 $x[n]$ 是实值的，并且滤波器掩模 $M[k]$ 是实数且对称的（即，对于 $k=1,\\dots,N/2-1$ 有 $M[k] = M[N-k]$），滤波后的频谱 $Y[k]$ 将表现出厄米对称性（$Y[k] = Y[N-k]^*$）。因此，得到的时域信号 $y[n]$ 必须是实值的。由于浮点不精确性，数值计算可能会引入可忽略的虚部，必须将其丢弃。\n\n**5. 波动性计算**\n最后，计算实值滤波信号 $y[n]$ 的波动性 $\\sigma$。这被定义为总体标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y[n] - \\mu\\right)^2}, \\quad \\text{其中} \\quad \\mu = \\frac{1}{N} \\sum_{n=0}^{N-1} y[n]\n$$\n对五个指定的 $f_c$ 值中的每一个重复此整个过程。DFT/IDFT 定义和总体标准差公式与 `numpy` 库中的默认实现一致，这简化了计算实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the volatility of a filtered signal for several cutoff frequencies.\n    \"\"\"\n    # 1. Define parameters and test cases from the problem statement.\n    N = 1024\n    a0 = 2.0\n    a1 = 0.5\n    a2 = -1.0\n    A1 = 1.0\n    A2 = 0.5\n    m1 = 40\n    m2 = 160\n\n    test_fcs_raw = [\n        0.0,\n        0.02,\n        0.10,\n        0.50,\n        m1 / N,\n    ]\n\n    # 2. Generate the time-domain signal x[n].\n    n = np.arange(N)\n    x = (a0 +\n         a1 * (n / N) +\n         a2 * (n / N)**2 +\n         A1 * np.sin(2 * np.pi * m1 * n / N) +\n         A2 * np.sin(2 * np.pi * m2 * n / N))\n\n    # 3. Compute the Discrete Fourier Transform (DFT) of the signal.\n    # The result is the spectrum X[k].\n    X = np.fft.fft(x)\n\n    # 4. Define the corresponding frequency vector f[k].\n    # np.fft.fftfreq(N, d=1) gives frequencies in cycles/sample, matching the problem.\n    f = np.fft.fftfreq(N, d=1.0)\n\n    results = []\n    # 5. Process each test case for the cutoff frequency fc.\n    for fc in test_fcs_raw:\n        # a. Create the ideal high-pass filter mask M[k].\n        # The mask is 1 where |f[k]| >= fc, and 0 otherwise.\n        mask = (np.abs(f) >= fc).astype(np.float64)\n\n        # b. Apply the filter in the frequency domain.\n        # The filtered spectrum is Y[k] = M[k] * X[k].\n        Y = X * mask\n\n        # c. Compute the Inverse DFT to get the filtered time-domain signal y[n].\n        # np.fft.ifft correctly applies the 1/N normalization.\n        y = np.fft.ifft(Y)\n        \n        # The resulting signal should be real. We take the real part to discard\n        # negligible imaginary components from floating-point errors.\n        y_real = np.real(y)\n\n        # d. Calculate the volatility (population standard deviation) of y[n].\n        # np.std calculates the population standard deviation by default.\n        sigma = np.std(y_real)\n\n        # e. Append the rounded result to the list.\n        results.append(f\"{sigma:.6f}\")\n\n    # 6. Format the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395589"}, {"introduction": "滤波并不总是各向同性的；有时我们需要在特定方向上对图像进行处理，例如，只在水平方向上进行模糊以模拟运动效果。本练习将指导你构建一个二维各向异性滤波器，它只影响水平频率分量，而不改变垂直细节。这个过程不仅能加深你对二维傅里叶空间的理解，还能揭示如何通过分析输入的特性来简化计算。[@problem_id:2395613]", "problem": "你的任务是构建并应用一个各向异性的二维傅里叶域滤波器，该滤波器仅沿水平方向执行模糊。考虑大小为 $N \\times N$（其中 $N = 128$）的离散、周期性方形场，由整数坐标 $(x,y)$ 索引，其中 $x,y \\in \\{0,1,\\dots,N-1\\}$。对于任何离散标量场 $f[x,y]$（可以是实值或复值），其二维离散傅里叶变换 (DFT) $F[u,v]$ 和逆离散傅里叶变换 $f[x,y]$ 定义如下：\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} f[x,y] \\, \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right),\n$$\n$$\nf[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} F[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\n将各向异性纯水平模糊定义为一个傅里叶域传递函数 $H[u,v]$，它仅依赖于水平角空间波数 $k_x$，而与垂直波数 $k_y$ 无关。设与列索引 $u$ 相关的角波数为 $k_x(u) = \\frac{2\\pi}{N}\\,u$，在 $2\\pi$ 周期圆上解释（角度以弧度为单位）。该滤波器为：\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right),\n$$\n其中 $\\sigma_{k_x}  0$ 是水平角波数尺度（单位为弧度/样本）。给定一个输入场 $f[x,y]$ 及其DFT $F[u,v]$，滤波后的场 $g[x,y]$ 定义为：\n$$\nG[u,v] = H[u,v]\\,F[u,v], \\qquad g[x,y] = \\frac{1}{N^2} \\sum_{u=0}^{N-1}\\sum_{v=0}^{N-1} G[u,v] \\, \\exp\\!\\left(i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right).\n$$\n你的程序必须构建并应用此滤波器，然后在一组单色平面波测试场上量化其响应。对于整数 $(f_x,f_y)$，其中 $0 \\le f_x \\le N-1$ 和 $0 \\le f_y \\le N-1$，定义单位振幅平面波：\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right).\n$$\n对于每个测试用例，令 $F$ 和 $G$ 分别为输入场和滤波后场的DFT。定义振幅比：\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}.\n$$\n所有角度必须以弧度为单位。量 $\\sigma_{k_x}$ 是一个角波数，单位为弧度/样本。\n\n测试套件（每个条目为 $(f_x,f_y,\\sigma_{k_x})$）：\n- 测试 $1$：$(0,\\,8,\\,1.2)$\n- 测试 $2$：$(8,\\,0,\\,1.2)$\n- 测试 $3$：$(12,\\,7,\\,0.3)$\n- 测试 $4$：$(64,\\,0,\\,1.2)$\n- 测试 $5$：$(23,\\,15,\\,10.0)$\n\n对于每个测试用例，构建 $f^{(f_x,f_y)}[x,y]$，应用具有给定 $\\sigma_{k_x}$ 的指定纯水平各向异性滤波器，计算如上定义的振幅比 $r$，并将其报告为浮点数。\n\n最终输出格式：你的程序应生成单行输出，其中包含五个振幅比的结果，以逗号分隔的列表形式，保留六位小数，并用方括号括起来，按测试 $1$ 到测试 $5$ 的顺序排列（例如，“[r1,r2,r3,r4,r5]”）。", "solution": "问题陈述已经过分析，被认为是有效的。它具有科学依据，是适定的、客观的且自洽的。它描述了计算物理学中傅里叶域滤波的标准应用，并为得出唯一解提供了所有必要的参数和定义。任务是计算特定单色平面波在应用了频域中的定向高斯模糊后所发生的衰减。\n\n问题的核心在于卷积定理，该定理指出空间域中的卷积等效于傅里叶域中的逐点相乘。滤波后场的离散傅里叶变换 (DFT) $G[u,v]$ 由输入场的 DFT $F[u,v]$ 与滤波器传递函数 $H[u,v]$ 的乘积给出。\n$$\nG[u,v] = H[u,v] F[u,v]\n$$\n在分析指定输入场后，问题得到了极大的简化。输入场是以下形式的单色平面波：\n$$\nf^{(f_x,f_y)}[x,y] = \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right)\n$$\n其中 $f_x$ 和 $f_y$ 是整数频率分量。让我们计算该输入场的DFT $F[u,v]$。\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\left(\\frac{f_x x}{N} + \\frac{f_y y}{N}\\right)\\right) \\exp\\!\\left(-i 2\\pi \\left(\\frac{u x}{N} + \\frac{v y}{N}\\right)\\right)\n$$\n$$\nF[u,v] = \\sum_{x=0}^{N-1}\\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right)\n$$\n$$\nF[u,v] = \\left( \\sum_{x=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_x - u)x}{N}\\right) \\right) \\left( \\sum_{y=0}^{N-1} \\exp\\!\\left(i 2\\pi \\frac{(f_y - v)y}{N}\\right) \\right)\n$$\n离散复指数的正交性表明，$\\sum_{k=0}^{N-1} \\exp(i 2\\pi jk/N)$ 在 $j$ 是 $N$ 的整数倍时等于 $N$，否则等于 $0$。由于索引 $u,v,f_x,f_y$ 都在 $\\{0, 1, \\dots, N-1\\}$ 范围内，因此项 $(f_x - u)$ 仅在 $f_x=u$ 时是 $N$ 的倍数，对于 $y$ 和 $v$ 的项也类似。因此，这些和仅在特定频率 $(u,v) = (f_x,f_y)$ 处非零。\n$$\nF[u,v] = (N \\delta_{u,f_x}) (N \\delta_{v,f_y}) = N^2 \\delta_{u,f_x} \\delta_{v,f_y}\n$$\n其中 $\\delta_{j,k}$ 是克罗内克δ函数。这表明单色平面波的DFT是在其频率对应的坐标处的一个非零单点。所有其他频率分量均为零。\n\n问题要求计算在频率 $(f_x, f_y)$ 处的振幅比 $r$：\n$$\nr = \\frac{\\lvert G[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert} = \\frac{\\lvert H[f_x,f_y] F[f_x,f_y]\\rvert}{\\lvert F[f_x,f_y]\\rvert}\n$$\n因为 $F[f_x,f_y] = N^2 \\neq 0$，我们可以将其简化为：\n$$\nr = \\lvert H[f_x,f_y]\\rvert\n$$\n这是一个关键的简化。问题简化为在输入平面波的特定频率点 $(f_x, f_y)$ 处评估传递函数的模。涉及FFT的完整数值模拟是不必要的。\n\n传递函数定义为：\n$$\nH[u,v] = \\exp\\!\\left(-\\frac{k_x(u)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\n请注意，$H[u,v]$ 与垂直频率索引 $v$ 无关。由于该函数是实数且为正，其模就是其自身。因此，比率 $r$ 为：\n$$\nr = H[f_x,f_y] = \\exp\\!\\left(-\\frac{k_x(f_x)^2}{2\\,\\sigma_{k_x}^2}\\right)\n$$\n最后一步是为给定的离散频率索引 $u$ 正确确定水平角波数 $k_x(u)$ 的值。问题将 $k_x(u) = \\frac{2\\pi u}{N}$ 定义为在 $2\\pi$ 周期圆上解释。对于大小为 $N$ 的离散网格，从 $0$ 到 $N/2$ 的频率索引表示正波数，而从 $N/2+1$ 到 $N-1$ 的索引由于混叠而表示负波数。索引 $N/2$ 对应于奈奎斯特频率，可解释为正或负 $\\pi$ 弧度/样本。标准惯例，如 NumPy 等数值库中所实现的，将 DFT 索引 $u \\in \\{0, \\dots, N-1\\}$ 映射到物理频率。对于索引 $u$，当 $0 \\le u  N/2$ 时，频率（单位：周/样本）为 $u/N$，当 $N/2 \\le u  N$ 时为 $(u-N)/N$。为了将其转换为角波数（单位：弧度/样本），我们乘以 $2\\pi$。\n给定 $N=128$，索引 $u$ 的角波数 $k_x(u)$ 可以通过离散傅里叶变换频率约定计算：\n$$\nk_x(u) = \n\\begin{cases} \n\\frac{2\\pi u}{N}  \\text{for } 0 \\le u \\le 64 \\\\\n\\frac{2\\pi (u-N)}{N}  \\text{for } 65 \\le u \\le 127\n\\end{cases}\n$$\n在实践中，用于FFT频率的标准库函数（如 `numpy.fft.fftfreq`）能正确处理此映射。与索引 $u=0,1,\\dots,N-1$ 对应的角波数向量由 $k = 2\\pi \\times \\texttt{fftfreq}(N)$ 给出。我们在计算中选择该向量在索引 $f_x$ 处的元素。\n\n对于每个测试用例 $(f_x, f_y, \\sigma_{k_x})$，我们计算：\n1. 水平角波数 $k_x(f_x)$。\n2. 比率 $r = \\exp(-k_x(f_x)^2 / (2 \\sigma_{k_x}^2))$。\n对所有五个测试用例都遵循此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and applies an anisotropic Fourier-domain filter and quantifies its response.\n    \"\"\"\n    # Define constants from the problem statement.\n    N = 128\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_x, f_y, sigma_kx)\n        (0, 8, 1.2),\n        (8, 0, 1.2),\n        (12, 7, 0.3),\n        (64, 0, 1.2),\n        (23, 15, 10.0),\n    ]\n\n    results = []\n    \n    # As derived in the solution, a full FFT simulation is not required.\n    # The amplitude ratio r is simply the value of the transfer function H[fx, fy].\n    # H[u,v] depends only on the horizontal wavenumber k_x(u).\n    # r = exp(-k_x(fx)^2 / (2 * sigma_kx^2))\n\n    # Pre-compute the array of discrete angular wavenumbers in radians per sample.\n    # The numpy.fft.fftfreq function computes the discrete frequencies in cycles/sample.\n    # We multiply by 2*pi to get angular wavenumbers in radians/sample.\n    # The array k_x_all will have entries corresponding to indices u = 0, 1, ..., N-1.\n    k_x_all = 2 * np.pi * np.fft.fftfreq(N)\n\n    for case in test_cases:\n        fx, _, sigma_kx = case\n        \n        # 1. Get the horizontal angular wavenumber k_x corresponding to the frequency index fx.\n        # This correctly handles the aliasing of frequencies beyond Nyquist.\n        kx = k_x_all[fx]\n        \n        # 2. Calculate the square of the wavenumber scale.\n        sigma_kx_sq = sigma_kx**2\n        \n        # 3. Calculate the amplitude ratio, r.\n        # The filter is Gaussian, so the expression is exp(-arg).\n        # The argument is (k_x^2) / (2 * sigma_kx^2).\n        if sigma_kx == 0:\n            # Although the problem states sigma_kx > 0, handle this case for robustness.\n            # Division by zero would occur.\n            # If kx is zero, r=1. If kx is not zero, the filter has zero width, so r=0.\n            r = 1.0 if kx == 0 else 0.0\n        else:\n            exponent = -(kx**2) / (2 * sigma_kx_sq)\n            r = np.exp(exponent)\n        \n        results.append(r)\n\n    # Format the final output as a comma-separated list of floats,\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2395613"}, {"introduction": "图像模糊是成像过程中常见的一种退化现象，而解卷积就像是为模糊过程按下的“撤销”键。本练习将带你解决一个更具挑战性的问题：从一个被噪声污染的模糊图像中恢复出清晰的原始图像，并且我们所知的模糊核（点扩散函数）本身也含有噪声。你将应用正则化技术来设计一个稳定的逆滤波器，这是处理现实世界中不适定逆问题的关键策略。[@problem_id:2395571]", "problem": "考虑一个在大小为 $N \\times N$、具有周期性边界条件（循环卷积）的方形网格上的二维离散成像模型。令 $f[m,n]$ 表示未知的清晰图像，$h[m,n]$ 表示真实的点扩散函数，$g[m,n]$ 表示观测到的图像。测量模型为\n$$\ng = f * h + \\eta,\n$$\n其中 $*$ 表示循环卷积，$\\eta[m,n]$ 是零均值加性噪声。点扩散函数无法直接获得；而是提供了一个含噪声的测量值 $\\tilde{h}[m,n]$。\n\n您的任务是通过求解以下在所有 $N \\times N$ 实数数组 $x$ 上的正则化最小二乘问题，从 $g$ 和 $\\tilde{h}$ 估计 $f$：\n$$\n\\hat{f} = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2,\n$$\n其中 $\\lambda  0$ 是给定的正则化参数。计算出 $\\hat{f}$ 后，使用均方根误差 (RMSE) 评估重建质量\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N^2}\\sum_{m=0}^{N-1}\\sum_{n=0}^{N-1}\\big(\\hat{f}[m,n] - f[m,n]\\big)^2}.\n$$\n\n按如下方式构建合成数据：\n\n1. 网格大小：$N = 128$。\n\n2. 清晰图像 $f[m,n]$：\n   - 令 $i \\in \\{0,1,\\ldots,N-1\\}$ 和 $j \\in \\{0,1,\\ldots,N-1\\}$ 分别为行和列的索引。\n   - 对于任意实数中心 $c$，在离散环面上定义环绕距离为\n     $$\n     d(i,c) = \\min\\left(\\lvert i - c\\rvert,\\, N - \\lvert i - c\\rvert\\right).\n     $$\n   - 定义两个高斯分量\n     $$\n     G_1[i,j] = \\exp\\!\\left(-\\frac{d(i,N/2)^2 + d(j,N/2)^2}{2\\sigma_1^2}\\right), \\quad \\sigma_1 = 3,\n     $$\n     $$\n     G_2[i,j] = \\exp\\!\\left(-\\frac{d(i,N/3)^2 + d(j,2N/3)^2}{2\\sigma_2^2}\\right), \\quad \\sigma_2 = 5.\n     $$\n   - 定义一个正弦分量\n     $$\n     S[i,j] = \\cos\\!\\left(2\\pi \\left(\\frac{f_x\\, i}{N} + \\frac{f_y\\, j}{N}\\right)\\right), \\quad f_x = 5,\\; f_y = 9.\n     $$\n   - 构成未缩放的图像\n     $$\n     f_0[i,j] = 0.9\\,G_1[i,j] + 0.7\\,G_2[i,j] + 0.3\\,S[i,j].\n     $$\n   - 通过最小-最大归一化到 $[0,1]$ 区间\n     $$\n     f[i,j] = \\frac{f_0[i,j] - \\min(f_0)}{\\max(f_0) - \\min(f_0)},\n     $$\n     其中 $\\min(f_0)$ 和 $\\max(f_0)$ 表示 $f_0$ 在所有网格点上的最小值和最大值。\n\n3. 真实点扩散函数 $h[m,n]$：\n   - 使用从原点开始的环绕（环面）径向距离，\n     $$\n     r(i,j) = \\sqrt{\\min(i,N-i)^2 + \\min(j,N-j)^2},\n     $$\n     定义各向同性高斯函数\n     $$\n     h[i,j] = \\exp\\!\\left(-\\frac{r(i,j)^2}{2\\sigma_h^2}\\right),\n     $$\n     然后进行归一化，使得 $\\sum_{i,j} h[i,j] = 1$。模糊宽度 $\\sigma_h$ 在下面的每个测试用例中指定。\n\n4. 含噪声的点扩散函数 $\\tilde{h}[m,n]$：\n   - 生成独立同分布的高斯噪声 $\\nu[i,j] \\sim \\mathcal{N}(0,\\sigma_p^2)$ 并设置\n     $$\n     \\tilde{h}_{\\text{raw}}[i,j] = h[i,j] + \\nu[i,j].\n     $$\n   - 通过将 $\\tilde{h}_{\\text{raw}}$ 中的所有负值条目设置为 $0$ 来强制非负性，得到 $\\tilde{h}_+[i,j]$。\n   - 重新归一化至总和为1，以获得 $\\tilde{h}[i,j] = \\tilde{h}_+[i,j]\\Big/\\sum_{m,n}\\tilde{h}_+[m,n]$。\n\n5. 观测图像 $g[m,n]$：\n   - 生成独立同分布的高斯噪声 $\\eta[i,j] \\sim \\mathcal{N}(0,\\sigma_n^2)$。\n   - 构成观测值\n     $$\n     g = f * h + \\eta,\n     $$\n     其中 $*$ 是循环卷积。\n\n6. 随机性与可复现性：\n   - 对于每个标识符为 $t \\in \\{1,2,3,4\\}$ 的测试用例，使用种子 $S_t = 123456 + t$ 初始化一个伪随机数生成器。使用此生成器为该测试用例生成所有高斯随机变量（包括 $\\nu$ 和 $\\eta$）。\n\n测试套件（四个用例），每个用例由四元组 $(\\sigma_h,\\sigma_n,\\sigma_p,\\lambda)$ 指定：\n- 用例 1 ($t=1$): $(2.0,\\,0.02,\\,0.01,\\,0.001)$。\n- 用例 2 ($t=2$): $(2.0,\\,0.08,\\,0.03,\\,0.02)$。\n- 用例 3 ($t=3$): $(0.7,\\,0.02,\\,0.05,\\,0.005)$。\n- 用例 4 ($t=4$): $(3.0,\\,0.05,\\,0.02,\\,0.02)$。\n\n对于每个测试用例，您的程序必须完全按照规定构建 $f$、$h$、$\\tilde{h}$ 和 $g$；计算给定目标的最小化器 $\\hat{f}$；然后计算相应的 $\\mathrm{RMSE}$。最终的程序输出必须是单行文本，其中包含四个 $\\mathrm{RMSE}$ 值的列表，按用例 $t=1,2,3,4$ 的顺序排列，每个值四舍五入到六位小数，形式为用方括号括起来的逗号分隔列表（例如，“[0.012345,0.067890,0.001234,0.056789]”）。不应打印任何其他文本。", "solution": "所提出的问题是计算图像复原中的一个标准练习，具体来说，是在点扩散函数存在不确定性情况下的反卷积。其目标是从一幅模糊且含噪声的观测图像 $g$ 中恢复真实图像 $f$，其中模糊核 $h$ 也仅通过一个含噪声的测量值 $\\tilde{h}$ 得知。该问题被表述为一个正则化最小二乘优化问题，这是一种处理此类不适定反问题的稳健且成熟的方法。\n\n该问题完全自洽，科学上基于线性系统和傅里叶分析的原理，并且是适定的。所有参数和过程都以足够的精度指定，以确保结果的唯一性和可复现性。因此，该问题被认为是有效的，并将提供一个解决方案。\n\n任务是找到目标函数 $J(x)$ 的最小化器 $\\hat{f}$：\n$$\n\\hat{f} = \\arg\\min_{x} J(x) = \\arg\\min_{x} \\left\\|g - \\tilde{h} * x\\right\\|_2^2 + \\lambda \\left\\|x\\right\\|_2^2\n$$\n其中 $x$ 是一个 $N \\times N$ 的实值数组， $*$ 表示二维循环卷积，$\\|\\cdot\\|_2^2$ 是欧几里得范数的平方（元素平方和）。正则化参数 $\\lambda$ 是正数，这确保了目标函数是严格凸的，因此有唯一的最小值。\n\n循环卷积算子的存在强烈暗示了在傅里叶域中求解。对于二维离散傅里叶变换 (DFT)（记为 $\\mathcal{F}$），其卷积定理指出，对于 $N \\times N$ 网格上的任意两个离散信号 $a$ 和 $b$，有 $\\mathcal{F}\\{a * b\\} = \\mathcal{F}\\{a\\} \\cdot \\mathcal{F}\\{b\\}$，其中右侧的乘积是逐元素乘积。\n\n我们用大写字母表示相应信号的 DFT：$X = \\mathcal{F}\\{x\\}$，$G = \\mathcal{F}\\{g\\}$ 和 $\\tilde{H} = \\mathcal{F}\\{\\tilde{h}\\}$。使用帕塞瓦尔定理，该定理将空间域中的平方和与傅里叶域中的平方和联系起来，我们可以变换目标函数。一个信号 $a$ 的 $\\ell_2$-范数的平方与其 DFT $A$ 的范数的平方成正比，即 $\\|a\\|_2^2 \\propto \\|A\\|_2^2$。由于我们是在进行最小化，可以忽略常数比例因子，并将目标函数在傅里叶域中写为：\n$$\nJ(X) = \\left\\| G - \\tilde{H} \\cdot X \\right\\|_F^2 + \\lambda \\left\\|X\\right\\|_F^2\n$$\n其中 $\\|\\cdot\\|_F^2$ 是弗罗贝尼乌斯范数的平方，等同于该复值矩阵各元素模的平方和。这可以写成关于所有频率分量 $(k,l)$ 的和：\n$$\nJ(X) = \\sum_{k=0}^{N-1}\\sum_{l=0}^{N-1} \\left( \\left| G[k,l] - \\tilde{H}[k,l] X[k,l] \\right|^2 + \\lambda \\left| X[k,l] \\right|^2 \\right)\n$$\n由于和中的每一项仅依赖于单个频率分量 $X[k,l]$，我们可以通过独立地最小化每一项来最小化总和。对于一个特定的频率 $(k,l)$，我们最小化：\n$$\nJ_{kl}(X_{kl}) = | G_{kl} - \\tilde{H}_{kl} X_{kl} |^2 + \\lambda | X_{kl} |^2\n$$\n为了找到使该表达式最小化的复数 $X_{kl}$，我们对它的共轭 $X_{kl}^*$ 求复导数，并令其为零：\n$$\n\\frac{\\partial J_{kl}}{\\partial X_{kl}^*} = \\frac{\\partial}{\\partial X_{kl}^*} \\left( (G_{kl} - \\tilde{H}_{kl} X_{kl})(G_{kl}^* - \\tilde{H}_{kl}^* X_{kl}^*) + \\lambda X_{kl} X_{kl}^* \\right) = 0\n$$\n$$\n- (G_{kl} - \\tilde{H}_{kl} X_{kl}) \\tilde{H}_{kl}^* + \\lambda X_{kl} = 0\n$$\n$$\n-G_{kl}\\tilde{H}_{kl}^* + |\\tilde{H}_{kl}|^2 X_{kl} + \\lambda X_{kl} = 0\n$$\n求解 $X_{kl}$ 得到估计图像 $\\hat{f}$ 的 DFT 的最优解：\n$$\n\\hat{X}[k,l] = \\frac{G[k,l] \\tilde{H}[k,l]^*}{|\\tilde{H}[k,l]|^2 + \\lambda}\n$$\n这是 Tikhonov 正则化反卷积的著名解。由于输入信号 $g$ 和 $\\tilde{h}$ 是实数，它们的 DFT $G$ 和 $\\tilde{H}$ 表现出厄米共轭对称性。此性质确保了得到的 $\\hat{X}$ 也具有厄米共轭对称性，因此其逆 DFT $\\hat{f}$ 是一个实值图像，与问题的约束一致。\n\n因此，算法流程如下：\n$1$. 对每个测试用例，根据精确的规范合成数据（$f$、$h$、$\\tilde{h}$、$g$），使用指定的随机种子以保证可复现性。\n$2$. 计算观测图像 $g$ 和含噪声的点扩散函数 $\\tilde{h}$ 的二维 DFT，得到 $G$ 和 $\\tilde{H}$。\n$3$. 在频域中应用推导出的滤波器，计算估计图像 DFT 的每个分量 $\\hat{X}$。\n$4$. 计算 $\\hat{X}$ 的二维逆 DFT，得到空间域的估计值 $\\hat{f}$。结果将是实数，但显式地取实部是很好的做法，可以舍弃由浮点数不精确性产生的可忽略的虚部。\n$5$. 最后，通过计算估计值 $\\hat{f}$ 和真实清晰图像 $f$ 之间的均方根误差 (RMSE) 来评估重建质量。\n\n将对所提供的四个测试用例中的每一个实施此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the regularized deconvolution problem for four test cases and\n    computes the RMSE for each.\n    \"\"\"\n\n    test_cases = [\n        # (sigma_h, sigma_n, sigma_p, lambda)\n        (2.0, 0.02, 0.01, 0.001),  # Case 1 (t=1)\n        (2.0, 0.08, 0.03, 0.02),   # Case 2 (t=2)\n        (0.7, 0.02, 0.05, 0.005),  # Case 3 (t=3)\n        (3.0, 0.05, 0.02, 0.02),   # Case 4 (t=4)\n    ]\n\n    # --- Static parameters for data generation ---\n    N = 128\n    # Clean image parameters\n    sigma1 = 3.0\n    sigma2 = 5.0\n    fx = 5.0\n    fy = 9.0\n    \n    results = []\n\n    # --- Generate common components for clean image f ---\n    ii, jj = np.indices((N, N))\n\n    def torus_dist(idx, center):\n        d = np.abs(idx - center)\n        return np.minimum(d, N - d)\n\n    # Component G1\n    d_i1 = torus_dist(ii, N / 2.0)\n    d_j1 = torus_dist(jj, N / 2.0)\n    G1 = np.exp(-(d_i1**2 + d_j1**2) / (2.0 * sigma1**2))\n\n    # Component G2\n    d_i2 = torus_dist(ii, N / 3.0)\n    d_j2 = torus_dist(jj, 2.0 * N / 3.0)\n    G2 = np.exp(-(d_i2**2 + d_j2**2) / (2.0 * sigma2**2))\n\n    # Component S\n    S = np.cos(2.0 * np.pi * (fx * ii / N + fy * jj / N))\n\n    # Unscaled image f0\n    f0 = 0.9 * G1 + 0.7 * G2 + 0.3 * S\n\n    # Normalized clean image f\n    f_min, f_max = f0.min(), f0.max()\n    f = (f0 - f_min) / (f_max - f_min)\n\n    # --- Generate common components for true PSF h ---\n    i_coords = np.arange(N)\n    j_coords = np.arange(N)\n    i_dist = np.minimum(i_coords, N - i_coords)\n    j_dist = np.minimum(j_coords, N - j_coords)\n    # Using broadcasting for robust grid creation\n    r = np.sqrt(i_dist[:, np.newaxis]**2 + j_dist[np.newaxis, :]**2)\n\n    for t, case in enumerate(test_cases, 1):\n        sigma_h, sigma_n, sigma_p, lambda_reg = case\n        \n        # --- Initialize PRNG for reproducibility ---\n        seed = 123456 + t\n        rng = np.random.default_rng(seed)\n\n        # --- Generate true PSF h ---\n        h_unnormalized = np.exp(-r**2 / (2.0 * sigma_h**2))\n        h = h_unnormalized / np.sum(h_unnormalized)\n\n        # --- Generate noisy PSF h_tilde ---\n        nu = rng.normal(0.0, sigma_p, size=(N, N))\n        h_tilde_raw = h + nu\n        h_tilde_nonneg = np.maximum(0.0, h_tilde_raw)\n        h_tilde = h_tilde_nonneg / np.sum(h_tilde_nonneg)\n\n        # --- Generate observed image g ---\n        # Circular convolution via FFT\n        f_conv_h = np.real(np.fft.ifft2(np.fft.fft2(f) * np.fft.fft2(h)))\n        eta = rng.normal(0.0, sigma_n, size=(N, N))\n        g = f_conv_h + eta\n        \n        # --- Solve for estimated image f_hat ---\n        # Transform to Fourier domain\n        G = np.fft.fft2(g)\n        H_tilde = np.fft.fft2(h_tilde)\n\n        # Apply regularized inverse filter\n        H_tilde_conj = np.conj(H_tilde)\n        H_tilde_mag_sq = np.abs(H_tilde)**2\n        \n        F_hat_fourier = (G * H_tilde_conj) / (H_tilde_mag_sq + lambda_reg)\n        \n        # Transform back to spatial domain\n        f_hat = np.real(np.fft.ifft2(F_hat_fourier))\n        \n        # --- Calculate RMSE ---\n        rmse = np.sqrt(np.mean((f_hat - f)**2))\n        results.append(rmse)\n    \n    # --- Format and print final output ---\n    output_str = \",\".join([f\"{r:.6f}\" for r in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2395571"}]}