{"hands_on_practices": [{"introduction": "计算多个独立随机变量之和的概率分布是一个常见的概率论问题。直接计算会随着变量数量的增加而变得异常繁琐。然而，卷积定理为此提供了一个优雅且计算高效的解决方案。本练习 ([@problem_id:2383106]) 将通过计算多个骰子点数之和的概率分布，来具体展示如何利用快速傅里叶变换（FFT）进行重复卷积，从而清晰地揭示卷积定理在概率建模中的强大威力。", "problem": "您需要编写一个完整、可运行的程序，该程序使用卷积定理来计算独立掷骰子点数之和的离散概率分布。核心计算任务是通过将基础分布与自身进行 $n-1$ 次卷积，来获得给定基础分布下 $n$ 个独立同分布离散随机变量之和的概率质量函数。您必须使用卷积定理和快速傅里叶变换 (FFT)，而不是直接在时域进行卷积。\n\n基本假设：\n- 取整数值的离散随机变量 $X$ 的概率质量函数 (PMF) 是函数 $p(k) = \\mathbb{P}[X = k]$，其中 $k$ 是一个整数。\n- 两个 PMF $p$ 和 $q$ 的离散卷积 $(p * q)(k)$ 定义为 $(p * q)(k) = \\sum_{j} p(j)\\, q(k - j)$。\n- 序列 $x[n]$ 的离散傅里叶变换 (DFT) 为 $\\hat{x}[m] = \\sum_{n=0}^{N-1} x[n]\\, e^{-2 \\pi i m n / N}$，其逆变换为 $\\displaystyle x[n] = \\frac{1}{N}\\sum_{m=0}^{N-1} \\hat{x}[m]\\, e^{+2 \\pi i m n / N}$，其中 $N$ 是变换长度。快速傅里叶变换 (FFT) 是计算 DFT 的一种高效算法。\n- 卷积定理指出，卷积的 DFT 等于 DFT 的逐点乘积：$\\widehat{p * q} = \\hat{p}\\,\\hat{q}$。对于同一序列 $p$ 的 n 重卷积，其 DFT 为 $\\widehat{p^{*n}} = (\\hat{p})^n$。\n\n您的程序必须：\n- 使用卷积定理和 FFT 构建基础骰子 PMF 的 n 重卷积。您必须论证并实现补零操作，以确保结果对应于没有循环混叠的线性卷积。推导、论证并使用能够保证 n 重卷积不发生环绕的最小补零长度。具体来说，基础骰子取值于 $\\{1,2,\\dots,m\\}$，其 PMF 条目为 $p_1, p_2, \\dots, p_m$，n 重求和的结果取值于一个有限整数区间。您选择的变换长度必须确保在该支撑集上能够进行正确的线性卷积。\n- 与概率论一致地处理边界条件 $n = 0$，即零个独立变量之和应几乎必然为零（在 0 处的单位点质量）。\n- 对于指定的 $s$，提取点概率 $\\mathbb{P}[S_n = s]$；对于指定的整数 $a$ 和 $b$（其中 $a \\le b$），提取区间概率 $\\mathbb{P}[a \\le S_n \\le b]$，其中 $S_n$ 是 n 个独立基础骰子副本的点数之和。\n- 通过丢弃可忽略的虚部、将因数值舍入误差导致的微小负值截断为零，以及重新归一化使其总和为 1，来对逆 FFT 结果进行数值稳定处理。\n\n在程序中实现的测试套件（无用户输入；对这些情况进行硬编码）：\n- 情况 A（正常路径）：基础骰子是公平的，有 $m = 6$ 个面，$k \\in \\{1,\\dots,6\\}$ 时 $p_k = 1/6$，$n = 10$。计算点概率 $\\mathbb{P}[S_{10} = 35]$。\n- 情况 B（边界：最小和）：同样的公平骰子，$n = 10$。计算 $\\mathbb{P}[S_{10} = 10]$。\n- 情况 C（边界：最大和）：同样的公平骰子，$n = 10$。计算 $\\mathbb{P}[S_{10} = 60]$。\n- 情况 D（边缘情况：零个骰子）：同样的公平骰子，$n = 0$。计算 $\\mathbb{P}[S_{0} = 0]$。\n- 情况 E（有偏骰子）：基础骰子是有偏的，有 $m = 6$ 个面，概率 $p = [0.05, 0.15, 0.20, 0.20, 0.20, 0.20]$ 分别对应于面 $\\{1,2,3,4,5,6\\}$，$n = 3$。计算 $\\mathbb{P}[S_{3} = 10]$。\n- 情况 F（不同大小的骰子）：基础骰子是公平的，有 $m = 4$ 个面，$k \\in \\{1,2,3,4\\}$ 时 $p_k = 1/4$，$n = 5$。计算 $\\mathbb{P}[S_{5} = 10]$。\n- 情况 G（区间概率）：同样的公平 6 面骰子，$n = 20$。计算区间概率 $\\mathbb{P}[60 \\le S_{20} \\le 70]$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含情况 A 到 G 的结果，按顺序排列，形式为一个用方括号括起来的、由逗号分隔的浮点数列表。\n- 将每个概率表示为四舍五入到小数点后恰好 12 位的小数。\n- 输出必须严格采用 $[r_A,r_B,r_C,r_D,r_E,r_F,r_G]$ 的形式，不含空格，其中每个 $r_\\cdot$ 是一个格式化为小数点后恰好 12 位的浮点数。\n\n本问题不涉及物理单位或角度单位。所有答案都是 $\\mathbb{R}$ 中的纯概率值。\n\n约束和附加要求：\n- 您必须使用卷积定理和快速傅里叶变换 (FFT) 来获得 n 重卷积；不允许使用直接的重复时域卷积或枚举法。\n- 确保您选择的变换长度是能够避免 n 重线性卷积发生循环混叠的最小长度，并在您的解题思路中证明此选择的合理性。\n- 代码必须是自包含的，仅使用标准库和允许的库，并产生上述描述的精确输出格式。", "solution": "该问题是有效的，因为它在概率论和数值方法方面有科学依据，是适定的，并提供了一套完整且一致的要求和数据。\n\n问题的核心是计算 $n$ 个独立同分布 (i.i.d.) 离散随机变量之和 $S_n = \\sum_{i=1}^{n} X_i$ 的概率质量函数 (PMF)。每个随机变量 $X_i$ 代表单次掷一个有 $m$ 个面的骰子的结果，其取值于集合 $\\{1, 2, \\dots, m\\}$。$X_i$ 的 PMF 是一个给定序列 $p_X(k) = \\mathbb{P}[X_i = k]$。\n\n根据概率论，两个独立随机变量之和的 PMF 是它们各自 PMF 的卷积。推而广之，$S_n$ 的 PMF（表示为 $p_{S_n}$）是基础 PMF $p_X$ 与自身的 n 重卷积：\n$$\np_{S_n} = \\underbrace{p_X * p_X * \\dots * p_X}_{n \\text{ times}} \\equiv p_X^{*n}\n$$\n其中离散卷积 $(f * g)(k)$ 定义为 $(f * g)(k) = \\sum_{j} f(j) g(k-j)$。直接计算这个 n 重卷积的计算成本高昂，其复杂度会随着 $n$ 的增长而迅速增加。\n\n卷积定理提供了一种使用离散傅里叶变换 (DFT) 的更高效的方法。该定理指出，两个序列卷积的 DFT 是它们各自 DFT 的逐元素乘积。设 $\\mathcal{F}$ 表示 DFT 算子，则有：\n$$\n\\mathcal{F}\\{f * g\\} = \\mathcal{F}\\{f\\} \\cdot \\mathcal{F}\\{g\\}\n$$\n将此定理递归地应用于 n 重卷积，可得：\n$$\n\\mathcal{F}\\{p_{S_n}\\} = \\mathcal{F}\\{p_X^{*n}\\} = (\\mathcal{F}\\{p_X\\})^n\n$$\n因此，可以通过计算基础 PMF 的 DFT 的 n 次方的逆 DFT (IDFT)（表示为 $\\mathcal{F}^{-1}$）来获得所需的 PMF $p_{S_n}$：\n$$\np_{S_n} = \\mathcal{F}^{-1}\\left\\{ (\\mathcal{F}\\{p_X\\})^n \\right\\}\n$$\n快速傅里叶变换 (FFT) 是计算 DFT 及其逆变换的一种高效算法，我们将采用该算法。\n\n使用 DFT 进行卷积的一个关键方面是线性卷积和循环卷积之间的区别。DFT 内在地计算循环卷积。为了获得正确的线性卷积结果，输入序列必须在变换前补零至足够的长度。设基础 PMF $p_X$ 对于 $m$ 个结果是非零的。我们可以将其表示为一个长度为 $m$ 的序列。两个长度为 $L_1$ 和 $L_2$ 的序列的线性卷积结果是一个长度为 $L_1 + L_2 - 1$ 的序列。对于一个长度为 $m$ 的序列的 n 重卷积，结果序列的长度为 $L_n = n(m-1) + 1$。为防止循环混叠（环绕误差），DFT 的变换长度 $N$ 必须至少为该长度：$N \\ge n(m-1) + 1$。问题要求使用最小的有效补零长度，因此我们将选择变换长度 $N$ 恰好为 $N = n(m-1) + 1$。\n\n算法流程如下：\n$1.$ **表示基础 PMF**：对于结果为 $\\{1, \\dots, m\\}$ 的单个骰子，其 PMF 表示为一个长度为 $m$ 的序列 $p$，其中 $p[k-1] = \\mathbb{P}[X=k]$。\n$2.$ **处理边缘情况**：\n   - 如果 $n=1$，PMF 就是基础 PMF $p_X$。\n   - 如果 $n=0$，按照惯例，“零个变量之和”是一个在 0 处为点质量的随机变量。因此，$\\mathbb{P}[S_0=0] = 1$。算法将把此作为特殊情况处理。\n$3.$ **确定变换长度**：对于 $n>1$，计算结果 PMF 所需的长度，这也是最小变换长度：$N = n(m-1) + 1$。\n$4.$ **正向 FFT**：将基础 PMF 序列 $p$ 补零至长度 $N$，并使用 FFT 算法计算其 DFT：$\\hat{p} = \\text{FFT}(p_{\\text{padded}}, N)$。\n$5.$ **频域求幂**：将所得频域谱的每个元素提升到 $n$ 次方：$\\hat{p}_{S_n} = (\\hat{p})^n$。\n$6.$ **逆向 FFT**：计算 $\\hat{p}_{S_n}$ 的逆 DFT，以在时域中获得最终的 PMF：$p_{S_n, \\text{raw}} = \\text{IFFT}(\\hat{p}_{S_n})$。\n$7.$ **数值稳定化**：由于浮点精度误差，IFFT 的结果可能包含微小的非零虚部和负实数值。\n   - 丢弃虚部：$p_{S_n} = \\text{Re}(p_{S_n, \\text{raw}})$。\n   - 将任何微小的负值截断为零：$p_{S_n}[p_{S_n}  0] = 0$。\n   - 重新归一化 PMF 以确保其元素总和恰好为 1：$p_{S_n} = p_{S_n} / \\sum p_{S_n}$。\n$8.$ **解释结果**：得到的数组 $p_{S_n}$ 是和 $S_n$ 的 PMF。和 $S_n$ 的取值范围从 $s_{\\min} = n \\times 1 = n$ 到 $s_{\\max} = n \\times m$。计算出的 PMF 数组 $p_{S_n}$ 长度为 $N=n(m-1)+1$。元素 $p_{S_n}[k]$ 对应于概率 $\\mathbb{P}[S_n = s]$，其中和 $s$ 通过 $s = k + n$ 与索引 $k$ 相关联。反之，要查找和为 $s$ 的概率，我们访问索引为 $k=s-n$ 的元素。\n   - 点概率 $\\mathbb{P}[S_n=s]$ 可通过访问 $p_{S_n}[s-n]$ 找到，前提是 $n \\le s \\le nm$。\n   - 区间概率 $\\mathbb{P}[a \\le S_n \\le b]$ 可通过对索引从 $a-n$ 到 $b-n$ 的元素求和找到：$\\sum_{s=a}^{b} p_{S_n}[s-n]$。\n此流程为解决所有指定的测试用例提供了一种计算上高效且鲁棒的方法。", "answer": "```python\nimport numpy as np\nfrom scipy import fft\n\ndef compute_dice_sum_pmf(pmf_base, n):\n    \"\"\"\n    Computes the PMF of the sum of n i.i.d. dice rolls using FFT-based convolution.\n\n    Args:\n        pmf_base (list or np.ndarray): The PMF of a single die roll for outcomes 1, 2, ..., m.\n        n (int): The number of dice to sum.\n\n    Returns:\n        tuple: A tuple containing:\n            - pmf_sum (np.ndarray): The resulting PMF of the sum.\n            - min_sum (int): The minimum possible sum.\n    \"\"\"\n    m = len(pmf_base)\n    \n    # Handle the edge case of n=0 dice. The sum is deterministically 0.\n    if n == 0:\n        return np.array([1.0]), 0\n\n    # The minimum possible sum is n*1 = n.\n    min_sum = n\n    \n    # For n=1, the PMF is just the base PMF.\n    if n == 1:\n        return np.array(pmf_base), min_sum\n\n    # Calculate the minimal transform length to avoid circular convolution.\n    # The length of the n-fold linear convolution of a sequence of length m is n*(m-1) + 1.\n    transform_length = n * (m - 1) + 1\n\n    # Perform FFT on the zero-padded base PMF.\n    # The 'n' argument in scipy.fft.fft handles the zero-padding.\n    fft_base = fft.fft(pmf_base, n=transform_length)\n\n    # Apply the convolution theorem: DFT of convolution is product of DFTs.\n    # For n-fold self-convolution, this becomes the n-th power of the DFT.\n    fft_sum = fft_base ** n\n\n    # Perform inverse FFT to get the convolved PMF back in the time domain.\n    pmf_sum_raw = fft.ifft(fft_sum)\n\n    # --- Numerical Stabilization ---\n    # 1. The result should be real; discard negligible imaginary parts.\n    pmf_sum = pmf_sum_raw.real\n\n    # 2. Clip tiny negative values resulting from floating-point errors.\n    pmf_sum = np.clip(pmf_sum, 0, None)\n\n    # 3. Renormalize to ensure the PMF sums to 1.\n    total_prob = np.sum(pmf_sum)\n    if total_prob > 0:\n        pmf_sum /= total_prob\n    \n    return pmf_sum, min_sum\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define base PMFs for the dice used in test cases.\n    fair_6_sided_pmf = np.full(6, 1/6)\n    biased_6_sided_pmf = np.array([0.05, 0.15, 0.20, 0.20, 0.20, 0.20])\n    fair_4_sided_pmf = np.full(4, 1/4)\n\n    # Test suite definition: (pmf_base, n, query_type, query_value)\n    # query_type can be 'point' or 'interval'.\n    # query_value is an integer for 'point' or a tuple (a, b) for 'interval'.\n    test_cases = [\n        # Case A: Fair 6-sided, n=10, P(S_10 = 35)\n        (fair_6_sided_pmf, 10, 'point', 35),\n        # Case B: Fair 6-sided, n=10, P(S_10 = 10)\n        (fair_6_sided_pmf, 10, 'point', 10),\n        # Case C: Fair 6-sided, n=10, P(S_10 = 60)\n        (fair_6_sided_pmf, 10, 'point', 60),\n        # Case D: Fair 6-sided, n=0, P(S_0 = 0)\n        (fair_6_sided_pmf, 0, 'point', 0),\n        # Case E: Biased 6-sided, n=3, P(S_3 = 10)\n        (biased_6_sided_pmf, 3, 'point', 10),\n        # Case F: Fair 4-sided, n=5, P(S_5 = 10)\n        (fair_4_sided_pmf, 5, 'point', 10),\n        # Case G: Fair 6-sided, n=20, P(60 = S_20 = 70)\n        (fair_6_sided_pmf, 20, 'interval', (60, 70)),\n    ]\n\n    results = []\n    for pmf_base, n, query_type, query_value in test_cases:\n        pmf_sum, min_sum = compute_dice_sum_pmf(pmf_base, n)\n        \n        m = len(pmf_base)\n        max_sum = n * m\n        \n        result = 0.0\n        if query_type == 'point':\n            s = query_value\n            # Check if sum s is within the possible range [min_sum, max_sum].\n            if min_sum = s = max_sum:\n                # The index corresponding to sum s is s - min_sum.\n                index = s - min_sum\n                result = pmf_sum[index]\n        elif query_type == 'interval':\n            a, b = query_value\n            # Clamp the interval to the valid range of sums.\n            start_s = max(a, min_sum)\n            end_s = min(b, max_sum)\n\n            if start_s = end_s:\n                start_index = start_s - min_sum\n                end_index = end_s - min_sum\n                # Sum the probabilities in the specified range (inclusive).\n                result = np.sum(pmf_sum[start_index : end_index + 1])\n        \n        results.append(result)\n\n    # Format the final output as specified.\n    output_str = \",\".join(f\"{r:.12f}\" for r in results)\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2383106"}, {"introduction": "卷积定理是频域滤波的理论基石，它深刻地揭示了时域操作与频域操作之间的对偶关系。本实践 ([@problem_id:2383027]) 旨在探究在频域中使用“理想”的尖锐截止滤波器会带来何种后果，从而引出著名的吉布斯现象。通过这个练习，你将直观地理解在一个域中的看似简单的操作（如频域截断）如何在另一个域（时域）中产生非直观但至关重要的影响（如振荡伪影）。", "problem": "你需要研究在频域中对周期性离散时间信号施加理想锐截止低通滤波器所引起的Gibbs现象。考虑一个实值的周期信号，在一个周期内以$N$个等距点进行采样。在索引$n \\in \\{0,1,\\dots,N-1\\}$上定义信号$x[n]$，它是一个宽度为$N/2$的单位幅度矩形脉冲，具体为\n$$\nx[n] =\n\\begin{cases}\n1,  N/4 \\le n  3N/4, \\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中索引以$N$为模进行解释，以强制实现一个周期内的周期性。在离散频域中定义理想低通投影如下。设离散傅里叶变换（DFT）的频率为$f_k$，单位为周/采样点，其中$k \\in \\{0,1,\\dots,N-1\\}$，由标准DFT频率网格给出。设Nyquist频率为$f_{\\text{Nyq}} = 1/2$ 周/采样点。对于指定的截止分数$f_c \\in (0,1)$，通过将频率$f_k$处的每个DFT系数乘以以下因子来定义理想低通滤波器\n$$\nH(f_k) =\n\\begin{cases}\n1,  |f_k| \\le f_c \\, f_{\\text{Nyq}},\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n将此频域乘法应用于$x[n]$并变换回时域，得到滤波后的信号$y[n]$。根据卷积定理，此操作等效于将$x[n]$与相应的时域核进行卷积，所得的$y[n]$在$x[n]$的不连续点附近表现出振荡行为（Gibbs现象）。\n\n对于测试套件中的每个参数对$(N,f_c)$，定义以下两个定量度量：\n- 过冲比 $G = \\max_{n} y[n] - 1$，它衡量滤波后的信号在阶跃处或附近超出目标平台值$1$的程度。\n- 下冲幅度 $U = \\max(0, -\\min_{n} y[n])$，它衡量滤波后的信号在阶跃处或附近低于基线值$0$的程度。\n\n为每个测试用例计算$(G,U)$。所有值都是无量纲的。报告所有浮点结果，四舍五入到$6$位小数。你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例贡献一个双元素列表$[G,U]$。例如，输出格式必须是\n$$\n[[G_1,U_1],[G_2,U_2],\\dots],\n$$\n所有数字都四舍五入到$6$位小数，且没有空格。\n\n测试套件（每对为$(N,f_c)$）：\n- $(4096, 0.2)$\n- $(4096, 0.05)$\n- $(2048, 0.45)$\n- $(128, 0.2)$", "solution": "该问题要求对Gibbs现象进行数值研究，当一个带有不连续点的信号从其傅里叶分量的截断集合中重建时，Gibbs现象表现为振荡伪影。这等效于在频域中应用一个理想的锐截止低通滤波器。我们的任务是为一个指定的离散矩形脉冲执行此滤波操作，并为几组参数量化由此产生的过冲和下冲。\n\n此分析的理论基础是离散傅里叶变换（DFT）的卷积定理。该定理确立了时域中的循环卷积等效于频域中的逐元素相乘。给定两个周期为$N$的周期信号$x[n]$和$h[n]$，其DFT分别为$X[k]$和$H[k]$，它们的循环卷积为$y[n] = (x * h)[n]$。所得信号$y[n]$的DFT由$Y[k] = X[k] H[k]$给出。算子$\\mathcal{F}$表示DFT，因此我们有$Y = \\mathcal{F}\\{y\\}$，$X = \\mathcal{F}\\{x\\}$和$H = \\mathcal{F}\\{h\\}$。逆关系式$\\mathcal{F}^{-1}\\{X[k] H[k]\\} = (x*h)[n]$构成了频域滤波的基础。\n\n问题定义了一个直接的滤波过程，我们将遵循该过程：\n$1$. 为$n \\in \\{0, 1, \\dots, N-1\\}$定义离散时间信号$x[n]$。\n$2$. 计算其DFT，$X[k] = \\sum_{n=0}^{N-1} x[n] e^{-i 2\\pi kn/N}$。\n$3$. 定义理想低通滤波器的频率响应$H[k]$。\n$4$. 在频域中相乘以获得滤波后的频谱：$Y[k] = X[k] H[k]$。\n$5$. 计算逆DFT以找到滤波后的时域信号：$y[n] = \\frac{1}{N} \\sum_{k=0}^{N-1} Y[k] e^{i 2\\pi kn/N}$。\n\n我们现在根据问题陈述来具体说明这些组件。\n输入信号$x[n]$是在$N$个采样点的周期内，具有单位幅度和$50\\%$占空比的周期性离散矩形脉冲。其定义如下：\n$$\nx[n] =\n\\begin{cases}\n1,  N/4 \\le n  3N/4 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n索引$n$应以$N$为模进行解释。给定的测试用例使用的$N$值是$4$的整数倍，确保了区间边界$N/4$和$3N/4$是整数。\n\n该滤波器是一个理想低通滤波器。其频率响应$H(f_k)$定义在标准DFT频率网格上。对于长度为$N$且采样周期$T=1$（意味着频率单位为周/采样点）的信号，离散频率$f_k$的范围是从$-f_s/2$到$f_s/2$，其中采样频率$f_s=1$。因此，Nyquist频率为$f_{\\text{Nyq}} = 1/2$ 周/采样点。该滤波器通过某个截止频率以下的频率，并阻断该频率以上的频率：\n$$\nH(f_k) =\n\\begin{cases}\n1,  |f_k| \\le f_c f_{\\text{Nyq}} \\\\\n0,  |f_k| > f_c f_{\\text{Nyq}}\n\\end{cases}\n$$\n这里，$f_c$是给定的截止分数。此滤波器函数在频率$f_{\\text{cutoff}} = f_c / 2$处创建一个“砖墙”式截止。\n\n输入信号$x[n]$是实值的。因此，其DFT $X[k]$必须表现出共轭对称性：$X[k] = X^{*}[N-k]$。滤波器响应$H(f_k)$是基于$|f_k|$定义的，使其成为一个实偶函数。因此，乘积$Y[k] = X[k] H[k]$保持了共轭对称性。一个具有共轭对称DFT的信号在时域中必须是实值的。因此，最终得到的滤波信号$y[n]$必须是实数。在数值计算中出现的任何微小虚部都是有限浮点精度造成的伪影，应当被舍弃。\n\n最后，我们必须使用两个指定的度量来量化Gibbs现象。过冲比$G$衡量滤波信号的最大峰值相对于脉冲预期的最大值$1$的程度：\n$$\nG = \\max_{n} y[n] - 1\n$$\n下冲幅度$U$衡量滤波信号低于预期基线$0$的最大偏差：\n$$\nU = \\max(0, -\\min_{n} y[n])\n$$\n对于每个参数对$(N, f_c)$的计算算法如下：\n$1$. 生成一个长度为$N$的数组来表示信号$x[n]$。\n$2$. 使用快速傅里叶变换（FFT）算法计算此数组的DFT。\n$3$. 生成相应的离散频率数组$f_k$。\n$4$. 根据定义，使用指定的$f_c$构建滤波器数组$H$。\n$5$. 对信号的DFT和滤波器数组进行逐元素相乘。\n$6$. 计算所得乘积数组的逆FFT以获得$y[n]$。通过取实部确保结果为实数。\n$7$. 从数组$y[n]$中，计算最大值和最小值以计算$G$和$U$。\n$8$. 根据输出要求，将$G$和$U$的最终值四舍五入到$6$位小数。\n\n此过程是确定性的，将对所有测试用例执行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Gibbs phenomenon problem by simulating the application of an\n    ideal low-pass filter on a discrete rectangular pulse.\n    \"\"\"\n    # Test suite: each pair is (N, f_c), where N is the number of samples\n    # and f_c is the cutoff fraction.\n    test_cases = [\n        (4096, 0.2),\n        (4096, 0.05),\n        (2048, 0.45),\n        (128, 0.2)\n    ]\n\n    all_results = []\n    for N, f_c in test_cases:\n        # Step 1: Generate the discrete-time signal x[n].\n        # The signal is a unit-amplitude rectangular pulse of width N/2.\n        # x[n] = 1 for N/4 = n  3N/4, and 0 otherwise.\n        x = np.zeros(N, dtype=float)\n        start_index = N // 4\n        end_index = 3 * N // 4\n        x[start_index:end_index] = 1.0\n\n        # Step 2: Compute the Discrete Fourier Transform (DFT) of x[n].\n        X = np.fft.fft(x)\n\n        # Step 3: Define the ideal low-pass filter H(f_k) in the frequency domain.\n        # Frequencies f_k are in cycles per sample (d=1.0).\n        # The Nyquist frequency is f_Nyq = 1/2 cycles/sample.\n        frequencies = np.fft.fftfreq(N, d=1.0)\n        f_nyquist = 0.5\n        cutoff_freq = f_c * f_nyquist\n\n        # The filter H is 1 if |f_k| = cutoff_freq, and 0 otherwise.\n        H = (np.abs(frequencies) = cutoff_freq).astype(float)\n\n        # Step 4: Apply the filter by multiplying in the frequency domain.\n        Y = X * H\n\n        # Step 5: Compute the Inverse DFT to get the filtered signal y[n].\n        # The signal y[n] must be real. We take the real part to handle\n        # minor imaginary components arising from numerical inaccuracies.\n        y = np.real(np.fft.ifft(Y))\n\n        # Step 6: Calculate the overshoot ratio G and undershoot magnitude U.\n        # G = max(y[n]) - 1.0\n        # U = max(0, -min(y[n]))\n        G = np.max(y) - 1.0\n        U = max(0.0, -np.min(y))\n\n        # Append the formatted results for the final output string.\n        # All floating-point results must be rounded to 6 decimal places.\n        all_results.append(f\"[{round(G, 6):.6f},{round(U, 6):.6f}]\")\n\n    # Final print statement must produce a single line in the exact format:\n    # [[G1,U1],[G2,U2],...]\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2383027"}, {"introduction": "在数据分析中，一个核心任务是在数据流中寻找一个已知的模式或模板，这在信号处理和天文学等领域中至关重要。逐一测试所有可能时间平移的暴力搜索方法效率极低。本问题 ([@problem_id:2383038]) 将引导你学习如何将这个搜索问题转化为一个互相关计算，并利用卷积定理通过快速傅里叶变换（FFT）高效地完成，这一强大的技术也被称为匹配滤波。", "problem": "给定两个长度均为 $N$ 的实值、有限、离散时间序列，一个数据序列 $d = \\{d_n\\}_{n=0}^{N-1}$ 和一个模板序列 $h = \\{h_n\\}_{n=0}^{N-1}$。考虑循环移位模型 $m_n(\\tau, A) = A \\, h_{(n-\\tau) \\bmod N}$，其中移位 $\\tau \\in \\{0,1,\\dots,N-1\\}$，振幅 $A \\in \\mathbb{R}$ 是实数。对于每个移位 $\\tau$，定义卡方值为\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A_{\\star}(\\tau) \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2},\n$$\n其中 $\\sigma^2$ 是已知的均匀方差，$A_{\\star}(\\tau)$ 是在固定 $\\tau$ 的情况下使 $\\chi^2(\\tau)$ 最小化的振幅。如果 $\\sum_{n=0}^{N-1} h_n^2 = 0$，则对于所有 $\\tau$，$A_{\\star}(\\tau)$ 均视为 $0$，且 $\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 / \\sigma^2$。如果有多个移位 $\\tau$ 都能得到相同的 $\\chi^2(\\tau)$ 最小值，则选择其中最小的 $\\tau$。\n\n您的任务是，对以下每个测试用例，计算使 $\\chi^2(\\tau)$ 最小的移位 $\\tau_{\\min}$、对应的最小值 $\\chi^2_{\\min}$ 以及对应的最佳拟合振幅 $A_{\\star}(\\tau_{\\min})$。所有用例均使用 $N=8$ 和 $\\sigma^2 = 1$。所有序列都应按模 $N$ 的循环索引进行解释。\n\n测试套件：\n1) 正常路径（非平凡模板和移位）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,2,3,2,1,0,0], \\quad d = [2,0,0,0,2,4,6,4].\n$$\n\n2) 边界情况（交替序列，精确负匹配）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [1,-1,1,-1,1,-1,1,-1], \\quad d = [-1,1,-1,1,-1,1,-1,1].\n$$\n\n3) 边缘情况（零模板）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,0,0,0,0,0,0,0], \\quad d = [3,-1,4,1,5,-9,2,6].\n$$\n\n4) 一般情况（周期模板，小数振幅）：\n$$\nN = 8, \\quad \\sigma^2 = 1, \\quad h = [0,1,0,-1,0,1,0,-1], \\quad d = [0,-0.5,0,0.5,0,-0.5,0,0.5].\n$$\n\n对于每个测试用例，您的程序必须输出一个包含三个值的列表 $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$，其中 $\\tau_{\\min}$ 是一个整数，两个浮点值四舍五入到六位小数。您的程序应生成单行输出，其中包含所有四个测试用例的结果，格式为一个由每个用例的列表组成的逗号分隔列表，并用方括号括起来，不含空格。例如，包含两个假设用例的输出应如下所示\n$$\n[[\\tau_1,\\chi^2_1,A_1],[\\tau_2,\\chi^2_2,A_2]].\n$$", "solution": "我们从最小二乘法的定义开始。对于一个固定的移位 $\\tau$，定义\n$$\n\\chi^2(\\tau;A) = \\sum_{n=0}^{N-1} \\frac{\\left(d_n - A \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\sigma^2}.\n$$\n在均匀方差 $\\sigma^2 = 1$ 的情况下，通过将关于 $A$ 的导数设为零，可以得到最小化振幅 $A_{\\star}(\\tau)$：\n$$\n\\frac{\\partial}{\\partial A} \\chi^2(\\tau;A) = -2 \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N} + 2 A \\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = 0.\n$$\n由于循环移位不改变平方范数，$\\sum_{n=0}^{N-1} h_{(n-\\tau) \\bmod N}^2 = \\sum_{n=0}^{N-1} h_n^2 \\equiv \\|h\\|^2$。因此，如果 $\\|h\\|^2  0$，\n$$\nA_{\\star}(\\tau) = \\frac{\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}}{\\|h\\|^2}.\n$$\n将 $A_{\\star}(\\tau)$ 代回 $\\chi^2$ 并展开，得到\n$$\n\\chi^2(\\tau) = \\sum_{n=0}^{N-1} d_n^2 - \\frac{\\left(\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}\\right)^2}{\\|h\\|^2}.\n$$\n如果 $\\|h\\|^2 = 0$，我们遵循所述约定，对所有 $\\tau$，$A_{\\star}(\\tau)=0$ 且 $\\chi^2(\\tau)=\\sum_{n=0}^{N-1} d_n^2$。\n\n量 $\\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}$ 是 $d$ 与 $h$ 在延迟为 $\\tau$ 时的循环互相关。记作\n$$\nc(\\tau) \\equiv \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N}.\n$$\n根据卷积定理，可以使用离散傅里叶变换（DFT）通过快速傅里叶变换（FFT）高效地计算所有 $\\tau$ 的 $c(\\tau)$。在以下 DFT 约定下\n$$\nD_k = \\sum_{n=0}^{N-1} d_n \\, e^{-2\\pi i k n / N}, \\quad H_k = \\sum_{n=0}^{N-1} h_n \\, e^{-2\\pi i k n / N},\n$$\n逆 DFT 给出\n$$\nc(\\tau) = \\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\frac{1}{N} \\sum_{k=0}^{N-1} D_k \\, \\overline{H_k} \\, e^{2\\pi i k \\tau / N}.\n$$\n直接推导表明\n$$\n\\operatorname{IDFT}\\left(D_k \\, \\overline{H_k}\\right)_\\tau = \\sum_{n=0}^{N-1} d_n \\, h_{(n-\\tau) \\bmod N},\n$$\n这正是我们所求的循环互相关。因此，我们可以通过对 $d$ 进行一次正向 FFT，对 $h$ 进行一次正向 FFT，与复共轭进行逐点相乘，再进行一次逆 FFT，在 $\\mathcal{O}(N \\log N)$ 时间内计算出整个相关序列 $c(\\tau)$。\n\n算法步骤：\n1) 计算 $\\|h\\|^2 = \\sum_{n=0}^{N-1} h_n^2$ 和 $\\|d\\|^2 = \\sum_{n=0}^{N-1} d_n^2$。\n2) 如果 $\\|h\\|^2 = 0$，则对所有 $\\tau$ 设置 $A_{\\star}(\\tau)=0$ 和 $\\chi^2(\\tau)=\\|d\\|^2$。\n3) 否则，使用 FFT 通过卷积定理计算 $c(\\tau)$。然后对每个 $\\tau$，\n$$\nA_{\\star}(\\tau) = \\frac{c(\\tau)}{\\|h\\|^2}, \\quad \\chi^2(\\tau) = \\|d\\|^2 - \\frac{c(\\tau)^2}{\\|h\\|^2}.\n$$\n4) 找到使 $\\chi^2(\\tau)$ 最小的 $\\tau_{\\min}$；通过选择最小的 $\\tau$ 来解决平局问题。\n5) 报告 $[\\tau_{\\min}, \\chi^2_{\\min}, A_{\\star}(\\tau_{\\min})]$，其中浮点数条目四舍五入到六位小数。\n\n应用于所提供的测试套件：\n\n用例 1：$h = [0,1,2,3,2,1,0,0]$，$d = [2,0,0,0,2,4,6,4]$。\n我们有 $\\|h\\|^2 = 19$ 和 $\\|d\\|^2 = 76$。互相关在 $\\tau=3$ 时达到最大值 $c(3) = 38$，得到 $A_{\\star}(3) = 38/19 = 2$ 和 $\\chi^2_{\\min} = 76 - 38^2/19 = 0$。\n\n用例 2：$h = [1,-1,1,-1,1,-1,1,-1]$，$d = [-1,1,-1,1,-1,1,-1,1]$。\n这里 $\\|h\\|^2 = 8$，$\\|d\\|^2 = 8$。对于所有 $\\tau$，$c(\\tau) \\in \\{\\pm 8\\}$，因此对每个 $\\tau$，$\\chi^2(\\tau) = 8 - 64/8 = 0$。我们选择最小的索引 $\\tau_{\\min} = 0$，此时 $A_{\\star}(0) = -1$。\n\n用例 3：$h = [0,0,0,0,0,0,0,0]$，$d = [3,-1,4,1,5,-9,2,6]$。\n此时 $\\|h\\|^2 = 0$，所以根据约定，对于所有 $\\tau$，$A_{\\star}(\\tau) = 0$ 且 $\\chi^2(\\tau) = \\|d\\|^2 = 173$。我们选择 $\\tau_{\\min} = 0$ 且 $A_{\\star}(0) = 0$。\n\n用例 4：$h = [0,1,0,-1,0,1,0,-1]$，$d = [0,-0.5,0,0.5,0,-0.5,0,0.5]$。\n我们有 $\\|h\\|^2 = 4$，$\\|d\\|^2 = 1$。互相关在 $\\tau=2$ 时达到峰值 $c(2)=2$，得到 $A_{\\star}(2) = 2/4 = 0.5$ 和 $\\chi^2_{\\min} = 1 - 4/4 = 0$。\n\n四舍五入到六位小数，每个用例的预期输出为\n$$\n[3, 0.000000, 2.000000], \\quad [0, 0.000000, -1.000000], \\quad [0, 173.000000, 0.000000], \\quad [2, 0.000000, 0.500000].\n$$\n按要求汇总成单行：\n$$\n[[3,0.000000,2.000000],[0,0.000000,-1.000000],[0,173.000000,0.000000],[2,0.000000,0.500000]].\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_min_chi2_shift(d, h):\n    \"\"\"\n    Given data d and template h (both length N), compute for circular shifts tau:\n    - A_hat(tau) = argmin_A sum (d_n - A h_{n - tau})^2\n    - chi2(tau) = min value at A_hat(tau) with sigma^2 = 1\n    Return (tau_min, chi2_min, A_hat_at_tau_min), breaking ties by smallest tau.\n    \"\"\"\n    d = np.asarray(d, dtype=np.float64)\n    h = np.asarray(h, dtype=np.float64)\n    N = d.size\n    assert h.size == N, \"d and h must have the same length\"\n\n    norm_h2 = float(np.dot(h, h))\n    norm_d2 = float(np.dot(d, d))\n\n    if norm_h2 == 0.0:\n        # Degenerate case: A_hat(tau)=0 and chi2(tau)=norm_d2 for all tau\n        tau_min = 0\n        chi2_min = norm_d2\n        A_hat_min = 0.0\n        return tau_min, chi2_min, A_hat_min\n\n    # Compute circular cross-correlation c[tau] = sum_n d_n h_{n - tau}\n    D = np.fft.fft(d)\n    H = np.fft.fft(h)\n    c = np.fft.ifft(D * np.conj(H))\n    # Numerical errors may leave tiny imaginary parts\n    c = np.real(c)\n\n    # Compute chi2(tau) = ||d||^2 - c[tau]^2 / ||h||^2\n    chi2 = norm_d2 - (c * c) / norm_h2\n    # Guard against tiny negative due to numerical precision\n    chi2 = np.maximum(chi2, 0.0)\n\n    tau_min = int(np.argmin(chi2))\n    chi2_min = float(chi2[tau_min])\n    A_hat_min = float(c[tau_min] / norm_h2)\n\n    return tau_min, chi2_min, A_hat_min\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (\n            [2, 0, 0, 0, 2, 4, 6, 4],\n            [0, 1, 2, 3, 2, 1, 0, 0]\n        ),\n        # Case 2\n        (\n            [-1, 1, -1, 1, -1, 1, -1, 1],\n            [1, -1, 1, -1, 1, -1, 1, -1]\n        ),\n        # Case 3\n        (\n            [3, -1, 4, 1, 5, -9, 2, 6],\n            [0, 0, 0, 0, 0, 0, 0, 0]\n        ),\n        # Case 4\n        (\n            [0.0, -0.5, 0.0, 0.5, 0.0, -0.5, 0.0, 0.5],\n            [0, 1, 0, -1, 0, 1, 0, -1]\n        ),\n    ]\n\n    results = []\n    for d, h in test_cases:\n        tau_min, chi2_min, A_hat_min = compute_min_chi2_shift(d, h)\n        # Format with required rounding for floats\n        results.append([tau_min, f\"{chi2_min:.6f}\", f\"{A_hat_min:.6f}\"])\n\n    # Build the exact required single-line output without spaces\n    inner = \",\".join(\"[\" + \",\".join([str(r[0]), r[1], r[2]]) + \"]\" for r in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383038"}]}