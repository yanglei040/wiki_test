{"hands_on_practices": [{"introduction": "我们实践的第一步是将最小二乘法应用到一个经典的科学问题上：地质年代测定。通过分析放射性同位素的衰变，我们可以将岩石年龄的计算转化为一个线性拟合问题。这个练习将展示如何利用基本的线性回归技术，从同位素比率数据中提取出关键的物理信息，从而揭示地球古老的历史。[@problem_id:2408074]", "problem": "您会获得来自同一块岩石中不同单矿物的多组铷-锶（Rb-Sr）地质年代学同位素比值数据。对于每组数据，通过绘制现今比值 $y = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})$ 相对于 $x = (^{87}\\mathrm{Rb}/^{86}\\mathrm{Sr})$ 的关系图来定义一条等时线。在铷-87的放射性衰变作用下，线性关系\n$$\ny = b + m x\n$$\n成立，其中 $b = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_{\\mathrm{initial}}$ 并且\n$$\nm = e^{\\lambda t} - 1,\n$$\n$\\lambda$ 是衰变常数，$t$ 是年龄。使用 $\\lambda = 1.42 \\times 10^{-11}\\ \\mathrm{yr}^{-1}$，并使用自然对数。年龄可以通过拟合的斜率 $\\hat{m}$，通过以下公式计算得出：\n$$\n\\hat{t} = \\frac{\\ln(1 + \\hat{m})}{\\lambda}.\n$$\n对于下面的每个数据集，通过最小二乘法对点集 $\\{(x_i, y_i)\\}$ 进行直线拟合，确定最佳拟合年龄 $\\hat{t}$。将每个最终年龄以百万年（Ma）为单位表示为浮点数，并四舍五入到小数点后两位。\n\n测试套件（每个数据集都是独立的）：\n\n- 数据集 A（一般情况）：\n  - $x$ 值：$[0.20, 0.80, 1.50, 2.50, 3.50, 5.00]$\n  - $y$ 值：$[0.702682, 0.713377, 0.725843, 0.743711, 0.761738, 0.788617]$\n- 数据集 B（零斜率边界情况）：\n  - $x$ 值：$[0.00, 0.50, 1.00, 1.50, 3.00]$\n  - $y$ 值：$[0.704700, 0.704700, 0.704700, 0.704700, 0.704700]$\n- 数据集 C（更古老的岩石；分布更广）：\n  - $x$ 值：$[0.30, 1.20, 2.80, 4.50, 7.50, 10.00]$\n  - $y$ 值：$[0.712295, 0.747371, 0.809941, 0.877448, 0.993603, 1.091396]$\n- 数据集 D（$x$ 值分布窄；条件数检验）：\n  - $x$ 值：$[0.95, 0.98, 1.02, 1.05, 1.07]$\n  - $y$ 值：$[0.732715, 0.733462, 0.734507, 0.735274, 0.735825]$\n\n您的程序必须处理所有四个数据集，计算最佳拟合斜率 $\\hat{m}$，并使用上述公式将其转换为年龄 $\\hat{t}$，然后以百万年（Ma）为单位返回四舍五入到小数点后两位的年龄。本问题不涉及角度。本问题不出现百分比。\n\n最终输出格式：您的程序应生成一行输出，其中包含数据集 A、B、C 和 D 的年龄，按此顺序排列，形式为用方括号括起来的逗号分隔列表，例如：[$1250.00$, $0.00$, $2700.00$, $1800.00$]。", "solution": "问题陈述已经过评估，被认为是有效的。它在科学上基于放射性衰变和地质年代学的原理，在数学上是适定的，并为获得唯一解提供了所有必要信息。我们将继续进行推导和计算。\n\n目标是根据几组同位素比值的测量数据，确定岩石的年龄 $t$。所提供的数据由数对 $(x_i, y_i)$ 组成，其中 $x_i = (^{87}\\mathrm{Rb}/^{86}\\mathrm{Sr})_i$ 和 $y_i = (^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_i$ 分别对应不同的矿物样品 $i$。其背后的物理模型是等时线方程，该方程预测了这些变量之间的线性关系：\n$$\ny = b + mx\n$$\n在这里，$b$ 代表岩石形成时（$t=0$）的初始同位素比值 $(^{87}\\mathrm{Sr}/^{86}\\mathrm{Sr})_{\\mathrm{initial}}$，而斜率 $m$ 通过放射性衰变方程与岩石的年龄 $t$ 相关联：\n$$\nm = e^{\\lambda t} - 1\n$$\n其中 $\\lambda$ 是 $^{87}\\mathrm{Rb}$ 的衰变常数。\n\n任务要求根据给定的实验数据找到线性模型的最佳拟合参数。指定的方法是标准的未加权线性最小二乘回归。该方法确定斜率 $\\hat{m}$ 和截距 $\\hat{b}$，以最小化垂直残差的平方和 $S$：\n$$\nS = \\sum_{i=1}^{N} (y_i - (\\hat{m}x_i + \\hat{b}))^2\n$$\n使 $S$ 最小化的斜率 $\\hat{m}$ 的值由以下公式给出：\n$$\n\\hat{m} = \\frac{\\sum_{i=1}^{N} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N} (x_i - \\bar{x})^2}\n$$\n其中 $N$ 是数据点的数量，$\\bar{x}$ 是 $x_i$ 值的平均值，$\\bar{y}$ 是 $y_i$ 值的平均值。只要 $x_i$ 值存在变化（所有提供的数据集都满足此条件），该公式就能提供唯一解。截距 $\\hat{b}$ 可以通过 $\\hat{b} = \\bar{y} - \\hat{m}\\bar{x}$ 计算得出，但对于年龄的确定并非必需。\n\n一旦计算出给定数据集的最佳拟合斜率 $\\hat{m}$，就可以通过反转斜率与年龄之间的关系来找到年龄 $\\hat{t}$。从 $\\hat{m} = e^{\\lambda \\hat{t}} - 1$ 开始，我们重新整理方程：\n$$\n1 + \\hat{m} = e^{\\lambda \\hat{t}}\n$$\n对两边取自然对数，得到：\n$$\n\\ln(1 + \\hat{m}) = \\ln(e^{\\lambda \\hat{t}}) = \\lambda \\hat{t}\n$$\n由此，我们解出年龄 $\\hat{t}$：\n$$\n\\hat{t} = \\frac{\\ln(1 + \\hat{m})}{\\lambda}\n$$\n问题指定了衰变常数 $\\lambda = 1.42 \\times 10^{-11}\\ \\mathrm{yr}^{-1}$。使用该值计算出的年龄 $\\hat{t}$ 将以年为单位。最终要求是以百万年（Ma）为单位表示年龄，这需要除以 $10^6$：\n$$\n\\hat{t}_{\\text{Ma}} = \\frac{\\hat{t}}{10^6} = \\frac{\\ln(1 + \\hat{m})}{\\lambda \\times 10^6}\n$$\n然后将结果四舍五入到小数点后两位。此过程将通过计算算法系统地应用于四个数据集中的每一个，以确保精度。对于数据集 B 的特殊情况，$y_i$ 值是恒定的，这正确地意味着斜率 $\\hat{m}=0$，因此年龄 $\\hat{t}=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Rb-Sr isochron age for multiple geological data sets.\n    \n    The age is determined by performing a linear least-squares fit on the\n    isotope ratio data to find the slope of the isochron, then using the\n    slope to calculate the age based on the radioactive decay equation.\n    \"\"\"\n    \n    # Define the physical constant and test cases.\n    \n    # Decay constant for Rubidium-87 in yr^-1.\n    LAMBDA_RB87 = 1.42e-11\n    \n    # Isotope ratio data for four different rock samples.\n    # Each data set is a tuple of (x_values, y_values).\n    test_cases = [\n        # Data set A (general case)\n        (\n            [0.20, 0.80, 1.50, 2.50, 3.50, 5.00],\n            [0.702682, 0.713377, 0.725843, 0.743711, 0.761738, 0.788617]\n        ),\n        # Data set B (boundary with zero slope)\n        (\n            [0.00, 0.50, 1.00, 1.50, 3.00],\n            [0.704700, 0.704700, 0.704700, 0.704700, 0.704700]\n        ),\n        # Data set C (older rock; broader spread)\n        (\n            [0.30, 1.20, 2.80, 4.50, 7.50, 10.00],\n            [0.712295, 0.747371, 0.809941, 0.877448, 0.993603, 1.091396]\n        ),\n        # Data set D (narrow x spread; conditioning check)\n        (\n            [0.95, 0.98, 1.02, 1.05, 1.07],\n            [0.732715, 0.733462, 0.734507, 0.735274, 0.735825]\n        )\n    ]\n    \n    results = []\n    \n    for x_data, y_data in test_cases:\n        # Convert data to numpy arrays for numerical processing.\n        x = np.array(x_data)\n        y = np.array(y_data)\n        \n        # Perform linear regression to find the slope (m) of the line y = mx + b.\n        # np.polyfit with degree 1 fits a line and returns [slope, intercept].\n        # We only need the slope for the age calculation.\n        slope, _ = np.polyfit(x, y, 1)\n        \n        # The slope m is related to age t by m = exp(lambda * t) - 1.\n        # We solve for t: t = ln(1 + m) / lambda.\n        # A slope of 0 (or very close) will result in an age of 0, as log(1)=0.\n        # This handles Data set B correctly.\n        if 1 + slope = 0:\n            # This case is physically unrealistic for Rb-Sr dating but included for robustness.\n            # An age cannot be calculated. For this problem, we can assume slope  -1.\n            # We will treat this as an error or undefined age. \n            # However, problem data guarantees non-negative slope.\n            age_yr = np.nan\n        else:\n            age_yr = np.log(1 + slope) / LAMBDA_RB87\n            \n        # Convert age from years to million years (Ma).\n        age_ma = age_yr / 1e6\n        \n        # Format the result to two decimal places and add to the list.\n        results.append(f\"{age_ma:.2f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2408074"}, {"introduction": "真实世界的物理模型往往比简单的直线关系更为复杂。本练习将带领我们超越理想气体模型，探索用于描述真实气体的范德华方程。由于该模型本质上是非线性的，我们将学习如何使用数值优化方法来估计其关键参数，从而让模型与实验数据达到最佳吻合。[@problem_id:2408017]", "problem": "给定一摩尔非理想气体的范德瓦尔斯状态方程，\n$$(P + \\tfrac{a}{V^2})(V - b) = R\\,T,$$\n其中，$P$ 是压力，$V$ 是摩尔体积，$T$ 是绝对温度，$R$ 是普适气体常数，$a$ 和 $b$ 是表征气体对理想气体行为偏离的未知参数。等价地，作为 $(V,T,a,b)$ 函数的模型压力为\n$$P_{\\text{model}}(V,T;a,b) = \\frac{R\\,T}{V - b} - \\frac{a}{V^2}.$$\n使用普适气体常数 $R = 8.31446261815324\\,\\mathrm{J\\,mol^{-1}\\,K^{-1}}$（注意 $\\mathrm{J} = \\mathrm{Pa\\,m^3}$，因此当 $V$ 的单位为 $\\mathrm{m^3\\,mol^{-1}}$ 且 $T$ 的单位为 $\\mathrm{K}$ 时，$P$ 的单位为 $\\mathrm{Pa}$）。对于下方的每个数据集，合成的压力-体积-温度 (PVT) 数据由已知的真实参数 $(a_\\star,b_\\star)$ 以及一组指定的温度和摩尔体积定义。每个压力数据点都由 $P_i = P_{\\text{model}}(V_i,T_i;a_\\star,b_\\star)$ 精确生成，不含任何附加噪声。\n\n对于每个数据集，您的任务是：给定三元组列表 $\\{(T_i,V_i,P_i)\\}_{i=1}^N$，确定估计值 $(\\hat a,\\hat b)$ 以最小化压力残差平方和\n$$S(a,b) = \\sum_{i=1}^{N}\\big(P_i - P_{\\text{model}}(V_i,T_i;a,b)\\big)^2,$$\n并满足物理约束 $a \\ge 0$ 和 $0 \\le b  \\min_i V_i$。报告 $\\hat a$（单位 $\\mathrm{Pa\\,m^6\\,mol^{-2}}$）和 $\\hat b$（单位 $\\mathrm{m^3\\,mol^{-1}}$）。\n\n测试套件定义（三个数据集）：\n- 数据集 $\\mathrm{A}$：\n  - 真实值：$a_\\star = 0.1390\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$, $b_\\star = 3.913\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{300\\,\\mathrm{K}, 350\\,\\mathrm{K}, 400\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.50\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 2.00\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 3.00\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：温度和体积的所有 9 种组合；$P_i$ 由带有 $(a_\\star,b_\\star)$ 的模型精确计算。\n- 数据集 $\\mathrm{B}$：\n  - 真实值：$a_\\star = 3.41\\times 10^{-3}\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$, $b_\\star = 2.37\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{300\\,\\mathrm{K}, 600\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}, 2.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}, 5.00\\times 10^{-2}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：温度和体积的所有 6 种组合；$P_i$ 由带有 $(a_\\star,b_\\star)$ 的模型精确计算。\n- 数据集 $\\mathrm{C}$：\n  - 真实值：$a_\\star = 0.3592\\,\\mathrm{Pa\\,m^6\\,mol^{-2}}$, $b_\\star = 4.267\\times 10^{-5}\\,\\mathrm{m^3\\,mol^{-1}}$。\n  - 温度：$\\{350\\,\\mathrm{K}\\}$。\n  - 摩尔体积：$\\{1.20\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}, 2.50\\times 10^{-3}\\,\\mathrm{m^3\\,mol^{-1}}\\}$。\n  - 数据点：单一温度下的 2 个体积值；$P_i$ 由带有 $(a_\\star,b_\\star)$ 的模型精确计算。\n\n要求的最终输出格式：\n- 按 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$ 的顺序，为每个数据集输出数值对 $[\\hat a,\\hat b]$，两个数值均采用指定的国际单位制 (SI) 单位，并四舍五入至 $6$ 位有效数字。\n- 您的程序应生成单行输出，其中包含三个数值对，聚合为一个用逗号分隔的列表，并用方括号括起来，例如 $\\big[\\,[\\hat a_{\\mathrm{A}},\\hat b_{\\mathrm{A}}],[\\hat a_{\\mathrm{B}},\\hat b_{\\mathrm{B}}],[\\hat a_{\\mathrm{C}},\\hat b_{\\mathrm{C}}]\\,\\big]$，不含任何额外文本。", "solution": "所提出的问题是有效的。这是一个定义明确的计算物理学任务，涉及范德瓦尔斯状态方程的参数估计，该方程是热力学中的一个基本模型。所有必要的数据、常数和约束条件都已提供，该问题在科学上是合理的、客观的，并且内部一致。\n\n问题的核心是确定范德瓦尔斯模型的最优参数 $(\\hat{a}, \\hat{b})$，以最佳地重现一组给定的压力-体积-温度 ($PVT$) 数据。压力模型由下式给出\n$$P_{\\text{model}}(V,T;a,b) = \\frac{R\\,T}{V - b} - \\frac{a}{V^2}$$\n其中 $R$ 是普适气体常数，$T$ 是温度，$V$ 是摩尔体积。待确定的参数是 $a$（表示分子间引力）和 $b$（每摩尔的排除体积）。\n\n“最佳拟合”的标准是最小化残差平方和 $S(a,b)$：\n$$S(a,b) = \\sum_{i=1}^{N}\\big(P_i - P_{\\text{model}}(V_i,T_i;a,b)\\big)^2$$\n其中 $\\{ (T_i, V_i, P_i) \\}_{i=1}^N$ 是 $N$ 个数据点。这是一个非线性最小二乘优化问题。非线性源于模型对参数 $b$ 的依赖性，体现在 $(V-b)^{-1}$ 项中。因此，标准的线性回归方法不适用。\n\n该问题的一个关键方面是，压力数据 $P_i$ 是使用已知的真实参数 $(a_\\star, b_\\star)$ 从模型本身合成生成的，不含噪声。这意味着可以实现完美拟合，目标函数 $S(a,b)$ 的全局最小值恰好为零，这在 $(a,b) = (a_\\star, b_\\star)$ 时出现。因此，任务简化为在数值上恢复这些已知参数，这是对所选优化算法的稳健性测试。\n\n数值求解是使用一个非线性最小二乘求解器实现的。SciPy 库中的 `scipy.optimize.least_squares` 函数非常适合此目的。该函数旨在最小化残差向量的 $L_2$ 范数。我们定义残差向量 $\\mathbf{r}(a,b)$，其分量为：\n$$r_i(a,b) = P_i - \\left( \\frac{R\\,T_i}{V_i - b} - \\frac{a}{V_i^2} \\right)$$\n然后，优化器找到参数 $(\\hat{a}, \\hat{b})$，以最小化 $||\\mathbf{r}||^2 = S(a,b)$。\n\n优化必须遵守问题中指定的物理约束：\n1.  $a \\ge 0$：分子间引力项为非负。\n2.  $0 \\le b  \\min_i V_i$：排除体积 $b$ 必须为非负，并且物理上不能超过数据集中最小的摩尔体积值 $V_i$。\n\n在优化过程中，这些约束作为参数的边界被施加：$a \\in [0, \\infty)$ 和 $b \\in [0, \\min_i V_i)$。\n\n对于迭代式非线性求解器，需要一个参数的初始猜测值。一个合乎逻辑的起点是理想气体极限，此时对理想气体定律没有修正。这对应于初始猜测值 $(a_0, b_0) = (0, 0)$。\n\n每个数据集的处理流程如下：\n1.  从指定的范围构建数据集 $(T_i, V_i)$。\n2.  使用范德瓦尔斯模型和给定的真实参数 $(a_\\star, b_\\star)$ 计算相应的压力值 $P_i$。\n3.  使用定义的残差函数、初始猜测值 $(0,0)$ 以及从约束中导出的物理边界来调用 `scipy.optimize.least_squares` 求解器。\n4.  对于数据集 A ($N=9$) 和 B ($N=6$)，系统是超定的 ($N2$)，这是最小二乘拟合的标准情况。对于数据集 C ($N=2$)，系统是恰定的，意味着我们正在求解一个包含两个未知数的两个非线性方程组。最小二乘法是通用的，可以正确处理所有这些情况。\n5.  提取得到的最优参数 $(\\hat{a}, \\hat{b})$。由于数据的无噪声特性，预计这些估计值在求解器的容差范围内与真实值 $(a_\\star, b_\\star)$ 在数值上是相同的。\n6.  最后，将估计的参数 $\\hat{a}$ 和 $\\hat{b}$ 四舍五入并格式化为六位有效数字的指定科学记数法形式，用于最终输出。", "answer": "```python\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Solves for the van der Waals parameters (a, b) for three different datasets\n    using nonlinear least-squares fitting.\n    \"\"\"\n    R = 8.31446261815324  # Universal gas constant in J mol^-1 K^-1\n\n    test_cases = [\n        {\n            \"a_star\": 0.1390,\n            \"b_star\": 3.913e-5,\n            \"T_vals\": np.array([300.0, 350.0, 400.0]),\n            \"V_vals\": np.array([1.50e-3, 2.00e-3, 3.00e-3]),\n        },\n        {\n            \"a_star\": 3.41e-3,\n            \"b_star\": 2.37e-5,\n            \"T_vals\": np.array([300.0, 600.0]),\n            \"V_vals\": np.array([1.00e-2, 2.00e-2, 5.00e-2]),\n        },\n        {\n            \"a_star\": 0.3592,\n            \"b_star\": 4.267e-5,\n            \"T_vals\": np.array([350.0]),\n            \"V_vals\": np.array([1.20e-3, 2.50e-3]),\n        },\n    ]\n\n    def p_model(params, T, V, R_const):\n        \"\"\"Calculates pressure using the van der Waals model.\"\"\"\n        a, b = params\n        return R_const * T / (V - b) - a / (V**2)\n\n    def residuals(params, T, V, P_data, R_const):\n        \"\"\"Calculates the residuals between model predictions and data.\"\"\"\n        return P_data - p_model(params, T, V, R_const)\n\n    formatted_results = []\n\n    for case in test_cases:\n        # 1. Generate the synthetic PVT data\n        T_grid, V_grid = np.meshgrid(case[\"T_vals\"], case[\"V_vals\"])\n        T_data = T_grid.flatten()\n        V_data = V_grid.flatten()\n        \n        true_params = [case[\"a_star\"], case[\"b_star\"]]\n        P_data = p_model(true_params, T_data, V_data, R)\n\n        # 2. Set up and run the optimization\n        # Initial guess: ideal gas limit (a=0, b=0)\n        x0 = [0.0, 0.0]\n        \n        # Physical constraints as bounds for the solver\n        min_V = np.min(V_data)\n        bounds = ([0.0, 0.0], [np.inf, min_V])\n\n        # Find the parameters that minimize the sum of squared residuals\n        result = optimize.least_squares(\n            residuals,\n            x0,\n            bounds=bounds,\n            args=(T_data, V_data, P_data, R),\n            method='trf'  # Trust Region Reflective algorithm, good for bounds\n        )\n        \n        a_hat, b_hat = result.x\n\n        # 3. Format the results to 6 significant figures\n        # The '.5e' format specifier ensures scientific notation with 1 digit\n        # before the decimal and 5 after, for a total of 6 significant figures.\n        a_hat_str = f\"{a_hat:.5e}\"\n        b_hat_str = f\"{b_hat:.5e}\"\n        \n        formatted_results.append(f\"[{a_hat_str},{b_hat_str}]\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2408017"}, {"introduction": "为了获得更精确的测量结果，科学家常常需要整合来自多个独立实验的数据。这个练习介绍了一种强大的技术——全局拟合，它允许我们同时分析多个数据集。通过将所有数据约束于共享的物理参数（例如共同的衰变寿命和背景噪声），我们可以显著提高参数估计的精度和可靠性。[@problem_id:2408092]", "problem": "给定多个独立的数据集，每个数据集测量一个带有恒定背景的衰减信号。通用物理模型是，探测器的计数率信号因存在一个在所有实验中具有共同寿命的单一组分而随时间呈指数衰减，并且所有探测器共享一个单一的恒定背景率。对于索引为 $k$ 的数据集，在时间 $t_{k,i}$ 进行的测量产生观测计数率 $y_{k,i}$，其报告的标准差为 $\\sigma_{k,i}$。正向模型为\n$$\ny_{k,i} \\approx A_k \\, e^{-t_{k,i}/\\tau} + B,\n$$\n其中 $A_k$ 是特定于数据集的振幅，$\\tau$ 是所有数据集共享的寿命，而 $B$ 是所有数据集共享的背景率。假设测量误差是加性的、独立的高斯误差，且具有已知的标准差 $\\sigma_{k,i}$。在这些假设下，最大似然原理意味着最小化加权残差平方和。也就是说，估计的参数需要最小化\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} \\left( \\frac{y_{k,i} - \\left(A_k e^{-t_{k,i}/\\tau} + B\\right)}{\\sigma_{k,i}} \\right)^2.\n$$\n您的任务是编写一个完整、可运行的程序，在每个测试案例中使用加权最小二乘法 (WLS) 同时拟合所有数据集，以找到最佳拟合的共享寿命 $\\tau$ 和共享背景 $B$，同时允许每个数据集拥有其自身的振幅 $A_k$。对参数进行物理约束，即 $A_k \\ge 0$、$\\tau  0$ 和 $B \\ge 0$。优化过程必须直接最小化与上述模型对应的加权残差平方和，并将 $\\tau$ 和 $B$ 视为同一测试案例中跨数据集共享的参数。\n\n物理单位：将每个时间 $t$ 解释为秒，每个计数率 $y$ 解释为计数每秒。报告寿命 $\\tau$ 的单位为秒，背景 $B$ 的单位为计数每秒。将每个报告的数字四舍五入到小数点后恰好三位。\n\n测试套件。对于下方的每个测试案例，程序必须同时拟合该案例中给出的所有数据集，并且仅输出最佳拟合的共享 $\\tau$ 和共享 $B$，四舍五入到恰好三位小数。\n\n测试案例 1（两个数据集，中等噪声，良态）：\n- 数据集 1：时间 $t_{1} = (0, 0.5, 1.0, 1.5, 2.0, 3.0)$，观测值 $y_{1} = (5.51, 4.38, 3.55, 2.86, 2.36, 1.62)$，不确定度 $\\sigma_{1} = (0.05, 0.05, 0.05, 0.05, 0.05, 0.05)$。\n- 数据集 2：时间 $t_{2} = (0, 0.7, 1.4, 2.1, 2.8, 3.5)$，观测值 $y_{2} = (3.49, 2.62, 2.00, 1.54, 1.25, 1.03)$，不确定度 $\\sigma_{2} = (0.08, 0.08, 0.08, 0.08, 0.08, 0.08)$。\n\n测试案例 2（一个数据集振幅较小，测试 $B$ 的可辨识性）：\n- 数据集 1：时间 $t_{1} = (0, 0.5, 1.0, 1.5, 2.0)$，观测值 $y_{1} = (2.31, 1.50, 1.04, 0.75, 0.57)$，不确定度 $\\sigma_{1} = (0.02, 0.02, 0.02, 0.02, 0.02)$。\n- 数据集 2：时间 $t_{2} = (0, 1.0, 2.0, 3.0)$，观测值 $y_{2} = (0.49, 0.38, 0.33, 0.31)$，不确定度 $\\sigma_{2} = (0.01, 0.01, 0.01, 0.01)$。\n\n测试案例 3（三个数据集，具有不同的时间覆盖范围和不确定性）：\n- 数据集 1：时间 $t_{1} = (0, 1.0, 2.0, 3.0, 5.0)$，观测值 $y_{1} = (5.21, 4.05, 3.26, 2.67, 1.97)$，不确定度 $\\sigma_{1} = (0.03, 0.03, 0.03, 0.03, 0.03)$。\n- 数据集 2：时间 $t_{2} = (0.5, 1.5, 2.5, 4.0, 6.0)$，观测值 $y_{2} = (2.46, 2.12, 1.86, 1.60, 1.39)$，不确定度 $\\sigma_{2} = (0.05, 0.05, 0.05, 0.05, 0.05)$。\n- 数据集 3：时间 $t_{3} = (0, 0.2, 0.4, 0.6, 0.8, 1.0)$，观测值 $y_{3} = (7.19, 6.82, 6.44, 6.11, 5.79, 5.49)$，不确定度 $\\sigma_{3} = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含：测试案例 1 的拟合 $\\tau$ 和 $B$，然后是测试案例 2 的拟合 $\\tau$ 和 $B$，接着是测试案例 3 的拟合 $\\tau$ 和 $B$。每个数字都表示为四舍五入到恰好三位小数，并以上述单位表示。例如，输出结构必须是\n$$\n[\\tau_1, B_1, \\tau_2, B_2, \\tau_3, B_3],\n$$\n其中每个条目都四舍五入到小数点后恰好三位，并隐式地以秒为单位表示 $\\tau$，以计数每秒为单位表示 $B$。", "solution": "所提出的问题是计算物理学中的一个标准练习：通过对物理模型进行非线性最小二乘拟合以应用于实验数据，从而进行参数估计。具体来说，我们的任务是对多个数据集进行全局分析，这些数据集被假定共享某些模型参数。该过程必须稳健，并基于可靠的统计学原理。\n\n验证步骤已确认该问题是适定的、科学上合理的且完整的。我们接下来进行求解。\n\n对于第 $k$ 个数据集，在时间 $t_{k,i}$ 的观测计数率 $y_{k,i}$ 的物理模型由下式给出：\n$$\nf(t_{k,i}; A_k, \\tau, B) = A_k e^{-t_{k,i}/\\tau} + B\n$$\n在这里，$A_k$ 是特定于数据集 $k$ 的振幅，而寿命 $\\tau$ 和恒定背景 $B$ 是全局参数，在单个测试案例中的所有数据集都是共同的。\n\n测量值被假定受到独立的、加性的高斯噪声的破坏，且具有已知的标准差 $\\sigma_{k,i}$。在此假设下，最大似然原理等同于最小化加权残差平方和，也称为卡方 ($\\chi^2$) 统计量。因此，要最小化的目标函数是：\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} w_{k,i} \\left[ y_{k,i} - f(t_{k,i}; A_k, \\tau, B) \\right]^2\n$$\n其中权重是方差的倒数，$w_{k,i} = 1/\\sigma_{k,i}^2$。展开模型函数，我们得到：\n$$\nS(\\{A_k\\}, \\tau, B) = \\sum_{k} \\sum_{i} \\left( \\frac{y_{k,i} - \\left(A_k e^{-t_{k,i}/\\tau} + B\\right)}{\\sigma_{k,i}} \\right)^2\n$$\n这是一个非线性优化问题。对于一个包含 $N_d$ 个数据集的给定测试案例，所有待确定的参数集合是 $\\{A_1, A_2, \\dots, A_{N_d}, \\tau, B\\}$。参数总数为 $N_d+2$。我们可以将这些参数表示为单个向量 $\\mathbf{p}$：\n$$\n\\mathbf{p} = (A_1, A_2, \\dots, A_{N_d}, \\tau, B)^T\n$$\n问题就变成了找到使目标函数 $S(\\mathbf{p})$ 最小化的参数向量 $\\mathbf{p}^*$：\n$$\n\\mathbf{p}^* = \\underset{\\mathbf{p}}{\\operatorname{argmin}} S(\\mathbf{p})\n$$\n此最小化过程必须遵循以下物理约束：\n$$A_k \\ge 0 \\quad \\forall k \\in \\{1, \\dots, N_d\\}$$\n$$\\tau > 0$$\n$$B \\ge 0$$\n\n为解决这个带约束的非线性优化问题，我们采用一种数值拟牛顿法，具体是在 `scipy.optimize.minimize` 函数中实现的带界限约束 (box constraints) 的 Broyden–Fletcher–Goldfarb–Shanno 算法 (L-BFGS-B)。该方法非常适合此类问题。\n\n每个测试案例的求解过程如下：\n1.  **数据聚合**：收集属于单个测试案例的所有数据集 $(t_k, y_k, \\sigma_k)$。数据集的数量 $N_d$ 决定了参数空间的维度。\n2.  **目标函数实现**：构建一个 Python 函数，用于在给定参数向量 $\\mathbf{p}$ 和聚合数据的情况下计算 $S(\\mathbf{p})$。该函数将 $\\mathbf{p}$ 解析为各个振幅 $\\{A_k\\}$、寿命 $\\tau$ 和背景 $B$，然后计算所有数据集的所有数据点的加权残差平方总和。\n3.  **初始化**：迭代优化算法需要一个参数的初始猜测值 $\\mathbf{p}_0$。虽然 L-BFGS-B 方法相对稳健，但一个合理的起始点可以提高收敛速度和可靠性。我们设计一个简单的自动化策略来生成 $\\mathbf{p}_0$：\n    -   初始背景 $B_0$ 取所有观测数据点 $y_{k,i}$ 中的最小值。\n    -   初始寿命 $\\tau_0$ 估计为实验总时间跨度的一部分。\n    -   每个初始振幅 $A_{k,0}$ 根据相应数据集的第一个数据点进行估计，并减去估计的背景：$A_{k,0} \\approx y_{k, \\text{first}} - B_0$。所有初始估计值都确保其不小于一个小的正数，以遵守非负约束。\n4.  **约束强制**：将物理约束转化为优化算法的界限约束。对于每个 $A_k$ 和 $B$，下界为 $0$，上界为无穷大。对于 $\\tau$，下界必须严格为正；我们使用一个小的机器精度值（例如，$10^{-9}$）来实际强制执行 $\\tau > 0$。\n5.  **优化**：使用目标函数、初始猜测向量 $\\mathbf{p}_0$、`L-BFGS-B` 方法以及定义的边界来调用 `scipy.optimize.minimize` 函数。该函数迭代地优化参数估计，直到满足收敛准则。\n6.  **结果提取**：成功收敛后，优化器返回最优参数向量 $\\mathbf{p}^*$。所需的共享寿命 $\\tau^*$ 和背景 $B^*$ 是该向量的最后两个分量。\n\n此过程被系统地应用于所提供的三个测试案例中的每一个。从每个案例中得到的 $\\tau$ 和 $B$ 的最终结果被收集起来，然后按指定格式进行格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves a series of global data fitting problems for exponential decay.\n\n    Each test case involves one or more datasets that are fit simultaneously\n    to a model y = A_k * exp(-t/tau) + B, where tau and B are shared across\n    datasets within a test case.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        [\n            (np.array([0, 0.5, 1.0, 1.5, 2.0, 3.0]), np.array([5.51, 4.38, 3.55, 2.86, 2.36, 1.62]), np.array([0.05, 0.05, 0.05, 0.05, 0.05, 0.05])),\n            (np.array([0, 0.7, 1.4, 2.1, 2.8, 3.5]), np.array([3.49, 2.62, 2.00, 1.54, 1.25, 1.03]), np.array([0.08, 0.08, 0.08, 0.08, 0.08, 0.08]))\n        ],\n        # Test Case 2\n        [\n            (np.array([0, 0.5, 1.0, 1.5, 2.0]), np.array([2.31, 1.50, 1.04, 0.75, 0.57]), np.array([0.02, 0.02, 0.02, 0.02, 0.02])),\n            (np.array([0, 1.0, 2.0, 3.0]), np.array([0.49, 0.38, 0.33, 0.31]), np.array([0.01, 0.01, 0.01, 0.01]))\n        ],\n        # Test Case 3\n        [\n            (np.array([0, 1.0, 2.0, 3.0, 5.0]), np.array([5.21, 4.05, 3.26, 2.67, 1.97]), np.array([0.03, 0.03, 0.03, 0.03, 0.03])),\n            (np.array([0.5, 1.5, 2.5, 4.0, 6.0]), np.array([2.46, 2.12, 1.86, 1.60, 1.39]), np.array([0.05, 0.05, 0.05, 0.05, 0.05])),\n            (np.array([0, 0.2, 0.4, 0.6, 0.8, 1.0]), np.array([7.19, 6.82, 6.44, 6.11, 5.79, 5.49]), np.array([0.02, 0.02, 0.02, 0.02, 0.02, 0.02]))\n        ]\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        num_datasets = len(case)\n\n        # Objective function for the current test case\n        def objective_function(p):\n            # p = [A1, A2, ..., Ak, tau, B]\n            amplitudes = p[:num_datasets]\n            tau = p[num_datasets]\n            B = p[num_datasets + 1]\n            \n            total_chi_squared = 0.0\n            for k in range(num_datasets):\n                t_k, y_k, sigma_k = case[k]\n                A_k = amplitudes[k]\n                \n                y_model_k = A_k * np.exp(-t_k / tau) + B\n                residuals = (y_k - y_model_k) / sigma_k\n                total_chi_squared += np.sum(residuals**2)\n            \n            return total_chi_squared\n\n        # Automated initial guesses\n        B_guess = np.min([np.min(d[1]) for d in case])\n        max_time = np.max([np.max(d[0]) for d in case])\n        tau_guess = max_time / 2.0 if max_time  0 else 1.0\n\n        A_guesses = []\n        for k in range(num_datasets):\n            y_first = case[k][1][0]\n            A_guess = max(1e-6, y_first - B_guess)\n            A_guesses.append(A_guess)\n            \n        p0 = A_guesses + [tau_guess, B_guess]\n\n        # Parameter bounds based on physical constraints\n        # Ak = 0, tau  0, B = 0\n        bounds = [(0, None)] * num_datasets  # Bounds for A_k\n        bounds.append((1e-9, None))           # Bound for tau\n        bounds.append((0, None))              # Bound for B\n\n        # Perform the optimization\n        res = minimize(objective_function, p0, method='L-BFGS-B', bounds=bounds)\n        \n        # Extract optimal shared parameters tau and B\n        optimal_tau = res.x[num_datasets]\n        optimal_B = res.x[num_datasets + 1]\n        \n        results.append(optimal_tau)\n        results.append(optimal_B)\n\n    # Format the final output string\n    print(f\"[{','.join(f'{x:.3f}' for x in results)}]\")\n\nsolve()\n```", "id": "2408092"}]}