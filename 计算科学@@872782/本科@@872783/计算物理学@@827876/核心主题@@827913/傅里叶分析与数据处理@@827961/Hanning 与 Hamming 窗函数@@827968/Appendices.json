{"hands_on_practices": [{"introduction": "窗函数的选择并非只有几个固定选项，而是在一系列权衡中进行。通过构建一个混合汉宁窗和汉明窗的“混合窗”，我们可以探索介于两者之间的设计空间。本练习将通过计算三个最重要的性能指标——主瓣宽度、峰值旁瓣电平和等效噪声带宽——来量化这种权衡。[@problem_id:2399871]", "problem": "您的任务是构建并分析一个混合离散时间窗函数，该函数由汉宁窗和汉明窗的凸组合形成。设窗长为 $N=128$，样本索引为 $n \\in \\{0,1,\\ldots,N-1\\}$。定义汉宁窗 $W_{Hanning}(n)$ 和汉明窗 $W_{Hamming}(n)$ 如下：\n$$\nW_{Hanning}(n) = \\tfrac{1}{2} - \\tfrac{1}{2}\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right), \\quad\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\n对于混合参数 $\\alpha \\in [0,1]$，定义混合窗\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n).\n$$\n设 $x[n]$ 为长度 $L=262144$ 的补零序列，定义为：当 $0 \\le n \\le N-1$ 时，$x[n]=W(n;\\alpha)$；其他情况下，$x[n]=0$。设 $X[k]$ 表示 $x[n]$ 的 $L$ 点离散傅里叶变换 (DFT)：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}, \\quad k=0,1,\\ldots,L-1.\n$$\n通过循环移位定义中心化频谱 $X_s[m]$\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad m=0,1,\\ldots,L-1,\n$$\n并设其对应的幅度为 $A[m]=|X_s[m]|$。设 $m_0 = \\tfrac{L}{2}$ 表示中心化频谱中直流 (DC) 分量的索引。定义 $m_L$ 和 $m_R$ 为满足 $m_L  m_0  m_R$ 的最近索引，使得 $A[m_L]$ 和 $A[m_R]$ 是离散序列 $A[m]$ 的严格局部最小值，并且在开区间 $(m_L,m_0)$ 和 $(m_0,m_R)$ 中分别没有其他严格局部最小值。\n\n使用这些定义，为每个给定的 $\\alpha$ 值计算以下三个标量指标：\n1. 主瓣宽度，以归一化频率（周期/样本）为单位，定义为\n$$\nw(\\alpha) = \\frac{m_R - m_L}{L}.\n$$\n2. 峰值旁瓣电平，以分贝为单位，定义为\n$$\n\\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\big\\{\\max_{0 \\le m  m_L} A[m],\\ \\max_{m_R  m \\le L-1} A[m]\\big\\}}{A[m_0]} \\right).\n$$\n3. 等效噪声带宽 (ENBW)，以 DFT 频点为单位，定义为\n$$\n\\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}.\n$$\n\n以上所有量均为无量纲。$\\mathrm{PSL}(\\alpha)$ 的分贝标度必须使用给定幅值比的以 10 为底的对数来计算。最终答案中不使用角度，因此不需要角度单位。\n\n测试套件：\n为以下五个 $\\alpha$ 值评估三元组 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$：\n- $\\alpha = 0.0$,\n- $\\alpha = 0.5$,\n- $\\alpha = 1.0$,\n- $\\alpha = 0.2$,\n- $\\alpha = 0.8$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是一个包含三个浮点数 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$ 的列表，对应于上面列出的相应 $\\alpha$ 值（按顺序列出）。每个浮点数必须四舍五入到六位小数。例如，一个有效的输出格式是\n$$\n\\big[\\,[w_1,\\mathrm{PSL}_1,\\mathrm{ENBW}_1],[w_2,\\mathrm{PSL}_2,\\mathrm{ENBW}_2],\\ldots\\,\\big],\n$$\n其中的确切数值由您的计算确定。", "solution": "所述问题定义明确、内部一致且科学上合理。它是在数字信号处理和计算物理学中的一个基本课题——数字窗函数分析方面的一个标准练习。我们将着手解决此问题。\n\n目标是通过计算三个标准性能指标：主瓣宽度、峰值旁瓣电平和等效噪声带宽，来合成并分析一个作为汉宁窗和汉明窗凸组合的混合窗函数。\n\n首先，我们定义构成窗和混合窗。窗长给定为 $N=128$，样本索引为 $n \\in \\{0, 1, \\dots, N-1\\}$。汉宁窗 $W_{Hanning}(n)$ 和汉明窗 $W_{Hamming}(n)$ 定义如下：\n$$\nW_{Hanning}(n) = \\frac{1}{2} - \\frac{1}{2}\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.5 - 0.5\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n$$\nW_{Hamming}(n) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{N-1}\\right) = 0.54 - 0.46\\cos\\left(\\frac{2\\pi n}{127}\\right)\n$$\n这些是窗函数的“对称”或“DFT-偶对称”版本，对于汉宁窗，其在第一个和最后一个样本处为零；对于汉明窗，则接近于零。混合窗 $W(n;\\alpha)$ 是通过由参数 $\\alpha \\in [0,1]$ 控制的线性插值形成的：\n$$\nW(n;\\alpha) = \\alpha\\, W_{Hanning}(n) + (1-\\alpha)\\, W_{Hamming}(n)\n$$\n当 $\\alpha=1$ 时，该窗为纯汉宁窗；当 $\\alpha=0$ 时，为纯汉明窗。汉宁窗以其良好的旁瓣滚降而闻名，而汉明窗则经过优化以最小化峰值旁瓣电平，但代价是主瓣稍宽。因此，参数 $\\alpha$ 在这些属性之间进行权衡。\n\n为分析该窗的频谱特性，我们考察其离散傅里叶变换 (DFT)。将长度为 $N$ 的窗序列补零至一个更大的长度 $L=262144$。这将创建一个长度为 $L$ 的新序列 $x[n]$。补零不会改变窗的底层连续谱，但它通过在更精细的频率网格上计算 DFT 来对频谱进行插值。这种密集采样对于精确测量如瓣宽和峰值电平等特征至关重要。$L$ 点 DFT $X[k]$ 计算如下：\n$$\nX[k] = \\sum_{n=0}^{L-1} x[n]\\,e^{-i\\,2\\pi kn/L}\n$$\n为了分析，频谱被循环移位，以将零频（DC）分量置于数组中心。中心化频谱 $X_s[m]$ 及其幅度 $A[m]$ 由下式给出：\n$$\nX_s[m] = X\\big((m + \\tfrac{L}{2}) \\bmod L\\big), \\quad A[m] = |X_s[m]|\n$$\n主瓣的峰值位于中心索引 $m_0 = L/2$ 处。\n\n有了这些定义，我们继续为每个给定的 $\\alpha$ 值计算三个指定的指标。\n\n1.  **等效噪声带宽 (ENBW)**：该指标衡量窗的有效带宽，如同它是一个理想的矩形滤波器，单位是 DFT 频点。它使用以下公式直接根据窗系数（而非补零序列）计算：\n    $$\n    \\mathrm{ENBW}(\\alpha) = N\\, \\frac{\\sum_{n=0}^{N-1} W(n;\\alpha)^2}{\\left(\\sum_{n=0}^{N-1} W(n;\\alpha)\\right)^2}\n    $$\n    此计算不需要 DFT。它衡量的是窗如何扩展白噪声信号的能量。\n\n2.  **主瓣宽度 ($w$)**：主瓣宽度是频率分辨率的关键指标。它由中心峰值两侧第一个零点（最小值）之间的距离定义。我们必须找到最接近中心峰值 $m_0$ 的严格局部最小值索引 $m_L$ 和 $m_R$。索引 $m$ 处的严格局部最小值由条件 $A[m]  A[m-1]$ 和 $A[m]  A[m+1]$ 定义。我们通过从 $m_0-1$ 向下搜索找到 $m_L$，并从 $m_0+1$ 向上搜索找到 $m_R$。主瓣宽度即为归一化频率差：\n    $$\n    w(\\alpha) = \\frac{m_R - m_L}{L}\n    $$\n\n3.  **峰值旁瓣电平 (PSL)**：PSL 量化了可能掩盖弱信号的频谱泄漏。它是最高旁瓣峰值相对于主瓣峰值的幅度，以分贝表示。旁瓣存在于主瓣之外的频谱区域，即索引 $m \\in [0, m_L-1] \\cup [m_R+1, L-1]$。峰值旁瓣幅度通过在这些区域上取 $A[m]$ 的最大值来找到。PSL 则为：\n    $$\n    \\mathrm{PSL}(\\alpha) = 20 \\log_{10} \\left( \\frac{\\max\\left\\{\\max_{0 \\le m  m_L} A[m], \\max_{m_R  m \\le L-1} A[m]\\right\\}}{A[m_0]} \\right)\n    $$\n    dB 值越负，表示旁瓣抑制效果越好。\n\n计算过程包括为测试套件 $\\{0.0, 0.5, 1.0, 0.2, 0.8\\}$ 中的每个 $\\alpha$ 值实施这些步骤，并收集得到的三元组 $[w(\\alpha), \\mathrm{PSL}(\\alpha), \\mathrm{ENBW}(\\alpha)]$。数值计算使用 `Python` 中的 `NumPy` 库执行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs and analyzes a hybrid Hanning-Hamming window function.\n    \n    For several mixing parameters alpha, it computes three metrics:\n    1. Mainlobe width (w)\n    2. Peak Sidelobe Level (PSL)\n    3. Equivalent Noise Bandwidth (ENBW)\n    \"\"\"\n\n    # --- Problem Parameters ---\n    N = 128           # Window length\n    L = 262144        # DFT length (zero-padding)\n    test_alphas = [0.0, 0.5, 1.0, 0.2, 0.8] # Mixing parameters\n\n    # --- Container for results ---\n    results = []\n\n    # --- Main loop over test cases ---\n    for alpha in test_alphas:\n        # Step 1: Construct the hybrid window function W(n; alpha)\n        n = np.arange(N, dtype=np.float64)\n        \n        w_hanning = 0.5 - 0.5 * np.cos(2 * np.pi * n / (N - 1))\n        w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n        \n        W = alpha * w_hanning + (1 - alpha) * w_hamming\n\n        # Step 2: Calculate Equivalent Noise Bandwidth (ENBW)\n        # This is calculated from the original window coefficients.\n        sum_W = np.sum(W)\n        sum_W_sq = np.sum(W**2)\n        enbw = N * sum_W_sq / (sum_W**2)\n\n        # Step 3: Compute the L-point DFT of the zero-padded window\n        # Create zero-padded sequence x[n]\n        x = np.zeros(L, dtype=np.float64)\n        x[:N] = W\n        \n        # Compute DFT and then shift it to center the DC component\n        X = np.fft.fft(x)\n        Xs = np.fft.fftshift(X)\n        A = np.abs(Xs)\n\n        # Step 4: Analyze the magnitude spectrum A[m] to find mainlobe width (w)\n        m0 = L // 2  # Index of the DC component (mainlobe peak)\n\n        # Find m_L, the first strict local minimum to the left of the peak\n        m_L = -1\n        # Search from m0-1 down to 1. Index m=0 is not checked for minimum.\n        for m in range(m0 - 1, 0, -1):\n            if A[m]  A[m - 1] and A[m]  A[m + 1]:\n                m_L = m\n                break\n        \n        # Find m_R, the first strict local minimum to the right of the peak\n        m_R = -1\n        # Search from m0+1 up to L-2. Index L-1 is not checked.\n        for m in range(m0 + 1, L - 1):\n            if A[m]  A[m - 1] and A[m]  A[m + 1]:\n                m_R = m\n                break\n\n        # A check for robustness, though minima should exist for these windows.\n        if m_L == -1 or m_R == -1:\n            raise ValueError(f\"Could not find mainlobe nulls for alpha = {alpha}\")\n\n        # Calculate mainlobe width in normalized frequency\n        w = (m_R - m_L) / L\n        \n        # Step 5: Calculate Peak Sidelobe Level (PSL)\n        A_m0 = A[m0] # Magnitude of the mainlobe peak\n        \n        # Find peak magnitude in the sidelobe regions\n        sidelobe_region_left = A[0:m_L]\n        sidelobe_region_right = A[m_R + 1:]\n        \n        peak_sidelobe = max(np.max(sidelobe_region_left), np.max(sidelobe_region_right))\n        \n        # Calculate PSL in decibels\n        psl = 20 * np.log10(peak_sidelobe / A_m0)\n\n        # Store the triple of metrics for this alpha\n        results.append([w, psl, enbw])\n    \n    # --- Final Output Formatting ---\n    # The output format is a string representation of a list of lists,\n    # with each float formatted to 6 decimal places.\n    outer_list_parts = []\n    for res_tuple in results:\n        inner_list_str = f\"[{res_tuple[0]:.6f},{res_tuple[1]:.6f},{res_tuple[2]:.6f}]\"\n        outer_list_parts.append(inner_list_str)\n\n    final_output_string = f\"[{','.join(outer_list_parts)}]\"\n\n    print(final_output_string)\n\nsolve()\n```", "id": "2399871"}, {"introduction": "在掌握了窗函数的基本性能指标后，我们将其应用于一个具体场景。假设一个信号由一个强分量和一个弱分量组成，哪个窗函数能更好地帮助我们“看清”弱分量？本练习将揭示，答案取决于分量之间的频率间隔，这直接关系到主瓣宽度（影响分辨率）和旁瓣电平（影响泄漏抑制）之间的核心权衡。[@problem_id:2399897]", "problem": "一个连续时间信号由两个幅度差异悬殊的正弦分量叠加而成： $$x(t) = \\sin(2\\pi f_1 t) + 10^{-4}\\,\\sin(2\\pi f_2 t),$$ 其中 $t$ 是以秒为单位的时间，$f_1$ 和 $f_2$ 是以赫兹为单位的频率。考虑使用采样频率 $f_s$ 对信号进行均匀采样，得到长度为 $N$ 的离散时间序列：$$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1,$$ 其中所有角度均以弧度为单位。为了在估计频谱时抑制频谱泄漏，在计算离散傅里叶变换 (DFT) 之前，数据会乘以一个窗函数 $w[n]$。我们将比较两种经典的窗函数：\n\n- Hann 窗（有时也称作“Hanning”窗）：$$w_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)\\right), \\quad n=0,1,\\dots,N-1.$$\n- Hamming 窗：$$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right), \\quad n=0,1,\\dots,N-1.$$\n\n从基本定义出发，时域加窗是 $x[n]$ 与 $w[n]$ 的乘法，而一个加窗信号 $x[n]w[n]$ 在一个 $N_{\\mathrm{FFT}}$ 点变换的频率仓 $k$ 处的 DFT 为：$$X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-j 2\\pi \\frac{k n}{N_{\\mathrm{FFT}}}}, \\quad k=0,1,\\dots,N_{\\mathrm{FFT}}-1,$$ 其中 $j$ 是虚数单位，$N_{\\mathrm{FFT}}$ 是一个用于补零以细化频谱采样的正整数。使用通过快速傅里叶变换 (FFT) 计算的、与 DFT 定义一致的单边幅度谱。\n\n你的任务是设计并实现一个算法，对于每个指定的测试用例，判断在存在强得多的分量 $f_1$ 的情况下，哪个窗函数能更好地“揭示”频率为 $f_2$ 的弱分量。为了使这个决策精确且可复现，为给定的窗函数 $w$ 定义以下检测优势度量：\n\n1. 选择一个 FFT 长度 $N_{\\mathrm{FFT}} = L N$，其中 $L$ 是一个固定的整数补零因子。\n2. 将以赫兹为单位的频率 $f$ 映射到最近的整数 FFT 频率仓索引 $k(f) = \\left\\lfloor \\frac{f}{f_s} N_{\\mathrm{FFT}} + \\tfrac{1}{2}\\right\\rfloor$。\n3. 对于一个固定的小整数 $K$，将 $f_2$ 周围的局部信号频带定义为频率仓 $k \\in \\{k(f_2)-K, \\dots, k(f_2)+K\\}$，并取 $$P_{\\mathrm{sig}}(w) = \\max_{k \\in \\{k(f_2)-K,\\dots,k(f_2)+K\\}} |X_w[k]|.$$\n4. 将 $f_2$ 周围的局部基底频带定义为频率仓 $k \\in \\{k(f_2)-B, \\dots, k(f_2)+B\\}$，但排除 $f_2$ 周围半宽为 $G$ 个频率仓的保护频带，即排除 $k \\in \\{k(f_2)-G, \\dots, k(f_2)+G\\}$。如果索引超出有效范围，则将其限制到最近的有效索引。计算 $$F_{\\mathrm{floor}}(w) = \\max_{\\substack{k \\in \\{k(f_2)-B,\\dots,k(f_2)+B\\} \\\\ k \\notin \\{k(f_2)-G,\\dots,k(f_2)+G\\}}} |X_w[k]|.$$\n5. 检测优势为 $$R(w) = \\frac{P_{\\mathrm{sig}}(w)}{F_{\\mathrm{floor}}(w)}.$$\n\n使用此度量，按如下方式声明测试用例中的更优窗函数：如果 $R(w_{\\mathrm{Hann}}) > R(w_{\\mathrm{Hamm}})$ 且超出相对容差 $\\varepsilon$，则输出 $1$；如果 $R(w_{\\mathrm{Hamm}}) > R(w_{\\mathrm{Hann}})$ 且超出该容差，则输出 $2$；如果两个优势在容差范围内，则输出 $0$。使用 $$\\varepsilon = 10^{-3}.$$ 容差比较必须按以下方式执行：$$\\left|R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\right| \\le \\varepsilon \\,\\max\\!\\left(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}})\\right).$$\n\n对所有测试用例，使用以下固定分析参数实现计算：\n- 补零因子 $L = 8$，因此 $N_{\\mathrm{FFT}} = 8N$。\n- 信号频带半宽 $K = 2$。\n- 基底频带半宽 $B = 400$。\n- 保护频带半宽 $G = 5$。\n\n物理和数值单位：\n- 频率 $f_s$、$f_1$、$f_2$ 以赫兹为单位。\n- 时间以秒为单位。\n- 三角函数内的角度以弧度为单位。\n\n测试套件：\n- 用例 1：$f_s = 32768$，$N = 8192$，$f_1 = 1000$，$f_2 = 10000$。\n- 用例 2：$f_s = 32768$，$N = 8192$，$f_1 = 5000$，$f_2 = 5000.5$。\n- 用例 3：$f_s = 48000$，$N = 4096$，$f_1 = 1000$，$f_2 = 1234$。\n\n你的程序必须使用上述规则为每个用例计算决策结果（一个在 $\\{0,1,2\\}$ 中的整数），并生成一行输出，其中包含三个结果，形式为方括号括起来的逗号分隔列表，例如 $$[r_1,r_2,r_3],$$ 其中 $r_i$ 按顺序对应于用例 $i$。不应打印任何其他文本。", "solution": "所述问题是有效的。这是一个在数字信号处理领域的良构且有科学依据的问题，而数字信号处理是计算物理与工程的一个基础领域。所有参数、定义和步骤都以足够的数学和算法严谨性进行了规定，从而可以得出一个唯一且可验证的解。问题中没有矛盾、歧义或违反既定科学原理之处。因此，我们可以着手求解。\n\n目标是比较 Hann 和 Hamming 窗函数在存在强正弦信号分量 $f_1$ 的情况下，分辨弱正弦信号分量 $f_2$ 的功效。这种比较不是定性的，而是基于一个定量的检测优势度量 $R(w)$，该度量定义为 $f_2$ 周围窄带内的信号峰值幅度与一个邻近但不连续频带内的频谱基底峰值幅度之比。频谱基底主要由强信号 $f_1$ 的泄漏组成。较高的 $R(w)$ 值表示能更好地将弱信号从这种泄漏背景中区分出来。\n\n这种比较的理论基础在于两种窗函数在频域中的不同特性。时域加窗等效于频域卷积。加窗正弦波的离散傅里叶变换 (DFT) 是窗函数自身变换的一个移位版本。\n- **Hann 窗** 的系数源自升余弦，其旁瓣衰减迅速（约每倍频程 $18$ dB）。此特性对于分辨频率间隔较大的信号非常有利，因为强信号的泄漏随距离的增加而迅速减小。\n- **Hamming 窗** 是对 Hann 窗的一种修正，它经过优化以最小化最高旁瓣的电平（相对于主瓣峰值约为 $-42.7$ dB）。这是以较慢的旁瓣衰减率为代价的。这对于分辨频率相近的信号很有利，因为此时强信号的最近旁瓣会造成最显著的干扰。\n\n因此，该问题提出的测试用例探究了这些不同的情况：大频率间隔（用例 1）、极小频率间隔（用例 2）和中等频率间隔（用例 3）。求解需要直接数值实现指定的算法。\n\n每个测试用例的步骤如下：\n\n1.  **信号和窗函数生成**：对于给定的参数集 $\\{f_s, N, f_1, f_2\\}$，我们根据以下公式生成长度为 $N$ 的离散时间信号 $x[n]$：\n    $$x[n] = \\sin\\!\\left(2\\pi \\frac{f_1}{f_s} n\\right) + 10^{-4}\\,\\sin\\!\\left(2\\pi \\frac{f_2}{f_s} n\\right), \\quad n=0,1,\\dots,N-1.$$\n    长度为 $N$ 的 Hann 和 Hamming 窗函数 $w_{\\mathrm{Hann}}[n]$ 和 $w_{\\mathrm{Hamm}}[n]$ 根据其定义生成：\n    $$w_{\\mathrm{Hann}}[n] = 0.5 - 0.5 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n    $$w_{\\mathrm{Hamm}}[n] = 0.54 - 0.46 \\cos\\!\\left(2\\pi \\frac{n}{N-1}\\right)$$\n\n2.  **频谱分析**：对于每个窗函数 $w[n]$，计算加窗信号 $x[n]w[n]$。然后使用快速傅里叶变换 (FFT) 算法计算该信号的 $N_{\\mathrm{FFT}}$ 点 DFT，并补零至长度 $N_{\\mathrm{FFT}} = L N = 8N$。这得到复数频谱 $X_w[k]$。幅度谱 $|X_w[k]|$ 用于后续计算。\n\n3.  **度量计算**：计算检测优势度量 $R(w)$。\n    a. 将频率 $f_2$ 映射到最近的整数 FFT 频率仓索引 $k(f_2) = \\left\\lfloor \\frac{f_2}{f_s} N_{\\mathrm{FFT}} + \\frac{1}{2}\\right\\rfloor$。\n    b. 通过在信号频带（定义为频率仓集合 $\\{k | k \\in [k(f_2)-K, k(f_2)+K]\\}$，其中 $K=2$）上取 $|X_w[k]|$ 的最大值，找到信号峰值幅度 $P_{\\mathrm{sig}}(w)$。\n    c. 通过在基底频带区域上取 $|X_w[k]|$ 的最大值，找到基底峰值幅度 $F_{\\mathrm{floor}}(w)$。该区域包括从 $k(f_2)-B$ 到 $k(f_2)+B$（$B=400$）的频率仓，但排除了从 $k(f_2)-G$ 到 $k(f_2)+G$（$G=5$）的中央保护频带。具体来说，最大值的搜索在两个不相交的索引范围的并集上进行：$[k(f_2)-B, k(f_2)-G-1]$ 和 $[k(f_2)+G+1, k(f_2)+B]$。任何超出有效范围 $[0, N_{\\mathrm{FFT}}-1]$ 的索引都将被限制在最近的边界上。\n    d. 检测优势是比率 $R(w) = P_{\\mathrm{sig}}(w) / F_{\\mathrm{floor}}(w)$。\n\n4.  **决策**：比较计算出的优势 $R(w_{\\mathrm{Hann}})$ 和 $R(w_{\\mathrm{Hamm}})$。根据指定的相对容差规则（$\\varepsilon = 10^{-3}$）做出决策：\n    - 如果 $|\\,R(w_{\\mathrm{Hann}}) - R(w_{\\mathrm{Hamm}})\\,| \\le \\varepsilon \\max(R(w_{\\mathrm{Hann}}), R(w_{\\mathrm{Hamm}}))$，则认为两个窗的性能等效，结果为 $0$。\n    - 如果 $R(w_{\\mathrm{Hann}})$ 大于 $R(w_{\\mathrm{Hamm}})$ 并超出了此容差，则 Hann 窗更优，结果为 $1$。\n    - 如果 $R(w_{\\mathrm{Hamm}})$ 大于 $R(w_{\\mathrm{Hann}})$ 并超出了此容差，则 Hamming 窗更优，结果为 $2$。\n\n对所提供的三个测试用例中的每一个都执行此完整步骤。最终输出是这些整数结果的有序列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.fft import fft\n\ndef solve():\n    # Define the fixed analysis parameters from the problem statement.\n    L = 8\n    K = 2\n    B = 400\n    G = 5\n    epsilon = 1e-3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (f_s, N, f_1, f_2)\n        (32768, 8192, 1000, 10000),\n        (32768, 8192, 5000, 5000.5),\n        (48000, 4096, 1000, 1234),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        f_s, N, f_1, f_2 = case\n        \n        N_fft = L * N\n        n = np.arange(N)\n        \n        # Generate the discrete-time signal\n        x_n = np.sin(2 * np.pi * f_1 / f_s * n) + 1e-4 * np.sin(2 * np.pi * f_2 / f_s * n)\n        \n        # Define the windows\n        windows = {\n            \"hann\": 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1))), # More stable than np.hanning(N) for precise definition\n            \"hamm\": 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))), # More stable than np.hamming(N) for precise definition\n        }\n        \n        adv_ratios = {}\n        \n        for name, w in windows.items():\n            # Apply the window to the signal\n            x_w = x_n * w\n            \n            # Compute the FFT and its magnitude\n            X_w = fft(x_w, n=N_fft)\n            mag_X_w = np.abs(X_w)\n            \n            # Map frequency f2 to the nearest integer bin index\n            k_f2 = int(np.round((f_2 / f_s) * N_fft))\n            \n            # 1. Compute P_sig(w)\n            sig_band_start = np.clip(k_f2 - K, 0, N_fft - 1)\n            sig_band_end = np.clip(k_f2 + K, 0, N_fft - 1)\n            P_sig = np.max(mag_X_w[sig_band_start : sig_band_end + 1])\n            \n            # 2. Compute F_floor(w)\n            # The floor is the max over two bands:\n            # [k_f2 - B, k_f2 - G - 1] and [k_f2 + G + 1, k_f2 + B]\n            \n            # Lower band\n            lower_band_start = k_f2 - B\n            lower_band_end = k_f2 - G - 1\n            \n            # Upper band\n            upper_band_start = k_f2 + G + 1\n            upper_band_end = k_f2 + B\n            \n            # Clamp indices to valid range [0, N_fft - 1]\n            c_lower_start = np.clip(lower_band_start, 0, N_fft - 1)\n            c_lower_end = np.clip(lower_band_end, 0, N_fft - 1)\n            c_upper_start = np.clip(upper_band_start, 0, N_fft - 1)\n            c_upper_end = np.clip(upper_band_end, 0, N_fft - 1)\n            \n            max_lower = 0.0\n            if c_lower_start = c_lower_end:\n                max_lower = np.max(mag_X_w[c_lower_start : c_lower_end + 1])\n            \n            max_upper = 0.0\n            if c_upper_start = c_upper_end:\n                max_upper = np.max(mag_X_w[c_upper_start : c_upper_end + 1])\n            \n            F_floor = np.max([max_lower, max_upper])\n            \n            # 3. Compute detection advantage R(w)\n            adv_ratios[name] = P_sig / F_floor if F_floor > 0 else np.inf\n\n        # Compare R(w_hann) and R(w_hamm)\n        R_hann = adv_ratios[\"hann\"]\n        R_hamm = adv_ratios[\"hamm\"]\n        \n        # Apply the decision rule with relative tolerance\n        if abs(R_hann - R_hamm) = epsilon * max(R_hann, R_hamm):\n            results.append(0)\n        elif R_hann > R_hamm:\n            results.append(1)\n        else: # R_hamm > R_hann\n            results.append(2)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399897"}, {"introduction": "本练习在前一个实践的基础上，专注于一个特定场景：当信号分量频率相距很远时。在这种情况下，峰值旁瓣电平的重要性不如旁瓣随频率增加而衰减的速度（即滚降率）。本练习旨在突出汉宁窗优越的旁瓣滚降特性，这对于在强干扰信号远处探测微弱信号至关重要。[@problem_id:2399887]", "problem": "给定两个作用于长度为 $N$ 的离散时间序列上的确定性窗函数：Hanning (Hann) 窗和 Hamming 窗。对于任意满足 $0 \\le n \\le N-1$ 的整数采样索引 $n$，Hanning 窗 $w_{\\mathrm{Hann}}[n]$ 和 Hamming 窗 $w_{\\mathrm{Hamming}}[n]$ 定义如下：\n$$\nw_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right),\n\\quad\nw_{\\mathrm{Hamming}}[n] = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right).\n$$\n考虑一个实值离散时间测试信号 $x[n]$，它由两个余弦波组成，其归一化频率（单位：周/采样点）分别为 $\\nu_0$ 和 $\\nu_1$，振幅分别为 $A_0$ 和 $A_1$，相位分别为 $\\phi_0$ 和 $\\phi_1$，具体由下式给出：\n$$\nx[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n + \\phi_0\\right) + A_1 \\cos\\!\\left(2\\pi \\nu_1 n + \\phi_1\\right), \\quad 0 \\le n \\le N-1.\n$$\n对于任意窗函数 $w[n]$，加窗信号 $x[n]w[n]$ 的 $N$ 点离散傅里叶变换 $X_w[k]$ 定义为：\n$$\nX_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-i 2\\pi kn/N}, \\quad 0 \\le k \\le N-1,\n$$\n并定义窗函数和归一化常数：\n$$\nS_w = \\sum_{n=0}^{N-1} w[n].\n$$\n令 $k_1$ 为最接近弱音频率 $\\nu_1$ 的离散傅里叶变换谱箱索引，定义为：\n$$\nk_1 = \\left\\lfloor \\nu_1 N + \\tfrac{1}{2} \\right\\rfloor \\bmod N.\n$$\n为了量化在强音频率 $\\nu_0$ 存在的情况下，弱音频率 $\\nu_1$ 是被揭示还是被掩盖，按以下步骤进行。对于给定的窗函数 $w[n]$，在谱箱 $k_1$ 处构建两个谱值：\n$$\nM_{\\mathrm{both},w} = \\frac{\\left|X^{(\\mathrm{both})}_w[k_1]\\right|}{S_w}, \\quad\nM_{\\mathrm{strong},w} = \\frac{\\left|X^{(\\mathrm{strong})}_w[k_1]\\right|}{S_w},\n$$\n其中 $X^{(\\mathrm{both})}_w[k]$ 是完整信号 $x[n]$ 的离散傅里叶变换，$X^{(\\mathrm{strong})}_w[k]$ 是将 $A_1$ 设置为 $0$ 后得到的信号（即只包含频率为 $\\nu_0$ 的强音）的离散傅里叶变换。定义信号泄漏比：\n$$\n\\mathrm{SLR}_w = \\frac{M_{\\mathrm{both},w}}{M_{\\mathrm{strong},w}},\n$$\n约定当 $M_{\\mathrm{strong},w}=0$ 时，如果 $M_{\\mathrm{both},w} > 0$，则结果视为 $+\\infty$；如果 $M_{\\mathrm{both},w} = 0$，则结果视为 $0$。当且仅当以下两个条件都成立时，宣告在使用窗函数 $w[n]$ 的情况下，频率为 $\\nu_1$ 的弱音被检测到：\n$$\n\\mathrm{SLR}_w \\ge r, \\quad M_{\\mathrm{both},w} \\ge \\theta,\n$$\n其中 $r$ 和 $\\theta$ 为给定阈值。\n\n您的任务是设计并分析一个测试信号，以突显 Hamming 窗和 Hanning 窗在远端旁瓣特性上的差异，使得 Hamming 窗相对较高的远端旁瓣掩盖了一个弱特征，而这个弱特征能被 Hanning 窗衰减更快的旁瓣所揭示。\n\n使用以下构成测试套件的固定参数值。在所有情况下，取 $N = 4096$，$\\phi_0 = 0$，$\\phi_1 = 0$， $r = 2$ 和 $\\theta = 10^{-5}$。$\\nu_0$ 和 $\\nu_1$ 的单位是 周/采样点。\n\n- 测试用例 1：$A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 10^{-4}$, $\\nu_1 = 0.6$。\n- 测试用例 2：$A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 5 \\times 10^{-3}$, $\\nu_1 = 0.6$。\n- 测试用例 3：$A_0 = 1$, $\\nu_0 = 0.101234567$, $A_1 = 10^{-6}$, $\\nu_1 = 0.6$。\n\n对于每个测试用例，使用上述检测规则，分别计算两个布尔值，以表明在使用 Hanning 窗和 Hamming 窗时，频率为 $\\nu_1$ 的弱音是否被检测到。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，并且本身是一个双元素列表 $[\\text{Hann\\_detected}, \\text{Hamming\\_detected}]$，其中包含布尔值字面量。例如，输出应具有以下形式：$[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$。", "solution": "该问题要求分析 Hanning 窗和 Hamming 窗函数的频谱特性。具体来说，我们需要构建一个场景，在该场景中，一个弱正弦信号在使用 Hamming 窗时被一个强而远的音调的频谱泄漏所掩盖，但在改用 Hanning 窗时能被正确检测到。这个练习展示了窗函数设计中的一个基本权衡：对近端旁瓣与远端旁瓣的抑制。\n\n首先，我们建立理论基础。有限长信号的离散傅里叶变换 (DFT) 内在地存在频谱泄漏问题。此现象的产生是因为对信号的隐式矩形窗处理，等效于真实信号频谱与矩形窗频谱（即 sinc 函数）的卷积。sinc 函数具有高幅值旁瓣，且衰减缓慢，速率为 $1/\\nu$，其中 $\\nu$ 是频率偏移。为了减少这种泄漏，可以将 Hanning 窗和 Hamming 窗等锥形窗函数应用于信号，以获得旁瓣低得多的频谱。\n\nHanning 窗和 Hamming 窗都是广义余弦窗函数族的一员。它们的定义如下：\n$$\nw_{\\mathrm{Hann}}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right) = 0.5 - 0.5\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\n$$\n$$\nw_{\\mathrm{Hamming}}[n] = 0.54 - 0.46\\cos\\!\\left(\\tfrac{2\\pi n}{N-1}\\right)\n$$\n对于从 $0$ 到 $N-1$ 的采样索引 $n$。系数的选择决定了它们的频谱特性。Hanning 窗表现出优秀的远端旁瓣抑制能力，其频谱包络以大约每倍频程 $18$ dB（$_~1/\\nu^3$）的速率衰减。然而，它的主瓣更宽，且其第一旁瓣相对较高，约为主瓣峰值的 $-31.5$ dB。\n\n相比之下，Hamming 窗被优化以最小化最高旁瓣的幅度，实现了约 $-42.8$ dB 的峰值旁瓣电平。这是以更慢的渐近衰减为代价的。Hamming 窗频谱的远端旁瓣仅以每倍频程 $6$ dB（$_~1/\\nu$）的速率衰减，这并不比矩形窗好。\n\n本问题旨在利用这一差异。频率为 $\\nu_0$ 的强音被放置在远离频率为 $\\nu_1$ 的弱音的位置。因此，在对应于弱音的频率谱箱 $k_1$ 处，来自强音的频谱泄漏由窗函数变换的*远端*旁瓣决定。我们预计，在这样大的频率间隔下，Hamming 窗的泄漏本底噪声将远高于 Hanning 窗。\n\n验证这一点的计算步骤如下：\n\n1.  对于每个测试用例，我们给定振幅 $A_0, A_1$ 和归一化频率 $\\nu_0, \\nu_1$。信号长度固定为 $N=4096$，相位为 $\\phi_0 = \\phi_1 = 0$。我们在 $n \\in [0, N-1]$ 上生成两个离散时间信号：\n    $$\n    x^{(\\mathrm{both})}[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n\\right) + A_1 \\cos\\!\\left(2\\pi \\nu_1 n\\right)\n    $$\n    $$\n    x^{(\\mathrm{strong})}[n] = A_0 \\cos\\!\\left(2\\pi \\nu_0 n\\right)\n    $$\n\n2.  我们根据定义生成长度为 $N=4096$ 的 Hanning 窗序列 $w_{\\mathrm{Hann}}[n]$ 和 Hamming 窗序列 $w_{\\mathrm{Hamming}}[n]$。\n\n3.  对于每个窗函数 $w[n]$，我们计算加窗信号，例如 $x^{(\\mathrm{both})}[n]w[n]$。然后，我们使用以下公式计算它们的 $N$ 点 DFT，$X^{(\\mathrm{both})}_w[k]$ 和 $X^{(\\mathrm{strong})}_w[k]$：\n    $$\n    X_w[k] = \\sum_{n=0}^{N-1} x[n]\\,w[n]\\,e^{-i 2\\pi kn/N}\n    $$\n\n4.  我们确定弱音的目标频率谱箱 $k_1$。当 $\\nu_1 = 0.6$ 和 $N=4096$ 时，该索引为：\n    $$\n    k_1 = \\left\\lfloor \\nu_1 N + \\tfrac{1}{2} \\right\\rfloor \\bmod N = \\left\\lfloor 0.6 \\times 4096 + 0.5 \\right\\rfloor \\bmod 4096 = \\left\\lfloor 2457.6 + 0.5 \\right\\rfloor = 2458\n    $$\n\n5.  我们计算窗函数和归一化常数，$S_{\\mathrm{Hann}} = \\sum w_{\\mathrm{Hann}}[n]$ 和 $S_{\\mathrm{Hamming}} = \\sum w_{\\mathrm{Hamming}}[n]$。\n\n6.  对于每个窗函数，我们计算在谱箱 $k_1$ 处的归一化 DFT 幅值：\n    $$\n    M_{\\mathrm{both},w} = \\frac{\\left|X^{(\\mathrm{both})}_w[k_1]\\right|}{S_w}, \\quad\n    M_{\\mathrm{strong},w} = \\frac{\\left|X^{(\\mathrm{strong})}_w[k_1]\\right|}{S_w}\n    $$\n    $M_{\\mathrm{strong},w}$ 表示从强音泄漏到目标谱箱中的频谱。$M_{\\mathrm{both},w}$ 表示此泄漏与来自弱音的贡献的相干和。\n\n7.  我们计算信号泄漏比 $\\mathrm{SLR}_w = M_{\\mathrm{both},w} / M_{\\mathrm{strong},w}$。问题指定了处理 $M_{\\mathrm{strong},w}=0$ 的情况，尽管在这里这种情况物理上不大可能发生。\n\n8.  最后，对于每个窗函数和每个测试用例，我们应用检测规则。当且仅当满足以下两个条件时，弱音被检测到：\n    $$\n    \\mathrm{SLR}_w \\ge r, \\quad M_{\\mathrm{both},w} \\ge \\theta\n    $$\n    其中阈值给定为 $r=2$ 和 $\\theta=10^{-5}$。\n\n两个音调之间的间隔为 $\\Delta \\nu = |\\nu_1 - \\nu_0| = |0.6 - 0.101234567| \\approx 0.499$，这是一个非常大的频率偏移。在此偏移下，Hanning 窗的 $-18$ dB/倍频程滚降将导致泄漏幅值 $M_{\\mathrm{strong, Hann}}$ 远小于 Hamming 窗，后者的 $-6$ dB/倍频程滚降将产生更大的 $M_{\\mathrm{strong, Hamming}}$。这将直接影响 $\\mathrm{SLR}$ 准则。\n\n-   对于测试用例 1 ($A_1=10^{-4}$): 弱音的振幅适中。Hanning 窗的低泄漏应产生一个较大的 $\\mathrm{SLR}_{\\mathrm{Hann}}$，从而导致检测成功。Hamming 窗的高泄漏将使 $M_{\\mathrm{strong, Hamming}}$ 与弱音的贡献相当，因此 $M_{\\mathrm{both, Hamming}} \\approx M_{\\mathrm{strong, Hamming}}$，从而 $\\mathrm{SLR}_{\\mathrm{Hamming}} \\approx 1$，未能通过 $\\mathrm{SLR} \\ge 2$ 的测试。\n-   对于测试用例 2 ($A_1=5 \\times 10^{-3}$): 弱音要强得多。它对 $M_{\\mathrm{both},w}$ 的贡献将主导两个窗的泄漏项。因此，在两种情况下都有 $M_{\\mathrm{both},w} \\gg M_{\\mathrm{strong},w}$，从而导致较大的 $\\mathrm{SLR}_w$ 并且两者都能成功检测。\n-   对于测试用例 3 ($A_1=10^{-6}$): 弱音极其微弱。弱音自身谱峰的幅值大约为 $A_1/2 = 5 \\times 10^{-7}$。这低于绝对检测阈值 $\\theta = 10^{-5}$。因此，我们预测对于任一窗口，$M_{\\mathrm{both},w}$ 都将无法达到该阈值，导致两种情况下都检测不到。\n\n现在将实施该算法以确认此分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the detection of a weak sinusoidal signal in the presence of a strong\n    one using Hanning and Hamming windows, based on specified criteria.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    N = 4096\n    phi0 = 0.0\n    phi1 = 0.0\n    r_threshold = 2.0\n    theta_threshold = 1e-5\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 1e-4, 'nu1': 0.6},\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 5e-3, 'nu1': 0.6},\n        {'A0': 1.0, 'nu0': 0.101234567, 'A1': 1e-6, 'nu1': 0.6},\n    ]\n\n    results = []\n\n    # Discrete time sequence index\n    n = np.arange(N)\n\n    # Generate window functions\n    w_hann = 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1)))\n    w_hamming = 0.54 - 0.46 * np.cos(2 * np.pi * n / (N - 1))\n    windows = {'Hann': w_hann, 'Hamming': w_hamming}\n\n    for case in test_cases:\n        A0, nu0, A1, nu1 = case['A0'], case['nu0'], case['A1'], case['nu1']\n\n        # Generate test signals\n        x_strong = A0 * np.cos(2 * np.pi * nu0 * n + phi0)\n        x_both = x_strong + A1 * np.cos(2 * np.pi * nu1 * n + phi1)\n\n        # Calculate the target bin index for the weak tone\n        k1 = int(np.floor(nu1 * N + 0.5)) % N\n\n        case_results = []\n        # Process for both Hanning and Hamming windows\n        for window_name in ['Hann', 'Hamming']:\n            w = windows[window_name]\n\n            # Calculate window-sum normalization constant\n            S_w = np.sum(w)\n\n            # Apply windowing and compute DFTs\n            X_strong_w = np.fft.fft(x_strong * w)\n            X_both_w = np.fft.fft(x_both * w)\n\n            # Calculate normalized magnitudes at bin k1\n            M_strong_w = np.abs(X_strong_w[k1]) / S_w\n            M_both_w = np.abs(X_both_w[k1]) / S_w\n            \n            # Calculate Signal-to-Leakage Ratio (SLR)\n            if M_strong_w == 0.0:\n                slr_w = np.inf if M_both_w > 0.0 else 0.0\n            else:\n                slr_w = M_both_w / M_strong_w\n\n            # Apply detection criteria\n            is_detected = (slr_w >= r_threshold) and (M_both_w >= theta_threshold)\n            case_results.append(is_detected)\n            \n        results.append(case_results)\n\n    # Format the final output string as specified\n    inner_parts = [f\"[{str(hann_res)},{str(hamming_res)}]\" for hann_res, hamming_res in results]\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n    \n    print(final_output_str.replace(\"'\", \"\"))\n\nsolve()\n```", "id": "2399887"}]}