{"hands_on_practices": [{"introduction": "求解拉普拉斯方程是计算物理中的一项基本任务。在此实践中，您将把二维的五点差分格式扩展到三维的七点差分格式，从而直接在三维网格上实现雅可比松弛法。这项练习将巩固您对核心雅可比算法的理解，并锻炼您在三维空间中建模物理系统的关键技能。[@problem_id:2404972]", "problem": "考虑一个在笛卡尔坐标系中占据区域 $[0,1]^3$ 的中空、完美导电立方体内部的静电势。电势 $V(x,y,z)$ 在开放单位立方体内满足三维拉普拉斯方程，即偏微分方程 (PDE) $\\nabla^2 V = 0$，并带有狄利克雷边界条件 (BC)。立方体恰好有一个面保持在固定电势 $V_0$（单位：伏特），而其他五个面保持在 $0$ 伏特（接地）。处于电势 $V_0$ 的特定面由一个坐标轴标签 $a \\in \\{x,y,z\\}$ 标识，并且总是“正”面，即如果 $a=x$，则为平面 $x=1$；如果 $a=y$，则为平面 $y=1$；如果 $a=z$，则为平面 $z=1$。\n\n在一个均匀网格上对单位立方体进行离散化，每个坐标方向上有 $N$ 个内部点，因此包括边界在内，每个轴的总网格点数为 $N+2$，网格间距为 $h = \\frac{1}{N+1}$。令 $U_{i,j,k}$ 表示在网格点 $(x_i,y_j,z_k) = (i\\,h,j\\,h,k\\,h)$ 处的离散电势，其中整数索引 $i,j,k \\in \\{0,1,\\dots,N+1\\}$。对所有边界点施加 $U_{i,j,k}=0$，除了位于由 $a$ 指定的“正”侧的单个面上的点，在这些点上 $U_{i,j,k}=V_0$。\n\n通过以下规则在该网格上定义一个网格函数序列 $\\{U^{(m)}\\}_{m=0}^{\\infty}$：\n- 对所有 $1 \\le i,j,k \\le N$ 的内部值进行初始化，设为 $U^{(0)}_{i,j,k}=0$，而所有边界值由上述狄利克雷边界条件设定，并对所有的 $m$ 保持不变。\n- 对于每个整数 $m \\ge 0$，通过离散调和平均关系\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\n为所有 $1 \\le i,j,k \\le N$ 的内部点定义下一个迭代值，同时在每次迭代中保持边界值不变。\n- 对于给定的容差 $\\varepsilon > 0$，定义停止时间 $K$ 为最小的非负整数，使得在执行 $K$ 次完整扫描（每次扫描通过上述平均规则更新所有内部点一次）后，以下条件成立：\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right|  \\varepsilon,\n$$\n约定不使用 $U^{(-1)}$（因此，严格不等式第一次可以被评估是在一次扫描之后，即对于 $K \\ge 1$）。报告 $K$ 为截至并包括第一次满足严格不等式的扫描所执行的扫描次数。\n\n对于每种情况，还需报告最接近几何中心 $(\\tfrac{1}{2},\\tfrac{1}{2},\\tfrac{1}{2})$ 的单个网格节点处的离散电势值（单位：伏特）。令 $n = N+2$ 为每个轴上的总网格点数；则每个方向上最近的中心索引为 $c = \\operatorname{round}\\!\\big(\\tfrac{1}{2}(n-1)\\big)$，报告的中心值为 $U^{(K)}_{c,c,c}$（单位：伏特）。\n\n测试套件：\n为以下参数集 $(N,\\varepsilon,V_0,a)$ 提供结果：\n- 情况 A（一般实例）：$(N,\\varepsilon,V_0,a) = (10,\\,10^{-3},\\,1,\\,z)$。\n- 情况 B（最小内部，两次扫描内达到精确离散不动点）：$(N,\\varepsilon,V_0,a) = (1,\\,10^{-12},\\,1,\\,x)$。\n- 情况 C（退化边界数据）：$(N,\\varepsilon,V_0,a) = (6,\\,5\\times 10^{-3},\\,0,\\,y)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个双元素列表 $[K, U^{(K)}_{c,c,c}]$。例如，输出格式必须为\n\"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\n其中 $K_A$、$K_B$、$K_C$ 是整数，$V_A$、$V_B$、$V_C$ 是代表伏特的浮点数。所有电势必须以伏特表示。不涉及角度。输出中不出现百分比；所有量均为原始整数或浮点数。", "solution": "该问题要求在单位立方体内求解三维拉普拉斯方程 $\\nabla^2 V = 0$ 的数值解，并遵循狄利克雷边界条件。立方体的所有六个面上都指定了电势 $V$：一个面保持在恒定电势 $V_0$，而其他五个面接地（电势为 $0$）。这是静电学中的一个标准问题，描述了无电荷区域内的电势。\n\n连续问题在均匀的笛卡尔网格上进行离散化。区域 $[0,1]^3$ 被划分为一个网格，每个轴上有 $N+2$ 个点，网格间距为 $h = \\frac{1}{N+1}$。网格点 $(x_i, y_j, z_k) = (ih, jh, kh)$ 处的离散电势用 $U_{i,j,k}$ 表示，其中索引 $i,j,k \\in \\{0, 1, \\dots, N+1\\}$。\n\n拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2} + \\frac{\\partial^2}{\\partial z^2}$ 在每个内部网格点 $(i,j,k)$ 处使用二阶中心差分格式进行近似：\n$$\n\\nabla^2 V \\bigg|_{(x_i,y_j,z_k)} \\approx \\frac{U_{i+1,j,k} - 2U_{i,j,k} + U_{i-1,j,k}}{h^2} + \\frac{U_{i,j+1,k} - 2U_{i,j,k} + U_{i,j-1,k}}{h^2} + \\frac{U_{i,j,k+1} - 2U_{i,j,k} + U_{i,j,k-1}}{h^2}\n$$\n将此近似值设为 $0$ 会得到一个关于未知内部电势的线性方程组。对 $U_{i,j,k}$ 的项进行重新整理，得到离散调和平均性质：\n$$\nU_{i,j,k} = \\frac{1}{6}\\Big(U_{i+1,j,k} + U_{i-1,j,k} + U_{i,j+1,k} + U_{i,j-1,k} + U_{i,j,k+1} + U_{i,j,k-1}\\Big)\n$$\n此方程必须对所有内部点成立，即对所有 $1 \\le i,j,k \\le N$ 成立。\n\n问题指定使用雅可比法 (Jacobi method) 来求解这个线性系统。这是一种迭代松弛技术。给定内部网格上电势的初始猜测值 $U^{(0)}$，生成一个精化的近似序列 $\\{U^{(m)}\\}_{m=0}^{\\infty}$。从迭代 $m$到 $m+1$ 的更新是通过对所有内部点同时应用离散调和平均规则来定义的，仅使用上一次迭代 $m$ 的值：\n$$\nU^{(m+1)}_{i,j,k} = \\frac{1}{6}\\Big(U^{(m)}_{i+1,j,k} + U^{(m)}_{i-1,j,k} + U^{(m)}_{i,j+1,k} + U^{(m)}_{i,j-1,k} + U^{(m)}_{i,j,k+1} + U^{(m)}_{i,j,k-1}\\Big)\n$$\n在整个过程中，边界值保持恒定。所有内部点的初始猜测值被指定为 $U^{(0)}_{i,j,k}=0$。\n\n迭代持续进行，直到解收敛。收敛性由一个基于连续迭代之间电势值最大变化的停止准则来确定。当整个网格上的最大绝对差首次低于给定容差 $\\varepsilon$ 时，过程在第一次迭代 $K \\ge 1$ 处终止：\n$$\n\\max_{0 \\le i,j,k \\le N+1} \\left| U^{(K)}_{i,j,k} - U^{(K-1)}_{i,j,k} \\right|  \\varepsilon\n$$\n报告迭代次数 $K$ 和最接近立方体几何中心的网格点处的最终电势 $U^{(K)}_{c,c,c}$。中心索引 $c$ 的计算公式为 $c = \\operatorname{round}\\!\\big(\\frac{1}{2}((N+2)-1)\\big)$。\n\n实现过程如下：\n1.  初始化两个大小为 $(N+2) \\times (N+2) \\times (N+2)$ 的三维数组 `U` 和 `U_next`，分别表示当前和下一个迭代步的电势。\n2.  对两个数组都施加狄利克雷边界条件。对于给定的轴 $a$ 和电势 $V_0$，该轴正端（$x=1$，$y=1$ 或 $z=1$）的面被设置为 $V_0$。其余的边界面和初始内部点被设置为 $0$。\n3.  执行一个迭代循环。在每次迭代 $m$ 中，使用雅可比更新规则的向量化版本，从 `U`（表示 $U^{(m-1)}$）计算 `U_next`（表示 $U^{(m)}$），用于所有内部点。\n4.  计算 `U_next` 和 `U` 之间的最大绝对差。\n5.  将 `U_next` 中的值复制到 `U`，为后续迭代做准备。\n6.  当最大差值小于 $\\varepsilon$ 时，循环终止。最终的迭代计数 $K$ 是执行的扫描次数。\n7.  从收敛后的网格 `U` 中提取中心索引 $(c,c,c)$ 处的最终电势。\n\n测试用例如下：\n- 情况 A：$(N,\\varepsilon,V_0,a) = (10, 10^{-3}, 1, z)$ 是一个具有合理细化网格的标准情况。\n- 情况 B：$(N,\\varepsilon,V_0,a) = (1, 10^{-12}, 1, x)$ 代表一个只有一个内部网格点的最小问题。雅可比迭代在 $K=2$ 步内收敛到精确离散解，因为第二次更新不产生任何变化。\n- 情况 C：$(N,\\varepsilon,V_0,a) = (6, 5 \\times 10^{-3}, 0, y)$ 是一个 $V_0=0$ 的退化情况。所有边界电势均为 $0$，初始内部电势也为 $0$。唯一解是处处为 $U=0$。算法在一步（$K=1$）内收敛，因为初始状态已经是固定点，所以第一次迭代后的差值为零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other non-standard libraries are used.\n\ndef solve_case(N, epsilon, V0, a):\n    \"\"\"\n    Solves the 3D Laplace equation on a unit cube using Jacobi relaxation.\n\n    Args:\n        N (int): Number of interior points in each dimension.\n        epsilon (float): Convergence tolerance.\n        V0 (float): Potential on the high-potential face.\n        a (str): Axis ('x', 'y', or 'z') of the high-potential face.\n\n    Returns:\n        list: A list containing [K, central_potential], where K is the number\n              of iterations and central_potential is the potential at the\n              grid point nearest the center.\n    \"\"\"\n    n = N + 2  # Total number of grid points per axis including boundaries\n\n    # Initialize U for iteration m and U_next for iteration m+1.\n    # Start with U^(0) = 0 everywhere.\n    U = np.zeros((n, n, n), dtype=np.float64)\n\n    # Apply Dirichlet boundary conditions.\n    # All faces are at 0V (grounded) by default.\n    # We only need to set the face at V0.\n    if V0 != 0:\n        if a == 'x':\n            U[N + 1, :, :] = V0\n        elif a == 'y':\n            U[:, N + 1, :] = V0\n        elif a == 'z':\n            U[:, :, N + 1] = V0\n            \n    # U_next must also have the boundary conditions.\n    U_next = U.copy()\n\n    K = 0\n    while True:\n        K += 1\n\n        # Perform one sweep of Jacobi relaxation.\n        # Update interior points of U_next based on values in U.\n        # This is the vectorized form of the 7-point stencil update.\n        U_next[1:-1, 1:-1, 1:-1] = (\n            U[0:-2, 1:-1, 1:-1] + U[2:, 1:-1, 1:-1] +\n            U[1:-1, 0:-2, 1:-1] + U[1:-1, 2:, 1:-1] +\n            U[1:-1, 1:-1, 0:-2] + U[1:-1, 1:-1, 2:]\n        ) / 6.0\n\n        # Calculate the maximum absolute difference between the new and old grids.\n        # The maximum is taken over all points, including boundaries.\n        max_diff = np.max(np.abs(U_next - U))\n\n        # Prepare for the next iteration by copying U_next to U.\n        U = U_next.copy()\n\n        # Check for convergence.\n        if max_diff  epsilon:\n            break\n            \n    # Find the index of the grid point nearest to the geometric center.\n    c = int(round(0.5 * (n - 1)))\n    \n    central_potential = U[c, c, c]\n    \n    return [K, central_potential]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, epsilon, V0, a)\n        (10, 1e-3, 1.0, 'z'),      # Case A\n        (1, 1e-12, 1.0, 'x'),      # Case B\n        (6, 5e-3, 0.0, 'y'),      # Case C\n    ]\n\n    results = []\n    for case in test_cases:\n        N, epsilon, V0, a = case\n        result = solve_case(N, epsilon, V0, a)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation of a list in Python includes a space after the comma,\n    # which matches the format example '[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]'.\n    # The provided template code produces this format correctly.\n    inner_parts = []\n    for pair in results:\n        # Manually format each inner list to avoid locale-specific representations\n        # and ensure consistency with the problem's example format '[K, V]'.\n        inner_parts.append(f\"[{pair[0]}, {pair[1]}]\")\n    \n    # The example format shows spaces between elements: \"[ [K_A, V_A], [K_B, V_B], [K_C, V_C] ]\"\n    final_output_string = f\"[{', '.join(inner_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2404972"}, {"introduction": "真实的物理系统通常具有复杂的内部结构，而不仅仅是简单的边界。本练习将探讨如何调整雅可比松弛法，以包含一个“内部”边界条件——即区域内一个电势被固定的点。通过比较有无此内部约束的解，您将深入理解格林函数在离散系统中的作用，并学会使用您的求解器进行数值实验，量化一个局部扰动对全局场的影响。[@problem_id:2405011]", "problem": "给定一个方形域上的二维拉普拉斯方程，该域具有均匀的笛卡尔离散化和狄利克雷边界条件。考虑一个边长为 $1$ 米的方形域，离散化为一个 $N \\times N$ 个节点的均匀网格，网格间距为 $h = \\dfrac{1}{N-1}$ 米。设网格索引为零基索引，其中 $i \\in \\{0,\\dots,N-1\\}$ 为垂直坐标（从下到上）的索引，$j \\in \\{0,\\dots,N-1\\}$ 为水平坐标（从左到右）的索引。在每个严格内部节点 $(i,j)$ （即 $1 \\le i \\le N-2$ 且 $1 \\le j \\le N-2$）处的离散拉普拉斯方程为\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0,\n$$\n这等价于\n$$\n\\phi_{i,j} = \\frac{1}{4}\\left(\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1}\\right).\n$$\n在边界上，每个边都规定了狄利克雷值：底边 $i=0$，顶边 $i=N-1$，左边 $j=0$，右边 $j=N-1$。在四个角节点处，即两条边规定相交的地方，边界值定义为两条入射边上规定值的算术平均值。所有电势必须以伏特为单位进行处理和报告。\n\n任务是研究在全局离散解中引入单个内部狄利克雷约束（一个“内部”固定电压点）的影响。对于给定的一组边界边值和一个指定的内部节点 $(i^\\star,j^\\star)$ 及其固定的内部电压 $V^\\star$，定义两个离散解：\n- $\\phi^{(0)}$: 满足边界上的狄利克雷条件且无内部约束的唯一离散调和函数；\n- $\\phi^{(\\mathrm{int})}$: 满足边界上相同的狄利克雷条件以及内部狄利克雷约束 $\\phi_{i^\\star,j^\\star} = V^\\star$ 的唯一离散调和函数。\n\n对于每种情况，计算这两个解在整个网格上的均方根（RMS）差，\n$$\nD = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2},\n$$\n以伏特为单位表示。\n\n如果在所有网格节点上，连续迭代之间的最大绝对变化量一致地严格小于指定的容差 $\\varepsilon$（单位为伏特），或者达到了指定的最大迭代次数，则认为离散解是可接受的。使用容差 $\\varepsilon = 10^{-6}$ 伏特，最大迭代次数为 $200{,}000$。\n\n测试套件。对于每个测试，您必须计算上面定义的 $D$。以下三个测试指定了 $N$、每条边上的边界电压、以及内部点及其固定电压。对 $(i^\\star,j^\\star)$ 使用零基索引。\n- 测试 $1$ (一般情况):\n  - $N = 41$。\n  - 边界电压：顶边 $1.0$ 伏特，底边 $0.0$ 伏特，左边 $0.0$ 伏特，右边 $0.0$ 伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (20,20)$，电压 $V^\\star = 0.75$ 伏特。\n- 测试 $2$ (内部点靠近边界):\n  - $N = 21$。\n  - 边界电压：左边 $1.0$ 伏特，顶边 $0.0$ 伏特，底边 $0.0$ 伏特，右边 $0.0$ 伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (10,2)$，电压 $V^\\star = 0.20$ 伏特。\n- 测试 $3$ (零边界，仅有内部源):\n  - $N = 11$。\n  - 边界电压：顶边 $0.0$ 伏特，底边 $0.0$ 伏特，左边 $0.0$ 伏特，右边 $0.0$ 伏特。\n  - 内部约束：$(i^\\star,j^\\star) = (5,5)$，电压 $V^\\star = 1.00$ 伏特。\n\n您的程序必须为每个测试计算满足指定容差的离散方程解 $\\phi^{(0)}$ 和 $\\phi^{(\\mathrm{int})}$，然后计算均方根差 $D$（单位为伏特）。最终的程序输出必须是单行文本，包含测试 1 到测试 3 的三个 $D$ 值列表，按顺序排列，四舍五入到 $6$ 位小数，并严格格式化为方括号内由逗号分隔且无空格的列表（例如，\"[0.123456,0.000001,1.234567]\"）。", "solution": "所提出的问题是有效的。这是计算物理学中的一个标准练习，涉及在笛卡尔网格上使用有限差分法求解二维拉普拉斯方程。选择的方法是Jacobi松弛法，这是一种用于求解此类离散化产生的线性方程组的经典迭代技术。该问题定义明确，科学上合理，并为其明确的解决方案提供了所有参数。\n\n控制方程是拉普拉斯方程 $\\nabla^2 \\phi = 0$。对于具有均匀笛卡尔网格（间距为 $h$）的二维域，在节点 $(i,j)$ 处对拉普拉斯算子 $\\nabla^2$ 进行二阶中心差分近似，得到离散方程：\n$$\n\\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2} = 0\n$$\n这可以重新整理，将电势 $\\phi_{i,j}$ 表示为其四个最近邻点的平均值，这构成了Jacobi迭代更新规则的基础：\n$$\n\\phi_{i,j}^{(k+1)} = \\frac{1}{4}\\left(\\phi_{i+1,j}^{(k)} + \\phi_{i-1,j}^{(k)} + \\phi_{i,j+1}^{(k)} + \\phi_{i,j-1}^{(k)}\\right)\n$$\n其中上标 $(k)$ 表示迭代次数。此更新同时应用于网格的所有严格内部节点，即索引 $i,j$ 在范围 $[1, N-2]$ 内。\n\n解决每个测试用例问题的总体算法如下：\n\n1.  **网格初始化**：对于给定的网格尺寸 $N \\times N$，创建一个表示电势 $\\phi$ 的数组。根据问题规范设置边界值。四个角节点的电势设置为两条相交边电势的算术平均值。例如，左下角 $(i=0, j=0)$ 的电势设置为 $\\phi_{0,0} = \\frac{1}{2}(V_{\\text{bottom}} + V_{\\text{left}})$，其中 $V_{\\text{bottom}}$ 和 $V_{\\text{left}}$ 分别是相应边上的电压。\n\n2.  **求解 $\\phi^{(0)}$ (无约束解)**：\n    - 从初始化的网格开始，应用Jacobi迭代。在每次迭代中，计算一个新的电势值网格，其中每个内部点的值是其邻点在前一次迭代网格中值的平均值。\n    - 重复此过程，直到满足收敛准则。当任意节点上两次连续迭代之间的最大电势绝对差 $\\max(|\\phi^{(k+1)} - \\phi^{(k)}|)$ 小于指定的容差 $\\varepsilon = 10^{-6}$ 伏特时，即达到收敛。如果达到最大迭代次数 $200,000$ 次，迭代也会终止。\n    - 得到的网格即为离散解 $\\phi^{(0)}$。\n\n3.  **求解 $\\phi^{(\\mathrm{int})}$ (有约束解)**：\n    - 该过程与求解 $\\phi^{(0)}$ 的过程几乎相同，但有一个关键的修改。在特定节点 $(i^\\star, j^\\star)$ 处引入一个内部狄利克雷约束，将其电势固定为 $V^\\star$。\n    - 对所有内部节点执行Jacobi迭代。在更新步骤之后，将约束节点处的值重置为其固定值 $\\phi_{i^\\star, j^\\star} = V^\\star$。这在整个迭代过程中强制执行内部约束。\n    - 应用相同的收敛准则。得到的网格即为离散解 $\\phi^{(\\mathrm{int})}$。\n\n4.  **计算均方根差**：一旦 $\\phi^{(0)}$ 和 $\\phi^{(\\mathrm{int})}$ 都计算完毕，就使用提供的公式计算它们在整个 $N \\times N$ 网格上的均方根（RMS）差 $D$：\n    $$\n    D = \\sqrt{\\frac{1}{N^2}\\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left(\\phi^{(\\mathrm{int})}_{i,j} - \\phi^{(0)}_{i,j}\\right)^2}\n    $$\n    该度量量化了由引入单个内部固定电压点引起的电势场的平均全局扰动。\n\n实现将使用 Python 和 NumPy 库进行，NumPy 库允许在网格上进行高效的向量化操作。一个单独的函数封装了Jacobi求解器，能够处理无约束和有约束两种情况。对于三个测试用例中的每一种情况（$\\phi^{(0)}$ 和 $\\phi^{(\\mathrm{int})}$），都会调用此函数来计算所需的解。最终的 $D$ 值列表按要求进行格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right,\n                  interior_constraint=None, tol=1e-6, max_iter=200000):\n    \"\"\"\n    Solves the 2D Laplace equation on a square grid using Jacobi relaxation.\n\n    Args:\n        N (int): The number of nodes along one dimension of the grid.\n        bc_top (float): Voltage on the top edge.\n        bc_bottom (float): Voltage on the bottom edge.\n        bc_left (float): Voltage on the left edge.\n        bc_right (float): Voltage on the right edge.\n        interior_constraint (tuple, optional): A tuple (i, j, V) specifying an\n            interior fixed-voltage point. Defaults to None.\n        tol (float, optional): Convergence tolerance. Defaults to 1e-6.\n        max_iter (int, optional): Maximum number of iterations. Defaults to 200000.\n\n    Returns:\n        numpy.ndarray: The converged potential field phi.\n    \"\"\"\n    phi = np.zeros((N, N), dtype=np.float64)\n\n    # Apply boundary conditions to edges\n    phi[N-1, :] = bc_top      # Top edge (i = N-1)\n    phi[0, :] = bc_bottom     # Bottom edge (i = 0)\n    phi[:, 0] = bc_left       # Left edge (j = 0)\n    phi[:, N-1] = bc_right    # Right edge (j = N-1)\n\n    # Apply boundary conditions to corners (arithmetic mean)\n    phi[0, 0] = (bc_bottom + bc_left) / 2.0\n    phi[0, N-1] = (bc_bottom + bc_right) / 2.0\n    phi[N-1, 0] = (bc_top + bc_left) / 2.0\n    phi[N-1, N-1] = (bc_top + bc_right) / 2.0\n\n    # If an interior constraint exists, retrieve its details\n    if interior_constraint:\n        i_star, j_star, v_star = interior_constraint\n        phi[i_star, j_star] = v_star\n\n    for _ in range(max_iter):\n        phi_old = phi.copy()\n\n        # Vectorized Jacobi update for all interior points\n        phi[1:-1, 1:-1] = 0.25 * (\n            phi_old[2:, 1:-1] +   # phi_{i+1, j}\n            phi_old[:-2, 1:-1] +  # phi_{i-1, j}\n            phi_old[1:-1, 2:] +   # phi_{i, j+1}\n            phi_old[1:-1, :-2]    # phi_{i, j-1}\n        )\n\n        # Re-enforce the interior constraint after the update\n        if interior_constraint:\n            phi[i_star, j_star] = v_star\n\n        # Check for convergence across the whole grid\n        max_change = np.max(np.abs(phi - phi_old))\n        if max_change  tol:\n            break\n\n    return phi\n\ndef calculate_rms_difference(case_params):\n    \"\"\"\n    Calculates the RMS difference D for a given test case.\n    \n    Args:\n        case_params (tuple): Contains N, boundary conditions, and interior constraint.\n    \n    Returns:\n        float: The computed RMS difference D.\n    \"\"\"\n    N, bcs, int_constr = case_params\n    bc_top, bc_bottom, bc_left, bc_right = bcs\n\n    # Solve for phi^(0) (unconstrained)\n    phi_0 = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right)\n    \n    # Solve for phi^(int) (with interior constraint)\n    phi_int = jacobi_solver(N, bc_top, bc_bottom, bc_left, bc_right, \n                            interior_constraint=int_constr)\n    \n    # Calculate the RMS difference D\n    rms_diff = np.sqrt(np.mean((phi_int - phi_0)**2))\n    \n    return rms_diff\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: N=41, top=1V, others=0V, constraint=(20,20) at 0.75V\n        (41, (1.0, 0.0, 0.0, 0.0), (20, 20, 0.75)),\n        # Test 2: N=21, left=1V, others=0V, constraint=(10,2) at 0.20V\n        (21, (0.0, 0.0, 1.0, 0.0), (10, 2, 0.20)),\n        # Test 3: N=11, all=0V, constraint=(5,5) at 1.00V\n        (11, (0.0, 0.0, 0.0, 0.0), (5, 5, 1.00)),\n    ]\n\n    results = []\n    for case in test_cases:\n        D = calculate_rms_difference(case)\n        results.append(D)\n\n    # Final print statement in the exact required format.\n    formatted_results = ','.join([f\"{res:.6f}\" for res in results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2405011"}, {"introduction": "许多物理现象由泊松方程 $\\nabla^2 u = f$ 描述，这是包含源项的拉普拉斯方程的推广。此外，周期性边界条件在模拟无限或环形系统时比固定边界条件更为合适。这项高级实践将要求您求解二维泊松方程，并同时实现周期性和狄利克雷两种边界条件，在此过程中您还会遇到并处理周期性问题所特有的基本可解性条件。掌握这项练习将使您能够处理更广泛的物理问题，并加深您对偏微分方程边值问题数学基础的理解。[@problem_id:2404984]", "problem": "考虑二维泊松偏微分方程 (PDE) $$\\nabla^2 u(x,y) = f(x,y)$$，定义在单位正方形域 $$\\Omega = [0,1]\\times[0,1]$$ 上，其中三角函数中的所有角度均以弧度为单位。您将实现雅可比松弛法 (Jacobi relaxation method) 来求解该方程在两种不同边界模型下的有限差分格式，然后量化边界模型的选择如何影响解的结构。这两种边界模型是：(i) 环面上的周期性边界条件（对边等同），以及 (ii) 方形域上的齐次狄利克雷边界条件（边界值为零）。对于周期性模型，请注意其可解性要求右端项的均值为零。\n\n您的实现必须从以下基本基础开始：\n- 泊松方程 $$\\nabla^2 u = f$$ 的定义，即梯度的散度，及其在间距为 $$h$$ 的均匀网格上使用二阶中心差分的有限差分离散化。\n- 雅可比松弛格式，它是一种通过分离五点模板的中心点而获得的不动点迭代。\n- 周期性泊松问题的可解性条件，该条件通过在域上对 $$\\nabla^2 u = f$$ 积分并利用散度定理和周期性得到。\n\n基于这些基础，为每种边界模型推导均匀网格上的雅可比松弛更新规则：\n- 周期性边界条件：每个网格点都有四个邻居，采用环绕索引；离散拉普拉斯算子使用周期性平移。\n- 齐次狄利克雷边界条件：解在边界上固定为 $$0$$；仅使用其邻居点和边界值来更新内部未知数。\n\n使用每个维度有 $$N_x=N_y$$ 个点的均匀网格。对于周期性模型，将网格放置在平坦环面上，点为 $$x_i = i/N_x$$ 和 $$y_j = j/N_y$$，其中 $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$，间距为 $$h_p = 1/N_x$$。对于狄利克雷模型，使用点 $$x_i = i/(N_x-1)$$ 和 $$y_j = j/(N_y-1)$$，其中 $$i,j \\in \\{0,1,\\dots,N_x-1\\}$$，间距为 $$h_d = 1/(N_x-1)$$，并在边界索引 $$i=0$$、$$i=N_x-1$$、$$j=0$$、$$j=N_y-1$$ 上强制 $$u=0$$。\n\n实现雅可比格式，初始猜测为零，停止准则基于残差的相对离散 $$L^2$$ 范数。设残差为 $$r = f - \\Delta_h u$$，其中 $$\\Delta_h$$ 表示经过适当边界处理的标准五点离散拉普拉斯算子。定义相对残差为 $$\\|r\\|_2 / \\|f\\|_2$$，其中 $$\\|g\\|_2 = \\left(\\sum_{i,j} g_{i,j}^2 \\, h^2\\right)^{1/2}$$ 使用相应的网格间距 $$h\\in\\{h_p,h_d\\}$$。当相对残差低于指定容差或达到最大迭代次数时停止。对于周期性模型，如果 $$f$$ 的离散均值，即 $$\\bar f = \\frac{1}{N_x N_y} \\sum_{i,j} f_{i,j}$$ 的量级非零且高于一个小阈值，则离散问题不可解；在这种情况下，报告周期性求解器不收敛（不要试图通过减去其均值来“修正”$$f$$）。\n\n测试套件和要求的输出：\n- 测试用例 $$1$$（周期性，均值为零的解析模式）：使用 $$N_x=N_y=64$$ 和 $$f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$$。使用周期性边界条件求解，直到相对残差容差低于 $$10^{-8}$$ 或达到最多 $$6000$$ 次雅可比迭代，以先到者为准。将数值解与此模式下周期性五点拉普拉斯算子的离散傅里叶模式解进行比较。具体来说，对于网格函数 $$f_{i,j} = \\sin(2\\pi x_i)\\sin(2\\pi y_j)$$，精确满足 $$\\Delta_h u = f$$ 的相应离散解是 $$u^\\star = -f/\\lambda_d$$，其中 $$\\lambda_d = \\frac{8}{h_p^2}\\sin^2\\!\\left(\\frac{\\pi}{N_x}\\right)$$。将相对 $$L^2$$ 误差 $$\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$$ 报告为浮点数。\n- 测试用例 $$2$$（周期性，不可解的强迫项）：使用 $$N_x=N_y=64$$ 和 $$f(x,y) \\equiv 1$$（值为 $$1$$ 的常数网格函数）。尝试在相同的容差和迭代上限下使用周期性边界条件求解。检测 $$f$$ 的非零均值，并报告一个布尔值，指示求解器是否因离散问题不可解而正确地拒绝收敛。此用例的预期输出是布尔值 $$\\mathrm{False}$$，表示因违反可解性条件而未收敛。\n- 测试用例 $$3$$（周期性与狄利克雷的结构效应）：使用由 $$f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$$ 定义的一对问题，采用相同的容差和迭代上限。分别在 $$64\\times 64$$ 环面网格上（间距 $$h_p=1/64$$）使用周期性边界条件求解一次，以及在 $$65\\times 65$$ 方形网格上（间距 $$h_d=1/64$$）使用齐次狄利克雷边界条件求解一次。使用各自的间距计算两个数值解的 $$L^2$$ 范数，即 $$\\|u_{\\mathrm{per}}\\|_2$$ 和 $$\\|u_{\\mathrm{dir}}\\|_2$$。报告浮点比率 $$R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$$。\n\n角度单位规范：所有三角函数必须使用弧度。\n\n最终输出格式：您的程序应生成单行输出，其中包含按上述三个测试用例顺序排列的结果，形式为方括号内以逗号分隔的列表。即，输出必须为 $$[e_1,b_2,R_3]$$ 格式，其中 $$e_1$$ 是测试用例 $$1$$ 的浮点相对误差，$$b_2$$ 是测试用例 $$2$$ 的布尔值，$$R_3$$ 是测试用例 $$3$$ 的浮点比率。例如，$$[0.00012,False,1.73]$$。", "solution": "所述问题是有效的。它构成了计算物理学领域中一个适定的练习，要求实现并分析用于二维泊松方程的雅可比松弛法。该问题具有科学依据，没有矛盾，并为每个测试用例提供了计算唯一且有意义的解所需的所有数据和条件。我们继续进行推导和求解。\n\n控制偏微分方程是在二维域 $\\Omega = [0,1]\\times[0,1]$ 上的泊松方程：\n$$ \\nabla^2 u(x,y) = f(x,y) $$\n其中 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子。为了数值求解该方程，我们将域 $\\Omega$ 离散化为一个均匀的点网格 $(x_i, y_j)$，在两个坐标方向上的间距均为 $h$。函数 $u(x,y)$ 由其在该网格上的值 $u_{i,j} = u(x_i, y_j)$ 表示。\n\n二阶偏导数使用二阶中心有限差分进行近似：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n将这些近似代入泊松方程，得到拉普拉斯算子的离散五点模板表示，记为 $\\Delta_h$：\n$$ (\\Delta_h u)_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = f_{i,j} $$\n该方程为未知的网格值 $u_{i,j}$ 构成了一个大型线性代数方程组。\n\n雅可比松弛法是求解该方程组的一种迭代格式。它通过重新整理离散方程以分离中心点 $u_{i,j}$ 而导出：\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j} $$\n$$ u_{i,j} = \\frac{1}{4} (u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - h^2 f_{i,j}) $$\n这个代数恒等式通过使用上一次迭代（索引为 $k$）的值来评估右侧，从而计算下一次迭代（索引为 $k+1$）的值，转化为一个不动点迭代：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k)} - h^2 f_{i,j} \\right) $$\n从一个初始猜测 $u^{(0)}$ 开始，该公式被重复应用于所有网格点，直到解收敛。邻近点 $(u_{i\\pm 1, j}, u_{i, j\\pm 1})$ 的处理取决于边界条件。\n\n对于周期性边界条件，网格代表一个环面。域 $\\Omega$ 被认为其对边是等同的。使用一个 $N_x \\times N_y$ 点的网格，其中 $x_i = i/N_x$ 和 $y_j = j/N_y$，$i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。网格间距为 $h_p = 1/N_x$。索引以 $N_x$ 和 $N_y$ 为模进行处理，因此对于一个点 $(i,j)$，其邻居是 $((i\\pm 1) \\pmod{N_x}, j)$ 和 $(i, (j\\pm 1) \\pmod{N_y})$。一个关键的可解性条件来自于在域上对偏微分方程进行积分：$\\int_\\Omega \\nabla^2 u \\, dA = \\int_\\Omega f \\, dA$。散度定理将左侧转化为边界积分 $\\oint_{\\partial\\Omega} \\nabla u \\cdot \\mathbf{n} \\, dS$，对于周期性函数，该积分为零。因此，我们必须有 $\\int_\\Omega f \\, dA = 0$。其离散模拟是 $\\sum_{i,j} f_{i,j} = 0$。如果强迫函数 $f$ 的均值非零，则解不存在，雅可比迭代将不会收敛。\n\n对于齐次狄利克雷边界条件，解在方形域的边界上固定为零：$u(x,y)=0$ 对于 $(x,y) \\in \\partial\\Omega$。使用一个 $N_x \\times N_y$ 点的网格，其中 $x_i = i/(N_x-1)$ 和 $y_j = j/(N_y-1)$，$i,j \\in \\{0, \\dots, N_x-1\\}$。网格间距为 $h_d = 1/(N_x-1)$。边界点是那些索引为 $i=0$、$i=N_x-1$、$j=0$ 或 $j=N_y-1$ 的点。雅可比更新仅应用于内部网格点，其中 $i,j \\in \\{1, \\dots, N_x-2\\}$。对于与边界相邻的内部点，更新公式直接使用已知的边界零值。\n\n算法流程如下：\n1. 初始化解网格，$u^{(0)}_{i,j} = 0$。\n2. 对于每次迭代 $k=0, 1, 2, \\dots$ 直到达到最大值：\n   a. 使用适合边界条件的雅可比更新规则，从 $u^{(k)}$ 计算下一个迭代值 $u^{(k+1)}$。\n   b. 计算离散残差网格 $r^{(k+1)} = f - \\Delta_h u^{(k+1)}$。离散拉普拉斯算子 $\\Delta_h$ 也必须遵守边界条件。\n   c. 计算残差的离散相对 $L^2$ 范数：$\\frac{\\|r^{(k+1)}\\|_2}{\\|f\\|_2}$，其中范数定义为 $\\|g\\|_2 = \\sqrt{\\sum_{i,j} g_{i,j}^2 h^2}$。\n   d. 如果相对残差低于指定的容差 $\\epsilon$，迭代已收敛并终止。\n3. 对于周期性情况，必须对可解性条件 $|\\sum_{i,j} f_{i,j}|  \\delta$ 进行初步检查，其中 $\\delta$ 为某个小的数值容差。如果违反此条件，求解器必须报告不收敛。\n\n此过程应用于三个指定的测试用例。\n\n用例 1：周期性问题，其中 $N_x=N_y=64$ 且 $f(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。此强迫函数的均值为零，因此存在解。将数值解 $u$ 与精确离散解 $u^\\star = -f/\\lambda_d$ 进行比较，其中 $\\lambda_d = \\frac{8}{h_p^2}\\sin^2(\\frac{\\pi}{N_x})$ 是此模式下离散拉普拉斯算子的精确特征值。计算相对误差 $\\|u-u^\\star\\|_2/\\|u^\\star\\|_2$。\n\n用例 2：周期性问题，其中 $N_x=N_y=64$ 且 $f(x,y)=1$。$f$ 的离散均值为 $1$，违反了可解性条件。求解器应检测到这一点并且不收敛。要求的输出是 `False`。\n\n用例 3：比较周期性解和狄利克雷解，其中 $f(x,y) = \\cos(2\\pi x) + \\cos(2\\pi y)$。网格间距保持为 $h=1/64$。对于周期性情况，这需要一个 $64 \\times 64$ 的网格。对于狄利克雷情况，这需要一个 $65 \\times 65$ 的网格。计算所得解的 $L^2$ 范数之比 $R = \\|u_{\\mathrm{per}}\\|_2 / \\|u_{\\mathrm{dir}}\\|_2$，以量化由边界条件施加的结构性差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n\n    def get_l2_norm(grid, h):\n        \"\"\"Calculates the discrete L2 norm: sqrt(sum(g_ij^2 * h^2)).\"\"\"\n        # Note: np.linalg.norm computes the Frobenius norm sqrt(sum(g_ij^2)).\n        return h * np.linalg.norm(grid)\n\n    def apply_laplacian(u, h, bc_type):\n        \"\"\"Applies the 5-point discrete Laplacian to a grid u.\"\"\"\n        if bc_type == 'periodic':\n            # Use np.roll for efficient periodic boundary handling.\n            u_i_plus = np.roll(u, -1, axis=1)\n            u_i_minus = np.roll(u, 1, axis=1)\n            u_j_plus = np.roll(u, -1, axis=0)\n            u_j_minus = np.roll(u, 1, axis=0)\n            lap_u = (u_i_plus + u_i_minus + u_j_plus + u_j_minus - 4.0 * u) / (h**2)\n        elif bc_type == 'dirichlet':\n            # Create a zero-padded laplacian grid and fill the interior.\n            lap_u = np.zeros_like(u)\n            # Central difference on the interior of the grid.\n            lap_u[1:-1, 1:-1] = (u[1:-1, 2:] + u[1:-1, :-2] + u[2:, 1:-1] + u[:-2, 1:-1] - 4.0 * u[1:-1, 1:-1]) / (h**2)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n        return lap_u\n\n    def jacobi_solver(N, f_func, bc_type, tol, max_iter):\n        \"\"\"\n        Solves the 2D Poisson equation using Jacobi relaxation.\n\n        Args:\n            N (int): Number of grid points in each dimension (Nx=Ny=N).\n            f_func (function): The forcing function f(x, y).\n            bc_type (str): 'periodic' or 'dirichlet'.\n            tol (float): Relative residual tolerance for convergence.\n            max_iter (int): Maximum number of iterations.\n        \n        Returns:\n            A tuple (u, h, converged_flag) or (None, h, converged_flag) for non-solvable periodic case.\n        \"\"\"\n        if bc_type == 'periodic':\n            h = 1.0 / N\n            x = np.linspace(0, 1.0 - h, N)\n        elif bc_type == 'dirichlet':\n            h = 1.0 / (N - 1)\n            x = np.linspace(0, 1.0, N)\n        else:\n            raise ValueError(\"Unknown boundary condition type.\")\n            \n        xv, yv = np.meshgrid(x, x, indexing='ij')\n        f = f_func(xv, yv)\n        u = np.zeros_like(f)\n\n        if bc_type == 'periodic':\n            # Check solvability condition for periodic problem.\n            mean_f = np.mean(f)\n            if abs(mean_f) > 1e-12:\n                # The problem is not solvable.\n                return None, h, False\n\n        f_norm = get_l2_norm(f, h)\n        if f_norm == 0:\n            # If f is zero everywhere, u=0 is the solution.\n            return u, h, True\n\n        for k in range(max_iter):\n            u_old = u.copy()\n            \n            if bc_type == 'periodic':\n                u_i_plus = np.roll(u_old, -1, axis=1)\n                u_i_minus = np.roll(u_old, 1, axis=1)\n                u_j_plus = np.roll(u_old, -1, axis=0)\n                u_j_minus = np.roll(u_old, 1, axis=0)\n                u = 0.25 * (u_i_plus + u_i_minus + u_j_plus + u_j_minus - h**2 * f)\n            else: # dirichlet\n                # Update only interior points\n                u[1:-1, 1:-1] = 0.25 * (u_old[1:-1, 2:] + u_old[1:-1, :-2] + \\\n                                       u_old[2:, 1:-1] + u_old[:-2, 1:-1] - h**2 * f[1:-1, 1:-1])\n\n            # Check for convergence\n            lap_u = apply_laplacian(u, h, bc_type)\n            residual = f - lap_u\n            residual_norm = get_l2_norm(residual, h)\n            \n            if residual_norm / f_norm  tol:\n                return u, h, True\n        \n        # If loop finishes, max iterations were reached without convergence.\n        # This is also considered non-convergence for the purpose of the problem.\n        return u, h, False\n\n    results = []\n    \n    # --- Test Case 1: Periodic, analytic mode ---\n    N1 = 64\n    tol1 = 1e-8\n    max_iter1 = 6000\n    f1_func = lambda x, y: np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n    \n    u1, h1, _ = jacobi_solver(N1, f1_func, 'periodic', tol1, max_iter1)\n    \n    # Analytic discrete solution\n    lambda_d = (8.0 / h1**2) * (np.sin(np.pi / N1)**2)\n    x1 = np.linspace(0, 1.0 - h1, N1)\n    xv1, yv1 = np.meshgrid(x1, x1, indexing='ij')\n    f1 = f1_func(xv1, yv1)\n    u_star1 = -f1 / lambda_d\n    \n    # Relative L2 error\n    error_norm = get_l2_norm(u1 - u_star1, h1)\n    ustar_norm = get_l2_norm(u_star1, h1)\n    relative_error = error_norm / ustar_norm\n    results.append(relative_error)\n\n    # --- Test Case 2: Periodic, non-solvable forcing ---\n    N2 = 64\n    tol2 = 1e-8\n    max_iter2 = 6000\n    f2_func = lambda x, y: np.ones_like(x)\n    \n    # Solver will detect non-zero mean and return converged_flag=False.\n    _, _, converged2 = jacobi_solver(N2, f2_func, 'periodic', tol2, max_iter2)\n    # As per prompt, output False for non-convergence.\n    results.append(converged2)\n\n    # --- Test Case 3: Periodic vs. Dirichlet ---\n    f3_func = lambda x, y: np.cos(2 * np.pi * x) + np.cos(2 * np.pi * y)\n    tol3 = 1e-8\n    max_iter3 = 6000\n    \n    # Periodic solution\n    # N=64 gives h=1/64\n    u_per, h_per, _ = jacobi_solver(64, f3_func, 'periodic', tol3, max_iter3)\n    norm_per = get_l2_norm(u_per, h_per)\n    \n    # Dirichlet solution\n    # N=65 gives h=1/64\n    u_dir, h_dir, _ = jacobi_solver(65, f3_func, 'dirichlet', tol3, max_iter3)\n    norm_dir = get_l2_norm(u_dir, h_dir)\n    \n    # Ratio of norms\n    ratio = norm_per / norm_dir\n    results.append(ratio)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2404984"}]}