{"hands_on_practices": [{"introduction": "我们的第一个实践将解决计算物理学中的一个核心挑战：当简单的显式方法因稳定性限制而失效时，如何模拟长时间尺度上的扩散过程。你将实现无条件稳定的Crank-Nicolson方法来求解一维热方程 [@problem_id:2402549]。通过将数值解与已知的解析解进行比较，你将练习代码验证的关键技能，并对数值精度有更具体的理解。", "problem": "考虑一维热传导进入一个半无限均匀固体。温度场 $T(x,t)$ 满足热方程（一个偏微分方程 (PDE)）\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\,\\frac{\\partial^2 T}{\\partial x^2}, \\quad x > 0, \\; t > 0,\n$$\n其中 $\\alpha$ 是热扩散率。该固体最初处于均匀温度，位于 $x=0$ 的表面突然升温并保持在一个较高的温度。为了计算数值近似解，用一个有限区间 $[0,L]$ 来近似半无限域，并使用以下适定的初始和边界条件：\n- 初始条件：对于所有 $x \\in (0,L]$，$T(x,0) = T_0$。\n- 表面边界条件：对于所有 $t > 0$，$T(0,t) = T_s$。\n- 远端边界条件：对于所有 $t > 0$，$\\frac{\\partial T}{\\partial x}(L,t) = 0$。\n\n在这些条件下，半无限域（无有限-$L$ 截断）的精确解析解是已知的，由下式给出\n$$\nT_{\\text{exact}}(x,t) = T_0 + \\bigl(T_s - T_0\\bigr)\\,\\mathrm{erfc}\\!\\left(\\frac{x}{2\\sqrt{\\alpha t}}\\right), \\quad x \\ge 0, \\; t > 0,\n$$\n其中 $\\mathrm{erfc}$ 表示互补误差函数。\n\n您的任务是，对于每个指定的参数集，在截断域 $[0,L]$ 上，使用一个具有 $N_x$ 个等尺寸子区间的均匀空间网格（因此网格点为 $x_i = i\\,\\Delta x$，其中 $\\Delta x = L/N_x$，对于 $i=0,1,\\dots,N_x$）和一个均匀时间步长 $\\Delta t$（因此到 $t_f$ 的时间步数是 $t_f/\\Delta t$，在测试套件中保证为整数），计算在最终时间 $t = t_f$ 时 $T(x,t)$ 的数值近似解。然后，在网格 $\\{x_i\\}_{i=0}^{N_x}$ 上，计算数值解 $T_{\\text{num}}(x_i,t_f)$ 和精确解 $T_{\\text{exact}}(x_i,t_f)$ 之间的最大绝对误差（单位为开尔文）：\n$$\nE_{\\max} = \\max_{0 \\le i \\le N_x} \\left| T_{\\text{num}}(x_i,t_f) - T_{\\text{exact}}(x_i,t_f) \\right|.\n$$\n\n所有物理单位必须一致使用：长度单位为米（$\\mathrm{m}$），时间单位为秒（$\\mathrm{s}$），温度单位为开尔文（$\\mathrm{K}$），以及扩散率单位为平方米/秒（$\\mathrm{m^2/s}$）。以开尔文报告每个 $E_{\\max}$，并四舍五入到六位小数。\n\n测试套件。对于以下每个参数集 $(\\alpha, L, T_0, T_s, t_f, N_x, \\Delta t)$，计算 $E_{\\max}$：\n\n- 情况 $1$：$\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，$L = 0.1\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 400\\ \\mathrm{K}$，$t_f = 100\\ \\mathrm{s}$，$N_x = 400$，$\\Delta t = 0.1\\ \\mathrm{s}$。\n- 情况 $2$：$\\alpha = 1.4\\times 10^{-7}\\ \\mathrm{m^2/s}$，$L = 0.02\\ \\mathrm{m}$，$T_0 = 293\\ \\mathrm{K}$，$T_s = 350\\ \\mathrm{K}$，$t_f = 10\\ \\mathrm{s}$，$N_x = 200$，$\\Delta t = 0.5\\ \\mathrm{s}$。\n- 情况 $3$：$\\alpha = 1.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，$L = 0.02\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 310\\ \\mathrm{K}$，$t_f = 200\\ \\mathrm{s}$，$N_x = 200$，$\\Delta t = 0.2\\ \\mathrm{s}$。\n- 情况 $4$：$\\alpha = 5.0\\times 10^{-6}\\ \\mathrm{m^2/s}$，$L = 0.05\\ \\mathrm{m}$，$T_0 = 300\\ \\mathrm{K}$，$T_s = 360\\ \\mathrm{K}$，$t_f = 200\\ \\mathrm{s}$，$N_x = 40$，$\\Delta t = 2.0\\ \\mathrm{s}$。\n\n最终输出格式。您的程序应生成单行输出，其中包含按测试套件顺序排列的四个四舍五入误差的列表，格式为方括号括起来的逗号分隔列表，例如 $[e_1,e_2,e_3,e_4]$，其中每个 $e_k$ 是情况 $k$ 的误差，单位为开尔文，四舍五入到六位小数（输出行中不含单位或多余空格）。", "solution": "所呈现的问题是一个在截断空间域上的一维热方程的适定初边值问题。需要计算一个数值解，并与对应于半无限域的给定解析解进行比较。\n\n该问题按如下方式进行验证。控制偏微分方程 $\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}$ 是传热学的基本原理。初始条件和边界条件是标准的且具有物理意义。所有参数都以一致的单位提供。关键的是，对显式前向时间中心空间（FTCS）格式的稳定性参数 $s = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$ 的分析显示，对于四个相应的测试用例，其值分别为 $s \\approx 16$、$s=7$、$s=200$ 和 $s \\approx 6.4$。由于 FTCS 格式的稳定性要求 $s \\le \\frac{1}{2}$，因此显式方法将是剧烈不稳定的。这需要使用无条件稳定的隐式方法。因此，该问题在科学上是合理的，并且结构严谨，旨在测试此类方法的实现。\n\n选择 Crank-Nicolson 方法是因为其无条件稳定性和在时间 $O((\\Delta t)^2)$ 和空间 $O((\\Delta x)^2)$ 上的二阶精度。该方法在时间区间 $[t_n, t_{n+1}]$ 的中点近似时间导数，并在两个时间层级上平均空间导数。设 $T_i^n$ 表示在网格点 $x_i = i\\Delta x$ 和时间 $t_n = n\\Delta t$ 时温度 $T(x_i, t_n)$ 的数值近似。热方程的 Crank-Nicolson 离散化为：\n$$ \\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left[ \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} + \\frac{T_{i+1}^{n+1} - 2T_i^{n+1} + T_{i-1}^{n+1}}{(\\Delta x)^2} \\right] $$\n该方程适用于内部空间网格点 $i = 1, 2, \\dots, N_x - 1$。设 $r = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。重新整理方程，将时间步 $n+1$ 的未知温度与时间步 $n$ 的已知温度分开，得到：\n$$ -r T_{i-1}^{n+1} + (1+2r) T_i^{n+1} - r T_{i+1}^{n+1} = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n $$\n这个方程组必须补充边界条件。空间网格有 $N_x+1$ 个点，索引从 $i=0$ 到 $i=N_x$。温度 $T_1^{n+1}, \\dots, T_{N_x}^{n+1}$ 是每个时间步需要求解的 $N_x$ 个未知数。\n\n在边界 $x=0$（对应于 $i=0$）处，应用狄利克雷（Dirichlet）条件 $T(0,t) = T_s$，因此对于所有 $n \\ge 0$，$T_0^n = T_s$。对于第一个未知数 $T_1^{n+1}$（即在 $i=1$ 处），将已知值 $T_0^{n+1} = T_s$ 移到方程的右侧：\n$$ (1+2r) T_1^{n+1} - r T_2^{n+1} = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n\n在边界 $x=L$（对应于 $i=N_x$）处，施加诺伊曼（Neumann）条件 $\\frac{\\partial T}{\\partial x}(L,t)=0$。这通过使用涉及在 $x_{N_x+1} = L+\\Delta x$ 处的“虚拟点”的二阶精确中心差分来近似。条件 $\\frac{T_{N_x+1} - T_{N_x-1}}{2\\Delta x} = 0$ 意味着 $T_{N_x+1} = T_{N_x-1}$。将此代入 $i=N_x$ 的通用 Crank-Nicolson 方程中，可得到最终未知数 $T_{N_x}^{n+1}$ 的方程：\n$$ -2r T_{N_x-1}^{n+1} + (1+2r) T_{N_x}^{n+1} = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\n这些关于 $i = 1, \\dots, N_x$ 的方程构成了一个形式为 $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$ 的线性系统，其中 $\\mathbf{U}^{n+1}$ 是未知温度的向量 $[T_1^{n+1}, \\dots, T_{N_x}^{n+1}]^T$。矩阵 $\\mathbf{A}$ 是一个常数、$N_x \\times N_x$ 的三对角矩阵：\n$$ \\mathbf{A} = \\begin{pmatrix}\n1+2r  -r  0  \\dots  \\dots  0 \\\\\n-r  1+2r  -r  \\ddots   \\vdots \\\\\n0  \\ddots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  -r  1+2r  -r  0 \\\\\n\\vdots   \\ddots  0  -2r  1+2r\n\\end{pmatrix} $$\n右侧向量 $\\mathbf{b}^n$ 由时间 $n$ 的已知温度计算得出：\n$$ b_1^n = (1-2r) T_1^n + r T_2^n + 2r T_s $$\n$$ b_i^n = r T_{i-1}^n + (1-2r) T_i^n + r T_{i+1}^n \\quad \\text{对于 } i=2, \\dots, N_x-1 $$\n$$ b_{N_x}^n = 2r T_{N_x-1}^n + (1-2r) T_{N_x}^n $$\n数值求解过程首先设置初始温度分布：对于 $x>0$，$T(x,0) = T_0$；对于 $T(0,0)=T_s$。然后，对于从 $n=0$ 到 $N_t-1$ 的每个时间步（其中 $N_t=t_f/\\Delta t$），构建右侧向量 $\\mathbf{b}^n$ 并求解三对角系统 $\\mathbf{A} \\mathbf{U}^{n+1} = \\mathbf{b}^n$，以找到下一个时间步的温度。重复此过程，直到达到最终时间 $t_f$。这个三对角系统可以使用科学计算库中提供的算法（如 Thomas 算法）高效求解。\n\n最后，在 $t=t_f$ 时，将计算出的数值解 $T_{\\text{num}}(x_i, t_f)$ 与半无限域的解析解 $T_{\\text{exact}}(x_i, t_f)$ 进行比较，并确定所有网格点上的最大绝对误差 $E_{\\max}$。需要注意的是，这个误差度量混合了数值离散误差与由域截断和近似远场边界条件引起的建模误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erfc\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation for given test cases using the Crank-Nicolson method\n    and computes the maximum error against the analytical solution.\n    \"\"\"\n    # (alpha, L, T0, Ts, tf, Nx, dt)\n    test_cases = [\n        (1.0e-5, 0.1, 300.0, 400.0, 100.0, 400, 0.1),\n        (1.4e-7, 0.02, 293.0, 350.0, 10.0, 200, 0.5),\n        (1.0e-5, 0.02, 300.0, 310.0, 200.0, 200, 0.2),\n        (5.0e-6, 0.05, 300.0, 360.0, 200.0, 40, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, T0, Ts, tf, Nx, dt = case\n\n        # Discretization parameters\n        dx = L / Nx\n        # Note: The stability parameter for FTCS is alpha*dt/dx**2.\n        # The Crank-Nicolson parameter 'r' is defined with a factor of 2.\n        r = (alpha * dt) / (2 * dx**2)\n        Nt = int(round(tf / dt))\n\n        # --- Initial Condition ---\n        # T_current is the temperature vector at the current time step.\n        # It has Nx+1 points, from x=0 to x=L.\n        T_current = np.full(Nx + 1, T0)\n        T_current[0] = Ts # Boundary condition at x=0\n\n        # --- Set up the Crank-Nicolson matrix system A*U_next = b ---\n        # Matrix A is tridiagonal and constant through time.\n        # We use scipy.linalg.solve_banded which is efficient.\n        # The matrix A acts on the interior points plus the far boundary, so it is Nx x Nx.\n        \n        # 'ab' stores the bands of matrix A in a format required by solve_banded.\n        # For a (1,1) banded matrix A, ab is (3, Nx).\n        # ab[0, 1:] = upper diagonal\n        # ab[1, :]   = main diagonal\n        # ab[2, :-1] = lower diagonal\n        ab = np.zeros((3, Nx))\n\n        # Main diagonal\n        ab[1, :] = 1 + 2 * r\n\n        # Upper diagonal\n        ab[0, 1:] = -r\n\n        # Lower diagonal\n        ab[2, :-1] = -r\n        # Modification for Neumann boundary condition at x=L (i=Nx)\n        # This affects the last row of matrix A: A[Nx-1, Nx-2] = -2*r\n        # which corresponds to the last element of the lower diagonal band.\n        if Nx > 1:\n            ab[2, Nx - 2] = -2 * r\n\n        # --- Time-stepping loop ---\n        for _ in range(Nt):\n            # Construct the right-hand side vector b\n            b = np.zeros(Nx)\n\n            # Equation for the first interior point i=1 (vector index 0)\n            b[0] = (1 - 2 * r) * T_current[1] + r * T_current[2] + 2 * r * Ts\n\n            # Equations for interior points i=2 to Nx-1 (vector indices 1 to Nx-2)\n            # This loop is slow but clear. Vectorization is possible but complex to write.\n            for i in range(2, Nx):\n                b[i-1] = r * T_current[i-1] + (1 - 2 * r) * T_current[i] + r * T_current[i+1]\n\n            # Equation for the last point i=Nx (vector index Nx-1)\n            # This is only relevant if there's more than one unknown point\n            if Nx > 1:\n                b[Nx - 1] = 2 * r * T_current[Nx - 1] + (1 - 2 * r) * T_current[Nx]\n\n            # Solve the linear system for the unknown interior temperatures at the next time step\n            T_next_interior = solve_banded((1, 1), ab, b)\n            \n            # Update the temperature vector\n            T_current[1:] = T_next_interior\n            # T_current[0] is always Ts\n\n        # --- Error Calculation ---\n        # The numerical solution at t=tf is in T_current\n        T_numerical = T_current\n\n        # Calculate the exact solution at t=tf\n        x = np.linspace(0, L, Nx + 1)\n        # The argument of erfc can become infinite if t=0, but tf > 0 here.\n        argument = x / (2 * np.sqrt(alpha * tf))\n        T_exact = T0 + (Ts - T0) * erfc(argument)\n        \n        # Compute the maximum absolute error\n        max_error = np.max(np.abs(T_numerical - T_exact))\n        results.append(round(max_error, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402549"}, {"introduction": "许多物理系统的边界不是固定的温度，而是由热通量定义的。本练习将挑战你使用全隐式格式来实现诺伊曼（Neumann）边界条件，这是实际建模中的一个常见要求 [@problem_id:2402591]。此外，你还将学习通过检验模拟是否遵循全局热量守恒定律来验证其物理正确性，这是一种在没有解析解可供参考时非常有用的调试和验证技术。", "problem": "考虑一维热方程，它是一个在闭区间上的数学初边值问题，所有量均为无量纲量。令 $x \\in [0,L]$ 且 $t \\ge 0$。温度场 $u(x,t)$ 根据扩散定律演化\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2},\n$$\n其中热扩散系数 $\\alpha > 0$ 为常数。边界条件为诺伊曼（Neumann）类型（指定法向导数），\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x=0} = C_0, \\qquad \\left.\\frac{\\partial u}{\\partial x}\\right|_{x=L} = C_1,\n$$\n其中 $C_0$ 和 $C_1$ 是实常数。初始条件为一个光滑函数 $u(x,0) = u_0(x)$。所有量均为无量纲。三角函数的参数必须以弧度解释。\n\n您的任务是：从第一性原理出发，推导并实现一种无条件稳定的隐式有限差分方法，该方法在每个时间步隐式地施加诺伊曼边界条件，然后验证由扩散定律和边通量所蕴含的全局热平衡。\n\n要求：\n1) 从基本偏微分方程以及一阶和二阶空间导数的定义出发，在 $[0,L]$ 上使用包含 $N$ 个节点的均匀网格（网格间距 $\\Delta x = L/(N-1)$）和时间步长 $\\Delta t$。使用完全隐式的后向欧拉步长对时间进行离散化，并使用中心有限差分对空间进行离散化。以数学上一致的方式消除边界处的“虚拟”值（ghost values），从而在每个时间步求解的线性系统中隐式地施加诺伊曼边界条件。除上述定律和定义外，不得假定任何未推导的公式。\n\n2) 仅使用扩散方程所蕴含的守恒律和微积分基本定理，证明对于任何足够光滑的解，\n$$\n\\frac{d}{dt}\\int_0^L u(x,t)\\,dx = \\alpha \\left[\\left.\\frac{\\partial u}{\\partial x}\\right|_{x=L} - \\left.\\frac{\\partial u}{\\partial x}\\right|_{x=0}\\right] = \\alpha\\,(C_1 - C_0).\n$$\n因此，\n$$\n\\int_0^L u(x,T)\\,dx - \\int_0^L u(x,0)\\,dx = \\alpha\\,(C_1 - C_0)\\,T.\n$$\n\n3) 实现该数值方法，并使用均匀网格上的梯形法则来近似时间 $t$ 处的空间积分，\n$$\n\\mathcal{Q}(t) \\approx \\Delta x\\left(\\tfrac{1}{2}u(x_0,t) + \\sum_{i=1}^{N-2}u(x_i,t) + \\tfrac{1}{2}u(x_{N-1},t)\\right),\n$$\n其中 $x_i = i\\,\\Delta x$。使用固定的初始条件\n$$\nu_0(x) = \\cos(2\\pi x) + 0.1\\,\\sin(3\\pi x).\n$$\n\n4) 对于下述测试套件中的每个测试用例，积分到时间 $T$ 并报告全局热平衡的绝对误差，\n$$\n\\varepsilon = \\left|\\left(\\mathcal{Q}(T) - \\mathcal{Q}(0)\\right) - \\alpha\\,(C_1 - C_0)\\,T\\right|.\n$$\n\n测试套件：\n- 用例 A（理想情况，零通量守恒）：$L=1$, $\\alpha=0.5$, $C_0=0$, $C_1=0$, $N=101$, $\\Delta t = 10^{-3}$, $T=0.1$。\n- 用例 B（非零净流入）：$L=1$, $\\alpha=0.5$, $C_0=0$, $C_1=1$, $N=101$, $\\Delta t = 10^{-3}$, $T=0.1$。\n- 用例 C（净流出）：$L=1$, $\\alpha=0.1$, $C_0=1$, $C_1=-1$, $N=121$, $\\Delta t = 5\\times 10^{-4}$, $T=0.2$。\n- 用例 D（边界情况，粗网格，相等通量）：$L=1$, $\\alpha=1.0$, $C_0=0.2$, $C_1=0.2$, $N=31$, $\\Delta t = 2\\times 10^{-3}$, $T=0.2$。\n\n编程约束和输出格式：\n- 您的程序必须是一个单一、完整、可运行的脚本，用于实现该方法并根据指定的初始条件计算上述四个用例的误差 $\\varepsilon$。不允许用户输入。\n- 最终输出必须为单行，包含按 A、B、C、D 顺序排列的四个浮点误差列表，格式为逗号分隔的 Python 列表，例如：“[0.001,0.002,0.003,0.004]”。", "solution": "问题陈述经分析有效。它提出了一个来自计算物理学的适定初边值问题，并为严谨的数值处理指定了所有必要的参数和条件。推导和实现过程遵循形式化的数学原理。\n\n一维热方程由下式给出\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于 $x \\in [0, L]$ 和 $t \\ge 0$。我们用均匀空间网格 $x_i = i\\Delta x$（其中 $i=0, 1, \\dots, N-1$，网格间距 $\\Delta x = L/(N-1)$）和均匀时间步长 $t_j = j\\Delta t$ 对时空域进行离散化。网格点上的数值解记为 $u_i^j \\approx u(x_i, t_j)$。\n\n对于时间离散化，采用完全隐式方法，即后向欧拉格式。在时间 $t_{j+1}$，时间导数近似为：\n$$\n\\left.\\frac{\\partial u}{\\partial t}\\right|_{x_i, t_{j+1}} \\approx \\frac{u_i^{j+1} - u_i^j}{\\Delta t}\n$$\n空间二阶导数使用二阶中心有限差分进行近似，并在未来的时间层 $t_{j+1}$ 上进行评估，以确保隐式性：\n$$\n\\left.\\frac{\\partial^2 u}{\\partial x^2}\\right|_{x_i, t_{j+1}} \\approx \\frac{u_{i-1}^{j+1} - 2u_i^{j+1} + u_{i+1}^{j+1}}{(\\Delta x)^2}\n$$\n将这些近似值代入热方程，得到网格内部节点（$i=1, \\dots, N-2$）的有限差分方程：\n$$\n\\frac{u_i^{j+1} - u_i^j}{\\Delta t} = \\alpha \\frac{u_{i-1}^{j+1} - 2u_i^{j+1} + u_{i+1}^{j+1}}{(\\Delta x)^2}\n$$\n令扩散数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。重新整理各项，将时间步 $j+1$ 的未知值置于左侧，得到每个内部节点的线性方程：\n$$\n-r u_{i-1}^{j+1} + (1+2r)u_i^{j+1} - r u_{i+1}^{j+1} = u_i^j\n$$\n对于任意 $r > 0$ 的选择，这种后向时间、中心空间（BTCS）格式都是无条件稳定的。\n\n为了隐式地施加诺伊曼边界条件，我们在 $x_{-1} = -\\Delta x$ 和 $x_N = L+\\Delta x$ 处引入“虚拟”节点（ghost nodes）。边界条件为\n$$\n\\left.\\frac{\\partial u}{\\partial x}\\right|_{x=0} = C_0, \\qquad \\left.\\frac{\\partial u}{\\partial x}\\right|_{x=L} = C_1\n$$\n在边界处使用中心差分近似可以保持格式的二阶空间精度：\n在 $x_0 = 0$ 处，我们有：\n$$\n\\frac{u_1^{j+1} - u_{-1}^{j+1}}{2\\Delta x} = C_0 \\implies u_{-1}^{j+1} = u_1^{j+1} - 2\\Delta x C_0\n$$\n在 $x_{N-1} = L$ 处，我们有：\n$$\n\\frac{u_N^{j+1} - u_{N-2}^{j+1}}{2\\Delta x} = C_1 \\implies u_N^{j+1} = u_{N-2}^{j+1} + 2\\Delta x C_1\n$$\n这些关系式用于从边界节点 $i=0$ 和 $i=N-1$ 的离散方程中消除虚拟节点的值。\n\n对于边界节点 $i=0$：\n$$\n-r u_{-1}^{j+1} + (1+2r)u_0^{j+1} - r u_1^{j+1} = u_0^j\n$$\n代入推导出的 $u_{-1}^{j+1}$ 表达式：\n$$\n-r(u_1^{j+1} - 2\\Delta x C_0) + (1+2r)u_0^{j+1} - r u_1^{j+1} = u_0^j\n$$\n$$\n(1+2r)u_0^{j+1} - 2r u_1^{j+1} = u_0^j - 2r\\Delta x C_0\n$$\n对于边界节点 $i=N-1$：\n$$\n-r u_{N-2}^{j+1} + (1+2r)u_{N-1}^{j+1} - r u_N^{j+1} = u_{N-1}^j\n$$\n代入推导出的 $u_N^{j+1}$ 表达式：\n$$\n-r u_{N-2}^{j+1} + (1+2r)u_{N-1}^{j+1} - r(u_{N-2}^{j+1} + 2\\Delta x C_1) = u_{N-1}^j\n$$\n$$\n-2r u_{N-2}^{j+1} + (1+2r)u_{N-1}^{j+1} = u_{N-1}^j + 2r\\Delta x C_1\n$$\n针对未知向量 $\\mathbf{u}^{j+1} = [u_0^{j+1}, u_1^{j+1}, \\dots, u_{N-1}^{j+1}]^T$ 的 $N$ 个方程组构成一个线性系统 $A \\mathbf{u}^{j+1} = \\mathbf{d}$。矩阵 $A$ 是一个大小为 $N \\times N$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\n1+2r  -2r  0  \\dots  0 \\\\\n-r  1+2r  -r  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n0  \\dots  -r  1+2r  -r \\\\\n0  \\dots  0  -2r  1+2r\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{d}$ 包含前一时间步 $t_j$ 的已知值和边界通量项：\n$$\nd_0 = u_0^j - 2r\\Delta x C_0 = u_0^j - \\frac{2\\alpha \\Delta t}{\\Delta x}C_0\n$$\n$$\nd_i = u_i^j \\quad \\text{对于 } i=1, \\dots, N-2\n$$\n$$\nd_{N-1} = u_{N-1}^j + 2r\\Delta x C_1 = u_{N-1}^j + \\frac{2\\alpha \\Delta t}{\\Delta x}C_1\n$$\n这个三对角系统在每个时间步被高效求解，以将解从 $t_j$推进到 $t_{j+1}$。\n\n全局热平衡直接从扩散定律推导得出。我们在空间域 $[0,L]$ 上对控制偏微分方程进行积分：\n$$\n\\int_0^L \\frac{\\partial u}{\\partial t}(x,t) \\,dx = \\int_0^L \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t) \\,dx\n$$\n通过应用莱布尼茨积分法则，左侧被确定为总热量的时间导数：\n$$\n\\int_0^L \\frac{\\partial u}{\\partial t}(x,t) \\,dx = \\frac{d}{dt} \\int_0^L u(x,t) \\,dx\n$$\n通过应用微积分基本定理，右侧被确定为穿过边界的净热通量：\n$$\n\\alpha \\int_0^L \\frac{\\partial}{\\partial x}\\left(\\frac{\\partial u}{\\partial x}\\right) \\,dx = \\alpha \\left[\\frac{\\partial u}{\\partial x}\\right]_0^L = \\alpha \\left(\\left.\\frac{\\partial u}{\\partial x}\\right|_{x=L} - \\left.\\frac{\\partial u}{\\partial x}\\right|_{x=0}\\right)\n$$\n代入诺伊曼边界条件 $C_0$ 和 $C_1$ 得到总热量的变化率：\n$$\n\\frac{d}{dt}\\int_0^L u(x,t)\\,dx = \\alpha (C_1 - C_0)\n$$\n将此表达式对时间从 $t=0$ 积分到 $t=T$，得到积分周期内的总热量变化：\n$$\n\\int_0^T \\left( \\frac{d}{dt}\\int_0^L u(x,t)\\,dx \\right) dt = \\int_0^T \\alpha(C_1 - C_0) \\,dt\n$$\n$$\n\\left[\\int_0^L u(x,t)\\,dx\\right]_0^T = \\alpha(C_1 - C_0) \\int_0^T dt\n$$\n$$\n\\int_0^L u(x,T)\\,dx - \\int_0^L u(x,0)\\,dx = \\alpha(C_1 - C_0)T\n$$\n这个精确的恒等式用于验证数值解的守恒性质。该积分按照指定使用梯形法则进行数值近似。程序计算绝对误差 $\\varepsilon = |\\left(\\mathcal{Q}(T) - \\mathcal{Q}(0)\\right) - \\alpha(C_1 - C_0)T|$，该误差量化了由于离散化误差，数值格式与精确全局守恒律之间的偏差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n\n    def solve_case(L, alpha, C0, C1, N, dt, T):\n        \"\"\"\n        Solves the 1D heat equation for a single test case using an implicit\n        finite difference method with Neumann boundary conditions.\n\n        Args:\n            L (float): Length of the domain.\n            alpha (float): Thermal diffusivity.\n            C0 (float): Neumann boundary condition at x=0.\n            C1 (float): Neumann boundary condition at x=L.\n            N (int): Number of grid points.\n            dt (float): Time step.\n            T (float): Total integration time.\n\n        Returns:\n            float: The absolute error in the global heat balance.\n        \"\"\"\n        # 1. Setup grid, initial condition, and parameters.\n        x = np.linspace(0, L, N)\n        dx = L / (N - 1)\n        num_steps = int(round(T / dt))\n\n        # Initial condition function\n        u0_func = lambda x_grid: np.cos(2 * np.pi * x_grid) + 0.1 * np.sin(3 * np.pi * x_grid)\n        u_current = u0_func(x)\n\n        # Trapezoidal integration function\n        def trapezoid_integral(u_vec, dx_val):\n            return dx_val * (0.5 * u_vec[0] + np.sum(u_vec[1:-1]) + 0.5 * u_vec[-1])\n\n        # Calculate initial total heat Q(0).\n        Q0 = trapezoid_integral(u_current, dx)\n\n        # 2. Setup the linear system for the implicit method.\n        # Diffusion number r = alpha * dt / dx^2.\n        r = alpha * dt / (dx * dx)\n\n        # Construct the tridiagonal matrix A in banded format for solve_banded.\n        # The matrix 'ab' has 3 rows: upper, main, and lower diagonals.\n        ab = np.zeros((3, N))\n        \n        # Main diagonal: 1 + 2r\n        ab[1, :] = 1.0 + 2.0 * r\n        \n        # Upper diagonal (first super-diagonal): -r, with a modification at the start.\n        # ab[0, j] corresponds to A[j-1, j].\n        ab[0, 1:] = -r\n        ab[0, 1] = -2.0 * r  # Modified for Neumann BC at x=0.\n\n        # Lower diagonal (first sub-diagonal): -r, with a modification at the end.\n        # ab[2, j] corresponds to A[j+1, j].\n        ab[2, :-1] = -r\n        ab[2, -2] = -2.0 * r # Modified for Neumann BC at x=L.\n\n        # 3. Time-stepping loop.\n        for _ in range(num_steps):\n            # Construct the right-hand side vector d.\n            d = u_current.copy()\n            \n            # Incorporate boundary condition terms into the RHS vector.\n            # Constant term for x=0 BC: -2*r*dx*C0\n            d[0] -= 2.0 * r * dx * C0\n            # Constant term for x=L BC: +2*r*dx*C1\n            d[-1] += 2.0 * r * dx * C1\n\n            # Solve the linear system A * u_next = d for the next time step.\n            # (1, 1) indicates 1 lower and 1 upper diagonal.\n            u_next = solve_banded((1, 1), ab, d)\n            \n            # Update the solution for the next iteration.\n            u_current = u_next\n        \n        # 4. Final calculation of heat balance error.\n        # Calculate final total heat Q(T).\n        QT = trapezoid_integral(u_current, dx)\n        \n        # Theoretical change in total heat.\n        delta_Q_theory = alpha * (C1 - C0) * T\n        \n        # Numerically computed change in total heat.\n        delta_Q_numerical = QT - Q0\n        \n        # Absolute error.\n        error = abs(delta_Q_numerical - delta_Q_theory)\n        \n        return error\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, C0, C1, N, dt, T)\n        (1.0, 0.5, 0.0, 0.0, 101, 1e-3, 0.1),       # Case A\n        (1.0, 0.5, 0.0, 1.0, 101, 1e-3, 0.1),       # Case B\n        (1.0, 0.1, 1.0, -1.0, 121, 5e-4, 0.2),      # Case C\n        (1.0, 1.0, 0.2, 0.2, 31, 2e-3, 0.2),        # Case D\n    ]\n\n    results = []\n    for case in test_cases:\n        L, alpha, C0, C1, N, dt, T = case\n        result = solve_case(L, alpha, C0, C1, N, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402591"}, {"introduction": "我们如何高效地将隐式方法应用于二维或三维问题？本练习将介绍交替方向隐式（ADI）方法，这是一种强大的技术，它避免了求解完整二维矩阵系统所带来的巨大计算成本 [@problem_id:2402582]。通过将每个时间步分解为两个半步，ADI巧妙地将二维问题转化为一系列易于求解的一维三对角系统。你将应用这项技能来模拟二维平板上热点的散热过程。", "problem": "考虑方形域上的二维热扩散问题，其由以下偏微分方程 (PDE) 控制\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right),\n$$\n在方形板 $\\Omega = [0,L]\\times[0,L]$ 上，具有恒定的狄利克雷边界条件\n$$\nT(x,y,t) = T_b \\quad \\text{for all } (x,y)\\in \\partial \\Omega, \\; t \\ge 0,\n$$\n以及以下形式的初始条件\n$$\nT(x,y,0) = T_b + A \\exp\\left(-\\frac{(x - L/2)^2 + (y - L/2)^2}{2\\sigma^2}\\right).\n$$\n使用具有 $N\\times N$ 个点的均匀笛卡尔网格，空间步长为 $\\Delta x = \\Delta y = L/(N-1)$，以及均匀的时间步长 $\\Delta t$。从 $t=0$ 开始，将温度演化至最终时间 $t_{\\text{final}}$。所有温度必须以开尔文 (K) 为单位，所有长度以米 (m) 为单位，所有时间以秒 (s) 为单位。\n\n您的任务是为下面列出的每个测试用例计算以下两个量：\n- 在时间 $t=t_{\\text{final}}$ 时，板中心网格点 $(x=L/2,y=L/2)$ 处的温度（开尔文）。\n- 在时间 $t=t_{\\text{final}}$ 时，所有网格点上的最高温度（开尔文）。\n\n假设 $N$ 为奇数，以便网格包含精确的中心点 $(L/2,L/2)$。对于所有 $t \\ge 0$，边界值被视为固定在 $T_b$。\n\n测试套件（每个用例指定 $(L,\\alpha,T_b,A,\\sigma,\\Delta t,t_{\\text{final}},N)$）：\n- 用例 1：$L=0.1$ 米, $\\alpha=1.0\\times 10^{-4}$ 米$^2$/秒, $T_b=300.0$ 开尔文, $A=100.0$ 开尔文, $\\sigma=0.01$ 米, $\\Delta t=2.5\\times 10^{-4}$ 秒, $t_{\\text{final}}=0.01$ 秒, $N=41$。\n- 用例 2：$L=0.1$ 米, $\\alpha=1.0\\times 10^{-4}$ 米$^2$/秒, $T_b=300.0$ 开尔文, $A=50.0$ 开尔文, $\\sigma=0.02$ 米, $\\Delta t=1.0\\times 10^{-3}$ 秒, $t_{\\text{final}}=0.01$ 秒, $N=5$。\n- 用例 3：$L=0.1$ 米, $\\alpha=1.0\\times 10^{-4}$ 米$^2$/秒, $T_b=300.0$ 开尔文, $A=0.0$ 开尔文, $\\sigma=0.01$ 米, $\\Delta t=1.0\\times 10^{-3}$ 秒, $t_{\\text{final}}=0.02$ 秒, $N=31$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。每个测试用例对应一个包含两个元素 $[T_{\\text{center}},T_{\\max}]$（单位为开尔文）的列表。对于上述三个用例，要求的格式为\n[ [T_center_case1,T_max_case1], [T_center_case2,T_max_case2], [T_center_case3,T_max_case3] ]\n打印输出中不含空格（例如：[[300.123456,350.654321],[...],[...]]）。这些值是单位为开尔文的实数。", "solution": "问题陈述已经过验证，被认为是有效的。它提出了一个适定的二维热方程初边值问题，这是物理学中的一个基本模型。所有参数和条件都已明确指定，这使得数值解是唯一、稳定且有意义的。\n\n该问题要求对二维热方程进行数值求解：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\left(\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2}\\right)\n$$\n在具有 $N \\times N$ 个点的空间网格的方形域 $\\Omega = [0,L]\\times[0,L]$ 上。边界温度固定为 $T(x,y,t) = T_b$（对于 $(x,y) \\in \\partial\\Omega$），而初始温度分布由叠加在边界温度上的高斯函数给出。\n\n对于这类抛物型偏微分方程的数值解，由于其无条件稳定性的特性，隐式有限差分法是合适的。交替方向隐式 (ADI) 方法，特别是 Peaceman-Rachford 格式，是解决二维问题的有效选择。该方法通过将每个时间步长 $\\Delta t$ 分成两个大小为 $\\Delta t / 2$ 的半步来解耦维度，从而将大型二维问题转化为一系列可以高效求解的、更小的、独立的一维问题。\n\n令 $T_{i,j}^n$ 表示在时间 $t_n = n\\Delta t$ 时网格点 $(x_i, y_j)$ 处的温度。空间网格步长为 $\\Delta x = \\Delta y = L/(N-1)$。\n\nADI 格式通过两个半步将解从时间 $t_n$推进到 $t_{n+1} = t_n + \\Delta t$：\n\n第 1 步：从 $t_n$ 推进到中间时间 $t_{n+1/2} = t_n + \\Delta t/2$。\n在这一步中，格式在 $x$ 方向是隐式的，在 $y$ 方向是显式的。有限差分方程为：\n$$\n\\frac{T_{i,j}^{n+1/2} - T_{i,j}^n}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n}{\\Delta y^2} \\right)\n$$\n令 $r = \\frac{\\alpha \\Delta t}{2\\Delta x^2}$ (因为 $\\Delta x = \\Delta y$)。重新整理各项，将时间层 $n+1/2$ 的未知数放在左侧，我们得到：\n$$\n-r T_{i-1,j}^{n+1/2} + (1+2r) T_{i,j}^{n+1/2} - r T_{i+1,j}^{n+1/2} = T_{i,j}^n + r (T_{i,j-1}^n - 2T_{i,j}^n + T_{i,j+1}^n)\n$$\n该方程是为每个内部行 $j \\in \\{1, 2, \\dots, N-2\\}$ 建立的。对于固定的 $j$，这是一个关于未知温度 $T_{i,j}^{n+1/2}$（对于 $i \\in \\{1, 2, \\dots, N-2\\}$）的三对角线性方程组。边界值 $T_{0,j}^{n+1/2}$ 和 $T_{N-1,j}^{n+1/2}$ 是已知的，且等于 $T_b$。这些方程组可以使用托马斯算法（三对角矩阵算法）高效求解。\n\n第 2 步：从 $t_{n+1/2}$ 推进到 $t_{n+1}$。\n在这一步中，格式在 $x$ 方向是显式的，在 $y$ 方向是隐式的：\n$$\n\\frac{T_{i,j}^{n+1} - T_{i,j}^{n+1/2}}{\\Delta t/2} = \\alpha \\left( \\frac{T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2}}{\\Delta x^2} + \\frac{T_{i,j-1}^{n+1} - 2T_{i,j}^{n+1} + T_{i,j+1}^{n+1}}{\\Delta y^2} \\right)\n$$\n重新整理后得到一个 $y$ 方向的三对角系统：\n$$\n-r T_{i,j-1}^{n+1} + (1+2r) T_{i,j}^{n+1} - r T_{i,j+1}^{n+1} = T_{i,j}^{n+1/2} + r(T_{i-1,j}^{n+1/2} - 2T_{i,j}^{n+1/2} + T_{i+1,j}^{n+1/2})\n$$\n该方程是为每个内部列 $i \\in \\{1, 2, \\dots, N-2\\}$ 建立的。对于固定的 $i$，这形成了一个关于未知数 $T_{i,j}^{n+1}$（对于 $j \\in \\{1, 2, \\dots, N-2\\}$）的三对角系统。边界值 $T_{i,0}^{n+1}$ 和 $T_{i,N-1}^{n+1}$ 是已知的，且等于 $T_b$。这些系统同样使用托马斯算法求解。\n\n总体算法如下：\n1.  **初始化**：定义模拟参数 $(L, \\alpha, T_b, A, \\sigma, \\Delta t, t_{\\text{final}}, N)$。构建空间网格 $x_i, y_j$。计算总时间步数 $N_t = \\lceil t_{\\text{final}} / \\Delta t \\rceil$。使用提供的高斯函数初始化温度场 $T$。边界点保持固定在 $T_b$。预先计算参数 $r$。为线性求解构建常数三对角矩阵。\n\n2.  **时间演化**：对于从 $0$ 到 $N_t-1$ 的 $n$ 进行循环：\n    a. 创建一个中间温度数组 $T_{\\text{intermediate}}$。\n    b. 对于每个内部行 $j$，根据 $T^n$ 中的已知值组装右侧向量，并求解三对角系统以得到 $T_{\\text{intermediate}}$ 中的相应行。通过调整右侧向量来强制执行边界值。\n    c. 对于每个内部列 $i$，根据 $T_{\\text{intermediate}}$ 中的已知值组装右侧向量，并求解三对角系统以得到新温度数组 $T^{n+1}$ 中的相应列。\n    d. 更新温度数组：$T \\leftarrow T^{n+1}$。\n\n3.  **结果提取**：在最后一个时间步之后，得到 $t=t_{\\text{final}}$ 时的温度场 $T$。中心网格点的温度 $T_{\\text{center}}$ 在索引 $((N-1)/2, (N-1)/2)$ 处找到。最高温度 $T_{\\max}$ 通过取整个网格上的最大值来找到。\n\n由于域、边界条件和初始条件的对称性，预计在整个模拟过程中，最高温度将保持在板的几何中心。因此，预计在 $t_{\\text{final}}$ 时，$T_{\\text{center}} = T_{\\max}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_case(params):\n    \"\"\"\n    Solves the 2D heat equation for a single test case using the ADI method.\n    \"\"\"\n    L, alpha, T_b, A, sigma, dt, t_final, N = params\n    \n    # 1. Initialization\n    dx = L / (N - 1)\n    # The problem asks to treat N as odd, so center index is integer\n    center_idx = (N - 1) // 2\n\n    # Create spatial grid\n    x = np.linspace(0, L, N)\n    y = np.linspace(0, L, N)\n    X, Y = np.meshgrid(x, y)\n\n    # Initialize temperature field from IC\n    T = T_b + A * np.exp(-((X - L/2)**2 + (Y - L/2)**2) / (2 * sigma**2))\n    \n    # Enforce boundary conditions (though IC should be consistent)\n    T[0, :] = T_b\n    T[-1, :] = T_b\n    T[:, 0] = T_b\n    T[:, -1] = T_b\n\n    # ADI parameters\n    r = (alpha * dt) / (2 * dx**2)\n    num_steps = int(round(t_final / dt))\n\n    # Construct the tridiagonal matrix for the linear solver.\n    # The matrix is for an (N-2) x (N-2) system (interior points).\n    M = N - 2\n    # For solve_banded, the matrix is specified in banded format (3, M)\n    # ab[0,:] = upper diagonal (length M, first element unused)\n    # ab[1,:] = main diagonal (length M)\n    # ab[2,:] = lower diagonal (length M, last element unused)\n    ab = np.zeros((3, M))\n    ab[0, 1:] = -r\n    ab[1, :] = 1 + 2 * r\n    ab[2, :-1] = -r\n    \n    # 2. Time Evolution\n    T_intermediate = np.copy(T)\n\n    for _ in range(num_steps):\n        # --- Step 1: Implicit in x, explicit in y ---\n        for j in range(1, N - 1): # Iterate over interior rows\n            # Construct RHS vector d\n            d = T[j, 1:-1] + r * (T[j-1, 1:-1] - 2*T[j, 1:-1] + T[j+1, 1:-1])\n            # Add boundary contributions\n            d[0] += r * T_b  # Boundary at x=0\n            d[-1] += r * T_b # Boundary at x=L\n\n            # Solve the tridiagonal system for the current row\n            T_intermediate[j, 1:-1] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on intermediate solution\n        T_intermediate[0, :] = T_b\n        T_intermediate[-1, :] = T_b\n        T_intermediate[:, 0] = T_b\n        T_intermediate[:, -1] = T_b\n\n        # --- Step 2: Implicit in y, explicit in x ---\n        for i in range(1, N - 1): # Iterate over interior columns\n            # Construct RHS vector d\n            d = T_intermediate[1:-1, i] + r * (T_intermediate[1:-1, i-1] - 2*T_intermediate[1:-1, i] + T_intermediate[1:-1, i+1])\n            # Add boundary contributions\n            d[0] += r * T_b # Boundary at y=0\n            d[-1] += r * T_b # Boundary at y=L\n\n            # Solve the tridiagonal system for the current column\n            T[1:-1, i] = solve_banded((1, 1), ab, d)\n        \n        # Enforce BC on final solution for the step\n        T[0, :] = T_b\n        T[-1, :] = T_b\n        T[:, 0] = T_b\n        T[:, -1] = T_b\n        \n    # 3. Result Extraction\n    T_center = T[center_idx, center_idx]\n    T_max = np.max(T)\n    \n    return [T_center, T_max]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, alpha, T_b, A, sigma, dt, t_final, N)\n        (0.1, 1.0e-4, 300.0, 100.0, 0.01, 2.5e-4, 0.01, 41),\n        (0.1, 1.0e-4, 300.0, 50.0, 0.02, 1.0e-3, 0.01, 5),\n        (0.1, 1.0e-4, 300.0, 0.0, 0.01, 1.0e-3, 0.02, 31),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(case)\n        results.append(result)\n\n    # Format the output string as required\n    results_str = [f\"[{res[0]},{res[1]}]\" for res in results]\n    final_output = f\"[{','.join(results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2402582"}]}