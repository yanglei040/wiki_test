{"hands_on_practices": [{"introduction": "动手实践是掌握计算物理学中波动方程数值格式的关键。我们将从一个基础但重要的练习开始：使用时域有限差分法（FDTD）模拟二维各向异性波动方程。通过将数值解与已知的精确解进行比较，这个练习 [@problem_id:2449882] 旨在帮助你验证代码的正确性，并深入理解数值误差的来源与评估方法。", "problem": "设计并实现一个完整的程序，该程序能对具有各向异性波速的二维波动方程进行数值近似求解，并针对多组参数集，在指定的最终时刻将数值解与相应的精确解进行定量比较。控制偏微分方程为\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t),\n$$\n方程定义在矩形空间域 $[0,L_x]\\times[0,L_y]$ 和时间域 $t\\in[0,T]$ 上，边界条件为齐次 Dirichlet 条件\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0,\n$$\n及可分离的初始条件\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad\n\\frac{\\partial u}{\\partial t}(x,y,0)=0.\n$$\n此处，$u$ 是无量纲的，$x$ 和 $y$ 的单位是米，$t$ 的单位是秒，$c_x$ 和 $c_y$ 的单位是米/秒，$L_x$、$L_y$ 和 $T$ 的单位分别是米和秒。与上述条件一致的精确解为：\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }.\n$$\n在每个空间方向上，使用一个包含边界的 $N_x\\times N_y$ 个点的均匀网格，网格间距分别为 $\\Delta x=L_x/(N_x-1)$ 和 $\\Delta y=L_y/(N_y-1)$。以恒定的时间步长 $\\Delta t$ 进行时间演化，总步数为 $N=\\operatorname{round}(T/\\Delta t)$。在 $t_N=N\\,\\Delta t$ 时刻，通过在相同网格上对 $u_{\\text{exact}}$ 进行采样，并计算所有网格点上的最大绝对差来评估误差。请为以下每个测试用例报告此最大绝对误差，该误差为一个无量纲实数。\n\n你的程序必须为以下三个测试用例分别执行此过程，并按照“最终输出格式”的要求，将三个产生的误差聚合到单行输出中。所有输入均采用国际单位制（SI），即米和秒。误差值本身是无量纲的。\n\n测试套件（每行指定 $\\{L_x,L_y,c_x,c_y,m,n,N_x,N_y,\\Delta t,T\\}$）：\n- 用例 A: $\\{\\,1.0,\\,1.0,\\,1.0,\\,2.0,\\,1,\\,1,\\,81,\\,81,\\,0.005,\\,0.5\\,\\}$\n- 用例 B: $\\{\\,1.0,\\,1.0,\\,0.5,\\,3.0,\\,2,\\,3,\\,101,\\,71,\\,0.0042,\\,0.28\\,\\}$\n- 用例 C: $\\{\\,1.0,\\,1.0,\\,2.0,\\,2.5,\\,3,\\,1,\\,65,\\,65,\\,0.0047,\\,0.235\\,\\}$\n\n最终输出格式：您的程序应生成单行输出，其中包含三个误差值，这些值以逗号分隔，并用方括号括起来，顺序为 A、B、C，例如：\n$$\n[\\varepsilon_A,\\varepsilon_B,\\varepsilon_C],\n$$\n其中每个 $\\varepsilon$ 是一个实数。", "solution": "在尝试求解之前，对问题陈述进行分析以验证其有效性。\n\n首先，逐字提取所有给定的数据和条件。\n控制方程：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}(x,y,t) = c_x^2 \\,\\frac{\\partial^2 u}{\\partial x^2}(x,y,t) + c_y^2 \\,\\frac{\\partial^2 u}{\\partial y^2}(x,y,t)\n$$\n定义域：$x \\in [0,L_x]$, $y \\in [0,L_y]$, $t \\in [0,T]$。\n边界条件（齐次 Dirichlet）：\n$$\nu(0,y,t)=u(L_x,y,t)=u(x,0,t)=u(x,L_y,t)=0\n$$\n初始条件：\n$$\nu(x,y,0)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big),\\qquad \\frac{\\partial u}{\\partial t}(x,y,0)=0\n$$\n精确解：\n$$\nu_{\\text{exact}}(x,y,t)=\\sin\\!\\Big(\\frac{m\\pi x}{L_x}\\Big)\\,\\sin\\!\\Big(\\frac{n\\pi y}{L_y}\\Big)\\,\\cos(\\omega t),\n\\quad\n\\omega=\\sqrt{c_x^2\\Big(\\frac{m\\pi}{L_x}\\Big)^2 + c_y^2\\Big(\\frac{n\\pi}{L_y}\\Big)^2 }\n$$\n数值网格：\n$N_x \\times N_y$ 个点；$\\Delta x=L_x/(N_x-1)$，$\\Delta y=L_y/(N_y-1)$；$\\Delta t$ 是时间步长。\n步数：$N=\\operatorname{round}(T/\\Delta t)$。\n误差度量：在 $t_N = N \\Delta t$ 时刻，数值解与精确解之间的最大绝对差。\n测试用例：\n- 用例 A: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=1.0,\\,c_y=2.0,\\,m=1,\\,n=1,\\,N_x=81,\\,N_y=81,\\,\\Delta t=0.005,\\,T=0.5\\}$\n- 用例 B: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=0.5,\\,c_y=3.0,\\,m=2,\\,n=3,\\,N_x=101,\\,N_y=71,\\,\\Delta t=0.0042,\\,T=0.28\\}$\n- 用例 C: $\\{L_x=1.0,\\,L_y=1.0,\\,c_x=2.0,\\,c_y=2.5,\\,m=3,\\,n=1,\\,N_x=65,\\,N_y=65,\\,\\Delta t=0.0047,\\,T=0.235\\}$\n\n接下来，根据形式化标准对问题进行验证。\n1.  **科学基础**：该问题描述了具有各向异性波速的二维线性波动方程，这是物理学中的一个基本模型。所提供的初始和边界条件是标准的。通过将给定的精确解代入偏微分方程并核对初始和边界条件，可以轻松验证其正确性。该问题在数学和科学上都是严谨的。\n2.  **适定性**：该问题是双曲型偏微分方程的一个经典初边值问题。对于给定的光滑初始数据和 Dirichlet 边界条件，可以保证解的存在性、唯一性和稳定性。数值计算任务也定义明确。\n3.  **客观性**：问题以定量、无歧义的语言陈述。所有参数均已定义。\n4.  **完整性与一致性**：每个测试用例都提供了所有必需的信息。\n5.  **可行性**：数值模拟的参数必须满足显式有限差分格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。对于二维各向异性波动方程，该条件为 $S = \\Delta t \\sqrt{ (c_x/\\Delta x)^2 + (c_y/\\Delta y)^2 } \\leq 1$。我们对每个用例进行检查：\n    - 用例 A: $\\Delta x = 1/(80)$, $\\Delta y = 1/(80)$。$S = 0.005 \\sqrt{(1.0/(1/80))^2 + (2.0/(1/80))^2} = 0.005 \\sqrt{80^2 + 160^2} \\approx 0.894  1$。稳定。\n    - 用例 B: $\\Delta x = 1/(100)$, $\\Delta y = 1/(70)$。$S = 0.0042 \\sqrt{(0.5/(1/100))^2 + (3.0/(1/70))^2} = 0.0042 \\sqrt{50^2 + 210^2} \\approx 0.907  1$。稳定。\n    - 用例 C: $\\Delta x = 1/(64)$, $\\Delta y = 1/(64)$。$S = 0.0047 \\sqrt{(2.0/(1/64))^2 + (2.5/(1/64))^2} = 0.0047 \\sqrt{128^2 + 160^2} \\approx 0.963  1$。稳定。\n所有测试用例使用的参数都能保证数值格式的稳定性。\n\n结论：该问题是有效的。它是一个定义明确、科学上合理且数值上可解的问题。我们着手进行求解。\n\n解法采用时域有限差分 (FDTD) 方法构建。我们将空间域离散化为网格 $\\{ (x_i, y_j) | x_i = i\\Delta x, y_j = j\\Delta y \\}$ (其中 $i \\in \\{0, ..., N_x-1\\}$ 且 $j \\in \\{0, ..., N_y-1\\}$)，并将时间离散化为 $t_k = k\\Delta t$。令 $u_{i,j}^k$ 表示 $u(x_i, y_j, t_k)$ 的数值近似。\n\n二阶偏导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial t^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\Bigg|_{i,j,k} \\approx \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\n将这些近似代入控制偏微分方程，即可得到显式更新格式。对于所有内部网格点 $(i,j)$ (其中 $1 \\leq i \\leq N_x-2$ 且 $1 \\leq j \\leq N_y-2$)：\n$$\n\\frac{u_{i,j}^{k+1} - 2u_{i,j}^k + u_{i,j}^{k-1}}{(\\Delta t)^2} = c_x^2 \\frac{u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k}{(\\Delta x)^2} + c_y^2 \\frac{u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k}{(\\Delta y)^2}\n$$\n解出 $u_{i,j}^{k+1}$，我们得到三层时间步进格式：\n$$\nu_{i,j}^{k+1} = 2u_{i,j}^k - u_{i,j}^{k-1} + \\left(\\frac{c_x \\Delta t}{\\Delta x}\\right)^2(u_{i+1,j}^k - 2u_{i,j}^k + u_{i-1,j}^k) + \\left(\\frac{c_y \\Delta t}{\\Delta y}\\right)^2(u_{i,j+1}^k - 2u_{i,j}^k + u_{i,j-1}^k)\n$$\n此公式根据时间步 $k$ 和 $k-1$ 的解来计算时间步 $k+1$ 的解。该公式适用于 $k \\geq 1$。\n\n对于第一个时间步 ($k=0$)，我们必须使用初始条件。状态 $u_{i,j}^0$ 由 $u(x_i, y_j, 0)$ 给出。为了求得 $u_{i,j}^1$，我们需要虚拟状态 $u_{i,j}^{-1}$。这可以通过使用中心差分对初始速度条件 $\\frac{\\partial u}{\\partial t}(x,y,0)=0$ 进行离散化得到：\n$$\n\\frac{\\partial u}{\\partial t}\\Bigg|_{i,j,0} \\approx \\frac{u_{i,j}^1 - u_{i,j}^{-1}}{2\\Delta t} = 0 \\implies u_{i,j}^{-1} = u_{i,j}^1\n$$\n将 $u_{i,j}^{-1} = u_{i,j}^1$ 代入 $k=0$ 时的一般更新公式：\n$$\nu_{i,j}^1 = 2u_{i,j}^0 - u_{i,j}^1 + (\\Delta t)^2 \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\n解出 $u_{i,j}^1$ 得到第一步的二层格式：\n$$\nu_{i,j}^1 = u_{i,j}^0 + \\frac{(\\Delta t)^2}{2} \\left[ c_x^2 \\frac{u_{i+1,j}^0 - 2u_{i,j}^0 + u_{i-1,j}^0}{\\Delta x^2} + c_y^2 \\frac{u_{i,j+1}^0 - 2u_{i,j}^0 + u_{i,j-1}^0}{\\Delta y^2} \\right]\n$$\n通过在所有时间步将数值网格边界上的值设为零，来施加齐次 Dirichlet 边界条件 $u=0$。\n\n总体算法如下：\n1.  初始化参数并创建空间网格。\n2.  计算 $t=0$ 时的初始状态 $u^0$。该数组将代表“前一”时间步的解，$u_{\\text{prev}}$。\n3.  使用特殊的第一步公式计算 $t=\\Delta t$ 时的状态 $u^1$。该数组代表“当前”解，$u_{\\text{curr}}$。\n4.  从 $k=1$ 迭代到 $N-1$：\n    a. 使用通用的三层更新公式，根据 $u_{\\text{curr}} (= u^k)$ 和 $u_{\\text{prev}} (= u^{k-1})$ 计算下一个状态 $u^{k+1}$。\n    b. 为下一次迭代更新状态数组：$u_{\\text{prev}}$ 变为 $u_{\\text{curr}}$，而 $u_{\\text{curr}}$ 变为新计算出的 $u^{k+1}$。通过高效管理内存以避免重复的内存分配。\n5.  经过 $N$ 步后，数组 $u_{\\text{curr}}$ 存储了最终时刻 $t_N = N \\Delta t$ 的数值解。\n6.  在相同网格上计算 $t_N$ 时刻的精确解。\n7.  通过在整个网格上逐点比较数值解和精确解，计算最大绝对误差。\n\n为每个测试用例实施此过程。为提高效率，使用了 NumPy 的向量化数组操作。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T)\n        (1.0, 1.0, 1.0, 2.0, 1, 1, 81, 81, 0.005, 0.5),   # Case A\n        (1.0, 1.0, 0.5, 3.0, 2, 3, 101, 71, 0.0042, 0.28), # Case B\n        (1.0, 1.0, 2.0, 2.5, 3, 1, 65, 65, 0.0047, 0.235), # Case C\n    ]\n\n    results = []\n    for params in test_cases:\n        error = solve_wave_equation_2d(*params)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_wave_equation_2d(Lx, Ly, cx, cy, m, n, Nx, Ny, dt, T):\n    \"\"\"\n    Numerically solves the 2D anisotropic wave equation for a single test case.\n\n    Implements a finite-difference time-domain (FDTD) scheme with second-order\n    central differences in space and time.\n    \"\"\"\n    # 1. Grid and parameter setup\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n    \n    x = np.linspace(0, Lx, Nx)\n    y = np.linspace(0, Ly, Ny)\n    # 'ij' indexing ensures X.shape is (Nx, Ny) and corresponds to u[i, j]\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # 2. Initial conditions\n    # u_prev stores the solution at the previous time step (k-1)\n    # u_curr stores the solution at the current time step (k)\n    \n    # Initialize u_prev to u(t=0)\n    u_prev = np.sin(m * np.pi * X / Lx) * np.sin(n * np.pi * Y / Ly)\n    \n    # Initialize u_curr to zeros, which respects boundary conditions\n    u_curr = np.zeros_like(u_prev)\n\n    # 3. Calculate first time step (t=dt) using special update rule\n    # This is a discrete version of the spatial operator L(u)\n    lap_u0 = (cx**2 * (u_prev[0:-2, 1:-1] - 2*u_prev[1:-1, 1:-1] + u_prev[2:, 1:-1]) / dx**2 +\n              cy**2 * (u_prev[1:-1, 0:-2] - 2*u_prev[1:-1, 1:-1] + u_prev[1:-1, 2:]) / dy**2)\n    \n    # Update interior points for u(t=dt)\n    u_curr[1:-1, 1:-1] = u_prev[1:-1, 1:-1] + 0.5 * dt**2 * lap_u0\n\n    # 4. Time-stepping loop\n    num_steps = round(T / dt)\n    # Loop from k=1 up to num_steps-1 to calculate u^2, u^3, ..., u^N\n    for _ in range(1, num_steps):\n        # Calculate Laplacian of the current state u_curr\n        lap_uk = (cx**2 * (u_curr[0:-2, 1:-1] - 2*u_curr[1:-1, 1:-1] + u_curr[2:, 1:-1]) / dx**2 +\n                  cy**2 * (u_curr[1:-1, 0:-2] - 2*u_curr[1:-1, 1:-1] + u_curr[1:-1, 2:]) / dy**2)\n        \n        # Calculate the interior of the next state u_next using the general update rule\n        u_next_interior = (2.0 * u_curr[1:-1, 1:-1] - u_prev[1:-1, 1:-1] + dt**2 * lap_uk)\n        \n        # Swap arrays to advance time, reusing memory\n        # u_prev will now hold u_curr's data\n        # u_curr will be overwritten with u_next's data\n        u_prev, u_curr = u_curr, u_prev\n        u_curr[1:-1, 1:-1] = u_next_interior\n\n    # 5. Final time and exact solution\n    final_time = num_steps * dt\n    omega = np.sqrt(cx**2 * (m * np.pi / Lx)**2 + cy**2 * (n * np.pi / Ly)**2)\n    \n    u_exact = (np.sin(m * np.pi * X / Lx) * \n               np.sin(n * np.pi * Y / Ly) * \n               np.cos(omega * final_time))\n    \n    # 6. Calculate and return final error\n    # The error is the maximum absolute difference over all grid points.\n    error = np.max(np.abs(u_curr - u_exact))\n    \n    return error\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449882"}, {"introduction": "波动方程不仅描述宏观现象，它也是量子力学的核心。下一个练习 [@problem_id:2449888] 将带你进入量子世界，求解含时薛定谔方程。我们将使用一种与FDTD截然不同但极为高效的方法——分步傅里叶法（Split-Step Fourier Method），来模拟一个波包在非寻常势场中的演化，这展示了数值方法在不同物理领域的广泛适用性。", "problem": "考虑一个单位质量的粒子在具有周期性边界条件的有限区间上、在空间变化的势场中的一维含时薛定谔方程。使用无量纲单位，其中约化普朗克常数设为1，即 $\\hbar = 1$，质量为 $m = 1$。波函数 $\\psi(x,t)$ 满足\n$$\ni \\frac{\\partial \\psi(x,t)}{\\partial t} \\;=\\; -\\frac{1}{2}\\,\\frac{\\partial^2 \\psi(x,t)}{\\partial x^2} \\;+\\; V(x)\\,\\psi(x,t),\n$$\n势为倒谐振子势\n$$\nV(x) \\;=\\; -k\\,x^2,\n$$\n其中 $k \\ge 0$ 是一个实常数。\n\n计算域为区间 $x \\in [-L, L)$，带有周期性边界条件，其中 $L = 50$。$t=0$ 时刻的初始条件是一个归一化的高斯波包，中心位于 $x_0$，宽度参数为 $\\sigma$，平均动量为 $p_0$，\n$$\n\\psi(x,0) \\;=\\; \\frac{1}{(\\pi \\sigma^2)^{1/4}} \\exp\\!\\left( -\\frac{(x-x_0)^2}{2\\sigma^2} + i\\,p_0\\,(x-x_0) \\right).\n$$\n取 $x_0 = -8$，$\\sigma = 1$，以及 $p_0 = 2$。使用一个包含 $N = 2048$ 个点、跨越 $[-L,L)$ 的均匀空间网格，以及时间步长为 $\\Delta t = 10^{-3}$ 的均匀时间网格。\n\n您的任务是，对于以下三个测试用例中的每一个，在给定的域和时间范围内计算 $\\psi(x,t)$ 的数值近似解。对于每个测试用例，请报告一个如下指定的标量值。所有量均为无量纲。\n\n测试组：\n- 用例 A (自由传播)：$k = 0$，最终时间 $T = 1.5$。令 $\\langle x \\rangle_T$ 表示在时间 $T$ 时位置的数值计算期望值，定义为\n$$\n\\langle x \\rangle_T \\;=\\; \\frac{\\int_{-L}^{L} x\\,|\\psi(x,T)|^2\\,dx}{\\int_{-L}^{L} |\\psi(x,T)|^2\\,dx}.\n$$\n对于一个 $m=1$ 的自由粒子，其中心的精确预测值为 $x_{\\mathrm{pred}}(T) = x_0 + p_0\\,T$。输出绝对误差\n$$\nE_A \\;=\\; \\left|\\, \\langle x \\rangle_T \\;-\\; x_{\\mathrm{pred}}(T) \\,\\right|.\n$$\n- 用例 B (弱倒置势)：$k = 0.02$，最终时间 $T = 1.0$。令 $\\mathcal{N}_T = \\int_{-L}^{L} |\\psi(x,T)|^2\\,dx$ 为时间 $T$ 时的范数。输出与1的绝对偏差\n$$\nE_B \\;=\\; \\left|\\, 1 \\;-\\; \\mathcal{N}_T \\,\\right|.\n$$\n- 用例 C (强倒置势)：$k = 0.2$，最终时间 $T = 0.8$。令 $\\sigma_x(t)$ 表示在时间 $t$ 时位置的标准差，\n$$\n\\sigma_x(t) \\;=\\; \\sqrt{\\langle x^2 \\rangle_t - \\langle x \\rangle_t^2}, \\quad \\langle x^n \\rangle_t \\;=\\; \\frac{\\int_{-L}^{L} x^n\\,|\\psi(x,t)|^2\\,dx}{\\int_{-L}^{L} |\\psi(x,t)|^2\\,dx}.\n$$\n输出比值\n$$\nR_C \\;=\\; \\frac{\\sigma_x(T)}{\\sigma_x(0)}.\n$$\n\n所有空间积分的计算都必须与指定的均匀网格保持一致。您的程序应生成单行输出，其中包含按 $[E_A, E_B, R_C]$ 顺序排列的结果，形式为一个用方括号括起来的逗号分隔列表，例如 $[a,b,c]$，其中 $a$、$b$ 和 $c$ 均为浮点数。", "solution": "该问题是有效的。它为一维含时薛定谔方程（量子力学中的一个基本方程）提出了一个适定的初边值问题。所有参数、条件和目标都以足够的清晰度和科学严谨性进行了规定，从而能够得到唯一的数值解。\n\n该问题要求数值求解含时薛定谔方程 (TDSE)：\n$$\ni \\frac{\\partial \\psi(x,t)}{\\partial t} = \\hat{H} \\psi(x,t)\n$$\n其中哈密顿算符 $\\hat{H}$ 是动能算符 $\\hat{T}$ 和势能算符 $\\hat{V}$ 的和：\n$$\n\\hat{H} = \\hat{T} + \\hat{V} = -\\frac{1}{2}\\,\\frac{\\partial^2}{\\partial x^2} + V(x)\n$$\n常数 $\\hbar=1$ 和 $m=1$。由于动能算符 $\\hat{T}$ 和势能算符 $\\hat{V}$ 通常不对易，时间演化算符 $e^{-i\\hat{H}\\Delta t}$ 不能简单地进行因式分解。\n\n解决此类问题最合适且最高效的数值方法是**分裂步傅里叶方法 (Split-Step Fourier Method)**。我们采用一种二阶对称分裂格式，也称为 Strang 分裂，该方法既精确又幺正，因此能够使范数 $|\\psi|^2$ 随时间演化而守恒。此格式将单个时间步长 $\\Delta t$ 的演化算符近似为：\n$$\nU(\\Delta t) = e^{-i\\hat{H}\\Delta t} \\approx e^{-i\\hat{V}\\Delta t/2} \\, e^{-i\\hat{T}\\Delta t} \\, e^{-i\\hat{V}\\Delta t/2} + \\mathcal{O}(\\Delta t^3)\n$$\n在有限时间区间 $T$ 内，全局误差的量级为 $\\mathcal{O}(\\Delta t^2)$。对于每个时间增量，该算符的作用通过三个连续步骤实现。令 $\\psi_n = \\psi(x, n\\Delta t)$。\n\n$1$. **第一步势能半步演化：** 波函数在势能算符 $\\hat{V}$ 下演化 $\\Delta t/2$ 的时间。在坐标表象中，这只是一个简单的乘法：\n$$\n\\psi'(x) = e^{-iV(x)\\Delta t/2} \\psi_n(x)\n$$\n\n$2$. **完整动能步演化：** 波函数接着在动能算符 $\\hat{T}$ 下演化一个完整的时间步长 $\\Delta t$。此操作在傅里叶（动量）空间中执行效率最高。动能算符 $\\hat{T} = -\\frac{1}{2}\\frac{\\partial^2}{\\partial x^2}$ 在波数 $k_x$ 空间中变为一个乘法算符 $\\frac{k_x^2}{2}$。该过程为：\n   a. 将 $\\psi'(x)$ 变换到傅里叶空间：$\\tilde{\\psi}'(k_x) = \\mathcal{F}[\\psi'(x)]$。\n   b. 乘以动能演化因子：$\\tilde{\\psi}''(k_x) = e^{-i (k_x^2/2) \\Delta t} \\tilde{\\psi}'(k_x)$。\n   c. 变换回坐标空间：$\\psi''(x) = \\mathcal{F}^{-1}[\\tilde{\\psi}''(k_x)]$。\n这里，$\\mathcal{F}$ 和 $\\mathcal{F}^{-1}$ 分别表示快速傅里叶变换 (FFT) 及其逆变换。\n\n$3$. **第二步势能半步演化：** 最后在势能算符下再演化 $\\Delta t/2$ 的时间，完成该时间步：\n$$\n\\psi_{n+1}(x) = e^{-iV(x)\\Delta t/2} \\psi''(x)\n$$\n\n总体的数值算法如下：\n首先，我们使用 $N$ 个均匀间隔的点 $x_j$ 来离散化空间域 $x \\in [-L, L)$，网格间距为 $\\Delta x = 2L/N$。我们还定义了 FFT 所需的相应波数网格 $k_{x,j}$。\n\n接下来，我们在空间网格 $x_j$ 上计算初始波函数 $\\psi(x,0)$。\n\n然后，通过重复应用三步 Strang 分裂过程，将系统从 $t=0$ 演化到最终时间 $T$，总共演化 $N_t = T/\\Delta t$ 个时间步。\n\n最后，我们计算所需的物理可观测量。根据问题规定，函数 $f(x)$ 的空间积分通过对网格点上的离散求和来近似：\n$$\n\\int_{-L}^{L} f(x)\\,dx \\approx \\sum_{j=0}^{N-1} f(x_j)\\,\\Delta x\n$$\n可观测量 $\\hat{A}$ 的期望值计算如下：\n$$\n\\langle A \\rangle_t = \\frac{\\int_{-L}^{L} \\psi^*(x,t) [\\hat{A}\\psi(x,t)] \\,dx}{\\int_{-L}^{L} |\\psi(x,t)|^2\\,dx} \\approx \\frac{\\sum_j (\\psi^* \\hat{A}\\psi)_j}{\\sum_j |\\psi_j|^2}\n$$\n其中 $\\Delta x$ 因子被消掉了。对于像 $x^n$ 这样依赖于位置的可观测量，这简化为对概率密度 $|\\psi(x,t)|^2$ 的加权平均。\n\n每个用例的具体量都是基于这些原理，使用最终波函数 $\\psi(x,T)$ 以及（对于用例 C）初始波函数 $\\psi(x,0)$ 来计算的。\n\n- **用例 A：** $E_A = |\\langle x \\rangle_T - (x_0 + p_0T)|$。$\\langle x \\rangle_T$ 是根据最终状态 $\\psi(x,T)$ 计算的。\n- **用例 B：** $E_B = |1 - \\mathcal{N}_T|$。计算范数 $\\mathcal{N}_T = \\int_{-L}^{L} |\\psi(x,T)|^2 dx$。由于数值格式是幺正的，这个值预计会非常小，反映了概率守恒。\n- **用例 C：** $R_C = \\sigma_x(T)/\\sigma_x(0)$。对 $t=0$ 和 $t=T$ 两个时刻计算标准差 $\\sigma_x(t) = \\sqrt{\\langle x^2 \\rangle_t - \\langle x \\rangle_t^2}$。\n\n所提供的代码实现了这一完整过程，以确定 $E_A$、$E_B$ 和 $R_C$ 的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-dependent Schrödinger equation using the split-step Fourier method\n    for three specified test cases and prints the results.\n    \"\"\"\n\n    # Global parameters from the problem statement\n    L_param = 50.0\n    N_param = 2048\n    dt_param = 1e-3\n    x0_param = -8.0\n    sigma_param = 1.0\n    p0_param = 2.0\n\n    # Discretization of the spatial and momentum domains\n    dx = 2 * L_param / N_param\n    x_grid = -L_param + np.arange(N_param) * dx\n    k_grid = 2 * np.pi * np.fft.fftfreq(N_param, d=dx)\n\n    # Initial wave function (normalized Gaussian wave packet)\n    norm_const = (np.pi * sigma_param**2)**(-0.25)\n    phase = 1j * p0_param * (x_grid - x0_param)\n    envelope = -(x_grid - x0_param)**2 / (2 * sigma_param**2)\n    psi0 = norm_const * np.exp(envelope + phase)\n\n    def compute_observables(psi):\n        \"\"\"Computes norm, expectation value of x, and expectation value of x^2.\"\"\"\n        prob_density = np.abs(psi)**2\n        norm_sum = np.sum(prob_density)\n        \n        # Expectation values are ratios, so the dx factor from integration cancels\n        x_exp = np.sum(x_grid * prob_density) / norm_sum\n        x2_exp = np.sum(x_grid**2 * prob_density) / norm_sum\n        \n        # The true norm requires multiplication by dx\n        norm_val = dx * norm_sum\n        \n        return norm_val, x_exp, x2_exp\n\n    def run_simulation(k, T):\n        \"\"\"\n        Runs the split-step simulation for a given potential parameter k and final time T.\n        \"\"\"\n        num_steps = int(round(T / dt_param))\n\n        # Potential V(x) = -k*x^2\n        V = -k * x_grid**2\n        \n        # Pre-compute time evolution operators for efficiency\n        potential_op_half = np.exp(-0.5j * V * dt_param)\n        kinetic_op_full = np.exp(-1.0j * 0.5 * k_grid**2 * dt_param)\n        \n        psi = psi0.copy()\n        \n        for _ in range(num_steps):\n            # Strang splitting a.k.a. symmetric split-step method\n            psi = potential_op_half * psi\n            psi = np.fft.ifft(kinetic_op_full * np.fft.fft(psi))\n            psi = potential_op_half * psi\n            \n        return psi\n\n    # --- Test Case A: Free Propagation ---\n    k_A = 0.0\n    T_A = 1.5\n    psi_A = run_simulation(k_A, T_A)\n    _, x_exp_A, _ = compute_observables(psi_A)\n    x_pred_A = x0_param + p0_param * T_A\n    E_A = np.abs(x_exp_A - x_pred_A)\n\n    # --- Test Case B: Weak Inverted Potential ---\n    k_B = 0.02\n    T_B = 1.0\n    psi_B = run_simulation(k_B, T_B)\n    norm_T_B, _, _ = compute_observables(psi_B)\n    E_B = np.abs(1.0 - norm_T_B)\n\n    # --- Test Case C: Stronger Inverted Potential ---\n    k_C = 0.2\n    T_C = 0.8\n    # Calculate observables at t=0\n    _, x_exp_0, x2_exp_0 = compute_observables(psi0)\n    variance_0 = x2_exp_0 - x_exp_0**2\n    sigma_x_0 = np.sqrt(variance_0)\n    \n    # Run simulation and calculate observables at t=T\n    psi_C = run_simulation(k_C, T_C)\n    _, x_exp_C, x2_exp_C = compute_observables(psi_C)\n    variance_C = x2_exp_C - x_exp_C**2\n    sigma_x_T = np.sqrt(variance_C)\n    \n    R_C = sigma_x_T / sigma_x_0\n    \n    # Collect results and format output\n    results = [E_A, E_B, R_C]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2449888"}, {"introduction": "最后一个练习 [@problem_id:2449910] 将我们前面学到的技能整合到一个更具实际应用背景的项目中：模拟一个二维房间中的声波传播。这个练习不仅要求你应用FDTD方法处理更复杂的诺伊曼（Neumann）边界条件，还需要你通过傅里叶变换等信号处理技术，从仿真数据中提取出如驻波频率等具有物理意义的结果。这让你能够体验计算物理在声学设计等工程问题中的实际应用。", "problem": "考虑一个由线性波动方程控制的二维标量声压场\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right),\n$$\n在一个矩形域 $$0 \\le x \\le L_x$$ 和 $$0 \\le y \\le L_y$$ 内，壁面为刚性，因此压力在边界上的外法向导数为零，\n$$\n\\left.\\frac{\\partial p}{\\partial n}\\right|_{\\partial \\Omega} = 0,\n$$\n即 Neumann 边界条件。设 $$c$$ 为恒定声速，单位为米/秒。您将使用在时间和空间上均为二阶精度的中心差分格式，在一个 $$\\Delta x = \\Delta y$$ 的均匀笛卡尔网格上，对时间演化进行数值建模。设 $$\\Delta t$$ 为时间步长。该格式必须满足适用于等间距二维空间的 Courant–Friedrichs–Lewy (CFL) 稳定性约束。初始状态为静止，场由一个在第一个时间步施加于内部网格节点的单个脉冲源激励。另一个内部网格节点上的接收器记录压力时间序列。不使用物理阻尼。\n\n您的任务是实现一个完整的程序，该程序能够：\n- 使用时间和空间上的二阶中心差分对波动方程进行离散化。\n- 在所有四个壁面上对 $$p$$ 实施与离散化一致的 Neumann 边界条件。\n- 使用均匀的空间步长 $$\\Delta x = \\Delta y$$。\n- 使用通过 Courant 数 $$s$$ 选择的时间步长 $$\\Delta t$$，其中 $$s$$ 满足二维稳定性约束，且 $$\\Delta t = s \\, \\Delta x / c$$。\n- 在时间索引 $$n=0$$ 时，在一个源网格节点注入单位脉冲源，并在指定的总仿真时间 $$T$$ 内记录一个接收器网格节点上的压力。\n- 通过计算所记录时间序列的离散傅里叶变换幅值，并针对三个解析上最低的非零模式中的每一个，在相应解析频率周围的窄频率窗口中搜索主导谱峰，来估计三个最低的驻波模式频率（单位为赫兹）。\n\n仅使用以下基础事实：\n- 上述标量波动方程以及矩形域上的 Neumann 边界条件的定义。\n- 一阶和二阶导数的二维均匀网格中心差分近似。\n- 多维显式双曲格式的稳定性约束概念。\n- 具有刚性壁（Neumann 边界条件）的矩形腔的解析非零本征频率由下式给出\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2},\n$$\n对于非负整数 $$m,n$$（不全为零），且排除 $$f_{0,0}=0$$。当 $$L_x=L_y$$ 时可能出现简并。\n\n您必须遵守的数值细节：\n- 使用 $$\\Delta x$$（单位为米）、$$\\Delta t$$（单位为秒）、$$c$$（单位为米/秒）、长度 $$L_x, L_y$$（单位为米）以及总时间 $$T$$（单位为秒）。频率必须以赫茲报告。\n- 选择 Courant 数 $$s$$，使得显式格式在二维且 $$\\Delta x = \\Delta y$$ 的情况下是稳定的。\n- 为稳健地估计模态频率，在计算离散傅里叶变换之前，对记录的时间序列应用 Hann 窗。在加窗前移除记录信号的均值以抑制零频分量。当搜索与给定解析频率 $$f_{m,n}$$ 对应的测量频率时，在以 $$f_{m,n}$$ 为中心、宽度设置为 $$5\\ \\text{Hz}$$ 或 $$0.15 f_{m,n}$$ 中较大值的对称窗口内搜索最大幅值的谱箱，该窗口被限制在总体分析频带内。\n- 将所有最终频率误差表示为绝对相对误差，即 $$\\left| \\hat{f} - f \\right| / f$$，形式为小数（无单位）。\n\n测试套件：\n对以下三个测试用例运行您的程序。在所有情况下，设置 $$c = 343\\ \\text{m/s}$$，$$\\Delta x = \\Delta y = 0.1\\ \\text{m}$$，Courant 数 $$s = 0.5$$ 以使得 $$\\Delta t = s \\Delta x / c$$，以及总仿真时间 $$T = 1.6\\ \\text{s}$$。将脉冲源放置在 $$x_s = 0.37 L_x$$，$$y_s = 0.41 L_y$$，接收器放置在 $$x_r = 0.23 L_x$$，$$y_r = 0.67 L_y$$，两者都吸附到最近的网格节点。使用 $$20\\ \\text{Hz} \\le f \\le 300\\ \\text{Hz}$$ 的分析频带。\n- 用例 1 (一般矩形房间): $$L_x = 3.0\\ \\text{m}$$，$$L_y = 4.0\\ \\text{m}$$。\n- 用例 2 (方形房间): $$L_x = 2.0\\ \\text{m}$$，$$L_y = 2.0\\ \\text{m}$$。\n- 用例 3 (细长房间): $$L_x = 5.0\\ \\text{m}$$，$$L_y = 2.0\\ \\text{m}$$。\n\n对于每个用例，计算三个最低的非零解析模态频率 $$f_{m,n}$$，如上所述从仿真频谱中识别出它们的测量对应值，并以小数形式报告三个绝对相对误差。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含九个结果（按用例 1、用例 2、用例 3 的顺序，每个用例三个结果），形式为用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4,r5,r6,r7,r8,r9]”）。每个条目必须是十进制数。", "solution": "问题陈述已经过评估，被确定为科学上合理、适定且完整。它描述了计算声学中的一个标准问题：在封闭二维域中模拟波传播及其共振频率的后续分析。我们接下来进行解的推导和实现。\n\n控制方程是关于声压 $$p(x,y,t)$$ 的二维线性标量波动方程：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} = c^2 \\left( \\frac{\\partial^2 p}{\\partial x^2} + \\frac{\\partial^2 p}{\\partial y^2} \\right) = c^2 \\nabla^2 p\n$$\n其中 $$c$$ 是恒定的声速。该问题将使用时域有限差分 (FDTD) 方法在均匀笛卡尔网格上进行数值求解。\n\n设离散压力场表示为 $$p_{i,j}^n \\approx p(i\\Delta x, j\\Delta y, n\\Delta t)$$，其中 $$i, j, n$$ 是空间和时间的整数索引，$$\\Delta x, \\Delta y, \\Delta t$$ 是相应的步长。已知 $$\\Delta x = \\Delta y$$。\n\n我们使用二阶精度中心差分近似来离散化偏导数：\n$$\n\\frac{\\partial^2 p}{\\partial t^2} \\approx \\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2}\n$$\n$$\n\\nabla^2 p \\approx \\frac{p_{i+1,j}^n - 2p_{i,j}^n + p_{i-1,j}^n}{(\\Delta x)^2} + \\frac{p_{i,j+1}^n - 2p_{i,j}^n + p_{i,j-1}^n}{(\\Delta y)^2}\n$$\n将这些近似代入波动方程，并注意到 $$\\Delta x = \\Delta y$$，我们得到离散更新方程：\n$$\n\\frac{p_{i,j}^{n+1} - 2p_{i,j}^n + p_{i,j}^{n-1}}{(\\Delta t)^2} = c^2 \\left( \\frac{p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n}{(\\Delta x)^2} \\right)\n$$\n求解下一时间步的压力 $$p_{i,j}^{n+1}$$，得到显式 FDTD 格式：\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\n量 $$s = c\\Delta t/\\Delta x$$ 是 Courant 数。于是更新方程为：\n$$\np_{i,j}^{n+1} = 2p_{i,j}^n - p_{i,j}^{n-1} + s^2 \\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - 4p_{i,j}^n \\right)\n$$\n为使此显式格式在二维且 $$\\Delta x = \\Delta y$$ 的情况下数值稳定，Courant 数 $$s$$ 必须满足 Courant–Friedrichs–Lewy (CFL) 条件：\n$$\ns \\le \\frac{1}{\\sqrt{2}} \\approx 0.7071\n$$\n指定的 Courant 数 $$s = 0.5$$ 符合此条件，确保了稳定性。\n\n仿真从静止状态开始，意味着初始条件为 $$p(x,y,0) = 0$$ 和 $$\\frac{\\partial p}{\\partial t}(x,y,0) = 0$$。在离散形式下，$$p_{i,j}^0 = 0$$。零速度条件通过在 $$n=0$$ 处对时间导数使用中心差分来实现：\n$$\n\\frac{p_{i,j}^1 - p_{i,j}^{-1}}{2\\Delta t} = 0 \\implies p_{i,j}^{-1} = p_{i,j}^1\n$$\n将 $$n=0$$ 代入更新方程并使用 $$p_{i,j}^{-1} = p_{i,j}^1$$，可以消除对虚拟时间层 $$n=-1$$ 的需求。然而，一个更简单的方法是将两个压力场 $$p^n$$ 和 $$p^{n-1}$$ 都初始化为零。脉冲源在第一个时间步 $$n=0$$ 作为附加项引入。设源位于网格节点 $$(i_s, j_s)$$。$$p_{i,j}^1$$ 的更新方程包含一个源项，我们通过在第一个更新步骤中，在源位置的压力场上增加一个与 $$\\Delta t$$ 成正比的值来对其建模。这修改了 $$p^1$$ 的计算：\n$$\np_{i_s,j_s}^1 = 2p_{i_s,j_s}^0 - p_{i_s,j_s}^{-1} + s^2(...)_{i_s,j_s}^0 + \\text{source} \\cdot \\delta_{n,0}\n$$\n在静止初始条件下，这简化了时间演化。源在时间索引 $$n=0$$ 处施加，影响时间索引 $$n=1$$ 处压力场的计算。\n\n边界条件是刚性壁（Neumann）类型，即 $$\\partial p / \\partial n = 0$$，其中 $$\\mathbf{n}$$ 是外指法向量。对于 $$x=0$$ 处的壁面，即 $$\\partial p / \\partial x = 0$$。在边界节点 $$i=0$$ 处用二阶中心差分离散化此条件得到：\n$$\n\\frac{p_{1,j}^n - p_{-1,j}^n}{2\\Delta x} = 0 \\implies p_{-1,j}^n = p_{1,j}^n\n$$\n其中 $$p_{-1,j}^n$$ 是域外“鬼点”处的压力。这个鬼点值用于边界点的主更新模板中。例如，在 $$i=0$$ 处，项 $$p_{i-1,j}^n$$ 变为 $$p_{1,j}^n$$。左侧壁面（$$i=0$$）上一点的更新规则变为：\n$$\np_{0,j}^{n+1} = 2p_{0,j}^n - p_{0,j}^{n-1} + s^2 \\left( 2p_{1,j}^n + p_{0,j+1}^n + p_{0,j-1}^n - 4p_{0,j}^n \\right)\n$$\n类似的规则适用于其他三个壁面和四个角点。实现这一目标的一个系统性方法是，在每次计算空间导数之前，用一层鬼点单元填充压力网格，并根据这些关系填充它们的值。\n\n仿真是通过对总时间步数 $$N_t = \\lfloor T/\\Delta t \\rfloor$$ 迭代应用更新方程来进行的。在每一步，记录接收器位置 $$(i_r, j_r)$$ 的压力，形成一个时间序列。\n\n对于频率分析，首先处理记录的时间序列，移除其均值以消除直流分量。然后，应用 Hann 窗以减少谱泄漏。使用快速傅里叶变换 (FFT) 算法计算加窗信号的离散傅里叶变换 (DFT)，从而得到幅度谱。\n\n给定域在 Neumann 边界条件下的解析本征频率为：\n$$\nf_{m,n} = \\frac{c}{2}\\sqrt{\\left(\\frac{m}{L_x}\\right)^2 + \\left(\\frac{n}{L_y}\\right)^2}\n$$\n其中 $$m, n$$ 是非负整数，不全为零。对于每个测试用例，我们计算三个最低的不同非零解析频率。\n\n对于每个解析频率 $$f_{\\text{anal}}$$，我们在计算出的频谱中搜索其测量的对应值 $$\\hat{f}_{\\text{meas}}$$。搜索在一个以 $$f_{\\text{anal}}$$ 为中心、宽度为 $$\\max(5 \\text{ Hz}, 0.15 f_{\\text{anal}})$$ 的频率窗口内进行。此窗口被限制在指定的分析频带 $$[20 \\text{ Hz}, 300 \\text{ Hz}]$$ 内。此搜索窗口内最大幅值峰值对应的频率被取为 $$\\hat{f}_{\\text{meas}}$$。\n\n最后，每个模态频率的绝对相对误差计算如下：\n$$\n\\text{Error} = \\frac{|\\hat{f}_{\\text{meas}} - f_{\\text{anal}}|}{f_{\\text{anal}}}\n$$\n对所有三个测试用例重复此过程，并报告九个得出的误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Lx, Ly)\n        (3.0, 4.0),  # Case 1\n        (2.0, 2.0),  # Case 2\n        (5.0, 2.0),  # Case 3\n    ]\n\n    all_results = []\n    for Lx, Ly in test_cases:\n        errors = run_simulation_and_analyze(Lx, Ly)\n        all_results.extend(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in all_results)}]\")\n\ndef run_simulation_and_analyze(Lx, Ly):\n    \"\"\"\n    Runs the FDTD simulation for a given geometry and analyzes the results.\n    Returns a list of three relative frequency errors.\n    \"\"\"\n    # --- 1. Simulation Setup ---\n\n    # Constants and parameters\n    c = 343.0      # Speed of sound (m/s)\n    dx = 0.1       # Spatial step (m), dy = dx\n    s = 0.5        # Courant number\n    T = 1.6        # Total simulation time (s)\n\n    # Derived parameters\n    dt = s * dx / c\n    Nx = int(round(Lx / dx)) + 1\n    Ny = int(round(Ly / dx)) + 1\n    Nt = int(np.floor(T / dt))\n\n    # Effective dimensions based on grid\n    Lx_eff = (Nx - 1) * dx\n    Ly_eff = (Ny - 1) * dx\n\n    # Source and receiver locations (snapped to grid)\n    xs_frac, ys_frac = 0.37, 0.41\n    xr_frac, yr_frac = 0.23, 0.67\n    is_ = int(round(xs_frac * (Nx - 1)))\n    js_ = int(round(ys_frac * (Ny - 1)))\n    ir_ = int(round(xr_frac * (Nx - 1)))\n    jr_ = int(round(yr_frac * (Ny - 1)))\n    \n    # Pressure fields (current, previous)\n    p_now = np.zeros((Nx, Ny), dtype=np.float64)\n    p_prev = np.zeros((Nx, Ny), dtype=np.float64)\n    \n    receiver_signal = np.zeros(Nt, dtype=np.float64)\n    s2 = s**2\n\n    # --- 2. FDTD Simulation Loop ---\n    \n    p_padded = np.zeros((Nx + 2, Ny + 2), dtype=np.float64)\n\n    for n in range(Nt):\n        # Apply Neumann boundary conditions using ghost cells\n        p_padded[1:-1, 1:-1] = p_now\n        \n        # Walls\n        p_padded[0, 1:-1] = p_padded[2, 1:-1]      # x=0\n        p_padded[-1, 1:-1] = p_padded[-3, 1:-1]    # x=Lx\n        p_padded[1:-1, 0] = p_padded[1:-1, 2]      # y=0\n        p_padded[1:-1, -1] = p_padded[1:-1, -3]    # y=Ly\n\n        # Corners\n        p_padded[0, 0] = p_padded[2, 2]\n        p_padded[-1, 0] = p_padded[-3, 2]\n        p_padded[0, -1] = p_padded[2, -3]\n        p_padded[-1, -1] = p_padded[-3, -3]\n\n        # Calculate Laplacian using the padded grid\n        laplacian = (p_padded[2:, 1:-1] + p_padded[:-2, 1:-1] +\n                     p_padded[1:-1, 2:] + p_padded[1:-1, :-2] - 4 * p_now)\n\n        # Update pressure field\n        p_next = 2 * p_now - p_prev + s2 * laplacian\n\n        # Inject impulsive source at n=0\n        if n == 0:\n            # Source is applied to affect the field at n=1\n            p_next[is_, js_] += dt\n\n        # Update fields for next iteration\n        p_prev, p_now = p_now, p_next\n\n        # Record pressure at receiver\n        receiver_signal[n] = p_now[ir_, jr_]\n\n    # --- 3. Frequency Analysis ---\n\n    # Signal processing\n    signal_proc = receiver_signal - np.mean(receiver_signal)\n    signal_win = signal_proc * np.hanning(Nt)\n\n    # FFT\n    yf = fft.rfft(signal_win)\n    xf = fft.rfftfreq(Nt, d=dt)\n    spectrum = np.abs(yf)\n\n    # Analysis band\n    analysis_f_min, analysis_f_max = 20.0, 300.0\n\n    # --- 4. Analytical Frequencies and Error Calculation ---\n\n    # Find the 3 lowest non-zero analytical frequencies\n    modes = []\n    max_m, max_n = 10, 10\n    for m in range(max_m):\n        for n in range(max_n):\n            if m == 0 and n == 0:\n                continue\n            freq = (c / 2.0) * np.sqrt((m / Lx_eff)**2 + (n / Ly_eff)**2)\n            if freq > 0:\n                modes.append({'m': m, 'n': n, 'freq': freq})\n    \n    # Sort by frequency, handling degeneracies\n    modes.sort(key=lambda x: x['freq'])\n    unique_freqs = []\n    seen_freqs = set()\n    for mode in modes:\n        f_rounded = round(mode['freq'], 4)\n        if f_rounded not in seen_freqs:\n            unique_freqs.append(mode['freq'])\n            seen_freqs.add(f_rounded)\n        if len(unique_freqs) >= 3:\n            break\n            \n    analytical_freqs = unique_freqs[:3]\n    \n    errors = []\n    for f_anal in analytical_freqs:\n        # Define search window for peak picking\n        search_width = max(5.0, 0.15 * f_anal)\n        search_min = f_anal - search_width / 2.0\n        search_max = f_anal + search_width / 2.0\n        \n        # Clamp to analysis band\n        clamped_search_min = max(analysis_f_min, search_min)\n        clamped_search_max = min(analysis_f_max, search_max)\n\n        # Find indices for the search window in the FFT frequency array\n        idx_low = np.searchsorted(xf, clamped_search_min, side='left')\n        idx_high = np.searchsorted(xf, clamped_search_max, side='right')\n\n        if idx_low >= idx_high: \n            # If window is empty or outside range, this indicates a problem\n            # But for this problem, modes are expected to be found\n            errors.append(1.0) # Maximum error\n            continue\n\n        # Find peak in the search window\n        peak_idx_local = np.argmax(spectrum[idx_low:idx_high])\n        peak_idx_global = idx_low + peak_idx_local\n        f_meas = xf[peak_idx_global]\n        \n        # Calculate relative error\n        rel_error = np.abs(f_meas - f_anal) / f_anal\n        errors.append(rel_error)\n\n    return errors\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449910"}]}