{"hands_on_practices": [{"introduction": "本练习是一个基础的起点，我们将解决一个由拉普拉斯方程描述的经典稳态热分布问题。这里的关键挑战和学习目标是，学习如何使用“虚拟点”法这一计算物理中的通用技巧，来正确实现固定温度（狄利克雷）边界和绝热（诺伊曼）边界。通过这个练习，你将掌握处理不同边界条件的核心技能 [@problem_id:2397045]。", "problem": "考虑一个矩形板上的稳态温度场，该温度场由标量场 $T(x,y)$ 描述，并在域 $\\Omega = [0,L_x] \\times [0,L_y]$ 的内部满足拉普拉斯方程 $\\nabla^2 T = 0$。温度是无量纲的。板的边界 $\\partial \\Omega$ 可能具有固定的温度（狄利克雷条件）或完美的绝热（法向导数为零的诺伊曼条件）。一个在 $x$ 方向有 $N_x$ 个节点、在 $y$ 方向有 $N_y$ 个节点的均匀笛卡尔网格覆盖了整个矩形（包括其边界），网格间距为 $\\Delta x = L_x/(N_x - 1)$ 和 $\\Delta y = L_y/(N_y - 1)$。令 $T_{i,j}$ 表示网格节点 $(x_i,y_j)$ 处 $T$ 的离散近似值，其中 $x_i = i \\,\\Delta x$（对于 $i = 0,1,\\dots,N_x-1$）和 $y_j = j \\,\\Delta y$（对于 $j = 0,1,\\dots,N_y-1$）。\n\n您的任务是为下面指定的几种边界值配置计算离散解 $T_{i,j}$，使得对应于 $\\nabla^2 T = 0$ 的离散方程在整个内部区域都满足，且误差在规定的容差范围内。离散五点拉普拉斯算子应与施加在 $\\partial \\Omega$ 上的边界条件一致地进行解释。对于位于狄利克雷条件边界上的节点，其值 $T_{i,j}$ 必须等于规定的边界值。对于邻近绝热边界的节点，必须强制法向导数为零，以使内部解在与此约束一致的方式下满足拉普拉斯方程。数值解必须满足离散残差界\n$$\n\\max_{i,j \\text{ not Dirichlet}} \\left| \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{\\Delta x^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{\\Delta y^2} \\right| \\le \\varepsilon,\n$$\n其中边界上的有限差分表达式必须与边界数据一致，且 $\\varepsilon$ 在每个测试用例中给出。\n\n对于每个测试用例，您必须报告两个数值：\n- 标量值 $T_{\\mathrm{center}}$，定义为在最接近域几何中心的网格节点上计算出的温度。当 $N_x$ 和 $N_y$ 为奇数时，该节点索引为 $i_c = (N_x-1)/2$ 和 $j_c = (N_y-1)/2$，因此 $T_{\\mathrm{center}} = T_{i_c, j_c}$。\n- 标量 $S_{\\mathrm{Neu}}$，定义为在所有绝热（诺伊曼）边上的所有节点上，使用二阶单边有限差分计算的离散法向导数的最大绝对值。对于 $y=L_y$ 处的顶部边界，节点 $i$ 处的离散导数为\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{top},i} \\approx \\frac{-3 T_{i,N_y-1} + 4 T_{i,N_y-2} - T_{i,N_y-3}}{2 \\,\\Delta y}.\n$$\n对于 $y = 0$ 处的底部边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{bottom},i} \\approx \\frac{3 T_{i,0} - 4 T_{i,1} + T_{i,2}}{2 \\,\\Delta y}.\n$$\n对于 $x = 0$ 处的左侧边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{left},j} \\approx \\frac{3 T_{0,j} - 4 T_{1,j} + T_{2,j}}{2 \\,\\Delta x}.\n$$\n对于 $x = L_x$ 处的右侧边界，\n$$\n\\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{right},j} \\approx \\frac{-3 T_{N_x-1,j} + 4 T_{N_x-2,j} - T_{N_x-3,j}}{2 \\,\\Delta x}.\n$$\n于是\n$$\nS_{\\mathrm{Neu}} = \\max \\left( \\{\\left| \\left.\\frac{\\partial T}{\\partial n}\\right|_{\\mathrm{edge,node}} \\right| \\;\\text{over all insulated edges and their nodes}\\} \\right).\n$$\n\n使用以下测试套件。每个测试用例指定 $(L_x,L_y,N_x,N_y)$、按 $(\\text{左},\\text{右},\\text{下},\\text{上})$ 顺序排列的四个边界的边界条件、残差容差 $\\varepsilon$ 以及为确保终止而设定的最大迭代次数 $I_{\\max}$。狄利克雷边界用 $D$ 和一个值表示，绝热边界用 $N$ 表示，其法向导数为零。对于属于狄利克雷边界一部分的角点，该狄利克雷值适用于角点节点。\n\n- 测试用例 A:\n  - 几何参数: $L_x = 1$, $L_y = 1$, $N_x = 33$, $N_y = 33$。\n  - 边界条件: $(D:1,\\; D:0,\\; N:0,\\; N:0)$。\n  - 容差和最大迭代次数: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$。\n\n- 测试用例 B:\n  - 几何参数: $L_x = 2$, $L_y = 1$, $N_x = 31$, $N_y = 17$。\n  - 边界条件: $(N:0,\\; N:0,\\; D:1,\\; D:0)$。\n  - 容差和最大迭代次数: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$。\n\n- 测试用例 C:\n  - 几何参数: $L_x = 1$, $L_y = 1$, $N_x = 25$, $N_y = 25$。\n  - 边界条件: $(D:0.5,\\; D:0.5,\\; N:0,\\; N:0)$。\n  - 容差和最大迭代次数: $\\varepsilon = 10^{-8}$, $I_{\\max} = 20000$。\n\n您的程序必须按 A、B、C 的顺序计算每个测试用例的 $(T_{\\mathrm{center}}, S_{\\mathrm{Neu}})$，并生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。输出应按 $[T_{\\mathrm{center}}^{(A)}, S_{\\mathrm{Neu}}^{(A)}, T_{\\mathrm{center}}^{(B)}, S_{\\mathrm{Neu}}^{(B)}, T_{\\mathrm{center}}^{(C)}, S_{\\mathrm{Neu}}^{(C)}]$ 的顺序列出六个数字。由于所有量都是无量纲的，因此不需要单位。角度（如果有的话）不使用。", "solution": "用户要求解在矩形域 $\\Omega = [0,L_x] \\times [0,L_y]$ 上定义的标量温度场 $T(x,y)$ 的二维稳态拉普拉斯方程。控制方程为：\n$$ \\nabla^2 T = \\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0 $$\n该问题将在具有混合狄利克雷和诺伊曼边界条件的离散笛卡尔网格上求解。\n\n解将通过有限差分法获得。该域被离散化为 $N_x \\times N_y$ 个节点的网格，均匀间距为 $\\Delta x = L_x/(N_x - 1)$ 和 $\\Delta y = L_y/(N_y - 1)$。网格节点 $(x_i, y_j) = (i\\Delta x, j\\Delta y)$ 处的温度表示为 $T_{i,j}$。\n\n拉普拉斯方程中的偏导数使用二阶中心差分进行近似。这得到了内部节点 $(i,j)$ 处著名的离散拉普拉斯算子的五点差分格式：\n$$ \\frac{T_{i+1,j} - 2T_{i,j} + T_{i-1,j}}{(\\Delta x)^2} + \\frac{T_{i,j+1} - 2T_{i,j} + T_{i,j-1}}{(\\Delta y)^2} = 0 $$\n此方程为所有非狄利克雷节点上的未知温度 $T_{i,j}$ 构成了一个线性代数方程组。\n\n该系统使用高斯-赛德尔迭代法求解。方程被重新整理以用其邻近点的值来表示 $T_{i,j}$。在迭代过程中，我们遍历网格，使用其邻近点的最新计算值来更新每个 $T_{i,j}$。内部节点的更新公式为：\n$$ T_{i,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{T_{i+1,j}^{(k)} + T_{i-1,j}^{(k+1)}}{(\\Delta x)^2} + \\frac{T_{i,j+1}^{(k)} + T_{i,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\n其中上标表示迭代次数，更新是通过扫描索引 $j$ 然后是 $i$ 来就地执行的。\n\n边界条件按如下方式并入：\n- **狄利克雷边界**：这些边界上的节点的温度被固定为指定值。它们不参与迭代更新过程。问题描述阐明了任何与狄利克雷边相邻的角点都被视为狄利克雷点。对于所有指定的测试用例，这意味着所有四个角点都是狄利克雷点。\n- **诺伊曼边界**：施加法向导数为零的条件（$\\frac{\\partial T}{\\partial n}=0$）。这通过使用“虚拟点”来实现。例如，在左边界（$i=0$）上，条件 $\\frac{\\partial T}{\\partial x}=0$ 通过中心差分被离散化为 $\\frac{T_{1,j} - T_{-1,j}}{2\\Delta x} = 0$，这意味着虚拟点的值为 $T_{-1,j} = T_{1,j}$。将此代入 $(0,j)$ 处的五点差分格式，得到该边界节点的更新规则：\n$$ T_{0,j}^{(k+1)} = \\frac{1}{2\\left(\\frac{1}{(\\Delta x)^2} + \\frac{1}{(\\Delta y)^2}\\right)} \\left[ \\frac{2 T_{1,j}^{(k)}}{(\\Delta x)^2} + \\frac{T_{0,j+1}^{(k)} + T_{0,j-1}^{(k+1)}}{(\\Delta y)^2} \\right] $$\n对于其他三个绝热边界（右、上、下），可推导出类似的公式。\n\n迭代过程持续到解收敛为止。当在所有非狄利克雷节点上评估的离散残差的最大绝对值低于指定的容差 $\\varepsilon$ 时，即达到收敛。节点 $(i,j)$ 处的残差是使用当前温度场 $T_{i,j}$ 计算出的离散拉普拉斯算子的值，必要时对诺伊曼边界使用虚拟点。迭代次数也受 $I_{\\max}$ 的限制，以防止无限循环。\n\n收敛后，计算两个量：\n1.  $T_{\\mathrm{center}}$：最接近板几何中心的网格节点处的温度，具体在索引 $i_c = (N_x-1)/2$ 和 $j_c = (N_y-1)/2$ 处。\n2.  $S_{\\mathrm{Neu}}$：所有绝热边界上法向导数的最大绝对值。这是使用问题描述中提供的特定二阶单边有限差分公式计算的。最大值取自绝热段上的所有节点，根据角点规则，这不包括角点本身。如果没有诺伊曼类型的边界，$S_{\\mathrm{Neu}}$ 取为 $0$。\n\n实现将包含一个主程序，该程序遍历所有测试用例。对于每个用例，将调用一个求解器函数。该函数将：\n1.  初始化温度网格并识别狄利克雷节点。\n2.  执行高斯-赛德尔迭代，在每次扫描中根据内部或诺伊曼边界公式更新所有非狄利克雷节点。\n3.  定期计算最大残差以检查是否收敛于 $\\varepsilon$。\n4.  循环终止后，计算并返回 $T_{\\mathrm{center}}$ 和 $S_{\\mathrm{Neu}}$。\n所有测试用例的最终结果将被汇总并以指定格式打印。", "answer": "```python\nimport numpy as np\n\ndef compute_case(Lx, Ly, Nx, Ny, boundaries, epsilon, max_iter):\n    \"\"\"\n    Solves the 2D Laplace equation on a rectangular grid with mixed boundary conditions.\n    \"\"\"\n    dx = Lx / (Nx - 1)\n    dy = Ly / (Ny - 1)\n\n    T = np.zeros((Ny, Nx), dtype=np.float64)\n    is_dirichlet = np.zeros((Ny, Nx), dtype=bool)\n    \n    bc_map = {'left': boundaries[0], 'right': boundaries[1], \n              'bottom': boundaries[2], 'top': boundaries[3]}\n\n    # Set Dirichlet boundary conditions and mask\n    if bc_map['left'].startswith('D'):\n        val = float(bc_map['left'].split(':')[1])\n        T[:, 0] = val\n        is_dirichlet[:, 0] = True\n    if bc_map['right'].startswith('D'):\n        val = float(bc_map['right'].split(':')[1])\n        T[:, -1] = val\n        is_dirichlet[:, -1] = True\n    if bc_map['bottom'].startswith('D'):\n        val = float(bc_map['bottom'].split(':')[1])\n        T[0, :] = val\n        is_dirichlet[0, :] = True\n    if bc_map['top'].startswith('D'):\n        val = float(bc_map['top'].split(':')[1])\n        T[-1, :] = val\n        is_dirichlet[-1, :] = True\n\n    # Pre-calculate coefficients for the update rule\n    cx = 1 / (dx**2)\n    cy = 1 / (dy**2)\n    c = 1 / (2 * (cx + cy))\n    \n    # Identify Neumann boundaries for convenience\n    is_left_N = bc_map['left'].startswith('N')\n    is_right_N = bc_map['right'].startswith('N')\n    is_bottom_N = bc_map['bottom'].startswith('N')\n    is_top_N = bc_map['top'].startswith('N')\n\n    for k in range(max_iter):\n        # Gauss-Seidel update sweep\n        for j in range(Ny):\n            for i in range(Nx):\n                if is_dirichlet[j, i]:\n                    continue\n                \n                # Interior points\n                if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j, i+1] + T[j, i-1]) + cy * (T[j+1, i] + T[j-1, i]))\n                # Neumann boundary points (corners are Dirichlet for all test cases)\n                elif is_bottom_N and j == 0 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j+1,i]))\n                elif is_top_N and j == Ny - 1 and 1 = i  Nx - 1:\n                    T[j,i] = c * (cx * (T[j,i+1] + T[j,i-1]) + cy * (2 * T[j-1,i]))\n                elif is_left_N and i == 0 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i+1]) + cy * (T[j+1,i] + T[j-1,i]))\n                elif is_right_N and i == Nx - 1 and 1 = j  Ny - 1:\n                    T[j,i] = c * (cx * (2 * T[j,i-1]) + cy * (T[j+1,i] + T[j-1,i]))\n        \n        # Check for convergence every 10 iterations to reduce overhead\n        if k % 10 == 0 or k == max_iter - 1:\n            max_res = 0.0\n            for j in range(Ny):\n                for i in range(Nx):\n                    if is_dirichlet[j, i]:\n                        continue\n                    \n                    res_val = 0.0\n                    # Interior residual\n                    if 1 = j  Ny - 1 and 1 = i  Nx - 1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    # Neumann boundary residuals\n                    elif is_bottom_N and j == 0 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j+1,i]-2*T[j,i])\n                    elif is_top_N and j == Ny-1 and 1 = i  Nx-1:\n                        res_val = cx*(T[j,i+1]+T[j,i-1]-2*T[j,i]) + cy*(2*T[j-1,i]-2*T[j,i])\n                    elif is_left_N and i == 0 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i+1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    elif is_right_N and i == Nx-1 and 1 = j  Ny-1:\n                        res_val = cx*(2*T[j,i-1]-2*T[j,i]) + cy*(T[j+1,i]+T[j-1,i]-2*T[j,i])\n                    \n                    max_res = max(max_res, abs(res_val))\n\n            if max_res = epsilon:\n                break\n    \n    # Calculate output values\n    ic, jc = (Nx - 1) // 2, (Ny - 1) // 2\n    T_center = T[jc, ic]\n\n    s_neu_max = 0.0\n    if is_left_N:\n        if Ny > 3: # Ensure slice is not empty and indices are valid\n            deriv = (3 * T[1:-1, 0] - 4 * T[1:-1, 1] + T[1:-1, 2]) / (2 * dx)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_right_N:\n        if Ny > 3:\n            deriv = (-3 * T[1:-1, -1] + 4 * T[1:-1, -2] - T[1:-1, -3]) / (2 * dx)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_bottom_N:\n        if Nx > 3:\n            deriv = (3 * T[0, 1:-1] - 4 * T[1, 1:-1] + T[2, 1:-1]) / (2 * dy)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n    if is_top_N:\n        if Nx > 3:\n            deriv = (-3 * T[-1, 1:-1] + 4 * T[-2, 1:-1] - T[-3, 1:-1]) / (2 * dy)\n            s_neu_max = max(s_neu_max, np.max(np.abs(deriv)))\n\n    return T_center, s_neu_max\n\ndef solve():\n    test_cases = [\n        {'Lx': 1, 'Ly': 1, 'Nx': 33, 'Ny': 33, 'boundaries': ('D:1', 'D:0', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 2, 'Ly': 1, 'Nx': 31, 'Ny': 17, 'boundaries': ('N:0', 'N:0', 'D:1', 'D:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n        {'Lx': 1, 'Ly': 1, 'Nx': 25, 'Ny': 25, 'boundaries': ('D:0.5', 'D:0.5', 'N:0', 'N:0'), 'epsilon': 1e-8, 'max_iter': 20000},\n    ]\n\n    results = []\n    for case in test_cases:\n        T_center, S_neu = compute_case(**case)\n        results.extend([T_center, S_neu])\n\n    print(f\"[{','.join(f'{x:.8g}' for x in results)}]\")\n\nsolve()\n```", "id": "2397045"}, {"introduction": "在拉普拉斯求解器的基础上，我们现在引入一个源项，从拉普拉斯方程推广到更普适的泊松方程。本练习模拟一个张紧的弹性膜在集中载荷下的物理问题，这需要将点源（狄拉克 $\\delta$ 函数）审慎地离散化为计算上可处理的形式 [@problem_id:2397056]。这个过程将加深你对偏微分方程离散化和物理建模之间联系的理解。", "problem": "您需要实现一个基于高斯-赛德尔松弛法的数值求解器，用于计算在点状载荷作用下，一张拉伸、夹紧的薄弹性膜的静态平面外位移。其控制偏微分方程(PDE)是在均匀张力作用下膜的二维泊松方程。数学模型如下。\n\n一张方形膜占据区域 $[0,L]\\times[0,L]$，其边界被夹紧，因此边界位移满足 $u(x,y)=0$ 对于 $(x,y)\\in\\partial([0,L]\\times[0,L])$。膜张力是一个正常数 $T$，单位为 $\\mathrm{N/m}$。在单位面积横向载荷 $p(x,y)$（单位为 $\\mathrm{N/m^2}$）的作用下，静态位移 $u(x,y)$（单位为米）满足泊松方程\n$$\nT\\,\\nabla^2 u(x,y) = -\\,p(x,y)\n$$\n其中拉普拉斯算子定义为 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$。施加于 $(x_0,y_0)$ 处、大小为 $P$（单位为 $\\mathrm{N}$）的点状载荷表示为\n$$\np(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0),\n$$\n其中 $\\delta$ 是狄拉克δ分布。\n\n从二阶导数的定义及其在均匀网格上的中心有限差分近似出发，推导泊松方程在均匀网格上的五点有限差分离散化形式，该网格间距为 $h=L/(N+1)$，在每个空间方向上有 $N$ 个内部点。用网格节点 $(x_i,y_j)=(ih,jh)$（其中 $i,j\\in\\{0,1,\\dots,N+1\\}$）对区域进行离散化，并强制当 $i\\in\\{0,N+1\\}$ 或 $j\\in\\{0,N+1\\}$ 时 $u_{i,j}=0$。通过将总载荷注入到离 $(x_0,y_0)$ 最近的内部网格节点 $(i_0,j_0)$ 来表示点状载荷，并根据连续载荷积分为 $P$ 以及离散更新在物理单位上保持一致的要求，推导该节点处经过正确缩放的离散右端项。您的推导必须从中心有限差分近似和狄拉克δ函数的定义出发，不得假设任何预先给定的离散更新公式。\n\n设计一个迭代高斯-赛德尔松弛算法，该算法原地更新内部网格值直至收敛。您可以选择使用逐次超松弛(SOR)变体，其中固定松弛参数 $\\omega\\in(1,2)$，以在保持高斯-赛德尔结构的同时加速收敛。使用基于一次完整扫描中所有内部节点上 $u$ 的最大绝对变化量的收敛判据，当该最大绝对变化量小于给定阈值 $\\tau$（单位为米）时停止。确保您的算法是数值稳定的，并且所有步骤都由您推导的离散化方程给出合理解释。\n\n您的程序必须为下面的每个测试用例计算施加点状载荷处最近的内部网格节点上的位移，单位为米。对每个测试用例，将结果四舍五入到恰好六位小数。不允许用户输入；所有参数都是硬编码的。本问题不使用角度。所有物理量必须使用上文指定的单位，所有位移均以米报告。\n\n使用以下必须嵌入到您程序中的测试套件：\n\n- 测试用例 1：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 2：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=5.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 3：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.2,0.3)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n- 测试用例 4：$L=1.0$ $\\mathrm{m}$，$N=63$，$T=100.0$ $\\mathrm{N/m}$，$P=0.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-10}$ $\\mathrm{m}$。\n- 测试用例 5：$L=1.0$ $\\mathrm{m}$，$N=127$，$T=100.0$ $\\mathrm{N/m}$，$P=1.0$ $\\mathrm{N}$，$(x_0,y_0)=(0.5,0.5)$ $\\mathrm{m}$，收敛阈值 $\\tau=1\\times 10^{-8}$ $\\mathrm{m}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含五个四舍五入后的结果，以逗号分隔的列表形式用方括号括起来，顺序与测试用例一致，例如 $[u_1,u_2,u_3,u_4,u_5]$，其中每个 $u_k$ 是一个浮点数，小数点后恰好有六位数字，代表米。", "solution": "该问题已经过验证，被认为是具有科学依据、良定且完整的。将构建一个解决方案。\n\n膜的静态位移 $u(x,y)$ 的控制方程是二维泊松方程：\n$$ T\\,\\nabla^2 u(x,y) = -p(x,y) $$\n其中 $T$ 是张力，$p(x,y)$ 是单位面积载荷，$\\nabla^2 = \\frac{\\partial^2}{\\partial x^2}+\\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子。区域是一个方形 $[0,L]\\times[0,L]$，具有夹紧边界条件，即边界上 $u=0$。\n\n首先，我们对区域和微分算子进行离散化。建立一个在每个方向上有 $N$ 个内部点的均匀网格。网格间距为 $h = L/(N+1)$。网格节点位于 $(x_i, y_j) = (ih, jh)$，其中整数 $i, j \\in \\{0, 1, \\dots, N+1\\}$。这些节点上的位移记为 $u_{i,j} = u(x_i, y_j)$。边界条件意味着如果 $i \\in \\{0, N+1\\}$ 或 $j \\in \\{0, N+1\\}$，则 $u_{i,j} = 0$。\n\n二阶偏导数使用二阶中心差分公式进行近似。对于函数 $f(z)$，其二阶导数为 $f''(z) \\approx (f(z+h) - 2f(z) + f(z-h))/h^2$。将此应用于节点 $(i,j)$ 处的 $u(x,y)$：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i+h, y_j) - 2u(x_i, y_j) + u(x_i-h, y_j)}{h^2} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(i,j)} \\approx \\frac{u(x_i, y_j+h) - 2u(x_i, y_j) + u(x_i, y_j-h)}{h^2} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} $$\n离散化的拉普拉斯算子，即所谓的五点差分格式，变为：\n$$ \\nabla^2 u \\bigg|_{(i,j)} \\approx \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} $$\n将此代入泊松方程，得到内部节点（$i,j \\in \\{1, \\dots, N\\}$）的线性系统：\n$$ T \\left( \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} \\right) = -p_{i,j} $$\n其中 $p_{i,j}$ 是节点 $(i,j)$ 处载荷密度 $p(x,y)$ 的离散表示。\n\n载荷是在 $(x_0, y_0)$ 处大小为 $P$ 的点状力，由狄拉克δ分布描述：$p(x,y) = P\\,\\delta(x-x_0)\\,\\delta(y-y_0)$。为了找到离散载荷 $p_{i,j}$，我们必须保留δ函数的积分性质。总力是载荷密度在整个面积上的积分。在离散网格上，总力是每个节点上力的总和，其中一个节点上的力是密度 $p_{i,j}$ 乘以与该节点关联的面积元 $h^2$。\n$$ \\sum_{i=1}^{N} \\sum_{j=1}^{N} p_{i,j} h^2 \\approx \\iint_{\\text{domain}} p(x,y) \\,dx\\,dy = \\iint_{\\text{domain}} P\\,\\delta(x-x_0)\\,\\delta(y-y_0) \\,dx\\,dy = P $$\n问题规定，将整个载荷 $P$ 施加到离 $(x_0, y_0)$ 最近的单个内部网格节点 $(i_0, j_0)$ 上。这意味着我们必须有 $p_{i_0,j_0}h^2 = P$，而对于所有其他节点 $(i,j) \\neq (i_0, j_0)$，则有 $p_{i,j}=0$。这给出了在作用点处的离散载荷密度为 $p_{i_0,j_0} = P/h^2$。\n\n有了这些，载荷点 $(i_0,j_0)$ 处的离散泊松方程为：\n$$ T \\left( \\frac{u_{i_0+1,j_0} + u_{i_0-1,j_0} + u_{i_0,j_0+1} + u_{i_0,j_0-1} - 4u_{i_0,j_0}}{h^2} \\right) = -\\frac{P}{h^2} $$\n对于任何其他内部节点 $(i,j) \\neq (i_0,j_0)$，我们有 $p_{i,j}=0$，因此方程简化为离散拉普拉斯方程：\n$$ \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} = 0 $$\n为了构建迭代格式，我们重排离散化方程以求解 $u_{i,j}$：\n$$ 4u_{i,j} = u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + \\frac{p_{i,j} h^2}{T} $$\n$$ u_{i,j} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\n其中我们定义源项 $f_{i,j} = p_{i,j} h^2 / T$。根据我们的载荷离散化，该源项仅在 $(i_0, j_0)$ 处非零：\n$$ f_{i,j} = \\begin{cases} P/T  \\text{if } (i,j) = (i_0,j_0) \\\\ 0  \\text{otherwise} \\end{cases} $$\n\n高斯-赛德尔方法是求解此线性系统的一种迭代技术。它使用其相邻点最新计算出的值来更新每个节点上的 $u_{i,j}$ 值。对于第 $k+1$ 次迭代，$u_{i,j}$ 的更新公式为：\n$$ u_{i,j}^{(k+1)} = \\frac{1}{4} \\left( u_{i+1,j}^{(k)} + u_{i-1,j}^{(k+1)} + u_{i,j+1}^{(k)} + u_{i,j-1}^{(k+1)} + f_{i,j} \\right) $$\n假设采用字典序扫描（例如，先增加 $i$，再增加 $j$）。这是通过在单个数组内原地覆盖 $u_{i,j}$ 的值来实现的。\n\n为了加速收敛，使用逐次超松弛(SOR)方法。该方法通过引入一个松弛参数 $\\omega \\in (1,2)$ 来修改高斯-赛德尔更新。首先，通过高斯-赛德尔步骤计算一个临时值，我们称之为 $u_{i,j}^{\\text{GS}}$：\n$$ u_{i,j}^{\\text{GS}} = \\frac{1}{4} \\left( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} + f_{i,j} \\right) $$\n新值 $u_{i,j}^{\\text{new}}$ 随后是旧值 $u_{i,j}^{\\text{old}}$ 和 $u_{i,j}^{\\text{GS}}$ 的加权平均：\n$$ u_{i,j}^{\\text{new}} = (1-\\omega) u_{i,j}^{\\text{old}} + \\omega u_{i,j}^{\\text{GS}} $$\n对于具有狄利克雷边界条件的方形区域，已知的最优松弛参数为：\n$$ \\omega_{\\text{opt}} = \\frac{2}{1 + \\sin(\\pi h/L)} = \\frac{2}{1 + \\sin(\\pi / (N+1))} $$\n与标准高斯-赛德尔方法（其中 $\\omega=1$）相比，使用此 $\\omega$ 值可显著减少收敛所需的迭代次数。\n\n该算法流程如下：\n1. 初始化一个 $(N+2) \\times (N+2)$ 的网格 $u$，所有元素设为 $0$。这自动满足了边界上 $u_{i,j}=0$ 的条件。\n2. 确定网格参数：$h = L/(N+1)$ 以及离载荷作用点 $(x_0,y_0)$ 最近的节点索引 $(i_0,j_0)$。这些由 $i_0 = \\text{round}(x_0/h)$ 和 $j_0 = \\text{round}(y_0/h)$ 给出。必须断言 $1 \\le i_0, j_0 \\le N$。\n3. 构建一个同样大小的源网格 $f$，其中 $f_{j_0,i_0} = P/T$，所有其他元素为 $0$。注意，数组索引 `(row, col)` 对应于 `(j, i)`。\n4. 使用 $\\omega_{\\text{opt}}$ 的公式计算最优松弛参数 $\\omega$。\n5. 迭代直至收敛：\n    a. 初始化变量 $\\text{max\\_abs\\_change} = 0$。\n    b. 扫描所有内部网格点，对于 $j=1, \\dots, N$ 和 $i=1, \\dots, N$。\n    c. 在每个点 $(i,j)$，存储当前值 $u_{j,i}^{\\text{old}}$。\n    d. 使用SOR更新公式计算新值 $u_{j,i}^{\\text{new}}$。\n    e. 原地更新网格：$u_{j,i} = u_{j,i}^{\\text{new}}$。\n    f. 更新最大变化量：$\\text{max\\_abs\\_change} = \\max(\\text{max\\_abs\\_change}, |u_{j,i}^{\\text{new}} - u_{j,i}^{\\text{old}}|)$。\n    g. 对所有内部节点完成一次完整扫描后，检查收敛判据：如果 $\\text{max\\_abs\\_change}  \\tau$，则终止迭代。\n6. 一旦收敛，所需的位移就是载荷点处的值 $u_{j_0,i_0}$。然后按要求将此值四舍五入到 $6$ 位小数。\n\n为每个提供的测试用例实现此过程。", "answer": "```python\nimport numpy as np\nimport math\n\ndef run_simulation(L, N, T, P, x0, y0, tau):\n    \"\"\"\n    Solves the Poisson equation for membrane displacement using the\n    Successive Over-Relaxation (SOR) method.\n\n    Args:\n        L (float): Side length of the square membrane [m].\n        N (int): Number of interior grid points in each direction.\n        T (float): Tension in the membrane [N/m].\n        P (float): Magnitude of the point load [N].\n        x0 (float): x-coordinate of the load application point [m].\n        y0 (float): y-coordinate of the load application point [m].\n        tau (float): Convergence threshold for displacement [m].\n\n    Returns:\n        float: The displacement at the node nearest to the load point.\n    \"\"\"\n    # Handle the trivial case where there is no load.\n    if P == 0.0:\n        return 0.0\n\n    # 1. Initialize grid and parameters\n    # The grid size is (N+2) x (N+2) to include the clamped boundaries.\n    grid_size = N + 2\n    u = np.zeros((grid_size, grid_size), dtype=np.float64)\n    \n    # Calculate the grid spacing h.\n    h = L / (N + 1)\n    \n    # 2. Determine load point and create the discrete source term grid `f`.\n    # Numpy array indexing is (row, col), which corresponds to (j, i).\n    # The variable i corresponds to the x-direction, and j to the y-direction.\n    # We find the nearest grid indices (i0, j0) to the physical point (x0, y0).\n    i0 = int(round(x0 / h))\n    j0 = int(round(y0 / h))\n    \n    # Verify that the calculated load point is an interior node.\n    if not (1 = i0 = N and 1 = j0 = N):\n        raise ValueError(f\"Load point ({x0}, {y0}) maps to a boundary node.\")\n\n    # The source term f is zero everywhere except at the load point.\n    # As derived, f_i0,j0 = P/T.\n    f_source_value = P / T\n    \n    # 3. Calculate the optimal relaxation parameter omega for SOR.\n    omega = 2.0 / (1.0 + math.sin(math.pi / (N + 1)))\n\n    # 4. Main SOR iteration loop.\n    # A safety break is included to prevent infinite loops.\n    max_iterations = 20000 \n    for _ in range(max_iterations):\n        max_abs_change = 0.0\n        \n        # Sweep over all interior grid points.\n        for j in range(1, N + 1):\n            for i in range(1, N + 1):\n                u_old = u[j, i]\n                \n                # Apply the source term only at the specific load point.\n                source = f_source_value if i == i0 and j == j0 else 0.0\n                \n                # Calculate the update using the Gauss-Seidel formula.\n                u_gs = 0.25 * (u[j, i+1] + u[j, i-1] + u[j+1, i] + u[j-1, i] + source)\n                \n                # Apply the SOR formula. The update is done in-place.\n                u[j, i] = (1.0 - omega) * u_old + omega * u_gs\n                \n                # Track the maximum change in displacement over the grid for this iteration.\n                max_abs_change = max(max_abs_change, abs(u[j, i] - u_old))\n\n        # 5. Check for convergence.\n        if max_abs_change  tau:\n            break\n            \n    # 6. Return the displacement at the node nearest to the load application point.\n    return u[j0, i0]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 5.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 1.0, 'x0': 0.2, 'y0': 0.3, 'tau': 1e-8},\n        {'L': 1.0, 'N': 63, 'T': 100.0, 'P': 0.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-10},\n        {'L': 1.0, 'N': 127, 'T': 100.0, 'P': 1.0, 'x0': 0.5, 'y0': 0.5, 'tau': 1e-8},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(\n            L=case['L'], N=case['N'], T=case['T'], P=case['P'],\n            x0=case['x0'], y0=case['y0'], tau=case['tau']\n        )\n        # Format the result to exactly six decimal places.\n        results.append(f\"{result:.6f}\")\n\n    # Print the final output in the required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2397056"}, {"introduction": "虽然高斯-赛德尔方法有效，但对于大型网格，其收敛速度可能非常缓慢。本练习将介绍一种强大的增强技术：逐次超松弛（SOR）方法。你不仅将使用高效的红黑排序方案来实现SOR，还将通过一个数值实验来经验性地找到最优松弛参数 $\\omega$，这是调优高性能迭代求解器的一项关键技能 [@problem_id:2397060]。", "problem": "您需要实现一个用于二维 Laplace 方程的数值求解器，使用逐次超松弛（Successive Over-Relaxation, SOR）方法来加速 Gauss–Seidel 迭代。您的实现必须针对具有 Dirichlet 边界条件的特定矩形几何结构，经验性地确定最优松弛参数 $\\,\\omega_{\\mathrm{opt}}\\,\\in(0,2)\\,$。此任务必须从基本定义出发，即从 Laplace 方程的定义和均匀笛卡尔网格上的标准五点有限差分离散化开始。\n\n您必须遵守以下要求。\n\n- 从二维空间中的 Laplace 方程定义 $\\,\\nabla^2 u = 0\\,$ 和矩形格子上均匀网格的五点有限差分离散化出发。使用通过逐次超松弛（SOR）增强的 Gauss–Seidel 迭代。除这些基础知识外，不假设任何预先推导的公式。\n- 使用红黑排序（棋盘式更新），以便在每次迭代中，首先更新所有红色的内部点，然后更新所有黑色的内部点，并进行原地更新。\n- 采用以下收敛准则。将一次“迭代”定义为一次完整的红黑扫描。每次扫描后，将迭代间的变化定义为所有已更新的内部点（不包括 Dirichlet 固定的边界点和任何内部 Dirichlet 障碍物）上，更新值与其先前值之间最大绝对差。当更新量的无穷范数低于容差 $\\,\\tau = 10^{-5}\\,$ 时，或当迭代次数达到最大值 $\\,I_{\\max} = 5000\\,$ 时，以先到者为准，停止迭代。\n- 对所有内部未知数使用零初始猜测，即在每次求解开始时，内部点的 $\\,u_{i,j}=0\\,$。在迭代开始前应用 Dirichlet 边界值和任何内部 Dirichlet 障碍值，并在迭代期间保持其固定。\n- 将 $\\,\\omega_{\\mathrm{opt}}\\,$ 的经验性搜索定义为一个两阶段搜索：\n  - 粗略阶段：在网格 $\\,\\{1.0, 1.1, 1.2, \\dots, 1.9\\}\\,$ 上测试 $\\,\\omega\\,$。\n  - 精细阶段：设 $\\,\\omega_c\\,$ 为粗略阶段中使收敛迭代次数最小化的 $\\,\\omega\\,$ 值（若存在多个最小值点，则选择最小的 $\\,\\omega\\,$）。然后在均匀网格 $\\,\\max(1.0,\\omega_c-0.05),\\,\\max(1.0,\\omega_c-0.05)+0.01,\\,\\dots,\\,\\min(1.95,\\omega_c+0.05)\\,$ 上测试 $\\,\\omega\\,$。选择 $\\,\\omega_{\\mathrm{opt}}\\,$ 作为精细网格上迭代次数的最小值点（同样，若存在多个最小值点，则选择最小的 $\\,\\omega\\,$）。报告四舍五入到两位小数的 $\\,\\omega_{\\mathrm{opt}}\\,$，以及对应的最小迭代次数（整数）。仅在选定最小值点后进行四舍五入。\n- 在两个方向上使用均匀的网格间距。您不需要报告物理单位，也不应使用角度量。\n\n测试套件。实现您的程序以计算并报告以下三（3）个测试用例的结果。\n\n- 用例 A（顶部为热边的正方形）：\n  - 网格：$\\,N_x = 50\\,$, $\\,N_y = 50\\,$。\n  - Dirichlet 边界值：顶边 $\\,u=1.0\\,$，底边、左边、右边 $\\,u=0.0\\,$。\n  - 无内部障碍物。\n- 用例 B（左侧为热边的矩形）：\n  - 网格：$\\,N_x = 60\\,$, $\\,N_y = 30\\,$。\n  - Dirichlet 边界值：左边 $\\,u=1.0\\,$，顶边、底边、右边 $\\,u=0.0\\,$。\n  - 无内部障碍物。\n- 用例 C（带有温热内部障碍物的正方形）：\n  - 网格：$\\,N_x = 40\\,$, $\\,N_y = 40\\,$。\n  - Dirichlet 边界值：所有四个外边界 $\\,u=0.0\\,$。\n  - 内部 Dirichlet 障碍物：一个居中的边长为 $\\,8\\,$ 个内部网格点的正方形（即，在零基索引中，索引为 $\\,x\\in\\{16,17,\\dots,23\\}\\,$ 和 $\\,y\\in\\{16,17,\\dots,23\\}\\,$），其值固定为 $\\,u=0.5\\,$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果必须是一个双元素列表 $[\\omega_{\\mathrm{opt}}, I_{\\min}]$，其中 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数，$\\,I_{\\min}\\,$ 是最小迭代次数（整数）。因此，最终行必须形如\n$\\,\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big]\\,$\n且不含任何额外文本。例如，一个语法正确的输出将是\n$\\,\\big[[1.80, 250], [1.90, 180], [1.75, 310]\\big]\\,$\n尽管这些不是本问题预期的数值。", "solution": "我们从二维空间中的 Laplace 方程开始，\n$$\n\\nabla^2 u \\;=\\; \\frac{\\partial^2 u}{\\partial x^2} \\;+\\; \\frac{\\partial^2 u}{\\partial y^2} \\;=\\; 0,\n$$\n该方程定义于一个带有 Dirichlet 边界数据的矩形上。在一个两个方向上网格间距均为 $\\,h\\,$ 的均匀笛卡尔网格上，内部点索引为 $\\,i=1,\\dots,N_x-2\\,$ 和 $\\,j=1,\\dots,N_y-2\\,$（最外层索引保留给 Dirichlet 边界），经典的五点有限差分（FD）近似可得到离散 Laplace 算子\n$$\n\\frac{u_{i+1,j} - 2\\,u_{i,j} + u_{i-1,j}}{h^2} \\;+\\; \\frac{u_{i,j+1} - 2\\,u_{i,j} + u_{i,j-1}}{h^2} \\;=\\; 0,\n$$\n对于均匀的 $\\,h\\,$ 和纯 Laplace 问题（无源项），该式可简化为不动点关系\n$$\nu_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} \\big).\n$$\n这个恒等式启发了一种迭代方法：Gauss–Seidel（GS）迭代使用最新可用的邻近点值对每个内部点 $\\,u_{i,j}\\,$ 进行原地更新。当某些网格点是 Dirichlet 固定的（边界或内部障碍物）时，它们不参与更新并作为常数保留，因此它们的值会参与邻近点求和但自身不变。\n\n逐次超松弛（Successive Over-Relaxation, SOR）方法通过对 GS 更新量进行朝向不动点的凸外插来加速 GS 迭代。将在 $\\,\\{i,j\\}\\,$ 点的 Gauss–Seidel 更新记为\n$$\nu^{\\mathrm{GS}}_{i,j} \\;=\\; \\frac{1}{4}\\,\\big( u_{i+1,j}^{\\star} + u_{i-1,j}^{\\star} + u_{i,j+1}^{\\star} + u_{i,j-1}^{\\star} \\big),\n$$\n其中每个邻近点 $\\,u^{\\star}\\,$ 是当前的原地值（一些邻近点已在同一次扫描中更新，另一些则尚未更新）。使用松弛参数 $\\,\\omega\\in(0,2)\\,$ 的 SOR 更新为\n$$\nu^{\\mathrm{new}}_{i,j} \\;=\\; (1-\\omega)\\,u^{\\mathrm{old}}_{i,j} \\;+\\; \\omega\\,u^{\\mathrm{GS}}_{i,j}.\n$$\n对于红黑排序，网格根据 $\\,i+j\\,$ 的奇偶性被划分为两个交错的集合。所有红点首先使用黑点邻居进行更新（因为每个红点的最近邻都是黑点），然后所有黑点使用新更新的红点邻居进行更新，完成一次迭代（一次扫描）。这种排序方式支持向量化更新，并保留了 Gauss–Seidel 迭代的依赖结构。\n\n收敛性通过每次迭代变化的无穷范数来监控。设 $\\,\\Delta^{(k)}\\,$ 为在第 $\\,k\\,$ 次迭代期间，所有更新的内部点上更新值与先前值之间的最大绝对差。当满足以下条件时，我们终止迭代\n$$\n\\Delta^{(k)}  \\tau \\;=\\; 10^{-5},\n$$\n或者当迭代次数达到上限 $\\,I_{\\max}=5000\\,$ 时。初始猜测为所有内部点 $\\,u_{i,j}=0\\,$，并施加 Dirichlet 边界和内部障碍物的值，且保持固定。\n\n为了经验性地确定 $\\,\\omega_{\\mathrm{opt}}\\,$，我们在一个预设的 $\\,\\omega\\,$ 值集合上，最小化满足停止准则所需的迭代次数。我们采用一个两阶段搜索来平衡鲁棒性和计算成本：\n\n- 粗略阶段：评估 $\\,\\omega \\in \\{1.0, 1.1, \\dots, 1.9\\}\\,$ 并选择使迭代次数最小的 $\\,\\omega_c\\,$（若存在多个最小值点，则选择较小的 $\\,\\omega\\,$）。\n- 精细阶段：在均匀网格 $\\,\\omega \\in [\\max(1.0,\\omega_c-0.05), \\min(1.95,\\omega_c+0.05)]\\,$ 上以步长 $\\,0.01\\,$ 进行评估，并选择最小值点 $\\,\\omega_{\\mathrm{opt}}\\,$（同样，若存在多个最小值点，则选择较小的 $\\,\\omega\\,$）。仅在选定最小值点后，我们将 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数以供报告。\n\n我们实现了三种几何结构。\n\n- 用例 A：$\\,N_x=50\\,$, $\\,N_y=50\\,$。顶边固定为 $\\,u=1.0\\,$；其他边固定为 $\\,u=0.0\\,$；无障碍物。\n- 用例 B：$\\,N_x=60\\,$, $\\,N_y=30\\,$。左边固定为 $\\,u=1.0\\,$；其他边固定为 $\\,u=0.0\\,$；无障碍物。\n- 用例 C：$\\,N_x=40\\,$, $\\,N_y=40\\,$。所有外边界固定为 $\\,u=0.0\\,$。一个居中的内部 Dirichlet 障碍物，边长为 $\\,8\\,$ 个内部网格点，索引为 $\\,x\\in\\{16,\\dots,23\\},\\,y\\in\\{16,\\dots,23\\}\\,$，固定值为 $\\,u=0.5\\,$。\n\n为保证效率和正确性的算法细节：\n\n- 构造内部点的布尔掩码，以识别红色和黑色的更新位置，并可选择性地将障碍物单元排除在更新之外。\n- 在每个红色（或黑色）半扫描中，计算整个内部区域的邻居和 $\\,u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\,$，然后仅在红色（或黑色）掩码上应用 SOR 更新。对于红色半扫描，邻居和使用的值中所有红色邻居实际上都是黑色单元格；因此，该和正确地使用了最新的黑色值。在红色更新之后，重新计算邻居和，以便黑色更新能看到已更新的红色邻居。\n- 跟踪该次扫描中更新量的最大绝对变化作为 $\\,\\Delta^{(k)}\\,$。\n\n程序随后对每个测试用例执行两阶段搜索，记录最佳的 $\\,\\omega_{\\mathrm{opt}}\\,$ 及其最小迭代次数 $\\,I_{\\min}\\,$，将 $\\,\\omega_{\\mathrm{opt}}\\,$ 四舍五入到两位小数，并打印包含列表的单行输出\n$$\n\\big[[\\omega^{(A)}_{\\mathrm{opt}}, I^{(A)}_{\\min}], [\\omega^{(B)}_{\\mathrm{opt}}, I^{(B)}_{\\min}], [\\omega^{(C)}_{\\mathrm{opt}}, I^{(C)}_{\\min}]\\big].\n$$\n此过程对于均匀网格上具有 Dirichlet 数据的类 Laplace 问题是通用的，并演示了逐次超松弛（SOR）方法如何加速 Gauss–Seidel 迭代，以及如何为给定的离散几何结构经验性地调整松弛参数 $\\,\\omega\\,$。", "answer": "```python\nimport numpy as np\n\ndef sor_red_black(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None = None,\n    obstacle_value: float | None = None,\n    omega: float = 1.5,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n) -> int:\n    \"\"\"\n    Perform red-black SOR for Laplace's equation on an nx-by-ny grid.\n    - boundary_values: dict with any of 'top','bottom','left','right' mapping to floats.\n      Edges not specified default to 0.0.\n    - obstacle_mask: full-size boolean array (ny, nx), True where Dirichlet-fixed internal obstacle exists.\n    - obstacle_value: float value assigned to obstacle cells (required if obstacle_mask is provided).\n    - omega: relaxation parameter in (0,2).\n    - tol: stopping tolerance on infinity norm of per-iteration change.\n    - max_iters: maximum number of red-black sweeps.\n    Returns: number of iterations (sweeps) taken to reach tol (or max_iters if not reached).\n    \"\"\"\n    # Initialize potential field\n    u = np.zeros((ny, nx), dtype=np.float64)\n\n    # Apply boundary conditions (unspecified edges are zero)\n    if 'bottom' in boundary_values:\n        u[0, :] = boundary_values['bottom']\n    if 'top' in boundary_values:\n        u[-1, :] = boundary_values['top']\n    if 'left' in boundary_values:\n        u[:, 0] = boundary_values['left']\n    if 'right' in boundary_values:\n        u[:, -1] = boundary_values['right']\n\n    # Internal Dirichlet obstacle\n    if obstacle_mask is not None:\n        if obstacle_value is None:\n            raise ValueError(\"obstacle_value must be provided when obstacle_mask is given.\")\n        u[obstacle_mask] = obstacle_value\n\n    # Interior masks (exclude outer boundary)\n    # Boolean mask of interior points that are updatable (not obstacle)\n    interior_shape = (ny - 2, nx - 2)\n    if interior_shape[0] = 0 or interior_shape[1] = 0:\n        return 0  # no interior to update\n\n    # Build interior obstacle mask\n    if obstacle_mask is not None:\n        obsI = obstacle_mask[1:-1, 1:-1].copy()\n    else:\n        obsI = np.zeros(interior_shape, dtype=bool)\n\n    update_mask = ~obsI  # True where we update\n\n    # Red-black masks over the interior\n    ii = np.arange(1, ny - 1)[:, None]\n    jj = np.arange(1, nx - 1)[None, :]\n    parity = (ii + jj) % 2  # 0 for even (red), 1 for odd (black)\n    red_mask = (parity == 0)\n    black_mask = ~red_mask\n    red_mask = red_mask  update_mask\n    black_mask = black_mask  update_mask\n\n    # Helper to compute neighbor sum over interior\n    def neighbor_sum(U):\n        return (U[2:, 1:-1] + U[:-2, 1:-1] + U[1:-1, 2:] + U[1:-1, :-2])\n\n    # Iterate\n    iters = 0\n    for k in range(1, max_iters + 1):\n        max_change = 0.0\n\n        # Red half-sweep\n        s = neighbor_sum(u)\n        uI = u[1:-1, 1:-1]\n        if np.any(red_mask):\n            old_vals = uI[red_mask]\n            gs_vals = 0.25 * s[red_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[red_mask] = new_vals\n\n        # Black half-sweep\n        s = neighbor_sum(u)  # recompute after red updates\n        if np.any(black_mask):\n            old_vals = uI[black_mask]\n            gs_vals = 0.25 * s[black_mask]\n            new_vals = (1.0 - omega) * old_vals + omega * gs_vals\n            change = np.max(np.abs(new_vals - old_vals)) if new_vals.size else 0.0\n            max_change = max(max_change, float(change))\n            uI[black_mask] = new_vals\n\n        iters = k\n        if max_change  tol:\n            break\n\n    return iters\n\n\ndef empirical_omega_opt(\n    nx: int,\n    ny: int,\n    boundary_values: dict,\n    obstacle_mask: np.ndarray | None,\n    obstacle_value: float | None,\n    tol: float = 1e-5,\n    max_iters: int = 5000,\n):\n    \"\"\"\n    Two-stage empirical search for omega_opt minimizing iteration count.\n    Returns (omega_opt_rounded_to_2_decimals, min_iterations).\n    \"\"\"\n    # Coarse grid: 1.0 to 1.9 step 0.1\n    coarse_candidates = [round(1.0 + 0.1 * i, 10) for i in range(0, 10)]  # [1.0, ..., 1.9]\n    coarse_results = []\n    for w in coarse_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        coarse_results.append((w, it))\n    # Select best coarse (min iters, tie-break by smallest omega)\n    min_it_coarse = min(it for _, it in coarse_results)\n    best_coarse = min([w for (w, it) in coarse_results if it == min_it_coarse])\n\n    # Fine grid around best_coarse: step 0.01 within [1.0, 1.95]\n    start = max(1.0, best_coarse - 0.05)\n    end = min(1.95, best_coarse + 0.05)\n    n_steps = int(round((end - start) / 0.01))  # inclusive range\n    fine_candidates = [round(start + 0.01 * i, 10) for i in range(n_steps + 1)]\n    fine_results = []\n    for w in fine_candidates:\n        it = sor_red_black(\n            nx, ny, boundary_values,\n            obstacle_mask=obstacle_mask,\n            obstacle_value=obstacle_value,\n            omega=w, tol=tol, max_iters=max_iters\n        )\n        fine_results.append((w, it))\n    min_it_fine = min(it for _, it in fine_results)\n    best_fine = min([w for (w, it) in fine_results if it == min_it_fine])\n\n    return round(best_fine, 2), int(min_it_fine)\n\n\ndef build_obstacle_mask(ny: int, nx: int, y0: int, y1: int, x0: int, x1: int) -> np.ndarray:\n    \"\"\"\n    Build a full-size boolean mask with True on [y0:y1, x0:x1] inclusive of endpoints if using slice semantics.\n    Here, we assume x1, y1 are exclusive upper bounds for numpy slicing.\n    \"\"\"\n    mask = np.zeros((ny, nx), dtype=bool)\n    mask[y0:y1, x0:x1] = True\n    return mask\n\n\ndef solve():\n    results = []\n\n    # Common solver settings\n    tol = 1e-5\n    max_iters = 5000\n\n    # Case A: Nx=50, Ny=50, top=1.0, others=0.0, no obstacle\n    nx_A, ny_A = 50, 50\n    bvals_A = {'top': 1.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    omega_A, it_A = empirical_omega_opt(\n        nx_A, ny_A, bvals_A,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_A, it_A])\n\n    # Case B: Nx=60, Ny=30, left=1.0, others=0.0, no obstacle\n    nx_B, ny_B = 60, 30\n    bvals_B = {'left': 1.0, 'top': 0.0, 'bottom': 0.0, 'right': 0.0}\n    omega_B, it_B = empirical_omega_opt(\n        nx_B, ny_B, bvals_B,\n        obstacle_mask=None, obstacle_value=None,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_B, it_B])\n\n    # Case C: Nx=40, Ny=40, all edges 0.0, centered 8x8 obstacle at 0.5\n    nx_C, ny_C = 40, 40\n    bvals_C = {'top': 0.0, 'bottom': 0.0, 'left': 0.0, 'right': 0.0}\n    # Center indices for obstacle: 8x8 block\n    side = 8\n    x0 = nx_C // 2 - side // 2\n    x1 = x0 + side\n    y0 = ny_C // 2 - side // 2\n    y1 = y0 + side\n    obstacle_C = build_obstacle_mask(ny_C, nx_C, y0, y1, x0, x1)\n    omega_C, it_C = empirical_omega_opt(\n        nx_C, ny_C, bvals_C,\n        obstacle_mask=obstacle_C, obstacle_value=0.5,\n        tol=tol, max_iters=max_iters\n    )\n    results.append([omega_C, it_C])\n\n    # Final output in the exact required format\n    # Print a single line: [[omegaA,iterA],[omegaB,iterB],[omegaC,iterC]]\n    print(str(results).replace(' ', ''))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2397060"}]}