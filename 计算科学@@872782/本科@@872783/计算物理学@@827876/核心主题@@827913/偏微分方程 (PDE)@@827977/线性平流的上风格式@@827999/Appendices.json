{"hands_on_practices": [{"introduction": "动手实践是掌握数值方法的最佳途径。我们的第一个练习将从零开始实现一阶迎风格式，并用它来模拟一个具有挑战性的初始条件——一个急剧的不连续阶级函数——的传播。通过这个练习[@problem_id:2448567]，你将亲眼观察到数值方法如何引入一种被称为“数值耗散”的效应，即将一个完美的尖锐波前逐渐变得模糊。这对于建立对一阶格式局限性的直观理解至关重要。", "problem": "考虑一个标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\n初始条件由赫维赛德阶跃函数 (Heaviside step function) 给出\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1, \\xi \\ge 0,\\\\\n0, \\xi  0.\n\\end{cases}\n$$\n施加与初始数据的远场状态一致的流入边界条件：如果 $a > 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\min},t)=0$；如果 $a  0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\max},t)=1$。所有量均为无量纲。\n\n在 $[x_{\\min},x_{\\max}]$ 区间内一个包含 $N$ 个点的均匀空间网格上，将解在时间上推进至最终时刻 $T$，时间步长 $\\Delta t$ 的选择应满足指定的 Courant–Friedrichs–Lewy (CFL) 数 $C$，其中\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\n使用与 $a$ 的符号一致的一阶迎风离散格式。对于下方的每个测试用例，计算在时刻 $T$ 的离散 $\\ell^1$ 误差，其定义为\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\n其中 $x_i$ 是网格点，$u_i^{\\text{num}}(T)$ 是在时刻 $T$ 的数值解，而解析解是平移后的阶跃函数\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\n对于下面给出的时间和参数，该解是有效的，因为平流带来的间断点始终严格位于区间 $[x_{\\min},x_{\\max}]$ 内部，不与边界相互作用。\n\n测试套件（每个测试用例是一个元组 $(a,x_{\\min},x_{\\max},x_0,N,T,C)$）：\n- 测试 $1$: $(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$。\n- 测试 $2$: $(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$。\n- 测试 $3$: $(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$。\n\n您的程序必须按所列顺序为每个测试计算 $E_1$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到六位小数（例如，$[0.123456,0.000000,1.234568]$）。", "solution": "该问题是有效的，因为它具有科学依据、适定且客观。它提出了计算物理学中的一个标准任务：使用一阶迎风格式求解线性平流方程并评估数值误差。所有参数和条件都已明确定义。\n\n控制方程是标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n为了对该方程进行数值求解，我们对时空域进行离散化。空间域 $[x_{\\min}, x_{\\max}]$ 被划分为一个包含 $N$ 个点的均匀网格，$x_i = x_{\\min} + i\\Delta x$（其中 $i=0, 1, \\dots, N-1$），网格间距为 $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$。时间以离散步长推进，我们将 $u(x_i, t^n)$ 的数值近似值表示为 $u_i^n$。\n\n时间导数 $\\partial_t u$ 使用一阶向前差分（前向欧拉法）进行近似：\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n一阶迎风格式使用单边有限差分来近似空间导数 $\\partial_x u$。单边模板的选择取决于信息传播的方向，该方向由平流速度 $a$ 的符号给出。这确保了数值方法从“迎风”方向提取信息，这是双曲型求解器稳定性的一个关键属性。\n\n情况 1：$a > 0$\n信息从左向右传播（沿 $x$ 轴正方向）。在 $x_i$ 处的空间导数使用向后差分进行近似，该差分涉及迎风点 $x_{i-1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n将这些离散近似代入偏微分方程，得到更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\n求解下一时间步的解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\n其中 $C = \\frac{a \\Delta t}{\\Delta x}$ 是 Courant–Friedrichs–Lewy (CFL) 数，因为 $a0$。此格式应用于 $i=1, \\dots, N-1$。\n\n情况 2：$a  0$\n信息从右向左传播（沿 $x$ 轴负方向）。空间导数使用向前差分进行近似，该差分涉及迎风点 $x_{i+1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n相应的更新规则是：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\n此处，CFL 数定义为 $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$，这意味着 $\\frac{a \\Delta t}{\\Delta x} = -C$。此格式应用于 $i=0, \\dots, N-2$。\n\n如果满足 CFL 条件 $C \\le 1$，则该显式时间步进格式的稳定性得到保证。所有提供的测试用例均满足此条件。\n\n模拟过程如下：\n1.  **初始化**：对于每个测试用例 $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$，计算网格间距 $\\Delta x$ 和名义时间步长 $\\Delta t = C \\Delta x / |a|$。解数组 $u$ 使用赫维赛德函数 $u(x,0) = H(x - x_0)$ 进行初始化。\n2.  **时间演化**：通过一个循环将解从 $t=0$ 推进到 $T$。为确保精确达到最终时刻 $T$，每次迭代的时间步长计算为 $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$。这可以处理 $T$ 不是 $\\Delta t$ 整数倍的情况。\n3.  **更新步骤**：在循环内部，创建解 $u^n$ 的一个副本。使用适当的迎风公式计算所有内部点的解 $u^{n+1}$，更新系数按 $\\Delta t_{\\text{curr}}$ 进行缩放。\n4.  **边界条件**：计算完内部点的更新后，强制执行流入边界条件。如果 $a > 0$，则设置左边界的值：$u_0^{n+1} = 0$。如果 $a  0$，则设置右边界的值：$u_{N-1}^{n+1} = 1$。流出边界无需特殊处理，因为它由迎风模板的单边性质处理。\n5.  **误差计算**：一旦模拟达到时刻 $t=T$，就获得了最终的数值解 $u_i^{\\text{num}}(T)$。在同一网格上计算解析解 $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$。然后使用以下公式计算离散 $\\ell^1$ 误差：\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\n对于 $C=1.0$ 的测试用例，该格式（对于 $a0$）简化为 $u_i^{n+1} = u_{i-1}^n$。这对应于每个时间步长将离散数据精确地移动一个网格单元。由于总时间 $T$ 的选择使得总平流距离 $aT$ 是 $\\Delta x$ 的整数倍，因此网格上的数值解与精确解完全相同，从而导致误差为零。对于 $C  1$，该格式会引入数值耗散，这会使陡峭的阶跃变得模糊，并产生非零误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "在我们已经直观地看到了数值耗散之后，下一步是学习如何对其进行量化。第二个练习将从定性观察转向定量分析。线性平流方程不仅守恒质量（$ \\int u dx $），也守恒像“能量”这样的高阶矩，例如 $ \\int u^2 dx $。这个实践[@problem_id:2448571]将探讨数值格式由于其固有的耗散性，是如何破坏这个二次矩的守恒性的。这教会我们超越视觉结果，使用守恒量（或其不守恒性）作为分析数值格式质量和特性的有力工具。", "problem": "考虑一维周期性定义域上具有恒定速度的线性平流方程，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\qquad x\\in[0,L],\\ t\\ge 0,\n$$\n其具有周期性边界条件和以下初始条件\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right).\n$$\n在一个包含 $N$ 个点的均匀网格上，点的位置为 $x_i=i\\,\\Delta x$（其中 $i=0,1,\\dots,N-1$）且 $\\Delta x=L/N$。定义在时间层 $t^n=n\\,\\Delta t$ 的离散解值 $u_i^n\\approx u(x_i,t^n)$，其中时间步长通过库朗数 $s\\in(0,1]$ 由下式选择：\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}.\n$$\n使用带周期性环绕的一阶迎风有限差分格式，将时间层从 $n$ 更新到 $n+1$：\n- 如果 $a0$，\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right),\n$$\n- 如果 $a0$，\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right),\n$$\n其中由于周期性，索引在模 $N$ 的意义下理解。将离散解从 $t=0$ 演化到最终时间\n$$\nt_{\\mathrm{final}}=\\frac{L}{|a|},\n$$\n这对应于恰好 $N_t=N/s$ 个时间步（以下所有测试用例均确保 $N/s$ 为整数），此时精确的连续解已在定义域上完成了一次完整的环绕。\n\n定义在时间层 $n$ 的离散二阶矩为\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x,\n$$\n以及诊断比率\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}.\n$$\n在具有周期性边界的连续方程中，量 $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$ 在时间上是守恒的。本问题旨在研究迎风格式引入的数值耗散如何在一个定义域遍历周期内影响离散二阶矩 $M_2^n$ 的守恒性。\n\n本问题中所有量均为无量纲。\n\n实现一个程序，对于下面测试套件中的每一组参数，计算如上定义的比率 $R$。\n\n测试套件（每个元组列出 $(L,a,N,s)$）：\n1. $(1,\\ 1,\\ 200,\\ 0.5)$,\n2. $(1,\\ 1,\\ 100,\\ 1)$,\n3. $(1,\\ -1,\\ 200,\\ 0.5)$,\n4. $(1,\\ 1,\\ 20,\\ 0.5)$,\n5. $(1,\\ 1,\\ 200,\\ 0.25)$.\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是按上述顺序列出的第 $k$ 个测试用例的 $R$ 的浮点值。", "solution": "所提出的问题是计算物理学中的一个标准练习，涉及线性平流方程的数值求解。该问题是适定的、科学上合理的，并且所有参数和条件都得到了明确的规定。因此，可以构建一个解决方案。\n\n问题的核心是量化一阶迎风有限差分格式固有的数值耗散。控制偏微分方程是线性平流方程：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n定义在一维定义域 $x\\in[0,L]$ 上，并具有周期性边界条件。对于这样的系统，解的平方积分 $\\int_0^L u(x,t)^2\\,\\mathrm{d}x$ 是一个守恒量。然而，数值格式会引入人为耗散，导致该量的离散模拟量随时间衰减。\n\n我们使用一个包含 $N$ 个点的均匀网格对定义域进行离散化，点为 $x_i = i\\,\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$），网格间距为 $\\Delta x = L/N$。解 $u(x,t)$ 由离散值 $u_i^n \\approx u(x_i, t^n)$ 近似，其中 $t^n = n\\,\\Delta t$ 是离散的时间层。\n\n首先，我们建立系统在时间 $t=0$ 时的初始状态。初始条件由下式给出：\n$$\nu(x,0)=\\sin\\!\\left(\\tfrac{2\\pi x}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x}{L}\\right)\n$$\n以离散形式，初始解向量 $u^0 = [u_0^0, u_1^0, \\dots, u_{N-1}^0]^T$ 初始化为：\n$$\nu_i^0 = \\sin\\!\\left(\\tfrac{2\\pi x_i}{L}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi x_i}{L}\\right) = \\sin\\!\\left(\\tfrac{2\\pi i}{N}\\right)+\\tfrac{1}{2}\\sin\\!\\left(\\tfrac{4\\pi i}{N}\\right)\n$$\n对于每个网格点 $i=0, 1, \\dots, N-1$。\n\n接下来，我们使用一阶迎风格式在时间上对解进行演化。时间步长 $\\Delta t$ 由库朗数 $s \\in (0,1]$ 决定：\n$$\n\\Delta t=\\frac{s\\,\\Delta x}{|a|}\n$$\n迎风格式的更新规则取决于平流速度 $a$ 的符号，该符号决定了信息传播的方向。\n\n情况1：$a0$（向右传播）。空间导数 $\\partial_x u$ 使用后向差分近似，因为信息来自“迎风”方向，即来自较小的 $x$。更新规则是：\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i-1}^{n}\\right)\n$$\n这里，因为 $a0$，所以 $s = a \\frac{\\Delta t}{\\Delta x}$。由于周期性边界条件，索引 $i-1$ 在模 $N$ 的意义下计算，即 $u_{-1}^n = u_{N-1}^n$。\n\n情况2：$a0$（向左传播）。空间导数使用前向差分近似，因为信息来自较大的 $x$。更新规则是：\n$$\nu_i^{n+1} = u_i^{n} - s\\left(u_i^{n}-u_{i+1}^{n}\\right)\n$$\n这里，$s = |a| \\frac{\\Delta t}{\\Delta x} = -a \\frac{\\Delta t}{\\Delta x}$。由于周期性，索引 $i+1$ 在模 $N$ 的意义下计算，即 $u_{N}^n = u_0^n$。\n\n模拟从 $t=0$ 进行到最终时间 $t_{\\mathrm{final}}=L/|a|$。这个时间对应于一个波在定义域上完成一次完整的周期性穿越。总时间步数 $N_t$ 为：\n$$\nN_t = \\frac{t_{\\mathrm{final}}}{\\Delta t} = \\frac{L/|a|}{s\\,\\Delta x/|a|} = \\frac{L}{s\\,\\Delta x} = \\frac{L}{s(L/N)} = \\frac{N}{s}\n$$\n问题保证对于所有测试用例，$N_t$ 都是一个整数。一个循环将执行此更新步骤 $N_t$ 次，以获得最终的离散解 $u^{N_t}$。\n\n最后，我们计算诊断比率 $R$。这需要计算离散二阶矩，其定义为：\n$$\nM_2^n=\\sum_{i=0}^{N-1} \\left(u_i^n\\right)^2 \\,\\Delta x\n$$\n我们使用初始解 $u^0$ 计算初始时刻的该量 $M_2^0$，并使用最终解 $u^{N_t}$ 计算最终时刻的该量 $M_2^{N_t}$。比率 $R$ 于是由下式给出：\n$$\nR=\\frac{M_2^{N_t}}{M_2^0}\n$$\n该比率 $R$ 量化了在一个遍历周期内，由于数值耗散导致的离散 $L_2$ 范数平方的衰减。对于无耗散格式，$R$ 将精确等于 $1$。对于一阶迎风格式，当 $s1$ 时，我们预期 $R1$，其与 $1$ 的偏差表明了耗散的大小。\n\n对于每个测试用例 $(L, a, N, s)$ 的算法如下：\n1.  定义网格参数：$\\Delta x = L/N$ 和 $N_t = \\text{int}(N/s)$。\n2.  生成空间网格 $x_i = i \\Delta x$（其中 $i = 0, \\dots, N-1$）。\n3.  使用给定公式计算初始解向量 $u^0$。\n4.  计算初始二阶矩 $M_2^0 = \\Delta x \\sum_{i=0}^{N-1} (u_i^0)^2$。\n5.  迭代 $N_t$ 次：在每一步中，根据 $a$ 的符号使用相应的迎风公式更新解向量 $u$，并遵守周期性边界。这可以使用向量化的数组操作来高效实现。\n6.  循环结束后，从最终解向量计算最终二阶矩 $M_2^{N_t}$。\n7.  计算并存储比率 $R = M_2^{N_t} / M_2^0$。\n\n对所有提供的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the linear advection equation using the first-order upwind scheme\n    and computes the diagnostic ratio R for several test cases.\n    \"\"\"\n    # Test suite from the problem statement: (L, a, N, s)\n    test_cases = [\n        (1, 1, 200, 0.5),\n        (1, 1, 100, 1),\n        (1, -1, 200, 0.5),\n        (1, 1, 20, 0.5),\n        (1, 1, 200, 0.25),\n    ]\n\n    results = []\n    \n    for L, a, N, s in test_cases:\n        # Step 1: Define grid parameters and number of time steps.\n        dx = L / N\n        # The problem statement guarantees that N/s is an integer.\n        num_time_steps = int(N / s)\n        \n        # Step 2: Set the initial condition on the grid.\n        # Grid points x_i = i * dx for i = 0, ..., N-1.\n        x = np.linspace(0, L, N, endpoint=False)\n        u_initial = np.sin(2 * np.pi * x / L) + 0.5 * np.sin(4 * np.pi * x / L)\n        \n        # Step 3: Calculate the initial discrete second moment M_2^0.\n        m2_initial = np.sum(u_initial**2) * dx\n        \n        # Step 4: Evolve the solution in time using the upwind scheme.\n        u_current = np.copy(u_initial)\n        \n        # The update rule depends on the sign of the velocity 'a'.\n        if a > 0:\n            # For a > 0, the scheme uses the backward difference (u_i - u_{i-1}).\n            # u_i^{n+1} = u_i^n - s * (u_i^n - u_{i-1}^n)\n            # np.roll(u, 1) provides u_{i-1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_previous = np.roll(u_current, 1)\n                u_current = u_current - s * (u_current - u_previous)\n        else: # a  0\n            # For a  0, the scheme uses the forward difference (u_{i+1} - u_i).\n            # The problem statement gives u_i^{n+1} = u_i^n - s * (u_i^n - u_{i+1}^n)\n            # which is equivalent to u_i^{n+1} = u_i^n + s * (u_{i+1}^n - u_i^n).\n            # np.roll(u, -1) provides u_{i+1} with periodic wrapping.\n            for _ in range(num_time_steps):\n                u_next = np.roll(u_current, -1)\n                u_current = u_current - s * (u_current - u_next)\n                \n        # Step 5: Calculate the final discrete second moment M_2^{N_t}.\n        m2_final = np.sum(u_current**2) * dx\n        \n        # Step 6: Compute the diagnostic ratio R.\n        # A check is included for the theoretical case of M_2^0 = 0, though not\n        # possible with the given initial condition.\n        if m2_initial == 0:\n            ratio = 1.0 if m2_final == 0 else np.inf\n        else:\n            ratio = m2_final / m2_initial\n            \n        results.append(ratio)\n        \n    # Final print statement in the exact required format.\n    # Results are formatted as floating-point numbers to ensure consistency.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\n# Execute the solver function.\nsolve()\n```", "id": "2448571"}, {"introduction": "真实世界的物理现象通常发生在多维空间中。最后的这个练习将把我们的一维求解器扩展到二维域。我们将把相同的一维迎风逻辑分别应用于$x$和$y$方向，以求解二维平流方程中一个高斯分布的演化[@problem_id:2448614]。这种通常被称为“分裂法”或“线方法”的技术，是构建多维数值方法的基石，也是计算科学中一项至关重要的实践技能。", "problem": "实现一个完整、可运行的程序，用于求解二维线性平流方程\n$$\n\\partial_t u(x,y,t) + v_x\\,\\partial_x u(x,y,t) + v_y\\,\\partial_y u(x,y,t) = 0\n$$\n在周期性域 $[0,L_x)\\times[0,L_y)$ 上，使用一阶迎风有限差分法，在均匀的、以单元为中心的网格上进行求解。初始条件是一个无量纲的高斯分布\n$$\nu(x,y,0) = \\exp\\!\\left(-\\frac{(x-x_0)^2 + (y-y_0)^2}{2\\,\\sigma^2}\\right),\n$$\n在两个空间方向上都具有周期性边界条件。所有量纲均为无量纲。使用在 $x$ 方向有 $N_x$ 个点、在 $y$ 方向有 $N_y$ 个点的均匀网格，网格点以单元为中心，位于\n$$\nx_i=(i+\\tfrac{1}{2})\\,\\Delta x,\\quad \\Delta x=\\frac{L_x}{N_x},\\quad i=0,1,\\dots,N_x-1,\n$$\n$$\ny_j=(j+\\tfrac{1}{2})\\,\\Delta y,\\quad \\Delta y=\\frac{L_y}{N_y},\\quad j=0,1,\\dots,N_y-1.\n$$\n使用恒定的时间步长 $\\Delta t$ 将数值解推进到最终时间 $T$，使得 $T = N_{\\text{steps}}\\Delta t$，其中 $N_{\\text{steps}}$ 是给定的整数。在两个空间方向上施加周期性边界条件。对于每个测试用例，计算在时间 $T$ 的离散均方根误差，\n$$\nE = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(u_{i,j}(T) - u_{\\text{exact}}(x_i,y_j,T)\\right)^2},\n$$\n其中，周期性边界条件下的精确解由初始条件的周期性平移给出，\n$$\nu_{\\text{exact}}(x,y,T) = u_0\\!\\Big(\\operatorname{wrap}(x - v_x T,L_x),\\ \\operatorname{wrap}(y - v_y T,L_y)\\Big),\n$$\n且 $\\operatorname{wrap}(z,L)$ 表示 $z$ 模 $L$ 在 $[0,L)$ 中的唯一代表。这里 $u_0(x,y)$ 表示初始高斯分布。所有计算都必须以无量纲单位进行。\n\n使用以下固定参数（所有测试用例通用）：\n- 域大小：$L_x=1$, $L_y=1$。\n- 初始高斯中心：$x_0=0.35$, $y_0=0.40$。\n- 初始高斯宽度：$\\sigma=0.08$。\n\n测试套件。为以下每组参数运行程序。在每种情况下，将时间步长设置为 $\\Delta t = T/N_{\\text{steps}}$ 并精确使用给定的值：\n- 情况 1：$N_x=64$, $N_y=64$, $v_x=0.7$, $v_y=0.2$, $T=0.5$, $N_{\\text{steps}}=36$。\n- 情况 2：$N_x=100$, $N_y=60$, $v_x=-1.0$, $v_y=0.0$, $T=0.4$, $N_{\\text{steps}}=50$。\n- 情况 3：$N_x=64$, $N_y=80$, $v_x=0.0$, $v_y=0.5$, $T=0.6$, $N_{\\text{steps}}=30$。\n- 情况 4：$N_x=64$, $N_y=64$, $v_x=0.0$, $v_y=0.0$, $T=0.25$, $N_{\\text{steps}}=25$。\n- 情况 5：$N_x=50$, $N_y=50$, $v_x=0.9$, $v_y=-0.9$, $T=0.44$, $N_{\\text{steps}}=40$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含五个均方根误差，按情况 1 到 5 的顺序排列，格式为用方括号括起来的逗号分隔列表，例如\n$$\n[\\text{E}_1,\\text{E}_2,\\text{E}_3,\\text{E}_4,\\text{E}_5].\n$$\n每个条目必须是一个浮点数。不应打印任何其他文本。", "solution": "所提出的问题是计算物理学中的一个标准练习，涉及二维线性平流方程的数值解。它具有科学依据，是适定的，并包含唯一解所需的所有必要信息。所有为测试用例提供的参数都满足所提出的显式一阶迎风格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件。因此，该问题被认为是有效的，其解的构造如下。\n\n控制方程是二维空间 $(x,y)$ 和时间 $t$ 的线性平流方程：\n$$\n\\partial_t u + v_x\\,\\partial_x u + v_y\\,\\partial_y u = 0\n$$\n其中 $u(x,y,t)$ 是一个被恒定速度场 $\\vec{v} = (v_x, v_y)$ 平流的标量。我们的任务是在周期性域 $[0,L_x) \\times [0,L_y)$ 上数值求解此方程。\n\n该求解采用了线方法，即分别对空间和时间维度进行离散化。时间离散化使用显式一阶前向欧拉法，而空间导数则使用一阶迎风有限差分格式进行近似。设 $u_{i,j}^n$ 表示 $u(x_i, y_j, t_n)$ 的数值近似，其中 $x_i = (i + 1/2)\\Delta x$ 和 $y_j = (j + 1/2)\\Delta y$ 是以单元为中心的网格坐标，而 $t_n = n\\Delta t$ 是第 $n$ 步的时间。\n\n方程在时间上的半离散化为：\n$$\n\\frac{u_{i,j}^{n+1} - u_{i,j}^n}{\\Delta t} = - (v_x\\,\\partial_x u + v_y\\,\\partial_y u)\\Big|_{i,j}^n\n$$\n\n迎风方法的核心是，空间差分偏向信息传播的方向，即平流速度的“上游”（迎风）方向。空间导数的近似取决于速度分量 $v_x$ 和 $v_y$ 的符号。\n\n对于 $\\partial_x u$ 项：\n- 如果 $v_x > 0$，信息从较小的 $x$（左侧）传播，因此使用后向差分：\n  $$ \\partial_x u \\approx \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} $$\n- 如果 $v_x  0$，信息从较大的 $x$（右侧）传播，因此使用前向差分：\n  $$ \\partial_x u \\approx \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} $$\n- 如果 $v_x = 0$，则该项为零。\n\n这可以使用速度的正部和负部 $v_x^+ = \\max(v_x, 0)$ 和 $v_x^- = \\min(v_x, 0)$ 紧凑地表示：\n$$\nv_x \\partial_x u \\approx v_x^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + v_x^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x}\n$$\n对于 $y$ 方向的导数，也有类似的表达式：\n$$\nv_y \\partial_y u \\approx v_y^+ \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} + v_y^- \\frac{u_{i,j+1}^n - u_{i,j}^n}{\\Delta y}\n$$\n\n结合这些离散化，我们得到 $u_{i,j}^{n+1}$ 的完整更新规则：\n$$\nu_{i,j}^{n+1} = u_{i,j}^n - \\Delta t \\left( v_x^+ \\frac{u_{i,j}^n - u_{i-1,j}^n}{\\Delta x} + v_x^- \\frac{u_{i+1,j}^n - u_{i,j}^n}{\\Delta x} \\right) - \\Delta t \\left( v_y^+ \\frac{u_{i,j}^n - u_{i,j-1}^n}{\\Delta y} + v_y^- \\frac{u_{i,j+1}^n - u_{i,j}^n}{\\Delta y} \\right)\n$$\n该格式在时间和空间上都是一阶精确的。虽然该格式简单且在 CFL 条件 $\\Delta t (|v_x|/\\Delta x + |v_y|/\\Delta y) \\le 1$ 下是稳定的，但众所周知它具有高耗散性，这意味着它会引入显著的数值耗散，从而平滑解中的尖锐特征。这将是误差的主要来源。\n\n实现过程如下：\n1. 对于每个测试用例，定义网格参数（$N_x, N_y$）、速度分量（$v_x, v_y$）和时间积分参数（$T, N_{\\text{steps}}$）。计算导出量 $\\Delta x=L_x/N_x$、$\\Delta y=L_y/N_y$ 和 $\\Delta t=T/N_{\\text{steps}}$。\n2. 构建一个二维的以单元为中心的坐标网格 $(X, Y)$。在这些网格点上计算初始条件 $u(x,y,0)$，以初始化解数组 $u$。\n3. 循环迭代 $N_{\\text{steps}}$ 次，将解从 $t=0$ 推进到 $t=T$。在每一步中，更新规则同时应用于所有网格点。通过使用数组滚动操作（如 `numpy.roll`）来实施周期性边界条件，这能正确地在域边界处包裹索引。例如，要访问 $u_{i-1,j}$，数组被移动，使得索引 $i-1$ 的数据移动到索引 $i$。对于 $i=0$，则使用最后一个索引 $N_x-1$ 的数据。\n4. 在最后一个时间步之后，获得数值解 $u(T)$。\n5. 计算最终时间 $T$ 的精确解。对于周期性域上的线性平流方程，初始分布只是简单地平移。在时间 $T$ 时，一个最初位于 $(x', y')$ 的流体元的位置是 $(x,y) = (x'+v_x T, y'+v_y T)$。因此，在 $(x,y,T)$ 处的解是初始状态在 $(x-v_x T, y-v_y T)$ 处的值。对于周期性域，这个参数必须被包裹：\n$$\nu_{\\text{exact}}(x,y,T) = u_0(\\operatorname{wrap}(x - v_x T,L_x),\\ \\operatorname{wrap}(y - v_y T,L_y))\n$$\n其中 $\\operatorname{wrap}(z, L)$ 计算 $z \\pmod{L}$ 到区间 $[0,L)$ 内的值。\n6. 最后，按规定计算离散均方根误差 $E$：\n$$\nE = \\sqrt{\\frac{1}{N_x N_y}\\sum_{i=0}^{N_x-1}\\sum_{j=0}^{N_y-1}\\left(u_{i,j}(T) - u_{\\text{exact}}(x_i,y_j,T)\\right)^2}\n$$\n程序为所提供的五个测试用例中的每一个计算此误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D linear advection equation using a first-order upwind scheme.\n    \"\"\"\n    \n    # Fixed parameters common to all test cases (dimensionless)\n    L_x = 1.0\n    L_y = 1.0\n    x_0 = 0.35\n    y_0 = 0.40\n    sigma = 0.08\n\n    # Test suite: (Nx, Ny, vx, vy, T, N_steps)\n    test_cases = [\n        (64, 64, 0.7, 0.2, 0.5, 36),\n        (100, 60, -1.0, 0.0, 0.4, 50),\n        (64, 80, 0.0, 0.5, 0.6, 30),\n        (64, 64, 0.0, 0.0, 0.25, 25),\n        (50, 50, 0.9, -0.9, 0.44, 40),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        N_x, N_y, v_x, v_y, T, N_steps = case\n        \n        # Calculate grid spacing and time step\n        delta_x = L_x / N_x\n        delta_y = L_y / N_y\n        delta_t = T / N_steps\n\n        # Create cell-centered grid coordinates\n        x_coords = (np.arange(N_x) + 0.5) * delta_x\n        y_coords = (np.arange(N_y) + 0.5) * delta_y\n        X, Y = np.meshgrid(x_coords, y_coords)\n\n        # Initialize the solution with the Gaussian profile\n        u = np.exp(-((X - x_0)**2 + (Y - y_0)**2) / (2 * sigma**2))\n\n        # Time evolution loop\n        for _ in range(N_steps):\n            u_current = u.copy()\n            \n            # X-advection flux term based on upwinding\n            if v_x > 0:\n                flux_x = v_x * (u_current - np.roll(u_current, 1, axis=1)) / delta_x\n            elif v_x  0:\n                flux_x = v_x * (np.roll(u_current, -1, axis=1) - u_current) / delta_x\n            else:  # v_x == 0\n                flux_x = np.zeros_like(u_current)\n\n            # Y-advection flux term based on upwinding\n            if v_y > 0:\n                flux_y = v_y * (u_current - np.roll(u_current, 1, axis=0)) / delta_y\n            elif v_y  0:\n                flux_y = v_y * (np.roll(u_current, -1, axis=0) - u_current) / delta_y\n            else:  # v_y == 0\n                flux_y = np.zeros_like(u_current)\n            \n            # Update the solution using forward Euler\n            u = u_current - delta_t * (flux_x + flux_y)\n\n        # Calculate the exact solution at time T\n        # The modulo operator '%' in Python correctly handles wrapping for periodic BC\n        x_exact_arg = (X - v_x * T) % L_x\n        y_exact_arg = (Y - v_y * T) % L_y\n        u_exact = np.exp(-((x_exact_arg - x_0)**2 + (y_exact_arg - y_0)**2) / (2 * sigma**2))\n\n        # Compute the discrete root-mean-square error\n        error = np.sqrt(np.mean((u - u_exact)**2))\n        results.append(error)\n\n    # Print the final results in the required format\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "2448614"}]}