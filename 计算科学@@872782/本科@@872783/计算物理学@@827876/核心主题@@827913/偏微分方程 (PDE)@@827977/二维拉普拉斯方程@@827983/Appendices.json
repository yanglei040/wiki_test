{"hands_on_practices": [{"introduction": "拉普拉斯方程的解（调和函数）具有一个非常重要的性质，即极值原理。这个原理指出，在一个无源区域内，电势或温度等物理量不会出现局部最大值或最小值，所有极值都必定出现在区域的边界上。这个练习将通过一个具体的例子，让你亲手验证并应用这个关键的物理和数学原理。[@problem_id:2249485]", "problem": "在物理学中，解析复变函数的实部通常表示一个标量势，例如静电势或温度分布。这类函数是调和的，意即在复变函数解析的区域内，它们满足拉普拉斯方程。\n\n考虑一个定义在闭合单位圆盘 $D = \\{z \\in \\mathbb{C} : |z| \\leq 1\\}$ 上的调和势函数 $\\Phi(x, y)$，其中 $z=x+iy$。该势由复变函数 $F(z) = (z-a)^2$ 给出，$\\Phi(x, y) = \\operatorname{Re}(F(z))$。常数 $a$ 是一个实数，具体为 $a=1/2$。\n\n你的任务是找出在圆盘 $D$ 上势 $\\Phi(x,y)$ 达到其绝对最大值和绝对最小值的点。下列哪个选项正确地指出了最大值（记为 $z_{max}$）和最小值（记为 $z_{min}$）的位置？\n\nA. $z_{max} = 1$；$z_{min} = -1$。\n\nB. $z_{max} = -1$；$z_{min}$ 是集合 $\\{ \\frac{1}{4} + i\\frac{\\sqrt{15}}{4}, \\frac{1}{4} - i\\frac{\\sqrt{15}}{4} \\}$ 中的两个点。\n\nC. $z_{max}$ 是集合 $\\{1, -1\\}$ 中的两个点；$z_{min}$ 是集合 $\\{i, -i\\}$ 中的两个点。\n\nD. $z_{max} = 1/2$；$z_{min} = -1$。\n\nE. $z_{max} = 1$；$z_{min}$ 是集合 $\\{ \\frac{1}{2} + i\\frac{\\sqrt{3}}{2}, \\frac{1}{2} - i\\frac{\\sqrt{3}}{2} \\}$ 中的两个点。", "solution": "给定 $F(z)=(z-a)^{2}$，其中 $a=\\frac{1}{2}$ 为实数，以及在闭合单位圆盘 $D=\\{z\\in\\mathbb{C}:|z|\\leq 1\\}$ 上的 $\\Phi(x,y)=\\operatorname{Re}(F(z))$。由于 $F$ 在 $D$ 的一个邻域上是解析的，所以 $\\Phi$ 在 $D$ 上是调和的。根据调和函数的最大/最小值原理，一个非常数的调和函数在边界 $|z|=1$ 上达到其绝对最大值和最小值。\n\n记 $z=x+iy$，并设 $u=x-\\frac{1}{2}$，$v=y$。则\n$$\nF(z)=(u+iv)^{2}=u^{2}-v^{2}+2iuv,\n$$\n所以\n$$\n\\Phi(x,y)=\\operatorname{Re}(F(z))=u^{2}-v^{2}=(x-\\tfrac{1}{2})^{2}-y^{2}.\n$$\n限制在边界 $x^{2}+y^{2}=1$ 上，用 $x=\\cos\\theta$，$y=\\sin\\theta$ 进行参数化。则\n$$\n\\Phi(\\theta)=(\\cos\\theta-\\tfrac{1}{2})^{2}-\\sin^{2}\\theta=\\cos^{2}\\theta-\\cos\\theta+\\tfrac{1}{4}-(1-\\cos^{2}\\theta)=2\\cos^{2}\\theta-\\cos\\theta-\\tfrac{3}{4}.\n$$\n令 $u=\\cos\\theta\\in[-1,1]$。则\n$$\n\\Phi(u)=2u^{2}-u-\\tfrac{3}{4}.\n$$\n这是一个关于 $u$ 的二次函数，其首项系数为正，所以它在 $[-1,1]$ 上的最小值在顶点 $u=\\frac{1}{4}$ 处取得，而其最大值在端点处取得。计算这些值：\n$$\n\\Phi\\!\\left(\\tfrac{1}{4}\\right)=2\\cdot\\tfrac{1}{16}-\\tfrac{1}{4}-\\tfrac{3}{4}=\\tfrac{1}{8}-1=-\\tfrac{7}{8},\n$$\n$$\n\\Phi(-1)=2\\cdot(-1)^2-(-1)-\\tfrac{3}{4}=2+1-\\tfrac{3}{4}=\\tfrac{9}{4},\\quad \\Phi(1)=2\\cdot 1^2-1-\\tfrac{3}{4}=\\tfrac{1}{4}.\n$$\n因此，绝对最大值在 $u=-1$ 处取得，即 $x=\\cos\\theta=-1$，$y=0$，所以 $z_{\\max}=-1$。绝对最小值在 $u=\\cos\\theta=\\frac{1}{4}$ 处取得，这给出 $x=\\frac{1}{4}$ 以及 $y=\\pm\\sqrt{1-\\frac{1}{16}}=\\pm\\frac{\\sqrt{15}}{4}$，即 $z_{\\min}\\in\\left\\{\\frac{1}{4}\\pm i\\frac{\\sqrt{15}}{4}\\right\\}$。\n\n这些位置与选项 B 相符。", "answer": "$$\\boxed{B}$$", "id": "2249485"}, {"introduction": "在计算物理中，我们常常倾向于立即使用数值方法求解偏微分方程。然而，在某些情况下，问题的物理约束（如绝热边界）可以极大地简化问题，甚至得到精确的解析解。这个练习模拟了一个看似复杂的二维热传导问题，但通过分析，你将发现其解出人意料地简单，从而深刻理解物理洞察力在问题求解中的价值。[@problem_id:2406731]", "problem": "考虑一个均匀、各向同性的矩形板，其占据的区域为 $\\{(x,y)\\,|\\,0 \\le x \\le L_x,\\;0 \\le y \\le L_y\\}$，且无内部热源。稳态温度场 $T(x,y)$ 在该开矩形上满足二维拉普拉斯方程\n$$\n\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n$$\n边界条件如下：底边保持在均匀温度 $T(x,0) = T_{\\mathrm{hot}}$（单位为 $\\mathrm{K}$），顶边保持在均匀温度 $T(x,L_y) = T_{\\mathrm{cold}}$（单位为 $\\mathrm{K}$），左右两边是绝热的，即对于所有 $y \\in [0,L_y]$，有 $\\frac{\\partial T}{\\partial x}(0,y) = 0$ 和 $\\frac{\\partial T}{\\partial x}(L_x,y) = 0$。所有长度单位均为 $\\mathrm{m}$，所有温度单位均为 $\\mathrm{K}$。不涉及角度。您的任务是，对于每一组指定的参数，计算几何中心 $(x,y) = (L_x/2,L_y/2)$ 处的稳态温度，并以 $\\mathrm{K}$ 为单位报告结果，四舍五入到小数点后 $3$ 位。\n\n测试组（每个案例指定 $(L_x,\\;L_y,\\;T_{\\mathrm{hot}},\\;T_{\\mathrm{cold}})$，单位为 $(\\mathrm{m},\\;\\mathrm{m},\\;\\mathrm{K},\\;\\mathrm{K})$）：\n- 案例 A: $L_x = 1.0\\,\\mathrm{m}$，$L_y = 1.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 400.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 300.0\\,\\mathrm{K}$。\n- 案例 B: $L_x = 2.5\\,\\mathrm{m}$，$L_y = 0.8\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 310.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 330.0\\,\\mathrm{K}$。\n- 案例 C: $L_x = 0.7\\,\\mathrm{m}$，$L_y = 3.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 273.15\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 373.15\\,\\mathrm{K}$。\n- 案例 D: $L_x = 1.2\\,\\mathrm{m}$，$L_y = 2.0\\,\\mathrm{m}$，$T_{\\mathrm{hot}} = 300.0\\,\\mathrm{K}$，$T_{\\mathrm{cold}} = 300.0\\,\\mathrm{K}$。\n\n对于每个案例，计算 $(L_x/2,L_y/2)$ 处的稳态温度 $T$（单位为 $\\mathrm{K}$），并四舍五入到小数点后 $3$ 位。您的程序应生成单行输出，包含一个逗号分隔的列表，用方括号括起来（例如，[resultA,resultB,resultC,resultD]），不含空格，其中每个条目是以十进制数表示的四舍五入后的数值（单位为 $\\mathrm{K}$）。", "solution": "问题陈述是连贯的、有科学依据的，并且在数学上是适定的。它描述了一个矩形域上二维拉普拉斯方程的标准边值问题，该问题组合了狄利克雷（Dirichlet）和诺伊曼（Neumann）边界条件。根据偏微分方程理论，已知此类问题存在唯一且稳定的解。因此，我们将直接推导该解。\n\n该物理系统由稳态热方程描述，即温度场 $T(x,y)$ 的拉普拉斯方程：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} + \\frac{\\partial^2 T}{\\partial y^2} = 0\n$$\n域是 $0 \\le x \\le L_x$ 和 $0 \\le y \\le L_y$ 定义的矩形。边界条件为：\n$1$. $T(x,0) = T_{\\mathrm{hot}}$（狄利克雷条件）\n$2$. $T(x,L_y) = T_{\\mathrm{cold}}$（狄利克雷条件）\n$3$. $\\frac{\\partial T}{\\partial x}(0,y) = 0$（诺伊曼条件）\n$4$. $\\frac{\\partial T}{\\partial x}(L_x,y) = 0$（诺伊曼条件）\n\n我们采用分离变量法，假设解的形式为 $T(x,y) = X(x)Y(y)$。将其代入拉普拉斯方程并分离变量，得到：\n$$\n\\frac{X''(x)}{X(x)} = -\\frac{Y''(y)}{Y(y)} = -\\lambda\n$$\n其中 $\\lambda$ 是分离常数。这给出了两个常微分方程：\n$$\nX''(x) + \\lambda X(x) = 0\n$$\n$$\nY''(y) - \\lambda Y(y) = 0\n$$\n我们首先使用齐次诺伊曼边界条件求解 $X(x)$ 的方程。条件 $\\frac{\\partial T}{\\partial x}(0,y) = X'(0)Y(y) = 0$ 和 $\\frac{\\partial T}{\\partial x}(L_x,y) = X'(L_x)Y(y) = 0$ 要求对于任何非平凡解 $Y(y)$，都有 $X'(0) = 0$ 和 $X'(L_x) = 0$。\n\n情况1：$\\lambda > 0$。令 $\\lambda = k^2$ 且 $k > 0$。解为 $X(x) = A\\cos(kx) + B\\sin(kx)$。其导数为 $X'(x) = -Ak\\sin(kx) + Bk\\cos(kx)$。\n应用 $X'(0)=0$ 得到 $Bk=0$，所以 $B=0$。解的形式为 $X(x) = A\\cos(kx)$。\n应用 $X'(L_x)=0$ 得到 $-Ak\\sin(kL_x) = 0$。对于非平凡解（$A \\neq 0$），我们必须有 $\\sin(kL_x) = 0$，这意味着 $kL_x = n\\pi$，其中 $n=1, 2, 3, \\ldots$。\n特征值为 $\\lambda_n = k_n^2 = \\left(\\frac{n\\pi}{L_x}\\right)^2$，其中 $n \\ge 1$。对应的特征函数为 $X_n(x) = A_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right)$。\n\n情况2：$\\lambda = 0$。方程变为 $X''(x) = 0$，解为 $X(x) = C_1x + C_2$。其导数为 $X'(x) = C_1$。\n条件 $X'(0)=0$ 和 $X'(L_x)=0$ 都给出 $C_1=0$。因此，$X_0(x) = C_2$（一个常数）也是一个有效的特征函数，对应于特征值 $\\lambda_0 = 0$。\n\n情况3：$\\lambda  0$。令 $\\lambda = -k^2$ 且 $k  0$。方程 $X''(x) - k^2X(x) = 0$ 的解为 $X(x) = A\\cosh(kx) + B\\sinh(kx)$。应用边界条件导致 $A=B=0$，只得到平凡解。因此没有负特征值。\n\n现在我们求解 $Y(y)$。\n对于 $\\lambda_n = k_n^2 = \\left(\\frac{n\\pi}{L_x}\\right)^2$ 且 $n \\ge 1$，方程为 $Y_n''(y) - k_n^2 Y_n(y) = 0$。其解为 $Y_n(y) = C_n\\cosh(k_n y) + D_n\\sinh(k_n y)$。\n对于 $\\lambda_0 = 0$，方程为 $Y_0''(y) = 0$。其解为 $Y_0(y) = C_0 y + D_0$。\n\n通解是所有可能乘积解的叠加：\n$$\nT(x,y) = X_0(x)Y_0(y) + \\sum_{n=1}^{\\infty} X_n(x)Y_n(y)\n$$\n合并常数后，上式变为：\n$$\nT(x,y) = C_0 y + D_0 + \\sum_{n=1}^{\\infty} \\cos\\left(\\frac{n\\pi x}{L_x}\\right) \\left[ E_n \\cosh\\left(\\frac{n\\pi y}{L_x}\\right) + F_n \\sinh\\left(\\frac{n\\pi y}{L_x}\\right) \\right]\n$$\n我们现在应用余下的非齐次狄利克雷边界条件。\n在 $y=0$ 处：$T(x,0) = T_{\\mathrm{hot}}$。\n$$\nT_{\\mathrm{hot}} = D_0 + \\sum_{n=1}^{\\infty} E_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right)\n$$\n这是一个常数函数 $T_{\\mathrm{hot}}$ 的傅里叶余弦级数表示。通过观察，或通过计算傅里叶系数，常数项必须是 $D_0 = T_{\\mathrm{hot}}$，而所有其他 $n \\ge 1$ 的系数必须为零，所以 $E_n = 0$ 对所有 $n \\ge 1$ 成立。\n\n解简化为：\n$$\nT(x,y) = C_0 y + T_{\\mathrm{hot}} + \\sum_{n=1}^{\\infty} F_n \\cos\\left(\\frac{n\\pi x}{L_x}\\right) \\sinh\\left(\\frac{n\\pi y}{L_x}\\right)\n$$\n在 $y=L_y$ 处：$T(x,L_y) = T_{\\mathrm{cold}}$。\n$$\nT_{\\mathrm{cold}} = C_0 L_y + T_{\\mathrm{hot}} + \\sum_{n=1}^{\\infty} F_n \\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) \\cos\\left(\\frac{n\\pi x}{L_x}\\right)\n$$\n这是常数函数 $T_{\\mathrm{cold}}$ 的傅里叶余弦级数。再次比较系数：\n常数项必须匹配：$T_{\\mathrm{cold}} = C_0 L_y + T_{\\mathrm{hot}} \\implies C_0 = \\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}$。\n$n \\ge 1$ 的余弦项系数必须为零：$F_n \\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) = 0$。\n由于当 $n \\ge 1$ 时，$\\frac{n\\pi L_y}{L_x}  0$，我们有 $\\sinh\\left(\\frac{n\\pi L_y}{L_x}\\right) \\neq 0$。因此，我们必须有 $F_n = 0$ 对所有 $n \\ge 1$ 成立。\n\n级数中的所有项都消失了。唯一解非常简单，仅依赖于 $y$ 坐标：\n$$\nT(x,y) = \\left(\\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}\\right) y + T_{\\mathrm{hot}}\n$$\n这个线性分布代表了一个均匀的垂直温度梯度，这与由绝热侧边界所决定的两平行板之间的一维热流是一致的。题目要求我们求解板的几何中心 $(x,y) = (L_x/2, L_y/2)$ 处的温度。温度与 $x$ 无关。代入 $y = L_y/2$ 得到：\n$$\nT(L_x/2, L_y/2) = \\left(\\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{L_y}\\right) \\frac{L_y}{2} + T_{\\mathrm{hot}} = \\frac{T_{\\mathrm{cold}} - T_{\\mathrm{hot}}}{2} + T_{\\mathrm{hot}} = \\frac{T_{\\mathrm{cold}} + T_{\\mathrm{hot}}}{2}\n$$\n垂直中点处的温度就是顶部和底部边界温度的算术平均值。这个结果与板的尺寸 $L_x$ 和 $L_y$ 无关。每个测试案例都通过应用此公式来解决。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state temperature at the center of a rectangular plate\n    with specified boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains (Lx, Ly, Thot, Tcold) in units of (m, m, K, K).\n    test_cases = [\n        (1.0, 1.0, 400.0, 300.0),\n        (2.5, 0.8, 310.0, 330.0),\n        (0.7, 3.0, 273.15, 373.15),\n        (1.2, 2.0, 300.0, 300.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack the parameters for the current case.\n        # Lx and Ly are not needed for the final calculation but are kept for clarity.\n        Lx, Ly, Thot, Tcold = case\n\n        # The analytical solution for the temperature T(x,y) is:\n        # T(x,y) = ((Tcold - Thot) / Ly) * y + Thot\n        # This is because the side walls are insulated, making the heat flow\n        # purely one-dimensional in the y-direction.\n        # We need to find the temperature at the geometric center (Lx/2, Ly/2).\n        # T(Lx/2, Ly/2) = ((Tcold - Thot) / Ly) * (Ly/2) + Thot\n        # T_center = (Tcold - Thot) / 2 + Thot\n        # T_center = (Tcold + Thot) / 2\n        \n        temp_center = (Thot + Tcold) / 2.0\n        \n        # Format the result to 3 decimal places as required.\n        results.append(f\"{temp_center:.3f}\")\n\n    # Final print statement in the exact required format: [resultA,resultB,...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2406731"}, {"introduction": "当解析解不存在或难以求得时，功能强大的数值求解器就变得至关重要。这个综合性练习将指导你从第一性原理出发，构建一个能够处理混合边界条件（狄利克雷和诺伊曼）的二维拉普拉斯方程有限差分求解器。通过完成这个练习，你将掌握将连续的物理定律离散化为线性方程组，并用代码实现求解的核心计算技能。[@problem_id:2406696]", "problem": "考虑二维拉普拉斯方程，它是用于稳态、无源场的典型椭圆偏微分方程（PDE）。在矩形域中的控制方程为\n$$\n\\nabla^2 u(x,y) \\equiv \\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0 \\quad \\text{for} \\quad (x,y)\\in \\Omega,\n$$\n其中 $\\Omega = [0,1]\\times[0,1]$。在边界 $\\partial\\Omega$ 上规定了边界条件，可以是狄利克雷（Dirichlet）类型 $u = d(x,y)$ 或诺伊曼（Neumann）类型 $\\frac{\\partial u}{\\partial n} = g(x,y)$，其中 $\\frac{\\partial}{\\partial n}$ 表示外法向导数。目标是构建一个计算求解器，能够处理边界上不同（可能为分段）部分上的狄利克雷和诺伊曼混合条件。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 使用 $N\\times N$ 个节点的均匀笛卡尔网格对域 $\\Omega$ 进行离散化，其中 $N$ 由每个测试用例指定。\n- 基于泰勒展开，从第一性原理推导出一个用于 $\\nabla^2 u = 0$ 内部离散的二阶精确有限差分方法，以及一个沿内法线方向处理诺伊曼边界条件的二阶精确方法（在没有推导的情况下，不要假设任何公式；使用导数和泰勒级数的定义来构建二阶近似）。\n- 组装并求解在所有网格节点上得到的关于 $u$ 的线性系统。\n- 支持沿正方形每条边分段指定的边界条件。对于每条边，分段由一个遍历该边的参数 $s\\in[0,1]$ 给出：对于左边和右边，$s=y$；对于底边和顶边，$s=x$。在每个网格边界节点上，通过在规定的分段区间内定位 $s$ 来选择适当的边界条件类型和值。在四个角节点处，施加从测试用例指定的精确解中获取的狄利克雷值，以消除任何歧义。\n- 对于诺伊曼数据，必须使用外法向导数。单位外法向量在左边是 $(-\\hat{\\boldsymbol{i}})$，在右边是 $(+\\hat{\\boldsymbol{i}})$，在底边是 $(-\\hat{\\boldsymbol{j}})$，在顶边是 $(+\\hat{\\boldsymbol{j}})$。\n\n请使用以下测试套件。在每种情况下，都提供了一个精确的调和函数 $u^\\star(x,y)$。您必须构建与 $u^\\star(x,y)$ 一致的边界条件数据，以使精确解同时满足偏微分方程和边界条件。对于诺伊曼数据，使用上述外法向定义计算 $g(x,y)=\\frac{\\partial u^\\star}{\\partial n}(x,y)$。\n\n- 测试用例 A（一般混合，平滑多项式）：\n  - 域：$\\Omega=[0,1]\\times[0,1]$。\n  - 网格：$N=51$（因此网格间距为 $h=\\frac{1}{N-1}$）。\n  - 精确解：$u^\\star(x,y)=x^2 - y^2$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = -\\frac{\\partial u^\\star}{\\partial y}(x,0)$。\n    - 顶边 ($y=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial y}(x,1)$。\n    - 角点：狄利克雷条件，值设为 $u^\\star$。\n- 测试用例 B（单边分段混合）：\n  - 域：$\\Omega=[0,1]\\times[0,1]$。\n  - 网格：$N=51$。\n  - 精确解：$u^\\star(x,y)=x$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial x}(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(x,0)$。\n    - 顶边 ($y=1$): 沿 $s=x$ 分段：\n      - 在 $s\\in[0,0.4]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial y}(x,1)$，\n      - 在 $s\\in(0.4,1]$ 上为狄利克雷条件，其中 $u = u^\\star(x,1)$。\n    - 角点：狄利克雷条件，值设为 $u^\\star$。\n- 测试用例 C（小网格及两边齐次诺伊曼条件的边缘情况）：\n  - 域：$\\Omega=[0,1]\\times[0,1]$。\n  - 网格：$N=9$。\n  - 精确解：$u^\\star(x,y)=y$。\n  - 边界分段：\n    - 左边 ($x=0$): 在 $s\\in[0,1]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = -\\frac{\\partial u^\\star}{\\partial x}(0,y)$。\n    - 右边 ($x=1$): 在 $s\\in[0,1]$ 上为诺伊曼条件，其中 $\\frac{\\partial u}{\\partial n} = +\\frac{\\partial u^\\star}{\\partial x}(1,y)$。\n    - 底边 ($y=0$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(x,0)$。\n    - 顶边 ($y=1$): 在 $s\\in[0,1]$ 上为狄利克雷条件，其中 $u = u^\\star(x,1)$。\n    - 角点：狄利克雷条件，值设为 $u^\\star$。\n\n要求的数值设计：\n- 内部离散化：使用关于网格节点的泰勒展开和二阶导数作为对称差商极限的定义，推导出一个在内部节点上对 $\\nabla^2 u = 0$ 的二阶精确五点有限差分近似。\n- 诺伊曼边界离散化：推导一个在边界节点上沿内法线方向对外法向导数的二阶精确单边有限差分近似。构建边界节点、沿内法线方向的前两个内部节点以及诺伊曼数据 $g$ 之间的线性关系，该关系在 $h$ 上达到二阶一致。\n- 狄利克雷边界离散化：在边界节点上精确施加规定的 $u$ 值。\n\n对于每个测试用例，计算最大绝对误差\n$$\nE_\\infty = \\max_{0\\le i,j \\le N-1} \\left| u_{i,j}^{\\text{num}} - u^\\star(x_i,y_j) \\right|\n$$\n遍历所有网格节点，其中 $x_i = i\\,h$，$y_j = j\\,h$，且 $h=\\frac{1}{N-1}$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个列表，按顺序含有测试用例 A、B 和 C 的三个误差值，四舍五入到八位小数。格式必须严格如下：\n- 单行：[eA,eB,eC]，其中每个条目都是一个十进制数（例如，[0.00000000,0.00000000,0.00000000]）。\n\n此问题不涉及物理单位。不使用角度。不要求百分比。程序必须完全自包含，且不得读取任何输入。它必须能“按原样”运行并产生所需的单行输出。在所有选择和推导中，请确保科学真实性和内部一致性。您的算法必须从导数和泰勒展开的基本定义开始；在您的实现设计中，不得在没有推导的情况下假设任何捷径公式。求解器必须具有足够的通用性，以处理上述分段边界规范。", "solution": "用户要求在单位正方形上使用二阶有限差分法，对二维拉普拉斯方程 $\\nabla^2 u = 0$ 进行计算求解，该方法适用于内部节点和诺伊曼边界条件。该问题定义明确，科学上合理，并为测试用例提供了所有必要的参数。问题有效性检查通过。我们将继续进行求解器的推导和构建。\n\n控制偏微分方程（PDE）是在域 $\\Omega = [0,1]\\times[0,1]$ 上的拉普拉斯方程：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x,y) + \\frac{\\partial^2 u}{\\partial y^2}(x,y) = 0\n$$\n\n我们使用一个包含 $N \\times N$ 个节点的均匀笛卡尔网格对域 $\\Omega$ 进行离散化。网格点表示为 $(x_i, y_j) = (i h, j h)$，其中 $i, j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = \\frac{1}{N-1}$。函数 $u$ 在网格点 $(x_i, y_j)$ 处的值记为 $u_{i,j}$。\n\n有限差分格式的推导\n\n该方法的核心是使用泰勒级数展开来近似偏导数。\n\n1. 内部节点离散化\n\n对于一个内部节点 $(i,j)$，其中 $0  i  N-1$ 且 $0  j  N-1$，我们对二阶偏导数进行近似。$u$ 在 $(x_i, y_j)$ 处沿 $x$ 方向的泰勒级数展开为：\n$$\nu(x_i+h, y_j) = u_{i,j} + h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + \\frac{h^3}{6} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + O(h^4)\n$$\n$$\nu(x_i-h, y_j) = u_{i,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{i,j} + \\frac{h^2}{2} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} - \\frac{h^3}{6} \\left(\\frac{\\partial^3 u}{\\partial x^3}\\right)_{i,j} + O(h^4)\n$$\n将这两个展开式相加可以消去奇数阶导数项：\n$$\nu_{i+1,j} + u_{i-1,j} = 2u_{i,j} + h^2 \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} + O(h^4)\n$$\n求解二阶导数，我们得到二阶精确的中心差分近似：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{i,j} = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + O(h^2)\n$$\n同理，沿 $y$ 方向的二阶导数近似为：\n$$\n\\left(\\frac{\\partial^2 u}{\\partial y^2}\\right)_{i,j} = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} + O(h^2)\n$$\n将这些代入拉普拉斯方程 $\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0$ 得到内部节点的离散方程：\n$$\n\\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} + \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} = 0\n$$\n两边乘以 $h^2$，我们得到著名的离散拉普拉斯算子的五点格式：\n$$\nu_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0\n$$\n\n2. 诺伊曼边界条件离散化\n\n问题要求对法向导数 $\\frac{\\partial u}{\\partial n} = g(x,y)$ 使用二阶精确的单边近似。我们以为 $x=1$ 的右边界（即节点 $(N-1, j)$）推导该公式，其中外法线方向为 $+x$ 方向，因此 $\\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial x}$。我们必须构建一个涉及边界节点 $u_{N-1,j}$ 以及沿内法线方向的两个相邻内部节点 $u_{N-2,j}$ 和 $u_{N-3,j}$ 的线性关系。\n\n我们写出 $u_{N-2,j}$ 和 $u_{N-3,j}$ 在边界节点 $(x_{N-1}, y_j)$ 处的泰勒展开：\n$$\nu_{N-2,j} = u(x_{N-1}-h, y_j) = u_{N-1,j} - h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + \\frac{h^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{N-1,j} + O(h^3)\n$$\n$$\nu_{N-3,j} = u(x_{N-1}-2h, y_j) = u_{N-1,j} - 2h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + \\frac{(2h)^2}{2!} \\left(\\frac{\\partial^2 u}{\\partial x^2}\\right)_{N-1,j} + O(h^3)\n$$\n我们构造一个线性组合 $A u_{N-2,j} + B u_{N-3,j}$ 来消除二阶导数项 $\\frac{\\partial^2 u}{\\partial x^2}$。我们需要 $A \\frac{h^2}{2} + B \\frac{4h^2}{2} = 0$，这意味着 $A + 4B = 0$。选择 $A=4$ 和 $B=-1$ 可得：\n$$\n4 u_{N-2,j} - u_{N-3,j} = (4-1) u_{N-1,j} + (-4h+2h) \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + O(h^3)\n$$\n$$\n4 u_{N-2,j} - u_{N-3,j} = 3 u_{N-1,j} - 2h \\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} + O(h^3)\n$$\n求解一阶导数，得到二阶精确的单边有限差分公式：\n$$\n\\left(\\frac{\\partial u}{\\partial x}\\right)_{N-1,j} = \\frac{3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j}}{2h} + O(h^2)\n$$\n给定诺伊曼条件 $\\frac{\\partial u}{\\partial x}|_{N-1,j} = g_{N-1,j}$，该边界节点的离散方程变为：\n$$\n3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j} = 2h g_{N-1,j}\n$$\n考虑到外法线的方向，为其他三个边界推导出类似的公式：\n- 左边界 ($i=0, \\frac{\\partial u}{\\partial n} = -\\frac{\\partial u}{\\partial x} = g$): $3u_{0,j} - 4u_{1,j} + u_{2,j} = 2h g_{0,j}$\n- 底边界 ($j=0, \\frac{\\partial u}{\\partial n} = -\\frac{\\partial u}{\\partial y} = g$): $3u_{i,0} - 4u_{i,1} + u_{i,2} = 2h g_{i,0}$\n- 顶边界 ($j=N-1, \\frac{\\partial u}{\\partial n} = \\frac{\\partial u}{\\partial y} = g$): $3u_{i,N-1} - 4u_{i,N-2} + u_{i,N-3} = 2h g_{i,N-1}$\n\n系统组装与求解\n\n所有 $N^2$ 个节点的离散方程构成一个大型线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u}$ 是一个包含所有未知值 $u_{i,j}$ 的向量。我们将二维网格索引 $(i,j)$ 映射到一维向量索引 $k = j \\times N + i$。矩阵 $A$ 和向量 $\\mathbf{b}$ 逐行构建，每个网格节点 $k$ 对应一行：\n\n1.  **内部节点 $(i,j)$**：方程为 $u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j} = 0$。对应的矩阵行 $k$ 的主对角线元素 ($A_{k,k}$) 系数为 $-4$，而对应其四个邻居的列的系数为 $1$。右侧项 $b_k$ 为 $0$。\n\n2.  **狄利克雷边界节点 $(i,j)$**：条件是 $u_{i,j} = d_{i,j}$。这被直接强制执行。矩阵行 $k$ 成为一个单位行：$A_{k,k} = 1$，所有其他 $A_{k,m}=0$，且 $b_k = d_{i,j}$。\n\n3.  **诺伊曼边界节点 $(i,j)$**：方程是上面推导的单边格式之一。对于右边界上的一个节点，使用方程 $3u_{N-1,j} - 4u_{N-2,j} + u_{N-3,j} = 2h g_{N-1,j}$。对应于 $(N-1, j)$ 的矩阵行 $k$ 将在映射到 $(N-1,j), (N-2,j), (N-3,j)$ 的列上分别具有系数 $3, -4, 1$。右侧项为 $b_k = 2h g_{N-1,j}$。\n\n4.  **角节点**：问题指定角节点总是从精确解 $u^\\star$ 中获取狄利克雷值。这是狄利克雷边界条件的一个特例，对于消除歧义至关重要，特别是当两个诺伊曼边界在一个角点相遇时。\n\n得到的线性系统是大型稀疏的。为提高效率，它使用稀疏矩阵格式（例如 `scipy.sparse.lil_matrix`）构建，并使用直接稀疏求解器（`scipy.sparse.linalg.spsolve`）求解。求解向量 $\\mathbf{u}$ 后，将其重塑回一个 $N \\times N$ 的网格，代表数值解 $u_{i,j}^{\\text{num}}$。然后将此解与网格上的精确解 $u^\\star(x_i, y_j)$进行比较，以计算最大绝对误差 $E_\\infty = \\max_{i,j} |u_{i,j}^{\\text{num}} - u^\\star(x_i, y_j)|$。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\n\ndef solve_laplace_2d(N, u_star, bc_config):\n    \"\"\"\n    Solves the 2D Laplace equation on a unit square using a second-order\n    finite difference method with mixed Dirichlet/Neumann boundary conditions.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    num_unknowns = N * N\n    \n    # Initialize sparse matrix A and vector b\n    A = lil_matrix((num_unknowns, num_unknowns))\n    b = np.zeros(num_unknowns)\n    \n    # Create coordinate grids\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n    \n    for j in range(N):\n        for i in range(N):\n            k = j * N + i  # Row-major mapping from (i, j) to k\n            x, y = x_coords[i], y_coords[j]\n            \n            # 1. Corner nodes (always Dirichlet from exact solution)\n            is_corner = (i == 0 or i == N - 1) and (j == 0 or j == N - 1)\n            if is_corner:\n                A[k, k] = 1.0\n                b[k] = u_star(x, y)\n                continue\n\n            # 2. Boundary nodes (not corners)\n            side_name = None\n            s_coord = -1.0\n            if i == 0:\n                side_name, s_coord = 'left', y\n            elif i == N - 1:\n                side_name, s_coord = 'right', y\n            elif j == 0:\n                side_name, s_coord = 'bottom', x\n            elif j == N - 1:\n                side_name, s_coord = 'top', x\n\n            if side_name:\n                segments = bc_config[side_name]\n                bc_type, bc_value_func = None, None\n                \n                # Find the correct piecewise segment for this node\n                for seg_s_max, seg_type, seg_func in segments:\n                    # The condition handles intervals like [0, 0.4] and (0.4, 1.0].\n                    # A small tolerance is added for floating point comparison.\n                    if s_coord = seg_s_max + 1e-9:\n                        bc_type = seg_type\n                        bc_value_func = seg_func\n                        break\n                \n                if bc_type == 'D': # Dirichlet condition\n                    A[k, k] = 1.0\n                    b[k] = bc_value_func(x, y)\n                elif bc_type == 'N': # Neumann condition\n                    g_val = bc_value_func(x, y)\n                    if side_name == 'left': # d/dn = -d/dx = g -> 3u_0 - 4u_1 + u_2 = 2hg\n                        A[k, j * N + 0] = 3.0\n                        A[k, j * N + 1] = -4.0\n                        A[k, j * N + 2] = 1.0\n                        b[k] = 2.0 * h * g_val\n                    elif side_name == 'right': # d/dn = d/dx = g -> 3u_{N-1} - 4u_{N-2} + u_{N-3} = 2hg\n                        A[k, j * N + (N - 1)] = 3.0\n                        A[k, j * N + (N - 2)] = -4.0\n                        A[k, j * N + (N - 3)] = 1.0\n                        b[k] = 2.0 * h * g_val\n                    elif side_name == 'bottom': # d/dn = -d/dy = g -> 3u_0 - 4u_1 + u_2 = 2hg\n                        A[k, (0 * N) + i] = 3.0\n                        A[k, (1 * N) + i] = -4.0\n                        A[k, (2 * N) + i] = 1.0\n                        b[k] = 2.0 * h * g_val\n                    elif side_name == 'top': # d/dn = d/dy = g -> 3u_{N-1} - 4u_{N-2} + u_{N-3} = 2hg\n                        A[k, ((N - 1) * N) + i] = 3.0\n                        A[k, ((N - 2) * N) + i] = -4.0\n                        A[k, ((N - 3) * N) + i] = 1.0\n                        b[k] = 2.0 * h * g_val\n                continue\n\n            # 3. Interior nodes\n            A[k, k] = -4.0\n            A[k, k - 1] = 1.0  # u_{i-1, j}\n            A[k, k + 1] = 1.0  # u_{i+1, j}\n            A[k, k - N] = 1.0  # u_{i, j-1}\n            A[k, k + N] = 1.0  # u_{i, j+1}\n            b[k] = 0.0\n\n    # Solve the linear system\n    A_csc = A.tocsc()\n    u_vec = spsolve(A_csc, b)\n    u_numerical = u_vec.reshape((N, N))\n\n    # Calculate exact solution and error\n    u_exact_grid = np.zeros((N, N))\n    for j in range(N):\n        for i in range(N):\n            u_exact_grid[j, i] = u_star(x_coords[i], y_coords[j])\n            \n    max_error = np.max(np.abs(u_numerical - u_exact_grid))\n    return max_error\n\n\ndef solve():\n    # Test case A (general mixed, smooth polynomial)\n    N_A = 51\n    u_star_A = lambda x, y: x**2 - y**2\n    u_dy_A = lambda x, y: -2*y\n    bc_A = {\n        'left':   [(1.0, 'D', lambda x, y: u_star_A(0, y))],\n        'right':  [(1.0, 'D', lambda x, y: u_star_A(1, y))],\n        'bottom': [(1.0, 'N', lambda x, y: -u_dy_A(x, 0))],\n        'top':    [(1.0, 'N', lambda x, y: u_dy_A(x, 1))]\n    }\n    case_A = (N_A, u_star_A, bc_A)\n\n    # Test case B (piecewise mix on a side)\n    N_B = 51\n    u_star_B = lambda x, y: x\n    u_dx_B = lambda x, y: 1.0\n    u_dy_B = lambda x, y: 0.0\n    bc_B = {\n        'left':   [(1.0, 'D', lambda x, y: u_star_B(0, y))],\n        'right':  [(1.0, 'N', lambda x, y: u_dx_B(1, y))],\n        'bottom': [(1.0, 'D', lambda x, y: u_star_B(x, 0))],\n        'top':    [(0.4, 'N', lambda x, y: u_dy_B(x, 1)),\n                   (1.0, 'D', lambda x, y: u_star_B(x, 1))]\n    }\n    case_B = (N_B, u_star_B, bc_B)\n\n    # Test case C (edge case with small grid and homogeneous Neumann)\n    N_C = 9\n    u_star_C = lambda x, y: y\n    u_dx_C = lambda x, y: 0.0\n    u_dy_C = lambda x, y: 1.0\n    bc_C = {\n        'left':   [(1.0, 'N', lambda x, y: -u_dx_C(0, y))],\n        'right':  [(1.0, 'N', lambda x, y: u_dx_C(1, y))],\n        'bottom': [(1.0, 'D', lambda x, y: u_star_C(x, 0))],\n        'top':    [(1.0, 'D', lambda x, y: u_star_C(x, 1))]\n    }\n    case_C = (N_C, u_star_C, bc_C)\n    \n    test_cases = [case_A, case_B, case_C]\n    \n    results = []\n    for case in test_cases:\n        error = solve_laplace_2d(*case)\n        results.append(f\"{error:.8f}\")\n        \n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2406696"}]}