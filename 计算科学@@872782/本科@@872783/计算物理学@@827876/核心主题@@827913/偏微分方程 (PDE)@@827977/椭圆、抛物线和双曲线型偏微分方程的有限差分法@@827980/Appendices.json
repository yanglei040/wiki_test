{"hands_on_practices": [{"introduction": "这项实践是关于数值精度的基础练习。我们将使用标准的5点格式和更复杂的高阶9点格式来求解作为椭圆型偏微分方程基石的二维泊松方程。通过将数值解与已知的解析解进行误差比较，你将直接观察到增加格式的复杂性如何显著提高收敛速度，这是选择高效数值方法的一个关键概念。[@problem_id:2393516]", "problem": "考虑在单位正方形域上的二维泊松方程，其带有齐次狄利克雷边界条件。设开域为 $\\Omega = (0,1)\\times(0,1)$，边界为 $\\partial\\Omega$。定义精确解为 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$，其中 $(x,y)\\in \\overline{\\Omega}$。该解是解析且非多项式的。源项由控制方程 $-\\Delta u = f$（在 $\\Omega$ 内）确定，且在 $\\partial\\Omega$ 上满足 $u = 0$。\n\na) 根据 $u(x,y)$ 的定义和等式 $-\\Delta u = f$ 推导出 $f(x,y)$ 的闭合形式表达式。\n\nb) 对于一个均匀笛卡尔网格，每个坐标方向有 $m$ 个等间距的子区间，定义网格间距 $h = 1/m$ 和网格节点 $(x_i,y_j) = (i h, j h)$，其中 $i,j\\in\\{0,1,\\dots,m\\}$。通过在 $\\partial\\Omega$ 上的狄利克雷条件 $u(x,y)=0$ 来施加边界值，精确解 $u$ 满足该条件。对于内部节点，使用以下两种离散算子在内部节点 $(i,j)$ 处构建与 $-\\Delta u = f$ 对应的离散线性系统：\n- 标准的二阶 $5$ 点模板，\n$$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)。$$\n- 经典的四阶 $9$ 点模板，\n$$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)。$$\n\nc) 对于每个选定的 $m$，令 $u_h^{(5)}$ 和 $u_h^{(9)}$ 分别表示通过求解相应离散系统得到的网格上的数值解，其中右端项在内部节点处设为 $f(x_i,y_j)$。通过将边界值设置为精确解 $u(x_i,y_j)$，并将内部值设置为相应的数值解，来构建完整的网格函数。定义网格函数 $w$ 相对于精确解 $u$ 的离散均方根误差（离散 $L^2$ 近似）为\n$$E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}。$$\n令 $E^{(5)}(h)$ 和 $E^{(9)}(h)$ 分别表示 $5$ 点和 $9$ 点解的这些误差。\n\nd) 对于每对连续的网格间距 $(h, h/2)$，定义以 $2$ 为底的观测收敛率为\n$$p^{(5)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(5)}(h)}{E^{(5)}(h/2)}\\right),\\qquad p^{(9)}(h\\to h/2) = \\log_2\\left(\\frac{E^{(9)}(h)}{E^{(9)}(h/2)}\\right)。$$\n\n使用以下子区间数量的测试集：$m\\in\\{2,4,8,16\\}$。对于每个 $m$，使用 $u$ 的定义计算 $f$ 并在 $\\partial\\Omega$ 上强制施加边界条件 $u=0$。对于成对的网格加密 $(m,m') = (2,4)$、$(4,8)$ 和 $(8,16)$，计算相应的观测收敛率。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$。\n\n所有数值必须以浮点数形式报告。不涉及物理单位。如果出现角度，必须以弧度为单位。最终输出格式必须与规范完全匹配：单行输出，列表用方括号括起，值用逗号分隔。", "solution": "问题陈述经过严格验证。\n\n步骤 1：提取的已知条件\n-   **控制方程**：在开放单位正方形域 $\\Omega = (0,1)\\times(0,1)$ 上的二维泊松方程 $-\\Delta u = f$。\n-   **边界条件 (BC)**：齐次狄利克雷边界条件，$u = 0$ 在边界 $\\partial\\Omega$ 上。\n-   **精确解**：$u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$，其中 $(x,y)\\in \\overline{\\Omega} = [0,1]\\times[0,1]$。\n-   **源项**：由等式 $f = -\\Delta u$ 定义。\n-   **离散化**：一个均匀笛卡尔网格，每个方向有 $m$ 个子区间，得到网格间距 $h = 1/m$ 和节点 $(x_i,y_j) = (ih, jh)$，其中 $i,j\\in\\{0,1,\\dots,m\\}$。\n-   **离散算子**：\n    -   标准二阶 $5$ 点负拉普拉斯算子模板：$\\left(-\\Delta_h^{(5)} u\\right)_{i,j} \\equiv \\frac{1}{h^2}\\left(4\\,u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\\right)$。\n    -   经典四阶 $9$ 点负拉普拉斯算子模板：$\\left(-\\Delta_h^{(9)} u\\right)_{i,j} \\equiv \\frac{1}{6h^2}\\Big(20\\,u_{i,j} - 4\\left(u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1}\\right) - \\left(u_{i+1,j+1} + u_{i-1,j+1} + u_{i+1,j-1} + u_{i-1,j-1}\\right)\\Big)$。\n-   **数值解**：$u_h^{(5)}$ 和 $u_h^{(9)}$ 是由模板产生的离散线性系统的解。右端项是内部节点上的 $f(x_i,y_j)$。边界值设为 $u(x_i,y_j)=0$。\n-   **误差度量**：离散均方根误差 $E(h; w) = \\left(h^2 \\sum_{i=0}^{m}\\sum_{j=0}^{m} \\left(w_{i,j} - u(x_i,y_j)\\right)^2\\right)^{1/2}$。\n-   **收敛率**：观测到的以 $2$ 为底的收敛率 $p(h\\to h/2) = \\log_2\\left(\\frac{E(h)}{E(h/2)}\\right)$。\n-   **测试参数**：子区间数量 $m\\in\\{2,4,8,16\\}$。\n-   **要求输出**：一个数值列表：$[E^{(5)}(1/2), E^{(9)}(1/2), p^{(5)}(1/2\\to 1/4), p^{(9)}(1/2\\to 1/4), p^{(5)}(1/4\\to 1/8), p^{(9)}(1/4\\to 1/8), p^{(5)}(1/8\\to 1/16), p^{(9)}(1/8\\to 1/16)]$。\n\n步骤 2：使用提取的已知条件进行验证\n该问题是偏微分方程数值分析中的一个标准练习，特别是有限差分法在泊松方程上的应用。\n-   **科学依据**：该问题基于数值分析和偏微分方程的既定数学原理。泊松方程、有限差分模板和收敛性分析都是基础且被充分理解的概念。\n-   **适定性**：带狄利克雷边界条件的泊松方程是适定椭圆问题的经典例子。两种模板产生的离散线性系统都对应于对称正定矩阵，保证了唯一解的存在。\n-   **客观性**：问题以精确、客观的数学语言陈述。\n-   **一致性检查**：给定的精确解 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ 正确地满足了在 $\\partial\\Omega$ 上的齐次狄利克雷边界条件 $u=0$，因为当 $x=0,1$ 时 $\\sin(\\pi x) = 0$，当 $y=0,1$ 时 $\\sin(\\pi y)=0$。\n-   **完整性**：提供了构建和解决问题所需的所有必要信息。\n\n步骤 3：结论与行动\n该问题是有效的。它在科学上是合理的、适定的和自洽的。将提供一个完整的解决方案。\n\n**a 部分) 源项 $f(x,y)$ 的推导**\n\n源项 $f(x,y)$ 由关系式 $f = -\\Delta u = -(\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2})$ 确定。我们计算精确解 $u(x,y) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y)$ 的二阶偏导数。\n\n首先，关于 $x$ 的偏导数：\n$$ \\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) \\right) = \\mathrm{e}^{x+y}\\sin(\\pi x)\\sin(\\pi y) + \\pi \\mathrm{e}^{x+y}\\cos(\\pi x)\\sin(\\pi y) $$\n关于 $x$ 的二阶偏导数：\n$$ \\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial}{\\partial x} \\left( \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) \\right) \\\\ = \\mathrm{e}^{x+y}(\\sin(\\pi x) + \\pi\\cos(\\pi x))\\sin(\\pi y) + \\mathrm{e}^{x+y}(\\pi\\cos(\\pi x) - \\pi^2\\sin(\\pi x))\\sin(\\pi y) \\\\ = \\mathrm{e}^{x+y}\\sin(\\pi y) \\left[ (1-\\pi^2)\\sin(\\pi x) + 2\\pi\\cos(\\pi x) \\right] $$\n由于 $u(x,y)$ 在交换 $x$ 和 $y$ 时具有对称性，关于 $y$ 的二阶偏导数是类似的：\n$$ \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y}\\sin(\\pi x) \\left[ (1-\\pi^2)\\sin(\\pi y) + 2\\pi\\cos(\\pi y) \\right] $$\n拉普拉斯算子 $\\Delta u$ 是这些二阶导数之和：\n$$ \\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\mathrm{e}^{x+y} \\left[ 2(1-\\pi^2)\\sin(\\pi x)\\sin(\\pi y) + 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\n最后，源项为 $f(x,y) = -\\Delta u$：\n$$ f(x,y) = \\mathrm{e}^{x+y} \\left[ 2(\\pi^2-1)\\sin(\\pi x)\\sin(\\pi y) - 2\\pi(\\cos(\\pi x)\\sin(\\pi y) + \\sin(\\pi x)\\cos(\\pi y)) \\right] $$\n这就是所要求的闭合形式表达式。\n\n**b, c, d 部分) 数值解与分析**\n\n该问题要求解线性系统 $A \\mathbf{u}_h = \\mathbf{b}$，以获得 $(m-1)^2$ 个内部网格点上数值解的未知值。向量 $\\mathbf{u}_h$ 包含 $i,j \\in \\{1, \\dots, m-1\\}$ 的值 $u_{i,j}$，并按字典序（列主序）排列。矩阵 $A$ 表示离散的负拉普拉斯算子，向量 $\\mathbf{b}$ 包含内部点上源项 $f(x_i, y_j)$ 的值。\n\n对于 $5$ 点模板，对应于 $(-\\Delta_h^{(5)})$ 的矩阵 $A_5$ 可以使用克罗内克积 (Kronecker product) 构建。设 $T_{1D}$ 是表示一维二阶导数算子 $-\\frac{d^2}{dx^2}$ 的 $(m-1) \\times (m-1)$ 矩阵，由 $T_{1D} = \\frac{1}{h^2} \\text{tridiag}(-1, 2, -1)$ 给出。设 $I$ 是 $(m-1) \\times (m-1)$ 的单位矩阵。那么，二维算子的矩阵是：\n$$ A_5 = I \\otimes T_{1D} + T_{1D} \\otimes I $$\n\n对于 $9$ 点模板，对应于 $(-\\Delta_h^{(9)})$ 的矩阵 $A_9$ 具有块三对角结构 $A_9 = \\text{block_tridiag}(B, D, B)$，其中块 $D$ 和 $B$ 是 $(m-1) \\times (m-1)$ 的矩阵：\n$$ D = \\frac{1}{6h^2} \\text{tridiag}(-4, 20, -4) $$\n$$ B = \\frac{1}{6h^2} \\text{tridiag}(-1, -4, -1) $$\n这种结构源于模板系数，这些系数耦合了同一网格行内的节点（矩阵 $D$）以及相邻网格行之间的节点（矩阵 $B$）。\n\n对于每个 $m \\in \\{2, 4, 8, 16\\}$，数值计算过程如下：\n1.  设置网格间距 $h=1/m$ 并定义网格坐标。\n2.  构建大小为 $(m-1)^2 \\times (m-1)^2$ 的稀疏矩阵 $A_5$ 和 $A_9$。\n3.  通过在 $(m-1)^2$ 个内部网格点上计算 $f(x_i, y_j)$ 来构建右端向量 $\\mathbf{b}$。\n4.  求解两个线性系统 $A_5 \\mathbf{u}_h^{(5)} = \\mathbf{b}$ 和 $A_9 \\mathbf{u}_h^{(9)} = \\mathbf{b}$ 以获得内部点上的数值解。\n5.  通过将内部解嵌入到一个零值网格中，形成完整的 $(m+1) \\times (m+1)$ 网格解 $u_h^{(5)}$ 和 $u_h^{(9)}$，这正确地表示了齐次边界条件。\n6.  在完整网格上计算精确解 $u(x,y)$。\n7.  使用指定公式计算离散均方根误差 $E^{(5)}(h)$ 和 $E^{(9)}(h)$。对每个 $m$ 值存储这些误差。\n8.  在计算完所有 $m$ 的误差后，使用给定的对数公式为每个加密级别计算观测收敛率 $p^{(5)}$ 和 $p^{(9)}$。\n\n对于二阶 $5$ 点模板，预期的收敛率是 $p \\approx 2$；对于四阶 $9$ 点模板，预期的收敛率是 $p \\approx 4$，因为这些分别是相应离散化的理论精度阶数。该数值实验旨在验证这一理论行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the 2D Poisson equation on a unit square using 5-point and 9-point\n    finite difference stencils and computes errors and convergence rates.\n    \"\"\"\n    m_values = [2, 4, 8, 16]\n    errors = {'5': {}, '9': {}}\n\n    def u_exact_func(x, y):\n        \"\"\"Computes the exact solution u(x,y).\"\"\"\n        return np.exp(x + y) * np.sin(np.pi * x) * np.sin(np.pi * y)\n\n    def f_func(x, y):\n        \"\"\"Computes the source term f(x,y) = -Delta u.\"\"\"\n        term1 = 2 * (np.pi**2 - 1) * np.sin(np.pi * x) * np.sin(np.pi * y)\n        term2 = -2 * np.pi * (np.cos(np.pi * x) * np.sin(np.pi * y) + np.sin(np.pi * x) * np.cos(np.pi * y))\n        return np.exp(x + y) * (term1 + term2)\n\n    for m in m_values:\n        h = 1.0 / m\n        N = m - 1  # Number of interior grid points in one dimension\n\n        # Create the full grid\n        grid_pts = np.linspace(0, 1, m + 1)\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='ij')\n\n        # Evaluate exact solution on the full grid\n        u_exact_grid = u_exact_func(X, Y)\n\n        if N == 0: # Trivial case with no interior points\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n        else:\n            N2 = N * N # Total number of unknowns\n\n            # Interior grid points and RHS vector b\n            interior_grid_pts = np.linspace(h, 1 - h, N)\n            XI, YI = np.meshgrid(interior_grid_pts, interior_grid_pts, indexing='ij')\n            # Use Fortran ordering for flattening to match lexicographical (column-major) order\n            b = f_func(XI, YI).flatten(order='F')\n\n            # --- 5-point stencil system ---\n            # A_5 = I kron T + T kron I for -Delta\n            T_1d = sparse.diags([-1, 2, -1], [-1, 0, 1], shape=(N, N))\n            I_n = sparse.eye(N)\n            A5 = (1 / h**2) * (sparse.kron(I_n, T_1d) + sparse.kron(T_1d, I_n))\n            \n            u_sol_5_flat = spsolve(A5.tocsc(), b)\n            u_sol_5 = np.zeros_like(u_exact_grid)\n            u_sol_5[1:-1, 1:-1] = u_sol_5_flat.reshape((N, N), order='F')\n\n            # --- 9-point stencil system ---\n            # Block-tridiagonal construction A_9 = block_tridiag(B, D, B)\n            D_diag_vals = [np.full(N - 1, -4), np.full(N, 20), np.full(N - 1, -4)]\n            D = (1 / (6 * h**2)) * sparse.diags(D_diag_vals, [-1, 0, 1])\n\n            B_diag_vals = [np.full(N - 1, -1), np.full(N, -4), np.full(N - 1, -1)]\n            B = (1 / (6 * h**2)) * sparse.diags(B_diag_vals, [-1, 0, 1])\n            \n            # Off-diagonal blocks for Kronecker sum\n            off_diag_block_matrix = sparse.diags([1, 1], [-1, 1], shape=(N, N))\n            A9 = sparse.kron(I_n, D) + sparse.kron(off_diag_block_matrix, B)\n            \n            u_sol_9_flat = spsolve(A9.tocsc(), b)\n            u_sol_9 = np.zeros_like(u_exact_grid)\n            u_sol_9[1:-1, 1:-1] = u_sol_9_flat.reshape((N, N), order='F')\n\n        # Compute discrete RMS error: E = sqrt(h^2 * sum((w-u)^2))\n        # This is equivalent to h * Frobenius_norm(w-u)\n        diff_5 = u_sol_5 - u_exact_grid\n        errors['5'][m] = h * np.sqrt(np.sum(diff_5**2))\n\n        diff_9 = u_sol_9 - u_exact_grid\n        errors['9'][m] = h * np.sqrt(np.sum(diff_9**2))\n\n    # Calculate convergence rates and assemble final results\n    results = []\n    \n    # E(h=1/2) for m=2\n    results.append(errors['5'][2])\n    results.append(errors['9'][2])\n\n    # p(1/2 - 1/4) for m=2,4\n    results.append(np.log2(errors['5'][2] / errors['5'][4]))\n    results.append(np.log2(errors['9'][2] / errors['9'][4]))\n\n    # p(1/4 - 1/8) for m=4,8\n    results.append(np.log2(errors['5'][4] / errors['5'][8]))\n    results.append(np.log2(errors['9'][4] / errors['9'][8]))\n\n    # p(1/8 - 1/16) for m=8,16\n    results.append(np.log2(errors['5'][8] / errors['5'][16]))\n    results.append(np.log2(errors['9'][8] / errors['9'][16]))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393516"}, {"introduction": "真实的物理问题常常涉及具有不同属性的多种材料。本实践将探讨如何在偏微分方程中处理不连续系数，这是热传导或静电学中的常见情景。你将为一个具有热导率阶跃的一维稳态热方程实现一个守恒的有限差分格式，并发现界面处的数值处理方式如何关键性地影响解的整体精度。[@problem_id:2393520]", "problem": "考虑一个一维稳态热传导问题，其热导率在材料界面上存在不连续性。设区域为闭区间 $[0,1]$，界面位置为 $x_{\\mathrm{I}}=\\tfrac{1}{2}$。热导率 $k(x)$ 是分段常数且右连续的，定义为\n$$\nk(x) = \\begin{cases}\nk_1,  x  x_{\\mathrm{I}},\\\\\nk_2,  x \\ge x_{\\mathrm{I}}.\n\\end{cases}\n$$\n温度 $u(x)$ 满足以下边值问题\n$$\n- \\dfrac{\\mathrm{d}}{\\mathrm{d}x}\\left( k(x)\\, \\dfrac{\\mathrm{d}u}{\\mathrm{d}x}(x) \\right) = 1 \\quad \\text{for } x \\in (0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\n并且在界面 $x=x_{\\mathrm{I}}$ 处，精确解具有温度连续和热通量连续的特性，\n$$\nu(x_{\\mathrm{I}}^-)=u(x_{\\mathrm{I}}^+), \\qquad k_1\\, u'(x_{\\mathrm{I}}^-)=k_2\\, u'(x_{\\mathrm{I}}^+).\n$$\n在一个具有 $N$ 个子区间的均匀网格上，网格间距为 $h=1/N$，网格点为 $x_i=i\\,h$（$i=0,1,\\dots,N$），令 $u_i$ 表示 $u(x_i)$ 的近似值。根据右连续规则定义节点热导率 $k_i := k(x_i)$，并用算术平均值定义面心热导率 $k_{i+\\tfrac{1}{2}} := \\tfrac{1}{2}\\big(k_i+k_{i+1}\\big)$。对于 $i=1,2,\\dots,N-1$ 的离散内部方程由守恒中心有限差分格式指定\n$$\n-\\frac{1}{h}\\left( k_{i+\\tfrac{1}{2}}\\, \\frac{u_{i+1}-u_i}{h} - k_{i-\\tfrac{1}{2}}\\, \\frac{u_i-u_{i-1}}{h} \\right) = 1,\n$$\n并精确施加边界值 $u_0=0$ 和 $u_N=0$。\n\n需要执行的任务：\n\n1) 对于给定的 $(k_1,k_2,N)$，根据离散方程计算数值解 $\\{u_i\\}_{i=0}^N$。定义最大范数节点误差\n$$\nE(N;k_1,k_2) := \\max_{0 \\le i \\le N} \\left| u_i - u(x_i) \\right|,\n$$\n其中 $u(x)$ 是在每个材料区域 $j\\in\\{1,2\\}$ 中满足 $-k_j\\,u''(x)=1$ 以及上述边界和界面条件的精确解。\n\n2) 对于一对网格 $N_{\\mathrm{c}}, N_{\\mathrm{f}}$，定义观测到的精度阶\n$$\np := \\frac{\\log\\left( E(N_{\\mathrm{c}};k_1,k_2) / E(N_{\\mathrm{f}};k_1,k_2)\\right)}{\\log\\left(N_{\\mathrm{f}}/N_{\\mathrm{c}}\\right)}.\n$$\n\n您的程序必须为以下测试套件中的每个参数集计算 $p$，其中每个案例都使用 $x_{\\mathrm{I}}=\\tfrac{1}{2}$，且 $N_{\\mathrm{c}}$ 和 $N_{\\mathrm{f}}$ 均为偶数：\n\n- 案例 1 (中等对比度)：$(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,2.0,64,128)$。\n- 案例 2 (高对比度，软到硬)：$(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,100.0,64,128)$。\n- 案例 3 (高对比度，硬到软)：$(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(100.0,1.0,64,128)$。\n- 案例 4 (无界面效应)：$(k_1,k_2,N_{\\mathrm{c}},N_{\\mathrm{f}})=(1.0,1.0,64,128)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含上述案例的四个 $p$ 值，按顺序排列，形式为用方括号括起来的逗号分隔列表。每个值必须打印为小数点后恰好有六位数字的十进制数。例如：`[p1,p2,p3,p4]`。", "solution": "所述问题是一个标准的、适定的一维稳态热传导两点边值问题，其系数为分段常数。该问题具有科学依据、内容自洽，并提出了一个清晰、客观的任务。因此，它适合进行分析。我们开始求解。\n\n求解过程需要两个主要部分：首先，推导精确的解析解作为基准；其次，实现并分析指定的有限差分格式。\n\n首先，我们确定精确解 $u(x)$。控制方程为 $-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\left( k(x)\\, \\frac{\\mathrm{d}u}{\\mathrm{d}x}(x) \\right) = 1$。该区域在界面 $x_{\\mathrm{I}}=\\tfrac{1}{2}$ 处被划分为两个区域。\n在区域 1 ($0 \\le x  \\tfrac{1}{2}$) 中，热导率为 $k(x)=k_1$，方程简化为 $-k_1 u_1''(x) = 1$。\n在区域 2 ($\\tfrac{1}{2} \\le x \\le 1$) 中，热导率为 $k(x)=k_2$，方程为 $-k_2 u_2''(x) = 1$。\n\n在每个区域中积分两次，得到关于 $x$ 的二次通解：\n对于区域 1：$u_1(x) = -\\frac{x^2}{2k_1} + A_1 x + B_1$。\n对于区域 2：$u_2(x) = -\\frac{x^2}{2k_2} + A_2 x + B_2$。\n四个积分常数 $A_1$、$B_1$、$A_2$ 和 $B_2$ 由四个给定条件确定：\n1. 在 $x=0$ 处的边界条件：$u_1(0)=0$。\n2. 在 $x=1$ 处的边界条件：$u_2(1)=0$。\n3. 在 $x=x_{\\mathrm{I}}$ 处的温度连续性：$u_1(x_{\\mathrm{I}}) = u_2(x_{\\mathrm{I}})$。\n4. 在 $x=x_{\\mathrm{I}}$ 处的热通量连续性：$k_1 u_1'(x_{\\mathrm{I}}) = k_2 u_2'(x_{\\mathrm{I}})$。\n\n系统地应用这些条件：\n由 $u_1(0)=0$ 可得 $B_1=0$。\n由 $k_1 u_1'(x_{\\mathrm{I}}) = k_2 u_2'(x_{\\mathrm{I}})$ 可得 $k_1(-\\frac{x_{\\mathrm{I}}}{k_1} + A_1) = k_2(-\\frac{x_{\\mathrm{I}}}{k_2} + A_2)$，简化后为 $k_1 A_1 = k_2 A_2$。\n剩下的两个条件构成了一个关于 $A_1$ 和 $B_2$（或 $A_1$ 和 $A_2$）的线性系统。代入 $x_{\\mathrm{I}} = \\tfrac{1}{2}$，我们求解此系统以求得这些常数：\n$$\nA_1 = \\frac{k_2+3k_1}{4k_1(k_1+k_2)}, \\qquad A_2 = \\frac{k_1}{k_2}A_1 = \\frac{k_2+3k_1}{4k_2(k_1+k_2)}\n$$\n$$\nB_1 = 0, \\qquad B_2 = \\frac{1}{2k_2} - A_2 = \\frac{k_2-k_1}{4k_2(k_1+k_2)}\n$$\n因此，精确解由以下分段函数给出：\n$$\nu(x) = \\begin{cases}\n    -\\dfrac{x^2}{2k_1} + \\dfrac{k_2+3k_1}{4k_1(k_1+k_2)} x  \\text{for } 0 \\le x  \\tfrac{1}{2} \\\\[1.5em]\n    -\\dfrac{x^2}{2k_2} + \\dfrac{k_2+3k_1}{4k_2(k_1+k_2)} x + \\dfrac{k_2-k_1}{4k_2(k_1+k_2)}  \\text{for } \\tfrac{1}{2} \\le x \\le 1\n\\end{cases}\n$$\n\n接下来，我们处理数值解。区域 $[0, 1]$ 被离散化为一个均匀网格，包含 $N$ 个宽度为 $h=1/N$ 的子区间。网格点为 $x_i = i h$（$i=0, 1, \\dots, N$）。指定的有限差分格式为：\n$$\n-\\frac{1}{h}\\left( k_{i+\\tfrac{1}{2}}\\, \\frac{u_{i+1}-u_i}{h} - k_{i-\\tfrac{1}{2}}\\, \\frac{u_i-u_{i-1}}{h} \\right) = 1, \\quad \\text{for } i=1, \\dots, N-1.\n$$\n整理后，我们得到每个内部节点 $i$ 的一个线性方程：\n$$\n-k_{i-\\tfrac{1}{2}} u_{i-1} + (k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}) u_i - k_{i+\\tfrac{1}{2}} u_{i+1} = h^2.\n$$\n这 $N-1$ 个方程与边界条件 $u_0=0$ 和 $u_N=0$ 一起，构成了一个关于未知向量 $\\mathbf{u} = (u_1, u_2, \\dots, u_{N-1})^T$ 的线性系统 $A\\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 是一个对称、正定、三对角的矩阵。面心热导率 $k_{i\\pm\\tfrac{1}{2}}$ 由节点热导率的算术平均值定义，$k_{i+\\tfrac{1}{2}} = \\tfrac{1}{2}(k_i + k_{i+1})$，其中 $k_i = k(x_i)$。由于 $N$ 是偶数，界面 $x_{\\mathrm{I}}=\\tfrac{1}{2}$ 与网格点 $x_{N/2}$ 重合。$k(x)$ 的右连续定义意味着 $k_{N/2} = k_2$，而 $k_{N/2-1} = k_1$。因此，穿过界面的面心热导率为 $k_{N/2 - \\tfrac{1}{2}} = \\tfrac{1}{2}(k_1+k_2)$。\n\n计算步骤如下：\n1. 对于给定的网格尺寸 $N$ 和热导率 $k_1, k_2$，定义节点热导率 $k_i$ 和面心热导率 $k_{i\\pm\\tfrac{1}{2}}$。\n2. 构建 $(N-1) \\times (N-1)$ 的三对角矩阵 $A$ 和大小为 $N-1$ 的右端向量 $\\mathbf{b}$，其所有元素均等于 $h^2$。\n3. 求解线性系统 $A\\mathbf{u} = \\mathbf{b}$ 以获得内部节点值 $u_1, \\dots, u_{N-1}$。使用专门的带状系统求解器可以高效完成此任务。\n4. 附加边界值 $u_0=0$ 和 $u_N=0$ 以构成完整的数值解向量 $\\{u_i\\}_{i=0}^N$。\n5. 在每个网格点 $x_i$ 处计算精确解 $u(x_i)$。\n6. 计算最大范数节点误差 $E(N;k_1,k_2) = \\max_{0 \\le i \\le N} | u_i - u(x_i) |$。\n7. 对粗网格 ($N=N_{\\mathrm{c}}$) 和细网格 ($N=N_{\\mathrm{f}}$) 重复步骤 1-6，以获得误差 $E_{\\mathrm{c}}$ 和 $E_{\\mathrm{f}}$。\n8. 使用公式 $p = \\log(E_{\\mathrm{c}}/E_{\\mathrm{f}}) / \\log(N_{\\mathrm{f}}/N_{\\mathrm{c}})$ 计算观测到的精度阶。\n\n必须指出，虽然对于光滑问题，该有限差分模板形式上是二阶精确的，但已知在材料界面处使用热导率的算术平均值会将全局精度降低到一阶 ($p \\approx 1$）。在 $k_1=k_2$ 的特殊情况下，不存在界面，问题是光滑的，应能恢复预期的二阶精度 ($p \\approx 2$）。数值实验将验证这一行为。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n\n    def get_exact_solution(x, k1, k2):\n        \"\"\"\n        Computes the exact analytical solution u(x) for the given problem.\n\n        Args:\n            x (np.ndarray): Array of spatial coordinates.\n            k1 (float): Thermal conductivity in the region x  0.5.\n            k2 (float): Thermal conductivity in the region x = 0.5.\n\n        Returns:\n            np.ndarray: The exact solution evaluated at points x.\n        \"\"\"\n        xI = 0.5\n        \n        # Handle the homogeneous case to avoid division by zero if k1+k2=0\n        if k1 + k2 == 0:\n            if k1 == 0 and k2 == 0: # Not a physically valid case, but handle numerically\n                return np.zeros_like(x, dtype=float)\n        \n        # Coefficients from analytical derivation\n        A1 = (k2 + 3.0 * k1) / (4.0 * k1 * (k1 + k2))\n        A2 = (k2 + 3.0 * k1) / (4.0 * k2 * (k1 + k2))\n        \n        u = np.zeros_like(x, dtype=float)\n        \n        # Define masks for the two material regions\n        mask1 = x = xI\n        mask2 = x  xI\n        \n        # Solution in the first region\n        u[mask1] = -x[mask1]**2 / (2.0 * k1) + A1 * x[mask1]\n        \n        # Solution in the second region can be written in a more stable form\n        # u(x) = (-x^2+1)/(2k2) + A2(x-1)\n        u[mask2] = -(x[mask2]**2 - 1.0) / (2.0 * k2) + A2 * (x[mask2] - 1.0)\n        \n        return u\n\n    def compute_error(N, k1, k2):\n        \"\"\"\n        Computes the numerical solution and its maximum-norm error against the exact solution.\n\n        Args:\n            N (int): Number of subintervals in the grid.\n            k1 (float): Thermal conductivity for x  0.5.\n            k2 (float): Thermal conductivity for x = 0.5.\n\n        Returns:\n            float: The maximum-norm error between numerical and exact solutions.\n        \"\"\"\n        h = 1.0 / N\n        x_grid = np.linspace(0.0, 1.0, N + 1)\n        \n        # Nodal conductivities k_i based on right-continuous k(x)\n        xI_idx = N // 2\n        k_nodal = np.full(N + 1, k1)\n        k_nodal[xI_idx:] = k2\n\n        # Face conductivities k_{i+1/2} using arithmetic mean\n        k_face = 0.5 * (k_nodal[:-1] + k_nodal[1:])\n\n        # Set up the tridiagonal system A*u = b for interior nodes u_1, ..., u_{N-1}\n        num_unknowns = N - 1\n        \n        # The banded matrix `ab` for scipy.linalg.solve_banded\n        # ab has l=1 lower diagonal, u=1 upper diagonal\n        ab = np.zeros((3, num_unknowns))\n        \n        # Main diagonal (row u=1)\n        ab[1, :] = k_face[1:N] + k_face[0:N-1]\n        \n        # Upper diagonal (row u-1=0), shifted\n        ab[0, 1:] = -k_face[1:N-1]\n\n        # Lower diagonal (row u+1=2), shifted\n        ab[2, :-1] = -k_face[1:N-1]\n        \n        # Right-hand side vector\n        b = np.full(num_unknowns, h**2)\n        \n        # Solve the linear system for interior nodes\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full numerical solution including boundaries\n        u_numerical = np.zeros(N + 1)\n        u_numerical[1:-1] = u_interior\n        \n        # Compute exact solution at grid points\n        u_exact = get_exact_solution(x_grid, k1, k2)\n        \n        # Calculate the maximum-norm nodal error\n        error = np.max(np.abs(u_numerical - u_exact))\n        return error\n\n    # -- Main execution --\n    \n    test_cases = [\n        # (k1, k2, Nc, Nf)\n        (1.0, 2.0, 64, 128),     # Case 1: moderate contrast\n        (1.0, 100.0, 64, 128),  # Case 2: high contrast, soft to hard\n        (100.0, 1.0, 64, 128),  # Case 3: high contrast, hard to soft\n        (1.0, 1.0, 64, 128),     # Case 4: no interface\n    ]\n\n    results = []\n    for k1, k2, Nc, Nf in test_cases:\n        # Calculate errors on coarse and fine grids\n        error_c = compute_error(Nc, k1, k2)\n        error_f = compute_error(Nf, k1, k2)\n        \n        # Compute the observed order of accuracy\n        # p = log(E_c / E_f) / log(N_f / N_c)\n        p = np.log(error_c / error_f) / np.log(Nf / Nc)\n        results.append(p)\n\n    # Format and print the final output as specified\n    print(f\"[{','.join([f'{p:.6f}' for p in results])}]\")\n\nsolve()\n```", "id": "2393520"}, {"introduction": "从稳态（椭圆型）问题转向随时间演化（抛物线型）的问题，边界条件的实现变得更加关键。在本练习中，你将求解带诺伊曼（通量）边界条件的一维热方程。通过使用“虚拟点”方法实现并比较一阶和二阶精度的边界封闭格式，你将亲身体会到边界处理的精度如何成为整个模拟收敛性的瓶颈。[@problem_id:2393512]", "problem": "考虑空间区间 $[0,1]$ 上的一维热传导方程（一种抛物型偏微分方程），\n$$\nu_t(x,t) = \\alpha \\, u_{xx}(x,t), \\quad x \\in [0,1], \\; t \\in [0,T],\n$$\n其中热扩散系数 $\\alpha  0$，服从诺伊曼边界条件\n$$\nu_x(0,t) = g_0(t), \\quad u_x(1,t) = g_1(t),\n$$\n以及初始条件\n$$\nu(x,0) = u_0(x).\n$$\n通过比较两种在空间一致性阶数上有所不同的诺伊曼边界条件的数学实现，研究不同的边界条件闭合格式如何影响总体精度。在所有内部网格点上，$u_{xx}$ 的内部空间离散必须采用标准的二阶中心有限差分，时间推进必须使用前向欧拉法。待比较的两种边界闭合格式为：\n\n1. 一阶一致的单边闭合格式（记为 $\\mathrm{FO}$）：在 $x=0$ 和 $x=1$ 处，使用一阶单边有限差分来施加诺伊曼边界条件以消除鬼点值，\n$$\n\\frac{u(x_0,t) - u(x_{-1},t)}{h} = g_0(t) \\Rightarrow u(x_{-1},t) = u(x_0,t) - h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_N,t)}{h} = g_1(t) \\Rightarrow u(x_{N+1},t) = u(x_N,t) + h\\, g_1(t),\n$$\n其中 $h$ 是空间步长，$x_i = i h$，$i=0,1,\\dots,N$，且 $N h = 1$，$x_{-1}$ 和 $x_{N+1}$ 是鬼点。\n\n2. 二阶一致的中心闭合格式（记为 $\\mathrm{SO}$）：在 $x=0$ 和 $x=1$ 处，使用中心有限差分来施加诺伊曼边界条件以消除鬼点值，\n$$\n\\frac{u(x_1,t) - u(x_{-1},t)}{2h} = g_0(t) \\Rightarrow u(x_{-1},t) = u(x_1,t) - 2 h\\, g_0(t),\n$$\n$$\n\\frac{u(x_{N+1},t) - u(x_{N-1},t)}{2h} = g_1(t) \\Rightarrow u(x_{N+1},t) = u(x_{N-1},t) + 2 h\\, g_1(t).\n$$\n\n在每个显式时间步，使用鬼点值通过与内部点相同的二阶中心差分公式来计算边界节点上的离散拉普拉斯算子。前向欧拉法的时间步长必须选择为\n$$\n\\Delta t = c \\, \\frac{h^2}{2 \\alpha},\n$$\n其中常数 $c = 0.45$ 固定不变，因此对于 $T  0$，时间步数取为与 $T / \\Delta t$ 最接近的整数，并调整最后一步的步长以确保最终时间恰好为 $T$。\n\n使用以下两种精确的人造解（本问题不涉及物理单位）：\n- 情况 A（非零诺伊曼通量）：取\n$$\nu(x,t) = \\sin(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\sin(\\pi x), \\quad g_0(t) = \\pi \\, e^{-\\alpha \\pi^2 t}, \\quad g_1(t) = -\\pi \\, e^{-\\alpha \\pi^2 t}.\n$$\n- 情况 B（齐次诺伊曼通量）：取\n$$\nu(x,t) = \\cos(\\pi x)\\, e^{-\\alpha \\pi^2 t}, \\quad u_0(x) = \\cos(\\pi x), \\quad g_0(t) = 0, \\quad g_1(t) = 0.\n$$\n\n固定参数 $\\alpha = 1$，$T = 0.1$。对于两种边界闭合格式 $\\mathrm{FO}$ 和 $\\mathrm{SO}$ 中的每一种，以及两种情况 A 和 B 中的每一种，计算在均匀网格（$N \\in \\{20, 40, 80, 160\\}$，因此 $h = 1/N$ 且网格点为 $x_i = i h$，$i = 0, 1, \\dots, N$）上 $T$ 时刻的离散 $L^2$ 误差。对于在这 4 次网格加密中收集到的误差序列 $E(h)$，将观测到的空间阶 $p$ 定义为 $\\log E$ 对 $\\log h$ 进行最小二乘拟合的斜率。\n\n您的程序必须：\n- 使用给定的 $\\Delta t$ 公式和二阶中心内部空间离散，实现前向欧拉时间积分。\n- 精确地实现所陈述的两种边界闭合格式 $\\mathrm{FO}$ 和 $\\mathrm{SO}$。\n- 对于每种情况（A 和 B）和每种边界闭合格式，通过对 $\\{(\\log h, \\log E(h))\\}$ 进行最小二乘法计算，从四网格误差序列中计算出观测阶 $p$。\n- 此外，报告在最细网格 $N=160$ 上，$\\mathrm{SO}$ 闭合格式是否比 $\\mathrm{FO}$ 闭合格式获得了更小的 $L^2$ 误差。\n\n测试套件和要求的输出：\n- 使用 $\\alpha = 1$，$T = 0.1$，$c = 0.45$ 以及 $N \\in \\{20, 40, 80, 160\\}$。\n- 按以下顺序生成六个输出：\n  1. 情况 A 使用 $\\mathrm{FO}$ 时的观测阶 $p$。\n  2. 情况 A 使用 $\\mathrm{SO}$ 时的观测阶 $p$。\n  3. 情况 B 使用 $\\mathrm{FO}$ 时的观测阶 $p$。\n  4. 情况 B 使用 $\\mathrm{SO}$ 时的观测阶 $p$。\n  5. 一个布尔值，指示在情况 A 的 $N=160$ 网格上，使用 $\\mathrm{SO}$ 的 $L^2$ 误差是否严格小于使用 $\\mathrm{FO}$ 的误差。\n  6. 一个布尔值，指示在情况 B 的 $N=160$ 网格上，使用 $\\mathrm{SO}$ 的 $L^2$ 误差是否严格小于使用 $\\mathrm{FO}$ 的误差。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含六个结果，以方括号括起来的逗号分隔列表形式，并严格按照上面列出的顺序。例如，输出如下：\n$$\n[\\;p\\_A^{\\mathrm{FO}},\\;p\\_A^{\\mathrm{SO}},\\;p\\_B^{\\mathrm{FO}},\\;p\\_B^{\\mathrm{SO}},\\;b\\_A,\\;b\\_B\\;]\n$$\n其中前四个条目是实数（浮点数），后两个条目是布尔值。不应打印任何其他文本。", "solution": "问题陈述已经过严格验证，并被确定为具有科学依据、适定且自洽的。它提出了一个标准的数值分析任务，涉及抛物型偏微分方程的有限差分方法。所有参数、方程和条件都已明确定义，构成了一个一致且可解的问题。我们继续进行解的推导和实现。\n\n该问题要求在区域 $x \\in [0,1]$ 和 $t \\in [0,T]$ 上模拟一维热传导方程 $u_t(x,t) = \\alpha \\, u_{xx}(x,t)$。我们在均匀网格上采用有限差分法，空间点为 $x_i = i h$（$i=0, 1, \\dots, N$），其中 $h=1/N$ 是空间步长。时间域被离散为大小为 $\\Delta t$ 的步长，即 $t_n = n \\Delta t$。设 $u_i^n$ 为精确解 $u(x_i, t_n)$ 的数值近似。\n\n时间导数 $u_t$ 使用一阶精度的前向欧拉法进行近似。空间二阶导数 $u_{xx}$ 使用二阶精度的中心差分格式进行近似。结合这些离散化，得到所有网格点 $i=0, \\dots, N$ 的更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\alpha \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{h^2}\n$$\n对 $u_i^{n+1}$ 进行整理，并引入网格傅里叶数 $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$，我们得到显式更新公式：\n$$\nu_i^{n+1} = u_i^n + \\lambda (u_{i+1}^n - 2u_i^n + u_{i-1}^n)\n$$\n此公式应用于所有内部点，$i = 1, \\dots, N-1$。对于边界点 $i=0$ 和 $i=N$，该公式需要“鬼点” $x_{-1} = -h$ 和 $x_{N+1} = 1+h$ 处的值。这些值 $u_{-1}^n$ 和 $u_{N+1}^n$ 是通过使用两种不同的有限差分闭合格式来施加诺伊曼边界条件 $u_x(0,t) = g_0(t)$ 和 $u_x(1,t) = g_1(t)$ 来确定的。\n\n问题指定了时间步长和空间步长之间的固定关系：$\\Delta t = c \\frac{h^2}{2 \\alpha}$，其中 $c = 0.45$。这得出 $\\lambda = c/2 = 0.225$，满足前向欧拉法的稳定性条件 $\\lambda \\le 1/2$。时间步数取为与 $T/\\Delta t$ 最接近的整数，然后调整 $\\Delta t$ 以确保最终时间恰好为 $T$。\n\n两种边界闭合格式如下：\n\n1.  **一阶 (FO) 闭合格式**：鬼点由诺伊曼条件的一阶精度单边差分近似确定，具体如下：\n    $$\n    u_{-1}^n = u_0^n - h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_N^n + h g_1(t_n)\n    $$\n    将这些代入 $i=0$ 和 $i=N$ 的通用更新公式，得到特定的边界更新规则：\n    -   在 $i=0$ 处： $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + u_0^n - h g_0(t_n)) = (1-\\lambda) u_0^n + \\lambda u_1^n - \\lambda h g_0(t_n)$。\n    -   在 $i=N$ 处： $u_N^{n+1} = u_N^n + \\lambda (u_N^n + h g_1(t_n) - 2u_N^n + u_{N-1}^n) = \\lambda u_{N-1}^n + (1-\\lambda) u_N^n + \\lambda h g_1(t_n)$。\n    该边界条件实现的局部截断误差为 $\\mathcal{O}(h)$。预计这将把整个格式的整体空间精度限制在一阶，因此观测到的收敛阶 $p$ 应约等于 1。\n\n2.  **二阶 (SO) 闭合格式**：鬼点由诺伊曼条件的二阶精度中心差分近似确定：\n    $$\n    u_{-1}^n = u_1^n - 2h g_0(t_n)\n    $$\n    $$\n    u_{N+1}^n = u_{N-1}^n + 2h g_1(t_n)\n    $$\n    代入这些可得到边界更新规则：\n    -   在 $i=0$ 处： $u_0^{n+1} = u_0^n + \\lambda (u_1^n - 2u_0^n + u_1^n - 2h g_0(t_n)) = (1-2\\lambda) u_0^n + 2\\lambda u_1^n - 2\\lambda h g_0(t_n)$。\n    -   在 $i=N$ 处： $u_N^{n+1} = u_N^n + \\lambda (u_{N-1}^n + 2h g_1(t_n) - 2u_N^n + u_{N-1}^n) = 2\\lambda u_{N-1}^n + (1-2\\lambda) u_N^n + 2\\lambda h g_1(t_n)$。\n    该边界实现的局部截断误差为 $\\mathcal{O}(h^2)$，这与内部空间离散的 $\\mathcal{O}(h^2)$ 精度是一致的。时间误差为 $\\mathcal{O}(\\Delta t) = \\mathcal{O}(h^2)$。因此，整个格式预计是二阶精度的，观测到的收敛阶 $p$ 应约等于 2。\n\n数值实验按以下步骤进行：对于每种情况 (A, B) 和每种闭合格式 (FO, SO)，我们对一系列网格分辨率 $N \\in \\{20, 40, 80, 160\\}$ 求解该问题。对于每个分辨率，我们计算在时间 $T$ 的最终数值解 $u_i$。误差使用离散 $L^2$ 范数来衡量，定义为 $E(h) = \\sqrt{h \\sum_{i=0}^N (u_i - u_{exact}(x_i, T))^2}$。观测到的收敛阶 $p$ 是通过对点集 $(\\log h, \\log E(h))$ 进行线性最小二乘拟合得到的斜率。最后，比较两种闭合格式在最细网格（$N=160$）上的误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified. It computes convergence orders\n    for two different Neumann boundary condition closures for the 1D heat equation.\n    \"\"\"\n    # Define problem parameters\n    alpha = 1.0\n    T = 0.1\n    c = 0.45\n    N_values = [20, 40, 80, 160]\n\n    # Define the two manufactured solution cases\n    case_A = {\n        'name': 'A',\n        'u_exact': lambda x, t, a: np.sin(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.sin(np.pi * x),\n        'g_0': lambda t, a: np.pi * np.exp(-a * np.pi**2 * t),\n        'g_1': lambda t, a: -np.pi * np.exp(-a * np.pi**2 * t)\n    }\n\n    case_B = {\n        'name': 'B',\n        'u_exact': lambda x, t, a: np.cos(np.pi * x) * np.exp(-a * np.pi**2 * t),\n        'u_0': lambda x: np.cos(np.pi * x),\n        'g_0': lambda t, a: 0.0,\n        'g_1': lambda t, a: 0.0\n    }\n\n    # Define the configurations to test\n    test_configs = [\n        {'case': case_A, 'closure': 'FO'},\n        {'case': case_A, 'closure': 'SO'},\n        {'case': case_B, 'closure': 'FO'},\n        {'case': case_B, 'closure': 'SO'},\n    ]\n\n    observed_orders = []\n    errors_N160 = {}\n\n    for config in test_configs:\n        case = config['case']\n        closure_type = config['closure']\n        \n        log_h_list = []\n        log_E_list = []\n\n        for N in N_values:\n            h = 1.0 / N\n            x = np.linspace(0.0, 1.0, N + 1)\n            \n            # Time stepping setup\n            dt_base = c * h**2 / (2.0 * alpha)\n            num_steps = int(round(T / dt_base))\n            dt = T / num_steps\n            \n            lam = alpha * dt / h**2\n            \n            # Initial condition\n            u = case['u_0'](x)\n            \n            # Time integration loop\n            for n in range(num_steps):\n                t_n = n * dt\n                u_new = np.zeros_like(u)\n                \n                # Interior points update\n                u_new[1:-1] = u[1:-1] + lam * (u[:-2] - 2 * u[1:-1] + u[2:])\n                \n                # Boundary functions g0(t), g1(t)\n                g0_tn = case['g_0'](t_n, alpha)\n                g1_tn = case['g_1'](t_n, alpha)\n\n                # Boundary points update\n                if closure_type == 'FO':\n                    u_new[0] = (1.0 - lam) * u[0] + lam * u[1] - lam * h * g0_tn\n                    u_new[-1] = lam * u[-2] + (1.0 - lam) * u[-1] + lam * h * g1_tn\n                elif closure_type == 'SO':\n                    u_new[0] = (1.0 - 2.0 * lam) * u[0] + 2.0 * lam * u[1] - 2.0 * lam * h * g0_tn\n                    u_new[-1] = 2.0 * lam * u[-2] + (1.0 - 2.0 * lam) * u[-1] + 2.0 * lam * h * g1_tn\n\n                u = u_new\n\n            # Compute error at final time T\n            u_exact_T = case['u_exact'](x, T, alpha)\n            error = np.sqrt(h) * np.linalg.norm(u - u_exact_T)\n            \n            log_h_list.append(np.log(h))\n            log_E_list.append(np.log(error))\n            \n            if N == 160:\n                errors_N160[(case['name'], closure_type)] = error\n\n        # Compute observed order of convergence using least-squares fit\n        p, _ = np.polyfit(log_h_list, log_E_list, 1)\n        observed_orders.append(p)\n    \n    # Final comparisons for N=160\n    b_A = errors_N160[('A', 'SO')]  errors_N160[('A', 'FO')]\n    b_B = errors_N160[('B', 'SO')]  errors_N160[('B', 'FO')]\n    \n    # Prepare results for printing\n    results_list = observed_orders + [b_A, b_B]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results_list))}]\")\n\nsolve()\n```", "id": "2393512"}]}