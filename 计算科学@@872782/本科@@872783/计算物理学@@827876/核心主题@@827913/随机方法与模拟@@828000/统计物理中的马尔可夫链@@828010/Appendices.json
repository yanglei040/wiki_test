{"hands_on_practices": [{"introduction": "我们的动手实践始于随机行走——物理学中典型的马尔可夫过程。本练习将粒子的微观、逐步行走与宏观的扩散现象联系起来。通过从第一性原理推导扩散系数，并在不同晶格结构上进行行走模拟，你将深入理解简单的无记忆规则如何导致可预测的宏观行为，这是统计物理学的基石概念。[@problem_id:2445720]", "problem": "您将研究在两种无限二维晶格（方形晶格和蜂窝晶格）上的无偏离散时间最近邻随机游走。每个行走器在时间步 $0$ 从原点开始，以固定的时间间隔 $\\tau$ (秒) 进行固定长度为 $a$ (米) 的步进，并且在每一步都从晶格几何所允许的最近邻中进行均匀选择。蜂窝晶格模型具有三个相互夹角为 $120^\\circ$ 的键方向；方形晶格模型具有四个基本方向。您的目标是从第一性原理出发，量化和比较这两种晶格上的扩散，并证实或证伪长时间扩散系数中任何与晶格相关的差异。所有数值结果必须以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位表示。\n\n所需的推导和实现任务：\n- 从 $n$ 步后随机游走位移的定义 $\\mathbf{r}_n = \\sum_{k=1}^{n} \\mathbf{s}_k$ 以及二维空间中扩散的定义关系出发，推导出一个扩散系数 $D$ 的估计量，该估计量以在总物理时间 $t = n \\tau$ 内经过 $n$ 步累积的均方位移 $\\langle r_n^2 \\rangle$ 表示。您的推导必须仅依赖于以下核心属性：在给定当前状态下，步进增量是独立的；由于晶格对称性，每一步的增量均值为零；步长固定为 $a$。不要假设任何特定于晶格的简化公式。\n- 实现两个独立的模拟器：\n  1. 方形晶格：在每一步，从由 $a$ 缩放的 $4$ 个单位向量 $(\\pm 1, 0)$、$(0, \\pm 1)$ 中均匀选择。\n  2. 蜂窝晶格：使用三个长度为 $a$ 的键向量 $\\mathbf{b}_1 = a (1, 0)$、$\\mathbf{b}_2 = a (-\\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2})$、$\\mathbf{b}_3 = a (-\\tfrac{1}{2}, -\\tfrac{\\sqrt{3}}{2})$，使得从一个子晶格出发的选择是 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$，而从另一个子晶格出发的选择是 $\\{-\\mathbf{b}_1, -\\mathbf{b}_2, -\\mathbf{b}_3\\}$。从一个子晶格的原点开始，每走一步就交替子晶格。\n- 对于下面的每个测试用例，在每个晶格上模拟 $M$ 个独立的行走器进行 $n$ 步，分别为每个晶格计算这 $M$ 个行走器的均方位移 $\\langle r_n^2 \\rangle$，并使用您推导出的估计量将其转换为扩散系数的估计值 $\\hat{D}$。在给定的测试用例中，对两种晶格使用相同的 $M$、$n$、$a$ 和 $\\tau$。如果提供了随机种子，请使用它来产生可复现的结果。\n\n物理单位和输出要求：\n- 以浮点数形式报告每个扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$。不要打印单位字符串；只打印数值。\n- 在蜂窝几何中，相关角度必须在内部以弧度制理解；上述指定的算法已经编码了方向，因此您无需在程序输出中显式处理角度。\n\n测试套件（每个元组为 $(n, a, \\tau, M, \\text{seed})$，所有量均应以国际单位制解释）：\n- 情况 A (标准情况): $(20000, 1.0 \\times 10^{-9}, 1.0 \\times 10^{-12}, 200, 12345)$。\n- 情况 B (边界条件，单步): $(1, 5.0 \\times 10^{-10}, 2.0 \\times 10^{-13}, 1000, 54321)$。\n- 情况 C (短程行走，多次试验): $(2000, 2.0 \\times 10^{-10}, 1.0 \\times 10^{-13}, 500, 202311)$。\n- 情况 D (不同尺度): $(5000, 3.0 \\times 10^{-10}, 5.0 \\times 10^{-13}, 300, 777)$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含一个结果列表，每个测试用例一个结果，按 A、B、C、D 的顺序排列。对于每个测试用例，输出一个包含三个浮点数的列表 $[\\hat{D}_{\\text{square}}, \\hat{D}_{\\text{honeycomb}}, D_{\\text{theory}}]$，其中 $D_{\\text{theory}}$是根据所述假设由您的推导预测的扩散系数。因此，完整的输出必须是一个列表的列表，例如 $[[x_1, y_1, z_1], [x_2, y_2, z_2], [x_3, y_3, z_3], [x_4, y_4, z_4]]$，所有值都以 $\\mathrm{m}^2/\\mathrm{s}$ 为单位。必须只打印这个单行列表。", "solution": "该问题要求从第一性原理出发，为二维离散随机游走推导扩散系数 $D$ 的估计量，并随后在方形和蜂窝晶格上进行数值验证。对问题陈述的验证表明，其在科学上是合理的、适定的且完整的。我们开始进行解答。\n\n首要任务是在随机游走的微观参数与宏观扩散系数之间建立关系。一个行走器在 $n$ 步后的位置 $\\mathbf{r}_n$ 是各个步进向量 $\\mathbf{s}_k$ 的总和：\n$$ \\mathbf{r}_n = \\sum_{k=1}^{n} \\mathbf{s}_k $$\n我们感兴趣的量是均方位移 (MSD) $\\langle r_n^2 \\rangle$，其中平均值 $\\langle \\cdot \\rangle$ 是对一个独立行走器系综计算的。位移的平方是位置向量与自身的点积：\n$$ r_n^2 = \\mathbf{r}_n \\cdot \\mathbf{r}_n = \\left( \\sum_{i=1}^{n} \\mathbf{s}_i \\right) \\cdot \\left( \\sum_{j=1}^{n} \\mathbf{s}_j \\right) = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\mathbf{s}_i \\cdot \\mathbf{s}_j $$\n根据期望算子的线性性质，MSD 为：\n$$ \\langle r_n^2 \\rangle = \\left\\langle \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\mathbf{s}_i \\cdot \\mathbf{s}_j \\right\\rangle = \\sum_{i=1}^{n} \\sum_{j=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle $$\n我们将这个双重求和分解为索引相等 ($i=j$) 的项和索引不相等 ($i \\neq j$) 的项：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_i \\rangle + \\sum_{i \\neq j} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle $$\n问题陈述指出，步进增量是独立的。因此，对于 $i \\neq j$，乘积的期望等于期望的乘积：$\\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle = \\langle \\mathbf{s}_i \\rangle \\cdot \\langle \\mathbf{s}_j \\rangle$。问题还指明，该游走是无偏的，意味着步进方向的选择来自一个对称集合，这导致任何步进向量的均值为零：对于所有 $k$，$\\langle \\mathbf{s}_k \\rangle = \\mathbf{0}$。对于所定义的方形和蜂窝晶格，这一点都成立。因此，所有交叉项 ($i \\neq j$) 都为零：\n$$ \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_j \\rangle = \\mathbf{0} \\cdot \\mathbf{0} = 0 \\quad \\text{for } i \\neq j $$\nMSD 表达式简化为对角项之和：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} \\langle \\mathbf{s}_i \\cdot \\mathbf{s}_i \\rangle = \\sum_{i=1}^{n} \\langle |\\mathbf{s}_i|^2 \\rangle $$\n步长被设定为固定常数 $|\\mathbf{s}_k| = a$。因此，其平方也是常数 $|\\mathbf{s}_k|^2 = a^2$，其期望就是 $a^2$。求和变为：\n$$ \\langle r_n^2 \\rangle = \\sum_{i=1}^{n} a^2 = n a^2 $$\n这就是具有固定步长的无偏随机游走在 $n$ 步后的理论 MSD。\n在连续极限下，二维扩散由爱因斯坦关系式描述，该关系式将 MSD 与扩散系数 $D$ 和时间 $t$ 联系起来：\n$$ \\langle r^2(t) \\rangle = 4 D t $$\n我们通过将总时间 $t$ 设为步数 $n$ 乘以每步时间 $\\tau$ (即 $t = n \\tau$)，来将我们的离散模型与这个连续描述联系起来。令两个 MSD 表达式相等，得到：\n$$ n a^2 = 4 D (n \\tau) $$\n求解 $D$ 得到理论扩散系数，我们将其表示为 $D_{\\text{theory}}$：\n$$ D_{\\text{theory}} = \\frac{a^2}{4 \\tau} $$\n这个理论结果对于任何满足初始假设的晶格都是通用的，并且值得注意的是，它与晶格的配位数或几何形状无关。此推导证伪了在该模型条件下扩散系数依赖于晶格的观点。\n\n对于问题的数值部分，我们必须从模拟数据中估计 $D$。对 $M$ 个行走器进行 $n$ 步的模拟，会产生一组最终位移平方值 $\\{r_{n,1}^2, r_{n,2}^2, \\dots, r_{n,M}^2\\}$。模拟的 MSD $\\langle r_n^2 \\rangle_{\\text{sim}}$ 是这些值的样本均值。我们使用这个经验结果代入扩散关系式，以找到我们的估计量 $\\hat{D}$：\n$$ \\langle r_n^2 \\rangle_{\\text{sim}} = 4 \\hat{D} (n \\tau) \\implies \\hat{D} = \\frac{\\langle r_n^2 \\rangle_{\\text{sim}}}{4 n \\tau} $$\n这就是需要实现的估计量。\n\n实现将包括两个独立的模拟器。两者都将追踪一个由 $M$ 个行走器组成的群体，该群体由一个形状为 $(M, 2)$、初始化为零的 NumPy 数组表示。对于 $n$ 个时间步中的每一步，都会为每个行走器选择一个随机步进向量，并加到其当前位置上。为提高效率，此过程是向量化的。\n\n对于方形晶格，可能的步进向量集合是 $\\{\\,(a, 0), (-a, 0), (0, a), (0, -a)\\,\\}$。在每一步中，以均匀概率 $p=1/4$ 从这 $4$ 个向量中选择一个。\n\n对于蜂窝晶格，其结构是二分的。步进向量的集合取决于行走器当前所在的子晶格。设子晶格为 $A$ 和 $B$。从 $A$ 开始的行走器必须步进到 $B$，从 $B$ 开始的必须步进到 $A$。我们将基准键向量定义为 $\\mathbf{b}_1 = a(1, 0)$、$\\mathbf{b}_2 = a(-\\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2})$ 和 $\\mathbf{b}_3 = a(-\\tfrac{1}{2}, -\\tfrac{\\sqrt{3}}{2})$。\n- 从子晶格 $A$（例如，在偶数步 $0, 2, \\dots$），允许的步进是 $\\{\\mathbf{b}_1, \\mathbf{b}_2, \\mathbf{b}_3\\}$，每个的概率为 $p=1/3$。\n- 从子晶格 $B$（例如，在奇数步 $1, 3, \\dots$），允许的步进是 $\\{-\\mathbf{b}_1, -\\mathbf{b}_2, -\\mathbf{b}_3\\}$，每个的概率为 $p=1/3$。\n\n在 $n$ 步之后，计算每个行走器的最终位移平方，然后对所有 $M$ 个行走器取平均值以得到 $\\langle r_n^2 \\rangle_{\\text{sim}}$，并用此值计算 $\\hat{D}_{\\text{square}}$ 和 $\\hat{D}_{\\text{honeycomb}}$。这些模拟值将与推导出的 $D_{\\text{theory}} = a^2 / (4\\tau)$ 进行比较。由于有限模拟 ($M  \\infty$) 中固有的统计涨落，估计值 $\\hat{D}$ 会与 $D_{\\text{theory}}$ 有轻微偏差，但随着 $M$ 和 $n$ 变大，应会收敛于它。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_square(n, a, tau, M, seed):\n    \"\"\"\n    Simulates a random walk on a 2D square lattice.\n\n    Args:\n        n (int): Number of steps.\n        a (float): Step length in meters.\n        tau (float): Time interval per step in seconds.\n        M (int): Number of independent walkers.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: Estimated diffusion coefficient in m^2/s.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Initialize all M walkers at the origin (0, 0).\n    positions = np.zeros((M, 2), dtype=np.float64)\n    # Define the four possible step vectors.\n    steps_set = a * np.array([[1.0, 0.0], [-1.0, 0.0], [0.0, 1.0], [0.0, -1.0]])\n\n    for _ in range(n):\n        # For each of the M walkers, choose one of the 4 steps randomly.\n        choices = rng.integers(0, 4, size=M)\n        # Get the corresponding displacement vectors for all walkers.\n        displacements = steps_set[choices]\n        # Update all positions simultaneously.\n        positions += displacements\n    \n    # For n=0, division by zero occurs. Problem cases have n >= 1.\n    if n == 0:\n        return 0.0\n\n    # Calculate the squared displacement from the origin for each walker.\n    squared_displacements = np.sum(positions**2, axis=1)\n    # Compute the mean squared displacement over all walkers.\n    mean_squared_displacement = np.mean(squared_displacements)\n    \n    # Use the derived estimator for the diffusion coefficient D.\n    D_hat = mean_squared_displacement / (4.0 * n * tau)\n    return D_hat\n\ndef simulate_honeycomb(n, a, tau, M, seed):\n    \"\"\"\n    Simulates a random walk on a 2D honeycomb lattice.\n\n    Args:\n        n (int): Number of steps.\n        a (float): Step length in meters.\n        tau (float): Time interval per step in seconds.\n        M (int): Number of independent walkers.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        float: Estimated diffusion coefficient in m^2/s.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    # Initialize all M walkers at the origin (0, 0) on sublattice A.\n    positions = np.zeros((M, 2), dtype=np.float64)\n    \n    sqrt3_div_2 = np.sqrt(3.0) / 2.0\n    # Define bond vectors for sublattice A -> B transitions.\n    steps_A = a * np.array([[1.0, 0.0], [-0.5, sqrt3_div_2], [-0.5, -sqrt3_div_2]])\n    # Bond vectors for sublattice B -> A are the negative of A -> B.\n    steps_B = -steps_A\n\n    for i in range(n):\n        # For each of the M walkers, choose one of the 3 steps randomly.\n        choices = rng.integers(0, 3, size=M)\n        # Select step set based on sublattice (even/odd step number).\n        if i % 2 == 0:  # Walker is on sublattice A\n            displacements = steps_A[choices]\n        else:  # Walker is on sublattice B\n            displacements = steps_B[choices]\n        # Update all positions simultaneously.\n        positions += displacements\n\n    if n == 0:\n        return 0.0\n\n    # Calculate and average the squared displacements.\n    squared_displacements = np.sum(positions**2, axis=1)\n    mean_squared_displacement = np.mean(squared_displacements)\n    \n    # Estimate D.\n    D_hat = mean_squared_displacement / (4.0 * n * tau)\n    return D_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (n, a, tau, M, seed)\n        (20000, 1.0e-9, 1.0e-12, 200, 12345),  # Case A\n        (1, 5.0e-10, 2.0e-13, 1000, 54321),    # Case B\n        (2000, 2.0e-10, 1.0e-13, 500, 202311), # Case C\n        (5000, 3.0e-10, 5.0e-13, 300, 777),      # Case D\n    ]\n\n    all_results = []\n    for case in test_cases:\n        n, a, tau, M, seed = case\n        \n        # Run simulation for the square lattice.\n        D_square = simulate_square(n, a, tau, M, seed)\n        \n        # Run simulation for the honeycomb lattice.\n        D_honeycomb = simulate_honeycomb(n, a, tau, M, seed)\n        \n        # Calculate the theoretical diffusion coefficient.\n        D_theory = (a**2) / (4.0 * tau)\n        \n        all_results.append([D_square, D_honeycomb, D_theory])\n\n    # Format the final output string to match the required format.\n    # The output is a string representation of a list of lists.\n    # e.g., [[val1,val2,val3],[val4,val5,val6]]\n    # Using str() on each sublist and then joining is a reliable way\n    # to produce the python literal representation.\n    result_strings = [str(res) for res in all_results]\n    \n    # The default str representation includes spaces. To match the example\n    # style [[x1,y1,z1],...] without spaces, we can build the string manually.\n    formatted_results = []\n    for res in all_results:\n        # Format each sublist as a string \"[v1,v2,v3]\"\n        formatted_results.append(f\"[{','.join(map(str, res))}]\")\n    \n    # Join all sublist strings and wrap in outer brackets.\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2445720"}, {"introduction": "在直接模拟的基础上，我们现在将马尔可夫链用作一种复杂的统计抽样工具。本实践将介绍伊辛模型（Ising model），这是研究磁性和相变的基本模型，其巨大的状态空间无法被穷举。你将实现吉布斯抽样（Gibbs sampling），一种强大的马尔可夫链蒙特卡洛（MCMC）算法，以根据玻尔兹曼分布生成构型并测量关键物理性质，从而直接洞察自发磁化等集体现象。[@problem_id:2411722]", "problem": "您将实现一个马尔可夫链蒙特卡洛模拟器，该模拟器使用吉布斯采样（也称为热浴算法）来模拟一个被建模为类伊辛格点阵系统的二维二元合金。考虑一个线性尺寸为 $L$ 的方形晶格，具有周期性边界条件，因此格点总数为 $N = L^2$。每个格点 $i$ 带有一个二元变量 $s_i \\in \\{-1, +1\\}$，代表两种原子种类之一。一个构型的能量由伊辛哈密顿量给出\n$$\n\\mathcal{H}(s) = - J \\sum_{\\langle i,j \\rangle} s_i s_j,\n$$\n其中求和遍及方形晶格上的最近邻对，$J$ 是一个耦合常数。您将使用吉布斯采样来构建一个马尔可夫链，该链是遍历的，并且在逆温度 $\\beta = 1/T$（玻尔兹曼常数 $k_B$ 设为 $1$，即温度以 $J/k_B$ 为单位，其中 $k_B=1$）下，相对于玻尔兹曼分布满足细致平衡。您必须明确实现周期性边界条件，并使用棋盘（红黑）更新方案，以便一个子晶格的所有格点都使用其邻居的当前值同时更新。\n\n从平衡概率与玻尔兹曼权重 $e^{-\\beta \\mathcal{H}(s)}$ 成正比的基本定义出发，推导在固定温度 $T$ 和耦合 $J$ 的条件下，给定其邻居状态，用于重采样一个格点 $s_i$ 的吉布斯更新所依赖的单格点条件概率。使用该条件概率实现一个单格点吉布斯采样器，通过交替进行子晶格更新来更新整个晶格。随机初始化自旋，并在收集测量数据前进行一段预烧期。\n\n对于预烧期后马尔可夫链的每个状态，计算以下可观测量：\n- 每格点的瞬时磁化强度 $m = \\frac{1}{N} \\sum_i s_i$ 及其绝对值 $|m|$。\n- 每格点的瞬时能量 $e = \\frac{1}{N} \\mathcal{H}(s)$，计算时每个最近邻对仅计入一次。\n- Binder累积量 $U_4 = 1 - \\frac{\\langle m^4 \\rangle}{3 \\langle m^2 \\rangle^2}$，其中尖括号表示在固定温度和晶格尺寸下，对马尔可夫链的测量样本进行的时间平均。\n\n设计您的模拟器，使其对于一个固定的随机数生成器种子，能够产生可复现的结果。您的程序必须运行以下参数集的测试套件，并为每个测试用例报告时间平均绝对磁化强度 $\\langle |m| \\rangle$、时间平均每格点能量 $\\langle e \\rangle$ 和Binder累积量 $U_4$。所有温度都以 $k_B=1$ 为单位，因此 $T$ 以 $J$ 为单位表示。在两个方向上都使用周期性边界条件。\n\n测试套件（每个元组为 $(L, J, T, n_{\\text{therm}}, n_{\\text{meas}})$）：\n- 正常路径，有序相：$(40, 1.0, 1.8, 800, 800)$。\n- 接近二维伊辛模型临界点：$(40, 1.0, 2.269, 1500, 1500)$。\n- 无序相：$(40, 1.0, 3.5, 800, 800)$。\n- 边界情况（无相互作用）：$(40, 0.0, 1.0, 500, 1000)$。\n\n您的程序必须为每个测试用例计算三个所需的可观测量，在 $n_{\\text{meas}}$ 次测量扫描中对它们进行平均，并将三个输出中的每一个四舍五入到 $4$ 位小数进行报告。最终输出没有物理单位，因为在所选单位制中（$k_B=1$），所有量都是无量纲的。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。与每个测试用例对应的结果本身必须是一个用方括号括起来的、逗号分隔的三个四舍五入浮点数的列表 $[\\langle |m| \\rangle, \\langle e \\rangle, U_4]$，顺序与上述测试套件相同。例如，输出应如下所示\n$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3],[x_4,y_4,z_4]]$\n其中每个 $x_i, y_i, z_i$ 都四舍五入到 $4$ 位小数，并且不打印任何其他文本。", "solution": "对所提供的问题进行验证。\n\n### 第一步：提取给定条件\n- **系统模型**：一个线性尺寸为 $L$ 的二维方形晶格，具有 $N = L^2$ 个格点。每个格点 $i$ 有一个自旋变量 $s_i \\in \\{-1, +1\\}$。\n- **哈密顿量**：构型 $s$ 的能量由 $\\mathcal{H}(s) = -J \\sum_{\\langle i,j \\rangle} s_i s_j$ 给出，其中求和遍及最近邻对。\n- **热力学**：系统与逆温度为 $\\beta = 1/T$ 的热浴处于平衡状态，玻尔兹曼常数 $k_B$ 设为 $1$。概率遵循玻尔兹曼分布 $P(s) \\propto e^{-\\beta \\mathcal{H}(s)}$。\n- **算法**：使用吉布斯采样（热浴算法）的马尔可夫链蒙特卡洛模拟。\n- **更新方案**：强制使用棋盘（红黑）更新方案，其中一个子晶格的所有格点同时更新。\n- **边界条件**：在两个晶格方向上均为周期性边界条件。\n- **模拟协议**：从随机自旋构型开始，执行 $n_{\\text{therm}}$ 次热化扫描，然后执行 $n_{\\text{meas}}$ 次测量扫描。\n- **待计算的可观测量**：\n    - 每格点的瞬时磁化强度：$m = \\frac{1}{N} \\sum_i s_i$。\n    - 每格点的瞬时绝对磁化强度：$|m|$。\n    - 每格点的瞬时能量：$e = \\frac{1}{N} \\mathcal{H}(s)$。\n    - Binder累积量：$U_4 = 1 - \\frac{\\langle m^4 \\rangle}{3 \\langle m^2 \\rangle^2}$，其中 $\\langle \\cdot \\rangle$ 表示对测量样本的平均。\n- **可复现性**：对于固定的随机数生成器种子，模拟必须是可复现的。\n- **测试套件**：一系列测试用例，每个由元组 $(L, J, T, n_{\\text{therm}}, n_{\\text{meas}})$ 定义：\n    1. $(40, 1.0, 1.8, 800, 800)$\n    2. $(40, 1.0, 2.269, 1500, 1500)$\n    3. $(40, 1.0, 3.5, 800, 800)$\n    4. $(40, 0.0, 1.0, 500, 1000)$\n- **输出格式**：对于每个测试用例，报告一个包含时间平均绝对磁化强度 $\\langle |m| \\rangle$、时间平均每格点能量 $\\langle e \\rangle$ 和Binder累积量 $U_4$ 的列表，每个值四舍五入到 $4$ 位小数。最终输出必须是单行：`[[...],[...],[...],[...]]`。\n\n### 第二步：使用提取的给定条件进行验证\n- **科学依据**：该问题在根本上是科学合理的。伊辛模型、吉布斯采样和指定的可观测量是统计物理和计算物理学的核心主题。该设置使用了已建立的原理和模型。\n- **良定性**：该问题是良定的。它提供了所有必要信息：物理模型、模拟算法、每次运行的具体参数以及所需输出的明确定义。使用固定的随机种子，该算法是确定性的，将产生唯一的解。\n- **客观性**：问题陈述是客观的，并使用了精确、无歧义的科学语言。\n\n该问题没有表现出任何缺陷，如科学上不合理、不完整、矛盾或模糊。它是一个计算统计力学中标准的、定义明确的问题。\n\n### 第三步：结论与行动\n问题有效。将提供完整的解决方案。\n\n### 基于原理的解决方案\n目标是使用一种特定的马尔可夫链蒙特卡洛方法，即吉布斯采样，来模拟二维伊辛模型，并计算几个关键的统计可观测量。\n\n**1. 吉布斯采样和条件概率**\n\n吉布斯采样算法，也称为热浴算法，通过从给定系统所有其他分量当前状态的条件概率分布中抽取一个新值，来更新系统单个分量 $s_i$ 的状态。对于伊辛模型，由于哈密顿量 $\\mathcal{H}$ 的最近邻性质，一个自旋 $s_i$ 的状态仅依赖于其直接邻居。\n\n在给定其邻居构型固定的情况下，找到自旋 $i$ 处于状态 $s_i$ 的条件概率，与该自旋贡献的能量相关的玻尔兹曼因子成正比：\n$$ P(s_i | \\{s_j\\}_{j \\in \\text{nn}(i)}) \\propto e^{-\\beta E_i} $$\n其中 $E_i$ 是总能量中依赖于 $s_i$ 的部分。该能量为 $E_i = -J s_i \\sum_{j \\in \\text{nn}(i)} s_j$。我们定义局域场 $h_i = \\sum_{j \\in \\text{nn}(i)} s_j$，即四个相邻自旋之和。那么，$E_i = -J s_i h_i$。\n\n$s_i$ 处于状态 $+1$ 的条件概率通过对两种可能状态 $s_i = +1$ 和 $s_i = -1$进行归一化得到：\n$$ P(s_i = +1 | h_i) = \\frac{e^{-\\beta (-J(+1)h_i)}}{e^{-\\beta (-J(+1)h_i)} + e^{-\\beta (-J(-1)h_i)}} = \\frac{e^{\\beta J h_i}}{e^{\\beta J h_i} + e^{-\\beta J h_i}} $$\n这个表达式可以用双曲正切函数重写成数值稳定的形式，或者更方便实现的形式为：\n$$ P(s_i = +1 | h_i) = \\frac{1}{1 + e^{-2\\beta J h_i}} $$\n$s_i$ 为 $-1$ 的概率就是 $P(s_i = -1 | h_i) = 1 - P(s_i = +1 | h_i)$。\n单个自旋 $s_i$ 的吉布斯更新规则如下：\n1. 计算其邻居之和 $h_i$。\n2. 计算概率 $p_+ = P(s_i = +1 | h_i)$。\n3. 抽取一个均匀随机数 $r \\in [0, 1)$。\n4. 如果 $r  p_+$，则设置 $s_i = +1$；否则，设置 $s_i = -1$。\n\n**2. 棋盘更新方案**\n\n为了并行化更新并确保正确性，采用了棋盘（或红黑）更新方案。晶格格点被划分为两个子晶格，“红色”和“黑色”，就像棋盘上的方格一样。如果 $i+j$ 是偶数，则格点 $(i,j)$ 是“红色”的；如果 $i+j$ 是奇数，则是“黑色”的。关键性质是，一个红色格点的所有邻居都是黑色的，反之亦然。\n\n对晶格的一次完整扫描包括两个步骤：\n1.  **更新红色子晶格**：同时更新红色子晶格上的所有自旋。对于每个红色自旋，其邻居都在黑色子晶格上。每个红色自旋的更新只依赖于黑色自旋的当前状态，因此这些更新彼此独立。\n2.  **更新黑色子晶格**：随后，同时更新黑色子晶格上的所有自旋。这些自旋的邻居在红色子晶格上，所以它们的更新将使用步骤1中新计算出的红色自旋的值。\n\n该方案保证了整个扫描满足细致平衡条件，并允许高效的矢量化实现。\n\n**3. 可观测量及其计算**\n\n经过 $n_{\\text{therm}}$ 次扫描的热化期，让系统达到平衡后，在 $n_{\\text{meas}}$ 次扫描中进行测量。\n\n- **每格点磁化强度 ($m$)**：对于给定的自旋构型，这是平均自旋值：$m = \\frac{1}{N} \\sum_{i=1}^N s_i$。我们将需要其绝对值 $|m|$，以及用于计算Binder累积量的 $m^2$ 和 $m^4$。\n\n- **每格点能量 ($e$)**：总能量为 $\\mathcal{H} = -J \\sum_{\\langle i,j \\rangle} s_i s_j$。为避免重复计数，我们对每个格点与其“右侧”和“下方”邻居的相互作用求和（使用周期性边界）。\n$$ \\mathcal{H} = -J \\sum_{i,j} s_{i,j} (s_{i,j+1} + s_{i+1,j}) $$\n其中索引取模 $L$。每格点能量为 $e = \\mathcal{H} / N$。\n\n- **Binder累积量 ($U_4$)**：这是一个用于定位相变的高阶矩比。其定义为：\n$$ U_4 = 1 - \\frac{\\langle m^4 \\rangle}{3 \\langle m^2 \\rangle^2} $$\n其中 $\\langle m^2 \\rangle$ 和 $\\langle m^4 \\rangle$ 是瞬时磁化强度的平方和四次方的平均值，在测量扫描中求得。这个量有一个有用的性质，即在临界温度下，它近似与系统大小无关。它在有序相中趋近于 $2/3$，在无序相中趋近于 $0$。对于无相互作用的情况（$J=0$），对于有限系统，$U_4 = 2/(3N)$，接近于 $0$。\n\n**4. 算法实现**\n\n对于每个测试用例 $(L, J, T, n_{\\text{therm}}, n_{\\text{meas}})$，模拟将按以下步骤进行：\n1.  用随机自旋（等概率为 $+1$ 或 $-1$）初始化一个 $L \\times L$ 的晶格。\n2.  定义红色和黑色子晶格掩码。\n3.  设置 $\\beta = 1/T$（如果 $T > 0$）。\n4.  **热化**：执行 $n_{\\text{therm}}$ 次完整的棋盘扫描，不进行测量。\n5.  **测量**：执行 $n_{\\text{meas}}$ 次扫描。每次扫描后：\n    a. 计算瞬时磁化强度 $m$ 和每格点能量 $e$。\n    b. 存储 $|m|$、$e$、$m^2$ 和 $m^4$。\n6.  **求平均**：测量循环结束后，计算存储量的平均值：$\\langle |m| \\rangle$、$\\langle e \\rangle$、$\\langle m^2 \\rangle$ 和 $\\langle m^4 \\rangle$。\n7.  从平均矩计算Binder累积量 $U_4$。\n8.  返回按规定四舍五入的最终三个可观测量。\n\n使用 `numpy` 可以高效地矢量化邻居和的计算（使用 `numpy.roll`）以及在整个子晶格上同时进行概率更新。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, J, T, n_therm, n_meas, rng):\n    \"\"\"\n    Runs a Markov Chain Monte Carlo simulation for the 2D Ising model.\n\n    Args:\n        L (int): Linear size of the square lattice.\n        J (float): Coupling constant.\n        T (float): Temperature.\n        n_therm (int): Number of thermalization sweeps.\n        n_meas (int): Number of measurement sweeps.\n        rng (np.random.Generator): Random number generator instance.\n\n    Returns:\n        tuple: A tuple containing the averaged absolute magnetization,\n               averaged energy per site, and the Binder cumulant.\n    \"\"\"\n    N = L * L\n    \n    # Initialize spins randomly\n    spins = rng.choice([-1, 1], size=(L, L))\n    \n    # Create checkerboard masks\n    x, y = np.meshgrid(range(L), range(L))\n    red_mask = (x + y) % 2 == 0\n    black_mask = ~red_mask\n    \n    beta = 1.0 / T if T > 0 else float('inf')\n\n    # Simulation sweeps\n    for _ in range(n_therm):\n        # Gibbs sweep\n        for mask in [red_mask, black_mask]:\n            # Sum of neighbors using np.roll for periodic boundaries\n            neighbors_sum = (np.roll(spins, 1, axis=0) +\n                             np.roll(spins, -1, axis=0) +\n                             np.roll(spins, 1, axis=1) +\n                             np.roll(spins, -1, axis=1))\n            \n            # Argument for the exponential in the probability calculation\n            # For J=0, delta_E_arg is 0, prob is 0.5, which is correct.\n            delta_E_arg = 2.0 * J * neighbors_sum * beta\n            \n            # Probability to be in the +1 state, numerically stable form\n            prob_plus_one = 1.0 / (1.0 + np.exp(-delta_E_arg))\n            \n            # Generate random numbers and update spins\n            rand_flips = rng.random(size=(L,L))\n            new_spins = 2 * (rand_flips  prob_plus_one) - 1\n            \n            # Apply update only to the current sublattice\n            spins[mask] = new_spins[mask]\n\n    # Measurement phase\n    m_vals = []\n    e_vals = []\n    m2_vals = []\n    m4_vals = []\n\n    for _ in range(n_meas):\n        # Gibbs sweep\n        for mask in [red_mask, black_mask]:\n            neighbors_sum = (np.roll(spins, 1, axis=0) +\n                             np.roll(spins, -1, axis=0) +\n                             np.roll(spins, 1, axis=1) +\n                             np.roll(spins, -1, axis=1))\n            \n            delta_E_arg = 2.0 * J * neighbors_sum * beta\n            prob_plus_one = 1.0 / (1.0 + np.exp(-delta_E_arg))\n            \n            rand_flips = rng.random(size=(L,L))\n            new_spins = 2 * (rand_flips  prob_plus_one) - 1\n            spins[mask] = new_spins[mask]\n\n        # Calculate observables\n        m = np.mean(spins)\n        \n        # Energy calculation (each bond counted once)\n        energy_total = -J * np.sum(spins * (np.roll(spins, 1, axis=0) + np.roll(spins, 1, axis=1)))\n        e = energy_total / N\n        \n        # Store values for averaging\n        m_vals.append(np.abs(m))\n        e_vals.append(e)\n        m2_vals.append(m**2)\n        m4_vals.append(m**4)\n        \n    # Calculate final averages\n    avg_abs_m = np.mean(m_vals)\n    avg_e = np.mean(e_vals)\n    avg_m2 = np.mean(m2_vals)\n    avg_m4 = np.mean(m4_vals)\n    \n    # Calculate Binder cumulant, handle division by zero\n    if avg_m2 > 1e-12:\n        binder_cumulant = 1.0 - (avg_m4 / (3.0 * avg_m2**2))\n    else:\n        # Occurs if m is always zero (highly unlikely in finite simulation)\n        # or for J=0 case where avg_m2 is small. The theoretical value is 0.\n        binder_cumulant = 0.0\n\n    return avg_abs_m, avg_e, binder_cumulant\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, J, T, n_therm, n_meas)\n        (40, 1.0, 1.8, 800, 800),\n        (40, 1.0, 2.269, 1500, 1500),\n        (40, 1.0, 3.5, 800, 800),\n        (40, 0.0, 1.0, 500, 1000),\n    ]\n\n    # For reproducibility\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    results = []\n    for case in test_cases:\n        L, J, T, n_therm, n_meas = case\n        avg_abs_m, avg_e, binder_cumulant = run_simulation(L, J, T, n_therm, n_meas, rng)\n        \n        # Round results to 4 decimal places\n        result_tuple = [\n            round(avg_abs_m, 4),\n            round(avg_e, 4),\n            round(binder_cumulant, 4)\n        ]\n        results.append(result_tuple)\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes the required brackets and spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2411722"}, {"introduction": "最后，我们将展示统计力学概念惊人的普适性，将其应用于一个看似无关的问题：解决数独谜题。通过将谜题构建为一个寻找“基态”（能量/错误为零的状态）的系统，并为其巧妙地定义一个“能量”函数，我们可以使用基于梅特罗波利斯（Metropolis）的 MCMC 算法来找到解决方案。这个练习阐明了模拟退火原理如何将一个复杂的组合优化问题转化为一个可行的模拟任务，展示了物理思维在不同领域的强大威力。[@problem_id:2411684]", "problem": "考虑以下受平衡统计力学启发的有限态马尔可夫链的构造。设 $b$ 为一个正整数，并定义 $n = b^2$。一个数独（Sudoku）实例表示为一个 $n \\times n$ 的整数数组，其条目取自 $\\{0,1,2,\\dots,n\\}$，其中值 $0$ 表示未指定的单元格，而 $\\{1,2,\\dots,n\\}$ 中的值代表固定的提示数字。一个构型（configuration）是通过为未指定的单元格赋予 $\\{1,2,\\dots,n\\}$ 中的值来完成实例的任意一种填法，使得在每个 $b \\times b$ 的子网格（宫）内，数字的多重集与该宫内已有的固定提示数字结合后，恰好等于 $\\{1,2,\\dots,n\\}$。\n\n定义一个构型 $X$ 的能量为\n$$\nE(X) = \\sum_{\\text{rows } r} \\left(n - \\left|\\{\\text{distinct digits in row } r\\}\\right|\\right) + \\sum_{\\text{columns } c} \\left(n - \\left|\\{\\text{distinct digits in column } c\\}\\right|\\right) + \\sum_{\\text{boxes } B} \\left(b^2 - \\left|\\{\\text{distinct digits in box } B\\}\\right|\\right).\n$$\n等价地，对于每行、每列和每宫，$E(X)$ 计算的是超出完美不重复数字集合的条目数量；$E(X)=0$ 当且仅当 $X$ 是一个有效的数独解。\n\n考虑在构型状态空间上的以下马尔可夫链：\n- 状态空间由所有满足上述宫内组成约束且保持给定提示数字不变的填法组成。\n- 从一个构型 $X$ 生成一个提议（proposal）的方法是：从所有宫中均匀随机选择一个宫，然后在该宫内均匀随机选择一对不同的、非提示数字的单元格并交换它们的值，从而得到一个提议构型 $Y$。\n- 给定逆温 $\\beta  0$，转移 $X \\to Y$ 以概率 $\\min\\{1, \\exp(-\\beta [E(Y)-E(X)])\\}$ 被接受，否则链保持在状态 $X$。\n\n一个扫描（sweep）定义为 $n \\times n$ 次连续的提议尝试（每次尝试包括选择一个宫，如上所述在该宫内提议一次交换，并应用接受规则）。初始构型是跨宫独立地均匀随机抽样的，通过补全每个 $b \\times b$ 的宫，使得该宫内的数字多重集与固定的提示数字相符，恰好为 $\\{1,2,\\dots,n\\}$；换句话说，在每个宫中，未指定的单元格被赋予所缺失数字的一个均匀随机排列。伪随机性必须由一个标准的伪随机数生成器产生，并为每个测试用例使用指定的整数种子进行初始化。\n\n对于下方的每个测试用例，使用指定的逆温 $\\beta$ 和指定的扫描次数 $T$，从指定的实例开始模拟该链。每个测试用例所需的输出是在整个轨迹中遇到的最小能量 $E_{\\min}$，包括初始构型（即在任何提议尝试之前）。每个输出都是一个整数。\n\n测试套件：\n- 测试用例 1（正常路径，中等规模）：$b=2$（因此 $n=4$），实例\n  $$\n  \\begin{bmatrix}\n  0  0  3  4\\\\\n  3  4  0  0\\\\\n  0  1  4  0\\\\\n  4  0  0  1\n  \\end{bmatrix}\n  $$\n  逆温 $\\beta = 2.5$，扫描次数 $T=2000$，随机种子 $314159$。\n- 测试用例 2（边界情况，无可变单元格）：$b=3$（因此 $n=9$），实例\n  $$\n  \\begin{bmatrix}\n  5  3  4  6  7  8  9  1  2\\\\\n  6  7  2  1  9  5  3  4  8\\\\\n  1  9  8  3  4  2  5  6  7\\\\\n  8  5  9  7  6  1  4  2  3\\\\\n  4  2  6  8  5  3  7  9  1\\\\\n  7  1  3  9  2  4  8  5  6\\\\\n  9  6  1  5  3  7  2  8  4\\\\\n  2  8  7  4  1  9  6  3  5\\\\\n  3  4  5  2  8  6  1  7  9\n  \\end{bmatrix}\n  $$\n  逆温 $\\beta = 1.0$，扫描次数 $T=10$，随机种子 $123$。\n- 测试用例 3（边缘情况，零次扫描）：$b=2$（因此 $n=4$），实例\n  $$\n  \\begin{bmatrix}\n  1  0  0  2\\\\\n  0  2  1  0\\\\\n  0  4  0  1\\\\\n  3  0  2  0\n  \\end{bmatrix}\n  $$\n  逆温 $\\beta = 1.0$，扫描次数 $T=0$，随机种子 $999$。\n\n您的程序必须按顺序计算这三个测试用例的整数最小能量 $E_{\\min}$，并生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如 $[x_1,x_2,x_3]$。不涉及角度或物理量，因此不需要物理单位。所有角度（如果在内部使用）必须以弧度处理，但该问题不需要任何角度计算。每个输出都必须是整数。", "solution": "所呈现的问题是计算物理学中一个明确定义的练习，具体而言是应用一种类似于模拟退火的马尔可夫链蒙特卡洛（MCMC）方法，来寻找一个系统的低能构型。所讨论的系统是一个数独谜题，被映射到一个统计力学框架中。我的方法是首先验证问题的表述，然后构建一个对所述过程的直接模拟。\n\n**问题表述**\n\n系统的状态是一个构型 $X$，即一个 $n \\times n$ 的网格，其中 $n = b^2$，它源自一个给定的数独实例。状态空间是受约束的：对于任何构型， $n$ 个不同的 $b \\times b$ 宫中的每一个都必须包含一个完整的数字集合 $\\{1, 2, \\dots, n\\}$。这是一个关键约束，它简化了系统的能量。\n\n能量函数 $E(X)$ 定义为：\n$$\nE(X) = \\sum_{r=1}^{n} \\left(n - \\left|\\{\\text{distinct digits in row } r\\}\\right|\\right) + \\sum_{c=1}^{n} \\left(n - \\left|\\{\\text{distinct digits in column } c\\}\\right|\\right) + \\sum_{B=1}^{n} \\left(b^2 - \\left|\\{\\text{distinct digits in box } B\\}\\right|\\right)\n$$\n根据状态空间的定义，每个构型 $X$ 都必须满足条件：任何宫 $B$ 内的数字多重集均为 $\\{1, 2, \\dots, n\\}$。这意味着对于任何宫 $B$，不同数字的集合基数为 $n$。由于 $n=b^2$，第三个求和中每个宫的项为 $b^2 - \\left|\\{\\text{宫 B 内的不同数字}\\}\\right| = n - n = 0$。因此，能量函数简化为仅对行和列的缺陷求和：\n$$\nE(X) = \\sum_{r=1}^{n} \\left(n - \\left|\\{\\text{distinct digits in row } r\\}\\right|\\right) + \\sum_{c=1}^{n} \\left(n - \\left|\\{\\text{distinct digits in column } c\\}\\right|\\right)\n$$\n一个构型 $X$ 对应一个有效的数独解，当且仅当 $E(X) = 0$。目标是找到在指定时长的模拟过程中遇到的最小能量 $E_{\\min}$。\n\n**模拟算法：Metropolis-Hastings**\n\n该模拟采用 Metropolis-Hastings 算法来探索状态空间。该过程由一个逆温 $\\beta  0$ 控制。\n\n1.  **初始化**：\n    模拟从一个初始构型 $X_0$ 开始。该构型是通过取给定的数独实例，并对每个宫独立地操作，用完成该宫的数字集合 $\\{1, 2, \\dots, n\\}$ 所需的数字的一个均匀随机排列来填充未指定的单元格（标记为 $0$）。使用特定种子初始化的伪随机数生成器（PRNG）确保了可复现性。计算初始能量 $E(X_0)$，并将观测到的最小能量初始化为 $E_{\\min} = E(X_0)$。\n\n2.  **马尔可夫链演化**：\n    模拟总共进行 $T$ 次扫描，其中一次扫描包含 $n \\times n$ 次提议尝试。对于每次尝试：\n    a. **提议**：从当前构型 $X$ 提议一个新的构型 $Y$。从 $n$ 个可能性中均匀随机选择一个宫。然后，在该宫内均匀随机选择一对不同的、非提示数字的单元格。交换它们的值以产生 $Y$。如果所选的宫包含少于两个非提示数字的单元格，则无法进行交换，提议实际上失败，构型仍为 $X$。这仍然算作一次尝试。\n    b. **接受**：从 $X$ 到 $Y$ 的转移是否被接受，取决于能量的变化 $\\Delta E = E(Y) - E(X)$。接受概率 $P(X \\to Y)$ 由 Metropolis 准则给出：\n       $$\n       P_{\\text{accept}}(X \\to Y) = \\min\\left\\{1, e^{-\\beta \\Delta E}\\right\\}\n       $$\n       如果移动被接受，新状态变为 $Y$。如果被拒绝，状态保持为 $X$。\n    c. **能量追踪**：每次尝试后（无论状态是否改变），将当前能量 $E_{\\text{current}}$ 与迄今为止找到的最小能量 $E_{\\min}$ 进行比较，并在必要时更新 $E_{\\min}$：$E_{\\min} = \\min(E_{\\min}, E_{\\text{current}})$。\n\n**实现细节**\n\n该算法在一个类结构中实现，以管理每个模拟实例的状态。\n\n-   **数据结构**：数独网格由一个 NumPy 整数数组表示。一个相同维度的布尔数组用于标记初始实例中固定提示数字的位置，以防止它们被修改。一个列表的列表存储每个宫的可变（非提示数字）单元格的坐标，以方便高效地生成提议。\n\n-   **能量计算**：一个函数 `calculate_energy(grid)` 实现了简化的能量公式。对于 $n$ 行和 $n$ 列中的每一行/列，它计算唯一元素的数量，并将差额 $n - |\\text{唯一元素}|$ 加到总和中。鉴于测试用例中 $n$ 的规模较小（$4$ 或 $9$），重新计算提议状态的全部能量在计算上是可行的，并且比增量式 $\\Delta E$ 计算更能避免实现错误。\n\n-   **模拟循环**：主循环运行 $T \\times n \\times n$ 次迭代。在每次迭代中，它执行所述的提议和接受步骤。特殊情况会得到妥善处理：\n    - 如果 $T=0$，模拟不运行。结果就是随机生成的初始构型的能量。\n    - 如果测试用例提供了一个完全指定的网格（没有空格），则永远不可能进行交换。构型保持不变，结果是其初始能量。\n\n每个测试用例开始时都会对伪随机数生成器（PRNG）进行播种，以确保确定性和可验证的结果。每个测试用例的最终输出是在整个模拟轨迹中找到的 $E_{\\min}$ 的整数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SudokuMCMCSimulator:\n    \"\"\"\n    Implements a Markov Chain Monte Carlo simulation for a Sudoku-like problem.\n    \"\"\"\n    def __init__(self, b: int, instance: list[list[int]], beta: float, seed: int):\n        self.b = int(b)\n        self.n = self.b * self.b\n        self.beta = float(beta)\n        self.rng = np.random.default_rng(seed)\n\n        self.grid = np.array(instance, dtype=np.int32)\n        self.is_clue = self.grid != 0\n\n        self._initialize_configuration()\n        self._precompute_mutable_cells()\n\n    def _initialize_configuration(self):\n        \"\"\"\n        Fills the unspecified (0) cells of the grid to create a valid initial configuration.\n        Each box is filled independently with a random permutation of missing numbers.\n        \"\"\"\n        all_digits = set(range(1, self.n + 1))\n        for box_r in range(self.b):\n            for box_c in range(self.b):\n                r_start, c_start = box_r * self.b, box_c * self.b\n                box_slice = slice(r_start, r_start + self.b), slice(c_start, c_start + self.b)\n                box_view = self.grid[box_slice]\n\n                clues_in_box = set(box_view[box_view != 0])\n                missing_digits = list(all_digits - clues_in_box)\n                self.rng.shuffle(missing_digits)\n\n                unassigned_indices = np.argwhere(box_view == 0)\n                for (local_r, local_c), digit in zip(unassigned_indices, missing_digits):\n                    self.grid[r_start + local_r, c_start + local_c] = digit\n\n    def _precompute_mutable_cells(self):\n        \"\"\"\n        Identifies all non-clue cells and groups them by their box index.\n        \"\"\"\n        self.mutable_cells_by_box = [[] for _ in range(self.n)]\n        for r in range(self.n):\n            for c in range(self.n):\n                if not self.is_clue[r, c]:\n                    box_idx = (r // self.b) * self.b + (c // self.b)\n                    self.mutable_cells_by_box[box_idx].append((r, c))\n\n    def calculate_energy(self, grid: np.ndarray) -> int:\n        \"\"\"\n        Calculates the energy of a given grid configuration.\n        The box energy term is always zero by construction, so it is omitted.\n        \"\"\"\n        energy = 0\n        # Row conflicts\n        for r in range(self.n):\n            energy += self.n - len(np.unique(grid[r, :]))\n        # Column conflicts\n        for c in range(self.n):\n            energy += self.n - len(np.unique(grid[:, c]))\n        return int(energy)\n\n    def run_simulation(self, T: int) -> int:\n        \"\"\"\n        Runs the MCMC simulation for T sweeps and returns the minimum energy found.\n        \"\"\"\n        initial_energy = self.calculate_energy(self.grid)\n        if T == 0:\n            return initial_energy\n\n        num_proposals = int(T * self.n * self.n)\n        \n        current_grid = self.grid.copy()\n        current_energy = initial_energy\n        min_energy = initial_energy\n\n        for _ in range(num_proposals):\n            # 1. Select a box uniformly at random\n            box_idx = self.rng.integers(0, self.n)\n            \n            mutable_coords = self.mutable_cells_by_box[box_idx]\n            \n            # 2. If swap is not possible, proposal fails. Continue to next attempt.\n            if len(mutable_coords)  2:\n                continue\n\n            # 3. Propose a swap of two distinct, non-clue cells within the box\n            cell_indices = self.rng.choice(len(mutable_coords), 2, replace=False)\n            (r1, c1) = mutable_coords[cell_indices[0]]\n            (r2, c2) = mutable_coords[cell_indices[1]]\n            \n            proposed_grid = current_grid.copy()\n            proposed_grid[r1, c1], proposed_grid[r2, c2] = proposed_grid[r2, c2], proposed_grid[r1, c1]\n            \n            new_energy = self.calculate_energy(proposed_grid)\n            delta_E = new_energy - current_energy\n\n            # 4. Metropolis-Hastings acceptance criterion\n            accept = False\n            if delta_E = 0:\n                accept = True\n            else:\n                if self.rng.random()  np.exp(-self.beta * delta_E):\n                    accept = True\n            \n            if accept:\n                current_grid = proposed_grid\n                current_energy = new_energy\n            \n            if current_energy  min_energy:\n                min_energy = current_energy\n        \n        return min_energy\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {\n            \"b\": 2,\n            \"instance\": [\n                [0, 0, 3, 4],\n                [3, 4, 0, 0],\n                [0, 1, 4, 0],\n                [4, 0, 0, 1]\n            ],\n            \"beta\": 2.5,\n            \"T\": 2000,\n            \"seed\": 314159\n        },\n        {\n            \"b\": 3,\n            \"instance\": [\n                [5, 3, 4, 6, 7, 8, 9, 1, 2],\n                [6, 7, 2, 1, 9, 5, 3, 4, 8],\n                [1, 9, 8, 3, 4, 2, 5, 6, 7],\n                [8, 5, 9, 7, 6, 1, 4, 2, 3],\n                [4, 2, 6, 8, 5, 3, 7, 9, 1],\n                [7, 1, 3, 9, 2, 4, 8, 5, 6],\n                [9, 6, 1, 5, 3, 7, 2, 8, 4],\n                [2, 8, 7, 4, 1, 9, 6, 3, 5],\n                [3, 4, 5, 2, 8, 6, 1, 7, 9]\n            ],\n            \"beta\": 1.0,\n            \"T\": 10,\n            \"seed\": 123\n        },\n        {\n            \"b\": 2,\n            \"instance\": [\n                [1, 0, 0, 2],\n                [0, 2, 1, 0],\n                [0, 4, 0, 1],\n                [3, 0, 2, 0]\n            ],\n            \"beta\": 1.0,\n            \"T\": 0,\n            \"seed\": 999\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        simulator = SudokuMCMCSimulator(\n            b=case[\"b\"],\n            instance=case[\"instance\"],\n            beta=case[\"beta\"],\n            seed=case[\"seed\"]\n        )\n        min_energy = simulator.run_simulation(T=case[\"T\"])\n        results.append(min_energy)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2411684"}]}