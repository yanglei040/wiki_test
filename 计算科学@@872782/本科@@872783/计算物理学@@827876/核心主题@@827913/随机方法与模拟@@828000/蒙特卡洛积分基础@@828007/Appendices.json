{"hands_on_practices": [{"introduction": "蒙特卡洛积分的强大之处在于其处理高维复杂问题的能力，尤其是在几何体积计算方面。当解析方法难以奏效时，该方法提供了一个直观且有效的数值解决方案。本练习将引导你使用经典的“命中或脱靶”蒙特卡洛方法来估算三维空间中点云的凸包体积，这是一个在计算几何和物理模拟中常见的任务 [@problem_id:2414597]。", "problem": "考虑使用蒙特卡洛（MC）积分来估计三维空间中凸包体积的问题。令 $d=3$。设 $\\mathcal{P}=\\{\\mathbf{p}_i\\}_{i=1}^n \\subset [0,1]^3$ 是一个有限点集，并用 $\\mathrm{conv}(\\mathcal{P})$ 表示其凸包。目标是估计体积 $V(\\mathrm{conv}(\\mathcal{P}))$。完全在纯数学术语下进行，不涉及物理单位。如果出现任何角度，必须以弧度为单位，但此处未使用角度。\n\n从以下基本原理出发：对于任何可测集 $S \\subseteq [0,1]^3$，$S$ 的体积是积分 $V(S)=\\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$，其中 $\\mathbf{1}_S$ 是 $S$ 的指示函数。这个恒等式将勒贝格测度与 $[0,1]^3$ 上均匀分布的期望联系起来。\n\n任务：\n- 从上述基础和蒙特卡洛（MC）积分的第一性原理出发，推导一个用于 $V(\\mathrm{conv}(\\mathcal{P}))$ 的估计量，该估计量使用 $N$ 个从 $[0,1]^3$ 中均匀抽取的独立同分布样本 $\\{\\mathbf{X}_k\\}_{k=1}^N$，以及一个用于 $\\mathrm{conv}(\\mathcal{P})$ 的半空间形式的多面体内点判定。清晰地陈述确保无偏性的假设，并推导方差作为 $N$ 和 $V(\\mathrm{conv}(\\mathcal{P}))$ 的函数。此推导中不得使用任何捷径公式。\n- 实现一个完整、可运行的程序，为每个测试用例执行以下操作：\n  - 通过在 $[0,1]^3$ 中使用指定的随机种子进行均匀采样，或使用单位立方体的8个顶点来构造 $\\mathcal{P}$。\n  - 使用一个鲁棒的凸包例程计算 $\\mathrm{conv}(\\mathcal{P})$ 的半空间表示。\n  - 在 $[0,1]^3$ 中使用指定的随机种子生成 $N$ 个独立同分布的均匀样本，评估其是否属于 $\\mathrm{conv}(\\mathcal{P})$ 的指示函数，并计算体积的蒙特卡洛估计值。\n  - 为每个测试用例返回一个浮点数形式的估计值，四舍五入到6位小数。\n\n测试套件：\n- 案例1（理想情况，大 $N$）：$\\mathcal{P}$ 是使用种子 $s_p=2025$ 在 $[0,1]^3$ 中均匀采样的 $n=100$ 个点。使用 $N=100000$ 个蒙特卡洛样本，种子为 $s_m=314159$。\n- 案例2（方差压力测试，小 $N$）：与案例1相同的 $\\mathcal{P}$。使用 $N=5000$ 个蒙特卡洛样本，种子为 $s_m=271828$。\n- 案例3（不同点云，大 $N$）：$\\mathcal{P}$ 是使用种子 $s_p=42$ 在 $[0,1]^3$ 中均匀采样的 $n=100$ 个点。使用 $N=100000$ 个蒙特卡洛样本，种子为 $s_m=123456$。\n- 案例4（边界覆盖，完整立方体）：$\\mathcal{P}$ 等于 $[0,1]^3$ 中单位立方体的8个顶点。使用 $N=200000$ 个蒙特卡洛样本，种子为 $s_m=13579$。\n\n答案规范和输出格式：\n- 对于每个案例，输出 $V(\\mathrm{conv}(\\mathcal{P}))$ 的蒙特卡洛估计值，格式为浮点数，四舍五入到6位小数。\n- 将案例1到4的结果按顺序汇总到单行输出中，结果为逗号分隔的列表，并用方括号括起来，不含空格，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是一个四舍五入到6位小数的浮点数。", "solution": "问题陈述已经过分析，并被认为是有效的。它自成体系、提法恰当，并且在蒙特卡洛方法和计算几何的既定原则上具有科学依据。它提出了一个清晰、客观的任务，可以通过严谨的数学推导和计算实现来解决。我们现在开始进行解答。\n\n问题的核心是估计一个凸集 $S = \\mathrm{conv}(\\mathcal{P})$ 的体积，其中 $S$ 是单位立方体 $[0,1]^3$ 的一个子集。体积 $V(S)$ 由指示函数 $\\mathbf{1}_S(\\mathbf{x})$ 在单位立方体上的勒贝格积分定义：\n$$V(S) = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x})\\,\\mathrm{d}\\mathbf{x}$$\n其中，如果 $\\mathbf{x} \\in S$，则 $\\mathbf{1}_S(\\mathbf{x}) = 1$；如果 $\\mathbf{x} \\notin S$，则 $\\mathbf{1}_S(\\mathbf{x}) = 0$。\n\n这个积分可以解释为函数 $g(\\mathbf{X}) = \\mathbf{1}_S(\\mathbf{X})$ 的期望，其中 $\\mathbf{X}$ 是从 $[0,1]^3$ 上的均匀分布中抽取的随机变量。该分布的概率密度函数（PDF）为：当 $\\mathbf{x} \\in [0,1]^3$ 时 $f(\\mathbf{x}) = 1$，否则 $f(\\mathbf{x}) = 0$。因此，期望为：\n$$E[\\mathbf{1}_S(\\mathbf{X})] = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x}) f(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x} = \\int_{[0,1]^3} \\mathbf{1}_S(\\mathbf{x}) \\cdot 1 \\,\\mathrm{d}\\mathbf{x} = V(S)$$\n这个恒等式是解决此问题的蒙特卡洛方法的基础。\n\n根据大数定律，一个随机变量的期望可以通过大量独立同分布 (i.i.d.) 样本的样本均值来近似。设 $\\{\\mathbf{X}_k\\}_{k=1}^N$ 是从 $[0,1]^3$ 中均匀抽取的 $N$ 个此类样本。随机变量 $\\mathbf{1}_S(\\mathbf{X})$ 的样本均值为体积 $V(S)$ 提供了一个估计量 $\\hat{V}_N$：\n$$\\hat{V}_N = \\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)$$\n这个估计量被称为“击中或错过”蒙特卡洛估计量。它代表落入集合 $S$ 内部的随机点的比例，乘以采样域的体积（在这种情况下为1）。\n\n我们必须分析这个估计量的统计特性，特别是其偏差和方差。\n\n如果估计量 $\\hat{V}_N$ 的期望值等于真实体积，即 $E[\\hat{V}_N] = V(S)$，则该估计量是无偏的。我们利用期望的线性性质来验证这一点：\n$$E[\\hat{V}_N] = E\\left[\\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)\\right] = \\frac{1}{N} \\sum_{k=1}^N E[\\mathbf{1}_S(\\mathbf{X}_k)]$$\n假设样本 $\\{\\mathbf{X}_k\\}$ 是同分布的。因此，对于所有 $k$，$E[\\mathbf{1}_S(\\mathbf{X}_k)]$ 是一个常数，等于 $E[\\mathbf{1}_S(\\mathbf{X})] = V(S)$。将此代入方程中得到：\n$$E[\\hat{V}_N] = \\frac{1}{N} \\sum_{k=1}^N V(S) = \\frac{1}{N} \\cdot N \\cdot V(S) = V(S)$$\n该估计量确实是无偏的。该性质的关键假设是样本从正确的 $[0,1]^3$ 上的均匀分布中抽取。\n\n接下来，我们推导估计量的方差 $\\mathrm{Var}(\\hat{V}_N)$。估计量的方差量化了与均值的期望平方偏差，是衡量估计量精度的指标。样本 $\\{\\mathbf{X}_k\\}$ 是独立的这一假设允许我们声明和的方差是方差的和：\n$$\\mathrm{Var}(\\hat{V}_N) = \\mathrm{Var}\\left(\\frac{1}{N} \\sum_{k=1}^N \\mathbf{1}_S(\\mathbf{X}_k)\\right) = \\frac{1}{N^2} \\sum_{k=1}^N \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}_k))$$\n因为样本是同分布的，方差项 $\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}_k))$ 对所有 $k$ 都是常数。设其为 $\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}))$。表达式简化为：\n$$\\mathrm{Var}(\\hat{V}_N) = \\frac{1}{N^2} \\cdot N \\cdot \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X})) = \\frac{1}{N} \\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X}))$$\n随机变量 $Y = \\mathbf{1}_S(\\mathbf{X})$ 是一个伯努利变量，因为它只取两个值：$1$（“击中”）或 $0$（“错过”）。击中的概率是 $p = P(Y=1) = P(\\mathbf{X} \\in S)$。如前所述，这个概率等于体积 $V(S)$。参数为 $p$ 的伯努利变量的方差由 $p(1-p)$ 给出。因此：\n$$\\mathrm{Var}(\\mathbf{1}_S(\\mathbf{X})) = V(S)(1 - V(S))$$\n将此结果代入估计量方差的方程中，我们得到最终表达式：\n$$\\mathrm{Var}(\\hat{V}_N) = \\frac{V(S)(1 - V(S))}{N}$$\n这个结果表明蒙特卡洛估计的方差与样本数量 $N$ 成反比。因此，标准误差 $\\sigma_{\\hat{V}_N} = \\sqrt{\\mathrm{Var}(\\hat{V}_N)}$ 的缩放级别为 $1/\\sqrt{N}$，这是标准蒙特卡洛积分的典型收敛速度。当 $V(S) = 0.5$ 时方差最大，并且随着体积接近 $0$ 或 $1$ 而减小。\n\n为了实现这一点，需要一个多面体内点测试。一个凸多面体，如 $\\mathrm{conv}(\\mathcal{P})$，可以表示为有限个半空间的交集。每个半空间由一个形如 $\\mathbf{a}_j \\cdot \\mathbf{x} + b_j \\le 0$ 的不等式定义，其中 $\\mathbf{a}_j$ 是第 $j$ 个小平面（facet plane）的法向量，$b_j$ 是偏移量。一个点 $\\mathbf{x}$ 在凸包内部，当且仅当它同时满足所有这些不等式。这为评估每个样本点 $\\mathbf{X}_k$ 的 $\\mathbf{1}_S(\\mathbf{X}_k)$ 提供了一种直接方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.spatial import ConvexHull\nimport itertools\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo volume estimation problem for the given test cases.\n    \"\"\"\n\n    def estimate_volume(hull, N, seed_m):\n        \"\"\"\n        Estimates the volume of a convex hull using Monte Carlo integration.\n        \n        Args:\n            hull (scipy.spatial.ConvexHull): The convex hull object.\n            N (int): The number of Monte Carlo samples.\n            seed_m (int): The random seed for Monte Carlo samples.\n\n        Returns:\n            float: The estimated volume.\n        \"\"\"\n        # Generate N samples uniformly from the [0,1]^3 cube\n        rng_mc = np.random.default_rng(seed_m)\n        mc_samples = rng_mc.random((N, 3))\n\n        # The hull is defined by a set of half-spaces Ax + b = 0.\n        # A is hull.equations[:, :3] and b is hull.equations[:, 3].\n        # The normals in hull.equations point outwards from the hull.\n        A = hull.equations[:, :3]\n        b = hull.equations[:, 3]\n\n        # For each sample point, evaluate all plane equations.\n        # A point is inside if it satisfies all inequalities.\n        # Use a small tolerance for floating point comparisons.\n        is_inside = np.all(mc_samples @ A.T + b = 1e-12, axis=1)\n        \n        # The number of \"hits\" is the sum of boolean `is_inside` array.\n        hits = np.sum(is_inside)\n\n        # The volume estimate is the ratio of hits to total samples,\n        # since the bounding box volume is 1.\n        volume_estimate = hits / N\n        \n        return volume_estimate\n\n    test_cases = [\n        # (n, s_p, N, s_m, use_cube_vertices)\n        (100, 2025, 100000, 314159, False),\n        (100, 2025, 5000, 271828, False),\n        (100, 42, 100000, 123456, False),\n        (8, None, 200000, 13579, True),\n    ]\n\n    results = []\n    \n    # Pre-compute hull for cases 1 and 2 as they share the same point cloud\n    rng_points_c12 = np.random.default_rng(2025)\n    points_c12 = rng_points_c12.random((100, 3))\n    hull_c12 = ConvexHull(points_c12)\n\n    # Case 1\n    n1, s_p1, N1, s_m1, _ = test_cases[0]\n    vol1 = estimate_volume(hull_c12, N1, s_m1)\n    results.append(round(vol1, 6))\n\n    # Case 2\n    n2, s_p2, N2, s_m2, _ = test_cases[1]\n    vol2 = estimate_volume(hull_c12, N2, s_m2)\n    results.append(round(vol2, 6))\n\n    # Case 3\n    n3, s_p3, N3, s_m3, _ = test_cases[2]\n    rng_points_c3 = np.random.default_rng(s_p3)\n    points_c3 = rng_points_c3.random((n3, 3))\n    hull_c3 = ConvexHull(points_c3)\n    vol3 = estimate_volume(hull_c3, N3, s_m3)\n    results.append(round(vol3, 6))\n\n    # Case 4\n    n4, s_p4, N4, s_m4, use_cube = test_cases[3]\n    # Generate the 8 vertices of the unit cube\n    points_c4 = np.array(list(itertools.product([0, 1], repeat=3)), dtype=float)\n    hull_c4 = ConvexHull(points_c4)\n    vol4 = estimate_volume(hull_c4, N4, s_m4)\n    results.append(round(vol4, 6))\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2414597"}, {"introduction": "蒙特卡洛方法的应用远不止于几何计算，它在处理涉及不确定性和随机性的概率问题时同样表现出色。本实践将模拟一个真实的工业制造场景，通过抽样随机变化的零件和夹具尺寸来估算生产流程的合格率。这个练习不仅展示了如何将积分思想应用于概率空间，还揭示了蒙特卡洛方法在工程风险分析和质量控制中的巨大价值 [@problem_id:2414629]。", "problem": "一个矩形制造零件必须能够装入一个矩形夹具中。该零件具有随机的宽度和高度，而夹具则具有随机的槽宽和槽高。所有尺寸均以毫米 (mm) 为单位。当且仅当零件的宽度小于或等于槽宽，并且零件的高度小于或等于槽高时，单次试验才能成功装配。设零件宽度为随机变量 $W_{p}$，零件高度为 $H_{p}$，槽宽为 $W_{s}$，槽高为 $H_{s}$。假设 $W_{p}$ 和 $H_{p}$ 相互独立，$W_{s}$ 和 $H_{s}$ 相互独立，并且所有零件变量与所有夹具变量均相互独立。工艺良率是一个随机零件能装入一个随机夹具的概率，即事件 $\\{W_{p} \\leq W_{s} \\text{ and } H_{p} \\leq H_{s}\\}$ 的概率。\n\n请从期望的积分概率定义和指示函数的定义出发，设计一个用于计算良率的蒙特卡洛估计量。您必须使用这些定义来推导您的估计量。将您的估计量实现为一个完整、可运行的程序，该程序：\n- 使用伪随机抽样来估计以下每个测试用例的良率。\n- 使用固定种子 $s=12345$ 以确保可复现性。\n- 每个测试用例使用 $N=400000$ 个独立样本。\n- 将每个良率报告为小数值（而非百分比）。\n- 将结果打印到小数点后六位。\n\n测试套件（每个用例指定了 $(W_{p},H_{p},W_{s},H_{s})$ 的分布）：\n- 用例 A（理想情况，全为正态分布）：\n  - $W_{p} \\sim \\mathcal{N}(50.0,\\,0.1^{2})$, $H_{p} \\sim \\mathcal{N}(10.0,\\,0.05^{2})$, \n  - $W_{s} \\sim \\mathcal{N}(50.15,\\,0.08^{2})$, $H_{s} \\sim \\mathcal{N}(10.10,\\,0.04^{2})$.\n- 用例 B（边界情况，对称正态分布）：\n  - $W_{p} \\sim \\mathcal{N}(30.0,\\,0.2^{2})$, $H_{p} \\sim \\mathcal{N}(20.0,\\,0.2^{2})$,\n  - $W_{s} \\sim \\mathcal{N}(30.0,\\,0.2^{2})$, $H_{s} \\sim \\mathcal{N}(20.0,\\,0.2^{2})$.\n- 用例 C（低良率，负平均间隙）：\n  - $W_{p} \\sim \\mathcal{N}(40.2,\\,0.1^{2})$, $H_{p} \\sim \\mathcal{N}(15.1,\\,0.1^{2})$,\n  - $W_{s} \\sim \\mathcal{N}(40.1,\\,0.1^{2})$, $H_{s} \\sim \\mathcal{N}(15.0,\\,0.1^{2})$.\n- 用例 D（均匀分布公差）：\n  - $W_{p} \\sim \\mathcal{U}[99.0,\\,101.0]$, $H_{p} \\sim \\mathcal{U}[49.0,\\,51.0]$,\n  - $W_{s} \\sim \\mathcal{U}[100.0,\\,102.0]$, $H_{s} \\sim \\mathcal{U}[50.0,\\,51.0]$.\n\n不涉及角度单位。所有物理单位均为毫米 (mm)。您的实现不得截断或限制采样值；请使用所述的分布。\n\n最终输出格式：您的程序应生成单行输出，其中包含四个估计的良率，按 A、B、C、D 的顺序排列，形式为用方括号括起来的逗号分隔列表（例如，`[$result_A,$result_B,$result_C,$result_D$]`），其中每个结果都是一个四舍五入到小数点后六位的浮点数。", "solution": "问题陈述已经过验证，被认为是有效的。它在概率论和统计学方面有科学依据，定义了所有必要的参数，问题设定良好且客观。该任务是蒙特卡洛方法在估计概率方面的标准应用，这是计算物理学和工程学中的一个核心课题。我们将继续提供完整的解决方案。\n\n问题要求估算制造工艺良率 $Y$。良率被定义为一个随机制造的零件能装入一个随机夹具的概率。设零件尺寸为随机变量 $W_{p}$（宽度）和 $H_{p}$（高度），夹具槽尺寸为 $W_{s}$（宽度）和 $H_{s}$（高度）。当且仅当两个条件同时满足时，装配才算成功：$W_{p} \\leq W_{s}$ 且 $H_{p} \\leq H_{s}$。\n\n问题陈述指出，所有四个随机变量 $W_{p}$、$H_{p}$、$W_{s}$ 和 $H_{s}$ 都是相互独立的。设这些变量的概率密度函数 (PDF) 分别为 $p_{W_p}(w_p)$、$p_{H_p}(h_p)$、$p_{W_s}(w_s)$ 和 $p_{H_s}(h_s)$。系统的状态可以用一个四维随机向量 $\\mathbf{X} = (W_p, H_p, W_s, H_s)$ 来描述。根据独立性假设，$\\mathbf{X}$ 的联合概率密度函数是各个独立概率密度函数的乘积：\n$$p(\\mathbf{x}) = p(w_p, h_p, w_s, h_s) = p_{W_p}(w_p) p_{H_p}(h_p) p_{W_s}(w_s) p_{H_s}(h_s)$$\n其中 $\\mathbf{x} = (w_p, h_p, w_s, h_s)$ 是随机向量 $\\mathbf{X}$ 的一个具体实现。\n\n良率 $Y$ 是成功事件的概率，我们将其表示为 $A$。事件 $A$ 是四维空间 $\\mathbb{R}^4$ 中所有满足 $w_p \\leq w_s$ 和 $h_p \\leq h_s$ 的结果 $\\mathbf{x}$ 的集合。概率 $Y = P(A)$ 的正式表达式为联合概率密度函数在事件 $A$ 定义的区域上的积分：\n$$Y = \\int \\int \\int \\int_{A} p(w_p, h_p, w_s, h_s) \\, dw_p \\, dh_p \\, dw_s \\, dh_s$$\n\n为了将其转换为适合蒙特卡洛估计的形式，我们引入一个指示函数 $\\mathbb{I}_{A}(\\mathbf{x})$。该函数定义如下：\n$$\n\\mathbb{I}_{A}(\\mathbf{x}) = \n\\begin{cases} \n1  \\text{if } w_p \\leq w_s \\text{ and } h_p \\leq h_s \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n使用指示函数，我们可以将良率 $Y$ 的积分重写为在整个状态空间 $\\Omega = \\mathbb{R}^4$ 上的积分：\n$$Y = \\int_{\\Omega} \\mathbb{I}_{A}(\\mathbf{x}) p(\\mathbf{x}) \\, d\\mathbf{x}$$\n根据定义，这个积分是指示函数 $\\mathbb{I}_{A}(\\mathbf{X})$ 关于概率分布 $p(\\mathbf{x})$ 的期望值：\n$$Y = E[\\mathbb{I}_{A}(\\mathbf{X})]$$\n\n蒙特卡洛方法通过使用从分布 $p(\\mathbf{x})$ 中抽取的 $N$ 个独立同分布 (i.i.d.) 的随机样本 $\\mathbf{x}^{(1)}, \\mathbf{x}^{(2)}, \\ldots, \\mathbf{x}^{(N)}$，计算函数在这些样本点上的值的样本均值，来为函数 $f(\\mathbf{X})$ 的期望值提供一个估计量。在我们的例子中，该函数为 $f(\\mathbf{X}) = \\mathbb{I}_{A}(\\mathbf{X})$。\n\n因此，良率的蒙特卡洛估计量 $\\hat{Y}_N$ 是指示函数的样本均值：\n$$\\hat{Y}_N = \\frac{1}{N} \\sum_{i=1}^{N} \\mathbb{I}_{A}(\\mathbf{x}^{(i)})$$\n这里，$\\mathbf{x}^{(i)} = (w_p^{(i)}, h_p^{(i)}, w_s^{(i)}, h_s^{(i)})$ 是从联合分布中抽取的第 $i$ 个随机样本。由于如果第 $i$ 个样本对应于成功装配，则 $\\mathbb{I}_{A}(\\mathbf{x}^{(i)})$ 为 1，否则为 0，所以总和 $\\sum_{i=1}^{N} \\mathbb{I}_{A}(\\mathbf{x}^{(i)})$ 就是成功装配的总次数，我们称之为 $N_{success}$。\n\n因此，估算良率的算法如下：\n1.  初始化一个成功计数器 $N_{success}$ 为 0。\n2.  生成 $N$ 个独立随机样本，其中每个样本 $i \\in \\{1, \\ldots, N\\}$ 包含从其指定分布中抽取的四个值 $(w_p^{(i)}, h_p^{(i)}, w_s^{(i)}, h_s^{(i)})$。对于本问题，$N = 400000$。\n3.  对于每个样本 $i$，评估装配条件：如果 $w_p^{(i)} \\leq w_s^{(i)}$ 并且 $h_p^{(i)} \\leq h_s^{(i)}$，则将 $N_{success}$ 加一。\n4.  估计的良率是 $\\hat{Y}_N = \\frac{N_{success}}{N}$。\n\n此过程将为指定的四个测试用例中的每一个实施。我们将使用固定的随机种子 $s=12345$ 以确保可复现性。对于给定为 $\\mathcal{N}(\\mu, \\sigma^2)$ 的分布，我们从均值为 $\\mu$、标准差为 $\\sigma$ 的正态分布中抽样。对于均匀分布 $\\mathcal{U}[a, b]$，我们从区间 $[a, b)$ 上的均匀分布中抽样。为提高效率，实现将使用 `numpy` 库进行向量化，一次性为四个变量中的每一个生成 $N$ 个样本，然后执行逐元素比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the manufacturing yield estimation problem using Monte Carlo simulation\n    for four different test cases.\n    \"\"\"\n    \n    # Define problem constants\n    SEED = 12345\n    NUM_SAMPLES = 400000\n\n    # Initialize the random number generator for reproducibility.\n    # The same generator instance is used across all test cases to ensure\n    # the entire output is reproducible from a single seed.\n    rng = np.random.default_rng(SEED)\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple of parameter tuples for (Wp, Hp, Ws, Hs).\n    # Each parameter tuple is (distribution_name, param1, param2).\n    # For 'norm': (mean, std_dev)\n    # For 'uniform': (low, high)\n    test_cases = [\n        # Case A (happy path, all normal)\n        (\n            ('norm', 50.0, 0.1), \n            ('norm', 10.0, 0.05),\n            ('norm', 50.15, 0.08), \n            ('norm', 10.10, 0.04)\n        ),\n        # Case B (boundary, symmetric normals)\n        (\n            ('norm', 30.0, 0.2), \n            ('norm', 20.0, 0.2), \n            ('norm', 30.0, 0.2), \n            ('norm', 20.0, 0.2)\n        ),\n        # Case C (low yield, negative mean clearance)\n        (\n            ('norm', 40.2, 0.1), \n            ('norm', 15.1, 0.1), \n            ('norm', 40.1, 0.1), \n            ('norm', 15.0, 0.1)\n        ),\n        # Case D (uniform tolerances)\n        (\n            ('uniform', 99.0, 101.0), \n            ('uniform', 49.0, 51.0), \n            ('uniform', 100.0, 102.0), \n            ('uniform', 50.0, 51.0)\n        )\n    ]\n\n    results = []\n    for case in test_cases:\n        wp_params, hp_params, ws_params, hs_params = case\n        \n        # Generate N samples for each of the four random variables\n        # using a vectorized approach for efficiency.\n        all_samples = []\n        for dist, p1, p2 in [wp_params, hp_params, ws_params, hs_params]:\n            if dist == 'norm':\n                # p1 is mean, p2 is standard deviation\n                samples = rng.normal(loc=p1, scale=p2, size=NUM_SAMPLES)\n            elif dist == 'uniform':\n                # p1 is low, p2 is high\n                samples = rng.uniform(low=p1, high=p2, size=NUM_SAMPLES)\n            all_samples.append(samples)\n            \n        wp_samples, hp_samples, ws_samples, hs_samples = all_samples\n\n        # Check the fit condition for all N samples in a vectorized manner.\n        # The condition is (Wp = Ws) AND (Hp = Hs).\n        # The result 'is_fit' is a boolean array.\n        is_fit = (wp_samples = ws_samples)  (hp_samples = hs_samples)\n\n        # The sum of the boolean array gives the total number of successful fits\n        # (True evaluates to 1, False to 0).\n        num_successes = np.sum(is_fit)\n\n        # The yield is the ratio of successful fits to the total number of samples.\n        yield_estimate = num_successes / NUM_SAMPLES\n        \n        # Format the result to six decimal places and append to the list.\n        results.append(f\"{yield_estimate:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2414629"}, {"introduction": "深入理解任何数值方法的理论基础和适用边界，是成为一名优秀计算科学家的关键。在掌握了蒙特卡洛积分的基本应用后，本次练习将引导你探索其理论边界。通过研究一个被积函数方差为无穷大的特殊情况，你将亲眼见证中心极限定理的失效，并理解为何有限方差是蒙特卡洛误差估计能够成立的关键前提 [@problem_id:2411534]。", "problem": "考虑单位区间上的一族积分，由下式给出\n$$ I(p) \\equiv \\int_{0}^{1} u^{p} \\, du, $$\n其中 $p$ 是一个满足 $p  -1$ 的实参数，以确保积分存在且有限。对于在 $[0,1]$ 上均匀分布的随机变量 $U$，定义被积函数为 $f_{p}(U) = U^{p}$。其精确值为\n$$ I(p) = \\frac{1}{p+1}. $$\n对于给定的样本量 $n \\in \\mathbb{N}$ 和批次数 $B \\in \\mathbb{N}$，考虑 $B$ 个独立的批次，每个批次包含从 $[0,1]$ 上的均匀分布中抽取的 $n$ 个独立样本 $U_{1},\\dots,U_{n}$。对于每个批次 $b \\in \\{1,\\dots,B\\}$，定义批次样本均值\n$$ \\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} f_{p}(U_{i}), $$\n和无偏批次样本方差\n$$ s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} \\left( f_{p}(U_{i}) - \\bar{f}_{b} \\right)^{2}, $$\n前提是 $n \\ge 2$。当 $n \\ge 2$ 时，定义名义 $95\\%$ 水平基于正态分布的半宽度\n$$ h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}. $$\n对于每个 $n \\ge 2$ 的批次 $b$，构建名义区间\n$$ \\left[ \\bar{f}_{b} - h_{b}, \\, \\bar{f}_{b} + h_{b} \\right]. $$\n设批次 $b$ 的覆盖指示符为 $C_{b} = 1$（如果 $I(p)$ 位于上述区间内）和 $C_{b} = 0$（否则）。如果 $n  2$，由于样本方差未定义，按惯例定义 $C_{b} = 0$。定义跨批次的经验覆盖分数为\n$$ \\widehat{\\mathrm{cov}} = \\frac{1}{B} \\sum_{b=1}^{B} C_{b}. $$\n请注意，对于 $p \\le -\\tfrac{1}{2}$，方差 $\\mathbb{V}[f_{p}(U)]$ 是无穷大的，因为\n$$ \\mathbb{E}\\left[ f_{p}(U)^{2} \\right] = \\int_{0}^{1} u^{2p} \\, du $$\n是发散的，尽管对于所有 $p  -1$，$I(p)$ 仍然是有限的。这种情况违反了中心极限定理（CLT）通常要求的有限方差条件，因此基于正态分布的名义误差界限可能会失效。\n\n您的任务是编写一个完整的程序，对于每个测试用例，生成经验覆盖分数 $\\widehat{\\mathrm{cov}}$（以小数形式表示）。每个测试用例指定 $(p, n, B, \\text{seed})$，其中 $\\text{seed}$ 用于初始化伪随机数生成器以确保可复现性。角度和物理单位不出现；无需单位转换。所有答案必须以小数形式表示。\n\n测试集：\n- 测试 $1$：$p = -\\tfrac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 17$。\n- 测试 $2$：$p = -0.6$，$n = 500$，$B = 200$，$\\text{seed} = 19$。\n- 测试 $3$：$p = \\tfrac{1}{2}$，$n = 500$，$B = 200$，$\\text{seed} = 23$。\n- 测试 $4$：$p = \\tfrac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 29$。\n- 测试 $5$：$p = -\\tfrac{1}{2}$，$n = 5000$，$B = 200$，$\\text{seed} = 31$。\n- 测试 $6$：$p = \\tfrac{1}{2}$，$n = 1$，$B = 200$，$\\text{seed} = 37$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试 1 到测试 6 的六个经验覆盖分数，按顺序排列，以逗号分隔并用方括号括起来，例如，\n$$ [x_{1},x_{2},x_{3},x_{4},x_{5},x_{6}]. $$", "solution": "问题陈述已经过评估，并被确定为有效。这是一个计算统计学中定义明确的问题，基于蒙特卡洛积分和假设检验的原理。定义清晰，参数完全指定，且其背景（探索中心极限定理的极限）在科学上是合理的。没有矛盾、歧义或事实错误。\n\n任务是执行蒙特卡洛模拟，以计算积分 $I(p) = \\int_{0}^{1} u^{p} \\, du$ 的名义 $95\\%$ 置信区间的经验覆盖分数。该模拟将检验覆盖行为如何随参数 $p$ 变化，该参数控制被积函数 $f_{p}(U) = U^{p}$（其中 $U \\sim \\text{Uniform}[0,1]$）的方差的有限性。\n\n已知积分的精确值为 $I(p) = \\frac{1}{p+1}$（对于 $p  -1$）。\n\n为计算由 $(p, n, B, \\text{seed})$ 指定的单个测试用例的经验覆盖分数 $\\widehat{\\mathrm{cov}}$，算法如下：\n\n1.  使用提供的整数 `seed` 初始化伪随机数生成器，以确保可复现性。\n2.  计算积分的真实值，我们将其表示为 $I_{true} = \\frac{1}{p+1}$。\n3.  对于样本量 $n$ 小于 2 的情况，给定了一个特定规则。如果 $n  2$，样本方差 $s_{b}^{2}$ 未定义。按照惯例，所有批次的覆盖指示符 $C_{b}$ 都设置为 $0$。因此，经验覆盖分数 $\\widehat{\\mathrm{cov}}$ 为 $0$。此情况的计算在此终止。\n4.  对于 $n \\ge 2$ 的主要情况，模拟将在 $B$ 个独立批次上进行。我们将维护一个计数器（初始化为零），用于记录置信区间覆盖真实值 $I_{true}$ 的批次数。\n5.  一种高效的方法是立即生成所有 $B$ 个批次所需的所有随机数。我们生成一个 $B \\times n$ 的独立随机变量矩阵，其中每个元素都从 $[0,1]$ 上的均匀分布中抽取。设该矩阵为 $\\mathbf{U}$，其元素为 $U_{b,i}$，其中批次 $b \\in \\{1, \\dots, B\\}$，样本索引 $i \\in \\{1, \\dots, n\\}$。\n6.  将被积函数 $f_{p}(u) = u^{p}$ 逐元素应用于矩阵 $\\mathbf{U}$，得到一个新矩阵 $\\mathbf{F}$，其元素为 $F_{b,i} = (U_{b,i})^{p}$。$\\mathbf{F}$ 的每一行对应单个批次的样本 $\\{f_{p}(U_{i})\\}_{i=1}^{n}$。\n7.  对于每个批次 $b$（即 $\\mathbf{F}$ 的每一行），我们计算所需的统计量：\n    a. 批次样本均值：$\\bar{f}_{b} = \\frac{1}{n} \\sum_{i=1}^{n} F_{b,i}$。这可以通过计算 $\\mathbf{F}$ 各行的均值来同时为所有批次计算。\n    b. 无偏批次样本方差：$s_{b}^{2} = \\frac{1}{n-1} \\sum_{i=1}^{n} (F_{b,i} - \\bar{f}_{b})^{2}$。这也可以通过计算 $\\mathbf{F}$ 各行的样本方差（使用单自由度校正，`ddof=1`）来为所有批次计算。\n8.  使用这些统计量，我们为每个批次计算名义 $95\\%$ 置信区间的半宽度：\n    $$h_{b} = 1.96 \\cdot \\frac{\\sqrt{s_{b}^{2}}}{\\sqrt{n}}$$\n    请注意，值 $1.96$ 是标准正态分布的 $0.975$ 分位数 $z_{0.025}$ 的近似值。\n9.  对于每个批次 $b$，我们确定置信区间 $[\\bar{f}_{b} - h_{b}, \\bar{f}_{b} + h_{b}]$ 是否包含真实值 $I_{true}$。这个条件等价于检验绝对误差 $|\\bar{f}_{b} - I_{true}|$ 是否小于或等于半宽度 $h_{b}$。\n10. 统计满足此条件的批次数。设此计数为 $N_{covered}$。\n11. 经验覆盖分数是覆盖区间数与总批次数的比率：\n    $$\\widehat{\\mathrm{cov}} = \\frac{N_{covered}}{B}$$\n对指定的六个测试用例中的每一个执行此过程。理论上预期，对于 $p  -1/2$（此时 $f_{p}(U)$ 的方差是有限的），中心极限定理成立，$\\widehat{\\mathrm{cov}}$ 应接近名义水平 $0.95$，尤其是在 $n$ 较大时。相反，对于 $p \\le -1/2$，方差是无穷大的，基于正态分布的置信区间的理论基础无效，我们预计 $\\widehat{\\mathrm{cov}}$ 将显著偏离 $0.95$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_coverage(p: float, n: int, B: int, seed: int) -> float:\n    \"\"\"\n    Computes the empirical coverage fraction for a given set of parameters.\n\n    Args:\n        p: The exponent parameter for the integrand u^p.\n        n: The sample size for each batch.\n        B: The number of batches.\n        seed: The seed for the random number generator.\n\n    Returns:\n        The empirical coverage fraction as a float.\n    \"\"\"\n    # Per the problem statement, for n  2, the sample variance is not defined,\n    # and the coverage indicator C_b is 0 by convention. Thus, the total\n    # empirical coverage is 0.\n    if n  2:\n        return 0.0\n\n    # Initialize the pseudorandom number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    # Calculate the exact value of the integral I(p) = 1/(p+1).\n    I_true = 1.0 / (p + 1.0)\n\n    # Generate all uniform random samples for all B batches at once.\n    # The shape of the resulting array is (B, n).\n    uniform_samples = rng.uniform(size=(B, n))\n\n    # Evaluate the integrand f_p(u) = u^p on the samples.\n    f_p_samples = uniform_samples**p\n\n    # Calculate batch means along axis 1 (across samples in a batch).\n    # The result is an array of shape (B,).\n    batch_means = np.mean(f_p_samples, axis=1)\n\n    # Calculate unbiased batch sample variances along axis 1.\n    # ddof=1 ensures the denominator is (n-1).\n    # The result is an array of shape (B,).\n    batch_variances = np.var(f_p_samples, axis=1, ddof=1)\n\n    # Calculate the half-width of the nominal 95% confidence interval for each batch.\n    # h_b = 1.96 * sqrt(s_b^2 / n)\n    # A small epsilon is not strictly necessary with standard floating point\n    # arithmetic as var >= 0, but good practice to consider. Here, it is omitted.\n    half_widths = 1.96 * np.sqrt(batch_variances / n)\n\n    # Determine for each batch if the true value is within the confidence interval.\n    # This is true if |sample_mean - true_value| = half_width.\n    # This operation returns a boolean array of shape (B,).\n    is_covered = np.abs(batch_means - I_true) = half_widths\n\n    # The empirical coverage is the mean of the boolean indicators (True=1, False=0).\n    coverage_fraction = np.mean(is_covered)\n\n    return coverage_fraction\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (p, n, B, seed)\n    test_cases = [\n        (-0.5, 500, 200, 17),    # Test 1\n        (-0.6, 500, 200, 19),    # Test 2\n        (0.5, 500, 200, 23),     # Test 3\n        (0.5, 5000, 200, 29),    # Test 4\n        (-0.5, 5000, 200, 31),   # Test 5\n        (0.5, 1, 200, 37),      # Test 6\n    ]\n\n    results = []\n    for p, n, B, seed in test_cases:\n        # Calculate the empirical coverage for the current test case.\n        result = compute_coverage(p, n, B, seed)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2411534"}]}