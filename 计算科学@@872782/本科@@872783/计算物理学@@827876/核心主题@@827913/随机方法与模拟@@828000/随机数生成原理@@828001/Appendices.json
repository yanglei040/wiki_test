{"hands_on_practices": [{"introduction": "随机性的核心挑战之一是确保其无偏性。本练习将向您展示一个深刻的原理：即使随机源本身存在缺陷（例如一枚不均匀的硬币），我们也可以通过巧妙的算法从中提取出完全无偏的随机结果。我们将实现经典的冯·诺依曼随机性提取器 [@problem_id:2433264]，通过具体的编码实践来揭示计算和信息论中的一个基本思想。", "problem": "给定一个模拟的带偏置硬币，其抛掷结果是独立同分布（i.i.d.）的。每次抛掷正面朝上的概率为 $p \\in (0,1)$，$p \\neq 0.5$，反之则为反面。您的任务是使用冯·诺依曼舍选法（von Neumann rejection method）从这个带偏置的硬币中提取无偏置的比特，并通过解析和数值两种方式验证其无偏性和效率。您编写的程序必须是一个完整、可运行的程序。为了保证可复现性，所有随机性必须由一个单一的、种子固定的随机数生成器（RNG）生成，种子固定为 $314159$。\n\n从以下基本原理出发：独立同分布伯努利试验的独立性、概率乘法法则、条件概率以及大数定律。\n\n实现以下内容：\n\n- 推导任务：\n  1. 考虑两次连续的独立硬币抛掷 $X_1$ 和 $X_2$，其中 $X_i \\in \\{0,1\\}$，$\\mathbb{P}(X_i = 1) = p$ 表示正面，$\\mathbb{P}(X_i = 0) = 1 - p$ 表示反面。冯·诺依曼提取器（von Neumann extractor）读取不重叠的配对 $(X_1, X_2), (X_3, X_4), \\dots$ 并执行以下操作：如果配对是 $(1,0)$，则将其解释为输出比特 $1$；如果配对是 $(0,1)$，则将其解释为输出比特 $0$；如果配对是 $(0,0)$ 或 $(1,1)$，则丢弃该配对且不产生输出。根据 $X_1$ 和 $X_2$ 的独立性以及基本概率法则，推导出一个比特从单个配对中产生的概率的通用表达式，并证明输出的比特是无偏置的，即其期望值为 $0.5$。\n  2. 从第一性原理出发，推导每个输入抛掷所产生的期望输出比特数的通用表达式。\n\n- 计算任务：\n  1. 实现一个函数，给定参数 $p$ 和偶数次抛掷 $N$（如果提供的是奇数 $N$，则丢弃最后一次抛掷以保持配对不重叠），使用一个单一的、种子固定的RNG模拟 $N$ 次带偏置的硬币抛掷，并应用冯·诺依曼提取器生成一个输出比特数组。所有测试用例的模拟都必须使用种子 $314159$，以保证结果的可复现性。\n  2. 对于下面的每个测试用例，计算：\n     - 提取比特的经验绝对偏置，定义为 $\\left|\\bar{Y} - 0.5\\right|$，其中 $\\bar{Y}$ 是提取比特的样本均值。如果未提取到任何比特，按惯例为此度量定义 $\\bar{Y} = 0.5$。\n     - 经验输出率（每个实际使用的输入抛掷所提取的比特数，其中使用的输入抛掷次数是 $\\leq N$ 的最大偶数）与您在推导步骤中得出的理论期望率之间的绝对误差。\n  3. 使用以下固定的参数值测试套件：\n     - 情况 1：$p = 0.2$, $N = 200000$。\n     - 情况 2：$p = 0.8$, $N = 200000$。\n     - 情况 3：$p = 0.01$, $N = 300000$。\n     - 情况 4：$p = 0.49$, $N = 200000$。\n\n- 最终输出格式：\n  您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对于上述顺序的每个测试用例，输出两个浮点数，四舍五入到 $6$ 位小数：首先是经验绝对偏置，然后是输出率的绝对误差。因此，最终输出必须按 $[\\text{bias}_1,\\text{rate\\_err}_1,\\text{bias}_2,\\text{rate\\_err}_2,\\text{bias}_3,\\text{rate\\_err}_3,\\text{bias}_4,\\text{rate\\_err}_4]$ 的顺序总共包含 $8$ 个浮点数。\n\n此问题不涉及物理单位，也不使用角度。所有结果均需以普通十进制数报告。程序不得读取任何输入，也不得写入除所要求的单行之外的任何输出。代码必须是完全自包含且可运行的。", "solution": "问题陈述需经过验证。\n\n步骤 1：提取已知条件\n- 一个模拟的带偏置硬币，其抛掷结果是独立同分布（i.i.d.）的。\n- 正面（记为 $1$）的概率为 $p$，其中 $p \\in (0,1)$ 且 $p \\neq 0.5$。反面（记为 $0$）的概率为 $1-p$。\n- 冯·诺依曼舍选法定义如下：对于不重叠的抛掷配对 $(X_{2k-1}, X_{2k})$，如果配对是 $(1,0)$，则输出比特 $1$；如果配对是 $(0,1)$，则输出比特 $0$；如果配对是 $(0,0)$ 或 $(1,1)$，则丢弃该配对。\n- 所有模拟都必须使用一个单一的、种子为 $314159$ 的随机数生成器（RNG）。\n- 使用的基本原理：独立同分布伯努利试验的独立性、概率乘法法则、条件概率以及大数定律。\n- 推导任务：\n  1. 推导单个配对产生一个输出比特的概率。\n  2. 证明输出的比特是无偏置的，即其期望值为 $0.5$。\n  3. 推导每个输入抛掷的期望输出比特数。\n- 计算任务：\n  1. 实现一个函数来模拟 $N$ 次抛掷（如果 $N$ 是奇数则为 $N-1$ 次）并应用提取器。\n  2. 对每个测试用例，计算经验绝对偏置 $|\\bar{Y} - 0.5|$（若未产生比特，则 $\\bar{Y}=0.5$）以及经验输出率与理论输出率之间的绝对误差。\n  3. 测试套件：\n     - 情况 1：$p = 0.2$, $N = 200000$。\n     - 情况 2：$p = 0.8$, $N = 200000$。\n     - 情况 3：$p = 0.01$, $N = 300000$。\n     - 情况 4：$p = 0.49$, $N = 200000$。\n- 输出格式：一个单行字符串 `[bias_1,rate_err_1,...,bias_4,rate_err_4]`，其中浮点数值四舍五入到 $6$ 位小数。\n\n步骤 2：使用提取的已知条件进行验证\n- **科学依据：**该问题描述了冯·诺依曼提取器，这是一种在计算物理学和计算机科学中用于随机性提取的、成熟且正确的算法。其基本原理是基础概率论。该问题在科学上是合理的。\n- **良态问题：**问题定义清晰。算法、输入和要求的输出都得到了明确的规定。由于RNG种子是固定的，因此可以保证得到唯一的数值结果。\n- **客观性：**问题以客观的、数学的术语陈述，没有任何主观性或模糊性。\n- **缺陷清单：**该问题没有违反任何列出的无效标准。它是完整的、一致的、现实的且可验证的。\n\n步骤 3：结论与行动\n该问题有效。将提供完整的解决方案。\n\n此问题的基础在于独立同分布伯努利试验的性质。设 $X_i$ 是一个随机变量，表示第 $i$ 次硬币抛掷的结果，其中 $X_i=1$ 表示正面，$X_i=0$ 表示反面。问题陈述 $\\mathbb{P}(X_i = 1) = p$ 且 $\\mathbb{P}(X_i = 0) = 1-p$ 对所有 $i$ 成立。各次抛掷是独立的。\n\n冯·诺依曼方法考虑不重叠的抛掷配对 $(X_1, X_2)$。由于独立性，一个配对的四种可能结果中每一种的概率由乘法法则给出：\n- $\\mathbb{P}(X_1=0, X_2=0) = \\mathbb{P}(X_1=0)\\mathbb{P}(X_2=0) = (1-p)(1-p) = (1-p)^2$\n- $\\mathbb{P}(X_1=0, X_2=1) = \\mathbb{P}(X_1=0)\\mathbb{P}(X_2=1) = (1-p)p$\n- $\\mathbb{P}(X_1=1, X_2=0) = \\mathbb{P}(X_1=1)\\mathbb{P}(X_2=0) = p(1-p)$\n- $\\mathbb{P}(X_1=1, X_2=1) = \\mathbb{P}(X_1=1)\\mathbb{P}(X_2=1) = p^2$\n\n这些概率的总和是 $(1-p)^2 + p(1-p) + p(1-p) + p^2 = (1-2p+p^2) + 2p - 2p^2 + p^2 = 1$，符合预期。\n\n首先，我们推导单次抛掷配对产生一个输出比特的概率。设 $E$ 为产生输出的事件。当结果为 $(0,1)$ 或 $(1,0)$ 时，该事件发生。这两个是互斥事件。因此，$E$ 的概率是它们各自概率的和：\n$$\n\\mathbb{P}(E) = \\mathbb{P}((X_1=0, X_2=1) \\cup (X_1=1, X_2=0)) = \\mathbb{P}(X_1=0, X_2=1) + \\mathbb{P}(X_1=1, X_2=0)\n$$\n代入上面推导出的概率：\n$$\n\\mathbb{P}(E) = p(1-p) + p(1-p) = 2p(1-p)\n$$\n这就是单个配对产生一个输出比特的概率的通用表达式。\n\n接下来，我们必须证明输出的比特（我们称之为 $Y$）是无偏置的。这意味着要证明 $\\mathbb{P}(Y=1) = \\mathbb{P}(Y=0) = 0.5$。$Y$ 的值是在事件 $E$ 发生的条件下确定的。\n根据该方法的定义，如果配对是 $(1,0)$，则 $Y=1$；如果配对是 $(0,1)$，则 $Y=0$。使用条件概率公式 $\\mathbb{P}(A|B) = \\mathbb{P}(A \\cap B)/\\mathbb{P}(B)$：\n$$\n\\mathbb{P}(Y=1) = \\mathbb{P}((X_1=1, X_2=0) | E) = \\frac{\\mathbb{P}((X_1=1, X_2=0) \\cap E)}{\\mathbb{P}(E)}\n$$\n由于事件 $(X_1=1, X_2=0)$ 是产生输出的一种情况，其与事件 $E$ 的交集 $(X_1=1, X_2=0) \\cap E$ 就是事件 $(X_1=1, X_2=0)$ 本身。因此：\n$$\n\\mathbb{P}(Y=1) = \\frac{\\mathbb{P}(X_1=1, X_2=0)}{\\mathbb{P}(E)} = \\frac{p(1-p)}{2p(1-p)}\n$$\n问题规定 $p \\in (0,1)$，这保证了 $p(1-p) \\neq 0$。我们可以安全地约掉这一项：\n$$\n\\mathbb{P}(Y=1) = \\frac{1}{2} = 0.5\n$$\n同理，对于输出比特 $Y=0$：\n$$\n\\mathbb{P}(Y=0) = \\mathbb{P}((X_1=0, X_2=1) | E) = \\frac{\\mathbb{P}(X_1=0, X_2=1)}{\\mathbb{P}(E)} = \\frac{p(1-p)}{2p(1-p)} = \\frac{1}{2} = 0.5\n$$\n输出比特 $Y$ 的期望值为：\n$$\n\\mathbb{E}[Y] = 1 \\cdot \\mathbb{P}(Y=1) + 0 \\cdot \\mathbb{P}(Y=0) = 1 \\cdot (0.5) + 0 \\cdot (0.5) = 0.5\n$$\n这正式地证明了输出的比特是无偏置的。冯·诺依曼的关键洞见在于，事件 $(1,0)$ 和 $(0,1)$ 具有相等的概率 $p(1-p)$，而这与偏置 $p$ 无关。\n\n最后，我们推导每个输入抛掷的期望输出比特数，这代表了提取器的效率或理论速率。每个配对由 $2$ 次输入抛掷组成。设 $N_{out}$ 为单个配对产生的比特数。$N_{out}$ 是一个随机变量，如果事件 $E$ 发生，其值为 $1$，否则为 $0$。$N_{out}$ 的期望值为：\n$$\n\\mathbb{E}[N_{out}] = 1 \\cdot \\mathbb{P}(N_{out}=1) + 0 \\cdot \\mathbb{P}(N_{out}=0) = \\mathbb{P}(E) = 2p(1-p)\n$$\n这是每 $2$ 次输入抛掷所产生的期望输出比特数。为了求出单次输入抛掷的期望输出比特数，我们除以 $2$：\n$$\n\\text{Theoretical Rate} = \\frac{\\mathbb{E}[N_{out}]}{2} = \\frac{2p(1-p)}{2} = p(1-p)\n$$\n这个表达式表明，当 $p=0.5$ 时效率最高（值为 $0.25$），而当 $p$ 趋近于 $0$ 或 $1$ 时，效率趋近于 $0$。\n\n对于计算任务，我们实现了一个模拟。一个单一的RNG用 $314159$ 作为种子以确保可复现性。对于每个测试用例 $(p, N)$，生成一个长度为 $N_{used} = N - (N \\pmod 2)$ 的带偏置抛掷序列。这些抛掷被分组成 $N_{used}/2$ 个配对。我们计算 $(1,0)$ 配对（设为 $n_{10}$）和 $(0,1)$ 配对（设为 $n_{01}$）的出现次数。\n提取的总比特数为 $n_{out} = n_{10} + n_{01}$。\n输出比特的样本均值为 $\\bar{Y} = n_{10} / n_{out}$。如果 $n_{out}=0$，我们按惯例使用 $\\bar{Y}=0.5$。那么经验绝对偏置就是 $|\\bar{Y} - 0.5|$。\n经验输出率是 $n_{out} / N_{used}$。速率的绝对误差是此经验率与理论率 $p(1-p)$ 之间的绝对差。大数定律表明，当 $N \\to \\infty$ 时，经验偏置和速率误差应收敛到 $0$。提供的代码将为指定的测试用例计算这些量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the von Neumann extractor problem by deriving theoretical values,\n    running simulations, and comparing empirical results to theory.\n    \"\"\"\n    \n    # Define the fixed test suite of parameter values.\n    test_cases = [\n        (0.2, 200000),  # Case 1\n        (0.8, 200000),  # Case 2\n        (0.01, 300000), # Case 3\n        (0.49, 200000), # Case 4\n    ]\n\n    # All randomness must be generated from a single seeded RNG.\n    seed = 314159\n    rng = np.random.default_rng(seed)\n\n    results = []\n    \n    for p, N in test_cases:\n        # --- Simulation ---\n        \n        # The number of input flips used must be an even number.\n        # Discard the last flip if N is odd.\n        num_flips_used = N - (N % 2)\n        \n        # Simulate biased coin flips. Heads (1) with probability p.\n        # This is an efficient way to generate Bernoulli trials.\n        flips = (rng.random(size=num_flips_used)  p).astype(np.int8)\n        \n        # Reshape the 1D array of flips into a 2D array of non-overlapping pairs.\n        pairs = flips.reshape(-1, 2)\n        \n        # Count the number of (1, 0) and (0, 1) pairs using vectorized operations.\n        # (1, 0) pairs yield an output bit of 1.\n        num_10 = np.sum((pairs[:, 0] == 1)  (pairs[:, 1] == 0))\n        \n        # (0, 1) pairs yield an output bit of 0.\n        num_01 = np.sum((pairs[:, 0] == 0)  (pairs[:, 1] == 1))\n        \n        # Total number of extracted unbiased bits.\n        num_output_bits = num_10 + num_01\n        \n        # --- Metric Calculation ---\n        \n        # 1. Empirical Absolute Bias\n        if num_output_bits == 0:\n            # If no bits are extracted, by convention, the sample mean is 0.5.\n            sample_mean_y = 0.5\n        else:\n            # The sample mean is the number of 1s divided by the total number of bits.\n            sample_mean_y = num_10 / num_output_bits\n            \n        empirical_absolute_bias = abs(sample_mean_y - 0.5)\n        \n        # 2. Absolute Error in Output Rate\n        if num_flips_used == 0:\n            empirical_rate = 0.0\n        else:\n            # Empirical rate is the number of output bits per input flip used.\n            empirical_rate = num_output_bits / num_flips_used\n        \n        # Theoretical rate is p*(1-p) output bits per input flip.\n        theoretical_rate = p * (1.0 - p)\n        \n        rate_error = abs(empirical_rate - theoretical_rate)\n\n        # Append formatted results to the list.\n        results.append(f\"{empirical_absolute_bias:.6f}\")\n        results.append(f\"{rate_error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2433264"}, {"introduction": "掌握了生成无偏随机比特的方法后，我们可以处理更复杂的随机化任务，例如对一组项目进行洗牌。在科学模拟和统计抽样中，确保每一种可能的排列（置换）都以相同的概率出现至关重要。本练习 [@problem_id:2433283] 将引导您实现标准的费雪-耶茨洗牌算法，并将其与几种故意设计的有偏算法进行对比，从而让您学会如何实施正确的随机化，并使用统计检验来发现其中隐藏的偏差。", "problem": "你被要求设计并实现一个程序，用于探究“无偏的随机排列应使每个元素在任何位置出现的概率均等”这一原理。你的重点是第一个位置。本练习与计算物理学中的蒙特卡洛方法论直接相关，在这些方法中，伪随机数生成器（PRNG）的保真度决定了随机模拟结果的有效性。\n\n起点和定义：\n- 伪随机数生成器（PRNG）在用种子初始化后，会产生一个确定性的数字序列，该序列近似于从指定概率分布中抽取的样本。\n- $N$ 个不同标签的一个排列是集合 $\\{0,1,\\dots,N-1\\}$ 上的一个双射。如果 $N!$ 种可能的排列中每一种的概率都是 $1/N!$，则该排列是均匀的。\n- 如果排列是均匀的，那么对于任何固定位置（特别是第一个位置），每个标签出现的概率必须是 $1/N$。\n- 为了检验经验计数是否与假设的离散均匀分布一致，可以使用经典的卡方拟合优度检验：根据观测计数和期望计数构建卡方统计量，并与具有适当自由度的卡方分布进行比较以获得 $p$ 值。当 $p$ 值在预选的显著性水平 $\\alpha$ 下足够小时，拒绝原假设。\n\n你的任务：\n1) 在标签列表 $[0,1,\\dots,N-1]$ 上实现三个排列生成器：\n   - 方法 U (无偏 Fisher–Yates)：将索引 $i$ 从 $N-1$ 向下迭代到 $1$。对于每个 $i$，从 $\\{0,1,\\dots,i\\}$ 中均匀抽取一个整数 $j$，并交换索引 $i$ 和 $j$ 处的元素。已知这种方法会产生均匀排列。\n   - 方法 P$(c)$ (部分 Fisher–Yates)：定义 $m=\\lfloor c\\,N\\rfloor$，其中 $0  c  1$。对于 $k=0,1,\\dots,m-1$，设置 $i=N-1-k$。在每一步中，从 $\\{0,1,\\dots,i\\}$ 中均匀抽取一个整数 $j$ 并交换元素。这是一种洗牌不足的方法。\n   - 方法 M$(b)$ (有偏的模运算首选)：在第一步，从 $\\{0,1,\\dots,2^b-1\\}$ 中均匀抽取一个整数 $x$。通过计算索引 $f=x \\pmod N$，将位置 $f$ 的元素与位置 $0$ 的元素交换。然后，对其余元素（位置 $1, \\dots, N-1$）执行一个 Fisher–Yates 变体：将索引 $i$ 从 $N-1$ 向下迭代到 $1$。对于每个 $i$，从 $\\{1,2,\\dots,i\\}$ 中均匀抽取一个整数 $j$，并交换索引 $i$ 和 $j$ 处的元素。\n\n2) 为每个测试案例运行一个包含 $T$ 次试验的实验。在每次试验中，使用指定的方法对数组进行排列，并记录下第一个位置（索引 $0$）的标签。\n\n3) 在 $T$ 次试验后，对收集到的关于第一个位置的标签的观测计数分布执行卡方拟合优度检验。计算 $p$ 值并将其与显著性水平 $\\alpha$ 进行比较，以决定是否拒绝均匀性假设（$H_0$）。\n\n4) 对于以下测试案例，执行上述步骤。所有PRNG实例都必须使用指定的种子进行初始化。\n   - 案例 1：方法=U， $N=10$，$T=100000$，$\\alpha=0.01$，种子=$10101$。\n   - 案例 2：方法=P， $N=20$，$T=80000$，$\\alpha=10^{-12}$，种子=$20202$，$c=0.2$。\n   - 案例 3：方法=M， $N=10$，$T=120000$，$\\alpha=10^{-6}$，种子=$30303$，$b=8$。\n   - 案例 4：方法=U， $N=2$，$T=60000$，$\\alpha=0.01$，种子=$40404$。\n   - 案例 5：方法=M， $N=7$，$T=120000$，$\\alpha=10^{-6}$，种子=$50505$，$b=3$。\n\n5) 输出格式：你的程序必须以方括号括起来的逗号分隔列表的形式生成单行输出。对于每个按顺序排列的测试案例，生成一个包含其 $p$ 值（四舍五入到6位小数）和决策（$1$ 表示拒绝 $H_0$，$0$ 表示不拒绝）的列表。因此，最终输出必须是 `[[p_value_1,decision_1],[p_value_2,decision_2],...]` 的形式。\n\n你的程序必须是完全自包含的，不读取任何输入，并严格按照指定格式打印单个输出行。", "solution": "该问题要求通过测试三种排列算法是否在排列后的数组的第一个位置上产生均匀的标签分布，来对它们进行经验性验证。这是计算物理学和蒙特卡洛方法中的一项基本检查，其中伪随机性的质量对于模拟结果的有效性至关重要。验证将使用卡方拟合优度检验进行。\n\n每个测试案例的总体过程涉及固定次数的试验 $T$。在每次试验中，使用指定的方法之一对初始标签数组 $[0, 1, \\dots, N-1]$ 进行排列。记录下最终位于索引 $0$ 的标签。经过 $T$ 次试验后，我们获得每个标签在第一个位置的观测计数频率分布 $\\mathbf{O} = (O_0, O_1, \\dots, O_{N-1})$。\n\n原假设 $H_0$ 指出，排列方法对于第一个位置是无偏的，这意味着每个标签 $k \\in \\{0, \\dots, N-1\\}$ 出现在该位置的概率为 $1/N$。在 $H_0$ 假设下，每个标签的期望计数为 $E_k = T/N$。卡方检验统计量 $\\chi^2$ 的计算公式为：\n$$ \\chi^2 = \\sum_{k=0}^{N-1} \\frac{(O_k - E_k)^2}{E_k} $$\n该统计量将与具有 $df = N-1$ 个自由度的 $\\chi^2$ 分布进行比较。$p$ 值代表在 $H_0$ 为真的情况下，观测到至少与计算出的统计量一样极端的统计量的概率，它由该分布的生存函数确定：$p = P(\\chi^2_{df} \\ge \\chi^2_{\\text{observed}})$。在给定的显著性水平 $\\alpha$ 下，如果 $p  \\alpha$，则拒绝 $H_0$。\n\n以下是对每种排列方法的分析。所有算法都使用一个以特定种子 $s$ 初始化的伪随机数生成器（PRNG）来实现，以确保可复现性。\n\n方法 U (无偏 Fisher–Yates)：该算法将索引 $i$ 从 $N-1$ 向下迭代到 $1$。在每一步中，它从 $\\{0, 1, \\dots, i\\}$ 中均匀选择一个随机索引 $j$，并交换位置 $i$ 和 $j$ 的元素。这个经典算法被证明能够以相等的概率 $1/N!$ 生成 $N$ 个元素的所有可能排列。因此，任何给定标签出现在任何给定位置的概率恰好是 $1/N$。该方法作为我们无偏排列的基准，我们预期统计检验不会拒绝原假设（即会得出较大的 $p$ 值）。\n\n方法 P($c$) (部分 Fisher–Yates)：此方法被设计为有偏的。它只执行完整 Fisher-Yates 洗牌算法的一部分交换操作。给定参数 $c \\in (0, 1)$，它执行 $m = \\lfloor cN \\rfloor$ 次交换。问题的描述“对于 $k=0,1,\\dots,m-1$，设置 $i=N-1-k$”表明这些交换是针对最大的索引，即 $i=N-1, N-2, \\dots, N-m$。这使得数组的前缀（对应于较小的索引）随机化不足。一个起始于前缀的标签被移动的可能性较小。具体来说，标签 $0$（初始在索引 $0$）会保持其位置，除非它在某次交换中被选为索引 $j$。它*不*被选中的概率是 $\\prod_{i=N-m}^{N-1} (1 - \\frac{1}{i+1}) = \\frac{N-m}{N}$。这造成了显著的偏差：标签 $0$ 出现在索引 $0$ 的可能性远大于任何其他标签。我们预计该检验将以接近 $0$ 的 $p$ 值强烈拒绝 $H_0$。\n\n方法 M($b$) (有偏的模运算首选)：此方法在第一步就引入了偏差。它从一个非均匀分布中为第一个位置选择元素。从 $\\{0, 1, \\dots, 2^b-1\\}$ 中均匀抽取一个整数 $x$，并计算索引 $f = x \\pmod N$。将索引 $f$ 处的元素（即标签 $f$）交换到索引 $0$。如前所述，随后的洗牌步骤将索引 $1$ 到 $N-1$ 的元素在它们之间进行洗牌，而保持索引 $0$ 处的元素不变。因此，最终在索引 $0$ 的标签分布精确地是 $f$ 的分布。这个分布仅在 $N$ 能整除 $2^b$ 时才是均匀的。否则，设 $2^b = qN+r$。标签 $\\{0, \\dots, r-1\\}$ 被选中的概率为 $(q+1)/2^b$，而标签 $\\{r, \\dots, N-1\\}$ 被选中的概率为 $q/2^b$。这种差异，无论多小，都会引入一个偏差，在有足够大的试验次数 $T$ 的情况下应该是可检测的。对于给定的测试案例，$N$ 不能整除 $2^b$，因此我们预计会拒绝 $H_0$。偏差的大小，以及由此产生的 $p$ 值，取决于这些概率偏离 $1/N$ 的程度。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import chi2\n\ndef permute_U(arr, rng):\n    \"\"\"\n    Generates a uniform permutation using the Fisher-Yates shuffle.\n    \"\"\"\n    n = len(arr)\n    for i in range(n - 1, 0, -1):\n        j = rng.integers(0, i, endpoint=True)\n        arr[i], arr[j] = arr[j], arr[i]\n    return arr\n\ndef permute_P(arr, rng, c):\n    \"\"\"\n    Generates a biased permutation using a partial Fisher-Yates shuffle.\n    \"\"\"\n    n = len(arr)\n    m = int(c * n)\n    for k in range(m):\n        i = n - 1 - k\n        # The swap is meaningful only for i > 0\n        if i > 0:\n            j = rng.integers(0, i, endpoint=True)\n            arr[i], arr[j] = arr[j], arr[i]\n    return arr\n\ndef permute_M(arr, rng, b):\n    \"\"\"\n    Generates a biased permutation using a modulo-biased first pick.\n    \"\"\"\n    n = len(arr)\n    # Draw x uniformly from {0, ..., 2^b - 1}\n    keyspace = 2**b\n    x = rng.integers(0, keyspace - 1, endpoint=True)\n    f = x % n\n    \n    # Swap element at index f into the first position\n    arr[0], arr[f] = arr[f], arr[0]\n    \n    # Shuffle the rest of the array (indices 1..N-1) among themselves\n    # The problem specifies j is drawn from {1, ..., i}\n    for i in range(n - 1, 0, -1):\n        j = rng.integers(1, i, endpoint=True)\n        arr[i], arr[j] = arr[j], arr[i]\n    return arr\n\ndef run_experiment(method, N, T, s, param):\n    \"\"\"\n    Runs the simulation to collect counts of labels at the first position.\n    \"\"\"\n    rng = np.random.default_rng(seed=s)\n    counts = np.zeros(N, dtype=np.int64)\n    \n    permute_func = None\n    if method == \"U\":\n        permute_func = lambda arr: permute_U(arr, rng)\n    elif method == \"P\":\n        permute_func = lambda arr: permute_P(arr, rng, c=param)\n    elif method == \"M\":\n        permute_func = lambda arr: permute_M(arr, rng, b=param)\n    else:\n        raise ValueError(f\"Unknown permutation method: {method}\")\n\n    for _ in range(T):\n        p = list(range(N))\n        permuted_p = permute_func(p)\n        first_element_label = permuted_p[0]\n        counts[first_element_label] += 1\n        \n    return counts\n\ndef perform_chi2_test(observed_counts, N, T, alpha):\n    \"\"\"\n    Performs the chi-squared goodness-of-fit test.\n    \"\"\"\n    # Under H0, expected count for each category is uniform.\n    expected_count = T / N\n    \n    # Calculate the chi-squared statistic\n    chisq_stat = np.sum((observed_counts - expected_count)**2 / expected_count)\n    \n    # Degrees of freedom for a GOF test is k-1.\n    df = N - 1\n    \n    # Calculate p-value using the survival function (1 - CDF).\n    p_value = chi2.sf(chisq_stat, df)\n    \n    # Decision: reject H0 if p  alpha\n    decision = 1 if p_value  alpha else 0\n    \n    return p_value, decision\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (method, N, T, alpha, seed, parameter)\n        (\"U\", 10, 100000, 0.01, 10101, None),\n        (\"P\", 20, 80000, 1e-12, 20202, 0.2),\n        (\"M\", 10, 120000, 1e-6, 30303, 8),\n        (\"U\", 2, 60000, 0.01, 40404, None),\n        (\"M\", 7, 120000, 1e-6, 50505, 3),\n    ]\n\n    results = []\n    for case in test_cases:\n        method, N, T, alpha, seed, param = case\n        \n        # 1. Run simulation to get observed counts\n        observed_counts = run_experiment(method, N, T, seed, param)\n        \n        # 2. Perform chi-squared test to get p-value and decision\n        p_value, decision = perform_chi2_test(observed_counts, N, T, alpha)\n        \n        results.append((p_value, decision))\n    \n    # 3. Format output string precisely as required\n    result_strings = [f\"[{p:.6f},{d}]\" for p, d in results]\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2433283"}, {"introduction": "在前面的练习中，我们依赖伪随机数生成器 (PRNG) 作为我们随机性的来源，但它们真的是“随机”的吗？本节将深入探讨这一问题，揭示由于 PRNG 本质上是确定性算法，其输出序列中蕴含着可被分析的数学结构。这项高级练习 [@problem_id:2433321] 将让您扮演密码分析者的角色，仅根据一个线性同余生成器 (LCG) 的输出序列，反向工程出其隐藏的模数，从而有力地证明伪随机性与真随机性之间的根本区别。", "problem": "你必须编写一个完整的、可运行的程序，该程序针对一个黑盒线性同余生成器（LCG），仅使用其输出序列来推断模数。线性同余生成器（LCG）由递归关系 $x_{n+1} \\equiv a x_n + c \\pmod{m}$ 定义，其中 $a$、$c$ 和 $m \\ge 2$ 为整数，且对所有 $n$，$x_n \\in \\{0,1,\\dots,m-1\\}$。模数 $m$ 是未知的，你的算法必须在无法访问 $a$ 或 $c$ 的情况下，通过同余的基本定义和递归结构进行推理来确定 $m$。你必须从模算术的基本原理、整数差分的性质以及最大公约数出发构建你的推理，并且必须确保你的方法对于混合LCG情况（非零 $c$）和乘法LCG情况（零 $c$）都具有鲁棒性。目标是为每个测试序列恢复一个整数模数 $m$。此任务不涉及物理单位。\n\n你的程序必须实现一个通用算法，该算法：\n- 仅接受输出序列 $x_0, x_1, \\dots, x_{N-1}$ 作为推断数据。\n- 使用基础数论原理来构建由递归和同余定义所隐含的整数约束，然后推导出一组候选模数。你的算法必须包含一种有原则的方法来选择唯一的模数，该模数应与观察到的输出范围以及存在满足整个序列递归关系的参数 $a$ 和 $c$ 的事实相一致。\n- 为每个序列生成一个整数答案 $m$。\n\n测试套件与答案规范：\n- 你的程序必须使用所列参数和初始种子，通过精确的LCG规则 $x_{n+1} \\equiv a x_n + c \\pmod{m}$ 在内部生成以下五个序列。提供这些参数仅为确保序列是明确定义且可复现的；你的推断必须仅使用序列本身，而不是这些参数。对于每种情况，生成前 $N$ 个输出 $x_0, x_1, \\dots, x_{N-1}$。\n\n    - 测试用例 $1$（顺利路径，素数模数）：$m = 104729$，$a = 314159$，$c = 271828$，$x_0 = 12345$，$N = 12$。\n    - 测试用例 $2$（乘法型，$c=0$）：$m = 10007$，$a = 5$，$c = 0$，$x_0 = 6789$，$N = 12$。\n    - 测试用例 $3$（2的幂次模数）：$m = 1048576$ (即 $2^{20}$)，$a = 1664525$，$c = 1013904223$，$x_0 = 424242$，$N = 16$。\n    - 测试用例 $4$（高合成数奇数模数）：$m = 65535$，$a = 1103515245$，$c = 12345$，$x_0 = 22222$，$N = 25$。\n    - 测试用例 $5$（较短序列，素数模数）：$m = 32749$，$a = 1234$，$c = 5678$，$x_0 = 13579$，$N = 10$。\n\n- 对于以上每个序列，你的程序必须仅从序列值推断模数 $m$。\n- 最终输出格式：你的程序应生成单行输出，其中包含推断出的模数，形式为方括号括起来的逗号分隔列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_5]$）。每个结果必须是整数。\n\n边界情况与覆盖范围期望：\n- 测试套件涵盖了非零 $c$ 的混合LCG情况（测试 1、3、4、5）、$c=0$ 的乘法LCG情况（测试 2）、2的幂次模数（测试 3）以及具有多个小素因数的高合成数奇数模数（测试 4）。你的算法应能处理其构建的任何辅助整数序列中可能出现的中间退化情况，例如重复的差值或临时的零值。\n- 你的程序中不允许存在随机性。所有结果必须是确定性的。\n\n你的程序必须严格按照指定格式打印一行，包含五个整数。不应打印任何额外文本。", "solution": "问题要求仅根据线性同余生成器（LCG）的输出序列来推断其模数 $m$。该方法必须从数论的基本原理推导得出，并且对混合型和乘法型LCG都具有鲁棒性。\n\n设LCG的输出序列表示为 $X = \\{x_0, x_1, \\dots, x_{N-1}\\}$。其控制递归关系如下：\n$$x_{n+1} \\equiv a x_n + c \\pmod{m}$$\n其中 $a$、$c$ 和 $m$ 是未知整数。我们的目标是确定 $m$。\n\n该方法的核心是消除未知参数 $a$ 和 $c$，以导出一个仅涉及模数 $m$ 和已知输出序列 $x_n$ 的约束。\n\n首先，我们消除加法常数 $c$。考虑 $n$ 和 $n+1$ 的两个连续递归关系实例：\n$$x_{n+1} \\equiv a x_n + c \\pmod{m}$$\n$$x_{n+2} \\equiv a x_{n+1} + c \\pmod{m}$$\n用第二个同余式减去第一个，得到：\n$$x_{n+2} - x_{n+1} \\equiv a(x_{n+1} - x_n) \\pmod{m}$$\n此操作成功消除了 $c$。我们定义一个辅助差分序列 $y_n$ 如下：\n$$y_n = x_{n+1} - x_n$$\n根据这个定义，关系变为：\n$$y_{n+1} \\equiv a y_n \\pmod{m}$$\n这个关于序列 $y_n$ 的新递归关系是一个纯乘法同余生成器，它对原始LCG的混合型（$c \\neq 0$）和乘法型（$c = 0$）情况都成立。该关系对 $n = 0, 1, \\dots, N-3$ 成立。\n\n接下来，我们消除乘数 $a$。考虑 $y_n$ 的新递归关系中的两个连续项：\n$$y_{n+1} \\equiv a y_n \\pmod{m}$$\n$$y_{n+2} \\equiv a y_{n+1} \\pmod{m}$$\n从这些同余式中，我们可以将关系写成整数方程的形式：\n$$y_{n+1} = a y_n + k_n m$$\n$$y_{n+2} = a y_{n+1} + k_{n+1} m$$\n其中 $k_n$ 和 $k_{n+1}$ 是某个整数。为了消除 $a$，我们可以将第一个方程乘以 $y_{n+1}$，第二个方程乘以 $y_n$，前提是 $y_n$ 和 $y_{n+1}$ 非零：\n$$y_{n+1}^2 = a y_n y_{n+1} + k_n m y_{n+1}$$\n$$y_n y_{n+2} = a y_n y_{n+1} + k_{n+1} m y_n$$\n用第二个方程减去第一个方程，得到：\n$$y_n y_{n+2} - y_{n+1}^2 = (k_{n+1} y_n - k_n y_{n+1})m$$\n右侧项是 $m$ 的整数倍。因此，我们建立了以下同余关系：\n$$y_n y_{n+2} - y_{n+1}^2 \\equiv 0 \\pmod{m}$$\n此关系对 $n = 0, 1, \\dots, N-4$ 成立。我们定义第二个辅助序列 $z_n$ 如下：\n$$z_n = y_n y_{n+2} - y_{n+1}^2$$\n我们的推导表明，每个 $z_n$ 都必须是真实模数 $m$ 的整数倍。这是一个强有力的约束。\n\n这意味着 $m$ 必须是所有 $z_n$ 值的公约数。因此，$m$ 也必须是它们最大公约数（GCD）的约数。我们定义一个候选值 $M$ 为所有非零 $z_n$ 值的GCD：\n$$M = \\left| \\gcd(\\{z_n \\mid z_n \\neq 0, n \\in [0, N-4]\\}) \\right|$$\n真实模数 $m$ 必须是 $M$ 的一个约数。这为 $m$ 提供了一个有限的候选集：$M$ 的所有正约数的集合。\n\n为了从这个候选集中选出正确的模数，我们引入第二个独立的约束。LCG的定义意味着其输出 $x_n$ 位于集合 $\\{0, 1, \\dots, m-1\\}$ 中。这对模数提供了一个严格的下界：\n$$m > x_n \\quad \\forall n \\in [0, N-1]$$\n因此，$m$ 必须严格大于输出序列中观察到的最大值：\n$$m > \\max(x_0, x_1, \\dots, x_{N-1})$$\n\n通过结合这两个必要条件，我们可以制定一个鲁棒的算法来推断模数：\n1.  从输入序列 $X = \\{x_n\\}_{n=0}^{N-1}$，计算差分序列 $Y = \\{y_n = x_{n+1} - x_n\\}_{n=0}^{N-2}$。\n2.  从序列 $Y$，计算序列 $Z = \\{z_n = y_n y_{n+2} - y_{n+1}^2\\}_{n=0}^{N-4}$。\n3.  计算 $M = |\\gcd(\\{z_n \\mid z_n \\neq 0\\})|$。如果所有 $z_n$ 均为零，则该方法无法得出结论。\n4.  确定观察到的最大输出值 $\\max_x = \\max(X)$。\n5.  找到 $M$ 的所有正约数的集合。\n6.  正确的模数 $m$ 必须是这个约数集合中的一个成员，并且必须满足 $m > \\max_x$。\n7.  如果存在多个这样的约数，必须做出有原则的选择。我们选择 $M$ 的大于 $\\max_x$ 的最小约数。这个选择对应于与所有可用数据一致的最受约束（即最小）的模数，代表了未被观察证伪的最强假设。\n\n此过程提供了一种仅从输出序列推断模数 $m$ 的确定性且有原则的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the LCG modulus inference problem for a given set of test cases.\n    \"\"\"\n\n    def generate_lcg_sequence(m, a, c, x0, n):\n        \"\"\"\n        Generates a sequence from a Linear Congruential Generator.\n        \n        Args:\n            m (int): The modulus.\n            a (int): The multiplier.\n            c (int): The increment.\n            x0 (int): The seed.\n            n (int): The number of values to generate.\n\n        Returns:\n            list: A list of n integers generated by the LCG.\n        \"\"\"\n        seq = [0] * n\n        seq[0] = x0\n        # Use Python's arbitrary-precision integers for intermediate calculations\n        # to avoid overflow before the modulo operation.\n        current_x = int(x0)\n        m, a, c = int(m), int(a), int(c)\n        for i in range(1, n):\n            current_x = (a * current_x + c) % m\n            seq[i] = current_x\n        return seq\n\n    def get_divisors(n):\n        \"\"\"\n        Computes all positive divisors of a given integer n.\n\n        Args:\n            n (int): The integer for which to find divisors.\n\n        Returns:\n            list: A sorted list of positive divisors of n.\n        \"\"\"\n        n = abs(n)\n        divs = set()\n        for i in range(1, int(np.sqrt(n)) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return sorted(list(divs))\n\n    def infer_modulus(x_seq):\n        \"\"\"\n        Infers the modulus of an LCG from its output sequence.\n\n        Args:\n            x_seq (list): A list of integers from the LCG output.\n\n        Returns:\n            int: The inferred modulus m, or -1 if the method fails.\n        \"\"\"\n        # We need at least 4 points to form one z_n value.\n        if len(x_seq)  4:\n            return -1\n\n        # Use object dtype to handle potentially very large Python integers\n        x = np.array(x_seq, dtype=object)\n\n        # Step 1: Compute the difference sequence y_n = x_{n+1} - x_n\n        y = x[1:] - x[:-1]\n\n        # Step 2: Compute the sequence z_n = y_n * y_{n+2} - y_{n+1}^2\n        z = y[:-2] * y[2:] - y[1:-1]**2\n\n        # Step 3: Compute M, the GCD of all non-zero z_n values\n        z_nonzero = z[z != 0]\n\n        if len(z_nonzero) == 0:\n            # Method is inconclusive if all z_n are zero\n            return -1\n        \n        # np.gcd.reduce requires a sequence. Take absolute values for GCD.\n        M = np.gcd.reduce(np.abs(z_nonzero))\n        \n        if M == 0:\n            # Should be covered by z_nonzero check, but as a safeguard.\n            return -1\n\n        # Step 4: Find the maximum observed value in the sequence\n        max_x = np.max(x)\n\n        # Step 5: Find the smallest divisor of M that is greater than max_x\n        divisors_of_M = get_divisors(M)\n        \n        for d in divisors_of_M:\n            if d > max_x:\n                # This is the smallest divisor of M that is larger than any\n                # observed value. It is our inferred modulus.\n                return d\n        \n        # This part should not be reached for a well-posed problem.\n        # It would imply that the true modulus is less than or equal to an\n        # observed value, a contradiction.\n        return -1\n\n    # Define the test cases from the problem statement.\n    test_params = [\n        # m, a, c, x0, N\n        (104729, 314159, 271828, 12345, 12),       # Test case 1\n        (10007, 5, 0, 6789, 12),                   # Test case 2\n        (1048576, 1664525, 1013904223, 424242, 16), # Test case 3\n        (65535, 1103515245, 12345, 22222, 25),      # Test case 4\n        (32749, 1234, 5678, 13579, 10),            # Test case 5\n    ]\n\n    sequences = [generate_lcg_sequence(*params) for params in test_params]\n    \n    results = [infer_modulus(seq) for seq in sequences]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2433321"}]}