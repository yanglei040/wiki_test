{"hands_on_practices": [{"introduction": "逆变换采样的核心在于对累积分布函数 (CDF) 求逆。这个练习将带你实践一个比简单指数分布更具挑战性的例子：截断幂律分布。幂律分布在物理学中无处不在，从临界现象到天体物理学，因此掌握其采样方法至关重要。此练习旨在巩固你从第一性原理出发，推导并实现逆变换公式的核心技能，特别是处理如指数 $\\alpha=1$ 这样的特殊参数值，这能加深你对数学推导严谨性的理解。", "problem": "您的任务是构建一个程序，从计算物理学中使用的截断幂律概率分布中生成独立的随机变量。该分布在一个有限区间上由概率密度函数 (Probability Density Function, PDF) 定义：\n$$\np(x) = C\\,x^{-\\alpha} \\quad \\text{for } x \\in [x_{\\min}, x_{\\max}],\n$$\n在其他情况下 $p(x)=0$，其中 $C$ 是归一化常数，使得在 $[x_{\\min}, x_{\\max}]$ 上的总概率等于 $1$。参数满足 $x_{\\min} > 0$、$x_{\\max} > x_{\\min}$ 以及 $\\alpha > 0$。定义域变量是实值 $x \\in \\mathbb{R}$。目标是生成完全遵循此截断密度分布的合成数据。\n\n您的程序必须：\n- 通过上面给出的目标分布的精确定义来隐式处理 $C$，确保生成的变量遵循在 $[x_{\\min}, x_{\\max}]$ 上的密度 $p(x)$ 分布。\n- 对于每个测试用例，根据此分布生成恰好 $N$ 个独立变量，使用一个在最开始用固定整数种子 $20231102$ 初始化一次的伪随机数生成器，然后按照下面列出的顺序，跨测试用例顺序使用伪随机数。\n- 对于每个测试用例，生成 $N$ 个变量后，计算以下三个汇总统计量：\n  1. $N$ 个变量中的最小值。\n  2. 中位数，定义为第 $\\left(\\frac{N+1}{2}\\right)$ 个顺序统计量（注意，下面每个 $N$ 都是奇数，所以这是一个无需插值的精确顺序统计量）。\n  3. $N$ 个变量中的最大值。\n- 将每个测试用例报告的三个值均四舍五入到恰好六位小数。\n- 将所有测试用例的结果汇总到单行输出中，该输出包含一个逗号分隔的列表的列表，每个内部列表按以下顺序对应一个测试用例。\n\n测试套件（五个测试用例）：\n- 用例 1: $\\alpha = 2.5$, $x_{\\min} = 1.0$, $x_{\\max} = 10.0$, $N = 9999$。\n- 用例 2: $\\alpha = 1.0$, $x_{\\min} = 0.1$, $x_{\\max} = 100.0$, $N = 9999$。\n- 用例 3: $\\alpha = 0.3$, $x_{\\min} = 1.0$, $x_{\\max} = 1000000.0$, $N = 7777$。\n- 用例 4: $\\alpha = 5.0$, $x_{\\min} = 0.5$, $x_{\\max} = 2.0$, $N = 5555$。\n- 用例 5: $\\alpha = 0.9$, $x_{\\min} = 2.0$, $x_{\\max} = 3.0$, $N = 3333$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由五个内部列表组成的逗号分隔列表，每个内部列表按 [最小值, 中位数, 最大值] 的顺序包含相应测试用例的三个四舍五入后的值。确切要求的格式是：\n[\n[min_case1,median_case1,max_case1],\n[min_case2,median_case2,max_case2],\n[min_case3,median_case3,max_case3],\n[min_case4,median_case4,max_case4],\n[min_case5,median_case5,max_case5]\n]\n输出中出现的所有数字必须按规定四舍五入到六位小数。不得打印任何额外文本。", "solution": "问题陈述经审查后确认有效。它具有科学依据，定义明确，客观，并为计算物理学中的一个可解问题提供了一套完整且一致的给定条件。任务是从一个截断幂律分布中生成随机变量，这是一个标准流程。逆变换采样法对于此目的而言是精确的，并将被采用。\n\n逆变换采样法的基本原理是，如果随机变量 $U$ 在区间 $[0, 1]$ 上均匀分布，那么通过变换 $X = F^{-1}(U)$ 定义的随机变量 $X$ 将遵循其累积分布函数 (CDF) 为 $F(x)$ 的概率密度函数 $p(x)$ 分布。此处，$F^{-1}$ 是逆 CDF，也称为分位数函数。\n\n因此，该过程首先是从给定的概率密度函数 (PDF) $p(x)$ 推导出累积分布函数 (CDF) $F(x)$，然后求其逆函数 $F^{-1}(u)$。\n\nPDF 由下式给出：\n$$\np(x) = C\\,x^{-\\alpha} \\quad \\text{for } x \\in [x_{\\min}, x_{\\max}]\n$$\n其中 $C$ 是一个归一化常数。对于支撑集 $[x_{\\min}, x_{\\max}]$ 中的值 $x$，其 CDF $F(x)$ 是概率 $P(X \\le x)$，由 PDF 从 $x_{\\min}$ 到 $x$ 的积分给出。\n$$\nF(x) = \\int_{x_{\\min}}^{x} p(t) \\,dt\n$$\n为确保 $F(x_{\\max}) = 1$，该积分必须通过在整个支撑集上的总概率进行归一化。\n$$\nF(x) = \\frac{\\int_{x_{\\min}}^{x} C t^{-\\alpha} \\,dt}{\\int_{x_{\\min}}^{x_{\\max}} C t^{-\\alpha} \\,dt}\n$$\n常数 $C$ 被消掉，这与问题中隐式处理 $C$ 的指令一致。我们剩下要计算的是 $t^{-\\alpha}$ 的积分。积分的形式取决于 $\\alpha$ 是否等于 $1$。\n\n情况 1: $\\alpha \\neq 1$\n$t^{-\\alpha}$ 的不定积分是 $\\frac{t^{1-\\alpha}}{1-\\alpha}$。定积分是：\n$$\n\\int_{a}^{b} t^{-\\alpha} \\,dt = \\left[ \\frac{t^{1-\\alpha}}{1-\\alpha} \\right]_{a}^{b} = \\frac{b^{1-\\alpha} - a^{1-\\alpha}}{1-\\alpha}\n$$\n将此代入 CDF 的表达式中：\n$$\nF(x) = \\frac{\\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{1-\\alpha}}{\\frac{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{1-\\alpha}} = \\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}\n$$\n\n情况 2: $\\alpha = 1$\nPDF 为 $p(x) \\propto x^{-1}$。$t^{-1}$ 的不定积分是 $\\ln(t)$。定积分是：\n$$\n\\int_{a}^{b} t^{-1} \\,dt = \\left[ \\ln(t) \\right]_{a}^{b} = \\ln(b) - \\ln(a) = \\ln(b/a)\n$$\n将此代入 CDF 的表达式中：\n$$\nF(x) = \\frac{\\ln(x) - \\ln(x_{\\min})}{\\ln(x_{\\max}) - \\ln(x_{\\min})} = \\frac{\\ln(x/x_{\\min})}{\\ln(x_{\\max}/x_{\\min})}\n$$\n\n接下来，我们必须通过设置 $u = F(x)$（其中 $u \\in [0, 1]$）并求解 $x$ 来找到逆 CDF $F^{-1}(u)$。\n\n情况 1: $\\alpha \\neq 1$\n$$\nu = \\frac{x^{1-\\alpha} - x_{\\min}^{1-\\alpha}}{x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}}\n$$\n$$\nu(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}) = x^{1-\\alpha} - x_{\\min}^{1-\\alpha}\n$$\n$$\nx^{1-\\alpha} = x_{\\min}^{1-\\alpha} + u(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha})\n$$\n$$\nx = F^{-1}(u) = \\left[ x_{\\min}^{1-\\alpha} + u(x_{\\max}^{1-\\alpha} - x_{\\min}^{1-\\alpha}) \\right]^{\\frac{1}{1-\\alpha}}\n$$\n\n情况 2: $\\alpha = 1$\n$$\nu = \\frac{\\ln(x) - \\ln(x_{\\min})}{\\ln(x_{\\max}) - \\ln(x_{\\min})}\n$$\n$$\nu(\\ln(x_{\\max}) - \\ln(x_{\\min})) = \\ln(x) - \\ln(x_{\\min})\n$$\n$$\n\\ln(x) = \\ln(x_{\\min}) + u(\\ln(x_{\\max}) - \\ln(x_{\\min}))\n$$\n使用对数的性质，这可以简化为：\n$$\n\\ln(x) = (1-u)\\ln(x_{\\min}) + u\\ln(x_{\\max}) = \\ln(x_{\\min}^{1-u} x_{\\max}^{u})\n$$\n对两边取指数，得到分位数函数：\n$$\nx = F^{-1}(u) = x_{\\min}^{1-u} x_{\\max}^{u} = x_{\\min} \\left(\\frac{x_{\\max}}{x_{\\min}}\\right)^u\n$$\n\n计算算法如下：\n1. 使用指定的种子初始化一个伪随机数生成器。\n2. 对于每个测试用例 $(\\alpha, x_{\\min}, x_{\\max}, N)$：\n   a. 从 $[0, 1]$ 上的均匀分布中生成 $N$ 个独立随机数 $u_1, u_2, \\dots, u_N$。\n   b. 对于每个 $u_i$，根据 $\\alpha$ 的值使用相应的公式计算出对应的变量 $x_i = F^{-1}(u_i)$。\n   c. 从得到的 $N$ 个变量样本 $\\{x_i\\}$ 中，计算最小值、中位数（对于奇数 $N$，即为第 $((N+1)/2)$ 个顺序统计量）和最大值。\n   d. 将这三个统计量四舍五入到六位小数。\n3. 按规定整理并格式化结果。\n此过程将保证生成的变量遵循所期望的截断幂律分布。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates random variates from a truncated power-law distribution using\n    inverse transform sampling and computes summary statistics for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, x_min, x_max, N)\n        (2.5, 1.0, 10.0, 9999),\n        (1.0, 0.1, 100.0, 9999),\n        (0.3, 1.0, 1000000.0, 7777),\n        (5.0, 0.5, 2.0, 5555),\n        (0.9, 2.0, 3.0, 3333),\n    ]\n\n    # Initialize a single pseudorandom number generator as required.\n    # The generator's state will be updated sequentially across all test cases.\n    rng = np.random.default_rng(20231102)\n\n    all_results = []\n    \n    for case in test_cases:\n        alpha, x_min, x_max, N = case\n\n        # Generate N uniform random numbers in [0, 1).\n        u = rng.random(size=N)\n\n        # Apply the inverse transform sampling formula.\n        # Two distinct formulas are required depending on whether alpha is 1.\n        if alpha == 1.0:\n            # Quantile function for alpha = 1: x = x_min * (x_max / x_min)^u\n            samples = x_min * (x_max / x_min)**u\n        else:\n            # Quantile function for alpha != 1:\n            # x = [x_min^(1-alpha) + u * (x_max^(1-alpha) - x_min^(1-alpha))]^(1/(1-alpha))\n            one_minus_alpha = 1.0 - alpha\n            x_min_pow = x_min**one_minus_alpha\n            x_max_pow = x_max**one_minus_alpha\n            \n            inner_term = x_min_pow + u * (x_max_pow - x_min_pow)\n            samples = inner_term**(1.0 / one_minus_alpha)\n\n        # Compute the required summary statistics.\n        # N is always odd, so np.median correctly calculates the ((N+1)/2)-th order statistic.\n        min_val = np.min(samples)\n        median_val = np.median(samples)\n        max_val = np.max(samples)\n\n        # Round the statistics to exactly six decimal places and store them.\n        all_results.append([\n            round(min_val, 6),\n            round(median_val, 6),\n            round(max_val, 6)\n        ])\n\n    # Format the results into the exact string format required.\n    # The output must be a single line.\n    # Example format: [[min1,med1,max1],[min2,med2,max2],...]\n    # Using .6f ensures that six decimal places are always shown.\n    formatted_cases = []\n    for res in all_results:\n        case_str = f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\"\n        formatted_cases.append(case_str)\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2403909"}, {"introduction": "本练习将逆变换采样方法应用于一个经典的量子力学系统：一维无限深势阱中的粒子。根据玻恩定则，波函数的模方代表了粒子在空间中出现的概率密度，而本次实践的目标就是从这个概率密度中进行抽样，从而将抽象的量子理论转化为具体的计算任务。[@problem_id:2403893] 此问题的独特之处在于，其累积分布函数的逆函数无法用初等函数解析表达，这就要求我们必须采用数值方法（如二分法或布伦特法）来求解。这个过程将向你展示，即使没有解析解，逆变换采样依然是一个普遍适用的强大工具。", "problem": "一个非相对论性的量子粒子被限制在区间 $[0,L]$ 上的一维无限深势阱中，势阱壁是完全刚性的。其归一化的定态波函数由 $\\psi_n(x) = \\sqrt{\\frac{2}{L}} \\sin\\!\\left(\\frac{n\\pi x}{L}\\right)$ 给出，其中 $x \\in [0,L]$ 且整数 $n \\ge 1$。考虑 $n=2$ 的第一激发态，因此在 $[0,L]$ 上的概率密度为 $f(x) = \\lvert \\psi_2(x) \\rvert^2$。所有三角函数参数必须以弧度为单位进行解释。\n\n任务：\n1. 从第一性原理出发，推导与 $f(x)$ 相关的累积分布函数 $F(x)$，其定义为 $F(x) = \\int_{0}^{x} f(t)\\,dt$，$x \\in [0,L]$。证明 $F(x)$ 在 $[0,L]$ 上是严格递增的，因此在 $u \\in [0,1]$ 上存在唯一的反函数 $G(u)$，使得 $F(G(u)) = u$。\n2. 构建一个程序，对下面列出的每个测试用例执行以下操作：\n   - 计算函数 $F(x)$ 及其反函数 $G(u)$，使得对于任何 $u \\in [0,1]$，值 $x = G(u)$ 满足 $\\lvert F(x) - u \\rvert \\le 10^{-12}$。\n   - 使用为该测试用例指定的整数种子初始化的伪随机数生成器，生成 $N$ 个在开区间 $(0,1)$ 上均匀分布的独立伪随机变量 $u_1,\\dots,u_N$。\n   - 将这些均匀分布的变量转换为样本 $x_i = G(u_i)$，这些样本遵循在 $[0,L]$ 上密度为 $f(x)$ 的分布。\n   - 计算样本的以下三个汇总统计量：\n     - 样本均值 $m_N = \\frac{1}{N}\\sum_{i=1}^{N} x_i$（以与 $L$ 相同的长度单位表示你的答案）。\n     - 样本二阶矩 $s_N^{(2)} = \\frac{1}{N}\\sum_{i=1}^{N} x_i^2$（以 $L$ 长度单位的平方表示你的答案）。\n     - 针对目标累积分布函数 $F$ 的 Kolmogorov–Smirnov 统计量 $D_N$，其定义为\n       $$D_N = \\max\\!\\left(\\max_{1\\le i\\le N}\\left(\\frac{i}{N} - F(x_{(i)})\\right), \\max_{1\\le i\\le N}\\left(F(x_{(i)}) - \\frac{i-1}{N}\\right)\\right),$$\n       其中 $x_{(1)} \\le \\cdots \\le x_{(N)}$ 是样本的非递减排序。统计量 $D_N$ 是无量纲的。\n3. 你的程序必须生成单行输出，其中包含所有测试用例的结果，格式为逗号分隔的子列表。每个子列表按顺序包含三个值 $[m_N, s_N^{(2)}, D_N]$。输出中的每个浮点结果必须四舍五入到 $6$ 位小数。例如，要求的整体格式是\n   $$\\big[\\,[m_{N,1}, s^{(2)}_{N,1}, D_{N,1}], [m_{N,2}, s^{(2)}_{N,2}, D_{N,2}], \\ldots \\big]$$\n   并且程序必须精确打印包含此列表的一行，并带有所示的方括号和逗号。\n\n测试套件：\n- 案例 $1$：$L = 1.0$，$N = 1000$，种子 $= 12345$。\n- 案例 $2$：$L = 5.0$，$N = 2000$，种子 $= 20231102$。\n- 案例 $3$：$L = 2.0$，$N = 1$，种子 $= 42$。\n\n角度单位说明：出现在三角函数内的所有角度都必须是弧度。\n\n物理单位：$m_N$ 以与 $L$ 相同的单位报告，$s_N^{(2)}$ 以该单位的平方报告，而 $D_N$ 是一个无单位的数。\n\n最终输出格式：你的程序应生成单行输出，包含所有结果，格式为逗号分隔的子列表。每个子列表的形式为 $[m_N,s_N^{(2)},D_N]$，并用方括号括起来，例如：$[[a,b,c],[d,e,f],[g,h,i]]$。", "solution": "该问题要求应用逆变换采样方法，从一维无限深势阱中粒子的量子力学概率密度所定义的分布中生成随机变量。这些步骤涉及概率密度函数和累积分布函数的解析推导，然后通过数值实现来生成样本并计算指定的统计量。该问题具有科学依据且定义明确。\n\n该系统是一个在区间 $[0, L]$ 上的无限深势阱中的粒子。其定态波函数为 $\\psi_n(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{n\\pi x}{L}\\right)$，其中量子数 $n$ 为整数且 $n \\ge 1$。我们关注的是对应于 $n=2$ 的第一激发态。\n\n**1. 概率密度函数 (PDF)**\n\n概率密度函数 $f(x)$ 由波函数的模平方给出，$f(x) = |\\psi_2(x)|^2$。\n对于 $n=2$，波函数为：\n$$ \\psi_2(x) = \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{2\\pi x}{L}\\right) $$\n对于 $x \\in [0, L]$，相应的 PDF 为：\n$$ f(x) = \\left| \\sqrt{\\frac{2}{L}} \\sin\\left(\\frac{2\\pi x}{L}\\right) \\right|^2 = \\frac{2}{L} \\sin^2\\left(\\frac{2\\pi x}{L}\\right) $$\n使用三角函数的降幂恒等式 $\\sin^2(\\theta) = \\frac{1 - \\cos(2\\theta)}{2}$，我们可以将 PDF 重写为：\n$$ f(x) = \\frac{2}{L} \\left( \\frac{1 - \\cos\\left(2 \\cdot \\frac{2\\pi x}{L}\\right)}{2} \\right) = \\frac{1}{L} \\left( 1 - \\cos\\left(\\frac{4\\pi x}{L}\\right) \\right) $$\n这种形式更便于积分。\n\n**2. 累积分布函数 (CDF)**\n\n累积分布函数 $F(x)$ 定义为 PDF 从 $0$ 到 $x$ 的积分：\n$$ F(x) = \\int_{0}^{x} f(t) \\,dt = \\int_{0}^{x} \\frac{1}{L} \\left( 1 - \\cos\\left(\\frac{4\\pi t}{L}\\right) \\right) dt $$\n我们逐项进行积分：\n$$ F(x) = \\frac{1}{L} \\left[ \\int_{0}^{x} 1 \\,dt - \\int_{0}^{x} \\cos\\left(\\frac{4\\pi t}{L}\\right) dt \\right] $$\n$$ F(x) = \\frac{1}{L} \\left[ t - \\frac{L}{4\\pi} \\sin\\left(\\frac{4\\pi t}{L}\\right) \\right]_{0}^{x} $$\n代入积分上下限可得：\n$$ F(x) = \\frac{1}{L} \\left[ \\left( x - \\frac{L}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) \\right) - \\left( 0 - \\frac{L}{4\\pi} \\sin(0) \\right) \\right] $$\n$$ F(x) = \\frac{x}{L} - \\frac{1}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) $$\n作为检验，我们计算 CDF 在边界处的值：$F(0) = 0$ 且 $F(L) = \\frac{L}{L} - \\frac{1}{4\\pi}\\sin(4\\pi) = 1 - 0 = 1$。这证实了归一性。\n\n**3. CDF 的可逆性**\n\n要应用逆变换采样，CDF $F(x)$ 必须有唯一的反函数。一个连续函数如果严格单调，则其有唯一的反函数。我们可以通过考察其导数来证明 $F(x)$ 在 $[0, L]$ 上是严格递增的。根据微积分基本定理，$F'(x) = f(x)$。\n$$ F'(x) = f(x) = \\frac{2}{L} \\sin^2\\left(\\frac{2\\pi x}{L}\\right) $$\n项 $\\frac{2}{L}$ 是正的。项 $\\sin^2(\\theta)$ 对所有实数 $\\theta$ 都是非负的。它仅在 $\\sin(\\theta)=0$ 时等于 $0$。对于 $\\theta = \\frac{2\\pi x}{L}$ 且 $x \\in [0, L]$，这发生在 $x=0$、$x=L/2$ 和 $x=L$ 处。\n由于对于所有 $x \\in [0, L]$ 都有 $F'(x) \\ge 0$，且 $F'(x)$ 仅在有限个孤立点上为零，因此函数 $F(x)$ 在整个区间 $[0, L]$ 上是严格递增的。因此，对于 $u \\in [0, 1]$，存在唯一的反函数 $G(u) = F^{-1}(u)$。\n\n**4. 逆变换采样算法**\n\n逆变换方法包括两个步骤：\n1. 从 $[0, 1]$ 上的均匀分布中生成一个随机变量 $u$，记为 $u \\sim U(0, 1)$。\n2. 通过应用 CDF 的反函数计算样本 $x$：$x = G(u) = F^{-1}(u)$。\n\n我们必须求解的方程是 $F(x) = u$，即：\n$$ \\frac{x}{L} - \\frac{1}{4\\pi} \\sin\\left(\\frac{4\\pi x}{L}\\right) = u $$\n这是一个超越方程，无法以简单的封闭形式求解 $x$。我们必须使用数值求根算法。对于给定的 $u$，我们在区间 $[0, L]$ 上寻找函数 $h(x) = F(x) - u = 0$ 的根 $x$。由于对于 $u \\in (0, 1)$，$h(0) = F(0) - u = -u  0$ 且 $h(L) = F(L) - u = 1 - u > 0$，所以根被限定在 $[0, L]$ 内。像 Brent 方法这样稳健而高效的算法适合于找到满足所需精度的根。\n\n**5. 汇总统计量的计算**\n\n对于通过此方法生成的 $N$ 个样本集合 $\\{x_1, x_2, \\ldots, x_N\\}$，我们计算以下统计量：\n- **样本均值 ($m_N$)**：样本的算术平均值。\n$$ m_N = \\frac{1}{N} \\sum_{i=1}^{N} x_i $$\n- **样本二阶矩 ($s_N^{(2)}$)**：样本平方的算术平均值。\n$$ s_N^{(2)} = \\frac{1}{N} \\sum_{i=1}^{N} x_i^2 $$\n- **Kolmogorov–Smirnov (KS) 统计量 ($D_N$)**：该统计量衡量样本的经验分布函数 (EDF) 与理论累积分布函数 $F(x)$ 之间的最大距离。对于一个已排序的样本集 $x_{(1)} \\le x_{(2)} \\le \\cdots \\le x_{(N)}$，该统计量定义为：\n$$ D_N = \\max\\left( \\max_{1 \\le i \\le N}\\left(\\frac{i}{N} - F(x_{(i)})\\right), \\max_{1 \\le i \\le N}\\left(F(x_{(i)}) - \\frac{i-1}{N}\\right) \\right) $$\n该算法将为每个测试用例实现，使用指定的种子生成 $N$ 个样本，计算这三个统计量，并以要求的格式报告结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Solves the inverse transform sampling problem for a particle in a box.\n    \"\"\"\n    test_cases = [\n        # (L, N, seed)\n        (1.0, 1000, 12345),\n        (5.0, 2000, 20231102),\n        (2.0, 1, 42),\n    ]\n\n    def F_cdf(x, L):\n        \"\"\"\n        Computes the theoretical cumulative distribution function (CDF) F(x).\n        F(x) = x/L - sin(4*pi*x/L) / (4*pi)\n        \"\"\"\n        arg = 4.0 * np.pi * x / L\n        return (x / L) - (np.sin(arg) / (4.0 * np.pi))\n\n    all_results = []\n\n    for L, N, seed in test_cases:\n        # 1. Initialize the pseudorandom number generator with the specified seed.\n        rng = np.random.default_rng(seed)\n\n        # 2. Generate N independent pseudorandom variates uniformly distributed on (0,1).\n        u_samples = rng.uniform(0.0, 1.0, size=N)\n\n        # 3. For each uniform variate u, find the corresponding x by inverting the CDF.\n        # This requires solving F(x) - u = 0 for x.\n        x_samples = np.zeros(N)\n        for i, u in enumerate(u_samples):\n            # The function to find the root of.\n            func_to_solve = lambda x: F_cdf(x, L) - u\n            \n            # Use Brent's method to find the root in the interval [0, L].\n            # The root is guaranteed to be in this interval as F(0)=0 and F(L)=1.\n            # h(0) = -u  0 and h(L) = 1-u > 0 for u in (0,1).\n            x_samples[i] = brentq(func_to_solve, 0.0, L)\n\n        # 4. Compute the required summary statistics.\n        # Sample mean\n        m_N = np.mean(x_samples)\n\n        # Sample second moment\n        s2_N = np.mean(np.square(x_samples))\n\n        # Kolmogorov-Smirnov statistic\n        if N > 0:\n            x_sorted = np.sort(x_samples)\n            F_values = F_cdf(x_sorted, L)\n            \n            # i/N for i=1,...,N\n            i_over_N = np.arange(1, N + 1) / N\n            # (i-1)/N for i=1,...,N\n            i_minus_1_over_N = np.arange(0, N) / N\n            \n            # D_N = max(max(i/N - F(x_i)), max(F(x_i) - (i-1)/N))\n            max1 = np.max(i_over_N - F_values)\n            max2 = np.max(F_values - i_minus_1_over_N)\n            D_N = np.max([max1, max2])\n        else:\n            # Although not in the test suite, handle the N=0 case gracefully.\n            m_N, s2_N, D_N = 0.0, 0.0, 0.0\n\n        all_results.append([m_N, s2_N, D_N])\n\n    # 5. Format the final output string exactly as specified.\n    # Each sublist is formatted, then joined by commas, then enclosed in brackets.\n    sublist_strs = [f\"[{res[0]:.6f},{res[1]:.6f},{res[2]:.6f}]\" for res in all_results]\n    final_output_str = f\"[{','.join(sublist_strs)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2403893"}, {"introduction": "最后，我们来看一个更高级的应用，它深刻揭示了逆变换采样思想的普适性——模拟非齐次泊松过程 (NHPP)。这个练习展示了该方法不仅能用于对随机变量进行采样，还能用于“拉直”一个随机过程，即通过变换时间坐标，将一个具有时变速率的复杂过程转化为一个速率恒定的标准过程。[@problem_id:2403943] 你将通过生成一系列简单的指数分布随机数（代表标准过程的事件间隔），再利用累积强度函数的逆函数将它们映射回原始时间轴，从而生成非齐次过程的事件时间。这个强大的技术突显了逆变换采样与坐标变换之间的深刻联系。", "problem": "您需要通过变换时间坐标，为一个非齐次泊松过程（NHPP）实现逆变换采样。从基本定义出发：一个在 $t \\in [0,T]$ 上具有确定性的、局部可积的速率（也称为强度）函数 $\\lambda(t) \\ge 0$ 的NHPP，具有独立增量，并且对于足够小的 $\\Delta t$，满足关系式 $\\mathbb{P}(N(t+\\Delta t)-N(t)=1) = \\lambda(t)\\,\\Delta t + o(\\Delta t)$ 和 $\\mathbb{P}(N(t+\\Delta t)-N(t)\\ge 2) = o(\\Delta t)$，其中 $N(t)$ 是计数过程。定义积分（或累积）强度为 $\\Lambda(t) = \\int_0^t \\lambda(u)\\,du$，其中 $\\Lambda(0)=0$ 且 $\\Lambda$ 是非递减的。利用这些基本定义和单位速率指数分布的性质（其累积分布函数为 $F(x) = 1 - e^{-x}$，当 $x \\ge 0$ 时），请从第一性原理推导，为什么时间变换 $s = \\Lambda(t)$ 会将NHPP的事件时间转换为 $s$ 坐标下单位速率的齐次泊松过程的事件时间，并因此解释为什么可以通过在 $s$ 坐标中抽取独立同分布的单位速率指数增量，然后使用广义逆 $t = \\inf\\{u \\in [0,T]: \\Lambda(u) \\ge s\\}$ 映射回去，来执行逆变换采样。您的推导不应将时间变换定理作为已知条件；请从NHPP的无穷小表征和指数分布的定义出发进行构建。\n\n然后，实现一个程序，该程序：\n- 使用以整数 $12345$ 为种子的伪随机数生成器，生成 $(0,1)$ 上的独立同分布标准均匀变量，并通过逆变换采样，使用 $x = -\\ln(1-U)$（其中 $U$ 是均匀变量）将其转换为变换后坐标中的单位速率指数增量。\n- 通过对单位速率指数增量求和得到部分和 $S_k$，并在 $[0,T]$ 上模拟一个NHPP，然后通过广义逆 $t_k = \\inf\\{t \\in [0,T]: \\Lambda(t) \\ge S_k\\}$ 将每个满足 $S_k \\le \\Lambda(T)$ 的 $S_k$ 映射回 $[0,T]$ 内的事件时间 $t_k$。\n- 使用一个稳健的数值单调逆例程（二分法作为下界查找器）来计算广义逆，即使当 $\\lambda(t)$ 在一个非平凡区间上为零，导致 $\\Lambda(t)$ 出现平台期时，该方法也适用。对于任意 $s \\in [0,\\Lambda(T)]$，数值逆应返回最小的 $t$，使得 $\\Lambda(t) \\ge s$，且 $t$ 的绝对精度至多为 $10^{-10}$。\n\n在以下四种情况下实现并测试您的程序，每种情况都提供了 $\\lambda(t)$、其解析累积函数 $\\Lambda(t)$ 和时间范围 $T$。对于每种情况，返回在 $[0,T]$ 内生成的事件数（一个整数）。\n\n- 情况一（恒定速率）：$\\lambda(t) = \\lambda_0$，其中 $\\lambda_0 = 3.0$，在 $t \\in [0,T]$ 上，且 $T = 5.0$。累积函数为 $\\Lambda(t) = \\lambda_0 t$。\n- 情况二（线性增长速率）：$\\lambda(t) = a + b\\,t$，其中 $a = 0.5, b = 0.3$，在 $t \\in [0,T]$ 上，且 $T = 10.0$。累积函数为 $\\Lambda(t) = a\\,t + \\tfrac{1}{2} b\\,t^2$。\n- 情况三（指数增长速率）：$\\lambda(t) = \\alpha\\,e^{\\beta t}$，其中 $\\alpha = 0.2, \\beta = 0.5$，在 $t \\in [0,T]$ 上，且 $T = 8.0$。当 $\\beta \\neq 0$ 时，累积函数为 $\\Lambda(t) = \\tfrac{\\alpha}{\\beta}\\big(e^{\\beta t} - 1\\big)$。\n- 情况四（带有零平台期的分段常数速率）：在 $t \\in [0,T]$ 上，其中 $T = 10.0$，定义 $\\lambda(t) = 5.0$ 对于 $t \\in [0,3)$，$\\lambda(t) = 0.0$ 对于 $t \\in [3,7)$，以及 $\\lambda(t) = 2.0$ 对于 $t \\in [7,10]$。累积函数 $\\Lambda(t)$ 是分段线性的，在 $[3,7]$ 上有一个平台期。\n\n实现要求：\n- 仅使用标准的双精度浮点运算。\n- 使用一个下界二分法，对于给定的 $s \\in [0,\\Lambda(T)]$，返回 $t \\in [0,T]$，使得 $\\Lambda(t) \\ge s$ 且对于所有足够小的 $\\epsilon > 0$，有 $\\Lambda(t-\\epsilon)  s$，其中 $t$ 的绝对误差不超过 $10^{-10}$。\n- 通过对 $(0,1)$ 上的独立同分布均匀变量进行逆变换采样，生成单位速率的指数增量。\n\n测试套件和输出规范：\n- 您的程序必须按给定顺序将上述算法应用于指定的四种情况。\n- 对于每种情况，输出 $[0,T]$ 内的事件数（一个整数）。\n- 将所有四种情况的结果汇总到一行输出中，格式为用方括号括起来的逗号分隔列表，不含空格。例如，输出格式必须与 [$r_1$,$r_2$,$r_3$,$r_4$] 完全一样，其中 $r_k$ 是情况 $k$ 的整数结果。\n- 输出不涉及物理单位。这些情况中不使用角度。", "solution": "所述问题是有效的。它在科学上基于随机过程理论，特别是非齐次泊松过程（NHPP），并描述了一种标准的、正确的模拟算法，称为时间变换法或变换法。该问题是适定的，提供了所有必要的定义、参数和约束，以便在给定指定伪随机数生成器种子的情况下产生唯一的、确定性的结果。它没有事实错误、矛盾和歧义。因此，我们可以着手解决。\n\n任务包括两部分：首先，从第一性原理推导模拟NHPP的时间变换法的有效性；其次，为一组指定的测试用例实现此方法。\n\n**第一部分：时间变换定理的推导**\n\n设 $N(t)$（$t \\in [0,T]$）为一个非齐次泊松过程的计数过程，其具有一个确定性的、局部可积的强度函数 $\\lambda(t) \\ge 0$。根据定义，该过程具有独立增量，并对于一个微小的时间间隔 $\\Delta t$ 满足以下无穷小性质：\n1.  在区间 $[t, t+\\Delta t)$ 内发生恰好一个事件的概率由 $\\mathbb{P}(N(t+\\Delta t) - N(t) = 1) = \\lambda(t)\\Delta t + o(\\Delta t)$ 给出。\n2.  在同一区间内发生两个或更多事件的概率是可忽略的：$\\mathbb{P}(N(t+\\Delta t) - N(t) \\ge 2) = o(\\Delta t)$。\n\n我们引入一个由累积（或积分）强度函数 $\\Lambda(t)$ 定义的时间坐标变换：\n$$s = \\Lambda(t) = \\int_0^t \\lambda(u)\\,du$$\n由于 $\\lambda(u) \\ge 0$，函数 $\\Lambda(t)$ 是非递减的。如果 $\\lambda(t)$ 是连续的，根据微积分基本定理，我们有微分关系 $ds/dt = \\lambda(t)$，这意味着 $ds = \\lambda(t)dt$。\n\n让我们在这个变换后的时间坐标 $s$ 中定义一个新的计数过程 $M(s)$，使得当 $s = \\Lambda(t)$ 时有 $M(s) = N(t)$。我们现在将证明 $M(s)$ 是一个常数速率为1的齐次泊松过程（HPP）。\n\n考虑在变换坐标中一个无穷小区间 $[s, s+\\Delta s)$。这对应于原始时间坐标中的一个区间 $[t, t+\\Delta t)$，其中 $\\Delta s = \\Lambda(t+\\Delta t) - \\Lambda(t) \\approx \\lambda(t)\\Delta t$。根据定义，过程 $M(s)$ 在 $[s, s+\\Delta s)$ 内的事件数与过程 $N(t)$ 在 $[t, t+\\Delta t)$ 内的事件数相同。因此，我们可以利用 $N(t)$ 的已知性质来分析 $M(s)$ 的性质。\n\n过程 $M(s)$ 在区间 $[s, s+\\Delta s)$ 内发生一个事件的概率是：\n$$\\mathbb{P}(M(s+\\Delta s) - M(s) = 1) = \\mathbb{P}(N(t+\\Delta t) - N(t) = 1)$$\n根据NHPP的定义，这等于：\n$$= \\lambda(t)\\Delta t + o(\\Delta t)$$\n代入 $\\Delta s = \\lambda(t)\\Delta t + o(\\Delta t)$，对于 $\\lambda(t)  0$，我们得到 $\\Delta t = \\Delta s / \\lambda(t) + o(\\Delta s)$。因此：\n$$= \\lambda(t) \\left( \\frac{\\Delta s}{\\lambda(t)} \\right) + o(\\Delta s) = \\Delta s + o(\\Delta s)$$\n\n类似地，过程 $M(s)$ 在 $[s, s+\\Delta s)$ 内发生两个或更多事件的概率是：\n$$\\mathbb{P}(M(s+\\Delta s) - M(s) \\ge 2) = \\mathbb{P}(N(t+\\Delta t) - N(t) \\ge 2) = o(\\Delta t) = o(\\Delta s)$$\n\n这两个结果，$\\mathbb{P}(M(s+\\Delta s) - M(s) = 1) = 1 \\cdot \\Delta s + o(\\Delta s)$ 和 $\\mathbb{P}(M(s+\\Delta s) - M(s) \\ge 2) = o(\\Delta s)$，是常数速率为1的齐次泊松过程的定义性无穷小性质。\n\n速率为 $\\rho$ 的HPP的一个基本性质是，其到达间隔时间——连续事件之间的时间间隔——是服从速率为 $\\rho$ 的指数分布的独立同分布（i.i.d.）随机变量。对于我们的变换过程 $M(s)$，速率为 $\\rho=1$。因此，在 $s$ 坐标中的到达间隔时间，我们记为 $E_k = S_k - S_{k-1}$（其中 $S_k$ 是 $s$ 坐标中的事件时间），是来自速率为1的指数分布的独立同分布随机变量。\n\n单位速率指数分布的累积分布函数（CDF）为 $F(x) = 1 - e^{-x}$，当 $x \\ge 0$ 时。根据逆变换采样原理，我们可以通过计算 $X = F^{-1}(U)$ 从标准均匀随机变量 $U \\sim \\mathcal{U}(0,1)$ 生成一个具有CDF $F$ 的随机变量 $X$。\n设 $u = F(x) = 1 - e^{-x}$，我们可以反解出 $x$：\n$$e^{-x} = 1 - u \\implies -x = \\ln(1 - u) \\implies x = -\\ln(1 - u)$$\n因此，我们可以通过抽取独立同分布的均匀变量 $U_k$ 并计算 $E_k = -\\ln(1 - U_k)$ 来生成独立同分布的单位速率指数到达间隔时间 $E_k$。\n\n模拟过程如下：\n1.  生成一系列独立同分布的单位速率指数增量 $E_1, E_2, E_3, \\dots$。\n2.  计算它们的偏和以获得变换坐标中的事件时间：$S_k = \\sum_{i=1}^k E_i$。这些是单位速率HPP的事件时间。\n3.  时间范围 $[0, T]$ 上的模拟对应于变换后的范围 $[0, \\Lambda(T)]$。我们收集所有满足 $S_k \\le \\Lambda(T)$ 的事件。\n4.  为了找到原始事件时间 $t_k$，我们必须对关系 $s = \\Lambda(t)$ 进行逆运算。这通过广义逆函数来完成，当 $\\Lambda(t)$ 不是严格递增时（即当 $\\lambda(t)=0$ 在某个区间上时），这是必需的：\n    $$t_k = \\inf\\{t \\in [0,T] : \\Lambda(t) \\ge S_k\\}$$\n这个广义逆正确地将在变换时间 $S_k$ 发生的事件映射到达到该累积强度的最早可能时间 $t_k$。\n\n**第二部分：算法实现**\n\n实现遵循推导出的过程。为了可复现性，使用 $12345$ 为一个伪随机数生成器设定种子。一个循环生成指数增量 $E_k = -\\ln(1-U_k)$ 并将其加到一个运行总和 `current_s` 上。只要 `current_s` 不超过总积分强度 $\\Lambda(T)$，循环就继续。生成的事件数是此条件成立的迭代次数。\n\n实现了一个二分法来寻找广义逆 $t = \\inf\\{u : \\Lambda(u) \\ge s\\}$。给定一个目标值 $s$，二分搜索维持一个区间 $[t_{low}, t_{high}]$，使得 $\\Lambda(t_{low})  s$ 和 $\\Lambda(t_{high}) \\ge s$。通过反复将区间减半并选择保持此属性的子区间，该方法收敛到所需的下确界 $t$。虽然问题陈述要求实现此例程，但获得最终的事件计数并不需要使用它。\n\n将对四种不同的 $\\lambda(t)$ 情况运行模拟，并报告每种情况的事件数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a non-homogeneous Poisson process (NHPP)\n    using the time-change method for four specified cases.\n    \"\"\"\n\n    def bisection_inverse(Lambda_func, s_target, t_max, tol=1e-10):\n        \"\"\"\n        Finds the generalized inverse of Lambda(t) using bisection.\n        This finds t = inf{u in [0, t_max] : Lambda(u) = s_target}.\n\n        Args:\n            Lambda_func (callable): The cumulative intensity function Lambda(t).\n            s_target (float): The target value in the transformed 's' coordinate.\n            t_max (float): The upper bound of the time interval [0, T].\n            tol (float): The absolute tolerance for the solution 't'.\n\n        Returns:\n            float: The time 't' corresponding to 's_target'.\n        \"\"\"\n        low = 0.0\n        high = t_max\n\n        # Handle edge cases\n        if s_target = Lambda_func(0.0):\n            return 0.0\n        if s_target >= Lambda_func(t_max):\n            return t_max\n\n        # Standard bisection loop to find the infimum\n        while high - low > tol:\n            mid = low + (high - low) / 2.0\n            if Lambda_func(mid)  s_target:\n                low = mid\n            else:\n                high = mid\n        return high\n\n    # Initialize the pseudorandom number generator with a fixed seed for reproducibility.\n    seed = 12345\n    rng = np.random.default_rng(seed)\n\n    # Define the four test cases from the problem statement.\n    # Each case is a tuple: (Lambda function, time horizon T).\n\n    # Case 1: Constant rate\n    lambda0_c1 = 3.0\n    T1 = 5.0\n    Lambda1 = lambda t: lambda0_c1 * t\n\n    # Case 2: Linearly increasing rate\n    a_c2, b_c2 = 0.5, 0.3\n    T2 = 10.0\n    Lambda2 = lambda t: a_c2 * t + 0.5 * b_c2 * t**2\n\n    # Case 3: Exponentially increasing rate\n    alpha_c3, beta_c3 = 0.2, 0.5\n    T3 = 8.0\n    Lambda3 = lambda t: (alpha_c3 / beta_c3) * (np.exp(beta_c3 * t) - 1.0)\n\n    # Case 4: Piecewise-constant rate with a zero plateau\n    T4 = 10.0\n    def Lambda4(t):\n        if t = 0.0:\n            return 0.0\n        elif t  3.0:\n            return 5.0 * t\n        elif t  7.0:\n            return 15.0\n        elif t = 10.0:\n            return 15.0 + 2.0 * (t - 7.0)\n        else: # t > 10.0\n            return 21.0\n\n    test_cases = [\n        (Lambda1, T1),\n        (Lambda2, T2),\n        (Lambda3, T3),\n        (Lambda4, T4),\n    ]\n\n    results = []\n    for Lambda_func, T in test_cases:\n        # Calculate the total integrated intensity over the horizon [0, T].\n        lambda_T = Lambda_func(T)\n\n        current_s = 0.0\n        event_count = 0\n        while True:\n            # Generate a standard uniform random variable U ~ U(0,1).\n            # The numpy generator produces values in [0,1), which is acceptable.\n            U = rng.random()\n            \n            # Transform U into a unit-rate exponential increment E.\n            # E = -ln(1-U)\n            E = -np.log(1.0 - U)\n\n            # Advance the transformed time.\n            current_s += E\n\n            # If the new event time is within the transformed horizon, count it.\n            if current_s = lambda_T:\n                event_count += 1\n                # Note: The problem requires implementing the bisection_inverse,\n                # which is done above. It is not necessary to call it to find\n                # the count of events, which is the required output.\n            else:\n                # The event falls outside the horizon, so we stop generating events.\n                break\n        \n        results.append(event_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403943"}]}