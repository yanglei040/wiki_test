{"hands_on_practices": [{"introduction": "阿诺尔迪迭代的一个核心优势在于其“无矩阵”特性，即算法的执行仅需要矩阵与向量的乘积（即算子 $A$ 对向量 $v$ 的作用 $Av$），而无需访问或存储矩阵 $A$ 本身的元素。这一特性对于处理计算物理中常见的大规模问题至关重要，因为在这些问题中，完整地构造和存储矩阵 $A$ 往往是不切实际的。本练习旨在通过实现一个“无矩阵”的阿诺尔迪迭代来巩固这一核心概念 [@problem_id:2373518]，并将其应用于几种不同类型的线性算子，以估算它们的谱半径。", "problem": "您的任务是计算几个实非对称线性算子的谱半径的近似值，并且只能使用将每个算子应用于向量的能力。对于维度为 $n$ 的有限维实向量空间，令 $A:\\mathbb{R}^n \\to \\mathbb{R}^n$ 是一个线性算子。对于一个选定的正整数 $m$ 和一个非零起始向量 $v_0 \\in \\mathbb{R}^n$，考虑 $m$ 维 Krylov 子空间 $K_m(A, v_0) = \\mathrm{span}\\{v_0, A v_0, A^2 v_0, \\dots, A^{m-1} v_0\\}$。令 $V_m \\in \\mathbb{R}^{n \\times m}$ 表示 $K_m(A, v_0)$ 的一个列正交基，并令 $H_m = V_m^\\top A V_m \\in \\mathbb{R}^{m \\times m}$ 表示 $A$ 在此子空间上的正交投影。将 $H_m$ 的特征值定义为 Ritz 值，并将这些 Ritz 值中的最大模定义为谱半径的 Ritz 估计值。$A$ 的真实谱半径为 $\\rho(A) = \\max\\{|\\lambda| : \\lambda \\in \\sigma(A)\\}$，其中 $\\sigma(A)$ 是 $A$ 的谱。\n\n您的程序必须为下面列出的每个测试用例计算 Ritz 估计值（由 $H_m$ 的特征值计算得出）与真实谱半径 $\\rho(A)$ 之间的绝对误差，并使用一个指定的初始向量。程序不能直接访问 $A$ 的矩阵元素；它只能使用 $A$ 对向量的作用。三角函数中的所有角度都应解释为弧度。最终输出必须是单行，包含一个浮点数列表，对应每个测试用例的绝对误差，并四舍五入到八位小数。\n\n使用以下测试套件。在每种情况下，初始向量 $v_0 \\in \\mathbb{R}^n$ 按分量定义为\n$$\n(v_0)_i = \\sin(i) + \\tfrac{1}{2}\\cos(2 i), \\quad i=1,2,\\dots,n,\n$$\n随后归一化为单位欧几里得范数 $\\|(v_0)\\|_2 = 1$。\n\n- 测试用例 1 (三对角 Toeplitz 算子)：\n  - 维度：$n = 80$。\n  - 参数：$a = 1$，$b = 2$，$c = \\tfrac{1}{2}$。\n  - 算子作用：对于任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y_1 = a x_1 + b x_2,\\quad\n    y_i = c x_{i-1} + a x_i + b x_{i+1}\\ \\text{for}\\ i=2,\\dots,n-1,\\quad\n    y_n = c x_{n-1} + a x_n.\n    $$\n  - 子空间维度：$m = 25$。\n  - 真实谱半径：对于此算子，特征值为 $a + 2\\sqrt{b c}\\cos\\left(\\tfrac{j\\pi}{n+1}\\right)$，$j=1,2,\\dots,n$，因此\n    $$\n    \\rho(A) = \\max\\Big\\{\\left|a + 2\\sqrt{b c}\\right|,\\ \\left|a - 2\\sqrt{b c}\\right|\\Big\\}.\n    $$\n\n- 测试用例 2 (Jordan 块)：\n  - 维度：$n = 60$。\n  - 参数：$\\lambda = 3$。\n  - 算子作用：对于任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y_i = \\lambda x_i + x_{i+1}\\ \\text{for}\\ i=1,2,\\dots,n-1,\\quad\n    y_n = \\lambda x_n.\n    $$\n  - 子空间维度：$m = 15$。\n  - 真实谱半径：$\\rho(A) = |\\lambda|$。\n\n- 测试用例 3 (具有对角谱的相似变换)：\n  - 维度：$n = 50$。\n  - 对角谱：定义 $d_{\\max} = 5$，$d_{\\min} = 1$，以及\n    $$\n    d_i = d_{\\min} + (d_{\\max} - d_{\\min})\\frac{n - i}{n - 1},\\quad i=1,2,\\dots,n.\n    $$\n    令 $D \\in \\mathbb{R}^{n \\times n}$ 为对角矩阵，其对角元为 $d_i$。\n  - 相似矩阵：定义 $S \\in \\mathbb{R}^{n \\times n}$ 如下\n    $$\n    S_{ij} = \\delta_{ij} + 10^{-2}\\sin\\!\\Big(\\frac{(i)(j)}{n+1}\\Big),\\quad i,j=1,2,\\dots,n,\n    $$\n    其中 $\\delta_{ij}$ 是 Kronecker delta。\n  - 算子作用：对于任意 $x \\in \\mathbb{R}^n$，定义 $y = A x$ 为 $y = S D S^{-1} x$。\n  - 子空间维度：$m = 30$。\n  - 真实谱半径：$\\rho(A) = \\max_i |d_i| = d_{\\max}$。\n\n- 测试用例 4 (单位矩阵标量倍的带状幂零扰动)：\n  - 维度：$n = 100$。\n  - 参数：$\\alpha = 2$，带宽 $p = 3$。\n  - 算子作用：对于任意 $x \\in \\mathbb{R}^n$，定义 $y = A x \\in \\mathbb{R}^n$ 如下\n    $$\n    y = \\alpha x + \\sum_{k=1}^{p} N_k x,\n    $$\n    其中对于 $i=1,2,\\dots,n-k$，$(N_k x)_i = x_{i+k}$，而对于 $i>n-k$，$(N_k x)_i = 0$。\n  - 子空间维度：$m = 50$。\n  - 真实谱半径：由于 $A = \\alpha I + N$ 且 $N$ 是幂零的，所以 $\\rho(A) = |\\alpha|$。\n\n对于每个测试用例，计算绝对误差\n$$\n\\varepsilon = \\left|\\max_{\\mu \\in \\sigma(H_m)} |\\mu| - \\rho(A)\\right|,\n$$\n其中 $H_m$ 是 $A$ 在由归一化 $v_0$ 生成的 $m$ 维 Krylov 子空间上的正交投影。如果由于精确或近似的崩溃（breakdown），Krylov 子空间的维度严格小于 $m$，则在构建 $H_m$ 时使用实际构造的子空间维度。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列结果，每个数字四舍五入到八位小数（例如，$[0.12345678,0.00000000,0.5,1.23456789]$）。不应打印任何其他文本。", "solution": "该问题要求计算线性算子 $A$ 的真实谱半径与通过 Arnoldi 迭代获得的近似值之间的绝对误差。谱半径 $\\rho(A)$ 定义为 $A$ 的特征值的最大绝对值。Arnoldi 迭代是一种数值方法，用于寻找一个一般的、通常是大型稀疏的非对称矩阵或线性算子的部分特征值。一个关键约束是，算子 $A$ 只能通过其对向量的作用来访问，即作为一个函数，对于给定的 $x$ 返回 $Ax$。\n\nArnoldi 迭代为 Krylov 子空间 $K_m(A, v_1) = \\mathrm{span}\\{v_1, A v_1, A^2 v_1, \\dots, A^{m-1} v_1\\}$ 构建一个标准正交基，其中 $v_1$ 是单位范数的起始向量，$m$ 是子空间的维度。设标准正交基向量是矩阵 $V_m = [v_1, v_2, \\dots, v_m] \\in \\mathbb{R}^{n \\times m}$ 的列。该过程还生成一个 $m \\times m$ 的上海森堡（upper Hessenberg）矩阵 $H_m$，它表示算子 A 在 Krylov 子空间上的正交投影：$H_m = V_m^\\top A V_m$。\n\n这个较小矩阵 $H_m$ 的特征值，记为 $\\{\\mu_k\\}_{k=1}^m$，被称为 Ritz 值。它们用作原始算子 $A$ 的特征值的近似。$A$ 的谱半径的 Ritz 估计值由 $\\hat{\\rho}_m(A) = \\max_{k=1,\\dots,m} |\\mu_k|$ 给出。目标是为几个测试用例计算绝对误差 $\\varepsilon = |\\hat{\\rho}_m(A) - \\rho(A)|$。\n\n基 $V_m$ 和矩阵 $H_m$ 的构建是通过一个稳定的 Gram-Schmidt 正交化过程来执行的。给定一个归一化的起始向量 $v_1$，算法按如下步骤进行，$j=1, 2, \\dots, m$：\n1.  计算 Krylov 序列中的下一个向量：$w \\gets A v_j$。\n2.  将 $w$ 与先前生成的基向量 $\\{v_1, \\dots, v_j\\}$ 正交化。这通过迭代 $i = 1, \\dots, j$ 来实现：\n    a.  计算投影系数：$h_{ij} \\gets v_i^\\top w$。\n    b.  减去投影：$w \\gets w - h_{ij} v_i$。\n3.  所得向量 $w$ 的范数是 Hessenberg 矩阵的下一个次对角线元素：$h_{j+1, j} \\gets \\|w\\|_2$。\n4.  如果 $h_{j+1, j}$ 在数值上为零，这表示发生了崩溃（breakdown）。Krylov 子空间在 $A$ 下是不变的，其维度为 $j$，小于期望的 $m$。算法终止，得到的投影是一个 $j \\times j$ 的矩阵。\n5.  如果没有发生崩溃，则将新向量归一化以获得下一个基向量：$v_{j+1} \\gets w / h_{j+1, j}$。\n\n系数 $h_{ij}$（其中 $i \\in \\{1,\\dots,j\\}$）和 $h_{j+1,j}$ 构成了 $(m+1) \\times m$ 的上海森堡矩阵 $\\tilde{H}_m$ 的元素。所求的矩阵 $H_m$ 是 $\\tilde{H}_m$ 的上部 $m \\times m$ 子矩阵。\n\n对于每个测试用例，实现需要一个特定的函数来计算算子 $A$ 对任意向量 $x$ 的作用。初始向量 $v_0$ 按分量定义为 $(v_0)_i = \\sin(i) + \\frac{1}{2}\\cos(2i)$，$i=1, \\dots, n$，然后归一化为 $v_1 = v_0/\\|v_0\\|_2$ 以开始迭代。\n\n-   **测试用例 1 (三对角 Toeplitz 算子)**：此算子的作用由一个简单的模板定义，可以使用向量运算高效实现。真实谱半径由基于其参数 $a, b, c$ 的解析公式给出。\n-   **测试用例 2 (Jordan 块)**：算子作用对应于与矩阵 $J = \\lambda I + N$ 相乘，其中 $N$ 是在第一条超对角线上元素为一的幂零矩阵。其对向量的作用很容易计算。真实谱半径就是 $|\\lambda|$。\n-   **测试用例 3 (相似变换)**：算子为 $A = S D S^{-1}$，其中 $D$ 是对角矩阵，$S$ 是一个指定的稠密矩阵。其作用 $y = A x$ 必须按顺序计算：首先，求解线性系统 $S z = x$ 以获得 $z=S^{-1}x$；其次，计算逐元素乘积 $w=Dz$；最后，计算矩阵向量乘积 $y=Sw$。真实谱半径是 $D$ 的对角元素的最大绝对值。\n-   **测试用例 4 (扰动单位阵)**：算子为 $A = \\alpha I + N$，其中 $N$ 是一系列移位算子的和，使其成为一个严格上三角矩阵，因而是幂零的。$A$ 的所有特征值都等于 $\\alpha$，因此 $\\rho(A) = |\\alpha|$。其作用通过缩放输入向量并加上其移位后的版本来计算。\n\n对于每种情况，执行 Arnoldi 迭代以构建 $H_m$。用数值方法计算 $H_m$ 的特征值，其中最大的模长给出了 Ritz 估计值 $\\hat{\\rho}_m(A)$。然后将其与已知的真实谱半径 $\\rho(A)$ 进行比较，以求得所需的绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef arnoldi_iteration(A_op, v_start, m):\n    \"\"\"\n    Performs Arnoldi iteration to find the Hessenberg projection H_m.\n    This implementation uses a modified Gram-Schmidt process for stability.\n\n    Args:\n        A_op: A function that computes A @ x.\n        v_start: The normalized starting vector of size n.\n        m: The desired dimension of the Krylov subspace.\n\n    Returns:\n        H: The m_eff x m_eff upper Hessenberg matrix, where m_eff = m is\n           the effective dimension upon breakdown.\n    \"\"\"\n    n = v_start.shape[0]\n    V = np.zeros((n, m + 1), dtype=np.float64)\n    H = np.zeros((m + 1, m), dtype=np.float64)\n    \n    # A small tolerance for breakdown detection\n    tolerance = np.finfo(np.float64).eps * n\n    \n    V[:, 0] = v_start\n    \n    for j in range(m):\n        w = A_op(V[:, j])\n        \n        # Orthogonalize w against the existing basis V using modified Gram-Schmidt\n        for i in range(j + 1):\n            h_ij = np.dot(V[:, i], w)\n            w -= h_ij * V[:, i]\n            H[i, j] = h_ij\n        \n        h_jp1_j = np.linalg.norm(w)\n        \n        if h_jp1_j  tolerance:\n            # Breakdown: Krylov subspace has dimension j+1\n            m_eff = j + 1\n            return H[:m_eff, :m_eff]\n            \n        H[j + 1, j] = h_jp1_j\n        V[:, j + 1] = w / h_jp1_j\n        \n    return H[:m, :m]\n\ndef solve():\n    \"\"\"\n    Solves the problem for all specified test cases.\n    \"\"\"\n    # Define operator factories and true spectral radii for each test case\n    \n    def get_op1(n, params):\n        a, b, c = params['a'], params['b'], params['c']\n        def op(x):\n            y = np.zeros_like(x)\n            y[0] = a * x[0] + b * x[1]\n            y[1:-1] = c * x[:-2] + a * x[1:-1] + b * x[2:]\n            y[-1] = c * x[-2] + a * x[-1]\n            return y\n        return op\n    \n    def get_op2(n, params):\n        lam = params['lambda']\n        def op(x):\n            y = np.zeros_like(x)\n            y[:-1] = lam * x[:-1] + x[1:]\n            y[-1] = lam * x[-1]\n            return y\n        return op\n        \n    def get_op3(n, params):\n        d_max, d_min = params['d_max'], params['d_min']\n        i_vec = np.arange(1, n + 1)\n        d = d_min + (d_max - d_min) * (n - i_vec) / (n - 1)\n        \n        i_v = i_vec[:, None]\n        j_h = i_vec[None, :]\n        S = np.eye(n) + 1e-2 * np.sin(i_v * j_h / (n + 1))\n        \n        # Return a closure that has pre-computed S and d\n        def op(x):\n            # y = S * D * S_inv * x\n            z = np.linalg.solve(S, x)\n            w = d * z\n            y = S @ w\n            return y\n        return op\n\n    def get_op4(n, params):\n        alpha, p = params['alpha'], params['p']\n        def op(x):\n            y = alpha * x.copy()\n            for k in range(1, p + 1):\n                y[:n-k] += x[k:]\n            return y\n        return op\n\n    test_cases = [\n        {\n            \"n\": 80, \"m\": 25, \"params\": {\"a\": 1.0, \"b\": 2.0, \"c\": 0.5},\n            \"A_op_factory\": get_op1,\n            \"true_rho\": lambda p: max(abs(p['a'] + 2 * np.sqrt(p['b'] * p['c'])), \n                                      abs(p['a'] - 2 * np.sqrt(p['b'] * p['c'])))\n        },\n        {\n            \"n\": 60, \"m\": 15, \"params\": {\"lambda\": 3.0},\n            \"A_op_factory\": get_op2,\n            \"true_rho\": lambda p: abs(p['lambda'])\n        },\n        {\n            \"n\": 50, \"m\": 30, \"params\": {\"d_max\": 5.0, \"d_min\": 1.0},\n            \"A_op_factory\": get_op3,\n            \"true_rho\": lambda p: p['d_max']\n        },\n        {\n            \"n\": 100, \"m\": 50, \"params\": {\"alpha\": 2.0, \"p\": 3},\n            \"A_op_factory\": get_op4,\n            \"true_rho\": lambda p: abs(p['alpha'])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n, m, params = case[\"n\"], case[\"m\"], case[\"params\"]\n        \n        # 1. Define initial vector\n        i_vals = np.arange(1, n + 1)\n        v0_unnormalized = np.sin(i_vals) + 0.5 * np.cos(2 * i_vals)\n        v0_norm = np.linalg.norm(v0_unnormalized)\n        v0_normalized = v0_unnormalized / v0_norm\n\n        # 2. Get operator and true spectral radius\n        A_op = case[\"A_op_factory\"](n, params)\n        true_rho = case[\"true_rho\"](params)\n        \n        # 3. Run Arnoldi iteration\n        H_m = arnoldi_iteration(A_op, v0_normalized, m)\n        \n        # 4. Compute Ritz estimate and error\n        if H_m.shape[0] > 0:\n            ritz_values = np.linalg.eigvals(H_m)\n            ritz_rho = np.max(np.abs(ritz_values))\n        else: # This case happens if m=0 or breakdown with j=0\n            ritz_rho = 0.0\n\n        error = abs(ritz_rho - true_rho)\n        results.append(f\"{error:.8f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2373518"}, {"introduction": "虽然阿诺尔迪迭代是求解特征值的有力工具，但其收敛速度会受到矩阵性质的显著影响，尤其是“非正规性”（non-normality）。非正规矩阵的幂次范数（$\\|A^k\\|_2$）在最终衰减之前，可能会经历显著的瞬态增长，这种行为与阿诺尔迪迭代的收敛困难密切相关。本练习将通过构造具有可调非正规性的矩阵，并量化其瞬态增长与阿诺尔迪迭代收敛速度之间的关系，来深入探索这一现象 [@problem_id:2373528]，从而揭示非对称特征值问题的一个核心挑战。", "problem": "您必须编写一个完整且可运行的程序，用以构建特定的非对称矩阵，这些矩阵的幂在最终衰减之前会表现出显著的瞬态增长，然后量化此行为与用于近似主导特征值大小的 Arnoldi 迭代收敛性之间的关联。您的程序必须显式实现 Arnoldi 过程，不得调用任何用于 Krylov 方法的内置特征求解器。所有计算均为纯数学计算，不涉及任何物理单位或角度。\n\n从以下基本定义开始：\n- 方阵 $A \\in \\mathbb{C}^{n \\times n}$ 的谱半径为 $\\rho(A) \\equiv \\max \\{ |\\lambda| : \\lambda \\text{ is an eigenvalue of } A \\}$。\n- 谱范数为 $\\|A\\|_2 \\equiv \\sigma_{\\max}(A)$，即 $A$ 的最大奇异值。\n- 如果 $A^\\ast A \\neq A A^\\ast$，则矩阵 $A$ 是非正规的，其中 $A^\\ast$ 表示共轭转置。\n- 由 $A$ 和一个非零向量 $b$ 生成的 $m$ 步 Krylov 子空间是 $\\mathcal{K}_m(A,b) \\equiv \\text{span}\\{ b, Ab, A^2 b, \\dots, A^{m-1} b \\}$。\n- Arnoldi 迭代构建 $\\mathcal{K}_m(A,b)$ 的一个标准正交基 $V_m$ 和一个上 Hessenberg 矩阵 $H_m \\in \\mathbb{C}^{m \\times m}$，使得在最小二乘意义上 $A V_m \\approx V_m H_m$。$H_m$ 的特征值被称为 Ritz 值，用于近似 $A$ 的特征值。\n\n通过相似变换 $A = V \\Lambda V^{-1}$ 来构造具有预设特征值和可调非正规性参数的测试矩阵。设 $n \\in \\mathbb{N}$，并通过以下公式定义实特征值 $\\{\\lambda_i\\}_{i=1}^n$\n$$\n\\lambda_i \\equiv 0.95 - 0.75 \\cdot \\frac{i-1}{n-1}, \\quad i = 1,2,\\dots,n,\n$$\n使得 $\\rho(A) = \\max_i |\\lambda_i| = 0.95  1$。为构建 $V$，首先通过对一个具有固定种子的随机高斯矩阵进行瘦 QR 分解来形成一个正交矩阵 $Q$，然后用一个由 $\\gamma  0$ 控制的几何级数来缩放其列：\n$$\nV \\equiv Q D_\\gamma, \\quad D_\\gamma \\equiv \\mathrm{diag}\\big(\\gamma^{0}, \\gamma^{1}, \\dots, \\gamma^{n-1}\\big).\n$$\n当 $\\gamma = 1$ 时，$V$ 是正交的，$A$ 是正规的；当 $\\gamma  1$ 时，$V$ 是病态的，$A$ 变得越来越非正规。\n\n对于下面套件中的每个测试矩阵 $A$，计算两个量：\n1. 瞬态增长因子\n$$\nG \\equiv \\max_{1 \\le k \\le K_{\\max}} \\frac{\\|A^k\\|_2}{\\rho(A)^k}.\n$$\n该值衡量了相对于渐近衰减率 $\\rho(A)^k$ 的最坏情况放大倍数。因为所有 $\\lambda_i$ 都满足 $|\\lambda_i|  1$，$\\|A^k\\|_2$ 最终会随 $k$ 的增加而衰减，但对于非正规矩阵 $A$，它可以在中等的 $k$ 值时显著增长。\n2. Arnoldi 收敛指数 $m_\\ast$，定义为使 $H_m$ 的模最大 Ritz 值（称之为 $\\lambda_{\\text{Ritz}}^{(m)}$）满足以下条件的最小 $m \\in \\{1,2,\\dots,m_{\\max}\\}$：\n$$\n\\left|\\,|\\lambda_{\\text{Ritz}}^{(m)}| - \\rho(A)\\,\\right| \\le \\varepsilon.\n$$\n如果在达到 $m_{\\max}$ 之前不存在这样的 $m$，或者 Arnoldi 过程在达到 $m_{\\max}$ 之前崩溃，则设 $m_\\ast \\equiv -1$。\n\n使用修正的 Gram–Schmidt 正交化实现 Arnoldi 迭代。使用一个从标准正态分布中抽取的固定起始向量 $b$，然后将其归一化为单位欧几里得范数。\n\n测试套件（四个标量和一个向量完全指定所有情况）：\n- 矩阵大小：$n = 20$。\n- 特征值：如上定义的 $\\lambda_i$。\n- 随机种子：对于 $Q$，使用种子 $12345$；对于 $b$，使用种子 $54321$。\n- 增长范围：$K_{\\max} = 60$。\n- Arnoldi 限制与容差：$m_{\\max} = 20$，$\\varepsilon = 10^{-6}$。\n- 非正规性参数：$\\gamma \\in \\{1.0, 1.5, 2.5\\}$。\n\n您的程序必须生成单行输出，其中包含一个列表，每个测试用例对应一个条目，顺序与所列的 $\\gamma$ 值相同。每个条目本身必须是一个双元素列表 $[G_{\\mathrm{rounded}}, m_\\ast]$，其中 $G_{\\mathrm{rounded}}$ 是 $G$ 四舍五入到小数点后三位的值，$m_\\ast$ 是如上定义的整数。因此，最终打印的行必须具有以下形式\n$$\n\\big[ [G_1, m_{\\ast,1}], [G_2, m_{\\ast,2}], [G_3, m_{\\ast,3}] \\big],\n$$\n不含多余的空格和附加文本。", "solution": "矩阵幂瞬态增长背后的基本机制是非正规性。如果一个矩阵 $A$ 可通过酉（实数情况下为正交）相似变换对角化，那么对于所有 $k$，都有 $\\|A^k\\|_2 = \\rho(A)^k$，因为谱范数在酉相似变换下是不变的，且正规矩阵的谱范数等于其特征值的最大模。因此，对于所有特征值都严格位于单位圆盘内的正规矩阵 $A$，$\\|A^k\\|_2$ 会随着 $k$ 的增加而单调衰减。\n\n然而，如果 $A$ 是非正规的，那么在由 $\\rho(A)^k$ 决定的最终衰减发生之前，$\\|A^k\\|_2$ 可以在中等的 $k$ 值时表现出显著增长。最简单的解析示例是使用 Jordan 块。考虑 $A = \\alpha I + N$，其中 $\\alpha \\in \\mathbb{C}$ 满足 $|\\alpha|  1$，$N$ 是一个严格上三角矩阵，其第一条超对角线上的元素为 1，其他地方为 0，因此 $N$ 是幂零的。使用二项式恒等式，\n$$\nA^k = (\\alpha I + N)^k = \\sum_{j=0}^{k} \\binom{k}{j} \\alpha^{k-j} N^j,\n$$\n并注意到对于直到矩阵大小的 $j$，$N^j$ 在第 $j$ 条超对角线上有 1，可以看出 $\\|A^k\\|_2$ 包含 $\\binom{k}{j} |\\alpha|^{k-j}$ 阶的项，这些项由于多项式因子的存在，最初会随 $k$ 增长，之后才被来自 $|\\alpha|^{k}$ 的几何衰减所主导。这会产生一个瞬态增长，其峰值大致按 $k$ 的多项式乘以 $|\\alpha|^k$ 的比例缩放，当 $|\\alpha|$ 接近 1 时，在某个中等的 $k$ 值（接近 $1/(-\\log|\\alpha|)$）处达到最大值。\n\n在计算实践中，精确的 Jordan 块很少见；相反，当一个可对角化矩阵在其分解 $A = V \\Lambda V^{-1}$ 中具有一个病态的特征向量矩阵 $V$ 时，就会出现强非正规性。在这种情况下，$A$ 的伪谱很大，范数 $\\|A^k\\|_2$ 可能会瞬态增长。一种实用的参数化方法是设 $V = Q D_\\gamma$，其中 $Q$ 是通过对高斯随机矩阵进行瘦 QR 分解得到的正交矩阵，而 $D_\\gamma = \\mathrm{diag}(\\gamma^0,\\gamma^1,\\dots,\\gamma^{n-1})$。对于 $\\gamma = 1$，$V$ 是正交的，$A$ 是正规的。对于 $\\gamma  1$，$V$ 变得越来越病态，$A$ 在保持相同特征值的同时变得越来越非正规。\n\n现在我们将此与 Arnoldi 迭代联系起来。Arnoldi 过程通过将 $A$ 重复应用于 $b$ 并进行 Gram–Schmidt 正交化，为 Krylov 子空间 $\\mathcal{K}_m(A,b)$ 构建一个标准正交基 $V_m$。该过程产生一个 $m \\times m$ 的上 Hessenberg 矩阵 $H_m = V_m^\\ast A V_m$，其特征值（Ritz 值）近似于 $A$ 的特征值。由模最大的 Ritz 值对主导特征值大小 $\\rho(A)$ 的近似通常随着 $m$ 的增加而改善。然而，对于非正规矩阵，Krylov 子空间初始时可能由与瞬态增长相关的方向主导，而不是渐近的特征向量对齐方向，这导致 Ritz 值向真实谱半径的收敛速度变慢。因此，我们预期存在一种相关性：较大的瞬态增长因子 $G \\equiv \\max_{1 \\le k \\le K_{\\max}} \\|A^k\\|_2 / \\rho(A)^k$ 往往与 Arnoldi 迭代在容差范围内近似 $\\rho(A)$ 所需的最小 $m$ 值较大相关。\n\n程序中的算法设计直接遵循这些原则：\n1. 固定 $n$、特征值 $\\{\\lambda_i\\}$、用于可复现性的种子以及测试套件的非正规性参数 $\\gamma$。通过对使用指定种子生成的高斯矩阵进行瘦 QR 分解来构建 $Q$。对于每个 $\\gamma$，形成 $V = Q D_\\gamma$ 并计算 $A = V \\Lambda V^{-1}$。这样，$A$ 的特征值就精确为 $\\{\\lambda_i\\}$，因此谱半径为 $\\rho(A) = \\max_i |\\lambda_i|$，在我们的构造中等于 $0.95$。\n2. 通过重复相乘迭代计算 $A^k$（其中 $k = 1, 2, \\dots, K_{\\max}$），将 $\\|A^k\\|_2$ 作为最大奇异值（谱范数）进行评估，并记录 $\\max_k \\|A^k\\|_2 / \\rho(A)^k$，从而计算瞬态增长因子 $G$。由于 $\\rho(A)  1$，$\\|A^k\\|_2$ 最终会衰减，因此当 $A$ 非正规时，最大值会在一个中等的 $k$ 值处达到。\n3. 使用修正的 Gram–Schmidt 方法实现 Arnoldi 过程，以生成 $V_m$ 和 $H_m$ 直到 $m_{\\max}$。在每个 $m$ 处，将 $H_m$ 的特征值作为 Ritz 值进行计算，并选择模最大的那个。找到最小的 $m$，使得该模与 $\\rho(A)$ 之间的绝对误差小于或等于容差 $\\varepsilon$。如果未找到这样的 $m$ 或者在达到 $m_{\\max}$ 之前发生崩溃，则报告 $m_\\ast = -1$。\n4. 汇总所有指定 $\\gamma$ 值的结果。对于 $\\gamma = 1$（正规情况），瞬态增长因子 $G$ 应接近 1，Arnoldi 收敛指数 $m_\\ast$ 应相对较小。随着 $\\gamma$ 的增加，$G$ 通常会增长到 1 以上，$m_\\ast$ 也趋于增加，这反映了非正规性对 Arnoldi 收敛的影响。\n\n最后，程序以所需的确切格式打印单行结果列表：一个包含三个双元素列表 $[G_{\\mathrm{rounded}}, m_\\ast]$ 的列表，按测试套件中 $\\gamma$ 值的顺序排列。", "answer": "```python\nimport numpy as np\n\ndef build_Q_from_seed(n: int, seed: int) -> np.ndarray:\n    rng = np.random.default_rng(seed)\n    X = rng.standard_normal((n, n))\n    Q, _ = np.linalg.qr(X)  # Thin QR; Q is orthonormal\n    return Q\n\ndef build_V(Q: np.ndarray, gamma: float) -> np.ndarray:\n    n = Q.shape[0]\n    scales = gamma ** np.arange(n, dtype=float)\n    D = np.diag(scales)\n    return Q @ D\n\ndef build_A_from_V_lambda(V: np.ndarray, lambdas: np.ndarray) -> np.ndarray:\n    # A = V * diag(lambdas) * V^{-1}\n    n = V.shape[0]\n    Vinv = np.linalg.inv(V)\n    return V @ np.diag(lambdas) @ Vinv\n\ndef spectral_radius(lambdas: np.ndarray) -> float:\n    return float(np.max(np.abs(lambdas)))\n\ndef spectral_norm(A: np.ndarray) -> float:\n    # 2-norm via largest singular value\n    # Use SVD with no vectors for stability on small n\n    s = np.linalg.svd(A, compute_uv=False)\n    return float(s[0])\n\ndef transient_growth_factor(A: np.ndarray, rho: float, Kmax: int) -> float:\n    n = A.shape[0]\n    Apow = np.eye(n)\n    max_ratio = 0.0\n    for k in range(1, Kmax + 1):\n        Apow = Apow @ A\n        norm_Ak = spectral_norm(Apow)\n        denom = rho ** k\n        # Avoid division by extremely small numbers; rho^k > 0 since rho>0; here rho=0.95>0.\n        ratio = norm_Ak / denom if denom != 0.0 else np.inf\n        if ratio > max_ratio:\n            max_ratio = ratio\n    return max_ratio\n\ndef arnoldi_modified_gram_schmidt(A: np.ndarray, b: np.ndarray, m_max: int):\n    n = A.shape[0]\n    V = np.zeros((n, m_max + 1))\n    H = np.zeros((m_max + 1, m_max))\n    beta = np.linalg.norm(b)\n    if beta == 0.0:\n        raise ValueError(\"Starting vector b must be nonzero.\")\n    V[:, 0] = b / beta\n    m_effective = 0\n    for j in range(m_max):\n        w = A @ V[:, j]\n        # Modified Gram-Schmidt\n        for i in range(j + 1):\n            H[i, j] = np.dot(V[:, i].conj(), w)\n            w = w - H[i, j] * V[:, i]\n        # Optional one-step reorthogonalization for numerical stability\n        for i in range(j + 1):\n            h_correction = np.dot(V[:, i].conj(), w)\n            H[i, j] += h_correction\n            w = w - h_correction * V[:, i]\n        h_next = np.linalg.norm(w)\n        H[j + 1, j] = h_next\n        m_effective = j + 1\n        if h_next = 1e-14:\n            # Happy breakdown: Krylov subspace is invariant; stop early\n            break\n        V[:, j + 1] = w / h_next\n    return V[:, :m_effective + 1], H[:m_effective + 1, :m_effective]\n\ndef arnoldi_convergence_index(A: np.ndarray, b: np.ndarray, rho: float, m_max: int, tol: float) -> int:\n    V, H_full = arnoldi_modified_gram_schmidt(A, b, m_max)\n    # H_full has shape (m_eff+1, m_eff); number of completed Arnoldi steps is m_eff\n    m_eff = H_full.shape[1]\n    m_star = -1\n    for m in range(1, m_eff + 1):\n        Hm = H_full[:m, :m]\n        ritz = np.linalg.eigvals(Hm)\n        # Choose Ritz value with largest modulus\n        idx = int(np.argmax(np.abs(ritz)))\n        ritz_max = ritz[idx]\n        err = abs(abs(ritz_max) - rho)\n        if err = tol:\n            m_star = m\n            break\n    # If we didn't reach m_max due to breakdown and no convergence, return -1\n    if m_star == -1 and m_eff  m_max:\n        return -1\n    # If we reached m_max and still no convergence, also return -1\n    return m_star\n\ndef solve():\n    # Test suite parameters\n    n = 20\n    # Define eigenvalues: lambda_i = 0.95 - 0.75 * (i-1)/(n-1), i=1..n\n    lam = np.array([0.95 - 0.75 * (i) / (n - 1) for i in range(0, n)], dtype=float)\n    rho = spectral_radius(lam)\n    seed_Q = 12345\n    seed_b = 54321\n    Kmax = 60\n    m_max = 20\n    tol = 1e-6\n    gammas = [1.0, 1.5, 2.5]\n\n    # Build Q and starting vector b\n    Q = build_Q_from_seed(n, seed_Q)\n    rng_b = np.random.default_rng(seed_b)\n    b = rng_b.standard_normal(n)\n    b_norm = np.linalg.norm(b)\n    if b_norm == 0.0:\n        b[0] = 1.0\n        b_norm = 1.0\n    b = b / b_norm\n\n    results = []\n    for gamma in gammas:\n        V = build_V(Q, gamma)\n        A = build_A_from_V_lambda(V, lam)\n        G = transient_growth_factor(A, rho, Kmax)\n        m_star = arnoldi_convergence_index(A, b, rho, m_max, tol)\n        # Round G to three decimals\n        G_round = round(G + 1e-12, 3)  # small epsilon to stabilize rounding\n        results.append([G_round, m_star])\n\n    # Print in exact required format: no spaces\n    out = \"[\" + \",\".join(f\"[{res[0]},{res[1]}]\" for res in results) + \"]\"\n    print(out)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2373528"}, {"introduction": "在许多应用中，我们不仅对最大的特征值感兴趣，还需要计算多个具有最大模的特征值。一个简单重启的阿诺尔迪方法可能会在每次重启后反复“重新发现”已经收敛的特征对，从而导致效率低下。本练习旨在通过实现一种“锁定与放缩”（locking and deflation）机制来解决此问题 [@problem_id:2373565]，该机制可以有效地将已收敛的特征向量从后续的计算中“移除”，从而引导算法专注于寻找新的未知特征对，这是构建鲁棒特征值求解器的关键一步。", "problem": "实现一个完整且可运行的程序，比较两种近似给定实非对称矩阵最大模特征对的方法：一种方法维护并强制与一组先前已收敛的近似特征向量保持正交性（带紧缩的锁定），另一种方法在重启过程中不维护这样的锁定集。目标是量化锁定如何减少获得指定数量的主特征对所需的矩阵向量乘积次数。您的程序必须是确定性的，并且不得读取输入。\n\n您将获得以下规范。\n\n1) 数学设定。\n\n- 令 $A \\in \\mathbb{R}^{n \\times n}$ 为一个实非对称矩阵。对于任意非零向量 $u \\in \\mathbb{C}^{n}$ 和标量 $\\theta \\in \\mathbb{C}$，近似特征对 $(\\theta,u)$ 的残差定义为 $r \\equiv A u - \\theta u$。残差范数为 $\\lVert r \\rVert_{2}$。\n- 如果满足 $\\lVert A u - \\theta u \\rVert_{2} \\le \\varepsilon$，则认为范数为 $\\lVert u \\rVert_{2} = 1$ 的特征对 $(\\theta,u)$ 已经收敛，其中 $\\varepsilon$ 是一个给定的容差。\n- 主特征对是指其特征值相对于其余特征值具有最大绝对值的特征对。对于一个请求的数目 $k \\in \\mathbb{N}$，目标集合是与 $k$ 个最大绝对值的特征值相对应的 $k$ 个特征对（相等情况可任意处理）。\n\n2) 带锁定和不带锁定的子空间构造。\n\n- 在迭代过程中，通过对初始向量重复应用 $A$ 来构造维度至多为 $m \\in \\mathbb{N}$ 的克雷洛夫子空间。每次将 $A$ 应用于一个向量计为一次矩阵向量乘积。在构建并处理一个维度至多为 $m$ 的子空间后，您可以通过丢弃该子空间并从一个新的初始向量开始来重启。这定义了一个周期。您可以执行多个周期，直到请求的 $k$ 个主特征对已经收敛。\n- 带紧缩的锁定：维护一个当前已收敛的单位范数近似特征向量集合 $\\mathcal{L}$。在任何时候，确保任何用于扩展子空间的新生成向量 $w$ 对所有 $u \\in \\mathcal{L}$ 都满足 $u^{*} w = 0$（关于标准复内积的正交性），即，将 $w$ 投影到 $\\mathrm{span}(\\mathcal{L})$ 的正交补上。当新的近似特征对收敛时，将其向量（经过正交规范化后）附加到 $\\mathcal{L}$。继续此过程直到 $|\\mathcal{L}| = k$。\n- 不锁定：在周期之间不维护任何集合 $\\mathcal{L}$。在每个周期中，识别当前子空间内已收敛的近似特征对；跨周期累积它们的特征值，作为一个唯一值的集合（在绝对差上小于一个小的阈值内被视为不同），直到收集到 $k$ 个唯一的已收敛特征值。在构造新子空间时，不对先前发现的向量进行紧缩。\n\n3) 子空间内的收敛性评估。\n\n- 在任何维度为 $j \\le m$ 且具有正交规范基 $V_{j} \\in \\mathbb{C}^{n \\times j}$ 的子空间中，形成一个投影矩阵 $H_{j} \\in \\mathbb{C}^{j \\times j}$，并计算其特征对 $(\\theta, y)$，其中 $y \\in \\mathbb{C}^{j}$。对于每个这样的对，形成 Ritz 向量 $u = V_{j} y / \\lVert V_{j} y \\rVert_{2}$ 和残差范数 $\\lVert A u - \\theta u \\rVert_{2}$。使用这些残差范数和容差 $\\varepsilon$ 来判断收敛性。\n- 在任何周期内，当识别要记录（以及在锁定变体中要锁定）哪些已收敛的近似特征对时，优先考虑与最大绝对值 $|\\theta|$ 相关联的那些，并通过将特征值的绝对差与一个小阈值进行比较来避免计数或锁定重复项。\n\n4) 测试套件。\n\n对于每个测试用例，构造 $A$ 为 $A = S D S^{-1}$，其中 $D$ 是具有指定对角元素的对角矩阵，$S$ 是一个稠密的实矩阵，使用固定的种子伪随机生成，其元素从区间 $[-1,1]$ 中均匀抽取，直到获得一个可逆的 $S$。用于周期的所有初始向量也使用该用例的相同种子规范进行伪随机抽取，并且在锁定激活时，会被投影以与锁定集正交。所有随机抽取必须是可复现的。\n\n测试套件包含三个用例：\n\n- 用例1（顺利情况）：$n = 8$, $D = [5.0, 3.0, 2.0, 1.0, 0.5, -0.2, -1.5, 4.0]$, $k = 3$, $m = 4$, $\\varepsilon = 10^{-8}$, 最大周期数 $C_{\\max} = 200$, 随机种子 $10$。\n- 用例2（特征值接近）：$n = 10$, $D = [4.0, 3.99, 1.0, 0.1, -0.1, 2.0, -2.0, 0.5, 0.49, -3.0]$, $k = 3$, $m = 5$, $\\varepsilon = 10^{-8}$, $C_{\\max} = 200$, 随机种子 $21$。\n- 用例3（单个主特征值，小子空间）：$n = 6$, $D = [-5.0, -1.0, -2.0, 0.1, 0.2, 0.3]$, $k = 1$, $m = 2$, $\\varepsilon = 10^{-8}$, $C_{\\max} = 200$, 随机种子 $7$。\n\n以上所有数字都是无量纲的。将任何绝对差和容差表示为实数。\n\n5) 要求输出。\n\n- 对每个用例，运行两种方法，直到请求的 $k$ 个主特征对根据标准 $\\lVert A u - \\theta u \\rVert_{2} \\le \\varepsilon$ 收敛，或者直到达到周期限制 $C_{\\max}$。将矩阵向量乘积次数计为在跨周期的子空间扩展期间发生的 $A$ 应用于向量的总次数，分别对不锁定和锁定方法进行计数。\n- 如果任一方法在达到 $C_{\\max}$ 时仍未满足收敛目标，则返回该方法到目前为止累计的矩阵向量乘积次数。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。对每个用例，输出一个双元素列表 $[M_{\\mathrm{no\\_lock}}, M_{\\mathrm{lock}}]$，其中包含分别代表不锁定和锁定方法的矩阵向量乘积计数的整数。最终格式必须是像 $[[a,b],[c,d],[e,f]]$ 这样的单行，其中 $a,b,c,d,e,f$ 是整数。", "solution": "所述问题是有效的。它提出了一个在数值线性代数领域内适定（well-posed）且具有科学依据的任务，该领域是计算物理学的基石。该问题要求对一种用于寻找非对称矩阵主特征对的重启克雷洛夫子空间方法的两种标准变体进行实证比较。所有参数和过程都以足够的清晰度和客观性进行了规定，从而可以得到唯一、可验证的解。\n\n任务的核心是为一个给定的实非对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，近似求解指定数量 $k$ 的、对应于最大模特征值 $\\lambda$ 的特征对 $(\\lambda, u)$。基本方程是 $A u = \\lambda u$。所提出的方法是一种重启克雷洛夫子空间迭代，这是 Arnoldi 方法的一种实际实现。\n\n让我们首先形式化算法的共同组成部分。该方法生成一系列克雷洛夫子空间 $\\mathcal{K}_j(A, v_1) = \\mathrm{span}\\{v_1, Av_1, \\dots, A^{j-1}v_1\\}$，其中 $v_1$ 是一个起始向量，满足 $\\lVert v_1 \\rVert_2 = 1$。Arnoldi 过程为 $\\mathcal{K}_j(A, v_1)$ 构造一个正交规范基 $V_j = [v_1, v_2, \\dots, v_j]$。该过程同时生成一个上 Hessenberg 矩阵 $H_j = V_j^* A V_j \\in \\mathbb{C}^{j \\times j}$，其中星号表示共轭转置。$m$ 步后的关键 Arnoldi 关系是：\n$$\nA V_m = V_m H_m + h_{m+1,m} v_{m+1} e_m^T\n$$\n其中 $V_m \\in \\mathbb{C}^{n \\times m}$ 具有正交规范列，$H_m \\in \\mathbb{C}^{m \\times m}$ 是上 Hessenberg 矩阵，$v_{m+1}$ 是一个与 $V_m$ 的列正交的单位向量，$h_{m+1,m}$ 是一个非负标量，而 $e_m$ 是 $\\mathbb{R}^m$ 中的第 $m$ 个标准基向量。$V_m$ 的每一列都需要一次与 $A$ 的矩阵向量乘积，这是计算成本的主要度量。\n\n从小的 $m \\times m$ 矩阵 $H_m$ 的特征问题 $H_m y_i = \\theta_i y_i$ 中，我们提取 $A$ 的近似特征对。这些被称为 Ritz 对 $(\\theta_i, u_i)$，其中 $\\theta_i$ 是 Ritz 值，$u_i = V_m y_i$ 是对应的 Ritz 向量。问题要求通过检查残差范数 $\\lVert A u_i - \\theta_i u_i \\rVert_2 \\le \\varepsilon$ 是否满足给定的容差 $\\varepsilon$ 来评估收敛性。利用 Arnoldi 关系，可以高效地计算此范数，而无需额外的矩阵向量乘积：\n$$\n\\begin{aligned}\nA u_i - \\theta_i u_i = A(V_m y_i) - \\theta_i(V_m y_i) \\\\\n= (AV_m) y_i - V_m(\\theta_i y_i) \\\\\n= (V_m H_m + h_{m+1,m} v_{m+1} e_m^T) y_i - V_m(H_m y_i) \\\\\n= V_m H_m y_i + h_{m+1,m} v_{m+1} (e_m^T y_i) - V_m H_m y_i \\\\\n= (h_{m+1,m} \\cdot (y_i)_m) v_{m+1}\n\\end{aligned}\n$$\n其中 $(y_i)_m$ 是特征向量 $y_i$ 的最后一个分量。由于 $\\lVert v_{m+1} \\rVert_2 = 1$，残差范数恰好是 $\\lVert A u_i - \\theta_i u_i \\rVert_2 = |h_{m+1,m}| \\cdot |(y_i)_m|$。\n\n在构建一个维度为 $m$ 的子空间（一个周期）后，过程会重启。两种方法在如何利用前几个周期的信息方面有所不同。\n\n1.  **不锁定方法：** 这是一个更简单的策略。每个周期都是独立的。它从一个新的、随机生成的向量 $v_1$ 开始。在一个周期内，它识别所有已收敛的 Ritz 对。相应的 Ritz 值 $\\theta_i$ 被收集起来。为避免重复，只有当一个新发现的 $\\theta_i$ 与所有先前发现的值足够不同时，即对于集合中所有的 $\\theta_{found}$ 均满足 $|\\theta_i - \\theta_{found}| \\ge \\delta$（其中 $\\delta$ 是一个小的唯一性容差），它才会被添加到已收敛特征值的集合中。当找到 $k$ 个唯一的特征值或达到最大周期数 $C_{\\max}$ 时，过程终止。这种方法可能会在连续的周期中重复找到相同的主特征对，这可能效率低下。\n\n2.  **带紧缩的锁定方法：** 此方法旨在通过防止重新计算已收敛的特征对来提高效率。它维护一个由先前已收敛并“锁定”的特征向量组成的显式正交规范集 $\\mathcal{L} = \\{u_1, \\dots, u_p\\}$，其中 $p  k$。在新周期开始时，初始向量 $v_1$ 是随机生成的，然后显式地与 $\\mathcal{L}$ 生成的空间进行正交化：$v_1 \\leftarrow v_1 - \\sum_{i=1}^p (u_i^* v_1) u_i$。然后 Arnoldi 迭代在与 $\\mathrm{span}(\\mathcal{L})$ 正交的子空间中进行，从而有效地从问题中“紧缩”掉已知的特征向量。当新的 Ritz 对收敛时，它们的 Ritz 向量成为被锁定的候选者。为保持 $\\mathcal{L}$ 的性质，新的候选向量 $u_{new}$ 首先与当前集合 $\\mathcal{L}$ 进行正交化，然后进行归一化，最后再被添加。这确保算法将其搜索集中在谱的尚未覆盖部分。此过程一直持续到 $|\\mathcal{L}| = k$。\n\n对于这两种方法，测试矩阵都构造为 $A = S D S^{-1}$，其中 $D$ 是具有指定特征值的对角矩阵，$S$ 是一个随机生成的、可逆的实矩阵。整个过程，包括矩阵生成和起始向量的选择，都通过使用固定种子的伪随机数生成器来确保确定性。为进行公平比较，两种算法都通过为每次运行重新初始化生成器来使用相同的随机数序列执行。", "answer": "```python\nimport numpy as np\n\ndef arnoldi_iteration(A, v_start, m, locked_vectors):\n    \"\"\"\n    Performs m steps of the Arnoldi iteration to build a Krylov subspace.\n    Handles explicit deflation against locked vectors.\n    \"\"\"\n    n = A.shape[0]\n    V = np.zeros((n, m + 1), dtype=np.complex128)\n    H = np.zeros((m + 1, m), dtype=np.complex128)\n    \n    mat_vec_count = 0\n    \n    # Start vector processing\n    v = v_start\n    if locked_vectors.shape[1] > 0:\n        v = v - locked_vectors @ (locked_vectors.conj().T @ v)\n    \n    v_norm = np.linalg.norm(v)\n    if v_norm  1e-12:\n        return None, None, None, mat_vec_count, 0 # Start vector is in locked space\n\n    V[:, 0] = v / v_norm\n    \n    actual_m = m\n    for j in range(m):\n        # Apply operator and count\n        w = A @ V[:, j]\n        mat_vec_count += 1\n        \n        # Deflate against locked vectors\n        if locked_vectors.shape[1] > 0:\n            w = w - locked_vectors @ (locked_vectors.conj().T @ w)\n            \n        # Modified Gram-Schmidt against current Krylov basis V\n        for i in range(j + 1):\n            H[i, j] = V[:, i].conj().T @ w\n            w = w - H[i, j] * V[:, i]\n            \n        H[j + 1, j] = np.linalg.norm(w)\n        \n        if H[j + 1, j]  1e-12:  # Breakdown\n            actual_m = j + 1\n            break\n            \n        V[:, j + 1] = w / H[j + 1, j]\n        \n    return V[:, :actual_m], H[:actual_m, :actual_m], H[actual_m, actual_m - 1], mat_vec_count, actual_m\n\ndef run_without_locking(A, k, m, tol, max_cycles, rng):\n    \"\"\"\n    Runs restarted Arnoldi without locking/deflation.\n    \"\"\"\n    n = A.shape[0]\n    total_mat_vecs = 0\n    found_eigenvalues = set()\n    \n    for _ in range(max_cycles):\n        if len(found_eigenvalues) >= k:\n            break\n            \n        v_start = rng.random(n)\n        \n        # We pass an empty locked_vectors set, so no deflation occurs.\n        V, H, h_next, mv_cycle, actual_m = arnoldi_iteration(\n            A, v_start, m, np.zeros((n, 0))\n        )\n        \n        total_mat_vecs += mv_cycle\n        if V is None or actual_m == 0:\n            continue\n            \n        ritz_vals, ritz_vecs_H = np.linalg.eig(H)\n        \n        converged_pairs = []\n        for theta, y in zip(ritz_vals, ritz_vecs_H.T):\n            residual_norm = abs(h_next) * abs(y[-1])\n            if residual_norm = tol:\n                converged_pairs.append(theta)\n\n        # Prioritize by magnitude and add unique values\n        converged_pairs.sort(key=abs, reverse=True)\n        for theta in converged_pairs:\n            is_new = True\n            for found_val in found_eigenvalues:\n                if abs(theta - found_val)  1e-6:\n                    is_new = False\n                    break\n            if is_new and len(found_eigenvalues)  k:\n                found_eigenvalues.add(theta)\n                \n    return total_mat_vecs\n\ndef run_with_locking(A, k, m, tol, max_cycles, rng):\n    \"\"\"\n    Runs restarted Arnoldi with explicit locking and deflation.\n    \"\"\"\n    n = A.shape[0]\n    total_mat_vecs = 0\n    locked_vectors = np.zeros((n, 0), dtype=np.complex128)\n    locked_eigenvalues = []\n\n    for _ in range(max_cycles):\n        if len(locked_eigenvalues) >= k:\n            break\n\n        v_start = rng.random(n)\n        \n        V, H, h_next, mv_cycle, actual_m = arnoldi_iteration(\n            A, v_start, m, locked_vectors\n        )\n        \n        total_mat_vecs += mv_cycle\n        if V is None or actual_m == 0:\n            continue\n\n        ritz_vals, ritz_vecs_H = np.linalg.eig(H)\n\n        newly_converged = []\n        for theta, y in zip(ritz_vals, ritz_vecs_H.T):\n            residual_norm = abs(h_next) * abs(y[-1])\n            is_new = True\n            for locked_val in locked_eigenvalues:\n                if abs(theta - locked_val)  1e-6:\n                    is_new = False\n                    break\n            if is_new and residual_norm = tol:\n                u = V @ y\n                newly_converged.append({'val': theta, 'vec': u / np.linalg.norm(u)})\n        \n        # Sort candidates by magnitude before attempting to lock\n        newly_converged.sort(key=lambda p: abs(p['val']), reverse=True)\n\n        for p in newly_converged:\n            if len(locked_eigenvalues) >= k:\n                break\n            \n            u_candidate = p['vec']\n            # Deflate candidate against current locked set\n            u_proj = u_candidate - locked_vectors @ (locked_vectors.conj().T @ u_candidate)\n            \n            # If it's not in the span of locked vectors, add it.\n            if np.linalg.norm(u_proj) > 1e-6:\n                u_ortho = (u_proj / np.linalg.norm(u_proj)).reshape(-1, 1)\n                locked_vectors = np.hstack([locked_vectors, u_ortho])\n                locked_eigenvalues.append(p['val'])\n                \n    return total_mat_vecs\n\ndef run_case(n, d_diag, k, m, tol, max_cycles, seed):\n    \"\"\"\n    Sets up a test case and runs both algorithms.\n    \"\"\"\n    # Create the test matrix A = S D S^-1\n    # Use a separate RNG for matrix generation to not interfere with start vectors\n    rng_A = np.random.default_rng(seed)\n    while True:\n        S = rng_A.uniform(-1, 1, size=(n, n))\n        if np.linalg.cond(S)  1 / np.finfo(S.dtype).eps:\n            break\n    D = np.diag(d_diag)\n    A = S @ D @ np.linalg.inv(S)\n\n    # Run without locking. Create a new RNG seeded for this run.\n    rng_no_lock = np.random.default_rng(seed)\n    mat_vec_no_lock = run_without_locking(A, k, m, tol, max_cycles, rng_no_lock)\n    \n    # Run with locking. Create another new RNG with the same seed.\n    # This ensures both algorithms use the same sequence of random start vectors.\n    rng_lock = np.random.default_rng(seed)\n    mat_vec_lock = run_with_locking(A, k, m, tol, max_cycles, rng_lock)\n    \n    return [mat_vec_no_lock, mat_vec_lock]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        (8, [5.0, 3.0, 2.0, 1.0, 0.5, -0.2, -1.5, 4.0], 3, 4, 1e-8, 200, 10),\n        (10, [4.0, 3.99, 1.0, 0.1, -0.1, 2.0, -2.0, 0.5, 0.49, -3.0], 3, 5, 1e-8, 200, 21),\n        (6, [-5.0, -1.0, -2.0, 0.1, 0.2, 0.3], 1, 2, 1e-8, 200, 7),\n    ]\n\n    all_results = []\n    for params in test_cases:\n        result_pair = run_case(*params)\n        all_results.append(result_pair)\n\n    formatted_results = \",\".join([f\"[{r[0]},{r[1]}]\" for r in all_results])\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2373565"}]}