{"hands_on_practices": [{"introduction": "幂法是计算矩阵主导本征值的一种基本迭代方法，但其收敛速度严重依赖于最大和次大本征值之间的“谱隙”。当谱隙很小时，收敛会变得非常缓慢。本实践旨在通过编程实现来亲身体验这一现象。你将实现基本的幂法和 Hotelling 降阶法，并通过对比不同谱隙下计算第一和第二本征值所需的迭代次数，直观地展示降阶法如何通过移除已知的主导本征对，从而有效“放大”次主导本征值的谱隙，极大地加速其求解过程 [@problem_id:2384610]。", "problem": "考虑通过迭代方法计算实对称矩阵的多个特征对的问题。从特征值和特征向量的核心定义开始：对于一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，一个特征对 $(\\lambda, v)$ 满足 $A v = \\lambda v$，其中 $v \\neq 0$。一个非零向量 $x$ 的瑞利商 (Rayleigh quotient) 是 $r(x) = \\dfrac{x^{\\top} A x}{x^{\\top} x}$，对于单位向量 $x$，有 $r(x) = x^{\\top} A x$。幂法通过重复应用矩阵 $A$ 并进行归一化来构造一个序列，$x_{k+1} = \\dfrac{A x_k}{\\|A x_k\\|_2}$，并监视 $r(x_k)$ 的收敛情况。降阶法 (Deflation) 是在计算出近似的主特征对 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 后对 $A$ 进行的变换，通过构造一个降阶矩阵 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$，其中 $\\widehat{v}_1$ 已被归一化为单位长度。对于对称矩阵 $A$，如果 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 是精确的，那么 $A_{\\text{def}}$ 的最大模特征值近似于 $A$ 的第二大特征值。\n\n您的任务是仅使用上述定义和基本的线性代数运算来实现以下内容：\n\n1) 实现用于实对称矩阵 $A$ 的幂法：\n- 初始化一个随机向量 $x_0 \\in \\mathbb{R}^n$，其分量为独立的标准正态分布，然后将其归一化为单位长度。\n- 迭代 $x_{k+1} = \\dfrac{A x_k}{\\|A x_k\\|_2}$。\n- 在每次迭代中，计算瑞利商 $r_k = x_k^{\\top} A x_k$。\n- 当瑞利商的绝对变化满足 $|r_k - r_{k-1}|  \\tau$ 时停止，其中 $\\tau$ 是给定的容差。\n- 统计满足停止条件所需的迭代次数 $k$。\n\n2) 对归一化的特征向量近似值实现 Hotelling 降阶法：给定 $\\|\\widehat{v}_1\\|_2 = 1$ 的 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$，构造 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n\n3) 通过构造具有指定谱的矩阵，演示当谱隙较小时幂法的收敛速度缓慢，并展示通过降阶法寻找第二特征对时的显著加速效果。构造 $A$ 为 $A = Q \\Lambda Q^{\\top}$，其中 $\\Lambda = \\operatorname{diag}(\\lambda_1, \\ldots, \\lambda_n)$，$Q$ 是一个正交矩阵，通过对一个具有标准正态分布分量的随机矩阵进行正交三角分解（QR分解）得到。使用具有固定整数种子的伪随机数生成器以使 $Q$ 可复现。\n\n4) 对于下面的每个测试用例：\n- 根据指定的谱构建 $A$。\n- 对 $A$ 应用幂法计算 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 并记录满足停止条件所需的迭代次数 $k_1$。\n- 构造 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n- 对 $A_{\\text{def}}$ 应用幂法计算第二特征值的近似值，并记录满足停止条件所需的迭代次数 $k_2$。\n\n使用以下参数值作为测试套件：\n- 通用参数：维度 $n = 5$；容差 $\\tau = 10^{-10}$；每次幂法调用的最大允许迭代次数 $k_{\\max} = 200000$；对于每个案例，使用所述种子生成一个 $n \\times n$ 标准正态矩阵的 QR 分解的 $Q$ 因子作为正交矩阵 $Q$，并在形成 $Q$ 后立即使用同一个伪随机数生成器为每次幂法调用生成初始向量 $x_0$（将 $x_0$ 归一化为单位长度）。所有随机数都是无量纲的。\n- 案例 $\\mathrm{A}$ (小谱隙)：谱 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 1 - 10^{-2}, 0.2, 0.1, 0.05\\}$，种子 $s = 123$。\n- 案例 $\\mathrm{B}$ (极小谱隙)：谱 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 1 - 10^{-3}, 0.2, 0.1, 0.05\\}$，种子 $s = 456$。\n- 案例 $\\mathrm{C}$ (大谱隙)：谱 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4, \\lambda_5\\} = \\{1, 0.5, 0.2, 0.1, 0.05\\}$，种子 $s = 789$。\n\n您的程序必须产生单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n- $[k_1^{(\\mathrm{A})}, k_2^{(\\mathrm{A})}, k_1^{(\\mathrm{B})}, k_2^{(\\mathrm{B})}, k_1^{(\\mathrm{C})}, k_2^{(\\mathrm{C})}]$，\n其中 $k_1^{(\\cdot)}$ 是对 $A$ 第一次调用幂法时的迭代次数，$k_2^{(\\cdot)}$ 是对 $A_{\\text{def}}$ 调用时的迭代次数。每个 $k$ 都必须报告为整数。此问题不涉及任何物理单位，也不需要角度或百分比。", "solution": "该问题要求实现并演示幂法与 Hotelling 降阶法相结合，以计算实对称矩阵的前两个特征对。问题的核心是阐明幂法的收敛速度对谱隙的依赖性，并展示降阶法如何在寻找次主导特征对时规避缓慢收敛的问题。\n\n首先，我们建立理论背景。对于一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其特征值为 $|\\lambda_1|  |\\lambda_2| \\ge \\dots \\ge |\\lambda_n|$，对应的标准正交特征向量集为 $\\{v_1, v_2, \\dots, v_n\\}$，幂法是一种旨在寻找主导特征对 $(\\lambda_1, v_1)$ 的迭代算法。迭代步骤由公式\n$$\nx_{k+1} = \\frac{A x_k}{\\|A x_k\\|_2}\n$$\n给出，其中 $x_0$ 是一个不与 $v_1$ 正交的初始向量。对于随机选择的 $x_0$，此条件以概率 $1$ 成立。向量序列 $\\{x_k\\}$ 收敛于 $\\pm v_1$。收敛速率由比率 $|\\lambda_2 / \\lambda_1|$ 决定。如果此比率接近 $1$，则谱隙很小，收敛速度缓慢。\n\n特征值 $\\lambda_1$ 可以使用瑞利商来估计，对于非零向量 $x$，瑞利商定义为 $r(x) = \\frac{x^{\\top} A x}{x^{\\top} x}$。当 $x_k \\to v_1$ 时，瑞利商 $r(x_k)$ 收敛于 $\\lambda_1$。问题指定的停止准则为 $|r_k - r_{k-1}|  \\tau$，其中 $r_k = x_k^{\\top} A x_k$（假设 $x_k$ 是单位向量），$\\tau$ 是一个很小的容差。因此，要实现的算法如下：\n1. 初始化一个归一化的随机向量 $x_0$。令 $x \\leftarrow x_0$。\n2. 计算初始瑞利商 $r_{\\text{old}} = x^{\\top} A x$。\n3. 对于 $k=1, 2, \\dots, k_{\\max}$：\n    a. 计算下一个迭代向量：$x_{\\text{next}} = A x / \\|A x\\|_2$。\n    b. 更新向量：$x \\leftarrow x_{\\text{next}}$。\n    c. 计算新的瑞利商：$r_{\\text{new}} = x^{\\top} A x$。\n    d. 检查收敛性：如果 $|r_{\\text{new}} - r_{\\text{old}}|  \\tau$，则终止并报告迭代次数 $k$。\n    e. 为下一次迭代更新：$r_{\\text{old}} \\leftarrow r_{\\text{new}}$。\n对问题陈述的这种字面解释要求每次迭代进行两次矩阵-向量乘法，这在计算上是低效的。更标准的实现会复用中间乘积 $A x$。但是，我们将严格遵守所述的公式。\n\n一旦找到主导特征对的近似值 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$（其中 $\\|\\widehat{v}_1\\|_2=1$），Hotelling 降阶法会构造一个新矩阵：\n$$\nA_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}\n$$\n如果 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 是一个精确的特征对 $(\\lambda_1, v_1)$，那么 $A$ 的特征向量 $v_2, \\dots, v_n$ 也是 $A_{\\text{def}}$ 的特征向量，具有相同的特征值 $\\lambda_2, \\dots, \\lambda_n$。向量 $v_1$ 成为 $A_{\\text{def}}$ 的一个特征向量，其特征值为 $0$。因此，$A_{\\text{def}}$ 的主导特征值是 $\\lambda_2$。从而，对 $A_{\\text{def}}$ 应用幂法将计算出原始矩阵 $A$ 的第二个特征对。第二阶段的收敛速率将取决于比率 $|\\lambda_3 / \\lambda_2|$。对于问题中提供的谱，这个比率远小于 1，这预示着与在小谱隙存在的情况下寻找 $\\lambda_1$ 相比，收敛速度将有显著提升。\n\n每个测试用例的总体流程如下：\n1.  设置伪随机数生成器的种子以确保可复现性。\n2.  构造对称矩阵 $A = Q \\Lambda Q^{\\top}$，其中 $\\Lambda$ 是指定特征值的对角矩阵，$Q$ 是通过对一个大小为 $n \\times n$、分量为标准正态分布的随机矩阵进行 QR 分解得到的正交矩阵。\n3.  为第一次幂法运行生成一个随机、归一化的初始向量 $x_0$。\n4.  对 $A$ 和初始向量 $x_0$ 应用幂法，以找到 $(\\widehat{\\lambda}_1, \\widehat{v}_1)$ 和迭代次数 $k_1$。\n5.  构造降阶矩阵 $A_{\\text{def}} = A - \\widehat{\\lambda}_1 \\widehat{v}_1 \\widehat{v}_1^{\\top}$。\n6.  为第二次幂法运行生成一个新的随机、归一化的初始向量。\n7.  对 $A_{\\text{def}}$ 应用幂法，以找到第二特征值的近似值并记录迭代次数 $k_2$。\n8.  最终输出汇集了所有指定测试用例的迭代次数 $\\{k_1, k_2\\}$。\n\n测试用例旨在阐释理论：案例 A 和 B 的谱隙很小（$1 - \\lambda_2/\\lambda_1$ 分别为 $10^{-2}$ 和 $10^{-3}$），这应该导致较大的 $k_1$ 值。案例 C 的谱隙较大，这应该导致较小的 $k_1$。在所有案例中，$\\lambda_2$ 和 $\\lambda_3$ 之间的谱隙都很大，因此预计 $k_2$ 会很小，从而展示降阶法的有效性。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import qr\n\ndef power_method(A, x0, tolerance, max_iter):\n    \"\"\"\n    Implements the power method for a real symmetric matrix.\n\n    Args:\n        A (np.ndarray): The symmetric matrix.\n        x0 (np.ndarray): The initial normalized vector.\n        tolerance (float): The stopping condition tolerance.\n        max_iter (int): The maximum number of iterations.\n\n    Returns:\n        tuple: A tuple containing:\n            - r_new (float): The estimated eigenvalue.\n            - x (np.ndarray): The estimated eigenvector.\n            - k (int): The number of iterations performed.\n        Returns (None, None, max_iter) if convergence is not achieved.\n    \"\"\"\n    n = A.shape[0]\n    x = x0.copy()\n    \n    # This implementation follows the problem description literally, which requires\n    # two matrix-vector products per iteration. One to update the vector,\n    # and one to compute the new Rayleigh quotient.\n    r_old = x.T @ A @ x\n\n    for k in range(1, max_iter + 1):\n        # Update step for the vector\n        Ax = A @ x\n        norm_Ax = np.linalg.norm(Ax)\n        if norm_Ax == 0:\n            # This can happen for the deflated matrix if x aligns with v1\n            return 0.0, x, k\n        x = Ax / norm_Ax\n\n        # Compute new Rayleigh quotient and check for convergence\n        r_new = x.T @ A @ x\n        \n        if np.abs(r_new - r_old)  tolerance:\n            return r_new, x, k\n        \n        r_old = r_new\n\n    return r_old, x, max_iter\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the power method and deflation experiments.\n    \"\"\"\n    # Common parameters\n    n = 5\n    tolerance = 1e-10\n    max_iter = 200000\n\n    test_cases = [\n        # Case A (small spectral gap)\n        (123, np.array([1.0, 1.0 - 1e-2, 0.2, 0.1, 0.05])),\n        # Case B (very small spectral gap)\n        (456, np.array([1.0, 1.0 - 1e-3, 0.2, 0.1, 0.05])),\n        # Case C (large spectral gap)\n        (789, np.array([1.0, 0.5, 0.2, 0.1, 0.05])),\n    ]\n\n    results = []\n\n    for seed, spectrum in test_cases:\n        rng = np.random.default_rng(seed)\n        \n        # 1. Construct the matrix A = Q * Lambda * Q^T\n        Lambda = np.diag(spectrum)\n        M = rng.standard_normal((n, n))\n        Q, _ = qr(M)\n        A = Q @ Lambda @ Q.T\n\n        # 2. Apply power method to A to find the first eigenpair\n        x0_1 = rng.standard_normal(n)\n        x0_1 /= np.linalg.norm(x0_1)\n        lambda_hat_1, v_hat_1, k1 = power_method(A, x0_1, tolerance, max_iter)\n        \n        # 3. Form the deflated matrix A_def\n        A_def = A - lambda_hat_1 * np.outer(v_hat_1, v_hat_1)\n\n        # 4. Apply power method to A_def to find the second eigenpair\n        x0_2 = rng.standard_normal(n)\n        x0_2 /= np.linalg.norm(x0_2)\n        _, _, k2 = power_method(A_def, x0_2, tolerance, max_iter)\n        \n        results.extend([k1, k2])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384610"}, {"introduction": "在掌握了幂法的基本应用之后，我们将深入探究一个影响其性能的关键细节：初始向量的选择。为了使幂法能够收敛到期望的本征向量，初始向量必须在该本征向量的方向上有一个非零分量。这个练习将提供一个精确控制的环境，让你探索当初始向量几乎与目标本征向量正交时会发生什么 [@problem_id:2384633]。通过量化这种“糟糕”的初始猜测所导致的误差，你将对算法的数值稳定性及其在实际应用中的行为建立更深刻的直觉。", "problem": "考虑一个具有严格有序特征值的实对称矩阵。设 $A \\in \\mathbb{R}^{3 \\times 3}$ 为对角矩阵\n$$\nA = \\mathrm{diag}(5,3,1),\n$$\n其标准正交特征向量是与特征值 $\\lambda_1 = 5$、$\\lambda_2 = 3$ 和 $\\lambda_3 = 1$ 分别相关的标准基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^3$。定义消除主特征对影响的降阶矩阵为\n$$\nA_{\\mathrm{def}} = A - \\lambda_1 \\, e_1 e_1^\\top.\n$$\n对于由角度 $\\theta \\in \\mathbb{R}$ 参数化的初始向量 $x^{(0)}(\\theta)$，令\n$$\nx^{(0)}(\\theta) = \\cos(\\theta) \\, e_2 + \\sin(\\theta) \\, e_3,\n$$\n使得初始猜测位于由 $e_2$ 和 $e_3$ 张成的不变子空间中，并与 $e_2$ 形成角度 $\\theta$。考虑通过在每一步中重复应用降阶矩阵并进行归一化所定义的序列：\n$$\nx^{(k)} = \\frac{A_{\\mathrm{def}} x^{(k-1)}}{\\lVert A_{\\mathrm{def}} x^{(k-1)} \\rVert_2}, \\quad k = 1,2,\\dots, T,\n$$\n其中 $\\lVert \\cdot \\rVert_2$ 表示欧几里得范数，T 是一个固定的正整数。经过 $T$ 次迭代后，通过 Rayleigh 商来近似 $A_{\\mathrm{def}}$ 的主特征值\n$$\n\\widehat{\\mu}_T(\\theta) = \\left(x^{(T)}(\\theta)\\right)^\\top A_{\\mathrm{def}} \\, x^{(T)}(\\theta).\n$$\n通过相对于真实第二特征值 $\\lambda_2 = 3$ 的相对误差来量化降阶特征值近似的准确性：\n$$\n\\varepsilon(\\theta) = \\frac{\\left| \\widehat{\\mu}_T(\\theta) - \\lambda_2 \\right|}{\\left| \\lambda_2 \\right|}.\n$$\n使用以弧度表示的角度。设置迭代次数为 $T = 5$。对以下初始角度测试集评估相对误差 $\\varepsilon(\\theta)$：\n$$\n\\theta \\in \\left\\{ 0,\\; \\frac{\\pi}{4},\\; \\frac{\\pi}{2} - 10^{-8},\\; \\frac{\\pi}{2},\\; \\frac{\\pi}{2} - 10^{-3} \\right\\}.\n$$\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），结果的顺序与上述角度的顺序相同。每个 $r_i$ 都必须是一个浮点数，表示指定集合中相应 $\\theta$ 的 $\\varepsilon(\\theta)$。", "solution": "问题陈述需经过验证。\n\n**步骤1：提取已知条件**\n- 矩阵：$A = \\mathrm{diag}(5, 3, 1)$，一个实对称矩阵 $A \\in \\mathbb{R}^{3 \\times 3}$。\n- $A$ 的特征值：$\\lambda_1 = 5$，$\\lambda_2 = 3$，$\\lambda_3 = 1$。\n- $A$ 的特征向量：标准正交基向量 $e_1, e_2, e_3 \\in \\mathbb{R}^3$，分别与 $\\lambda_1, \\lambda_2, \\lambda_3$ 相关联。\n- 降阶矩阵：$A_{\\mathrm{def}} = A - \\lambda_1 \\, e_1 e_1^\\top$。\n- 初始向量参数化：$x^{(0)}(\\theta) = \\cos(\\theta) \\, e_2 + \\sin(\\theta) \\, e_3$。\n- 迭代方案（归一化幂法）：$x^{(k)} = \\frac{A_{\\mathrm{def}} x^{(k-1)}}{\\lVert A_{\\mathrm{def}} x^{(k-1)} \\rVert_2}$。\n- 迭代次数：$T = 5$。\n- 特征值近似：Rayleigh 商 $\\widehat{\\mu}_T(\\theta) = \\left(x^{(T)}(\\theta)\\right)^\\top A_{\\mathrm{def}} \\, x^{(T)}(\\theta)$。\n- 误差度量：相对误差 $\\varepsilon(\\theta) = \\frac{\\left| \\widehat{\\mu}_T(\\theta) - \\lambda_2 \\right|}{\\left| \\lambda_2 \\right|}$。\n- 测试角度（以弧度为单位）：$\\theta \\in \\left\\{ 0,\\; \\frac{\\pi}{4},\\; \\frac{\\pi}{2} - 10^{-8},\\; \\frac{\\pi}{2},\\; \\frac{\\pi}{2} - 10^{-3} \\right\\}$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，采用了数值线性代数中的标准概念：特征值问题、矩阵降阶和幂迭代法。整个设定是自洽的，提供了所有必要的参数和定义。逻辑一致，任务定义明确，对于每个指定的初始条件，都能得出一个唯一且可验证的解。没有矛盾、歧义或事实错误。初始向量是迭代矩阵的特征向量这一特殊情况是该算法分析中的一个标准场景，并不构成缺陷。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整解答。\n\n该问题要求对通过幂法在降阶矩阵上计算出的特征值的准确性进行数值评估。我们首先对迭代过程进行严谨的分析。矩阵 $A$ 已知为 $A = \\mathrm{diag}(5, 3, 1)$。其特征对为 $(\\lambda_1, e_1) = (5, [1,0,0]^\\top)$、$(\\lambda_2, e_2) = (3, [0,1,0]^\\top)$ 和 $(\\lambda_3, e_3) = (1, [0,0,1]^\\top)$。降阶矩阵构造为 $A_{\\mathrm{def}} = A - \\lambda_1 e_1 e_1^\\top$。代入给定值，我们得到：\n$$\nA_{\\mathrm{def}} = \\begin{pmatrix} 5  0  0 \\\\ 0  3  0 \\\\ 0  0  1 \\end{pmatrix} - 5 \\begin{pmatrix} 1 \\\\ 0 \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 1  0  0 \\end{pmatrix} = \\begin{pmatrix} 5  0  0 \\\\ 0  3  0 \\\\ 0  0  1 \\end{pmatrix} - \\begin{pmatrix} 5  0  0 \\\\ 0  0  0 \\\\ 0  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  0  0 \\\\ 0  3  0 \\\\ 0  0  1 \\end{pmatrix}.\n$$\n$A_{\\mathrm{def}}$ 的特征值为 $\\mu_1 = 3$、$\\mu_2 = 1$ 和 $\\mu_3 = 0$，对应的特征向量为 $e_2$、$e_3$ 和 $e_1$。当幂迭代法应用于 $A_{\\mathrm{def}}$ 时，其设计目的是收敛到与模最大特征值相关的特征向量，即 $\\mu_1=3$（等于 $\\lambda_2$）。初始向量由 $x^{(0)}(\\theta) = \\cos(\\theta) e_2 + \\sin(\\theta) e_3$ 给出。该向量位于由 $\\{e_2, e_3\\}$ 张成的不变子空间中，并且与 $e_1$ 正交。因此，所有后续的迭代向量 $x^{(k)}$ 都将留在此子空间内。我们来分析一次迭代对该子空间中向量 $v = c_2 e_2 + c_3 e_3$ 的影响：\n$$\nA_{\\mathrm{def}} v = A_{\\mathrm{def}}(c_2 e_2 + c_3 e_3) = c_2 (A_{\\mathrm{def}} e_2) + c_3 (A_{\\mathrm{def}} e_3) = c_2 (\\mu_1 e_2) + c_3 (\\mu_2 e_3) = 3 c_2 e_2 + 1 c_3 e_3.\n$$\n$A_{\\mathrm{def}}$ 的作用将沿 $e_2$ 方向的分量乘以因子 $3$，将沿 $e_3$ 方向的分量乘以因子 $1$。沿 $e_3$ 方向的分量与沿 $e_2$ 方向的分量之比从 $c_3/c_2$ 变为 $(1 c_3)/(3 c_2) = (1/3)(c_3/c_2)$。对于初始向量 $x^{(0)}(\\theta)$，该比值为 $\\sin(\\theta)/\\cos(\\theta) = \\tan(\\theta)$。经过一次迭代，未归一化的向量为 $3\\cos(\\theta) e_2 + \\sin(\\theta) e_3$。此时分量的比值为 $(1/3)\\tan(\\theta)$。经过 $k$ 次迭代后，未归一化的向量将与 $3^k \\cos(\\theta) e_2 + 1^k \\sin(\\theta) e_3$ 成正比。$e_3$ 分量与 $e_2$ 分量的比值将为 $(1/3)^k \\tan(\\theta)$。归一化向量 $x^{(k)}(\\theta)$ 可写为 $x^{(k)}(\\theta) = \\cos(\\theta_k) e_2 + \\sin(\\theta_k) e_3$，其中 $\\tan(\\theta_k) = (1/3)^k \\tan(\\theta)$。经过 $T$ 次迭代后，最终向量为 $x^{(T)}(\\theta) = \\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3$，其中 $\\tan(\\theta_T) = (1/3)^T \\tan(\\theta)$。现在我们计算 Rayleigh 商：\n$$\n\\widehat{\\mu}_T(\\theta) = (x^{(T)})^\\top A_{\\mathrm{def}} x^{(T)} = (\\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3)^\\top (3\\cos(\\theta_T) e_2 + \\sin(\\theta_T) e_3).\n$$\n利用 $e_2$ 和 $e_3$ 的标准正交性，我们得到：\n$$\n\\widehat{\\mu}_T(\\theta) = 3\\cos^2(\\theta_T) + \\sin^2(\\theta_T) = 3\\cos^2(\\theta_T) + (1 - \\cos^2(\\theta_T)) = 1 + 2\\cos^2(\\theta_T).\n$$\n那么相对于 $\\lambda_2 = 3$ 的相对误差 $\\varepsilon(\\theta)$ 为：\n$$\n\\varepsilon(\\theta) = \\frac{|\\widehat{\\mu}_T(\\theta) - \\lambda_2|}{|\\lambda_2|} = \\frac{|(1 + 2\\cos^2(\\theta_T)) - 3|}{3} = \\frac{|2\\cos^2(\\theta_T) - 2|}{3} = \\frac{2| \\cos^2(\\theta_T) - 1 |}{3} = \\frac{2}{3}\\sin^2(\\theta_T).\n$$\n使用恒等式 $\\sin^2(\\phi) = \\tan^2(\\phi) / (1+\\tan^2(\\phi))$，我们可以用初始角度 $\\theta$ 来表示误差：\n$$\n\\varepsilon(\\theta) = \\frac{2}{3} \\frac{\\tan^2(\\theta_T)}{1+\\tan^2(\\theta_T)} = \\frac{2}{3} \\frac{(1/3)^{2T} \\tan^2(\\theta)}{1+(1/3)^{2T} \\tan^2(\\theta)}.\n$$\n这个解析结果可以用来验证数值实现的正确性。我们考虑两种特殊情况。如果 $\\theta=0$，那么 $x^{(0)} = e_2$，这就是所求的特征向量。迭代过程不改变该向量，因此 $\\widehat{\\mu}_T(0) = 3$ 且 $\\varepsilon(0) = 0$。这与公式一致，因为 $\\tan(0)=0$。如果 $\\theta=\\pi/2$，那么 $x^{(0)}=e_3$。这是 $A_{\\mathrm{def}}$ 的另一个特征向量（与 $\\mu_2=1$ 相关联）。迭代对所有 $k$ 都得到 $x^{(k)}=e_3$，因此 $\\widehat{\\mu}_T(\\pi/2) = (e_3)^\\top A_{\\mathrm{def}} e_3 = 1$。相对误差为 $|1 - 3|/3 = 2/3$。这是我们的公式在 $\\theta \\to \\pi/2$ 时的极限，因为此时 $\\tan^2(\\theta) \\to \\infty$。当 $\\theta$ 接近 $\\pi/2$ 时，初始向量在 $e_2$ 方向上的分量非常小，导致在固定的迭代次数 $T=5$ 后收敛缓慢且误差较大。以下代码通过数值方式实现了规定的迭代过程，以计算所要求的误差值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the relative error in eigenvalue approximation\n    using the power method on a deflated matrix.\n    \"\"\"\n    \n    # Define problem parameters\n    T = 5  # Number of iterations\n    lambda2_true = 3.0  # True second eigenvalue of A\n\n    # Define the test suite of initial angles in radians\n    test_angles = [\n        0.0,\n        np.pi / 4.0,\n        np.pi / 2.0 - 1e-8,\n        np.pi / 2.0,\n        np.pi / 2.0 - 1e-3\n    ]\n\n    # The matrix A is diag(5, 3, 1). The deflated matrix A_def = A - lambda1*e1*e1.T\n    # This results in A_def = diag(0, 3, 1).\n    A_def = np.diag([0.0, 3.0, 1.0])\n\n    # Standard basis vectors in R^3\n    e2 = np.array([0.0, 1.0, 0.0])\n    e3 = np.array([0.0, 0.0, 1.0])\n\n    results = []\n    \n    # Iterate through each specified angle\n    for theta in test_angles:\n        # 1. Define the initial vector x^{(0)}\n        x = np.cos(theta) * e2 + np.sin(theta) * e3\n        \n        # 2. Perform T iterations of the normalized power method\n        for _ in range(T):\n            v = A_def @ x\n            norm_v = np.linalg.norm(v)\n            \n            # The norm will not be zero because x is constructed in the invariant\n            # subspace of A_def spanned by e2 and e3, unless theta is pi/2 and A_def*e3 is 0.\n            # In our case A_def*e3 is e3, so norm is never 0 unless x is 0.\n            if norm_v > 0:\n                x = v / norm_v\n            # if norm is 0, vector x remains unchanged.\n        \n        x_T = x # Final vector after T iterations\n        \n        # 3. Approximate the dominant eigenvalue of A_def using the Rayleigh quotient\n        mu_hat_T = x_T.T @ A_def @ x_T\n\n        # 4. Quantify the accuracy by the relative error\n        relative_error = np.abs(mu_hat_T - lambda2_true) / np.abs(lambda2_true)\n        results.append(relative_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384633"}, {"introduction": "前面的练习侧重于通过降阶法“分解”矩阵以寻找其本征对。现在，让我们换个角度，从“构造”出发。本实践将引导你进行逆向思维：如何构建一个矩阵，使其拥有一个预设的本征对，且其余谱结构由另一个更小的矩阵决定 [@problem_id:2384661]。这个“升阶”过程是降阶法的概念对应，它不仅能加深你对矩阵、谱和相似变换之间内在联系的理解，也展示了线性代数构造性方法的威力。", "problem": "构建一个程序，该程序为每个测试用例构建一个实数方阵 $A \\in \\mathbb{R}^{n \\times n}$，该方阵具有一个预设的目标特征对 $(\\lambda_0, v_0)$，并且其剩余特征值与一个给定的较小实数方阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 的谱一致，所有特征值均计及其代数重数。对于每个测试用例，给定一个实数标量 $\\lambda_0 \\in \\mathbb{R}$、一个非零实数向量 $v_0 \\in \\mathbb{R}^n$ 和一个实数矩阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$。您的程序必须为每种情况构建一个矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使得：\n- $(\\lambda_0, v_0)$ 是 $A$ 的一个特征对，即 $A v_0 = \\lambda_0 v_0$，并且\n- $A$ 的特征值多重集等于 $\\{\\lambda_0\\} \\cup \\sigma(A_0)$，其中 $\\sigma(A_0)$ 表示 $A_0$ 的特征值多重集。\n\n为进行数值验证，定义一个容差 $\\tau = 10^{-8}$。对于每个构建的 $A$，您的程序必须验证以下两个条件：\n1. 特征对残差条件：残差的欧几里得范数满足 $\\|A v_0 - \\lambda_0 v_0\\|_2 \\le \\tau \\cdot \\max\\{1, (\\|A\\|_2 + |\\lambda_0|)\\|v_0\\|_2\\}$。\n2. 谱匹配条件：从 $A$ 的特征值中移除一个与 $\\lambda_0$ 模长最接近的特征值（以考虑目标特征值）后，$A$ 的剩余特征值多重集在容差范围内与 $\\sigma(A_0)$ 多重集匹配，其含义如下：对于 $\\sigma(A_0)$ 中的每个 $\\mu$，在 $A$ 的剩余特征值中存在一个不同的特征值 $\\nu$，使得 $|\\nu - \\mu| \\le \\tau \\cdot \\max\\{1, |\\mu|\\}$。\n\n测试套件的值如下。对于每种情况，$n$ 是 $v_0$ 的长度，且 $A_0 \\in \\mathbb{R}^{(n-1)\\times(n-1)}$：\n- 情况 1：$\\lambda_0 = -1.5$， $v_0 = [\\,2,\\,-1,\\,0,\\,2\\,]^\\top$， $A_0 = \\begin{bmatrix} 0  2  0 \\\\ -2  0  0 \\\\ 0  0  3 \\end{bmatrix}$。\n- 情况 2：$\\lambda_0 = 0$， $v_0 = [\\,1,\\,1,\\,1\\,]^\\top$， $A_0 = \\begin{bmatrix} 5  0 \\\\ 0  5 \\end{bmatrix}$。\n- 情况 3：$\\lambda_0 = 7$， $v_0 = [\\,0,\\,1\\,]^\\top$， $A_0 = \\begin{bmatrix} -3 \\end{bmatrix}$。\n- 情况 4：$\\lambda_0 = 2$， $v_0 = [\\,1,\\,0,\\,0\\,]^\\top$， $A_0 = \\begin{bmatrix} 4  1 \\\\ 0  4 \\end{bmatrix}$。\n\n您的程序必须为每种情况按顺序输出一个布尔值，表示两个验证条件是否都成立。最终输出必须是单行，包含一个用方括号括起来的、由逗号分隔的布尔值列表。例如，输出格式必须类似于“[result1,result2,result3,result4]”（不含空格）。此问题不涉及角度或物理单位。所有数值比较必须使用指定的容差 $\\tau = 10^{-8}$。", "solution": "问题陈述已经过审阅，并被认为是有效的。它提出了一个数值线性代数中定义明确的任务，没有科学或逻辑上的不一致之处。目标是构建一个实数矩阵 $A \\in \\mathbb{R}^{n \\times n}$，使其满足两个条件：它必须拥有一个指定的特征对 $(\\lambda_0, v_0)$，并且其剩余的谱必须与给定矩阵 $A_0 \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 的谱相匹配。我们接下来推导一个构造性的解法。\n\n我们方法的核心在于使用相似变换。如果存在某个可逆矩阵 $P$ 使得 $A = P B P^{-1}$，则矩阵 $A$ 与矩阵 $B$ 相似。相似矩阵具有相同的谱（特征值及其代数重数）。我们的目标是巧妙地选择 $P$ 和 $B$ 以强制满足给定的特征对和谱属性。\n\n设给定的特征向量为 $v_0 \\in \\mathbb{R}^n$，其中 $v_0 \\neq 0$。我们首先为 $\\mathbb{R}^n$ 构建一个特殊的基。令 $u_0 = v_0 / \\|v_0\\|_2$ 为归一化后的特征向量。然后我们将 $\\{u_0\\}$ 扩充为 $\\mathbb{R}^n$ 的一个标准正交基，记作 $\\{u_0, u_1, \\dots, u_{n-1}\\}$。令 $U$ 是以这些基向量为列的正交矩阵：$U = [u_0 | u_1 | \\dots | u_{n-1}]$。由于 $U$ 是正交矩阵，其逆矩阵等于其转置，即 $U^{-1} = U^\\top$。\n\n我们通过相似变换 $A = U B U^\\top$ 来定义矩阵 $A$。现在我们必须确定 $B$ 的结构以满足问题的条件。\n\n首先，我们施加特征对条件，$A v_0 = \\lambda_0 v_0$。代入 $A$ 的定义以及 $v_0 = \\|v_0\\|_2 u_0$，我们得到：\n$$\n(U B U^\\top) (\\|v_0\\|_2 u_0) = \\lambda_0 (\\|v_0\\|_2 u_0)\n$$\n由于 $\\|v_0\\|_2$ 是一个非零标量，我们可以将其简化为 $U B U^\\top u_0 = \\lambda_0 u_0$。从左侧乘以 $U^\\top$ 得到：\n$$\nB (U^\\top u_0) = \\lambda_0 (U^\\top u_0)\n$$\n根据构造，$u_0$ 是 $U$ 的第一列。因此，$U^\\top u_0$ 是向量 $e_1 = [1, 0, \\dots, 0]^\\top$。该条件简化为 $B e_1 = \\lambda_0 e_1$。这个方程意味着矩阵 $B$ 的第一列必须是 $[\\lambda_0, 0, \\dots, 0]^\\top$。因此，$B$ 必须具有上三角分块结构：\n$$\nB = \\begin{bmatrix} \\lambda_0  w^\\top \\\\ 0  C \\end{bmatrix}\n$$\n其中 $w \\in \\mathbb{R}^{n-1}$ 是一个任意行向量，$C \\in \\mathbb{R}^{(n-1) \\times (n-1)}$ 是某个矩阵。\n\n其次，我们考虑谱条件。$A$ 的谱，记作 $\\sigma(A)$，必须是 $\\{\\lambda_0\\} \\cup \\sigma(A_0)$。由于 $A$ 和 $B$ 相似，所以 $\\sigma(A) = \\sigma(B)$。分块三角矩阵的特征值是其对角线上分块矩阵特征值的并集。因此，$B$ 的谱是 $\\{\\lambda_0\\} \\cup \\sigma(C)$。\n为满足问题的要求，我们必须有 $\\sigma(C) = \\sigma(A_0)$。虽然有很多矩阵 $C$ 与 $A_0$ 相似，因而具有相同的谱，但最简单、最直接的选择是设 $C = A_0$。\n\n行向量 $w^\\top$ 不影响 $B$ 的特征值。它的选择会影响 $A$ 的（除 $v_0$ 之外的）特征向量，但不影响所要求的谱属性。为简单起见，我们选择 $w=0$。这使得 $B$ 具有分块对角形式：\n$$\nB = \\begin{bmatrix} \\lambda_0  0 \\\\ 0  A_0 \\end{bmatrix}\n$$\n\n有了这些选择，矩阵 $A$ 的最终构造为：\n$$\nA = U \\begin{bmatrix} \\lambda_0  0 \\\\ 0  A_0 \\end{bmatrix} U^\\top\n$$\n构造 $A$ 的步骤如下：\n1.  给定 $v_0$，将其归一化以获得 $u_0 = v_0 / \\|v_0\\|_2$。\n2.  为 $u_0$ 的正交补构造一个标准正交基。这等价于找到 $u_0^\\top$ 的零空间的一个标准正交基。令以这些基向量为列的矩阵为 $U_1 \\in \\mathbb{R}^{n \\times (n-1)}$。\n3.  构成正交矩阵 $U = [u_0 | U_1]$。\n4.  构成块对角矩阵 $B = \\text{scipy.linalg.block\\_diag}(\\lambda_0, A_0)$。\n5.  计算 $A = U B U^\\top$。由于 $\\lambda_0$、$v_0$ 和 $A_0$ 都是实数，因此 $U$ 和 $B$ 可以构造为实数矩阵，从而确保 $A$ 也是实数矩阵。\n\n为进行数值验证，必须对照容差 $\\tau = 10^{-8}$ 检查两个条件。\n1.  特征对残差条件，$\\|A v_0 - \\lambda_0 v_0\\|_2 \\le \\tau \\cdot \\max\\{1, (\\|A\\|_2 + |\\lambda_0|)\\|v_0\\|_2\\}$，通过直接计算所涉及的范数来检验。\n2.  谱匹配条件要求将 $A_0$ 的特征值多重集 $\\sigma(A_0)$ 与移除 $A$ 的一个与 $\\lambda_0$ 模长最接近的特征值后得到的特征值多重集进行比较。设 $A$ 的剩余特征值为多重集 $S'_A$。我们必须验证是否存在一个双射 $f: \\sigma(A_0) \\to S'_A$，使得对于每一个 $\\mu \\in \\sigma(A_0)$，其像 $\\nu = f(\\mu)$ 满足 $|\\nu - \\mu| \\le \\tau \\cdot \\max\\{1, |\\mu|\\}$。这是一个二分图上的最小权完美匹配问题，可以通过找到 $\\sigma(A_0)$ 元素的一个排列来解决，该排列使得与 $S'_A$ 元素之间的距离总和最小。鉴于测试用例中的维度较小，遍历所有排列是可行的。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import null_space, block_diag\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Constructs and verifies a matrix A for each test case.\n    \"\"\"\n    test_cases = [\n        {\n            \"lambda0\": -1.5,\n            \"v0\": np.array([2.0, -1.0, 0.0, 2.0]),\n            \"A0\": np.array([[0.0, 2.0, 0.0], [-2.0, 0.0, 0.0], [0.0, 0.0, 3.0]])\n        },\n        {\n            \"lambda0\": 0.0,\n            \"v0\": np.array([1.0, 1.0, 1.0]),\n            \"A0\": np.array([[5.0, 0.0], [0.0, 5.0]])\n        },\n        {\n            \"lambda0\": 7.0,\n            \"v0\": np.array([0.0, 1.0]),\n            \"A0\": np.array([[-3.0]])\n        },\n        {\n            \"lambda0\": 2.0,\n            \"v0\": np.array([1.0, 0.0, 0.0]),\n            \"A0\": np.array([[4.0, 1.0], [0.0, 4.0]])\n        },\n    ]\n\n    results = []\n    tau = 1e-8\n\n    for case in test_cases:\n        lambda0 = case[\"lambda0\"]\n        v0 = case[\"v0\"]\n        A0 = case[\"A0\"]\n        n = len(v0)\n\n        # Step 1: Construct the orthogonal matrix U\n        u0 = v0 / np.linalg.norm(v0)\n        u0_col = u0.reshape(-1, 1)\n\n        # Find an orthonormal basis for the orthogonal complement of u0\n        # This is the null space of u0.T\n        U1 = null_space(u0.reshape(1, -1))\n\n        # Form the full orthogonal matrix U\n        U = np.hstack((u0_col, U1))\n        \n        # Step 2: Construct the block matrix B\n        B = block_diag(lambda0, A0)\n\n        # Step 3: Construct the matrix A\n        A = U @ B @ U.T\n\n        # Step 4: Verification\n        # Condition 1: Eigenpair residual\n        residual_norm = np.linalg.norm(A @ v0 - lambda0 * v0)\n        bound = tau * max(1.0, (np.linalg.norm(A, 2) + np.abs(lambda0)) * np.linalg.norm(v0))\n        cond1_holds = residual_norm = bound\n        \n        # Condition 2: Spectrum match\n        eigs_A = np.linalg.eigvals(A)\n        eigs_A0 = np.linalg.eigvals(A0)\n        \n        # Find and remove the eigenvalue of A closest to lambda0\n        # Using simple distance, not modulus, as lambda0 is real.\n        idx_to_remove = np.argmin(np.abs(eigs_A - lambda0))\n        eigs_A_rem = np.delete(eigs_A, idx_to_remove)\n        \n        # Sort remaining eigenvalues for a canonical order for comparison\n        eigs_A_rem = np.sort_complex(eigs_A_rem)\n        \n        cond2_holds = False\n        # Check all permutations of eigs_A0 to find a valid matching\n        for p in permutations(eigs_A0):\n            p_arr = np.sort_complex(np.array(p))\n            # Check the tolerance for this permutation\n            errors = np.abs(eigs_A_rem - p_arr)\n            tolerances = tau * np.maximum(1.0, np.abs(p_arr))\n            if np.all(errors = tolerances):\n                cond2_holds = True\n                break\n        \n        results.append(str(cond1_holds and cond2_holds).lower())\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2384661"}]}