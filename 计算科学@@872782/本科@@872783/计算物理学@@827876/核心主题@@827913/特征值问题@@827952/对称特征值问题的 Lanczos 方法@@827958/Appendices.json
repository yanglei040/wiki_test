{"hands_on_practices": [{"introduction": "理论学习之后，我们通过一系列动手实践来巩固对兰索斯方法的理解。第一个练习旨在揭示该算法核心的代数结构。通过构建一个其特征多项式与经典正交多项式（即切比雪夫多项式）相关的特殊测试矩阵，我们将亲手验证兰索斯三项递推关系与正交多项式递推关系之间的深刻联系 [@problem_id:2406049]。这个练习不仅能帮助你理解兰索斯过程为何自然地产生一个三对角矩阵，还能让你洞察其谱性质背后的优美数学原理。", "problem": "您将为一个实对称特征值问题实现并分析 Lanczos 方法。该问题使用一个特意构造的测试矩阵，其特征多项式与一个经典正交多项式一致。其目标是将正交多项式所遵循的三项递推关系与 Lanczos 过程产生的三对角形式联系起来，并通过一个小型测试套件对该构造进行数值验证。\n\n从以下基本原理开始：\n- 实对称矩阵的特征值问题：给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其特征值为实数，Lanczos 方法构造一个标准正交 Krylov 基，从而得到一个实对称三对角投影 $T_m \\in \\mathbb{R}^{m \\times m}$，其特征值（Ritz 值）近似于 $A$ 的特征值。\n- 行列式的拉普拉斯展开（余子式展开），以及三对角矩阵的行列式遵循三项递推关系这一事实。\n- 实轴上的经典正交多项式通过三项递推关系进行定义。特别是，对于第二类 Chebyshev 多项式 $U_k(x)$，其递推关系为 $U_0(x)=1$，$U_1(x)=2x$，并且当 $k \\ge 2$ 时，$U_k(x)=2x\\,U_{k-1}(x)-U_{k-2}(x)$。\n\n构造一个 $n \\times n$ 的实对称三对角矩阵 $A_n$，其主对角线上的元素为 $0$，次对角线和超对角线上的元素为 $1$，即：\n$$\nA_n = \\begin{bmatrix}\n0  1  0  \\cdots  0 \\\\\n1  0  1  \\ddots  \\vdots \\\\\n0  1  0  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  1 \\\\\n0  \\cdots  0  1  0\n\\end{bmatrix}.\n$$\n利用三对角矩阵的行列式展开，且不使用任何其他专用公式，推导出 $A_n$ 的特征多项式满足一个三项递推关系，该关系与在缩放自变量下求值的第二类 Chebyshev 多项式的递推关系相匹配。最终得出 $A_n$ 的特征多项式与 $U_n(x)$ 的某个适当缩放形式之间的精确恒等式。\n\n为一个实对称矩阵 $A$ 和一个初始向量 $v_0 \\in \\mathbb{R}^n$（其中 $v_0 \\ne 0$）实现 Lanczos 方法。该算法必须生成张成 m 阶 Krylov 子空间的标准正交向量 $v_1,\\dots,v_m$，以及由三项递推关系产生的三对角矩阵 $T_m$，其对角线元素为 $\\alpha_j$，副/超对角线元素为 $\\beta_j$。仅使用标准线性代数运算，并确保失效检查的数值稳健性。\n\n对于每个指定的测试用例，您的程序必须执行以下操作：\n\n- 按上述方式构建 $A_n$。\n- 从给定的 $v_0$ 开始，运行 $m$ 次 Lanczos 迭代，生成 $T_m$，其元素为 $\\{\\alpha_j\\}_{j=1}^m$ 和 $\\{\\beta_j\\}_{j=1}^{m-1}$。\n- 对于指定的比较，使用 $A_n$ 的特征多项式与第二类 Chebyshev 多项式之间的恒等式来计算 $A_n$ 的精确特征值。使用这些精确特征值为 Ritz 值（$T_m$ 的特征值）定义定量误差度量。\n- 在需要时，使用行列式三项递推关系 $D_0(\\lambda)=1$，$D_1(\\lambda)=\\lambda-\\alpha_1$ 以及当 $k \\ge 2$ 时 $D_k(\\lambda)=(\\lambda-\\alpha_k) D_{k-1}(\\lambda)-\\beta_{k-1}^2 D_{k-2}(\\lambda)$，在实数自变量 $\\lambda$ 处计算三对角矩阵 $T_m$ 的特征多项式。将此结果与通过其定义的三项递推关系计算的 $U_m(\\lambda/2)$ 的值进行比较。\n\n使用以下测试套件；所有向量均在 $\\mathbb{R}^n$ 中：\n- 测试用例 1：$n=6$，$m=6$，$v_0 = e_1$，其中 $e_1$ 是 $\\mathbb{R}^n$ 中的第一个标准基向量。将结果定义为 $T_m$ 的 Ritz 值与 $A_n$ 的精确特征值之间的最大绝对差。\n- 测试用例 2：$n=10$，$m=5$，$v_0 = e_1$。定义两个量：(i) 计算出的 $\\alpha_j$ 与 $0$ 的最大偏差以及计算出的 $\\beta_j$ 与 $1$ 的最大偏差，将这两个最大值中的较大者作为汇总值；以及 (ii) 在区间 $[-2.5,2.5]$ 内的 17 个均匀分布点上，$\\det(\\lambda I - T_m)$ 与 $U_m(\\lambda/2)$ 之间绝对差的最大值，两者均通过三项递推关系求值。此测试用例的结果是这两个量的最大值。\n- 测试用例 3：$n=20$，$m=12$，$v_0$ 是一个确定性伪随机向量，其元素从具有固定种子 $314159$ 的标准正态分布中抽取，然后归一化为单位欧几里得范数。将结果定义为 $T_m$ 的最大 Ritz 值与 $A_n$ 的最大精确特征值之间的绝对差。\n- 测试用例 4：$n=8$，$m=1$，$v_0=e_1$。将结果定义为在点集 $\\{-3,-1,0,1,3\\}$ 上，$\\det(\\lambda I - T_1)$ 与 $U_1(\\lambda/2)$ 之间的最大绝对差。\n\n所有答案均为纯数字，不涉及物理单位。您的程序应生成单行输出，其中包含一个用方括号括起来的、按四个测试用例顺序排列的、以逗号分隔的十进制数列表，例如 \"[$r_1,r_2,r_3,r_4$]\"。每个 $r_j$ 都应为一个浮点数。为了可读性，您可以将结果四舍五入到 $10^{-12}$ 的绝对容差范围内。不应打印任何其他输出。", "solution": "所述问题在科学上是合理的、适定的和客观的。这是数值线性代数中的一个标准练习，它将正交多项式理论与 Lanczos 算法的行为联系起来。所有参数和目标都已明确定义。该问题是有效的。我们开始进行解答。\n\n解答分为两个部分：首先，解析推导矩阵 $A_n$ 的特征多项式与第二类 Chebyshev 多项式之间的恒等式；其次，描述 Lanczos 方法的数值实现以及对指定测试用例的评估。\n\n**1. 特征多项式的推导**\n\n设 $A_n$ 是一个 $n \\times n$ 的实对称三对角矩阵，其定义为 $(A_n)_{i,i} = 0$，$(A_n)_{i,i+1} = (A_n)_{i+1,i} = 1$，所有其他元素均为 $0$。$A_n$ 的特征多项式为 $p_n(\\lambda) = \\det(\\lambda I_n - A_n)$。矩阵 $\\lambda I_n - A_n$ 为：\n$$\n\\lambda I_n - A_n = \\begin{bmatrix}\n\\lambda  -1  0  \\cdots  0 \\\\\n-1  \\lambda  -1  \\ddots  \\vdots \\\\\n0  -1  \\lambda  \\ddots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  -1 \\\\\n0  \\cdots  0  -1  \\lambda\n\\end{bmatrix}\n$$\n设 $p_k(\\lambda)$ 表示 $\\lambda I_n - A_n$ 的 k x k 阶主子矩阵（即 $\\lambda I_k - A_k$）的行列式。\n对于 $k \\ge 2$，我们可以沿最后一行使用拉普拉斯（余子式）展开来计算 $p_k(\\lambda)$。这得到：\n$$\np_k(\\lambda) = \\lambda \\cdot p_{k-1}(\\lambda) - (-1) \\cdot \\det(M_{k,k-1})\n$$\n其中 $M_{k,k-1}$ 是通过移除第 k 行和第 k-1 列得到的子矩阵。矩阵 $M_{k,k-1}$ 是一个上三角矩阵，其对角线元素为 $-1, -1, ..., -1$（k-2 次），并在一个非对角块结构中包含 $p_{k-2}(\\lambda)$。更简单地，通过沿 $\\lambda I_k - A_k$ 的最后一列展开：\n$$\np_k(\\lambda) = \\lambda \\cdot p_{k-1}(\\lambda) - (-1) \\cdot \\det\\begin{pmatrix} \\lambda I_{k-2}-A_{k-2}  \\mathbf{0} \\\\ \\mathbf{c}^T  -1 \\end{pmatrix}\n$$\n这个分块下三角矩阵的行列式为 $-p_{k-2}(\\lambda)$。对最后一列进行更直接的展开，得到来自元素 $(k,k)$ 和 $(k-1,k)$ 的项。\n位于 $(k,k)$ 的元素是 $\\lambda$，得到项 $\\lambda \\cdot p_{k-1}(\\lambda)$。\n位于 $(k-1,k)$ 的元素是 $-1$。其代数余子式为 $(-1)^{(k-1)+k}$ 乘以移除第 $k-1$ 行和第 $k$ 列后矩阵的行列式。该矩阵是分块三角矩阵，其行列式为 $-1 \\cdot p_{k-2}(\\lambda)$。\n因此，其贡献为 $(-1) \\cdot (-1)^{2k-1} \\cdot (-p_{k-2}(\\lambda)) = -p_{k-2}(\\lambda)$。\n完整的递推关系是：\n$$\np_k(\\lambda) = \\lambda p_{k-1}(\\lambda) - p_{k-2}(\\lambda) \\quad \\text{for } k \\ge 2.\n$$\n我们建立基本情况：\n$p_1(\\lambda) = \\det([\\lambda]) = \\lambda$。\n$p_2(\\lambda) = \\det \\begin{pmatrix} \\lambda  -1 \\\\ -1  \\lambda \\end{pmatrix} = \\lambda^2 - 1$。\n为了启动递推，我们需要一个 $p_0(\\lambda)$ 的值。使用 $k=2$ 时的递推式：$p_2(\\lambda) = \\lambda p_1(\\lambda) - p_0(\\lambda)$，这意味着 $\\lambda^2 - 1 = \\lambda(\\lambda) - p_0(\\lambda)$，所以我们必须定义 $p_0(\\lambda) = 1$。\n\n现在，考虑由以下递推关系定义的第二类 Chebyshev 多项式 $U_k(x)$：\n$U_0(x)=1$，$U_1(x)=2x$，并且当 $k \\ge 2$ 时，$U_k(x) = 2x U_{k-1}(x) - U_{k-2}(x)$。\n让我们进行代换 $\\lambda = 2x$，即 $x = \\lambda/2$。$p_k(\\lambda)$ 的递推关系变为 $p_k(2x) = 2x p_{k-1}(2x) - p_{k-2}(2x)$。\n这在形式上与 $U_k(x)$ 的递推关系相同。我们检查序列 $\\{p_k(2x)\\}$ 的初始条件是否与 $\\{U_k(x)\\}$ 的初始条件相匹配。\n- 对于 $k=0$：$p_0(2x) = 1$，与 $U_0(x)=1$ 相匹配。\n- 对于 $k=1$：$p_1(2x) = 2x$，与 $U_1(x)=2x$ 相匹配。\n由于递推关系和前两项是相同的，我们通过归纳法得出结论，对于所有 $k \\ge 0$，$p_k(2x) = U_k(x)$。将 $x=\\lambda/2$ 代回，我们便确立了 $A_k$ 特征多项式的恒等式：\n$$\np_k(\\lambda) = U_k(\\lambda/2).\n$$\n$A_n$ 的特征值是 $p_n(\\lambda) = 0$ 的根，也就是 $U_n(\\lambda/2)=0$ 的根。$U_n(x)$ 的根是 $x_j = \\cos\\left(\\frac{j\\pi}{n+1}\\right)$，其中 $j=1, \\dots, n$。因此，$A_n$ 的精确特征值是 $\\lambda_j = 2x_j = 2\\cos\\left(\\frac{j\\pi}{n+1}\\right)$，其中 $j=1, \\dots, n$。\n\n**2. 数值实现与分析**\n\n该实现包括四个主要组成部分：\n1.  一个函数，用于为给定维度 n 构建矩阵 $A_n$。\n2.  Lanczos 算法的实现，用于处理一个实对称矩阵 A、一个起始向量 $v_0$ 和迭代次数 m。该算法生成三对角矩阵 $T_m$ 的系数 $\\{\\alpha_j\\}_{j=1}^m$ 和 $\\{\\beta_j\\}_{j=1}^{m-1}$。该过程首先将初始向量 $v_0$ 归一化以获得第一个 Lanczos 向量 $q_1$。\n3.  一个函数，用于在点 $\\lambda$ 处计算给定三对角矩阵 $T_k$ 的特征多项式 $\\det(\\lambda I_k - T_k)$，使用三项递推关系 $D_k(\\lambda)=(\\lambda-\\alpha_k) D_{k-1}(\\lambda)-\\beta_{k-1}^2 D_{k-2}(\\lambda)$，初始条件为 $D_0(\\lambda)=1$ 和 $D_1(\\lambda)=\\lambda-\\alpha_1$。\n4.  一个函数，用于使用其定义递推式在点 x 处计算 Chebyshev 多项式 $U_k(x)$。\n\n这些组件用于解决指定的四个测试用例。\n\n- 对于测试用例 1（$n=6, m=6, v_0=e_1$），在 $(A_n, e_1)$ 上执行 n 步的 Lanczos 算法理论上会产生 $T_n=A_n$。因此，Ritz 值（$T_6$ 的特征值）应与 $A_6$ 的精确特征值在机器精度范围内相匹配。\n- 对于测试用例 2（$n=10, m=5, v_0=e_1$），该算法生成 $A_{10}$ 的 5x5 阶主子矩阵，即 $A_5$。因此，系数 $\\alpha_j$ 必须为 $0$，$\\beta_j$ 必须为 $1$。$T_5 = A_5$ 的特征多项式恰好是 $U_5(\\lambda/2)$。指定的误差量应都接近于零。\n- 对于测试用例 3（$n=20, m=12, v_0$ 是一个随机向量），Lanczos 算法提供了一个近似值。$T_{12}$ 的最大 Ritz 值预计将是 $A_{20}$ 最大特征值的一个非常好的近似，因为该方法对极端特征值的收敛速度最快。\n- 对于测试用例 4（$n=8, m=1, v_0=e_1$），执行单步 Lanczos 方法。得到的矩阵是 $T_1 = [\\alpha_1]$。计算得出 $\\alpha_1 = v_1^T A v_1 = e_1^T A_8 e_1 = 0$。所以 $T_1=[0]$，其特征多项式为 $\\det(\\lambda I_1 - T_1) = \\lambda$。这与 $U_1(\\lambda/2) = 2(\\lambda/2) = \\lambda$ 相同。其差值在解析上为零。\n\n最终的代码实现了这些过程，并为每个测试用例计算所需的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes the Lanczos method for a specific real symmetric matrix\n    whose characteristic polynomial corresponds to Chebyshev polynomials.\n    \"\"\"\n\n    def build_A(n):\n        \"\"\"Builds the n x n test matrix A_n.\"\"\"\n        A = np.zeros((n, n), dtype=float)\n        A += np.diag(np.ones(n - 1), k=1)\n        A += np.diag(np.ones(n - 1), k=-1)\n        return A\n\n    def lanczos_gvl(A, v_start, m):\n        \"\"\"\n        Performs m iterations of the Lanczos algorithm.\n        Based on algorithm 10.1.1 from Golub & Van Loan, \"Matrix Computations\" 4th ed.\n        \n        Args:\n            A (np.ndarray): The symmetric matrix.\n            v_start (np.ndarray): The starting vector.\n            m (int): The number of iterations.\n            \n        Returns:\n            tuple[np.ndarray, np.ndarray]: (alphas, betas) for the tridiagonal matrix T_m.\n        \"\"\"\n        n = A.shape[0]\n        q_prev = np.zeros(n, dtype=float)\n        r = v_start.copy()\n        beta = np.linalg.norm(r)\n\n        alphas = np.zeros(m, dtype=float)\n        betas = np.zeros(m - 1, dtype=float)\n\n        for j in range(m):\n            if beta < 1e-15:  # Breakdown check\n                # For this problem, breakdown is not expected.\n                # If it occurs, we would return truncated T matrix coeffs.\n                # Here we assume it runs for m steps successfully.\n                alphas = alphas[:j]\n                betas = betas[:j - 1] if j > 0 else np.array([])\n                break\n\n            q = r / beta\n            u = A @ q\n            alpha = np.dot(q, u)\n            alphas[j] = alpha\n\n            r = u - alpha * q - beta * q_prev\n\n            if j < m - 1:\n                beta_next = np.linalg.norm(r)\n                betas[j] = beta_next\n                beta = beta_next\n            \n            q_prev = q\n\n        return alphas, betas\n\n    def get_exact_eigenvalues(n):\n        \"\"\"Computes the exact eigenvalues of the matrix A_n.\"\"\"\n        j = np.arange(1, n + 1, dtype=float)\n        eigvals = 2 * np.cos(j * np.pi / (n + 1))\n        return np.sort(eigvals)\n\n    def eval_det_poly(alphas, betas, lam):\n        \"\"\"\n        Evaluates the characteristic polynomial det(lambda*I - T) of a tridiagonal matrix T\n        using the three-term recurrence for determinants.\n        \"\"\"\n        m = len(alphas)\n        if m == 0:\n            return 1.0\n        \n        d_prev = 1.0  # D_0(lambda)\n        d_curr = lam - alphas[0]  # D_1(lambda)\n\n        for k in range(1, m):\n            beta_sq = betas[k-1]**2\n            d_next = (lam - alphas[k]) * d_curr - beta_sq * d_prev\n            d_prev = d_curr\n            d_curr = d_next\n            \n        return d_curr\n\n    def eval_U(k, x):\n        \"\"\"\n        Evaluates the Chebyshev polynomial of the second kind U_k(x) via its recurrence relation.\n        \"\"\"\n        if k == 0:\n            return 1.0\n        if k == 1:\n            return 2.0 * x\n        \n        u_prev = 1.0  # U_0\n        u_curr = 2.0 * x  # U_1\n        \n        for _ in range(2, k + 1):\n            u_next = 2.0 * x * u_curr - u_prev\n            u_prev = u_curr\n            u_curr = u_next\n            \n        return u_curr\n\n    test_cases = [\n        {'n': 6, 'm': 6, 'v0_type': 'e1'},\n        {'n': 10, 'm': 5, 'v0_type': 'e1'},\n        {'n': 20, 'm': 12, 'v0_type': 'random', 'seed': 314159},\n        {'n': 8, 'm': 1, 'v0_type': 'e1'}\n    ]\n    results = []\n\n    # Test Case 1\n    params = test_cases[0]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    T_m = np.diag(alphas) + np.diag(betas, k=1) + np.diag(betas, k=-1)\n    ritz_values = np.linalg.eigvalsh(T_m)\n    exact_eigvals = get_exact_eigenvalues(n)\n    res1 = np.max(np.abs(ritz_values - exact_eigvals))\n    results.append(res1)\n\n    # Test Case 2\n    params = test_cases[1]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    \n    max_dev_alpha = np.max(np.abs(alphas)) if len(alphas) > 0 else 0.0\n    max_dev_beta = np.max(np.abs(betas - 1.0)) if len(betas) > 0 else 0.0\n    q1 = max(max_dev_alpha, max_dev_beta)\n    \n    grid = np.linspace(-2.5, 2.5, 17)\n    max_diff_poly = 0.0\n    for lam in grid:\n        det_val = eval_det_poly(alphas, betas, lam)\n        cheby_val = eval_U(m, lam / 2.0)\n        max_diff_poly = max(max_diff_poly, np.abs(det_val - cheby_val))\n    \n    res2 = max(q1, max_diff_poly)\n    results.append(res2)\n\n    # Test Case 3\n    params = test_cases[2]\n    n, m, seed = params['n'], params['m'], params['seed']\n    A = build_A(n)\n    rng = np.random.default_rng(seed)\n    v0_unnormalized = rng.standard_normal(n)\n    v0 = v0_unnormalized / np.linalg.norm(v0_unnormalized)\n    \n    alphas, betas = lanczos_gvl(A, v0, m)\n    T_m = np.diag(alphas) + np.diag(betas, k=1) + np.diag(betas, k=-1)\n    ritz_values = np.linalg.eigvalsh(T_m)\n    exact_eigvals = get_exact_eigenvalues(n)\n    \n    max_ritz = np.max(ritz_values)\n    max_exact = np.max(exact_eigvals)\n    res3 = np.abs(max_ritz - max_exact)\n    results.append(res3)\n\n    # Test Case 4\n    params = test_cases[3]\n    n, m = params['n'], params['m']\n    A = build_A(n)\n    v0 = np.zeros(n)\n    v0[0] = 1.0\n    alphas, betas = lanczos_gvl(A, v0, m)\n    \n    test_points = np.array([-3.0, -1.0, 0.0, 1.0, 3.0])\n    max_diff_poly = 0.0\n    for lam in test_points:\n        det_val = eval_det_poly(alphas, betas, lam)\n        cheby_val = eval_U(m, lam / 2.0)\n        max_diff_poly = max(max_diff_poly, np.abs(det_val - cheby_val))\n    \n    res4 = max_diff_poly\n    results.append(res4)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2406049"}, {"introduction": "掌握了兰索斯算法的内在机理后，下一个练习将展示其在实际问题中的强大威力。我们将应用兰索斯方法来估算大型稀疏矩阵的条件数，这是一个在计算物理和工程中至关重要的指标 [@problem_id:2406053]。对于大规模问题，通过完全对角化来计算极端特征值是不现实的，而兰索斯方法正是为高效求解这类问题而设计的，它能快速逼近矩阵谱的两端。", "problem": "给定一个实对称稀疏矩阵的集合，要求您估计每个矩阵在欧几里得范数下的条件数。对于一个对称正定矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其 $2$-范数条件数定义为\n$$\n\\kappa(A) \\equiv \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)},\n$$\n其中 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 分别表示 $A$ 的最大和最小特征值。对于下面测试套件中定义的每个矩阵，通过近似 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 来计算 $\\kappa(A)$ 的估计值。\n\n此问题中的所有矩阵都是实数、对称且正定的，并且完全由所提供的参数定义。不需要物理单位，也不涉及角度。\n\n测试套件（矩阵需严格按此顺序构造）：\n- 情况 $1$（一维狄利克雷拉普拉斯算子）：设 $n = 200$。定义 $A \\in \\mathbb{R}^{n \\times n}$ 为一个三对角结构，其对角线元素等于 $2$，第一亚对角线和第一超对角线元素等于 $-1$。形式上，$A = \\mathrm{tridiag}(-1, 2, -1)$，大小为 $n$。\n- 情况 $2$（对数间隔谱的对角矩阵）：设 $n = 300$。定义 $A = \\mathrm{diag}(d_1,\\dots,d_n)$，其对角线元素为 $d_k = 10^{x_k}$，其中 $x_k$ 在 $-2$ 和 $0$ 之间线性间隔，对于 $k = 1,\\dots,n$。\n- 情况 $3$（通过克罗内克和实现的二维狄利克雷拉普拉斯算子）：设 $N = 20$ 且 $n = N^2$。如情况 $1$ 中那样定义 $L \\in \\mathbb{R}^{N \\times N}$，其对角线元素为 $2$，第一亚对角线和第一超对角线元素为 $-1$。设 $I$ 表示 $N \\times N$ 的单位矩阵。通过克罗内克和定义 $A \\in \\mathbb{R}^{n \\times n}$\n$$\nA = I \\otimes L + L \\otimes I,\n$$\n其中 $\\otimes$ 表示克罗内克积。\n- 情况 $4$（缩放单位矩阵）：设 $n = 300$ 且 $c = 3.5$。定义 $A = c I_n$，其中 $I_n$ 是 $n \\times n$ 的单位矩阵。\n\n您的程序必须：\n- 对于每种情况，严格按照规定构造矩阵 $A$。\n- 计算 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$ 的估计值，然后以 $\\lambda_{\\max}(A)/\\lambda_{\\min}(A)$ 的形式构成 $\\kappa(A)$ 的估计值。\n- 对于每种情况，生成一个浮点数值，该值等于估计的条件数并精确到 $6$ 位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个结果，以逗号分隔的列表形式并用方括号括起来，情况的顺序与上述顺序一致。例如，输出行应如下所示\n$$\n[\\kappa_1,\\kappa_2,\\kappa_3,\\kappa_4],\n$$\n其中每个 $\\kappa_i$ 是一个精确到 $6$ 位的小数（例如，$[123.456789,100.000000,177.882001,1.000000]$）。", "solution": "问题陈述经过验证，确认有效。它在科学上基于线性代数的既定原理，问题定义清晰，提供了矩阵构造所需的所有参数，并且表述客观，没有歧义。所有指定矩阵均为实数、对称和正定的前提是正确的。这确保了 $2$-范数条件数 $\\kappa(A) = \\lambda_{\\max}(A)/\\lambda_{\\min}(A)$ 是良定义的，因为 $\\lambda_{\\min}(A) > 0$。我们开始进行解答。\n\n目标是为四个指定的矩阵计算条件数 $\\kappa(A)$。对于对称矩阵 $A$，这需要找到其最大和最小特征值，即 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$。这些矩阵的结构各不相同；一些是大型稀疏矩阵，而另一些则具有平凡的特征谱。求解方法将针对每种情况进行调整，以确保正确性和效率。对于大型稀疏矩阵，极端特征值的计算使用基于 Lanczos 算法的迭代方法执行，这是完成此任务的最新技术。`scipy.sparse.linalg.eigsh` 函数提供了这样的实现。\n\n情况 $1$：一维狄利克雷拉普拉斯算子\n矩阵 $A \\in \\mathbb{R}^{n \\times n}$（其中 $n=200$）被定义为 $A = \\mathrm{tridiag}(-1, 2, -1)$。这是一个稀疏对称矩阵。由于其规模较大，我们避免直接对角化。我们使用 Lanczos 方法计算极端特征值。\n- 通过寻找代数值最大的特征值来找到 $\\lambda_{\\max}(A)$。\n- 通过寻找代数值最小的特征值来找到 $\\lambda_{\\min}(A)$。\n矩阵 $A$ 被构造为稀疏矩阵。然后，对迭代特征求解器进行两次调用，一次用于 $\\lambda_{\\max}(A)$，一次用于 $\\lambda_{\\min}(A)$。条件数是这些计算值的比率。\n\n情况 $2$：对数间隔谱的对角矩阵\n矩阵 $A \\in \\mathbb{R}^{n \\times n}$（其中 $n=300$）是对角矩阵，其元素为 $d_k = 10^{x_k}$，其中 $x_k$ 在区间 $[-2, 0]$ 内线性间隔。对角矩阵的特征值就是其对角线元素。因此，不需要数值估计。\n- 值 $x_k$ 的范围从 $-2$ 到 $0$。由于 $10^x$ 是一个单调递增函数，极端特征值对应于 $x_k$ 的极值。\n- $\\lambda_{\\min}(A) = \\min_k(d_k) = 10^{\\min(x_k)} = 10^{-2} = 0.01$。\n- $\\lambda_{\\max}(A) = \\max_k(d_k) = 10^{\\max(x_k)} = 10^0 = 1$。\n- 条件数精确为 $\\kappa(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)} = \\frac{1}{0.01} = 100$。\n\n情况 $3$：二维狄利克雷拉普拉斯算子\n矩阵 $A$ 的大小为 $n \\times n$，其中 $n=N^2$ 且 $N=20$。它由克罗内克和 $A = I \\otimes L + L \\otimes I$ 定义，其中 $L$ 是情况 $1$ 中的 $N \\times N$ 一维拉普拉斯算子，$I$ 是 $N \\times N$ 单位矩阵。生成的矩阵 $A$ 大小为 $400 \\times 400$，是稀疏且对称的。与情况 $1$ 一样，我们使用 Lanczos 算法计算极端特征值 $\\lambda_{\\max}(A)$ 和 $\\lambda_{\\min}(A)$。矩阵 $A$ 使用稀疏矩阵例程构造单位矩阵、一维拉普拉斯算子和克罗内克积。\n\n情况 $4$：缩放单位矩阵\n矩阵 $A \\in \\mathbb{R}^{n \\times n}$（其中 $n=300$）被定义为 $A = c I_n$，其中 $I_n$ 是单位矩阵，$c = 3.5$。这个矩阵是对角矩阵。它的所有特征值都等于常数 $c$。\n- $\\lambda_{\\min}(A) = 3.5$。\n- $\\lambda_{\\max}(A) = 3.5$。\n- 条件数精确为 $\\kappa(A) = \\frac{3.5}{3.5} = 1$。\n不需要数值估计。\n\n最终结果基于这些原理计算，并按要求四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import eigsh\n\ndef solve():\n    \"\"\"\n    Computes condition number estimates for a suite of test matrices.\n    \"\"\"\n    test_cases_params = [\n        {'type': 'laplacian_1d', 'n': 200},\n        {'type': 'diag_log', 'n': 300},\n        {'type': 'laplacian_2d', 'N': 20},\n        {'type': 'scaled_identity', 'n': 300, 'c': 3.5}\n    ]\n\n    results = []\n    for params in test_cases_params:\n        case_type = params['type']\n        \n        if case_type == 'laplacian_1d':\n            # Case 1: 1D Dirichlet Laplacian\n            n = params['n']\n            # A = tridiag(-1, 2, -1)\n            diagonals = [-1 * np.ones(n - 1), 2 * np.ones(n), -1 * np.ones(n - 1)]\n            A = diags(diagonals, [-1, 0, 1], shape=(n, n), format='csr')\n            \n            # Find largest eigenvalue\n            lambda_max = eigsh(A, k=1, which='LA', return_eigenvectors=False)[0]\n            # Find smallest eigenvalue\n            lambda_min = eigsh(A, k=1, which='SA', return_eigenvectors=False)[0]\n            \n            kappa = lambda_max / lambda_min\n            results.append(kappa)\n\n        elif case_type == 'diag_log':\n            # Case 2: Diagonal matrix with logarithmically spaced spectrum\n            # Eigenvalues are the diagonal entries.\n            # d_k = 10^x_k, with x_k in [-2, 0].\n            # Smallest eigenvalue is 10^-2, largest is 10^0.\n            lambda_min = 10**(-2.0)\n            lambda_max = 10**(0.0)\n            \n            kappa = lambda_max / lambda_min\n            results.append(kappa)\n\n        elif case_type == 'laplacian_2d':\n            # Case 3: 2D Dirichlet Laplacian via Kronecker sum\n            N = params['N']\n            n = N * N\n            \n            # 1D Laplacian L of size N\n            diagonals_L = [-1 * np.ones(N - 1), 2 * np.ones(N), -1 * np.ones(N - 1)]\n            L = diags(diagonals_L, [-1, 0, 1], shape=(N, N), format='csr')\n            \n            # Identity I of size N\n            I = identity(N, format='csr')\n            \n            # Kronecker sum A = I kron L + L kron I\n            A = kron(I, L) + kron(L, I)\n            \n            # Find largest eigenvalue\n            lambda_max = eigsh(A, k=1, which='LA', return_eigenvectors=False)[0]\n            # Find smallest eigenvalue. Use a small shift sigma=0 for stability with some solvers,\n            # though 'SA' is generally robust for positive definite matrices.\n            lambda_min = eigsh(A, k=1, which='SA', return_eigenvectors=False)[0]\n\n            kappa = lambda_max / lambda_min\n            results.append(kappa)\n            \n        elif case_type == 'scaled_identity':\n            # Case 4: Scaled identity matrix\n            # A = c * I, all eigenvalues are c.\n            c = params['c']\n            kappa = c / c\n            results.append(kappa)\n\n    # Format results to exactly 6 decimal places.\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2406053"}, {"introduction": "构建一个实用的迭代求解器，最后关键的一步是设计一个智能的终止准则。在真实世界的应用中，我们不会运行固定的迭代次数，而是持续迭代直到结果“足够好”为止 [@problem_id:2406056]。本练习将指导你实现一个基于残差范数的稳健终止条件，这是迭代方法的标准实践。你将学到一个巧妙的技巧，无需显式构造高维的里兹向量，就能高效地计算出残差范数，从而完成一个高效且可靠的兰索斯求解器。", "problem": "给定一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个非零起始向量 $v_{1} \\in \\mathbb{R}^{n}$ 且 $\\|v_{1}\\|_{2} = 1$，考虑 $k$ 维 Krylov 子空间 $\\mathcal{K}_{k}(A, v_{1}) = \\mathrm{span}\\{v_{1}, A v_{1}, \\ldots, A^{k-1} v_{1}\\}$。令 $Q_{k} \\in \\mathbb{R}^{n \\times k}$ 是一个列向量标准正交的矩阵，其列向量构成 $\\mathcal{K}_{k}(A, v_{1})$ 的一组基，并令 $T_{k} = Q_{k}^{\\top} A Q_{k} \\in \\mathbb{R}^{k \\times k}$ 为 $A$ 在 $\\mathcal{K}_{k}(A, v_{1})$ 上的 Rayleigh–Ritz 投影。记 $(\\theta_{i}^{(k)}, u_{i}^{(k)})$ 为 $T_{k}$ 的特征对，其中 $\\|u_{i}^{(k)}\\|_{2} = 1$，并定义原始空间中相应的 Ritz 向量为 $y_{i}^{(k)} = Q_{k} u_{i}^{(k)}$，其中 $\\|y_{i}^{(k)}\\|_{2} = 1$。对于每个 Ritz 对 $(\\theta_{i}^{(k)}, y_{i}^{(k)})$，定义残差 $r_{i}^{(k)} = A y_{i}^{(k)} - \\theta_{i}^{(k)} y_{i}^{(k)}$ 及其范数 $\\|r_{i}^{(k)}\\|_{2}$。\n\n开发一个稳健的终止准则，当不等式\n$$\n\\|r_{i}^{(k)}\\|_{2} \\leq \\max\\big(\\mathrm{atol}, \\ \\mathrm{rtol} \\cdot \\max(1, |\\theta_{i}^{(k)}|)\\big)\\, \\|A\\|_{2}\n$$\n成立时，接受一个 Ritz 对 $(\\theta_{i}^{(k)}, y_{i}^{(k)})$。其中 $\\mathrm{rtol} > 0$ 和 $\\mathrm{atol} \\ge 0$ 是用户指定的容差，$\\|A\\|_{2}$ 表示谱范数（最大奇异值，对于对称矩阵 $A$ 等于最大的特征值绝对值）。对于给定的目标规范，令 $\\mathcal{I}_{k}$ 表示根据目标规则选择的 $r$ 个 Ritz 值的索引集：\n- 如果目标是“smallest”（最小），则 $\\mathcal{I}_{k}$ 包含 $\\{\\theta_{i}^{(k)}\\}_{i=1}^{k}$ 中 $r$ 个代数上最小的 Ritz 值的索引。\n- 如果目标是“largest”（最大），则 $\\mathcalI_{k}$ 包含 $\\{\\theta_{i}^{(k)}\\}_{i=1}^{k}$ 中 $r$ 个代数上最大的 Ritz 值的索引。\n\n定义最小迭代次数 $k_{\\mathrm{acc}}$ 为 $k \\in \\{1, 2, \\ldots, k_{\\max}\\}$ 中的最小值，使得目标集 $\\mathcal{I}_{k}$ 中至少有 $r$ 个 Ritz 对满足上述接受不等式。如果在 $k_{\\max}$ 之前不存在这样的 $k$，则定义 $k_{\\mathrm{acc}} = -1$。\n\n实现一个程序，对于以下每个测试用例，构造指定的对称矩阵 $A$，使用分量为 $v_{1,j} = 1$（对于 $j \\in \\{1,\\ldots,n\\}$）并归一化到单位 $2$-范数的起始向量 $v_{1}$，并返回相应的 $k_{\\mathrm{acc}}$ 值。\n\n测试套件：\n- 测试用例 1：$A$ 是大小为 $n = 50$ 的一维离散 Dirichlet 拉普拉斯算子，即一个对角线元素为 $2$，次对角线和超对角线元素为 $-1$ 的三对角矩阵。目标：“smallest”（最小），$r = 2$。容差：$\\mathrm{rtol} = 10^{-8}$，$\\mathrm{atol} = 10^{-12}$。最大迭代次数 $k_{\\max} = 50$。\n- 测试用例 2：$A$ 是大小为 $n = 60$ 的对称 Toeplitz 矩阵，定义为 $A_{ij} = \\exp\\!\\big(-((i-j)/\\sigma)^{2}\\big)$，其中 $\\sigma = 5$。目标：“largest”（最大），$r = 1$。容差：$\\mathrm{rtol} = 10^{-6}$，$\\mathrm{atol} = 10^{-10}$。最大迭代次数 $k_{\\max} = 60$。\n- 测试用例 3：$A = c I$，其中 $c = 7$，大小 $n = 20$。目标：“smallest”（最小），$r = 1$。容差：$\\mathrm{rtol} = 10^{-12}$，$\\mathrm{atol} = 0$。最大迭代次数 $k_{\\max} = 5$。\n- 测试用例 4：$A$ 是大小为 $n = 40$ 的一维离散 Dirichlet 拉普拉斯算子。目标：“smallest”（最小），$r = 1$。容差：$\\mathrm{rtol} = 10^{-14}$，$\\mathrm{atol} = 0$。最大迭代次数 $k_{\\max} = 5$。\n\n您的程序应生成单行输出，其中包含四个值 $[k_{\\mathrm{acc}}^{(1)}, k_{\\mathrm{acc}}^{(2)}, k_{\\mathrm{acc}}^{(3)}, k_{\\mathrm{acc}}^{(4)}]$，按顺序以逗号分隔的列表形式，并用方括号括起来。每个 $k_{\\mathrm{acc}}^{(t)}$ 必须是一个整数，$-1$ 表示对于测试用例 $t$，在规定的 $k_{\\max}$ 内没有发生接受。", "solution": "该问题是一个在计算物理和数值线性代数领域中定义明确的练习。它涉及使用 Lanczos 算法寻找实对称矩阵的特征值，并结合一个基于残差范数的实用终止准则。所有参数和矩阵都得到了明确的规定，该问题在科学上是合理的，它建立在矩阵计算的基本原理之上。因此，该问题是有效的，我们将继续提供一个完整的解决方案。\n\n问题的核心是 Lanczos 算法。对于给定的实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个起始向量 $v_1$（$\\|v_1\\|_2 = 1$），该算法迭代地为 Krylov 子空间 $\\mathcal{K}_k(A, v_1) = \\mathrm{span}\\{v_1, A v_1, \\ldots, A^{k-1} v_1\\}$ 构建一组标准正交基 $\\{v_1, v_2, \\ldots, v_k\\}$。这些基向量构成的矩阵是 $Q_k = [v_1 | v_2 | \\ldots | v_k] \\in \\mathbb{R}^{n \\times k}$。\n\n该过程由一个三项递推关系控制：\n$$\n\\beta_{j+1} v_{j+1} = A v_j - \\alpha_j v_j - \\beta_j v_{j-1}\n$$\n初始条件为 $v_0 = 0$ 和 $\\beta_1 = 0$。系数由 $\\alpha_j = v_j^\\top A v_j$ 和 $\\beta_{j+1} = \\|A v_j - \\alpha_j v_j - \\beta_j v_{j-1}\\|_2$ 确定。这些系数构成一个对称三对角矩阵 $T_k \\in \\mathbb{R}^{k \\times k}$：\n$$\nT_k = Q_k^\\top A Q_k = \\begin{pmatrix}\n\\alpha_1  \\beta_2   \\\\\n\\beta_2  \\alpha_2  \\ddots  \\\\\n \\ddots  \\ddots  \\beta_k \\\\\n  \\beta_k  \\alpha_k\n\\end{pmatrix}\n$$\n这个小矩阵 $T_k$ 的特征对 $(\\theta_i^{(k)}, u_i^{(k)})$ 被称为 Ritz 对。Ritz 值 $\\theta_i^{(k)}$ 是对 $A$ 的特征值的近似，而 Ritz 向量 $y_i^{(k)} = Q_k u_i^{(k)}$ 是对 $A$ 的相应特征向量的近似。\n\n高效实现的一个关键部分是计算残差范数 $\\|r_i^{(k)}\\|_2 = \\|A y_i^{(k)} - \\theta_i^{(k)} y_i^{(k)}\\|_2$。朴素的计算方法在计算上会很昂贵。相反，我们利用 Lanczos 分解的一个基本性质，$A Q_k = Q_k T_k + \\beta_{k+1} v_{k+1} e_k^\\top$，其中 $e_k$ 是 $\\mathbb{R}^k$ 中的第 $k$ 个标准基向量。通过代入 $y_i^{(k)} = Q_k u_i^{(k)}$ 并使用特征关系 $T_k u_i^{(k)} = \\theta_i^{(k)} u_i^{(k)}$，我们推导出：\n$$\nA y_i^{(k)} = A (Q_k u_i^{(k)}) = (Q_k T_k + \\beta_{k+1} v_{k+1} e_k^\\top) u_i^{(k)} = Q_k (T_k u_i^{(k)}) + \\beta_{k+1} v_{k+1} (e_k^\\top u_i^{(k)})\n$$\n$$\nA y_i^{(k)} = Q_k (\\theta_i^{(k)} u_i^{(k)}) + \\beta_{k+1} u_{i,k}^{(k)} v_{k+1} = \\theta_i^{(k)} (Q_k u_i^{(k)}) + \\beta_{k+1} u_{i,k}^{(k)} v_{k+1}\n$$\n其中 $u_{i,k}^{(k)}$ 是特征向量 $u_i^{(k)}$ 的第 $k$ 个（最后一个）分量。因此，残差向量为 $r_i^{(k)} = A y_i^{(k)} - \\theta_i^{(k)} y_i^{(k)} = \\beta_{k+1} u_{i,k}^{(k)} v_{k+1}$。由于 Lanczos 向量是标准正交的（$\\|v_{k+1}\\|_2 = 1$），残差的范数可以优雅地简化为：\n$$\n\\|r_i^{(k)}\\|_2 = |\\beta_{k+1}| \\cdot |u_{i,k}^{(k)}|\n$$\n这个公式提供了一种在每次迭代 $k$ 时以低计算成本检查终止准则的方法。\n\n寻找最小迭代次数 $k_{\\mathrm{acc}}$ 的总体算法如下：\n1. 对每个测试用例，构造矩阵 $A$ 和归一化的起始向量 $v_1$。\n2. 计算谱范数 $\\|A\\|_2$。对于对称矩阵，这是 $\\max(|\\lambda_{\\min}|, |\\lambda_{\\max}|)$。\n3. 从 $1$ 到 $k_{\\max}$ 迭代 $k$。在每次迭代中：\n    a. 执行一步 Lanczos 算法来计算 $\\alpha_k$ 和 $\\beta_{k+1}$，将三对角矩阵 $T_{k-1}$ 扩展到 $T_k$。\n    b. 求解 $k \\times k$ 矩阵 $T_k$ 的特征问题，以获得其全套 Ritz 对 $\\{(\\theta_i^{(k)}, u_i^{(k)})\\}_{i=1}^k$。为此，我们使用专门为对称三对角矩阵设计的高效求解器。\n    c. 根据测试用例中指定的“smallest”或“largest”准则，识别出 $r$ 个目标 Ritz 对。\n    d. 对于这 $r$ 个目标对中的每一个，使用公式 $\\|r_i^{(k)}\\|_2 = |\\beta_{k+1}| |u_{i,k}^{(k)}|$ 计算残差范数。\n    e. 将此范数与阈值 $\\tau_i^{(k)} = \\max(\\mathrm{atol}, \\mathrm{rtol} \\cdot \\max(1, |\\theta_i^{(k)}|)) \\cdot \\|A\\|_2$ 进行比较。\n    f. 统计满足 $\\|r_i^{(k)}\\|_2 \\leq \\tau_i^{(k)}$ 的目标对的数量。\n4. 如果此计数大于或等于 $r$，则当前迭代次数 $k$ 即为答案 $k_{\\mathrm{acc}}$。此测试用例的搜索完成。\n5. 如果循环在 $k \\le k_{\\max}$ 内未满足条件，则 $k_{\\mathrm{acc}} = -1$。\n对所有四个测试用例重复此过程，以获得最终的结果向量。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef calculate_k_acc(A, v1_unnormalized, r, target, rtol, atol, k_max):\n    \"\"\"\n    Calculates the minimal Lanczos iteration count k_acc for convergence.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Normalize the starting vector to have a 2-norm of 1.\n    v1 = v1_unnormalized / np.linalg.norm(v1_unnormalized)\n\n    # Pre-compute the spectral norm of A for the tolerance calculation.\n    norm_A = np.linalg.norm(A, 2)\n    \n    # Lists to store Lanczos coefficients\n    alphas = []\n    betas_offdiag = []  # Stores beta_2, beta_3, ... for T_k's off-diagonal\n\n    # Lanczos algorithm initialization\n    v_prev = np.zeros(n)\n    v_curr = v1\n    beta_curr = 0.0  # beta_1 is defined as 0\n\n    for k in range(1, k_max + 1):\n        # Perform one step of the Lanczos iteration\n        w = A @ v_curr - beta_curr * v_prev\n        \n        alpha_curr = np.dot(v_curr, w)\n        alphas.append(alpha_curr)\n        \n        w -= alpha_curr * v_curr\n        \n        v_prev = v_curr\n        beta_next = np.linalg.norm(w)\n        \n        # At iteration k, we have T_k of size k x k.\n        # Its diagonal is 'alphas' (k elements).\n        # Its off-diagonal is 'betas_offdiag' (k-1 elements).\n        diag = np.array(alphas)\n        \n        if k == 1:\n            ritz_values = diag\n            # Eigenvector of a 1x1 matrix is [1].\n            ritz_vecs = np.array([[1.0]])\n        else:\n            offdiag = np.array(betas_offdiag)\n            # eigh_tridiagonal is efficient for this task and returns sorted eigenvalues.\n            ritz_values, ritz_vecs = eigh_tridiagonal(diag, offdiag, eigvals_only=False)\n        \n        # Only check for convergence if we have at least r Ritz values.\n        if k >= r:\n            # Identify the indices of the r target Ritz pairs.\n            if target == 'smallest':\n                target_indices = range(r)\n            else:  # 'largest'\n                target_indices = range(k - r, k)\n            \n            num_converged = 0\n            for i in target_indices:\n                theta_i = ritz_values[i]\n                # Last component of the i-th eigenvector of T_k.\n                u_ik = ritz_vecs[-1, i]\n                \n                # Calculate the residual norm efficiently.\n                res_norm = abs(beta_next * u_ik)\n                \n                # Calculate the dynamic tolerance threshold.\n                threshold = max(atol, rtol * max(1.0, abs(theta_i))) * norm_A\n                \n                if res_norm <= threshold:\n                    num_converged += 1\n            \n            if num_converged >= r:\n                return k\n\n        # If breakdown occurs (beta_next is zero), the Krylov subspace is exhausted.\n        # If convergence was not declared, it means the required pairs did not converge.\n        if np.isclose(beta_next, 0.0):\n            return -1\n        \n        # Prepare for the next iteration.\n        v_curr = w / beta_next\n        beta_curr = beta_next\n        betas_offdiag.append(beta_curr)\n\n    # If the loop completes, convergence was not achieved within k_max iterations.\n    return -1\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_suite = [\n        # Test case 1\n        {'n': 50, 'type': 'laplacian', 'r': 2, 'target': 'smallest', 'rtol': 1e-8, 'atol': 1e-12, 'k_max': 50},\n        # Test case 2\n        {'n': 60, 'type': 'toeplitz', 'sigma': 5.0, 'r': 1, 'target': 'largest', 'rtol': 1e-6, 'atol': 1e-10, 'k_max': 60},\n        # Test case 3\n        {'n': 20, 'type': 'identity', 'c': 7.0, 'r': 1, 'target': 'smallest', 'rtol': 1e-12, 'atol': 0.0, 'k_max': 5},\n        # Test case 4\n        {'n': 40, 'type': 'laplacian', 'r': 1, 'target': 'smallest', 'rtol': 1e-14, 'atol': 0.0, 'k_max': 5},\n    ]\n\n    results = []\n    for params in test_suite:\n        n = params['n']\n        \n        # Construct the matrix A based on the test case type.\n        if params['type'] == 'laplacian':\n            A = 2.0 * np.eye(n) - np.eye(n, k=1) - np.eye(n, k=-1)\n        elif params['type'] == 'toeplitz':\n            sigma = params['sigma']\n            indices = np.arange(n, dtype=float).reshape(-1, 1)\n            A = np.exp(-(((indices - indices.T) / sigma) ** 2))\n        elif params['type'] == 'identity':\n            c = params['c']\n            A = c * np.eye(n)\n        \n        # The unnormalized starting vector has all components equal to 1.\n        v1_unnormalized = np.ones(n)\n        \n        # Calculate k_acc for the current test case.\n        k_acc = calculate_k_acc(A, v1_unnormalized, params['r'], params['target'], params['rtol'], params['atol'], params['k_max'])\n        results.append(k_acc)\n\n    # Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2406056"}]}