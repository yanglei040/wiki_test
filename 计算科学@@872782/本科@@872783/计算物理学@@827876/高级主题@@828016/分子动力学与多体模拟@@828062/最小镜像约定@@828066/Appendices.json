{"hands_on_practices": [{"introduction": "在计算物理中，最常见的周期性边界条件应用于正交晶胞（orthorhombic box）。在这种几何结构中，最小镜像约定可以独立地应用于每个笛卡尔坐标分量。这个练习将指导你编写一个核心函数，它能正确计算周期性边界下的最小镜像距离，并通过一系列精心设计的测试用例，确保你的代码在处理跨越边界、各向异性晶胞乃至坐标位于主晶胞外等情况时依然稳健。这是构建任何分子动力学或蒙特卡洛模拟程序的基础。[@problem_id:2458300]", "problem": "您需要编写一个完整、可运行的程序，以演示在分子动力学（MD）模拟中，周期性边界条件下的最小镜像约定的效果。该程序必须以两种方式计算正交周期性模拟盒子中两个粒子之间的欧几里得距离：(1) 忽略周期性的朴素欧几里得距离，以及 (2) 应用最小镜像约定后的欧几里得距离。距离必须以纳米（nm）为单位表示，并四舍五入保留恰好六位小数。\n\n背景和基本原理：在采用周期性边界条件（PBC）的分子动力学（MD）模拟中，通过对有限的模拟盒子进行无限平铺来模仿体相行为。两个粒子之间的物理距离被解释为一个粒子与另一个粒子的任何周期性镜像之间的最小距离。其底层的几何规则源自欧几里得距离的定义和晶格的平移对称性。对于边长为 $L_x$、$L_y$ 和 $L_z$ 的正交盒子，最小距离是通过沿每个轴选择整数倍盒子长度的平移来获得的，该平移使得位移矢量的欧几里得范数最小。您的程序必须实现此规则。\n\n您的任务：\n- 定义一个函数，给定两个以纳米为单位的三维位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以及以纳米为单位的盒子边长 $(L_x,L_y,L_z)$，返回两个值：\n  1) 以纳米为单位的朴素欧几里得距离 $d_{\\text{naive}} = \\lVert \\mathbf{r}_j - \\mathbf{r}_i \\rVert$，\n  2) 以纳米为单位的最小镜像约定距离 $d_{\\text{mic}}$，通过将位移分量平移 $(L_x,L_y,L_z)$ 的整数倍以使其范数最小化而获得。\n- 将盒子视为正交且轴对齐的。\n- 位置可能位于主盒子区间之外。您的实现仍必须利用周期性正确计算 $d_{\\text{mic}}$。\n- 为了使您的实现清晰，还请在程序中包含一个多行伪代码字符串（不打印），概述您所实现的最小镜像约定逻辑。\n\n数值和单位要求：\n- 所有距离必须以纳米（nm）为单位。\n- 报告的距离需四舍五入到恰好 $6$ 位小数。\n\n测试套件：\n您的程序必须按规定顺序为以下 $5$ 个测试用例中的每一个计算 $[d_{\\text{naive}}, d_{\\text{mic}}]$。\n\n1) 正常情况，盒子内的小分离：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.5\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.5\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.7\\,\\text{nm},\\,1.2\\,\\text{nm},\\,1.6\\,\\text{nm}\\,)$\n\n2) 沿一个轴穿越周期性边界：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.1\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.9\\,\\text{nm},\\,1.0\\,\\text{nm},\\,1.0\\,\\text{nm}\\,)$\n\n3) 各向异性盒子和多轴环绕：\n- 盒子：$(L_x,L_y,L_z) = (\\,2.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,5.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,1.9\\,\\text{nm},\\,0.2\\,\\text{nm},\\,4.8\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,0.1\\,\\text{nm},\\,3.9\\,\\text{nm},\\,0.3\\,\\text{nm}\\,)$\n\n4) 沿一个轴恰好为半个盒子长度的分离（临界情况）：\n- 盒子：$(L_x,L_y,L_z) = (\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm},\\,4.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,2.0\\,\\text{nm},\\,0.0\\,\\text{nm},\\,0.0\\,\\text{nm}\\,)$\n\n5) 位置在主盒子区间之外：\n- 盒子：$(L_x,L_y,L_z) = (\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm},\\,3.0\\,\\text{nm}\\,)$\n- $\\mathbf{r}_i = (\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm},\\,{-}0.1\\,\\text{nm}\\,)$\n- $\\mathbf{r}_j = (\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm},\\,3.1\\,\\text{nm}\\,)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的数对列表。每个数对对应指定顺序的一个测试用例，并且必须采用 $[d_{\\text{naive}},d_{\\text{mic}}]$ 的形式，两个值都以纳米为单位四舍五入到恰好 $6$ 位小数。输出中不得包含空格。\n- 例如，要求的整体格式类似于 $[[a_1,b_1],[a_2,b_2],\\dots]$，其中每个 $a_k$ 和 $b_k$ 都是以纳米为单位且恰好有 $6$ 位小数的浮点数。", "solution": "所提出的问题是计算统计力学中的一个基本练习，具体涉及在分子动力学（MD）模拟中实现周期性边界条件（PBC）。使用PBC是通过模拟少量有限粒子来近似宏观系统性质的一种标准且必要的技术。它减轻了严重的表面效应，否则这些效应将主导小系统的行为。这个问题的核心是正确计算粒子间距离，这由最小镜像约定（MIC）所规定。\n\n该问题定义明确，具有科学依据，并为获得唯一且可验证的解提供了所有必要数据。我们将进行严格的推导和实现。\n\n设正交模拟盒子由一组对应于边长的三个正交矢量定义，$\\mathbf{L} = (L_x, L_y, L_z)$。两个粒子 $i$ 和 $j$ 的位置由矢量 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 给出。\n\n首先，我们定义朴素欧几里得距离 $d_{\\text{naive}}$。这是非周期性三维欧几里得空间中的标准距离。它根据位移矢量 $\\Delta\\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$ 的范数计算得出。\n$$\nd_{\\text{naive}} = \\lVert \\Delta\\mathbf{r} \\rVert = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}\n$$\n其中 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y, \\Delta z)$。此计算忽略了模拟盒子的周期性，并将系统视为孤立在真空中。\n\n其次，我们讨论最小镜像约定距离 $d_{\\text{mic}}$。在周期性系统中，模拟盒子在所有方向上无限复制。位于位置 $\\mathbf{r}$ 的粒子在位置 $\\mathbf{r} + n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}$ 处有一个无限的周期性镜像晶格，其中 $n_x, n_y, n_z$ 是任意整数。粒子 $i$ 和粒子 $j$ 之间的物理距离是粒子 $i$ 与粒子 $j$ 的*任何*周期性镜像之间的最短距离。\n\n数学上，这表示为：\n$$\nd_{\\text{mic}} = \\min_{n_x, n_y, n_z \\in \\mathbb{Z}} \\left\\lVert (\\mathbf{r}_j - \\mathbf{r}_i) - (n_x L_x \\hat{\\mathbf{x}} + n_y L_y \\hat{\\mathbf{y}} + n_z L_z \\hat{\\mathbf{z}}) \\right\\rVert\n$$\n对于正交盒子，范数的最小化可以对每个笛卡尔分量独立进行。让我们考虑位移矢量的 $x$ 分量，$\\Delta x = x_j - x_i$。我们必须找到一个整数 $n_x$ 来最小化 $|\\Delta x - n_x L_x|$。当 $n_x$ 是最接近比率 $\\Delta x / L_x$ 的整数时，即可达到此目的。这就是“最近整数函数”，通常表示为 $\\text{nint}(s)$ 或通过 `round(s)` 实现。\n\n因此，经最小镜像约定调整后的位移分量 $\\Delta x'$ 为：\n$$\n\\Delta x' = \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right)\n$$\n这个公式正确地将位移矢量分量“包裹”到区间 $[-L_x/2, L_x/2]$ 内。同样的逻辑也适用于 $y$ 和 $z$ 分量。那么，经过最小镜像约定调整后的完整位移矢量 $\\Delta\\mathbf{r}'$ 为：\n$$\n\\Delta\\mathbf{r}' = \\left( \\Delta x - L_x \\cdot \\text{round}\\left(\\frac{\\Delta x}{L_x}\\right), \\Delta y - L_y \\cdot \\text{round}\\left(\\frac{\\Delta y}{L_y}\\right), \\Delta z - L_z \\cdot \\text{round}\\left(\\frac{\\Delta z}{L_z}\\right) \\right)\n$$\n这种矢量运算是稳健的，并且能正确处理粒子坐标可能位于主模拟盒子之外的情况，因为只有它们的相对位移才是重要的。\n\n最小镜像距离 $d_{\\text{mic}}$ 是这个调整后位移矢量的欧几里得范数：\n$$\nd_{\\text{mic}} = \\lVert \\Delta\\mathbf{r}' \\rVert = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2 + (\\Delta z')^2}\n$$\n\n所提供的测试用例将使用这种既定方法来解决。实现将利用 `numpy` 库进行高效的矢量运算。对于每个测试用例，我们将计算 $d_{\\text{naive}}$ 和 $d_{\\text{mic}}$，并按要求将结果四舍五入到恰好 $6$ 位小数后报告。对于位移恰好为盒子长度一半的特殊情况，例如 $\\Delta x = L_x/2$，由 `round` 函数处理，该函数通常会四舍五入到最近的偶数整数（例如，在 `numpy` 中），但无论调整后位移的符号选择如何，最终的距离都是唯一的 $L_x/2$。对于 $\\Delta x = L_x/2$，$\\Delta x' = L_x/2 - L_x \\cdot \\text{round}(0.5) = L_x/2 - L_x \\cdot 0 = L_x/2$。其大小是明确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating naive and minimum image convention (MIC)\n    distances for a set of test cases in a molecular dynamics context.\n    \"\"\"\n\n    # Per the problem specification, this multi-line string contains the\n    # pseudocode explaining the implemented MIC logic. It is not printed.\n    # noinspection PyUnusedLocal\n    MIC_PSEUDOCODE = \"\"\"\n    function calculate_minimum_image_distance(r_i, r_j, box_dims):\n        // r_i, r_j: 3D position vectors [x, y, z] of two particles in nm.\n        // box_dims: 3D vector of orthorhombic box lengths [L_x, L_y, L_z] in nm.\n\n        // 1. Calculate the raw displacement vector.\n        //    This is a simple vector subtraction.\n        delta_r = r_j - r_i\n\n        // 2. Apply the minimum image convention to each component of the displacement vector.\n        //    For an orthorhombic box, this can be done independently for each axis.\n        //    The principle is to find the closest periodic image by shifting the displacement\n        //    by an integer number of box lengths. This is mathematically equivalent to\n        //    finding the nearest integer multiple of the box length to subtract.\n        \n        //    Let dr_c be a component of delta_r (e.g., delta_x) and L_c be the\n        //    corresponding box length (e.g., L_x).\n        //    The scaled displacement is s = dr_c / L_c.\n        //    The nearest integer number of box lengths to shift by is n = round(s).\n        //    The MIC-adjusted displacement component is dr'_c = dr_c - n * L_c.\n\n        //    In vector notation, this is:\n        mic_delta_r = delta_r - box_dims * np.round(delta_r / box_dims)\n        \n        // 3. Calculate the Euclidean norm (length) of the MIC-adjusted displacement vector.\n        //    This is the final minimum image distance.\n        distance_mic = sqrt(mic_delta_r[0]^2 + mic_delta_r[1]^2 + mic_delta_r[2]^2)\n        \n        return distance_mic\n    \"\"\"\n\n    def compute_distances(r_i_tuple, r_j_tuple, box_dims_tuple):\n        \"\"\"\n        Calculates naive and MIC distances for a single pair of particles.\n        \n        Args:\n            r_i_tuple (tuple): Position of particle i.\n            r_j_tuple (tuple): Position of particle j.\n            box_dims_tuple (tuple): Orthorhombic box dimensions (Lx, Ly, Lz).\n        \n        Returns:\n            A list containing two floats: [d_naive, d_mic].\n        \"\"\"\n        r_i = np.array(r_i_tuple, dtype=float)\n        r_j = np.array(r_j_tuple, dtype=float)\n        box_dims = np.array(box_dims_tuple, dtype=float)\n\n        # 1. Naive Euclidean distance\n        delta_r_naive = r_j - r_i\n        d_naive = np.linalg.norm(delta_r_naive)\n\n        # 2. Minimum Image Convention (MIC) distance\n        # The logic delta_r - L * round(delta_r / L) correctly finds the\n        # shortest vector in a periodic lattice.\n        delta_r_mic = delta_r_naive - box_dims * np.round(delta_r_naive / box_dims)\n        d_mic = np.linalg.norm(delta_r_mic)\n        \n        return [d_naive, d_mic]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1) Happy path, small separation\n        {'r_i': (0.5, 1.0, 1.5), 'r_j': (0.7, 1.2, 1.6), 'box': (3.0, 3.0, 3.0)},\n        # 2) Crossing a periodic boundary\n        {'r_i': (0.1, 1.0, 1.0), 'r_j': (2.9, 1.0, 1.0), 'box': (3.0, 3.0, 3.0)},\n        # 3) Anisotropic box and multi-axis wrapping\n        {'r_i': (1.9, 0.2, 4.8), 'r_j': (0.1, 3.9, 0.3), 'box': (2.0, 4.0, 5.0)},\n        # 4) Exactly half-box separation\n        {'r_i': (0.0, 0.0, 0.0), 'r_j': (2.0, 0.0, 0.0), 'box': (4.0, 4.0, 4.0)},\n        # 5) Positions outside the primary box\n        {'r_i': (-0.1, -0.1, -0.1), 'r_j': (3.1, 3.1, 3.1), 'box': (3.0, 3.0, 3.0)},\n    ]\n\n    result_strings = []\n    for case in test_cases:\n        d_naive, d_mic = compute_distances(case['r_i'], case['r_j'], case['box'])\n        \n        # Format the numbers to exactly 6 decimal places and create the pair string.\n        # This ensures trailing zeros are included and meets the formatting requirement.\n        result_strings.append(f\"[{d_naive:.6f},{d_mic:.6f}]\")\n\n    # Final print statement in the exact required format: [[a1,b1],[a2,b2],...]\n    # without spaces between elements.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2458300"}, {"introduction": "虽然正交晶胞很常见，但许多先进的模拟（尤其是在材料科学和固态物理学中）需要在更普遍的三斜晶胞（triclinic box）中进行，其晶格矢量不一定相互正交。在这种情况下，简单的逐分量校正方法将不再适用。本练习将引导你实现一个更强大、更通用的最小镜像约定算法，它通过将问题从笛卡尔坐标转换到分数坐标（fractional coordinates）来解决，这对于处理任意形状的周期性晶胞都是至关重要的。[@problem_id:2414062]", "problem": "要求您为通用的三斜（非正交）周期性模拟盒子实现最小镜像约定（MIC）。对于任意点对，MIC在其模拟晶胞的中心周期性镜像中定义了其位移的唯一代表。该模拟盒子由一个满秩晶格矩阵 $H \\in \\mathbb{R}^{3 \\times 3}$ 指定，其列是三个布拉菲晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的笛卡尔坐标。对于任意两个具有笛卡尔位置矢量 $\\mathbf{r}_i, \\mathbf{r}_j \\in \\mathbb{R}^3$ 的点，原始位移为 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。在周期性边界条件下，周期性镜像之间相差一个晶格平移量 $H \\mathbf{n}$，其中 $\\mathbf{n} \\in \\mathbb{Z}^3$。MIC旨在寻找位于模拟晶胞中心镜像内的位移 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，该位移可通过合适的整数晶格平移获得。\n\n从周期性边界条件的基本定义出发：两个笛卡尔位置矢量 $\\mathbf{r}$ 和 $\\mathbf{r}'$ 表示同一个物理点，当且仅当存在某个 $\\mathbf{n} \\in \\mathbb{Z}^3$ 使得 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$。利用此定义，通过在分数坐标 $\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$ 中进行计算，并将 $\\mathbf{s}$ 约化到分数空间中的一个中心平行六面体内，来推导一个用于计算三斜盒子 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的数值稳定且通用的算法。明确说明在约化分数坐标分量时如何处理半整数的取舍问题，并证明您的选择能够确保约化后的每个分数坐标分量都位于一个长度为1的半开区间内。\n\n您的程序必须实现所推导的算法，并将其应用于以下测试套件。在每个案例中，$H$ 由其列向量给出，位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 以笛卡尔坐标给出。您的代码必须为每个案例计算出以笛卡尔坐标表示的MIC位移矢量 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 及其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n\n测试套件（每个矩阵和矢量均采用笛卡尔分量）：\n\n- 案例 $1$（正交立方体）：\n  - $H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (1, 2, 3)$，\n  - $\\mathbf{r}_j = (9, 9, 9)$。\n- 案例 $2$（三斜剪切 I）：\n  - $\\mathbf{a} = (10, 0, 0)$，$\\mathbf{b} = (2, 8, 0)$，$\\mathbf{c} = (1, 1, 6)$，\n  - $H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (1, 1, 1)$，\n  - $\\mathbf{r}_j = (9, 7, 5)$。\n- 案例 $3$（边界取舍处理）：\n  - $\\mathbf{a} = (8, 0, 0)$，$\\mathbf{b} = (1, 7, 0)$，$\\mathbf{c} = (2, 1, 9)$，\n  - $H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$，\n  - 令 $\\mathbf{s} = (0.5, -0.5, 0.5)$ 并定义 $\\mathbf{r} = H \\mathbf{s}$，\n  - $\\mathbf{r}_i = (0, 0, 0)$，\n  - $\\mathbf{r}_j = \\mathbf{r}$。\n- 案例 $4$（三斜剪切 II）：\n  - $\\mathbf{a} = (5, 0, 0)$，$\\mathbf{b} = (4, 5, 0)$，$\\mathbf{c} = (3, 2, 5)$，\n  - $H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$，\n  - $\\mathbf{r}_i = (4.9, 0.1, 0.1)$，\n  - $\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n\n最终输出规范：\n- 对于每个案例，输出一个包含四个实数的列表：$\\Delta \\mathbf{r}_{\\mathrm{MIC}}$ 的三个笛卡尔分量，后跟其欧几里得范数 $\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2$。\n- 将每个实数四舍五入到6位小数。\n- 您的程序应生成单行输出，其中包含四个案例的结果，格式为Python风格的列表的列表，例如：$[\\,[x_1,y_1,z_1,n_1],[x_2,y_2,z_2,n_2],[x_3,y_3,z_3,n_3],[x_4,y_4,z_4,n_4]\\,]$。", "solution": "所提出的问题是为三斜周期性系统中的最小镜像约定（MIC）位移矢量计算制定并实现一个通用算法。这是计算物理学中的一项基本任务，尤其是在分子动力学和蒙特卡洛模拟中。该问题陈述在科学上是合理的、适定的，并为获得唯一解提供了足够的信息。\n\n首先，我们建立理论基础。一个三斜模拟晶胞由三个线性无关的晶格矢量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义，它们构成了晶格矩阵 $H = [\\mathbf{a}, \\mathbf{b}, \\mathbf{c}] \\in \\mathbb{R}^{3 \\times 3}$ 的列。由于周期性边界条件，一个具有笛卡尔位置矢量 $\\mathbf{r}$ 的点有无限多个等效的周期性镜像，由 $\\mathbf{r}' = \\mathbf{r} + H \\mathbf{n}$ 给出，其中 $\\mathbf{n} = (n_1, n_2, n_3)^T$ 是任意整数矢量，$\\mathbf{n} \\in \\mathbb{Z}^3$。\n\n从点 $\\mathbf{r}_i$ 到点 $\\mathbf{r}_j$ 的位移矢量也不是唯一的。原始位移是 $\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。对于某个 $\\mathbf{n} \\in \\mathbb{Z}^3$，任意一个等效位移由 $\\Delta \\mathbf{r}' = \\mathbf{r}_j' - \\mathbf{r}_i = (\\mathbf{r}_j + H\\mathbf{n}) - \\mathbf{r}_i = \\Delta \\mathbf{r} + H\\mathbf{n}$ 给出。最小镜像约定旨在找到这组矢量中唯一的代表，记为 $\\Delta \\mathbf{r}_{\\mathrm{MIC}}$，它与原点“最接近”。在一般的三斜晶胞中，这意味着找到位于中心维格纳-赛兹原胞内的矢量，该原胞是空间中比到任何其他晶格点都更接近原点晶格点的点的集合。\n\n直接在所有 $\\mathbf{n} \\in \\mathbb{Z}^3$ 上最小化范数 $\\|\\Delta \\mathbf{r} + H\\mathbf{n}\\|_2$ 的计算量很大。一种更稳健、更高效的方法，如问题所建议的，是在分数（或标度）坐标中操作。一个笛卡尔矢量 $\\mathbf{v}$ 通过线性变换 $\\mathbf{s} = H^{-1} \\mathbf{v}$ 转换为分数坐标 $\\mathbf{s}$。$\\mathbf{s}$ 的分量将 $\\mathbf{v}$ 表示为晶格矢量的线性组合。\n\n让我们将此应用于位移矢量：\n$$\n\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} (\\mathbf{r}_j - \\mathbf{r}_i)\n$$\n位移的任意周期性镜像 $\\Delta \\mathbf{r} - H\\mathbf{n}$ 转换到分数坐标为：\n$$\nH^{-1} (\\Delta \\mathbf{r} - H\\mathbf{n}) = H^{-1} \\Delta \\mathbf{r} - H^{-1}H\\mathbf{n} = \\mathbf{s} - \\mathbf{n}\n$$\n这表明，在笛卡尔空间中的周期性镜像之间移动等同于将分数坐标矢量移动一个整数矢量。问题现在简化为找到一个整数矢量 $\\mathbf{n}$，使得约化后的分数矢量 $\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\mathbf{n}$ 的分量位于分数空间中的一个中心单位晶胞内。此中心晶胞的标准选择是每个分量的范围为 $[-0.5, 0.5]$。\n\n要将任意分数坐标分量 $s_k$ 映射到其中心镜像 $s_{k, \\mathrm{MIC}}$，我们必须找到一个整数 $n_k$ 使得 $s_{k, \\mathrm{MIC}} = s_k - n_k \\in [-0.5, 0.5)$。选择一个半开区间，如 $[-0.5, 0.5)$，对于确保唯一映射和解决分量恰好在边界上（半整数）时的歧义至关重要。满足此条件的整数 $n_k$ 是最接近 $s_k$ 的整数。这可以通过算法计算。一种找到 $n_k$ 并执行约化的标准且数值稳定的方法是：\n$$\ns_{k, \\mathrm{MIC}} = s_k - \\lfloor s_k + 0.5 \\rfloor\n$$\n这个操作正确地处理了半整数值的取舍问题。例如，如果 $s_k = 2.5$，则 $s_{k, \\mathrm{MIC}} = 2.5 - \\lfloor 2.5 + 0.5 \\rfloor = 2.5 - \\lfloor 3.0 \\rfloor = 2.5 - 3 = -0.5$。如果 $s_k = -1.5$，则 $s_{k, \\mathrm{MIC}} = -1.5 - \\lfloor -1.5 + 0.5 \\rfloor = -1.5 - \\lfloor -1.0 \\rfloor = -1.5 - (-1) = -0.5$。这将上边界 $0.5$ 一致地映射到下边界 $-0.5$，确保了约化后的分数坐标分量 $s_{k, \\mathrm{MIC}}$ 都位于半开区间 $[-0.5, 0.5)$ 内。这一选择的合理性在于其计算简单，并保证对任何浮点数输入都能得到唯一结果。\n\n完整的算法如下：\n$1$. 计算笛卡尔坐标下的原始位移矢量：$\\Delta \\mathbf{r} = \\mathbf{r}_j - \\mathbf{r}_i$。\n$2$. 将 $\\Delta \\mathbf{r}$ 转换为分数坐标：$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r}$。这需要计算晶格矩阵 $H$ 的逆矩阵。\n$3$. 在分数空间中应用最小镜像条件，将每个分量 $s_k$ 约化到区间 $[-0.5, 0.5)$ 内：$\\mathbf{s}_{\\mathrm{MIC}} = \\mathbf{s} - \\lfloor \\mathbf{s} + 0.5 \\rfloor$，其中运算是逐元素执行的。\n$4$. 将约化后的分数矢量转换回笛卡尔坐标：$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}}$。\n$5$. 计算最终矢量的欧几里得范数：$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(\\Delta \\mathbf{r}_{\\mathrm{MIC}}) \\cdot (\\Delta \\mathbf{r}_{\\mathrm{MIC}})}$。\n\n该算法普遍适用于由满秩矩阵 $H$ 描述的任何周期性晶胞，包括正交和一般三斜形式。我们现在将此算法应用于指定的测试案例。\n\n案例 $1$：$H = \\begin{bmatrix} 10  0  0 \\\\ 0  10  0 \\\\ 0  0  10 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 2, 3)$，$\\mathbf{r}_j = (9, 9, 9)$。\n$\\Delta \\mathbf{r} = (8, 7, 6)$。\n$H^{-1} = \\begin{bmatrix} 0.1  0  0 \\\\ 0  0.1  0 \\\\ 0  0  0.1 \\end{bmatrix}$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = (0.8, 0.7, 0.6)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.8 - 1, 0.7 - 1, 0.6 - 1) = (-0.2, -0.3, -0.4)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-2, -3, -4)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-2)^2+(-3)^2+(-4)^2} = \\sqrt{29} \\approx 5.385165$。\n\n案例 $2$：$H = \\begin{bmatrix} 10  2  1 \\\\ 0  8  1 \\\\ 0  0  6 \\end{bmatrix}$，$\\mathbf{r}_i = (1, 1, 1)$，$\\mathbf{r}_j = (9, 7, 5)$。\n$\\Delta \\mathbf{r} = (8, 6, 4)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (0.6, 0.666667, 0.666667)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.6 - 1, 0.666667 - 1, 0.666667 - 1) = (-0.4, -0.333333, -0.333333)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5, -3, -2)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5)^2+(-3)^2+(-2)^2} = \\sqrt{38} \\approx 6.164414$。\n\n案例 $3$：$H = \\begin{bmatrix} 8  1  2 \\\\ 0  7  1 \\\\ 0  0  9 \\end{bmatrix}$，$\\mathbf{r}_i = (0, 0, 0)$，$\\mathbf{r}_j = H(0.5, -0.5, 0.5)^T$。\n$\\Delta \\mathbf{r} = \\mathbf{r}_j$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} = H^{-1} \\mathbf{r}_j = (0.5, -0.5, 0.5)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (0.5 - \\lfloor 1.0 \\rfloor, -0.5 - \\lfloor 0.0 \\rfloor, 0.5 - \\lfloor 1.0 \\rfloor) = (-0.5, -0.5, -0.5)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (-5.5, -4.0, -4.5)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{(-5.5)^2+(-4)^2+(-4.5)^2} = \\sqrt{66.5} \\approx 8.154753$。\n\n案例 $4$：$H = \\begin{bmatrix} 5  4  3 \\\\ 0  5  2 \\\\ 0  0  5 \\end{bmatrix}$，$\\mathbf{r}_i = (4.9, 0.1, 0.1)$，$\\mathbf{r}_j = (0.2, 4.9, 0.2)$。\n$\\Delta \\mathbf{r} = (-4.7, 4.8, 0.1)$。\n$\\mathbf{s} = H^{-1} \\Delta \\mathbf{r} \\approx (-1.7136, 0.952, 0.02)$。\n$\\mathbf{s}_{\\mathrm{MIC}} = (-1.7136 - \\lfloor -1.2136 \\rfloor, 0.952 - \\lfloor 1.452 \\rfloor, 0.02 - \\lfloor 0.52 \\rfloor) = (0.2864, -0.048, 0.02)$。\n$\\Delta \\mathbf{r}_{\\mathrm{MIC}} = H \\mathbf{s}_{\\mathrm{MIC}} = (1.3, -0.2, 0.1)$。\n$\\|\\Delta \\mathbf{r}_{\\mathrm{MIC}}\\|_2 = \\sqrt{1.3^2+(-0.2)^2+0.1^2} = \\sqrt{1.74} \\approx 1.319091$。\n\n实现将遵循此推导过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Minimum Image Convention displacement for a series of test cases\n    in triclinic periodic boundary conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"H\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"r_i\": np.array([1.0, 2.0, 3.0]),\n            \"r_j\": np.array([9.0, 9.0, 9.0])\n        },\n        {\n            \"H\": np.array([\n                [10.0, 2.0, 1.0],\n                [0.0, 8.0, 1.0],\n                [0.0, 0.0, 6.0]\n            ]),\n            \"r_i\": np.array([1.0, 1.0, 1.0]),\n            \"r_j\": np.array([9.0, 7.0, 5.0])\n        },\n        {\n            \"H\": np.array([\n                [8.0, 1.0, 2.0],\n                [0.0, 7.0, 1.0],\n                [0.0, 0.0, 9.0]\n            ]),\n            \"r_i\": np.array([0.0, 0.0, 0.0]),\n            \"r_j\": np.dot(\n                np.array([\n                    [8.0, 1.0, 2.0],\n                    [0.0, 7.0, 1.0],\n                    [0.0, 0.0, 9.0]\n                ]),\n                np.array([0.5, -0.5, 0.5])\n            )\n        },\n        {\n            \"H\": np.array([\n                [5.0, 4.0, 3.0],\n                [0.0, 5.0, 2.0],\n                [0.0, 0.0, 5.0]\n            ]),\n            \"r_i\": np.array([4.9, 0.1, 0.1]),\n            \"r_j\": np.array([0.2, 4.9, 0.2])\n        }\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        H = case[\"H\"]\n        r_i = case[\"r_i\"]\n        r_j = case[\"r_j\"]\n\n        # Step 1: Calculate the raw displacement vector in Cartesian coordinates.\n        delta_r = r_j - r_i\n\n        # Step 2: Convert delta_r to fractional coordinates.\n        H_inv = np.linalg.inv(H)\n        s = H_inv @ delta_r\n\n        # Step 3: Apply the minimum image condition in fractional space.\n        # This maps each component to the interval [-0.5, 0.5).\n        # s_mic = s - n, where n is the nearest integer vector to s.\n        # This is equivalent to s_mic = s - round(s).\n        # A numerically stable way to implement rounding to the nearest integer\n        # with a consistent tie-breaking rule (x.5 -> x-1) is s - floor(s + 0.5)\n        s_mic = s - np.floor(s + 0.5)\n\n        # Step 4: Convert the reduced fractional vector back to Cartesian coordinates.\n        delta_r_mic = H @ s_mic\n\n        # Step 5: Compute the Euclidean norm of the final vector.\n        norm_mic = np.linalg.norm(delta_r_mic)\n\n        # Format the result for the final output string.\n        result_vector = [\n            delta_r_mic[0],\n            delta_r_mic[1],\n            delta_r_mic[2],\n            norm_mic\n        ]\n        \n        # Round each number to 6 decimal places and format as a string list.\n        formatted_vector = [f\"{val:.6f}\" for val in result_vector]\n        results_as_strings.append(f\"[{','.join(formatted_vector)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2414062"}, {"introduction": "掌握了如何计算最小镜像距离后，一个自然而然的进阶应用是在模拟后处理中正确地分析分子结构。由于周期性边界条件，一个大分子（如聚合物或蛋白质）的原子坐标在输出时可能被“切割”到晶胞的不同侧，导致其看起来是断裂的。本练习将最小镜像约定与图论中的遍历算法（如广度优先搜索）相结合，教你如何识别并重构出完整的、跨越周期性边界的分子或原子团簇。这是一项在分析模拟轨迹时不可或缺的实用技能。[@problem_id:2460022]", "problem": "给定一个三维周期性模拟晶胞，由一个满秩晶格矩阵 $\\mathbf{L} \\in \\mathbb{R}^{3 \\times 3}$ 描述，其列是晶胞向量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 的笛卡尔分量，因此任何笛卡尔坐标位置向量 $\\mathbf{r}$ 都通过 $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ 对应于一个分数坐标向量 $\\mathbf{s}$，其中 $\\mathbf{s} \\in [0,1)^3$。给定原胞内的一组原子位置 $\\{\\mathbf{r}_i\\}_{i=0}^{N-1}$（以笛卡尔坐标表示），一个原子间连接阈值 $r_{\\text{cut}}  0$（以埃 Å 为单位），并指定一个种子原子索引 $s \\in \\{0,\\dots,N-1\\}$（从零开始的索引）。当且仅当周期性体系中两个原子 $i$ 和 $j$ 的最小镜像分离距离 $d_{ij}$ 满足 $d_{ij} \\le r_{\\text{cut}}$ 时，它们被认为是相邻的（由一条无向边连接）。从原子 $i$ 到原子 $j$ 的最小镜像位移 $\\Delta \\mathbf{r}_{ij}$ 定义如下：计算分数坐标 $\\mathbf{s}_i = \\mathbf{L}^{-1}\\mathbf{r}_i$ 和 $\\mathbf{s}_j = \\mathbf{L}^{-1}\\mathbf{r}_j$，形成 $\\Delta \\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i$，然后通过加上一个整数向量得到 $\\widehat{\\Delta \\mathbf{s}}_{ij}$，使其每个分量都位于半开区间 $[-\\tfrac{1}{2}, \\tfrac{1}{2})$ 内，最后设置 $\\Delta \\mathbf{r}_{ij} = \\mathbf{L}\\widehat{\\Delta \\mathbf{s}}_{ij}$。最小镜像距离为 $d_{ij} = \\|\\Delta \\mathbf{r}_{ij}\\|_2$。在顶点 $\\{0,\\dots,N-1\\}$ 上定义一个图，只要 $d_{ij} \\le r_{\\text{cut}}$，就存在边 $\\{i,j\\}$。您的任务是确定属于包含种子原子索引 $s$ 的连通分量的所有原子索引集合，并按升序将这些索引作为排序列表报告。\n\n所有长度（$\\mathbf{L}$ 的条目、$\\mathbf{r}_i$ 的分量和 $r_{\\text{cut}}$）均以埃 (Å) 为单位指定。索引是无单位整数，必须使用从零开始的索引进行报告。边的条件必须解释为 $d_{ij} \\le r_{\\text{cut}}$。\n\n测试套件。对于每个测试用例 $t \\in \\{1,2,3\\}$，给定 $\\mathbf{L}^{(t)}$、笛卡尔位置列表 $\\{\\mathbf{r}^{(t)}_i\\}$、标量 $r^{(t)}_{\\text{cut}}$ 和种子 $s^{(t)}$：\n\n- 测试用例 1（立方晶胞，其中一条链跨越一个面包裹）：\n  - $\\mathbf{L}^{(1)} = \\begin{bmatrix} 10.0  0.0  0.0 \\\\ 0.0  10.0  0.0 \\\\ 0.0  0.0  10.0 \\end{bmatrix}$。\n  - 位置 $\\{\\mathbf{r}^{(1)}_i\\}_{i=0}^{5}$：\n    - $i = 0$: $(9.5,\\, 5.0,\\, 5.0)$，\n    - $i = 1$: $(0.5,\\, 5.0,\\, 5.0)$，\n    - $i = 2$: $(1.5,\\, 5.0,\\, 5.0)$，\n    - $i = 3$: $(8.0,\\, 5.0,\\, 5.0)$，\n    - $i = 4$: $(3.0,\\, 3.0,\\, 3.0)$，\n    - $i = 5$: $(3.9,\\, 3.0,\\, 3.0)$。\n  - $r^{(1)}_{\\text{cut}} = 1.2$。\n  - $s^{(1)} = 0$。\n\n- 测试用例 2（三斜晶胞，其中一个团簇跨越边界）：\n  - $\\mathbf{L}^{(2)} = \\begin{bmatrix} 8.0  2.0  1.0 \\\\ 0.0  7.0  1.5 \\\\ 0.0  0.0  6.5 \\end{bmatrix}$，其中列向量为 $\\mathbf{a} = (8.0,\\,0.0,\\,0.0)$、$\\mathbf{b} = (2.0,\\,7.0,\\,0.0)$、$\\mathbf{c} = (1.0,\\,1.5,\\,6.5)$。\n  - 位置 $\\{\\mathbf{r}^{(2)}_i\\}_{i=0}^{3}$：\n    - $i = 0$: $(10.45,\\, 8.075,\\, 6.175)$，\n    - $i = 1$: $(3.03,\\, 8.145,\\, 6.175)$，\n    - $i = 2$: $(1.33,\\, 1.635,\\, 6.175)$，\n    - $i = 3$: $(4.4,\\, 3.4,\\, 2.6)$。\n  - $r^{(2)}_{\\text{cut}} = 1.0$。\n  - $s^{(2)} = 0$。\n\n- 测试用例 3（正交晶胞，其中距离恰好在阈值上）：\n  - $\\mathbf{L}^{(3)} = \\begin{bmatrix} 8.0  0.0  0.0 \\\\ 0.0  8.0  0.0 \\\\ 0.0  0.0  8.0 \\end{bmatrix}$。\n  - 位置 $\\{\\mathbf{r}^{(3)}_i\\}_{i=0}^{3}$：\n    - $i = 0$: $(7.5,\\, 4.0,\\, 4.0)$，\n    - $i = 1$: $(0.5,\\, 4.0,\\, 4.0)$，\n    - $i = 2$: $(1.5,\\, 4.0,\\, 4.0)$，\n    - $i = 3$: $(4.0,\\, 4.0,\\, 4.0)$。\n  - $r^{(3)}_{\\text{cut}} = 1.0$。\n  - $s^{(3)} = 0$。\n\n要求的程序行为：\n- 对于每个测试用例，根据上述定义的周期性边界条件下的最小镜像约定和邻接规则 $d_{ij} \\le r_{\\text{cut}}$，确定包含种子原子的连通分量中所有原子的索引排序列表。\n- 您的程序应生成单行输出，其中包含结果，格式为不含空格、用方括号括起来的逗号分隔的列表之列表。例如，如果三个结果是列表 $\\ell^{(1)}$、$\\ell^{(2)}$ 和 $\\ell^{(3)}$，则要求的输出格式为 $[\\ell^{(1)},\\ell^{(2)},\\ell^{(3)}]$，其中每个列表呈现为 $[i_0,i_1,\\dots]$，使用从零开始的索引且无空白字符。", "solution": "所提出的问题是计算几何和图论中一个明确定义的练习，是分子模拟领域的基础。它要求在周期性边界条件 (PBC) 下，识别一个原子团簇，该团簇在图中表示为一个连通分量。该问题具有科学依据，内部一致，并包含唯一解所需的所有必要信息。因此，它是有效的，我们将着手进行严谨的分析和算法求解。\n\n问题的核心在于为一般的三斜晶胞正确应用最小镜像约定 (MIC) 来确定原子间的邻接关系，然后使用图遍历算法找到包含指定种子原子的连通分量。\n\n让我们剖析一下这个过程。\n\n1.  **体系表示**：模拟晶胞是一个由三个晶格向量 $\\mathbf{a}$、$\\mathbf{b}$ 和 $\\mathbf{c}$ 定义的平行六面体，这些向量构成了晶格矩阵 $\\mathbf{L} = [\\mathbf{a} \\ \\mathbf{b} \\ \\mathbf{c}]$ 的列。晶胞内的任何笛卡尔位置向量 $\\mathbf{r}$ 都可以通过线性变换 $\\mathbf{r} = \\mathbf{L}\\mathbf{s}$ 唯一地映射到一个分数坐标向量 $\\mathbf{s} \\in [0, 1)^3$。其逆变换为 $\\mathbf{s} = \\mathbf{L}^{-1}\\mathbf{r}$。由于规定 $\\mathbf{L}$ 是满秩的，因此保证 $\\mathbf{L}^{-1}$ 的存在。\n\n2.  **最小镜像约定 (MIC)**：为了计算位于笛卡尔位置 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 的两个原子 $i$ 和 $j$ 之间的距离，我们必须考虑体系的周期性。距离不仅仅是 $\\|\\mathbf{r}_j - \\mathbf{r}_i\\|_2$，而是原子 $j$ 与原子 $i$ 的所有周期性镜像之间的最小距离。原子 $i$ 的所有镜像集合由 $\\{\\mathbf{r}_i + \\mathbf{L}\\mathbf{n} \\,|\\, \\mathbf{n} \\in \\mathbb{Z}^3\\}$ 给出。因此，距离的平方为 $d_{ij}^2 = \\min_{\\mathbf{n} \\in \\mathbb{Z}^3} \\|\\mathbf{r}_j - (\\mathbf{r}_i + \\mathbf{L}\\mathbf{n})\\|_2^2$。\n\n    该问题提供了一种直接且计算高效的算法来找到这个最小镜像位移向量。这个过程避免了对整数向量 $\\mathbf{n}$ 的显式搜索。\n    \n    a. 首先，我们将问题转换到分数坐标空间，在这里处理周期性更简单。笛卡尔坐标中的位移向量是 $\\Delta\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。在分数坐标中，这变为 $\\Delta\\mathbf{s}_{ij} = \\mathbf{s}_j - \\mathbf{s}_i = \\mathbf{L}^{-1}(\\mathbf{r}_j - \\mathbf{r}_i)$。由于 $\\mathbf{s}_i, \\mathbf{s}_j \\in [0,1)^3$，$\\Delta\\mathbf{s}_{ij}$ 的每个分量都位于 $(-1, 1)$ 内。\n\n    b. 下一步是在分数空间中应用 MIC。这意味着找到一个整数向量 $\\mathbf{n}$，使得包裹后的位移 $\\widehat{\\Delta\\mathbf{s}}_{ij} = \\Delta\\mathbf{s}_{ij} - \\mathbf{n}$ 的每个分量都位于区间 $[-\\frac{1}{2}, \\frac{1}{2})$ 内。该向量对应于离原子 $i$ 最近的原子 $j$ 的镜像。对于向量 $\\mathbf{v}$ 的每个分量 $v_k$，将其映射到 $[-\\frac{1}{2}, \\frac{1}{2})$ 的包裹操作可以实现为 $v_k - \\lfloor v_k + \\frac{1}{2} \\rfloor$。在使用浮点运算的计算环境中，必须注意边界情况。一个稳健的实现是 `v_wrapped = (v + 0.5) % 1.0 - 0.5`，其中 `%` 表示能正确处理负数的模运算，例如 Python 的 `%` 运算符或 `numpy.mod`。\n\n    c. 一旦找到包裹后的分数位移 $\\widehat{\\Delta\\mathbf{s}}_{ij}$，我们将其转换回笛卡尔坐标以获得最小镜像位移向量：$\\Delta\\mathbf{r}_{ij}^{\\text{min}} = \\mathbf{L} \\widehat{\\Delta\\mathbf{s}}_{ij}$。\n\n    d. 最小镜像距离 $d_{ij}$ 是该向量的欧几里得范数：$d_{ij} = \\|\\Delta\\mathbf{r}_{ij}^{\\text{min}}\\|_2$。\n\n3.  **图的构建**：一个无向图 $G = (V, E)$被隐式定义。顶点集 $V$是原子索引集 $\\{0, 1, \\dots, N-1\\}$。当且仅当最小镜像距离 $d_{ij}$ 小于或等于给定的截断半径，即 $d_{ij} \\le r_{\\text{cut}}$ 时，边 $(i, j)$ 存在于 $E$ 中。由于距离度量的性质，$d_{ij} = d_{ji}$，因此该图确实是无向的。\n\n4.  **连通分量搜索**：最后的任务是找到包含给定种子原子索引 $s$ 的连通分量中的所有顶点。这是一个标准的图遍历问题。我们可以采用广度优先搜索 (BFS) 或深度优先搜索 (DFS) 算法，从种子顶点 $s$ 开始。\n\n    该算法流程如下：\n    a. 构建图 $G$ 的邻接表表示。对于每对原子 $(i, j)$（其中 $i  j$），计算 $d_{ij}$。如果 $d_{ij} \\le r_{\\text{cut}}$，则将 $j$ 添加到 $i$ 的邻接表中，并将 $i$ 添加到 $j$ 的邻接表中。\n    b. 初始化一个用于 BFS 的队列，其中包含种子原子 $s$，并初始化一个也包含 $s$ 的集合 `visited`。\n    c. 当队列不为空时，从队列中取出一个顶点 $u$。对于邻接表中 $u$ 的每个邻居 $v$，如果 $v$ 尚未被访问，则将其添加到 `visited` 集合中并将其入队。\n    d. 当队列为空时，过程终止。此时 `visited` 集合包含了 $s$ 的连通分量中的所有原子索引。\n\n5.  **最终结果格式化**：按要求将得到的索引集合转换为列表并按升序排序。对每个测试用例重复此过程。\n\n该实现将使用 `numpy` 库进行高效的线性代数运算，例如矩阵求逆、矩阵向量积和向量范数。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Solves the connected components problem for the given test cases.\n    \"\"\"\n    \n    test_cases = [\n        {\n            \"L\": np.array([\n                [10.0, 0.0, 0.0],\n                [0.0, 10.0, 0.0],\n                [0.0, 0.0, 10.0]\n            ]),\n            \"positions\": np.array([\n                [9.5, 5.0, 5.0], [0.5, 5.0, 5.0], [1.5, 5.0, 5.0],\n                [8.0, 5.0, 5.0], [3.0, 3.0, 3.0], [3.9, 3.0, 3.0]\n            ]),\n            \"r_cut\": 1.2,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 2.0, 1.0],\n                [0.0, 7.0, 1.5],\n                [0.0, 0.0, 6.5]\n            ]),\n            \"positions\": np.array([\n                [10.45, 8.075, 6.175], [3.03, 8.145, 6.175],\n                [1.33, 1.635, 6.175], [4.4, 3.4, 2.6]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        },\n        {\n            \"L\": np.array([\n                [8.0, 0.0, 0.0],\n                [0.0, 8.0, 0.0],\n                [0.0, 0.0, 8.0]\n            ]),\n            \"positions\": np.array([\n                [7.5, 4.0, 4.0], [0.5, 4.0, 4.0],\n                [1.5, 4.0, 4.0], [4.0, 4.0, 4.0]\n            ]),\n            \"r_cut\": 1.0,\n            \"seed\": 0\n        }\n    ]\n\n    def find_connected_component(L, positions, r_cut, seed):\n        \"\"\"\n        Finds the connected component for a single test case.\n        \"\"\"\n        num_atoms = len(positions)\n        try:\n            L_inv = np.linalg.inv(L)\n        except np.linalg.LinAlgError:\n            # This should not happen for valid problems with a full-rank matrix L.\n            return []\n\n        # Convert all Cartesian positions to fractional coordinates at once.\n        # Here, positions are rows, so we transpose for matmul and transpose back.\n        # r = Ls - s = L^-1 r. For r vectors as rows: S^T = (L^-1 R^T) - S = (L^-1 R^T)^T = R (L^-1)^T\n        s_coords = positions @ L_inv.T\n        \n        # Build adjacency list\n        adj = {i: [] for i in range(num_atoms)}\n        for i in range(num_atoms):\n            for j in range(i + 1, num_atoms):\n                # Fractional displacement\n                delta_s = s_coords[j] - s_coords[i]\n                \n                # Apply minimum image convention to fractional displacement\n                # Wrap into [-0.5, 0.5)\n                # This is a robust way to handle the wrapping for both positive and negative values.\n                delta_s_wrapped = np.mod(delta_s + 0.5, 1.0) - 0.5\n                \n                # Convert back to Cartesian\n                delta_r = delta_s_wrapped @ L.T\n                \n                # Calculate distance\n                dist = np.linalg.norm(delta_r)\n                \n                # Check against cutoff and add edge if connected\n                if dist = r_cut:\n                    adj[i].append(j)\n                    adj[j].append(i)\n\n        # Find connected component using Breadth-First Search (BFS)\n        if seed = num_atoms:\n            return []\n\n        q = deque([seed])\n        visited = {seed}\n        \n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if v not in visited:\n                    visited.add(v)\n                    q.append(v)\n        \n        return sorted(list(visited))\n\n    results = []\n    for case in test_cases:\n        component = find_connected_component(case[\"L\"], case[\"positions\"], case[\"r_cut\"], case[\"seed\"])\n        results.append(component)\n        \n    # Format the final output string as per requirements.\n    formatted_results = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2460022"}]}