{"hands_on_practices": [{"introduction": "虽然PME方法最经典的的应用是处理三维周期性系统中的静电相互作用，但其基本原理具有更强的普适性。本练习将挑战你回归第一性原理，将PME方法论应用于具有对数势的二维系统，例如二维静电学或引力系统。通过从基本的泊松方程出发推导倒易空间核函数，你将加深对该方法背后核心数学物理思想的理解 ([@problem_id:2424403])。", "problem": "考虑一个边长为 $L$ 的二维正方形区域中的 $N$ 个点电荷，其电荷量为 $\\{q_{j}\\}_{j=1}^{N}$，位置为 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$，并采用周期性边界条件。假设系统整体呈电中性，即 $\\sum_{j=1}^{N} q_{j} = 0$。基本相互作用是对数形式的：势 $\\phi(\\mathbf{r})$ 满足二维泊松方程 $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$，因此两个单位电荷之间的对势与 $-\\ln r$ 成正比，其中 $r = |\\mathbf{r}|$。在粒子-网格-埃瓦尔德 (Particle–Mesh Ewald, PME) 方法中，为每个点电荷引入一个高斯屏蔽电荷密度，其宽度（埃瓦尔德）参数为 $\\alpha > 0$，由下式给出：\n$$\n\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp\\!\\big(-\\alpha^{2} r^{2}\\big),\n$$\n并将长程势定义为屏蔽泊松方程的周期解，其源为 $\\rho_{G} * \\rho$，其中 $*$ 表示卷积，$\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$ 是微观电荷密度。\n\n设二维离散傅里叶模为 $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$，其中 $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$，并为区域上的周期函数 $f(\\mathbf{r})$ 定义傅里叶系数：\n$$\n\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp\\!\\big(-i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big)\\,d^{2}\\mathbf{r}\n\\quad\\text{和}\\quad\nf(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp\\!\\big(i\\,\\mathbf{k}\\cdot\\mathbf{r}\\big).\n$$\n记 $k = |\\mathbf{k}|$。在倒易空间中，对于 $\\mathbf{k} \\neq \\mathbf{0}$，PME长程势通过核函数 $\\hat{G}(\\mathbf{k})$ 写为 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$。请推导 $\\hat{G}(\\mathbf{k})$ 关于 $\\alpha$ 和 $k$ 的精确闭式解析表达式（对于 $\\mathbf{k} \\neq \\mathbf{0}$）。您的最终答案必须是仅含 $k$ 和 $\\alpha$ 的单个表达式。不要包含 $\\mathbf{k} = \\mathbf{0}$ 模。不需要进行数值计算。[@problem_id:483]", "solution": "问题陈述需要经过验证。\n\n步骤1：提取已知条件。\n- 一个包含 $N$ 个点电荷的系统，其电荷量为 $\\{q_{j}\\}_{j=1}^{N}$，位置为 $\\{\\mathbf{r}_{j}\\}_{j=1}^{N}$。\n- 该区域是一个边长为 $L$ 的二维正方形，具有周期性边界条件。\n- 系统是电中性的：$\\sum_{j=1}^{N} q_{j} = 0$。\n- 二维泊松方程由 $\\Delta \\phi(\\mathbf{r}) = -2\\pi \\rho(\\mathbf{r})$ 给出。\n- 微观电荷密度为 $\\rho(\\mathbf{r}) = \\sum_{j=1}^{N} q_{j}\\,\\delta(\\mathbf{r}-\\mathbf{r}_{j})$。\n- 高斯屏蔽电荷密度定义为 $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\,\\exp(-\\alpha^{2} r^{2})$，其中 $r = |\\mathbf{r}|$。\n- 长程势的源是卷积 $\\rho_{G} * \\rho$。\n- 离散傅里叶模为 $\\mathbf{k} = \\frac{2\\pi}{L}(m_{x}, m_{y})$，对于 $(m_{x}, m_{y}) \\in \\mathbb{Z}^{2}$。\n- 傅里叶变换的约定如下：$\\hat{f}(\\mathbf{k}) = \\int_{[0,L)^{2}} f(\\mathbf{r})\\,\\exp(-i\\,\\mathbf{k}\\cdot\\mathbf{r})\\,d^{2}\\mathbf{r}$ 和 $f(\\mathbf{r}) = \\frac{1}{L^{2}} \\sum_{\\mathbf{k}} \\hat{f}(\\mathbf{k})\\,\\exp(i\\,\\mathbf{k}\\cdot\\mathbf{r})$。\n- 倒易空间中长程势的关系由 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$ 给出，适用于 $\\mathbf{k} \\neq \\mathbf{0}$，其中 $k=|\\mathbf{k}|$。\n- 目标是推导核函数 $\\hat{G}(\\mathbf{k})$ 的表达式。\n\n步骤2：使用提取的已知条件进行验证。\n该问题具有科学依据。它描述了具有对数相互作用的二维系统中粒子-网格-埃瓦尔德 (PME) 方法的倒易空间部分的数学表述，这在计算物理学中是一项标准且成熟的技术。泊松方程、电荷密度和傅里叶变换的约定都是标准的且内部一致。\n\n该问题是适定的。它要求基于一组清晰的定义和物理方程，推导一个特定的数学量，即傅里叶空间核函数 $\\hat{G}(\\mathbf{k})$。排除 $\\mathbf{k}=\\mathbf{0}$ 模是一个关键且正确的规定，它避免了泊松算子格林函数中的奇点，并确保了在给定的电中性条件下问题的适定性。\n\n该问题是客观的，其术语是精确的。它不包含任何会妨碍严格推导的主观论断、歧义或缺失信息。\n\n步骤3：结论与行动。\n该问题被判定为 **有效**。我们继续进行推导。\n\n势的长程分量 $\\phi^{\\mathrm{LR}}(\\mathbf{r})$ 被定义为屏蔽泊松方程的解。该方程的源是微观电荷密度 $\\rho(\\mathbf{r})$ 与高斯屏蔽密度 $\\rho_{G}(\\mathbf{r})$ 的卷积。我们将此长程源密度记为 $\\rho^{\\mathrm{LR}}(\\mathbf{r}) = (\\rho * \\rho_{G})(\\mathbf{r})$。因此，控制方程为：\n$$\n\\Delta \\phi^{\\mathrm{LR}}(\\mathbf{r}) = -2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\n$$\n为了解此方程，我们将其变换到傅里叶空间。在倒易空间中，作用于函数的拉普拉斯算子 $\\Delta$ 的傅里叶变换是乘以 $-k^{2}$，其中 $k = |\\mathbf{k}|$。对该方程两边应用傅里叶变换得到：\n$$\n\\widehat{\\Delta \\phi^{\\mathrm{LR}}}(\\mathbf{k}) = -k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n右边变为：\n$$\n\\mathcal{F}\\{-2\\pi \\rho^{\\mathrm{LR}}(\\mathbf{r})\\} = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n因此，傅里叶空间中的泊松方程为：\n$$\n-k^{2} \\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = -2\\pi \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n对于 $\\mathbf{k} \\neq \\mathbf{0}$，我们可以解出 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$：\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k})\n$$\n接下来，我们利用卷积定理，该定理指出两个函数卷积的傅里叶变换是它们各自傅里叶变换的乘积。源 $\\rho^{\\mathrm{LR}}$ 是一个卷积，所以其傅里叶变换为：\n$$\n\\hat{\\rho}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{\\rho}(\\mathbf{k}) \\hat{\\rho}_{G}(\\mathbf{k})\n$$\n这里，$\\hat{\\rho}(\\mathbf{k})$ 是微观电荷密度的傅里叶变换，$\\hat{\\rho}_{G}(\\mathbf{k})$ 是高斯屏蔽密度的傅里叶变换。将此代入 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k})$ 的表达式中得到：\n$$\n\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k}) \\hat{\\rho}(\\mathbf{k})\n$$\n问题陈述通过核函数 $\\hat{G}(\\mathbf{k})$ 将倒易空间势定义为 $\\hat{\\phi}^{\\mathrm{LR}}(\\mathbf{k}) = \\hat{G}(\\mathbf{k})\\,\\hat{\\rho}(\\mathbf{k})$。通过直接比较，我们确定核函数为：\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\hat{\\rho}_{G}(\\mathbf{k})\n$$\n最后一步是计算屏蔽密度 $\\rho_{G}(\\mathbf{r})$ 的傅里叶变换。由于 $\\rho_{G}(\\mathbf{r}) = \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2})$ 是一个快速衰减的函数，其傅里叶变换通过在整个空间 $\\mathbb{R}^{2}$ 上积分来计算：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\int_{\\mathbb{R}^{2}} \\frac{\\alpha^{2}}{\\pi}\\exp(-\\alpha^{2} r^{2}) \\exp(-i \\mathbf{k} \\cdot \\mathbf{r}) d^{2}\\mathbf{r}\n$$\n用笛卡尔坐标表示，令 $\\mathbf{r} = (x,y)$ 和 $\\mathbf{k} = (k_{x}, k_{y})$，该积分可以分离：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx \\right) \\left( \\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} y^{2} - i k_{y} y) dy \\right)\n$$\n这是一个标准的高斯积分，形式为 $\\int_{-\\infty}^{\\infty} \\exp(-ax^{2} - bx) dx = \\sqrt{\\frac{\\pi}{a}}\\exp(\\frac{b^{2}}{4a})$。对于 $x$ 的积分，我们有 $a=\\alpha^{2}$ 和 $b=ik_{x}$。结果是：\n$$\n\\int_{-\\infty}^{\\infty} \\exp(-\\alpha^{2} x^{2} - i k_{x} x) dx = \\sqrt{\\frac{\\pi}{\\alpha^{2}}} \\exp\\left(\\frac{(ik_{x})^{2}}{4\\alpha^{2}}\\right) = \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right)\n$$\n对 $y$ 的积分形式相同。结合 $x$ 和 $y$ 的积分结果：\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{x}^{2}}{4\\alpha^{2}}\\right) \\right) \\left( \\frac{\\sqrt{\\pi}}{\\alpha} \\exp\\left(-\\frac{k_{y}^{2}}{4\\alpha^{2}}\\right) \\right)\n$$\n$$\n\\hat{\\rho}_{G}(\\mathbf{k}) = \\frac{\\alpha^{2}}{\\pi} \\frac{\\pi}{\\alpha^{2}} \\exp\\left(-\\frac{k_{x}^{2} + k_{y}^{2}}{4\\alpha^{2}}\\right) = \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\n这是一个众所周知的结果，即归一化高斯函数的傅里叶变换是另一个高斯函数。\n\n最后，我们将其代回核函数 $\\hat{G}(\\mathbf{k})$ 的表达式中：\n$$\n\\hat{G}(\\mathbf{k}) = \\frac{2\\pi}{k^{2}} \\exp\\left(-\\frac{k^{2}}{4\\alpha^{2}}\\right)\n$$\n这就是对于 $\\mathbf{k} \\neq \\mathbf{0}$ 所要求的倒易空间PME核的闭式表达式。", "answer": "$$\n\\boxed{\\frac{2\\pi}{k^2} \\exp\\left(-\\frac{k^2}{4\\alpha^2}\\right)}\n$$", "id": "2424403"}, {"introduction": "PME中的“PM”代表“粒子-网格”（Particle-Mesh），这是一种功能强大的数值技术，其应用远不止于分配电荷。本练习将这一核心技术拓展到新的物理量计算中。通过将质量和成对相互作用的维里等粒子属性“沉积”到网格上，我们可以计算出如质量密度和应力张量这样的连续场，从而搭建起从离散粒子描述到连续介质力学的桥梁 ([@problem_id:2424437])。", "problem": "要求您推导并实现一个粒子到网格的算法，本着Particle-Mesh Ewald (PME)方法的精神，用于在周期性立方体区域内根据粒子数据计算局域场。目标是通过使用Particle-Mesh Ewald (PME)中常用的相同紧支集分配函数，将粒子和粒子对的量沉积到均匀网格上，从而计算质量密度场和构型应力张量场。该方法必须从微观场的基本定义出发进行推导，然后使用一阶B样条分配（也称为云中胞）离散化到网格上。所有量均采用约化的无量纲单位。\n\n基本依据：\n- 微观质量密度由分布 $ \\rho(\\mathbf{r}) = \\sum_{i=1}^{N} m_i \\, \\delta(\\mathbf{r} - \\mathbf{r}_i) $ 定义，其中 $ m_i $ 和 $ \\mathbf{r}_i $ 分别是粒子 $ i $ 的质量和位置，$ \\delta(\\cdot) $ 是狄拉克δ函数。\n- 静态构型（速度为零）的Irving–Kirkwood (IK)构型应力张量场定义为 $ \\boldsymbol{\\sigma}(\\mathbf{r}) = - \\dfrac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta\\!\\left(\\mathbf{r} - \\mathbf{r}_i + s \\, \\mathbf{r}_{ij}\\right) \\, ds $，其中 $ \\mathbf{r}_{ij} $ 是从粒子 $ i $ 到 $ j $ 的最小镜像分离矢量，$ \\mathbf{F}_{ij} $ 是 $ j $ 对 $ i $ 的作用力，$ \\otimes $ 表示外积。\n\n任务1（推导）：从上述定义出发，将狄拉克δ函数 $ \\delta(\\cdot) $ 替换为Particle-Mesh Ewald (PME)中使用的一阶基数B样条（云中胞）的可分离紧支集分配函数 $ W(\\mathbf{r}) = w(x) \\, w(y) \\, w(z) $。明确推导以下离散网格公式：\n- 在边长为 $ L $、具有 $ N \\times N \\times N $ 个节点且间距为 $ h = L/N $ 的周期性立方体内的均匀网格上，由整数 $ (i,j,k) $ 索引的网格节点处的网格质量密度值 $ \\rho_{i,j,k} $。您的离散公式必须满足精确的质量守恒，即 $ \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{\\ell=1}^{N_p} m_\\ell $，其中 $ N_p $ 是粒子数。\n- 使用Irving–Kirkwood线积分的中点近似计算网格构型应力张量值 $ \\boldsymbol{\\sigma}_{i,j,k} $，即将每对粒子的贡献沉积在两粒子间最小镜像线段的中点上。证明当使用相同的分配函数 $ W $ 进行沉积时，体积积分 $ \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 $ 等于全局维里张量 $ \\mathbf{W} = - \\dfrac{1}{2} \\sum_{i \\neq j} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} $。\n\n任务2（算法设计）：使用您推导出的离散公式，\n- 在边长为 $ L $ 的立方体上实现周期性边界条件，最小镜像分离矢量为 $ \\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i - L \\, \\mathrm{round}\\!\\left((\\mathbf{r}_j - \\mathbf{r}_i)/L\\right) $，按分量应用。\n- 使用在截断半径 $ r_c $ 处截断的Lennard-Jones对力，其势能为 $ U(r) = 4 \\, \\varepsilon \\left[ \\left(\\dfrac{\\sigma}{r}\\right)^{12} - \\left(\\dfrac{\\sigma}{r}\\right)^6 \\right] $，力为 $ \\mathbf{F}(r) = - \\dfrac{dU}{dr} \\, \\hat{\\mathbf{r}} $，且仅对 $r  r_c$ 的粒子对计算力。不应用尾部校正或位移；使用直接截断法。假设速度为零，因此应力的动能部分恒为零。\n\n任务3（实现与输出）：编写一个完整、可运行的程序，该程序：\n- 使用一阶B样条分配（云中胞）构建网格并沉积质量密度和构型应力张量。\n- 对下面的每个测试用例，计算三个标量诊断值：\n  1) 网格上的总质量， $ M_{\\mathrm{grid}} = \\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 $。\n  2) 最大网格密度值 $ \\max_{i,j,k} \\rho_{i,j,k} $。\n  3) 体积积分后的网格应力与解析全局维里张量之差的弗罗贝尼乌斯范数， $ \\left\\| \\sum_{i,j,k} \\boldsymbol{\\sigma}_{i,j,k} \\, h^3 - \\mathbf{W} \\right\\|_F $。\n\n所有量都是无量纲的。不使用角度。不使用百分比。\n\n测试套件：\n- 案例A（通用多粒子）：$ L = 1.0 $，$ N = 8 $，$ \\varepsilon = 1.0 $，$ \\sigma = 0.2 $，$ r_c = 0.5 $。粒子：质量 $ [1.0, 2.0, 1.5] $，位置 $ \\{ [0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5] \\} $。\n- 案例B（边界环绕单粒子）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [1.0] $，位置 $ \\{ [0.99, 0.01, 0.49] \\} $。\n- 案例C（最小镜像近邻对）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [1.0, 1.0] $，位置 $ \\{ [0.95, 0.5, 0.5], [0.05, 0.5, 0.5] \\} $。\n- 案例D（空系统）：$ L, N, \\varepsilon, \\sigma, r_c $ 同上。粒子：质量 $ [\\,] $，位置 $ \\{ \\, \\} $。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含按顺序排列的逗号分隔结果列表，并用方括号括起：\n  $ [ M_{\\mathrm{grid}}^{(A)}, \\max \\rho^{(A)}, \\Delta \\sigma^{(A)}, M_{\\mathrm{grid}}^{(B)}, \\max \\rho^{(B)}, \\Delta \\sigma^{(B)}, M_{\\mathrm{grid}}^{(C)}, \\max \\rho^{(C)}, \\Delta \\sigma^{(C)}, M_{\\mathrm{grid}}^{(D)}, \\max \\rho^{(D)}, \\Delta \\sigma^{(D)} ] $，\n  其中 $ \\Delta \\sigma $ 表示上文定义的应力差异的弗罗贝尼乌斯范数。例如，格式必须类似于 $ [r_1,r_2,\\dots,r_{12}] $，包含 $ 12 $ 个浮点数。", "solution": "所提出的问题是计算物理学中一个明确定义的任务，要求推导并实现一个粒子到网格的算法，用于计算质量密度和构型应力场。它在科学上基于统计力学原理和标准数值方法（粒子-网格法）。该问题是自包含的，提供了所有必要的定义、参数和测试数据。因此，该问题被认为是有效的，有必要提供完整的解决方案。\n\n### 任务1：离散网格公式的推导\n\n给定一个边长为 $L$ 的周期性立方体区域，其上有一个 $N \\times N \\times N$ 个节点的均匀网格，网格间距为 $h = L/N$。\n\n#### 1.1. 质量密度场\n\n微观质量密度定义为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, \\delta(\\mathbf{r} - \\mathbf{r}_p)\n$$\n其中 $m_p$ 和 $\\mathbf{r}_p$ 分别是粒子 $p$ 的质量和位置，$\\delta(\\cdot)$ 是狄拉克δ函数。\n\n为了离散化此式，我们将狄拉克δ函数替换为一个连续的紧支集分配函数 $W(\\mathbf{r})$。得到的平mooth密度场 $\\rho_{\\text{smooth}}(\\mathbf{r})$ 为：\n$$\n\\rho_{\\text{smooth}}(\\mathbf{r}) = \\sum_{p=1}^{N_p} m_p \\, W(\\mathbf{r} - \\mathbf{r}_p)\n$$\n问题指定了使用一阶基数B样条（云中胞或CIC）分配函数。此函数是可分离的，$W(\\mathbf{r}) = w(x)w(y)w(z)$。对于网格间距 $h$，一维核函数是一个三角（或“帽状”）函数：\n$$\nw(u) = \\frac{1}{h} \\max\\left(0, 1 - \\frac{|u|}{h}\\right)\n$$\n$1/h$ 因子确保 $\\int_{-\\infty}^{\\infty} w(u) \\, du = 1$，从而使得 $\\int_{\\mathbb{R}^3} W(\\mathbf{r}) \\, d^3\\mathbf{r} = 1$。\n\n粒子-网格方法中保证质量守恒的标准流程，不是通过采样 $\\rho_{\\text{smooth}}(\\mathbf{r})$ 来定义基于网格的密度 $\\rho_{i,j,k}$，而是通过将质量分配到网格上来定义。设 $M_{i,j,k}$ 为分配给网格节点 $\\mathbf{r}_{i,j,k} = (ih, jh, kh)$ 的总质量。此节点的密度定义为：\n$$\n\\rho_{i,j,k} = \\frac{M_{i,j,k}}{h^3}\n$$\n质量 $M_{i,j,k}$ 的计算方法是，根据从B样条派生出的无量纲权重函数，将每个粒子 $m_p$ 的质量分配到其相邻的网格节点上。假设一个粒子位于位置 $\\mathbf{r}_p$。其标度化位置为 $\\mathbf{s}_p = \\mathbf{r}_p/h$。设 $\\mathbf{n}_p = (\\lfloor s_p^x \\rfloor, \\lfloor s_p^y \\rfloor, \\lfloor s_p^z \\rfloor)$ 为粒子负方向上最接近的网格节点的整数索引（“基”节点）。粒子在此基单元内的分数位置为 $\\mathbf{u}_p = \\mathbf{s}_p - \\mathbf{n}_p$。\n\nCIC方案将粒子质量 $m_p$ 分配给包含该粒子的单元格的 $2^3=8$ 个网格节点。对于距 $\\mathbf{n}_p$ 偏移量为 $(\\delta_x, \\delta_y, \\delta_z)$ 的节点（其中 $\\delta_x, \\delta_y, \\delta_z \\in \\{0, 1\\}$），其权重为：\n$$\nS(\\mathbf{u}_p, \\boldsymbol{\\delta}) = \\big( (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} \\big) \\big( (1-u_p^y)^{1-\\delta_y}(u_p^y)^{\\delta_y} \\big) \\big( (1-u_p^z)^{1-\\delta_z}(u_p^z)^{\\delta_z} \\big)\n$$\n从粒子 $p$ 分配到网格节点 $\\mathbf{k} = \\mathbf{n}_p + \\boldsymbol{\\delta}$ 的质量为 $m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta})$。节点 $\\mathbf{k}$ 上的总质量是所有粒子的贡献之和：\n$$\nM_{\\mathbf{k}} = \\sum_{p=1}^{N_p} m_p S(\\mathbf{u}_p, \\boldsymbol{\\delta}_{\\mathbf{k},p})\n$$\n其中 $\\boldsymbol{\\delta}_{\\mathbf{k},p}$ 是节点 $\\mathbf{k}$ 相对于粒子 $p$ 的基节点的相对索引。\n\n**质量守恒证明：** 我们必须证明 $\\sum_{i,j,k} \\rho_{i,j,k} \\, h^3 = \\sum_{p=1}^{N_p} m_p$。\n代入 $\\rho_{i,j,k}$ 的定义：\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{i,j,k} \\left( \\frac{M_{i,j,k}}{h^3} \\right) h^3 = \\sum_{i,j,k} M_{i,j,k}\n$$\n这是分配给所有网格节点的总质量。通过交换求和顺序：\n$$\n\\sum_{i,j,k} M_{i,j,k} = \\sum_{i,j,k} \\sum_{p=1}^{N_p} (\\text{从 } p \\text{ 到 } i,j,k \\text{ 的质量}) = \\sum_{p=1}^{N_p} m_p \\left( \\sum_{i,j,k} \\text{对 } p \\text{ 的权重} \\right)\n$$\n对于任何粒子 $p$，其在所有网格节点上的分配权重之和为 $\\sum_{\\delta_x,\\delta_y,\\delta_z \\in \\{0,1\\}} S(\\mathbf{u}_p, \\boldsymbol{\\delta}) = 1$。这是因为 $\\sum_{\\delta_x=0}^1 (1-u_p^x)^{1-\\delta_x}(u_p^x)^{\\delta_x} = (1-u_p^x)+u_p^x = 1$，并且这对每个维度都成立。因此，权重之和为 $1 \\times 1 \\times 1 = 1$。\n因此，我们证明了守恒定律：\n$$\n\\sum_{i,j,k} \\rho_{i,j,k} h^3 = \\sum_{p=1}^{N_p} m_p (1) = \\sum_{p=1}^{N_p} m_p\n$$\n\n#### 1.2. 构型应力张量场\n\n静态构型的Irving-Kirkwood构型应力张量为：\n$$\n\\boldsymbol{\\sigma}(\\mathbf{r}) = - \\frac{1}{2} \\sum_{i \\neq j} \\int_{0}^{1} \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij} \\, \\delta(\\mathbf{r} - \\mathbf{r}_i - s \\mathbf{r}_{ij}) \\, ds\n$$\n其中 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$ 是最小镜像分离矢量，$\\mathbf{F}_{ij}$ 是粒子 $j$ 对粒子 $i$ 的作用力。符号 $\\otimes$ 表示外积。\n\n我们用分配函数 $W(\\cdot)$ 替换 $\\delta(\\cdot)$，并对该积分使用中点近似。积分 $\\int_0^1 f(s) ds$ 近似为 $f(1/2)$。这设定了 $s=1/2$。对 $(i,j)$ 粒子对的沉积位置变为 $\\mathbf{r}_i + \\frac{1}{2}\\mathbf{r}_{ij} = \\frac{\\mathbf{r}_i+\\mathbf{r}_j}{2}$，即连接两粒子的线段的中点。\n平滑后的应力场近似为：\n$$\n\\boldsymbol{\\sigma}_{\\text{smooth}}(\\mathbf{r}) \\approx - \\frac{1}{2} \\sum_{i \\neq j} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) W(\\mathbf{r} - (\\mathbf{r}_i+\\mathbf{r}_j)/2)\n$$\n对 $i \\neq j$ 的求和会将每对相互作用计算两次。考虑粒子 $i$ 和 $j$ 之间相互作用的贡献。这些项分别对应 $(i,j)$ 和 $(j,i)$。为这个单一相互作用沉积的量是：\n$$\n\\mathbf{T}_{ij} = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) - \\frac{1}{2} (\\mathbf{r}_{ji} \\otimes \\mathbf{F}_{ji})\n$$\n利用牛顿第三定律 $\\mathbf{F}_{ji} = -\\mathbf{F}_{ij}$ 和矢量恒等式 $\\mathbf{r}_{ji} = -\\mathbf{r}_{ij}$，第二项变为 $-\\frac{1}{2} ((-\\mathbf{r}_{ij}) \\otimes (-\\mathbf{F}_{ij})) = -\\frac{1}{2} (\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij})$。因此：\n$$\n\\mathbf{T}_{ij} = -(\\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ij}) = \\mathbf{r}_{ij} \\otimes \\mathbf{F}_{ji}\n$$\n这个张量代表了粒子对相互作用的全部贡献，它被沉积在单一位置 $\\mathbf{r}_{mid} = (\\mathbf{r}_i+\\mathbf{r}_j)/2$ 上。\n\n与质量密度类似，我们将网格化应力张量 $\\boldsymbol{\\sigma}_{i,j,k}$ 定义为节点 $(i,j,k)$ 处沉积的总应力二元并矢（我们表示为 $\\boldsymbol{\\Sigma}_{i,j,k}$）除以单元体积 $h^3$：\n$$\n\\boldsymbol{\\sigma}_{i,j,k} = \\frac{\\boldsymbol{\\Sigma}_{i,j,k}}{h^3}\n$$\n这里，$\\boldsymbol{\\Sigma}_{i,j,k}$ 是通过对所有唯一粒子对 $(i  j)$ 的贡献求和得到的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the particle-to-mesh problem for the given test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case A (general multi-particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 2.0, 1.5]),\n            \"positions\": np.array([[0.2, 0.3, 0.4], [0.8, 0.1, 0.9], [0.5, 0.5, 0.5]])\n        },\n        # Case B (boundary wrap single particle)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0]),\n            \"positions\": np.array([[0.99, 0.01, 0.49]])\n        },\n        # Case C (minimum-image close pair)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([1.0, 1.0]),\n            \"positions\": np.array([[0.95, 0.5, 0.5], [0.05, 0.5, 0.5]])\n        },\n        # Case D (empty system)\n        {\n            \"L\": 1.0, \"N_grid\": 8, \"epsilon\": 1.0, \"sigma\": 0.2, \"r_c\": 0.5,\n            \"masses\": np.array([]),\n            \"positions\": np.array([])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case[\"L\"]\n        N_grid = case[\"N_grid\"]\n        epsilon = case[\"epsilon\"]\n        sigma = case[\"sigma\"]\n        r_c = case[\"r_c\"]\n        masses = case[\"masses\"]\n        positions = case[\"positions\"]\n        \n        num_particles = len(masses)\n        h = L / N_grid\n        h_inv = 1.0 / h\n\n        # Initialize grids for deposited mass (M_k) and stress (Sigma_k)\n        mass_grid = np.zeros((N_grid, N_grid, N_grid))\n        stress_grid = np.zeros((N_grid, N_grid, N_grid, 3, 3))\n        \n        # --- Mass Deposition ---\n        if num_particles > 0:\n            for p_idx in range(num_particles):\n                m_p = masses[p_idx]\n                r_p = positions[p_idx]\n                \n                s_p = r_p * h_inv\n                base_idx = np.floor(s_p).astype(int)\n                frac_coord = s_p - base_idx\n                \n                # Cloud-in-Cell (CIC) weights\n                w = np.zeros((2, 3))\n                w[0, :] = 1.0 - frac_coord\n                w[1, :] = frac_coord\n\n                for di in range(2):\n                    for dj in range(2):\n                        for dk in range(2):\n                            weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                            grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                            mass_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += m_p * weight\n        \n        # --- Stress Deposition and Analytic Virial ---\n        analytic_virial = np.zeros((3, 3))\n\n        if num_particles > 1:\n            for i in range(num_particles):\n                for j in range(i + 1, num_particles):\n                    # Minimum image convention\n                    r_ij_raw = positions[j] - positions[i]\n                    r_ij = r_ij_raw - L * np.round(r_ij_raw / L)\n                    r_sq = np.dot(r_ij, r_ij)\n                    \n                    if 0  r_sq  r_c**2:\n                        r = np.sqrt(r_sq)\n                        \n                        # Lennard-Jones force calculation\n                        # F_ji = force on particle j due to i\n                        s_over_r_2 = (sigma / r)**2\n                        s_over_r_6 = s_over_r_2**3\n                        s_over_r_12 = s_over_r_6**2\n                        \n                        force_magnitude = 24.0 * epsilon / r * (2.0 * s_over_r_12 - s_over_r_6)\n                        F_ji = (force_magnitude / r) * r_ij\n                        \n                        # Contribution to analytic virial: r_ij (x) F_ji\n                        virial_pair = np.outer(r_ij, F_ji)\n                        analytic_virial += virial_pair\n                        \n                        # Deposition onto grid at midpoint\n                        r_mid = positions[i] + 0.5 * r_ij\n                        # Ensure midpoint is within [0, L)\n                        r_mid = r_mid - L * np.floor(r_mid / L)\n\n                        s_mid = r_mid * h_inv\n                        base_idx = np.floor(s_mid).astype(int)\n                        frac_coord = s_mid - base_idx\n                        \n                        w = np.zeros((2, 3))\n                        w[0, :] = 1.0 - frac_coord\n                        w[1, :] = frac_coord\n\n                        for di in range(2):\n                            for dj in range(2):\n                                for dk in range(2):\n                                    weight = w[di, 0] * w[dj, 1] * w[dk, 2]\n                                    grid_idx = (base_idx + np.array([di, dj, dk])) % N_grid\n                                    stress_grid[grid_idx[0], grid_idx[1], grid_idx[2]] += virial_pair * weight\n\n        # --- Calculate Diagnostics ---\n        \n        # 1. Total mass on the mesh\n        # M_grid = sum(rho_ijk * h^3) = sum( (M_ijk/h^3) * h^3 ) = sum(M_ijk)\n        total_mass_grid = np.sum(mass_grid)\n        \n        # 2. Maximum grid density value\n        # rho_ijk = M_ijk / h^3\n        if num_particles > 0:\n            rho_grid_density = mass_grid / (h**3)\n            max_rho = np.max(rho_grid_density)\n        else:\n            max_rho = 0.0\n\n        # 3. Frobenius norm of stress difference\n        # W_grid = sum(sigma_ijk * h^3) = sum( (Sigma_ijk/h^3) * h^3 ) = sum(Sigma_ijk)\n        grid_virial = np.sum(stress_grid, axis=(0, 1, 2))\n        stress_diff = grid_virial - analytic_virial\n        stress_norm = np.linalg.norm(stress_diff, 'fro')\n        \n        results.extend([total_mass_grid, max_rho, stress_norm])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.8e}' for r in results)}]\")\n\nsolve()\n```", "id": "2424437"}, {"introduction": "标准的PME算法假定系统在所有维度上都具有周期性，但这并非总是符合物理实际。这个高级实践将探讨如何调整PME求解器，以处理具有混合边界条件的系统——即在两个维度上是周期性的，但在第三个维度上被限制在导电板之间。这需要用离散正弦变换（DST）等不同的谱方法来代替标准的快速傅里叶变换（FFT），以正确地施加狄利克雷边界条件，从而展示了PME框架强大的适应性和扩展性 ([@problem_id:2424449])。", "problem": "你需要从第一性原理出发，实现一个简化的粒子-网格-埃瓦尔德（PME）长程静电计算。计算对象为限制在两块平行的接地导电板之间的点电荷。这两块板平行于 $xy$ 平面，分别位于 $z=0$ 和 $z=L_z$ 处，对静电势施加狄利克雷边界条件 $\\,\\phi(x,y,0)=\\phi(x,y,L_z)=0\\,$。该系统在 $x$ 和 $y$ 方向上具有周期性，盒子长度分别为 $L_x$ 和 $L_y$。你的目标是仅使用一个遵守这些边界条件的离散泊松求解器，来计算粒子上仅由基于网格的长程场产生的电力。\n\n基本原理：\n- 从微分形式的高斯定律和真空中的静电本构关系出发：$\\nabla\\cdot \\mathbf{E} = \\rho/\\varepsilon_0$ 和 $\\mathbf{E}=-\\nabla\\phi$，两者结合得到泊松方程 $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$。\n- 使用一个规则的笛卡尔网格，其间距为 $\\Delta x=L_x/N_x$、$\\Delta y=L_y/N_y$ 和 $\\Delta z=L_z/(N_z-1)$。其中，$N_x$ 和 $N_y$ 是 $x$ 和 $y$ 方向（周期性）的网格点数，$N_z$ 是 $z$ 方向（狄利克雷）的网格点数，包括位于 $z=0$ 和 $z=L_z$ 的两个边界平面。内部平面集的索引为 $k=1,\\dots,N_z-2$。\n- 使用云中单元（CIC）方法将电荷分配到网格上，并将场插值回粒子位置，两者均与网格保持一致。\n- 使用混合谱方法求解离散泊松方程：在 $x$ 和 $y$ 方向上使用离散傅里叶变换（周期性），在 $z$ 方向上使用离散正弦变换（狄利克雷）。对于 $x$ 和 $y$ 方向，离散拉普拉斯算子的特征值为 $\\lambda_x(p) = \\left(2\\cos\\left(2\\pi p/N_x\\right)-2\\right)/\\Delta x^2$（对于 $p=0,\\dots,N_x-1$）和 $\\lambda_y(q) = \\left(2\\cos\\left(2\\pi q/N_y\\right)-2\\right)/\\Delta y^2$（对于 $q=0,\\dots,N_y-1$）。对于具有狄利克雷边界条件的 $z$ 方向，在内部节点上使用离散正弦基，其特征值为 $\\lambda_z(m) = \\left(2\\cos\\left(\\pi m/(N_z-1)\\right)-2\\right)/\\Delta z^2$（对于 $m=1,\\dots,N_z-2$）。总特征值为 $\\lambda(p,q,m)=\\lambda_x(p)+\\lambda_y(q)+\\lambda_z(m)$。\n- 在谱空间中，求解 $\\lambda\\,\\Phi = -\\widehat{\\rho}/\\varepsilon_0$ 以得到 $\\Phi$，其中 $\\widehat{\\rho}$ 是内部 $z$ 平面上变换后的电荷密度，$\\Phi$ 是那些内部平面上变换后的电势。然后进行逆变换，以获得整个网格上的 $\\phi$，并通过构造使得边界平面上的 $\\phi=0$。\n- 通过有限差分计算电场分量，在 $x$ 和 $y$ 方向上使用周期性差分，在 $z$ 内部使用中心差分；在 $z$ 边界上，使用单侧二阶差分来近似 $\\partial\\phi/\\partial z$，以与狄利克雷边界条件保持一致。\n\n数值和物理规格：\n- 使用真空介电常数 $\\varepsilon_0 = 8.854187817\\times 10^{-12}\\,\\mathrm{F/m}$。\n- 所有粒子电荷的单位必须是库仑，位置单位是米，输出的力单位是牛顿。\n- 你将只计算通过在具有所述边界条件的网格上求解泊松方程得到的基于网格的长程力。不要包含任何显式的短程或自相互作用校正；目的是测试通过网格求解是否正确地引入了导电板的边界条件。\n\n算法要求：\n- 实现将每个位于位置 $\\mathbf{r}_\\ell$ 的点电荷 $q_\\ell$ 分配到其八个最近网格节点的 CIC 分配方法。在 $x$ 和 $y$ 方向上，使用周期性环绕。在 $z$ 方向上，通过夹紧插值索引将电荷沉积限制在内部平面 $k=1,\\dots,N_z-2$ 上，使得没有电荷沉积在边界节点 $k=0$ 或 $k=N_z-1$ 上；归一化权重，使其在 $z$ 方向上的和为 $1$，尽管在靠近板的区域进行了夹紧操作。\n- 使用上述混合谱方法和给定的特征值在网格上求解离散泊松方程。在 $z$ 内部使用具有标准正交归一化的 I 型离散正弦变换。\n- 在所有网格节点上计算电场 $\\mathbf{E}=-\\nabla\\phi$，使用：\n  - $E_x(i,j,k) = -\\left(\\phi(i+1,j,k)-\\phi(i-1,j,k)\\right)/(2\\Delta x)$，在 $i$ 上使用周期性环绕，\n  - $E_y(i,j,k) = -\\left(\\phi(i,j+1,k)-\\phi(i,j-1,k)\\right)/(2\\Delta y)$，在 $j$ 上使用周期性环绕，\n  - $E_z(i,j,0) = -\\left(-3\\phi(i,j,0)+4\\phi(i,j,1)-\\phi(i,j,2)\\right)/(2\\Delta z)$，\n  - $E_z(i,j,N_z-1) = -\\left(3\\phi(i,j,N_z-1)-4\\phi(i,j,N_z-2)+\\phi(i,j,N_z-3)\\right)/(2\\Delta z)$，\n  - $E_z(i,j,k) = -\\left(\\phi(i,j,k+1)-\\phi(i,j,k-1)\\right)/(2\\Delta z)$，对于 $k=1,\\dots,N_z-2$。\n- 使用相同的 CIC 权重和相同的 $z$ 方向夹紧策略，将电场 $\\mathbf{E}$ 从网格插值到每个粒子位置，然后计算力 $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$。\n\n测试套件：\n所有测试用例使用以下共同的网格和盒子参数：\n- $N_x=N_y=16$, $N_z=32$。\n- $L_x=L_y=4.0\\times 10^{-9}\\,\\mathrm{m}$, $L_z=4.0\\times 10^{-9}\\,\\mathrm{m}$。\n\n设 $e=1.602176634\\times 10^{-19}\\,\\mathrm{C}$。定义四个测试用例：\n\n- 用例 1（对称性检查）：一个电荷为 $q=+e$ 的粒子，位于 $\\left(L_x/2,\\,L_y/2,\\,L_z/2\\right)$。\n- 用例 2（近板吸引）：一个电荷为 $q=+e$ 的粒子，位于 $\\left(0.7L_x,\\,0.3L_y,\\,0.5\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n- 用例 3（跨越中平面的偶极子）：两个粒子，$q_1=+e$ 位于 $\\left(L_x/2-0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2+0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$，$q_2=-e$ 位于 $\\left(L_x/2+0.3\\times 10^{-9}\\,\\mathrm{m},\\,L_y/2,\\,L_z/2-0.4\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n- 用例 4（两个同种电荷靠近相对的板）：两个粒子，$q_1=+e$ 位于 $\\left(L_x/3,\\,L_y/3,\\,0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$，$q_2=+e$ 位于 $\\left(2L_x/3,\\,2L_y/3,\\,L_z-0.6\\times 10^{-9}\\,\\mathrm{m}\\right)$。\n\n最终输出规范：\n- 你的程序必须按顺序为每个用例计算每个粒子上的力分量 $(F_x,F_y,F_z)$（单位为牛顿），粒子的顺序与用例中列出的顺序相同。\n- 将所有用例的结果聚合到一个扁平的浮点数列表中，顺序为\n  $\\left[F_{x,1}^{(1)},F_{y,1}^{(1)},F_{z,1}^{(1)},F_{x,1}^{(2)},F_{y,1}^{(2)},F_{z,1}^{(2)},\\dots\\right]$，其中上标表示用例索引，下标表示该用例内的粒子索引。\n- 将每个数字以牛顿为单位表示，并四舍五入到 $6$ 位有效数字。\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,...]”）。", "solution": "用户要求实现一个简化的粒子-网格-埃瓦尔德（PME）方法，用于计算两块接地导电板之间的点电荷所受的长程静电力。该问题需要遵循一套详细的算法和物理规范，从第一性原理出发进行求解。\n\n### 问题验证\n\n首先，对问题陈述进行严格验证。\n\n**1. 提取已知条件：**\n- **物理学**：泊松方程 $\\nabla^2 \\phi = -\\rho/\\varepsilon_0$，具有混合边界条件：在 $x$ 和 $y$ 方向上是周期性的，在 $z=0$ 和 $z=L_z$ 处是狄利克雷边界条件（$\\phi=0$）。\n- **离散化**：在尺寸为 $L_x \\times L_y \\times L_z$ 的盒子中使用一个尺寸为 $N_x \\times N_y \\times N_z$ 的规则笛卡尔网格。网格间距为 $\\Delta x=L_x/N_x$, $\\Delta y=L_y/N_y$, $\\Delta z=L_z/(N_z-1)$。\n- **数值方法**：\n    - 使用云中单元（CIC）方法进行电荷分配和场插值，并对 $z$ 方向靠近边界处有特定的“夹紧”和“归一化”规则。\n    - 一个混合谱求解器：对 $xy$ 平面使用二维离散傅里叶变换（DFT），对 $z$ 方向的内部网格点（$k=1, \\dots, N_z-2$）使用离散正弦变换（DST）。\n    - 提供了变换空间中离散拉普拉斯算子特征值（$\\lambda_x, \\lambda_y, \\lambda_z$）的具体公式。\n    - 电场 $\\mathbf{E} = -\\nabla\\phi$ 使用指定的有限差分模板计算（内部使用中心差分，边界使用二阶单侧差分）。\n- **参数**：给定了 $\\varepsilon_0$、$e$、盒子尺寸（$L_x, L_y, L_z$）和网格尺寸（$N_x, N_y, N_z$）的值。\n- **测试用例**：定义了四种特定的点电荷配置。\n- **输出**：一个包含所有粒子所有力分量的扁平列表，格式化为 $6$ 位有效数字。\n\n**2. 验证评估：**\n- **科学依据**：该问题牢固地植根于经典静电学以及计算物理中求解偏微分方程的既定数值方法。所提出的方法是PME方法针对板状几何的一个有效但简化的变体。\n- **良构性**：该问题是良构的。使用混合谱方法求解具有给定边界条件的泊松方程，可以得到电势的唯一解。所指定的离散拉普拉斯算子特征值 $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$ 总是非零。具体来说，对于给定的索引范围，$\\lambda_x(p) \\le 0$, $\\lambda_y(q) \\le 0$ 且 $\\lambda_z(m)  0$，确保它们的和总是严格为负。这保证了在谱空间中的除法总是有定义的。\n- **客观且完整**：问题以精确、客观的语言陈述。所有必要的参数、方程和算法步骤均已提供。关于CIC的“夹紧”过程存在轻微的模糊之处，可通过将其解释为将超出边界的网格索引映射到最近的有效内部索引（$1$ 或 $N_z-2$）来解决。该过程被指定用于电荷分配和场插值，从而保持算法的自洽性。\n- **未检测到其他缺陷**：该问题在科学上不是不合理的，也不是不可形式化、矛盾、不切实际或不可验证的。\n\n**3. 结论：**\n该问题是**有效的**。可以按照指定的步骤构建一个完整的解决方案。\n\n### 解题推导\n\n解决方案遵循所概述的算法。核心步骤是：（1）将电荷分配到网格，（2）在网格上求解泊松方程，（3）从电势计算电场，以及（4）将场插值回粒子位置以求得力。\n\n**1. 网格与参数设置**\n我们定义模拟盒子和网格参数。盒子尺寸为 $L_x, L_y, L_z$，网格尺寸为 $N_x, N_y, N_z$。网格间距为 $\\Delta x = L_x/N_x$、$\\Delta y = L_y/N_y$ 和 $\\Delta z = L_z/(N_z-1)$。物理常数 $\\varepsilon_0$ 和 $e$ 按规定使用。\n\n**2. 电荷分配（CIC）**\n对于每个电荷为 $q_\\ell$、位置为 $\\mathbf{r}_\\ell = (x_\\ell, y_\\ell, z_\\ell)$ 的粒子，我们将其电荷映射到网格上。\n首先，我们计算粒子的分数坐标和基准网格索引：\n- $u_x = x_\\ell / \\Delta x$，$i_{base} = \\lfloor u_x \\rfloor \\pmod{N_x}$，$d_x = u_x - \\lfloor u_x \\rfloor$\n- $u_y = y_\\ell / \\Delta y$，$j_{base} = \\lfloor u_y \\rfloor \\pmod{N_y}$，$d_y = u_y - \\lfloor u_y \\rfloor$\n- $u_z = z_\\ell / \\Delta z$，$k_{base} = \\lfloor u_z \\rfloor$，$d_z = u_z - k_{base}$\n\n电荷 $q_\\ell$ 被分配到最近的 $8$ 个网格点。对于网格点 $(i_{base}+di, j_{base}+dj, k_{base}+dk)$（其中 $di, dj, dk \\in \\{0, 1\\}$），其权重为 $w_x(di)w_y(dj)w_z(dk)$，其中 $w_x(0) = 1-d_x$, $w_x(1)=d_x$，对于 $y,z$ 依此类推。\n电荷被沉积到一个尺寸为 $N_x \\times N_y \\times (N_z-2)$ 的内部网格 $\\rho$ 上，对应于物理平面 $k=1, \\dots, N_z-2$。根据问题的“夹紧”指令，任何目标 $z$ 索引 $k$ 超出范围 $[1, N_z-2]$ 的沉积都被重定向到最近的有效索引。这通过夹紧目标索引来实现：$k_{target} = \\text{clip}(k, 1, N_z-2)$。最后，将电荷网格除以单元体积 $V_{cell} = \\Delta x \\Delta y \\Delta z$ 以获得电荷密度。\n\n**3. 在谱空间中求解泊松方程**\n使用混合谱方法求解离散泊松方程。\n电荷密度网格 $\\rho(i, j, k')$（其中 $k' = k-1$ 是内部网格的索引，$k' \\in [0, N_z-3]$）按以下方式变换：\n- 沿 $x$ 和 $y$ 轴应用二维快速傅里叶变换（FFT）。\n- 沿 $z$ 轴应用一种特殊的离散正弦变换（DST）。问题暗示了一种基于内部点 $k=1, \\dots, N_z-2$ 的特征函数 $\\sin(\\frac{\\pi m k}{N_z-1})$ 的DST。这是一种特定类型的DST，我们通过与标准正交变换矩阵 $S_{mk} = \\sqrt{\\frac{2}{N_z-1}} \\sin(\\frac{\\pi m k}{N_z-1})$ 进行矩阵乘法来实现。\n\n变换后的密度 $\\widehat{\\rho}(p,q,m)$ 现在位于谱域。我们使用提供的公式构建拉普拉斯算子特征值网格 $\\lambda(p,q,m) = \\lambda_x(p) + \\lambda_y(q) + \\lambda_z(m)$：\n$$ \\lambda_x(p) = \\frac{2\\cos(2\\pi p/N_x) - 2}{\\Delta x^2}, \\quad p \\in [0, N_x-1] $$\n$$ \\lambda_y(q) = \\frac{2\\cos(2\\pi q/N_y) - 2}{\\Delta y^2}, \\quad q \\in [0, N_y-1] $$\n$$ \\lambda_z(m) = \\frac{2\\cos(\\pi m/(N_z-1)) - 2}{\\Delta z^2}, \\quad m \\in [1, N_z-2] $$\n然后通过代数除法找到变换后的电势 $\\Phi$：\n$$ \\Phi(p,q,m) = -\\frac{\\widehat{\\rho}(p,q,m)}{\\varepsilon_0 \\lambda(p,q,m)} $$\n由于 $\\lambda(p,q,m)  0$，此除法有明确定义。\n通过应用逆变换（逆DST，由于矩阵 $S$ 是对称且正交的，它与正向DST相同；以及二维逆FFT）恢复内部网格上的实空间电势 $\\phi(i,j,k')$。通过用零填充边界平面 $k=0$ 和 $k=N_z-1$ 来形成尺寸为 $N_x \\times N_y \\times N_z$ 的完整电势网格 $\\phi$，从而满足狄利克雷条件。\n\n**4. 电场计算**\n使用指定的有限差分计算完整网格上的电场 $\\mathbf{E} = -\\nabla\\phi$：\n- $E_x, E_y$：使用周期性边界条件的中心差分。例如，$E_x(i,j,k) = -(\\phi_{i+1,j,k} - \\phi_{i-1,j,k})/(2\\Delta x)$。\n- $E_z$：对于内部点 $k \\in [1, N_z-2]$ 使用中心差分，在边界 $k=0$ 和 $k=N_z-1$ 使用二阶单侧模板，这考虑了 $\\phi=0$ 的边界条件。\n$$ E_z(i,j,0) = -\\frac{4\\phi_{i,j,1} - \\phi_{i,j,2}}{2\\Delta z} $$\n$$ E_z(i,j,N_z-1) = -\\frac{-4\\phi_{i,j,N_z-2} + \\phi_{i,j,N_z-3}}{2\\Delta z} $$\n\n**5. 力插值**\n使用与电荷分配步骤中相同的CIC权重和 $z$ 方向夹紧逻辑，将电场 $\\mathbf{E}$ 从网格插值回每个粒子的位置 $\\mathbf{r}_\\ell$。这确保了一致性并保持动量守恒。粒子上的力即为 $\\mathbf{F}_\\ell = q_\\ell \\mathbf{E}(\\mathbf{r}_\\ell)$。\n\n**用例1：合理性检查**\n对于位于盒子精确中心 $(L_x/2, L_y/2, L_z/2)$ 的单个电荷，由于对称性，其受力必须为零。$x, y$ 方向的周期性镜像以及由 $z$ 方向导电板感应出的镜像电荷所施加的力将在该中心点完全抵消。实现必须重现此 $\\mathbf{F}=(0,0,0)$ 的结果，这是对代码正确性的关键验证。", "answer": "```python\nimport numpy as np\n\ndef format_to_sig_figs(value, sig_figs):\n    \"\"\"Formats a number to a specified number of significant figures.\"\"\"\n    if value == 0:\n        return '0.0'\n    \n    # Use 'g' format specifier which is designed for significant figures\n    # and handles scientific notation appropriately.\n    return f\"{value:.{sig_figs}g}\"\n\ndef solve():\n    \"\"\"\n    Main function to solve the PME problem for the given test cases.\n    \"\"\"\n    # Physical and numerical constants\n    EPS0 = 8.854187817e-12  # F/m\n    E_CHARGE = 1.602176634e-19  # C\n\n    # Common mesh and box parameters\n    NX, NY, NZ = 16, 16, 32\n    LX, LY, LZ = 4.0e-9, 4.0e-9, 4.0e-9\n\n    test_cases_defs = [\n        # Case 1: Symmetry check\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[LX / 2, LY / 2, LZ / 2]])},\n        # Case 2: Near-plate attraction\n        {\"charges\": [E_CHARGE], \"positions\": np.array([[0.7 * LX, 0.3 * LY, 0.5e-9]])},\n        # Case 3: Dipole across mid-plane\n        {\n            \"charges\": [E_CHARGE, -E_CHARGE],\n            \"positions\": np.array([\n                [LX / 2 - 0.3e-9, LY / 2, LZ / 2 + 0.4e-9],\n                [LX / 2 + 0.3e-9, LY / 2, LZ / 2 - 0.4e-9]\n            ]),\n        },\n        # Case 4: Two like charges near opposite plates\n        {\n            \"charges\": [E_CHARGE, E_CHARGE],\n            \"positions\": np.array([\n                [LX / 3, LY / 3, 0.6e-9],\n                [2 * LX / 3, 2 * LY / 3, LZ - 0.6e-9]\n            ]),\n        },\n    ]\n\n    all_forces = []\n\n    for case_def in test_cases_defs:\n        forces = compute_pme_forces(\n            case_def[\"charges\"],\n            case_def[\"positions\"],\n            (LX, LY, LZ),\n            (NX, NY, NZ),\n            EPS0,\n        )\n        all_forces.extend(forces.flatten())\n\n    # Format results to 6 significant figures\n    formatted_results = [format_to_sig_figs(f, 6) for f in all_forces]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef compute_pme_forces(charges, positions, L, N, eps0):\n    \"\"\"\n    Computes mesh-based electrostatic forces using the specified PME algorithm.\n    \"\"\"\n    LX, LY, LZ = L\n    NX, NY, NZ = N\n    \n    dx = LX / NX\n    dy = LY / NY\n    dz = LZ / (NZ - 1)\n    \n    # 1. Charge Assignment (CIC)\n    rho = np.zeros((NX, NY, NZ - 2))\n    \n    # Store weights for force interpolation\n    particle_weights = []\n\n    for idx, (q, pos) in enumerate(zip(charges, positions)):\n        weights_info = {}\n        # Fractional coordinates and base indices\n        ux, uy, uz = pos[0] / dx, pos[1] / dy, pos[2] / dz\n        \n        ix_base, iy_base, iz_base = int(np.floor(ux)), int(np.floor(uy)), int(np.floor(uz))\n        dx_frac, dy_frac, dz_frac = ux - ix_base, uy - iy_base, uz - iz_base\n        \n        weights_info['bases'] = (ix_base, iy_base, iz_base)\n        weights_info['fracs'] = (dx_frac, dy_frac, dz_frac)\n        \n        # Distribute charge to 8 nearest grid points\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Clamp z-index to interior planes [1, NZ-2]\n                    k_clamped = np.clip(k_physical, 1, NZ - 2)\n                    k_rho = k_clamped - 1 # Index for rho array\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    rho[i, j, k_rho] += q * wx * wy * wz\n\n        particle_weights.append(weights_info)\n\n    rho /= (dx * dy * dz)  # Convert to charge density\n\n    # 2. Solve Poisson Equation\n    # 2a. Fourier transform in x, y\n    rho_hat_xy = np.fft.fft2(rho, axes=(0, 1))\n\n    # 2b. Custom Discrete Sine Transform in z\n    N_interior = NZ - 2\n    S = np.zeros((N_interior, N_interior))\n    m_vals = np.arange(1, N_interior + 1)\n    k_vals = np.arange(1, N_interior + 1)\n    arg = np.pi * m_vals[:, None] * k_vals[None, :] / (NZ - 1)\n    S = np.sqrt(2.0 / (NZ - 1)) * np.sin(arg)\n\n    # Einstein summation for applying DST matrix to all (i,j) slices\n    rho_hat = np.einsum('ijk,lk->ijl', rho_hat_xy, S, optimize=True)\n\n    # 2c. Solve in spectral space\n    p = np.fft.fftfreq(NX) * NX\n    q = np.fft.fftfreq(NY) * NY\n    m = np.arange(1, NZ - 1)\n\n    lambda_x = (2 * np.cos(2 * np.pi * p / NX) - 2) / dx**2\n    lambda_y = (2 * np.cos(2 * np.pi * q / NY) - 2) / dy**2\n    lambda_z = (2 * np.cos(np.pi * m / (NZ - 1)) - 2) / dz**2\n\n    lambda_total = (lambda_x[:, None, None] + lambda_y[None, :, None] + lambda_z[None, None, :])\n    \n    phi_hat = np.zeros_like(rho_hat)\n    # Avoid division by zero by checking where lambda_total is non-zero.\n    # It's always non-zero in this problem.\n    non_zero_lambda = lambda_total != 0\n    phi_hat[non_zero_lambda] = -rho_hat[non_zero_lambda] / (eps0 * lambda_total[non_zero_lambda])\n\n    # 2d. Inverse transforms\n    # Inverse DST (S is its own inverse)\n    phi_xy = np.einsum('ijk,lk->ijl', phi_hat, S, optimize=True)\n    \n    # Inverse FFT\n    phi_interior = np.fft.ifft2(phi_xy, axes=(0, 1)).real\n    \n    phi = np.zeros((NX, NY, NZ))\n    phi[:, :, 1:-1] = phi_interior\n\n    # 3. Calculate Electric Field\n    Ex = - (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * dx)\n    Ey = - (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * dy)\n    \n    Ez = np.zeros_like(phi)\n    # Interior\n    Ez[:, :, 1:-1] = - (phi[:, :, 2:] - phi[:, :, :-2]) / (2 * dz)\n    # Boundaries (phi is 0 on boundaries)\n    Ez[:, :, 0] = - (4 * phi[:, :, 1] - phi[:, :, 2]) / (2 * dz)\n    Ez[:, :, -1] = - (-4 * phi[:, :, -2] + phi[:, :, -3]) / (2 * dz)\n\n    # 4. Interpolate Field and Calculate Force\n    forces = np.zeros((len(charges), 3))\n    for idx, (q, weights_info) in enumerate(zip(charges, particle_weights)):\n        # Retrieve weights and indices for this particle\n        ix_base, iy_base, iz_base = weights_info['bases']\n        dx_frac, dy_frac, dz_frac = weights_info['fracs']\n        \n        E_particle = np.zeros(3)\n        for di in range(2):\n            for dj in range(2):\n                for dk in range(2):\n                    i = (ix_base + di) % NX\n                    j = (iy_base + dj) % NY\n                    k_physical = iz_base + dk\n                    \n                    # Per instructions, clamping is to the interior planes for deposition.\n                    # \"the same clamping strategy in z\" for interpolation.\n                    k_interp_idx = np.clip(k_physical, 1, NZ-2)\n\n                    wx = (1 - dx_frac) if di == 0 else dx_frac\n                    wy = (1 - dy_frac) if dj == 0 else dy_frac\n                    wz = (1 - dz_frac) if dk == 0 else dz_frac\n                    \n                    weight = wx * wy * wz\n                    E_particle[0] += Ex[i, j, k_interp_idx] * weight\n                    E_particle[1] += Ey[i, j, k_interp_idx] * weight\n                    E_particle[2] += Ez[i, j, k_interp_idx] * weight\n        \n        forces[idx, :] = q * E_particle\n        \n    return forces\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2424449"}]}