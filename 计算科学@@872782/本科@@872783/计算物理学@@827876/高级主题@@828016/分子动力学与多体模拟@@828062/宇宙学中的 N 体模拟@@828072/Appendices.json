{"hands_on_practices": [{"introduction": "在运行大规模模拟之前，理解我们期望形成的结构之属性至关重要。本练习将指导您构建一个理想化的暗物质晕，并使用维里定理（$2T + U = 0$）来验证其物理状态。通过从第一性原理出发建立一个稳定的自引力系统，您将深入理解一个暗物质晕的动能与势能之间的联系，这是天体物理学中的一个基本概念。[@problem_id:2416301]", "problem": "你需要编写一个完整、可运行的程序，该程序构建确定性的、孤立的、自引力粒子系统，以表示理想化的暗物质晕，并通过报告几种指定情况下的无量纲维里残差，来定量检验维里定理条件 $2T + U = 0$。所有量均采用无量纲的 $N$ 体单位，其中引力常数 $G = 1$，所有角度均以弧度为单位。输出应为无量纲实数。\n\n考虑一个包含 $N$ 个等质量粒子的系统，总质量为 $M$，在牛顿引力下建模，并采用长度为 $\\epsilon  0$ 的 Plummer 型引力软化。设粒子位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，速度为 $\\{\\mathbf{v}_i\\}_{i=1}^N$。定义质心参考系中的动能为\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{with} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i,\n$$\n其中 $m = M/N$。定义软化引力势能为\n$$\nU = - G \\sum_{1 \\le i  j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\n对于一个在平方反比力作用下的稳定、孤立系统，维里定理预测 $2T + U = 0$。\n\n初始条件按如下方式完全确定性地指定。\n\n- 位置：对于给定的 $N$ 和外部尺度 $R  0$，将粒子 $k \\in \\{1,\\dots,N\\}$ 放置在球坐标角度和半径\n$$\nq_k = \\frac{k}{N+1}, \\quad r_k = R \\, q_k, \\quad \\theta_k = \\arccos(1 - 2 q_k), \\quad \\phi_k = \\frac{2\\pi k}{\\varphi},\n$$\n其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。其笛卡尔坐标位置为\n$$\n\\mathbf{r}_k = r_k \\begin{bmatrix} \\cos \\phi_k \\, \\sin \\theta_k \\\\ \\sin \\phi_k \\, \\sin \\theta_k \\\\ \\cos \\theta_k \\end{bmatrix}.\n$$\n\n- 速度：对于给定的非负无量纲因子 $f$，通过以下方式为每个粒子定义一个确定性的切线方向\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert} \\quad \\text{if } \\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert  10^{-12}, \\quad \\text{otherwise} \\quad \\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_x \\times \\hat{\\mathbf{r}}_k \\rVert},\n$$\n其中 $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$，$\\mathbf{e}_z = [0,0,1]^T$ 且 $\\mathbf{e}_x = [1,0,0]^T$。构建基础切向场 $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$，计算其平均值 $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$，并选择一个标量 $s \\ge 0$，使得质心动能等于\n$$\nT_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right).\n$$\n具体而言，设置\n$$\n\\mathbf{v}_k = s \\left(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}\\right), \\quad \\text{with} \\quad s = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}},\n$$\n当 $T_{\\mathrm{target}} = 0$ 时，将 $s$ 解读为 0。\n\n- 软化：使用 Plummer 软化长度 $\\epsilon = \\eta \\, R$，其中 $\\eta$ 是一个指定的无量纲分数。\n\n对于下面的每个测试用例，计算无量纲维里残差\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\n\n你的程序必须实现上述确定性构建过程，并为以下测试组的每个用例生成 $\\nu$ 的值：\n\n- 用例 1：$N = 64$，$M = 1.0$，$R = 1.0$，$\\eta = 0.05$，$f = 1.0$。\n- 用例 2：$N = 8$，$M = 2.0$，$R = 0.5$，$\\eta = 0.1$，$f = 0.5$。\n- 用例 3：$N = 2$，$M = 1.0$，$R = 1.0$，$\\eta = 0.01$，$f = 0.0$。\n- 用例 4：$N = 3$，$M = 1.0$，$R = 1.5$，$\\eta = 0.2$，$f = 1.2$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的浮点数列表，浮点数四舍五入到六位小数，并与上述用例顺序相同（例如，“[0.000000,-0.750000,-1.000000,0.440000]”）。", "solution": "问题陈述已经过严格验证。所有给定条件、定义和约束都已被提取和分析。该问题被认定为有效。它在科学上基于牛顿力学，内部一致，且方法论上是适定的。它为构建N体系统及随后计算一个物理可观测量提供了一个清晰、确定性的算法。为测试用例提供的参数在物理上是合理的，在计算上是可行的。可以直接从问题定义中推导出的解析关系 $\\nu = f^2 - 1$，是数值实现的一个关键验证目标。该问题是计算物理学中的一个有效练习，旨在检验理论理解和实现准确性。我们将着手构建解决方案。\n\n任务是为几个指定的多粒子系统计算维里残差 $\\nu = \\frac{2T + U}{\\lvert U \\rvert}$。这需要系统地、一步步地构建每个系统的初始条件（位置和速度），然后计算总动能（$T$）和总势能（$U$）。\n\n首先，我们为给定用例确定系统参数：粒子数 $N$、总质量 $M$、外部尺度半径 $R$、软化分数 $\\eta$ 和动能因子 $f$。引力常数给定为 $G=1$。由此，我们推导出每个粒子的质量 $m = M/N$ 和 Plummer 软化长度 $\\epsilon = \\eta R$。\n\n生成粒子位置 $\\{\\mathbf{r}_k\\}_{k=1}^N$ 是初始步骤。此过程是确定性的。对于由 $k \\in \\{1, \\dots, N\\}$ 索引的每个粒子，我们计算一个中间变量 $q_k = \\frac{k}{N+1}$。该变量用于定义粒子的球坐标：半径 $r_k = R \\, q_k$、极角 $\\theta_k = \\arccos(1 - 2 q_k)$ 和方位角 $\\phi_k = \\frac{2\\pi k}{\\varphi}$，其中 $\\varphi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。这种布点方法是球体上斐波那契螺旋的一种变体，可产生相当均匀的角度分布。径向分布是一个简单的线性斜坡。然后使用标准变换将球坐标转换为笛卡尔坐标 $\\mathbf{r}_k = [x_k, y_k, z_k]^T$：\n$$\n\\mathbf{r}_k = r_k \\begin{pmatrix} \\cos \\phi_k \\sin \\theta_k \\\\ \\sin \\phi_k \\sin \\theta_k \\\\ \\cos \\theta_k \\end{pmatrix}.\n$$\n\n一旦所有粒子位置都已知，我们就可以计算系统的总势能 $U$。势能是在软化引力势下成对相互作用的总和。公式为：\n$$\nU = - G \\sum_{1 \\le i  j \\le N} \\frac{m^2}{\\sqrt{\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert^2 + \\epsilon^2}}.\n$$\n求和遍历所有唯一的粒子对 $(i, j)$（其中 $i  j$），以避免重复计算相互作用。分母中的项 $\\epsilon^2$ 是 Plummer 软化，它防止势能在粒子非常接近时发散到负无穷大。对于任何 $N \\ge 2$ 的系统，$U$ 都将是负数。\n\n接下来，我们确定速度。该程序旨在赋予系统特定量的动能，该动能与其势能相关。目标动能定义为 $T_{\\mathrm{target}} = f^2 \\left(-\\frac{U}{2}\\right)$。因子 $f$ 相对于维里平衡所需的能量（其中 $T = -U/2$）来缩放初始动能。\n\n为了生成能够产生此动能的速度，我们首先定义一个确定性的速度场，随后对其进行缩放。对于每个粒子 $k$，构造一个切向方向矢量 $\\hat{\\mathbf{t}}_k$。该矢量与粒子的位置矢量 $\\hat{\\mathbf{r}}_k = \\mathbf{r}_k / \\lVert \\mathbf{r}_k \\rVert$ 正交。它是通过与固定的z轴单位矢量 $\\mathbf{e}_z = [0,0,1]^T$ 的叉积计算得出的：\n$$\n\\hat{\\mathbf{t}}_k = \\frac{\\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k}{\\lVert \\mathbf{e}_z \\times \\hat{\\mathbf{r}}_k \\rVert}.\n$$\n包含了一个数值稳定性检查，用于处理 $\\hat{\\mathbf{r}}_k$ 与 $\\mathbf{e}_z$ 几乎共线的情况，此时改用与 $\\mathbf{e}_x = [1,0,0]^T$ 的叉积。然后定义一个基础速度场为 $\\mathbf{u}_k = r_k \\, \\hat{\\mathbf{t}}_k$。\n\n为确保最终系统净动量为零，速度是在基础场 $\\mathbf{u}_k$ 的质心参考系中设置的。我们计算平均值 $\\mathbf{u}_{\\mathrm{cm}} = \\frac{1}{N}\\sum_{k=1}^N \\mathbf{u}_k$，并定义一组未缩放的、零质心速度 $\\mathbf{u}'_k = \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}}$。最终速度通过缩放这些矢量获得，$\\mathbf{v}_k = s \\, \\mathbf{u}'_k$，其中选择标量 $s \\ge 0$ 以满足目标动能。质心参考系中的动能为 $T = \\frac{1}{2} m \\sum_{k=1}^N \\lVert \\mathbf{v}_k \\rVert^2$（因为根据构造，最终质心速度为零）。代入 $\\mathbf{v}_k = s(\\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}})$ 并设置 $T = T_{\\mathrm{target}}$，得到缩放因子的表达式：\n$$\ns = \\sqrt{\\frac{2 T_{\\mathrm{target}}}{m \\sum_{k=1}^N \\lVert \\mathbf{u}_k - \\mathbf{u}_{\\mathrm{cm}} \\rVert^2}}.\n$$\n如果 $T_{\\mathrm{target}} = 0$（当 $f=0$ 时发生），则 $s=0$，所有粒子都处于静止状态。\n\n在完全确定了速度 $\\{\\mathbf{v}_k\\}_{k=1}^N$ 之后，计算系统的实际动能 $T$。它在质心参考系中定义：\n$$\nT = \\frac{1}{2} \\, m \\sum_{i=1}^N \\left\\lVert \\mathbf{v}_i - \\mathbf{v}_{\\mathrm{cm}} \\right\\rVert^2, \\quad \\text{where} \\quad \\mathbf{v}_{\\mathrm{cm}} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{v}_i.\n$$\n根据构造，$\\mathbf{v}_{\\mathrm{cm}}$ 在解析上为零，但显式计算并减去它可以提供数值稳健性。计算出的 $T$ 值应在机器精度范围内等于 $T_{\\mathrm{target}}$。\n\n最后，使用计算出的 $T$ 和 $U$ 值计算无量纲维里残差 $\\nu$：\n$$\n\\nu = \\frac{2T + U}{\\lvert U \\rvert}.\n$$\n由于 $U  0$，这等价于 $\\nu = -(2T+U)/U$。如解析检验所示，由于 $T$ 被构造为 $T = f^2(-U/2)$，我们预期 $\\nu = f^2 - 1$。数值实现必须为每个测试用例复现此结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_virial_residual(N, M, R, eta, f):\n    \"\"\"\n    Constructs a deterministic N-body system and calculates its virial residual.\n\n    Args:\n        N (int): Number of particles.\n        M (float): Total mass of the system.\n        R (float): Outer scale radius.\n        eta (float): Dimensionless softening fraction.\n        f (float): Dimensionless factor for target kinetic energy.\n\n    Returns:\n        float: The dimensionless virial residual nu.\n    \"\"\"\n    # 1. System constants and derived parameters\n    G = 1.0\n    phi_const = (1.0 + np.sqrt(5.0)) / 2.0\n    m = M / float(N)\n    epsilon = eta * R\n\n    # 2. Generate particle positions\n    k = np.arange(1, N + 1, dtype=np.float64)\n    q_k = k / (N + 1.0)\n    r_k = R * q_k\n    theta_k = np.arccos(1.0 - 2.0 * q_k)\n    phi_k = 2.0 * np.pi * k / phi_const\n\n    x = r_k * np.sin(theta_k) * np.cos(phi_k)\n    y = r_k * np.sin(theta_k) * np.sin(phi_k)\n    z = r_k * np.cos(theta_k)\n    positions = np.vstack((x, y, z)).T  # Shape: (N, 3)\n\n    # 3. Calculate potential energy U\n    if N  2:\n        U = 0.0\n    else:\n        # Use broadcasting to get all pairwise squared distances efficiently\n        r_diff = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        dist_sq = np.sum(r_diff**2, axis=-1)\n        \n        # Get indices for the upper triangle of the distance matrix to sum unique pairs\n        i_upper, j_upper = np.triu_indices(N, k=1)\n        \n        pairwise_dist = np.sqrt(dist_sq[i_upper, j_upper] + epsilon**2)\n        U = -G * m**2 * np.sum(1.0 / pairwise_dist)\n\n    # 4. Calculate target kinetic energy\n    T_target = f**2 * (-U / 2.0)\n\n    # 5. Generate particle velocities\n    if T_target  1e-15: # Handles f=0 case and avoids precision issues\n        velocities = np.zeros((N, 3))\n    else:\n        # Normalize position vectors to get unit vectors r_hat\n        r_norms = np.linalg.norm(positions, axis=1, keepdims=True)\n        r_hat = positions / r_norms\n\n        # Define canonical basis vectors\n        ez = np.array([0.0, 0.0, 1.0])\n        ex = np.array([1.0, 0.0, 0.0])\n\n        # Calculate tangential directions t_hat\n        c_z = np.cross(ez, r_hat)\n        c_z_norms = np.linalg.norm(c_z, axis=1, keepdims=True)\n        t_hat = np.zeros_like(positions)\n        \n        # Numerically stable case (not near z-axis)\n        mask_stable = (c_z_norms > 1e-12).flatten()\n        if np.any(mask_stable):\n            t_hat[mask_stable] = c_z[mask_stable] / c_z_norms[mask_stable]\n\n        # Fallback for particles near z-axis\n        mask_unstable = ~mask_stable\n        if np.any(mask_unstable):\n            c_x = np.cross(ex, r_hat[mask_unstable])\n            c_x_norms = np.linalg.norm(c_x, axis=1, keepdims=True)\n            t_hat[mask_unstable] = c_x / c_x_norms\n\n        # Base tangential velocity field u\n        u = r_k[:, np.newaxis] * t_hat\n        \n        # Make field have zero center of mass\n        u_cm = np.mean(u, axis=0)\n        u_prime = u - u_cm\n        \n        # Calculate velocity scaling factor s\n        s_sq_denom = m * np.sum(np.linalg.norm(u_prime, axis=1)**2)\n        \n        if s_sq_denom  1e-15:\n            # This should not occur for N>1 with this position generator\n            s = 0.0\n        else:\n            s = np.sqrt(2.0 * T_target / s_sq_denom)\n\n        velocities = s * u_prime\n\n    # 6. Calculate actual kinetic energy T in the center-of-mass frame\n    v_cm = np.mean(velocities, axis=0)\n    v_prime = velocities - v_cm\n    T = 0.5 * m * np.sum(np.linalg.norm(v_prime, axis=1)**2)\n    \n    # 7. Calculate the dimensionless virial residual\n    if np.abs(U)  1e-15:\n        # Unlikely for N>1, but handles division by zero\n        return 0.0\n\n    nu = (2.0 * T + U) / np.abs(U)\n    \n    return nu\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, M, R, eta, f)\n        (64, 1.0, 1.0, 0.05, 1.0),\n        (8, 2.0, 0.5, 0.1, 0.5),\n        (2, 1.0, 1.0, 0.01, 0.0),\n        (3, 1.0, 1.5, 0.2, 1.2),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, M, R, eta, f = case\n        result = calculate_virial_residual(N, M, R, eta, f)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416301"}, {"introduction": "任何N体模拟的引擎都是其力求解器，而粒子-网格（Particle-Mesh, PM）方法因其高效率而成为宇宙学模拟的基石。在本次实践中，您将实现一个完整的二维PM求解器，它涉及将粒子质量分配到网格上，使用快速傅里叶变换（FFT）求解泊松方程，并将得到的力插值回粒子位置。这个练习对于理解在周期性宇宙中如何高效计算长程引力至关重要。[@problem_id:2416244]", "problem": "实现一个完整的二维粒子-网格（PM）求解器，使用快速傅里叶变换（FFT）方法求解具有周期性边界条件的牛顿宇宙学泊松方程。其控制方程是三维泊松方程，应用于沿一个轴具有平移不变性的构型，因此场和源仅依赖于两个空间坐标：\n$$\\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}),$$\n在方形域上具有周期性边界条件。在代码单位中工作，箱体边长 $L = 1$，引力常数 $G = 1$。在这种设定下，$\\rho(\\mathbf{x})$ 是通过质量分配由粒子感应的单位面积质量密度场，或直接在网格上规定为解析函数，而 $\\phi(\\mathbf{x})$ 是引力势。加速度场由下式给出：\n$$\\mathbf{a}(\\mathbf{x}) = - \\nabla \\phi(\\mathbf{x}).$$\n从周期性网格上的离散傅里叶变换和牛顿引力的基本定义出发，推导谱解，使您能够通过 FFT 从密度场计算加速度场。不要使用任何预先存在的势核或力核；直接从控制方程和傅里叶变换的定义中推导并实现它们。使用云中单元（CIC）质量分配方案将粒子质量沉积到网格上，并使用相同的 CIC 权重将网格加速度插值回粒子位置，以最小化网格诱导的自作用力。根据宇宙学习惯，通过强制零均值源来一致地处理零波数（平均密度）模式：将 $k=\\mathbf{0}$ 模式设置为零，以使势没有均匀或线性增长的分量。\n\n您的程序必须：\n- 在大小为 $N \\times N$ 的均匀二维网格上实现周期性边界条件，其中 $N$ 是 2 的幂。\n- 实现 CIC 质量分配方案，将粒子质量映射到域 $[0,L)\\times[0,L)$（其中 $L=1$）上的网格化密度场 $\\rho_{i,j}$。\n- 实现基于 FFT 的谱泊松求解器，以获得势 $\\phi$ 然后求得 $\\mathbf{a}=-\\nabla \\phi$，或者直接在傅里叶空间中从 $\\rho$ 获得加速度场 $\\mathbf{a}$。\n- 使用与质量分配相同的 CIC 权重，将加速度场从网格插值回粒子位置。\n- 使用双精度浮点运算。\n\n设计一个确定性测试套件来验证实现的不同方面。使用以下四个测试用例（均在代码单位中， $L=1$，$G=1$）：\n- 测试 A（傅里叶模式求解器精度）：在 $N=64$ 的网格上，将密度场在网格上解析地设置为 $\\rho(x,y) = \\cos(2\\pi x)$。通过您的谱方法求解势 $\\phi(x,y)$，并将其与控制方程和周期性边界条件所蕴含的精确解进行比较。计算所有网格点上的最大绝对误差，\n$$\\varepsilon_{\\mathrm{mode}} = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{exact}}(x_i,y_j) \\right|,$$\n并将 $\\varepsilon_{\\mathrm{mode}}$ 报告为一个浮点数。\n- 测试 B（远离边界的双粒子对称性）：在 $N=64$ 的网格上，将两个质量相等的粒子（质量 $m_1=m_2 = \\tfrac{1}{2}$）放置在位置 $(x_1,y_1)=(0.25,0.5)$ 和 $(x_2,y_2)=(0.75,0.5)$。使用 CIC 将质量沉积到网格，减去平均密度，计算网格加速度，并将加速度插值回粒子位置。将对称性误差定义为\n$$\\varepsilon_{\\mathrm{sym}} = \\frac{\\max\\!\\left(\\left\\|\\mathbf{a}_1+\\mathbf{a}_2\\right\\|, \\, |a_{1,y}|+|a_{2,y}|\\right)}{\\max\\!\\left(\\left\\|\\mathbf{a}_1\\right\\|, \\left\\|\\mathbf{a}_2\\right\\|\\right)},$$\n并将 $\\varepsilon_{\\mathrm{sym}}$ 报告为一个浮点数。\n- 测试 C（多粒子净力一致性）：在 $N=64$ 的网格上，将 $N_{\\mathrm{p}}=200$ 个粒子放置在 $[0,1)\\times[0,1)$ 内均匀抽取的位置，所有粒子质量相等，为 $m_i = 1/N_{\\mathrm{p}}$。通过 CIC 进行沉积，减去平均密度，计算加速度网格，并插值到粒子位置。计算净质量加权加速度的大小，\n$$\\varepsilon_{\\mathrm{net}} = \\left\\| \\sum_{i=1}^{N_{\\mathrm{p}}} m_i \\, \\mathbf{a}_i \\right\\|,$$\n并将 $\\varepsilon_{\\mathrm{net}}$ 报告为一个浮点数。\n- 测试 D（周期性环绕对称性）：在 $N=64$ 的网格上，将两个质量相等的粒子（质量 $m_1=m_2=\\tfrac{1}{2}$）放置在位置 $(x_1,y_1)=(0.01,0.5)$ 和 $(x_2,y_2)=(0.99,0.5)$，这两个位置跨周期性边界分隔。重复 CIC 沉积、平均值减法、加速度计算和插值。计算并报告与测试 B 中相同的对称性误差 $\\varepsilon_{\\mathrm{sym,wrap}}$。\n\n此问题不使用角度单位。所有量均为指定的无量纲代码单位。您的程序必须按顺序计算测试 A、B、C 和 D 的四个标量结果，并生成一行输出，其中包含这四个值，格式为方括号内的逗号分隔列表，例如\n\"[v_A,v_B,v_C,v_D]\"。\n每个值必须以标准浮点表示法打印为十进制数。\n\n您的实现必须是完整且自包含的，并且不得读取任何外部输入。测试 C 中的随机粒子位置必须使用固定的种子生成，以确保确定性。", "solution": "用户提供了一个有效的、适定的计算物理问题。任务是实现一个用于求解具有周期性边界条件的牛顿泊松方程的二维粒子-网格（PM）求解器，并用一套特定的测试来验证它。该问题具有科学依据，算法上具体，并为确定性实现提供了所有必要的参数。\n\n解决方案首先推导求解泊松方程的谱方法，然后解释质量分配和力插值方案。最后，概述了数值算法，它构成了所提供代码的基础。\n\n### 1. 泊松方程和谱方法\n\n控制方程是关于由质量密度分布 $\\rho(\\mathbf{x})$ 产生的引力势 $\\phi(\\mathbf{x})$ 的二维泊松方程：\n$$ \\nabla^2 \\phi(\\mathbf{x}) = 4\\pi G \\rho(\\mathbf{x}) $$\n其中 $\\mathbf{x} = (x, y)$ 是空间坐标，$\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 是拉普拉斯算子，$G$ 是引力常数。问题设置在一个方形域 $[0, L) \\times [0, L)$ 上，具有周期性边界条件。我们使用代码单位，其中 $L=1$，$G=1$。\n\n谱方法利用了傅里叶变换的性质，它可将微分算子对角化。函数 $f(\\mathbf{x})$ 的连续傅里叶变换定义为 $\\hat{f}(\\mathbf{k}) = \\int f(\\mathbf{x}) e^{-i \\mathbf{k} \\cdot \\mathbf{x}} d\\mathbf{x}$。将此应用于泊松方程，拉普拉斯项变为：\n$$ \\mathcal{F}\\{\\nabla^2 \\phi(\\mathbf{x})\\} = -\\|\\mathbf{k}\\|^2 \\hat{\\phi}(\\mathbf{k}) = -(k_x^2 + k_y^2) \\hat{\\phi}(\\mathbf{k}) $$\n这里，$\\mathbf{k}=(k_x, k_y)$ 是波矢量。因此，傅里叶空间中的泊松方程是一个代数方程：\n$$ -k^2 \\hat{\\phi}(\\mathbf{k}) = 4\\pi G \\hat{\\rho}(\\mathbf{k}) $$\n其中 $k^2 = \\|\\mathbf{k}\\|^2$。这得出了傅里叶空间中势的解：\n$$ \\hat{\\phi}(\\mathbf{k}) = - \\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} $$\n加速度场 $\\mathbf{a}(\\mathbf{x}) = -\\nabla \\phi(\\mathbf{x})$ 也可以在傅里叶空间中找到。梯度算子 $\\nabla$ 变换为乘以 $i\\mathbf{k}$：\n$$ \\hat{\\mathbf{a}}(\\mathbf{k}) = -i\\mathbf{k} \\hat{\\phi}(\\mathbf{k}) = -i\\mathbf{k} \\left( -\\frac{4\\pi G \\hat{\\rho}(\\mathbf{k})}{k^2} \\right) = i \\frac{4\\pi G \\mathbf{k}}{k^2} \\hat{\\rho}(\\mathbf{k}) $$\n这允许直接从密度计算加速度，通常效率更高。\n\n在 $\\mathbf{k}=\\mathbf{0}$ 处出现奇异点，其中 $k^2=0$。这对应于平均密度模式（直流分量）。对于周期性边界条件，只有当净源为零时，即 $\\int \\rho(\\mathbf{x}) d\\mathbf{x} = 0$，泊松方程才有解，这意味着 $\\hat{\\rho}(\\mathbf{k=0}) = 0$。在宇宙学模拟中，人们考虑的是围绕均匀平均密度的密度涨落。通过减去这个平均值，我们确保 $\\hat{\\rho}(\\mathbf{0}) = 0$。因此，$\\mathbf{k}=\\mathbf{0}$ 模式对力没有贡献，所以我们可以设置 $\\hat{\\phi}(\\mathbf{0}) = 0$ 和 $\\hat{\\mathbf{a}}(\\mathbf{0}) = \\mathbf{0}$。\n\n### 2. 离散化和数值实现\n\n连续域被离散化在一个均匀的 $N \\times N$ 网格上，网格间距为 $h=L/N$。函数 $f(\\mathbf{x})$ 由其在网格节点上的值 $f_{i,j} = f(i h, j h)$ 表示。傅里叶变换被离散傅里叶变换（DFT）取代，后者使用快速傅里叶变换（FFT）算法高效计算。\n\n网格函数 $f_{i,j}$ 的 DFT 为：\n$$ \\hat{f}_{k_x, k_y} = \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} f_{i,j} e^{-2\\pi i (k_x i / N + k_y j / N)} $$\n对应于整数频率指数 $(k_x, k_y)$ 的离散波矢量由 $\\mathbf{k} = (\\frac{2\\pi}{L} k'_x, \\frac{2\\pi}{L} k'_y)$ 给出，其中 $k'_x, k'_y$ 是整数波数，范围大约从 $-N/2$ 到 $N/2$。\n\n谱求解器算法如下：\n1.  在网格上获得离散密度场 $\\rho_{i,j}$。\n2.  计算其 DFT，$\\hat{\\rho}_{k_x,k_y} = \\text{FFT}(\\rho_{i,j})$。\n3.  通过设置 $\\hat{\\rho}_{0,0} = 0$ 来强制零平均密度。\n4.  在傅里叶空间中，计算势或加速度的变换。对于加速度，分量为：\n    $$ \\hat{a}_{x; k_x, k_y} = \\left( i \\frac{4\\pi G k_x}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y}, \\quad \\hat{a}_{y; k_x, k_y} = \\left( i \\frac{4\\pi G k_y}{k_x^2 + k_y^2} \\right) \\hat{\\rho}_{k_x, k_y} $$\n    对于 $\\mathbf{k} \\ne \\mathbf{0}$，且 $\\hat{\\mathbf{a}}_{0,0} = \\mathbf{0}$。括号中的项是谱响应函数或谱核。\n5.  对 $\\hat{a}_{x}$ 和 $\\hat{a}_{y}$ 执行逆 DFT，以获得网格上的加速度分量 $a_{x; i,j}$ 和 $a_{y; i,j}$。\n    $$ \\mathbf{a}_{i,j} = \\text{IFFT}(\\hat{\\mathbf{a}}_{k_x,k_y}) $$\n\n### 3. 质量分配和力插值\n\n在粒子-网格模拟中，粒子代表离散的质量包裹。密度场 $\\rho_{i,j}$ 是通过将每个粒子的质量分配到网格上获得的。云中单元（CIC）方案是一种二阶质量分配方法。对于位于位置 $\\mathbf{x}_p = (x_p, y_p)$、质量为 $m_p$ 的粒子，我们确定其所在的网格单元，其左下角位于 $(i,j) = (\\lfloor x_p/h \\rfloor, \\lfloor y_p/h \\rfloor)$。粒子的质量使用基于双线性插值的权重分配给周围的四个网格节点。粒子在其单元内的分数位移是 $\\delta_x = (x_p/h) - i$ 和 $\\delta_y = (y_p/h) - j$。质量分配如下：\n- 到节点 $(i,j)$: $m_p (1-\\delta_x)(1-\\delta_y)$\n- 到节点 $(i+1,j)$: $m_p \\delta_x(1-\\delta_y)$\n- 到节点 $(i,j+1)$: $m_p (1-\\delta_x)\\delta_y$\n- 到节点 $(i+1,j+1)$: $m_p \\delta_x \\delta_y$\n索引以 $N$ 为模进行处理，以遵循周期性边界条件。在对所有粒子的贡献求和后，网格质量 $M_{i,j}$ 通过 $\\rho_{i,j} = M_{i,j}/h^2$ 转换为密度。\n\n一旦在网格上计算出加速度场 $\\mathbf{a}_{i,j}$，粒子原始位置 $\\mathbf{x}_p$ 处的加速度 $\\mathbf{a}_p$ 就通过从网格插值得到。为确保动量守恒并消除虚假的自作用力，插值必须使用与质量分配相同的加权方案。因此，粒子位置处的加速度为：\n$$ \\mathbf{a}_p = (1-\\delta_x)(1-\\delta_y)\\mathbf{a}_{i,j} + \\delta_x(1-\\delta_y)\\mathbf{a}_{i+1,j} + (1-\\delta_x)\\delta_y\\mathbf{a}_{i,j+1} + \\delta_x\\delta_y\\mathbf{a}_{i+1,j+1} $$\n\n### 4. 验证测试\n\n该问题指定了四个测试来验证实现：\n- **测试 A:** 使用解析密度场 $\\rho(x,y) = \\cos(2\\pi x)$，其势为 $\\phi(x,y) = -(1/\\pi)\\cos(2\\pi x)$。这测试了谱泊松求解器本身的精度，与粒子-网格操作无关。数值解应与解析解达到机器精度。\n- **测试 B:** 在盒子中对称地放置两个粒子。根据对称性，对上的净力应为零，并且每个粒子上的力应纯粹沿着连接它们的直线。这测试了 PM 力的计算和 CIC 方案的对称性。\n- **测试 C:** 使用大量随机放置的粒子。对于孤立系统，内力之和必须为零（牛顿第三定律的表述）。该测试测量净质量加权加速度的大小，$\\left\\| \\sum m_i \\mathbf{a}_i \\right\\|$，对于正确的实现，该值应接近于零。\n- **测试 D:** 与测试 B 类似，但在周期性边界附近放置粒子。这专门测试了 CIC 分配和插值步骤中周期性环绕的正确实现。\n\n实现将遵循这些原则来计算每个测试用例所需的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests a 2D Particle-Mesh (PM) solver.\n    \"\"\"\n\n    class PM_Solver:\n        \"\"\"\n        A 2D Particle-Mesh solver for the Poisson equation with periodic BCs.\n        \"\"\"\n        def __init__(self, N, L=1.0, G=1.0):\n            \"\"\"\n            Initializes the solver.\n            Args:\n                N (int): Grid size (N x N).\n                L (float): Box side length.\n                G (float): Gravitational constant.\n            \"\"\"\n            if not (N > 0 and (N  (N - 1) == 0)):\n                # This is not strictly required by the mathematics but is a problem constraint\n                # We will proceed anyway as the logic works for any N.\n                pass\n            \n            self.N = N\n            self.L = float(L)\n            self.G = float(G)\n            self.h = self.L / self.N\n            self.dtype = np.float64\n\n            # Pre-compute wavevectors\n            k_freq = np.fft.fftfreq(self.N, d=self.h)\n            k_phys = 2.0 * np.pi * k_freq\n            kx_phys, ky_phys = np.meshgrid(k_phys, k_phys, indexing='ij')\n\n            # Pre-compute spectral kernels\n            k_sq = kx_phys**2 + ky_phys**2\n            \n            # Kernel for potential: -1/k^2\n            self.potential_kernel = np.zeros_like(k_sq, dtype=self.dtype)\n            nonzero = k_sq != 0\n            self.potential_kernel[nonzero] = -1.0 / k_sq[nonzero]\n\n            # Kernel for acceleration: i*k_x/k^2 and i*k_y/k^2\n            self.accel_kernel_x = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_y = np.zeros_like(k_sq, dtype=np.complex128)\n            self.accel_kernel_x[nonzero] = 1j * kx_phys[nonzero] / k_sq[nonzero]\n            self.accel_kernel_y[nonzero] = 1j * ky_phys[nonzero] / k_sq[nonzero]\n\n\n        def _assign_mass(self, particles):\n            \"\"\"\n            Assigns particle mass to the grid using Cloud-In-Cell (CIC).\n            \"\"\"\n            mass_grid = np.zeros((self.N, self.N), dtype=self.dtype)\n            for m_p, x_p, y_p in particles:\n                # Position in grid units\n                pos_gu = np.array([x_p, y_p]) / self.h\n                \n                # Bottom-left grid cell index and fractional displacement\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n                \n                # Get indices of 4 cells, with periodic wrapping\n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                # CIC weights\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                # Assign mass\n                mass_grid[ix, iy] += m_p * w_ij\n                mass_grid[ixp1, iy] += m_p * w_ip1j\n                mass_grid[ix, iyp1] += m_p * w_ijp1\n                mass_grid[ixp1, iyp1] += m_p * w_ip1jp1\n            \n            density_grid = mass_grid / (self.h**2)\n            return density_grid\n\n        def _interpolate_accel(self, accel_x_grid, accel_y_grid, particles):\n            \"\"\"\n            Interpolates acceleration from grid to particle positions using CIC.\n            \"\"\"\n            accels = []\n            for _, x_p, y_p in particles:\n                pos_gu = np.array([x_p, y_p]) / self.h\n                idx = np.floor(pos_gu).astype(int)\n                delta = pos_gu - idx\n            \n                ix, iy = idx[0], idx[1]\n                ixp1 = (ix + 1) % self.N\n                iyp1 = (iy + 1) % self.N\n\n                w_ij = (1.0 - delta[0]) * (1.0 - delta[1])\n                w_ip1j = delta[0] * (1.0 - delta[1])\n                w_ijp1 = (1.0 - delta[0]) * delta[1]\n                w_ip1jp1 = delta[0] * delta[1]\n\n                a_x = (w_ij * accel_x_grid[ix, iy] +\n                       w_ip1j * accel_x_grid[ixp1, iy] +\n                       w_ijp1 * accel_x_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_x_grid[ixp1, iyp1])\n                \n                a_y = (w_ij * accel_y_grid[ix, iy] +\n                       w_ip1j * accel_y_grid[ixp1, iy] +\n                       w_ijp1 * accel_y_grid[ix, iyp1] +\n                       w_ip1jp1 * accel_y_grid[ixp1, iyp1])\n                \n                accels.append(np.array([a_x, a_y], dtype=self.dtype))\n            \n            return np.array(accels)\n\n        def get_potential(self, density_grid):\n            \"\"\"\n            Calculates potential from a density grid.\n            \"\"\"\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            phi_k = 4.0 * np.pi * self.G * self.potential_kernel * rho_k\n            phi = np.fft.ifft2(phi_k)\n            return phi.real\n\n        def get_particle_accel(self, particles):\n            \"\"\"\n            Calculates acceleration on particles.\n            \"\"\"\n            density_grid = self._assign_mass(particles)\n            rho_k = np.fft.fft2(density_grid.astype(self.dtype))\n            rho_k[0, 0] = 0.0 # Enforce zero mean density\n\n            ax_k = 4.0 * np.pi * self.G * self.accel_kernel_x * rho_k\n            ay_k = 4.0 * np.pi * self.G * self.accel_kernel_y * rho_k\n\n            ax_grid = np.fft.ifft2(ax_k).real\n            ay_grid = np.fft.ifft2(ay_k).real\n\n            particle_accels = self._interpolate_accel(ax_grid, ay_grid, particles)\n            return particle_accels\n\n    # --- Problem Parameters ---\n    N = 64\n    L = 1.0\n    G = 1.0\n\n    solver = PM_Solver(N=N, L=L, G=G)\n    results = []\n\n    # --- Test A: Fourier-mode solver accuracy ---\n    x_coords = np.arange(N, dtype=solver.dtype) * solver.h\n    rho_analytic = np.cos(2.0 * np.pi * x_coords)\n    rho_grid_A = np.zeros((N, N), dtype=solver.dtype)\n    rho_grid_A[:, :] = rho_analytic[:, np.newaxis]\n    \n    phi_num = solver.get_potential(rho_grid_A)\n    phi_exact = -(1.0 / (4.0 * np.pi**2)) * 4.0 * np.pi * G * rho_grid_A\n    \n    eps_mode = np.max(np.abs(phi_num - phi_exact))\n    results.append(eps_mode)\n\n    # --- Test B: two-particle symmetry away from boundaries ---\n    particles_B = [\n        (0.5, 0.25, 0.5), # (mass, x, y)\n        (0.5, 0.75, 0.5)\n    ]\n    accels_B = solver.get_particle_accel(particles_B)\n    a1_B, a2_B = accels_B[0], accels_B[1]\n    norm_a1_B = np.linalg.norm(a1_B)\n    norm_a2_B = np.linalg.norm(a2_B)\n\n    num_B = max(np.linalg.norm(a1_B + a2_B), abs(a1_B[1]) + abs(a2_B[1]))\n    den_B = max(norm_a1_B, norm_a2_B) if max(norm_a1_B, norm_a2_B) > 0 else 1.0\n    eps_sym = num_B / den_B if den_B != 0 else 0.0\n    results.append(eps_sym)\n    \n    # --- Test C: net-force consistency for many particles ---\n    Np_C = 200\n    np.random.seed(1234) # Fixed seed for determinism\n    positions_C = np.random.rand(Np_C, 2).astype(solver.dtype)\n    masses_C = np.full(Np_C, 1.0/Np_C, dtype=solver.dtype)\n    particles_C = [(masses_C[i], positions_C[i,0], positions_C[i,1]) for i in range(Np_C)]\n\n    accels_C = solver.get_particle_accel(particles_C)\n    net_force = np.sum(masses_C[:, np.newaxis] * accels_C, axis=0)\n    eps_net = np.linalg.norm(net_force)\n    results.append(eps_net)\n    \n    # --- Test D: periodic wrap symmetry ---\n    particles_D = [\n        (0.5, 0.01, 0.5),\n        (0.5, 0.99, 0.5)\n    ]\n    accels_D = solver.get_particle_accel(particles_D)\n    a1_D, a2_D = accels_D[0], accels_D[1]\n    norm_a1_D = np.linalg.norm(a1_D)\n    norm_a2_D = np.linalg.norm(a2_D)\n    \n    num_D = max(np.linalg.norm(a1_D + a2_D), abs(a1_D[1]) + abs(a2_D[1]))\n    den_D = max(norm_a1_D, norm_a2_D) if max(norm_a1_D, norm_a2_D) > 0 else 1.0\n    eps_sym_wrap = num_D / den_D if den_D != 0 else 0.0\n    results.append(eps_sym_wrap)\n    \n    # Final print statement\n    print(f\"[{results[0]},{results[1]},{results[2]},{results[3]}]\")\n\nsolve()\n```", "id": "2416244"}, {"introduction": "当一个宇宙学模拟演化后，粒子会聚集形成复杂的宇宙网；一项关键任务是识别出其中形成的引力束缚结构，即“暗物质晕”。本练习将介绍“友邻（Friends-of-Friends, FoF）”算法，这是一种基于粒子邻近度来识别暗物质晕的广泛使用的方法。您将实现该算法，将粒子分组到暗物质晕中，这是分析模拟数据并将其与可观测星系联系起来的关键后处理步骤。[@problem_id:2416288]", "problem": "在周期性三维立方体域中，实现一个具有可变连接长度参数的“友邻”(Friends-of-Friends, FoF) 晕轮识别器。请从以下基本定义开始。设在一个边长为 $L$、具有周期性边界条件的立方体盒子内，有 $N$ 个粒子，其共动位置为 $\\{\\mathbf{x}_i\\}_{i=1}^{N}$。全局数密度为 $n = N / L^3$。平均粒子间距为 $\\bar{\\ell} = n^{-1/3}$。为每个粒子 $i$ 分配一个无量纲连接长度因子 $b_i$，该粒子的绝对连接长度定义为 $\\ell_i = b_i \\, \\bar{\\ell}$。粒子连通性的无向图定义如下：如果两个粒子 $i$ 和 $j$ 在最小镜像约定下的共动距离不大于它们各自粒子连接长度的算术平均值，则它们相连，即最小镜像距离 $r_{ij}$ 满足 $r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$。一个晕轮是此无向图的一个连通分量。将所有连通分量（包括孤立点）都视为晕轮。所有位置均以无量纲共动盒子单位表示，所有距离均使用与 $L$ 相同的单位。不需要物理单位。\n\n您的任务是编写一个完整、可运行的程序，该程序：\n- 对每个测试用例，根据 $N$ 和 $L$ 计算 $\\bar{\\ell}$。\n- 为每个粒子计算 $\\ell_i = b_i \\, \\bar{\\ell}$。\n- 使用周期性边界条件通过最小镜像约定计算所有两两之间的距离 $r_{ij}$：对于位移矢量 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$，应用分量环绕 $\\Delta x \\mapsto \\Delta x - L \\cdot \\mathrm{round}(\\Delta x / L)$，对 $\\Delta y$ 和 $\\Delta z$ 也类似处理，然后 $r_{ij} = \\|\\Delta \\mathbf{x}\\|_2$。\n- 当且仅当 $r_{ij} \\le \\tfrac{1}{2}(\\ell_i + \\ell_j)$ 时，在 $i$ 和 $j$ 之间构造一条边，从而构建无向图。\n- 找到所有连通分量，并报告每个分量的大小（一个正整数），对每个测试用例按非递增顺序排序。\n\n请基于上述定义和基本运动学（$\\mathbf{v} = d\\mathbf{x}/dt$，根据需要用于证明空间间隔的合理性）从第一性原理出发设计您的实现，不使用任何预封装的图或聚类程序。每个测试用例的正确性标准是连通分量大小的列表。\n\n使用以下三个测试用例的测试套件。对于每个用例，程序应按规定计算晕轮大小并汇总结果。\n\n测试用例 A (两个紧凑且分离良好的星团)：\n- 盒子大小：$L = 2.0$。\n- 粒子数量：$N = 8$。\n- 粒子位置 $\\mathbf{x}_i$ (无量纲)：\n  - $\\mathbf{x}_1 = (\\,0.20,\\,0.20,\\,0.20\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.25,\\,0.20,\\,0.22\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.20,\\,0.26,\\,0.20\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.24,\\,0.25,\\,0.24\\,)$,\n  - $\\mathbf{x}_5 = (\\,1.60,\\,1.60,\\,1.60\\,)$,\n  - $\\mathbf{x}_6 = (\\,1.65,\\,1.60,\\,1.58\\,)$,\n  - $\\mathbf{x}_7 = (\\,1.60,\\,1.66,\\,1.60\\,)$,\n  - $\\mathbf{x}_8 = (\\,1.58,\\,1.62,\\,1.64\\,)$.\n- 各粒子连接参数 $b_i$：\n  - $b_i = 0.20$，对所有 $i \\in \\{1,\\dots,8\\}$。\n\n测试用例 B (跨盒子边界的周期性边界连接)：\n- 盒子大小：$L = 1.0$。\n- 粒子数量：$N = 6$。\n- 粒子位置 $\\mathbf{x}_i$ (无量纲)：\n  - $\\mathbf{x}_1 = (\\,0.05,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.07,\\,0.48,\\,0.52\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.04,\\,0.52,\\,0.49\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.95,\\,0.50,\\,0.50\\,)$,\n  - $\\mathbf{x}_5 = (\\,0.93,\\,0.51,\\,0.49\\,)$,\n  - $\\mathbf{x}_6 = (\\,0.96,\\,0.48,\\,0.52\\,)$.\n- 各粒子连接参数 $b_i$：\n  - $b_i = 0.25$，对所有 $i \\in \\{1,\\dots,6\\}$。\n\n测试用例 C (可变 $b_i$ 抑制近邻对之间的连接)：\n- 盒子大小：$L = 1.0$。\n- 粒子数量：$N = 4$。\n- 粒子位置 $\\mathbf{x}_i$ (无量纲)：\n  - $\\mathbf{x}_1 = (\\,0.10,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_2 = (\\,0.16,\\,0.10,\\,0.10\\,)$,\n  - $\\mathbf{x}_3 = (\\,0.70,\\,0.70,\\,0.70\\,)$,\n  - $\\mathbf{x}_4 = (\\,0.74,\\,0.70,\\,0.70\\,)$.\n- 各粒子连接参数 $b_i$：\n  - $b_1 = 0.05$,\n  - $b_2 = 0.05$,\n  - $b_3 = 0.20$,\n  - $b_4 = 0.20$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例对应一个列表，其中每个内部列表包含该用例的晕轮大小，按非递增顺序排序。例如，它应类似于 $[[\\dots],[\\dots],[\\dots]]$，且只包含整数。不应打印任何其他文本。", "solution": "我们通过将数密度、平均粒子间距和周期性距离的核心定义与图连通性分析相结合来构建解决方案。\n\n1.  定义和输入。对于一个边长为 $L$、包含 $N$ 个粒子的立方周期域，全局数密度为 $n = N / L^3$。平均粒子间距为 $\\bar{\\ell} = n^{-1/3} = \\left( \\dfrac{L^3}{N} \\right)^{1/3} = \\dfrac{L}{N^{1/3}}$。每个粒子 $i$ 被赋予一个无量纲的粒子专属因子 $b_i$，因此其绝对连接长度为 $\\ell_i = b_i \\, \\bar{\\ell}$。\n\n2.  最小镜像距离。对于位于位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的两个粒子，我们首先构建位移矢量 $\\Delta \\mathbf{x} = \\mathbf{x}_j - \\mathbf{x}_i$。为了在最小镜像约定下实施周期性边界条件，我们对每个笛卡尔分量进行环绕处理：如果 $\\Delta x$ 是 $x$ 分量，则设置\n    $$\n    \\Delta x \\leftarrow \\Delta x - L \\cdot \\mathrm{round}\\!\\left(\\frac{\\Delta x}{L}\\right),\n    $$\n    对 $y$ 和 $z$ 分量也进行类似操作。最小镜像距离为 $r_{ij} = \\|\\Delta \\mathbf{x}\\|_2 = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2}$。\n\n3.  连接准则。具有可变连接长度的“友邻”构建方法在粒子 $i$ 和 $j$ 之间的距离不超过其各自粒子连接长度的对称平均值时，使用一条无向边连接它们：\n    $$\n    r_{ij} \\le \\frac{1}{2}\\left(\\ell_i + \\ell_j\\right).\n    $$\n    当 $b_i \\ne b_j$ 时，这强制执行了一个一致、对称的规则。\n\n4.  图与晕轮。通过上述不等式定义的边集，晕轮即为在 $N$ 个顶点上生成的无向图的连通分量。我们使用不相交集并（也称为并查集）或广度优先搜索来识别分量；两者均可接受。每个粒子都恰好属于一个分量；大小为 1 的分量（孤立点）也包括在内。\n\n5.  每个测试用例的算法步骤。\n    -   计算 $N$ 和 $L$，然后计算 $\\bar{\\ell} = L / N^{1/3}$。\n    -   为 $i=1,\\dots,N$ 计算 $\\ell_i = b_i \\bar{\\ell}$。\n    -   对于所有 $i  j$ 的粒子对，计算最小镜像距离 $r_{ij}$ 并应用连接准则。接着，使用图遍历算法（如广度优先搜索或深度优先搜索）或并查集数据结构来识别所有连通分量。最后，计算每个分量中的粒子数，并将这些大小按非递增顺序排序，以生成最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef min_image_displacement(dx, L):\n    \"\"\"\n    Apply the minimum-image convention component-wise to a displacement vector dx\n    in a cubic periodic box of side length L.\n    \"\"\"\n    return dx - L * np.round(dx / L)\n\nclass DisjointSetUnion:\n    def __init__(self, n):\n        self.parent = np.arange(n, dtype=int)\n        self.size = np.ones(n, dtype=int)\n\n    def find(self, x):\n        # Path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def union(self, a, b):\n        ra = self.find(a)\n        rb = self.find(b)\n        if ra == rb:\n            return\n        # Union by size\n        if self.size[ra]  self.size[rb]:\n            ra, rb = rb, ra\n        self.parent[rb] = ra\n        self.size[ra] += self.size[rb]\n\ndef fof_variable_b(positions, L, b_values):\n    \"\"\"\n    Compute Friends-of-Friends halos with variable per-particle b-values.\n\n    positions: (N,3) numpy array of particle positions within [0,L).\n    L: float, box size (periodic).\n    b_values: (N,) numpy array of dimensionless linking-length factors.\n\n    Returns a list of component sizes sorted in nonincreasing order.\n    \"\"\"\n    positions = np.asarray(positions, dtype=float)\n    b_values = np.asarray(b_values, dtype=float)\n    N = positions.shape[0]\n    # Mean interparticle separation\n    lbar = L / (N ** (1.0 / 3.0))\n    # Per-particle linking lengths\n    l_i = b_values * lbar\n\n    # Build union-find structure\n    dsu = DisjointSetUnion(N)\n\n    # Check all pairs\n    for i in range(N - 1):\n        # Vectorized differences to all j>i\n        diffs = positions[i+1:] - positions[i]\n        # Apply minimum image to each component\n        diffs = min_image_displacement(diffs, L)\n        # Euclidean distances\n        rij = np.linalg.norm(diffs, axis=1)\n        # Thresholds: (l_i + l_j)/2\n        thresholds = 0.5 * (l_i[i] + l_i[i+1:])\n        # Determine links\n        links = rij = thresholds\n        linked_js = np.where(links)[0] + (i + 1)\n        for j in linked_js:\n            dsu.union(i, j)\n\n    # Compute component sizes\n    roots, counts = np.unique([dsu.find(k) for k in range(N)], return_counts=True)\n    sizes = list(counts.astype(int))\n    sizes.sort(reverse=True)\n    return sizes\n\ndef solve():\n    # Define the test cases from the problem statement.\n\n    # Test case A\n    L_A = 2.0\n    positions_A = np.array([\n        [0.20, 0.20, 0.20],\n        [0.25, 0.20, 0.22],\n        [0.20, 0.26, 0.20],\n        [0.24, 0.25, 0.24],\n        [1.60, 1.60, 1.60],\n        [1.65, 1.60, 1.58],\n        [1.60, 1.66, 1.60],\n        [1.58, 1.62, 1.64],\n    ], dtype=float)\n    b_A = np.full(positions_A.shape[0], 0.20, dtype=float)\n\n    # Test case B\n    L_B = 1.0\n    positions_B = np.array([\n        [0.05, 0.50, 0.50],\n        [0.07, 0.48, 0.52],\n        [0.04, 0.52, 0.49],\n        [0.95, 0.50, 0.50],\n        [0.93, 0.51, 0.49],\n        [0.96, 0.48, 0.52],\n    ], dtype=float)\n    b_B = np.full(positions_B.shape[0], 0.25, dtype=float)\n\n    # Test case C\n    L_C = 1.0\n    positions_C = np.array([\n        [0.10, 0.10, 0.10],\n        [0.16, 0.10, 0.10],\n        [0.70, 0.70, 0.70],\n        [0.74, 0.70, 0.70],\n    ], dtype=float)\n    b_C = np.array([0.05, 0.05, 0.20, 0.20], dtype=float)\n\n    test_cases = [\n        (positions_A, L_A, b_A),\n        (positions_B, L_B, b_B),\n        (positions_C, L_C, b_C),\n    ]\n\n    results = []\n    for positions, L, bvals in test_cases:\n        sizes = fof_variable_b(positions, L, bvals)\n        results.append(sizes)\n\n    # Final print statement in the exact required format.\n    # Print a list of lists with integers only, single line.\n    # Ensure no extra spaces for strict formatting.\n    def list_to_str(lst):\n        if isinstance(lst, list):\n            return \"[\" + \",\".join(list_to_str(x) for x in lst) + \"]\"\n        else:\n            return str(int(lst))\n    print(list_to_str(results))\n\nsolve()\n```", "id": "2416288"}]}