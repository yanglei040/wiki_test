{"hands_on_practices": [{"introduction": "任何粒子-网格（PM）方法的核心都是在网格上高效地计算引力场。本练习将完全聚焦于这个“网格”部分。通过使用快速傅里叶变换（FFT）实现一个二维泊松方程求解器，你将掌握从给定的质量密度场求解引力势和加速度的基本技术。[@problem_id:2424811]", "problem": "本题要求您构建一个完整、可运行的程序，该程序使用粒子-网格方法实现一个基于二维快速傅里叶变换 (FFT) 的牛顿引力泊松求解器。您的任务是从第一性原理出发，从通过泊松方程关联质量密度与引力势的基本定律开始，推导并实现适用于二维宇宙的正确傅里叶空间格林函数。然后，您必须在具有已知解析解的精心设计的测试场上验证您的实现。\n\n基本原理：在一个连续的二维域中，由面质量密度 $\\Sigma(\\vec{r})$ 产生的牛顿引力势 $\\phi(\\vec{r})$ 通过泊松方程相关联，该方程的选择必须与空间维度及对数函数的拉普拉斯算子恒等式保持一致。使用恒等式 $\\nabla^2 \\ln r = 2\\pi \\delta^{(2)}(\\vec{r})$ 和引力势的定义，在二维空间中关联 $\\nabla^2 \\phi$ 和 $\\Sigma$。在傅里叶空间中，拉普拉斯算子变为乘以 $-|\\vec{k}|^2$，与格林函数的卷积变为乘以其傅里叶变换。您的任务是基于此原理，推导出正确的二维傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$，以取代三维表达式 $\\tilde{G}(\\vec{k}) = -4\\pi G/|\\vec{k}|^2$。\n\n实现设置：考虑一个边长为 $L$ 的方形周期性二维域，该域被离散化为一个 $N \\times N$ 点的均匀网格。使用快速傅里叶变换实现的离散傅里叶变换在傅里叶空间中求解泊松方程。设网格间距为 $\\Delta x = L/N$。使用一维离散频率定义，其中 $k$ 分量由实空间间距 $d=\\Delta x$ 构建：对于每个轴，将离散角波数定义为 $k_\\alpha = 2\\pi \\,\\mathrm{fftfreq}(N, d=\\Delta x)$（其中 $\\alpha \\in \\{x,y\\}$），然后构成 $|\\vec{k}|^2 = k_x^2 + k_y^2$。您必须通过强制实施零平均势来处理零模式 $\\vec{k}=\\vec{0}$（将相应的傅里叶空间格林函数设置为零，并在变换前减去实空间中密度场的平均值）。\n\n您的程序必须：\n- 推导并实现正确的二维引力傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$。\n- 构建一个求解器，对于给定的面密度场 $\\Sigma(x,y)$，通过将减去平均值的密度的傅里叶变换乘以 $\\tilde{G}(\\vec{k})$ 并进行逆变换来计算引力势 $\\phi(x,y)$。\n- 另外，使用傅里叶空间中的谱方法求导来计算引力加速度场 $\\vec{g}(x,y) = -\\nabla \\phi(x,y)$，即利用傅里叶空间中 $\\partial/\\partial x \\leftrightarrow i k_x$ 和 $\\partial/\\partial y \\leftrightarrow i k_y$ 的性质。\n\n单位：使用无量纲代码单位，引力常数 $G=1$。所有要求的输出都是无量纲的实数。\n\n角度单位：所有三角函数必须使用弧度。\n\n测试套件和要求输出：您的程序必须在周期性方形域上运行以下四个测试用例，并生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n\n所有测试的域和常数：$N=64$， $L=1$， $G=1$。\n\n令 $x_i = i\\,\\Delta x$ 且 $y_j = j\\,\\Delta x$，对于 $i,j \\in \\{0,1,\\dots,N-1\\}$，其中 $\\Delta x = L/N$。使用 $\\cos\\left(2\\pi m x/L\\right)$ 和 $\\cos\\left(2\\pi n y/L\\right)$ 定义余弦场。\n\n- 测试 $1$ (标准情况，一维余弦)：面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)$，其中 $A=1$, $m=1$, $n=0$。用您的求解器计算数值势 $\\phi_{\\mathrm{num}}(x,y)$。使用正确的二维泊松关系以及余弦函数是周期域上拉普拉斯算子本征函数的事实，独立推导与此 $\\Sigma(x,y)$ 对应的解析势 $\\phi_{\\mathrm{an}}(x,y)$。输出最大绝对误差 $E_1 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$，作为一个浮点数。\n\n- 测试 $2$ (二维余弦模式)：面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$，其中 $A=0.5$, $m=3$, $n=2$。计算数值势并与为此场解析推导的 $\\phi_{\\mathrm{an}}(x,y)$进行比较。输出 $E_2 = \\max_{i,j} \\left| \\phi_{\\mathrm{num}}(x_i,y_j) - \\phi_{\\mathrm{an}}(x_i,y_j) \\right|$，作为一个浮点数。\n\n- 测试 $3$ (通过加速度进行矢量场检验)：面密度 $\\Sigma(x,y) = A \\cos\\left(2\\pi m x/L\\right)\\cos\\left(2\\pi n y/L\\right)$，其中 $A=0.8$, $m=5$, $n=1$。使用您的求解器，通过势的谱梯度计算数值加速度分量 $g_{x,\\mathrm{num}}(x,y)$ 和 $g_{y,\\mathrm{num}}(x,y)$。独立推导此场的解析加速度分量 $g_{x,\\mathrm{an}}(x,y)$ 和 $g_{y,\\mathrm{an}}(x,y)$，并输出两个分量上的最大绝对误差 $E_3 = \\max\\left\\{\\max_{i,j} \\left| g_{x,\\mathrm{num}} - g_{x,\\mathrm{an}} \\right|,\\; \\max_{i,j} \\left| g_{y,\\mathrm{num}} - g_{y,\\mathrm{an}} \\right|\\right\\}$，作为一个浮点数。\n\n- 测试 $4$ (零模式处理边界情况)：面密度 $\\Sigma(x,y) = A$，其中 $A=7$。在减去平均值并将格林函数的 $\\vec{k}=\\vec{0}$ 模式设置为零后，周期域上的势应恒为零。计算数值势 $\\phi_{\\mathrm{num}}(x,y)$ 并输出其均方根值 $E_4 = \\sqrt{\\frac{1}{N^2}\\sum_{i,j} \\phi_{\\mathrm{num}}(x_i,y_j)^2}$，作为一个浮点数。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[E_1,E_2,E_3,E_4]$。例如，一个有效的输出行格式为“[0.0,0.0,0.0,0.0]”。所有四个输出都必须是无量纲单位的浮点数，并由您所用编程语言的默认字符串转换进行四舍五入。不应打印任何额外文本。", "solution": "所述问题是计算物理学中一个定义明确的练习。它要求使用谱方法（特别是快速傅里叶变换FFT）构建一个在周期性域上求解二维引力泊松方程的数值求解器。该问题具有科学依据，内部逻辑一致，并提供了一套清晰、可验证的测试用例。我们将着手进行解答。\n\n根本任务是求解泊松方程，该方程关联了引力势 $\\phi$ 与面质量密度 $\\Sigma$。\n\n首先，我们必须确立二维宇宙中泊松方程的正确形式。问题引导我们使用二维空间中对数函数的拉普拉斯算子恒等式 $\\nabla^2 \\ln(r) = 2\\pi \\delta^{(2)}(\\vec{r})$，其中 $r=|\\vec{r}|$ 是到原点的距离，$\\delta^{(2)}(\\vec{r})$ 是二维狄拉克δ函数。在二维空间中，引力呈现 $1/r$ 依赖关系，从而导致引力势随 $\\ln(r)$ 变化。对于位于原点的点质量 $m$，其面密度为 $\\Sigma(\\vec{r}) = m \\delta^{(2)}(\\vec{r})$，引力势为 $\\phi(\\vec{r}) = G m \\ln(r)$，其中 $G$ 是引力常数。\n\n对此势取拉普拉斯算子，我们得到：\n$$\n\\nabla^2 \\phi(\\vec{r}) = \\nabla^2 (G m \\ln r) = G m \\nabla^2(\\ln r) = G m (2\\pi \\delta^{(2)}(\\vec{r}))\n$$\n通过用 $\\Sigma(\\vec{r}) / m$ 替换 $\\delta^{(2)}(\\vec{r})$，我们获得了点质量的关系式：\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi G \\Sigma(\\vec{r})\n$$\n根据叠加原理，该方程对任意质量分布 $\\Sigma(\\vec{r})$ 均成立。这就是二维引力的泊松方程。在问题指定的 $G=1$ 的无量纲单位中，该方程简化为：\n$$\n\\nabla^2 \\phi(\\vec{r}) = 2\\pi \\Sigma(\\vec{r})\n$$\n\n我们的目标是使用傅里叶方法求解此偏微分方程。傅里叶变换定义为 $\\tilde{f}(\\vec{k}) = \\mathcal{F}\\{f(\\vec{r})\\} = \\int f(\\vec{r}) e^{-i\\vec{k}\\cdot\\vec{r}} d^2r$。傅里叶变换的一个关键性质是它将微分运算转换成乘法运算。具体而言，拉普拉斯算子的变换为：\n$$\n\\mathcal{F}\\{\\nabla^2 f(\\vec{r})\\} = -|\\vec{k}|^2 \\tilde{f}(\\vec{k})\n$$\n其中 $|\\vec{k}|^2 = k_x^2 + k_y^2$ 是波矢量 $\\vec{k}$ 大小的平方。\n\n对我们的泊松方程两边应用傅里叶变换，我们得到：\n$$\n\\mathcal{F}\\{\\nabla^2 \\phi\\} = \\mathcal{F}\\{2\\pi \\Sigma\\}\n$$\n$$\n-|\\vec{k}|^2 \\tilde{\\phi}(\\vec{k}) = 2\\pi \\tilde{\\Sigma}(\\vec{k})\n$$\n这个代数方程可以解出势的傅里叶变换 $\\tilde{\\phi}(\\vec{k})$：\n$$\n\\tilde{\\phi}(\\vec{k}) = \\left(\\frac{-2\\pi}{|\\vec{k}|^2}\\right) \\tilde{\\Sigma}(\\vec{k})\n$$\n实空间中的卷积问题在傅里叶空间中变成简单的乘法。乘以变换后密度的项就是傅里叶空间格林函数 $\\tilde{G}(\\vec{k})$。因此，对于 $G=1$ 的二维引力：\n$$\n\\tilde{G}(\\vec{k}) = \\frac{-2\\pi}{|\\vec{k}|^2}\n$$\n在 $\\vec{k}=\\vec{0}$ 处存在一个奇点。这反映了势的绝对值是任意的这一物理事实；只有势差才具有物理意义。对于具有周期性边界条件的系统，可以通过要求势具有零平均值来强制得到唯一解。这等价于 $\\tilde{\\phi}(\\vec{k}=\\vec{0}) = 0$。我们通过两个措施实现这一点：\n1.  在傅里叶变换之前减去密度场的平均值：$\\Sigma'(\\vec{r}) = \\Sigma(\\vec{r}) - \\langle \\Sigma \\rangle$。这确保了 $\\tilde{\\Sigma}'(\\vec{k}=\\vec{0})=0$。\n2.  将格林函数在原点处显式设置为零：$\\tilde{G}(\\vec{k}=\\vec{0}) = 0$。\n\n对于在边长为 $L$ 的域上离散的 $N \\times N$ 网格的数值实现，连续傅里叶变换被离散傅里叶变换 (DFT) 所取代，后者通过 FFT 算法实现。离散波矢量由 $k_\\alpha = 2\\pi \\, \\mathrm{fftfreq}(N, d=\\Delta x)$ 给出，用于每个轴 $\\alpha \\in \\{x, y\\}$，其中 $\\Delta x = L/N$ 是网格间距。\n\n从密度场 $\\Sigma(x_i, y_j)$ 计算势 $\\phi(x_i, y_j)$ 的完整算法如下：\n1.  计算离散网格坐标和波矢量。\n2.  在网格上构建离散密度场 $\\Sigma$。\n3.  减去平均值：$\\Sigma' = \\Sigma - \\frac{1}{N^2} \\sum_{i,j} \\Sigma_{i,j}$。\n4.  计算减去平均值的密度的二维 DFT：$\\tilde{\\Sigma}' = \\mathrm{FFT2}(\\Sigma')$。\n5.  构建离散傅里叶空间格林函数 $\\tilde{G}(k_x, k_y) = -2\\pi/(k_x^2 + k_y^2)$，并将 $(k_x, k_y)=(0,0)$ 处的值设为 $0$。\n6.  在傅里叶空间中相乘：$\\tilde{\\phi}(k_x, k_y) = \\tilde{G}(k_x, k_y) \\tilde{\\Sigma}'(k_x, k_y)$。\n7.  计算二维逆 DFT 以获得实空间中的势：$\\phi = \\mathrm{IFFT2}(\\tilde{\\phi})$。结果在数值精度误差范围内应为实值。\n\n引力加速度场 $\\vec{g} = -\\nabla\\phi$ 也可以在傅里叶空间中高效计算。梯度算子变换为 $\\mathcal{F}\\{\\nabla f\\} = i\\vec{k} \\tilde{f}(\\vec{k})$。因此，加速度的傅里叶分量为：\n$$\n\\tilde{g}_x(\\vec{k}) = -i k_x \\tilde{\\phi}(\\vec{k})\n$$\n$$\n\\tilde{g}_y(\\vec{k}) = -i k_y \\tilde{\\phi}(\\vec{k})\n$$\n然后，通过对 $\\tilde{g}_x$ 和 $\\tilde{g}_y$ 分别应用逆 DFT，可以得到实空间加速度分量 $g_x$ 和 $g_y$。\n\n我们用解析解来验证此实现。测试用例使用余弦函数，它们是周期域上拉普拉斯算子的本征函数。对于形式为 $\\Sigma(x,y) = A \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)$ 的密度，满足 $\\nabla^2 \\phi = 2\\pi G \\Sigma$ 且平均值为零的相应势为：\n$$\n\\phi_{\\mathrm{an}}(x,y) = -\\frac{G A L^2}{2\\pi(m^2+n^2)} \\cos(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\n对于 $(m,n) \\neq (0,0)$。相应的加速度分量通过对此势取负梯度得到：\n$$\ng_{x,\\mathrm{an}}(x,y) = -\\frac{G A L m}{m^2+n^2} \\sin(2\\pi m x/L)\\cos(2\\pi n y/L)\n$$\n$$\ng_{y,\\mathrm{an}}(x,y) = -\\frac{G A L n}{m^2+n^2} \\cos(2\\pi m x/L)\\sin(2\\pi n y/L)\n$$\n这些解析解为测量数值求解器的准确性提供了基准。对于均匀密度测试用例，减去平均值后得到一个零场，其势也必须为零。这种情况下的数值误差量化了求解器对零模式的处理能力。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 2D FFT-based Poisson solver for Newtonian gravity and validates it.\n    \"\"\"\n    # Domain and constants for all tests\n    N = 64\n    L = 1.0\n    G = 1.0 # Set to 1 as per problem statement\n\n    # Discretization\n    dx = L / N\n    x = np.arange(N) * dx\n    y = np.arange(N) * dx\n    \n    # Grid coordinates. Use 'xy' indexing for intuitive array layout.\n    # Sigma[i, j] will correspond to Sigma(x_j, y_i)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # Frequencies\n    k_1d = 2 * np.pi * np.fft.fftfreq(N, d=dx)\n    kx, ky = np.meshgrid(k_1d, k_1d, indexing='xy')\n\n    # Fourier-space Green's function for 2D Poisson equation \\nabla^2\\phi = 2\\pi*G*\\Sigma\n    k_sq = kx**2 + ky**2\n    \n    # Suppress division by zero warning for the k=0 case\n    with np.errstate(divide='ignore', invalid='ignore'):\n        green_k = -2 * np.pi * G / k_sq\n    \n    # Handle the k=0 mode (DC component)\n    green_k[0, 0] = 0.0\n\n    # Define a helper function for the solver core\n    def poisson_solver(Sigma):\n        # Subtract mean to enforce zero-mean potential\n        Sigma_mean_subtracted = Sigma - np.mean(Sigma)\n        \n        # Forward FFT\n        Sigma_k = np.fft.fft2(Sigma_mean_subtracted)\n        \n        # Solve in Fourier space\n        phi_k = green_k * Sigma_k\n        \n        # Inverse FFT to get potential\n        phi_num = np.fft.ifft2(phi_k).real\n        \n        return phi_num, phi_k\n\n    # Test cases from the problem statement.\n    test_cases = [\n        {'id': 1, 'A': 1.0, 'm': 1, 'n': 0},\n        {'id': 2, 'A': 0.5, 'm': 3, 'n': 2},\n        {'id': 3, 'A': 0.8, 'm': 5, 'n': 1},\n        {'id': 4, 'A': 7.0, 'm': 0, 'n': 0}\n    ]\n\n    results = []\n\n    for case in test_cases:\n        A = case['A']\n        m = case['m']\n        n = case['n']\n\n        if case['id'] in [1, 2, 3]: # Cosine-based density fields\n            # The general form is A * cos(2*pi*m*x/L) * cos(2*pi*n*y/L),\n            # with n=0 for Test 1.\n            term_x = np.cos(2 * np.pi * m * xx / L)\n            term_y = np.cos(2 * np.pi * n * yy / L)\n            Sigma = A * term_x * term_y\n            \n            # Solve numerically\n            phi_num, phi_k = poisson_solver(Sigma)\n\n            if case['id'] == 1 or case['id'] == 2:\n                # Analytic potential\n                k_norm_sq_mode = m**2 + n**2\n                # From \\nabla^2 \\phi = 2\\pi G \\Sigma\n                C = -G * A * L**2 / (2 * np.pi * k_norm_sq_mode)\n                phi_an = C * term_x * term_y\n                \n                # Calculate error E1 or E2\n                error = np.max(np.abs(phi_num - phi_an))\n                results.append(error)\n            \n            elif case['id'] == 3:\n                # Compute numerical acceleration\n                gx_k = -1j * kx * phi_k\n                gy_k = -1j * ky * phi_k\n                gx_num = np.fft.ifft2(gx_k).real\n                gy_num = np.fft.ifft2(gy_k).real\n\n                # Analytic acceleration\n                k_norm_sq_mode = m**2 + n**2\n                C_gx = -G * A * L * m / k_norm_sq_mode\n                C_gy = -G * A * L * n / k_norm_sq_mode\n\n                gx_an = C_gx * np.sin(2 * np.pi * m * xx / L) * np.cos(2 * np.pi * n * yy / L)\n                gy_an = C_gy * np.cos(2 * np.pi * m * xx / L) * np.sin(2 * np.pi * n * yy / L)\n\n                # Calculate error E3\n                error_gx = np.max(np.abs(gx_num - gx_an))\n                error_gy = np.max(np.abs(gy_num - gy_an))\n                error = max(error_gx, error_gy)\n                results.append(error)\n\n        elif case['id'] == 4: # Constant density field\n            Sigma = np.full((N, N), A)\n            \n            # Solve numerically. The mean subtraction should make Sigma=0.\n            phi_num, _ = poisson_solver(Sigma)\n            \n            # The potential should be identically zero, up to machine precision.\n            # Calculate RMS error E4.\n            error = np.sqrt(np.mean(phi_num**2))\n            results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424811"}, {"introduction": "掌握了场求解器之后，下一步是将其与粒子运动结合起来，创建一个完整的动态模拟。本练习将指导你构建一个一维粒子-网格模拟。你将通过观察当时间步长过大时会发生什么，来探索数值稳定性的关键概念，特别是 Courant-Friedrichs-Lewy (CFL) 条件。[@problem_id:2424803]", "problem": "要求您实现一个完整的、自包含的程序，该程序模拟一维自引力系统的质点-网格（Particle–Mesh, PM）方法，并用它来研究当 Courant–Friedrichs–Lewy (CFL) 条件被有意违反时，显式时间积分的数值稳定性。PM 方法代表质点-网格（Particle–Mesh, PM）方法，稳定性条件是 Courant–Friedrichs–Lewy (CFL) 条件。所有量均为无量纲。空间域是周期性的，长度为 $L=1$。网格有 $N_g=256$ 个均匀间隔的单元，宽度为 $\\Delta x=L/N_g$。共有 $N_p=8192$ 个质点，每个质点的质量为 $m_i=1/N_p$，其初始位置为 $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$，其中 $i=0,1,\\dots,N_p-1$。初始速度为 $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$，其中 $v_0=0.5$。引力常数为 $G=1$。演化由牛顿方程 $\\,\\ddot{x}_i(t)=a\\!\\left(x_i(t),t\\right)\\,$ 控制，其中加速度场 $a(x,t)$ 是通过在网格上求解引力势 $\\phi(x,t)$ 的泊松方程得到的：$$\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}(x,t) = 4\\pi G \\left(\\rho(x,t)-\\bar{\\rho}\\right),$$ 该方程具有周期性边界条件和零均值势（即 $\\phi$ 的 $k=0$ 傅里叶模被设为零）。此处，$\\rho(x,t)$ 是通过使用云中单元（Cloud-In-Cell, CIC）插值法将质点质量分配到网格上得到的质量密度，而 $\\bar{\\rho}$ 是 $\\rho(x,t)$ 的空间平均值。加速度为 $a(x,t)=-\\mathrm{d}\\phi/\\mathrm{d}x$。质点位置处的加速度是通过使用相同的云中单元（CIC）方案将网格加速度插值回质点得到的。时间积分必须使用一个二阶精确、显式、时间可逆的牛顿方程积分器执行 $N_{\\text{steps}}=300$ 步。程序必须运行四个模拟，这些模拟仅在时间步长 $\\Delta t$ 的选择上有所不同。定义初始 CFL 比率为 $$r_0=\\frac{\\Delta t\\,\\max_i |v_i(0)|}{\\Delta x}=\\frac{\\Delta t\\,v_0}{\\Delta x}。$$ 四个模拟所用的 $\\Delta t$ 必须使得 $r_0$ 的取值来自集合 $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$（即，对于每个列出的 $r_0$，设置 $\\Delta t=r_0\\,\\Delta x/v_0$）。对于每个模拟，按如下方式确定一个布尔稳定性指标。当且仅当对于所有步数 $n=0,1,\\dots,N_{\\text{steps}}-1$，以下所有条件都得到满足时，一次运行被判定为稳定： - 在任何时间，任何质点或网格量中均未出现浮点数“非数值”（Not-a-Number）或“无穷大”（infinity）。 - 如果 $v_{i,n+\\tfrac{1}{2}}$ 表示在第 $n$ 步的时间中点评估的质点速度，则满足每步路径长度约束，$$\\max_i \\left|v_{i,n+\\tfrac{1}{2}}\\right|\\,\\Delta t \\le \\theta\\,\\Delta x,$$ 其中 $\\theta=0.9$。 - 整个运行过程中的最大质点速度满足 $$\\max_{n}\\max_i |v_{i,n}| \\le \\gamma\\,v_0,$$ 其中 $\\gamma=10$。 - 网格密度场在以下意义上保持有界 $$\\max_{n}\\left(\\frac{\\max_j \\rho_j^{(n)}}{\\bar{\\rho}}\\right) \\le \\eta,$$ 其中 $\\eta=100$，$\\rho_j^{(n)}$ 是第 $n$ 步时单元 $j$ 的密度，$\\bar{\\rho}$ 是恒定的平均密度。您的程序必须按 $r_0$ 值 $\\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ 的顺序输出四个模拟的稳定性指标，形式为单行输出，包含一个方括号括起来的逗号分隔的布尔值列表，例如，`[{\\rm True},{\\rm False},{\\rm True},{\\rm False}]`。不允许外部输入，也不涉及物理单位；所有量均为无量纲。测试套件是四个初始 CFL 比率 $r_0 \\in \\{0.2,\\,0.9,\\,1.2,\\,2.5\\}$ 的集合，这组测试探测了一个远在稳定极限内的典型情况、一个接近边界的情况、一个轻微违反的情况以及一个严重违反的情况。最终输出格式必须是严格的一行，内容为指定格式的布尔值列表。", "solution": "该问题要求实现一个用于自引力质点系统的一维质点-网格（PM）模拟，以研究显式时间积分方案的数值稳定性。问题陈述的有效性已得到确认，因为它是科学上合理的、适定的，并且为可复现的计算实验提供了所有必要的参数和条件。\n\n解决方案的核心是 PM 方法，这是一种混合技术，它结合了拉格朗日方法和欧拉方法的优点。质点的位置和速度在连续的相空间中被追踪（拉格朗日方法），而长程引力则在离散的网格上计算（欧拉方法）。这种方法避免了直接求和方法中对 $N_p$ 个质点而言计算成本高昂的 $O(N_p^2)$ 复杂度，代之以一系列效率高得多的操作，其中主要由快速傅里叶变换（FFT）主导，其对于大小为 $N_g$ 的网格，复杂度为 $O(N_g \\log N_g)$。\n\n该模拟演化一个由 $N_p=8192$ 个质点组成的系统，每个质点质量为 $m_i = 1/N_p$，位于长度为 $L=1$ 的一维周期性域上。质点以均匀间距 $x_i(0)=\\left(i+\\tfrac{1}{2}\\right)\\,L/N_p$ 和正弦速度分布 $v_i(0)=v_0 \\sin\\!\\left(2\\pi x_i(0)/L\\right)$（振幅 $v_0=0.5$）进行初始化。演化由牛顿运动方程 $\\ddot{x}_i(t) = a(x_i(t), t)$ 控制。加速度场 $a(x,t)$ 源于引力势 $\\phi(x,t)$，后者通过在具有 $N_g=256$ 个单元的网格上求解泊松方程获得。\n\n模拟以离散的时间步进行，主要的计算循环包括三个阶段：时间积分、力计算和稳定性监控。\n\n**时间积分：蛙跳（踢-漂移-踢）格式**\n为了更新质点的位置和速度，我们采用一种二阶精确、显式且时间可逆的积分器，称为蛙跳格式。其踢-漂移-踢（Kick-Drift-Kick, KDK）形式特别适用于引力动力学，因为它是辛的，这意味着它随时间保持相空间体积微元守恒。设 $x_n$ 和 $v_n$ 分别为时间 $t_n = n\\Delta t$ 时的位置和速度。从第 $n$ 步到第 $n+1$ 步的更新过程如下：\n1.  **速度的半步踢：** $v_{n+1/2} = v_n + a_n \\cdot \\frac{\\Delta t}{2}$\n2.  **位置的全步漂移：** $x_{n+1} = x_n + v_{n+1/2} \\cdot \\Delta t$\n3.  **计算新加速度：** $a_{n+1} = a(x_{n+1})$\n4.  **速度的第二个半步踢：** $v_{n+1} = v_{n+1/2} + a_{n+1} \\cdot \\frac{\\Delta t}{2}$\n此处，$v_{n+1/2}$ 表示在时间中点 $t_n + \\Delta t/2$ 时的速度。对于第一步，执行一个初始的半步踢 $v_{1/2} = v_0 + a_0\\Delta t/2$，以使速度相对于位置错开，建立蛙跳格式的交错排列。\n\n**力计算周期**\n每一步所需的加速度 $a_n = a(x_n)$ 在网格上计算，然后插值到质点位置。\n\n1.  **质量分配（质点到网格）：** 将质点质量分配到计算网格的节点上，以获得质量密度场 $\\rho(x,t)$。我们使用云中单元（CIC）方案，这是一种二阶插值方法。对于位于网格节点 $j$ 和 $j+1$ 之间的位置为 $x_p$ 的质点，其质量 $m_p$ 根据距离线性地分配给这两个节点。如果网格间距为 $\\Delta x$，权重为 $w_j = 1 - (x_p/\\Delta x - \\lfloor x_p/\\Delta x \\rfloor)$ 和 $w_{j+1} = 1 - w_j$。每个网格节点 $j$ 上的质量是所有质点贡献的总和。然后，网格密度为 $\\rho_j = M_j/\\Delta x$。该方案起到低通滤波器的作用，在网格间距尺度上平滑密度场。\n\n2.  **泊松求解器（FFT）：** 引力势 $\\phi(x,t)$ 通过求解泊松方程 $\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2} = 4\\pi G (\\rho(x,t)-\\bar{\\rho})$ 来找到，其中 $\\bar{\\rho} = N_p m_i/L = 1$ 是平均密度。减去平均密度确保了源项的空间平均值为零，这对于周期性域上的适定问题是必要的。我们在傅里叶空间中求解此方程，其中微分变为代数乘法。应用傅里叶变换 $\\mathcal{F}$ 得到：\n    $$ \\mathcal{F}\\left[\\frac{\\mathrm{d}^2 \\phi}{\\mathrm{d}x^2}\\right] (k) = (ik)^2 \\hat{\\phi}(k) = -k^2 \\hat{\\phi}(k) $$\n    其中 $k$ 是波数，$\\hat{\\phi}(k)=\\mathcal{F}[\\phi(x)](k)$。方程变为：\n    $$ -k^2 \\hat{\\phi}(k) = 4\\pi G \\hat{\\rho}_{\\text{over}}(k) $$\n    其中 $\\hat{\\rho}_{\\text{over}}$ 是超密度 $\\rho(x,t)-\\bar{\\rho}$ 的傅里叶变换。势在傅里叶空间中的解为：\n    $$ \\hat{\\phi}(k) = - \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\quad \\text{for } k \\neq 0 $$\n    对于 $k=0$ 模（直流分量），问题指定 $\\hat{\\phi}(0)=0$。通过构造，超密度的 $\\hat{\\rho}_{\\text{over}}(0)=0$，从而避免了奇异点。\n\n3.  **加速度计算（FFT）：** 加速度场 $a(x,t) = -\\frac{\\mathrm{d}\\phi}{\\mathrm{d}x}$ 也在傅里叶空间中计算。导数的变换是 $\\hat{a}(k) = -ik \\hat{\\phi}(k)$。代入 $\\hat{\\phi}(k)$ 的表达式：\n    $$ \\hat{a}(k) = ik \\left( \\frac{4\\pi G \\hat{\\rho}_{\\text{over}}(k)}{k^2} \\right) = \\frac{4\\pi i G \\hat{\\rho}_{\\text{over}}(k)}{k} \\quad \\text{for } k \\neq 0 $$\n    并且由于 $\\hat{\\phi}(0)=0$，所以 $\\hat{a}(0)=0$。然后通过对 $\\hat{a}(k)$ 应用逆傅里叶变换，恢复网格上的加速度场 $a_j$。\n\n4.  **力的插值（网格到质点）：** 每个质点位置 $x_i$ 处的加速度是从基于网格的加速度场 $a_j$ 插值得到的。为确保动量守恒，用于质量分配的相同 CIC 权方案被反向应用。位置为 $x_p$ 的质点的加速度是其两侧网格节点上加速度的加权平均：$a_p = a_j w_j + a_{j+1} w_{j+1}$。\n\n**稳定性分析**\n模拟针对四种不同的时间步长 $\\Delta t$ 运行，分别对应初始 Courant–Friedrichs–Lewy (CFL) 比率 $r_0 = \\Delta t v_0 / \\Delta x$ 为 $\\{0.2, 0.9, 1.2, 2.5\\}$。对于每次运行，在每个时间步 $n$ 都会监控几个稳定性标准：\n- **数值完整性：** 模拟不得产生任何浮点数 `NaN` 或 `infinity` 值。这是对灾难性失效的基本检查。\n- **路径长度约束：** $\\max_i |v_{i,n+\\tfrac{1}{2}}|\\,\\Delta t \\le \\theta\\,\\Delta x$，其中 $\\theta=0.9$。这是一个严格的类 CFL 条件，确保没有质点在单个时间步内行进超过网格单元的一小部分 $\\theta$。违反此条件会导致力计算中的混叠误差，是导致不稳定的主要原因。\n- **速度增长：** $\\max_{n,i} |v_{i,n}| \\le \\gamma\\,v_0$，其中 $\\gamma=10$。这可以防止非物理的动能失控增长。\n- **密度对比度：** $\\max_{n,j} (\\rho_j^{(n)}/\\bar{\\rho}) \\le \\eta$，其中 $\\eta=100$。这用于检查是否形成了过密的结构，这些结构可能导致数值奇异点。\n\n当且仅当所有四个条件在整个 $N_{\\text{steps}}=300$ 步的运行过程中都得到满足时，模拟才被认为是稳定的。路径长度约束 $\\frac{\\max|v_{n+1/2}|}{v_0} r_0 \\le \\theta$ 意味着对于 $v \\approx v_0$ 的情况，稳定性要求 $r_0 \\le \\theta=0.9$。因此，我们预期 $r_0=1.2$ 和 $r_0=2.5$ 的模拟会立即失败。$r_0=0.9$ 的情况恰好处于稳定边界上，并且预计会因为引力坍缩导致质点速度不可避免地超过其初始值而失败。$r_0=0.2$ 的情况应该会稳定地保持在稳定区间内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import fft\n\ndef solve():\n    \"\"\"\n    Main solver function to run simulations for all test cases and print results.\n    \"\"\"\n    \n    def run_simulation(r0: float) -> bool:\n        \"\"\"\n        Runs a single 1D Particle-Mesh simulation for a given initial CFL ratio r0.\n\n        Args:\n            r0: The initial Courant-Friedrichs-Lewy (CFL) ratio.\n\n        Returns:\n            A boolean indicating whether the simulation remained stable.\n        \"\"\"\n        # --- Problem Parameters ---\n        L = 1.0  # Domain length\n        Ng = 256  # Number of grid cells\n        Np = 8192  # Number of particles\n        v0 = 0.5  # Initial velocity amplitude\n        G = 1.0  # Gravitational constant\n        N_steps = 300  # Number of time steps\n\n        # --- Stability Check Parameters ---\n        theta = 0.9  # Path length constraint factor\n        gamma = 10.0  # Max velocity factor\n        eta = 100.0  # Max density ratio\n\n        # --- Derived Constants ---\n        dx = L / Ng  # Grid cell width\n        m = 1.0 / Np  # Particle mass\n        rho_mean = 1.0  # Mean density: (Np * m) / L\n        dt = r0 * dx / v0  # Time step\n\n        # --- Helper function for acceleration calculation ---\n        def get_accel_and_density(pos: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n            \"\"\"\n            Calculates particle accelerations and grid density using the PM method.\n            \"\"\"\n            # 1. Mass Assignment (Particle-to-Mesh) using CIC\n            grid_mass = np.zeros(Ng, dtype=np.float64)\n            pos_in_grid_units = pos / dx\n            j = np.floor(pos_in_grid_units).astype(int)\n            w_right = pos_in_grid_units - j\n            w_left = 1.0 - w_right\n            \n            # Use np.add.at for safe atomistic addition\n            np.add.at(grid_mass, j % Ng, m * w_left)\n            np.add.at(grid_mass, (j + 1) % Ng, m * w_right)\n\n            grid_density = grid_mass / dx\n\n            # 2. Solve Poisson's Equation in Fourier Space\n            overdensity = grid_density - rho_mean\n            overdensity_hat = fft.fft(overdensity)\n            \n            wavenumbers = 2.0 * np.pi * fft.fftfreq(Ng, d=dx)\n            \n            phi_hat = np.zeros_like(overdensity_hat)\n            k_sq = wavenumbers**2\n            \n            # Solve for phi_hat, handling k=0 case\n            non_zero_k = wavenumbers != 0\n            phi_hat[non_zero_k] = -4.0 * np.pi * G * overdensity_hat[non_zero_k] / k_sq[non_zero_k]\n            \n            # 3. Calculate Acceleration in Fourier Space\n            accel_hat = -1j * wavenumbers * phi_hat\n            \n            # 4. Transform Acceleration to Real Space\n            grid_accel = fft.ifft(accel_hat).real\n\n            # 5. Interpolate Acceleration to Particles (Mesh-to-Particle) using CIC\n            particle_accel = grid_accel[j % Ng] * w_left + grid_accel[(j + 1) % Ng] * w_right\n            \n            return particle_accel, grid_density\n        \n        # --- Initialization ---\n        particle_pos = (np.arange(Np, dtype=np.float64) + 0.5) * L / Np\n        particle_vel = v0 * np.sin(2.0 * np.pi * particle_pos / L)\n        \n        max_vel_history = [np.max(np.abs(particle_vel))]\n\n        try:\n            # Use np.errstate to catch floating point errors as exceptions\n            with np.errstate(all='raise'):\n                # --- Initial force calculation and half-step kick ---\n                accel, grid_density = get_accel_and_density(particle_pos)\n                \n                # Check initial density constraint\n                if np.max(grid_density) / rho_mean > eta:\n                    return False\n                \n                vel_half = particle_vel + accel * (dt / 2.0)\n                \n                # --- Main Time Integration Loop ---\n                for _ in range(N_steps):\n                    # --- Stability Check 1: Path Length (CFL) ---\n                    if np.max(np.abs(vel_half)) * dt > theta * dx:\n                        return False\n                    \n                    # --- Drift (full step) ---\n                    particle_pos += vel_half * dt\n                    particle_pos %= L  # Periodic boundary conditions\n                    \n                    # --- Force Calculation ---\n                    accel, grid_density = get_accel_and_density(particle_pos)\n\n                    # --- Stability Check 2: Density Contrast ---\n                    if np.max(grid_density) / rho_mean > eta:\n                        return False\n\n                    # --- Kick (full step for next half-step velocity) ---\n                    vel_half_next = vel_half + accel * dt\n\n                    # --- Store velocity at full step for max velocity check ---\n                    vel_full = (vel_half + vel_half_next) / 2.0\n                    max_vel_history.append(np.max(np.abs(vel_full)))\n                    \n                    # Update velocity for next iteration\n                    vel_half = vel_half_next\n\n        except FloatingPointError:\n            # --- Stability Check 3: NaN/inf detection ---\n            return False\n            \n        # --- Stability Check 4: Max velocity over entire run ---\n        if max(max_vel_history) > gamma * v0:\n            return False\n            \n        # If all checks passed for all steps\n        return True\n\n    # Define the test cases from the problem statement.\n    test_cases = [0.2, 0.9, 1.2, 2.5]\n    \n    results = [run_simulation(r0) for r0 in test_cases]\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2424803"}, {"introduction": "真实的宇宙学系统是高度动态的，密集区域的演化速度远快于稀疏区域。本练习介绍了一种高级且必要的技术：自适应时间步长。你将实现一个PM模拟，其中时间步长 $\\Delta t$ 会根据最大密度动态调整，从而确保密集区域的计算精度和稀疏区域的计算效率。[@problem_id:2424737]", "problem": "实现一个独立的程序，使用粒子-网格（PM）方法，在方形域上采用周期性边界条件，模拟点粒子在其自引力作用下的运动。时间积分必须使用可变时间步长的蛙跳格式，时间步长由网格上的最大质量密度确定。所有量都是无量纲的。任务是为一组固定的测试套件生成数值结果。\n\n模型和离散化的数学规范：\n\n- 域：一个边长为 $L$ 的正方形，具有周期性边界条件，$L$ 在每个测试用例中给出。\n- 网格：一个具有 $N \\times N$ 个单元的均匀笛卡尔网格，其中 $N$ 是每个测试用例中给出的正整数。网格间距为 $a = L/N$，单元面积为 $a^2$。\n- 粒子：$P$ 个点粒子，具有相等或指定的质量 $m_p$、位置 $\\mathbf{x}_p = (x_p, y_p)$ 和速度 $\\mathbf{v}_p = (v_{x,p}, v_{y,p})$，其中 $p \\in \\{1,\\dots,P\\}$。由于周期性，每个坐标的位置总是被包裹在 $[0,L)$ 内。\n- 网格上的质量分配：使用云中单元（CIC）格式。对于位置为 $(x_p, y_p)$ 的粒子，计算其分数单元坐标 $(u, v) = (x_p/a, y_p/a)$，令 $(i, j) = (\\lfloor u \\rfloor, \\lfloor v \\rfloor)$，以及 $f_x = u - \\lfloor u \\rfloor$, $f_y = v - \\lfloor v \\rfloor$。该粒子对周围四个单元的贡献权重如下：\n  - 对 $(i,j)$ 的权重为 $(1 - f_x)(1 - f_y)$，\n  - 对 $((i+1) \\bmod N, j)$ 的权重为 $f_x(1 - f_y)$，\n  - 对 $(i, (j+1) \\bmod N)$ 的权重为 $(1 - f_x)f_y$，\n  - 对 $((i+1) \\bmod N, (j+1) \\bmod N)$ 的权重为 $f_x f_y$。\n  网格上单元 $(i,j)$ 的质量密度为 $\\rho_{ij} = \\frac{1}{a^2} \\sum_{p} m_p W_{ij}(\\mathbf{x}_p)$，其中 $W_{ij}$ 是上述的 CIC 权重。\n- 引力势和加速度：设引力常数 $G = 1$。定义密度涨落场 $\\delta \\rho = \\rho - \\bar{\\rho}$，其中 $\\bar{\\rho}$ 是 $\\rho$ 在网格上的平均值。使用标准的复指数约定在网格上定义离散傅里叶变换。设波数为 $k_x = 2\\pi n_x / L$, $k_y = 2\\pi n_y / L$，整数索引 $n_x, n_y \\in \\{-\\lfloor N/2 \\rfloor, \\dots, \\lfloor (N-1)/2 \\rfloor\\}$。傅里叶空间中的引力加速度分量为\n  $$ \\tilde{g}_x(\\mathbf{k}) = 4\\pi i \\frac{k_x}{k_x^2 + k_y^2} \\tilde{\\delta \\rho}(\\mathbf{k}), \\quad \\tilde{g}_y(\\mathbf{k}) = 4\\pi i \\frac{k_y}{k_x^2 + k_y^2} \\tilde{\\delta \\rho}(\\mathbf{k}), $$\n  对于所有 $k_x^2 + k_y^2 \\neq 0$ 的模式，且 $\\tilde{g}_x(\\mathbf{0}) = \\tilde{g}_y(\\mathbf{0}) = 0$。通过逆离散傅里叶变换获得实空间加速度 $g_x(i,j)$ 和 $g_y(i,j)$。使用与质量分配相同的 CIC 权重，将 $(g_x, g_y)$ 插值到粒子位置，从而获得粒子加速度 $\\mathbf{a}_p$。\n- 时间积分：使用可变时间步长的蛙跳踢-漂移-踢格式。在每一步中，给定当前位置 $\\mathbf{x}_p$ 和速度 $\\mathbf{v}_p$，计算网格密度 $\\rho$ 及其最大值 $\\rho_{\\max} = \\max_{i,j} \\rho_{ij}$，并设置\n  $$ \\Delta t = \\frac{C}{\\sqrt{\\rho_{\\max} + \\rho_{\\mathrm{floor}}}}, $$\n  其中 $C$ 和 $\\rho_{\\mathrm{floor}}$ 是测试用例输入中提供的正常数。如果前进 $\\Delta t$ 将超过最终时间，则减小 $\\Delta t$ 以便精确达到最终时间。对于给定的 $\\Delta t$，执行：\n  - 半步踢：$\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{1}{2} \\Delta t \\, \\mathbf{a}_p(\\mathbf{x}_p)$，\n  - 漂移：$\\mathbf{x}_p \\leftarrow \\mathbf{x}_p + \\Delta t \\, \\mathbf{v}_p$（将每个坐标包裹到 $[0,L)$ 内），\n  - 在更新后的位置重新计算加速度，\n  - 半步踢：$\\mathbf{v}_p \\leftarrow \\mathbf{v}_p + \\frac{1}{2} \\Delta t \\, \\mathbf{a}_p(\\mathbf{x}_p)$。\n  继续此过程，直到累积时间达到指定的最终时间 $T_{\\mathrm{end}}$。\n- 每个测试用例需报告的量：总步数 $N_{\\mathrm{steps}}$、实际使用的最后一个时间步长 $\\Delta t_{\\mathrm{final}}$，以及根据最终时间的粒子位置计算出的最终最大网格密度 $\\rho_{\\max,\\mathrm{final}}$。\n\n所有计算必须在指定的无量纲系统中进行；不报告任何物理单位。输出中的所有浮点数结果必须格式化为小数点后恰好 $6$ 位数字。\n\n测试套件：\n\n为以下三个测试用例提供结果。在每个用例中，除非另有说明，所有粒子的质量相等且总和为 $1$。\n\n- 测试用例 1：\n  - $N = 32$, $L = 1$,\n  - $P = 2$，粒子质量 $m_1 = m_2 = 0.5$,\n  - 初始位置：$\\mathbf{x}_1 = (0.5, 0.5)$, $\\mathbf{x}_2 = (0.53, 0.5)$,\n  - 初始速度：$\\mathbf{v}_1 = (0, 0)$, $\\mathbf{v}_2 = (0, 0)$,\n  - $C = 0.02$, $\\rho_{\\mathrm{floor}} = 10^{-6}$, $T_{\\mathrm{end}} = 0.5$。\n- 测试用例 2：\n  - $N = 32$, $L = 1$,\n  - $P = 4$，所有 $p$ 的粒子质量均为 $m_p = 0.25$,\n  - 初始位置：$\\mathbf{x}_1 = (0.25, 0.25)$, $\\mathbf{x}_2 = (0.75, 0.25)$, $\\mathbf{x}_3 = (0.25, 0.75)$, $\\mathbf{x}_4 = (0.75, 0.75)$,\n  - 初始速度：所有 $p$ 的速度均为 $\\mathbf{v}_p = (0, 0)$,\n  - $C = 0.05$, $\\rho_{\\mathrm{floor}} = 10^{-6}$, $T_{\\mathrm{end}} = 0.5$。\n- 测试用例 3：\n  - $N = 16$, $L = 1$,\n  - $P = 2$，粒子质量 $m_1 = m_2 = 0.5$,\n  - 初始位置：$\\mathbf{x}_1 = (0.1, 0.1)$, $\\mathbf{x}_2 = (0.6, 0.9)$,\n  - 初始速度：$\\mathbf{v}_1 = (0, 0.1)$, $\\mathbf{v}_2 = (-0.05, 0)$,\n  - $C = 0.2$, $\\rho_{\\mathrm{floor}} = 10^{-6}$, $T_{\\mathrm{end}} = 0.01$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个含三个列表的列表，每个测试用例一个，每个内部列表包含 $[N_{\\mathrm{steps}}, \\Delta t_{\\mathrm{final}}, \\rho_{\\max,\\mathrm{final}}]$。外部列表和每个内部列表都必须用方括号括起来，条目之间用逗号分隔，浮点数必须格式化为小数点后恰好 $6$ 位数字。例如，语法正确的输出（使用占位符数字）将如下所示\n$[[123,0.001234,456.789000],[\\dots],[\\dots]]$。", "solution": "在尝试解决方案之前，需要对问题陈述进行验证。\n\n**第一步：提取已知条件**\n\n问题为使用粒子-网格（PM）方法进行N体引力动力学的数值模拟提供了完整的规范。关键组成部分如下：\n- **域：** 一个边长为 $L$ 的二维正方形，具有周期性边界条件。\n- **网格：** 一个 $N \\times N$ 单元的均匀笛卡尔网格。网格间距为 $a = L/N$。\n- **粒子：** $P$ 个粒子，具有指定的质量 $m_p$、初始位置 $\\mathbf{x}_p$ 和初始速度 $\\mathbf{v}_p$。\n- **质量分配：** 使用云中单元（CIC）格式将粒子质量分配到网格上，得到质量密度场 $\\rho_{ij} = \\frac{1}{a^2} \\sum_{p} m_p W_{ij}(\\mathbf{x}_p)$，其中 $W_{ij}$ 是 CIC 权重。\n- **力计算：** 引力加速度在傅里叶空间中计算。引力常数 $G = 1$。该方法使用密度涨落场 $\\delta \\rho = \\rho - \\bar{\\rho}$，其中 $\\bar{\\rho}$ 是网格密度的平均值。傅里叶空间中的加速度分量由 $\\tilde{g}_x(\\mathbf{k}) = 4\\pi i \\frac{k_x}{k_x^2 + k_y^2} \\tilde{\\delta \\rho}(\\mathbf{k})$ 和 $\\tilde{g}_y(\\mathbf{k}) = 4\\pi i \\frac{k_y}{k_x^2 + k_y^2} \\tilde{\\delta \\rho}(\\mathbf{k})$ 给出，适用于非零波矢 $\\mathbf{k} = (k_x, k_y)$，且 $\\tilde{\\mathbf{g}}(\\mathbf{0}) = \\mathbf{0}$。通过逆傅里叶变换获得实空间加速度网格。\n- **力插值：** 每个粒子位置处的加速度 $\\mathbf{a}_p$ 是通过使用与质量分配相同的 CIC 权重从网格插值得到的。\n- **时间积分：** 使用速度Verlet形式的蛙跳（踢-漂移-踢）格式。时间步长 $\\Delta t$ 是可变的，在每一步由最大网格密度 $\\rho_{\\max}$ 根据公式 $\\Delta t = C / \\sqrt{\\rho_{\\max} + \\rho_{\\mathrm{floor}}}$ 确定，其中 $C$ 和 $\\rho_{\\mathrm{floor}}$ 是给定的常数。\n- **测试用例：** 提供了三个具体的测试用例，每个都有一套完整的参数：$N, L, P$，粒子初始条件（$m_p, \\mathbf{x}_p, \\mathbf{v}_p$）和模拟参数（$C, \\rho_{\\mathrm{floor}}, T_{\\mathrm{end}}$）。\n- **要求输出：** 对每个测试用例，必须报告总步数 $N_{\\mathrm{steps}}$、使用的最终时间步长 $\\Delta t_{\\mathrm{final}}$ 和最终时间的最大网格密度 $\\rho_{\\max,\\mathrm{final}}$。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题描述了粒子-网格（PM）方法，这是一种在计算物理学中，特别是在宇宙学和天体物理学中，用于模拟无碰撞N体系统的标准且经过充分验证的技术。使用傅里叶变换在周期性网格上求解引力的泊松方程是此方法的基础。CIC 格式是一种标准的二阶质量分配和插值方法。速度Verlet积分器是一种辛的、二阶精确的格式，广泛用于分子动力学和N体模拟。时间步长准则 $\\Delta t \\propto 1/\\sqrt{\\rho_{\\max}}$ 是一种常见且有物理动机的启发式方法，与最密集区域的动力学时间（自由落体时间）相关。为傅里叶空间加速度提供的数学公式对于投影到二维平面上的三维引力是正确的，这是此类二维模拟的标准方法，源自泊松方程 $\\nabla^2 \\phi = 4\\pi G \\delta \\rho$。该问题在科学上是合理的。\n- **良定性：** 问题指定了一个基于常微分方程组（粒子的运动方程）的时间演化问题，具有明确定义的初始条件。离散化方法已完全指定。对于有限的时间间隔，数值解是良定且唯一的。\n- **客观性：** 问题以纯粹的数学和算法术语陈述，没有任何主观或模棱两可的语言。\n- **完整性和一致性：** 提供了每个测试用例的所有必要参数和初始条件。所有方法的定义（CIC、傅里叶力计算、时间积分）都是明确的，并与标准文献一致。使用密度涨落 $\\delta\\rho$ 并将加速度的 $\\mathbf{k}=\\mathbf{0}$ 模式设置为零，是处理周期性域中自引力系统的正确程序。\n\n**第三步：结论与行动**\n\n该问题是**有效的**。这是一个良定的、有科学依据且完全指定的计算任务。将开发并实现一个解决方案。\n\n**解决方案设计**\n\n该解决方案将作为一个 Python 程序实现，利用 `numpy` 库进行高效的数组计算。整体结构将包含一个主循环，遍历指定的测试用例。对于每个用例，将实例化并运行一个模拟对象。\n\n模拟以离散的时间步长进行。算法的核心是主时间循环，该循环一直持续到模拟时间达到指定的最终时间 $T_{\\mathrm{end}}$。在此循环内部，执行以下对应一个时间步长的序列：\n\n1.  **计算加速度**：在当前粒子位置 $\\mathbf{x}_p$，计算加速度 $\\mathbf{a}_p$。这是 PM 方法中最复杂的部分，涉及三个子步骤：\n    a.  **质量分配**：使用 CIC 格式将每个粒子的质量分布到 $N \\times N$ 网格上。这会生成一个质量密度网格 $\\rho_{ij}$。此步骤将进行矢量化以提高效率。\n    b.  **场求解**：在网格上计算引力场。首先，计算密度涨落场 $\\delta\\rho = \\rho - \\bar{\\rho}$。然后使用 `numpy.fft.fft2` 计算其二维离散傅里叶变换 $\\tilde{\\delta\\rho}(\\mathbf{k})$。使用提供的公式计算傅里叶空间加速度分量 $\\tilde{g}_x(\\mathbf{k})$ 和 $\\tilde{g}_y(\\mathbf{k})$。将使用一个预先计算的 $1/(k_x^2+k_y^2)$ 核，并适当处理 $k=0$ 的奇异点。最后，通过逆二维离散傅里叶变换（`numpy.fft.ifft2`）得到网格上的实空间加速度分量 $g_x(i,j)$ 和 $g_y(i,j)$。\n    c.  **加速度插值**：通过使用与质量分配步骤中相同的 CIC 权重，插值网格加速度值 $(g_x, g_y)$，找到每个粒子位置处的加速度矢量。\n\n2.  **更新时间步长**：确定网格上的最大密度 $\\rho_{\\max}$。计算新的时间步长 $\\Delta t = C / \\sqrt{\\rho_{\\max} + \\rho_{\\mathrm{floor}}}$。如果当前时间加上 $\\Delta t$ 超过 $T_{\\mathrm{end}}$，则调整 $\\Delta t$ 以精确达到 $T_{\\mathrm{end}}$。\n\n3.  **积分运动方程**：使用指定的踢-漂移-踢（速度Verlet）格式，将粒子位置和速度推进一个步长 $\\Delta t$：\n    a.  **第一次半步踢**：将速度从时间 $t$ 更新到 $t + \\Delta t/2$：$\\mathbf{v}_{p, t+\\Delta t/2} = \\mathbf{v}_{p,t} + \\mathbf{a}_p(\\mathbf{x}_{p,t}) \\frac{\\Delta t}{2}$。\n    b.  **漂移**：将位置更新到时间 $t+\\Delta t$：$\\mathbf{x}_{p, t+\\Delta t} = \\mathbf{x}_{p,t} + \\mathbf{v}_{p, t+\\Delta t/2} \\Delta t$。然后将位置在每个坐标上包裹在域 $[0, L)$ 内，以强制执行周期性边界条件。\n    c.  **重新计算加速度**：使用与步骤1中相同的三步 PM 程序，在新的位置计算新的加速度 $\\mathbf{a}_p(\\mathbf{x}_{p,t+\\Delta t})$。\n    d.  **第二次半步踢**：将速度更新到时间 $t+\\Delta t$：$\\mathbf{v}_{p, t+\\Delta t} = \\mathbf{v}_{p, t+\\Delta t/2} + \\mathbf{a}_p(\\mathbf{x}_{p,t+\\Delta t}) \\frac{\\Delta t}{2}$。\n\n4.  **更新状态**：模拟时间增加 $\\Delta t$，步数计数器加一。\n\n此循环重复进行，直到模拟时间达到 $T_{\\mathrm{end}}$。循环终止后，使用最终的粒子位置执行一次最终的质量分配，以计算所需的量 $\\rho_{\\max,\\mathrm{final}}$。总步数 $N_{\\mathrm{steps}}$ 和最终时间步长 $\\Delta t_{\\mathrm{final}}$ 也被记录下来。然后将所有测试用例的结果格式化为指定的字符串作为最终输出。使用 `numpy` 矢量化操作对于实现可接受的性能至关重要。需要特别注意数组索引约定（例如，`numpy` 数组的 `(y, x)`）和 `meshgrid` 的索引参数，以确保实空间网格与其傅里叶空间表示之间的一致性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the Particle-Mesh simulation.\n    \"\"\"\n    \n    test_cases_data = [\n        {\n            \"N\": 32, \"L\": 1.0, \"P\": 2,\n            \"masses\": [0.5, 0.5],\n            \"init_pos\": [[0.5, 0.5], [0.53, 0.5]],\n            \"init_vel\": [[0.0, 0.0], [0.0, 0.0]],\n            \"C\": 0.02, \"rho_floor\": 1e-6, \"T_end\": 0.5\n        },\n        {\n            \"N\": 32, \"L\": 1.0, \"P\": 4,\n            \"masses\": [0.25, 0.25, 0.25, 0.25],\n            \"init_pos\": [[0.25, 0.25], [0.75, 0.25], [0.25, 0.75], [0.75, 0.75]],\n            \"init_vel\": [[0.0, 0.0], [0.0, 0.0], [0.0, 0.0], [0.0, 0.0]],\n            \"C\": 0.05, \"rho_floor\": 1e-6, \"T_end\": 0.5\n        },\n        {\n            \"N\": 16, \"L\": 1.0, \"P\": 2,\n            \"masses\": [0.5, 0.5],\n            \"init_pos\": [[0.1, 0.1], [0.6, 0.9]],\n            \"init_vel\": [[0.0, 0.1], [-0.05, 0.0]],\n            \"C\": 0.2, \"rho_floor\": 1e-6, \"T_end\": 0.01\n        }\n    ]\n\n    results = []\n    for params in test_cases_data:\n        sim = ParticleMeshSimulation(**params)\n        n_steps, dt_final, rho_max_final = sim.run()\n        results.append([n_steps, dt_final, rho_max_final])\n\n    inner_lists = [f\"[{r[0]},{r[1]:.6f},{r[2]:.6f}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists)}]\"\n    print(final_output)\n\n\nclass ParticleMeshSimulation:\n    \"\"\"\n    Implements a 2D Particle-Mesh gravitational simulation.\n    \"\"\"\n    def __init__(self, N, L, P, masses, init_pos, init_vel, C, rho_floor, T_end):\n        # Simulation parameters\n        self.N = int(N)\n        self.L = float(L)\n        self.P = int(P)\n        self.C = float(C)\n        self.rho_floor = float(rho_floor)\n        self.T_end = float(T_end)\n\n        self.a = self.L / self.N\n\n        # Particle state (using float64 for precision)\n        self.pos = np.array(init_pos, dtype=np.float64)\n        self.vel = np.array(init_vel, dtype=np.float64)\n        self.mass = np.array(masses, dtype=np.float64)\n\n        # Simulation state variables\n        self.time = 0.0\n        self.steps = 0\n        self.dt_final = 0.0\n        \n        # Precompute k-space Green's function and wavevectors\n        self._precompute_k_space()\n\n    def _precompute_k_space(self):\n        \"\"\"\n        Precomputes Fourier-space wavevectors and the Green's function kernel.\n        \"\"\"\n        k_freq = np.fft.fftfreq(self.N, d=self.a)\n        kx_vec = 2 * np.pi * k_freq\n        ky_vec = 2 * np.pi * k_freq\n\n        # Use 'xy' indexing for meshgrid to align with numpy's FFT axis conventions\n        # KX shape: (N, N), varies along axis 1 (columns)\n        # KY shape: (N, N), varies along axis 0 (rows)\n        self.KX, self.KY = np.meshgrid(kx_vec, ky_vec, indexing='xy')\n\n        k_squared = self.KX**2 + self.KY**2\n        self.inv_k_squared = np.zeros_like(k_squared)\n        # Avoid division by zero at k=0\n        non_zero_k = k_squared != 0\n        self.inv_k_squared[non_zero_k] = 1.0 / k_squared[non_zero_k]\n        \n    def _get_accel_and_rho_max(self, positions):\n        \"\"\"\n        Calculates accelerations and max density for a given set of particle positions.\n        \"\"\"\n        # 1. Mass Assignment (CIC)\n        rho_grid = np.zeros((self.N, self.N), dtype=np.float64)\n        u_v = positions / self.a\n        i_j = np.floor(u_v).astype(int)\n        f_xy = u_v - i_j\n        \n        fx, fy = f_xy[:, 0], f_xy[:, 1]\n        i, j = i_j[:, 0], i_j[:, 1]\n        \n        # CIC weights\n        w1 = (1 - fx) * (1 - fy)  # for cell (i, j)\n        w2 = fx * (1 - fy)        # for cell (i+1, j)\n        w3 = (1 - fx) * fy        # for cell (i, j+1)\n        w4 = fx * fy              # for cell (i+1, j+1)\n\n        # Apply periodic boundary conditions to indices\n        i_plus_1 = (i + 1) % self.N\n        j_plus_1 = (j + 1) % self.N\n\n        # Use np.add.at for safe, vectorized addition to grid cells\n        # Note: numpy indexing is (row, column) -> (j, i)\n        np.add.at(rho_grid, (j, i), self.mass * w1)\n        np.add.at(rho_grid, (j, i_plus_1), self.mass * w2)\n        np.add.at(rho_grid, (j_plus_1, i), self.mass * w3)\n        np.add.at(rho_grid, (j_plus_1, i_plus_1), self.mass * w4)\n\n        rho_grid /= (self.a**2)\n        rho_max = np.max(rho_grid)\n\n        # 2. Field Solving (Fourier method)\n        delta_rho = rho_grid - rho_grid.mean()\n        delta_rho_k = np.fft.fft2(delta_rho)\n        \n        # Gravitational constant G = 1 is implied by the formula\n        g_x_k = (4.0 * np.pi * 1j * self.KX) * delta_rho_k * self.inv_k_squared\n        g_y_k = (4.0 * np.pi * 1j * self.KY) * delta_rho_k * self.inv_k_squared\n        \n        g_x_grid = np.real(np.fft.ifft2(g_x_k))\n        g_y_grid = np.real(np.fft.ifft2(g_y_k))\n\n        # 3. Interpolate Acceleration (CIC)\n        accel_x = (w1 * g_x_grid[j, i] +\n                   w2 * g_x_grid[j, i_plus_1] +\n                   w3 * g_x_grid[j_plus_1, i] +\n                   w4 * g_x_grid[j_plus_1, i_plus_1])\n                   \n        accel_y = (w1 * g_y_grid[j, i] +\n                   w2 * g_y_grid[j, i_plus_1] +\n                   w3 * g_y_grid[j_plus_1, i] +\n                   w4 * g_y_grid[j_plus_1, i_plus_1])\n        \n        accel = np.column_stack((accel_x, accel_y))\n\n        return accel, rho_max\n\n    def _get_rho_max_final(self):\n        \"\"\"\n        Simplified mass assignment to compute final max density.\n        \"\"\"\n        rho_grid = np.zeros((self.N, self.N), dtype=np.float64)\n        u_v = self.pos / self.a\n        i_j = np.floor(u_v).astype(int)\n        f_xy = u_v - i_j\n        fx, fy = f_xy[:, 0], f_xy[:, 1]\n        i, j = i_j[:, 0], i_j[:, 1]\n        \n        w1 = (1 - fx) * (1 - fy)\n        w2 = fx * (1 - fy)\n        w3 = (1 - fx) * fy\n        w4 = fx * fy\n        \n        i_plus_1 = (i + 1) % self.N\n        j_plus_1 = (j + 1) % self.N\n        \n        np.add.at(rho_grid, (j, i), self.mass * w1)\n        np.add.at(rho_grid, (j, i_plus_1), self.mass * w2)\n        np.add.at(rho_grid, (j_plus_1, i), self.mass * w3)\n        np.add.at(rho_grid, (j_plus_1, i_plus_1), self.mass * w4)\n        \n        rho_grid /= (self.a**2)\n        return np.max(rho_grid)\n\n    def run(self):\n        \"\"\"\n        Executes the simulation loop until T_end is reached.\n        \"\"\"\n        # Initial acceleration\n        accel, rho_max = self._get_accel_and_rho_max(self.pos)\n\n        while self.time  self.T_end:\n            \n            dt = self.C / np.sqrt(rho_max + self.rho_floor)\n            if self.time + dt > self.T_end:\n                dt = self.T_end - self.time\n            \n            # Prevent infinite loop if dt becomes zero due to precision\n            if dt == 0:\n                break\n            \n            self.dt_final = dt\n            \n            # KDK (Velocity Verlet) Integrator\n            # First half-kick\n            vel_half = self.vel + 0.5 * dt * accel\n            \n            # Drift\n            self.pos += dt * vel_half\n            self.pos = np.mod(self.pos, self.L) # Apply periodic boundaries\n            \n            # Recompute accelerations and max density at new positions\n            accel, rho_max = self._get_accel_and_rho_max(self.pos)\n            \n            # Second half-kick\n            self.vel = vel_half + 0.5 * dt * accel\n            \n            self.time += dt\n            self.steps += 1\n            \n        rho_max_final = self._get_rho_max_final()\n        \n        return self.steps, self.dt_final, rho_max_final\n\nsolve()\n```", "id": "2424737"}]}