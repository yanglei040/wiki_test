{"hands_on_practices": [{"introduction": "任何有效的邻域列表算法，其首要任务是保证正确性——即不能遗漏任何一个相互作用的粒子对。本练习 [@problem_id:2416939] 将引导我们思考单元列表方法中最基本的设计决策：如何设置单元格大小以确保在包含不同尺寸颗粒（多分散系统）的模拟中，搜索邻居的算法万无一失。通过分析最坏情况，我们能够为正确的算法实现奠定坚实的基础。", "problem": "在一个三维（$3$D）多分散球形颗粒的离散元法（DEM）模拟中，一个周期性立方体区域内有 $N$ 个颗粒。颗粒 $i$ 的半径为 $r_i$，其中 $r_{\\min} = \\min_i r_i$ 且 $r_{\\max} = \\max_i r_i$。仅当两个颗粒的中心距小于或等于其半径之和时，它们才通过接触力相互作用，即中心距 $d_{ij}$ 满足 $d_{ij} \\le r_i + r_j$。邻域搜索采用均匀立方体单元链表法，其中立方体单元的边长为 $a$。对每个颗粒而言，其候选邻居被视为位于同一单元及 $26$ 个相邻邻居单元中的所有颗粒。没有额外的缓冲区（“表皮”）：邻居数据结构在每个时间步都会重建，并且只搜索那 $27$ 个单元。\n\n为了保证在保持邻居枚举最小化的同时，不错过任何接触对，应如何根据颗粒尺寸设置 $a$？哪个选项是最佳选择？\n\nA. 将 $a$ 设置为最小颗粒直径，即 $a = 2 r_{\\min}$，以保持每个单元的占据率较低。\n\nB. 将 $a$ 设置为至少与最大颗粒直径一样大，即 $a \\ge 2 r_{\\max}$，这样任何接触对都必然位于相同或相邻的单元中；取更小的 $a$ 可能会漏掉接触。\n\nC. 将 $a$ 设置为平均颗粒直径，即 $a = 2 \\langle r \\rangle$，以在平均水平上平衡精度和成本。\n\nD. 将 $a$ 设置为几何平均直径，即 $a = 2 \\sqrt{r_{\\min} r_{\\max}}$，因为它能限定大多数成对中心间距。", "solution": "### 步骤1：提取已知条件\n- 模拟方法：离散元法（DEM）。\n- 系统：$N$ 个多分散球形颗粒位于一个 $3$D 周期性立方体区域内。\n- 颗粒半径：$r_i$，最小值为 $r_{\\min}$，最大值为 $r_{\\max}$。\n- 相互作用条件：两个颗粒 $i$ 和 $j$ 接触，如果它们的中心距 $d_{ij}$ 满足 $d_{ij} \\le r_i + r_j$。\n- 邻域搜索算法：使用边长为 $a$ 的均匀立方体单元链表。\n- 搜索模板：对于任意给定颗粒，在其自身单元和 $26$ 个相邻单元（一个 $3 \\times 3 \\times 3$ 的单元块）中搜索候选邻居。\n- 重建策略：邻居数据结构在每个时间步重建，无任何额外缓冲区或“表皮”。\n- 目标：确定单元边长 $a$ 的条件，以保证不错过任何接触对，同时使邻居枚举最小化。\n\n### 步骤2：问题验证\n该问题描述了多颗粒系统中的一个标准短程相互作用场景，以及使用单元链表法（或单元网格法）进行高效邻域搜索。这是计算物理和分子动力学模拟中的一个基本且典型的问题。各组成部分如下：\n- **科学依据：** 该设置基于 DEM 和计算几何的既定原理。球体的接触条件和单元链表算法都是标准的。该问题在科学上是合理的。\n- **良态问题：** 该问题要求在特定搜索模板下，保证邻域搜索算法正确性的单元尺寸 $a$ 所需满足的条件。目标明确陈述：保证正确性，同时力求高效（“最小枚举”）。对于这个明确定义的问题，存在一个唯一的可推导条件。\n- **客观性：** 问题使用该领域通用的精确技术语言进行描述，没有歧义或主观性。\n\n问题陈述有效，可以进行解答。\n\n### 解答推导\n采用单元链表法旨在将寻找相互作用对的计算复杂度从 $\\mathcal{O}(N^2)$ 降低到 $\\mathcal{O}(N)$。该方法的正确性取决于单元尺寸 $a$ 的选择。问题规定，对于一个给定的颗粒，我们在以其所在单元为中心的 $3 \\times 3 \\times 3$ 单元块中搜索其邻居。这意味着，如果两个颗粒要被识别为潜在的相互作用对，它们必须位于至多是相邻的单元中。\n\n设两个颗粒 $i$ 和 $j$ 中心的位置矢量分别为 $\\vec{p}_i = (x_i, y_i, z_i)$ 和 $\\vec{p}_j = (x_j, y_j, z_j)$。一个位于位置 $(x, y, z)$ 的颗粒被分配到索引为 $(\\lfloor x/a \\rfloor, \\lfloor y/a \\rfloor, \\lfloor z/a \\rfloor)$ 的单元中。\n\n为使邻域搜索成功，如果两个颗粒 $i$ 和 $j$ 接触，它们沿每个维度的单元索引的绝对差值必须至多为 $1$。即：\n$$|\\lfloor x_i/a \\rfloor - \\lfloor x_j/a \\rfloor| \\le 1, \\quad |\\lfloor y_i/a \\rfloor - \\lfloor y_j/a \\rfloor| \\le 1, \\quad |\\lfloor z_i/a \\rfloor - \\lfloor z_j/a \\rfloor| \\le 1$$\n\n如果两个接触颗粒沿任意坐标轴的分离距离 $|x_i - x_j|$ 大于单元尺寸 $a$，那么它们就有可能被分配到不相邻的单元中，从而导致接触被遗漏。为保证对于任何相互作用对都不会发生这种情况，它们中心沿任意笛卡尔坐标轴的分离距离必须小于或等于单元尺寸 $a$。设 $\\Delta x = |x_i - x_j|$，$\\Delta y = |y_i - y_j|$，以及 $\\Delta z = |z_i - z_j|$。保证找到该对的条件是：\n$$\\max(\\Delta x, \\Delta y, \\Delta z) \\le a$$\n\n接触条件是 $d_{ij} = \\sqrt{(\\Delta x)^2 + (\\Delta y)^2 + (\\Delta z)^2} \\le r_i + r_j$。由于 $\\Delta x \\le d_{ij}$，我们可知对于任意两个接触的颗粒 $i$ 和 $j$：\n$$\\Delta x \\le d_{ij} \\le r_i + r_j$$\n\n为了确保对于*所有*可能的接触对都有 $\\Delta x \\le a$，$a$ 必须大于或等于右侧的最大可能值。最大可能的接触距离发生在系统中两个最大的颗粒接触时，即两个半径为 $r_{\\max}$ 的颗粒。它们的最大分离距离是 $r_{\\max} + r_{\\max} = 2 r_{\\max}$。\n\n因此，对 $a$ 的条件必须是：\n$$a \\ge \\max_{i,j \\text{ in contact}} (r_i + r_j) = r_{\\max} + r_{\\max} = 2 r_{\\max}$$\n\n如果 $a  2 r_{\\max}$，可以构造一个反例。设两个半径均为 $r_{\\max}$ 的颗粒接触，并沿 $x$ 轴对齐。它们的中心相距 $2 r_{\\max}$。如果我们选择 $a$ 使得 $a  2 r_{\\max}$，那么就有可能将这两个颗粒放置在不相邻的单元格中，导致这次接触被遗漏。\n\n为了使邻居枚举最小化，应该选择满足正确性准则的最小可能单元尺寸 $a$。这意味着选择不等式的下限，即 $a = 2 r_{\\max}$。因此，保证正确性的条件是 $a \\ge 2 r_{\\max}$。\n\n### 逐项分析\n\n**A. 将 $a$ 设置为最小颗粒直径，即 $a = 2 r_{\\min}$，以保持每个单元的占据率较低。**\n这个选择是有缺陷的。在 $r_{\\max} > r_{\\min}$ 的多分散系统中，我们可能会有 $a = 2 r_{\\min}  2 r_{\\max}$。如推导所示，如果 $a  2 r_{\\max}$，两个半径为 $r_{\\max}$ 的接触颗粒可能会被放置在不相邻的单元中。这将违反搜索保证。因此，该选项**不正确**。\n\n**B. 将 $a$ 设置为至少与最大颗粒直径一样大，即 $a \\ge 2 r_{\\max}$，这样任何接触对都必然位于相同或相邻的单元中；取更小的 $a$ 可能会漏掉接触。**\n这个陈述与推导出的条件 $a \\ge 2 r_{\\max}$ 完全一致。如果满足该条件，那么对于任何接触对 $(i, j)$，它们中心沿任意轴向的分离距离 $\\Delta x$ 满足 $\\Delta x \\le d_{ij} \\le r_i + r_j \\le 2 r_{\\max} \\le a$。这保证了颗粒位于相同或相邻的单元中。关于取更小的 $a$ 可能漏掉接触的说法也是正确的。该选项**正确**。\n\n**C. 将 $a$ 设置为平均颗粒直径，即 $a = 2 \\langle r \\rangle$，以在平均水平上平衡精度和成本。**\n使用平均值 $\\langle r \\rangle$ 来建立严格保证是不正确的。在任何非单分散系统中，$r_{\\max} > \\langle r \\rangle$。因此，该选择意味着 $a = 2 \\langle r \\rangle  2 r_{\\max}$。这无法处理两个大颗粒接触的最坏情况，并可能导致漏掉相互作用。问题要求的是保证，而不是平均情况下的性能。因此，该选项**不正确**。\n\n**D. 将 $a$ 设置为几何平均直径，即 $a = 2 \\sqrt{r_{\\min} r_{\\max}}$，因为它能限定大多数成对中心间距。**\n与算术平均值类似，几何平均值提供了一种集中趋势的度量。对于 $r_{\\min}  r_{\\max}$，我们有 $\\sqrt{r_{\\min} r_{\\max}}  r_{\\max}$。这意味着 $a = 2 \\sqrt{r_{\\min} r_{\\max}}  2 r_{\\max}$，这是一个不充分的条件。保证必须覆盖所有情况，而不是“大多数”情况。两个半径为 $r_{\\max}$ 的颗粒接触的最坏情况将无法被正确处理。因此，该选项**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2416939"}, {"introduction": "在实际的模拟中，系统通常采用周期性边界条件（PBC）来近似无限大的体系，这给邻域搜索带来了新的挑战。本练习 [@problem_id:2416982] 聚焦于一个棘手的场景——当模拟盒子尺寸较小（$L  3r_c$）时，粒子间的相互作用可能会“环绕”整个盒子。通过这个练习，你将深入理解如何正确地处理单元格尺寸 $a$、截断半径 $r_c$ 和盒子边长 $L$ 之间的相互关系，以确保在周期性边界条件下邻域搜索的准确性。", "problem": "一个边长为 $L$ 的三维立方模拟盒子，采用周期性边界条件 (PBC)，包含 $N$ 个粒子。这些粒子通过在截断半径 $r_c$ 处截断的短程对势相互作用。您计划使用链式列表（单元列表）邻域搜索算法，该算法将盒子在每个维度上划分为 $n$ 个单元，每个立方体单元的边长为 $a=L/n$，其中 $n$ 是一个正整数。邻域搜索必须找到最小镜像距离小于或等于 $r_c$ 的所有粒子对，并且每对相互作用的粒子必须只计算一次。考虑 $L  3r_c$ 的情况。\n\n在这种情况下，以下哪种策略是正确且足以确保周期性边界条件下算法正确性的？选择所有适用选项。\n\nA. 当 $2r_c \\le L  3r_c$ 时，选择 $n=2$，使得 $a=L/2 \\ge r_c$，并对每个单元，搜索标准的 $3 \\times 3 \\times 3$ 模板（单元自身及其所有面、边、角相邻的邻居单元），邻居单元的索引对 $2$ 取模以实现周期性边界条件。使用半壳层约定（例如，在同一单元内只考虑 $j>i$ 的粒子对，并只搜索邻居单元的一个固定子集）以避免重复计数。\n\nB. 对于任何 $L  3r_c$ 的情况，强制设定 $n=3$ 并仅使用标准的 $3 \\times 3 \\times 3$ 模板总是足够的，因为无论 $a$ 的大小如何，这都会覆盖每个方向上一个单元内的所有邻居。\n\nC. 当 $r_c  L  2r_c$ 时，选择 $n=1$，使得 $a=L$，然后对盒子中的所有粒子对应用最小镜像约定，从而进行暴力检查。\n\nD. 对于任何 $L  3r_c$ 的情况，使用幽灵单元（ghost cells）来处理周期性边界条件。这种方法通过在每个单元周围创建相邻单元粒子的周期性副本，消除了在搜索过程中对单元索引进行模运算或显式处理距离环绕的需求。", "solution": "该问题描述了一个标准的计算物理场景，涉及在具有周期性边界条件（PBC）的立方体盒子中，使用链式列表（单元列表）算法进行邻域搜索。所提出策略的有效性取决于该算法的基本原理，特别是在指定的小盒子情况下，即盒子边长 $L$ 小于势能截断半径 $r_c$ 的三倍（$L  3r_c$）。\n\n使用 $3 \\times 3 \\times 3$ 邻居单元模板的标准链式列表方法，其正确性的首要条件是单元边长 $a$ 必须大于或等于截断半径 $r_c$，即 $a \\ge r_c$。由于盒子在每个维度上被划分为 $n$ 个单元，我们有 $a = L/n$。该条件变为 $L/n \\ge r_c$，等价于 $n \\le L/r_c$。如果不满足此条件（即 $a  r_c$），那么距离小于 $r_c$ 的粒子对可能存在于非直接相邻的单元中，这使得 $3 \\times 3 \\times 3$ 的搜索模板变得不充分。在这种情况下，搜索模板必须扩展以覆盖更大的范围。周期性边界条件的实现需要通过模运算来“环绕”单元索引。为避免重复计算相互作用对，必须采用“半壳层”约定，即只搜索邻居单元的一个非冗余子集。\n\n问题陈述在科学上是合理的，问题定义良好且客观。我们现在开始评估每个提出的策略。\n\n**A. 当 $2r_c \\le L  3r_c$ 时，选择 $n=2$，使得 $a=L/2 \\ge r_c$ ...**\n建议的范围是 $2r_c \\le L  3r_c$。该策略建议将每个维度的单元数设置为 $n=2$，导致单元边长为 $a = L/2$。根据给定的条件 $2r_c \\le L$，两边除以2可得 $r_c \\le L/2$，即 $r_c \\le a$。由于基本条件 $a \\ge r_c$ 得到满足，使用标准的 $3 \\times 3 \\times 3$ 邻居单元模板确实是正确且足以找到所有相互作用对的。使用对 $n=2$ 取模的环绕单元索引是处理周期性边界条件的正确方法。提及使用半壳层约定来避免重复计算也是正确实现的必要细节。此策略是完全合理的。\n结论：**正确**。\n\n**B. 对于任何 $L  3r_c$ 的情况，强制设定 $n=3$ ...**\n该策略建议对于任何 $L  3r_c$ 的情况都设置 $n=3$。单元边长将为 $a = L/3$。从条件 $L  3r_c$ 可得 $L/3  r_c$，即 $a  r_c$。如前所述，如果单元尺寸 $a$ 小于截断半径 $r_c$，标准的 $3 \\times 3 \\times 3$ 模板是不充分的。两个粒子之间的距离可能小于 $r_c$，但它们却位于非直接相邻的单元中。因此，这个策略存在根本性缺陷。\n结论：**错误**。\n\n**C. 当 $r_c  L  2r_c$ 时，选择 $n=1$ ...**\n该策略建议在 $r_c  L  2r_c$ 的条件下设置 $n=1$。这将导致只有一个单元，其边长 $a=L$ 等于整个盒子的边长。在这种情况下，所有粒子都在同一个单元中。邻域搜索退化为对所有粒子对进行暴力检查。由于我们检查了所有可能的粒子对，并使用最小镜像约定计算它们的距离，因此不可能漏掉任何相互作用。虽然效率不高，但这种方法在逻辑上是正确的。\n结论：**正确**。\n\n**D. 对于任何 $L  3r_c$ 的情况，使用幽灵单元来处理周期性边界条件...**\n该选项描述的是一种实现技术（幽灵单元），而不是一个完整的、自洽的策略。幽灵单元是处理周期性边界条件的一种有效方法，它通过在每个子域周围创建填充了周期性副本的“幽灵”层来简化搜索逻辑。然而，该选项本身并未指定关键参数，如单元数 $n$ 或单元尺寸 $a$。仅仅“使用幽灵单元”并不能保证正确性。例如，如果在此框架下选择了一个不合适的单元尺寸（如 $a  r_c$）而没有相应地扩大搜索模板，算法仍然会失败。选项 A 和 C 提供了关于如何根据 $L$ 和 $r_c$ 设置 $n$ 的具体、可操作的规则，从而构成了完整的策略。相比之下，选项 D 只是提出了一个方法论，但缺乏使其成为一个可保证正确性的独立策略的必要规定。\n结论：**不充分/错误**。", "answer": "$$\\boxed{AC}$$", "id": "2416982"}, {"introduction": "为了模拟数百万甚至数十亿粒子的系统，单处理器计算已远远不够，必须采用并行计算。本编码练习 [@problem_id:2416963] 将带你实践一种核心的并行化技术——区域分解法，用于邻域搜索。你将学习如何通过引入“幽灵单元”（ghost cells）来处理跨越处理器边界的相互作用，并设计正确的计数规则以避免重复计算，这是现代大规模科学计算中的一项关键技能。", "problem": "给定一个边长为 $L_x$ 和 $L_y$ 的二维周期性域，其中包含 $N$ 个位置固定的点粒子 $\\{(x_i,y_i)\\}_{i=1}^N$。两个粒子 $i$ 和 $j$ 构成一个相互作用对，当且仅当它们在周期性域上遵循最小镜像约定的欧几里得距离小于或等于一个预设的截断半径 $r_c$。最小镜像距离定义如下：对于任意坐标差 $\\Delta x = x_j - x_i$，其周期性差值为 $\\Delta x' = \\Delta x - \\operatorname{round}\\left(\\frac{\\Delta x}{L_x}\\right)L_x$。类似地，$\\Delta y' = y_j - y_i - \\operatorname{round}\\left(\\frac{y_j - y_i}{L_y}\\right)L_y$。距离为 $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$。一个唯一的相互作用对是任意满足 $d_{ij} \\le r_c$ 的无序索引对 $(i,j)$，其中 $1 \\le i  j \\le N$。\n\n该域在逻辑上被分解为 $P_x$ 个不重叠的子域，方法是沿 $x$ 方向将区间 $[0,L_x)$ 划分为宽度为 $L_x/P_x$ 的等宽条带，并在 $x=0$ 和 $x=L_x$ 处施加周期性边界条件。对于 $k \\in \\{0,1,\\dots,P_x-1\\}$，第 $k$ 个子域沿 $x$ 方向的区间为 $[k L_x/P_x,(k+1)L_x/P_x)$，沿 $y$ 方向则覆盖整个区间 $[0,L_y)$。每个子域通过在其左右 $x$ 边界各增加一个宽度为 $r_c$ 的幽灵区域来扩充其本地粒子，导入任何其周期性 $x$ 坐标位于任一边界 $r_c$ 距离内的粒子。相互作用对的枚举必须保证每个满足 $1 \\le i  j \\le N$ 和 $d_{ij} \\le r_c$ 的无序对 $(i,j)$ 在全局范围内被精确计数一次，尽管幽灵区域会引入重复计算。\n\n您的程序必须对下面的每个测试用例使用一种遵循上述子域分解和幽灵区域描述的算法，计算整个域中唯一相互作用对的总数。所有坐标都使用相同的任意长度单位，并且 $r_c$、$L_x$ 和 $L_y$ 也使用该单位。程序必须使用准则 $d_{ij} \\le r_c$ 来处理所有与截断值的比较。\n\n您的程序将使用的测试套件：\n- 测试用例 $1$ (一般情况): $L_x = 10.0$, $L_y = 10.0$, $r_c = 2.1$, $P_x = 3$，粒子位置由有序列表给出\n$\\left[(1.0,1.0),(2.5,1.0),(3.9,1.0),(4.8,9.5),(4.8,0.6),(9.6,5.0),(0.4,5.0),(6.7,5.0)\\right]$。\n- 测试用例 $2$ (边界与等值情况): $L_x = 8.0$, $L_y = 8.0$, $r_c = 2.0$, $P_x = 2$，粒子位置为\n$\\left[(0.5,0.5),(7.5,0.5),(4.0,4.0),(6.0,4.0)\\right]$。\n- 测试用例 $3$ (包含空子域的稀疏情况): $L_x = 5.0$, $L_y = 5.0$, $r_c = 0.9$, $P_x = 4$，粒子位置为\n$\\left[(0.2,0.2),(2.6,4.7),(4.8,2.5)\\right]$。\n\n最终输出格式：您的程序应生成单行输出，其中包含所有三个测试用例的结果，结果为逗号分隔的列表，并用方括号括起来，顺序与上述测试用例相同。每个结果必须是等于唯一相互作用对数量的整数，因此输出形式必须为 $[\\text{n}_1,\\text{n}_2,\\text{n}_3]$，其中每个 $\\text{n}_k$ 是一个整数。", "solution": "所提出的问题是一个有效的计算物理练习。它具有科学依据、是适定且客观的。它描述了一种在分子模拟中用于高效计算短程相互作用的标准域分解技术。所有参数和条件都已指定，从而允许一个唯一且可验证的解。我们将开始进行求解。\n\n该问题要求我们计算一个二维周期性域内唯一相互作用粒子对的总数。任务的核心是实现一个基于域分解的并行计算策略，其中域被划分为垂直的条带（子域）。为了正确计算跨越子域边界的相互作用，每个子域不仅必须考虑其“本地”粒子，还必须考虑来自相邻区域的“幽灵”粒子。\n\n解决方案所基于的基本原则如下：\n\n1.  **最小镜像约定 (MIC)**：在周期性系统中，一个粒子与所有其他粒子的最近周期性镜像相互作用。距离计算必须考虑周期性边界。对于一个大小为 $L_x \\times L_y$ 的域中的粒子对，其坐标差为 $\\Delta x$ 和 $\\Delta y$，MIC 规定有效分离矢量的分量为 $\\Delta x' = \\Delta x - L_x \\cdot \\operatorname{round}(\\frac{\\Delta x}{L_x})$ 和 $\\Delta y' = \\Delta y - L_y \\cdot \\operatorname{round}(\\frac{\\Delta y}{L_y})$。距离则为 $d_{ij} = \\sqrt{(\\Delta x')^2 + (\\Delta y')^2}$。如果 $d_{ij} \\le r_c$，则发生相互作用，其中 $r_c$ 是截断半径。为了计算效率，我们将比较距离的平方：$d_{ij}^2 \\le r_c^2$。\n\n2.  **域分解**：全局域沿 $x$ 轴被分解为 $P_x$ 个子域。每个粒子根据其 $x$ 坐标被唯一地分配给一个“属主”或“本地”子域。这种分配是排他的；坐标为 $x_i$ 的粒子 $i$ 属于子域 $k$，如果 $x_i \\in [k \\cdot L_x/P_x, (k+1) \\cdot L_x/P_x)$。\n\n3.  **幽灵区域**：对于位于子域 $k$ 中的粒子 $i$，任何与之相互作用的伙伴 $j$ 都必须位于 $r_c$ 的距离之内。这意味着它们的周期性 $x$ 距离至多为 $r_c$。因此，为了找到涉及其本地粒子的所有对，子域 $k$ 只需要导入位于其自身边界 $r_c$ 宽度“幽灵层”内的粒子副本（幽灵粒子）。\n\n4.  **唯一对计数**：为防止对 $(i, j)$ 的重复计数（例如，子域 $k$ 计数了 $(i, j)$，而子域 $m$ 也计数了 $(j, i)$），需要一个严格的计数协议。一个通用且正确的约定是将计数对 $(i, j)$ 的责任分配给“拥有”索引较小粒子的子域。算法将按如下方式构建：子域 $k$ 遍历其本地粒子 $i$。对于每个这样的 $i$，它检查与在其扩展区域内的所有其他粒子 $j$（包括本地和幽灵粒子）的相互作用，但仅当原始粒子索引满足 $i  j$ 时才计数该对。这保证了每个唯一的对 $(i, j)$ 由拥有粒子 $i$ 的属主子域精确地考虑计数一次。\n\n算法对每个测试用例按以下步骤进行：\n\n1.  **初始化**：对于给定的测试用例，其参数为 $L_x, L_y, r_c, P_x$ 以及 $N$ 个粒子位置，我们将总对数初始化为 $0$。我们计算截断半径的平方 $r_c^2$ 和每个子域的宽度 $W = L_x / P_x$。\n\n2.  **粒子归属**：$N$ 个粒子中的每一个都被分配给一个属主子域。对于位于位置 $(x_i, y_i)$ 的粒子 $i$，其属主子域索引 $k$ 计算为 $k = \\lfloor x_i / W \\rfloor$。我们必须确保 $k$ 被裁剪到范围 $[0, P_x-1]$ 内。\n\n3.  **子域迭代**：我们从 $0$ 到 $P_x-1$ 遍历每个子域 $k$。\n\n4.  **识别本地和幽灵粒子**：对于当前子域 $k$，我们首先确定其本地粒子的索引集合 $L_k$。然后，我们构建一个更大的索引集合 $S_k$，其中包含该子域扩展区域内的所有粒子。子域 $k$ 的区域覆盖 $[k \\cdot W, (k+1) \\cdot W)$，其扩展区域沿 $x$ 轴由 $[k \\cdot W - r_c, (k+1) \\cdot W + r_c)$ 给出。位于位置 $x_j$ 的粒子 $j$ 属于此扩展区域，如果它的任何一个周期性镜像 $x_j + m \\cdot L_x$（其中 $m \\in \\{-1, 0, 1\\}$）落在此区间内。\n\n5.  **对计数**：对于当前子域 $k$，我们遍历其每个本地粒子 $i \\in L_k$。对于每个 $i$，我们再遍历所有满足索引条件 $i  j$ 的粒子 $j \\in S_k$。对于每个这样的对 $(i, j)$，我们计算 MIC 距离的平方 $d_{ij}^2$。如果 $d_{ij}^2 \\le r_c^2$，我们就将总对数加一。\n\n6.  **最终结果**：遍历所有子域后，累计的总对数即为该测试用例的最终答案。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(Lx, Ly, rc, Px, positions):\n    \"\"\"\n    Computes the number of interacting pairs for a single test case\n    using a domain decomposition algorithm.\n    \"\"\"\n    particles = np.array(positions, dtype=np.float64)\n    N = len(particles)\n    if N == 0:\n        return 0\n        \n    rc_sq = rc**2\n    subdomain_width = Lx / Px\n\n    # Assign each particle to an owner subdomain based on its x-coordinate.\n    # The interval for subdomain k is [k*width, (k+1)*width).\n    # np.floor(x / width) correctly assigns particles to subdomains.\n    # We clip to handle the case where a particle might be exactly at x=Lx.\n    owner = np.floor(particles[:, 0] / subdomain_width).astype(int)\n    owner = np.clip(owner, 0, Px - 1)\n\n    total_pairs = 0\n    box_dims = np.array([Lx, Ly])\n\n    def mic_dist_sq(p1, p2):\n        \"\"\"Calculates the squared Euclidean distance under the Minimum Image Convention.\"\"\"\n        delta = p2 - p1\n        # This implements delta' = delta - L * round(delta/L)\n        delta -= box_dims * np.round(delta / box_dims)\n        return np.dot(delta, delta)\n\n    # Iterate through each subdomain\n    for k in range(Px):\n        # Identify particles local to this subdomain\n        local_indices = np.where(owner == k)[0]\n        \n        # If the subdomain is empty, no pairs will be counted by it.\n        if len(local_indices) == 0:\n            continue\n\n        # Identify all particles in the extended subdomain (local + ghosts)\n        # The extended region for subdomain k is [xmin - rc, xmax + rc).\n        xmin = k * subdomain_width\n        xmax = (k + 1) * subdomain_width\n        ext_min = xmin - rc\n        ext_max = xmax + rc\n\n        subdomain_particle_indices = []\n        for j in range(N):\n            x_j = particles[j, 0]\n            # Check if particle j or its periodic images fall in the extended region.\n            # Checking images at m=-1, 0, 1 is sufficient for rc  Lx/2.\n            if (ext_min = x_j  ext_max) or \\\n               (ext_min = x_j + Lx  ext_max) or \\\n               (ext_min = x_j - Lx  ext_max):\n                subdomain_particle_indices.append(j)\n        \n        # Count pairs according to the rule:\n        # Particle i must be local to subdomain k.\n        # Particle j can be local or ghost.\n        # The index condition i  j ensures each pair is counted only once.\n        for i in local_indices:\n            for j in subdomain_particle_indices:\n                if i  j:\n                    if mic_dist_sq(particles[i], particles[j]) = rc_sq:\n                        total_pairs += 1\n\n    return total_pairs\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"Lx\": 10.0, \"Ly\": 10.0, \"rc\": 2.1, \"Px\": 3,\n            \"positions\": [(1.0, 1.0), (2.5, 1.0), (3.9, 1.0), (4.8, 9.5), \n                          (4.8, 0.6), (9.6, 5.0), (0.4, 5.0), (6.7, 5.0)]\n        },\n        # Test case 2\n        {\n            \"Lx\": 8.0, \"Ly\": 8.0, \"rc\": 2.0, \"Px\": 2,\n            \"positions\": [(0.5, 0.5), (7.5, 0.5), (4.0, 4.0), (6.0, 4.0)]\n        },\n        # Test case 3\n        {\n            \"Lx\": 5.0, \"Ly\": 5.0, \"rc\": 0.9, \"Px\": 4,\n            \"positions\": [(0.2, 0.2), (2.6, 4.7), (4.8, 2.5)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        num_pairs = solve_case(\n            case[\"Lx\"], case[\"Ly\"], case[\"rc\"], case[\"Px\"], case[\"positions\"]\n        )\n        results.append(num_pairs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2416963"}]}