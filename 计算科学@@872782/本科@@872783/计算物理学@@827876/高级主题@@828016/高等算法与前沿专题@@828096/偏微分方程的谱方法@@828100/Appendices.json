{"hands_on_practices": [{"introduction": "在开始编写任何代码之前，理解离散网格的一个基本性质至关重要。当我们在离散点上对一个连续函数进行采样时，高频分量有时会“伪装”成低频分量，这种现象被称为混叠。这个练习将通过构造一个高波数余弦函数来探索混叠效应，该函数在特定网格上与一个低波数余弦函数完全无法区分。这项练习 ([@problem_id:2440939]) 能够为我们建立关于奈奎斯特极限的关键直觉，并帮助我们避免对数值结果的错误解读，这是谱方法中一个常见的陷阱。", "problem": "考虑一个与偏微分方程（PDE）谱方法相关的周期性标量场的傅里叶伪谱离散化。设空间域为 $[0,2\\pi)$，具有周期性边界条件，且粗网格由 $N=12$ 个等距点 $x_j=\\frac{2\\pi j}{N}$（$j=0,1,\\dots, N-1$）组成。假设我们感兴趣的低频模式是 $\\cos(3x)$。构造一个连续函数 $f(x)$，该函数由单一高频余弦分量组成，其波数严格大于奈奎斯特波数 $\\frac{N}{2}$，使得在粗网格点上对 $f(x)$ 进行采样所得到的值，与在相同点上对 $\\cos(3x)$ 采样所得的值完全相同（对所有 $j=0,1,\\dots, N-1$）。请以关于 $x$ 的闭式解析表达式给出您的答案 $f(x)$。所有角度必须以弧度为单位。", "solution": "该问题要求构造一个高频余弦函数 $f(x)$，它在离散网格上是低频余弦函数 $g(x) = \\cos(3x)$ 的一个混叠。这是谱方法中一个称为混叠的基本概念。\n\n首先，让我们将给定的信息形式化。\n空间域为 $[0, 2\\pi)$，具有周期性边界条件。\n离散化网格由 $N=12$ 个等距点组成，定义为 $x_j = \\frac{2\\pi j}{N}$（$j=0, 1, \\dots, N-1$）。\n低频函数是 $g(x) = \\cos(kx)$，其波数为 $k=3$。\n目标高频函数的形式为 $f(x) = \\cos(k'x)$，其中波数 $k'$ 必须满足 $k' > k_{Nyquist}$。奈奎斯特波数定义为 $k_{Nyquist} = \\frac{N}{2}$，在本例中为 $\\frac{12}{2} = 6$。因此，我们要求 $k' > 6$。\n核心条件是这两个函数在网格上采样时必须完全相同：\n$$f(x_j) = g(x_j) \\quad \\forall j \\in \\{0, 1, \\dots, N-1\\}$$\n代入函数形式，我们得到：\n$$\\cos(k'x_j) = \\cos(3x_j)$$\n\n为了使等式 $\\cos(A) = \\cos(B)$ 成立，必须有 $A = \\pm B + 2\\pi m$（对于某个整数 $m$）。将此应用于我们在每个网格点 $x_j$ 上的条件：\n$$k'x_j = \\pm 3x_j + 2\\pi m_j$$\n其中 $m_j$ 是一个可能依赖于 $j$ 的整数。\n代入 $x_j = \\frac{2\\pi j}{N}$：\n$$k' \\frac{2\\pi j}{N} = \\pm 3 \\frac{2\\pi j}{N} + 2\\pi m_j$$\n两边除以 $2\\pi$，我们发现：\n$$\\frac{k'j}{N} = \\pm \\frac{3j}{N} + m_j$$\n这意味着对于所有 $j \\in \\{0, 1, \\dots, N-1\\}$，$(k' \\mp 3)\\frac{j}{N}$ 都必须是整数。为了使此条件对所有 $j$（包括 $j=1$）都成立，项 $(k' \\mp 3)$ 必须是 $N$ 的整数倍。\n设 $m$ 是一个整数。因此，在大小为 $N$ 的网格上，两个波数 $k'$ 和 $k$ 之间发生混叠的条件是：\n$$k' = \\pm k + mN$$\n这个关系定义了在离散网格上所有与波数 $k$ 无法区分的波数。\n\n在我们的问题中，有 $k=3$ 和 $N=12$。我们正在寻找一个波数 $k'$，使得：\n$$k' = \\pm 3 + m \\cdot 12$$\n并且 $k' > 6$。我们按照惯例假设波数为非负整数。因此，我们寻找满足 $k' = |\\pm 3 + 12m| > 6$ 的 $k'$。\n\n让我们检查整数 $m$ 的不同取值：\n- 如果 $m=0$：$k' = |\\pm 3 + 0| = 3$。这是原始波数，不大于 $6$。\n- 如果 $m=1$：\n  - $k' = |3 + 12(1)| = 15$。这满足条件 $15 > 6$。\n  - $k' = |-3 + 12(1)| = |9| = 9$。这也满足条件 $9 > 6$。\n- 如果 $m=-1$：\n  - $k' = |3 + 12(-1)| = |-9| = 9$。这与 $m=1$ 的一个结果相同。\n  - $k' = |-3 + 12(-1)| = |-15| = 15$。这也与 $m=1$ 的一个结果相同。\n- 如果 $m=2$：\n  - $k' = |3 + 12(2)| = 27$。\n  - $k' = |-3 + 12(2)| = 21$。\n\n在此网格上与 $k=3$ 发生混叠的可能的高频波数集合包括 $\\{9, 15, 21, 27, \\dots\\}$。问题要求构造 *一个* 这样的函数。最简单的选择是对应于最小有效波数的那个，即 $k'=9$。\n\n因此，一个满足所有给定条件的连续函数是 $f(x) = \\cos(9x)$。\n\n让我们验证这个解。我们需要证明对于 $x_j = \\frac{2\\pi j}{12} = \\frac{\\pi j}{6}$，有 $\\cos(9x_j) = \\cos(3x_j)$。\n网格上的值是 $\\cos(9 \\frac{\\pi j}{6}) = \\cos(\\frac{3\\pi j}{2})$ 和 $\\cos(3 \\frac{\\pi j}{6}) = \\cos(\\frac{\\pi j}{2})$。\n混叠关系为 $k' = mN-k$，所以 $9 = 1 \\cdot 12 - 3$。\n在网格点 $x_j$ 处，我们有：\n$$\\cos(k'x_j) = \\cos((mN-k)x_j) = \\cos\\left((mN-k)\\frac{2\\pi j}{N}\\right) = \\cos\\left(2\\pi mj - \\frac{2\\pi kj}{N}\\right)$$\n使用余弦差角恒等式 $\\cos(A-B) = \\cos(A)\\cos(B) + \\sin(A)\\sin(B)$，其中 $A=2\\pi mj$ 且 $B=\\frac{2\\pi kj}{N} = kx_j$。由于 $m$ 和 $j$ 都是整数，$A$ 是 $2\\pi$ 的整数倍，所以 $\\cos(A)=1$ 且 $\\sin(A)=0$。\n因此，\n$$\\cos(k'x_j) = (1)\\cos(kx_j) + (0)\\sin(kx_j) = \\cos(kx_j)$$\n当 $k'=9$、$k=3$ 和 $N=12$ 时，此恒等式成立，证实了 $\\cos(9x)$ 确实是在指定网格上 $\\cos(3x)$ 的一个混叠。所选函数 $f(x)=\\cos(9x)$ 满足所有标准。", "answer": "$$\\boxed{\\cos(9x)}$$", "id": "2440939"}, {"introduction": "掌握了混叠的概念之后，我们现在可以满怀信心地应用谱方法了，首先从最理想的情况开始：周期性区域，傅里叶方法在此类问题上表现得异常强大。我们将求解双调和方程 $\\nabla^4 u = f$，在傅里叶空间中，复杂的 $\\nabla^4$ 算子变成了一个简单的代数乘法，从而将一个偏微分方程转化为一组易于求解的代数方程。这个编程练习 ([@problem_id:2440935]) 展示了傅里叶谱方法的核心优势——简洁与高效，揭示了如何使用快速傅里叶变换 (FFT) 通过几行代码就解决一个看似困难的高阶偏微分方程。", "problem": "考虑在周期性方形域上的二维双调和方程，\n$$\\nabla^4 u(x,y) = f(x,y), \\quad (x,y) \\in [0,1)\\times[0,1),$$\n在两个空间方向上均具有周期性边界条件。假设强迫项 $f$ 的空间平均值为零，这对于周期性边界条件下的可解性是必要的。您将构建一个基于谱方法的数值求解器，以从给定的 $f$ 中恢复 $u$。\n\n使用以下基本基底。\n- 用傅里叶级数表示足够光滑的周期函数。在周期域上，物理空间中的微分对应于傅里叶空间中与角波数的乘法：如果 $\\widehat{u}(\\kappa_x,\\kappa_y)$ 表示角波数 $(\\kappa_x,\\kappa_y)$ 处的傅里叶系数，则应用空间导数 $\\partial/\\partial x$ 对应于乘以 $i\\kappa_x$，对 $\\partial/\\partial y$ 也类似。因此，拉普拉斯算子满足 $\\widehat{\\nabla^2 u}(\\kappa_x,\\kappa_y) = -(\\kappa_x^2+\\kappa_y^2)\\widehat{u}(\\kappa_x,\\kappa_y)$。\n- 离散傅里叶变换 (DFT) 通过快速傅里叶变换 (FFT) 高效实现，它通过将网格值映射到离散傅里叶系数来近似这些运算。使用与广泛使用的数值库一致的标准离散傅里叶变换约定。角度以弧度为单位。\n\n设计并实现一个程序，该程序：\n- 在一个均匀的 $N\\times N$ 网格上离散化 $[0,1)\\times[0,1)$，网格点为 $x_j = j/N$ 和 $y_k = k/N$，其中整数 $j,k \\in \\{0,1,\\dots,N-1\\}$。\n- 使用离散傅里叶变换转换到傅里叶空间，在傅里叶空间中应用两次拉普拉斯算子，然后逆变换回物理空间以近似 $u$。通过将 $u$ 的零傅里叶模式设置为零来强制执行零均值解。以数学上一致的方式小心处理零波数的除法。\n- 对下面的每个测试用例，计算均方根误差，\n$$\\mathrm{RMS}(u_{\\mathrm{num}},u_{\\mathrm{exact}})=\\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left(u_{\\mathrm{num}}(x_j,y_k)-u_{\\mathrm{exact}}(x_j,y_k)\\right)^2},$$\n\n测试套件。对于每个用例，从指定的精确解 $u_{\\mathrm{exact}}$ 解析地构造 $f$。令 $\\pi$ 表示通常的圆周常数，并使用 $\\sin$ 和 $\\cos$ 的参数以弧度为单位的约定。通过 $\\kappa_x = 2\\pi n_x$ 和 $\\kappa_y = 2\\pi n_y$ 定义角波数，其中 $n_x$ 和 $n_y$ 分别是 $x$ 和 $y$ 方向上的整数模数。对于具有模数 $(n_x,n_y)$ 的纯傅里叶模式，双调和算子将该模式乘以 $(\\kappa_x^2+\\kappa_y^2)^2$。\n\n- 用例 A (常规情况): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。则\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+1^2\\big)\\right)^2\\,u_{\\mathrm{exact}}(x,y).$$\n- 用例 B (分辨率变更): $N = 64$, $u_{\\mathrm{exact}}(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$。$f$ 的公式与用例 A 相同。\n- 用例 C (不同模式的叠加): $N = 32$, $u_{\\mathrm{exact}}(x,y) = \\cos(2\\pi x) + \\cos(4\\pi y)$。则\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\big(1^2+0^2\\big)\\right)^2\\cos(2\\pi x) \\;+\\; \\left(\\big(2\\pi\\big)^2\\big(0^2+2^2\\big)\\right)^2\\cos(4\\pi y).$$\n- 用例 D (奇数 $N$ 和混合高阶模式): $N = 33$, $u_{\\mathrm{exact}}(x,y) = \\sin(6\\pi x)\\sin(2\\pi y) - 2\\cos(2\\pi x)\\cos(6\\pi y)$。这里 $(n_x,n_y)=(3,1)$ 和 $(n_x,n_y)=(1,3)$ 都有 $n_x^2+n_y^2 = 10$，所以\n$$f(x,y) = \\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\sin(6\\pi x)\\sin(2\\pi y) \\;-\\; 2\\left(\\big(2\\pi\\big)^2\\cdot 10\\right)^2\\cos(2\\pi x)\\cos(6\\pi y).$$\n- 用例 E (零强迫项的边界情况): $N = 40$, $u_{\\mathrm{exact}}(x,y) \\equiv 0$, 所以 $f(x,y)\\equiv 0$。\n\n您的程序应计算每个测试用例的数值解 $u_{\\mathrm{num}}$，并输出相应的均方根误差作为浮点数。最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中 $r_i$ 是用例 $i$ 的均方根误差。不应打印额外的文本。", "solution": "问题陈述经过审阅并被确认为有效。它提出了一个计算物理学中良定的数学问题，该问题基于偏微分方程和谱分析的既定原理。所有数据和条件都足以推导出一个唯一的、可验证的数值解。因此，我将继续提供一个完整的解决方案。\n\n问题是在周期域 $(x,y) \\in [0,1) \\times [0,1)$ 上求解二维双调和方程，\n$$ \\nabla^4 u(x,y) = f(x,y) $$\n算子 $\\nabla^4$ 是双拉普拉斯算子，定义为 $\\nabla^2(\\nabla^2 u)$。域的周期性使得傅里叶级数成为表示解 $u(x,y)$ 和强迫项 $f(x,y)$ 的理想基底选择。\n\n在该域上足够光滑的周期函数 $g(x,y)$ 可以由其复傅里叶级数表示：\n$$ g(x,y) = \\sum_{n_x=-\\infty}^{\\infty} \\sum_{n_y=-\\infty}^{\\infty} \\widehat{g}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\n其中 $n_x$ 和 $n_y$ 是整数波数，$\\widehat{g}_{n_x,n_y}$ 是复傅里叶系数。傅里叶级数的一个基本性质是，空间微分在傅里叶域中转变为代数乘法。将拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 应用于函数 $u(x,y)$ 得到：\n$$ \\nabla^2 u(x,y) = \\sum_{n_x,n_y} \\left( (i 2\\pi n_x)^2 + (i 2\\pi n_y)^2 \\right) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} = \\sum_{n_x,n_y} -(2\\pi)^2(n_x^2 + n_y^2) \\widehat{u}_{n_x,n_y} e^{i 2\\pi (n_x x + n_y y)} $$\n因此，$\\nabla^2 u$ 的傅里叶系数与 $u$ 的傅里叶系数通过 $\\widehat{\\nabla^2 u}_{n_x,n_y} = -K^2 \\widehat{u}_{n_x,n_y}$ 相关，其中 $K^2 = (2\\pi n_x)^2 + (2\\pi n_y)^2 = \\kappa_x^2 + \\kappa_y^2$ 是波矢量的平方大小。\n\n应用两次拉普拉斯算子，我们发现在傅里叶空间中双调和算子的作用：\n$$ \\widehat{\\nabla^4 u}_{n_x,n_y} = (-\\kappa_x^2 - \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} $$\n因此，原始的偏微分方程 $\\nabla^4 u = f$ 转变为一组关于傅里叶系数的代数方程：\n$$ (\\kappa_x^2 + \\kappa_y^2)^2 \\widehat{u}_{n_x,n_y} = \\widehat{f}_{n_x,n_y} $$\n我们可以解出 $\\widehat{u}_{n_x,n_y}$：\n$$ \\widehat{u}_{n_x,n_y} = \\frac{\\widehat{f}_{n_x,n_y}}{(\\kappa_x^2 + \\kappa_y^2)^2} = \\frac{\\widehat{f}_{n_x,n_y}}{(2\\pi)^4(n_x^2 + n_y^2)^2} $$\n此表达式对除零波数模式 $(0,0)$ 外的所有波数 $(n_x, n_y)$ 均有效。对于此模式，分母为零。相应的分子 $\\widehat{f}_{0,0}$ 表示强迫函数 $f(x,y)$ 在域上的空间平均值。在周期域上求解双调和方程的一个必要条件是该平均值必须为零，即 $\\widehat{f}_{0,0} = 0$。这导致 $\\widehat{u}_{0,0}$ 的形式为不定的 $0/0$。$\\widehat{u}_{0,0}$ 的值，即解 $u(x,y)$ 的空间平均值，不由该方程确定。为确保唯一解，我们强制执行问题的约束，即解具有零均值，这等同于设置 $\\widehat{u}_{0,0} = 0$。\n\n数值算法使用离散傅里叶变换 (DFT) 实现了此过程的离散模拟，DFT 通过快速傅里叶变换 (FFT) 高效计算。\n\n算法流程如下：\n$1$。将域 $[0,1) \\times [0,1)$ 在一个均匀的 $N \\times N$ 网格上离散化，网格点为 $(x_j, y_k) = (j/N, k/N)$，其中 $j, k \\in \\{0, 1, \\dots, N-1\\}$。在该网格上评估强迫函数 $f(x,y)$，以生成矩阵 $F_{jk} = f(x_j, y_k)$。\n\n$2$。计算矩阵 $F$ 的二维 FFT，以获得离散傅里叶系数 $\\widehat{F}$。这是 $\\widehat{f}_{n_x,n_y}$ 的一个近似。\n$$ \\widehat{F} = \\mathrm{FFT2D}(F) $$\n\n$3$。生成一个对应的 $N \\times N$ 网格的离散整数波数 $(n_x, n_y)$。对于用 $N$ 个点离散化的长度为 $1$ 的域，与 FFT 输出数组对应的整数波数由序列 $[0, 1, \\dots, N/2-1, -N/2, \\dots, -1]$（对于偶数 $N$）或类似序列（对于奇数 $N$）给出，这可以使用像 `numpy.fft.fftfreq` 这样的库函数生成。\n\n$4$。在傅里叶域中应用双调和算子，方法是将系数 $\\widehat{F}_{n_x,n_y}$ 除以算子符号的离散版本 $L_{n_x,n_y} = \\left( (2\\pi n_x)^2 + (2\\pi n_y)^2 \\right)^2$。零波数模式被单独处理。\n$$ \\widehat{U}_{n_x,n_y} = \\begin{cases} \\widehat{F}_{n_x,n_y} / L_{n_x,n_y}  \\text{if } (n_x, n_y) \\neq (0,0) \\\\ 0  \\text{if } (n_x, n_y) = (0,0) \\end{cases} $$\n此步骤正确处理了奇点并强制执行了零均值解约束。\n\n$5$。通过对系数矩阵 $\\widehat{U}$ 应用二维逆 FFT，恢复网格上的数值解 $U_{\\mathrm{num}}$。\n$$ U_{\\mathrm{num}} = \\mathrm{real}(\\mathrm{IFFT2D}(\\widehat{U})) $$\n取实部是为了舍弃由浮点不精确性产生的可忽略的虚部。\n\n$6$。最后，通过比较数值解 $U_{\\mathrm{num}}$ 和在网格上评估的精确解 $U_{\\mathrm{exact}}$ 来计算均方根误差：\n$$ \\mathrm{RMS} = \\sqrt{\\frac{1}{N^2}\\sum_{j=0}^{N-1}\\sum_{k=0}^{N-1}\\left( (U_{\\mathrm{num}})_{jk} - (U_{\\mathrm{exact}})_{jk} \\right)^2} $$\n此过程应用于每个测试用例，以得出所需的误差值。由于所有精确解都由低波数的正弦波组成，这些正弦波在指定的网格上可以被完美表示，因此预期误差在机器浮点精度的数量级上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D biharmonic equation on a periodic domain using a spectral method\n    and calculates the RMS error for several test cases.\n    \"\"\"\n    pi = np.pi\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 64,\n            'u_exact': lambda x, y: np.sin(2*pi*x) * np.sin(2*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 1**2))**2 * (np.sin(2*pi*x) * np.sin(2*pi*y))\n        },\n        {\n            'N': 32,\n            'u_exact': lambda x, y: np.cos(2*pi*x) + np.cos(4*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * (1**2 + 0**2))**2 * np.cos(2*pi*x) + \\\n                              ((2*pi)**2 * (0**2 + 2**2))**2 * np.cos(4*pi*y)\n        },\n        {\n            'N': 33,\n            'u_exact': lambda x, y: np.sin(6*pi*x)*np.sin(2*pi*y) - 2*np.cos(2*pi*x)*np.cos(6*pi*y),\n            'f': lambda x, y: ((2*pi)**2 * 10)**2 * np.sin(6*pi*x)*np.sin(2*pi*y) - \\\n                              2*((2*pi)**2 * 10)**2 * np.cos(2*pi*x)*np.cos(6*pi*y)\n        },\n        {\n            'N': 40,\n            'u_exact': lambda x, y: 0.0 * x, # Ensures correct shape (N, N) with all zeros\n            'f': lambda x, y: 0.0 * x\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        N = case['N']\n        u_exact_func = case['u_exact']\n        f_func = case['f']\n\n        # 1. Discretize domain and create grid\n        grid_pts = np.arange(N) / N\n        X, Y = np.meshgrid(grid_pts, grid_pts, indexing='xy')\n\n        # 2. Evaluate exact solution and forcing term on the grid\n        u_exact = u_exact_func(X, Y)\n        f_grid = f_func(X, Y)\n\n        # 3. Solve the PDE using the spectral method\n        \n        # 3a. Forward FFT of the forcing term\n        f_hat = np.fft.fft2(f_grid)\n\n        # 3b. Define discrete integer wavenumbers (modes) n_x, n_y\n        # Using d=1/N in fftfreq scales the result to be the integer mode number.\n        nx = np.fft.fftfreq(N, d=1/N)\n        ny = np.fft.fftfreq(N, d=1/N)\n        NX, NY = np.meshgrid(nx, ny, indexing='xy')\n\n        # 3c. Construct the biharmonic operator symbol in Fourier space\n        # L_hat = ( (2*pi*n_x)^2 + (2*pi*n_y)^2 )^2\n        op_fourier = ((2*pi*NX)**2 + (2*pi*NY)**2)**2\n\n        # 3d. Solve for u_hat, handling the zero-wavenumber mode\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Create a mask for non-zero frequencies to avoid division by zero.\n        # The operator is zero only at the (0,0) frequency.\n        nonzero_mask = op_fourier != 0\n        u_hat[nonzero_mask] = f_hat[nonzero_mask] / op_fourier[nonzero_mask]\n\n        # The zero-mean constraint on u is enforced by setting u_hat[0,0] = 0.\n        # This is already implicitly true because f has zero mean (f_hat[0,0]~0),\n        # but setting it explicitly ensures robustness.\n        u_hat[0, 0] = 0.0\n        \n        # 3e. Inverse FFT to get numerical solution in physical space\n        u_num = np.real(np.fft.ifft2(u_hat))\n\n        # 4. Compute the root-mean-square error\n        rms_error = np.sqrt(np.mean((u_num - u_exact)**2))\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15e}' for r in results)}]\")\n\nsolve()\n```", "id": "2440935"}, {"introduction": "许多现实世界的问题并非是周期性的，因此我们必须扩展我们的工具箱来处理指定的边界条件，例如狄利克雷边界条件。对于非周期性区间上的问题，切比雪夫多项式是首选的基函数。我们将通过使用切比雪夫微分矩阵和克罗内克积来构建线性系统，从而为泊松方程建立一个二维求解器。这个综合性的编程练习 ([@problem_id:2440925]) 介绍了切比雪夫配置法，这是以谱精度求解边值问题的基石，同时它也教授了在谱方法背景下如微分矩阵和边界条件施加等高级技术。", "problem": "考虑一个矩形上的二维（$2$-dimensional）泊松方程，\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in [a_x,b_x]\\times [a_y,b_y],$$\n服从于狄利克雷边界条件\n$$u(x,y) = g(x,y) \\quad \\text{for } (x,y) \\in \\partial([a_x,b_x]\\times [a_y,b_y]),$$\n其中 $\\nabla^2$ 表示关于物理坐标 $x$ 和 $y$ 的拉普拉斯算子。对于下文的每个测试用例，都指定了精确解 $u(x,y)$；请使用它来定义边界上的边界条件 $g(x,y)$ 以及内部的源函数 $f(x,y) = \\nabla^2 u(x,y)$。\n\n您的任务是编写一个完整的、可运行的程序，对每个测试用例，在一个包含边界点、尺寸为 $N_x \\times N_y$ 的张量积网格上计算 $u(x,y)$ 的数值近似解，并返回该域内所有网格点上数值近似解与精确解之间的最大逐点绝对误差。\n\n测试套件（每行为一个用例，提供矩形区域、网格尺寸和精确解）：\n- 用例 $1$：$[a_x,b_x]=[-1,1]$, $[a_y,b_y]=[-1,1]$, $N_x=24$, $N_y=24$, 精确解\n  $$u(x,y) = \\sin(\\pi x)\\sin(\\pi y).$$\n- 用例 $2$：$[a_x,b_x]=[0,1]$, $[a_y,b_y]=[0,2]$, $N_x=30$, $N_y=28$, 精确解\n  $$u(x,y) = x(1-x)\\,y(2-y).$$\n- 用例 $3$：$[a_x,b_x]=[-2,3]$, $[a_y,b_y]=[-1,1]$, $N_x=22$, $N_y=18$, 精确解\n  $$u(x,y) = e^{x}\\,(1-y^2).$$\n- 用例 $4$：$[a_x,b_x]=[-1,1]$, $[a_y,b_y]=[-1,1]$, $N_x=8$, $N_y=8$, 精确解\n  $$u(x,y) = 0.$$\n\n对于每个用例，请在物理坐标 $(x,y)$ 中计算 $f(x,y)=\\nabla^2 u(x,y)$，并在矩形的所有边上施加来自 $u(x,y)$ 的狄利克雷边界值。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含 $4$ 个用例的最大绝对误差列表，格式为用方括号括起来的、以逗号分隔的十进制数列表，采用科学记数法，保留 $10$ 位有效数字。例如，\n$$[1.2345678900e-06,3.2100000000e-08,9.9900000000e-10,0.0000000000e+00].$$\n\n所有量均为无量纲，无需报告物理单位。若中间表达式中出现角度，则必须以弧度为单位进行解释。最终答案必须是如上所述的无量纲实数。", "solution": "用户提供了一个有效的问题陈述。任务是使用数值方法求解矩形域上带有狄利克雷边界条件的二维泊松方程。该问题是适定的、科学上合理的，并且为四个测试用例中的每一个都提供了所有必要的参数。\n\n所选方法为 Chebyshev 谱配置法，该方法以其在处理光滑解问题时的高精度而著称。该方法论包括以下步骤：\n\n1.  **域映射与离散化**：将物理矩形域 $[a_x,b_x]\\times [a_y,b_y]$ 映射到规范计算域 $[-1,1]\\times[-1,1]$。然后使用 Chebyshev-Gauss-Lobatto 点的张量积网格对此计算域进行离散化。网格维度为每个测试用例指定的 $N_x \\times N_y$。仿射映射定义如下：\n    $$x(\\xi) = \\frac{b_x - a_x}{2} \\xi + \\frac{b_x + a_x}{2}$$\n    $$y(\\eta) = \\frac{b_y - a_y}{2} \\eta + \\frac{b_y + a_y}{2}$$\n    其中 $(\\xi, \\eta) \\in [-1,1]\\times[-1,1]$ 是计算坐标。网格点为 $\\xi_i = \\cos(\\frac{i\\pi}{N_x-1})$ 和 $\\eta_j = \\cos(\\frac{j\\pi}{N_y-1})$。\n\n2.  **变换后的方程**：将拉普拉斯算子变换到计算坐标 $(\\xi, \\eta)$。根据链式法则可得：\n    $$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = \\left(\\frac{2}{b_x-a_x}\\right)^2 \\frac{\\partial^2 u}{\\partial \\xi^2} + \\left(\\frac{2}{b_y-a_y}\\right)^2 \\frac{\\partial^2 u}{\\partial \\eta^2}$$\n    令 $c_x = (2/(b_x-a_x))^2$ 和 $c_y = (2/(b_y-a_y))^2$，则偏微分方程变为 $c_x u_{\\xi\\xi} + c_y u_{\\eta\\eta} = f$。\n\n3.  **谱算子离散化**：使用 Chebyshev 微分矩阵来近似关于 $\\xi$ 和 $\\eta$ 的偏导数。设 $U$ 为代表网格点上解的 $N_x \\times N_y$ 矩阵。该偏微分方程的离散形式为：\n    $$c_x D_{xx} U + c_y U D_{yy}^T = F$$\n    其中 $D_{xx}$ 和 $D_{yy}$ 分别是 $x$ 和 $y$ 方向的二阶 Chebyshev 微分矩阵，而 $F$ 是在网格点上求值的源函数所构成的矩阵。\n\n4.  **线性系统构建**：为使用标准线性求解器，通过将 $N_x \\times N_y$ 矩阵展平为大小为 $N_x N_y$ 的向量，将该矩阵方程转换为一个大型线性系统 $\\mathcal{L}\\vec{u} = \\vec{f}$。使用行主序的 `flatten` 操作和克罗内克积 (Kronecker product)，算子矩阵 $\\mathcal{L}$ 可构建为：\n    $$\\mathcal{L} = c_x(D_{xx} \\otimes I_y) + c_y(I_x \\otimes D_{yy})$$\n    其中 $I_x$ 和 $I_y$ 是相应大小的单位矩阵。\n\n5.  **边界条件的施加**：狄利克雷边界条件指定了域边界上 $u$ 的值。这些条件被直接强制施加到线性系统中。对于每个边界网格点，矩阵 $\\mathcal{L}$ 中的相应行被修改以表示一个恒等方程，右侧向量 $\\vec{f}$ 中的相应条目则被设置为来自精确解的已知边界值。\n\n6.  **求解与误差分析**：求解最终的线性系统以获得未知的网格点值 $\\vec{u}$。解向量被重塑回 $N_x \\times N_y$ 的矩阵 $U_{\\text{num}}$。通过计算数值解与在同一网格上求值的精确解 $U_{\\text{exact}}$ 之间的最大逐点绝对误差来量化数值解的准确性：\n    $$\\text{Error} = \\max_{i,j} |(U_{\\text{num}})_{ij} - (U_{\\text{exact}})_{ij}|$$\n\n对于每个测试用例，源函数 $f(x,y)$ 是通过对给定的精确解 $u(x,y)$ 解析地计算拉普拉斯算子而导出的：\n-   用例 $1$：$u(x,y) = \\sin(\\pi x)\\sin(\\pi y) \\implies \\nabla^2 u = -2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$。\n-   用例 $2$：$u(x,y) = x(1-x)y(2-y) \\implies \\nabla^2 u = -2y(2-y) - 2x(1-x)$。\n-   用例 $3$：$u(x,y) = e^{x}(1-y^2) \\implies \\nabla^2 u = e^x(1-y^2) - 2e^x = -e^x(1+y^2)$。\n-   用例 $4$：$u(x,y) = 0 \\implies \\nabla^2 u = 0$。\n\n以下程序为每个指定用例实现了此策略。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Computes the first-order Chebyshev differentiation matrix on N points.\n    \n    Args:\n        N (int): The number of collocation points.\n\n    Returns:\n        np.ndarray: The (N, N) differentiation matrix.\n    \"\"\"\n    if N == 1:\n        return np.array([[0.0]])\n\n    x = np.cos(np.pi * np.arange(N) / (N - 1))\n    c = np.ones(N)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Create a broadcast-ready version of x and c\n    x_col = x[:, np.newaxis]\n    c_col = c[:, np.newaxis]\n    \n    # Compute off-diagonal elements\n    dX = x_col - x\n    D = (c_col / c) * ((-1)**(np.arange(N)[:, np.newaxis] + np.arange(N))) / (dX + np.eye(N))\n    np.fill_diagonal(D, 0.0)\n\n    # Compute diagonal elements\n    D[np.diag_indices_from(D)] = -np.sum(D, axis=1)\n\n    return D\n\ndef solve_poisson_2d(params):\n    \"\"\"\n    Solves the 2D Poisson equation on a rectangular domain using a Chebyshev spectral method.\n    \n    Args:\n        params (tuple): A tuple containing (ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func).\n\n    Returns:\n        float: The maximum pointwise absolute error.\n    \"\"\"\n    ax, bx, ay, by, Nx, Ny, u_exact_func, f_source_func = params\n    \n    # 1. Coordinate transformation factors\n    dx = bx - ax\n    dy = by - ay\n    cx = (2.0 / dx)**2\n    cy = (2.0 / dy)**2\n\n    # 2. Chebyshev differentiation matrices\n    Dx = chebyshev_diff_matrix(Nx)\n    Dxx = Dx @ Dx\n    Dy = chebyshev_diff_matrix(Ny)\n    Dyy = Dy @ Dy\n\n    # 3. Construct the 2D operator matrix using Kronecker products (row-major)\n    Ix = np.identity(Nx)\n    Iy = np.identity(Ny)\n    L_op = cx * np.kron(Dxx, Iy) + cy * np.kron(Ix, Dyy)\n\n    # 4. Create the physical grid\n    xi = np.cos(np.pi * np.arange(Nx) / (Nx - 1))\n    eta = np.cos(np.pi * np.arange(Ny) / (Ny - 1))\n    \n    # Map from computational [-1, 1] to physical [a, b]\n    # Note: xi and eta run from 1 down to -1.\n    x_1d = (bx - ax) / 2.0 * xi + (ax + bx) / 2.0\n    y_1d = (by - ay) / 2.0 * eta + (ay + by) / 2.0\n    \n    # Create a meshgrid consistent with matrix indexing ('ij')\n    X, Y = np.meshgrid(x_1d, y_1d, indexing='ij')\n\n    # 5. Evaluate source term and exact solution on the grid\n    F = f_source_func(X, Y)\n    U_exact = u_exact_func(X, Y)\n\n    # 6. Flatten RHS and prepare for boundary condition imposition\n    f_flat = F.flatten() # Row-major\n    u_exact_flat = U_exact.flatten()\n\n    # 7. Identify boundary points\n    is_bnd = np.zeros_like(X, dtype=bool)\n    is_bnd[0, :] = True\n    is_bnd[-1, :] = True\n    is_bnd[:, 0] = True\n    is_bnd[:, -1] = True\n    bnd_indices = np.where(is_bnd.flatten())[0]\n\n    # 8. Impose Dirichlet boundary conditions\n    for k in bnd_indices:\n        L_op[k, :] = 0.0\n        L_op[k, k] = 1.0\n        f_flat[k] = u_exact_flat[k]\n        \n    # 9. Solve the linear system\n    u_num_flat = np.linalg.solve(L_op, f_flat)\n    \n    # 10. Reshape solution and calculate error\n    U_num = u_num_flat.reshape((Nx, Ny))\n    max_error = np.max(np.abs(U_num - U_exact))\n    \n    return max_error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1\n        (-1.0, 1.0, -1.0, 1.0, 24, 24,\n         lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y),\n         lambda x, y: -2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)),\n        \n        # Case 2\n        (0.0, 1.0, 0.0, 2.0, 30, 28,\n         lambda x, y: x * (1 - x) * y * (2 - y),\n         lambda x, y: -2 * y * (2 - y) - 2 * x * (1 - x)),\n        \n        # Case 3\n        (-2.0, 3.0, -1.0, 1.0, 22, 18,\n         lambda x, y: np.exp(x) * (1 - y**2),\n         lambda x, y: -np.exp(x) * (1 + y**2)),\n        \n        # Case 4\n        (-1.0, 1.0, -1.0, 1.0, 8, 8,\n         lambda x, y: 0.0 * x * y,\n         lambda x, y: 0.0 * x * y)\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_poisson_2d(case)\n        results.append(f\"{error:.10e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2440925"}]}