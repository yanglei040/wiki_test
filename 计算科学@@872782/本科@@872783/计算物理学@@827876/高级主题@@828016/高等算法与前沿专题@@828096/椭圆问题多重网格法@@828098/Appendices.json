{"hands_on_practices": [{"introduction": "解决泊松方程是计算物理中的一项基本任务。在处理具有周期性边界条件的区域（例如宇宙学模拟）时，快速傅里叶变换 (FFT) 提供了一种极其高效和优雅的求解策略。本练习将指导您实现一个基于 FFT 的求解器 [@problem_id:2415805]，它不仅是解决此类问题的重要工具，还能加深您对傅里叶空间中拉普拉斯算子特性的理解，并为更通用的求解器提供性能基准。", "problem": "编写一个完整、可运行的程序，通过求解一组给定右端项的泊松方程，来计算周期性三维网格上的引力势。使用边长为 $1$ 的周期性立方体域，坐标 $x,y,z \\in [0,1)$，以及一个包含 $N \\times N \\times N$ 个点的均匀笛卡尔网格，网格间距为 $h = 1/N$，且所有面均采用周期性边界条件。考虑无量纲化的泊松方程\n$$\n\\nabla^2 \\phi(x,y,z) = f(x,y,z),\n$$\n并满足 $\\phi$ 的空间平均值为零的规范条件，即\n$$\n\\frac{1}{|\\Omega|}\\int_{\\Omega}\\phi(x,y,z)\\,dx\\,dy\\,dz = 0,\n$$\n其中 $|\\Omega| = 1$ 是该域的体积。该方程应在离散意义上进行解释，使用网格上的标准 $7$ 点周期性有限差分拉普拉斯算子：\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big),\n$$\n其中，每个方向上的索引都对 $N$ 取模以强制施加周期性。网格点应位于 $(x_i,y_j,z_k) = (i/N, j/N, k/N)$，其中整数 $i,j,k \\in \\{0,1,\\dots,N-1\\}$。\n\n您的程序必须针对下述每个测试用例，计算满足零平均值规范的离散泊松方程 $L_h \\phi_h = f_h$ 的数值近似解 $\\phi_h$，然后报告一个指定的标量值。所有量均为无量纲。角度（如有）以弧度为单位。最终输出必须是单行文本，其中包含一个由方括号括起来的、逗号分隔的三个浮点数值列表，顺序与下方给出的测试用例一致，且不含任何额外文本。\n\n测试套件（每个用例指定了 $N$ 和右端项 $f(x,y,z)$；通过在网格上对 $f$ 采样并以数值方式减去其平均值来定义 $f_h$，从而满足离散相容性条件）：\n\n- 用例 1：$N=16$。定义\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z).\n$$\n对于此用例，还需定义连续解析参考场\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 3}\\sin(2\\pi x)\\sin(2\\pi y)\\sin(2\\pi z),\n$$\n它是在连续统中满足零均值条件的 $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ 的解。计算出数值解 $\\phi_h$ 后，报告离散均方根（RMS）误差\n$$\nE_1 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- 用例 2：$N=32$。定义\n$$\nf(x,y,z) = \\sin(2\\pi x)\\sin(2\\pi y) + \\frac{1}{2}\\sin(4\\pi z).\n$$\n对于此用例，还需定义连续解析参考场\n$$\n\\phi_{\\mathrm{ref}}(x,y,z) = -\\frac{1}{(2\\pi)^2\\cdot 2}\\sin(2\\pi x)\\sin(2\\pi y) - \\frac{1}{2}\\cdot\\frac{1}{(2\\pi)^2\\cdot 4}\\sin(4\\pi z),\n$$\n它是在连续统中满足零均值条件的 $\\nabla^2 \\phi_{\\mathrm{ref}} = f$ 的解。计算出数值解 $\\phi_h$ 后，报告离散均方根（RMS）误差\n$$\nE_2 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)-\\phi_{\\mathrm{ref}}(x_i,y_j,z_k)\\right)^2\\right)^{1/2}.\n$$\n\n- 用例 3：$N=8$。定义\n$$\nf(x,y,z) \\equiv 0.\n$$\n在这种情况下，施加规范条件后的精确连续解恒为零。计算出数值解 $\\phi_h$ 后，报告离散 RMS 幅值\n$$\nE_3 = \\left(\\frac{1}{N^3}\\sum_{i,j,k}\\left(\\phi_h(i,j,k)\\right)^2\\right)^{1/2}.\n$$\n\n您的程序必须生成单行输出，按顺序包含三个结果 $[E_1,E_2,E_3]$。例如，一个有效的输出行看起来会像\n“[0.00123,0.00045,0.0]”。", "solution": "所提出的问题是在周期性立方体域上求解三维泊松方程 $\\nabla^2 \\phi = f$ 的数值解。该问题定义明确，具有科学依据，并为获得唯一解提供了所有必要信息。这是计算物理学中的一个标准问题，我们将给出一个完整的解法。\n\n在周期域上求解常系数线性偏微分方程的最有效方法是使用快速傅里叶变换（FFT）。周期性边界条件和拉普拉斯算子的结构意味着离散傅里叶模式（复指数函数）是离散拉普拉斯算子的精确本征函数。此性质允许将实空间中的耦合线性代数方程组变换为傅里叶空间中的一组独立代数方程，从而可以轻松求解。\n\n问题是在一个大小为 $N \\times N \\times N$ 的均匀笛卡尔网格上求解离散泊松方程 $L_h \\phi_h = f_h$。网格间距为 $h=1/N$。离散场 $\\phi_h$ 由网格点 $(x_i, y_j, z_k) = (i/N, j/N, k/N)$ 上的值 $\\phi_{i,j,k}$ 表示，其中整数 $i,j,k \\in \\{0, 1, \\dots, N-1\\}$。7 点离散拉普拉斯算子 $L_h$ 由下式给出：\n$$\n(L_h \\phi)_{i,j,k} = \\frac{1}{h^2}\\Big(\\phi_{i+1,j,k}+\\phi_{i-1,j,k}+\\phi_{i,j+1,k}+\\phi_{i,j-1,k}+\\phi_{i,j,k+1}+\\phi_{i,j,k-1}-6\\phi_{i,j,k}\\Big)\n$$\n其中索引对 $N$ 取模以强制施加周期性。\n\n我们对该方程 $L_h \\phi_h = f_h$ 应用三维离散傅里叶变换（DFT）。DFT 将实空间网格函数 $\\psi_{i,j,k}$ 变换为其傅里叶空间表示 $\\hat{\\psi}_{p,q,r}$，其中 $(p,q,r)$ 是整数频率指数。卷积算子 $L_h$ 在实空间中的作用在傅里叶空间中变为简单的乘法：\n$$\n\\hat{L}_{p,q,r} \\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r}\n$$\n此处，$\\hat{L}_{p,q,r}$ 是算子 $L_h$ 的本征值，对应于频率向量为 $(p,q,r)$ 的离散傅里叶模式。这些本征值可以通过将 $L_h$ 应用于本征函数 $\\exp(2\\pi i (pi/N + qj/N + rk/N))$ 来找到，结果为：\n$$\n\\hat{L}_{p,q,r} = \\frac{1}{h^2} \\left( e^{2\\pi i p/N} + e^{-2\\pi i p/N} + e^{2\\pi i q/N} + e^{-2\\pi i q/N} + e^{2\\pi i r/N} + e^{-2\\pi i r/N} - 6 \\right)\n$$\n使用关系式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，本征值为：\n$$\n\\hat{L}_{p,q,r} = \\frac{2}{h^2} \\left[ \\cos\\left(\\frac{2\\pi p}{N}\\right) + \\cos\\left(\\frac{2\\pi q}{N}\\right) + \\cos\\left(\\frac{2\\pi r}{N}\\right) - 3 \\right]\n$$\n势 $\\phi_h$ 的傅里叶系数的解则通过除法求得：\n$$\n\\hat{\\phi}_{p,q,r} = \\frac{\\hat{f}_{p,q,r}}{\\hat{L}_{p,q,r}}\n$$\n对于零频模式，即 $(p,q,r) = (0,0,0)$，此过程会遇到一个奇点。对于该模式，$\\hat{L}_{0,0,0} = \\frac{2}{h^2} (\\cos(0) + \\cos(0) + \\cos(0) - 3) = 0$。除以零是未定义的。这表明，在一个完全周期性的域上，泊松方程只有在源项 $f_h$ 满足相容性条件时才可解。离散相容性条件是源在整个网格上的总和必须为零：$\\sum_{i,j,k} f_{i,j,k} = 0$。在傅里叶空间中，这对应于零频分量为零：$\\hat{f}_{0,0,0} = 0$。问题陈述正确地要求通过以数值方式减去离散源项 $f_h$ 的平均值来强制执行此条件。\n\n在 $\\hat{f}_{0,0,0} = 0$ 的情况下，零模式的方程变为 $0 \\cdot \\hat{\\phi}_{0,0,0} = 0$，这意味着 $\\hat{\\phi}_{0,0,0}$ 是不确定的。这对应于可以给势 $\\phi$ 加上一个任意常数的自由度。该问题通过施加一个规范条件来解决这个模糊性：$\\phi$ 的空间平均值必须为零。对于离散解 $\\phi_h$，这意味着 $\\sum_{i,j,k} \\phi_{i,j,k} = 0$，这等效于将其零频分量设为零：$\\hat{\\phi}_{0,0,0} = 0$。\n\n完整的算法如下：\n1. 对于给定的网格大小 $N$ 和源函数 $f(x,y,z)$，通过在网格点 $(x_i, y_j, z_k)$ 上求值 $f$ 来创建离散源场 $f_h$。\n2. 通过从 $f_h$ 中减去平均值来强制执行相容性条件：$f_h \\leftarrow f_h - \\frac{1}{N^3} \\sum_{i,j,k} f_{i,j,k}$。\n3. 计算修改后的 $f_h$ 的 3D FFT 以获得 $\\hat{f}_{p,q,r}$。\n4. 构建本征值 $\\hat{L}_{p,q,r}$ 的三维数组。\n5. 对于所有非零频率 $(p,q,r) \\neq (0,0,0)$，计算解的傅里叶系数 $\\hat{\\phi}_{p,q,r} = \\hat{f}_{p,q,r} / \\hat{L}_{p,q,r}$。\n6. 将解的零频分量设为零，$\\hat{\\phi}_{0,0,0} = 0$，以满足规范条件。\n7. 计算 $\\hat{\\phi}_{p,q,r}$ 的 3D 逆 FFT 以获得实空间中的解 $\\phi_h$。由于源项是实数且算子是对称的，解 $\\phi_h$ 必须是实数。我们取 IFFT 结果的实部，以舍弃由浮点运算误差产生的可忽略的虚部。\n8. 最后，对每个测试用例，使用计算出的数值解 $\\phi_h$ 计算指定的标量值（$E_1, E_2, E_3$）。\n\n此过程是为所提供的三个测试用例实现的。对于用例 1 和 2，我们计算相对于所提供的解析解的均方根（RMS）误差。对于用例 3，其源项为零，精确解也为零，我们报告计算出的数值解的 RMS 幅值，该值应接近于浮点精度。", "answer": "```python\nimport numpy as np\n\ndef solve_poisson_fft(N, f_func, phi_ref_func=None):\n    \"\"\"\n    Solves the 3D periodic Poisson equation using the FFT method.\n\n    Args:\n        N (int): The number of grid points in each dimension.\n        f_func (callable): A function f(x, y, z) for the right-hand side.\n        phi_ref_func (callable, optional): A function phi_ref(x, y, z) for\n            the analytical reference solution. If None, the RMS magnitude of\n            the solution is computed instead of the error.\n\n    Returns:\n        float: The computed RMS error or RMS magnitude.\n    \"\"\"\n    # 1. Define grid parameters and coordinates.\n    h = 1.0 / N\n    indices = np.indices((N, N, N))\n    x = indices[0] * h\n    y = indices[1] * h\n    z = indices[2] * h\n\n    # 2. Construct discrete source term f_h and enforce compatibility.\n    f_h = f_func(x, y, z)\n    f_h -= np.mean(f_h)\n\n    # 3. Compute the 3D FFT of the source term.\n    f_k = np.fft.fftn(f_h)\n\n    # 4. Construct the array of eigenvalues for the discrete Laplacian.\n    # The frequencies are p/N, where p are integer wave numbers.\n    freq_unit = np.fft.fftfreq(N)\n    p_N, q_N, r_N = np.meshgrid(freq_unit, freq_unit, freq_unit, indexing='ij')\n\n    L_k = (2.0 / h**2) * (np.cos(2 * np.pi * p_N) +\n                           np.cos(2 * np.pi * q_N) +\n                           np.cos(2 * np.pi * r_N) - 3.0)\n\n    # 5. Solve for Fourier coefficients of phi, handling the k=0 singularity.\n    phi_k = np.zeros_like(f_k, dtype=complex)\n    \n    # Create a mask for non-zero frequencies.\n    # L_k is zero at (0,0,0), but f_k is also zero there due to mean subtraction.\n    # The result phi_k[0,0,0] should be 0 due to the gauge condition.\n    # We only compute the division for non-zero k.\n    non_zero_k_mask = (L_k != 0)\n    phi_k[non_zero_k_mask] = f_k[non_zero_k_mask] / L_k[non_zero_k_mask]\n    \n    # Explicitly enforce the gauge condition phi_k[0,0,0]=0\n    # This is already handled by initializing phi_k to zeros and dividing only\n    # for non_zero_k, but we state it for clarity.\n    phi_k[0, 0, 0] = 0.0\n\n    # 6. Compute the inverse 3D FFT to get the real-space solution.\n    phi_h = np.real(np.fft.ifftn(phi_k))\n\n    # 7. Calculate and return the required scalar quantity.\n    if phi_ref_func:\n        phi_ref = phi_ref_func(x, y, z)\n        # RMS Error\n        rms_val = np.sqrt(np.mean((phi_h - phi_ref)**2))\n    else:\n        # RMS Magnitude\n        rms_val = np.sqrt(np.mean(phi_h**2))\n        \n    return rms_val\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define functions for test cases\n    # Case 1: N=16\n    def f1(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) * np.sin(2 * np.pi * z)\n\n    def phi_ref1(x, y, z):\n        return -1.0 / (3.0 * (2 * np.pi)**2) * f1(x, y, z)\n\n    # Case 2: N=32\n    def f2(x, y, z):\n        return np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y) + 0.5 * np.sin(4 * np.pi * z)\n\n    def phi_ref2(x, y, z):\n        term1 = -1.0 / (2.0 * (2 * np.pi)**2) * np.sin(2 * np.pi * x) * np.sin(2 * np.pi * y)\n        term2 = -0.5 / ((4 * np.pi)**2) * np.sin(4 * np.pi * z)\n        return term1 + term2\n\n    # Case 3: N=8\n    def f3(x, y, z):\n        return np.zeros_like(x)\n\n    test_cases = [\n        {'N': 16, 'f_func': f1, 'phi_ref_func': phi_ref1},\n        {'N': 32, 'f_func': f2, 'phi_ref_func': phi_ref2},\n        {'N': 8, 'f_func': f3, 'phi_ref_func': None}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_poisson_fft(case['N'], case['f_func'], case['phi_ref_func'])\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415805"}, {"introduction": "然而，许多现实世界的问题并不具备周期性边界，这使得 FFT 方法不再适用。对于更一般的情况，例如狄利克雷边界条件，多重网格方法是一种功能强大且广泛应用的替代方案，它能以接近线性的时间复杂度高效求解。本练习 [@problem_id:2415837] 将带您深入实践，从零开始构建一个几何多重网格 V-循环求解器，您将亲手实现平滑、限制和延长等核心组件，从而真正掌握该算法的精髓。", "problem": "考虑单位正方形上的二维椭圆偏微分方程 (PDE)，其带有齐次狄利克雷边界条件 (DBC)：\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{for } (x,y)\\in (0,1)\\times (0,1), \\qquad u(x,y)=0 \\quad \\text{on } \\partial([0,1]\\times[0,1]).\n$$\n使用包含 $N\\times N$ 个未知数的均匀笛卡尔网格对内部区域进行离散化，网格间距为 $h=1/(N+1)$，并采用标准的五点有限差分格式来表示离散负拉普拉斯算子。设右端项 $f$ 为一个点源，该点源位于一个与网格节点重合的点上，并用狄拉克 $\\delta$ 函数建模。在网格上，通过一个离散的克罗内克 $\\delta$ 函数来表示此点源，并进行缩放以在连续极限下保持单位积分，即，在所选网格节点 $(i_{0},j_{0})$ 处设 $f_{i_{0},j_{0}}=1/h^{2}$，而在其他位置设 $f_{i,j}=0$。在下文所有情况中，索引 $(i,j)$ 指的是内部网格索引，其中 $i\\in\\{0,1,\\dots,N-1\\}$ 和 $j\\in\\{0,1,\\dots,N-1\\}$ 对应物理位置 $(x_{i},y_{j})=((i+1)h,(j+1)h)$。\n\n您的任务是为该离散化所产生的线性系统实现一个几何多重网格 V 循环求解器。从以下基本要素开始：\n- 在内部区域上，与 $-\\Delta$ 对应的五点有限差分离散算子由下式给出：\n$$\n(Au)_{i,j}=\\frac{4u_{i,j}-u_{i+1,j}-u_{i-1,j}-u_{i,j+1}-u_{i,j-1}}{h^{2}},\n$$\n其中，通过将内部区域之外的值视为零来施加齐次狄利克雷边界条件。\n- 位于 $(i_{0},j_{0})$ 且具有单位积分的点源的克罗内克 $\\delta$ 表示需要满足 $f_{i_{0},j_{0}}=1/h^{2}$，从而使得 $\\sum_{i,j} f_{i,j} h^{2}=1$。\n\n设计一个在每一层上执行以下操作的 V 循环：\n- 使用权重为 $\\omega=2/3$ 的加权雅可比光滑进行 $\\nu_{1}$ 次预光滑和 $\\nu_{2}$ 次后光滑。取 $\\nu_{1}=\\nu_{2}=3$。加权雅可比更新公式为\n$$\nu \\leftarrow u + \\omega D^{-1}(f-Au),\n$$\n其中 $D$ 是 $A$ 的对角部分，即 $D_{i,j}=4/h^{2}$，因此 $D^{-1}=(h^{2}/4)I$。\n- 采用全权重限制算子将细网格残差转移到粗网格。\n- 采用双线性插值进行延长，以传递粗网格的误差校正。\n- 通过标准粗化进行递归，内部尺寸遵循 $N\\mapsto(N-1)/2$ 的规则，并假设 $N$ 的形式为 $2^{\\ell}-1$。在 $N\\le 3$ 的最粗层上，通过对离散算子进行直接密集求解来精确求解该线性系统。\n\n在每次完整的 V 循环后，使用相对残差来量化其鲁棒性：\n$$\n\\rho = \\frac{\\lVert r \\rVert_{2}}{\\lVert f \\rVert_{2}}, \\quad r=f-Au,\n$$\n其中 $\\lVert\\cdot\\rVert_{2}$ 是欧几里得范数。从零初始猜测开始迭代 V 循环，直到 $\\rho \\le \\epsilon$ 或已执行最大循环次数 $K$ 为止。报告每个测试用例最终达到的 $\\rho$ 值。\n\n测试套件。为以下参数集实现并运行您的求解器，这些参数集共同探测了理想路径、近边界行为、多点源叠加以及一个较小网格的边缘情况：\n- 情况 1：$N=63$，单个点源位于 $(i_{0},j_{0})=(31,31)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 2：$N=63$，单个点源位于 $(i_{0},j_{0})=(1,1)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 3：$N=31$，两个点源位于 $(i_{0},j_{0})\\in\\{(7,7),(23,23)\\}$，两处的值均设为 $1/h^{2}$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n- 情况 4：$N=31$，单个点源位于 $(i_{0},j_{0})=(0,0)$，容差 $\\epsilon=10^{-8}$，最大循环次数 $K=20$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的、逗号分隔的浮点数列表。每个浮点数是对应情况的最终相对残差 $\\rho$，并四舍五入到 6 位有效数字（例如，$[3.2e-07,1.1e-09, \\dots]$）。不应打印任何其他文本。", "solution": "所提出的问题是计算物理学中一个有效且适定的任务。它要求为在单位正方形上、带有齐次狄利克雷边界条件的二维泊松方程 $-\\Delta u = f$ 的有限差分离散化所产生的线性系统 $Au = f$ 实现一个几何多重网格 V 循环求解器。该问题有科学依据、内容自洽，并且所有参数和算法都以足够的精度进行了规定，以确保唯一的实现。\n\n多重网格方法的核心原理是通过在一系列粗网格层次上求解误差来加速基本迭代求解器（即“光滑器”）的收敛。误差的高频分量在细网格上被光滑器有效衰减，而低频分量则在粗网格上被求解，在粗网格上它们表现为高频分量，因此可以被有效衰减。V 循环是一种遍历此网格层次结构的特定递归算法。\n\n解决方案的结构如下：首先，我们定义多重网格算法的组成部分——离散算子、光滑器和网格传输算子（限制和延长）。然后，我们将这些组合成递归的 V 循环过程。\n\n**1. 离散化与算子**\n\n连续问题在具有 $N \\times N$ 个内部点和网格尺寸 $h = 1/(N+1)$ 的均匀网格上进行离散化。解 $u$ 和右端项 $f$ 表示为 $N \\times N$ 的数组。离散负拉普拉斯算子 $A$ 由五点格式给出：\n$$\n(Au)_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2}\n$$\n适用于内部索引 $i,j \\in \\{0, 1, \\dots, N-1\\}$。通过将此内部范围之外的任何索引对 $(i,j)$ 的 $u_{i,j}$ 值设为 0 来施加齐次狄利克雷边界条件。\n\n**2. 加权雅可比光滑器**\n\n光滑器的作用是减少高频误差。我们使用加权雅可比方法。单次光滑步骤的更新公式为：\n$$\nu \\leftarrow u + \\omega D^{-1}(f - Au)\n$$\n此处，$r = f - Au$ 是残差。矩阵 $D$ 是 $A$ 的对角部分，对于所有内部点，其值恒为 $D_{i,j} = 4/h^2$。因此，其逆是一个标量乘法：$D^{-1} = (h^2/4)I$。选择权重 $\\omega = 2/3$ 是为了针对此特定算子获得良好的光滑特性。我们在粗化前执行 $\\nu_1 = 3$ 次预光滑步骤，并在从粗网格校正后执行 $\\nu_2 = 3$ 次后光滑步骤。\n\n**3. 网格传输算子**\n\n网格传输算子在细网格和粗网格之间移动数据。网格层次结构由尺寸为 $N = 2^\\ell - 1$ 的网格的标准粗化规则定义，其中尺寸为 $N_{\\text{fine}}$ 的细网格映射到尺寸为 $N_{\\text{coarse}} = (N_{\\text{fine}} - 1)/2$ 的粗网格。\n\n**限制 ($R$)：** 细网格残差 $r^{\\text{fine}}$ 被转移到粗网格，形成粗网格误差方程的右端项，$r^{\\text{coarse}} = R r^{\\text{fine}}$。我们使用全权重限制，其中一个粗网格点的值是对应的 9 个细网格点值的加权平均。以细网格点 $(2I+1, 2J+1)$ 为中心的粗网格点 $(I,J)$ 的计算格式为：\n$$\nr^{\\text{coarse}}_{I,J} = \\frac{1}{16} \\sum_{i,j \\in \\{-1,0,1\\}} w_{i,j} r^{\\text{fine}}_{2I+1+i, 2J+1+j}, \\quad \\text{，权重为 } W = \\begin{pmatrix} 1  2  1 \\\\ 2  4  2 \\\\ 1  2  1 \\end{pmatrix}\n$$\n\n**延长 ($P$)：** 在粗网格上求解误差方程后，得到的误差校正 $e^{\\text{coarse}}$ 必须被插值回细网格：$e^{\\text{fine}} = P e^{\\text{coarse}}$。我们使用双线性插值。一个粗网格点的值 $e^{\\text{coarse}}_{I,J}$ 用于确定一个 $2 \\times 2$ 细网格点块上的值。\n- 与粗网格点重合的细网格点直接复制：$e^{\\text{fine}}_{2I+1, 2J+1} = e^{\\text{coarse}}_{I,J}$。\n- 沿水平边的细网格点是两个粗网格邻点的平均值：$e^{\\text{fine}}_{2I+1, 2J} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I,J-1})$。\n- 沿垂直边的细网格点是两个粗网格邻点的平均值：$e^{\\text{fine}}_{2I, 2J+1} = \\frac{1}{2}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J})$。\n- 位于交叉位置的细网格点是四个粗网格邻点的平均值：$e^{\\text{fine}}_{2I, 2J} = \\frac{1}{4}(e^{\\text{coarse}}_{I,J} + e^{\\text{coarse}}_{I-1,J} + e^{\\text{coarse}}_{I,J-1} + e^{\\text{coarse}}_{I-1,J-1})$。\n通过假设粗网格外部的值为零来处理边界条件。\n\n**4. V 循环算法**\n\n用于求解网格层级 $k$ 上 $A^k u^k = f^k$ 的单个 V 循环被递归定义如下：\n\n1.  **基本情况：** 如果网格是最粗的（此处为 $N_k \\le 3$），则直接求解系统 $A^k u^k = f^k$。这涉及构建小的密集矩阵 $A^k$ 并使用像 LU 分解这样的标准线性求解器。\n2.  **递归步骤（对于更细的网格）：**\n    a. **预光滑：** 对 $u^k$ 的当前近似解应用 $\\nu_1 = 3$ 步加权雅可比光滑。\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_1}(A^k, f^k, u^k)\n    $$\n    b. **计算残差：** 在细网格上计算残差：$r^k = f^k - A^k u^k$。\n    c. **限制：** 将残差转移到下一个更粗的层级 $k+1$。\n    $$\n    r^{k+1} = R r^k\n    $$\n    d. **粗网格求解：** 在粗网格上求解残差方程 $A^{k+1} e^{k+1} = r^{k+1}$，以获得误差校正 $e^{k+1}$。这是通过对 V 循环算法进行递归调用来完成的，误差的初始猜测为零。\n    $$\n    e^{k+1} = \\text{V-cycle}(A^{k+1}, r^{k+1}, \\text{initial guess } 0)\n    $$\n    e. **延长：** 将计算出的误差校正插值回细网格。\n    $$\n    e^k = P e^{k+1}\n    $$\n    f. **校正：** 更新细网格解。\n    $$\n    u^k \\leftarrow u^k + e^k\n    $$\n    g. **后光滑：** 对校正后的解应用 $\\nu_2 = 3$ 步加权雅可比光滑。\n    $$\n    u^k \\leftarrow \\text{Smooth}^{\\nu_2}(A^k, f^k, u^k)\n    $$\nV 循环过程以零初始猜测 $u=0$ 启动，并进行迭代，直到相对残差 $\\rho = \\lVert f-Au \\rVert_2 / \\lVert f \\rVert_2$ 低于容差 $\\epsilon = 10^{-8}$ 或达到最大循环次数 $K=20$。报告最终达到的 $\\rho$ 值。", "answer": "```python\nimport numpy as np\n\nclass VCycleSolver:\n    \"\"\"\n    A geometric multigrid V-cycle solver for the 2D Poisson equation.\n    \"\"\"\n    def __init__(self, omega=2/3, nu1=3, nu2=3, coarsest_n=3):\n        self.omega = omega\n        self.nu1 = nu1\n        self.nu2 = nu2\n        self.coarsest_n = coarsest_n\n        self._coarsest_matrices = {}\n\n    def _apply_A(self, u, h):\n        \"\"\"Applies the 5-point stencil discrete Laplacian operator.\"\"\"\n        u_padded = np.pad(u, 1, mode='constant', constant_values=0)\n        # 4*u_ij - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}\n        laplacian = (4 * u -\n                     (u_padded[1:-1, 2:] + u_padded[1:-1, :-2] +\n                      u_padded[2:, 1:-1] + u_padded[:-2, 1:-1]))\n        return laplacian / (h**2)\n\n    def _weighted_jacobi(self, u, f, h, nu):\n        \"\"\"Performs `nu` steps of weighted Jacobi smoothing.\"\"\"\n        D_inv = h**2 / 4.0\n        for _ in range(nu):\n            r = f - self._apply_A(u, h)\n            u += self.omega * D_inv * r\n        return u\n\n    def _restrict(self, r_fine):\n        \"\"\"Performs full-weighting restriction.\"\"\"\n        # Stencil: 1/16 * [[1, 2, 1], [2, 4, 2], [1, 2, 1]]\n        r_coarse = (\n            4 * r_fine[1::2, 1::2] +\n            2 * (r_fine[1::2, 0:-1:2] + r_fine[1::2, 2::2] +\n                 r_fine[0:-1:2, 1::2] + r_fine[2::2, 1::2]) +\n            1 * (r_fine[0:-1:2, 0:-1:2] + r_fine[0:-1:2, 2::2] +\n                 r_fine[2::2, 0:-1:2] + r_fine[2::2, 2::2])\n        ) / 16.0\n        return r_coarse\n\n    def _prolongate(self, e_coarse):\n        \"\"\"Performs bilinear interpolation for prolongation.\"\"\"\n        Nc = e_coarse.shape[0]\n        Nf = 2 * Nc + 1\n        e_fine = np.zeros((Nf, Nf))\n\n        # Direct injection\n        e_fine[1::2, 1::2] = e_coarse\n\n        # Pad for easier interpolation\n        e_coarse_padded = np.pad(e_coarse, 1, mode='constant', constant_values=0)\n\n        # Interpolate vertical edges (average of horizontal neighbors)\n        e_fine[1::2, 0::2] = 0.5 * (e_coarse_padded[1:-1, :-1] + e_coarse_padded[1:-1, 1:])\n\n        # Interpolate horizontal edges (average of vertical neighbors)\n        e_fine[0::2, 1::2] = 0.5 * (e_coarse_padded[:-1, 1:-1] + e_coarse_padded[1:, 1:-1])\n\n        # Interpolate center points (average of 4 diagonal neighbors)\n        e_fine[0::2, 0::2] = 0.25 * (e_coarse_padded[:-1, :-1] + e_coarse_padded[:-1, 1:] +\n                                     e_coarse_padded[1:, :-1] + e_coarse_padded[1:, 1:])\n        return e_fine\n\n    def _get_coarsest_A(self, N, h):\n        \"\"\"Builds and caches the matrix for the coarsest grid.\"\"\"\n        if N in self._coarsest_matrices:\n            return self._coarsest_matrices[N]\n\n        size = N * N\n        if size == 0:\n            return np.zeros((0, 0))\n            \n        T_n = np.diag(np.full(N, 4.0)) - np.diag(np.ones(N - 1), 1) - np.diag(np.ones(N - 1), -1)\n        A = (np.kron(np.eye(N), T_n) +\n             np.kron(np.diag(np.ones(N - 1), 1), -np.eye(N)) +\n             np.kron(np.diag(np.ones(N - 1), -1), -np.eye(N)))\n        A /= h**2\n        self._coarsest_matrices[N] = A\n        return A\n\n    def _solve_coarsest(self, f, N, h):\n        \"\"\"Directly solves the system on the coarsest grid.\"\"\"\n        if N == 0:\n            return np.zeros((0,0))\n        A = self._get_coarsest_A(N, h)\n        u_vec = np.linalg.solve(A, f.flatten())\n        return u_vec.reshape((N, N))\n\n    def run_v_cycle(self, u, f, N):\n        \"\"\"Executes one recursive V-cycle.\"\"\"\n        h = 1.0 / (N + 1)\n\n        # 1. Base case: solve directly on coarsest grid\n        if N = self.coarsest_n:\n            return self._solve_coarsest(f, N, h)\n\n        # 2. Pre-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu1)\n\n        # 3. Compute residual\n        r = f - self._apply_A(u, h)\n\n        # 4. Restrict residual\n        r_coarse = self._restrict(r)\n\n        # 5. Solve coarse-grid error equation recursively\n        Nc = (N - 1) // 2\n        e_coarse_initial = np.zeros((Nc, Nc))\n        e_coarse = self.run_v_cycle(e_coarse_initial, r_coarse, Nc)\n\n        # 6. Prolongate error correction\n        e_fine = self._prolongate(e_coarse)\n\n        # 7. Correct fine-grid solution\n        u += e_fine\n\n        # 8. Post-smoothing\n        u = self._weighted_jacobi(u, f, h, self.nu2)\n\n        return u\n\n    def solve_system(self, N, f, tol, max_cycles):\n        \"\"\"Iteratively solves the system using V-cycles.\"\"\"\n        u = np.zeros((N, N))\n        h = 1.0 / (N + 1)\n        \n        norm_f = np.linalg.norm(f.flatten())\n        if norm_f == 0:\n            return 0.0\n\n        r = f - self._apply_A(u, h)\n        rel_res = np.linalg.norm(r.flatten()) / norm_f\n\n        for _ in range(max_cycles):\n            if rel_res = tol:\n                break\n            u = self.run_v_cycle(u, f, N)\n            r = f - self._apply_A(u, h)\n            rel_res = np.linalg.norm(r.flatten()) / norm_f\n        \n        return rel_res\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        {'N': 63, 'sources': [(31, 31)]},\n        {'N': 63, 'sources': [(1, 1)]},\n        {'N': 31, 'sources': [(7, 7), (23, 23)]},\n        {'N': 31, 'sources': [(0, 0)]},\n    ]\n    epsilon = 1e-8\n    K = 20\n\n    solver = VCycleSolver(omega=2/3, nu1=3, nu2=3)\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        sources = case['sources']\n        \n        h = 1.0 / (N + 1)\n        f = np.zeros((N, N))\n        for i0, j0 in sources:\n            f[i0, j0] = 1.0 / h**2\n        \n        final_rho = solver.solve_system(N, f, epsilon, K)\n        results.append(f\"{final_rho:.6g}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2415837"}, {"introduction": "椭圆问题的应用范畴远不止于网格上的偏微分方程。本练习 [@problem_id:2415820] 将您的视野拓展到图论领域，展示了类似的数学结构如何出现在力引导图布局等截然不同的问题中。您将看到，通过最小化一个能量函数，如何自然地导出一个由图拉普拉斯算子定义的线性系统。这不仅突显了多重网格类求解器的广泛适用性，也为探索更高级的代数多重网格 (AMG) 方法提供了动机，后者可用于解决非结构化问题。", "problem": "给定一个无向简单图，其顶点集为 $V=\\{0,1,\\dots,N-1\\}$，边集为 $E \\subseteq V \\times V$。图中有一部分锚定顶点 $A \\subset V$，其二维位置 $\\{\\mathbf{g}_i \\in \\mathbb{R}^2 : i \\in A\\}$ 是固定的；另一部分是自由顶点 $U = V \\setminus A$，其位置未知。考虑以下二次能量函数：\n$$\n\\mathcal{E}(\\{\\mathbf{p}_i\\}_{i \\in V}) \\;=\\; \\frac{k_a}{2} \\sum_{(i,j)\\in E} \\|\\mathbf{p}_i - \\mathbf{p}_j\\|_2^2 \\;+\\; \\frac{k_r}{2}\\sum_{i\\in V} \\|\\mathbf{p}_i - \\bar{\\mathbf{p}}\\|_2^2,\n$$\n其中 $k_a \\ge 0$ 和 $k_r \\ge 0$ 是给定的实数参数，$\\bar{\\mathbf{p}} = \\frac{1}{N}\\sum_{i\\in V}\\mathbf{p}_i$ 是形心。所有顶点的位置 $\\{\\mathbf{p}_i\\}$ 受到约束 $\\mathbf{p}_i = \\mathbf{g}_i$（对所有 $i \\in A$）。令 $\\mathbf{L}\\in\\mathbb{R}^{N\\times N}$ 为未归一化的图拉普拉斯矩阵，其元素为 $L_{ii}=\\deg(i)$，若 $(i,j)\\in E$ 则 $L_{ij}=-1$，否则 $L_{ij}=0$。令 $\\mathbf{J}\\in\\mathbb{R}^{N\\times N}$ 为全一矩阵。证明自由顶点的驻定条件可导出一个如下形式的线性系统：\n$$\n\\Big(k_a\\,\\mathbf{L} + k_r\\big(\\mathbf{I} - \\tfrac{1}{N}\\mathbf{J}\\big)\\Big)_{UU}\\,\\mathbf{p}_U \\;=\\; -\\Big(k_a\\,\\mathbf{L} + k_r\\big(\\mathbf{I} - \\tfrac{1}{N}\\mathbf{J}\\big)\\Big)_{UA}\\,\\mathbf{p}_A,\n$$\n其中 $\\mathbf{p}_U$ 和 $\\mathbf{p}_A$ 分别堆叠了未知位置和锚定位置。两个空间分量是独立的，并且满足相同的标量线性系统。\n\n你的任务是，为每个指定的测试用例，计算与锚点一致的唯一最小化子，并评估该最小化子处的总能量 $\\mathcal{E}$。将每个测试用例的结果报告为一个实数。所有计算都是无量纲的，不需要物理单位。\n\n测试套件：\n- 测试用例 1（两端锚定且具有弱形心排斥的一维路径图）：\n  - 图：包含 $N=5$ 个顶点的路径图，边为 $(0,1),(1,2),(2,3),(3,4)$。\n  - 锚点：$A=\\{0,4\\}$，其中 $\\mathbf{g}_0=(0,0)$ 且 $\\mathbf{g}_4=(1,0)$。\n  - 参数：$k_a=1$ 和 $k_r=0.1$。\n- 测试用例 2（具有完全边界锚定且无形心排斥的二维矩形网格图）：\n  - 图：一个 $5\\times 5$ 的网格图，有 $N=25$ 个顶点，标记为 $(i,j)$，其中 $i,j\\in\\{0,1,2,3,4\\}$。边连接在轴对齐且单位间距的相邻顶点之间。\n  - 锚点：所有边界顶点 $\\{(i,j): i\\in\\{0,4\\}\\ \\text{或}\\ j\\in\\{0,4\\}\\}$ 被固定到它们在单位正方形中的归一化坐标，即 $\\mathbf{g}_{(i,j)}=\\big(i/4,\\; j/4\\big)$。内部顶点 $\\{(i,j): i,j\\in\\{1,2,3\\}\\}$ 是自由的。\n  - 参数：$k_a=1$ 和 $k_r=0$。\n- 测试用例 3（两端锚定且具有强形心排斥的一维路径图）：\n  - 图：包含 $N=3$ 个顶点的路径图，边为 $(0,1),(1,2)$。\n  - 锚点：$A=\\{0,2\\}$，其中 $\\mathbf{g}_0=(0,0)$ 且 $\\mathbf{g}_2=(1,0)$。\n  - 参数：$k_a=1$ 和 $k_r=1$。\n- 测试用例 4（具有单个锚点且无形心排斥的一维路径图）：\n  - 图：包含 $N=2$ 个顶点的路径图，边为 $(0,1)$。\n  - 锚点：$A=\\{0\\}$，其中 $\\mathbf{g}_0=(0,0)$。顶点 $1$ 是自由的。\n  - 参数：$k_a=1$ 和 $k_r=0$。\n\n所需输出：\n- 对于每个测试用例，计算最小化构型 $\\{\\mathbf{p}_i\\}$，并以实数形式评估该构型下的总能量 $\\mathcal{E}$。\n- 你的程序应生成单行输出，包含一个由方括号括起来的逗号分隔列表（例如，\"[$\\text{result}_1$,$\\text{result}_2$,$\\text{result}_3$,$\\text{result}_4$]\"）。\n- 每个结果必须四舍五入到小数点后恰好 $6$ 位。输出中的数值必须是十进制形式（不是科学记数法）。\n\n问题陈述中不应陈述或使用任何方法论假设；该问题纯粹是关于在线性约束下最小化二次能量并报告所得能量值。测试用例的最终答案必须是指定的实数。", "solution": "所述问题是有效的。这是一个适定的数学优化问题，其基础是最小化势能泛函的物理原理。它自成体系、客观，且其所有组成部分都经过严格定义。我将继续进行求解。\n\n问题的核心是找到一组位置 $\\{\\mathbf{p}_i \\in \\mathbb{R}^2\\}_{i \\in V}$，使二次能量泛函\n$$\n\\mathcal{E}(\\{\\mathbf{p}_i\\}) \\;=\\; \\frac{k_a}{2} \\sum_{(i,j)\\in E} \\|\\mathbf{p}_i - \\mathbf{p}_j\\|_2^2 \\;+\\; \\frac{k_r}{2}\\sum_{i\\in V} \\|\\mathbf{p}_i - \\bar{\\mathbf{p}}\\|_2^2\n$$\n最小化，同时满足约束条件 $\\mathbf{p}_i = \\mathbf{g}_i$（对所有锚定顶点 $i \\in A$）。自由顶点的集合表示为 $U = V \\setminus A$。位置 $\\{\\mathbf{p}_i\\}_{i \\in U}$ 是待优化的变量。\n\n问题的空间分量是解耦的。能量泛函可以对 $x$ 和 $y$ 坐标进行可加分离。设 $\\mathbf{x} \\in \\mathbb{R}^N$ 和 $\\mathbf{y} \\in \\mathbb{R}^N$ 分别是所有 $x$ 和 $y$ 坐标的向量。总能量为 $\\mathcal{E} = \\mathcal{E}_x(\\mathbf{x}) + \\mathcal{E}_y(\\mathbf{y})$，其中 $\\mathcal{E}_x$ 和 $\\mathcal{E}_y$ 的形式相同。我们将推导 $x$ 坐标的系统；$y$ 坐标的系统可类似得到。\n$$\n\\mathcal{E}_x(\\mathbf{x}) = \\frac{k_a}{2} \\sum_{(i,j)\\in E} (x_i - x_j)^2 + \\frac{k_r}{2}\\sum_{i\\in V} (x_i - \\bar{x})^2\n$$\n第一项是涉及图拉普拉斯矩阵 $\\mathbf{L}$ 的二次型。它可以写成 $\\frac{k_a}{2} \\mathbf{x}^T \\mathbf{L} \\mathbf{x}$。第二项涉及形心 $\\bar{x} = \\frac{1}{N} \\sum_{j=1}^N x_j = \\frac{1}{N} \\mathbf{1}^T \\mathbf{x}$。该项可以写成 $\\frac{k_r}{2} \\|\\mathbf{x} - \\bar{x}\\mathbf{1}\\|_2^2 = \\frac{k_r}{2} \\|\\mathbf{x} - \\frac{1}{N}\\mathbf{J}\\mathbf{x}\\|_2^2$，其中 $\\mathbf{J}$ 是全一矩阵。令 $\\mathbf{P} = \\mathbf{I} - \\frac{1}{N}\\mathbf{J}$ 为到与向量 $\\mathbf{1}$ 正交的子空间上的投影矩阵。由于 $\\mathbf{P}$ 是一个投影，$\\mathbf{P}^T\\mathbf{P} = \\mathbf{P}$。因此，第二项是 $\\frac{k_r}{2} \\mathbf{x}^T \\mathbf{P} \\mathbf{x}$。\n\n因此，$x$ 坐标的总能量为\n$$\n\\mathcal{E}_x(\\mathbf{x}) = \\frac{1}{2} \\mathbf{x}^T \\Big(k_a\\mathbf{L} + k_r\\big(\\mathbf{I} - \\tfrac{1}{N}\\mathbf{J}\\big)\\Big) \\mathbf{x} = \\frac{1}{2}\\mathbf{x}^T \\mathbf{M} \\mathbf{x},\n$$\n其中 $\\mathbf{M} = k_a\\mathbf{L} + k_r\\big(\\mathbf{I} - \\tfrac{1}{N}\\mathbf{J}\\big)$。\n\n为了找到最小值，我们必须求解与自由顶点 $U$ 对应的未知坐标 $\\mathbf{x}_U$。让我们根据集合 $U$ 和 $A$ 对向量 $\\mathbf{x}$ 和矩阵 $\\mathbf{M}$ 进行分块。设 $\\mathbf{x}_U$ 是 $U$ 中顶点的坐标向量，$\\mathbf{x}_A$ 是 $A$ 中顶点的已知坐标向量。\n$$\n\\mathcal{E}_x(\\mathbf{x}_U) = \\frac{1}{2} \\begin{pmatrix} \\mathbf{x}_U^T  \\mathbf{x}_A^T \\end{pmatrix} \\begin{pmatrix} \\mathbf{M}_{UU}  \\mathbf{M}_{UA} \\\\ \\mathbf{M}_{AU}  \\mathbf{M}_{AA} \\end{pmatrix} \\begin{pmatrix} \\mathbf{x}_U \\\\ \\mathbf{x}_A \\end{pmatrix}\n$$\n展开此表达式得到\n$$\n\\mathcal{E}_x(\\mathbf{x}_U) = \\frac{1}{2} (\\mathbf{x}_U^T \\mathbf{M}_{UU} \\mathbf{x}_U + 2 \\mathbf{x}_U^T \\mathbf{M}_{UA} \\mathbf{x}_A + \\mathbf{x}_A^T \\mathbf{M}_{AA} \\mathbf{x}_A),\n$$\n这里我们使用了对称性 $\\mathbf{M}_{AU} = \\mathbf{M}_{UA}^T$。为找到驻点，我们计算 $\\mathcal{E}_x$ 相对于 $\\mathbf{x}_U$ 的梯度并将其设为零：\n$$\n\\nabla_{\\mathbf{x}_U} \\mathcal{E}_x = \\mathbf{M}_{UU} \\mathbf{x}_U + \\mathbf{M}_{UA} \\mathbf{x}_A = \\mathbf{0}.\n$$\n这就得出了未知坐标的线性系统：\n$$\n\\mathbf{M}_{UU} \\mathbf{x}_U = -\\mathbf{M}_{UA} \\mathbf{x}_A.\n$$\n由于这对 $x$ 和 $y$ 坐标都成立，我们可以用位置向量来表示它，其中 $\\mathbf{p}_U$ 是一个 $|U|\\times 2$ 的未知位置矩阵，$\\mathbf{p}_A$ 是一个 $|A|\\times 2$ 的锚定位置矩阵：\n$$\n\\mathbf{M}_{UU} \\mathbf{p}_U = -\\mathbf{M}_{UA} \\mathbf{p}_A.\n$$\n这证实了问题陈述中给出的形式。对于至少有一个锚点的连通图，矩阵 $\\mathbf{M}_{UU}$ 是对称正定的，保证了唯一解的存在。\n\n解决每个测试用例的算法如下：\n1. 根据边集 $E$ 构建图拉普拉斯矩阵 $\\mathbf{L}$。\n2. 构建系统矩阵 $\\mathbf{M} = k_a\\mathbf{L} + k_r(\\mathbf{I} - \\frac{1}{N}\\mathbf{J})$。\n3. 识别自由 ($U$) 和锚定 ($A$) 顶点的集合及其对应的索引。\n4. 提取子矩阵 $\\mathbf{M}_{UU}$ 和 $\\mathbf{M}_{UA}$ 以及锚点位置矩阵 $\\mathbf{p}_A$。\n5. 求解线性系统 $\\mathbf{M}_{UU}\\mathbf{p}_U = -\\mathbf{M}_{UA}\\mathbf{p}_A$ 以获得未知位置 $\\mathbf{p}_U$。\n6. 重构包含自由和锚定顶点的完整位置矩阵 $\\mathbf{p}$。\n7. 使用完整的位置集合 $\\{\\mathbf{p}_i\\}$ 计算总能量 $\\mathcal{E}$。这可以高效地计算为 $\\mathcal{E} = \\frac{1}{2} \\mathrm{Tr}(\\mathbf{p}^T \\mathbf{M} \\mathbf{p})$。\n\n此过程应用于每个测试用例。\n对于测试用例 1，一个 $N=5$ 个顶点的路径图，该系统通过数值方法求解。\n对于测试用例 2，一个 $5\\times 5$ 的网格，其边界被锚定且 $k_r=0$，解可以通过观察得到。最小化子对应于一个离散调和函数，这导致了边界位置的线性插值，即 $\\mathbf{p}_{(i,j)}=(i/4, j/4)$。能量为 $\\mathcal{E} = 1.25$。\n对于测试用例 3，一个 $N=3$ 个顶点的路径图，该问题有一个简单的解析解 $\\mathbf{p}_1 = (1/2, 0)$，得到的能量为 $\\mathcal{E}=0.5$。\n对于测试用例 4，一个 $N=2$ 个顶点且有一个锚点的路径图，自由顶点被拉到与锚点相同的位置，导致能量为零，$\\mathcal{E}=0$。\n\n根据所述算法计算数值结果。", "answer": "```python\nimport numpy as np\n\ndef compute_energy_for_case(N, edges, anchors, k_a, k_r):\n    \"\"\"\n    Computes the minimum energy for a given graph layout problem.\n\n    Args:\n        N (int): Number of vertices.\n        edges (list of tuples): List of edges in the graph.\n        anchors (dict): Dictionary mapping anchored vertex indices to their (x, y) positions.\n        k_a (float): Spring constant for the attractive term.\n        k_r (float): Repulsion constant for the centroid term.\n\n    Returns:\n        float: The total energy at the minimizing configuration.\n    \"\"\"\n    # 1. Setup indices\n    all_indices = set(range(N))\n    anchor_indices = sorted(list(anchors.keys()))\n    free_indices = sorted(list(all_indices - set(anchor_indices)))\n\n    # 2. Build matrices L and M\n    L = np.zeros((N, N))\n    for i, j in edges:\n        L[i, j] = -1\n        L[j, i] = -1\n        L[i, i] += 1\n        L[j, j] += 1\n    \n    M = k_a * L\n    if k_r > 0:\n        J = np.ones((N, N))\n        M += k_r * (np.identity(N) - J / N)\n    \n    # 3. Partition M and setup linear system\n    num_free = len(free_indices)\n    num_anchors = len(anchor_indices)\n\n    if num_free == 0:\n        p_full = np.zeros((N, 2))\n        if num_anchors > 0:\n            p_A = np.array([anchors[i] for i in anchor_indices])\n            p_full[anchor_indices, :] = p_A\n        energy = 0.5 * np.trace(p_full.T @ M @ p_full)\n        return energy\n\n    M_UU = M[np.ix_(free_indices, free_indices)]\n    M_UA = M[np.ix_(free_indices, anchor_indices)]\n    \n    p_A = np.array([anchors[i] for i in anchor_indices])\n    \n    # 4. Solve for free vertex positions\n    if num_anchors > 0:\n        RHS = -M_UA @ p_A\n    else:\n        RHS = np.zeros((num_free, 2))\n        \n    p_U = np.linalg.solve(M_UU, RHS)\n    \n    # 5. Assemble full position matrix\n    p_full = np.zeros((N, 2))\n    if num_free > 0:\n        p_full[free_indices, :] = p_U\n    if num_anchors > 0:\n        p_full[anchor_indices, :] = p_A\n\n    # 6. Calculate total energy\n    energy = 0.5 * np.trace(p_full.T @ M @ p_full)\n    \n    return energy\n\ndef solve():\n    \"\"\"\n    Defines test cases and computes the energy for each, printing the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {\n            \"N\": 5,\n            \"edges\": [(0, 1), (1, 2), (2, 3), (3, 4)],\n            \"anchors\": {0: (0.0, 0.0), 4: (1.0, 0.0)},\n            \"k_a\": 1.0,\n            \"k_r\": 0.1\n        },\n        # Test case 2\n        {\n            \"N\": 25,\n            \"edges\": [\n                (i * 5 + j, i * 5 + j + 1) for i in range(5) for j in range(4)\n            ] + [\n                (i * 5 + j, (i + 1) * 5 + j) for i in range(4) for j in range(5)\n            ],\n            \"anchors\": {\n                i * 5 + j: (i / 4.0, j / 4.0)\n                for i in range(5) for j in range(5)\n                if i in {0, 4} or j in {0, 4}\n            },\n            \"k_a\": 1.0,\n            \"k_r\": 0.0\n        },\n        # Test case 3\n        {\n            \"N\": 3,\n            \"edges\": [(0, 1), (1, 2)],\n            \"anchors\": {0: (0.0, 0.0), 2: (1.0, 0.0)},\n            \"k_a\": 1.0,\n            \"k_r\": 1.0\n        },\n        # Test case 4\n        {\n            \"N\": 2,\n            \"edges\": [(0, 1)],\n            \"anchors\": {0: (0.0, 0.0)},\n            \"k_a\": 1.0,\n            \"k_r\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        energy = compute_energy_for_case(\n            case[\"N\"], case[\"edges\"], case[\"anchors\"], case[\"k_a\"], case[\"k_r\"]\n        )\n        results.append(energy)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2415820"}]}