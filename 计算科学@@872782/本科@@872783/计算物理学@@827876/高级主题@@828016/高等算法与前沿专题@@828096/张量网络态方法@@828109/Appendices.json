{"hands_on_practices": [{"introduction": "我们的第一个实践练习旨在建立具体直觉，将一个简单的量子多体态精确地表示为矩阵乘积态 (Matrix Product State, MPS)[@problem_id:2445466]。这个练习将量子力学中的熟悉概念（如费米子系统的基态）与张量网络的语言直接联系起来。通过为一个仅有两个格点的微观系统手动构建MPS张量，你将深入理解MPS如何编码量子态的振幅，并学会如何运用它来计算纠缠熵等关键物理量。", "problem": "考虑一个具有开放边界条件、包含 $L=2$ 个无自旋费米子格点的一维链。格点 $j \\in \\{1,2\\}$ 上的产生和湮灭算符 $c_{j}^{\\dagger}$ 和 $c_{j}$ 满足正则反对易关系 $\\{c_{i},c_{j}^{\\dagger}\\}=\\delta_{ij}$ 和 $\\{c_{i},c_{j}\\}=0=\\{c_{i}^{\\dagger},c_{j}^{\\dagger}\\}$。哈密顿量为\n$$\nH \\;=\\; -\\,t\\,\\big(c_{1}^{\\dagger}c_{2}+c_{2}^{\\dagger}c_{1}\\big)\\,,\n$$\n其中 $t>0$。在总粒子数为 $N=1$ 的扇区中进行计算。从以上定义出发，不作任何进一步假设，完成以下任务：\n\n- 确定 $N=1$ 扇区中哈密顿量 $H$ 的唯一归一化基态 $\\lvert\\psi_{0}\\rangle$，并用占据数基 $\\{|n_{1}n_{2}\\rangle\\}$（其中 $n_{j}\\in\\{0,1\\}$）表示。\n- 将 $\\lvert\\psi_{0}\\rangle$ 精确地表示为矩阵乘积态（MPS），即\n$$\n\\lvert\\psi_{0}\\rangle \\;=\\; \\sum_{n_{1},n_{2}\\in\\{0,1\\}} A^{[1]}_{n_{1}}\\,A^{[2]}_{n_{2}}\\,\\lvert n_{1}n_{2}\\rangle\\,,\n$$\n其中对于某个最小键维 $\\chi$，$A^{[1]}_{n_{1}}$ 是一个 $1\\times \\chi$ 的行向量，$A^{[2]}_{n_{2}}$ 是一个 $\\chi\\times 1$ 的列向量。你的 MPS 必须精确地复现 $\\lvert\\psi_{0}\\rangle$ 在占据数基下的振幅。\n- 使用你的 MPS，直接验证两点关联函数 $\\langle \\psi_{0}|\\,c_{1}^{\\dagger}c_{2}\\,|\\psi_{0}\\rangle$ 具有 $\\lvert\\psi_{0}\\rangle$ 所蕴含的正确值，并验证格点 1 的约化密度矩阵 $\\rho_{1}=\\mathrm{Tr}_{2}\\,\\lvert\\psi_{0}\\rangle\\langle\\psi_{0}|$ 是正确归一化且半正定的。\n\n答案要求：\n- 计算穿过 $\\{1\\}|\\{2\\}$ 二分划的 von Neumann 纠缠熵，其定义为 $S \\equiv -\\mathrm{Tr}\\big(\\rho_{1}\\,\\ln \\rho_{1}\\big)$，并将其作为最终答案。\n- 无需四舍五入；提供一个精确的闭式解析表达式。\n- 最终答案不包含任何单位；熵以纳特（自然对数）为单位报告。", "solution": "所提出的问题是量子多体物理学中的一个标准练习，它定义明确、有科学依据且客观。问题包含了确定唯一解所需的所有信息。因此，我们进行全面的分析。\n\n该系统是一个由 $L=2$ 个无自旋费米子格点构成的一维链。我们被限制在总粒子数为 $N=1$ 的扇区内。该扇区的基矢是 $\\lvert 10\\rangle$（表示格点1上有一个费米子，格点2上没有）和 $\\lvert 01\\rangle$（表示格点2上有一个费米子，格点1上没有）。因此，该扇区的希尔伯特空间是二维的。\n\n哈密顿量由 $H = -t(c_{1}^{\\dagger}c_{2}+c_{2}^{\\dagger}c_{1})$ 给出，其中 $t>0$。我们在基 $\\{\\lvert 10\\rangle, \\lvert 01\\rangle\\}$ 下求 $H$ 的矩阵表示。我们将 $H$ 应用于每个基矢：\n$$\nH\\lvert 10\\rangle = -t(c_{1}^{\\dagger}c_{2}+c_{2}^{\\dagger}c_{1})\\lvert 10\\rangle = -t(c_{1}^{\\dagger}c_{2}\\lvert 10\\rangle + c_{2}^{\\dagger}c_{1}\\lvert 10\\rangle)\n$$\n由于在 $\\lvert 10\\rangle$ 中格点2是空的，所以 $c_{2}\\lvert 10\\rangle = 0$。算符 $c_{1}$ 湮灭格点1上的一个费米子，得到真空态 $\\lvert 00\\rangle$，因此 $c_{1}\\lvert 10\\rangle = \\lvert 00\\rangle$。于是，$c_{2}^{\\dagger}c_{1}\\lvert 10\\rangle = c_{2}^{\\dagger}\\lvert 00\\rangle = \\lvert 01\\rangle$。因此，$H\\lvert 10\\rangle = -t\\lvert 01\\rangle$。\n\n类似地，我们将 $H$ 应用于 $\\lvert 01\\rangle$：\n$$\nH\\lvert 01\\rangle = -t(c_{1}^{\\dagger}c_{2}+c_{2}^{\\dagger}c_{1})\\lvert 01\\rangle = -t(c_{1}^{\\dagger}c_{2}\\lvert 01\\rangle + c_{2}^{\\dagger}c_{1}\\lvert 01\\rangle)\n$$\n这里，$c_{1}\\lvert 01\\rangle = 0$。我们有 $c_{2}\\lvert 01\\rangle=\\lvert 00\\rangle$，所以 $c_{1}^{\\dagger}c_{2}\\lvert 01\\rangle = c_{1}^{\\dagger}\\lvert 00\\rangle = \\lvert 10\\rangle$。因此，$H\\lvert 01\\rangle = -t\\lvert 10\\rangle$。\n\n在有序基 $(\\lvert 10\\rangle, \\lvert 01\\rangle)$ 中，哈密顿量矩阵为：\n$$\n\\mathbf{H} = \\begin{pmatrix} \\langle 10|H|10\\rangle  \\langle 10|H|01\\rangle \\\\ \\langle 01|H|10\\rangle  \\langle 01|H|01\\rangle \\end{pmatrix} = \\begin{pmatrix} 0  -t \\\\ -t  0 \\end{pmatrix}\n$$\n特征值 $\\lambda$ 可通过 $\\det(\\mathbf{H} - \\lambda I) = \\lambda^2 - t^2 = 0$ 求得，解得 $\\lambda = \\pm t$。由于 $t>0$，基态能量为 $E_0 = -t$。对应的特征向量 $(a, b)^T$ 满足 $(\\mathbf{H} - E_0 I)\\begin{pmatrix} a \\\\ b \\end{pmatrix} = 0$：\n$$\n\\begin{pmatrix} t  -t \\\\ -t  t \\end{pmatrix} \\begin{pmatrix} a \\\\ b \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix} \\implies ta - tb = 0 \\implies a = b\n$$\n未归一化的基态是 $\\lvert 10\\rangle + \\lvert 01\\rangle$。对该态进行归一化，我们得到唯一的归一化基态 $\\lvert\\psi_0\\rangle$：\n$$\n\\lvert\\psi_0\\rangle = \\frac{1}{\\sqrt{2}} \\left( \\lvert 10\\rangle + \\lvert 01\\rangle \\right)\n$$\n\n接下来，我们将 $\\lvert\\psi_0\\rangle$ 表示为矩阵乘积态（MPS）。在占据数基 $\\{\\lvert n_1 n_2\\rangle\\}$ 中，该态为 $\\lvert\\psi_0\\rangle = \\sum_{n_1,n_2} C_{n_1 n_2} \\lvert n_1 n_2\\rangle$。系数矩阵为：\n$$\nC = \\begin{pmatrix} C_{00}  C_{01} \\\\ C_{10}  C_{11} \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}}  0 \\end{pmatrix}\n$$\n最小键维 $\\chi$ 是该矩阵的秩，即 $\\chi=2$。MPS 表示由 $C_{n_1 n_2} = A^{[1]}_{n_1} A^{[2]}_{n_2}$ 给出，其中对每个 $n_1 \\in \\{0, 1\\}$，$A^{[1]}_{n_1}$ 是一个 $1 \\times 2$ 的行向量；对每个 $n_2 \\in \\{0, 1\\}$，$A^{[2]}_{n_2}$ 是一个 $2 \\times 1$ 的列向量。我们用行向量 $A^{[1]}_{n_1}$ 构成一个 $2 \\times 2$ 矩阵 $M_1$，用列向量 $A^{[2]}_{n_2}$ 构成一个 $2 \\times 2$ 矩阵 $M_2$，使得 $C = M_1 M_2$。一个有效且简单的选择是 $M_1 = C$ 和 $M_2 = I$：\n$$\nA^{[1]}_0 = \\begin{pmatrix} 0  \\frac{1}{\\sqrt{2}} \\end{pmatrix}, \\quad A^{[1]}_1 = \\begin{pmatrix} \\frac{1}{\\sqrt{2}}  0 \\end{pmatrix}\n$$\n$$\nA^{[2]}_0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}, \\quad A^{[2]}_1 = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n$$\n这个选择满足条件并能精确地复现系数。\n\n现在我们使用这个 MPS 来验证两点关联函数 $\\langle \\psi_0 | c_1^\\dagger c_2 | \\psi_0 \\rangle$。首先，从精确态出发，我们有 $\\langle \\psi_0 | c_1^\\dagger c_2 | \\psi_0 \\rangle = \\frac{1}{2}(\\langle 10| + \\langle 01|)c_1^\\dagger c_2(\\lvert 10\\rangle + \\lvert 01\\rangle) = \\frac{1}{2}(\\langle 10| + \\langle 01|)c_1^\\dagger\\lvert 00\\rangle = \\frac{1}{2}(\\langle 10| + \\langle 01|)\\lvert 10\\rangle = \\frac{1}{2}$。\n为了用 MPS 计算这个值，我们使用两格点算符 $\\hat{O}_1 \\otimes \\hat{O}_2$ 的公式：\n$$\n\\langle \\psi_0 | \\hat{O}_1 \\otimes \\hat{O}_2 | \\psi_0 \\rangle = \\sum_{n_1,m_1,n_2,m_2} (A^{[1]}_{m_1}A^{[2]}_{m_2})^* \\langle m_1|\\hat{O}_1|n_1\\rangle \\langle m_2|\\hat{O}_2|n_2\\rangle (A^{[1]}_{n_1}A^{[2]}_{n_2})\n$$\n该表达式可以重排为：\n$$\n\\langle \\psi_0 | \\hat{O}_1 \\otimes \\hat{O}_2 | \\psi_0 \\rangle = \\sum_{n_2, m_2} \\langle m_2|\\hat{O}_2|n_2\\rangle (A^{[2]}_{m_2})^\\dagger \\left( \\sum_{n_1, m_1} \\langle m_1|\\hat{O}_1|n_1\\rangle (A^{[1]}_{m_1})^\\dagger A^{[1]}_{n_1} \\right) A^{[2]}_{n_2}\n$$\n令 $\\tilde{E}_1 = \\sum_{n_1, m_1} \\langle m_1|\\hat{O}_1|n_1\\rangle (A^{[1]}_{m_1})^\\dagger A^{[1]}_{n_1}$。对于 $\\hat{O}_1 = c_1^\\dagger$，唯一的非零矩阵元是 $\\langle 1|c_1^\\dagger|0\\rangle=1$。\n$$\n\\tilde{E}_1 = (A^{[1]}_1)^\\dagger A^{[1]}_0 = \\begin{pmatrix} \\frac{1}{\\sqrt{2}} \\\\ 0 \\end{pmatrix} \\begin{pmatrix} 0  \\frac{1}{\\sqrt{2}} \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{1}{2} \\\\ 0  0 \\end{pmatrix}\n$$\n因此期望值为 $\\sum_{n_2, m_2} \\langle m_2|\\hat{O}_2|n_2\\rangle (A^{[2]}_{m_2})^\\dagger \\tilde{E}_1 A^{[2]}_{n_2}$。对于 $\\hat{O}_2=c_2$，非零矩阵元为 $\\langle 0|c_2|1\\rangle=1$。\n$$\n\\langle \\psi_0 | c_1^\\dagger c_2 | \\psi_0 \\rangle = (A^{[2]}_0)^\\dagger \\tilde{E}_1 A^{[2]}_1 = \\begin{pmatrix} 1  0 \\end{pmatrix} \\begin{pmatrix} 0  \\frac{1}{2} \\\\ 0  0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 0  \\frac{1}{2} \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\frac{1}{2}\n$$\n这证实了值的正确性。\n\n最后，我们求约化密度矩阵 $\\rho_1 = \\mathrm{Tr}_2(\\lvert\\psi_0\\rangle\\langle\\psi_0|)$。在 MPS 形式体系中，这与从系数矩阵 $C = U S V^\\dagger$ 的奇异值分解（SVD）导出的施密特分解有关。$\\rho_1$ 的特征值是 $C$ 的奇异值的平方。奇异值是 $C C^\\dagger = \\frac{1}{2}I$ 的特征值的平方根，即 $\\sigma_1^2 = \\sigma_2^2 = \\frac{1}{2}$。所以奇异值为 $s_1 = s_2 = \\frac{1}{\\sqrt{2}}$。\n$\\rho_1$ 的特征值为 $\\lambda_{1,2} = s_{1,2}^2 = \\frac{1}{2}$。$\\rho_1$ 的特征向量是对应的施密特向量，即 $U$ 的列向量。由于 $C C^\\dagger$ 与单位矩阵成正比，我们可以选择 $U=I$，得到特征向量 $\\lvert 0\\rangle$ 和 $\\lvert 1\\rangle$。\n$$\n\\rho_1 = \\lambda_1 \\lvert 0\\rangle\\langle 0\\rvert + \\lambda_2 \\lvert 1\\rangle\\langle 1\\rvert = \\frac{1}{2}\\lvert 0\\rangle\\langle 0\\rvert + \\frac{1}{2}\\lvert 1\\rangle\\langle 1\\rvert = \\frac{1}{2} \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix}\n$$\n归一化：$\\mathrm{Tr}(\\rho_1) = \\frac{1}{2}+\\frac{1}{2}=1$。该矩阵是正确归一化的。\n半正定性：特征值 $\\frac{1}{2}, \\frac{1}{2}$ 均为非负。该矩阵是半正定的。\n\nvon Neumann 纠缠熵为 $S = -\\mathrm{Tr}(\\rho_1 \\ln \\rho_1)$。使用 $\\rho_1$ 的特征值 $\\lambda_i$：\n$$\nS = -\\sum_i \\lambda_i \\ln \\lambda_i = -\\left( \\frac{1}{2}\\ln\\left(\\frac{1}{2}\\right) + \\frac{1}{2}\\ln\\left(\\frac{1}{2}\\right) \\right) = - (2) \\left( \\frac{1}{2}\\ln\\left(\\frac{1}{2}\\right) \\right) = -\\ln\\left(\\frac{1}{2}\\right) = \\ln(2)\n$$\n纠缠熵为 $\\ln(2)$ 纳特，这是对二能级系统进行二分所能达到的最大值，表明是最大纠缠。", "answer": "$$\n\\boxed{\\ln(2)}\n$$", "id": "2445466"}, {"introduction": "在学会用MPS表示量子态之后，我们自然地转向如何用张量网络表示算符，即矩阵乘积算符 (Matrix Product Operator, MPO)[@problem_id:2445471]。本练习要求你为一个全局投影算符构建MPO表示，该算符用于筛选出具有特定总粒子数的量子态。通过引入一个在格点间传递粒子计数的“虚拟”指标，你将掌握MPO构造中的一个核心技巧：利用辅助自由度来高效地编码全局约束。", "problem": "考虑一个长度为 $L$ 的开放链，每个格点上的局域希尔伯特空间为 $\\{|0\\rangle, |1\\rangle\\}$，代表无自旋费米子的占据数基，其数算符 $n_i$ 满足 $n_i |0\\rangle = 0 |0\\rangle$ 和 $n_i |1\\rangle = 1 |1\\rangle$。全局希尔伯特空间是 $L$ 个局域空间的张量积。投影到总粒子数为 $N$ 的固定总粒子数扇区的投影算符，是一个作用在满足 $\\sum_{i=1}^{L} n_i = N$ 的态上为单位算符，并湮灭所有其他态的算符。\n\n仅使用矩阵乘积算符（MPO）和占据数基的基本定义，通过引入一个编码累积粒子数的虚键指标，构造该投影算符的显式 MPO 表示。你的 MPO 必须由以下部分指定：\n- 一个由从 $0$ 到 $N$ 的整数标记的态张成的键空间。\n- 强制总计数恰好为 $N$ 的左右边界向量。\n- 一个在占据数基下确保计数一致性和对角性的局域格点张量。\n\n然后，使用你的构造和第一性原理（不使用任何已有的计数公式），计算该投影算符的迹，并将其表示为关于 $L$ 和 $N$ 的闭合形式解析表达式。仅提供迹的最终表达式作为答案。不需要数值计算，也不涉及单位。[@problem_id:150]", "solution": "问题陈述具有科学依据、提法恰当、客观，并包含足够的信息以进行严格求解。因此，我们将着手进行推导。\n\n投影到总粒子数固定为 $N$ 的态所构成的子空间上的投影算符 $P_N$，在占据数基 $\\{|s_1 s_2 \\dots s_L\\rangle\\}$ 下是对角的，其中 $s_i \\in \\{0, 1\\}$ 是格点 $i$ 上的占据数。该算符可以写为：\n$$\nP_N = \\sum_{\\{s_i\\}} \\lambda(\\{s_i\\}) |s_1 \\dots s_L\\rangle \\langle s_1 \\dots s_L |\n$$\n其中，如果总粒子数 $\\sum_{i=1}^{L} s_i = N$，则本征值 $\\lambda(\\{s_i\\})$ 为 $1$，否则为 $0$。\n\n我们的任务是为 $P_N$ 构造一个矩阵乘积算符（MPO）表示。在这种表示中，本征值 $\\lambda(\\{s_i\\})$ 表示为矩阵的乘积：\n$$\n\\lambda(\\{s_i\\}) = B_L M^{s_1} M^{s_2} \\cdots M^{s_L} B_R\n$$\n此处，$M^{s_i}$ 是对应于局域物理态 $|s_i\\rangle$ 的矩阵，$B_L$ 是一个左边界行向量，$B_R$ 是一个右边界列向量。矩阵乘积是在一个虚拟“键”空间上进行的。\n\n该构造基于一个追踪累积粒子数的虚拟指标。\n\n$1$. **虚键空间**：\n虚键空间将由一组基态 $\\{|\\alpha\\rangle\\}$ 张成，其中指标 $\\alpha$ 代表到目前为止已计数的粒子数。由于总粒子数固定为 $N$，累积计数可以从 $0$ 到 $N$。任何累积计数超过 $N$ 的路径都是无效的。因此，虚键空间的维度为 $N+1$，指标 $\\alpha$ 取整数值 $0, 1, \\dots, N$。\n\n$2$. **局域格点张量**：\n格点 $i$ 上的局域张量是一组 $(N+1) \\times (N+1)$ 矩阵 $\\{M^0, M^1\\}$，对应于物理占据态 $|0\\rangle$ 和 $|1\\rangle$。矩阵元 $[M^s]_{\\alpha, \\beta}$ 连接一个输入的虚态 $|\\alpha\\rangle$（代表截至格点 $i-1$ 的计数）和一个输出的虚态 $|\\beta\\rangle$（代表截至格点 $i$ 的计数）。\n- 如果格点 $i$ 未被占据（$s_i=0$），粒子数不变。因此，输出计数 $\\beta$ 必须等于输入计数 $\\alpha$。这定义了矩阵 $M^0$：\n$$\n[M^0]_{\\alpha, \\beta} = \\delta_{\\alpha, \\beta} \\quad \\text{for } \\alpha, \\beta \\in \\{0, 1, \\dots, N\\}\n$$\n这个矩阵是 $(N+1) \\times (N+1)$ 的单位矩阵 $I$。\n- 如果格点 $i$ 被占据（$s_i=1$），粒子数增加一。输出计数 $\\beta$ 必须是 $\\alpha+1$。这定义了矩阵 $M^1$：\n$$\n[M^1]_{\\alpha, \\beta} = \\delta_{\\beta, \\alpha+1} \\quad \\text{for } \\alpha, \\beta \\in \\{0, 1, \\dots, N\\}\n$$\n这个矩阵在第一上副对角线上的元素等于 $1$（即 $[M^1]_{k, k+1} = 1$），其他位置的元素为零。这是一个幂零矩阵，我们将其记为 $S_u$，即“上移”算符。\n\n$3$. **边界向量**：\n- 左边界向量 $B_L$ 必须强制初始条件，即在第一个格点之前粒子数为 $0$。它是一个 $1 \\times (N+1)$ 的行向量，用于选择虚态 $|\\alpha=0\\rangle$：\n$$\nB_L = \\begin{pmatrix} 1  0  \\dots  0 \\end{pmatrix} = e_0^T\n$$\n- 右边界向量 $B_R$ 必须强制最终条件，即在最后一个格点 $L$ 之后总粒子数恰好为 $N$。它是一个 $(N+1) \\times 1$ 的列向量，用于选择虚态 $|\\alpha=N\\rangle$：\n$$\nB_R = \\begin{pmatrix} 0 \\\\ \\vdots \\\\ 0 \\\\ 1 \\end{pmatrix} = e_N\n$$\n通过这种构造，对于任何态 $|\\{s_i\\}\\rangle$ 的系数非零（且等于 $1$）的充要条件是，算符序列允许一条从虚态 $0$ 到虚态 $N$ 的路径。这恰好在乘积中 $M^1$ 矩阵的数量等于 $N$ 时发生，即对应于 $\\sum s_i = N$。\n\n现在，我们计算投影算符的迹 $\\text{Tr}(P_N)$。迹是在整个物理希尔伯特空间上对角元之和：\n$$\n\\text{Tr}(P_N) = \\sum_{s_1=0}^1 \\sum_{s_2=0}^1 \\cdots \\sum_{s_L=0}^1 \\langle s_1 \\dots s_L | P_N | s_1 \\dots s_L \\rangle\n$$\n使用对角元的 MPO 形式：\n$$\n\\text{Tr}(P_N) = \\sum_{\\{s_i\\}} (B_L M^{s_1} M^{s_2} \\cdots M^{s_L} B_R)\n$$\n由于求和的结构，我们可以重排这些项：\n$$\n\\text{Tr}(P_N) = B_L \\left(\\sum_{s_1=0}^1 M^{s_1}\\right) \\left(\\sum_{s_2=0}^1 M^{s_2}\\right) \\cdots \\left(\\sum_{s_L=0}^1 M^{s_L}\\right) B_R\n$$\n让我们定义转移矩阵 $T$ 为局域算符之和：\n$$\nT = \\sum_{s=0}^1 M^s = M^0 + M^1 = I + S_u\n$$\n迹则由以下乘积给出：\n$$\n\\text{Tr}(P_N) = B_L T^L B_R = e_0^T (I+S_u)^L e_N\n$$\n这个表达式对应于矩阵 $(I+S_u)^L$ 的第 $0$ 行、第 $N$ 列的矩阵元。\n我们使用二项式定理展开 $(I+S_u)^L$：\n$$\n(I+S_u)^L = \\sum_{k=0}^L \\binom{L}{k} I^{L-k} S_u^k = \\sum_{k=0}^L \\binom{L}{k} S_u^k\n$$\n因此，矩阵元为：\n$$\n[ (I+S_u)^L ]_{0,N} = \\sum_{k=0}^L \\binom{L}{k} [S_u^k]_{0,N}\n$$\n让我们分析上移矩阵 $S_u$ 的幂。$S_u$ 的元素为 $[S_u]_{\\alpha, \\beta} = \\delta_{\\alpha, \\beta-1}$。其 $k$ 次幂 $[S_u^k]_{\\alpha, \\beta}$ 的元素由下式给出：\n$$\n[S_u^k]_{\\alpha, \\beta} = \\delta_{\\alpha, \\beta-k}\n$$\n我们需要元素 $[S_u^k]_{0,N} = \\delta_{0, N-k}$。当 $k=N$ 时，该元素为 $1$，否则为 $0$。\n将此代入求和式中，只有 $k=N$ 的项保留下来：\n$$\n\\text{Tr}(P_N) = \\sum_{k=0}^L \\binom{L}{k} \\delta_{k,N} = \\binom{L}{N}\n$$\n这个结果在 $0 \\le N \\le L$ 时有效。如果 $N > L$，则对于 $k \\in \\{0, \\dots, L\\}$，条件 $k=N$ 永远不会满足，因此和为零，这正确地反映了在这种情况下 $\\binom{L}{N}=0$。迹是从 $L$ 个格点中选择 $N$ 个来放置粒子的方式总数，这正是被投影到的子空间的维度。", "answer": "$$\\boxed{\\binom{L}{N}}$$", "id": "2445471"}, {"introduction": "拥有了态 (MPS) 和算符 (MPO) 的表示之后，计算物理可观测量（如期望值 $\\langle\\Psi|\\hat{O}|\\Psi\\rangle$）就转化为收缩一个复杂的张量网络[@problem_id:2445469]。这个实践环节将揭示一个在实际计算中至关重要的问题：计算效率。你将学习到收缩网络的顺序会极大地影响计算成本，并通过编写程序为给定的网络寻找最优收缩路径，亲身体验聪明的算法如何能将一个指数级复杂的难题转变为一个可行的计算任务。", "problem": "给定一个由成对张量网络组成的族，这些张量网络是连通且闭合的，意味着每个指标标签恰好出现在两个张量中，并且网络收缩后得到一个标量。每个张量在概念上是一个复数值的多维数组。设存在一个有限的指标标签集 $\\mathcal{L}$，以及一个维度映射 $d : \\mathcal{L} \\to \\mathbb{N}$，它为每个标签 $\\ell \\in \\mathcal{L}$ 分配一个严格为正的整数维度 $d_{\\ell}$。一个张量 $t$ 由其模的指标标签集 $\\mathcal{I}_t \\subset \\mathcal{L}$ 指定。一对张量 $t_a$ 和 $t_b$ 是可收缩的，当且仅当 $\\mathcal{I}_{t_a} \\cap \\mathcal{I}_{t_b} \\neq \\varnothing$。$t_a$ 和 $t_b$ 沿其公共标签 $S = \\mathcal{I}_{t_a} \\cap \\mathcal{I}_{t_b}$ 的收缩会产生一个新的张量 $t_{ab}$，其标签集为 $\\mathcal{I}_{t_{ab}} = (\\mathcal{I}_{t_a} \\cup \\mathcal{I}_{t_b}) \\setminus S$。此过程重复进行，直到只剩下一个标签集为空的张量，该张量对应一个标量。\n\n在使用张量网络态方法的计算物理学中，一个标准的成本模型是计算复数乘加 (Complex Multiply-Add, CMA) 运算的次数。对于收缩两个张量 $t_a$ 和 $t_b$，CMA 计数是它们指标集并集中所有标签维度的乘积，即\n$$\n\\mathrm{cost}(t_a, t_b) \\;=\\; \\prod_{\\ell \\in \\mathcal{I}_{t_a} \\cup \\mathcal{I}_{t_b}} d_{\\ell}.\n$$\n一个完整收缩序列的总 CMA 成本是该序列中所有二元收缩步骤成本的总和。您的任务是编写一个完整的程序，对每个指定的张量网络，找出在所有有效收缩顺序下的最小可能总 CMA 成本。\n\n您的程序必须：\n- 解析下面提供的一个固定的、硬编码的张量网络测试套件。\n- 对每个测试用例，计算在所有有效的二元收缩顺序下的最小总 CMA 成本，这些顺序必须遵守只有共享至少一个标签的张量才能被收缩的规则。\n- 输出一行，其中包含所有测试用例的最小成本列表，格式严格为方括号括起来的逗号分隔列表。\n\n您可以假定的基本定义：\n- 张量网络是带有标签指标的张量的集合，其中每个标签如果恰好出现在两个张量中，则代表一个求和指标。\n- 收缩成本模型计算复数乘加 (CMA) 运算。单个收缩步骤的成本等于被收缩的两个张量并集中的标签维度的乘积。总成本是各步骤成本的累加。\n\n您的程序要使用的测试套件：\n- 测试用例 1：\n  - 维度：$d_i = 7$。\n  - 张量：$t_1 = \\{i\\}$, $t_2 = \\{i\\}$。\n- 测试用例 2：\n  - 维度：$d_x = 2$, $d_y = 3$, $d_z = 4$。\n  - 张量：$t_1 = \\{x, z\\}$, $t_2 = \\{x, y\\}$, $t_3 = \\{y, z\\}$。\n- 测试用例 3：\n  - 维度：$d_a = 2$, $d_b = 3$, $d_c = 5$, $d_d = 4$。\n  - 张量：$t_1 = \\{a, b\\}$, $t_2 = \\{b, c\\}$, $t_3 = \\{c, d\\}$, $t_4 = \\{d, a\\}$。\n- 测试用例 4：\n  - 维度：$d_a = 2$, $d_b = 3$, $d_c = 5$, $d_d = 4$, $d_e = 6$。\n  - 张量：$t_1 = \\{a, b, e\\}$, $t_2 = \\{b, c\\}$, $t_3 = \\{c, d, e\\}$, $t_4 = \\{d, a\\}$。\n- 测试用例 5：\n  - 维度：$d_x = 6$, $d_y = 1$, $d_z = 5$。\n  - 张量：$t_1 = \\{x, z\\}$, $t_2 = \\{x, y\\}$, $t_3 = \\{y, z\\}$。\n\n附加要求：\n- 您的程序必须通过探索有效的收缩顺序来计算确切的最小成本；最终值不允许使用启发式近似。\n- 此问题不涉及角度，也无需物理单位。\n- 最终输出格式必须是一行，包含一个方括号括起来的逗号分隔列表（例如，$[c_1,c_2,\\dots]$），其中每个 $c_k$ 是测试用例 $k$ 的整数最小 CMA 计数。", "solution": "该问题要求找到成对收缩的最优序列，以最小化总计算成本。这是一个经典的优化问题，在一般情况下是 NP-难问题，但对于所提供测试用例中的少量张量，可以通过系统地探索所有可能的有效收缩路径来精确求解。使用带记忆化的动态规划或递归可以使这种暴力探索变得高效。\n\n在收缩过程中的任何一点，系统的状态由剩余的张量集合定义。设 $C(T)$ 是将一组张量 $T = \\{t_1, t_2, \\dots, t_k\\}$ 收缩成一个标量的最小成本。递归的基本情况是当只剩下一个张量时，这意味着所有收缩都已完成，因此进一步的成本为 $0$。\n\n如果张量集 $T$ 中的张量多于一个，则总的最小成本 $C(T)$ 可以通过考虑每个可能的第一个收缩步骤来递归地找到。一个步骤包括选择两个可收缩的张量 $t_i, t_j \\in T$（即，它们的指标集有非空交集），计算这次收缩的成本，并将其加到收缩后续张量集的最小成本上。\n\n递归关系式可以写成：\n$$\nC(T) = \\min_{t_i, t_j \\in T, \\mathcal{I}_{t_i} \\cap \\mathcal{I}_{t_j} \\neq \\varnothing} \\left( \\mathrm{cost}(t_i, t_j) + C\\left((T \\setminus \\{t_i, t_j\\}) \\cup \\{t_{ij}\\}\\right) \\right)\n$$\n其中 $t_{ij}$ 是由 $t_i$ 和 $t_j$ 收缩产生的张量，其指标集为 $\\mathcal{I}_{t_i}$ 和 $\\mathcal{I}_{t_j}$ 的对称差。\n\n为了高效实现，我们采用一个带记忆化的递归函数。该函数 `find_min_cost(tensors, dims)` 接受当前的张量集和维度映射作为参数，并返回收缩它们的最小成本。状态（即当前的张量集）通过一个规范化的、可哈希的表示（例如，一个排序后的、包含不可变集合的元组）在记忆化表中进行存储和查找，以避免对同一子问题进行重复计算。该算法通过穷举搜索所有有效的二元收缩树的搜索空间来保证找到确切的最小成本，而记忆化则有效地剪枝了重复的计算分支。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\n# Memoization cache for the recursive function. It will be cleared for each test case.\n_memo = {}\n\ndef get_contraction_cost(t1_indices, t2_indices, dims):\n    \"\"\"\n    Calculates the CMA cost of contracting two tensors.\n    Cost is the product of dimensions of all indices in the union of the two tensors' index sets.\n    \"\"\"\n    union_indices = t1_indices.union(t2_indices)\n    # np.prod returns a numpy integer type. We convert to a standard Python int.\n    cost = np.prod([dims[idx] for idx in union_indices])\n    return int(cost)\n\ndef find_min_cost(tensors, dims):\n    \"\"\"\n    Recursively finds the minimum contraction cost for a given set of tensors.\n    Uses memoization to store results for previously seen sets of tensors.\n\n    Args:\n        tensors (tuple of frozenset): The current set of tensors, each represented by a frozenset of its indices.\n        dims (dict): A dictionary mapping index labels to their dimensions.\n\n    Returns:\n        int: The minimum cost to contract the given tensors to a scalar.\n    \"\"\"\n    global _memo\n\n    # Base case: if only one tensor remains, the contraction is finished.\n    if len(tensors) == 1:\n        return 0\n\n    # Create a canonical, hashable representation of the current state for memoization.\n    # The key is a tuple of frozensets, sorted to ensure order doesn't matter.\n    # To sort frozensets, we sort them by a canonical form of their contents (a sorted tuple of elements).\n    state_key = tuple(sorted(tensors, key=lambda fs: tuple(sorted(list(fs)))))\n    if state_key in _memo:\n        return _memo[state_key]\n\n    min_total_cost = float('inf')\n\n    # Iterate over all unique pairs of tensors to find the next contraction.\n    for i, j in combinations(range(len(tensors)), 2):\n        t1 = tensors[i]\n        t2 = tensors[j]\n\n        # A contraction is only valid if the tensors share at least one index.\n        if not t1.isdisjoint(t2):\n            # Calculate the cost of this specific contraction step.\n            step_cost = get_contraction_cost(t1, t2, dims)\n\n            # The new tensor's indices are the symmetric difference of the two contracted tensors.\n            new_tensor = t1.symmetric_difference(t2)\n\n            # Form the new set of tensors for the recursive call.\n            next_tensors_list = [t for k, t in enumerate(tensors) if k != i and k != j]\n            next_tensors_list.append(new_tensor)\n            next_tensors = tuple(next_tensors_list)\n\n            # Recursively find the minimum cost for the remaining network and add the current step's cost.\n            total_cost_for_path = step_cost + find_min_cost(next_tensors, dims)\n\n            # Update the minimum cost found so far.\n            min_total_cost = min(min_total_cost, total_cost_for_path)\n\n    # Memoize the result for the current state.\n    _memo[state_key] = min_total_cost\n    return min_total_cost\n\ndef solve():\n    \"\"\"\n    Solves the tensor network contraction problem for the provided test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (\n            {'i': 7},\n            [{'i'}, {'i'}]\n        ),\n        # Test case 2\n        (\n            {'x': 2, 'y': 3, 'z': 4},\n            [{'x', 'z'}, {'x', 'y'}, {'y', 'z'}]\n        ),\n        # Test case 3\n        (\n            {'a': 2, 'b': 3, 'c': 5, 'd': 4},\n            [{'a', 'b'}, {'b', 'c'}, {'c', 'd'}, {'d', 'a'}]\n        ),\n        # Test case 4\n        (\n            {'a': 2, 'b': 3, 'c': 5, 'd': 4, 'e': 6},\n            [{'a', 'b', 'e'}, {'b', 'c'}, {'c', 'd', 'e'}, {'d', 'a'}]\n        ),\n        # Test case 5\n        (\n            {'x': 6, 'y': 1, 'z': 5},\n            [{'x', 'z'}, {'x', 'y'}, {'y', 'z'}]\n        ),\n    ]\n\n    results = []\n    for dims, initial_tensors_list in test_cases:\n        global _memo\n        _memo.clear()  # Ensure memoization cache is empty for each independent test case.\n\n        # Convert list of sets to tuple of frozensets for hashability.\n        initial_tensors = tuple(frozenset(t) for t in initial_tensors_list)\n\n        min_cost = find_min_cost(initial_tensors, dims)\n        results.append(min_cost)\n\n    # Print the results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2445469"}]}