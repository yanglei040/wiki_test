{"hands_on_practices": [{"introduction": "本章节的第一个实践是基础性的。我们将从头开始实现经典的扩散限制聚集（DLA）模型。通过在两种常见的几何结构——方格点阵和六角点阵——上模拟这一过程，你将深入理解核心算法，并学会如何表征最终形成的分形结构。通过比较这两种点阵上生长出的聚集体的分形维数 $D_f$，你还能洞察 DLA 过程的普适性。[@problem_id:2386014]", "problem": "编写一个完整、可运行的程序，该程序在两种二维晶格上模拟扩散限制聚集 (DLA)，并通过回转半径的标度关系估计分形维数。目标是在方形晶格和六边形晶格上对聚集过程进行建模，并比较两者经验估计出的分形维数 $D_f$。程序必须通过使用固定的随机数种子来确定性地运行，并且必须按照下面指定的精确格式输出单行结果。\n\n使用的基本原理和定义：\n- 扩散限制聚集 (DLA) 是一个生长过程，其中粒子进行无偏的最近邻随机游走（一种与扩散方程 $\\partial_t \\rho = D \\nabla^2 \\rho$ 一致的布朗运动的离散模型），直到它们首次接触到簇的边界（与任何已占据位点相邻）时附着于其上。\n- 晶格上的一个随机游走步骤是在所有最近邻的集合中均匀选择。对于方形晶格，每个位点有 $4$ 个邻居；对于六边形晶格，每个位点有 $6$ 个邻居。\n- 一组 $N$ 个点，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，其回转半径 $R_g$ 定义为\n$$\nR_g^2 = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2,\n\\quad \\text{其中} \\quad\n\\mathbf{r}_{\\mathrm{cm}}=\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i.\n$$\n对于一个统计自相似的聚集体（分形），标度关系 $R_g \\propto N^{1/D_f}$ 成立，因此对 $\\log R_g$ 与 $\\log N$ 进行对数-对数线性回归得到的斜率 $s$ 满足 $D_f = 1/s$。\n- 距离和角度必须在数学上一致的嵌入中处理。对于方形晶格，笛卡尔嵌入为 $\\mathbf{r}=(x,y)$，其中 $x$ 和 $y$ 是整数。对于六边形晶格，使用轴向坐标系 $(q,r)$，其最近邻方向为 $(1,0)$、$(-1,0)$、$(0,1)$、$(0,-1)$、$(1,-1)$、$(-1,1)$，并通过以下方式嵌入到平面中：\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\n这样，到原点的欧几里得距离的平方为\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n\n模拟规则和数值细节：\n- 在 $N=1$ 时，将聚集体初始化为原点处的一个已占据位点。\n- 在半径为 $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$ 的圆上沿随机方向发射每个扩散粒子，其中 $R_{\\max}^2$ 是当前任何已占据位点距离原点的最大欧几里得距离平方，$\\Delta_{\\text{launch}}$ 是一个正的边距。使用 $[0,2\\pi)$ 范围内的均匀随机角度（以弧度为单位）来放置发射点，然后取整到最近的晶格位点（对于六边形晶格，在与嵌入一致的轴向坐标中进行取整；对于方形晶格，对笛卡尔坐标进行取整）。角度必须以弧度处理。\n- 进行无偏的最近邻随机游走，直到出现以下情况之一：\n  1. 游走者移动到一个其邻居集合中包含任何当前已占据位点的位点。在这种情况下，游走者在其当前位置不可逆地附着，并成为聚集体的一部分。\n  2. 游走者漫游到超出“终止”半径 $R_{\\text{kill}} = R_{\\text{launch}} + \\Delta_{\\text{kill}}$，此时该游走者被丢弃，并发射一个新的游走者。\n- 在每次附着事件使 $N$ 增加到 $N+1$ 后，使用上述在所选嵌入中的精确定义更新回转半径 $R_g(N+1)$。\n- 通过对 $\\log R_g(N)$ 与 $\\log N$ 在一个避免极小 $N$ 的范围内进行最小二乘线性回归来估计分形维数 $D_f$，以减少有限尺寸效应。具体来说，当 $N_{\\text{final}} \\ge 100$ 时，在 $N \\ge N_{\\min}$ 的范围内进行拟合，其中 $N_{\\min} = \\max(50, \\lfloor 0.2 N_{\\text{final}} \\rfloor)$；否则 $N_{\\min} = 10$。使用自然对数。\n\n您的程序必须实现两种晶格类型，并为每个测试用例计算 $D_f$。随机数生成器必须为每个测试用例设置种子，以确保确定性行为。\n\n必需的测试套件（每个元组为 $(\\text{晶格}, N_{\\text{final}}, \\text{种子}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$）：\n- 案例 A：$(\\text{\"square\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- 案例 B：$(\\text{\"hex\"},\\, 220,\\, 2023,\\, 5,\\, 15)$\n- 案例 C：$(\\text{\"square\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n- 案例 D：$(\\text{\"hex\"},\\, 60,\\, 777,\\, 5,\\, 15)$\n\n所有距离都是无量纲的晶格间距；角度必须以弧度为单位。输出是无单位的实数（浮点数）。对于每个测试用例，程序必须输出估计的 $D_f$，四舍五入到三位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按 $[\\text{案例 A}, \\text{案例 B}, \\text{案例 C}, \\text{案例 D}]$ 顺序排列、用逗号分隔并用方括号括起来的结果。例如：[$1.700,1.690,1.660,1.650$]。", "solution": "我们通过显式的最近邻随机游走来模拟扩散限制聚集 (DLA)，该方法基于两个基本要素。首先，晶格上的无偏最近邻随机游走提供了布朗运动的离散表示，与扩散方程 $\\partial_t \\rho = D \\nabla^2 \\rho$ 一致。其次，聚集体的分形维数 $D_f$ 是通过质量-半径标度关系定义的。我们避免使用任何特定于晶格的快捷公式，而是从定义中推导出测量过程。\n\n原理与推导：\n1. 随机游走动力学与聚集。令 $\\mathcal{S}$ 表示已占据位点的集合，初始时 $\\mathcal{S}=\\{(0,0)\\}$。在欧几里得半径 $R_{\\text{launch}} = \\sqrt{R_{\\max}^2} + \\Delta_{\\text{launch}}$ 处发射一个游走者，其中 $R_{\\max}^2=\\max_{\\mathbf{r}\\in\\mathcal{S}} \\|\\mathbf{r}\\|^2$。发射方向在 $[0,2\\pi)$（弧度）内均匀采样，以保持各向同性。对于方形晶格，位置被取整为整数笛卡尔坐标 $(x,y)\\in\\mathbb{Z}^2$；对于六边形晶格，我们使用轴向坐标 $(q,r)\\in\\mathbb{Z}^2$，其最近邻为 $(1,0)$、$(-1,0)$、$(0,1)$、$(0,-1)$、$(1,-1)$、$(-1,1)$。游走过程是在每一步从最近邻中均匀随机选择一个。如果游走者的当前位点有任何邻居在 $\\mathcal{S}$ 中，它就会附着，该位点被添加到 $\\mathcal{S}$ 中。如果它漫游超过 $R_{\\text{kill}}=R_{\\text{launch}}+\\Delta_{\\text{kill}}$，它将被丢弃，并发射一个新的游走者。这些规则实现了由到聚集体边界的扩散通量所限制的生长。\n\n2. 嵌入与距离度量。对于方形晶格，我们使用 $\\mathbf{r}=(x,y)$，其欧几里得距离平方为 $\\|\\mathbf{r}\\|^2=x^2+y^2$。对于六边形晶格，我们将轴向坐标 $(q,r)$ 嵌入为\n$$\nx = q + \\frac{1}{2} r,\\qquad y = \\frac{\\sqrt{3}}{2} r,\n$$\n这得到了恒等式\n$$\nx^2 + y^2 = q^2 + q r + r^2.\n$$\n该恒等式允许在随机游走期间，从整数轴向坐标精确计算欧几里得距离平方，而没有浮点数模糊性。我们通过将笛卡尔坐标 $(x,y)$ 转换为分数轴向坐标 $(q_f,r_f)$（通过 $q_f = x - y/\\sqrt{3}$ 和 $r_f = 2y/\\sqrt{3}$），然后应用标准的立方体坐标取整法（约束条件为 $x_c + y_c + z_c = 0$）来获得整数轴向坐标 $(q,r)$，从而将发射点取整到最近的六边形位点。\n\n3. 从回转半径计算分形维数。对于位于 $\\{\\mathbf{r}_i\\}$ 的 $N$ 个已占据位点，其回转半径为\n$$\nR_g^2(N) = \\frac{1}{N}\\sum_{i=1}^N \\left|\\mathbf{r}_i - \\mathbf{r}_{\\mathrm{cm}}\\right|^2\n= \\frac{1}{N}\\sum_{i=1}^N |\\mathbf{r}_i|^2 - \\left|\\frac{1}{N}\\sum_{i=1}^N \\mathbf{r}_i\\right|^2,\n$$\n这是精确且计算上方便的。对于自相似聚集体，质量-半径标度关系 $N \\propto R^{{D_f}}$ 意味着 $R \\propto N^{1/D_f}$，因此\n$$\n\\log R_g(N) = \\frac{1}{D_f}\\log N + \\text{constant}.\n$$\n因此，在避免小 $N$ 瞬态效应的范围内，对 $\\log R_g$ 与 $\\log N$ 进行最小二乘拟合，可以得到斜率 $s$ 和估计值 $D_f = 1/s$。为减少有限尺寸和晶格伪影效应，当 $N_{\\text{final}} \\ge 100$ 时，我们在 $N \\ge N_{\\min}$ 且 $N_{\\min}=\\max(50,\\lfloor 0.2 N_{\\text{final}}\\rfloor)$ 的范围内进行拟合，否则 $N_{\\min}=10$。\n\n算法设计：\n- 数据结构：将已占据集合 $\\mathcal{S}$ 维护为晶格坐标的哈希集合，以实现期望时间复杂度为 $O(1)$ 的成员资格测试。保留运行总和 $\\sum \\mathbf{r}_i$ 和 $\\sum |\\mathbf{r}_i|^2$，以便在每次附着事件中以 $O(1)$ 的时间更新 $R_g$。跟踪 $R_{\\max}^2$，即已占据位点中距离原点的最大欧几里得距离平方，用于更新发射半径。\n- 六边形晶格实现细节：在随机游走期间，使用轴向邻居和精确公式 $q^2 + q r + r^2$ 计算欧几里得距离平方，用于终止半径检查。仅在附着事件发生时，使用 $x=q+\\frac{1}{2}r$，$y=\\frac{\\sqrt{3}}{2}r$ 将坐标转换为笛卡尔坐标 $(x,y)$ 以更新 $R_g$。\n- 确定性：为每个测试用例使用固定的种子和独立的随机数生成器，以保证可复现性。角度在 $[0,2\\pi)$ 范围内以弧度为单位均匀采样。\n- 计算保障措施：为每个发射的游走者设定一个宽松的随机游走步数上限，以保证终止；如果超过此上限，则丢弃并重新发射，以避免病态轨迹。当此限制设置得足够高时，这不会对结果产生实质性偏差。\n\n测试套件与输出：\n我们运行四个案例，其元组为 $(\\text{晶格}, N_{\\text{final}}, \\text{种子}, \\Delta_{\\text{launch}}, \\Delta_{\\text{kill}})$：\n- 案例 A：$(\\text{\"square\"}, 220, 2023, 5, 15)$。\n- 案例 B：$(\\text{\"hex\"}, 220, 2023, 5, 15)$。\n- 案例 C：$(\\text{\"square\"}, 60, 777, 5, 15)$。\n- 案例 D：$(\\text{\"hex\"}, 60, 777, 5, 15)$。\n对于每个案例，我们按照规定通过对 $\\log R_g$ 与 $\\log N$ 进行线性回归来计算 $D_f$，并将结果四舍五入到三位小数。程序以 [$D_A, D_B, D_C, D_D$] 的格式打印单行结果。二维空间中典型的 DLA 值接近 $D_f \\approx 1.7$；由于配位数和晶格各向异性的不同，两种晶格可能会产生略有不同的估计值，但在这些尺寸下，两者都应在同一范围内。\n\n整个实现遵循了所需的环境，仅使用了允许的库，并生成了指定的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---------------------------\n# DLA simulation on square and hex lattices with R_g scaling\n# ---------------------------\n\n# Neighbor steps for square and hex lattices\nSQUARE_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1))\nHEX_NEIGHBORS = ((1, 0), (-1, 0), (0, 1), (0, -1), (1, -1), (-1, 1))\n\nSQRT3 = np.sqrt(3.0)\nSQRT3_OVER_2 = SQRT3 / 2.0\n\ndef axial_to_cartesian(q: int, r: int) -> tuple[float, float]:\n    \"\"\"\n    Map axial hex coordinates (q, r) to Cartesian coordinates (x, y).\n    x = q + r/2\n    y = (sqrt(3)/2) * r\n    \"\"\"\n    x = q + 0.5 * r\n    y = SQRT3_OVER_2 * r\n    return x, y\n\ndef hex_distance_sq_axial(q: int, r: int) -> int:\n    \"\"\"\n    Exact Euclidean squared distance in the hex embedding:\n    x^2 + y^2 = q^2 + q*r + r^2\n    \"\"\"\n    return q*q + q*r + r*r\n\ndef cartesian_to_axial_round(x: float, y: float) -> tuple[int, int]:\n    \"\"\"\n    Convert Cartesian (x, y) in the hex embedding to the nearest axial integer (q, r)\n    using cube-coordinate rounding. Inverse of axial_to_cartesian.\n    From axial to cart: x = q + r/2, y = (sqrt(3)/2) r.\n    Inverse (fractional axial): q_f = x - y/sqrt(3), r_f = 2y/sqrt(3).\n    \"\"\"\n    qf = x - y / SQRT3\n    rf = 2.0 * y / SQRT3\n    # Convert to cube coords (x_c, y_c, z_c) with x_c + y_c + z_c = 0\n    xf = qf\n    zf = rf\n    yf = -xf - zf\n    rx = round(xf)\n    ry = round(yf)\n    rz = round(zf)\n    dx = abs(rx - xf)\n    dy = abs(ry - yf)\n    dz = abs(rz - zf)\n    if dx > dy and dx > dz:\n        rx = -ry - rz\n    elif dy > dz:\n        ry = -rx - rz\n    else:\n        rz = -rx - ry\n    q = int(rx)\n    r = int(rz)\n    return q, r\n\ndef simulate_dla(lattice: str, N_final: int, seed: int, launch_margin: float, kill_margin: float) -> float:\n    \"\"\"\n    Simulate DLA on the specified lattice ('square' or 'hex') until N_final occupied sites (including the seed),\n    return the estimated fractal dimension D_f by fitting log(R_g) vs log(N) with N >= N_min (see problem statement).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    if lattice == \"square\":\n        neighbors = SQUARE_NEIGHBORS\n        # Distance from origin squared\n        dist2 = lambda pos: pos[0]*pos[0] + pos[1]*pos[1]\n        # Map lattice coord to cartesian\n        to_cart = lambda pos: (float(pos[0]), float(pos[1]))\n        # Round launch on circle to nearest lattice site\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return int(round(x)), int(round(y))\n    elif lattice == \"hex\":\n        neighbors = HEX_NEIGHBORS\n        dist2 = lambda pos: hex_distance_sq_axial(pos[0], pos[1])\n        to_cart = lambda pos: axial_to_cartesian(pos[0], pos[1])\n        def launch_from_radius(R_launch: float) -> tuple[int, int]:\n            theta = rng.uniform(0.0, 2.0*np.pi)\n            x = R_launch * np.cos(theta)\n            y = R_launch * np.sin(theta)\n            return cartesian_to_axial_round(x, y)\n    else:\n        raise ValueError(\"Unknown lattice type\")\n\n    occupied = set()\n    origin = (0, 0)\n    occupied.add(origin)\n\n    # Running sums for R_g computation\n    sum_x = 0.0\n    sum_y = 0.0\n    sum_sq = 0.0\n    # R_g at N=1 is zero\n    Rg_by_N = [(1, 0.0)]\n\n    # Track maximum squared radius\n    Rmax2 = 0.0  # includes the origin which is 0\n\n    # Simulation parameters\n    max_steps_per_walker = 10000  # safety limit to avoid very long walks\n\n    # Main aggregation loop\n    while len(occupied) < N_final:\n        # Set launch and kill radii\n        R_launch = np.sqrt(Rmax2) + float(launch_margin)\n        R_kill = R_launch + float(kill_margin)\n        R_kill2 = R_kill * R_kill\n\n        # Launch a new walker\n        pos = launch_from_radius(R_launch)\n\n        steps = 0\n        while True:\n            steps += 1\n            if steps > max_steps_per_walker:\n                # Discard and relaunch\n                break\n\n            # Propose a random nearest-neighbor step\n            # Choose index more cheaply than rng.choice on small tuple\n            di = int(rng.integers(0, len(neighbors)))\n            dx, dy = neighbors[di]\n            new_pos = (pos[0] + dx, pos[1] + dy)\n\n            # Do not move into already occupied site (reflect by rejecting step)\n            if new_pos in occupied:\n                continue\n\n            pos = new_pos\n\n            # Kill if beyond kill radius\n            if dist2(pos) > R_kill2:\n                break\n\n            # Stick if adjacent to occupied site\n            hit = False\n            # Test adjacency\n            for ndx, ndy in neighbors:\n                nb = (pos[0] + ndx, pos[1] + ndy)\n                if nb in occupied:\n                    hit = True\n                    break\n            if hit:\n                # Stick the walker\n                occupied.add(pos)\n                # Update R_g running sums using Cartesian embedding\n                x, y = to_cart(pos)\n                sum_x += x\n                sum_y += y\n                sum_sq += x*x + y*y\n                N_now = len(occupied)\n                # Update Rmax2\n                d2 = x*x + y*y\n                if d2 > Rmax2:\n                    Rmax2 = d2\n                # Compute R_g from definition: R_g^2 = (sum |r|^2)/N - |sum r|^2 / N^2\n                cm2 = (sum_x*sum_x + sum_y*sum_y) / (N_now * N_now)\n                Rg2 = (sum_sq / N_now) - cm2\n                if Rg2 < 0.0:\n                    Rg2 = 0.0\n                Rg = float(np.sqrt(Rg2))\n                Rg_by_N.append((N_now, Rg))\n                break  # proceed to next walker\n\n    # Prepare data for fitting log(R_g) vs log(N)\n    Ns = np.array([n for n, _ in Rg_by_N], dtype=float)\n    Rgs = np.array([rg for _, rg in Rg_by_N], dtype=float)\n\n    # Select fitting range\n    if N_final >= 100:\n        N_min = max(50, int(np.floor(0.2 * N_final)))\n    else:\n        N_min = 10\n    mask = Ns >= N_min\n    # Ensure we have sufficient points; if not, relax to use all N >= 2\n    if not np.any(mask):\n        mask = Ns >= 2.0\n\n    # Avoid log of zero; filter R_g > 0 as well\n    mask = mask & (Rgs > 0.0)\n\n    # In degenerate cases with too few points, fall back to pseudo-estimate to avoid crash\n    if np.count_nonzero(mask) < 2:\n        # Minimal fallback: return NaN-like but still numeric; choose 0.0 as indicator\n        return float(\"nan\")\n\n    logN = np.log(Ns[mask])\n    logRg = np.log(Rgs[mask])\n\n    # Linear regression: logRg = m * logN + b\n    m, b = np.polyfit(logN, logRg, 1)\n    if m == 0.0:\n        return float(\"nan\")\n    D_est = 1.0 / m\n    return float(D_est)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (lattice, N_final, seed, launch_margin, kill_margin)\n    test_cases = [\n        (\"square\", 220, 2023, 5, 15),  # Case A\n        (\"hex\",    220, 2023, 5, 15),  # Case B\n        (\"square\",  60,  777, 5, 15),  # Case C\n        (\"hex\",     60,  777, 5, 15),  # Case D\n    ]\n\n    results = []\n    for lattice, N_final, seed, lmargin, kmargin in test_cases:\n        D_est = simulate_dla(lattice, N_final, seed, lmargin, kmargin)\n        # Round to three decimal places as required\n        if np.isnan(D_est):\n            # In the unlikely event of NaN, output 0.000 to maintain format\n            results.append(\"0.000\")\n        else:\n            results.append(f\"{D_est:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386014"}, {"introduction": "经典的 DLA 模型会产生高度分支、稀疏的结构，对随机涨落极为敏感。本练习引入了一种“噪声抑制”机制，这是模拟更广泛物理现象的一项关键改进。通过要求一个潜在的附着位点在粒子附着前被多次访问，我们可以控制聚集体的形态，随着附着阈值 $m$ 的增加，从稀疏的分形结构向更紧凑的结构转变。这项实践将帮助你理解噪声在模式形成中的作用，以及如何调整模型以产生不同的结果。[@problem_id:2386048]", "problem": "考虑在整数晶格上的二维扩散限制聚集（DLA），其中在时间 $t=0$ 时，一个固定的种子占据原点。粒子从一个发射圆上一次释放一个，并进行离散时间的无偏最近邻随机游走。施加了一个降噪规则：粒子在首次降落在团簇旁边时不会立即粘附。相反，每个空格点都会维护一个整数计数器，记录当该位点至少有一个最近邻已被占据时，随机游走者降落在此处的次数。只有当一个位点的计数器达到预设的正整数阈值 $m$ 时，该位点才会永久被占据。目标是为不同的 $m$ 生成团簇，并通过质量-半径标度法估计分形维数 $D_f(m)$。\n\n模型规范：\n- 晶格：整数对 $(x,y)\\in\\mathbb{Z}^2$ 的集合。\n- 种子：在时间 $t=0$ 时，已占据集合为 $\\{(0,0)\\}$。\n- 随机游走动力学：位于 $(x,y)$ 的游走者在一个离散步骤中以等概率 $1/4$ 移动到 $(x\\pm 1,y)$ 或 $(x,y\\pm 1)$。\n- 发射规则：令 $R(t)$ 表示当前团簇半径，定义为在时间 $t$ 时所有已占据位点的最大欧几里得距离 $\\sqrt{x^2+y^2}$。定义边距 $r_{\\mathrm{margin}}=5$ 和最小发射半径 $r_{\\min}=10$。每个新游走者从半径为 $r_{\\mathrm{launch}}=\\max\\{R(t)+r_{\\mathrm{margin}},\\,r_{\\min}\\}$ 的圆上以均匀随机角度（以弧度为单位）发射，并置于距离该圆最近的晶格位点上。角度必须在 $[0, 2\\pi)$ 内均匀采样。\n- 终止规则：定义终止半径 $r_{\\mathrm{kill}}=r_{\\mathrm{launch}}+3\\,r_{\\mathrm{margin}}$。如果一个游走者与原点的欧几里得距离超过 $r_{\\mathrm{kill}}$，则该游走者被丢弃，并按上述方式发射一个新的游走者。\n- 排他性：一个试图将游走者置于已占据位点的移动将被拒绝并立即重新采样；等效地，该游走者在该时间步停留在当前晶格位点，并在下一步重新选择方向。\n- 降落事件与降噪：当一个游走者位于空格点 $(x,y)$ 且其四个最近邻中至少有一个被占据时，发生一次降落事件。每个空格点 $(x,y)$ 维护一个从 $0$ 开始的整数计数器 $c(x,y)$，每次在 $(x,y)$ 发生降落事件时，该计数器加 $1$。当 $c(x,y)$ 首次达到阈值 $m$ 时，位点 $(x,y)$ 变为永久占据，该位点的 $c(x,y)$ 不再需要，当前游走者被移除。团簇半径 $R(t)$ 相应更新。\n- 终止条件：持续发射游走者并应用上述规则，直到已占据集合的基数恰好为 $N$。\n\n分形维数估计：\n- 对于一个已完成的、已占据集合为 $\\mathcal{C}$ 且大小为 $|\\mathcal{C}|=N$ 的团簇，定义团簇半径 $R_{\\max}=\\max\\{\\sqrt{x^2+y^2}:(x,y)\\in\\mathcal{C}\\}$ 和质量函数 $M(R)=|\\{(x,y)\\in\\mathcal{C}:\\sqrt{x^2+y^2}\\le R\\}|$。\n- 定义拟合窗口参数 $\\alpha=0.2$ 和 $\\beta=0.9$。令 $R_{\\min}=\\lceil\\alpha R_{\\max}\\rceil$ 和 $R_{\\mathrm{fit}}=\\lfloor\\beta R_{\\max}\\rfloor$。考虑整数半径集合 $\\{R_i\\}_{i=1}^K=\\{R\\in\\mathbb{Z}: R_{\\min}\\le R\\le R_{\\mathrm{fit}},\\,R\\ge 1\\}$，按升序排列，其中 $K$ 是此类半径的数量。对于每个 $R_i$，计算 $M(R_i)$。将 $D_f$ 估计为点集 $\\{(\\log R_i,\\log M(R_i))\\}_{i=1}^K$ 的最小二乘最佳拟合线的斜率。\n- 所有对数均为自然对数。\n\n测试套件与所需输出：\n- 使用以下测试用例，每个用例由元组 $(m,N,\\text{seed})$ 指定，其中“seed”用于初始化随机数生成器以确保可复现性：\n  1. $(m=1,\\,N=900,\\,\\text{seed}=1337)$\n  2. $(m=3,\\,N=700,\\,\\text{seed}=2021)$\n  3. $(m=5,\\,N=600,\\,\\text{seed}=31415)$\n- 对于每个用例，根据模型模拟团簇，按上述方法估计 $D_f$，并将结果四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个四舍五入的 $D_f$ 估计值，以逗号分隔并用方括号括起（例如，$[1.700,1.750,1.780]$）。不应打印任何额外的文本或行。角度必须以弧度为单位。所有量都是无量纲的，因此不需要进行物理单位转换。", "solution": "问题陈述经评估为**有效**。它描述了计算物理学中的一个适定问题，具体是在二维整数晶格上模拟降噪扩散限制聚集（DLA）。所有参数、规则和目标都以足够的清晰度和科学严谨性进行了规定，从而能够得到一个唯一的、可复现的解。\n\n该问题要求模拟团簇的生长，并随后估计其分形维数 $D_f$。解决方案的核心是一个随机模拟算法，其后是使用线性回归的数据分析步骤。该过程必须针对由降噪阈值 $m$、最终团簇大小 $N$ 和随机数生成器种子定义的三个不同测试用例重复执行。\n\n**算法方法**\n\n模拟将在 $\\mathbb{Z}^2$ 晶格的稀疏表示上进行，这是必要的，因为晶格是无界的。采用以下数据结构：\n1.  **已占据位点 (Occupied Sites)**：一个坐标元组集合 `occupied_sites`，用于存储构成聚集团簇的粒子的位置。`set` 为成员资格测试提供了高效的 $O(1)$ 平均时间复杂度，这对于排他性规则至关重要。\n2.  **边界位点 (Perimeter Sites)**：一个集合 `perimeter_sites`，用于存储所有与团簇中至少一个位点是最近邻的空格点的坐标。这优化了对“降落事件”的检查，根据定义，降落事件只能在此类位点上发生。\n3.  **降落计数器 (Landing Counters)**：一个字典 `landing_counters`，将边界位点的坐标映射到一个整数计数。这用于跟踪随机游走者访问每个特定边界位点的次数，从而实现降噪机制。\n\n模拟通过一次添加一个粒子的方式进行，直到团簇达到目标大小 $N$。对于每个粒子，执行以下步骤：\n\n1.  **粒子发射**：一个新的游走者被引入系统。\n    -   确定当前团簇半径 $R(t) = \\max\\{\\sqrt{x^2+y^2} \\mid (x,y) \\in \\text{occupied\\_sites}\\}$。为进行优化，我们维护最大半径的平方，并仅在发生聚集时更新它。\n    -   计算发射半径 $r_{\\mathrm{launch}} = \\max\\{R(t) + r_{\\mathrm{margin}}, r_{\\min}\\}$，其中 $r_{\\mathrm{margin}} = 5$ 且 $r_{\\min} = 10$。\n    -   从 $[0, 2\\pi)$ 中均匀采样一个随机角度 $\\theta$。\n    -   游走者被放置在距离发射圆上点 $(r_{\\mathrm{launch}}\\cos\\theta, r_{\\mathrm{launch}}\\sin\\theta)$ 最近的整数晶格位点 $(x, y)$ 上。这通过对浮点坐标进行四舍五入来实现。如果该位点已被占据（罕见事件），则重新采样角度，直到找到一个空的发射位点。\n    -   定义终止半径为 $r_{\\mathrm{kill}} = r_{\\mathrm{launch}} + 3 \\cdot r_{\\mathrm{margin}}$。\n\n2.  **随机游走**：游走者在晶格上进行无偏随机游走。在每个离散时间步：\n    -   **终止条件**：检查游走者与原点的欧几里得距离。如果超过 $r_{\\mathrm{kill}}$，则丢弃该游走者，模拟过程继续发射一个新的游走者。\n    -   **降落事件与粘附**：检查游走者的当前位置是否在 `perimeter_sites` 集合中。如果是，则发生降落事件。`landing_counters` 中对应的计数器递增。如果该位点的计数器达到阈值 $m$，该位点就成为团簇的一部分。`occupied_sites` 和 `perimeter_sites` 集合将被更新，最大团簇半径重新计算，当前游走者被移除。然后发射一个新的游走者。\n    -   **移动**：以等概率 $1/4$ 选择一个方向（上、下、左或右）。计算出建议的 `next_pos`。**排他性规则**：如果 `next_pos` 在 `occupied_sites` 中，则游走者在此时间步不移动。否则，游走者的位置更新为 `next_pos`。\n\n**分形维数估计**\n\n当团簇增长到大小 $N$ 后，其分形维数 $D_f$ 基于质量-半径标度关系 $M(R) \\propto R^{D_f}$ 进行估计。这种关系在对数-对数图上是线性的：$\\log M(R) = D_f \\log R + \\text{const}$。\n\n1.  **数据收集**：\n    -   确定最终团簇的最大半径 $R_{\\max}$。\n    -   通过 $R_{\\min-\\text{fit}} = \\lceil\\alpha R_{\\max}\\rceil$ 和 $R_{\\mathrm{fit}} = \\lfloor\\beta R_{\\max}\\rfloor$ 定义半径的拟合窗口，其中 $\\alpha = 0.2$ 且 $\\beta = 0.9$。\n    -   对于在范围 $[R_{\\min-\\text{fit}}, R_{\\mathrm{fit}}]$（且 $R \\ge 1$）内的每个整数半径 $R$，计算质量 $M(R)$。$M(R)$ 是距离原点不超过 $R$ 的已占据位点的数量。\n    -   为该半径范围生成一组数据点 $(\\log R, \\log M(R))$。按规定使用自然对数。\n\n2.  **线性回归**：\n    -   对收集的对数-对数数据点执行简单线性回归。\n    -   分形维数 $D_f$ 是最佳拟合线的斜率。这可以使用标准数值库计算，例如 `numpy.polyfit`，它可以将指定阶数的多项式拟合到数据并返回系数。对于一条直线（1次），第一个系数就是斜率。\n\n整个过程在一个Python脚本中实现，利用 `numpy` 库进行数值计算和随机数生成。为确保可复现性，每个测试用例都对随机数生成器设置了种子。最终计算出的 $D_f$ 值四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_dla_and_get_df(m, N, seed):\n    \"\"\"\n    Simulates a noise-reduced DLA cluster and calculates its fractal dimension.\n\n    Args:\n        m (int): The noise reduction threshold.\n        N (int): The target number of particles in the cluster.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated fractal dimension D_f.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # --- Data Structures ---\n    # The set of occupied lattice sites\n    occupied_sites = {(0, 0)}\n    # The set of empty sites adjacent to the cluster\n    perimeter_sites = {(1, 0), (-1, 0), (0, 1), (0, -1)}\n    # Counters for the number of landings on perimeter sites\n    landing_counters = {}\n    \n    current_R_sq = 0.0\n\n    # --- Model Parameters ---\n    R_MARGIN = 5\n    R_MIN_LAUNCH = 10\n    MOVES = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=np.int32)\n\n    # --- Main Simulation Loop ---\n    # Grow the cluster until it reaches size N\n    while len(occupied_sites) < N:\n        # --- 1. Set up for a new walker ---\n        current_R = np.sqrt(current_R_sq)\n        r_launch = max(current_R + R_MARGIN, R_MIN_LAUNCH)\n        r_kill_sq = (r_launch + 3 * R_MARGIN)**2\n\n        # Launch walker from a random position on the launch circle\n        while True:\n            angle = rng.uniform(0, 2 * np.pi)\n            x_c = r_launch * np.cos(angle)\n            y_c = r_launch * np.sin(angle)\n            walker_pos = (int(round(x_c)), int(round(y_c)))\n            if walker_pos not in occupied_sites:\n                break\n        \n        # --- 2. Random Walk Loop for the current walker ---\n        while True:\n            # Check kill condition\n            if walker_pos[0]**2 + walker_pos[1]**2 > r_kill_sq:\n                break  # Walker is killed, launch a new one\n\n            # Check for landing event (walker is on the cluster perimeter)\n            if walker_pos in perimeter_sites:\n                landing_counters[walker_pos] = landing_counters.get(walker_pos, 0) + 1\n                \n                # Check for sticking condition\n                if landing_counters[walker_pos] >= m:\n                    # Particle sticks!\n                    new_site = walker_pos\n                    occupied_sites.add(new_site)\n\n                    # Update cluster max radius\n                    current_R_sq = max(current_R_sq, new_site[0]**2 + new_site[1]**2)\n\n                    # Update perimeter and counters\n                    perimeter_sites.remove(new_site)\n                    if new_site in landing_counters:\n                        del landing_counters[new_site]\n\n                    for dx, dy in MOVES:\n                        neighbor = (new_site[0] + dx, new_site[1] + dy)\n                        if neighbor not in occupied_sites:\n                            perimeter_sites.add(neighbor)\n                    \n                    break # Walker has stuck, end its walk\n\n            # Perform one step of the random walk\n            move = MOVES[rng.integers(4)]\n            next_pos = (walker_pos[0] + move[0], walker_pos[1] + move[1])\n\n            # Exclusion rule: cannot move into an occupied site\n            if next_pos not in occupied_sites:\n                walker_pos = next_pos\n            # If next_pos is occupied, walker stays put for this time step\n\n    # --- 3. Fractal Dimension Estimation ---\n    ALPHA = 0.2\n    BETA = 0.9\n\n    R_max = np.sqrt(current_R_sq)\n    \n    R_min_fit = int(np.ceil(ALPHA * R_max))\n    R_fit = int(np.floor(BETA * R_max))\n\n    if R_min_fit > R_fit or R_fit < 1:\n        return np.nan # Not enough range for fitting\n\n    radii_for_fit = list(range(max(1, R_min_fit), R_fit + 1))\n    if not radii_for_fit:\n      return np.nan\n\n    log_R_values = []\n    log_M_values = []\n    \n    # Pre-calculate squared distances of all particles from origin\n    dist_sq_array = np.array([x**2 + y**2 for x, y in occupied_sites])\n    \n    for R_i in radii_for_fit:\n        R_i_sq = R_i**2\n        mass = np.sum(dist_sq_array <= R_i_sq)\n        if mass > 0:\n            log_R_values.append(np.log(R_i))\n            log_M_values.append(np.log(mass))\n\n    if len(log_R_values) < 2:\n        return np.nan # Not enough points for a linear regression\n\n    # Perform least-squares fit: log(M) = D_f * log(R) + C\n    # np.polyfit returns [slope, intercept]\n    slope, _ = np.polyfit(log_R_values, log_M_values, 1)\n    D_f = slope\n    \n    return D_f\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 900, 1337),\n        (3, 700, 2021),\n        (5, 600, 31415),\n    ]\n\n    results = []\n    for m, N, seed in test_cases:\n        df = simulate_dla_and_get_df(m, N, seed)\n        # Round result to three decimal places\n        results.append(f\"{df:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2386048"}, {"introduction": "纯粹的扩散并非自然界中唯一的输运机制；粒子常常在外部场的影响下运动。这项实践要求你修改随机行走过程，加入一个方向性偏好，以模拟一个将粒子拉向聚集体中心的力。这种变体对于模拟电化学沉积或引力场中的聚集等过程至关重要。通过实现有偏随机行走，你将探索外部场如何打破生长过程的各向同性，并将经典的 DLA 分形转变为不同的结构形态。[@problem_id:2386060]", "problem": "要求您在一个方形晶格上实现一个二维扩散限制聚集 (DLA) 模型，该模型采用偏向种子的有偏随机行走。请使用一个基于标准扩散和漂移原理推导出的数学上一致的随机行走模型。DLA 的生长方式是从当前团簇外部发射随机行走者，让它们进行扩散，直到它们通过最近邻接触首次触碰到现有聚集体时粘附上去。所有计算必须在二维空间中进行，不带物理单位。\n\n核心定义与假设：\n- 模型建立在一个二维方形晶格上。种子位于晶格原点 $(0,0)$，并在初始化时被占据。\n- 随机行走者执行一个具有四邻域连接的离散时间马尔可夫过程。在每一步中，它根据一个偏向于减小到种子欧几里得距离的有偏转移概率，从四个基本方向 $\\{(+1,0),(-1,0),(0,+1),(0,-1)\\}$ 中选择一个。\n- 设当前行走者的位置为 $(x,y)$，其半径平方为 $r^2 = x^2 + y^2$。对于每个候选步进方向 $(\\Delta x, \\Delta y)$，计算其尝试性的半径平方 $r'^2 = (x+\\Delta x)^2 + (y+\\Delta y)^2$。定义两个权重：对于 $r'^2 < r^2$ 的步（朝向内部），权重为 $w_{\\text{in}} = 1 + b$；对于 $r'^2 \\ge r^2$ 的步（朝向外部或非朝向内部），权重为 $w_{\\text{out}} = 1 - b$，其中 $b \\in [0,1)$ 是偏置参数。选择某个方向的概率是其对应的权重除以四个权重之和。\n- 当一个行走者在其四个相邻的最近邻位置中，任意一个位置已被团簇占据时，该行走者将首次在晶格位置 $(x,y)$ 处发生不可逆的粘附。粘附后，$(x,y)$ 被添加到团簇中。\n- 行走者从半径为 $R_{\\text{launch}} = R_{\\max} + \\Delta$ 的圆上发射，其中 $R_{\\max}$ 是当前从原点到任何已占据位置的最大欧几里得距离，且 $\\Delta = 5$。发射角度必须在以弧度为单位的角度范围内均匀采样。终止半径为 $R_{\\text{kill}} = R_{\\max} + 10$。如果行走者的距离超过 $R_{\\text{kill}}$，它将被丢弃，并重新发射一个新的行走者。\n- 当被占据位置的总数（包括种子）达到指定的目标 $N$ 时，团簇停止生长。\n\n对于每个完成的团簇，计算其均方根距离\n$$\nR_g = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} \\left(x_i^2 + y_i^2\\right)} ,\n$$\n其中 $(x_i,y_i)$ 是被占据位置的坐标，$N$ 是被占据位置的总数。报告的 $R_g$ 值需四舍五入到三位小数。\n\n角度单位要求：\n- 所有角度都必须以弧度处理。\n\n随机性与可复现性：\n- 为确保可复现性，每个测试用例需使用提供的整数种子来初始化伪随机数生成器。\n\n测试套件：\n实现您的程序，为以下四个测试用例计算 $R_g$。在每种情况下，均使用上述的方形晶格和规则，并确保报告的值四舍五入到三位小数。\n1. $N = 1$, $b = 0.6$, seed $= 314159$.\n2. $N = 60$, $b = 0.0$, seed $= 271828$.\n3. $N = 60$, $b = 0.3$, seed $= 161803$.\n4. $N = 60$, $b = 0.7$, seed $= 141421$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含四个结果的列表，格式为方括号内用逗号分隔且无空格。例如：“[1.234,2.345,3.456,4.567]”。每个条目必须是对应测试用例的 $R_g$ 值，并四舍五入到三位小数。", "solution": "该问题陈述对于一个计算物理模拟而言，是一个有效且定义明确的指令。它要求在一个方形晶格上实现一个二维扩散限制聚集 (DLA) 模型。该模型的核心是一个随机行走者，其运动受参数 $b$ 控制，偏向于团簇的原点。目标是计算指定大小为 $N$ 的最终聚集体的回旋半径 $R_g$。通过使用带种子的伪随机数生成器，该过程是可复现的。\n\n该问题具有科学依据，采用了随机过程和统计力学的标准原理。所有定义、参数和边界条件都已提供，使得问题自成体系且明确无歧义。验证成功，解决方案如下。\n\n**1. 算法框架**\n\n模拟过程从二维笛卡尔晶格的原点 $(0, 0)$ 处的一个单一种子开始，构建一个粒子团簇。团簇通过一次添加一个粒子的方式迭代生长，直到粒子总数达到 $N$。\n\n模拟的核心是必须跟踪的几个关键量：\n- 被占据晶格位置的集合 $\\mathcal{C}$。需要一个高效的数据结构（如哈希集合）以实现快速查找。初始时，$\\mathcal{C} = \\{(0, 0)\\}$。\n- 粒子总数，即集合 $\\mathcal{C}$ 的基数 $|\\mathcal{C}|$。\n- 团簇中所有粒子位置向量的欧几里得范数平方和，$\\sum_{\\vec{p_i} \\in \\mathcal{C}} \\|\\vec{p_i}\\|^2 = \\sum_{i=1}^{|\\mathcal{C}|} (x_i^2 + y_i^2)$。该值用于最终计算 $R_g$。\n- 从原点到团簇中任意粒子的最大欧几里得距离的平方，$R_{\\text{max}}^2 = \\max_{\\vec{p_i} \\in \\mathcal{C}} \\|\\vec{p_i}\\|^2$。该值决定了发射和终止行走者的几何边界。\n\n主模拟通过一个循环进行，只要 $|\\mathcal{C}| < N$ 就持续执行。在循环的每次迭代中，都会生成一个新的随机行走者，并模拟其轨迹，直到它粘附到团簇上或被移除。\n\n**2. 行走者的生成与终止**\n\n对于每个待添加的新粒子，会从一个圆形边界上发射一个行走者，如果它偏离太远则被终止。\n- **发射半径**：行走者在一个发射半径 $R_{\\text{launch}} = R_{\\max} + \\Delta$ 处被引入，其中 $R_{\\max} = \\sqrt{R_{\\text{max}}^2}$，偏移量 $\\Delta = 5$。\n- **发射位置**：从区间 $[0, 2\\pi)$ 中均匀采样一个随机角度 $\\theta$。初始的浮点笛卡尔坐标为 $(R_{\\text{launch}} \\cos \\theta, R_{\\text{launch}} \\sin \\theta)$。然后将这些坐标四舍五入到最近的整数坐标 $(x_w, y_w)$，以将行走者放置在晶格上。\n- **终止半径**：如果行走者离团簇太远，则认为其已丢失。定义一个终止半径 $R_{\\text{kill}} = R_{\\max} + 10$。如果行走者距离原点的平方 $x_w^2 + y_w^2$ 超过 $R_{\\text{kill}}^2$，其轨迹将被终止，并重新发射一个新的行走者。\n\n**3. 行走者动力学与粘附规则**\n\n行走者在晶格上逐点移动，直到满足粘附条件。\n- **粘附条件**：位于位置 $\\vec{p}_w = (x_w, y_w)$ 的行走者，如果其四个最近邻位置 $\\vec{p}_w + \\vec{\\delta}$ 中有任何一个已在被占据位置集合 $\\mathcal{C}$ 中，则该行走者将不可逆地粘附到团簇上。最近邻位移向量集合为 $\\vec{\\delta} \\in \\{(+1, 0), (-1, 0), (0, +1), (0, -1)\\}$。粘附后，行走者的位置 $\\vec{p}_w$ 被添加到 $\\mathcal{C}$ 中，并且聚集体的属性（$\\sum r_i^2$ 和 $R_{\\text{max}}^2$）会更新。\n- **有偏随机行走**：如果行走者没有粘附，它会向其四个邻居之一进行一次离散跳跃。步长的选择是概率性的，并受到参数 $b \\in [0, 1)$ 的影响。设行走者的当前位置为 $\\vec{p}$，其半径平方为 $r^2 = \\|\\vec{p}\\|^2$。对于四个可能的步长 $\\vec{\\delta}_j$ 中的每一个，尝试性的下一个位置是 $\\vec{p}'_j = \\vec{p} + \\vec{\\delta}_j$，相应的半径平方为 $r_j'^2 = \\|\\vec{p}'_j\\|^2$。为每个潜在的步长分配一个权重 $w_j$：\n$$\nw_j = \\begin{cases}\n1 + b & \\text{若 } r_j'^2 < r^2 \\quad (\\text{朝向内部的步}) \\\\\n1 - b & \\text{若 } r_j'^2 \\ge r^2 \\quad (\\text{朝向外部或非朝向内部的步})\n\\end{cases}\n$$\n选择第 $j$ 步的概率 $P_j$ 是其权重被所有四个权重之和归一化后的值：\n$$\nP_j = \\frac{w_j}{\\sum_{k=1}^4 w_k}\n$$\n根据这些概率选择一个步长，并更新行走者的位置。这个检查粘附然后移动的过程会重复进行，直到行走者的命运——粘附或被终止——被确定。\n\n**4. 回旋半径的计算**\n\n一旦团簇大小达到目标 $N$，模拟就终止。回旋半径 $R_g$ 是衡量团簇空间广度的指标，根据所有 $N$ 个组成粒子的位置计算得出：\n$$\nR_g = \\sqrt{\\frac{1}{N} \\sum_{i=1}^{N} (x_i^2 + y_i^2)}\n$$\n总和 $\\sum (x_i^2 + y_i^2)$ 通过在每个新粒子粘附到团簇时维护一个动态总和来高效计算。位于 $(0,0)$ 的初始种子的贡献为 $0$。对于 $N=1$ 的平凡情况，团簇仅包含种子，因此 $R_g = 0$。最终值按要求四舍五入到三位小数。\n\n**5. 可复现性**\n\n通过为每个测试用例使用特定整数种子初始化的伪随机数生成器 (PRNG)，模拟的随机性变得确定性和可复现。所有的随机选择——发射角度和随机行走步长——都源自这同一个 PRNG 实例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_dla(N, b, seed):\n    \"\"\"\n    Simulates a 2D biased Diffusion-Limited Aggregation (DLA) process.\n\n    Args:\n        N (int): The target number of particles in the cluster.\n        b (float): The bias parameter for the random walk.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The calculated radius of gyration, rounded to three decimal places.\n    \"\"\"\n    if N <= 1:\n        return 0.0\n\n    rng = np.random.default_rng(seed)\n\n    # Use a set for efficient O(1) average time complexity for lookups.\n    occupied_sites = {(0, 0)}\n    sum_r_sq = 0.0\n    max_r_sq = 0.0\n\n    # Constant array for cardinal directions (steps and neighbor checks).\n    directions = np.array([[1, 0], [-1, 0], [0, 1], [0, -1]], dtype=np.int32)\n    \n    # Main simulation loop: add particles until the cluster reaches size N.\n    while len(occupied_sites) < N:\n        # 1. Launch a new walker.\n        R_max = np.sqrt(max_r_sq)\n        R_launch = R_max + 5.0\n        R_kill_sq = (R_max + 10.0)**2\n        \n        while True:\n            # Launch from a random angle on the launch circle.\n            angle = rng.uniform(0, 2 * np.pi)\n            x_launch = R_launch * np.cos(angle)\n            y_launch = R_launch * np.sin(angle)\n            \n            # Round to the nearest integer lattice site.\n            walker_pos = np.round([x_launch, y_launch]).astype(np.int32)\n            \n            # Ensure the launch position is not already occupied.\n            if tuple(walker_pos) not in occupied_sites:\n                break\n        \n        # 2. Simulate the walker's random walk.\n        while True:\n            # 2a. Check for sticking condition.\n            is_stuck = False\n            for dx, dy in directions:\n                neighbor = (walker_pos[0] + dx, walker_pos[1] + dy)\n                if neighbor in occupied_sites:\n                    is_stuck = True\n                    break\n            \n            if is_stuck:\n                pos_tuple = tuple(walker_pos)\n                occupied_sites.add(pos_tuple)\n                \n                # Update aggregate properties.\n                r_sq = float(walker_pos[0]**2 + walker_pos[1]**2)\n                sum_r_sq += r_sq\n                if r_sq > max_r_sq:\n                    max_r_sq = r_sq\n                \n                # Break from this walker's loop to launch a new one.\n                break\n\n            # 2b. Check for kill condition.\n            walker_r_sq = walker_pos[0]**2 + walker_pos[1]**2\n            if walker_r_sq > R_kill_sq:\n                # Walker is lost; break to launch a new one.\n                break\n\n            # 2c. Perform a biased random walk step.\n            current_r_sq = walker_r_sq\n            weights = []\n            for dx, dy in directions:\n                next_pos = walker_pos + np.array([dx, dy])\n                next_r_sq = next_pos[0]**2 + next_pos[1]**2\n                if next_r_sq < current_r_sq:\n                    weights.append(1.0 + b)\n                else:\n                    weights.append(1.0 - b)\n            \n            # Normalize weights to get probabilities.\n            total_weight = sum(weights)\n            probabilities = [w / total_weight for w in weights]\n            \n            # Choose a step and update the walker's position.\n            chosen_idx = rng.choice(4, p=probabilities)\n            walker_pos += directions[chosen_idx]\n\n    # 3. Calculate and return the radius of gyration.\n    # The sum_r_sq accounts for the N-1 attached particles. The seed at (0,0) has r^2=0.\n    Rg = np.sqrt(sum_r_sq / N)\n    return Rg\n\ndef solve():\n    \"\"\"\n    Runs the DLA simulation for the specified test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        (1, 0.6, 314159),\n        (60, 0.0, 271828),\n        (60, 0.3, 161803),\n        (60, 0.7, 141421),\n    ]\n\n    results = []\n    for N, b, seed in test_cases:\n        result = solve_dla(N, b, seed)\n        # Format to exactly three decimal places.\n        results.append(f\"{result:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2386060"}]}