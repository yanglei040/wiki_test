{"hands_on_practices": [{"introduction": "本练习是计算物理学中的一个奠基石。我们将通过在临界阈值 $p_c$ 下进行模拟，来数值上验证渗流理论中最重要的普适标度律之一——Fisher定律 $n_s \\sim s^{-\\tau}$。这项实践旨在锻炼你实现簇标记算法的核心技能，并学习如何从原始模拟数据中提取临界指数 $\\tau$，这是计算物理学家的基本功。[@problem_id:2426213]", "problem": "您将编写一个完整、可运行的程序，通过数值模拟研究二维方格点阵在临界点上的位点逾渗。目标是确定在逾渗阈值 $p_c$ 处有限集团尺寸的分布（用 $n_s$ 表示），并通过从模拟数据中估计指数 $\\tau$ 来验证其是否遵循 Fisher 定律 $n_s \\sim s^{-\\tau}$。\n\n您需要从逾渗理论和统计估计的核心定义与事实出发，除这些定义外，不假定任何专门的逾渗公式。您可以使用的基础理论包括：\n\n- 方格点阵上位点逾渗的定义：每个位点以概率 $p$ 独立地被占据，或以概率 $1-p$ 为空，其中 $p \\in [0,1]$ 是一个小数（而非百分比）。最近邻连通性是沿着点阵方向定义的。\n- 集团的定义：在点阵上，基于最近邻连通性，由被占据位点组成的极大连通集合。\n- 无限二维方格点阵上位点逾渗的逾渗阈值 $p_c$ 约为 $p_c \\approx 0.592746$，这是一个源自高精度研究、被广泛接受的经验常数。\n- 在具有自由边界的有限 $L \\times L$ 系统中，跨越集团的概念：一个连接了顶部与底部边界，或左侧与右侧边界的集团。在临界点构建有限集团尺寸分布时，应排除此类集团。\n- 统计估计原理，该原理允许以一种有原则的方式（源自似然最大化和渐近论证）将幂律模型拟合到下限截止值 $s_{\\min}$ 以上的经验数据，并承认集团尺寸是整数值。\n\n您的程序必须：\n\n1. 在一个具有自由边界条件的 $L \\times L$ 方格点阵上，以占据概率 $p = p_c$（其中 $p_c = 0.592746$）生成 $R$ 个独立的位点逾渗实现。在每次实现中，仅使用最近邻连通性识别所有集团。\n2. 检测并排除跨越集团，即任何同时接触顶部和底部边界，或同时接触左侧和右侧边界的集团。\n3. 将所有 $R$ 次实现中所有剩余的（有限、非跨越）集团的尺寸汇总成一个多重集 $\\{s_i\\}$。\n4. 从汇总的多重集中，确定经验性有限尺寸集团尺寸分布 $n_s$。在概念意义上，$n_s$ 与在 $p = p_c$ 时单位点上尺寸为 $s$ 的集团的频率成正比。您无需输出 $n_s$ 本身；它将作为第 5 项中估计任务的基础。\n5. 通过推导并应用基于幂律尾部似然性第一性原理、具有良好统计基础的 $\\tau$ 估计量，将 $n_s$ 在下限截止值 $s_{\\min}$ 以上的尾部拟合到幂律 $n_s \\sim s^{-\\tau}$。拟合时仅使用 $s \\ge s_{\\min}$ 的数据。\n6. 将您的估计值 $\\hat{\\tau}$ 与二维理论值 $\\tau_{\\mathrm{2D}} = \\frac{187}{91}$ 进行比较，并计算绝对误差 $|\\hat{\\tau} - \\tau_{\\mathrm{2D}}|$。为进行验证，如果此绝对误差严格小于指定的容差 $\\epsilon$，则声明该案例通过。\n\n您的实现必须使用一种逻辑上合理且计算高效的、适用于大 $L$ 值的集团标记算法（例如，带有动态等价性解析的单遍扫描标记法）。程序必须是自包含的，在给定固定种子的情况下能产生可复现的结果，并避免任何对外部输入或文件的依赖。\n\n测试套件：\n使用以下三组参数。每组参数都是一个元组 $(L, R, p, s_{\\min}, \\text{seed}, \\epsilon)$，所有数值均已明确给出。\n\n- 案例 1：$(L, R, p, s_{\\min}, \\text{seed}, \\epsilon) = (\\,64,\\,200,\\,0.592746,\\,8,\\,12345,\\,0.35\\,)$。\n- 案例 2：$(L, R, p, s_{\\min}, \\text{seed}, \\epsilon) = (\\,96,\\,150,\\,0.592746,\\,10,\\,67890,\\,0.35\\,)$。\n- 案例 3：$(L, R, p, s_{\\min}, \\text{seed}, \\epsilon) = (\\,128,\\,120,\\,0.592746,\\,12,\\,424242,\\,0.35\\,)$。\n\n对于每个案例，您的程序必须计算：\n- 估计的指数 $\\hat{\\tau}$（浮点数）。\n- 绝对误差 $|\\hat{\\tau} - \\frac{187}{91}|$（浮点数）。\n- 一个布尔值，指示该案例是否通过验证标准 $|\\hat{\\tau} - \\frac{187}{91}|  \\epsilon$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按以下顺序汇总到单个列表中的所有三个案例的结果：\n$[\\hat{\\tau}_1, \\text{err}_1, \\text{pass}_1, \\hat{\\tau}_2, \\text{err}_2, \\text{pass}_2, \\hat{\\tau}_3, \\text{err}_3, \\text{pass}_3]$,\n其中 $\\text{err}_k = |\\hat{\\tau}_k - \\frac{187}{91}|$。该行必须严格是一个 Python 风格的列表字面量，使用逗号分隔值，且不含任何其他文本。", "solution": "所述问题是有效的。这是统计物理学领域（特别是逾渗理论）中一个定义明确的计算练习。所有参数都已提供，目标清晰，其底层的物理和数学原理也是合理的。我现在将提供一个完整的解决方案。\n\n目标是在二维方格点阵上，于临界逾渗阈值 $p_c$ 处，数值验证关于有限集团尺寸分布 $n_s$ 的 Fisher 标度律。该定律假定 $n_s \\sim s^{-\\tau}$，其中 $s$ 是集团尺寸，$\\tau$ 是一个普适临界指数。对于二维情况，理论预测 $\\tau = \\frac{187}{91}$。我们的任务是从模拟数据中估计 $\\tau$，并将其与该理论值进行比较。\n\n该过程的结构如下：\n1.  执行蒙特卡洛模拟，以生成逾渗系统的多个实现。\n2.  实现一个算法，以识别每个实现中所有由连通位点组成的集团。\n3.  识别并从分析中排除跨越集团，这些集团是有限系统尺寸造成的人为效应。\n4.  汇总所有剩余有限集团的尺寸。\n5.  使用一种源自最大似然原理的、统计上稳健的方法，从观测到的集团尺寸分布的尾部来估计指数 $\\tau$。\n\n下面将对每个步骤进行详细阐述。\n\n**1. 逾渗系统的模拟**\n\n我们考虑一个尺寸为 $L \\times L$、具有自由边界条件的二维方格点阵。该点阵上的每个位点以概率 $p$ 被指定为“占据”，或以概率 $1-p$ 被指定为“空”，且与其他所有位点无关。本问题在临界逾渗阈值 $p = p_c \\approx 0.592746$ 下进行研究。对于每组参数 $(L, R, p_c, \\text{seed})$，我们生成 $R$ 个独立的点阵构型。使用一个由指定种子初始化的伪随机数生成器来分配每个位点的状态，从而确保可复现性。如果一个抽取的随机变量 $u \\in [0, 1)$ 小于 $p_c$，则坐标为 $(i, j)$ 的位点被占据。此过程会生成一个代表点阵上已占据位点的二元矩阵。\n\n**2. 集团的算法识别**\n\n集团是一组通过最近邻路径相连的已占据位点。为了识别这些集团，我们采用一种基于单遍扫描和不交集并 (Disjoint-Set Union, DSU) 或并查集 (Union-Find) 数据结构的标准高效算法。这是 Hoshen-Kopelman 算法的一种变体。\n\n该算法的流程如下：\n- 一个大小为 $L \\times L$ 的整数矩阵 `labels` 被初始化为全零。一个变量 `next_label` 被初始化为 1。\n- 初始化一个 DSU 数据结构，用于管理标签之间的等价关系。\n- 点阵位点被逐行、从左到右扫描。在每个被占据的位点 $(i, j)$ 处：\n    - 我们检查其已经处理过的最近邻：上方的位点 $(i-1, j)$ 和左侧的位点 $(i, j-1)$。\n    - 如果没有已占据且已标记的邻居，则当前位点是一个新集团的开始。它被赋值 `labels[i, j] = next_label`，并且 `next_label` 自增。在 DSU 中为这个标签创建一个新集合。\n    - 如果存在一个或多个已占据且已标记的邻居，则当前位点属于它们其中一个集团。它被赋予其邻居标签中的最小值。然后调用 DSU 的 `union` 操作来记录所有邻居标签都是等价的。\n- 在这单遍扫描之后，`labels` 矩阵包含初步的标签，而 DSU 结构包含了所有必要的等价信息。然后对 `labels` 矩阵进行第二遍扫描。每个位点的标签被替换为其等价类的规范代表，该代表通过使用带有路径压缩的 DSU `find` 操作找到。\n结果是一个矩阵，其中所有属于同一集团的位点都被标记为相同的唯一整数标签。\n\n**3. 排除跨越集团**\n\n在有限点阵的临界点 $p_c$ 处，存在形成“跨越”或“逾渗”集团的非零概率。这些是宏观集团，其性质受系统有限尺寸的严重影响，并且不属于有限集团分布 $n_s$。我们必须识别并排除它们。如果一个集团连接了点阵的顶部边界与底部边界，或左侧边界与右侧边界，则定义其为跨越集团。\n\n为实现这一点，我们识别出最终 `labels` 矩阵四个边界上存在的唯一集团标签集合：$S_{\\text{top}}$、$S_{\\text{bottom}}$、$S_{\\text{left}}$ 和 $S_{\\text{right}}$。\n如果一个标签为 $k$ 的集团满足 $k \\in (S_{\\text{top}} \\cap S_{\\text{bottom}}) \\cup (S_{\\text{left}} \\cap S_{\\text{right}})$，则该集团为跨越集团。\n所有其标签属于此跨越集合的集团的尺寸，都将从后续的统计分析中排除。\n\n**4. 幂律指数 $\\tau$ 的统计估计**\n\n在汇总了所有 $R$ 次实现中所有有限、非跨越集团的尺寸 $\\{s_i\\}$ 后，我们将分布的尾部拟合到幂律 $n_s \\sim s^{-\\tau}$。这意味着，在给定 $s \\ge s_{\\min}$ 的条件下，观测到尺寸为 $s$ 的集团的概率遵循一个概率分布 $P(s) \\propto s^{-\\tau}$。我们需要一个 $\\tau$ 的估计量。\n\n我们推导连续幂律分布指数的最大似然估计量 (Maximum Likelihood Estimator, MLE)，对于离散情况，这是一个极佳且广泛使用的近似，尤其是在下限截止值 $s_{\\min}$ 不小的情况下。\n对于一个变量 $s$，当 $s \\ge s_{\\min}$ 时，其遵循指数为 $\\tau$ 的幂律的概率密度函数 (PDF) 为：\n$$ P(s | \\tau, s_{\\min}) = (\\tau - 1)s_{\\min}^{\\tau - 1}s^{-\\tau} $$\n这是通过将分布归一化以使 $\\int_{s_{\\min}}^{\\infty} P(s) ds = 1$ 推导出来的。这要求 $\\tau > 1$。\n\n给定一组 $N$ 个观测到的集团尺寸 $\\{s_i\\}_{i=1}^N$（满足 $s_i \\ge s_{\\min}$），似然函数是观测到每个尺寸的概率的乘积：\n$$ \\mathcal{L}(\\tau | \\{s_i\\}) = \\prod_{i=1}^{N} P(s_i | \\tau, s_{\\min}) = \\prod_{i=1}^{N} (\\tau - 1)s_{\\min}^{\\tau - 1}s_i^{-\\tau} $$\n处理对数似然 $\\ln \\mathcal{L}$ 更为方便：\n$$ \\ln \\mathcal{L} = \\sum_{i=1}^{N} \\ln \\left( (\\tau - 1)s_{\\min}^{\\tau - 1}s_i^{-\\tau} \\right) = N \\ln(\\tau - 1) + N(\\tau - 1)\\ln(s_{\\min}) - \\tau \\sum_{i=1}^{N} \\ln(s_i) $$\n为了找到使该函数最大化的 $\\tau$ 值，我们对其关于 $\\tau$ 求导，并令结果为零：\n$$ \\frac{\\partial \\ln \\mathcal{L}}{\\partial \\tau} = \\frac{N}{\\tau - 1} + N\\ln(s_{\\min}) - \\sum_{i=1}^{N} \\ln(s_i) = 0 $$\n求解 $\\tau$ 可得估计量 $\\hat{\\tau}$：\n$$ \\frac{N}{\\hat{\\tau} - 1} = \\sum_{i=1}^{N} \\ln(s_i) - N\\ln(s_{\\min}) = \\sum_{i=1}^{N} (\\ln(s_i) - \\ln(s_{\\min})) = \\sum_{i=1}^{N} \\ln\\left(\\frac{s_i}{s_{\\min}}\\right) $$\n$$ \\hat{\\tau} = 1 + N \\left[ \\sum_{i=1}^{N} \\ln\\left(\\frac{s_i}{s_{\\min}}\\right) \\right]^{-1} $$\n这就是在代码中实现的公式，用于从收集到的、大于或等于指定截止值 $s_{\\min}$ 的集团尺寸中计算估计指数 $\\hat{\\tau}$。理论值为 $\\tau_{\\mathrm{2D}} = \\frac{187}{91}$。计算绝对误差 $|\\hat{\\tau} - \\tau_{\\mathrm{2D}}|$ 并与容差 $\\epsilon$ 进行比较，以确定测试案例是否通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass DSU:\n    \"\"\"A Disjoint-Set Union data structure for cluster labeling.\"\"\"\n\n    def __init__(self):\n        # The parent array maps a label to its parent in the set.\n        # It is represented as a dictionary for sparse label numbers.\n        self.parent = {}\n\n    def find(self, i):\n        \"\"\"Finds the representative of the set containing element i with path compression.\"\"\"\n        if i not in self.parent:\n            self.parent[i] = i\n            return i\n        \n        path = []\n        while self.parent[i] != i:\n            path.append(i)\n            i = self.parent[i]\n        \n        # Path compression\n        for node in path:\n            self.parent[node] = i\n        return i\n\n    def union(self, i, j):\n        \"\"\"Merges the sets containing elements i and j.\"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            # A simple union rule: the smaller root becomes the parent.\n            if root_i  root_j:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_i] = root_j\n\ndef _label_clusters(grid: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Identifies and labels clusters on a 2D grid using a two-pass algorithm with a DSU structure.\n\n    Args:\n        grid: A boolean numpy array where True indicates an occupied site.\n\n    Returns:\n        A numpy array of the same shape with integer labels for each cluster.\n    \"\"\"\n    L = grid.shape[0]\n    labels = np.zeros_like(grid, dtype=np.int32)\n    next_label = 1\n    dsu = DSU()\n\n    # First pass: Scan the grid and assign preliminary labels.\n    for i in range(L):\n        for j in range(L):\n            if grid[i, j]:\n                # Check neighbors (top and left)\n                top_neighbor = labels[i - 1, j] if i > 0 else 0\n                left_neighbor = labels[i, j - 1] if j > 0 else 0\n\n                neighbor_labels = []\n                if top_neighbor > 0:\n                    neighbor_labels.append(top_neighbor)\n                if left_neighbor > 0:\n                    neighbor_labels.append(left_neighbor)\n\n                if not neighbor_labels:\n                    # New cluster\n                    labels[i, j] = next_label\n                    dsu.find(next_label) # Initialize the new label in DSU\n                    next_label += 1\n                else:\n                    # Part of an existing cluster\n                    min_label = min(neighbor_labels)\n                    labels[i, j] = min_label\n                    for label in neighbor_labels:\n                        dsu.union(min_label, label)\n\n    # Second pass: Resolve label equivalences.\n    # A vector mapping old labels to their canonical root is more efficient\n    # than iterating through the grid again, but this is conceptually clear.\n    final_labels = np.zeros_like(labels)\n    for i in range(L):\n        for j in range(L):\n            if labels[i, j] > 0:\n                final_labels[i, j] = dsu.find(labels[i, j])\n\n    return final_labels\n\ndef _estimate_tau(sizes: np.ndarray, s_min: int) -> float:\n    \"\"\"\n    Estimates the power-law exponent tau using the Maximum Likelihood Estimator.\n\n    Args:\n        sizes: A numpy array of all finite cluster sizes.\n        s_min: The minimum size to include in the fit.\n\n    Returns:\n        The estimated exponent tau_hat.\n    \"\"\"\n    sizes_above_min = sizes[sizes >= s_min]\n    n = len(sizes_above_min)\n\n    if n == 0:\n        return np.nan # No data to fit\n\n    # MLE formula: tau = 1 + n / sum(ln(s_i / s_min))\n    log_sum = np.sum(np.log(sizes_above_min / s_min))\n    \n    if log_sum = 0:\n        # This case occurs if all s_i = s_min, implying an infinitely steep exponent.\n        # Or if n=0, though checked above.\n        return np.inf\n\n    tau_hat = 1.0 + n / log_sum\n    return tau_hat\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, R, p, s_min, seed, epsilon)\n        (64, 200, 0.592746, 8, 12345, 0.35),\n        (96, 150, 0.592746, 10, 67890, 0.35),\n        (128, 120, 0.592746, 12, 424242, 0.35),\n    ]\n\n    TAU_2D = 187.0 / 91.0\n    all_results = []\n\n    for L, R, p, s_min, seed, epsilon in test_cases:\n        rng = np.random.default_rng(seed)\n        all_finite_cluster_sizes = []\n\n        for _ in range(R):\n            # 1. Generate lattice\n            grid = rng.random((L, L))  p\n\n            # 2. Identify all clusters\n            labeled_grid = _label_clusters(grid)\n            \n            # Find unique non-zero labels and their counts (sizes)\n            unique_labels, sizes = np.unique(labeled_grid[labeled_grid > 0], return_counts=True)\n            if unique_labels.size == 0:\n                continue\n            \n            cluster_sizes = dict(zip(unique_labels, sizes))\n\n            # 3. Detect and exclude spanning clusters\n            top_boundary_labels = set(np.unique(labeled_grid[0, :]))\n            bottom_boundary_labels = set(np.unique(labeled_grid[L - 1, :]))\n            left_boundary_labels = set(np.unique(labeled_grid[:, 0]))\n            right_boundary_labels = set(np.unique(labeled_grid[:, L - 1]))\n            \n            # Remove background label 0\n            for s in [top_boundary_labels, bottom_boundary_labels, left_boundary_labels, right_boundary_labels]:\n                s.discard(0)\n\n            v_spanning = top_boundary_labels.intersection(bottom_boundary_labels)\n            h_spanning = left_boundary_labels.intersection(right_boundary_labels)\n            spanning_labels = v_spanning.union(h_spanning)\n\n            # 4. Aggregate sizes of finite, non-spanning clusters\n            for label, size in cluster_sizes.items():\n                if label not in spanning_labels:\n                    all_finite_cluster_sizes.append(size)\n        \n        # 5. Fit power law and estimate tau\n        tau_hat = _estimate_tau(np.array(all_finite_cluster_sizes), s_min)\n\n        # 6. Compare with theory and check verification\n        error = abs(tau_hat - TAU_2D)\n        passed = error  epsilon\n\n        all_results.extend([tau_hat, error, passed])\n\n    # Final print statement in the exact required format.\n    # Custom mapping for booleans and floats to get precise string representation.\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v)\n        if isinstance(v, float):\n            return f\"{v:.7f}\" # Ensure sufficient precision\n        return str(v)\n\n    print(f\"[{','.join(map(format_val, all_results))}]\")\n\nsolve()\n```", "id": "2426213"}, {"introduction": "在验证了标度律之后，我们现在将深入探究临界簇错综复杂的几何形态。本练习将引导你区分出贯穿簇的“骨架”（即能够承载从左到右传导路径的部分）与“悬挂端”，并测量它们各自的分形维数 $d_f$ 和 $d_b$。这将让你对临界状态下的物体如何展现出非整数维度和复杂的内部结构有一个具体而直观的理解。[@problem_id:2426194]", "problem": "要求您编写一个完整的、可运行的程序，该程序针对二维方格点阵上的位点逾渗，识别左右贯穿集团（无限集团的有限尺寸代理）的骨架，并使用盒计数法估计其分形维数。您需要将此估计值与完整贯穿集团的估计值进行比较。该任务必须从第一性原理出发解决：使用逾渗理论和图连通性的定义，不使用任何现成的逾渗库。\n\n定义和使用的基本原理：\n- 考虑一个线性尺寸为 $L$ 的开放边界方格点阵，由整数坐标 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,L-1\\}$ 且 $j \\in \\{0,\\dots,L-1\\}$。占据概率为 $p$ 的位点逾渗意味着每个位点以概率 $p$ 独立地被占据，并以概率 $1-p$ 为空置。\n- 如果两个已占据位点在一个坐标上恰好相差一，而在另一个坐标上相等，则它们是最近邻相连的（四邻居连通性）。一个集团是相互连接的已占据位点的最大集合。\n- 左右贯穿集团是指一个集团，它在左边界列 $j=0$ 中至少包含一个已占据位点，并在右边界列 $j=L-1$ 中至少包含一个已占据位点。在一个无向点阵中，同时连接到左边界和右边界的位点集合可以通过两个连通性泛滥的交集获得。\n- 左右贯穿集团的骨架是其位点的一个子集，当电流从左向右传导时，这些位点不属于任何悬挂的死胡同树。一种构造性的定义方法是：在由贯穿集团导出的子图中，重复移除所有度 $\\le 1$ 且不在左或右边界上的位点（度是在该子图内使用四邻居连接计算的），直到无法再移除为止。剩余的位点构成了可以承载左右路径的骨架。\n- 嵌入在平面中的集合的分形维数 $d$ 可以通过盒计数法估计：用边长为 $s$ 的不重叠盒子（其中 $s$ 是 $L$ 的一个因子）网格覆盖 $L \\times L$ 点阵，计算与该集合相交的盒子数量 $N(s)$，并拟合标度律 $N(s) \\propto s^{-d}$；等价地，对 $\\log N(s)$ 与 $\\log (1/s)$ 进行线性最小二乘拟合，以斜率的形式估计 $d$。\n\n要求：\n1. 使用参数为 $p$ 的独立同分布伯努利试验，在 $L \\times L$ 网格上生成位点逾渗构型。使用四邻居连通性和开放边界。\n2. 按如下方式识别左右贯穿集团：通过广度优先搜索 (BFS) 或深度优先搜索 (DFS) 分别计算连接到左边界的已占据位点集合 $A$ 和连接到右边界的已占据位点集合 $B$。贯穿集团的位点是 $A \\cap B$ 中的那些位点。如果 $A \\cap B$ 为空，则不存在左右贯穿集团。\n3. 通过迭代剪枝（燃烧算法）识别贯穿集团的骨架：在由 $A \\cap B$ 导出的子图内，将一个位点的度定义为其同样位于 $A \\cap B$ 中的四邻居已占据邻居的数量。重复移除所有度 $\\le 1$ 且不在列 $j=0$ 或 $j=L-1$ 上的位点（这些边界位点是受保护的，绝不能被剪枝），每次移除后更新度，直到收敛。剩余的集合即为骨架。\n4. 通过盒计数法估计完整贯穿集团的分形维数 $d_f$ 及其骨架的分形维数 $d_b$。使用盒尺寸 $s$，其中 $s$ 是 $L$ 的正整数因子，满足 $1 \\le s \\le L/2$，并至少包含3个不同的尺度。对于每个 $s$，用沿每个轴线排列的 $L/s$ 个盒子铺满网格，并计算包含研究集合中至少一个位点的盒子数量 $N(s)$。对 $\\log N(s)$ 与 $\\log(1/s)$ 进行普通最小二乘拟合以估计 $d$。如果集合为空，则将其分形维数定义为 $0.0$。为保证数值稳健性，您可以将估计的 $d$ 限制在区间 $[0,2]$ 内。\n5. 为保证可复现性，请使用每个测试用例中提供的固定伪随机数生成器 (PRNG) 种子。\n\n测试套件：\n- 用例 $1$：$(L,p,\\text{seed}) = (64,0.62,1)$。\n- 用例 $2$：$(L,p,\\text{seed}) = (64,0.55,2)$。\n- 用例 $3$：$(L,p,\\text{seed}) = (96,1.0,0)$。\n- 用例 $4$：$(L,p,\\text{seed}) = (64,0.70,3)$。\n\n输出规范：\n- 对于每个用例，如果没有左右贯穿集团（即 $A \\cap B$ 为空），则该用例返回数对 $[0.000,0.000]$。\n- 否则，计算并返回数对 $[d_f,d_b]$，其中 $d_f$ 是完整贯穿集团 $A \\cap B$ 的分形维数， $d_b$ 是其骨架的分形维数，每个值都四舍五入到三位小数。\n- 您的程序应生成单行输出，包含四个用例的结果，格式为按测试套件顺序排列的、用方括号括起来的、以逗号分隔的数对列表，例如：$[[d_{f,1},d_{b,1}],[d_{f,2},d_{b,2}],[d_{f,3},d_{b,3}],[d_{f,4},d_{b,4}]]$。不应打印任何额外文本。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。它提出了一个在统计物理学领域内，特别是逾渗理论范畴下的，定义明确的计算问题。所有的定义、参数和算法要求都清晰、一致且有科学依据。任务是实现一系列标准算法：通过伯努利试验生成点阵、使用图搜索识别集团、通过迭代剪枝提取骨架，以及使用盒计数法估计分形维数。我们将提供一个完整的解决方案。\n\n对于每个测试用例 $(L, p, \\text{seed})$，该方法论按四个顺序阶段执行。\n\n**1. 生成逾渗点阵**\n一个大小为 $L \\times L$ 的方格点阵被建模为一个二维数组。每个位点 $(i,j)$（其中 $i, j \\in \\{0, \\dots, L-1\\}$）根据一个随机过程被指定为已占据或空置。我们使用一个由给定种子初始化的伪随机数生成器 (PRNG) 来确保可复现性。对于每个位点，从一个均匀分布中抽取一个随机数 $r \\in [0, 1)$。如果 $r  p$，该位点被标记为“已占据”，否则标记为“空置”，其中 $p$ 是指定的占据概率。这构成了一组独立的伯努利试验，从而产生一个特定的已占据位点构型，分析将在此构型上进行。\n\n**2. 识别左右贯穿集团**\n左右贯穿集团是一条从左边界（$j=0$）到右边界（$j=L-1$）的已占据位点的连通路径。为了识别形成这样一个集团的位点，我们采用两次独立的图遍历搜索。连通性由最近邻定义（一个4邻居冯·诺依曼邻域 (von Neumann neighborhood)）。\n\n首先，我们找到所有与左边界上任何已占据位点相连的已占据位点集合 $A$。这通过从列 $j=0$ 中的所有已占据位点同时发起广度优先搜索 (BFS) 来实现。BFS 探索已占据位点的图，识别所有可达位置。\n\n其次，我们类似地通过从右边界（$j=L-1$）列中的所有已占据位点发起另一次 BFS，找到与右边界相连的所有已占据位点集合 $B$。\n\n属于左右贯穿集团的位点集合，我们记为 $C_{span}$，是这两个集合的交集：$C_{span} = A \\cap B$。如果这个交集为空（$A \\cap B = \\emptyset$），则对于给定的构型，不存在贯穿集团。\n\n**3. 提取集团骨架**\n贯穿集团的骨架是其位点中对维持从左到右的连接至关重要的子集。它排除了“悬挂端”或“死胡同树”。我们使用一种迭代剪枝算法（也称为燃烧算法）来识别骨架。\n\n设 $S_0 = C_{span}$ 为候选骨架位点的初始集合。算法按步骤 $k=0, 1, 2, \\dots$ 进行：\n- 对于每个位点 $s \\in S_k$，我们计算它的度，定义为其也在 $S_k$ 中的最近邻的数量。\n- 如果一个位点 $s=(i,j) \\in S_k$ 的度小于或等于 1（即它是 $S_k$ 内的一个叶节点或孤立位点）并且它不在左或右边界上（即 $j \\neq 0$ 且 $j \\neq L-1$），则该位点被识别为可剪枝的。边界列上的位点是假设电流的受保护蓄水池，永远不会被移除。\n- 形成一个包含所有可剪枝位点的新集合 $P_k$。\n- 如果 $P_k$ 为空，则过程已收敛。骨架是最终的集合 $S_k$。\n- 否则，下一组候选集是 $S_{k+1} = S_k \\setminus P_k$。过程以 $k \\leftarrow k+1$ 重复。\n\n经过这次迭代移除后剩余的位点集合构成了骨架，$C_{backbone}$。\n\n**4. 估计分形维数**\n一组点的分形维数 $d$ 是使用盒计数法来估计的。该方法基于标度假设，即覆盖该集合所需的线性尺寸为 $s$ 的盒子数量 $N(s)$ 遵循幂律标度关系：$N(s) \\propto s^{-d}$。\n\n为了估计 $d$，我们对这个关系取对数：$\\log N(s) = -d \\log s + \\text{const}$，这等价于 $\\log N(s) = d \\log(1/s) + \\text{const}$。这揭示了 $\\log N(s)$ 和 $\\log(1/s)$ 之间的线性关系，其中斜率就是分形维数 $d$。\n\n对于给定的位点集合（$C_{span}$ 或 $C_{backbone}$），算法如下：\n- 如果集合为空，其维数定义为 $0.0$。\n- 选择一系列盒尺寸 $\\{s_k\\}$。根据要求，这些是 $L$ 的整数因子，使得 $1 \\le s_k \\le L/2$。\n- 对于每个 $s_k$，用大小为 $s_k \\times s_k$ 的不重叠盒子平铺 $L \\times L$ 网格。我们计算包含集合中至少一个位点的盒子数量 $N(s_k)$。\n- 然后我们对数据点 $(\\log(1/s_k), \\log N(s_k))$ 进行普通最小二乘线性回归。所得最佳拟合线的斜率提供了分形维数 $d$ 的估计值。为保证数值稳定性，我们使用自然对数。\n- 最终估计的维数被限制在物理上有意义的区间 $[0, 2]$ 内。\n\n该过程应用于完整的贯穿集团 $C_{span}$ 以找到其维数 $d_f$，并应用于其骨架 $C_{backbone}$ 以找到其维数 $d_b$。对每个测试用例计算得到的数对 $[d_f, d_b]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run the percolation analysis for all test cases.\n    \"\"\"\n    test_cases = [\n        (64, 0.62, 1),\n        (64, 0.55, 2),\n        (96, 1.0, 0),\n        (64, 0.70, 3),\n    ]\n\n    results = []\n    for L, p, seed in test_cases:\n        result_pair = run_percolation_analysis(L, p, seed)\n        results.append(result_pair)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{r[0]:.3f},{r[1]:.3f}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n\ndef run_percolation_analysis(L, p, seed):\n    \"\"\"\n    Executes the full analysis for a single test case.\n    \"\"\"\n    # 1. Generate percolation configuration\n    rng = np.random.default_rng(seed)\n    grid = rng.random((L, L))  p\n\n    # 2. Identify spanning cluster\n    \n    # Find sites connected to the left boundary\n    left_starts = {(i, 0) for i in range(L) if grid[i, 0]}\n    cluster_A = _run_bfs(grid, L, left_starts)\n\n    # Find sites connected to the right boundary\n    right_starts = {(i, L - 1) for i in range(L) if grid[i, L - 1]}\n    cluster_B = _run_bfs(grid, L, right_starts)\n\n    # The spanning cluster is the intersection\n    spanning_cluster = cluster_A.intersection(cluster_B)\n\n    if not spanning_cluster:\n        return [0.0, 0.0]\n\n    # 3. Identify backbone\n    backbone = _find_backbone(spanning_cluster, L)\n\n    # 4. Estimate fractal dimensions\n    d_f = _calculate_fractal_dimension(spanning_cluster, L)\n    d_b = _calculate_fractal_dimension(backbone, L)\n\n    return [d_f, d_b]\n\n\ndef _run_bfs(grid, L, start_nodes):\n    \"\"\"\n    Performs a Breadth-First Search on the grid from a set of start nodes.\n    \"\"\"\n    if not start_nodes:\n        return set()\n\n    q = deque(start_nodes)\n    visited = set(start_nodes)\n\n    while q:\n        r, c = q.popleft()\n\n        for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 = nr  L and 0 = nc  L and \\\n               grid[nr, nc] and (nr, nc) not in visited:\n                visited.add((nr, nc))\n                q.append((nr, nc))\n    \n    return visited\n\n\ndef _find_backbone(cluster_sites, L):\n    \"\"\"\n    Identifies the backbone of a cluster by iterative pruning.\n    \"\"\"\n    backbone_candidates = cluster_sites.copy()\n\n    while True:\n        to_prune = set()\n        \n        # Calculate degrees for all sites in the current candidate set\n        degrees = {}\n        for r, c in backbone_candidates:\n            degree = 0\n            for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nr, nc = r + dr, c + dc\n                if (nr, nc) in backbone_candidates:\n                    degree += 1\n            degrees[(r, c)] = degree\n        \n        # Identify prunable sites\n        for (r,c), degree in degrees.items():\n            if degree = 1 and c != 0 and c != L - 1:\n                to_prune.add((r, c))\n\n        if not to_prune:\n            break\n        \n        backbone_candidates.difference_update(to_prune)\n    \n    return backbone_candidates\n\n\ndef _calculate_fractal_dimension(site_set, L):\n    \"\"\"\n    Estimates the fractal dimension of a set of sites using box-counting.\n    \"\"\"\n    if not site_set:\n        return 0.0\n\n    # Determine box sizes s: divisors of L, with 1 = s = L/2\n    box_sizes = [s for s in range(1, L // 2 + 1) if L % s == 0]\n    \n    if len(box_sizes)  3:\n        # Not enough scales for a meaningful fit, might happen for small L.\n        # Although problem constraints (L=64,96) ensure this is not an issue.\n        return 0.0\n\n    site_coords = np.array(list(site_set))\n    log_N_s = []\n    log_inv_s = []\n\n    for s in box_sizes:\n        # Map site coordinates to box coordinates\n        box_coords = site_coords // s\n        \n        # Count unique boxes containing sites\n        num_boxes = len(np.unique(box_coords, axis=0))\n        \n        if num_boxes > 0:\n            log_N_s.append(np.log(num_boxes))\n            log_inv_s.append(np.log(1.0 / s))\n    \n    if len(log_inv_s)  2:\n        # Need at least 2 points for a line fit\n        return 0.0\n\n    # Perform linear regression\n    # log(N(s)) = slope * log(1/s) + intercept\n    slope, _, _, _, _ = linregress(log_inv_s, log_N_s)\n    \n    # Clamp dimension to the interval [0, 2]\n    dimension = np.clip(slope, 0.0, 2.0)\n    \n    return dimension\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2426194"}, {"introduction": "渗流理论不仅限于离散格点模型。这项实践将挑战你模拟一个由重叠圆盘构成的连续模型，这种情况与多孔介质和随机网络等实际问题息息相关。你将通过实现更高级的计算技术，包括高效的空间搜索算法，来确定连续空间中发生渗流的临界密度 $\\eta_c$，从而展示渗流现象的普适性。[@problem_id:2426247]", "problem": "编写一个完整的程序，使用第一性原理模拟和基于原则的统计推断来估算重叠圆盘连续逾渗模型中的临界面积密度。该模型为一个二维布尔模型，建立在边长为 $L$ 的正方形区域上。其中，圆盘中心遵循强度为 $\\rho$（单位面积内的点数）的空间泊松点过程分布，且每个圆盘的半径均为 $r$。当且仅当两个圆盘中心之间的欧几里得距离小于或等于 $2r$ 时，它们被认为是连通的。该系统形成一个无向图，其连通分量即为逾渗团簇。定义无量纲面积密度为 $\\eta = \\rho \\pi r^2$。如果存在至少一个连通分量同时与正方形的左边界（$x \\le r$）和右边界（$x \\ge L - r$）相交，则发生一次（左右）跨越事件。\n\n从空间泊松点过程和几何连通性的核心定义出发，设计一个蒙特卡洛（MC）估算器，用于计算给定 $\\eta$ 下的逾渗概率，然后在一个有限系统中，找出当跨越概率等于 $0.5$ 时的临界面积密度 $\\eta_c$ 的估计值。使用二分法在区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}]$ 上对 $\\eta$ 进行搜索，经过固定次数的迭代后，将最终区间的中心点作为 $\\eta_c$ 的值。在每次评估固定 $\\eta$ 下的跨越概率时，通过以下步骤生成一次独立的实现：首先从均值为 $\\rho L^2$（其中 $\\rho = \\eta / (\\pi r^2)$）的泊松分布中抽取圆盘数量 $N$，然后在 $[0,L]\\times[0,L]$ 区域内独立且均匀地放置 $N$ 个圆盘中心，最后利用重叠圆盘的连通性来测试是否存在左右跨越。\n\n算法要求：\n- 使用带有路径压缩和按秩合并的并查集（DSU）来维护圆盘的连通性。\n- 对于邻居搜索，必须避免对所有点对进行距离检查。应使用一种期望复杂度低于平方级别（例如，空间分割树）的空间搜索方法，来仅枚举距离至多为 $2r$ 的圆盘对。\n- 从几何上处理边界接触：如果一个圆盘的中心坐标 $x$ 满足 $x \\le r$，则它接触左边界；如果满足 $x \\ge L - r$，则它接触右边界。\n- 为每个测试用例使用固定的随机种子，以确保结果的可复现性。\n\n数值和统计规范：\n- 所有量均为无量纲；无需物理单位。\n- 本任务不涉及角度。\n- 在每次评估给定 $\\eta$ 下的跨越概率时，使用恰好 $T$ 次独立试验，并将这 $T$ 次跨越指示变量的样本均值作为跨越概率的估计值。在二分法的决策规则中使用此估算器。\n- 在完成指定数量 $I$ 的二分迭代后，将最终区间的中心点报告为 $\\eta_c$。\n- 为确保数值稳定性和运行时可行性，您必须使用高效的空间结构实现所需的邻居搜索，并使用基于 DSU 的方法处理连通性。\n\n测试套件：\n针对以下三个测试用例运行您的程序。对于每个用例，输出估算出的 $\\eta_c$，结果四舍五入到三位小数。\n\n- 用例 1（理想情况，中等 $N$）：$L = 1$，$r = 0.05$，种子 $s = 12345$，二分迭代次数 $I = 8$，每次评估的试验次数 $T = 128$，区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n- 用例 2（不同尺度，较小的 $N$）：$L = 1$，$r = 0.07$，种子 $s = 54321$，二分迭代次数 $I = 8$，每次评估的试验次数 $T = 128$，区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n- 用例 3（较大的圆盘，更强的有限尺寸效应）：$L = 1$，$r = 0.09$，种子 $s = 999$，二分迭代次数 $I = 8$，每次评估的试验次数 $T = 128$，区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。每个条目都应四舍五入到三位小数，并与测试用例的顺序保持一致。例如，输出必须如下所示：\n[x_1,x_2,x_3]\n其中每个 $x_j$ 是对应案例的四舍五入后的估计值，该行前后不应有任何附加文本。\n\n约束条件：\n- 您必须按规定实现 DSU 连通性算法和空间邻居搜索算法。\n- 您不得读取任何输入；测试用例是硬编码的。\n- 唯一允许使用的库是执行环境中指定的 Python 标准库、NumPy 和 SciPy。", "solution": "对用户提供的问题陈述进行验证。\n\n### 步骤 1：提取给定信息\n- **模型**：边长为 $L$ 的正方形区域上的二维布尔模型。\n- **圆盘中心**：遵循强度为 $\\rho$（单位面积内的点数）的空间泊松点过程分布。\n- **圆盘**：所有圆盘的半径均为固定的 $r$。\n- **连通性**：如果两个圆盘中心的欧几里得距离小于或等于 $2r$，则它们是连通的。\n- **无量纲面积密度**：$\\eta = \\rho \\pi r^2$。\n- **跨越事件**：一个连通的圆盘团簇同时与左边界（$x \\le r$）和右边界（$x \\ge L - r$）相交。\n- **目标**：估算当跨越概率为 $0.5$ 时的临界面积密度 $\\eta_c$。\n- **寻找 $\\eta_c$ 的方法**：在给定的区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}]$ 上对 $\\eta$ 使用二分法，进行固定次数 $I$ 的迭代。最终估计值是最终区间的中心点。\n- **跨越概率估算方法**：蒙特卡洛估算器。对于给定的 $\\eta$，进行 $T$ 次独立试验。估计值是出现跨越事件的试验所占的比例。\n- **单次试验生成**：\n    1. 计算 $\\rho = \\eta / (\\pi r^2)$。\n    2. 从均值为 $\\rho L^2$ 的泊松分布中抽取圆盘数量 $N$。\n    3. 在 $[0,L]\\times[0,L]$ 区域内独立且均匀地放置 $N$ 个圆盘中心。\n- **算法要求**：\n    - 必须使用带有路径压缩和按秩合并的并查集（DSU）来跟踪连通性。\n    - 邻居搜索必须使用低于平方级别的算法（例如，空间分割）来寻找距离 $\\le 2r$ 的点对。禁止全对检查。\n- **测试用例 1**：$L = 1$, $r = 0.05$, 种子 $s = 12345$, 迭代次数 $I = 8$, 试验次数 $T = 128$, 区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n- **测试用例 2**：$L = 1$, $r = 0.07$, 种子 $s = 54321$, 迭代次数 $I = 8$, 试验次数 $T = 128$, 区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n- **测试用例 3**：$L = 1$, $r = 0.09$, 种子 $s = 999$, 迭代次数 $I = 8$, 试验次数 $T = 128$, 区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}] = [0.7, 1.5]$。\n- **输出**：单行输出，包含一个逗号分隔的列表，其中包含每个用例的 $\\eta_c$ 估计值，四舍五入到三位小数，例如 `[x_1,x_2,x_3]`。\n\n### 步骤 2：使用提取的信息进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题描述了圆盘的连续逾渗，也称为布尔模型或随机几何图。这是统计物理学和概率论中的一个经典模型，用于研究随机系统中的连通性。所有的定义——空间泊松点过程、无量纲密度 $\\eta$ 以及临界阈值 $\\eta_c$ 的概念——都是标准的且事实上是正确的。对于无限重叠圆盘系统，$\\eta_c$ 的理论值是一个被充分研究的量，已知约为 $1.12$。该问题在科学上是合理的。\n- **适定性**：该问题在数学和算法上都给出了精确的规定。它要求使用一个完全定义的数值过程——嵌入在二分搜索中的蒙特卡洛模拟——来*估算*有限系统的 $\\eta_c$。为每个测试用例提供了所有参数（$L、r、I、T$、种子、区间）。数值过程的终点（DSU、空间搜索）也受到了明确的约束。这种结构保证了可以获得唯一的数值结果。\n- **客观性**：该问题使用数学和计算机科学的客观语言陈述。没有主观、模糊或基于观点性的条款。\n\n### 步骤 3：结论与行动\n该问题是**有效**的。它是计算统计物理学中一个标准的、适定性的问题，科学上合理且客观。将提供一个解决方案。\n\n### 解决方案设计\n\n该问题要求估算连续逾渗的临界面积密度 $\\eta_c$。解决方案通过实现指定的数值方案来构建，该方案将二分搜索与用于计算跨越概率的蒙特卡洛估算器相结合。\n\n**1. 用于定位 $\\eta_c$ 的二分法**\n跨越概率 $P(\\eta)$ 是面积密度 $\\eta$ 的单调递增函数。临界密度 $\\eta_c$ 被定义为满足 $P(\\eta_c) = 0.5$ 的值。二分法是用于单调函数的稳健求根算法。\n我们从一个已知包含 $\\eta_c$ 的区间 $[\\eta_{\\mathrm{lo}}, \\eta_{\\mathrm{hi}}]$ 开始。算法进行固定次数 $I$ 的迭代：\n1. 计算中点密度 $\\eta_{\\mathrm{mid}} = (\\eta_{\\mathrm{lo}} + \\eta_{\\mathrm{hi}}) / 2$。\n2. 使用蒙特卡洛模拟估算跨越概率 $P(\\eta_{\\mathrm{mid}})$。\n3. 如果估算出的概率大于 $0.5$，则意味着 $\\eta_{\\mathrm{mid}}$ 可能高于临界阈值。更新上界：$\\eta_{\\mathrm{hi}} = \\eta_{\\mathrm{mid}}$。\n4. 如果估算出的概率小于或等于 $0.5$，则 $\\eta_{\\mathrm{mid}}$ 可能等于或低于临界阈值。更新下界：$\\eta_{\\mathrm{lo}} = \\eta_{\\mathrm{mid}}$。\n经过 $I$ 次迭代后，$\\eta_c$ 的估计值为最终缩小后区间的中心点：$(\\eta_{\\mathrm{lo}} + \\eta_{\\mathrm{hi}}) / 2$。\n\n**2. 跨越概率的蒙特卡洛估算**\n为了在给定的密度 $\\eta$ 下评估 $P(\\eta)$，我们执行 $T$ 次独立试验。对于每次试验：\n1. 从无量纲密度 $\\eta$ 计算出圆盘中心的物理密度 $\\rho$，即 $\\rho = \\eta / (\\pi r^2)$。\n2. 区域是面积为 $L^2$ 的正方形。期望的圆盘数量为 $\\lambda = \\rho L^2$。对于空间泊松点过程，固定区域内的点数 $N$ 服从泊松分布。我们从 $\\text{Poisson}(\\lambda)$ 中抽取 $N$。\n3. 我们通过在区域 $[0,L]\\times[0,L]$ 内独立且均匀地抽取它们的中心坐标 $(x, y)$ 来生成这 $N$ 个圆盘的位置。\n4. 然后我们检查这个系统的实现是否包含一个“跨越团簇”。\n$P(\\eta)$ 的估计值是发生跨越的试验次数除以总试验次数 $T$。\n\n**3. 跨越团簇的识别**\n这是单次试验分析的核心。跨越团簇是一个同时接触区域左边界（$x=0$）和右边界（$x=L$）的圆盘连通分量。\n- **连通性**：我们使用一个并查集（DSU）数据结构，该结构通过路径压缩和按秩合并实现以获得最佳性能。$N$ 个圆盘中的每一个都是 DSU 中的一个元素。为了处理边界，我们引入两个虚拟节点：“左边界”节点和“右边界”节点。\n- **边界条件**：中心为 $(x,y)$、半径为 $r$ 的圆盘，如果 $x \\le r$ 则接触左边界，如果 $x \\ge L-r$ 则接触右边界。我们遍历所有圆盘：如果一个圆盘接触左边界，我们就对该圆盘和左边界节点执行合并操作。对右边界也进行类似操作。\n- **邻居搜索**：为了找到哪些圆盘对是连通的（中心距离 $\\le 2r$），进行全对检查（$O(N^2)$）是低效且被禁止的。我们实现了一个基于网格的空间搜索，对于均匀分布的点，其期望时间复杂度为 $O(N)$。\n    1. 将区域 $[0,L]\\times[0,L]$ 划分为一个方形单元格的网格。单元格的边长必须至少为 $2r$。我们选择它恰好为 $2r$。\n    2. 每个圆盘被放入其中心所在的单元格对应的列表中。\n    3. 为了寻找连接，我们遍历每个圆盘 $i$。任何与 $i$ 连通的圆盘 $j$ 的中心必须位于以 $i$ 中心为圆心、半径为 $2r$ 的圆内。由于我们选择的单元格大小，圆盘 $j$ 的中心必须位于与 $i$ 相同的单元格或其 8 个直接相邻的单元格之一。\n    4. 为避免重复检查，对于每个单元格，我们检查该单元格内圆盘之间的连接，以及该单元格中的圆盘与它 8 个邻居中的 4 个（例如，右、左下、下、右下）中的圆盘之间的连接。对于每个识别出的中心距离 $\\le 2r$ 的圆盘对 $(i, j)$，我们执行 `dsu.union(i, j)`。\n- **跨越检查**：在处理完所有潜在的连接（圆盘到边界和圆盘到圆盘）之后，当且仅当左边界和右边界虚拟节点在 DSU 中属于同一个连通分量时，存在跨越团簇。这可以通过 `dsu.find(left_node) == dsu.find(right_node)` 来检查。\n\n设计至此完成。实现将严格遵循此逻辑，确保满足问题陈述中的所有约束条件。", "answer": "```python\nimport numpy as np\n\nclass DSU:\n    \"\"\"Disjoint Set Union data structure with path compression and union by rank.\"\"\"\n    def __init__(self, n):\n        self.parent = np.arange(n)\n        self.rank = np.zeros(n, dtype=np.int32)\n\n    def find(self, i):\n        \"\"\"Finds the representative of the set containing element i with path compression.\"\"\"\n        if self.parent[i] == i:\n            return i\n        self.parent[i] = self.find(self.parent[i])\n        return self.parent[i]\n\n    def union(self, i, j):\n        \"\"\"Merges the sets containing elements i and j using union by rank.\"\"\"\n        root_i = self.find(i)\n        root_j = self.find(j)\n        if root_i != root_j:\n            if self.rank[root_i]  self.rank[root_j]:\n                self.parent[root_i] = root_j\n            elif self.rank[root_i] > self.rank[root_j]:\n                self.parent[root_j] = root_i\n            else:\n                self.parent[root_j] = root_i\n                self.rank[root_i] += 1\n            return True\n        return False\n\ndef has_spanning_cluster(points, L, r):\n    \"\"\"\n    Checks for a left-right spanning cluster in a single realization of disks.\n    Uses DSU for connectivity and a grid-based spatial search for neighbors.\n    \"\"\"\n    N = len(points)\n    if N == 0:\n        return False\n\n    # N disks (0 to N-1), plus two virtual nodes for left/right boundaries\n    left_boundary_node = N\n    right_boundary_node = N + 1\n    dsu = DSU(N + 2)\n\n    # Connect disks to virtual boundary nodes\n    for i in range(N):\n        x = points[i, 0]\n        if x = r:\n            dsu.union(i, left_boundary_node)\n        if x >= L - r:\n            dsu.union(i, right_boundary_node)\n\n    # Early exit if no disks are near both boundaries initially\n    if dsu.find(left_boundary_node) == dsu.find(right_boundary_node):\n        return True\n\n    # Spatial search using a grid to find neighboring disks\n    # The connection distance is 2r, so cell size should be >= 2r\n    cell_size = 2.0 * r\n    grid_dim = int(np.ceil(L / cell_size))\n    if grid_dim == 0: grid_dim = 1\n    \n    grid = [[] for _ in range(grid_dim * grid_dim)]\n    \n    for i in range(N):\n        x, y = points[i]\n        ix = min(int(x / cell_size), grid_dim - 1)\n        iy = min(int(y / cell_size), grid_dim - 1)\n        grid[iy * grid_dim + ix].append(i)\n\n    dist_sq_threshold = (2.0 * r)**2\n\n    for iy in range(grid_dim):\n        for ix in range(grid_dim):\n            current_cell_idx = iy * grid_dim + ix\n            points_in_cell = grid[current_cell_idx]\n            \n            # 1. Pairs WITHIN the current cell\n            for i in range(len(points_in_cell)):\n                for j in range(i + 1, len(points_in_cell)):\n                    p1_idx = points_in_cell[i]\n                    p2_idx = points_in_cell[j]\n                    dist_sq = np.sum((points[p1_idx] - points[p2_idx])**2)\n                    if dist_sq = dist_sq_threshold:\n                        dsu.union(p1_idx, p2_idx)\n\n            # 2. Pairs with neighboring cells (4 directions to avoid double counting)\n            neighbor_deltas = [(1, 0), (0, 1), (1, 1), (-1, 1)] # Right, Bottom, Bottom-Right, Bottom-Left\n            for dix, diy in neighbor_deltas:\n                nix, niy = ix + dix, iy + diy\n                if 0 = nix  grid_dim and 0 = niy  grid_dim:\n                    neighbor_cell_idx = niy * grid_dim + nix\n                    points_in_neighbor_cell = grid[neighbor_cell_idx]\n                    for p1_idx in points_in_cell:\n                        for p2_idx in points_in_neighbor_cell:\n                            dist_sq = np.sum((points[p1_idx] - points[p2_idx])**2)\n                            if dist_sq = dist_sq_threshold:\n                                dsu.union(p1_idx, p2_idx)\n\n    return dsu.find(left_boundary_node) == dsu.find(right_boundary_node)\n\ndef estimate_spanning_prob(eta, L, r, T, rng):\n    \"\"\"Estimates the spanning probability for a given area density eta using T Monte Carlo trials.\"\"\"\n    rho = eta / (np.pi * r**2)\n    lambda_N = rho * L**2\n    \n    spanning_count = 0\n    for _ in range(T):\n        N = rng.poisson(lambda_N)\n        if N == 0:\n            continue\n        \n        points = rng.uniform(0, L, size=(N, 2))\n        \n        if has_spanning_cluster(points, L, r):\n            spanning_count += 1\n            \n    return spanning_count / T\n\ndef solve_case(L, r, seed, I, T, eta_bracket):\n    \"\"\"\n    Finds the critical area density eta_c for one set of parameters using bisection.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    eta_lo, eta_hi = eta_bracket\n\n    for _ in range(I):\n        eta_mid = (eta_lo + eta_hi) / 2.0\n        p_span = estimate_spanning_prob(eta_mid, L, r, T, rng)\n        \n        if p_span > 0.5:\n            eta_hi = eta_mid\n        else:\n            eta_lo = eta_mid\n            \n    return (eta_lo + eta_hi) / 2.0\n\ndef solve():\n    \"\"\"Main function to run all test cases and print results.\"\"\"\n    test_cases = [\n        # Case 1 (happy path, moderate N)\n        {'L': 1, 'r': 0.05, 'seed': 12345, 'I': 8, 'T': 128, 'eta_bracket': [0.7, 1.5]},\n        # Case 2 (different scale, smaller N)\n        {'L': 1, 'r': 0.07, 'seed': 54321, 'I': 8, 'T': 128, 'eta_bracket': [0.7, 1.5]},\n        # Case 3 (larger disks, stronger finite-size effects)\n        {'L': 1, 'r': 0.09, 'seed': 999, 'I': 8, 'T': 128, 'eta_bracket': [0.7, 1.5]},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_case(\n            L=case['L'],\n            r=case['r'],\n            seed=case['seed'],\n            I=case['I'],\n            T=case['T'],\n            eta_bracket=case['eta_bracket']\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{res:.3f}' for res in results])}]\")\n\nsolve()\n```", "id": "2426247"}]}