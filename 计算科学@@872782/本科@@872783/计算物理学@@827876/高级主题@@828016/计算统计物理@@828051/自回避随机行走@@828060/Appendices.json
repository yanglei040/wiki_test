{"hands_on_practices": [{"introduction": "理论联系实践的第一步是处理那些我们可以精确求解的简单情况。对于自回避行走，当行走步数 $N$ 较小时，我们可以通过计算机程序穷举所有可能的路径。这项练习将指导你编写一个程序，通过递归回溯的方法来精确枚举二维方形晶格上所有短程自回避行走，并计算其“跨度”（span）的平均值，这是衡量行走尺寸的一个指标。通过分析平均跨度如何随行走长度 $N$ 变化，你将首次接触到描述这种标度行为的关键参数——标度指数 $\\nu$ [@problem_id:2436367]。", "problem": "要求您以精确、可复现和可检验的方式，研究二维方格格点上自避行走（SAW）的跨度。自避行走是一系列格点位置的序列，其中每一步移动一个单位到四个最近邻之一，且任何位置都不能被访问超过一次。考虑从原点 $(0,0)$ 开始，恰好有 $N$ 个单位步长，并且位于无限大的方格格点上的行走。\n\n对于长度为 $N$ 的行走，将访问过的位置表示为 $\\{(x_i,y_i)\\}_{i=0}^{N}$，其中 $(x_0,y_0)=(0,0)$，对所有 $i$ 都有 $\\|(x_{i+1},y_{i+1})-(x_i,y_i)\\|_1=1$，并且当 $i\\neq j$ 时 $(x_i,y_i)\\neq(x_j,y_j)$。定义 $x$ 方向上的跨度为\n$$\nS_N=\\max_{0\\le i\\le N} x_i - \\min_{0\\le i\\le N} x_i.\n$$\n令 $\\langle S_N\\rangle$ 表示 $S_N$ 的算术平均值，该平均值是对所有从原点开始的长度为 $N$ 的自避行走计算得出的，其中每个行走被赋予相同的权重。\n\n任务：\n1. 对于每个指定的 $N$ 值，计算 $\\langle S_N\\rangle$ 的精确值。\n2. 使用两个指定值 $N_1$ 和 $N_2$（其中 $N_2N_1\\ge 1$），计算由成对对数斜率定义的标度指数估计值 $\\nu$：\n$$\n\\nu=\\frac{\\log\\big(\\langle S_{N_2}\\rangle/\\langle S_{N_1}\\rangle\\big)}{\\log\\big(N_2/N_1\\big)}.\n$$\n\n测试套件：\n- 情况 1：$N=0$。\n- 情况 2：$N=1$。\n- 情况 3：$N=2$。\n- 情况 4：$N=5$。\n- 情况 5：$N=8$。\n- 情况 6：$N=10$。\n- 情况 7：$(N_1,N_2)=(4,10)$，程序必须使用上述定义计算 $\\nu$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序和格式如下：\n- $[\\langle S_0\\rangle,\\langle S_1\\rangle,\\langle S_2\\rangle,\\langle S_5\\rangle,\\langle S_8\\rangle,\\langle S_{10}\\rangle,\\nu]$,\n- 每个数字必须四舍五入到小数点后恰好六位，\n- 输出行中不允许有空格。\n\n不涉及物理单位。不使用角度。不使用百分比。所有量都是纯数。每种情况的预期答案都是如上定义的实数（浮点数）。", "solution": "问题陈述已经过严格验证。它在科学上是合理的、适定的且无歧义的，是研究自避行走中的一个标准计算练习。因此可以推导出解决方案。任务是计算二维方格格点上 $N$ 步自避行走（SAW）的平均跨度 $\\langle S_N \\rangle$ 以及相关的标度指数 $\\nu$。\n\n**1. 理论框架**\n\n长度为 $N$ 的自避行走是由 $N+1$ 个不同格点位置 $p_0, p_1, \\ldots, p_N$ 组成的序列，其中 $p_0$ 是原点 $(0,0)$，每个后续位置 $p_{i+1}$ 都是 $p_i$ 的最近邻。相邻位置之间的距离满足 $\\|p_{i+1} - p_i\\|_1 = 1$。行走在 $x$ 方向上的跨度定义为 $S_N = \\max_{i} x_i - \\min_{i} x_i$，其中 $p_i = (x_i, y_i)$。\n\n我们关注的量 $\\langle S_N \\rangle$ 是在所有长度为 $N$ 的不重复自避行走的系综上对 $S_N$ 取的算术平均值，其中每个行走被赋予相等的概率。\n$$\n\\langle S_N \\rangle = \\frac{1}{C_N} \\sum_{w \\in \\mathcal{W}_N} S_N(w)\n$$\n此处，$\\mathcal{W}_N$ 是所有长度为 $N$ 的 SAW 的集合，而 $C_N = |\\mathcal{W}_N|$ 是这类行走的总数。\n\n对于较小的 $N$，对所有可能的行走进行精确枚举在计算上是可行的。这就是我们将要采用的方法。\n\n**2. 算法方法：递归回溯**\n\n我们将使用递归回溯（深度优先搜索）算法生成给定长度 $N$ 的所有 SAW。\n递归的状态由当前位置、已走的步数以及已访问位置的集合定义。\n\n该算法流程如下：\n- 从原点 $p_0 = (0,0)$ 开始，路径仅包含此点。\n- 递归地将行走延长一步。从当前位置 $p_i$，尝试移动到四个最近邻中的每一个。\n- 仅当新位置 $p_{i+1}$ 未被访问过时，移动才有效。\n- 如果移动有效，则将新位置添加到路径并进行递归。在递归调用返回后，通过从路径中移除该位置来进行回溯，以探索其他可能性。\n- 当行走达到期望的 $N$ 步长度（即路径包含 $N+1$ 个位置）时，递归终止。\n\n**3. 使用格点对称性进行优化**\n\n通过利用方格格点的对称性，计算量可以减少大约 4 倍。所有 SAW 的集合在 $90^\\circ$、$180^\\circ$、$270^\\circ$ 旋转和反射下是不变的。\n\n我们不生成所有的行走，而是只生成行走的子集，记为 $\\mathcal{W}_R$，其中第一步固定为特定方向，例如向右，到达位置 $(1,0)$。对于 $\\mathcal{W}_R$ 中的任何行走 $w$，我们可以通过将其旋转 $90^\\circ$、$180^\\circ$ 和 $270^\\circ$ 来生成其他三个不同的行走。这些分别对应于以向上、向左和向下的步长开始的行走。\n\n令 $w_R$ 为 $\\mathcal{W}_R$ 中的一个行走。其坐标为 $\\{(x_i, y_i)\\}$。\n- 关于 y 轴的反射得到一个行走 $w_L \\in \\mathcal{W}_L$，其坐标为 $\\{(-x_i, y_i)\\}$。它的 x-跨度是 $S_x(w_L) = \\max(-x_i) - \\min(-x_i) = \\max(x_i) - \\min(x_i) = S_x(w_R)$。\n- $90^\\circ$ 逆时针旋转得到一个行走 $w_U \\in \\mathcal{W}_U$，其坐标为 $\\{(-y_i, x_i)\\}$。它的 x-跨度是 $S_x(w_U) = \\max(-y_i) - \\min(-y_i) = \\max(y_i) - \\min(y_i) = S_y(w_R)$，即原始行走的 y-跨度。\n- 类似地，对于行走 $w_D \\in \\mathcal{W}_D$，$S_x(w_D) = S_y(w_R)$。\n\n所有行走上的 x-跨度总和是：\n$$\n\\sum_{w \\in \\mathcal{W}_N} S_x(w) = \\sum_{w \\in \\mathcal{W}_R} S_x(w) + \\sum_{w \\in \\mathcal{W}_L} S_x(w) + \\sum_{w \\in \\mathcal{W}_U} S_x(w) + \\sum_{w \\in \\mathcal{W}_D} S_x(w)\n$$\n$$\n\\sum_{w \\in \\mathcal{W}_N} S_x(w) = 2 \\sum_{w \\in \\mathcal{W}_R} S_x(w) + 2 \\sum_{w \\in \\mathcal{W}_R} S_y(w)\n$$\n对于 $N \\ge 1$，行走的总数为 $C_N = 4 |\\mathcal{W}_R|$。\n因此，平均跨度是：\n$$\n\\langle S_N \\rangle = \\frac{2 \\sum_{w \\in \\mathcal{W}_R} (S_x(w) + S_y(w))}{4 |\\mathcal{W}_R|} = \\frac{1}{2 |\\mathcal{W}_R|} \\sum_{w \\in \\mathcal{W}_R} (S_x(w) + S_y(w))\n$$\n这个优化后的公式只需要枚举 $\\mathcal{W}_R$ 中的行走，计算它们的 x-跨度和 y-跨度，然后合并结果。这就是所实现的程序。对于 $N=0$ 和 $N=1$ 的平凡情况会直接处理：\n- 对于 $N=0$，只有一个行走 $\\{(0,0)\\}$。$S_0=0-0=0$。因此 $\\langle S_0 \\rangle = 0$。\n- 对于 $N=1$，有四个行走。两个的 $S_1=1$（沿 x 轴的步），两个的 $S_1=0$（沿 y 轴的步）。$\\langle S_1 \\rangle = (1+1+0+0)/4 = 0.5$。\n\n**4. 标度指数的计算**\n\n问题要求使用两对数据 $(N_1, \\langle S_{N_1} \\rangle)$ 和 $(N_2, \\langle S_{N_2} \\rangle)$ 计算标度指数 $\\nu$ 的一个估计值。这种关系基于大 $N$ 时的预期幂律标度关系 $\\langle S_N \\rangle \\sim N^\\nu$。指数 $\\nu$ 使用成对对数斜率公式进行估计：\n$$\n\\nu=\\frac{\\log\\big(\\langle S_{N_2}\\rangle/\\langle S_{N_1}\\rangle\\big)}{\\log\\big(N_2/N_1\\big)}\n$$\n对于这个问题，我们使用 $(N_1, N_2) = (4, 10)$。这需要计算 $\\langle S_4 \\rangle$ 和 $\\langle S_{10} \\rangle$。\n\n**5. 实现计划**\n\n一个 Python 类将封装此逻辑。一个递归方法将执行优化后的行走生成。为高效地确保满足自避条件，将使用一个由元组组成的 `set` 来存储已访问的坐标，以实现 $O(1)$ 的平均时间复杂度查找。程序将计算 $N \\in \\{0, 1, 2, 4, 5, 8, 10\\}$ 的 $\\langle S_N \\rangle$，然后使用 $N=4$ 和 $N=10$ 的值计算 $\\nu$，最后按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass SawEnumerator:\n    \"\"\"\n    A class to enumerate Self-Avoiding Walks (SAWs) on a 2D square lattice\n    and calculate the average span. It uses a recursive backtracking algorithm\n    optimized with lattice symmetries.\n    \"\"\"\n    def __init__(self):\n        self.total_x_span_sum = 0.0\n        self.total_y_span_sum = 0.0\n        self.walk_count_one_dir = 0\n\n    def _walk_recursive(self, current_steps, max_steps, pos, path_set, path_list):\n        \"\"\"\n        Recursively generates SAWs from a given state.\n\n        Args:\n            current_steps (int): The number of steps already taken.\n            max_steps (int): The target number of steps for the walk.\n            pos (tuple): The current (x, y) position of the walk.\n            path_set (set): A set of visited coordinates for fast lookups.\n            path_list (list): The ordered list of coordinates in the path.\n        \"\"\"\n        if current_steps == max_steps:\n            self.walk_count_one_dir += 1\n            x_coords = [p[0] for p in path_list]\n            y_coords = [p[1] for p in path_list]\n            self.total_x_span_sum += max(x_coords) - min(x_coords)\n            self.total_y_span_sum += max(y_coords) - min(y_coords)\n            return\n\n        x, y = pos\n        # Possible moves to nearest neighbors\n        moves = [(x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)]\n\n        for next_pos in moves:\n            if next_pos not in path_set:\n                # Explore this valid move\n                path_set.add(next_pos)\n                path_list.append(next_pos)\n                self._walk_recursive(current_steps + 1, max_steps, next_pos, path_set, path_list)\n                # Backtrack to explore other branches\n                path_list.pop()\n                path_set.remove(next_pos)\n\n    def calculate_avg_span(self, N):\n        \"\"\"\n        Calculates the average x-span for all SAWs of length N.\n\n        Args:\n            N (int): The number of steps in the SAW.\n\n        Returns:\n            float: The average span.\n        \"\"\"\n        if N == 0:\n            return 0.0\n        if N == 1:\n            return 0.5\n        \n        self.total_x_span_sum = 0.0\n        self.total_y_span_sum = 0.0\n        self.walk_count_one_dir = 0\n        \n        # Start walk from (0,0), with the first step fixed to (1,0) for symmetry\n        initial_path_set = {(0, 0), (1, 0)}\n        initial_path_list = [(0, 0), (1, 0)]\n        \n        self._walk_recursive(1, N, (1, 0), initial_path_set, initial_path_list)\n        \n        if self.walk_count_one_dir == 0:\n            return 0.0\n        \n        # From solution: avg_span = (sum(S_x) + sum(S_y)) / (2 * count_one_dir)\n        avg_span = (self.total_x_span_sum + self.total_y_span_sum) / (2 * self.walk_count_one_dir)\n        return avg_span\n\ndef solve():\n    \"\"\"\n    Main function to run the calculations and print the results as specified.\n    \"\"\"\n    calculator = SawEnumerator()\n    \n    # Use a cache to store results as calculate_avg_span is expensive\n    span_cache = {}\n    def get_span(n):\n        if n not in span_cache:\n            span_cache[n] = calculator.calculate_avg_span(n)\n        return span_cache[n]\n\n    s0 = get_span(0)\n    s1 = get_span(1)\n    s2 = get_span(2)\n    s5 = get_span(5)\n    s8 = get_span(8)\n    s10 = get_span(10)\n    \n    s4 = get_span(4) # Needed for nu calculation\n\n    # Calculate nu using N1=4 and N2=10\n    if s4 > 0 and s10 > 0:\n        nu = np.log(s10 / s4) / np.log(10 / 4)\n    else:\n        nu = 0.0\n\n    results = [s0, s1, s2, s5, s8, s10, nu]\n    \n    # Format the output string\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function\nsolve()\n```", "id": "2436367"}, {"introduction": "当行走长度 $N$ 增大时，路径数量呈指数级增长，精确穷举变得不可行。在这种情况下，我们转向蒙特卡洛模拟方法。本练习将引导你使用一种名为“动力学增长”的算法，并结合“Rosenbluth权重”这一重要的重要性抽样技术，来生成更长程的自回避行走样本[@problem_id:2436438]。通过在二维三角晶格上模拟，你将估算平均末端距的平方 $\\langle R^2 \\rangle$，并通过对数-对数坐标下的线性回归来提取普适的临界指数 $\\nu$。这项实践不仅能让你掌握一种核心的模拟技巧，还能加深对不同晶格结构下标度行为普适性的理解。", "problem": "您需要编写一个完整、可运行的程序，该程序使用第一性原理和有原则的蒙特卡洛方法，估算二维三角晶格上自回避随机行走的临界指数 $ \\nu $。临界指数 $ \\nu $ 由 $ N $ 步自回避行走的均方末端距 $ \\langle R^2 \\rangle $ 在 $ N \\to \\infty $ 时的标度行为定义，即 $ \\langle R^2 \\rangle \\propto N^{2 \\nu} $。您的程序必须通过生成自回避行走并测量 $ \\langle R^2 \\rangle $ 对 $ N $ 的依赖关系，来估算三角晶格上的 $ \\nu $，然后执行回归以推断 $ \\nu $。您必须将您的估算值与二维方形晶格的参考值 $ \\nu_{\\text{ref}} = 3/4 $ 进行比较，并报告绝对偏差。\n\n您必须遵守以下精确的建模假设、定义和数值规范，以确保普适可复现性和科学真实性：\n\n- 晶格与几何：\n  - 使用通过整数坐标 $ (i,j) \\in \\mathbb{Z}^2 $ 实现的二维三角晶格，基矢为 $ \\mathbf{a}_1 = (1,0) $ 和 $ \\mathbf{a}_2 = \\left( \\tfrac{1}{2}, \\tfrac{\\sqrt{3}}{2} \\right) $。一个格点对应于 $ \\mathbf{r} = i \\mathbf{a}_1 + j \\mathbf{a}_2 $。\n  - 整数坐标系中六个最近邻位移的集合恰好是 $ \\{ (1,0), (0,1), (-1,1), (-1,0), (0,-1), (1,-1) \\} $。\n  - 对于任意格点 $ (i,j) $，其到原点的欧几里得距离平方为 $R^2(i,j) = i^2 + j^2 + ij$。\n\n- 自回避随机行走 (SAW)：\n  - 长度为 $ N $ 的行走是从原点 $ (0,0) $ 开始、由 $ N $ 个最近邻步组成的序列，且从不重复访问任何格点。\n  - 您必须通过动态增长方式生成完整长度的行走：在每一步，从当前可用的未访问邻居中均匀随机地选择一个；如果在任何一步没有可用的邻居，则增长尝试失败并被舍弃。\n\n- 通过 Rosenbluth 权重进行无偏估计：\n  - 为消除动态增长中固有的抽样偏差，每次成功的 $ N $ 步行走都必须被赋予一个 Rosenbluth 权重 $ W = \\prod_{k=1}^{N} c_k $，其中 $ c_k $ 是在迈出第 $ k $ 步之前，从当前格点出发可选择的步数。\n  - 在长度为 $ N $ 时，$ \\langle R^2 \\rangle $ 的无偏估计量是加权平均值 $ \\langle R^2 \\rangle \\approx \\left( \\sum_{m} W_m R^2_m \\right) \\big/ \\left( \\sum_{m} W_m \\right) $，其中求和遍历所有长度为 $ N $ 的成功行走 $ m $。为确保数值稳定性，您必须使用 log-sum-exp 程序在对数域中执行这些加权求和。\n\n- 估算 $ \\nu $：\n  - 对于一组长度 $ \\{ N_\\ell \\} $，计算如上所述的加权平均值 $ \\{ \\langle R^2 \\rangle (N_\\ell) \\} $。\n  - 对 $ \\log \\langle R^2 \\rangle $ 与 $ \\log N $ 进行线性回归，得到斜率 $ s $，由此估算 $ \\nu $ 为 $ \\nu = s / 2 $。使用普通最小二乘法。\n\n- 测试套件和抽样参数：\n  - 您的程序必须使用以下确定性参数集运行三个独立的案例（每个案例都是一个独立的实验）。在每个案例中，都使用三角晶格和上述带 Rosenbluth 权重的动态增长方法。对于案例中的每个 $ N $，收集达到指定数量的成功行走；如果增长尝试次数超过指定的最大值，则使用已收集到的任意数量的成功行走继续。如果为某个 $ N $ 收集到的成功行走少于 $ 10 $ 次，则在该案例的回归中排除该 $ N $。\n    - 案例 1：随机种子 $ 1729 $，长度 $ [10, 20, 30, 40] $，每个长度的目标成功行走次数 $ 40 $，每个长度的最大增长尝试次数 $ 100000 $。\n    - 案例 2：随机种子 $ 2027 $，长度 $ [8, 16, 24, 32] $，每个长度的目标成功行走次数 $ 40 $，每个长度的最大增长尝试次数 $ 100000 $。\n    - 案例 3：随机种子 $ 123 $，长度 $ [5, 10, 15, 20] $，每个长度的目标成功行走次数 $ 60 $，每个长度的最大增长尝试次数 $ 100000 $。\n\n- 输出规范：\n  - 对每个案例，计算估算的 $ \\nu $ 值以及与参考值 $ \\nu_{\\text{ref}} = 3/4 $ 的绝对偏差。将估算值和偏差都四舍五入到 $ 3 $ 位小数。\n  - 您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起，结果按 $[\\widehat{\\nu}_1, |\\widehat{\\nu}_1 - 0.75|, \\widehat{\\nu}_2, |\\widehat{\\nu}_2 - 0.75|, \\widehat{\\nu}_3, |\\widehat{\\nu}_3 - 0.75|]$ 的顺序排列。\n  - 本问题不涉及物理单位。\n\n最终程序必须是自包含的，不需要用户输入，并严格遵守指定的输出格式。每个测试案例的输出必须是实数（浮点数）。", "solution": "所述问题是有效的。这是一个定义明确的计算统计力学练习，基于合理的物理和数学原理。它是自包含的，指定了所有必要的参数和步骤，并提出了一个非平凡但可行的计算任务。我们将着手解决。\n\n目标是估算二维三角晶格上自回避行走（SAW）的临界指数 $\\nu$。该指数决定了行走的空间尺寸随其长度的标度关系。基本关系式如下：\n$$ \\langle R^2 \\rangle \\propto N^{2\\nu} $$\n其中 $N$ 是行走的步数，$\\langle R^2 \\rangle$ 是均方末端距，在所有可能的长度为 $N$ 的自回避行走系综上进行平均。自回避行走模型是研究良溶剂中长链聚合物的核心，也是临界现象理论中的一个典范问题。\n\n为了估算 $\\nu$，我们必须首先生成一个自回避行走的统计系综，并计算不同长度 $N$ 下的 $\\langle R^2 \\rangle$。然后，通过分析 $\\langle R^2 \\rangle$ 对 $N$ 的依赖关系，我们就可以提取出该指数。\n\n**1. 晶格表示与几何**\n\n问题指定了一个二维三角晶格。一个方便的表示方法是使用非正交基矢和整数坐标 $(i,j) \\in \\mathbb{Z}^2$。一个格点 $(i,j)$ 相对于原点 $(0,0)$ 的位置矢量 $\\mathbf{r}$ 由 $\\mathbf{r} = i\\mathbf{a}_1 + j\\mathbf{a}_2$ 给出，其中基矢为 $\\mathbf{a}_1 = (1,0)$ 和 $\\mathbf{a}_2 = (\\frac{1}{2}, \\frac{\\sqrt{3}}{2})$。该晶格的配位数为 $z=6$。在整数坐标系中，从任意格点指向六个最近邻的矢量集合为 $\\{ (1,0), (0,1), (-1,1), (-1,0), (0,-1), (1,-1) \\}$。\n\n从原点到格点 $(i,j)$ 的欧几里得距离平方由点积 $\\mathbf{r} \\cdot \\mathbf{r}$ 推导得出：\n$$ R^2(i,j) = (i\\mathbf{a}_1 + j\\mathbf{a}_2) \\cdot (i\\mathbf{a}_1 + j\\mathbf{a}_2) = i^2|\\mathbf{a}_1|^2 + j^2|\\mathbf{a}_2|^2 + 2ij(\\mathbf{a}_1 \\cdot \\mathbf{a}_2) $$\n由于 $|\\mathbf{a}_1|^2 = 1$，$|\\mathbf{a}_2|^2 = 1$，且 $\\mathbf{a}_1 \\cdot \\mathbf{a}_2 = \\frac{1}{2}$，该式简化为所提供的公式：\n$$ R^2(i,j) = i^2 + j^2 + ij $$\n\n**2. 蒙特卡洛模拟：动态增长与 Rosenbluth 权重**\n\n我们被要求使用动态增长算法生成自回避行走。这是一种简单的序贯方法：\n1. 从原点 $(0,0)$ 开始行走。\n2. 在每一步 $k$（对于 $k=1, \\dots, N$），识别出尚未被访问过的可用最近邻格点集合。\n3. 如果此集合为空，则行走受困，增长尝试失败。该行走被舍弃。\n4. 如果集合非空，则从中均匀随机地选择一个可用格点并移至该处。\n5. 重复此过程，直到成功完成一次长度为 $N$ 的行走。\n\n这种简单的动态增长过程存在固有的偏差。那些探索晶格中更“开放”区域的行走更有可能达到全长 $N$ 而不被困住。这种“耗损偏差”意味着对成功生成的行走进行简单平均，并不能得到真实系综中所有可能自回避行走的平均值。\n\n为了修正这种偏差，我们必须使用 Rosenbluth-Rosenbluth 方法。对于每个成功生成的行走 $m$，我们计算一个权重 $W_m$：\n$$ W_m = \\prod_{k=1}^{N} c_{m,k} $$\n其中 $c_{m,k}$ 是在行走 $m$ 的第 $k$ 步时可用的选择（未访问的邻居）数量。这个权重精确地抵消了抽样偏差。均方末端距的无偏估计量就是加权平均值：\n$$ \\langle R^2 \\rangle = \\frac{\\sum_{m} W_m R^2_m}{\\sum_{m} W_m} $$\n其中 $R^2_m$ 是行走 $m$ 的末端距平方，求和遍历我们样本中所有成功生成的行走。\n\n权重 $W_m$ 可能会相差许多数量级，这会引入数值不稳定性。为减轻此问题，所有涉及权重求和的计算都必须在对数域中进行。我们计算每条行走的权重对数，$\\log W_m = \\sum_{k=1}^{N} \\log c_{m,k}$。然后使用 log-sum-exp 恒等式计算所需的和：\n$$ \\log \\left( \\sum_{i} e^{x_i} \\right) = x_{\\max} + \\log \\left( \\sum_{i} e^{x_i - x_{\\max}} \\right) $$\n应用此方法，我们计算 $\\log \\langle R^2 \\rangle$ 如下：\n$$ \\log \\langle R^2 \\rangle = \\log \\left( \\sum_{m} W_m R^2_m \\right) - \\log \\left( \\sum_{m} W_m \\right) $$\n其中 $\\log(\\sum W_m)$ 是对 $\\log W_m$ 值数组的 log-sum-exp 运算，而 $\\log(\\sum W_m R^2_m)$ 是对 $(\\log W_m + \\log R^2_m)$ 值数组的 log-sum-exp 运算。\n\n**3. 临界指数 $\\nu$ 的估算**\n\n在大 $N$ 的情况下，标度关系定义式 $\\langle R^2 \\rangle \\approx A N^{2\\nu}$ 可以通过取自然对数进行线性化：\n$$ \\log \\langle R^2 \\rangle \\approx \\log A + (2\\nu) \\log N $$\n这表明 $y = \\log \\langle R^2 \\rangle$ 和 $x = \\log N$ 之间存在线性关系。这条线的斜率是 $s = 2\\nu$。\n\n步骤如下：\n1. 对于给定测试案例中每个指定的长度 $N_\\ell$，生成一个自回避行走样本，并计算无偏估计值 $\\langle R^2 \\rangle(N_\\ell)$。\n2. 构建一组数据点 $(\\log N_\\ell, \\log \\langle R^2 \\rangle(N_\\ell))$。任何成功行走次数少于 10 次的长度 $N_\\ell$ 必须被排除。\n3. 对这些数据点执行普通最小二乘法（OLS）线性回归，以找到最佳拟合斜率 $s$。OLS 斜率的公式为：\n$$ s = \\frac{\\sum_{i} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i} (x_i - \\bar{x})^2} $$\n其中 $x_i = \\log N_i$ 且 $y_i = \\log \\langle R^2 \\rangle(N_i)$。\n4. 临界指数的估算值则为 $\\widehat{\\nu} = s/2$。\n5. 最后，我们计算我们的估算值与二维系统的参考值 $\\nu_{\\text{ref}} = 3/4 = 0.75$ 之间的绝对偏差。\n\n对问题中指定的三个测试案例，使用提供的随机种子和抽样参数独立重复此过程，以确保可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the critical exponent nu for self-avoiding walks\n    on a triangular lattice for three specified test cases.\n    \"\"\"\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case 1\n        {\n            \"seed\": 1729,\n            \"lengths\": [10, 20, 30, 40],\n            \"target_walks\": 40,\n            \"max_attempts\": 100000,\n        },\n        # Case 2\n        {\n            \"seed\": 2027,\n            \"lengths\": [8, 16, 24, 32],\n            \"target_walks\": 40,\n            \"max_attempts\": 100000,\n        },\n        # Case 3\n        {\n            \"seed\": 123,\n            \"lengths\": [5, 10, 15, 20],\n            \"target_walks\": 60,\n            \"max_attempts\": 100000,\n        },\n    ]\n\n    # --- Constants ---\n    NEIGHBOR_DELTAS = [(1, 0), (0, 1), (-1, 1), (-1, 0), (0, -1), (1, -1)]\n    NU_REF = 0.75\n\n    # --- Helper Functions ---\n    def custom_logsumexp(x):\n        \"\"\"Numerically stable log-sum-exp operation.\"\"\"\n        if not len(x):\n            return -np.inf\n        max_x = np.max(x)\n        if np.isneginf(max_x):\n            return -np.inf\n        return max_x + np.log(np.sum(np.exp(x - max_x)))\n\n    final_results = []\n    for case in test_cases:\n        rng = np.random.default_rng(case[\"seed\"])\n        \n        log_N_vals = []\n        log_mean_R2_vals = []\n\n        for N in case[\"lengths\"]:\n            successful_walks_data = []\n\n            for _ in range(case[\"max_attempts\"]):\n                path = {(0, 0)}\n                current_pos = (0, 0)\n                log_W = 0.0\n                \n                is_trapped = False\n                for _ in range(N):\n                    neighbors = [(current_pos[0] + dx, current_pos[1] + dy) for dx, dy in NEIGHBOR_DELTAS]\n                    available_neighbors = [n for n in neighbors if n not in path]\n                    \n                    c_k = len(available_neighbors)\n                    if c_k == 0:\n                        is_trapped = True\n                        break\n                    \n                    log_W += np.log(c_k)\n                    \n                    # Choose a step uniformly at random\n                    step_idx = rng.integers(0, c_k)\n                    current_pos = available_neighbors[step_idx]\n                    path.add(current_pos)\n\n                if not is_trapped:\n                    i, j = current_pos\n                    r_sq = float(i**2 + i*j + j**2)\n                    successful_walks_data.append({\"log_W\": log_W, \"r_sq\": r_sq})\n\n                if len(successful_walks_data) >= case[\"target_walks\"]:\n                    break\n            \n            # Exclusion rule: must have at least 10 successful walks\n            if len(successful_walks_data)  10:\n                continue\n\n            # Process collected data for this N\n            log_weights = np.array([d[\"log_W\"] for d in successful_walks_data])\n            r_sq_values = np.array([d[\"r_sq\"] for d in successful_walks_data])\n\n            # Filter out any walks that end at the origin (R^2 = 0) to avoid log(0)\n            valid_indices = r_sq_values > 0\n            if not np.any(valid_indices):\n                continue\n\n            log_weights = log_weights[valid_indices]\n            r_sq_values = r_sq_values[valid_indices]\n\n            # Calculate log of mean R^2 using log-sum-exp\n            log_total_weight = custom_logsumexp(log_weights)\n            log_weighted_r2_sum = custom_logsumexp(log_weights + np.log(r_sq_values))\n            \n            log_mean_R2 = log_weighted_r2_sum - log_total_weight\n            \n            log_N_vals.append(np.log(N))\n            log_mean_R2_vals.append(log_mean_R2)\n\n        # Perform linear regression to find nu\n        if len(log_N_vals)  2:\n            # Not enough data points for regression, produce NaN or handle as error\n            # For this problem, a valid case will always produce enough points.\n            # We add representative invalid values for robustness.\n            nu_hat = float('nan')\n            deviation = float('nan')\n        else:\n            x = np.array(log_N_vals)\n            y = np.array(log_mean_R2_vals)\n\n            # OLS slope calculation\n            x_mean = np.mean(x)\n            y_mean = np.mean(y)\n            numerator = np.sum((x - x_mean) * (y - y_mean))\n            denominator = np.sum((x - x_mean)**2)\n            \n            slope = numerator / denominator if denominator != 0 else 0.0\n            \n            nu_hat = slope / 2.0\n            deviation = abs(nu_hat - NU_REF)\n\n        # Round and append results for the case\n        final_results.append(f\"{nu_hat:.3f}\")\n        final_results.append(f\"{deviation:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(final_results)}]\")\n\n# Execute the simulation and print results\nsolve()\n```", "id": "2436438"}, {"introduction": "从模拟数据中精确提取物理量是计算物理学的一项核心技能。虽然简单的对数-对数图可以给出临界指数 $\\nu$ 的初步估计，但由于行走长度有限而产生的“有限尺寸效应”会引入系统误差。这项高级实践将教你如何运用“有限尺寸标度分析”技术，来系统地处理这些修正项，从而获得更精确的指数估计值[@problem_id:2436413]。你将通过分析一组精心设计的合成数据来学习此方法，这使得你能够专注于分析技术本身，并将其与已知的“真实”值进行比较，这是连接课堂练习与前沿研究的重要一步。", "problem": "您的任务是估算 Flory 指数 $\\nu$，该指数表征了二维方格晶格上 $N$ 步自避行走 (SAW) 的均方末端距 $\\langle R_N^2 \\rangle$ 的渐进行为。自避行走 (SAW) 定义为在 $\\mathbb{Z}^2$ 上的最近邻行走，且从不重访已访问过的位点。$N$ 步后的末端矢量记为 $R_N = x_N - x_0$，系综平均 $\\langle R_N^2 \\rangle$ 是对通过一个固定的、明确定义的抽样过程生成的长度为 $N$ 的 SAW 系综进行平均。Flory 指数 $\\nu$ 由一个渐近关系定义，即对于大的 $N$，一个 SAW 的典型尺寸遵循一个带有乘性有限尺寸修正的幂律。目标是利用有限尺寸标度法，在存在这些修正和抽样噪声的情况下，提高 $\\nu$ 估计值的准确性。\n\n待使用的基本原理和定义：\n- 核心定义：在方格晶格 $\\mathbb{Z}^2$ 上的长度为 $N$ 的自避行走 (SAW) 是一个由不同晶格位点组成的序列 $\\{x_0, x_1, \\dots, x_N\\}$，其中 $x_{i+1}$ 是 $x_i$ 的最近邻，且 $x_0 = (0,0)$。\n- 可观测量：末端矢量为 $R_N = x_N - x_0$，均方末端距为 $\\langle R_N^2 \\rangle$。\n- 经过充分检验的事实：对于大的 $N$，$\\langle R_N^2 \\rangle$ 的增长形式为一个幂律乘以一个缓慢衰减的修正项，这与有限尺寸标度理论一致。您可以将在临界现象和高分子统计学研究中，存在一个代数衰减的修正项视为一个有效且被广泛接受的假设。\n\n您的程序必须实现一个有限尺寸标度分析，以减少次领头修正项带来的偏差。您必须：\n- 基于 $\\ln \\langle R_N^2 \\rangle$ 对 $\\ln N$ 的线性回归构建一个 $\\nu$ 的估计器（基线方法），并提出一个改进方法，该方法使用有效指数和针对 $N$ 的代数修正进行外推，以估计 $N \\to \\infty$ 的极限（有限尺寸标度估计器）。\n- 有限尺寸标度估计器必须基于以下逻辑：从相邻的 $N$ 值定义一个局部斜率或“有效指数”，并通过将其对 $N$ 的负幂进行回归，将该斜率外推至 $N \\to \\infty$ 的极限；此回归必须包含一个可调的修正指数。\n\n不要假设或使用任何特定领域的数值常数，例如 $\\nu$ 在二维空间中的期望值。您的算法必须仅从定义和有限尺寸标度假设中推导得出。\n\n合成模拟数据生成：\n- 为确保可测试性和可复现性，您将生成 $\\langle R_N^2 \\rangle$ 的合成“类模拟”数据集，这些数据集通过组合一个领头幂律、一个代数修正和一个乘性对数正态噪声来模拟蒙特卡洛结果。具体来说，对于每个给定的 $N$ 值列表，根据以下公式生成数据：\n$$\n\\langle R_N^2 \\rangle_{\\text{obs}} = A \\, N^{2 \\nu_{\\text{true}}} \\left(1 + B \\, N^{-\\Delta_{\\text{true}}}\\right) \\times \\exp(\\epsilon_N),\n$$\n其中 $\\epsilon_N$ 是来自均值为 $0$、标准差为 $\\sigma$ 的正态分布的独立样本；每个案例使用一个固定的伪随机数生成器种子以保证可复现性。这里的 $A$、$B$、$\\nu_{\\text{true}}$、$\\Delta_{\\text{true}}$ 和 $\\sigma$ 是下面给出的案例特定参数。您不能在您的估计器中使用这些基准真相参数；它们仅用于生成合成数据集。\n\n估计器设计要求：\n- 基线估计器：通过最小二乘法将一条直线拟合到 $(x_i, y_i)$（其中 $x_i = \\ln N_i$ 和 $y_i = \\ln \\langle R_{N_i}^2 \\rangle_{\\text{obs}}$），并使用斜率除以 $2$ 作为 $\\nu$ 的基线估计。此基线不作为要求输出的一部分，但如果需要，可在内部实现以验证您的方法。\n- 有限尺寸标度估计器：\n  - 使用相邻数据点构建有效斜率 $s_i$：\n  $$\n  s_i = \\frac{1}{2}\\,\\frac{\\ln \\langle R_{N_{i+1}}^2 \\rangle_{\\text{obs}} - \\ln \\langle R_{N_{i}}^2 \\rangle_{\\text{obs}}}{\\ln N_{i+1} - \\ln N_i},\n  $$\n  这样 $s_i$ 可近似于 $\\nu$，误差为一个有限尺寸修正项。\n  - 对于在一个区间 $[\\delta_{\\min}, \\delta_{\\max}]$ 内均匀采样的候选修正指数 $\\Delta$ 网格，对 $s_i$ 与 $N_{\\text{eff},i}^{-\\Delta}$ 进行线性回归，其中 $N_{\\text{eff},i}$ 是对 $(N_i, N_{i+1})$ 这对值的代表性尺度；您必须使用几何平均值 $N_{\\text{eff},i} = \\sqrt{N_i N_{i+1}}$。\n  - 对于每个候选 $\\Delta$，通过最小二乘法对 $s_i = \\nu + K \\, N_{\\text{eff},i}^{-\\Delta}$ 进行回归，记录残差平方和，并选择使该残差最小的 $\\Delta$。相应拟合的截距即为您的有限尺寸标度估计值 $\\widehat{\\nu}_{\\text{fss}}$。\n  - 您的实现不能假设 $\\Delta$ 的值是已知的；它必须在一个范围内搜索并从数据中选择它。\n\n测试套件：\n通过使用上述规则生成合成数据集来创建四个案例。对于每个案例，您必须使用给定的参数和指定的随机种子在内部生成数据。您不得使用任何外部输入。对于每个案例，仅返回 $\\widehat{\\nu}_{\\text{fss}}$。\n\n- 案例 1：\n  - $N$ 值: $\\{12, 16, 20, 24, 28, 32\\}$。\n  - 参数: $A = 1.10$, $B = 0.85$, $\\nu_{\\text{true}} = 0.75$, $\\Delta_{\\text{true}} = 0.50$, $\\sigma = 0.02$。\n  - 随机种子: $12345$。\n- 案例 2：\n  - $N$ 值: $\\{16, 20, 24, 28, 32, 40\\}$。\n  - 参数: $A = 0.95$, $B = -0.60$, $\\nu_{\\text{true}} = 0.75$, $\\Delta_{\\text{true}} = 0.80$, $\\sigma = 0.05$。\n  - 随机种子: $24680$。\n- 案例 3：\n  - $N$ 值: $\\{10, 12, 14, 16, 18, 20, 24\\}$。\n  - 参数: $A = 1.00$, $B = 1.50$, $\\nu_{\\text{true}} = 0.75$, $\\Delta_{\\text{true}} = 0.40$, $\\sigma = 0.03$。\n  - 随机种子: $13579$。\n- 案例 4：\n  - $N$ 值: $\\{20, 24, 28, 32, 36, 40, 48, 56\\}$。\n  - 参数: $A = 1.25$, $B = 0.50$, $\\nu_{\\text{true}} = 0.75$, $\\Delta_{\\text{true}} = 1.00$, $\\sigma = 0.04$。\n  - 随机种子: $112233$。\n\n实现细节：\n- 您必须在有限尺寸标度估计器中使用一个均匀网格来表示候选 $\\Delta$ 值，边界为 $\\delta_{\\min} = 0.20$ 和 $\\delta_{\\max} = 1.50$，网格间距为 $\\delta_{\\text{step}} = 0.01$。\n- 使用自然对数。\n- 所有回归步骤必须是无附加权重的欧几里得范数下的普通最小二乘法。\n- 不涉及角度；没有单位要求。以普通数值形式报告最终的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 1 到 4 的顺序排列结果，每个值四舍五入到恰好 $6$ 位小数，例如 `[0.750000,0.749500,0.751200,0.748900]`。", "solution": "问题陈述已经过验证，被确定为计算物理学中一个有效、适定的问题。其科学基础是临界现象和高分子统计学中已确立的理论，特别是关于自避行走 (SAW) 的研究。所有定义、参数和算法要求都陈述得足够清晰和精确，可以得出一个唯一且可验证的解。其中没有矛盾、歧义或事实错误。\n\n目标是估计二维方格晶格 $\\mathbb{Z}^2$ 上自避行走的 Flory 指数 $\\nu$。该指数控制着聚合物尺寸随其长度的渐近标度行为。主要可观测量是 $N$ 步自避行走的均方末端距 $\\langle R_N^2 \\rangle$。对于大的 $N$，该量预期遵循幂律关系：\n$$\n\\langle R_N^2 \\rangle \\sim A N^{2\\nu}\n$$\n其中 $A$ 是一个非普适振幅，$\\nu$ 是一个普适临界指数。在实践中，对于有限的 $N$，存在对这种领头行为的修正。问题提供了一个包含领头修正项的模型，这是有限尺寸标度分析中的标准方法：\n$$\n\\langle R_N^2 \\rangle = A N^{2\\nu} \\left(1 + B N^{-\\Delta} + \\dots\\right)\n$$\n这里，$B$ 是另一个非普适振幅，$\\Delta  0$ 是领头的标度修正指数。待分析的合成数据是根据此模型生成的，并加入了额外的乘性对数正态噪声，以模拟蒙特卡洛实验中的统计误差：\n$$\n\\langle R_N^2 \\rangle_{\\text{obs}} = A N^{2\\nu_{\\text{true}}} \\left(1 + B N^{-\\Delta_{\\text{true}}}\\right) \\exp(\\epsilon_N)\n$$\n其中 $\\epsilon_N$ 是一个均值为 $0$、标准差为 $\\sigma$ 的正态分布随机变量。我们的任务是在不知道真实参数 $A$、$B$、$\\nu_{\\text{true}}$、$\\Delta_{\\text{true}}$ 或 $\\sigma$ 的情况下，从此类数据中估计 $\\nu$。\n\n一个朴素的方法是通过取对数来将领头幂律线性化：$\\ln \\langle R_N^2 \\rangle \\approx \\ln A + 2\\nu \\ln N$。然后，对 $\\ln \\langle R_N^2 \\rangle$ 与 $\\ln N$ 进行线性拟合，将得到 $2\\nu$ 的斜率。然而，修正项 $B N^{-\\Delta}$ 会引入系统性偏差，使估计产生偏差。\n\n指定的有限尺寸标度方法旨在系统地解释这种修正。首先，我们对完整模型取自然对数（为清晰起见，近似 $\\ln(1+x) \\approx x$ 对于小的 $x = B N^{-\\Delta}$，并忽略噪声项）：\n$$\n\\ln \\langle R_N^2 \\rangle \\approx \\ln A + 2\\nu \\ln N + B N^{-\\Delta}\n$$\n为了分析 $\\nu$ 的估计值如何随 $N$ 变化，我们根据相邻数据点对 $(N_i, \\langle R_{N_i}^2 \\rangle_{\\text{obs}})$ 和 $(N_{i+1}, \\langle R_{N_{i+1}}^2 \\rangle_{\\text{obs}})$ 定义一个有效指数 $s_i$：\n$$\ns_i = \\frac{1}{2} \\frac{\\ln \\langle R_{N_{i+1}}^2 \\rangle_{\\text{obs}} - \\ln \\langle R_{N_{i}}^2 \\rangle_{\\text{obs}}}{\\ln N_{i+1} - \\ln N_i}\n$$\n这个量是局部导数 $\\frac{1}{2} \\frac{d(\\ln \\langle R_N^2 \\rangle)}{d(\\ln N)}$ 的一个离散近似。对我们的 $\\ln \\langle R_N^2 \\rangle$ 模型关于 $\\ln N$ 求导，得到：\n$$\n\\frac{1}{2} \\frac{d(\\ln \\langle R_N^2 \\rangle)}{d(\\ln N)} = \\frac{1}{2} \\frac{d}{d(\\ln N)} \\left( \\ln A + 2\\nu \\ln N + B N^{-\\Delta} \\right) = \\nu - \\frac{1}{2} B \\Delta N^{-\\Delta}\n$$\n这表明，在 $N_i$ 和 $N_{i+1}$ 之间的有效尺度 $N_{\\text{eff},i}$ 处计算的有效指数 $s_i$ 应具有如下行为：\n$$\ns_i \\approx \\nu + K (N_{\\text{eff},i})^{-\\Delta}\n$$\n其中 $K = -B\\Delta/2$ 是一个常数。我们使用几何平均值 $N_{\\text{eff},i} = \\sqrt{N_i N_{i+1}}$ 作为有效尺度。\n\n这个方程提供了一种强大的分析方法。它是 $s_i$ 和变量 $x_i = (N_{\\text{eff},i})^{-\\Delta}$ 之间的一个线性关系。这种线性关系的截距就是渐近指数 $\\nu$，这正是我们希望估计的量。\n\n然而，修正指数 $\\Delta$ 也是未知的。该算法通过执行搜索来解决这个问题。我们在区间 $[\\delta_{\\min}, \\delta_{\\max}] = [0.20, 1.50]$ 内定义一个候选 $\\Delta$ 值的网格。对于每个候选 $\\Delta$，我们对 $s_i$ 与 $(N_{\\text{eff},i})^{-\\Delta}$ 进行普通最小二乘线性回归。每次拟合的质量通过其残差平方和 (RSS) 来衡量。产生最小 RSS 的 $\\Delta$ 值被认为是修正指数的最佳估计。Flory 指数的最终估计值 $\\widehat{\\nu}_{\\text{fss}}$ 是对应于这个最优 $\\Delta$ 的线性拟合的截距。这个过程系统地消除了领头的有限尺寸偏差，并为 $N \\to \\infty$ 的极限情况提供了外推估计。\n\n整个算法流程如下：\n1.  对于每个测试案例，使用提供的参数和随机种子生成合成数据集 $\\{\\left(N_i, \\langle R_{N_i}^2 \\rangle_{\\text{obs}}\\right)\\}$。\n2.  计算有效指数序列 $\\{s_i\\}$ 和有效尺度序列 $\\{N_{\\text{eff},i}\\}$。\n3.  遍历候选修正指数 $\\Delta$ 的网格，$\\Delta \\in [0.20, 0.21, \\dots, 1.50]$。\n4.  对于每个 $\\Delta$，对 $s_i$ 与 $(N_{\\text{eff},i})^{-\\Delta}$ 进行线性回归，得到截距 $\\nu(\\Delta)$ 和相应的 RSS$(\\Delta)$。\n5.  找到最优修正指数 $\\Delta^* = \\arg\\min_{\\Delta} \\text{RSS}(\\Delta)$。\n6.  最终估计值为 $\\widehat{\\nu}_{\\text{fss}} = \\nu(\\Delta^*)$。\n对四个指定的测试案例均执行此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Estimates the Flory exponent nu for a 2D Self-Avoiding Walk using\n    a finite-size scaling analysis on synthetic data.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N_values\": [12, 16, 20, 24, 28, 32],\n            \"A\": 1.10, \"B\": 0.85, \"nu_true\": 0.75, \"Delta_true\": 0.50, \"sigma\": 0.02,\n            \"seed\": 12345\n        },\n        {\n            \"N_values\": [16, 20, 24, 28, 32, 40],\n            \"A\": 0.95, \"B\": -0.60, \"nu_true\": 0.75, \"Delta_true\": 0.80, \"sigma\": 0.05,\n            \"seed\": 24680\n        },\n        {\n            \"N_values\": [10, 12, 14, 16, 18, 20, 24],\n            \"A\": 1.00, \"B\": 1.50, \"nu_true\": 0.75, \"Delta_true\": 0.40, \"sigma\": 0.03,\n            \"seed\": 13579\n        },\n        {\n            \"N_values\": [20, 24, 28, 32, 36, 40, 48, 56],\n            \"A\": 1.25, \"B\": 0.50, \"nu_true\": 0.75, \"Delta_true\": 1.00, \"sigma\": 0.04,\n            \"seed\": 112233\n        }\n    ]\n\n    results = []\n    \n    # Define parameters for the finite-size scaling estimator\n    delta_min = 0.20\n    delta_max = 1.50\n    delta_step = 0.01\n    \n    delta_grid = np.arange(delta_min, delta_max + delta_step, delta_step)\n\n    for case in test_cases:\n        # 1. Generate synthetic data\n        rng = np.random.default_rng(case[\"seed\"])\n        N = np.array(case[\"N_values\"], dtype=float)\n        \n        # Generate log-normal noise\n        epsilon_N = rng.normal(0, case[\"sigma\"], size=len(N))\n        \n        # Calculate observed mean-squared end-to-end distance using the provided model\n        r2_obs = (case[\"A\"] * N**(2 * case[\"nu_true\"]) *\n                  (1 + case[\"B\"] * N**(-case[\"Delta_true\"])) *\n                  np.exp(epsilon_N))\n\n        # 2. Construct effective slopes and effective lengths\n        log_r2 = np.log(r2_obs)\n        log_N = np.log(N)\n        \n        # Effective slopes s_i from adjacent points\n        s_i = 0.5 * (log_r2[1:] - log_r2[:-1]) / (log_N[1:] - log_N[:-1])\n        # Effective scales N_eff,i (geometric mean)\n        N_eff = np.sqrt(N[1:] * N[:-1])\n\n        # 3. Search for the best correction exponent Delta by minimizing RSS\n        min_rss = float('inf')\n        best_nu_fss = None\n\n        y_data = s_i\n        \n        for delta_candidate in delta_grid:\n            # Independent variable for regression: x = N_eff^(-Delta)\n            x_data = N_eff**(-delta_candidate)\n            \n            # Setup for Ordinary Least Squares: y = p[1] + p[0] * x\n            # where p[0] is the slope and p[1] is the intercept (our nu estimate)\n            A = np.vstack([x_data, np.ones(len(x_data))]).T\n            \n            p, residuals, _, _ = np.linalg.lstsq(A, y_data, rcond=None)\n            \n            # The residual sum of squares is returned by lstsq\n            rss = residuals[0] if residuals.size > 0 else 0.0\n            intercept_nu = p[1]\n\n            # Update if this Delta gives a better fit (lower RSS)\n            if rss  min_rss:\n                min_rss = rss\n                best_nu_fss = intercept_nu\n        \n        results.append(best_nu_fss)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2436413"}]}