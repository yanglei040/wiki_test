{"hands_on_practices": [{"introduction": "我们从研究统计系统的最直接方法——精确枚举——开始。对于一个小尺寸的伊辛模型系统，我们可以遍历所有可能的自旋构型，计算每种构型的能量，并由此直接从配分函数出发计算宏观热力学量。这个练习将通过计算能量的概率分布，具体展示微观能量涨落与宏观可观测量（如热容）之间的深刻联系，这正是涨落-耗散定理的一个核心体现。", "problem": "考虑一个线性尺寸为 $L$ 的方形晶格上的二维伊辛模型，该模型具有周期性边界条件、零外场和均匀最近邻耦合 $J$。每个自旋 $s_i$ 的取值为 $\\{-1,+1\\}$。其哈密顿量为\n$$\n\\mathcal{H}(\\{s\\}) \\;=\\; -J \\sum_{\\langle i,j\\rangle} s_i s_j,\n$$\n其中，求和遍历所有满足周期性边界条件的独立最近邻对。在绝对温度为 $T$、玻尔兹曼常数为 $k_{\\mathrm B}$ 的典则平衡下进行计算，并定义总自旋数 $N=L^2$，逆温度 $\\beta = 1/(k_{\\mathrm B} T)$，以及配分函数\n$$\nZ(\\beta) \\;=\\; \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})},\n$$\n以及由典则系综引出的总能量概率分布 $P(E)$。令 $g(E)$ 表示态密度（总能量恰好等于 $E$ 的微观态数量）。则\n$$\nP(E) \\;=\\; \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)}.\n$$\n\n任务：\n1. 对于指定的系统，计算典则系综所蕴含的离散能量分布 $P(E)$，并验证其归一性。\n2. 计算关于 $P(E)$ 的平均能量 $\\langle E\\rangle$ 和方差 $\\mathrm{Var}(E)=\\langle E^2\\rangle - \\langle E\\rangle^2$。\n3. 计算单位自旋热容 $c(T)$，其定义为\n$$\nc(T) \\;=\\; \\frac{1}{N}\\,\\frac{d\\langle E\\rangle}{dT}.\n$$\n仅使用上述基本定义，证明能量 $E$ 的方差与热容之间的关系。\n\n所有计算均使用以下固定参数：\n- $L=4$，\n- $J=1$，\n- $k_{\\mathrm B}=1$。\n因此，在这些单位下，所有能量、温度和热容都是无量纲的。本问题不涉及角度。不需要其他物理单位。\n\n测试集（三个温度，用于探测性质不同的区域）：\n- 低温 $T=0.5$，\n- 临界点附近温度 $T=2.2691853$，\n- 高温 $T=5.0$。\n\n对于以上述顺序给出的每个温度，产生三个输出：\n- 一个布尔值，表示 $\\sum_E P(E)$ 是否在 $10^{-12}$ 的绝对容差内等于 $1$，\n- 单位自旋方差 $\\mathrm{Var}(E)/N$，以实数形式表示，\n- 单位自旋热容 $c(T)$，以实数形式表示。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，该列表汇总了三个温度下的结果。该列表必须恰好包含九个条目，排列如下\n$$\n[\\text{norm\\_ok}_{T=0.5},\\, \\mathrm{Var}(E)/N\\big|_{T=0.5},\\, c(T)\\big|_{T=0.5},\\, \\text{norm\\_ok}_{T=2.2691853},\\, \\mathrm{Var}(E)/N\\big|_{T=2.2691853},\\, c(T)\\big|_{T=2.2691853},\\, \\text{norm\\_ok}_{T=5.0},\\, \\mathrm{Var}(E)/N\\big|_{T=5.0},\\, c(T)\\big|_{T=5.0}],\n$$\n其中每个 $\\text{norm\\_ok}_{T}$ 是布尔字面量 True 或 False，每个实数以十进制形式打印。不应打印任何额外文本。", "solution": "在具有周期性边界条件的 $L\\times L$ 晶格上，哈密顿量为 $\\mathcal{H}(\\{s\\}) = -J \\sum_{\\langle i,j\\rangle} s_i s_j$ 的二维伊辛模型，对于任何有限的 $L$，都具有有限的微观态集合。在温度为 $T$ 的典则系综中达到平衡时，一个微观态 $\\{s\\}$ 的概率由玻尔兹曼因子除以配分函数给出，即 $p(\\{s\\}) = e^{-\\beta \\mathcal{H}(\\{s\\})}/Z(\\beta)$，其中 $\\beta = 1/(k_{\\mathrm B} T)$ 且 $Z(\\beta) = \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})\\}$。将微观态按其总能量 $E$ 分组，定义了态密度 $g(E)$，并得到典则能量分布\n$$\nP(E) \\;=\\; \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)}.\n$$\n归一化可由定义得出：\n$$\n\\sum_E P(E) \\;=\\; \\sum_E \\frac{g(E)\\, e^{-\\beta E}}{Z(\\beta)} \\;=\\; \\frac{1}{Z(\\beta)} \\sum_{\\{s\\}} e^{-\\beta \\mathcal{H}(\\{s\\})} \\;=\\; 1.\n$$\n\n根据基本定义，平均能量和均方能量为\n$$\n\\langle E\\rangle \\;=\\; \\sum_E E\\, P(E), \n\\qquad\n\\langle E^2\\rangle \\;=\\; \\sum_E E^2\\, P(E),\n$$\n方差为 $\\mathrm{Var}(E) = \\langle E^2\\rangle - \\langle E\\rangle^2$。\n\n为了将方差与热容联系起来，我们从配分函数 $Z(\\beta)$ 及其对数开始。对 $\\beta$ 求导可得\n$$\n\\frac{\\partial \\ln Z}{\\partial \\beta} \n\\;=\\; \\frac{1}{Z}\\frac{\\partial Z}{\\partial \\beta}\n\\;=\\; \\frac{1}{Z} \\sum_{\\{s\\}} \\left(-\\mathcal{H}(\\{s\\})\\right) e^{-\\beta \\mathcal{H}(\\{s\\})}\n\\;=\\; - \\langle E\\rangle.\n$$\n再次求导，\n$$\n\\frac{\\partial^2 \\ln Z}{\\partial \\beta^2}\n\\;=\\; -\\frac{\\partial \\langle E\\rangle}{\\partial \\beta}\n\\;=\\; \\langle E^2\\rangle - \\langle E\\rangle^2\n\\;=\\; \\mathrm{Var}(E).\n$$\n总热容 $C$ 定义为\n$$\nC \\;=\\; \\frac{d\\langle E\\rangle}{dT}.\n$$\n使用 $\\beta = 1/(k_{\\mathrm B} T)$，我们有 $d\\beta/dT = -1/(k_{\\mathrm B} T^2)$。因此，\n$$\nC \\;=\\; \\frac{d\\langle E\\rangle}{d\\beta} \\frac{d\\beta}{dT}\n\\;=\\; \\left(-\\frac{\\partial^2 \\ln Z}{\\partial \\beta^2}\\right)\\left(-\\frac{1}{k_{\\mathrm B} T^2}\\right)\n\\;=\\; \\frac{\\mathrm{Var}(E)}{k_{\\mathrm B} T^2}.\n$$\n除以自旋数 $N=L^2$ 得到单位自旋热容\n$$\nc(T) \\;=\\; \\frac{C}{N} \\;=\\; \\frac{\\mathrm{Var}(E)}{N\\, k_{\\mathrm B}\\, T^2}.\n$$\n\n当 $J=1$ 和 $k_{\\mathrm B}=1$ 时，所有量均为无量纲量，上式简化为 $c(T) = \\mathrm{Var}(E)/(N T^2)$。这个恒等式直接从典则定义中得出，并精确地展示了能量的方差如何决定热容。\n\n在算法上，对于有限的 $L$，可以通过构造所有自旋构型 $\\{s\\}$，使用具有周期性边界条件的哈密顿量计算它们的能量，统计每个不同能量的出现次数以形成 $g(E)$，然后用 $Z = \\sum_E g(E) e^{-\\beta E}$ 来计算 $P(E) = g(E) e^{-\\beta E}/Z$。根据 $P(E)$，计算 $\\langle E\\rangle$、$\\langle E^2\\rangle$、$\\mathrm{Var}(E)$，最后计算 $c(T)=\\mathrm{Var}(E)/(N T^2)$。归一化检查验证了 $\\sum_E P(E)$ 在规定的数值容差内等于 $1$。所选的测试温度 $T=0.5$、$T=2.2691853$ 和 $T=5.0$ 跨越了低温、临界点附近和高温区域；相应地，对于这个有限系统，单位自旋方差在极低和极高温度下很小，在临界区域附近较大，而单位自旋热容则遵循由 $c(T) = \\mathrm{Var}(E)/(N T^2)$ 所决定的相同定性趋势。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ising_energy_spectrum_L(L: int, J: float = 1.0):\n    \"\"\"\n    Compute the energy spectrum (unique energies and their degeneracies g(E))\n    for the 2D Ising model on an LxL lattice with periodic boundary conditions\n    and zero external field, with coupling J.\n\n    Returns:\n        E_values: np.ndarray of shape (M,), sorted unique energies (dtype=int64)\n        g_values: np.ndarray of shape (M,), degeneracy counts for each energy (dtype=int64)\n        N: total number of spins (int)\n    \"\"\"\n    N = L * L\n    # Neighbor indices for counting each bond once: right and down neighbors\n    right = np.empty(N, dtype=np.int64)\n    down = np.empty(N, dtype=np.int64)\n    for r in range(L):\n        for c in range(L):\n            idx = r * L + c\n            right[idx] = r * L + ((c + 1) % L)\n            down[idx] = ((r + 1) % L) * L + c\n\n    # Enumerate all spin configurations via bit representation\n    num_states = 1  N  # 2^N\n    states = np.arange(num_states, dtype=np.uint32)  # shape (num_states,)\n    masks = (1  np.arange(N, dtype=np.uint32))     # shape (N,)\n\n    # Convert bits to spins in {-1, +1}\n    bits = ((states[:, None]  masks) != 0).astype(np.int8)  # shape (num_states, N)\n    spins = (bits * 2) - 1  # 0->-1, 1->+1\n\n    # Compute total energy for each configuration; count each bond once (right and down)\n    # E = -J * sum_{i} (s_i s_{right(i)} + s_i s_{down(i)})\n    # We can vectorize using advanced indexing over columns\n    prod_right = spins * spins[:, right]\n    prod_down = spins * spins[:, down]\n    bond_sum = prod_right + prod_down\n    # Sum over all sites to get total bond contribution, then multiply by -J\n    E = (-J * bond_sum.sum(axis=1)).astype(np.int64)  # shape (num_states,)\n\n    # Get unique energies and degeneracies g(E)\n    E_values, g_values = np.unique(E, return_counts=True)\n    g_values = g_values.astype(np.int64)\n    return E_values.astype(np.int64), g_values, N\n\ndef canonical_stats_from_spectrum(E_values, g_values, T: float, kB: float = 1.0):\n    \"\"\"\n    Given energy levels E_values (int) and degeneracies g_values (int),\n    compute canonical probabilities P(E), mean energy, mean squared energy,\n    and variance at temperature T with Boltzmann constant kB.\n    \"\"\"\n    beta = 1.0 / (kB * T)\n    E_float = E_values.astype(np.float64)\n    g_float = g_values.astype(np.float64)\n\n    # Unnormalized weights: w(E) = g(E) * exp(-beta * E)\n    # For numerical stability here, direct exponentiation is sufficient for given L and T.\n    weights = g_float * np.exp(-beta * E_float)\n    Z = weights.sum()\n    P_E = weights / Z\n\n    # Normalization check\n    norm_ok = bool(np.isclose(P_E.sum(), 1.0, atol=1e-12, rtol=0.0))\n\n    # Moments\n    mean_E = np.sum(P_E * E_float)\n    mean_E2 = np.sum(P_E * (E_float ** 2))\n    var_E = mean_E2 - mean_E ** 2\n    # Guard against tiny negative due to floating errors\n    if var_E  0 and var_E > -1e-18:\n        var_E = 0.0\n\n    return norm_ok, mean_E, mean_E2, var_E\n\ndef solve():\n    # Define the test cases from the problem statement.\n    L = 4\n    J = 1.0\n    kB = 1.0\n    test_temperatures = [0.5, 2.2691853, 5.0]\n\n    # Precompute spectrum for given L and J\n    E_values, g_values, N = ising_energy_spectrum_L(L=L, J=J)\n\n    results = []\n    for T in test_temperatures:\n        norm_ok, mean_E, mean_E2, var_E = canonical_stats_from_spectrum(E_values, g_values, T=T, kB=kB)\n        var_per_spin = var_E / N\n        c_per_spin = var_E / (N * (T ** 2) * kB)  # with kB=1.0\n        results.append(norm_ok)\n        results.append(var_per_spin)\n        results.append(c_per_spin)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2448166"}, {"introduction": "当系统尺寸增大时，精确枚举会变得不可行。然而，对于在一个维度上无限延伸的条带状系统，我们可以使用传递矩阵方法获得精确解。该方法将二维统计力学问题巧妙地转化为一个一维的、类似量子力学的本征值问题。通过构建并对角化传递矩阵，我们可以根据其最大和次大本征值来精确计算系统的关联长度，从而深入理解长程有序的本质。", "problem": "考虑一个宽度为 $W$ 的条带上的铁磁二维 (2D) 伊辛模型，该条带在宽度方向上具有周期性边界条件，传递方向沿行方向。设每个自旋 $s_i \\in \\{-1,+1\\}$，沿传递方向（连续行之间）的最近邻耦合由无量纲耦合常数 $K_v$ 给出，行内（水平方向）的最近邻耦合由无量纲耦合常数 $K_h$ 给出。行间传递矩阵 $T$ 定义在行构型的 $2^W$ 维空间上。对于两个连续的行构型 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$，定义\n$$\n\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})=\\sum_{i=1}^{W} s_i s_{i+1},\\quad s_{W+1}\\equiv s_1,\\qquad\n\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}')=\\sum_{i=1}^{W} s_i s_i',\n$$\n以及对称的传递矩阵元\n$$\nT_{\\boldsymbol{s},\\boldsymbol{s}'}=\\exp\\!\\left(K_v\\,\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}')+\\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})+\\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}')\\right).\n$$\n设 $\\lambda_0$ 是 $T$ 的最大特征值，$\\lambda_1$ 是绝对值第二大的特征值。沿传递方向的相关长度 $\\xi$（以行间晶格间距为单位）定义为\n$$\n\\xi=\\frac{1}{\\ln\\!\\left(\\frac{\\lambda_0}{|\\lambda_1|}\\right)}.\n$$\n构建一个程序，对于下面提供的每个测试用例，精确地按定义构建 $T$，确定如上定义的 $\\lambda_0$ 和 $\\lambda_1$，并返回相应的 $\\xi$。如果 $|\\lambda_1|$ 在数值精度范围内有效为零，则定义 $\\xi=0$。\n\n所有输出都必须以沿传递方向的晶格间距为单位的无量纲量报告。本问题不涉及角度。最终输出必须是单行，包含一个方括号括起来的、所有测试用例的相关长度的逗号分隔列表，每个值四舍五入到 $8$ 位小数，例如 $[\\xi_1,\\xi_2,\\xi_3]$。\n\n使用以下参数值测试套件：\n- 测试用例 A (边界尺寸条带)：$W=1$, $K_v=0.4$, $K_h=0.4$。\n- 测试用例 B (高温各向异性)：$W=3$, $K_v=0.1$, $K_h=0.2$。\n- 测试用例 C (中等宽度条带上的近临界各向同性)：$W=4$, $K_v=0.4$, $K_h=0.4$。\n- 测试用例 D (较宽条带上的低温各向同性)：$W=5$, $K_v=0.7$, $K_h=0.7$。\n\n您的程序应生成单行输出，其中包含方括号括起来的结果（例如 $[\\text{result}_A,\\text{result}_B,\\text{result}_C,\\text{result}_D]$），结果为逗号分隔列表，每个条目四舍五入到 $8$ 位小数。每个结果都必须是浮点数。", "solution": "所述问题是有效的。它在科学上基于统计力学的原理，特别是二维伊辛模型的传递矩阵表述。定义和参数是完整的、数学上一致且适定的，允许唯一且稳定的数值解。没有矛盾、歧义或事实不准确之处。我将继续提供完整解法。\n\n该问题要求计算在有限宽度条带上的铁磁二维伊辛模型的相关长度 $\\xi$。完成此任务的基本理论工具是传递矩阵方法。对于一个宽度为 $W$、长度为 $N$ 的晶格系统，配分函数 $Z$ 可以表示为行间传递矩阵 $T$ 的 $N$ 次方的迹：$Z = \\text{Tr}(T^N)$。在条带长度 $N \\to \\infty$ 的热力学极限下，系统的物理性质由传递矩阵 $T$ 的最大特征值 $\\lambda_0$ 主导。\n\n相关长度 $\\xi$ 表征了自旋-自旋关联函数随距离的指数衰减。沿传递方向，这种衰减由最大特征值 $\\lambda_0$ 与绝对值第二大的特征值（我们记为 $\\lambda_1$）之比决定。以行间晶格间距为单位测量的相关长度由以下公式给出：\n$$\n\\xi = \\frac{1}{\\ln\\left(\\frac{\\lambda_0}{|\\lambda_1|}\\right)}\n$$\n我们的任务是根据给定的参数构建矩阵 $T$，计算其特征值，并使用此公式求出 $\\xi$。\n\n传递矩阵 $T$ 作用于由单行所有可能的自旋构型张成的向量空间上。对于宽度为 $W$ 的条带，行构型是一个向量 $\\boldsymbol{s} = (s_1, s_2, \\dots, s_W)$，其中每个自旋 $s_i \\in \\{-1, +1\\}$。此类构型的总数为 $2^W$，因此 $T$ 是一个 $2^W \\times 2^W$ 的矩阵。该矩阵的索引对应于行构型。\n\n矩阵元 $T_{\\boldsymbol{s},\\boldsymbol{s}'}$ 连接一行中的构型 $\\boldsymbol{s}$ 与下一行中的构型 $\\boldsymbol{s}'$。问题为此矩阵元提供了一个对称定义：\n$$\nT_{\\boldsymbol{s},\\boldsymbol{s}'} = \\exp\\left(K_v\\,\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}') + \\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}) + \\frac{K_h}{2}\\,\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}')\\right)\n$$\n其中 $K_v$ 和 $K_h$ 分别是垂直和水平耦合常数。指数中的各项代表相互作用能：\n1.  $\\mathcal{V}(\\boldsymbol{s},\\boldsymbol{s}') = \\sum_{i=1}^{W} s_i s_i'$ 是构型为 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$ 的相邻两行之间的相互作用能。\n2.  $\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}) = \\sum_{i=1}^{W} s_i s_{i+1}$（具有周期性边界条件 $s_{W+1} \\equiv s_1$）是构型为 $\\boldsymbol{s}$ 的行内的相互作用能。该项在两个构型 $\\boldsymbol{s}$ 和 $\\boldsymbol{s}'$ 之间的对称分裂确保了最终得到的矩阵 $T$ 是对称的（$T_{\\boldsymbol{s},\\boldsymbol{s}'} = T_{\\boldsymbol{s}',\\boldsymbol{s}}$）。\n\n算法流程如下：\n1.  **生成状态空间**：对于给定的宽度 $W$，我们首先枚举所有 $2^W$ 种可能的自旋构型。这可以通过将其二进制表示映射到唯一的自旋向量来完成，即将整数 $k$（从 $0$ 到 $2^W-1$）映射到自旋向量。例如，一个整数的比特位 $b_i \\in \\{0, 1\\}$ 可以通过诸如 $s_i = 1 - 2b_i$ 的变换映射到自旋 $s_i \\in \\{+1, -1\\}$。这些构型存储在一个大小为 $2^W \\times W$ 的矩阵中。\n\n2.  **构建传递矩阵 $T$**：我们构建 $2^W \\times 2^W$ 的矩阵 $T$。为了提高计算效率，此过程适合向量化。\n    - 对所有 $2^W$ 种构型，预先计算行内相互作用能 $\\mathcal{H}_{\\text{row}}(\\boldsymbol{s})$。\n    - 所有行间能量组成的矩阵，其元素为 $\\mathcal{V}_{ij} = \\mathcal{V}(\\boldsymbol{s}^{(i)}, \\boldsymbol{s}^{(j)})$，可以通过构型矩阵与其转置的矩阵乘积来计算。\n    - 行内能量之和的矩阵，其元素为 $(\\mathcal{H}_{\\text{row}}(\\boldsymbol{s}^{(i)}) + \\mathcal{H}_{\\text{row}}(\\boldsymbol{s}^{(j)}))$，是通过对预先计算的能量向量使用广播操作形成的。\n    - 最后，根据定义，使用指数函数逐元素计算 $T$ 的元素。\n\n3.  **求解特征值问题**：由于 $T$ 是一个实对称矩阵，其所有特征值都是实数。我们使用为对称矩阵优化的标准数值特征值求解器来找到完整的谱。这些求解器通常返回按升序排列的特征值。对于任何实数耦合 $K_v, K_h$，$T$ 的元素都严格为正，因此根据 Perron-Frobenius 定理，存在一个唯一的最大特征值 $\\lambda_0$，它是正的且重数为一。\n\n4.  **计算相关长度**：\n    - 最大特征值 $\\lambda_0$ 是排序后的特征值数组的最后一个元素。\n    - 为了找到绝对值第二大的特征值 $|\\lambda_1|$，我们确定所有其他特征值绝对值的最大值。\n    - 然后使用公式 $\\xi = 1/\\ln(\\lambda_0/|\\lambda_1|)$ 计算相关长度 $\\xi$。根据问题规定，如果 $|\\lambda_1|$ 在数值上为零（在机器精度内），我们定义 $\\xi=0$。\n\n这个过程是确定性的，并为所定义的有限宽度系统提供了精确的相关长度。该实现将把此方法应用于每个指定的测试用例。", "answer": "```python\nimport numpy as np\n\ndef calculate_xi(W, K_v, K_h):\n    \"\"\"\n    Calculates the correlation length for the 2D Ising model on a strip.\n\n    Args:\n        W (int): The width of the strip.\n        K_v (float): The dimensionless vertical coupling.\n        K_h (float): The dimensionless horizontal coupling.\n\n    Returns:\n        float: The calculated correlation length xi.\n    \"\"\"\n    num_configs = 1  W\n\n    # Step 1: Generate all 2^W spin configurations.\n    # We map integers 0 to 2^W-1 to spin configurations {-1, +1}^W.\n    # The j-th bit of integer i corresponds to the j-th spin.\n    # We use bit order from MSB to LSB for s_1 to s_W.\n    indices = np.arange(num_configs, dtype=int)\n    bit_positions = np.arange(W - 1, -1, -1)\n    bits = ((indices[:, None]  (1  bit_positions)) > 0).astype(np.int8)\n    configs = 1 - 2 * bits  # Map {0, 1} -> {+1, -1}\n\n    # Step 2: Pre-calculate the horizontal interaction energy H_row for each configuration.\n    # H_row(s) = sum(s_i * s_{i+1}) with periodic s_{W+1}=s_1.\n    # np.roll shifts columns cyclically, implementing the periodic boundary condition.\n    H_values = np.sum(configs * np.roll(configs, -1, axis=1), axis=1)\n\n    # Step 3: Build the transfer matrix T in a vectorized manner.\n    # V_ij = sum(s_i_k * s_j_k), the vertical interaction between rows.\n    # This is equivalent to a matrix multiplication of the configs with its transpose.\n    V = configs @ configs.T\n\n    # H_sum_ij = H_i + H_j\n    # This is constructed using numpy's broadcasting rules.\n    H_sum = H_values[:, None] + H_values[None, :]\n\n    # T_ij = exp(K_v * V_ij + 0.5 * K_h * (H_i + H_j))\n    T = np.exp(K_v * V + 0.5 * K_h * H_sum)\n\n    # Step 4: Find eigenvalues.\n    # T is real and symmetric, so we use np.linalg.eigvalsh for efficiency.\n    # It returns real eigenvalues sorted in ascending order.\n    eigenvalues = np.linalg.eigvalsh(T)\n\n    # Step 5: Identify lambda_0 and the magnitude of lambda_1.\n    # lambda_0 is the largest eigenvalue.\n    lambda_0 = eigenvalues[-1]\n\n    # This case is not strictly necessary for W >= 1, but is good practice.\n    if num_configs  2:\n        return 0.0\n\n    # |lambda_1| is the second-largest eigenvalue in magnitude. We find it by\n    # taking the maximum of the absolute values of all other eigenvalues.\n    other_evals = eigenvalues[:-1]\n    abs_lambda_1 = np.max(np.abs(other_evals))\n\n    # Step 6: Calculate the correlation length xi.\n    # Handle the case where the second largest eigenvalue is numerically zero.\n    if abs_lambda_1  1e-15:\n        return 0.0\n\n    # The ratio must be > 1 for the logarithm to be positive. For a positive\n    # matrix, Perron-Frobenius guarantees lambda_0 > |lambda_k| for all k!=0.\n    ratio = lambda_0 / abs_lambda_1\n    if ratio = 1.0:\n        # This case suggests numerical instability or degeneracy,\n        # which is not expected here. Returning infinity for a critical system.\n        return np.inf\n\n    xi = 1.0 / np.log(ratio)\n\n    return xi\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite of parameters.\n    \"\"\"\n    test_cases = [\n        # (W, K_v, K_h)\n        (1, 0.4, 0.4),  # Test case A\n        (3, 0.1, 0.2),  # Test case B\n        (4, 0.4, 0.4),  # Test case C\n        (5, 0.7, 0.7),  # Test case D\n    ]\n\n    results = []\n    for W, K_v, K_h in test_cases:\n        xi = calculate_xi(W, K_v, K_h)\n        results.append(xi)\n\n    # Format the results to 8 decimal places and print in the required format.\n    formatted_results = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "2384603"}, {"introduction": "对于接近相变点的大尺寸二维系统，即便是传递矩阵法也面临计算挑战，我们通常依赖于像蒙特卡洛这样的数值模拟方法。这个练习模拟了这类研究的关键步骤：如何从有限尺寸系统的模拟数据中提取普适的物理规律。通过应用有限尺寸标度理论，我们将学习如何利用线性回归技术，从模拟数据中精确地提取出描述相变行为的临界指数，这是现代计算统计物理中一项至关重要的技能。", "problem": "您将获得二维伊辛模型在 $L \\times L$ 方形晶格上、零外场下的合成含噪可观测量。您的目标是使用有限尺寸标度分析来估计临界指数 $\\,\\beta\\,$, $\\,\\gamma\\,$ 和 $\\,\\nu\\,$。您的程序必须从基本定义和有限尺寸标度假设出发，实现一种基于原理的分析方法，然后通过对所提供数据进行回归来推断指数。本问题中所有量均为无量纲量，因此无需进行单位转换。\n\n基本原理如下。\n\n- 伊辛哈密顿量为 $\\,\\mathcal{H} = -J \\sum_{\\langle i j \\rangle} s_i s_j - h \\sum_i s_i\\,$, 其中 $\\,s_i \\in \\{-1,+1\\}\\,$, 耦合常数 $\\,J0\\,$, 本问题中磁场 $\\,h=0\\,$。\n- 单位自旋磁化强度为 $\\,m = L^{-2} \\sum_i s_i\\,$。静态磁化率为 $\\,\\chi = L^{2} \\left(\\langle m^2 \\rangle - \\langle m \\rangle^2 \\right)/T\\,$.\n- 具有最近邻相互作用的二维模型具有已知的临界温度 $\\,T_c = \\dfrac{2J}{\\ln(1+\\sqrt{2})}\\,$. 在约化单位制下，取 $\\,J=1\\,$ 和玻尔兹曼常数 $\\,k_B=1\\,$, 我们使用 $\\,T_c = 2/\\ln(1+\\sqrt{2}) \\approx 2.269185314\\,$.\n\n经过充分检验的有限尺寸标度 (FSS) 假设指出，自由能密度的奇异部分具有标度形式 $\\,f_s(t,h,L) = L^{-d} \\mathcal{F}(t L^{1/\\nu}, h L^{y_h})\\,$, 其中 $\\,d=2\\,$ 是空间维度, $\\,t=(T-T_c)/T_c\\,$ 是约化温度, $\\,\\nu\\,$ 是关联长度指数, $\\,y_h\\,$ 是磁场的标度维度。从此假设可推断，在临界点 $\\,t=0\\,$ 处，\n- 磁化强度标度关系为 $\\,\\langle |m| \\rangle \\sim L^{-\\beta/\\nu}\\,$,\n- 磁化率标度关系为 $\\,\\chi \\sim L^{\\gamma/\\nu}\\,$,\n- 由磁化率峰值位置 $\\,T_{\\max}(L)\\,$ 定义的赝临界温度趋近于 $\\,T_c\\,$ 的关系为 $\\,T_{\\max}(L) - T_c \\sim L^{-1/\\nu}\\,$.\n\n您的任务是利用这些标度关系，通过在适当的双对数坐标中拟合直线来估计 $\\,\\beta\\,$, $\\,\\gamma\\,$ 和 $\\,\\nu\\,$。具体来说，对于每个数据集，\n- 拟合 $\\,\\log \\langle |m| \\rangle\\,$ 与 $\\,\\log L\\,$ 的关系，以估计斜率 $\\,s_m \\approx -\\beta/\\nu\\,$,\n- 拟合 $\\,\\log \\chi\\,$ 与 $\\,\\log L\\,$ 的关系，以估计斜率 $\\,s_\\chi \\approx \\gamma/\\nu\\,$,\n- 拟合 $\\,\\log\\!\\left(T_{\\max}(L)-T_c\\right)\\,$ 与 $\\,\\log L\\,$ 的关系，以估计斜率 $\\,s_t \\approx -1/\\nu\\,$,\n然后组合结果以获得 $\\,\\nu \\approx -1/s_t\\,$, $\\,\\beta \\approx (-s_m)\\,\\nu\\,$ 和 $\\,\\gamma \\approx (s_\\chi)\\,\\nu\\,$。\n\n对这三个拟合使用普通最小二乘法处理对数值。不要假定任何关于精确指数值的先验知识；从数据中推断它们。\n\n测试套件。以下三个数据集模拟了通过马尔可夫链蒙特卡洛 (MCMC) 方法在临界点附近产生的测量结果，其中包含轻微的标度修正。在所有 $\\,T_{\\max}(L)-T_c\\,$ 的计算中，请精确使用下面给出的 $\\,T_c = 2.269185314\\,$。\n\n数据集 A:\n- $\\,L = [8,12,16,24,32,48,64]\\,$\n- $\\,\\langle |m| \\rangle = [0.806300,\\,0.742300,\\,0.706000,\\,0.660900,\\,0.631600,\\,0.595200,\\,0.572000]\\,$\n- $\\,\\chi = [32.300,\\,64.360,\\,105.430,\\,212.330,\\,350.690,\\,707.700,\\,1167.590]\\,$\n- $\\,T_{\\max}(L) = [2.387310314,\\,2.346685314,\\,2.326841314,\\,2.307310314,\\,2.297661914,\\,2.288091314,\\,2.283335714]\\,$\n\n数据集 B:\n- $\\,L = [10,14,20,28,40,56,80]\\,$\n- $\\,\\langle |m| \\rangle = [0.937100,\\,0.864300,\\,0.801600,\\,0.750100,\\,0.703600,\\,0.665300,\\,0.627800]\\,$\n- $\\,\\chi = [45.840,\\,84.620,\\,160.970,\\,293.370,\\,555.000,\\,1003.200,\\,1891.000]\\,$\n- $\\,T_{\\max}(L) = [2.384415314,\\,2.350605314,\\,2.325688314,\\,2.309288314,\\,2.297116314,\\,2.289062314,\\,2.283059314]\\,$\n\n数据集 C:\n- $\\,L = [6,8,10,12,14]\\,$\n- $\\,\\langle |m| \\rangle = [0.904500,\\,0.828700,\\,0.778300,\\,0.743600,\\,0.716900]\\,$\n- $\\,\\chi = [18.790,\\,29.925,\\,43.343,\\,58.709,\\,76.010]\\,$\n- $\\,T_{\\max}(L) = [2.420296314,\\,2.379185314,\\,2.355585314,\\,2.340296314,\\,2.329838314]\\,$\n\n要求：\n- 对每个数据集使用自然对数实现三个独立的最小二乘拟合。\n- 从 $\\,T_{\\max}(L)\\,$ 位移拟合中计算 $\\,\\nu\\,$, 然后利用 $\\,\\beta/\\nu\\,$ 和 $\\,\\gamma/\\nu\\,$ 的估计值，从磁化强度和磁化率拟合中计算 $\\,\\beta\\,$ 和 $\\,\\gamma\\,$。\n- 对于每个数据集，返回一个列表 $\\,[\\beta, \\gamma, \\nu]\\,$, 其中每个值都使用标准四舍五入到三位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含三个数据集的结果，格式为一个由逗号分隔的三个列表组成的列表，并用方括号括起来，例如 $\\,[[\\beta_A,\\gamma_A,\\nu_A],[\\beta_B,\\gamma_B,\\nu_B],[\\beta_C,\\gamma_C,\\nu_C]]\\,$。不应打印任何附加文本。\n\n您的解决方案必须是一个完整的、可运行的程序，不读取任何输入，并精确使用上述数据。唯一允许的库是 Python 标准库、NumPy 和 SciPy。", "solution": "所提出的问题是计算统计物理学中的一个标准练习。其目标是利用有限尺寸标度的原理，从合成的数值数据中估计二维伊辛模型的临界指数 $\\beta$、$\\gamma$ 和 $\\nu$。该问题定义明确、科学上合理且内部一致。我们将着手解决。\n\n分析建立在有限尺寸标度 (FSS) 假设之上。对于一个在 $d$ 维空间中线性尺寸为 $L$ 的系统，在临界点附近，自由能密度的奇异部分（记为 $f_s$）被假定具有以下标度形式：\n$$f_s(t, h, L) = L^{-d} \\mathcal{F}(t L^{1/\\nu}, h L^{y_h})$$\n此处, $t = (T-T_c)/T_c$ 是约化温度, $h$ 是外磁场, $\\nu$ 是关联长度临界指数, $y_h$ 是磁场的标度维度。在本问题中，空间维度为 $d=2$。分析在临界温度（即 $t=0$）和零外场（$h=0$）下进行。\n\n从 FSS 假设可以推导出各种热力学量的标度关系。问题正确地提供了在临界点处可观测量的必要关系：\n1.  单位自旋的平均绝对磁化强度 $\\langle |m| \\rangle$ 随系统尺寸 $L$ 的标度关系为：\n    $$\\langle |m| \\rangle \\propto L^{-\\beta/\\nu}$$\n    其中 $\\beta$ 是磁化强度临界指数。\n2.  磁化率 $\\chi$ 的标度关系为：\n    $$\\chi \\propto L^{\\gamma/\\nu}$$\n    其中 $\\gamma$ 是磁化率临界指数。\n3.  对于有限尺寸系统，磁化率峰值的位置 $T_{\\max}(L)$ 在热力学极限下（$L \\to \\infty$）根据以下关系趋近于真实临界温度 $T_c$：\n    $$T_{\\max}(L) - T_c \\propto L^{-1/\\nu}$$\n这些幂律依赖关系构成了我们估算程序的基础。\n\n为了从所提供的数据中确定指数，我们通过对两边取自然对数，将这些幂律关系转换为线性方程：\n1.  $\\ln(\\langle |m| \\rangle) = C_m - (\\beta/\\nu) \\ln L$\n2.  $\\ln(\\chi) = C_\\chi + (\\gamma/\\nu) \\ln L$\n3.  $\\ln(T_{\\max}(L) - T_c) = C_t - (1/\\nu) \\ln L$\n这里, $C_m$, $C_\\chi$ 和 $C_t$ 是常数。这些方程中的每一个都具有线性形式 $y = c + s \\cdot x$, 其中自变量是 $x = \\ln L$, 因变量 $y$ 是相应可观测量值的对数。这些直线的斜率与临界指数直接相关：$s_m = -\\beta/\\nu$、 $s_\\chi = \\gamma/\\nu$ 和 $s_t = -1/\\nu$。这些斜率可以通过普通最小二乘 (OLS) 线性回归进行数值确定。\n\n对三个数据集中的每一个执行的计算过程如下：\na.  对于给定数据集中的每个晶格尺寸 $L_i$, 所有回归的自变量都准备为 $x_i = \\ln(L_i)$。\nb.  计算回归的因变量： $y_{m,i} = \\ln(\\langle |m| \\rangle_i)$, $y_{\\chi,i} = \\ln(\\chi_i)$, 和 $y_{t,i} = \\ln(T_{\\max}(L)_i - T_c)$。在计算 $y_{t,i}$ 时，使用所提供的临界温度值 $T_c = 2.269185314$。\nc.  执行三个独立的 OLS 回归以找到最佳拟合斜率：\n    -   通过 $y_m$ 对 $x$ 的回归获得 $s_m$。\n    -   通过 $y_\\chi$ 对 $x$ 的回归获得 $s_\\chi$。\n    -   通过 $y_t$ 对 $x$ 的回归获得 $s_t$。\nd.  然后使用指定的相互关系，从这些估计的斜率计算临界指数：\n    -   $\\nu = -1 / s_t$\n    -   $\\beta = -s_m \\cdot \\nu$\n    -   $\\gamma = s_\\chi \\cdot \\nu$\ne.  最后，按要求将计算出的 $\\beta$, $\\gamma$ 和 $\\nu$ 的值四舍五入到三位小数。整个过程在附带的程序中系统地实现。二维伊辛模型的已知精确值为 $\\beta = 1/8=0.125$, $\\gamma = 7/4=1.75$, 和 $\\nu=1$。从包含噪声和标度修正的所提供数据中得到的结果，预计将是这些理论值的近似值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Estimates the critical exponents beta, gamma, and nu for the 2D Ising model\n    using finite-size scaling analysis on three provided datasets.\n    \"\"\"\n    \n    # Define the critical temperature T_c as given in the problem statement.\n    T_c = 2.269185314\n\n    # The three datasets provided in the problem statement.\n    datasets = [\n        # Dataset A\n        {\n            \"L\": np.array([8, 12, 16, 24, 32, 48, 64]),\n            \"m_abs\": np.array([0.806300, 0.742300, 0.706000, 0.660900, 0.631600, 0.595200, 0.572000]),\n            \"chi\": np.array([32.300, 64.360, 105.430, 212.330, 350.690, 707.700, 1167.590]),\n            \"T_max\": np.array([2.387310314, 2.346685314, 2.326841314, 2.307310314, 2.297661914, 2.288091314, 2.283335714])\n        },\n        # Dataset B\n        {\n            \"L\": np.array([10, 14, 20, 28, 40, 56, 80]),\n            \"m_abs\": np.array([0.937100, 0.864300, 0.801600, 0.750100, 0.703600, 0.665300, 0.627800]),\n            \"chi\": np.array([45.840, 84.620, 160.970, 293.370, 555.000, 1003.200, 1891.000]),\n            \"T_max\": np.array([2.384415314, 2.350605314, 2.325688314, 2.309288314, 2.297116314, 2.289062314, 2.283059314])\n        },\n        # Dataset C\n        {\n            \"L\": np.array([6, 8, 10, 12, 14]),\n            \"m_abs\": np.array([0.904500, 0.828700, 0.778300, 0.743600, 0.716900]),\n            \"chi\": np.array([18.790, 29.925, 43.343, 58.709, 76.010]),\n            \"T_max\": np.array([2.420296314, 2.379185314, 2.355585314, 2.340296314, 2.329838314])\n        }\n    ]\n\n    all_results = []\n\n    for data in datasets:\n        # Prepare the variables for linear regression by taking natural logarithms.\n        log_L = np.log(data[\"L\"])\n        \n        # 1. Magnetization fit: log(|m|>) = C_m - (beta/nu) * log(L)\n        log_m = np.log(data[\"m_abs\"])\n        # Perform OLS regression to find the slope s_m = -beta/nu\n        s_m = stats.linregress(log_L, log_m).slope\n        \n        # 2. Susceptibility fit: log(chi) = C_chi + (gamma/nu) * log(L)\n        log_chi = np.log(data[\"chi\"])\n        # Perform OLS regression to find the slope s_chi = gamma/nu\n        s_chi = stats.linregress(log_L, log_chi).slope\n        \n        # 3. T_max shift fit: log(T_max(L) - T_c) = C_t - (1/nu) * log(L)\n        log_T_shift = np.log(data[\"T_max\"] - T_c)\n        # Perform OLS regression to find the slope s_t = -1/nu\n        s_t = stats.linregress(log_L, log_T_shift).slope\n        \n        # Calculate the critical exponents from the slopes.\n        nu = -1.0 / s_t\n        beta = -s_m * nu\n        gamma = s_chi * nu\n        \n        # Round the results to three decimal places.\n        beta_rounded = round(beta, 3)\n        gamma_rounded = round(gamma, 3)\n        nu_rounded = round(nu, 3)\n        \n        # Store the list of exponents for the current dataset.\n        all_results.append([beta_rounded, gamma_rounded, nu_rounded])\n        \n    # Format the final output according to the problem specification.\n    # The string representation of a list of lists is converted to a compact\n    # format by removing all space characters.\n    final_output_string = str(all_results).replace(\" \", \"\")\n    print(final_output_string)\n\nsolve()\n```", "id": "2448171"}]}