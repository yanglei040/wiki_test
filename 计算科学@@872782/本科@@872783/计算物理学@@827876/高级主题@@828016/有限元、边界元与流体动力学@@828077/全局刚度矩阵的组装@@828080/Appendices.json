{"hands_on_practices": [{"introduction": "有限元方法的核心在于“组装”过程，即将各个单元的物理贡献累加到全局系统中。本练习旨在剥离编程的复杂性，让您专注于最基本的簿记任务：如何将局部单元矩阵的贡献正确地映射并累加到全局刚度矩阵中。通过特意打乱的节点编号，本练习将考验您对这一映射逻辑的理解，该逻辑独立于节点的标记方式。[@problem_id:2393853]", "problem": "考虑一个稳态一维热传导问题，研究对象是一根具有恒定热导率 $k$ 和恒定横截面积 $A$ 的直棱杆。杆内没有内部热源。使用标准伽辽金有限元法，将该杆离散化为包含5个全局节点的4个单元，其中采用线性拉格朗日形函数。全局节点标识符及其沿杆的位置如下：\n- 节点 $42$：$x=0.00 \\ \\mathrm{m}$\n- 节点 $7$：$x=0.35 \\ \\mathrm{m}$\n- 节点 $13$：$x=0.50 \\ \\mathrm{m}$\n- 节点 $5$：$x=0.90 \\ \\mathrm{m}$\n- 节点 $21$：$x=1.20 \\ \\mathrm{m}$\n\n单元连接关系被故意打乱，由以下双节点单元列表给出（（第一节点，第二节点））：\n- 单元 $17$：$(42,7)$\n- 单元 $100$：$(13,7)$\n- 单元 $9$：$(13,5)$\n- 单元 $23$：$(21,5)$\n\n组装无约束系统（即施加任何边界条件之前）的全局刚度矩阵。全局刚度矩阵的行和列应按照节点标识符序列 $(5, \\ 42, \\ 13, \\ 21, \\ 7)$ 进行排序。\n\n材料和几何属性如下：\n- 热导率 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$\n- 横截面积 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$\n\n与全局节点标识符 $13$ 相关联的组装后全局刚度矩阵的对角线元素的值是多少？答案以 $\\mathrm{W \\, K^{-1}}$ 为单位，并四舍五入到4位有效数字。", "solution": "对于无内部热源、具有恒定热导率 $k$ 和恒定横截面积 $A$ 的直棱杆，其稳态一维热传导的控制微分方程为\n$$\n-\\frac{\\mathrm{d}}{\\mathrm{d}x}\\!\\left(k A \\, \\frac{\\mathrm{d}T}{\\mathrm{d}x}\\right) \\,=\\, 0.\n$$\n对于长度为 $L_{e}$ 的双节点单元，使用标准伽辽金有限元法和线性拉格朗日形函数，可得到单元刚度矩阵\n$$\n\\mathbf{K}^{(e)} \\,=\\, \\int_{0}^{L_{e}} k A \\, \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right)^{\\!\\top} \\left(\\frac{\\mathrm{d}\\mathbf{N}}{\\mathrm{d}x}\\right) \\, \\mathrm{d}x,\n$$\n其中 $\\mathbf{N} = \\begin{bmatrix} N_{1}  N_{2} \\end{bmatrix}$ 是线性形函数。对于线性双节点单元，其导数在单元上是常数，$\\frac{\\mathrm{d}N_{1}}{\\mathrm{d}x} = -\\frac{1}{L_{e}}$ 和 $\\frac{\\mathrm{d}N_{2}}{\\mathrm{d}x} = \\frac{1}{L_{e}}$，因此\n$$\n\\mathbf{K}^{(e)} \\,=\\, k A \\int_{0}^{L_{e}} \n\\begin{bmatrix}\n\\frac{1}{L_{e}^{2}}  -\\frac{1}{L_{e}^{2}} \\\\\n-\\frac{1}{L_{e}^{2}}  \\frac{1}{L_{e}^{2}}\n\\end{bmatrix}\n\\mathrm{d}x\n\\,=\\, \\frac{k A}{L_{e}} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n$$\n\n因此，每个单元对其两个节点相关联的对角线元素贡献 $\\frac{k A}{L_{e}}$，对相应的非对角耦合项贡献 $-\\frac{k A}{L_{e}}$。与特定全局节点相关联的全局刚度矩阵的对角线元素是所有与该节点相连接的单元的对角贡献之和。\n\n我们首先根据给定的节点坐标计算单元长度：\n- 单元 $17$ 连接节点 $(42, 7)$，其坐标分别为 $x=0.00 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{17} = |0.35 - 0.00| = 0.35 \\ \\mathrm{m}$。\n- 单元 $100$ 连接节点 $(13, 7)$，其坐标分别为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.35 \\ \\mathrm{m}$，因此 $L_{100} = |0.50 - 0.35| = 0.15 \\ \\mathrm{m}$。\n- 单元 $9$ 连接节点 $(13, 5)$，其坐标分别为 $x=0.50 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{9} = |0.90 - 0.50| = 0.40 \\ \\mathrm{m}$。\n- 单元 $23$ 连接节点 $(21, 5)$，其坐标分别为 $x=1.20 \\ \\mathrm{m}$ 和 $x=0.90 \\ \\mathrm{m}$，因此 $L_{23} = |1.20 - 0.90| = 0.30 \\ \\mathrm{m}$。\n\n全局节点 $13$ 与单元 $100$ 和单元 $9$ 相连接。因此，与节点 $13$ 相关联的全局刚度矩阵的对角线元素为\n$$\nK_{(13,13)} \\,=\\, \\frac{k A}{L_{100}} \\,+\\, \\frac{k A}{L_{9}}.\n$$\n\n代入给定的材料和几何属性 $k = 180 \\ \\mathrm{W \\, m^{-1} \\, K^{-1}}$ 和 $A = 2.0 \\times 10^{-3} \\ \\mathrm{m^{2}}$：\n$$\nk A \\,=\\, 180 \\times \\left(2.0 \\times 10^{-3}\\right) \\,=\\, 0.36 \\ \\mathrm{W \\, K^{-1}}.\n$$\n因此，\n$$\nK_{(13,13)} \\,=\\, 0.36 \\left(\\frac{1}{0.15} + \\frac{1}{0.40}\\right) \\ \\mathrm{W \\, K^{-1}}.\n$$\n计算长度的倒数：\n$$\n\\frac{1}{0.15} \\,=\\, \\frac{100}{15} \\,=\\, \\frac{20}{3} \\,=\\, 6.\\overline{6}, \n\\qquad\n\\frac{1}{0.40} \\,=\\, \\frac{10}{4} \\,=\\, \\frac{5}{2} \\,=\\, 2.5.\n$$\n因此，\n$$\nK_{(13,13)} \\,=\\, 0.36 \\left( \\frac{20}{3} + \\frac{5}{2} \\right) \\ \\mathrm{W \\, K^{-1}}\n\\,=\\, 0.36 \\left( \\frac{40}{6} + \\frac{15}{6} \\right) \\ \\mathrm{W \\, K^{-1}}\n\\,=\\, 0.36 \\left( \\frac{55}{6} \\right) \\ \\mathrm{W \\, K^{-1}}.\n$$\n计算乘积：\n$$\n0.36 \\left( \\frac{55}{6} \\right)\n\\,=\\, \\frac{0.36 \\times 55}{6}\n\\,=\\, \\frac{19.8}{6}\n\\,=\\, 3.3.\n$$\n\n因此，与全局节点 $13$ 相关联的对角线元素为\n$$\nK_{(13,13)} \\,=\\, 3.3 \\ \\mathrm{W \\, K^{-1}}.\n$$\n按要求四舍五入到4位有效数字，得到 $3.300 \\ \\mathrm{W \\, K^{-1}}$。", "answer": "$$\\boxed{3.300}$$", "id": "2393853"}, {"introduction": "在掌握了手动计算之后，我们转向一个更真实的编程场景。实际工程问题中的刚度矩阵通常是巨大且稀疏的（大部分元素为零），因此将其存储为稠密矩阵是极其浪费的。本练习将引导您使用压缩稀疏行（CSR）格式——一种高效存储稀疏矩阵的标准方法——来直接实现组装过程，并量化其与稠密存储相比的内存优势。[@problem_id:2374280]", "problem": "你的任务是编写一个程序，使用有限元方法为一维泊松问题组装全局刚度矩阵，将其以压缩稀疏行 (CSR) 格式存储，并将其内存占用与稠密矩阵进行比较。你的程序必须从第一性原理出发实现组装过程，且不得分配稠密矩阵。所有计算均为纯数学和逻辑计算，不涉及物理单位。请使用以下基础框架。\n\n从区间 $[0,L]$ 上的一维泊松方程的强形式开始，两端施加齐次狄利克雷边界条件：\n$$\n- \\frac{d^2 u}{dx^2} = f(x), \\quad x \\in (0,L), \\quad u(0) = 0, \\quad u(L) = 0.\n$$\n在一个包含 $E$ 个单元的均匀网格上，使用标准有限元方法和分段线性基函数。通过乘以一个测试函数并进行分部积分，可以得到单个单元（节点位于 $x_e$ 和 $x_{e+1}$）上的弱形式，从而产生一个涉及每个单元上线性形函数 $N_i$ 的梯度 $\\frac{dN_i}{dx}$ 的表达式。全局刚度矩阵通过根据单元连接关系对局部贡献求和来组装。你的算法必须通过使用单位贡献覆写受约束的行和列来施加齐次狄利克雷边界条件。\n\n你必须使用压缩稀疏行 (CSR) 格式来存储组装好的矩阵。在 CSR 格式中，非零值数组包含 $N_{nz}$ 个浮点数条目，列索引数组包含 $N_{nz}$ 个整数条目，行指针数组包含 $n+1$ 个整数条目，其中 $n$ 是全局自由度的数量。假设使用以下存储模型：\n- 值存储为 $64$ 位浮点数。\n- 列索引和行指针存储为 $32$ 位整数。\n- 内存应以字节为单位报告。\n\n对于稠密矩阵的比较，不要实际分配一个稠密矩阵。而是将其内存计算为 $8 \\times n^2$ 字节，对应一个由 $64$ 位浮点数组成的 $n \\times n$ 数组。对于 CSR 矩阵，将其内存计算为 $8 \\times N_{nz} + 4 \\times N_{nz} + 4 \\times (n+1)$ 字节。\n\n实现以下测试套件。在每种情况下，按照规定以 CSR 格式组装全局刚度矩阵，计算 CSR 内存（字节），按指定公式计算稠密内存（字节），并返回 CSR 内存与稠密内存之比，结果为浮点数，四舍五入至 $6$ 位小数。\n\n- 测试用例 $1$ (正常路径)：一维域，长度 $L = 1$，包含 $E = 5$ 个线性单元，两端施加齐次狄利克雷边界条件。节点数为 $n = E + 1 = 6$。\n- 测试用例 $2$ (边界小系统)：$L = 1$，$E = 1$，两端施加齐次狄利克雷边界条件。节点数为 $n = E + 1 = 2$。\n- 测试用例 $3$ (周期性连接边界)：$L = 1$，包含 $E = 100$ 个单元，施加周期性边界条件，形成环形拓扑。对于此处的周期性边界条件，节点数等于单元数，$n = E = 100$，且单元连接关系是环绕的，因此节点 $n-1$ 会连接回节点 $0$。\n- 测试用例 $4$ (伸缩性)：$L = 1$，$E = 5000$，两端施加齐次狄利克雷边界条件。节点数为 $n = E + 1 = 5001$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如“[r1,r2,r3,r4]”。每个 $r_k$ 必须是测试用例 $k$ 的 CSR 内存与稠密内存之比，四舍五入至 $6$ 位小数。不应打印任何其他文本。\n\n附加实现细节和约束：\n- 直接从带有线性形函数的有限元弱形式组装单元刚度矩阵。使用均匀网格，因此每个单元的长度相同，$h = L / E$。\n- 对于齐次狄利克雷边界条件，通过将相应行和列清零，然后将这些节点处的对角线元素设置为 $1$ 来施加。\n- 对于周期性边界条件，不施加任何狄利克雷约束；而是环绕连接关系，使得单元 $e$ 连接节点 $(e, (e+1) \\bmod n)$，其中 $e \\in \\{0,1,\\dots,E-1\\}$。\n- 测试套件的最终输出必须采用指定的单行格式，每个比率四舍五入至 $6$ 位小数。", "solution": "用户提供的问题陈述已经过评估，并被认为是有效的。它在科学上基于计算物理学的原理，特别是用于求解偏微分方程的有限元方法 (FEM)。该问题是适定的、客观的，并包含了推导唯一解所需的所有必要信息。关于边界条件和内存计算的说明是精确且无歧义的。\n\n任务是为一维泊松方程组装全局刚度矩阵，并比较稀疏表示（压缩稀疏行，CSR）与稠密表示的内存存储需求。分析从第一性原理出发，过程如下。\n\n控制方程的强形式如下：\n$$\n- \\frac{d^2 u}{dx^2} = f(x), \\quad x \\in (0,L), \\quad u(0) = 0, \\quad u(L) = 0\n$$\n为获得弱形式，我们乘以一个满足相同齐次边界条件（即 $v(0)=0, v(L)=0$）的任意测试函数 $v(x)$，并在域 $\\Omega = [0, L]$ 上积分：\n$$\n- \\int_0^L v \\frac{d^2 u}{dx^2} dx = \\int_0^L v f(x) dx\n$$\n对左侧项应用分部积分法得到：\n$$\n\\int_0^L \\frac{dv}{dx} \\frac{du}{dx} dx - \\left[ v \\frac{du}{dx} \\right]_0^L = \\int_0^L v f(x) dx\n$$\n边界项 $\\left[ v \\frac{du}{dx} \\right]_0^L$ 因为测试函数 $v(x)$ 在 $x=0$ 和 $x=L$ 处为零而消失。最终的弱形式是：寻找 $u(x)$，使得对于所有有效的测试函数 $v(x)$，\n$$\n\\int_0^L \\frac{dv}{dx} \\frac{du}{dx} dx = \\int_0^L v f(x) dx\n$$\n\n在有限元方法中，域被离散化为 $E$ 个单元。对于均匀网格，每个单元的长度为 $h = L/E$。在每个单元内，解 $u(x)$ 和测试函数 $v(x)$ 由基函数 $N_i(x)$ 的线性组合来近似。我们使用分段线性的“帽函数”。近似式为 $u_h(x) = \\sum_{j=0}^{n-1} u_j N_j(x)$ 和 $v_h(x) = \\sum_{i=0}^{n-1} v_i N_i(x)$，其中 $n$ 是节点数，$u_j$ 是解的未知节点值。\n\n将这些近似式代入弱形式，得到一个线性方程组 $KU=F$，其中 $K$ 是全局刚度矩阵，$U$ 是未知节点值的向量，$F$ 是载荷向量。刚度矩阵的元素由下式给出：\n$$\nK_{ij} = \\int_0^L \\frac{dN_i}{dx} \\frac{dN_j}{dx} dx\n$$\n这个全局积分是通过对每个单元的贡献求和来计算的。在从 $x_e$ 到 $x_{e+1}$ 的单个单元 $e$ 上，单元刚度矩阵 $K^e$ 是一个 $2 \\times 2$ 的矩阵。在归一化坐标 $\\xi = (x - x_e)/h \\in [0, 1]$ 中，局部基函数为 $N_1^e(\\xi) = 1-\\xi$ 和 $N_2^e(\\xi) = \\xi$。它们关于 $x$ 的导数为 $\\frac{dN_1^e}{dx} = -\\frac{1}{h}$ 和 $\\frac{dN_2^e}{dx} = \\frac{1}{h}$。单元刚度矩阵的元素是：\n$$\nK^e_{ab} = \\int_{x_e}^{x_{e+1}} \\frac{dN_a^e}{dx} \\frac{dN_b^e}{dx} dx = \\int_0^1 \\left(\\frac{dN_a^e}{d\\xi}\\frac{d\\xi}{dx}\\right) \\left(\\frac{dN_b^e}{d\\xi}\\frac{d\\xi}{dx}\\right) h d\\xi\n$$\n由于 $\\frac{d\\xi}{dx} = \\frac{1}{h}$，上式简化为：\n$$\nK^e_{ab} = \\frac{1}{h} \\int_0^1 \\frac{dN_a^e}{d\\xi} \\frac{dN_b^e}{d\\xi} d\\xi\n$$\n为 $a,b \\in \\{1,2\\}$ 计算此式，得到单元刚度矩阵：\n$$\nK^e = \\frac{1}{h} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix}\n$$\n全局刚度矩阵 $K$ 是通过遍历所有单元并将每个 $K^e$ 添加到相应的全局自由度上组装而成的。为避免分配一个完整的 $n \\times n$ 稠密矩阵，我们可以使用字典（或坐标格式，COO）来仅存储非零元素。对于连接全局节点 $i$ 和 $j$ 的每个单元 $e$，$K^e$ 的元素被添加到字典中全局位置 $(i,i), (i,j), (j,i), (j,j)$ 上。\n\n然后施加边界条件。\n对于节点 $i_{bc}$ 处的齐次狄利克雷条件，指定的过程是将矩阵的相应行和列清零，并将对角线元素设置为 $1$。这通过过滤 COO 字典以移除任何满足 $r=i_{bc}$ 或 $c=i_{bc}$ 的条目 $(r, c)$，然后插入值为 $1.0$ 的条目 $(i_{bc}, i_{bc})$ 来实现。\n\n对于具有 $E$ 个单元的域上的周期性边界条件，节点数为 $n=E$。连接关系是环绕的，因此单元 $E-1$ 连接节点 $E-1$ 和节点 $0$。这会在矩阵的角落添加非零项，特别是在 $K_{0, n-1}$ 和 $K_{n-1, 0}$ 处。不应用狄利克雷约束。\n\n在组装和施加边界条件后，我们得到最终的非零元素集。设 $N_{nz}$ 为非零元素的数量，$n$ 为全局自由度的数量。CSR 和稠密格式的内存占用根据问题的存储模型计算：\n- CSR 内存：M_{CSR} = $8 \\times N_{nz}$ (值) + $4 \\times N_{nz}$ (列索引) + $4 \\times (n+1)$ (行指针)\n- 稠密内存：M_{dense} = $8 \\times n^2$\n\n最终结果是比率 $M_{CSR} / M_{dense}$。\n\n这个系统性的、基于原理的过程允许直接构建所需的稀疏矩阵数据，并随后对每个测试用例进行内存分析，而无需实例化任何稠密矩阵。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Main solver function that runs through the test cases,\n    calculates the memory ratio for each, and prints the results.\n    \"\"\"\n\n    def calculate_memory_ratio(L, E, bc_type):\n        \"\"\"\n        Assembles the global stiffness matrix in a sparse format,\n        calculates memory for CSR and dense storage, and returns the ratio.\n\n        Args:\n            L (float): Length of the 1D domain.\n            E (int): Number of elements.\n            bc_type (str): Type of boundary condition ('dirichlet' or 'periodic').\n\n        Returns:\n            float: The ratio of CSR memory to dense memory, rounded to 6 decimal places.\n        \"\"\"\n        h = L / E\n        k_elem = (1.0 / h) * np.array([[1.0, -1.0], [-1.0, 1.0]], dtype=np.float64)\n\n        coo_matrix = defaultdict(float)\n\n        if bc_type == 'dirichlet':\n            n = E + 1\n            # Assemble the full matrix first (conceptually, in COO format)\n            for e in range(E):\n                nodes = (e, e + 1)\n                for i in range(2):\n                    for j in range(2):\n                        row, col = nodes[i], nodes[j]\n                        coo_matrix[(row, col)] += k_elem[i, j]\n\n            # Apply homogeneous Dirichlet boundary conditions\n            final_coo = {}\n            boundary_nodes = {0, n - 1}\n            for (r, c), v in coo_matrix.items():\n                if r not in boundary_nodes and c not in boundary_nodes:\n                    final_coo[(r, c)] = v\n            \n            # Set identity on boundary nodes\n            final_coo[(0, 0)] = 1.0\n            final_coo[(n - 1, n - 1)] = 1.0\n            \n            N_nz = len(final_coo)\n\n        elif bc_type == 'periodic':\n            n = E\n            for e in range(E):\n                nodes = (e, (e + 1) % n)\n                for i in range(2):\n                    for j in range(2):\n                        row, col = nodes[i], nodes[j]\n                        coo_matrix[(row, col)] += k_elem[i, j]\n            \n            N_nz = len(coo_matrix)\n        \n        else:\n            raise ValueError(\"Unknown boundary condition type\")\n\n        # Memory calculation based on the problem specification\n        # Values: 64-bit float (8 bytes)\n        # Indices/Pointers: 32-bit int (4 bytes)\n        csr_memory = 8 * N_nz + 4 * N_nz + 4 * (n + 1)\n        dense_memory = 8 * (n ** 2)\n        \n        if dense_memory == 0:\n            return 0.0\n\n        ratio = csr_memory / dense_memory\n        return round(ratio, 6)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (L, E, bc_type)\n        (1.0, 5, 'dirichlet'),      # Test case 1\n        (1.0, 1, 'dirichlet'),      # Test case 2\n        (1.0, 100, 'periodic'),     # Test case 3\n        (1.0, 5000, 'dirichlet'),   # Test case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        L, E, bc_type = case\n        result = calculate_memory_ratio(L, E, bc_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2374280"}, {"introduction": "学习了组装的逻辑和高效实现后，理解计算机算术的局限性也至关重要。本练习模拟了一个常见于多材料仿真中的场景：连接刚度差异巨大的单元。您将分析有限的浮点数精度如何导致“淹没”误差，使得较柔顺单元的贡献完全丢失，从而影响模型的物理准确性。[@problem_id:2374300]", "problem": "一根一维杆使用有限元法 (FEM) 建模，被离散为两个线性弹簧单元，在一个共享节点处串联。每个双节点单元的局部刚度矩阵为 $k^{(e)} \\in \\mathbb{R}^{2 \\times 2}$，其元素为 $k^{(e)} = \\begin{bmatrix} k_{e}  -k_{e} \\\\ -k_{e}  k_{e} \\end{bmatrix}$，其中 $k_{e} = E_{e}A_{e}/L_{e}$。单元 $\\left(1\\right)$ 的刚度非常大，为 $k_{1} = 10^{12}$，而单元 $\\left(2\\right)$ 的刚度非常小，为 $k_{2} = 10^{-6}$。它们在全局系统中编号为 $2$ 的共享节点处相遇。在全局刚度矩阵 $K \\in \\mathbb{R}^{3 \\times 3}$（节点 $1$–$3$）中，共享节点的对角线元素 $K_{22}$ 是通过对两个单元的贡献求和得到的，这与有限元法的组装规则一致，即全局矩阵的元素是与共享自由度相关的局部贡献之和。\n\n假设组装过程在国际电气与电子工程师协会 (IEEE) $754$ 标准双精度二进制浮点算术中执行，单位舍入误差为 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。令 $\\mathrm{fl}\\!\\left(\\cdot\\right)$ 表示浮点运算的结果，并令在量级 $\\left|x\\right|$ 处的最后一位单位 (ULP) 为 $x$ 附近相邻可表示浮点数之间的距离，其值约为 $2u\\left|x\\right|$；因此，当一个小的加数 $y$ 与一个大得多的数 $x$ 相加时，只要 $\\left|y\\right|  \\tfrac{1}{2}\\mathrm{ULP}\\!\\left(x\\right) \\approx u\\left|x\\right|$，$y$ 就会被舍去。\n\n关于在组装 $K_{22}$ 过程中的数值误差传播及其缓解措施，以下哪些陈述是正确的？\n\nA. 在双精度下计算 $\\mathrm{fl}\\!\\left(k_{1}+k_{2}\\right)$ 时，柔性单元的贡献 $k_{2}$ 因 $k_{2}  \\tfrac{1}{2}\\mathrm{ULP}\\!\\left(k_{1}\\right)$ 而被完全舍去，因此组装后的 $K_{22}$ 在浮点表示中等于 $k_{1}$。\n\nB. 浮点模型 $\\mathrm{fl}\\!\\left(a+b\\right) = \\left(a+b\\right)\\left(1+\\delta\\right)$（其中 $\\left|\\delta\\right| \\le u$）保证了无论 $k_{1}/k_{2}$ 的比值如何，两个贡献都在 $K_{22}$ 中有所体现。\n\nC. 对于这个两项和，颠倒求和顺序（即先加 $k_{2}$ 再加 $k_{1}$）不会改变最终的舍入值；较小的项仍然会因舍入而被消除。\n\nD. 用一个单一的全局常数对矩阵方程进行缩放以使 $k_{1}$ 的量级为 $1$，将同时使 $k_{2}$ 的量级也为 $1$，从而防止 $K_{22}$ 处的舍入损失。\n\nE. 如果每个全局矩阵元素都以更高精度的格式（例如，$p=64$ 位尾数的扩展精度）进行组装和存储，那么对于给定的数值，较小的项 $k_{2}$ 将被保留在 $K_{22}$ 中，因为在该更高精度下，$k_{2}$ 超过了 $k_{1}$ 量级上的舍入阈值。\n\n选择所有适用的选项。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 一根一维杆使用有限元法 (FEM) 建模。\n- 该杆被离散为两个串联的线性弹簧单元。\n- 一个单元的局部刚度矩阵为 $k^{(e)} = \\begin{bmatrix} k_{e}  -k_{e} \\\\ -k_{e}  k_{e} \\end{bmatrix}$。\n- 单元 $\\left(1\\right)$ 的刚度常数为 $k_{1} = 10^{12}$。\n- 单元 $\\left(2\\right)$ 的刚度常数为 $k_{2} = 10^{-6}$。\n- 在一个包含 $3$ 个节点的全局系统中，这两个单元共享节点 $2$。\n- 全局刚度矩阵为 $K \\in \\mathbb{R}^{3 \\times 3}$。\n- 共享节点对角线元素的组装规则是 $K_{22} = (\\text{单元1的贡献}) + (\\text{单元2的贡献})$。根据局部刚度矩阵的定义和标准组装方法，这意味着其精确值为 $K_{22} = k_{1} + k_{2}$。\n- 计算在 IEEE $754$ 双精度浮点算术中执行。\n- 单位舍入误差为 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。\n- 浮点运算由 $\\mathrm{fl}\\!\\left(\\cdot\\right)$ 表示。\n- 当一个加数 $y$ 与一个大得多的数 $x$ 相加时，如果其量级小于 $x$ 的最后一位单位 (ULP) 的一半，即 $\\left|y\\right|  \\tfrac{1}{2}\\mathrm{ULP}\\!\\left(x\\right) \\approx u\\left|x\\right|$，则 $y$ 会丢失。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据**：该问题在数值分析和计算力学中有充分的依据。它描述了一个经典的数值问题，称为“吸收”或“淹没”，发生在有限精度算术中对数量级差异巨大的数进行相加时。这是有限元法软件中一个真实且重要的考虑因素。所提供的浮点加法模型是舍入发生方式的一个标准（尽管简化了）的表示。\n- **适定性**：该问题是适定的。给定的数据和定义的算术模型足以唯一地评估每个陈述的正确性。\n- **客观性**：该问题使用客观、技术性的语言陈述，没有歧义或主观论断。\n\n**步骤 3：结论与行动**\n- **结论**：问题陈述是有效的。它在科学上是合理的、内容自洽且客观。\n- **行动**：继续进行推导和选项评估。\n\n核心任务是分析浮点求和 $\\mathrm{fl}\\!\\left(k_{1} + k_{2}\\right)$，它决定了全局刚度元素 $K_{22}$ 的计算值。其精确值为 $K_{22} = k_{1} + k_{2} = 10^{12} + 10^{-6}$。\n计算在双精度下进行，其中单位舍入误差为 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。根据问题的舍入模型，如果 $k_{2}  u \\cdot k_{1}$，则 $k_{2}$ 的贡献将会丢失。\n\n我们来评估这个条件：\n- 较小的项是 $k_{2} = 10^{-6}$。\n- 较大的项是 $k_{1} = 10^{12}$。\n- 舍入阈值为 $u \\cdot k_{1} \\approx (1.11 \\times 10^{-16}) \\cdot 10^{12} = 1.11 \\times 10^{-4}$。\n- 我们必须将 $k_{2}$ 与此阈值进行比较：$10^{-6}$ 与 $1.11 \\times 10^{-4}$。\n- 显然，$10^{-6}  10^{-4}$，更具体地说，$10^{-6}  1.11 \\times 10^{-4}$。\n满足了吸收条件。在双精度下，对于量级为 $k_{1}$ 的数，项 $k_{2}$ 的量级远小于其最小可表示增量。因此，$\\mathrm{fl}\\!\\left(k_{1} + k_{2}\\right) = k_{1}$。\n\n现在我们评估每个陈述。\n\n**A. 在双精度下计算 $\\mathrm{fl}\\!\\left(k_{1}+k_{2}\\right)$ 时，柔性单元的贡献 $k_{2}$ 因 $k_{2}  \\tfrac{1}{2}\\mathrm{ULP}\\!\\left(k_{1}\\right)$ 而被完全舍去，因此组装后的 $K_{22}$ 在浮点表示中等于 $k_{1}$。**\n我们上面的分析证实了这一点。舍去较小项的条件被给出为 $k_{2}  \\tfrac{1}{2}\\mathrm{ULP}\\!\\left(k_{1}\\right)$，近似为 $k_{2}  u \\cdot k_{1}$。\n我们计算出 $u \\cdot k_{1} \\approx 1.11 \\times 10^{-4}$。\n给定 $k_{2} = 10^{-6}$。\n不等式 $10^{-6}  1.11 \\times 10^{-4}$ 是成立的。\n因此，在浮点加法过程中，来自柔性单元的贡献 $k_{2}$ 被完全吸收。计算机内存中 $K_{22}$ 的最终值将精确地是 $k_{1}$ 的浮点表示。\n**结论：正确。**\n\n**B. 浮点模型 $\\mathrm{fl}\\!\\left(a+b\\right) = \\left(a+b\\right)\\left(1+\\delta\\right)$（其中 $\\left|\\delta\\right| \\le u$）保证了无论 $k_{1}/k_{2}$ 的比值如何，两个贡献都在 $K_{22}$ 中有所体现。**\n该陈述误解了标准浮点误差模型的含义。模型 $\\mathrm{fl}\\!\\left(a+b\\right) = \\left(a+b\\right)\\left(1+\\delta\\right)$ 界定了计算结果相对于真实和的*相对误差*。它并不意味着来自两个原始操作数 $a$ 和 $b$ 的信息在最终结果中被保留。在我们的例子中，$\\mathrm{fl}\\!\\left(k_{1} + k_{2}\\right) = k_{1}$。真实和是 $S = k_{1} + k_{2}$。计算结果是 $\\hat{S} = k_{1}$。\n相对误差为 $\\frac{|\\hat{S} - S|}{|S|} = \\frac{|k_{1} - (k_{1}+k_{2})|}{|k_{1}+k_{2}|} = \\frac{k_{2}}{k_{1}+k_{2}} \\approx \\frac{k_{2}}{k_{1}} = \\frac{10^{-6}}{10^{12}} = 10^{-18}$。\n这个 $10^{-18}$ 的相对误差确实小于单位舍入误差 $u \\approx 1.11 \\times 10^{-16}$。所以，误差模型是满足的。\n然而，结果 $k_{1}$ 不包含关于 $k_{2}$ 的任何信息。$k_{2}$ 的贡献已经丢失。该陈述声称模型“保证了两个贡献都在...中有所体现”是根本错误的。\n**结论：不正确。**\n\n**C. 对于这个两项和，颠倒求和顺序（即先加 $k_{2}$ 再加 $k_{1}$）不会改变最终的舍入值；较小的项仍然会因舍入而被消除。**\n一般来说，浮点加法不满足交换律。对于一系列加法，按不同顺序（例如，从小到大）求和可以产生更精确的结果。然而，对于两个数 $a+b$ 的单次加法，一个标准的浮点单元 (FPU) 将首先比较 $a$ 和 $b$ 的指数来执行该操作。然后它将指数较小的数的尾数向右移动，直到两个指数对齐。然后对尾数进行加法运算。这个过程与 $a$ 和 $b$ 作为操作数提供的顺序无关。FPU 将始终将 $k_{1}$ 识别为量级较大的数，并移动 $k_{2}$ 的尾数。因此，对于一个两项和，$\\mathrm{fl}\\!\\left(k_{1} + k_{2}\\right) = \\mathrm{fl}\\!\\left(k_{2} + k_{1}\\right)$。无论哪种情况，较小的项都会丢失。\n**结论：正确。**\n\n**D. 用一个单一的全局常数对矩阵方程进行缩放以使 $k_{1}$ 的量级为 $1$，将同时使 $k_{2}$ 的量级也为 $1$，从而防止 $K_{22}$ 处的舍入损失。**\n该陈述包含一个逻辑谬误。让我们对刚度项应用一个缩放因子 $\\alpha$。为了使 $k_{1}$ 的量级为 $1$，我们必须选择 $\\alpha \\approx 1/k_{1} = 10^{-12}$。\n现在，我们将这个相同的缩放因子应用于 $k_{2}$：$\\alpha k_{2} \\approx 10^{-12} \\cdot 10^{-6} = 10^{-18}$。这个值远非量级为 $1$。该陈述的前提是错误的。\n此外，缩放并不能解决吸收问题。现在要计算的和是 $\\mathrm{fl}\\!\\left(\\alpha k_{1} + \\alpha k_{2}\\right)$。这两项的比率是 $(\\alpha k_{2}) / (\\alpha k_{1}) = k_{2}/k_{1} = 10^{-18}$。数值量级的比率在缩放下是不变的。新的较小项是 $\\alpha k_{2} \\approx 10^{-18}$。新的较大项是 $\\alpha k_{1} \\approx 1$。现在的吸收阈值是 $u \\cdot (\\alpha k_{1}) \\approx u \\cdot 1 \\approx 1.11 \\times 10^{-16}$。由于 $10^{-18}  1.11 \\times 10^{-16}$，被缩放的较小项仍然会丢失。通过单一因子进行缩放不会改变相对量级，因此无法缓解这种类型的舍入误差。\n**结论：不正确。**\n\n**E. 如果每个全局矩阵元素都以更高精度的格式（例如，$p=64$ 位尾数的扩展精度）进行组装和存储，那么对于给定的数值，较小的项 $k_{2}$ 将被保留在 $K_{22}$ 中，因为在该更高精度下，$k_{2}$ 超过了 $k_{1}$ 量级上的舍入阈值。**\n让我们用提议的更高精度来分析这个问题。一个 $p=64$ 位的尾数意味着单位舍入误差为 $u_{ext} = 2^{-64}$。我们必须计算这个值并再次检查吸收条件。\n我们可以使用对数来近似 $2^{-64}$：\n$\\log_{10}(2^{-64}) = -64 \\log_{10}(2) \\approx -64 \\times 0.30103 = -19.26592$。\n所以，$u_{ext} = 2^{-64} \\approx 10^{-19.266} = 10^{0.734} \\times 10^{-20} \\approx 5.42 \\times 10^{-20}$。\n在 $k_{1}$ 的量级上，新的舍入阈值是 $u_{ext} \\cdot k_{1} \\approx (5.42 \\times 10^{-20}) \\cdot 10^{12} = 5.42 \\times 10^{-8}$。\n吸收的条件是较小的项小于这个阈值。我们将 $k_{2}$ 与这个新阈值进行比较：\n$k_{2} = 10^{-6} = 100 \\times 10^{-8}$。\n比较的是 $100 \\times 10^{-8} > 5.42 \\times 10^{-8}$。这个不等式是错误的。\n由于 $k_{2} > u_{ext} \\cdot k_{1}$，较小的项现在足够大，可以在求和中被记录下来。它的贡献将被保留。增加累加器变量（在这里是元素 $K_{22}$）的精度是缓解这个问题的标准且有效的方法。例如，常用的 80 位扩展精度格式使用 64 位尾数，可以实现这一点。\n**结论：正确。**", "answer": "$$\\boxed{ACE}$$", "id": "2374300"}]}