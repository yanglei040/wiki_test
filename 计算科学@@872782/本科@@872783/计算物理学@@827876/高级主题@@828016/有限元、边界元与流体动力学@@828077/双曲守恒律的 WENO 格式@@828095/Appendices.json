{"hands_on_practices": [{"introduction": "要真正掌握WENO格式，我们必须首先观察其核心机制的实际作用。本练习旨在独立展示其自适应加权过程，演示该格式在遇到间断时如何智能地选择较光滑的子模板，这是其“基本不振荡”特性的关键所在。通过这个练习，您将深入理解WENO格式如何通过非线性权重实现对间断的稳健处理。[@problem_id:2450629]", "problem": "考虑标量双曲守恒律 $u_{t} + f(u)_{x} = 0$，其通量为线性平流 $f(u) = a u$，其中 $a > 0$ 是一个恒定的平流速度。您将分析 Jiang–Shu 五阶加权基本不振荡（WENO）重构中，应用于一个间断初始条件的左偏界面值的非线性权 $\\omega_{k}$ 的行为。目的是确定当网格在间断处加密时，$\\omega_{k}$ 如何作为网格分辨率 $\\Delta x$ 的函数而变化。\n\n您必须使用以下基本设置和假设，这些是在计算物理学中用于双曲守恒律的标准设置：\n- 使用标量平流方程 $u_{t} + a u_{x} = 0$（其中 $a > 0$）和用于界面 $x_{i+\\frac{1}{2}}$ 处状态的左偏五阶 WENO 重构（Jiang–Shu 公式）。\n- 非线性权 $\\omega_{k}$ 是由光滑度指示子计算得出的，这些指示子会惩罚跨越间断的模板，并倾向于局部光滑的模板，其中包含一个微小正参数 $\\varepsilon$ 以避免除零，以及一个指数 $p$ 来控制敏感度。\n- 线性权 $d_{k}$ 的和为 $1$，并且对应于光滑区域中的最优线性五阶格式。\n\n将初始数据定义为黎曼阶跃：\n- $u(x) = 0$ 当 $x < 0$，$u(x) = 1$ 当 $x > 0$，以及 $u(0) = \\tfrac{1}{2}$。\n\n采用由以下方式定义的均匀节点网格：\n- $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，其中 $j \\in \\mathbb{Z}$ 且 $\\Delta x > 0$，因此界面位于任意整数 $m$ 的 $x = m \\Delta x$ 处。\n- 对于每个选定的界面位置 $x = m \\Delta x$，使用五点模板 $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$（其中 $i = m - 1$）在该界面上重构左偏五阶 WENO 值，使得界面为 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x = m \\Delta x$。\n- 假设 $a > 0$，因此应用左偏重构。使用点值 $u_{j} = u(x_{j})$。\n\n为 WENO-JS 权使用标准参数：\n- 线性权 $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$。\n- 微小参数 $\\varepsilon = 10^{-6}$。\n- 指数 $p = 2$。\n\n您的任务：\n- 对于下面指定的每个测试案例，计算指定界面处的非线性权向量 $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$。每个 $\\omega_{k}$ 必须以四舍五入到 $6$ 位小数的浮点数形式返回。\n\n测试套件：\n- 使用以下网格间距 $\\Delta x \\in \\{0.5, 0.25, 0.125\\}$ 和界面偏移 $m \\in \\{-2, 0, 1\\}$。\n- 这将产生如下所列顺序的 $9$ 个测试案例：\n    1. $(\\Delta x, m) = (0.5, -2)$\n    2. $(\\Delta x, m) = (0.25, -2)$\n    3. $(\\Delta x, m) = (0.125, -2)$\n    4. $(\\Delta x, m) = (0.5, 0)$\n    5. $(\\Delta x, m) = (0.25, 0)$\n    6. $(\\Delta x, m) = (0.125, 0)$\n    7. $(\\Delta x, m) = (0.5, 1)$\n    8. $(\\Delta x, m) = (0.25, 1)$\n    9. $(\\Delta x, m) = (0.125, 1)$\n\n实现说明：\n- 将标量场值视为上述定义的间断函数的点采样 $u_{j} = u(x_{j})$。特别地，指定 $u(0) = \\tfrac{1}{2}$ 是为了完整性，但对于这些测试案例，由于 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，没有网格节点恰好位于 $x = 0$。\n- 使用与三个大小为 $3$ 的子模板相关的经典五阶 WENO-JS 光滑度指示子和权重定义。不要引入替代的光滑度指示子或映射权；请使用原始的 Jiang–Shu 形式。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 每个条目必须是对应测试案例的列表 $\\left[\\omega_{0}, \\omega_{1}, \\omega_{2}\\right]$，其中每个权重都四舍五入到 $6$ 位小数。\n- 具体来说，输出应看起来像一个单一的 Python 风格的列表之列表，例如：$[[\\omega_{0}^{(1)},\\omega_{1}^{(1)},\\omega_{2}^{(1)}],[\\omega_{0}^{(2)},\\omega_{1}^{(2)},\\omega_{2}^{(2)}],\\dots,[\\omega_{0}^{(9)},\\omega_{1}^{(9)},\\omega_{2}^{(9)}]]$。\n\n不涉及物理单位；报告纯数字。不使用角度。不使用百分比。最终输出必须是如上所述的恰好一行，不含任何额外文本。", "solution": "我们分析 Jiang–Shu 五阶加权基本无振荡（WENO）格式中，用于线性平流的标量双曲守恒律的非线性权 $\\omega_{k}$。基本基础包括：标量平流方程 $u_{t} + a u_{x} = 0$（其中 $a > 0$，一种双曲守恒律），以及 WENO-JS 非线性权的核心定义，这些权是通过测量子模板上局部变化的光滑度指示子并相应地混合线性权来计算的。\n\n原理与定义：\n- 对于 $a > 0$，左偏重构基于五个节点值 $\\{u_{i-2}, u_{i-1}, u_{i}, u_{i+1}, u_{i+2}\\}$ 提供在界面 $x_{i+\\frac{1}{2}}$ 处的近似。\n- 五阶 WENO-JS 方法在三个子模板 $S_{0} = \\{i-2,i-1,i\\}$, $S_{1} = \\{i-1,i,i+1\\}$, $S_{2} = \\{i,i+1,i+2\\}$ 上构建了三个二次多项式，其相关的线性权为 $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$，和为 $1$。\n- Jiang–Shu 光滑度指示子 $\\beta_{k}$ 通过平方导数的离散近似来量化每个子模板上的局部光滑度。非线性权定义为\n$$\n\\alpha_{k} = \\frac{d_{k}}{(\\varepsilon + \\beta_{k})^{p}}, \\quad \\omega_{k} = \\frac{\\alpha_{k}}{\\alpha_{0} + \\alpha_{1} + \\alpha_{2}},\n$$\n其中 $\\varepsilon = 10^{-6}$ 且 $p = 2$。\n\n网格几何与采样：\n- 节点为 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，因此界面位于整数 $m$ 的 $x = m \\Delta x$ 处，其中 $x_{i+\\frac{1}{2}} = (i+1)\\Delta x$ 对应于 $i = m - 1$。\n- 初始条件是黎曼阶跃 $u(x) = 0$ 当 $x < 0$，$u(x) = 1$ 当 $x > 0$，以及 $u(0) = \\tfrac{1}{2}$。对于所选节点 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$，没有节点恰好位于 $x=0$，因此 $u(0)$ 未被采样。\n\n根据第一性原理分析间断附近的行为：\n- WENO 机制会增加解光滑（$\\beta_{k}$ 小）的子模板的权重 $\\omega_{k}$，并减少跨越间断（$\\beta_{k}$ 大）的子模板的权重。这种行为与确切的通量无关，只要重构方向由 $a$ 的符号确定。\n- 考虑位于 $x=0$ 的界面，对应于 $m = 0$ 和 $i = -1$。涉及的五个节点位于 $x_{-3} = (-2.5)\\Delta x$, $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$。采样值为 $u_{-3} = 0$, $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$。最左边的子模板 $S_{0} = \\{-3,-2,-1\\}$ 完全位于左侧，数据为常数；因此其光滑度指示子满足 $\\beta_{0} = 0$。其他子模板 $S_{1}$ 和 $S_{2}$ 跨越了间断，它们的光滑度指示子是 $O(1)$ 的常数，取决于跳跃幅度，但与 $\\Delta x$ 无关，因为采样值在跳跃处是分段常数。\n- 当 $\\varepsilon$ 固定且非常小时，这导致 $\\alpha_{0} = d_{0}/\\varepsilon^{p}$，与 $\\alpha_{1}$ 和 $\\alpha_{2}$ 相比极大，因此 $\\omega_{0} \\approx 1$，$\\omega_{1} \\approx 0$，$\\omega_{2} \\approx 0$。重要的是，这个结论与 $\\Delta x$ 无关，因为跨越跳跃的模板上的指示子在加密下保持为 $O(1)$，而光滑模板上的指示子对于此采样保持为 $0$。\n- 考虑位于 $x = \\Delta x$ 的界面，对应于 $m = 1$ 和 $i = 0$。五个节点位于 $x_{-2} = (-1.5)\\Delta x$, $x_{-1} = (-0.5)\\Delta x$, $x_{0} = (0.5)\\Delta x$, $x_{1} = (1.5)\\Delta x$, $x_{2} = (2.5)\\Delta x$，采样值为 $u_{-2} = 0$, $u_{-1} = 0$, $u_{0} = 1$, $u_{1} = 1$, $u_{2} = 1$。现在最右边的子模板 $S_{2} = \\{0,1,2\\}$ 完全位于右侧光滑区域；因此 $\\beta_{2} = 0$ 且 $\\omega_{2} \\approx 1$，$\\omega_{0}, \\omega_{1} \\approx 0$，同样与 $\\Delta x$ 无关。\n- 考虑一个完全光滑的左侧区域，在一个远离间断的界面上，例如 $x = -2\\Delta x$，其中 $m = -2$ 和 $i = -3$。五个节点严格位于间断的左侧，因此所有采样值均为 $0$，每个光滑度指示子都满足 $\\beta_{k} = 0$。在这种情况下，非线性权精确地简化为线性权：\n$$\n\\alpha_{k} = \\frac{d_{k}}{\\varepsilon^{p}}, \\quad \\sum_{k=0}^{2} \\alpha_{k} = \\frac{1}{\\varepsilon^{p}} \\sum_{k=0}^{2} d_{k} = \\frac{1}{\\varepsilon^{p}},\n$$\n所以对于 $k \\in \\{0,1,2\\}$，$\\omega_{k} = d_{k}$，同样与 $\\Delta x$ 无关。\n\n因此，对于这种间断初始条件和节点采样，理论预期是：\n- 在 $m = 0$ (间断处的界面)，$\\omega_{0} \\to 1$ 且 $\\omega_{1}, \\omega_{2} \\to 0$，与 $\\Delta x$ 无关。\n- 在 $m = 1$ (右侧一个单元的界面)，$\\omega_{2} \\to 1$ 且 $\\omega_{0}, \\omega_{1} \\to 0$，与 $\\Delta x$ 无关。\n- 在 $m = -2$ (左侧光滑区域内两个单元的界面)，对所有 $k$，$\\omega_{k} = d_{k}$，与 $\\Delta x$ 无关。\n\n用于计算测试套件的算法设计：\n- 对于每个测试案例 $(\\Delta x, m)$，设置 $i = m - 1$。通过使用 $x_{j} = \\left(j + \\tfrac{1}{2}\\right)\\Delta x$ 和定义的分段常数阶跃 $u(x)$ 进行采样，形成五点向量 $\\{u_{i-2},u_{i-1},u_{i},u_{i+1},u_{i+2}\\}$。\n- 使用标准的基于未除差分的离散公式，在子模板 $S_{0},S_{1},S_{2}$ 上计算 Jiang–Shu 光滑度指示子 $(\\beta_{0},\\beta_{1},\\beta_{2})$。这些指示子是非负的，并且在常数数据上精确为零。\n- 使用 $d_{0} = 0.1$, $d_{1} = 0.6$, $d_{2} = 0.3$, $\\varepsilon = 10^{-6}$, $p = 2$ 构建 $\\alpha_{k} = d_{k}/(\\varepsilon + \\beta_{k})^{p}$，然后归一化为 $\\omega_{k} = \\alpha_{k}/\\sum_{j=0}^{2}\\alpha_{j}$。\n- 为了报告，将每个 $\\omega_{k}$ 四舍五入到 $6$ 位小数。\n\n定性结果和数值：\n- 对于 $(\\Delta x, m) = (0.5, -2)$, $(0.25, -2)$, $(0.125, -2)$，所有五个点都位于左侧光滑区域，其中 $u_{j} = 0$，因此在归一化后，$(\\omega_{0},\\omega_{1},\\omega_{2}) = (0.1, 0.6, 0.3)$ 精确成立，所以报告值为 $[0.1, 0.6, 0.3]$。\n- 对于 $(\\Delta x, m) = (0.5, 0)$, $(0.25, 0)$, $(0.125, 0)$，只有最左边的子模板是光滑的；因此 $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (1, 0, 0)$；四舍五入到 $6$ 位小数得到 $[1.0, 0.0, 0.0]$。\n- 对于 $(\\Delta x, m) = (0.5, 1)$, $(0.25, 1)$, $(0.125, 1)$，只有最右边的子模板是光滑的；因此 $(\\omega_{0},\\omega_{1},\\omega_{2}) \\approx (0, 0, 1)$；四舍五入到 $6$ 位小数得到 $[0.0, 0.0, 1.0]$。\n\n这些结果从第一性原理和计算两方面证实，对于给定的节点采样和固定的 $\\varepsilon$，跨越间断时，WENO-JS 非线性权会饱和到那些完全保留在光滑一侧的模板上，并且这种饱和实际上与 $\\Delta x$ 无关。在完全光滑的区域，权重简化为线性权，也与 $\\Delta x$ 无关。", "answer": "```python\nimport numpy as np\n\ndef weno_js_weights(u_im2, u_im1, u_i, u_ip1, u_ip2, eps=1e-6, p=2):\n    \"\"\"\n    Compute WENO-JS (5th order, left-biased) nonlinear weights at an interface\n    using point values u_{i-2},...,u_{i+2}. Returns [omega0, omega1, omega2].\n    \"\"\"\n    # Smoothness indicators (Jiang–Shu) for left-biased reconstruction\n    beta0 = (13.0/12.0)*(u_im2 - 2.0*u_im1 + u_i)**2 + 0.25*(u_im2 - 4.0*u_im1 + 3.0*u_i)**2\n    beta1 = (13.0/12.0)*(u_im1 - 2.0*u_i + u_ip1)**2 + 0.25*(u_im1 - u_ip1)**2\n    beta2 = (13.0/12.0)*(u_i - 2.0*u_ip1 + u_ip2)**2 + 0.25*(3.0*u_i - 4.0*u_ip1 + u_ip2)**2\n\n    d0, d1, d2 = 0.1, 0.6, 0.3\n\n    alpha0 = d0 / (eps + beta0)**p\n    alpha1 = d1 / (eps + beta1)**p\n    alpha2 = d2 / (eps + beta2)**p\n\n    asum = alpha0 + alpha1 + alpha2\n    omega0 = alpha0 / asum\n    omega1 = alpha1 / asum\n    omega2 = alpha2 / asum\n    return [omega0, omega1, omega2]\n\ndef step_ic(x):\n    # u(x) = 0 for x0, 1 for x>0, 0.5 for x==0\n    if x > 0.0:\n        return 1.0\n    elif x  0.0:\n        return 0.0\n    else:\n        return 0.5\n\ndef weights_for_case(dx, m):\n    \"\"\"\n    Nodes: x_j = (j + 0.5) * dx\n    Interface at x = m * dx corresponds to i = m - 1, interface is between i and i+1.\n    Left-biased WENO uses stencil u_{i-2},...,u_{i+2}.\n    \"\"\"\n    i = m - 1\n    # Collect nodal values u_{i-2} ... u_{i+2}\n    us = []\n    for j in range(i-2, i+3):\n        xj = (j + 0.5) * dx\n        us.append(step_ic(xj))\n    omega = weno_js_weights(us[0], us[1], us[2], us[3], us[4])\n    # Round to 6 decimals as required\n    omega = [float(f\"{w:.6f}\") for w in omega]\n    return omega\n\ndef solve():\n    # Define the test cases from the problem statement: 9 cases\n    dxs = [0.5, 0.25, 0.125]\n    ms = [-2, 0, 1]\n    test_cases = []\n    # Order: for each m in [-2,0,1], sweep dxs in order listed to match the problem ordering\n    # The problem lists in blocks: (dx,-2) for all dxs, then (dx,0), then (dx,1).\n    for m in [-2, 0, 1]:\n        for dx in [0.5, 0.25, 0.125]:\n            test_cases.append((dx, m))\n\n    results = []\n    for dx, m in test_cases:\n        omega = weights_for_case(dx, m)\n        results.append(omega)\n\n    # Final print statement: a single line list of lists\n    # Format exactly as a Python-style list of lists with commas.\n    inner = \",\".join(\"[\" + \",\".join(str(v) for v in trip) + \"]\" for trip in results)\n    print(f\"[{inner}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2450629"}, {"introduction": "在理解了空间重构之后，下一步是将其与时间积分格式相结合，以求解含时双曲型偏微分方程。本练习将探讨空间离散（WENO）和时间离散（龙格-库塔方法）之间至关重要的相互作用，重点关注强稳定性保持（SSP）属性。对于捕捉激波的数值格式而言，该属性对于确保稳定性至关重要。[@problem_id:2450643]", "problem": "考虑由无粘性 Burgers 方程给出的一维标量双曲守恒律\n$$\nu_t + \\left(\\tfrac{1}{2}u^2\\right)_x = 0,\n$$\n该方程定义在周期性空间域 $[-1,1]$ 上，初始数据为\n$$\nu(x,0) = \\begin{cases}\n1,  x  0,\\\\\n0,  x \\ge 0.\n\\end{cases}\n$$\n设空间网格是均匀的，有 $N=400$ 个点覆盖 $[-1,1)$，网格间距为 $\\Delta x = 2/N$。使用周期性边界条件。对于空间离散化，使用五阶加权本质无振荡 (WENO, Weighted Essentially Non-Oscillatory) 重构，并结合全局 Lax–Friedrichs 通量分裂，该分裂在当前阶段状态下采用边界 $\\alpha=\\max_i |u_i|$。定义半离散算子 $L(u)$，以在单元节点处使用此 WENO 通量来近似 $- \\partial_x f(u)$，其中 $f(u)=\\tfrac{1}{2}u^2$。使用显式 Runge–Kutta (RK, Runge–Kutta) 方法进行时间推进。考虑以下显式时间积分器：前向欧拉法 (FE)、二阶强稳定性保持 Runge–Kutta (SSPRK2)、三阶强稳定性保持 Runge–Kutta (SSPRK3) 和经典的四阶 Runge–Kutta (RK4)。强稳定性保持 (SSP, Strong-Stability-Preserving) 属性通过离散总变差在时间上的单调性来评估。\n\n将状态 $u\\in\\mathbb{R}^N$ 的离散总变差定义为\n$$\n\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} \\left|u_{i+1}-u_i\\right|,\n$$\n其中使用周期性索引 $u_N \\equiv u_0$。令时间步长在每个完整时间步开始时由 Courant–Friedrichs–Lewy 数 $\\mathrm{CFL}$ 根据下式确定\n$$\n\\Delta t = \\mathrm{CFL}\\,\\frac{\\Delta x}{\\max_i |u_i|},\n$$\n并进行裁剪以不超过到达最终时间 $T$ 的剩余时间。使用固定的最终时间 $T=0.2$。对于每个完整的时间步，按时间顺序记录每个中间 RK 阶段状态和步末状态的 $\\mathrm{TV}$ 值序列。如果在每次比较中，该记录序列在容差 $\\varepsilon=10^{-8}$ 内是单调不增的，则称一次运行为“总变差不增” (nonincreasing-in-$\\mathrm{TV}$)。也就是说，对于记录序列中每对连续的值，后一个值小于或等于前一个值加上 $\\varepsilon$。\n\n实现一个程序，对每个测试用例从 $t=0$ 积分到 $t=T$，并返回一个布尔值，指示所记录的总变差序列是否如上文定义的那样是单调不增的。使用以下测试套件，其中每个测试用例是一个对 $(\\text{方法名称}, \\mathrm{CFL})$，方法名称是字符串 \"FE\"、\"SSPRK2\"、\"SSPRK3\"、\"RK4\" 之一：\n- $($\"SSPRK3\", $0.4)$,\n- $($\"SSPRK2\", $0.8)$,\n- $($\"FE\", $0.4)$,\n- $($\"RK4\", $0.8)$,\n- $($\"RK4\", $0.9)$,\n- $($\"SSPRK3\", $0.9)$,\n- $($\"FE\", $0.9)$.\n\n您的程序应生成单行输出，其中包含按所列顺序排列的测试用例结果，格式为方括号内以逗号分隔的布尔字面量列表，无空格。例如，输出应如下所示\n$$\n[\\text{true},\\text{false},\\dots]\n$$\n尽管实际的布尔值应是您的程序为指定测试套件计算出的值。", "solution": "该问题要求数值求解一维无粘性 Burgers 方程，这是一个标量双曲守恒律的典型例子：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(\\frac{1}{2}u^2\\right) = 0\n$$\n该方程定义在周期性空间域 $x \\in [-1, 1]$ 上，初始数据为阶跃函数：\n$$\nu(x,0) = \\begin{cases} 1,  x  0 \\\\ 0,  x \\ge 0 \\end{cases}\n$$\n我们需要研究几种显式 Runge-Kutta 时间积分格式与高阶空间离散化方法耦合时的总变差 (TV) 稳定性。\n\n首先，在包含 $N=400$ 个单元的均匀网格上使用有限体积法对问题进行空间离散化，网格间距为 $\\Delta x = 2/N$。这产生了一个常微分方程组 (ODEs)：\n$$\n\\frac{du_i}{dt} = -\\frac{1}{\\Delta x}(\\hat{f}_{i+1/2} - \\hat{f}_{i-1/2}) \\equiv L(u)_i\n$$\n其中 $u_i(t)$ 是第 $i$ 个单元中的单元平均解，而 $\\hat{f}_{i+1/2}$ 是单元 $i$ 和 $i+1$ 之间界面上的数值通量。\n\n数值通量 $\\hat{f}_{i+1/2}$ 是通过五阶加权本质无振荡 (WENO) 方法结合全局 Lax-Friedrichs 通量分裂来构造的。通量函数 $f(u) = \\frac{1}{2}u^2$ 被分裂为其正部和负部：\n$$\nf^+(u) = \\frac{1}{2}(f(u) + \\alpha u), \\quad f^-(u) = \\frac{1}{2}(f(u) - \\alpha u)\n$$\n其中 $\\alpha = \\max_i |f'(u_i)| = \\max_i |u_i|$ 是最大特征速度的全局估计。然后，数值通量是这些分裂通量重构后之和：\n$$\n\\hat{f}_{i+1/2} = \\hat{f}^+_{i+1/2} + \\hat{f}^-_{i+1/2}\n$$\n分裂通量分量 $\\hat{f}^+_{i+1/2}$ 是从单元平均值 $\\{f^+(u_j)\\}$ 使用左偏模板重构的，因为其对应的特征速度是非负的。相反，$\\hat{f}^-_{i+1/2}$ 是从 $\\{f^-(u_j)\\}$ 使用右偏模板重构的，因为其特征速度是非正的。这构成了迎风离散格式。\n\n在界面 $x_{i+1/2}$ 处值的五阶 WENO 重构是三个三阶多项式重构的非线性凸组合。对于用于 $\\hat{f}^+_{i+1/2}$ 的左偏情况，其值来源于单元 $\\{i-2, i-1, i\\}$、$\\{i-1, i, i+1\\}$ 和 $\\{i, i+1, i+2\\}$ 上的模板。组合权重（记为 $\\omega_k$）是根据每个模板的光滑度指示子 $\\beta_k$ 计算的。这些指示子衡量了每个模板上重构多项式的振荡程度。对于一组通用值 $\\{v_j\\}$，光滑度指示子由下式给出：\n$$\n\\begin{aligned}\n\\beta_0 = \\frac{13}{12}(v_{i-2} - 2v_{i-1} + v_i)^2 + \\frac{1}{4}(v_{i-2} - 4v_{i-1} + 3v_i)^2 \\\\\n\\beta_1 = \\frac{13}{12}(v_{i-1} - 2v_i + v_{i+1})^2 + \\frac{1}{4}(v_{i-1} - v_{i+1})^2 \\\\\n\\beta_2 = \\frac{13}{12}(v_i - 2v_{i+1} + v_{i+2})^2 + \\frac{1}{4}(3v_i - 4v_{i+1} + v_{i+2})^2\n\\end{aligned}\n$$\n然后，非线性权重为 $\\omega_k = \\gamma_k / (\\beta_k + \\varepsilon)^2$，其中 $\\{\\gamma_k\\} = \\{0.1, 0.6, 0.3\\}$ 是最优线性权重，$\\varepsilon$ 是一个为避免除以零而设置的小参数。归一化后，$\\tilde{\\omega}_k = \\omega_k / \\sum_j \\omega_j$，最终的重构值是 $\\sum_k \\tilde{\\omega}_k p_k$，其中 $p_k$ 是在界面处求值的模板 $k$ 的重构多项式的值。$\\hat{f}^-_{i+1/2}$ 的右偏重构是通过利用该格式在反转数据数组上的对称性来实现的。\n\n得到半离散系统 $\\frac{du}{dt} = L(u)$，使用四种显式 Runge-Kutta 方法之一进行时间积分：\n1.  **前向欧拉法 (FE)：** 一种一阶方法，$u^{n+1} = u^n + \\Delta t L(u^n)$。\n2.  **SSPRK2：** 一种二阶强稳定性保持方法。\n    $$\n    u^{(1)} = u^n + \\Delta t L(u^n) \\\\\n    u^{n+1} = \\frac{1}{2}u^n + \\frac{1}{2}(u^{(1)} + \\Delta t L(u^{(1)}))\n    $$\n3.  **SSPRK3：** 一种三阶强稳定性保持方法。\n    $$\n    u^{(1)} = u^n + \\Delta t L(u^n) \\\\\n    u^{(2)} = \\frac{3}{4}u^n + \\frac{1}{4}(u^{(1)} + \\Delta t L(u^{(1)})) \\\\\n    u^{n+1} = \\frac{1}{3}u^n + \\frac{2}{3}(u^{(2)} + \\Delta t L(u^{(2)}))\n    $$\n4.  **经典 RK4：** 经典的四阶 Runge-Kutta 方法，通常不具有 SSP 特性。\n    $$\n    k_1 = L(u^n) \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad\\space u^{(1)} = u^n + \\frac{\\Delta t}{2} k_1 \\\\\n    k_2 = L(u^{(1)}) \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad u^{(2)} = u^n + \\frac{\\Delta t}{2} k_2 \\\\\n    k_3 = L(u^{(2)}) \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad u^{(3)} = u^n + \\Delta t k_3 \\\\\n    k_4 = L(u^{(3)}) \\quad\\quad\\quad\\quad\\quad\\quad\\quad\\quad u^{n+1} = u^n + \\frac{\\Delta t}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    $$\n时间步长 $\\Delta t$ 由 Courant-Friedrichs-Lewy (CFL) 条件确定：$\\Delta t = \\mathrm{CFL} \\frac{\\Delta x}{\\max_i |u_i|}$。\n\n问题的核心是评估这些格式的“总变差不增” (nonincreasing-in-TV) 属性。离散总变差定义为 $\\mathrm{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$，其中使用周期性索引 $u_N \\equiv u_0$。对于每个完整的时间步，我们必须记录步初、每个中间 RK 阶段以及步末的解的总变差。对于给定的方法和 CFL 数，一次模拟运行被视为“总变差不增”的充要条件是，对于此序列中每对连续的记录值，都有 $TV_{k+1} \\le TV_k + \\varepsilon$ 成立，其中 $\\varepsilon=10^{-8}$ 是一个䂘容差。此检查在每个时间步中都会执行，直到最终时间 $T=0.2$。例如，经典 RK4 的非 SSP 性质可能导致中间阶段的总变差超过前一阶段的总变差，从而违反此条件，尤其是在较大的 CFL 数下。SSP 方法是专门为防止这种行为而设计的，前提是 CFL 数在该方法的 SSP 限制范围内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for the specified test suite.\n    \"\"\"\n    # Problem Constants\n    N = 400\n    DOMAIN_START = -1.0\n    DOMAIN_END = 1.0\n    T_FINAL = 0.2\n    TV_TOLERANCE = 1e-8\n    WENO_EPS = 1e-40\n\n    DX = (DOMAIN_END - DOMAIN_START) / N\n    x = np.linspace(DOMAIN_START, DOMAIN_END, N, endpoint=False)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        (\"SSPRK3\", 0.4),\n        (\"SSPRK2\", 0.8),\n        (\"FE\", 0.4),\n        (\"RK4\", 0.8),\n        (\"RK4\", 0.9),\n        (\"SSPRK3\", 0.9),\n        (\"FE\", 0.9),\n    ]\n\n    # --- WENO5 Implementation ---\n    # Based on the formulation by Jiang and Shu (1996)\n    \n    # Precompute constants for vectorized WENO flux calculation\n    C_p0 = np.array([1./3., -7./6., 11./6.])\n    C_p1 = np.array([-1./6., 5./6., 1./3.])\n    C_p2 = np.array([1./3., 5./6., -1./6.])\n    D_L = np.array([0.1, 0.6, 0.3])\n\n    def weno5_flux_reconstruction(v):\n        \"\"\"\n        Computes the 5th-order left-biased WENO flux reconstruction.\n        This is a vectorized implementation for performance.\n        \"\"\"\n        v_padded = np.pad(v, (3, 3), 'wrap')\n        \n        v_m2 = v_padded[1:-5]\n        v_m1 = v_padded[2:-4]\n        v_0  = v_padded[3:-3]\n        v_p1 = v_padded[4:-2]\n        v_p2 = v_padded[5:-1]\n\n        # Smoothness indicators (beta)\n        beta0 = 13./12. * (v_m2 - 2*v_m1 + v_0)**2 + 0.25 * (v_m2 - 4*v_m1 + 3*v_0)**2\n        beta1 = 13./12. * (v_m1 - 2*v_0 + v_p1)**2 + 0.25 * (v_m1 - v_p1)**2\n        beta2 = 13./12. * (v_0 - 2*v_p1 + v_p2)**2 + 0.25 * (3*v_0 - 4*v_p1 + v_p2)**2\n        \n        # Nonlinear weights (alpha -> omega)\n        alpha0 = D_L[0] / (WENO_EPS + beta0)**2\n        alpha1 = D_L[1] / (WENO_EPS + beta1)**2\n        alpha2 = D_L[2] / (WENO_EPS + beta2)**2\n        sum_alpha = alpha0 + alpha1 + alpha2\n        \n        w0 = alpha0 / sum_alpha\n        w1 = alpha1 / sum_alpha\n        w2 = alpha2 / sum_alpha\n        \n        # Reconstructed fluxes from each sub-stencil\n        p0 = C_p0[0]*v_m2 + C_p0[1]*v_m1 + C_p0[2]*v_0\n        p1 = C_p1[0]*v_m1 + C_p1[1]*v_0  + C_p1[2]*v_p1\n        p2 = C_p2[0]*v_0  + C_p2[1]*v_p1  + C_p2[2]*v_p2\n        \n        return w0*p0 + w1*p1 + w2*p2\n\n    def spatial_operator_L(u):\n        \"\"\"\n        Computes the semi-discrete operator L(u) = -d/dx(f(u)).\n        \"\"\"\n        alpha = np.max(np.abs(u))\n        \n        f = 0.5 * u**2\n        f_plus = 0.5 * (f + alpha * u)\n        f_minus = 0.5 * (f - alpha * u)\n        \n        # Reconstruct positive flux (left-biased)\n        f_hat_plus = weno5_flux_reconstruction(f_plus)\n        \n        # Reconstruct negative flux (right-biased) using symmetry\n        f_minus_rev = f_minus[::-1]\n        f_hat_minus_rev = weno5_flux_reconstruction(f_minus_rev)\n        f_hat_minus = f_hat_minus_rev[::-1]\n        \n        # Total numerical flux at interfaces i+1/2\n        f_hat = f_hat_plus + f_hat_minus\n        \n        # Finite volume difference\n        f_hat_im12 = np.roll(f_hat, 1)\n        \n        return -(f_hat - f_hat_im12) / DX\n\n    def total_variation(u):\n        \"\"\"Computes the total variation of a state vector.\"\"\"\n        return np.sum(np.abs(u - np.roll(u, -1)))\n\n    # --- Time Stepper Implementations ---\n    def step_fe(u, dt, L_op):\n        tv0 = total_variation(u)\n        u_next = u + dt * L_op(u)\n        tv1 = total_variation(u_next)\n        return u_next, [tv0, tv1]\n\n    def step_ssprk2(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u_next = 0.5 * u + 0.5 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2]\n\n    def step_ssprk3(u, dt, L_op):\n        tv0 = total_variation(u)\n        u1 = u + dt * L_op(u)\n        tv1 = total_variation(u1)\n        u2 = 0.75 * u + 0.25 * (u1 + dt * L_op(u1))\n        tv2 = total_variation(u2)\n        u_next = (1./3.) * u + (2./3.) * (u2 + dt * L_op(u2))\n        tv3 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3]\n\n    def step_rk4(u, dt, L_op):\n        tv0 = total_variation(u)\n        k1 = L_op(u)\n        stage1 = u + dt/2. * k1\n        tv1 = total_variation(stage1)\n        k2 = L_op(stage1)\n        stage2 = u + dt/2. * k2\n        tv2 = total_variation(stage2)\n        k3 = L_op(stage2)\n        stage3 = u + dt * k3\n        tv3 = total_variation(stage3)\n        k4 = L_op(stage3)\n        u_next = u + dt/6. * (k1 + 2*k2 + 2*k3 + k4)\n        tv4 = total_variation(u_next)\n        return u_next, [tv0, tv1, tv2, tv3, tv4]\n\n    stepper_map = {\n        \"FE\": step_fe,\n        \"SSPRK2\": step_ssprk2,\n        \"SSPRK3\": step_ssprk3,\n        \"RK4\": step_rk4,\n    }\n\n    results = []\n    for method_name, cfl in test_cases:\n        # Initial condition from problem description: u(x,0) = 1 for x0, 0 for x>=0\n        u = np.where(x  0, 1.0, 0.0)\n        \n        t = 0.0\n        is_tv_nonincreasing = True\n        stepper = stepper_map[method_name]\n\n        while t  T_FINAL:\n            max_u_abs = np.max(np.abs(u))\n            # Prevent division by zero if u is all zero\n            if max_u_abs  1e-12: \n                break \n            \n            dt = cfl * DX / max_u_abs\n            dt = min(dt, T_FINAL - t)\n            \n            u_next, tv_sequence = stepper(u, dt, spatial_operator_L)\n            \n            for i in range(len(tv_sequence) - 1):\n                if tv_sequence[i+1] > tv_sequence[i] + TV_TOLERANCE:\n                    is_tv_nonincreasing = False\n                    break\n            \n            if not is_tv_nonincreasing:\n                break\n                \n            u = u_next\n            t += dt\n            \n        results.append(is_tv_nonincreasing)\n\n    # Format the final output string\n    output_str = f\"[{','.join(map(str, results))}]\".replace(\"True\", \"true\").replace(\"False\", \"false\")\n    print(output_str)\n\n# Run the simulation\nsolve()\n```", "id": "2450643"}, {"introduction": "尽管WENO格式功能强大，但其非线性权重的计算会带来显著的计算成本。这个高级练习将引导您实现一种实用的优化方法：混合格式。该方法在流动的光滑区域使用计算成本较低的线性高阶格式，并仅在需要的地方（即间断附近）选择性地激活完整的WENO格式，从而在保证精度的同时大幅提升计算效率。[@problem_id:2450580]", "problem": "您需要设计并实现一个完整的、可运行的程序，该程序使用混合高阶空间离散化方法求解一维双曲守恒律。该混合方法必须在光滑区域使用计算成本低的线性高阶有限体积法，并且仅在检测到的间断附近切换到五阶加权基本无振荡 (WENO) 格式。控制方程为线性平流方程\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\\quad f(u) = a\\,u,\n$$\n定义在周期性域 $[0,1)$ 上，其中 $a$ 是一个恒定的平流速度。此任务必须基于以下基本原理推导得出：(i) 守恒律定义，(ii) 均匀网格上的有限体积离散化，(iii) 与 $a$ 的符号一致的迎风格式，以及 (iv) 强稳定性保持时间步进。\n\n您的实现必须满足以下要求。\n\n1. 空间离散化和通量：\n- 使用包含 $N$ 个单元的均匀网格，单元中心为 $x_i$（$i=0,\\dots,N-1$），网格宽度 $\\Delta x = 1/N$。应用周期性边界条件。\n- 对单元平均值 $u_i(t)$ 使用有限体积更新，\n$$\n\\frac{d u_i}{d t} = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x},\n$$\n其中 $F_{i+\\frac{1}{2}}$ 是界面 $x_{i+\\frac{1}{2}}$ 上的一个相容的数值通量。\n- 对于 $a0$，使用左侧迎风：$F_{i+\\frac{1}{2}} = a\\,u_{i+\\frac{1}{2}}^{-}$。对于 $a0$，使用右侧迎风：$F_{i+\\frac{1}{2}} = a\\,u_{i+\\frac{1}{2}}^{+}$。这里的 $u_{i+\\frac{1}{2}}^{-}$（左状态）和 $u_{i+\\frac{1}{2}}^{+}$（右状态）是根据相邻单元平均值重构得到的值。\n\n2. 混合重构：\n- 在每个面 $x_{i+\\frac{1}{2}}$ 处，通过一个光滑度传感器来决定使用计算成本低的线性五阶迎风重构还是五阶 WENO 重构。\n- 在单元 $i$ 处定义光滑度传感器为\n$$\nS_i = \\frac{\\left|\\Delta^2 u_i\\right|}{\\left|\\Delta^{+} u_i\\right| + \\left|\\Delta^{-} u_i\\right| + \\varepsilon_s},\n$$\n其中 $\\Delta^{+} u_i = u_{i+1} - u_i$，$\\Delta^{-} u_i = u_i - u_{i-1}$，以及 $\\Delta^2 u_i = u_{i+1} - 2u_i + u_{i-1}$。对 $u_{i\\pm 1}$ 使用周期性索引。\n- 在 $x_{i+\\frac{1}{2}}$ 处定义面传感器为 $S_{i+\\frac{1}{2}} = \\max(S_i, S_{i+1})$。\n- 使用一个阈值 $\\tau = C_{\\tau}\\,\\Delta x$，其中 $C_{\\tau}$ 是一个固定常数。如果 $S_{i+\\frac{1}{2}}  \\tau$，则在该面使用 WENO 重构，否则在该面使用线性五阶迎风重构。\n- 使用一个小的 $\\varepsilon_s$ 以避免传感器中出现除以零的情况；选择一个与网格和时间无关的恒定值。\n\n3. 时间积分：\n- 使用三阶强稳定性保持龙格-库塔格式 (SSP-RK3) 进行时间推进，时间步长 $\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件决定\n$$\n\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{|a|},\n$$\n并调整最后的时间步长，以确保对于每个测试用例，解都能精确地推进到最终时间。\n\n4. 测试套件与输出：\n在下面的三个测试用例上运行您的求解器。在所有情况下，域在 $[0,1)$ 上是周期性的，角度以弧度为单位。不需要进行物理单位转换；将要求的值报告为无量纲实数。\n\n- 测试用例 A（光滑平流精度）：\n  - 参数：$a = 1$, $N = 200$, $\\text{CFL} = 0.45$, $t_{\\text{final}} = 0.25$, $C_{\\tau} = 1$, $\\varepsilon_s = 10^{-12}$。\n  - 初始条件：$u(x,0) = \\sin(2\\pi x)$。\n  - 精确解：$u(x,t) = \\sin(2\\pi(x - a t))$。\n  - 输出：$L^1$ 误差\n    $$\n    E_1 = \\sum_{i=0}^{N-1} |u_i^{\\text{num}}(t_{\\text{final}}) - u_i^{\\text{exact}}(t_{\\text{final}})|\\,\\Delta x.\n    $$\n\n- 测试用例 B（间断附近的混合切换）：\n  - 参数：$a = 1$, $N = 200$, $\\text{CFL} = 0.45$, $t_{\\text{final}} = 0.50$, $C_{\\tau} = 1$, $\\varepsilon_s = 10^{-12}$。\n  - 初始条件：\n    $$\n    u(x,0) = \\chi_{[0.1,\\,0.3)}(x)\\cdot 1 + 0.2\\sin(2\\pi x),\n    $$\n    其中 $\\chi_{[0.1,\\,0.3)}(x)$ 是指示函数，当 $x \\in [0.1,0.3)$ 时（在 $[0,1)$ 上周期性环绕）等于 $1$，否则等于 $0$。\n  - 精确解：$u(x,t) = u_0(\\operatorname{mod}(x - a t, 1))$。\n  - 输出：$L^1$ 误差 $E_2$，其定义与 $E_1$ 类似。\n\n- 测试用例 C（尖锐锋面附近的无振荡特性）：\n  - 参数：$a = 1$, $N = 400$, $\\text{CFL} = 0.45$, $t_{\\text{final}} = 0.30$, $C_{\\tau} = 1$, $\\varepsilon_s = 10^{-12}$。\n  - 初始条件：\n    $$\n    u(x,0) = \\chi_{[0.4,\\,0.6)}(x)\\cdot 1.\n    $$\n  - 输出：过冲幅度\n    $$\n    O = \\max\\left( \\max_i u_i^{\\text{num}}(t_{\\text{final}}) - 1,\\; 0 \\right) + \\max\\left( 0 - \\min_i u_i^{\\text{num}}(t_{\\text{final}}),\\; 0 \\right).\n    $$\n\n5. 最终输出格式：\n- 您的程序必须生成单行输出，其中包含三个结果，格式为用方括号括起来的逗号分隔列表，顺序为 $[E_1, E_2, O]$。\n- 每个数字必须打印为四舍五入到八位小数的浮点值。\n- 不应打印任何其他文本。\n\n您的程序必须是自包含的，仅使用用于数组的标准数值库，并且不得需要用户输入。实现语言和环境在最终答案部分指定，并且必须严格遵守。", "solution": "所呈现的问题是计算物理学中一个明确定义的任务，具体是使用混合高阶有限体积法数值求解一维线性平流方程。问题陈述在科学上是合理的、内部一致的，并为构建唯一的算法解决方案提供了足够的细节。所有组成部分——控制方程、数值格式（有限体积法、线性五阶、WENO5、SSP-RK3）、混合切换逻辑以及测试用例——在偏微分方程数值方法领域都是标准且成熟的。该问题被认为是有效的，并将提供一个解决方案。\n\n该问题要求实现一个用于线性平流方程的混合格式：\n$$\n\\partial_t u + a \\partial_x u = 0, \\quad x \\in [0, 1)\n$$\n边界条件为周期性。这里，$u(x,t)$ 是守恒量，$a$ 是恒定的平流速度。所有测试用例都使用 $a0$，因此为简洁起见，我们将仅详细说明这种情况的实现。$a0$ 的情况是对称的扩展。\n\n我们在一个包含 $N$ 个单元的均匀网格上采用有限体积法，单元宽度为 $\\Delta x = 1/N$，单元中心为 $x_i = (i+0.5)\\Delta x$（$i=0, \\dots, N-1$）。单元平均值 $u_i(t)$ 的半离散形式为：\n$$\n\\frac{d u_i}{d t} = L(u)_i = - \\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x}\n$$\n这里，$F_{i+\\frac{1}{2}}$ 是单元 $i$ 和单元 $i+1$ 之间界面上的数值通量。由于 $a0$，我们使用左侧迎风格式，这意味着通量依赖于在界面左侧重构的状态，记为 $u_{i+\\frac{1}{2}}^{-}$。通量由下式给出：\n$$\nF_{i+\\frac{1}{2}} = a \\, u_{i+\\frac{1}{2}}^{-}\n$$\n该方法的核心在于从单元平均值 $\\{u_j\\}$ 中混合重构 $u_{i+\\frac{1}{2}}^{-}$。\n\n在计算成本低的线性格式和鲁棒的 WENO 格式之间的选择，是基于一个光滑度传感器在每个界面 $x_{i+\\frac{1}{2}}$ 上局部进行的。单元 $i$ 的传感器定义为：\n$$\nS_i = \\frac{\\left|\\Delta^2 u_i\\right|}{\\left|\\Delta^{+} u_i\\right| + \\left|\\Delta^{-} u_i\\right| + \\varepsilon_s}\n$$\n其中 $\\Delta^{+} u_i = u_{i+1} - u_i$，$\\Delta^{-} u_i = u_i - u_{i-1}$，以及 $\\Delta^2 u_i = u_{i+1} - 2u_i + u_{i-1}$ 是有限差分算子。对于范围 $[0, N-1]$ 之外的索引应用周期性边界条件。项 $\\varepsilon_s$ 是一个小的正常数，用于防止除以零。界面处的传感器取为两个相邻单元传感器的最大值：\n$$\nS_{i+\\frac{1}{2}} = \\max(S_i, S_{i+1})\n$$\n使用阈值 $\\tau = C_{\\tau} \\Delta x$。如果 $S_{i+\\frac{1}{2}}  \\tau$，则认为解在界面附近不光滑，使用五阶 WENO 重构。否则，使用五阶线性迎风重构。\n\n**1. 五阶线性迎风重构**\n对于光滑区域，我们使用一个标准的五阶精度重构来计算 $u_{i+\\frac{1}{2}}^{-}$，该重构基于一个五点模板 $\\{u_{i-2}, u_{i-1}, u_i, u_{i+1}, u_{i+2}\\}$。公式为：\n$$\nu_{i+\\frac{1}{2}}^{-, \\text{lin}} = \\frac{1}{60} (2 u_{i-2} - 13 u_{i-1} + 47 u_i + 27 u_{i+1} - 3 u_{i+2})\n$$\n\n**2. 五阶 WENO 重构**\n在间断附近，我们使用五阶加权基本无振荡 (WENO) 格式 (WENO5-JS) 来计算 $u_{i+\\frac{1}{2}}^{-}$。该格式以非线性方式组合来自三个三点子模板的三阶重构，以避免振荡。这些子模板是 $S_0=\\{u_{i-2}, u_{i-1}, u_i\\}$，$S_1=\\{u_{i-1}, u_i, u_{i+1}\\}$ 和 $S_2=\\{u_i, u_{i+1}, u_{i+2}\\}$。\n在这些子模板上的重构为：\n$$\n\\begin{aligned}\nu_{i+\\frac{1}{2}}^{(0)} = \\frac{1}{6}(2u_{i-2} - 7u_{i-1} + 11u_i) \\\\\nu_{i+\\frac{1}{2}}^{(1)} = \\frac{1}{6}(-u_{i-1} + 5u_i + 2u_{i+1}) \\\\\nu_{i+\\frac{1}{2}}^{(2)} = \\frac{1}{6}(2u_i + 5u_{i+1} - u_{i+2})\n\\end{aligned}\n$$\n为每个子模板计算光滑度指示子 $\\beta_k$：\n$$\n\\begin{aligned}\n\\beta_0 = \\frac{13}{12}(u_{i-2} - 2u_{i-1} + u_i)^2 + \\frac{1}{4}(u_{i-2} - 4u_{i-1} + 3u_i)^2 \\\\\n\\beta_1 = \\frac{13}{12}(u_{i-1} - 2u_i + u_{i+1})^2 + \\frac{1}{4}(u_{i-1} - u_{i+1})^2 \\\\\n\\beta_2 = \\frac{13}{12}(u_i - 2u_{i+1} + u_{i+2})^2 + \\frac{1}{4}(3u_i - 4u_{i+1} + u_{i+2})^2\n\\end{aligned}\n$$\n使用理想权 $c_0=1/10$, $c_1=6/10$, $c_2=3/10$ 计算非线性权 $\\omega_k$：\n$$\n\\alpha_k = \\frac{c_k}{(\\beta_k + \\varepsilon_w)^2}, \\quad \\omega_k = \\frac{\\alpha_k}{\\sum_{j=0}^{2} \\alpha_j}\n$$\n这里，$\\varepsilon_w$ 是一个小的参数，用于避免除以零。将使用标准值 $\\varepsilon_w = 10^{-6}$。\n最终的 WENO 重构是凸组合：\n$$\nu_{i+\\frac{1}{2}}^{-, \\text{weno}} = \\sum_{k=0}^{2} \\omega_k u_{i+\\frac{1}{2}}^{(k)}\n$$\n\n**3. 时间积分**\n常微分方程组 $\\frac{d\\mathbf{u}}{dt} = \\mathbf{L}(\\mathbf{u})$ 使用三阶强稳定性保持龙格-库塔 (SSP-RK3) 格式进行时间推进。给定在时间 $t^n$ 的解 $\\mathbf{u}^n$，在 $t^{n+1} = t^n + \\Delta t$ 的解通过以下方式找到：\n$$\n\\begin{aligned}\n\\mathbf{u}^{(1)} = \\mathbf{u}^n + \\Delta t \\mathbf{L}(\\mathbf{u}^n) \\\\\n\\mathbf{u}^{(2)} = \\frac{3}{4}\\mathbf{u}^n + \\frac{1}{4}\\mathbf{u}^{(1)} + \\frac{1}{4}\\Delta t \\mathbf{L}(\\mathbf{u}^{(1)}) \\\\\n\\mathbf{u}^{n+1} = \\frac{1}{3}\\mathbf{u}^n + \\frac{2}{3}\\mathbf{u}^{(2)} + \\frac{2}{3}\\Delta t \\mathbf{L}(\\mathbf{u}^{(2)})\n\\end{aligned}\n$$\n时间步长 $\\Delta t$ 由 CFL 条件确定：$\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{|a|}$。调整最后的时间步长以确保精确达到最终时间 $t_{\\text{final}}$。\n\n算法通过迭代时间步来推进。在每一步中，以及对于 SSP-RK3 积分器的每个阶段，首先通过计算整个网格上的光滑度传感器来评估空间算子 $\\mathbf{L}(\\mathbf{u})$，然后在每个单元界面选择合适的重构方法（线性或 WENO）来计算通量，最后计算通量散度。然后使用所得的解来执行特定于测试的测量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using a hybrid 5th-order\n    WENO/linear scheme with SSP-RK3 time stepping.\n    \"\"\"\n\n    test_cases = [\n        # Test Case A\n        {\n            \"id\": \"A\",\n            \"a\": 1.0, \"N\": 200, \"CFL\": 0.45, \"t_final\": 0.25, \n            \"C_tau\": 1.0, \"eps_s\": 1e-12,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x),\n            \"exact_sol_func\": lambda x, t, a, u0: u0(np.mod(x - a * t, 1.0)),\n            \"metric\": \"L1_error\"\n        },\n        # Test Case B\n        {\n            \"id\": \"B\",\n            \"a\": 1.0, \"N\": 200, \"CFL\": 0.45, \"t_final\": 0.50,\n            \"C_tau\": 1.0, \"eps_s\": 1e-12,\n            \"u0_func\": lambda x: np.where((x >= 0.1)  (x  0.3), 1.0, 0.0) + 0.2 * np.sin(2 * np.pi * x),\n            \"exact_sol_func\": lambda x, t, a, u0: u0(np.mod(x - a * t, 1.0)),\n            \"metric\": \"L1_error\"\n        },\n        # Test Case C\n        {\n            \"id\": \"C\",\n            \"a\": 1.0, \"N\": 400, \"CFL\": 0.45, \"t_final\": 0.30,\n            \"C_tau\": 1.0, \"eps_s\": 1e-12,\n            \"u0_func\": lambda x: np.where((x >= 0.4)  (x  0.6), 1.0, 0.0),\n            \"exact_sol_func\": None, # Not needed for overshoot\n            \"metric\": \"overshoot\"\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    results_str = [f\"{r:.8f}\" for r in results]\n    print(f\"[{','.join(results_str)}]\")\n\n\ndef get_rhs(u, a, dx, C_tau, eps_s):\n    \"\"\"\n    Computes the right-hand side of the semi-discretized advection equation\n    du/dt = L(u), using a hybrid 5th-order scheme.\n    \"\"\"\n    N = u.shape[0]\n    \n    # --- Smoothness Sensor ---\n    # Finite differences for the sensor\n    u_p1 = np.roll(u, -1)\n    u_m1 = np.roll(u, 1)\n    \n    delta_plus = u_p1 - u\n    delta_minus = u - u_m1\n    delta_2 = u_p1 - 2 * u + u_m1\n    \n    # Cell-centered sensor Si\n    sensor_i = np.abs(delta_2) / (np.abs(delta_plus) + np.abs(delta_minus) + eps_s)\n    \n    # Face-centered sensor S_{i+1/2}\n    sensor_face = np.maximum(sensor_i, np.roll(sensor_i, -1))\n    \n    # Threshold for switching\n    tau = C_tau * dx\n    \n    # --- Reconstructions (assuming a > 0) ---\n    # Stencil values (periodic)\n    u_m2 = np.roll(u, 2)\n    u_p2 = np.roll(u, -2)\n    \n    # 5th-order linear reconstruction for u_{i+1/2}^-\n    u_rec_lin = (2 * u_m2 - 13 * u_m1 + 47 * u + 27 * u_p1 - 3 * u_p2) / 60.0\n\n    # 5th-order WENO reconstruction for u_{i+1/2}^-\n    # This function is written to be vectorized over the whole grid.\n    u_rec_weno = weno5_reconstruction(u, u_m1, u_m2, u_p1, u_p2)\n    \n    # --- Hybridization ---\n    # The `where` mask will be True for faces that need WENO\n    weno_mask = sensor_face > tau\n    u_rec = np.where(weno_mask, u_rec_weno, u_rec_lin)\n    \n    # --- Flux calculation and divergence ---\n    # Fluxes at faces i+1/2\n    flux = a * u_rec\n    \n    # Flux difference term -(F_{i+1/2} - F_{i-1/2}) / dx\n    flux_diff = flux - np.roll(flux, 1)\n    rhs = -flux_diff / dx\n\n    return rhs\n\ndef weno5_reconstruction(u, u_m1, u_m2, u_p1, u_p2):\n    \"\"\"\n    Computes the 5th-order WENO reconstruction u_{i+1/2}^- for a > 0.\n    Vectorized for efficiency.\n    \"\"\"\n    eps_w = 1e-6 # Regularization for WENO weights\n\n    # Ideal weights\n    c0, c1, c2 = 0.1, 0.6, 0.3\n\n    # Smoothness indicators (beta_k)\n    b0 = (13./12.) * (u_m2 - 2*u_m1 + u)**2 + (1./4.) * (u_m2 - 4*u_m1 + 3*u)**2\n    b1 = (13./12.) * (u_m1 - 2*u + u_p1)**2 + (1./4.) * (u_m1 - u_p1)**2\n    b2 = (13./12.) * (u - 2*u_p1 + u_p2)**2 + (1./4.) * (3*u - 4*u_p1 + u_p2)**2\n\n    # Alpha weights\n    a0 = c0 / (b0 + eps_w)**2\n    a1 = c1 / (b1 + eps_w)**2\n    a2 = c2 / (b2 + eps_w)**2\n\n    # WENO weights (omega_k)\n    sum_a = a0 + a1 + a2\n    w0 = a0 / sum_a\n    w1 = a1 / sum_a\n    w2 = a2 / sum_a\n\n    # Reconstructions on sub-stencils\n    u_rec0 = (2*u_m2 - 7*u_m1 + 11*u) / 6.0\n    u_rec1 = (-u_m1 + 5*u + 2*u_p1) / 6.0\n    u_rec2 = (2*u + 5*u_p1 - u_p2) / 6.0\n\n    # Final WENO reconstruction\n    return w0 * u_rec0 + w1 * u_rec1 + w2 * u_rec2\n\ndef run_simulation(params):\n    \"\"\"\n    Main simulation driver for a single test case.\n    \"\"\"\n    a = params[\"a\"]\n    N = params[\"N\"]\n    CFL = params[\"CFL\"]\n    t_final = params[\"t_final\"]\n    C_tau = params[\"C_tau\"]\n    eps_s = params[\"eps_s\"]\n    u0_func = params[\"u0_func\"]\n    exact_sol_func = params[\"exact_sol_func\"]\n\n    # Grid setup\n    dx = 1.0 / N\n    x = np.linspace(0.5 * dx, 1.0 - 0.5 * dx, N)\n\n    # Initial condition\n    u = u0_func(x)\n\n    # Time-stepping\n    dt = CFL * dx / np.abs(a)\n    t = 0.0\n    \n    num_steps = int(np.floor(t_final / dt))\n\n    # SSP-RK3 time integration loop\n    for _ in range(num_steps):\n        # Stage 1\n        rhs1 = get_rhs(u, a, dx, C_tau, eps_s)\n        u1 = u + dt * rhs1\n        \n        # Stage 2\n        rhs2 = get_rhs(u1, a, dx, C_tau, eps_s)\n        u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt * rhs2\n\n        # Stage 3\n        rhs3 = get_rhs(u2, a, dx, C_tau, eps_s)\n        u = (1./3.) * u + (2./3.) * u2 + (2./3.) * dt * rhs3\n\n        t += dt\n\n    # Final step to reach t_final exactly\n    dt_final = t_final - t\n    if dt_final > 1e-12: # Avoid tiny steps\n        # Stage 1\n        rhs1 = get_rhs(u, a, dx, C_tau, eps_s)\n        u1 = u + dt_final * rhs1\n        \n        # Stage 2\n        rhs2 = get_rhs(u1, a, dx, C_tau, eps_s)\n        u2 = 0.75 * u + 0.25 * u1 + 0.25 * dt_final * rhs2\n\n        # Stage 3\n        rhs3 = get_rhs(u2, a, dx, C_tau, eps_s)\n        u = (1./3.) * u + (2./3.) * u2 + (2./3.) * dt_final * rhs3\n\n    # --- Compute final metric ---\n    if params[\"metric\"] == \"L1_error\":\n        u_exact = exact_sol_func(x, t_final, a, u0_func)\n        error = np.sum(np.abs(u - u_exact)) * dx\n        return error\n    elif params[\"metric\"] == \"overshoot\":\n        u_num_max = np.max(u)\n        u_num_min = np.min(u)\n        # For this case, the exact solution is bounded by [0, 1]\n        overshoot = max(u_num_max - 1.0, 0.0)\n        undershoot = max(0.0 - u_num_min, 0.0)\n        return overshoot + undershoot\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2450580"}]}