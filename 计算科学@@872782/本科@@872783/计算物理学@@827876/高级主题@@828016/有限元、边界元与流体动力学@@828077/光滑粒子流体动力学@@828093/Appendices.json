{"hands_on_practices": [{"introduction": "SPH方法的核心在于对邻近粒子的贡献进行求和。然而，对所有粒子对进行遍历的“朴素”搜索法计算成本过高，其复杂度为 $O(N^2)$。本实践将引导你使用K-D树这一关键数据结构，来高效地找出给定粒子在核函数支撑半径内的所有邻居，这是实现大规模SPH模拟的关键一步。你将通过实现该方法来计算粒子密度[@problem_id:2416285]。", "problem": "在平滑粒子流体动力学 (Smoothed Particle Hydrodynamics, SPH) 中，像质量密度这样的连续场通过对离散粒子的加权求和来近似。其基础出发点是连续积分的粒子近似：给定粒子位置 $\\{\\mathbf{r}_j\\}$、粒子质量 $\\{m_j\\}$ 和一个平滑长度为 $h$ 的平滑核 $W(\\mathbf{r}, h)$，粒子 $i$ 的密度通过求和近似为 $\\rho_i \\approx \\sum_j m_j \\, W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)$。一个广泛使用的选择是具有紧支集的三维三次样条核。对于三维空间，记 $r = \\lVert \\mathbf{r} \\rVert$，$q = r/h$，并使用\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n该核的紧支集半径为 $2h$，因此只有在 $r \\le 2 h$ 范围内的粒子才会对给定粒子产生影响。对于 $N$ 个粒子，朴素的全对邻居搜索需要检查所有 $N(N-1)/2$ 个粒子对，这在计算上是昂贵的。k维树 (k-dimensional tree, K-D tree) 数据结构将空间中的点组织起来，以实现高效的范围查询。通过仅在核支集半径内进行查询，可以加速密度计算，同时保持上述定义的精确SPH求和结果。你必须实现一个程序，对于几个指定的测试用例，该程序在粒子位置上构建一个K-D树，并为每个粒子计算：\n- SPH密度 $\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$，使用三维三次样条核，其中 $\\mathcal{N}_i$ 是通过围绕 $\\mathbf{r}_i$ 进行半径为 $2 h_i$ 的范围查询返回的邻居，该求和包括粒子自身（在 $r=0$ 时的自贡献）。\n- K-D树在核支集内返回的邻居数量 $\\lvert \\mathcal{N}_i \\rvert$，条件为 $r \\le 2 h_i$。\n\n使用以下完全指定的测试套件。所有位置都是三维的，单位为千秒差距 (kpc)。所有质量单位为太阳质量 (M$_\\odot$)。所有平滑长度单位为千秒差距 (kpc)。密度必须以太阳质量每立方千秒差距 (M$_\\odot$/kpc$^3$) 为单位报告。本问题不使用角度。测试套件包含3个用例：\n\n- 测试用例1（具有统一平滑长度的常规星团）：位置为\n$[\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$，质量为 $[\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$，统一平滑长度为 $h=0.5$。\n- 测试用例2（邻居恰好在核支集边界上）：位置为 $[\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$，质量为 $[\\,1.0,\\,1.0\\,]$，统一平滑长度为 $h=0.2$。\n- 测试用例3（每个粒子具有可变平滑长度）：位置为 $[\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$，质量为 $[\\,1.0,\\,2.0,\\,1.0\\,]$，每个粒子的平滑长度为 $[\\,0.5,\\,0.3,\\,0.7\\,]$。\n\n你的任务：\n- 精确实现上述定义的三维三次样条核。\n- 为每个测试用例构建一个K-D树，为每个粒子 $i$ 找到半径 $2 h_i$ 内的所有邻居。\n- 为每个粒子计算 $\\rho_i$，使用核函数 $W$ 并包括自贡献。\n- 为每个测试用例中的每个粒子，报告密度和邻居数量 $\\lvert \\mathcal{N}_i \\rvert$。\n\n单位和格式要求：\n- 密度以 M$_\\odot$/kpc$^3$ 表示，并将每个密度值四舍五入到6位小数。\n- 邻居数量必须是整数。\n- 你的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个包含两个列表的列表：第一个列表是该测试用例中每个粒子的密度（浮点数，四舍五入到6位小数），第二个列表是每个粒子的邻居数量（整数）。例如，总输出格式为 $[\\,[\\,[\\rho_{1,1}, \\rho_{1,2}, \\dots],\\,[c_{1,1}, c_{1,2}, \\dots]\\,],\\,[\\,[\\rho_{2,1}, \\dots],\\,[c_{2,1}, \\dots]\\,],\\,[\\,[\\rho_{3,1}, \\dots],\\,[c_{3,1}, \\dots]\\,]\\,]$，其中索引 $(t,i)$ 表示测试用例 $t$ 中的粒子 $i$。\n- 程序必须是完全自包含的，测试套件需硬编码，且不得读取任何输入。\n\n从第一性原理出发设计你的算法，从SPH求和的定义和核的紧支集开始，以证明使用半径为 $2 h_i$ 的范围查询是合理的。然后实现基于K-D树的邻居搜索，为给定的测试套件计算所需的输出。确保逻辑对于 $r = 2 h$ 的边界情况以及每个粒子具有可变平滑长度的情况是正确的。最终输出必须是符合上述描述的精确格式的单行文本。", "solution": "对问题陈述进行验证。\n\n**第1步：提取给定条件**\n- **物理模型**：平滑粒子流体动力学 (SPH) 密度估计。\n- **目标量**：粒子密度 $\\rho_i$。\n- **公式**：$\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j \\, W(\\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert, h_i)$。\n- **平滑核**：一个三维三次样条核，定义如下。令 $r = \\lVert \\mathbf{r} \\rVert$ 和 $q = r/h$。\n$$\nW(r,h) = \\frac{1}{\\pi h^3} \\times\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n- **计算方法**：必须使用k维树 (K-D tree) 进行邻居搜索。搜索是在每个粒子 $\\mathbf{r}_i$ 周围进行半径为 $2h_i$ 的范围查询。\n- **每个粒子的输出**：\n    1. SPH密度 $\\rho_i$，包括自贡献。\n    2. 从范围查询中得到的邻居数量 $|\\mathcal{N}_i|$，条件为 $r \\le 2h_i$。\n- **常量和单位**：位置单位为千秒差距 (kpc)，质量单位为太阳质量 ($M_\\odot$)，平滑长度单位为kpc。密度必须以 $M_\\odot$/kpc$^3$ 表示。\n- **测试用例**：\n    - **用例1**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.3, 0.0, 0.0],\\,[0.0, 0.4, 0.0],\\,[0.0, 0.0, 0.5],\\,[1.2, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,1.0,\\,2.0,\\,1.0,\\,1.0\\,]$，统一平滑长度 $h=0.5$。\n    - **用例2**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.4, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,1.0\\,]$，统一平滑长度 $h=0.2$。\n    - **用例3**：位置 $\\mathbf{r} = [\\,[0.0, 0.0, 0.0],\\,[0.6, 0.0, 0.0],\\,[1.3, 0.0, 0.0]\\,]$，质量 $m = [\\,1.0,\\,2.0,\\,1.0\\,]$，每个粒子的平滑长度 $h = [\\,0.5,\\,0.3,\\,0.7\\,]$。\n- **输出格式**：一个单行字符串，表示一个嵌套列表：$[\\,[\\,[\\text{densities}_1], [\\text{counts}_1]\\,], \\dots\\,]$。密度需四舍五入到6位小数。\n\n**第2步：使用提取的给定条件进行验证**\n- **科学依据**：该问题在计算天体物理学中有坚实的基础。SPH是一种标准的数值方法。三次样条核是一种常规选择，其性质已得到充分理解。使用K-D树进行邻居查找是优化SPH计算的典型方法。\n- **良构性**：该问题在数学和算法上是良构的。输入被完全指定。要计算的函数定义明确。对于给定的输入和规定的方法，存在唯一的结果。\n- **客观性**：问题使用精确、客观和正式的语言陈述。\n\n问题表述是完整的、一致的且科学上合理的。未发现任何缺陷。\n\n**第3步：结论与行动**\n问题有效。将构建一个解决方案。\n\n**基于原理的设计与解决方案**\n\n目标是计算由一组离散粒子采样的质量密度场。在平滑粒子流体动力学 (SPH) 中，任何连续场 $A(\\mathbf{r})$ 都通过与平滑核 $W$ 的卷积来近似。粒子 $i$ 位置处 $\\mathbf{r}_i$ 的密度 $\\rho(\\mathbf{r}_i)$ 的粒子近似由以下求和给出：\n$$\n\\rho_i = \\rho(\\mathbf{r}_i) \\approx \\sum_{j=1}^{N} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i)\n$$\n其中 $\\mathbf{r}_i$ 和 $\\mathbf{r}_j$ 分别是粒子 $i$ 和 $j$ 的位置向量，$m_j$ 是粒子 $j$ 的质量，$N$ 是粒子总数，$W$ 是平滑核，其特征平滑长度为 $h_i$，与粒子 $i$ 相关联。\n\n指定的三维三次样条核被定义为无量纲距离 $q = r/h$ 的函数，其中 $r = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$。该核的关键属性是其*紧支集*。定义明确指出，对于 $q \\ge 2$（等价于 $r \\ge 2h$），$W(r,h) = 0$。这意味着只有距离粒子 $i$ 在 $2h_i$ 以内的粒子才能对其密度产生非零贡献。因此，对所有 $N$ 个粒子的求和可以被限制为仅对该支集半径内的“邻居”粒子求和：\n$$\n\\rho_i = \\sum_{j \\in \\mathcal{N}_i} m_j W(\\mathbf{r}_i - \\mathbf{r}_j, h_i), \\quad \\text{其中 } \\mathcal{N}_i = \\{j \\mid \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert \\le 2h_i\\}\n$$\n问题将邻居搜索条件指定为 $r \\le 2h_i$。由于当 $q=2$（即 $r=2h_i$）时核函数为零，将在支集半径边界上的粒子包含进来并不会改变密度值，但对于按要求正确计算邻居数量是必要的。\n\n为每个粒子寻找邻居的朴素的全对搜索大约需要 $N(N-1)/2$ 次距离计算，导致总体计算复杂度为 $O(N^2)$。对于大的 $N$，这是不现实的。问题要求使用更高效的方法，即k维树 (K-D tree)。K-D树是一种空间划分数据结构，用于组织k维空间中的点。对于我们的三维问题，它允许进行高效的范围查询（也称为球查询）。通过在粒子位置集合 $\\{\\mathbf{r}_j\\}$ 上构建一个K-D树，我们可以为每个粒子 $i$ 查询该树，以找到以 $\\mathbf{r}_i$ 为中心、半径为 $R_i = 2h_i$ 的球内的所有粒子。此操作明显快于 $O(N^2)$，其构建树和执行所有查询的平均情况复杂度接近 $O(N \\log N)$。\n\n因此，算法如下：\n1.  对于每个测试用例，获取粒子位置并构建一个K-D树。`scipy.spatial.KDTree` 类适合此目的。\n2.  初始化空列表，用于存储当前测试用例的最终计算密度和邻居数量。\n3.  遍历每个粒子 $i$，从 $0$ 到 $N-1$。\n    a. 确定当前粒子的平滑长度 $h_i$。对于测试用例3，这是粒子特定的；对于用例1和2，这是所有粒子的统一值。\n    b. 定义支集半径 $R_i = 2h_i$。\n    c. 使用K-D树的 `query_ball_point` 方法，以位置 $\\mathbf{r}_i$ 和半径 $R_i$ 作为参数，找到所有邻居粒子（包括粒子 $i$ 自身）的索引。\n    d. 邻居数量 $|\\mathcal{N}_i|$ 是查询返回的索引列表的长度。存储此整数值。\n    e. 将粒子 $i$ 的密度 $\\rho_i$ 初始化为 $0.0$。\n    f. 遍历步骤3c中找到的邻居粒子的索引 $j$。\n        i.  检索邻居粒子的质量 $m_j$ 和位置 $\\mathbf{r}_j$。\n        ii. 计算距离 $r_{ij} = \\lVert \\mathbf{r}_i - \\mathbf{r}_j \\rVert$。\n        iii. 计算无量纲距离 $q = r_{ij} / h_i$。请注意，当 $h_i=0$ 时，这将是未定义的，但问题只提供正的平滑长度。\n        iv. 根据 $q$ 的值，使用其分段定义来评估核函数 $W(r_{ij}, h_i)$。必须包括归一化因子 $\\frac{1}{\\pi h_i^3}$。\n        v. 将贡献 $m_j W(r_{ij}, h_i)$ 加到 $\\rho_i$ 上。\n    g. 遍历所有邻居后，存储 $\\rho_i$ 的最终值。\n4.  处理完测试用例中的所有粒子后，将密度列表和邻居数量列表收集到该用例的单个结构中。\n5.  对所有测试用例重复此过程，并按规定格式化最终输出。\n\n该过程正确地实现了使用高效K-D树进行邻居查找的SPH密度计算，遵循了三次样条核的紧支集特性，并处理了统一和平滑长度可变的情况。如测试用例2所强调的，在 $r=2h$ 的边界条件也得到了正确处理：该粒子被计为邻居，但其对密度的贡献为零。", "answer": "```python\nimport numpy as np\nfrom scipy.spatial import KDTree\n\ndef solve():\n    \"\"\"\n    Solves the SPH density calculation problem for the specified test suite.\n    \"\"\"\n\n    # Fully specified test suite\n    test_suite = [\n        {\n            \"positions\": np.array([\n                [0.0, 0.0, 0.0], [0.3, 0.0, 0.0], [0.0, 0.4, 0.0],\n                [0.0, 0.0, 0.5], [1.2, 0.0, 0.0]\n            ]),\n            \"masses\": np.array([1.0, 1.0, 2.0, 1.0, 1.0]),\n            \"h_values\": 0.5\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.4, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 1.0]),\n            \"h_values\": 0.2\n        },\n        {\n            \"positions\": np.array([[0.0, 0.0, 0.0], [0.6, 0.0, 0.0], [1.3, 0.0, 0.0]]),\n            \"masses\": np.array([1.0, 2.0, 1.0]),\n            \"h_values\": np.array([0.5, 0.3, 0.7])\n        }\n    ]\n\n    def kernel_3d_cubic_spline(r, h):\n        \"\"\"\n        Computes the value of the 3D cubic spline smoothing kernel.\n        \n        Args:\n            r (float): The distance between particles.\n            h (float): The smoothing length.\n\n        Returns:\n            float: The kernel value W(r, h).\n        \"\"\"\n        if h == 0:\n            return 0.0\n\n        sigma = 1.0 / (np.pi * h**3)\n        q = r / h\n        \n        if 0 = q  1:\n            return sigma * (1.0 - 1.5 * q**2 + 0.75 * q**3)\n        elif 1 = q  2:\n            return sigma * (0.25 * (2.0 - q)**3)\n        else: # q >= 2\n            return 0.0\n\n    all_results = []\n\n    for case in test_suite:\n        positions = case[\"positions\"]\n        masses = case[\"masses\"]\n        h_values_input = case[\"h_values\"]\n        num_particles = len(positions)\n\n        # Handle both uniform and per-particle smoothing lengths\n        if isinstance(h_values_input, (int, float)):\n            h_values = np.full(num_particles, h_values_input)\n        else:\n            h_values = h_values_input\n\n        # Build the K-D tree on particle positions\n        kdtree = KDTree(positions)\n\n        case_densities = []\n        case_neighbor_counts = []\n\n        for i in range(num_particles):\n            pos_i = positions[i]\n            h_i = h_values[i]\n            \n            # Query for neighbors within the compact support radius 2*h_i\n            # The query condition is r = 2*h_i\n            support_radius = 2.0 * h_i\n            neighbor_indices = kdtree.query_ball_point(pos_i, r=support_radius)\n            \n            neighbor_count = len(neighbor_indices)\n            case_neighbor_counts.append(neighbor_count)\n            \n            # Calculate SPH density\n            density_i = 0.0\n            for j in neighbor_indices:\n                pos_j = positions[j]\n                mass_j = masses[j]\n                \n                # Calculate distance between particles i and j\n                distance_rij = np.linalg.norm(pos_i - pos_j)\n                \n                # Calculate kernel contribution and add to density\n                kernel_val = kernel_3d_cubic_spline(distance_rij, h_i)\n                density_i += mass_j * kernel_val\n            \n            case_densities.append(round(density_i, 6))\n            \n        all_results.append([case_densities, case_neighbor_counts])\n\n    # Format the final output string exactly as required\n    # Creates a string representation like \"[[[...],[...]],[[...],[...]]]\"\n    # using the list's default str conversion, which is then joined.\n    result_strings = [str(res).replace(\" \", \"\") for res in all_results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2416285"}, {"introduction": "掌握了空间计算之后，下一步是让系统在时间上进行演化。显式时间积分方案的稳定性取决于一个足够小的时间步长，而这个步长在模拟过程中可能会发生剧烈变化。本练习将重点实现一个基于Courant–Friedrichs–Lewy (CFL)条件、力（加速度）条件和粘性扩散条件的自适应时间步长控制器。这是确保SPH模拟稳健、高效运行的核心组件[@problem_id:2439517]。", "problem": "您的任务是为一个显式光滑粒子流体动力学（SPH）时间积分器实现一个可变时间步控制器，该控制器使用三个基本的稳定性和精度考量：一个库朗-弗里德里希斯-列维（CFL）条件，一个力（加速度）条件，以及一个黏性扩散条件。您的解决方案必须从与双曲型和抛物型问题的显式方法以及经典运动学一致的第一性原理出发，并推导出您将在每次迭代中为时间步长实现的精确表达式。场景是一维的，具有均匀的光滑长度，程序应仅对时间变量进行积分，同时随时间采样规定的最大场量值。所有物理量都必须以国际单位制（SI）处理，时间应始终以秒为单位计算和报告。\n\n推导的出发点：仅使用以下基本原理作为您的基础出发点。\n- 双曲型系统中的特征信号传播：信息以特征速度传播，因此稳定的显式步长必须受空间分辨率与最大信号速度之比的限制。\n- 在一个时间步长内恒定加速度下的运动学：在均匀加速度下的位移必须相对于空间分辨率保持较小，以保持精度。\n- 应用于抛物型扩散的显式格式的稳定性极限：时间步长必须与空间分辨率的平方成正比，与运动黏度成反比。\n\n假设使用以下建模设置：\n- 光滑长度 $h$ 是恒定且均匀的。\n- 最大信号速度被建模为声速与对流速度之和，因此瞬时最大信号速度为 $s(t) = c + \\lvert v_{\\max}(t)\\rvert$，其中 $c$ 是（恒定）声速，$v_{\\max}(t)$ 是随时间变化的最大粒子速度大小。\n- 最大加速度大小 $a_{\\max}(t)$ 是随时间变化的。\n- 运动黏度 $\\nu$ 是恒定且均匀的。\n- 每个时间步长分别对三个极限使用安全系数 $C_{\\mathrm{CFL}}$、$C_{\\mathrm{force}}$ 和 $C_{\\mathrm{visc}}$，每个系数都严格介于 $0$ 和 $1$ 之间。\n\n根据上述原理，推导在时间 $t$ 的三个候选时间步长的显式公式：一个用 $h$ 和 $s(t)$ 表示的双曲型（CFL）界限，一个用 $h$ 和 $a_{\\max}(t)$ 表示的基于力的界限，以及一个用 $h$ 和 $\\nu$ 表示的黏性扩散界限。然后实现一个显式时间推进控制器，该控制器从 $t=0$ 开始，重复执行以下操作：\n- 在当前时间 $t$ 评估三个候选界限；\n- 选择三者中的最小者作为下一个时间增量 $\\Delta t$（通过按CFL、力、黏性的顺序选择第一个来打破平局）；\n- 使用整数代码记录该步中哪个界限起限制作用：$0$ 代表CFL，$1$ 代表力，$2$ 代表黏性；\n- 将时间推进 $\\Delta t$；\n- 当 $t$ 达到指定的最终时间 $T_{\\mathrm{end}}$ 时停止（您必须确保 $t$ 不超过 $T_{\\mathrm{end}}$；如有必要，截断最后一步以精确在 $T_{\\mathrm{end}}$ 结束，但使用未截断的候选界限对限制器进行分类）。\n\n稳健地处理边界情况：如果在任何时候 $a_{\\max}(t)=0$，则基于力的界限应被视为 $+\\infty$；如果 $\\nu=0$，则黏性界限应被视为 $+\\infty$。您可以假设 $c0$，因此CFL界限始终是有限的。$v_{\\max}(t)$ 和 $a_{\\max}(t)$ 的评估由下面给出的平滑时间函数定义。此问题中不出现角度。没有百分比数量。\n\n为了测试和可复现性，请使用以下三个测试用例。在每个案例中，最大速度和加速度由以下公式指定：\n- $v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right)$，\n- $a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}}$，\n所有参数如下所示。时间单位为秒，长度单位为米，速度单位为米/秒，加速度单位为米/秒平方，运动黏度单位为米平方/秒。安全系数是无量纲的。\n\n测试用例 1（一般混合机制）：\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 1.0\\times 10^{-6}$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.10$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 4000.0$ m/s$^{2}$, $\\tau_{a} = 0.015$ s.\n\n测试用例 2（黏性限制，零加速度）：\n- $h = 0.01$ m, $c = 5.0$ m/s, $\\nu = 0.5$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.25$, $C_{\\mathrm{force}} = 0.25$, $C_{\\mathrm{visc}} = 0.125$,\n- $T_{\\mathrm{end}} = 0.05$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 3.0$ m/s, $\\tau_{v} = 0.02$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 0.0$ m/s$^{2}$, $\\tau_{a} = 0.01$ s.\n\n测试用例 3（CFL限制，零黏度）：\n- $h = 0.005$ m, $c = 30.0$ m/s, $\\nu = 0.0$ m$^{2}$/s,\n- $C_{\\mathrm{CFL}} = 0.30$, $C_{\\mathrm{force}} = 0.30$, $C_{\\mathrm{visc}} = 0.30$,\n- $T_{\\mathrm{end}} = 0.010$ s,\n- $v_{0} = 0.0$ m/s, $A_{v} = 1.5$ m/s, $\\tau_{v} = 0.01$ s,\n- $a_{0} = 0.0$ m/s$^{2}$, $A_{a} = 5000.0$ m/s$^{2}$, $\\tau_{a} = 0.005$ s.\n\n程序要求：\n- 完全按照描述实现可变时间步控制器。\n- 对于每个测试用例，生成一个整数代码列表，指示从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 的每次迭代中哪个界限限制了时间步长。\n- 您的程序应生成单行输出，其中包含所有三个测试用例的结果，格式为Python字面量形式的列表的列表，例如，$\\left[\\left[\\dots\\right],\\left[\\dots\\right],\\left[\\dots\\right]\\right]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个限制器代码的列表，这些列表包含在一对方括号内，并用逗号分隔，例如，$\\left[\\left[\\ell_{1,1}, \\ell_{1,2}, \\dots\\right], \\left[\\ell_{2,1}, \\ell_{2,2}, \\dots\\right], \\left[\\ell_{3,1}, \\ell_{3,2}, \\dots\\right]\\right]$，其中每个 $\\ell_{i,j}$ 是 $\\left\\{0,1,2\\right\\}$ 中的一个整数。", "solution": "所提出的问题是有效的。它在科学上基于偏微分方程数值方法的原理，特别是光滑粒子流体动力学（SPH）的原理。该问题是适定的、客观的，并为实现确定性时间步进算法提供了一套完整且一致的数据和指令。我们现在将进行推导和求解。\n\n目标是为显式SPH模拟构建一个可变时间步控制器。每一步的时间增量 $\\Delta t$ 被选为从稳定性和精度考量中导出的三个候选值的最小值：库朗-弗里德里希斯-列维（CFL）条件、基于力的加速度限制和黏性扩散限制。\n\n让我们从所提供的第一性原理出发，推导这三个时间步长界限的表达式。SPH方法的特征空间分辨率由光滑长度 $h$ 给出。\n\n1.  **CFL（双曲型）时间步长, $\\Delta t_{\\mathrm{CFL}}$**\n第一个原理基于双曲型系统显式方法的稳定性。信息或物理信号以特征速度传播。为了保持稳定性，数值依赖域必须包含物理依赖域。在SPH背景下，这意味着在单个时间步长 $\\Delta t$ 内，信息传播的距离不应超过局部相互作用距离，该距离与光滑长度 $h$ 在同一数量级。信号传播的最大速度 $s(t)$ 被给定为声速 $c$ 与最大粒子速度大小 $|v_{\\max}(t)|$ 的和。\n该条件表示为：\n$$ \\Delta t \\le C_{\\mathrm{CFL}} \\frac{h}{s(t)} $$\n其中 $C_{\\mathrm{CFL}}$ 是一个安全系数，通常小于1。代入给定的 $s(t) = c + |v_{\\max}(t)|$ 表达式，我们得到由CFL条件得出的候选时间步长：\n$$ \\Delta t_{\\mathrm{CFL}}(t) = C_{\\mathrm{CFL}} \\frac{h}{c + |v_{\\max}(t)|} $$\n\n2.  **基于力（运动学）的时间步长, $\\Delta t_{\\mathrm{force}}$**\n第二个原理通过限制单个时间步长内粒子因加速度产生的位移来确保精度。该原理指出，此位移应相对于空间分辨率 $h$ 保持较小。在恒定加速度 $a$ 下，粒子在时间 $\\Delta t$ 内的位移是 $\\frac{1}{2}a(\\Delta t)^2$。将此原理形式化的标准SPH准则限制时间步长，使得：\n$$ \\frac{1}{2} a_{\\max}(t) (\\Delta t)^2 \\le \\alpha h $$\n其中 $a_{\\max}(t)$ 是系统中加速度的最大幅值，$\\alpha$ 是一个小的无量纲常数。对 $\\Delta t$ 重新整理得到 $\\Delta t \\le \\sqrt{2\\alpha h / a_{\\max}(t)}$。这通常写成以下形式：\n$$ \\Delta t \\le C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n其中 $C_{\\mathrm{force}}$ 是一个用户定义的安全系数。我们将采用这种标准形式作为所述原理的直接实现。因此，基于力的时间步长为：\n$$ \\Delta t_{\\mathrm{force}}(t) = C_{\\mathrm{force}} \\sqrt{\\frac{h}{a_{\\max}(t)}} $$\n此表达式仅在 $a_{\\max}(t)  0$ 时有效。如果 $a_{\\max}(t) = 0$，则没有加速度需要限制，因此该条件对时间步长没有上限约束。在这种情况下，我们将 $\\Delta t_{\\mathrm{force}}$ 视为无穷大。\n\n3.  **黏性扩散时间步长, $\\Delta t_{\\mathrm{visc}}$**\n第三个原理来自于对形式为 $\\partial u/\\partial t = \\nu \\nabla^2 u$ 的抛物型扩散方程的显式数值格式的稳定性分析，其中 $\\nu$ 是运动黏度。对于简单的前向时间、中心空间（FTCS）离散化，稳定性条件是 $\\Delta t \\le (\\Delta x)^2/(2\\nu)$。在SPH中，空间分辨率 $\\Delta x$ 被光滑长度 $h$ 替代。这种稳定性约束的一般形式是：\n$$ \\Delta t \\le C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n其中 $C_{\\mathrm{visc}}$ 是一个安全系数，它考虑了常数前置因子（如 $1/2$）和黏性项特定SPH离散化的其他细节。问题直接提供了这个系数。因此，黏性时间步长为：\n$$ \\Delta t_{\\mathrm{visc}} = C_{\\mathrm{visc}} \\frac{h^2}{\\nu} $$\n请注意，如果 $\\nu$ 和 $h$ 是常数，则此时间步长也是常数。如果 $\\nu = 0$，则不存在黏性，此约束不适用。因此，在这种情况下，我们将 $\\Delta t_{\\mathrm{visc}}$ 视为无穷大。\n\n**时间积分算法**\n模拟从初始时间 $t=0$ 进行到最终时间 $T_{\\mathrm{end}}$。在每个步骤中，从时间 $t$ 开始，算法如下：\n1.  使用规定的函数评估随时间变化的最大速度和加速度，$v_{\\max}(t)$ 和 $a_{\\max}(t)$：\n    $$ v_{\\max}(t) = v_{0} + A_{v}\\left(1 - e^{-t/\\tau_{v}}\\right) $$\n    $$ a_{\\max}(t) = a_{0} + A_{a} e^{-t/\\tau_{a}} $$\n2.  计算三个候选时间步长：$\\Delta t_{\\mathrm{CFL}}(t)$、$\\Delta t_{\\mathrm{force}}(t)$ 和 $\\Delta t_{\\mathrm{visc}}$。\n3.  确定当前迭代的限制性时间步长：\n    $$ \\Delta t_{\\mathrm{chosen}} = \\min(\\Delta t_{\\mathrm{CFL}}, \\Delta t_{\\mathrm{force}}, \\Delta t_{\\mathrm{visc}}) $$\n4.  识别哪个条件是限制性条件。我们使用整数代码：$0$ 代表CFL，$1$ 代表力，$2$ 代表黏性。平局打破规则是按此指定顺序选择第一个。此代码被记录用于当前步骤。\n5.  推进模拟时间。时间增量 $\\Delta t_{\\mathrm{step}}$ 设置为 $\\Delta t_{\\mathrm{chosen}}$。然而，为确保模拟精确在 $T_{\\mathrm{end}}$ 结束，必要时会截断最后一步。也就是说，如果 $t + \\Delta t_{\\mathrm{chosen}} \\ge T_{\\mathrm{end}}$，当前步是最后一步，时间将推进到 $T_{\\mathrm{end}}$。否则，时间将推进 $\\Delta t_{\\mathrm{chosen}}$：$t \\leftarrow t + \\Delta t_{\\mathrm{chosen}}$。只要 $t  T_{\\mathrm{end}}$，循环就继续。最后一步的限制器代码由未截断的 $\\Delta t_{\\mathrm{chosen}}$ 确定。\n\n对每个测试用例实施此过程，以生成限制器代码序列。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a variable time-step controller for an explicit SPH simulation.\n    The controller uses CFL, force, and viscous stability criteria.\n    \"\"\"\n\n    def run_simulation(h, c, nu, C_cfl, C_force, C_visc, T_end, v0, Av, tau_v, a0, Aa, tau_a):\n        \"\"\"\n        Runs a single SPH time-stepping simulation for a given set of parameters.\n        \n        Returns a list of integer codes indicating the limiter at each step.\n        \"\"\"\n\n        # Define the time-dependent functions for maximum velocity and acceleration\n        def v_max_func(t):\n            # The problem statement defines v_max(t) which may not be a magnitude, but\n            # all test cases result in v_max(t) >= 0. The CFL condition uses |v_max(t)|.\n            if tau_v > 0:\n                return v0 + Av * (1.0 - np.exp(-t / tau_v))\n            return v0 + Av # Case for tau_v -> 0 or t -> inf\n\n        def a_max_func(t):\n            if tau_a > 0:\n                return a0 + Aa * np.exp(-t / tau_a)\n            return a0 # Case for tau_a -> 0 or t -> inf\n\n        t = 0.0\n        limiters = []\n\n        # The loop must continue as long as the current time is less than the end time.\n        while t  T_end:\n            # 1. Evaluate maximum velocity and acceleration at the current time t\n            current_v_max = v_max_func(t)\n            current_a_max = a_max_func(t)\n\n            # 2. Calculate the three candidate time steps\n            \n            # CFL (Hyperbolic) Condition\n            # s(t) = c + |v_max(t)|\n            # c > 0 is assumed, so s_t is always positive.\n            s_t = c + abs(current_v_max)\n            dt_cfl = C_cfl * h / s_t\n\n            # Force (Kinematic) Condition\n            if current_a_max > 0.0:\n                dt_force = C_force * np.sqrt(h / current_a_max)\n            else:\n                dt_force = np.inf\n\n            # Viscous Diffusion Condition\n            if nu > 0.0:\n                dt_visc = C_visc * h**2 / nu\n            else:\n                dt_visc = np.inf\n\n            # 3. Determine the limiting time step and its corresponding code\n            dt_candidates = [dt_cfl, dt_force, dt_visc]\n            \n            # np.argmin implements the required tie-breaking rule (first minimum is chosen)\n            limiter_code = int(np.argmin(dt_candidates))\n            dt_chosen = dt_candidates[limiter_code]\n            \n            # 4. Record the limiter code for the current step\n            limiters.append(limiter_code)\n\n            # 5. Advance the simulation time.\n            # Truncate the last step to ensure t does not exceed T_end.\n            if t + dt_chosen >= T_end:\n                t = T_end\n            else:\n                t += dt_chosen\n        \n        return limiters\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general mixed regime)\n        {'h': 0.01, 'c': 5.0, 'nu': 1.0e-6, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.10, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 4000.0, 'tau_a': 0.015},\n        # Case 2 (viscous-limited with zero acceleration)\n        {'h': 0.01, 'c': 5.0, 'nu': 0.5, 'C_cfl': 0.25, 'C_force': 0.25, 'C_visc': 0.125, 'T_end': 0.05, 'v0': 0.0, 'Av': 3.0, 'tau_v': 0.02, 'a0': 0.0, 'Aa': 0.0, 'tau_a': 0.01},\n        # Case 3 (CFL-limited with zero viscosity)\n        {'h': 0.005, 'c': 30.0, 'nu': 0.0, 'C_cfl': 0.30, 'C_force': 0.30, 'C_visc': 0.30, 'T_end': 0.010, 'v0': 0.0, 'Av': 1.5, 'tau_v': 0.01, 'a0': 0.0, 'Aa': 5000.0, 'tau_a': 0.005},\n    ]\n\n    results = []\n    for case in test_cases:\n        limiters = run_simulation(**case)\n        results.append(limiters)\n\n    # Format the output as a compact Python literal string for a list of lists.\n    # e.g., [[1,2,3],[4],[5,6]]\n    # This construction ensures no spaces are included, matching the example format style.\n    inner_lists_str = [f\"[{','.join(map(str, r))}]\" for r in results]\n    final_output = f\"[{','.join(inner_lists_str)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2439517"}, {"introduction": "现在，你已经掌握了空间求和与时间积分的工具，可以构建一个完整的SPH模拟了。这项综合性实践将模拟一个旋转的、自引力作用下的气体云。你的目标是验证你的模拟程序是否能够正确地保持角动量守恒——这是对任何N体或流体动力学代码物理保真度的基本检验[@problem_id:2439484]。", "problem": "你需要编写一个完整、可运行的程序，使用光滑粒子流体动力学（SPH）在无量纲单位下对一个二维自引力气体云进行数值演化，并分析总角动量的守恒情况。在无量纲单位下工作，引力常数 $G=1$。考虑一个正压气体，其压力由 $P(\\rho) = c_s^2 \\rho$ 给出，其中 $c_s$ 是一个恒定的声速，并通过带有软化长度 $\\epsilon$ 的牛顿成对吸引来处理自引力。\n\n设平面上有 $N$ 个粒子，质量相等，为 $m_i = M/N$，总质量 $M=1$，位置为 $\\vec{r}_i(t) \\in \\mathbb{R}^2$，速度为 $\\vec{v}_i(t) \\in \\mathbb{R}^2$。关于原点的总角动量为\n$$\n\\vec{L}(t) = \\sum_{i=1}^{N} m_i \\, \\vec{r}_i(t) \\times \\vec{v}_i(t),\n$$\n其中叉乘是标准的三维叉乘；在二维中，其大小对应于平面外分量。在给定的状态方程和自引力作用下，根据欧拉动量方程演化该系统。假设没有外力和物理粘性。根据下面每个测试用例的描述，在 $t=0$ 时初始化粒子。\n\n你的任务是，对于每个测试用例，从 $t=0$ 到 $t=T$ 对运动方程进行数值积分，在离散时间点（包括初始时刻和所有后续时间步长）跟踪角动量大小 $|\\vec{L}(t)|$，并为每个用例计算以下诊断量：\n- 如果 $|\\vec{L}(0)|  0$，报告\n$$\n\\max_{0 \\le t \\le T} \\frac{\\left|\\,|\\vec{L}(t)| - |\\vec{L}(0)|\\,\\right|}{|\\vec{L}(0)|}.\n$$\n- 如果 $|\\vec{L}(0)| = 0$，报告\n$$\n\\max_{0 \\le t \\le T} |\\vec{L}(t)|.\n$$\n\n使用以下测试套件。在所有情况下，将粒子均匀地放置在以原点为中心、半径为 $R$ 的圆上，极角为 $\\theta_k = 2\\pi k/N$，$k \\in \\{0,1,\\dots,N-1\\}$，位置为 $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$。将初始速度设置为绕原点的刚体旋转，角速度为 $\\Omega$，即 $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$。\n\n测试套件（每个元组列出 $(N, R, \\Omega, c_s, h, \\epsilon, T, \\Delta t)$）：\n1. $(N=32, R=1.0, \\Omega=0.5, c_s=0.05, h=0.2, \\epsilon=0.02, T=2.0, \\Delta t=0.002)$\n2. $(N=1, R=1.0, \\Omega=1.0, c_s=0.0, h=0.1, \\epsilon=0.0, T=1.0, \\Delta t=0.005)$\n3. $(N=32, R=1.0, \\Omega=0.0, c_s=0.05, h=0.2, \\epsilon=0.02, T=1.0, \\Delta t=0.002)$\n\n对于每个测试用例，使用SPH模拟压力，并使用成对的软化牛顿引力模拟自引力。你必须使用一个球对称、紧支集的光滑核函数，其光滑长度为 $h$，并通过标准的SPH密度求和计算密度，并使用动量守恒的对称形式计算压力。引力软化的实现必须使粒子 $i$ 和 $j$ 之间的成对引力与 $(\\vec{r}_i - \\vec{r}_j)/\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}$ 成正比。\n\n你的程序必须生成一行输出，其中包含三个测试用例的三个诊断值，按顺序排列，形式为用方括号括起来的逗号分隔列表。例如，输出格式必须与以下完全一样：\n[diagnostic_case1,diagnostic_case2,diagnostic_case3]\n所有量都是无量纲的；输出中不要包含任何单位。", "solution": "我们需要在没有外力矩的情况下演化一个二维、自引力、正压的气体，并分析角动量守恒。支配角动量的基本物理原理是，对于一个只受中心且成对反对称的内力作用的封闭系统，总力矩为零，从而导致总角动量守恒。对于一个粒子系统，以连续形式表示，总角动量的时间导数为\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\vec{a}_i.\n$$\n如果力是成对内力之和 $m_i \\vec{a}_i = \\sum_{j\\ne i} \\vec{F}_{ij}$，且 $\\vec{F}_{ij} = -\\vec{F}_{ji}$，并且每个 $\\vec{F}_{ij}$ 都与 $(\\vec{r}_i - \\vec{r}_j)$ 平行，那么总力矩\n$$\n\\sum_{i=1}^{N} \\vec{r}_i \\times \\sum_{j\\ne i} \\vec{F}_{ij} = \\frac{1}{2} \\sum_{i\\ne j} (\\vec{r}_i - \\vec{r}_j) \\times \\vec{F}_{ij} = \\vec{0},\n$$\n因为对于中心力，$(\\vec{r}_i - \\vec{r}_j)$ 与 $\\vec{F}_{ij}$ 平行，它们的叉积为零。因此，在没有外力矩和非中心力的情况下，$\\vec{L}(t)$ 在连续系统中是精确守恒的。\n\n光滑粒子流体动力学（SPH）将压力表示为成对相互作用之和，在对称的、动量守恒的离散化中，这些相互作用是反对称和中心的。粒子 $i$ 处的密度通过求和估计\n$$\n\\rho_i = \\sum_{j=1}^{N} m_j W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\n其中 $W$ 是一个具有紧支集和光滑长度 $h$ 的球对称核函数。正压压力为 $P_i = c_s^2 \\rho_i$。一个尊重线性和角动量守恒的压力加速度的对称SPH表示是\n$$\n\\vec{a}_i^{\\mathrm{(P)}} = - \\sum_{j=1}^{N} m_j \\left( \\frac{P_i}{\\rho_i^2} + \\frac{P_j}{\\rho_j^2} \\right) \\nabla W(|\\vec{r}_i - \\vec{r}_j|, h),\n$$\n其中，由于 $W$ 的球对称性，$\\nabla W$ 与 $(\\vec{r}_i - \\vec{r}_j)$ 平行，从而确保每个成对贡献都是中心且反对称的。自引力通过具有软化长度 $\\epsilon$ 的牛顿引力来建模：\n$$\n\\vec{a}_i^{\\mathrm{(G)}} = - G \\sum_{j\\ne i} m_j \\frac{\\vec{r}_i - \\vec{r}_j}{\\left(|\\vec{r}_i - \\vec{r}_j|^2 + \\epsilon^2\\right)^{3/2}}.\n$$\n这也是成对中心力之和。因此，在精确算术中，总角动量是守恒的：\n$$\n\\frac{d\\vec{L}}{dt} = \\sum_{i=1}^{N} \\vec{r}_i \\times m_i \\left( \\vec{a}_i^{\\mathrm{(P)}} + \\vec{a}_i^{\\mathrm{(G)}} \\right) = \\vec{0}.\n$$\n\n在数值模拟中，离散化和时间积分误差会引入微小的偏差。为了最小化类似哈密顿系统中的长期漂移并保持不变量，可以使用辛二阶积分器，如速度Verlet算法。给定在时间 $t_n$ 的位置 $\\vec{r}_i^n$、速度 $\\vec{v}_i^n$ 和加速度 $\\vec{a}_i^n$，速度Verlet算法按以下方式推进\n$$\n\\vec{r}_i^{n+1} = \\vec{r}_i^{n} + \\vec{v}_i^{n} \\Delta t + \\frac{1}{2} \\vec{a}_i^{n} \\Delta t^2,\n$$\n$$\n\\vec{a}_i^{n+1} = \\vec{a}_i\\big(\\{\\vec{r}_j^{n+1}\\}\\big),\n$$\n$$\n\\vec{v}_i^{n+1} = \\vec{v}_i^{n} + \\frac{1}{2}\\left(\\vec{a}_i^{n} + \\vec{a}_i^{n+1}\\right) \\Delta t,\n$$\n其中 $\\vec{a}_i(\\{\\vec{r}_j\\})$ 是根据当前位置的SPH压力和引力相互作用计算得出的。在每个离散时间，角动量的大小为\n$$\n|\\vec{L}(t_n)| = \\left| \\sum_{i=1}^{N} m_i \\, \\vec{r}_i^n \\times \\vec{v}_i^n \\right|.\n$$\n\n程序的算法设计：\n1. 对于每个测试用例，在半径为 $R$ 的圆上初始化 $N$ 个粒子，其质量相等，为 $m_i = 1/N$，角度为 $\\theta_k = 2\\pi k/N$，位置为 $\\vec{r}_k(0) = R(\\cos\\theta_k, \\sin\\theta_k)$。设置速度为 $\\vec{v}_k(0) = \\Omega(-y_k(0), x_k(0))$，这对应于角速度为 $\\Omega$ 的刚体旋转。\n2. 在每个时间步，使用球对称的紧支集核函数通过SPH求和计算密度。然后计算压力 $P_i = c_s^2 \\rho_i$ 和通过对称SPH力表达式计算压力加速度。使用软化牛顿公式（$G=1$ 和给定的 $\\epsilon$）计算引力加速度。\n3. 使用速度Verlet方案，以时间步长 $\\Delta t$ 在时间 $T$ 内推进位置和速度。\n4. 从 $t=0$ 开始在所有时间步中跟踪 $|\\vec{L}(t)|$。对于 $|\\vec{L}(0)|  0$ 的情况，计算最大相对偏差 $\\max_t \\big||\\vec{L}(t)| - |\\vec{L}(0)|\\big|/|\\vec{L}(0)|$。对于 $|\\vec{L}(0)| = 0$ 的情况，计算 $\\max_t |\\vec{L}(t)|$。\n5. 将三个测试用例的三个诊断值按顺序输出到一行，格式为用方括号括起来的逗号分隔列表。\n\n预期的定性结果：\n- 对于旋转的、自引力的云团，$N=32$，$R=1.0$，$\\Omega=0.5$，内部SPH压力和引力是中心的且成对对称的，因此总角动量应在小的积分和离散化误差范围内守恒；因此最大相对偏差应该很小。\n- 对于 $\\Omega=1.0$ 的单个自由粒子（$N=1$），没有内力，所以 $\\vec{a}=\\vec{0}$ 并且 $\\vec{L}(t)$ 是严格恒定的；在数值上，任何偏差都源于浮点运算，应该非常小。\n- 对于不旋转的云团（$\\Omega=0.0$），初始角动量大小为零；根据对称性和中心力，它应该保持在零附近，所以最大值应该很小。\n\n这些计算直接源于牛顿力学、正压流体的欧拉方程，以及SPH离散化方法。该离散化方法保留了成对内力的反对称性和中心性，从而在没有外力矩的情况下保证了角动量守恒。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Numpy print options (not strictly necessary, but consistent output)\nnp.set_printoptions(precision=10, floatmode='maxprec')\n\ndef cubic_spline_W_2d(r, h):\n    \"\"\"\n    2D cubic spline (M4) kernel value W(r,h).\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    W = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    W[mask1] = 1 - 1.5*q1*q1 + 0.75*q1*q1*q1\n    W[mask2] = 0.25 * (2 - q2)**3\n    return sigma * W\n\ndef cubic_spline_dW_dr_2d(r, h):\n    \"\"\"\n    Derivative dW/dr for 2D cubic spline kernel.\n    Vectorized for numpy arrays.\n    \"\"\"\n    sigma = 10.0 / (7.0 * np.pi * h * h)\n    q = r / h\n    dW_dq = np.zeros_like(r)\n    mask1 = (q >= 0)  (q  1)\n    mask2 = (q >= 1)  (q  2)\n    q1 = q[mask1]\n    q2 = q[mask2]\n    # d/dq of 1 - 1.5 q^2 + 0.75 q^3 is -3 q + 2.25 q^2\n    dW_dq[mask1] = -3.0*q1 + 2.25*q1*q1\n    # d/dq of 0.25 (2 - q)^3 is -0.75 (2 - q)^2\n    dW_dq[mask2] = -0.75 * (2 - q2)**2\n    # dW/dr = (dW/dq) * (1/h) * sigma\n    return sigma * dW_dq / h\n\ndef compute_densities(positions, masses, h):\n    \"\"\"\n    Compute SPH densities by direct summation using the 2D cubic spline kernel.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n    W = cubic_spline_W_2d(dist, h)     # (N,N)\n    rho = W @ masses  # (N,)\n    return rho\n\ndef compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0):\n    \"\"\"\n    Compute accelerations from SPH pressure forces and softened self-gravity.\n    positions: (N,2)\n    masses: (N,)\n    \"\"\"\n    N = positions.shape[0]\n    # Density and pressure\n    rho = compute_densities(positions, masses, h)\n    P = (cs * cs) * rho\n\n    # Pairwise vectors\n    r_i = positions[:, None, :]  # (N,1,2)\n    r_j = positions[None, :, :]  # (1,N,2)\n    dx = r_i - r_j               # (N,N,2)\n    dist = np.linalg.norm(dx, axis=2)  # (N,N)\n\n    # Kernel gradient\n    dW_dr = cubic_spline_dW_dr_2d(dist, h)  # (N,N)\n    # Avoid division by zero\n    inv_r = 1.0 / (dist + 1e-16)\n    gradW = (dW_dr * inv_r)[..., None] * dx  # (N,N,2)\n\n    # Symmetric pressure force factor: (P_i/rho_i^2 + P_j/rho_j^2)\n    # Build matrices via broadcasting\n    Pi_over_rhoi2 = (P / (rho * rho + 1e-30))  # (N,)\n    Pj_over_rhoj2 = Pi_over_rhoi2              # same array, but we'll broadcast\n    term_ij = Pi_over_rhoi2[:, None] + Pj_over_rhoj2[None, :]  # (N,N)\n    # Multiply by masses of j\n    mj = masses[None, :]  # (1,N)\n    facP = term_ij * mj   # (N,N)\n\n    # Pressure acceleration\n    aP = -np.sum(facP[..., None] * gradW, axis=1)  # (N,2)\n\n    # Gravity: softened Newtonian\n    soft2 = eps_soft * eps_soft\n    inv_r3 = 1.0 / (dist*dist + soft2)**1.5  # (N,N)\n    # Exclude self-interaction\n    np.fill_diagonal(inv_r3, 0.0)\n    aG = -G * np.sum((mj[..., None] * inv_r3[..., None]) * dx, axis=1)  # (N,2)\n\n    return aP + aG\n\ndef angular_momentum_z(positions, velocities, masses):\n    \"\"\"\n    Compute total angular momentum (z-component) for 2D system: Lz = sum m (x vy - y vx)\n    \"\"\"\n    x = positions[:, 0]\n    y = positions[:, 1]\n    vx = velocities[:, 0]\n    vy = velocities[:, 1]\n    Lz = np.sum(masses * (x * vy - y * vx))\n    return Lz\n\ndef simulate_case(N, R, Omega, cs, h, eps_soft, T, dt):\n    \"\"\"\n    Simulate one test case and return the diagnostic:\n    - If |L0| > 0: max_t | |L(t)| - |L0| | / |L0|\n    - If |L0| == 0: max_t |L(t)|\n    \"\"\"\n    # Initialize masses\n    M = 1.0\n    masses = np.full(N, M / N)\n    # Initialize positions on a circle\n    if N == 1:\n        thetas = np.array([0.0])\n    else:\n        thetas = 2.0 * np.pi * np.arange(N) / N\n    positions = np.column_stack([R * np.cos(thetas), R * np.sin(thetas)])\n    # Solid-body rotation velocities v = Omega * (-y, x)\n    velocities = Omega * np.column_stack([-positions[:, 1], positions[:, 0]])\n\n    # Initial acceleration\n    acc = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n\n    # Track angular momentum magnitude over time\n    L0 = angular_momentum_z(positions, velocities, masses)\n    L_mags = [abs(L0)]\n\n    steps = int(np.round(T / dt))\n    # Velocity Verlet integration\n    for _ in range(steps):\n        # r_{n+1} = r_n + v_n dt + 0.5 a_n dt^2\n        positions = positions + velocities * dt + 0.5 * acc * (dt * dt)\n        # a_{n+1}\n        acc_new = compute_accelerations(positions, masses, h, cs, eps_soft, G=1.0)\n        # v_{n+1} = v_n + 0.5 (a_n + a_{n+1}) dt\n        velocities = velocities + 0.5 * (acc + acc_new) * dt\n        # Prepare for next step\n        acc = acc_new\n        # Record angular momentum magnitude\n        L_mags.append(abs(angular_momentum_z(positions, velocities, masses)))\n\n    L0_abs = abs(L0)\n    if L0_abs > 1e-14:\n        deviations = np.abs(np.array(L_mags) - L0_abs) / L0_abs\n        diagnostic = float(np.max(deviations))\n    else:\n        diagnostic = float(np.max(L_mags))\n    return diagnostic\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, R, Omega, cs, h, eps, T, dt)\n        (32, 1.0, 0.5, 0.05, 0.2, 0.02, 2.0, 0.002),\n        (1,  1.0, 1.0, 0.0,  0.1, 0.0,  1.0, 0.005),\n        (32, 1.0, 0.0, 0.05, 0.2, 0.02, 1.0, 0.002),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, R, Omega, cs, h, eps_soft, T, dt = case\n        result = simulate_case(N, R, Omega, cs, h, eps_soft, T, dt)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2439484"}]}