{"hands_on_practices": [{"introduction": "在我们深入研究打靶法的具体技术细节之前，首先来探究一个支配我们系统的基本物理原理：对称性。对于像有限深势阱这样的对称势 $V(x) = V(-x)$，其波函数具有确定的宇称（奇或偶）。这个练习将指导你使用直接的矩阵方法，通过数值计算来验证这一量子力学基本定理，为后续更高效的打靶算法设计奠定概念基础。[@problem_id:2388895]", "problem": "编写一个完整的、可运行的程序，从一维不含时薛定谔方程出发，\n$$\n\\hat{H}\\,\\psi(x) \\;=\\; E\\,\\psi(x),\\qquad \\hat{H} \\;=\\; -\\,\\frac{\\hbar^2}{2m}\\,\\frac{d^2}{dx^2} \\;+\\; V(x),\n$$\n计算在有限区间上，对于几种指定的势，具有消失边界值的最低 $K$ 个能量本征值和相关的正交归一本征函数，然后定量地验证这个陈述：对于任何满足 $V(x)=V(-x)$ 的对称势，其本征函数必须具有确定的宇称（偶或奇）。使用约化普朗克常数 $\\hbar = 1$ 和质量 $m = 1$ 的单位制，并取空间域为 $x \\in [-L,L]$，其中 $L = 8$，施加边界条件 $\\psi(-L)=\\psi(L)=0$。对于下面测试套件中列出的每一种势，您必须按能量递增的顺序（即，六个最小的能量本征值，计入简并度）给出前 $K=6$ 个束缚态的结果。\n\n对于每个计算出的本征函数 $\\psi_n(x)$，定义归一化宇称相关器\n$$\np_n \\;=\\; \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx}.\n$$\n一个本征函数具有确定宇称，当且仅当 $|p_n|=1$。在数值上，如果 $|p_n|\\ge \\tau$（阈值 $\\tau = 0.99$），则声明 $\\psi_n(x)$ 具有确定宇称。对每一种势，报告一个包含 $K$ 个布尔值 $b_n$ 的列表，其中如果 $|p_n|\\ge \\tau$ 则 $b_n$ 为真，否则为假。\n\n测试套件（按所列顺序评估）：\n- 情况 A（对称，谐振子）：$V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2$，其中 $\\omega=1$。\n- 情况 B（对称，四次双势阱）：$V(x)=x^4 - 2x^2$。\n- 情况 C（对称，有限方势阱）：当 $|x|  1.5$ 时，$V(x)=-5.0$；否则为 $0$。\n- 情况 D（非对称，倾斜谐振子）：$V(x)=\\tfrac{1}{2}\\,\\omega^2 x^2 + c x$，其中 $\\omega=1, c=1$。", "solution": "问题陈述经评估有效。它在科学上基于量子力学原理，特别是不含时薛定谔方程。该问题是适定的、客观的，并包含唯一数值解所需的所有必要信息。任务是计算几种一维势的最低能量本征态，并验证势的对称性与其本征函数的宇称之间的关系。\n\n控制方程是一维不含时薛定谔方程：\n$$ \\hat{H}\\psi(x) = E\\psi(x) $$\n其中 $E$ 是能量本征值，$\\psi(x)$ 是对应的本征函数。哈密顿算符 $\\hat{H}$ 由下式给出：\n$$ \\hat{H} = -\\frac{\\hbar^2}{2m}\\frac{d^2}{dx^2} + V(x) $$\n问题指定了约化普朗克常数 $\\hbar=1$ 和质量 $m=1$ 的单位制。因此，哈密顿算符简化为：\n$$ \\hat{H} = -\\frac{1}{2}\\frac{d^2}{dx^2} + V(x) $$\n系统被限制在有限区间 $x \\in [-L, L]$ 内，其中 $L=8$，并服从消失边界条件 $\\psi(-L) = \\psi(L) = 0$。这种配置等效于一个宽度为 $2L$ 的无限深方势阱中的粒子，阱内还有一个附加势 $V(x)$。\n\n为了数值求解这个本征值问题，我们采用有限差分法。空间域 $[-L, L]$ 被离散化为 $N+1$ 个等距点 $x_j = -L + j \\cdot \\Delta x$，其中 $j=0, 1, \\dots, N$。网格间距为 $\\Delta x = \\frac{2L}{N}$。本征函数在网格点 $x_j$ 处的值表示为 $\\psi_j = \\psi(x_j)$。边界条件意味着 $\\psi_0 = 0$ 和 $\\psi_N = 0$。我们必须求解 $N-1$ 个内部点的函数值。\n\n动能项中的二阶导数使用三点中心差分公式近似：\n$$ \\frac{d^2\\psi}{dx^2}\\bigg|_{x=x_j} \\approx \\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2} $$\n将此近似代入每个内部网格点 $x_j$（$j=1, \\dots, N-1$）的薛定谔方程，得到一个线性方程组：\n$$ -\\frac{1}{2}\\left(\\frac{\\psi_{j+1} - 2\\psi_j + \\psi_{j-1}}{(\\Delta x)^2}\\right) + V(x_j)\\psi_j = E\\psi_j $$\n这可以重新排列成矩阵本征值问题的标准形式 $\\mathbf{H}\\vec{\\psi} = E\\vec{\\psi}$。这里，$\\vec{\\psi}$ 是未知函数值 $(\\psi_1, \\psi_2, \\dots, \\psi_{N-1})^T$ 的列向量，而 $\\mathbf{H}$ 是一个大小为 $(N-1) \\times (N-1)$ 的实对称三对角矩阵。其元素定义为：\n$$\n\\mathbf{H}_{j,k} =\n\\begin{cases}\n\\frac{1}{(\\Delta x)^2} + V(x_j)  \\text{若 } j=k \\\\\n-\\frac{1}{2(\\Delta x)^2}  \\text{若 } j=k\\pm 1 \\\\\n0  \\text{其他情况}\n\\end{cases}\n$$\n该矩阵方程的解提供了能量本征值 $E_n$ 和相应本征函数 $\\vec{\\psi}_n$ 的离散近似。对于此计算，使用了一种专为对称三对角矩阵设计的数值稳定且高效的算法，即 `scipy.linalg.eigh_tridiagonal`。我们寻求 $K=6$ 个最低的本征值及其相关的本征向量。\n\n该问题要求验证量子力学的一个定理：对于对称势 $V(x)=V(-x)$，哈密顿算符 $\\hat{H}$ 与宇称算符 $\\mathcal{P}$（其中 $\\mathcal{P}f(x) = f(-x)$）对易，因此它们共享一组共同的本征函数。因此，只要能级不简并，$\\hat{H}$ 的本征函数就可以被选择为具有确定宇称的函数，即它们要么是偶函数（$\\psi(-x) = \\psi(x)$），要么是奇函数（$\\psi(-x) = -\\psi(x)$）。对于简并能级，总可以构建一个由具有确定宇称的本征函数组成的基。\n\n为了定量评估数值计算出的本征函数 $\\psi_n(x)$ 的宇称，计算归一化宇称相关器 $p_n$：\n$$ p_n = \\frac{\\int_{-L}^{L} \\psi_n(x)\\,\\psi_n(-x)\\,dx}{\\int_{-L}^{L} |\\psi_n(x)|^2\\,dx} $$\n对于一个真正的偶函数，$p_n=1$；对于一个真正的奇函数，$p_n=-1$。对于任何具有确定宇称的函数，都有 $|p_n|=1$。在离散数值近似中，积分被替换为对网格点的求和。通过选择奇数个总点数（$N+1$），网格被构建为关于 $x=0$ 对称，从而确保 $x_{N-j} = -x_j$。相关器变为：\n$$ p_n \\approx \\frac{\\sum_{j=0}^{N} \\psi_{n,j} \\psi_{n, N-j}}{\\sum_{j=0}^{N} |\\psi_{n,j}|^2} $$\n其中 $\\psi_{n,j}$ 是完整离散本征函数向量的分量，包括零边界。数值求解器返回的本征向量是归一化的，使得分母的和为 $1$。计算简化为本征向量与其反转版本的点积。\n如果 $|p_n| \\ge \\tau$（给定阈值为 $\\tau = 0.99$），则认为一个本征函数具有确定宇称。\n\n算法流程如下：对于 4 种势的情况中的每一种，构建相应的哈密顿矩阵并对其进行对角化，以找到最低的 $K=6$ 对本征对。对于每个得到的本征函数，计算宇称相关器 $p_n$ 并与阈值 $\\tau$ 进行比较，以生成一个布尔值。最终输出是一个包含这 4 个布尔结果列表的列表。\n\n前 3 种势（情况 A、B、C）是对称的，因此它们的本征函数预计具有确定宇称，从而产生一个 `True` 值的列表。第四种势（情况 D）是非对称的，因此其本征函数预计不具有确定宇称，这应该会产生一个 `False` 值的列表。这为物理原理和数值实现都提供了一个清晰的测试。使用足够精细的网格（例如，使用 $N=2000$ 个区间，即 $N+1=2001$ 个点）来确保高精度并最小化数值伪影。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh_tridiagonal\n\ndef solve():\n    \"\"\"\n    Solves the 1D time-independent Schrödinger equation for several potentials,\n    and verifies the parity of the resulting eigenfunctions.\n    \"\"\"\n    \n    # Global parameters as defined in the problem statement\n    L = 8.0\n    K = 6\n    tau = 0.99\n    \n    # Numerical parameters for the finite difference method\n    # Use an odd number of points to have a grid point at x=0\n    num_points = 2001 \n    \n    # Define the potential functions for the test suite\n    def potential_A(x):\n        # Symmetric harmonic oscillator: V(x) = 1/2 * omega^2 * x^2 with omega=1\n        omega = 1.0\n        return 0.5 * omega**2 * x**2\n\n    def potential_B(x):\n        # Symmetric quartic double well: V(x) = x^4 - 2x^2\n        return x**4 - 2.0 * x**2\n\n    def potential_C(x):\n        # Symmetric finite square well\n        V0 = 5.0\n        a = 1.5\n        return np.where(np.abs(x)  a, -V0, 0.0)\n\n    def potential_D(x):\n        # Non-symmetric control: V(x) = 1/2 * omega^2 * x^2 + c*x\n        omega = 1.0\n        c = 1.0\n        return 0.5 * omega**2 * x**2 + c * x\n\n    test_cases = [potential_A, potential_B, potential_C, potential_D]\n\n    all_results = []\n\n    # Setup the spatial grid\n    # Grid spans from -L to L with num_points total points\n    x_grid = np.linspace(-L, L, num_points)\n    dx = x_grid[1] - x_grid[0]\n    \n    # We solve on the interior grid, excluding the boundaries\n    interior_x_grid = x_grid[1:-1]\n    num_interior_points = len(interior_x_grid)\n\n    # Pre-calculate constant kinetic energy terms\n    kinetic_diag = 1.0 / dx**2\n    kinetic_offdiag = -1.0 / (2.0 * dx**2)\n\n    for pot_func in test_cases:\n        # Evaluate the potential on the interior grid\n        V = pot_func(interior_x_grid)\n        \n        # Construct the tridiagonal Hamiltonian matrix components\n        # Diagonal elements: H_jj = T_jj + V_j\n        diagonal = kinetic_diag + V\n        \n        # Off-diagonal elements (constant for this stencil)\n        off_diagonal = np.full(num_interior_points - 1, kinetic_offdiag)\n        \n        # Solve the eigenvalue problem for the lowest K eigenvalues/eigenvectors.\n        # eigh_tridiagonal returns them sorted by eigenvalue.\n        _, eigenvectors = eigh_tridiagonal(diagonal, off_diagonal, select='i', select_range=(0, K - 1))\n        \n        case_booleans = []\n        for i in range(K):\n            # Get the i-th eigenvector (column)\n            eigenvector = eigenvectors[:, i]\n            \n            # Construct the full wavefunction on the grid, including boundaries\n            # where psi is zero.\n            psi_full = np.concatenate(([0.0], eigenvector, [0.0]))\n            \n            # The eigenvectors from eigh_tridiagonal are L2-normalized to 1.\n            # The denominator of the parity correlator is sum(|psi|^2), which is 1.\n            # So, p_n is just the numerator.\n            # The numerator is the dot product of psi(x) with psi(-x).\n            # On our symmetric grid, psi(-x) corresponds to the reversed vector.\n            p_n = np.dot(psi_full, psi_full[::-1])\n            \n            # Check if the absolute value of the parity correlator meets the threshold\n            has_definite_parity = abs(p_n) >= tau\n            case_booleans.append(has_definite_parity)\n            \n        all_results.append(case_booleans)\n\n    # Format the final output string as per the problem specification\n    string_lists = []\n    for bool_list in all_results:\n        # Convert list of booleans [True, False] to string \"[true,false]\"\n        string_lists.append(f\"[{','.join(map(str, bool_list)).lower()}]\")\n    \n    # Combine the case results into the final format \"[[...],[...],...]\"\n    final_output = f\"[{','.join(string_lists)}]\"\n    \n    # Print the single-line result\n    print(final_output)\n\nsolve()\n```", "id": "2388895"}, {"introduction": "现在我们来学习求解量子阱束缚态能量的核心数值技术——打靶法。这个方法巧妙地将一个边值问题（在空间两端都有边界条件）转化为一个初值问题。本练习将引导你从第一性原理出发，通过对薛定谔方程进行离散化，并将其转化为一个递推关系来实现打靶法，最终通过寻找一个“失配函数”的根来确定能量本征值。[@problem_id:2437421]", "problem": "您必须编写一个完整、可运行的程序，从第一性原理出发，通过在格点上离散化空间并对得到的差分方程组执行打靶法，数值求解一维不含时薛定谔方程中粒子在有限深方势阱中的问题。在约化的无量纲单位中进行计算，其中 $\\hbar^2/(2m)=1$，因此控制方程为\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x),\n$$\n有限深方势阱的势函数为\n$$\nV(x) = \\begin{cases}\n-D,  |x| \\le a,\\\\\n0,  |x|  a,\n\\end{cases}\n$$\n对于给定的半宽 $a0$ 和深度 $D0$。使用有限计算域 $x \\in [-L, L]$ 和齐次狄利克雷边界条件 $\\psi(-L)=0$ 和 $\\psi(L)=0$。在这些约化单位中，所有量都是无量纲的，因此最终答案中不需要物理单位。\n\n从该微分方程和这些边界条件出发，推导一个在均匀格点 $x_i = x_{\\min} + i\\,\\Delta x$（其中 $\\Delta x = (x_{\\max}-x_{\\min})/(N-1)$ 且 $N \\ge 3$）上的一致的二阶中心差分离散格式，并实现一个打靶法，对于一个试探能量 $E$，将差分方程从左边界 $x_{\\min}=-L$ 推进到右边界 $x_{\\max}=L$。使用左边界的边界值和非零的初始斜率来启动递推，并将失配函数定义为 $\\psi$ 在右边界的终端值。然后，在失配函数改变符号的子区间上，使用稳健的区间法（例如，二分法），将束缚态能量 $E_0$ 作为该失配函数在区间 $(-D, 0)$ 内的单零点进行框定和精确求解。实施数值保护措施（例如在需要时重标定解）以防止在打靶迭代过程中发生溢出。您的程序必须：\n- 为每个测试用例构建势函数 $V(x)$。\n- 在格点上离散化方程，并对得到的差分方程实现打靶法。\n- 在粗糙网格上扫描能量区间 $(-D,0)$ 以识别失配函数的符号变化，然后应用区间求根方法将每个根收敛到严格的容差。\n- 对于每个测试用例，返回找到的束缚态能量列表，按升序（从最负到最不负）排序，并四舍五入到六位小数。\n\n测试套件。使用以下参数集，它们共同涵盖了一个具有多个束缚态的典型深阱、一个接近阈值的浅阱和一个窄深阱：\n- 用例 1：$a=1.0$, $D=25.0$, $L=10\\,a$, $N=2001$，在 $(-D,0)$ 上粗略能量扫描分辨率为 $M=600$ 个采样点。\n- 用例 2：$a=1.0$, $D=1.0$, $L=12\\,a$, $N=2001$，粗略能量扫描分辨率 $M=600$。\n- 用例 3：$a=0.3$, $D=50.0$, $L=10\\,a$, $N=2001$，粗略能量扫描分辨率 $M=600$。\n\n数值和算法约束：\n- 使用均匀格点和二阶中心差分来推导离散更新。不要使用闭合形式的超越量子化条件；目标是实现格点打靶法。\n- 在 $x=\\pm L$ 处使用齐次狄利克雷边界条件。\n- 在失配函数改变符号的区间上实施区间法加二分法。\n- 为稳定递推关系，如果 $|\\psi|$ 的增长超过一个大阈值，则包含一个重标定步骤。此重标定必须保持波函数在右边界的符号，因此不影响求根的区间框定。\n- 在输出前将每个报告的能量四舍五入到六位小数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素本身是针对一个测试用例的浮点数列表。例如，一个包含两个测试用例的输出可能看起来像 $[[e_{1,1},e_{1,2}], [e_{2,1}]]$，但在这里您必须提供上面指定的三个测试用例的结果。", "solution": "用户提供了一个计算量子力学中有效且适定的问题。任务是通过实现数值打靶法，找到粒子在一维有限深方势阱中的束缚态能量本征值。\n\n该问题由不含时薛定谔方程（TISE）在约化的无量纲单位中（其中 $\\hbar^2/(2m)=1$）控制：\n$$\n-\\psi''(x) + V(x)\\,\\psi(x) = E\\,\\psi(x)\n$$\n势函数 $V(x)$ 是一个深度为 $D0$、半宽为 $a0$ 的有限深方势阱：\n$$\nV(x) = \\begin{cases}\n-D,  |x| \\le a,\\\\\n0,  |x|  a,\n\\end{cases}\n$$\n问题在有限计算域 $x \\in [-L, L]$ 上求解，边界条件为齐次狄利克雷边界条件 $\\psi(-L)=0$ 和 $\\psi(L)=0$。我们感兴趣的是束缚态的能量，其满足 $-D  E  0$。\n\n解的构建遵循以下步骤：控制方程的离散化，实现打靶法将其构建为一个求根问题，以及应用稳健的求根算法来确定能量本征值。\n\n首先，我们离散化薛定谔方程。连续空间坐标 $x$ 被一个包含 $N$ 个点的均匀格点 $x_i = -L + i\\Delta x$（对于 $i=0, 1, \\dots, N-1$）所替代，其中网格间距为 $\\Delta x = 2L/(N-1)$。波函数的二阶导数 $\\psi''(x)$ 在每个格点 $x_i$ 处使用二阶精度的中心差分公式进行近似：\n$$\n\\psi''(x_i) \\approx \\frac{\\psi(x_{i+1}) - 2\\psi(x_i) + \\psi(x_{i-1})}{(\\Delta x)^2}\n$$\n令 $\\psi_i = \\psi(x_i)$ 和 $V_i = V(x_i)$，我们将此近似代入不含时薛定谔方程（TISE）：\n$$\n-\\frac{\\psi_{i+1} - 2\\psi_i + \\psi_{i-1}}{(\\Delta x)^2} + V_i \\psi_i = E \\psi_i\n$$\n这是一个线性差分方程。为实现打靶法，我们将其重排为一个递推关系，使我们能够从两个前面的值 $\\psi_i$ 和 $\\psi_{i-1}$ 计算出 $\\psi_{i+1}$：\n$$\n\\psi_{i+1} - 2\\psi_i + \\psi_{i-1} = -(\\Delta x)^2 (V_i - E)\\psi_i \\\\\n\\psi_{i+1} = (2 + (\\Delta x)^2 (V_i - E))\\psi_i - \\psi_{i-1}\n$$\n这个递推关系构成了我们数值积分的核心。\n\n接下来，我们应用打靶法。该问题是一个两点边值问题，条件为 $\\psi_0=0$ 和 $\\psi_{N-1}=0$。打靶法将其视为一个初值问题。我们固定一个试探能量 $E$，施加左边界条件，然后在整个区域上积分或“打靶”到右边界。然后检查右边界的值。\n\n递推的初始条件是 $\\psi_0$ 和 $\\psi_1$。左边界条件给出 $\\psi_0 = 0$。第二个值 $\\psi_1$ 决定了波函数的初始斜率，$\\psi'(-L) \\approx (\\psi_1-\\psi_0)/\\Delta x = \\psi_1/\\Delta x$。由于零斜率会导致平凡解 $\\psi(x)=0$，我们必须为 $\\psi_1$ 选择一个非零值。TISE的线性性质意味着波函数的总体归一化是任意的，因此任何小的非零选择都是有效的。我们选择 $\\psi_1 = \\Delta x$，这对应于初始斜率为1。\n\n对于一个给定的试探能量 $E$，我们从 $i=1$到 $N-2$ 迭代递推关系以计算整个波函数。右边界的值 $\\psi_{N-1}$ 通常不为零。我们将一个失配函数 $f(E)$ 定义为这个终端值：\n$$\nf(E) = \\psi_{N-1}(E)\n$$\n能量本征值是使该函数为零的特定 $E$ 值，即 $f(E)=0$，从而满足右边界条件。\n\n此过程中的一个关键问题是数值稳定性。在经典禁区（$V(x)  E$）中，真实解呈指数衰减。然而，数值递推关系也允许一个指数增长的解。由于有限的浮点精度，这个增长分量最终会占主导地位并导致溢出。为了解决这个问题，我们引入了一个重标定步骤。在迭代过程中，如果波函数值的绝对值 $|\\psi_i|$ 超过一个大阈值，我们就将前一个值和当前值除以这个阈值。这使得数值保持在可控范围内，而不改变波函数的符号或其零点的位置，从而保持了求根过程的完整性。\n\n最后，我们求 $f(E)$ 的根。我们感兴趣的是在区间 $(-D, 0)$ 内的能量。\n1.  在 $(-D, 0)$ 区间内均匀分布 $M$ 个能量点的粗糙网格。在每个点上计算失配函数 $f(E)$。\n2.  我们扫描结果以查找相邻能量点之间的符号变化。根据介值定理，满足 $f(E_j) \\cdot f(E_{j+1})  0$ 的区间 $[E_j, E_{j+1}]$ 保证至少包含一个根。\n3.  对于每个这样的框定区间，我们应用二分法。这是一个迭代算法，它重复地将搜索区间减半，同时确保根始终被框定，从而稳健地收敛到具有所需数值容差的能量本征值。\n\n这个结合了离散化、打靶法、数值稳定化和稳健求根方法的系统性步骤被实施，以求解每个所提供测试用例的束缚态能量。然后，为每个用例找到的能量按升序排序并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# A strict Russian professor does not tolerate floating-point overflow.\n# RESCALE_THRESHOLD prevents the wavefunction from growing uncontrollably\n# in classically forbidden regions.\nRESCALE_THRESHOLD = 1e10\n\n# Tolerance for the bisection root-finding method.\nBISECTION_TOL = 1e-12\n\ndef create_potential(x: np.ndarray, a: float, D: float) -> np.ndarray:\n    \"\"\"\n    Constructs the finite square well potential V(x).\n    \n    Args:\n        x (np.ndarray): Array of spatial coordinates.\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n\n    Returns:\n        np.ndarray: The potential V(x) at each point in x.\n    \"\"\"\n    V = np.zeros_like(x)\n    V[np.abs(x) = a] = -D\n    return V\n\ndef bisection(f, a: float, b: float, tol: float = BISECTION_TOL) -> float | None:\n    \"\"\"\n    Finds a root of function f in the interval [a, b] using the bisection method.\n    \n    Args:\n        f (callable): The function for which to find a root.\n        a (float): The lower bound of the interval.\n        b (float): The upper bound of the interval.\n        tol (float): The desired tolerance for the root.\n\n    Returns:\n        float | None: The root if found, otherwise None.\n    \"\"\"\n    fa = f(a)\n    if fa == 0.0:\n        return a\n    fb = f(b)\n    if fb == 0.0:\n        return b\n    if fa * fb > 0:\n        # A change of sign is required to guarantee a root.\n        return None\n\n    while (b - a) > tol:\n        c = a + (b - a) / 2.0\n        fc = f(c)\n        if fc == 0.0:\n            return c\n        if fa * fc  0:\n            b = c\n        else:\n            a = c\n            fa = fc  # Optimization: reuse f(c) as the new f(a)\n    return (a + b) / 2.0\n\ndef solve_case(a: float, D: float, L: float, N: int, M: int) -> list[float]:\n    \"\"\"\n    Solves for the bound-state energies of the finite potential well for one case.\n    \n    Args:\n        a (float): Half-width of the well.\n        D (float): Depth of the well.\n        L (float): Half-width of the computational domain.\n        N (int): Number of points in the spatial grid.\n        M (int): Number of points in the coarse energy scan.\n\n    Returns:\n        list[float]: A sorted list of bound-state energies, rounded to 6 decimals.\n    \"\"\"\n    # 1. Setup the spatial grid and potential\n    x = np.linspace(-L, L, N)\n    delta_x = x[1] - x[0]\n    V = create_potential(x, a, D)\n\n    # 2. Define the mismatch function using a factory pattern\n    def mismatch_function_factory(V_grid, n_points, dx):\n        def mismatch(E: float) -> float:\n            \"\"\"\n            Calculates the value of the wavefunction at the right boundary psi(L)\n            for a given trial energy E.\n            \"\"\"\n            # The recurrence relation is:\n            # psi_{i+1} = (2 + (dx^2)*(V_i - E))*psi_i - psi_{i-1}\n            # The term g_i = (dx^2)*(V_i - E) is pre-calculated.\n            g = dx**2 * (V_grid - E)\n            \n            # Initial conditions: psi_0 = 0, psi_1 = dx (for initial slope of 1)\n            p_prev = 0.0\n            p_curr = dx\n            \n            # Use recurrence to \"shoot\" across the grid\n            for i in range(1, n_points - 1):\n                p_next = (2.0 + g[i]) * p_curr - p_prev\n                \n                p_prev = p_curr\n                p_curr = p_next\n\n                # Stabilization: Rescale to prevent overflow\n                if abs(p_curr) > RESCALE_THRESHOLD:\n                    p_prev /= RESCALE_THRESHOLD\n                    p_curr /= RESCALE_THRESHOLD\n            \n            return p_curr  # Mismatch is the value at x=L\n        return mismatch\n\n    mismatch = mismatch_function_factory(V, N, delta_x)\n\n    # 3. Coarse energy scan to find intervals containing roots\n    # Epsilon prevents scanning E=-D or E=0, where solutions might be special.\n    epsilon = 1e-9\n    E_scan = np.linspace(-D + epsilon, -epsilon, M)\n    m_vals = np.array([mismatch(E) for E in E_scan])\n\n    # 4. Find brackets where the mismatch function changes sign\n    root_brackets = []\n    for i in range(M - 1):\n        if m_vals[i] * m_vals[i+1]  0:\n            root_brackets.append((E_scan[i], E_scan[i+1]))\n\n    # 5. Refine each root using the bisection method\n    energies = []\n    for e_low, e_high in root_brackets:\n        energy = bisection(mismatch, e_low, e_high, tol=BISECTION_TOL)\n        if energy is not None:\n            energies.append(energy)\n    \n    # 6. Sort and round the final results\n    return [round(e, 6) for e in sorted(energies)]\n\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    test_cases = [\n        # Case 1: Deep well, multiple states\n        {'a': 1.0, 'D': 25.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n        # Case 2: Shallow well, near threshold\n        {'a': 1.0, 'D': 1.0, 'L_factor': 12.0, 'N': 2001, 'M': 600},\n        # Case 3: Narrow, deep well\n        {'a': 0.3, 'D': 50.0, 'L_factor': 10.0, 'N': 2001, 'M': 600},\n    ]\n\n    results = []\n    for case in test_cases:\n        L = case['a'] * case['L_factor']\n        result = solve_case(case['a'], case['D'], L, case['N'], case['M'])\n        results.append(result)\n\n    # Format the final output string to match the problem specification,\n    # specifically producing a list of lists of floats without extra spaces.\n    # For example: [[-24.51,-23.05],[-0.6],[-48.24,-43.12]]\n    formatted_results = [str(res).replace(' ', '') for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2437421"}, {"introduction": "在掌握了基本的打靶法之后，我们可以通过结合物理洞察和更精巧的数值策略来进一步优化算法。这个练习将展示如何利用在第一个练习中验证过的宇称性质，将求解域减半，并分别针对偶宇称和奇宇称的解设定不同的初始条件。此外，我们还将引入对数微商作为边界匹配条件，并探讨如何通过并行计算来划分能量搜索区间，从而大幅提升计算效率。[@problem_id:2437420]", "problem": "您需要设计并实现一个平行打靶法，用于计算一维有限方势阱在无量纲单位下的束缚态本征值。在该单位制中，约化普朗克常数的平方除以两倍粒子质量为1，即 $\\hbar^2/(2m)=1$。考虑一个定态波函数 $u(x)$ 的定态薛定谔方程，\n$$\n-\\frac{d^2 u}{dx^2} + V(x)\\,u(x) = E\\,u(x),\n$$\n该方程等价地可以写为\n$$\n\\frac{d^2 u}{dx^2} = \\big(V(x)-E\\big)\\,u(x).\n$$\n势 $V(x)$ 是一个深度为 $V_00$、半宽度为 $a0$ 的有限方势阱，\n$$\nV(x) = \\begin{cases}\n-\\,V_0,  |x|\\le a,\\\\\n0,  |x|a.\n\\end{cases}\n$$\n束缚态的能量 $E$ 严格介于 $-V_0$ 和 $0$ 之间，即 $-V_0  E  0$。由于势是偶函数，本征函数具有确定的宇称。对于偶宇称态，在 $x=0$ 处施加初始条件 $u(0)=1, u'(0)=0$。对于奇宇称态，施加 $u(0)=0, u'(0)=1$。这些初始条件固定了一个适用于打靶法的任意归一化。\n\n基本依据和数值原理。在 $V(x)=0$ 且 $E0$ 的渐近区域 $x\\to+\\infty$ 中，束缚态解以 $u(x)\\propto e^{-\\kappa x}$ 的形式衰减，其中衰减常数 $\\kappa=\\sqrt{-E}$。因此，对于一个正确的本征值 $E$，当 $x$ 很大时，对数导数满足 $u'(x)/u(x)\\to -\\kappa$。利用这一点，在一个很大但有限的 $x_{\\max}a$ 处定义一个失配函数：\n$$\nF(E) \\equiv \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E},\n$$\n该函数通过对指定宇称的初值问题从 $x=0$ 积分到 $x_{\\max}$ 来计算。本征值对应于 $F(E)$ 的零点。\n\n平行方案设计要求。将能量区间 $(-V_0,0)$ 划分为 $P$ 个独立的子区间。将每个子区间分配给一个单独的处理器，该处理器独立且并行地对两种宇称执行以下操作：\n- 在其分配的子区间内的网格上对 $F(E)$ 进行采样，以定位指示可能零点的符号变化，\n- 通过仅使用函数符号信息的稳健求根方法（例如，二分法）对每个符号变化区间进行精化，\n- 返回在该子区间中找到的精化后的根（候选本征值）列表。\n\n所有处理器完成后，合并并排序所有候选值，在小容差范围内移除重复值（以处理子区间边界上的情况），并为测试用例输出唯一的本征值集合。仅使用实数运算。不出现角度，因此不需要角度单位。所有物理量都是无量纲的。所有本征值都用由 $\\hbar^2/(2m)=1$ 所隐含的相同无量纲能量单位表示，并四舍五入到六位小数。\n\n实现约束。\n- 使用固定步长的显式积分器，对于给定的 $E$ 和宇称，将系统 $\\frac{d}{dx}\\begin{pmatrix}u\\\\u'\\end{pmatrix}=\\begin{pmatrix}u'\\\\(V(x)-E)u\\end{pmatrix}$ 从 $x=0$ 推进到 $x_{\\max}$。选择足够大的 $x_{\\max}$，以确保渐近区域 $V(x)=0$ 得到充分采样。\n- 为保证数值稳定性，您可以在积分过程中将 $(u,u')$ 按一个常数因子进行重新归一化；这不会改变对数导数。\n- 在扫描 $E$ 时，避免使用任何针对有限势阱的解析超越条件；算法必须仅基于初值积分和 $F(E)$ 的符号变化来执行。\n\n测试套件。您的程序必须为以下每个参数集计算并报告本征值，每个参数集都被视为一个独立的测试用例：\n- 用例 A（理想路径）：$V_0=50.0$, $a=1.0$, $P=8$。\n- 用例 B（近阈值浅势阱）：$V_0=2.0$, $a=1.0$, $P=4$。\n- 用例 C（较宽且中等深度的势阱）：$V_0=20.0$, $a=2.0$, $P=10$。\n\n对于每个用例：\n- 使用 $x_{\\max}=20.0$。\n- 使用固定积分步长 $\\Delta x=0.02$。\n- 在每个子区间中，在 $M=60$ 个等间距能量点上对 $F(E)$ 进行采样以检测符号变化，然后通过二分法精化每个区间，直到区间宽度低于 $\\varepsilon_E=10^{-6}$ 或 $|F(E)|\\varepsilon_F=10^{-6}$。\n- 在跨子区间和宇称合并候选值时，如果 $|E_1-E_2|\\delta_{\\text{merge}}=10^{-3}$，则将两个能量 $E_1$ 和 $E_2$ 视为相同。\n\n最终输出规范。您的程序应生成单行输出，其中包含三个测试用例的结果，格式为列表的列表，每个内部列表包含该用例排序后（升序）的本征值，四舍五入到六位小数。格式必须是单行，由方括号括起来的逗号分隔列表，内部列表也由方括号括起来。例如，包含两个用例的输出可能看起来像 $[[e_{1,1},e_{1,2}],[e_{2,1}]]$。您的程序必须精确地打印这样一行。\n\n每个独立数字的预期数据类型是浮点数。不出现百分比或角度，因此除了指定的无量纲能量单位外，不需要特殊的单位说明。该设计涵盖：\n- 一个通用情况（用例 A），\n- 一个接近 $E\\to 0$ 边界的浅束缚态情况（用例 B），\n- 一个具有多个量子态的更宽的势阱（用例 C）。", "solution": "问题陈述经评估有效。它在科学上是合理的、良构的，并为计算量子力学中的一个数值任务提供了完整且一致的规范。问题没有矛盾、歧义和事实错误。因此，我们可以着手解决。\n\n该问题要求计算一维有限方势阱的束缚态能量本征值。其控制方程是定态薛定谔方程（TISE），在 $\\hbar^2/(2m) = 1$ 的无量纲单位下表示为：\n$$\n-\\frac{d^2 u}{dx^2} + V(x)u(x) = E u(x)\n$$\n势 $V(x)$ 由下式给出：\n$$\nV(x) = \\begin{cases}\n-V_0,  |x| \\le a \\\\\n0,  |x|  a\n\\end{cases}\n$$\n其中 $V_0  0$ 是势阱深度，$a  0$ 是半宽度。束缚态对应于波函数 $u(x)$ 平方可积的解，对于此势，这要求能量 $E$ 处于 $-V_0  E  0$ 的范围内。\n\nTISE 是一个二阶常微分方程（ODE）。为了将其作为初值问题（IVP）求解，我们将其重写为一个包含两个一阶 ODE 的方程组。设 $\\mathbf{y}(x) = \\begin{pmatrix} u(x) \\\\ u'(x) \\end{pmatrix}$。则该方程组为：\n$$\n\\frac{d\\mathbf{y}}{dx} = \\frac{d}{dx}\\begin{pmatrix} u \\\\ u' \\end{pmatrix} = \\begin{pmatrix} u' \\\\ (V(x) - E)u \\end{pmatrix}\n$$\n由于势 $V(x)$ 是一个偶函数（$V(x) = V(-x)$），本征函数 $u(x)$ 必须具有确定的宇称（偶或奇）。这使我们能够仅在定义域 $x \\ge 0$ 上进行积分，并在 $x=0$ 处采用适当的初始条件来求解问题：\n- 对于偶宇称态：$u(0) = 1$, $u'(0) = 0$。\n- 对于奇宇称态：$u(0) = 0$, $u'(0) = 1$。\n归一化是任意的，其选择是为了方便打靶法计算。\n\n打靶法的核心是找到使该 IVP 的解满足无穷远处边界条件的能量 $E$ 值。对于束缚态，$u(x)$ 必须在 $x \\to \\infty$ 时衰减到零。在区域 $|x|  a$ 中，势 $V(x)=0$，TISE 变为 $\\frac{d^2 u}{dx^2} = -E u(x)$。当 $E  0$ 时，通解为 $u(x) = A e^{\\kappa x} + B e^{-\\kappa x}$，其中 $\\kappa = \\sqrt{-E}  0$。为使解在 $x \\to +\\infty$ 时保持有界，增长指数项的系数 $A$ 必须为零。因此，解的渐近行为必须是 $u(x) \\propto e^{-\\kappa x}$。这意味着波函数的对数导数必须满足：\n$$\n\\frac{u'(x)}{u(x)} \\to -\\kappa = -\\sqrt{-E} \\quad \\text{as } x \\to \\infty\n$$\n我们可以定义一个失配函数 $F(E)$，它用于衡量对于一个试探能量 $E$ 的解在一个很大但有限的匹配点 $x_{\\max}  a$ 处不满足此边界条件的程度：\n$$\nF(E) = \\frac{u'(x_{\\max})}{u(x_{\\max})} + \\sqrt{-E}\n$$\n能量本征值正是方程 $F(E) = 0$ 的根。\n\n所指定的算法是一种为寻找这些根而设计的平行打靶法。总的能量搜索区间 $(-V_0, 0)$ 被划分为 $P$ 个更小的独立子区间。对于每个子区间和每种宇称，按如下方式进行搜索：\n1.  **ODE 积分**：为了对给定的能量 $E$ 求值 $F(E)$，使用固定步长的显式欧拉积分器将一阶 ODE 方程组从 $x=0$ 积分到 $x_{\\max}$。给定在步长 $x_n$ 处的状态 $(u_n, u'_n)$，在 $x_{n+1} = x_n + \\Delta x$ 处的状态近似为：\n    $$\n    u_{n+1} = u_n + \\Delta x \\cdot u'_n\n    $$\n    $$\n    u'_{n+1} = u'_n + \\Delta x \\cdot (V(x_n) - E) u_n\n    $$\n    在积分过程中，解向量 $(u, u')$ 可能会变得非常大，导致浮点溢出。为确保数值稳定性，如果向量的幅值变得过大，则在每一步都对其进行重新归一化，这不会影响对数导数。\n\n2.  **求根区间限定**：在每个子区间内，函数 $F(E)$ 在 $M$ 个等距点上被采样。两个连续点之间的符号变化，$F(E_i) \\cdot F(E_{i+1})  0$，表明在区间 $[E_i, E_{i+1}]$ 中存在一个根。这个区间被称为一个根区间（bracket）。\n\n3.  **根的精化**：每个根区间都被传递给一个二分法算法。二分法是一种稳健的求根方法，它通过重复地将区间减半，同时保持根被限定在区间内。这个过程持续进行，直到区间宽度小于容差 $\\varepsilon_E$ 或失配函数的绝对值小于容差 $\\varepsilon_F$。\n\n4.  **结果聚合**：在处理完所有子区间和两种宇称后，收集到的本征值将被合并。对候选值列表进行排序，并通过将在子区间边界附近找到的根视为相同来移除重复项，即如果 $|E_1 - E_2|$ 小于合并容差 $\\delta_{\\text{merge}}$，则认为能量 $E_1$ 和 $E_2$ 是相同的。\n\n此过程将应用于三个测试用例，使用指定的数值参数：$x_{\\max}=20.0$, $\\Delta x=0.02$, $M=60$, $\\varepsilon_E=10^{-6}$, $\\varepsilon_F=10^{-6}$ 和 $\\delta_{\\text{merge}}=10^{-3}$。最终结果是每个用例排序后的唯一本征值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final output.\n    \"\"\"\n    test_cases = [\n        # (V0, a, P)\n        (50.0, 1.0, 8),   # Case A\n        (2.0, 1.0, 4),    # Case B\n        (20.0, 2.0, 10),  # Case C\n    ]\n\n    # Common numerical parameters from the problem statement\n    params = {\n        'x_max': 20.0,\n        'dx': 0.02,\n        'M': 60,\n        'tol_E': 1e-6,\n        'tol_F': 1e-6,\n        'tol_merge': 1e-3,\n    }\n\n    all_results = []\n    for V0, a, P in test_cases:\n        eigenvalues = _find_eigenvalues_for_case(V0, a, P, **params)\n        all_results.append([f\"{eig:.6f}\" for eig in eigenvalues])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join([\"[\" + \",\".join(map(str, res)) + \"]\" for res in all_results]) + \"]\"\n    print(output_str)\n\n\ndef _potential(x, V0, a):\n    \"\"\"Calculates the finite square well potential V(x).\"\"\"\n    if abs(x) = a:\n        return -V0\n    return 0.0\n\n\ndef _integrate_schrodinger(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Integrates the Schrodinger equation for a given energy and parity.\n    Uses a fixed-step explicit Euler method.\n    \"\"\"\n    # Initial conditions at x=0\n    if parity == 'even':\n        u, du_dx = 1.0, 0.0\n    else:  # odd\n        u, du_dx = 0.0, 1.0\n    \n    # Renormalization threshold to prevent overflow\n    renorm_threshold = 1e20\n\n    x_points = np.arange(0, x_max, dx)\n    for x in x_points:\n        # Explicit Euler step\n        u_new = u + dx * du_dx\n        du_dx_new = du_dx + dx * (_potential(x, V0, a) - E) * u\n        u, du_dx = u_new, du_dx_new\n\n        # Renormalization to maintain numerical stability\n        if abs(u) > renorm_threshold or abs(du_dx) > renorm_threshold:\n            norm = np.sqrt(u**2 + du_dx**2)\n            if norm > 0:\n                u /= norm\n                du_dx /= norm\n\n    return u, du_dx\n\n\ndef _mismatch_function_F(E, parity, V0, a, x_max, dx):\n    \"\"\"\n    Calculates the mismatch function F(E) for the shooting method.\n    \"\"\"\n    if E >= 0:\n        # Bound states must have E  0, handle edge case of E approaching 0.\n        return np.inf\n\n    u_xmax, du_dx_xmax = _integrate_schrodinger(E, parity, V0, a, x_max, dx)\n\n    if abs(u_xmax)  1e-30:  # Avoid division by zero, indicates a vertical asymptote\n        return np.inf\n\n    kappa = np.sqrt(-E)\n    return du_dx_xmax / u_xmax + kappa\n\n\ndef _bisection(func, E1, E2, tol_E, tol_F):\n    \"\"\"\n    Performs bisection to find a root of func in the bracket [E1, E2].\n    \"\"\"\n    f1 = func(E1)\n    f2 = func(E2)\n\n    if f1 * f2 >= 0:\n        return None  # Not a valid bracket\n\n    if f1 > f2: # Ensure E1 is the lower bound of F\n        E1, E2 = E2, E1\n        \n    while (E2 - E1) > tol_E:\n        E_mid = (E1 + E2) / 2.0\n        f_mid = func(E_mid)\n\n        if abs(f_mid)  tol_F:\n            return E_mid\n\n        if f_mid  0:\n            E1 = E_mid\n        else:\n            E2 = E_mid\n            \n    return (E1 + E2) / 2.0\n\n\ndef _find_eigenvalues_for_case(V0, a, P, x_max, dx, M, tol_E, tol_F, tol_merge):\n    \"\"\"\n    Implements the full parallel shooting algorithm for a single test case.\n    The \"parallel\" aspect is simulated by iterating through independent subranges.\n    \"\"\"\n    E_min_total, E_max_total = -V0, 0.0\n    subrange_width = (E_max_total - E_min_total) / P\n    \n    candidate_eigenvalues = []\n\n    # This loop simulates P processors working in parallel\n    for i in range(P):\n        E_sub_min = E_min_total + i * subrange_width\n        E_sub_max = E_min_total + (i + 1) * subrange_width\n        \n        # This inner loop covers both parities for each subrange\n        for parity in ['even', 'odd']:\n            \n            # Create a lambda for the function to be solved in this sub-problem\n            mismatch_func = lambda E: _mismatch_function_F(E, parity, V0, a, x_max, dx)\n\n            # Sample F(E) on a grid to find sign changes (brackets)\n            # Use M points strictly inside the subrange to avoid boundary issues\n            energy_grid = np.linspace(E_sub_min, E_sub_max, M + 2)[1:-1]\n            F_values = [mismatch_func(E) for E in energy_grid]\n\n            for j in range(len(energy_grid) - 1):\n                if F_values[j] * F_values[j+1]  0:\n                    # Found a bracket, refine it with bisection\n                    E1, E2 = energy_grid[j], energy_grid[j+1]\n                    root = _bisection(mismatch_func, E1, E2, tol_E, tol_F)\n                    if root is not None:\n                        candidate_eigenvalues.append(root)\n\n    # Merge results: sort and remove duplicates\n    if not candidate_eigenvalues:\n        return []\n\n    candidate_eigenvalues.sort()\n    \n    unique_eigenvalues = [candidate_eigenvalues[0]]\n    for i in range(1, len(candidate_eigenvalues)):\n        if abs(candidate_eigenvalues[i] - unique_eigenvalues[-1]) > tol_merge:\n            unique_eigenvalues.append(candidate_eigenvalues[i])\n            \n    return unique_eigenvalues\n\n# Execute the main function when the script is run\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2437420"}]}