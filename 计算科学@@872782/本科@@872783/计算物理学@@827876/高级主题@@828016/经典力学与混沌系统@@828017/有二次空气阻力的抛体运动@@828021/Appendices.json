{"hands_on_practices": [{"introduction": "理论知识的最终目的是解决实际问题。这个练习将指导你从第一性原理出发，构建一个包含二次空气阻力的抛体运动数值模拟器。通过应用像四阶龙格-库塔（RK4）这样的数值积分方法，你将能够预测炮弹的飞行轨迹，并判断它是否能飞越特定高度的障碍物，这是将物理模型转化为可执行代码的基础实践。[@problem_id:2430459]", "problem": "一枚质量为 $m$ 的炮弹以初速度 $v_0$ 和高于水平线的发射角 $\\theta$ 从地面发射。运动发生在一个大小为 $g$ 的匀强引力场中，并受到与速度平方成正比的二次空气动力学阻力。空气密度为 $\\rho$，炮弹被建模为一个半径为 $r$ 的刚性球体，其阻力系数为 $C_d$，横截面积为 $A = \\pi r^2$。阻力始终与瞬时速度方向相反。在距离发射点水平距离为 $D$ 的地方，有一堵高度为 $H$ 的垂直城堡墙壁。任务是通过第一性原理和数值模拟，确定炮弹是否能越过墙壁，即在炮弹落地之前，其在水平位置 $x = D$ 处的高度是否大于或等于 $H$。\n\n您的程序必须：\n- 从基本物理定律（牛顿第二定律和运动学定义）出发，建立在匀强引力下受二次空气阻力作用的炮弹的运动方程。\n- 实现一个时间推进数值积分器，从 $t = 0$ 开始演化系统状态 $(x(t), y(t), v_x(t), v_y(t))$，直到出现以下情况之一：\n    1. 水平位置达到或超过墙壁位置 ($x \\ge D$)。\n    2. 炮弹击中地面 ($y  0$)。\n    3. 超过预设定的最大模拟时间（声明未能到达墙壁）。\n- 当满足条件 $x \\ge D$ 时，通过在包夹 $D$ 的最后两个时间步之间进行线性插值，计算出在 $x = D$ 处的垂直位置，并将其与 $H$ 进行比较，以判断是否越过墙壁。\n- 如果炮弹在到达 $x = D$ 之前击中地面，或者在达到最大模拟时间时仍未到达 $x \\ge D$，则声明未越过墙壁。\n\n所有量都必须用国际单位制 (SI) 表示：长度单位为米 ($\\mathrm{m}$)，质量单位为千克 ($\\mathrm{kg}$)，时间单位为秒 ($\\mathrm{s}$)，重力加速度单位为 $\\mathrm{m/s^2}$。使用 $g = 9.81\\,\\mathrm{m/s^2}$。角度 $\\theta$ 以度为单位指定。\n\n测试套件：\n使用以下五个测试用例。对每个用例，输出一个布尔值，表示炮弹是否越过墙壁（如果越过则为 True，否则为 False）。所有用例的参数使用相同的空气密度 $\\rho$ 和重力加速度 $g$，但其他参数可能因用例而异。\n\n通用参数：\n- $\\rho = 1.225\\,\\mathrm{kg/m^3}$，\n- $g = 9.81\\,\\mathrm{m/s^2}$。\n\n各用例参数：\n1. 用例1（理想情况，轻松越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。\n2. 用例2（边界情况：纯垂直发射，永远无法到达墙壁）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 90.0^\\circ$，$D = 50.0\\,\\mathrm{m}$，$H = 5.0\\,\\mathrm{m}$。\n3. 用例3（边界情况：墙壁在发射点）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 100.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 0.0\\,\\mathrm{m}$，$H = 1.0\\,\\mathrm{m}$。\n4. 用例4（低速，真空极限情况，测试在到达墙壁前落地）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.0$，$v_0 = 20.0\\,\\mathrm{m/s}$，$\\theta = 10.0^\\circ$，$D = 30.0\\,\\mathrm{m}$，$H = 0.1\\,\\mathrm{m}$。\n5. 用例5（合理的中世纪高性能射击，在一定距离处越过）：\n   - $m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的布尔值列表。例如，一个包含五个结果的有效输出形式为“[True,False,True,False,True]”。不应打印任何其他文本。\n\n角度单位要求：\n角度 $\\theta$ 以度为单位提供，对于任何三角函数计算，必须在内部转换为弧度。\n\n单位要求：\n所有内部计算均以国际单位制表示；比较结果是无单位的布尔值。判断是否越过墙壁时，是将插值得到的高度 $y(D)$（单位为 $\\mathrm{m}$）与墙壁高度 $H$（单位为 $\\mathrm{m}$）进行比较。\n\n您的程序必须是一个完整、可运行的程序，该程序硬编码上述测试套件并打印所需的单行输出。", "solution": "我们从牛顿第二定律和运动学开始。设 $(x(t), y(t))$ 表示炮弹的位置，$(v_x(t), v_y(t))$ 表示其速度分量，速度大小为 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。质量为 $m$，重力大小为 $g$，方向向下。对于中等雷诺数下稳定流中的球体，阻力被建模为与速度成二次关系，其大小为 $\\frac{1}{2}\\rho C_d A v(t)^2$，方向与瞬时速度相反。这里 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A = \\pi r^2$ 是横截面积。\n\n根据牛顿第二定律，\n$$\nm \\frac{d\\mathbf{v}}{dt} = \\mathbf{F}_g + \\mathbf{F}_d,\n$$\n其中 $\\mathbf{F}_g = (0, - m g)$ 且 $\\mathbf{F}_d = - \\frac{1}{2} \\rho C_d A \\, v \\, \\mathbf{v}$，因为 $v \\, \\mathbf{v}$ 等于沿 $\\mathbf{v}$ 方向大小为 $v^2$ 的向量，而负号表示与运动方向相反。写成份量形式，\n$$\n\\frac{dv_x}{dt} = - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_x, \\quad\n\\frac{dv_y}{dt} = - g - \\frac{\\frac{1}{2} \\rho C_d A}{m} \\, v \\, v_y.\n$$\n运动学给出\n$$\n\\frac{dx}{dt} = v_x, \\quad \\frac{dy}{dt} = v_y.\n$$\n\n发射时（$t=0$）从地面（$x(0)=0$，$y(0)=0$）的初始条件由初速度 $v_0$ 和角度 $\\theta$（以度为单位，转换为弧度 $\\theta_\\mathrm{rad}$）决定：\n$$\nv_x(0) = v_0 \\cos(\\theta_\\mathrm{rad}), \\quad v_y(0) = v_0 \\sin(\\theta_\\mathrm{rad}).\n$$\n\n这些耦合的、非线性的、一阶常微分方程在二次阻力下通常没有闭式解，因此我们进行数值求解。一个稳健的选择是经典的四阶龙格-库塔 (RK4) 方法。对于状态向量 $\\mathbf{s} = (x, y, v_x, v_y)$ 和时间步长 $\\Delta t$，定义右端项 $\\mathbf{f}(\\mathbf{s}) = (v_x, v_y, a_x, a_y)$，其中\n$$\na_x = - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_x, \\quad a_y = - g - \\frac{1}{2} \\frac{\\rho C_d A}{m} v v_y, \\quad v = \\sqrt{v_x^2 + v_y^2}.\n$$\n给定在时间 $t_n$ 时的 $\\mathbf{s}_n$，RK4 方法通过以下方式推进到 $t_{n+1} = t_n + \\Delta t$ 时的 $\\mathbf{s}_{n+1}$：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{s}_n), \\\\\n\\mathbf{k}_2 = \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_1 \\right), \\\\\n\\mathbf{k}_3 = \\mathbf{f}\\left(\\mathbf{s}_n + \\tfrac{1}{2}\\Delta t \\, \\mathbf{k}_2 \\right), \\\\\n\\mathbf{k}_4 = \\mathbf{f}\\left(\\mathbf{s}_n + \\Delta t \\, \\mathbf{k}_3 \\right), \\\\\n\\mathbf{s}_{n+1} = \\mathbf{s}_n + \\frac{\\Delta t}{6} \\left( \\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4 \\right).\n\\end{aligned}\n$$\n\n终止与事件处理：\n- 我们随时间向前积分，直到满足以下三个条件之一：(i) 水平方向上达到或超过墙壁 ($x \\ge D$)，(ii) 炮弹击中地面 ($y  0$)，或 (iii) 达到最大模拟时间 $t_{\\max}$ 以避免在退化情况（例如，零水平速度）下出现无限循环。\n- 为评估在墙壁确切位置 $x=D$ 处的垂直位置，我们在满足 $x_\\text{prev}  D \\le x_\\text{next}$ 的最后两个积分状态之间执行线性插值。将这两个包夹状态表示为 $(x_\\text{prev}, y_\\text{prev})$ 和 $(x_\\text{next}, y_\\text{next})$，且 $x_\\text{next} \\ne x_\\text{prev}$，则插值得到的高度为\n$$\ny(D) \\approx y_\\text{prev} + \\frac{D - x_\\text{prev}}{x_\\text{next} - x_\\text{prev}} \\left( y_\\text{next} - y_\\text{prev} \\right).\n$$\n- 当且仅当 $y(D) \\ge H$ 且炮弹在到达 $x = D$ 之前没有落地时，才认为越过墙壁。\n\n数值参数：\n- 我们使用指定的 $g = 9.81\\,\\mathrm{m/s^2}$ 和 $\\rho = 1.225\\,\\mathrm{kg/m^3}$。\n- 对于测试套件中的距离和速度，一个固定的时间步长如 $\\Delta t = 10^{-3}\\,\\mathrm{s}$ 可以在精度和计算成本之间取得平衡。\n- 最大模拟时间 $t_{\\max}$ 可以设置为一个足够大的值（例如 $t_{\\max} = 200\\,\\mathrm{s}$）以确保终止。\n\n正确性考量：\n- 对于光滑的右端项，RK4 格式对 $\\Delta t$ 具有四阶精度。阻力和引力是状态的光滑函数，因此该方法是合适的。\n- 当 $\\Delta t$ 很小时，在 $x$ 方向进行线性插值是合理的，因为状态平滑变化，且 $x_\\text{prev}$ 和 $x_\\text{next}$ 之间的距离很小。\n\n应用于测试套件：\n我们现在对每个用例进行定性分析；程序将执行精确的数值评估和比较。\n\n1. 用例1：$m = 5.0\\,\\mathrm{kg}$，$r = 0.06\\,\\mathrm{m}$，$C_d = 0.47$，$v_0 = 200.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 100.0\\,\\mathrm{m}$，$H = 10.0\\,\\mathrm{m}$。即使没有阻力，在 $x = D$ 处的高度也相当大（约为 $10^2\\,\\mathrm{m}$ 的量级），因此计入阻力后，$y(D)$ 仍然远大于 $H$。程序得出 True。\n2. 用例2：$\\theta = 90.0^\\circ$ 意味着 $v_x(0) = 0$。炮弹垂直运动，永远无法到达 $x = D = 50.0\\,\\mathrm{m}$，因此无法越过墙壁。程序得出 False。\n3. 用例3：$D = 0.0\\,\\mathrm{m}$ 意味着我们将初始高度 $y(0) = 0$ 与 $H = 1.0\\,\\mathrm{m}$ 进行比较。由于 $0  1.0$，未越过墙壁。程序得出 False。\n4. 用例4：在真空 ($C_d = 0.0$) 中，$v_0 = 20.0\\,\\mathrm{m/s}$ 和 $\\theta = 10.0^\\circ$ 产生一个低且快速下降的弹道，在 $x$ 到达 $D = 30.0\\,\\mathrm{m}$ 之前就击中地面（这在无阻力极限情况下可以解析地验证），因此未越过墙壁。程序得出 False。\n5. 用例5：$v_0 = 250.0\\,\\mathrm{m/s}$，$\\theta = 45.0^\\circ$，$D = 300.0\\,\\mathrm{m}$，$H = 30.0\\,\\mathrm{m}$。炮弹大约在几秒钟内到达 $x = 300.0\\,\\mathrm{m}$，并且尽管有阻力，仍保持在相当高的高度；因此 $y(D) \\ge H$。程序得出 True。\n\n因此，五个测试用例按顺序的预期布尔值输出列表是：\n[True, False, False, False, True]。\n\n附带的程序实现了 RK4 积分器、事件检测、在 $x = D$ 处的插值，并精确打印所需的输出格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_clearance(m, r, Cd, rho, v0, theta_deg, D, H, g=9.81, dt=1e-3, t_max=200.0):\n    \"\"\"\n    Simulate a projectile with quadratic drag and determine if it clears a wall.\n\n    Parameters:\n        m (float): mass [kg]\n        r (float): radius [m]\n        Cd (float): drag coefficient [-]\n        rho (float): air density [kg/m^3]\n        v0 (float): initial speed [m/s]\n        theta_deg (float): launch angle [deg]\n        D (float): wall horizontal distance [m]\n        H (float): wall height [m]\n        g (float): gravitational acceleration [m/s^2]\n        dt (float): time step [s]\n        t_max (float): maximum simulation time [s]\n\n    Returns:\n        bool: True if clears (y(D) = H before ground impact), else False.\n    \"\"\"\n    # Handle trivial D == 0 without integrating\n    if D == 0.0:\n        # Launched from y=0, so cannot clear any positive H\n        return 0.0 = H\n\n    # Cross-sectional area of sphere\n    A = np.pi * r * r\n\n    # Initial state\n    theta = np.deg2rad(theta_deg)\n    vx = v0 * np.cos(theta)\n    vy = v0 * np.sin(theta)\n    x = 0.0\n    y = 0.0\n    t = 0.0\n\n    # Precompute drag factor\n    drag_coeff_factor = 0.5 * rho * Cd * A / m\n\n    # Keep previous state for interpolation\n    prev_x, prev_y = x, y\n\n    # Integration loop using RK4\n    while t  t_max:\n        if x = D:\n            break\n        if y  0.0:\n            # Impacted ground before reaching the wall\n            return False\n\n        # Store current for interpolation after step\n        prev_x, prev_y = x, y\n\n        # Define RHS function\n        def rhs(state):\n            sx, sy, svx, svy = state\n            v = np.hypot(svx, svy)\n            ax = -drag_coeff_factor * v * svx\n            ay = -g - drag_coeff_factor * v * svy\n            return np.array([svx, svy, ax, ay], dtype=float)\n\n        state = np.array([x, y, vx, vy], dtype=float)\n\n        k1 = rhs(state)\n        k2 = rhs(state + 0.5 * dt * k1)\n        k3 = rhs(state + 0.5 * dt * k2)\n        k4 = rhs(state + dt * k3)\n\n        state_next = state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n\n        x, y, vx, vy = state_next\n        t += dt\n\n        # Check if we have crossed or reached the wall this step\n        if x = D:\n            dx = x - prev_x\n            if dx == 0.0:\n                # No horizontal progress; cannot interpolate meaningfully\n                # Let the loop continue (will hit t_max or ground)\n                continue\n            # Linear interpolation to find y at x = D\n            frac = (D - prev_x) / dx\n            y_at_D = prev_y + frac * (y - prev_y)\n            return y_at_D = H\n\n    # If loop exits due to time max or other reasons without reaching D, or check at end\n    if x = D:\n        # If exactly at or beyond D at final step, compute y_at_D by interpolation\n        dx = x - prev_x\n        if dx == 0.0:\n            # Degenerate; treat as not cleared unless y itself is defined at D (unlikely)\n            return y = H\n        frac = (D - prev_x) / dx\n        y_at_D = prev_y + frac * (y - prev_y)\n        return y_at_D = H\n\n    # Did not reach the wall\n    return False\n\ndef solve():\n    # Common parameters\n    rho = 1.225  # kg/m^3\n    g = 9.81     # m/s^2\n\n    # Test cases as tuples: (m, r, Cd, rho, v0, theta_deg, D, H)\n    test_cases = [\n        # Case 1: happy path, clears easily\n        (5.0, 0.06, 0.47, rho, 200.0, 45.0, 100.0, 10.0),\n        # Case 2: vertical launch; never reaches the wall\n        (5.0, 0.06, 0.47, rho, 100.0, 90.0, 50.0, 5.0),\n        # Case 3: wall at launch point\n        (5.0, 0.06, 0.47, rho, 100.0, 45.0, 0.0, 1.0),\n        # Case 4: low speed, vacuum; hits ground before reaching D\n        (5.0, 0.06, 0.0,  rho, 20.0,  10.0, 30.0, 0.1),\n        # Case 5: plausible medieval high-performance shot\n        (5.0, 0.06, 0.47, rho, 250.0, 45.0, 300.0, 30.0),\n    ]\n\n    results = []\n    for (m, r, Cd, rho_i, v0, theta_deg, D, H) in test_cases:\n        clears = simulate_clearance(\n            m=m, r=r, Cd=Cd, rho=rho_i, v0=v0,\n            theta_deg=theta_deg, D=D, H=H, g=g, dt=1e-3, t_max=200.0\n        )\n        results.append(clears)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2430459"}, {"introduction": "在掌握了基本的轨迹模拟之后，我们来挑战一个更高级的问题：如何精确命中目标？这个问题引入了计算物理学中一个强大的技术——“打靶法”（shooting method）。你将学习如何将一个边界值问题（即给定起点和终点）转化为一个根求解问题，并通过结合你的轨迹模拟器和根求解算法，来精确确定击中目标所需的发射角度。[@problem_id:2430429]", "problem": "质量为 $m$ 的二维抛射体从原点以初速度 $v_0$、与水平面夹角为 $\\theta$ 的发射角发射。抛射体在均匀重力加速度 $\\mathbf{g} = (0,-g)$ 下运动，并受到与速度平方成正比、方向与瞬时速度相反的二次空气动力阻力。使用牛顿第二定律对阻力进行建模，如下所示。设状态为 $\\mathbf{r}(t) = (x(t),y(t))$ 和 $\\mathbf{v}(t) = (v_x(t),v_y(t))$，其中 $v(t) = \\sqrt{v_x(t)^2 + v_y(t)^2}$。运动方程为\n$$\n\\frac{d x}{d t} = v_x, \\quad \\frac{d y}{d t} = v_y,\n$$\n$$\n\\frac{d v_x}{d t} = -k\\, v\\, v_x, \\quad \\frac{d v_y}{d t} = -g - k\\, v\\, v_y,\n$$\n初始条件为\n$$\nx(0) = 0,\\quad y(0) = 0,\\quad v_x(0) = v_0 \\cos\\theta,\\quad v_y(0) = v_0 \\sin\\theta.\n$$\n阻力参数 $k$ 定义为\n$$\nk = \\frac{\\tfrac{1}{2}\\,\\rho\\, C_d\\, A}{m},\n$$\n其中 $\\rho$ 是空气密度，$C_d$ 是阻力系数，$A$ 是横截面积。\n\n你的任务是编写一个完整的、可运行的程序，对于每个目标点 $(x_T,y_T)$，使用求根算法来确定所有能使抛射体在高度 $y = y_T$ 处通过垂直线 $x = x_T$ 的发射角 $\\theta \\in (0,\\tfrac{\\pi}{2})$（严格介于水平和垂直之间）。求根过程必须应用于一个根据第一性原理构造的、以发射角为变量的标量函数，具体如下。\n\n1. 对于给定的 $\\theta$，定义标量函数\n$$\nF(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T,\n$$\n其中 $t^\\star(\\theta)$ 是以角度 $\\theta$ 和速度 $v_0$ 发射的飞行过程中 $x\\big(t^\\star(\\theta)\\big) = x_T$ 第一次（如果有的话）出现的时间。如果抛射体从未到达 $x_T$（例如，在 $x$ 到达 $x_T$ 之前就以 $y=0$ 落地），则 $F(\\theta)$ 未定义，该 $\\theta$ 不应用于求根的括号对中。\n\n2. 一个有效的解角度 $\\theta^\\star$ 满足 $F(\\theta^\\star) = 0$。你的程序必须系统地搜索区间 $\\theta \\in [\\theta_{\\min}, \\theta_{\\max}]$（其中 $\\theta_{\\min} = 0.1^\\circ$ 和 $\\theta_{\\max} = 89.9^\\circ$）以检测 $F(\\theta)$ 变号的子区间，然后对每个检测到的子区间应用一维求根算法（例如，区间法）以收敛到一个根。\n\n3. 如果存在多个不同的根，必须找到并报告所有在 $(0^\\circ,90^\\circ)$ 内的此类角度。如果不存在根，则为该情况报告一个空列表。\n\n数值要求和约定：\n\n- 使用上述微分方程和初始条件作为唯一的物理模型；不要代入任何闭合形式的轨迹公式。\n- 实现一个数值常微分方程积分器，当 $x(t)$ 首次等于 $x_T$ 时（如果发生）或当抛射体在下降过程中击中地面 $y(t)=0$ 时停止。使用足够严格的容差以可靠地检测穿越。\n- 距离单位必须是米，时间单位是秒，质量单位是千克，空气密度单位是千克/立方米，面积单位是平方米，加速度单位是米/平方秒。角度必须以度为单位报告。\n- 报告每个解角度，以度为单位，四舍五入到三位小数。\n- 如果在穿越时间 $t^\\star$ 时，值 $|y(t^\\star) - y_T|$ 在 $10^{-3}$ 米以内，则该解角度是可接受的。你的求根容差应确保达到此目标精度。\n- 为保证可复现性，对所有测试用例使用以下固定的物理参数：$m = 0.145$ 千克，$\\rho = 1.225$ 千克/立方米，$C_d = 0.47$，$A = 0.0042$ 平方米，以及 $g = 9.81$ 米/平方秒。\n\n覆盖不同情况的测试套件：\n\n- 情况 1（理想路径，地面目标，预计有两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (80.0, 0.0)$ 米。\n- 情况 2（高处目标，通常有一或两个解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (60.0, 10.0)$ 米。\n- 情况 3（近程，预计有两个解）：$v_0 = 30.0$ 米/秒，$(x_T,y_T) = (30.0, 0.0)$ 米。\n- 情况 4（超出最大射程，预计无解）：$v_0 = 40.0$ 米/秒，$(x_T,y_T) = (200.0, 0.0)$ 米。\n\n程序输入和输出规范：\n\n- 没有外部输入。使用上述确切的常数和测试套件。\n- 你的程序应生成单行输出，其中包含四个测试用例的结果，格式为一个用方括号括起来的逗号分隔列表。每个用例的结果必须是一个以度为单位的解角度列表，按升序排序并四舍五入到三位小数。如果某个用例没有解，则为该用例输出一个空列表。\n- 例如，要求的整体输出格式类似于 $[ [\\ldots], [\\ldots], [\\ldots], [\\ldots] ]$，其中数值条目以十进制形式显示，没有多余的文本。\n\n你的程序必须是完整的，并且按所提供的方式可运行，它必须使用应用于如上定义的 $F(\\theta)$ 的求根算法来为每个用例定位解角度。角度必须以度为单位报告。", "solution": "所提出的问题是计算物理学中一个定义明确的标准练习。它具有科学依据，数学上一致，并且提供了求解所需的所有参数。该物理模型基于带有二次空气阻力的牛顿第二定律，是抛射体在粘性介质中运动的典型表示。这个数值任务是找到使抛射体通过特定目标点的发射角，这构成了一个边值问题。规定的求解方法——打靶法与标量函数的求根算法相结合——是解决此类问题的一种稳健且合适的技术。因此，该问题是有效的，我们将继续提供一个完整的解决方案。\n\n问题的核心是求解一个耦合的一阶常微分方程（ODE）组。设系统在时间 $t$ 的状态由向量 $\\mathbf{S}(t) = [x(t), y(t), v_x(t), v_y(t)]^T$ 描述。运动方程可以写成 $\\frac{d\\mathbf{S}}{dt} = \\mathbf{f}(t, \\mathbf{S})$ 的形式，其中函数 $\\mathbf{f}$ 定义为：\n$$\n\\mathbf{f}(t, \\mathbf{S}) = \n\\begin{pmatrix}\nv_x \\\\\nv_y \\\\\n-k \\sqrt{v_x^2 + v_y^2} \\, v_x \\\\\n-g - k \\sqrt{v_x^2 + v_y^2} \\, v_y\n\\end{pmatrix}\n$$\n在 $t=0$ 时的初始状态由 $\\mathbf{S}(0) = [0, 0, v_0 \\cos\\theta, v_0 \\sin\\theta]^T$ 给出。参数 $\\theta$ 是发射角，这是我们必须确定的。\n\n对于这个系统，轨迹 $\\mathbf{r}(t)$ 的直接解析解不存在。我们必须采用数值方法。问题要求我们找到使轨迹通过目标点 $(x_T, y_T)$ 的 $\\theta$ 值。这是一个边值问题。我们将使用“打靶法”来解决它，该方法将边值问题转化为一个求根问题。\n\n打靶法按以下步骤进行：\n1.  我们选择一个试验发射角 $\\theta$。这完全确定了初始条件 $\\mathbf{S}(0)$。\n2.  我们从 $t=0$ 开始对常微分方程组进行数值积分。这个过程就是“发射”抛射体。\n3.  我们监控轨迹，以找到抛射体水平位置 $x(t)$ 首次等于目标水平位置 $x_T$ 的时间 $t^\\star$。\n4.  在这个时间 $t^\\star$，我们评估抛射体的高度 $y(t^\\star)$。\n5.  我们定义一个标量目标函数 $F(\\theta)$，即抛射体在 $x=x_T$ 处的高度与目标高度 $y_T$ 之间的差：\n    $$\n    F(\\theta) = y\\big(t^\\star(\\theta)\\big) - y_T\n    $$\n    一个解角度 $\\theta^\\star$ 是使 $F(\\theta^\\star) = 0$ 的角度。因此，问题被简化为找到函数 $F(\\theta)$ 的根。\n\n为了实现这种方法，我们需要一个稳健的常微分方程积分器。SciPy 库中的 `solve_ivp` 函数是完成此任务的绝佳工具。`solve_ivp` 的一个关键特性是它能够检测“事件”——即状态和时间的某个函数变为零的条件。我们将使用此功能来精确确定穿越时间 $t^\\star$，而无需积分到固定的最大时间然后进行插值。\n\n我们定义两个终止事件函数：\n1.  `event_reach_x_target(t, S)`：此函数返回 $x(t) - x_T$。当该值为零时，积分器将停止，表示抛射体已到达目标的横坐标。\n2.  `event_hit_ground(t, S)`：此函数返回 $y(t)$。我们将其配置为仅当 $y(t)$ 减小时（即抛射体正在下落）触发，这标志着抛射体在到达 $x=x_T$ 之前已经落地。\n\n函数 $F(\\theta)$ 是通过为给定的 $\\theta$ 调用常微分方程求解器来构造的。如果积分因 `event_reach_x_target` 事件而终止，我们计算并返回 $y(t^\\star) - y_T$。如果积分因 `event_hit_ground` 事件而终止，或者在未触发任何事件的情况下达到最大模拟时间，则意味着轨迹射程不足。在这种情况下，函数 $F(\\theta)$ 对于区间划分的目的被认为是未定义的，我们可以返回一个非数值，如 `NaN`（非数字），来表示这一点。\n\n为了在指定区间 $\\theta \\in [0.1^\\circ, 89.9^\\circ]$ 内找到 $F(\\theta)=0$ 的所有根，我们采用一个两阶段过程：\n1.  **划分区间**：我们首先将搜索区间离散化为一个精细的角度网格。我们评估网格上每个点的 $F(\\theta)$。通过搜索函数符号发生变化的相邻网格点 $(\\theta_i, \\theta_{i+1})$（即 $F(\\theta_i) \\cdot F(\\theta_{i+1})  0$），我们根据介值定理确定保证至少包含一个根的子区间。正确处理 `NaN` 情况非常重要，因为一个有效的括号区间需要在两端都有定义的数值。\n2.  **求解**：对于找到的每个括号区间 $[\\theta_a, \\theta_b]$，我们应用一个数值求根算法。在 `scipy.optimize.brentq` 中实现的 Brent 方法是一个非常有效的选择。它结合了二分法的保证收敛性和割线法的更快收敛性，是在已知括号区间时进行一维求根的标准方法。求根器的容差将被设定以确保在角度和最终目标高度上都达到所需的精度。\n\n这种数值积分、事件检测、划分区间和求根的系统性程序将被应用于每个测试用例，以找到所有有效的发射角。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile motion problem for all test cases.\n    \"\"\"\n    # Fixed physical parameters\n    M = 0.145  # mass in kg\n    RHO = 1.225  # air density in kg/m^3\n    C_D = 0.47  # drag coefficient (dimensionless)\n    A = 0.0042  # cross-sectional area in m^2\n    G = 9.81  # gravitational acceleration in m/s^2\n\n    # Derived drag parameter k = (rho * C_d * A) / (2 * m)\n    K = (0.5 * RHO * C_D * A) / M\n\n    # Test suite\n    test_cases = [\n        (40.0, (80.0, 0.0)),   # Case 1\n        (40.0, (60.0, 10.0)),  # Case 2\n        (30.0, (30.0, 0.0)),   # Case 3\n        (40.0, (200.0, 0.0)),  # Case 4\n    ]\n\n    def derivatives(t, state, k, g):\n        \"\"\"\n        Computes the derivatives for the system of ODEs.\n        state = [x, y, v_x, v_y]\n        \"\"\"\n        x, y, vx, vy = state\n        v = np.sqrt(vx**2 + vy**2)\n        \n        # Avoid division by zero if velocity is zero, though unlikely in this problem.\n        if v == 0:\n            ax = 0\n            ay = -g\n        else:\n            ax = -k * v * vx\n            ay = -g - k * v * vy\n            \n        return [vx, vy, ax, ay]\n\n    def calculate_y_error_at_xT(theta_deg, v0, xT, yT, k_param, g_param):\n        \"\"\"\n        Calculates the error F(theta) = y(t*) - yT for a given launch angle.\n        Returns np.nan if the projectile does not reach xT.\n        \"\"\"\n        theta_rad = np.deg2rad(theta_deg)\n        vx0 = v0 * np.cos(theta_rad)\n        vy0 = v0 * np.sin(theta_rad)\n        \n        initial_state = [0.0, 0.0, vx0, vy0]\n        \n        # Event: projectile reaches the target's x-coordinate\n        def reach_x_target(t, state, k, g):\n            return state[0] - xT\n        reach_x_target.terminal = True\n        reach_x_target.direction = 1 # Trigger only when x is increasing\n\n        # Event: projectile hits the ground (y=0)\n        def hit_ground(t, state, k, g):\n            return state[1]\n        hit_ground.terminal = True\n        hit_ground.direction = -1 # Trigger only when y is decreasing\n\n        t_span = (0, 100) # Max integration time of 100s is sufficient\n        sol = solve_ivp(\n            fun=derivatives,\n            t_span=t_span,\n            y0=initial_state,\n            args=(k_param, g_param),\n            events=[reach_x_target, hit_ground],\n            dense_output=True,\n            rtol=1e-8,\n            atol=1e-8\n        )\n\n        # Check which event terminated the integration\n        if sol.status == 1 and sol.t_events[0].size > 0:\n            # The 'reach_x_target' event was triggered\n            y_at_t_star = sol.y_events[0][0][1]\n            return y_at_t_star - yT\n        else:\n            # Projectile hit the ground first or integration timed out\n            return np.nan\n\n    all_results = []\n    for v0, (xT, yT) in test_cases:\n        \n        # Define the function for root finding, which depends on the case parameters\n        objective_func = lambda th: calculate_y_error_at_xT(th, v0, xT, yT, K, G)\n\n        # 1. Bracketing stage: Scan the angle range to find sign changes\n        theta_min_deg = 0.1\n        theta_max_deg = 89.9\n        scan_step_deg = 0.5  # Step size for scanning\n        \n        angles_to_scan = np.arange(theta_min_deg, theta_max_deg + scan_step_deg, scan_step_deg)\n        f_values = np.array([objective_func(th) for th in angles_to_scan])\n        \n        case_roots = []\n        for i in range(len(angles_to_scan) - 1):\n            th1, f1 = angles_to_scan[i], f_values[i]\n            th2, f2 = angles_to_scan[i+1], f_values[i+1]\n\n            if not np.isnan(f1) and not np.isnan(f2):\n                if f1 * f2  0:\n                    # Found a bracket [th1, th2]\n                    try:\n                        # 2. Solving stage: Find the root within the bracket\n                        root_deg = brentq(objective_func, th1, th2, xtol=1e-5)\n                        # Check if this root is a duplicate before adding\n                        is_duplicate = False\n                        for existing_root in case_roots:\n                            if abs(root_deg - existing_root)  1e-4:\n                                is_duplicate = True\n                                break\n                        if not is_duplicate:\n                            case_roots.append(root_deg)\n                    except ValueError:\n                        # brentq can fail if signs are not opposite, though our check prevents this.\n                        pass\n        \n        case_roots.sort()\n        all_results.append([round(r, 3) for r in case_roots])\n\n    # Format the final output string as specified\n    case_strs = []\n    for res_list in all_results:\n        num_strs = [f\"{num:.3f}\" for num in res_list]\n        case_strs.append(f\"[{','.join(num_strs)}]\")\n    \n    print(f\"[{','.join(case_strs)}]\")\n\nsolve()\n```", "id": "2430429"}, {"introduction": "除了命中特定目标，我们常常还关心如何使某个性能指标达到最优，例如实现最大射程。由于空气阻力的存在，决定最优发射角度的函数无法解析求解，这为我们提供了探索数值优化方法的绝佳机会。在此练习中，你将使用黄金分割搜索（Golden-section search）算法——一种无需导数的稳健优化方法——来系统地寻找能够最大化 projectile 射程的发射角度。[@problem_id:2398598]", "problem": "要求您实现一个完整的程序，使用黄金分割搜索来最大化一个只能通过数值模拟获得的单变量目标函数。该目标函数是在二次空气阻力作用下，以速度 $v_0$ 和角度 $\\theta$（单位为度）从地面发射的抛体的水平射程（单位为米）。运动方程源于牛顿第二定律，由以下公式给出\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\quad\n\\frac{d\\mathbf{v}}{dt} = -g \\,\\mathbf{e}_y - \\frac{k}{m}\\,\\|\\mathbf{v}\\|\\,\\mathbf{v},\n$$\n其中 $\\mathbf{r} = (x,y)$ 是位置（单位为米），$\\mathbf{v} = (v_x,v_y)$ 是速度（单位为米/秒），$m$ 是质量（单位为千克），$g$ 是重力加速度（单位为米/秒平方），$k$ 是二次阻力系数（单位为千克/米），$\\mathbf{e}_y$ 是垂直方向的单位向量。在时间 $t=0$ 时的初始条件为\n$$\nx(0)=0,\\quad y(0)=0,\\quad v_x(0)=v_0\\cos\\theta,\\quad v_y(0)=v_0\\sin\\theta.\n$$\n将水平射程 $R(\\theta)$ 定义为轨迹首次返回地面时 $x(t)$ 的值，即满足 $y(t)=0$ 的最小 $t>0$。使用地面上方的最后一步和下方的第一步之间的线性插值来估计着地点。由于当 $k>0$ 时，$R(\\theta)$ 没有闭式解，因此必须通过数值时间积分来计算。\n\n建模和计算的基本依据：\n- 使用牛顿第二定律推导上述系统。\n- 将时间离散化，并使用经典的四阶 Runge–Kutta 方法以固定的时间步长 $\\Delta t = 0.005$ 秒来演化系统。\n- 检测着地点，并使用线性插值来估算精确的着陆点 $x$ 坐标。\n- 假设 $g$ 和 $k$ 为常数。\n\n黄金分割搜索规范：\n- 在闭区间 $[\\underline{\\theta},\\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$ 上最大化 $R(\\theta)$。\n- 假设 $R(\\theta)$ 在此区间上是单峰的。\n- 使用黄金比例共轭 $\\varphi = (\\sqrt{5}-1)/2$ 实现黄金分割搜索，以在无需导数的情况下界定并缩小搜索区间。\n- 当区间宽度小于或等于 $\\varepsilon_\\theta = 10^{-5}$ 度时，或在达到最大迭代次数 $N_{\\max} = 64$ 后终止，以先发生者为准。\n- 返回最终区间的中点作为最大值点 $\\theta^\\star$。\n\n单位和数值要求：\n- 所有距离必须以米为单位计算。\n- 所有时间必须以秒为单位计算。\n- 在整个搜索过程中，所有角度都必须以度为单位处理，并以度为单位报告。\n- 将报告的每个最优角度四舍五入到4位小数。\n\n测试套件：\n实现您的程序，使其能解决以下三个测试用例，每个用例由 $(v_0, m, k, g)$ 定义，单位如上所述。对于每个用例，使用指定的算法和数值方法计算出最大化射程的发射角 $\\theta^\\star$（以度为单位）。\n\n- 用例 A（无阻力基准，预期内部最大值在 $45^\\circ$ 附近）：$(v_0, m, k, g) = (50, 1.0, 0.0, 9.81)$。\n- 用例 B（中等二次阻力）：$(v_0, m, k, g) = (50, 0.145, 0.001286, 9.81)$。\n- 用例 C（强二次阻力，最大值可能趋向边界）：$(v_0, m, k, g) = (20, 0.005, 0.001372, 9.81)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按上述测试用例的顺序包含三个最大化射程的角度（以度为单位），每个角度四舍五入到4位小数，例如：“[45.0000,38.1234,5.6789]”。打印的列表中不得有空格。", "solution": "所述问题是有效的。这是一个计算物理和数值优化中的适定问题。所有参数、方法和条件都已足够清晰地指定，并且在科学上是合理的。该问题需要实现数值模拟与优化算法的结合，这是科学和工程领域的标准流程。我们将着手解决此问题。\n\n这个问题的核心是找到一个发射角 $\\theta$，使得受二次空气阻力影响的抛体的水平射程 $R(\\theta)$ 最大化。由于函数 $R(\\theta)$ 没有闭式解，我们必须通过数值方法来构造它。这个过程包括两个主要部分：首先，一个用于求解运动方程的数值积分器；其次，一个用于寻找结果函数最大值的优化算法。\n\n让我们首先将常微分方程（ODE）系统形式化。抛体在任意时间 $t$ 的状态由其位置 $\\mathbf{r}(t) = (x(t), y(t))$ 和速度 $\\mathbf{v}(t) = (v_x(t), v_y(t))$ 描述。我们可以定义一个状态向量 $\\mathbf{y}(t) \\in \\mathbb{R}^4$ 如下：\n$$\n\\mathbf{y}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\\\ v_x(t) \\\\ v_y(t) \\end{pmatrix}\n$$\n给定的控制方程是 $\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}$ 和 $\\frac{d\\mathbf{v}}{dt} = -g_v\\mathbf{e}_y - \\frac{k}{m}\\|\\mathbf{v}\\|\\mathbf{v}$。这里要精确一点，问题中使用的是 $g$ 而不是 $g_v$。所以，$\\frac{d\\mathbf{v}}{dt} = -g\\mathbf{e}_y - \\frac{k}{m}\\|\\mathbf{v}\\|\\mathbf{v}$。我们可以将其写成一个包含四个一阶常微分方程的系统，$\\frac{d\\mathbf{y}}{dt} = f(t, \\mathbf{y})$：\n$$\nf(t, \\mathbf{y}) = \\begin{pmatrix} v_x \\\\ v_y \\\\ -\\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_x \\\\ -g - \\frac{k}{m} \\sqrt{v_x^2 + v_y^2} \\cdot v_y \\end{pmatrix}\n$$\n对于给定的发射速度 $v_0$ 和角度 $\\theta$，在 $t=0$ 时的初始条件为：\n$$\n\\mathbf{y}(0) = \\begin{pmatrix} 0 \\\\ 0 \\\\ v_0 \\cos(\\theta_{rad}) \\\\ v_0 \\sin(\\theta_{rad}) \\end{pmatrix}\n$$\n请注意，角度 $\\theta$ 以度为单位给出，在使用三角函数时必须转换为弧度（$\\theta_{rad}$）。\n\n为求解此系统，我们采用经典的四阶 Runge-Kutta (RK4) 方法。给定在时间 $t_n$ 的状态 $\\mathbf{y}_n$，在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $\\mathbf{y}_{n+1}$ 可通过以下公式近似得到：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中，中间向量斜率为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{y}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(t_n + \\Delta t, \\mathbf{y}_n + \\Delta t\\mathbf{k}_3)\n\\end{aligned}\n$$\n我们以固定的时间步长 $\\Delta t = 0.005$ 秒，从 $\\mathbf{y}(0)$ 开始，逐步执行此积分。对于给定的 $\\theta$，当抛体击中地面时，模拟终止。这是通过检测垂直位置 $y(t)$ 变为负值来判断的。设 $\\mathbf{y}_{n-1}$ 为最后一个满足 $y_{n-1} \\ge 0$ 的状态，$\\mathbf{y}_{n}$ 为第一个满足 $y_{n}  0$ 的状态。水平射程 $R(\\theta)$ 是 $y(t)=0$ 时刻 $x$ 坐标的插值。通过在 $(x_{n-1}, y_{n-1})$ 和 $(x_n, y_n)$ 之间进行线性插值，我们得到射程：\n$$\nR(\\theta) = x_{n-1} - y_{n-1} \\frac{x_n - x_{n-1}}{y_n - y_{n-1}}\n$$\n这个过程定义了我们必须最大化的目标函数 $R(\\theta)$。\n\n优化过程使用黄金分割搜索算法，该算法适用于在闭区间上最大化一个单峰函数而无需导数。搜索区间为 $[\\underline{\\theta}, \\overline{\\theta}] = [0.1^\\circ, 89.9^\\circ]$。设某次迭代的区间为 $[a, b]$。我们计算两个内部点 $c$ 和 $d$：\n$$\n\\begin{aligned}\nc = b - \\varphi(b - a) \\\\\nd = a + \\varphi(b - a)\n\\end{aligned}\n$$\n其中 $\\varphi = \\frac{\\sqrt{5}-1}{2}$ 是黄金比例共轭。然后我们计算这些点的目标函数值 $R(c)$ 和 $R(d)$。\n- 如果 $R(c) > R(d)$，则最大值必定位于区间 $[a, d]$ 内。我们通过设置 $b=d$ 来更新搜索区间。\n- 如果 $R(d) \\ge R(c)$，则最大值必定位于区间 $[c, b]$ 内。我们通过设置 $a=c$ 来更新搜索区间。\n此过程被重复，每一步都将区间宽度缩小一个因子 $\\varphi$。当区间宽度 $(b-a)$ 小于或等于容差 $\\varepsilon_\\theta = 10^{-5}$ 度时，或在达到最大迭代次数 $N_{\\max} = 64$ 后，算法终止。然后将最终区间的中点 $\\frac{a+b}{2}$ 作为最优角度 $\\theta^\\star$ 报告。\n\n总的流程如下：\n1.  实现代表 ODE 系统的函数 $f(t, \\mathbf{y})$。\n2.  实现 RK4 积分步骤。\n3.  实现目标函数 $R(\\theta)$，该函数对于给定的角度 $\\theta$，使用 RK4 模拟轨迹，检测着地，并返回插值计算的射程。\n4.  实现黄金分割搜索算法，以找到使 $R(\\theta)$ 最大化的角度 $\\theta^\\star \\in [0.1, 89.9]$。\n5.  将此流程应用于提供的三个测试用例中的每一个。\n基准用例（$k=0$ 的用例 A）作为一个关键的验证点。在没有空气阻力的情况下，射程由 $R(\\theta) = (v_0^2/g) \\sin(2\\theta)$ 给出，该函数在 $\\theta = 45^\\circ$ 时取得最大值。我们对此用例的数值解应非常接近这个理论结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the projectile optimization problem for the given test cases.\n    \"\"\"\n\n    # Golden ratio conjugate as specified\n    PHI_CONJ = (np.sqrt(5) - 1.0) / 2.0\n\n    def dydt(y_state, k, m, g):\n        \"\"\"\n        Computes the derivative of the state vector for the projectile motion ODEs.\n        State vector y_state = [x, y, vx, vy].\n        \"\"\"\n        _, _, vx, vy = y_state\n        v_mag = np.sqrt(vx**2 + vy**2)\n        \n        # When v_mag is zero (at t=0), the drag term is zero.\n        # This check avoids potential division by zero if not handled carefully, though here it just multiplies.\n        if v_mag == 0.0:\n            drag_term_x = 0.0\n            drag_term_y = 0.0\n        else:\n            drag_factor = (k / m) * v_mag\n            drag_term_x = drag_factor * vx\n            drag_term_y = drag_factor * vy\n\n        ax = -drag_term_x\n        ay = -g - drag_term_y\n        \n        return np.array([vx, vy, ax, ay])\n\n    def rk4_step(f_ode, y_state, dt, k, m, g):\n        \"\"\"\n        Performs a single step of the classical fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = f_ode(y_state, k, m, g)\n        k2 = f_ode(y_state + 0.5 * dt * k1, k, m, g)\n        k3 = f_ode(y_state + 0.5 * dt * k2, k, m, g)\n        k4 = f_ode(y_state + dt * k3, k, m, g)\n        return y_state + (dt / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\n    def calculate_range(theta_deg, v0, m, k, g):\n        \"\"\"\n        Numerically simulates projectile trajectory to calculate the horizontal range.\n        This serves as the objective function R(theta).\n        \"\"\"\n        dt = 0.005  # Time step in seconds\n        \n        # Initial conditions\n        theta_rad = np.deg2rad(theta_deg)\n        y_state = np.array([\n            0.0,  # x(0)\n            0.0,  # y(0)\n            v0 * np.cos(theta_rad),  # vx(0)\n            v0 * np.sin(theta_rad)   # vy(0)\n        ])\n\n        y_prev = y_state\n        \n        # Max simulation steps to prevent infinite loops (e.g., if it never lands)\n        max_steps = 100000 \n        for _ in range(max_steps):\n            y_curr = rk4_step(dydt, y_prev, dt, k, m, g)\n            \n            # Check for ground crossing (y becomes negative)\n            if y_curr[1]  0.0 and y_prev[1] = 0.0:\n                # Linearly interpolate to find the range at y = 0\n                x_prev, y_pos_prev = y_prev[0], y_prev[1]\n                x_curr, y_pos_curr = y_curr[0], y_curr[1]\n                # Formula: R = x_prev - y_prev * (dx / dy)\n                range_val = x_prev - y_pos_prev * (x_curr - x_prev) / (y_pos_curr - y_pos_prev)\n                return range_val\n            \n            y_prev = y_curr\n            \n        # Return 0 if the projectile does not land within the maximum number of steps\n        return 0.0\n\n    def golden_section_maximize(f_obj, a, b, tol, max_iter):\n        \"\"\"\n        Maximizes a unimodal function f_obj on the interval [a, b] using golden-section search.\n        \"\"\"\n        # Pre-calculate initial interior points and their function values\n        h = b - a\n        c = b - PHI_CONJ * h\n        d = a + PHI_CONJ * h\n        f_c = f_obj(c)\n        f_d = f_obj(d)\n\n        for _ in range(max_iter):\n            if (b - a)  tol:\n                break\n            \n            if f_c  f_d:\n                b = d\n                d = c\n                f_d = f_c\n                h = b - a\n                c = b - PHI_CONJ * h\n                f_c = f_obj(c)\n            else:\n                a = c\n                c = d\n                f_c = f_d\n                h = b - a\n                d = a + PHI_CONJ * h\n                f_d = f_obj(d)\n                \n        return (a + b) / 2.0\n\n    # Test cases defined in the problem statement\n    test_cases = [\n        # (v0, m, k, g)\n        (50.0, 1.0, 0.0, 9.81),        # Case A: No drag\n        (50.0, 0.145, 0.001286, 9.81), # Case B: Moderate drag (baseball-like)\n        (20.0, 0.005, 0.001372, 9.81)  # Case C: Strong drag\n    ]\n\n    results = []\n    # Search parameters\n    theta_min, theta_max = 0.1, 89.9\n    tolerance = 1e-5\n    max_iterations = 64\n\n    for v0, m, k, g in test_cases:\n        # Create a lambda function to pass parameters to the objective function\n        objective_function = lambda theta: calculate_range(theta, v0, m, k, g)\n        \n        # Perform the optimization\n        optimal_angle = golden_section_maximize(\n            objective_function, theta_min, theta_max, tolerance, max_iterations\n        )\n        \n        # Append the rounded result\n        results.append(f\"{optimal_angle:.4f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2398598"}]}