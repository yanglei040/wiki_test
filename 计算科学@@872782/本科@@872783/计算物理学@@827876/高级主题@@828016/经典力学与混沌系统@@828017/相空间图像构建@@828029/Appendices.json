{"hands_on_practices": [{"introduction": "相图分析的基础是识别系统的平衡点，即不动点。这些点代表了系统保持静止的状态，其稳定性决定了邻近轨迹的局部行为。本练习 [@problem_id:2426930] 将指导你编写程序，为著名的达芬振子（Duffing oscillator）自动寻找并分类不动点，确定它们是鞍点、节点还是焦点，从而揭示相空间的局部动力学流。", "problem": "考虑由阻尼 Duffing 振子定义的二维自治动力系统\n$$\n\\dot{x} = y, \\qquad \\dot{y} = -\\delta\\, y + \\alpha\\, x - \\beta\\, x^3,\n$$\n其中 $x$ 和 $y$ 是无量纲状态变量，$\\alpha$、$\\beta$ 和 $\\delta$ 是实的无量纲参数。一个点 $(x^\\ast,y^\\ast)$ 是不动点，当且仅当\n$$\ny^\\ast = 0 \\quad \\text{and} \\quad -\\delta\\, y^\\ast + \\alpha\\, x^\\ast - \\beta\\, (x^\\ast)^3 = 0.\n$$\n在点 $(x,y)$ 处的雅可比矩阵是一阶偏导数矩阵\n$$\nJ(x,y) = \\begin{pmatrix}\n\\frac{\\partial \\dot{x}}{\\partial x}  \\frac{\\partial \\dot{x}}{\\partial y} \\\\\n\\frac{\\partial \\dot{y}}{\\partial x}  \\frac{\\partial \\dot{y}}{\\partial y}\n\\end{pmatrix}\n= \\begin{pmatrix}\n0  1 \\\\\n\\alpha - 3 \\beta x^2  -\\delta\n\\end{pmatrix}.\n$$\n对于下面的每一组参数，您必须在方形域 $[-2,2]\\times[-2,2]$ 内数值求解所有不动点 $(x^\\ast,y^\\ast)$，并遵循以下接受和区分标准。使用数值容差 $\\varepsilon = 10^{-9}$。如果一个候选点 $(x^\\ast,y^\\ast)$ 满足 $\\|\\,( \\dot{x}(x^\\ast,y^\\ast), \\dot{y}(x^\\ast,y^\\ast) )\\,\\|_2 \\le \\varepsilon$，则它被接受为不动点。如果两个候选点 $(x_1^\\ast,y_1^\\ast)$ 和 $(x_2^\\ast,y_2^\\ast)$ 满足 $\\sqrt{(x_1^\\ast-x_2^\\ast)^2 + (y_1^\\ast-y_2^\\ast)^2} \\le \\varepsilon$，则它们代表同一个不动点。\n\n在每个不同的不动点上，计算雅可比矩阵 $J(x^\\ast,y^\\ast)$ 及其特征值。根据基于特征值的线性稳定性，将不动点分类为以下整数代码之一：\n- 代码 $1$：鞍点 ($J$ 的行列式为负，等价于一个实特征值为正，另一个为负)。\n- 代码 $2$：稳定退化节点 (两个相等的实特征值，值为负)。\n- 代码 $3$：不稳定退化节点 (两个相等的实特征值，值为正)。\n- 代码 $4$：稳定节点 (两个不等的实特征值，均为负)。\n- 代码 $5$：不稳定节点 (两个不等的实特征值，均为正)。\n- 代码 $6$：稳定焦点 (具有严格负实部的复共轭特征值)。\n- 代码 $7$：不稳定焦点 (具有严格正实部的复共轭特征值)。\n- 代码 $8$：中心点 (实部绝对值 $\\le \\varepsilon$ 的复共轭特征值)。\n- 代码 $9$：具有零特征值的非双曲点 ($J$ 的行列式绝对值 $\\le \\varepsilon$)。\n\n在应用上述测试时，使用容差 $\\varepsilon = 10^{-9}$ 进行与零的比较；例如，如果一个实部的绝对值 $\\le \\varepsilon$，则将其视为零；如果两个实特征值的差的绝对值 $\\le \\varepsilon$，则将它们视为相等。\n\n对于每个参数组，输出域中所有不同不动点的分类代码列表，该列表通过将不动点按 $x^\\ast$ 然后按 $y^\\ast$（均为升序）进行字典序排序而得到。\n\n测试套件 (每行给出 $(\\alpha,\\beta,\\delta)$):\n- $(1,1,0)$\n- $(1,1,1)$\n- $(1,1,4)$\n- $(1,1,2.8284271247461903)$，即 $2\\sqrt{2}$ 保留至所示精度。\n- $(1,1,-1)$\n- $(-1,1,1)$\n- $(-1,1,4)$\n- $(0,1,1)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身也是一个用方括号括起来的逗号分隔列表，对应于相应参数组的代码。例如，格式必须是\n$[$ [第一组参数的代码] $,$ [第二组参数的代码] $,$ $\\dots$ $]$\n不含任何额外文本。此问题不涉及角度，也没有物理单位；所有量都是无量纲的。数值容差为 $\\varepsilon = 10^{-9}$，必须严格按照规定使用。", "solution": "问题陈述经评估是科学上可靠、适定且客观的。它构成了对一个著名动力系统——阻尼 Duffing 振子——进行线性稳定性分析的标准练习。所有参数、条件和分类标准都得到了明确且无歧义的定义。因此，该问题被认为是有效的，并将构建一个完整的解决方案。\n\n对于每个给定的参数组 $(\\alpha, \\beta, \\delta)$，解决策略包括两个主要阶段：首先，解析识别系统的不动点；其次，使用雅可比矩阵的特征值分析对它们进行分类。\n\n**1. 寻找不动点**\n\n动力系统的一个不动点 $(x^\\ast, y^\\ast)$ 必须满足平衡条件 $\\dot{x}=0$ 和 $\\dot{y}=0$。第一个条件 $\\dot{x} = y$ 直接意味着 $y^\\ast=0$。将 $y^\\ast=0$ 代入第二个条件 $\\dot{y} = -\\delta y + \\alpha x - \\beta x^3$，得到不动点 $x$ 坐标的方程：\n$$ \\alpha x^\\ast - \\beta (x^\\ast)^3 = 0 $$\n这个多项式方程可以因式分解为 $x^\\ast(\\alpha - \\beta(x^\\ast)^2) = 0$。$x^\\ast$ 的实数解取决于参数 $\\alpha$ 和 $\\beta$：\n- 一个解总是 $x^\\ast = 0$，对应于不动点 $(0, 0)$。\n- 如果比率 $\\alpha/\\beta  0$，则存在另外两个实数解：$x^\\ast = \\pm\\sqrt{\\alpha/\\beta}$。它们对应于不动点 $(\\sqrt{\\alpha/\\beta}, 0)$ 和 $(-\\sqrt{\\alpha/\\beta}, 0)$。\n- 如果 $\\alpha/\\beta \\le 0$ 或者 $\\beta = 0$（且 $\\alpha \\neq 0$），则 $x^\\ast=0$ 是唯一的实数解。\n\n所有找到的不动点都必须位于指定的域 $[-2, 2] \\times [-2, 2]$ 内。由于 $y^\\ast=0$ 总是满足的，这个要求简化为确保 $|x^\\ast| \\le 2$。然后对每个参数组的有效不动点进行字典序排序。由于 $y^\\ast$ 是常数，这等价于按 $x^\\ast$ 的值升序排序。\n\n**2. 不动点分类**\n\n对每个已排序的不动点 $(x^\\ast, y^\\ast)$，进行线性稳定性分析。该过程如下：\n\na. **雅可比矩阵**: 系统的雅可比矩阵 $J$ 在不动点 $(x^\\ast, y^\\ast)$ 处进行求值：\n$$\nJ(x^\\ast, y^\\ast) = \\begin{pmatrix}\n\\frac{\\partial \\dot{x}}{\\partial x}  \\frac{\\partial \\dot{x}}{\\partial y} \\\\\n\\frac{\\partial \\dot{y}}{\\partial x}  \\frac{\\partial \\dot{y}}{\\partial y}\n\\end{pmatrix}_{(x^\\ast, y^\\ast)}\n= \\begin{pmatrix}\n0  1 \\\\\n\\alpha - 3 \\beta (x^\\ast)^2  -\\delta\n\\end{pmatrix}\n$$\n\nb. **特征值计算**: 雅可比矩阵的特征值 $\\lambda_1$ 和 $\\lambda_2$ 通过数值方法计算。不动点附近的局部动力学由这些特征值决定。\n\nc. **分类逻辑**: 根据特征值的性质分配分类代码，对所有涉及零的比较使用指定的数值容差 $\\varepsilon = 10^{-9}$。该逻辑遵循指定的标准：\n\n- **代码 9 (非双曲/零特征值)**: 如果雅可比矩阵的行列式 $\\det(J) = \\lambda_1\\lambda_2$ 的绝对值小于或等于 $\\varepsilon$，即 $|\\lambda_1\\lambda_2| \\le \\varepsilon$，则分配此代码。\n\n- **代码 1 (鞍点)**: 如果 $\\det(J)  -\\varepsilon$，则分配此代码。这表示特征值为实数且符号相反。\n\n- 对于 $\\det(J) > \\varepsilon$ 的情况，分类取决于特征值是实数还是复共轭对。\n  - **复特征值** (如果 $|\\text{Im}(\\lambda_1)| > \\varepsilon$ 则识别): 分类由特征值实部 $\\text{Re}(\\lambda_1)$ 的符号决定。\n    - **代码 6 (稳定焦点)**: 如果 $\\text{Re}(\\lambda_1)  -\\varepsilon$。\n    - **代码 7 (不稳定焦点)**: 如果 $\\text{Re}(\\lambda_1) > \\varepsilon$。\n    - **代码 8 (中心点)**: 如果 $|\\text{Re}(\\lambda_1)| \\le \\varepsilon$。\n  - **实特征值** (如果 $|\\text{Im}(\\lambda_1)| \\le \\varepsilon$ 则识别): 分类取决于特征值是否相等及其符号。\n    - **退化节点** (如果特征值的绝对差 $|\\lambda_1 - \\lambda_2|$ 小于或等于 $\\varepsilon$，则认为它们相等):\n      - **代码 2 (稳定)**: 如果公共特征值小于 $-\\varepsilon$。\n      - **代码 3 (不稳定)**: 如果公共特征值大于 $\\varepsilon$。\n    - **不同节点** (如果 $|\\lambda_1 - \\lambda_2| > \\varepsilon$): 由于 $\\det(J) > 0$，特征值符号相同。此符号由雅可比矩阵的迹 $\\text{Tr}(J) = \\lambda_1 + \\lambda_2$ 决定。\n      - **代码 4 (稳定)**: 如果 $\\text{Tr}(J)  -\\varepsilon$。\n      - **代码 5 (不稳定)**: 如果 $\\text{Tr}(J) > \\varepsilon$。\n\n将此系统性程序实现并应用于测试套件中的每个参数组，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding and classifying fixed points for the\n    damped Duffing oscillator for a given set of parameters.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (alpha, beta, delta).\n    test_cases = [\n        (1.0, 1.0, 0.0),\n        (1.0, 1.0, 1.0),\n        (1.0, 1.0, 4.0),\n        (1.0, 1.0, 2.8284271247461903),  # 2*sqrt(2)\n        (1.0, 1.0, -1.0),\n        (-1.0, 1.0, 1.0),\n        (-1.0, 1.0, 4.0),\n        (0.0, 1.0, 1.0),\n    ]\n\n    all_results = []\n    epsilon = 1e-9\n\n    for params in test_cases:\n        alpha, beta, delta = params\n\n        # 1. Find fixed points analytically\n        fixed_points = []\n        \n        # Fixed point at x=0 is always a candidate\n        x_star_0 = 0.0\n        if abs(x_star_0) = 2.0:\n            fixed_points.append((x_star_0, 0.0))\n\n        # Other fixed points from alpha - beta*x^2 = 0\n        if beta != 0:\n            ratio = alpha / beta\n            if ratio > 0:\n                x_star_pos = np.sqrt(ratio)\n                if abs(x_star_pos) = 2.0:\n                    fixed_points.append((x_star_pos, 0.0))\n                \n                x_star_neg = -np.sqrt(ratio)\n                if abs(x_star_neg) = 2.0:\n                    fixed_points.append((x_star_neg, 0.0))\n        \n        # Remove duplicates and sort lexicographically.\n        # Sorting a list of tuples sorts by the first element, then second, etc.\n        unique_fps = sorted(list(set(fixed_points)))\n\n        # 2. Classify each fixed point\n        case_results = []\n        for fp in unique_fps:\n            x_star, y_star = fp  # y_star is always 0\n\n            # Construct the Jacobian matrix\n            jacobian = np.array([\n                [0.0, 1.0],\n                [alpha - 3.0 * beta * x_star**2, -delta]\n            ])\n            \n            # Compute eigenvalues\n            eigenvalues = np.linalg.eigvals(jacobian)\n            l1, l2 = eigenvalues[0], eigenvalues[1]\n            \n            # Classification based on eigenvalue properties\n            code = 0\n            # product l1*l2 is the determinant, which is guaranteed to be real\n            det_J = (l1 * l2).real\n            \n            if abs(det_J) = epsilon:\n                code = 9\n            elif det_J  -epsilon:\n                code = 1\n            else:  # det_J > epsilon\n                is_complex = abs(l1.imag) > epsilon\n                if is_complex:\n                    real_part = l1.real\n                    if real_part  -epsilon:\n                        code = 6  # Stable spiral\n                    elif real_part > epsilon:\n                        code = 7  # Unstable spiral\n                    else:\n                        code = 8  # Center\n                else:  # Real eigenvalues\n                    l1_real, l2_real = l1.real, l2.real\n                    \n                    # Check for degeneracy\n                    if abs(l1_real - l2_real) = epsilon:\n                        if l1_real  -epsilon:\n                            code = 2  # Stable degenerate node\n                        elif l1_real > epsilon:\n                            code = 3  # Unstable degenerate node\n                        else:\n                            # Eigenvalue is zero, so det_J is zero.\n                            # This should have been caught by the first `if`.\n                            code = 9\n                    else:\n                        # Distinct real eigenvalues\n                        # sum l1+l2 is the trace, which is real\n                        trace_J = (l1 + l2).real\n                        if trace_J  -epsilon:\n                            code = 4  # Stable node\n                        elif trace_J > epsilon:\n                            code = 5  # Unstable node\n                        # else: trace is zero, which implies D=0, a contradiction for this case.\n            \n            case_results.append(code)\n        \n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    list_of_lists_str = [f\"[{','.join(map(str, r))}]\" for r in all_results]\n    print(f\"[{','.join(list_of_lists_str)}]\")\n\nsolve()\n```", "id": "2426930"}, {"introduction": "在定位了不动点之后，下一步是理解它们是如何相互连接的，这决定了相图的全局结构。鞍点（saddle points）的稳定与不稳定流形（manifolds）构成了相图的“骨架”，如同分水岭一样将相空间划分为不同的行为区域。此练习 [@problem_id:2426894] 的核心任务是从鞍点附近的一个微小扰动出发，通过向前和向后积分动力学方程，来数值化地追踪这些关键的流形曲线。", "problem": "您需要编写一个完整的、可运行的程序，通过数值计算鞍点的稳定和非稳定流形，来构建一个二维动力系统的相空间图。该程序必须实现并积分一个二维自治常微分方程，并自动提取计算出的流形的定量诊断指标。不需要绘图或文件输入/输出；您的程序必须生成单行文本输出，其中包含针对指定初始偏移测试套件所要求的数值指标。\n\n考虑由以下一阶方程定义的保守平面系统\n$$\n\\frac{dx}{dt} = y, \\quad \\frac{dy}{dt} = x - x^{3}.\n$$\n该系统在原点处有一个鞍点平衡。在原点处的雅可比矩阵为\n$$\nJ(0,0) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix},\n$$\n其特征值为 $+1$ 和 $-1$，对应的单位特征向量分别沿着 $(1,1)$ 和 $(1,-1)$ 方向。鞍点的稳定流形和非稳定流形分别定义为当 $t \\to +\\infty$ 和 $t \\to -\\infty$ 时轨迹趋近于鞍点的点的集合。该系统是哈密顿系统，其守恒能量为\n$$\nH(x,y) = \\frac{y^{2}}{2} - \\frac{x^{2}}{2} + \\frac{x^{4}}{4},\n$$\n因此轨迹位于 $H$ 的水平集上。构成鞍点全局稳定和非稳定流形的分界线曲线是水平集 $H(x,y) = 0$。\n\n您的任务是：\n- 使用上述基本定义，为离开原点进入第一象限的非稳定流形，以及相应的稳定流形，构建数值近似。这是通过对与相应线性特征方向相切且位于分界线能级 $H=0$ 上的初始条件进行积分来完成的。不要使用任何显式预构建的流形公式；通过在原点附近强制执行 $H(x,y)=0$ 和与适当特征方向相切的条件来计算初始条件。\n- 对于第一象限中的非稳定流形分支，向前积分直到轨迹首次返回水平轴，即直到 $y=0$ 从正值穿过变为零。记录此次穿越点的 $x$ 坐标。\n- 对于第四象限中趋近于原点的稳定流形分支，向后积分（等效于对时间反向的系统进行积分）直到轨迹首次从负值到达 $y=0$。记录此次穿越点的 $x$ 坐标。\n- 对于两个分支，通过计算沿数值积分段的 $H(x(t),y(t))$ 与初始能量值的最大绝对偏差，来量化您的数值轨迹对分界线的遵循程度。此外，通过计算初始条件处系统矢量场与相关特征向量之间的夹角，来量化与线性特征向量的局部对齐程度。该角度必须以弧度报告。\n\n设计您的程序以执行以下包含三个初始偏移的测试套件，每个偏移由一个小的正标量 $\\varepsilon$ 指定，它设定了沿适当特征方向距原点的初始距离，同时保持在分界线 $H=0$ 上：\n- 情况1：$\\varepsilon = 10^{-6}$。\n- 情况2：$\\varepsilon = 10^{-3}$。\n- 情况3：$\\varepsilon = 10^{-2}$。\n\n实现要求和约定：\n- 对于第一象限中的非稳定分支，选择一个初始条件 $(x_{0},y_{0})$，其中 $x_{0} = \\varepsilon$, $y_{0}  0$，位于水平集 $H=0$ 上，并在原点处与非稳定特征方向相切。向前积分直到首次从正值穿越到零跨过 $y=0$。为避免在开始时的平凡穿越，您必须对条件 $y=0$ 使用方向敏感的事件检测，并仅检测 $y$ 值减小的穿越。使用足够大的最终积分时间，以确保对所有给定的 $\\varepsilon$ 都能检测到穿越。预期的穿越点 $x$ 坐标接近 $\\sqrt{2}$；您的程序必须计算测得的穿越点 $x$ 与 $\\sqrt{2}$ 之间的绝对差。\n- 对于第四象限中的稳定分支，选择一个初始条件 $(x_{0},y_{0})$，其中 $x_{0} = \\varepsilon$, $y_{0}  0$，位于水平集 $H=0$ 上，并在原点处与稳定特征方向相切。向后积分直到首次从负值穿越到零跨过 $y=0$，并计算测得的穿越点 $x$ 与 $\\sqrt{2}$ 之间的绝对差。\n- 仅对于非稳定分支，计算在 $(x_{0},y_{0})$ 处评估的系统矢量场与原点处的单位非稳定特征向量之间的夹角（以弧度为单位）。将此角度报告为非负弧度值。\n- 仅对于非稳定分支，报告沿积分轨迹段的哈密顿量 $H$ 与其初始值的最大绝对偏差。由于初始条件位于 $H=0$ 上，这即为沿该段哈密顿量 $H$ 的最大绝对值。\n\n所有角度必须以弧度报告。没有物理单位。\n\n数值规格：\n- 使用具有自适应步长和事件检测功能的精确时间积分器。\n- 使用足够大的积分范围以在所有情况下达到第一个 $y=0$ 穿越点，例如在向前或向后方向上的最大时间为 $T_{\\max} = 50$。\n- 使用足够严格的容差来解析流形和事件。\n\n最终输出格式：\n- 对于测试套件中的每个 $\\varepsilon$，您的程序必须按以下顺序输出一个包含四个浮点数的列表：$[\\text{unstable\\_apex\\_error}, \\text{unstable\\_angle\\_error}, \\text{unstable\\_max\\_energy\\_deviation}, \\text{stable\\_apex\\_error}]$。\n- 将三种情况的结果汇总到打印到标准输出的单行中，该行包含一个由三个按情况排列的列表组成的列表，例如 $[[r_{11},r_{12},r_{13},r_{14}],[r_{21},r_{22},r_{23},r_{24}],[r_{31},r_{32},r_{33},r_{34}]]$, 其中每个 $r_{ij}$ 都是一个浮点数。打印时，数值必须四舍五入到六位有效数字。\n\n您的程序不得读取任何输入，并且除了所需的单行输出外，不得产生任何其他输出。", "solution": "所提出的问题是计算非线性动力学中的一个标准练习，并已被验证为科学上合理、适定且客观。它要求对一个二维哈密顿系统进行稳定和非稳定流形的数值构建，并计算特定的定量指标。我们开始进行求解。\n\n该系统由以下自治常微分方程定义：\n$$\n\\frac{dx}{dt} = \\dot{x} = y\n$$\n$$\n\\frac{dy}{dt} = \\dot{y} = x - x^3\n$$\n该系统是保守的，源自哈密顿函数 $H(x,y)$：\n$$\nH(x,y) = \\frac{y^2}{2} - \\frac{x^2}{2} + \\frac{x^4}{4}\n$$\n动力学被限制在该哈密顿量的水平集上。通过设置 $\\dot{x}=0$ 和 $\\dot{y}=0$ 可以找到平衡点，这得到 $y=0$ 和 $x - x^3 = 0$。解为 $(0,0)$、$(1,0)$ 和 $(-1,0)$。我们关注的是位于原点的平衡点 $(0,0)$。\n\n原点的稳定性由矢量场 $F(x,y) = (y, x-x^3)$ 的雅可比矩阵确定：\n$$\nJ(x,y) = \\begin{pmatrix} \\frac{\\partial \\dot{x}}{\\partial x}  \\frac{\\partial \\dot{x}}{\\partial y} \\\\ \\frac{\\partial \\dot{y}}{\\partial x}  \\frac{\\partial \\dot{y}}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 1 - 3x^2  0 \\end{pmatrix}\n$$\n在原点处，它变为：\n$$\nJ(0,0) = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}\n$$\n特征值 $\\lambda$ 通过 $\\det(J - \\lambda I) = 0$ 求得，得出 $\\lambda^2 - 1 = 0$，因此 $\\lambda_{1,2} = \\pm 1$。存在一个正特征值和一个负特征值证实了原点是一个鞍点。对于非稳定特征值 $\\lambda_u = +1$ 的特征向量是 $\\vec{v}_u \\propto (1,1)$，对于稳定特征值 $\\lambda_s = -1$ 的特征向量是 $\\vec{v}_s \\propto (1,-1)$。这些特征向量分别定义了非稳定流形和稳定流形的局部方向。\n\n全局流形，也就是相空间的分界线，对应于穿过鞍点的特定能级。在原点处计算哈密顿量得到 $H(0,0)=0$。因此，稳定和非稳定流形位于由 $H(x,y)=0$ 定义的曲线上。\n\n为了数值计算流形的一个分支，我们必须选择一个初始条件 $(x_0, y_0)$，该条件从鞍点沿相应特征向量方向有无穷小位移，并且位于分界线能级上。问题指定了一个由小参数 $\\varepsilon$ 表征的位移。\n\n对于第一象限中的非稳定流形分支（$x0, y0$），我们设置 $x_0 = \\varepsilon$。条件 $H(\\varepsilon, y_0) = 0$ 给出：\n$$\n\\frac{y_0^2}{2} - \\frac{\\varepsilon^2}{2} + \\frac{\\varepsilon^4}{4} = 0 \\implies y_0^2 = \\varepsilon^2 - \\frac{\\varepsilon^4}{2}\n$$\n由于我们在第一象限，我们取正根：\n$$\ny_0 = \\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = \\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\n对于小的 $\\varepsilon$，泰勒展开显示 $y_0 \\approx \\varepsilon(1 - \\varepsilon^2/4) \\approx \\varepsilon$。因此，初始点 $(x_0, y_0)$ 近似为 $(\\varepsilon, \\varepsilon)$，这与非稳定特征向量方向 $(1,1)$ 相切。我们对这个初始条件进行时间上的前向积分（$t0$），直到轨迹首次穿过 x 轴，即 $y=0$。当同宿环闭合时，可以找到穿越点 $x_{cross}$。在分界线上，这发生在 $H(x,0) = 0$ 时，这意味着 $-\\frac{x^2}{2} + \\frac{x^4}{4} = 0$。非零解为 $x = \\pm\\sqrt{2}$。第一象限的分支将在 $x = \\sqrt{2}$ 处穿越。第一个度量是与这个精确值的偏差：$|x_{cross} - \\sqrt{2}|$。\n\n对于从第四象限接近原点的稳定流形分支（$x0, y0$），我们类似地设置 $x_0 = \\varepsilon$。条件 $H(\\varepsilon, y_0) = 0$ 要求取负根：\n$$\ny_0 = -\\sqrt{\\varepsilon^2 - \\frac{\\varepsilon^4}{2}} = -\\varepsilon \\sqrt{1 - \\frac{\\varepsilon^2}{2}}\n$$\n对于小的 $\\varepsilon$，$y_0 \\approx -\\varepsilon$，并且初始点 $(x_0, y_0)$ 近似为 $(\\varepsilon, -\\varepsilon)$，与稳定特征向量方向 $(1,-1)$ 相切。为了追踪这个远离原点的流形，我们必须向后积分（$t0$）。根据对称性，在 $y=0$ 轴上的穿越点 $x_{cross}$ 也预期在 $x=\\sqrt{2}$ 处。最终的度量是 $|x_{cross} - \\sqrt{2}|$。\n\n剩余的度量是为非稳定分支计算的。角度误差量化了在初始点 $(x_0, y_0)$ 处的真实矢量场与线性近似（特征向量 $\\vec{v}_u=(1,1)$）的对齐程度。矢量场为 $\\vec{F}(x_0, y_0) = (y_0, x_0 - x_0^3)$。$\\vec{F}$ 和 $\\vec{v}_u$ 之间的夹角 $\\theta$ 使用点积公式计算：\n$$\n\\theta = \\arccos\\left(\\frac{\\vec{F}(x_0, y_0) \\cdot \\vec{v}_u}{||\\vec{F}(x_0, y_0)|| \\cdot ||\\vec{v}_u||}\\right)\n$$\n能量偏差衡量了数值积分器的准确性。由于初始条件精确地在 $H=0$ 水平集上，因此沿计算出的轨迹段的哈密顿量的最大绝对值 $\\max_t |H(x(t), y(t))|$ 量化了累积的数值误差。\n\n数值实现将使用一个配备了事件检测功能的高精度、自适应步长的微分方程求解器，以准确定位 $y=0$ 的穿越点。`scipy.integrate.solve_ivp` 适合此目的。对测试套件中的每个 $\\varepsilon$ 值执行积分，并按要求计算和格式化四个指定的度量。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef format_float(val):\n    \"\"\"Formats a float to 6 significant figures in scientific notation if needed.\"\"\"\n    return f\"{val:.6g}\"\n\ndef solve():\n    \"\"\"\n    Computes stable and unstable manifolds for a 2D dynamical system,\n    and extracts quantitative diagnostics for a suite of initial offsets.\n    \"\"\"\n    test_cases = [1e-6, 1e-3, 1e-2]\n    all_results = []\n    \n    # The ODE system dx/dt = y, dy/dt = x - x^3\n    def diffeq(t, state):\n        x, y = state\n        return [y, x - x**3]\n\n    # Hamiltonian H(x,y) = y^2/2 - x^2/2 + x^4/4\n    def hamiltonian(x, y):\n        return 0.5 * y**2 - 0.5 * x**2 + 0.25 * x**4\n\n    # Event for y=0 crossing with y decreasing\n    def event_y_zero_down(t, state):\n        return state[1]\n    event_y_zero_down.terminal = True\n    event_y_zero_down.direction = -1\n\n    # Event for y=0 crossing with y increasing\n    def event_y_zero_up(t, state):\n        return state[1]\n    event_y_zero_up.terminal = True\n    event_y_zero_up.direction = 1\n\n    # Theoretical x-crossing on the separatrix\n    x_apex_theoretical = np.sqrt(2.0)\n\n    # Unit unstable eigenvector direction\n    evec_u = np.array([1.0, 1.0])\n\n    # Numerical integration settings\n    t_max = 50.0\n    rtol = 1e-12\n    atol = 1e-12\n\n    for eps in test_cases:\n        case_results = []\n\n        # --- Unstable Manifold (Q1) ---\n        x0_u = eps\n        y0_u = eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_u = [x0_u, y0_u]\n\n        # Integrate forward in time\n        sol_u = solve_ivp(\n            diffeq, [0, t_max], ic_u,\n            events=event_y_zero_down,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        unstable_apex_error = np.nan\n        unstable_angle_error = np.nan\n        unstable_max_energy_deviation = np.nan\n\n        if sol_u.status == 1 and sol_u.t_events[0].size > 0:\n            # Metric 1: Apex error\n            x_cross_u = sol_u.y_events[0][0, 0]\n            unstable_apex_error = np.abs(x_cross_u - x_apex_theoretical)\n\n            # Metric 2: Angle error at initial condition\n            vf_at_ic = np.array([y0_u, x0_u - x0_u**3])\n            cos_theta = np.dot(vf_at_ic, evec_u) / (np.linalg.norm(vf_at_ic) * np.linalg.norm(evec_u))\n            # Clip to handle potential floating point inaccuracies for arccos\n            cos_theta = np.clip(cos_theta, -1.0, 1.0)\n            unstable_angle_error = np.arccos(cos_theta)\n\n            # Metric 3: Max energy deviation\n            h_values = hamiltonian(sol_u.y[0, :], sol_u.y[1, :])\n            unstable_max_energy_deviation = np.max(np.abs(h_values))\n\n        # --- Stable Manifold (Q4) ---\n        x0_s = eps\n        y0_s = -eps * np.sqrt(1.0 - 0.5 * eps**2)\n        ic_s = [x0_s, y0_s]\n\n        # Integrate backward in time\n        sol_s = solve_ivp(\n            diffeq, [0, -t_max], ic_s,\n            events=event_y_zero_up,\n            dense_output=True,\n            rtol=rtol, atol=atol\n        )\n\n        stable_apex_error = np.nan\n        if sol_s.status == 1 and sol_s.t_events[0].size > 0:\n            # Metric 4: Apex error\n            x_cross_s = sol_s.y_events[0][0, 0]\n            stable_apex_error = np.abs(x_cross_s - x_apex_theoretical)\n        \n        case_results = [\n            unstable_apex_error,\n            unstable_angle_error,\n            unstable_max_energy_deviation,\n            stable_apex_error\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string\n    formatted_results = []\n    for row in all_results:\n        formatted_row = f\"[{','.join([format_float(v) for v in row])}]\"\n        formatted_results.append(formatted_row)\n    \n    final_output = f\"[{','.join(formatted_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2426894"}, {"introduction": "许多物理系统的相空间并非简单的平面，例如，两个独立振子的组合运动天然地存在于一个环面上。本练习 [@problem_id:2426886] 将探索周期运动与准周期运动之间的本质区别，前者发生于频率比为有理数时，后者则在频率比为无理数时出现，其轨迹能够稠密地填充整个环面。我们将通过计算一个“覆盖率”指标，来量化这种令人着迷的动力学行为。", "problem": "考虑两个非耦合的一维谐振子，其广义坐标为 $q_1(t)$ 和 $q_2(t)$，共轭动量为 $p_1(t)$ 和 $p_2(t)$。每个振子都满足常微分方程 (ODE) $m_i \\ddot{q}_i(t) + k_i q_i(t) = 0$（$i \\in \\{1,2\\}$），其中 $m_i$ 是质量，$k_i$ 是弹簧常数。令 $\\omega_i = \\sqrt{k_i/m_i}$ 表示角频率，单位为弧度/秒。对于振幅 $A_i  0$ 和相位 $\\phi_i \\in \\mathbb{R}$，解可以写作 $q_i(t) = A_i \\cos(\\omega_i t + \\phi_i)$ 和 $p_i(t) = m_i \\dot{q}_i(t) = -m_i A_i \\omega_i \\sin(\\omega_i t + \\phi_i)$，其中角度以弧度为单位，时间 $t$ 以秒为单位。\n\n定义相角 $\\theta_i(t) = \\omega_i t + \\phi_i$（模 $2\\pi$），使得 $(\\theta_1(t) \\bmod 2\\pi, \\theta_2(t) \\bmod 2\\pi)$ 在二维环面 $\\mathbb{T}^2 = (\\mathbb{R}/2\\pi\\mathbb{Z})^2$ 上演化。考虑通过光滑映射将 $\\mathbb{T}^2$ 标准嵌入到三维 (3D) 欧几里得空间 $\\mathbb{R}^3$ 中\n$$\n\\Phi(\\theta_1,\\theta_2) = \\big((R + r \\cos \\theta_1)\\cos \\theta_2,\\; (R + r \\cos \\theta_1)\\sin \\theta_2,\\; r \\sin \\theta_1\\big),\n$$\n其中 $R  r  0$ 是无量纲的。像 $\\Phi(\\mathbb{T}^2)$ 是 $\\mathbb{R}^3$ 中的一个几何环面。\n\n您的任务是构建由点对 $(\\theta_1(t), \\theta_2(t))$ 在 $\\mathbb{T}^2$ 上引起的流的数值相空间图，并量化对于不同的频率比，轨迹如何对环面进行采样。使用以下经验覆盖率的精确定义。固定一个正整数 $M$，并将 $[0,2\\pi)\\times[0,2\\pi)$ 沿每个角坐标划分为 $M\\times M$ 个边长为 $2\\pi/M$ 的相等矩形。对于一个均匀时间网格 $t_k = k\\Delta t$（$k=0,1,\\dots,N-1$ 且 $\\Delta t = T/N$），构建角对集合 $\\big(\\theta_1(t_k) \\bmod 2\\pi,\\; \\theta_2(t_k) \\bmod 2\\pi\\big)$。经验覆盖率分数定义为比率\n$$\n\\mathcal{C} = \\frac{\\text{至少被一个采样角对触及的非空矩形数量}}{M^2}。\n$$\n角度必须以弧度处理。覆盖率分数 $\\mathcal{C}$ 是无量纲的，并且必须以实数形式报告。\n\n实现一个完整、可运行的程序，该程序针对下面的测试套件，使用指定的参数计算并输出每种情况下的经验覆盖率分数 $\\mathcal{C}$。使用零相位 $\\phi_1 = \\phi_2 = 0$ 和环面嵌入参数 $R = 2$ 和 $r = 1$（这些几何参数定义了 3D 环面，但不直接影响角空间中的覆盖率计算）。使用所述的精确值；不要引入任何额外的随机性。\n\n测试套件（角度单位为弧度，频率单位为弧度/秒，时间单位为秒）：\n- 情况 1（无理数比，理想情况）：$\\omega_1 = 1$，$\\omega_2 = \\frac{1+\\sqrt{5}}{2}$，总时间 $T = 2\\pi \\cdot 200$，采样点数 $N = 200000$，网格尺寸 $M = 64$。\n- 情况 2（有理数比，对比行为）：$\\omega_1 = 1$，$\\omega_2 = \\frac{3}{2}$，总时间 $T = 2\\pi \\cdot 200$，采样点数 $N = 200000$，网格尺寸 $M = 64$。\n- 情况 3（有限时间内的近共振边缘情况）：$\\omega_1 = 1$，$\\omega_2 = 1 + 10^{-6}$，总时间 $T = 2\\pi \\cdot 100$，采样点数 $N = 200000$，网格尺寸 $M = 64$。\n\n您的程序必须使用相同的定义计算每种情况下的覆盖率分数 $\\mathcal{C}$，并生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个值四舍五入到小数点后四位（例如，[1.0000,0.0820,0.0313]）。在整个过程中，角度必须以弧度处理。不允许用户输入，并且程序必须是自包含的。", "solution": "所述问题是有效的。它在科学上基于经典力学和动力系统理论的原理，特别是关于环面上运动的研究。该问题是适定的，为待计算的量提供了所有必要的参数和无歧义的定义。它是客观的，没有任何事实或逻辑上的不一致。我们可以继续进行求解。\n\n任务是量化一个二维动力系统相空间的采样情况，该系统由两个相角 $\\theta_1(t)$ 和 $\\theta_2(t)$ 的演化定义。该系统代表两个非耦合的谐振子。系统在时间 $t$ 的状态由二维环面 $\\mathbb{T}^2 = (\\mathbb{R}/2\\pi\\mathbb{Z})^2$ 上的点 $(\\theta_1(t), \\theta_2(t))$ 给出。角度的演化方程由 $\\theta_i(t) = \\omega_i t + \\phi_i$ 给出，其中 $\\omega_i$ 是角频率，$\\phi_i$ 是初始相位。对于此问题，给定 $\\phi_1 = \\phi_2 = 0$，因此轨迹就是 $(\\omega_1 t, \\omega_2 t)$ 模 $2\\pi$。\n\n该轨迹的行为从根本上由频率比 $\\omega_2/\\omega_1$ 决定。\n- 如果比率 $\\omega_2/\\omega_1$ 是有理数，即对于整数 $p, q$ 有 $\\omega_2/\\omega_1 = p/q$，则轨迹是周期性的。它在环面上形成一条闭合曲线。经过时间 $T_p$（该时间是各自周期 $2\\pi/\\omega_1$ 和 $2\\pi/\\omega_2$ 的公倍数）后，系统返回其初始状态。该轨迹作为一条一维曲线，将只覆盖二维环面面积中极小的一部分。\n- 如果比率 $\\omega_2/\\omega_1$ 是无理数，则轨迹是准周期的，并且根据 Kronecker-Weyl 定理，它在环面上是稠密的。这意味着在无限长的时间里，轨迹将任意接近环面上的每一个点。\n\n我们被要求计算经验覆盖率分数 $\\mathcal{C}$，这是一个数值度量，衡量在有限时间区间 $[0, T)$ 内轨迹探索了环面的多大范围。环面 $[0, 2\\pi) \\times [0, 2\\pi)$ 被划分为一个由 $M \\times M$ 个相同矩形单元组成的网格。覆盖率 $\\mathcal{C}$ 是采样轨迹中至少有一个点访问过的单元格数量除以总单元格数量 $M^2$。\n\n计算每个测试案例的 $\\mathcal{C}$ 的算法如下：\n1.  为案例设置参数：角频率 $\\omega_1, \\omega_2$；总时间 $T$；采样点数 $N$；以及网格维度 $M$。\n2.  在区间 $[0, T)$ 内生成一个包含 $N$ 个点的均匀时间向量 $\\vec{t}$，使得 $t_k = k \\cdot (T/N)$，其中 $k = 0, 1, \\dots, N-1$。\n3.  计算两个角度的轨迹：$\\vec{\\theta}_1 = (\\omega_1 \\vec{t}) \\pmod{2\\pi}$ 和 $\\vec{\\theta}_2 = (\\omega_2 \\vec{t}) \\pmod{2\\pi}$。模运算的结果必须在区间 $[0, 2\\pi)$ 内。\n4.  对于采样轨迹中的每个点 $(\\theta_{1,k}, \\theta_{2,k})$，确定其占据的网格单元。一个点 $(\\theta_1, \\theta_2)$ 的单元格索引 $(i_1, i_2)$ 由 $i_1 = \\lfloor \\frac{M \\theta_1}{2\\pi} \\rfloor$ 和 $i_2 = \\lfloor \\frac{M \\theta_2}{2\\pi} \\rfloor$ 给出。这些索引的范围将从 $0$ 到 $M-1$。\n5.  维护一个大小为 $M \\times M$ 的二维布尔网格 `visited_cells`，并将其初始化为 `False`。对于所有计算出的索引对 $(i_{1,k}, i_{2,k})$，将对应的元素 `visited_cells`$[i_{1,k}, i_{2,k}]$ 设置为 `True`。使用一组唯一的索引对将是等效的。\n6.  访问过的单元格数量 $N_{visited}$ 是 `visited_cells` 网格中 `True` 条目的总数。\n7.  经验覆盖率分数为 $\\mathcal{C} = \\frac{N_{visited}}{M^2}$。\n\n我们将此算法应用于三个指定的案例。\n\n**情况 1：无理数比**\n- 参数：$\\omega_1 = 1$，$\\omega_2 = \\frac{1+\\sqrt{5}}{2} \\approx 1.618$（黄金比例），$T = 2\\pi \\cdot 200$，$N = 200000$，$M = 64$。\n- 频率比是无理数。轨迹预计是稠密的。在长时间 $T$ 内有大量样本 $N$ 的情况下，覆盖率 $\\mathcal{C}$ 应接近 $1$。\n\n**情况 2：有理数比**\n- 参数：$\\omega_1 = 1$，$\\omega_2 = \\frac{3}{2} = 1.5$，$T = 2\\pi \\cdot 200$，$N = 200000$，$M = 64$。\n- 频率比是有理数。轨迹是周期性的，周期为 $T_p = 4\\pi$。由于总积分时间 $T = 2\\pi \\cdot 200 = 100 \\cdot (2\\pi) = 50 \\cdot (4\\pi)$ 是周期的整数倍，轨迹将简单地重复描绘同一条闭合曲线 50 次。这条曲线是一个一维对象，因此它只会与 $M^2 = 4096$ 个网格单元中的一小部分相交。我们预期 $\\mathcal{C} \\ll 1$。\n\n**情况 3：近共振情况**\n- 参数：$\\omega_1 = 1$，$\\omega_2 = 1 + 10^{-6}$，$T = 2\\pi \\cdot 100$，$N = 200000$，$M = 64$。\n- 频率比极度接近于 1。运动是准周期的，但从共振 $\\omega_1 = \\omega_2$ 处演化得非常缓慢。相位差演化为 $\\theta_2(t) - \\theta_1(t) = (\\omega_2 - \\omega_1)t = 10^{-6} t$。在最终时间 $t=T=2\\pi \\cdot 100$ 时，最大相位差仅为 $2\\pi \\cdot 10^{-4}$ 弧度。轨迹仍然局限在对角线 $\\theta_1 = \\theta_2$ 周围一个非常窄的带内。这个带的宽度远小于单个网格单元的宽度 $2\\pi/M = 2\\pi/64$。因此，轨迹将主要占据沿网格主对角线的一条近乎一维的路径，可能会溢出到相邻的单元格中。被访问的单元格数量应该在 $M$ 或 $2M$ 的数量级。覆盖率预计会很小，大约为 $1/M \\approx 0.0156$ 或 $2/M \\approx 0.0313$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical coverage fraction for three test cases of\n    a dynamical system on a 2-torus.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Irrational ratio\n        {\n            \"omega1\": 1.0,\n            \"omega2\": (1.0 + np.sqrt(5.0)) / 2.0,\n            \"T\": 2.0 * np.pi * 200.0,\n            \"N\": 200000,\n            \"M\": 64\n        },\n        # Case 2: Rational ratio\n        {\n            \"omega1\": 1.0,\n            \"omega2\": 3.0 / 2.0,\n            \"T\": 2.0 * np.pi * 200.0,\n            \"N\": 200000,\n            \"M\": 64\n        },\n        # Case 3: Near-resonant edge case\n        {\n            \"omega1\": 1.0,\n            \"omega2\": 1.0 + 1e-6,\n            \"T\": 2.0 * np.pi * 100.0,\n            \"N\": 200000,\n            \"M\": 64\n        }\n    ]\n\n    results = []\n\n    for case in test_cases:\n        omega1 = case[\"omega1\"]\n        omega2 = case[\"omega2\"]\n        T = case[\"T\"]\n        N = case[\"N\"]\n        M = case[\"M\"]\n\n        # 1. Generate a uniform time vector\n        # The interval is [0, T), with N points.\n        t = np.linspace(0.0, T, N, endpoint=False)\n\n        # 2. Compute the trajectories of the two angles modulo 2*pi\n        theta1 = (omega1 * t) % (2.0 * np.pi)\n        theta2 = (omega2 * t) % (2.0 * np.pi)\n\n        # 3. Map angles to grid cell indices\n        # The mapping floor(angle * M / (2*pi)) correctly maps the\n        # interval [0, 2*pi) to integer indices [0, M-1].\n        idx1 = np.floor(theta1 * M / (2.0 * np.pi)).astype(int)\n        idx2 = np.floor(theta2 * M / (2.0 * np.pi)).astype(int)\n\n        # 4. Use a boolean grid to mark visited cells efficiently\n        # This avoids storing all points or using a slow loop.\n        visited_grid = np.zeros((M, M), dtype=bool)\n        # Advanced indexing marks all unique (idx1, idx2) pairs as True\n        visited_grid[idx1, idx2] = True\n        \n        # 5. Count the number of visited cells\n        num_visited_cells = np.sum(visited_grid)\n\n        # 6. Compute the empirical coverage fraction\n        coverage_fraction = num_visited_cells / (M * M)\n        \n        results.append(coverage_fraction)\n\n    # Format the results as specified: rounded to four decimal places.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    \n    # Print the final output in the required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2426886"}]}