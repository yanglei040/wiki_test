{"hands_on_practices": [{"introduction": "在深入研究复杂的数值模拟之前，掌握基本物理定律的分析应用至关重要。这个练习 [@problem_id:2196965] 直接应用了开普勒第三定律，这是一个在设计航天任务和理解天体系统尺度时不可或缺的基础计算。通过这个练习，你将能够运用核心物理原理来解决实际的天体动力学问题。", "problem": "一个航天机构正计划将一颗新的观测卫星送入环绕地球的稳定圆形轨道。为了任务计时的目的，他们需要计算地球的年轨道周期与新卫星的周期之比。\n\n该卫星将被放置在这样一个高度，使其轨道半径恰好等于月球轨道的半长轴 $a_M$。地球本身以一个半长轴为 $a_E$ 的近圆形轨道环绕太阳运行。\n\n你的任务是计算地球环绕太阳的轨道周期 $T_E$ 与卫星环绕地球的轨道周期 $T_S$ 之比。\n\n你被提供了以下数据：\n- 太阳质量：$M_{Sun} = 1.989 \\times 10^{30}$ kg\n- 地球质量：$M_{Earth} = 5.972 \\times 10^{24}$ kg\n- 地球环绕太阳轨道的半长轴：$a_E = 1.496 \\times 10^{11}$ m\n- 月球环绕地球轨道的半长轴：$a_M = 3.844 \\times 10^8$ m\n\n在你的计算中，假设轨道是圆形的。对于一个二体系统，如果轨道天体的质量远小于中心天体，你可以忽略其质量。例如，卫星的质量与地球的质量相比可以忽略不计，地球的质量与太阳的质量相比也可以忽略不计。万有引力常数用 $G$ 表示。\n\n计算比值 $\\frac{T_E}{T_S}$ 的数值，并将你的最终答案四舍五入到三位有效数字。", "solution": "我们使用牛顿二体圆形轨道动力学，这等同于从牛顿万有引力定律推导出的开普勒第三定律。对于一个质量可忽略的物体，在半径为 $r$ 的圆形轨道上环绕一个中心质量为 $M$ 的天体运行时，其轨道周期为\n$$\nT=2\\pi\\sqrt{\\frac{r^{3}}{G M}}.\n$$\n对于地球环绕太阳，\n$$\nT_{E}=2\\pi\\sqrt{\\frac{a_{E}^{3}}{G M_{Sun}}},\n$$\n对于卫星在半径为 $a_{M}$ 的轨道上环绕地球，\n$$\nT_{S}=2\\pi\\sqrt{\\frac{a_{M}^{3}}{G M_{Earth}}}.\n$$\n求比值并消去公共因子 $2\\pi$ 和 $G$ 得到\n$$\n\\frac{T_{E}}{T_{S}}=\\sqrt{\\frac{a_{E}^{3} M_{Earth}}{a_{M}^{3} M_{Sun}}}\n=\\sqrt{\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}\\frac{M_{Earth}}{M_{Sun}}}.\n$$\n\n代入给定的数值：\n$$\n\\frac{a_{E}}{a_{M}}=\\frac{1.496\\times 10^{11}}{3.844\\times 10^{8}}\n=\\left(\\frac{1.496}{3.844}\\right)\\times 10^{3}\\approx 0.389178\\times 10^{3}=3.89178\\times 10^{2}.\n$$\n然后\n$$\n\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}=(3.89178)^{3}\\times 10^{6}\\approx 58.9447113949\\times 10^{6}=5.89447113949\\times 10^{7}.\n$$\n对于质量比，\n$$\n\\frac{M_{Earth}}{M_{Sun}}=\\frac{5.972\\times 10^{24}}{1.989\\times 10^{30}}\n=\\left(\\frac{5.972}{1.989}\\right)\\times 10^{-6}\\approx 3.00251382\\times 10^{-6}.\n$$\n因此平方根内的参数为\n$$\n\\left(\\frac{a_{E}}{a_{M}}\\right)^{3}\\frac{M_{Earth}}{M_{Sun}}\n=(5.89447113949\\times 10^{7})(3.00251382\\times 10^{-6})\n=(5.89447113949\\times 3.00251382)\\times 10^{1}\\approx 176.9823106.\n$$\n因此，\n$$\n\\frac{T_{E}}{T_{S}}=\\sqrt{176.9823106}\\approx 13.3035\\ldots\n$$\n四舍五入到三位有效数字得到 $13.3$。", "answer": "$$\\boxed{13.3}$$", "id": "2196965"}, {"introduction": "现实世界中的轨道问题往往过于复杂，难以用简单的解析公式求解，这时数值模拟就派上了用场。这个练习 [@problem_id:2390259] 将引导你编写第一个轨道模拟器，并比较两种最基础的积分方法：显式欧拉法和半隐式欧拉-克罗默法。通过亲手实践，你将直观地看到一个微小的算法差异如何对长期能量守恒和模拟稳定性产生巨大影响，这是计算物理学中一堂基础而又深刻的一课。", "problem": "考虑一个牛顿双体系统，该系统模拟一颗质量可忽略的彗星绕一个中心大质量天体运行。在无量纲引力单位制下进行计算，其中引力常数与中心天体质量的乘积被归一化为 $G M = 1$，彗星质量为 $m = 1$。运动被限制在一个平面内，位置向量为 $\\mathbf{x}(t) \\in \\mathbb{R}^2$，速度为 $\\mathbf{v}(t) = d\\mathbf{x}/dt$。所使用的基本定律是牛顿第二定律和平方反比引力定律，它们导出以下一阶系统：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}, \\quad \\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}.\n$$\n在这些单位制下，总机械能（哈密顿量）为\n$$\nH(\\mathbf{x},\\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert},\n$$\n对于连续动力学系统，它是一个不随时间变化的守恒量。\n\n你的任务是仅根据核心定义 $d\\mathbf{x}/dt = \\mathbf{v}$ 和 $d\\mathbf{v}/dt = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$ 为此常微分方程（ODE, ordinary differential equation）设计和实现两个一阶时间步进积分器：\n- 一个标准的显式欧拉积分器，它使用在当前时间层级上求值的速度来推进位置。\n- 一个半隐式欧拉积分器（也称为欧拉-克罗默方法），它使用当前位置的加速度来推进速度，然后在同一步内使用更新后的速度来推进位置。\n\n从第一性原理出发，通过以步长 $\\Delta t$ 离散化时间，并一致地应用上述定义来为每种方法构建步进更新逻辑。除了这种显式时间离散化之外，不要引入任何无关的近似，并确保两种方法在每一步开始时都使用相同的力求值 $\\mathbf{a}(\\mathbf{x}) = -\\mathbf{x}/\\lVert \\mathbf{x} \\rVert^3$。\n\n使用以下测试套件。对于每个案例，使用固定的时间步长 $\\Delta t$ 对指定的轨道周期数 $P$进行积分。在这些单位制下，半长轴为 $a$ 的开普勒椭圆的轨道周期是 $T = 2\\pi a^{3/2}$。初始状态被选为圆形轨道上或椭圆的远日点上，初始速度垂直于半径向量并朝向顺行运动方向。在这些单位制下，所有量都是无量纲的。\n\n- 测试用例1（圆形轨道“理想情况”）：$a = 1$，$e = 0$，初始状态 $\\mathbf{x}_0 = (1, 0)$，$\\mathbf{v}_0 = (0, 1)$，$\\Delta t = 0.01$，$P = 50$。\n- 测试用例2（中等偏心率彗星）：$a = 1$，$e = 0.6$，远日点初始状态 $\\mathbf{x}_0 = (1.6, 0)$，$\\mathbf{v}_0 = (0, 0.5)$，$\\Delta t = 0.001$，$P = 20$。\n- 测试用例3（高偏心率彗星）：$a = 1$，$e = 0.9$，远日点初始状态 $\\mathbf{x}_0 = (1.9, 0)$，$\\mathbf{v}_0 \\approx (0, 0.22941573387)$，$\\Delta t = 0.0005$，$P = 5$。\n- 测试用例4（边界时间步长，圆形轨道）：$a = 1$，$e = 0$，初始状态 $\\mathbf{x}_0 = (1, 0)$，$\\mathbf{v}_0 = (0, 1)$，$\\Delta t = 0.05$，$P = 5$。\n\n对于每个测试用例，为每个积分器计算相对末端能量漂移，\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H(\\mathbf{x}_N,\\mathbf{v}_N) - H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|}{\\left| H(\\mathbf{x}_0,\\mathbf{v}_0) \\right|},\n$$\n其中 $N = \\left\\lceil \\frac{P \\, T}{\\Delta t} \\right\\rceil$ 是所采取的步数，然后返回比率\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}.\n$$\n该比率 $r$ 是无量纲的。$r  1$ 的值表示对于相同的持续时间，半隐式欧拉（欧拉-克罗默）方法比标准显式欧拉方法表现出更小的绝对能量漂移。\n\n最终输出格式：你的程序应生成单行输出，其中包含测试用例1-4的 $r$ 值，以逗号分隔的列表形式，并用方括号括起来，例如 `[r_1,r_2,r_3,r_4]`。条目必须是浮点数。输出中不出现物理单位，因为根据设计，所有量都是无量纲的。\n\n你的实现必须是完全自包含的，并且不得读取任何输入。每个测试用例的答案是一个浮点数 $r$。这四个输出的集合必须按照上述格式出现在一行上。通过全程使用标准的双精度算术，并忠实地实现根据所述基本定律和定义推导出的两种所要求的积分器，来确保数值稳定性。", "solution": "问题陈述已经过严格验证，并被认定是有效的。它在科学上植根于经典力学原理，特别是开普勒问题，并且在数学上作为一个常微分方程组的初值问题是适定的。参数和目标定义精确，不含任何矛盾、歧义或事实错误。该任务是计算物理学中的一个标准练习，要求推导和比较两种基本的数值积分器。\n\n我们继续进行推导和求解。\n\n该系统由一组关于位置向量 $\\mathbf{x}(t) \\in \\mathbb{R}^2$ 和速度向量 $\\mathbf{v}(t) \\in \\mathbb{R}^2$ 的一阶常微分方程（ODE）描述：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{x}) = -\\frac{\\mathbf{x}}{\\lVert \\mathbf{x} \\rVert^3}\n$$\n此处，$\\mathbf{a}(\\mathbf{x})$ 是由引力引起的加速度，引力参数 $G M$ 设为 $1$。\n\n我们将以一个恒定的时间步长 $\\Delta t$ 来离散化时间。设系统在时间 $t_n = n \\Delta t$ 的状态为 $(\\mathbf{x}_n, \\mathbf{v}_n)$。我们旨在求出在时间 $t_{n+1} = t_n + \\Delta t$ 的状态 $(\\mathbf{x}_{n+1}, \\mathbf{v}_{n+1})$。\n\n**标准显式欧拉积分器的推导**\n\n显式（或前向）欧拉方法使用当前时间层级 $t_n$ 的值来近似导数。\n第一个ODE的离散近似为：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{x}}{dt} \\right|_{t_n} = \\mathbf{v}_n\n$$\n类似地，对于第二个ODE：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\left. \\frac{d\\mathbf{v}}{dt} \\right|_{t_n} = \\mathbf{a}(\\mathbf{x}_n)\n$$\n整理这些表达式即可得到显式欧拉方法的更新规则。首先，从当前位置 $\\mathbf{x}_n$ 计算加速度 $\\mathbf{a}_n$。然后，使用时间 $t_n$ 的状态来推进位置和速度。\n\n单步的更新逻辑是：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_n \\Delta t$\n\n关键特征是，新位置 $\\mathbf{x}_{n+1}$ 是使用旧速度 $\\mathbf{v}_n$ 计算的，而不是新计算出的速度 $\\mathbf{v}_{n+1}$。\n\n**半隐式欧拉（欧拉-克罗默）积分器的推导**\n\n半隐式欧拉方法，也称为欧拉-克罗默方法，引入了一个微小但关键的修改。首先执行速度的更新，然后这个新计算出的速度立即被用来更新位置。在单个步骤内对时间层级的这种“混合”定义了其半隐式的性质。\n\n速度的更新与显式方法保持相同：\n$$\n\\frac{\\mathbf{v}_{n+1} - \\mathbf{v}_n}{\\Delta t} \\approx \\mathbf{a}(\\mathbf{x}_n) \\implies \\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}(\\mathbf{x}_n) \\Delta t\n$$\n然而，位置更新使用的是新速度 $\\mathbf{v}_{n+1}$：\n$$\n\\frac{\\mathbf{x}_{n+1} - \\mathbf{x}_n}{\\Delta t} \\approx \\mathbf{v}_{n+1}\n$$\n\n单步的更新逻辑是：\n1.  计算加速度：$\\mathbf{a}_n = -\\frac{\\mathbf{x}_n}{\\lVert \\mathbf{x}_n \\rVert^3}$\n2.  更新速度：$\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\mathbf{a}_n \\Delta t$\n3.  更新位置：$\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\mathbf{v}_{n+1} \\Delta t$\n\n该方法是一个简单的辛积分器。对于像开普勒问题这样的哈密顿系统，此类积分器表现出优越的长期稳定性，特别是在能量守恒方面。它们不完全守恒能量，但能量误差通常保持有界，在真实值附近振荡，而显式欧拉方法通常会导致能量的长期漂移。\n\n**模拟与评估方法**\n\n对于每个测试用例，我们执行两次模拟，每个积分器一次。\n初始状态为 $(\\mathbf{x}_0, \\mathbf{v}_0)$。\n总积分时间由轨道周期数 $P$ 指定。半长轴为 $a$ 的开普勒轨道的周期 $T$ 是 $T = 2\\pi a^{3/2}$。\n所需的总步数是 $N = \\lceil (P \\cdot T) / \\Delta t \\rceil$。\n\n连续系统的守恒量是机械能，或哈密顿量：\n$$\nH(\\mathbf{x}, \\mathbf{v}) = \\frac{1}{2}\\lVert \\mathbf{v} \\rVert^2 - \\frac{1}{\\lVert \\mathbf{x} \\rVert}\n$$\n我们计算初始能量 $H_0 = H(\\mathbf{x}_0, \\mathbf{v}_0)$。经过 $N$ 步后，我们得到最终状态 $(\\mathbf{x}_N, \\mathbf{v}_N)$ 并计算最终能量 $H_N = H(\\mathbf{x}_N, \\mathbf{v}_N)$。\n\n每个积分器的性能由相对末端能量漂移 $\\delta$ 来量化：\n$$\n\\delta_{\\mathrm{method}} = \\frac{\\left| H_N - H_0 \\right|}{\\left| H_0 \\right|}\n$$\n问题要求计算两种方法的这些漂移的比率 $r$：\n$$\nr = \\frac{\\delta_{\\mathrm{Cromer}}}{\\delta_{\\mathrm{Euler}}}\n$$\n$r  1$ 的值表示对于给定的参数，半隐式欧拉-克罗默方法比标准显式欧拉方法提供更好的长期能量守恒性。实现将精确遵循这些推导。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-body problem using explicit Euler and semi-implicit Euler\n    methods and computes the ratio of their energy drifts.\n    \"\"\"\n    \n    # Test cases as specified in the problem statement.\n    test_cases = [\n        # case 1: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.01, P=50\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.01, 'P': 50},\n        # case 2: a=1, e=0.6, x0=(1.6,0), v0=(0,0.5), dt=0.001, P=20\n        {'a': 1.0, 'x0': np.array([1.6, 0.0]), 'v0': np.array([0.0, 0.5]), 'dt': 0.001, 'P': 20},\n        # case 3: a=1, e=0.9, x0=(1.9,0), v0=(0, ~0.2294), dt=0.0005, P=5\n        {'a': 1.0, 'x0': np.array([1.9, 0.0]), 'v0': np.array([0.0, 0.22941573387]), 'dt': 0.0005, 'P': 5},\n        # case 4: a=1, e=0, x0=(1,0), v0=(0,1), dt=0.05, P=5\n        {'a': 1.0, 'x0': np.array([1.0, 0.0]), 'v0': np.array([0.0, 1.0]), 'dt': 0.05, 'P': 5},\n    ]\n\n    results = []\n\n    def hamiltonian(x, v):\n        \"\"\"Computes the Hamiltonian (total energy) of the system.\"\"\"\n        r_norm = np.linalg.norm(x)\n        v_norm_sq = np.dot(v, v)\n        return 0.5 * v_norm_sq - 1.0 / r_norm\n\n    def run_explicit_euler(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the standard explicit Euler method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Store old velocity for position update\n            v_old = v\n            # Update velocity\n            v = v + a * dt\n            # Update position using old velocity\n            x = x + v_old * dt\n        return x, v\n\n    def run_euler_cromer(x0, v0, N, dt):\n        \"\"\"Simulates the orbit using the semi-implicit Euler-Cromer method.\"\"\"\n        x = x0.copy()\n        v = v0.copy()\n        for _ in range(N):\n            r_norm = np.linalg.norm(x)\n            a = -x / r_norm**3\n            # Update velocity\n            v = v + a * dt\n            # Update position using new velocity\n            x = x + v * dt\n        return x, v\n        \n    for case in test_cases:\n        a = case['a']\n        x0 = case['x0']\n        v0 = case['v0']\n        dt = case['dt']\n        P = case['P']\n\n        # Calculate orbital period and number of steps\n        T = 2.0 * np.pi * a**(1.5)\n        N = int(np.ceil(P * T / dt))\n\n        # Initial energy\n        H0 = hamiltonian(x0, v0)\n\n        # Run Explicit Euler simulation\n        x_N_euler, v_N_euler = run_explicit_euler(x0, v0, N, dt)\n        H_N_euler = hamiltonian(x_N_euler, v_N_euler)\n        delta_euler = np.abs(H_N_euler - H0) / np.abs(H0)\n\n        # Run Euler-Cromer simulation\n        x_N_cromer, v_N_cromer = run_euler_cromer(x0, v0, N, dt)\n        H_N_cromer = hamiltonian(x_N_cromer, v_N_cromer)\n        delta_cromer = np.abs(H_N_cromer - H0) / np.abs(H0)\n\n        # Calculate the ratio of energy drifts\n        # Handle the case where delta_euler is zero to avoid division by zero\n        if delta_euler == 0.0:\n            # If Euler has no drift, and Cromer does, ratio is infinity.\n            # If neither has drift, ratio is undefined, but 1.0 is a neutral choice.\n            # In practice, with finite precision, this is unlikely.\n            r = 1.0 if delta_cromer == 0.0 else np.inf\n        else:\n            r = delta_cromer / delta_euler\n        \n        results.append(r)\n\n    # Format the final output string\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2390259"}, {"introduction": "虽然像四阶龙格-库塔（RK4）这样的高阶方法在解决许多微分方程问题时表现出色，但长期的轨道模拟提出了独特的挑战。这个练习 [@problem_id:2423025] 深入探讨了通用高阶积分器与结构保持的辛积分器（如蛙跳法）之间的关键区别。通过观察RK4方法中能量的长期漂移与蛙跳法中有界能量振荡的对比，你将深刻理解为天体力学模拟选择正确数值工具的重要性。", "problem": "考虑牛顿定律下的平面二体引力问题，其引力参数为 $\\mu$。在无量纲单位下，设 $\\mu = 1$，因此半长轴 $a = 1$ 的轨道周期为 $T = 2\\pi$。状态为 $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t)) \\in \\mathbb{R}^{4}$，其中 $\\mathbf{r}(t) \\in \\mathbb{R}^{2}$ 是位置，$\\mathbf{v}(t) \\in \\mathbb{R}^{2}$ 是速度。运动方程为常微分方程 (ODE)：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}, \\qquad\n\\frac{d\\mathbf{v}}{dt} = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}},\n$$\n其中 $\\|\\cdot\\|$ 是欧几里得范数。精确解的守恒比轨道能量（单位质量能量）为：\n$$\nE(\\mathbf{r},\\mathbf{v}) = \\frac{1}{2}\\,\\|\\mathbf{v}\\|^{2} - \\frac{1}{\\|\\mathbf{r}\\|}.\n$$\n对于一个半长轴为 $a$、离心率为 $e$ 的椭圆，其近心点半径为 $r_{\\mathrm{p}} = a(1-e)$，近心点速度由活力公式给出：$v_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}$。你将使用此公式在近心点初始化轨道，平面坐标为 $\\mathbf{r}(0) = (r_{\\mathrm{p}},0)$ 和 $\\mathbf{v}(0) = (0,v_{\\mathrm{p}})$。\n\n你的任务是量化和比较应用于此开普勒轨道的两种数值时间积分器的长期能量行为：\n\n- 阶数为 $p=4$ 的经典四阶 Runge–Kutta 方法 (RK4)。\n- 阶数为 $p=2$ 的二阶辛 Leapfrog (速度 Verlet) 方法。\n\n从第一性原理来看，单步法的精度阶数定义为其全局误差在固定有限时间内随时间步长 $h$ 减小的速率，而辛性质则关系到哈密顿系统中的结构保持。在引力二体运动中，精确能量 $E$ 是恒定的，因此任何偏差都纯粹是数值计算的产物。你需要测量：\n\n1. RK4 的线性漂移度量：在离散时间 $t_n = nh$（其中 $n=0,1,\\dots,N$）构建时间序列 $y(t_n) = \\big(E(\\mathbf{r}_n,\\mathbf{v}_n) - E_0\\big)/|E_0|$，其中 $E_0 = E(\\mathbf{r}_0,\\mathbf{v}_0)$。对 $y$ 与 $t$ 进行最小二乘线性拟合，以估计漂移率 $\\hat{s}$（无量纲，单位为每单位无量纲时间），并将模拟时域内的总线性漂移报告为 $\\Delta_{\\mathrm{RK4}} = \\hat{s}\\,T_{\\mathrm{end}}$，其中 $T_{\\mathrm{end}}$ 是总模拟时间。\n2. Leapfrog 的有界振荡度量：计算整个轨迹上的最大绝对相对能量偏差 $\\mathcal{A}_{\\mathrm{LF}} = \\max_{0\\le n\\le N} |y(t_n)|$。\n\n实现这两种积分器，并为以下测试套件计算这两个度量。所有量都是无量纲的；除了此处给出的定义外，不需要任何物理单位。输入中不提供任何角度，你的推理或代码中使用的任何内部角度默认单位为弧度。\n\n测试套件（每个案例都使用 $a=1$，$\\mu=1$，并模拟 $N_{\\mathrm{per}}=200$ 个完整周期，因此 $T_{\\mathrm{end}} = N_{\\mathrm{per}}\\cdot 2\\pi$）：\n\n- 案例1：离心率 $e=0$，时间步长 $h=0.05$。\n- 案例2：离心率 $e=0.6$，时间步长 $h=0.05$。\n- 案例3：离心率 $e=0.6$，时间步长 $h=0.02$。\n\n对于每个案例，按照规定使用活力公式在近心点进行初始化。对于 RK4，计算如上定义的 $\\Delta_{\\mathrm{RK4}}$。对于 Leapfrog，计算如上定义的 $\\mathcal{A}_{\\mathrm{LF}}$。你的程序应该生成单行输出，其中包含一个由三个项目组成的逗号分隔列表，每个项目对应一个测试案例。每个项目本身是一个双元素列表，顺序为 $[\\Delta_{\\mathrm{RK4}},\\mathcal{A}_{\\mathrm{LF}}]$。例如，整体输出格式必须是：\n$$\n[\\,[\\Delta_{\\mathrm{RK4}}^{(1)},\\mathcal{A}_{\\mathrm{LF}}^{(1)}],\\,[\\Delta_{\\mathrm{RK4}}^{(2)},\\mathcal{A}_{\\mathrm{LF}}^{(2)}],\\,[\\Delta_{\\mathrm{RK4}}^{(3)},\\mathcal{A}_{\\mathrm{LF}}^{(3)}]\\,],\n$$\n以浮点数形式打印在单行上。为了可读性，请将打印的浮点数四舍五入到合理的有效位数。\n\n你的代码必须完全自包含，不需要用户输入，并且必须精确地按照此处的定义实现两种积分器和能量诊断。", "solution": "该问题要求对应用于平面引力二体问题的两种数值积分器——四阶 Runge-Kutta 方法 (RK4) 和二阶 Leapfrog 方法——进行定量比较。其目标是数值上展示它们相对于守恒量——比轨道能量——的特征性长期行为。对于像 RK4 这样的通用、非结构保持方法，能量预计会表现出长期漂移。对于像 Leapfrog 这样的辛方法，能量误差预计会保持有界。我们将计算特定的度量来量化这些现象。\n\n该系统由状态向量 $\\mathbf{y}(t) = (\\mathbf{r}(t), \\mathbf{v}(t))$ 描述，其中 $\\mathbf{r} \\in \\mathbb{R}^2$ 是位置，$\\mathbf{v} \\in \\mathbb{R}^2$ 是速度。运动方程由一阶常微分方程 (ODE) 系统 $\\dot{\\mathbf{y}} = f(\\mathbf{y})$ 给出：\n$$\n\\frac{d\\mathbf{r}}{dt} = \\mathbf{v}\n$$\n$$\n\\frac{d\\mathbf{v}}{dt} = \\mathbf{a}(\\mathbf{r}) = -\\frac{\\mathbf{r}}{\\|\\mathbf{r}\\|^{3}}\n$$\n这对应于引力参数 $\\mu=1$。该系统是哈密顿系统，其比轨道能量 $E$ 是精确解的一个守恒量：\n$$\nE(\\mathbf{r}, \\mathbf{v}) = \\frac{1}{2}\\|\\mathbf{v}\\|^{2} - \\frac{1}{\\|\\mathbf{r}\\|}\n$$\n轨道在近心点进行初始化。对于给定的半长轴 $a$ 和离心率 $e$，近心点半径为 $r_{\\mathrm{p}} = a(1-e)$。初始位置设为 $\\mathbf{r}(0) = (r_{\\mathrm{p}}, 0)$。相应的近心点速度 $v_{\\mathrm{p}}$ 由活力公式得出：\n$$\nv_{\\mathrm{p}} = \\sqrt{\\mu\\left(\\frac{2}{r_{\\mathrm{p}}} - \\frac{1}{a}\\right)}\n$$\n初始速度则为 $\\mathbf{v}(0) = (0, v_{\\mathrm{p}})$。对于所有指定的测试案例，我们有 $a=1$ 和 $\\mu=1$，这意味着精确的初始能量为 $E_0 = E(\\mathbf{r}(0), \\mathbf{v}(0)) = -\\frac{\\mu}{2a} = -0.5$。\n\n我们将实现两种不同的单步法，以根据时间 $t_n$ 的解 $\\mathbf{y}_n$ 来近似时间 $t_{n+1} = t_n + h$ 的解 $\\mathbf{y}_{n+1}$。\n\n首先，是阶数为 $p=4$ 的经典四阶 Runge-Kutta (RK4) 方法。对于一个 ODE $\\dot{\\mathbf{y}} = f(t, \\mathbf{y})$，单个步长的计算如下：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{y}_n) \\\\\n\\mathbf{k}_2 = f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(t_n + \\frac{h}{2}, \\mathbf{y}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(t_n + h, \\mathbf{y}_n + h \\mathbf{k}_3) \\\\\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n此处，$\\mathbf{y} = (\\mathbf{r}, \\mathbf{v})$ 是一个 4 维向量，函数 $f$ 不显式依赖于时间 $t$，因此 $f(t, \\mathbf{y}) = f(\\mathbf{y}) = (\\mathbf{v}, -\\mathbf{r}/\\|\\mathbf{r}\\|^3)$。\n\n其次，是阶数为 $p=2$ 的二阶 Leapfrog 方法，采用其速度 Verlet 形式。该方法特别适用于形式为 $H(\\mathbf{r},\\mathbf{v}) = T(\\mathbf{v}) + U(\\mathbf{r})$ 的可分哈密顿量。加速度 $\\mathbf{a}(\\mathbf{r})$ 仅依赖于位置。从 $(\\mathbf{r}_n, \\mathbf{v}_n)$ 和预先计算的加速度 $\\mathbf{a}_n = \\mathbf{a}(\\mathbf{r}_n)$ 开始，单个步长的计算过程如下：\n$$\n\\begin{aligned}\n\\mathbf{r}_{n+1} = \\mathbf{r}_n + h \\mathbf{v}_n + \\frac{h^2}{2} \\mathbf{a}_n \\\\\n\\mathbf{a}_{n+1} = \\mathbf{a}(\\mathbf{r}_{n+1}) = -\\frac{\\mathbf{r}_{n+1}}{\\|\\mathbf{r}_{n+1}\\|^{3}} \\\\\n\\mathbf{v}_{n+1} = \\mathbf{v}_n + \\frac{h}{2}(\\mathbf{a}_n + \\mathbf{a}_{n+1})\n\\end{aligned}\n$$\n这种方法是辛的，保证了它能保持哈密顿系统相空间流的几何结构。其结果是，虽然数值能量不被精确守恒，但其误差在极长的积分时间内保持有界。\n\n在每一步 $n=0, 1, \\dots, N$，我们计算数值能量 $E_n = E(\\mathbf{r}_n, \\mathbf{v}_n)$ 和相对能量误差：\n$$\ny_n = \\frac{E_n - E_0}{|E_0|}\n$$\n对这些积分器的评估依赖于两个不同的度量。对于 RK4 方法，我们量化能量的线性漂移。我们对时间序列 $(t_n, y_n)$（其中 $t_n = nh$）进行线性最小二乘拟合，以找到模型 $y(t) = \\hat{s}t + c$。斜率 $\\hat{s}$ 代表能量漂移率。在模拟时域 $T_{\\mathrm{end}} = N_{\\mathrm{per}} \\cdot 2\\pi = 400\\pi$ 内的总漂移报告为：\n$$\n\\Delta_{\\mathrm{RK4}} = \\hat{s} \\cdot T_{\\mathrm{end}}\n$$\n对于 Leapfrog 方法，我们通过计算整个模拟过程中的最大绝对相对能量偏差来量化能量误差的有界振荡：\n$$\n\\mathcal{A}_{\\mathrm{LF}} = \\max_{0 \\le n \\le N} |y_n|\n$$\n\n我们进行总时间为 $T_{\\mathrm{end}} = 200 \\cdot 2\\pi = 400\\pi$ 的模拟。步数为 $N = \\text{round}(T_{\\mathrm{end}}/h)$。对于三个测试案例中的每一个，我们计算初始条件，运行两种积分器，并计算所需的度量。\n\n案例1：$e=0$, $h=0.05$。\n- 初始条件：$a=1$, $e=0 \\implies r_{\\mathrm{p}} = 1$。$v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{1} - \\frac{1}{1})} = 1$。$\\mathbf{r}_0 = (1, 0)$, $\\mathbf{v}_0 = (0, 1)$。\n- $N = \\text{round}(400\\pi / 0.05) = 25133$。\n\n案例2：$e=0.6$, $h=0.05$。\n- 初始条件：$a=1$, $e=0.6 \\implies r_{\\mathrm{p}} = 0.4$。$v_{\\mathrm{p}} = \\sqrt{1(\\frac{2}{0.4} - \\frac{1}{1})} = 2$。$\\mathbf{r}_0 = (0.4, 0)$, $\\mathbf{v}_0 = (0, 2)$。\n- $N = \\text{round}(400\\pi / 0.05) = 25133$。\n\n案例3：$e=0.6$, $h=0.02$。\n- 初始条件：与案例2相同。$\\mathbf{r}_0 = (0.4, 0)$, $\\mathbf{v}_0 = (0, 2)$。\n- $N = \\text{round}(400\\pi / 0.02) = 62832$。\n\n对于每个案例，初始能量为 $E_0 = -0.5$。计算根据指定的步骤进行。实现过程包括编写加速度函数、RK4 步进函数和 Leapfrog 步进函数，然后为测试套件中的每个案例组织模拟和度量计算。最终输出将是一个列表，其中包含每个测试案例的配对 $[\\Delta_{\\mathrm{RK4}}, \\mathcal{A}_{\\mathrm{LF}}]$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares RK4 and Leapfrog integrators for the Kepler problem\n    and computes energy drift/oscillation metrics.\n    \"\"\"\n    # Define problem constants and test suite\n    MU_GRAV = 1.0\n    SEMI_MAJOR_AXIS = 1.0\n    N_PERIODS = 200\n    T_END = N_PERIODS * 2 * np.pi\n\n    test_cases = [\n        {'e': 0.0, 'h': 0.05},\n        {'e': 0.6, 'h': 0.05},\n        {'e': 0.6, 'h': 0.02},\n    ]\n\n    results = []\n\n    for case in test_cases:\n        eccentricity = case['e']\n        h = case['h']\n\n        # --- Initial Conditions ---\n        r_pericenter = SEMI_MAJOR_AXIS * (1 - eccentricity)\n        v_pericenter = np.sqrt(MU_GRAV * (2 / r_pericenter - 1 / SEMI_MAJOR_AXIS))\n        \n        r0 = np.array([r_pericenter, 0.0])\n        v0 = np.array([0.0, v_pericenter])\n        \n        y0 = np.concatenate([r0, v0])\n\n        E0 = 0.5 * np.linalg.norm(v0)**2 - MU_GRAV / np.linalg.norm(r0)\n        \n        N_steps = int(np.round(T_END / h))\n        times = np.linspace(0, N_steps * h, N_steps + 1)\n        \n        # --- Helper functions ---\n        def acceleration(r):\n            dist_cubed = np.linalg.norm(r)**3\n            return -MU_GRAV * r / dist_cubed\n\n        def f_ode(y):\n            r = y[:2]\n            v = y[2:]\n            accel = acceleration(r)\n            return np.concatenate([v, accel])\n            \n        def energy(r, v):\n            return 0.5 * np.linalg.norm(v)**2 - MU_GRAV / np.linalg.norm(r)\n\n        # --- Integrator 1: RK4 ---\n        y_rk4 = np.zeros((N_steps + 1, 4))\n        y_rk4[0] = y0\n        \n        for n in range(N_steps):\n            k1 = f_ode(y_rk4[n])\n            k2 = f_ode(y_rk4[n] + 0.5 * h * k1)\n            k3 = f_ode(y_rk4[n] + 0.5 * h * k2)\n            k4 = f_ode(y_rk4[n] + h * k3)\n            y_rk4[n+1] = y_rk4[n] + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        \n        energies_rk4 = np.array([energy(y[:2], y[2:]) for y in y_rk4])\n        rel_energy_error_rk4 = (energies_rk4 - E0) / np.abs(E0)\n        \n        # Calculate Delta_RK4\n        slope, _ = np.polyfit(times, rel_energy_error_rk4, 1)\n        delta_rk4 = slope * T_END\n\n        # --- Integrator 2: Leapfrog (Velocity Verlet) ---\n        r_lf = np.zeros((N_steps + 1, 2))\n        v_lf = np.zeros((N_steps + 1, 2))\n        \n        r_lf[0] = r0\n        v_lf[0] = v0\n        \n        a_n = acceleration(r_lf[0])\n        \n        for n in range(N_steps):\n            # Update position to full step\n            r_lf[n+1] = r_lf[n] + h * v_lf[n] + 0.5 * h**2 * a_n\n            \n            # Compute new acceleration\n            a_n_plus_1 = acceleration(r_lf[n+1])\n            \n            # Update velocity to full step\n            v_lf[n+1] = v_lf[n] + 0.5 * h * (a_n + a_n_plus_1)\n            \n            # Store new acceleration for a_n in the next step\n            a_n = a_n_plus_1\n\n        energies_lf = np.array([energy(r_lf[i], v_lf[i]) for i in range(N_steps + 1)])\n        rel_energy_error_lf = (energies_lf - E0) / np.abs(E0)\n\n        # Calculate A_LF\n        A_lf = np.max(np.abs(rel_energy_error_lf))\n\n        results.append([delta_rk4, A_lf])\n\n    # Format the final output string according to the problem specification\n    result_str = '[' + ','.join([f\"[{res[0]:.6e},{res[1]:.6e}]\" for res in results]) + ']'\n    print(result_str)\n\nsolve()\n```", "id": "2423025"}]}