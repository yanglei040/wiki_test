{"hands_on_practices": [{"introduction": "逻辑斯蒂映射的分岔图充满了有趣的结构，其中“超循环”（supercycles）是特别重要的参考点。一个参数 $r$ 对应一个超循环，指的是系统的临界点 $x_c=1/2$ 本身是一个周期点。通过求解方程 $f_r^{(p)}(1/2) - 1/2 = 0$，我们可以精确定位这些特殊的 $r$ 值。这个练习 [@problem_id:2409482] 旨在让你亲手实践参数空间的探索，并应用基于介值定理的稳健数值方法（如二分法或布伦特方法）来精确锁定动力系统的关键特征。", "problem": "给定一个单参数逻辑斯蒂族，它由映射 $f_{r}(x) = r\\,x\\,(1-x)$ 在单位区间 $[0,1]$ 上的迭代定义，其中 $r \\in [0,4]$。其临界点为 $x_{\\mathrm{c}} = 1/2$。如果临界点是周期性的，且其精确的最小周期为 $p$，即 $p$ 重复合映射 $f_{r}^{(p)}$ 满足 $f_{r}^{(p)}(1/2) = 1/2$，而对于 $p$ 的每个真因子 $q$，都有 $f_{r}^{(q)}(1/2) \\neq 1/2$，那么参数值 $r$ 就被称为一个本原周期为 $p \\in \\mathbb{N}$ 的超循环（也称超稳定循环）。等价地，周期为 $p$ 的超循环是指标量方程 $g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2 = 0$ 在 $r \\in [0,4]$ 内的一个解，并且对于 $p$ 的任何真因子 $q$，$g_{q}(r)$ 都不为零。函数 $g_{p}$ 在 $r$ 上是连续的，因为它是通过对以 $x=1/2$ 为初值的关于 $r$ 和 $x$ 的多项式进行有限次复合得到的。\n\n您的任务是开发一种算法，对于每个指定的整数周期 $p$，高精度地定位最小的参数值 $r \\in (0,4]$，使得 $x=1/2$ 是一个本原周期为 $p$ 的周期点。您的算法必须仅使用基本事实（多项式映射的连续性、函数迭代的性质和介值定理 (IVT)）从第一性原理出发进行论证。您不得对任何特殊参数值使用闭式表达式。\n\n算法要求：\n1) 通过显式迭代定义逻辑斯蒂映射 $f_{r}(x) = r\\,x\\,(1-x)$ 及其在 $x=1/2$ 处的 $p$ 次迭代 $f_{r}^{(p)}$。定义 $g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2$。\n2) 对于每个周期 $p$，在 $[0,4]$ 上的一个密集网格上搜索 $g_{p}(r)$ 的符号变化，以获得满足 $g_{p}(a)\\,g_{p}(b) \\le 0$ 的区间 $\\,[a,b]\\,$。使用介值定理证明每个区间至少包含一个根。然后，使用稳健的区间法（如二分法或 Brent 方法）将每个区间内的根提炼出来，确保数值容差在 $r$ 上达到优于 $10^{-10}$ 的绝对精度。\n3) 筛选这些根，只保留那些本原周期恰好为 $p$ 的根。具体来说，对于 $g_{p}$ 的每个候选根 $r^{\\star}$，验证对于 $p$ 的每个真因子 $q$，$|g_{q}(r^{\\star})|$ 都大于一个小的阈值。等价地，数值上确认对于 $p$ 的真因子 $q$，不会发生更早的返回 $f_{r^{\\star}}^{(q)}(1/2) = 1/2$。在剩下的候选根中，选择最小的 $r$。\n4) 所有与零的数值比较都应使用明确说明的容差。对函数值使用绝对容差，对根的精化使用绝对和相对容差的组合。您的搜索网格必须足够精细，以捕捉狭窄的参数值窗口。\n\n测试套件：\n- 要分析的周期：$p \\in \\{1,2,3,4,5\\}$。\n- 参数搜索域：$r \\in [0,4]$。\n- 容差：对于返回的 $r$ 值，目标绝对误差小于 $10^{-10}$；在检验本原性时，仅当 $|g_{q}(r)| \\le 10^{-12}$ 时，才宣告 $f_{r}^{(q)}(1/2) = 1/2$。\n\n答案规格：\n- 对于 $p=1, p=2, p=3, p=4, p=5$ 中的每个 $p$（按此顺序），计算最小的参数值 $r \\in (0,4]$，使得 $x=1/2$ 是一个本原周期为 $p$ 的周期点。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个值都四舍五入到10位小数，例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$，其中每个 $r_{k}$ 都是一个四舍五入到10位小数的十进制数。", "solution": "该问题要求计算本原周期 $p \\in \\{1,2,3,4,5\\}$ 对应的最小超循环参数 $r_{p} \\in (0,4]$。如果逻辑斯蒂映射的临界点 $x_{\\mathrm{c}} = 1/2$ 是一个最小周期为 $p$ 的周期点，则参数值 $r$ 对应于一个本原周期为 $p$ 的超循环。\n\n逻辑斯蒂映射定义为：\n$$f_{r}(x) = r\\,x\\,(1-x)$$\n其中状态变量 $x$ 在单位区间 $[0,1]$上，分岔参数 $r$ 在范围 $[0,4]$ 内。\n\n临界点 $x_{\\mathrm{c}} = 1/2$ 成为周期为 $p$ 的周期点的条件是，其第 $p$ 次迭代返回其自身：\n$$f_{r}^{(p)}(1/2) = 1/2$$\n其中 $f_{r}^{(p)}$ 表示映射 $f_{r}$ 与自身的 $p$ 重复合。这可以表示为寻找函数 $g_{p}(r)$ 的根：\n$$g_{p}(r) = f_{r}^{(p)}(1/2) - 1/2 = 0$$\n函数 $g_{p}(r)$ 是通过从 $x_{0} = 1/2$ 开始迭代映射来构造的：\n$x_{1} = f_{r}(x_{0}) = f_{r}(1/2) = r/4$\n$x_{2} = f_{r}(x_{1}) = f_{r}(r/4) = r(r/4)(1 - r/4)$\n$...$\n$x_{p} = f_{r}^{(p)}(1/2)$\n因此，$g_{p}(r) = x_{p} - 1/2$。由于 $f_{r}(x)$ 是关于 $r$ 和 $x$ 的多项式，并且迭代从一个常数开始，因此得到的函数 $g_{p}(r)$ 是一个关于 $r$ 的多项式。作为一个多项式，$g_{p}(r)$ 对所有 $r \\in \\mathbb{R}$ 都是连续的。这一基本性质为使用基于介值定理（IVT）的求根算法提供了依据。\n\n$g_{p}(r) = 0$ 的一个根 $r^{\\star}$ 对应于一个*本原*周期为 $p$ 的超循环，当且仅当 $x_{\\mathrm{c}} = 1/2$ 的轨道在任何更早的、作为 $p$ 的真因子的迭代次数 $q$ 时，都没有返回到 $1/2$。也就是说，对于一个给定的根 $r^{\\star}$：\n$$f_{r^{\\star}}^{(q)}(1/2) \\neq 1/2 \\quad \\text{对于所有 } q \\in \\{1, 2, ..., p-1\\} \\text{ 且 } p \\pmod q = 0$$\n这等价于对于 $p$ 的所有真因子 $q$，$g_{q}(r^{\\star}) \\neq 0$ 的条件。\n\n算法解决方案按规定分为三个阶段设计。\n\n**1. 根的区间定位**\n为了定位潜在的超循环参数，我们首先识别出保证包含 $g_{p}(r) = 0$ 的根的区间。这通过在参数域 $r \\in [0,4]$ 上进行系统性搜索来实现。我们定义一个覆盖该区间的密集网格点 $r_{i}$，步长很小，例如 $\\Delta r = 10^{-4}$。对于每个周期 $p$ 和每对相邻的网格点 $(r_{i}, r_{i+1})$，我们计算乘积 $g_{p}(r_{i}) \\cdot g_{p}(r_{i+1})$。如果该乘积小于或等于 $0$，则表示存在符号变化（或在某个端点处有根）。根据介值定理，$g_{p}(r)$ 的连续性保证了在区间 $[r_{i}, r_{i+1}]$ 中至少存在一个根 $r^{\\star}$。所有这样的区间都被收集起来以供进一步处理。\n\n**2. 根的精化**\n在第一阶段获得的每个区间 $[a,b]$ 都将应用高精度求根算法。如建议所述，我们采用 Brent 方法，这是一种稳健且高效的区间算法，它结合了二分法、割线法和逆二次插值。只要 $g_{p}(a)$ 和 $g_{p}(b)$ 异号，该方法就保证收敛。我们配置算法来精化每个根 $r^{\\star}$，直到包围区间的宽度小于指定的容差 $10^{-10}$，从而确保参数值达到所需的精度。此过程为每个周期 $p$ 产生一组候选根。\n\n**3. 本原性筛选与最终选择**\n为 $g_{p}(r) = 0$ 找到的候选根集合包括了所有使 $x_{\\mathrm{c}}=1/2$ 的周期能整除 $p$ 的参数。为了分离出对应于*本原*周期 $p$ 的参数，我们必须筛选掉那些使 $x_{\\mathrm{c}}=1/2$ 具有更短周期 $q$（其中 $q$ 是 $p$ 的一个真因子）的参数。对于每个候选根 $r^{\\star}$，我们执行以下检查：\n对于 $p$ 的每个真因子 $q$，我们计算 $g_{q}(r^{\\star})$。如果对于*所有*真因子 $q$，$|g_{q}(r^{\\star})|$ 都大于指定的数值容差 $10^{-12}$，则该根 $r^{\\star}$ 被确认为对应于一个本原周期为 $p$ 的超循环。否则，它将被丢弃。\n\n筛选后，我们得到一组对应于本原周期为 $p$ 的超循环的参数。问题要求在域 $(0,4]$ 中找到最小的此类参数。因此，我们从此组经过验证的根中找到最小值。对每个指定的周期 $p \\in \\{1,2,3,4,5\\}$ 重复整个过程，以产生最终的结果列表。此方法是系统性的，并基于基本的数值原理，确保了解决方案的正确性和可验证性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Computes the smallest supercycle parameter r for primitive periods p from 1 to 5.\n    A supercycle of primitive period p occurs when the critical point x_c = 1/2 is\n    periodic with exact minimal period p.\n    \"\"\"\n    \n    # Define the periods to analyze as per the problem statement.\n    test_cases = [1, 2, 3, 4, 5]\n    \n    # Define parameters for the numerical procedure.\n    r_min, r_max = 0.0, 4.0\n    grid_points = 40001 # Grid step of 1e-4\n    root_tolerance_r = 1e-11 # Target error  1e-10\n    primitivity_tolerance_g = 1e-12\n\n    results = []\n    \n    def get_g_p(p):\n        \"\"\"\n        Returns a function g_p(r) = f_r^(p)(1/2) - 1/2.\n        This uses a closure to capture the period p.\n        \"\"\"\n        def g(r_val):\n            \"\"\"Calculates the p-th iterate of the logistic map from x=0.5 and subtracts 0.5.\"\"\"\n            x = 0.5\n            # Use high-precision floats for iteration to minimize round-off error.\n            r_val_f = float(r_val)\n            x_f = float(x)\n            for _ in range(p):\n                x_f = r_val_f * x_f * (1.0 - x_f)\n            return x_f - 0.5\n        return g\n\n    def get_proper_divisors(n):\n        \"\"\"\n        Finds all proper divisors of an integer n.\n        For the small p in this problem, a simple loop is sufficient.\n        \"\"\"\n        if n == 1:\n            return []\n        divisors = {1}\n        for i in range(2, int(np.sqrt(n)) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return sorted(list(divisors))\n\n    # Main loop over each period p\n    for p in test_cases:\n        g_p_func = get_g_p(p)\n        proper_divisors = get_proper_divisors(p)\n        \n        primitive_roots = []\n        \n        # Stage 1: Search for brackets using a dense grid\n        r_grid = np.linspace(r_min, r_max, grid_points)\n        g_values = np.array([g_p_func(r) for r in r_grid])\n\n        for i in range(len(r_grid) - 1):\n            r_a, r_b = r_grid[i], r_grid[i+1]\n            g_a, g_b = g_values[i], g_values[i+1]\n\n            # Check for sign change (bracket found)\n            if g_a * g_b = 0:\n                # Stage 2: Refine the root within the bracket\n                try:\n                    # Brent's method requires a strict sign change.\n                    # If an endpoint is a root, g_a*g_b = 0.\n                    if g_a == 0:\n                        r_star = r_a\n                    elif g_b == 0:\n                        r_star = r_b\n                    else:\n                        r_star = brentq(g_p_func, r_a, r_b, xtol=root_tolerance_r, rtol=root_tolerance_r)\n                except ValueError:\n                    # This might happen if g_a and g_b have the same sign despite g_a*g_b=0 (due to rounding)\n                    # or if brentq otherwise fails. It's safe to skip.\n                    continue\n\n                # Stage 3: Filter for primitivity\n                is_primitive = True\n                if proper_divisors:\n                    for q in proper_divisors:\n                        g_q_func = get_g_p(q)\n                        if abs(g_q_func(r_star)) = primitivity_tolerance_g:\n                            is_primitive = False\n                            break\n                \n                if is_primitive:\n                    # Check for r > 0, as problem asks for r in (0, 4]\n                    if r_star > 1e-12: # Check against small tolerance to exclude r=0\n                        primitive_roots.append(r_star)\n\n        # Final Selection: Find the smallest primitive root\n        if not primitive_roots:\n            # This case should not be reached for the given problem periods.\n            # It would indicate no primitive supercycle was found.\n            # We can append a placeholder, but it implies an issue with the search.\n            # raise RuntimeError(f\"No primitive root found for p={p}\")\n            results.append(np.nan)\n        else:\n            # Find the minimum of the unique roots found\n            unique_roots = sorted(list(set(primitive_roots)))\n            results.append(min(unique_roots))\n\n    # Final print statement in the exact required format.\n    # Round to 10 decimal places as requested.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2409482"}, {"introduction": "在找到超循环这些特殊参数点之后，一个更普遍的问题是：对于一个给定的参数 $r$，系统有哪些稳定的长期行为（即吸引子）？找到所有吸引周期轨道能够帮助我们完整地描绘系统在特定参数下的动力学全貌。这个问题 [@problem_id:2409563] 引导我们使用更为强大的牛顿-拉夫逊法来求解方程 $f_r^{(n)}(x) - x = 0$，这需要我们高效地利用链式法则计算迭代映射的导数。通过这个练习，你将掌握实现高级数值求解器的技能，并学会对解进行严格验证，包括检查稳定性和本征周期性，这些都是表征动力学系统的核心能力。", "problem": "考虑由函数 $f_{r}(x) = r x (1 - x)$ 定义的逻辑斯蒂映射，该函数作用于单位区间 $[0,1]$ 上，其中控制参数 $r \\in [0,4]$。对于一个正整数 $n$，用 $f_{r}^{n}(x)$ 表示 $f_{r}$ 与自身的 $n$ 次复合。如果一个点 $x^{\\star} \\in [0,1]$ 满足 $f_{r}^{n}(x^{\\star}) = x^{\\star}$，并且对于每个整除 $n$ 且 $d  n$ 的正整数 $d$，都有 $f_{r}^{d}(x^{\\star}) \\neq x^{\\star}$，则称该点为本原周期为 $n$ 的周期点。此类周期点的稳定性由乘子 $\\lambda_{n}(x^{\\star}) = (f_{r}^{n})'(x^{\\star})$ 来刻画，如果 $|\\lambda_{n}(x^{\\star})|  1$，则该周期点是吸引的。\n\n您的任务是开发一个完整、可运行的程序，对于给定的 $(r,n)$，高效地找到逻辑斯蒂映射在 $[0,1]$ 上的所有不同的吸引性本原周期-$n$ 轨道。该算法必须从适用于计算物理和动力系统的第一性原理出发：函数复合的定义、导数的链式法则以及用于求解非线性方程的牛顿-拉夫逊方法。关键思想是求解方程 $F_{n}(x) = f_{r}^{n}(x) - x = 0$，其中导数 $F'_{n}(x) = (f_{r}^{n})'(x) - 1$ 是通过沿 $x$ 的 $n$ 步轨道应用链式法则来高效计算的。您还必须确保报告的每个解都是本原的（即，精确周期为 $n$）和吸引的（即，满足 $|(f_{r}^{n})'(x)|  1$），并且对轨道进行去重，直到点的循环置换为止。\n\n程序必须纯粹以数学方式实现以下计算步骤，不依赖任何外部数据：\n- 在 $[0,1]$ 中使用多个初始猜测值。\n- 对每个初始猜测值，对方程 $F_{n}(x) = 0$ 应用牛顿-拉夫逊迭代，其导数基于 $(f_{r}^{n})'(x)$，并通过沿迭代序列 $x, f_{r}(x), f_{r}^{2}(x), \\dots, f_{r}^{n-1}(x)$ 应用链式法则计算得出。\n- 仅当 $|F_{n}(x^{\\star})|$ 低于一个严格的容差，$x^{\\star} \\in [0,1]$，周期是本原的（不存在更小的因子 $d$ 使得 $f_{r}^{d}(x^{\\star}) \\approx x^{\\star}$），并且轨道是吸引的，满足 $|(f_{r}^{n})'(x^{\\star})|  1$ 时，才接受候选根 $x^{\\star}$。\n- 将所有找到的根分组为 $[0,1]$ 上不同的吸引性本原周期-$n$ 轨道，其中如果两个根在 $f_{r}$ 下的前向 $n$ 元组在数值容差范围内，经过循环置换后重合，则它们属于同一轨道。\n- 返回不同的吸引性本原周期-$n$ 轨道的数量。\n\n不涉及角度。不涉及物理单位。所有数值输出必须是标准十进制表示的实数。\n\n测试套件和要求的输出：\n- 使用以下参数案例：$(r,n) = (0.5, 1)$, $(2.5, 1)$, $(3.2, 2)$, $(3.83, 3)$, $(4.0, 1)$。\n- 对于每个案例，您的程序必须计算一个整数：在 $[0,1]$ 中找到的不同吸引性本原周期-$n$ 轨道的数量。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如 $[a,b,c,d,e]$），顺序与上面列出的案例相同。\n\n您的最终程序必须是自包含的，不需要任何输入，并且仅使用指定的环境。", "solution": "核心任务是找到逻辑斯蒂映射（由函数 $f_{r}(x) = r x (1 - x)$ 在区间 $[0,1]$ 上定义）的不同吸引性本原周期-$n$ 轨道的数量。如果一个点 $x^{\\star}$ 满足方程 $f_{r}^{n}(x^{\\star}) = x^{\\star}$，则该点是周期-$n$ 轨道的一部分，其中 $f_{r}^{n}$ 表示函数 $f_{r}$ 的第 $n$ 次迭代。这可以重写为求解非线性方程 $F_{n}(x) = f_{r}^{n}(x) - x = 0$ 的根。\n\n为了求解该方程，牛顿-拉夫逊方法是一种合适且强大的数值技术。该方法的迭代公式为：\n$$x_{k+1} = x_{k} - \\frac{F_{n}(x_{k})}{F'_{n}(x_{k})}$$\n其中 $x_{k}$ 是第 $k$ 次迭代的估计值。需要导数 $F'_{n}(x)$，即 $F'_{n}(x) = (f_{r}^{n})'(x) - 1$。\n\n该算法基于以下原则构建：\n\n1.  **高效的函数与导数求值**：$f_{r}^{n}(x)$ 的直接解析表达式是一个 $2^n$ 次的多项式，即使对于中等大小的 $n$，其计算也是难以处理的。因此，$f_{r}^{n}(x)$ 及其导数 $(f_{r}^{n})'(x)$ 都是沿点 $x_0$ 的轨道进行数值计算的。\n    -   为计算 $f_{r}^{n}(x_0)$，生成序列 $x_1 = f_r(x_0)$, $x_2 = f_r(x_1)$, $\\dots$, $x_n = f_r(x_{n-1})$。结果就是 $x_n$。\n    -   为计算导数 $(f_{r}^{n})'(x_0)$，对复合函数 $f_{r}^{n}(x) = f_r(f_r(\\dots f_r(x)\\dots))$ 应用链式法则。这会得到 $f_r$ 的一阶导数在轨道序列中每个点上求值的乘积：\n        $$\\lambda_{n}(x_0) = (f_{r}^{n})'(x_0) = \\prod_{i=0}^{n-1} f'_{r}(x_i) = \\prod_{i=0}^{n-1} r(1 - 2x_i)$$\n        这个乘积 $\\lambda_{n}(x_0)$ 也是轨道的稳定性乘子。\n\n2.  **通过牛顿-拉夫逊搜索求根**：从区间 $[0,1]$ 上大量均匀分布的起始点启动牛顿-拉夫逊方法。这种全面的搜索策略增加了找到所有吸引轨道的概率。对于每个初始猜测值，迭代一直进行，直到连续迭代值之间的变化量低于严格容差 $\\epsilon$（例如 $\\epsilon = 10^{-12}$）或达到最大迭代次数。\n\n3.  **候选根的验证**：一旦牛顿-拉夫逊方法收敛到一个潜在的根 $x^{\\star}$，它将经历一个严格的多阶段验证过程：\n    -   **收敛性**：首先通过检查 $|f_{r}^{n}(x^{\\star}) - x^{\\star}|  \\epsilon$ 来确认 $x^{\\star}$ 确实是一个根。\n    -   **稳定性**：只有当其乘子的绝对值小于1时，轨道才是吸引的。我们必须计算 $\\lambda_{n}(x^{\\star})$ 并验证 $|\\lambda_{n}(x^{\\star})|  1$。对应于排斥或中性轨道（$|\\lambda_{n}(x^{\\star})| \\geq 1$）的根将被丢弃。\n    -   **本原性**：为确保轨道的本原周期恰好为 $n$，我们必须验证它不属于更小的周期 $d$，其中 $d$ 是 $n$ 的真因子（$d|n$ 且 $d  n$）。对于每个这样的 $d$，我们检查 $|f_{r}^{d}(x^{\\star}) - x^{\\star}| > \\epsilon$。如果该条件对任何 $d$ 不成立，则该根属于一个周期为 $d$ 的轨道，并被丢弃。\n\n4.  **轨道去重**：从不同的初始猜测值出发，牛顿-拉夫逊方法可能会收敛到属于同一周期轨道的不同点上。为了只计算不同轨道的数量，去重过程是必要的。当找到一个经过验证的根 $x^{\\star}$ 时，会生成其完整轨道 $\\{x^{\\star}, f_r(x^{\\star}), \\dots, f_r^{n-1}(x^{\\star})\\}$。通过对轨道上的点进行数值排序，创建该轨道的规范表示。然后将此排序后的列表与先前找到的唯一轨道集合进行比较。只有当新轨道与任何已存储的轨道在数值上不接近（在容差范围内，例如 $10^{-9}$）时，才将其添加到集合中。\n\n不同的、吸引的、本原周期为 $n$ 的轨道的最终数量是在搜索完成后集合中唯一轨道的总数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_proper_divisors(n):\n    \"\"\"\n    Finds all proper divisors of an integer n (divisors other than n).\n    \"\"\"\n    if n == 1:\n        return []\n    \n    divisors = {1}\n    for i in range(2, int(np.sqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return sorted(list(divisors))\n\ndef find_attracting_orbits(r, n):\n    \"\"\"\n    Finds the number of distinct attracting primitive period-n orbits for the logistic map\n    f_r(x) = r*x*(1-x).\n\n    Args:\n        r (float): The control parameter of the logistic map.\n        n (int): The period of the orbits to find.\n\n    Returns:\n        int: The number of distinct attracting primitive period-n orbits.\n    \"\"\"\n    # Define numerical parameters for the solver\n    num_guesses = 20000\n    max_newton_iter = 50\n    conv_tol = 1e-12  # Tolerance for root convergence and verification\n    dedup_tol = 1e-9   # Tolerance for orbit point comparison during deduplication\n\n    # Define the logistic map and its first derivative\n    f = lambda x: r * x * (1.0 - x)\n    f_prime = lambda x: r * (1.0 - 2.0 * x)\n\n    proper_divisors = find_proper_divisors(n)\n    found_orbits = []\n\n    # Use a grid of initial guesses in (0, 1) to avoid potential issues at boundaries\n    initial_guesses = np.linspace(1e-4, 1.0 - 1e-4, num_guesses)\n\n    for x_init in initial_guesses:\n        x_k = x_init\n        \n        # Newton-Raphson iteration to find a root of F_n(x) = f^n(x) - x = 0\n        for _ in range(max_newton_iter):\n            if not (0.0 = x_k = 1.0):\n                break # Iteration left the domain of interest\n\n            # Generate the orbit sequence x_0, x_1, ..., x_{n-1} starting from x_k\n            orbit_seq = [x_k]\n            current_x = x_k\n            try:\n                for _ in range(n - 1):\n                    current_x = f(current_x)\n                    orbit_seq.append(current_x)\n            except (OverflowError, ValueError):\n                break # Sequence diverged or resulted in math error\n            \n            x_n = f(current_x)\n\n            # Compute the derivative (multiplier) (f^n)'(x_k) using the chain rule\n            multiplier = 1.0\n            try:\n                for point in orbit_seq:\n                    multiplier *= f_prime(point)\n            except (OverflowError, ValueError):\n                break\n\n            # Define F_n(x_k) and its derivative F_n'(x_k)\n            fn_x = x_n - x_k\n            fn_prime_x = multiplier - 1.0\n\n            if abs(fn_prime_x)  1e-12: # Avoid division by zero or unstable updates\n                break\n\n            x_k_plus_1 = x_k - fn_x / fn_prime_x\n\n            # Check for convergence\n            if abs(x_k_plus_1 - x_k)  conv_tol:\n                x_k = x_k_plus_1\n                break\n            \n            x_k = x_k_plus_1\n        else:\n            # The loop finished without converging, try next initial guess\n            continue\n        \n        # --- Validation of the candidate root x_star = x_k ---\n        x_star = x_k\n\n        # 1. Domain Check: Must be in [0, 1]\n        if not (0.0 = x_star = 1.0):\n            continue\n\n        # 2. Convergence Check: Verify |f^n(x_star) - x_star| is small\n        current_x = x_star\n        try:\n            for _ in range(n):\n                current_x = f(current_x)\n        except (OverflowError, ValueError):\n            continue\n        if abs(current_x - x_star) > conv_tol:\n            continue\n            \n        # 3. Stability Check: The multiplier |(f^n)'(x_star)| must be less than 1\n        orbit_seq = [x_star]\n        current_x = x_star\n        try:\n            for _ in range(n - 1):\n                current_x = f(current_x)\n                orbit_seq.append(current_x)\n        except (OverflowError, ValueError):\n            continue\n        \n        multiplier = 1.0\n        try:\n            for point in orbit_seq:\n                multiplier *= f_prime(point)\n        except (OverflowError, ValueError):\n            continue\n        if abs(multiplier) >= 1.0:\n            continue\n            \n        # 4. Primitivity Check: f^d(x_star) is not close to x_star for any proper divisor d\n        is_primitive = True\n        for d in proper_divisors:\n            current_x = x_star\n            try:\n                for _ in range(d):\n                    current_x = f(current_x)\n            except (OverflowError, ValueError):\n                is_primitive = False\n                break\n            if abs(current_x - x_star) = conv_tol:\n                is_primitive = False\n                break\n        if not is_primitive:\n            continue\n\n        # --- The root is valid. Add its orbit to the list after deduplication ---\n        new_orbit_sorted = sorted(orbit_seq)\n\n        # Check if this orbit is a duplicate of one already found\n        is_duplicate = False\n        for existing_orbit in found_orbits:\n            # Use allclose for element-wise comparison with absolute tolerance\n            if np.allclose(new_orbit_sorted, existing_orbit, rtol=0, atol=dedup_tol):\n                is_duplicate = True\n                break\n        \n        if not is_duplicate:\n            found_orbits.append(new_orbit_sorted)\n            \n    return len(found_orbits)\n\ndef solve():\n    \"\"\"\n    Main function to define test cases, run the solver for each, and print the\n    final results in the specified format.\n    \"\"\"\n    # The set of test cases (r, n) provided in the problem statement.\n    test_cases = [\n        (0.5, 1),\n        (2.5, 1),\n        (3.2, 2),\n        (3.83, 3),\n        (4.0, 1),\n    ]\n\n    results = []\n    for r, n in test_cases:\n        count = find_attracting_orbits(r, n)\n        results.append(count)\n\n    # Print the final results in the required format: [res1,res2,...]\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main solver function.\nsolve()\n```", "id": "2409563"}, {"introduction": "理论上，当参数 $r=4$ 时，逻辑斯蒂映射在连续区间上表现出混沌行为。然而，计算机使用有限精度进行计算，这从根本上改变了系统的动力学。由于状态空间变成了有限的离散格点，根据鸽巢原理，任何轨迹都最终会重复，从而将混沌轨道转变为长的周期循环。通过实现一个有限精度的模型并使用弗洛伊德的“龟兔赛跑”算法来检测周期，这个练习 [@problem_id:2409551] 揭示了理想数学模型与其实际计算实现之间的关键差异，这是计算科学中的一个深刻而重要的概念。", "problem": "考虑由以下递推关系定义的逻辑斯谛映射\n$$ x_{n+1} = r\\,x_n\\,(1 - x_n), $$\n其中控制参数固定为 $r = 4$，初始条件为 $x_0 \\in [0,1]$。为了以一种通用且与语言无关的方式对有限精度算术进行建模，固定一个精度参数 $B \\in \\mathbb{N}$ 并定义 $N = 2^B$。容许状态空间是均匀网格\n$$ \\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}。 $$\n定义量化器 $Q_B:[0,1]\\to \\mathcal{G}_B$ 为\n$$ Q_B(y) = \\frac{\\mathrm{round}(N\\,y)}{N}, $$\n其中 $\\mathrm{round}(\\cdot)$ 表示四舍五入到最近的整数，若结果恰为两整数正中，则取偶数。有限精度逻辑斯谛映射 $F_B:\\mathcal{G}_B \\to \\mathcal{G}_B$ 为\n$$ F_B(x) = Q_B\\!\\left(4\\,x\\,(1-x)\\right)。 $$\n设轨迹为 $x_{n+1} = F_B(x_n)$，其中 $x_0 \\in \\mathcal{G}_B$。定义轨迹的最终周期（也称为循环长度）为任意有限暂态之后周期部分的长度 $ \\lambda \\in \\mathbb{N} $。\n\n任务：\n1) 仅使用第一性原理，证明对于每个固定的 $B \\in \\mathbb{N}$ 和每个初始条件 $x_0 \\in \\mathcal{G}_B$，在 $F_B$ 下的轨迹最终都是周期的，即它有一个有限的暂态长度，然后以某个有限周期 $\\lambda$ 重复。\n\n2) 对于以下测试集，通过对形式为 $x_0 = k/N$（其中 $k \\in \\{1,2,\\dots,S_B\\}$）的 $S_B$ 个初始条件下的最终周期 $\\lambda$ 进行平均，计算平均最终周期：\n- 情况 A：$B = 8$, $S_B = 200$。\n- 情况 B：$B = 12$, $S_B = 200$。\n- 情况 C：$B = 16$, $S_B = 200$。\n将每个平均值报告为一个四舍五入到恰好 $3$ 位小数的实数。\n\n3) 边界情况（单一种子的最终周期）：\n- 情况 D：$B = 8$, $x_0 = 0$。\n- 情况 E：$B = 8$, $x_0 = \\frac{1}{2}$ (即 $k = N/2$）。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]。对于情况 A-C，输出四舍五入到恰好 $3$ 位小数的平均值。对于情况 D-E，输出最终周期为整数。例如，输出应如下所示\n“[10.123,40.321,160.654,1,1]”。\n不应打印任何其他文本。", "solution": "该问题包括一项理论证明和一组数值计算。\n\n**任务1：最终周期性的证明**\n\n该证明是状态空间 $\\mathcal{G}_B$ 有限性的直接推论。\n对于一个固定的精度参数 $B \\in \\mathbb{N}$，网格大小为 $N = 2^B$。状态空间定义为 $\\mathcal{G}_B = \\left\\{ \\frac{k}{N} \\,\\middle|\\, k \\in \\{0,1,2,\\dots,N\\} \\right\\}$。该集合中不同状态的数量，即其基数，为 $|\\mathcal{G}_B| = N+1 = 2^B+1$。对于任何自然数 $B$，这都是一个有限量。\n\n函数 $F_B$ 被构造成将状态空间 $\\mathcal{G}_B$ 映射到其自身，即 $F_B: \\mathcal{G}_B \\to \\mathcal{G}_B$。对于任意初始状态 $x_0 \\in \\mathcal{G}_B$，轨迹是一个无穷的状态序列 $x_0, x_1, x_2, \\dots$，其中每个 $x_n = F_B(x_{n-1}) \\in \\mathcal{G}_B$。\n\n我们有一个从有限的可能性集合中抽取的无穷状态序列。根据鸽巢原理，至少有一个状态必须被访问超过一次。设 $x_j$ 是序列中第一个重复先前状态（比如 $x_i$，$i  j$）的状态。令这对索引 $(i, j)$ 的 $i$ 为最小可能值。\n\n因此，状态序列为 $x_0, x_1, \\dots, x_{i-1}, \\left(x_i, x_{i+1}, \\dots, x_{j-1}\\right), \\dots$。\n片段 $x_0, \\dots, x_{i-1}$ 是轨迹的暂态部分，其长度为有限的 $i$。\n片段 $x_i, \\dots, x_{j-1}$ 构成一个循环。由于映射 $F_B$是确定性的，状态 $x_j=x_i$ 必然会跟随 $x_{j+1} = F_B(x_j) = F_B(x_i) = x_{i+1}$，并且随后的状态将以相同的顺序重复。这确立了序列在暂态部分之后的周期性。这个循环的长度，即最终周期，为 $\\lambda = j-i$。\n\n由于在有限状态空间上的任何轨迹都保证存在这样的索引 $i$ 和 $j$，因此在 $F_B$ 下的每个轨迹最终都是周期的。证明完毕。\n\n**任务2和3：计算算法**\n\n为了计算最终周期 $\\lambda$，我们必须在从给定初始条件生成的轨迹中检测循环。Floyd 循环查找算法，也称为“龟兔赛跑”算法，是一种稳健且高效的方法。\n\n为确保计算精度并在模拟过程中避免浮点表示错误，我们在整数集 $\\{0, 1, \\dots, N\\}$ 上重新构建动力学模型。每个状态 $x_n \\in \\mathcal{G}_B$ 都由一个整数 $k_n$ 唯一表示，使得 $x_n = k_n / N$。分数上的映射 $F_B$ 导出一个相应的整数映射 $f_B(k_n) = k_{n+1}$。\n从 $x_{n+1} = F_B(x_n)$ 出发，我们代入 $x_n = k_n/N$ 和 $x_{n+1} = k_{n+1}/N$：\n$$\n\\frac{k_{n+1}}{N} = Q_B\\left(4 \\frac{k_n}{N} \\left(1 - \\frac{k_n}{N}\\right)\\right) = \\frac{\\mathrm{round}\\left(N \\cdot 4 \\frac{k_n}{N} \\frac{N-k_n}{N}\\right)}{N}\n$$\n这给出了基于整数的递推关系：\n$$\nk_{n+1} = f_B(k_n) = \\mathrm{round}\\left(\\frac{4 k_n (N-k_n)}{N}\\right)\n$$\n问题指定 $\\mathrm{round}(\\cdot)$ 通过选择最近的偶数来处理平局情况。Python的 `round()` 函数（或 `numpy.round`）符合此标准。\n\n将 Floyd 算法应用于由 $k_{n+1} = f_B(k_n)$ 生成的序列 $k_0, k_1, k_2, \\dots$ 的过程分为三个标准阶段：\n1.  **碰撞检测：** 初始化一个“乌龟”指针（每次前进一步）和一个“兔子”指针（每次前进两步）。它们最终保证会在循环内的某个状态相等。\n2.  **循环起点识别：** 将一个指针重置到初始状态 $k_0$，而另一个指针保持在碰撞点。然后两个指针都每次前进一步。它们的下一个相遇点就是循环的第一个状态。\n3.  **周期计算：** 从循环的起点开始，一个指针每次前进一步，直到它返回起点。所需的步数就是循环长度 $\\lambda$。\n\n此算法被实现用于解决这些测试用例。对于情况 A-C，计算了指定初始条件范围内的平均 $\\lambda$。对于情况 D-E，确定了单个初始条件的 $\\lambda$。结果按要求格式化。", "answer": "```python\nimport numpy as np\n\ndef find_eventual_period(B: int, k0: int) -> int:\n    \"\"\"\n    Computes the eventual period of the finite-precision logistic map trajectory.\n\n    The algorithm uses Floyd's cycle-finding algorithm (tortoise and hare)\n    on an integer representation of the state space to avoid floating-point issues.\n\n    Args:\n        B: The precision parameter, defining N = 2**B.\n        k0: The initial state represented as an integer k, where x_0 = k/N.\n\n    Returns:\n        The length of the eventual periodic cycle (lambda).\n    \"\"\"\n    N = 2**B\n\n    # The finite-precision map on the integer state space {0, 1, ..., N}.\n    # The rounding rule \"ties to nearest even\" is correctly implemented by np.round().\n    def f(k: int) -> int:\n        # Use floating point for the division, which is safe as the state 'k' is\n        # always an integer, ensuring exact comparisons.\n        val = 4.0 * k * (N - k) / N\n        return int(np.round(val))\n\n    # Floyd's Algorithm\n    # Phase 1: Find a point in the cycle.\n    # The tortoise moves one step at a time, the hare moves two.\n    try:\n        tortoise = f(k0)\n        hare = f(f(k0))\n    except (OverflowError, ValueError):\n        # In rare cases with very large B, intermediate products might overflow standard Python integers\n        # before the division. For the given constraints, this is not an issue.\n        # This is a safeguard for general application.\n        return -1 \n\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(f(hare))\n\n    # Phase 2: Find the start of the cycle.\n    # The number of steps 'mu' is the length of the transient part.\n    mu = 0\n    tortoise = k0\n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n\n    # Phase 3: Find the length of the cycle (the eventual period, lambda).\n    # Start from the first element of the cycle and count steps until return.\n    lam = 1\n    hare = f(tortoise)\n    while tortoise != hare:\n        hare = f(hare)\n        lam += 1\n\n    return lam\n\ndef compute_average_period(B: int, S_B: int) -> float:\n    \"\"\"\n    Computes the average eventual period over a range of initial conditions.\n\n    Args:\n        B: The precision parameter.\n        S_B: The number of initial conditions to test (k from 1 to S_B).\n\n    Returns:\n        The average period.\n    \"\"\"\n    periods = []\n    for k in range(1, S_B + 1):\n        period = find_eventual_period(B, k)\n        periods.append(period)\n    \n    return np.mean(periods)\n\ndef solve():\n    \"\"\"\n    Solves the given problem by computing results for all five cases\n    and printing them in the specified format.\n    \"\"\"\n    # Case A: B = 8, S_B = 200\n    avg_A = compute_average_period(B=8, S_B=200)\n\n    # Case B: B = 12, S_B = 200\n    avg_B = compute_average_period(B=12, S_B=200)\n\n    # Case C: B = 16, S_B = 200\n    avg_C = compute_average_period(B=16, S_B=200)\n\n    # Case D: B = 8, x_0 = 0 (k=0)\n    period_D = find_eventual_period(B=8, k0=0)\n\n    # Case E: B = 8, x_0 = 1/2 (k = N/2)\n    N_E = 2**8\n    k0_E = N_E // 2\n    period_E = find_eventual_period(B=8, k0=k0_E)\n\n    # Construct the final output string as per requirements.\n    results = [\n        f\"{avg_A:.3f}\",\n        f\"{avg_B:.3f}\",\n        f\"{avg_C:.3f}\",\n        str(period_D),\n        str(period_E)\n    ]\n    \n    # Print the single-line output.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2409551"}]}