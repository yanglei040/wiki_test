{"hands_on_practices": [{"introduction": "现实世界中的振子很少是完美线性的。杜芬振子（Duffing oscillator）是研究非线性系统的一个典型范例，它在经典的线性恢复力基础上增加了一个三次项。与线性振子不同，非线性系统中的共振频率和相移等特性可能依赖于振动的振幅。这个练习 [@problem_id:2419785] 将挑战你量化这一效应，通过计算不同驱动力下系统的稳态相移，亲身体验非线性动力学的独特之处。", "problem": "考虑由常微分方程（ODE）控制的受迫、阻尼、非线性振子\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t),\n$$\n其中质量为 $m$，阻尼系数为 $c$，线性刚度为 $k$，三次刚度为 $\\alpha$，驱动力振幅为 $F_{0}$，驱动角频率为 $\\omega$。采用国际单位制（SI）中的以下固定参数值：$m = 1.0\\,\\mathrm{kg}$，$c = 0.3\\,\\mathrm{kg/s}$，$k = 1.0\\,\\mathrm{N/m}$，$\\alpha = 1.0\\,\\mathrm{N/m^{3}}$ 以及 $\\omega = 1.2\\,\\mathrm{rad/s}$。初始条件为 $x(0) = 0.0\\,\\mathrm{m}$ 和 $\\dot{x}(0) = 0.0\\,\\mathrm{m/s}$，时间 $t$ 的单位为 $\\mathrm{s}$。驱动器与振子之间的相位滞后 $\\delta$ 定义如下。在稳态下，位移 $x(t)$ 在长度为 $T_{\\mathrm{w}}$ 的有限平均窗口内，其基频（角频率为 $\\omega$）的同相和正交投影由以下公式定义：\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt, \\qquad\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt,\n$$\n并设\n$$\n\\delta = \\operatorname{atan2}(B, A),\n$$\n如果计算值为负，则通过加上 $2\\pi$ 将其映射到区间 $[0, 2\\pi)$ 内。平均必须在瞬态衰减后进行，使用 $t_{0} = 200.0\\,\\mathrm{s}$ 和窗口 $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\,\\frac{2\\pi}{\\omega}$，其中 $N_{\\mathrm{avg}} = 20$。角度必须以弧度表示。您的任务是计算以下每个驱动力振幅 $F_{0}$（单位为 $\\mathrm{N}$）对应的相位滞后 $\\delta$：$F_{0} \\in \\{\\,0.05,\\,0.20,\\,0.50,\\,0.80\\,\\}$。使用上面给出的 $(m,c,k,\\alpha,\\omega)$ 的固定值和初始条件，并在从 $t_{0}$ 开始的指定平均窗口上计算定义 $A$ 和 $B$ 的积分。\n\n测试套件与答案规范：\n- 使用上面给出的四个驱动力振幅 $F_{0}$ 作为测试套件。\n- 对每种情况，生成一个对应于相位滞后 $\\delta$ 的实数（以弧度为单位），并按规定映射到 $[0, 2\\pi)$ 区间。\n- 最终程序输出必须为一行，包含与测试用例相对应的四个 $\\delta$ 值，顺序与所列顺序相同，并四舍五入到恰好 $6$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[0.123456,1.234567,2.345678,3.456789]$。", "solution": "问题陈述已经过验证，并被认定为有效。它描述了一个关于受迫、阻尼 Duffing 振子的适定初值问题，这是非线性动力学研究中的一个典型系统。所有参数、初始条件和分析步骤都以科学和数学的严谨性进行了定义。不存在矛盾、歧义或事实不准确之处。\n\n任务是计算非线性振子的响应 $x(t)$ 与驱动力之间的稳态相位滞后 $\\delta$。控制方程是二阶常微分方程（ODE）：\n$$\nm\\,\\ddot{x}(t) + c\\,\\dot{x}(t) + k\\,x(t) + \\alpha\\,x^{3}(t) = F_{0}\\cos(\\omega t)\n$$\n求解需要采用数值方法，其过程如下。\n\n首先，我们将二阶常微分方程转换为一个包含两个一阶常微分方程的方程组。我们定义一个状态向量 $\\mathbf{y}(t) = [y_1(t), y_2(t)]^T$，其中 $y_1(t) = x(t)$ 代表位置，$y_2(t) = \\dot{x}(t)$ 代表速度。该状态向量的时间演化由以下方程组给出：\n$$\n\\dot{\\mathbf{y}}(t) = \n\\begin{pmatrix} \\dot{y}_1(t) \\\\ \\dot{y}_2(t) \\end{pmatrix} =\n\\begin{pmatrix} y_2(t) \\\\ \\frac{1}{m} \\left( F_{0}\\cos(\\omega t) - c\\,y_2(t) - k\\,y_1(t) - \\alpha\\,y_1^3(t) \\right) \\end{pmatrix}\n$$\n该方程组需使用初始条件 $x(0) = y_1(0) = 0.0\\,\\mathrm{m}$ 和 $\\dot{x}(0) = y_2(0) = 0.0\\,\\mathrm{m/s}$ 进行求解。给定参数为 $m = 1.0\\,\\mathrm{kg}$，$c = 0.3\\,\\mathrm{kg/s}$，$k = 1.0\\,\\mathrm{N/m}$，$\\alpha = 1.0\\,\\mathrm{N/m^{3}}$ 以及 $\\omega = 1.2\\,\\mathrm{rad/s}$。该问题需要针对驱动力振幅 $F_{0}$ 的四个不同值 $F_{0} \\in \\{0.05, 0.20, 0.50, 0.80\\}\\,\\mathrm{N}$ 进行求解。\n\n这个初值问题（IVP）使用适当的算法进行数值求解。`scipy.integrate.solve_ivp` 函数实现了一种高阶自适应步长 Runge-Kutta 方法（例如 `RK45`），是完成此任务的合适选择。积分必须在足够长的时间区间内进行，以使瞬态响应衰减并覆盖指定的平均窗口。积分区间为从 $t=0$ 到 $t_{f} = t_{0} + T_{w}$。平均的起始时间为 $t_{0} = 200.0\\,\\mathrm{s}$，窗口持续时间为 $T_{\\mathrm{w}} = N_{\\mathrm{avg}} \\frac{2\\pi}{\\omega}$，其中 $N_{\\mathrm{avg}} = 20$。这得出 $t_{f} = 200.0 + 20 \\frac{2\\pi}{1.2} \\approx 304.7198\\,\\mathrm{s}$。为了方便后续的积分计算，常微分方程求解器被配置为产生密集输出，它为解 $x(t)$ 提供了一个连续的插值函数。\n\n一旦获得了 $x(t)$ 的数值解，就可以计算同相和正交投影 $A$ 和 $B$。它们被定义为稳态响应的傅里叶基波系数：\n$$\nA = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\cos(\\omega t)\\,dt\n$$\n$$\nB = \\frac{2}{T_{\\mathrm{w}}}\\int_{t_{0}}^{t_{0} + T_{\\mathrm{w}}} x(t)\\sin(\\omega t)\\,dt\n$$\n这些定积分使用稳健的求积方法进行数值计算。`scipy.integrate.quad` 函数采用自适应求积方案，是一个绝佳的选择。它作用于被积函数，其中 $x(t)$ 由 `solve_ivp` 输出的插值函数提供。\n\n最后，使用双参数反正切函数根据系数 $A$ 和 $B$ 确定相位滞后 $\\delta$：\n$$\n\\delta = \\operatorname{atan2}(B, A)\n$$\n使用 `atan2` 可以将角度正确地置于适当的象限，得到一个在 $(-\\pi, \\pi]$ 范围内的结果。根据问题规范，然后通过对任何负结果加上 $2\\pi$ 将该值映射到区间 $[0, 2\\pi)$ 内。\n\n对每个指定的 $F_{0}$ 值，重复整个过程——常微分方程的数值求解、 $A$ 和 $B$ 积分的数值计算以及 $\\delta$ 的计算。最终的数值结果四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp, quad\n\ndef solve():\n    \"\"\"\n    Solves the damped, driven Duffing oscillator equation for several forcing\n    amplitudes and computes the steady-state phase lag for each case.\n    \"\"\"\n\n    # --- Define problem parameters in SI units ---\n    m = 1.0        # mass (kg)\n    c = 0.3        # damping coefficient (kg/s)\n    k = 1.0        # linear stiffness (N/m)\n    alpha = 1.0    # cubic stiffness (N/m^3)\n    omega = 1.2    # driving angular frequency (rad/s)\n\n    # --- Define simulation and analysis parameters ---\n    x0 = 0.0       # initial position (m)\n    v0 = 0.0       # initial velocity (m/s)\n    y0 = [x0, v0]  # initial state vector [x, v]\n\n    t0 = 200.0     # start time for averaging (s)\n    N_avg = 20     # number of cycles for averaging\n    T_w = N_avg * (2 * np.pi / omega)  # averaging window duration (s)\n    t_final = t0 + T_w               # end time for simulation\n\n    # --- Test cases for forcing amplitude ---\n    test_cases_F0 = [0.05, 0.20, 0.50, 0.80]  # (N)\n\n    results = []\n\n    def duffing_ode_system(t, y, F0):\n        \"\"\"\n        Defines the system of first-order ODEs for the Duffing oscillator.\n        y[0] = x (position), y[1] = v (velocity).\n        \"\"\"\n        x, v = y\n        # Equation: m*x_ddot + c*v + k*x + alpha*x^3 = F0*cos(omega*t)\n        # Transformed to: x_ddot = (F0*cos(omega*t) - c*v - k*x - alpha*x^3) / m\n        dv_dt = (F0 * np.cos(omega * t) - c * v - k * x - alpha * x**3) / m\n        return [v, dv_dt]\n\n    for F0 in test_cases_F0:\n        # Numerically solve the ODE system.\n        # dense_output=True creates an interpolant for the solution,\n        # which is needed for accurate quadrature.\n        # Stricter tolerances are used for higher accuracy of the final result.\n        solution = solve_ivp(\n            fun=lambda t, y: duffing_ode_system(t, y, F0),\n            t_span=(0, t_final),\n            y0=y0,\n            dense_output=True,\n            method='RK45',\n            rtol=1e-8,\n            atol=1e-10\n        )\n\n        # The solution object `sol.sol` is a callable interpolating function.\n        x_t = lambda t: solution.sol(t)[0]\n\n        # Define the integrands for the Fourier projections A and B.\n        integrand_A = lambda t: x_t(t) * np.cos(omega * t)\n        integrand_B = lambda t: x_t(t) * np.sin(omega * t)\n\n        # Compute the integrals using `scipy.integrate.quad`.\n        # `quad` returns (integral_value, error_estimate), we only need the value.\n        A_integral, _ = quad(integrand_A, t0, t_final)\n        B_integral, _ = quad(integrand_B, t0, t_final)\n\n        # Calculate the A and B coefficients based on their definition.\n        A = (2 / T_w) * A_integral\n        B = (2 / T_w) * B_integral\n\n        # Calculate the phase lag delta using atan2(B, A).\n        delta = np.arctan2(B, A)\n\n        # Map delta from (-pi, pi] to the required interval [0, 2pi).\n        if delta  0:\n            delta += 2 * np.pi\n\n        results.append(delta)\n\n    # Format the final output string to exactly 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419785"}, {"introduction": "现在，我们将视野从稳态振荡扩展到系统的稳定性问题。考虑一个被势垒束缚在势阱中的粒子，一个足够强的外部驱动力就可能将其“摇晃”出来，导致其逃逸。这个练习 [@problem_id:2419806] 为这种现象提供了一个具体的物理模型，要求你判断粒子在给定条件下是否会逃逸。通过解决这个问题，你将掌握在数值积分中应用“事件探测”这一重要且实用的计算技巧。", "problem": "一个质量为 $m$ 的点状粒子在三次方一维势阱中沿 $x$ 轴运动，受到线性粘性阻尼和周期性外部驱动力的作用。其势能为 $U(x)=\\tfrac{1}{2}k x^{2}-\\tfrac{1}{3}\\mu x^{3}$，其中 $k0$ 且 $\\mu0$。根据牛顿第二定律和保守力 $-\\partial U/\\partial x$ 推导出的运动方程为\n$$\nm\\,\\ddot{x}(t)+\\gamma\\,\\dot{x}(t)+k\\,x(t)-\\mu\\,x(t)^{2}=F_{0}\\cos\\big(\\omega t+\\phi\\big),\n$$\n其中 $\\gamma\\ge 0$ 是线性阻尼系数，$F_{0}\\ge 0$ 是驱动振幅，$\\omega0$ 是驱动角频率，$\\phi$ 是一个恒定相位。角度必须以弧度表示。\n\n该三次方势在 $x=0$ 处有一个局部最小值，在位置 $x_{b}=\\dfrac{k}{\\mu}$ 处有一个势垒（局部最大值）。定义“逃逸”为：在闭区间 $[0,T_{\\mathrm{end}}]$ 内存在一个时间 $t$，使得 $x(t)\\ge x_{b}$。\n\n您的任务是为上述常微分方程（ODE）所描述的运动建模，并对下面测试套件中的每一组参数，判断粒子是否在指定的时间范围内逃逸。使用国际单位制（SI）：$m$ 的单位是千克，$\\gamma$ 的单位是千克/秒， $k$ 的单位是牛顿/米，$\\mu$ 的单位是牛顿/平方米，$F_{0}$ 的单位是牛顿，$\\omega$ 的单位是弧度/秒，$x$ 的单位是米，$t$ 的单位是秒，$\\phi$ 的单位是弧度。初始条件为 $x(0)=x_{0}$ 和 $\\dot{x}(0)=v_{0}$。以布尔值形式报告结果，其中 $\\mathrm{True}$ 表示逃逸（对于某个 $t\\in[0,T_{\\mathrm{end}}]$ 有 $x(t)\\ge x_{b}$），$\\mathrm{False}$ 表示在 $[0,T_{\\mathrm{end}}]$ 上未逃逸。\n\n测试套件（每行列出 $(m,\\gamma,k,\\mu,F_{0},\\omega,\\phi,x_{0},v_{0},T_{\\mathrm{end}})$）：\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.30,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;20.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.05,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;50.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.5,\\;k=\\;2.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;1.10,\\;\\omega=\\;1.2,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;10.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;1.5,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.22,\\;\\omega=\\;1.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;60.0\\;)$\n- $(\\;m=\\;1.0,\\;\\gamma=\\;0.1,\\;k=\\;1.0,\\;\\mu=\\;1.0,\\;F_{0}=\\;0.26,\\;\\omega=\\;3.0,\\;\\phi=\\;0.0,\\;x_{0}=\\;0.0,\\;v_{0}=\\;0.0,\\;T_{\\mathrm{end}}=\\;5.0\\;)$\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如，按照上述测试套件的顺序，$[\\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{False},\\mathrm{True}]$。", "solution": "所提出的问题是计算物理学中的一个标准练习，具体来说是非线性、受阻尼、受驱动振子的数值分析。该问题在科学上是合理的，且提法是适定的。我们必须确定一个运动由给定的二阶常微分方程（ODE）控制的粒子，是否在指定时间内从势阱中逃逸。\n\n运动方程为：\n$$\nm\\,\\ddot{x}(t)+\\gamma\\,\\dot{x}(t)+k\\,x(t)-\\mu\\,x(t)^{2}=F_{0}\\cos\\big(\\omega t+\\phi\\big)\n$$\n这是一个初值问题，因为系统的初始状态由位置 $x(0) = x_{0}$ 和速度 $\\dot{x}(0) = v_{0}$ 给出。这个非线性方程的解析解是不可行的，因此需要采用数值方法。\n\n数值求解 $n$ 阶常微分方程的标准步骤是将其转换为一个包含 $n$ 个一阶常微分方程的方程组。对于我们的二阶方程，我们引入一个具有两个分量的状态向量 $\\mathbf{y}(t)$：$y_{1}(t) = x(t)$（位置）和 $y_{2}(t) = \\dot{x}(t)$（速度）。在任何时间 $t$ 系统的状态都由这个向量 $\\mathbf{y}(t) = [y_{1}(t), y_{2}(t)]^{T}$ 完全描述。\n\n一阶方程组推导如下：\n第一个分量的时间导数就是速度的定义：\n$$\n\\dot{y}_{1}(t) = \\frac{dx}{dt} = \\dot{x}(t) = y_{2}(t)\n$$\n第二个分量的时间导数是加速度 $\\ddot{x}(t)$，我们可以通过重新整理原始运动方程得到：\n$$\n\\ddot{x}(t) = \\frac{1}{m} \\left( F_{0}\\cos(\\omega t + \\phi) - \\gamma\\,\\dot{x}(t) - k\\,x(t) + \\mu\\,x(t)^{2} \\right)\n$$\n代入 $y_{1}$ 和 $y_{2}$，我们得到：\n$$\n\\dot{y}_{2}(t) = \\frac{1}{m} \\left( F_{0}\\cos(\\omega t + \\phi) - \\gamma\\,y_{2}(t) - k\\,y_{1}(t) + \\mu\\,y_{1}(t)^{2} \\right)\n$$\n这给了我们方程组 $\\dot{\\mathbf{y}}(t) = \\mathbf{f}(t, \\mathbf{y})$，可以使用标准的数值积分器求解。该方程组的初始条件是 $\\mathbf{y}(0) = [x_{0}, v_{0}]^{T}$。\n\n问题要求我们确定粒子是否“逃逸”。逃逸的定义是对于某个时间 $t \\in [0, T_{\\mathrm{end}}]$ 存在 $x(t) \\ge x_{b}$，其中逃逸边界为 $x_{b} = k/\\mu$。与其在整个时长 $T_{\\mathrm{end}}$ 内积分系统然后检查整个轨迹，一种计算效率更高的方法是使用事件检测，这是现代ODE求解器（如 `scipy.integrate.solve_ivp`）中可用的一个功能。\n\n定义一个事件函数，我们称之为 $g(t, \\mathbf{y})$，当 $g(t, \\mathbf{y}) = 0$ 时，我们关心的事件发生。对于我们的逃逸条件，我们将事件函数定义为：\n$$\ng(t, \\mathbf{y}) = y_{1}(t) - x_{b}\n$$\n我们关心的是粒子位置 $y_{1}(t)$ 从下方穿过边界 $x_{b}$ 的点。这对应于事件函数 $g(t, \\mathbf{y})$ 以正斜率穿过零点。我们指示求解器将此事件视为“终止”事件，意味着一旦满足条件，积分将停止。\n\n因此，对每个测试用例的算法如下：\n$1$. 对于给定的一组参数 $(m, \\gamma, k, \\mu, F_{0}, \\omega, \\phi, x_{0}, v_{0}, T_{\\mathrm{end}})$，计算逃逸边界 $x_{b} = k/\\mu$。\n$2$. 为一阶常微分方程组定义向量函数 $\\mathbf{f}(t, \\mathbf{y})$。\n$3$. 定义终止事件函数 $g(t, \\mathbf{y}) = y_{1}(t) - x_{b}$。\n$4$. 使用数值求解器，特别是 `scipy.integrate.solve_ivp`，从 $t=0$ 到 $t=T_{\\mathrm{end}}$ 对系统进行积分，初始条件为 $\\mathbf{y}(0)=[x_{0}, v_{0}]^{T}$，同时监测终止事件。\n$5$. 如果求解器因为事件被触发而返回，这意味着在某个 $t \\le T_{\\mathrm{end}}$ 时 $x(t)$ 达到了 $x_{b}$。结果为 $\\mathrm{True}$。\n$6$. 如果求解器在积分到 $T_{\\mathrm{end}}$ 之前事件未被触发，则粒子在给定的时间范围内没有逃逸。结果为 $\\mathrm{False}$。\n\n这个过程为解决该问题提供了一种严谨而高效的方法。所提供的Python代码实现了这一确切逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Solves the damped driven oscillator problem for a suite of test cases.\n    \"\"\"\n    \n    # Test suite (m, gamma, k, mu, F0, omega, phi, x0, v0, T_end)\n    test_cases = [\n        (1.0, 0.1, 1.0, 1.0, 0.30, 1.0, 0.0, 0.0, 0.0, 20.0),\n        (1.0, 0.1, 1.0, 1.0, 0.05, 1.0, 0.0, 0.0, 0.0, 50.0),\n        (1.0, 0.5, 2.0, 1.0, 1.10, 1.2, 0.0, 0.0, 0.0, 10.0),\n        (1.0, 1.5, 1.0, 1.0, 0.22, 1.0, 0.0, 0.0, 0.0, 60.0),\n        (1.0, 0.1, 1.0, 1.0, 0.26, 3.0, 0.0, 0.0, 0.0, 5.0),\n    ]\n\n    results = []\n\n    for params in test_cases:\n        m, gamma, k, mu, F0, omega, phi, x0, v0, T_end = params\n\n        # Escape boundary position\n        x_b = k / mu\n\n        def ode_system(t, y):\n            \"\"\"\n            Defines the system of first-order ODEs.\n            y[0] = x (position)\n            y[1] = v (velocity)\n            \"\"\"\n            x, v = y\n            \n            # Driving force\n            F_drive = F0 * np.cos(omega * t + phi)\n            \n            # Acceleration (d^2x/dt^2), from rearranging the equation of motion\n            # m*x_ddot + gamma*x_dot + k*x - mu*x^2 = F_drive\n            # x_ddot = (1/m) * (F_drive - gamma*x_dot - k*x + mu*x^2)\n            acceleration = (F_drive - gamma * v - k * x + mu * x**2) / m\n            \n            return [v, acceleration]\n\n        def escape_event(t, y):\n            \"\"\"\n            Event function to detect when the particle reaches the escape boundary.\n            Event occurs when this function is zero.\n            \"\"\"\n            return y[0] - x_b\n        \n        # The event is terminal: integration stops when the particle escapes.\n        escape_event.terminal = True\n        # We only care about crossing from below (increasing position).\n        escape_event.direction = 1\n\n        # Initial conditions for the state vector [x, v]\n        y0 = [x0, v0]\n        \n        # Time span for the integration\n        t_span = [0, T_end]\n\n        # Solve the initial value problem\n        # We use solve_ivp, a modern, robust ODE solver in SciPy.\n        sol = solve_ivp(\n            fun=ode_system,\n            t_span=t_span,\n            y0=y0,\n            method='RK45',  # Standard Runge-Kutta adaptive method\n            events=escape_event,\n            dense_output=True # Necessary for precise event location\n        )\n\n        # Check if the escape event was triggered.\n        # sol.t_events is a list of arrays, one for each event function.\n        # If the array for our event is non-empty, the event occurred.\n        if sol.t_events[0].size > 0:\n            results.append(True)  # Particle escaped\n        else:\n            results.append(False) # Particle did not escape within T_end\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2419806"}, {"introduction": "接下来，我们来探索阻尼驱动振子最复杂也最迷人的方面：混沌。我们将通过一个看似简单却极为深刻的模型——滴水的水龙头——来揭示这一现象。当改变某个控制参数（如此处的水流速率 $q$）时，系统会从简单的周期性行为通过一系列倍周期分岔（period-doubling bifurcations）转变为复杂的非周期性行为。这个练习 [@problem_id:2419756] 让你有机会亲手模拟这条通往混沌的经典路径，并学习如何量化系统的周期性。", "problem": "你的任务是构建一个完整、可运行的程序，通过阻尼驱动振子的视角对滴水的水龙头进行数值模拟。该模型是根据牛顿第二定律构建的，并基于以下简化且被广泛使用的假设：当一滴水仍附着在水龙头上时，它的行为如同一个连接到线性弹簧和阻尼器的点质量，受到恒定的引力作用。水龙头以恒定的流率增加质量，当伸长量超过一个与质量相关的破裂阈值时，水滴便会脱离。之后，一小部分残留物会作为下一滴水的种子。这个设定是一个标准的计算物理练习，它会导出一个带有状态重置的非自治常微分方程（ordinary differential equation (ODE)）。目标是模拟当流率变化时的动力学过程，并提取暂态结束后的不同滴水间隔时间的数量，从而揭示一个倍周期序列。\n\n从牛顿第二定律以及线性阻尼和线性弹性的定义出发。当水滴附着时，假设如下：\n- 水滴相对于水龙头的位置是一个向下测量的标量位移 $x(t)$，其速度为 $v(t) = \\frac{dx}{dt}$。\n- 瞬时质量 $m(t)$ 以恒定的流入速率 $q$ 增加，即 $\\frac{dm}{dt} = q$。\n- 作用在水滴上的力来自重力、线性弹簧和线性阻尼器，其系数分别为 $g$、$\\kappa$ 和 $\\gamma$。\n- 假设新加入的质量附着时其相对动量效应可以忽略不计，这给出了一个常用的近似，即等式左侧使用 $m(t)\\,x''(t)$ 而不包含额外的喷射动量项。\n\n在这些假设下，水滴附着时的控制方程为：\n$$\n\\frac{dx}{dt} = v, \\quad \n\\frac{dv}{dt} = \\frac{m(t)\\,g - \\gamma\\,v - \\kappa\\,x}{m(t)}, \\quad\n\\frac{dm}{dt} = q.\n$$\n当伸长量 $x(t)$ 从下方达到阈值 $x_{\\mathrm{break}}(m)$ 时，发生破裂（脱离），其中\n$$\nx_{\\mathrm{break}}(m) = x_0 - \\beta\\,m,\n$$\n$x_0$ 和 $\\beta$ 是正常数。在脱离时刻 $t_d$，状态被重置，以模拟附着在水龙头颈部的残余质量，并为下一滴水设定一个松弛、静止的初始条件：\n$$\nx(t_d^+) = 0, \\quad v(t_d^+) = 0, \\quad m(t_d^+) = \\alpha\\,m(t_d^-),\n$$\n其中 $0  \\alpha  1$ 是残余质量分数，上标 $^-$ 和 $^+$ 分别表示事件发生前后的极限。\n\n你的任务是：\n1) 根据牛顿第二定律，在所述假设下，证明上述ODE系统和重置规则的合理性。阐明变质量如何进入加速度方程，以及为何所选的简化在这种情况下是合适的。\n2) 设计并实现一个稳健的事件驱动的数值积分器，以：\n   - 积分ODE，直到检测到 $x$ 递增并触发破裂事件 $x(t) - x_{\\mathrm{break}}(m(t)) = 0$。\n   - 应用重置规则并继续模拟，以生成一个长的滴水时间序列。\n3) 对于每个指定的流率 $q$，计算滴水间隔时间 $\\Delta t_n = t_{n} - t_{n-1}$。舍去初始的暂态，然后确定在一定容差内存在的不同滴水间隔时间的数量，这是一个用于诊断周期-k行为（例如，周期-1为$k=1$，倍周期后的周期-2为$k=2$，等等）的整数。使用结合了绝对和相对分量的容差，以避免因数值噪声导致的错误区分。\n4) 使用以下无量纲参数用于振荡器和破裂模型，并指定流率的测试套件：\n   - 振荡器参数：$\\kappa = 1.0$，$\\gamma = 0.05$，$g = 0.34$。\n   - 破裂参数：$x_0 = 0.50$，$\\beta = 0.10$，$\\alpha = 0.30$。\n   - 最开始的初始条件：$x(0) = 0$， $v(0) = 0$， $m(0) = 0.40$。\n   - 流率测试套件（四种情况）：$q \\in \\{\\,0.010,\\,0.025,\\,0.050,\\,0.080\\,\\}$。\n   - 积分足够长的时间，以观察每种情况下至少 $N_{\\mathrm{total}} = 60$ 次滴水，舍弃前 $N_{\\mathrm{trans}} = 30$ 次作为暂态，并分析接下来的 $N_{\\mathrm{keep}} = 30$ 次滴水。\n   - 使用一个检测容差，将滴水间隔时间 $\\Delta t$ 聚类为不同的组，规则为“如果 $|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$，则属于同一组”，其中 $\\varepsilon_{\\mathrm{abs}}=10^{-3}$ 且 $\\varepsilon_{\\mathrm{rel}}=10^{-3}$。\n5) 你的程序必须产生单行输出，包含一个用方括号括起来的逗号分隔的整数列表（例如，“[1,2,4,1]”），其中每个整数是按上述顺序为相应流率计数的不同滴水间隔时间的数量。\n\n该问题必须以纯数学和算法的方式解决，以便可以在任何编程语言中实现。以上所有量都是无量纲的，因此不需要物理单位转换。确保参数具有科学真实性，并在你的解决方案中讨论该方法为何能捕捉到倍周期序列。每个测试用例的最终答案是整数，量化了暂态后发现的不同滴水间隔时间的数量。", "solution": "所提出的问题是计算物理学中一个有效的练习。它在科学上是合理的、适定的，并且所有必要的参数和条件都已指定。它将一个复杂的物理现象——滴水的水龙头——标准地简化为一个带有状态重置的非自治常微分方程系统，该模型已知会展现倍周期分岔和混沌。我们将进行严谨的推导和算法设计。\n\n首先，我们必须从基本原理出发来证明控制方程的合理性。所描述的系统是一个其质量$m(t)$随时间变化的质点。对于变质量物体，牛顿第二定律最普遍的表述是动量$\\vec{p}$的变化率等于净外力$\\vec{F}_{\\mathrm{ext}}$，即$\\vec{F}_{\\mathrm{ext}} = \\frac{d\\vec{p}}{dt}$。在我们的以为系统中，动量是$p(t) = m(t)v(t)$，其中$v(t) = \\frac{dx}{dt}$是速度。应用微分的乘法法则，我们得到：\n$$\n\\frac{dp}{dt} = \\frac{d(mv)}{dt} = m(t)\\frac{dv}{dt} + v(t)\\frac{dm}{dt} = m(t)a(t) + v(t)q\n$$\n其中$a(t) = \\frac{dv}{dt}$是加速度，而$\\frac{dm}{dt} = q$是恒定的质量流入速率。项$v(t)q$表示将流入的流体（假设其初始垂直速度为零）加速到水滴当前速度$v(t)$所需的力。问题陈述指导我们使用一个常见的简化，即忽略这个“喷射动量”项。如果速度$v(t)$很小，或者主要动力学由其他力主导，这是一个合理的近似，通常情况下确实如此。在此简化下，牛顿第二定律简化为：\n$$\nm(t)a(t) \\approx F_{\\mathrm{ext}}\n$$\n作用在质量上的外力是重力（$F_g = m(t)g$）、线性弹簧的回复力（$F_s = -\\kappa x$）和线性粘性阻尼力（$F_d = -\\gamma v$）。弹簧常数为$\\kappa$，阻尼系数为$\\gamma$，$g$是重力加速度。位移$x$是从水龙头向下测量的，因此重力为正。这些力的总和是：\n$$\nF_{\\mathrm{ext}} = m(t)g - \\kappa x - \\gamma v\n$$\n将此与动量变化率的简化表达式相等，得到水滴的运动方程：\n$$\nm(t)\\frac{dv}{dt} = m(t)g - \\kappa x - \\gamma v\n$$\n两边除以瞬时质量$m(t)$，得到加速度：\n$$\n\\frac{dv}{dt} = g - \\frac{\\gamma}{m(t)}v - \\frac{\\kappa}{m(t)}x\n$$\n这正是所给出的方程。该方程与定义$\\frac{dx}{dt} = v$和$\\frac{dm}{dt} = q$一起，构成了一个包含三个耦合的一阶非自治常微分方程的系统。该系统是非自治的，因为加速度方程中$v$和$x$的系数通过质量$m(t) = m(0) + qt$显式地依赖于时间。\n\n模拟通过积分该系统直到发生破裂事件来进行。破裂的条件是伸长量$x(t)$达到一个依赖于质量的阈值$x_{\\mathrm{break}}(m) = x_0 - \\beta m$。物理直觉是，随着水滴变重，表面张力越来越难以支撑大的伸长。因此，事件函数为$G(t, x, m) = x(t) - x_{\\mathrm{break}}(m(t)) = 0$。我们感兴趣的是$x(t)$从下方穿过这个阈值的事件，所以我们必须检测一个递增方向上的过零点。\n\n在脱离时刻$t_d$，系统状态被重置。新的水滴以零位移和零速度开始，即$x(t_d^+) = 0$和$v(t_d^+) = 0$。这是一个简化，假设残余流体瞬间稳定到静止状态。关键的是，并非所有质量都脱离。在破裂时，水滴质量$m(t_d^-)$的一部分，即比例为$\\alpha$的部分，仍然附着在水龙头上：$m(t_d^+) = \\alpha m(t_d^-)$。这个残余质量$m(t_d^+)$作为下一滴水的初始条件，并在连续的滴水事件之间提供了一种“记忆”。正是这种记忆，加上重置机制的非线性特性以及质量流入的驱动力，使得系统能够展现出复杂的动力学。第$n$滴水形成时的质量$m_n(0)$，取决于第$(n-1)$滴水破裂时的质量$m_{n-1}(t_{\\text{rupture}})$。这在一次滴水到下一次滴水之间建立了一个映射，对于某些参数区域，例如流率$q$，这个映射会经历倍周期级联，这是通往混沌之路的标志。对于低流率$q$，系统会稳定在一个周期-1的极限环上，其中每一滴水都相同，滴水之间的时间间隔是恒定的。当$q$增加时，系统可能会分岔到一个周期-2的循环，其中滴水间隔时间（和水滴大小）在两个不同的值之间交替。进一步增加$q$可能导致周期-4、周期-8，并最终导致混沌行为，此时滴水间隔时间看起来是随机的。我们的任务是为给定的$q$值计算这些不同的滴水间隔时间的数量。\n\n算法如下：\n1.  为ODE系统定义一个函数：$\\frac{dY}{dt} = F(t, Y)$，其中$Y = [x, v, m]^T$。\n2.  为破裂条件$x - (x_0 - \\beta m) = 0$定义一个事件函数。该函数必须是终止的，并检测从负到正的穿越。\n3.  对于测试套件中的每个流率$q$：\n    a. 初始化状态向量$Y_0 = [0, 0, 0.40]^T$，当前时间$t_{\\mathrm{current}} = 0$，以及一个用于存储滴水时间的列表`drip_times`。\n    b. 循环$N_{\\mathrm{total}} = 60$次以收集60次滴水的数据。\n        i. 使用一个数值ODE求解器（例如`scipy.integrate.solve_ivp`）从$t_{\\mathrm{current}}$和当前状态开始积分系统，直到触发破裂事件。\n        ii. 记录事件时间$t_{\\mathrm{event}}$。将其添加到`drip_times`。\n        iii. 根据重置规则更新状态向量：$x_{\\mathrm{new}} = 0$, $v_{\\mathrm{new}} = 0$, $m_{\\mathrm{new}} = \\alpha \\cdot m_{\\mathrm{event}}$，其中$m_{\\mathrm{event}}$是破裂时的质量。新的当前时间是$t_{\\mathrm{current}} = t_{\\mathrm{event}}$。\n    c. 计算滴水间隔时间$\\Delta t_i = \\text{drip\\_times}[i] - \\text{drip\\_times}[i-1]$，对于$i=1, \\dots, N_{\\mathrm{total}}-1$。我们还需要第一个时间间隔$\\text{drip\\_times}[0] - 0$。这将产生$N_{\\mathrm{total}}$个时间间隔。\n    d. 舍弃前$N_{\\mathrm{trans}} = 30$个时间间隔作为暂态动力学。\n    e. 分析接下来的$N_{\\mathrm{keep}} = 30$个时间间隔。为了计算不同值的数量，对时间间隔进行排序，并遍历排序后的列表，根据指定的容差将彼此接近的值分组计数：$|\\Delta t_i - \\Delta t_j| \\le \\max(\\varepsilon_{\\mathrm{abs}}, \\varepsilon_{\\mathrm{rel}}\\cdot \\max(|\\Delta t_i|,|\\Delta t_j|))$。一个简单的方法是计算排序列表中一个元素与前一个元素显著不同的次数。\n    f. 将此计数记录为给定$q$的结果。\n4.  按规定格式化最终的计数列表。\n这种稳健的、事件驱动的方法正确地模拟了物理过程，并允许准确地确定系统的周期性行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Numerically models a dripping faucet to observe period-doubling.\n\n    The model treats a growing water drop as a damped, driven harmonic oscillator\n    with variable mass. The system is described by a non-autonomous ODE with\n    state resets upon drop detachment. This function simulates the dynamics for\n    a set of flow rates and determines the periodicity of the drip intervals.\n    \"\"\"\n\n    # Define physical and numerical parameters as per the problem statement.\n    # Oscillator parameters\n    kappa = 1.0  # Spring constant\n    gamma = 0.05 # Damping coefficient\n    g = 0.34     # Gravitational acceleration\n\n    # Rupture and reset parameters\n    x0 = 0.50    # Rupture threshold constant\n    beta = 0.10  # Rupture threshold mass dependency\n    alpha = 0.30 # Residual mass fraction\n\n    # Initial conditions for the very first drop\n    x_init = 0.0\n    v_init = 0.0\n    m_init = 0.40\n\n    # Simulation control\n    N_total = 60  # Total number of drips to simulate per case\n    N_trans = 30  # Number of transient drips to discard\n    \n    # Tolerance for clustering inter-drip times\n    eps_abs = 1e-3\n    eps_rel = 1e-3\n    \n    # Test suite of flow rates\n    test_cases = [0.010, 0.025, 0.050, 0.080]\n\n    results = []\n\n    # ODE system definition: dy/dt = f(t, y)\n    # y = [x, v, m]\n    def ode_system(t, y, q_val):\n        x, v, m = y\n        # Avoid division by zero if mass is ever zero, though m_init > 0.\n        if m = 0:\n            return [0.0, 0.0, q_val]\n        \n        dxdt = v\n        dvdt = g - (gamma * v / m) - (kappa * x / m)\n        dmdt = q_val\n        return [dxdt, dvdt, dmdt]\n\n    # Event function: fires when x(t) = x_break(m(t))\n    # x_break(m) = x0 - beta * m\n    def rupture_event(t, y, q_val):\n        x, v, m = y\n        return x - (x0 - beta * m)\n    \n    rupture_event.terminal = True  # Stop integration at the event\n    rupture_event.direction = 1    # Event triggers when x is increasing\n\n    # Main loop over each flow rate\n    for q_flow in test_cases:\n        \n        # Initialize state for this test case\n        current_time = 0.0\n        y_current = np.array([x_init, v_init, m_init])\n        \n        drip_times = []\n\n        # Simulate N_total drips\n        for _ in range(N_total):\n            # Define a sufficiently long time span for the next drip\n            t_span = (current_time, current_time + 100.0)\n            \n            # Integrate until the next rupture event\n            sol = solve_ivp(\n                fun=lambda t, y: ode_system(t, y, q_flow),\n                t_span=t_span,\n                y0=y_current,\n                events=lambda t, y: rupture_event(t, y, q_flow),\n                dense_output=True,\n                max_step=0.1\n            )\n            \n            # Check if an event was found\n            if sol.t_events[0].size > 0:\n                event_time = sol.t_events[0][0]\n                drip_times.append(event_time)\n                \n                # State at the moment of rupture\n                y_event = sol.sol(event_time)\n                m_rupture = y_event[2]\n                \n                # Apply reset rules\n                current_time = event_time\n                y_current = np.array([0.0, 0.0, alpha * m_rupture])\n            else:\n                # Should not happen with given parameters and t_span\n                # Break if no drip is found in the time window\n                break\n\n        # Analyze the collected drip times\n        if len(drip_times)  N_total:\n             # If simulation failed, append an error code (e.g., -1)\n             results.append(-1)\n             continue\n        \n        # Calculate inter-drip times\n        all_times = np.insert(np.array(drip_times), 0, 0.0)\n        inter_drip_times = np.diff(all_times)\n\n        # Discard transients and keep the part for analysis\n        analysis_times = inter_drip_times[N_trans:]\n\n        if len(analysis_times) == 0:\n            results.append(0)\n            continue\n        \n        # Cluster the inter-drip times to count distinct values\n        sorted_times = np.sort(analysis_times)\n        \n        num_distinct_times = 1\n        # The first time interval starts the first cluster\n        cluster_representative = sorted_times[0]\n        \n        for i in range(1, len(sorted_times)):\n            dt_current = sorted_times[i]\n            # Use the representative of the last cluster for comparison\n            # to handle multi-point clusters correctly.\n            tolerance = max(eps_abs, eps_rel * max(abs(dt_current), abs(cluster_representative)))\n            if abs(dt_current - cluster_representative) > tolerance:\n                num_distinct_times += 1\n                cluster_representative = dt_current # Start a new cluster\n        \n        results.append(num_distinct_times)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419756"}]}