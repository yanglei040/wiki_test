{"hands_on_practices": [{"introduction": "在研究限制性三体问题时，为了简化和普适性，通常会采用无量纲化的坐标系。然而，要将仿真结果应用于现实世界（例如地月系统），就必须掌握将这些抽象的无量纲数据转换回物理单位（如千米和秒）的技能。本练习 [@problem_id:2223530] 将指导你完成这一关键的转换过程，让你能够解释和验证数值仿真的物理意义。", "problem": "一名学生正在使用基于圆形限制性三体问题 (CR3BP) 的数值模拟来分析一个小型航天器在地月系统中的轨道。在此模型中，地球和月球被视为质点，围绕它们的共同质心作圆周轨道运动。该模拟使用一个无量纲的旋转坐标系，其中原点是质心，x轴始终从地球指向月球，z轴平行于地月系统的角速度矢量。\n\n模拟中使用的单位按如下方式进行归一化：\n- 长度单位是地球和月球之间的平均距离 $D$。\n- 地球和月球的质量之和 $M_E + M_M$ 是质量单位。\n- 时间单位的选择使得旋转坐标系的角速度 $\\Omega$ 在无量纲项中为1。\n\n在某一特定时刻，模拟报告航天器的无量纲位置矢量为 $\\vec{\\tilde{r}} = (1.160, 0.050, -0.020)$，其*相对于旋转坐标系*的无量纲速度矢量为 $\\vec{\\tilde{v}}_{rot} = (0.100, -0.250, 0.080)$。\n\n使用下面提供的物理常数，计算航天器在非旋转惯性坐标系中的速度大小（其速率），该坐标系的原点也位于地月质心。\n\n物理常数：\n- 引力常数, $G = 6.674 \\times 10^{-11} \\text{ m}^3 \\text{kg}^{-1} \\text{s}^{-2}$\n- 地球质量, $M_E = 5.972 \\times 10^{24} \\text{ kg}$\n- 月球质量, $M_M = 7.342 \\times 10^{22} \\text{ kg}$\n- 地月平均距离, $D = 3.844 \\times 10^{8} \\text{ m}$\n\n将您的答案以千米/秒 (km/s) 为单位表示，并四舍五入到三位有效数字。", "solution": "在旋转坐标系中，惯性速度是旋转坐标系速度与坐标系旋转贡献的总和：\n$$\\vec{v}_{\\text{inertial}} = \\vec{v}_{\\text{rot}} + \\vec{\\Omega} \\times \\vec{r}.$$\n在所述的无量纲CR3BP单位中，角速度矢量为 $\\tilde{\\vec{\\Omega}} = (0,0,1)$，且给定的矢量是无量纲的。因此，\n$$\\vec{\\tilde{v}}_{\\text{inertial}} = \\vec{\\tilde{v}}_{\\text{rot}} + \\tilde{\\vec{\\Omega}} \\times \\vec{\\tilde{r}}.$$\n已知 $\\vec{\\tilde{r}} = (1.160,\\,0.050,\\,-0.020)$ 和 $\\vec{\\tilde{v}}_{\\text{rot}} = (0.100,\\,-0.250,\\,0.080)$，并使用 $\\tilde{\\vec{\\Omega}} \\times \\vec{\\tilde{r}} = (-\\tilde{y},\\,\\tilde{x},\\,0)$，我们得到\n$$(\\tilde{\\vec{\\Omega}} \\times \\vec{\\tilde{r}}) = (-0.050,\\,1.160,\\,0),$$\n$$\\vec{\\tilde{v}}_{\\text{inertial}} = (0.100-0.050,\\,-0.250+1.160,\\,0.080+0) = (0.050,\\,0.910,\\,0.080).$$\n其无量纲大小为\n$$|\\vec{\\tilde{v}}_{\\text{inertial}}| = \\sqrt{0.050^{2} + 0.910^{2} + 0.080^{2}} = \\sqrt{0.0025 + 0.8281 + 0.0064} = \\sqrt{0.837} \\approx 0.914877.$$\n\n为了转换为物理单位，请注意，所选择的无量纲化设置了时间尺度，使得无量纲角速度为1。物理平均角速度为\n$$\\Omega = \\sqrt{\\frac{G(M_{E}+M_{M})}{D^{3}}},$$\n因此时间单位是 $T = \\Omega^{-1}$，速度单位是\n$$U = \\frac{D}{T} = D\\,\\Omega = \\sqrt{\\frac{G(M_{E}+M_{M})}{D}}.$$\n因此物理速率是\n$$v_{\\text{phys}} = U\\,|\\vec{\\tilde{v}}_{\\text{inertial}}| = \\sqrt{\\frac{G(M_{E}+M_{M})}{D}}\\;|\\vec{\\tilde{v}}_{\\text{inertial}}|.$$\n代入给定的常数，\n$$G(M_{E}+M_{M}) = (6.674 \\times 10^{-11})\\,(5.972 \\times 10^{24} + 7.342 \\times 10^{22}) \\text{ m}^{3}\\text{s}^{-2} \\approx 4.034713308 \\times 10^{14},$$\n$$\\frac{G(M_{E}+M_{M})}{D} \\approx \\frac{4.034713308 \\times 10^{14}}{3.844 \\times 10^{8}} \\approx 1.04961324 \\times 10^{6} \\text{ m}^{2}\\text{s}^{-2},$$\n$$U = \\sqrt{1.04961324 \\times 10^{6}} \\text{ m/s} \\approx 1.02450634 \\times 10^{3} \\text{ m/s}.$$\n因此\n$$v_{\\text{phys}} \\approx (1.02450634 \\times 10^{3} \\text{ m/s}) \\times 0.914877 \\approx 9.372972868 \\times 10^{2} \\text{ m/s} = 0.9372972868 \\text{ km/s}.$$\n四舍五入到三位有效数字得到 $0.937$ km/s。", "answer": "$$\\boxed{0.937}$$", "id": "2223530"}, {"introduction": "对于天体力学中的长期轨道仿真，数值积分方法的选择至关重要，因为它直接影响仿真的稳定性和物理真实性。本练习 [@problem_id:2444608] 要求你实现并比较两种不同类型的积分器：一种是为哈密顿系统设计的辛积分器，另一种是标准的高精度龙格-库塔（RK4）方法。通过这个实践，你将亲眼见证辛积分器在长期能量守恒方面的卓越表现，并理解为何它在天体动力学仿真中备受青睐。", "problem": "实现一个程序，用于在均匀旋转参考系中比较一个辛积分器和一个非辛积分器在处理平面圆形限制性三体问题（CRTBP）时的长期行为，重点关注地球-太阳系统中从三角拉格朗日平衡点 $L_4$ 和 $L_5$ 附近初始化的轨道。在推导和算法设计中仅使用第一性原理。\n\n从以下基本基础开始：\n- 哈密顿力学及其哈密顿方程 $\\dot{q}_i=\\partial H/\\partial p_i$ 和 $\\dot{p}_i=-\\partial H/\\partial q_i$。\n- 在旋转参考系中的平面 CRTBP，使用无量纲单位，使得主天体之间的距离为 $1$，旋转角速度为 $1$（因此主天体在此参考系中是固定的），总质量为 $1$。设太阳质量为 $1-\\mu$，地球质量为 $\\mu$，对于地球-太阳系统，$\\mu=3.003489614915\\times 10^{-6}$。\n- 使用正则坐标 $(x,y,p_x,p_y)$ 和不依赖时间的哈密顿量\n$$\nH(x,y,p_x,p_y)=\\tfrac{1}{2}\\left(p_x^2+p_y^2\\right)+y\\,p_x-x\\,p_y-\\left(\\frac{1-\\mu}{r_1}+\\frac{\\mu}{r_2}\\right),\n$$\n其中 $r_1=\\sqrt{(x+\\mu)^2+y^2}$ 且 $r_2=\\sqrt{(x-1+\\mu)^2+y^2}$。该哈密顿量通过哈密顿方程可以导出标准的旋转参考系 CRTBP 方程。守恒的雅可比积分为 $C=-2H$。\n- 三角拉格朗日点位于\n$$\nL_4:\\ \\left(x_{L_4},y_{L_4}\\right)=\\left(\\tfrac{1}{2}-\\mu,\\tfrac{\\sqrt{3}}{2}\\right),\\quad\nL_5:\\ \\left(x_{L_5},y_{L_5}\\right)=\\left(\\tfrac{1}{2}-\\mu,-\\tfrac{\\sqrt{3}}{2}\\right).\n$$\n在旋转参考系中，$L_4$ 和 $L_5$ 处的平衡速度为零。与零物理速度一致的正则动量为 $p_x(0)=-y_0$ 和 $p_y(0)=x_0$，其中 $(x_0,y_0)$ 是初始位置。\n\n任务：\n1. 根据哈密顿方程和给定的哈密顿量，推导出关于 $(x,y,p_x,p_y)$ 的一阶常微分方程组，并实现两种时间步进方法：\n   - 一种辛方法：使用直接从哈密顿结构导出的一阶辛欧拉方法（你必须通过以保持辛形式的方式应用哈密顿方程来设计更新步骤）。\n   - 一种非辛方法：使用应用于同一一阶系统的经典四阶显式龙格-库塔方法。\n\n2. 使用这两种积分器，模拟在 $L_4$ 和 $L_5$ 附近初始化的长期轨道，并量化两个反映稳定性和长期精度的诊断指标：\n   - 轨道上哈密顿量的最大绝对偏差，\n     $$\n     \\max_{0\\le n\\le N}\\left|H_n-H_0\\right|,\n     $$\n     其中 $H_n$ 是在第 $n$ 步计算的哈密顿量。\n   - 与相应平衡点的最大绝对位移，\n     $$\n     \\max_{0\\le n\\le N}\\sqrt{(x_n-x_{\\mathrm{eq}})^2+(y_n-y_{\\mathrm{eq}})^2}。\n     $$\n\n使用以下测试套件（每种情况都必须用两种积分器进行模拟）：\n- 所有情况的通用参数：\n  - 质量参数 $\\mu=3.003489614915\\times 10^{-6}$。\n  - 主天体公转圈数 $N_p=30$。名义积分时间为 $T=2\\pi N_p$。使用恒定步长 $h$，并在每次模拟中执行 $N=\\left\\lfloor T/h\\right\\rfloor$ 步。\n  - 旋转参考系中的初始速度为零。使用 $p_x(0)=-y_0$，$p_y(0)=x_0$ 转换为正则动量。\n- 情况 A（$L_4$ 附近的正常情况）：平衡点 $L_4$，初始位置 $(x_0,y_0)=(x_{L_4}+\\varepsilon,y_{L_4})$，其中 $\\varepsilon=10^{-6}$，步长 $h=0.01$。\n- 情况 B（$L_5$ 附近的正常情况）：平衡点 $L_5$，初始位置 $(x_0,y_0)=(x_{L_5}+\\varepsilon,y_{L_5})$，其中 $\\varepsilon=10^{-6}$，步长 $h=0.01$。\n- 情况 C（$L_4$ 附近的较大步长）：平衡点 $L_4$，初始位置 $(x_0,y_0)=(x_{L_4}+\\varepsilon,y_{L_4})$，其中 $\\varepsilon=10^{-6}$，步长 $h=0.05$。\n- 情况 D（$L_4$ 处的精确平衡点）：平衡点 $L_4$，精确平衡点初始位置 $(x_0,y_0)=(x_{L_4},y_{L_4})$，其中 $\\varepsilon=0$，步长 $h=0.05$。\n\n角度单位为弧度。所有量均为无量纲。对于每种情况，按以下顺序计算四个浮点数：\n- $E^{\\mathrm{sym}}$：辛方法的最大绝对哈密顿量偏差。\n- $E^{\\mathrm{rk4}}$：龙格-库塔方法的最大绝对哈密顿量偏差。\n- $D^{\\mathrm{sym}}$：辛方法与平衡点的最大绝对位移。\n- $D^{\\mathrm{rk4}}$：龙格-库塔方法与平衡点的最大绝对位移。\n\n最终输出格式：\n你的程序应生成单行输出，包含案例 A、B、C 和 D 的 16 个结果，按顺序汇总并打印为用方括号括起来的逗号分隔列表，即：\n$[E^{\\mathrm{sym}}_{\\mathrm{A}},E^{\\mathrm{rk4}}_{\\mathrm{A}},D^{\\mathrm{sym}}_{\\mathrm{A}},D^{\\mathrm{rk4}}_{\\mathrm{A}},E^{\\mathrm{sym}}_{\\mathrm{B}},E^{\\mathrm{rk4}}_{\\mathrm{B}},D^{\\mathrm{sym}}_{\\mathrm{B}},D^{\\mathrm{rk4}}_{\\mathrm{B}},E^{\\mathrm{sym}}_{\\mathrm{C}},E^{\\mathrm{rk4}}_{\\mathrm{C}},D^{\\mathrm{sym}}_{\\mathrm{C}},D^{\\mathrm{rk4}}_{\\mathrm{C}},E^{\\mathrm{sym}}_{\\mathrm{D}},E^{\\mathrm{rk4}}_{\\mathrm{D}},D^{\\mathrm{sym}}_{\\mathrm{D}},D^{\\mathrm{rk4}}_{\\mathrm{D}}]$。", "solution": "提出的问题是有效的。其科学基础在于哈密顿力学和天体力学的原理，特别是圆形限制性三体问题。问题定义良好，提供了所有必要的常数、初始条件、方程和明确的目标。语言精确客观，该任务是计算物理学中比较数值积分器长期性能的一个标准练习。\n\n第一步是从给定的哈密顿量推导出显式的一阶常微分方程组（ODEs）。系统的状态由正则坐标 $(q,p) = (x, y, p_x, p_y)$ 描述。哈密顿量由下式给出\n$$H(x,y,p_x,p_y)=\\tfrac{1}{2}\\left(p_x^2+p_y^2\\right)+y\\,p_x-x\\,p_y-\\left(\\frac{1-\\mu}{r_1}+\\frac{\\mu}{r_2}\\right)$$\n其中 $r_1=\\sqrt{(x+\\mu)^2+y^2}$ 且 $r_2=\\sqrt{(x-1+\\mu)^2+y^2}$。运动方程为哈密顿方程，$\\dot{q}_i = \\partial H / \\partial p_i$ 和 $\\dot{p}_i = -\\partial H / \\partial q_i$。\n\n关于动量的导数为：\n$$\\dot{x} = \\frac{\\partial H}{\\partial p_x} = p_x + y$$\n$$\\dot{y} = \\frac{\\partial H}{\\partial p_y} = p_y - x$$\n\n关于位置的导数需要计算 $H$ 的偏导数。我们有：\n$$\\frac{\\partial H}{\\partial x} = -p_y - (1-\\mu)(-\\frac{1}{r_1^2})\\frac{\\partial r_1}{\\partial x} - \\mu(-\\frac{1}{r_2^2})\\frac{\\partial r_2}{\\partial x} = -p_y + \\frac{(1-\\mu)(x+\\mu)}{r_1^3} + \\frac{\\mu(x-1+\\mu)}{r_2^3}$$\n$$\\frac{\\partial H}{\\partial y} = p_x - (1-\\mu)(-\\frac{1}{r_1^2})\\frac{\\partial r_1}{\\partial y} - \\mu(-\\frac{1}{r_2^2})\\frac{\\partial r_2}{\\partial y} = p_x + \\frac{(1-\\mu)y}{r_1^3} + \\frac{\\mu y}{r_2^3}$$\n从 $\\dot{p}_i = -\\partial H/\\partial q_i$，我们得到动量的方程：\n$$\\dot{p}_x = p_y - \\frac{(1-\\mu)(x+\\mu)}{r_1^3} - \\frac{\\mu(x-1+\\mu)}{r_2^3}$$\n$$\\dot{p}_y = -p_x - y\\left(\\frac{1-\\mu}{r_1^3} + \\frac{\\mu}{r_2^3}\\right)$$\n这个由四个耦合的、自治的、一阶常微分方程组成的系统 $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$，其中 $\\mathbf{z}=(x,y,p_x,p_y)^T$，控制着动力学。\n\n接下来，我们指定数值积分方法。\n1.  **一阶辛欧拉方法：** 这种方法保留了相空间的辛结构，这对于哈密顿系统模拟的长期定性精度至关重要。对于在时间 $t_n$ 的状态 $\\mathbf{z}_n = (\\mathbf{q}_n, \\mathbf{p}_n)$，一个常见的显式一阶辛欧拉格式（也称为 Euler-B）通过以下两步更新得到在 $t_{n+1} = t_n + h$ 的状态：\n    $$\\mathbf{p}_{n+1} = \\mathbf{p}_n - h \\frac{\\partial H}{\\partial \\mathbf{q}}(\\mathbf{q}_n, \\mathbf{p}_n)$$\n    $$\\mathbf{q}_{n+1} = \\mathbf{q}_n + h \\frac{\\partial H}{\\partial \\mathbf{p}}(\\mathbf{q}_n, \\mathbf{p}_{n+1})$$\n    请注意，位置 $\\mathbf{q}$ 的更新使用了新计算出的动量 $\\mathbf{p}_{n+1}$。对于给定的 CRTBP 哈密顿量，这转化为以下一个时间步长 $h$ 的显式算法：\n    给定 $(\\mathbf{q}_n, \\mathbf{p}_n)=(x_n, y_n, p_{x,n}, p_{y,n})$：\n    首先，使用在当前状态下计算的力来更新动量：\n    $$p_{x, n+1} = p_{x,n} + h \\left(p_{y,n} - \\frac{(1-\\mu)(x_n+\\mu)}{r_{1,n}^3} - \\frac{\\mu(x_n-1+\\mu)}{r_{2,n}^3}\\right)$$\n    $$p_{y, n+1} = p_{y,n} + h \\left(-p_{x,n} - y_n\\left(\\frac{1-\\mu}{r_{1,n}^3} + \\frac{\\mu}{r_{2,n}^3}\\right)\\right)$$\n    其次，使用*新*动量和*旧*位置来更新位置：\n    $$x_{n+1} = x_n + h (p_{x,n+1} + y_n)$$\n    $$y_{n+1} = y_n + h (p_{y,n+1} - x_n)$$\n    这种方法具有一阶精度，但与同阶的非辛方法相比，它对哈密顿系统具有更优越的长期稳定性。\n\n2.  **经典四阶龙格-库塔（RK4）方法：** 这是一种标准的、通用的、非辛的求解常微分方程的方法。对于系统 $\\dot{\\mathbf{z}} = \\mathbf{f}(\\mathbf{z})$，从 $\\mathbf{z}_n$ 到 $\\mathbf{z}_{n+1}$ 的单步计算如下：\n    $$\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{z}_n)$$\n    $$\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{z}_n + \\tfrac{h}{2}\\mathbf{k}_1)$$\n    $$\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{z}_n + \\tfrac{h}{2}\\mathbf{k}_2)$$\n    $$\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{z}_n + h\\mathbf{k}_3)$$\n    $$\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\tfrac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$$\n    虽然单步精度很高（局部误差为 $O(h^5)$），但 RK4 方法不保留辛形式。这会导致守恒量（如哈密顿量）出现长期漂移，使其不适合此类系统的长期积分。\n\n模拟过程是通过为每个测试案例设置初始条件来推进的。地球-太阳系统的质量参数是 $\\mu=3.003489614915\\times 10^{-6}$。积分时间对应于 $N_p=30$ 次主天体公转，$T=2\\pi N_p$。步数为 $N=\\lfloor T/h \\rfloor$。对于每个案例，轨道在旋转参考系中以零速度初始化，这对应于初始正则动量 $p_x(0) = -y_0$ 和 $p_y(0) = x_0$。每个测试案例都用两种积分器分别运行一次模拟。在每次模拟期间，状态向量在每一步都被存储。积分完成后，计算两个诊断指标：哈密顿量与其初始值的最大绝对偏差 $\\max_{0\\le n\\le N}|H_n-H_0|$，以及与平衡点的最大位移 $\\max_{0\\le n\\le N}\\sqrt{(x_n-x_{\\mathrm{eq}})^2+(y_n-y_{\\mathrm{eq}})^2}$。然后将所有测试案例的结果汇总。预期结果是，辛积分器将显示有界的哈密顿量误差，而 RK4 方法将表现出漂移，这种能量守恒上的差异将反映在轨道稳定性上。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the CRTBP problem by comparing a symplectic Euler integrator\n    with a standard RK4 integrator for trajectories near L4 and L5.\n    \"\"\"\n\n    # Common parameters\n    MU = 3.003489614915e-6\n    NUM_REVOLUTIONS = 30\n    T_FINAL = 2.0 * np.pi * NUM_REVOLUTIONS\n\n    # Lagrange point coordinates\n    L4_POS = np.array([0.5 - MU, np.sqrt(3.0) / 2.0])\n    L5_POS = np.array([0.5 - MU, -np.sqrt(3.0) / 2.0])\n\n    # Test cases from the problem statement\n    test_cases = [\n        {'name': 'A', 'eq_point_pos': L4_POS, 'epsilon': 1e-6, 'h': 0.01},\n        {'name': 'B', 'eq_point_pos': L5_POS, 'epsilon': 1e-6, 'h': 0.01},\n        {'name': 'C', 'eq_point_pos': L4_POS, 'epsilon': 1e-6, 'h': 0.05},\n        {'name': 'D', 'eq_point_pos': L4_POS, 'epsilon': 0.0, 'h': 0.05},\n    ]\n\n    def get_hamiltonian(state):\n        x, y, px, py = state\n        r1 = np.sqrt((x + MU)**2 + y**2)\n        r2 = np.sqrt((x - 1.0 + MU)**2 + y**2)\n        \n        if r1 == 0 or r2 == 0:\n            return np.inf\n\n        H = 0.5 * (px**2 + py**2) + y * px - x * py - (1.0 - MU) / r1 - MU / r2\n        return H\n\n    def get_derivatives(state):\n        x, y, px, py = state\n        \n        r1_sq = (x + MU)**2 + y**2\n        r2_sq = (x - 1.0 + MU)**2 + y**2\n        \n        # Avoid division by zero, although not expected for these ICs\n        if r1_sq == 0 or r2_sq == 0:\n            return np.array([0.0, 0.0, 0.0, 0.0])\n\n        r1_cubed = r1_sq * np.sqrt(r1_sq)\n        r2_cubed = r2_sq * np.sqrt(r2_sq)\n\n        Gx_term1 = (1.0 - MU) * (x + MU) / r1_cubed\n        Gx_term2 = MU * (x - 1.0 + MU) / r2_cubed\n        Gy_factor = (1.0 - MU) / r1_cubed + MU / r2_cubed\n\n        dot_x = px + y\n        dot_y = py - x\n        dot_px = py - (Gx_term1 + Gx_term2)\n        dot_py = -px - y * Gy_factor\n        \n        return np.array([dot_x, dot_y, dot_px, dot_py])\n\n    def step_symplectic_euler(state, h):\n        x, y, px, py = state\n        \n        # Get derivatives for momentum update\n        _, _, dot_px, dot_py = get_derivatives(state)\n        \n        # Update momenta\n        px_new = px + h * dot_px\n        py_new = py + h * dot_py\n        \n        # Update positions using new momenta\n        x_new = x + h * (px_new + y)\n        y_new = y + h * (py_new - x)\n        \n        return np.array([x_new, y_new, px_new, py_new])\n\n    def step_rk4(state, h):\n        k1 = get_derivatives(state)\n        k2 = get_derivatives(state + 0.5 * h * k1)\n        k3 = get_derivatives(state + 0.5 * h * k2)\n        k4 = get_derivatives(state + h * k3)\n        return state + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    results = []\n    for case in test_cases:\n        h = case['h']\n        eq_point_pos = case['eq_point_pos']\n        \n        # Initial conditions\n        x0 = eq_point_pos[0] + case['epsilon']\n        y0 = eq_point_pos[1]\n        px0 = -y0\n        py0 = x0\n        initial_state = np.array([x0, y0, px0, py0])\n\n        num_steps = int(np.floor(T_FINAL / h))\n        H0 = get_hamiltonian(initial_state)\n\n        # Run for both integrators\n        for integrator_name, step_func in [('sym', step_symplectic_euler), ('rk4', step_rk4)]:\n            state = initial_state.copy()\n            max_hamiltonian_dev = 0.0\n            max_displacement = 0.0\n\n            for _ in range(num_steps):\n                state = step_func(state, h)\n\n                # Calculate diagnostics\n                H_current = get_hamiltonian(state)\n                hamiltonian_dev = np.abs(H_current - H0)\n                if hamiltonian_dev  max_hamiltonian_dev:\n                    max_hamiltonian_dev = hamiltonian_dev\n                \n                displacement = np.sqrt((state[0] - eq_point_pos[0])**2 + (state[1] - eq_point_pos[1])**2)\n                if displacement  max_displacement:\n                    max_displacement = displacement\n            \n            # Store results for this integrator\n            results.append(max_hamiltonian_dev)\n            results.append(max_displacement)\n    \n    # Reorder results list. Currently [E_sym, D_sym, E_rk4, D_rk4, ...].\n    # Need [E_sym, E_rk4, D_sym, D_rk4, ...].\n    final_results = []\n    for i in range(0, len(results), 4):\n        final_results.append(results[i])     # E_sym\n        final_results.append(results[i+2])   # E_rk4\n        final_results.append(results[i+1])   # D_sym\n        final_results.append(results[i+3])   # D_rk4\n    \n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2444608"}, {"introduction": "标准限制性三体问题模型将天体视为无体积的质点，这在大多数情况下是合理的近似，但在处理近距离飞越或轨道撞击等情况时则不够精确。本练习 [@problem_id:2434661] 将引导你对基础模型进行扩展，引入具有有限半径的主天体，并实现碰撞检测机制。这项实践是构建更真实、更鲁棒的航天器轨道或小行星动力学仿真的重要一步。", "problem": "实现一个独立的程序，模拟带有有限大小主天体的平面圆形限制性三体问题（CR3BP）。考虑两个质量分别为 $m_1$ 和 $m_2$ 的主天体，它们围绕其共同质心作圆周运动，以及一个质量可忽略不计的第三天体在它们的引力影响下运动。在一个均匀旋转的参考系中进行计算，在该参考系中，两个主天体固定在 $x$ 轴上，位置分别为 $(-\\mu,0)$ 和 $(1-\\mu,0)$，其中 $\\mu = \\dfrac{m_2}{m_1 + m_2} \\in (0,1)$。使用标准的 CR3BP 无量纲化标度，其中主天体之间的距离、质量之和 $m_1 + m_2$ 以及平均运动角速度均设为 $1$，因此所有长度和时间都是无量纲的。不使用任何物理单位；所有量根据构造都是无量纲的。\n\n在旋转参考系中，第三天体的位置 $(x,y)$ 和速度 $(\\dot{x},\\dot{y})$ 的运动方程为\n$$\n\\ddot{x} - 2 \\dot{y} = \\frac{\\partial \\Omega}{\\partial x}, \\quad\n\\ddot{y} + 2 \\dot{x} = \\frac{\\partial \\Omega}{\\partial y},\n$$\n其有效势为\n$$\n\\Omega(x,y) = \\frac{1}{2}\\left(x^2 + y^2\\right) + \\frac{1-\\mu}{r_1} + \\frac{\\mu}{r_2},\n$$\n到主天体的距离为\n$$\nr_1 = \\sqrt{(x+\\mu)^2 + y^2}, \\qquad r_2 = \\sqrt{(x-1+\\mu)^2 + y^2}.\n$$\n假设两个主天体都具有有限半径 $R_1$ 和 $R_2$（无量纲）。当 $r_1 \\le R_1$（与 $m_1$ 碰撞）或 $r_2 \\le R_2$（与 $m_2$ 碰撞）任一条件首次满足时，于最早时间 $t \\ge 0$ 发生碰撞事件。如果在同一模拟时间两个条件都满足，则将其归类为同时碰撞。如果在 $t \\in [0,T_{\\max}]$ 时间内两个条件都未发生，则归类为未发生碰撞。对于在 $t=0$ 时满足 $r_1 \\le R_1$ 或 $r_2 \\le R_2$ 的初始状态，您必须将其视为在 $t=0$ 发生的即时碰撞。\n\n对于下方的每个测试用例，从给定的初始状态 $(x(0),y(0),\\dot{x}(0),\\dot{y}(0))$ 开始模拟运动，直至最终时间 $T_{\\max}$（含），并根据以下约定输出一个整数代码：\n- 如果首先与 $m_1$ 发生碰撞，输出 $1$。\n- 如果首先与 $m_2$ 发生碰撞，输出 $2$。\n- 如果在同一模拟时间发生两次碰撞，输出 $3$。\n- 如果在 $t \\in [0,T_{\\max}]$ 时间内未发生碰撞，输出 $-1$。\n\n测试套件中的所有量均为无量纲。此问题中不涉及角度；无需使用角度单位。\n\n参数集 $(\\mu, R_1, R_2, x(0), y(0), \\dot{x}(0), \\dot{y}(0), T_{\\max})$ 的测试套件：\n- 情况 A（接近较小的主天体）：$\\left(\\mu, R_1, R_2, x(0), y(0), \\dot{x}(0), \\dot{y}(0), T_{\\max}\\right) = \\left(0.0121505856,\\; 0.0166,\\; 0.0045,\\; \\left(1-\\mu\\right)-\\left(R_2+0.001\\right),\\; 0,\\; 0.01,\\; 0,\\; 2.0\\right)$。\n- 情况 B（无运动的平衡构型）：$\\left(\\mu, R_1, R_2, x(0), y(0), \\dot{x}(0), \\dot{y}(0), T_{\\max}\\right) = \\left(0.0121505856,\\; 0.0166,\\; 0.0045,\\; 0.5-\\mu,\\; \\sqrt{3}/2,\\; 0,\\; 0,\\; 5.0\\right)$。\n- 情况 C（初始位于较大的主天体内部）：$\\left(\\mu, R_1, R_2, x(0), y(0), \\dot{x}(0), \\dot{y}(0), T_{\\max}\\right) = \\left(0.0121505856,\\; 0.0166,\\; 0.0045,\\; -\\mu,\\; 0,\\; 0,\\; 0,\\; 1.0\\right)$。\n- 情况 D（初始位于较小的主天体表面）：$\\left(\\mu, R_1, R_2, x(0), y(0), \\dot{x}(0), \\dot{y}(0), T_{\\max}\\right) = \\left(0.0121505856,\\; 0.0166,\\; 0.0045,\\; \\left(1-\\mu\\right)-R_2,\\; 0,\\; 0,\\; 0,\\; 1.0\\right)$。\n\n您的程序必须按 A、B、C、D 的顺序处理所有四个情况，并生成单行输出，其中包含四个整数结果，格式为逗号分隔的列表并用方括号括起，例如 $[a,b,c,d]$，其中 $a$、$b$、$c$ 和 $d$ 分别是情况 A、B、C 和 D 的整数代码。", "solution": "所述问题具有科学依据，提法恰当，并包含获得唯一且有意义解所需的所有信息。它描述了平面圆形限制性三体问题（CR3BP），这是天体力学中的一个经典问题。其运动方程是标准的，而模拟轨迹并进行碰撞检测的任务是一个清晰且可解的计算物理问题。我们将继续进行求解。\n\n该问题要求对一个二阶常微分方程（ODE）组进行数值积分。为便于数值求解，我们首先将该系统转换为等效的一阶形式。设第三天体的状态由一个四维向量 $S = [x, y, v_x, v_y]^T$ 表示，其中 $(x, y)$ 是位置坐标，$(v_x, v_y) = (\\dot{x}, \\dot{y})$ 是旋转参考系中的速度分量。这个由四个一阶常微分方程组成的系统由 $\\frac{dS}{dt} = F(t, S)$ 给出：\n$$\n\\begin{cases}\n\\dot{x} = v_x \\\\\n\\dot{y} = v_y \\\\\n\\dot{v}_x = \\ddot{x} = 2 v_y + \\frac{\\partial \\Omega}{\\partial x} \\\\\n\\dot{v}_y = \\ddot{y} = -2 v_x + \\frac{\\partial \\Omega}{\\partial y}\n\\end{cases}\n$$\n需要计算有效势 $\\Omega(x,y) = \\frac{1}{2}(x^2 + y^2) + \\frac{1-\\mu}{r_1} + \\frac{\\mu}{r_2}$ 的偏导数。它们是：\n$$\n\\frac{\\partial \\Omega}{\\partial x} = x - \\frac{(1-\\mu)(x+\\mu)}{r_1^3} - \\frac{\\mu(x-1+\\mu)}{r_2^3}\n$$\n$$\n\\frac{\\partial \\Omega}{\\partial y} = y - \\frac{(1-\\mu)y}{r_1^3} - \\frac{\\mu y}{r_2^3} = y \\left(1 - \\frac{1-\\mu}{r_1^3} - \\frac{\\mu}{r_2^3}\\right)\n$$\n其中 $r_1 = \\sqrt{(x+\\mu)^2 + y^2}$ 和 $r_2 = \\sqrt{(x-1+\\mu)^2 + y^2}$ 分别是到主天体质量 $m_1$ 和 $m_2$ 的距离。\n\n求解策略如下：\n$1$. 对于每个测试用例，首先检查在时间 $t=0$ 是否有即时碰撞。碰撞定义为 $r_1 \\le R_1$ 或 $r_2 \\le R_2$。初始距离 $r_1(0)$ 和 $r_2(0)$ 根据给定的初始位置 $(x(0), y(0))$ 计算。如果在 $t=0$ 时满足碰撞条件，则立即返回相应的整数代码，不执行积分。\n\n$2$. 如果在 $t=0$ 时没有发生碰撞，我们通过从 $t=0$ 到 $t=T_{\\max}$ 对一阶常微分方程组进行数值积分来解决这个初值问题（IVP）。为此，我们采用 `scipy.integrate` 库中的 `solve_ivp` 函数。该函数提供了适用于此类问题的稳健、自适应步长的积分器。为确保高精度，我们将相对和绝对误差容限分别设置为 $10^{-9}$ 和 $10^{-12}$。\n\n$3$. 模拟过程中的碰撞检测通过 `solve_ivp` 的 `events` 特性来处理。我们为每个主天体定义两个事件函数：\n- 针对 $m_1$ 的事件：$f_1(t, S) = r_1(x,y) - R_1$。当该函数值从正变为负过零时，发生碰撞。\n- 针对 $m_2$ 的事件：$f_2(t, S) = r_2(x,y) - R_2$。当该函数值从正变为负过零时，发生碰撞。\n\n这些事件被配置为 `terminal`，意味着一旦检测到首次碰撞，积分将立即停止。求解器能精确地找到根跨越的时刻。\n\n$4$. 积分后，我们分析输出。`solve_ivp` 的结果对象包含任何事件发生的时间。\n- 如果积分完成至 $T_{\\max}$ 仍未触发任何事件，则表示没有发生碰撞，结果为 $-1$。\n- 如果只触发了一种类型的事件，则表示与相应主天体的碰撞首先发生。\n- 如果两种类型的事件都触发了，我们比较它们的首次发生时间。时间较小的事件决定了哪个碰撞先发生。如果时间相同（在很小的数值容差内，例如 $10^{-9}$），则为同时碰撞。\n\n该方法为确定每种指定情况的结果提供了一个严谨且计算上可靠的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Simulates the planar circular restricted three-body problem (CR3BP)\n    for a set of test cases and determines collision outcomes.\n    \"\"\"\n\n    def cr3bp_odes(t, state, mu, R1, R2):\n        \"\"\"\n        Defines the CR3BP system of first-order ODEs.\n        The parameters R1 and R2 are unused but required for a unified\n        signature with the event functions.\n        \"\"\"\n        x, y, vx, vy = state\n\n        r1_sq = (x + mu)**2 + y**2\n        r2_sq = (x - (1 - mu))**2 + y**2\n\n        # Avoid division by zero. The event detection should prevent this by\n        # stopping the integration before a true singularity is reached.\n        if r1_sq == 0 or r2_sq == 0:\n            return [0, 0, 0, 0]\n\n        r1_cubed = r1_sq * np.sqrt(r1_sq)\n        r2_cubed = r2_sq * np.sqrt(r2_sq)\n\n        ax = x - (1 - mu) * (x + mu) / r1_cubed - mu * (x - (1 - mu)) / r2_cubed\n        ay = y * (1 - (1 - mu) / r1_cubed - mu / r2_cubed)\n        \n        dvx_dt = 2 * vy + ax\n        dvy_dt = -2 * vx + ay\n\n        return [vx, vy, dvx_dt, dvy_dt]\n\n    def event_m1(t, state, mu, R1, R2):\n        \"\"\"Event function for collision with primary m1.\"\"\"\n        x, y, _, _ = state\n        r1 = np.sqrt((x + mu)**2 + y**2)\n        return r1 - R1\n    event_m1.terminal = True\n    event_m1.direction = -1  # Detect when r1 crosses R1 downwards\n\n    def event_m2(t, state, mu, R1, R2):\n        \"\"\"Event function for collision with primary m2.\"\"\"\n        x, y, _, _ = state\n        r2 = np.sqrt((x - (1 - mu))**2 + y**2)\n        return r2 - R2\n    event_m2.terminal = True\n    event_m2.direction = -1  # Detect when r2 crosses R2 downwards\n\n    def run_simulation(params):\n        \"\"\"\n        Executes the simulation for a single test case.\n        \"\"\"\n        mu, R1, R2, x0, y0, vx0, vy0, Tmax = params\n\n        # 1. Check for immediate collision at t=0\n        r1_0 = np.sqrt((x0 + mu)**2 + y0**2)\n        r2_0 = np.sqrt((x0 - (1 - mu))**2 + y0**2)\n\n        coll1_init = (r1_0 = R1)\n        coll2_init = (r2_0 = R2)\n\n        if coll1_init and coll2_init:\n            return 3\n        if coll1_init:\n            return 1\n        if coll2_init:\n            return 2\n\n        # 2. Set up and run the integration if no initial collision\n        S0 = [x0, y0, vx0, vy0]\n        t_span = [0, Tmax]\n        args_tuple = (mu, R1, R2)\n\n        sol = solve_ivp(\n            fun=cr3bp_odes,\n            t_span=t_span,\n            y0=S0,\n            args=args_tuple,\n            events=[event_m1, event_m2],\n            rtol=1e-9,\n            atol=1e-12\n        )\n\n        # 3. Analyze the results from the solver\n        t_events_m1 = sol.t_events[0]\n        t_events_m2 = sol.t_events[1]\n\n        coll_m1_occurred = len(t_events_m1)  0\n        coll_m2_occurred = len(t_events_m2)  0\n\n        if coll_m1_occurred and coll_m2_occurred:\n            t1 = t_events_m1[0]\n            t2 = t_events_m2[0]\n            if abs(t1 - t2)  1e-9: # Check for simultaneous collision\n                return 3\n            elif t1  t2:\n                return 1\n            else:\n                return 2\n        elif coll_m1_occurred:\n            return 1\n        elif coll_m2_occurred:\n            return 2\n        else: # No events occurred, integration finished at Tmax\n            return -1\n\n    # Define the test cases from the problem statement.\n    mu_val = 0.0121505856\n    R1_val = 0.0166\n    R2_val = 0.0045\n\n    test_cases = [\n        # Case A: Near approach to the smaller primary\n        (mu_val, R1_val, R2_val, (1 - mu_val) - (R2_val + 0.001), 0, 0.01, 0, 2.0),\n        # Case B: Equilibrium configuration with no motion (L4 point)\n        (mu_val, R1_val, R2_val, 0.5 - mu_val, np.sqrt(3) / 2, 0, 0, 5.0),\n        # Case C: Initially inside the larger primary\n        (mu_val, R1_val, R2_val, -mu_val, 0, 0, 0, 1.0),\n        # Case D: Initially on the surface of the smaller primary\n        (mu_val, R1_val, R2_val, (1 - mu_val) - R2_val, 0, 0, 0, 1.0)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2434661"}]}