{"hands_on_practices": [{"introduction": "一个正的最大李雅普诺夫指数（LLE）是混沌动力系统最明确的标志，它量化了初始条件的敏感依赖性。本练习将指导你通过第一性原理，为经典的二维离散映射——Hénon映射——编写代码来计算其最大李雅普诺夫指数。通过实践，你将掌握追踪相邻轨迹指数分离的核心数值方法，这是研究奇异吸引子的基本功。[@problem_id:2443507]", "problem": "考虑在简单奇异吸引子相关文献中（包括 Julien C. Sprott 的目录）经常研究的一族二维自治离散时间二次多项式映射。该族的一个通用成员定义如下\n$$\n\\begin{aligned}\nx_{n+1} = a_0 + a_1 x_n + a_2 y_n + a_3 x_n^2 + a_4 x_n y_n + a_5 y_n^2,\\\\\ny_{n+1} = b_0 + b_1 x_n + b_2 y_n + b_3 x_n^2 + b_4 x_n y_n + b_5 y_n^2,\n\\end{aligned}\n$$\n其中 $x_n \\in \\mathbb{R}$ 和 $y_n \\in \\mathbb{R}$ 表示在离散时间步长 $n \\in \\mathbb{Z}_{\\ge 0}$ 时的状态，系数 $\\{a_i\\}_{i=0}^5$ 和 $\\{b_i\\}_{i=0}^5$ 是实常数。该映射的雅可比矩阵 $J(x,y)$ 是\n$$\nJ(x,y)=\n\\begin{bmatrix}\n\\frac{\\partial x_{n+1}}{\\partial x_n}  \\frac{\\partial x_{n+1}}{\\partial y_n} \\\\\n\\frac{\\partial y_{n+1}}{\\partial x_n}  \\frac{\\partial y_{n+1}}{\\partial y_n}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\na_1 + 2 a_3 x + a_4 y  a_2 + a_4 x + 2 a_5 y \\\\\nb_1 + 2 b_3 x + b_4 y  b_2 + b_4 x + 2 b_5 y\n\\end{bmatrix}.\n$$\n\n你的任务是仅使用第一性原理，为该族的几个特定实例计算最大李雅普诺夫指数（Largest Lyapunov Exponent, LLE）。从离散时间动力系统的定义以及李雅普诺夫指数作为相邻轨道分离的渐进指数率的定义出发。使用雅可比矩阵进行线性化来演化一个无穷小切向量，并周期性地对其进行重新归一化以避免数值溢出，同时累加平均对数拉伸。你不能使用任何计算李雅普诺夫指数的闭式快捷公式；相反，必须通过迭代映射及其雅可比矩阵来实现计算。\n\n定义与要求：\n- 对于离散映射 $F:\\mathbb{R}^2 \\to \\mathbb{R}^2$，沿轨道 $\\{(x_n,y_n)\\}_{n=0}^{N}$ 计算的最大李雅普诺夫指数 $\\lambda_{\\max}$ 定义为\n$$\n\\lambda_{\\max} = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln \\left\\| J(x_n,y_n)\\, \\mathbf{v}_n \\right\\|,\n$$\n其中 $\\mathbf{v}_n$ 是一个单位切向量，它通过线性化 $\\mathbf{v}_{n+1} \\propto J(x_n,y_n)\\, \\mathbf{v}_n$ 进行演化，并在每一步应用归一化 $\\|\\mathbf{v}_{n+1}\\|=1$ ，$\\|\\cdot\\|$ 是欧几里得范数。\n- 舍弃最初 $N_{\\text{trans}}$ 次迭代的暂态，以确保轨道在累加求和之前已经处于吸引子上，然后在 $N_{\\text{iter}}$ 次迭代上进行平均。\n- 以“奈特/迭代”（以 $e$ 为底的自然对数）为单位报告每个 $\\lambda_{\\max}$，结果为四舍五入到 $6$ 位小数的浮点数。\n\n实现一个程序，对下面的每个测试用例执行以下操作：\n1. 按规定初始化 $(x_0,y_0)$。\n2. 迭代映射 $N_{\\text{trans}}$ 步，不累加李雅普诺夫和。\n3. 初始化一个单位切向量 $\\mathbf{v}_0$（你可以使用归一化后的 $\\mathbf{v}_0 = (1,0)$）。\n4. 进行 $N_{\\text{iter}}$ 步，在每次迭代中：\n   - 计算 $J(x_n,y_n)$。\n   - 计算 $\\mathbf{w} = J(x_n,y_n)\\,\\mathbf{v}_n$、其范数 $\\|\\mathbf{w}\\|$，并累加 $\\ln \\|\\mathbf{w}\\|$。\n   - 设置 $\\mathbf{v}_{n+1} = \\mathbf{w}/\\|\\mathbf{w}\\|$。\n   - 通过二次映射更新 $(x_{n+1},y_{n+1})$。\n5. 返回累加和除以 $N_{\\text{iter}}$ 的结果作为 $\\lambda_{\\max}$。\n\n测试套件：\n- 用例 1（Sprott 目录中常见的 Hénon 型系数），参数 $a = 1.4$, $b = 0.3$：\n  - 映射: $x_{n+1} = 1 + y_n - a x_n^2$, $y_{n+1} = b x_n$。\n  - 系数: $a_0=1$, $a_1=0$, $a_2=1$, $a_3=-a$, $a_4=0$, $a_5=0$; $b_0=0$, $b_1=b$, $b_2=0$, $b_3=0$, $b_4=0$, $b_5=0$。\n  - 初始条件: $(x_0,y_0)=(0,0)$。\n  - 暂态: $N_{\\text{trans}}=1000$。\n  - 平均长度: $N_{\\text{iter}}=100000$。\n- 用例 2（结构相同，但非线性减弱），参数 $a = 1.2$, $b = 0.3$：\n  - 系数定义与用例 1 相同，但 $a=1.2$, $b=0.3$。\n  - 初始条件: $(x_0,y_0)=(0,0)$。\n  - 暂态: $N_{\\text{trans}}=1000$。\n  - 平均长度: $N_{\\text{iter}}=100000$。\n- 用例 3（面积收缩减弱），参数 $a = 1.4$, $b = 0.1$：\n  - 系数定义与用例 1 相同，但 $a=1.4$, $b=0.1$。\n  - 初始条件: $(x_0,y_0)=(0,0)$。\n  - 暂态: $N_{\\text{trans}}=1000$。\n  - 平均长度: $N_{\\text{iter}}=100000$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是相应测试用例计算出的最大李雅普诺夫指数，四舍五入到 $6$ 位小数，单位为奈特/迭代。\n\n此问题不涉及角度。所有量都是无量纲的，李雅普诺夫指数必须以“奈特/迭代”为单位报告。最终输出必须是严格符合指定格式的一行，且不包含任何额外文本。", "solution": "按规定，此问题需要经过验证。\n\n**第 1 步：提取的已知信息**\n- **系统**：一个二维二次映射 $F: \\mathbb{R}^2 \\to \\mathbb{R}^2$，由 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$ 给出，其中 $\\mathbf{z}_n = (x_n, y_n)^T$。\n  - 通用形式：\n    $x_{n+1} = a_0 + a_1 x_n + a_2 y_n + a_3 x_n^2 + a_4 x_n y_n + a_5 y_n^2$\n    $y_{n+1} = b_0 + b_1 x_n + b_2 y_n + b_3 x_n^2 + b_4 x_n y_n + b_5 y_n^2$\n  - 雅可比矩阵：\n    $J(x,y) = \\begin{bmatrix} a_1 + 2 a_3 x + a_4 y  a_2 + a_4 x + 2 a_5 y \\\\ b_1 + 2 b_3 x + b_4 y  b_2 + b_4 x + 2 b_5 y \\end{bmatrix}$\n- **最大李雅普诺夫指数 (LLE) 定义**：$\\lambda_{\\max} = \\lim_{N \\to \\infty} \\frac{1}{N} \\sum_{n=0}^{N-1} \\ln \\| J(x_n,y_n)\\, \\mathbf{v}_n \\|$，其中 $\\mathbf{v}_{n+1} = J(x_n,y_n)\\,\\mathbf{v}_n / \\|J(x_n,y_n)\\,\\mathbf{v}_n\\|$。\n- **数值计算步骤**：\n  - 初始状态：$(x_0, y_0)$ 按规定。\n  - 暂态迭代：$N_{\\text{trans}}$。\n  - 平均迭代：$N_{\\text{iter}}$。\n  - 初始切向量：$\\mathbf{v}_0$ 是单位向量，例如，归一化后的 $(1,0)$。\n- **测试用例**：所有用例都使用 Hénon 型映射：$x_{n+1} = 1 + y_n - a x_n^2$, $y_{n+1} = b x_n$。\n  - 所有用例的初始条件：$(x_0,y_0)=(0,0)$。\n  - 所有用例的迭代次数：$N_{\\text{trans}}=1000$, $N_{\\text{iter}}=100000$。\n  - 用例 1: $a = 1.4$, $b = 0.3$。\n  - 用例 2: $a = 1.2$, $b = 0.3$。\n  - 用例 3: $a = 1.4$, $b = 0.1$。\n- **输出**：一个 $\\lambda_{\\max}$ 值的列表，四舍五入到 6 位小数，单位为奈特/迭代。\n\n**第 2 步：验证**\n- **科学依据**：该问题在动力系统和混沌理论中有坚实的理论基础。李雅普诺夫指数的计算是该领域的典型技术。\n- **良置性**：问题定义了动力系统、待计算量 ($\\lambda_{\\max}$) 以及包含所有必要参数（$N_{\\text{trans}}$、$N_{\\text{iter}}$、初始条件）的数值算法。有限和近似是计算理论极限的标准实用方法。\n- **一致性**：为上下文提供了映射的通用形式及其雅可比矩阵。测试用例的特定映射，即 Hénon 型映射，是此通用形式的一个特例。其系数为 $a_0=1, a_2=1, a_3=-a, b_1=b$，所有其他系数均为零。由特定映射导出的雅可比矩阵 $J(x,y) = \\begin{bmatrix} -2ax  1 \\\\ b  0 \\end{bmatrix}$ 与给定这些系数值的通用雅可比公式一致。整个设置是完全自洽和一致的。\n\n**第 3 步：结论**\n该问题是有效的。它是一项精确、科学上合理且良置的计算任务。我将继续进行解答。\n\n---\n\n该问题要求从第一性原理出发，计算一个离散时间动力系统的最大李雅普诺夫指数 ($\\lambda_{\\max}$)。这是计算物理学中的一个基本练习，用于探究系统对初始条件的敏感性——这是混沌的一个定义性特征。\n\n一个正的最大李雅普诺夫指数 $\\lambda_{\\max}  0$ 表示无穷近的轨道平均以指数速率 $e^{\\lambda_{\\max}}$ 分离。这是混沌动力学的数学标志。我们的任务是实现计算指定二维二次映射此量的标准算法。\n\n系统在离散时间 $n$ 的状态由向量 $\\mathbf{z}_n = (x_n, y_n)^T$ 给出。其演化由非线性映射 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$ 控制。考虑两个邻近的初始点 $\\mathbf{z}_0$ 和 $\\mathbf{z}_0 + \\delta\\mathbf{z}_0$，其中 $\\delta\\mathbf{z}_0$ 是一个无穷小位移向量。经过一次迭代，分离向量根据映射的线性化进行演化：\n$$\n\\delta\\mathbf{z}_1 = F(\\mathbf{z}_0 + \\delta\\mathbf{z}_0) - F(\\mathbf{z}_0) \\approx J(\\mathbf{z}_0) \\delta\\mathbf{z}_0,\n$$\n其中 $J(\\mathbf{z}_0)$ 是 $F$ 在 $\\mathbf{z}_0$ 处求值的雅可比矩阵。经过 $N$ 次迭代，分离向量变为：\n$$\n\\delta\\mathbf{z}_N \\approx J(\\mathbf{z}_{N-1}) \\cdots J(\\mathbf{z}_1) J(\\mathbf{z}_0) \\delta\\mathbf{z}_0.\n$$\n最大李雅普诺夫指数由该分离向量的模 $\\|\\delta\\mathbf{z}_N\\|$ 在 $N \\to \\infty$ 时的最大指数增长率定义。\n\n直接计算雅可比矩阵的乘积在数值上是不稳定的。我们必须实现一种稳健的方法，它涉及沿轨道演化一个切向量 $\\mathbf{v}_n$ 并周期性地对其进行重新归一化。这可以避免数值溢出，并确保该向量与最大拉伸方向对齐。算法如下：\n\n1.  初始化状态 $\\mathbf{z}_0=(x_0, y_0)$ 和一个单位长度的切向量 $\\mathbf{v}_0$，例如 $\\mathbf{v}_0 = (1, 0)^T$。\n2.  迭代映射 $N_{\\text{trans}}$ 步，让轨道稳定到其吸引子上。这确保计算出的指数是系统长期行为的特征，而不是初始暂态的。因此，对于 $n = 0, \\dots, N_{\\text{trans}}-1$，我们计算 $\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$。\n3.  暂态过后，开始进行 $N_{\\text{iter}}$ 步的累加阶段。对于 $n = N_{\\text{trans}}, \\dots, N_{\\text{trans}}+N_{\\text{iter}}-1$：\n    a. 使用线性化演化切向量一步：$\\mathbf{w}_n = J(\\mathbf{z}_n) \\mathbf{v}_n$。\n    b. 这个新向量的长度 $s_n = \\|\\mathbf{w}_n\\|$ 代表了沿 $\\mathbf{v}_n$ 方向的局部拉伸因子。该值的对数 $\\ln(s_n)$ 被累加到一个总和中。\n    c. 为下一次迭代将向量重新归一化为单位长度：$\\mathbf{v}_{n+1} = \\mathbf{w}_n / s_n$。\n    d. 将状态演化到轨道上的下一个点：$\\mathbf{z}_{n+1} = F(\\mathbf{z}_n)$。\n4.  最大李雅普诺夫指数是累积的对数拉伸的平均值：\n    $$\n    \\lambda_{\\max} \\approx \\frac{1}{N_{\\text{iter}}} \\sum_{i=0}^{N_{\\text{iter}}-1} \\ln(s_i).\n    $$\n\n对于问题中给出的特定 Hénon 型映射，我们有：\n- 映射 $F(x,y)$:\n  $x_{n+1} = 1 + y_n - a x_n^2$\n  $y_{n+1} = b x_n$\n- 雅可比矩阵 $J(x,y)$:\n  $$\n  J(x,y) = \\begin{bmatrix} -2ax_n  1 \\\\ b  0 \\end{bmatrix}\n  $$\n该过程将对三个测试用例中的每一个实施，使用提供的参数 $a$、$b$、初始条件 $(x_0, y_0)=(0,0)$ 以及迭代次数 $N_{\\text{trans}}=1000$ 和 $N_{\\text{iter}}=100000$。每个用例的结果将按要求四舍五入到 6 位小数。使用 NumPy 来高效处理向量和矩阵运算是合适的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the largest Lyapunov exponent (LLE) for several instances of the Hénon map.\n    The final output is a single line containing a comma-separated list of results.\n    \"\"\"\n\n    def compute_lle(a, b, x0, y0, N_trans, N_iter):\n        \"\"\"\n        Calculates the LLE for a given set of Hénon map parameters.\n\n        Args:\n            a (float): The 'a' parameter of the Hénon map.\n            b (float): The 'b' parameter of the Hénon map.\n            x0 (float): Initial x-coordinate.\n            y0 (float): Initial y-coordinate.\n            N_trans (int): Number of transient iterations to discard.\n            N_iter (int): Number of iterations for averaging the LLE.\n\n        Returns:\n            float: The computed largest Lyapunov exponent.\n        \"\"\"\n        x, y = x0, y0\n\n        # Transient phase to let the trajectory settle onto the attractor\n        for _ in range(N_trans):\n            x_next = 1.0 + y - a * x * x\n            y_next = b * x\n            x, y = x_next, y_next\n\n        # Initialization for Lyapunov exponent calculation\n        # Start with an arbitrary normalized tangent vector\n        v = np.array([1.0, 0.0])\n        log_stretch_sum = 0.0\n\n        # Main loop for LLE calculation\n        for _ in range(N_iter):\n            # Evolve state\n            x_next = 1.0 + y - a * x * x\n            y_next = b * x\n\n            # Jacobian matrix at the current point (x, y)\n            # J = [[-2*a*x, 1.0], [b, 0.0]]\n            J = np.array([[-2.0 * a * x, 1.0], [b, 0.0]])\n\n            # Evolve the tangent vector by matrix multiplication\n            w = J @ v\n\n            # Calculate the norm (stretching factor)\n            norm_w = np.linalg.norm(w)\n            \n            # Accumulate the logarithm of the stretching factor\n            if norm_w > 0: # Avoid log(0) in case of collapse to a fixed point\n                log_stretch_sum += np.log(norm_w)\n            \n            # Re-normalize the tangent vector for the next iteration\n            v = w / norm_w\n\n            # Update the state for the next iteration\n            x, y = x_next, y_next\n\n        # The LLE is the average of the logarithmic stretches\n        lle = log_stretch_sum / N_iter\n        return lle\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: a = 1.4, b = 0.3 (Classic Hénon)\n        (1.4, 0.3),\n        # Case 2: a = 1.2, b = 0.3\n        (1.2, 0.3),\n        # Case 3: a = 1.4, b = 0.1\n        (1.4, 0.1),\n    ]\n\n    # Shared parameters for all test cases\n    N_transient = 1000\n    N_iterations = 100000\n    initial_x = 0.0\n    initial_y = 0.0\n\n    results = []\n    for a, b in test_cases:\n        # Calculate the LLE for the current case\n        result = compute_lle(a, b, initial_x, initial_y, N_transient, N_iterations)\n        # Round the result to 6 decimal places\n        results.append(round(result, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443507"}, {"introduction": "在掌握了离散映射的LLE计算之后，我们将目光转向更复杂的连续流系统，例如洛伦兹系统。完整的李雅普诺夫指数谱 $(\\lambda_1, \\lambda_2, \\lambda_3)$ 提供了比单个最大指数更全面的动力学图像。本练习要求你通过数值积分和QR分解这一标准方法，计算洛伦兹系统的完整李雅普诺夫谱，并验证奇异吸引子所特有的指数符号模式。[@problem_id:2443522]", "problem": "计算三维洛伦兹系统的完整李雅普诺夫谱，并验证奇异吸引子的标准特征。洛伦兹系统是由以下常微分方程（ODE）给出的自治系统：\n$$\n\\dot{x} = \\sigma (y - x), \\quad\n\\dot{y} = x(\\rho - z) - y, \\quad\n\\dot{z} = x y - \\beta z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是实数参数，$(x,y,z)$ 是状态变量。一条轨迹 $x(t)$ 的李雅普诺夫谱 $(\\lambda_1,\\lambda_2,\\lambda_3)$ 是由受变分方程控制的切流 $W(t)$ 定义的：\n$$\n\\dot{W}(t) = J(x(t))\\,W(t), \\qquad W(0)=I,\n$$\n其中 $J(x)$ 是沿轨迹求值的向量场的雅可比矩阵，$I$ 是单位矩阵。如果 $s_1(t)\\ge s_2(t)\\ge s_3(t)0$ 表示 $W(t)$ 的奇异值，那么李雅普诺夫指数为：\n$$\n\\lambda_i = \\lim_{t\\to\\infty} \\frac{1}{t}\\,\\ln s_i(t), \\quad i\\in\\{1,2,3\\}.\n$$\n对于一个光滑流，李雅普诺夫指数之和等于向量场散度沿轨迹的长时间平均值。对于洛伦兹系统，其散度是恒定的，由下式给出：\n$$\n\\nabla\\cdot f = -\\sigma - 1 - \\beta,\n$$\n因此\n$$\n\\lambda_1+\\lambda_2+\\lambda_3 = -\\sigma - 1 - \\beta.\n$$\n你的任务是为下面的每个测试用例计算 $(\\lambda_1,\\lambda_2,\\lambda_3)$，并对每个用例返回一个布尔值，该值表示以下两个条件是否同时成立：\n- 符号模式条件：$\\lambda_1  0$，$|\\lambda_2| \\le \\delta_0$ 且 $\\lambda_3  0$，其中 $\\delta_0 = 0.1$。\n- 和一致性条件：$\\left|(\\lambda_1+\\lambda_2+\\lambda_3) - \\big(-\\sigma - 1 - \\beta\\big)\\right| \\le \\delta_\\Sigma$，其中 $\\delta_\\Sigma = 0.5$。\n\n使用以下测试套件。在每个用例中，从初始条件 $(x(0),y(0),z(0))$ 开始积分，舍弃持续时间为 $T_{\\text{trans}}$ 的初始暂态过程，然后使用持续时间为 $T_{\\text{avg}}$ 的后续时间间隔上的时间平均来估计李雅普诺夫指数：\n- 用例 1：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 2：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(5,5,5)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 3：$\\sigma=10$，$\\rho=35$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 4：$\\sigma=10$，$\\rho=20$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=100$。\n- 用例 5：$\\sigma=10$，$\\rho=28$，$\\beta=8/3$，$(x(0),y(0),z(0))=(1,1,1)$，$T_{\\text{trans}}=5$，$T_{\\text{avg}}=40$。\n\n你的程序应生成单行输出，其中包含一个由五个布尔值组成的逗号分隔列表，并用方括号括起来（例如，'[True,False,True,True,False]'）。不允许有任何其他输出。本问题不涉及物理单位。本问题不涉及角度。如上所述，使用绝对值来表示任何容差检查。", "solution": "洛伦兹系统是一个光滑的三维自治流，由向量场定义：\n$$\nf(x,y,z) = \\big(\\sigma(y-x),\\,x(\\rho - z) - y,\\,xy - \\beta z\\big).\n$$\n其雅可比矩阵为：\n$$\nJ(x,y,z) = \n\\begin{pmatrix}\n-\\sigma  \\sigma  0\\\\\n\\rho - z  -1  -x\\\\\ny  x  -\\beta\n\\end{pmatrix}.\n$$\n李雅普诺夫指数用于量化无穷小扰动的渐近指数增长率。设 $x(t)$ 为一条解轨迹，$W(t)$ 为变分方程的基本矩阵：\n$$\n\\dot{W}(t) = J(x(t))\\,W(t), \\qquad W(0)=I.\n$$\n如果 $s_i(t)$ 是 $W(t)$ 按非递增顺序排列的奇异值，那么根据定义：\n$$\n\\lambda_i = \\lim_{t\\to\\infty} \\frac{1}{t}\\ln s_i(t), \\quad i=1,2,3.\n$$\n这个定义与坐标无关，并源于第一性原理：沿轨迹将非线性流线性化，并追踪切向量的增长。\n\n一个关键的恒等式将李雅普诺夫指数之和与向量场的散度联系起来。刘维尔公式（Liouville’s formula）指出：\n$$\n\\frac{d}{dt}\\ln\\det W(t) = \\operatorname{tr}\\left(J(x(t))\\right).\n$$\n积分并除以 $t$ 可得：\n$$\n\\frac{1}{t}\\ln\\det W(t) = \\frac{1}{t}\\int_0^t \\operatorname{tr}(J(x(s)))\\,ds.\n$$\n当 $t\\to\\infty$ 时，左侧收敛于 $\\lambda_1+\\lambda_2+\\lambda_3$（因为 $\\det W$ 是奇异值的乘积），右侧收敛于散度的长时间平均值。对于洛伦兹系统，$\\operatorname{tr} J = -\\sigma - 1 - \\beta$ 是一个常数，因此：\n$$\n\\lambda_1+\\lambda_2+\\lambda_3 = -\\sigma - 1 - \\beta.\n$$\n为了数值计算完整的谱，需要将基础流 $x(t)$ 与切流 $W(t)$ 一起积分。由于指数增长和衰减，$W(t)$ 的直接演化会导致严重的条件数问题。标准的、基于原理的解决方法是使用正交三角（QR）分解，周期性地将 $W(t)$ 分解为正交三角形式，\n$$\nW(t_k) = Q_k R_k,\n$$\n其中 $Q_k$ 是正交矩阵，$R_k$ 是对角线元素为正的上三角矩阵。$R_k$ 的对角线捕捉了该时间间隔内的局部拉伸因子，我们需要累加这些对角元素的对数。具体来说，如果两次再正交化之间的时间间隔为 $\\Delta t$，并且在第 $k$ 个间隔上得到 $R_k$，那么经过 $N$ 个这样的间隔后，李雅普诺夫指数可估计为：\n$$\n\\hat{\\lambda}_i = \\frac{1}{N\\,\\Delta t} \\sum_{k=1}^{N} \\ln\\left(\\left|R_k(i,i)\\right|\\right), \\quad i=1,2,3.\n$$\n将这些估计值按非递增顺序排序，即可得到 $(\\lambda_1,\\lambda_2,\\lambda_3)$。\n\n为进行验证，每个测试用例都需要进行两项检查：\n- 奇异吸引子预期的符号模式是 $\\lambda_10$，$\\lambda_2\\approx 0$ 且 $\\lambda_30$。我们强制要求 $|\\lambda_2|\\le \\delta_0$（其中 $\\delta_0=0.1$）以考虑有限时间估计的影响。\n- 指数之和必须与精确的散度恒等式一致，即 $\\left|(\\lambda_1+\\lambda_2+\\lambda_3) - \\big(-\\sigma - 1 - \\beta\\big)\\right|\\le \\delta_\\Sigma$（其中 $\\delta_\\Sigma=0.5$）。\n\n对于经典的混沌洛伦兹参数 $\\sigma=10, \\rho=28, \\beta=8/3$，已知的渐近值约为 $\\lambda_1\\approx 0.9, \\lambda_2\\approx 0, \\lambda_3\\approx -14.6$，其和约为 $-13.7$，这与 $-\\sigma-1-\\beta = -13.\\overline{6}$ 一致。由于遍历性，同一吸引子上的不同初始条件会产生相同的谱。将 $\\rho$ 增加到 $\\rho=35$ 仍然是混沌的，并保持了符号模式。将 $\\rho$ 减小到 $\\rho=20$ 会产生一个非混沌区域，其中 $\\lambda_10$，因此符号模式测试会失败，尽管和恒等式仍然成立。\n\n从算法上讲，该程序积分洛伦兹ODE及其变分方程，对切矩阵应用周期性的正交三角（QR）再正交化，在舍弃初始暂态 $T_{\\text{trans}}$ 后，在平均间隔 $T_{\\text{avg}}$ 上累加对数拉伸因子以估计李雅普诺夫指数，对指数进行排序，并使用给定的容差评估这两个条件。最终输出是一个包含五个布尔值的列表，每个布尔值对应一个测试用例，表示两个条件是否同时满足。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef lorenz_and_variational(t, y, sigma, rho, beta):\n    \"\"\"\n    y contains [x, y, z, W_flattened(9)]\n    Returns derivatives for the Lorenz system and the variational matrix W.\n    \"\"\"\n    x, yv, z = y[0], y[1], y[2]\n    W = y[3:].reshape(3, 3)\n\n    # Lorenz dynamics\n    dx = sigma * (yv - x)\n    dy = x * (rho - z) - yv\n    dz = x * yv - beta * z\n\n    # Jacobian of the Lorenz system\n    J = np.array([\n        [-sigma,   sigma,     0.0],\n        [rho - z,  -1.0,     -x   ],\n        [yv,       x,       -beta ]\n    ], dtype=float)\n\n    # Variational equation: dW/dt = J * W\n    dW = J @ W\n\n    deriv = np.empty(12, dtype=float)\n    deriv[0:3] = [dx, dy, dz]\n    deriv[3:] = dW.reshape(9)\n    return deriv\n\ndef integrate_step_with_qr(x_state, Q, h, sigma, rho, beta, rtol=1e-6, atol=1e-9, method='RK45'):\n    \"\"\"\n    Integrate the augmented system for time h starting from state x_state and\n    tangent basis Q. Return the next state, next orthonormal basis, and the\n    diagonal of R from QR factorization of the transported basis.\n    \"\"\"\n    y0 = np.empty(12, dtype=float)\n    y0[0:3] = x_state\n    y0[3:] = (Q).reshape(9)\n\n    sol = solve_ivp(\n        lorenz_and_variational,\n        t_span=(0.0, h),\n        y0=y0,\n        args=(sigma, rho, beta),\n        method=method,\n        rtol=rtol,\n        atol=atol\n    )\n    yf = sol.y[:, -1]\n    xf = yf[0:3]\n    Wf = yf[3:].reshape(3, 3)\n\n    # QR decomposition to re-orthonormalize\n    Qn, R = np.linalg.qr(Wf)\n    # Ensure numerical stability: avoid zero diagonals for log\n    diagR = np.diag(R)\n    # Accumulate logs of absolute diagonal entries\n    abs_diag = np.abs(diagR)\n    # Protect against extremely small values\n    eps = 1e-300\n    abs_diag = np.maximum(abs_diag, eps)\n\n    return xf, Qn, np.log(abs_diag)\n\ndef lyapunov_spectrum(sigma, rho, beta, x0, T_trans, T_avg, dt_re=0.05):\n    \"\"\"\n    Compute the full Lyapunov spectrum (lambda1 >= lambda2 >= lambda3)\n    for the Lorenz system with given parameters and initial condition.\n    Discard an initial transient T_trans, then average over T_avg.\n    \"\"\"\n    # Ensure T_trans and T_avg are multiples of dt_re for clean stepping\n    n_trans = int(round(T_trans / dt_re))\n    n_avg = int(round(T_avg / dt_re))\n    # Initialize state and tangent basis\n    x = np.array(x0, dtype=float)\n    Q = np.eye(3, dtype=float)\n\n    # Transient phase (do not accumulate)\n    for _ in range(n_trans):\n        x, Q, _ = integrate_step_with_qr(x, Q, dt_re, sigma, rho, beta)\n\n    # Averaging phase (accumulate)\n    sum_logs = np.zeros(3, dtype=float)\n    for _ in range(n_avg):\n        x, Q, logs = integrate_step_with_qr(x, Q, dt_re, sigma, rho, beta)\n        sum_logs += logs\n\n    # Estimate exponents\n    lambdas = sum_logs / (n_avg * dt_re)\n    # Sort in nonincreasing order\n    lambdas_sorted = np.sort(lambdas)[::-1]\n    return lambdas_sorted\n\ndef verify_case(sigma, rho, beta, x0, T_trans, T_avg, delta_zero=0.1, delta_sum=0.5):\n    lambdas = lyapunov_spectrum(sigma, rho, beta, x0, T_trans, T_avg)\n    lam1, lam2, lam3 = lambdas[0], lambdas[1], lambdas[2]\n    # Sign pattern condition\n    ok_signs = (lam1 > 0.0) and (abs(lam2) = delta_zero) and (lam3  0.0)\n    # Sum consistency condition\n    target_sum = -(sigma + 1.0 + beta)\n    ok_sum = abs((lam1 + lam2 + lam3) - target_sum) = delta_sum\n    return ok_signs and ok_sum\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (sigma, rho, beta, (x0,y0,z0), T_trans, T_avg)\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 1\n        (10.0, 28.0, 8.0/3.0, (5.0, 5.0, 5.0), 5.0, 100.0),  # Case 2\n        (10.0, 35.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 3\n        (10.0, 20.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 100.0),  # Case 4 (nonchaotic)\n        (10.0, 28.0, 8.0/3.0, (1.0, 1.0, 1.0), 5.0, 40.0),   # Case 5 (shorter average)\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, rho, beta, x0, T_trans, T_avg = case\n        result = verify_case(sigma, rho, beta, x0, T_trans, T_avg, delta_zero=0.1, delta_sum=0.5)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2443522"}, {"introduction": "李雅普诺夫指数不仅揭示了系统的动力学行为，还能帮助我们估算奇异吸引子的几何复杂性。Kaplan-Yorke维度正是连接动力学（李雅普诺夫指数）与几何学（分形维度）的桥梁。在此练习中，你将运用前一个练习中获得的技能来计算洛伦兹吸引子的Kaplan-Yorke维度，并探究它如何随系统参数 $\\rho$ 的变化而变化，从而深入理解混沌吸引子的分形结构。[@problem_id:2443485]", "problem": "要求您从第一性原理出发，研究Kaplan–Yorke (KY) 维数对Lorenz系统控制参数的依赖关系。考虑由以下常微分方程 (ODEs) 组构成的Lorenz系统\n$$\n\\dot{x} = \\sigma (y - x),\\quad\n\\dot{y} = x(\\rho - z) - y,\\quad\n\\dot{z} = x y - \\beta z,\n$$\n参数固定为 $ \\sigma = 10 $，$ \\beta = \\frac{8}{3} $，以及一个可变的控制参数 $ \\rho  0 $。设初始条件为 $ (x(0),y(0),z(0)) = (1,1,1) $。本问题中的所有量均为无量纲。\n\n设 $ \\phi^t(\\mathbf{x}_0) $ 表示从 $ \\mathbf{x}_0 \\in \\mathbb{R}^3 $ 出发在时间 $ t $ 的流映射。沿轨道 $ \\mathbf{x}(t) $ 的流的线性化由变分方程决定\n$$\n\\frac{d}{dt}\\,\\delta \\mathbf{x}(t) = J(\\mathbf{x}(t))\\,\\delta \\mathbf{x}(t),\n$$\n其中 $ J(\\mathbf{x}) $ 是向量场的雅可比矩阵，\n$$\nJ(x,y,z) =\n\\begin{pmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{pmatrix}.\n$$\n\n将三个Lyapunov指数 $ \\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3 $ 定义为沿典型轨道上变分方程基本矩阵解的奇异值的渐近指数增长率。使用这些指数，将Kaplan–Yorke维数 $ D_{\\mathrm{KY}} $ 定义为\n$$\nS_j = \\sum_{i=1}^{j} \\lambda_i,\\quad j \\in \\{1,2,3\\},\\quad\nj^\\star = \\max\\{ j \\in \\{0,1,2,3\\} \\,:\\, S_j \\ge 0\\},\\quad S_0 \\equiv 0,\n$$\n和\n$$\nD_{\\mathrm{KY}} =\n\\begin{cases}\n0,  j^\\star = 0, \\\\\nj^\\star + \\dfrac{S_{j^\\star}}{|\\lambda_{j^\\star+1}|},  j^\\star \\in \\{1,2\\}.\n\\end{cases}\n$$\n\n任务：对于下面测试套件中指定的每个 $ \\rho $ 值，沿从 $ (1,1,1) $ 开始的轨道，根据变分方程计算三个Lyapunov指数，然后按上述定义计算相应的Kaplan–Yorke维数 $ D_{\\mathrm{KY}} $。您的程序必须从第一性原理出发，数值逼近定义中所包含的长时间极限，并生成所要求的输出。\n\n为确保任务适定而设定的数值规范：\n- 使用固定的时间步长 $ \\Delta t = 0.01 $ 来演化基础轨道和变分动力学。\n- 在估计渐近量时，舍弃初始瞬态，时长为 $ T_{\\mathrm{trans}} = 50 $ (即 $ 5000 $ 步)。\n- 在瞬态之后，使用持续时间为 $ T_{\\mathrm{acc}} = 250 $ (即 $ 25000 $ 步) 的数据累积区间来估计Lyapunov指数。\n- 不涉及角度；无需角度单位。\n- 没有物理单位；所有量均为无量纲。\n\n测试套件 (不同区域)：\n- 稳定原点：$ \\rho = 0.5 $。\n- 稳定非平凡平衡点：$ \\rho = 20.0 $。\n- 混沌初现附近：$ \\rho = 24.0 $。\n- 经典混沌区域：$ \\rho = 28.0 $。\n- 更强混沌：$ \\rho = 35.0 $。\n- 远混沌区域：$ \\rho = 160.0 $。\n\n答案规格：\n- 对于列表 $ [0.5, 20.0, 24.0, 28.0, 35.0, 160.0] $ 中的每个 $ \\rho $ 值，输出相应的 $ D_{\\mathrm{KY}} $，四舍五入到小数点后三位。\n- 最终输出格式必须是单行文本，包含一个用方括号括起来的逗号分隔列表，结果顺序与测试套件相同。例如：$ [d_1,d_2,d_3,d_4,d_5,d_6] $，其中每个 $ d_k $ 是一个小数点后恰好有三位的小数。", "solution": "所述问题是有效的。这是一个基于动力系统理论和计算物理学既定原则的、定义明确的计算任务。它在科学上是合理的，内容自洽，且没有歧义。Lorenz系统、Lyapunov指数和Kaplan-Yorke维数都是标准的研究课题。我们将提供一个完整的解法。\n\n目标是针对一组给定的控制参数 $\\rho$，计算Lorenz系统的Kaplan-Yorke维数 $D_{\\mathrm{KY}}$。该系统由以下三个耦合常微分方程(ODEs)描述：\n$$\n\\dot{x} = \\sigma (y - x) \\\\\n\\dot{y} = x(\\rho - z) - y \\\\\n\\dot{z} = x y - \\beta z\n$$\n其中参数固定为 $\\sigma = 10$ 和 $\\beta = \\frac{8}{3}$。系统的状态由向量 $\\mathbf{x}(t) = (x(t), y(t), z(t))^{\\mathrm{T}}$ 给出。\n\nKaplan-Yorke维数是系统Lyapunov指数 $\\lambda_1 \\ge \\lambda_2 \\ge \\lambda_3$ 的函数。这些指数表征了状态空间中相邻轨道的平均指数发散或收敛率。它们通过流的线性化来正式定义，该线性化由变分方程描述：\n$$\n\\frac{d}{dt}\\delta\\mathbf{x} = J(\\mathbf{x}(t))\\delta\\mathbf{x}\n$$\n这里，$\\delta\\mathbf{x}$ 是一个无穷小扰动向量，$J(\\mathbf{x})$ 是向量场的雅可比矩阵，由下式给出：\n$$\nJ(x,y,z) =\n\\begin{pmatrix}\n-\\sigma  \\sigma  0 \\\\\n\\rho - z  -1  -x \\\\\ny  x  -\\beta\n\\end{pmatrix}\n$$\nLyapunov指数之和等于雅可比矩阵迹的时间平均值。对于Lorenz系统，迹是恒定的：$\\mathrm{Tr}(J) = -\\sigma - 1 - \\beta = -10 - 1 - 8/3 \\approx -13.67$。这意味着该系统是耗散的，状态空间中任何初始条件集合的体积都会随时间收缩，这是奇异吸引子存在的必要条件。因此，典型轨道的指数之和为负：$S_3 = \\lambda_1 + \\lambda_2 + \\lambda_3  0$。\n\n为了数值计算Lyapunov指数，我们必须同时积分系统的状态方程和变分方程。我们演化一组三个初始正交归一的扰动向量，它们构成矩阵 $\\mathbf{V}(t)$ 的列。初始系统状态为 $\\mathbf{x}(0) = (1, 1, 1)^{\\mathrm{T}}$，初始扰动矩阵为单位矩阵 $\\mathbf{V}(0) = \\mathbf{I}$。状态和扰动根据以下方程在一个时间步长 $\\Delta t = 0.01$ 内演化：\n$$\n\\dot{\\mathbf{x}} = \\mathbf{F}(\\mathbf{x}) \\\\\n\\dot{\\mathbf{V}} = J(\\mathbf{x}(t))\\mathbf{V}(t)\n$$\n$\\mathbf{V}(t)$ 的直接积分在数值上是不稳定的，因为列向量会呈指数增长并与最大指数的方向对齐。为了解决这个问题，在每个时间步结束时都应用了重新正交归一化程序。我们将采用的标准方法是QR分解。\n\n算法流程如下：\n1. 初始化状态 $\\mathbf{x}_0 = (1, 1, 1)^{\\mathrm{T}}$ 和一个正交归一矩阵 $\\mathbf{V}_0 = \\mathbf{I}_{3 \\times 3}$。初始化一个向量 $\\mathbf{L} = (0, 0, 0)^{\\mathrm{T}}$ 来累加缩放因子的对数。\n\n2. 将 $\\mathbf{x}(t)$ 和 $\\mathbf{V}(t)$ 的 $3+9=12$ 个耦合ODEs组成的系统在一个时间步长 $\\Delta t = 0.01$ 上进行积分，得到 $\\mathbf{x}_1$ 和 $\\mathbf{V}'_1$。问题指定了固定的时间步长，但未指定积分方法。一阶欧拉法比较初级；为了获得更好的精度和稳定性，我们使用四阶Runge-Kutta (RK4) 方法。\n\n3. 在该步结束时，对演化后的扰动矩阵进行QR分解：$\\mathbf{V}'_1 = \\mathbf{Q}_1 \\mathbf{R}_1$，其中 $\\mathbf{Q}_1$ 是一个正交矩阵，$\\mathbf{R}_1$ 是一个上三角矩阵。\n\n4. $\\mathbf{R}_1$ 的对角元素，即 $R_{1,11}$、$R_{1,22}$ 和 $R_{1,33}$，代表了扰动向量在时间间隔 $\\Delta t$ 内的增长因子。累加这些对角元素绝对值的对数。下一步的矩阵 $\\mathbf{V}$ 被重置为正交矩阵 $\\mathbf{Q}_1$。为了确保 $\\mathbf{V}$ 保持为右手坐标基，并且对数的参数为正，我们通过将任何负号吸收到 $\\mathbf{Q}$ 的列中来强制 $\\mathbf{R}$ 的对角线为正。\n\n5. 重复步骤2-4，总迭代次数对应于指定的瞬态时间 $T_{\\mathrm{trans}} = 50$ 和累积时间 $T_{\\mathrm{acc}} = 250$。对数和仅在 $T_{\\mathrm{acc}}$ 区间内累积。\n\n6. 仿真结束后，根据累加的和计算Lyapunov指数：\n$$ \\lambda_i = \\frac{1}{T_{\\mathrm{acc}}} L_i = \\frac{1}{T_{\\mathrm{acc}}} \\sum_{k} \\ln |R_{k,ii}| $$\n求和遍历累积周期内的所有步长。QR算法自然地得出指数，只要初始向量具有通用方向，$\\lambda_1$ 就与 $i=1$ 时的 $R_{ii}$ 相关联。\n\n7. 计算出指数 $\\lambda_1, \\lambda_2, \\lambda_3$ 后，使用提供的公式计算Kaplan-Yorke维数 $D_{\\mathrm{KY}}$。令 $S_j = \\sum_{i=1}^j \\lambda_i$ 且 $S_0=0$。找到 $j^\\star = \\max\\{j \\in \\{0, 1, 2, 3\\} : S_j \\ge 0\\}$。由于 $S_3  0$，$j^\\star$ 最多为 $2$。\n   - 如果 $j^\\star=0$ (即 $\\lambda_1  0$), $D_{\\mathrm{KY}} = 0$。这表示一个稳定的不动点。\n   - 如果 $j^\\star=1$ (即 $\\lambda_1 \\ge 0$ 且 $S_2  0$), $D_{\\mathrm{KY}} = 1 + S_1 / |\\lambda_2|$。这通常表示一个极限环。\n   - 如果 $j^\\star=2$ (即 $S_2 \\ge 0$), $D_{\\mathrm{KY}} = 2 + S_2 / |\\lambda_3|$。这表示一个奇异吸引子。\n\n将对测试套件中的每个 $\\rho$ 值执行此过程，并将得到的 $D_{\\mathrm{KY}}$ 报告到小数点后三位。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Kaplan-Yorke dimension for the Lorenz system for various\n    values of the control parameter rho.\n    \"\"\"\n    # System parameters and numerical specifications\n    SIGMA = 10.0\n    BETA = 8.0 / 3.0\n    DT = 0.01\n    T_TRANS = 50.0\n    T_ACC = 250.0\n    N_TRANS = int(T_TRANS / DT)\n    N_ACC = int(T_ACC / DT)\n    \n    # Test suite for the parameter rho\n    test_rhos = [0.5, 20.0, 24.0, 28.0, 35.0, 160.0]\n    results = []\n\n    def lorenz_system_and_variational(full_state, rho):\n        \"\"\"\n        Computes the time derivative of the extended 12-dimensional state vector,\n        which includes the Lorenz system variables (x, y, z) and the 3x3\n        matrix of perturbation vectors V.\n        \"\"\"\n        x, y, z = full_state[:3]\n        V = full_state[3:].reshape((3, 3))\n\n        # Lorenz system ODEs\n        d_xyz = np.array([\n            SIGMA * (y - x),\n            x * (rho - z) - y,\n            x * y - BETA * z\n        ])\n\n        # Jacobian matrix J(x,y,z)\n        J = np.array([\n            [-SIGMA, SIGMA, 0.0],\n            [rho - z, -1.0, -x],\n            [y, x, -BETA]\n        ])\n\n        # Variational equation dV/dt = J * V\n        d_V = J @ V\n        \n        # Return the flattened 12-element derivative vector\n        return np.concatenate((d_xyz, d_V.flatten()))\n\n    def rk4_step(f, y, dt, rho):\n        \"\"\"\n        Performs a single step of the fourth-order Runge-Kutta method.\n        \"\"\"\n        k1 = f(y, rho)\n        k2 = f(y + dt / 2.0 * k1, rho)\n        k3 = f(y + dt / 2.0 * k2, rho)\n        k4 = f(y + dt * k3, rho)\n        return y + dt / 6.0 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    for rho in test_rhos:\n        # Initial conditions for each run\n        # State vector [x, y, z]\n        xyz_state = np.array([1.0, 1.0, 1.0])\n        # Perturbation matrix V, initialized to identity\n        v_state = np.identity(3)\n        # Combined 12-element state vector\n        full_state = np.concatenate((xyz_state, v_state.flatten()))\n        \n        # Accumulator for logarithms of stretching factors\n        lyap_sum = np.zeros(3)\n        \n        total_steps = N_TRANS + N_ACC\n        for step in range(total_steps):\n            # Evolve the combined state by one time step\n            full_state = rk4_step(lorenz_system_and_variational, full_state, DT, rho)\n\n            # Extract the evolved perturbation matrix\n            v_prime = full_state[3:].reshape((3, 3))\n            \n            # Orthonormalize using QR decomposition\n            Q, R = np.linalg.qr(v_prime)\n            \n            # The diagonal of R contains the stretching factors.\n            # To ensure the logarithm is well-defined and the new basis Q\n            # maintains orientation, we force R's diagonal elements to be positive.\n            # Any negative sign is absorbed into the corresponding column of Q.\n            signs = np.sign(np.diag(R))\n            signs[signs == 0] = 1 # Avoid issues with zero on the diagonal\n            Q = Q @ np.diag(signs)\n            R_diag_abs = np.abs(np.diag(R))\n            \n            # Reset the perturbation part of the state to the new orthonormal basis\n            full_state[3:] = Q.flatten()\n            \n            # Accumulate after the transient period\n            if step >= N_TRANS:\n                # Add logarithm of stretching factors to the sum\n                lyap_sum += np.log(R_diag_abs)\n\n        # Calculate the Lyapunov exponents\n        lyap_exponents = lyap_sum / T_ACC\n        \n        # The QR procedure naturally orders the exponents lambda_1 >= lambda_2 >= ...\n        # Sort them to be sure\n        lyap_exponents.sort()\n        lambda3, lambda2, lambda1 = lyap_exponents[0], lyap_exponents[1], lyap_exponents[2]\n\n        # Calculate sums S_j for Kaplan-Yorke dimension formula\n        S1 = lambda1\n        S2 = lambda1 + lambda2\n        \n        # Determine j_star\n        j_star = 0\n        if S1 >= 0:\n            j_star = 1\n            if S2 >= 0:\n                j_star = 2\n        \n        # Calculate Kaplan-Yorke dimension D_KY\n        D_KY = 0.0\n        if j_star == 1:\n            # Avoid division by zero, though unlikely for stable limit cycles\n            if abs(lambda2) > 1e-12:\n                D_KY = 1.0 + S1 / abs(lambda2)\n            else:\n                D_KY = 1.0\n        elif j_star == 2:\n            # Avoid division by zero, though lambda3 is strongly negative in chaos\n            if abs(lambda3) > 1e-12:\n                D_KY = 2.0 + S2 / abs(lambda3)\n            else:\n                D_KY = 2.0\n        \n        results.append(f\"{D_KY:.3f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2443485"}]}