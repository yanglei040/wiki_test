{"hands_on_practices": [{"introduction": "要真正理解浮点数的工作原理，最好的方法莫过于从头开始构建一个简化模型。这个练习将引导你设计一个“玩具”般的8位浮点系统。通过亲手计算其关键属性，你将直接体会指数偏移、尾数表示以及规范化数与非规范化数的不同规则，为理解更复杂的实际标准打下坚实的基础。[@problem_id:3257655]", "problem": "你的任务是定义一个自洽的玩具二进制浮点格式，并利用基本定义推导出关于其规范化数和次规格化数的关键量。\n\n考虑一个具有以下设计的玩具$8$位二进制浮点系统：\n- 该表示法有$1$个符号位、$4$个指数位和$3$个尾数位。\n- 指数使用$7$的偏置值。\n- 当指数字段全为零且尾数非零时，该数是次规格化数（也称非规格化数）；当指数字段全为零且尾数也为零时，该数是带符号的零。\n- 当指数字段全为一时，该编码表示无穷大和非数值（NaN），不在本问题的考虑范围之内。\n- 对于规范化数（指数字段既不全为零也不全为一），其有效数被解释为带有一个隐含的前导$1$，即形式为$1.f_1 f_2 f_3$（以$2$为基数）。对于次规格化数（指数字段全为零且尾数非零），其有效数没有隐含的前导$1$，形式为$0.f_1 f_2 f_3$（以$2$为基数）。\n- 表示的实数值为$(-1)^{s} \\times m \\times 2^{e}$，其中$s$是符号位，$m$是如上定义的有效数，$e$是无偏指数。对于规范化数，无偏指数是存储的指数字段值减去偏置值。对于次规格化数，无偏指数固定为在次规格化数和规范化数范围之间的边界处保持连续性的最小指数。\n\n仅使用这些定义和二进制浮点表示法的第一性原理（在实践中由电气和电子工程师协会（IEEE）754标准化，但在此处适用于上述玩具格式），确定：\n- 最小的正规范化数，记为$N_{\\min}$。\n- 最小的正次规格化数，记为$S_{\\min}$。\n- 可表示的次规格化数（包含正负两种符号，不包括两个带符号的零）的总数。\n\n将$N_{\\min}$和$S_{\\min}$精确表示为$2$的幂，并将次规格化数的数量作为整数给出。以行矩阵$\\big(N_{\\min},\\,S_{\\min},\\,C\\big)$的形式提供最终答案。不要四舍五入。不需要单位。", "solution": "用户提供了一个玩具$8$位二进制浮点系统的规范，并要求确定三个量：最小的正规范化数（$N_{\\min}$）、最小的正次规格化数（$S_{\\min}$）以及次规格化数的总数（$C$）。\n\n该问题是自洽的，并且与IEEE 754等标准所定义的浮点运算原理一致。所有必要的参数都已提供，问题是适定的。因此，该问题是有效的，并且可以推导出解。\n\n该系统由以下参数定义：\n- 总位数：$8$。\n- 符号位（$s$）：$1$。\n- 指数位（$k$）：$4$。\n- 尾数位（$p$）：$3$。\n- 指数偏置值（$B$）：$7$。\n\n浮点数的值$v$由公式$v = (-1)^{s} \\times m \\times 2^{e}$给出，其中$s$是符号位，$m$是有效数，$e$是无偏指数。\n\n首先，我们确定规范化数的存储指数值（$E$）的范围。指数字段有$k=4$位，因此其值范围可以从$0$到$2^4-1 = 15$。问题指出，$E=0$（全零）保留给零和次规格化数，$E=15$（全一）保留给特殊值（无穷大/NaN）。因此，规范化数的存储指数范围是$E \\in [1, 14]$。规范化数的无偏指数$e$计算为$e = E - B$。当偏置值$B=7$时，规范化数的无偏指数范围是：\n- $e_{\\min\\_norm} = 1 - 7 = -6$。\n- $e_{\\max\\_norm} = 14 - 7 = 7$。\n\n**1. 最小的正规范化数（$N_{\\min}$）**\n\n为了找到最小的正规范化数，我们必须满足三个条件：\n- 符号必须为正，因此符号位$s=0$。\n- 有效数$m$必须尽可能小。对于规范化数，有效数的形式为$m = 1.f_1 f_2 f_3$（以$2$为基数），带有一个隐含的前导$1$。当所有尾数位都为零时，即$f_1=0, f_2=0, f_3=0$，其值最小。这得到的有效数为$m_{\\min\\_norm} = 1.000_2 = 1$。\n- 指数$e$必须尽可能小。如上所述，规范化数的最小无偏指数是$e_{\\min\\_norm} = -6$。\n\n综合这些，我们计算$N_{\\min}$：\n$$N_{\\min} = (-1)^0 \\times 1 \\times 2^{-6} = 2^{-6}$$\n\n**2. 最小的正次规格化数（$S_{\\min}$）**\n\n首先，我们必须确定次规格化数的固定无偏指数$e_{sub}$。问题规定，选择该指数是为了在次规格化数和规范化数范围的边界处保持连续性。该边界位于最大的次规格化数$S_{\\max}$和最小的规范化数$N_{\\min}$之间。\n\n$N_{\\min}$的值为$1.000_2 \\times 2^{-6}$。具有此指数的可表示数之间的间距（或ulp，末位单位）由尾数最低有效位的值决定，即$2^{-p} = 2^{-3}$。此指数下的总步长为$2^{-3} \\times 2^{e_{\\min\\_norm}} = 2^{-3} \\times 2^{-6} = 2^{-9}$。\n\n为了实现连续过渡，最大的次规格化数必须比最小的规范化数小一个步长：\n$$S_{\\max} = N_{\\min} - (\\text{step size}) = 2^{-6} - 2^{-9} = 2^{-6}(1 - 2^{-3}) = 2^{-6}(1 - \\frac{1}{8}) = \\frac{7}{8} \\times 2^{-6}$$\n\n现在，我们使用次规格化数的定义来表示$S_{\\max}$。对于次规格化数，有效数是$m = 0.f_1 f_2 f_3$（以$2$为基数）。当所有尾数位都为$1$时，即$f_1=1, f_2=1, f_3=1$，出现最大的次规格化有效数。\n$$m_{\\max\\_sub} = 0.111_2 = \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{8} = \\frac{7}{8}$$\n最大的次规格化数的值是$S_{\\max} = m_{\\max\\_sub} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{e_{sub}}$。\n\n令$S_{\\max}$的两个表达式相等，我们可以解出$e_{sub}$：\n$$\\frac{7}{8} \\times 2^{e_{sub}} = \\frac{7}{8} \\times 2^{-6}$$\n$$\\implies e_{sub} = -6$$\n这证实了次规格化指数为$e_{sub} = 1 - B = 1 - 7 = -6$的标准约定。\n\n现在我们可以找到最小的正次规格化数$S_{\\min}$。\n- 符号必须为正，所以$s=0$。\n- 指数是固定的次规格化指数，$e_{sub} = -6$。\n- 有效数$m = 0.f_1 f_2 f_3$必须是最小的可能*非零*值。这发生在只有最低有效位为$1$的时候：$f_1=0, f_2=0, f_3=1$。\n$$m_{\\min\\_sub} = 0.001_2 = 0 \\times 2^{-1} + 0 \\times 2^{-2} + 1 \\times 2^{-3} = 2^{-3}$$\n\n综合这些，我们计算$S_{\\min}$：\n$$S_{\\min} = (-1)^0 \\times (2^{-3}) \\times 2^{-6} = 2^{-9}$$\n\n**3. 可表示的次规格化数的总数（$C$）**\n\n如果一个数的指数字段全为零且其尾数字段非零，则该数为次规格化数。我们需要计算所有这种可能的位模式。\n- 符号位（$s$）：$1$位，可以是$0$或$1$。这提供了$2$种选择。\n- 指数字段（$E$）：$4$位，必须是$0000_2$。这提供了$1$种选择。\n- 尾数字段（$f$）：$3$位，可以是除全零（$000_2$）之外的任何模式。$3$位的模式总数为$2^3 = 8$。非零模式的数量是$2^3 - 1 = 7$。\n\n总数$C$是每个字段选择数的乘积：\n$$C = (\\text{choices for sign}) \\times (\\text{choices for fraction}) = 2 \\times (2^3 - 1) = 2 \\times 7 = 14$$\n\n这三个量是$N_{\\min} = 2^{-6}$，$S_{\\min} = 2^{-9}$，以及$C = 14$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2^{-6}  2^{-9}  14\n\\end{pmatrix}\n}\n$$", "id": "3257655"}, {"introduction": "非规范化数并不仅仅是静态的好奇之物，它们在保持数值精度方面扮演着动态的角色，其核心功能是实现“渐进下溢”。本练习将探讨两个微小的非规范化数之和是否可能“爬出”非规范化范围，成为一个规范化数。通过构建一个具体的例子，你将理解这一机制是如何平滑地填补从最小规范化数到零之间的鸿沟的。[@problem_id:3257753]", "problem": "考虑电气和电子工程师协会 (IEEE) 754 标准的半精度二进制浮点系统 (binary16)，该系统使用基数 $2$、$1$ 个符号位、$5$ 个指数位和 $10$ 个小数（尾数）位。指数偏移量为 $15$。在此系统中，指数域非零的数为规范化数，而指数域为 $0$ 且小数部分非零的数为非规范化数。\n\n回答以下问题：两个正的非规范化数 $x$ 和 $y$ 的和是否可能超出非规范化数的范围，并能在此系统中表示为一个规范化数？通过将 $x$ 取为 binary16 中最大的正非规范化数，并将 $y$ 取为最小的正非规范化数，构造一个明确的例子，并计算 $x + y$ 的精确实数值。将你的最终答案表示为以 $2$ 为底、整数为指数的单一幂。无需舍入。", "solution": "该问题是有效的，因为它科学地基于IEEE 754浮点算术标准，问题表述清晰、客观，并包含了获得唯一解所需的所有信息。\n\n首先，我们分析指定的 IEEE 754 半精度二进制浮点系统 (binary16) 中数字的结构。该系统使用基数 $B=2$ 、$1$ 个符号位（$s$）、$5$ 个指数位（构成指数域 $e$）和 $10$ 个小数位（构成小数域 $f$）。指数偏移量为 $15$。\n\n此系统中的一个数 $v$ 由公式 $v = (-1)^s \\times m \\times 2^E$ 表示，其中 $m$ 是尾数，$E$ 是真实指数。$m$ 和 $E$ 的值取决于指数域 $e$。\n\n对于非规范化（或非正规）数，指数域为 $e = 0$。真实指数固定为其最小值，$E = 1 - \\text{bias} = 1 - 15 = -14$。尾数有一个隐含的前导位 $0$，由 $m = (0.f)_2 = \\sum_{i=1}^{10} f_i 2^{-i}$ 给出，其中 $f_i$ 是小数域 $f$ 的第 $i$ 位。一个数要成为非规范化数，小数域 $f$ 必须非零。\n因此，一个正的非规范化数的形式为 $v_{sub} = (\\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{-14}$。\n\n对于规范化数，指数域 $e$ 的范围是 $1 \\le e \\le 30$。真实指数为 $E = e - \\text{bias} = e - 15$。尾数有一个隐含的前导位 $1$，由 $m = (1.f)_2 = 1 + \\sum_{i=1}^{10} f_i 2^{-i}$ 给出。\n因此，一个正的规范化数的形式为 $v_{norm} = (1 + \\sum_{i=1}^{10} f_i 2^{-i}) \\times 2^{e-15}$。\n\n问题询问两个正的非规范化数的和是否能产生一个规范化数。我们按照要求构造一个明确的例子来研究这个问题。\n\n令 $x$ 为最大的正非规范化数。这发生在小数域 $f$ 的所有位都为 $1$ 的时候。\n小数域为 $f = 1111111111_2$。\n尾数为 $m_x = (0.1111111111)_2 = \\sum_{i=1}^{10} 2^{-i}$。这是一个几何级数，其和为 $2^{-1} \\frac{1-(2^{-1})^{10}}{1-2^{-1}} = \\frac{1}{2} \\frac{1-2^{-10}}{1/2} = 1 - 2^{-10}$。\n指数为 $E = -14$。\n因此，$x$ 的值为：\n$$x = (1 - 2^{-10}) \\times 2^{-14}$$\n\n令 $y$ 为最小的正非规范化数。这发生在小数域 $f$ 取最小非零值时，即 $f = 0000000001_2$。\n尾数为 $m_y = (0.0000000001)_2 = 2^{-10}$。\n指数为 $E = -14$。\n因此，$y$ 的值为：\n$$y = 2^{-10} \\times 2^{-14} = 2^{-24}$$\n\n现在，我们计算和 $x+y$：\n$$x + y = \\left( (1 - 2^{-10}) \\times 2^{-14} \\right) + \\left( 2^{-10} \\times 2^{-14} \\right)$$\n提出公因子 $2^{-14}$：\n$$x + y = (1 - 2^{-10} + 2^{-10}) \\times 2^{-14}$$\n$$x + y = 1 \\times 2^{-14} = 2^{-14}$$\n\n和为 $2^{-14}$。我们现在必须确定这个数是在非规范化范围内还是在规范化范围内。\n非规范化数的最大值为 $x = (1 - 2^{-10}) \\times 2^{-14}$，它严格小于 $2^{-14}$。\n由于 $x+y = 2^{-14}$，这个和大于最大的非规范化数，因此它必定位于非规范化范围之外。\n\n我们来检查 $2^{-14}$ 是否可以在 binary16 系统中表示为规范化数。\n一个规范化数的形式为 $(1.f)_2 \\times 2^{e-15}$。我们想找到 $f$ 和 $e$ 使得这个表达式等于 $2^{-14}$。\n$$(1.f)_2 \\times 2^{e-15} = 2^{-14}$$\n我们可以通过将尾数设置为 $(1.0)_2 = 1$ 并将指数设置为 $-14$ 来实现这一点。\n对于为 $1$ 的尾数，小数域 $f$ 必须全为零：$f = 0000000000_2$。\n对于真实指数 $E = -14$，我们需要 $e-15 = -14$，这意味着 $e=1$。\n指数域 $e=1$ 是规范化数的有效值（范围为 $1 \\le e \\le 30$）。\n因此，$2^{-14}$ 是 binary16 系统中最小的正规范化数。它的表示为 $s=0$，$e=00001_2$，$f=0000000000_2$。\n\n这明确地证明了两个正的非规范化数 $x$ 和 $y$ 的和可以超出非规范化数的范围，并可以表示为一个规范化数。所选 $x$ 和 $y$ 的和的精确实数值是 $2^{-14}$。\n问题要求答案表示为以 $2$ 为底、整数为指数的单一幂，即 $2^{-14}$。", "answer": "$$\\boxed{2^{-14}}$$", "id": "3257753"}, {"introduction": "从理论走向实践，理解浮点数在位级别的表示和处理方式至关重要。这个编程练习要求你在不使用任何内置浮点函数的情况下，解码一个数字的32位整数表示。通过仅使用位运算来实现分类器，你将对计算机如何区分规范化数、非规范化数、零以及其他特殊值获得深刻而实际的理解。[@problem_id:3257791]", "problem": "给定一个二进制浮点数的无符号$32$位整数表示，该浮点数遵循电气和电子工程师协会（IEEE）浮点算术标准（IEEE $754$）的binary$32$格式。您的任务是编写一个程序，在不使用任何浮点运算的情况下，判断给定的每个$32$位模式表示的是规范化有限数、次规格化（非规格化）有限数、零、无穷大还是非数（NaN），并为每种分类输出一个整数代码。\n\n使用的基本依据：\n- IEEE $754$ binary$32$格式使用$32$个比特来编码一个实数值，其划分如下：一个符号位$s$（最高有效位）、一个$8$位指数场$e$和一个$23$位小数部分（也称为有效数位场）$f$。存储的指数$e$是一个在$\\{0,1,\\dots,255\\}$范围内的无符号整数，小数部分$f$是一个在$\\{0,1,\\dots,2^{23}-1\\}$范围内的无符号整数。指数偏移量为$127$。\n- 对于规范化有限数，编码值（如果解释为实数）的形式为$(-1)^s \\cdot (1.f)_2 \\cdot 2^{E}$，其中无偏指数$E = e - 127$，且$1 \\le e \\le 254$。\n- 对于次规格化有限数，编码值的形式为$(-1)^s \\cdot (0.f)_2 \\cdot 2^{1-127}$，其中$e = 0$且$f \\ne 0$。\n- 对于零，$e = 0$且$f = 0$（$+0$和$-0$均被视为零）。\n- 对于无穷大，$e = 255$且$f = 0$（$+\\infty$和$-\\infty$均被视为无穷大）。\n- 对于非数（NaN），$e = 255$且$f \\ne 0$。\n\n您的程序必须：\n- 将每个输入视为一个无符号$32$位整数$x \\in \\{0,1,\\dots,2^{32}-1\\}$，并仅通过整数和位运算对其进行分类。\n- 使用对$x$的位运算来提取字段$s$、$e$和$f$。\n- 为每个输入输出一个分类代码$c \\in \\{0,1,2,3,4\\}$，定义如下：\n  - $0$：零，\n  - $1$：次规格化有限数，\n  - $2$：规范化有限数，\n  - $3$：无穷大，\n  - $4$：非数（NaN）。\n\n测试套件：\n精确使用以下测试用例（每个都是一个为了可读性而以十六进制书写的无符号$32$位整数）：\n- $x_1 = \\texttt{0x00000000}$,\n- $x_2 = \\texttt{0x80000000}$,\n- $x_3 = \\texttt{0x00000001}$,\n- $x_4 = \\texttt{0x00012345}$,\n- $x_5 = \\texttt{0x00800000}$,\n- $x_6 = \\texttt{0x3F800000}$,\n- $x_7 = \\texttt{0x7F7FFFFF}$,\n- $x_8 = \\texttt{0x7F800000}$,\n- $x_9 = \\texttt{0xFF800000}$,\n- $x_{10} = \\texttt{0x7FC00000}$。\n\n最终输出格式：\n- 您的程序应生成单行输出，按顺序包含$10$个测试用例的分类代码，形式为方括号内以逗号分隔的列表，例如：$[c_1,c_2,\\dots,c_{10}]$。\n- 每个$c_i$必须是如上定义的整数。", "solution": "该问题是有效的，因为它定义明确，科学上基于IEEE $754$标准，并且是自包含的。任务是仅使用整数和位运算，将一个给定的、表示单精度浮点数的$32$位无符号整数分类为五种类别之一：零、次规格化数、规范化数、无穷大或非数（NaN）。\n\n核心原理是根据IEEE $754$ binary$32$标准的定义，将$32$位整数$x$分解为其三个组成字段：符号位$s$、8位指数场$e$和23位小数部分场$f$。数字的分类完全由字段$e$和$f$的值确定。\n\n一个$32$位整数$x$的结构如下，从最高有效位（MSB）到最低有效位（LSB）：\n- 比特$31$：符号位$s$（$1$位）\n- 比特$30-23$：指数场$e$（$8$位）\n- 比特$22-0$：小数部分场$f$（$23$位）\n\n分类算法分两个主要步骤进行：字段提取和逻辑规则应用。\n\n**第一步：使用位运算提取字段**\n\n我们可以使用与特定掩码的位与（AND）运算，然后进行位右移，从整数$x$中分离出指数场和小数部分场。\n\n1.  **指数场（$e$）提取：**\n    指数场占据比特$23$到$30$。为了分离出这$8$个比特，我们使用一个在这些位置为$1$、其他位置为$0$的位掩码。这个掩码的十六进制表示为`0x7F800000`。\n    首先，我们对输入整数`x`和指数掩码执行位与运算。\n    该操作会将除指数位之外的所有位都置零。结果包含向左移动了$23$个位置的指数值。为了获得$e$的实际$8$位值，我们必须执行$23$位的逻辑右移：\n    `e = (x  0x7F800000) >> 23`\n    $e$的结果值将是一个在$\\{0, 1, \\dots, 255\\}$范围内的整数。\n\n2.  **小数部分场（$f$）提取：**\n    小数部分场占据了低$23$位（比特$0$到$22$）。用于分离该字段的掩码在这些位置为$1$、其他位置为$0$。这个掩码的十六进制表示为`0x007FFFFF`。\n    我们对输入整数`x`和小数部分掩码执行位与运算。由于该字段已经与最低有效位对齐，因此不需要移位。\n    `f = x  0x007FFFFF`\n    $f$的结果值将是一个在$\\{0, 1, \\dots, 2^{23}-1\\}$范围内的整数。\n\n对于这个分类问题，符号位$s$不是必需的，因为规则仅取决于$e$和$f$。例如，$+0$和$-0$都被分类为零。\n\n**第二步：基于提取的字段进行分类**\n\n一旦获得了$e$和$f$的值，我们就可以应用问题描述中提供的分类规则。这些规则构成了一组互斥条件，涵盖了$e$和$f$的所有可能组合。该逻辑实现为一系列条件检查。一个稳健的方法是首先测试特殊的指数值（$e=0$和$e=255$）。\n\n令$E_{max} = 2^8 - 1 = 255$。\n\n- **情况1：$e = E_{max} = 255_d = \\texttt{0xFF}_{h}$**\n  这种情况对应于无穷大和非数（NaNs）。\n  - 如果$f = 0$，则该数为**无穷大**。分类代码为$3$。这对正无穷大（`0x7F800000`）和负无穷大（`0xFF800000`）都成立。\n  - 如果$f \\ne 0$，则该数为**非数（NaN）**。分类代码为$4$。\n\n- **情况2：$e = 0$**\n  这种情况对应于零和次规格化（非规格化）数。\n  - 如果$f = 0$，则该数为**零**。分类代码为$0$。这对正零（`0x00000000`）和负零（`0x80000000`）都成立。\n  - 如果$f \\ne 0$，则该数为**次规格化有限数**。分类代码为$1$。\n\n- **情况3：$1 \\le e \\le 254$**\n  如果指数$e$不为$0$也不为$255$，根据定义，该数为**规范化有限数**。分类代码为$2$。\n\n这套规则为根据IEEE $754$标准对任何$32$位模式进行分类提供了一个完整的决策过程。将此逻辑应用于提供的测试用例，可以得出最终的分类代码序列。\n\n例如，让我们分析$x_4 = \\texttt{0x00012345}$：\n- $x = \\texttt{0x00012345}$\n- `e = (0x00012345  0x7F800000) >> 23 = 0 >> 23 = 0`。\n- `f = 0x00012345  0x007FFFFF = 0x00012345`。\n- 因为$e=0$且$f \\ne 0$，所以该数为次规格化数，其代码为$1$。\n\n再举一个例子，让我们分析$x_8 = \\texttt{0x7F800000}$：\n- $x = \\texttt{0x7F800000}$\n- `e = (0x7F800000  0x7F800000) >> 23`。指数位的二进制模式是`11111111`，十进制为$255$。所以，$e=255$。\n- `f = 0x7F800000  0x007FFFFF = 0`。\n- 因为$e=255$且$f=0$，所以该数为无穷大，其代码为$3$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Classifies 32-bit unsigned integers representing IEEE 754 single-precision\n    floating-point numbers using only bitwise integer operations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement as unsigned 32-bit integers.\n    test_cases = [\n        0x00000000,  # x1: +0\n        0x80000000,  # x2: -0\n        0x00000001,  # x3: smallest positive subnormal\n        0x00012345,  # x4: a subnormal number\n        0x00800000,  # x5: smallest positive normalized\n        0x3F800000,  # x6: 1.0\n        0x7F7FFFFF,  # x7: largest normalized\n        0x7F800000,  # x8: +infinity\n        0xFF800000,  # x9: -infinity\n        0x7FC00000,  # x10: a quiet NaN\n    ]\n\n    results = []\n    \n    # Constants for bitwise field extraction based on the IEEE 754 binary32 format.\n    # Exponent field: bits 23-30\n    EXP_MASK = np.uint32(0x7F800000)\n    # Fraction/significand field: bits 0-22\n    FRAC_MASK = np.uint32(0x007FFFFF)\n    \n    # The maximum value for the 8-bit exponent field (all bits set to 1).\n    EXP_MAX = np.uint32(0xFF) # 255 in decimal\n\n    for x_int in test_cases:\n        # We work with numpy.uint32 to be explicit about the 32-bit nature of the data,\n        # aligning with common practices in numerical computing.\n        x = np.uint32(x_int)\n        \n        # Extract the 8-bit exponent field by masking and right-shifting.\n        exp_field = (x  EXP_MASK)  np.uint32(23)\n        \n        # Extract the 23-bit fraction field by masking.\n        frac_field = x  FRAC_MASK\n        \n        # Apply the classification rules defined in the problem statement.\n        \n        # Case 1: Exponent bits are all 1s (e = 255)\n        # This corresponds to infinities and NaNs.\n        if exp_field == EXP_MAX:\n            if frac_field == 0:\n                # Code 3: infinity\n                results.append(3)\n            else:\n                # Code 4: not-a-number (NaN)\n                results.append(4)\n        \n        # Case 2: Exponent bits are all 0s (e = 0)\n        # This corresponds to zeros and subnormal numbers.\n        elif exp_field == 0:\n            if frac_field == 0:\n                # Code 0: zero\n                results.append(0)\n            else:\n                # Code 1: subnormal (denormalized)\n                results.append(1)\n        \n        # Case 3: Exponent is in the range [1, 254]\n        # This corresponds to normalized numbers.\n        else:\n            # Code 2: normalized\n            results.append(2)\n\n    # Format the final output as a comma-separated list in brackets.\n    # The problem asks for the output format: [c1,c2,...,c10]\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3257791"}]}