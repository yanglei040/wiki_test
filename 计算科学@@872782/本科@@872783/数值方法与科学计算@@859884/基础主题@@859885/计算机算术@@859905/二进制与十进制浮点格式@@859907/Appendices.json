{"hands_on_practices": [{"introduction": "要想真正掌握浮点数，理解其内部结构至关重要。第一个练习提供了一个直接的动手实践机会，让您根据 IEEE 754 标准的定义，从原始的二进制表示中解码一个数字 [@problem_id:1948832]。通过手动从符号、指数和尾数域计算其数值，您将巩固对计算机如何存储和解释这些基本数值类型的理解。", "problem": "在一个32位微处理器架构中，一个浮点单元寄存器包含十六进制值 $0xC1E80000$。该值需要根据电气与电子工程师协会（IEEE）754单精度浮点数标准进行解释。\n\n32位单精度格式的结构如下：\n- 一个1位的符号字段（S），位于第31位（最高有效位）。\n- 一个8位的偏置指数字段（E），位于第30位至第23位。\n- 一个23位的小数字段（F），位于第22位至第0位。\n\n对于一个规格化数（其指数字段不全为0也不全为1），其十进制值由公式 $N = (-1)^S \\times (1.F)_2 \\times 2^{(E - \\text{bias})}$ 给出，其中 $(1.F)_2$ 表示隐含的前导1后跟小数字段的位，并被解释为一个二进制数。单精度的指数偏移量为127。\n\n确定由位模式 $0xC1E80000$ 所表示的数的十进制值。", "solution": "根据IEEE 754单精度标准，字段分别为：符号位 $S$（第31位）、指数字段 $E$（第30位至第23位）和小数字段 $F$（第22位至第0位）。对于一个规格化数，其值为 $N = (-1)^{S} \\times (1.F)_{2} \\times 2^{(E - 127)}$。\n\n十六进制值 $0x\\text{C1E80000}$ 的二进制表示分组为 $1100\\,0001\\,1110\\,1000\\,0000\\,0000\\,0000\\,0000$。符号位是 $S = 1$（表示负数）。指数字段的位（第30位至第23位）是 $(10000011)_{2}$，所以\n$$\nE = 1 \\cdot 2^{7} + 0 \\cdot 2^{6} + \\cdots + 0 \\cdot 2^{2} + 1 \\cdot 2^{1} + 1 \\cdot 2^{0} = 128 + 2 + 1 = 131.\n$$\n因为 $E \\neq 0$ 且 $E \\neq 255$，所以该数是规格化的，无偏指数为\n$$\ne = E - 127 = 131 - 127 = 4.\n$$\n小数字段 $F$ 的前四位是 $1101$，对应的值为\n$$\n(1.F)_{2} = 1 + 1 \\cdot 2^{-1} + 1 \\cdot 2^{-2} + 0 \\cdot 2^{-3} + 1 \\cdot 2^{-4} = 1 + \\frac{1}{2} + \\frac{1}{4} + \\frac{1}{16} = \\frac{16+8+4+1}{16} = \\frac{29}{16}.\n$$\n因此，所表示的值为\n$$\nN = (-1)^{1} \\times \\frac{29}{16} \\times 2^{4} = - \\frac{29}{16} \\times 16 = -29.\n$$", "answer": "$$\\boxed{-29}$$", "id": "1948832"}, {"introduction": "浮点格式的精度是有限的，这意味着并非所有数字都能被精确表示。这个练习将探讨这一局限性的一个重要后果：要求您找出单精度浮点数无法精确表示的最小正整数 [@problem_id:3210700]。通过这个实践，您将加深对数值精度以及可表示数之间“间隙”的直观理解。", "problem": "一个仿真系统以电气与电子工程师协会 (IEEE) 754 单精度二进制浮点格式（通常称为 binary32）记录非负整数事件计数。一个 binary32 数使用 $1$ 个符号位、一个偏置为 $127$ 的 $8$ 位指数场和一个 $23$ 位的尾数场；规格化值在有效数中有一个隐含的前导 $1$，从而产生 $24$ 位的精度。仅使用规格化二进制浮点表示的核心定义和关于二进制展开的第一性原理推理，确定不能在 binary32 中精确表示的最小正整数 $n$。然后，令 $x$ 表示严格大于 $n$ 的最小可由 binary32 表示的实数；将间隙 $g$ 定义为 $g = x - n$。通过分析在 $n$ 的量级上可表示值的间距，从第一性原理计算 $g$。请提供 $n$ 和 $g$ 的精确值作为最终答案。无需四舍五入，不涉及单位。", "solution": "本题要求我们确定不能用 IEEE 754 单精度 (binary32) 格式精确表示的最小正整数 $n$，然后计算 $n$ 与下一个更大的可表示数之间的间隙 $g$。此分析将基于 binary32 浮点数的结构，从第一性原理进行。\n\n在 binary32 格式中，一个数表示为 $v = (-1)^s \\times M \\times 2^E$，其中 $s$ 是符号位，$M$ 是有效数（significand），$E$ 是指数。题目说明我们处理的是非负整数，所以符号位 $s$ 为 $0$。\n\nbinary32 格式规定了一个 $8$ 位的指数场和一个 $23$ 位的小数场。对于规格化数，有效数 $M$ 有一个隐含的前导 $1$ 位。其形式为 $M = (1.f)_{2}$，其中 $f$ 是 $23$ 位的小数部分。这意味着有效数由 $1$ 个整数位和 $23$ 个小数位组成，总精度为 $p=24$ 位。小数部分 $f$ 可以写成一个和：\n$$f = \\sum_{i=1}^{23} d_i 2^{-i}$$\n其中每个 $d_i$ 为 $0$ 或 $1$。因此，有效数 $M = 1 + f$。指数 $E$ 是由 $8$ 位指数场的值 $e$ 使用偏置 $127$ 计算得出的，即 $E = e - 127$。对于规格化数，$1 \\le e \\le 254$，这对应于指数范围 $-126 \\le E \\le 127$。\n\n一个整数是可精确表示的，如果它能使用允许的小数部分 $f$ 和指数 $E$ 写成 $v = (1.f)_2 \\times 2^E$ 的形式。这当且仅当该整数的二进制表示可以用不超过 $24$ 个有效位来表达。\n\n让我们检查整数，找出第一个不能表示的最小整数。\n任何整数 $I$ 都可以用二进制写成 $(b_k b_{k-1} \\dots b_1 b_0)_2$。为了将其表示为规格化浮点形式，我们将其写为 $(1.b_{k-1} \\dots b_0)_2 \\times 2^k$。有效数是 $(1.b_{k-1} \\dots b_0)_2$。小数部分有 $k$ 位。为了能在 binary32 中表示，小数部分的位数必须最多为 $23$。这个条件是 $k \\le 23$。整数 $I$ 的总有效位数为 $k+1$。所以，如果 $k+1 \\le 24$，该整数是可表示的。\n\n这意味着所有可以用最多 $24$ 个有效位写出的整数都是可以精确表示的。最大的这类整数是其二进制表示由 $24$ 个 $1$ 组成：\n$$ 2^{24} - 1 = \\sum_{i=0}^{23} 2^i = (11\\dots1)_{2} \\quad (24 \\text{ 个 } 1) $$\n这个数可以写成 $(1.11\\dots1)_2 \\times 2^{23}$（小数点后有 $23$ 个 $1$），这是完全可以表示的，因为小数部分符合可用的 $23$ 位。\n\n现在，考虑下一个整数 $2^{24}$。在二进制中，这是一个 $1$ 后面跟着 $24$ 个零：$(100\\dots0)_{2}$。这个数在其标准整数表示中有 $25$ 位。然而，在科学记数法中，它是 $(1.0)_2 \\times 2^{24}$。\n- 有效数是 $M=1.0$。小数部分是 $f=0$。这是可以表示的。\n- 指数是 $E=24$。编码后的指数将是 $e = E + 127 = 24 + 127 = 151$。因为 $1 \\le 151 \\le 254$，所以这是一个规格化数的有效指数。\n因此，整数 $2^{24}$ 在 binary32 中是可精确表示的。\n\n因此，从 $1$ 到 $2^{24}$ 的所有整数都是可精确表示的。\n\n我们来考察下一个整数，$n = 2^{24} + 1$。它的值是 $16,777,216 + 1 = 16,777,217$。$n$ 的二进制表示是：\n$$ n = (1000000000000000000000001)_2 $$\n这由位置 $24$ 上的一个 $1$ 和位置 $0$ 上的一个 $1$ 组成。为了将其表示为规格化浮点形式，我们必须将其写为：\n$$ n = (1.000000000000000000000001)_2 \\times 2^{24} $$\n所需的有效数是 $M = 1 + 2^{-24}$。所需的小数部分是 $f = 2^{-24}$。\nbinary32 格式的 $23$ 位小数场只能表示 $\\sum_{i=1}^{23} d_i 2^{-i}$ 形式的小数。可以形成的最小非零项是 $2^{-23}$。不可能形成 $2^{-24}$ 这一项。因此，有效数 $1+2^{-24}$ 无法被创建，整数 $n=2^{24}+1$ 不能被精确表示。这使其成为不能被精确表示的最小正整数。\n所以，$n = 2^{24} + 1 = 16,777,217$。\n\n接下来，我们必须找到严格大于 $n$ 的最小可由 binary32 表示的实数 $x$，并计算间隙 $g=x-n$。\n量级接近 $n = 2^{24}+1$ 的数落在指数为 $E=24$ 的范围内。对于区间 $[2^{24}, 2^{25})$ 中的任何数 $v$，其指数为 $E=24$。\n在此范围内的可表示数的形式为：\n$$ v = (1.f_1f_2\\dots f_{23})_2 \\times 2^{24} $$\n小数部分的值 $f = \\sum_{i=1}^{23} d_i 2^{-i}$ 可以表示为 $k \\cdot 2^{-23}$，其中 $k$ 是一个整数且 $0 \\le k \\le 2^{23}-1$。\n将此代入 $v$ 的表达式中：\n$$ v_k = (1 + k \\cdot 2^{-23}) \\times 2^{24} = 2^{24} + k \\cdot 2^{24-23} = 2^{24} + 2k $$\n这表明对于整数 $k \\ge 0$，在此量级上的可表示数为 $2^{24}$、$2^{24}+2$、$2^{24}+4$ 等等。连续可表示数之间的间距为 $2$。这个间距被称为该范围的“末位单位”(Unit in the Last Place, ULP)。\n\n我们不可表示的整数是 $n = 2^{24}+1$。我们可以将其置于两个连续的可表示数之间：\n$$ 2^{24}  2^{24}+1  2^{24}+2 $$\n题目要求的是 $x$，即严格大于 $n$ 的最小可由 binary32 表示的实数。从上面的不等式可知，这个数必须是 $x = 2^{24}+2$。\n\n最后，我们计算由 $g = x - n$ 定义的间隙 $g$：\n$$ g = (2^{24}+2) - (2^{24}+1) = 1 $$\n\n这两个值是 $n=2^{24}+1 = 16,777,217$ 和 $g=1$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 16777217  1 \\end{pmatrix}}\n$$", "id": "3210700"}, {"introduction": "即使公式在代数上完全等价，算法的选择也可能对数值精度产生巨大影响。这个编程练习通过比较计算 $x^2 - y^2$ 的两种方法，展示了经典的“灾难性相消”问题 [@problem_id:3210660]。通过亲手实现和测试这两种方法，您将直观地看到一个简单的代数重构如何能避免有效数字的灾难性损失，这是科学计算中至关重要的一课。", "problem": "要求您编写一个完整的、可运行的程序，该程序比较两种代数上等价的公式，用于计算几乎相等的输入的平方差。比较将在两种浮点格式下进行：一种二进制格式和一种十进制格式。该代数恒等式为 $x^2 - y^2 = (x-y)(x+y)$。需要比较的两种公式是：朴素公式 $x^2 - y^2$ 和因式分解公式 $(x-y)(x+y)$。您的程序必须以两种格式计算这两种公式，测量它们相对于高精度参考值的数值误差，并确定哪种公式能更好地保留有效性。二进制格式应使用电气和电子工程师协会（IEEE）$754$标准的原生双精度浮点运算（通常称为 binary64）来实现，十进制格式应使用精度为16位有效数字、舍入模式为“舍入到最近，偶数优先”（round-to-nearest, ties-to-even）的十进制浮点运算来实现。\n\n推理和设计的基本依据：\n- 浮点表示通过一组有限的可表示值来近似实数。在 IEEE $754$ 二进制格式中，值被编码为符号、二进制指数和二进制有效数。在十进制浮点中，值被编码为符号、十进制指数和十进制有效数。\n- 每种浮点格式都根据一种舍入模式将结果舍入到最近的可表示值。我们将对两种格式都使用“舍入到最近，偶数优先”。\n- 当两个几乎相等的数在有限精度下相减时，会发生相消抵消（subtractive cancellation），导致结果产生巨大的相对误差。代数重构可以减轻或加剧抵消，具体取决于计算了哪些中间量。\n\n测量定义：\n- 设 $x$ 和 $y$ 以十进制字符串形式给出；设 $t = x^2 - y^2$ 是在高精度十进制算术中计算出的高精度参考值，该算术相对于 binary64 和16位十进制算术能够充分减少舍入效应。\n- 对于一个计算结果 $r$（无论采用哪种格式和公式），定义缩放相对误差\n$$\nE(r; x, y) = \\frac{|r - t|}{\\max\\{ |t|, \\, S \\}}, \\quad \\text{其中} \\quad S = \\left(\\max\\{ |x|, |y| \\}\\right)^2.\n$$\n当 $t = 0$ 时，此定义回退到由自然量级 $S$ 缩放的绝对误差，从而避免了除以零，同时产生一个无量纲的指标。较小的 $E$ 表示更好地保留了有效性。\n\n您的程序必须执行的任务：\n1. 从十进制字符串中解析每个测试用例 $(x, y)$。\n2. 使用足够高精度（至少100个十进制位）和“舍入到最近，偶数优先”的十进制算术，计算高精度参考值 $t = x^2 - y^2$。\n3. 在 IEEE $754$ binary64 中：\n   - 将 $x$ 和 $y$ 转换为 binary64。\n   - 计算朴素结果 $r_{\\mathrm{bn}} = x^2 - y^2$。\n   - 计算因式分解结果 $r_{\\mathrm{bf}} = (x-y)(x+y)$。\n   - 使用上述定义的高精度 $t$ 和缩放因子 $S$ 计算 $E(r_{\\mathrm{bn}}; x, y)$ 和 $E(r_{\\mathrm{bf}}; x, y)$。\n   - 通过比较 $E(r_{\\mathrm{bf}}; x, y)$ 和 $E(r_{\\mathrm{bn}}; x, y)$ 来确定在 binary64 中哪种更好。\n4. 在具有16位有效数字和“舍入到最近，偶数优先”模式的十进制浮点运算中：\n   - 将 $x$ 和 $y$ 量化到十进制16位上下文中，然后在该上下文中执行算术运算。\n   - 计算朴素结果 $r_{\\mathrm{dn}} = x^2 - y^2$。\n   - 计算因式分解结果 $r_{\\mathrm{df}} = (x-y)(x+y)$。\n   - 使用相同的高精度 $t$ 和缩放因子 $S$ 按上述方法计算 $E(r_{\\mathrm{dn}}; x, y)$ 和 $E(r_{\\mathrm{df}}; x, y)$。\n   - 通过比较 $E(r_{\\mathrm{df}}; x, y)$ 和 $E(r_{\\mathrm{dn}}; x, y)$ 来确定在十进制中哪种更好。\n\n测试套件：\n使用以下六对以十进制字符串形式提供的 $(x,y)$，它们涵盖了典型、边界和边缘情况，包括接近抵消、完全相等、大数值操作数、小数值操作数和异号情况：\n- 情况 A（1 附近的相近值）：$x = \\text{\"1.0000001\"}$, $y = \\text{\"0.9999999\"}$。\n- 情况 B（非常接近，非对称）：$x = \\text{\"1.0000001\"}$, $y = \\text{\"1.0000000\"}$。\n- 情况 C（非常大的、接近相等的整数）：$x = \\text{\"10000000000000001\"}$, $y = \\text{\"9999999999999999\"}$。\n- 情况 D（非常小的、接近相等的值）：$x = \\text{\"1.0000001e-16\"}$, $y = \\text{\"9.999999e-17\"}$。\n- 情况 E（异号，大小接近相等）：$x = \\text{\"10000000000000001\"}$, $y = \\text{\"-9999999999999999\"}$。\n- 情况 F（完全相等）：$x = \\text{\"1.23456789012345\"}$, $y = \\text{\"1.23456789012345\"}$。\n\n最终输出格式：\n- 对于每个测试用例，您的程序必须按以下固定顺序生成一个包含六个元素的列表：\n  - $E(r_{\\mathrm{bn}}; x, y)$，作为浮点数，\n  - $E(r_{\\mathrm{bf}}; x, y)$，作为浮点数，\n  - 一个布尔值，指示在 binary64 中因式分解公式是否更好（即 $E(r_{\\mathrm{bf}}; x, y)  E(r_{\\mathrm{bn}}; x, y)$ 是否成立），\n  - $E(r_{\\mathrm{dn}}; x, y)$，作为浮点数，\n  - $E(r_{\\mathrm{df}}; x, y)$，作为浮点数，\n  - 一个布尔值，指示在十进制16位算术中因式分解公式是否更好。\n- 将每个用例的列表聚合到一个单一列表中，并将其作为单行打印。具体来说，程序应打印如下所示的一行：\n  ```\n  [[e_bn_A, e_bf_A, better_bin_A, e_dn_A, e_df_A, better_dec_A],...,[e_bn_F, e_bf_F, better_bin_F, e_dn_F, e_df_F, better_dec_F]]\n  ```\n- 所有布尔值、整数和浮点数输出都必须是纯数值；不应打印任何额外的文本、单位或注释。\n\n此问题不涉及任何物理单位或角度。所有数字都是无量纲的。请确保所有算术和比较都遵循上述描述。参考值、二进制和十进制计算必须在您的程序内部执行；不要需要任何用户输入或外部数据文件。程序必须是确定性的和自包含的。", "solution": "该问题要求对计算平方差 $x^2 - y^2$ 的两种代数等价公式进行比较分析，分析将在两种不同的浮点算術系统下进行：标准的 IEEE 754 binary64 格式和16位十进制格式。目标是量化每种公式的数值误差，并确定哪种公式对于有效性损失更具鲁棒性。\n\n待研究的两种公式是：\n1.  **朴素公式**：$f_n(x, y) = x^2 - y^2$\n2.  **因式分解公式**：$f_f(x, y) = (x-y)(x+y)$\n\n该问题核心的基本数值原理是**相消抵消**（subtractive cancellation）。当两个几乎相等的数在有限精度算术中相减时，就会出现这种现象。数字的前导有效位相消，留下的结果由有效性较低、可能不准确的尾部数字主导。这可能导致相对精度的灾难性损失。\n\n在 $x^2 - y^2$ 的情境下，如果 $x$ 和 $y$ 的量级相近（$|x| \\approx |y|$），那么 $x^2$ 和 $y^2$ 也会非常接近。朴素公式 $x^2 - y^2$ 将计算这两个几乎相等的中间值，然后将它们相减，使其容易受到相消抵消的影响。\n\n相反，因式分解公式 $(x-y)(x+y)$ 计算中间量 $x-y$ 和 $x+y$。\n-   如果 $x \\approx y$ 且它们符号相同，则首先计算 $x-y$ 项。虽然这也是一次减法，但精度损失发生在不同的阶段。$x-y$ 的值可能很小，但通常可以被精确表示。第二项 $x+y \\approx 2x$ 不涉及抵消。最终的乘积保留了在 $x-y$ 项中捕获的有效性。\n-   如果 $x \\approx -y$，抵消将发生在 $x+y$ 项中，而 $x-y \\approx 2x$ 将是准确的。在这种情况下，因式分解形式也容易发生抵消，但在不同的中间步骤。朴素形式，即减去两个大的正数（$x^2$ 和 $y^2$），仍然是易受抵消影响的形式。这需要仔细分析。当 $x \\approx -y$ 时，如果我们写成 $y = -x + \\delta$（其中 $\\delta$ 很小），那么 $x^2 - y^2$ 就不涉及减去几乎相等的数。此时 $x^2-y^2 = x^2 - (-x+\\delta)^2 = x^2 - (x^2 - 2x\\delta + \\delta^2) = 2x\\delta - \\delta^2$。朴素方法会计算 $x^2$ 和 $y^2$ 然后相减，这两个值仍然几乎相等，因此是不稳定的。而因式分解形式 $(x-y)(x+y)$ 会计算 $(x-(-x+\\delta))(x+(-x+\\delta)) = (2x-\\delta)(\\delta)$，这应该更稳定。因此，当 $|x| \\approx |y|$ 时，因式分解形式通常更优。\n\n解决方案将通过为每个测试用例 $(x, y)$ 执行以下步骤来实现：\n\n1.  **高精度参考值**：使用精度为100位的十进制算术计算一个可信的“真”值 $t = x^2 - y^2$。这种高精度上下文可以最大限度地减少舍入误差，为比较提供一个可靠的基准。缩放因子 $S = (\\max(|x|, |y|))^2$ 也在该上下文中计算。\n\n2.  **Binary64 算术**：将 $x$ 和 $y$ 的输入字符串转换为原生的 IEEE 754 双精度浮点数（`binary64`）。朴素结果 $r_{\\mathrm{bn}}$ 和因式分解结果 $r_{\\mathrm{bf}}$ 都使用标准浮点运算进行计算。\n\n3.  **Decimal16 算术**：建立一个独立的十进制算术上下文，精度为16位，舍入模式为“舍入到最近，偶数优先”。输入 $x$ 和 $y$ 被量化到此精度。然后，朴素结果（$r_{\\mathrm{dn}}$）和因式分解结果（$r_{\\mathrm{df}}$）完全在此十进制上下文中计算。\n\n4.  **误差分析**：对于四个计算结果中的每一个 $r$，根据指定的公式计算缩放相对误差：\n    $$\n    E(r; x, y) = \\frac{|r - t|}{\\max\\{ |t|, \\, S \\}}\n    $$\n    此计算使用高精度上下文执行，以确保误差测量本身是准确的。结果 $r$（可能是一个 `binary64` 浮点数或一个 `Decimal16` 对象）首先被提升为一个高精度的 `Decimal`，以便与参考值 $t$ 进行精确比较。\n\n5.  **结论**：对于每个算术系统（二进制和十进制），比较两种公式的误差（$E(r_{\\mathrm{bf}})$ 与 $E(r_{\\mathrm{bn}})$ 以及 $E(r_{\\mathrm{df}})$ 与 $E(r_{\\mathrm{dn}})$），以确定哪种公式产生了更准确的结果。一个布尔值指示因式分解形式是否更好（即，其误差是否严格更小）。\n\n这种系统化的方法将具体展示数值稳定性的原理，并突显二进制和十进制浮点系统在面对有问题的计算时行为上的差异。测试套件旨在探测各种场景，包括严重的抵消、不存在抵消问题的情况，以及初始输入量化误差比算法选择影响更大的情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, Context, ROUND_HALF_EVEN\n\ndef solve():\n    \"\"\"\n    Compares two formulations for x^2 - y^2 in binary64 and decimal16 floating-point arithmetic.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: nearby around 1\n        (\"1.0000001\", \"0.9999999\"),\n        # Case B: very close, asymmetric\n        (\"1.0000001\", \"1.0000000\"),\n        # Case C: very large, near-equal integers\n        (\"10000000000000001\", \"9999999999999999\"),\n        # Case D: very small, near-equal\n        (\"1.0000001e-16\", \"9.999999e-17\"),\n        # Case E: opposite signs, near equal magnitude\n        (\"10000000000000001\", \"-9999999999999999\"),\n        # Case F: exact equality\n        (\"1.23456789012345\", \"1.23456789012345\"),\n    ]\n\n    # Setup for arithmetic contexts\n    # High-precision for reference calculations\n    ctx_hp = Context(prec=100, rounding=ROUND_HALF_EVEN)\n    # 16-digit decimal for testing\n    ctx_d16 = Context(prec=16, rounding=ROUND_HALF_EVEN)\n\n    results = []\n    \n    for x_str, y_str in test_cases:\n        # 1. High-precision reference computation\n        x_hp = ctx_hp.create_decimal(x_str)\n        y_hp = ctx_hp.create_decimal(y_str)\n\n        # Compute reference t = x^2 - y^2 using the stable factored form.\n        t_ref = ctx_hp.multiply(ctx_hp.subtract(x_hp, y_hp), ctx_hp.add(x_hp, y_hp))\n        \n        # Compute scale S = (max(|x|,|y|))^2\n        s_scale = ctx_hp.power(max(x_hp.copy_abs(), y_hp.copy_abs()), 2)\n        \n        # Denominator for error formula, handles t=0 case\n        error_denominator = max(t_ref.copy_abs(), s_scale)\n        # Avoid division by zero if x=y=0 (not in test suite, but good practice)\n        if error_denominator == 0:\n            error_denominator = Decimal(1)\n\n        # 2. IEEE 754 binary64 computation\n        x_b64 = np.float64(x_str)\n        y_b64 = np.float64(y_str)\n        \n        # Naive formulation\n        r_bn = x_b64**2 - y_b64**2\n        \n        # Factored formulation\n        r_bf = (x_b64 - y_b64) * (x_b64 + y_b64)\n\n        # 3. Decimal 16-digit computation\n        x_d16 = ctx_d16.create_decimal(x_str)\n        y_d16 = ctx_d16.create_decimal(y_str)\n\n        # Naive formulation\n        r_dn = ctx_d16.subtract(ctx_d16.power(x_d16, 2), ctx_d16.power(y_d16, 2))\n        \n        # Factored formulation\n        r_df = ctx_d16.multiply(ctx_d16.subtract(x_d16, y_d16), ctx_d16.add(x_d16, y_d16))\n\n        # 4. Error calculation\n        def get_error(r, t_ref, den, high_prec_ctx):\n            # Promote computed result r (float or Decimal) to a high-precision Decimal\n            # The Decimal constructor accurately represents the exact value of a float.\n            if isinstance(r, (float, np.floating)):\n                r_hp = high_prec_ctx.create_decimal(r)\n            else: # r is already a Decimal\n                r_hp = r\n\n            # Calculate error numerator |r - t| in high precision\n            err_num = high_prec_ctx.subtract(r_hp, t_ref).copy_abs()\n            \n            # Calculate scaled relative error\n            return float(high_prec_ctx.divide(err_num, den))\n\n        e_bn = get_error(r_bn, t_ref, error_denominator, ctx_hp)\n        e_bf = get_error(r_bf, t_ref, error_denominator, ctx_hp)\n        e_dn = get_error(r_dn, t_ref, error_denominator, ctx_hp)\n        e_df = get_error(r_df, t_ref, error_denominator, ctx_hp)\n\n        # 5. Determine which formulation is better\n        better_bin = e_bf  e_bn\n        better_dec = e_df  e_dn\n        \n        case_result = [e_bn, e_bf, better_bin, e_dn, e_df, better_dec]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The default string representation of list of lists is the desired format.\n    print(f\"{results}\")\n\nsolve()\n```", "id": "3210660"}]}