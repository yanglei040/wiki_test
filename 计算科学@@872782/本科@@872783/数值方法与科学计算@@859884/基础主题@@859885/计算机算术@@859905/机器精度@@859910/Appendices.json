{"hands_on_practices": [{"introduction": "理解了浮点数的离散性后，我们来看一个它在编程实践中可能导致的惊人后果。这个练习要求你构建一个由于浮点数精度限制而无法终止的循环。通过亲手实现这个“无限循环”，你将直观地感受到为何在数值计算中对浮点数进行精确的相等性比较是危险的。[@problem_id:3250049]", "problem": "您必须编写一个完整、可运行的程序，来演示并检测在一个条件使用浮点数相等性判断的循环中，因接近相等时机器 epsilon 的效应而导致的不终止现象。在符合电气和电子工程师协会 (IEEE) 754 标准的二进制浮点模型下工作，使用“向最接近的值舍入，若相等则取偶数”（rounding to nearest with ties to even）的舍入规则。从以下基础概念出发：\n\n- 机器 epsilon 的定义：最小的正实数 $\\varepsilon_{\\mathrm{mach}}$，使得在浮点运算中 $\\mathrm{fl}(1 + \\varepsilon_{\\mathrm{mach}}) \\neq 1$。\n- 末位单位 (ULP)：对于一个给定的浮点数 $a$，到下一个更大的可表示浮点数的距离，记作 $\\mathrm{ulp}(a)$，其值为 $\\mathrm{nextafter}(a,+\\infty) - a$。这是浮点分析中一个经过广泛验证的事实。\n- 向最接近的值舍入，若相等则取偶数：给定一个实数 $z$，它正好位于两个可表示的浮点数 $z_{-}$ 和 $z_{+}$ 的中间，舍入后的值是其有效数（significand）的最低有效位为偶数的那个数。\n\n您的程序将模拟一系列简单的更新循环，形式如下：\n- 初始化 $x \\leftarrow x_{0}$，\n- 固定一个目标值 $y$ 和一个常量增量 $\\delta > 0$，\n- 迭代 $x \\leftarrow \\mathrm{fl}(x + \\delta)$ 直到满足条件 $x = y$。\n\n在精确的实数算术中，如果 $x_{0}  y$ 且 $\\delta > 0$，那么存在一个整数 $k$ 使得 $x_{0} + k \\delta = y$。然而，在浮点运算中，如果对于当前的 $x$，增量 $\\delta$ 小于 $\\tfrac{1}{2}\\,\\mathrm{ulp}(x)$，那么 $\\mathrm{fl}(x + \\delta) = x$，循环将无法取得进展。特别地，如果 $x \\neq y$ 且 $\\mathrm{fl}(x + \\delta) = x$，那么循环体无法改变 $x$ 的值，循环条件 $x \\neq y$ 将永远为真，因此循环不会终止。\n\n您的程序必须执行以下任务：\n\n1) 通过第一性原理的减半过程计算工作浮点类型的机器 epsilon $\\varepsilon_{\\mathrm{mach}}$。不要为 $\\varepsilon_{\\mathrm{mach}}$ 硬编码一个常量。\n2) 实现一个函数来计算任意有限数 $a$ 的 $\\mathrm{ulp}(a)$，其定义为 $|\\mathrm{nextafter}(a,+\\infty) - a|$。\n3) 为循环“while $x \\neq y$ do $x \\leftarrow \\mathrm{fl}(x + \\delta)$”实现一个模拟器，其行为如下：\n   - 如果在一次迭代的开始时 $x = y$，则声明循环终止。\n   - 否则，计算 $x_{\\text{new}} \\leftarrow \\mathrm{fl}(x + \\delta)$。\n   - 如果 $x_{\\text{new}} = x$ 且 $x \\neq y$，则声明循环无法终止，因为状态停滞且循环条件保持为真。\n   - 同时，通过在一个大的固定迭代次数 $N_{\\max}$ 后停止来防止病态情况，并在这种情况下声明不终止。您可以取 $N_{\\max} = 10^{7}$。\n4) 对于下面的每个测试用例，构造指定的 $x_{0}$、$y$ 和 $\\delta$，并报告一个布尔值，指示循环是终止（true）还是被停滞规则或迭代上限检测为不终止（false）。\n\n测试套件规范：\n\n令 $\\mathrm{prev}(a)$ 表示严格小于 $a$ 的最大可表示浮点数，即对于 $a > 0$，$\\mathrm{prev}(a) = \\mathrm{nextafter}(a,0)$。\n\n提供以下五个案例的结果：\n\n- 案例 A（因在 1 附近停滞而导致不终止）：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\tfrac{1}{4}\\,\\mathrm{ulp}(y)$。预期行为：由于在 $x = x_{0}$ 时 $\\delta  \\tfrac{1}{2}\\,\\mathrm{ulp}(x)$，舍入导致 $\\mathrm{fl}(x + \\delta) = x$，因此当 $x \\neq y$ 时无法取得进展。\n- 案例 B（因中点舍入而在一次迭代中终止）：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\tfrac{1}{2}\\,\\mathrm{ulp}(y)$。预期行为：由于“ties to even”规则，$\\mathrm{fl}(x + \\delta)$ 会舍入到 $y$，因此循环在下一次条件检查时终止。\n- 案例 C（立即终止）：$y = 1$，$x_{0} = 1$，且 $\\delta = \\tfrac{1}{4}\\,\\mathrm{ulp}(y)$。预期行为：由于初始时 $x = y$，循环不会进入。\n- 案例 D（在数量级较大时因增量过小而不终止）：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\tfrac{1}{4}\\,\\mathrm{ulp}(1)$。预期行为：由于 $\\mathrm{ulp}(y) \\gg \\mathrm{ulp}(1)$，在 $x \\approx y$ 时，有 $\\delta \\ll \\tfrac{1}{2}\\,\\mathrm{ulp}(x)$，因此 $\\mathrm{fl}(x + \\delta) = x$ 且循环无法取得进展。\n- 案例 E（在数量级较大时因增量足够而终止）：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\tfrac{1}{2}\\,\\mathrm{ulp}(y)$。预期行为：与案例 B 中一样，一步迭代就将 $x$ 移至 $y$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。对于按顺序排列的五个案例 A 到 E，输出一个布尔值列表，例如，“[True,False,True,False,True]”。输出行中不得包含任何其他文本。", "solution": "该问题要求探究浮点运算的特性，特别是其离散性如何导致依赖相等性检查的循环不终止。我们将通过实现机器 epsilon 的第一性原理计算、一个计算末位单位 (ULP) 的函数以及一个简单迭代循环的模拟器，来构建一个程序以演示此现象。该分析基于 IEEE 754 二进制浮点运算标准，使用向最近可表示值舍入，若相等则舍入到有效数最低有效位为偶数的那个值的规则。\n\n问题的核心在于更新步骤 $x \\leftarrow \\mathrm{fl}(x + \\delta)$，其中 $\\mathrm{fl}(\\cdot)$ 表示一个实数的浮点表示。由于浮点数的精度有限，任何数 $x$ 与下一个更大的可表示数之间都存在一个最小间隙。这个间隙被称为末位单位，即 $\\mathrm{ulp}(x)$。如果增量 $\\delta$ 相对于此间隙过小，和 $x + \\delta$ 可能会被舍入回 $x$，导致循环停滞。\n\n逐步解决方案如下：\n\n首先，我们必须计算工作浮点类型（我们采用 64 位双精度）的机器 epsilon, $\\varepsilon_{\\mathrm{mach}}$。$\\varepsilon_{\\mathrm{mach}}$ 定义为使得 $\\mathrm{fl}(1 + \\varepsilon_{\\mathrm{mach}}) \\neq 1$ 的最小正数。它等价于 $\\mathrm{ulp}(1)$。我们可以通过算法来确定 $\\varepsilon_{\\mathrm{mach}}$，即从一个值（比如 $\\varepsilon = 1$）开始，并不断将其减半。只要 `epsilon` 足够大，加到 1 上时能被识别，循环 `while (1.0 + epsilon) > 1.0` 就会继续。当 `1.0 + epsilon` 被向下舍入到 `1.0` 时，循环终止。如果循环终止时 `epsilon` 的最终值为 $\\varepsilon_{f}$，这意味着 $\\mathrm{fl}(1 + \\varepsilon_{f}) = 1$，而前一个值 $2\\varepsilon_{f}$ 满足 $\\mathrm{fl}(1 + 2\\varepsilon_{f}) > 1$。因此，$\\varepsilon_{\\mathrm{mach}} = 2\\varepsilon_{f}$。\n\n其次，我们实现一个函数来计算浮点数 $a$ 的 $\\mathrm{ulp}(a)$。按照规定，这是到下一个更大的可表示浮点数的距离。它由表达式 $\\mathrm{ulp}(a) = |\\mathrm{nextafter}(a, +\\infty) - a|$ 给出。$\\mathrm{ulp}(a)$ 的值不是恒定的；它随 $a$ 的数量级缩放。具体来说，对于范围在 $[2^k, 2^{k+1})$ 内的数 $a$，其 ULP 由 $\\mathrm{ulp}(a) = 2^k \\varepsilon_{\\mathrm{mach}}$ 给出。\n\n第三，我们分析循环停滯的条件。和 $x + \\delta$ 是一个必须舍入为可表示的浮点值的实数。最接近 $x$ 的可表示数是 $x$ 本身和 $\\mathrm{nextafter}(x, +\\infty) = x + \\mathrm{ulp}(x)$。这两者之间的中点是 $x + \\frac{1}{2}\\mathrm{ulp}(x)$。“向最接近的值舍入”规则规定：\n- 如果 $x + \\delta \\le x + \\frac{1}{2}\\mathrm{ulp}(x)$，和将被向下舍入到 $x$。这等价于 $\\delta \\le \\frac{1}{2}\\mathrm{ulp}(x)$。\n- 如果 $x + \\delta > x + \\frac{1}{2}\\mathrm{ulp}(x)$，和将被向上舍入到 $\\mathrm{nextafter}(x, +\\infty)$。这等价于 $\\delta > \\frac{1}{2}\\mathrm{ulp}(x)$。\n- 如果 $x + \\delta = x + \\frac{1}{2}\\mathrm{ulp}(x)$，和正好在中间。“ties to even”规则适用，舍入到有效数最低有效位为 0 的邻近值。\n\n如果 $\\delta \\le \\frac{1}{2}\\mathrm{ulp}(x)$，那么 $\\mathrm{fl}(x + \\delta) = x$。如果此时 $x \\neq y$，循环变量将停止改变，终止条件 $x=y$ 永远不会被满足，从而导致无限循环。我们的模拟器必须检测到这种停滞。它还将包含一个 $N_{\\max} = 10^7$ 次迭代的安全限制。\n\n第四，我们设计循环模拟器函数。它接受初始值 $x_0$、$y$ 和 $\\delta$。它进行迭代，更新 $x \\leftarrow \\mathrm{fl}(x + \\delta)$。在每次迭代中，它首先检查是否 $x=y$（终止），然后计算新值 $x_{\\text{new}}$，最后检查是否 $x_{\\text{new}} = x$（停滞）。如果循环在两个条件都未满足的情况下完成了 $N_{\\max}$ 次迭代，它也被声明为不终止。\n\n最后，我们将此框架应用于五个指定的测试用例。我们记 $\\mathrm{prev}(a) = \\mathrm{nextafter}(a, 0)$ for $a>0$。\n\n案例 A：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。\n此处 $y=1$，因此 $\\mathrm{ulp}(y) = \\mathrm{ulp}(1) = \\varepsilon_{\\mathrm{mach}}$。增量为 $\\delta = \\frac{1}{4}\\varepsilon_{\\mathrm{mach}}$。初始值为 $x_0 = \\mathrm{prev}(1)$，它非常接近 1，所以 $\\mathrm{ulp}(x_0) \\approx \\mathrm{ulp}(1) = \\varepsilon_{\\mathrm{mach}}$。停滞条件为 $\\delta \\le \\frac{1}{2}\\mathrm{ulp}(x_0)$，即 $\\frac{1}{4}\\varepsilon_{\\mathrm{mach}} \\le \\frac{1}{2}\\varepsilon_{\\mathrm{mach}}$。这是成立的。因此，$\\mathrm{fl}(x_0 + \\delta) = x_0$。循环在第一次迭代时就停滞了。结果是不终止 (False)。\n\n案例 B：$y = 1$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。\n此处 $\\delta = \\frac{1}{2}\\varepsilon_{\\mathrm{mach}}$。值 $x_0 + \\delta$ 正好在 $x_0$ 和 $y=1$ 的中间。我们必须应用“ties to even”规则。数字 $1.0$ 的有效数表示中，其最低有效位为 0（偶数）。数字 $x_0 = \\mathrm{prev}(1)$ 的有效数最低有效位为 1（奇数）。舍入到“偶数”邻近值，即 $y=1$。因此，$\\mathrm{fl}(x_0 + \\delta) = y$。循环在一次迭代后终止。结果是终止 (True)。\n\n案例 C：$y = 1$，$x_{0} = 1$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(y)$。\n初始条件是 $x_0 = y$。循环条件 `while x != y` 从一开始就为假。循环体永远不会执行。结果是立即终止 (True)。\n\n案例 D：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{4}\\,\\mathrm{ulp}(1)$。\n目标值 $y = 2^{30}$ 是一个大数。其 ULP 显著大于 1 的 ULP：$\\mathrm{ulp}(y) = \\mathrm{ulp}(2^{30}) = 2^{30}\\mathrm{ulp}(1) = 2^{30}\\varepsilon_{\\mathrm{mach}}$。增量为 $\\delta = \\frac{1}{4}\\mathrm{ulp}(1) = \\frac{1}{4}\\varepsilon_{\\mathrm{mach}}$。当前值 $x_0 \\approx y$，所以 $\\mathrm{ulp}(x_0) \\approx \\mathrm{ulp}(y)$。停滞条件 $\\delta \\le \\frac{1}{2}\\mathrm{ulp}(x_0)$ 变为 $\\frac{1}{4}\\varepsilon_{\\mathrm{mach}} \\le \\frac{1}{2}(2^{30}\\varepsilon_{\\mathrm{mach}})$，即 $\\frac{1}{4} \\le 2^{29}$。这显然是成立的。在这个数量级上，增量太小以至于没有任何效果。循环停滞。结果是不终止 (False)。\n\n案例 E：$y = 2^{30}$，$x_{0} = \\mathrm{prev}(y)$，且 $\\delta = \\frac{1}{2}\\,\\mathrm{ulp}(y)$。\n这与案例 B 类似，但在一个更大的数量级上。增量 $\\delta = \\frac{1}{2}\\mathrm{ulp}(y)$ 使和 $x_0 + \\delta$ 正好处在 $x_0$ 和 $y$ 的中间。数字 $y=2^{30}$ 是 2 的幂，其有效数的最低有效位是偶数。数字 $x_0 = \\mathrm{prev}(y)$ 的最低有效位是奇数。舍入到偶数邻近值，即 $y$。循环在一步之内终止。结果是终止 (True)。\n\n预期结果为 [False, True, True, False, True]。以下程序将此分析形式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by setting up and running simulations for the five\n    specified test cases and printing the results.\n    \"\"\"\n\n    def compute_machine_epsilon():\n        \"\"\"\n        Computes machine epsilon for float64 using a first-principles halving procedure.\n        Machine epsilon is the smallest positive number eps such that 1.0 + eps != 1.0.\n        \"\"\"\n        # Start with a value that is guaranteed to be significant when added to 1.\n        epsilon = np.float64(1.0)\n        # Repeatedly halve epsilon until 1.0 + epsilon is indistinguishable from 1.0.\n        while np.float64(1.0) + epsilon > np.float64(1.0):\n            epsilon /= np.float64(2.0)\n        # The loop terminates when epsilon is too small. The machine epsilon is the\n        # previous value of epsilon, which is the current value multiplied by 2.\n        return epsilon * np.float64(2.0)\n\n    def compute_ulp(a: np.float64) -> np.float64:\n        \"\"\"\n        Computes the Unit in the Last Place (ULP) for a given float64 number 'a'.\n        Defined as the distance to the next larger representable floating-point number.\n        \"\"\"\n        # Ensure input is a float64 for consistent calculations.\n        a = np.float64(a)\n        # Use np.inf to find the next representable number in the positive direction.\n        # np.nextafter handles negative numbers and special cases correctly.\n        return np.abs(np.nextafter(a, np.inf) - a)\n\n    def simulate_loop(x0: np.float64, y: np.float64, delta: np.float64) -> bool:\n        \"\"\"\n        Simulates the loop 'while x != y: x = x + delta' and detects non-termination.\n\n        Returns:\n            bool: True if the loop terminates, False otherwise.\n        \"\"\"\n        N_MAX = 10**7\n        x = np.float64(x0)\n        y = np.float64(y)\n        delta = np.float64(delta)\n\n        for _ in range(N_MAX):\n            # Condition 1: Loop terminates if x reaches the target y.\n            if x == y:\n                return True\n\n            # Perform one step of the iteration.\n            x_new = x + delta\n\n            # Condition 2: Non-termination due to stagnation.\n            # If the value of x does not change, and x is not at the target,\n            # the loop will never terminate.\n            if x_new == x:\n                return False\n\n            x = x_new\n\n        # Condition 3: Non-termination due to exceeding max iterations.\n        return False\n\n    # Define a helper for prev(a) as specified in the problem\n    def prev(a: np.float64) -> np.float64:\n        return np.nextafter(a, np.float64(0.0))\n\n    # --- Test Case Construction ---\n    \n    # Common helper values\n    y1 = np.float64(1.0)\n    ulp1 = compute_ulp(y1)\n    \n    y2 = np.float64(2**30)\n    ulp2 = compute_ulp(y2)\n\n    test_cases = [\n        # Case A: Non-terminating by stagnation near one\n        (prev(y1), y1, np.float64(0.25) * ulp1),\n        \n        # Case B: Terminating in one iteration by midpoint rounding\n        (prev(y1), y1, np.float64(0.5) * ulp1),\n        \n        # Case C: Immediate termination\n        (y1, y1, np.float64(0.25) * ulp1),\n        \n        # Case D: Non-terminating at large magnitude with too-small increment\n        (prev(y2), y2, np.float64(0.25) * ulp1),\n        \n        # Case E: Terminating at large magnitude by adequate increment\n        (prev(y2), y2, np.float64(0.5) * ulp2),\n    ]\n\n    results = []\n    for x0, y, delta in test_cases:\n        terminates = simulate_loop(x0, y, delta)\n        results.append(terminates)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250049"}, {"introduction": "除了加法失效，减法中的精度损失是另一个常见陷阱，即“灾难性抵消”。本练习将带你探究当两个几乎相等的数相减时，如何导致计算结果的有效数字完全丢失。通过比较朴素计算与专用库函数的表现，你将学会识别并避免这类数值稳定性问题。[@problem_id:3250061]", "problem": "您的任务是分析在浮点运算中计算实值映射 $x \\mapsto e^x - 1$ 函数值的数值稳定性。目标是检测在浮点运算中以 $\\exp(x) - 1$ 的方式朴素地计算 $e^x - 1$ 何时会遭受灾难性抵消，并将其与一个无需抵消即可计算相同函数的数值稳定替代方法进行比较。\n\n您的推理应基于以下基本概念。\n- 对于标准双精度格式，采用浮点数就近舍入、向偶数舍入的规则，以及指数函数 $x \\mapsto e^x$ 对实数 $x$ 的单调性。\n- 机器 epsilon 的定义：在目标格式中，满足 $1 + \\varepsilon > 1$ 的最小正浮点数 $\\varepsilon$。\n- 当 $x$ 很小时，实数 $e^x$ 等于 $1 + x + \\frac{x^2}{2} + \\cdots$，因此满足 $e^x - 1 \\approx x$。\n- 灾难性抵消现象：减去几乎相等的浮点数会抹去前面的有效数字，导致巨大的相对误差。\n\n您的程序必须使用双精度浮点运算（即由 Numerical Python 库提供的语言标准 $64$ 位浮点数）实现以下内容。\n1. 通过迭代减半方法计算浮点类型的机器 epsilon $\\varepsilon$。将结果表示为 $\\hat{\\varepsilon}$。\n2. 确定一个最小的正实数 $x$（意义上是使得朴素计算的差值保持为零的最大 $x$），使得使用 $\\exp(x) - 1$ 对 $e^x - 1$ 进行的朴素浮点计算在浮点运算中恰好返回 $0$。形式上，找到上确界 $x_{\\mathrm{crit}} > 0$，使得在所选的浮点类型中，$\\exp(x) - 1 = 0$ 成立。使用单调性和二分搜索法将 $x_{\\mathrm{crit}}$ 近似到浮点类型的分辨率范围内。\n3. 对于相同的 $x_{\\mathrm{crit}}$，计算一个为小 $x$ 设计的、无抵消的 $e^x - 1$ 实现所产生的值。将此值表示为 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$。此函数应为语言或库提供的能在零附近区域避免抵消的实现。\n4. 对于一组精心选择的输入，将朴素差分和无抵消实现的相对误差与高精度参考值进行比较。使用高精度实数算术工具为每个 $x$ 计算参考值 $\\operatorname{true}(x)$，然后计算相对误差\n$$\n\\operatorname{relerr}(y;\\operatorname{true}) = \\frac{|y - \\operatorname{true}|}{|\\operatorname{true}|}.\n$$\n必须评估的输入测试套件是列表\n$$\n\\left[ x_{\\mathrm{crit}}, \\frac{x_{\\mathrm{crit}}}{2}, \\hat{\\varepsilon}, \\frac{\\hat{\\varepsilon}}{2}, \\sqrt{\\hat{\\varepsilon}}, -x_{\\mathrm{crit}}, -\\frac{x_{\\mathrm{crit}}}{2}, -\\hat{\\varepsilon}, -\\frac{\\hat{\\varepsilon}}{2}, -\\sqrt{\\hat{\\varepsilon}} \\right].\n$$\n对于此列表中的每个输入 $x$，计算布尔值\n$$\nb(x) = \\left( \\operatorname{relerr}\\big(\\exp(x) - 1; \\operatorname{true}(x)\\big) > \\operatorname{relerr}\\big(\\text{alt}(x); \\operatorname{true}(x)\\big) \\right),\n$$\n该布尔值回答了在该输入上，朴素差分的相对误差是否严格大于无抵消实现的相对误差。\n假设不涉及物理单位。角度不相关。所有数值结果必须按照下文规定，报告为浮点数或布尔值。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下确切顺序排列：\n- 首先是 $\\hat{\\varepsilon}$。\n- 其次是 $x_{\\mathrm{crit}}$。\n- 第三是 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$。\n- 然后是对应于上述测试套件中输入的10个布尔值 $b(x)$ 序列，按此确切顺序。\n\n例如，输出必须看起来像\n$[r_1,r_2,r_3,b_1,b_2,\\dots,b_{10}]$\n其中 $r_1, r_2, r_3$ 是浮点数，$b_1,\\dots,b_{10}$ 是布尔值。不应打印任何额外文本。", "solution": "目标是分析当 $x$ 值接近零时，在双精度浮点运算中朴素地计算函数 $f(x) = e^x - 1$ 所出现的数值不稳定性。这种不稳定性被称为灾难性抵消，我们将它与一个稳定的替代实现进行比较。分析涉及四个主要步骤：计算机器 epsilon，确定抵消的临界阈值，评估一个稳定的替代方案，以及在一组指定的测试输入上比较两种方法的相对误差。\n\n### 第 1 部分：计算机器 Epsilon ($\\hat{\\varepsilon}$)\n\n机器 epsilon，记为 $\\varepsilon$，是使得 $1$ 与 $\\varepsilon$ 相加的结果严格大于 $1$ 的最小正浮点数。形式上，在浮点运算中，$\\varepsilon = \\min \\{ y > 0 \\mid 1 + y > 1 \\}$。它量化了 $1$ 与下一个更大的可表示浮点数之间的间隙。\n\n为了计算标准 $64$ 位双精度浮点类型的 $\\hat{\\varepsilon}$，我们按照规定采用迭代减半法。我们从一个值开始，例如 $x_0 = 1$，然后重复将其除以 $2$。对于每个新值 $x_k = x_{k-1}/2$，我们测试条件 $1 + x_k > 1$。当此条件不再满足时，循环终止。条件最后一次成立时的 $x_{k-1}$ 值就是我们计算出的机器 epsilon，即 $\\hat{\\varepsilon}$。使用 NumPy 的 `float64` 类型可确保运算以双精度执行。\n\n### 第 2 部分：确定临界值 ($x_{\\mathrm{crit}}$)\n\n当 $x$ 接近 $0$ 时，表达式 $e^x - 1$ 中会发生灾难性抵消。在这种情况下，$e^x$ 接近 $1$。$e^x$ 的浮点表示，记为 $\\mathrm{fl}(e^x)$，可能会损失精度。当我们再减去 $1$ 时，$\\mathrm{fl}(e^x)$ 和 $1$ 的前导比特位是相同的，它们的抵消导致结果主要由舍入误差主导。\n\n问题要求找到上确界 $x_{\\mathrm{crit}} > 0$，使得朴素的浮点计算恰好产生零：\n$$\n\\mathrm{fl}(\\mathrm{fl}(e^x) - 1) = 0\n$$\n在标准浮点运算中，此等式成立当且仅当 $\\mathrm{fl}(e^x)$ 恰好为 $1.0$。根据 IEEE 754 标准（就近舍入，向偶数舍入），如果实数 $z$ 落在区间 $[1.0 - \\varepsilon/4, 1.0 + \\varepsilon/2)$ 内，它将被舍入为 $1.0$。由于我们考虑 $x > 0$，所以有 $e^x > 1$。因此，如果 $e^x \\le 1.0 + \\varepsilon/2$，则 $\\mathrm{fl}(e^x) = 1.0$。阈值在 $e^x = 1.0 + \\varepsilon/2$ 时达到，这意味着 $x = \\ln(1.0 + \\varepsilon/2)$。因此，所有满足该条件的 $x$ 的集合的上确界是 $x_{\\mathrm{crit}} = \\ln(1 + \\varepsilon/2) \\approx \\varepsilon/2$。\n\n我们使用二分搜索法来数值地找到这个值。我们搜索使得布尔表达式 `np.exp(x) - 1.0 == 0.0` 为真的最大正浮点数 $x$。搜索区间被初始化，例如，为 $[0, \\hat{\\varepsilon}]$，然后迭代地细化。如果对于中点 `mid`，条件 `np.exp(mid) - 1.0 == 0.0` 成立，我们知道 $x_{\\mathrm{crit}}$ 至少是 `mid`，所以我们将搜索的下界设置为 `mid`。否则，`mid` 太大，我们将上界设置为 `mid`。经过足够次数的迭代后，搜索区间的下界将收敛到机器可表示的值，这个值就是我们对 $x_{\\mathrm{crit}}$ 的最佳近似。\n\n### 第 3 部分：稳定的替代实现 ($y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$)\n\n存在专门的库函数可以为小的 $|x|$ 精确计算 $e^x - 1$。这些函数，例如 `numpy.expm1`，通常在 $|x|$ 很小时使用泰勒级数展开 $e^x - 1 = x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\cdots$，而在 $|x|$ 足够大以至于抵消不成问题时，则回退到直接计算 $\\exp(x) - 1$。我们被要求在我们确定的临界点上计算这个稳定函数的值，即 $y_{\\mathrm{alt}}(x_{\\mathrm{crit}}) = \\mathrm{expm1}(x_{\\mathrm{crit}})$。\n\n### 第 4 部分：相对误差比较\n\n为了定量评估朴素方法与稳定方法的性能，我们计算它们相对于高精度参考值的相对误差。一个近似值 $y$ 相对于真值 $\\operatorname{true}$ 的相对误差由下式给出：\n$$\n\\operatorname{relerr}(y; \\operatorname{true}) = \\frac{|y - \\operatorname{true}|}{|\\operatorname{true}|}\n$$\n$e^x - 1$ 的“真”值是使用 Python 的 `decimal` 模块计算的，该模块配置了高精度（例如 $50$ 位数字），以作为可靠的基准真相。\n\n比较是针对一个包含 $10$ 个输入的测试套件进行的：$[ x_{\\mathrm{crit}}, \\frac{x_{\\mathrm{crit}}}{2}, \\hat{\\varepsilon}, \\frac{\\hat{\\varepsilon}}{2}, \\sqrt{\\hat{\\varepsilon}}, -x_{\\mathrm{crit}}, -\\frac{x_{\\mathrm{crit}}}{2}, -\\hat{\\varepsilon}, -\\frac{\\hat{\\varepsilon}}{2}, -\\sqrt{\\hat{\\varepsilon}} ]$。选择这些输入是为了让它们位于预期灾难性抵消会很显著的区域内。对于每个输入 $x$，我们计算布尔指示符：\n$$\nb(x) = \\left( \\operatorname{relerr}\\big(\\mathrm{fl}(\\exp(x) - 1); \\operatorname{true}(x)\\big) > \\operatorname{relerr}\\big(\\mathrm{expm1}(x); \\operatorname{true}(x)\\big) \\right)\n$$\n如果朴素计算的精确度严格低于稳定计算，则此布尔值为 `True`。对于所有指定的测试输入，它们的量级都很小，预计朴素方法会遭受严重的抵消，产生比 `expm1` 函数大得多的相对误差。因此，我们预期所有 $10$ 个布尔结果都将为 `True`。\n\n最终输出是这些计算值的集合：$\\hat{\\varepsilon}$，$x_{\\mathrm{crit}}$，$y_{\\mathrm{alt}}(x_{\\mathrm{crit}})$，以及 $10$ 个布尔结果 $b(x_i)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Solves the numerical analysis problem as specified.\n    1. Computes machine epsilon.\n    2. Finds the critical value x_crit where exp(x)-1 underflows to 0.\n    3. Computes the stable alternative expm1(x_crit).\n    4. Compares relative errors for a test suite of inputs.\n    \"\"\"\n    \n    # Task 1: Compute machine epsilon (eps_hat) for float64 by iterative halving.\n    # We are looking for the smallest positive float64 'eps' such that 1.0 + eps > 1.0.\n    eps = np.float64(1.0)\n    # The loop finds the largest power-of-two smaller than or equal to the true machine epsilon.\n    # The true epsilon is the *first* value that fails 1+eps > 1, so the last one that passes is what we want.\n    # A more precise way is to check 1.0 + eps/2.0.\n    # Let `one = np.float64(1.0)`. Find eps s.t. `one + eps > one` and `one + eps/2 == one`.\n    current_eps = np.float64(1.0)\n    while np.float64(1.0) + current_eps / np.float64(2.0) > np.float64(1.0):\n        current_eps /= np.float64(2.0)\n    eps_hat = current_eps\n\n    # Task 2: Determine the critical value x_crit using a bisection search.\n    # We are looking for the supremum x > 0 such that naive exp(x) - 1 == 0.\n    # This happens when exp(x) is rounded to 1.0.\n    # The search space is bounded by 0 and a value known to be too large, like eps_hat.\n    low = np.float64(0.0)\n    high = eps_hat\n    # 100 iterations are sufficient for double precision convergence.\n    for _ in range(100):\n        mid = low + (high - low) / np.float64(2.0)\n        # Check if the naive computation results in zero\n        if np.exp(mid) - np.float64(1.0) == np.float64(0.0):\n            # If so, mid is a candidate; try larger values.\n            low = mid\n        else:\n            # If not, mid is too large.\n            high = mid\n    x_crit = low\n\n    # Task 3: Compute the value using the cancellation-free implementation.\n    y_alt_x_crit = np.expm1(x_crit)\n\n    # Task 4: Compare relative errors for the test suite.\n    \n    # Set precision for the high-precision reference calculation.\n    getcontext().prec = 50\n\n    # Define the test suite of inputs.\n    test_inputs = [\n        x_crit,\n        x_crit / np.float64(2.0),\n        eps_hat,\n        eps_hat / np.float64(2.0),\n        np.sqrt(eps_hat),\n        -x_crit,\n        -x_crit / np.float64(2.0),\n        -eps_hat,\n        -eps_hat / np.float64(2.0),\n        -np.sqrt(eps_hat)\n    ]\n\n    boolean_results = []\n    for x_float in test_inputs:\n        x_dec = Decimal(x_float)\n        \n        # Compute high-precision \"true\" value\n        true_val = x_dec.exp() - Decimal(1)\n\n        # Compute values using naive and stable methods in float64\n        naive_val = np.exp(x_float) - np.float64(1.0)\n        alt_val = np.expm1(x_float)\n        \n        # Convert to Decimal for high-precision error calculation\n        naive_val_dec = Decimal(naive_val)\n        alt_val_dec = Decimal(alt_val)\n\n        # Avoid division by zero if true_val is zero (not possible for these inputs)\n        if true_val == Decimal(0):\n            # This case shouldn't be reached with the given test inputs.\n            # If it were, relative error is ill-defined. We could define error as absolute.\n            # For this problem, we assume it's non-zero.\n            rel_err_naive = Decimal('inf') if naive_val_dec != 0 else Decimal(0)\n            rel_err_alt = Decimal('inf') if alt_val_dec != 0 else Decimal(0)\n        else:\n            rel_err_naive = abs(naive_val_dec - true_val) / abs(true_val)\n            rel_err_alt = abs(alt_val_dec - true_val) / abs(true_val)\n        \n        # Compare relative errors\n        is_naive_worse = rel_err_naive > rel_err_alt\n        boolean_results.append(is_naive_worse)\n\n    # Assemble the final list of results.\n    final_results = [eps_hat, x_crit, y_alt_x_crit] + boolean_results\n    \n    # Format the final list as a string per problem specification.\n    # Booleans must be lowercase 'true' or 'false'.\n    str_results = []\n    for item in final_results:\n        if isinstance(item, bool):\n            str_results.append(str(item).lower())\n        else:\n            str_results.append(str(item))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str_results)}]\")\n\nsolve()\n```", "id": "3250061"}]}