{"hands_on_practices": [{"introduction": "分析算法复杂度的第一步通常是计算其执行的基本操作次数。本练习提供了一个简单明了的场景，旨在帮助你实践这项基本技能。通过这个例子[@problem_id:1349082]，你将理解为什么在大O表示法中我们忽略常数因子，而更关注运行时间如何随输入规模的变化而增长。", "problem": "一位工程师正在为一个社交媒体平台开发一个系统，用于验证其用户账户的完整性。他们设计了一个名为 `verifyAllAccounts` 的算法，该算法接受一个包含 $n$ 个用户个人资料的列表作为输入。该算法会逐一遍历这 $n$ 个个人资料。对于每个单独的个人资料，它会调用一个名为 `runComplianceScan` 的子程序。这个 `runComplianceScan` 子程序被设计用来执行一组固定的、包含1000个基本计算操作（例如数据字段比较和哈希检查），以确保账户符合平台的服务条款。无论个人资料中的具体数据或用户总数 $n$ 是多少，`runComplianceScan` 执行的操作数量始终是 1000。\n\n假设访问列表中的每个个人资料花费常数时间，那么整个 `verifyAllAccounts` 算法的渐进时间复杂度（大O表示法）作为用户数量 $n$ 的函数是什么？\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(1000^n)$\n\nF. $O(1)$", "solution": "为了确定 `verifyAllAccounts` 算法的时间复杂度，我们需要分析其执行的基本操作总数，该总数是输入大小 $n$ 的函数。设 $T(n)$ 表示这个操作总数。\n\n该算法包含一个主循环，它会遍历 $n$ 个用户个人资料中的每一个。这个结构可以建模为一个从 $i=1$ 到 $n$ 的 `for` 循环。\n\n对于主循环的每次迭代（即，对于每个用户个人资料），算法都会调用 `runComplianceScan` 子程序。问题陈述 `runComplianceScan` 执行常数数量的操作，具体为 1000。\n\n因此，在第一次迭代中（针对第一个用户），执行 1000 次操作。\n在第二次迭代中（针对第二个用户），又执行 1000 次操作。\n这个过程对所有 $n$ 个用户都持续进行。\n\n为了求出总操作数 $T(n)$，我们将主循环的 $n$ 次迭代中每次执行的操作数相加。由于每次迭代都恰好贡献 1000 次操作，总数是：\n$$T(n) = \\sum_{i=1}^{n} 1000$$\n这等价于将 1000 自身相加 $n$ 次：\n$$T(n) = 1000 + 1000 + \\dots + 1000 \\quad (n \\text{ 次})$$\n$$T(n) = 1000 \\cdot n$$\n\n现在，我们必须求出 $T(n)$ 的大O复杂度。根据大O表示法的定义，如果存在正常数 $c$ 和 $n_0$，使得对于所有 $n \\ge n_0$ 都满足 $0 \\le T(n) \\le c \\cdot g(n)$，那么函数 $T(n)$ 就属于 $O(g(n))$。\n\n在我们的例子中，$T(n) = 1000n$。我们在寻找能作为 $T(n)$ 上界的最简单的函数 $g(n)$。让我们测试函数 $g(n) = n$。\n我们需要检查是否存在某个常数 $c$ 和某个 $n_0$，使得对于所有 $n \\ge n_0$ 都有 $1000n \\le c \\cdot n$。\n如果我们选择常数 $c = 1000$，不等式就变为 $1000n \\le 1000n$。这对于所有 $n \\ge 1$ 都成立。所以，我们可以选择 $c=1000$ 和 $n_0=1$。\n既然我们找到了这样的常数，我们可以得出结论：$T(n)$ 属于 $O(n)$。\n\n在大O分析中，常数因子被忽略，因为我们关心的是当 $n$ 变得非常大时函数的增长率。函数 $1000n$ 随 $n$ 线性增长，就像函数 $n$ 一样。因此，渐进时间复杂度是 $O(n)$。\n\n将我们的结果与给定选项进行比较：\nA. $O(\\log n)$: 错误。对数增长比线性增长慢得多。\nB. $O(n)$: 正确。运行时间随着用户数量线性增长。\nC. $O(n \\log n)$: 错误。这是超线性增长，在高效的排序算法中很常见。\nD. $O(n^2)$: 错误。这是平方增长，是嵌套循环的典型特征，其中内层循环的迭代次数也依赖于 $n$。\nE. $O(1000^n)$: 错误。这是指数增长，远大于实际的线性增长。\nF. $O(1)$: 错误。常数时间复杂度意味着运行时间与 $n$无关。\n\n因此，正确的时间复杂度是 $O(n)$。", "answer": "$$\\boxed{B}$$", "id": "1349082"}, {"introduction": "在掌握了简单循环的分析之后，下一步是分析更复杂的算法结构，例如朴素的模式搜索。这个问题[@problem_id:3215980]将引导你识别并分析“最坏情况”，这是算法分析中的一个核心概念，用于确定算法性能的上限。通过这个练习，你将学会如何对一个具有多个输入参数（$N$ 和 $M$）的算法进行复杂度分析。", "problem": "一个数字档案馆将每个音符存储为一个整数代码，形成一个长度为 $N$ 的序列。一个长度为 $M$ 的目标旋律以另一个整数代码序列的形式给出。在随机存取机（RAM）模型下，考虑以下朴素的模式匹配过程，其中每个基本操作（包括单个整数相等性检查和索引递增）的成本为常数：在旋律与较长乐曲的每个可能对齐位置 $i \\in \\{0, 1, \\dots, N - M\\}$，从左到右比较旋律的音符与乐曲的相应子序列，一旦出现不匹配或完成 $M$ 次成功比较后立即停止。\n\n从大O记号的形式化定义和基本操作计数模型出发，推导这种朴素方法在最坏情况下执行的音符比较次数，作为 $N$ 和 $M$ 的函数，然后简化为关于 $N$ 和 $M$ 的大O时间复杂度。假设 $1 \\leq M \\leq N$ 并且存在一个在每个对齐位置都使比较次数最大化的对抗序列。将您的最终答案表示为单个大O表达式。", "solution": "问题要求朴素模式匹配算法的最坏情况时间复杂度。分析将首先确定最坏情况下的确切比较次数，然后根据其形式化定义将此计数简化为大O记号。\n\n对于双变量函数 $f(N, M)$，大O记号的形式化定义如下：$f(N, M) = O(g(N, M))$ 当且仅当存在正常数 $c$、$N_0$ 和 $M_0$，使得对于所有满足问题约束条件的 $N \\ge N_0$ 和 $M \\ge M_0$，不等式 $0 \\le |f(N, M)| \\le c \\cdot |g(N, M)|$ 成立。\n\n设乐曲由长度为 $N$ 的整数序列 $P$ 表示，目标旋律由长度为 $M$ 的整数序列 $T$ 表示。给定的约束条件是 $1 \\le M \\le N$。该算法通过测试每个可能的对齐位置来检查模式 $T$ 是否存在于文本 $P$ 中。\n\n一个对齐位置由文本 $P$ 中的起始索引 $i$ 定义。长度为 $M$ 的模式 $T$ 可以与 $P$ 中从索引 $i=0$ 到 $i=N-M$ 开始的子序列对齐。因此，需要检查的不同对齐位置的总数为 $(N - M) - 0 + 1 = N - M + 1$。\n\n对于每个对齐位置 $i$，算法执行一系列音符比较。它将旋律的第 $j$ 个音符 $T[j]$ 与乐曲中对应的音符 $P[i+j]$ 进行比较，其中 $j=0, 1, \\dots, M-1$。这个过程持续进行，直到发现不匹配（即 $T[j] \\neq P[i+j]$），或者旋律的所有 $M$ 个音符都已比较并发现匹配为止。因此，对于单个对齐位置 $i$，基本操作（比较）的次数在 $1$（如果在 $j=0$ 处发生不匹配）和 $M$（如果前 $M-1$ 个音符匹配，或所有 $M$ 个音符都匹配）之间。\n\n问题要求进行最坏情况分析。这涉及到确定可能的最大比较次数。“一个在每个对齐位置都使比较次数最大化的对抗序列” 这句话意味着，对于每一个对齐位置 $i$，执行的比较次数都是最大的。一个对齐位置的最大比较次数是 $M$。这种情况发生在模式的前 $M-1$ 个字符与文本的相应字符匹配时，迫使算法继续进行第 $M$ 次比较。\n\n我们必须验证这样的“最坏情况”文本和模式可以存在。考虑一个旋律 $T$，它由 $M-1$ 个相同的音符后跟一个不同的音符组成，例如，$T = (a, a, \\dots, a, b)$。设乐曲 $P$ 由 $N$ 个第一种类型的相同音符组成，$P = (a, a, \\dots, a)$。在任何对齐位置 $i \\in \\{0, 1, \\dots, N-M\\}$，算法将比较 $T[j]$ 与 $P[i+j]$。对于 $j \\in \\{0, 1, \\dots, M-2\\}$，比较将是 $T[j]=a$ 对 $P[i+j]=a$，这是一个匹配。算法将继续进行直到在索引 $j=M-1$ 处的第 $M$ 次比较，此时它比较 $T[M-1]=b$ 与 $P[i+M-1]=a$。这是一个不匹配。因此，对于每个对齐位置 $i$，都恰好执行了 $M$ 次比较。\n\n在这种最坏情况下，总比较次数（我们表示为 $C(N, M)$）是 对齐位置的数量 与 每个对齐位置执行的比较次数 的乘积：\n$$C(N, M) = (\\text{对齐位置数}) \\times (\\text{每次对齐的比较次数})$$\n$$C(N, M) = (N - M + 1) M$$\n\n为了用大O记号表示它，我们需要找到一个简单的函数 $g(N, M)$ 作为 $C(N, M)$ 的渐近上界。让我们展开 $C(N, M)$ 的表达式：\n$$C(N, M) = NM - M^2 + M$$\n$g(N, M)$ 的一个自然选择是 $NM$，因为它代表两个输入大小的乘积，并且通常是具有嵌套循环的算法的特征。让我们应用形式化定义来验证是否 $C(N, M) = O(NM)$。我们需要证明存在一个正常数 $c$，使得对于所有足够大的 $N$ 和 $M$（满足 $1 \\le M \\le N$），不等式 $(N - M + 1) M \\le c \\cdot NM$ 成立。\n\n我们来分析这个不等式：\n$$NM - M^2 + M \\le c \\cdot NM$$\n由于问题指定 $M \\ge 1$，因此有 $M \\le M^2$。这意味着项 $M - M^2$ 是非正的，即 $M - M^2 \\le 0$。\n因此，我们可以写出：\n$$NM - M^2 + M \\le NM$$\n对于选择 $c=1$，这个不等式成立。它对所有满足 $1 \\le M \\le N$ 的 $N, M$ 都有效。因此，根据形式化定义，我们已经证明了 $C(N, M) = O(NM)$。\n\n该过程的总时间复杂度与音符比较的次数成正比，因为在RAM模型下，每次比较都被认为是常数时间操作。因此，朴素模式匹配算法的最坏情况时间复杂度是 $O(NM)$。", "answer": "$$\n\\boxed{O(NM)}\n$$", "id": "3215980"}, {"introduction": "尽管大O表示法是理解算法扩展性的基石，但它并不能揭示性能的全貌。这个发人深省的练习[@problem_id:3215939]探讨了为什么两个具有相同渐近复杂度的算法在实际运行中会表现出天壤之别的性能差异。它揭示了计算机体系结构（如内存访问模式和缓存机制）对程序实际运行时间的关键影响。", "problem": "考虑大小为 $N \\times N$ 的稠密实数矩阵 $A$、$B$ 和 $C$，它们以行主序存储，其中元素 $X[i,j]$ 位于与 $iN + j$ 成正比的内存地址处。乘积 $C = A \\cdot B$ 通过一个三重嵌套循环算法计算，无论循环顺序如何，该算法都执行 $N^3$ 次乘加运算。现代中央处理器（CPU）以包含 $L$ 个连续元素的缓存行（cache line）为单位获取内存，并受益于空间局部性（spatial locality）和时间局部性（temporal locality）。所有三种被标记为 $\\text{ijk}$、$\\text{ikj}$ 和 $\\text{jik}$ 的循环顺序都实现了相同的算术序列，并且具有 $\\mathcal{O}(N^3)$ 的渐近时间复杂度。\n\n选择所有能正确解释为什么这些循环顺序在实际应用中通常表现出巨大性能差异的陈述，并指出在行主序数据上，哪些因素使得某一种顺序通常比其他顺序更快：\n- A. 渐近界 $\\mathcal{O}(N^3)$ 隐藏了由内存层次结构（memory hierarchy）引起的常数因子；改变循环顺序会改变空间和时间局部性，因此缓存未命中（cache miss）的数量可能会相差一个与 $L$ 成正比的因子，这在现代硬件上主导了运行时间。\n- B. $\\text{ikj}$ 顺序执行的浮点运算次数比 $\\text{ijk}$ 和 $\\text{jik}$ 顺序少，从而将算术计数降低到 $\\mathcal{O}(N^3)$ 以下。\n- C. 在行主序存储中，$\\text{ijk}$ 和 $\\text{jik}$ 顺序在最内层循环中沿列访问 $B[k,j]$（步长为 $N$），每个缓存行大约只产生一个有用元素，并且导致较差的转译后备缓冲器（TLB）行为，而 $\\text{ikj}$ 顺序在最内层循环中沿行访问 $B[k,j]$（步长为 1），这使得硬件预取（hardware prefetch）和单指令多数据（SIMD）向量化成为可能；这导致了显著不同的运行时间。\n- D. 所有三种顺序的性能都相同，因为编译器总是在编译时将循环重排为最优布局，而不考虑数据布局和依赖关系。\n- E. 在具有单位成本内存访问和无限大缓存的理想化随机存取存储器（RAM）模型下，所有三种顺序的性能将无法区分；大O表示法抽象掉了这些与机器相关的效应，这解释了为什么它不能预测这些差异。", "solution": "该问题陈述是计算科学中的一个有效练习，探讨了算法设计在现代计算机体系结构上的实际性能影响。它有科学依据、提法得当、客观，且没有任何逻辑或事实错误。它正确地设置了一个经典场景，展示了在忽略内存层次结构时渐近分析（$\\mathcal{O}$表示法）的局限性。因此，我们可以进行全面分析。\n\n问题的核心在于矩阵乘积 $C = A \\cdot B$ 的计算，其中 $A, B, C$ 是 $N \\times N$ 的矩阵。一个元素 $C[i,j]$ 的矩阵乘法定义为：\n$$C[i,j] = \\sum_{k=0}^{N-1} A[i,k] \\cdot B[k,j]$$\n对于所有 $i,j \\in \\{0, 1, \\dots, N-1\\}$ 都必须执行此计算。一个简单的实现使用三个嵌套循环来遍历索引 $i, j, k$。这些循环的顺序会显著影响性能，这是因为现代CPU处理内存访问的方式，特别是通过缓存。矩阵以行主序存储，意味着元素 $X[i,j]$ 的内存地址与 $iN+j$ 成正比。沿行顺序访问元素（例如，$X[i,j]$ 后跟 $X[i,j+1]$）是步长为1的访问，这是高效的。沿列向下访问元素（例如，$X[i,j]$ 后跟 $X[i+1,j]$）是步长为 $N$ 的访问，对于大的 $N$ 来说是低效的。\n\n让我们分析每种顺序下最内层循环的内存访问模式，因为这个循环执行 $N^3$ 次并主导了运行时间。\n\n1.  **`ijk` 顺序：**\n    ```\n    for i = 0 to N-1\n      for j = 0 to N-1\n        // C[i,j] is accumulated in this loop\n        for k = 0 to N-1\n          C[i,j] += A[i,k] * B[k,j]\n    ```\n    在最内层循环（关于 $k$）中，索引 $i$ 和 $j$ 是固定的。\n    - **`A[i,k]`**：顺序访问 $A$ 的第 $i$ 行的元素。这是步长为1的访问，表现出良好的空间局部性。\n    - **`B[k,j]`**：访问 $B$ 的第 $j$ 列的元素。在行主序存储中，这是步长为 $N$ 的访问。这具有很差的空间局部性；如果 $N$ 大于缓存行中的元素数量，每次访问都可能导致缓存未命中。\n    - **`C[i,j]`**：同一个元素被重复访问，用作累加器。这表现出极好的时间局部性，并且很可能被保存在CPU寄存器中。\n\n2.  **`ikj` 顺序：**\n    ```\n    for i = 0 to N-1\n      for k = 0 to N-1\n        // A[i,k] is a scalar for the inner loop\n        for j = 0 to N-1\n          C[i,j] += A[i,k] * B[k,j]\n    ```\n    在最内层循环（关于 $j$）中，索引 $i$ 和 $k$ 是固定的。\n    - **`A[i,k]`**：在内层循环的所有 $N$ 次迭代中，同一个元素被重复访问。这具有极好的时间局部性。\n    - **`B[k,j]`**：顺序访问 $B$ 的第 $k$ 行的元素。这是步长为1的访问，表现出良好的空间局部性。\n    - **`C[i,j]`**：顺序访问 $C$ 的第 $i$ 行的元素。这也是步长为1的访问，具有良好的空间局部性。\n    这个顺序是最高效的，因为最内层循环中的所有内存访问都是局部的（无论是时间局部性还是步长为1的空间局部性）。\n\n3.  **`jik` 顺序：**\n    ```\n    for j = 0 to N-1\n      for i = 0 to N-1\n        // C[i,j] is accumulated in this loop\n        for k = 0 to N-1\n          C[i,j] += A[i,k] * B[k,j]\n    ```\n    在最内层循环（关于 $k$）中，索引 $j$ 和 $i$ 是固定的。\n    - **`A[i,k]`**：顺序访问 $A$ 的第 $i$ 行的元素。这是步长为1的访问（良好的空间局部性）。\n    - **`B[k,j]`**：访问 $B$ 的第 $j$ 列的元素。这是步长为 $N$ 的访问（较差的空间局部性），与 `ijk` 顺序中的情况相同。\n    - **`C[i,j]`**：同一个元素被重复访问（极好的时间局部性）。\n    `jik` 顺序的最内层循环具有与 `ijk` 顺序相同的内存访问特性。两者都受到对矩阵 $B$ 的非局部访问的瓶颈限制。\n\n基于此分析，在具有内存层次结构的系统上，`ikj` 顺序的性能将显著优于 `ijk` 和 `jik`。性能差异源于缓存未命中的数量。对于 `ijk`/`jik` 顺序，缓存未命中的数量级为 $\\mathcal{O}(N^3)$，而对于 `ikj` 顺序，其数量级为 $\\mathcal{O}(N^3/L)$，其中 $L$ 是每个缓存行的数据元素数量。\n\n现在我们来评估每个选项。\n\n**A. 渐近界 $\\mathcal{O}(N^3)$ 隐藏了由内存层次结构（memory hierarchy）引起的常数因子；改变循环顺序会改变空间和时间局部性，因此缓存未命中（cache miss）的数量可能会相差一个与 $L$ 成正比的因子，这在现代硬件上主导了运行时间。**\n这个陈述是对情况的准确、高层次的总结。$\\mathcal{O}(N^3)$ 复杂度指的是算术运算的数量，假设每次运算的成本为单位成本。在实际硬件上，内存访问成本不均匀，这个假设不成立。大O表示法隐藏的“常数因子”实际上是缓存大小、延迟、带宽和缓存行大小 $L$ 的复杂函数。正如我们的分析所示，低效顺序（`ijk`、`jik`）的缓存未命中次数约为 $N^3$，而高效顺序（`ikj`）的缓存未命中次数约为 $N^3/L$。未命中次数的比率确实与 $L$ 成正比。由于内存访问远慢于算术运算，对于大型矩阵，这种缓存性能的差异是影响总运行时间的主导因素。\n**结论：正确。**\n\n**B. $\\text{ikj}$ 顺序执行的浮点运算次数比 $\\text{ijk}$ 和 $\\text{jik}$ 顺序少，从而将算术计数降低到 $\\mathcal{O}(N^3)$ 以下。**\n这个陈述是错误的。问题陈述本身就正确地指出，所有三种顺序都执行 $N^3$ 次乘加运算。标准算法的浮点运算总数为 $2N^3 - N^2$，即 $\\mathcal{O}(N^3)$。重排循环会改变加法和乘法的执行顺序（例如，`ijk` 计算点积，`ikj` 执行向量-标量乘积和加法），但它不会改变这些运算的总数。\n**结论：不正确。**\n\n**C. 在行主序存储中，$\\text{ijk}$ 和 $\\text{jik}$ 顺序在最内层循环中沿列访问 $B[k,j]$（步长为 $N$），每个缓存行大约只产生一个有用元素，并且导致较差的转译后备缓冲器（TLB）行为，而 $\\text{ikj}$ 顺序在最内层循环中沿行访问 $B[k,j]$（步长为 1），这使得硬件预取（hardware prefetch）和单指令多数据（SIMD）向量化成为可能；这导致了显著不同的运行时间。**\n这个陈述为性能差异提供了详细且技术上正确的解释。我们的分析证实了 `ijk` 和 `jik` 顺序在最内层循环中涉及对矩阵 $B$ 的步长为 $N$ 的访问。这导致了较差的缓存利用率（“每个缓存行只有一个有用元素”）。如果矩阵足够大，以至于每一步长为 $N$ 的访问都落在新的内存页上，这种大步长也可能导致频繁的转译后备缓冲器（TLB）未命中。相比之下，`ikj` 顺序以良好的局部性访问所有矩阵（对 `B` 和 `C` 是步长为1的访问，对 `A` 是时间局部性）。可预测的步长为1的访问模式对于硬件预取器自动在需要之前将数据取入缓存，以及编译器生成SIMD（向量）指令（该指令可同时对多个数据元素执行相同操作）来说是理想的。这些因素共同造成了巨大的性能差距。\n**结论：正确。**\n\n**D. 所有三种顺序的性能都相同，因为编译器总是在编译时将循环重排为最优布局，而不考虑数据布局和依赖关系。**\n这个陈述是不正确的。虽然现代优化编译器可以并且确实会执行像循环交换这样的循环变换，但它们这样做的能力是有限的。编译器必须能够证明这种变换是安全的并且保留了程序的语义。指针别名、循环内的函数调用，或者矩阵维度在编译时未知等情况都可能阻止此类优化。声称它们“总是”成功是一种严重的夸大，并且在经验上是错误的；如果这是真的，矩阵内核的性能调优就不会成为一个主要的研究领域。此外，优化严重依赖于数据布局，而不是独立于它。\n**结论：不正确。**\n\n**E. 在具有单位成本内存访问和无限大缓存的理想化随机存取存储器（RAM）模型下，所有三种顺序的性能将无法区分；大O表示法抽象掉了这些与机器相关的效应，这解释了为什么它不能预测这些差异。**\n这个陈述正确地指出了标准渐近分析所基于的理论计算机科学模型。在RAM模型中，每个内存操作都有统一的成本，通常被认为是 $\\mathcal{O}(1)$。无限大的缓存有效地模拟了该模型。在此模型下，总运行时间与算术运算的数量成正比。由于所有三种循环顺序执行相同数量的运算（$\\mathcal{O}(N^3)$），它们的性能确实将无法区分。该陈述正确地得出结论，大O表示法基于这种理想化模型，抽象掉了内存层次结构的实际影响，因此本身不足以预测观察到的性能差异。\n**结论：正确。**", "answer": "$$\\boxed{ACE}$$", "id": "3215939"}]}