{"hands_on_practices": [{"introduction": "一个问题本身的敏感度（其条件数）和我们用于解决该问题的算法的稳定性之间存在着至关重要的区别。这个练习将通过一个经典的例子来阐明这一概念：当 $x$ 接近于零时计算函数 $f(x) = \\sqrt{1+x}-1$。通过从第一性原理推导其条件数，你将发现这个问题本身是良态的，但一种直接的计算方法会因灾难性的舍入误差而失败。这项实践旨在训练你识别并修正数值不稳定的计算，这是编写可靠科学代码的一项核心技能 [@problem_id:3216339]。", "problem": "考虑一个标量计算问题，即对于定义域为 $x>-1$ 且 $x$ 接近于 $0$ 的输入，计算函数 $f(x)=\\sqrt{1+x}-1$。您的目标是评估该问题对 $x$ 的微小扰动的敏感程度，并找出一个能够减轻因减法抵消 (subtractive cancellation) 导致的有效数字损失 (loss of significance) 的代数等价表达式。从第一性原理出发：使用条件数的定义，即在扰动趋于零的极限情况下，相对输出变化与相对输入变化之比；并利用输入和输出微小变化之间的微分关系。不要假定任何预先推导出的条件数公式。\n\n任务：\n- 通过将输入的无穷小变化 $\\mathrm{d}x$ 与输出的相应变化 $\\mathrm{d}f$ 联系起来，推导该问题在点 $x$ 处的绝对条件数。\n- 在极限 $\\mathrm{d}x \\to 0$ 下，通过构造相对输出变化与相对输入变化的比值，推导该问题在点 $x$ 处的相对条件数。\n- 解释为什么对于小的 $x$，直接计算表达式 $f(x)=\\sqrt{1+x}-1$ 会遭受灾难性抵消，并为 $f(x)$ 构造一个能避免相近数相减的代数等价表达式。通过引用基本代数恒等式来证明你构造的合理性。\n- 使用单位舍入误差为 $u$ 的标准一阶浮点误差模型（即，对实数的每次基本算术运算返回的结果是精确值乘以一个因子 $(1+\\delta)$，其中 $|\\delta|\\le u$），比较当 $x \\to 0$ 时，直接表达式和你的稳定表达式的相对前向误差的主阶行为。\n- 作为最终答案，给出相对条件数作为 $x$ 的函数的简化封闭形式表达式。\n\n无需数值近似；将你的最终答案表示为一个无单位的、精确的解析表达式。", "solution": "用户提供了一个来自数值分析领域的有效问题陈述。该问题具有科学依据、是适定的且客观的。它要求分析在 $x$ 接近 $0$ 时计算 $f(x)=\\sqrt{1+x}-1$ 的问题。我将按顺序处理每个任务来给出解答。\n\n首先，我们推导该问题的绝对条件数。绝对条件数将输入的绝对变化与输出的相应绝对变化联系起来。对于一个可微标量函数 $f(x)$，输入的一个无穷小变化 $\\mathrm{d}x$ 会导致输出的一个无穷小变化 $\\mathrm{d}f$，由一阶近似 $\\mathrm{d}f = f'(x) \\mathrm{d}x$ 给出。绝对条件数 $\\kappa_{abs}(x)$ 是输出对该变化的敏感度大小，即 $|f'(x)|$。\n函数为 $f(x) = (1+x)^{1/2} - 1$。它关于 $x$ 的导数是：\n$$ f'(x) = \\frac{\\mathrm{d}}{\\mathrm{d}x} \\left( (1+x)^{1/2} - 1 \\right) = \\frac{1}{2} (1+x)^{-1/2} = \\frac{1}{2\\sqrt{1+x}} $$\n由于定义域为 $x > -1$，项 $\\sqrt{1+x}$ 是实数且为正，因此我们不需要对 $f'(x)$ 取绝对值。\n绝对条件数为：\n$$ \\kappa_{abs}(x) = |f'(x)| = \\frac{1}{2\\sqrt{1+x}} $$\n对于接近 $0$ 的 $x$，$\\kappa_{abs}(x) \\approx \\frac{1}{2}$。这表明 $x$ 的微小绝对误差不会被显著放大，说明该问题在绝对意义上是良态的。\n\n接下来，我们推导该问题的相对条件数。相对条件数 $\\kappa_{rel}(x)$ 定义为输出的相对变化与输入的相对变化的极限比值。\n$$ \\kappa_{rel}(x) = \\lim_{\\Delta x \\to 0} \\frac{|\\Delta f / f(x)|}{|\\Delta x / x|} = \\frac{|\\mathrm{d}f / f(x)|}{|\\mathrm{d}x / x|} = \\left| \\frac{\\mathrm{d}f}{\\mathrm{d}x} \\cdot \\frac{x}{f(x)} \\right| = |f'(x)| \\left| \\frac{x}{f(x)} \\right| $$\n代入 $f'(x)$ 和 $f(x)$ 的表达式：\n$$ \\kappa_{rel}(x) = \\left| \\frac{1}{2\\sqrt{1+x}} \\cdot \\frac{x}{\\sqrt{1+x}-1} \\right| $$\n该表达式在 $x=0$ 时是不定式，并且对于小的 $x$ 似乎会变得很大。然而，我们可以通过给分子和分母同乘以分母项的共轭式 $\\sqrt{1+x}+1$ 来对其进行化简：\n$$ \\kappa_{rel}(x) = \\left| \\frac{1}{2\\sqrt{1+x}} \\cdot \\frac{x}{\\sqrt{1+x}-1} \\cdot \\frac{\\sqrt{1+x}+1}{\\sqrt{1+x}+1} \\right| = \\left| \\frac{x(\\sqrt{1+x}+1)}{2\\sqrt{1+x} \\left( (\\sqrt{1+x})^2 - 1^2 \\right)} \\right| $$\n$$ \\kappa_{rel}(x) = \\left| \\frac{x(\\sqrt{1+x}+1)}{2\\sqrt{1+x} (1+x-1)} \\right| = \\left| \\frac{x(\\sqrt{1+x}+1)}{2x\\sqrt{1+x}} \\right| $$\n对于 $x \\neq 0$，我们可以消去因子 $x$：\n$$ \\kappa_{rel}(x) = \\left| \\frac{\\sqrt{1+x}+1}{2\\sqrt{1+x}} \\right| $$\n由于 $x > -1$，分子和分母均为正，因此绝对值是多余的。相对条件数的最终简化形式为：\n$$ \\kappa_{rel}(x) = \\frac{\\sqrt{1+x}+1}{2\\sqrt{1+x}} $$\n为评估在 $x=0$ 附近的条件数，我们取其极限：\n$$ \\lim_{x \\to 0} \\kappa_{rel}(x) = \\lim_{x \\to 0} \\frac{\\sqrt{1+x}+1}{2\\sqrt{1+x}} = \\frac{\\sqrt{1+0}+1}{2\\sqrt{1+0}} = \\frac{1+1}{2} = 1 $$\n接近 $1$ 的相对条件数表明，对于接近 $0$ 的 $x$，计算 $f(x)$ 的问题是内在良态的。输出的相对误差应该与输入的相对误差具有大致相同的量级。\n\n“有效数字损失”的问题并非源于问题的条件数，而是源于所使用的特定计算算法。当 $x$ 接近 $0$ 时，在浮点运算中计算直接表达式 $f(x) = \\sqrt{1+x}-1$ 会遭受灾难性抵消。在这种情况下，$1+x$ 略大于 $1$，因此 $\\sqrt{1+x}$ 是一个非常接近 $1$ 的数。减法 $\\sqrt{1+x}-1$ 涉及两个几乎相等的数。在浮点表示中，这两个数的高位有效数字是相同的，会相互抵消，使得结果主要由低位的有效数字决定，而这些数字已经被前面步骤（如计算平方根）的舍入误差所污染。这导致了严重的相对精度损失。\n\n为了创建一个稳定的算法，我们必须找到一个能够避免这种减法运算的代数等价表达式。用于推导条件数的化简过程提供了这样一个表达式。通过乘以共轭式，我们得到：\n$$ f(x) = (\\sqrt{1+x}-1) \\cdot \\frac{\\sqrt{1+x}+1}{\\sqrt{1+x}+1} = \\frac{(1+x)-1}{\\sqrt{1+x}+1} = \\frac{x}{\\sqrt{1+x}+1} $$\n这个替代形式，我们称之为 $g(x) = \\frac{x}{\\sqrt{1+x}+1}$，对于所有 $x \\in (-1, \\infty)$ 都与 $f(x)$ 代数等价。在计算上，对于小的 $x$ 它要优越得多。对于 $x \\approx 0$，分母 $\\sqrt{1+x}+1$ 约等于 $2$。该表达式涉及一次加法和一次除法，在此情境下，两者都不会导致有效数字损失。\n\n最后，我们比较前向误差的传播。令 $\\text{fl}(\\cdot)$ 表示浮点计算的结果，并令 $u$ 为单位舍入误差。每次基本算术运算引入的相对误差至多为 $u$。\n\n对于不稳定形式 $f(x) = \\sqrt{1+x}-1$，主要误差来自于计算平方根然后进行减法。设平方根的计算值为 $\\hat{y} = \\text{fl}(\\sqrt{1+x}) = \\sqrt{1+x}(1+\\epsilon)$，其中 $|\\epsilon| \\lesssim u$。最终的计算结果为 $\\hat{f}(x) = \\text{fl}(\\hat{y}-1) = (\\hat{y}-1)(1+\\delta) = (\\sqrt{1+x}(1+\\epsilon)-1)(1+\\delta)$，其中 $|\\delta| \\le u$。\n$$ \\hat{f}(x) = (\\sqrt{1+x}-1 + \\epsilon\\sqrt{1+x})(1+\\delta) \\approx f(x) + \\epsilon\\sqrt{1+x} $$\n绝对误差为 $\\hat{f}(x)-f(x) \\approx \\epsilon\\sqrt{1+x}$。相对前向误差为：\n$$ \\frac{|\\hat{f}(x)-f(x)|}{|f(x)|} \\approx \\frac{|\\epsilon\\sqrt{1+x}|}{|f(x)|} $$\n对于小的 $x$，我们知道 $f(x) \\approx x/2$ 且 $\\sqrt{1+x} \\approx 1$。因此，相对误差表现为：\n$$ \\frac{|\\epsilon \\cdot 1|}{|x/2|} = \\frac{2|\\epsilon|}{|x|} $$\n由于 $|\\epsilon|$ 与 $u$ 同阶，相对误差的阶为 $O(u/|x|)$。当 $x \\to 0$ 时，此误差无界增长，证明了该算法的不稳定性。\n\n对于稳定形式 $g(x) = \\frac{x}{\\sqrt{1+x}+1}$，计算过程为 $\\hat{d} = \\text{fl}(\\text{fl}(\\sqrt{1+x})+1)$，然后是 $\\hat{g}(x) = \\text{fl}(x/\\hat{d})$。经过类似的分析，总相对误差由几次稳定运算累积而成。\n设 $\\hat{d} = (\\sqrt{1+x}(1+\\epsilon_1)+1)(1+\\epsilon_2) = (\\sqrt{1+x}+1)(1+\\frac{\\epsilon_1\\sqrt{1+x}}{\\sqrt{1+x}+1})(1+\\epsilon_2)$。\n最终的计算值为 $\\hat{g}(x) = \\frac{x}{\\hat{d}}(1+\\epsilon_3) \\approx \\frac{x}{(\\sqrt{1+x}+1)} \\frac{1+\\epsilon_3}{(1+\\epsilon_2)(1+\\frac{\\epsilon_1\\sqrt{1+x}}{\\sqrt{1+x}+1})}$。\n$$ \\hat{g}(x) \\approx g(x) (1+\\epsilon_3-\\epsilon_2 - \\frac{\\epsilon_1\\sqrt{1+x}}{\\sqrt{1+x}+1}) $$\n相对误差为 $\\frac{|\\hat{g}(x)-g(x)|}{|g(x)|} \\approx |\\epsilon_3-\\epsilon_2 - \\frac{\\epsilon_1\\sqrt{1+x}}{\\sqrt{1+x}+1}|$。\n当 $x \\to 0$ 时，此误差趋近于 $|\\epsilon_3-\\epsilon_2 - \\epsilon_1/2|$，其大小被单位舍入误差 $u$ 的一个小的倍数所限制。当 $x \\to 0$ 时，相对误差不会增长，这表明该算法是稳定的。\n\n所要求的最终答案是相对条件数的封闭形式表达式。", "answer": "$$ \\boxed{\\frac{\\sqrt{1+x} + 1}{2\\sqrt{1+x}}} $$", "id": "3216339"}, {"introduction": "理解了条件数的基本概念后，我们来深入探究一个问题的数学结构如何影响其敏感度。这个练习将焦点放在函数求值问题上，特别是当求值点接近函数的根时。你将通过分析发现，如果一个根的重数大于一，那么在根附近对函数求值的条件数会急剧恶化，揭示了函数“平坦度”与数值病态之间的深刻联系 [@problem_id:3216334]。", "problem": "考虑一个标量问题，即在输入存在微小扰动的情况下，在点 $x$ 处计算函数 $y = f(x)$ 的值。一个问题的条件数定义为，在扰动趋于零的极限下，输入的微小相对变化被放大为输出的相对变化的（局部）因子。从条件数的这个基本定义出发，推导求值映射 $x \\mapsto f(x)$ 在点 $x$（其中 $f(x) \\neq 0$）处的点态条件数的表达式。\n\n假设 $f$ 在 $x=a$ 处有一个重数为 $m>1$ 的根，即 $f(x) = (x-a)^{m} h(x)$，其中 $h$ 可微且 $h(a) \\neq 0$。使用从定义推导出的表达式，确定当 $x \\to a$ 时条件数的主阶渐进行为。解释为什么重数 $m>1$ 的存在会影响求值问题在根附近的条件性。\n\n最后，应用你的推理来比较在 $x=1$ 附近的函数 $f(x) = (x-1)^{3}$ 和 $g(x) = x-1$。计算当 $x$ 沿实轴趋于 $1$ 时，它们的条件数之比 $\\kappa_{f}(x)/\\kappa_{g}(x)$ 的极限。将你的最终答案表示为没有舍入的精确值。", "solution": "问题要求推导函数求值的条件数，分析其在重根附近的渐进行为，对结果进行解释，并将其应用于一个具体案例。我们将按步骤进行。\n\n首先，我们推导求值映射 $x \\mapsto f(x)$ 的点态条件数的一般表达式。条件数 $\\kappa_f(x)$ 定义为输出的相对变化与输入的相对变化之比的极限。设输入 $x$ 受到一个微小量 $\\delta x$ 的扰动，得到扰动后的输入 $x + \\delta x$。相应的输出为 $f(x+\\delta x)$。\n\n输入的相对变化为 $\\frac{\\delta x}{x}$。我们假设 $x \\neq 0$。\n输出的绝对变化为 $\\delta y = f(x + \\delta x) - f(x)$。\n输出的相对变化为 $\\frac{\\delta y}{y} = \\frac{f(x + \\delta x) - f(x)}{f(x)}$。我们假设 $f(x) \\neq 0$。\n\n根据定义，条件数为：\n$$ \\kappa_f(x) = \\lim_{\\delta x \\to 0} \\left| \\frac{\\text{relative change in output}}{\\text{relative change in input}} \\right| = \\lim_{\\delta x \\to 0} \\left| \\frac{ \\frac{f(x + \\delta x) - f(x)}{f(x)} }{ \\frac{\\delta x}{x} } \\right| $$\n重新整理极限内的项得到：\n$$ \\kappa_f(x) = \\lim_{\\delta x \\to 0} \\left| \\frac{f(x + \\delta x) - f(x)}{\\delta x} \\cdot \\frac{x}{f(x)} \\right| $$\n假设 $f$ 在 $x$ 处可微，则乘积的第一部分是导数 $f'(x)$ 的定义：\n$$ \\lim_{\\delta x \\to 0} \\frac{f(x + \\delta x) - f(x)}{\\delta x} = f'(x) $$\n因此，条件数的表达式变为：\n$$ \\kappa_f(x) = \\left| f'(x) \\cdot \\frac{x}{f(x)} \\right| = \\left| \\frac{x f'(x)}{f(x)} \\right| $$\n\n接下来，我们分析这个条件数在重数 $m > 1$ 的根附近的行为。函数给定为 $f(x) = (x-a)^m h(x)$，其中 $h$ 可微且 $h(a) \\neq 0$。\n我们首先使用乘法法则计算导数 $f'(x)$：\n$$ f'(x) = \\frac{d}{dx} \\left[ (x-a)^m h(x) \\right] = m(x-a)^{m-1}h(x) + (x-a)^m h'(x) $$\n现在，我们将 $f(x)$ 和 $f'(x)$ 代入条件数公式：\n$$ \\kappa_f(x) = \\left| \\frac{x \\left( m(x-a)^{m-1}h(x) + (x-a)^m h'(x) \\right)}{(x-a)^m h(x)} \\right| $$\n我们可以从分子中提出因子 $(x-a)^{m-1}$：\n$$ \\kappa_f(x) = \\left| \\frac{x (x-a)^{m-1} \\left( m h(x) + (x-a) h'(x) \\right)}{(x-a)^m h(x)} \\right| $$\n对于 $x \\neq a$，我们可以消去项 $(x-a)^{m-1}$：\n$$ \\kappa_f(x) = \\left| \\frac{x \\left( m h(x) + (x-a) h'(x) \\right)}{(x-a) h(x)} \\right| $$\n我们可以将其分成两项：\n$$ \\kappa_f(x) = \\left| \\frac{m x h(x)}{(x-a) h(x)} + \\frac{x(x-a)h'(x)}{(x-a)h(x)} \\right| = \\left| \\frac{mx}{x-a} + \\frac{x h'(x)}{h(x)} \\right| $$\n为了找到当 $x \\to a$ 时的主阶渐进行为，我们考察各项。当 $x \\to a$ 时，第二项 $\\frac{x h'(x)}{h(x)}$ 趋近于有限常数 $\\frac{a h'(a)}{h(a)}$，因为 $h(a) \\neq 0$ 且 $h'$ 在 $a$ 处连续。第一项 $\\frac{mx}{x-a}$ 趋近于 $\\frac{ma}{x-a}$，它发散到无穷大。因此，在 $x=a$ 附近，第一项主导了 $\\kappa_f(x)$ 的行为。\n主阶渐进行为是：\n$$ \\kappa_f(x) \\sim \\left| \\frac{mx}{x-a} \\right| \\quad \\text{as } x \\to a $$\n由于 $x \\to a$，我们可以将分子中的 $x$ 替换为 $a$，因为与分母相比，它是一个缓变部分。\n$$ \\kappa_f(x) \\approx \\left| \\frac{ma}{x-a} \\right| \\quad \\text{for } x \\text{ near } a $$\n\n重数 $m>1$ 的存在使得在根 $x=a$ 附近计算 $f(x)$ 的问题是病态的。当 $x \\to a$ 时，条件数 $\\kappa_f(x)$ 无界增长。这是因为当 $x \\to a$ 时，$f(x)$ 和 $f'(x)$ 都趋于零，但速率不同。函数 $f(x)$ 的行为类似于 $(x-a)^m$，而其导数 $f'(x)$ 的行为类似于 $(x-a)^{m-1}$。因此，比率 $f'(x)/f(x)$ 的行为类似于 $\\frac{m}{x-a}$，是发散的。$x$ 中的一个小的相对扰动被这个大因子放大，导致 $f(x)$ 的一个大的相对变化。这种放大的幅度与重数 $m$ 成正比。更高的重数导致根处的函数更“平坦”，从而加剧了病态性。单根（$m=1$）在根附近也会导致病态的求值问题，但重根（$m>1$）的病态性要严重 $m$ 倍。\n\n最后，我们将此应用于 $x=1$ 附近的具体函数 $f(x) = (x-1)^3$ 和 $g(x) = x-1$。\n对于 $f(x) = (x-1)^3$，我们在 $a=1$ 处有一个重数为 $m_f=3$ 的根。\n其导数为 $f'(x) = 3(x-1)^2$。\n条件数为：\n$$ \\kappa_f(x) = \\left| \\frac{x f'(x)}{f(x)} \\right| = \\left| \\frac{x \\cdot 3(x-1)^2}{(x-1)^3} \\right| = \\left| \\frac{3x}{x-1} \\right| $$\n对于 $g(x) = x-1$，我们在 $a=1$ 处有一个重数为 $m_g=1$ 的根。\n其导数为 $g'(x) = 1$。\n条件数为：\n$$ \\kappa_g(x) = \\left| \\frac{x g'(x)}{g(x)} \\right| = \\left| \\frac{x \\cdot 1}{x-1} \\right| = \\left| \\frac{x}{x-1} \\right| $$\n题目要求我们计算当 $x \\to 1$ 时它们条件数之比的极限：\n$$ \\lim_{x \\to 1} \\frac{\\kappa_f(x)}{\\kappa_g(x)} = \\lim_{x \\to 1} \\frac{\\left| \\frac{3x}{x-1} \\right|}{\\left| \\frac{x}{x-1} \\right|} $$\n对于 $x \\neq 1$，我们可以简化表达式：\n$$ \\frac{\\left| \\frac{3x}{x-1} \\right|}{\\left| \\frac{x}{x-1} \\right|} = \\frac{\\frac{|3x|}{|x-1|}}{\\frac{|x|}{|x-1|}} = \\frac{|3x|}{|x|} = \\frac{3|x|}{|x|} $$\n由于 $x \\to 1$，在 1 的一个邻域内 $x$ 必不为零，所以我们可以消去 $|x|$：\n$$ \\lim_{x \\to 1} \\frac{\\kappa_f(x)}{\\kappa_g(x)} = \\lim_{x \\to 1} 3 = 3 $$\n这个结果与我们的渐进分析一致，该分析表明，在公共根附近，条件数之比应趋近于重数之比，即 $m_f/m_g = 3/1 = 3$。", "answer": "$$\\boxed{3}$$", "id": "3216334"}, {"introduction": "理论是基础，但亲眼见证数值效应能极大地加深理解。本练习将引导你从标量问题转向线性代数中的一个实际计算挑战。你将编写一个程序，使用著名的希尔伯特矩阵（一个典型的病态矩阵）来实证研究线性系统求解中的精度损失。通过这个动手编码任务，你将经验性地验证条件数、前向误差和后向误差（残差）之间的理论关系，并观察解的精度是如何随着矩阵规模和条件数的增长而灾难性地恶化的 [@problem_id:2428600]。", "problem": "编写一个完整的程序，以经验性地展示在标准浮点运算中，问题条件性对求解线性系统精度的影响。考虑线性系统 $A x = b$，其中 $A$ 是一个 $n \\times n$ 的希尔伯特矩阵，其元素为 $A_{i j} = \\dfrac{1}{i + j - 1}$，其中 $1 \\le i,j \\le n$。对于每个测试用例，定义精确解向量 $x_{\\text{true}} \\in \\mathbb{R}^n$ 为 $x_{\\text{true}} = \\mathbf{1}$ (所有元素均为1)，并构造右侧项 $b = A x_{\\text{true}}$。然后，使用符合电气和电子工程师协会（IEEE）754 双精度（binary$64$）语义的标准浮点运算来计算数值解 $\\hat{x}$。使用 $\\hat{x}$，计算以下量：\n- 2-范数条件数 $\\kappa_2(A) = \\|A\\|_2 \\,\\|A^{-1}\\|_2$。\n- 2-范数下的相对前向误差，$\\dfrac{\\|\\hat{x} - x_{\\text{true}}\\|_2}{\\|x_{\\text{true}}\\|_2}$。\n- 缩放残差（一个归一化的后向误差代理），$\\dfrac{\\|b - A \\hat{x}\\|_2}{\\|A\\|_2 \\,\\|\\hat{x}\\|_2 + \\|b\\|_2}$。\n- 解中正确十进制数字的估计数量，定义为 $\\max\\!\\bigl(0,\\,-\\log_{10}(\\max(\\text{相对前向误差}, \\varepsilon)))$，其中 $\\varepsilon$ 表示最小的正规格化 IEEE 754 双精度数。\n\n测试套件：\n针对以下问题规模 $n$ 评估上述各项：\n- $n = 3$，\n- $n = 6$，\n- $n = 10$，\n- $n = 12$。\n\n所有向量和矩阵范数均为谱范数（即矩阵 2-范数和向量 2-范数）。不涉及角度。不涉及物理单位。\n\n您的程序必须生成单行输出，其中包含所有测试结果，形式为方括号括起来的逗号分隔列表，其中每个测试结果本身是一个形式为 $[n,\\;\\kappa_2(A),\\;\\text{相对前向误差},\\;\\text{缩放残差},\\;\\text{估计位数}]$ 的列表。因此，最终输出必须是表示列表的列表的单行文本，不得包含任何额外文本。例如，其结构必须类似于 $[[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],[\\cdot,\\cdot,\\cdot,\\cdot,\\cdot],\\ldots]$，但用实际计算出的数字代替占位符。", "solution": "所提出的问题陈述是有效的。这是数值线性代数中一个适定、有科学依据的练习，旨在演示问题条件性、前向误差和后向误差等基本概念。该问题是自洽的，提供了所有必要的定义和数据。它没有违反任何科学原理、逻辑，也不包含任何歧义。我们将着手求解。\n\n该问题要求对病态条件对线性方程组 $A x = b$ 的解的影响进行经验性研究。矩阵 $A$ 被选为 $n \\times n$ 的希尔伯特矩阵，这是一个严重病态矩阵的典型例子。其元素由 $A_{i j} = \\frac{1}{i + j - 1}$ 给出，其中 $i, j$ 的范围从 $1$ 到 $n$。\n\n数值分析的核心不仅在于计算解，还在于理解其精度。我们记为 $\\hat{x}$ 的计算解的精度受两个主要因素影响：所用算法的稳定性和问题本身的内在敏感性。这种敏感性由条件数来量化。\n\n对于线性系统 $A x = b$，矩阵 $A$ 的 2-范数条件数定义为：\n$$ \\kappa_2(A) = \\|A\\|_2 \\|A^{-1}\\|_2 $$\n其中 $\\| \\cdot \\|_2$ 是谱范数（最大奇异值）。大条件数 $\\kappa_2(A) \\gg 1$ 表示一个病态问题，其中输入数据（$A$ 或 $b$）的微小相对扰动可能导致解 $x$ 的巨大相对变化。\n\n当我们使用浮点运算求解 $A x = b$ 时，不可避免地会引入舍入误差。一个后向稳定算法，例如标准求解器采用的 LU 分解，会产生一个计算解 $\\hat{x}$，它是某个微扰问题的精确解：\n$$ (A + \\delta A) \\hat{x} = b + \\delta b $$\n这些扰动 $\\delta A$ 和 $\\delta b$ 的“小”是衡量该算法后向稳定性的指标。数值分析中的一个关键结果确立了相对前向误差的以下界限：\n$$ \\frac{\\|\\hat{x} - x_{\\text{true}}\\|_2}{\\|x_{\\text{true}}\\|_2} \\le \\kappa_2(A) \\left( \\frac{\\|\\delta A\\|_2}{\\|A\\|_2} + \\frac{\\|\\delta b\\|_2}{\\|b\\|_2} \\right) $$\n右侧括号内的项是相对后向误差。对于一个在机器精度 $\\varepsilon_{\\text{mach}}$ 下运行的后向稳定算法，后向误差通常为 $\\mathcal{O}(\\varepsilon_{\\text{mach}})$ 阶。IEEE 754 双精度的机器精度约为 $2.22 \\times 10^{-16}$。因此，我们预期相对前向误差的界限约为 $\\kappa_2(A) \\cdot \\varepsilon_{\\text{mach}}$。这表明大条件数会放大不可避免的舍入误差，可能破坏解的精度。\n\n残差向量定义为 $r = b - A \\hat{x}$。残差的范数 $\\|r\\|_2$ 与后向误差有关。问题要求计算一个特定的缩放残差：\n$$ \\frac{\\|b - A \\hat{x}\\|_2}{\\|A\\|_2 \\,\\|\\hat{x}\\|_2 + \\|b\\|_2} $$\n这个量可作为后向误差的归一化代理。由于求解器的后向稳定性，我们预期该值会保持很小，约为 $\\varepsilon_{\\text{mach}}$ 阶，即使条件数增长且前向误差爆炸式增长。这是一个至关重要的区别：小残差并不保证小前向误差。\n\n最后，我们估计解中正确十进制数字的数量。这与相对前向误差直接相关。如果相对误差为 $10^{-k}$，则解的精度大约为 $k$ 位十进制数字。给定的公式 $\\max\\!\\bigl(0,\\,-\\log_{10}(\\max(\\text{相对前向误差}, \\varepsilon)))$ 将此形式化。$\\varepsilon$ 项是最小的正规格化双精度数，约为 $2.225 \\times 10^{-308}$，它可以防止对零取对数，并处理误差小于可表示精度的情况。\n\n我们现在将对指定的矩阵规模测试套件 $n \\in \\{3, 6, 10, 12\\}$ 执行这些计算。对于每个 $n$：\n1.  构造 $n \\times n$ 的希尔伯特矩阵 $A$。\n2.  定义真解 $x_{\\text{true}}$ 为一个包含 $n$ 个 1 的向量。\n3.  计算右侧项 $b = A x_{\\text{true}}$。\n4.  使用标准线性求解器求解数值解 $\\hat{x}$。\n5.  计算四个指定的量：$\\kappa_2(A)$、相对前向误差、缩放残差和估计位数。\n\n结果将经验性地验证该理论。希尔伯特矩阵的条件数随 $n$ 急剧增长。对于较小的 $n$（例如 $n=3$），$\\kappa_2(A)$ 的值适中，我们预期会得到一个相当精确的解。随着 $n$ 增加到 $10$ 和 $12$，$\\kappa_2(A)$ 将变得巨大（$> 10^{13}$），导致相对前向误差达到 $1$ 阶或更高，意味着精度完全丧失。在整个过程中，缩放残差应保持很小，这表明了算法的后向稳定性，与病态问题糟糕的前向精度形成对比。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import hilbert\n\ndef solve_hilbert_experiment():\n    \"\"\"\n    Runs the Hilbert matrix experiment as described in the problem statement\n    and prints the results to standard output.\n    \"\"\"\n    test_cases = [3, 6, 10, 12]\n    results = []\n    smallest_norm_val = np.finfo(np.float64).smallest_normal\n\n    for n in test_cases:\n        # Construct the Hilbert matrix and the exact solution/RHS.\n        A = hilbert(n)\n        x_true = np.ones(n)\n        b = A @ x_true\n        \n        # Compute the numerical solution.\n        x_hat = np.linalg.solve(A, b)\n        \n        # Calculate condition number.\n        kappa_A = np.linalg.cond(A, 2)\n        \n        # Calculate relative forward error.\n        rel_fwd_err = np.linalg.norm(x_hat - x_true, 2) / np.linalg.norm(x_true, 2)\n        \n        # Calculate scaled residual.\n        residual_norm = np.linalg.norm(b - A @ x_hat, 2)\n        norm_A = np.linalg.norm(A, 2)\n        norm_x_hat = np.linalg.norm(x_hat, 2)\n        norm_b = np.linalg.norm(b, 2)\n        scaled_residual = residual_norm / (norm_A * norm_x_hat + norm_b)\n        \n        # Calculate estimated number of correct digits.\n        est_digits = max(0.0, -np.log10(max(rel_fwd_err, smallest_norm_val)))\n        \n        results.append([n, kappa_A, rel_fwd_err, scaled_residual, est_digits])\n        \n    # Print the final list of lists as a single line.\n    print(str(results))\n\n# Execute the function to generate the output.\nsolve_hilbert_experiment()\n```", "id": "2428600"}]}