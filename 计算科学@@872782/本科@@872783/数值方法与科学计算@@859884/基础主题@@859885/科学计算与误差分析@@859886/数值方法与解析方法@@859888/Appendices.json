{"hands_on_practices": [{"introduction": "我们的实践探索始于一个看似简单却直观揭示解析方法局限性的问题。这个练习要求你求解方程 $x = \\cos(x)$。你将首先理解为何这个超越方程无法通过标准的代数操作得到一个封闭形式的解析解，从而必须依赖数值方法。通过这个动手实践，你将实现一个简单而强大的迭代算法，并运用压缩映射定理来严格证明你的数值解将收敛到唯一的真实解 [@problem_id:3259287]。", "problem": "考虑寻找一个实数 $x^{\\ast}$ 使得 $x^{\\ast} = \\cos(x^{\\ast})$ 的不动点问题，其中 $\\cos(\\cdot)$ 表示余弦函数，其参数以弧度为单位。您的任务是分析符号方法的局限性，使用第一性原理证明不动点的存在性和唯一性，并实现一种数值方法来近似该不动点，同时给出严格的后验误差界，所有这些都要求能以程序进行测试。\n\n1. 解析局限性。解释为什么我们不期望也在此不使用符号初等闭式解来求解 $x = \\cos(x)$。您应明确指出这是一个超越不动点方程，并以适合高年级本科生的水平，从高层次上证明为何在初等函数范围内的代数操作无法得出 $x^{\\ast}$ 的显式公式。\n\n2. 通过压缩映射证明存在性和唯一性。令 $g(x) = \\cos(x)$。仅使用基本定义和公认事实，证明 $g$ 在一个对 $g$ 保持不变的闭区间内有唯一的不动点。具体来说：\n   - 识别一个闭区间 $I \\subset \\mathbb{R}$，使得 $g(I) \\subset I$。\n   - 在 $I$ 上对导数 $g'(x)$ 进行界定，以获得一个满足 $0 \\le L  1$ 的 Lipschitz 常数 $L$。\n   - 根据 Banach 不动点定理（也称为压缩映射定理），得出结论：在 $I$ 中存在一个唯一的不动点 $x^{\\ast} \\in I$。\n\n3. 数值迭代与停止准则。考虑由初始猜测值 $x_0 \\in \\mathbb{R}$ 定义的简单不动点迭代 $x_{n+1} = g(x_n) = \\cos(x_n)$。设计一个仅基于连续迭代值的停止准则：\n   - 当索引 $n \\ge 0$ 首次满足 $\\lvert x_{n+1} - x_n \\rvert \\le \\text{tol}$ 时停止，其中 $\\text{tol}  0$ 是用户指定的容差。\n   - 设置一个硬性的迭代次数上限 $\\text{max\\_iter} \\in \\mathbb{N}$；如果在 $n = \\text{max\\_iter}$ 时仍未满足停止条件，则报告不收敛。\n\n4. 后验误差界。假设您的迭代值位于区间 $I$ 内，在该区间上 $g$ 是一个压缩映射，其 Lipschitz 常数 $L$ 满足 $0 \\le L  1$。推导并使用标准的后验误差界\n   $$\\lvert x_{n+1} - x^{\\ast} \\rvert \\le \\frac{L}{1 - L} \\lvert x_{n+1} - x_n \\rvert,$$\n   该界必须在最后一次可用迭代时计算，无论停止准则是否已满足。您的程序应使用 $L = \\sin(1)$，这对应于在不变区间 $I = [-1, 1]$ 上的压缩分析。\n\n5. 单位。角度必须以弧度为单位。不涉及其他物理单位。\n\n6. 测试套件。您的程序必须在以下测试用例上运行该方法，每个用例由一个三元组 $(x_0, \\text{tol}, \\text{max\\_iter})$ 指定：\n   - 用例 A (理想路径): $(0, 10^{-12}, 100)$，即 $x_0 = 0$，$\\text{tol} = 10^{-12}$，$\\text{max\\_iter} = 100$。\n   - 用例 B (不变集内的不同起点): $(1, 10^{-12}, 100)$。\n   - 用例 C (起点远离不变集，快速进入): $(10, 10^{-12}, 100)$。\n   - 用例 D (边界条件：迭代次数不足): $(0.5, 10^{-16}, 5)$。\n\n7. 要求的最终输出格式。对于每个测试用例，输出一个包含四项的列表：\n   - 终止时（满足停止准则或达到迭代上限时）$x^{\\ast}$ 的数值近似值。\n   - 执行的迭代次数。\n   - 一个布尔值，指示是否在迭代上限内满足了停止准则。\n   - 在最后一次可用迭代时计算的后验误差界 $\\dfrac{L}{1-L} \\lvert x_{n+1} - x_n \\rvert$，使用 $L = \\sin(1)$。\n\n   您的程序应生成单行输出，其中包含所有四个用例的结果，形式为一个用方括号括起来的逗号分隔列表，例如\n   $[ \\text{caseA\\_result}, \\text{caseB\\_result}, \\text{caseC\\_result}, \\text{caseD\\_result} ]$，\n   其中每个 $\\text{caseX\\_result}$ 本身是一个列表 $[x\\_{\\text{approx}}, \\text{iterations}, \\text{converged}, \\text{bound}]$。\n\n8. 数值报告。每个用例中的两个浮点输出，即 $x^{\\ast}$ 的近似值和后验界，在打印前必须四舍五入到 $12$ 位小数。迭代次数必须是整数，收敛标志必须是布尔值。\n\n所有角度必须以弧度为单位，所有数值都应是无量纲的。任何地方都不得使用百分号；任何比率如果需要都应表示为小数。最终输出必须是指定格式的单行文本。", "solution": "该问题陈述是数值分析中的一个有效练习。它要求对余弦函数的不动点 $x^{\\ast} = \\cos(x^{\\ast})$ 进行理论论证和数值近似。该问题具有科学依据，是适定的、客观的，并包含了完整解答所需的所有信息。\n\n### 1. 解析局限性\n\n待解方程为 $x = \\cos(x)$。这是一个超越方程，因为它将一个多项式函数 $f(x)=x$ 与一个超越函数 $g(x) = \\cos(x)$ 相等。“初等闭式解”是指用算术运算、根式、指数、对数和三角函数的有限组合来表示不动点 $x^{\\ast}$。\n\n没有通用的代数程序来求解此类方程。对于多项式方程有效的代数操作依赖于逆运算（例如，通过开平方来反转 $x^2$）。余弦函数没有可以用来从表达式 $\\cos(x)$ 中分离出 $x$ 的初等反函数。虽然其反函数 $\\arccos(y)$ 存在，但将其应用于方程 $x = \\cos(x)$ 会得到 $\\arccos(x) = \\arccos(\\cos(x))$，这会导出诸如 $\\arccos(x) = x$ 或对于整数 $k$ 的 $\\arccos(x) = -x + 2k\\pi$ 等恒等式，而这些恒等式本身就是新的超越方程，并不能分离出 $x$。\n\n无法找到闭式解是与初等函数域的代数结构相关的深层属性。证明不存在这样的解是一项不平凡的任务（与 Lindemann-Weierstrass 定理或微分 Galois 理论等成果有关，这些超出了此处的范围），但一个标准结论是，混合了代数项和超越项的方程，如 $x = \\cos(x)$，通常没有可以用标准初等函数表示的解。因此，必须借助数值方法来获得解的近似值。\n\n### 2. 通过 Banach 不动点定理证明存在性与唯一性\n\nBanach 不动点定理（或压缩映射定理）为证明不动点的存在性和唯一性提供了一个强大的工具。该定理指出，如果一个函数 $g$ 将一个完备度量空间 $(X, d)$ 映射到其自身，并且是一个压缩映射，那么 $g$ 在 $X$ 中有一个唯一的不动点。\n\n设函数为 $g(x) = \\cos(x)$，空间为一个闭区间 $I \\subset \\mathbb{R}$，其度量为标准欧几里得度量 $d(x, y) = |x - y|$。$\\mathbb{R}$ 中的闭区间是一个完备度量空间。我们必须执行两个步骤：\n\n**步骤 2a：识别一个不变区间 $I$**\n\n我们需要找到一个闭区间 $I$，使得对于任何 $x \\in I$，值 $g(x)$ 也在 $I$ 中；即 $g(I) \\subset I$。对于任何实数输入，余弦函数的值域是 $[-1, 1]$。因此，对于任何 $x \\in \\mathbb{R}$，$g(x) = \\cos(x) \\in [-1, 1]$。如果我们选择区间 $I = [-1, 1]$，那么对于任何 $x \\in I$，$g(x) = \\cos(x)$ 保证在 $[-1, 1]$ 内。因此，$g([-1, 1]) \\subset [-1, 1]$，且 $I = [-1, 1]$ 是 $g$ 的一个不变集。\n\n**步骤 2b：证明 $g$ 在 $I$ 上是一个压缩映射**\n\n如果存在一个 Lipschitz 常数 $L$ 使得 $0 \\le L  1$ 且对于所有 $x, y \\in I$，都有 $|g(x) - g(y)| \\le L|x - y|$，则函数 $g$ 是在 $I$ 上的一个压缩映射。\n\n根据中值定理，对于任何 $x, y \\in I$，在 $x$ 和 $y$ 之间存在一个点 $c$，使得 $|g(x) - g(y)| = |g'(c)||x - y|$。为了找到最小的可能 Lipschitz 常数，我们必须找到 $|g'(x)|$ 在 $I$ 上的最大值。\n\n$g(x)$ 的导数是 $g'(x) = -\\sin(x)$。在区间 $I = [-1, 1]$ 上，我们需要对 $|g'(x)| = |-\\sin(x)| = |\\sin(x)|$ 进行界定。函数 $|\\sin(x)|$ 是偶函数，并且在 $[0, 1]$ 上是增函数。因此，它在 $[-1, 1]$ 上的最大值出现在端点 $x = -1$ 和 $x = 1$ 处。最大值为 $L = \\sup_{x \\in [-1, 1]} |\\sin(x)| = \\sin(1)$。\n\n数值上，$L = \\sin(1) \\approx 0.84147$。由于 $0  1  \\pi/2$，我们知道 $0  \\sin(1)  \\sin(\\pi/2) = 1$。因此，我们找到了一个 Lipschitz 常数 $L = \\sin(1)$，满足 $0 \\le L  1$。\n\n**步骤 2c：结论**\n\n函数 $g(x) = \\cos(x)$ 将完备度量空间 $I = [-1, 1]$ 映射到自身，并且是在 $I$ 上的一个压缩映射，其常数 $L = \\sin(1)  1$。因此，根据 Banach 不动点定理，在 $[-1, 1]$ 中存在一个唯一的不动点 $x^{\\ast}$，使得 $x^{\\ast} = \\cos(x^{\\ast})$。\n\n### 3. 数值迭代与停止准则\n\nBanach 不动点定理的构造性证明为数值算法提供了基础。从一个初始猜测值 $x_0$ 开始，序列 $x_{n+1} = g(x_n) = \\cos(x_n)$（对于 $n \\ge 0$）保证收敛到唯一的不动点 $x^{\\ast}$，这对任何 $x_0 \\in \\mathbb{R}$ 都成立。这是因为第一次迭代 $x_1 = \\cos(x_0)$ 会将迭代值置于不变区间 $I = [-1, 1]$ 内，而所有后续的迭代值都将保留在 $I$ 中，从而保证了收敛性。\n\n在实践中，迭代必须在有限步数后终止。该算法如下：\n1. 初始化 $x_0$、一个容差 $\\text{tol}  0$ 和最大迭代次数 $\\text{max\\_iter}$。\n2. 对于 $n = 0, 1, 2, \\dots, \\text{max\\_iter}-1$：\n   a. 计算下一个迭代值：$x_{n+1} = \\cos(x_n)$。\n   b. 检查停止条件：如果 $|x_{n+1} - x_n| \\le \\text{tol}$，则认为序列已收敛。过程终止，并将 $x_{n+1}$ 作为 $x^{\\ast}$ 的近似值。\n   c. 如果条件未满足，则继续下一次迭代。\n3. 如果循环完成时仍未满足停止条件，则该方法未在给定的迭代预算内收敛。报告最终的迭代值 $x_{\\text{max\\_iter}}$。\n\n### 4. 后验误差界\n\n数值计算的一个重要部分是估计近似值的误差。后验误差界仅使用迭代本身可获得的量，来估计当前迭代值与真实不动点之间的距离 $|x_{n+1} - x^{\\ast}|$。\n\n推导过程如下，针对在区间 $I$ 内的迭代值，其中 $g$ 是常数为 $L$ 的压缩映射：\n不动点性质为 $x^{\\ast} = g(x^{\\ast})$。到不动点的距离是：\n$$|x_{n+1} - x^{\\ast}| = |g(x_n) - g(x^{\\ast})|$$\n根据压缩性质，我们有：\n$$|g(x_n) - g(x^{\\ast})| \\le L |x_n - x^{\\ast}|$$\n所以， $|x_{n+1} - x^{\\ast}| \\le L |x_n - x^{\\ast}|$。为了将其与已知量联系起来，我们对 $|x_n - x^{\\ast}|$ 使用三角不等式：\n$$|x_n - x^{\\ast}| = |x_n - x_{n+1} + x_{n+1} - x^{\\ast}| \\le |x_n - x_{n+1}| + |x_{n+1} - x^{\\ast}|$$\n将此代回到关于 $|x_{n+1} - x^{\\ast}|$ 的不等式中：\n$$|x_{n+1} - x^{\\ast}| \\le L (|x_n - x_{n+1}| + |x_{n+1} - x^{\\ast}|)$$\n重新整理各项以分离出 $|x_{n+1} - x^{\\ast}|$：\n$$|x_{n+1} - x^{\\ast}| - L|x_{n+1} - x^{\\ast}| \\le L|x_n - x_{n+1}|$$\n$$(1 - L)|x_{n+1} - x^{\\ast}| \\le L|x_{n+1} - x_n|$$\n由于 $L  1$，$(1-L)$ 是正数，所以我们可以用它来除，而不用改变不等号的方向：\n$$|x_{n+1} - x^{\\ast}| \\le \\frac{L}{1 - L} |x_{n+1} - x_n|$$\n这就是所要求的后验误差界。实现时将在最后一次迭代步骤计算此值，使用指定的常数 $L = \\sin(1)$，无论是否已达到收敛。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the fixed point problem x = cos(x) for a suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (x0, tol, max_iter).\n    test_cases = [\n        (0.0, 1e-12, 100),  # Case A\n        (1.0, 1e-12, 100),  # Case B\n        (10.0, 1e-12, 100), # Case C\n        (0.5, 1e-16, 5),   # Case D\n    ]\n\n    # The Lipschitz constant for g(x) = cos(x) on the interval [-1, 1].\n    L = np.sin(1)\n    \n    # List to store the results for each test case.\n    results = []\n    \n    for x0, tol, max_iter in test_cases:\n        x_current = float(x0)\n        n_iters = 0\n        converged = False\n        diff = 0.0\n\n        for i in range(max_iter):\n            n_iters = i + 1\n            x_next = np.cos(x_current)\n            diff = np.abs(x_next - x_current)\n            \n            if diff = tol:\n                converged = True\n                x_current = x_next\n                break\n            \n            x_current = x_next\n\n        # At this point, the loop has terminated.\n        # x_current holds the final approximation.\n        # n_iters holds the total number of iterations performed.\n        # converged indicates if the tolerance was met.\n        # diff holds the last computed |x_{n+1} - x_n|.\n        \n        # Calculate the a posteriori error bound\n        # The formula is |x_n+1 - x*| = (L / (1 - L)) * |x_n+1 - x_n|\n        # This is computed at the last available iteration step.\n        bound = (L / (1.0 - L)) * diff\n\n        # Round the floating-point results to 12 decimal places as required.\n        x_approx_rounded = round(x_current, 12)\n        bound_rounded = round(bound, 12)\n        \n        # Assemble the result for this test case.\n        case_result = [x_approx_rounded, n_iters, converged, bound_rounded]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The format is a string representation of a list of lists.\n    # Using str() on the list of lists naturally produces the desired format,\n    # including spaces after commas inside the sublist representations, which\n    # aligns with the visual layout of a standard Python list representation.\n    # Example: [[0.739..., 58, True, 0.0], [...]]\n    print(str(results))\n\nsolve()\n```", "id": "3259287"}, {"introduction": "当一个问题存在解析解，但该解无法用我们熟悉的初等函数表达时，我们该怎么办？本练习将探讨高斯函数 $e^{-x^2}$ 的积分，这是概率论和物理学中的一个基石，但它的原函数无法用初等函数写出。这个实践将向你展示不同的数值积分方法——从辛普森法则到高斯求积——如何有效地逼近这类积分，从而揭示了在纯解析分析需要定义新函数的地方，数值方法所具有的实用威力 [@problem_id:3259211]。", "problem": "考虑高斯函数 $f(x)=e^{-x^{2}}$ 在区间 $[0,1]$ 上的定积分。根据定积分作为黎曼和极限的定义以及指数函数通过其幂级数的定义，可知函数 $e^{-x^{2}}$ 在 $\\mathbb{R}$ 上是光滑且解析的。在初等函数（由多项式、指数函数、对数函数、三角函数以及它们的有限次代数运算和复合构成）的范畴内，$e^{-x^{2}}$ 没有初等原函数。这启发我们引入误差函数，其定义为\n$$\\operatorname{erf}(x)=\\frac{2}{\\sqrt{\\pi}}\\int_{0}^{x} e^{-t^{2}}\\,dt,$$\n这是一个特殊函数，在相差一个常数因子的情况下表示了 $e^{-x^{2}}$ 的原函数。因此，\n$$\\int_{0}^{1} e^{-x^{2}}\\,dx=\\frac{\\sqrt{\\pi}}{2}\\,\\operatorname{erf}(1).$$\n你的任务是编写一个完整的、可运行的程序，将三种数值方法与由特殊函数 $\\operatorname{erf}(x)$ 给出的解析基准进行比较。\n\n从基本原理（定积分的定义和多项式插值）出发，实现对 $\\int_{0}^{1} e^{-x^{2}}\\,dx$ 的以下三种数值近似方法：\n\n- 在 $[0,1]$ 上使用复合 Simpson 法则，将区间划分为 $N$ 个等长子区间，其中 $N$ 为偶数。\n- 在 $[0,1]$ 上使用 $n$ 阶 Gauss–Legendre 求积法，通过将标准节点和权重从 $[-1,1]$ 映射到 $[0,1]$ 来实现。\n- 一种基于 Maclaurin 级数的方法：使用 $e^{y}$ 的幂级数，即 $e^{y}=\\sum_{k=0}^{\\infty}\\frac{y^{k}}{k!}$，代入 $y=-x^{2}$，并在 $[0,1]$ 上逐项积分，生成一个包含 $m$ 项的部分和。使用所得级数的恰好 $m$ 项来近似该积分。\n\n使用以下参数值测试套件，并严格按照所示顺序，生成一组相对于解析基准 $\\frac{\\sqrt{\\pi}}{2}\\,\\operatorname{erf}(1)$ 的绝对误差：\n\n1. 复合 Simpson 法则，$N=2$。\n2. 复合 Simpson 法则，$N=10$。\n3. 复合 Simpson 法则，$N=100$。\n4. Gauss–Legendre 求积法，$n=2$。\n5. Gauss–Legendre 求积法，$n=4$。\n6. Gauss–Legendre 求积法，$n=8$。\n7. 级数部分和，$m=1$。\n8. 级数部分和，$m=3$。\n9. 级数部分和，$m=5$。\n10. 级数部分和，$m=20$。\n\n对于每个测试用例，计算绝对误差\n$$E=\\left|\\text{近似值}-\\frac{\\sqrt{\\pi}}{2}\\,\\operatorname{erf}(1)\\right|.$$\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内容为按上述顺序排列的结果。每个数字必须是浮点值，并采用科学记数法格式，小数点后精确到 12 位（例如，$1.234567890123\\mathrm{e}{-04}$）。不应打印任何额外文本。\n\n注意：本题不涉及物理单位或角度。所有输出均为无量纲实数。", "solution": "用户要求编写一个程序，用于比较三种数值积分方法与高斯函数 $f(x) = e^{-x^2}$ 在区间 $[0, 1]$ 上定积分的解析解。\n\n### 步骤 1：问题验证\n我将首先提取给定信息并验证问题陈述。\n\n**给定条件：**\n- **待积函数：** $f(x) = e^{-x^2}$。\n- **积分区间：** $[0, 1]$。\n- **积分的解析表达式：** $\\int_{0}^{1} e^{-x^{2}}\\,dx=\\frac{\\sqrt{\\pi}}{2}\\,\\operatorname{erf}(1)$。\n- **需要实现的数值方法：**\n    1.  **复合 Simpson 法则：** 使用 $N$ 个等长子区间，其中 $N$ 是偶数。\n    2.  **Gauss–Legendre 求积法：** 使用 $n$ 阶方法，将节点和权重从 $[-1, 1]$ 映射到 $[0, 1]$。\n    3.  **基于 Maclaurin 级数的方法：** 使用 $e^{-x^2}$ 的积分幂级数的前 $m$ 项。\n- **测试套件（按顺序）：**\n    1.  Simpson 法则，$N=2$。\n    2.  Simpson 法则，$N=10$。\n    3.  Simpson 法则，$N=100$。\n    4.  Gauss–Legendre 求积法，$n=2$。\n    5.  Gauss–Legendre 求积法，$n=4$。\n    6.  Gauss–Legendre 求积法，$n=8$。\n    7.  级数法，$m=1$。\n    8.  级数法，$m=3$。\n    9.  级数法，$m=5$。\n    10. 级数法，$m=20$。\n- **误差度量：** 绝对误差，$E = \\left|\\text{近似值}-\\frac{\\sqrt{\\pi}}{2}\\,\\operatorname{erf}(1)\\right|$。\n- **输出格式：** 单行输出，包含一个由方括号括起来的、由 10 个绝对误差组成的逗号分隔列表。每个数字都必须是科学记数法格式，且有 12 位小数（例如，$1.234567890123\\mathrm{e}{-04}$）。\n\n**验证：**\n1.  **科学性：** 该问题基于数值分析和微积分中标准的、公认的概念。函数 $e^{-x^2}$、误差函数 $\\operatorname{erf}(x)$、Simpson 法则、Gauss-Legendre 求积法和 Maclaurin 级数都是数学和科学计算中的基本主题。所有数学陈述都是正确的。\n2.  **适定性：** 该问题描述得非常精确。函数、区间、方法、参数和输出格式都有清晰明确的定义。对于每个指定的测试用例，都存在唯一的数值结果。\n3.  **客观性：** 该问题以精确、客观的语言陈述，不含任何主观性或意见。\n\n**结论：** 该问题是有效的。它在科学上是合理的，是适定的、客观的，并且完全属于数值方法的范畴。\n\n### 步骤 2：解法构思\n\n目标是使用三种不同的数值方案计算定积分 $I = \\int_{0}^{1} e^{-x^2} dx$ 的值，并将其与精确的解析值进行比较。\n\n**解析基准**\n问题正确地指出，该积分与误差函数 $\\operatorname{erf}(x)$ 相关，其定义为：\n$$ \\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} e^{-t^2} dt $$\n根据此定义，积分的精确值为：\n$$ I = \\int_{0}^{1} e^{-x^2} dx = \\frac{\\sqrt{\\pi}}{2} \\operatorname{erf}(1) $$\n该值将作为我们比较所有数值近似值的参考基准。\n\n**方法 1：复合 Simpson 法则**\n复合 Simpson 法则通过将区间 $[a, b]$ 划分为偶数个（$N$ 个）宽度为 $h = (b-a)/N$ 的子区间来近似积分 $\\int_a^b f(x) dx$。其公式为：\n$$ \\int_a^b f(x) dx \\approx \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{j=1}^{N/2} f(x_{2j-1}) + 2\\sum_{j=1}^{N/2-1} f(x_{2j}) + f(x_N) \\right] $$\n其中 $x_j = a + jh$。对于本问题，$a=0$，$b=1$，$h=1/N$，且 $f(x)=e^{-x^2}$。将针对 $N \\in \\{2, 10, 100\\}$ 计算近似值。\n\n**方法 2：Gauss–Legendre 求积法**\nGauss-Legendre 求积法为标准区间 $[-1, 1]$ 上的积分提供了一个高阶近似：\n$$ \\int_{-1}^{1} g(t) dt \\approx \\sum_{i=1}^{n} w_i g(t_i) $$\n其中 $t_i$ 是 $n$ 次 Legendre 多项式 $P_n(t)$ 的根（节点），$w_i$ 是相应的权重。为了将其应用于区间 $[0, 1]$，我们进行线性变量替换：\n$$ x = \\frac{1-0}{2} t + \\frac{1+0}{2} = \\frac{t+1}{2} \\implies dx = \\frac{1}{2} dt $$\n积分变换为：\n$$ I = \\int_{0}^{1} f(x) dx = \\int_{-1}^{1} f\\left(\\frac{t+1}{2}\\right) \\frac{1}{2} dt $$\n因此，求积近似值为：\n$$ I \\approx \\frac{1}{2} \\sum_{i=1}^{n} w_i f\\left(\\frac{t_i+1}{2}\\right) $$\n节点 $t_i$ 和权重 $w_i$ 将使用标准数值库函数获得。将针对阶数 $n \\in \\{2, 4, 8\\}$ 进行计算。\n\n**方法 3：Maclaurin 级数积分**\n指数函数的 Maclaurin 级数为 $e^y = \\sum_{k=0}^{\\infty} \\frac{y^k}{k!}$。通过代入 $y = -x^2$，我们得到被积函数的级数：\n$$ e^{-x^2} = \\sum_{k=0}^{\\infty} \\frac{(-x^2)^k}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k x^{2k}}{k!} $$\n该级数在任何紧区间上都一致收敛，因此允许在 $[0, 1]$ 上进行逐项积分：\n$$ I = \\int_{0}^{1} \\left( \\sum_{k=0}^{\\infty} \\frac{(-1)^k x^{2k}}{k!} \\right) dx = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\int_{0}^{1} x^{2k} dx $$\n计算 $x^{2k}$ 的简单积分可得：\n$$ \\int_{0}^{1} x^{2k} dx = \\left[ \\frac{x^{2k+1}}{2k+1} \\right]_0^1 = \\frac{1}{2k+1} $$\n因此，积分的精确值由以下无穷级数给出：\n$$ I = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!(2k+1)} $$\n数值近似值将是该级数的前 $m$ 项的部分和，记作 $S_m$：\n$$ S_m = \\sum_{k=0}^{m-1} \\frac{(-1)^k}{k!(2k+1)} $$\n将针对 $m \\in \\{1, 3, 5, 20\\}$ 计算此和。\n\n**误差计算与实现**\n对于 10 个测试用例中的每一个，计算出相应的近似值 $I_{\\text{approx}}$。然后按如下方式计算绝对误差 $E$：\n$$ E = |I_{\\text{approx}} - I_{\\text{exact}}| = \\left|I_{\\text{approx}} - \\frac{\\sqrt{\\pi}}{2}\\operatorname{erf}(1)\\right| $$\n这些步骤将在一个 Python 程序中实现，使用 `numpy` 库进行数值运算，使用标准 `math` 库进行误差函数 $\\operatorname{erf}$ 和阶乘的计算。最后将包含 10 个误差的列表按指定格式进行格式化并打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes absolute errors for three numerical integration methods against an analytical baseline.\n    \"\"\"\n\n    # Define the function to be integrated\n    def f(x):\n        return np.exp(-x**2)\n\n    def simpson_rule(func, a, b, N):\n        \"\"\"\n        Computes the definite integral of a function using the composite Simpson's rule.\n        \n        Args:\n            func: The function to integrate.\n            a, b: The limits of integration.\n            N: The number of subintervals (must be even).\n        \n        Returns:\n            The approximate value of the integral.\n        \"\"\"\n        if N % 2 != 0:\n            raise ValueError(\"N must be an even integer for Simpson's rule.\")\n        h = (b - a) / N\n        x = np.linspace(a, b, N + 1)\n        y = func(x)\n        \n        s = y[0] + y[-1] + 4 * np.sum(y[1:-1:2]) + 2 * np.sum(y[2:-1:2])\n        return (h / 3) * s\n\n    def gauss_legendre_quad(func, a, b, n):\n        \"\"\"\n        Computes the definite integral using Gauss-Legendre quadrature.\n\n        Args:\n            func: The function to integrate.\n            a, b: The limits of integration.\n            n: The order of the quadrature.\n\n        Returns:\n            The approximate value of the integral.\n        \"\"\"\n        nodes, weights = np.polynomial.legendre.leggauss(n)\n        \n        # Transform nodes from [-1, 1] to [a, b]\n        transformed_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        integral = 0.5 * (b - a) * np.sum(weights * func(transformed_nodes))\n        return integral\n\n    def series_approx(m):\n        \"\"\"\n        Approximates the integral using the first m terms of its Maclaurin series expansion.\n\n        Args:\n            m: The number of terms to use in the partial sum.\n\n        Returns:\n            The approximate value of the integral.\n        \"\"\"\n        total_sum = 0.0\n        for k in range(m):\n            term = ((-1)**k) / (math.factorial(k) * (2*k + 1))\n            total_sum += term\n        return total_sum\n\n    # Define the analytical baseline value for the integral\n    analytical_value = (np.sqrt(np.pi) / 2.0) * math.erf(1)\n\n    # Define the test cases from the problem statement.\n    # The format is (method_name, parameter_value)\n    test_cases = [\n        ('simpson', 2),\n        ('simpson', 10),\n        ('simpson', 100),\n        ('gauss', 2),\n        ('gauss', 4),\n        ('gauss', 8),\n        ('series', 1),\n        ('series', 3),\n        ('series', 5),\n        ('series', 20),\n    ]\n\n    results = []\n    # Integration interval\n    a, b = 0, 1\n\n    for method, param in test_cases:\n        if method == 'simpson':\n            approximation = simpson_rule(f, a, b, param)\n        elif method == 'gauss':\n            approximation = gauss_legendre_quad(f, a, b, param)\n        elif method == 'series':\n            approximation = series_approx(param)\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n\n        error = np.abs(approximation - analytical_value)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3259211"}, {"introduction": "即使我们拥有一个简单而精确的解析解，工作也并非总是一劳永逸。本练习将探讨一个隐藏在中学数学最著名公式之一——二次方程求根公式——中的陷阱。你将亲眼见证，当使用有限精度浮点数进行计算时，尤其是在 $b^2 \\gg 4ac$ 的情况下，直接套用该公式会因“灾难性相消”而导致精度的灾难性损失。通过对比标准公式与一个经过巧妙重构的、在数值上更稳健的等价形式，这个练习突显了数学等价性与数值稳定性之间的关键区别，让你体会到设计稳健数值算法的精妙之处 [@problem_id:3259338]。", "problem": "您需要编写一个完整的、可运行的程序，在发生灾难性抵消的情况下，对比二次方程解析公式的数值计算与一种数值稳定方法的表现。考虑具有实系数 $a$、$b$ 和 $c$ 的二次多项式 $a x^2 + b x + c = 0$。解析解（二次公式）用 $a$、$b$ 和 $c$ 表示根，但在有限精度算术中计算它时，当 $b^2 \\gg 4 a c$ 时，可能会遭受灾难性抵消。目标是展示、量化并减轻这种有效数字的损失。\n\n使用的基本依据和事实：\n- 二次多项式 $a x^2 + b x + c$ 的形式解析根由二次公式给出。\n- 在电气和电子工程师协会（IEEE）$754$ 双精度（$64$ 位二进制浮点）算术中，运算遵循“就近舍入”的原则，机器ε (epsilon) 约为 $2.22 \\times 10^{-16}$，对于一个量级为 $|y|$ 的值，其绝对舍入尺度为 $O(\\varepsilon |y|)$。\n- 韦达定理 (Vieta’s formulas)：对于 $a x^2 + b x + c = 0$ 的根 $x_1$ 和 $x_2$，有 $x_1 + x_2 = -b/a$ 和 $x_1 x_2 = c/a$。\n\n任务说明：\n- 对于每个测试用例，通过选择导致两个几乎相等的数相减的符号，来计算易发生数值抵消的小模根。定义 $s = \\mathrm{sign}(b)$，其中如果 $b > 0$，则 $s = +1$；如果 $b  0$，则 $s = -1$。在浮点运算中，易发生抵消的根为\n$$\nx_{\\text{small,naive}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}.\n$$\n- 通过分子有理化，推导并实现一个用于计算相同小根的数值稳定表达式，得到\n$$\nx_{\\text{small,stable}} = \\frac{2 c}{-b - s \\sqrt{b^2 - 4 a c}}.\n$$\n- 使用任意精度算术（至少 $60$ 位有效数字）计算精确的解析表达式，从而获得小根的高精度参考值 $x_{\\text{small,true}}$\n$$\nx_{\\text{small,true}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}.\n$$\n- 通过计算每种方法的相对误差来量化数值误差，结果为十进制数：\n$$\n\\text{rel\\_err\\_naive} = \\frac{\\left|x_{\\text{small,naive}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}, \\quad\n\\text{rel\\_err\\_stable} = \\frac{\\left|x_{\\text{small,stable}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}.\n$$\n\n测试套件：\n- 案例 $1$：$a = 1$, $b = 10^{10}$, $c = 1$（当 $b > 0$ 时发生严重抵消）。\n- 案例 $2$：$a = 1$, $b = -10^{10}$, $c = 1$（当 $b  0$ 时发生严重抵消）。\n- 案例 $3$：$a = 1$, $b = 2$, $c = 1$（判别式为零的边界情况，$b^2 = 4 a c$）。\n- 案例 $4$：$a = 1$, $b = 100$, $c = 1$（中等数值，$b^2 \\gg 4 a c$ 但抵消有限）。\n\n输出规格：\n- 对于每个测试用例，计算 $\\text{rel\\_err\\_naive}$ 和 $\\text{rel\\_err\\_stable}$，每个值都四舍五入到 $10$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{rel\\_err\\_naive}^{(1)}, \\text{rel\\_err\\_stable}^{(1)}, \\text{rel\\_err\\_naive}^{(2)}, \\text{rel\\_err\\_stable}^{(2)}, \\text{rel\\_err\\_naive}^{(3)}, \\text{rel\\_err\\_stable}^{(3)}, \\text{rel\\_err\\_naive}^{(4)}, \\text{rel\\_err\\_stable}^{(4)}]$，其中上标表示测试用例的索引。\n\n所有答案都必须是纯数字和浮点数。不涉及物理单位。不涉及角度。不得使用百分比；误差必须表示为小数。程序必须是自包含的，不需要任何输入，并遵守指定的执行环境。", "solution": "用户想要分析计算二次方程 $a x^2 + b x + c = 0$ 根的两种不同公式的数值稳定性。\n\n### 步骤1：提取已知条件\n- **多项式**：$a x^2 + b x + c = 0$，其中 $a$、$b$ 和 $c$ 为实系数。\n- **抵消条件**：$b^2 \\gg 4 a c$。\n- **$s$ 的定义**：$s = \\mathrm{sign}(b)$，其中如果 $b > 0$，则 $s = +1$；如果 $b  0$，则 $s = -1$。\n- **易发生抵消的公式（“朴素法”）**：\n$$\nx_{\\text{small,naive}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}\n$$\n- **数值稳定公式**：\n$$\nx_{\\text{small,stable}} = \\frac{2 c}{-b - s \\sqrt{b^2 - 4 a c}}\n$$\n- **高精度“真”值**：使用任意精度算术（至少 $60$ 位有效数字）计算的朴素公式。\n$$\nx_{\\text{small,true}} = \\frac{-b + s \\sqrt{b^2 - 4 a c}}{2 a}\n$$\n- **相对误差公式**：\n$$\n\\text{rel\\_err\\_naive} = \\frac{\\left|x_{\\text{small,naive}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}\n$$\n$$\n\\text{rel\\_err\\_stable} = \\frac{\\left|x_{\\text{small,stable}} - x_{\\text{small,true}}\\right|}{\\left|x_{\\text{small,true}}\\right|}\n$$\n- **测试用例**：\n    1.  $a = 1$, $b = 10^{10}$, $c = 1$\n    2.  $a = 1$, $b = -10^{10}$, $c = 1$\n    3.  $a = 1$, $b = 2$, $c = 1$\n    4.  $a = 1$, $b = 100$, $c = 1$\n- **输出规格**：对于每个案例，计算 $\\text{rel\\_err\\_naive}$ 和 $\\text{rel\\_err\\_stable}$，四舍五入到 $10$ 位小数。输出为包含这些值的单行逗号分隔列表字符串。\n- **算术环境**：标准计算在 IEEE $754$ 双精度（$64$ 位）浮点算术中执行。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是数值分析中的一个经典例子，展示了浮点运算中的灾难性抵消现象。分析基于数值计算和误差分析的既定原则。所提供的公式是正确的。“稳定”公式是通过对“朴素”公式的分子进行有理化推导出来的，这是一种标准技术。\n2.  **良态问题**：该问题是良态的。对于每组系数 $(a, b, c)$，都有一组唯一的根。计算“真”值的方法（使用高精度算术）已明确定义，为误差比较提供了坚实的基础。误差度量是标准的且无歧义。\n3.  **客观性**：该问题使用精确的数学语言和客观标准进行陈述。没有主观或基于意见的元素。\n4.  **完整性**：所有必要的数据（测试用例的系数）、公式和定义均已提供。所需的输出格式已明确指定。\n5.  **一致性**：问题陈述中没有矛盾。使用朴素公式计算高精度参考值与评估无浮点伪影的解析表达式的目标是一致的。\n\n### 步骤3：结论与行动\n该问题是**有效的**。这是一个数值方法中的标准、定义明确的问题。我现在将着手解决。\n\n### 基于原则的设计\n该解决方案将用 Python 实现，利用 `numpy` 库进行标准的双精度浮点运算，并使用 `decimal` 标准库进行高精度参考计算。\n\n1.  **高精度参考 (`x_small,true`)**：验证过程的核心依赖于一个“真”值，浮点结果将与之进行比较。由于解析解在有限精度算术中只能被近似，我们使用更高的精度来模拟“真”值。Python 中的 `decimal` 模块允许设置任意精度。对于此问题，选择100位十进制数字的精度，这远高于要求的至少60位，并大大超过了IEEE 754双精度的大约16位数字。对于每个测试用例 $(a, b, c)$，系数将转换为 `Decimal` 对象。然后，完全使用 `Decimal` 算术来计算 $x_{\\text{small,true}}$ 的公式，包括由 `Decimal.sqrt()` 方法处理的平方根。这将舍入误差最小化到对于本分析目的可以忽略不计的水平。\n\n2.  **标准精度计算 (`x_small,naive`)**：要测试的第一个方法是直接计算二次公式。该公式被特意选择，以便在 $b^2 \\gg 4ac$ 时引起几乎相等的数相减。\n    - 项 $\\sqrt{b^2 - 4ac}$ 可以通过泰勒级数近似：$|b|\\sqrt{1 - 4ac/b^2} \\approx |b|(1 - 2ac/b^2) = |b| - 2ac/|b|$。\n    - 分子变为 $-b + s\\sqrt{b^2 - 4ac}$。由于 $s = \\mathrm{sign}(b)$，这等价于 $-b + |b|\\sqrt{1 - 4ac/b^2}$。\n    - 如果 $b > 0$, $s=+1$，分子约等于 $-b + (b - 2ac/b) = -2ac/b$。\n    - 如果 $b  0$, $s=-1$，分子是 $-b - \\sqrt{b^2 - 4ac}$。这应该是 $-b + (-1)\\sqrt{...}$。这是一个负数减去一个正数，即一个加法。这表明我对 $b0$ 符号的分析有误。让我们重新评估。设 $b = -10^{10}$。$s = -1$。分子是 $-(-10^{10}) + (-1)\\sqrt{(-10^{10})^2-4} = 10^{10} - \\sqrt{10^{20}-4}$。这又是一次两个几乎相等的数相减。问题陈述确实是正确且自洽的。给定的公式总是计算那个计算不稳定的根。我们称这个根为 $x_{unstable}$。\n    - 该计算使用 `numpy.float64` 类型实现，以确保标准行为。\n\n3.  **稳定精度计算 (`x_small,stable`)**：第二个公式是通过将朴素公式的分子和分母乘以其共轭项 $(-b - s\\sqrt{b^2-4ac})$ 推导出来的：\n$$\nx = \\frac{-b + s\\sqrt{D}}{2a} \\times \\frac{-b - s\\sqrt{D}}{-b - s\\sqrt{D}} = \\frac{(-b)^2 - (s\\sqrt{D})^2}{2a(-b - s\\sqrt{D})} = \\frac{b^2 - s^2 D}{2a(-b - s\\sqrt{D})}\n$$\n其中 $D = b^2 - 4ac$。由于 $s^2 = (\\pm 1)^2 = 1$，这简化为：\n$$\nx = \\frac{b^2 - (b^2 - 4ac)}{2a(-b - s\\sqrt{D})} = \\frac{4ac}{2a(-b - s\\sqrt{D})} = \\frac{2c}{-b - s\\sqrt{D}}\n$$\n这是提供的稳定公式。分母涉及两个同号数（$-b$ 和 $-s\\sqrt{D}$ 符号相同）的相加，从而避免了灾难性抵消。这也使用 `numpy.float64` 实现。\n\n4.  **误差计算**：针对高精度参考值，计算朴素法和稳定法的相对误差。计算值（例如 $x_{\\text{small,naive}}$）与真值（$x_{\\text{small,true}}$）之差的绝对值除以真值的绝对值。此计算使用 `Decimal` 类型以保持精度，最终结果转换为浮点数并按要求四舍五入到10位小数。\n\n程序将遍历提供的测试用例，为每个用例执行这四个步骤，并将得到的相对误差整理成一个列表，用于最终的格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Computes and compares the relative errors of a naive and a stable formula\n    for a quadratic root subject to catastrophic cancellation.\n    \"\"\"\n    \n    # Set precision for high-accuracy reference calculations.\n    # 60 digits are required, 100 provides a safe margin.\n    getcontext().prec = 100\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (a, b, c).\n    test_cases = [\n        (1, 10**10, 1),      # Case 1: Severe cancellation, b > 0\n        (1, -10**10, 1),     # Case 2: Severe cancellation, b  0\n        (1, 2, 1),           # Case 3: Discriminant is zero\n        (1, 100, 1)          # Case 4: Moderate cancellation\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        a, b, c = case\n\n        # --- High-precision reference calculation (x_small_true) ---\n        a_d = Decimal(a)\n        b_d = Decimal(b)\n        c_d = Decimal(c)\n\n        s_d = Decimal(1) if b_d > 0 else Decimal(-1)\n        \n        discriminant_d = b_d**2 - 4 * a_d * c_d\n        \n        # Handle the case of zero discriminant separately for sqrt\n        # although Decimal.sqrt() handles it correctly. This is for clarity.\n        if discriminant_d  0:\n            # Problem assumes real coefficients leading to real roots.\n            # This branch should not be taken by the test cases.\n            continue\n        \n        sqrt_discriminant_d = discriminant_d.sqrt()\n        \n        # x_small_true is computed using the high-precision Decimal objects\n        # following the 'naive' formula structure, as specified.\n        x_small_true = (-b_d + s_d * sqrt_discriminant_d) / (2 * a_d)\n\n        # --- Standard double-precision calculations (numpy.float64) ---\n        a_f = np.float64(a)\n        b_f = np.float64(b)\n        c_f = np.float64(c)\n\n        s_f = np.sign(b_f)\n        \n        discriminant_f = b_f**2 - 4 * a_f * c_f\n        sqrt_discriminant_f = np.sqrt(discriminant_f)\n        \n        # 1. Naive (cancellation-prone) formula\n        x_small_naive = (-b_f + s_f * sqrt_discriminant_f) / (2 * a_f)\n        \n        # 2. Stable (rationalized) formula\n        denominator_stable = -b_f - s_f * sqrt_discriminant_f\n        # Avoid division by zero if discriminant is zero and b is also zero,\n        # which is not the case in the test suite.\n        if denominator_stable == 0:\n            # This can happen if b^2=4ac and b=0, meaning a=0 or c=0 with b=0.\n            # In our case 3, b=2 so denominator is -2-2=-4.\n            # If a=0, it's not a quadratic. So this case is unlikely in valid problems.\n            # Based on the formula, if D=0, root is -b/2a. stable formula becomes 2c/-b.\n            # Vieta's formulas: x1*x2 = c/a and x1+x2 = -b/a.\n            # If D=0, x1=x2=-b/2a. So (-b/2a)^2 = c/a => b^2/4a^2 = c/a => b^2 = 4ac.\n            # And x1*x1 = (2c/-b)*(2c/-b) = 4c^2/b^2 = 4c^2/(4ac) = c/a. Correct.\n            x_small_stable = -b_f / (2 * a_f)\n        else:\n            x_small_stable = (2 * c_f) / denominator_stable\n\n        # --- Relative Error Calculation ---\n        # Convert float results to Decimal for accurate error computation\n        x_naive_d = Decimal(x_small_naive)\n        x_stable_d = Decimal(x_small_stable)\n        \n        # Avoid division by zero for relative error if true value is zero.\n        # None of the test cases produce a true root of zero.\n        if x_small_true == 0:\n            rel_err_naive = Decimal(0) if x_naive_d == 0 else Decimal('inf')\n            rel_err_stable = Decimal(0) if x_stable_d == 0 else Decimal('inf')\n        else:\n            rel_err_naive = abs((x_naive_d - x_small_true) / x_small_true)\n            rel_err_stable = abs((x_stable_d - x_small_true) / x_small_true)\n            \n        # Round the final error values to 10 decimal places as specified\n        rounded_err_naive = round(float(rel_err_naive), 10)\n        rounded_err_stable = round(float(rel_err_stable), 10)\n        \n        results.append(rounded_err_naive)\n        results.append(rounded_err_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3259338"}]}