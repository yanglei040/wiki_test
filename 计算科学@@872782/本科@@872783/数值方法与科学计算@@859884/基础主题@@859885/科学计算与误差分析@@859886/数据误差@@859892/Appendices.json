{"hands_on_practices": [{"introduction": "我们从最直接的数据误差形式开始：在计算球体体积 $V = \\frac{4}{3}\\pi R^3$ 时，为一个基本常数 $\\pi$ 使用一个近似值。这个练习将演示一个微小的初始误差如何通过公式传播，并影响最终结果。理解这个基本原理是培养数值误差分析直觉的第一步。[@problem_id:3221388]", "problem": "在数值方法和科学计算中，对数学常数的截断会引入数据误差，这些误差会在计算过程中传播。考虑一个半径为 $R$ 的球体体积，其中 $R$ 是一个精确已知的正实数。真实体积由一个经过充分检验的几何公式确定。在实践中，假设在计算球体体积之前，常数 $\\pi$ 被截断为小数值 $3.14$。使用前向（输出）误差的基本定义，即计算量与真实量之差，并仅利用公认的几何事实，推导仅因将 $\\pi$ 截断为 $3.14$ 而导致的计算体积的有符号误差的精确闭式表达式。将你的最终答案表示为关于 $R$ 的单个解析表达式。无需四舍五入。", "solution": "该问题陈述已经过验证，被认为是自洽、一致且科学合理的。它提出了一个数值分析领域的适定问题，具体涉及由常数截断引起的数据误差。该问题是可形式化且客观的。\n\n目标是推导当常数 $\\pi$ 被截断时，球体计算体积的有符号误差的精确闭式表达式。问题明确将此误差定义为前向误差。\n\n设 $V_{\\text{true}}$ 为球体的真实体积，$V_{\\text{computed}}$ 为计算体积。球体半径为 $R$，它是一个精确已知的正实数。\n\n根据公认的几何原理，球体的真实体积由以下公式给出：\n$$V_{\\text{true}} = \\frac{4}{3}\\pi R^3$$\n\n问题陈述，在计算中，常数 $\\pi$ 被截断为小数值 $3.14$。我们将此近似值记为 $\\pi_{\\text{approx}}$。\n$$\\pi_{\\text{approx}} = 3.14$$\n因此，计算体积是使用这个截断值计算的：\n$$V_{\\text{computed}} = \\frac{4}{3}\\pi_{\\text{approx}} R^3 = \\frac{4}{3}(3.14)R^3$$\n\n问题将我们记为 $E$ 的有符号误差定义为前向（输出）误差。这是计算量与真实量之差。\n$$E = V_{\\text{computed}} - V_{\\text{true}}$$\n\n将 $V_{\\text{computed}}$ 和 $V_{\\text{true}}$ 的表达式代入误差 $E$ 的定义，我们得到：\n$$E = \\left(\\frac{4}{3}(3.14)R^3\\right) - \\left(\\frac{4}{3}\\pi R^3\\right)$$\n\n为了化简此表达式，我们可以提出公共项 $\\frac{4}{3}R^3$：\n$$E = \\frac{4}{3}R^3 (3.14 - \\pi)$$\n\n此表达式代表了体积的有符号误差的精确闭式表达式。按要求，它是一个以 $R$ 表示的解析表达式。项 $(3.14 - \\pi)$ 是一个负常数，这正确地表明将 $\\pi$ 截断为一个更小的值将导致计算体积小于真实体积。\n最终表达式为：\n$$E = \\frac{4}{3}(3.14 - \\pi)R^3$$", "answer": "$$\\boxed{\\frac{4}{3}(3.14 - \\pi)R^3}$$", "id": "3221388"}, {"introduction": "除了简单的误差传播，我们构建计算的方式也可能极大地放大误差。本练习探讨了在计算函数 $f(x) = \\frac{1 - \\exp(-x)}{x}$ 时，当 $x$ 很小时出现的“灾难性相消”（catastrophic cancellation）问题。通过分析这种因两个几乎相等的数值相减而导致的有效数字损失，并使用泰勒级数开发出数值稳定的替代算法，我们将认识到，一个鲁棒的算法与精确的输入数据同样关键。[@problem_id:3221400]", "problem": "考虑函数 $f(x) = \\frac{1 - \\exp(-x)}{x}$，其中 $x \\in \\mathbb{R}$，$x \\neq 0$，其在 $x=0$ 处的连续性扩展由 $x \\to 0$ 时的极限定义。在科学计算中，当 $x$ 很小时，常常需要计算该函数的值。本题的目标是理解对于很小的 $x$ 值，计算时产生的数据误差和数值稳定性问题。\n\n任务：\n1. 使用浮点舍入和一阶误差传播的核心定义，为当 $x$ 很小时通过其定义的商进行 $f(x)$ 的朴素计算构建一个前向误差模型。假设每次基本运算和初等函数求值都采用就近舍入，单位舍入误差为 $u$，并设 $x$ 被扰动为 $\\hat{x} = x(1 + \\delta)$，其中 $|\\delta| \\leq u$，而指数函数计算为 $\\widehat{\\exp(-x)} = \\exp(-x)(1 + \\epsilon)$，其中 $|\\epsilon| \\leq u$。推导相对前向误差 $\\frac{\\hat{f} - f}{f}$ 关于 $x$、$u$ 和误差符号的一阶近似，并解释为什么当 $x$ 很小时，分子会发生有效数字损失。\n\n2. 从指数函数在 $x=0$ 处的泰勒级数出发，推导 $f(x)$ 的麦克劳林级数，并（从基本原理）证明对于 $x > 0$，它是一个项的绝对值单调递减的交错级数。解释为什么当 $x$ 很小时，该级数提供了一种数值稳定的计算 $f(x)$ 的方法。\n\n3. 对于 $x = 10^{-8}$，使用从交错级数理论推导出的严格余项界，确定麦克劳林级数中保证绝对截断误差小于 $10^{-24}$ 所需的最少非零项数 $N$。然后使用包含 $N$ 项的截断级数计算 $f(10^{-8})$ 的值，并将结果保留到六位有效数字。\n\n4. 使用标量函数相对于标量输入的相对条件数的核心定义，\n$$\n\\kappa_{f}(x) = \\left|\\frac{x f'(x)}{f(x)}\\right|,\n$$\n推导给定函数 $f(x)$ 的 $\\kappa_{f}(x)$ 的封闭形式表达式，并在 $x = 10^{-8}$ 处求值。将最终值四舍五入到四位有效数字。提供此最终数值作为您的答案。", "solution": "该问题已经过验证，是数值分析中一组良构的任务。它具有科学依据、客观性，并包含足够的信息以获得唯一解。\n\n### 第1部分：前向误差模型与有效数字损失\n\n函数由 $f(x) = \\frac{1 - \\exp(-x)}{x}$ 给出。我们分析其朴素计算在 $x$ 很小时的误差。计算涉及指数求值、减法和除法。每次运算都会引入浮点舍入误差。设 $u$ 为单位舍入误差。\n\n我们来为前向误差建模。我们假设输入 $x$ 是一个精确的浮点数。\n1.  指数计算为 $\\widehat{\\exp(-x)} = \\exp(-x)(1+\\epsilon_1)$，其中 $|\\epsilon_1| \\le u$。\n2.  分子中的减法计算为 $\\hat{n} = \\text{fl}(1 - \\widehat{\\exp(-x)})$。这等于 $(1 - \\widehat{\\exp(-x)})(1+\\epsilon_s)$，其中 $|\\epsilon_s| \\le u$。\n3.  最后的除法计算为 $\\hat{f} = \\text{fl}(\\hat{n} / x) = (\\hat{n}/x)(1+\\epsilon_d)$，其中 $|\\epsilon_d| \\le u$。\n\n结合这些步骤，计算出的值 $\\hat{f}$ 是：\n$$\n\\hat{f} = \\frac{(1 - \\exp(-x)(1+\\epsilon_1))(1+\\epsilon_s)}{x}(1+\\epsilon_d)\n$$\n展开此表达式，并只保留误差 $\\epsilon_1, \\epsilon_s, \\epsilon_d$ 的一阶项：\n$$\n\\hat{f} \\approx \\frac{1 - \\exp(-x) - \\epsilon_1 \\exp(-x)}{x} (1 + \\epsilon_s + \\epsilon_d)\n$$\n$$\n\\hat{f} \\approx \\left( \\frac{1 - \\exp(-x)}{x} - \\frac{\\epsilon_1 \\exp(-x)}{x} \\right) (1 + \\epsilon_s + \\epsilon_d)\n$$\n$$\n\\hat{f} \\approx f(x)(1 + \\epsilon_s + \\epsilon_d) - \\frac{\\epsilon_1 \\exp(-x)}{x}\n$$\n相对前向误差为 $\\frac{\\hat{f} - f(x)}{f(x)}$：\n$$\n\\frac{\\hat{f} - f(x)}{f(x)} \\approx (\\epsilon_s + \\epsilon_d) - \\frac{\\epsilon_1 \\exp(-x)}{x f(x)}\n$$\n代入 $f(x) = \\frac{1-\\exp(-x)}{x}$：\n$$\n\\frac{\\hat{f} - f(x)}{f(x)} \\approx \\epsilon_s + \\epsilon_d - \\frac{\\epsilon_1 \\exp(-x)}{x \\left(\\frac{1-\\exp(-x)}{x}\\right)} = \\epsilon_s + \\epsilon_d - \\epsilon_1 \\frac{\\exp(-x)}{1-\\exp(-x)}\n$$\n对于很小的 $x$，我们使用泰勒展开 $\\exp(-x) \\approx 1 - x$。因此，$1 - \\exp(-x) \\approx x$。误差放大因子变为：\n$$\n\\frac{\\exp(-x)}{1-\\exp(-x)} \\approx \\frac{1-x}{x} \\approx \\frac{1}{x}\n$$\n因此，相对误差近似为：\n$$\n\\frac{\\hat{f} - f(x)}{f(x)} \\approx \\epsilon_s + \\epsilon_d - \\frac{\\epsilon_1}{x}\n$$\n当 $x$ 很小时，由于项 $-\\epsilon_1 / x$ 的存在，会发生有效数字损失。如果 $x$ 与单位舍入误差 $u$ 的量级相同，相对误差的量级可能为 $u/u = 1$，这意味着完全丢失了所有正确的有效数字。\n\n其根本原因是减法 $1 - \\exp(-x)$。当 $x$ 很小时，$\\exp(-x)$ 是一个非常接近 1 的数。两个几乎相等的数相减，会导致前面的、最高位的有效数字被抵消，留下的结果由后面的、最低位的有效数字主导，而这些数字已经被舍入误差所污染。这种现象被称为灾难性相消。\n\n### 第2部分：麦克劳林级数\n\n我们从 $\\exp(t)$ 的麦克劳林级数开始：\n$$\n\\exp(t) = \\sum_{k=0}^{\\infty} \\frac{t^k}{k!} = 1 + t + \\frac{t^2}{2!} + \\frac{t^3}{3!} + \\dots\n$$\n代入 $t = -x$：\n$$\n\\exp(-x) = \\sum_{k=0}^{\\infty} \\frac{(-x)^k}{k!} = 1 - x + \\frac{x^2}{2!} - \\frac{x^3}{3!} + \\dots\n$$\n接下来，我们计算 $1 - \\exp(-x)$：\n$$\n1 - \\exp(-x) = 1 - \\left(1 - x + \\frac{x^2}{2!} - \\frac{x^3}{3!} + \\dots\\right) = x - \\frac{x^2}{2!} + \\frac{x^3}{3!} - \\frac{x^4}{4!} + \\dots = \\sum_{k=1}^{\\infty} \\frac{(-1)^{k+1}x^k}{k!}\n$$\n最后，我们除以 $x$ 得到 $f(x)$ 的级数：\n$$\nf(x) = \\frac{1}{x} \\sum_{k=1}^{\\infty} \\frac{(-1)^{k+1}x^k}{k!} = \\sum_{k=1}^{\\infty} \\frac{(-1)^{k+1}x^{k-1}}{k!}\n$$\n通过用 $j = k-1$（因此 $k=j+1$）重新索引，我们得到 $f(x)$ 的麦克劳林级数：\n$$\nf(x) = \\sum_{j=0}^{\\infty} \\frac{(-1)^{j}x^{j}}{(j+1)!} = 1 - \\frac{x}{2!} + \\frac{x^2}{3!} - \\frac{x^3}{4!} + \\dots\n$$\n对于 $x>0$，这是一个交错级数，因为其形式为 $\\sum (-1)^j a_j$ 且 $a_j = \\frac{x^j}{(j+1)!} > 0$。\n为了证明项的绝对值是单调递减的，我们考察对于 $j \\ge 0$ 的连续项之比：\n$$\n\\frac{a_{j+1}}{a_j} = \\frac{x^{j+1}/(j+2)!}{x^j/(j+1)!} = \\frac{x^{j+1}(j+1)!}{x^j(j+2)!} = \\frac{x}{j+2}\n$$\n为使绝对值递减，我们需要 $\\frac{a_{j+1}}{a_j} < 1$，这意味着 $x < j+2$。对于很小的 $x$（例如，$x<2$），这个条件对所有 $j \\ge 0$ 都成立。因此，对于很小的正数 $x$，该级数是一个项的绝对值单调递减的交错级数。\n\n该级数为在 $x$ 很小时计算 $f(x)$ 提供了一种数值稳定的方法，因为它避免了灾难性相消问题。它不是计算两个几乎相等的数的差，而是计算一个各项绝对值迅速减小的和。求和过程涉及对大小悬殊的数进行加减，这是一种数值稳定的运算。\n\n### 第3部分：使用级数进行数值计算\n\n我们需要找到麦克劳林级数的最少非零项数 $N$，以确保 $f(10^{-8})$ 的绝对截断误差小于 $10^{-24}$。对于一个项的绝对值单调递减的交错级数，其部分和的绝对误差以第一个被舍弃项的绝对值为界。\n包含 $N$ 项的部分和为 $S_N = \\sum_{j=0}^{N-1} (-1)^j \\frac{x^j}{(j+1)!}$。误差的界为：\n$$\n|\\text{Error}| = |f(x) - S_N| \\le \\left|\\frac{(-1)^N x^N}{(N+1)!}\\right| = \\frac{x^N}{(N+1)!}\n$$\n给定 $x=10^{-8}$，我们要求误差小于 $10^{-24}$：\n$$\n\\frac{(10^{-8})^N}{(N+1)!} < 10^{-24}\n$$\n我们测试 $N$ 的值：\n对于 $N=1$：误差 $\\le \\frac{10^{-8}}{2!} = 5 \\times 10^{-9}$。不够小。\n对于 $N=2$：误差 $\\le \\frac{(10^{-8})^2}{3!} = \\frac{10^{-16}}{6} \\approx 1.67 \\times 10^{-17}$。不够小。\n对于 $N=3$：误差 $\\le \\frac{(10^{-8})^3}{4!} = \\frac{10^{-24}}{24}$。这个值确实小于 $10^{-24}$。\n因此，最少项数为 $N=3$。\n\n现在我们用这3项来计算 $f(10^{-8})$：\n$$\nf(10^{-8}) \\approx 1 - \\frac{10^{-8}}{2!} + \\frac{(10^{-8})^2}{3!} = 1 - \\frac{10^{-8}}{2} + \\frac{10^{-16}}{6}\n$$\n$$\nf(10^{-8}) \\approx 1 - 0.5 \\times 10^{-8} + 0.166666... \\times 10^{-16}\n$$\n$$\nf(10^{-8}) \\approx 0.9999999950000001666...\n$$\n将此值保留到六位有效数字，得到 $1.00000$。\n\n### 第4部分：条件数\n\n相对条件数定义为 $\\kappa_{f}(x) = \\left|\\frac{x f'(x)}{f(x)}\\right|$。\n首先，我们使用除法法则求 $f(x) = \\frac{1 - \\exp(-x)}{x}$ 的导数 $f'(x)$：\n$$\nf'(x) = \\frac{x \\frac{d}{dx}(1 - \\exp(-x)) - (1 - \\exp(-x)) \\frac{d}{dx}(x)}{x^2}\n$$\n$$\nf'(x) = \\frac{x(\\exp(-x)) - (1 - \\exp(-x))}{x^2} = \\frac{(x+1)\\exp(-x) - 1}{x^2}\n$$\n现在，将 $f(x)$ 和 $f'(x)$ 代入条件数公式：\n$$\n\\kappa_{f}(x) = \\left| \\frac{x}{f(x)} f'(x) \\right| = \\left| \\frac{x}{\\frac{1 - \\exp(-x)}{x}} \\cdot \\frac{(x+1)\\exp(-x) - 1}{x^2} \\right|\n$$\n$$\n\\kappa_{f}(x) = \\left| \\frac{x^2}{1 - \\exp(-x)} \\cdot \\frac{(x+1)\\exp(-x) - 1}{x^2} \\right| = \\left| \\frac{(x+1)\\exp(-x) - 1}{1 - \\exp(-x)} \\right|\n$$\n我们需要在 $x = 10^{-8}$ 处计算该值。由于 $x$ 非常小，我们可以使用泰勒级数近似。\n分子：$(1+x)\\exp(-x) - 1 \\approx (1+x)(1-x+x^2/2) - 1 = (1 - x^2/2 + \\dots) - 1 \\approx -x^2/2$。\n分母：$1 - \\exp(-x) \\approx 1 - (1-x+x^2/2) = x - x^2/2 \\approx x$。\n所以，对于很小的 $x$：\n$$\n\\kappa_f(x) \\approx \\left| \\frac{-x^2/2}{x} \\right| = \\frac{|x|}{2}\n$$\n对于很小的 $x$，该问题是良态的。在 $x = 10^{-8}$ 处求值：\n$$\n\\kappa_f(10^{-8}) \\approx \\frac{10^{-8}}{2} = 0.5 \\times 10^{-8} = 5 \\times 10^{-9}\n$$\n为了更精确，我们在 $\\kappa_f(x)$ 的近似中包含下一项：\n分子：$(1+x)\\exp(-x)-1 = (1+x)(1-x+x^2/2-x^3/6+\\dots)-1 = (-x^2/2+x^3/3-\\dots)$\n分母：$1-\\exp(-x) = (x-x^2/2+x^3/6-\\dots)$\n比值：$\\frac{-x^2/2+x^3/3-\\dots}{x-x^2/2+x^3/6-\\dots} = \\frac{-x/2+x^2/3-\\dots}{1-x/2+x^2/6-\\dots} \\approx (-x/2+x^2/3)(1+x/2) \\approx -x/2 + x^2/12$。\n$\\kappa_f(x) \\approx |-x/2+x^2/12| \\approx x/2 - x^2/12$。\n对于 $x=10^{-8}$，修正项是 $(10^{-8})^2/12 \\approx 8.3 \\times 10^{-18}$，而主项是 $5 \\times 10^{-9}$。对于四舍五入到四位有效数字来说，该修正是可以忽略的。\n因此，$\\kappa_f(10^{-8}) = 5 \\times 10^{-9}$。写成四位有效数字，即为 $5.000 \\times 10^{-9}$。", "answer": "$$\\boxed{5.000 \\times 10^{-9}}$$", "id": "3221400"}, {"introduction": "最后的这个练习处理求和 $\\sum_{i=1}^{n} x_i$ 时许多微小舍入误差的累积效应，这是在浮点运算中固有的挑战。我们将亲眼看到，对于一个由大小不一的数组成的序列，求和的顺序至关重要，并发现一种强大的技术——Kahan求和算法，它能补偿舍入误差以达到高得多的精度。这个练习突显了编写数值稳健代码所需的精妙思维。[@problem_id:3221372]", "problem": "考虑双精度浮点数求和。假设采用舍入到最近的策略，单位舍入误差为 $u$，其模型为标准浮点舍入关系 $ \\operatorname{fl}(a \\circ b) = (a \\circ b)(1 + \\theta) $，适用于基本运算 $ \\circ \\in \\{ +, -, \\times, \\div \\} $，其中 $|\\theta| \\leq u$，对于 IEEE 754 双精度标准，$u = 2^{-53}$。设 $x_i = \\frac{1}{i} + \\delta_i$，其中 $i \\in \\{1,2,\\dots,n\\}$，$\\delta_i$ 是微小的附加数据噪声。本题的目标是通过按 $i$ 的升序和降序计算 $ \\sum_{i=1}^{n} x_i $，来研究求和顺序对舍入误差的影响，并比较在存在附加数据噪声 $\\delta_i$ 的情况下，朴素顺序求和与补偿求和方法（Kahan 求和算法）的差异。\n\n任务：\n- 对每个测试用例，构造序列 $x_i = \\frac{1}{i} + \\delta_i$，$i = 1,\\dots,n$。从均值为 $0$、标准差为 $\\sigma$ 的正态分布中生成独立的 $\\delta_i$ 样本，使用固定的伪随机种子 $0$ 以确保噪声的实现是确定性的。整个过程使用双精度。\n- 对每个测试用例计算四个和：朴素升序、朴素降序、补偿升序、补偿降序。这里的“朴素”指的是没有任何补偿的直接从左到右累加，“补偿”则指为减少舍入误差而设计的数值稳定求和技术。\n- 对每个测试用例，报告以下四个浮点数度量：\n    1. $d_{\\text{naive}} = \\left| S_{\\text{naive}}^{\\uparrow} - S_{\\text{naive}}^{\\downarrow} \\right|$，朴素升序和与降序和之间的绝对差。\n    2. $d_{\\text{comp}} = \\left| S_{\\text{comp}}^{\\uparrow} - S_{\\text{comp}}^{\\downarrow} \\right|$，补偿升序和与降序和之间的绝对差。\n    3. $I_{\\uparrow} = \\left| S_{\\text{naive}}^{\\uparrow} - S_{\\text{comp}}^{\\uparrow} \\right|$，升序求和中朴素方法与补偿方法之间的绝对差。\n    4. $I_{\\downarrow} = \\left| S_{\\text{naive}}^{\\downarrow} - S_{\\text{comp}}^{\\downarrow} \\right|$，降序求和中朴素方法与补偿方法之间的绝对差。\n\n测试套件：\n- 用例 A: $n = 1$, $\\sigma = 0$。\n- 用例 B: $n = 10^3$, $\\sigma = 0$。\n- 用例 C: $n = 10^5$, $\\sigma = 0$。\n- 用例 D: $n = 10^5$, $\\sigma = 10^{-12}$。\n\n实现细节：\n- 在每个测试用例中，使用固定的伪随机种子 $0$ 来生成长度为 $n$ 的整个向量 $\\delta_i$。噪声在 $i$ 之间是独立的。\n- 所有计算必须以双精度进行。\n- 没有物理单位；所有量均为无量纲。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。每个测试用例的结果本身也是一个逗号分隔的列表，包含按上述顺序排列的四个度量。例如，输出格式应类似于 $[[d_{\\text{naive}},d_{\\text{comp}},I_{\\uparrow},I_{\\downarrow}],\\dots]$，不含空格。", "solution": "该问题是有效的。这是一个在数值分析领域中适定（well-posed）、有科学依据的问题，旨在研究浮点舍入误差的累积以及不同求和策略的有效性。所有参数和步骤都得到了清晰的定义。\n\n### 基于原理的解决方案设计\n\n这个问题的核心在于理解浮点运算与精确实数运算的偏差，尤其是在对长序列数求和的背景下。\n\n#### 1. 浮点求和与误差传播\n\n标准的浮点加法运算模型为 $\\operatorname{fl}(a + b) = (a + b)(1 + \\theta)$，其中 $|\\theta| \\leq u$。术语 $u$ 是单位舍入误差，对于 IEEE 754 双精度，$u = 2^{-53}$。每次加法都可能引入一个小的相对误差。当对 $n$ 个数求和时，$S_n = \\sum_{i=1}^n x_i$，朴素的顺序求和计算 $s_1 = x_1$, $s_2 = \\operatorname{fl}(s_1 + x_2)$, $s_3 = \\operatorname{fl}(s_2 + x_3)$，依此类推。每一步的误差都会累积。\n\n当相加的数字量级差异巨大时，会出现一个众所周知的问题。如果我们将一个小数加到一个大数上，即 $|x_i| \\ll |s_{i-1}|$，那么由于舍入，这个较小的数可能会部分或完全丢失。对于序列 $x_i = \\frac{1}{i}$，各项的量级是严格递减的：$x_1 > x_2 > \\dots > x_n$。\n\n- **朴素升序求和 ($S_{\\text{naive}}^{\\uparrow}$):** 这涉及从 $i=1$ 到 $n$ 求和。我们从最大的项 $x_1=1$ 开始，然后依次加上越来越小的项。随着运行和 $s_k = \\sum_{i=1}^k x_i$ 的增长，新加入的项 $x_{k+1}$ 相对于 $s_k$ 变得越来越小。这会导致显著的精度损失，这种现象在广义上被称为“灾难性相消”，尽管在这里它更像是一种渐进的吸收误差。\n\n- **朴素降序求和 ($S_{\\text{naive}}^{\\downarrow}$):** 这涉及从 $i=n$ 到 $1$ 求和。我们从最小的项开始，逐渐加上较大的项。运行和增长得更慢，且连续相加的项量级更相似。这种策略通常能减少舍入误差的累积。因此，我们预期 $S_{\\text{naive}}^{\\downarrow}$ 会比 $S_{\\text{naive}}^{\\uparrow}$ 更准确。对于大的 $n$，差值 $d_{\\text{naive}} = |S_{\\text{naive}}^{\\uparrow} - S_{\\text{naive}}^{\\downarrow}|$ 预计会很显著。\n\n#### 2. 补偿求和 (Kahan 算法)\n\n为了减轻舍入误差的累积，已经开发出了数值稳定的算法。问题指定使用一种补偿求和方法，其中 Kahan 求和算法是经典选择。它巧妙地跟踪每次加法产生的舍入误差，并将其并入下一步计算中。\n\n计算 $S = \\sum_{i=1}^n x_i$ 的算法如下：\n1. 初始化和 $s = 0.0$ 以及一个补偿变量 $c = 0.0$。\n2. 对于 $i=1$ 到 $n$：\n   a. $y = x_i - c$  (从当前项中减去上一步的误差)\n   b. $t = s + y$    (将修正后的项加到和上)\n   c. $c = (t - s) - y$  (新的误差是 $y$ 在加到 $s$ 上时丢失的部分)\n   d. $s = t$          (更新和)\n3. 最终结果是 $s$。\n\n关键在于步骤 2c。在精确实数运算中，$c$ 将为 $0$。在浮点运算中，$(t - s)$ 是 $y$ 中实际被吸收到 $s$ 中的部分。从这个值中减去 $y$ 得到 $y$ 丢失部分的相反数。这个“丢失的低位部分”随后在下一次迭代的步骤 2a 中从下一项 $x_{i+1}$ 中减去，从而有效地将其携带到后续计算中以便包含在总和里。\n\nKahan 求和的误差界大约为 $(2u + O(nu^2))\\sum_{i=1}^n |x_i|$。其一阶项与 $n$ 无关，这使得该算法即使对于非常大的和也极其准确。因此，升序 ($S_{\\text{comp}}^{\\uparrow}$) 和降序 ($S_{\\text{comp}}^{\\downarrow}$) 的补偿求和结果都应该非常接近真实的数学和，因此彼此也非常接近。我们预计它们的差值 $d_{\\text{comp}} = |S_{\\text{comp}}^{\\uparrow} - S_{\\text{comp}}^{\\downarrow}|$ 将接近于零。\n\n补偿求和可作为高精度基准。因此，度量 $I_{\\uparrow} = |S_{\\text{naive}}^{\\uparrow} - S_{\\text{comp}}^{\\uparrow}|$ 和 $I_{\\downarrow} = |S_{\\text{naive}}^{\\downarrow} - S_{\\text{comp}}^{\\downarrow}|$ 分别有效地衡量了朴素升序和降序求和的绝对误差。我们预计对于大的 $n$，$I_{\\uparrow} > I_{\\downarrow}$。\n\n#### 3. 附加数据噪声的影响\n\n用例 D 引入了从均值为 $0$、标准差为 $\\sigma = 10^{-12}$ 的正态分布中采样的附加数据噪声 $\\delta_i$。单位舍入误差 $u$ 约为 $2.22 \\times 10^{-16}$。由于 $\\sigma \\gg u$，数据噪声远大于单次运算的舍入误差。这些噪声项的和 $\\sum \\delta_i$ 将对总和产生误差。这个总噪声误差的标准差为 $\\sqrt{n}\\sigma$。对于 $n=10^5$，这个值约为 $\\sqrt{10^5} \\times 10^{-12} \\approx 3.16 \\times 10^{-10}$。\n\nKahan 求和能准确地对给定的带噪数据 $x_i = 1/i + \\delta_i$ 求和。升序和降序 Kahan 求和之间的差值应该仍然可以忽略不计。然而，朴素求和将同时受到其固有的舍入误差累积和数据噪声的影响。度量 $I_{\\uparrow}$ 和 $I_{\\downarrow}$ 仍将主要反映朴素方法的巨大舍入误差，因为对于 $n=10^5$，这些误差预计将远大于总数据误差。\n\n### 算法实现\n\n- 对于每个测试用例 $(n, \\sigma)$：\n  1. 生成项的向量 $x_i = \\frac{1}{i} + \\delta_i$，$i=1, \\dots, n$。为每个用例使用以 $0$ 为种子的新伪随机数生成器来生成长度为 $n$ 的噪声向量 $\\delta$。对于 $\\sigma = 0$ 的用例，$\\delta_i = 0$。所有计算都使用双精度 (`np.float64`)。\n  2. 创建数据向量的两个版本：一个按 $i$ 的升序排列，另一个按降序排列。\n  3. 实现两个求和函数：`naive_sum`（一个简单的循环累加器）和 `kahan_sum`（实现上述算法）。\n  4. 通过将适当的函数应用于适当的数据向量，计算四个和：$S_{\\text{naive}}^{\\uparrow}$、$S_{\\text{naive}}^{\\downarrow}$、$S_{\\text{comp}}^{\\uparrow}$ 和 $S_{\\text{comp}}^{\\downarrow}$。\n  5. 根据这些和计算所需的四个度量 ($d_{\\text{naive}}, d_{\\text{comp}}, I_{\\uparrow}, I_{\\downarrow}$)。\n  6. 按照规定存储和格式化结果。", "answer": "```python\nimport numpy as np\n\ndef naive_sum(arr: np.ndarray) -> np.float64:\n    \"\"\"\n    Computes the sum of array elements using a naive, left-to-right\n    iterative approach.\n    \"\"\"\n    s = np.float64(0.0)\n    for x_i in arr:\n        s += x_i\n    return s\n\ndef kahan_sum(arr: np.ndarray) -> np.float64:\n    \"\"\"\n    Computes the sum of array elements using the Kahan summation algorithm\n    to minimize rounding error.\n    \"\"\"\n    s = np.float64(0.0)\n    c = np.float64(0.0)  # A running compensation for lost low-order bits.\n    for x_i in arr:\n        y = x_i - c\n        t = s + y\n        # (t - s) is the high-order part of y; ((t - s) - y) is the low-order part.\n        c = (t - s) - y\n        s = t\n    return s\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        (1, 0.0),            # Case A\n        (10**3, 0.0),        # Case B\n        (10**5, 0.0),        # Case C\n        (10**5, 10**-12)     # Case D\n    ]\n\n    all_results = []\n    for n, sigma in test_cases:\n        # 1. Construct the sequence x_i = 1/i + delta_i\n        # As per problem, re-seed for each test case for deterministic noise.\n        rng = np.random.default_rng(0)\n        \n        i_vals = np.arange(1, n + 1, dtype=np.float64)\n        x = 1.0 / i_vals\n        \n        if sigma > 0:\n            delta = rng.normal(loc=0.0, scale=sigma, size=n)\n            x += delta.astype(np.float64)\n\n        # Ensure final array is of the correct type\n        x = x.astype(np.float64)\n\n        # 2. Get ascending and descending views of the sequence\n        x_asc = x\n        x_desc = x[::-1].copy() # Use copy to ensure it's a new continuous array\n\n        # 3. Compute the four required sums\n        S_naive_up = naive_sum(x_asc)\n        S_naive_down = naive_sum(x_desc)\n        S_comp_up = kahan_sum(x_asc)\n        S_comp_down = kahan_sum(x_desc)\n\n        # 4. Compute the four metrics\n        d_naive = abs(S_naive_up - S_naive_down)\n        d_comp = abs(S_comp_up - S_comp_down)\n        I_up = abs(S_naive_up - S_comp_up)\n        I_down = abs(S_naive_down - S_comp_down)\n        \n        case_results = [d_naive, d_comp, I_up, I_down]\n        all_results.append(case_results)\n\n    # 5. Format the final output string as per requirements\n    # Format: [[d_naive_A,d_comp_A,I_up_A,I_down_A],[...]]\n    output_str = \",\".join([f\"[{','.join(map(str, res))}]\" for res in all_results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3221372"}]}