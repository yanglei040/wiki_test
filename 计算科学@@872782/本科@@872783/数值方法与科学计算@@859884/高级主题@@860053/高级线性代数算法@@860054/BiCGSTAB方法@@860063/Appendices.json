{"hands_on_practices": [{"introduction": "双共轭梯度稳定 (BiCGSTAB) 方法等克雷洛夫子空间方法的一个关键理论特性是其有限终止性。这个性质与矩阵的最小多项式密切相关，因为算法在理想情况下构造了一个与该多项式对应的残差多项式。通过这个练习[@problem_id:3210293]，您将为一个简单的 $2 \\times 2$ 系统推导这一过程，从而将抽象的理论与具体的计算联系起来，加深对算法收敛根本原因的理解。", "problem": "考虑将双共轭梯度稳定 (BiCGSTAB) 方法应用于一个线性系统，该系统具有一个二维的实、非奇异、非对称矩阵。设\n$$\nA \\;=\\; \\begin{pmatrix} 2  1 \\\\ 0  3 \\end{pmatrix},\n$$\n并假设初始猜测为 $x_{0} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$，右端项为 $b \\in \\mathbb{R}^{2}$，使得 $b \\neq 0$，并选择影子残差 $\\hat{r}_{0} = r_{0} := b - A x_{0} = b$。假设在 BiCGSTAB 递推过程中不发生崩溃（即，该方法定义的所有除法运算对于此输入都是良定义的）。\n\n仅使用以下基本原理：\n- 克雷洛夫子空间 $ \\mathcal{K}_{k}(A, r_{0}) = \\operatorname{span}\\{ r_{0}, A r_{0}, \\dots, A^{k-1} r_{0} \\}$ 的定义，\n- $A$ 的最小多项式 $\\mu_{A}(t)$ 的定义，即满足 $\\mu_{A}(A) = 0$ 的次数最低的唯一首一多项式，\n- 以及双共轭梯度稳定方法的更新关系，该关系将每个 BiCGSTAB 残差 $r_{k}$ 建立为 $r_{k} = \\phi_{k}(A)\\,r_{0}$ 的形式，其中 $\\phi_{k}$ 是某个多项式，\n\n完成以下任务：\n1) 从双共轭梯度稳定方法的更新方程推导，经过 $k$ 次外迭代后，残差具有形式 $r_{k} = \\phi_{k}(A)\\,r_{0}$，其中 $\\deg(\\phi_{k}) \\leq 2k$，并且 $\\phi_{k}(t)$ 可以分解为一个 $k$ 次“稳定”多项式和一个 $k$ 次双共轭梯度残差多项式的乘积。使用此结构以及最小多项式的定义，证明在二维情况下，只要不发生崩溃，该方法在最多两次外迭代内有限终止（即，在精确算术中 $r_{2} = 0$）。\n2) 对于上面给定的特定矩阵 $A$，显式计算其唯一的首一最小多项式 $\\mu_{A}(t)$。\n\n您的最终答案必须是多项式 $\\mu_{A}(t)$ 的显式解析表达式。不需要数值舍入。不要包含单位。", "solution": "问题分为两部分。第一部分是关于双共轭梯度稳定 (BiCGSTAB) 方法终止性质的理论推导。第二部分是针对给定矩阵计算最小多项式。\n\n第 1 部分：BiCGSTAB 残差结构和有限终止性\n\nBiCGSTAB 方法是一种求解非对称线性系统 $A x = b$ 的迭代方法。该方法生成一系列迭代解 $x_k$，使得相应的残差 $r_k = b - A x_k$ 逐渐减小。像 BiCGSTAB 这样的克雷洛夫子空间方法的一个关键特性是，经过 $k$ 次迭代后的残差可以表示为一个作用于初始残差 $r_0$ 的矩阵 $A$ 的多项式。\n\n正如问题所述，BiCGSTAB 方法经过 $k$ 次外迭代后的残差形式为 $r_k = \\phi_k(A) r_0$，其中 $\\phi_k(t)$ 是一个多项式。问题进一步指明了此多项式的结构。从算法的递推关系进行的详细推导证实，$\\phi_k(t)$ 是两个均为 $k$ 次的多项式的乘积：\n$$ \\phi_k(t) = \\sigma_k(t) \\psi_k(t) $$\n此处，$\\psi_k(t)$ 是一个 $k$ 次多项式，源于该算法底层的双共轭梯度 (BiCG) 结构。它被称为 BiCG 残差多项式。第二个多项式 $\\sigma_k(t) = \\prod_{j=1}^{k} (1 - \\omega_j t)$ 是一个 $k$ 次多项式，源于“稳定化”步骤，这些步骤类似于单步广义最小残差 (GMRES) 更新。系数 $\\omega_j$ 在每一步被选择以局部最小化残差的范数。因此，BiCGSTAB 残差多项式 $\\phi_k(t)$ 的总次数为 $\\deg(\\phi_k) = \\deg(\\sigma_k) + \\deg(\\psi_k) = k + k = 2k$。这确立了第一个所要求的性质。\n\n现在，我们使用此结构来证明 BiCGSTAB 对于一个 $2 \\times 2$ 矩阵的有限终止性。该论证依赖于矩阵最小多项式的性质。\n设 $A$ 是一个 $N \\times N$ 矩阵。$A$ 的最小多项式，记为 $\\mu_A(t)$，是满足 $\\mu_A(A) = 0$ 的次数最低的唯一首一多项式 $m$。根据 Cayley-Hamilton 定理，$m \\le N$。\n对于任意向量 $v$，$v$ 关于 $A$ 的最小多项式，记为 $\\mu_{A,v}(t)$，是满足 $\\mu_{A,v}(A)v=0$ 的次数最低的唯一首一多项式 $m'$。该多项式整除 $\\mu_A(t)$，因此其次数满足 $m' \\le m \\le N$。\n\n假设不发生崩溃，BiCG 方法保证在最多 $m'$ 步内找到精确解，其中 $m'$ 是初始残差 $r_0$ 关于 $A$ 的最小多项式的次数。这意味着当 $k=m'$ 时，BiCG 残差多项式 $\\psi_k(t)$ 必须是 $\\mu_{A, r_0}(t)$ 的一个标量倍。由于 $\\psi_{m'}(t)$ 和 $\\mu_{A, r_0}(t)/\\mu_{A, r_0}(0)$ 都是次数为 $m'$ 且在 $t=0$ 时等于 $1$ 的多项式，它们必须是相同的。因此，在第 $m'$ 步的 BiCG 残差为零：\n$$ r_{m'}^{\\text{BCG}} = \\psi_{m'}(A) r_0 = \\frac{\\mu_{A, r_0}(A)}{\\mu_{A, r_0}(0)} r_0 = 0 $$\n问题指出 BiCGSTAB 残差多项式 $\\phi_k(t)$ 分解为一个稳定部分和一个 BiCG 残差多项式部分 $\\psi_k(t)$。因此，在第 $k=m'$ 步的 BiCGSTAB 残差由下式给出：\n$$ r_{m'} = \\sigma_{m'}(A) \\psi_{m'}(A) r_0 $$\n代入 $\\psi_{m'}(A) r_0 = 0$ 的结果，我们得到：\n$$ r_{m'} = \\sigma_{m'}(A) \\cdot 0 = 0 $$\n这表明 BiCGSTAB 也必须在最多 $m'$ 步内终止。\n\n对于问题中给出的具体情况，矩阵 $A$ 的维数为 $N=2$。其最小多项式 $\\mu_A(t)$ 的次数为 $m \\le 2$。$r_0$ 关于 $A$ 的最小多项式的次数为 $m' \\le m \\le 2$。因此，BiCGSTAB 方法保证在某个 $k \\le m' \\le 2$ 时以 $r_k=0$ 终止。这意味着该方法在最多 2 次外迭代内找到精确解。\n\n第 2 部分：最小多项式的计算\n\n给定矩阵：\n$$ A = \\begin{pmatrix} 2  1 \\\\ 0  3 \\end{pmatrix} $$\n为了找到最小多项式 $\\mu_A(t)$，我们首先计算特征多项式 $\\chi_A(t)$。\n$$ \\chi_A(t) = \\det(A - tI) = \\det\\begin{pmatrix} 2-t  1 \\\\ 0  3-t \\end{pmatrix} $$\n$$ \\chi_A(t) = (2-t)(3-t) = t^2 - 5t + 6 $$\n最小多项式 $\\mu_A(t)$ 必须整除特征多项式 $\\chi_A(t)$。$\\chi_A(t)$ 的根是 $A$ 的特征值，即 $\\lambda_1 = 2$ 和 $\\lambda_2 = 3$。由于特征值是互不相同的，矩阵 $A$ 是可对角化的。对于一个可对角化的矩阵，其最小多项式是对应于每个不同特征值的线性因子的乘积。\n因此，最小多项式必须是：\n$$ \\mu_A(t) = (t-2)(t-3) = t^2 - 5t + 6 $$\n最小多项式要求是首一的，此多项式满足该条件。其次数为 $2$。$\\chi_A(t)$ 的仅有的其他首一因式是 $(t-2)$ 和 $(t-3)$，它们都是 $1$ 次的。我们检查它们是否零化 $A$：\n$$ A - 2I = \\begin{pmatrix} 2  1 \\\\ 0  3 \\end{pmatrix} - \\begin{pmatrix} 2  0 \\\\ 0  2 \\end{pmatrix} = \\begin{pmatrix} 0  1 \\\\ 0  1 \\end{pmatrix} \\neq 0 $$\n$$ A - 3I = \\begin{pmatrix} 2  1 \\\\ 0  3 \\end{pmatrix} - \\begin{pmatrix} 3  0 \\\\ 0  3 \\end{pmatrix} = \\begin{pmatrix} -1  1 \\\\ 0  0 \\end{pmatrix} \\neq 0 $$\n由于没有 1 次多项式能零化 $A$，最小多项式必须是 2 次的。因为它必须整除特征多项式且次数相同（并且两者都是首一的），所以它们必须相等。\n\n因此，$A$ 的唯一首一最小多项式是 $\\mu_A(t) = t^2 - 5t + 6$。", "answer": "$$\\boxed{t^2 - 5t + 6}$$", "id": "3210293"}, {"introduction": "BiCGSTAB 的设计初衷是为了解决其前身 BiCG 方法收敛不稳定和容易崩溃的问题。此练习 [@problem_id:2376326] 精心构造了一个场景，在该场景中，BiCG 方法由于双正交性损失而遭遇所谓的“幸运崩溃”(lucky breakdown)，导致计算无法继续。通过亲手计算 BiCG 和 BiCGSTAB 两种方法的第一步，您将清晰地看到 BiCGSTAB 的“稳定”步骤是如何巧妙地绕过这一障碍，从而直观体会其鲁棒性的来源。", "problem": "要求您从克里洛夫子空间迭代法的基本原理出发，演示双共轭梯度(BiCG)法如何可能发生崩溃，而稳定双共轭梯度(BiCGSTAB)法在相同的线性系统上仍然收敛。考虑线性系统 $A x = b$，其中\n$$\nA \\;=\\; \\begin{pmatrix}\n2  0  1\\\\\n1  3  0\\\\\n0  0  4\n\\end{pmatrix}, \n\\qquad\nb \\;=\\; \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix},\n\\qquad\nx_0 \\;=\\; \\begin{pmatrix} 0\\\\ 0\\\\ 0 \\end{pmatrix}.\n$$\n对于双共轭梯度(BiCG)法，设置初始残差 $r_0 = b - A x_0$ 和初始影子残差 $\\tilde{r}_0 = r_0$。仅使用BiCG法中第一步更新的定义（残差和影子残差由带双正交配对的单步克里洛夫投影定义），显式计算 $r_1$ 和 $\\tilde{r}_1$，并验证 $r_1 \\neq 0$，$\\tilde{r}_1 \\neq 0$ 且 $r_1^{T}\\tilde{r}_1 = 0$，这意味着BiCG法在下一步将发生崩溃。\n\n接下来，将稳定双共轭梯度(BiCGSTAB)法应用于具有相同初始猜测 $x_0$、相同初始残差 $r_0$ 和选定的固定影子残差 $\\hat{r}$ 的同一系统，其中\n$$\n\\hat{r} \\;=\\; r_0 + \\begin{pmatrix} 0\\\\ 1\\\\ 0 \\end{pmatrix} \\;=\\; \\begin{pmatrix} 1\\\\ 1\\\\ 0 \\end{pmatrix}.\n$$\n使用BiCGSTAB递推的标准定义（标量系数由 $r_{k-1}$、$\\hat{r}$ 以及在 $A$ 下的克里洛夫像的内积定义），执行第一次BiCGSTAB迭代以计算平滑参数 $\\omega_1$。\n\n您的任务是提供标量 $\\omega_1$ 的值。将您的最终答案精确地表示为最简分数。无需四舍五入。最终答案必须是一个没有单位的数字。", "solution": "所提出的问题具有科学依据、是适定的且客观的。它提供了一个具体的、可验证的数值例子，以演示计算物理学中的一个已知现象：双共轭梯度(BiCG)法在特定条件下的崩溃以及稳定双共轭梯度(BiCGSTAB)法的稳健性。所有必要的数据和定义都已提供，任务是直接的计算。因此，该问题是有效的。\n\n所考虑的线性系统是 $A x = b$，给定条件如下：\n$$\nA \\;=\\; \\begin{pmatrix}\n2  0  1\\\\\n1  3  0\\\\\n0  0  4\n\\end{pmatrix}, \n\\qquad\nb \\;=\\; \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix},\n\\qquad\nx_0 \\;=\\; \\begin{pmatrix} 0\\\\ 0\\\\ 0 \\end{pmatrix}.\n$$\n\n首先，我们分析BiCG方法。初始残差为 $r_0 = b - A x_0 = b - 0 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix}$。\n问题指定设置初始影子残差 $\\tilde{r}_0 = r_0$。因此，$\\tilde{r}_0 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix}$。\nBiCG算法将初始搜索方向设置为 $p_0 = r_0$ 和 $\\tilde{p}_0 = \\tilde{r}_0$。\n在每一步 $k$，标量 $\\alpha_k$ 计算如下 $\\alpha_k = \\frac{\\tilde{r}_k^T r_k}{\\tilde{p}_k^T A p_k}$。\n对于第一步（$k=0$）：\n分子是 $\\tilde{r}_0^T r_0 = r_0^T r_0 = \\begin{pmatrix} 1  0  0 \\end{pmatrix} \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} = 1$。\n为计算分母，我们首先求出 $A p_0$：\n$A p_0 = A r_0 = \\begin{pmatrix} 2  0  1\\\\ 1  3  0\\\\ 0  0  4 \\end{pmatrix} \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix}$。\n那么分母是 $\\tilde{p}_0^T A p_0 = \\tilde{r}_0^T (A r_0) = \\begin{pmatrix} 1  0  0 \\end{pmatrix} \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix} = 2$。\n因此，$\\alpha_0 = \\frac{1}{2}$。\n\n更新后的残差 $r_1$ 和 $\\tilde{r}_1$ 计算如下：\n$r_1 = r_0 - \\alpha_0 A p_0 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1\\\\ 1/2\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0\\\\ -1/2\\\\ 0 \\end{pmatrix}$。\n$\\tilde{r}_1 = \\tilde{r}_0 - \\alpha_0 A^T \\tilde{p}_0$。$A$ 的转置是 $A^T = \\begin{pmatrix} 2  1  0\\\\ 0  3  0\\\\ 1  0  4 \\end{pmatrix}$。\n$A^T \\tilde{p}_0 = A^T \\tilde{r}_0 = \\begin{pmatrix} 2  1  0\\\\ 0  3  0\\\\ 1  0  4 \\end{pmatrix} \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2\\\\ 0\\\\ 1 \\end{pmatrix}$。\n$\\tilde{r}_1 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} - \\frac{1}{2} \\begin{pmatrix} 2\\\\ 0\\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 1\\\\ 0\\\\ 1/2 \\end{pmatrix} = \\begin{pmatrix} 0\\\\ 0\\\\ -1/2 \\end{pmatrix}$。\n\n我们验证问题中陈述的条件：\n1. $r_1 = \\begin{pmatrix} 0\\\\ -1/2\\\\ 0 \\end{pmatrix} \\neq 0$。\n2. $\\tilde{r}_1 = \\begin{pmatrix} 0\\\\ 0\\\\ -1/2 \\end{pmatrix} \\neq 0$。\n3. $r_1^T \\tilde{r}_1 = \\begin{pmatrix} 0  -1/2  0 \\end{pmatrix} \\begin{pmatrix} 0\\\\ 0\\\\ -1/2 \\end{pmatrix} = (0)(0) + (-1/2)(0) + (0)(-1/2) = 0$。\n\nBiCG算法的下一步是计算 $\\beta_0 = \\frac{\\tilde{r}_1^T r_1}{\\tilde{r}_0^T r_0} = \\frac{0}{1} = 0$。\n这会得到新的搜索方向 $p_1 = r_1 + \\beta_0 p_0 = r_1$ 和 $\\tilde{p}_1 = \\tilde{r}_1 + \\beta_0 \\tilde{p}_0 = \\tilde{r}_1$。\n然后，下一个标量 $\\alpha_1$ 计算为 $\\alpha_1 = \\frac{\\tilde{r}_1^T r_1}{\\tilde{p}_1^T A p_1} = \\frac{0}{\\tilde{r}_1^T A r_1}$。\n分母项是 $\\tilde{r}_1^T A r_1 = \\begin{pmatrix} 0  0  -1/2 \\end{pmatrix} \\begin{pmatrix} 2  0  1\\\\ 1  3  0\\\\ 0  0  4 \\end{pmatrix} \\begin{pmatrix} 0\\\\ -1/2\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0  0  -2 \\end{pmatrix} \\begin{pmatrix} 0\\\\ -1/2\\\\ 0 \\end{pmatrix} = 0$。\n由于 $\\alpha_1$ 的分子和分母都为零，这构成了BiCG算法的严重崩溃。\n\n接下来，我们应用BiCGSTAB方法。初始残差为 $r_0 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix}$。给定的固定影子残差为 $\\hat{r} = \\begin{pmatrix} 1\\\\ 1\\\\ 0 \\end{pmatrix}$。\n标准算法以初始值 $\\rho_0=1$、$\\alpha_0=1$、$\\omega_0=1$、$p_0=0$ 和 $v_0=0$ 开始。我们执行第一次迭代（$k=1$）。\n\n1. 计算 $\\rho_1 = \\hat{r}^T r_0$：\n$\\rho_1 = \\begin{pmatrix} 1  1  0 \\end{pmatrix} \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} = 1$。\n\n2. 计算 $\\beta_1 = \\frac{\\rho_1}{\\rho_0} \\frac{\\alpha_0}{\\omega_0}$：\n$\\beta_1 = \\frac{1}{1} \\cdot \\frac{1}{1} = 1$。\n\n3. 计算 $p_1 = r_0 + \\beta_1 (p_0 - \\omega_0 v_0)$：\n$p_1 = r_0 + 1 (0 - 1 \\cdot 0) = r_0 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix}$。\n\n4. 计算 $v_1 = A p_1$：\n$v_1 = A r_0 = \\begin{pmatrix} 2  0  1\\\\ 1  3  0\\\\ 0  0  4 \\end{pmatrix} \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix}$。\n\n5. 计算 $\\alpha_1 = \\frac{\\rho_1}{\\hat{r}^T v_1}$：\n$\\hat{r}^T v_1 = \\begin{pmatrix} 1  1  0 \\end{pmatrix} \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix} = (1)(2) + (1)(1) + (0)(0) = 3$。\n$\\alpha_1 = \\frac{1}{3}$。\n\n6. 计算临时残差 $s_1 = r_0 - \\alpha_1 v_1$：\n$s_1 = \\begin{pmatrix} 1\\\\ 0\\\\ 0 \\end{pmatrix} - \\frac{1}{3} \\begin{pmatrix} 2\\\\ 1\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 - 2/3\\\\ 0 - 1/3\\\\ 0 - 0 \\end{pmatrix} = \\begin{pmatrix} 1/3\\\\ -1/3\\\\ 0 \\end{pmatrix}$。\n\n7. 计算 $t_1 = A s_1$：\n$t_1 = \\begin{pmatrix} 2  0  1\\\\ 1  3  0\\\\ 0  0  4 \\end{pmatrix} \\begin{pmatrix} 1/3\\\\ -1/3\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2(1/3) + 0(-1/3) + 1(0) \\\\ 1(1/3) + 3(-1/3) + 0(0) \\\\ 0(1/3) + 0(-1/3) + 4(0) \\end{pmatrix} = \\begin{pmatrix} 2/3\\\\ 1/3 - 1\\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 2/3\\\\ -2/3\\\\ 0 \\end{pmatrix}$。\n\n8. 计算平滑参数 $\\omega_1 = \\frac{t_1^T s_1}{t_1^T t_1}$：\n分子是 $t_1^T s_1 = \\begin{pmatrix} 2/3  -2/3  0 \\end{pmatrix} \\begin{pmatrix} 1/3\\\\ -1/3\\\\ 0 \\end{pmatrix} = (\\frac{2}{3})(\\frac{1}{3}) + (\\frac{-2}{3})(\\frac{-1}{3}) = \\frac{2}{9} + \\frac{2}{9} = \\frac{4}{9}$。\n分母是 $t_1^T t_1 = \\begin{pmatrix} 2/3  -2/3  0 \\end{pmatrix} \\begin{pmatrix} 2/3\\\\ -2/3\\\\ 0 \\end{pmatrix} = (\\frac{2}{3})^2 + (\\frac{-2}{3})^2 = \\frac{4}{9} + \\frac{4}{9} = \\frac{8}{9}$。\n$\\omega_1 = \\frac{4/9}{8/9} = \\frac{4}{8} = \\frac{1}{2}$。\n\n平滑参数 $\\omega_1$ 的值为 $\\frac{1}{2}$。这表明，在适当选择 $\\hat{r}$ 的情况下，BiCGSTAB算法不会崩溃并能继续进行计算。", "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$", "id": "2376326"}, {"introduction": "从理论分析转向实际应用，一个稳健的求解器必须能在有限精度算术中处理各种数值不稳定性。尽管 BiCGSTAB 比 BiCG 更可靠，但它仍可能遇到分母接近于零的数值“崩溃”情况。这个综合性编程练习 [@problem_id:3210263] 要求您实现一个完整的 BiCGSTAB 求解器，并为其配备一个用于检测和修复潜在崩溃的机制。这个练习是连接算法理论与科学计算实践的桥梁，旨在培养您构建不仅正确而且在实际应用中足够强大的数值工具的能力。", "problem": "您需要使用带有“失效修复”机制的双共轭梯度稳定 (Bi-Conjugate Gradient Stabilized, BiCGSTAB) 方法，为线性系统 $A x = b$ 实现一个鲁棒的求解器。该修复机制用于处理当双正交标量 $\\rho_k = \\langle \\hat{r}, r_k \\rangle$ 在数值上接近于零时的“接近失效”情况。实现必须是完全确定性的、可复现的、且自包含的。\n\n从以下基础出发：\n- 对于一个非对称、非奇异矩阵 $A \\in \\mathbb{R}^{n \\times n}$，Krylov 子空间方法从仿射空间 $x_0 + \\mathcal{K}_k(A, r_0)$ 中构造近似解 $x_k$，其中 $r_0 = b - A x_0$ 且 $\\mathcal{K}_k(A, r_0) = \\text{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$。\n- 双共轭梯度 (Bi-Conjugate Gradient, BiCG) 方法寻找满足双正交约束的两个序列，该约束由影子残差 $\\hat{r}$ 定义，要求在每一步中，内积 $\\langle \\hat{r}, r_k \\rangle$ 和 $\\langle \\hat{r}, v_k \\rangle$ 都是良定义且非零的。\n- 双共轭梯度稳定 (BiCGSTAB) 方法对 BiCG 应用了局部最小残差稳定化，以提高其在求解非对称问题时的鲁棒性。\n\n定义一个“接近失效”事件，当 $|\\rho_k| \\le \\tau \\,\\|\\hat{r}\\|_2 \\,\\|r_k\\|_2$ 时发生，其中 $\\rho_k = \\langle \\hat{r}, r_k \\rangle$，$\\tau > 0$ 是一个很小的阈值。在此类事件发生时，执行确定性的“失效修复”操作，包括：\n- 使用一个带有指定种子的固定伪随机数生成器，选择一个单位范数的随机方向 $z$。\n- 通过 $\\hat{r} \\leftarrow r_k + \\varepsilon z$ 更新影子残差，其中 $\\varepsilon > 0$ 是一个小正数。\n- 对迭代解施加一个小的随机步长 $x_k \\leftarrow x_k + \\gamma \\|r_k\\|_2 z$，其中 $\\gamma > 0$ 是一个小正数。\n- 通过将辅助向量和标量重置为其初始值来重启 BiCGSTAB 递推。\n- 将总修复次数限制为一个小的整数 $R_{\\max}$，如果超过则声明失败。\n\n您的程序必须实现以下内容：\n- 一个函数，该函数尝试使用上述的“接近失效”检测和修复机制通过 BiCGSTAB 求解 $A x = b$。使用相对残差容差 $\\|b - A x_k\\|_2 / \\|b\\|_2 \\le \\text{tol}$ 作为成功标准。使用最大迭代次数 $\\text{max\\_iter}$。\n- “接近失效”检测器必须使用不等式 $|\\rho_k| \\le \\tau \\,\\|\\hat{r}\\|_2 \\,\\|r_k\\|_2$ 以及给定的 $\\tau$。您还必须对其他可能导致失效的除法（例如 $\\langle \\hat{r}, v_k \\rangle$ 和 $\\langle t, t \\rangle$）采用相同的修复策略，当它们的绝对值 $\\le \\tau$ 乘以某个相关范数的乘积时。\n- 修复参数必须固定如下：$\\tau = 10^{-14}$，$\\varepsilon = 10^{-16}$，$\\gamma = 10^{-8}$，$R_{\\max} = 5$。所有随机向量 $z$ 必须由一个使用给定种子的伪随机数生成器确定性地生成，然后归一化为单位 $2$-范数。\n\n输入数据与确定性：\n- 您不能读取任何输入。必须按照下文规定在内部构造所有测试矩阵和向量。所有随机抽样必须使用为每个测试案例给定的种子初始化的伪随机数生成器，从标准正态分布中进行。在每个案例中，维度为 $n$，初始猜测为 $x_0 = 0$。\n\n测试套件。对每个案例，生成一个布尔值，指示求解器是否返回了一个满足相对残差 $\\le \\text{tol}$ 的解 $x$。\n\n- 案例1（顺利路径，对角占优非对称系统）：\n  - 维度 $n = 10$。\n  - 种子 $20231107$。\n  - 抽取一个矩阵 $M \\in \\mathbb{R}^{n \\times n}$，其元素为独立的标准正态分布。\n  - 设置 $A \\leftarrow M$，然后对每一行 $i$ 通过更新 $A_{ii} \\leftarrow A_{ii} + \\sum_{j=1}^{n} |A_{ij}| + 0.5$ 来强制实现严格对角占优。\n  - 抽取一个向量 $x^\\star \\in \\mathbb{R}^{n}$，其元素为标准正态分布，并设置 $b \\leftarrow A x^\\star$。\n  - 使用 $x_0 = 0$，无影子残差覆盖。\n  - 使用 $\\text{tol} = 10^{-10}$，$\\text{max\\_iter} = 1000$，$\\tau = 10^{-14}$。\n\n- 案例2（通过近乎正交的影子残差在第一步强制触发接近失效）：\n  - 维度 $n = 12$。\n  - 种子 $20231108$。\n  - 如案例1一样构造 $A$（带对角占优）。\n  - 抽取一个标准正态分布的 $x^\\star$ 并设置 $b \\leftarrow A x^\\star$。\n  - 使用 $x_0 = 0$。令 $r_0 = b$。\n  - 抽取一个标准正态分布的 $z \\in \\mathbb{R}^{n}$，构造 $z_\\perp \\leftarrow z - \\frac{\\langle z, r_0 \\rangle}{\\langle r_0, r_0 \\rangle} r_0$，并将初始影子残差设置为 $\\hat{r}_0 \\leftarrow z_\\perp + 10^{-16} r_0$。\n  - 使用 $\\text{tol} = 10^{-10}$，$\\text{max\\_iter} = 1000$，$\\tau = 10^{-14}$。\n  - 算法必须在开始时检测到接近失效，并使用上述规则进行确定性修复。\n\n- 案例3（轻度非对称、良态的、带有小上三角扰动的三对角矩阵）：\n  - 维度 $n = 30$。\n  - 种子 $20231109$。\n  - 令 $T \\in \\mathbb{R}^{n \\times n}$ 为三对角矩阵，其中 $T_{ii} = 2$，$T_{i,i+1} = -1$，$T_{i+1,i} = -1$（对于 $i = 1,\\dots,n-1$）。\n  - 令 $U$ 为严格上三角矩阵，其中 $U_{ij} = 10^{-2} \\,\\xi_{ij}$（对于 $i  j$），其中每个 $\\xi_{ij}$ 是从带种子的生成器中抽取的标准正态分布；$U_{ij} = 0$（对于 $i \\ge j$）。\n  - 设置 $A \\leftarrow T + U$。\n  - 抽取一个标准正态分布的 $x^\\star$ 并设置 $b \\leftarrow A x^\\star$。\n  - 使用 $x_0 = 0$，无影子残差覆盖。\n  - 使用 $\\text{tol} = 10^{-10}$，$\\text{max\\_iter} = 2000$，$\\tau = 10^{-14}$。\n\n对于所有案例，使用相同的失效修复常数 $\\varepsilon = 10^{-16}$，$\\gamma = 10^{-8}$ 和 $R_{\\max} = 5$。成功条件是相对残差 $\\|b - A x\\|_2 / \\|b\\|_2 \\le \\text{tol}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，包含按顺序1,2,3排列的案例结果，结果为逗号分隔的列表，并用方括号括起来。例如：“[true1,true2,true3]”，使用布尔字面量，即“[True,False,True]”。", "solution": "该问题要求实现双共轭梯度稳定 (BiCGSTAB) 方法来求解非对称线性系统 $A x = b$。任务的一个关键部分是集成一个特定的“失效修复”机制，以处理算法中某些标量值在数值上接近于零时出现的数值不稳定性。整个实现必须是确定性的，其随机部分由一个带种子的伪随机数生成器 (PRNG) 控制。\n\n首先，让我们形式化地描述带有指定修复机制的 BiCGSTAB 算法。该算法迭代地计算线性系统的近似解 $x_k$。\n\n标准的 BiCGSTAB 算法流程如下，从初始猜测 $x_0$ (此处为 $x_0=0$) 开始：\n\n1.  **初始化**：\n    $r \\leftarrow b - A x$\n    $\\hat{r} \\leftarrow r$ (或一个指定的初始影子残差)\n    $p \\leftarrow 0$, $v \\leftarrow 0$\n    $\\rho_{prev} \\leftarrow 1$, $\\alpha \\leftarrow 1$, $\\omega \\leftarrow 1$\n    \n2.  **迭代**：对于 $k=1, 2, \\dots, \\text{max\\_iter}$:\n    a.  $\\rho \\leftarrow \\langle \\hat{r}, r \\rangle$\n    b.  $\\beta \\leftarrow (\\rho / \\rho_{prev}) (\\alpha / \\omega)$\n    c.  $p \\leftarrow r + \\beta (p - \\omega v)$\n    d.  $v \\leftarrow A p$\n    e.  $\\alpha \\leftarrow \\rho / \\langle \\hat{r}, v \\rangle$\n    f.  $s \\leftarrow r - \\alpha v$\n    g.  $t \\leftarrow A s$\n    h.  $\\omega \\leftarrow \\langle t, s \\rangle / \\langle t, t \\rangle$\n    i.  $x \\leftarrow x + \\alpha p + \\omega s$\n    j.  $r \\leftarrow s - \\omega t$\n    k.  $\\rho_{prev} \\leftarrow \\rho$\n    l.  检查收敛性。\n\n如果在计算 $\\beta$, $\\alpha$ 或 $\\omega$ 时，任何分母为零或数值上非常小，该算法就容易发生失效。具体来说，这些分母是 $\\rho_{prev}$，$\\langle \\hat{r}, v \\rangle$ 和 $\\langle t, t \\rangle$。问题定义了一种“接近失效”情况以及相应的修复策略。\n\n如果一个分母的绝对值小于由容差 $\\tau$ 和相关向量的范数定义的阈值，则检测到接近失效事件。三个具体的检查是：\n\n1.  对于 $\\rho = \\langle \\hat{r}, r \\rangle$: 如果 $|\\rho| \\le \\tau \\|\\hat{r}\\|_2 \\|r\\|_2$，则标记为失效。此检查在计算 $\\beta$ 之前执行。注意，当前迭代的 $\\rho$ 会成为下一次迭代的 $\\rho_{prev}$，因此该检查有效地保护了 $\\beta$ 的分母。\n2.  对于 $\\delta = \\langle \\hat{r}, v \\rangle$: 如果 $|\\delta| \\le \\tau \\|\\hat{r}\\|_2 \\|v\\|_2$，则标记为失效。这是 $\\alpha$ 的分母。\n3.  对于 $\\eta = \\langle t, t \\rangle = \\|t\\|_2^2$: 如果 $|\\eta| \\le \\tau \\|t\\|_2 \\|t\\|_2$，则标记为失效，这可以简化为 $\\|t\\|_2^2 \\le \\tau \\|t\\|_2^2$。对于 $\\tau  1$，此条件仅在 $\\|t\\|_2 = 0$ 时满足。这能正确识别当 $t$ 是零向量时的失效情况。\n\n一旦检测到任何这些接近失效的条件，将执行以下确定性修复程序：\n\n1.  增加修复计数器。如果计数器超过最大值 $R_{\\max}$，求解过程失败。\n2.  使用带种子的 PRNG 从标准正态分布中生成一个随机向量 $z \\in \\mathbb{R}^n$，并将其归一化为单位 $L_2$-范数：$z \\leftarrow z / \\|z\\|_2$。\n3.  扰动影子残差：$\\hat{r} \\leftarrow r + \\varepsilon z$，其中 $r$ 是当前残差，$\\varepsilon$ 是一个小的正常数。\n4.  在解空间中迈出一个小的随机步：$x \\leftarrow x + \\gamma \\|r\\|_2 z$，其中 $\\gamma$ 是另一个小的正常数。\n5.  基于新的迭代解重新计算真实残差：$r \\leftarrow b - A x$。\n6.  通过将辅助向量和标量重置为其初始状态来重启 BiCGSTAB 递推：$p \\leftarrow 0$, $v \\leftarrow 0$, $\\rho_{prev} \\leftarrow 1$, $\\alpha \\leftarrow 1$, $\\omega \\leftarrow 1$。然后算法使用更新后的 $x$, $r$, 和 $\\hat{r}$ 继续下一次迭代。\n\n整个算法被实现为一个单一函数，该函数接受矩阵 $A$、向量 $b$ 和其他参数。它返回一个布尔值，指示是否在给定的容差 $\\text{tol}$、最大迭代次数 $\\text{max\\_iter}$ 和最大修复次数 $R_{\\max}$ 内达到了收敛。收敛由相对残差范数定义：$\\|b - A x\\|_2 / \\|b\\|_2 \\le \\text{tol}$。\n\n指定的三个测试案例如下构造：\n- **案例1**: 一个 $10 \\times 10$ 的对角占优矩阵，对于 BiCGSTAB 来说应该表现良好。这作为一个“顺利路径”测试。矩阵 $A$ 是从一个随机矩阵 $M$ 生成的，通过将每个对角元素 $A_{ii}$ 更新为 $A_{ii} \\leftarrow M_{ii} + \\sum_{j=1}^{n} |M_{ij}| + 0.5$。\n- **案例2**: 一个 $12 \\times 12$ 的系统，旨在在第一次迭代时触发失效修复机制。这是通过将初始影子残差 $\\hat{r}_0$ 设置为与初始残差 $r_0=b$ 近乎正交来实现的。因此，点积 $\\rho_1 = \\langle \\hat{r}_0, r_0 \\rangle$ 将会非常小，从而触发条件 $|\\rho_1| \\le \\tau \\|\\hat{r}_0\\|_2 \\|r_0\\|_2$。\n- **案例3**: 一个 $30 \\times 30$ 的系统，基于一个离散拉普拉斯算子（一个对称正定三对角矩阵），并被一个小的、严格上三角的随机矩阵扰动。这创建了一个轻度非对称、良态的系统。\n\n对于每个案例，右端向量 $b$ 通过 $b = A x^\\star$ 构造，其中 $x^\\star$ 是一个已知的“真实”解，其元素从标准正态分布中抽取。这确保了系统是相容的，并允许在需要时进行验证，尽管收敛准则仅依赖于残差。求解器从初始猜测 $x_0=0$ 开始。用于矩阵构造和失效修复的所有伪随机数都是使用每个案例的种子值确定性地生成的，以确保可复现性。实现的求解器将应用于每个案例，并报告布尔结果（成功或失败）。", "answer": "```python\nimport numpy as np\n\ndef bicgstab_with_repair(A, b, x0, tol, max_iter, seed, r_hat0=None, tau=1e-14, epsilon=1e-16, gamma=1e-8, R_max=5):\n    \"\"\"\n    Solves the linear system Ax = b using the Bi-Conjugate Gradient Stabilized (BiCGSTAB)\n    method with a breakdown repair mechanism.\n\n    Args:\n        A (np.ndarray): The n x n coefficient matrix.\n        b (np.ndarray): The n-dimensional right-hand side vector.\n        x0 (np.ndarray): The initial guess for the solution.\n        tol (float): The relative residual tolerance for convergence.\n        max_iter (int): The maximum number of iterations.\n        seed (int): Seed for the pseudorandom number generator for repairs.\n        r_hat0 (np.ndarray, optional): The initial shadow residual. If None, set to r0.\n        tau (float): Threshold for breakdown detection.\n        epsilon (float): Perturbation factor for shadow residual in repair.\n        gamma (float): Step size factor for solution update in repair.\n        R_max (int): Maximum number of repairs allowed.\n\n    Returns:\n        tuple: (bool indicating success, final solution vector x)\n    \"\"\"\n    n = A.shape[0]\n    x = x0.copy()\n    \n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return True, np.zeros(n)\n\n    r = b - A @ x\n    \n    if r_hat0 is None:\n        hat_r = r.copy()\n    else:\n        hat_r = r_hat0.copy()\n\n    # Auxiliary vectors and scalars\n    p = np.zeros(n)\n    v = np.zeros(n)\n    rho_prev = 1.0\n    alpha = 1.0\n    omega = 1.0\n    \n    num_repairs = 0\n    rng = np.random.default_rng(seed)\n\n    # Initial residual check\n    if np.linalg.norm(r) / norm_b = tol:\n        return True, x\n\n    for _ in range(max_iter):\n        rho = np.dot(hat_r, r)\n        \n        # --- Breakdown Detection and Repair ---\n        do_repair = False\n        \n        # Check 1: Breakdown in rho\n        norm_hat_r = np.linalg.norm(hat_r)\n        norm_r = np.linalg.norm(r)\n        if abs(rho) = tau * norm_hat_r * norm_r:\n            do_repair = True\n        \n        if not do_repair:\n            if abs(rho_prev) == 0.0 and abs(omega) == 0.0:  # Avoid division by zero\n                 do_repair = True\n            else:\n                 beta = (rho / rho_prev) * (alpha / omega) if rho_prev != 0 and omega != 0 else 0.0\n                 p = r + beta * (p - omega * v)\n                 v = A @ p\n                 \n                 # Check 2: Breakdown in alpha's denominator\n                 denom_alpha = np.dot(hat_r, v)\n                 norm_v = np.linalg.norm(v)\n                 if abs(denom_alpha) = tau * norm_hat_r * norm_v:\n                     do_repair = True\n\n        if do_repair:\n            if num_repairs >= R_max:\n                return False, x\n            num_repairs += 1\n            \n            z = rng.standard_normal(n)\n            z /= np.linalg.norm(z)\n            \n            hat_r = r + epsilon * z\n            x += gamma * norm_r * z\n            r = b - A @ x\n            \n            # Restart recurrence\n            p = np.zeros(n)\n            v = np.zeros(n)\n            rho_prev = 1.0\n            alpha = 1.0\n            omega = 1.0\n            continue\n\n        # --- Standard BiCGSTAB Step ---\n        alpha = rho / denom_alpha\n        s = r - alpha * v\n\n        # Early exit if s is small\n        if np.linalg.norm(s) / norm_b = tol:\n            x += alpha * p\n            # Recompute final residual for accurate check\n            final_r = b - A @ x\n            if np.linalg.norm(final_r) / norm_b = tol:\n                return True, x\n            # else continue, might not have converged yet\n        \n        t = A @ s\n        \n        # Check 3: Breakdown in omega's denominator\n        norm_t_sq = np.dot(t, t)\n        norm_t = np.sqrt(norm_t_sq)\n        if norm_t_sq = tau * norm_t * norm_t: # Effectively checks if t is zero\n            if num_repairs >= R_max:\n                return False, x\n            num_repairs += 1\n            z = rng.standard_normal(n)\n            z /= np.linalg.norm(z)\n            hat_r = r + epsilon * z\n            x += gamma * norm_r * z\n            r = b - A @ x\n            p = np.zeros(n); v = np.zeros(n); rho_prev = 1.0; alpha = 1.0; omega = 1.0\n            continue\n\n        omega = np.dot(t, s) / norm_t_sq\n        x += alpha * p + omega * s\n        r = s - omega * t\n        \n        rho_prev = rho\n\n        # --- Convergence Check ---\n        final_r = b - A @ x\n        if np.linalg.norm(final_r) / norm_b = tol:\n            return True, x\n\n    return False, x\n\ndef solve():\n    # Global Parameters\n    params = {\n        'tau': 1e-14,\n        'epsilon': 1e-16,\n        'gamma': 1e-8,\n        'R_max': 5\n    }\n\n    results = []\n\n    # --- Case 1 ---\n    n1 = 10\n    seed1 = 20231107\n    tol1 = 1e-10\n    max_iter1 = 1000\n    rng1 = np.random.default_rng(seed1)\n    \n    M1 = rng1.standard_normal((n1, n1))\n    A1 = M1.copy()\n    diag_updates = np.array([np.sum(np.abs(M1[i, :])) for i in range(n1)])\n    np.fill_diagonal(A1, M1.diagonal() + diag_updates + 0.5)\n    \n    x_star1 = rng1.standard_normal(n1)\n    b1 = A1 @ x_star1\n    x0_1 = np.zeros(n1)\n    \n    success1, _ = bicgstab_with_repair(A1, b1, x0_1, tol1, max_iter1, seed1, **params)\n    results.append(success1)\n\n    # --- Case 2 ---\n    n2 = 12\n    seed2 = 20231108\n    tol2 = 1e-10\n    max_iter2 = 1000\n    rng2 = np.random.default_rng(seed2)\n\n    M2 = rng2.standard_normal((n2, n2))\n    A2 = M2.copy()\n    diag_updates_2 = np.array([np.sum(np.abs(M2[i, :])) for i in range(n2)])\n    np.fill_diagonal(A2, M2.diagonal() + diag_updates_2 + 0.5)\n\n    x_star2 = rng2.standard_normal(n2)\n    b2 = A2 @ x_star2\n    x0_2 = np.zeros(n2)\n    r0_2 = b2 - A2 @ x0_2\n\n    z2 = rng2.standard_normal(n2)\n    z_perp = z2 - (np.dot(z2, r0_2) / np.dot(r0_2, r0_2)) * r0_2\n    r_hat0_2 = z_perp + 1e-16 * r0_2\n    \n    success2, _ = bicgstab_with_repair(A2, b2, x0_2, tol2, max_iter2, seed2, r_hat0=r_hat0_2, **params)\n    results.append(success2)\n\n    # --- Case 3 ---\n    n3 = 30\n    seed3 = 20231109\n    tol3 = 1e-10\n    max_iter3 = 2000\n    rng3 = np.random.default_rng(seed3)\n    \n    T3 = np.diag(2 * np.ones(n3)) - np.diag(np.ones(n3 - 1), k=1) - np.diag(np.ones(n3 - 1), k=-1)\n    \n    U3 = np.zeros((n3, n3))\n    xi3 = rng3.standard_normal((n3, n3))\n    for i in range(n3):\n        for j in range(i + 1, n3):\n            U3[i, j] = 1e-2 * xi3[i, j]\n            \n    A3 = T3 + U3\n    \n    x_star3 = rng3.standard_normal(n3)\n    b3 = A3 @ x_star3\n    x0_3 = np.zeros(n3)\n\n    success3, _ = bicgstab_with_repair(A3, b3, x0_3, tol3, max_iter3, seed3, **params)\n    results.append(success3)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3210263"}]}