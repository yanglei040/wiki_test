{"hands_on_practices": [{"introduction": "将偏微分方程的离散形式转化为矩阵系统，是实现Crank-Nicolson方法的第一步。本练习将引导你为一个简单的一维热方程问题构建核心矩阵$A$和$B$ ([@problem_id:2139888])。通过这个过程，你将具体地理解该格式如何随时间推进求解，为将来应用此方法解决更复杂的问题打下坚实的基础。", "problem": "考虑一维热方程 $u_t = \\alpha u_{xx}$，其中函数 $u(x, t)$ 定义在空间域 $x \\in [0, L]$ 和时间 $t \\geq 0$ 上。该方程满足齐次狄利克雷边界条件 $u(0, t) = u(L, t) = 0$。\n\n我们希望使用 Crank-Nicolson 方法对此方程进行数值求解。空间域被离散化为间距为 $\\Delta x$ 的均匀网格，使得恰好有三个内部网格点。设 $\\Delta t$ 为时间步长。该方法得到一个形如 $A\\mathbf{u}^{n+1} = B\\mathbf{u}^{n}$ 的矩阵方程组，其中 $\\mathbf{u}^{k}$ 是在时间步 $k$ 时三个内部网格点上数值解的列向量。\n\n定义参数 $\\lambda$ 为 $\\lambda = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$。\n\n以下哪个选项正确地给出了 $3 \\times 3$ 矩阵 $A$ 和 $B$？\n\nA. $A = \\begin{pmatrix} 1+\\lambda  -\\frac{\\lambda}{2}  0 \\\\ -\\frac{\\lambda}{2}  1+\\lambda  -\\frac{\\lambda}{2} \\\\ 0  -\\frac{\\lambda}{2}  1+\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1-\\lambda  \\frac{\\lambda}{2}  0 \\\\ \\frac{\\lambda}{2}  1-\\lambda  \\frac{\\lambda}{2} \\\\ 0  \\frac{\\lambda}{2}  1-\\lambda \\end{pmatrix}$\n\nB. $A = \\begin{pmatrix} 1-\\lambda  \\frac{\\lambda}{2}  0 \\\\ \\frac{\\lambda}{2}  1-\\lambda  \\frac{\\lambda}{2} \\\\ 0  \\frac{\\lambda}{2}  1-\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1+\\lambda  -\\frac{\\lambda}{2}  0 \\\\ -\\frac{\\lambda}{2}  1+\\lambda  -\\frac{\\lambda}{2} \\\\ 0  -\\frac{\\lambda}{2}  1+\\lambda \\end{pmatrix}$\n\nC. $A = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$, $B = \\begin{pmatrix} 1-2\\lambda  \\lambda  0 \\\\ \\lambda  1-2\\lambda  \\lambda \\\\ 0  \\lambda  1-2\\lambda \\end{pmatrix}$\n\nD. $A = \\begin{pmatrix} 1+2\\lambda  -\\lambda  0 \\\\ -\\lambda  1+2\\lambda  -\\lambda \\\\ 0  -\\lambda  1+2\\lambda \\end{pmatrix}$, $B = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix}$", "solution": "我们用均匀间距 $\\Delta x$ 离散化空间区间，并记内部索引为 $i=1,2,3$。齐次狄利克雷边界条件要求对所有 $n$ 都有 $u_{0}^{n}=0$ 和 $u_{4}^{n}=0$。\n\n令 $u_{i}^{n}$ 近似 $u(x_{i}, t^{n})$。Crank–Nicolson 方法对 $u_{t}=\\alpha u_{xx}$ 在内部点 $i$ 的离散化为\n$$\n\\frac{u_{i}^{n+1}-u_{i}^{n}}{\\Delta t}\n=\\frac{\\alpha}{2}\\left(\\frac{u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}}{(\\Delta x)^{2}}+\\frac{u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1}}{(\\Delta x)^{2}}\\right).\n$$\n设 $\\lambda=\\frac{\\alpha\\Delta t}{(\\Delta x)^{2}}$，两边同乘以 $\\Delta t$ 可得\n$$\nu_{i}^{n+1}-u_{i}^{n}\n=\\frac{\\lambda}{2}\\left[(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n})+(u_{i+1}^{n+1}-2u_{i}^{n+1}+u_{i-1}^{n+1})\\right].\n$$\n整理方程，将未知的时间层 $n+1$ 的项移到左边，时间层 $n$ 的项移到右边，得到\n$$\n\\left(1+\\lambda\\right)u_{i}^{n+1}-\\frac{\\lambda}{2}u_{i+1}^{n+1}-\\frac{\\lambda}{2}u_{i-1}^{n+1}\n=\\left(1-\\lambda\\right)u_{i}^{n}+\\frac{\\lambda}{2}u_{i+1}^{n}+\\frac{\\lambda}{2}u_{i-1}^{n}.\n$$\n由于边界值为零，没有出现额外的边界项。将 $i=1,2,3$ 的这个方程组写成矩阵形式 $A\\mathbf{u}^{n+1}=B\\mathbf{u}^{n}$，其中 $\\mathbf{u}^{k}=(u_{1}^{k},u_{2}^{k},u_{3}^{k})^{T}$，得到的矩阵为\n$$\nA=\\begin{pmatrix}\n1+\\lambda  -\\frac{\\lambda}{2}  0 \\\\\n-\\frac{\\lambda}{2}  1+\\lambda  -\\frac{\\lambda}{2} \\\\\n0  -\\frac{\\lambda}{2}  1+\\lambda\n\\end{pmatrix},\\quad\nB=\\begin{pmatrix}\n1-\\lambda  \\frac{\\lambda}{2}  0 \\\\\n\\frac{\\lambda}{2}  1-\\lambda  \\frac{\\lambda}{2} \\\\\n0  \\frac{\\lambda}{2}  1-\\lambda\n\\end{pmatrix}.\n$$\n这与选项 A 相符。", "answer": "$$\\boxed{A}$$", "id": "2139888"}, {"introduction": "Crank-Nicolson方法因其无条件稳定性而备受推崇，但这并不意味着它能避免所有数值问题。这个动手编程实践将挑战你去探究该方法如何响应非光滑的初始条件，特别是一个急剧的间断点 ([@problem_id:3220540])。通过特意设计一个场景来产生并量化数值振荡，你将对该方法的特性以及解的光滑性的重要性获得更深刻的直觉。", "problem": "考虑有限区间上具有齐次狄利克雷边界条件的一维热方程。设 $u(x,t)$ 在 $x \\in (0,1)$，$t \\ge 0$ 上满足 $u_t = \\nu u_{xx}$，边界条件为 $u(0,t) = 0$，$u(1,t) = 0$，初始条件 $u(x,0) = u_0(x)$ 是一个不连续函数，其值仅为 $0$ 或 $1$。目标是使用 Crank-Nicolson 方法，在较大时间步长下，刻意生成并分析由不连续性引起的非物理振荡。\n\n从该偏微分方程以及时间和空间上的一阶和二阶导数的标准定义出发，完成以下任务：\n\n1) 将空间域离散化为 $M$ 个内部点，均匀间距为 $\\Delta x = 1/(M+1)$，并用内部网格上的中心有限差分算子近似二阶导数。在时间上使用时间步长为 $\\Delta t  0$ 的梯形 (Crank-Nicolson) 法则，以获得在每个时间步将 $u^n$推进到 $u^{n+1}$ 的线性系统。定义无量纲参数 $\\mu = \\nu \\Delta t / \\Delta x^2$。\n\n2) 在离散网格上设计一个不连续的初始条件 $u^0$，它是一个二元向量（值为 $0$ 或 $1$），具有单个跳跃不连续点，使得在单个时间步后，Crank-Nicolson 方法产生的非物理振荡的振幅最大化。设计空间仅限于以下形式的离散亥维赛阶跃函数：\n- 对于 $i \\le m$，$u_i^0 = 1$；对于 $i  m$，$u_i^0 = 0$，其中 $i \\in \\{1,2,\\dots,M\\}$ 是内部点的索引，$m \\in \\{1,2,\\dots,M-1\\}$。\n您的任务是选择 $m$（从而确定阶跃位置），以在给定 $M$ 的情况下最大化振荡伪影。您的选择必须在解题报告中从第一性原理出发进行论证，但您的程序必须实现一个固定的、体现您论证的设计。\n\n3) 使用您的离散化产生的三对角系统，实现 Crank-Nicolson 时间步，并在 $x=0$ 和 $x=1$ 处施加齐次狄利克雷边界条件。对于下面定义的每个测试用例，将解从您设计的 $u^0$ 精确推进一个时间步，以获得 $u^1$。\n\n4) 使用从 $u^1$ 计算出的以下两个标量来量化非物理振荡：\n- 下冲幅度 $U = \\max(0,\\,-\\min_i u_i^1)$。\n- 过冲幅度 $O = \\max(0,\\,\\max_i u_i^1 - 1)$。\n这些值必须是非负实数。\n\n对所有测试使用以下固定参数：\n- $\\nu = 1$。\n- $M = 400$ 个内部点。\n- 网格是 $[0,1]$ 均匀划分的 $M$ 个内部点。\n- 对每个参数集，仅使用一个时间步，并从 $u^0$ 计算 $u^1$。\n\n测试套件（改变无量纲时间步长 $\\mu$）：\n- 情况 A（亚阈值，预期振荡很小或没有）：$\\mu = 0.2$。\n- 情况 B（略高于阈值，预期有可见振荡）：$\\mu = 0.6$。\n- 情况 C（高度刚性，预期有强振荡）：$\\mu = 5.0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每种情况，按顺序输出下冲和过冲，因此最终输出必须是展平的列表\n$[U_A, O_A, U_B, O_B, U_C, O_C]$。\n\n所有数值均为无量纲；无需进行物理单位转换。不涉及角度。不涉及百分比；任何分数量必须表示为小数。结果列表元素必须以实数（浮点数）形式打印。", "solution": "该问题要求分析 Crank-Nicolson 方法应用于具有不连续初始条件的一维热方程时产生的非物理振荡。解决方案涉及推导数值格式，设计一个能最大化振荡伪影的初始条件，实现该格式进行单步时间推进，并量化产生的下冲和过冲。\n\n### 步骤 1：离散化与 Crank-Nicolson 格式\n\n控制偏微分方程 (PDE) 是热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义在域 $x \\in (0, 1)$ 和 $t \\ge 0$ 上，其中 $\\nu$ 是扩散系数。边界条件是齐次狄利克雷条件：\n$$\nu(0, t) = 0, \\quad u(1, t) = 0 \\quad \\text{for } t \\ge 0.\n$$\n空间域 $(0, 1)$ 被离散化为 $M$ 个内部点 $x_i = i \\Delta x$，其中 $i = 1, 2, \\dots, M$，网格间距为 $\\Delta x = 1/(M+1)$。边界点为 $x_0 = 0$ 和 $x_{M+1} = 1$。令 $u_i(t)$ 为 $u(x_i, t)$ 的近似值。\n\n内部点 $x_i$ 处的空间二阶导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{\\Delta x^2}\n$$\n将此应用于偏微分方程，得到一个常微分方程组 (ODEs)，每个内部点对应一个方程：\n$$\n\\frac{du_i}{dt} = \\frac{\\nu}{\\Delta x^2} (u_{i-1} - 2u_i + u_{i+1})\n$$\n\nCrank-Nicolson 方法应用梯形法则进行时间积分。令 $u_i^n$ 为在时间 $t_n = n \\Delta t$ 处 $u(x_i, t_n)$ 的近似值。时间导数近似为 $(u_i^{n+1} - u_i^n) / \\Delta t$。空间导数项在时间 $t_n$ 和 $t_{n+1}$ 之间取平均值：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\nu}{2} \\left[ \\left(\\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{\\Delta x^2}\\right) + \\left(\\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{\\Delta x^2}\\right) \\right]\n$$\n引入无量纲参数 $\\mu = \\nu \\Delta t / \\Delta x^2$，我们可以重新整理方程，将时间步 $n+1$（未知数）和 $n$（已知数）的项分开：\n$$\nu_i^{n+1} - \\frac{\\mu}{2}(u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) = u_i^n + \\frac{\\mu}{2}(u_{i-1}^n - 2u_i^n + u_{i+1}^n)\n$$\n对每个网格点 $i = 1, \\dots, M$ 收集项：\n$$\n-\\frac{\\mu}{2}u_{i-1}^{n+1} + (1+\\mu)u_i^{n+1} - \\frac{\\mu}{2}u_{i+1}^{n+1} = \\frac{\\mu}{2}u_{i-1}^n + (1-\\mu)u_i^n + \\frac{\\mu}{2}u_{i+1}^n\n$$\n在 $i=1$ 和 $i=M$ 处，并入边界条件 $u_0^n = u_0^{n+1} = 0$ 和 $u_{M+1}^n = u_{M+1}^{n+1} = 0$。\n这可以写成一个线性方程组 $A \\mathbf{u}^{n+1} = B \\mathbf{u}^n$，其中 $\\mathbf{u}^n = [u_1^n, u_2^n, \\dots, u_M^n]^T$ 是在时间 $t_n$ 的解向量。矩阵 $A$ 和 $B$ 是 $M \\times M$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\n1+\\mu  -\\frac{\\mu}{2}    \\\\\n-\\frac{\\mu}{2}  1+\\mu  -\\frac{\\mu}{2}   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -\\frac{\\mu}{2}  1+\\mu  -\\frac{\\mu}{2} \\\\\n   -\\frac{\\mu}{2}  1+\\mu\n\\end{pmatrix}\n$$\n$$\nB = \\begin{pmatrix}\n1-\\mu  \\frac{\\mu}{2}    \\\\\n\\frac{\\mu}{2}  1-\\mu  \\frac{\\mu}{2}   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  \\frac{\\mu}{2}  1-\\mu  \\frac{\\mu}{2} \\\\\n   \\frac{\\mu}{2}  1-\\mu\n\\end{pmatrix}\n$$\n为了将解从 $\\mathbf{u}^0$ 推进到 $\\mathbf{u}^1$，我们首先计算右侧向量 $\\mathbf{d} = B \\mathbf{u}^0$，然后求解线性系统 $A \\mathbf{u}^1 = \\mathbf{d}$。\n\n### 步骤 2：初始条件的设计\n\n问题要求设计一个离散亥维赛初始条件 $\\mathbf{u}^0$，以最大化单步时间推进后产生的非物理振荡。其形式被指定为 $u_i^0 = 1$ (对于 $i \\le m$) 和 $u_i^0 = 0$ (对于 $i  m$)，其中 $m \\in \\{1, \\dots, M-1\\}$。\n\n对于所有 $\\mu  0$，Crank-Nicolson 方法是 $L_2$-稳定的，但它并非没有伪振荡，特别是在初始数据不光滑和 $\\mu$ 较大时。离散拉普拉斯算子的第 $k$ 个本征模 $\\phi_k(i) = \\sin(k \\pi x_i)$ 的放大因子由下式给出：\n$$\ng_k = \\frac{1 - 2\\mu \\sin^2(k\\pi\\Delta x/2)}{1 + 2\\mu \\sin^2(k\\pi\\Delta x/2)}\n$$\n对于大的 $\\mu$，高频模式（大 $k$）的放大因子 $g_k$ 趋近于 $-1$。这意味着初始条件中的高频分量不会被衰减，而是被反相并持续存在，从而引起振荡。最高频率模式 ($k=M$) 对应于一种棋盘状模式。\n\n阶跃不连续性富含高频分量。为了最大化 $\\mathbf{u}^1 = A^{-1}B\\mathbf{u}^0$ 中的振荡，我们应将此不连续点放置在它与格式动力学相互作用最显著且受边界阻尼影响最小的位置。齐次狄利克雷边界条件在区域两端强制 $u=0$，这对振荡行为有局部阻尼效应。为了以最不受抑制的形式观察数值伪影，不连续点应尽可能远离两个边界。\n\n空间域的中心 $x=0.5$ 是距离 $x=0$ 和 $x=1$ 都最远的点。在我们由 $M$ 个内部点组成的离散网格上，这对应于索引 $\\{1, \\dots, M\\}$ 的中点。对于 $M=400$，中点位于索引 $i=200$ 和 $i=201$ 之间。因此，在此位置设置跳跃可以最大化其与边界影响的“距离”。\n\n所选的设计是在点 $i=200$ 和 $i=201$ 之间设置不连续点。这对应于选择 $m=M/2=200$。\n因此，初始条件向量 $\\mathbf{u}^0$ 定义为：\n$$\nu_i^0 = \\begin{cases} 1  \\text{if } 1 \\le i \\le 200 \\\\ 0  \\text{if } 201 \\le i \\le 400 \\end{cases}\n$$\n这种放置确保了由阶跃引入的高频成分在区域内部被对称地最大化激发，从而导致格式产生最强的振荡响应。\n\n### 步骤 3：单时间步的实现\n\n给定 $\\mathbf{u}^0$ 和 $\\mu$，我们通过求解 $A\\mathbf{u}^1 = \\mathbf{d}$ 来计算 $\\mathbf{u}^1$，其中 $\\mathbf{d} = B \\mathbf{u}^0$。\n\n1.  **构造 $\\mathbf{d}$**：使用 $B$ 作用于 $\\mathbf{u}^0$ 的公式计算分量 $d_i$。\n    $$ d_i = \\frac{\\mu}{2}u_{i-1}^0 + (1-\\mu)u_i^0 + \\frac{\\mu}{2}u_{i+1}^0 $$\n    边界条件为 $u_0^0=0$ 和 $u_{M+1}^0=0$。由于 $\\mathbf{u}^0$ 的阶跃形式，$\\mathbf{d}$ 的大多数元素将是常数，仅在 $i=m=200$ 的跳跃点附近和边界点出现非平凡值。具体来说：\n    - 对于 $1  i  200$：$d_i = \\frac{\\mu}{2}(1) + (1-\\mu)(1) + \\frac{\\mu}{2}(1) = 1$。\n    - 对于 $i = 200$：$d_{200} = \\frac{\\mu}{2}(1) + (1-\\mu)(1) + \\frac{\\mu}{2}(0) = 1-\\frac{\\mu}{2}$。\n    - 对于 $i = 201$：$d_{201} = \\frac{\\mu}{2}(1) + (1-\\mu)(0) + \\frac{\\mu}{2}(0) = \\frac{\\mu}{2}$。\n    - 对于 $i > 201$：$d_i = \\frac{\\mu}{2}(0) + (1-\\mu)(0) + \\frac{\\mu}{2}(0) = 0$。\n    - （对于 $i=1$ 需特别注意 $u_0^0=0$，因此 $d_1 = \\frac{\\mu}{2}(0) + (1-\\mu)(1) + \\frac{\\mu}{2}(1) = 1-\\mu/2$。）\n\n2.  **求解 $A\\mathbf{u}^1 = \\mathbf{d}$**：矩阵 $A$ 是一个对称正定三对角矩阵。求解此类系统的最有效方法是托马斯算法（三对角系统的高斯消元法特例）。该算法具有线性时间复杂度 $\\mathcal{O}(M)$，并且对于此类矩阵是数值稳定的。该算法包括一个用于修改矩阵系数和右端项的前向消元过程，以及一个用于找到解向量 $\\mathbf{u}^1$ 的回代过程。\n\n### 步骤 4：量化振荡\n\n在为测试套件中的每个 $\\mu$ 值计算出解向量 $\\mathbf{u}^1$ 后，我们使用指定的度量标准来量化非物理振荡。初始状态受限于 $0 \\le u_i^0 \\le 1$。根据极值原理，热方程的精确解也应保持在这些界限内。$\\mathbf{u}^1$ 中任何超出区间 $[0, 1]$ 的值都是数值伪影。\n\n-   **下冲 ($U$)**：任何低于物理最小值 $0$ 的值的最大幅度。\n    $$ U = \\max(0, -\\min_i u_i^1) $$\n-   **过冲 ($O$)**：任何超过物理最大值 $1$ 的值的最大幅度。\n    $$ O = \\max(0, \\max_i u_i^1 - 1) $$\n\n将为三个测试用例（A、B、C），即 $\\mu = 0.2, 0.6, 5.0$ 分别计算这两个标量。预期的结果是，随着 $\\mu$ 的增加，$U$ 和 $O$ 的值将增加，反映出更严重的振荡。对于 $\\mu  0.5$，振荡通常很小或不存在。对于 $\\mu > 0.5$，它们变得明显。对于大的 $\\mu$，它们非常显著。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_solver(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal system of equations Ax = d using the Thomas algorithm.\n    a: sub-diagonal vector (length n-1)\n    b: main diagonal vector (length n)\n    c: super-diagonal vector (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    if n == 0:\n        return np.array([])\n    if n == 1:\n        return np.array([d[0] / b[0]])\n\n    # Create copies to avoid modifying input arrays\n    c_prime = np.zeros(n)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denominator = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denominator\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denominator\n    \n    # Last element of d_prime\n    denominator = b[n - 1] - a[n - 2] * c_prime[n - 2]\n    d_prime[n-1] = (d[n - 1] - a[n - 2] * d_prime[n - 2]) / denominator\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef run_crank_nicolson_step(M, mu):\n    \"\"\"\n    Performs one step of the Crank-Nicolson method for the 1D heat equation.\n    \n    Args:\n        M (int): Number of interior grid points.\n        mu (float): Nondimensional parameter nu * dt / dx^2.\n        \n    Returns:\n        tuple: (undershoot, overshoot)\n    \"\"\"\n    # 1. Design the initial condition u0\n    # The jump is placed at the center of the grid to maximize oscillations.\n    m = M // 2\n    u0 = np.zeros(M)\n    # Python's slicing u0[:m] modifies indices 0 to m-1, which corresponds\n    # to grid points i=1 to m. For m=200, this is points 1 to 200.\n    u0[:m] = 1.0\n\n    # 2. Construct the right-hand side vector d = B * u0\n    d = np.zeros(M)\n    \n    # General interior points using vectorization\n    if M > 2:\n        d[1:-1] = (mu / 2) * u0[:-2] + (1 - mu) * u0[1:-1] + (mu / 2) * u0[2:]\n\n    # Boundary points (incorporating u_(-1) = 0 and u_(M) = 0)\n    # Using 0-based indexing for arrays u0[0]...u0[M-1]\n    # For i=1 (index 0): d[0] = (mu/2)*u_0 + (1-mu)*u_1 + (mu/2)*u_2\n    # with u_0=0 => d[0] = (1-mu)*u_1 + (mu/2)*u_2\n    if M > 0:\n        d[0] = (1 - mu) * u0[0] + (mu / 2) * (u0[1] if M > 1 else 0)\n    \n    # For i=M (index M-1): d[M-1] = (mu/2)*u_{M-1} + (1-mu)*u_M + (mu/2)*u_{M+1}\n    # with u_{M+1}=0 => d[M-1] = (mu/2)*u_{M-1} + (1-mu)*u_M\n    if M > 1:\n        d[M - 1] = (mu / 2) * u0[M - 2] + (1 - mu) * u0[M - 1]\n\n    # 3. Define the tridiagonal matrix A and solve A * u1 = d\n    # A = tridiag(-mu/2, 1+mu, -mu/2)\n    sub_diag_a = np.full(M - 1, -mu / 2)\n    main_diag_b = np.full(M, 1 + mu)\n    super_diag_c = np.full(M - 1, -mu / 2)\n\n    u1 = thomas_solver(sub_diag_a, main_diag_b, super_diag_c, d)\n\n    # 4. Quantify oscillations\n    undershoot = max(0.0, -np.min(u1)) if u1.size > 0 else 0.0\n    overshoot = max(0.0, np.max(u1) - 1.0) if u1.size > 0 else 0.0\n    \n    return undershoot, overshoot\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Fixed parameters from the problem statement\n    M = 400\n    \n    # Test cases for the nondimensional time step mu\n    test_cases = [\n        0.2,  # Case A: subthreshold\n        0.6,  # Case B: just above threshold\n        5.0,  # Case C: highly stiff\n    ]\n\n    results = []\n    for mu in test_cases:\n        U, O = run_crank_nicolson_step(M=M, mu=mu)\n        results.append(U)\n        results.append(O)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.8f}' for x in results)}]\")\n\nsolve()\n\n```", "id": "3220540"}, {"introduction": "Crank-Nicolson方法的一个关键优势是其时间上的二阶精度，但我们如何确定一个具体的实现达到了这个标准？本练习将通过一个时间收敛性研究，向你介绍科学计算中的核心技能——代码验证 ([@problem_id:3220441])。你将通过一个巧妙的设计来消除空间误差，编写代码来测量该方法的收敛阶，从而在计算上验证其对于多种物理系统的理论$\\mathcal{O}(\\Delta t^2)$精度。", "problem": "你需要通过计算来验证克兰克-尼科尔森（Crank–Nicolson, CN）方法（即时间上的梯形法则）对于线性常系数偏微分方程（PDE）的时间二阶精度，同时确保空间离散误差可以忽略不计。请在一维周期性域 $[0,2\\pi]$ 上进行，并使用傅里叶谱表示法来处理空间算子，这样每个傅里叶模态都可以独立演化，并且对于所选的初始数据，空间微分是精确的。\n\n起点与基本原理：在周期性域上，一个足够光滑的函数可以展开为傅里叶级数，并且常系数空间微分算子在傅里叶基下是对角的。对于任何线性时不变系统 $u_t = \\mathcal{L} u$，其中 $\\mathcal{L}$ 是一个常系数线性空间算子，每个傅里叶模态的振幅 $a_k(t)$ 都满足常微分方程（ODE）$a_k'(t) = \\lambda_k a_k(t)$，其中 $\\lambda_k$ 是算子 $\\mathcal{L}$ 对应波数 $k$ 的特征值。对于单个模态的精确解为 $a_k(t) = e^{\\lambda_k t} a_k(0)$。对于右端项连续可微的 ODE，克兰克-尼科尔森时间离散格式的局部截断误差为 $\\mathcal{O}(\\Delta t^3)$ 阶，在标准的平滑性假设下，其全局误差为时间 $\\mathcal{O}(\\Delta t^2)$ 阶。\n\n你的任务：\n\n1) 空间模型与对角化。考虑在 $[0,2\\pi]$ 上的以下三个偏微分方程，均带有周期性边界条件和初始条件 $u(x,0) = e^{\\mathrm{i} k x}$，其中 $k$ 为指定的整数模态：\n   - 扩散方程：$u_t = \\nu u_{xx}$，扩散系数 $\\nu  0$。\n   - 自由薛定谔方程：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$，色散系数 $\\alpha  0$。\n   - 对流扩散方程：$u_t + c u_x = \\nu u_{xx}$，对流速度 $c \\in \\mathbb{R}$，扩散系数 $\\nu  0$。\n\n   在 $[0,2\\pi]$ 上使用傅里叶级数，为每个偏微分方程中傅里叶模态 $e^{\\mathrm{i} k x}$ 的振幅 $a_k(t)$ 推导出相应的模态 ODE，并确定 $a_k'(t) = \\lambda_k a_k(t)$ 中的模态增长/衰减率 $\\lambda_k$。\n\n2) 时间离散化。对模态 ODE $a_k'(t) = \\lambda_k a_k(t)$ 应用克兰克-尼科尔森时间离散格式。用前一步 $a_k^n$ 和时间步长 $\\Delta t$ 表示单步更新，并获得单步放大因子关于 $\\lambda_k$ 和 $\\Delta t$ 的闭式公式。使用此公式推进 $M$ 步，以在时间 $T$ 逼近 $a_k(T)$。\n\n3) 误差测量与观测阶数。对于每个偏微分方程，使用时间步长 $\\Delta t = T/M$ 进行时间加密研究，加密级别为 $M \\in \\{10,20,40,80,160\\}$。对于每个 $\\Delta t$，计算在时间 $T$ 的数值振幅，并与精确振幅 $e^{\\lambda_k T}$ 进行比较，测量绝对误差 $E(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - e^{\\lambda_k T} \\rvert$。通过最小二乘法对 $(\\log(\\Delta t), \\log(E(\\Delta t)))$ 拟合一条直线并取其斜率来估计观测阶数 $p$。如果方法是时间二阶的，该斜率应接近 $2$。由于初始条件是网格上精确表示的单个傅里叶模态，且空间算子在傅里叶空间中是对角的，因此该测试的空间离散误差可以忽略不计。\n\n测试套件规范：\n\n- 域：$[0,2\\pi]$，带有周期性边界条件。\n- 所有情况的初始条件：$u(x,0) = e^{\\mathrm{i} k x}$，使用下面指定的整数 $k$。\n- 加密级别：$M \\in \\{10,20,40,80,160\\}$，因此 $\\Delta t = T/M$。\n- 测试案例：\n  1) 扩散：$\\nu = 0.5$, $k = 3$, $T = 1.0$。\n  2) 自由薛定谔：$\\alpha = 0.7$, $k = 4$, $T = 2.0$。\n  3) 对流扩散：$c = 2.0$, $\\nu = 0.1$, $k = 5$, $T = 1.5$。\n\n答案规范与输出格式：\n\n- 对于每个案例，返回通过 $\\log(E(\\Delta t))$ 对 $\\log(\\Delta t)$ 的最小二乘斜率计算出的观测阶数 $p$，形式为浮点数。\n- 你的程序应生成单行输出，其中包含按上述顺序列出的三个观测阶数，四舍五入到三位小数，格式为逗号分隔的 Python 风格列表，例如：\"[2.000,2.001,1.999]\"。\n- 此任务不涉及物理单位。由于域选择为 $[0,2\\pi]$，根据构造，角度（若有）单位为弧度。\n\n你的最终交付成果必须是一个完整的、可运行的程序，该程序能为上述测试套件精确执行这些计算，并以要求的单行格式打印结果。不允许用户输入或外部文件。仅使用指定的库。", "solution": "问题陈述已经过验证，被认为是可靠、适定且完整的。我们现在开始求解。这个问题的核心是通过计算验证克兰克-尼科尔森方法对于几种线性偏微分方程（PDE）的时间二阶精度。该问题的构造旨在消除空间离散误差，从而可以纯粹地评估时间误差。这是通过使用单个傅里叶模态作为初始条件来实现的，该模态是所涉及的常系数线性空间算子的特征函数。\n\n**1. 模态分析与特征值推导**\n\n我们考虑在周期性域 $[0, 2\\pi]$ 上形式为 $u(x,t) = a_k(t) e^{\\mathrm{i} k x}$ 的解，其中 $k$ 为整数波数。初始条件 $u(x,0) = e^{\\mathrm{i} k x}$ 意味着第 $k$ 个模态的初始振幅为 $a_k(0) = 1$，而所有其他模态振幅均为零。由于控制方程是线性的，各模态独立演化。我们可以通过将解的形式代入每个 PDE 来分析单个非零模态 $a_k(t)$ 的演化。\n\n空间导数为：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = \\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2} = \\frac{\\partial^2}{\\partial x^2} \\left( a_k(t) e^{\\mathrm{i} k x} \\right) = (\\mathrm{i} k)^2 a_k(t) e^{\\mathrm{i} k x} = -k^2 a_k(t) e^{\\mathrm{i} k x}\n$$\n时间导数为 $\\frac{\\partial u}{\\partial t} = a_k'(t) e^{\\mathrm{i} k x}$。\n\n对于每个形如 $u_t = \\mathcal{L}u$ 的 PDE，代入模态形式可得 $a_k'(t) e^{\\mathrm{i} k x} = \\mathcal{L}(a_k(t) e^{\\mathrm{i} k x}) = a_k(t) \\mathcal{L}(e^{\\mathrm{i} k x})$。由于 $e^{\\mathrm{i} k x}$ 是空间算子 $\\mathcal{L}$ 的特征函数，我们有 $\\mathcal{L}(e^{\\mathrm{i} k x}) = \\lambda_k e^{\\mathrm{i} k x}$，其中 $\\lambda_k$ 是特征值。这将 PDE 简化为关于振幅 $a_k(t)$ 的线性常微分方程（ODE）：\n$$\na_k'(t) = \\lambda_k a_k(t)\n$$\n该 ODE 在初始条件 $a_k(0)=1$ 下的精确解为 $a_k(t) = e^{\\lambda_k t}$。\n\n我们现在为每个指定的 PDE 确定 $\\lambda_k$。\n\n- **扩散方程**：$u_t = \\nu u_{xx}$\n  $a_k'(t) e^{\\mathrm{i} k x} = \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。两边同除以 $e^{\\mathrm{i} k x}$ 得 $a_k'(t) = (-\\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2$。\n\n- **自由薛定谔方程**：$\\mathrm{i} \\psi_t = -\\alpha \\psi_{xx}$。设解为 $\\psi(x,t) = a_k(t) e^{\\mathrm{i} k x}$。\n  该方程等价于 $\\psi_t = \\frac{-\\alpha}{\\mathrm{i}} \\psi_{xx} = \\mathrm{i} \\alpha \\psi_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = \\mathrm{i} \\alpha (-k^2 a_k(t) e^{\\mathrm{i} k x})$。这得到 $a_k'(t) = (-\\mathrm{i} \\alpha k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\mathrm{i} \\alpha k^2$。\n\n- **对流扩散方程**：$u_t + c u_x = \\nu u_{xx}$，即 $u_t = -c u_x + \\nu u_{xx}$。\n  $a_k'(t) e^{\\mathrm{i} k x} = -c (\\mathrm{i} k a_k(t) e^{\\mathrm{i} k x}) + \\nu (-k^2 a_k(t) e^{\\mathrm{i} k x})$。\n  这得到 $a_k'(t) = (-\\mathrm{i} c k - \\nu k^2) a_k(t)$。\n  因此，特征值为 $\\lambda_k = -\\nu k^2 - \\mathrm{i} c k$。\n\n**2. 克兰克-尼科尔森时间离散化**\n\n克兰克-尼科尔森方法是一种用于积分 ODE 的隐式方法，等价于梯形法则。对于 ODE $a' = \\lambda a$，从 $t_n$ 到 $t_{n+1}$ 的一个时间步长 $\\Delta t$ 上的离散格式为：\n$$\n\\frac{a^{n+1} - a^n}{\\Delta t} = \\frac{1}{2} \\left( \\lambda a^{n+1} + \\lambda a^n \\right)\n$$\n其中 $a^n \\approx a(t_n)$。我们求解 $a^{n+1}$：\n$$\na^{n+1} \\left( 1 - \\frac{\\lambda \\Delta t}{2} \\right) = a^n \\left( 1 + \\frac{\\lambda \\Delta t}{2} \\right)\n$$\n这给出了单步的显式更新公式：\n$$\na^{n+1} = \\left( \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2} \\right) a^n\n$$\n项 $G(\\lambda, \\Delta t) = \\frac{1 + \\lambda \\Delta t / 2}{1 - \\lambda \\Delta t / 2}$ 是单步放大因子。为了在 $M$ 步内从时间 $t=0$ 推进到 $T = M \\Delta t$，我们将此因子应用 $M$ 次。设 $a^0 = a_k(0) = 1$，在时间 $T$ 的数值解为：\n$$\na_k^{\\text{num}}(T) = a^M = (G(\\lambda_k, \\Delta t))^M a^0 = \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M\n$$\n\n**3. 误差分析与观测精度阶数**\n\n该方法的全局误差预计为时间二阶，这意味着在固定时间 $T$ 的误差 $E(\\Delta t)$ 的行为类似于 $E(\\Delta t) \\approx C (\\Delta t)^p$，其中某个常数 $C$ 和阶数 $p \\approx 2$。绝对误差定义为：\n$$\nE(\\Delta t) = \\lvert a_k^{\\text{num}}(T) - a_k(T) \\rvert = \\left| \\left( \\frac{1 + \\lambda_k \\Delta t / 2}{1 - \\lambda_k \\Delta t / 2} \\right)^M - e^{\\lambda_k T} \\right|\n$$\n为了确定观测阶数 $p$，我们对误差关系式取对数：\n$$\n\\log(E(\\Delta t)) \\approx \\log(C) + p \\log(\\Delta t)\n$$\n这显示了 $\\log(E)$ 和 $\\log(\\Delta t)$ 之间的线性关系，其斜率即为精度阶数 $p$。我们将为一系列时间步长 $\\Delta t_i = T/M_i$（其中 $M_i \\in \\{10, 20, 40, 80, 160\\}$）计算误差。然后，我们对数据点 $(\\log(\\Delta t_i), \\log(E_i))$ 进行线性最小二乘拟合以找到斜率 $p$。\n\n对于每个测试案例，计算流程如下：\n1.  使用给定参数计算特征值 $\\lambda_k$。\n2.  定义加密级别集合 $M_i$。\n3.  对于每个 $M_i$，计算时间步长 $\\Delta t_i = T/M_i$。\n4.  计算数值解 $a_k^{\\text{num}}(T) = \\left( \\frac{1 + \\lambda_k \\Delta t_i / 2}{1 - \\lambda_k \\Delta t_i / 2} \\right)^{M_i}$。\n5.  计算精确解 $a_k(T) = e^{\\lambda_k T}$。\n6.  计算绝对误差 $E_i = |a_k^{\\text{num}}(T) - a_k(T)|$。\n7.  构建两个向量：$x = [\\log(\\Delta t_i)]$ 和 $y = [\\log(E_i)]$。\n8.  计算 $(x, y)$ 的最佳拟合线的斜率 $p$，即为观测阶数。这将使用 `numpy.polyfit` 完成。\n将对三个指定的案例执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_observed_order(lambda_k, T, M_levels):\n    \"\"\"\n    Computes the observed order of accuracy for the Crank-Nicolson method.\n\n    Args:\n        lambda_k (complex): The eigenvalue of the spatial operator for mode k.\n        T (float): The final time for the simulation.\n        M_levels (np.ndarray): An array of integers representing the number of time steps.\n\n    Returns:\n        float: The observed order of accuracy, p.\n    \"\"\"\n    delta_ts = T / M_levels\n    errors = np.zeros_like(delta_ts, dtype=float)\n\n    # Calculate the exact solution at time T\n    exact_solution = np.exp(lambda_k * T)\n\n    for i, M in enumerate(M_levels):\n        dt = delta_ts[i]\n        \n        # Calculate the one-step amplification factor\n        z = lambda_k * dt / 2.0\n        amplification_factor = (1.0 + z) / (1.0 - z)\n        \n        # Compute the numerical solution at time T\n        # Initial condition a_k(0) = 1 is implicit\n        numerical_solution = amplification_factor**M\n        \n        # Compute the absolute error\n        errors[i] = np.abs(numerical_solution - exact_solution)\n\n    # Perform a least-squares fit on the log-log data to find the slope\n    log_delta_ts = np.log(delta_ts)\n    log_errors = np.log(errors)\n    \n    # np.polyfit returns [slope, intercept] for degree 1\n    p, _ = np.polyfit(log_delta_ts, log_errors, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Refinement levels for the temporal grid\n    M_levels = np.array([10, 20, 40, 80, 160])\n    \n    # --- Test Case 1: Diffusion Equation ---\n    # u_t = nu * u_xx\n    # Parameters: nu = 0.5, k = 3, T = 1.0\n    nu1 = 0.5\n    k1 = 3\n    T1 = 1.0\n    # Eigenvalue: lambda_k = -nu * k^2\n    lambda_k1 = -nu1 * k1**2\n    p1 = calculate_observed_order(lambda_k1, T1, M_levels)\n\n    # --- Test Case 2: Free Schrödinger Equation ---\n    # i * psi_t = -alpha * psi_xx  =>  psi_t = i * alpha * psi_xx\n    # Parameters: alpha = 0.7, k = 4, T = 2.0\n    alpha2 = 0.7\n    k2 = 4\n    T2 = 2.0\n    # Eigenvalue: lambda_k = -i * alpha * k^2\n    lambda_k2 = -1j * alpha2 * k2**2\n    p2 = calculate_observed_order(lambda_k2, T2, M_levels)\n\n    # --- Test Case 3: Advection-Diffusion Equation ---\n    # u_t + c * u_x = nu * u_xx  => u_t = -c * u_x + nu * u_xx\n    # Parameters: c = 2.0, nu = 0.1, k = 5, T = 1.5\n    c3 = 2.0\n    nu3 = 0.1\n    k3 = 5\n    T3 = 1.5\n    # Eigenvalue: lambda_k = -nu * k^2 - i * c * k\n    lambda_k3 = -nu3 * k3**2 - 1j * c3 * k3\n    p3 = calculate_observed_order(lambda_k3, T3, M_levels)\n\n    results = [p1, p2, p3]\n\n    # Format the output as a list of strings with 3 decimal places\n    formatted_results = [f'{p:.3f}' for p in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3220441"}]}