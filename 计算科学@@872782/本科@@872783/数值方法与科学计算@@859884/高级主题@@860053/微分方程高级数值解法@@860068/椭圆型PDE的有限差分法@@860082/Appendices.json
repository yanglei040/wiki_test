{"hands_on_practices": [{"introduction": "本练习从一维泊松方程入手，是掌握有限差分法的基础。通过使用频率 $\\omega$ 可变的正弦波作为精确解，我们将探索网格间距与数值解精度之间的关系 ([@problem_id:3228860])。这项实践旨在帮助你直观地理解“每个波长的点数”这一概念，以及为什么数值方法难以精确求解高频解分量。", "problem": "考虑一维泊松方程，这是一个典型的椭圆型偏微分方程 (PDE)，该方程定义在闭区间 $[0,1]$ 上，并带有齐次狄利克雷边界条件，\n$$\n-\\,u''(x) = f(x), \\quad x \\in (0,1), \\quad u(0) = 0, \\quad u(1) = 0,\n$$\n其中 $u(x)$ 是精确解，$f(x)$ 是源项。为了测试离散误差作为频率的函数，选择如下形式的精确解\n$$\nu(x) = \\sin(\\omega \\pi x),\n$$\n其中 $\\omega$ 是一个正实数参数，$\\pi$ 是圆周率，角度应以弧度为单位进行解释。从上述精确解推导出 $f(x)$，并在一个均匀网格上构建该方程的二阶精度有限差分离散化。该网格共有 $N$ 个网格点（包括边界点），网格间距为 $h = \\frac{1}{N-1}$，内部节点为 $x_i = i h$，其中 $i=1,2,\\dots,N-2$。使用标准的中心有限差分近似来逼近二阶导数，从而为内部未知量 $u_i \\approx u(x_i)$ 形成一个三对角线性系统，强制施加狄利克雷边界条件 $u_0 = u_N = 0$，并使用数值稳定的方法精确求解该线性系统。然后，计算在完整网格 $\\{x_0, x_1, \\dots, x_{N-1}\\}$ 上采样的数值解与精确解之间的均方根 (RMS) 误差：\n$$\n\\mathrm{RMS}(u_h,u) = \\left( \\frac{1}{N} \\sum_{i=0}^{N-1} \\left(u_h(x_i) - u(x_i)\\right)^2 \\right)^{1/2}.\n$$\n这里，$u_h(x_i)$ 表示节点 $x_i$ 处的数值近似解，$u(x_i)$ 表示在 $x_i$ 处采样的精确解。正弦函数内的角度必须按弧度处理。\n\n您的程序必须实现上述过程，并对以下参数值 $(\\omega, N)$ 的测试套件评估 RMS 误差：\n\n- 测试用例 1：$(\\omega, N) = (1, 129)$。\n- 测试用例 2：$(\\omega, N) = (4, 129)$。\n- 测试用例 3：$(\\omega, N) = (60, 129)$。\n- 测试用例 4：$(\\omega, N) = (60, 257)$。\n- 测试用例 5：$(\\omega, N) = (16, 33)$。\n\n这些测试用例旨在覆盖一系列场景：低频、中频、固定网格上接近分辨率极限的高频、高频下的网格加密，以及中高频下的粗糙网格。\n\n您的程序应生成单行输出，其中包含五个测试用例的 RMS 误差，形式为方括号内以逗号分隔的列表，顺序与测试用例相同，例如，\n$$\n[\\mathrm{err}_1,\\mathrm{err}_2,\\mathrm{err}_3,\\mathrm{err}_4,\\mathrm{err}_5].\n$$\n所有角度都必须以弧度为单位进行解释，并且由于所有量都是无量纲的，因此不需要物理单位。最终输出必须是指定格式的单行文本。", "solution": "在尝试求解之前，对问题进行验证。\n\n### 步骤1：提取已知条件\n\n- **控制方程**：一维泊松方程 $-\\,u''(x) = f(x)$，适用于 $x \\in (0,1)$。\n- **边界条件 (BCs)**：齐次狄利克雷条件，$u(0) = 0$ 和 $u(1) = 0$。\n- **精确解**：规定的精确解形式为 $u(x) = \\sin(\\omega \\pi x)$，其中 $\\omega$ 是一个正实数参数。\n- **源项**：$f(x)$ 需从给定的精确解 $u(x)$ 推导得出。\n- **数值网格**：一个包含 $N$ 个总点（包括边界）的均匀网格。网格点为 $x_i = i h$，其中 $i=0, 1, \\dots, N-1$。\n- **网格间距**：$h = \\frac{1}{N-1}$。\n- **内部节点**：在内部节点 $x_i$（$i=1, 2, \\dots, N-2$）处求解未知解。\n- **离散格式**：二阶导数 $u''(x)$ 将使用二阶精度的中心有限差分公式进行近似。\n- **数值边界条件**：问题指定强制施加 $u_0 = u_N = 0$。鉴于网格定义为包含索引为 $0, \\dots, N-1$ 的 $N$ 个点，右边界位于索引 $N-1$ 处。因此，$u_N=0$ 被解释为 $u_{N-1}=0$ 的常见印刷错误。\n- **误差度量**：均方根 (RMS) 误差定义为 $\\mathrm{RMS}(u_h,u) = \\left( \\frac{1}{N} \\sum_{i=0}^{N-1} \\left(u_h(x_i) - u(x_i)\\right)^2 \\right)^{1/2}$，其中 $u_h$ 是数值解。\n- **参数**：测试套件包含五对 $(\\omega, N)$：$(1, 129)$、$(4, 129)$、$(60, 129)$、$(60, 257)$ 和 $(16, 33)$。\n- **其他**：所有角度都应按弧度处理。\n\n### 步骤2：使用提取的已知条件进行验证\n\n- **科学基础**：该问题涉及使用有限差分法求解泊松方程，这是数值分析和科学计算中的一个基石性课题。制造解法是验证数值代码的一种标准技术。该问题在根本上是合理的。\n- **适定性**：带狄利克雷边界条件的一维泊松方程是适定椭圆问题的一个经典例子，保证解的唯一性。有限差分离散化导出一个对称正定线性系统，该系统也是适定的，并有唯一解。\n- **客观性**：该问题使用精确的数学语言和客观标准进行陈述。\n- **一致性与完整性**：该问题提供了构建和求解系统所需的所有必要信息。如前所述，条件 $u_N=0$ 被解释为 $u_{N-1}=0$，以便与网格定义（从 $x_0$ 到 $x_{N-1}$ 的 $N$ 个点）保持一致，这是此类问题中一个常见且易于解决的歧义。精确解 $u(x) = \\sin(\\omega \\pi x)$ 满足 $u(0)=0$。另一个条件 $u(1)=\\sin(\\omega\\pi)=0$ 成立当且仅当 $\\omega$ 是一个整数。所有提供的测试用例都使用整数值的 $\\omega$，因此在本问题的范围内，精确解的形式与边界条件是一致的。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。它是一个定义明确、一致且标准的数值分析问题。微小的符号歧义并不关键，并且可以根据上下文解决。将提供完整的解法。\n\n### 解法\n\n求解过程分为三个主要步骤：解析源项的推导、数值有限差分格式的构建以及误差的计算。\n\n**1. 源项的推导**\n\n问题给出了精确解 $u(x) = \\sin(\\omega \\pi x)$。为了找到相应的源项 $f(x)$，我们将 $u(x)$ 求导两次，并将其代入泊松方程 $-\\,u''(x) = f(x)$。\n\n$u(x)$ 关于 $x$ 的一阶导数是：\n$$\nu'(x) = \\frac{d}{dx} \\sin(\\omega \\pi x) = \\omega \\pi \\cos(\\omega \\pi x)\n$$\n\n二阶导数是：\n$$\nu''(x) = \\frac{d}{dx} (\\omega \\pi \\cos(\\omega \\pi x)) = -(\\omega \\pi)^2 \\sin(\\omega \\pi x)\n$$\n\n将此代入泊松方程，得到源项 $f(x)$：\n$$\nf(x) = -u''(x) = - \\left( -(\\omega \\pi)^2 \\sin(\\omega \\pi x) \\right) = (\\omega \\pi)^2 \\sin(\\omega \\pi x)\n$$\n\n**2. 有限差分离散化**\n\n我们使用 $N$ 个网格点 $x_i = ih$（$i=0, 1, \\dots, N-1$）来离散化区域 $[0,1]$，其中网格间距为 $h = 1/(N-1)$。在这些点上的数值解记为 $u_i \\approx u(x_i)$。\n\n在内部网格点 $x_i$ 处（对于 $i=1, \\dots, N-2$），二阶导数 $u''(x)$ 由二阶精度的中心有限差分公式近似：\n$$\nu''(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n\n将此近似代入泊松方程 $-\\,u''(x_i) = f(x_i)$，我们得到：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i)\n$$\n\n整理各项，得到关于未知数 $u_i$ 的线性方程：\n$$\n-u_{i-1} + 2u_i - u_{i+1} = h^2 f(x_i) = h^2 (\\omega \\pi)^2 \\sin(\\omega \\pi x_i)\n$$\n这组关于 $i = 1, 2, \\dots, N-2$ 的方程构成了一个线性系统。\n\n边界条件为 $u(0)=0$ 和 $u(1)=0$。在我们的离散系统中，这转化为 $u_0 = 0$ 和 $u_{N-1} = 0$。我们将这些已知值代入第一个和最后一个内部点的方程中。\n\n对于 $i=1$：\n$$\n-u_0 + 2u_1 - u_2 = h^2 f(x_1) \\implies 2u_1 - u_2 = h^2 f(x_1)\n$$\n\n对于 $i=N-2$：\n$$\n-u_{N-3} + 2u_{N-2} - u_{N-1} = h^2 f(x_{N-2}) \\implies -u_{N-3} + 2u_{N-2} = h^2 f(x_{N-2})\n$$\n\n这产生了一个三对角线性方程组 $A \\mathbf{u}_{\\text{int}} = \\mathbf{b}$，其中 $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ 是由 $N-2$ 个内部未知量组成的向量。尺寸为 $(N-2) \\times (N-2)$ 的矩阵 $A$ 具有以下形式：\n$$\nA = \\begin{pmatrix}\n2  -1  0  \\dots  0 \\\\\n-1  2  -1  \\dots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  -1 \\\\\n0  \\dots  0  -1  2\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}$ 为：\n$$\n\\mathbf{b} = h^2 \\begin{pmatrix} f(x_1) \\\\ f(x_2) \\\\ \\vdots \\\\ f(x_{N-2}) \\end{pmatrix} = h^2 (\\omega \\pi)^2 \\begin{pmatrix} \\sin(\\omega \\pi x_1) \\\\ \\sin(\\omega \\pi x_2) \\\\ \\vdots \\\\ \\sin(\\omega \\pi x_{N-2}) \\end{pmatrix}\n$$\n使用标准的、数值稳定的线性代数库函数求解此线性系统，得到 $\\mathbf{u}_{\\text{int}}$。\n\n**3. 误差计算**\n\n在求解系统得到内部解值 $u_1, \\dots, u_{N-2}$ 后，通过包含边界值来组装完整的数值解向量 $u_h$：\n$$\nu_h = [u_0, u_1, \\dots, u_{N-2}, u_{N-1}]^T = [0, u_1, \\dots, u_{N-2}, 0]^T\n$$\n在相同的网格点上对精确解进行采样：\n$$\nu_{\\text{exact}} = [u(x_0), u(x_1), \\dots, u(x_{N-1})]^T\n$$\n然后根据给定的公式计算 RMS 误差：\n$$\n\\mathrm{RMS}(u_h, u) = \\sqrt{\\frac{1}{N} \\sum_{i=0}^{N-1} (u_h(x_i) - u(x_i))^2}\n$$\n由于对于给定的测试用例，在边界处（$i=0$ 和 $i=N-1$），$u_h(x_i)$ 和 $u(x_i)$ 均为零，因此这些点的误差贡献为零。对问题陈述中指定的五个 $(\\omega, N)$ 对中的每一个都执行此计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_poisson_1d(omega, N):\n    \"\"\"\n    Solves the 1D Poisson equation -u''(x) = f(x) on [0,1] with u(0)=u(1)=0\n    using a second-order finite difference method.\n\n    The exact solution is u(x) = sin(omega * pi * x), from which the source\n    term f(x) is derived.\n\n    Args:\n        omega (float): The frequency parameter in the exact solution.\n        N (int): The total number of grid points (including boundaries).\n\n    Returns:\n        float: The RMS error between the numerical and exact solutions.\n    \"\"\"\n    # Grid parameters\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n\n    # Number of interior points determines the size of the linear system\n    N_interior = N - 2\n    if N_interior = 0:\n        # Handle cases with too few points to have an interior\n        u_h = np.zeros(N)\n        u_exact = np.sin(omega * np.pi * x)\n        rms_error = np.sqrt(np.mean((u_h - u_exact)**2))\n        return rms_error\n\n    # Construct the tridiagonal matrix A for the linear system\n    main_diag = 2.0 * np.ones(N_interior)\n    off_diag = -1.0 * np.ones(N_interior - 1)\n    A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n\n    # Construct the right-hand side vector b\n    # f(x) = (omega*pi)^2 * sin(omega*pi*x)\n    x_interior = x[1:-1]\n    f_interior = (omega * np.pi)**2 * np.sin(omega * np.pi * x_interior)\n    b = h**2 * f_interior\n\n    # Solve the linear system A * u_interior = b\n    u_interior = np.linalg.solve(A, b)\n\n    # Assemble the full numerical solution u_h, including boundary conditions\n    u_h = np.zeros(N)\n    u_h[1:-1] = u_interior\n\n    # Calculate the exact solution on the grid\n    u_exact = np.sin(omega * np.pi * x)\n\n    # Compute the RMS error\n    # RMS = sqrt( (1/N) * sum_{i=0}^{N-1} (u_h(i) - u_exact(i))^2 )\n    rms_error = np.sqrt(np.mean((u_h - u_exact)**2))\n\n    return rms_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 129),    # Test case 1\n        (4, 129),    # Test case 2\n        (60, 129),   # Test case 3\n        (60, 257),   # Test case 4\n        (16, 33),    # Test case 5\n    ]\n\n    results = []\n    for omega, N in test_cases:\n        rms_error = solve_poisson_1d(omega, N)\n        results.append(rms_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228860"}, {"introduction": "在掌握了一维问题后，我们将进入二维泊松方程的世界。本练习不仅是实现一个求解器，更侧重于代码验证和误差分析这项关键技能 ([@problem_id:3228788])。你将通过计算“实验收敛阶”(EOC) 来验证你的实现是否达到了理论精度，并通过对比光滑解与奇异解，深入理解精确解的正则性（即光滑度）如何影响有限差分法的收敛速度。", "problem": "考虑在单位平方域 $\\Omega = (0,1) \\times (0,1)$ 上的二维泊松方程，带有狄利克雷边界条件，\n$$\n-\\Delta u(x,y) = f(x,y) \\quad \\text{在 } \\Omega \\text{ 内}, \n\\qquad\nu(x,y) = g(x,y) \\quad \\text{在 } \\partial\\Omega \\text{ 上}.\n$$\n从二维拉普拉斯算子的定义以及由泰勒展开推导出的二阶导数的经典中心差分近似出发。仅使用这些基本原理，推导在网格间距为 $h = 1/N$ 的均匀网格上的标准五点有限差分法，其内部节点为 $(x_i,y_j) = (ih,jh)$，其中 $i,j \\in \\{1,\\dots,N-1\\}$：\n$$\n\\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j},\n$$\n其中 $\\partial\\Omega$ 上的边界值 $u_{i,j}$ 由 $g(x,y)$ 指定。解释为什么在假设 $u \\in C^4(\\overline{\\Omega})$ 的情况下，局部截断误差为 $\\mathcal{O}(h^2)$，以及离散极值原理如何导致全局误差界 $\\lVert u - u_h \\rVert_\\infty = \\mathcal{O}(h^2)$。\n\n接下来，为此方案产生的离散线性系统实现一个求解器，使用共轭梯度迭代法，该方法应用于与五点模板相关的对称正定矩阵。求解器必须是无矩阵的（matrix-free）：通过模板直接将离散算子应用于网格函数，并通过将已知的边界贡献添加到右侧来处理狄利克雷边界数据。使用基于残差范数相对于右侧范数减小到用户指定容差的停止准则。\n\n您将针对两个精确解验证误差估计和观察到的收敛率。在每种情况下，在 $\\partial \\Omega$ 上设置 $g(x,y) = u(x,y)$，在 $\\Omega$ 中设置 $f(x,y) = -\\Delta u(x,y)$。对于每个网格尺寸，计算离散解 $u_h$，将其嵌入到包括边界节点的完整网格中，并计算最大范数误差\n$$\nE(h) = \\max_{0 \\le i,j \\le N} \\left| u(x_i,y_j) - u_h(x_i,y_j) \\right|.\n$$\n给定一组网格间距 $\\{h_k\\}$ 及其对应的误差 $\\{E(h_k)\\}$，在关系式 $\\log E(h) \\approx \\log C + p \\log h$ 中，将实验收敛阶（EOC）估计为最小二乘斜率 $p$。\n\n使用以下两个精确解：\n- 光滑解：$u_s(x,y) = \\sin(\\pi x)\\sin(\\pi y)$，对于此解 $f_s(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$ 且 $g_s = u_s$。\n- 奇异解：$u_{sg}(x,y) = r^\\alpha$，其中 $\\alpha = 3/2$ 且 $r = \\sqrt{x^2 + y^2}$，对于此解，当 $r0$ 时有 $\\Delta u_{sg}(x,y) = \\alpha^2 r^{\\alpha - 2}$，因此 $f_{sg}(x,y) = -\\alpha^2 r^{\\alpha - 2}$ 且 $g_{sg} = u_{sg}$。如果需要，可以通过连续性定义 $f_{sg}(0,0)$；请注意，$(0,0)$ 是一个边界点，因此不是内部节点。\n\n设计一个程序，执行以下测试套件并报告每种情况的EOC：\n- 情况A（理想路径，光滑且分辨率良好）：使用 $N \\in \\{8,16,32,64\\}$ 和 $u_s$。\n- 情况B（正则性降低，在边界角点附近奇异）：使用 $N \\in \\{8,16,32,64\\}$ 和 $u_{sg}$ 以及 $\\alpha = 3/2$。\n- 情况C（边界粗分辨率边界情况）：使用 $N \\in \\{4,8,16\\}$ 和 $u_s$。\n\n您的程序必须实现五点法、无矩阵共轭梯度求解器、最大范数下的误差计算以及最小二乘EOC估计。对于每种情况，对 $\\log E(h)$ 与 $\\log h$ 进行线性回归，并报告估计的斜率 $p$。\n\n不涉及物理单位。所有角度（如果存在）均以弧度为单位。最终输出必须为单行，包含情况A、B、C的三个EOC估计值的逗号分隔列表，保留三位小数并用方括号括起，顺序为 [A,B,C]。例如，如果三个估计阶数为 $p_A$、$p_B$ 和 $p_C$，您的程序应输出形如 $[p_A,p_B,p_C]$ 的单行。", "solution": "该问题是有效的，因为它代表了偏微分方程数值分析中一个适定、标准的练习，其基础是已建立的数学原理。它是自洽的、客观的，并且其要求是算法上可形式化的。\n\n该任务涉及为泊松方程推导五点有限差分格式，分析其误差，并实现一个无矩阵共轭梯度求解器，以计算两种不同测试用例的实验收敛阶（EOC）。\n\n### 第1部分：五点模板的推导\n\n我们从单位平方域 $\\Omega = (0,1) \\times (0,1)$ 上的二维泊松方程开始：\n$$\n-\\Delta u(x,y) = f(x,y)\n$$\n其中 $\\Delta u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$ 是拉普拉斯算子。该域使用均匀网格进行离散化，两个方向的网格间距均为 $h=1/N$。网格点为 $(x_i, y_j) = (ih, jh)$，其中整数 $i,j \\in \\{0, 1, \\dots, N\\}$。我们寻求近似值 $u_{i,j} \\approx u(x_i, y_j)$。\n\n有限差分法的核心是使用泰勒级数展开来近似导数。考虑一个足够光滑的函数 $u(x,y)$ 在点 $(x_i, y_j)$ 附近的展开式：\n$$\nu(x_i \\pm h, y_j) = u(x_i, y_j) \\pm h \\frac{\\partial u}{\\partial x}(x_i, y_j) + \\frac{h^2}{2} \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) \\pm \\frac{h^3}{6} \\frac{\\partial^3 u}{\\partial x^3}(x_i, y_j) + \\frac{h^4}{24} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^5)\n$$\n将 $u(x_i+h, y_j)$ 和 $u(x_i-h, y_j)$ 的展开式相加：\n$$\nu(x_{i+1}, y_j) + u(x_{i-1}, y_j) = 2u(x_i, y_j) + h^2 \\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) + \\frac{h^4}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^6)\n$$\n重新整理以求解关于 x 的二阶偏导数，得到二阶中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i, y_j) = \\frac{u_{i+1,j} - 2u_{i,j} + u_{i-1,j}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial x^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\n通过对 y 方向进行相同的论证：\n$$\n\\frac{\\partial^2 u}{\\partial y^2}(x_i, y_j) = \\frac{u_{i,j+1} - 2u_{i,j} + u_{i,j-1}}{h^2} - \\frac{h^2}{12} \\frac{\\partial^4 u}{\\partial y^4}(x_i, y_j) + \\mathcal{O}(h^4)\n$$\n将这两个表达式相加，可得到拉普拉斯算子的近似：\n$$\n\\Delta u(x_i, y_j) = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2} - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\n我们将离散拉普拉斯算子（记为 $\\Delta_h$）定义为：\n$$\n\\Delta_h u_{i,j} = \\frac{u_{i+1,j} + u_{i-1,j} + u_{i,j+1} + u_{i,j-1} - 4u_{i,j}}{h^2}\n$$\n将此代入泊松方程 $-\\Delta u(x_i, y_j) = f(x_i, y_j)$，并忽略高阶项，即可得到内部节点 $(i,j)$（其中 $i,j \\in \\{1, \\dots, N-1\\}$）的五点有限差分格式：\n$$\n-\\Delta_h u_{i,j} = \\frac{4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1}}{h^2} = f_{i,j}\n$$\n其中 $f_{i,j} = f(x_i, y_j)$。这就是所求的公式。\n\n### 第2部分：局部截断误差和全局误差\n\n局部截断误差（LTE）$\\tau_{i,j}$ 是将精确解 $u(x,y)$ 代入离散方程时得到的残差。令 $L_h = -\\Delta_h$。离散系统为 $L_h u_h = f$，其中 $u_h$ 是数值解向量。将算子应用于精确解 $u$：\n$$\n\\tau_{i,j} = L_h u(x_i, y_j) - f(x_i, y_j) = L_h u(x_i, y_j) - (-\\Delta u(x_i, y_j))\n$$\n根据上面的泰勒展开分析，我们有：\n$$\n\\Delta_h u(x_i, y_j) = \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right)(x_i, y_j) + \\mathcal{O}(h^4)\n$$\n因此，LTE 为：\n$$\n\\tau_{i,j} = - \\left( \\Delta u(x_i, y_j) + \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4} \\right) + \\mathcal{O}(h^4) \\right) + \\Delta u(x_i, y_j)\n$$\n$$\n\\tau_{i,j} = - \\frac{h^2}{12} \\left( \\frac{\\partial^4 u}{\\partial x^4}(x_i,y_j) + \\frac{\\partial^4 u}{\\partial y^4}(x_i,y_j) \\right) + \\mathcal{O}(h^4)\n$$\n如果精确解 $u$ 属于 $C^4(\\overline{\\Omega})$，意味着它的四阶偏导数在闭域 $\\Omega$ 上是连续的，因而是有界的，那么存在一个常数 $M$ 使得 $|\\frac{\\partial^4 u}{\\partial x^4}| \\le M$ 且 $|\\frac{\\partial^4 u}{\\partial y^4}| \\le M$。因此，LTE 的最大范数有界为：\n$$\n\\lVert \\tau \\rVert_\\infty = \\max_{i,j} |\\tau_{i,j}| \\le \\frac{h^2}{12} (M+M) + \\mathcal{O}(h^4) = \\mathcal{O}(h^2)\n$$\n该格式是2阶相容的。\n\n全局误差定义为 $e_{i,j} = u(x_i, y_j) - u_{h, i,j}$，其中 $u_h$ 是离散系统的解。将离散算子 $L_h$ 应用于误差：\n$$\nL_h e_{i,j} = L_h (u_{i,j} - u_{h, i,j}) = L_h u_{i,j} - L_h u_{h, i,j}\n$$\n根据定义，$L_h u_{h, i,j} = f_{i,j}$ 且 $L_h u_{i,j} = f_{i,j} + \\tau_{i,j}$。将两者相减，我们得到误差方程：\n$$\nL_h e_{i,j} = \\tau_{i,j}\n$$\n对所有内部节点成立。在边界 $\\partial\\Omega$ 上，误差为零，$e_{i,j} = 0$，因为精确解和数值解都取指定的边界值 $g(x,y)$。\n\nLTE 和全局误差之间的联系是通过离散算子 $L_h$ 的稳定性建立的。算子 $L_h$ 满足离散极值原理（DMP）。对于像 $L_h$ 这样的算子，DMP指出，如果在所有内部节点上 $L_h v_{i,j} \\ge 0$，那么 $v$ 在整个网格上的最大值必须出现在边界上。DMP 的一个关键推论是其逆在最大范数下的稳定性。也就是说，存在一个与 $h$ 无关的常数 $C  0$，使得对于任何网格函数 $z$，具有零边界条件的方程 $L_h v = z$ 的解 $v$ 满足：\n$$\n\\lVert v \\rVert_\\infty \\le C \\lVert z \\rVert_\\infty\n$$\n这表示为 $\\lVert L_h^{-1} \\rVert_\\infty \\le C$。将此稳定性估计应用于误差方程 $e = L_h^{-1} \\tau$：\n$$\n\\lVert e \\rVert_\\infty = \\lVert L_h^{-1} \\tau \\rVert_\\infty \\le \\lVert L_h^{-1} \\rVert_\\infty \\lVert \\tau \\rVert_\\infty \\le C \\lVert \\tau \\rVert_\\infty\n$$\n因为我们已经证明 $\\lVert \\tau \\rVert_\\infty = \\mathcal{O}(h^2)$，所以最大范数下的全局误差也是二阶精确的：\n$$\n\\lVert u - u_h \\rVert_\\infty = \\lVert e \\rVert_\\infty = \\mathcal{O}(h^2)\n$$\n这证明了对于一个足够光滑的解（$u \\in C^4(\\overline{\\Omega})$），五点格式以2的阶数全局收敛。\n\n### 第3部分：算法设计\n\n该实现将包含一个无矩阵共轭梯度（CG）求解器。必须构建线性系统 $A u_h = b$，其中 $A$ 对应于 $(N-1)^2$ 个内部节点上的离散算子 $L_h$。\n\n**系统构建：** 向量 $u_h$ 包含内部节点处的未知值。矩阵 $A$ 代表五点模板。右侧向量 $b$ 结合了源项 $f(x,y)$ 和来自已知狄利克雷边界值 $g(x,y)$ 的贡献。对于一个内部节点 $(x_i,y_j)$：\n$$\nb_{i,j} = f(x_i, y_j) + \\frac{1}{h^2} \\left[ \\delta_{i,1}g(x_0,y_j) + \\delta_{i,N-1}g(x_N,y_j) + \\delta_{j,1}g(x_i,y_0) + \\delta_{j,N-1}g(x_i,y_N) \\right]\n$$\n其中 $\\delta_{k,l}$ 是克罗内克 delta。这种形式将所有已知的边界项移到方程的右侧。\n\n**无矩阵CG：** CG算法迭代求解一个对称正定系统。五点模板的矩阵具有此性质。CG中的关键操作是矩阵向量乘积 $A\\vec{p}$。在无矩阵方法中，我们不组装 $(N-1)^2 \\times (N-1)^2$ 矩阵 $A$。相反，我们实现一个函数，用于计算算子 $L_h$ 对网格函数 $\\vec{p}$（代表搜索方向）的作用。这是通过在每个内部节点应用五点模板来完成的。\n\n**EOC估计：** EOC $p$ 是通过模型 $\\log E(h) \\approx \\log C + p \\log h$ 从一系列网格尺寸 $h_k$ 处的误差 $E(h_k)$ 估计出来的。这是一个关于点对 $(\\log h_k, \\log E_k)$ 的线性回归问题。斜率 $p$ 使用标准的最小二乘公式计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute EOC for all cases.\n    \"\"\"\n\n    # --- Test Case Definitions ---\n\n    # Case 1: Smooth solution u_s(x,y) = sin(pi*x)sin(pi*y)\n    u_s = lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y)\n    f_s = lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y)\n    \n    # Case 2: Singular solution u_sg(x,y) = r^(3/2)\n    def u_sg(x, y):\n        r = np.sqrt(x**2 + y**2)\n        # Handle r=0 case to avoid 0**negative power in f_sg\n        return np.power(r, 1.5)\n\n    def f_sg(x, y):\n        # f is evaluated only at interior points, so r > 0.\n        r = np.sqrt(x**2 + y**2)\n        alpha = 1.5\n        return -alpha**2 * np.power(r, alpha - 2)\n\n    # --- Test Suite ---\n    test_cases = [\n        # Case A: Smooth solution, standard refinement\n        {'name': 'A', 'Ns': [8, 16, 32, 64], 'u_func': u_s, 'f_func': f_s},\n        # Case B: Singular solution\n        {'name': 'B', 'Ns': [8, 16, 32, 64], 'u_func': u_sg, 'f_func': f_sg},\n        # Case C: Smooth solution, coarse grids\n        {'name': 'C', 'Ns': [4, 8, 16], 'u_func': u_s, 'f_func': f_s},\n    ]\n\n    eoc_results = []\n\n    for case in test_cases:\n        h_values = []\n        error_values = []\n\n        for N in case['Ns']:\n            h = 1.0 / N\n            u_func = case['u_func']\n            f_func = case['f_func']\n            g_func = u_func # Boundary condition is the exact solution\n\n            # 1. Set up grid and coordinates\n            # Grid for interior points (1..N-1)\n            int_coords = np.linspace(h, 1.0 - h, N - 1)\n            X_int, Y_int = np.meshgrid(int_coords, int_coords, indexing='ij')\n\n            # Full grid for error calculation (0..N)\n            full_coords = np.linspace(0, 1.0, N + 1)\n            X_full, Y_full = np.meshgrid(full_coords, full_coords, indexing='ij')\n\n            # 2. Construct the right-hand side (RHS) vector 'b'\n            b = f_func(X_int, Y_int)\n            h2_inv = 1.0 / (h**2)\n            \n            # Add boundary contributions\n            # j = 1, ..., N-1\n            b[0, :] += h2_inv * g_func(0, int_coords)  # Left boundary i=0\n            b[-1, :] += h2_inv * g_func(1, int_coords) # Right boundary i=N\n            # i = 1, ..., N-1\n            b[:, 0] += h2_inv * g_func(int_coords, 0)  # Bottom boundary j=0\n            b[:, -1] += h2_inv * g_func(int_coords, 1) # Top boundary j=N\n\n            # 3. Solve the linear system using matrix-free Conjugate Gradient\n            u_h_interior = cg_solver(b, h, tol=1e-12)\n\n            # 4. Construct full solution grid and compute error\n            u_h_full = np.zeros((N + 1, N + 1))\n            # Set boundary values\n            u_h_full[0, :] = g_func(0, full_coords)\n            u_h_full[N, :] = g_func(1, full_coords)\n            u_h_full[:, 0] = g_func(full_coords, 0)\n            u_h_full[:, N] = g_func(full_coords, 1)\n            # Fill interior\n            u_h_full[1:N, 1:N] = u_h_interior\n\n            u_exact_full = u_func(X_full, Y_full)\n            \n            error = np.max(np.abs(u_exact_full - u_h_full))\n            \n            h_values.append(h)\n            error_values.append(error)\n\n        # 5. Compute EOC using least-squares fit\n        log_h = np.log(np.array(h_values))\n        log_e = np.log(np.array(error_values))\n        \n        # Fit a line (degree 1 polynomial) to (log_h, log_e)\n        # The slope is the first coefficient returned by polyfit.\n        p_eoc = np.polyfit(log_h, log_e, 1)[0]\n        eoc_results.append(p_eoc)\n    \n    # Final print statement\n    print(f\"[{','.join(f'{p:.3f}' for p in eoc_results)}]\")\n\ndef apply_A_matvec(v, h):\n    \"\"\"\n    Computes the matrix-free matrix-vector product for the 5-point stencil.\n    Assumes zero boundary conditions for the input vector v.\n    \n    Args:\n        v (np.ndarray): A 2D numpy array of size (N-1)x(N-1) representing the vector.\n        h (float): The mesh spacing.\n    \n    Returns:\n        np.ndarray: The result of Av, a 2D array of size (N-1)x(N-1).\n    \"\"\"\n    if v.shape[0] == 0:\n        return np.array([])\n    N_minus_1 = v.shape[0]\n    Av = np.zeros_like(v)\n    h2_inv = 1.0 / (h**2)\n    \n    # Pad with zeros for boundary conditions\n    v_padded = np.pad(v, pad_width=1, mode='constant', constant_values=0)\n    \n    for i in range(N_minus_1):\n        for j in range(N_minus_1):\n            # Convert to padded indices\n            ip, jp = i + 1, j + 1\n            center = v_padded[ip, jp]\n            left = v_padded[ip - 1, jp]\n            right = v_padded[ip + 1, jp]\n            down = v_padded[ip, jp - 1]\n            up = v_padded[ip, jp + 1]\n            \n            Av[i, j] = h2_inv * (4 * center - left - right - down - up)\n            \n    return Av\n\ndef cg_solver(b, h, tol=1e-10, max_iter=1000):\n    \"\"\"\n    Solves Ax=b using matrix-free Conjugate Gradient method.\n    \n    Args:\n        b (np.ndarray): The right-hand side vector as a 2D (N-1)x(N-1) array.\n        h (float): The mesh spacing.\n        tol (float): The relative tolerance for the residual norm.\n        max_iter (int): Maximum number of iterations.\n    \n    Returns:\n        np.ndarray: The solution vector x as a 2D (N-1)x(N-1) array.\n    \"\"\"\n    if b.size == 0:\n        return np.array([])\n    x = np.zeros_like(b)\n    r = b - apply_A_matvec(x, h)\n    p = r.copy()\n    rs_old = np.sum(r**2)\n    \n    b_norm = np.sqrt(np.sum(b**2))\n    if b_norm == 0:\n        return x\n\n    for k in range(max_iter):\n        Ap = apply_A_matvec(p, h)\n        pAp = np.sum(p * Ap)\n\n        if pAp == 0:\n            break\n            \n        alpha = rs_old / pAp\n        x += alpha * p\n        r -= alpha * Ap\n        \n        rs_new = np.sum(r**2)\n        \n        if np.sqrt(rs_new)  tol * b_norm:\n            break\n            \n        p = r + (rs_new / rs_old) * p\n        rs_old = rs_new\n        \n    return x\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228788"}, {"introduction": "在分析了有限差分格式的误差之后，一个自然的问题是：我们能否在不设计全新高阶格式的情况下提高其精度？Richardson外推法正是实现这一目标的强大技术。通过对一系列系统加密的网格上得到的解进行线性组合，你可以消除主导的误差项，从而获得一个精度更高的结果 ([@problem_id:3228920])。这项实践将向你展示如何利用已知的截断误差结构，从低阶格式的计算结果中构造出高阶精度的近似解。", "problem": "考虑单位平方域上的二维泊松偏微分方程（PDE），其笛卡尔坐标为 $(x,y) \\in [0,1] \\times [0,1]$，\n$$- \\Delta u(x,y) = f(x,y),$$\n服从齐次狄利克雷边界条件\n$$u(x,y) = 0 \\quad \\text{for} \\quad (x,y) \\in \\partial([0,1] \\times [0,1]).$$\n假设精确解由下式给出\n$$u(x,y) = \\sin(\\pi x)\\sin(\\pi y),$$\n因此源项由拉普拉斯算子 $\\Delta$ 的恒等式确定，\n$$- \\Delta u(x,y) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y).$$\n所有三角函数的角度必须以弧度解释。\n\n在间距为 $h$ 的均匀网格上，使用标准的五点中心有限差分（FD）格式来处理拉普拉斯算子。内部网格节点 $(i,j)$ 处的离散算子由二阶导数的定义构建，并产生一个线性代数系统。在 $u(x,y)$ 的光滑性假设下，该系统近似于该偏微分方程，其截断误差渐近正比于 $h^2$。设内部网格大小为 $n \\times n$，网格间距为 $h = \\frac{1}{n+1}$，内部索引为 $i,j \\in \\{1,2,\\dots,n\\}$。用 $U_h$ 表示在域的几何中心 $(x,y) = (0.5,0.5)$ 处对 $u$ 的有限差分近似值。当 $n$ 为奇数时，该中心对应于内部索引 $(i,j) = \\left(\\frac{n+1}{2},\\frac{n+1}{2}\\right)$。\n\n您的任务是：\n- 构建由 $- \\Delta u = f$ 的五点有限差分离散化（在 $\\partial \\Omega$ 上具有齐次狄利克雷边界条件 $u=0$）所产生的线性系统，在间距分别为 $h$、$h/2$ 和 $h/4$ 的三个嵌套均匀网格上求解该系统，并提取在中心点得到的三个近似值，记为 $U_h$、$U_{h/2}$ 和 $U_{h/4}$。\n- 对序列 $\\{U_h, U_{h/2}, U_{h/4}\\}$ 应用 Richardson 外推法，加密比 $r = 2$，以消除主导的 $O(h^2)$ 截断误差项，然后消除接下来的 $O(h^4)$ 项，从而在中心点产生一个更高阶的精确近似值。您必须根据渐近误差展开和加密比，推导并实现能够抵消主导误差项和次主导误差项的代数组合。\n- 计算中心点的绝对误差，定义为 $|U_{\\text{extrap}} - u(0.5,0.5)|$，其中 $U_{\\text{extrap}}$是您的三级 Richardson 外推值，而 $u(0.5,0.5) = \\sin(\\pi/2)\\sin(\\pi/2) = 1$。\n\n测试套件：\n- 程序必须针对定义粗网格的三个基本内部尺寸 $n_0$ 运行该过程。对于每个 $n_0$，构建内部尺寸分别为 $n_0$、$2n_0+1$ 和 $4n_0+3$（分别对应间距 $h$、$h/2$ 和 $h/4$）的三个嵌套网格，并按所述执行外推。使用以下测试用例：\n    1. $n_0 = 1$ (边缘情况的粗网格，最少内部点)，\n    2. $n_0 = 7$ (典型的中等分辨率情况)，\n    3. $n_0 = 15$ (较精细的粗网格)。\n这些选择确保了几何中心 $(0.5,0.5)$ 在每个嵌套网格上都与一个网格点重合。\n\n最终输出规格：\n- 您的程序应生成单行输出，其中包含三个测试用例的三级 Richardson 外推中心值的绝对误差，格式为方括号内以逗号分隔的列表，例如 $$[e_1,e_2,e_3],$$ 其中每个 $e_k$ 是一个浮点数，表示第 $k$ 个测试用例的绝对误差。", "solution": "### 问题验证\n\n根据指定标准对问题陈述进行严格审查。\n\n#### 步骤 1：提取已知条件\n\n- **PDE**：给定的二维泊松方程为 $- \\Delta u(x,y) = f(x,y)$，定义在域 $\\Omega = [0,1] \\times [0,1]$ 上。\n- **边界条件 (BCs)**：指定了齐次狄利克雷边界条件：对于 $(x,y) \\in \\partial\\Omega$，$u(x,y) = 0$。\n- **精确解**：问题的精确解由 $u(x,y) = \\sin(\\pi x)\\sin(\\pi y)$ 给出。\n- **源项**：源项 $f(x,y)$ 由精确解确定：$f(x,y) = - \\Delta u(x,y) = 2 \\pi^2 \\sin(\\pi x)\\sin(\\pi y)$。所有三角函数均以弧度为单位。\n- **离散化方法**：将使用标准五点中心有限差分（FD）格式，该格式应用于间距为 $h$ 的均匀网格。截断误差据称渐近正比于 $h^2$。\n- **网格定义**：网格有 $n \\times n$ 个内部节点。网格间距为 $h = \\frac{1}{n+1}$，内部索引为 $i,j \\in \\{1,2,\\dots,n\\}$。\n- **关注量**：域几何中心 $(x,y)=(0.5,0.5)$ 处的有限差分近似值 $U_h$。对于奇数 $n$，这对应于网格索引 $(i,j) = \\left(\\frac{n+1}{2},\\frac{n+1}{2}\\right)$。\n- **任务**：\n    1.  在间距为 $h$、$h/2$ 和 $h/4$ 的三个嵌套网格上求解有限差分系统，得到中心点的近似值 $U_h, U_{h/2}, U_{h/4}$。\n    2.  对序列 $\\{U_h, U_{h/2}, U_{h/4}\\}$ 应用两阶段 Richardson 外推，以获得更高阶的近似值 $U_{\\text{extrap}}$。\n    3.  计算绝对误差 $|U_{\\text{extrap}} - u(0.5,0.5)|$，其中精确值为 $u(0.5,0.5) = 1$。\n- **测试用例**：该过程将针对三个基本内部网格尺寸 $n_0$ 运行：\n    1.  $n_0=1$：使用 $n=1, 3, 7$ 的网格。\n    2.  $n_0=7$：使用 $n=7, 15, 31$ 的网格。\n    3.  $n_0=15$：使用 $n=15, 31, 63$ 的网格。\n    嵌套网格由 $n_0$、$n_1=2n_0+1$ 和 $n_2=4n_0+3$ 定义，这正确地对应于间距 $h$、$h/2$ 和 $h/4$。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n- **科学基础**：该问题是偏微分方程数值分析领域的经典练习。泊松方程、有限差分法和 Richardson 外推都是标准的、成熟的课题。所提供的精确解和推导出的源项是一致的。\n- **适定性**：带狄利克雷边界条件的泊松方程是一个适定的椭圆型偏微分方程。其有限差分离散化产生一个非奇异、唯一可解的线性系统。任务定义清晰，并能得出唯一的数值结果。\n- **客观性**：问题使用精确的数学语言陈述，没有主观或模糊的术语。\n- **完整性和一致性**：提供了所有必要信息（PDE、域、边界条件、离散化格式、精确解和测试参数）。网格尺寸 $n$ 和间距 $h$ 之间的关系在嵌套加密中保持一致。选择奇数值 $n$ 确保了域中心 $(0.5,0.5)$ 始终是一个网格点，这是完成该任务的必要条件。\n\n该问题没有科学缺陷、不一致或模糊之处。\n\n#### 步骤 3：结论与行动\n\n该问题是**有效的**。将提供解决方案。\n\n### 解决方案\n\n解决方案是通过一个系统的程序制定的，该程序包括离散化、线性系统构建和 Richardson 外推。\n\n#### 1. 有限差分离散化\n泊松方程为 $-(\\partial^2 u/\\partial x^2 + \\partial^2 u/\\partial y^2) = f(x,y)$。我们引入一个在每个方向上有 $n$ 个内部点的均匀网格，使得网格间距为 $h=1/(n+1)$。网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j = 0, 1, \\dots, n+1$。内部点对应于索引 $i,j = 1, \\dots, n$。\n\n二阶偏导数使用中心差分进行近似：\n$$ \\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} $$\n$$ \\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} $$\n其中 $U_{i,j}$ 是 $u(x_i, y_j)$ 的数值近似值。\n\n将这些代入泊松方程，得到每个内部节点 $(i,j)$ 处负拉普拉斯算子的五点差分格式：\n$$ -\\Delta_h U_{i,j} = \\frac{4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1}}{h^2} = f(x_i, y_j) $$\n对于 $i,j=1, \\dots, n$。齐次狄利克雷边界条件意味着如果 $i$ 或 $j$ 为 $0$ 或 $n+1$，则 $U_{i,j}=0$。\n\n#### 2. 线性系统构建\n关于未知内部值 $U_{i,j}$ 的 $n^2$ 个线性方程组可以写成矩阵形式 $A\\vec{U} = \\vec{F}$。未知向量 $\\vec{U}$ 是一个 $n^2 \\times 1$ 的列向量，通过对 $U_{i,j}$ 值进行排序而形成。使用标准的逐行（或自然）排序，其中索引 $j$ 变化最快，从二维网格索引 $(i,j)$ (其中 $i,j \\in \\{1,\\dots,n\\}$) 到一维向量索引 $k \\in \\{1,\\dots,n^2\\}$ 的映射为 $k = (i-1)n+j$。\n\n矩阵 $A$ 是一个 $n^2 \\times n^2$ 的稀疏、对称、正定、块三对角矩阵：\n$$ A = \\frac{1}{h^2} \\begin{pmatrix}\nT  -I    \\\\\n-I  T  -I   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -I  T  -I \\\\\n   -I  T\n\\end{pmatrix} $$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，而 $T$ 是 $n \\times n$ 的三对角矩阵：\n$$ T = \\begin{pmatrix}\n4  -1    \\\\\n-1  4  -1   \\\\\n \\ddots  \\ddots  \\ddots  \\\\\n  -1  4  -1 \\\\\n   -1  4\n\\end{pmatrix} $$\n这种结构直接源于五点差分格式。矩阵 $A$ 可以使用克罗内克积优雅地构建。设 $A_{1D} = T/h^2$ 是表示一维负二阶导数的矩阵。那么二维算子矩阵是 $A = I \\otimes A_{1D} + A_{1D} \\otimes I$。\n\n右端向量 $\\vec{F}$ 是一个 $n^2 \\times 1$ 的列向量，包含在内部网格点 $(x_i, y_j)$ 处计算的源项 $f(x,y) = 2\\pi^2\\sin(\\pi x)\\sin(\\pi y)$ 的值，其排序与 $\\vec{U}$ 一致。\n对于每个测试用例，我们构建此系统并使用标准线性求解器求解 $\\vec{U}$。\n\n#### 3. Richardson 外推\n有限差分格式的截断误差，对于对称域上的足够光滑的解，可以表示为关于 $h$ 的偶次幂的渐近级数：\n$$ U_h = u + C_1 h^2 + C_2 h^4 + C_3 h^6 + \\dots $$\n其中 $U_h$ 是某一点的数值近似值，$u$ 是该点的精确解，而 $C_k$ 是与 $h$ 无关的常数。\n\n我们计算在域中心点，使用间距为 $h_0$、$h_1=h_0/2$ 和 $h_2=h_0/4$ 的三个网格得到的解。设相应的数值解为 $A_0, A_1, A_2$。\n$$ A_0 = u + C_1 h_0^2 + C_2 h_0^4 + O(h_0^6) $$\n$$ A_1 = u + C_1 (h_0/2)^2 + C_2 (h_0/2)^4 + O(h_0^6) = u + \\frac{1}{4}C_1 h_0^2 + \\frac{1}{16}C_2 h_0^4 + O(h_0^6) $$\n$$ A_2 = u + C_1 (h_0/4)^2 + C_2 (h_0/4)^4 + O(h_0^6) = u + \\frac{1}{16}C_1 h_0^2 + \\frac{1}{256}C_2 h_0^4 + O(h_0^6) $$\n\n**第一次外推（至 $O(h^4)$ 阶）：**\n我们组合几对近似值以消除主导的 $O(h^2)$ 误差项。对于加密比 $r$ 和误差阶 $p$，通用公式为 $(r^p A_{fine} - A_{coarse}) / (r^p-1)$。这里，$r=2$ 且 $p=2$。\n设 $B_0$ 是由 $A_0$ 和 $A_1$ 外推得到的值：\n$$ B_0 = \\frac{2^2 A_1 - A_0}{2^2 - 1} = \\frac{4A_1 - A_0}{3} = u - \\frac{1}{4}C_2 h_0^4 + O(h_0^6) $$\n设 $B_1$ 是由 $A_1$ 和 $A_2$ 外推得到的值：\n$$ B_1 = \\frac{2^2 A_2 - A_1}{2^2 - 1} = \\frac{4A_2 - A_1}{3} = u - \\frac{1}{4}C_2 (h_0/2)^4 + O(h_0^6) = u - \\frac{1}{64}C_2 h_0^4 + O(h_0^6) $$\n$B_0$ 和 $B_1$ 现在是四阶精确的近似值。\n\n**第二次外推（至 $O(h^6)$ 阶）：**\n我们组合 $B_0$ 和 $B_1$ 以消除 $O(h^4)$ 误差项。此时主导误差的阶为 $p=4$。\n$$ U_{\\text{extrap}} = \\frac{2^4 B_1 - B_0}{2^4 - 1} = \\frac{16B_1 - B_0}{15} $$\n代入 $B_0$ 和 $B_1$ 的表达式：\n$$ U_{\\text{extrap}} = \\frac{1}{15} \\left[ 16\\left(\\frac{4A_2 - A_1}{3}\\right) - \\left(\\frac{4A_1 - A_0}{3}\\right) \\right] $$\n$$ U_{\\text{extrap}} = \\frac{1}{45} \\left[ 16(4A_2 - A_1) - (4A_1 - A_0) \\right] $$\n$$ U_{\\text{extrap}} = \\frac{64A_2 - 16A_1 - 4A_1 + A_0}{45} = \\frac{64A_2 - 20A_1 + A_0}{45} $$\n这个最终值 $U_{\\text{extrap}}$ 的截断误差为 $O(h_0^6)$。\n\n#### 4. 计算步骤\n为每个测试用例 $n_0 \\in \\{1, 7, 15\\}$ 实现以下算法：\n1.  定义三个内部网格尺寸：$n_h = n_0$，$n_{h/2} = 2n_0+1$ 和 $n_{h/4} = 4n_0+3$。\n2.  对于每个网格尺寸 $n \\in \\{n_h, n_{h/2}, n_{h/4}\\}$：\n    a. 计算网格间距 $h = 1/(n+1)$。\n    b. 构建 $n^2 \\times n^2$ 矩阵 $A$ 和 $n^2 \\times 1$ 的右端向量 $\\vec{F}$。\n    c. 求解线性系统 $A\\vec{U} = \\vec{F}$ 以获得解向量 $\\vec{U}$。\n    d. 提取中心网格点的解。对于一个 $n \\times n$ 的内部网格（使用从 $0$ 到 $n-1$ 的零基索引），中心索引为 $(i_c,j_c) = ((n-1)/2, (n-1)/2)$。对应的一维索引是 $k_c = i_c \\cdot n + j_c$。中心值为 $U_{i_c,j_c}$。\n3.  将三个中心值存储为 $A_0 = U_h$，$A_1 = U_{h/2}$ 和 $A_2 = U_{h/4}$。\n4.  计算外推值 $U_{\\text{extrap}} = (64A_2 - 20A_1 + A_0) / 45$。\n5.  中心点 $(0.5,0.5)$ 的精确解为 $u(0.5,0.5) = \\sin(\\pi/2)\\sin(\\pi/2) = 1$。\n6.  计算绝对误差：$E = |U_{\\text{extrap}} - 1|$。\n7.  收集三个 $n_0$ 值的误差，并以列表形式呈现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_poisson_center(n):\n    \"\"\"\n    Solves the 2D Poisson equation -Delta u = f on the unit square\n    using a five-point finite difference scheme on an n x n interior grid.\n\n    Args:\n        n (int): The number of interior grid points in one dimension.\n                 n must be odd.\n\n    Returns:\n        float: The numerical solution at the center of the domain (0.5, 0.5).\n    \"\"\"\n    if n % 2 == 0:\n        raise ValueError(\"n must be an odd integer for the center to be a grid point.\")\n\n    h = 1.0 / (n + 1)\n    \n    # Construct the n x n tridiagonal matrix T for the 1D operator part.\n    T = 4 * np.eye(n) - np.eye(n, k=1) - np.eye(n, k=-1)\n    \n    # Construct the n^2 x n^2 matrix A for the 2D operator -Delta_h\n    # using Kronecker products. This forms the block-tridiagonal matrix.\n    A_mat = np.kron(np.eye(n), T) + np.kron(-np.eye(n, k=1) - np.eye(n, k=-1), np.eye(n))\n    \n    A_mat /= h**2\n    \n    # Construct the right-hand side vector F\n    # Create grid coordinates for interior points\n    x = np.linspace(h, 1.0 - h, n)\n    # Use 'ij' indexing to match row-major flattening\n    xx, yy = np.meshgrid(x, x, indexing='ij')\n    \n    # Evaluate the source function f(x,y)\n    F_grid = 2 * (np.pi**2) * np.sin(np.pi * xx) * np.sin(np.pi * yy)\n    \n    # Flatten grid to a vector, matching the matrix's row-major ordering\n    F_vec = F_grid.flatten()\n    \n    # Solve the linear system A * U = F\n    U_vec = np.linalg.solve(A_mat, F_vec)\n    \n    # Extract the solution at the center\n    # For an n x n grid (0-indexed), the center is at ( (n-1)/2, (n-1)/2 )\n    center_idx_1d = (n - 1) // 2\n    center_k = center_idx_1d * n + center_idx_1d\n    \n    return U_vec[center_k]\n\ndef solve():\n    \"\"\"\n    Main function to run the Richardson extrapolation procedure for the given test cases.\n    \"\"\"\n    # The program must run the procedure for three base interior sizes n0.\n    # The test cases specify these base sizes.\n    test_cases = [1, 7, 15]\n    \n    results = []\n    \n    for n0 in test_cases:\n        # Define the three nested grid sizes\n        n_h = n0\n        n_h_div_2 = 2 * n0 + 1\n        n_h_div_4 = 4 * n0 + 3\n        \n        # Calculate the numerical solution at the center for each grid\n        A0 = solve_poisson_center(n_h)        # Coarsest grid, h\n        A1 = solve_poisson_center(n_h_div_2)  # Medium grid, h/2\n        A2 = solve_poisson_center(n_h_div_4)  # Finest grid, h/4\n        \n        # Apply the three-level Richardson extrapolation formula:\n        # U_extrap = (64 * A2 - 20 * A1 + A0) / 45\n        U_extrap = (64.0 * A2 - 20.0 * A1 + A0) / 45.0\n        \n        # Exact solution at the center (0.5, 0.5)\n        u_exact_center = np.sin(np.pi / 2.0) * np.sin(np.pi / 2.0) # which is 1.0\n        \n        # Compute the absolute error\n        error = np.abs(U_extrap - u_exact_center)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{err:.16e}' for err in results)}]\")\n\nsolve()\n\n```", "id": "3228920"}]}