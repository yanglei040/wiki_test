{"hands_on_practices": [{"introduction": "理论最好的试金石是实践。在对显式前向时间中心空间（FTCS）格式有了基本了解后，我们通过几个动手实践来加深理解。第一个练习 [@problem_id:2483538] 将理论直接应用于一个实际的计算问题。在编写任何代码之前，我们首先需要根据给定的空间分辨率，利用稳定性判据来确定允许的最大时间步长，这是确保数值模拟结果有意义的关键第一步。", "problem": "一个均匀、各向同性的一维固体，其热扩散系数为常数，该固体由能量守恒和傅里叶定律推导出的瞬态热传导方程控制，其形式为 $\\frac{\\partial T}{\\partial t}=\\alpha\\,\\frac{\\partial^{2}T}{\\partial x^{2}}$，其中 $T$ 是温度，$t$ 是时间，$x$ 是沿杆的空间坐标，$\\alpha$ 是热扩散系数。考虑一个间距为 $\\Delta x$ 的均匀网格，并应用前向时间中心空间（FTCS）显式时间积分格式，该格式使用前向欧拉步长在时间上推进 $T$，并用二阶中心差分近似空间二阶导数。使用 von Neumann (傅里叶) 稳定性分析，确定最大时间步长 $\\Delta t_{\\max}$，使得该格式对于所有空间傅里叶模式达到临界稳定。\n\n使用数据 $\\alpha=1.4\\times 10^{-5}\\,\\mathrm{m^{2}/s}$ 和 $\\Delta x=0.5\\,\\mathrm{mm}$，计算此一维 FTCS 离散化对应的 $\\Delta t_{\\max}$。将答案四舍五入到四位有效数字，并以秒为单位表示时间。", "solution": "该问题陈述具有科学依据，是适定的，并包含了获得唯一解所需的所有信息。因此，该问题被认为是有效的。我们开始求解。\n\n一维瞬态热传导的控制方程如下：\n$$\n\\frac{\\partial T}{\\partial t} = \\alpha \\frac{\\partial^2 T}{\\partial x^2}\n$$\n这里，$T(x, t)$ 是温度，$x$ 是空间坐标，$t$ 是时间，$\\alpha$ 是热扩散系数。我们要分析此方程的前向时间中心空间（FTCS）离散格式的稳定性。\n\n我们定义一个空间步长为 $\\Delta x$、时间步长为 $\\Delta t$ 的均匀网格。在网格节点 $i$ 和时间层 $n$ 的温度表示为 $T_i^n \\equiv T(i\\Delta x, n\\Delta t)$。\n\nFTCS 格式按如下方式近似偏导数：\n时间导数使用一阶前向差分近似：\n$$\n\\frac{\\partial T}{\\partial t} \\bigg|_{i,n} \\approx \\frac{T_i^{n+1} - T_i^n}{\\Delta t}\n$$\n空间二阶导数使用二阶中心差分近似：\n$$\n\\frac{\\partial^2 T}{\\partial x^2} \\bigg|_{i,n} \\approx \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2}\n$$\n将这些近似值代入控制方程，得到 FTCS 格式的离散形式：\n$$\n\\frac{T_i^{n+1} - T_i^n}{\\Delta t} = \\alpha \\left( \\frac{T_{i+1}^n - 2T_i^n + T_{i-1}^n}{(\\Delta x)^2} \\right)\n$$\n我们可以重排此方程，以显式求解下一个时间步的温度 $T_i^{n+1}$：\n$$\nT_i^{n+1} = T_i^n + \\frac{\\alpha \\Delta t}{(\\Delta x)^2} (T_{i+1}^n - 2T_i^n + T_{i-1}^n)\n$$\n我们定义无量纲傅里叶数 $Fo$（也称为扩散数）为：\n$$\nFo = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}\n$$\n离散方程简化为：\n$$\nT_i^{n+1} = T_i^n + Fo (T_{i+1}^n - 2T_i^n + T_{i-1}^n) = Fo \\, T_{i+1}^n + (1 - 2Fo)T_i^n + Fo \\, T_{i-1}^n\n$$\n为了确定此数值格式的稳定性，我们进行 von Neumann 稳定性分析。我们考虑解的单个傅里叶模式的行为。设时间层 $n$ 的温度分布表示为一个傅里叶分量：\n$$\nT_i^n = \\hat{T}^n(k) e^{I k x_i}\n$$\n其中 $k$ 是波数，$x_i = i\\Delta x$ 是节点 $i$ 的空间位置，$I = \\sqrt{-1}$ 是虚数单位。该模式在时间 $n$ 的振幅是 $\\hat{T}^n(k)$。经过一个时间步后，该模式将被一个因子 $G(k)$（放大因子）放大：\n$$\nT_i^{n+1} = \\hat{T}^{n+1}(k) e^{I k x_i} = G(k) \\hat{T}^n(k) e^{I k x_i}\n$$\n为了使数值格式稳定，放大因子的模对于任何波数 $k$ 都不得超过 1。稳定性条件是：\n$$\n|G(k)| \\le 1\n$$\n我们将傅里叶模式表示代入离散方程：\n$$\nG(k) \\hat{T}^n(k) e^{I k (i\\Delta x)} = Fo \\, \\hat{T}^n(k) e^{I k ((i+1)\\Delta x)} + (1 - 2Fo) \\hat{T}^n(k) e^{I k (i\\Delta x)} + Fo \\, \\hat{T}^n(k) e^{I k ((i-1)\\Delta x)}\n$$\n两边同除以 $\\hat{T}^n(k) e^{I k (i\\Delta x)}$，得到放大因子 $G(k)$ 的表达式：\n$$\nG(k) = Fo \\, e^{I k \\Delta x} + (1 - 2Fo) + Fo \\, e^{-I k \\Delta x}\n$$\n使用欧拉恒等式 $e^{I\\theta} + e^{-I\\theta} = 2\\cos(\\theta)$，我们可以简化此表达式：\n$$\nG(k) = 1 - 2Fo + Fo (e^{I k \\Delta x} + e^{-I k \\Delta x}) = 1 - 2Fo + 2Fo \\cos(k \\Delta x)\n$$\n$$\nG(k) = 1 - 2Fo(1 - \\cos(k \\Delta x))\n$$\n使用三角半角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们得到：\n$$\nG(k) = 1 - 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n现在我们应用稳定性条件 $|G(k)| \\le 1$。由于 $Fo > 0$，项 $4Fo \\sin^2(k\\Delta x/2)$ 是非负的。因此，$G(k)$ 总是小于或等于 $1$。稳定性因此由下界决定：\n$$\nG(k) \\ge -1\n$$\n$$\n1 - 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right) \\ge -1\n$$\n$$\n2 \\ge 4Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n$$\n\\frac{1}{2} \\ge Fo \\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n这个不等式必须对所有可能的波数 $k$ 成立。最苛刻的条件发生在项 $\\sin^2(k\\Delta x/2)$ 达到其最大值时。$\\sin^2(\\theta)$ 的最大值是 $1$。这对应于可在网格上表示的最高频率（振荡最快）的模式，此时 $k \\Delta x = \\pi$。\n因此，稳定性条件变为：\n$$\nFo \\le \\frac{1}{2}\n$$\n临界稳定性在此条件的极限处达到，即 $Fo = 1/2$。最大允许时间步长 $\\Delta t_{\\max}$ 对应于此极限：\n$$\n\\frac{\\alpha \\Delta t_{\\max}}{(\\Delta x)^2} = \\frac{1}{2}\n$$\n求解 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{(\\Delta x)^2}{2\\alpha}\n$$\n给定以下数据：\n$\\alpha = 1.4 \\times 10^{-5} \\, \\mathrm{m^2/s}$\n$\\Delta x = 0.5 \\, \\mathrm{mm} = 0.5 \\times 10^{-3} \\, \\mathrm{m}$\n\n将这些值代入 $\\Delta t_{\\max}$ 的表达式中：\n$$\n(\\Delta x)^2 = (0.5 \\times 10^{-3} \\, \\mathrm{m})^2 = 0.25 \\times 10^{-6} \\, \\mathrm{m^2}\n$$\n$$\n\\Delta t_{\\max} = \\frac{0.25 \\times 10^{-6} \\, \\mathrm{m^2}}{2 \\times (1.4 \\times 10^{-5} \\, \\mathrm{m^2/s})} = \\frac{0.25 \\times 10^{-6}}{2.8 \\times 10^{-5}} \\, \\mathrm{s}\n$$\n$$\n\\Delta t_{\\max} = \\frac{0.25}{2.8} \\times 10^{-1} \\, \\mathrm{s} \\approx 0.0892857 \\times 10^{-1} \\, \\mathrm{s} = 0.00892857 \\, \\mathrm{s}\n$$\n问题要求将答案四舍五入到四位有效数字。\n$$\n\\Delta t_{\\max} \\approx 0.008929 \\, \\mathrm{s}\n$$", "answer": "$$\n\\boxed{0.008929}\n$$", "id": "2483538"}, {"introduction": "理论预测需要通过计算实验来验证。这个编码练习 [@problem_id:3204666] 让你有机会亲眼目睹违反稳定性条件时数值解如何“爆炸”，并定量地检验该格式的收敛阶。通过设置不同的稳定性参数 $r$ 并比较不同网格分辨率下的误差，你将深刻体会到理论分析在指导计算实践中的重要性。", "problem": "考虑一维热方程 $u_t = \\alpha u_{xx}$，其空间区间为 $x \\in [0,1]$，时间为 $t \\ge 0$，其中 $\\alpha > 0$ 是一个常数。施加齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$（对于所有 $t \\ge 0$），以及初始条件 $u(x,0) = \\sin(\\pi x)$。此初边值问题的精确解为 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$。从偏导数和二阶中心差分的基本定义出发，实现一种显式前向时间格式，该格式结合了二阶中心空间差分，即用前向差分近似 $u_t$，用二阶中心差分近似 $u_{xx}$。此格式应用于一个具有空间步长 $\\Delta x$ 和时间步长 $\\Delta t$ 的均匀网格。使用无量纲参数 $r = \\alpha \\Delta t / (\\Delta x)^2$ 来根据空间分辨率参数化时间步长。\n\n您的程序必须：\n- 用 $N_x$ 个网格点离散化区间 $[0,1]$，使得 $\\Delta x = 1/(N_x-1)$。\n- 使用由指定 $r$ 确定的 $\\Delta t$ 将显式格式演化至最终时间 $T$。\n- 对于每次运行，计算数值解在整个时间内的最大范数，并且如果整个模拟过程中的最大范数不超过初始条件最大范数的 $1.05$ 倍，则声明其行为为“观测稳定”；否则声明为“观测不稳定”。\n- 将观测稳定性与基于 $r$ 的理论分类准则进行比较，并返回一个布尔值，指示该次运行的观测结果是否与理论相符。\n- 在模拟结束时，使用精确解 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$ 和网格误差的无穷范数来计算数值误差。\n\n测试套件和参数：\n- 在 $\\alpha = 1.0$，$N_x = 51$，最终时间 $T = 0.1$ 的条件下，对三种情况进行稳定性验证：\n  - 情况 1：$r = 0.45$。\n  - 情况 2：$r = 0.5$。\n  - 情况 3：$r = 0.55$。\n  对于每种情况，输出一个布尔值，说明观测到的稳定性是否与理论稳定性分类相符。\n- 在稳定运行条件下的准确性与效率评估：\n  - 使用 $\\alpha = 1.0$，$T = 0.1$，$r = 0.45$。\n  - 运行两次模拟：一次使用 $N_x = 51$ 的粗网格，另一次使用 $N_x = 101$ 的细网格。\n  - 计算无穷范数误差之比 $E_{\\text{coarse}} / E_{\\text{fine}}$，结果为浮点数。此外，程序应内部为每次运行计算运算代理 $W = N_t \\cdot (N_x - 2)$，其中 $N_t$ 是时间步数，以便从概念上讨论效率，但此计数值无需打印。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表内无空格。该列表必须按顺序包含四个条目：用于稳定性验证的三个布尔值，以及用于准确性评估的浮点误差比率。例如，输出应类似于“[True,True,False,3.85]”，其中最后一个数字是浮点数。\n- 本问题中没有物理单位；所有量均为无量纲。", "solution": "一维热方程 $u_t = \\alpha u_{xx}$ 模拟了扩散平滑过程。对于一个均匀网格 $x_i = i \\Delta x$（其中 $i = 0,\\dots,N_x-1$）和时间层 $t^n = n \\Delta t$，显式前向时间和二阶中心空间格式可从时间导数和二阶导数的定义中导出。时间导数通过前向差分近似为 $u_t(x_i,t^n) \\approx \\left(u_i^{n+1} - u_i^n\\right)/\\Delta t$，二阶导数通过中心差分近似为 $u_{xx}(x_i,t^n) \\approx \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right)/(\\Delta x)^2$。令这些近似相等，得到显式更新方程：\n$$\nu_i^{n+1} = u_i^n + r \\left(u_{i+1}^n - 2u_i^n + u_{i-1}^n\\right), \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2},\n$$\n该方程适用于内部索引 $i = 1,\\dots,N_x-2$，并配合狄利克雷边界条件 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$（对所有 $n$）。\n\n基于原理的稳定性分析使用冯·诺依曼方法（Von Neumann method）来处理线性常系数格式。考虑一个傅里叶模 $e^{\\mathrm{i} k x_i}$，并写出放大因子 $g(k)$，使得对于该模有 $u_i^{n+1} = g(k) u_i^n$。代入中心差分可得：\n$$\ng(k) = 1 - 4 r \\sin^2\\left(\\frac{k \\Delta x}{2}\\right).\n$$\n在所有模的放大都有界的意义上，稳定性要求对所有波数 $k$ 都有 $\\lvert g(k) \\rvert \\le 1$。最严格的情况出现在 $\\sin^2\\left(k \\Delta x/2\\right) = 1$ 时，这导致了以下条件：\n$$\n-1 \\le 1 - 4r \\le 1 \\quad \\Rightarrow \\quad r \\le \\frac{1}{2}.\n$$\n因此，显式前向时间中心空间格式是稳定的，当且仅当 $r \\le 1/2$。该格式在时间上是一阶精确的（截断误差为 $\\mathcal{O}(\\Delta t)$），在空间上是二阶精确的（截断误差为 $\\mathcal{O}((\\Delta x)^2)$）。如果在加密网格时保持 $r$ 不变，则 $\\Delta t$ 的缩放方式与 $(\\Delta x)^2$ 相同，此时时间和空间误差都以 $\\mathcal{O}((\\Delta x)^2)$ 的方式缩放，整体误差表现为 $\\mathcal{O}((\\Delta x)^2)$。在这种耦合下，将 $\\Delta x$ 减半会使误差大约减少为原来的四分之一。\n\n显式方法的效率考量很简单：每个时间步更新 $N_x-2$ 个内部点，并且每个点的算术运算量是恒定的，因此计算工作量代理 $W$ 的缩放方式为 $W = N_t \\cdot (N_x - 2)$，其中 $N_t$ 是时间步数。对于固定的 $r$ 和最终时间 $T$，我们有 $\\Delta t = r (\\Delta x)^2/\\alpha$ 和 $N_t \\approx T/\\Delta t \\propto 1/(\\Delta x)^2$。因此，对于一维均匀网格，总工作量缩放为 $W \\propto (N_x-2) \\cdot 1/(\\Delta x)^2 \\sim \\mathcal{O}(N_x^3)$（因为 $N_x \\sim 1/\\Delta x$），这反映了显式格式对时间步长的抛物线型限制。\n\n该程序实现了初始条件为 $u(x,0) = \\sin(\\pi x)$ 和狄利克雷边界的显式格式，针对给定的 $\\alpha$、$N_x$ 和 $r$ 演化到最终时间 $T$，并通过监测整个时间内的最大范数来衡量观测稳定性。它使用精确解 $u(x,t) = e^{-\\alpha \\pi^2 t} \\sin(\\pi x)$ 计算最后模拟时刻的无穷范数误差。稳定性验证将观测到的分类与基于 $r$ 的理论分类进行比较，并为每个测试用例输出布尔值。对于准确性评估，它在稳定耦合 $r = 0.45$ 的条件下，比较 $N_x = 51$ 与 $N_x = 101$ 时的误差比率 $E_{\\text{coarse}}/E_{\\text{fine}}$，预期比率接近 4，这与空间二阶精度以及 $\\Delta t \\propto (\\Delta x)^2$ 耦合下的一阶时间精度相符。\n\n最终输出是格式为“[b1,b2,b3,ratio]”的单行文本，其中 $b1$、$b2$ 和 $b3$ 分别是对应 $r = 0.45$、$r = 0.5$ 和 $r = 0.55$ 情况的布尔值，而“ratio”是 $E_{\\text{coarse}}/E_{\\text{fine}}$ 的浮点数值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef explicit_heat(alpha: float, Nx: int, r: float, T: float):\n    \"\"\"\n    Run the explicit FTCS (Forward-Time, Central-Space) scheme for the 1D heat equation\n    u_t = alpha * u_xx with Dirichlet boundaries u(0,t)=u(1,t)=0 and initial condition\n    u(x,0) = sin(pi x).\n\n    Parameters\n    ----------\n    alpha : float\n        Diffusion coefficient (dimensionless).\n    Nx : int\n        Number of spatial grid points on [0,1].\n    r : float\n        Nondimensional parameter r = alpha * dt / dx^2.\n    T : float\n        Final simulation time.\n\n    Returns\n    -------\n    verify_match : bool\n        True if the observed stability classification matches the theoretical classification.\n    err_inf : float\n        Infinity-norm error at the final simulated time compared to the exact solution.\n    work_units : int\n        Proxy for computational work: number of interior updates performed.\n    \"\"\"\n    L = 1.0\n    x = np.linspace(0.0, L, Nx)\n    dx = x[1] - x[0]\n    dt = r * dx * dx / alpha\n    # Number of time steps to reach or slightly exceed T\n    Nt = int(np.ceil(T / dt)) if dt > 0 else 0\n    # Initialize u with the exact initial condition\n    u = np.sin(np.pi * x)\n    # Enforce Dirichlet boundaries explicitly (though sin(pi*x) already satisfies them)\n    u[0] = 0.0\n    u[-1] = 0.0\n    max_initial = np.max(np.abs(u))\n    max_over_time = max_initial\n    observed_stable = True\n\n    # Time stepping loop\n    for _ in range(Nt):\n        # Vectorized interior update\n        u_new = u.copy()\n        u_new[1:-1] = u[1:-1] + r * (u[2:] - 2.0 * u[1:-1] + u[:-2])\n        # Enforce Dirichlet boundaries\n        u_new[0] = 0.0\n        u_new[-1] = 0.0\n        u = u_new\n        current_max = np.max(np.abs(u))\n        # Detect numerical issues\n        if not np.isfinite(current_max):\n            observed_stable = False\n            max_over_time = np.inf\n            break\n        if current_max > max_over_time:\n            max_over_time = current_max\n\n    # Observational stability criterion: no growth beyond 5% of initial peak\n    if not (np.isfinite(max_over_time) and max_over_time = 1.05 * max_initial):\n        observed_stable = False\n\n    # Final time actually reached\n    t_end = Nt * dt\n    # Exact solution at final time\n    u_exact = np.exp(-alpha * (np.pi ** 2) * t_end) * np.sin(np.pi * x)\n    # Infinity-norm error\n    err_inf = float(np.max(np.abs(u - u_exact)))\n\n    # Theoretical stability classification for FTCS heat: r = 1/2\n    theoretical_stable = (r = 0.5 + 1e-12)\n    verify_match = (observed_stable == theoretical_stable)\n\n    # Work units proxy: number of interior updates\n    work_units = Nt * max(Nx - 2, 0)\n    return verify_match, err_inf, work_units\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Stability verification cases: alpha=1.0, Nx=51, T=0.1, r in {0.45, 0.5, 0.55}\n    stability_cases = [\n        (1.0, 51, 0.45, 0.1),\n        (1.0, 51, 0.5, 0.1),\n        (1.0, 51, 0.55, 0.1),\n    ]\n    # Accuracy ratio assessment: alpha=1.0, T=0.1, r=0.45, Nx in {51, 101}\n    accuracy_params = {\n        \"alpha\": 1.0,\n        \"T\": 0.1,\n        \"r\": 0.45,\n        \"Nx_coarse\": 51,\n        \"Nx_fine\": 101,\n    }\n\n    results = []\n\n    # Run stability verification cases\n    for alpha, Nx, r, T in stability_cases:\n        verify_match, _, _ = explicit_heat(alpha, Nx, r, T)\n        results.append(verify_match)\n\n    # Run accuracy ratio assessment\n    # Coarse grid\n    e_match_c, err_coarse, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_coarse\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Fine grid\n    e_match_f, err_fine, _ = explicit_heat(\n        accuracy_params[\"alpha\"], accuracy_params[\"Nx_fine\"], accuracy_params[\"r\"], accuracy_params[\"T\"]\n    )\n    # Compute error ratio; guard against zero to avoid division by zero\n    ratio = (err_coarse / err_fine) if err_fine != 0.0 else float(\"inf\")\n    results.append(ratio)\n\n    # Final print statement in the exact required format: single line, no spaces.\n    def fmt(x):\n        if isinstance(x, float):\n            # Format float with reasonable precision, remove spaces\n            return f\"{x:.12g}\"\n        else:\n            return str(x)\n\n    print(f\"[{','.join(fmt(r) for r in results)}]\")\n\nsolve()\n```", "id": "3204666"}, {"introduction": "优秀的数值格式不仅要精确，还应尽可能地反映其所模拟的物理系统的基本守恒定律。本练习 [@problem_id:3227077] 探究了 FTCS 格式的一个更深层次的性质：总热量守恒。你将需要为绝热边界（Neumann 条件）和恒温边界（Dirichlet 条件）实现不同的离散方法，并检验在哪种情况下数值解能够保持总热量守恒，从而理解边界条件如何影响解的全局物理特性。", "problem": "考虑空间区间 $[0,L]$ 上具有恒定热扩散系数 $\\alpha0$ 的一维热传导方程：\n$$\n\\frac{\\partial u}{\\partial t}(x,t)=\\alpha\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n其初始条件为 $u(x,0)=u_0(x)$，并采用以下两种边界条件类型之一：绝热边界条件 (Neumann，零热通量) $\\frac{\\partial u}{\\partial x}(0,t)=0$ 和 $\\frac{\\partial u}{\\partial x}(L,t)=0$，或固定温度边界条件 (Dirichlet) $u(0,t)=u_L$ 和 $u(L,t)=u_R$，其中 $u_L$ 和 $u_R$ 是常数。目标是数值验证显式时间向前中心空间 (FTCS) 有限差分格式在绝热与固定温度边界条件下，是否能够使总热量积分\n$$\nQ(t)=\\int_0^L u(x,t)\\,dx\n$$\n随时间保持守恒。\n\n从均匀网格上经过充分检验的有限差分定义出发，使用一个包含 $M$ 个点的均匀空间网格和一个均匀的时间步长来构建显式 FTCS 格式。设 $x_j=j\\,\\Delta x$ (对于 $j=0,1,\\dots,M-1$)，其中 $\\Delta x=L/(M-1)$；并设时间层级为 $t^n=n\\,\\Delta t$。定义无量纲参数 $r=\\alpha\\,\\Delta t/\\Delta x^2$。对于绝热边界，使用与 $\\partial u/\\partial x=0$ 在 $x=0$ 和 $x=L$ 处一致的适当离散边界处理来实现零通量。对于固定温度边界，在每个时间步强制执行 $u(0,t)=u_L$ 和 $u(L,t)=u_R$。使用最简单的时间向前、空间中心的相容离散化方法；不要引入任何隐式步骤或高阶模板。计算总热量的离散近似值 $Q^n\\approx\\sum_{j=0}^{M-1}u_j^n\\,\\Delta x$，并比较其在初始时刻和经过预定数量的时间步长后的值。\n\n所有量均为无量纲；无需物理单位。不出现角度，因此也不需要角度单位。如果需要，将任何分数答案表示为小数。\n\n您的程序必须实现所述的 FTCS 格式，并对以下每个测试用例评估总热量是否在规定的容差范围内守恒。守恒性通过总热量的相对变化来判断：\n$$\n\\delta=\\frac{\\left|Q^{\\text{final}}-Q^{\\text{initial}}\\right|}{\\max\\left(\\left|Q^{\\text{initial}}\\right|,\\,\\epsilon\\right)},\n$$\n其中 $\\epsilon$ 是一个小的正数以避免除以零，如果 $\\delta\\leq\\tau$（容差 $\\tau=10^{-10}$），则声明为守恒。\n\n使用以下测试套件，其中 $L=1$ 及指定参数；对于每个用例，运行 $N_t$ 个时间步长，并报告一个布尔值，指示是否在容差范围内满足守恒。\n\n- 测试用例1 (绝热，稳定)：$\\alpha=1$, $L=1$, $M=101$, $r=0.4$, $N_t=200$, $u_0(x)=1+0.5\\cos(2\\pi x)$，绝热 (Neumann) 边界条件 $\\partial u/\\partial x=0$ 在 $x=0$ 和 $x=1$ 处。\n- 测试用例2 (固定温度，稳定)：$\\alpha=1$, $L=1$, $M=101$, $r=0.4$, $N_t=200$, $u_0(x)=\\sin(\\pi x)$，固定温度 (Dirichlet) 边界条件 $u(0,t)=0$ 和 $u(1,t)=0$。\n- 测试用例3 (绝热，稳定性极限)：$\\alpha=1$, $L=1$, $M=21$, $r=0.5$, $N_t=200$, $u_0(x)=1+0.5\\cos(2\\pi x)$，绝热 (Neumann) 边界条件 $\\partial u/\\partial x=0$ 在 $x=0$ 和 $x=1$ 处。\n- 测试用例4 (固定温度，稳定性极限)：$\\alpha=1$, $L=1$, $M=21$, $r=0.5$, $N_t=200$, $u_0(x)=\\sin(\\pi x)$，固定温度 (Dirichlet) 边界条件 $u(0,t)=0$ 和 $u(1,t)=0$。\n\n对于绝热情况，选择初始数据 $u_0(x)=1+0.5\\cos(2\\pi x)$ 以使得在 $x=0$ 和 $x=L$ 处 $\\partial u/\\partial x=0$；对于固定温度情况，选择 $u_0(x)=\\sin(\\pi x)$ 以使得 $u(0,0)=0$ 和 $u(L,0)=0$。\n\n您的程序应生成单行输出，其中包含四个测试用例的布尔结果，格式为逗号分隔的列表，并用方括号括起来，例如 $[{\\tt True},{\\tt False},{\\tt True},{\\tt False}]$。", "solution": "问题要求我们研究一维热传导方程\n$$\n\\frac{\\partial u}{\\partial t}(x,t)=\\alpha\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n在使用显式时间向前中心空间 (FTCS) 有限差分格式进行数值求解时，总热量的守恒性。我们将比较在绝热 (Neumann) 和固定温度 (Dirichlet) 边界条件下的行为。\n\n首先，我们推导 FTCS 格式。求解域为一个空间区间 $x \\in [0, L]$ 和时间 $t \\ge 0$。我们使用均匀网格对该域进行离散化，该网格包含 $M$ 个空间点 $x_j=j\\,\\Delta x$ (其中 $j=0, 1, \\dots, M-1$，$ \\Delta x = L/(M-1)$) 和均匀的时间步长 $t^n=n\\,\\Delta t$。网格点 $(x_j, t^n)$ 处的解记为 $u_j^n$。\n\n时间导数 $\\frac{\\partial u}{\\partial t}$ 使用一阶向前差分近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_j, t^n)} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}.\n$$\n空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心差分近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t^n)} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2}.\n$$\n将这些近似代入热传导方程，得到：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\alpha \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2}.\n$$\n整理以求解下一个时间步的解 $u_j^{n+1}$，我们得到内部网格点 ($j=1, 2, \\dots, M-2$) 的 FTCS 更新规则：\n$$\nu_j^{n+1} = u_j^n + r(u_{j+1}^n - 2u_j^n + u_{j-1}^n),\n$$\n其中 $r = \\frac{\\alpha\\,\\Delta t}{\\Delta x^2}$ 是无量纲稳定性参数。为使此显式格式稳定，我们需要满足 $r \\le 0.5$。\n\n接下来，我们必须处理边界条件。\n\n对于固定温度 (Dirichlet) 边界条件 $u(0,t)=u_L$ 和 $u(L,t)=u_R$，实现非常直接。在每个时间步，我们强制执行：\n$$\nu_0^{n+1} = u_L \\quad \\text{和} \\quad u_{M-1}^{n+1} = u_R.\n$$\n\n对于绝热 (Neumann) 边界条件 $\\frac{\\partial u}{\\partial x}(0,t)=0$ 和 $\\frac{\\partial u}{\\partial x}(L,t)=0$，我们使用“虚拟点”法来保持中心差分格式。\n在左边界 ($x_0=0$)，我们使用以 $j=0$ 为中心的中心差分来离散化零通量条件：\n$$\n\\frac{\\partial u}{\\partial x}\\bigg|_{x_0} \\approx \\frac{u_1^n - u_{-1}^n}{2\\Delta x} = 0 \\implies u_{-1}^n = u_1^n,\n$$\n其中 $u_{-1}^n$ 是位于求解域左侧的一个虚构虚拟点上的值。将此关系代入 $j=0$ 处的通用 FTCS 公式：\n$$\nu_0^{n+1} = u_0^n + r(u_1^n - 2u_0^n + u_{-1}^n) = u_0^n + r(u_1^n - 2u_0^n + u_1^n) = u_0^n + 2r(u_1^n - u_0^n).\n$$\n同样，在右边界 ($x_{M-1}=L$)，我们使用虚拟点 $u_M^n$。零通量条件 $\\frac{\\partial u}{\\partial x}|_{x_{M-1}} \\approx \\frac{u_M^n - u_{M-2}^n}{2\\Delta x} = 0$ 得到 $u_M^n = u_{M-2}^n$。将此代入 $j=M-1$ 处的 FTCS 公式得到 $u_{M-1}^{n+1} = u_{M-1}^n + r(u_M^n - 2u_{M-1}^n + u_{M-2}^n) = u_{M-1}^n + 2r(u_{M-2}^n - u_{M-1}^n)$。这是与 $j=0$ 处规则相对应的对称形式。\n\n理论上，总热量 $Q(t) = \\int_0^L u(x,t)\\,dx$ 随时间演变如下：\n$$\n\\frac{dQ}{dt} = \\frac{d}{dt}\\int_0^L u\\,dx = \\int_0^L \\frac{\\partial u}{\\partial t}\\,dx = \\int_0^L \\alpha\\frac{\\partial^2 u}{\\partial x^2}\\,dx = \\alpha\\left[\\frac{\\partial u}{\\partial x}\\right]_0^L = \\alpha\\left(\\frac{\\partial u}{\\partial x}(L,t) - \\frac{\\partial u}{\\partial x}(0,t)\\right).\n$$\n对于绝热 (Neumann) 边界，右侧项为零，因此热量守恒。对于固定温度 (Dirichlet) 边界，热通量通常不为零，因此热量不守恒。\n\n问题要求检查离散热量积分 $Q^n = \\sum_{j=0}^{M-1} u_j^n \\Delta x$ 的守恒性。这是一个黎曼和近似。\n我们来分析它在单个时间步内的变化，$\\Delta Q^n = Q^{n+1} - Q^n = \\Delta x \\sum_{j=0}^{M-1} (u_j^{n+1} - u_j^n)$。\n$$\n\\sum_{j=0}^{M-1} (u_j^{n+1} - u_j^n) = (u_0^{n+1}-u_0^n) + \\sum_{j=1}^{M-2}(u_j^{n+1}-u_j^n) + (u_{M-1}^{n+1}-u_{M-1}^n).\n$$\n对于 Neumann 情况，代入更新规则：\n$$\n\\sum (u_j^{n+1}-u_j^n) = r\\left[ 2(u_1^n-u_0^n) + \\sum_{j=1}^{M-2}(u_{j+1}^n-2u_j^n+u_{j-1}^n) + 2(u_{M-2}^n-u_{M-1}^n) \\right].\n$$\n求和项是一个差分的裂项和：$\\sum_{j=1}^{M-2} \\left[ (u_{j+1}^n-u_j^n) - (u_j^n-u_{j-1}^n) \\right] = (u_{M-1}^n-u_{M-2}^n) - (u_1^n-u_0^n)$。将此代回，总和为：\n$$\nr\\left[ 2(u_1^n-u_0^n) + (u_{M-1}^n-u_{M-2}^n) - (u_1^n-u_0^n) + 2(u_{M-2}^n-u_{M-1}^n) \\right] = r\\left[ (u_1^n-u_0^n) - (u_{M-1}^n-u_{M-2}^n) \\right].\n$$\n这个量通常不为零。因此，FTCS 格式、Neumann 虚拟点方法以及积分的黎曼和这三者的特定组合并非精确守恒。然而，非守恒项与边界附近的离散一阶导数成正比。由于边界条件是零通量，该项应该很小，量级为 $O(\\Delta x^2)$，因此我们可能预期在指定的数值容差 $\\tau=10^{-10}$ 内守恒是成立的。\n\n对于 Dirichlet 情况，预计热量会流出或流入，导致 $Q^n$ 发生显著变化。\n\n指定的验证测试是计算相对变化 $\\delta = \\frac{|Q^{\\text{final}}-Q^{\\text{initial}}|}{\\max(|Q^{\\text{initial}}|,\\,\\epsilon)}$ 并检查是否 $\\delta \\le \\tau=10^{-10}$。使用一个小的数值 $\\epsilon=10^{-15}$ 以在初始总热量可能为零的情况下避免除以零。\n\n程序的算法如下：\n1. 对于每个测试用例，设置参数：$\\alpha$、$L$、$M$、$r$、$N_t$、初始条件函数和边界条件类型。\n2. 计算派生的网格参数：$\\Delta x = L/(M-1)$ 和 $\\Delta t = r \\Delta x^2 / \\alpha$。\n3. 创建空间网格 $x$ 并用 $u_0(x)$ 初始化解向量 $u$。\n4. 计算并存储初始离散热量 $Q^{\\text{initial}} = \\Delta x \\sum_{j=0}^{M-1} u_j^0$。\n5. 循环 $N_t$ 个时间步。在每个步骤中：\n   a. 将当前解 $u^n$ 存储在一个临时数组中。\n   b. 使用 FTCS 规则计算内部点的下一个解 $u^{n+1}$。\n   c. 根据情况 (Neumann 或 Dirichlet) 应用 $u_0^{n+1}$ 和 $u_{M-1}^{n+1}$ 的边界条件。\n6. 循环结束后，计算最终离散热量 $Q^{\\text{final}} = \\Delta x \\sum_{j=0}^{M-1} u_j^{N_t}$。\n7. 计算相对变化 $\\delta$ 并判断其是否小于或等于容差 $\\tau$。\n8. 报告布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the FTCS scheme for the 1D heat equation and verifies\n    the conservation of the total heat integral for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1: Insulating, stable\n        {'alpha': 1.0, 'M': 101, 'r': 0.4, 'Nt': 200, \n         'u0_func': lambda x: 1.0 + 0.5 * np.cos(2 * np.pi * x), \n         'bc_type': 'Neumann', 'u_L': None, 'u_R': None},\n        # Case 2: Fixed temperature, stable\n        {'alpha': 1.0, 'M': 101, 'r': 0.4, 'Nt': 200, \n         'u0_func': lambda x: np.sin(np.pi * x), \n         'bc_type': 'Dirichlet', 'u_L': 0.0, 'u_R': 0.0},\n        # Case 3: Insulating, stability limit\n        {'alpha': 1.0, 'M': 21, 'r': 0.5, 'Nt': 200, \n         'u0_func': lambda x: 1.0 + 0.5 * np.cos(2 * np.pi * x), \n         'bc_type': 'Neumann', 'u_L': None, 'u_R': None},\n        # Case 4: Fixed temperature, stability limit\n        {'alpha': 1.0, 'M': 21, 'r': 0.5, 'Nt': 200, \n         'u0_func': lambda x: np.sin(np.pi * x), \n         'bc_type': 'Dirichlet', 'u_L': 0.0, 'u_R': 0.0},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Parameters for the current simulation\n        L = 1.0\n        alpha = case['alpha']\n        M = case['M']\n        r = case['r']\n        Nt = case['Nt']\n        u0_func = case['u0_func']\n        bc_type = case['bc_type']\n        u_L = case['u_L']\n        u_R = case['u_R']\n\n        # Grid parameters\n        dx = L / (M - 1)\n        dt = r * dx**2 / alpha\n\n        # Spatial grid\n        x = np.linspace(0, L, M)\n\n        # Initial condition\n        u = u0_func(x)\n\n        # Discrete total heat integral (using Riemann sum as specified)\n        Q_initial = np.sum(u) * dx\n        \n        # Time evolution\n        for _ in range(Nt):\n            u_prev = u.copy()\n            \n            # Update interior points\n            for j in range(1, M - 1):\n                u[j] = u_prev[j] + r * (u_prev[j+1] - 2 * u_prev[j] + u_prev[j-1])\n            \n            # Apply boundary conditions\n            if bc_type == 'Neumann':\n                # Zero-flux BC using ghost points\n                # at j=0\n                u[0] = u_prev[0] + 2 * r * (u_prev[1] - u_prev[0])\n                # at j=M-1\n                u[M-1] = u_prev[M-1] + 2 * r * (u_prev[M-2] - u_prev[M-1])\n            elif bc_type == 'Dirichlet':\n                # Fixed-temperature BC\n                u[0] = u_L\n                u[M-1] = u_R\n        \n        # Final total heat\n        Q_final = np.sum(u) * dx\n\n        # Check for conservation\n        tau = 1e-10  # Tolerance\n        epsilon = 1e-15 # Small number to avoid division by zero\n        \n        q_init_abs = np.abs(Q_initial)\n        denominator = max(q_init_abs, epsilon)\n        \n        delta = np.abs(Q_final - Q_initial) / denominator\n        \n        is_conserved = delta = tau\n        results.append(is_conserved)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3227077"}]}