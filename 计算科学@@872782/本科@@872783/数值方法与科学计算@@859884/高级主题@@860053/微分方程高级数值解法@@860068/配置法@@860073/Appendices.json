{"hands_on_practices": [{"introduction": "第一个练习将向您介绍配置法的基本工作流程。我们将通过构造一个满足边界条件并包含一个未知参数的试函数来求解一个简单的线性边值问题（BVP）。通过强制这个近似解在单个点（即“配置点”）上满足微分方程，我们可以确定该参数并找到我们的近似解。这个练习阐明了试函数和残差的核心概念。[@problem_id:2159883]", "problem": "一位工程师正在对一根单位长度、侧向绝热的薄杆的稳态温度分布 $y(x)$ 进行建模。该杆受到一个与位置 $x$ 的平方成正比的内部热源作用，并且其两端温度是固定的。该系统的控制微分方程是一个二阶线性非齐次边值问题（BVP）：\n\n$$y''(x) - y(x) = -x^2, \\quad \\text{for } x \\in [0, 1]$$\n\n边界条件为：\n\n$$y(0) = 0, \\quad y(1) = 2$$\n\n为了找到一个近似解，采用了配置法。提出了一个单参数试验函数 $\\tilde{y}(x)$，其构造旨在自动满足边界条件：\n\n$$\\tilde{y}(x) = 2x + c \\cdot x(1-x)$$\n\n其中 $c$ 是一个待确定的未知常数系数。\n\n你的任务是使用位于 $x_c = 1/2$ 的单个配置点来确定参数 $c$ 的值。然后，用这个 $c$ 值，计算绝对残差的最大值 $\\max_{x \\in [0, 1]} |R(x)|$，其中残差函数 $R(x)$ 定义为 $R(x) = \\tilde{y}''(x) - \\tilde{y}(x) + x^2$。\n\n将你的最终答案表示为一个实数，四舍五入到三位有效数字。", "solution": "试验函数为 $\\tilde{y}(x) = 2x + c\\,x(1-x) = (2+c)x - c x^{2}$，它满足边界条件 $\\tilde{y}(0)=0$ 和 $\\tilde{y}(1)=2$。其导数为\n$$\n\\tilde{y}'(x) = (2+c) - 2c x, \\qquad \\tilde{y}''(x) = -2c.\n$$\n残差由 $R(x) = \\tilde{y}''(x) - \\tilde{y}(x) + x^{2}$ 定义，因此\n$$\nR(x) = -2c - \\big[(2+c)x - c x^{2}\\big] + x^{2} = -2c - (2+c)x + (c+1)x^{2}.\n$$\n使用在 $x_{c}=\\frac{1}{2}$ 处的配置条件，施加 $R\\!\\left(\\frac{1}{2}\\right)=0$：\n$$\n-2c - \\frac{2+c}{2} + \\frac{c+1}{4} = 0.\n$$\n通分分母为 $4$，得到\n$$\n\\frac{-8c - 2(2+c) + (c+1)}{4} = \\frac{-8c - 4 - 2c + c + 1}{4} = \\frac{-9c - 3}{4} = 0,\n$$\n所以 $-9c - 3 = 0$，因此 $c = -\\frac{1}{3}$。\n\n将 $c=-\\frac{1}{3}$ 代入 $R(x)$：\n$$\nR(x) = -2\\!\\left(-\\frac{1}{3}\\right) - \\left(2 - \\frac{1}{3}\\right)x + \\left(1 - \\frac{1}{3}\\right)x^{2} = \\frac{2}{3} - \\frac{5}{3}x + \\frac{2}{3}x^{2} = \\frac{1}{3}\\big(2 - 5x + 2x^{2}\\big).\n$$\n令 $q(x) = 2 - 5x + 2x^{2}$。则 $R(x) = \\frac{1}{3}q(x)$。函数 $q$ 是一个二次函数，其导数 $q'(x) = -5 + 4x$ 在 $[0,1]$ 上为负，所以 $q$ 在 $[0,1]$ 上单调递减。此外，$q\\!\\left(\\frac{1}{2}\\right)=0$（与配置条件一致）。因此，在 $[0,\\frac{1}{2}]$ 上，$q \\ge 0$ 且 $|q|=q$ 从 $q(0)=2$ 递减到 $0$，而在 $[\\frac{1}{2},1]$ 上，$q \\le 0$ 且 $|q|=-q$ 从 $0$ 递增到 $|q(1)|=1$。因此\n$$\n\\max_{x \\in [0,1]} |q(x)| = 2 \\quad \\Rightarrow \\quad \\max_{x \\in [0,1]} |R(x)| = \\frac{1}{3} \\cdot 2 = \\frac{2}{3}.\n$$\n四舍五入到三位有效数字，结果是 $0.667$。", "answer": "$$\\boxed{0.667}$$", "id": "2159883"}, {"introduction": "在上一个例子的基础上，我们现在将配置法应用于一个非线性边值问题。您将看到，其求解过程非常相似，但微分方程中的非线性项导致了一个关于未知系数的非线性代数方程，而不是线性方程。这个练习突出了该方法在处理更复杂的非线性物理问题时的通用性。[@problem_id:2159872]", "problem": "配置法是一种求解微分方程近似解的数值方法。该方法包括假设一个带有未知参数的试探解形式，然后通过强制该试探解在定义域内的一组离散点（称为配置点）上满足微分方程来确定这些参数。\n\n考虑以下非线性二阶边值问题：\n$$ y''(x) + y(x)^2 = 0, \\quad \\text{for } x \\in [0, 1] $$\n其边界条件为 $y(0) = 0$ 和 $y(1) = 1$。\n\n提出了一个近似解，记为 $\\tilde{y}(x)$，其形式为：\n$$ \\tilde{y}(x) = x + c x(1-x) $$\n其中 $c$ 是一个待定系数。选择此形式是因为对于任何 $c$ 值，它都已满足边界条件。\n\n为了使用配置法求出 $c$ 的值，我们定义一个残差函数 $R(x,c) = \\tilde{y}''(x) + (\\tilde{y}(x))^2$。然后我们强制要求残差在某个特定的配置点处为零。对于本问题，使用位于 $x_1 = 1/2$ 的单个配置点。\n\n确定残差在此配置点处的值 $R(1/2, c)$ 的表达式。您的最终答案应该是一个关于系数 $c$ 的代数表达式。", "solution": "给定边值问题 $y''(x) + y(x)^{2} = 0$，其边界条件为 $y(0)=0$ 和 $y(1)=1$，以及试探解函数 $\\tilde{y}(x) = x + c x(1-x)$。该试探解函数对于任意 $c$ 都满足边界条件，因为 $\\tilde{y}(0)=0$ 且 $\\tilde{y}(1)=1$。\n\n计算 $\\tilde{y}$ 的导数：\n$$\n\\tilde{y}(x) = x + c x(1-x),\n$$\n$$\n\\tilde{y}'(x) = 1 + c(1 - 2x),\n$$\n$$\n\\tilde{y}''(x) = -2c.\n$$\n\n残差定义为 $R(x,c) = \\tilde{y}''(x) + (\\tilde{y}(x))^{2}$，因此\n$$\nR(x,c) = -2c + \\left(x + c x(1-x)\\right)^{2}.\n$$\n在配置点 $x = \\frac{1}{2}$ 处求值。首先计算\n$$\n\\tilde{y}\\!\\left(\\frac{1}{2}\\right) = \\frac{1}{2} + c \\cdot \\frac{1}{2}\\left(1 - \\frac{1}{2}\\right) = \\frac{1}{2} + \\frac{c}{4},\n$$\n所以\n$$\n\\left(\\tilde{y}\\!\\left(\\frac{1}{2}\\right)\\right)^{2} = \\left(\\frac{1}{2} + \\frac{c}{4}\\right)^{2} = \\frac{1}{4} + \\frac{c}{4} + \\frac{c^{2}}{16}.\n$$\n因此，\n$$\nR\\!\\left(\\frac{1}{2}, c\\right) = -2c + \\frac{1}{4} + \\frac{c}{4} + \\frac{c^{2}}{16} = \\frac{1}{16}c^{2} - \\frac{7}{4}c + \\frac{1}{4}.\n$$\n这就是在配置点处所求的残差。", "answer": "$$\\boxed{\\frac{1}{16}c^{2} - \\frac{7}{4}c + \\frac{1}{4}}$$", "id": "2159872"}, {"introduction": "这个高级实践展示了当配置法升级为伪谱法时所能发挥的全部威力。我们将通过求解哈密顿-雅可比-贝尔曼（HJB）方程——一个非线性常微分方程——来解决一个来自最优控制理论的问题。这次我们不再使用单个参数，而是用一个高次多项式来近似解，并求解其在多个配置点（切比雪夫节点）上的值。这将导出一个我们用牛顿法求解的非线性代数方程组。这个问题展示了配置法如何作为解决科学与工程中复杂问题的强大工具。[@problem_id:3214244]", "problem": "考虑一个确定性最优控制系统，其中标量状态 $x(t)$ 根据控制 $u(t)$ 演化，其动态方程为 $dx/dt = u(t)$。需要最小化的性能指标是无限时域积分 $J = \\int_0^{\\infty} \\left( \\tfrac{1}{2} x(t)^2 + \\tfrac{1}{2} \\alpha u(t)^2 \\right) \\, dt$，其中 $\\alpha  0$ 是一个给定的标量，用于惩罚控制努力。该设置可作为垂直上升控制的一个简化模型，其中 $x(t)$ 可以代表一个类似速度的状态，$u(t)$ 代表一个类似推力的控制；对 $u(t)$ 的二次惩罚项起到了一个适用于数值分析的燃料消耗的光滑替代物的作用。\n\n从动态规划原理出发，可以通过将瞬时成本的最小值加上值函数 $V$ 沿动态方向的方向导数设为零，来构建值函数 $V(x)$ 的稳态 Hamilton-Jacobi-Bellman (HJB) 方程。本问题旨在使用基于 Chebyshev-Gauss-Lobatto 点的全局配置法，在有限对称域 $[-L,L]$ 上近似值函数 $V(x)$，并通过求解由此产生的非线性代数方程组来计算该近似解。该近似应在配置点上逐点强制满足 HJB 方程，同时施加确保解唯一的相容性条件，而不在问题陈述本身引入任何捷径公式。\n\n您必须推导稳态 HJB 方程，然后使用映射到此域的 $N+1$ 个 Chebyshev-Gauss-Lobatto 节点，为 $[-L,L]$ 上的 $V(x)$ 构建一个配置近似。使用 $V$ 在这些配置点上的节点值作为未知数。在除中心点外的所有配置点上强制满足 HJB 方程，并在中心点施加 $V(0)=0$ 以固定 $V(x)$ 中的可加常数。使用合适的迭代方法求解得到的非线性系统以获得节点未知数，该方法不依赖于指定库之外的外部库。计算出节点解后，在 $[-L,L]$ 内一个包含 $200$ 个等距点的精细验证网格上，评估由节点值定义的插值多项式，以估算相对于通过 HJB 方程第一性原理推导得到的精确值函数而言的最大绝对近似误差。\n\n您的程序必须以数学上合理的方式实现以下步骤：\n1. 从第一性原理推导 $V(x)$ 的稳态 Hamilton-Jacobi-Bellman (HJB) 方程，并用它来刻画最优控制 $u^*(x)$ 以及 $V$ 必须满足的结果方程。\n2. 在 $[-1,1]$ 上构造 Chebyshev-Gauss-Lobatto 节点 $s_k$，将它们映射到物理域 $x_k = L s_k$，并构建与这些 $s$ 坐标系下的节点相关的谱微分矩阵 $D$。使用链式法则将关于 $s$ 的导数转换为关于 $x$ 的导数。\n3. 建立非线性配置方程组，在除中心节点 $s=0$ 外的所有节点上强制满足 HJB 方程，并在中心节点上强制 $V(0)=0$ 以固定可加常数。\n4. 使用牛顿类迭代法求解该非线性系统以获得 $V$ 的节点值，其中雅可比矩阵应根据残差通过微分矩阵对节点值的依赖关系来正确构造。\n5. 使用根据 Chebyshev-Gauss-Lobatto 节点及其相关权重构建的重心插值法，在验证网格上评估近似的 $V(x)$，并计算其与通过解析求解 HJB 方程得到的精确 $V(x)$ 之间的最大绝对误差。\n6. 按下文规定，输出每个测试用例的最大绝对误差。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是一个浮点数，等于配置近似解与精确值函数在验证网格上的最大绝对误差。\n\n使用以下涵盖不同参数范围的测试套件：\n- 测试用例 1 (理想情况): $\\alpha = 1$, $L = 1$, $N = 10$。\n- 测试用例 2 (控制惩罚项变更): $\\alpha = 4$, $L = 1$, $N = 8$。\n- 测试用例 3 (更大定义域): $\\alpha = 9$, $L = 2$, $N = 12$。\n\n所有量均为无量纲，因此不需要物理单位。不涉及角度。不涉及百分比。您的程序应以“[r1,r2,r3]”的格式精确输出一行，其中 $r_i$ 是三个测试用例按上述顺序列出的最大绝对误差（浮点数）。", "solution": "该问题旨在使用全局配置法，为确定性最优控制系统的值函数 $V(x)$ 寻找一个近似解。该系统由状态动力学 $\\frac{dx}{dt} = u(t)$ 控制，目标是最小化无限时域性能指标 $J = \\int_0^{\\infty} \\left( \\tfrac{1}{2} x(t)^2 + \\tfrac{1}{2} \\alpha u(t)^2 \\right) dt$，其中 $\\alpha  0$。\n\n求解过程涉及推导稳态 Hamilton-Jacobi-Bellman (HJB) 方程，使用 Chebyshev 配置法对其进行离散化，求解所得的非线性代数方程组，并对照精确解析解评估数值解的准确性。\n\n### 步骤 1：Hamilton-Jacobi-Bellman (HJB) 方程的推导与解析解\n\n值函数 $V(x)$ 代表从状态 $x$ 出发的最小可能成本。其定义为：\n$$\nV(x) = \\min_{u(t)} \\int_{0}^{\\infty} \\left( \\tfrac{1}{2} x(t)^2 + \\tfrac{1}{2} \\alpha u(t)^2 \\right) dt, \\quad \\text{subject to } x(0) = x \\text{ and } \\frac{dx}{dt} = u(t).\n$$\n对于无限时域、时不变问题，动态规划原理可导出稳态 Hamilton-Jacobi-Bellman (HJB) 方程。该原理指出，对于任意小的时间间隔 $\\Delta t$，从状态 $x$ 出发的最优成本是在 $\\Delta t$ 内产生的成本与从后续状态 $x(t+\\Delta t)$ 出发的最优成本之和的最小值。在极限 $\\Delta t \\to 0$ 时，可得：\n$$\n0 = \\min_{u} \\left[ L(x, u) + \\nabla V(x) \\cdot \\frac{dx}{dt} \\right]\n$$\n其中 $L(x, u) = \\tfrac{1}{2} x^2 + \\tfrac{1}{2} \\alpha u^2$ 是拉格朗日量，$\\nabla V(x)$ 是值函数的梯度（对于标量状态，即为导数 $V'(x)$），且 $\\frac{dx}{dt} = u$。将这些代入 HJB 方程可得：\n$$\n0 = \\min_{u} \\left[ \\tfrac{1}{2} x^2 + \\tfrac{1}{2} \\alpha u^2 + V'(x)u \\right]\n$$\n为找到使括号内表达式（哈密顿量）最小化的控制 $u$，我们对 $u$ 求偏导并令其为零：\n$$\n\\frac{\\partial}{\\partial u} \\left[ \\tfrac{1}{2} x^2 + \\tfrac{1}{2} \\alpha u^2 + V'(x)u \\right] = \\alpha u + V'(x) = 0\n$$\n这给出了最优控制律 $u^*(x)$，其为状态和值函数导数的函数：\n$$\nu^*(x) = -\\frac{1}{\\alpha} V'(x)\n$$\n将此最优控制代回 HJB 方程，得到一个关于 $V(x)$ 的非线性常微分方程：\n$$\n0 = \\tfrac{1}{2} x^2 + \\tfrac{1}{2} \\alpha \\left(-\\frac{1}{\\alpha} V'(x)\\right)^2 + V'(x) \\left(-\\frac{1}{\\alpha} V'(x)\\right)\n$$\n$$\n0 = \\tfrac{1}{2} x^2 + \\frac{1}{2\\alpha} (V'(x))^2 - \\frac{1}{\\alpha} (V'(x))^2\n$$\n$$\n0 = \\tfrac{1}{2} x^2 - \\frac{1}{2\\alpha} (V'(x))^2\n$$\n整理后得到该问题的稳态 HJB 方程的最终形式：\n$$\n(V'(x))^2 = \\alpha x^2\n$$\n这是一个标准的线性二次调节器 (LQR) 问题，已知其值函数为二次型。我们寻求形式为 $V(x) = \\frac{1}{2} P x^2$ 的解，其中 $P$ 是一个正常数。条件 $V(0)=0$ 自然满足。其导数为 $V'(x) = Px$。将此代入 HJB 方程可得：\n$$\n(Px)^2 = \\alpha x^2 \\implies P^2x^2 = \\alpha x^2\n$$\n此式必须对所有 $x$ 成立，因此我们必须有 $P^2 = \\alpha$。由于成本必须为非负，值函数 $V(x)$ 必须是正定的，这意味着 $P  0$。因此，$P = \\sqrt{\\alpha}$。值函数的精确解析解为：\n$$\nV_{\\text{exact}}(x) = \\frac{\\sqrt{\\alpha}}{2} x^2\n$$\n\n### 步骤 2：Chebyshev 配置离散化\n\n我们在域 $[-L, L]$ 上用一个 $N$ 次多项式 $V_N(x)$ 来近似 $V(x)$，该多项式在 $N+1$ 个配置点上对函数进行插值。我们使用 Chebyshev-Gauss-Lobatto (CGL) 节点，它们是 $N$ 次 Chebyshev 多项式的极值点。\n在规范区间 $s \\in [-1, 1]$ 内的 CGL 节点由下式给出：\n$$\ns_k = \\cos\\left(\\frac{k\\pi}{N}\\right), \\quad k = 0, 1, \\dots, N\n$$\n通过仿射变换 $x = Ls$，这些节点被映射到物理域 $x \\in [-L, L]$：\n$$\nx_k = Ls_k = L\\cos\\left(\\frac{k\\pi}{N}\\right)\n$$\n设 $\\vec{V} = [V_0, V_1, \\dots, V_N]^T$ 是函数在这些节点上的未知值向量，即 $V_k = V_N(x_k)$。插值多项式 $V_N(s)$ 在节点 $s_k$ 处的导数可以通过矩阵-向量乘法计算，$\\vec{V}'_s = D \\vec{V}$，其中 $D$ 是 $(N+1) \\times (N+1)$ 的 Chebyshev 谱微分矩阵。其元素为：\n$$\nD_{ij} = \\begin{cases} \\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{s_i - s_j},  i \\neq j \\\\ -\\frac{s_j}{2(1-s_j^2)},  i=j \\in \\{1,\\dots,N-1\\} \\\\ \\frac{2N^2+1}{6},  i=j=0 \\\\ -\\frac{2N^2+1}{6},  i=j=N \\end{cases}\n$$\n其中 $c_k = 2$ 当 $k=0, N$ 时成立，否则 $c_k=1$。\n利用链式法则，关于 $x$ 的导数与关于 $s$ 的导数通过 $\\frac{dV_N}{dx} = \\frac{dV_N}{ds} \\frac{ds}{dx} = \\frac{1}{L} \\frac{dV_N}{ds}$ 相关联。因此，在物理节点 $x_k$ 处的导数向量，记为 $\\vec{V}'$，是：\n$$\n\\vec{V}' = \\frac{1}{L} D \\vec{V}\n$$\n\n### 步骤 3：非线性代数方程组的构建\n\n我们在配置点上强制满足离散化的 HJB 方程。问题规定，对于偶数 $N$，我们使用中心节点 $x_{N/2} = L\\cos(\\frac{(N/2)\\pi}{N}) = L\\cos(\\pi/2) = 0$ 来强制施加条件 $V(0)=0$。在所有其他节点上，我们强制满足 HJB 方程。这为 $N+1$ 个未知数 $V_k$ 提供了 $N+1$ 个方程。\n\n该方程组由一个大小为 $N+1$ 的残差向量 $\\vec{R}(\\vec{V})$ 定义：\n$$\nR_k(\\vec{V}) = \\begin{cases} (V'_k)^2 - \\alpha x_k^2 = 0,  k \\in \\{0, \\dots, N\\} \\setminus \\{N/2\\} \\\\ V_k - 0 = 0,  k=N/2 \\end{cases}\n$$\n其中 $V'_k$ 是向量 $\\vec{V}' = \\frac{1}{L}D\\vec{V}$ 的第 $k$ 个分量。\n\n### 步骤 4：用牛顿法求解方程组\n\n非线性系统 $\\vec{R}(\\vec{V}) = \\vec{0}$ 使用牛顿法求解。从一个初始猜测 $\\vec{V}^{(0)}$ 开始，我们使用以下公式迭代地优化解：\n$$\n\\vec{V}^{(m+1)} = \\vec{V}^{(m)} + \\Delta\\vec{V}\n$$\n其中更新量 $\\Delta\\vec{V}$ 通过求解线性系统得到：\n$$\nJ(\\vec{V}^{(m)}) \\Delta\\vec{V} = -\\vec{R}(\\vec{V}^{(m)})\n$$\n这里，$J$ 是残差向量 $\\vec{R}$ 相对于未知数 $\\vec{V}$ 的雅可比矩阵，其元素为 $J_{ij} = \\frac{\\partial R_i}{\\partial V_j}$。\n对于 $i \\neq N/2$ 且 $R_i = (V'_i)^2 - \\alpha x_i^2$ 的行：\n$$\nJ_{ij} = \\frac{\\partial}{\\partial V_j} \\left( \\left(\\frac{1}{L}\\sum_{l=0}^N D_{il}V_l\\right)^2 \\right) = 2 V'_i \\cdot \\frac{\\partial V'_i}{\\partial V_j} = 2 V'_i \\cdot \\frac{1}{L}D_{ij} = \\frac{2}{L} V'_i D_{ij}\n$$\n对于 $i = N/2$ 且 $R_{N/2} = V_{N/2}$ 的行：\n$$\nJ_{N/2, j} = \\frac{\\partial V_{N/2}}{\\partial V_j} = \\delta_{j, N/2} \\quad (\\text{克罗内克δ函数})\n$$\n迭代从一个好的初始猜测开始，为此我们可以使用精确解的节点值：$V^{(0)}_k = \\frac{\\sqrt{\\alpha}}{2} x_k^2$。迭代持续进行，直到残差向量的范数 `||\\vec{R}||` 降至指定的容差以下。\n\n### 步骤 5：误差评估与插值\n\n一旦计算出节点值 $\\vec{V}$，就在 $[-L, L]$ 上一个包含 $200$ 个等距点的精细验证网格上评估多项式近似 $V_N(x)$。为保证数值稳定性，此评估使用重心插值公式（第二形式）进行：\n$$\nV_N(x) = \\frac{\\displaystyle\\sum_{k=0}^{N} \\frac{w_k}{x - x_k} V_k}{\\displaystyle\\sum_{k=0}^{N} \\frac{w_k}{x - x_k}}\n$$\n其中 CGL 节点的重心权重 $w_k$ 由 $w_k = (-1)^k \\delta_k$ 给出，其中 $\\delta_0 = \\delta_N = 1/2$ 且对于 $k=1, \\dots, N-1$ 有 $\\delta_k = 1$。\n然后通过比较插值 $V_N(x)$与验证网格上每个点的精确值 $V_{\\text{exact}}(x)$ 来计算最大绝对误差：\n$$\n\\text{Error} = \\max_{x \\in \\text{grid}} |V_N(x) - V_{\\text{exact}}(x)|\n$$", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the optimal control problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # (alpha, L, N)\n        (1.0, 1.0, 10),\n        (4.0, 1.0, 8),\n        (9.0, 2.0, 12),\n    ]\n\n    results = []\n    for alpha, L, N in test_cases:\n        error = solve_hjb_collocation(alpha, L, N)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_hjb_collocation(alpha, L, N):\n    \"\"\"\n    Solves the HJB equation using Chebyshev collocation for a given set of parameters.\n\n    Args:\n        alpha (float): Control penalty parameter.\n        L (float): Half-width of the symmetric domain [-L, L].\n        N (int): Degree of the Chebyshev polynomial, N+1 nodes. N must be even.\n\n    Returns:\n        float: The maximum absolute error on the verification grid.\n    \"\"\"\n    if N % 2 != 0:\n        raise ValueError(\"N must be even for a central node at 0.\")\n\n    # 1. Setup grid and differentiation matrix\n    k = np.arange(N + 1)\n    s_nodes = np.cos(k * np.pi / N)  # CGL nodes in [-1, 1], ordered from 1 down to -1\n    x_nodes = L * s_nodes  # Physical nodes in [-L, L]\n\n    # Chebyshev differentiation matrix D in s-space\n    D = np.zeros((N + 1, N + 1))\n    c = np.ones(N + 1)\n    c[0], c[N] = 2.0, 2.0\n\n    for i in range(N + 1):\n        for j in range(N + 1):\n            if i == j:\n                if i == 0:\n                    D[i, j] = (2 * N**2 + 1) / 6.0\n                elif i == N:\n                    D[i, j] = -(2 * N**2 + 1) / 6.0\n                else:\n                    D[i, j] = -s_nodes[j] / (2.0 * (1.0 - s_nodes[j]**2))\n            else:\n                D[i, j] = (c[i] / c[j]) * ((-1)**(i + j)) / (s_nodes[i] - s_nodes[j])\n\n    # 2. Newton's method to solve for the nodal values V\n    # Initial guess for V from the analytical solution form\n    V = (np.sqrt(alpha) / 2.0) * x_nodes**2\n\n    k_center = N // 2\n    \n    max_iter = 15\n    tolerance = 1e-13\n\n    for _ in range(max_iter):\n        V_prime = (1.0 / L) * (D @ V)\n\n        # Build residual vector R\n        R = np.zeros(N + 1)\n        non_center_indices = np.arange(N + 1) != k_center\n        R[non_center_indices] = V_prime[non_center_indices]**2 - alpha * x_nodes[non_center_indices]**2\n        R[k_center] = V[k_center] - 0.0\n\n        if np.linalg.norm(R)  tolerance:\n            break\n\n        # Build Jacobian matrix J\n        J = np.zeros((N + 1, N + 1))\n        for i in range(N + 1):\n            if i == k_center:\n                J[i, k_center] = 1.0\n            else:\n                J[i, :] = (2.0 / L) * V_prime[i] * D[i, :]\n        \n        # Solve linear system for the update step dV and update V\n        try:\n            dV = np.linalg.solve(J, -R)\n            V += dV\n        except np.linalg.LinAlgError:\n            # If Jacobian is singular, break. The solution might be good enough.\n            break\n\n    # 3. Evaluate error on a fine grid\n    V_exact_func = lambda x, a: (np.sqrt(a) / 2.0) * x**2\n\n    x_verif = np.linspace(-L, L, 200)\n\n    # Barycentric interpolation weights\n    w = (-1.0)**np.arange(N + 1)\n    w[0] /= 2.0\n    w[N] /= 2.0\n\n    # Evaluate numerical solution on verification grid using barycentric formula\n    V_num = np.zeros_like(x_verif)\n    for i, xv in enumerate(x_verif):\n        # Check if xv is very close to a node to avoid division by zero\n        match_indices = np.where(np.isclose(xv, x_nodes))[0]\n        if len(match_indices)  0:\n            V_num[i] = V[match_indices[0]]\n        else:\n            terms = w / (xv - x_nodes)\n            V_num[i] = np.sum(terms * V) / np.sum(terms)\n\n    # Compute V_exact on verification grid and calculate max absolute error\n    V_exact_vals = V_exact_func(x_verif, alpha)\n    max_error = np.max(np.abs(V_num - V_exact_vals))\n\n    return max_error\n\nsolve()\n```", "id": "3214244"}]}