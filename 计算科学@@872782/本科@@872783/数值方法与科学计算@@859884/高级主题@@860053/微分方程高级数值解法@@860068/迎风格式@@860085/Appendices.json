{"hands_on_practices": [{"introduction": "理论联系实际是掌握数值方法的最佳途径。本节的第一个动手实践将指导你实现最基础的一阶迎风格式，用于求解线性平流方程。通过模拟一个急剧变化的阶跃函数 ([@problem_id:2448567]) 的传播，你将能直观地观察到该格式的关键特性，特别是它在处理不连续问题时所引入的数值耗散现象。这是理解更高级格式的性能和设计思想的必要起点。", "problem": "考虑一个标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数，\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0,\\quad x \\in [x_{\\min},x_{\\max}],\\ t \\ge 0,\n$$\n初始条件由 Heaviside 阶跃函数给出\n$$\nu(x,0) = H(x - x_0),\\quad H(\\xi) = \\begin{cases}\n1, & \\xi \\ge 0,\\\\\n0, & \\xi < 0.\n\\end{cases}\n$$\n施加与初始数据的远场状态一致的流入边界条件：如果 $a > 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\min},t)=0$；如果 $a < 0$，则对所有 $t \\ge 0$ 强制 $u(x_{\\max},t)=1$。所有量纲均为无量纲。\n\n在 $[x_{\\min},x_{\\max}]$ 上的一个包含 $N$ 个点的均匀空间网格上，将解在时间上推进到最终时刻 $T$。时间步长 $\\Delta t$ 的选择应满足指定的 Courant–Friedrichs–Lewy (CFL) 数 $C$，其中\n$$\nC = \\frac{|a|\\,\\Delta t}{\\Delta x},\\quad \\Delta x = \\frac{x_{\\max} - x_{\\min}}{N-1}.\n$$\n使用与 $a$ 的符号相符的一阶迎风离散格式。对于下方的每个测试用例，计算在时刻 $T$ 的离散 $\\ell^1$ 误差，其定义为\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x,\n$$\n其中 $x_i$ 是网格点，$u_i^{\\text{num}}(T)$ 是在时刻 $T$ 的数值解，解析解是平移后的阶跃函数\n$$\nu^{\\text{exact}}(x,T) = H\\!\\left( x - (x_0 + a\\,T) \\right),\n$$\n对于下面给出的时间和参数，该解析解是有效的，因为平流带来的间断点严格保持在区间 $[x_{\\min},x_{\\max}]$ 内部，并且不与边界相互作用。\n\n测试套件（每个测试用例是一个元组 $(a,x_{\\min},x_{\\max},x_0,N,T,C)$）：\n- 测试 1：$(1.0,\\,0.0,\\,1.0,\\,0.25,\\,401,\\,0.2,\\,0.5)$。\n- 测试 2：$(-0.7,\\,0.0,\\,1.0,\\,0.8,\\,401,\\,0.15,\\,0.8)$。\n- 测试 3：$(1.0,\\,0.0,\\,1.0,\\,0.3,\\,201,\\,0.3,\\,1.0)$。\n\n你的程序必须按所列顺序计算每个测试的 $E_1$，并生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个数字四舍五入到六位小数（例如，$[0.123456,0.000000,1.234568]$）。", "solution": "该问题是有效的，因为它具有科学依据、是适定的且客观的。它提出了一个计算物理学中的标准任务：使用一阶迎风格式求解线性平流方程并评估数值误差。所有参数和条件都已明确定义。\n\n控制方程是标量场 $u(x,t)$ 的一维线性平流方程，其平流速度 $a$ 为常数：\n$$\n\\partial_t u(x,t) + a\\,\\partial_x u(x,t) = 0\n$$\n为了数值求解该方程，我们对时空域进行离散化。空间域 $[x_{\\min}, x_{\\max}]$ 被划分为一个包含 $N$ 个点的均匀网格，$x_i = x_{\\min} + i\\Delta x$，$i=0, 1, \\dots, N-1$，其中网格间距为 $\\Delta x = (x_{\\max} - x_{\\min}) / (N-1)$。时间以离散步长推进，我们将 $u(x_i, t^n)$ 的数值近似值记为 $u_i^n$。\n\n时间导数 $\\partial_t u$ 使用一阶向前差分（前向欧拉法）进行近似：\n$$\n\\partial_t u(x_i, t^n) \\approx \\frac{u_i^{n+1} - u_i^n}{\\Delta t}\n$$\n一阶迎风格式使用单边有限差分来近似空间导数 $\\partial_x u$。单边模板的选择取决于信息传播的方向，该方向由平流速度 $a$ 的符号决定。这确保了数值方法从“迎风”方向提取信息，这是双曲型求解器稳定性的一个关键属性。\n\n情况 1：$a > 0$\n信息从左向右（沿 $x$ 正方向）传播。在 $x_i$ 处的空间导数使用后向差分进行近似，这涉及到迎风点 $x_{i-1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n$$\n将这些离散近似值代入偏微分方程，得到更新规则：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_i^n - u_{i-1}^n}{\\Delta x} = 0\n$$\n求解下一个时间步的解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_i^n - u_{i-1}^n) = u_i^n - C (u_i^n - u_{i-1}^n)\n$$\n其中 $C = \\frac{a \\Delta t}{\\Delta x}$ 是 Courant–Friedrichs–Lewy (CFL) 数，因为 $a>0$。该格式应用于 $i=1, \\dots, N-1$。\n\n情况 2：$a < 0$\n信息从右向左（沿 $x$ 负方向）传播。空间导数使用前向差分进行近似，这涉及到迎风点 $x_{i+1}$：\n$$\n\\partial_x u(x_i, t^n) \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n$$\n相应的更新规则是：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a \\frac{u_{i+1}^n - u_i^n}{\\Delta x} = 0\n$$\n求解 $u_i^{n+1}$：\n$$\nu_i^{n+1} = u_i^n - \\frac{a \\Delta t}{\\Delta x} (u_{i+1}^n - u_i^n) = u_i^n + C (u_{i+1}^n - u_i^n)\n$$\n这里，CFL 数定义为 $C = \\frac{|a| \\Delta t}{\\Delta x} = \\frac{-a \\Delta t}{\\Delta x}$，这意味着 $\\frac{a \\Delta t}{\\Delta x} = -C$。该格式应用于 $i=0, \\dots, N-2$。\n\n如果满足 CFL 条件 $C \\le 1$，则该显式时间步进格式的稳定性得到保证。所有提供的测试用例都满足此条件。\n\n模拟过程如下：\n1.  **初始化**：对于每个测试用例 $(a, x_{\\min}, x_{\\max}, x_0, N, T, C)$，计算网格间距 $\\Delta x$ 和名义时间步长 $\\Delta t = C \\Delta x / |a|$。解数组 $u$ 使用 Heaviside 函数 $u(x,0) = H(x - x_0)$ 进行初始化。\n2.  **时间演化**：一个循环将解从 $t=0$ 推进到 $T$。为确保精确达到最终时刻 $T$，每次迭代的时间步长计算为 $\\Delta t_{\\text{curr}} = \\min(\\Delta t, T - t)$。这处理了 $T$ 不是 $\\Delta t$ 整数倍的情况。\n3.  **更新步骤**：在循环内部，创建解 $u^n$ 的一个副本。使用适当的迎风公式计算所有内部点的解 $u^{n+1}$，更新系数按 $\\Delta t_{\\text{curr}}$ 进行缩放。\n4.  **边界条件**：计算完内部点的更新后，强制施加流入边界条件。如果 $a > 0$，则设置左边界的值：$u_0^{n+1} = 0$。如果 $a < 0$，则设置右边界的值：$u_{N-1}^{n+1} = 1$。流出边界不需要特殊处理，因为它由迎风模板的单边性质处理。\n5.  **误差计算**：一旦模拟达到 $t=T$，就获得了最终的数值解 $u_i^{\\text{num}}(T)$。在同一网格上计算解析解 $u^{\\text{exact}}(x_i,T) = H(x_i - (x_0 + aT))$。然后使用以下公式计算离散 $\\ell^1$ 误差：\n    $$\n    E_1 = \\sum_{i=0}^{N-1} \\left| u_i^{\\text{num}}(T) - u^{\\text{exact}}(x_i,T) \\right|\\,\\Delta x\n    $$\n对于 $C=1.0$ 的测试用例，该格式（对于 $a>0$）简化为 $u_i^{n+1} = u_{i-1}^n$。这对应于每个时间步长将离散数据精确地移动一个网格单元。由于总时间 $T$ 的选择使得总平流距离 $aT$ 是 $\\Delta x$ 的整数倍，因此网格上的数值解与精确解完全相同，导致误差为零。对于 $C < 1$ 的情况，该格式会引入数值耗散，这会使陡峭的阶跃变得模糊，从而产生非零误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation for multiple test cases\n    using a first-order upwind scheme and computes the l1 error.\n    \"\"\"\n    test_cases = [\n        # (a, x_min, x_max, x_0, N, T, C)\n        (1.0, 0.0, 1.0, 0.25, 401, 0.2, 0.5),\n        (-0.7, 0.0, 1.0, 0.8, 401, 0.15, 0.8),\n        (1.0, 0.0, 1.0, 0.3, 201, 0.3, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(*case)\n        # Append result formatted to six decimal places.\n        results.append(f\"{error:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef solve_case(a, x_min, x_max, x_0, N, T, C):\n    \"\"\"\n    Runs a single simulation case for the 1D linear advection equation.\n\n    Args:\n        a (float): Advection speed.\n        x_min (float): Minimum of the spatial domain.\n        x_max (float): Maximum of the spatial domain.\n        x_0 (float): Initial position of the step in the Heaviside function.\n        N (int): Number of grid points.\n        T (float): Final time.\n        C (float): Courant–Friedrichs–Lewy (CFL) number.\n\n    Returns:\n        float: The discrete l1 error at the final time T.\n    \"\"\"\n    # 1. Setup grid and initial condition\n    dx = (x_max - x_min) / (N - 1)\n    x = np.linspace(x_min, x_max, N)\n    # The problem defines H(xi) = 1 for xi >= 0. np.heaviside with second arg 1.0 does this.\n    u = np.heaviside(x - x_0, 1.0)\n\n    # 2. Setup time stepping\n    # The advection speed 'a' is non-zero in all test cases.\n    dt_nominal = C * dx / abs(a)\n    \n    # 3. Time integration loop\n    t = 0.0\n    # Use a small tolerance for floating point comparison to ensure loop termination.\n    while t  T:\n        # Determine current time step to not step over T.\n        current_dt = min(dt_nominal, T - t)\n        \n        # Make a copy of the solution at the current time step 'n'.\n        u_n = u.copy()\n        \n        # The update coefficient nu = a * dt / dx\n        nu = a * current_dt / dx\n        \n        if a > 0:\n            # FTBS (Forward-Time, Backward-Space) for a > 0\n            # u_i^{n+1} = u_i^n - nu * (u_i^n - u_{i-1}^n)\n            u[1:] = u_n[1:] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_min\n            u[0] = 0.0\n        else: # a  0\n            # FTFS (Forward-Time, Forward-Space) for a  0\n            # u_i^{n+1} = u_i^n - nu * (u_{i+1}^n - u_i^n)\n            u[:-1] = u_n[:-1] - nu * (u_n[1:] - u_n[:-1])\n            # Apply inflow boundary condition at x_max\n            u[-1] = 1.0\n            \n        t += current_dt\n\n    # 4. Calculate exact solution at time T\n    x_final_discontinuity = x_0 + a * T\n    u_exact = np.heaviside(x - x_final_discontinuity, 1.0)\n    \n    # 5. Compute the discrete l1 error\n    error = np.sum(np.abs(u - u_exact)) * dx\n    \n    return error\n\nsolve()\n```", "id": "2448567"}, {"introduction": "在真实的物理和工程问题中，平流速度场很少是恒定的。第二个实践 ([@problem_id:3285398]) 将挑战一个更复杂且更具现实意义的场景：一个空间依赖且可能变号的速度场 $a(x)$。这个练习将迫使你实现迎风概念的真正精髓——根据信息传播的*局部*方向动态选择差分格式，从而加深对双曲型方程因果律物理基础的理解。", "problem": "考虑具有空间相关速度的一维线性平流方程，\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0,\\quad x\\in[0,1],\\ t\\ge 0,\n$$\n其中 $u(x,t)$ 是一个被输运的标量场，$a(x)$ 是一个预设的、足够光滑的速度，其在空间域上可能改变符号。对于双曲输运方程，信息沿着由 $a(x)$ 的符号决定的特征线传播，稳定的离散化必须使用来自上风向的值。您的任务是实现一个一阶显式上风有限差分方法，该方法根据 $a(x)$ 的局部符号切换差分格式，并量化这种切换的属性以及所得到的离散解的属性。\n\n在单个完整的程序中实现以下设计：\n- 使用 $N$ 个点的均匀网格离散化 $[0,1]$，点为 $x_i = i\\,\\Delta x$，其中 $i=0,1,\\dots,N-1$，$\\Delta x = 1/(N-1)$。\n- 使用单个显式欧拉时间步进器，时间步长 $\\Delta t$ 满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件，具体为\n$$\n\\Delta t = \\lambda\\,\\frac{\\Delta x}{\\max_{0\\le i\\le N-1} |a(x_i)|},\n$$\n其中 $0  \\lambda\\le 1$ 是 Courant 数。\n- 在每个内部网格点 $i=1,2,\\dots,N-2$ 处，通过取自上风向的单边差分来近似 $u_x(x_i,t)$，该方向由 $a(x_i)$ 的符号选择：如果 $a(x_i)0$，使用后向差分；如果 $a(x_i)0$，使用前向差分；当 $a(x_i)=0$ 时（无输运），将导数贡献设置为零。\n- 对所有 $t\\ge 0$ 施加 Dirichlet 边值 $u(0,t) = u_L$ 和 $u(1,t) = u_R$。注意，对于双曲流，当特征信息进入区域时，这些值充当流入值；在流出边界上，它们不影响内部更新，因为上风格式不引用它们。\n- 将数值解推进 $K$ 个显式欧拉步。\n\n从第一性原理出发，该方法必须利用双曲输运方程的因果性和由 $a(x)$ 符号所暗示的特征线方向性来推导。特别地，后向差分与 $a(x)0$ 一致，因为 $x_i$ 处的信息来自 $x_{i-1}$；而前向差分与 $a(x)0$ 一致，因为 $x_i$ 处的信息来自 $x_{i+1}$。\n\n为每个测试用例定义以下由您的程序计算的离散诊断量：\n1. 方法使用后向差分的内部点 $i=1,\\dots,N-2$ 的整数数量（即 $a(x_i)0$ 的点）。\n2. 方法使用前向差分的内部点 $i=1,\\dots,N-2$ 的整数数量（即 $a(x_i)0$ 的点）。\n3. 离散速度场中符号变化界面的整数数量，定义为满足 $\\operatorname{sign}(a(x_i))\\ne \\operatorname{sign}(a(x_{i+1}))$ 的索引 $i=0,\\dots,N-2$ 的计数，并约定 $\\operatorname{sign}(0)=0$。\n4. 一个布尔值，指示经过 $K$ 步后，离散解是否满足相对于初始和边界数据包络的离散极值原理，即是否\n$$\n\\min_{0\\le i\\le N-1} u^K_i \\ge \\min\\left(\\min_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right)\n\\quad\\text{and}\\quad\n\\max_{0\\le i\\le N-1} u^K_i \\le \\max\\left(\\max_{0\\le i\\le N-1} u^0_i,\\ u_L,\\ u_R\\right),\n$$\n其中 $u^n_i$ 表示经过 $n$ 个时间步后在网格点 $x_i$ 处的数值解。\n\n使用以下参数值测试套件来检验该方法的不同方面：\n- 测试用例 A（具有单次跳跃和不同量值的通用情况）：\n  - $N=51$, $\\lambda=0.9$, $K=25$,\n  - $a(x)=\\begin{cases}1,  x0.5\\\\ -0.5,  x\\ge 0.5\\end{cases}$,\n  - $u_L=0$, $u_R=1$,\n  - $u_0(x)=\\sin(2\\pi x)$.\n- 测试用例 B（边界对齐的零速度，在网格点上精确的符号反转）：\n  - $N=51$, $\\lambda=0.9$, $K=30$,\n  - $a(x)=x-0.5$,\n  - $u_L=0.5$, $u_R=-0.5$,\n  - $u_0(x)=1-2|x-0.5|$.\n- 测试用例 C（具有快速变化过渡的平滑符号变化）：\n  - $N=101$, $\\lambda=0.9$, $K=40$,\n  - $a(x)=\\tanh\\big(20(0.7-x)\\big)$,\n  - $u_L=1$, $u_R=-1$,\n  - $u_0(x)=\\cos(4\\pi x)$.\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是按上述顺序排列的、用方括号括起来的逗号分隔列表。例如，输出格式必须为\n$$\n[\\,[n_{\\text{back}},n_{\\text{fwd}},n_{\\text{sign}},\\text{mp}],\\,[\\dots],\\,[\\dots]\\,],\n$$\n其中 $n_{\\text{back}}$ 和 $n_{\\text{fwd}}$ 是整数，$n_{\\text{sign}}$ 是整数，$\\text{mp}$ 是布尔值。", "solution": "用户提供的问题被评估为有效。这是一个在偏微分方程数值分析领域中提法恰当、有科学依据的问题，所有必要组成部分都已明确定义。\n\n该问题要求实现一个一阶显式上风有限差分方法，用于求解具有空间相关、符号变化的平流速度 $a(x)$ 的一维线性平流方程：\n$$\nu_t(x,t) + a(x)\\,u_x(x,t) = 0\n$$\n支配该问题的基本原理是双曲因果性。对于双曲方程（如平流方程），信息沿着特征线传播。这些曲线在 $(x,t)$ 平面上的轨迹由常微分方程 $dx/dt = a(x)$ 定义。速度 $a(x)$ 的符号决定了信息流动的方向：如果 $a(x)0$，信息从左向右传播；如果 $a(x)0$，则从右向左传播。一个稳定的数值格式必须通过在“上风”方向（信息来源的方向）进行差分来尊重这种物理因果性。\n\n解在由 $N$ 个点组成的均匀空间网格上离散化，点为 $x_i = i\\,\\Delta x$，其中 $i=0, 1, \\dots, N-1$，网格间距为 $\\Delta x = 1/(N-1)$。时间使用显式欧拉法推进，时间步长为 $\\Delta t$。在网格点 $x_i$ 处的半离散方程为：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} + a(x_i) (u_x)_i^n = 0\n$$\n这给出了更新公式 $u_i^{n+1} = u_i^n - \\Delta t \\, a(x_i) (u_x)_i^n$。\n\n上风方法的核心在于空间导数 $(u_x)_i^n$ 的近似。差分格式的选择由平流速度 $a(x_i)$ 的局部符号决定：\n1.  如果 $a(x_i)  0$，则流动是从左到右。$x_i$ 处的信息来自 $x_{i-1}$。空间导数使用一阶后向差分来近似：\n    $$\n    (u_x)_i^n \\approx \\frac{u_i^n - u_{i-1}^n}{\\Delta x}\n    $$\n2.  如果 $a(x_i)  0$，则流动是从右到左。$x_i$ 处的信息来自 $x_{i+1}$。空间导数使用一阶前向差分来近似：\n    $$\n    (u_x)_i^n \\approx \\frac{u_{i+1}^n - u_i^n}{\\Delta x}\n    $$\n3.  如果 $a(x_i) = 0$，则在 $x_i$ 处没有输运。平流项 $a(x_i)u_x$ 为零，解不发生变化：$u_i^{n+1} = u_i^n$。\n\n综合这些，内部点 $i=1, \\dots, N-2$ 的完整更新格式为：\n$$\nu_i^{n+1} = \\begin{cases}\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_i^n - u_{i-1}^n),   \\text{if } a(x_i)  0 \\\\\nu_i^n - \\frac{a(x_i)\\Delta t}{\\Delta x}(u_{i+1}^n - u_i^n),   \\text{if } a(x_i)  0 \\\\\nu_i^n,   \\text{if } a(x_i) = 0\n\\end{cases}\n$$\n该显式格式在 Courant-Friedrichs-Lewy (CFL) 条件下是稳定的，该条件要求数值依赖域包含物理依赖域。这转化为对所有 $i$ 的约束 $|a(x_i)|\\Delta t / \\Delta x \\le 1$。为确保在整个网格上的稳定性，时间步长 $\\Delta t$ 根据最大速度来选择：\n$$\n\\Delta t = \\lambda \\frac{\\Delta x}{\\max_{i} |a(x_i)|}\n$$\n其中 $\\lambda \\in (0, 1]$ 是 Courant 数。\n\n通过在所有时间步 $n$ 设置 $u_0^n = u_L$ 和 $u_{N-1}^n = u_R$ 来施加 Dirichlet 边界条件 $u(0,t) = u_L$ 和 $u(1,t) = u_R$。当流动指向域内时，这些值为邻近边界的内部点提供了必要的上风数据。例如，在 $i=1$ 处，如果 $a(x_1)0$，则差分格式需要 $u_0^n = u_L$。反之，如果流动指向域外（例如 $a(x_1)0$），则边界值 $u_L$ 不用于 $u_1^n$ 的更新，这正确地反映了流出的物理特性。\n\n实现过程首先定义离散网格，并在所有网格点上计算速度场 $a(x_i)$ 和初始条件 $u_i^0$。与速度场相关的诊断量（$n_{\\text{back}}$、$n_{\\text{fwd}}$、$n_{\\text{sign}}$）计算一次。然后，将解推进 $K$ 个时间步，每步都涉及根据上述上风逻辑更新所有内部点。经过 $K$ 步后，最终解 $u_i^K$ 用于检查离散极值原理。该原理指出格式不会产生新的极值，是此方法的一个关键属性，并且在满足 CFL 条件时成立。通过将最终解的最小值和最大值与初始数据和边界值的包络进行比较来验证该原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(N, lambda_cfl, K, a_func, u_L, u_R, u0_func):\n    \"\"\"\n    Solves the 1D advection equation with a space-dependent speed\n    using a first-order upwind scheme and computes specified diagnostics.\n    \"\"\"\n    # 1. Grid and Field Setup\n    x = np.linspace(0.0, 1.0, N)\n    dx = 1.0 / (N - 1)\n    \n    a = a_func(x)\n    u = u0_func(x)\n    u_initial = u.copy()\n\n    # 2. Pre-computation of Diagnostics\n    # Number of interior points with backward/forward differences\n    interior_a = a[1:-1]\n    n_back = int(np.sum(interior_a > 0))\n    n_fwd = int(np.sum(interior_a  0))\n\n    # Number of sign-change interfaces in the discrete speed field\n    signs = np.sign(a)\n    n_sign = int(np.sum(signs[:-1] != signs[1:]))\n\n    # 3. Time Step Calculation\n    a_max = np.max(np.abs(a))\n    if a_max == 0:\n        # Avoid division by zero if a(x) is identically zero.\n        # dt can be anything, as nothing will change.\n        dt = 1.0\n    else:\n        dt = lambda_cfl * dx / a_max\n\n    # 4. Time-stepping Loop\n    u[0] = u_L\n    u[N - 1] = u_R\n    \n    for _ in range(K):\n        u_old = u.copy()\n        \n        # Vectorized update for interior points, can be slow. A loop is clearer and sufficient for these N.\n        for i in range(1, N - 1):\n            a_i = a[i]\n            if a_i > 0:\n                # Backward difference for u_x\n                grad_u = (u_old[i] - u_old[i-1]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            elif a_i  0:\n                # Forward difference for u_x\n                grad_u = (u_old[i+1] - u_old[i]) / dx\n                u[i] = u_old[i] - dt * a_i * grad_u\n            # If a_i == 0, u[i] remains u_old[i], so no operation needed.\n    \n    # 5. Post-computation of Diagnostics (Maximum Principle)\n    min_bound = min(np.min(u_initial), u_L, u_R)\n    max_bound = max(np.max(u_initial), u_L, u_R)\n    \n    # Use a small tolerance for floating-point comparisons\n    tol = 1e-9\n    mp = bool((np.min(u) >= min_bound - tol) and (np.max(u) = max_bound + tol))\n\n    return [n_back, n_fwd, n_sign, mp]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 25,\n            \"a_func\": lambda x: np.where(x  0.5, 1.0, -0.5),\n            \"u_L\": 0.0, \"u_R\": 1.0,\n            \"u0_func\": lambda x: np.sin(2 * np.pi * x)\n        },\n        {\n            \"N\": 51, \"lambda_cfl\": 0.9, \"K\": 30,\n            \"a_func\": lambda x: x - 0.5,\n            \"u_L\": 0.5, \"u_R\": -0.5,\n            \"u0_func\": lambda x: 1.0 - 2.0 * np.abs(x - 0.5)\n        },\n        {\n            \"N\": 101, \"lambda_cfl\": 0.9, \"K\": 40,\n            \"a_func\": lambda x: np.tanh(20 * (0.7 - x)),\n            \"u_L\": 1.0, \"u_R\": -1.0,\n            \"u0_func\": lambda x: np.cos(4 * np.pi * x)\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        result = run_simulation(\n            case[\"N\"], case[\"lambda_cfl\"], case[\"K\"],\n            case[\"a_func\"], case[\"u_L\"], case[\"u_R\"], case[\"u0_func\"]\n        )\n        all_results.append(result)\n\n    # Final print statement in the exact required format.\n    inner_results_str = []\n    for res in all_results:\n        # res is a list like [n_back, n_fwd, n_sign, mp_bool]\n        inner_str = f\"[{res[0]},{res[1]},{res[2]},{str(res[3])}]\"\n        inner_results_str.append(inner_str)\n    \n    final_output_str = f\"[{','.join(inner_results_str)}]\"\n    print(final_output_str)\n\nsolve()\n```", "id": "3285398"}, {"introduction": "一阶迎风格式虽然稳定，但其固有的数值耗散会严重影响解的精度，这一点在第一个实践中显而易见。为了克服这一缺陷，我们需要更高阶的格式。本实践 ([@problem_id:3285423]) 将引导你实现一种现代计算流体力学中常用的高分辨率方法：带有minmod通量限制器的二阶MUSCL格式。通过这个练习，你将学会如何在保持解的光滑区域高精度的同时，有效抑制不连续处的非物理振荡，这是设计鲁棒数值格式的关键技术。", "problem": "考虑标量守恒律 $u_t + f(u)_x = 0$，其定义在周期为 $1$ 的周期性空间域 $x \\in [0,1]$ 上。关注线性平流情况 $f(u) = a u$，其中 $a$ 是一个恒定的波速。目标是构建一个带有 minmod 通量限制器和强稳定性保持（SSP）二阶龙格-库塔时间积分的二阶 Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) 有限体积法，并证明该限制器在间断点附近将方法恢复到一阶精度，以防止伪振荡。\n\n从单元 $I_i = [x_i - \\tfrac{1}{2}\\Delta x, x_i + \\tfrac{1}{2}\\Delta x]$ 上的单元平均值 $u_i(t)$ 开始，其中单元间距均匀，为 $\\Delta x = \\tfrac{1}{N}$，单元中心为 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$，适用于 $i = 0,1,\\dots,N-1$。有限体积半离散形式为\n$$\n\\frac{d u_i}{d t} = -\\frac{F_{i+\\tfrac{1}{2}} - F_{i-\\tfrac{1}{2}}}{\\Delta x},\n$$\n其中 $F_{i+\\tfrac{1}{2}}$ 是单元交界面 $x_{i+\\tfrac{1}{2}}$ 上的相容数值通量。对线性平流使用迎风数值通量：\n$$\nF_{i+\\tfrac{1}{2}} =\n\\begin{cases}\na\\,u_{i+\\tfrac{1}{2}}^{-},   \\text{if } a \\ge 0, \\\\\na\\,u_{i+\\tfrac{1}{2}}^{+},   \\text{if } a  0,\n\\end{cases}\n$$\n其中 $u_{i+\\tfrac{1}{2}}^{-}$ 和 $u_{i+\\tfrac{1}{2}}^{+}$ 分别是左侧和右侧重构的交界面状态。使用基于单边差分的带有 minmod 限制器的 MUSCL 重构\n$$\ns_i = \\operatorname{minmod}\\left(u_i - u_{i-1}, \\; u_{i+1} - u_i\\right),\n$$\n和\n$$\nu_{i+\\tfrac{1}{2}}^{-} = u_i + \\frac{1}{2} s_i, \\quad\nu_{i+\\tfrac{1}{2}}^{+} = u_{i+1} - \\frac{1}{2} s_{i+1}.\n$$\nminmod 函数定义为\n$$\n\\operatorname{minmod}(a,b) =\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min\\left(|a|,|b|\\right),   \\text{if } a\\,b  0, \\\\\n0,   \\text{otherwise}.\n\\end{cases}\n$$\n使用周期性边界条件，因此索引按模 $N$ 进行循环。使用强稳定性保持二阶龙格-库塔（SSP RK2）方法进行时间推进，该方法也称为 Shu–Osher 格式：\n$$\n\\begin{aligned}\nu^{(1)} = u^n + \\Delta t\\,L(u^n), \\\\\nu^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)}), \\\\\nu^{n+1} = \\frac{1}{2}\\left(u^n + u^{(2)}\\right),\n\\end{aligned}\n$$\n其中 $L(u)$ 是由 $L(u)_i = -\\dfrac{F_{i+\\tfrac{1}{2}}(u) - F_{i-\\tfrac{1}{2}}(u)}{\\Delta x}$ 定义的空间算子，$\\Delta t$ 由 Courant–Friedrichs–Lewy (CFL) 条件 $\\Delta t = \\text{CFL} \\cdot \\dfrac{\\Delta x}{|a|}$ 选定，其中 $\\text{CFL} = 0.9$。通过执行所需数量的大小为 $\\Delta t$ 的步长，积分到最终时间 $T$，如有必要，使用一个较短的最后一步以确保在 $t=T$ 时精确结束。\n\n实现此方法并将其应用于以下测试套件。在所有情况下，使用 $N=200$，$\\Delta x = \\tfrac{1}{N}$，以及指定的 $a$、$T$ 和在单元中心 $x_i = \\left(i + \\tfrac{1}{2}\\right)\\Delta x$ 采样的初始数据 $u_0(x)$。\n\n- 测试用例 1 (光滑输运)：$a=1$，$T=0.2$，$u_0(x) = \\sin(2\\pi x)$。计算精确解 $u_{\\text{exact}}(x,T) = \\sin\\left(2\\pi(x - a T)\\right)$ 并将离散 $\\ell^1$ 误差\n$$\nE_1 = \\sum_{i=0}^{N-1} \\left|u_i(T) - u_{\\text{exact}}(x_i,T)\\right| \\Delta x,\n$$\n作为浮点数报告。\n\n- 测试用例 2 (间断输运，边缘附近的限制器削波)：$a=1$，$T=0.2$，$u_0(x) = \\begin{cases} 1,   x \\in [0,0.5), \\\\ 0,   x \\in [0.5,1). \\end{cases}$ 演化到 $t=T$ 后，计算单边差分 $d_i^- = u_i - u_{i-1}$ 和 $d_i^+ = u_{i+1} - u_i$。定义一个小阈值 $\\varepsilon = 10^{-6}$。统计 minmod 限制器因符号变化而被削波的索引数，即满足 $d_i^-\\,d_i^+ \\le 0$ 且 $\\max\\{|d_i^-|,|d_i^+|\\}  \\varepsilon$ 的索引。将此比例\n$$\nE_2 = \\frac{\\#\\left\\{i : d_i^-\\,d_i^+ \\le 0 \\text{ and } \\max\\{|d_i^-|,|d_i^+|\\}  \\varepsilon \\right\\}}{N}\n$$\n作为浮点数报告。这量化了格式为抑制振荡而局部恢复为一阶迎风行为的位置。\n\n- 测试用例 3 (负速输运，全变差减小行为)：$a=-1$，$T=0.2$，$u_0(x)$ 与测试用例 2 中相同。计算初始和最终时刻的全变差 $\\operatorname{TV}(u) = \\sum_{i=0}^{N-1} |u_{i+1} - u_i|$（使用周期性索引）。将变化量\n$$\nE_3 = \\operatorname{TV}(u(T)) - \\operatorname{TV}(u(0)),\n$$\n作为浮点数报告。对于一个全变差减小（TVD）格式，人们期望在小的数值容差范围内 $E_3 \\le 0$。\n\n你的程序应产生单行输出，其中包含以逗号分隔并用方括号括起来的结果列表，顺序为 $[E_1,E_2,E_3]$。", "solution": "所提出的问题是偏微分方程数值方法领域中一个适定的标准练习。它要求实现一个用于线性平流方程的二阶精度有限体积格式。该数值方法的所有组成部分——MUSCL 重构、minmod 限制器、迎风通量和 SSP RK2 时间积分——都得到了精确定义。参数和测试用例已完全指定，从而可以得到唯一且可验证的解。该问题在科学上是合理的，在算法上是可形式化的。因此，给出解是合理的。\n\n问题的核心是求解标量线性平流方程，这是一个双曲守恒律的原型：\n$$\n\\frac{\\partial u}{\\partial t} + \\frac{\\partial (a u)}{\\partial x} = 0,\n$$\n在周期域 $x \\in [0, 1]$ 上。在这里，$u(x,t)$ 是守恒量，$a$ 是恒定的波速。我们采用一种有限体积法，该方法演化解在离散网格单元 $I_i = [x_i - \\frac{1}{2}\\Delta x, x_i + \\frac{1}{2}\\Delta x]$ 上的单元平均值 $u_i(t)$，其中 $\\Delta x = 1/N$ 是均匀的单元宽度。守恒律的半离散形式为：\n$$\n\\frac{d u_i}{dt} = L(u)_i = -\\frac{F_{i+\\frac{1}{2}} - F_{i-\\frac{1}{2}}}{\\Delta x},\n$$\n其中 $L(u)$ 表示空间离散化算子，$F_{i+\\frac{1}{2}}$ 是单元 $I_i$ 和 $I_{i+1}$ 之间交界面上的数值通量。\n\n为了实现二阶空间精度，我们使用 Monotone Upstream-centered Schemes for Conservation Laws (MUSCL) 方法在每个单元内对解进行分段线性重构。对于每个单元 $I_i$，我们用一个线性函数来近似 $u(x,t)$：\n$$\nu(x,t) \\approx u_i(t) + \\frac{s_i}{\\Delta x} (x - x_i),\n$$\n其中 $s_i$ 是一个精心选择的、受限的斜率。这种重构提供了在每个单元交界面左右两侧的解值。具体来说，在交界面 $x_{i+\\frac{1}{2}}$ 处，从左侧单元 $I_i$ 重构的值记为 $u_{i+\\frac{1}{2}}^{-}$，从右侧单元 $I_{i+1}$ 重构的值记为 $u_{i+\\frac{1}{2}}^{+}$。在交界面上对线性重构进行求值可得：\n$$\nu_{i+\\frac{1}{2}}^{-} = u_i + \\frac{1}{2}s_i, \\quad u_{i+\\frac{1}{2}}^{+} = u_{i+1} - \\frac{1}{2}s_{i+1}.\n$$\n为防止间断点附近的伪振荡（吉布斯现象），斜率 $s_i$ 必须受到限制。问题指定了 minmod 限制器，它是基于相邻单元平均值之间的差来定义的：\n$$\ns_i = \\operatorname{minmod}(u_i - u_{i-1}, u_{i+1} - u_i).\n$$\nminmod 函数确保重构是非振荡的。其定义为：\n$$\n\\operatorname{minmod}(a,b) =\n\\begin{cases}\n\\operatorname{sign}(a)\\,\\min(|a|,|b|),   \\text{if } a\\,b  0, \\\\\n0,   \\text{otherwise}.\n\\end{cases}\n$$\n如果前向差分 $u_{i+1} - u_i$ 和后向差分 $u_i - u_{i-1}$ 符号相同，minmod 会选择量级较小的一个，从而倾向于一个保守的斜率。如果它们的符号不同（这发生在局部极值点），斜率 $s_i$ 将被设为 $0$。这会局部地将格式降为一阶迎风格式，该格式虽然鲁棒但具有耗散性，从而削平了初生的振荡。通过将索引按模 $N$ 进行循环处理来实施周期性边界条件。\n\n数值通量 $F_{i+\\frac{1}{2}}$ 由迎风原理确定，该原理根据波速 $a$ 的符号所给出的信息传播方向来选择交界面上的值。对于线性平流，其形式为：\n$$\nF_{i+\\frac{1}{2}} =\n\\begin{cases}\na\\,u_{i+\\frac{1}{2}}^{-},   \\text{if } a \\ge 0, \\\\\na\\,u_{i+\\frac{1}{2}}^{+},   \\text{if } a  0.\n\\end{cases}\n$$\n\n对于时间积分，问题指定了二阶强稳定性保持龙格-库塔（SSP RK2）方法，也称为 Shu-Osher 格式。选择该方法是因为在合适的 CFL 条件下，它能保持空间离散化的非振荡特性（例如全变差减小，TVD）。给定时间 $t_n$ 的解 $u^n$，时间 $t_{n+1} = t_n + \\Delta t$ 的解 $u^{n+1}$ 通过以下方式计算：\n$$\n\\begin{aligned}\nu^{(1)} = u^n + \\Delta t\\,L(u^n), \\\\\nu^{(2)} = u^{(1)} + \\Delta t\\,L(u^{(1)}), \\\\\nu^{n+1} = \\frac{1}{2}(u^n + u^{(2)}).\n\\end{aligned}\n$$\n时间步长 $\\Delta t$ 受 Courant-Friedrichs-Lewy (CFL) 条件约束以确保稳定性，$\\Delta t = \\text{CFL} \\cdot \\frac{\\Delta x}{|a|}$ 且给定的 $\\text{CFL}=0.9$。积分从 $t=0$ 进行到最终时间 $t=T$，如有必要，使用一个较小的最终时间步长以精确到达 $T$。\n\n这三个测试用例旨在探究该格式性能的不同方面：\n1.  用例 1 (光滑解)：使用光滑的正弦波初始条件。对于光滑解，minmod 限制器在大多数单元中应处于非激活状态，从而使格式能展示其设计的二阶精度。离散 $\\ell^1$ 误差 $E_1$ 用于量化其精度。\n2.  用例 2 (间断解)：方波初始条件引入了尖锐的间断。度量 $E_2$ 量化了限制器因局部差分符号变化而被激活的单元比例。这展示了该格式的自适应机制，即在间断点处恢复到一阶精度以保持稳定性。\n3.  用例 3 (TVD 特性)：使用相同的间断剖面但波速为负，此用例测试全变差减小（TVD）特性。对于非振荡格式，全变差 $\\operatorname{TV}(u) = \\sum_i |u_{i+1} - u_i|$ 不应随时间增加。全变差的变化量 $E_3 = \\operatorname{TV}(u(T)) - \\operatorname{TV}(u(0))$，预计将小于或等于零（在微小的数值浮点误差范围内）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a second-order MUSCL finite volume scheme for the linear\n    advection equation and runs a suite of tests.\n    \"\"\"\n\n    def minmod(a, b):\n        \"\"\"Vectorized minmod function.\"\"\"\n        ab = a * b\n        s = np.sign(a)\n        return np.where(ab > 0, s * np.minimum(np.abs(a), np.abs(b)), 0)\n\n    def l_operator(u, a, dx):\n        \"\"\"\n        Computes the spatial operator L(u), representing the semi-discrete\n        form of the advection equation.\n        \"\"\"\n        # Periodic boundary conditions are handled by np.roll\n        # u_prev[i] = u[i-1], u_next[i] = u[i+1]\n        u_prev = np.roll(u, 1)\n        u_next = np.roll(u, -1)\n\n        # 1. Slope Calculation with minmod limiter\n        diff_bwd = u - u_prev\n        diff_fwd = u_next - u\n        s = minmod(diff_bwd, diff_fwd)\n\n        # 2. Reconstruction at cell interfaces i+1/2\n        # u_minus is the state on the left side of the interface, from cell i\n        # u_plus is the state on the right side of the interface, from cell i+1\n        u_minus = u + 0.5 * s\n        s_next = np.roll(s, -1)\n        u_plus = u_next - 0.5 * s_next\n        \n        # 3. Upwind Flux Calculation at interface i-1/2 (rolled)\n        # We compute fluxes at i+1/2 and roll to get i-1/2\n        if a >= 0:\n            flux_half = a * u_minus\n        else:\n            flux_half = a * u_plus\n            \n        # 4. Flux differencing\n        # L(u)_i = -(F_{i+1/2} - F_{i-1/2}) / dx\n        flux_half_prev = np.roll(flux_half, 1)\n        return -(flux_half - flux_half_prev) / dx\n        \n    def time_stepper(u0, a, T, N, dx, cfl):\n        \"\"\"\n        Evolves the solution u from t=0 to t=T using SSP RK2.\n        \"\"\"\n        u = np.copy(u0)\n        t = 0.0\n        # Calculate base time step from CFL condition\n        # Handle a=0 case to avoid division by zero, although not in tests.\n        if abs(a) > 0:\n            dt_base = cfl * dx / abs(a)\n        else:\n            dt_base = float('inf')\n\n        while t  T:\n            dt = min(dt_base, T - t)\n            \n            # SSP RK2 (Shu-Osher)\n            u1 = u + dt * l_operator(u, a, dx)\n            u2 = u1 + dt * l_operator(u1, a, dx)\n            u = 0.5 * (u + u2)\n            \n            t += dt\n            \n        return u\n\n    # General Parameters\n    N = 200\n    DX = 1.0 / N\n    CFL = 0.9\n    X_CELLS = (np.arange(N) + 0.5) * DX\n    \n    results = []\n\n    # --- Test Case 1: Smooth Transport ---\n    a1 = 1.0\n    T1 = 0.2\n    u0_1 = np.sin(2 * np.pi * X_CELLS)\n    u_final_1 = time_stepper(u0_1, a1, T1, N, DX, CFL)\n    u_exact_1 = np.sin(2 * np.pi * (X_CELLS - a1 * T1))\n    e1 = np.sum(np.abs(u_final_1 - u_exact_1)) * DX\n    results.append(e1)\n\n    # --- Test Case 2: Discontinuous Transport ---\n    a2 = 1.0\n    T2 = 0.2\n    u0_2 = np.where(X_CELLS  0.5, 1.0, 0.0)\n    u_final_2 = time_stepper(u0_2, a2, T2, N, DX, CFL)\n    \n    # Calculate one-sided differences\n    d_minus = u_final_2 - np.roll(u_final_2, 1)\n    d_plus = np.roll(u_final_2, -1) - u_final_2\n    \n    # Count where limiter is active due to sign change near edges\n    epsilon = 1e-6\n    cond1 = (d_minus * d_plus) = 0\n    cond2 = np.maximum(np.abs(d_minus), np.abs(d_plus)) > epsilon\n    limiter_activations = np.sum(cond1  cond2)\n    e2 = limiter_activations / N\n    results.append(e2)\n\n    # --- Test Case 3: Negative Speed and TVD ---\n    a3 = -1.0\n    T3 = 0.2\n    u0_3 = np.where(X_CELLS  0.5, 1.0, 0.0)\n    \n    # Initial Total Variation\n    tv0 = np.sum(np.abs(np.roll(u0_3, -1) - u0_3))\n    \n    u_final_3 = time_stepper(u0_3, a3, T3, N, DX, CFL)\n    \n    # Final Total Variation\n    tvT = np.sum(np.abs(np.roll(u_final_3, -1) - u_final_3))\n    \n    e3 = tvT - tv0\n    results.append(e3)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3285423"}]}