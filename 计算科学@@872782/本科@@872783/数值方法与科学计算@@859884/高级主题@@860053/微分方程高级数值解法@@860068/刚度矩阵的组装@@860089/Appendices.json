{"hands_on_practices": [{"introduction": "理论知识的真正掌握在于应用。此练习将引导您从第一性原理出发，亲手构建一个简单但极具启发性的一维有限元模型。通过分析一个由两种不同材料交替组成的复合杆，您将计算其刚度矩阵的条件数，从而直观地理解材料属性的突变如何直接影响数值求解的稳定性。这个“纸笔”练习是连接物理直觉与数值分析的关键一步。[@problem_id:3206749]", "problem": "考虑一维扩散偏微分方程(PDE) $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$，其定义域为 $[0, 3h]$，齐次狄利克雷边界条件为 $u(0) = 0$ 和 $u(3h) = 0$。材料系数 $k(x)$ 是分段常数，在一个包含3个单元和4个节点（位于 $x_1 = 0$、$x_2 = h$、$x_3 = 2h$ 和 $x_4 = 3h$）的均匀网格上交替变化，具体如下：$k(x) = k_1$ 在 $[0, h]$ 上，$k(x) = k_2$ 在 $[h, 2h]$ 上，以及 $k(x) = k_1$ 在 $[2h, 3h]$ 上，其中 $k_1 \\gg k_2 > 0$。使用标准的伽辽金有限元法(FEM)，并采用与节点相关的连续分段线性基函数，从弱形式和单元刚度项的定义出发，组装全局刚度矩阵。然后，在施加齐次狄利克雷边界条件以消除 $x_1$ 和 $x_4$ 处的边界自由度后，提取与内部节点 $x_2$ 和 $x_3$ 相关的简化全局刚度矩阵。\n\n从第一性原理出发，不使用预先组装好的公式，计算该简化刚度矩阵在矩阵2-范数下的精确谱条件数，并将其表示为关于 $k_1$ 和 $k_2$ 的闭合形式表达式。请以单个简化的解析表达式给出最终答案。无需四舍五入，最终表达式中不应包含单位。", "solution": "用户提供了一个问题，要求推导由一维有限元问题产生的简化刚度矩阵的谱条件数。\n\n### 第1步：问题验证\n\n**提取的已知条件：**\n- **偏微分方程：** $- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x)$\n- **定义域：** $x \\in [0, 3h]$\n- **边界条件(BCs)：** $u(0) = 0$ 和 $u(3h) = 0$ (齐次狄利克雷)。\n- **网格：** 包含3个单元和4个节点的均匀网格：$x_1 = 0$, $x_2 = h$, $x_3 = 2h$, $x_4 = 3h$。\n- **材料系数：** $k(x)$ 是分段常数：\n  - $k(x) = k_1$ 对于 $x \\in [0, h]$\n  - $k(x) = k_2$ 对于 $x \\in [h, 2h]$\n  - $k(x) = k_1$ 对于 $x \\in [2h, 3h]$\n- **系数约束：** $k_1 \\gg k_2 > 0$。\n- **方法：** 标准的伽辽金有限元法(FEM)，采用连续分段线性基函数。\n- **任务：**\n  1. 推导弱形式。\n  2. 组装全局刚度矩阵。\n  3. 施加边界条件以获得与内部节点 $x_2$ 和 $x_3$ 相关的简化全局刚度矩阵。\n  4. 计算该简化矩阵在矩阵2-范数下的精确谱条件数，并将其表示为关于 $k_1$ 和 $k_2$ 的闭合形式表达式。\n\n**使用提取的已知条件进行验证：**\n1.  **科学依据：** 该问题是使用有限元法进行偏微分方程数值分析的标准练习。所有概念——扩散方程、弱形式、伽辽金法、刚度矩阵和条件数——在数学和工程领域都是基础且公认的。\n2.  **适定性：** 问题提供了构建刚度矩阵并计算其条件数所需的所有信息。问题设置清晰，目标是找到一个特定的解析表达式，这是一个适定的数学任务。\n3.  **客观性：** 问题以精确、技术性的语言陈述，没有任何主观或模棱两可的术语。\n4.  **完整性与一致性：** 问题是自洽的。定义域、边界条件、网格、基函数和材料属性都已指定，并且没有内部矛盾。\n5.  **现实性：** 该设置对应于一个物理系统，例如热传导或流体流过多孔介质，该介质由三层材料组成，其中外层的属性（如电导率）与内层不同。\n\n**结论：** 问题有效、科学合理、适定且完整。我将继续进行求解。\n\n### 第2步：推导与求解\n\n**弱形式**\n我们从控制偏微分方程开始：\n$$ - \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0, 3h) $$\n我们将其乘以一个测试函数 $v(x)$，该函数属于在狄利克雷边界上为零的函数空间，即 $H_0^1(0, 3h)$。在定义域上积分得到：\n$$ -\\int_{0}^{3h} v(x) \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) dx = \\int_{0}^{3h} v(x) f(x) dx $$\n对左侧项应用分部积分：\n$$ \\int_{0}^{3h} \\frac{dv}{dx} k(x) \\frac{du}{dx} dx - \\left[ v(x) k(x) \\frac{du}{dx} \\right]_{0}^{3h} = \\int_{0}^{3h} v(x) f(x) dx $$\n由于测试函数 $v(x)$ 必须满足齐次狄利克雷边界条件，$v(0) = v(3h) = 0$，边界项消失。弱形式为：找到 $u \\in H_0^1(0, 3h)$，使得对于所有 $v \\in H_0^1(0, 3h)$：\n$$ \\int_{0}^{3h} k(x) \\frac{du}{dx} \\frac{dv}{dx} dx = \\int_{0}^{3h} f(x) v(x) dx $$\n左侧定义了双线性形式 $a(u,v)$，刚度矩阵由此导出。\n\n**有限元离散化**\n我们使用与每个节点 $x_i$ 相关的连续分段线性基函数（帽函数）$\\phi_i(x)$，使得 $\\phi_i(x_j) = \\delta_{ij}$。近似解为 $u_h(x) = \\sum_{j=1}^{4} U_j \\phi_j(x)$。\n基函数的导数是分段常数。在一个长度为 $h$ 的单元上，导数为 $\\pm 1/h$。\n- $\\phi'_1(x) = -1/h$ 在 $[0, h]$ 上\n- $\\phi'_2(x) = 1/h$ 在 $[0, h]$ 上，以及 $-1/h$ 在 $[h, 2h]$ 上\n- $\\phi'_3(x) = 1/h$ 在 $[h, 2h]$ 上，以及 $-1/h$ 在 $[2h, 3h]$ 上\n- $\\phi'_4(x) = 1/h$ 在 $[2h, 3h]$ 上\n\n**组装全局刚度矩阵**\n全局刚度矩阵 $K$ 的项由 $K_{ij} = a(\\phi_j, \\phi_i) = \\int_{0}^{3h} k(x) \\phi'_i(x) \\phi'_j(x) dx$ 给出。我们通过在导数乘积非零的每个单元上积分来计算非零项。\n\n- **单元1：$[0, h]$，其中 $k(x) = k_1$**\n  - $K_{11}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_1)^2 dx = \\int_{0}^{h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{22}^{(1)} = \\int_{0}^{h} k_1 (\\phi'_2)^2 dx = \\int_{0}^{h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{12}^{(1)} = K_{21}^{(1)} = \\int_{0}^{h} k_1 \\phi'_1 \\phi'_2 dx = \\int_{0}^{h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\n- **单元2：$[h, 2h]$，其中 $k(x) = k_2$**\n  - $K_{22}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_2)^2 dx = \\int_{h}^{2h} k_2 (-1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{33}^{(2)} = \\int_{h}^{2h} k_2 (\\phi'_3)^2 dx = \\int_{h}^{2h} k_2 (1/h)^2 dx = \\frac{k_2}{h}$\n  - $K_{23}^{(2)} = K_{32}^{(2)} = \\int_{h}^{2h} k_2 \\phi'_2 \\phi'_3 dx = \\int_{h}^{2h} k_2 (-1/h)(1/h) dx = -\\frac{k_2}{h}$\n\n- **单元3：$[2h, 3h]$，其中 $k(x) = k_1$**\n  - $K_{33}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_3)^2 dx = \\int_{2h}^{3h} k_1 (-1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{44}^{(3)} = \\int_{2h}^{3h} k_1 (\\phi'_4)^2 dx = \\int_{2h}^{3h} k_1 (1/h)^2 dx = \\frac{k_1}{h}$\n  - $K_{34}^{(3)} = K_{43}^{(3)} = \\int_{2h}^{3h} k_1 \\phi'_3 \\phi'_4 dx = \\int_{2h}^{3h} k_1 (-1/h)(1/h) dx = -\\frac{k_1}{h}$\n\n全局刚度矩阵 $K$ 是通过将每个单元的贡献相加来组装的：\n- $K_{11} = K_{11}^{(1)} = \\frac{k_1}{h}$\n- $K_{22} = K_{22}^{(1)} + K_{22}^{(2)} = \\frac{k_1}{h} + \\frac{k_2}{h} = \\frac{k_1+k_2}{h}$\n- $K_{33} = K_{33}^{(2)} + K_{33}^{(3)} = \\frac{k_2}{h} + \\frac{k_1}{h} = \\frac{k_1+k_2}{h}$\n- $K_{44} = K_{44}^{(3)} = \\frac{k_1}{h}$\n- $K_{12} = K_{21} = -\\frac{k_1}{h}$\n- $K_{23} = K_{32} = -\\frac{k_2}{h}$\n- $K_{34} = K_{43} = -\\frac{k_1}{h}$\n\n得到的 $4 \\times 4$ 全局刚度矩阵为：\n$$ K = \\frac{1}{h} \\begin{pmatrix} k_1 & -k_1 & 0 & 0 \\\\ -k_1 & k_1+k_2 & -k_2 & 0 \\\\ 0 & -k_2 & k_1+k_2 & -k_1 \\\\ 0 & 0 & -k_1 & k_1 \\end{pmatrix} $$\n\n**施加边界条件并提取简化矩阵**\n齐次狄利克雷边界条件 $u(0)=0$ 和 $u(3h)=0$ 对应于设置节点值 $U_1=0$ 和 $U_4=0$。这等价于从全局矩阵 $K$ 中移除第一行和第四行以及第一列和第四列，以获得关于内部未知自由度 $U_2$ 和 $U_3$ 的简化系统。简化刚度矩阵 $K_{red}$ 是对应于节点2和3的 $2 \\times 2$ 子矩阵：\n$$ K_{red} = \\frac{1}{h} \\begin{pmatrix} k_1+k_2 & -k_2 \\\\ -k_2 & k_1+k_2 \\end{pmatrix} $$\n\n**计算谱条件数**\n对称正定矩阵的谱条件数（在2-范数下）是其最大特征值与最小特征值的比值：$\\kappa_2(A) = \\frac{\\lambda_{\\max}(A)}{\\lambda_{\\min}(A)}$。\n\n我们通过求解特征方程 $\\det(K_{red} - \\lambda I) = 0$ 来找到 $K_{red}$ 的特征值。\n$$ \\det \\begin{pmatrix} \\frac{k_1+k_2}{h} - \\lambda & -\\frac{k_2}{h} \\\\ -\\frac{k_2}{h} & \\frac{k_1+k_2}{h} - \\lambda \\end{pmatrix} = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 - \\left(-\\frac{k_2}{h}\\right)^2 = 0 $$\n$$ \\left(\\frac{k_1+k_2}{h} - \\lambda\\right)^2 = \\frac{k_2^2}{h^2} $$\n两边取平方根：\n$$ \\frac{k_1+k_2}{h} - \\lambda = \\pm \\frac{k_2}{h} $$\n这给出了 $\\lambda$ 的两个可能值：\n1.  $\\lambda_a = \\frac{k_1+k_2}{h} - \\frac{k_2}{h} = \\frac{k_1}{h}$\n2.  $\\lambda_b = \\frac{k_1+k_2}{h} + \\frac{k_2}{h} = \\frac{k_1+2k_2}{h}$\n\n由于 $k_1 > 0$ 且 $k_2 > 0$，显然 $\\lambda_b > \\lambda_a$。因此：\n- $\\lambda_{\\min}(K_{red}) = \\frac{k_1}{h}$\n- $\\lambda_{\\max}(K_{red}) = \\frac{k_1+2k_2}{h}$\n\n$K_{red}$ 的谱条件数为：\n$$ \\kappa_2(K_{red}) = \\frac{\\lambda_{\\max}(K_{red})}{\\lambda_{\\min}(K_{red})} = \\frac{\\frac{k_1+2k_2}{h}}{\\frac{k_1}{h}} $$\n$$ \\kappa_2(K_{red}) = \\frac{k_1+2k_2}{k_1} $$\n简化表达式得到最终答案：\n$$ \\kappa_2(K_{red}) = 1 + \\frac{2k_2}{k_1} $$", "answer": "$$\\boxed{1 + \\frac{2k_2}{k_1}}$$", "id": "3206749"}, {"introduction": "从理论分析转向编程实践，我们来处理一个更贴近实际应用的问题：周期性边界条件。在模拟晶体结构或任何具有重复单元的系统时，周期性边界条件是必不可少的。本练习要求您编写代码，实现对具有周期性边界的一维问题进行刚度矩阵的组装与归约。这不仅能巩固您对组装过程的理解，还将让您掌握如何通过代数操作将物理约束精确地施加到离散系统中。[@problem_id:3206698]", "problem": "请从第一性原理出发，使用给定网格上的线性 Lagrange 基函数，实现一维二阶扩散算子在周期性边界条件下的刚度矩阵全局组装。目标是组装出强制执行周期性辨识 $u(x_1) = u(x_N)$ 的缩减全局刚度矩阵，其中 $x_1$ 和 $x_N$ 分别是第一个和最后一个网格节点。请完全在有限元法 (FEM) 的框架下进行，并基于扩散算子的标准双线性形式进行推导。不要使用任何预先推导的单元矩阵公式；请从核心定义出发推导所有内容。\n\n给定一个包含 $N$ 个节点的网格，其坐标为 $x_1 < x_2 < \\dots < x_N$，覆盖区间 $[x_1,x_N]$。设扩散系数为函数 $a(x) \\gt 0$，在每个单元上该函数被视为常数，并等于其单元上指定的值。弱形式导出双线性形式\n$$\nB(u,v) = \\int_{x_1}^{x_N} a(x)\\, \\frac{du}{dx}\\, \\frac{dv}{dx}\\, dx.\n$$\n对于使用线性 Lagrange 基函数 $\\{\\phi_i\\}_{i=1}^N$ 进行组装，刚度矩阵的元素定义为\n$$\nK_{ij} = \\sum_{e=1}^{N-1} \\int_{x_e}^{x_{e+1}} a(x)\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx,\n$$\n其中 $[x_e,x_{e+1}]$ 表示单元 $e$。在每个单元上，使用限制在该单元上的标准帽函数，并回想对于线性基函数，其导数 $\\frac{d\\phi}{dx}$ 在单元上是常数，并在单元外为零。仅使用这些定义和基本微积分来推导局部贡献并组装全局矩阵。\n\n为强制执行周期性辨识 $u(x_N)=u(x_1)$，您必须通过在代数（双线性形式）层面替换 $u_N=u_1$ 来消除与节点 $N$ 对应的冗余自由度，从而使得到的缩减刚度矩阵大小为 $(N-1)\\times(N-1)$。具体来说，如果消除前完全组装的矩阵以分块形式写作\n$$\nK = \\begin{bmatrix}\nA & b \\\\\nb^\\mathsf{T} & c\n\\end{bmatrix},\n$$\n其中 $A \\in \\mathbb{R}^{(N-1)\\times(N-1)}$，$b \\in \\mathbb{R}^{N-1}$，$c \\in \\mathbb{R}$，且最后一行和最后一列对应于节点 $N$，则对应于替换 $u_N=u_1$ 的缩减周期性矩阵必须与此约束下的能量 $u^\\mathsf{T} K u$ 相一致地组装。您的实现必须在组装 $K$ 之后明确执行此缩减操作。\n\n每个测试用例的输入规范：\n- 一个节点位置列表 $\\{x_i\\}_{i=1}^N$，其元素严格递增（这些是实数）。\n- 或者一个在每个单元上使用的单一常数系数 $a$，或者一个单元上的正实数列表 $\\{a_e\\}_{e=1}^{N-1}$，其中 $a_e$ 是 $a(x)$ 在单元 $e$ 上的常数值。\n\n输出规范：\n- 对于每个测试用例，您的程序必须生成大小为 $(N-1)\\times(N-1)$ 的缩减周期性刚度矩阵，按行主序展平为一个浮点数列表。\n- 将每个浮点数四舍五入到 $10$ 位小数。\n- 将所有测试用例的展平列表聚合为单行输出，该输出包含一个用方括号括起来的逗号分隔列表，其中不含空格。例如，如果有两个测试用- 例，输出应类似于 $[[m_{11},\\dots],[n_{11},\\dots]]$，所有数字均按要求四舍五入。\n\n角度单位不适用。此纯数学公式不需要物理单位。\n\n需要实现和评估的测试套件：\n- 测试 1 (均匀网格，常数系数):\n  - 节点: $[0.0, 0.25, 0.5, 0.75, 1.0]$。\n  - 系数: 常数 $a=1.0$。\n- 测试 2 (非均匀网格，逐单元系数):\n  - 节点: $[0.0, 0.1, 0.4, 1.0]$。\n  - 逐单元系数: $[2.0, 1.0, 3.0]$。\n- 测试 3 (均匀网格，常数系数，小系统):\n  - 节点: $[0.0, 0.5, 1.0]$。\n  - 系数: 常数 $a=2.0$。\n- 测试 4 (周期性辨识下的退化边缘情况):\n  - 节点: $[0.0, 1.0]$。\n  - 系数: 常数 $a=1.0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，其中不含空格，每个元素本身是另一个用方括号括起来的逗号分隔列表，代表对应测试用例的展平缩减刚度矩阵。例如：$[[r_{1,1},\\dots,r_{1,M_1}], [r_{2,1},\\dots,r_{2,M_2}], [r_{3,1},\\dots,r_{3,M_3}], [r_{4,1},\\dots,r_{4,M_4}]]$，其中对于测试用例 $k$，$M_k=(N_k-1)^2$。", "solution": "该问题要求实现一个组装程序，用于在一维扩散问题下，考虑周期性边界条件时，生成缩减的全局刚度矩阵。该方法是使用线性 Lagrange 基函数的有限元法 (FEM)。解将按照指定要求从第一性原理推导。\n\n### 1. 框架与双线性形式\n\n给定一个由 $N$ 个节点 $x_1 < x_2 < \\dots < x_N$ 定义的一维域。控制物理过程是一个扩散过程，其弱形式由双线性形式 $B(u,v)$ 给出：\n$$\nB(u,v) = \\int_{x_1}^{x_N} a(x)\\, \\frac{du}{dx}\\, \\frac{dv}{dx}\\, dx\n$$\n这里，$u$ 是试探函数，$v$ 是检验函数。扩散系数 $a(x)$ 是正的，并假定在网格的每个单元上是分段常数。\n\n在有限元法中，我们将解 $u(x)$ 近似为基函数 $\\phi_j(x)$ 的线性组合：\n$$\nu(x) \\approx u_h(x) = \\sum_{j=1}^{N} u_j \\phi_j(x)\n$$\n其中 $u_j$ 是未知的节点值（自由度），$\\phi_j(x)$ 是线性 Lagrange（帽）基函数。帽函数 $\\phi_j(x)$ 在节点 $x_j$ 处等于 $1$，在所有其他节点 $x_k$ ($k \\neq j$) 处等于 $0$。\n\n将此展开式代入双线性形式，并对每个 $i \\in \\{1, \\dots, N\\}$ 取 $v = \\phi_i(x)$，得到代数系统 $K\\mathbf{u} = \\mathbf{f}$，其中全局刚度矩阵 $K$ 的元素由下式给出：\n$$\nK_{ij} = B(\\phi_j, \\phi_i) = \\int_{x_1}^{x_N} a(x)\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx\n$$\n该积分可以计算为网格上 $N-1$ 个单元的积分之和：\n$$\nK_{ij} = \\sum_{e=1}^{N-1} \\int_{x_e}^{x_{e+1}} a_e\\, \\frac{d\\phi_i}{dx}\\, \\frac{d\\phi_j}{dx}\\, dx\n$$\n其中 $a_e$ 是 $a(x)$ 在单元 $e = [x_e, x_{e+1}]$ 上的常数值。\n\n### 2. 单元刚度矩阵的推导\n\n只有当 $\\phi_i$ 和 $\\phi_j$ 导数的支集重叠时，$K_{ij}$ 的积分才不为零。对于线性帽函数，$\\phi_i$ 的支集是 $[x_{i-1}, x_{i+1}]$。这意味着我们只需要考虑每个单元上的局部贡献。\n\n让我们考虑一个跨越区间 $[x_e, x_{e+1}]$ 的通用单元 $e$。该单元的长度为 $h_e = x_{e+1} - x_e$。在此单元上，只有两个全局基函数非零：$\\phi_e(x)$ 和 $\\phi_{e+1}(x)$。我们将其在单元 $e$ 上的限制分别表示为局部基函数 $\\hat{\\phi}_1^{(e)}(x)$ 和 $\\hat{\\phi}_2^{(e)}(x)$。\n$$\n\\hat{\\phi}_1^{(e)}(x) = \\frac{x_{e+1} - x}{x_{e+1} - x_e} \\quad (\\text{对应于 } \\phi_e)\n$$\n$$\n\\hat{\\phi}_2^{(e)}(x) = \\frac{x - x_e}{x_{e+1} - x_e} \\quad (\\text{对应于 } \\phi_{e+1})\n$$\n它们在该单元上的导数是常数：\n$$\n\\frac{d\\hat{\\phi}_1^{(e)}}{dx} = -\\frac{1}{h_e} \\quad \\text{和} \\quad \\frac{d\\hat{\\phi}_2^{(e)}}{dx} = \\frac{1}{h_e}\n$$\n单元 $e$ 的 $2 \\times 2$ 单元刚度矩阵 $K^{(e)}$ 的元素为 $K_{ij}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\frac{d\\hat{\\phi}_i^{(e)}}{dx} \\frac{d\\hat{\\phi}_j^{(e)}}{dx} dx$。\n\n- $K_{11}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(-\\frac{1}{h_e}\\right)\\left(-\\frac{1}{h_e}\\right) dx = \\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = \\frac{a_e}{h_e^2} (h_e) = \\frac{a_e}{h_e}$。\n- $K_{12}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(-\\frac{1}{h_e}\\right)\\left(\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = -\\frac{a_e}{h_e}$。\n- $K_{21}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(\\frac{1}{h_e}\\right)\\left(-\\frac{1}{h_e}\\right) dx = -\\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = -\\frac{a_e}{h_e}$。\n- $K_{22}^{(e)} = \\int_{x_e}^{x_{e+1}} a_e \\left(\\frac{1}{h_e}\\right)\\left(\\frac{1}{h_e}\\right) dx = \\frac{a_e}{h_e^2} \\int_{x_e}^{x_{e+1}} dx = \\frac{a_e}{h_e}$。\n\n因此，单元刚度矩阵为：\n$$\nK^{(e)} = \\frac{a_e}{h_e}\n\\begin{bmatrix}\n1 & -1 \\\\\n-1 & 1\n\\end{bmatrix}\n$$\n\n### 3. 完整全局刚度矩阵的组装\n\n$N \\times N$ 的全局刚度矩阵 $K$ 是通过将其初始化为零，然后累加所有 $N-1$ 个单元的贡献来构建的。对于连接节点 $e$ 和 $e+1$ 的单元 $e$，其局部矩阵 $K^{(e)}$ 被加到全局矩阵的相应元素上。\n令 $c_e = a_e/h_e$，贡献为：\n- $K_{e,e} \\leftarrow K_{e,e} + c_e$\n- $K_{e,e+1} \\leftarrow K_{e,e+1} - c_e$\n- $K_{e+1,e} \\leftarrow K_{e+1,e} - c_e$\n- $K_{e+1,e+1} \\leftarrow K_{e+1,e+1} + c_e$\n\n此过程产生一个大小为 $N \\times N$ 的对称三对角矩阵 $K$。其非零元素为：\n- $K_{i,i} = c_{i-1} + c_i$ for $i=2, \\dots, N-1$\n- $K_{1,1} = c_1$\n- $K_{N,N} = c_{N-1}$\n- $K_{i,i+1} = K_{i+1,i} = -c_i$ for $i=1, \\dots, N-1$\n\n### 4. 施加周期性边界条件\n\n周期性边界条件为 $u(x_1) = u(x_N)$，这在代数层面转化为约束 $u_1 = u_N$。这意味着节点 $N$ 处的自由度不是独立的；它与节点 $1$ 处的自由度等同。因此，我们可以从系统中消除 $u_N$，将未知数的数量从 $N$减少到 $N-1$。\n\n问题指定了用于此缩减的代数过程。我们将完整的刚度矩阵 $K$ 和未知数向量 $\\mathbf{u}$ 分块如下：\n$$\nK = \\begin{bmatrix}\nA & b \\\\\nb^\\mathsf{T} & c\n\\end{bmatrix}, \\quad\n\\mathbf{u} = \\begin{bmatrix}\n\\mathbf{u}' \\\\\nu_N\n\\end{bmatrix}\n$$\n其中 $A$ 是一个 $(N-1) \\times (N-1)$ 矩阵，$b$ 是一个长度为 $N-1$ 的向量，$c$ 是一个标量，$\\mathbf{u}' = [u_1, u_2, \\dots, u_{N-1}]^\\mathsf{T}$。\n\n表示系统能量的二次型为 $\\frac{1}{2}\\mathbf{u}^\\mathsf{T}K\\mathbf{u}$。代入分块形式可得：\n$$\n\\frac{1}{2} \\left( (\\mathbf{u}')^\\mathsf{T}A\\mathbf{u}' + 2(\\mathbf{u}')^\\mathsf{T}b u_N + c u_N^2 \\right)\n$$\n现在，我们施加约束 $u_N=u_1$。未知数 $u_1$ 是 $\\mathbf{u}'$ 的第一个分量。使用向量 $e_1 = [1, 0, \\dots, 0]^\\mathsf{T} \\in \\mathbb{R}^{N-1}$，我们有 $u_1 = e_1^\\mathsf{T}\\mathbf{u}'$。将 $u_N = e_1^\\mathsf{T}\\mathbf{u}'$ 代入能量表达式，得到一个新的二次型 $\\frac{1}{2}(\\mathbf{u}')^\\mathsf{T}K_{red}\\mathbf{u}'$，其中 $K_{red}$ 是所求的 $(N-1)\\times(N-1)$ 缩减矩阵。\n\n与 $u_N$ 相关的项会修改原始矩阵 $A$：\n- 项 $2(\\mathbf{u}')^\\mathsf{T}b u_N$ 变为 $2(\\mathbf{u}')^\\mathsf{T}b (e_1^\\mathsf{T}\\mathbf{u}') = (\\mathbf{u}')^\\mathsf{T}(b e_1^\\mathsf{T} + e_1 b^\\mathsf{T})\\mathbf{u}'$。\n- 项 $c u_N^2$ 变为 $c(e_1^\\mathsf{T}\\mathbf{u}')^2 = (\\mathbf{u}')^\\mathsf{T}(c e_1 e_1^\\mathsf{T})\\mathbf{u}'$。\n\n结合这些修改，缩减的刚度矩阵 $K_{red}$ 由下式给出：\n$$\nK_{red} = A + b e_1^\\mathsf{T} + e_1 b^\\mathsf{T} + c e_1 e_1^\\mathsf{T}\n$$\n此矩阵运算转化为对子矩阵 $A$ 的以下修改：\n1.  将向量 $b$（$K$ 的最后一列的前 $N-1$ 个元素）加到 $A$ 的第一列。因此，$(K_{red})_{i,1} = A_{i,1} + b_i = K_{i,1} + K_{i,N}$ 对于 $i=1,\\dots,N-1$。\n2.  将向量 $b^\\mathsf{T}$（$K$ 的最后一行的前 $N-1$ 个元素）加到 $A$ 的第一行。因此，$(K_{red})_{1,j} = A_{1,j} + b_j = K_{1,j} + K_{j,N}$ 对于 $j=1,\\dots,N-1$。\n3.  将标量 $c$（元素 $K_{N,N}$）加到 $(1,1)$ 元素。\n由于 $K$ 是三对角矩阵，$b_i = K_{i,N}$ 仅在 $i=N-1$ 时非零。更新简化为：\n- $(K_{red})_{1,1}$ 变为 $K_{1,1} + K_{N,N}$。\n- $(K_{red})_{1,N-1}$ 变为 $K_{1,N-1} + K_{N-1,N}$。\n- $(K_{red})_{N-1,1}$ 变为 $K_{N-1,1} + K_{N,N-1}$。\n- 所有其他元素与 $A$ 中的保持不变。\n\n这个代数过程等效于从一开始就在周期域上组装矩阵，其中一个额外的单元连接节点 $N$ 和节点 $1$，从而验证了所规定的方法。\n\n实现将遵循此过程：首先，为线性网格组装 $N \\times N$ 矩阵 $K$，然后应用代数缩减以获得 $(N-1) \\times (N-1)$ 的周期性刚度矩阵 $K_{red}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_and_reduce(nodes: list[float], coeffs: list[float] | float) -> list[float]:\n    \"\"\"\n    Assembles the reduced stiffness matrix for a 1D diffusion problem with periodic BCs.\n\n    Args:\n        nodes: A list of N node coordinates, strictly increasing.\n        coeffs: A single coefficient 'a' for all elements, or a list of N-1\n                elementwise coefficients.\n\n    Returns:\n        The (N-1)x(N-1) reduced stiffness matrix, flattened in row-major order\n        and rounded to 10 decimal places.\n    \"\"\"\n    N = len(nodes)\n\n    if N  2:\n        # A problem with  2 nodes has no elements and an empty reduced matrix.\n        return []\n\n    num_elements = N - 1\n    element_coeffs = []\n    if isinstance(coeffs, (int, float)):\n        element_coeffs = [float(coeffs)] * num_elements\n    else:\n        element_coeffs = [float(c) for c in coeffs]\n\n    # Step 1: Assemble the full NxN global stiffness matrix (for Neumann BCs)\n    K_full = np.zeros((N, N), dtype=np.float64)\n\n    for e in range(num_elements):\n        # Node indices for element e are e and e+1 (0-based)\n        node_i, node_j = e, e + 1\n        \n        # Calculate element length h_e\n        h_e = nodes[node_j] - nodes[node_i]\n        \n        # Get diffusion coefficient a_e\n        a_e = element_coeffs[e]\n\n        # Calculate the derived constant c_e = a_e / h_e\n        c_e = a_e / h_e\n\n        # The element stiffness matrix is c_e * [[1, -1], [-1, 1]]\n        # Add its contributions to the global matrix\n        K_full[node_i, node_i] += c_e\n        K_full[node_i, node_j] -= c_e\n        K_full[node_j, node_i] -= c_e\n        K_full[node_j, node_j] += c_e\n        \n    # Step 2: Enforce periodic BC u_N = u_1 by algebraic reduction\n    if N == 2:\n        # Special case for N=2 gives a 1x1 reduced matrix.\n        # K_red[0,0] = K_11 + 2*K_12 + K_22\n        k_red_scalar = K_full[0, 0] + 2 * K_full[0, 1] + K_full[1, 1]\n        K_red = np.array([[k_red_scalar]], dtype=np.float64)\n    else:\n        # General case for N > 2\n        # Partition K_full into A, b, c\n        A = K_full[:N-1, :N-1]\n        b = K_full[:N-1, N-1]  # Last column (without corner)\n        c = K_full[N-1, N-1]   # Corner element\n\n        # Start with the upper-left (N-1)x(N-1) block\n        K_red = A.copy()\n        \n        # Apply the reduction formula derived from energy conservation:\n        # K_red = A + b*e1^T + e1*b^T + c*e1*e1^T\n        # This translates to modifying the first row and column of A\n        # and its top-left element.\n        \n        # Add b to the first column of K_red\n        K_red[:, 0] += b\n        # Add b^T to the first row of K_red\n        K_red[0, :] += b\n        # Add c to the top-left element\n        K_red[0, 0] += c\n    \n    # Step 3: Flatten and round the result\n    flattened_matrix = K_red.flatten()\n    rounded_matrix = np.round(flattened_matrix, 10).tolist()\n    \n    return rounded_matrix\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        { \"nodes\": [0.0, 0.25, 0.5, 0.75, 1.0], \"coeffs\": 1.0 },\n        { \"nodes\": [0.0, 0.1, 0.4, 1.0], \"coeffs\": [2.0, 1.0, 3.0] },\n        { \"nodes\": [0.0, 0.5, 1.0], \"coeffs\": 2.0 },\n        { \"nodes\": [0.0, 1.0], \"coeffs\": 1.0 }\n    ]\n\n    all_results_str = []\n    for case in test_cases:\n        nodes = case[\"nodes\"]\n        coeffs = case[\"coeffs\"]\n        \n        # Calculate the flattened reduced matrix for the current case\n        result_list = assemble_and_reduce(nodes, coeffs)\n        \n        # Format the list of numbers into the required string format '[n1,n2,...]'\n        result_str = f\"[{','.join(map(str, result_list))}]\"\n        all_results_str.append(result_str)\n\n    # Final print statement in the exact required format '[[...],[...],...]'\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "3206698"}, {"introduction": "最后，让我们将技能提升到解决真实世界问题的维度——三维空间。此练习是一个综合性的挑战，要求您为三维四面体网格实现刚度矩阵的组装。您将接触到有限元方法的核心技术之一：从参考单元到物理单元的雅可比映射。成功完成这个练习意味着您已经具备了构建复杂几何形状下有限元模型的基本能力，为进行高级工程与科学计算奠定了坚实的基础。[@problem_id:3206634]", "problem": "考虑在一个多面体域 $\\Omega \\subset \\mathbb{R}^3$ 上的标量扩散偏微分方程（PDE）$- \\nabla \\cdot (\\kappa \\nabla u) = f$，其在边界 $\\partial \\Omega$ 上具有狄利克雷（Dirichlet）边界数据 $u = g$。使用标准的伽辽金有限元法（FEM），以及一阶（分片线性）四面体单元，组装全局刚度矩阵。组装过程必须源自从该偏微分方程导出的弱形式，不得使用任何快捷公式。\n\n从弱形式出发：求解 $u \\in H^1(\\Omega)$，使得在 $\\partial \\Omega$ 上有 $u = g$，并且对于所有 $v \\in H_0^1(\\Omega)$，满足\n$$\na(u,v) = \\ell(v)，\n$$\n其中\n$$\na(u,v) = \\int_{\\Omega} \\kappa \\, \\nabla u \\cdot \\nabla v \\, \\mathrm{d}x, \\qquad \\ell(v) = \\int_{\\Omega} f \\, v \\, \\mathrm{d}x.\n$$\n使用 $N$ 个节点和 $M$ 个四面体进行离散化。对于每个顶点为 $\\mathbf{x}_1, \\mathbf{x}_2, \\mathbf{x}_3, \\mathbf{x}_4 \\in \\mathbb{R}^3$ 的四面体，通过雅可比矩阵\n$$\nJ = \\begin{bmatrix} \\mathbf{x}_2 - \\mathbf{x}_1  \\mathbf{x}_3 - \\mathbf{x}_1  \\mathbf{x}_4 - \\mathbf{x}_1 \\end{bmatrix} \\in \\mathbb{R}^{3 \\times 3}\n$$\n定义从参考四面体（其顶点为 $(0,0,0)$, $(1,0,0)$, $(0,1,0)$, $(0,0,1)$）到该四面体的仿射映射。\n令 $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$ 为参考形函数的梯度。物理梯度为\n$$\n\\nabla N_i = J^{-\\top} \\nabla \\hat{N}_i, \\quad i \\in \\{1,2,3,4\\},\n$$\n物理四面体的体积为\n$$\n|T| = \\frac{|\\det(J)|}{6}.\n$$\n利用这些，单元刚度矩阵的项为\n$$\nK_e(i,j) = \\kappa_e \\, |T| \\, \\nabla N_i \\cdot \\nabla N_j, \\quad i,j \\in \\{1,2,3,4\\},\n$$\n其中 $\\kappa_e$ 是该四面体上的常数扩散系数。通过根据所有单元的连接关系对它们的贡献求和，来组装全局刚度矩阵 $K \\in \\mathbb{R}^{N \\times N}$。\n\n为了在一组边界节点 $G$ 上施加具有规定值 $\\{g_k\\}_{k \\in G}$ 的狄利克雷边界条件，将节点的索引集划分为自由节点 $F$ 和边界节点 $G$，并求解从离散弱形式中获得的简化线性系统：\n$$\nK_{FF} \\, u_F = b_F - K_{FG} \\, u_G,\n$$\n其中 $b$ 是全局载荷向量，其项为 $b_i = \\int_{\\Omega} f N_i \\, \\mathrm{d}x$。在本问题中，使用 $f \\equiv 0$，因此 $b = 0$。自由节点上的最终内部解是 $u_F$，而完整的节点场可以通过将 $u_F$ 与规定的 $u_G$ 组合得到。\n\n请实现所述的组装和狄利克雷条件施加过程，并为以下测试套件生成特定的量化输出。在整个过程中，使用解析函数 $u^\\star(x,y,z) = x + y + z$ 来定义边界节点上的狄利克雷数据 $g(\\mathbf{x}) = u^\\star(\\mathbf{x})$。\n\n测试套件：\n- 情况 A（单个四面体）：\n  - 节点（索引 $0$ 到 $3$）：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$。\n  - 单元：一个四面体，连接关系为 $[0,1,2,3]$。\n  - 单元扩散系数：$\\kappa = 2$。\n  - 狄利克雷边界节点：$G = \\{0,1,2,3\\}$，其中 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$。\n  - 右侧项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装后的全局刚度矩阵 $K$ 的弗罗贝尼乌斯范数（Frobenius norm）$\\|K\\|_F$。\n    2. 自由节点上的最大绝对误差，定义为 $\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$。如果 $F$ 为空，则将此值定义为 $0$。\n\n- 情况 B（一个由一个内部节点细分的四面体）：\n  - 节点（索引 $0$ 到 $4$）：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$, $\\mathbf{x}_4 = (0.25,0.25,0.25)$。\n  - 单元：四个四面体，连接关系为 $[4,1,2,3]$, $[4,0,2,3]$, $[4,0,1,3]$, $[4,0,1,2]$。\n  - 单元扩散系数：每个四面体均为 $\\kappa = 1$。\n  - 狄利克雷边界节点：$G = \\{0,1,2,3\\}$，其中 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$；内部节点为 $4$。\n  - 右侧项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装后的全局刚度矩阵 $K$ 的弗罗贝尼乌斯范数 $\\|K\\|_F$。\n    2. 自由节点 $F = \\{4\\}$ 上的最大绝对误差，定义为 $|u_F(4) - u^\\star(\\mathbf{x}_4)|$。\n\n- 情况 C（一个近乎退化的薄片四面体）：\n  - 节点（索引 $0$ 到 $3$）：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (10^{-6},0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$。\n  - 单元：一个四面体，连接关系为 $[0,1,2,3]$。\n  - 单元扩散系数：$\\kappa = 1$。\n  - 狄利克雷边界节点：$G = \\{0,1,2,3\\}$，其中 $u_G = \\{u^\\star(\\mathbf{x}_k)\\}_{k \\in G}$。\n  - 右侧项：$f \\equiv 0$。\n  - 需要计算的输出：\n    1. 组装后的全局刚度矩阵 $K$ 的弗罗贝尼乌斯范数 $\\|K\\|_F$。\n    2. 自由节点上的最大绝对误差；由于 $F$ 为空，将此值定义为 $0$。\n\n您的程序必须如上所述实现三维四面体的有限元组装，构建全局刚度矩阵，通过系统划分施加狄利克雷边界条件，在适用时求解内部节点值，并为每种情况计算上述的一对输出。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\|K\\|_F^{(A)}, \\mathrm{err}^{(A)}, \\|K\\|_F^{(B)}, \\mathrm{err}^{(B)}, \\|K\\|_F^{(C)}, \\mathrm{err}^{(C)}]$。不涉及物理单位；所有量均为无量纲实数。不使用角度。输出为实值浮点数。", "solution": "问题陈述经过了仔细验证，并被确定为有效。它在科学上基于求解偏微分方程的有限元法（FEM）原理，是适定的（well-posed），具有一套完整且一致的数据和定义，并以客观、正式的语言表述。所提供的关于仿射映射、物理梯度、单元体积和单元刚度矩阵的公式对于一阶（P1）四面体单元是标准且正确的。测试用例定义明确，用于对照参考单元、带有一个内部节点的网格以及一个几何上退化的单元来验证实现。\n\n任务是为标量扩散方程 $- \\nabla \\cdot (\\kappa \\nabla u) = f$ 实现全局刚度矩阵的组装，该方程使用有限元法在四面体网格上通过分片线性基函数进行离散化。组装后的矩阵随后用于在施加狄利克雷边界条件后求解未知的节点值。要求的具体输出是全局刚度矩阵的弗罗贝尼乌斯范数以及三种不同测试用例下内部节点的最大误差。\n\n通用步骤如下：\n1.  初始化一个 $N \\times N$ 的全局刚度矩阵 $K$，所有项均设为零，其中 $N$ 是网格中的总节点数。\n2.  遍历网格中的每个四面体（单元）$T_e$。对每个单元：\n    a. 从单元连接关系列表中识别其四个顶点的全局索引，$[n_1, n_2, n_3, n_4]$。\n    b. 获取这些顶点的坐标：$\\mathbf{x}_{n_1}, \\mathbf{x}_{n_2}, \\mathbf{x}_{n_3}, \\mathbf{x}_{n_4}$。\n    c. 构成从参考四面体到物理四面体 $T_e$ 的仿射映射的雅可比矩阵 $J_e$。问题将其定义为 $J_e = \\begin{bmatrix} \\mathbf{x}_{n_2} - \\mathbf{x}_{n_1}  \\mathbf{x}_{n_3} - \\mathbf{x}_{n_1}  \\mathbf{x}_{n_4} - \\mathbf{x}_{n_1} \\end{bmatrix}$。\n    d. 计算单元的体积，$|T_e| = \\frac{|\\det(J_e)|}{6}$。\n    e. 计算雅可比矩阵的逆转置，$J_e^{-\\top}$。\n    f. 通过使用关系式 $\\nabla N_i = J_e^{-\\top} \\nabla \\hat{N}_i$ 变换参考梯度 $\\nabla \\hat{N}_i$，来确定四个物理基函数的梯度 $\\nabla N_i$。参考梯度给定为 $\\nabla \\hat{N}_1 = (-1,-1,-1)^\\top$, $\\nabla \\hat{N}_2 = (1,0,0)^\\top$, $\\nabla \\hat{N}_3 = (0,1,0)^\\top$, $\\nabla \\hat{N}_4 = (0,0,1)^\\top$。\n    g. 计算 $4 \\times 4$ 的单元刚度矩阵 $K_e$，其项由 $K_e(i,j) = \\kappa_e |T_e| (\\nabla N_i \\cdot \\nabla N_j)$ 给出，其中 $\\kappa_e$ 是单元 $T_e$ 上的常数扩散系数。以矩阵形式，这可以写为 $K_e = \\kappa_e |T_e| G_e^\\top G_e$，其中 $G_e = \\begin{bmatrix} \\nabla N_1  \\nabla N_2  \\nabla N_3  \\nabla N_4 \\end{bmatrix}$ 是物理基函数梯度的 $3 \\times 4$ 矩阵。\n    h. 将 $K_e$ 的贡献累加到全局刚度矩阵 $K$ 中。对于每个项 $K_e(i,j)$，其值被加到全局项 $K(n_i, n_j)$ 上。\n3.  遍历所有单元后，计算组装完成的全局矩阵 $K$ 的弗罗贝尼乌斯范数，$\\|K\\|_F = \\sqrt{\\sum_{i,j=1}^N |K_{ij}|^2}$。\n4.  为了求解，将节点划分为一组自由（内部）节点 $F$ 和一组狄利克雷边界节点 $G$。问题使用的源项为 $f \\equiv 0$，因此载荷向量为零。为求解自由节点值 $u_F$ 所需解的系统是 $K_{FF} u_F = -K_{FG} u_G$，其中 $K_{FF}$ 和 $K_{FG}$ 是 $K$ 的子矩阵，而 $u_G$ 是边界节点上规定值的向量。规定值由解析函数 $u^\\star(x,y,z) = x+y+z$ 导出。\n5.  在求解出 $u_F$ 后，计算自由节点上的最大绝对误差：$\\max_{i \\in F} |u_F(i) - u^\\star(\\mathbf{x}_i)|$。如果集合 $F$ 为空，则此误差定义为 $0$。\n\n**情况 A：单个参考四面体**\n-   节点：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (1,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$。$N=4$。\n-   连接关系：$[0,1,2,3]$。\n-   雅可比矩阵为 $J = [\\mathbf{x}_1-\\mathbf{x}_0 \\ \\ \\mathbf{x}_2-\\mathbf{x}_0 \\ \\ \\mathbf{x}_3-\\mathbf{x}_0] = \\begin{pmatrix} 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} = I_3$。\n-   单元体积为 $|T| = |\\det(I_3)|/6 = 1/6$。\n-   由于 $J^{-\\top} = I_3$，物理梯度与参考梯度相同。\n-   单元刚度矩阵为 $K_e(i,j) = \\kappa_e |T| (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$。当 $\\kappa=2$ 且 $|T|=1/6$ 时，该矩阵为 $K_e(i,j) = \\frac{1}{3} (\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$。\n-   点积矩阵 $(\\nabla \\hat{N}_i \\cdot \\nabla \\hat{N}_j)$ 为 $\\begin{pmatrix} 3  -1  -1  -1 \\\\ -1  1  0  0 \\\\ -1  0  1  0 \\\\ -1  0  0  1 \\end{pmatrix}$。\n-   因此，$K_e = \\frac{1}{3} \\begin{pmatrix} 3  -1  -1  -1 \\\\ -1  1  0  0 \\\\ -1  0  1  0 \\\\ -1  0  0  1 \\end{pmatrix} = \\begin{pmatrix} 1  -1/3  -1/3  -1/3 \\\\ -1/3  1/3  0  0 \\\\ -1/3  0  1/3  0 \\\\ -1/3  0  0  1/3 \\end{pmatrix}$。\n-   由于只有一个单元，全局矩阵 $K$ 等于 $K_e$。\n-   弗罗贝尼乌斯范数为 $\\|K\\|_F = \\sqrt{1^2 + 4 \\times (-1/3)^2 + 3 \\times (1/3)^2} = \\sqrt{1 + 4/9 + 3/9} = \\sqrt{16/9} = 4/3$。\n-   所有节点都是狄利克雷节点，因此自由节点集 $F$ 为空。误差为 $0$。\n-   结果：$\\|K\\|_F = 4/3 \\approx 1.3333$，误差 $= 0.0$。\n\n**情况 B：细分的四面体**\n-   区域与情况 A 中的参考四面体相同，但它被一个内部节点 $\\mathbf{x}_4 = (0.25, 0.25, 0.25)$ 细分为四个更小的四面体。\n-   共有 $N=5$ 个节点。节点 $4$ 是唯一的自由节点 ($F=\\{4\\}$)，而节点 $0, 1, 2, 3$ 是狄利克雷节点 ($G=\\{0,1,2,3\\}$)。\n-   全局刚度矩阵 $K$ 是一个 $5 \\times 5$ 矩阵，由四个单元的贡献组装而成。四个单元刚度矩阵中每一个的计算以及它们到 $K$ 中的求和都是通过计算完成的。\n-   该偏微分方程的解析解是 $u^\\star(x,y,z) = x+y+z$。由于 $u^\\star$ 是一个线性函数，它可以被分片线性有限元基完美表示。因此，有限元解必须是精确的，即内部节点 $u_4$ 处的计算值必须等于解析值 $u^\\star(\\mathbf{x}_4)$。\n-   $u^\\star(\\mathbf{x}_4) = 0.25 + 0.25 + 0.25 = 0.75$。\n-   $u_4$ 的解从单一方程 $K_{44}u_4 = -(K_{40}u_0 + K_{41}u_1 + K_{42}u_2 + K_{43}u_3)$ 中获得。当 $u_0=0, u_1=1, u_2=1, u_3=1$ 时，这变为 $K_{44}u_4 = -(K_{41}+K_{42}+K_{43})$。由于重心细分和网格对称性，可以证明 $K_{40} = K_{41} = K_{42} = K_{43}$，并且行和为零（$K_{40}+K_{41}+K_{42}+K_{43}+K_{44}=0$）。这些性质导致 $u_4 = 0.75$。\n-   因此，误差预期为 $0$（在浮点精度范围内）。弗罗贝尼乌斯范数 $\\|K\\|_F$ 通过数值计算得出。\n\n**情况 C：薄片四面体**\n-   节点：$\\mathbf{x}_0 = (0,0,0)$, $\\mathbf{x}_1 = (\\epsilon,0,0)$, $\\mathbf{x}_2 = (0,1,0)$, $\\mathbf{x}_3 = (0,0,1)$，其中 $\\epsilon=10^{-6}$。\n-   雅可比矩阵是一个对角矩阵 $J = \\text{diag}(\\epsilon, 1, 1)$。其行列式为 $\\det(J) = \\epsilon$。\n-   单元体积为 $|T| = |\\det(J)|/6 = \\epsilon/6$。\n-   逆转置是 $J^{-\\top} = \\text{diag}(1/\\epsilon, 1, 1)$。\n-   物理梯度被各向异性地缩放。例如，$\\nabla N_2 = J^{-\\top}(1,0,0)^\\top = (1/\\epsilon, 0, 0)^\\top$。\n-   当 $\\kappa=1$ 时，单元刚度矩阵为 $K_e = \\frac{\\epsilon}{6} G_e^\\top G_e$，其计算结果为：\n$$ K = K_e = \\begin{pmatrix} \\frac{1}{6\\epsilon} + \\frac{\\epsilon}{3}  -\\frac{1}{6\\epsilon}  -\\frac{\\epsilon}{6}  -\\frac{\\epsilon}{6} \\\\ -\\frac{1}{6\\epsilon}  \\frac{1}{6\\epsilon}  0  0 \\\\ -\\frac{\\epsilon}{6}  0  \\frac{\\epsilon}{6}  0 \\\\ -\\frac{\\epsilon}{6}  0  0  \\frac{\\epsilon}{6} \\end{pmatrix} $$\n-   弗罗贝尼乌斯范数的平方为 $\\|K\\|_F^2 = \\sum_{i,j} K_{ij}^2 = \\frac{1}{9\\epsilon^2} + \\frac{1}{9} + \\frac{2\\epsilon^2}{9} = \\frac{1}{9}(\\frac{1}{\\epsilon^2} + 1 + 2\\epsilon^2)$。\n-   对于 $\\epsilon=10^{-6}$，$\\|K\\|_F = \\frac{1}{3}\\sqrt{10^{12} + 1 + 2 \\times 10^{-12}} \\approx 10^6/3$。\n-   与情况 A 一样，所有节点都是狄利克雷边界节点，所以 $F$ 为空，误差为 $0$。\n-   结果：$\\|K\\|_F \\approx 333333.3333$，误差 $= 0.0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(nodes, elements, kappas, dirichlet_nodes):\n    \"\"\"\n    Assembles the global stiffness matrix and solves the FEM system for a given case.\n\n    Args:\n        nodes (list of tuples): Coordinates of the mesh nodes.\n        elements (list of lists): Connectivity of the mesh elements (tetrahedra).\n        kappas (list of floats): Diffusion coefficient for each element.\n        dirichlet_nodes (set): Set of global indices for nodes with Dirichlet BCs.\n\n    Returns:\n        tuple: A tuple containing (Frobenius norm of K, max absolute error at free nodes).\n    \"\"\"\n    num_nodes = len(nodes)\n    K = np.zeros((num_nodes, num_nodes))\n    node_coords = np.array(nodes)\n\n    # Gradients of the basis functions on the reference tetrahedron\n    grad_N_hat = np.array([\n        [-1, 1, 0, 0],\n        [-1, 0, 1, 0],\n        [-1, 0, 0, 1]\n    ])\n\n    for i, conn in enumerate(elements):\n        # Get element properties\n        kappa_e = kappas[i]\n        \n        # Get coordinates of the element's nodes\n        x0, x1, x2, x3 = node_coords[conn]\n\n        # Form the Jacobian matrix\n        J = np.array([x1 - x0, x2 - x0, x3 - x0]).T\n        \n        if np.linalg.det(J) == 0:\n            # Handle degenerate element if necessary, though not expected in tests\n            continue\n\n        # Compute volume and inverse transpose of Jacobian\n        volume = np.abs(np.linalg.det(J)) / 6.0\n        J_inv_T = np.linalg.inv(J).T\n        \n        # Compute gradients of physical basis functions\n        grad_N_phys = J_inv_T @ grad_N_hat\n        \n        # Compute element stiffness matrix\n        # Ke_ij = kappa * volume * (grad_N_phys_i . grad_N_phys_j)\n        Ke = kappa_e * volume * (grad_N_phys.T @ grad_N_phys)\n\n        # Assemble Ke into the global stiffness matrix K\n        for r_local in range(4):\n            r_global = conn[r_local]\n            for c_local in range(4):\n                c_global = conn[c_local]\n                K[r_global, c_global] += Ke[r_local, c_local]\n    \n    # --- 1. Compute Frobenius norm ---\n    frobenius_norm = np.linalg.norm(K, 'fro')\n\n    # --- 2. Compute solution and error ---\n    all_nodes = set(range(num_nodes))\n    free_nodes = sorted(list(all_nodes - dirichlet_nodes))\n    \n    if not free_nodes:\n        error = 0.0\n    else:\n        # Define the exact solution function\n        def u_star(coord):\n            return sum(coord)\n\n        # Partition the system\n        G = sorted(list(dirichlet_nodes))\n        \n        K_FF = K[np.ix_(free_nodes, free_nodes)]\n        K_FG = K[np.ix_(free_nodes, G)]\n\n        # Get prescribed boundary values from exact solution\n        u_G = np.array([u_star(node_coords[i]) for i in G])\n        \n        # The source term f is zero, so the load vector b is zero\n        # The right-hand side for the reduced system comes from boundary values\n        rhs = -K_FG @ u_G\n        \n        # Solve for the interior nodes\n        u_F = np.linalg.solve(K_FF, rhs)\n\n        # Compute error\n        u_star_F = np.array([u_star(node_coords[i]) for i in free_nodes])\n        error = np.max(np.abs(u_F - u_star_F))\n\n    return frobenius_norm, error\n\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the FEM stiffness matrix assembly problem.\n    \"\"\"\n    test_cases = [\n        # Case A: single tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [2.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case B: a tetrahedron subdivided by one interior node\n        {\n            \"nodes\": [(0,0,0), (1,0,0), (0,1,0), (0,0,1), (0.25,0.25,0.25)],\n            \"elements\": [\n                [4,1,2,3], [4,0,2,3], [4,0,1,3], [4,0,1,2]\n            ],\n            \"kappas\": [1.0, 1.0, 1.0, 1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        },\n        # Case C: a near-degenerate sliver tetrahedron\n        {\n            \"nodes\": [(0,0,0), (1e-6,0,0), (0,1,0), (0,0,1)],\n            \"elements\": [[0,1,2,3]],\n            \"kappas\": [1.0],\n            \"dirichlet_nodes\": {0,1,2,3}\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        norm, err = process_case(**case)\n        results.append(norm)\n        results.append(err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3206634"}]}