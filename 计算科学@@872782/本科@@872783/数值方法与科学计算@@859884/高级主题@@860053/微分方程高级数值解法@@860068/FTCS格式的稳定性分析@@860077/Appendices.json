{"hands_on_practices": [{"introduction": "稳定性分析的基石在于理解误差（可表示为不同频率模式的叠加）如何随时间增长或衰减。本练习将引导你掌握一个基本工具：增长因子。通过推导和计算该因子，我们能够精确预测当稳定性条件被违反时，哪些模式会首先变得不稳定。[@problem_id:3278053]", "problem": "考虑在一维周期性域（长度为 $L$）上的热传导方程 $u_{t}=\\kappa\\,u_{xx}$，该方程在一个具有 $N=8$ 个点、间距为 $\\Delta x=L/N$ 的均匀网格上进行离散化。前向时间中心空间（FTCS）格式通过以下公式来推进解：\n$$\nu_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right),\n$$\n其中 $r=\\kappa\\,\\Delta t/\\Delta x^{2}$。对于给定的离散傅里叶模态，其单步增长因子定义为一个时间步长之后模态的振幅与该步长之前振幅的比值。\n\n设 $r=0.51$，并考虑由 $m=0,1,2,3,4$ 索引的离散傅里叶模态，其相位为 $\\theta_{m}=2\\pi m/N$。从控制方程和FTCS更新格式出发，推导出一个一般离散傅里叶模态的单步增长因子，并计算 $m=0,1,2,3,4$ 时的增长因子。找出第一个发散的模态，即在这些模态中，其单步增长因子的绝对值大于1且为最大的那个模态。将最终答案报告为模态指数 $m$。无需四舍五入。", "solution": "首先对问题进行验证，以确保其是适定的、有科学依据的，并且包含了得到唯一解所需的所有信息。\n\n**问题验证**\n\n*   **提取的已知条件：**\n    *   控制方程：$u_{t}=\\kappa\\,u_{xx}$\n    *   区域：长度为 $L$ 的一维周期性域\n    *   离散化：均匀网格，$N=8$ 个点，间距 $\\Delta x=L/N$\n    *   数值格式：FTCS，$u_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right)$\n    *   Courant-Friedrichs-Lewy (CFL) 数定义：$r=\\kappa\\,\\Delta t/\\Delta x^{2}$\n    *   特定的CFL数：$r=0.51$\n    *   用于分析的模态：由 $m=0,1,2,3,4$ 索引的离散傅里叶模态\n    *   模态相位定义：$\\theta_{m}=2\\pi m/N$\n    *   目标：推导单步增长因子，为指定的模态计算该因子，并找出第一个发散的模态（定义为增长因子绝对值大于1且最大的模态）。\n\n*   **验证结论：**\n    该问题是 **有效的**。这是一个关于有限差分格式的 von Neumann 稳定性分析的标准练习，是数值分析中的一个核心课题。所有参数和定义都是清晰、一致的，并且足以推导出唯一的答案。所选的 $r=0.51$ 值略高于FTCS格式的理论稳定性阈值 $r=0.5$，这是研究数值不稳定性时一个合理且常见的情景。\n\n**求解推导**\n\n为了确定单步增长因子，我们进行 von Neumann 稳定性分析。我们将单个离散傅里叶模态视为有限差分方程的一个解。对应于指数 $m$ 的一个通用模态可以写成：\n$$\nu_i^n = A_m^n \\exp(I i \\theta_m)\n$$\n其中 $A_m^n$ 是模态 $m$ 在时间步 $n$ 处的振幅，$i$ 是空间网格指数，$I$ 是虚数单位（$I^2 = -1$），$\\theta_m$ 是模态 $m$ 的相位。我们记为 $G_m$ 的单步增长因子是连续时间步长上振幅的比值，即 $G_m = A_m^{n+1} / A_m^n$。因此，我们可以将 $u_i^{n+1}$ 写为：\n$$\nu_i^{n+1} = A_m^{n+1} \\exp(I i \\theta_m) = G_m A_m^n \\exp(I i \\theta_m)\n$$\n我们将 $u_i^n$ 和 $u_i^{n+1}$ 的这些形式代入FTCS格式中：\n$$\nu_{i}^{n+1}=u_{i}^{n}+r\\left(u_{i+1}^{n}-2u_{i}^{n}+u_{i-1}^{n}\\right)\n$$\n$$\nG_m A_m^n \\exp(I i \\theta_m) = A_m^n \\exp(I i \\theta_m) + r \\left[ A_m^n \\exp(I (i+1) \\theta_m) - 2 A_m^n \\exp(I i \\theta_m) + A_m^n \\exp(I (i-1) \\theta_m) \\right]\n$$\n将整个方程除以公共非零因子 $A_m^n \\exp(I i \\theta_m)$，得到增长因子 $G_m$ 的表达式：\n$$\nG_m = 1 + r \\left[ \\exp(I \\theta_m) - 2 + \\exp(-I \\theta_m) \\right]\n$$\n使用欧拉公式 $\\exp(I\\theta) + \\exp(-I\\theta) = 2\\cos(\\theta)$，我们简化括号中的表达式：\n$$\nG_m = 1 + r \\left[ 2\\cos(\\theta_m) - 2 \\right] = 1 - 2r \\left[ 1 - \\cos(\\theta_m) \\right]\n$$\n我们应用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$：\n$$\nG_m = 1 - 4r \\sin^2\\left(\\frac{\\theta_m}{2}\\right)\n$$\n这就是相位为 $\\theta_m$ 的离散傅里叶模态的单步增长因子的一般表达式。\n\n问题给出了具体参数 $r=0.51$ 和 $N=8$，并要求分析模态 $m \\in \\{0,1,2,3,4\\}$。相角为 $\\theta_m = 2\\pi m/N = 2\\pi m/8 = \\pi m/4$。\n将这些值代入 $G_m$ 的表达式中：\n$$\nG_m = 1 - 4(0.51) \\sin^2\\left(\\frac{\\pi m/4}{2}\\right) = 1 - 2.04 \\sin^2\\left(\\frac{\\pi m}{8}\\right)\n$$\n一个模态是稳定的，当且仅当其增长因子的绝对值小于或等于1，即 $|G_m| \\le 1$。现在我们为每个指定的模态计算 $G_m$ 及其绝对值。\n\n*   **模态 $m=0$：**\n    $\\theta_0 = 0$。\n    $G_0 = 1 - 2.04 \\sin^2(0) = 1 - 0 = 1$。\n    $|G_0| = 1$。该模态是中性稳定的。\n\n*   **模态 $m=1$：**\n    $\\theta_1 = \\pi/4$。\n    $G_1 = 1 - 2.04 \\sin^2(\\pi/8)$。使用 $\\sin^2(x) = (1-\\cos(2x))/2$，我们有 $\\sin^2(\\pi/8) = (1-\\cos(\\pi/4))/2 = (1-\\sqrt{2}/2)/2 = (2-\\sqrt{2})/4$。\n    $G_1 = 1 - 2.04 \\left(\\frac{2-\\sqrt{2}}{4}\\right) = 1 - 0.51(2 - \\sqrt{2}) = 1 - 1.02 + 0.51\\sqrt{2} = -0.02 + 0.51\\sqrt{2}$。\n    由于 $\\sqrt{2} \\approx 1.414$，$G_1 \\approx -0.02 + 0.51(1.414) \\approx 0.701$。显然，$|G_1|  1$。该模态是稳定的。\n\n*   **模态 $m=2$：**\n    $\\theta_2 = 2\\pi/4 = \\pi/2$。\n    $G_2 = 1 - 2.04 \\sin^2(\\pi/4) = 1 - 2.04 (\\frac{\\sqrt{2}}{2})^2 = 1 - 2.04(\\frac{1}{2}) = 1 - 1.02 = -0.02$。\n    $|G_2| = 0.02  1$。该模态是稳定的。\n\n*   **模态 $m=3$：**\n    $\\theta_3 = 3\\pi/4$。\n    $G_3 = 1 - 2.04 \\sin^2(3\\pi/8)$。使用 $\\sin^2(x) = (1-\\cos(2x))/2$，我们有 $\\sin^2(3\\pi/8) = (1-\\cos(3\\pi/4))/2 = (1-(-\\sqrt{2}/2))/2 = (2+\\sqrt{2})/4$。\n    $G_3 = 1 - 2.04 \\left(\\frac{2+\\sqrt{2}}{4}\\right) = 1 - 0.51(2 + \\sqrt{2}) = 1 - 1.02 - 0.51\\sqrt{2} = -0.02 - 0.51\\sqrt{2}$。\n    $|G_3| = |-0.02 - 0.51\\sqrt{2}| = 0.02 + 0.51\\sqrt{2}$。由于 $0.51\\sqrt{2} \\approx 0.72$，所以 $|G_3| \\approx 0.74  1$。该模态是稳定的。\n\n*   **模态 $m=4$：**\n    $\\theta_4 = 4\\pi/4 = \\pi$。\n    $G_4 = 1 - 2.04 \\sin^2(\\pi/2) = 1 - 2.04 (1)^2 = 1 - 2.04 = -1.04$。\n    $|G_4| = |-1.04| = 1.04 > 1$。该模态是不稳定的。\n\n问题要求在 $m=0,1,2,3,4$ 中找出那个发散的模态，其定义为 $|G_m| > 1$ 且具有最大绝对值的模态。回顾我们的计算：\n*   $|G_0| = 1$\n*   $|G_1|  1$\n*   $|G_2|  1$\n*   $|G_3|  1$\n*   $|G_4| = 1.04$\n\n在所考虑的模态中，$m=4$ 是唯一一个增长因子绝对值大于1的模态。因此，根据问题的定义，它是第一个发散的模态。这个结果与FTCS格式的一般稳定性分析是一致的，该分析表明不稳定性首先出现在最高频率（或最短波长）的模态上，对于一个有 $N$ 个点的网格，这个模态是奈奎斯特模态，即 $m=N/2$。这里，$N=8$，所以最不稳定的模态是 $m=4$。", "answer": "$$\\boxed{4}$$", "id": "3278053"}, {"introduction": "从理论走向实践。理论分析预测在 $r = 1/2$ 处存在一个尖锐的稳定性阈值，这主要由最高频率模式的行为决定。这个动手编程练习将让你通过一个简单的数值实验，测量这一特定模式的增长情况，从而直接观察到这一现象，并以经验方式验证理论预测。[@problem_id:3277980]", "problem": "考虑定义在长度为 $L$ 的周期性域上的一维热传导方程 $u_t = \\alpha u_{xx}$，该方程使用时间前向中心差分 (FTCS) 格式进行离散化。设空间网格有 $N$ 个点，均匀间距为 $h = L/N$，并选择时间步长 $\\Delta t$ 使得 $r = \\alpha \\Delta t / h^2$。在网格索引 $j$ 处的 FTCS 更新公式为 $u_j^{n+1} = u_j^n + r \\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right)$，并应用周期性边界条件，使得 $u_{-1}^n = u_{N-1}^n$ 且 $u_{N}^n = u_0^n$。\n\n设计一个数值实验，通过测量一个高频初始条件的离散 $\\ell^2$ 范数的增长率，来估计其经验单步放大率。使用初始条件 $u_j^0 = (-1)^j$（其中 $j = 0, 1, \\dots, N-1$），这是偶数点周期性网格上的最高频率（奈奎斯特）模态。执行单个 FTCS 时间步以获得 $u^1$，并计算经验放大率 $g = \\|u^1\\|_2 / \\|u^0\\|_2$。\n\n使用 $L = 1$ 和 $\\alpha = 1$ 对以下测试套件实现该实验：\n- 测试用例 1：$N = 128$，$r = 0.25$。\n- 测试用例 2：$N = 128$，$r = 0.50$。\n- 测试用例 3：$N = 128$，$r = 0.75$。\n- 测试用例 4：$N = 128$，$r = 0.49$。\n\n您的程序应生成单行输出，其中包含按上述顺序列出的四个测试用例的经验放大率，形式为用方括号括起来的逗号分隔列表，例如 $[g_1,g_2,g_3,g_4]$。所有报告的值都必须是浮点数。", "solution": "一维热传导方程 $u_t = \\alpha u_{xx}$ 模拟扩散过程，是抛物型方程。在时间上采用标准的显式离散和在空间上采用中心离散，即可得到时间前向中心差分 (FTCS) 格式。在间距为 $h = L/N$ 的均匀网格上，网格点 $j$ 处的离散拉普拉斯算子近似为 $(u_{j+1}^n - 2 u_j^n + u_{j-1}^n)/h^2$，使用时间步长 $\\Delta t$，FTCS 更新公式为 $u_j^{n+1} = u_j^n + \\alpha \\Delta t \\cdot \\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{h^2}$。定义 $r = \\alpha \\Delta t / h^2$，该式变为 $u_j^{n+1} = u_j^n + r \\left(u_{j+1}^n - 2 u_j^n + u_{j-1}^n\\right)$。\n\n为了分析稳定性，Von Neumann 分析法考虑离散傅里叶模态 $u_j^n = \\hat{u}^n e^{i \\kappa j h}$，这些模态是周期性网格上离散拉普拉斯算子的特征函数。将一个模态代入更新公式，得到放大因子 $G(\\kappa) = 1 - 4 r \\sin^2\\left(\\frac{\\kappa h}{2}\\right)$。显式格式的稳定性要求对于所有波数 $\\kappa$ 都有 $|G(\\kappa)| \\leq 1$，这导出了条件 $r \\leq 1/2$，因为最坏的情况发生在最高频率处，此时 $\\sin^2\\left(\\frac{\\kappa h}{2}\\right) = 1$。\n\n该数值实验旨在经验性地测量这种最坏情况下的放大。在偶数点周期性网格上，奈奎斯特模态由 $u_j^0 = (-1)^j$ 表示，它对应于 $\\kappa h = \\pi$ 并使得 $\\sin^2\\left(\\frac{\\kappa h}{2}\\right) = 1$。对于这个特定的离散模态，可以直接计算出 $u_{j+1}^0 + u_{j-1}^0 = -2 u_j^0$，因此离散拉普拉斯算子项简化为 $u_{j+1}^0 - 2 u_j^0 + u_{j-1}^0 = -4 u_j^0$。因此，该模态的 FTCS 更新公式为\n$$\nu_j^1 = u_j^0 + r \\left(-4 u_j^0\\right) = \\left(1 - 4 r\\right) u_j^0.\n$$\n因此，该模态的单步放大因子为 $G = 1 - 4 r$，其模长为 $|G| = \\left|1 - 4 r\\right|$。由于更新后的向量是初始向量的标量倍数，离散 $\\ell^2$ 范数也按相同因子缩放，得到\n$$\ng = \\frac{\\|u^1\\|_2}{\\|u^0\\|_2} = \\left|1 - 4 r\\right|.\n$$\n\n这直接揭示了稳定性阈值：该格式对于奈奎斯特模态是稳定的，当且仅当 $\\left|1 - 4 r\\right| \\leq 1$，这可简化为 $r \\leq 1/2$。当 $r = 1/2$ 时，放大因子为 $G = -1$，意味着模长没有增长，但每一步符号会翻转。对于 $r  1/2$，模长会衰减；对于 $r > 1/2$，模长会增长。\n\n对于指定的测试套件，其中 $L = 1$ 和 $\\alpha = 1$：\n- 测试用例 1：$N = 128$，$r = 0.25$，预测的 $g = \\left|1 - 4 \\cdot 0.25\\right| = \\left|1 - 1\\right| = 0$。\n- 测试用例 2：$N = 128$，$r = 0.50$，预测的 $g = \\left|1 - 4 \\cdot 0.50\\right| = \\left|1 - 2\\right| = 1$。\n- 测试用例 3：$N = 128$，$r = 0.75$，预测的 $g = \\left|1 - 4 \\cdot 0.75\\right| = \\left|1 - 3\\right| = 2$。\n- 测试用例 4：$N = 128$，$r = 0.49$，预测的 $g = \\left|1 - 4 \\cdot 0.49\\right| = \\left|1 - 1.96\\right| = 0.96$。\n\n算法的实现过程如下：首先构建初始数组 $u^0$，其元素为 $u_j^0 = (-1)^j$（其中 $j = 0, 1, \\dots, N-1$），然后使用周期性索引回绕（可通过循环移位实现）应用一个 FTCS 步，最后计算 $g = \\|u^1\\|_2 / \\|u^0\\|_2$。由于所选的初始条件是偶数网格上离散拉普拉斯算子的一个特征向量，计算出的 $g$ 值将在浮点舍入误差范围内与上述理论值相匹配。最终的程序将四个 $g$ 值聚合成所要求的单行输出 $[g_1,g_2,g_3,g_4]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef ftcs_one_step_growth(N: int, r: float) - float:\n    \"\"\"\n    Compute the empirical one-step amplification magnitude g = ||u^1||_2 / ||u^0||_2\n    for the FTCS scheme applied to the high-frequency initial condition u_j^0 = (-1)^j\n    on a periodic grid of size N, with scheme parameter r.\n    \"\"\"\n    # Construct high-frequency (Nyquist) initial condition on an even N grid.\n    j = np.arange(N, dtype=np.int64)\n    u0 = ((-1) ** j).astype(np.float64)\n\n    # Periodic neighbors using numpy.roll\n    u_plus = np.roll(u0, -1)\n    u_minus = np.roll(u0, 1)\n\n    # FTCS update: u1 = u0 + r*(u_plus - 2*u0 + u_minus)\n    laplacian = u_plus - 2.0 * u0 + u_minus\n    u1 = u0 + r * laplacian\n\n    # Compute empirical amplification magnitude\n    norm_u0 = np.linalg.norm(u0)\n    norm_u1 = np.linalg.norm(u1)\n    g = norm_u1 / norm_u0\n    return float(g)\n\ndef solve():\n    # Define the test cases from the problem statement: (N, r)\n    test_cases = [\n        (128, 0.25),\n        (128, 0.50),\n        (128, 0.75),\n        (128, 0.49),\n    ]\n\n    results = []\n    for N, r in test_cases:\n        g = ftcs_one_step_growth(N, r)\n        results.append(g)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3277980"}, {"introduction": "在解决了稳定与不稳定的二元问题之后，我们进一步探讨更微妙的方面。在实践中，选择数值格式需要在稳定性、准确性和计算成本之间进行权衡。这个高级练习将探索稳定区域内部的细微差别，通过量化“数值扩散”这一评估数值解质量的关键概念，展示稳定性参数 $r$ 的选择如何影响模拟的准确性。[@problem_id:3278125]", "problem": "考虑一维热扩散方程 $u_t = \\nu u_{xx}$，定义在一个长度为 $L$ 的周期性空间域上，其中 $u(x,t)$ 是温度场，$t$ 是时间（单位：秒），$x$ 是位置（单位：米），$\\nu$ 是热扩散系数（单位：$\\mathrm{m^2/s}$）。使用前向时间中心空间 (FTCS) 格式，在具有 $N_x$ 个点、间距为 $\\Delta x = L/N_x$ 的均匀网格上，以时间步长 $\\Delta t$ 来近似求解。定义无量纲参数 $r = \\nu \\Delta t / \\Delta x^2$。FTCS 更新在周期性边界条件下应用，并使用下面指定的固定 $r$ 值。初始条件为单一傅里叶模式 $u(x,0) = \\sin(k x)$，其中波数 $k = 2\\pi m / L$，$m$ 为给定的整数模式指数。此初始条件的热方程精确解析解为 $u_{\\mathrm{exact}}(x,t) = \\sin(k x)\\,\\exp(-\\nu k^2 t)$。\n\n你的任务是通过比较 FTCS 数值解在固定物理时间 $T$ 后，$r=0.49$ 和 $r=0.1$ 两种情况下的表现，来进行误差与稳定性的参数化研究，并量化多余的数值扩散。对于下面测试套件中的每种情况，实施 FTCS 格式，直到恰好达到物理时间 $T$。使用周期性边界条件。对于每种情况，计算两个量：\n\n1. 在时间 $T$ 时相对于解析解的 $L^2$ 误差，定义为 $E = \\left(\\int_0^L (u_{\\mathrm{num}}(x,T) - u_{\\mathrm{exact}}(x,T))^2\\,dx\\right)^{1/2}$，表示为一个无单位的浮点数（无量纲，因为 $u$ 是无量纲的）。\n\n2. 多余的数值扩散 $\\Delta \\nu_{\\mathrm{num}}$（单位：$\\mathrm{m^2/s}$），通过从基模的数值计算振幅衰减中估计有效扩散系数 $\\nu_{\\mathrm{eff}}$ 来定义，然后报告 $\\Delta \\nu_{\\mathrm{num}} = \\nu_{\\mathrm{eff}} - \\nu$。通过使用网格上内积的离散近似，将 $u(x,t)$ 投影到 $\\sin(kx)$ 上来估计振幅 $A(t)$。使用 $A(0)$ 和 $A(T)$ 通过公式 $\\nu_{\\mathrm{eff}} = -\\frac{1}{k^2 T}\\ln\\left(\\left|\\frac{A(T)}{A(0)}\\right|\\right)$ 来计算 $\\nu_{\\mathrm{eff}}$。以浮点数形式报告 $\\Delta \\nu_{\\mathrm{num}}$（单位：$\\mathrm{m^2/s}$）。请注意，对数内的绝对值确保了在离散放大导致符号变化但仍保持稳定的情况下，衰减率具有物理意义。\n\n使用的科学和数值参数为 $L = 1.0$ 米，$\\nu = 0.01$ $\\mathrm{m^2/s}$，$T = 0.49$ 秒。角度（例如，在三角函数中）必须以弧度处理。\n\n为每种情况实现 FTCS 格式的时间更新，并计算所要求的量。FTCS 更新必须使用每种情况指定的无量纲参数 $r$、周期性边界条件和均匀网格。对于每种情况，从 $r = \\nu \\Delta t / \\Delta x^2$ 的定义中选择时间步长 $\\Delta t$，并确保时间步数使得总模拟时间恰好等于 $T$ 秒。\n\n测试套件：\n- 情况 1 (理想情况): $N_x = 100$, $m = 1$, $r = 0.1$。\n- 情况 2 (接近稳定边界): $N_x = 100$, $m = 1$, $r = 0.49$。\n- 情况 3 (高波数，接近离散稳定边缘): $N_x = 100$, $m = 45$, $r = 0.49$。\n\n对于每种情况，按规定计算数据对 $\\left[E, \\Delta \\nu_{\\mathrm{num}}\\right]$。您的程序应生成单行输出，其中包含三个情况的结果，格式为方括号括起来的逗号分隔列表，其中每个元素本身是一个包含两个元素的列表。例如，输出格式应类似于“[[E1,DN1],[E2,DN2],[E3,DN3]]”，其中 $E1$ 是情况 1 的 $L^2$ 误差，$DN1$ 是情况 1 的多余数值扩散（单位：$\\mathrm{m^2/s}$），以此类推。所有数字必须打印为标准 Python 浮点数。输出行中不应打印任何单位。", "solution": "该问题已经过验证，被确定为数值分析领域中一个适定且科学合理的问题。\n\n该问题要求数值求解一维热扩散方程，\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n在一个周期性空间域 $x \\in [0, L]$ 上。这里，$u(x,t)$ 表示温度，$\\nu$ 是热扩散系数，$x$ 是空间坐标，$t$ 是时间。初始条件是单一傅里叶模式 $u(x,0) = \\sin(k x)$，波数为 $k = 2\\pi m / L$，其中 $m$ 是给定的整数模式指数。\n\n要使用的数值方法是前向时间中心空间 (FTCS) 格式。我们用 $N_x$ 个网格点将域离散化，使得网格间距为 $\\Delta x = L/N_x$，空间坐标为 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N_x-1$。时间以 $\\Delta t$ 为步长进行离散化，因此 $t_n = n \\Delta t$。在网格点 $j$ 和时间步 $n$ 的数值解表示为 $u_j^n \\approx u(x_j, t_n)$。\n\nFTCS 格式使用前向差分对时间导数进行离散化，使用中心差分对空间导数进行离散化：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\nu \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{\\Delta x^2}\n$$\n重新整理该方程，得到下一个时间步 $u_j^{n+1}$ 的数值解的显式更新规则：\n$$\nu_j^{n+1} = u_j^n + r (u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n其中 $r = \\frac{\\nu \\Delta t}{\\Delta x^2}$ 是无量纲稳定性参数。FTCS 格式的稳定性由 von Neumann 稳定性条件决定，该条件规定，为获得稳定解，参数 $r$ 必须满足 $r \\le 1/2$。所考虑的 $r=0.1$ 和 $r=0.49$ 的情况均满足此条件。\n\n每个测试用例的步骤如下：\n\n1.  **设置模拟参数**：根据提供的案例数据（$N_x, m, r$）和全局常量（$L=1.0$, $\\nu=0.01$, $T=0.49$），我们计算必要的参数：\n    *   空间网格间距：$\\Delta x = L / N_x$。\n    *   波数：$k = 2\\pi m / L$。\n    *   时间步长：$\\Delta t = r \\Delta x^2 / \\nu$。\n    *   总时间步数：$N_t = T / \\Delta t$。问题参数的选择使得 $N_t$ 是一个整数，从而确保模拟在时间 $T$ 精确结束。\n\n2.  **初始化解**：根据初始条件 $u(x,0) = \\sin(kx)$ 初始化表示解 $u$ 的一维数组。空间网格定义为 $x_j = j \\Delta x$，$j \\in \\{0, \\dots, N_x-1\\}$。因此，初始数值解为 $u_j^0 = \\sin(k x_j)$。\n\n3.  **执行时间积分**：一个从 $n=0$ 到 $N_t-1$ 的循环。在每次迭代中，将 FTCS 更新规则应用于所有网格点 $j$，以从 $u^n$ 计算 $u^{n+1}$。强制执行周期性边界条件，意味着在 $j=0$ 处的计算中，“左”邻居 $u_{-1}^n$ 取为 $u_{N_x-1}^n$，而在 $j=N_x-1$ 处的计算中，“右”邻居 $u_{N_x}^n$ 取为 $u_0^n$。\n\n4.  **计算最终量**：经过 $N_t$ 个时间步后，获得最终数值解 $u_{\\mathrm{num}}(x,T)$。然后我们计算两个所需的度量指标：\n\n    a. **$L^2$ 误差 ($E$)**：给定初始条件的精确解析解是 $u_{\\mathrm{exact}}(x,t) = \\sin(k x) e^{-\\nu k^2 t}$。我们在数值网格上计算其在 $t=T$ 时的值。$L^2$ 误差定义为 $E = \\left(\\int_0^L (u_{\\mathrm{num}}(x,T) - u_{\\mathrm{exact}}(x,T))^2\\,dx\\right)^{1/2}$。该积分使用网格上的 Riemann 和进行数值近似：\n    $$\n    E \\approx \\left( \\sum_{j=0}^{N_x-1} (u_j^{N_t} - u_{\\mathrm{exact}}(x_j,T))^2 \\Delta x \\right)^{1/2}\n    $$\n\n    b. **多余的数值扩散 ($\\Delta \\nu_{\\mathrm{num}}$)**：FTCS 格式会引入数值误差，通常表现为额外的扩散。为了量化这一点，我们根据解的振幅衰减计算一个有效的扩散系数 $\\nu_{\\mathrm{eff}}$。数值解 $u(x,t)$ 中模式 $\\sin(kx)$ 的振幅 $A(t)$ 通过投影求得：\n    $$\n    A(t) = \\frac{\\langle u(x,t), \\sin(kx) \\rangle}{\\langle \\sin(kx), \\sin(kx) \\rangle} = \\frac{\\int_0^L u(x,t) \\sin(kx) dx}{\\int_0^L \\sin^2(kx) dx} = \\frac{2}{L} \\int_0^L u(x,t) \\sin(kx) dx\n    $$\n    我们通过数值近似该积分来计算初始振幅 $A(0)$ 和最终振幅 $A(T)$。由于所选网格上离散傅里叶基的性质，$A(0)$ 将恰好为 $1$。最终振幅由以下公式给出：\n    $$\n    A(T) \\approx \\frac{2}{L} \\sum_{j=0}^{N_x-1} u_j^{N_t} \\sin(k x_j) \\Delta x = \\frac{2}{N_x} \\sum_{j=0}^{N_x-1} u_j^{N_t} \\sin(k x_j)\n    $$\n    然后，假设指数定律，根据振幅衰减计算有效扩散系数 $\\nu_{\\mathrm{eff}}$：\n    $$\n    \\nu_{\\mathrm{eff}} = -\\frac{1}{k^2 T}\\ln\\left(\\left|\\frac{A(T)}{A(0)}\\right|\\right)\n    $$\n    使用绝对值使得计算对于数值格式中可能出现的符号翻转振荡具有鲁棒性。多余的数值扩散是有效扩散系数与真实扩散系数之差：\n    $$\n    \\Delta \\nu_{\\mathrm{num}} = \\nu_{\\mathrm{eff}} - \\nu\n    $$\n\n对三个测试用例中的每一个都执行此过程，并将得到的结果对 $[E, \\Delta \\nu_{\\mathrm{num}}]$ 收集并格式化为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_case(Nx, m, r):\n    \"\"\"\n    Solves the 1D heat equation with FTCS for a given parameter set.\n\n    Args:\n        Nx (int): Number of spatial grid points.\n        m (int): Wavenumber index for the initial condition.\n        r (float): Nondimensional stability parameter.\n\n    Returns:\n        list: A list containing the L2 error [E] and the excess numerical \n              diffusion [delta_nu_num].\n    \"\"\"\n    # Scientific and numerical parameters\n    L = 1.0  # meters\n    nu = 0.01  # m^2/s\n    T = 0.49  # seconds\n\n    # 1. Grid and Parameters Setup\n    dx = L / Nx\n    k = 2 * np.pi * m / L\n    \n    # Calculate time step and number of steps to reach T exactly\n    dt = r * dx**2 / nu\n    # Use np.round to handle potential floating point inaccuracies ensuring an integer\n    Nt = int(np.round(T / dt)) \n    \n    # Check if simulation time is exactly T\n    if not np.isclose(Nt * dt, T):\n        raise ValueError(\"Simulation time T is not an integer multiple of dt.\")\n\n    # Spatial grid\n    x = np.linspace(0, L, Nx, endpoint=False)\n\n    # 2. Initial Condition\n    u = np.sin(k * x)\n    u_initial = u.copy()\n\n    # 3. Time Evolution (FTCS)\n    for _ in range(Nt):\n        # Use np.roll for efficient periodic boundary conditions\n        u_jp1 = np.roll(u, -1)\n        u_jm1 = np.roll(u, 1)\n        u = u + r * (u_jp1 - 2 * u + u_jm1)\n    \n    u_final = u\n\n    # 4. Post-processing\n    # Analytical solution at time T\n    u_exact_T = np.sin(k * x) * np.exp(-nu * k**2 * T)\n\n    # 5. Compute L2 Error (E)\n    # The integral is approximated by a sum over the discrete grid points.\n    error_integrand = (u_final - u_exact_T)**2\n    L2_error = np.sqrt(np.sum(error_integrand) * dx)\n\n    # 6. Compute Excess Numerical Diffusion (delta_nu_num)\n    # The amplitude is computed by projecting the solution onto sin(kx).\n    # The discrete projection integral: (2/L) * sum(f(x)*sin(kx)*dx)\n    # A_0 = (2/L) * np.sum(u_initial * np.sin(k*x)) * dx which simplifies to\n    # A_0 = (2/Nx) * np.sum(u_initial * np.sin(k*x))\n    # For a perfect sine wave on the grid, this sum is exactly Nx/2, so A_0 is 1.0.\n    # We compute it numerically for robustness.\n    \n    # Inner product helper function\n    def inner_product(f, g, dx_val):\n        return np.sum(f * g) * dx_val\n\n    # Basis function for projection\n    sin_kx = np.sin(k*x)\n\n    # Normalization factor is integral of sin^2(kx) over [0,L], approximately L/2\n    norm_factor = inner_product(sin_kx, sin_kx, dx)\n\n    # Initial amplitude\n    A0 = inner_product(u_initial, sin_kx, dx) / norm_factor\n\n    # Final amplitude\n    AT = inner_product(u_final, sin_kx, dx) / norm_factor\n    \n    # Handle the case k=0 (m=0), where k^2 T is zero.\n    if k == 0:\n        nu_eff = 0.0 # No diffusion for a constant initial condition\n    else:\n        # The formula given in the problem\n        nu_eff = (-1 / (k**2 * T)) * np.log(np.abs(AT / A0))\n\n    delta_nu_num = nu_eff - nu\n    \n    return [L2_error, delta_nu_num]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 1, 0.1),   # Case 1: happy path\n        (100, 1, 0.49),  # Case 2: near stability boundary\n        (100, 45, 0.49), # Case 3: high wavenumber near stability edge\n    ]\n\n    results = []\n    for case in test_cases:\n        Nx, m, r = case\n        result = run_case(Nx, m, r)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function on a list correctly formats it as '[item1, item2]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3278125"}]}