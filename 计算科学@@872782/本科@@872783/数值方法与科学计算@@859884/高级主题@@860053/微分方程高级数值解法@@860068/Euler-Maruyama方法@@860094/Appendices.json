{"hands_on_practices": [{"introduction": "衡量数值方案质量的一个关键指标是其“强收敛性”——即单条模拟路径与真实解的贴近程度。虽然欧拉-丸山（EM）方法很简单，但其强收敛阶数存在已知的局限性。此练习 ([@problem_id:3226794]) 让你能够通过经验性测量来量化这一阶数，并将其与更高阶的替代方案——米尔斯坦（Milstein）方法——进行直接比较，从而清晰地理解为何以及何时需要更高级的数值格式。", "problem": "你需要比较两种随机微分方程（SDE）数值格式的强收敛行为：欧拉-丸山（Euler-Maruyama）法和米尔斯坦（Milstein）法。研究完全在标量设置下，针对几何布朗运动进行，其动力学由以下伊藤（Itô）SDE 给出：\n$$\ndX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t,\n$$\n初始条件为 $X_0 = x_0$，其中 $\\mu \\in \\mathbb{R}$ 是漂移项，$\\sigma \\in \\mathbb{R}$ 是扩散系数，$W_t$ 是一个标准维纳过程。其精确解是众所周知的闭式形式：\n$$\nX_T = X_0 \\exp\\big((\\mu - \\tfrac{1}{2}\\sigma^2) T + \\sigma W_T\\big).\n$$\n你的任务是实现一个蒙特卡洛研究，以估计以下两种方法在终端时刻 $T$ 的强收敛阶：\n- 欧拉-丸山法（Euler-Maruyama 是最简单的基于伊藤积分的离散化方法，它用增量 $\\,\\Delta W_n\\,$ 替代伊藤积分），以及\n- 米尔斯坦法（Milstein 法是针对标量 SDE 的一阶伊藤-泰勒方法，它在欧拉-丸山增量的基础上，增加了涉及扩散项导数 $\\,b'(x)\\,$（对于 $\\,b(x)=\\sigma x\\,$）的主要随机泰勒修正项）。\n\n从伊藤积分、伊藤公式和伊藤-泰勒展开的核心定义出发，并利用这些来设计这两种时间步进更新方案。使用上述精确解来计算终端强误差。对于每种方法和每个时间步长，估计在时间 $T$ 的均方根（RMS）强误差：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) = \\Big(\\mathbb{E}\\big[|X_T^{(h)} - X_T|^2\\big]\\Big)^{1/2},\n$$\n其中 $X_T^{(h)}$ 表示使用均匀步长 $h$ 的数值近似。\n\n为了估计收敛阶，考虑一组均匀步长 $h_k = T/N_k$，并通过在对数-对数尺度上进行最小二乘法拟合以下模型，以获得估计的强收敛阶 $p$：\n$$\n\\log \\varepsilon_{\\mathrm{RMS}}(h_k) \\approx p \\log h_k + C\n$$\n\n蒙特卡洛要求：\n- 使用 $M = 10000$ 条独立的样本路径。\n- 为了减少方差并在不同步长之间进行公平比较，应在最细的网格上生成布朗增量，并通过对连续的细网格增量求和来获得粗网格的增量（即，使用一致的加密方式，使得 $N_{\\max}/N_k \\in \\mathbb{N}$，并且所有分辨率都由相同的底层噪声驱动）。\n- 为了可复现性，每个测试用例使用指定的伪随机种子。\n\n使用以下测试套件。对于每个测试，使用共同的时间剖分集合 $N_k \\in \\{16, 32, 64, 128\\}$（因此 $h_k = T/N_k$），以及给定的路径数和种子进行模拟：\n- 测试 A（理想情况，中等噪声）：$x_0 = 1.0$, $\\mu = 1.0$, $\\sigma = 0.5$, $T = 1.0$, 种子 $= 314159$。\n- 测试 B（小噪声的边界情况）：$x_0 = 2.0$, $\\mu = 0.3$, $\\sigma = 0.05$, $T = 2.0$, 种子 $= 271828$。\n- 测试 C（负漂移，较强噪声）：$x_0 = 1.0$, $\\mu = -1.0$, $\\sigma = 1.0$, $T = 1.0$, 种子 $= 161803$。\n\n你的程序必须：\n- 基于伊藤微积分的原理构造，为给定的 SDE 实现欧拉-丸山法和米尔斯坦法。\n- 对于每个测试用例和每个 $N_k \\in \\{16, 32, 64, 128\\}$，使用 $M = 10000$ 条模拟路径和如前述的耦合布朗增量计算 RMS 强误差，然后分别为欧拉-丸山法和米尔斯坦法拟合对数-对数模型中的斜率 $p$。\n- 对于每个测试用例，返回一个估计的强收敛阶对 $[p_{\\mathrm{EM}}, p_{\\mathrm{Mil}}]$，每个值四舍五入到两位小数。\n\n最终输出格式：\n- 你的程序应打印单行，其中包含一个含三个条目的列表，每个条目对应一个测试用例，顺序为 A、B、C。每个条目是该测试用例的双元素列表 $[p_{\\mathrm{EM}}, p_{\\mathrm{Mil}}]$。\n- 具体来说，你的程序应精确地产生如下一行：\n$$\n[[p_{\\mathrm{EM,A}}, p_{\\mathrm{Mil,A}}],[p_{\\mathrm{EM,B}}, p_{\\mathrm{Mil,B}}],[p_{\\mathrm{EM,C}}, p_{\\mathrm{Mil,C}}]]\n$$\n所有六个值均为四舍五入到两位小数的十进制浮点数，除逗号、括号和数字外，没有多余的字符或空格。", "solution": "问题陈述已经过分析，并被确定为有效。它在科学上基于随机微积分理论和 SDE 的数值方法，所有必要参数均已定义，问题设定适定，其表述和要求均客观明确。\n\n此问题要求对应用于几何布朗运动（GBM）随机微分方程（SDE）的欧拉-丸山（Euler-Maruyama）和米尔斯坦（Milstein）数值方法的强收敛阶进行比较研究。该 SDE 由下式给出：\n$$\ndX_t = \\mu X_t \\, dt + \\sigma X_t \\, dW_t, \\quad X(0) = x_0\n$$\n其中 $\\mu \\in \\mathbb{R}$ 是漂移参数，$\\sigma \\in \\mathbb{R}$ 是扩散参数，$W_t$ 是一个标准维纳过程。这是一个伊藤过程，其漂移系数为 $a(x) = \\mu x$，扩散系数为 $b(x) = \\sigma x$。问题给出了在时间 $T$ 的精确解：\n$$\nX_T = X_0 \\exp\\left((\\mu - \\tfrac{1}{2}\\sigma^2) T + \\sigma W_T\\right)\n$$\n其中 $W_T = \\int_0^T dW_s$ 是维纳过程在 $[0, T]$ 上的总增量。\n\n解决方案涉及推导数值格式，在蒙特卡洛模拟中实现它们，计算强误差，并最终通过回归估计收敛阶。\n\n**1. 数值格式的推导**\n\n数值格式是通过将 SDE 的积分形式在长度为 $h = t_{n+1} - t_n$ 的时间区间 $[t_n, t_{n+1}]$ 上离散化来推导的。积分形式为：\n$$\nX_{t_{n+1}} = X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_s) \\, ds + \\int_{t_n}^{t_{n+1}} b(X_s) \\, dW_s\n$$\n\n**欧拉-丸山（EM）法：**\nEM 方法是最简单的离散化，通过将被积函数 $a(X_s)$ 和 $b(X_s)$ 近似为区间上的常数，等于它们在区间开始时的值 $X_n \\equiv X_{t_n}$。\n$$\nX_{n+1} \\approx X_n + a(X_n) \\int_{t_n}^{t_{n+1}} \\, ds + b(X_n) \\int_{t_n}^{t_{n+1}} \\, dW_s\n$$\n积分的计算结果为 $\\int_{t_n}^{t_{n+1}} ds = h$ 和 $\\int_{t_n}^{t_{n+1}} dW_s = \\Delta W_n = W_{t_{n+1}} - W_{t_n}$。项 $\\Delta W_n$ 代表从均值为 $0$、方差为 $h$ 的正态分布中随机抽样，即 $\\Delta W_n \\sim \\mathcal{N}(0, h)$。EM 更新规则是：\n$$\nX_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n\n$$\n对于给定的 GBM SDE，其中 $a(x) = \\mu x$ 和 $b(x) = \\sigma x$，EM 格式为：\n$$\nX_{n+1} = X_n + \\mu X_n h + \\sigma X_n \\Delta W_n = X_n (1 + \\mu h + \\sigma \\Delta W_n)\n$$\n对于一般的 SDE，EM 方法的强收敛阶为 $0.5$。\n\n**米尔斯坦（Milstein）法：**\n米尔斯坦法通过包含一个来自伊藤-泰勒展开的附加项来改进 EM 方法。对于标量 SDE，该展开为：\n$$\nX_{t_{n+1}} = X_{t_n} + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left((\\Delta W_n)^2 - h\\right) + \\mathcal{O}(h^{3/2})\n$$\n其中 $b'(x)$ 是扩散系数关于 $x$ 的导数。该格式是通过在随机积分近似中包含更高阶项得到的。\n米尔斯坦方法的更新规则是：\n$$\nX_{n+1} = X_n + a(X_n) h + b(X_n) \\Delta W_n + \\frac{1}{2} b(X_n) b'(X_n) \\left((\\Delta W_n)^2 - h\\right)\n$$\n对于 GBM SDE，我们有 $b(x) = \\sigma x$ 及其导数 $b'(x) = \\sigma$。将这些代入米尔斯坦格式得到：\n$$\nX_{n+1} = X_n + \\mu X_n h + \\sigma X_n \\Delta W_n + \\frac{1}{2} (\\sigma X_n) (\\sigma) \\left((\\Delta W_n)^2 - h\\right)\n$$\n$$\nX_{n+1} = X_n \\left(1 + \\mu h + \\sigma \\Delta W_n + \\frac{1}{2} \\sigma^2 \\left((\\Delta W_n)^2 - h\\right)\\right)\n$$\n米尔斯坦方法通常具有 $1.0$ 的强收敛阶。\n\n**2. 蒙特卡洛模拟框架**\n\n目标是从关系式 $\\varepsilon_{\\mathrm{RMS}}(h) \\propto h^p$ 中估计强收敛阶 $p$。均方根（RMS）强误差定义为：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) = \\left( \\mathbb{E}\\left[|X_T^{(h)} - X_T|^2\\right] \\right)^{1/2}\n$$\n其中 $X_T^{(h)}$ 是在时间 $T$ 处步长为 $h$ 的数值解，$X_T$ 是精确解。期望 $\\mathbb{E}[\\cdot]$ 通过对 $M = 10000$ 条独立模拟路径的样本均值来近似：\n$$\n\\varepsilon_{\\mathrm{RMS}}(h) \\approx \\sqrt{ \\frac{1}{M} \\sum_{i=1}^{M} \\left|X_{T,i}^{(h)} - X_{T,i}\\right|^2 }\n$$\n为确保公平比较和减少方差，对于不同的步长 $h_k = T/N_k$（其中 $N_k \\in \\{16, 32, 64, 128\\}$）的模拟由相同的底层噪声驱动。这通过首先为最细的网格 $N_{\\max} = 128$（步长 $h_{\\text{fine}} = T/N_{\\max}$）生成布朗增量来实现。对于一个较粗的网格 $N_k < N_{\\max}$，其粗增量 $\\Delta W_n^{(k)}$ 通过对 $R_k = N_{\\max}/N_k$ 个连续的细增量求和得到。这确保了所有模拟的总维纳路径 $W_T$ 是相同的。\n\n**3. 收敛阶的估计**\n\n收敛阶 $p$ 是通过对对数转换后的误差和步长拟合一个线性模型来估计的：\n$$\n\\log \\varepsilon_{\\mathrm{RMS}}(h_k) = p \\log h_k + C\n$$\n这是一个关于数据点 $(\\log h_k, \\log \\varepsilon_{\\mathrm{RMS}}(h_k))$ 的简单线性回归问题。最佳拟合线的斜率 $p$ 即为估计的收敛阶。对每个测试用例，分别为欧拉-丸山法和米尔斯坦法计算此值。\n\n对于每个测试用例，总体算法流程如下：\n1.  初始化参数（$\\mu, \\sigma, x_0, T$）和模拟设置（$M, N_k, \\text{seed}$）。\n2.  为 $N_{\\max}=128$ 个步骤生成 $M$ 条细网格布朗增量路径 $\\{\\Delta W_n^{\\text{fine}}\\}$。\n3.  对每条路径 $i$，使用总维纳增量 $W_{T,i} = \\sum_n \\Delta W_{n,i}^{\\text{fine}}$ 计算精确解 $X_{T,i}$。\n4.  对每个步数 $N_k \\in \\{16, 32, 64, 128\\}$：\n    a. 确定步长 $h_k = T/N_k$。\n    b. 通过对细网格增量求和来构造粗网格的布朗增量。\n    c. 使用 EM 和 Milstein 两种格式，模拟从 $t=0$到$t=T$ 的 $M$ 条路径。\n    d. 计算两种方法的 RMS 强误差 $\\varepsilon_{\\mathrm{RMS}}(h_k)$。\n5.  使用计算出的一组误差，对 $(\\log h_k, \\log \\varepsilon_k)$ 进行线性回归，以找到欧拉-丸山法的斜率 $p_{\\mathrm{EM}}$ 和米尔斯坦法的斜率 $p_{\\mathrm{Mil}}$。\n6.  将估计的阶数四舍五入到两位小数，并存储结果对。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs a Monte Carlo study to estimate the strong convergence orders of the\n    Euler-Maruyama and Milstein methods for the Geometric Brownian Motion SDE.\n    \"\"\"\n    test_cases = [\n        # (x0, mu, sigma, T, seed)\n        (1.0, 1.0, 0.5, 1.0, 314159),  # Test A\n        (2.0, 0.3, 0.05, 2.0, 271828), # Test B\n        (1.0, -1.0, 1.0, 1.0, 161803), # Test C\n    ]\n\n    all_results = []\n\n    M = 10000  # Number of Monte Carlo paths\n    N_steps_list = [16, 32, 64, 128]\n    N_max = max(N_steps_list)\n\n    for x0, mu, sigma, T, seed in test_cases:\n        rng = np.random.default_rng(seed)\n        \n        # Step 1: Generate fine-grained Brownian increments for all paths\n        h_fine = T / N_max\n        # (M, N_max) matrix of increments\n        fine_increments = rng.normal(0, np.sqrt(h_fine), (M, N_max))\n        \n        # Step 2: Calculate the exact solution at time T\n        # Total Wiener increment for each path\n        W_T_paths = np.sum(fine_increments, axis=1)\n        X_exact_T = x0 * np.exp((mu - 0.5 * sigma**2) * T + sigma * W_T_paths)\n        \n        log_h_values = []\n        log_em_errors = []\n        log_mil_errors = []\n\n        # Step 3: Loop over different step sizes\n        for N_k in N_steps_list:\n            h_k = T / N_k\n            log_h_values.append(np.log(h_k))\n            \n            # Step 3a: Construct coarse Brownian increments from fine ones\n            refinement_ratio = N_max // N_k\n            coarse_increments = fine_increments.reshape(M, N_k, refinement_ratio).sum(axis=2)\n            \n            # Initialize numerical solutions at t=0\n            X_em = np.full(M, x0)\n            X_mil = np.full(M, x0)\n            \n            # Step 3b: Simulate paths for both schemes\n            for n in range(N_k):\n                dW = coarse_increments[:, n]\n                \n                # Euler-Maruyama update\n                X_em = X_em * (1 + mu * h_k + sigma * dW)\n                \n                # Milstein update\n                mil_correction = 0.5 * sigma**2 * (dW**2 - h_k)\n                X_mil = X_mil * (1 + mu * h_k + sigma * dW + mil_correction)\n            \n            # Step 3c: Calculate RMS strong error for this step size\n            em_error_sq = np.mean((X_em - X_exact_T)**2)\n            mil_error_sq = np.mean((X_mil - X_exact_T)**2)\n            \n            log_em_errors.append(0.5 * np.log(em_error_sq))\n            log_mil_errors.append(0.5 * np.log(mil_error_sq))\n\n        # Step 4: Perform log-log regression to find the convergence order\n        # np.polyfit returns [slope, intercept]\n        p_em = np.polyfit(log_h_values, log_em_errors, 1)[0]\n        p_mil = np.polyfit(log_h_values, log_mil_errors, 1)[0]\n        \n        # Round results to two decimal places\n        p_em_rounded = round(p_em, 2)\n        p_mil_rounded = round(p_mil, 2)\n        \n        all_results.append([p_em_rounded, p_mil_rounded])\n\n    # Step 5: Format the final output string\n    inner_strings = [f\"[{p_em},{p_mil}]\" for p_em, p_mil in all_results]\n    print(f\"[{','.join(inner_strings)}]\")\n\nsolve()\n```", "id": "3226794"}, {"introduction": "虽然强收敛性衡量的是路径级别的准确性，但许多应用只要求模拟结果的统计矩（如均值和方差）是正确的。这一性质被称为“弱收敛性”，而欧拉-丸山方法在这方面的表现通常出人意料地好。在此练习 ([@problem_id:3226701]) 中，你将研究欧拉-丸山格式的弱收敛率，并发现其在计算期望值方面的精度可能高于其强收敛阶所暗示的水平。", "problem": "考虑 Ornstein–Uhlenbeck (OU) 随机微分方程 (SDE)，其形式如下\n$$\ndX_t = a\\,(m - X_t)\\,dt + \\sigma\\,dW_t,\\quad X_0 = x_0,\\quad t \\in [0,T],\n$$\n其中 $a>0$ 是均值回归速率，$m \\in \\mathbb{R}$ 是长期均值，$\\sigma>0$ 是扩散系数，$W_t$ 是标准维纳过程，$X_t$ 是状态变量。时间步长为 $\\Delta t$ 的 Euler–Maruyama (EM) 方法通过以下递归关系离散化该 SDE\n$$\nX_{n+1}^{\\text{EM}} = X_n^{\\text{EM}} + a\\,(m - X_n^{\\text{EM}})\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n,\n$$\n其中 $\\xi_n \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量，$n=0,1,\\dots,N-1$，且 $N = T/\\Delta t$ 是一个整数。\n\n你的任务如下，并且每一项都必须用代码实现：\n\n1. 从期望的线性性质和 Euler–Maruyama 方法定义的递归关系出发，推导 Euler–Maruyama 近似解 $X_T^{\\text{EM}}$ 在终端时刻 $T$ 的均值和方差的精确表达式，用 $a$、$m$、$\\sigma$、$x_0$、$T$ 和 $\\Delta t$ 表示。另外，利用常系数线性 Itô SDE 具有高斯解这一事实，推导 OU SDE 真实解 $X_T$ 的精确均值和方差。你的推导必须基于期望、方差、Itô 等距性和线性递归的定义；不得在没有论证的情况下调用任何现成的结果。\n\n2. 仅利用 $X_T$ 和 $X_T^{\\text{EM}}$ 都是高斯随机变量这一事实，精确地（而非通过蒙特卡洛方法）表达期望 $\\mathbb{E}[f(X_T)]$ 和 $\\mathbb{E}[f(X_T^{\\text{EM}})]$，其中 $f$ 为以下光滑检验函数：\n   - $f_1(x) = x$,\n   - $f_2(x) = \\sin(x)$,\n   - $f_3(x) = x^2$.\n   你可以使用由矩生成函数和特征函数得到的高斯随机变量函数期望的标准恒等式。\n\n3. 对于一组时间步长网格 $\\Delta t \\in \\{T/10,\\,T/20,\\,T/40,\\,T/80\\}$，计算弱误差\n$$\n\\left|\\mathbb{E}[f(X_T)] - \\mathbb{E}[f(X_T^{\\text{EM}})]\\right|\n$$\n对每个 $f \\in \\{f_1,f_2,f_3\\}$。在此网格上使用对数-对数尺度上的最小二乘线性拟合，估计由下式中的斜率定义的经验弱阶 $p$\n$$\n\\log\\left(\\text{weak error}\\right) \\approx p\\,\\log(\\Delta t) + C,\n$$\n并报告每个检验函数对应的 $p$ 值，四舍五入到三位小数。\n\n4. 对于特殊情况 $f_1(x)=x$，通过分析当 $\\Delta t \\to 0^+$ 时 $\\left|\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}]\\right|$ 的行为来量化主阶差异，并从第一性原理出发，确认其为 $\\mathcal{O}(\\Delta t)$。\n\n将上述任务在单个程序中实现，该程序通过评估下面列出的两组独立参数集（一个测试套件）来确定性地执行，无需任何外部输入。对每组参数集，使用检验函数 $f_1$、$f_2$ 和 $f_3$，以及四个时间步长 $\\Delta t \\in \\{T/10,\\,T/20,\\,T/40,\\,T/80\\}$。\n\n测试套件：\n- 情况 1：$a = 1.3$，$m = 0.5$，$\\sigma = 0.7$，$x_0 = -0.4$，$T = 1.0$。\n- 情况 2：$a = 3.0$，$m = -0.2$，$\\sigma = 0.5$，$x_0 = 1.1$，$T = 0.8$。\n\n你的程序必须：\n- 对每种情况，使用四个 $\\Delta t$ 值计算 $f_1$、$f_2$ 和 $f_3$ 的经验弱阶 $p$。\n- 将每个 $p$ 四舍五入到三位小数，并按以下顺序汇总结果：情况 1 的 $f_1$，情况 1 的 $f_2$，情况 1 的 $f_3$，情况 2 的 $f_1$，情况 2 的 $f_2$，情况 2 的 $f_3$。\n- 生成单行输出，包含六个结果，以逗号分隔，并用方括号括起来，不含空格，例如 $[p_{11},p_{12},p_{13},p_{21},p_{22},p_{23}]$。\n\n该问题不涉及物理单位。正弦函数内的角度以弧度为单位。不使用百分比；任何速率都应以小数形式报告。你的实现不得读取任何输入。", "solution": "该问题是有效的，因为它是随机微分方程数值分析领域中的一个适定问题。它具有科学依据，内容自洽，客观，并且提供了所有必要的参数和条件。我们可以着手提供完整解答。\n\n解答分为四个部分：(1) 推导 Euler-Maruyama 近似解 ($X_T^{\\text{EM}}$) 和真实解 ($X_T$) 的均值和方差的精确表达式，(2) 推导一组检验函数的精确期望值，(3) 对均值误差进行渐近分析，(4) 概述经验性估计弱收敛阶的方法。\n\n**1. 解的均值和方差**\n\n**A. Euler-Maruyama 格式 ($X_T^{\\text{EM}}$)**\nOrnstein-Uhlenbeck 过程的 Euler-Maruyama 递归式由下式给出：\n$$\nX_{n+1}^{\\text{EM}} = X_n^{\\text{EM}} + a\\,(m - X_n^{\\text{EM}})\\,\\Delta t + \\sigma\\,\\sqrt{\\Delta t}\\,\\xi_n\n$$\n其中 $\\xi_n \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量。这个线性递归关系可以重写为：\n$$\nX_{n+1}^{\\text{EM}} = (1 - a\\Delta t)X_n^{\\text{EM}} + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\xi_n\n$$\n初始条件为 $X_0^{\\text{EM}} = x_0$。\n\n**$X_T^{\\text{EM}}$ 的均值：**\n令 $\\mu_n^{\\text{EM}} = \\mathbb{E}[X_n^{\\text{EM}}]$。根据期望的线性性质以及 $\\mathbb{E}[\\xi_n] = 0$，对递归式两边取期望可得：\n$$\n\\mathbb{E}[X_{n+1}^{\\text{EM}}] = \\mathbb{E}[(1 - a\\Delta t)X_n^{\\text{EM}} + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\xi_n]\n$$\n$$\n\\mu_{n+1}^{\\text{EM}} = (1 - a\\Delta t)\\mathbb{E}[X_n^{\\text{EM}}] + am\\Delta t + \\sigma\\sqrt{\\Delta t}\\mathbb{E}[\\xi_n]\n$$\n$$\n\\mu_{n+1}^{\\text{EM}} = (1 - a\\Delta t)\\mu_n^{\\text{EM}} + am\\Delta t\n$$\n这是一个关于均值的一阶线性递归关系，其中 $\\mu_0^{\\text{EM}} = x_0$。该递归关系的不动点是 $m$。通过定义 $\\delta_n = \\mu_n^{\\text{EM}} - m$，该关系简化为一个几何级数 $\\delta_{n+1} = (1 - a\\Delta t)\\delta_n$，其解为 $\\delta_n = (1 - a\\Delta t)^n \\delta_0$。由于 $\\delta_0 = x_0 - m$，我们得到 $\\mu_n^{\\text{EM}} = m + (x_0 - m)(1 - a\\Delta t)^n$。\n在终端时刻 $T$，我们有 $n = N = T/\\Delta t$。因此，Euler-Maruyama 近似解在时刻 $T$ 的均值为：\n$$\n\\mathbb{E}[X_T^{\\text{EM}}] = m + (x_0 - m)(1 - a\\Delta t)^{T/\\Delta t}\n$$\n\n**$X_T^{\\text{EM}}$ 的方差：**\n令 $V_n^{\\text{EM}} = \\text{Var}(X_n^{\\text{EM}})$。由于 $\\xi_n$ 独立于 $X_n^{\\text{EM}}$（它仅依赖于 $\\xi_0, \\dots, \\xi_{n-1}$），它们和的方差等于方差的和：\n$$\n\\text{Var}(X_{n+1}^{\\text{EM}}) = \\text{Var}((1 - a\\Delta t)X_n^{\\text{EM}}) + \\text{Var}(\\sigma\\sqrt{\\Delta t}\\xi_n)\n$$\n$$\nV_{n+1}^{\\text{EM}} = (1 - a\\Delta t)^2 V_n^{\\text{EM}} + \\sigma^2 \\Delta t \\text{Var}(\\xi_n)\n$$\n使用 $\\text{Var}(\\xi_n) = 1$，我们得到递归式 $V_{n+1}^{\\text{EM}} = (1 - a\\Delta t)^2 V_n^{\\text{EM}} + \\sigma^2 \\Delta t$，初始条件为 $V_0^{\\text{EM}} = \\text{Var}(x_0) = 0$。这是一个形式为 $y_{n+1} = \\alpha y_n + \\beta$ 的线性递归，其中 $\\alpha = (1 - a\\Delta t)^2$ 且 $\\beta = \\sigma^2 \\Delta t$。其解为 $V_n^{\\text{EM}} = \\beta \\sum_{k=0}^{n-1} \\alpha^k = \\beta \\frac{1-\\alpha^n}{1-\\alpha}$。\n分母为 $1 - \\alpha = 1 - (1-2a\\Delta t + a^2(\\Delta t)^2) = a\\Delta t(2-a\\Delta t)$。\n代入 $\\alpha$ 和 $\\beta$：\n$$\nV_n^{\\text{EM}} = \\sigma^2 \\Delta t \\frac{1 - (1 - a\\Delta t)^{2n}}{a\\Delta t(2 - a\\Delta t)} = \\frac{\\sigma^2}{a(2 - a\\Delta t)}[1 - (1 - a\\Delta t)^{2n}]\n$$\n在时刻 $T$，当 $n=N=T/\\Delta t$ 时，方差为：\n$$\n\\text{Var}(X_T^{\\text{EM}}) = \\frac{\\sigma^2}{a(2 - a\\Delta t)}[1 - (1 - a\\Delta t)^{2T/\\Delta t}]\n$$\n由于 $X_n^{\\text{EM}}$ 是在每一步由高斯随机变量的线性和与和构成的，所以 $X_N^{\\text{EM}}$ 是一个高斯随机变量。\n\n**B. 真实 SDE 解 ($X_T$)**\nSDE $dX_t = a(m - X_t)dt + \\sigma dW_t$ 可以重写为 $dX_t + aX_t dt = am dt + \\sigma dW_t$。使用积分因子 $e^{at}$，我们得到 $d(e^{at}X_t) = am e^{at} dt + \\sigma e^{at} dW_t$。从 $0$ 到 $t$ 积分可得：\n$$\ne^{at}X_t - X_0 = \\int_0^t am e^{as}ds + \\int_0^t \\sigma e^{as}dW_s\n$$\n解出 $X_t$ 可得精确解：\n$$\nX_t = X_0 e^{-at} + m(1 - e^{-at}) + \\sigma \\int_0^t e^{-a(t-s)} dW_s = m + (x_0-m)e^{-at} + \\sigma \\int_0^t e^{-a(t-s)} dW_s\n$$\n\n**$X_T$ 的均值：**\n为了求均值，我们对 $t=T$ 时的解取期望。对于确定性被积函数 $f(s)$，Itô 积分的期望为零，即 $\\mathbb{E}[\\int_0^T f(s)dW_s] = 0$。\n$$\n\\mathbb{E}[X_T] = \\mathbb{E}[m + (x_0-m)e^{-aT}] + \\sigma \\mathbb{E}\\left[\\int_0^T e^{-a(T-s)} dW_s\\right]\n$$\n$$\n\\mathbb{E}[X_T] = m + (x_0 - m)e^{-aT}\n$$\n\n**$X_T$ 的方差：**\n方差完全由随机项决定。使用 Itô 等距性质，该性质表明 $\\text{Var}(\\int_0^T f(s) dW_s) = \\int_0^T f(s)^2 ds$：\n$$\n\\text{Var}(X_T) = \\text{Var}\\left(\\sigma \\int_0^T e^{-a(T-s)}dW_s\\right) = \\sigma^2 \\int_0^T (e^{-a(T-s)})^2 ds = \\sigma^2 \\int_0^T e^{-2a(T-s)}ds\n$$\n计算该积分：\n$$\n\\int_0^T e^{-2a(T-s)}ds = \\left[\\frac{e^{-2a(T-s)}}{2a}\\right]_0^T = \\frac{1}{2a}(e^0 - e^{-2aT}) = \\frac{1-e^{-2aT}}{2a}\n$$\n因此，真实解的方差为：\n$$\n\\text{Var}(X_T) = \\frac{\\sigma^2}{2a}(1 - e^{-2aT})\n$$\n真实解 $X_T$ 是一个高斯随机变量，因为它是一个常数加上一个具有确定性被积函数的 Itô 积分。\n\n**2. 检验函数的期望**\n对于一个高斯随机变量 $Y \\sim \\mathcal{N}(\\mu, v)$，检验函数 $f_1, f_2, f_3$ 的期望推导如下：\n- $f_1(x) = x$：$\\mathbb{E}[f_1(Y)] = \\mathbb{E}[Y] = \\mu$。\n- $f_3(x) = x^2$：根据方差的定义 $\\text{Var}(Y) = \\mathbb{E}[Y^2] - (\\mathbb{E}[Y])^2$，我们得到 $\\mathbb{E}[f_3(Y)] = \\mathbb{E}[Y^2] = v + \\mu^2$。\n- $f_2(x) = \\sin(x)$：这个期望可以使用高斯分布的特征函数 $\\phi_Y(k) = \\mathbb{E}[e^{ikY}] = e^{ik\\mu - \\frac{1}{2}vk^2}$ 来计算：\n$$\n\\mathbb{E}[\\sin(Y)] = \\mathbb{E}\\left[\\frac{e^{iY}-e^{-iY}}{2i}\\right] = \\frac{1}{2i}(\\phi_Y(1) - \\phi_Y(-1)) = \\frac{1}{2i}\\left(e^{i\\mu - \\frac{v}{2}} - e^{-i\\mu - \\frac{v}{2}}\\right) = e^{-\\frac{v}{2}}\\sin(\\mu)\n$$\n通过将 $(\\mu, v)$ 替换为 $X_T$ 和 $X_T^{\\text{EM}}$ 各自的均值-方差对，使用这些公式来计算精确期望。\n\n**3. 均值误差的渐近分析**\n我们分析当 $\\Delta t \\to 0^+$ 时，对于 $f_1(x)=x$ 的主阶差异 $|\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}]|$。该误差正比于 $|e^{-aT} - (1 - a\\Delta t)^{T/\\Delta t}|$。我们对小 $\\Delta t$ 的离散项进行展开：\n$$\n(1 - a\\Delta t)^{T/\\Delta t} = \\exp\\left(\\frac{T}{\\Delta t}\\log(1 - a\\Delta t)\\right)\n$$\n使用泰勒展开式 $\\log(1-x) = -x - x^2/2 - O(x^3)$，其中 $x=a\\Delta t$：\n$$\n\\frac{T}{\\Delta t}\\log(1 - a\\Delta t) = \\frac{T}{\\Delta t}\\left(-a\\Delta t - \\frac{(a\\Delta t)^2}{2} - O((\\Delta t)^3)\\right) = -aT - \\frac{a^2T\\Delta t}{2} - O((\\Delta t)^2)\n$$\n将此代回指数函数，并对小的 $y$ 使用 $e^{y} = 1+y+O(y^2)$：\n$$\n(1-a\\Delta t)^{T/\\Delta t} = e^{-aT} e^{-a^2T\\Delta t/2 - O((\\Delta t)^2)} = e^{-aT}\\left(1 - \\frac{a^2T\\Delta t}{2} + O((\\Delta t)^2)\\right)\n$$\n那么均值的差异为：\n$$\n\\mathbb{E}[X_T] - \\mathbb{E}[X_T^{\\text{EM}}] = (x_0-m)\\left[e^{-aT} - \\left(e^{-aT} - e^{-aT}\\frac{a^2T\\Delta t}{2} + \\dots\\right)\\right] = (x_0-m)e^{-aT}\\frac{a^2T}{2}\\Delta t + O((\\Delta t)^2)\n$$\n这表明均值的误差是 $\\mathcal{O}(\\Delta t)$ 阶的，从第一性原理证实了均值的弱收敛阶为 $1$。\n\n**4. 经验弱阶估计方法**\n对于检验函数 $f$ 和时间步长 $\\Delta t$，弱误差为 $E(\\Delta t) = |\\mathbb{E}[f(X_T)] - \\mathbb{E}[f(X_T^{\\text{EM}})]|$。弱收敛阶 $p$ 由渐近关系 $E(\\Delta t) \\approx C(\\Delta t)^p$ 定义，其中 $C$ 为某个常数。对两边取自然对数，得到一个线性模型：\n$$\n\\log(E(\\Delta t)) \\approx p \\log(\\Delta t) + \\log(C)\n$$\n这条线的斜率就是弱阶 $p$。给定一组时间步长网格 $\\{\\Delta t_i\\}$ 对应的 $k$ 个误差 $\\{E_i\\}$，我们计算 $y_i = \\log(E_i)$ 和 $x_i = \\log(\\Delta t_i)$。然后通过对点 $(x_i, y_i)$ 进行线性最小二乘回归来估计参数 $p$。斜率由以下公式给出：\n$$\np = \\frac{k \\sum (x_i y_i) - (\\sum x_i)(\\sum y_i)}{k \\sum (x_i^2) - (\\sum x_i)^2}\n$$\n对每个参数集下的每个检验函数（$f_1, f_2, f_3$）应用此过程，以找到经验弱阶，该值预期接近 $1$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the empirical weak order of the Euler-Maruyama method for the\n    Ornstein-Uhlenbeck SDE for two parameter sets and three test functions.\n    \"\"\"\n    # Test Suite\n    test_cases = [\n        # Case 1: a=1.3, m=0.5, sigma=0.7, x0=-0.4, T=1.0\n        (1.3, 0.5, 0.7, -0.4, 1.0),\n        # Case 2: a=3.0, m=-0.2, sigma=0.5, x0=1.1, T=0.8\n        (3.0, -0.2, 0.5, 1.1, 0.8),\n    ]\n\n    all_orders = []\n\n    for case_params in test_cases:\n        a, m, sigma, x0, T = case_params\n\n        # Calculate mean and variance of the true solution X_T\n        mean_true = m + (x0 - m) * np.exp(-a * T)\n        var_true = (sigma**2 / (2 * a)) * (1 - np.exp(-2 * a * T))\n\n        # Test functions: a lambda to compute expectation from mean (mu) and variance (var)\n        test_functions = [\n            lambda mu, var: mu,                            # f1(x) = x\n            lambda mu, var: np.sin(mu) * np.exp(-var / 2), # f2(x) = sin(x)\n            lambda mu, var: var + mu**2,                   # f3(x) = x^2\n        ]\n\n        for func_exp in test_functions:\n            # Calculate true expectation for the current test function\n            exp_true = func_exp(mean_true, var_true)\n\n            dt_values = np.array([T / 10.0, T / 20.0, T / 40.0, T / 80.0])\n            errors = []\n\n            for dt in dt_values:\n                # Number of steps N=T/dt is an integer for the chosen dt values\n                N = T / dt\n                \n                # Calculate mean and variance of the Euler-Maruyama approximation\n                term_mean = (1 - a * dt)**N\n                mean_em = m + (x0 - m) * term_mean\n\n                term_var = (1 - a * dt)**(2 * N)\n                var_em = (sigma**2 / (a * (2 - a * dt))) * (1 - term_var)\n                \n                # Calculate EM expectation for the current test function\n                exp_em = func_exp(mean_em, var_em)\n                \n                # Calculate and store the weak error\n                errors.append(np.abs(exp_true - exp_em))\n\n            errors = np.array(errors)\n            \n            # Perform log-log linear regression to find the order p.\n            # The model is log(error) = p * log(dt) + C.\n            # np.polyfit(x, y, 1) returns [slope, intercept], so we take the first element.\n            log_dt = np.log(dt_values)\n            log_errors = np.log(errors)\n            \n            p = np.polyfit(log_dt, log_errors, 1)[0]\n            \n            all_orders.append(round(p, 3))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_orders))}]\")\n\nsolve()\n```", "id": "3226701"}, {"introduction": "在物理学和工程学中，随机过程通常使用斯特拉托诺维奇（Stratonovich）积分来描述，该积分遵循经典微积分法则，但与基于伊藤（Itô）积分的欧拉-丸山格式不兼容。此练习 ([@problem_id:3226843]) 提出了一个实际挑战：你必须首先运用随机微积分的知识，将一个斯特拉托诺维奇随机微分方程转换为其等价的伊藤形式。只有这样，你才能应用欧拉-丸山方法进行模拟，从而在理论建模与数值实现之间架起一座关键的桥梁。", "problem": "设 $W_t$ 表示一个标准布朗运动（维纳过程）。考虑一个一维 Stratonovich 随机微分方程 (SDE)，\n$$\ndX_t \\;=\\; a(X_t)\\,dt \\;+\\; b(X_t)\\circ dW_t,\n$$\n其中 $a(\\cdot)$ 和 $b(\\cdot)$ 是充分光滑的函数。仅从 Itô 和 Stratonovich 随机积分的基本定义以及它们所满足的链式法则出发，推导等价的 Itô 随机微分方程，并找出转换过程中产生的附加漂移项。然后，设计一个程序，使用 Euler–Maruyama (EM) 格式模拟所得 Itô 随机微分方程的样本路径，并根据理论推导的基准验证路径统计量。\n\n您的程序必须以基于原理的方式实现以下任务。\n\n- 推导任务：\n  - 从链式法则以及 Itô 和 Stratonovich 积分的定义极限出发，证明形式为\n    $$\n    dX_t \\;=\\; a(X_t)\\,dt \\;+\\; b(X_t)\\circ dW_t\n    $$\n    的 Stratonovich SDE 等价于形式为\n    $$\n    dX_t \\;=\\; f(X_t)\\,dt \\;+\\; g(X_t)\\,dW_t,\n    $$\n    的 Itô SDE，其中 $f(\\cdot)$ 和 $g(\\cdot)$ 需要用 $a(\\cdot)$、$b(\\cdot)$ 及其导数来表示。不得假定任何预先推导出的转换公式；您必须从积分的基本定义及其链式法则进行推理。\n\n- 离散化任务：\n  - 在时间步长为 $h$ 的均匀网格上，为 Itô SDE $dX_t=f(X_t)\\,dt+g(X_t)\\,dW_t$ 实现 Euler–Maruyama (EM) 方法，即\n    $$\n    X_{n+1} \\;=\\; X_n \\;+\\; f(X_n)\\,h \\;+\\; g(X_n)\\,\\Delta W_n,\\qquad \\Delta W_n \\sim \\mathcal{N}(0,h),\n    $$\n    其中 $X_0$ 是给定的。在不同时间和不同路径上使用独立的高斯增量。使用下面每个测试用例指定的 $h$。\n\n- 统计验证任务：\n  - 对于每个指定的测试用例，使用 EM 方法模拟一个包含 $N$ 条独立路径的系综，直至时间 $T$。计算在终端时间 $T$ 的所需统计量，并与从 Itô SDE 推导出的精确理论值进行比较。每次比较都必须根据一个绝对容差进行评估，结果记录为一个布尔值，表示经验统计量是否在理论值的容差范围内。所需的统计量和容差在下面的测试套件中提供。\n\n测试套件。对于每种情况，您必须首先通过有理有据的推导将给定的 Stratonovich SDE 转换为其 Itô 形式，然后用 EM 方法进行模拟，最后验证所述的统计量。所有时间都使用相同的抽象单位；不涉及物理单位，也不需要角度单位。\n\n- 情况 A（线性漂移与常数扩散；零修正的边界测试）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)= -k\\,x$，$b(x)=\\sigma$。\n  - 参数：$k=1.1$, $\\sigma=0.6$, $X_0=1.3$, $T=1.0$, $h=0.005$, $N=30000$, 种子 $=12345$。\n  - Itô SDE 在时间 $T$ 的理论统计量：\n    - 均值：$\\mathbb{E}[X_T] \\,=\\, X_0\\,e^{-kT}$。\n    - 方差：$\\mathrm{Var}(X_T) \\,=\\, \\dfrac{\\sigma^2}{2k}\\left(1-e^{-2kT}\\right)$。\n  - 容差：均值容差 $\\tau_{\\text{mean}}=0.04$，方差容差 $\\tau_{\\text{var}}=0.05$。\n  - 此情况的验证输出：按顺序输出两个布尔值，均值是否在容差内，方差是否在容差内。\n\n- 情况 B（乘性噪声；非零转换修正；几何增长）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)=\\mu_{\\mathrm{S}}\\,x$，$b(x)=\\sigma\\,x$。\n  - 参数：$\\mu_{\\mathrm{S}}=0.10$, $\\sigma=0.50$, $X_0=1.2$, $T=1.0$, $h=0.005$, $N=30000$, 种子 $=54321$。\n  - Itô SDE 在时间 $T$ 的理论统计量：\n    - 均值：$\\mathbb{E}[X_T] \\,=\\, X_0\\,\\exp\\!\\big(\\mu_{\\mathrm{I}}\\,T\\big)$，其中 $\\mu_{\\mathrm{I}}$ 是乘以 $x$ 的 Itô 漂移系数，您必须通过转换推导出该系数。\n  - 容差：均值容差 $\\tau_{\\text{mean}}=0.04$。\n  - 此情况的验证输出：一个布尔值，均值是否在容差内。\n\n- 情况 C（平方根扩散；具有奇异导数的状态依赖噪声；正性挑战）：\n  - Stratonovich SDE: $dX_t \\,=\\, a(X_t)\\,dt + b(X_t)\\circ dW_t$，其中 $a(x)=0$，$b(x)=2\\sqrt{x}$。\n  - 参数：$X_0=0.4$, $T=1.0$, $h=0.005$, $N=30000$, 种子 $=20231102$。\n  - Itô SDE 在时间 $T$ 的理论统计量：\n    - 均值：$\\mathbb{E}[X_T] \\,=\\, X_0 + T$。\n  - 容差：均值容差 $\\tau_{\\text{mean}}=0.05$。\n  - 数值稳定性说明：在数值格式中计算 $b(x)$ 时，使用 $\\sqrt{\\max(x,0)}$ 以确保平方根有明确定义；这可以防止由离散化引入的罕见负向偏移。\n  - 此情况的验证输出：一个布尔值，均值是否在容差内。\n\n需满足的实现细节：\n- 严格按照所述方式使用 Euler–Maruyama 方法。\n- 使用由 $\\sqrt{h}$ 缩放的独立标准正态随机变量作为增量 $\\Delta W_n$。\n- 为保证可复现性，对每种情况使用给定的随机种子。\n- 按顺序生成所有要求的布尔值：情况 A 均值、情况 A 方差、情况 B 均值、情况 C 均值。\n\n要求的最终输出格式：\n- 您的程序必须打印一行，其中包含一个由方括号括起来的、逗号分隔的四个布尔结果列表，例如 $[{\\rm True},{\\rm False},{\\rm True},{\\rm True}]$。\n\n不需要外部输入；所有参数均已在上方指定。答案必须不带单位，也不含额外文本。最终打印的行必须与格式完全匹配。", "solution": "该问题是有效的，因为它在随机微积分理论中有科学依据，具有所有必要的参数和指定条件，定义明确，并且以客观、正式的语言表述。我们将首先从基本原理推导 Stratonovich 和 Itô SDE 之间的关系，然后将其应用于具体情况，最后设计一个数值模拟来验证理论结果。\n\n### 第 1 部分：Itô-Stratonovich 转换公式的推导\n\n核心任务是将形式为\n$$\ndX_t = a(X_t)\\,dt + b(X_t)\\circ dW_t\n$$\n的 Stratonovich SDE 转换为其等价的 Itô 形式\n$$\ndX_t = f(X_t)\\,dt + g(X_t)\\,dW_t.\n$$\n这需要将以 `$\\circ$` 表示的 Stratonovich 积分与 Itô 积分联系起来。根本区别在于定义它们的 Riemann-Stieltjes 和中被积函数的求值点。Itô 积分使用时间区间的左端点，而 Stratonovich 积分使用中点。\n\n对于一个一般过程 $Y_t$，这两个积分之间的关系由下式给出：\n$$\n\\int_0^T Y_t \\circ dW_t = \\int_0^T Y_t \\,dW_t + \\frac{1}{2} [Y, W]_T\n$$\n其中 $[Y, W]_T$ 是过程 $Y_t$ 和 $W_t$ 在区间 $[0, T]$ 上的二次协变差。其微分形式为：\n$$\nY_t \\circ dW_t = Y_t \\,dW_t + \\frac{1}{2} d[Y, W]_t.\n$$\n在我们的问题中，过程 $Y_t$ 是 $X_t$ 的函数，具体为 $Y_t = b(X_t)$。我们需要找到协变差 $d[b(X), W]_t$。二次协变差是根据 Itô 微积分的法则由微分项的乘积计算得出：$dt \\cdot dt = 0$，$dt \\cdot dW_t = 0$，以及 $dW_t \\cdot dW_t = dt$。协变差的微分为 $d[b(X), W]_t = d(b(X_t)) \\cdot dW_t$。\n\n为了求得 $d(b(X_t))$，我们对函数 $b(x)$ 应用 Itô 引理（Itô 过程的链式法则），假设 $X_t$ 服从目标 Itô SDE $dX_t = f(X_t)dt + g(X_t)dW_t$：\n$$\nd(b(X_t)) = b'(X_t) dX_t + \\frac{1}{2} b''(X_t) (dX_t)^2\n$$\n代入 $dX_t = f(X_t)dt + g(X_t)dW_t$ 并应用 Itô 乘法法则：\n\\begin{align*}\nd(b(X_t)) = b'(X_t) (f(X_t)dt + g(X_t)dW_t) + \\frac{1}{2} b''(X_t) (f(X_t)dt + g(X_t)dW_t)^2 \\\\\n= b'(X_t)f(X_t)dt + b'(X_t)g(X_t)dW_t + \\frac{1}{2} b''(X_t) g(X_t)^2 dt\n\\end{align*}\n现在，我们计算协变差的微分：\n$$\nd[b(X), W]_t = d(b(X_t)) \\cdot dW_t = (b'(X_t)g(X_t)dW_t) \\cdot dW_t = b'(X_t)g(X_t)dt.\n$$\n现在我们可以将其代回积分关系式中：\n$$\nb(X_t) \\circ dW_t = b(X_t) \\,dW_t + \\frac{1}{2} b'(X_t)g(X_t)dt.\n$$\n我们将其代入原始的 Stratonovich SDE 中：\n$$\ndX_t = a(X_t)dt + \\left( b(X_t) \\,dW_t + \\frac{1}{2}b'(X_t)g(X_t)dt \\right).\n$$\n通过将此方程中的 $dW_t$ 项与目标 Itô 形式 $dX_t = f(X_t)dt + g(X_t)dW_t$进行比较，我们必须有 $g(X_t) = b(X_t)$。\n\n将 $g(x) = b(x)$ 代入我们推导出的表达式中，得到：\n$$\ndX_t = a(X_t)dt + b(X_t) \\,dW_t + \\frac{1}{2}b'(X_t)b(X_t)dt.\n$$\n最后，将 $dt$ 项合并，得到等价的 Itô SDE：\n$$\ndX_t = \\left( a(X_t) + \\frac{1}{2}b(X_t)b'(X_t) \\right)dt + b(X_t)dW_t.\n$$\n由此，我们确定了 Itô 形式的函数：\n$$\nf(x) = a(x) + \\frac{1}{2}b(x)b'(x)\n$$\n$$\ng(x) = b(x)\n$$\n项 $\\frac{1}{2}b(x)b'(x)$ 是 Itô-Stratonovich 修正项。\n\n### 第 2 部分：应用于测试用例和离散化\n\n我们现在将此转换公式应用于每种情况，并定义 Euler-Maruyama 格式。对于时间步长为 $h$ 的 Itô SDE $dX_t = f(X_t)dt + g(X_t)dW_t$，其格式为：\n$$\nX_{n+1} = X_n + f(X_n)h + g(X_n)\\Delta W_n,\n$$\n其中 $X_n \\approx X(nh)$ 且 $\\Delta W_n \\sim \\mathcal{N}(0,h)$ 是维纳过程的独立增量。\n\n**情况 A：线性漂移，常数扩散**\n- Stratonovich SDE: $a(x) = -k x$, $b(x) = \\sigma$。\n- $b(x)$ 的导数：$b'(x) = 0$。\n- 修正项：$\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(\\sigma)(0) = 0$。\n- Itô SDE: $dX_t = (-k X_t + 0)dt + \\sigma dW_t = -k X_t dt + \\sigma dW_t$。\n- 这是一个 Ornstein-Uhlenbeck 过程。其 Itô 和 Stratonovich 形式是相同的。\n- 用于模拟：$f(x) = -k x$，$g(x) = \\sigma$。\n- 理论均值 $\\mathbb{E}[X_T] = X_0 e^{-kT}$ 和方差 $\\mathrm{Var}(X_T) = \\frac{\\sigma^2}{2k}(1-e^{-2kT})$ 是该过程的已知矩。\n\n**情况 B：乘性噪声，几何增长**\n- Stratonovich SDE: $a(x) = \\mu_{\\mathrm{S}} x$, $b(x) = \\sigma x$。\n- $b(x)$ 的导数：$b'(x) = \\sigma$。\n- 修正项：$\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(\\sigma x)(\\sigma) = \\frac{1}{2}\\sigma^2 x$。\n- Itô SDE 漂移项：$f(x) = a(x) + \\frac{1}{2}b(x)b'(x) = \\mu_{\\mathrm{S}} x + \\frac{1}{2}\\sigma^2 x = (\\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2) x$。\n- Itô SDE: $dX_t = (\\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2) X_t dt + \\sigma X_t dW_t$。\n- 这是一个几何布朗运动。Itô 漂移系数为 $\\mu_{\\mathrm{I}} = \\mu_{\\mathrm{S}} + \\frac{1}{2}\\sigma^2$。\n- 用于模拟：$f(x) = \\mu_{\\mathrm{I}} x$，$g(x) = \\sigma x$。\n- 理论均值为 $\\mathbb{E}[X_T] = X_0 \\exp(\\mu_{\\mathrm{I}}T)$，与问题陈述相符。\n\n**情况 C：平方根扩散**\n- Stratonovich SDE: $a(x) = 0$, $b(x) = 2\\sqrt{x}$。\n- $b(x)$ 的导数：$b'(x) = 2 \\cdot \\frac{1}{2}x^{-1/2} = \\frac{1}{\\sqrt{x}}$。\n- 修正项：$\\frac{1}{2}b(x)b'(x) = \\frac{1}{2}(2\\sqrt{x})(\\frac{1}{\\sqrt{x}}) = 1$。出人意料的是，该修正项是一个常数。\n- Itô SDE 漂移项：$f(x) = a(x) + \\frac{1}{2}b(x)b'(x) = 0 + 1 = 1$。\n- Itô SDE: $dX_t = 1 \\cdot dt + 2\\sqrt{X_t} dW_t$。\n- 用于模拟：$f(x) = 1$，$g(x) = 2\\sqrt{x}$。\n- 为了求理论均值，我们对 Itô SDE 取期望：$d\\mathbb{E}[X_t] = \\mathbb{E}[1]dt + \\mathbb{E}[2\\sqrt{X_t}dW_t]$。Itô 积分的期望为零，因此 $d\\mathbb{E}[X_t] = dt$。\n- 从 $0$ 到 $T$ 积分得到 $\\mathbb{E}[X_T] - \\mathbb{E}[X_0] = T$。由于 $X_0$ 是一个常数，这给出 $\\mathbb{E}[X_T] = X_0 + T$，与问题相符。\n\n模拟过程将为每个推导出的 Itô SDE 实现 Euler-Maruyama 格式，生成 $N$ 条路径，并计算在时间 $T$ 的样本均值和方差，以便与这些理论基准进行比较。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives Itô SDEs from Stratonovich SDEs, simulates them using the\n    Euler-Maruyama method, and validates path statistics.\n    \"\"\"\n    results = []\n\n    # --- Case A: Ornstein-Uhlenbeck Process ---\n    # Parameters\n    k = 1.1\n    sigma = 0.6\n    X0 = 1.3\n    T = 1.0\n    h = 0.005\n    N = 30000\n    seed = 12345\n    \n    # Stratonovich: a(x) = -k*x, b(x) = sigma\n    # b'(x) = 0. Correction term is 0.\n    # Itô: f(x) = -k*x, g(x) = sigma\n    f_A = lambda x: -k * x\n    g_A = lambda x: sigma\n\n    # Simulation\n    rng = np.random.default_rng(seed)\n    num_steps = int(T / h)\n    X = np.full(N, X0, dtype=np.float64)\n    # Pre-generate all random increments for efficiency\n    dW = rng.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n\n    for i in range(num_steps):\n        X = X + f_A(X) * h + g_A(X) * dW[i, :]\n\n    # Statistical Validation\n    theo_mean_A = X0 * np.exp(-k * T)\n    theo_var_A = (sigma**2 / (2 * k)) * (1 - np.exp(-2 * k * T))\n    emp_mean_A = np.mean(X)\n    emp_var_A = np.var(X)\n    \n    tau_mean_A = 0.04\n    tau_var_A = 0.05\n\n    results.append(np.abs(emp_mean_A - theo_mean_A) = tau_mean_A)\n    results.append(np.abs(emp_var_A - theo_var_A) = tau_var_A)\n\n    # --- Case B: Geometric Brownian Motion ---\n    # Parameters\n    mu_S = 0.10\n    sigma_B = 0.50\n    X0_B = 1.2\n    # T, h, N are the same\n    seed_B = 54321\n\n    # Stratonovich: a(x) = mu_S*x, b(x) = sigma*x\n    # b'(x) = sigma. Correction term is 0.5 * b(x) * b'(x) = 0.5 * (sigma*x) * sigma = 0.5 * sigma^2 * x.\n    # Itô drift coefficient: mu_I = mu_S + 0.5 * sigma^2\n    mu_I = mu_S + 0.5 * sigma_B**2\n    f_B = lambda x: mu_I * x\n    g_B = lambda x: sigma_B * x\n\n    # Simulation\n    rng_B = np.random.default_rng(seed_B)\n    X_B = np.full(N, X0_B, dtype=np.float64)\n    dW_B = rng_B.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n    \n    for i in range(num_steps):\n        X_B = X_B + f_B(X_B) * h + g_B(X_B) * dW_B[i, :]\n    \n    # Statistical Validation\n    theo_mean_B = X0_B * np.exp(mu_I * T)\n    emp_mean_B = np.mean(X_B)\n    \n    tau_mean_B = 0.04\n    \n    results.append(np.abs(emp_mean_B - theo_mean_B) = tau_mean_B)\n\n    # --- Case C: Square-Root Diffusion ---\n    # Parameters\n    X0_C = 0.4\n    # T, h, N are the same\n    seed_C = 20231102\n\n    # Stratonovich: a(x) = 0, b(x) = 2*sqrt(x)\n    # b'(x) = 1/sqrt(x). Correction term is 0.5 * b(x) * b'(x) = 0.5 * (2*sqrt(x)) * (1/sqrt(x)) = 1.\n    # Itô: f(x) = 1, g(x) = 2*sqrt(x)\n    f_C = lambda x: 1.0\n    # Use np.maximum to handle potential negative values from discretization noise\n    g_C = lambda x: 2.0 * np.sqrt(np.maximum(x, 0))\n\n    # Simulation\n    rng_C = np.random.default_rng(seed_C)\n    X_C = np.full(N, X0_C, dtype=np.float64)\n    dW_C = rng_C.standard_normal(size=(num_steps, N)) * np.sqrt(h)\n\n    for i in range(num_steps):\n        X_C = X_C + f_C(X_C) * h + g_C(X_C) * dW_C[i, :]\n\n    # Statistical Validation\n    theo_mean_C = X0_C + T\n    emp_mean_C = np.mean(X_C)\n    \n    tau_mean_C = 0.05\n    \n    results.append(np.abs(emp_mean_C - theo_mean_C) = tau_mean_C)\n\n    # Print a single line with the comma-separated list of booleans\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3226843"}]}