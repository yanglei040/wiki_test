{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式就是亲手实践。这个练习将指导你完成一个求解边值问题的完整流程，从构建一个已知精确解的基准问题开始。通过“人造解”（method of manufactured solutions）方法，你不仅能练习有限差分法的基本步骤，还能掌握一种验证数值代码正确性的重要技巧。[@problem_id:3104017]", "problem": "考虑以下用于常微分方程 (ODE) 的线性两点边值问题 (BVP) 的人造解基准问题，其定义在区间 $[0,1]$ 上。其精确解给定为 $u(x)=e^{x}-x$，狄利克雷边界条件为 $u(0)=1$ 和 $u(1)=e-1$。您的任务是：\n\n1) 推导一个线性的、常系数的、二阶 ODE，其右侧为多项式，使得精确解 $u(x)=e^{x}-x$ 满足该 ODE 和边界条件。从一阶和二阶导数的定义出发，计算 $u'(x)$ 和 $u''(x)$，以构建形式为 $u''(x)-u(x)=g(x)$ 的 ODE，然后确定使 $u(x)$ 成为精确解的 $g(x)$。\n\n2) 在均匀网格 $x_{i}=ih$ 上离散化得到的 BVP，其中 $i\\in\\{0,1,\\dots,N+1\\}$，$N$ 是内部点的数量，$h=1/(N+1)$。使用从泰勒展开推导出的二阶导数中心差分近似，为未知数 $\\{u_{1},u_{2},\\dots,u_{N}\\}$ 建立相应的三对角线性系统，并强制执行边界条件 $u_{0}=1$ 和 $u_{N+1}=e-1$。\n\n3) 实现一个完整、可运行的程序，该程序：\n- 对于测试集 $N\\in\\{1,10,20,40\\}$ 中的每个 $N$，构建并求解三对角线性系统。\n- 重构包含边界值的网格函数，并计算所有网格点 $x_{i}$（$i\\in\\{0,1,\\dots,N+1\\}$）上与精确解 $u(x)=e^{x}-x$ 相比的最大绝对误差。\n- 为每个 $N$ 报告最大绝对误差，该误差为一个四舍五入到八位小数的浮点数。\n\n您可以使用的基础知识：\n- 一阶导数 $u'(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-u(x)}{h}$ 和二阶导数 $u''(x)=\\lim_{h\\to 0}\\dfrac{u(x+h)-2u(x)+u(x-h)}{h^{2}}$ 的定义。\n- 关于点 $x$ 对一个足够光滑的函数的泰勒展开。\n- 用于求解线性系统的标准线性代数。\n\n科学真实性要求：\n- 纯粹在数学术语下工作，不涉及物理单位。\n- 不涉及角度和百分比。\n\n测试集和输出规范：\n- 使用测试集 $N\\in\\{1,10,20,40\\}$。\n- 对每个 $N$，计算包括端点在内的整个网格上的最大绝对误差。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序与测试集中 $N$ 的值相对应。每个条目必须四舍五入到八位小数。例如，包含三个假设结果的输出应类似于 [$r_{1},$ $r_{2},$ $r_{3}$]，其中每个 $r_{k}$ 是一个四舍五入到八位小数的十进制数。\n- 程序必须是自包含的，且不需要用户输入。", "solution": "用户提供的问题是数值分析领域一个明确定义的练习，具体涉及有限差分法在两点边值问题 (BVP) 上的应用。该问题是有效的，因为它在数学上是合理的、自包含的且客观的。它基于微积分和数值方法的既定原理。所有提供的数据，包括人造解和边界条件，都是一致的。\n$u(x) = e^x - x$\n$u(0) = e^0 - 0 = 1$\n$u(1) = e^1 - 1 = e-1$\n边界条件陈述正确。此问题将按要求分三部分解决。\n\n### 第一部分：边值问题的推导\n\n问题要求推导一个形式为 $u''(x) - u(x) = g(x)$ 的线性、常系数、二阶 ODE，其精确解为 $u(x) = e^x - x$。\n\n首先，我们计算给定解 $u(x)$ 的一阶和二阶导数。\n精确解为：\n$$u(x) = e^x - x$$\n\n一阶导数 $u'(x)$ 为：\n$$u'(x) = \\frac{d}{dx}(e^x - x) = e^x - 1$$\n\n二阶导数 $u''(x)$ 为：\n$$u''(x) = \\frac{d}{dx}(e^x - 1) = e^x$$\n\n现在，我们将 $u(x)$ 和 $u''(x)$ 代入指定的 ODE 形式 $u''(x) - u(x) = g(x)$ 中，以求得右侧函数 $g(x)$：\n$$g(x) = u''(x) - u(x) = (e^x) - (e^x - x)$$\n$$g(x) = e^x - e^x + x = x$$\n\n函数 $g(x) = x$ 是一个多项式，符合要求。因此，完整的 BVP 是：\n$$\n\\begin{cases}\nu''(x) - u(x) = x,  x \\in [0, 1] \\\\\nu(0) = 1 \\\\\nu(1) = e - 1\n\\end{cases}\n$$\n\n### 第二部分：离散化与线性系统的构建\n\n接下来，我们使用有限差分法在均匀网格上对推导出的 BVP 进行离散化。区域 $[0, 1]$ 被划分为 $N+1$ 个等宽的子区间，宽度为 $h = 1/(N+1)$。网格点为 $x_i = ih$，其中 $i = 0, 1, \\dots, N+1$。解在这些网格点上的值记为 $u_i = u(x_i)$。\n\nODE $u''(x) - u(x) = x$ 必须在每个内部网格点 $x_i$（$i = 1, 2, \\dots, N$）上成立：\n$$u''(x_i) - u(x_i) = x_i$$\n\n我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$：\n$$u''(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}$$\n\n将此近似代入 ODE，得到一个关于未知内部值 $\\{u_1, u_2, \\dots, u_N\\}$ 的代数方程组：\n$$\\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} - u_i = x_i, \\quad \\text{for } i = 1, 2, \\dots, N$$\n\n为了构成一个线性系统，我们重新整理方程，将涉及未知数的项组合在左侧：\n$$u_{i-1} - 2u_i - h^2 u_i + u_{i+1} = h^2 x_i$$\n$$1 \\cdot u_{i-1} + (-2 - h^2)u_i + 1 \\cdot u_{i+1} = h^2 (ih) = ih^3$$\n\n这组 $N$ 个方程构成一个三对角线性系统 $A\\mathbf{u} = \\mathbf{b}$，其中 $\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$。\n\n$N \\times N$ 矩阵 $A$ 具有以下结构：\n- 主对角线元素：$A_{ii} = -2 - h^2$\n- 次对角线元素：$A_{i, i-1} = 1$\n- 超对角线元素：$A_{i, i+1} = 1$\n\n$$A = \\begin{pmatrix}\n-2-h^2   1   0   \\dots   0 \\\\\n1   -2-h^2   1   \\dots   0 \\\\\n0   1   -2-h^2   \\ddots   \\vdots \\\\\n\\vdots   \\ddots   \\ddots   \\ddots   1 \\\\\n0   \\dots   0   1   -2-h^2\n\\end{pmatrix}$$\n\n右侧向量 $\\mathbf{b}$ 是一个 $N \\times 1$ 的列向量。我们必须整合给定的狄利克雷边界条件 $u_0 = 1$ 和 $u_{N+1} = e-1$。\n\n对于第一个方程（$i=1$）：\n$$u_0 + (-2 - h^2)u_1 + u_2 = 1 \\cdot h^3$$\n由于 $u_0 = 1$ 是已知的，我们将其移到右侧：\n$$(-2 - h^2)u_1 + u_2 = h^3 - u_0 = h^3 - 1$$\n因此，向量 $\\mathbf{b}$ 的第一个元素是 $b_1 = h^3 - 1$。\n\n对于最后一个方程（$i=N$）：\n$$u_{N-1} + (-2 - h^2)u_N + u_{N+1} = N h^3$$\n由于 $u_{N+1} = e-1$ 是已知的，我们将其移到右侧：\n$$u_{N-1} + (-2 - h^2)u_N = Nh^3 - u_{N+1} = Nh^3 - (e-1)$$\n因此，向量 $\\mathbf{b}$ 的最后一个元素是 $b_N = Nh^3 - e + 1$。\n\n对于一般的内部方程（$i=2, \\dots, N-1$）：\n$$u_{i-1} + (-2-h^2)u_i + u_{i+1} = ih^3$$\n$\\mathbf{b}$ 的相应元素是 $b_i = ih^3$。\n\n总结来说，右侧向量 $\\mathbf{b} = [b_1, b_2, \\dots, b_N]^T$ 是：\n$$b_i = \\begin{cases}\nh^3 - 1   \\text{if } i=1 \\\\\nih^3   \\text{if } 2 \\le i \\le N-1 \\\\\nNh^3 - (e-1)   \\text{if } i=N\n\\end{cases}$$\n$N=1$ 的情况通过此构造得到正确处理，因为 $i=1$ 和 $i=N$ 的条件都将应用于 $b_1$，导致 $b_1 = (h^3-1) - (e-1) = h^3 - e$，这对于单个方程 $u_0 + (-2-h^2)u_1 + u_2 = h^3 \\implies (-2-h^2)u_1 = h^3 - u_0 - u_2$ 是正确的。\n\n### 第三部分：实现算法\n\n对于测试集 $\\{1, 10, 20, 40\\}$ 中的每个 $N$ 值，实现将执行以下步骤：\n1.  **初始化参数**：计算步长 $h = 1/(N+1)$ 和 $e$ 的值。\n2.  **构建线性系统**：\n    -   以适用于高效求解器（例如 `scipy.linalg.solve_banded`）的带状格式创建三对角矩阵 $A$。这需要创建一个 $3 \\times N$ 的数组，其中各行分别代表超对角线、主对角线和次对角线。\n    -   根据第二部分推导的公式构造大小为 $N$ 的右侧向量 $\\mathbf{b}$。\n3.  **求解系统**：求解线性系统 $A\\mathbf{u} = \\mathbf{b}$，得到内部解的向量 $\\mathbf{u} = [u_1, \\dots, u_N]^T$。\n4.  **重构完整解**：组装包括边界值在内的完整数值解向量：$U_{num} = [u_0, u_1, \\dots, u_N, u_{N+1}] = [1, \\mathbf{u}^T, e-1]^T$。\n5.  **计算精确解**：创建网格点向量 $X = [x_0, x_1, \\dots, x_{N+1}]$，其中 $x_i = ih$。在每个网格点上评估精确解 $u(x) = e^x - x$ 以获得向量 $U_{exact}$。\n6.  **计算误差**：计算数值解与精确解在所有网格点上的最大绝对误差：$E_{max} = \\max_{i \\in \\{0, \\dots, N+1\\}} |U_{num, i} - U_{exact, i}|$。\n7.  **存储和格式化结果**：将计算出的最大误差四舍五入到八位小数并存储。在处理完所有 $N$ 值后，将收集到的结果格式化为指定的字符串格式。\n\n此过程将封装在一个 Python 程序中，并按要求使用 `numpy` 和 `scipy` 库。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the BVP u''(x) - u(x) = x on [0,1] with u(0)=1, u(1)=e-1\n    using a finite difference scheme for a given set of N values.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [1, 10, 20, 40]\n\n    results = []\n    for N in test_cases:\n        # Step 1: Initialize Parameters\n        # N: number of interior points\n        # There are N+2 total points (including boundaries)\n        h = 1.0 / (N + 1)\n        \n        # Exact boundary values\n        u0 = 1.0\n        uN_plus_1 = np.e - 1.0\n\n        # Step 2: Construct the tridiagonal linear system A*u = b\n        \n        # Construct the tridiagonal matrix A in banded format for SciPy.\n        # The format is a (3, N) array:\n        # Row 0: Super-diagonal (padded with a 0 at the start)\n        # Row 1: Main diagonal\n        # Row 2: Sub-diagonal (padded with a 0 at the end)\n        ab = np.zeros((3, N))\n        ab[0, 1:] = 1.0  # Super-diagonal\n        ab[1, :] = -2.0 - h**2  # Main diagonal\n        ab[2, :-1] = 1.0  # Sub-diagonal\n\n        # Construct the right-hand side vector b\n        # Start with the base value b_i = i * h^3\n        b = np.array([(i + 1) * h**3 for i in range(N)])\n        \n        # Incorporate boundary conditions\n        b[0] -= u0\n        b[-1] -= uN_plus_1\n        \n        # Step 3: Solve the system for the interior points u\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Step 4: Reconstruct the full numerical solution grid function\n        u_numerical = np.concatenate(([u0], u_interior, [uN_plus_1]))\n\n        # Step 5: Compute the exact solution at grid points\n        # Grid points x_i = i*h for i = 0, ..., N+1\n        x = np.linspace(0, 1, N + 2)\n        u_exact = np.exp(x) - x\n\n        # Step 6: Calculate the maximum absolute error\n        # The error at the boundaries is zero by construction (up to float precision)\n        max_error = np.max(np.abs(u_numerical - u_exact))\n        \n        # Add the rounded result to the list\n        results.append(max_error)\n\n    # Final print statement in the exact required format.\n    # Each result is formatted to eight decimal places.\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3104017"}, {"introduction": "在物理和工程问题中，边界条件常常涉及导数，例如描述绝热边界的热通量。本练习将重点关注如何处理这类诺伊曼（Neumann）边界条件，同时保持数值方法的精度。你将学习并实现“虚点法”（ghost point method），这是一种在有限差分框架中处理导数边界条件的关键且优雅的技术，并会通过收敛性分析来验证方法的准确性。[@problem_id:3211343]", "problem": "您的任务是设计并实现一个二阶有限差分求解器，用于求解一个带有诺伊曼边界条件的常微分方程一维边值问题。其数学模型为线性泊松方程：\n$u''(x) = f(x), x \\in [0,1],$\n在左端点有一个诺伊曼边界条件，在右端点有一个狄利克雷边界条件：\n$u'(0) = \\alpha, \\quad u(1) = \\beta.$\n您必须使用一个将区间 $[0,1]$ 进行 $m$ 次等分的均匀网格，网格点为 $x_i = i h$，其中 $h = 1/m$ 且 $i = 0,1,\\dots,m$。您的数值方法必须：\n- 在内部节点处使用标准的二阶中心差分来近似二阶导数。\n- 在 $x=0$ 处使用“虚拟点”实现诺伊曼条件，使得边界处的导数由中心差分近似，并通过调用常微分方程 $u''(x)=f(x)$ 和适当的泰勒展开来消除该虚拟点，以保持二阶精度。设计必须从基本定义（网格、泰勒展开和常微分方程）出发，并避免使用特设的公式。\n- 在 $x=1$ 处结合狄利克雷边界条件，并要保证在最后一个内部节点处保持二阶精度。\n\n您的程序必须求解内部未知数 $u(x_i)$（其中 $i=1,2,\\dots,m-1$）的离散线性系统，然后计算相对于精确解析解在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上的最大绝对误差。\n\n为了进行验证，通过对 $u''(x)=f(x)$ 进行两次积分，并利用边界条件来确定积分常数，从而推导出精确解析解。对于下方的每个测试用例，程序必须计算：\n- 使用您设计的在 $x=0$ 处采用虚拟点处理的二阶格式，计算内部网格点上的数值解。\n- 在相同的内部网格点上的精确解。\n- 内部点上的最大绝对误差（即逐点误差向量的无穷范数），表示为一个实数。\n\n此外，对于收敛性评估测试，计算观测到的精度阶 $p$，其定义为：\n$p = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right),$\n其中 $E_{h}$ 和 $E_{h/2}$ 分别是使用 $m$ 和 $2m$ 个子区间的网格所产生的最大绝对误差。\n\n使用以下测试套件：\n1. 理想情况：$f(x) = 2, \\alpha = 1, \\beta = 0, m = 50$。精确解通过求解 $u''(x)=2$ 并结合给定的边界条件得到。\n2. 边界条件主导的粗网格：$f(x) = 0, \\alpha = 0, \\beta = 1, m = 4$。精确解是一个常数。\n3. 振荡强迫项：$f(x) = -\\pi^2 \\sin(\\pi x), \\alpha = 0, \\beta = 0, m = 64$。精确解通过求解 $u''(x) = -\\pi^2 \\sin(\\pi x)$ 并结合给定的边界条件得到。\n4. 收敛阶：$f(x) = x, \\alpha = 0, \\beta = 0$, 使用两个网格 $m=20$ 和 $m=40$。按上述定义计算观测到的阶数 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述测试套件一致。前三项必须是代表每种情况下最大绝对误差的实数，最后一项必须是代表收敛性测试中观测到的阶数的实数。例如，输出应类似于 $[e_1,e_2,e_3,p]$，其中每个 $e_i$ 和 $p$ 都是实数。", "solution": "用户提供的问题是有效的，因为它在科学上基于常微分方程数值方法的理论，在数学上是适定的，并且用客观、形式化的标准进行了定义。本文档为验证提供了数值方法的完整推导和解析解。\n\n问题是求解在区间 $x \\in [0,1]$ 上的一维泊松方程，这是一个线性二阶常微分方程（ODE）：\n$$\nu''(x) = f(x)\n$$\n其在 $x=0$ 处有诺伊曼边界条件，在 $x=1$ 处有狄利克雷边界条件：\n$$\nu'(0) = \\alpha, \\quad u(1) = \\beta.\n$$\n\n我们将构建一个二阶有限差分格式来近似该解。\n\n**1. 区域离散化**\n\n将区域 $[0,1]$ 离散化为一个有 $m$ 个子区间的均匀网格。网格间距为 $h = 1/m$。网格点定义为 $x_i = i h$，其中 $i = 0, 1, \\dots, m$。令 $U_i$ 为网格点 $x_i$ 处精确解 $u(x_i)$ 的数值近似。$x=1$ 处的边界条件给出 $U_m = u(1) = \\beta$。需要确定的值是 $U_0, U_1, \\dots, U_{m-1}$。\n\n**2. 内部点的有限差分近似**\n\n对于任何内部网格点 $x_i$（其中 $i = 1, 2, \\dots, m-1$），我们使用二阶中心差分公式来近似二阶导数 $u''(x_i)$。这可由 $u(x_{i+1})$ 和 $u(x_{i-1})$ 在 $x_i$ 点的泰勒级数展开得到：\n$$\nu(x_{i+1}) = u(x_i+h) = u(x_i) + h u'(x_i) + \\frac{h^2}{2} u''(x_i) + \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n$$\nu(x_{i-1}) = u(x_i-h) = u(x_i) - h u'(x_i) + \\frac{h^2}{2} u''(x_i) - \\frac{h^3}{6} u'''(x_i) + O(h^4)\n$$\n将这两个展开式相加并整理得到 $u''(x_i)$ 的表达式：\n$$\nu''(x_i) = \\frac{u(x_{i+1}) - 2u(x_i) + u(x_{i-1})}{h^2} - \\frac{h^2}{12} u^{(4)}(x_i) + \\dots\n$$\n该近似具有二阶精度，局部截断误差为 $O(h^2)$。将 $u(x_i)$ 替换为 $U_i$，并根据常微分方程将 $u''(x_i)$ 替换为 $f(x_i)$，我们得到内部节点的离散方程：\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i), \\quad \\text{for } i = 1, 2, \\dots, m-1.\n$$\n\n**3. $x=0$ 处诺伊曼边界条件的离散化**\n\n题目要求使用虚拟点来保持二阶精度。我们在 $x_{-1} = -h$ 处引入一个虚拟点。\n首先，我们使用二阶中心差分在 $x_0 = 0$ 处近似导数 $u'(0) = \\alpha$：\n$$\nu'(0) = \\frac{u(x_1) - u(x_{-1})}{2h} + O(h^2) \\implies \\frac{U_1 - U_{-1}}{2h} = \\alpha\n$$\n这给出了虚拟点值 $U_{-1}$ 的表达式：\n$$\nU_{-1} = U_1 - 2h\\alpha\n$$\n接下来，我们假设常微分方程 $u''(x) = f(x)$ 在边界点 $x_0=0$ 处也成立。我们应用中心差分公式来表示 $u''(0)$：\n$$\n\\frac{U_{-1} - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n现在，我们将 $U_{-1}$ 的表达式代入此方程以消除虚拟点：\n$$\n\\frac{(U_1 - 2h\\alpha) - 2U_0 + U_1}{h^2} = f(x_0)\n$$\n简化此表达式得到节点 $i=0$ 的方程：\n$$\n\\frac{-2U_0 + 2U_1 - 2h\\alpha}{h^2} = f(x_0) \\implies -2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha\n$$\n该边界格式的局部截断误差为 $O(h)$，这足以保证整个方法的全局误差为 $O(h^2)$。\n\n**4. 线性系统的组装**\n\n我们得到了一个关于 $m$ 个未知数 $U_0, U_1, \\dots, U_{m-1}$ 的 $m$ 个线性方程组。设 $\\mathbf{U} = [U_0, U_1, \\dots, U_{m-1}]^T$ 为未知数向量。该系统可以写作 $A \\mathbf{U} = \\mathbf{b}$。\n\n方程组如下：\n- 对于 $i=0$: $-2U_0 + 2U_1 = h^2 f(x_0) + 2h\\alpha$\n- 对于 $i=1, \\dots, m-2$: $U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n- 对于 $i=m-1$: $U_{m-2} - 2U_{m-1} + U_m = h^2 f(x_{m-1})$。由于 $U_m = \\beta$，该方程变为 $U_{m-2} - 2U_{m-1} = h^2 f(x_{m-1}) - \\beta$。\n\n$m \\times m$ 的系数矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n-2   2   0   \\cdots   \\cdots   0 \\\\\n1   -2   1   \\ddots       \\vdots \\\\\n0   1   -2   1   \\ddots   \\vdots \\\\\n\\vdots   \\ddots   \\ddots   \\ddots   \\ddots   0 \\\\\n\\vdots       \\ddots   1   -2   1 \\\\\n0   \\cdots   \\cdots   0   1   -2\n\\end{pmatrix}\n$$\n大小为 $m$ 的右端向量 $\\mathbf{b}$ 为：\n$$\n\\mathbf{b} = \\begin{pmatrix}\nh^2 f(x_0) + 2h\\alpha \\\\\nh^2 f(x_1) \\\\\n\\vdots \\\\\nh^2 f(x_{m-2}) \\\\\nh^2 f(x_{m-1}) - \\beta\n\\end{pmatrix}\n$$\n该线性系统 $A \\mathbf{U} = \\mathbf{b}$ 是非奇异的，可以求解得到数值解 $\\mathbf{U}$。\n\n**5. 误差计算与收敛阶**\n\n最大绝对误差 $E_h$ 在内部网格点 $\\{x_i\\}_{i=1}^{m-1}$ 上计算为误差向量的无穷范数：\n$$\nE_h = \\max_{i=1,\\dots,m-1} |U_i - u(x_i)|\n$$\n对于一个二阶精度的方法，误差预计表现为 $E_h \\approx C h^2$，其中 $C$ 为某个常数。精度阶 $p$ 可以通过比较两种不同网格尺寸 $h$ 和 $h/2$ 的误差来数值地观测。\n$$\nE_h \\approx C h^p \\quad \\text{and} \\quad E_{h/2} \\approx C (h/2)^p\n$$\n取其比值得到 $\\frac{E_h}{E_{h/2}} \\approx 2^p$。求解 $p$ 得：\n$$\np = \\log_2\\left(\\frac{E_{h}}{E_{h/2}}\\right)\n$$\n\n**6. 测试用例的解析解**\n\n精确解 $u(x)$ 通过对 $u''(x) = f(x)$ 进行两次积分，并应用边界条件 $u'(0) = \\alpha$ 和 $u(1) = \\beta$ 来确定积分常数而得到。\n\n- **用例 1:** $f(x) = 2$, $\\alpha = 1$, $\\beta = 0$.\n$u'' = 2 \\implies u'(x) = 2x+C_1$。$u'(0)=C_1=1$。所以 $u'(x)=2x+1$。\n$u(x) = x^2+x+C_2$。$u(1)=1+1+C_2=0 \\implies C_2=-2$。\n$u(x) = x^2+x-2$。\n\n- **用例 2:** $f(x) = 0$, $\\alpha = 0$, $\\beta = 1$.\n$u'' = 0 \\implies u'(x) = C_1$。$u'(0)=C_1=0$。所以 $u'(x)=0$。\n$u(x) = C_2$。$u(1)=C_2=1$。\n$u(x) = 1$。\n\n- **用例 3:** $f(x) = -\\pi^2 \\sin(\\pi x)$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = -\\pi^2 \\sin(\\pi x) \\implies u'(x) = \\pi \\cos(\\pi x)+C_1$。$u'(0)=\\pi+C_1=0 \\implies C_1=-\\pi$。\n$u'(x) = \\pi \\cos(\\pi x) - \\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + C_2$。$u(1)=\\sin(\\pi)-\\pi+C_2=0 \\implies C_2=\\pi$。\n$u(x) = \\sin(\\pi x) - \\pi x + \\pi$。\n\n- **用例 4:** $f(x) = x$, $\\alpha = 0$, $\\beta = 0$.\n$u''(x) = x \\implies u'(x) = x^2/2+C_1$。$u'(0)=C_1=0$。所以 $u'(x)=x^2/2$。\n$u(x) = x^3/6+C_2$。$u(1)=1/6+C_2=0 \\implies C_2=-1/6$。\n$u(x) = \\frac{x^3}{6} - \\frac{1}{6}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for the finite difference solver.\n    \"\"\"\n\n    def run_solver(f, alpha, beta, m):\n        \"\"\"\n        Solves u''(x) = f(x) with u'(0)=alpha, u(1)=beta on a grid with m subdivisions.\n        \n        Args:\n            f (callable): The forcing function f(x).\n            alpha (float): The Neumann boundary condition value at x=0.\n            beta (float): The Dirichlet boundary condition value at x=1.\n            m (int): The number of grid subdivisions.\n            \n        Returns:\n            tuple: A tuple containing:\n                - np.ndarray: Grid points for the interior, x_1, ..., x_{m-1}.\n                - np.ndarray: Numerical solution at the interior points, U_1, ..., U_{m-1}.\n        \"\"\"\n        # Grid setup\n        h = 1.0 / m\n        # We solve for unknowns at x_0, x_1, ..., x_{m-1}\n        x_nodes = np.linspace(0, 1, m + 1)\n        \n        # Assemble the m x m matrix A\n        A = np.zeros((m, m))\n        \n        # Fill diagonals for the standard interior stencil (1, -2, 1)\n        np.fill_diagonal(A, -2.0)\n        # Lower diagonal (k=-1): A[i, i-1] = 1 for i=1,...,m-1\n        np.fill_diagonal(A[1:], 1.0)\n        # Upper diagonal (k=1): A[i, i+1] = 1 for i=0,...,m-2\n        np.fill_diagonal(A[:, 1:], 1.0)\n        \n        # Modify the first row for the Neumann condition: -2*U_0 + 2*U_1 = ...\n        A[0, 1] = 2.0\n        \n        # Assemble the right-hand side vector b of size m\n        # We evaluate f at x_0, ..., x_{m-1}\n        b = h**2 * f(x_nodes[0:m])\n        \n        # Modify first and last elements of b for boundary conditions\n        # b_0 = h^2*f(x_0) + 2*h*alpha\n        b[0] += 2.0 * h * alpha\n        # b_{m-1} = h^2*f(x_{m-1}) - beta\n        b[m-1] -= beta\n        \n        # Solve the linear system A*U = b for U = [U_0, ..., U_{m-1}]\n        U = np.linalg.solve(A, b)\n        \n        # Return interior grid points and corresponding solution values\n        return x_nodes[1:m], U[1:]\n\n    results = []\n\n    # Test Case 1: Happy path\n    f1 = lambda x: 2.0 * np.ones_like(x)\n    u_exact1 = lambda x: x**2 + x - 2.0\n    alpha1, beta1, m1 = 1.0, 0.0, 50\n    x_interior1, U_interior1 = run_solver(f1, alpha1, beta1, m1)\n    u_exact_vals1 = u_exact1(x_interior1)\n    error1 = np.max(np.abs(U_interior1 - u_exact_vals1))\n    results.append(error1)\n\n    # Test Case 2: Boundary-condition-dominant coarse grid\n    f2 = lambda x: np.zeros_like(x)\n    u_exact2 = lambda x: np.ones_like(x)\n    alpha2, beta2, m2 = 0.0, 1.0, 4\n    x_interior2, U_interior2 = run_solver(f2, alpha2, beta2, m2)\n    u_exact_vals2 = u_exact2(x_interior2)\n    error2 = np.max(np.abs(U_interior2 - u_exact_vals2))\n    results.append(error2)\n\n    # Test Case 3: Oscillatory forcing\n    f3 = lambda x: -np.pi**2 * np.sin(np.pi * x)\n    u_exact3 = lambda x: np.sin(np.pi * x) - np.pi * x + np.pi\n    alpha3, beta3, m3 = 0.0, 0.0, 64\n    x_interior3, U_interior3 = run_solver(f3, alpha3, beta3, m3)\n    u_exact_vals3 = u_exact3(x_interior3)\n    error3 = np.max(np.abs(U_interior3 - u_exact_vals3))\n    results.append(error3)\n\n    # Test Case 4: Convergence order\n    f4 = lambda x: x\n    u_exact4 = lambda x: x**3 / 6.0 - 1.0 / 6.0\n    alpha4, beta4 = 0.0, 0.0\n    \n    # Solve on grid with m=20\n    m_h = 20\n    x_h, U_h = run_solver(f4, alpha4, beta4, m_h)\n    u_h = u_exact4(x_h)\n    E_h = np.max(np.abs(U_h - u_h))\n    \n    # Solve on grid with m=40\n    m_h2 = 40\n    x_h2, U_h2 = run_solver(f4, alpha4, beta4, m_h2)\n    u_h2 = u_exact4(x_h2)\n    E_h2 = np.max(np.abs(U_h2 - u_h2))\n    \n    order_p = np.log2(E_h / E_h2)\n    results.append(order_p)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3211343"}, {"introduction": "虽然我们在前两个练习中使用的二阶方法简单有效，但在追求更高计算效率时，高阶方法往往更具优势。在投入精力编写更复杂的代码之前，理解其理论优势至关重要。这个练习旨在通过分析比较二阶和四阶格式的全局误差，让你深入理解“精度阶” ($p$) 的实际意义，即误差与步长 $h$ 呈 $h^p$ 关系，以及它如何影响网格加密时的误差收敛速度。[@problem_id:2377632]", "problem": "考虑常微分方程（ODE）的两点边值问题（BVP）\n$$\ny''(x) = -\\,y(x) \\quad \\text{on} \\quad [0,\\tfrac{\\pi}{2}],\n$$\n其狄利克雷边界条件为\n$$\ny(0)=0, \\quad y\\!\\left(\\tfrac{\\pi}{2}\\right)=1.\n$$\n设 $x_i = i h$ (其中 $i=0,1,\\dots,m+1$) 为一个间距为 $h = \\tfrac{\\pi}{2(m+1)}$ 的均匀网格，并令 $y_i$ 表示 $y(x_i)$ 的数值近似。\n\n考虑两种有限差分（FD）离散化方法：\n\n1) 标准的二阶三点格式：对于每个内部索引 $i=1,2,\\dots,m$，\n$$\n\\frac{y_{i+1}-2 y_i + y_{i-1}}{h^2} \\;=\\; -\\,y_i,\n$$\n边界值为 $y_0=0$ 和 $y_{m+1}=1$。\n\n2) 内部的标准四阶五点格式：对于每个内部索引 $i=2,3,\\dots,m-1$，\n$$\n\\frac{-\\,y_{i-2} + 16\\,y_{i-1} - 30\\,y_i + 16\\,y_{i+1} - y_{i+2}}{12\\,h^2} \\;=\\; -\\,y_i,\n$$\n以及在 $i=1$ 和 $i=m$ 处任何保持名义全局四阶精度的相容四阶边界闭合格式，并使用相同的边界值 $y_0=0$ 和 $y_{m+1}=1$。\n\n当 $h \\to 0$ 时，哪个陈述正确地比较了这两种格式的渐近全局精度（例如，在内部网格点上的最大范数意义下）以及当 $h$ 减半时相应的误差缩减因子？\n\nA. 二阶格式是全局 $\\mathcal{O}(h^2)$ 的，四阶格式是全局 $\\mathcal{O}(h^4)$ 的。当 $h$ 减半时，它们的误差分别减少约 $4$ 倍和 $16$ 倍。\n\nB. 对于这个带有狄利克雷边界的问题，两种格式都是全局 $\\mathcal{O}(h^2)$ 的；将 $h$ 减半会使两种误差都减少约 $4$ 倍。\n\nC. 二阶格式在任何均匀网格上对于 $y(x)=\\sin x$ 都是精确的，而四阶格式则表现出 $\\mathcal{O}(h^2)$ 阶的边界层误差。\n\nD. 对于这种形式的常系数问题，四阶格式达到了 $\\mathcal{O}(h^6)$ 的全局精度；将 $h$ 减半会使其误差减少约 $64$ 倍。\n\nE. 由于边界效应，二阶格式的全局精度仅为 $\\mathcal{O}(h)$，而四阶格式保持 $\\mathcal{O}(h^4)$ 的精度。", "solution": "用户提出了一个关于两点边值问题数值解的问题。作为我的职责，我将首先严格验证问题陈述。\n\n### 步骤 1：提取已知条件\n- **常微分方程 (ODE)：** $y''(x) = -y(x)$\n- **定义域：** $[0, \\frac{\\pi}{2}]$\n- **狄利克雷边界条件：** $y(0)=0$, $y(\\frac{\\pi}{2})=1$\n- **网格：** 一个均匀网格 $x_i = i h$，其中 $i=0, 1, \\dots, m+1$，间距为 $h = \\frac{\\pi}{2(m+1)}$。\n- **数值近似：** $y_i$ 是 $y(x_i)$ 的近似值。\n- **格式 1 (二阶)：** 对于 $i=1, 2, \\dots, m$，离散化为 $\\frac{y_{i+1}-2 y_i + y_{i-1}}{h^2} = -y_i$，边界值为 $y_0=0$ 和 $y_{m+1}=1$。\n- **格式 2 (四阶)：** 对于 $i=2, 3, \\dots, m-1$，离散化为 $\\frac{-y_{i-2} + 16y_{i-1} - 30y_i + 16y_{i+1} - y_{i+2}}{12h^2} = -y_i$。题目指明，该格式辅以“在 $i=1$ 和 $i=m$ 处任何保持名义全局四阶精度的相容四阶边界闭合格式”，并使用 $y_0=0$ 和 $y_{m+1}=1$。\n\n### 步骤 2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题牢固地植根于微分方程和数值分析领域。ODE $y''+y=0$ 是简谐振子的方程，这是物理学中的一个基本模型。所提出的有限差分法是求解该方程的标准、成熟的技术。\n2.  **适定性：** 该边值问题是适定的。$y''+y=0$ 的通解为 $y(x) = C_1\\cos(x) + C_2\\sin(x)$。应用边界条件 $y(0)=0$ 得到 $C_1=0$，而 $y(\\frac{\\pi}{2})=1$ 得到 $C_2=1$。因此，存在一个唯一、稳定且有意义的解析解：$y(x) = \\sin(x)$。\n3.  **客观性：** 该问题使用精确的数学语言陈述，没有歧义或主观内容。\n4.  **完整性：** 该问题提供了分析数值格式渐近精度的所有必要信息。提及“相容的四阶边界闭合格式”是数值分析中的一个标准理论手段，表明与边界相关的误差源不会降低内部的精度阶。这种抽象是可以接受的，并不会使问题不完整。\n5.  **一致性：** 所提供的信息没有内部矛盾。\n\n### 步骤 3：结论与行动\n问题陈述是有效的。它在科学上是合理的、适定的，并且对于数值方法的理论分析是完整的。我现在将着手推导解决方案。\n\n### 推导与分析\n\n问题的核心是通过分析每种有限差分格式的局部截断误差来确定其精度阶。对于一个稳定的方法，只要边界条件处理得足够精确，全局误差的阶数将与局部截断误差的阶数相同。\n\n**格式 1 的分析：二阶格式**\n\n第一种格式通过 $\\frac{y_{i+1}-2 y_i + y_{i-1}}{h^2} + y_i = 0$ 来近似 ODE $y''(x_i) + y(x_i) = 0$。局部截断误差 $\\tau_i$ 是通过将精确解 $y(x)$ 代入有限差分方程得到的。\n\n$$\n\\tau_i = \\left(\\frac{y(x_{i+1}) - 2y(x_i) + y(x_{i-1})}{h^2}\\right) + y(x_i)\n$$\n\n使用 $y(x_{i \\pm 1})$ 在 $x_i$ 点的泰勒级数展开：\n$y(x_{i+1}) = y(x_i) + h y'(x_i) + \\frac{h^2}{2} y''(x_i) + \\frac{h^3}{6} y'''(x_i) + \\frac{h^4}{24} y^{(4)}(x_i) + \\mathcal{O}(h^5)$\n$y(x_{i-1}) = y(x_i) - h y'(x_i) + \\frac{h^2}{2} y''(x_i) - \\frac{h^3}{6} y'''(x_i) + \\frac{h^4}{24} y^{(4)}(x_i) + \\mathcal{O}(h^5)$\n\n将这些代入二阶导数的近似表达式中，得到：\n$$\n\\frac{y(x_{i+1}) - 2y(x_i) + y(x_{i-1})}{h^2} = y''(x_i) + \\frac{h^2}{12} y^{(4)}(x_i) + \\mathcal{O}(h^4)\n$$\n\n因此，截断误差为：\n$$\n\\tau_i = \\left(y''(x_i) + \\frac{h^2}{12} y^{(4)}(x_i) + \\mathcal{O}(h^4)\\right) + y(x_i)\n$$\n由于精确解满足 $y''(x_i) + y(x_i) = 0$，上式可简化为：\n$$\n\\tau_i = \\frac{h^2}{12} y^{(4)}(x_i) + \\mathcal{O}(h^4)\n$$\n局部截断误差为 $\\mathcal{O}(h^2)$。对于一个具有精确指定的狄利克雷边界的稳定格式，全局误差也是 $\\mathcal{O}(h^2)$。如果误差 $E$ 与 $h^2$ 成正比，即 $E \\approx C h^2$，将步长减半为 $h/2$ 会得到新的误差 $E' \\approx C (h/2)^2 = C h^2/4 = E/4$。误差减少了 $4$ 倍。\n\n**格式 2 的分析：四阶格式**\n\n第二种格式使用五点模板来近似二阶导数。其局部截断误差为：\n$$\n\\tau_i = \\left(\\frac{-y(x_{i-2}) + 16y(x_{i-1}) - 30y(x_i) + 16y(x_{i+1}) - y(x_{i+2})}{12h^2}\\right) + y(x_i)\n$$\n一个类似但更冗长的泰勒展开分析表明：\n$$\n\\frac{-y(x_{i-2}) + \\dots - y(x_{i+2})}{12h^2} = y''(x_i) - \\frac{h^4}{90} y^{(6)}(x_i) + \\mathcal{O}(h^6)\n$$\n该格式的截断误差为：\n$$\n\\tau_i = \\left(y''(x_i) - \\frac{h^4}{90} y^{(6)}(x_i) + \\mathcal{O}(h^6)\\right) + y(x_i)\n$$\n再次使用 $y''(x_i) + y(x_i) = 0$，我们得到：\n$$\n\\tau_i = - \\frac{h^4}{90} y^{(6)}(x_i) + \\mathcal{O}(h^6)\n$$\n局部截断误差为 $\\mathcal{O}(h^4)$。问题陈述中说明，使用了适当的四阶边界闭合格式以确保全局精度不被降低。因此，全局误差为 $\\mathcal{O}(h^4)$。如果误差 $E \\approx C h^4$，将步长减半会得到新的误差 $E' \\approx C (h/2)^4 = C h^4/16 = E/16$。误差减少了 $16$ 倍。\n\n### 逐项分析选项\n\n现在我将根据我的推导来评估每个提供的选项。\n\n**A. 二阶格式是全局 $\\mathcal{O}(h^2)$ 的，四阶格式是全局 $\\mathcal{O}(h^4)$ 的。当 $h$ 减半时，它们的误差分别减少约 $4$ 倍和 $16$ 倍。**\n这个陈述与我们的理论分析完全一致。全局误差阶分别为 $\\mathcal{O}(h^2)$ 和 $\\mathcal{O}(h^4)$，当 $h$ 减半时，相应的误差缩减因子为 $2^2=4$ 和 $2^4=16$。\n**结论：正确**\n\n**B. 对于这个带有狄利克雷边界的问题，两种格式都是全局 $\\mathcal{O}(h^2)$ 的；将 $h$ 减半会使两种误差都减少约 $4$ 倍。**\n这个陈述错误地声称四阶格式的全局精度仅为 $\\mathcal{O}(h^2)$。使用更复杂的五点模板和相关的边界闭合格式的目的正是为了实现更高的精度阶。\n**结论：不正确**\n\n**C. 二阶格式在任何均匀网格上对于 $y(x)=\\sin x$ 都是精确的，而四阶格式则表现出 $\\mathcal{O}(h^2)$ 阶的边界层误差。**\n该陈述的第一部分是错误的。只有当截断误差恒为零时，格式才是精确的。对于格式 1，$\\tau_i = \\frac{h^2}{12} y^{(4)}(x_i) + \\mathcal{O}(h^4) = \\frac{h^2}{12} \\sin(x_i) + \\mathcal{O}(h^4)$，它不为零。第二部分也是错误的；问题明确指出，选择边界闭合格式是为了*保持*四阶精度，而不是将其降低到 $\\mathcal{O}(h^2)$。\n**结论：不正确**\n\n**D. 对于这种形式的常系数问题，四阶格式达到了 $\\mathcal{O}(h^6)$ 的全局精度；将 $h$ 减半会使其误差减少约 $64$ 倍。**\n这是不正确的。我们的分析表明，局部截断误差的主项是 $\\mathcal{O}(h^4)$，导致全局精度为 $\\mathcal{O}(h^4)$。要达到 $\\mathcal{O}(h^6)$ 的精度，需要误差中 $h^4$ 项的系数（涉及 $y^{(6)}(x)$）为零，但对于 $y(x)=\\sin(x)$ 来说，情况并非如此。\n**结论：不正确**\n\n**E. 由于边界效应，二阶格式的全局精度仅为 $\\mathcal{O}(h)$，而四阶格式保持 $\\mathcal{O}(h^4)$ 的精度。**\n这是不正确的。对于一个具有精确实现的狄利克雷边界条件的二阶线性ODE，一个二阶内部格式会产生 $\\mathcal{O}(h^2)$ 的全局误差，而不是 $\\mathcal{O}(h)$。边界精度的损失通常发生在用低阶公式近似导数边界条件时。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "2377632"}]}