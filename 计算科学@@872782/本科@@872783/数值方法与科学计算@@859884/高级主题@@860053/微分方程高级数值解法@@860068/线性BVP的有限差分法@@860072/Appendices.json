{"hands_on_practices": [{"introduction": "第一个实践将指导您从头开始构建一个稳健的有限差分求解器。您将学习处理带有混合边界条件的通用线性边界值问题，这是在模拟热传导或力学等物理现象时常见的情景。掌握微分算子和边界条件的离散化是每位计算科学家的基本功。[@problem_id:3228073]", "problem": "考虑以下散度（自伴随）形式的线性二阶常微分方程\n$$\n-\\,\\frac{d}{dx}\\left(p(x)\\,\\frac{d u}{dx}\\right) + q(x)\\,u(x) = r(x),\n$$\n该方程定义在闭区间 $[a,b]$ 上，其中 $p(x)$、$q(x)$ 和 $r(x)$ 是给定的足够光滑的函数，且 $p(x) > 0$，解 $u(x)$ 服从以下混合边界条件：\n$$\nu(a) = \\alpha \\quad \\text{（在 } x=a\\text{ 处为狄利克雷条件）}, \\qquad u'(b) = \\beta \\quad \\text{（在 } x=b\\text{ 处为诺伊曼条件）}。\n$$\n您的任务是，从第一性原理出发，在均匀网格上推导出一个二阶精度的有限差分法（FDM）离散格式，并实现该方法以求解此边值问题。推导过程必须从一阶导数的核心定义和围绕网格点的泰勒级数展开开始，并且不得假定任何已知的离散格式。具体要求如下：\n- 从一阶导数的定义开始，并应用网格点附近的泰勒级数展开来获得二阶近似。\n- 使用得到的近似在内部网格点上对算子 $-(p u')'$ 进行一致的离散化。在半网格点位置处理 $p(x)$，以使离散算子是守恒的。\n- 通过直接指定 $x=a$ 处的值来施加狄利克雷边界条件。\n- 使用通过泰勒级数推导的二阶单边差分公式在 $x=b$ 处施加诺伊曼边界条件。\n- 组装并求解得到的线性系统，以获得 $u(x)$ 的节点值。\n\n实现要求：\n- 使用一个包含 $N$ 个相等子区间的均匀网格，网格点为 $x_i = a + i h$（$i=0,1,\\dots,N$），网格间距为 $h = (b-a)/N$。\n- 在每个内部网格点，使用依赖于在半网格点位置求值的 $p(x)$ 的二阶一致通量差分来近似微分算子。\n- 使用一个针对 $u'(b)$ 的二阶单边有限差分关系式在 $x=b$ 处强制施加诺伊曼边界条件。\n\n测试套件：\n对于下方的每个测试用例，通过将数值解与提供的精确解进行比较，计算所有网格点上的最大绝对误差。最终的数值答案是无量纲实数（没有物理单位）。将每个结果表示为四舍五入到六位小数的浮点数。\n\n测试用例：\n1. 守恒扩散，无反应项：\n   - 定义域：$[a,b] = [0,1]$，$N = 50$。\n   - 系数：$p(x) = 1$，$q(x) = 0$，$r(x) = \\sin(x)$。\n   - 精确解：$u(x) = \\sin(x) + x$。\n   - 边界数据：$\\alpha = u(0)$，$\\beta = u'(1)$。\n\n2. 可变扩散系数，无反应项：\n   - 定义域：$[a,b] = [0,1]$，$N = 40$。\n   - 系数：$p(x) = 1 + x$，$q(x) = 0$，$r(x)$ 的选择方式使得 $u(x) = x^2$ 是该微分方程的解。使用 $r(x) = -\\frac{d}{dx}\\left(p(x)\\,\\frac{d}{dx} x^2\\right) = -(2 + 4x)$。\n   - 精确解：$u(x) = x^2$。\n   - 边界数据：$\\alpha = u(0)$，$\\beta = u'(1)$。\n\n3. 恒定扩散系数，有反应项：\n   - 定义域：$[a,b] = [0,1]$，$N = 60$。\n   - 系数：$p(x) = 1$，$q(x) = 2$，$r(x)$ 的选择方式使得 $u(x) = e^x$ 是该微分方程的解。使用 $r(x) = -u''(x) + q(x) u(x) = e^x$。\n   - 精确解：$u(x) = e^x$。\n   - 边界数据：$\\alpha = u(0)$，$\\beta = u'(1)$。\n\n4. 用于测试边界处理的边缘网格用例：\n   - 定义域：$[a,b] = [0,1]$，$N = 2$。\n   - 系数：$p(x) = 1$，$q(x) = 0$，$r(x) = \\sin(x)$。\n   - 精确解：$u(x) = \\sin(x) + x$。\n   - 边界数据：$\\alpha = u(0)$，$\\beta = u'(1)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4]”），其中每个结果是相应测试用例的最大绝对误差，四舍五入到六位小数。", "solution": "用户提供了有效的问题陈述。我将继续进行推导和求解。\n\n我们的任务是求解以下自伴随形式的线性二阶常微分方程：\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right) + q(x)u(x) = r(x), \\quad x \\in [a, b]\n$$\n该方程带有混合边界条件：狄利克雷条件 $u(a) = \\alpha$ 和诺伊曼条件 $u'(b) = \\beta$。函数 $p(x)$、$q(x)$ 和 $r(x)$ 是给定的，且 $p(x) > 0$。我们将在均匀网格上推导一个二阶精度的有限差分法并予以实现。\n\n**1. 网格与记号**\n\n我们在区间 $[a,b]$ 上定义一个包含 $N$ 个子区间的均匀网格。网格点为 $x_i = a + i h$，$i=0, 1, \\dots, N$，其中网格间距为 $h = (b-a)/N$。在这些点上的数值解将表示为 $U_i \\approx u(x_i)$。需要求解的未知数是 $U_1, U_2, \\dots, U_N$，因为 $U_0 = u(a) = \\alpha$ 由狄利克雷边界条件给定。这构成了一个包含 $N$ 个未知数的方程组。\n\n**2. 内部点的离散化**\n\n该微分方程可以写成 $-F'(x) + q(x)u(x) = r(x)$，其中 $F(x) = p(x)u'(x)$ 是通量。\n对于内部网格点 $x_i$（$i=1, \\dots, N-1$），我们使用以 $x_i$ 为中心的二阶中心差分来近似 $-F'(x_i)$ 项：\n$$\n-F'(x_i) \\approx -\\frac{F(x_i + h/2) - F(x_i - h/2)}{h}\n$$\n半网格点表示为 $x_{i \\pm 1/2} = x_i \\pm h/2$。这个近似具有 $O(h^2)$ 的精度。\n\n为保持二阶精度和算子的守恒性，我们在这些半网格点上近似通量 $F$。在 $x_{i+1/2}$ 处，我们有 $F(x_{i+1/2}) = p(x_{i+1/2}) u'(x_{i+1/2})$。我们使用以 $x_{i+1/2}$ 为中心的二阶中心差分来近似导数 $u'(x_{i+1/2})$：\n$$\nu'(x_{i+1/2}) \\approx \\frac{u(x_{i+1}) - u(x_i)}{h} = \\frac{U_{i+1} - U_i}{h} + O(h^2)\n$$\n令 $p_{i+1/2} = p(x_{i+1/2})$，则通量的近似为：\n$$\nF_{i+1/2} \\approx p_{i+1/2} \\frac{U_{i+1} - U_i}{h}\n$$\n类似地，在 $x_{i-1/2}$ 处：\n$$\nF_{i-1/2} \\approx p_{i-1/2} \\frac{U_i - U_{i-1}}{h}\n$$\n将这些通量近似代回到 $-F'(x_i)$ 的近似式中：\n$$\n-\\frac{d}{dx}\\left(p(x)\\frac{du}{dx}\\right)\\bigg|_{x_i} \\approx -\\frac{1}{h} \\left( p_{i+1/2} \\frac{U_{i+1} - U_i}{h} - p_{i-1/2} \\frac{U_i - U_{i-1}}{h} \\right)\n$$\n$$\n= \\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right]\n$$\n在内部点 $x_i$（$i=1, \\dots, N-1$）处的完整离散方程为：\n$$\n\\frac{1}{h^2} \\left[ -p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2}) U_i - p_{i+1/2} U_{i+1} \\right] + q(x_i) U_i = r(x_i)\n$$\n两边乘以 $h^2$，我们得到第 $i$ 行的线性方程：\n$$\n-p_{i-1/2} U_{i-1} + (p_{i-1/2} + p_{i+1/2} + h^2 q_i) U_i - p_{i+1/2} U_{i+1} = h^2 r_i\n$$\n其中 $q_i=q(x_i)$ 且 $r_i=r(x_i)$。\n\n**3. 边界条件的离散化**\n\n该系统需要 $N$ 个方程来求解 $N$ 个未知数 $U_1, \\dots, U_N$。我们已经从内部点得到了 $N-1$ 个方程。剩下的一个方程来自 $x_N=b$ 处的诺伊曼边界条件。\n\n**$x_0=a$ 处的狄利克雷条件：**\n$U_0$ 的值是已知的：$U_0 = \\alpha$。这个值不是未知数。对于第一个方程（$i=1$），包含 $U_0$ 的项被移到右侧：\n$$\n(p_{1/2} + p_{3/2} + h^2 q_1) U_1 - p_{3/2} U_2 = h^2 r_1 + p_{1/2} U_0 = h^2 r_1 + p_{1/2} \\alpha\n$$\n\n**$x_N=b$ 处的诺伊曼条件：**\n条件是 $u'(b) = \\beta$。我们需要使用一个二阶精度的单边差分公式。我们通过考虑 $u(x)$ 在 $x_N$ 附近的泰勒级数展开来推导这个公式：\n$$\nu(x_{N-1}) = u(x_N - h) = u(x_N) - h u'(x_N) + \\frac{h^2}{2} u''(x_N) - \\frac{h^3}{6} u'''(x_N) + O(h^4)\n$$\n$$\nu(x_{N-2}) = u(x_N - 2h) = u(x_N) - 2h u'(x_N) + \\frac{(2h)^2}{2} u''(x_N) - \\frac{(2h)^3}{6} u'''(x_N) + O(h^4)\n$$\n为了创建一个 $O(h^2)$ 精度的 $u'(x_N)$ 公式，我们必须消去 $u''(x_N)$ 项。我们将第一个方程乘以 $4$ 然后减去第二个方程：\n$$\n4u(x_{N-1}) - u(x_{N-2}) = 3u(x_N) - 2h u'(x_N) + O(h^3)\n$$\n求解 $u'(x_N)$：\n$$\nu'(x_N) = \\frac{3u(x_N) - 4u(x_{N-1}) + u(x_{N-2})}{2h} + O(h^2)\n$$\n将此应用于我们在 $x_N=b$ 处的离散问题，我们得到最后一个方程：\n$$\n\\frac{3U_N - 4U_{N-1} + U_{N-2}}{2h} = \\beta\n$$\n这可以写成：$U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$。注意，对于 $N=2$ 的特殊情况，点 $x_{N-2}$ 就是 $x_0$，因此方程涉及已知值 $U_0 = \\alpha$：$-4U_1 + 3U_2 = 2h\\beta - U_0 = 2h\\beta - \\alpha$。\n\n**4. 组装线性系统**\n\n我们组装 $N \\times N$ 的线性系统 $A \\vec{U} = \\vec{F}$，其中未知向量为 $\\vec{U} = [U_1, U_2, \\dots, U_N]^T$。为与编程实践对应，我们让矩阵和向量的索引从0开始，其中行/列 $k$ 对应于未知数 $U_{k+1}$。\n\n对于 $k = 0, \\dots, N-2$（代表在网格点 $x_{k+1}$ 处的常微分方程）：\n$x_j$（$j=k+1$）处的方程为：$-p_{j-\\frac{1}{2}}U_{j-1} + (p_{j-\\frac{1}{2}}+p_{j+\\frac{1}{2}}+h^2q_j)U_j -p_{j+\\frac{1}{2}}U_{j+1} = h^2r_j$。\n- **第 $k=0$ 行（对应 $U_1$）：**\n  $A_{0,0} = p_{1/2} + p_{3/2} + h^2 q_1$\n  $A_{0,1} = -p_{3/2}$\n  $F_0 = h^2 r_1 + p_{1/2} \\alpha$\n- **第 $k=1, \\dots, N-2$ 行（对应 $U_2, \\dots, U_{N-1}$）：**\n  $j = k+1$。未知数是 $U_j, U_{j \\pm 1}$，对应于 `U_vec` 的索引 $k, k \\pm 1$。\n  $A_{k, k-1} = -p_{k+1/2}$\n  $A_{k, k} = p_{k+1/2} + p_{k+3/2} + h^2 q_{k+1}$\n  $A_{k, k+1} = -p_{k+3/2}$\n  $F_k = h^2 r_{k+1}$\n\n- **第 $k=N-1$ 行（对应 $U_N$，来自诺伊曼边界条件）：**\n  - 如果 $N \\ge 3$：方程为 $U_{N-2} - 4U_{N-1} + 3U_N = 2h\\beta$。涉及的未知数对应于 `U_vec` 的索引 $N-3, N-2, N-1$。\n    $A_{N-1, N-3} = 1$\n    $A_{N-1, N-2} = -4$\n    $A_{N-1, N-1} = 3$\n    $F_{N-1} = 2h\\beta$\n  - 如果 $N=2$：方程为 $-4U_1 + 3U_2 = 2h\\beta - \\alpha$。未知数是 $U_1, U_2$，对应于 `U_vec` 的索引 $0, 1$。\n    $A_{1,0} = -4$\n    $A_{1,1} = 3$\n    $F_1 = 2h\\beta - \\alpha$\n\n这个完全确定的线性系统可以求解得到 $\\vec{U}$。然后，通过将狄利克雷值与解出的未知数连接起来，得到完整的数值解：$[U_0, U_1, \\dots, U_N]$。最后，通过将该向量与在网格点上求值的精确解进行比较，来计算最大绝对误差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Conservative diffusion, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 50,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n        {\n            \"name\": \"Variable diffusivity, no reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 40,\n            \"p\": lambda x: 1.0 + x,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: -(2.0 + 4.0 * x),\n            \"u_exact\": lambda x: x**2,\n            \"du_exact\": lambda x: 2.0 * x,\n        },\n        {\n            \"name\": \"Constant diffusivity with reaction\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 60,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 2.0,\n            \"r\": lambda x: np.exp(x),\n            \"u_exact\": lambda x: np.exp(x),\n            \"du_exact\": lambda x: np.exp(x),\n        },\n        {\n            \"name\": \"Edge-grid case\",\n            \"a\": 0.0, \"b\": 1.0, \"N\": 2,\n            \"p\": lambda x: 1.0,\n            \"q\": lambda x: 0.0,\n            \"r\": lambda x: np.sin(x),\n            \"u_exact\": lambda x: np.sin(x) + x,\n            \"du_exact\": lambda x: np.cos(x) + 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha = case[\"u_exact\"](case[\"a\"])\n        beta = case[\"du_exact\"](case[\"b\"])\n\n        U_numerical, x_grid = solve_bvp(\n            p=case[\"p\"], q=case[\"q\"], r=case[\"r\"],\n            a=case[\"a\"], b=case[\"b\"], N=case[\"N\"],\n            alpha=alpha, beta=beta\n        )\n\n        U_exact_vals = case[\"u_exact\"](x_grid)\n        max_abs_error = np.max(np.abs(U_numerical - U_exact_vals))\n        results.append(f\"{max_abs_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\ndef solve_bvp(p, q, r, a, b, N, alpha, beta):\n    \"\"\"\n    Solves the BVP using the derived finite difference scheme.\n    \n    The system is A * U_vec = F, where U_vec contains the N unknowns U_1, ..., U_N.\n    \"\"\"\n    h = (b - a) / N\n\n    # Grid points\n    x_grid = np.linspace(a, b, N + 1)\n    \n    # Initialize the linear system\n    A = np.zeros((N, N))\n    F = np.zeros(N)\n\n    # The vector of unknowns U_vec corresponds to U_1, ..., U_N\n    # U_vec[k] approximates u(x_{k+1})\n\n    # Equation for U_1 (matrix row 0)\n    # This corresponds to the ODE at x_1\n    p_half = p(x_grid[0] + h/2.0)\n    p_3half = p(x_grid[1] + h/2.0)\n    A[0, 0] = p_half + p_3half + h**2 * q(x_grid[1])\n    if N > 1:\n        A[0, 1] = -p_3half\n    F[0] = h**2 * r(x_grid[1]) + p_half * alpha\n\n    # Equations for U_2, ..., U_{N-1} (matrix rows 1 to N-2)\n    # This corresponds to the ODE at x_j where j = 2, ..., N-1\n    for j in range(2, N):\n        k = j - 1 # 0-based index for matrix row\n        \n        p_minus_half = p(x_grid[j] - h/2.0)\n        p_plus_half = p(x_grid[j] + h/2.0)\n        \n        A[k, k - 1] = -p_minus_half\n        A[k, k] = p_minus_half + p_plus_half + h**2 * q(x_grid[j])\n        A[k, k + 1] = -p_plus_half\n        F[k] = h**2 * r(x_grid[j])\n\n    # Equation for U_N (matrix row N-1) from Neumann BC\n    if N >= 3:\n        # One-sided 2nd order formula for u'(x_N) uses U_N, U_{N-1}, U_{N-2}\n        # U_N-2 - 4*U_{N-1} + 3*U_N = 2*h*beta\n        A[N - 1, N - 3] = 1.0\n        A[N - 1, N - 2] = -4.0\n        A[N - 1, N - 1] = 3.0\n        F[N - 1] = 2.0 * h * beta\n    elif N == 2:\n        # For N=2, formula uses U_2, U_1, U_0\n        # -4*U_1 + 3*U_2 = 2*h*beta - U_0\n        A[1, 0] = -4.0\n        A[1, 1] = 3.0\n        F[1] = 2.0 * h * beta - alpha\n    elif N == 1:\n        # For N=1, formula is 3*U_1 - 4*U_0 + ... not usable.\n        # But this problem doesn't test N=1. The standard one-sided formula is:\n        # (U_1 - U_0)/h = beta. A[0,0]=1, F[0]=h*beta+alpha.\n        # A simpler handling for N=1: (3U_1 - 4U_0 + U_{-1})/2h = beta\n        # Let's derive a simpler O(h^2) for this case:\n        # u(a) = u(b-h) = u(b)-h*u'(b)+h^2/2 u''(b) + ...\n        # alpha = U_1 - h*beta + h^2/2*... -> U_1 = alpha+h*beta\n        # Use equation at U1: -p0.5*(U0)+ (p0.5+p1.5+h^2q1)U1-p1.5U2 = h^2 r1 --> needs U2\n        # The prompt only requires handling N>=2\n        pass\n\n    # Solve the linear system\n    U_vec = np.linalg.solve(A, F)\n\n    # Combine with Dirichlet BC to form full solution\n    U_solution = np.concatenate(([alpha], U_vec))\n\n    return U_solution, x_grid\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3228073"}, {"introduction": "构建求解器后，理解其性能极限至关重要。本实践将通过一个带有不连续强迫函数的问题，探讨解的光滑性如何影响有限差分法的精度。通过将数值解与精确解进行比较，您将深入了解局部误差是如何产生的，并明白为何理解问题的内在特性是解读数值结果的关键。[@problem_id:3228101]", "problem": "考虑定义在区间 $[0,1]$ 上的带有狄利克雷边界条件的线性边值问题 (BVP)。令 $u:[0,1]\\to\\mathbb{R}$ 满足\n$$\nu''(x) = f(x), \\quad x\\in(0,1), \\qquad u(0)=0,\\quad u(1)=0,\n$$\n其中，强制函数 $f(x)$ 是在点 $x=x_c$ 处不连续的阶跃函数，由下式给出\n$$\nf(x) = \\begin{cases}\n1, & 0 \\le x < x_c,\\\\\n0, & x_c \\le x \\le 1.\n\\end{cases}\n$$\n使用具有 $N$ 个子区间的均匀网格，网格宽度为 $h=1/N$，节点为 $x_i = i h$（$i=0,1,\\dots,N$）。在内部节点 $\\{x_i\\}_{i=1}^{N-1}$ 处，通过 $u''(x)$ 的标准中心有限差分格式来近似 $u(x)$，即将 $u''(x_i)$ 替换为以下表达式来构建三对角线性系统\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i), \\quad i=1,2,\\dots,N-1,\n$$\n并满足边界条件 $u_0=0$ 和 $u_N=0$。求解得到的线性系统，以获得数值近似解 $\\{u_i\\}_{i=0}^N$。\n\n通过求解 BVP 并在 $x=x_c$ 处施加适当的连续性条件，解析地定义精确解 $u(x)$。使用此精确解，根据数值近似计算以下误差度量：\n- 内部节点上误差的无穷范数，\n$$\nE_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|.\n$$\n- 紧邻不连续点左右两侧网格点处的误差。令 $i_L$ 和 $i_R$ 定义如下：\n  1. 如果 $x_c$ 不与网格节点重合，则设 $i_L = \\lfloor x_c/h \\rfloor$ 和 $i_R = i_L + 1$，然后将其限制在内部索引范围内，以使 $1 \\le i_L \\le N-2$ 和 $2 \\le i_R \\le N-1$。\n  2. 如果 $x_c$ 与某个网格节点 $x_k$ 重合（即，对于某个整数 $k$，$x_k = x_c$），则设 $i_L = \\max(1,k-1)$ 和 $i_R = \\min(N-1,k+1)$。\n然后计算\n$$\nE_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\qquad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|.\n$$\n\n您的程序必须：\n- 对下面指定的每个测试用例，组装并求解有限差分线性系统。\n- 构造精确解 $u(x)$，并为每个测试用例计算 $E_{\\infty}$、$E_L$ 和 $E_R$。\n- 生成单行输出，其中包含一个逗号分隔的结果列表，每个测试用例对应一个结果，每个结果为列表 $[E_{\\infty},E_L,E_R]$。\n\n测试套件（每个项目为一对 $(x_c,N)$）：\n1. $(x_c,N) = (0.37,40)$，一个一般情况，其中不连续点严格位于网格节点之间。\n2. $(x_c,N) = (0.50,50)$，一个不连续点与网格节点完全重合的情况。\n3. $(x_c,N) = (0.05,41)$，一个不连续点靠近左边界且不与网格节点重合的情况。\n4. $(x_c,N) = (1.00,60)$，一个不连续点位于右边界的情况。\n5. $(x_c,N) = (0.37,80)$，对第一个案例进行网格加密，以观察网格加密下的误差行为。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个子列表 $[E_{\\infty},E_L,E_R]$。例如，输出应如下所示\n$$\n[[e_{\\infty}^{(1)},e_L^{(1)},e_R^{(1)}],[e_{\\infty}^{(2)},e_L^{(2)},e_R^{(2)}],\\dots].\n$$", "solution": "该问题要求使用有限差分法求解一个带不连续强制函数的一维线性边值问题 (BVP)，并将数值解与精确解析解进行比较。\n\n### 1. 解析解\nBVP 由下式给出：\n$$\nu''(x) = f(x), \\quad x \\in (0,1)\n$$\n边界条件为狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$。强制函数 $f(x)$ 是一个阶跃函数：\n$$\nf(x) = \\begin{cases}\n1, & 0 \\le x < x_c, \\\\\n0, & x_c \\le x \\le 1.\n\\end{cases}\n$$\n我们通过在由不连续点 $x=x_c$ 定义的两个子区间上对 $u''(x)$ 进行分段积分来求解此问题。\n\n对于 $0 \\le x < x_c$，我们有 $u''(x) = 1$。对 $x$ 积分两次得到：\n$$\nu'(x) = x + A\n$$\n$$\nu(x) = \\frac{1}{2}x^2 + Ax + B\n$$\n对于 $x_c \\le x \\le 1$，我们有 $u''(x) = 0$。积分两次得到：\n$$\nu'(x) = C\n$$\n$$\nu(x) = Cx + D\n$$\n其中 $A$、$B$、$C$ 和 $D$ 是积分常数。这些常数由边界条件以及在 $x=x_c$ 处强制解 $u(x)$ 及其一阶导数 $u'(x)$ 连续来确定。与此方程对应的物理系统（例如，在分段常数载荷下的弦）要求弦本身不会断裂（$u$ 连续）且不会出现扭折（$u'$ 连续）。\n\n1.  **$x=0$ 处的边界条件**：$u(0)=0$。假设 $x_c>0$，我们使用解的第一种形式：\n    $u(0) = \\frac{1}{2}(0)^2 + A(0) + B = 0 \\implies B=0$。\n\n2.  **$x=1$ 处的边界条件**：$u(1)=0$。我们使用第二种形式：\n    $u(1) = C(1) + D = 0 \\implies D=-C$。\n\n3.  **$u(x)$ 在 $x=x_c$ 处的连续性**：两部分的值必须匹配，即 $u(x_c^-) = u(x_c^+)$。\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = Cx_c + D\n    $$\n    代入 $B=0$ 和 $D=-C$，我们得到：\n    $$\n    \\frac{1}{2}x_c^2 + Ax_c = C(x_c - 1) \\quad (\\text{方程 1})\n    $$\n\n4.  **$u'(x)$ 在 $x=x_c$ 处的连续性**：导数也必须匹配，即 $u'(x_c^-) = u'(x_c^+)$。\n    $$\n    x_c + A = C \\quad (\\text{方程 2})\n    $$\n\n我们现在求解由两个线性方程（方程 1 和方程 2）组成的方程组，以求解 $A$ 和 $C$。从方程 2，我们有 $A = C-x_c$。将其代入方程 1：\n$$\n\\frac{1}{2}x_c^2 + (C-x_c)x_c = C(x_c - 1)\n$$\n$$\n\\frac{1}{2}x_c^2 + Cx_c - x_c^2 = Cx_c - C\n$$\n$$\n-\\frac{1}{2}x_c^2 = -C \\implies C = \\frac{1}{2}x_c^2\n$$\n现在，我们求出其他常数：\n$A = C - x_c = \\frac{1}{2}x_c^2 - x_c$\n$D = -C = -\\frac{1}{2}x_c^2$\n\n将这些常数代回到 $u(x)$ 的分段表达式中，得到精确解析解为：\n$$\nu(x) = \\begin{cases}\n\\frac{1}{2}x^2 + \\left(\\frac{1}{2}x_c^2 - x_c\\right)x, & 0 \\le x < x_c \\\\\n\\frac{1}{2}x_c^2 (x-1), & x_c \\le x \\le 1\n\\end{cases}\n$$\n\n### 2. 有限差分法\n我们使用具有 $N$ 个宽度为 $h=1/N$ 的子区间的均匀网格来离散化域 $[0,1]$。网格节点为 $x_i = ih$，$i=0,1,\\dots,N$。令 $u_i$ 为 $u(x_i)$ 的数值近似值。\n\n二阶导数 $u''(x_i)$ 由二阶中心差分公式近似：\n$$\nu''(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n将此式代入每个内部节点 $x_i$（$i=1, 2, \\dots, N-1$）处的 BVP，我们得到一个线性方程组：\n$$\n\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f(x_i)\n$$\n边界条件给出 $u_0=0$ 和 $u_N=0$。整理方程，我们得到：\n$$\nu_{i-1} - 2u_i + u_{i+1} = h^2 f(x_i), \\quad i=1, 2, \\dots, N-1\n$$\n这构成了一个关于未知向量 $\\mathbf{u} = [u_1, u_2, \\dots, u_{N-1}]^T$ 的线性系统 $A \\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵：\n$$\nA = \\begin{pmatrix}\n-2 & 1 & & \\\\\n1 & -2 & 1 & \\\\\n & \\ddots & \\ddots & \\ddots & \\\\\n & & 1 & -2 & 1 \\\\\n & & & 1 & -2\n\\end{pmatrix}\n$$\n右侧向量 $\\mathbf{b}$ 的分量为 $b_{i-1} = h^2 f(x_i)$，$i=1, \\dots, N-1$。如果 $x_i < x_c$，则 $f(x_i)$ 的值为 $1$；如果 $x_i \\ge x_c$，则为 $0$。该系统是非奇异的，可以使用标准线性求解器等方法高效求解。\n\n### 3. 误差计算\n一旦求得数值解 $\\{u_i\\}_{i=0}^N$，我们通过将其与精确解 $\\{u(x_i)\\}_{i=0}^N$ 进行比较来计算误差。\n所需的误差度量为：\n- 内部节点上的最大绝对误差：\n  $$\n  E_{\\infty} = \\max_{1\\le i \\le N-1} \\left|u_i - u(x_i)\\right|\n  $$\n- 框住不连续点的网格点处的局部误差。索引 $i_L$（左）和 $i_R$（右）按指定方式确定：\n  - 如果 $x_c$ 不与网格节点 $x_k$ 重合，则 $i_L = \\lfloor x_c/h \\rfloor$，$i_R = i_L + 1$。问题陈述意味着这些索引应在不连续点附近的内部点的有效范围内。\n  - 如果 $x_c$ 与网格节点 $x_k$ 重合，则 $i_L = \\max(1,k-1)$，$i_R = \\min(N-1,k+1)$。\n  然后误差计算如下：\n  $$\n  E_L = \\left|u_{i_L} - u(x_{i_L})\\right|, \\quad E_R = \\left|u_{i_R} - u(x_{i_R})\\right|\n  $$\n下面的 Python 程序为给定的测试套件实现了这整个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_case(xc, N):\n    \"\"\"\n    Solves the BVP for a given xc and N, and computes error metrics.\n    \"\"\"\n    # 1. Discretization\n    h = 1.0 / N\n    x_nodes = np.linspace(0, 1, N + 1)\n    dim = N - 1\n\n    if dim == 0:\n        return [0.0, 0.0, 0.0]\n\n    # 2. Assemble the finite difference matrix A\n    main_diag = np.full(dim, -2.0)\n    off_diag = np.full(dim - 1, 1.0)\n    A = np.diag(main_diag) + np.diag(off_diag, k=1) + np.diag(off_diag, k=-1)\n    \n    # 3. Assemble the right-hand side vector b\n    f_int = np.zeros(dim)\n    for i in range(dim):\n        # x_nodes[i + 1] corresponds to the interior node x_{i+1}\n        if x_nodes[i + 1]  xc:\n            f_int[i] = 1.0\n    \n    b = (h**2) * f_int\n    \n    # 4. Solve the linear system for interior nodes\n    u_int = np.linalg.solve(A, b)\n    \n    # 5. Construct full numerical solution vector (including boundaries)\n    u_num = np.concatenate(([0.0], u_int, [0.0]))\n\n    # 6. Compute the exact solution at grid points\n    def exact_u_func(x, xc_val):\n        \"\"\"Computes the exact analytical solution u(x) for a given xc.\"\"\"\n        A_const = 0.5 * xc_val**2 - xc_val\n        C_const = 0.5 * xc_val**2\n        \n        if x  xc_val:\n            return 0.5 * x**2 + A_const * x\n        else:\n            return C_const * (x - 1)\n\n    u_exact_vals = np.array([exact_u_func(xi, xc) for xi in x_nodes])\n\n    # 7. Compute error vector and E_infinity\n    errors = np.abs(u_num - u_exact_vals)\n    E_inf = np.max(errors[1:N])\n    \n    # 8. Determine indices i_L and i_R for local errors\n    is_on_grid = np.isclose(xc / h, np.round(xc / h))\n    \n    if is_on_grid:\n        k = int(np.round(xc / h))\n        i_L = max(1, k - 1)\n        i_R = min(N - 1, k + 1)\n    else:\n        i_L_raw = int(np.floor(xc / h))\n        i_R_raw = i_L_raw + 1\n        \n        # The problem statement's clamping instruction is:\n        # \"...clamp to interior indices so that 1=iL=N-2 and 2=iR=N-1.\"\n        # The following implementation satisfies this constraint and keeps i_R = i_L + 1.\n        if i_L_raw  1:\n            i_L = 1\n            i_R = 2\n        elif i_L_raw >= N - 1:\n            i_L = N - 2\n            i_R = N - 1\n        else:\n            i_L = i_L_raw\n            i_R = i_R_raw\n\n    E_L = errors[i_L]\n    E_R = errors[i_R]\n    \n    return [E_inf, E_L, E_R]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.37, 40),\n        (0.50, 50),\n        (0.05, 41),\n        (1.00, 60),\n        (0.37, 80),\n    ]\n\n    results = []\n    for xc, N in test_cases:\n        result = solve_case(xc, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{res[0]},{res[1]},{res[2]}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3228101"}, {"introduction": "最后的这个实践将深入探讨一个更深层次的主题：当底层物理系统发生共振时，数值方法的稳定性问题。您将研究一个本身接近“不适定”的边界值问题，其离散系统虽然在技术上可解，但随着网格的加密会变得严重病态。这个练习连接了微分算子理论性质与数值计算的实际挑战，揭示了数值方法如何能反映出连续问题本身的精细特性。[@problem_id:3228013]", "problem": "考虑单位区间上的线性边值问题，其边界条件为齐次狄利克雷边界条件，\n$$\n-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\\;=\\;f(x),\\quad x\\in(0,1),\\qquad u(0)=0,\\;u(1)=0.\n$$\n从有限差分法（FDM）的第一性原理出发，在具有 $N$ 个内部点和间距 $h=1/(N+1)$ 的均匀网格上，使用二阶中心差分近似二阶导数，以推导出一个离散线性系统，其形式为\n$$\n\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b},\n$$\n其中 $\\mathbf{u}\\in\\mathbb{R}^N$ 表示内部节点 $x_i=i\\,h$ 处的离散未知数 $u_i\\approx u(x_i)$，而 $\\mathbf{b}\\in\\mathbb{R}^N$ 包含样本 $f(x_i)$。清晰并明确地指出由中心差分近似和狄利克雷边界条件产生的矩阵 $\\mathbf{A}$ 的元素。\n\n从关于 Sturm–Liouville 问题和 $(0,1)$ 上狄利克雷拉普拉斯算子的公认事实出发，解释为什么在给定边界条件下，连续算子\n$$\n\\mathcal{L}u\\;=\\;-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\n$$\n具有非平凡的零空间。利用特征函数的正交性，陈述连续问题有解所需满足的关于 $f(x)$ 的相容性条件。然后，通过将离散 FDM 矩阵 $\\mathbf{A}$ 表示为一个移位的离散狄利克雷拉普拉斯算子来分析它。利用具有狄利克雷边界条件的对称三对角托普利茨（Toeplitz）矩阵的基本性质，推导 $\\mathbf{A}$ 的特征值的封闭形式表达式，作为 $N$ 的函数。利用此表达式确定最小奇异值和谱范数下的条件数，并论证当 $N$ 增大时会发生什么。您的分析应明确指出对于有限的 $N$，$\\mathbf{A}$ 是否是精确奇异的，以及为什么它可能仍然是病态的。\n\n实现任务。编写一个完整、可运行的程序，该程序：\n- 为每个测试用例构建 FDM 矩阵 $\\mathbf{A}$ 和右侧向量 $\\mathbf{b}$。\n- 求解 $\\mathbf{A}\\mathbf{u}=\\mathbf{b}$ 以获得离散解 $\\mathbf{u}$。\n- 为每个测试用例计算以下诊断指标：\n  1. 使用从分析中推导出的 $\\mathbf{A}$ 的精确特征值，估算谱条件数 $\\kappa_2(\\mathbf{A})$。\n  2. $\\mathbf{A}$ 的最小绝对特征值。\n  3. 相对残差 $\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2 / \\|\\mathbf{b}\\|_2$，当 $\\mathbf{b}=\\mathbf{0}$ 时定义为 $0$。\n  4. 离散解的范数 $\\|\\mathbf{u}\\|_2$。\n所有三角函数都必须以弧度为单位计算角度。\n\n测试套件。您的程序必须评估以下五个测试用例，每个用例由一对 $(N,f)$ 指定，其中 $N$ 是内部点数， $f(x)$ 是右侧函数：\n- 用例 1: $N=50$, $f(x)=\\sin(\\pi x)$。\n- 用例 2: $N=50$, $f(x)=\\sin(2\\pi x)$。\n- 用例 3: $N=200$, $f(x)=\\sin(\\pi x)$。\n- 用例 4: $N=200$, $f(x)=\\sin(\\pi x)+10^{-3}\\sin(2\\pi x)$。\n- 用例 5: $N=100$, $f(x)\\equiv 0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，其本身是一个包含 $[\\kappa_2(\\mathbf{A}),\\,\\min_k|\\lambda_k(\\mathbf{A})|,\\,\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2/\\|\\mathbf{b}\\|_2,\\,\\|\\mathbf{u}\\|_2]$ 的四元素列表，顺序如此。例如，\n$$\n[\\,[\\text{case1\\_cond},\\text{case1\\_minabs},\\text{case1\\_relres},\\text{case1\\_unorm}],\\ldots,[\\text{case5\\_cond},\\text{case5\\_minabs},\\text{case5\\_relres},\\text{case5\\_unorm}]\\,].\n$$", "solution": "用户提供了一个关于使用有限差分法（FDM）数值求解线性边值问题（BVP）的问题。我将首先根据指定标准验证问题陈述。\n\n### 步骤 1：提取给定信息\n\n- **控制方程**：$-\\,u''(x)\\;-\\;\\pi^2\\,u(x)\\;=\\;f(x)$，对于 $x \\in (0,1)$。\n- **边界条件**：齐次狄利克雷，$u(0)=0$ 和 $u(1)=0$。\n- **离散化方法**：二阶导数的二阶中心差分近似。\n- **网格**：具有 $N$ 个内部点的均匀网格，$x_i = i\\,h$ 对于 $i=1, \\dots, N$。\n- **网格间距**：$h=1/(N+1)$。\n- **离散系统**：$\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b}$，其中 $\\mathbf{u} \\in \\mathbb{R}^N$ 的元素为 $u_i \\approx u(x_i)$，$\\mathbf{b} \\in \\mathbb{R}^N$ 的元素为 $b_i = f(x_i)$。\n- **连续算子**：$\\mathcal{L}u\\;=\\;-\\,u''(x)\\;-\\;\\pi^2\\,u(x)$。\n- **分析任务**：\n    1.  推导矩阵 $\\mathbf{A}$。\n    2.  分析连续算子 $\\mathcal{L}$ 的零空间。\n    3.  陈述连续问题所需的关于 $f(x)$ 的相容性条件。\n    4.  分析离散矩阵 $\\mathbf{A}$、其特征值、奇异性以及作为 $N$ 的函数的条件数。\n- **实现任务**：\n    1.  构建 $\\mathbf{A}$ 和 $\\mathbf{b}$。\n    2.  求解 $\\mathbf{A}\\,\\mathbf{u}\\;=\\;\\mathbf{b}$。\n    3.  计算诊断指标：$\\kappa_2(\\mathbf{A})$、$\\min_k|\\lambda_k(\\mathbf{A})|$、相对残差 $\\|\\mathbf{A}\\mathbf{u}-\\mathbf{b}\\|_2 / \\|\\mathbf{b}\\|_2$ 和解的范数 $\\|\\mathbf{u}\\|_2$。\n- **测试用例**：\n    - 用例 1: $N=50$, $f(x)=\\sin(\\pi x)$。\n    - 用例 2: $N=50$, $f(x)=\\sin(2\\pi x)$。\n    - 用例 3: $N=200$, $f(x)=\\sin(\\pi x)$。\n    - 用例 4: $N=200$, $f(x)=\\sin(\\pi x)+10^{-3}\\sin(2\\pi x)$。\n    - 用例 5: $N=100$, $f(x)\\equiv 0$。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n根据验证标准评估该问题：\n\n- **科学依据**：该问题植根于 Sturm-Liouville 问题的经典理论和数值分析，特别是求解微分方程的有限差分法。连续问题是一个共振情况，其中算子具有非平凡的零空间，这是 BVP 研究中的一个标准课题。对相应离散系统的病态性分析是科学计算中的一个基本概念。该问题是该领域一个表述良好且标准的练习。\n- **适定性**：问题陈述是完整的，提供了微分方程、边界条件、离散化方案和所有必要的参数。任务定义清晰，可以得出一套唯一的分析推导和数值结果。连续问题被有意地选择在适定性的边界上（只有在满足相容性条件时才可解），问题的核心是分析该性质如何反映在离散化系统中。这是一个有意的、有意义的结构，而不是一个缺陷。\n- **客观性**：问题使用精确的数学语言和符号陈述，没有任何主观或模棱两可的术语。\n\n该问题没有任何无效性缺陷。它在科学上是合理的，可形式化的，完整的，可行的，并且结构合理，旨在研究一个重要的数值现象。\n\n### 步骤 3：结论与行动\n\n问题陈述是 **有效的**。我将继续提供完整的解决方案。\n\n### 推导与分析\n\n我们首先对给定的边值问题进行离散化。\n微分方程在内部网格点 $x_i = i h$（其中 $i=1, \\dots, N$，$h = 1/(N+1)$）处进行计算：\n$$\n-u''(x_i) - \\pi^2 u(x_i) = f(x_i)\n$$\n二阶导数 $u''(x_i)$ 使用二阶中心差分公式进行近似：\n$$\nu''(x_i) \\approx \\frac{u(x_i - h) - 2u(x_i) + u(x_i + h)}{h^2} = \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2}\n$$\n将连续函数 $u(x_i)$ 替换为其离散近似 $u_i$，我们得到线性方程组：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} - \\pi^2 u_i = f_i\n$$\n其中 $f_i = f(x_i)$。整理各项可得：\n$$\n\\frac{1}{h^2} (-u_{i-1} + 2u_i - u_{i+1}) - \\pi^2 u_i = f_i\n$$\n该方程对 $i=1, \\dots, N$ 成立。边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着 $u_0=0$ 和 $u_{N+1}=0$。\n对于 $i=1$：$\\frac{1}{h^2} (2u_1 - u_2) - \\pi^2 u_1 = f_1$。\n对于 $i=N$：$\\frac{1}{h^2} (-u_{N-1} + 2u_N) - \\pi^2 u_N = f_N$。\n\n这 $N$ 个线性方程可以写成矩阵形式 $\\mathbf{A}\\mathbf{u} = \\mathbf{b}$。矩阵 $\\mathbf{A}$ 是一个 $N \\times N$ 矩阵，$\\mathbf{u} = [u_1, u_2, \\dots, u_N]^T$，$\\mathbf{b} = [f_1, f_2, \\dots, f_N]^T$。\n矩阵 $\\mathbf{A}$ 可以表示为两个矩阵之和：一个来自离散化的二阶导数，另一个来自 $-\\pi^2 u(x)$ 项。\n设 $\\mathbf{L}_N$ 是表示负二阶导数算子 $-d^2/dx^2$ 的有限差分近似的矩阵。其元素由项 $\\frac{1}{h^2}(-u_{i-1} + 2u_i - u_{i+1})$ 推导而来。\n$$\n\\mathbf{L}_N = \\frac{1}{h^2}\n\\begin{pmatrix}\n2  -1  0  \\cdots  0 \\\\\n-1  2  -1  \\cdots  0 \\\\\n0  -1  2  \\ddots  \\vdots \\\\\n\\vdots  \\vdots  \\ddots  \\ddots  -1 \\\\\n0  0  \\cdots  -1  2\n\\end{pmatrix}\n$$\n$-\\pi^2 u_i$ 项对系统矩阵的贡献为 $-\\pi^2 \\mathbf{I}$，其中 $\\mathbf{I}$ 是 $N \\times N$ 单位矩阵。\n因此，系统矩阵 $\\mathbf{A}$ 为：\n$$\n\\mathbf{A} = \\mathbf{L}_N - \\pi^2 \\mathbf{I}\n$$\n$\\mathbf{A}$ 的元素明确由下式给出：\n$$\nA_{ij} = \\begin{cases} \\frac{2}{h^2} - \\pi^2  \\text{if } i=j \\\\ -\\frac{1}{h^2}  \\text{if } |i-j|=1 \\\\ 0  \\text{otherwise} \\end{cases}\n$$\n\n接下来，我们分析具有齐次狄利克雷边界条件的连续算子 $\\mathcal{L}u = -u'' - \\pi^2 u$。这是一个 Sturm-Liouville 算子。其零空间由 $\\mathcal{L}u=0$ 的非平凡解组成，即齐次方程 $-u'' - \\pi^2 u = 0$，或 $u'' + \\pi^2 u = 0$。通解为 $u(x) = C_1 \\cos(\\pi x) + C_2 \\sin(\\pi x)$。\n应用边界条件：\n1. $u(0) = C_1 \\cos(0) + C_2 \\sin(0) = C_1 = 0$。解必须具有 $u(x) = C_2 \\sin(\\pi x)$ 的形式。\n2. $u(1) = C_2 \\sin(\\pi) = C_2 \\cdot 0 = 0$。对于任何 $C_2$ 的值，此条件都满足。\n因此，对于任意常数 $C \\in \\mathbb{R}$，任何函数 $u(x) = C \\sin(\\pi x)$ 都是一个解。零空间是非平凡的，由特征函数 $\\phi_1(x) = \\sin(\\pi x)$ 张成。这是因为 $\\pi^2$ 是在 $(0,1)$ 上具有这些边界条件的负拉普拉斯算子 $-d^2/dx^2$ 的第一个特征值。\n为了使非齐次问题 $\\mathcal{L}u = f$ 有解，Fredholm 择一定理要求右端项 $f(x)$ 与伴随算子 $\\mathcal{L}^*$ 的零空间正交。由于 $\\mathcal{L}$ 是自伴的，相容性条件是 $f(x)$ 必须与 $\\mathcal{L}$ 的零空间正交。这意味着：\n$$\n\\langle f, \\phi_1 \\rangle = \\int_0^1 f(x) \\sin(\\pi x) \\, dx = 0\n$$\n\n我们现在分析离散矩阵 $\\mathbf{A} = \\mathbf{L}_N - \\pi^2 \\mathbf{I}$。矩阵 $\\mathbf{L}_N$ 是一个对称三对角托普利茨（Toeplitz）矩阵。其特征值和特征向量是众所周知的。$\\mathbf{L}_N$ 的特征值是连续算子 $-d^2/dx^2$ 的特征值 $k^2 \\pi^2$ 的近似值，由下式给出：\n$$\n\\mu_k = \\frac{2}{h^2} (1 - \\cos(k \\pi h)) = \\frac{4}{h^2} \\sin^2\\left(\\frac{k \\pi h}{2}\\right) \\quad \\text{for } k = 1, \\dots, N\n$$\n$\\mathbf{A}$ 的特征值是通过平移 $\\mathbf{L}_N$ 的特征值得到的：\n$$\n\\lambda_k(\\mathbf{A}) = \\mu_k - \\pi^2 = \\frac{4}{h^2} \\sin^2\\left(\\frac{k \\pi h}{2}\\right) - \\pi^2 = 4(N+1)^2 \\sin^2\\left(\\frac{k \\pi}{2(N+1)}\\right) - \\pi^2\n$$\n矩阵 $\\mathbf{A}$ 是奇异的当且仅当对于某个 $k$，$\\lambda_k(\\mathbf{A}) = 0$。这需要 $2(N+1) \\sin\\left(\\frac{k \\pi}{2(N+1)}\\right) = \\pi$。对于 $x \\in (0, \\pi/2)$，我们有不等式 $\\sin(x)  x$。令 $x = \\frac{k\\pi}{2(N+1)}$，我们得到 $2(N+1)\\sin\\left(\\frac{k\\pi}{2(N+1)}\\right)  2(N+1)\\frac{k\\pi}{2(N+1)} = k\\pi$。要使其等于 $\\pi$，我们需要 $k=1$ 并且不等式为等式，但对于 $x0$ 这是不可能的。因此，对于任何 $k$ 和有限的 $N$，$\\lambda_k(\\mathbf{A}) \\ne 0$。矩阵 $\\mathbf{A}$ 从不是精确奇异的。\n\n然而，当 $k=1$ 时，特征值 $\\lambda_1$ 非常接近于零。对于小的 $x = \\pi h/2$，使用 Taylor 展开 $\\sin(x) = x - x^3/6 + O(x^5)$：\n$$\n\\lambda_1(\\mathbf{A}) = \\frac{4}{h^2} \\left( \\frac{\\pi h}{2} - \\frac{1}{6}\\left(\\frac{\\pi h}{2}\\right)^3 + O(h^5) \\right)^2 - \\pi^2 = \\pi^2 \\left(1 - \\frac{\\pi^2 h^2}{12} + O(h^4) \\right) - \\pi^2 = -\\frac{\\pi^4 h^2}{12} + O(h^4)\n$$\n当 $h \\to 0$（即 $N \\to \\infty$）时，该特征值 $\\lambda_1$ 趋近于 $0$。这种近奇异性使得矩阵 $\\mathbf{A}$ 病态。由于 $\\mathbf{A}$ 是对称的，其奇异值是其特征值的绝对值，即 $\\sigma_k = |\\lambda_k|$。最小奇异值为 $\\sigma_{\\min} = |\\lambda_1| = |\\mu_1 - \\pi^2| \\approx \\frac{\\pi^4 h^2}{12}$。\n\n谱条件数为 $\\kappa_2(\\mathbf{A}) = \\sigma_{\\max}/\\sigma_{\\min} = \\max_k|\\lambda_k|/\\min_k|\\lambda_k|$。特征值 $\\lambda_k$ 构成一个递增序列。$\\lambda_1$ 是一个小的负数，而 $\\lambda_2, \\dots, \\lambda_N$ 是正数。模最大的特征值是 $\\lambda_N$：\n$$\n\\lambda_N = \\frac{4}{h^2}\\sin^2\\left(\\frac{N \\pi h}{2}\\right) - \\pi^2 = \\frac{4}{h^2}\\sin^2\\left(\\frac{N \\pi}{2(N+1)}\\right) - \\pi^2\n$$\n当 $N \\to \\infty$ 时，$h \\to 0$ 且 $\\frac{N}{N+1} \\to 1$，因此 $\\lambda_N \\to \\frac{4}{h^2} - \\pi^2 \\approx 4(N+1)^2$。\n因此，条件数的行为如下：\n$$\n\\kappa_2(\\mathbf{A}) = \\frac{|\\lambda_N|}{|\\lambda_1|} \\approx \\frac{4/h^2}{\\pi^4 h^2/12} = \\frac{48}{\\pi^4 h^4} = O((N+1)^4)\n$$\n条件数以 $N^4$ 的速度增长，表明对于大的 $N$ 存在严重的病态问题。这反映了离散问题正在逼近一个并非无条件可解的连续问题这一事实。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the FDM discretization of a linear BVP for several test cases\n    and computes specified diagnostics for each case.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (N, f(x)), where N is the number of interior points\n    # and f(x) is the right-hand side function.\n    test_cases = [\n        (50, lambda x: np.sin(np.pi * x)),\n        (50, lambda x: np.sin(2 * np.pi * x)),\n        (200, lambda x: np.sin(np.pi * x)),\n        (200, lambda x: np.sin(np.pi * x) + 1e-3 * np.sin(2 * np.pi * x)),\n        (100, lambda x: np.zeros_like(x))\n    ]\n\n    results = []\n    for N, f_func in test_cases:\n        # 1. Setup grid and parameters\n        h = 1.0 / (N + 1)\n        # Grid points x_i = i*h for i=1,...,N\n        x = np.arange(1, N + 1) * h\n\n        # 2. Construct the FDM matrix A\n        # A = (1/h^2) * tridiag(-1, 2, -1) - pi^2 * I\n        diag_val = 2.0 / h**2 - np.pi**2\n        off_diag_val = -1.0 / h**2\n        \n        A = diag_val * np.eye(N) + off_diag_val * np.diag(np.ones(N - 1), k=1) + off_diag_val * np.diag(np.ones(N - 1), k=-1)\n\n        # 3. Construct the right-hand side vector b\n        b = f_func(x)\n\n        # 4. Solve the linear system Au = b\n        # For the homogeneous case (b=0), the solution is the zero vector.\n        if np.all(b == 0):\n            u = np.zeros(N)\n        else:\n            u = np.linalg.solve(A, b)\n\n        # 5. Compute diagnostics\n\n        # a) Spectral condition number kappa_2(A) using exact eigenvalues\n        # lambda_k = 4*(N+1)^2 * sin^2(k*pi/(2*(N+1))) - pi^2\n        # Smallest magnitude eigenvalue is |lambda_1|\n        lambda_1 = 4 * (N + 1)**2 * np.sin(np.pi / (2 * (N + 1)))**2 - np.pi**2\n        min_abs_eig = np.abs(lambda_1)\n        \n        # Largest magnitude eigenvalue is lambda_N\n        lambda_N = 4 * (N + 1)**2 * np.sin(N * np.pi / (2 * (N + 1)))**2 - np.pi**2\n        \n        # kappa_2(A) = |lambda_N| / |lambda_1|\n        cond_A = lambda_N / min_abs_eig\n\n        # b) Minimum absolute eigenvalue (already computed)\n        \n        # c) Relative residual ||Au - b||_2 / ||b||_2\n        norm_b = np.linalg.norm(b)\n        if norm_b == 0:\n            rel_res = 0.0\n        else:\n            residual = A @ u - b\n            rel_res = np.linalg.norm(residual) / norm_b\n\n        # d) Discrete solution norm ||u||_2\n        u_norm = np.linalg.norm(u)\n\n        # Store results for this case\n        results.append([cond_A, min_abs_eig, rel_res, u_norm])\n\n    # Final print statement in the exact required format.\n    # The str() representation of a list includes spaces, which is acceptable.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3228013"}]}