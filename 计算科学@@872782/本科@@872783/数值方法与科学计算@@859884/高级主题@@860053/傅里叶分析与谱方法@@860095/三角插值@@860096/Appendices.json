{"hands_on_practices": [{"introduction": "我们的第一个实践将三角插值置于现代信号处理的背景下。你将学习如何利用周期信号的少量样本，通过构建三角插值来生成一个平滑的高分辨率版本。这个练习 [@problem_id:3284404] 揭示了一个核心原理：插值函数是与样本数据一致的最自然的带限信号，并展示了如何使用快速傅里叶变换（FFT）进行高效计算。", "problem": "您的任务是设计并实现一个基于其基本原理的周期信号“超分辨率”算法，该算法通过三角插值实现，并从数值方法和科学计算的第一性原理推导得出。考虑在定义域 $[0,2\\pi]$ 上周期为 $2\\pi$ 的实值连续函数（角度单位为弧度）。您的算法必须通过构建一个与给定样本一致并在整个定义域上自然延伸的三角插值多项式，从低分辨率、等间距的样本中生成底层周期信号的高分辨率近似。推导和算法必须从傅里叶级数定义和周期函数离散采样的基本基础出发。您必须确保数值稳健性，不得使用超出这些基础定义之外的快捷公式。\n\n定义和要求：\n- 设 $f:[0,2\\pi]\\to\\mathbb{R}$ 是一个周期为 $2\\pi$ 的函数。傅里叶级数形式体系指出，$f(x)$ 可以用复指数 $e^{\\mathrm{i}kx}$（其中 $k\\in\\mathbb{Z}$）和傅里叶系数 $\\hat{f}_k$ 来表示，这些系数表征了每个模式的贡献。\n- 给定在节点 $x_j = 2\\pi j/N$（$j\\in\\{0,1,\\dots,N-1\\}$）上的 $N$ 个等间距样本 $f(x_j)$，三角插值多项式是一个有限三角多项式，其在这些节点上的值与采样数据匹配。利用傅里叶级数的定义和均匀网格上离散采样的结构，该插值多项式的系数可以通过样本值的离散傅里叶变换获得，其缩放与样本值和系数之间的逆关系保持一致。当在 $[0,2\\pi]$ 中的任意点 $x$ 上求值时，该三角插值多项式提供了一种“超分辨率”重建，因为它产生了一个与粗略样本一致的、合理的高分辨率周期信号。\n- 您的数值程序必须利用傅里叶分析所蕴含的基本关系，从粗略样本中计算离散频率系数，然后在由 $M$ 个点 $y_m = 2\\pi m/M$（$m\\in\\{0,1,\\dots,M-1\\}$）组成的更精细的网格上，对相应的三角插值多项式进行求值。\n\n角度单位说明：\n- 所有角度均应解释为弧度。\n\n测试套件：\n实现您的算法，并在以下四个测试用例上进行评估。对于每个用例，使用指定的 $f(x)$、低分辨率样本数 $N$ 和期望的高分辨率求值点数 $M$。\n\n1. 理想情况（带限）：\n   - $f(x) = \\sin(3x) + 0.5\\cos(5x)$\n   - $N = 32$\n   - $M = 1024$\n\n2. 边界情况，包含最小采样和奈奎斯特分量：\n   - $f(x) = \\cos(x)$\n   - $N = 2$\n   - $M = 128$\n\n3. 存在混叠（频率超出粗网格的奈奎斯特极限）：\n   - $f(x) = \\sin(20x) + 0.3\\cos(2x)$\n   - $N = 16$\n   - $M = 1024$\n\n4. 非光滑周期信号（在 $[0,2\\pi)$ 上的分段线性锯齿波）：\n   - $f(x) = \\left(\\frac{(x \\bmod 2\\pi)}{\\pi}\\right) - 1$\n   - $N = 64$\n   - $M = 2048$\n\n对于每个测试用例，计算以下两个定量指标：\n- 粗网格上的一致性误差：在粗节点上求值的三角插值多项式与给定的粗略样本之间的最大绝对差（$\\max_j |p(x_j) - f(x_j)|$）。该值必须为浮点数。\n- 高分辨率误差：在精细网格上求值的三角插值多项式与同一精细网格上的真实函数值之间的最大绝对差（$\\max_m |p(y_m) - f(y_m)|$）。该值必须为浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表应包含八个浮点数，按四个测试用例的以下顺序排列：$[\\text{consistency}_1,\\text{hires}_1,\\text{consistency}_2,\\text{hires}_2,\\text{consistency}_3,\\text{hires}_3,\\text{consistency}_4,\\text{hires}_4]$。\n- 输出行中不允许出现任何额外的文本或字符。\n\n所有计算都必须以弧度为单位，并使用指定的周期 $2\\pi$。基于傅里叶级数和离散采样的基础定义，确保三角插值的数值稳定性和正确性。程序必须是完整的，并且无需外部输入或资源即可运行。", "solution": "该问题要求设计并实现一种用于信号超分辨率的三角插值算法，该算法需从第一性原理推导得出。算法将从一组低分辨率、等间距的样本中重建一个高分辨率的周期信号。\n\n### 1. 问题验证\n\n**步骤1：提取已知条件**\n- **函数：** 一个在定义域 $[0, 2\\pi]$ 上周期为 $2\\pi$ 的实值连续函数 $f(x)$。\n- **低分辨率采样：** 在节点 $x_j = 2\\pi j/N$（$j \\in \\{0, 1, \\dots, N-1\\}$）处的 $N$ 个等间距样本 $f(x_j)$。\n- **高分辨率求值：** 插值多项式将在一个由 $M$ 个点 $y_m = 2\\pi m/M$（$m \\in \\{0, 1, \\dots, M-1\\}$）组成的更精细的网格上进行求值。\n- **核心原理：** 插值多项式的系数由样本值的离散傅里叶变换（DFT）推导得出。\n- **测试用例：**\n    1. $f(x) = \\sin(3x) + 0.5\\cos(5x)$, $N = 32$, $M = 1024$。\n    2. $f(x) = \\cos(x)$, $N = 2$, $M = 128$。\n    3. $f(x) = \\sin(20x) + 0.3\\cos(2x)$, $N = 16$, $M = 1024$。\n    4. $f(x) = (\\frac{(x \\bmod 2\\pi)}{\\pi}) - 1$, $N = 64$, $M = 2048$。\n- **指标：**\n    - 一致性误差：$\\max_j |p(x_j) - f(x_j)|$\n    - 高分辨率误差：$\\max_m |p(y_m) - f(y_m)|$\n- **角度单位：** 所有角度均为弧度。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据、适定且客观。这是一个数值分析和信号处理中的标准问题，基于已建立的傅里叶分析理论和离散傅里叶变换。已知条件完整、一致，并且可以形式化为一个可解的数值问题。测试用例经过精心选择，旨在探究三角插值的不同方面：一个带限情况、一个奈奎斯特边界情况、一个混叠情况以及一个非光滑情况。问题中没有科学缺陷、歧义或矛盾。\n\n**步骤3：结论与行动**\n问题有效。将开发一个完整的解决方案。\n\n### 2. 从第一性原理推导\n\n我们的目标是找到一个三角多项式 $p(x)$，它能插值给定的数据点 $(x_j, y_j)$，其中 $y_j = f(x_j)$。这意味着对于 $j = 0, \\dots, N-1$，有 $p(x_j) = y_j$。\n\n一个通用的周期为 $2\\pi$ 的函数 $f(x)$ 可以用其傅里叶级数表示：\n$$\nf(x) = \\sum_{k=-\\infty}^{\\infty} \\hat{f}_k e^{\\mathrm{i}kx}\n$$\n其中傅里叶系数 $\\hat{f}_k$ 由下式给出：\n$$\n\\hat{f}_k = \\frac{1}{2\\pi} \\int_0^{2\\pi} f(t) e^{-\\mathrm{i}kt} dt\n$$\n由于我们只有函数 $f(x)$ 在离散点 $x_j$ 上的样本，我们无法直接计算该积分。但是，我们可以使用数值积分法则，特别是基于均匀网格点 $x_j$ 的黎曼和来近似它：\n$$\n\\hat{f}_k \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} f(x_j) e^{-\\mathrm{i}kx_j} \\Delta x\n$$\n当 $x_j = 2\\pi j/N$ 且 $\\Delta x = 2\\pi/N$ 时，上式变为：\n$$\n\\hat{f}_k \\approx \\frac{1}{2\\pi} \\sum_{j=0}^{N-1} y_j e^{-\\mathrm{i}k(2\\pi j/N)} \\left(\\frac{2\\pi}{N}\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j e^{-2\\pi\\mathrm{i}kj/N}\n$$\n右侧的表达式是经过缩放的离散傅里叶变换（DFT）的定义。我们定义离散傅里叶系数 $c_k$（$k=0, \\dots, N-1$）如下：\n$$\nc_k = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j e^{-2\\pi\\mathrm{i}kj/N}\n$$\n三角插值多项式 $p(x)$ 是一个有限三角多项式，它使用一组有限的频率模式构建，这些模式可以由 $N$ 个样本唯一确定。对于 $N$ 个样本，我们可以解析出 $N$ 个频率分量。对于实值数据 $y_j$，系数表现出共轭对称性：$c_{N-k} = \\overline{c_k}$。\n\n当 $N$ 为偶数时，可以解析的唯一整数频率集合为 $k \\in \\{0, \\pm 1, \\dots, \\pm(N/2-1), N/2\\}$。在采样网格上，模式 $e^{\\mathrm{i}(N/2)x_j}$ 和 $e^{-\\mathrm{i}(N/2)x_j}$ 是相同的，因为 $e^{\\pm\\mathrm{i}(N/2)x_j} = e^{\\pm\\mathrm{i}\\pi j} = (-1)^j$。因此，它们无法被区分，我们将它们合并为一个余弦项。\n\n对于偶数个点 $N$，三角插值多项式 $p(x)$ 由下式给出：\n$$\np(x) = \\sideset{}{'}\\sum_{k=-N/2}^{N/2} \\hat{c}_k e^{\\mathrm{i}kx}\n$$\n其中求和符号上的撇号表示第一项（$k=-N/2$）和最后一项（$k=N/2$）的权重为 $1/2$。系数 $\\hat{c}_k$ 是通过对DFT系数 $c_k$ 进行重新索引得到的：\n- 对于 $k = 0, 1, \\dots, N/2$，$\\hat{c}_k = c_k$。\n- 对于 $k = -1, \\dots, -N/2+1$，$\\hat{c}_k = c_{k+N}$。\n\n由于共轭对称性质（$c_{N-k} = \\overline{c_k}$），我们有 $\\hat{c}_{-k} = \\overline{\\hat{c}_k}$。这确保了 $p(x)$ 是实值的。对于实数数据，奈奎斯特系数 $\\hat{c}_{N/2} = c_{N/2}$ 是实数。\n该和式可以展开为：\n$$\np(x) = \\hat{c}_0 + \\sum_{k=1}^{N/2-1} (\\hat{c}_k e^{\\mathrm{i}kx} + \\hat{c}_{-k} e^{-\\mathrm{i}kx}) + \\frac{1}{2}(\\hat{c}_{N/2} e^{\\mathrm{i}(N/2)x} + \\hat{c}_{-N/2} e^{-\\mathrm{i}(N/2)x})\n$$\n使用 $\\hat{c}_{-k} = \\overline{\\hat{c}_k}$ 和 $\\hat{c}_{-N/2} = \\hat{c}_{N/2}$（因为 $c_{N/2}$ 是实数），上式可简化为：\n$$\np(x) = \\hat{c}_0 + \\sum_{k=1}^{N/2-1} 2 \\text{Re}(\\hat{c}_k e^{\\mathrm{i}kx}) + \\hat{c}_{N/2} \\cos(Nx/2)\n$$\n这种形式保证了对于所有 $j=0, \\dots, N-1$ 都有 $p(x_j) = y_j$。\n\n### 3. 通过傅里叶空间中的零填充实现超分辨率\n\n为了在一个由 $M$ 个点 $y_m=2\\pi m/M$ 组成的精细网格上求值 $p(x)$，我们可以直接计算该和式。然而，一种更高效的方法是使用快速傅里叶逆变换（IFFT）。这是通过创建一个包含 $M$ 个傅里叶系数的更大向量来实现的，其中原始系数被放置在它们对应的频率位置，而额外的高频系数则被设置为零。这个过程称为零填充。\n\n设 `c_low` 是通过 `fft(y)` 计算出的包含 $N$ 个未缩放DFT系数的数组。新的 $M$ 点系数数组 `c_high` 按如下方式构建（假设 $N, M$ 为偶数）：\n1.  将直到原始奈奎斯特极限的非负频率系数复制过来：\n    `c_high[0 : N//2] = c_low[0 : N//2]`\n2.  将负频率的系数复制到新数组中的相应位置：\n    `c_high[M - N//2 + 1 : M] = c_low[N//2 + 1 : N]`\n3.  原始的奈奎斯特频率 $k=N/2$ 在 $M$ 点的上下文中不再是奈奎斯特频率。它的能量必须在 $k=N/2$ 和 $k=-N/2$ 的模式之间分配。\n    `c_high[N//2] = c_low[N//2] / 2.0`\n    `c_high[M - N//2] = c_low[N//2] / 2.0`\n4.  `c_high` 的所有其他项保持为零，这假设底层信号不包含幅度大于 $N/2$ 的频率。\n\n然后通过应用一个经过缩放的 IFFT 来获得插值 $p(y_m)$：\n$$\np_m = \\frac{M}{N} \\text{real}(\\text{ifft}(\\text{c\\_high}))_m\n$$\n缩放因子 $M/N$ 考虑了 DFT 的缩放约定（在我们的定义中是 $1/N$）和 IFFT 的缩放约定（在标准算法中是 $1/M$）。\n\n该过程在 $M$ 个高分辨率网格点上产生三角插值多项式 $p(x)$ 的值，从而实现“超分辨率”。\n\n### 4. 算法实现\n\n总体算法如下：\n1.  **输入：** 函数定义 $f(x)$、低分辨率样本数 $N$ 和高分辨率样本数 $M$。\n2.  **采样：** 生成粗网格 $x_j = 2\\pi j/N$ 和样本值 $y_j = f(x_j)$（$j=0, \\dots, N-1$）。\n3.  **DFT：** 计算样本的未缩放DFT：`c_low = np.fft.fft(y_j)`。\n4.  **零填充：** 使用第3节中描述的逻辑，从 `c_low` 构建 $M$ 点系数数组 `c_high`。\n5.  **IDFT：** 通过缩放的IFFT计算高分辨率信号：`p_highres = (M/N) * np.real(np.fft.ifft(c_high))`。\n6.  **计算误差：**\n    a.  **一致性误差：** 根据构造，三角插值多项式必须与样本完美匹配。通过对高分辨率结果进行子采样来评估误差 $p(x_j) - y_j$：`p_highres[::M//N]`。计算最大绝对差。这个误差应该在机器精度的数量级。\n    b.  **高分辨率误差：** 在精细网格上生成真实函数值 $f(y_m)$，并计算 `p_highres` 与这些真实值之间的最大绝对差。\n\n现在将此算法应用于问题中指定的四个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the trigonometric interpolation problem for a suite of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda x: np.sin(3 * x) + 0.5 * np.cos(5 * x),\n            \"N\": 32,\n            \"M\": 1024,\n            \"name\": \"Happy path (band-limited)\"\n        },\n        {\n            \"f\": lambda x: np.cos(x),\n            \"N\": 2,\n            \"M\": 128,\n            \"name\": \"Boundary case with minimal sampling\"\n        },\n        {\n            \"f\": lambda x: np.sin(20 * x) + 0.3 * np.cos(2 * x),\n            \"N\": 16,\n            \"M\": 1024,\n            \"name\": \"Aliasing present\"\n        },\n        {\n            \"f\": lambda x: np.fmod(x, 2 * np.pi) / np.pi - 1.0,\n            \"N\": 64,\n            \"M\": 2048,\n            \"name\": \"Non-smooth periodic signal\"\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f, N, M = case[\"f\"], case[\"N\"], case[\"M\"]\n\n        # 1. Generate low-resolution grid and sample the function.\n        # x_j = 2 * pi * j / N for j = 0, ..., N-1\n        x_coarse = 2 * np.pi * np.arange(N) / N\n        y_coarse = f(x_coarse)\n\n        # 2. Compute the DFT of the low-resolution samples.\n        # The coefficients are c_k = (1/N) * sum(y_j * exp(-2*pi*i*j*k/N)).\n        # We compute the unscaled DFT first: c_low = fft(y_coarse).\n        c_low = np.fft.fft(y_coarse)\n\n        # 3. Create high-resolution coefficients by zero-padding in Fourier space.\n        # This is the core of the \"super-resolution\" process.\n        c_high = np.zeros(M, dtype=np.complex128)\n\n        # All test cases have N as an even number.\n        # Positive frequencies (and DC component at k=0)\n        # Indices 0 to N/2 - 1 for freqs k=0,...,N/2-1\n        k_pos_limit = N // 2\n        c_high[0:k_pos_limit] = c_low[0:k_pos_limit]\n\n        # Negative frequencies go at the end of the array for 'fft' convention\n        # Indices N/2 + 1 to N - 1 correspond to freqs k = -N/2+1,...,-1\n        # These are mapped to indices M-N/2+1 to M-1 in the high-res array.\n        k_neg_start = N // 2 + 1\n        c_high[M - (N - k_neg_start):] = c_low[k_neg_start:]\n\n        # The Nyquist frequency k = N/2 component must be split.\n        # Its energy is distributed between the +k and -k modes in the new basis.\n        # In the original N-point DFT, +N/2 and -N/2 were indistinguishable.\n        nyquist_idx = N // 2\n        nyquist_coeff = c_low[nyquist_idx]\n        c_high[nyquist_idx] = nyquist_coeff / 2.0\n        c_high[M - nyquist_idx] = nyquist_coeff / 2.0\n        \n        # 4. Perform inverse FFT to get the high-resolution signal.\n        # The scaling factor M/N arises from our coefficient definition (1/N)\n        # and the standard IFFT algorithm's scaling (1/M).\n        # We want p(x) = sum(c_k * exp(ikx)), where c_k is the scaled coefficient.\n        # Our c_high is based on unscaled DFT.\n        # ifft(c_high) computes (1/M) * sum(c_high[k] * exp(2*pi*i*k*m/M)).\n        # We have c_high_k ~ N*c_k. So ifft(c_high) ~ (N/M) * p(y_m).\n        # Thus, p(y_m) = (M/N) * ifft(c_high).\n        p_highres = (M / N) * np.real(np.fft.ifft(c_high))\n\n        # 5. Calculate the two required error metrics.\n        \n        # Consistency error on the coarse grid.\n        # The trigonometric interpolant must match the samples at the coarse nodes.\n        # The coarse nodes correspond to every M/N-th sample of the fine grid.\n        # Due to floating-point arithmetic, this will be close to zero.\n        subsample_step = M // N\n        p_coarse_from_highres = p_highres[::subsample_step]\n        consistency_error = np.max(np.abs(p_coarse_from_highres - y_coarse))\n        \n        # High-resolution error\n        # Compare the interpolant with the true function on the fine grid.\n        y_fine = 2 * np.pi * np.arange(M) / M\n        y_true_fine = f(y_fine)\n        hires_error = np.max(np.abs(p_highres - y_true_fine))\n        \n        results.append(consistency_error)\n        results.append(hires_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3284404"}, {"introduction": "精确插值的前提是数据点是完美的。但当面对真实的、含有噪声的数据时，情况会怎样呢？这个实践 [@problem_id:3284517] 将引导你完成一个关键实验，比较精确三角插值与三角函数最小二乘回归。通过观察每种方法如何处理噪声，你将深刻理解偏差-方差权衡，并明白为什么拟合噪声（即过拟合）会导致糟糕的预测性能。", "problem": "您的任务是设计并实现一个实验，用于在存在噪声的情况下区分三角插值和最小二乘三角回归，并量化它们在未见点上的泛化性能。所有角度都必须以弧度为单位。\n\n从以下基本依据出发：\n- 复指数在周期区间上的正交性，即集合 $\\{e^{\\mathrm{i} k t}\\}_{k\\in\\mathbb{Z}}$ 在一个周期上是正交的。\n- 三角插值的定义：一个周期性的三角多项式，它精确地通过在一个完整周期上的等间距节点上采样的给定数据。\n- 最小二乘回归的定义：指定模型类别相对于观测数据的残差平方和的最小化器。\n\n您必须：\n1) 推导计算公式，用于构建一个在单个周期上于 $N$ 个等间距节点采样的周期函数的精确三角插值。该插值必须在训练节点上与带噪声的样本完全匹配，并且可以表示为一个有限三角级数。您可以使用离散傅里叶变换作为计算工具，但必须从正交性和插值条件出发，证明其使用的合理性。\n2) 推导计算公式，用于将一个 $M$ 阶截断实三角模型以最小二乘的方式拟合到相同的训练数据上。该模型形式为\n$$\ns_M(t) \\;=\\; a_0 \\;+\\; \\sum_{k=1}^{M} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big),\n$$\n其系数必须通过最小化训练节点上的残差平方和来获得。\n3) 实现这两种方法，并通过计算每种方法在一个密集的测试网格上相对于真实的无噪声周期函数的均方根误差（RMSE），来比较它们的样本外性能。\n\n数据生成协议（角度以弧度为单位）：\n- 训练节点：对于每个用例，使用 $t_j = 2\\pi j / N$，其中 $j=0,1,\\dots,N-1$。\n- 一个真实的周期性目标函数被指定为\n$$\nf(t) \\;=\\; a_0 \\;+\\; \\sum_{k=1}^{K} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big).\n$$\n- 观测值是带噪声的：$y_j = f(t_j) + \\varepsilon_j$，其中 $\\varepsilon_j$ 是独立同分布的正态随机变量，均值为 $0$，标准差为 $\\sigma$，使用固定的随机种子生成以保证可复现性。\n- 测试网格必须是一个周期上的一组 $T$ 个等间距点：$t^{\\ast}_m = 2\\pi m / T$，其中 $m=0,1,\\dots,T-1$。使用 $T = 4096$。\n\n性能度量：\n- 对于每种方法，计算样本外均方根误差\n$$\n\\mathrm{RMSE} \\;=\\; \\sqrt{\\frac{1}{T} \\sum_{m=0}^{T-1} \\big( \\hat{f}(t^{\\ast}_m) - f(t^{\\ast}_m) \\big)^2 },\n$$\n其中 $\\hat{f}$ 是三角插值或截断最小二乘拟合。较低的 $\\mathrm{RMSE}$ 表示对真实潜在函数的泛化能力更好。\n\n您的程序必须实现以上内容，并评估以下测试用例集。在每个用例中，生成噪声前，都应使用相同的种子 $314159$ 初始化一个伪随机数生成器，以确保结果是可复现的。对于每个用例，报告一个布尔值，表示最小二乘截断模型是否比精确插值泛化得更好，即 $\\mathrm{RMSE}_{\\mathrm{LS}}  \\mathrm{RMSE}_{\\mathrm{Interp}}$ 是否成立。\n\n带系数和参数的测试用例集：\n- 用例 $1$：$N = 64$，$K = 3$，$\\sigma = 0.2$，$M = 3$，$a_0 = 0.1$，其中\n  对于 $k = 1,2,3$ 的 $a_k$ 等于 $\\{1.0,\\,0.5,\\,0.2\\}$，\n  对于 $k = 1,2,3$ 的 $b_k$ 等于 $\\{0.5,\\,-0.3,\\,0.1\\}$。\n- 用例 $2$：$N = 64$，$K = 6$，$\\sigma = 0.0$，$M = 3$，$a_0 = 0.0$，其中\n  对于 $k = 1,2,3,4,5,6$ 的 $a_k$ 等于 $\\{0.7,\\,-0.4,\\,0.3,\\,0.2,\\,-0.1,\\,0.05\\}$，\n  对于 $k = 1,2,3,4,5,6$ 的 $b_k$ 等于 $\\{-0.2,\\,0.3,\\,-0.1,\\,0.25,\\,0.2,\\,-0.05\\}$。\n- 用例 $3$：$N = 64$，$K = 5$，$\\sigma = 1.0$，$M = 3$，$a_0 = 0.2$，其中\n  对于 $k = 1,2,3,4,5$ 的 $a_k$ 等于 $\\{0.9,\\,-0.6,\\,0.4,\\,-0.3,\\,0.15\\}$，\n  对于 $k = 1,2,3,4,5$ 的 $b_k$ 等于 $\\{0.5,\\,0.4,\\,-0.2,\\,0.3,\\,-0.1\\}$。\n- 用例 $4$：$N = 16$，$K = 3$，$\\sigma = 0.5$，$M = 3$，$a_0 = -0.1$，其中\n  对于 $k = 1,2,3$ 的 $a_k$ 等于 $\\{0.9,\\,0.4,\\,-0.2\\}$，\n  对于 $k = 1,2,3$ 的 $b_k$ 等于 $\\{-0.4,\\,0.35,\\,0.15\\}$。\n\n实现要求：\n- 利用其匹配所有训练样本的定义属性以及复指数在一个周期上的正交性来构建精确的三角插值。您可以使用适用于等间距样本的离散傅里叶变换来计算其系数，并在密集的测试网格上评估该插值。\n- 通过求解系数 $\\{a_0,a_1,\\dots,a_M,b_1,\\dots,b_M\\}$ 的线性最小二乘问题，使用训练数据构建 $M$ 阶最小二乘截断实三角拟合，然后在密集的测试网格上评估拟合后的模型。\n- 对于每个用例，在测试网格上计算 $\\mathrm{RMSE}_{\\mathrm{Interp}}$ 和 $\\mathrm{RMSE}_{\\mathrm{LS}}$ 两者相对于真实函数 $f(t)$ 的值。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，并按上述用例排序。每个条目必须是一个布尔值，当且仅当该用例的 $\\mathrm{RMSE}_{\\mathrm{LS}}  \\mathrm{RMSE}_{\\mathrm{Interp}}$ 时为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。例如：$\\big[ \\mathrm{True},\\mathrm{False},\\mathrm{True},\\mathrm{True} \\big]$。", "solution": "### 第 1 步：提取已知信息\n- **任务**：设计并实现一个实验，以比较三角插值和最小二乘三角回归。所有角度均以弧度为单位。\n- **基本依据**：\n    - $\\{e^{\\mathrm{i} k t}\\}_{k\\in\\mathbb{Z}}$ 在一个周期区间上的正交性。\n    - 三角插值：周期性三角多项式，精确通过在一个完整周期上的 $N$ 个等间距节点上采样的数据。\n    - 最小二乘回归：指定模型类别的残差平方和的最小化器。\n\n- **推导要求**：\n    1.  用于 $N$ 个等间距节点的精确三角插值的计算公式，使用 DFT 并证明其合理性。\n    2.  通过最小二乘法拟合一个 $M$ 阶截断实三角模型的计算公式：\n        $$\n        s_M(t) \\;=\\; a_0 \\;+\\; \\sum_{k=1}^{M} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big)\n        $$\n\n- **实现与比较**：\n    - 实现这两种方法。\n    - 在一个密集的测试网格上，使用均方根误差 (RMSE) 对比真实的无噪声函数，比较样本外性能。\n\n- **数据生成协议**：\n    - 训练节点：$t_j = 2\\pi j / N$，其中 $j=0,1,\\dots,N-1$。\n    - 真实目标函数：$f(t) = a_0 + \\sum_{k=1}^{K} \\big( a_k \\cos(kt) + b_k \\sin(kt) \\big)$。\n    - 带噪声的观测值：$y_j = f(t_j) + \\varepsilon_j$，其中 $\\varepsilon_j \\sim \\mathcal{N}(0, \\sigma^2)$，独立同分布。\n    - 用于生成噪声的随机种子：$314159$。\n    - 测试网格：$t^{\\ast}_m = 2\\pi m / T$，其中 $m=0,1,\\dots,T-1$，且 $T = 4096$。\n\n- **性能度量**：\n    - RMSE: $\\sqrt{\\frac{1}{T} \\sum_{m=0}^{T-1} \\big( \\hat{f}(t^{\\ast}_m) - f(t^{\\ast}_m) \\big)^2 }$，其中 $\\hat{f}$ 是插值或最小二乘拟合。\n\n- **最终输出**：一个布尔值列表，其中如果 $\\mathrm{RMSE}_{\\mathrm{LS}}  \\mathrm{RMSE}_{\\mathrm{Interp}}$，则条目为 $\\mathrm{True}$。\n\n- **测试用例集**：\n    - 用例 1：$N = 64$，$K = 3$，$\\sigma = 0.2$，$M = 3$，$a_0 = 0.1$，$a_k = \\{1.0,\\,0.5,\\,0.2\\}$，$b_k = \\{0.5,\\,-0.3,\\,0.1\\}$。\n    - 用例 2：$N = 64$，$K = 6$，$\\sigma = 0.0$，$M = 3$，$a_0 = 0.0$，$a_k = \\{0.7,\\,-0.4,\\,0.3,\\,0.2,\\,-0.1,\\,0.05\\}$，$b_k = \\{-0.2,\\,0.3,\\,-0.1,\\,0.25,\\,0.2,\\,-0.05\\}$。\n    - 用例 3：$N = 64$，$K = 5$，$\\sigma = 1.0$，$M = 3$，$a_0 = 0.2$，$a_k = \\{0.9,\\,-0.6,\\,0.4,\\,-0.3,\\,0.15\\}$，$b_k = \\{0.5,\\,0.4,\\,-0.2,\\,0.3,\\,-0.1\\}$。\n    - 用例 4：$N = 16$，$K = 3$，$\\sigma = 0.5$，$M = 3$，$a_0 = -0.1$，$a_k = \\{0.9,\\,0.4,\\,-0.2\\}$，$b_k = \\{-0.4,\\,0.35,\\,0.15\\}$。\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据，是数值分析和应用傅里叶分析中的一个标准练习。它涉及三角插值、最小二乘逼近以及统计建模中偏差-方差权衡等已成熟的概念。该问题是适定的：它为每个测试用例提供了所有必要的数据、参数和定义。目标陈述清晰，语言精确无歧义。任务可被形式化为一个具体的计算实验。整个设置是自洽且一致的。不存在科学或逻辑上的缺陷。\n\n### 第 3 步：结论与行动\n问题是有效的。将提供一个解决方案。\n\n### 基于原理的解决方案\n\n该问题要求对从带噪声样本中逼近周期函数的两种方法进行比较分析：精确三角插值和截断最小二乘三角回归。这种比较突显了函数逼近中偏差与方差之间的基本权衡。插值能完美拟合训练数据，包括噪声，这通常会导致一个泛化能力差的高方差模型（过拟合）。相比之下，使用一个 $M$ 阶截断模型的最小二乘回归充当一个低通滤波器，通过不拟合高频噪声来降低方差，但如果真实信号包含高于 $M$ 的频率，则可能会引入偏差。\n\n**1. 精确三角插值的公式**\n\n给定一组 $N$ 个数据点 $(t_j, y_j)$，其中 $t_j = 2\\pi j/N$，$j=0, 1, \\dots, N-1$，目标是找到一个三角多项式 $p(t)$，它满足对所有 $j$ 的插值条件 $p(t_j) = y_j$。对于偶数个点 $N$（如测试用例中所指定），阶数至多为 $N/2$ 的唯一三角多项式可以写成实数形式：\n$$\np(t) = A_0 + \\sum_{k=1}^{N/2-1} \\left( A_k \\cos(kt) + B_k \\sin(kt) \\right) + A_{N/2} \\cos\\left(\\frac{N}{2}t\\right)\n$$\n这个多项式有 $1 + 2(N/2 - 1) + 1 = N$ 个自由度，对应于系数 $\\{A_k\\}_{k=0}^{N/2}$ 和 $\\{B_k\\}_{k=1}^{N/2-1}$。\n\n这些系数是通过利用三角基函数在节点集 $\\{t_j\\}$ 上的离散正交性来确定的。这些性质是复指数在离散点集上正交性的直接推论。具体来说，对于整数 $k, l \\in [0, N/2]$：\n$$\n\\sum_{j=0}^{N-1} \\cos(kt_j)\\cos(lt_j) = \\begin{cases} N   k=l=0 \\text{ 或 } N/2 \\\\ N/2   k=l \\in \\{1,\\dots,N/2-1\\} \\\\ 0   k \\neq l \\end{cases}\n$$\n$$\n\\sum_{j=0}^{N-1} \\sin(kt_j)\\sin(lt_j) = \\begin{cases} N/2   k=l \\in \\{1,\\dots,N/2-1\\} \\\\ 0   k \\neq l \\end{cases}\n$$\n$$\n\\sum_{j=0}^{N-1} \\cos(kt_j)\\sin(lt_j) = 0 \\quad \\forall k, l\n$$\n通过将 $t=t_j$ 代入 $p(t)$ 的表达式，令其等于 $y_j$，再乘以一个基函数（例如 $\\cos(kt_j)$），并对所有 $j$ 求和，由于这些正交关系，我们可以分离出每个系数。这个过程得出了以下系数公式：\n$$\nA_0 = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j\n$$\n$$\nA_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\cos(kt_j), \\quad k \\in \\{1, \\dots, N/2-1\\}\n$$\n$$\nB_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\sin(kt_j), \\quad k \\in \\{1, \\dots, N/2-1\\}\n$$\n$$\nA_{N/2} = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j \\cos\\left(\\frac{N}{2}t_j\\right) = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j (-1)^j\n$$\n这些和式定义了离散傅里叶变换 (DFT)。可以使用快速傅里叶变换 (FFT) 算法高效地计算这些系数。令 $\\{C_k\\}_{k=0}^{N/2}$ 为序列 $\\{y_j\\}_{j=0}^{N-1}$ 的实值 FFT 结果。这些系数与 FFT 输出的关系如下：\n$A_0 = C_0 / N$, $A_{N/2} = C_{N/2} / N$，以及对于 $k=1, \\dots, N/2-1$：\n$$\nA_k = \\frac{2}{N} \\mathrm{Re}(C_k)\n$$\n$$\nB_k = -\\frac{2}{N} \\mathrm{Im}(C_k)\n$$\n\n**2. 最小二乘三角回归的公式**\n\n第二种方法涉及将一个指定阶数 $M  N/2$ 的三角多项式拟合到数据上。模型是：\n$$\ns_M(t) = a_0 + \\sum_{k=1}^{M} \\left( a_k \\cos(kt) + b_k \\sin(kt) \\right)\n$$\n目标是找到系数 $\\{a_k\\}_{k=0}^M$ 和 $\\{b_k\\}_{k=1}^M$，以最小化残差平方和：\n$$\nS = \\sum_{j=0}^{N-1} \\left( y_j - s_M(t_j) \\right)^2\n$$\n这是一个线性最小二乘问题。设未知系数向量为 $\\boldsymbol{\\theta} = [a_0, a_1, \\dots, a_M, b_1, \\dots, b_M]^T$。该问题可以写成矩阵形式，即最小化 $\\|\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta}\\|_2^2$，其中 $\\mathbf{y} = [y_0, \\dots, y_{N-1}]^T$ 是观测向量，$\\mathbf{X}$ 是 $N \\times (1+2M)$ 的设计矩阵，其列是在训练节点 $t_j$ 上求值的基函数：\n$$\n\\mathbf{X} = \\begin{bmatrix}\n1  \\cos(1 t_0)  \\dots  \\cos(M t_0)  \\sin(1 t_0)  \\dots  \\sin(M t_0) \\\\\n1  \\cos(1 t_1)  \\dots  \\cos(M t_1)  \\sin(1 t_1)  \\dots  \\sin(M t_1) \\\\\n\\vdots  \\vdots  \\ddots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  \\cos(1 t_{N-1})  \\dots  \\cos(M t_{N-1})  \\sin(1 t_{N-1})  \\dots  \\sin(M t_{N-1})\n\\end{bmatrix}\n$$\n解 $\\boldsymbol{\\theta}$ 通过求解正规方程 $\\mathbf{X}^T\\mathbf{X}\\boldsymbol{\\theta} = \\mathbf{X}^T\\mathbf{y}$ 得到。由于 $M  N/2$，离散正交关系对 $\\mathbf{X}$ 的列成立，使得矩阵 $\\mathbf{X}^T\\mathbf{X}$ 为对角矩阵：\n$$\n\\mathbf{X}^T\\mathbf{X} = \\mathrm{diag}\\left(N, \\frac{N}{2}, \\dots, \\frac{N}{2}, \\frac{N}{2}, \\dots, \\frac{N}{2}\\right)\n$$\n求解 $\\boldsymbol{\\theta}$ 得出的系数表达式与完整插值的前 $M$ 个傅里叶系数相同：\n$$\na_0 = \\frac{1}{N} \\sum_{j=0}^{N-1} y_j\n$$\n$$\na_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\cos(kt_j), \\quad k \\in \\{1, \\dots, M\\}\n$$\n$$\nb_k = \\frac{2}{N} \\sum_{j=0}^{N-1} y_j \\sin(kt_j), \\quad k \\in \\{1, \\dots, M\\}\n$$\n因此，使用该模型的最小二乘逼近等价于截断数据的傅里叶级数。虽然存在这种解析解，但一个鲁棒的数值实现可以直接使用标准的最小二乘求解器来解决该线性系统，这也是此处采用的方法。\n\n**3. 实验设计与评估**\n\n对于每个测试用例，实验将按以下步骤进行：\n1.  在 $N$ 个训练节点上生成真实函数值 $f(t_j)$ 和带噪声的观测值 $y_j = f(t_j) + \\varepsilon_j$。\n2.  使用 $\\{y_j\\}$ 的 FFT 计算精确三角插值 $p(t)$ 的系数。\n3.  求解线性最小二乘问题，以找到截断模型 $s_M(t)$ 的系数。\n4.  在一个由 $T$ 个测试点 $\\{t^*_m\\}$ 组成的密集网格上评估 $p(t)$ 和 $s_M(t)$。\n5.  在相同的测试网格上计算真实函数值 $f(t^*_m)$。\n6.  计算两种方法相对于真实函数值 $f(t^*_m)$ 的 RMSE。\n7.  比较 RMSE 值，以确定哪种方法提供更好的泛化性能，即在未见数据上有更低的误差。布尔结果 $\\mathrm{RMSE}_{\\mathrm{LS}}  \\mathrm{RMSE}_{\\mathrm{Interp}}$ 量化了这种比较。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of comparing trigonometric interpolation and least-squares\n    regression by running a suite of test cases.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1\n        {\n            'N': 64, 'K': 3, 'sigma': 0.2, 'M': 3, 'a0': 0.1,\n            'a_k': [1.0, 0.5, 0.2], 'b_k': [0.5, -0.3, 0.1]\n        },\n        # Case 2\n        {\n            'N': 64, 'K': 6, 'sigma': 0.0, 'M': 3, 'a0': 0.0,\n            'a_k': [0.7, -0.4, 0.3, 0.2, -0.1, 0.05],\n            'b_k': [-0.2, 0.3, -0.1, 0.25, 0.2, -0.05]\n        },\n        # Case 3\n        {\n            'N': 64, 'K': 5, 'sigma': 1.0, 'M': 3, 'a0': 0.2,\n            'a_k': [0.9, -0.6, 0.4, -0.3, 0.15],\n            'b_k': [0.5, 0.4, -0.2, 0.3, -0.1]\n        },\n        # Case 4\n        {\n            'N': 16, 'K': 3, 'sigma': 0.5, 'M': 3, 'a0': -0.1,\n            'a_k': [0.9, 0.4, -0.2], 'b_k': [-0.4, 0.35, 0.15]\n        }\n    ]\n\n    T = 4096\n    seed = 314159\n    results = []\n\n    for case in test_cases:\n        N = case['N']\n        K = case['K']\n        sigma = case['sigma']\n        M = case['M']\n        \n        # --- Data Generation ---\n        # Initialize RNG with fixed seed for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # Training nodes\n        t_train = 2 * np.pi * np.arange(N) / N\n\n        # True function definition\n        def f(t, params):\n            val = np.full_like(t, params['a0'])\n            for k in range(1, params['K'] + 1):\n                val += params['a_k'][k-1] * np.cos(k * t) + params['b_k'][k-1] * np.sin(k * t)\n            return val\n\n        # True values and noisy observations at training nodes\n        f_train = f(t_train, case)\n        noise = rng.normal(0, sigma, N)\n        y_train = f_train + noise\n\n        # Test grid and true values on the test grid\n        t_test = 2 * np.pi * np.arange(T) / T\n        f_test = f(t_test, case)\n\n        # --- Method 1: Trigonometric Interpolation ---\n        # Compute coefficients using Real FFT\n        C = np.fft.rfft(y_train)\n        A_interp = np.zeros(N // 2 + 1)\n        B_interp = np.zeros(N // 2 - 1)\n        \n        A_interp[0] = C[0] / N\n        if N > 1:\n            A_interp[1:N//2] = 2 * np.real(C[1:N//2]) / N\n            B_interp[:] = -2 * np.imag(C[1:N//2]) / N\n            A_interp[N//2] = C[N//2] / N\n\n        # Evaluate interpolant on the test grid\n        y_interp_pred = np.full_like(t_test, A_interp[0])\n        if N > 1:\n            for k in range(1, N // 2):\n                y_interp_pred += A_interp[k] * np.cos(k * t_test) + B_interp[k-1] * np.sin(k * t_test)\n            y_interp_pred += A_interp[N//2] * np.cos((N // 2) * t_test)\n\n        # --- Method 2: Least-Squares Trigonometric Regression ---\n        # Construct the design matrix X\n        num_coeffs = 1 + 2 * M\n        X = np.zeros((N, num_coeffs))\n        X[:, 0] = 1  # Column for a0\n        for k in range(1, M + 1):\n            X[:, k] = np.cos(k * t_train)      # Columns for a_k\n            X[:, M + k] = np.sin(k * t_train)  # Columns for b_k\n            \n        # Solve the linear least-squares problem\n        coeffs_ls, _, _, _ = np.linalg.lstsq(X, y_train, rcond=None)\n        a_ls = coeffs_ls[0:M+1]\n        b_ls = coeffs_ls[M+1:]\n        \n        # Evaluate the least-squares model on the test grid\n        y_ls_pred = np.full_like(t_test, a_ls[0])\n        for k in range(1, M + 1):\n            y_ls_pred += a_ls[k] * np.cos(k * t_test) + b_ls[k-1] * np.sin(k * t_test)\n\n        # --- Performance Evaluation ---\n        # Calculate RMSE for both methods\n        rmse_interp = np.sqrt(np.mean((y_interp_pred - f_test)**2))\n        rmse_ls = np.sqrt(np.mean((y_ls_pred - f_test)**2))\n\n        # Append boolean result\n        results.append(rmse_ls  rmse_interp)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3284517"}, {"introduction": "一个数学上正确的公式未必在数值上是稳定的。我们最后的实践 [@problem_id:3284441] 将探讨这一关键概念，通过比较两种计算三角插值的方法：标准的重心插值公式和更稳健的基于傅里叶级数求和的方法。你将构建一个会导致重心公式因灾难性抵消而严重失效的场景，从而凸显在科学计算中选择数值稳定算法的重要性。", "problem": "考虑一个在区间 $[0,2\\pi)$ 上以 $n$ 个等距节点采样的实值 $2\\pi$ 周期函数。设节点为 $x_j = \\frac{2\\pi j}{n}$，其中 $j=0,1,\\dots,n-1$，采样值为 $f_j = f(x_j)$。一个次数为 $m$ 且 $n=2m+1$ 的三角插值函数是 $\\{\\exp(i k x) : k=-m,\\dots,m\\}$ 张成的空间中与样本点 $\\{f_j\\}$ 匹配的唯一函数。在远离节点处计算该插值函数的标准方法是使用基于基本三角恒等式构建的重心坐标式公式；然而，当计算点非常接近某个节点时，这种标准重心坐标计算的直接实现会遭遇灾难性相消，因为大小为 $O\\left(\\frac{1}{|x-x_j|}\\right)$ 且符号交替的项被求和。\n\n您的任务是：\n- 从离散傅里叶基和狄利克雷核作为基础出发，构建等距节点三角插值的标准重心坐标形式（不要在问题陈述中列出任何显式的计算公式）。解释为什么当 $x$ 趋近于节点 $x_j$ 时，朴素计算会损失许多精度位数。\n- 实现两个三角插值函数求值器：\n  1. 一个标准的重心坐标求值器，通过浮点运算中的朴素求和直接实现推导出的重心坐标形式。\n  2. 一个数值稳定的求值器，它使用从 $\\{f_j\\}$ 计算出的离散傅里叶级数系数，然后在目标点 $x$ 处计算 $\\sum_{k=-m}^m c_k e^{ikx}$，其中系数 $c_k$ 由样本确定。这种表示方法避免了重心坐标形式的近极点相消问题。\n- 使用函数 $f(x) = \\sin(x) + \\frac{1}{2}\\sin(5x) + \\frac{1}{4}\\cos(12x)$ 创建一个特定的数据集，该函数可以在次数 $m \\ge 12$ 的三角函数空间中精确表示。使用节点 $x_j = \\frac{2\\pi j}{n}$，其中 $n$ 为奇数，以使 $n=2m+1$，从而确保对所选函数 $f(x)$ 的表示没有混叠。\n\n角度单位：始终使用弧度。\n\n定义以下计算场景的测试套件，每个场景由 $(n, j^\\*, \\varepsilon, x)$ 指定，其中 $x$ 或者通过 $x = x_{j^\\*} + \\varepsilon$ 构建，或者直接给出：\n- 案例1：$(n=\\;25,\\; j^\\*=\\;10,\\; \\varepsilon=\\;5\\times 10^{-16},\\; x = x_{10} + \\varepsilon)$，一个旨在在朴素重心坐标计算中引发灾难性相消的极端近节点情况。\n- 案例2：$(n=\\;25,\\; j^\\*=\\;10,\\; \\varepsilon=\\;0,\\; x = x_{10})$，插值函数必须精确返回数据值的边界情况。\n- 案例3：$(n=\\;25,\\; j^\\* \\text{ 未使用},\\; \\varepsilon \\text{ 未使用},\\; x=\\;1.234)$，一个远离节点的通用“理想路径”计算。\n- 案例4：$(n=\\;101,\\; j^\\*=\\;50,\\; \\varepsilon=\\;10^{-12},\\; x = x_{50} + \\varepsilon)$，一个更大的样本量，增加了近节点项的动态范围。\n- 案例5：$(n=\\;25,\\; j^\\*=\\;10,\\; \\varepsilon=\\;10^{-8},\\; x = x_{10} + \\varepsilon)$，一个中等程度的近节点情况。\n\n对于每种情况：\n- 使用 $f(x) = \\sin(x) + \\frac{1}{2}\\sin(5x) + \\frac{1}{4}\\cos(12x)$ 构建节点 $\\{x_j\\}$ 和样本 $f_j = f(x_j)$。\n- 使用朴素重心坐标求值器和基于傅里叶系数的稳定求值器，在指定的 $x$ 处计算插值函数。\n- 令 $p_{\\text{naive}}(x)$ 表示朴素重心坐标计算的结果，令 $p_{\\text{stable}}(x)$ 表示基于傅里叶系数的计算结果。\n- 计算绝对误差 $E = |p_{\\text{naive}}(x) - p_{\\text{stable}}(x)|$。\n\n您的程序应生成单行输出，其中包含案例1到案例5的结果，格式为方括号内由逗号分隔的列表，即 $[E_1,E_2,E_3,E_4,E_5]$，其中每个 $E_k$ 是一个以弧度派生单位（无量纲标量值）表示的浮点数，按上述规定计算。最终输出必须严格为这种格式的单行。", "solution": "该问题要求推导等距节点三角插值的重心坐标公式，解释其数值不稳定性，并对朴素重心坐标求值器和稳定的基于傅里叶的求值器进行比较性实现。\n\n一个实值 $2\\pi$ 周期函数 $f(x)$ 在 $n$ 个等距节点 $x_j = \\frac{2\\pi j}{n}$ (其中 $j=0, 1, \\dots, n-1$) 处进行采样，其中 $n=2m+1$ 是一个奇数。采样值为 $f_j = f(x_j)$。三角插值函数 $p(x)$ 是由 $\\{e^{ikx}\\}_{k=-m}^{m}$ 张成的空间中满足所有 $j$ 的 $p(x_j)=f_j$ 条件的唯一函数。\n\n该插值函数可以用离散傅里叶基表示为：\n$$ p(x) = \\sum_{k=-m}^{m} c_k e^{ikx} $$\n其中系数 $c_k$ 由样本值 $\\{f_j\\}$ 的离散傅里叶变换给出：\n$$ c_k = \\frac{1}{n} \\sum_{j=0}^{n-1} f_j e^{-ikx_j} $$\n将 $c_k$ 的表达式代入 $p(x)$ 的公式中，得到：\n$$ p(x) = \\sum_{k=-m}^{m} \\left( \\frac{1}{n} \\sum_{j=0}^{n-1} f_j e^{-ikx_j} \\right) e^{ikx} $$\n通过交换求和顺序，我们可以按样本值 $f_j$ 对项进行分组：\n$$ p(x) = \\sum_{j=0}^{n-1} f_j \\left( \\frac{1}{n} \\sum_{k=-m}^{m} e^{ik(x-x_j)} \\right) = \\sum_{j=0}^{n-1} f_j L_j(x) $$\n这是插值函数的拉格朗日形式，其中 $L_j(x)$ 是基函数。$L_j(x)$ 的表达式是狄利克雷核的一个缩放版本：\n$$ L_j(x) = \\frac{1}{n} \\sum_{k=-m}^{m} (e^{i(x-x_j)})^k $$\n这是一个有限几何级数。令 $u = e^{i(x-x_j)}$，则和为 $\\frac{1}{n} u^{-m} \\sum_{l=0}^{2m} u^l$。由于 $n=2m+1$，该和可计算为：\n$$ L_j(x) = \\frac{1}{n} u^{-m} \\frac{u^{2m+1}-1}{u-1} = \\frac{1}{n} \\frac{u^{m+1}-u^{-m}}{u-1} = \\frac{1}{n} \\frac{u^{m+1/2}-u^{-(m+1/2)}}{u^{1/2}-u^{-1/2}} $$\n使用欧拉恒等式 $e^{i\\theta}-e^{-i\\theta} = 2i\\sin(\\theta)$，我们得到 $L_j(x)$ 的闭式形式：\n$$ L_j(x) = \\frac{1}{n} \\frac{2i\\sin((m+1/2)(x-x_j))}{2i\\sin((x-x_j)/2)} = \\frac{\\sin(n(x-x_j)/2)}{n\\sin((x-x_j)/2)} $$\n因为 $m+1/2 = n/2$。\n\n为推导重心坐标公式，我们简化分子。已知 $x_j = 2\\pi j/n$ 且 $n$ 为奇数，我们有：\n$$ \\sin\\left(\\frac{n(x-x_j)}{2}\\right) = \\sin\\left(\\frac{nx}{2} - \\pi j\\right) = \\sin\\left(\\frac{nx}{2}\\right)\\cos(\\pi j) - \\cos\\left(\\frac{nx}{2}\\right)\\sin(\\pi j) = (-1)^j \\sin\\left(\\frac{nx}{2}\\right) $$\n因此，基函数变为：\n$$ L_j(x) = \\frac{(-1)^j\\sin(nx/2)}{n\\sin((x-x_j)/2)} $$\n插值函数为 $p(x) = \\sum_{j=0}^{n-1} f_j L_j(x)$。关键在于，如果我们对常数函数 $g(x)=1$ 进行插值，其样本为所有 $j$ 的 $g_j=1$，其唯一插值函数为 $p(x)=1$。这意味着基函数之和必须为1：\n$$ 1 = \\sum_{j=0}^{n-1} L_j(x) = \\sum_{j=0}^{n-1} \\frac{(-1)^j\\sin(nx/2)}{n\\sin((x-x_j)/2)} $$\n将 $p(x)$ 的表达式除以 $1$ 的表达式，会消去公因子 $\\sin(nx/2)/n$，从而得到三角插值（对于奇数 $n$）的标准重心坐标公式：\n$$ p(x) = \\frac{\\sum_{j=0}^{n-1} \\frac{(-1)^j f_j}{\\sin((x-x_j)/2)}}{\\sum_{j=0}^{n-1} \\frac{(-1)^j}{\\sin((x-x_j)/2)}} $$\n\n**朴素重心坐标计算的数值不稳定性：**\n当计算点 $x$ 非常接近但又不完全等于某个插值节点 $x_k$ 时，此公式的不稳定性就会出现。设 $x = x_k + \\varepsilon$，其中 $\\varepsilon$ 是一个很小的值。\n1.  求和中对应于 $j=k$ 的项涉及 $\\sin((x-x_k)/2) = \\sin(\\varepsilon/2) \\approx \\varepsilon/2$。这个分母极小。\n2.  因此，分子和中的第 $k$ 项 $\\frac{(-1)^k f_k}{\\sin(\\varepsilon/2)}$ 和分母和中的第 $k$ 项 $\\frac{(-1)^k}{\\sin(\\varepsilon/2)}$ 都变得巨大，其量级为 $O(1/|\\varepsilon|)$。\n3.  求和中的所有其他项（$j \\neq k$）保持中等大小，因为它们的分母 $\\sin((x-x_j)/2)$ 不接近于零。\n4.  在浮点运算中，一个非常大的数与几个较小的数相加，会导致大数的低有效位丢失，而这些位正是本应与较小数相结合的。实际上，由较小项（$j \\neq k$）贡献的信息被部分或完全丢失了。\n5.  最终结果是两个计算出的大数之比。由于插值函数 $p(x)$ 的真值必须接近 $f_k$，因此真实的分子和分母必须非常接近一个简单的比率。这意味着所有 $j \\neq k$ 的项之和必须几乎抵消掉占主导地位的第 $k$ 项。这种两个几乎相等的大量（其中一个量是单个项，另一个是和）相减是灾难性相消的典型情况，导致结果带有很大的相对误差，几乎没有（甚至完全没有）正确的数字。\n\n**稳定计算方法：**\n一种数值稳定的替代方法是回到插值函数的基本定义：\n$$ p(x) = \\sum_{k=-m}^{m} c_k e^{ikx} $$\n该方法包括两个步骤：\n1.  计算傅里叶系数 $c_k = \\frac{1}{n} \\sum_{j=0}^{n-1} f_j e^{-i k (2\\pi j/n)}$，其中 $k = -m, \\ldots, m$。这一步使用快速傅里叶变换（FFT）算法可以高效而准确地完成。\n2.  直接计算该和。这个求和过程是数值稳定的。被相加的项 $c_k e^{ikx}$ 的量级与系数 $c_k$ 相当（因为 $|e^{ikx}|=1$）。没有会相互抵消的大中间项，因此避免了灾难性相消。该方法被用作“基准真相”，以衡量朴素重心坐标方法的误差。\n\n该实现将为每个测试用例计算绝对误差 $|p_{\\text{naive}}(x) - p_{\\text{stable}}(x)|$。对于 $x$ 正好是节点 $x_k$ 的情况，朴素求值器必须进行特殊处理，以返回 $f_k$ 并避免除以零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives, implements, and compares two trigonometric interpolation evaluation methods.\n    \"\"\"\n\n    # Define the target function f(x)\n    def f(x):\n        \"\"\"\n        The function to be interpolated. It is a trigonometric polynomial of degree 12.\n        f(x) = sin(x) + 1/2*sin(5x) + 1/4*cos(12x)\n        \"\"\"\n        return np.sin(x) + 0.5 * np.sin(5 * x) + 0.25 * np.cos(12 * x)\n\n    # Method 1: Numerically stable evaluator using Fourier coefficients\n    def stable_evaluator(x, f_j, n):\n        \"\"\"\n        Evaluates the trigonometric interpolant using its Fourier series representation.\n        This method is numerically stable.\n        \"\"\"\n        m = (n - 1) // 2\n        \n        # Compute Fourier coefficients c_k using the Fast Fourier Transform (FFT)\n        f_coeffs = np.fft.fft(f_j) / n\n        \n        # Shift coefficients to correspond to frequencies -m, ..., 0, ..., m\n        c_shifted = np.fft.fftshift(f_coeffs)\n        \n        # Corresponding integer frequencies k = -m, ..., m\n        k_vals = np.arange(-m, m + 1)\n        \n        # Evaluate p(x) = sum_{k=-m to m} c_k * exp(i*k*x)\n        val = np.sum(c_shifted * np.exp(1j * k_vals * x))\n        \n        # The result must be real as f(x) is real. Take the real part to discard\n        # imaginary noise from floating point inaccuracies.\n        return np.real(val)\n\n    # Method 2: Naive barycentric formula evaluator\n    def naive_barycentric_evaluator(x, f_j, x_j, n):\n        \"\"\"\n        Evaluates the trigonometric interpolant using the standard barycentric formula.\n        This method is prone to catastrophic cancellation near nodes.\n        \"\"\"\n        # A direct check for whether x is exactly one of the nodes.\n        # This is necessary to handle the interpolating property p(x_j) = f_j\n        # and to avoid division by zero. Using '==' is intentional to only catch\n        # the exact node case (Test Case 2) and not the near-node cases.\n        match_indices = np.where(x == x_j)[0]\n        if len(match_indices) > 0:\n            return f_j[match_indices[0]]\n\n        # If x is not an exact node, proceed with the barycentric formula\n        numerator = 0.0\n        denominator = 0.0\n        for j in range(n):\n            # Barycentric weights for equispaced points with n odd\n            w_j = (-1)**j\n            \n            # Denominator of the j-th term in the barycentric sum.\n            # This becomes very small if x is close to x_j, leading to a large term.\n            term_den = np.sin((x - x_j[j]) / 2.0)\n            \n            term = w_j / term_den\n            \n            numerator += term * f_j[j]\n            denominator += term\n        \n        # The ratio gives the interpolated value. For x near a node, this is a\n        # ratio of two very large numbers, which is where precision is lost.\n        return numerator / denominator\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set 1): Case 1: Extreme near-node case\n        {'n': 25, 'j_star': 10, 'epsilon': 5e-16, 'x_spec': 'relative'},\n        # (Parameter set 2): Case 2: Exactly at a node\n        {'n': 25, 'j_star': 10, 'epsilon': 0.0, 'x_spec': 'relative'},\n        # (Parameter set 3): Case 3: A generic point far from nodes\n        {'n': 25, 'x': 1.234, 'x_spec': 'absolute'},\n        # (Parameter set 4): Case 4: Larger n, near-node\n        {'n': 101, 'j_star': 50, 'epsilon': 1e-12, 'x_spec': 'relative'},\n        # (Parameter set 5): Case 5: Moderately near-node\n        {'n': 25, 'j_star': 10, 'epsilon': 1e-8, 'x_spec': 'relative'},\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case['n']\n        \n        # Construct nodes and sample data\n        nodes_x_j = (2 * np.pi / n) * np.arange(n)\n        samples_f_j = f(nodes_x_j)\n        \n        # Determine the evaluation point x for the current case\n        if case['x_spec'] == 'relative':\n            j_star = case['j_star']\n            epsilon = case['epsilon']\n            x_eval = nodes_x_j[j_star] + epsilon\n        else:  # 'absolute'\n            x_eval = case['x']\n            \n        # Evaluate the interpolant at x_eval using both methods\n        p_stable = stable_evaluator(x_eval, samples_f_j, n)\n        p_naive = naive_barycentric_evaluator(x_eval, samples_f_j, nodes_x_j, n)\n        \n        # Compute the absolute error between the two evaluations.\n        # p_stable is treated as the ground truth.\n        error = np.abs(p_naive - p_stable)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3284441"}]}