{"hands_on_practices": [{"introduction": "在我们深入探讨快速傅里叶变换 (FFT) 的各种应用之前，首先必须理解它为何是数字信号处理领域的基石。本练习通过一次动手计算，旨在让您直观地感受 FFT 相对于离散傅里叶变换 (DFT) 的巨大计算优势。通过精确计算两种算法所需的乘法次数，您将亲身体会到 FFT 如何将理论上可行的计算变为现实世界中高效的实时处理。", "problem": "一名软件工程师必须决定是直接实现离散傅里叶变换（DFT），还是通过基2 Cooley–Tukey 快速傅里叶变换（FFT）来处理大小为 $N=1024$ 的数据集。该工程师仅通过浮点乘法的次数来衡量成本，定义如下：\n- 一次复数乘法被朴素地实现为 $4$ 次实数乘法。\n- 预计算旋转因子的时间被忽略。\n- 不应用特殊旋转因子值（如 $1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）的代数简化；旋转因子的每次出现都被视为一次常规复数乘法并相应计数。\n\n仅使用 DFT 的定义和 Cooley–Tukey FFT 底层的基2抽取原理，确定对于 $N=1024$ 的情况，直接 DFT 计算所有 $N$ 个输出与基2 Cooley–Tukey FFT 计算所有 $N$ 个输出之间，在实数浮点乘法总次数上的确切差异。请以整数形式提供最终答案；无需四舍五入。", "solution": "将首先提取给定信息，然后评估其科学和逻辑完整性，以此来验证问题。\n\n### 步骤 1：提取已知条件\n- 数据集大小为 $N=1024$。\n- 成本度量是实数浮点乘法的总次数。\n- 单次复数乘法定义为消耗 $4$ 次实数乘法。\n- 预计算旋转因子的时间被忽略。\n- 不考虑特殊旋转因子值（例如 $1$, $-1$, $\\mathrm{i}$, $-\\mathrm{i}$）的代数简化。每次旋转因子乘法都计为一次常规复数乘法。\n- 目标是找出直接离散傅里叶变换（DFT）计算与基2 Cooley–Tukey 快速傅里叶变换（FFT）计算在实数乘法总次数上的差异。\n\n### 步骤 2：使用已知条件进行验证\n- **科学依据：** 该问题是计算复杂性分析中的一个标准练习，比较了 DFT 和 FFT 算法的性能。这是数值方法和信号处理中的一个基本主题。所提供的假设，例如复数乘法的朴素成本和忽略特殊情况优化，虽然是简化的，但表述清晰，对于理论分析而言在科学上是一致的。\n- **适定性：** 问题是适定的。输入大小 $N=1024$ 是 $2$ 的幂（$N=2^{10}$），这是标准基2 Cooley–Tukey 算法的要求。成本函数有明确定义。可以从提供的信息中确定一个唯一的整数值解。\n- **客观性：** 问题陈述是客观的，并使用了精确、无歧义的语言。\n- **完整性与一致性：** 问题是自洽的，提供了所有必要的数据和定义。没有矛盾之处。\n\n### 步骤 3：结论与行动\n问题有效。现在将推导完整的解答。\n\n### 解答推导\n\n目标是计算对于长度为 $N=1024$ 的信号，直接 DFT 和基2 FFT 在实数浮点乘法次数上的差异。\n\n**1. 直接 DFT 的成本**\n\n长度为 $N$ 的序列 $x_n$ 的离散傅里叶变换（DFT）由 $N$ 个复数 $X_k$ 定义：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n e^{-i \\frac{2\\pi kn}{N}} \\quad \\text{for } k = 0, 1, \\dots, N-1\n$$\n我们来分析单个输出系数 $X_k$ 的计算成本。该计算涉及 $N$ 项的总和。和中的每一项形式为 $x_n \\cdot e^{-i \\frac{2\\pi kn}{N}}$。这是两个复数（输入样本 $x_n$，在一般情况下为复数，以及旋转因子 $e^{-i \\frac{2\\pi kn}{N}}$）的乘积。根据问题陈述，我们必须将每个此类运算计为一次常规复数乘法。\n\n因此，对于 $N$ 个输出系数 $X_k$ 中的每一个，我们都必须执行 $N$ 次复数乘法。因此，直接 DFT 的复数乘法总次数为：\n$$\n\\text{Cost}_{\\text{complex, DFT}} = N \\times N = N^2\n$$\n问题指明，一次复数乘法消耗 $4$ 次实数乘法。因此，直接 DFT 的实数乘法总次数为：\n$$\n\\text{Cost}_{\\text{real, DFT}} = 4 \\times N^2\n$$\n\n**2. 基2 Cooley–Tukey FFT 的成本**\n\n基2 Cooley–Tukey 算法是计算 DFT 的一种递归方法。它通过将一个大小为 $N$ 的 DFT 分解为两个大小为 $N/2$ 的 DFT 来工作。设 $C_{\\text{complex}}(N)$ 为大小为 $N$ 的 FFT 所需的复数乘法次数。递推关系为：\n$$\nC_{\\text{complex}}(N) = 2 \\cdot C_{\\text{complex}}(N/2) + (\\text{组合步骤中的乘法次数})\n$$\n组合步骤，或称“蝶形”阶段，根据两个子问题的输出来计算最终输出。对于 $k = 0, 1, \\dots, N/2 - 1$，计算如下：\n$$\nX_k = E_k + e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n$$\nX_{k+N/2} = E_k - e^{-i \\frac{2\\pi k}{N}} O_k\n$$\n其中 $E_k$ 和 $O_k$ 分别是输入信号偶数索引部分和奇数索引部分的 DFT。\n\n乘法发生在项 $e^{-i \\frac{2\\pi k}{N}} O_k$ 中。对于从 $0$ 到 $N/2 - 1$ 的每个 $k$ 值，都必须执行此乘法。这相当于 $N/2$ 次复数乘法。问题明确指出，不对特殊值进行简化，因此即使对于 $k=0$（此时旋转因子为 $1$），我们也必须将其计为一次完整的复数乘法。\n\n因此，递推关系变为：\n$$\nC_{\\text{complex}}(N) = 2 C_{\\text{complex}}(N/2) + \\frac{N}{2}\n$$\n递归的基例是大小为 $N=1$ 的 DFT，它就是恒等变换（$X_0 = x_0$），需要 $0$ 次乘法。所以，$C_{\\text{complex}}(1) = 0$。\n\n由于 $N$ 是 $2$ 的幂，设 $N = 2^m$。递归共有 $m = \\log_2(N)$ 个阶段。在每个阶段，所有蝶形运算总共执行 $N/2$ 次复数乘法。因此，FFT 的复数乘法总次数为：\n$$\nC_{\\text{complex, FFT}}(N) = (\\log_2 N) \\times \\frac{N}{2} = \\frac{N}{2} \\log_2(N)\n$$\n实数乘法的总次数是这个数量的 $4$ 倍：\n$$\n\\text{Cost}_{\\text{real, FFT}} = 4 \\times \\left(\\frac{N}{2} \\log_2(N)\\right) = 2N \\log_2(N)\n$$\n\n**3. 计算差异**\n\n我们需要计算直接 DFT 和 FFT 之间实数乘法次数的差异。设此差异为 $\\Delta M$。\n$$\n\\Delta M = \\text{Cost}_{\\text{real, DFT}} - \\text{Cost}_{\\text{real, FFT}}\n$$\n$$\n\\Delta M = 4N^2 - 2N \\log_2(N)\n$$\n代入给定值 $N = 1024$。我们首先注意到 $1024 = 2^{10}$，所以 $\\log_2(1024) = 10$。\n$$\n\\Delta M = 4(1024)^2 - 2(1024)(10)\n$$\n$$\n\\Delta M = 4(1048576) - 20(1024)\n$$\n$$\n\\Delta M = 4194304 - 20480\n$$\n$$\n\\Delta M = 4173824\n$$\n或者，我们可以在计算前对表达式进行因式分解：\n$$\n\\Delta M = 2N(2N - \\log_2(N))\n$$\n$$\n\\Delta M = 2(1024)(2(1024) - 10)\n$$\n$$\n\\Delta M = 2048(2048 - 10)\n$$\n$$\n\\Delta M = 2048 \\times 2038\n$$\n$$\n\\Delta M = (2040+8)(2040-2) = 2040^2 - 4080 + 16320 - 16 = 4161600 + 12240 - 16 = 4173840 - 16 = 4173824\n$$\n实数浮点乘法总次数的差异是 $4,173,824$。", "answer": "$$\n\\boxed{4173824}\n$$", "id": "3282537"}, {"introduction": "卷积定理是 FFT 最强大的应用之一，它使得对长信号进行快速卷积成为可能。然而，一个关键的细节是，DFT 本质上是在周期信号上进行操作，这导致了所谓的“循环卷积”，它与我们通常需要的“线性卷积”不同。本练习旨在让您通过实践发现这一现象，并掌握使用标准技巧——零填充（zero-padding）——来通过 FFT 正确计算线性卷积的方法，这是信号处理和科学计算中的一项基本技能。[@problem_id:3282547]", "problem": "你需要研究快速傅里叶变换 (FFT) 算法中固有的周期性假设如何影响卷积，以及零填充如何减轻回卷伪影 (wrap-around artifacts)。整个过程完全在离散时间下进行。你的程序必须从核心定义开始，实现以下内容。\n\n设一个有限长、非周期的离散时间信号定义为 $x[n] = n + 1$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，且在其他情况下 $x[n] = 0$，其中 $N = 10$。设一个有限长、非周期的平均核定义为 $h[n] = \\frac{1}{M}$，其中 $n \\in \\{0,1,\\dots,M-1\\}$，且在其他情况下 $h[n] = 0$，其中 $M = 4$。定义线性卷积 $y_{\\mathrm{lin}}[n]$ 为\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k],\n$$\n其中，$x[n]$ 和 $h[n]$ 在其指定的支撑集之外均被视为零。这个和是有限的，$y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1 = 13$。\n\n定义一个支撑于 $\\{0,1,\\dots,L-1\\}$ 的序列 $a[n]$ 的长度为 $L$ 的离散傅里叶变换 (DFT) 为\n$$\nA_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}},\\quad m=0,1,\\dots,L-1,\n$$\n其逆变换为\n$$\na[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}.\n$$\n对于给定的长度 $L$，通过以下方式形成零填充版本 $x_L[n]$ 和 $h_L[n]$\n$$\nx_L[n] = \\begin{cases}\nx[n], 0\\le n\\le N-1\\\\\n0, \\text{otherwise}\n\\end{cases},\\quad\nh_L[n] = \\begin{cases}\nh[n], 0\\le n\\le M-1\\\\\n0, \\text{otherwise}\n\\end{cases},\n$$\n其中 $n\\in\\{0,1,\\dots,L-1\\}$。通过在 DFT 域中使用快速傅里叶变换 (FFT) 进行逐点相乘，来计算长度为 $L$ 的循环卷积\n$$\ny_{\\mathrm{circ},L}[n] = \\sum_{k=0}^{L-1} x_L[k]\\,h_L[(n-k)\\bmod L],\\quad n=0,1,\\dots,L-1。\n$$\n一个经过充分验证的事实是，DFT 的乘积对应于时域中的循环卷积。\n\n为了量化回卷伪影，对每个 $L$ 定义误差\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|,\n$$\n其中 $y_{\\mathrm{lin},L}[n]$ 是线性卷积 $y_{\\mathrm{lin}}[n]$ 的一个版本：如果 $L \\le N+M-1$，则截断为其前 $L$ 个样本；如果 $L \\ge N+M-1$，则用 $L-(N+M-1)$ 个尾随零进行填充。这个共同的比较长度确保了在 $L$ 个样本上的逐点误差。如果 $E(L)$ 显著大于数值舍入误差，则表明存在回卷伪影。\n\n你的任务是：\n- 实现上述定义，并为一组测试填充长度 $L \\in \\{10,12,13,16,64\\}$ 计算 $E(L)$。\n- 解释结果，以评估三种填充策略 $L$：不填充 $L=N$，最小填充 $L=N+M-1$，以及2的幂次填充 $L=\\min\\{2^p: 2^p\\ge N+M-1\\}$，并附加一个超大填充 $L=64$ 以探测数值稳定性。\n\n你的程序应生成单行输出，其中包含按测试集顺序排列的浮点误差的逗号分隔列表，并用方括号括起来，例如 $[e_{10},e_{12},e_{13},e_{16},e_{64}]$，其中每个 $e_L$ 是为该 $L$ 计算出的 $E(L)$。不允许有其他输出。\n\n请确保你的实现是自包含的，不使用用户输入，并遵守上述定义。根据定义，复指数中的角度以弧度为单位。不涉及任何物理单位。目标受众是学习数值方法和科学计算的高年级本科生。", "solution": "该问题要求研究如何使用快速傅里叶变换 (FFT) 计算两个离散时间信号的线性卷积。所考察的核心原理是离散傅里叶变换 (DFT) 的卷积定理，该定理指出，两个序列的循环卷积的 DFT 是它们各自 DFT 的逐点乘积。只有当信号被零填充到足够长的长度以防止时域混叠（也称为回卷误差）时，才能通过此方法正确计算线性卷积。本练习旨在演示和量化这种效应。\n\n过程结构如下：\n\n首先，我们定义输入信号。主信号是一个有限长斜坡序列 $x[n] = n + 1$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$，$N=10$，在其他情况下 $x[n]=0$。第二个信号是一个有限长平均核 $h[n] = \\frac{1}{M}$，其中 $n \\in \\{0, 1, \\dots, M-1\\}$，$M=4$，在其他情况下 $h[n]=0$。\n\n其次，我们计算真实的线性卷积，表示为 $y_{\\mathrm{lin}}[n]$，它作为我们的参考标准。它由卷积和定义：\n$$\ny_{\\mathrm{lin}}[n] = \\sum_{k=-\\infty}^{\\infty} x[k]\\,h[n-k]\n$$\n对于长度为 $N$ 的信号和长度为 $M$ 的核，得到的序列 $y_{\\mathrm{lin}}[n]$ 的长度为 $N+M-1$。在本例中，长度为 $10+4-1=13$。此计算直接在时域中执行。\n\n第三，对于集合 $\\{10, 12, 13, 16, 64\\}$ 中的每个指定变换长度 $L$，我们计算长度为 $L$ 的循环卷积 $y_{\\mathrm{circ},L}[n]$。这是通过利用卷积定理来完成的。步骤如下：\n1. 通过将原始信号 $x[n]$ 和 $h[n]$ 零填充到长度 $L$，创建输入信号的长度为 $L$ 的版本 $x_L[n]$ 和 $h_L[n]$。\n2. 使用 FFT 算法计算填充后信号的长度为 $L$ 的 DFT，$X_L[m] = \\text{DFT}\\{x_L[n]\\}$ 和 $H_L[m] = \\text{DFT}\\{h_L[n]\\}$，以提高效率。DFT 定义为 $A_L[m] = \\sum_{n=0}^{L-1} a[n]\\,e^{-2\\pi i \\frac{mn}{L}}$。\n3. 在频域中执行逐点相乘：$Y_{\\mathrm{circ},L}[m] = X_L[m] \\cdot H_L[m]$。\n4. 计算乘积的逆 DFT，$y_{\\mathrm{circ},L}[n] = \\text{IDFT}\\{Y_{\\mathrm{circ},L}[m]\\}$，以获得时域中的循环卷积结果。逆 DFT 定义为 $a[n] = \\frac{1}{L}\\sum_{m=0}^{L-1} A_L[m]\\,e^{2\\pi i \\frac{mn}{L}}$。\n\n第四，我们量化循环卷积和线性卷积之间的差异。通过对参考标准 $y_{\\mathrm{lin}}[n]$ 进行截断或用零填充以匹配长度 $L$，创建一个比较信号 $y_{\\mathrm{lin},L}[n]$。然后，给定长度 $L$ 的误差定义为两个结果在所有采样点上的最大绝对差：\n$$\nE(L) = \\max_{0\\le n \\le L-1} \\left| y_{\\mathrm{circ},L}[n] - y_{\\mathrm{lin},L}[n] \\right|\n$$\n一个不可忽略的 $E(L)$ 值表明存在回卷伪影。\n\n此分析的理论基础是，当且仅当 $L \\ge N+M-1$ 时，用长度 $L$ 计算的循环卷积等价于线性卷积。\n- 如果 $L  N+M-1$，线性卷积结果的尾部（其延伸到索引 $N+M-2$）会“回卷”并加到循环卷积结果的初始样本上，从而引起混叠。因此，对于 $L=10$ 和 $L=12$，我们预期 $E(L)$ 会显著大于零。\n- 如果 $L \\ge N+M-1$，则有足够的填充来容纳整个线性卷积结果而不会发生回卷。在这种情况下，$y_{\\mathrm{circ},L}[n]$ 将与 $y_{\\mathrm{lin},L}[n]$ 完全相同。因此，对于 $L=13$、$L=16$ 和 $L=64$，我们预期误差 $E(L)$ 将在机器浮点精度的量级上。\n\n选择这些测试用例是为了说明关键的填充策略：$L=10$（填充不足）、$L=13$（最小有效填充）和 $L=16$（2的幂次填充，通常为 FFT 效率而选择）。$L=64$ 的情况进一步证实了超大填充下的稳定性。该实现为这些情况中的每一种计算了 $E(L)$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes convolution error E(L) to demonstrate the effect of zero-padding.\n    \"\"\"\n    # Define signal and kernel parameters as per the problem statement.\n    N = 10\n    M = 4\n\n    # Define the discrete-time signal x[n] = n + 1.\n    x = np.arange(1, N + 1, dtype=float)\n\n    # Define the averaging kernel h[n] = 1/M.\n    h = np.ones(M, dtype=float) / M\n\n    # Compute the ground-truth linear convolution y_lin[n].\n    # The length of the result is N + M - 1 = 13.\n    L_lin = N + M - 1\n    y_lin = np.convolve(x, h)\n\n    # Define the test suite of padding lengths L.\n    test_Ls = [10, 12, 13, 16, 64]\n    \n    results = []\n\n    # Iterate through each padding length L to compute the error E(L).\n    for L in test_Ls:\n        # Step 1: Create the comparison linear convolution y_lin_L[n] of length L.\n        # This is done by truncating or padding y_lin to length L.\n        y_lin_L = np.zeros(L)\n        len_to_copy = min(L, L_lin)\n        y_lin_L[:len_to_copy] = y_lin[:len_to_copy]\n\n        # Step 2: Create zero-padded versions of x and h to length L.\n        x_L = np.zeros(L)\n        x_L[:N] = x\n        \n        h_L = np.zeros(L)\n        h_L[:M] = h\n\n        # Step 3: Compute circular convolution via FFT.\n        # This uses the convolution theorem: IDFT{DFT{x} * DFT{h}}.\n        X_L = np.fft.fft(x_L)\n        H_L = np.fft.fft(h_L)\n        Y_circ_L = X_L * H_L\n        y_circ_L = np.fft.ifft(Y_circ_L)\n\n        # Step 4: Calculate the error E(L) as the maximum absolute difference.\n        # np.abs handles the case where y_circ_L has a tiny imaginary part\n        # due to numerical precision.\n        error = np.max(np.abs(y_circ_L - y_lin_L))\n        results.append(error)\n\n    # Print the results in the specified single-line format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282547"}, {"introduction": "在理解了 FFT 的效率优势和如何用它来执行卷积之后，我们可以将这些知识应用于一个更具体的信号处理任务：降噪。本练习将指导您实现一种常见的降噪策略，即将信号变换到频域，在频域中，信号和噪声的成分通常更容易区分。通过有选择地滤除高频且幅度较小的噪声成分，然后将信号变换回时域，您将构建一个完整的、实用的滤波流程，并量化其性能。[@problem_id:3282556]", "problem": "给定一个有限长度的离散时间实值信号，要求您实现一个基于离散傅里叶变换 (DFT) 的去噪程序。您的程序必须构造合成信号，添加高频干扰，通过 DFT 转换到频域，将小幅值的高频系数置零，进行逆变换，并量化去噪效果。\n\n请基于以下基本定义和事实进行推理。\n\n1. 离散傅里叶变换 (DFT) 和逆离散傅里叶变换 (IDFT)。对于序列 $\\{x_n\\}_{n=0}^{N-1}$，其中 $N \\in \\mathbb{N}$，\n$$\nX_k = \\sum_{n=0}^{N-1} x_n \\, e^{-2\\pi i \\, n k / N}, \\quad k = 0,1,\\dots,N-1,\n$$\n逆变换重构为\n$$\nx_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k \\, e^{2\\pi i \\, n k / N}, \\quad n = 0,1,\\dots,N-1.\n$$\n2. 对于实值时域序列，其 DFT 表现出厄米对称性。在不考虑归一化的情况下，能量在时域和频域之间是守恒的（这是帕塞瓦尔定理 Parseval’s relation 的一个推论），这为在时域中使用均方误差来衡量失真提供了依据。\n\n需要实现的去噪算子。令 $X_k$ 表示长度为 $N$ 的含噪信号的 DFT。定义对称归一化频率半径\n$$\n\\rho(k) = \\frac{\\min\\{k,\\,N-k\\}}{N/2}, \\quad k = 0,1,\\dots,N-1.\n$$\n给定参数 $\\gamma \\in [0,1]$ 和 $\\tau \\in [0,1]$，以及 $M = \\max_{0 \\le k \\le N-1} |X_k|$，将同时满足以下两个条件的每个频率系数置零：\n$$\n\\rho(k) \\ge \\gamma \\quad \\text{和} \\quad |X_k| \\le \\tau \\, M.\n$$\n然后计算修改后频谱的逆 DFT，以获得去噪后的序列。所有三角函数中的角度必须以弧度为单位。\n\n测试用信号模型。对于每个测试用例，纯净信号是与 DFT 频点索引对齐的正弦波的有限和，因此对于振幅 $A_j > 0$ 和整数频点索引 $b_j \\in \\{0,1,\\dots,N-1\\}$，\n$$\nx^{(\\mathrm{clean})}_n = \\sum_{j} A_j \\, \\sin\\!\\left(2\\pi \\, \\frac{b_j}{N} \\, n\\right), \\quad n = 0,1,\\dots,N-1.\n$$\n噪声是以同样方式定义的（具有指定的振幅和频点索引）高频正弦波之和。含噪信号为 $x^{(\\mathrm{noisy})}_n = x^{(\\mathrm{clean})}_n + x^{(\\mathrm{noise})}_n$。\n\n质量度量。令\n$$\n\\mathrm{MSE}_{\\mathrm{before}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noisy})}_n - x^{(\\mathrm{clean})}_n\\right)^2,\n$$\n$$\n\\mathrm{MSE}_{\\mathrm{after}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}_n - x^{(\\mathrm{clean})}_n\\right)^2,\n$$\n其中 $\\hat{x}_n$ 是通过逆 DFT 获得的去噪后序列。为避免在退化情况下出现除以零的错误，定义一个小的正则化项 $\\varepsilon = 10^{-12}$ 并报告改善因子\n$$\nI = \\frac{\\mathrm{MSE}_{\\mathrm{before}} + \\varepsilon}{\\mathrm{MSE}_{\\mathrm{after}} + \\varepsilon}.\n$$\n\n您的任务。实现一个程序，对下述每个测试用例，构造纯净信号和含噪信号，使用提供的 $(\\gamma,\\tau)$ 应用上述指定的去噪算子，计算 $I$，并报告四舍五入到六位小数的结果。\n\n测试套件。使用以下四个用例。在每个用例中，纯净信号的参数均相同，而噪声、阈值和高频参数有所不同。所有振幅和参数均为无量纲。\n\n- 所有用例的纯净信号：$N = 256$，振幅和频点\n  - $(A_1, b_1) = (1.0, 10)$,\n  - $(A_2, b_2) = (0.8, 30)$,\n  - $(A_3, b_3) = (0.6, 50)$.\n\n- 用例 $1$ (理想路径)：噪声振幅和频点\n  - $(0.3, 100)$, $(0.25, 110)$, $(0.1, 90)$,\n  参数为 $\\gamma = 0.7$, $\\tau = 0.5$。\n\n- 用例 $2$ (无噪声边界情况)：无噪声分量，参数为 $\\gamma = 0.7$, $\\tau = 0.5$。\n\n- 用例 $3$ (未被标记为“小”的强高频噪声)：噪声振幅和频点\n  - $(1.2, 120)$, $(0.4, 100)$,\n  参数为 $\\gamma = 0.7$, $\\tau = 0.6$。\n\n- 用例 $4$ (高频阈值过高，接近奈奎斯特频率)：噪声振幅和频点\n  - $(0.3, 100)$, $(0.25, 110)$,\n  参数为 $\\gamma = 0.99$, $\\tau = 0.5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个改善因子，四舍五入到六位小数，并以方括号括起来的逗号分隔列表形式聚合，不含空格。例如：\"[v1,v2,v3,v4]\"。", "solution": "问题陈述经过正式评估，被认定为有效。它在科学上基于数字信号处理的原理，其参数完整且一致，问题设定良好，表述客观。任务是实现一个特定的频域去噪算法，并在一系列明确定义的测试用例上量化其性能。\n\n解决方案通过为每个测试用例实现指定的程序来推进。其核心原理是，由少数主导正弦波组成的信号在频域中具有稀疏表示，而噪声通常分布更广或位于高频区域。该算法试图通过将信号转换到频域，将特定系数置零，再转换回时域来隔离和移除这些噪声分量。\n\n分步程序如下：\n\n1.  **信号合成**：对每个测试用例，我们构造三个长度为 $N=256$ 的离散时间信号，采样索引为 $n = 0, 1, \\dots, N-1$。\n    -   纯净信号 $x^{(\\mathrm{clean})}_n$ 根据公式 $x^{(\\mathrm{clean})}_n = \\sum_{j} A_j \\, \\sin(2\\pi \\frac{b_j}{N} n)$ 生成，使用提供的振幅 $A_j$ 和频点索引 $b_j$。\n    -   噪声信号 $x^{(\\mathrm{noise})}_n$ 使用给定用例指定的振幅和频点参数以类似方式构造。\n    -   待处理信号 $x^{(\\mathrm{noisy})}_n$ 是纯净信号和噪声信号之和：$x^{(\\mathrm{noisy})}_n = x^{(\\mathrm{clean})}_n + x^{(\\mathrm{noise})}_n$。\n\n2.  **频率变换**：使用离散傅里叶变换 (DFT) 将含噪信号转换到频域，得到复值频谱 $X_k$：\n    $$\n    X_k = \\sum_{n=0}^{N-1} x^{(\\mathrm{noisy})}_n \\, e^{-2\\pi i \\, n k / N}, \\quad k = 0,1,\\dots,N-1.\n    $$\n    这在计算上通过快速傅里叶变换 (FFT) 算法实现。\n\n3.  **频域去噪**：去噪直接在复数频谱 $X_k$ 上执行。通过应用阈值规则创建滤波后的频谱 $\\hat{X}_k$。对于每个频率系数 $X_k$，我们评估两个条件：\n    -   **高频条件**：归一化频率半径 $\\rho(k) = \\frac{\\min\\{k, N-k\\}}{N/2}$ 必须大于或等于给定的阈值 $\\gamma$。此条件隔离了远离直流分量 ($k=0$) 的频率。\n    -   **小幅值条件**：系数的幅值 $|X_k|$ 必须小于或等于与整个频谱中的最大幅值 $M = \\max_{j} |X_j|$ 成比例的阈值。条件是 $|X_k| \\le \\tau M$。这旨在保留强的信号分量（即使它们位于高频），同时衰减弱的（假定为噪声的）分量。\n\n    当且仅当两个条件都满足时，在滤波后的频谱 $\\hat{X}_k$ 中将系数 $X_k$ 置零。否则，$\\hat{X}_k = X_k$。\n\n4.  **信号重构**：通过对滤波后的频谱 $\\hat{X}_k$ 应用逆离散傅里叶变换 (IDFT) 获得去噪后的时域信号 $\\hat{x}_n$：\n    $$\n    \\hat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} \\hat{X}_k \\, e^{2\\pi i \\, n k / N}, \\quad n = 0,1,\\dots,N-1.\n    $$\n    由于原始信号 $x^{(\\mathrm{noisy})}_n$ 是实值的，并且滤波规则保持了厄米对称性（如果 $X_k$ 被置零，其共轭对称的对应项 $X_{N-k}$ 也会被置零），因此得到的 $\\hat{x}_n$ 也必须是实数。我们取 IDFT 输出的实部，以舍弃由数值浮点不精确性产生的微小虚部。\n\n5.  **性能评估**：通过比较滤波前后的均方误差 (MSE) 来量化去噪过程的有效性。\n    -   初始误差为 $\\mathrm{MSE}_{\\mathrm{before}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noisy})}_n - x^{(\\mathrm{clean})}_n\\right)^2 = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(x^{(\\mathrm{noise})}_n\\right)^2$。\n    -   去噪后的误差为 $\\mathrm{MSE}_{\\mathrm{after}} = \\frac{1}{N}\\sum_{n=0}^{N-1} \\left(\\hat{x}_n - x^{(\\mathrm{clean})}_n\\right)^2$。\n    -   最终的度量是改善因子 $I$，定义为这些误差的比率，通过一个小的常数 $\\varepsilon = 10^{-12}$进行正则化以确保数值稳定性：\n    $$\n    I = \\frac{\\mathrm{MSE}_{\\mathrm{before}} + \\varepsilon}{\\mathrm{MSE}_{\\mathrm{after}} + \\varepsilon}.\n    $$\n    改善因子 $I > 1$ 表示去噪成功，$I \\approx 1$ 表示没有显著变化，而 $I  1$ 则表示该过程增加的误差多于移除的误差。\n\n将此完整程序应用于提供的四个测试用例中的每一个，并计算和报告由此产生的改善因子。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs signals, applies a DFT-based denoising filter, and computes\n    the performance improvement for a suite of test cases.\n    \"\"\"\n    # Define constants and test parameters from the problem statement.\n    N = 256\n    epsilon = 1e-12\n    \n    clean_components = [\n        (1.0, 10),\n        (0.8, 30),\n        (0.6, 50)\n    ]\n\n    test_suite = [\n        {\n            # Case 1: Standard denoising scenario\n            \"noise_components\": [(0.3, 100), (0.25, 110), (0.1, 90)],\n            \"gamma\": 0.7,\n            \"tau\": 0.5\n        },\n        {\n            # Case 2: No noise, to test filter's effect on clean signal\n            \"noise_components\": [],\n            \"gamma\": 0.7,\n            \"tau\": 0.5\n        },\n        {\n            # Case 3: Strong high-frequency noise that exceeds magnitude threshold\n            \"noise_components\": [(1.2, 120), (0.4, 100)],\n            \"gamma\": 0.7,\n            \"tau\": 0.6\n        },\n        {\n            # Case 4: High-frequency threshold is too restrictive (close to Nyquist)\n            \"noise_components\": [(0.3, 100), (0.25, 110)],\n            \"gamma\": 0.99,\n            \"tau\": 0.5\n        }\n    ]\n\n    results = []\n\n    # Pre-calculate arrays that are common across all test cases for efficiency\n    n = np.arange(N)\n    k_indices = np.arange(N)\n    rho = np.minimum(k_indices, N - k_indices) / (N / 2.0)\n\n    # Generate the clean signal once, as it's the same for all cases\n    x_clean = np.zeros(N, dtype=float)\n    for A, b in clean_components:\n        x_clean += A * np.sin(2 * np.pi * b * n / N)\n\n    for case in test_suite:\n        # Unpack parameters for the current test case\n        noise_components = case['noise_components']\n        gamma = case['gamma']\n        tau = case['tau']\n\n        # Step 1: Synthesize the noise and noisy signals\n        x_noise = np.zeros(N, dtype=float)\n        if noise_components:\n            for A, b in noise_components:\n                x_noise += A * np.sin(2 * np.pi * b * n / N)\n        x_noisy = x_clean + x_noise\n\n        # Calculate the initial Mean Squared Error\n        mse_before = np.mean(x_noise**2)\n\n        # Step 2: Transform to the frequency domain\n        X_noisy = np.fft.fft(x_noisy)\n        M = np.max(np.abs(X_noisy))\n\n        # Step 3: Apply frequency-domain denoising\n        # Identify coefficients that meet both filtering conditions\n        high_freq_mask = rho >= gamma\n        small_mag_mask = np.abs(X_noisy) = tau * M\n        zero_mask = high_freq_mask  small_mag_mask\n\n        # Create the filtered spectrum by setting identified coefficients to zero\n        X_filtered = X_noisy.copy()\n        X_filtered[zero_mask] = 0.0\n\n        # Step 4: Reconstruct the signal via Inverse DFT\n        # Use np.real to discard negligible imaginary parts from numerical error\n        x_denoised = np.real(np.fft.ifft(X_filtered))\n\n        # Step 5: Evaluate performance\n        # Calculate the Mean Squared Error after denoising\n        mse_after = np.mean((x_denoised - x_clean)**2)\n\n        # Compute the regularized improvement factor\n        improvement = (mse_before + epsilon) / (mse_after + epsilon)\n        results.append(f\"{improvement:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3282556"}]}