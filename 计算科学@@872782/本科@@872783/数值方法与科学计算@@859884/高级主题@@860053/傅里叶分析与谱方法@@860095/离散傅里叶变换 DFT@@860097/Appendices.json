{"hands_on_practices": [{"introduction": "理论知识的最佳试金石是动手实践。要真正掌握离散傅里叶变换 (DFT)，最有效的方法莫过于从其基本定义出发，将其应用于一个简单的场景。这个练习将引导你手动计算一个仅包含两个样本点的信号的DFT，通过这个过程，你将直观地理解DFT是如何将一个信号分解为其最基础的频率分量——直流分量和交流分量的。[@problem_id:1759585]", "problem": "一个微机电系统 (MEMS) 加速度计被用来监测一个微型悬臂梁的高频振动。由于硬件限制，数据采集系统在其缓冲区满之前只能从梁的运动中捕获两个连续的位移测量值。这个时域信号是一个包含两个样本的序列，记为 $x[n]$。\n\n测得的两个值为：\n$x[0] = A_0 + A_1$\n$x[1] = A_0 - A_1$\n\n其中，$A_0$ 代表梁的静态平衡位置（直流分量），而 $A_1$ 代表在采样频率下的主导振动模式的振幅。$A_0$ 和 $A_1$ 均为非零实值物理常数。\n\n为分析这个极短信号的频率成分，你需要计算其2点离散傅里叶变换 (DFT)。序列 $x[n]$ 的N点DFT定义为：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-j \\frac{2\\pi}{N} kn\\right) \\quad \\text{for } k = 0, 1, \\dots, N-1$$\n其中 $j$ 是虚数单位，满足 $j^2 = -1$。\n\n求出两个DFT分量 $X[0]$ 和 $X[1]$ 关于常数 $A_0$ 和 $A_1$ 的表达式。将你的最终答案以一个行矩阵的形式呈现，该矩阵按顺序包含 $X[0]$ 和 $X[1]$ 的表达式。", "solution": "给定一个长度为2的序列，其样本为 $x[0]=A_{0}+A_{1}$ 和 $x[1]=A_{0}-A_{1}$，我们需要使用以下公式计算其 $N=2$ 点的DFT\n$$\nX[k]=\\sum_{n=0}^{N-1}x[n]\\exp\\left(-j\\frac{2\\pi}{N}kn\\right),\\quad k\\in\\{0,1\\}.\n$$\n当 $N=2$ 时，该公式变为\n$$\nX[k]=\\sum_{n=0}^{1}x[n]\\exp(-j\\pi kn).\n$$\n\n当 $k=0$ 时，对于 $n=0$ 和 $n=1$，指数因子均为 $\\exp(0)=1$，因此\n$$\nX[0]=x[0]+x[1]=(A_{0}+A_{1})+(A_{0}-A_{1})=2A_{0}.\n$$\n\n当 $k=1$ 时，我们有\n$$\nX[1]=x[0]\\exp(0)+x[1]\\exp(-j\\pi)=x[0]-x[1]=(A_{0}+A_{1})-(A_{0}-A_{1})=2A_{1}.\n$$\n\n因此，按 $(X[0],X[1])$ 顺序排列成行矩阵的两个DFT分量是 $2A_{0}$ 和 $2A_{1}$。", "answer": "$$\\boxed{\\begin{pmatrix}2A_{0}  2A_{1}\\end{pmatrix}}$$", "id": "1759585"}, {"introduction": "卷积定理是信号处理领域的基石，它揭示了时域中的卷积运算（例如滤波）与频域中简单的逐点相乘之间的深刻联系。这个编程练习要求你从第一性原理出发，通过编写代码来数值验证这一重要等价关系。完成这项任务不仅能加深你对卷积定理的理解，还能让你体会到为何将问题转换到频域能带来巨大的计算优势。[@problem_id:3222895]", "problem": "考虑有限长度的复数序列及其离散变换。您将从离散傅里叶变换 (DFT) 和离散傅里叶逆变换 (IDFT) 的定义开始。对于长度为 $N$ 的序列 $x[n]$，其 DFT $X[k]$ 和 IDFT $x[n]$ 由以下基本公式定义：$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad k=0,1,\\dots,N-1,$$ $$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad n=0,1,\\dots,N-1.$$ 两个长度同为 $N$ 的序列 $x[n]$ 和 $y[n]$ 的离散循环卷积定义为 $$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N],\\quad n=0,1,\\dots,N-1.$$ 您的任务是直接根据这些定义实现 DFT 和 IDFT，并根据其定义实现直接循环卷积。仅使用这些基本公式，而不使用任何专门用于变换或卷积的库函数，通过比较两种计算路径来数值验证离散序列的卷积定理的等效性：(i) 时域中的直接循环卷积，以及 (ii) 通过变换到频域，在频域中执行逐元素相乘，然后变换回时域来获得的循环卷积。对于每个测试用例，计算两个结果序列之间最大的逐元素绝对差值，并判断该差值是否小于或等于双精度浮点运算的机器 epsilon。使用复数双精度，并将所有量视为无单位。任何指数参数的角度单位均为弧度。每个测试用例的最终结果必须是一个布尔值，指示数值等效性是否在机器 epsilon 范围内成立。\n\n实现您的程序以运行以下测试套件，其中每个测试用例由 $(N, x, y)$ 给出，$N$ 是共同长度，$x$ 和 $y$ 是序列：\n- 测试 $1$：$N=1$，$x=[\\,3\\,]$，$y=[\\,-2\\,]$。\n- 测试 $2$：$N=2$，$x=[\\,1,\\,2\\,]$，$y=[\\,-1,\\,3\\,]$。\n- 测试 $3$：$N=4$，$x=[\\,1,\\,0,\\,-1,\\,0\\,]$，$y=[\\,0,\\,2,\\,0,\\,-2\\,]$。\n- 测试 $4$：$N=4$，$x=[\\,0,\\,0,\\,0,\\,0\\,]$，$y=[\\,5,\\,-7,\\,13,\\,-11\\,]$。\n- 测试 $5$：$N=4$，$x=[\\,\\mathrm{i},\\,0,\\,-\\mathrm{i},\\,0\\,]$，$y=[\\,2,\\,0,\\,-2,\\,0\\,]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述五个测试的顺序排列结果（例如 $[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_j$ 为 $True$ 或 $False$。", "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n\n问题提供了以下定义、数据和条件：\n- **离散傅里叶变换 (DFT)**，对于长度为 $N$ 的序列 $x[n]$：\n$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad k=0,1,\\dots,N-1$\n- **离散傅里叶逆变换 (IDFT)**，对于长度为 $N$ 的频域序列 $X[k]$：\n$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right),\\quad n=0,1,\\dots,N-1$\n- **离散循环卷积**，对于两个长度同为 $N$ 的序列 $x[n]$ 和 $y[n]$：\n$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N],\\quad n=0,1,\\dots,N-1$\n- **任务**：通过比较两种方法来数值验证卷积定理：\n    1.  `(i)` 时域中的直接循环卷积。\n    2.  `(ii)` 通过 DFT、频域中的逐元素相乘和 IDFT 实现的循环卷积。\n- **比较标准**：两个结果序列之间的最大逐元素绝对差值必须小于或等于双精度浮点运算的机器 epsilon。\n- **数值精度**：使用复数双精度。\n- **单位**：所有量都是无单位的，角度以弧度为单位。\n- **测试套件**：\n    - 测试 $1$：$N=1$，$x=[\\,3\\,]$，$y=[\\,-2\\,]$。\n    - 测试 $2$：$N=2$，$x=[\\,1,\\,2\\,]$，$y=[\\,-1,\\,3\\,]$。\n    - 测试 $3$：$N=4$，$x=[\\,1,\\,0,\\,-1,\\,0\\,]$，$y=[\\,0,\\,2,\\,0,\\,-2\\,]$。\n    - 测试 $4$：$N=4$，$x=[\\,0,\\,0,\\,0,\\,0\\,]$，$y=[\\,5,\\,-7,\\,13,\\,-11\\,]$。\n    - 测试 $5$：$N=4$，$x=[\\,\\mathrm{i},\\,0,\\,-\\mathrm{i},\\,0\\,]$，$y=[\\,2,\\,0,\\,-2,\\,0\\,]$。\n- **输出格式**：一个用方括号括起来的单行逗号分隔布尔结果，例如 $[r_1,r_2,r_3,r_4,r_5]$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估：\n- **科学性**：该问题基于卷积定理，这是离散傅里叶变换的一个基本且经过严格证明的属性。所提供的 DFT、IDFT 和循环卷积的定义是标准且正确的。该问题是一个标准的数值验证任务。\n- **适定性**：问题定义清晰。输入已指定，计算过程有明确描述（或由公式定义），判断结果的标准是精确的。每个测试用例都存在唯一且有意义的布尔结果。\n- **客观性**：语言精确无歧义。指令具体，没有主观解释的余地。\n- **完整性**：提供了所有必要的信息（公式、测试数据、精度要求、输出格式）。问题是自洽的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个在数值方法和数字信号处理领域中适定且科学合理的练习。我将继续提供完整的解决方案。\n\n## 解决方案\n\n目标是数值验证离散有限长度序列的卷积定理。该定理指出，时域中的循环卷积等效于频域中的逐元素相乘。我们将直接根据其数学定义实现 DFT、IDFT 和循环卷积的函数，然后使用它们来比较每个测试用例的两种计算路径。\n\n### 1. 核心函数的实现\n\n我们将编写三个与问题陈述中提供的定义相对应的函数。所有计算都将使用复数双精度数 (`complex128`) 进行。\n\n#### 离散傅里叶变换 (DFT)\n长度为 $N$ 的序列 $x[n]$ 的 DFT 由下式给出：\n$$X[k] = \\sum_{n=0}^{N-1} x[n] \\exp\\left(-\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\n这可以转化为一个具有两个嵌套循环的算法。外层循环遍历频率指数 $k$（从 $0$ 到 $N-1$），内层循环计算时域指数 $n$（从 $0$ 到 $N-1$）的和。对于每对 $(n,k)$，我们计算复指数项，乘以 $x[n]$，并将其加到 $X[k]$ 的运行总和中。\n\n#### 离散傅里叶逆变换 (IDFT)\n$X[k]$ 频域序列的 IDFT 为：\n$$x[n] = \\frac{1}{N}\\sum_{k=0}^{N-1} X[k] \\exp\\left(\\mathrm{i}\\,\\frac{2\\pi}{N} n k\\right)$$\n其实现与 DFT 类似，但指数的符号为正，并且每个 $x[n]$ 的最终总和要乘以一个因子 $1/N$。\n\n#### 直接循环卷积\n两个长度为 $N$ 的序列 $x[n]$ 和 $y[n]$ 的循环卷积为：\n$$z[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\n该算法同样涉及两个嵌套循环。外层循环遍历输出指数 $n$（从 $0$ 到 $N-1$）。内层循环遍历求和指数 $m$（从 $0$ 到 $N-1$）。一个关键步骤是计算序列 $y$ 的索引，即 $(n-m) \\pmod N$。这种模运算确保了卷积的周期性（循环）特性。\n\n### 2. 验证过程\n\n对于每个测试用例 $(N, x, y)$，执行一个双管齐下的计算：\n\n- **路径 (i)：时域中的直接卷积**\n使用输入序列 $x$ 和 $y$ 调用直接循环卷积函数，以产生结果 $z_{\\text{direct}}$。\n$$z_{\\text{direct}}[n] = \\sum_{m=0}^{N-1} x[m]\\,y[(n-m)\\bmod N]$$\n\n- **路径 (ii)：通过频域进行卷积**\n该路径包括三个步骤：\n1.  计算两个输入序列的 DFT：$X = \\text{DFT}(x)$ 和 $Y = \\text{DFT}(y)$。\n2.  对得到的频域序列进行逐元素相乘：$Z[k] = X[k] \\cdot Y[k]$。\n3.  计算乘积序列 $Z$ 的 IDFT，将结果变换回时域：$z_{\\text{freq}} = \\text{IDFT}(Z)$。\n\n### 3. 比较与最终结果\n\n卷积定理保证了，在无限精度算术下，$z_{\\text{direct}}$ 和 $z_{\\text{freq}}$ 将是完全相同的。然而，由于数值计算中的浮点表示和舍入误差，我们预计会出现微小的差异。验证过程包括检查这些差异是否在可接受的容差范围内。\n\n问题将此容差指定为双精度浮点数的机器 epsilon，记为 $\\epsilon$。该值表示在浮点运算中使得 $1.0 + \\epsilon \\neq 1.0$ 成立的最小数。\n\n比较过程形式化如下：\n1.  计算两个结果向量之间的逐元素绝对差：$\\Delta[n] = |z_{\\text{direct}}[n] - z_{\\text{freq}}[n]|$。\n2.  找出该差值向量中的最大值：$\\Delta_{\\max} = \\max_{n} \\Delta[n]$。\n3.  如果这个最大差值小于或等于机器 epsilon，则认为等效性得到验证：$\\Delta_{\\max} \\leq \\epsilon$。\n\n根据此条件为每个测试用例生成一个布尔结果（$True$ 或 $False$）。最终输出将这些布尔值汇总成指定的列表格式。", "answer": "```python\nimport numpy as np\n\ndef dft(x_seq: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the Discrete Fourier Transform (DFT) of a sequence.\n    \n    Args:\n        x_seq: A 1D numpy array of complex numbers representing the sequence.\n        \n    Returns:\n        A 1D numpy array representing the DFT of the sequence.\n    \"\"\"\n    N = len(x_seq)\n    X = np.zeros(N, dtype=np.complex128)\n    for k in range(N):\n        sum_val = np.complex128(0)\n        for n in range(N):\n            angle = -1j * 2 * np.pi * n * k / N\n            sum_val += x_seq[n] * np.exp(angle)\n        X[k] = sum_val\n    return X\n\ndef idft(X_seq: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the Inverse Discrete Fourier Transform (IDFT) of a sequence.\n    \n    Args:\n        X_seq: A 1D numpy array of complex numbers representing the frequency-domain sequence.\n        \n    Returns:\n        A 1D numpy array representing the IDFT of the sequence.\n    \"\"\"\n    N = len(X_seq)\n    x = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for k in range(N):\n            angle = 1j * 2 * np.pi * n * k / N\n            sum_val += X_seq[k] * np.exp(angle)\n        x[n] = sum_val / N\n    return x\n\ndef circular_conv(x_seq: np.ndarray, y_seq: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the direct circular convolution of two sequences.\n    \n    Args:\n        x_seq: The first 1D numpy array of complex numbers.\n        y_seq: The second 1D numpy array of complex numbers.\n        \n    Returns:\n        A 1D numpy array representing the circular convolution of the two sequences.\n    \"\"\"\n    N = len(x_seq)\n    z = np.zeros(N, dtype=np.complex128)\n    for n in range(N):\n        sum_val = np.complex128(0)\n        for m in range(N):\n            y_index = (n - m) % N\n            sum_val += x_seq[m] * y_seq[y_index]\n        z[n] = sum_val\n    return z\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the convolution theorem and prints the results.\n    \"\"\"\n    test_cases = [\n        (1, [3], [-2]),\n        (2, [1, 2], [-1, 3]),\n        (4, [1, 0, -1, 0], [0, 2, 0, -2]),\n        (4, [0, 0, 0, 0], [5, -7, 13, -11]),\n        (4, [1j, 0, -1j, 0], [2, 0, -2, 0])\n    ]\n\n    results = []\n    machine_epsilon = np.finfo(np.float64).eps\n\n    for N, x_list, y_list in test_cases:\n        x = np.array(x_list, dtype=np.complex128)\n        y = np.array(y_list, dtype=np.complex128)\n\n        # Route (i): Direct circular convolution\n        z_direct = circular_conv(x, y)\n\n        # Route (ii): Convolution via frequency domain\n        X = dft(x)\n        Y = dft(y)\n        Z = X * Y\n        z_freq = idft(Z)\n\n        # Compare the two results\n        max_abs_diff = np.max(np.abs(z_direct - z_freq))\n        \n        is_equivalent = max_abs_diff = machine_epsilon\n        results.append(is_equivalent)\n\n    # Print results in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3222895"}, {"introduction": "离散傅里叶变换在理论上假设信号是无限周期的，但这在现实世界中几乎从不成立，这种不匹配导致了一种被称为“谱泄漏”的分析伪影。本练习将引导你探索如何使用“加窗”技术来抑制谱泄漏，并揭示在频谱分析中一个无法回避的基本权衡：频率分辨率与幅度精度之间的取舍。掌握这一概念对于从真实数据中获取有意义的频谱至关重要。[@problem_id:3222838]", "problem": "考虑一个实值离散时间信号，该信号由两个归一化频率非常接近的正弦波组成。设 $x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$，对于 $n = 0, 1, \\dots, N-1$，其中 $f_1$ 和 $f_2$ 的单位是周/采样点（无量纲），并且正弦波的参数使用弧度。您将从频谱泄漏和双音调可分辨性的角度，分析加窗对离散傅里叶变换 (DFT) 的影响。\n\n在您的推理和算法设计中，请使用以下基本依据：\n\n- 长度为 $N$ 的序列 $y[n]$ 的离散傅里叶变换 (DFT) 定义为 $Y[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$，对于 $k = 0, 1, \\dots, N-1$，其中 $j$ 是虚数单位。\n- 时域中的加窗操作是将信号乘以一个窗函数 $w[n]$，这对应于频域中的卷积：如果 $y[n] = x[n] w[n]$，那么 $Y[k]$ 是 $x[n]$ 的频谱与 $w[n]$ 的频谱的采样卷积。当窗函数的频谱具有非零旁瓣时，这会将能量扩散到其他 DFT 频点上。\n- 使用两种窗函数：\n  - 矩形窗，定义为 $w_\\mathrm{rect}[n] = 1$，对于 $0 \\le n \\le N-1$。\n  - Hann 窗，定义为 $w_\\mathrm{Hann}[n] = \\tfrac{1}{2}\\left(1 - \\cos\\left(\\tfrac{2\\pi n}{N-1}\\right)\\right)$，对于 $0 \\le n \\le N-1$。\n\n定义以下量化指标：\n\n1. 给定窗函数 $w$ 的频谱泄漏比：\n   - 计算加窗信号 $x[n] w[n]$ 的 DFT $X_w[k]$ 和功率谱 $P_w[k] = |X_w[k]|^2$，对于 $k = 0, 1, \\dots, N-1$。\n   - 对于每个正弦波 $f_i$（其中 $i \\in \\{1,2\\}$），找到其最近的正频率 DFT 频点索引 $k_i = \\mathrm{round}(f_i N)$ 和对应的负频率索引 $k_i^- = (N - k_i) \\bmod N$。\n   - 对于这两个索引（正频率和负频率），通过在索引周围的一个小邻域内搜索 $P_w[k]$ 的局部最大值来精化峰值位置。设精化后的峰值索引为 $k_i^{(+)}$ 和 $k_i^{(-)}$。\n   - 定义以频点数为单位的主瓣半宽度为 $M_w$，对于矩形窗，$M_\\mathrm{rect} = 1$，对于 Hann 窗，$M_\\mathrm{Hann} = 2$。构建闭合索引区间 $[k_i^{(+)} - M_w, \\, k_i^{(+)} + M_w]$ 和 $[k_i^{(-)} - M_w, \\, k_i^{(-)} + M_w]$（对于 $i=1,2$）的并集，裁剪到有效索引范围 $\\{0,1,\\dots,N-1\\}$ 内，并合并任何重叠部分。\n   - 设 $E_\\mathrm{main}(w)$ 为这些区间并集上 $P_w[k]$ 的总和，设 $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$ 为总频谱能量。泄漏比为 $\\mathrm{LR}(w) = \\dfrac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$，该值为无量纲。\n\n2. 给定窗函数 $w$ 的双音调可分辨性判据：\n   - 将注意力限制在正频率半谱索引 $k \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ 上。\n   - 使用上面找到的精化峰值索引 $k_1^{(+)}$ 和 $k_2^{(+)}$，检查它们之间是否至少存在一个严格位于两者之间的频点。如果没有，则它们未被分辨。\n   - 设 $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ 和 $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$。计算谷底功率 $V = \\min\\{P_w[k] : k_\\mathrm{low}  k  k_\\mathrm{high}\\}$，以及较弱峰值功率 $P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$。\n   - 使用阈值参数 $\\alpha = 0.5$，如果 $V  \\alpha \\, P_\\mathrm{weak}$，则声明音调被分辨；否则，声明它们未被分辨。将此结果输出为布尔值。\n\n您的程序必须精确实现这些定义，并评估以下测试套件。所有频率 $f$ 均以周/采样点为单位进行归一化，正弦波参数中的所有角度均以弧度为单位。输出为指定的无量纲浮点数或布尔值。\n\n测试套件参数集 $(N, f_1, f_2, A_1, A_2)$：\n\n- 情况 1 (一般栅外频率，频率接近): $(1024, \\, 0.100, \\, 0.100 + \\tfrac{1.5}{1024}, \\, 1.0, \\, 1.0)$\n- 情况 2 (精确栅上频率，相邻频点): $(1024, \\, \\tfrac{100}{1024}, \\, \\tfrac{102}{1024}, \\, 1.0, \\, 1.0)$\n- 情况 3 (亚频点间隔): $(1024, \\, 0.200, \\, 0.200 + \\tfrac{0.6}{1024}, \\, 1.0, \\, 1.0)$\n- 情况 4 (不等幅值，较高 $N$ 值下的单频点间隔): $(2048, \\, 0.123, \\, 0.123 + \\tfrac{1}{2048}, \\, 1.0, \\, 0.2)$\n\n对于每个测试用例，计算并返回一个包含四个元素的列表：$\\mathrm{LR}(\\mathrm{rect})$（浮点数），$\\mathrm{LR}(\\mathrm{Hann})$（浮点数），$\\mathrm{R}(\\mathrm{rect})$（布尔值）和 $\\mathrm{R}(\\mathrm{Hann})$（布尔值）。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果。结果是一个用方括号括起来的逗号分隔列表，每个测试用例的结果本身也是一个按上述顺序排列的列表。例如，输出应类似于 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，不含任何附加文本。", "solution": "问题陈述已经过仔细审查，并被确定为**有效**。它在科学上基于数字信号处理的原理，问题提出得当，包含了所有必要的数据和定义，并且表述客观。任务是分析双音调信号在不同窗函数下的频谱特性，这是数值方法中的一个标准且信息丰富的练习。因此，我们可以着手解决该问题。\n\n这个问题的核心在于加窗操作引入的频谱分析中的基本权衡。有限长度信号的离散傅里叶变换 (DFT) 内在地假设信号以其长度 $N$ 为周期。如果信号的频率不是基本频率分辨率 $\\frac{1}{N}$ 的整数倍，就会发生一种称为频谱泄漏的现象。这等效于将无限时长的信号乘以一个矩形窗，该窗函数具有类似 sinc 函数的频谱和高旁瓣。这些旁瓣将信号真实频率分量的能量扩散到所有其他 DFT 频点上。\n\n除矩形窗外的其他窗函数旨在通过使信号在其端点处平滑地衰减到零来减轻这种泄漏。这会降低频谱的旁瓣，但代价是加宽了主瓣。Hann 窗是一个经典的例子：它提供的旁瓣远低于矩形窗，但其主瓣大约是矩形窗的两倍宽。这导致了一个直接的权衡：更高的幅值精度和更少的泄漏（更适合检测强信号附近的弱信号）与更低的频率分辨率（更难区分两个频率相近的音调）。\n\n我们的算法将通过实现两个指定的指标来量化给定测试用例中的这种权衡：频谱泄漏比 ($\\mathrm{LR}$) 和双音调可分辨性判据 ($\\mathrm{R}$)。\n\n每个测试用例的算法流程如下：\n\n1.  **信号生成**：对于给定的参数集 $(N, f_1, f_2, A_1, A_2)$，根据模型生成离散时间信号 $x[n]$，其中 $n = 0, 1, \\dots, N-1$：\n    $$x[n] = A_1 \\sin(2\\pi f_1 n) + A_2 \\sin(2\\pi f_2 n)$$\n    对两种指定的窗函数重复此过程。\n\n2.  **加窗与 DFT**：\n    - 将信号 $x[n]$ 与所选窗函数 $w[n]$ 进行逐元素相乘以产生加窗信号 $y[n] = x[n] w[n]$。两种窗函数是：\n      - 矩形窗: $w_\\mathrm{rect}[n] = 1$\n      - Hann 窗: $w_\\mathrm{Hann}[n] = \\frac{1}{2}\\left(1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right)\\right)$\n    - 使用以下公式计算加窗信号的 $N$ 点 DFT $X_w[k]$：\n      $$X_w[k] = \\sum_{n=0}^{N-1} y[n] e^{-j 2\\pi k n / N}$$\n      其中 $j$ 是虚数单位。然后计算功率谱为 $P_w[k] = |X_w[k]|^2$。\n\n3.  **频谱泄漏比 ($\\mathrm{LR}$) 计算**：\n    - 对于每个频率分量 $f_i$（其中 $i \\in \\{1, 2\\}$），其在频谱正半部分和负半部分的预期频点位置分别估计为 $k_i = \\mathrm{round}(f_i N)$ 和 $k_i^- = (N - k_i) \\bmod N$。\n    - 通过在每个估计位置周围 $\\pm 2$ 个频点的小邻域内搜索功率谱 $P_w[k]$ 的局部最大值来精化这些估计位置。这样可以得到精化后的峰值索引 $\\{ k_1^{(+)}, k_1^{(-)}, k_2^{(+)}, k_2^{(-)} \\}$。\n    - 主瓣能量 $E_\\mathrm{main}(w)$ 是通过对这四个精化峰值周围定义的区间内的功率谱值求和来计算的。区间为 $[k_\\mathrm{peak} - M_w, k_\\mathrm{peak} + M_w]$，其中主瓣半宽度 $M_w$ 对于矩形窗为 $M_\\mathrm{rect} = 1$，对于 Hann 窗为 $M_\\mathrm{Hann} = 2$。为了处理来自两个正弦波的频谱分量和潜在的重叠，将这四个区间中所有频点的并集形成，并将索引裁剪到有效范围 $[0, N-1]$ 内。\n    - 同时计算总能量 $E_\\mathrm{tot}(w) = \\sum_{k=0}^{N-1} P_w[k]$。\n    - 泄漏比由下式给出：\n      $$\\mathrm{LR}(w) = \\frac{E_\\mathrm{tot}(w) - E_\\mathrm{main}(w)}{E_\\mathrm{tot}(w)}$$\n      该值表示“泄漏”到定义的主瓣之外的总能量的分数。\n\n4.  **双音调可分辨性 ($\\mathrm{R}$) 计算**：\n    - 该指标关注正频率谱，$k \\in \\{0, 1, \\dots, \\lfloor N/2 \\rfloor\\}$，使用精化后的正频率峰值 $k_1^{(+)}$ 和 $k_2^{(+)}$。\n    - 设 $k_\\mathrm{low} = \\min(k_1^{(+)}, k_2^{(+)})$ 和 $k_\\mathrm{high} = \\max(k_1^{(+)}, k_2^{(+)})$。\n    - 如果两个峰值之间没有严格位于两者之间的 DFT 频点，即如果 $k_\\mathrm{high} \\le k_\\mathrm{low} + 1$，则认为音调未被分辨。\n    - 如果存在间隙，则找到峰值之间谷底的最小功率：$V = \\min\\{P_w[k] \\mid k_\\mathrm{low}  k  k_\\mathrm{high}\\}$。\n    - 同时确定两个峰值中较弱者的功率：$P_\\mathrm{weak} = \\min(P_w[k_1^{(+)}], P_w[k_2^{(+)}])$。\n    - 如果谷底相对于较弱峰值足够深，即满足以下条件，则声明音调被分辨，使用给定的阈值 $\\alpha = 0.5$：\n      $$V  \\alpha \\, P_\\mathrm{weak}$$\n      结果是一个布尔值（True 表示已分辨，False 表示未分辨）。\n\n通过将此完整流程应用于每种窗类型的每个测试用例，我们生成所需的四个指标集：$\\mathrm{LR}(\\mathrm{rect})$、$\\mathrm{LR}(\\mathrm{Hann})$、$\\mathrm{R}(\\mathrm{rect})$ 和 $\\mathrm{R}(\\mathrm{Hann})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the DFT windowing analysis problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General off-bin, closely spaced\n        (1024, 0.100, 0.100 + 1.5/1024, 1.0, 1.0),\n        # Case 2: Exact bins, adjacent bins\n        (1024, 100/1024, 102/1024, 1.0, 1.0),\n        # Case 3: Sub-bin spacing\n        (1024, 0.200, 0.200 + 0.6/1024, 1.0, 1.0),\n        # Case 4: Unequal amplitudes, one-bin spacing at higher N\n        (2048, 0.123, 0.123 + 1/2048, 1.0, 0.2),\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        N, f1, f2, A1, A2 = case\n        \n        # Generate time vector and signal\n        n = np.arange(N)\n        x = A1 * np.sin(2 * np.pi * f1 * n) + A2 * np.sin(2 * np.pi * f2 * n)\n        \n        # Define window parameters\n        window_params = {\n            'rect': {'func': np.ones(N), 'M_w': 1},\n            'hann': {'func': 0.5 * (1 - np.cos(2 * np.pi * n / (N - 1))), 'M_w': 2}\n        }\n        \n        case_results = []\n\n        for name in ['rect', 'hann']:\n            params = window_params[name]\n            w = params['func']\n            M_w = params['M_w']\n            \n            # Apply window\n            y = x * w\n            \n            # Compute DFT and power spectrum\n            X_w = np.fft.fft(y)\n            P_w = np.abs(X_w)**2\n            \n            # --- METRIC CALCULATIONS ---\n            \n            def find_peak(k_est, P, search_radius=2):\n                \"\"\"Finds the index of the local maximum around an estimated bin.\"\"\"\n                start = max(0, k_est - search_radius)\n                end = min(len(P), k_est + search_radius + 1)\n                \n                # Check for empty search range\n                if start >= end:\n                    return k_est\n                \n                local_P = P[start:end]\n                local_max_idx = np.argmax(local_P)\n                return start + local_max_idx\n\n            # Estimate initial bin locations\n            k1_est = int(np.round(f1 * N))\n            k2_est = int(np.round(f2 * N))\n            \n            # Refine peak locations for positive and negative frequencies\n            k1_p = find_peak(k1_est, P_w)\n            k2_p = find_peak(k2_est, P_w)\n            k1_n = find_peak((N - k1_est) % N, P_w)\n            k2_n = find_peak((N - k2_est) % N, P_w)\n            \n            # --- Spectral Leakage Ratio (LR) ---\n            \n            refined_peak_indices = {k1_p, k1_n, k2_p, k2_n}\n            main_lobe_indices = set()\n            for k_peak in refined_peak_indices:\n                for d in range(-M_w, M_w + 1):\n                    idx = k_peak + d\n                    if 0 = idx  N:\n                        main_lobe_indices.add(idx)\n\n            E_main = np.sum(P_w[list(main_lobe_indices)])\n            E_tot = np.sum(P_w)\n            \n            lr = (E_tot - E_main) / E_tot if E_tot > 0 else 0.0\n            \n            # --- Two-Tone Resolvability (R) ---\n            \n            k_low = min(k1_p, k2_p)\n            k_high = max(k1_p, k2_p)\n            \n            resolved = False\n            # Check for at least one bin strictly between peaks\n            if k_high > k_low + 1:\n                V = np.min(P_w[k_low + 1 : k_high])\n                P_weak = min(P_w[k_low], P_w[k_high])\n                alpha = 0.5\n                if P_weak > 0:\n                    if V  alpha * P_weak:\n                        resolved = True\n            \n            # Store results for this window\n            case_results.extend([lr, resolved])\n\n        # Arrange results in the specified order: LR(rect), LR(hann), R(rect), R(hann)\n        final_case_results = [case_results[0], case_results[2], case_results[1], case_results[3]]\n        all_results.append(final_case_results)\n\n    # Final print statement in the exact required format.\n    formatted_results = []\n    for res_list in all_results:\n        # Format: float, float, bool, bool\n        r1 = f\"{res_list[0]:.6f}\"\n        r2 = f\"{res_list[1]:.6f}\"\n        r3 = str(res_list[2])\n        r4 = str(res_list[3])\n        formatted_results.append(f\"[{r1},{r2},{r3},{r4}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3222838"}]}