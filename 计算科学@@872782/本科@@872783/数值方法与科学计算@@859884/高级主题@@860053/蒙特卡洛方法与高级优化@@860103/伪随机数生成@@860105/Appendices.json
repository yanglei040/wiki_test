{"hands_on_practices": [{"introduction": "线性同余生成器（LCG）是最简单且历史上最重要的伪随机数生成器之一。它们基于简单的模运算递推关系，其确定性特质令人惊讶地能产生完美的一维均匀性。这项动手实践 [@problem_id:3264088] 挑战你进行更深入的探索，通过考察连续数对之间的关系，揭示困扰简单LCG的著名晶格结构，为“为何一维测试不足以评估生成器质量”提供了鲜明的视觉教训。", "problem": "考虑由整数模剩余类上的确定性映射产生的序列，以及它们在归一化到单位区间后的行为。设 $m \\in \\mathbb{N}$，并设 $(X_i)_{i \\ge 0}$ 是一个序列，其中 $X_i \\in \\{0,1,\\dots,m-1\\}$，其归一化形式为 $U_i = X_i / m \\in [0,1)$。一维边际均匀性在离散情况下定义为在一个完整周期内恰好访问每个剩余类一次，而二维结构则通过连续对 $(U_i, U_{i+1})$ 的几何形状进行评估。\n\n从模算术和剩余类双射的基本定义出发，设计并实现能够产生具有以下性质序列的生成器：\n- 一个生成器，其在 $\\{0,1,\\dots,m-1\\}$ 上的一维边际分布是完全均匀的，即在一个周期内每个剩余类都恰好出现一次。\n- 一个生成器，其连续对 $(X_i, X_{i+1})$ 满足线性模关系，从而其归一化后的 $(U_i,U_{i+1})$ 在二维空间中展现出易于检测的几何结构。\n\n您的程序必须：\n1. 生成每个测试用例所需的序列。\n2. 为每个测试用例计算以下定量指标，所有指标均基于归一化对 $(U_i, U_{i+1})$：\n    - 一维均匀性比率，定义为 $|\\mathrm{VisitedStates}| / m$，其中 $|\\mathrm{VisitedStates}|$ 是在一个检测到的周期内观察到的 $\\{X_i\\}$ 中不同值的数量。该比率为 $[0,1]$ 内的实数。\n    - 在 $[0,1) \\times [0,1)$ 上大小为 $G \\times G$ 的均匀网格的占据数，定义为由点对 $(U_i, U_{i+1})$ 命中的不同网格单元的数量，单元格索引为 $(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)$。此计数是一个整数。\n    - 点云对 $(U_i,U_{i+1})$ 各分量之间的皮尔逊相关系数，计算时使用所有可用的点对。该系数是一个实数。\n    - 模差 $(X_{i+1} - X_i) \\bmod m$ 在宽度为 $m/G$ 的粗分箱下的不同分箱数量，即 $\\left\\lfloor \\frac{(X_{i+1} - X_i) \\bmod m}{m/G} \\right\\rfloor$ 的不同值的计数。此计数是一个整数。\n\n仅使用模算术和剩余类双射的定义作为基本基础。不要依赖任何未经证明的快捷公式。您必须从第一性原理出发，推导为什么一维边际分布可以做到完全均匀，同时二维连续对图又可以显示出可见的结构。\n\n实现以下测试套件，其设计旨在覆盖一般情况、边界情况和比较情况。对于所有情况，使用 $G = 64$：\n- 情况 A (加法同余，完整周期)：模数 $m = 4096$，增量 $c = 5$，种子 $X_0 = 0$。通过逐次加 $c$ 并模 $m$ 来生成序列，直到状态重复，然后在第一次重复时停止。\n- 情况 B (加法同余，短周期边界情况)：模数 $m = 4096$，增量 $c = 512$，种子 $X_0 = 0$。通过逐次加法并模 $m$ 来生成序列，直到状态重复，然后停止。\n- 情况 C (线性同余，一般情况)：模数 $m = 4096$，乘数 $a = 5$，增量 $c = 1$，种子 $X_0 = 1$。通过重复应用线性映射并模 $m$ 来生成序列，直到状态重复，然后停止。\n- 情况 D (独立均匀基准)：模数 $m = 4096$，种子 $s = 12345$。生成 $m$ 个独立的样本 $U_i \\in [0,1)$，设置 $X_i = \\lfloor m U_i \\rfloor$，并使用前 $m$ 个值，不进行周期检测。\n\n对于每种情况，使用所有可用的连续对 $(U_i, U_{i+1})$ 计算上述四个指标，其中索引 $i$ 遍历该情况生成的序列位置，并在不环绕配对时在最后一个元素前停止。所有量均表示为无单位的纯数字。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，每个情况的结果是一个四元素列表，顺序为：[均匀性比率, 占据数, 相关系数, 差值分箱数]。例如，输出应类似于 $[[r_1,o_1,\\rho_1,b_1],[r_2,o_2,\\rho_2,b_2],[r_3,o_3,\\rho_3,b_3],[r_4,o_4,\\rho_4,b_4]]$，不含多余的空格或文本。", "solution": "该问题要求分析和实现通过模算术生成的确定性序列，这种序列常用于伪随机数生成。任务的核心是从第一性原理出发，理解这些序列的性质，特别是一维均匀性和二维结构。\n\n## 基本原理\n\n### 模算术和线性同余生成器（LCG）\n序列 $(X_i)_{i \\ge 0}$ 在模 $m$ 的剩余类集合 $\\mathbb{Z}_m = \\{0, 1, \\dots, m-1\\}$ 内生成。这类生成器中被广泛研究的一类是线性同余生成器 (LCG)，由以下递推关系定义：\n$$X_{i+1} = (a X_i + c) \\bmod m$$\n其中 $m  0$ 是模数，$a$ 是乘数，$c$ 是增量，$X_0$ 是种子。当 $a=1$ 时，该生成器称为加法同余生成器 (ACG)。归一化序列由 $U_i = X_i/m \\in [0, 1)$ 给出。\n\n### 一维均匀性与周期性\n一个好的生成器的一个关键特性是长周期。周期是满足对所有 $i$ 都有 $X_{i+p} = X_i$ 的最小正整数 $p$。为了使生成器最大程度地有用，我们希望周期尽可能大。一个 LCG 具有 $m$ 的完整周期，当且仅当它在重复之前恰好生成 $\\{0, 1, \\dots, m-1\\}$ 中的每个整数一次。这赋予了其完美的一维边际均匀性，意味着均匀性比率 $|\\mathrm{VisitedStates}|/m$ 恰好为 $1$。\n\n达到完整周期的条件取决于参数 $a$、$c$ 和 $m$。\n1.  **对于 ACG ($a=1$):** 递推关系为 $X_{i+1} = (X_i + c) \\bmod m$。状态序列是模 $m$ 的一个算术级数。该序列具有完整周期 $m$ 的充要条件是增量 $c$ 是加法群 $\\mathbb{Z}_m$ 的一个生成元，这要求 $c$ 与 $m$ 互质。即 $\\gcd(c, m) = 1$。如果 $\\gcd(c, m) = d  1$，则周期缩短为 $m/d$。\n\n2.  **对于 LCG ($a1$):** 当模数 $m$ 是 2 的幂时，比如 $m = 2^k$ 且 $k \\ge 2$，著名的 Hull-Dobell 定理指出，LCG 具有完整周期 $m$ 的充要条件是：\n    -   $c$ 是奇数 (即 $\\gcd(c, m) = 1$）。\n    -   $a \\equiv 1 \\pmod 4$。\n\n### 二维结构\nLCG 的确定性性质为连续对 $(X_i, X_{i+1})$ 施加了刚性结构。对 LCG 递推关系进行归一化，我们得到：\n$$m U_{i+1} = (a m U_i + c) \\pmod m$$\n两边同除以 $m$ 得到：\n$$U_{i+1} = (a U_i + c/m) \\pmod 1$$\n这个方程揭示了所有连续对 $(U_i, U_{i+1})$ 都位于有限数量的平行超平面上。在二维空间中，这些就是直线。具体来说，这些点落在由 $y = ax + c/m - k$ 定义的线段上，其中 $k$ 为整数，使得该直线与单位正方形 $[0,1) \\times [0,1)$ 相交。这种固有的晶格结构是一种“易于检测的几何结构”，也是 LCG 的一个众所周知弱点，而指定的指标正是为了量化这一点而设计的。\n\n## 测试用例分析\n\n对于所有情况，用于计算占据数指标的网格大小为 $G=64$。\n\n**情况 A：加法同余，完整周期**\n($m=4096$, $c=5$, $X_0=0$, $a=1$)\n-   **均匀性：** $m=4096=2^{12}$ 且 $c=5$。因为 $5$ 是一个奇数，它与 2 的幂没有公因子，所以 $\\gcd(5, 4096)=1$。该 ACG 具有 $m=4096$ 的完整周期。序列会恰好访问一次 $\\{0, \\dots, 4095\\}$ 中的每个状态。均匀性比率为 $4096/4096 = 1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 满足 $U_{i+1} = (U_i + 5/4096) \\pmod 1$。这些点位于两条平行的直线上。预计会存在强正相关。模差 $(X_{i+1} - X_i) \\bmod m$ 恒为 $5$。这个单一值落入分箱 $\\lfloor 5 / (4096/64) \\rfloor = \\lfloor 5/64 \\rfloor = 0$ 中。因此，差值分箱数为 $1$。\n\n**情况 B：加法同余，短周期**\n($m=4096$, $c=512$, $X_0=0$, $a=1$)\n-   **均匀性：** 这里，$c=512=2^9$。最大公约数为 $\\gcd(512, 4096) = 512$。周期为 $m/\\gcd(c,m) = 4096/512 = 8$。该序列只访问 8 个状态。均匀性比率为 $8/4096 = 1/512$。\n-   **结构：** 这 8 个状态都是 512 的倍数。点对 $(U_i, U_{i+1})$ 位于单一直线 $y=x+1/8$ 上。相关性将是完美的。模差恒为 $512$，落入分箱 $\\lfloor 512 / 64 \\rfloor = 8$ 中。差值分箱数为 $1$。\n\n**情况 C：线性同余，一般情况**\n($m=4096$, $a=5$, $c=1$, $X_0=1$)\n-   **均匀性：** 满足 Hull-Dobell 条件：$m=2^{12}$，$c=1$ 是奇数，且 $a=5 \\equiv 1 \\pmod 4$。该 LCG 具有 $m=4096$ 的完整周期。均匀性比率为 $1.0$。\n-   **结构：** 点对 $(U_i, U_{i+1})$ 位于由 $U_{i+1} = (5 U_i + 1/4096) \\pmod 1$ 定义的 $a=5$ 条平行线上。模差为 $(X_{i+1} - X_i) \\bmod m = (4X_i + 1) \\bmod m$。由于 $X_i$ 遍历所有剩余类，且 $\\gcd(4, 4096)=4$，差值会取 $4096/4=1024$ 个不同的值，所有这些值都与 $1 \\pmod 4$ 同余。这些值为 $\\{1, 5, 9, \\dots\\}$。这 1024 个值在 $[0, 4096)$ 上分布良好，并将落入所有 $G=64$ 个宽度为 $m/G=64$ 的分箱中。差值分箱数将为 $64$。\n\n**情况 D：独立均匀基准**\n($m=4096$, $s=12345$)\n-   此情况作为“良好”随机性的基准，其中连续值是独立的。\n-   **均匀性：** 抽取 $m=4096$ 个值。访问到的唯一状态数与优惠券收集者问题有关。唯一值的期望数量是 $m(1-(1-1/m)^m) \\approx m(1-1/e) \\approx 0.632m$。所以比率应该接近 $0.632$。\n-   **结构：** 对于独立的点对 $(U_i, U_{i+1})$，这些点应均匀散布在单位正方形上，没有可辨别的线性结构。皮尔逊相关系数应接近 $0$。这些点应占据许多网格单元，其期望计数与均匀性结果相似，约为 $m(1-e^{-1}) \\approx 2588$。模差 $(X_{i+1}-X_i)\\bmod m$ 将在 $\\{0, \\dots, m-1\\}$ 上近似均匀分布。对于 4095 个这样的差值，极有可能所有 64 个分箱都会被访问到。差值分箱数应为 $64$。\n\n## 定量指标\n问题定义了需要计算的四个指标：\n1.  **均匀性比率：** $R_U = \\frac{|\\{X_i\\}|}{m}$，其中 $|\\{X_i\\}|$ 是一个周期内访问到的不同状态的数量。\n2.  **占据数：** $N_{occ} = |\\{(\\lfloor G U_i \\rfloor, \\lfloor G U_{i+1} \\rfloor)\\}|$，即点对 $(U_i, U_{i+1})$ 在一个 $G \\times G$ 网格中命中的唯一单元格数量。\n3.  **皮尔逊相关系数：** $\\rho(U_i, U_{i+1}) = \\frac{\\mathrm{Cov}(U_i, U_{i+1})}{\\sigma_{U_i}\\sigma_{U_{i+1}}}$，衡量连续归一化值之间的线性相关性。\n4.  **差值分箱数：** $N_{db} = |\\{\\lfloor \\frac{(X_{i+1}-X_i)\\bmod m}{m/G} \\rfloor\\}|$，即模差所命中的不同粗分箱的数量。\n\n现在，实现将遵循这些原理来生成序列，并为每种情况计算指定的指标。", "answer": "```python\nimport numpy as np\n\ndef generate_sequence_lcg(m, a, c, x0):\n    \"\"\"\n    Generates a sequence from a Linear Congruential Generator (LCG)\n    X_{i+1} = (a * X_i + c) mod m, until the first state repeats.\n    \"\"\"\n    seq = []\n    # Use a dictionary for fast lookups and to store the first occurrence index.\n    visited = {}\n    x = x0\n    i = 0\n    while x not in visited:\n        visited[x] = i\n        seq.append(x)\n        x = (a * x + c) % m\n        i += 1\n    return np.array(seq, dtype=np.int64)\n\ndef calculate_metrics(X, m, G):\n    \"\"\"\n    Calculates the four specified metrics for a given sequence X.\n    \"\"\"\n    # 1. One-dimensional uniformity ratio\n    # Using np.unique is a robust way to count distinct elements.\n    num_distinct_states = len(np.unique(X))\n    uniformity_ratio = num_distinct_states / m\n\n    if len(X)  2:\n        # Cannot compute pair-based metrics if sequence length is less than 2.\n        return [uniformity_ratio, 0, 0.0, 0]\n\n    # Create consecutive pairs from the sequence\n    X_i = X[:-1]\n    X_ip1 = X[1:]\n\n    # Normalize pairs to the unit interval [0, 1)\n    U_i = X_i / m\n    U_ip1 = X_ip1 / m\n\n    # 2. Occupancy count of a uniform grid\n    grid_indices = np.floor(np.vstack([U_i * G, U_ip1 * G]).T).astype(np.int32)\n    # Using a set of tuples is an efficient way to count unique 2D integer points.\n    unique_cells = set(map(tuple, grid_indices))\n    occupancy_count = len(unique_cells)\n\n    # 3. Pearson correlation coefficient\n    # Check for constant series to avoid NaN from division by zero in correlation formula.\n    if np.std(U_i) == 0 or np.std(U_ip1) == 0:\n        correlation = 1.0 if np.array_equal(U_i, U_ip1) else 0.0\n    else:\n        correlation = np.corrcoef(U_i, U_ip1)[0, 1]\n\n    # 4. Number of distinct bins of the modular difference\n    # np.mod ensures the result is in [0, m), correctly handling negative differences.\n    diff = np.mod(X_ip1 - X_i, m)\n    bin_width = m / G\n    diff_bins = np.floor(diff / bin_width)\n    diff_bin_count = len(np.unique(diff_bins))\n    \n    return [uniformity_ratio, occupancy_count, correlation, diff_bin_count]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results in the required format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (name, (m, a, c, x0), G) or (name, (m, seed), G)\n    test_cases = [\n        ('A', (4096, 1, 5, 0), 64),\n        ('B', (4096, 1, 512, 0), 64),\n        ('C', (4096, 5, 1, 1), 64),\n        ('D', (4096, 12345), 64)\n    ]\n\n    results = []\n    for case in test_cases:\n        name, params, G = case\n        \n        if name == 'D':\n            m, seed = params\n            # Generate sequence for Case D (independent uniform baseline)\n            rng = np.random.default_rng(seed=seed)\n            U = rng.random(size=m)\n            X = np.floor(m * U).astype(np.int64)\n        else:\n            # Generate sequence for Cases A, B, C (LCGs)\n            m, a, c, x0 = params\n            X = generate_sequence_lcg(m, a, c, x0)\n            \n        metrics = calculate_metrics(X, m, G)\n        results.append(metrics)\n\n    # The final print statement must produce the exact single-line format.\n    # repr() creates a string representation of the list, and replace() removes spaces.\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3264088"}, {"introduction": "虽然目视检查可以揭示伪随机数生成器（PRNG）的严重结构性缺陷，但更严谨的方法需要定量的统计检验。皮尔逊卡方（$\\chi^2$）检验是评估生成器输出均匀性的基石。在这项实践中 [@problem_id:3264207]，你将从第一性原理出发，实现完整的测试流程：生成随机数、将其分箱、计算$\\chi^2$统计量，并最终计算$p$值以做出统计决策，从而在随机数生成与形式化的假设检验之间架起一座桥梁。", "problem": "要求您从第一性原理出发，对一个自定义伪随机数生成器 (PRNG) 的输出实现皮尔逊卡方均匀性检验。伪随机数生成器 (PRNG) 是指任何旨在生成模拟目标分布独立样本序列的确定性算法。在此任务中，该 PRNG 将是一个线性同余生成器 (LCG)，目标分布是区间 $\\left[0,1\\right)$ 上的连续均匀分布。\n\n从核心定义和经过充分检验的事实出发，实现以下内容：\n\n- 构建一个线性同余生成器 (LCG)，其整数状态的更新规则定义为：新状态等于 (当前状态乘以乘数再加上增量) 对模数取模。通过将每个整数状态除以模数，将其映射到 $\\left[0,1\\right)$ 区间内的一个实数。LCG 状态更新使用整数算术，并精确生成 $n$ 个样本。\n- 将区间 $\\left[0,1\\right)$ 划分为 $k$ 个等宽的组。根据样本计算观测到的各组频数。在完全均匀的假设下，期望的组频数是总样本数除以组数。\n- 根据观测频数和期望频数计算皮尔逊卡方统计量。为卡方分布使用正确的自由度。\n- 使用正则化上不完全伽马函数计算卡方分布上尾的 $p$ 值。您必须以数值方式实现此计算，不得使用任何黑盒统计检验函数。为了提高数值稳定性，可以使用伽马函数的自然对数。\n- 通过将 $p$ 值与给定的显著性水平 $\\alpha$（以小数表示）进行比较，来决定是否接受均匀性假设。当 $p$ 值大于或等于 $\\alpha$ 时，接受均匀性假设，否则拒绝。\n\n实现约束：\n\n- 程序必须是一个完整、可运行的程序，仅使用 Python 标准库和指定版本的 Numerical Python (NumPy) 库。\n- PRNG 必须是自定义构建的，不得使用任何外部随机源。\n- $p$ 值的计算必须通过对正则化上不完全伽马函数的数值稳定求值来实现，避免使用任何外部统计库。\n\n测试套件：\n\n为以下参数集提供结果。每个集合是一个元组 $\\left(m,a,c,s,n,k,\\alpha\\right)$，包含模数 $m$、乘数 $a$、增量 $c$、种子 $s$、样本数量 $n$、组数 $k$ 和显著性水平 $\\alpha$。\n\n- 情况 1（理想情况，广泛使用的参数）：$\\left(2^{31}-1,16807,0,1,100000,100,0.01\\right)$。\n- 情况 2（退化生成器，常数序列）：$\\left(2^{16},1,0,12345,10000,50,0.01\\right)$。\n- 情况 3（乘法 LCG 的退化种子）：$\\left(2^{31}-1,16807,0,0,10000,50,0.01\\right)$。\n- 情况 4（临界可靠性：每组的期望频数较小）：$\\left(2^{31}-1,16807,0,1,200,50,0.05\\right)$。\n- 情况 5（模数过小导致短周期）：$\\left(8,5,0,1,1000,10,0.01\\right)$。\n\n最终输出规范：\n\n- 对于每种情况，输出一个布尔值，表示在显著性水平 $\\alpha$ 下是否接受均匀性假设。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格，结果按上述情况排序。例如：$\\left[\\text{result1},\\text{result2},\\text{result3},\\text{result4},\\text{result5}\\right]$，其中每个结果为 $\\text{True}$ 或 $\\text{False}$。", "solution": "我们通过整合将 PRNG 输出与统计决策过程联系起来的定义和性质来构建解决方案。\n\n首先，定义线性同余生成器 (LCG)。给定整数 $m$、$a$、$c$ 和初始种子 $s$，LCG 的状态通过以下方式演化\n$$\nX_{n+1} = \\left(a X_n + c\\right) \\bmod m,\n$$\n其中 $X_0 = s$。每个状态 $X_n \\in \\{0,1,\\ldots,m-1\\}$ 被映射到一个实数样本\n$$\nU_n = \\frac{X_n}{m},\n$$\n该样本位于 $\\left[0,1\\right)$ 区间内。\n\n为了评估 $\\{U_n\\}$ 的均匀性，我们将 $\\left[0,1\\right)$ 划分为 $k$ 个等宽的不相交区间（组）。设这些组为\n$$\nB_i = \\left[\\frac{i}{k}, \\frac{i+1}{k}\\right), \\quad i = 0,1,\\ldots,k-1.\n$$\n通过计算落入 $B_i$ 的样本数量来定义观测频数 $O_i$。在完全均匀分布的假设下，落入任何一个组的概率为 $1/k$，因此每个组的期望频数为\n$$\nE = \\frac{n}{k},\n$$\n其中 $n$ 是总样本数。\n\n用于检验均匀性的皮尔逊卡方统计量是\n$$\n\\chi^2 = \\sum_{i=0}^{k-1} \\frac{\\left(O_i - E\\right)^2}{E}.\n$$\n在均匀性原假设下，只要 $n$ 足够大且期望频数不太小，该统计量近似服从自由度为\n$$\n\\nu = k - 1\n$$\n的卡方分布。卡方分布是伽马分布的一个特例：如果 $X \\sim \\chi^2_\\nu$，则 $X$ 服从形状参数为 $\\nu/2$、尺度参数为 $2$ 的伽马分布。因此，对于观测值 $\\chi^2$，其上尾 $p$ 值与正则化上不完全伽马函数相关。具体而言，\n$$\np = Q\\left(\\frac{\\nu}{2},\\frac{\\chi^2}{2}\\right),\n$$\n其中 $Q(a,x)$ 是正则化上不完全伽马函数，定义为\n$$\nQ(a,x) = \\frac{\\Gamma(a,x)}{\\Gamma(a)},\n$$\n而 $\\Gamma(a,x)$ 是上不完全伽马函数，$\\Gamma(a)$ 是伽马函数。\n\n为在不使用黑盒函数的情况下数值计算 $Q(a,x)$，我们使用两种互补的展开式以确保数值稳定性（如标准数值分析文献中所述）。设 $a0$ 且 $x \\ge 0$。引入公共前置因子\n$$\n\\mathrm{pref}(a,x) = \\exp\\left(a \\ln x - x - \\ln \\Gamma(a)\\right).\n$$\n然后使用：\n- 当 $x  a+1$ 时，使用正则化下不完全伽马函数 $P(a,x)$ 的收敛级数\n$$\nP(a,x) = \\mathrm{pref}(a,x) \\sum_{n=0}^{\\infty} \\frac{x^n}{a (a+1) \\cdots (a+n)},\n$$\n通过级数项的递推关系实现，并返回 $Q(a,x) = 1 - P(a,x)$。\n- 当 $x \\ge a+1$ 时，使用 $Q(a,x)$ 的连分数，该连分数基于分数\n$$\nQ(a,x) = \\mathrm{pref}(a,x) \\cdot \\left[ \\cfrac{1}{x+1-a - \\cfrac{1 \\cdot (1-a)}{x+3-a - \\cfrac{2 \\cdot (2-a)}{x+5-a - \\cdots}}} \\right],\n$$\n通过使用标准保障措施（微小值初始化和收敛容差）对连分数进行稳定的正向迭代来求值。\n\n给定计算出的 $p$ 值，应用在显著性水平 $\\alpha$ 下的决策规则：\n$$\n\\text{接受均匀性假设} \\quad \\Leftrightarrow \\quad p \\ge \\alpha.\n$$\n\n算法设计：\n\n- 在 LCG 中使用整数算术生成 $n$ 个样本。通过除以 $m$ 将状态映射到 $\\left[0,1\\right)$ 区间的实数。\n- 通过 $b(U_n) = \\min\\left(\\left\\lfloor k U_n \\right\\rfloor, k-1\\right)$ 计算组索引，以确保索引在 $\\{0,1,\\ldots,k-1\\}$ 范围内。\n- 通过类似直方图的计算累积观测频数 $O_i$。\n- 计算 $E = n/k$，然后通过归一化偏差的平方和计算 $\\chi^2$。\n- 令 $\\nu = k-1$，计算 $a = \\nu/2$ 和 $x = \\chi^2/2$，使用上述的分段策略计算 $Q(a,x)$，并将 $p$ 值与 $\\alpha$ 进行比较。\n\n边缘情况考虑：\n\n- 退化的生成器（如 $a=1, c=0$）会产生一个常数序列，将所有样本集中在一个组中，从而产生极大的 $\\chi^2$ 值和 $p \\approx 0$，因此拒绝原假设。\n- 种子 $s=0$ 的乘法 LCG 会对所有 $n$ 产生 $U_n=0$，同样导致拒绝。\n- 当 $n$ 较小而 $k$ 较大时，期望频数 $E=n/k$ 可能很小，导致卡方近似的准确性降低。算法仍然会计算出有效的统计量和 $p$ 值，但在这种情况下应谨慎解释决策结果。\n\n程序评估五个指定的情况，并输出一行包含五个布尔值的文本，用方括号括起，以逗号分隔且无空格，按顺序对应每种情况的接受决策。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef lcg_generate(m: int, a: int, c: int, seed: int, n: int) - np.ndarray:\n    \"\"\"\n    Generate n samples in [0,1) using a Linear Congruential Generator (LCG):\n    X_{n+1} = (a * X_n + c) mod m, with X_0 = seed.\n    Returns a NumPy array of floats in [0,1).\n    \"\"\"\n    samples = np.empty(n, dtype=np.float64)\n    state = seed % m\n    for i in range(n):\n        # Map current state to [0,1)\n        samples[i] = state / m\n        # Advance state\n        state = (a * state + c) % m\n    return samples\n\ndef chi_square_uniformity(samples: np.ndarray, k: int):\n    \"\"\"\n    Compute Pearson chi-squared statistic for uniformity over k equal bins on [0,1).\n    Returns (chi2_stat, p_value).\n    \"\"\"\n    n = samples.size\n    # Bin indices: floor(k * x), clipped to k-1 to guard against edge\n    bin_indices = np.minimum((samples * k).astype(np.int64), k - 1)\n    counts = np.bincount(bin_indices, minlength=k)\n    expected = n / k\n    # Chi-squared statistic: sum((O_i - E)^2 / E)\n    diffs = counts - expected\n    chi2 = np.sum((diffs * diffs) / expected)\n    # Degrees of freedom\n    v = k - 1\n    # Upper-tail p-value using regularized upper incomplete gamma:\n    # p = Q(v/2, chi2/2)\n    a = 0.5 * v\n    x = 0.5 * chi2\n    p = gammaincc(a, x)\n    return chi2, p\n\ndef gammaincc(a: float, x: float) - float:\n    \"\"\"\n    Regularized upper incomplete gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n    Implements the Numerical Recipes-style algorithm with series for P(a, x) when x  a+1,\n    and continued fraction for Q(a, x) when x = a+1.\n    \"\"\"\n    if a = 0.0 or x  0.0:\n        raise ValueError(\"Invalid arguments for gammaincc: require a  0 and x = 0.\")\n    if x == 0.0:\n        return 1.0\n    # Common prefactor: exp(a*ln(x) - x - lnGamma(a))\n    ln_gamma_a = math.lgamma(a)\n    lnpref = a * math.log(x) - x - ln_gamma_a\n    pref = math.exp(lnpref)\n    # Switch by x relative to a+1\n    if x  a + 1.0:\n        # Compute P(a, x) via series\n        return 1.0 - _gammainc_lower_reg_series(a, x, pref)\n    else:\n        # Compute Q(a, x) via continued fraction\n        return _gammainc_upper_reg_cf(a, x, pref)\n\ndef _gammainc_lower_reg_series(a: float, x: float, pref: float) - float:\n    \"\"\"\n    Regularized lower incomplete gamma P(a, x) via series expansion.\n    Returns P(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    sum_term = 1.0 / a\n    term = sum_term\n    ap = a\n    for n in range(1, max_iter + 1):\n        ap += 1.0\n        term *= x / ap\n        sum_term += term\n        if abs(term)  abs(sum_term) * eps:\n            break\n    return pref * sum_term\n\ndef _gammainc_upper_reg_cf(a: float, x: float, pref: float) - float:\n    \"\"\"\n    Regularized upper incomplete gamma Q(a, x) via continued fraction.\n    Returns Q(a, x).\n    \"\"\"\n    eps = 1e-14\n    max_iter = 100000\n    tiny = 1e-300\n    b = x + 1.0 - a\n    c = 1.0 / tiny\n    d = 1.0 / b\n    h = d\n    for i in range(1, max_iter + 1):\n        an = -i * (i - a)\n        b += 2.0\n        d = 1.0 / (an * d + b)\n        c = b + an / c\n        if c == 0.0:\n            c = tiny\n        del_cf = d * c\n        h *= del_cf\n        if abs(del_cf - 1.0)  eps:\n            break\n    return pref * h\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (m, a, c, seed, n, k, alpha)\n    test_cases = [\n        (2**31 - 1, 16807, 0, 1, 100000, 100, 0.01),   # Case 1: Park-Miller minimal standard\n        (2**16, 1, 0, 12345, 10000, 50, 0.01),         # Case 2: Degenerate generator (constant)\n        (2**31 - 1, 16807, 0, 0, 10000, 50, 0.01),     # Case 3: Seed zero degeneracy\n        (2**31 - 1, 16807, 0, 1, 200, 50, 0.05),       # Case 4: Borderline small expected count\n        (8, 5, 0, 1, 1000, 10, 0.01),                  # Case 5: Very small modulus, short cycle\n    ]\n\n    results = []\n    for case in test_cases:\n        m, a, c, seed, n, k, alpha = case\n        samples = lcg_generate(m, a, c, seed, n)\n        chi2, pval = chi_square_uniformity(samples, k)\n        accept = pval = alpha\n        results.append(accept)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3264207"}, {"introduction": "伪随机数是蒙特卡洛方法的基石，该方法通过重复随机抽样来解决复杂问题。本练习 [@problem_id:3264193] 将此原理应用于经典的“集券问题”（coupon collector's problem），要求你构建一个模拟来估计集齐一套卡券所需的期望次数。这项任务强调了计算实验的完整生命周期：实现一个生成器，用它来为一个随机过程建模，并将经验结果与理论预测进行比较，同时还要小心处理采样偏置这个虽然微妙但至关重要的问题。", "problem": "您需要使用伪随机数生成器实现一个集券人过程的模拟，并将试验次数的蒙特卡洛估计值与从第一性原理推导出的理论值进行比较。考虑以下模型：有 $n$ 种不同的优惠券类型，标记为 $0,1,\\dots,n-1$。在每次试验中，恰好抽取一张优惠券，且每种优惠券类型被抽取的概率均等。各次试验是独立的。令 $T$ 为集齐所有 $n$ 种类型的优惠券至少一次所需的总试验次数。\n\n此任务的基础必须是试验独立性、均匀离散选择以及几何随机变量期望的定义。伪随机数生成器 (PRNG) 是一种确定性算法，其生成的数列可近似于离散集上的独立均匀随机变量。您必须实例化一个线性同余生成器 (LCG)，其由以下递推关系定义\n$$\nx_{t+1} = (a x_t + c) \\bmod m,\n$$\n其中 $a$、$c$ 和 $m$ 是固定整数，$x_t$ 是步骤 $t$ 的内部状态。您必须使用以下已知能产生长周期序列的参数：$a=16807$，$c=0$ 和 $m=2^{31}-1$。使用满足 $0  s  m$ 的种子 $s$ 初始化状态。基于此生成器，通过应用无偏拒绝采样来消除模偏差，从而构造在 $\\{0,1,\\dots,n-1\\}$ 内的均匀整数抽取：如果 $y = x_t - 1 \\in \\{0,1,\\dots,m-2\\}$ 且 $t^\\star = \\left\\lfloor \\frac{m-1}{n} \\right\\rfloor \\cdot n$，则当 $y  t^\\star$ 时接受 $y$ 并返回 $y \\bmod n$；否则，推进生成器并重试直至接受。\n\n对于每个测试用例，使用您的 PRNG 驱动集券人过程，执行 $M$ 次独立的蒙特卡洛重复实验，计算所有重复实验的经验均值 $\\hat{E}[T]$，并计算从第一性原理推导出的理论期望 $E[T]$（在本问题陈述中不要使用快捷公式）。报告绝对误差 $|\\hat{E}[T] - E[T]|$。\n\n您的程序必须实现所述的 PRNG 和模拟，并生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表，每个测试用例产生一个列表 $[\\hat{E}[T],E[T],|\\hat{E}[T]-E[T]|]$。所有输出均为实数（浮点数），以标准十进制表示法表示，不带任何物理单位。\n\n使用以下测试套件，涵盖正常路径和边界条件：\n- 用例 A (边界): $n=1$, $M=100$, $s=12345$。\n- 用例 B (正常路径-小规模): $n=5$, $M=10000$, $s=987654321$。\n- 用例 C (中等规模): $n=50$, $M=2000$, $s=42$。\n- 用例 D (较大规模): $n=200$, $M=800$, $s=20231107$。\n\n您的程序应生成单行输出，其中包含结果，格式为方括号括起来的逗号分隔列表（例如，$[[\\hat{E}_A,E_A,|e_A|],[\\hat{E}_B,E_B,|e_B|],[\\hat{E}_C,E_C,|e_C|],[\\hat{E}_D,E_D,|e_D|]]$），其中每个内部列表按给定顺序对应相应的测试用例。", "solution": "该问题要求为集券人问题实现蒙特卡洛模拟，并将其经验结果与理论期望进行比较。这涉及三个主要部分：从第一性原理推导理论期望，实现指定的伪随机数生成器 (PRNG)，以及设计模拟逻辑。\n\n### 1. 试验的理论期望 $E[T]$\n\n问题的核心是确定集齐所有 $n$ 种不同类型优惠券所需的期望试验次数 $E[T]$。令 $T$ 为表示总试验次数的随机变量。我们可以将 $T$ 分解为一系列更简单的随机变量之和。\n\n令 $T_i$ 为在已集齐 $i-1$ 种不同类型优惠券的条件下，获得第 $i$ 种新优惠券所需的额外试验次数。总试验次数是获得每一种新优惠券所需试验次数的总和：\n$$\nT = T_1 + T_2 + \\dots + T_n\n$$\n根据期望的线性性质，总试验次数的期望是这些单个阶段期望值的总和：\n$$\nE[T] = E\\left[\\sum_{i=1}^{n} T_i\\right] = \\sum_{i=1}^{n} E[T_i]\n$$\n现在，我们来求每个阶段 $i$ 的期望 $E[T_i]$。在阶段 $i$ 开始时，我们已经收集了 $i-1$ 种不同的优惠券类型。优惠券的总类型数为 $n$。因此，尚未收集的优惠券类型数量为 $n - (i-1)$。由于 $n$ 种类型中的每一种都以相等的概率 $1/n$ 被抽取，因此抽到任何一个特定未收集类型的概率是 $1/n$。因此，在单次试验中抽到任何新（未收集）类型的概率是：\n$$\np_i = \\frac{n - (i-1)}{n}\n$$\n在一系列独立的伯努利试验中等待首次成功（抽到一种新优惠券）的过程，可以用几何分布来描述。随机变量 $T_i$ 服从成功概率为 $p_i$ 的几何分布。对于参数为 $p$ 的几何分布，首次成功前的期望试验次数为 $1/p$。因此，阶段 $i$ 的期望试验次数为：\n$$\nE[T_i] = \\frac{1}{p_i} = \\frac{n}{n - i + 1}\n$$\n将此结果代入 $E[T]$ 的求和式中：\n$$\nE[T] = \\sum_{i=1}^{n} \\frac{n}{n - i + 1}\n$$\n为了简化此表达式，我们可以进行换元。令 $k = n - i + 1$。当 $i=1$ 时，$k=n$。当 $i=n$ 时，$k=1$。求和式变为：\n$$\nE[T] = \\sum_{k=1}^{n} \\frac{n}{k} = n \\sum_{k=1}^{n} \\frac{1}{k}\n$$\n和式 $\\sum_{k=1}^{n} \\frac{1}{k}$ 是第 $n$ 个调和数，记为 $H_n$。因此，$E[T] = n H_n$。该公式将用于计算理论期望。\n\n### 2. 算法设计\n\n该解决方案围绕一个处理每个测试用例的主函数构建。对于每个用例，它通过蒙特卡洛模拟计算理论期望和经验估计，然后找出绝对误差。\n\n**A. 伪随机数生成器 (PRNG)**\n\n实现一个线性同余生成器 (LCG) 作为随机性来源。\n-   **状态与递推：** 生成器维护一个内部状态 $x_t$。下一个状态通过递推关系 $x_{t+1} = (a x_t + c) \\bmod m$ 计算。问题指定了参数 $a=16807$，$c=0$ 和 $m=2^{31}-1$。状态由给定的种子 $s$ 初始化。\n-   **实现：** 一个 `LCG` 类封装了状态和参数。`_next_raw()` 方法计算并返回序列中的下一个值，同时更新内部状态。计算 $(a \\cdot x_t)$ 可能会超过 $2^{31}-1$，因此在取模运算前，需要使用 64 位整数算术（或 Python 的任意精度整数）以防止溢出。\n\n**B. 无偏均匀整数采样器**\n\n如果简单地将 LCG 的原始输出对 $n$ 取模，结果在 $\\{0, 1, \\dots, n-1\\}$ 上不是均匀分布的。为纠正这种偏差，按规定采用拒绝采样法。\n-   **拒绝阈值：** 首先，计算一个阈值 $t^\\star$：$t^\\star = \\lfloor \\frac{m-1}{n} \\rfloor \\cdot n$。该值是不大于 $m-1$ 的 $n$ 的最大倍数。\n-   **采样逻辑：** 采样方法按如下方式生成整数：\n    1.  从 LCG 生成一个原始值 $x_t$。\n    2.  通过计算 $y = x_t - 1$，将其映射到范围 $\\{0, 1, \\dots, m-2\\}$。\n    3.  如果 $y  t^\\star$，则接受样本。函数返回 $y \\bmod n$。因为接受的 $y$ 值范围 $[0, t^\\star-1]$ 的长度是 $n$ 的倍数，所以 $\\{0, 1, \\dots, n-1\\}$ 中的每个输出值都会以相同的频率产生。\n    4.  如果 $y \\ge t^\\star$，则拒绝样本，并从步骤 1 开始重复该过程，直到样本被接受。\n\n**C. 蒙特卡洛模拟**\n\n经验估计的核心是集券人过程的模拟。\n-   **单次重复：** 一个函数 `run_single_collection(n, prng)` 执行一次完整的实验运行。\n    1.  初始化一个大小为 $n$ 的布尔数组 `collected` 为 `False`，用于跟踪哪些类型的优惠券已被见过。\n    2.  初始化 `distinct_coupons_count = 0` 和 `trials = 0`。\n    3.  循环直到 `distinct_coupons_count` 等于 $n$：\n        - 递增 `trials`。\n        - 使用无偏采样器从 $\\{0, 1, \\dots, n-1\\}$ 中抽取一张优惠券 `c`。\n        - 如果 `collected[c]` 是 `False`，说明这是一张新优惠券。将 `collected[c]` 设置为 `True` 并递增 `distinct_coupons_count`。\n    4.  返回最终的 `trials` 计数。\n-   **主模拟循环：** 对于每个测试用例 $(n, M, s)$：\n    1.  用种子 $s$ 实例化 `LCG`。\n    2.  运行一个循环 $M$ 次。在每次迭代中，调用 `run_single_collection` 并存储得到的试验次数。\n    3.  通过对 $M$ 次试验计数取平均，计算经验均值 $\\hat{E}[T]$。\n\n**D. 最终计算与输出**\n\n对于每个测试用例，程序执行以下最后步骤：\n1.  计算理论期望 $E[T] = n \\sum_{k=1}^{n} \\frac{1}{k}$。\n2.  运行蒙特卡洛模拟以获得经验均值 $\\hat{E}[T]$。\n3.  计算绝对误差 $|\\hat{E}[T] - E[T]|$。\n4.  将三个浮点数值 $[\\hat{E}[T], E[T], |\\hat{E}[T]-E[T]|]$ 存储在结果列表中。\n5.  处理完所有测试用例后，将结果列表格式化为指定的字符串格式 `[[...],[...],...]` 并打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass LCG:\n    \"\"\"\n    Implements a Linear Congruential Generator (LCG) with rejection sampling.\n    x_{t+1} = (a * x_t + c) mod m\n    \"\"\"\n    def __init__(self, seed: int, a: int, c: int, m: int):\n        if not (0  seed  m):\n            raise ValueError(\"Seed must be in the range (0, m-1)\")\n        self.state = seed\n        self.a = a\n        self.c = c\n        self.m = m\n\n    def _next_raw(self) - int:\n        \"\"\"\n        Generates the next integer in the LCG sequence.\n        \"\"\"\n        self.state = (self.a * self.state + self.c) % self.m\n        return self.state\n\n    def get_uniform_draw(self, n: int, t_star: int) - int:\n        \"\"\"\n        Generates a uniform integer in {0, ..., n-1} using unbiased rejection sampling.\n        \"\"\"\n        while True:\n            # Generate a raw value from the LCG.\n            raw_val = self._next_raw()\n            \n            # Map to the range {0, ..., m-2}\n            y = raw_val - 1\n            \n            # Accept if y is in the valid range [0, t_star - 1]\n            if y  t_star:\n                return y % n\n            # Otherwise, reject and retry.\n\ndef run_single_collection(n: int, prng: LCG) - int:\n    \"\"\"\n    Simulates one full coupon collection process for n coupons.\n\n    Args:\n        n (int): The number of distinct coupon types.\n        prng (LCG): An initialized LCG instance.\n\n    Returns:\n        int: The total number of trials to collect all n coupons.\n    \"\"\"\n    if n == 1:\n        return 1\n\n    # Pre-calculate the rejection sampling threshold t_star\n    t_star = ((prng.m - 1) // n) * n\n    \n    collected_coupons = [False] * n\n    distinct_coupons_count = 0\n    trials = 0\n\n    while distinct_coupons_count  n:\n        trials += 1\n        coupon = prng.get_uniform_draw(n, t_star)\n        \n        if not collected_coupons[coupon]:\n            collected_coupons[coupon] = True\n            distinct_coupons_count += 1\n    \n    return trials\n\ndef calculate_theoretical_e(n: int) - float:\n    \"\"\"\n    Calculates the theoretical expected number of trials E[T] = n * H_n.\n\n    Args:\n        n (int): The number of distinct coupon types.\n\n    Returns:\n        float: The theoretical expectation E[T].\n    \"\"\"\n    if n == 0:\n        return 0.0\n    \n    harmonic_sum = sum(1.0 / k for k in range(1, n + 1))\n    return n * harmonic_sum\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # LCG parameters from the problem statement\n    a = 16807\n    c = 0\n    m = 2**31 - 1\n    \n    # Test cases from the problem statement\n    test_cases = [\n        # (n, M, seed)\n        (1, 100, 12345),\n        (5, 10000, 987654321),\n        (50, 2000, 42),\n        (200, 800, 20231107),\n    ]\n\n    all_results = []\n\n    for n, M, s in test_cases:\n        # 1. Calculate theoretical expectation\n        e_t = calculate_theoretical_e(n)\n\n        # 2. Run Monte Carlo simulation\n        prng = LCG(seed=s, a=a, c=c, m=m)\n        \n        trial_counts = np.empty(M, dtype=int)\n        for i in range(M):\n            # The PRNG state is carried over between replications\n            trial_counts[i] = run_single_collection(n, prng)\n        \n        hat_e_t = np.mean(trial_counts)\n\n        # 3. Calculate absolute error\n        abs_error = abs(hat_e_t - e_t)\n\n        # 4. Store results as floats\n        all_results.append([float(hat_e_t), float(e_t), float(abs_error)])\n\n    # Final print statement in the exact required format.\n    # Using str() on a list creates the [item1, item2, ...] representation.\n    # Joining these string representations with a comma creates the desired output.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3264193"}]}