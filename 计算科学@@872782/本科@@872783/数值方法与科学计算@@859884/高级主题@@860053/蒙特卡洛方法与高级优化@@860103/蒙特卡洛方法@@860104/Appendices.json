{"hands_on_practices": [{"introduction": "蒙特卡洛方法的核心思想之一是利用随机抽样来解决确定性问题，其中最经典的应用就是数值积分。这个练习将带你入门最基础的蒙特卡洛积分，通过一个简单的例子，让你亲手计算如何使用一组随机点来近似一个定积分的值。这个过程能帮助你直观地理解，积分可以被看作是函数在某个区间上的“平均高度”乘以区间的“宽度”，而蒙特卡洛方法正是用样本均值来估计这个“平均高度”[@problem_id:1964916]。", "problem": "一名计算物理课程的学生正在学习简单的蒙特卡洛（MC）方法。任务是通过在少量随机抽样点上计算被积函数的值来估计定积分的值。该技术通过计算表达式 $(b-a) \\times \\langle f \\rangle_N$ 来近似积分 $I = \\int_a^b f(x) dx$，其中 $\\langle f \\rangle_N$ 是在区间 $[a, b]$ 上均匀抽取的 $N$ 个点上函数值的算术平均值。\n\n学生被要求估计积分：\n$$ I = \\int_{0}^{2} \\frac{1}{1 + x^2} dx $$\n为了进行此估计，已从区间 $[0, 2]$ 上的均匀随机分布中预先选择了一组 $N=5$ 个点。这些点是：\n$$ x_1 = 0.25, \\quad x_2 = 1.50, \\quad x_3 = 0.80, \\quad x_4 = 1.90, \\quad x_5 = 1.10 $$\n仅使用这些信息，计算积分 $I$ 的蒙特卡洛估计值。将您的最终答案四舍五入到三位有效数字。", "solution": "在有限区间上进行均匀抽样的粗略蒙特卡洛估计量为\n$$\n\\hat{I}_{N}=(b-a)\\,\\langle f\\rangle_{N}=(b-a)\\,\\frac{1}{N}\\sum_{i=1}^{N}f(x_{i}).\n$$\n这里，$a=0$，$b=2$，$N=5$，且 $f(x)=\\frac{1}{1+x^{2}}$。对于给定的点，\n$$\n\\begin{aligned}\nf(0.25)=\\frac{1}{1+(0.25)^{2}}=\\frac{1}{1+\\frac{1}{16}}=\\frac{16}{17},\\\\\nf(1.50)=\\frac{1}{1+(1.50)^{2}}=\\frac{1}{1+\\frac{9}{4}}=\\frac{4}{13},\\\\\nf(0.80)=\\frac{1}{1+(0.80)^{2}}=\\frac{1}{1+\\frac{16}{25}}=\\frac{25}{41},\\\\\nf(1.90)=\\frac{1}{1+(1.90)^{2}}=\\frac{1}{1+\\frac{361}{100}}=\\frac{100}{461},\\\\\nf(1.10)=\\frac{1}{1+(1.10)^{2}}=\\frac{1}{1+\\frac{121}{100}}=\\frac{100}{221}.\n\\end{aligned}\n$$\n求和，\n$$\nS=\\frac{16}{17}+\\frac{4}{13}+\\frac{25}{41}+\\frac{100}{461}+\\frac{100}{221}\n=\\frac{10,559,901}{4,177,121}.\n$$\n因此，\n$$\n\\langle f\\rangle_{5}=\\frac{S}{5}=\\frac{10,559,901}{20,885,605},\n\\quad\n\\hat{I}_{5}=(b-a)\\langle f\\rangle_{5}=2\\cdot\\frac{10,559,901}{20,885,605}\n=\\frac{21,119,802}{20,885,605}.\n$$\n数值上，\n$$\n\\hat{I}_{5}\\approx 1.011213321\\ldots\n$$\n四舍五入到三位有效数字得到 $1.01$。", "answer": "$$\\boxed{1.01}$$", "id": "1964916"}, {"introduction": "蒙特卡洛方法的应用远不止于计算一维积分。它的真正威力体现在处理高维和复杂问题上，例如估算概率或计算不规则区域的体积。本练习将通过一个系统可靠性的模拟场景，向你介绍经典的“投针法”（Hit-or-Miss Method）。你将看到，通过在一个更大的、规则的区域内随机“投点”，并计算落在目标区域内的点的比例，我们可以轻松地估算出难以解析计算的概率或高维体积[@problem_id:2188161]。", "problem": "一种新的分布式计算架构涉及一个由五个节点组成的集群，它们共享一个共同的、有限的资源（例如，网络带宽）。对于一种特定类型的计算，每个节点 $i$（$i=1, 2, 3, 4, 5$）都独立地请求总可用资源的一部分，比例为 $x_i$。每个 $x_i$ 是一个从区间 $[0, 1]$ 上的均匀分布中抽取的随机变量。仅当来自所有五个节点的需求比例之和小于1时，即 $\\sum_{i=1}^5 x_i  1$，该计算才被认为是成功的。如果总和大于或等于1，系统将发生严重故障。\n\n为了估计该架构的可靠性，工程师们进行了一次大规模的蒙特卡洛模拟。他们总共运行了 $N = 3,600,000$ 次试验。在每次试验中，都会生成一组五个随机的需求比例 $(x_1, x_2, x_3, x_4, x_5)$。模拟记录到导致严重故障的试验次数为 $N_{fail} = 3,570,012$。\n\n根据这次模拟的结果，计算单次计算成功的估计概率。将您的答案表示为小数，并四舍五入到三位有效数字。", "solution": "我们已知总试验次数 $N$ 和失败次数 $N_{fail}$。成功试验的次数为\n$$\nN_{succ} = N - N_{fail}.\n$$\n成功概率的蒙特卡洛估计值为\n$$\n\\hat{p} = \\frac{N_{succ}}{N}.\n$$\n代入给定值 $N = 3{,}600{,}000$ 和 $N_{fail} = 3{,}570{,}012$，我们计算\n$$\nN_{succ} = 3{,}600{,}000 - 3{,}570{,}012 = 29{,}988,\n$$\n因此\n$$\n\\hat{p} = \\frac{29{,}988}{3{,}600{,}000}.\n$$\n对分子和分母进行因式分解，\n$$\n29{,}988 = 36 \\cdot 833, \\quad 3{,}600{,}000 = 36 \\cdot 100{,}000,\n$$\n所以\n$$\n\\hat{p} = \\frac{36 \\cdot 833}{36 \\cdot 100{,}000} = \\frac{833}{100{,}000} = 0.00833.\n$$\n四舍五入到三位有效数字，结果仍然是 $0.00833$。", "answer": "$$\\boxed{0.00833}$$", "id": "2188161"}, {"introduction": "虽然基础的蒙特卡洛方法简单直观，但在面对某些“病态”问题时，其效率会变得极低甚至失效，一个典型的例子是当被积函数包含奇异点时。这种情况可能导致估计量的方差无穷大，使得收敛异常缓慢。本练习是一个进阶实践，旨在通过一个带有奇异点的积分问题，展示一种强大的方差缩减技术——变量变换（或称重要性抽样）[@problem_id:3253703]。你将通过编程对比三种不同方法的表现，深刻体会一个巧妙的数学变换（并正确使用雅可比行列式）如何能将一个几乎无法处理的问题，转变为一个收敛极快甚至得到精确解的问题。", "problem": "考虑在高等本科水平上使用蒙特卡洛方法近似计算积分 $$I=\\int_{0}^{1} x^{-1/2}\\,dx$$ 的问题。从基本定义出发：(i) 在有界区间上的积分等于被积函数在该区间上均匀分布的随机变量下的期望值，以及 (ii) 积分的变量替换定理指出，在应用一个光滑的双射映射时，积分通过乘以该映射导数的绝对值（一维情况下的雅可比行列式）进行变换。除了这些定义之外，不要使用任何预先推导的专用蒙特卡洛公式。\n\n您必须设计并实现三种蒙特卡洛估计量，它们都通过在单位区间上采样点来计算，但使用不同的被积函数表示形式：\n\n- 方法 $0$（直接对 $x$ 采样）：在 $[0,1]$ 中对 $x$ 进行采样，并通过对函数 $f(x)=x^{-1/2}$ 的值进行平均来近似积分。\n\n- 方法 $1$（正确的变量替换 $x=u^2$）：在 $[0,1]$ 上应用映射 $x=u^2$，并使用变量替换定理获得一个在 $u \\in [0,1]$ 上的被积函数，该函数必须包含雅可比因子 $|dx/du|$，然后通过对 $u$ 的样本上的正确变换后的被积函数进行平均来近似积分。\n\n- 方法 $2$（忽略雅可比行列式的错误映射）：应用相同的映射 $x=u^2$，但错误地忽略了雅可比因子，仅对 $u$ 的样本上的复合函数 $f(u^2)$ 进行平均。\n\n为了数值稳定性和确定性可复现性，在所有三种方法中，都应在单位区间上使用分层中点，而不是伪随机数。具体来说，对于给定的正整数 $N$，定义 $N$ 个样本点 $$s_i=\\frac{i-1/2}{N},\\quad i=1,2,\\dots,N.$$ 在方法 $0$ 中，设置 $x_i=s_i$。在方法 $1$ 和 $2$ 中，设置 $u_i=s_i$ 并应用相应的变换。\n\n对于每种方法和每个 $N$，计算：\n\n- $I$ 的估计值，即相应求和项值的算术平均值。\n\n- 这些求和项值的经验方差，使用除数为 $N-1$ 的常规无偏样本方差公式计算（如果 $N=1$，则定义经验方差为 $0$）。\n\n从第一性原理出发，对于每种方法，确定在单位区间上进行独立同分布采样时，求和项的真实均值是否有限，以及其真实方差是否有限。将这些有限性属性报告为布尔值。\n\n测试套件。您的程序必须为以下测试用例计算上述输出，这些测试用例涵盖了每种方法的典型情况和边界增长情况：\n\n- 方法 $0$，$N=10$。\n\n- 方法 $0$，$N=1000$。\n\n- 方法 $1$，$N=10$。\n\n- 方法 $1$，$N=1000$。\n\n- 方法 $2$，$N=10$。\n\n- 方法 $2$，$N=1000$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，按顺序输出以下四项：作为浮点数并四舍五入到六位小数的估计值，作为浮点数并四舍五入到六位小数的经验方差，一个指示求和项的真实均值是否有限的布尔值，以及一个指示求和项的真实方差是否有限的布尔值。将所有测试用例按上述顺序列出并连接成一个扁平列表。例如，整体打印结构必须是这种形式 $$[\\text{est}_{0,10},\\text{var}_{0,10},\\text{meanOK}_{0},\\text{varOK}_{0},\\text{est}_{0,1000},\\dots,\\text{est}_{2,1000},\\text{var}_{2,1000},\\text{meanOK}_{2},\\text{varOK}_{2}],$$ 其中每个 $\\text{est}_{\\cdot,\\cdot}$ 和 $\\text{var}_{\\cdot,\\cdot}$ 都是四舍五入到六位小数的浮点数，每个 $\\text{meanOK}_{\\cdot}$ 和 $\\text{varOK}_{\\cdot}$ 都是布尔值。不应打印其他任何文本。", "solution": "该问题要求对积分 $I=\\int_{0}^{1} x^{-1/2}\\,dx$ 的三种蒙特卡洛风格的估计量进行设计、理论分析和数值实现。分析必须基于第一性原理，即积分作为期望的解释和变量替换定理。\n\n积分的精确值是 $I = \\int_{0}^{1} x^{-1/2}\\,dx = [2x^{1/2}]_{0}^{1} = 2(1)^{1/2} - 2(0)^{1/2} = 2$。如果将其作为瑕积分处理，由于极限存在，这是一个正常的黎曼积分。被积函数 $f(x) = x^{-1/2}$ 在 $x=0$ 处有一个奇点。\n\n对于一个函数 $g(v)$ 和一个在 $[0,1]$ 上均匀分布的随机变量 $V$，其期望值为 $E[g(V)] = \\int_0^1 g(v)\\,dv$。因此，积分 $I$ 可以表示为期望 $E[f(X)]$，其中 $X$ 是 $[0,1]$ 上的一个均匀随机变量。$I$ 的蒙特卡洛估计是样本均值 $\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^N f(x_i)$，其中 $\\{x_i\\}$ 是从 $[0,1]$ 上的均匀分布中抽取的独立样本。问题指定了一种确定性的分层抽样方案，而不是随机抽样：$s_i = \\frac{i-1/2}{N}$，其中 $i=1,2,\\dots,N$。这是一种拟蒙特卡洛方法。\n\n蒙特卡洛估计量的质量由其求和项的性质决定。求和项的均值 $E[g(V)]$ 决定了估计量是否有偏。求和项的方差 $Var[g(V)] = E[g(V)^2] - (E[g(V)])^2$ 决定了估计的收敛速度。有限的方差对于估计量的标准误差以经典的 $1/\\sqrt{N}$ 速率下降至关重要。\n\n让我们分析所提出的三种方法中的每一种。\n\n**方法 0：直接对 $x$ 采样**\n在这种方法中，我们直接使用被积函数 $f(x)=x^{-1/2}$。样本点是 $x_i = s_i = \\frac{i-1/2}{N}$。求和项是 $y_i = x_i^{-1/2}$。\n对于给定的 $N$，积分的估计值为 $\\hat{I}_0 = \\frac{1}{N} \\sum_{i=1}^{N} y_i = \\frac{1}{N} \\sum_{i=1}^{N} (s_i)^{-1/2}$。\n\n理论分析：\n求和项是函数 $g_0(x) = x^{-1/2}$。\n对于 $X \\sim U(0,1)$，求和项的真实均值是其期望值：\n$$E[g_0(X)] = \\int_0^1 x^{-1/2} \\,dx = [2x^{1/2}]_0^1 = 2$$\n均值是有限的。\n求和项的真实方差是 $Var[g_0(X)] = E[g_0(X)^2] - (E[g_0(X)])^2$。我们首先计算二阶矩：\n$$E[g_0(X)^2] = \\int_0^1 (x^{-1/2})^2 \\,dx = \\int_0^1 x^{-1} \\,dx = [\\ln|x|]_0^1$$\n这个积分在下限 $x=0$ 处发散。由于二阶矩是无穷大，所以方差是无穷大。\n因此，对于方法 $0$，求和项的真实均值是有限的，但真实方差是无穷大。这意味着尽管大数定律适用且估计量是一致的（即它收敛到真实值），但收敛速度非常慢，并且标准形式的中心极限定理不适用。\n\n有限性属性：`meanOK` 为 True，`varOK` 为 False。\n\n**方法 1：正确的变量替换 $x=u^2$**\n此方法使用变换 $x=g(u)=u^2$，其中 $u \\in [0,1]$。积分的变量替换定理指出 $\\int f(x) \\,dx = \\int f(g(u)) |g'(u)| \\,du$。\n这里，$g(u)=u^2$，所以雅可比行列式是 $|g'(u)| = |dx/du| = |2u| = 2u$，因为 $u \\ge 0$。\n积分变换为：\n$$I = \\int_0^1 x^{-1/2} \\,dx = \\int_0^1 (u^2)^{-1/2} (2u) \\,du = \\int_0^1 u^{-1}(2u) \\,du = \\int_0^1 2 \\,du$$\n新的被积函数，也就是蒙特卡洛方法的求和项，是 $g_1(u) = 2$。\n样本点是 $u_i = s_i = \\frac{i-1/2}{N}$。求和项是 $y_i = g_1(u_i) = 2$。\n估计值是 $\\hat{I}_1 = \\frac{1}{N} \\sum_{i=1}^{N} 2 = \\frac{1}{N} (2N) = 2$。\n\n理论分析：\n求和项是常数函数 $g_1(u) = 2$。\n对于 $U \\sim U(0,1)$，求和项的真实均值是：\n$$E[g_1(U)] = \\int_0^1 2 \\,du = 2$$\n均值是有限的。\n求和项的真实方差是：\n$$Var[g_1(U)] = Var[2] = 0$$\n由于求和项是一个常数，其方差为零。方差是有限的。\n这个变量替换将一个具有无穷大方差的被积函数转换为了一个方差为零的函数，这是方差缩减的一个完美例子。对于任何 $N \\ge 1$，估计值都将是精确正确的 ($2$)。\n\n有限性属性：`meanOK` 为 True，`varOK` 为 True。\n\n**方法 2：忽略雅可比行列式的错误映射**\n此方法应用了变换 $x=u^2$，但错误地忽略了雅可比因子 $|dx/du|$。\n求和项被取为 $g_2(u) = f(g(u)) = f(u^2) = (u^2)^{-1/2} = u^{-1}$（对于 $u0$）。\n样本点是 $u_i = s_i = \\frac{i-1/2}{N}$。求和项是 $y_i = (u_i)^{-1}$。\n估计值是 $\\hat{I}_2 = \\frac{1}{N} \\sum_{i=1}^{N} (s_i)^{-1}$。此方法实际上是在估计积分 $\\int_0^1 u^{-1} du$，而不是原始积分 $I$。\n\n理论分析：\n求和项是函数 $g_2(u) = u^{-1}$。\n对于 $U \\sim U(0,1)$，求和项的真实均值是：\n$$E[g_2(U)] = \\int_0^1 u^{-1} \\,du = [\\ln|u|]_0^1$$\n这个积分在下限 $u=0$ 处发散。\n均值是无穷大。\n由于均值（一阶矩）是无穷大，方差（其依赖于一阶矩和二阶矩）也必然是无穷大。\n\n有限性属性：`meanOK` 为 False，`varOK` 为 False。\n\n**数值计算**\n对于每种方法和给定的 $N$，我们计算：\n1.  样本点：$s_i = (i-0.5)/N$，其中 $i=1, \\dots, N$。\n2.  根据方法的定义计算求和项 $y_i$。\n3.  估计值：$\\hat{I} = \\frac{1}{N}\\sum_{i=1}^N y_i$。\n4.  经验方差：$S^2 = \\frac{1}{N-1}\\sum_{i=1}^N (y_i - \\hat{I})^2$（对于 $N  1$），以及 $0$（对于 $N=1$）。\n\n将对指定的测试用例执行这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Monte Carlo integration problem for the specified test cases.\n    \"\"\"\n\n    # Test cases: list of (method_id, N)\n    # method_id 0: Direct, f(x) = x^(-1/2)\n    # method_id 1: Correct change of vars, f(u) = 2\n    # method_id 2: Incorrect change of vars, f(u) = u^(-1)\n    test_cases = [\n        (0, 10),\n        (0, 1000),\n        (1, 10),\n        (1, 1000),\n        (2, 10),\n        (2, 1000),\n    ]\n\n    # Theoretical properties determined from first principles\n    # (is_mean_finite, is_variance_finite)\n    theoretical_props = {\n        0: (True, False),  # Mean is 2, Variance is infinite\n        1: (True, True),   # Mean is 2, Variance is 0\n        2: (False, False), # Mean is infinite, Variance is infinite\n    }\n\n    results = []\n\n    for method_id, N in test_cases:\n        # Generate stratified midpoint samples on the unit interval\n        # s_i = (i - 1/2) / N for i = 1, 2, ..., N\n        # np.arange(1, N + 1) creates the sequence of i's.\n        samples = (np.arange(1, N + 1) - 0.5) / N\n\n        summands = None\n        if method_id == 0:\n            # Method 0: Direct sampling on x. Summands are x_i^(-1/2)\n            # The samples 's' are the x_i values.\n            summands = samples**(-0.5)\n        elif method_id == 1:\n            # Method 1: Correct change of variables x=u^2.\n            # Summands are f(u^2) * |dx/du| = (u^-2)^(1/2) * 2u = u^-1 * 2u = 2.\n            # The samples 's' are the u_i values.\n            # np.full creates an array of size N filled with the value 2.0.\n            summands = np.full(N, 2.0)\n        elif method_id == 2:\n            # Method 2: Incorrect mapping x=u^2 without Jacobian.\n            # Summands are f(u^2) = (u^2)^(-1/2) = u^-1.\n            # The samples 's' are the u_i values.\n            summands = samples**(-1)\n\n        # Calculate the estimate (arithmetic mean of summands)\n        estimate = np.mean(summands)\n\n        # Calculate the empirical variance of the summands\n        # The problem specifies unbiased sample variance (divisor N-1).\n        # np.var with ddof=1 computes this.\n        # If N=1, variance is defined as 0.\n        if N  1:\n            empirical_variance = np.var(summands, ddof=1)\n        else:\n            empirical_variance = 0.0\n\n        # Retrieve theoretical finiteness properties\n        mean_ok, var_ok = theoretical_props[method_id]\n\n        # Append results for this test case, formatted as required\n        results.extend([\n            f\"{estimate:.6f}\",\n            f\"{empirical_variance:.6f}\",\n            str(mean_ok),\n            str(var_ok)\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3253703"}]}