{"hands_on_practices": [{"introduction": "我们从一个基础示例开始，为由简单线性片段定义的三角分布推导采样器。这个练习非常适合从第一性原理出发，理解如何构建和反转分段累积分布函数（CDF），这是掌握逆变换采样法的核心技能。通过这个练习，你将学会处理分段函数，并为更复杂的问题打下坚实的基础 [@problem_id:2403851]。", "problem": "要求您为一个具有限支撑的三角形概率分布实现反变换采样。三角形分布由三个实数参数 $a$、$c$ 和 $b$ 定义，满足 $a  b$ 和 $a \\le c \\le b$，其中 $a$ 是左端点，$b$ 是右端点，$c$ 是众数（峰值位置）。其概率密度函数在 $[a, c]$ 和 $[c, b]$ 上是连续的分段线性函数，在 $[a, b]$ 之外为零。您的任务是从第一性原理出发推导出采样器，并将其实现为一个程序。\n\n基本原理：\n- 概率密度函数 (PDF)：一个非负函数 $f(x)$，其在其支撑上的积分为 $1$。\n- 累积分布函数 (CDF)：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- 反变换采样：如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，且 $F$ 是一个连续的、严格递增的 CDF，那么 $X = F^{-1}(U)$ 的 CDF 就是 $F$。\n\n要求：\n1) 仅从上述定义出发，推导三角形分布 $[a, c, b]$ 的分段 CDF $F(x)$，并解析地求其逆函数以得到对于 $u \\in [0,1]$ 的分位数函数 $F^{-1}(u)$。确保您的推导覆盖通用情况 $a  c  b$，并能正确处理极限情况 $c = a$ 和 $c = b$。\n\n2) 实现一个程序，给定 $(a, c, b)$ 和一个包含多个 $u$ 值的列表（每个 $u \\in [0,1]$），使用您推导出的逆函数返回相应的样本 $x = F^{-1}(u)$。您必须处理以下细节：\n- 为保证数值鲁棒性，在应用逆函数之前，将每个 $u$ 的值限制在 $[0,1]$ 区间内。\n- 您的实现必须在 $c = a$ 和 $c = b$ 的情况下正常工作，不会出现除零或无效分支问题。\n- 对于每个计算出的样本，将结果四舍五入到 $10$ 位小数。\n\n3) 您不得依赖任何库中预封装的三角形分布。您可以使用允许的库中的基本数值运算，但采样器必须直接实现您推導出的逆函数。\n\n本次挑战的输入和输出是固定的；没有用户输入。您的程序必须在指定的参数集和 $u$ 值（见下方的测试套件）上评估逆函数，并打印包含所有结果的单行输出。\n\n测试套件：\n- 案例 1 (通用“理想”路径)：$(a, c, b) = (0, 2, 5)$，u 值为 $[0, 0.1, 0.4, 0.5, 0.9, 1]$。\n- 案例 2 (边界情况 $c = a$)：$(a, c, b) = (3, 3, 7)$，u 值为 $[0, 0.25, 0.999999, 1]$。\n- 案例 3 (边界情况 $c = b$)：$(a, c, b) = (-2, 1, 1)$，u 值为 $[0, 0.25, 0.8, 1]$。\n- 案例 4 (边界鲁棒性)：$(a, c, b) = (0, 1, 2)$，u 值为 $[0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果，每个测试案例贡献一个包含四舍五入后样本的列表。具体来说，输出必须是一个形如\n$[[x_{1,1},x_{1,2},\\dots],[x_{2,1},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]]$\n的单行字符串，不含空格。每个 $x_{i,j}$ 都必须是四舍五入到 $10$ 位小数的浮点数。\n- 此问题不涉及任何物理单位；所有量均为无量纲实数。", "solution": "用户提供了一个问题陈述。我将首先验证它。\n\n### 步骤 1：提取已知条件\n- **分布**：三角形概率分布。\n- **参数**：实数 $a$、$c$、$b$，满足 $a  b$ 和 $a \\le c \\le b$。$a$ 是最小值，$b$ 是最大值，$c$ 是众数。\n- **概率密度函数 (PDF)**：$f(x)$ 是连续的、分段线性的，支撑集为 $[a, b]$。\n- **累积分布函数 (CDF)**：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- **核心任务**：使用反变换采样，其中样本 $X$ 通过 $X = F^{-1}(U)$ 从均匀随机变量 $U \\sim \\text{Uniform}[0,1]$ 生成。\n- **推导要求**：从第一性原理推导分段 CDF $F(x)$ 及其逆函数，即分位数函数 $F^{-1}(u)$。推导必须覆盖通用情况 $a  c  b$ 和极限情况 $c = a$ 和 $c = b$。\n- **实现要求**：\n    1. 实现推导出的 $F^{-1}(u)$ 函数。\n    2. 不使用库中预封装的三角形分布函数。\n    3. 输入的 $u$ 值必须被限制在 $[0,1]$ 区间内。\n    4. 实现必须能正确处理 $c=a$ 和 $c=b$ 的情况。\n    5. 输出的样本必须四舍五入到 $10$ 位小数。\n- **测试套件**：\n    - 案例 1: $(a, c, b) = (0, 2, 5)$， $u = [0, 0.1, 0.4, 0.5, 0.9, 1]$。\n    - 案例 2: $(a, c, b) = (3, 3, 7)$， $u = [0, 0.25, 0.999999, 1]$。\n    - 案例 3: $(a, c, b) = (-2, 1, 1)$， $u = [0, 0.25, 0.8, 1]$。\n    - 案例 4: $(a, c, b) = (0, 1, 2)$， $u = [0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n- **输出格式**：一个单行字符串，表示一个结果列表的列表，不含空格：`[[...],[...],[...],[...]]`。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学性**：该问题基于概率论（PDF、CDF）和计算统计学（反变换采样）的基本、公认原理。三角形分布是一个标准的、无争议的概率分布。此标准已满足。\n- **良态性 (Well-Posed)**：问题提供了所有必要的定义、约束（$a  b$，$a \\le c \\le b$）和一个明确的目标。CDF 及其逆函数（对于连续、严格递增的函数）的存在性和唯一性由数学原理保证。此标准已满足。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或歧义。此标准已满足。\n- **缺陷检查**：问题不违反任何科学定律，是可形式化、完整且可验证的。约束条件是一致的，所要求的任务是明确定义的。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。我将继续进行推导和求解。\n\n任务是为三角形分布推导分位数函数并加以实现。这分为三个阶段：首先，定义概率密度函数 (PDF)；其次，对 PDF 积分求出累积分布函数 (CDF)；第三，对 CDF 求逆得到分位数函数 $F^{-1}(u)$。\n\n**1. 概率密度函数 (PDF), $f(x)$**\n\nPDF $f(x)$ 描述了一个顶点分别为 $(a, 0)$、$(c, h)$ 和 $(b, 0)$ 的三角形，其中 $h$ 是三角形的高度。PDF 下的总面积必须为 $1$。三角形的面积由 $\\frac{1}{2} \\times \\text{底} \\times \\text{高}$ 给出。\n$$\n\\text{面积} = \\frac{1}{2} (b-a) h = 1 \\implies h = \\frac{2}{b-a}\n$$\nPDF 是一个分段线性函数。\n对于 $a \\le x \\le c$，直线通过 $(a, 0)$ 和 $(c, h)$。方程为：\n$$\nf(x) = \\frac{h-0}{c-a} (x-a) = \\frac{2(x-a)}{(b-a)(c-a)}\n$$\n对于 $c  x \\le b$，直线通过 $(c, h)$ 和 $(b, 0)$。方程为：\n$$\nf(x) = h + \\frac{0-h}{b-c} (x-c) = \\frac{2}{b-a} - \\frac{2(x-c)}{(b-a)(b-c)} = \\frac{2(b-c) - 2(x-c)}{(b-a)(b-c)} = \\frac{2(b-x)}{(b-a)(b-c)}\n$$\n综合起来，PDF 为：\n$$\nf(x) = \\begin{cases}\n\\frac{2(x-a)}{(b-a)(c-a)}  \\text{if } a \\le x \\le c \\\\\n\\frac{2(b-x)}{(b-a)(b-c)}  \\text{if } c  x \\le b \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n这些表达式是在假设 $a  c  b$ 的情况下定义的。我们将看到，最终的分位数函数能够正确处理 $c=a$ 和 $c=b$ 的边界情况。\n\n**2. 累积分布函数 (CDF), $F(x)$**\n\nCDF 是 PDF 的积分，即 $F(x) = \\int_{a}^{x} f(t) \\,dt$。\n对于 $x  a$，$F(x)=0$。对于 $x > b$，$F(x)=1$。\n\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_{a}^{x} \\frac{2(t-a)}{(b-a)(c-a)} \\,dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_{a}^{x} = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处，CDF 的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。该值是区间 $[a, c]$ 内的总概率质量。\n\n对于 $c  x \\le b$：\n$$\nF(x) = F(c) + \\int_{c}^{x} \\frac{2(b-t)}{(b-a)(b-c)} \\,dt \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{2}{(b-a)(b-c)} \\left[ -\\frac{(b-t)^2}{2} \\right]_{c}^{x} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n通过化简可以得到一个更简洁的形式：\n$$\nF(x) = \\frac{(c-a)(b-c) + (b-c)^2 - (b-x)^2}{(b-a)(b-c)} = \\frac{(b-c)(c-a+b-c) - (b-x)^2}{(b-a)(b-c)} \\\\\nF(x) = \\frac{(b-c)(b-a) - (b-x)^2}{(b-a)(b-c)} = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n所以，完整的 CDF 是：\n$$\nF(x) = \\begin{cases}\n0  \\text{if } x  a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)}  \\text{if } a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)}  \\text{if } c  x \\le b \\\\\n1  \\text{if } x > b\n\\end{cases}\n$$\n\n**3. 逆 CDF (分位数函数), $F^{-1}(u)$**\n\n要实现反变换采样，我们必须从方程 $u = F(x)$ 中求解 $x$，其中 $u \\in [0, 1]$。\n逆函数的形式取决于 $u$ 是落在对应于 $x \\le c$ 的范围还是 $x > c$ 的范围。划分这两个区域的 $u$ 的临界值是 $u_c = F(c) = \\frac{c-a}{b-a}$。\n\n情况 1：$0 \\le u \\le u_c$ (对应于 $a \\le x \\le c$)\n$$\nu = \\frac{(x-a)^2}{(b-a)(c-a)} \\\\\n(x-a)^2 = u(b-a)(c-a) \\\\\nx-a = \\sqrt{u(b-a)(c-a)} \\quad (\\text{因为 } x \\ge a \\text{，取正根}) \\\\\nx = a + \\sqrt{u(b-a)(c-a)}\n$$\n\n情况 2：$u_c  u \\le 1$ (对应于 $c  x \\le b$)\n$$\nu = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\\\\n(b-x)^2 = (1-u)(b-a)(b-c) \\\\\nb-x = \\sqrt{(1-u)(b-a)(b-c)} \\quad (\\text{因为 } x \\le b \\text{，取正根}) \\\\\nx = b - \\sqrt{(1-u)(b-a)(b-c)}\n$$\n\n最终得到的分位数函数 $F^{-1}(u)$ 是：\n$$\nF^{-1}(u) = \\begin{cases}\na + \\sqrt{u (b-a) (c-a)}  \\text{if } 0 \\le u \\le \\frac{c-a}{b-a} \\\\\nb - \\sqrt{(1-u) (b-a) (b-c)}  \\text{if } \\frac{c-a}{b-a}  u \\le 1\n\\end{cases}\n$$\n这个单一、统一的公式是鲁棒的，并且能正确处理边界情况。\n- 如果 $c=a$，那么 $u_c = \\frac{c-a}{b-a} = 0$。条件 $0 \\le u \\le 0$ 仅对 $u=0$ 成立。对于任何 $u > 0$，使用第二个分支：$x = b - \\sqrt{(1-u) (b-a) (b-a)} = b - (b-a)\\sqrt{1-u}$。这对应于一个峰值在 $a$ 处的直角三角形。\n- 如果 $c=b$，那么 $u_c = \\frac{c-a}{b-a} = 1$。条件 $0 \\le u \\le 1$ 对所有 $u$ 都成立，因此始终使用第一个分支：$x = a + \\sqrt{u (b-a) (b-a)} = a + (b-a)\\sqrt{u}$。这对应于一个峰值在 $b$ 处的直角三角形。\n\n推导是完整且合理的。实现将遵循这个最终公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the inverse transform sampling for a triangular distribution.\n    The final output is printed in the exact required format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'params': (0, 2, 5), 'u_values': [0, 0.1, 0.4, 0.5, 0.9, 1]},\n        # Case 2: Edge case c = a\n        {'params': (3, 3, 7), 'u_values': [0, 0.25, 0.999999, 1]},\n        # Case 3: Edge case c = b\n        {'params': (-2, 1, 1), 'u_values': [0, 0.25, 0.8, 1]},\n        # Case 4: Boundary robustness\n        {'params': (0, 1, 2), 'u_values': [0, 10**-12, 0.5, 1 - 10**-12, 1]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        a, c, b = case['params']\n        u_values = case['u_values']\n        \n        case_results = []\n        \n        # Pre-calculate terms for efficiency and clarity\n        # The problem states a  b, so b - a > 0 is guaranteed.\n        range_ab = b - a\n        range_ac = c - a\n        range_cb = b - c\n        \n        # Calculate the CDF value at the mode, which is the threshold for u\n        # This handles the case where b-a might equal 0 if the problem constraints were different,\n        # but here it's safe.\n        if range_ab == 0:\n            # Degenerate case, not covered by problem statement a  b\n            # but good practice for robustness. All samples are at 'a'.\n            fc = 0.5 # A reasonable default.\n        else:\n            fc = range_ac / range_ab\n        \n        for u in u_values:\n            # Per requirement, clamp u into [0, 1] for numerical robustness.\n            u_clamped = max(0.0, min(1.0, u))\n            \n            x = 0.0\n            # The logic directly implements the derived piecewise inverse CDF.\n            # The comparison u_clamped = fc correctly selects the formula branch,\n            # naturally handling the edge cases c=a (fc=0) and c=b (fc=1).\n            if u_clamped = fc:\n                # This branch corresponds to the interval [a, c]\n                # x = a + sqrt(u * (b-a) * (c-a))\n                # Handle c=a case where range_ac is 0, term is 0, sqrt(0) is 0.\n                term = u_clamped * range_ab * range_ac\n                x = a + np.sqrt(term)\n            else:\n                # This branch corresponds to the interval (c, b]\n                # x = b - sqrt((1-u) * (b-a) * (b-c))\n                # Handle c=b case where range_cb is 0, term is 0, sqrt(0) is 0.\n                term = (1 - u_clamped) * range_ab * range_cb\n                x = b - np.sqrt(term)\n            \n            # Round the result to 10 decimal places as required.\n            case_results.append(round(x, 10))\n            \n        all_results.append(case_results)\n\n    # Format the final output string to the exact required format.\n    # e.g., [[x11,x12,...],[x21,...],[x31,...],[x41,...]] with no spaces.\n    # Convert list of lists to string and remove whitespace.\n    output_string = str(all_results).replace(\" \", \"\")\n    \n    print(output_string)\n\nsolve()\n```", "id": "2403851"}, {"introduction": "在掌握了基础之后，我们来解决一个更实际的问题：从一个由直方图定义的分布中采样。在科学计算中，当我们希望从经验数据或一个任意形状的分布进行模拟时，这是一个非常常见的任务。此练习 [@problem_id:3244347] 完美地展示了逆变换采样法如何灵活地应用于分段常数密度函数，将理论与数据驱动的应用联系起来。", "problem": "考虑一个由非均匀组距的直方图指定的实数区间上的概率分布。该直方图由一个严格递增的组边界序列 $E = [e_0, e_1, \\dots, e_m]$ 和一个正的组高序列 $H = [h_0, h_1, \\dots, h_{m-1}]$ 给出。其解释是，概率密度函数 $f(x)$ 在每个组 $[e_i, e_{i+1})$ 上是分段常数，在该组上 $f(x)$ 与 $h_i$ 成正比，并且在 $[e_0, e_m]$ 之外为零。累积分布函数 $F(x)$ 由基本关系 $F(x) = \\int_{-\\infty}^{x} f(t) \\, dt$ 定义，而逆变换采样法使用累积分布函数的定义来生成样本：如果 $U$ 是 $[0,1)$ 上的一个均匀随机变量，那么可以通过求解 $F(x) = U$ 来获得目标分布的一个样本 $x$。\n\n您的任务是：\n\n- 从第一性原理推导，然后实现一个数值稳定的采样器，该采样器使用逆变换采样法从由 $(E, H)$ 描述的分布中生成独立样本。利用 $f(x)$ 在每个组 $[e_i, e_{i+1})$ 上是分段常数这一性质，并回顾概率密度函数的积分必须为 $1$，这决定了一个归一化常数。\n- 构建一个函数，用于在任意查询点 $x$ 处计算累积分布函数 $F(x)$ 的值，该函数与分段常数 $f(x)$ 和基本定义 $F(x) = \\int_{-\\infty}^x f(t)\\,dt$ 一致。\n- 使用逆变换采样法生成随机样本。为保证可复现性，您必须对每个测试用例使用指定的固定伪随机数生成器种子。本问题不涉及角度，也不涉及任何物理单位。\n\n实现要求：\n\n- 将组高 $h_i$ 视为相对密度高度，这意味着在组 $i$ 上的未归一化密度为 $h_i$，并且归一化因子确保 $\\int f(x)\\,dx = 1$。\n- 确保 $h_i = 0$ 的组不贡献任何概率质量；采样器不应选择这些组。\n- 处理 $F(x)$ 的边界条件，使得当 $x \\le e_0$ 时 $F(x) = 0$，当 $x \\ge e_m$ 时 $F(x) = 1$。\n\n测试套件：\n\n为以下三个测试用例提供结果。对于每个用例，按顺序计算并输出：\n\n$1.$ 归一化常数 $c$，使得在组 $i$ 上 $f(x) = c \\cdot h_i$。\n\n$2.$ 在第一个查询点 $q_1$ 处的累积分布函数值 $F(q_1)$。\n\n$3.$ 在第二个查询点 $q_2$ 处的累积分布函数值 $F(q_2)$。\n\n$4.$ 使用指定种子通过您的逆变换采样器生成的 $N$ 个独立样本的样本均值 $\\bar{x}$。样本均值必须是实值浮点数。\n\n三个用例如下：\n\n- 用例 $1$：$E = [0,1,3,4]$，$H = [2,1,3]$，查询点 $Q = [0.5, 3.2]$，样本大小 $N = 1000$，种子 $S = 314159$。\n- 用例 $2$：$E = [-2,0,0.5,2.5]$，$H = [0,4,1]$，查询点 $Q = [-1.0, 2.0]$，样本大小 $N = 800$，种子 $S = 271828$。\n- 用例 $3$：$E = [0,0.1,1.0]$，$H = [10,0.1]$，查询点 $Q = [0.05, 0.5]$，样本大小 $N = 1200$，种子 $S = 1618033$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。该列表必须按上述顺序包含 $12$ 个浮点数，汇总了三个用例的结果，例如 $[c_1,F_1(q_{1}),F_1(q_{2}),\\bar{x}_1,c_2,F_2(q_{1}),F_2(q_{2}),\\bar{x}_2,c_3,F_3(q_{1}),F_3(q_{2}),\\bar{x}_3]$，不带任何附加文本。所有数字都必须打印为标准十进制浮点数。不需要物理单位或角度单位，结果不应使用百分号表示。输出列表的每个元素都必须是浮点数。", "solution": "为分段常数概率密度函数构建逆变换采样器，始于概率论的核心定义。实线上的概率密度函数 $f(x)$ 必须满足 $\\int_{-\\infty}^{\\infty} f(x)\\,dx = 1$，累积分布函数定义为 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。逆变换采样法利用的原理是：如果 $U$ 是在 $[0,1)$ 上均匀分布的随机变量，并且 $F$ 是一个连续、非递减函数，满足 $F(e_0) = 0$ 和 $\\lim_{x\\to\\infty}F(x) = 1$，那么求解 $F(x) = U$ 会得到一个根据 $f$ 分布的随机样本 $x$。\n\n给定一个具有非均匀组距的直方图，由严格递增的组边界 $E = [e_0, e_1, \\dots, e_m]$ 和组高 $H = [h_0, h_1, \\dots, h_{m-1}]$（其中 $h_i \\ge 0$）描述。其解释是，未归一化的概率密度函数是分段常数：对于 $x \\in [e_i, e_{i+1})$，我们有 $f(x) \\propto h_i$；在 $[e_0, e_m]$ 之外，我们有 $f(x) = 0$。令 $w_i = e_{i+1} - e_i$ 表示组 $i$ 的宽度。归一化常数 $c$ 由 $f(x)$ 在其支撑集上的积分等于 $1$ 的要求确定：\n$$\n\\int_{-\\infty}^{\\infty} f(x)\\,dx = \\sum_{i=0}^{m-1} \\int_{e_i}^{e_{i+1}} c \\cdot h_i \\, dx = c \\sum_{i=0}^{m-1} h_i \\cdot (e_{i+1} - e_i) = 1.\n$$\n因此，\n$$\nc = \\left( \\sum_{i=0}^{m-1} h_i \\cdot (e_{i+1} - e_i) \\right)^{-1}.\n$$\n$h_i = 0$ 的组贡献零质量，除了通过边界外，不影响采样器。\n\n累积分布函数 $F(x)$ 源于定义 $F(x) = \\int_{-\\infty}^{x} f(t)\\,dt$。当 $x \\le e_0$ 时，我们有 $F(x) = 0$。当 $x \\ge e_m$ 时，我们有 $F(x) = 1$。当 $x \\in [e_i, e_{i+1})$ 时，\n$$\nF(x) = \\sum_{j=0}^{i-1} \\int_{e_j}^{e_{j+1}} c h_j \\, dt + \\int_{e_i}^{x} c h_i \\, dt = \\sum_{j=0}^{i-1} c h_j (e_{j+1} - e_j) + c h_i (x - e_i).\n$$\n因此，它是一个在支撑集上从 $0$ 增加到 $1$ 的连续分段线性函数。\n\n为了构建逆变换采样器，我们首先预计算组末端的累积质量：\n$$\nM_i^{\\text{end}} = \\sum_{j=0}^{i} c h_j (e_{j+1} - e_j), \\quad i = 0,1,\\dots,m-1,\n$$\n其中根据归一化有 $M_{m-1}^{\\text{end}} = 1$。令 $M_i^{\\text{start}} = \\sum_{j=0}^{i-1} c h_j (e_{j+1} - e_j)$ 表示到组 $i$ 开始处的累积质量（其中 $M_0^{\\text{start}} = 0$）。给定一个均匀随机变量 $U \\in [0,1)$，我们确定唯一的组索引 $i$，使得 $M_i^{\\text{start}} \\le U  M_i^{\\text{end}}$。此选择步骤可以通过对 $M_i^{\\text{end}}$ 数组进行二分搜索来高效实现。在组 $i$ 内，方程 $F(x) = U$ 变为\n$$\nM_i^{\\text{start}} + c h_i (x - e_i) = U,\n$$\n它可以直接解出 $x$：\n$$\nx = e_i + \\frac{U - M_i^{\\text{start}}}{c h_i}.\n$$\n该公式在 $h_i > 0$ 的前提下有效，这一点是有保证的，因为 $h_i = 0$ 的组质量为零，因此不会被搜索步骤选中。数值稳定性的考虑包括确保 $U$ 位于 $[0,1)$ 内（由于浮点舍入，不等于 $1$），以及使用稳健的搜索过程来处理因组质量为零而导致的重复累积质量值。\n\n分布的解析均值对于验证很有用，并且直接从期望值的定义中导出：\n$$\n\\mathbb{E}[X] = \\int_{-\\infty}^{\\infty} x f(x)\\,dx = \\sum_{i=0}^{m-1} \\int_{e_i}^{e_{i+1}} x \\cdot c h_i \\, dx = c \\sum_{i=0}^{m-1} h_i \\left( \\frac{e_{i+1}^2 - e_i^2}{2} \\right).\n$$\n尽管程序只被要求输出归一化常数、选定的累积分布函数值和样本均值，但该表达式是实现正确性的基础，并在内部用于验证。\n\n算法步骤：\n\n- 验证 $E$ 是严格递增的，并且所有 $h_i \\ge 0$。\n- 计算组宽 $w_i = e_{i+1} - e_i$ 和归一化常数 $c = \\left( \\sum_i h_i w_i \\right)^{-1}$。\n- 计算组末端累积质量 $M_i^{\\text{end}} = \\sum_{j=0}^{i} c h_j w_j$。\n- 通过以下方式实现 $F(x)$：\n  - 如果 $x \\le e_0$，返回 $0$，\n  - 如果 $x \\ge e_m$，返回 $1$，\n  - 否则，定位满足 $e_i \\le x  e_{i+1}$ 的组 $i$ 并计算 $F(x) = M_i^{\\text{start}} + c h_i (x - e_i)$。\n- 通过以下方式实现逆变换采样：\n  - 从 Uniform$(0,1)$ 生成器中抽取 $U$，\n  - 必要时将 $U$ 截断为一个严格小于 $1$ 的值，\n  - 通过对 $M_i^{\\text{end}}$ 进行二分搜索来定位组 $i$，使得 $U  M_i^{\\text{end}}$，\n  - 恢复起始质量 $M_i^{\\text{start}}$ 并计算 $x = e_i + \\frac{U - M_i^{\\text{start}}}{c h_i}$。\n- 对于每个测试用例，计算 $c$，在两个查询点处评估 $F$，并使用指定的种子计算 $N$ 个样本的样本均值以保证可复现性。\n- 按照指定顺序，将这 $12$ 个浮点数输出为单个由方括号括起来的逗号分隔列表。\n\n这种方法完全遵循从概率密度函数和累积分布函数的基本定义推导出的逆变换采样法，并能正确处理非均匀组距和零高度的组。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_normalization_constant(edges, heights):\n    # edges: list of bin edges, strictly increasing\n    # heights: list of nonnegative bin heights (relative densities)\n    widths = np.diff(edges)\n    total = np.dot(heights, widths)\n    if total = 0:\n        raise ValueError(\"Total unnormalized mass must be positive.\")\n    return 1.0 / total\n\ndef compute_cumulative_end_masses(edges, heights, c):\n    widths = np.diff(edges)\n    bin_masses = c * heights * widths\n    cum_end = np.cumsum(bin_masses)\n    return cum_end  # end-of-bin cumulative masses\n\ndef cdf_from_histogram(edges, heights, c, x):\n    # Piecewise linear CDF consistent with piecewise constant PDF\n    e = np.array(edges)\n    h = np.array(heights)\n    if x = e[0]:\n        return 0.0\n    if x >= e[-1]:\n        return 1.0\n    # Find bin i such that e[i] = x  e[i+1]\n    i = np.searchsorted(e, x, side='right') - 1\n    # Compute cumulative mass up to start of bin i\n    widths = np.diff(e)\n    bin_masses = c * h * widths\n    if i > 0:\n        start_mass = float(np.sum(bin_masses[:i]))\n    else:\n        start_mass = 0.0\n    # Contribution within bin i\n    return start_mass + c * h[i] * (x - e[i])\n\ndef inverse_transform_sample(edges, heights, size, seed):\n    # Build cumulative end-of-bin masses to locate bins\n    e = np.array(edges, dtype=float)\n    h = np.array(heights, dtype=float)\n    if np.any(np.diff(e) = 0):\n        raise ValueError(\"Edges must be strictly increasing.\")\n    if np.any(h  0):\n        raise ValueError(\"Heights must be nonnegative.\")\n    c = compute_normalization_constant(e, h)\n    cum_end = compute_cumulative_end_masses(e, h, c)\n    widths = np.diff(e)\n    bin_masses = c * h * widths\n    rng = np.random.default_rng(seed)\n    # Draw uniforms in [0,1)\n    u = rng.random(size=size)\n    # Clip any values that are numerically 1.0 (extremely unlikely) to just below 1.0\n    u = np.minimum(u, np.nextafter(1.0, 0.0))\n    # Locate bin index for each u: find first cum_end > u\n    idx = np.searchsorted(cum_end, u, side='right')\n    # Compute start mass for each selected bin\n    # For idx == 0, start_mass = 0; else start_mass = cum_end[idx-1]\n    start_mass = np.where(idx > 0, cum_end[idx - 1], 0.0)\n    # Compute x for each sample: e[idx] + (u - start_mass)/(c * h[idx])\n    # Ensure heights for selected bins are positive; bins with zero height have zero mass and won't be selected.\n    selected_heights = h[idx]\n    # To be safe, handle any potential zero height (shouldn't occur) by leaving x at left edge\n    denom = c * selected_heights\n    # Avoid divide-by-zero by assigning any zero denom to 1 (and zero numerator), though should not happen.\n    safe_denom = np.where(denom == 0.0, 1.0, denom)\n    offset = (u - start_mass) / safe_denom\n    x = e[idx] + offset\n    return x\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"edges\": [0.0, 1.0, 3.0, 4.0],\n            \"heights\": [2.0, 1.0, 3.0],\n            \"queries\": [0.5, 3.2],\n            \"N\": 1000,\n            \"seed\": 314159\n        },\n        {\n            \"edges\": [-2.0, 0.0, 0.5, 2.5],\n            \"heights\": [0.0, 4.0, 1.0],\n            \"queries\": [-1.0, 2.0],\n            \"N\": 800,\n            \"seed\": 271828\n        },\n        {\n            \"edges\": [0.0, 0.1, 1.0],\n            \"heights\": [10.0, 0.1],\n            \"queries\": [0.05, 0.5],\n            \"N\": 1200,\n            \"seed\": 1618033\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        edges = case[\"edges\"]\n        heights = case[\"heights\"]\n        queries = case[\"queries\"]\n        N = case[\"N\"]\n        seed = case[\"seed\"]\n\n        c = compute_normalization_constant(edges, heights)\n        # Compute CDF values at queries\n        Fq1 = cdf_from_histogram(edges, heights, c, queries[0])\n        Fq2 = cdf_from_histogram(edges, heights, c, queries[1])\n        # Generate samples and compute sample mean\n        samples = inverse_transform_sample(edges, heights, N, seed)\n        sample_mean = float(np.mean(samples))\n\n        results.extend([float(c), float(Fq1), float(Fq2), sample_mean])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244347"}, {"introduction": "最后的练习将探讨一个更高级的场景：一个混合了连续部分和离散点质量（即狄拉克 $\\delta$ 函数）的分布。这种分布在许多物理和工程模型中都会出现。此练习 [@problem_id:2403899] 要求我们仔细思考当累积分布函数（CDF）存在跳跃间断点时，如何应用广义逆变换采样，从而加深我们对该方法理论基础的理解。", "problem": "您需要设计并实现一个逆变换采样器，用于一个由点质量（狄拉克δ函数）和连续分量混合而成的概率分布。目标概率密度为\n$$\np(x) = w\\,\\delta(x - x_0) + (1 - w)\\,f(x),\n$$\n其中 $w \\in [0,1]$，$x_0 \\in \\mathbb{R}$，且 $f(x)$ 在其定义域上是一个合规的概率密度函数。您的推导必须从以下基本定义出发：如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，那么 $X = F^{-1}(U)$ 的累积分布函数为 $F(x)$，其中 $F^{-1}$ 是 $F$ 的广义逆函数。您不得假定任何快捷公式；当累积分布函数因狄拉克δ项而出现跳跃间断点时，您必须推导广义逆采样法则的含义，并展示这如何导出一个每次采样仅使用单个均匀分布随机数的实用算法。\n\n实现一个单一的程序，该程序：\n- 推导、实现并使用一个采样器，该采样器通过每次采样转换一个均匀分布的随机数 $U \\sim \\mathrm{Uniform}(0,1)$ 来从 $p(x)$ 中抽取样本。\n- 支持为连续分量 $f(x)$ 选择以下分布（您必须从第一性原理推导并使用相应的逆累积分布函数）：\n  1. 在 $x \\ge 0$ 上，率参数为 $\\lambda  0$ 的指数分布。\n  2. 在 $[a,b]$ 上，满足 $a  b$ 的均匀分布。\n  3. 在 $x \\in \\mathbb{R}$ 上，位置参数为 $\\mu$、尺度参数为 $s  0$ 的逻辑斯谛分布。\n\n对于每种支持的连续分布，推导并使用 $f(x)$ 的一阶矩和二阶矩的解析表达式，然后使用无意识统计学家法则和混合分布的基本性质推导混合分布的均值和方差。\n\n您的程序必须硬编码并执行以下测试套件。对于每个测试用例，它必须：\n- 每次生成样本时仅使用一个独立的均匀分布随机数，从指定的 $p(x)$ 生成 $N$ 个样本。\n- 计算经验点质量、经验均值和经验方差，其定义分别为：\n  - 在 $x_0$ 处的经验点质量，等于所生成的样本中恰好等于 $x_0$ 的样本所占的比例。\n  - 经验均值 $\\hat{\\mu} = \\frac{1}{N}\\sum_{i=1}^N x_i$。\n  - 经验方差 $\\hat{\\sigma}^2 = \\frac{1}{N}\\sum_{i=1}^N (x_i - \\hat{\\mu})^2$。\n- 使用您推导的公式计算理论点质量 $w$、理论混合均值和理论混合方差。\n- 对于每个指标（点质量、均值、方差），输出一个布尔值，指示经验值是否在理论值的给定绝对容差范围内。\n\n使用以下带有固定种子的测试套件以确保可复现性：\n- 案例 A（$\\mathbb{R}_{\\ge 0}$ 上的通用混合分布）：$w = 0.3$，$x_0 = 1.5$，$f$ 是率参数为 $\\lambda = 2.0$ 的指数分布，$N = 80000$，种子 $314159$。\n- 案例 B（边界条件 $w = 0$）：$w = 0$，$x_0 = -100.0$，$f$ 是在 $[a,b]$ 上的均匀分布，其中 $a = 2.0$，$b = 5.0$，$N = 60000$，种子 $271828$。\n- 案例 C（边界条件 $w = 1$）：$w = 1$，$x_0 = -2.0$，$f$ 是参数为 $\\mu = 0.0$，$s = 1.5$ 的逻辑斯谛分布，$N = 40000$，种子 $161803$。\n- 案例 D（点质量占主导的混合分布）：$w = 0.95$，$x_0 = 0.0$，$f$ 是参数为 $\\mu = -1.0$，$s = 0.8$ 的逻辑斯谛分布，$N = 80000$，种子 $141421$。\n\n使用以下绝对容差：\n- 点质量容差 $\\tau_p = 0.01$。\n- 均值容差 $\\tau_m = 0.02$。\n- 方差容差 $\\tau_v = 0.05$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个测试用例，按以下顺序输出六个项目：经验点质量（浮点数）、经验均值（浮点数）、经验方差（浮点数），然后是三个布尔值，分别表示点质量、均值和方差容差检查的通过/失败情况。将所有测试用例（按 A、B、C、D 的顺序）的输出连接成一个扁平列表。例如，总体结构为\n$$\n[\\hat{p}_A, \\hat{\\mu}_A, \\hat{\\sigma}^2_A, b^p_A, b^\\mu_A, b^\\sigma_A,\\ \\hat{p}_B, \\hat{\\mu}_B, \\hat{\\sigma}^2_B, b^p_B, b^\\mu_B, b^\\sigma_B,\\ \\ldots ].\n$$\n不需要用户输入，也不涉及物理单位。不使用角度。输出必须完全由上面给出的固定种子决定。", "solution": "问题陈述经过验证。\n\n**第一步：提取已知条件**\n- **目标概率密度函数 (PDF):** $p(x) = w\\,\\delta(x - x_0) + (1 - w)\\,f(x)$，其中 $w \\in [0,1]$，$x_0 \\in \\mathbb{R}$，且 $f(x)$ 是一个合规的概率密度函数。\n- **基本原理：** 采样器必须从逆变换采样原理推导得出，即对于均匀分布的随机数 $U \\sim \\mathrm{Uniform}(0,1)$ 和累积分布函数 (CDF) $F(x)$，有 $X = F^{-1}(U)$。$F^{-1}$ 是广义逆累积分布函数。采样器每次采样必须只使用一个均匀分布的随机数。\n- **连续分量 $f(x)$:**\n  1. 在 $x \\ge 0$ 上，率参数为 $\\lambda > 0$ 的指数分布。\n  2. 在 $[a,b]$ 上，满足 $a  b$ 的均匀分布。\n  3. 在 $x \\in \\mathbb{R}$ 上，位置参数为 $\\mu$、尺度参数为 $s > 0$ 的逻辑斯谛分布。\n- **要求的推导:**\n  1. 采样算法本身，须从第一性原理推导。\n  2. 每种指定 $f(x)$ 的逆累积分布函数。\n  3. 每种 $f(x)$ 的一阶矩和二阶矩。\n  4. 混合分布 $p(x)$ 的均值和方差。\n- **测试套件:**\n  - **案例 A:** $w = 0.3$，$x_0 = 1.5$，$f(x)$ 是指数分布($\\lambda = 2.0$)，$N = 80000$，种子 $314159$。\n  - **案例 B:** $w = 0$，$x_0 = -100.0$，$f(x)$ 是均匀分布($a = 2.0, b = 5.0$)，$N = 60000$，种子 $271828$。\n  - **案例 C:** $w = 1$，$x_0 = -2.0$，$f(x)$ 是逻辑斯谛分布($\\mu = 0.0, s = 1.5$)，$N = 40000$，种子 $161803$。\n  - **案例 D:** $w = 0.95$，$x_0 = 0.0$，$f(x)$ 是逻辑斯谛分布($\\mu = -1.0, s = 0.8$)，$N = 80000$，种子 $141421$。\n- **容差:** 点质量 $\\tau_p = 0.01$，均值 $\\tau_m = 0.02$，方差 $\\tau_v = 0.05$。\n- **输出格式:** 一个扁平的浮点数和布尔值列表：$[\\hat{p}_A, \\hat{\\mu}_A, \\hat{\\sigma}^2_A, b^p_A, b^\\mu_A, b^\\sigma_A, \\ldots]$。\n\n**第二步：使用提取的已知条件进行验证**\n1.  **科学依据：** 问题基于混合模型和逆变换采样等完善的统计学方法。所指定的分布（狄拉克δ函数、指数分布、均匀分布、逻辑斯谛分布）是概率论中的标准分布。该问题在根本上是合理的。\n2.  **适定性：** 问题定义了明确的目标（实现并测试一个采样器），并提供了所有必要的参数、约束和测试用例。概率论保证了解的存在性。使用固定种子确保了唯一且可复现的输出。\n3.  **客观性：** 问题以精确的数学和计算术语陈述，没有主观性或歧义。\n\n**第三步：结论与行动**\n问题是**有效的**。它具有科学合理性、适定性、客观性和完整性。将提供完整解决方案。\n\n**推导与求解**\n\n目标是为具有密度 $p(x) = w\\,\\delta(x - x_0) + (1 - w)\\,f(x)$ 的混合概率分布构建一个采样算法，其中 $w$ 是在 $x_0$ 处的点质量的权重，$f(x)$ 是一个连续概率密度。推导过程必须遵循逆变换采样原理。\n\n**1. 从第一性原理推导通用采样算法**\n\n密度 $p(x)$ 的累积分布函数 (CDF) $P(x)$ 由以下积分给出：\n$$\nP(x) = \\int_{-\\infty}^{x} p(t) \\,dt = \\int_{-\\infty}^{x} \\left[ w\\,\\delta(t - x_0) + (1 - w)\\,f(t) \\right] dt\n$$\n根据积分的线性性质，我们有：\n$$\nP(x) = w \\int_{-\\infty}^{x} \\delta(t - x_0) \\,dt + (1 - w) \\int_{-\\infty}^{x} f(t) \\,dt\n$$\n狄拉克δ函数的积分是亥维赛阶跃函数 $H(z)$，当 $z \\ge 0$ 时为 $1$，当 $z  0$ 时为 $0$。密度 $f(t)$ 的积分是它自身的累积分布函数，我们记为 $F_f(x)$。因此，混合分布的累积分布函数是：\n$$\nP(x) = w\\,H(x - x_0) + (1-w)\\,F_f(x)\n$$\n这个累积分布函数在 $x = x_0$ 处有一个大小为 $w$ 的跳跃间断点。逆变换采样原理指出，如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，那么随机变量 $X = P^{-1}(U)$ 的累积分布函数为 $P(x)$。由于阶跃函数和 $P(x)$ 的分段性质，直接通过代数反演求 $P^{-1}$ 是复杂的。\n\n然而，我们可以构建一个算法，然后证明它能正确地根据 $P(x)$ 生成样本，从而证明它是逆变换方法的一个有效实现。这种方法被称为复合方法。该混合分布可以解释为一个两步过程：首先，以概率 $w$ 和 $1-w$ 分别选择一个分量（狄拉克δ函数或连续分布 $f(x)$）；其次，从所选分量中抽取一个样本。这可以用一个均匀分布的随机数来实现。\n\n所提出的算法如下：\n1.  生成一个均匀分布的随机数 $U \\sim \\mathrm{Uniform}(0,1)$。\n2.  如果 $U \\le w$，则样本 $X = x_0$。此分支以概率 $w$ 被选择。\n3.  如果 $U > w$，则从密度 $f(x)$ 中抽取一个样本。此分支以概率 $1-w$ 被选择。为了使用同一个随机数 $U$ 来完成此操作，我们必须将其转换为一个新的在 $[0,1]$ 上的均匀分布随机数。令 $U' = \\frac{U-w}{1-w}$。如果 $U \\sim \\mathrm{Uniform}(w, 1)$，那么 $U' \\sim \\mathrm{Uniform}(0,1)$。然后我们设置样本 $X = F_f^{-1}(U')$，其中 $F_f^{-1}$ 是 $f(x)$ 的逆累积分布函数。\n\n为证明此算法的正确性，我们推导它产生的随机变量 $X$ 的累积分布函数。设这个计算出的累积分布函数为 $P_X(z) = \\mathrm{Pr}(X \\le z)$。使用全概率定律，以 $U$ 的值为条件：\n$$\nP_X(z) = \\mathrm{Pr}(X \\le z | U \\le w)\\mathrm{Pr}(U \\le w) + \\mathrm{Pr}(X \\le z | U > w)\\mathrm{Pr}(U > w)\n$$\n条件的概率为 $\\mathrm{Pr}(U \\le w) = w$ 和 $\\mathrm{Pr}(U > w) = 1-w$。\n- 如果 $U \\le w$，算法将 $X$ 设为 $x_0$。因此，$\\mathrm{Pr}(X \\le z | U \\le w) = \\mathrm{Pr}(x_0 \\le z) = H(z - x_0)$。\n- 如果 $U > w$，算法将 $X$ 设为 $F_f^{-1}(U')$。变量 $U' = \\frac{U-w}{1-w}$ 在 $(0,1)$ 上均匀分布。根据逆变换定理，此分支中生成的变量 $X$ 的累积分布函数为 $F_f(z)$。因此，$\\mathrm{Pr}(X \\le z | U > w) = F_f(z)$。\n\n将这些代入 $P_X(z)$ 的方程中：\n$$\nP_X(z) = H(z - x_0) \\cdot w + F_f(z) \\cdot (1-w)\n$$\n这与目标累积分布函数 $P(x)$ 完全相同。因此，该算法是从 $p(x)$ 采样的正确实现，并且是从逆变换采样原理推导出来的。\n\n**2. 连续分量 $f(x)$ 的分析**\n\n**2.1. 指数分布**\n- **PDF:** $f(x) = \\lambda e^{-\\lambda x}$，对于 $x \\ge 0$；否则为 $0$。\n- **CDF:** $F_f(x) = \\int_0^x \\lambda e^{-\\lambda t} dt = [-e^{-\\lambda t}]_0^x = 1 - e^{-\\lambda x}$，对于 $x \\ge 0$。\n- **逆 CDF:** 令 $u = F_f(x)$。则 $u = 1 - e^{-\\lambda x} \\implies e^{-\\lambda x} = 1 - u \\implies -\\lambda x = \\ln(1-u) \\implies x = -\\frac{\\ln(1-u)}{\\lambda}$。此即 $F_f^{-1}(u)$。\n- **矩:**\n  - 均值: $E_f[X] = \\int_0^\\infty x \\lambda e^{-\\lambda x} dx = \\frac{1}{\\lambda}$。\n  - 二阶矩: $E_f[X^2] = \\int_0^\\infty x^2 \\lambda e^{-\\lambda x} dx = \\frac{2}{\\lambda^2}$。\n\n**2.2. 均匀分布**\n- **PDF:** $f(x) = \\frac{1}{b-a}$，对于 $x \\in [a,b]$；否则为 $0$。\n- **CDF:** $F_f(x) = \\int_a^x \\frac{1}{b-a} dt = \\frac{x-a}{b-a}$，对于 $x \\in [a,b]$。\n- **逆 CDF:** 令 $u = F_f(x)$。则 $u = \\frac{x-a}{b-a} \\implies u(b-a) = x-a \\implies x = a + u(b-a)$。此即 $F_f^{-1}(u)$。\n- **矩:**\n  - 均值: $E_f[X] = \\int_a^b x \\frac{1}{b-a} dx = \\frac{1}{b-a} [\\frac{x^2}{2}]_a^b = \\frac{b^2-a^2}{2(b-a)} = \\frac{a+b}{2}$。\n  - 二阶矩: $E_f[X^2] = \\int_a^b x^2 \\frac{1}{b-a} dx = \\frac{1}{b-a} [\\frac{x^3}{3}]_a^b = \\frac{b^3-a^3}{3(b-a)} = \\frac{a^2+ab+b^2}{3}$。\n\n**2.3. 逻辑斯谛分布**\n- **PDF:** $f(x) = \\frac{e^{-(x-\\mu)/s}}{s(1+e^{-(x-\\mu)/s})^2}$，对于 $x \\in \\mathbb{R}$。\n- **CDF:** $F_f(x) = \\frac{1}{1+e^{-(x-\\mu)/s}}$。\n- **逆 CDF:** 令 $u = F_f(x)$。则 $u = \\frac{1}{1+e^{-(x-\\mu)/s}} \\implies \\frac{1}{u} = 1+e^{-(x-\\mu)/s} \\implies \\frac{1-u}{u} = e^{-(x-\\mu)/s} \\implies \\ln(\\frac{1-u}{u}) = -\\frac{x-\\mu}{s} \\implies x = \\mu - s\\ln(\\frac{1-u}{u}) = \\mu + s\\ln(\\frac{u}{1-u})$。此即 $F_f^{-1}(u)$。\n- **矩:**\n  - 均值: $E_f[X] = \\mu$。\n  - 方差: $\\mathrm{Var}_f(X) = \\frac{\\pi^2 s^2}{3}$。\n  - 二阶矩: $E_f[X^2] = \\mathrm{Var}_f(X) + (E_f[X])^2 = \\frac{\\pi^2 s^2}{3} + \\mu^2$。\n\n**3. 混合分布的矩**\n\n混合分布 $p(x)$ 的矩使用无意识统计学家法则推导。\n\n- **混合分布的均值 ($E[X]$):**\n$$\nE[X] = \\int_{-\\infty}^{\\infty} x\\, p(x) \\,dx = \\int_{-\\infty}^{\\infty} x [w\\,\\delta(x - x_0) + (1 - w)\\,f(x)] \\,dx\n$$\n$$\nE[X] = w \\int_{-\\infty}^{\\infty} x\\,\\delta(x - x_0)\\,dx + (1-w) \\int_{-\\infty}^{\\infty} x\\,f(x)\\,dx\n$$\n根据狄拉克δ函数的筛选性质，第一个积分为 $x_0$。第二个积分是 $f(x)$ 的均值 $E_f[X]$。\n$$\nE[X] = w\\,x_0 + (1-w)\\,E_f[X]\n$$\n\n- **混合分布的二阶矩 ($E[X^2]$):**\n$$\nE[X^2] = \\int_{-\\infty}^{\\infty} x^2 p(x) \\,dx = w \\int_{-\\infty}^{\\infty} x^2 \\delta(x - x_0) \\,dx + (1-w) \\int_{-\\infty}^{\\infty} x^2 f(x)\\,dx\n$$\n第一个积分为 $x_0^2$。第二个积分是 $f(x)$ 的二阶矩 $E_f[X^2]$。\n$$\nE[X^2] = w\\,x_0^2 + (1-w)\\,E_f[X^2]\n$$\n\n- **混合分布的方差 ($\\mathrm{Var}(X)$):**\n方差由标准公式给出，$\\mathrm{Var}(X) = E[X^2] - (E[X])^2$。\n$$\n\\mathrm{Var}(X) = \\left( w\\,x_0^2 + (1-w)\\,E_f[X^2] \\right) - \\left( w\\,x_0 + (1-w)\\,E_f[X] \\right)^2\n$$\n这些公式允许计算每个测试用例的理论均值和方差。\n在 $x_0$ 处的理论点质量概率就是 $w$。\n\n实施将依据这些推导进行。", "answer": "```python\nimport numpy as np\nimport math\n\n# Use a fixed version of the default generator for reproducibility across numpy versions.\n# PCG64 is available in numpy 1.23.5.\nGenerator = np.random.PCG64\n\nclass Distribution:\n    \"\"\"Abstract base class for continuous probability distributions.\"\"\"\n    def inverse_cdf(self, u: np.ndarray) -> np.ndarray:\n        raise NotImplementedError\n\n    def mean(self) -> float:\n        raise NotImplementedError\n\n    def second_moment(self) -> float:\n        raise NotImplementedError\n\nclass Exponential(Distribution):\n    \"\"\"Exponential distribution f(x) = lambda * exp(-lambda * x).\"\"\"\n    def __init__(self, lam: float):\n        if lam = 0:\n            raise ValueError(\"Rate parameter lambda must be positive.\")\n        self.lam = float(lam)\n\n    def inverse_cdf(self, u: np.ndarray) -> np.ndarray:\n        # Derived from u = 1 - exp(-lambda * x)\n        # Using 1-u. For a uniform variate u, 1-u is also uniform.\n        # This form is common, but log(u) is numerically more stable if u can be 1.\n        # Since u is U', it's from (0,1), so no risk of u=1 for inverse_cdf.\n        return -np.log(1.0 - u) / self.lam\n\n    def mean(self) -> float:\n        return 1.0 / self.lam\n\n    def second_moment(self) -> float:\n        return 2.0 / self.lam**2\n\nclass Uniform(Distribution):\n    \"\"\"Uniform distribution f(x) = 1/(b-a) on [a, b].\"\"\"\n    def __init__(self, a: float, b: float):\n        if a >= b:\n            raise ValueError(\"Parameter 'a' must be less than 'b'.\")\n        self.a = float(a)\n        self.b = float(b)\n\n    def inverse_cdf(self, u: np.ndarray) -> np.ndarray:\n        # Derived from u = (x - a) / (b - a)\n        return self.a + u * (self.b - self.a)\n\n    def mean(self) -> float:\n        return (self.a + self.b) / 2.0\n\n    def second_moment(self) -> float:\n        # E[X^2] = (a^2 + ab + b^2) / 3\n        return (self.a**2 + self.a * self.b + self.b**2) / 3.0\n\nclass Logistic(Distribution):\n    \"\"\"Logistic distribution.\"\"\"\n    def __init__(self, mu: float, s: float):\n        if s = 0:\n            raise ValueError(\"Scale parameter 's' must be positive.\")\n        self.mu = float(mu)\n        self.s = float(s)\n\n    def inverse_cdf(self, u: np.ndarray) -> np.ndarray:\n        # Derived from u = 1 / (1 + exp(-(x-mu)/s))\n        # This is x = mu + s * log(u / (1-u))\n        # The input u will be in (0, 1), so no division by zero or log(0).\n        return self.mu + self.s * np.log(u / (1.0 - u))\n\n    def mean(self) -> float:\n        return self.mu\n\n    def second_moment(self) -> float:\n        # E[X^2] = Var(X) + E[X]^2\n        var = (math.pi**2 * self.s**2) / 3.0\n        return var + self.mu**2\n\ndef solve():\n    \"\"\"\n    Main function to execute the test suite for the mixed distribution sampler.\n    \"\"\"\n    test_cases = [\n        {'name': 'A', 'w': 0.3, 'x0': 1.5, 'f_type': 'exp', 'f_params': {'lam': 2.0}, 'N': 80000, 'seed': 314159},\n        {'name': 'B', 'w': 0.0, 'x0': -100.0, 'f_type': 'unif', 'f_params': {'a': 2.0, 'b': 5.0}, 'N': 60000, 'seed': 271828},\n        {'name': 'C', 'w': 1.0, 'x0': -2.0, 'f_type': 'logis', 'f_params': {'mu': 0.0, 's': 1.5}, 'N': 40000, 'seed': 161803},\n        {'name': 'D', 'w': 0.95, 'x0': 0.0, 'f_type': 'logis', 'f_params': {'mu': -1.0, 's': 0.8}, 'N': 80000, 'seed': 141421},\n    ]\n\n    tolerances = {'pm': 0.01, 'mean': 0.02, 'var': 0.05}\n    \n    dist_map = {\n        'exp': Exponential,\n        'unif': Uniform,\n        'logis': Logistic,\n    }\n\n    final_results = []\n\n    for case in test_cases:\n        w = case['w']\n        x0 = case['x0']\n        N = case['N']\n        seed = case['seed']\n        \n        f_dist = dist_map[case['f_type']](**case['f_params'])\n        \n        # --- Generate Samples ---\n        rng = np.random.Generator(Generator(seed))\n        U = rng.random(size=N)\n        samples = np.zeros(N)\n\n        # Boolean mask for the point mass component\n        is_point_mass = U = w\n        \n        # Assign point mass samples\n        samples[is_point_mass] = x0\n        \n        # Handle continuous component\n        # The condition (1-w) > 0 avoids division by zero when w=1\n        num_continuous = np.sum(~is_point_mass)\n        if num_continuous > 0:\n            # Rescale uniform variates for the continuous part\n            U_cont = U[~is_point_mass]\n            U_prime = (U_cont - w) / (1.0 - w)\n            samples[~is_point_mass] = f_dist.inverse_cdf(U_prime)\n\n        # --- Empirical Metrics ---\n        # The fraction of samples exactly equal to x0\n        emp_point_mass = np.sum(samples == x0) / N\n        emp_mean = np.mean(samples)\n        # np.var with ddof=0 calculates population variance (1/N), as required\n        emp_var = np.var(samples)\n\n        # --- Theoretical Metrics ---\n        theo_point_mass = w\n        \n        E_f_X = f_dist.mean()\n        E_f_X2 = f_dist.second_moment()\n        \n        theo_mean = w * x0 + (1.0 - w) * E_f_X\n        E_mix_X2 = w * x0**2 + (1.0 - w) * E_f_X2\n        theo_var = E_mix_X2 - theo_mean**2\n        \n        # --- Tolerance Checks ---\n        pm_ok = abs(emp_point_mass - theo_point_mass) = tolerances['pm']\n        mean_ok = abs(emp_mean - theo_mean) = tolerances['mean']\n        var_ok = abs(emp_var - theo_var) = tolerances['var']\n        \n        # Collect results for this case\n        case_results = [\n            emp_point_mass,\n            emp_mean,\n            emp_var,\n            pm_ok,\n            mean_ok,\n            var_ok\n        ]\n        final_results.extend(case_results)\n\n    # Format output as a single flat list string.\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2403899"}]}