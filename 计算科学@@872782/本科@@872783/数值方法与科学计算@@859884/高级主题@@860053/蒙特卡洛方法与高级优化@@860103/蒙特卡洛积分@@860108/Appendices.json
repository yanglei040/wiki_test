{"hands_on_practices": [{"introduction": "蒙特卡洛积分最直接的应用之一是估算复杂定义域上的多重积分。本练习 [@problem_id:1376816] 模拟了一个现实场景：通过在三维空间中随机采样来计算非均匀分布的物质总质量。这个实践旨在帮助你掌握蒙特卡洛方法的核心思想，即将复杂的解析积分问题转化为一个简单的统计平均问题。", "problem": "一位材料科学家正在研究一种在边长为1米的立方体模具中制造的新型合金。坐标系与模具对齐，使其占据由 $0 \\le x \\le 1$、$0 \\le y \\le 1$ 和 $0 \\le z \\le 1$ 定义的区域。一种特殊硬化剂的浓度 $C$ 被发现在模具中仅在由不等式 $0 \\le z \\le y \\le x \\le 1$ 定义的特定子区域内非零。在此子区域内，点 $(x,y,z)$ 处的浓度由函数 $C(x,y,z) = k x y z$ 描述，其中 $k$ 是一个常数。在此区域外，浓度为零。模具中硬化剂的总质量由浓度函数在整个1立方米模具体积上的积分给出。\n\n为了估计这个总质量，一个自动化测量系统在一组 $N=5$ 个样本点上探测浓度，这些样本点被假定为单位立方体内均匀随机抽样的代表。这五个点的坐标是：\n$P_1 = (0.8, 0.7, 0.2)$\n$P_2 = (0.9, 0.5, 0.6)$\n$P_3 = (0.6, 0.8, 0.3)$\n$P_4 = (0.5, 0.4, 0.3)$\n$P_5 = (0.7, 0.9, 0.8)$\n\n给定浓度常数 $k = 4.8 \\text{ kg/m}^6$，根据这五个样本点的数据，计算模具中硬化剂总质量的数值估计。答案以千克（kg）为单位，并保留三位有效数字。", "solution": "总质量是浓度在单位立方体上的体积分：\n$$\nM=\\iiint_{[0,1]^{3}} C(x,y,z)\\,dV.\n$$\n在体积为 $V=1$ 的域上进行均匀随机抽样，使用 $N$ 个样本 $\\{P_{i}\\}_{i=1}^{N}$ 的蒙特卡罗估计量为\n$$\n\\widehat{M}=\\frac{V}{N}\\sum_{i=1}^{N} C(P_{i})=\\frac{1}{N}\\sum_{i=1}^{N} C(P_{i}).\n$$\n此处，如果 $0 \\le z \\le y \\le x \\le 1$，则 $C(x,y,z)=k\\,x y z$，否则 $C=0$。对每个样本点，判断是否满足条件 $0 \\le z \\le y \\le x \\le 1$：\n- $P_{1}=(0.8,0.7,0.2)$: $0.2 \\le 0.7 \\le 0.8 \\le 1$ 成立，所以贡献为 $k\\cdot 0.8\\cdot 0.7\\cdot 0.2=0.112\\,k$。\n- $P_{2}=(0.9,0.5,0.6)$: $0.6 \\le 0.5$ 不成立，贡献为 $0$。\n- $P_{3}=(0.6,0.8,0.3)$: $0.8 \\le 0.6$ 不成立，贡献为 $0$。\n- $P_{4}=(0.5,0.4,0.3)$: $0.3 \\le 0.4 \\le 0.5 \\le 1$ 成立，贡献为 $k\\cdot 0.5\\cdot 0.4\\cdot 0.3=0.06\\,k$。\n- $P_{5}=(0.7,0.9,0.8)$: $0.9 \\le 0.7$ 不成立，贡献为 $0$。\n因此\n$$\n\\sum_{i=1}^{5} C(P_{i})=(0.112+0.06)\\,k=0.172\\,k,\n$$\n且\n$$\n\\widehat{M}=\\frac{1}{5}\\cdot 0.172\\,k=0.0344\\,k.\n$$\n代入 $k=4.8$ 得到\n$$\n\\widehat{M}=0.0344\\times 4.8=0.16512,\n$$\n保留三位有效数字后，结果为 $0.165$ 千克。", "answer": "$$\\boxed{0.165}$$", "id": "1376816"}, {"introduction": "蒙特卡洛方法的应用远不止计算标准函数的积分，它同样是估算随机事件概率的强大工具。在这个经典的“断棍成三角形”问题 [@problem_id:1376854] 中，你将通过模拟随机过程来估算概率，这在概念上等同于对一个指示函数进行积分。这项练习直观地展示了蒙特卡洛模拟在解决概率论和统计力学等领域中复杂问题时的通用性和力量。", "problem": "一位材料科学家正在研究一种新型聚合物纤维的断裂力学统计特性。作为一个简化模型，他们考虑一根单位长度的纤维，对其施加应力，直到它在两个不同的点上断裂。这两个断裂点的位置，记为 $X_1$ 和 $X_2$，被建模为从区间 $[0, 1]$ 上的均匀分布中抽取的独立随机变量。\n\n这两处断裂将纤维分成三个较短的片段。该科学家旨在确定这三段片段能够构成一个三角形的概率 $P$。为此，他们采用蒙特卡罗模拟。该模拟生成大量的随机断点对 $(X_1, X_2)$，并对每一对计算所产生的三个片段的长度。然后，它检查这些长度是否满足三角形不等式，该不等式指出，三角形任意两边长度之和必须大于第三边长度。\n\n该模拟总共运行了 $N = 2,500,000$ 次试验。实验日志中记录的、片段能够构成有效三角形的试验最终计数为 $N_{\\text{success}} = 624,875$。\n\n根据这次特定的蒙特卡罗模拟的结果，计算估计概率 $P$。将你的答案以保留四位有效数字的小数形式报告。", "solution": "概率的蒙特卡罗估计是成功试验次数与总试验次数之比。将估计量定义为\n$$\n\\hat{P}=\\frac{N_{\\text{success}}}{N}.\n$$\n代入给定的计数，\n$$\n\\hat{P}=\\frac{624875}{2500000}.\n$$\n通过将分子和分母同时除以 $125$ 来化简分数：\n$$\n\\frac{624875}{2500000}=\\frac{125\\cdot 4999}{125\\cdot 20000}=\\frac{4999}{20000}=0.24995.\n$$\n将 $0.24995$ 四舍五入到四位有效数字，得到 $0.2500$。", "answer": "$$\\boxed{0.2500}$$", "id": "1376854"}, {"introduction": "掌握一种数值方法不仅意味着了解如何使用它，更关键的是理解其优势和适用场景。本练习 [@problem_id:3253419] 引导你将蒙特卡洛方法与一种确定性方法（辛普森法则）进行对比，特别是在处理一个带有“尖点”（不可导点）的函数时。通过这个实践，你将深刻体会到蒙特卡洛方法的一个关键优势：其收敛速度与被积函数的光滑度无关，这使其在许多现实世界应用中成为更稳健的选择。", "problem": "您需要实现并分析积分 $$I = \\int_{0}^{1} \\lvert x - 0.3 \\rvert \\, dx$$ 的两种数值估计量，重点关注 $$x = 0.3$$ 处的不可微点（扭折点）如何影响收敛性和方差。请完全在纯数学术语内进行操作：没有物理单位，也没有角度。您的程序必须是自包含的，并且无需任何用户输入即可产生指定的输出。\n\n使用的基本原理：\n- 将确定性积分等同于期望值：对于一个随机变量 $$U \\sim \\mathrm{Uniform}(0,1),$$ $$\\mathbb{E}[f(U)] = \\int_{0}^{1} f(x) \\, dx.$$\n- 独立性条件下蒙特卡罗（MC）估计量的性质。\n- 在具有偶数个子区间的均匀分区上，用于数值积分的复合辛普森法则。\n\n定义 $$f(x) = \\lvert x - 0.3 \\rvert.$$ 考虑使用 $$N$$ 个独立同分布样本 $$U_1, U_2, \\dots, U_N \\sim \\mathrm{Uniform}(0,1)$$ 的蒙特卡罗估计量，以及在 $$[0,1]$$ 上使用 $$m$$ 个均匀子区间的复合辛普森法则，其中 $$m$$ 是一个偶数。重点在于 $$x = 0.3$$ 处的扭折点如何改变误差行为。\n\n您的程序必须执行以下任务：\n1. 从第一性原理出发，解析计算 $$I$$ 的精确值。\n2. 对于蒙特卡罗估计量：\n   - 对每个测试用例使用固定的伪随机数生成器种子，从 $$\\mathrm{Uniform}(0,1)$$ 中抽取 $$N$$ 个样本 $$U_i$$，并计算样本均值 $$\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} f(U_i)$$。\n   - 使用总体约定（除以 $$N$$）计算观测到的 $$f(U_i)$$ 值的样本方差，这样即使在 $$N = 1$$ 时它仍然有定义。\n   - 通过解析推导 $$\\operatorname{Var}(f(U))$$ 来计算理论标准误差 $$\\sqrt{\\operatorname{Var}(f(U))/N}$$。\n3. 对于复合辛普森法则：\n   - 在 $$[0,1]$$ 上实现复合辛普森法则，使用 $$m$$ 个偶数子区间和均匀间距 $$h = 1/m$$。使用标准权重 $$\\frac{h}{3} \\left[f(x_0) + 4 \\sum f(x_{2j+1}) + 2 \\sum f(x_{2j}) + f(x_m)\\right]$$，其中 $$x_k = k h$$。\n   - 计算辛普森近似值 $$S_m$$ 及其相对于精确值 $$I$$ 的绝对误差。\n4. 对于这两种方法，报告相对于精确值 $$I$$ 的绝对误差。\n5. 使用以下测试套件评估不同场景：\n   - 情况 $$1$$（理想情况，扭折点与网格节点对齐）：$$N = 100,$$ $$m = 10,$$ 种子 $$= 12345.$$\n   - 情况 $$2$$（理想情况，扭折点与网格节点不对齐）：$$N = 100,$$ $$m = 12,$$ 种子 $$= 54321.$$\n   - 情况 $$3$$（蒙特卡罗和辛普森法则的边界条件）：$$N = 1,$$ $$m = 2,$$ 种子 $$= 7.$$\n   - 情况 $$4$$（大样本量和细网格，扭折点与网格节点对齐）：$$N = 10000,$$ $$m = 100,$$ 种子 $$= 2025.$$\n   所有 $$m$$ 均为偶数，以满足复合辛普森法则的要求。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是包含七个浮点数的列表，顺序如下：\n- $$\\hat{I}_N$$（蒙特卡罗估计值），\n- 使用除以 $$N$$ 计算的 $$f(U_i)$$ 的样本方差，\n- 理论标准误差 $$\\sqrt{\\operatorname{Var}(f(U))/N},$$\n- $$S_m$$（复合辛普森估计值），\n- 精确值 $$I,$$\n- 蒙特卡罗的绝对误差 $$\\lvert \\hat{I}_N - I \\rvert,$$\n- 辛普森法则的绝对误差 $$\\lvert S_m - I \\rvert.$$\n\n因此，最终输出格式是表示列表的列表的单行，例如 $$[[\\ldots],[\\ldots],[\\ldots],[\\ldots]]$$。", "solution": "在继续之前，对问题进行验证。\n\n### 步骤 1：提取已知条件\n- 待评估积分：$$I = \\int_{0}^{1} \\lvert x - 0.3 \\rvert \\, dx$$。\n- 函数定义：$$f(x) = \\lvert x - 0.3 \\rvert$$。\n- 蒙特卡罗方法的随机变量：$$U \\sim \\mathrm{Uniform}(0,1)$$。\n- 蒙特卡罗估计量：$$\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} f(U_i)$$，其中 $$U_i \\sim \\mathrm{Uniform}(0,1)$$ 独立同分布。\n- 样本方差定义：使用总体约定（除以 $$N$$）。\n- 理论标准误差：$$\\sqrt{\\operatorname{Var}(f(U))/N}$$。\n- 复合辛普森法则：使用 $$m$$ 个偶数子区间，间距为 $$h = 1/m$$，点为 $$x_k = k h$$，公式为 $$S_m = \\frac{h}{3} \\left[f(x_0) + 4 \\sum_{j=0}^{m/2-1} f(x_{2j+1}) + 2 \\sum_{j=1}^{m/2-1} f(x_{2j}) + f(x_m)\\right]$$。\n- 测试用例：\n  - 情况 1：$$N = 100$$, $$m = 10$$, 种子 $$= 12345$$。\n  - 情况 2：$$N = 100$$, $$m = 12$$, 种子 $$= 54321$$。\n  - 情况 3：$$N = 1$$, $$m = 2$$, 种子 $$= 7$$。\n  - 情况 4：$$N = 10000$$, $$m = 100$$, 种子 $$= 2025$$。\n- 每个情况所需的输出：一个包含七个浮点数的列表：$$\\hat{I}_N$$、$$f(U_i)$$ 的样本方差、理论标准误差、$$S_m$$、精确值 $$I$$、蒙特卡罗方法的绝对误差 $$\\lvert \\hat{I}_N - I \\rvert$$、辛普森法则的绝对误差 $$\\lvert S_m - I \\rvert$$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学依据**：该问题是数值分析中的一个标准练习，比较了随机方法（蒙特卡罗）和确定性求积法则（辛普森法则）。函数 $$f(x) = \\lvert x - 0.3 \\rvert$$ 是一个经典的例子，用于说明数值方法在非光滑函数上的行为。所有引用的原理都是数学和科学计算的基础。\n- **适定性**：问题已完全指定。积分定义明确。两种估计量的公式都已明确给出。每个测试用例的所有参数（$$N, m$$，种子）都已提供。样本方差的定义已明确，以避免歧义。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或偏见。\n\n该问题不存在任何无效性缺陷。它是数值方法领域中一个定义明确、可形式化和可验证的问题。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n该解决方案包括三个主要部分：精确值的解析计算、蒙特卡罗估计量的实现以及复合辛普森法则的实现。\n\n#### 1. 解析计算\n\n首先，我们必须计算积分 $$I$$ 的精确值和 $$f(U)$$ 的理论方差，以便对数值方法进行准确评估。\n\n**积分 $$I$$ 的精确值**\n被积函数 $$f(x) = \\lvert x - 0.3 \\rvert$$ 在 $$x = 0.3$$ 处有一个不可微点。为了对其进行积分，我们在此点分割定义域：\n$$I = \\int_{0}^{1} \\lvert x - 0.3 \\rvert \\, dx = \\int_{0}^{0.3} -(x - 0.3) \\, dx + \\int_{0.3}^{1} (x - 0.3) \\, dx$$\n$$I = \\left[ 0.3x - \\frac{x^2}{2} \\right]_{0}^{0.3} + \\left[ \\frac{x^2}{2} - 0.3x \\right]_{0.3}^{1}$$\n$$I = \\left( 0.3^2 - \\frac{0.3^2}{2} \\right) - 0 + \\left( \\frac{1^2}{2} - 0.3 \\cdot 1 \\right) - \\left( \\frac{0.3^2}{2} - 0.3^2 \\right)$$\n$$I = \\left( \\frac{0.09}{2} \\right) + (0.5 - 0.3) - \\left( -\\frac{0.09}{2} \\right) = 0.045 + 0.2 + 0.045 = 0.29$$\n所以，积分的精确值为 $$I = 0.29$$。\n\n**$$f(U)$$ 的理论方差，其中 $$U \\sim \\mathrm{Uniform}(0,1)$$。**\n方差由 $$\\operatorname{Var}(f(U)) = \\mathbb{E}[f(U)^2] - (\\mathbb{E}[f(U)])^2$$ 给出。\n我们已经知道 $$\\mathbb{E}[f(U)] = \\int_{0}^{1} f(x) \\, dx = I = 0.29$$。\n我们计算二阶矩 $$\\mathbb{E}[f(U)^2]$$：\n$$\\mathbb{E}[f(U)^2] = \\int_{0}^{1} f(x)^2 \\, dx = \\int_{0}^{1} (\\lvert x - 0.3 \\rvert)^2 \\, dx = \\int_{0}^{1} (x - 0.3)^2 \\, dx$$\n$$\\mathbb{E}[f(U)^2] = \\int_{0}^{1} (x^2 - 0.6x + 0.09) \\, dx = \\left[ \\frac{x^3}{3} - 0.3x^2 + 0.09x \\right]_{0}^{1}$$\n$$\\mathbb{E}[f(U)^2] = \\left( \\frac{1}{3} - 0.3 + 0.09 \\right) - 0 = \\frac{1}{3} - 0.21 = \\frac{100 - 63}{300} = \\frac{37}{300}$$\n现在，我们可以求出方差：\n$$\\operatorname{Var}(f(U)) = \\frac{37}{300} - (0.29)^2 = \\frac{37}{300} - 0.0841 = \\frac{3700 - 2523}{30000} = \\frac{1177}{30000}$$\n这就是精确的理论方差。\n\n#### 2. 蒙特卡罗积分\n\n蒙特卡罗方法通过在从相关分布中抽取的随机点 $$U_i$$ 上的 $$N$$ 个函数评估的样本均值来估计积分 $$I = \\mathbb{E}[f(U)]$$。\n- **估计量**：$$\\hat{I}_N = \\frac{1}{N} \\sum_{i=1}^{N} f(U_i)$$。\n- **样本方差**：问题指定使用总体公式（除以 $$N$$）：$$\\hat{\\sigma}^2_N = \\frac{1}{N} \\sum_{i=1}^{N} (f(U_i) - \\hat{I}_N)^2$$。这是 NumPy 中的 `ddof=0` 约定。\n- **理论标准误差**：中心极限定理表明，蒙特卡罗估计量的误差近似服从正态分布，其标准差为 $$\\sigma / \\sqrt{N}$$，其中 $$\\sigma^2 = \\operatorname{Var}(f(U))$$。这个量，$$\\sqrt{\\operatorname{Var}(f(U))/N}$$，就是均值的理论标准误差。\n对于每个测试用例，我们将使用给定的种子生成 $$N$$ 个样本，计算估计值 $$\\hat{I}_N$$、其样本方差、理论标准误差以及绝对误差 $$\\lvert \\hat{I}_N - I \\rvert$$。\n\n#### 3. 复合辛普森法则\n\n这是一种确定性求积法则，用分段二次多项式来近似被积函数。\n- **公式**：$$S_m = \\frac{h}{3} \\sum_{j=0}^{m/2-1} \\left( f(x_{2j}) + 4f(x_{2j+1}) + f(x_{2j+2}) \\right)$$，其中 $$h=1/m$$。\n- **收敛性分析**：复合辛普森法则的标准误差界为 $$O(h^4)$$ 或 $$O(m^{-4})$$ 阶，但这依赖于被积函数是四次连续可微的。我们的函数 $$f(x) = \\lvert x-0.3 \\rvert$$ 在 $$x=0.3$$ 处不可微。它的四阶导数在此处无定义。因此，收敛速度将显著慢于 $$O(m^{-4})$$。误差主要由包含扭折点的子区间上的近似所主导。\n- **具体情况**：\n  - 当 $$m=10$$, $$h=0.1$$ 时，扭折点 $$x=0.3$$ 是一个网格点 ($$x_3$$)。误差将被限制在跨越该扭折点的区间 $$[x_2, x_4] = [0.2, 0.4]$$ 上单次应用辛普森法则所产生的误差范围内。\n  - 当 $$m=12$$, $$h=1/12$$ 时，扭折点 $$x=0.3$$ 不是网格点。它位于区间 $$[x_3, x_4] = [0.25, 0.33\\dots]$$ 内。误差将来自于包含此扭折点的区间 $$[x_2, x_4]$$ 上的近似。\n对于每个测试用例，我们构造具有 $$m+1$$ 个点的均匀网格，在这些点上评估 $$f(x)$$，应用求和公式得到 $$S_m$$，并计算绝对误差 $$\\lvert S_m - I \\rvert$$。\n\n这些步骤将针对每个指定的测试用例在 Python 中实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Monte Carlo and Simpson's rule estimators for a\n    given integral with a non-differentiable point.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, m, seed)\n        (100, 10, 12345),\n        (100, 12, 54321),\n        (1, 2, 7),\n        (10000, 100, 2025)\n    ]\n\n    # Analytical values derived in the solution\n    exact_I = 0.29\n    # Theoretical variance Var(f(U)) = 1177 / 30000\n    theoretical_variance = 1177.0 / 30000.0\n\n    # The function to integrate: f(x) = |x - 0.3|\n    def f(x):\n        return np.abs(x - 0.3)\n\n    results = []\n    for N, m, seed in test_cases:\n        # --- Monte Carlo Method ---\n        rng = np.random.default_rng(seed)\n        samples = rng.uniform(0, 1, N)\n        f_samples = f(samples)\n\n        # Monte Carlo estimate\n        I_hat_N = np.mean(f_samples)\n        \n        # Sample variance (population convention, divide by N)\n        # np.var default is ddof=0, which is the population variance.\n        sample_var = np.var(f_samples)\n        \n        # Theoretical standard error of the mean\n        theo_std_err = np.sqrt(theoretical_variance / N)\n        \n        # Absolute error of Monte Carlo estimate\n        mc_abs_err = np.abs(I_hat_N - exact_I)\n\n        # --- Composite Simpson's Rule ---\n        h = 1.0 / m\n        # Generate m+1 points from 0 to 1\n        x_grid = np.linspace(0, 1, m + 1)\n        y_grid = f(x_grid)\n\n        # Simpson's formula: S_m = (h/3) * [f(x_0) + 4*f(x_1) + 2*f(x_2) + ... + f(x_m)]\n        # We can implement this with slicing for efficiency.\n        # Sum of odd-indexed terms: y[1], y[3], ..., y[m-1]\n        sum_odd = np.sum(y_grid[1:-1:2])\n        # Sum of even-indexed terms (excluding endpoints): y[2], y[4], ..., y[m-2]\n        sum_even = np.sum(y_grid[2:-1:2])\n        \n        S_m = (h / 3.0) * (y_grid[0] + y_grid[-1] + 4 * sum_odd + 2 * sum_even)\n\n        # Absolute error of Simpson's estimate\n        simpson_abs_err = np.abs(S_m - exact_I)\n\n        # Collect the seven required values\n        case_result = [\n            I_hat_N,\n            sample_var,\n            theo_std_err,\n            S_m,\n            exact_I,\n            mc_abs_err,\n            simpson_abs_err\n        ]\n        results.append(case_result)\n\n    # Format the final output as a string representing a list of lists.\n    # The default str() for a list includes spaces, which we need to remove\n    # to strictly match the requested format.\n    case_strings = []\n    for res in results:\n        # Using repr() to get a standard representation, can also use f-strings\n        res_str = f\"[{','.join(repr(val) for val in res)}]\"\n        case_strings.append(res_str)\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3253419"}]}