{"hands_on_practices": [{"introduction": "理论是重要的，但检验数值方法的真正标准是实践。这个练习将让你亲手实现并比较两种经典的四阶方法——泰勒级数法和龙格-库塔（RK4）法。通过求解一个简单的初值问题[@problem_id:3282721]，你将直接体会到不同方法在实现复杂度、计算成本和精度之间的权衡，这是评估和选择数值求解器时的核心考量。", "problem": "实现一个完整的程序，该程序使用两种方法在区间 $[0, T]$ 上数值求解初值问题 (IVP) 常微分方程 (ODE) $y'(t) = \\cos(t) + y(t)$，初始条件为 $y(0) = y_0$：一种是4阶 Taylor 级数法，另一种是经典的4阶 Runge–Kutta 方法 (RK4)。您的实现必须从 IVP 的基本定义出发，即对于一个连续可微的右端项 $f(t,y)$，IVP 由 $y'(t) = f(t, y(t))$ 和 $y(t_0) = y_0$ 指定。通过将 $y(t)$ 在 $t_n$ 附近展开 Taylor 级数，并应用链式法则于 $f(t,y) = \\cos(t) + y$，将时间导数 $y^{(k)}(t_n)$ 表示为 $t_n$ 和 $y_n$ 的函数，从而为该 ODE 推导出4阶 Taylor 级数法。通过构建一个4阶段的近似来实现 RK4 方法，其基本思想是通过在中间点进行加权求值来近似每一步上 $f(t,y(t))$ 的积分。除这些基本原理外，不要使用或假设任何快捷公式。\n\n使用精确解析解来评估准确性：通过积分因子法求解线性 IVP $y'(t) - y(t) = \\cos(t)$ 以获得 $y(t)$，然后计算每种数值方法在 $t = T$ 时的绝对误差。将计算成本定义为对基本右端项函数 $f(t,y)$ 的总求值次数（每次调用 $f$ 计为1个单位成本）。$\\cos(\\cdot)$ 和 $\\sin(\\cdot)$ 中使用的角度必须以弧度为单位。\n\n测试套件：\n- 最终时间 $T = 1$。\n- 初始条件 $y_0 \\in \\{0, 1\\}$。\n- 步长 $h \\in \\{1.0, 0.2, 0.1, 0.05, 0.0125\\}$，每个步长的选择都使得步数 $N = T/h$ 为整数。\n\n对于每个测试用例 $(y_0, h)$，计算：\n- Taylor-4 方法在 $t = T$ 时的绝对误差，记为 $E_{\\mathrm{T4}}$。\n- RK4 方法在 $t = T$ 时的绝对误差，记为 $E_{\\mathrm{RK4}}$。\n- Taylor-4 方法的总函数求值成本，记为 $C_{\\mathrm{T4}}$。\n- RK4 方法的总函数求值成本，记为 $C_{\\mathrm{RK4}}$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，格式为一个由方括号括起来的逗号分隔列表。列表中的每个元素对应一个测试用例，本身也是一个形式为 $[E_{\\mathrm{T4}}, E_{\\mathrm{RK4}}, C_{\\mathrm{T4}}, C_{\\mathrm{RK4}}]$ 的列表。例如：$[[e_1,r_1,c_1,d_1],[e_2,r_2,c_2,d_2],\\dots]$。所有数值都应为标准的浮点数或整数类型，不带任何单位符号。", "solution": "用户提供的问题经评估是有效的。这是一个在常微分方程 (ODE) 数值方法标准框架内的适定初值问题 (IVP)。问题陈述具有科学依据、自成体系，并为获得唯一且有意义的解提供了所有必需的参数、定义和约束。\n\n该问题要求在区间 $[0, T]$ 上求解由一阶 ODE $y'(t) = \\cos(t) + y(t)$ 和初始条件 $y(0) = y_0$ 定义的 IVP。这将使用两种不同的4阶数值方法来完成：Taylor 级数法和经典的 Runge-Kutta 方法 (RK4)。这些方法的准确性将以精确解析解为基准进行评估。\n\n### 1. 解析解\n\n该 ODE 是一个一阶线性微分方程，可以写成标准形式 $y'(t) - y(t) = \\cos(t)$。我们使用积分因子 $I(t)$ 来求解。\n\n积分因子由 $I(t) = \\exp\\left(\\int -1 \\, dt\\right) = e^{-t}$ 给出。将 ODE 的标准形式乘以 $I(t)$ 得到：\n$$e^{-t} y'(t) - e^{-t} y(t) = e^{-t} \\cos(t)$$\n左边是乘积 $I(t)y(t) = e^{-t}y(t)$ 的导数：\n$$\\frac{d}{dt}\\left(e^{-t} y(t)\\right) = e^{-t} \\cos(t)$$\n两边对 $t$ 积分：\n$$e^{-t} y(t) = \\int e^{-t} \\cos(t) \\, dt$$\n为计算右侧的积分，我们使用两次分部积分法。设积分为 $J = \\int e^{-t} \\cos(t) \\, dt$。\n首先，设 $u = \\cos(t)$ 和 $dv = e^{-t} dt$，则 $du = -\\sin(t) dt$ 和 $v = -e^{-t}$。\n$$J = -\\cos(t)e^{-t} - \\int (-e^{-t})(-\\sin(t)) \\, dt = -e^{-t}\\cos(t) - \\int e^{-t}\\sin(t) \\, dt$$\n对于剩余的积分，设 $u = \\sin(t)$ 和 $dv = e^{-t} dt$，则 $du = \\cos(t) dt$ 和 $v = -e^{-t}$。\n$$\\int e^{-t}\\sin(t) \\, dt = -\\sin(t)e^{-t} - \\int (-e^{-t})(\\cos(t)) \\, dt = -e^{-t}\\sin(t) + J$$\n将此代回关于 $J$ 的方程中：\n$$J = -e^{-t}\\cos(t) - (-e^{-t}\\sin(t) + J)$$\n$$2J = e^{-t}(\\sin(t) - \\cos(t))$$\n$$J = \\frac{1}{2}e^{-t}(\\sin(t) - \\cos(t)) + C_0$$\n其中 $C_0$ 是积分常数。\n将此结果代回关于 $y(t)$ 的方程中：\n$$e^{-t} y(t) = \\frac{1}{2}e^{-t}(\\sin(t) - \\cos(t)) + C_0$$\n$$y(t) = \\frac{1}{2}(\\sin(t) - \\cos(t)) + C_0 e^{t}$$\n我们应用初始条件 $y(0) = y_0$ 来确定 $C_0$：\n$$y_0 = y(0) = \\frac{1}{2}(\\sin(0) - \\cos(0)) + C_0 e^{0} = \\frac{1}{2}(0 - 1) + C_0 = -\\frac{1}{2} + C_0$$\n因此，$C_0 = y_0 + \\frac{1}{2}$。精确解析解为：\n$$y(t) = \\frac{1}{2}(\\sin(t) - \\cos(t)) + \\left(y_0 + \\frac{1}{2}\\right) e^{t}$$\n\n### 2. 4阶 Taylor 级数法 (T4)\n\nTaylor 级数法是通过将解 $y(t)$ 在点 $t_n$ 附近展开来近似 $t_{n+1} = t_n + h$ 处的值：\n$$y(t_{n+1}) = y(t_n) + h y'(t_n) + \\frac{h^2}{2!} y''(t_n) + \\frac{h^3}{3!} y'''(t_n) + \\frac{h^4}{4!} y^{(4)}(t_n) + O(h^5)$$\n一个4阶方法在此级数的 $h^4$ 项后截断。数值更新法则为：\n$$y_{n+1} = y_n + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + \\frac{h^3}{6} y'''(t_n) + \\frac{h^4}{24} y^{(4)}(t_n)$$\n我们必须将 $y$ 在 $t_n$ 处的导数表示为 $t_n$ 和 $y_n = y(t_n)$ 的函数。给定 $y'(t) = f(t,y) = \\cos(t) + y(t)$，我们通过对 $t$ 重复求全导数来找到更高阶的导数：\n- $y'(t) = \\cos(t) + y(t)$\n- $y''(t) = \\frac{d}{dt}y'(t) = -\\sin(t) + y'(t) = -\\sin(t) + \\cos(t) + y(t)$\n- $y'''(t) = \\frac{d}{dt}y''(t) = -\\cos(t) - \\sin(t) + y'(t) = -\\cos(t) - \\sin(t) + (\\cos(t) + y(t)) = -\\sin(t) + y(t)$\n- $y^{(4)}(t) = \\frac{d}{dt}y'''(t) = -\\cos(t) + y'(t) = -\\cos(t) + (\\cos(t) + y(t)) = y(t)$\n\n将这些代入更新法则，其中 $y_n$ 近似于 $y(t_n)$：\n$y_{n+1} = y_n + h(\\cos(t_n) + y_n) + \\frac{h^2}{2}(-\\sin(t_n) + \\cos(t_n) + y_n) + \\frac{h^3}{6}(-\\sin(t_n) + y_n) + \\frac{h^4}{24}y_n$\n计算成本定义为 $f(t,y)$ 的求值次数。在每一步中，我们必须计算导数。$y'(t_n)$ 的表达式恰好是 $f(t_n, y_n)$。更高阶的导数是使用 $\\sin(t_n)$、$\\cos(t_n)$ 和 $y_n$ 解析地构造的，不需要额外对 $f$ 进行“黑箱”调用。因此，每步的成本是1次 $f$ 的求值。对于 $N = T/h$ 步，总成本为 $C_{\\mathrm{T4}} = N$。\n\n### 3. 经典的4阶 Runge-Kutta 方法 (RK4)\n\nRK4 方法通过在区间 $[t_n, t_{n+1}]$ 内使用四个斜率估计值（$k_1, k_2, k_3, k_4$）的加权平均来近似精确关系 $y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(\\tau, y(\\tau)) d\\tau$ 中的积分。这是一种多阶段方法。\n\n经典的 RK4 方法的阶段定义如下：\n1.  区间开始处的初始斜率估计：\n    $$k_1 = f(t_n, y_n)$$\n2.  区间中点的斜率估计，使用 $k_1$ 来近似该点的 $y$：\n    $$k_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)$$\n3.  一个在区间中点经过修正的斜率估计，此时使用 $k_2$ 来近似 $y$：\n    $$k_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)$$\n4.  区间末端的斜率估计，使用 $k_3$ 来近似 $y$：\n    $$k_4 = f(t_n + h, y_n + h k_3)$$\n\n最终的更新是这些斜率的加权平均，类似于数值积分中的 Simpson 法则：\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n每一步都需要计算 $k_1, k_2, k_3$ 和 $k_4$，每一个都需要对函数 $f(t,y)$ 进行一次求值。因此，每步的成本是4次求值。对于 $N=T/h$ 步，总成本为 $C_{\\mathrm{RK4}} = 4N$。\n\n### 4. 误差与成本总结\n\n- **绝对误差**：对于每种方法，误差是在 $t=T$ 时数值解与解析解之间的绝对差值：$E = |y_{\\text{numerical}}(T) - y_{\\text{analytical}}(T)|$。\n- **计算成本**：对于一个包含 $N=T/h$ 步的模拟：\n    - $C_{\\mathrm{T4}} = N$\n    - $C_{\\mathrm{RK4}} = 4N$\n\n下面的程序将实现这两种方法，为指定的测试套件计算结果，并按要求格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the IVP y' = cos(t) + y using Taylor-4 and RK4 methods,\n    and calculates errors and costs for a given test suite.\n    \"\"\"\n    \n    # Problem parameters from the statement\n    T = 1.0\n    y0_values = [0.0, 1.0]\n    h_values = [1.0, 0.2, 0.1, 0.05, 0.0125]\n\n    # Generate the list of test cases (y0, h)\n    test_cases = [(y0, h) for y0 in y0_values for h in h_values]\n\n    def f(t, y):\n        \"\"\"The right-hand side of the ODE y'(t) = f(t, y).\"\"\"\n        return np.cos(t) + y\n\n    def analytical_solution(t, y0):\n        \"\"\"The exact analytical solution to the IVP.\"\"\"\n        # y(t) = 0.5*(sin(t) - cos(t)) + (y0 + 0.5)*exp(t)\n        return 0.5 * (np.sin(t) - np.cos(t)) + (y0 + 0.5) * np.exp(t)\n\n    def solve_taylor4(y0, T, h):\n        \"\"\"\n        Solves the ODE using the Taylor series method of order 4.\n        The derivatives are specific to y' = cos(t) + y.\n        \"\"\"\n        N = int(round(T / h))\n        t = 0.0\n        y = y0\n        for _ in range(N):\n            # y' = cos(t) + y\n            y_d1 = np.cos(t) + y\n            # y'' = -sin(t) + cos(t) + y\n            y_d2 = -np.sin(t) + np.cos(t) + y\n            # y''' = -sin(t) + y\n            y_d3 = -np.sin(t) + y\n            # y'''' = y\n            y_d4 = y\n            \n            # Update y using the Taylor-4 formula\n            y = y + h * y_d1 + (h**2 / 2.0) * y_d2 + (h**3 / 6.0) * y_d3 + (h**4 / 24.0) * y_d4\n            \n            t += h\n            \n        # Cost is N function evaluations (one evaluation of y' per step).\n        cost = N\n        return y, cost\n\n    def solve_rk4(f, y0, T, h):\n        \"\"\"Solves the ODE using the classical Runge-Kutta method of order 4.\"\"\"\n        N = int(round(T / h))\n        t = 0.0\n        y = y0\n        for _ in range(N):\n            k1 = f(t, y)\n            k2 = f(t + h / 2.0, y + h / 2.0 * k1)\n            k3 = f(t + h / 2.0, y + h / 2.0 * k2)\n            k4 = f(t + h, y + h * k3)\n            \n            y = y + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        # Cost is 4 function evaluations per step.\n        cost = 4 * N\n        return y, cost\n\n    results = []\n    for y0, h in test_cases:\n        # Calculate the exact solution at the final time T\n        y_exact_T = analytical_solution(T, y0)\n        \n        # Solve with Taylor-4 method and compute error/cost\n        y_t4, cost_t4 = solve_taylor4(y0, T, h)\n        error_t4 = np.abs(y_t4 - y_exact_T)\n        \n        # Solve with RK4 method and compute error/cost\n        y_rk4, cost_rk4 = solve_rk4(f, y0, T, h)\n        error_rk4 = np.abs(y_rk4 - y_exact_T)\n        \n        results.append([error_t4, error_rk4, cost_t4, cost_rk4])\n\n    # Format the final output string as specified\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str.replace(\" \", \"\"))\n\nsolve()\n```", "id": "3282721"}, {"introduction": "从单个方程到方程组是数值求解的一大步，它让我们能够模拟真实世界中相互作用的复杂系统。在本练习中，你将应用龙格-库塔方法来求解著名的洛特卡-沃尔泰拉（Lotka-Volterra）竞争模型[@problem_id:3282760]，这是一个描述生物种群动态的经典方程组。通过模拟，你将探索模型参数如何决定物种的最终命运——是共存还是灭绝，从而将抽象的数学工具与具体的生态学问题联系起来。", "problem": "考虑一个由常微分方程组（ODEs）表示的双物种竞争模型的初值问题（IVP）。令 $x(t)$ 和 $y(t)$ 表示在时间 $t$ 两个竞争物种的非负密度。经典的 Lotka–Volterra 竞争模型通过以下方程描述其动力学：\n$$\n\\frac{dx}{dt} = x\\left(r_1 - a_{11} x - a_{12} y\\right), \\quad\n\\frac{dy}{dt} = y\\left(r_2 - a_{21} x - a_{22} y\\right),\n$$\n初始条件为 $x(0) = x_0$ 和 $y(0) = y_0$。在此，$r_1$ 和 $r_2$ 是内禀增长率，$a_{11}, a_{22}$ 是种内竞争系数，而 $a_{12}, a_{21}$ 是种间竞争系数。\n\n从常微分方程（ODEs）的初值问题（IVP）的定义出发，使用固定步长的显式四阶龙格-库塔方法为上述系统实现一个数值求解器。您必须：\n- 将状态向量 $(x,y)$ 在所有 $t \\ge 0$ 时均视为非负；如果数值更新由于离散化误差产生负分量，您必须在每个时间步后立即通过将其替换为 $0$ 来将其投影回非负象限。\n- 使用统一的时间步长 $h$ 从 $t=0$ 积分到 $t=T$，其中 $T$ 和 $h$ 在下面给出。\n- 使用阈值 $\\varepsilon$ 对 $t=T$ 时的长期结果进行如下分类：\n  - 如果 $x(T) > \\varepsilon$ 且 $y(T) > \\varepsilon$（共存），则输出 $2$。\n  - 如果 $x(T) > \\varepsilon$ 且 $y(T) \\le \\varepsilon$（物种 $x$ 存续，物种 $y$ 灭绝），则输出 $1$。\n  - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) > \\varepsilon$（物种 $y$ 存续，物种 $x$ 灭绝），则输出 $-1$。\n  - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) \\le \\varepsilon$（两者均灭绝），则输出 $0$。\n\n对所有测试用例使用以下数值参数：\n- 最终时间 $T = 60$。\n- 时间步长 $h = 0.01$。\n- 阈值 $\\varepsilon = 10^{-8}$。\n\n测试套件包含五组参数集 $(r_1,r_2,a_{11},a_{12},a_{21},a_{22},x_0,y_0)$，用于探究不同的动力学机制：\n1. 预期在中等初始密度下产生共存的案例：\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.2$, $y_0 = 0.2$。\n2. 对物种 $x$ 的种间压力足够强以致其被排斥的案例：\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 1.4$, $a_{21} = 0.3$, $a_{22} = 1.0$, $x_0 = 0.6$, $y_0 = 0.6$。\n3. 对物种 $y$ 的种间压力足够强以致其被排斥的案例：\n   - $r_1 = 1.0$, $r_2 = 1.0$, $a_{11} = 1.0$, $a_{12} = 0.4$, $a_{21} = 1.3$, $a_{22} = 1.0$, $x_0 = 0.4$, $y_0 = 0.7$。\n4. 两种物种的内禀增长率均为负（均趋于灭绝）的案例：\n   - $r_1 = -0.3$, $r_2 = -0.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.5$, $y_0 = 0.5$。\n5. 一个初始种群恰好为零的边界案例：\n   - $r_1 = 1.0$, $r_2 = 1.2$, $a_{11} = 1.0$, $a_{12} = 0.3$, $a_{21} = 0.5$, $a_{22} = 1.0$, $x_0 = 0.3$, $y_0 = 0.0$。\n\n您的程序应生成一行输出，其中包含五个测试用例的分类结果，格式为方括号内以逗号分隔的列表，例如 $[c_1,c_2,c_3,c_4,c_5]$，其中每个 $c_i$ 是为测试用例 $i$ 在 $t=T$ 时计算的整数分类代码。", "solution": "所提出的问题是常微分方程（ODEs）数值分析领域中一个有效的初值问题（IVP）。它在科学上基于已确立的 Lotka–Volterra 竞争模型，提供了所有必需的参数和条件，是适定的，并且是客观且计算上可行的。因此，我们可以着手求解。\n\n问题的核心是确定由以下自治常微分方程组建模的双物种竞争的长期结果：\n$$\n\\begin{align*}\n\\frac{dx}{dt} = x(t) \\left(r_1 - a_{11} x(t) - a_{12} y(t)\\right) \\\\\n\\frac{dy}{dt} = y(t) \\left(r_2 - a_{21} x(t) - a_{22} y(t)\\right)\n\\end{align*}\n$$\n其中 $x(t)$ 和 $y(t)$ 是两个物种在时间 $t$ 的种群密度。该系统受初始条件 $x(0) = x_0$ 和 $y(0) = y_0$ 的约束。这组方程和初始条件构成了该初值问题（IVP）。\n\n为简洁和便于计算实现，我们使用向量 $\\vec{u}(t) = \\begin{pmatrix} x(t) \\\\ y(t) \\end{pmatrix}$ 来表示系统的状态。该初值问题（IVP）可以写成紧凑形式：\n$$\n\\frac{d\\vec{u}}{dt} = \\vec{F}(\\vec{u}(t)), \\quad \\vec{u}(0) = \\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}\n$$\n其中函数 $\\vec{F}: \\mathbb{R}^2 \\to \\mathbb{R}^2$ 是常微分方程组的右侧：\n$$\n\\vec{F}(\\vec{u}) = \\begin{pmatrix} x(r_1 - a_{11} x - a_{12} y) \\\\ y(r_2 - a_{21} x - a_{22} y) \\end{pmatrix}\n$$\n由于该非线性系统通常不具有闭式解析解，我们必须采用数值方法来近似解轨道 $\\vec{u}(t)$ 在区间 $[0, T]$ 上的值。问题指定使用固定时间步长 $h$ 的显式四阶龙格-库塔（RK4）方法。\n\nRK4 方法在给定时间 $t_n = nh$ 的近似值 $\\vec{u}_n$ 的情况下，迭代计算在时间 $t_{n+1} = (n+1)h$ 的真实解 $\\vec{u}(t_{n+1})$ 的近似值 $\\vec{u}_{n+1}$。对于自治系统，更新规则是：\n$$\n\\vec{u}_{n+1} = \\vec{u}_n + \\frac{h}{6}(\\vec{k}_1 + 2\\vec{k}_2 + 2\\vec{k}_3 + \\vec{k}_4)\n$$\n四个中间“斜率” $\\vec{k}_i$ 是函数 $\\vec{F}$ 在时间步内不同点的求值，形成一个加权平均，以达到四阶精度：\n$$\n\\begin{align*}\n\\vec{k}_1 = \\vec{F}(\\vec{u}_n) \\\\\n\\vec{k}_2 = \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_1) \\\\\n\\vec{k}_3 = \\vec{F}(\\vec{u}_n + \\frac{h}{2}\\vec{k}_2) \\\\\n\\vec{k}_4 = \\vec{F}(\\vec{u}_n + h\\vec{k}_3)\n\\end{align*}\n\n该生物模型的一个关键特征是种群密度不能为负。虽然具有非负初始数据的 Lotka–Volterra 方程的精确解保持非负，但数值方法中的离散化误差有时可能导致出现小的负值。为了强制执行这一物理约束，问题要求进行投影步骤。在每个时间步计算之后，计算出的状态向量 $\\vec{u}_{n+1}$ 中的任何负分量都必须设置为 $0$。如果我们令 $\\vec{u}_{n+1}^{\\text{raw}}$ 为 RK4 公式的计算结果，则投影后的状态为：\n$$\n\\vec{u}_{n+1} = \\begin{pmatrix} x_{n+1} \\\\ y_{n+1} \\end{pmatrix} = \\begin{pmatrix} \\max(0, x_{n+1}^{\\text{raw}}) \\\\ \\max(0, y_{n+1}^{\\text{raw}}) \\end{pmatrix}\n$$\n\n解决该问题的整体算法如下：\n1.  对于五个测试用例中的每一个，设置特定的模型参数 $(r_1, r_2, a_{11}, a_{12}, a_{21}, a_{22})$ 和初始条件 $(x_0, y_0)$。\n2.  初始化状态向量 $\\vec{u}_0 = \\begin{pmatrix} x_0 \\\\ y_0 \\end{pmatrix}$。\n3.  设置数值参数：最终时间 $T = 60$，时间步长 $h = 0.01$。所需的步数为 $N = T/h = 6000$。\n4.  从 $n = 0$ 迭代到 $N-1$：\n    a. 使用当前状态 $\\vec{u}_n$ 计算四个 RK4 阶段 $\\vec{k}_1, \\vec{k}_2, \\vec{k}_3, \\vec{k}_4$。\n    b. 使用 RK4 更新公式计算原始的下一个状态 $\\vec{u}_{n+1}^{\\text{raw}}$。\n    c. 应用非负性投影以获得该步的最终状态 $\\vec{u}_{n+1}$。\n5.  经过 $N$ 步后，最终状态为 $\\vec{u}_N \\approx \\vec{u}(T) = \\begin{pmatrix} x(T) \\\\ y(T) \\end{pmatrix}$。\n6.  根据 $\\vec{u}_N$ 的分量和阈值 $\\varepsilon = 10^{-8}$ 对结果进行分类：\n    - 如果 $x(T) > \\varepsilon$ 且 $y(T) > \\varepsilon$，结果为共存（代码 $2$）。\n    - 如果 $x(T) > \\varepsilon$ 且 $y(T) \\le \\varepsilon$，物种 $x$ 存续（代码 $1$）。\n    - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) > \\varepsilon$，物种 $y$ 存续（代码 $-1$）。\n    - 如果 $x(T) \\le \\varepsilon$ 且 $y(T) \\le \\varepsilon$，两个物种均灭绝（代码 $0$）。\n\n然后将此过程应用于五个不同的参数集中的每一个，以生成最终的分类代码列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Lotka-Volterra competition model for five test cases\n    using the RK4 method and classifies the long-term outcome.\n    \"\"\"\n    # Numerical parameters for all test cases\n    T = 60.0\n    h = 0.01\n    epsilon = 1e-8\n\n    # The test suite comprises five parameter sets:\n    # (r1, r2, a11, a12, a21, a22, x0, y0)\n    test_cases = [\n        # 1. Expected coexistence\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.2, 0.2),\n        # 2. Species x is excluded\n        (1.0, 1.0, 1.0, 1.4, 0.3, 1.0, 0.6, 0.6),\n        # 3. Species y is excluded\n        (1.0, 1.0, 1.0, 0.4, 1.3, 1.0, 0.4, 0.7),\n        # 4. Both species go extinct\n        (-0.3, -0.2, 1.0, 0.3, 0.5, 1.0, 0.5, 0.5),\n        # 5. One initial population is zero\n        (1.0, 1.2, 1.0, 0.3, 0.5, 1.0, 0.3, 0.0),\n    ]\n\n    def lotka_volterra_rhs(u, p):\n        \"\"\"\n        Computes the right-hand side of the Lotka-Volterra ODE system.\n        \n        Args:\n            u (np.ndarray): State vector [x, y].\n            p (tuple): Model parameters (r1, r2, a11, a12, a21, a22).\n        \n        Returns:\n            np.ndarray: The derivatives [dx/dt, dy/dt].\n        \"\"\"\n        x, y = u\n        r1, r2, a11, a12, a21, a22 = p\n        dxdt = x * (r1 - a11 * x - a12 * y)\n        dydt = y * (r2 - a21 * x - a22 * y)\n        return np.array([dxdt, dydt])\n\n    results = []\n    num_steps = int(T / h)\n\n    for case in test_cases:\n        r1, r2, a11, a12, a21, a22, x0, y0 = case\n        params = (r1, r2, a11, a12, a21, a22)\n        \n        u = np.array([x0, y0], dtype=np.float64)\n\n        # Time-stepping loop using RK4\n        for _ in range(num_steps):\n            k1 = lotka_volterra_rhs(u, params)\n            k2 = lotka_volterra_rhs(u + 0.5 * h * k1, params)\n            k3 = lotka_volterra_rhs(u + 0.5 * h * k2, params)\n            k4 = lotka_volterra_rhs(u + h * k3, params)\n            \n            u_raw = u + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            # Project to non-negative orthant\n            u = np.maximum(0.0, u_raw)\n        \n        xT, yT = u\n        \n        # Classify the outcome at t=T\n        classification_code = 0\n        if xT > epsilon and yT > epsilon:\n            classification_code = 2  # Coexistence\n        elif xT > epsilon and yT = epsilon:\n            classification_code = 1  # Species x persists\n        elif xT = epsilon and yT > epsilon:\n            classification_code = -1 # Species y persists\n        else: # xT = epsilon and yT = epsilon\n            classification_code = 0  # Both extinct\n            \n        results.append(classification_code)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3282760"}, {"introduction": "许多物理和工程系统不仅包含平滑的连续演化，还包含瞬时发生的离散事件，例如碰撞或开关切换。这个高级练习[@problem_id:3282603]将带你挑战一个典型的混合动力系统：一个弹跳的球。你将学习如何将数值积分器与事件定位算法（求根法）相结合，以精确地找到球撞击地面的时刻，并处理撞击瞬间速度的突变，这是开发能够处理现实世界复杂问题的鲁棒求解器的关键一步。", "problem": "您将为一个带事件检测的一维弹跳球设计并实现一个完整的数值初始值问题（IVP）求解器，该求解器会在每次碰撞时重新启动。目标是精确检测小球撞击地面的事件时间，在撞击时施加恢复系数，然后用碰撞后的速度重新开始积分。该场景由牛顿力学支配，并被表述为一个常微分方程（ODE）初始值问题（IVP）。您必须从基本原理推导出您的方法，然后在一个正确且鲁棒的程序中实现它。\n\n物理设置如下。考虑一个点质量小球在重力和线性空气阻力作用下垂直运动。设 $y(t)$ 为垂直位置，$v(t)$ 为垂直速度。支配力平衡的是牛顿第二定律：$m \\,\\mathrm{d}v/\\mathrm{d}t = \\sum F$，其中重力为 $-m g$，线性阻力为 $-b v$。定义单位质量阻力参数 $\\gamma = b/m$。连续时间模型是一阶系统\n$\n\\frac{\\mathrm{d}y}{\\mathrm{d}t} = v,\\quad\n\\frac{\\mathrm{d}v}{\\mathrm{d}t} = -g - \\gamma v,\n$\n初始条件为 $y(0)=y_0$ 和 $v(0)=v_0$。每当 $y(t)=0$ 且为向下穿过时，发生一次地面碰撞事件。在碰撞时间 $t_e$，碰撞前速度为 $v(t_e^-)$，碰撞后速度由牛顿恢复定律给出：$v(t_e^+) = - r \\, v(t_e^-)$，其中恢复系数 $r \\in [0,1]$。位置保持连续，$y(t_e^+)=0$。\n\n您的程序必须：\n- 从 $t=0$ 开始向前积分系统，使用基于标准显式龙格-库塔方法的积分器设计。使用经典的四阶龙格-库塔方法（RK4）作为基本的时间推进格式。通过步长加倍来控制局部截断误差：比较一个大小为 $h$ 的步长与两个大小为 $h/2$ 的步长的结果，以获得误差估计。根据用户指定的绝对容差和相对容差接受或拒绝步长，并相应地自适应调整 $h$ 以保持稳定性和准确性。\n- 通过在已接受的步长上包围 $y(t)$ 的符号变化来检测地面碰撞事件。当一个事件被包围时，通过在时间上使用二分法对 $y(t)$ 进行求根来精确化事件时间 $t_e$。在精确化过程中，每次对 $y(t)$ 的评估都必须通过使用RK4子步将ODE从左边界数值传播到查询时间来计算。当时间区间的宽度低于一个小的绝对阈值且高度的绝对值低于一个小的绝对阈值时，精确化过程应停止。\n- 在 $t_e$ 时应用恢复定律，将状态重置为 $y(t_e)=0$ 和 $v(t_e) = - r \\, v(t_e^-)$，然后从该事件状态重新启动IVP，继续积分。计算碰撞次数。如果在某次事件中，碰撞后的速率实际上为零，您应停止进一步的积分，因为不会再发生碰撞。\n- 当达到指定的碰撞次数或达到指定的最大时间时，以先到者为准，终止积分。\n\n所有计算必须使用一致的国际单位制（SI）：$y$ 以米为单位，$v$ 以米/秒为单位，$g$ 以米/平方秒为单位，$\\gamma$ 以秒的倒数为单位，时间以秒为单位。不使用角度。您的程序必须以秒为单位报告所请求的输出，并四舍五入到六位小数。\n\n您必须提出并使用具体的数值容差：\n- 绝对容差 $\\mathrm{atol} = 10^{-12}$（以状态单位计）。\n- 相对容差 $\\mathrm{rtol} = 10^{-9}$（无量纲）。\n- 事件时间精确化容差 $\\delta t = 10^{-10}$ 秒和事件高度容差 $\\delta y = 10^{-12}$ 米。\n这些调整必须用于所有测试用例。\n\n测试套件规范。对于下面的每个测试用例，运行您的求解器直到第 $K$ 次碰撞（如果它在最大时间 $T_{\\max}$ 之前发生），并返回第 $K$ 次碰撞的时间 $t_K$，以秒为单位，四舍五入到六位小数。\n\n- 测试用例 A（理想情况，无阻力）：\n  - 参数：$y_0 = 10.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.8$, $K = 3$, $T_{\\max} = 30.0$ s。\n- 测试用例 B（有阻力，向上初速度）：\n  - 参数：$y_0 = 20.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.1$ s$^{-1}$, $r = 0.9$, $K = 2$, $T_{\\max} = 40.0$ s。\n- 测试用例 C（边界情况，从地面开始但向上运动）：\n  - 参数：$y_0 = 0.0$ m, $v_0 = 5.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.6$, $K = 2$, $T_{\\max} = 20.0$ s。\n- 测试用例 D（边界情况，完全非弹性碰撞）：\n  - 参数：$y_0 = 1.0$ m, $v_0 = 0.0$ m/s, $g = 9.81$ m/s$^2$, $\\gamma = 0.0$ s$^{-1}$, $r = 0.0$, $K = 1$, $T_{\\max} = 10.0$ s。\n\n最终输出格式。您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[resultA,resultB,resultC,resultD]”）。具体来说，对于A、B、C和D这四个测试用例，按顺序输出 $[t_3^{(A)}, t_2^{(B)}, t_2^{(C)}, t_1^{(D)}]$，以秒为单位，四舍五入到六位小数，不含任何附加文本。", "solution": "我们根据物理原理和数值分析基础来构建求解器。物理基础是牛顿第二定律 $m \\,\\mathrm{d}v/\\mathrm{d}t = \\sum F$。对于有重力和线性阻力的垂直运动，力为 $-m g$ 和 $- b v$，因此 $m \\,\\mathrm{d}v/\\mathrm{d}t = -m g - b v$。引入 $\\gamma = b/m$ 得到 $\\mathrm{d}v/\\mathrm{d}t = -g - \\gamma v$。运动学恒等式 $\\mathrm{d}y/\\mathrm{d}t = v$ 闭合该一阶系统\n$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\n\\begin{bmatrix}\ny \\\\ v\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv \\\\\n- g - \\gamma v\n\\end{bmatrix},\n$\n初始状态为 $\\begin{bmatrix} y(0) \\\\ v(0) \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ v_0 \\end{bmatrix}$。\n\n当下降过程中到达地面 $y=0$ 时，发生一次事件：$y(t_e) = 0$ 且 $v(t_e^-)  0$。碰撞被建模为瞬时发生，具有位置连续性 $y(t_e^+) = 0$ 和速度跳变 $v(t_e^+) = - r \\, v(t_e^-)$。对于 $r \\in [0,1]$，能量在碰撞时减少；对于 $r=0$，运动在第一次碰撞时停止。\n\n我们必须设计一个能够积分初始值问题（IVP）并精确检测事件时间的求解器。我们使用显式四阶龙格-库塔方法（RK4），这是一种针对光滑右端项且经过充分测试的积分器：\n$\n\\mathbf{k}_1 = f(t_n,\\mathbf{y}_n),\\;\n\\mathbf{k}_2 = f(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_1),\\;\n\\mathbf{k}_3 = f(t_n+\\tfrac{h}{2}, \\mathbf{y}_n + \\tfrac{h}{2}\\mathbf{k}_2),\\;\n\\mathbf{k}_4 = f(t_n+h, \\mathbf{y}_n + h \\mathbf{k}_3),\n$\n$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\tfrac{h}{6}\\left(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4\\right).\n$\n为了在不依赖预先制表的嵌入对的情况下控制局部误差，我们应用步长加倍法：使用一个大小为 $h$ 的RK4步长计算 $\\mathbf{y}^{(1)}$，并使用两个大小为 $h/2$ 的RK4步长计算 $\\mathbf{y}^{(2)}$。差值 $\\delta = \\|\\mathbf{y}^{(2)} - \\mathbf{y}^{(1)}\\|_{\\infty}$ 估计了局部截断误差。如果 $\\delta \\le \\mathrm{atol} + \\mathrm{rtol}\\,\\|\\mathbf{y}^{(2)}\\|_{\\infty}$，我们接受这两个半步的解；否则，我们拒绝该步并减小 $h$。接受后，我们可以适度增加 $h$ 以提高效率，同时保持在容差范围内。\n\n事件检测按如下方式处理。在从 $(t_n,\\mathbf{y}_n)$ 到 $(t_{n+1},\\mathbf{y}_{n+1})$ 的每一步被接受后，我们检查高度分量 $y$ 的符号。如果 $y_n > 0$ 且 $y_{n+1} \\le 0$，则一个事件被包围在 $[t_n,t_{n+1}]$ 区间内。然后我们通过对时间进行二分法来精确化事件时间 $t_e$：\n- 维持一个左边界 $(t_L,\\mathbf{y}_L)$（其中 $y_L0$）和一个右边界 $(t_R,\\mathbf{y}_R)$（其中 $y_R \\le 0$）。\n- 在每次精确化迭代中，选择 $t_M=(t_L+t_R)/2$ 并通过使用具有固定小数目子步长的RK4方法从 $(t_L,\\mathbf{y}_L)$ 数值传播到 $t_M$ 来计算 $\\mathbf{y}_M$，以确保精度。如果 $y_M0$，则将左边界更新为 $(t_M,\\mathbf{y}_M)$；否则，将右边界更新为 $(t_M,\\mathbf{y}_M)$。\n- 当 $t_R-t_L \\le \\delta t$ 且 $|y_M| \\le \\delta y$ 时终止。精确化后的事件时间为 $t_e \\approx t_R$，碰撞前状态为 $\\mathbf{y}(t_e^-)\\approx \\mathbf{y}_R$。\n在事件发生时，我们精确地设置 $y(t_e)=0$ 并计算碰撞后速度 $v(t_e^+)=-r\\,v(t_e^-)$。从 $(t_e,[0, v(t_e^+)])$ 重新启动IVP。如果碰撞后速率极小，例如 $|v(t_e^+)| \\le 10^{-12}$，我们停止进一步积分，因为不会再发生碰撞。\n\n正确性和一致性检查源于特殊情况下的基本解。在无阻力情况 $\\gamma=0$ 下，两次碰撞之间的运动是抛体运动，满足 $\\mathrm{d}^2 y/\\mathrm{d}t^2 = -g$。如果 $y_00$ 且 $v_0 \\ge 0$，则第一次碰撞时间为\n$\nt_1 = \\frac{v_0 + \\sqrt{v_0^2 + 2 g y_0}}{g}.\n$\n设碰撞前速度为 $v_1^- = -\\sqrt{v_0^2 + 2 g y_0}$，则 $v_1^+ = r \\sqrt{v_0^2 + 2 g y_0}$。下一次飞行具有对称的上升和下降过程，碰撞间的时间增量为 $\\Delta t = 2 v_1^+/g$。如果 $\\gamma=0$，后续的碰撞时间增量会形成一个公比为 $r, r^2, \\dots$ 的等比数列。我们的数值方法必须在容差范围内再现这些值。例如，在 $y_0=0$ 和 $v_00$ 且 $\\gamma=0$ 的特殊情况下，第一次碰撞时间为 $t_1 = 2 v_0/g$，第二次为 $t_2 = t_1 + 2 r v_0/g$。\n\n在存在线性阻力 $\\gamma0$ 的情况下，两次碰撞之间的解不再对称，对于一般的初始数据，碰撞间时间的闭式解不能用初等函数简单表示。上述事件驱动的数值方法仍然适用且准确，因为右端项是光滑的，并且二分法精确化过程使用了由ODE本身定义的流映射，从而确保了对 $y(t)=0$ 的一致性求根。\n\n算法设计总结：\n- 使用带步长加倍的RK4进行自适应控制，绝对容差 $\\mathrm{atol}=10^{-12}$，相对容差 $\\mathrm{rtol}=10^{-9}$。\n- 通过在已接受步长上 $y$ 的符号变化来检测事件。\n- 使用带数值传播的时间二分法来精确化事件时间，容差为 $\\delta t=10^{-10}$ 秒和 $\\delta y=10^{-12}$ 米。\n- 在每次事件中应用 $v^+ = - r v^-$，在事件发生时设置 $y=0$，然后重新启动。\n- 在达到第 $K$ 次碰撞或超过 $T_{\\max}$ 时终止。\n\n最终输出是测试套件所要求的事件时间，以秒为单位，四舍五入到六位小数，并按指定的顺序和格式汇总。此设计直接反映了常微分方程（ODE）的初始值问题（IVP）的表述，遵守物理定律，并通过有原则的误差控制和求根方法确保了数值的鲁棒性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dynamics(t, state, g, gamma):\n    # state = [y, v]\n    y, v = state\n    dy = v\n    dv = -g - gamma * v\n    return np.array([dy, dv], dtype=float)\n\ndef rk4_step(f, t, y, h, args):\n    k1 = f(t, y, *args)\n    k2 = f(t + 0.5*h, y + 0.5*h*k1, *args)\n    k3 = f(t + 0.5*h, y + 0.5*h*k2, *args)\n    k4 = f(t + h, y + h*k3, *args)\n    return y + (h/6.0)*(k1 + 2*k2 + 2*k3 + k4)\n\ndef rk4_step_doubling(f, t, y, h, args):\n    # One full step\n    y1 = rk4_step(f, t, y, h, args)\n    # Two half steps\n    y_half = rk4_step(f, t, y, 0.5*h, args)\n    y2 = rk4_step(f, t + 0.5*h, y_half, 0.5*h, args)\n    # Error estimate\n    err = np.max(np.abs(y2 - y1))\n    return y2, err\n\ndef integrate_segment(f, t0, y0, t1, args, nsub=12):\n    # Propagate from (t0, y0) to t1 using nsub RK4 substeps\n    t = t0\n    y = y0.copy()\n    dt = t1 - t0\n    if dt == 0.0:\n        return y\n    h = dt / float(nsub)\n    for _ in range(nsub):\n        y = rk4_step(f, t, y, h, args)\n        t += h\n    return y\n\ndef refine_event_bisection(f, tL, yL, tR, yR, args, tol_t, tol_y):\n    # Assumes yL[0] > 0 and yR[0] = 0\n    left_t = tL\n    left_y = yL.copy()\n    right_t = tR\n    right_y = yR.copy()\n    # Use bisection with numerical propagation from left\n    while (right_t - left_t) > tol_t:\n        mid_t = 0.5*(left_t + right_t)\n        # Propagate from left to mid\n        mid_y = integrate_segment(f, left_t, left_y, mid_t, args, nsub=12)\n        ymid = mid_y[0]\n        if abs(ymid) = tol_y:\n            # Close enough in height; choose mid as right bracket\n            right_t = mid_t\n            right_y = mid_y\n            break\n        if ymid > 0.0:\n            left_t = mid_t\n            left_y = mid_y\n        else:\n            right_t = mid_t\n            right_y = mid_y\n    # Ensure right_y corresponds to y = 0 (or near zero)\n    return right_t, right_y\n\ndef simulate_bouncing_ball(y0, v0, g, gamma, r, K, t_max,\n                           atol=1e-12, rtol=1e-9,\n                           event_tol_t=1e-10, event_tol_y=1e-12):\n    # Initial state\n    t = 0.0\n    y = np.array([y0, v0], dtype=float)\n    impacts = 0\n    impact_times = []\n\n    # Initial step size guess based on time scales\n    # Use a conservative initial step\n    h = 0.01\n    h_min = 1e-8\n    h_max = 0.2\n\n    # Helper for norm\n    def norm_inf(vec):\n        return float(np.max(np.abs(vec)))\n\n    # Main integration loop\n    while t  t_max and impacts  K:\n        # Adjust step not to overrun t_max\n        h = min(h, t_max - t)\n        if h  h_min:\n            h = h_min\n\n        # Take a trial step with error estimation\n        y_new, err = rk4_step_doubling(dynamics, t, y, h, (g, gamma))\n        ynew_val = y_new[0]\n        tol = atol + rtol * max(norm_inf(y_new), 1.0)\n\n        if err = tol or h = h_min*1.01:\n            # Accept step\n            t_new = t + h\n            # Event detection: look for crossing from y>0 to y=0\n            y_old_val = y[0]\n            if y_old_val >= 0.0 and ynew_val = 0.0 and y[1]  0:\n                # Refine event time within [t, t_new]\n                yR = y_new.copy()\n                t_e, state_e_minus = refine_event_bisection(\n                    dynamics, t, y, t_new, yR, (g, gamma), event_tol_t, event_tol_y\n                )\n                # Compute post-impact state\n                v_minus = state_e_minus[1]\n                v_plus = -r * v_minus\n                # Register impact\n                impacts += 1\n                impact_times.append(t_e)\n                # Restart at event\n                t = t_e\n                y = np.array([0.0, v_plus], dtype=float)\n                # If the bounce has essentially zero speed, stop\n                if abs(v_plus) = 1e-12:\n                    break\n                # Reduce step after event to be safe\n                h = max(h_min*10, min(h*0.5, h_max))\n                continue\n            else:\n                # No event, advance\n                t = t_new\n                y = y_new\n                # Attempt to increase step slightly if error is small\n                if err  0.1 * tol:\n                    h = min(h * 1.5, h_max)\n                else:\n                    # Keep h or slightly reduce\n                    h = min(h, h_max)\n        else:\n            # Reject step and decrease h\n            # Scale h down; use a safety factor\n            factor = 0.5\n            h = max(h * factor, h_min)\n\n    if len(impact_times) >= K:\n        return impact_times[K-1]\n    else:\n        return t_max\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (y0, v0, g, gamma, r, K, T_max)\n    test_cases = [\n        (10.0, 0.0, 9.81, 0.0, 0.8, 3, 30.0),  # A\n        (20.0, 5.0, 9.81, 0.1, 0.9, 2, 40.0),  # B\n        (0.0, 5.0, 9.81, 0.0, 0.6, 2, 20.0),   # C\n        (1.0, 0.0, 9.81, 0.0, 0.0, 1, 10.0),   # D\n    ]\n\n    results = []\n    for case in test_cases:\n        y0, v0, g, gamma, r, K, tmax = case\n        t_k = simulate_bouncing_ball(y0, v0, g, gamma, r, K, tmax)\n        results.append(t_k)\n\n    # Final print statement in the exact required format with six decimals.\n    print(f\"[{','.join(f'{x:.6f}' for x in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3282603"}]}