{"hands_on_practices": [{"introduction": "理解步长 $h$、方法阶数 $p$ 与全局截断误差 $E(h)$ 之间的关系是数值分析的基础。本练习通过一个概念性问题，旨在快速检验您对这一核心关系的理解 [@problem_id:2185101]。通过预测当步长改变时误差如何变化，您可以巩固对收敛阶数实际含义的掌握。", "problem": "一位数值分析家正在研究一种用于求解固定区间上常微分方程的稳定数值方法的精度。已知该方法为二阶方法。\n\n在第一次计算实验中，该分析家使用常数步长 $h$ 计算求解，并发现区间末端的全局截断误差约为 $\\epsilon$。\n\n在第二次实验中，该分析家决定将步长改为 $2h$，同时保持所有其他参数和微分方程不变。假设该方法保持稳定，并且全局误差与步长之间的关系在此范围内成立，那么这次实验的估计全局截断误差是多少？\n\nA. $\\frac{\\epsilon}{4}$\n\nB. $\\frac{\\epsilon}{2}$\n\nC. $\\epsilon$\n\nD. $2\\epsilon$\n\nE. $4\\epsilon$", "solution": "对于一个 $p$ 阶的稳定方法，在固定的最终时间点，其全局截断误差与步长 $h$ 的关系为 $E(h)=C h^{p}$，其中 $C$ 是一个与 $h$ 无关的常数，前提是该方法保持稳定且渐近误差关系成立。\n\n鉴于该方法是二阶的，所以 $p=2$。对于步长 $h$，观测到的全局误差为 $\\epsilon$，所以\n$$\n\\epsilon = C h^{2}.\n$$\n如果步长变为 $2h$，新的全局误差为\n$$\nE(2h) = C (2h)^{2} = 4 C h^{2} = 4 \\epsilon.\n$$\n因此，将步长加倍会使全局误差乘以 $4$，这对应于选项 E。", "answer": "$$\\boxed{E}$$", "id": "2185101"}, {"introduction": "理论公式 $E(h) \\approx C h^p$ 非常强大，但我们如何为一个给定的方法和问题来验证它呢？这个动手练习将引导您完成经验证的过程 [@problem_id:3236754]。您将实现广泛使用的四阶龙格-库塔方法，并利用数值实验数据来估计方法的阶数 $p$，从而掌握验证计算模型的一项关键技能。", "problem": "考虑由常微分方程 $y^{\\prime}(t) = f(t, y)$ 和初始条件 $y(t_{0}) = y_{0}$ 定义的初值问题。显式经典四阶龙格-库塔（RK4）方法是一种四阶段单步法，它通过在 $t_{n}$、$t_{n} + \\frac{h}{2}$ 和 $t_{n} + h$ 处对 $f$ 进行阶段求值，将数值解 $y_{n}$ 从时间 $t_{n}$推进到 $t_{n+1} = t_{n} + h$。在最终时间 $T$ 处，与均匀步长 $h$ 相关的全局截断误差定义为 $e(h) = \\left|y_{N} - y_{\\mathrm{exact}}(T)\\right|$，其中 $N = \\frac{T - t_{0}}{h}$，$y_{N}$ 是 RK4 方法经过 $N$ 步后产生的数值近似解。\n\n您的任务是通过拟合多个步长 $h$ 下观测到的误差 $e(h)$，并在对数-对数尺度上进行线性拟合，来经验性地重建 RK4 方法的全局截断误差规律，从而推断出经验阶数 $p$ 和首项常数 $C$。具体来说，对于下面的每个测试用例，您必须：\n- 实现一个求解器，对于每个给定的步长 $h$，计算在最终时间 $T$ 处的 RK4 数值解，并评估相应的误差 $e(h)$。\n- 使用自然对数，通过对给定步长集合进行最小二乘法来拟合模型 $\\log\\left(e(h)\\right) = \\log(C) + p \\,\\log(h)$，从而推断出 $p$ 和 $C$。\n- 按照本说明末尾指定的确切输出格式，汇总所有测试用例推断出的 $\\left[p, C\\right]$。\n\n使用和证明的基础理论：初值问题的定义 $y^{\\prime}(t) = f(t, y)$ 及 $y(t_{0}) = y_{0}$，全局截断误差 $e(h)$ 定义为在 $T$ 时刻数值解与精确解之间的差异，以及在对数-对-数尺度上对幂律关系的经验线性化。\n\n用于评估和拟合经验误差定律的测试套件：\n- 测试用例 1：$f(t, y) = y$, $t_{0} = 0$, $y_{0} = 1$, $T = 1$, 精确解 $y_{\\mathrm{exact}}(t) = e^{t}$，步长 $h \\in \\left\\{0.5, 0.25, 0.125, 0.0625\\right\\}$。\n- 测试用例 2：$f(t, y) = -3\\,y$, $t_{0} = 0$, $y_{0} = 2$, $T = 2$, 精确解 $y_{\\mathrm{exact}}(t) = 2\\,e^{-3t}$，步长 $h \\in \\left\\{0.5, 0.25, 0.125, 0.0625\\right\\}$。\n- 测试用例 3：$f(t, y) = y + t$, $t_{0} = 0$, $y_{0} = 0$, $T = 0.8$, 精确解 $y_{\\mathrm{exact}}(t) = e^{t} - t - 1$，步长 $h \\in \\left\\{0.4, 0.2, 0.1, 0.05\\right\\}$。\n- 测试用例 4：$f(t, y) = -5\\,y$, $t_{0} = 0$, $y_{0} = 1$, $T = 1$, 精确解 $y_{\\mathrm{exact}}(t) = e^{-5t}$，步长 $h \\in \\left\\{0.1, 0.05, 0.025, 0.0125\\right\\}$。\n\n所有时间量均为无量纲。不涉及物理单位。不出现角度。您的程序必须：\n- 对 $\\left(\\log(h), \\log(e(h))\\right)$ 数据对使用自然对数进行最小二乘拟合。\n- 生成单行输出，其中包含所有测试用例的结果，格式为方括号内包含的逗号分隔列表，每个测试用例贡献一个双元素列表 $\\left[p, C\\right]$。例如，要求的格式是 $\\left[\\left[p_{1}, C_{1}\\right], \\left[p_{2}, C_{2}\\right], \\left[p_{3}, C_{3}\\right], \\left[p_{4}, C_{4}\\right]\\right]$。\n- 以浮点数形式报告数值。不要求四舍五入或特定的有效数字位数。\n\n您的最终答案必须是一个完整的、可运行的程序，该程序执行这些计算并仅打印指定的输出行。", "solution": "该问题要求经验性地确定经典四阶龙格-库塔（RK4）方法的全局截断误差规律。对于一个 $p$ 阶数值方法，当使用步长 $h$ 时，在固定的最终时间 $T$ 产生的全局误差 $e(h)$，预计在 $h$ 足够小的情况下遵循幂律关系 $e(h) \\approx C h^p$。这里，$C$ 是一个常数，它取决于微分方程和最终时间 $T$，但与 $h$ 无关。目标是通过对变换后的误差数据进行线性回归，来确定几个初值问题的阶数 $p$ 和常数 $C$ 的经验值。\n\n初值问题由常微分方程（ODE）$y^{\\prime}(t) = f(t, y)$ 和初始条件 $y(t_0) = y_0$ 给出。\n\n数值求解的核心是 RK4 方法，它是一种单步、四阶段的显式方法。为了将解从 $(t_n, y_n)$ 推进到 $(t_{n+1}, y_{n+1})$，其中 $t_{n+1} = t_n + h$，该方法计算四个中间斜率估计值（阶段）$k_1, k_2, k_3, k_4$：\n$$k_1 = f(t_n, y_n)$$\n$$k_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)$$\n$$k_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)$$\n$$k_4 = f(t_n + h, y_n + hk_3)$$\n然后使用这些斜率的加权平均值来更新解：\n$$y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)$$\n\n为了确定误差模型 $e(h) \\approx C h^p$ 中的参数 $p$ 和 $C$，我们通过对两边取自然对数来线性化该关系：\n$$\\log(e(h)) \\approx \\log(C h^p) = \\log(C) + \\log(h^p) = \\log(C) + p \\log(h)$$\n该方程具有直线形式 $Y = mX + b$，其中 $Y = \\log(e(h))$，斜率为 $m = p$，自变量为 $X = \\log(h)$，y 轴截距为 $b = \\log(C)$。\n\n每个测试用例的总体算法如下：\n1.  对于给定集合中的每个步长 $h_i$，使用 RK4 方法求解从 $t_0$ 到 $T$ 的常微分方程。这包括执行 $N_i = (T - t_0) / h_i$ 步以获得数值解 $y_{N_i}$。\n2.  计算最终时间点的精确解 $y_{\\mathrm{exact}}(T)$。\n3.  计算每个步长的绝对全局误差：$e(h_i) = |y_{N_i} - y_{\\mathrm{exact}}(T)|$。\n4.  此过程产生一组数据点 $(h_i, e(h_i))$。\n5.  将这些数据点转换到对数尺度，创建一组新的点 $(\\log(h_i), \\log(e(h_i)))$。\n6.  对这些变换后的点进行线性最小二乘回归，以找到最佳拟合直线。该直线的斜率是经验阶数 $p$，截距是 $\\log(C)$。\n7.  然后通过对截距取指数来恢复常数 $C$：$C = \\exp(\\log(C))$。\n8.  将得到的对 $[p, C]$ 存储起来用于该测试用例。\n\n对问题陈述中提供的所有四个测试用例重复此过程。最终输出是每个案例的 $[p, C]$ 对的汇总。为每次回归使用多个步长可以提高推断参数的稳健性，前提是步长处于主导误差项起决定性作用的渐近区域内。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically reconstructs the global truncation error law for the RK4 method\n    by fitting observed errors to a power law e(h) = C*h^p.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"f\": lambda t, y: y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"y_exact\": lambda t: np.exp(t),\n            \"h_values\": np.array([0.5, 0.25, 0.125, 0.0625])\n        },\n        {\n            \"f\": lambda t, y: -3.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 2.0,\n            \"T\": 2.0,\n            \"y_exact\": lambda t: 2.0 * np.exp(-3.0 * t),\n            \"h_values\": np.array([0.5, 0.25, 0.125, 0.0625])\n        },\n        {\n            \"f\": lambda t, y: y + t,\n            \"t0\": 0.0,\n            \"y0\": 0.0,\n            \"T\": 0.8,\n            \"y_exact\": lambda t: np.exp(t) - t - 1.0,\n            \"h_values\": np.array([0.4, 0.2, 0.1, 0.05])\n        },\n        {\n            \"f\": lambda t, y: -5.0 * y,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"y_exact\": lambda t: np.exp(-5.0 * t),\n            \"h_values\": np.array([0.1, 0.05, 0.025, 0.0125])\n        }\n    ]\n\n    def run_rk4(f, y0, t0, T, h):\n        \"\"\"\n        Solves an ODE y'(t) = f(t,y) from t0 to T with step size h using RK4.\n        \n        Args:\n            f (callable): The function f(t, y).\n            y0 (float): The initial value y(t0).\n            t0 (float): The initial time.\n            T (float): The final time.\n            h (float): The step size.\n\n        Returns:\n            float: The numerical solution y(T).\n        \"\"\"\n        t = t0\n        y = y0\n        # Use rounding to ensure integer number of steps for the loop\n        num_steps = int(round((T - t0) / h))\n        \n        for _ in range(num_steps):\n            k1 = f(t, y)\n            k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n            k3 = f(t + 0.5 * h, y + 0.5 * h * k2)\n            k4 = f(t + h, y + h * k3)\n            y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n            t += h\n            \n        return y\n\n    results = []\n    for case in test_cases:\n        errors = []\n        h_vals = case[\"h_values\"]\n        \n        for h in h_vals:\n            y_numerical = run_rk4(case[\"f\"], case[\"y0\"], case[\"t0\"], case[\"T\"], h)\n            y_true = case[\"y_exact\"](case[\"T\"])\n            error = np.abs(y_numerical - y_true)\n            errors.append(error)\n        \n        # Transform data to log-log scale\n        log_h = np.log(h_vals)\n        log_e = np.log(np.array(errors))\n        \n        # Perform linear least-squares fit: log(e) = p*log(h) + log(C)\n        # np.polyfit returns [p, log(C)]\n        p, log_C = np.polyfit(log_h, log_e, 1)\n        \n        # Recover C from the intercept\n        C = np.exp(log_C)\n        \n        results.append([p, C])\n\n    # Convert results to a string with the specified format\n    # The default str() representation of a list is [item1, item2], which matches the requirement\n    # Example: str([4.0, 0.001]) -> '[4.0, 0.001]'\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "3236754"}, {"introduction": "在实际应用中，我们的目标通常不仅是解出方程，而是要以保证的精度完成计算。这个练习让您扮演计算科学家的角色，任务是选择合适的步长 $h$ 以满足特定的误差容限 $\\epsilon$ [@problem_id:3236664]。您将学习如何使用全局误差公式作为预测工具，并通过实测数据来修正您的预测，最终掌握一种高效且可靠的误差控制策略。", "problem": "考虑形式为 $y^{\\prime}(t)=f(t,y(t))$ 的初值问题，其在有限区间 $[0,T]$ 上具有给定的初始条件 $y(0)=y_{0}$。假设 $f$ 足够光滑，以至于精确解 $y(t)$ 在 $[0,T]$ 上存在且唯一。对于一个相容且零稳定的 $p$ 阶单步数值方法，其阶数为 $p$ 的含义是，当步长 $h \\to 0$ 时，全局截断误差的渐近行为如同 $O(h^{p})$。我们可以将步长为 $h$ 的网格上的最大节点全局误差与一个依赖于方法和问题的常数联系起来。具体来说，假设有一个已知的界常数 $C_{0}$，使得在小步长 $h$ 的渐近区域内，最大节点全局误差 $E(h)$ 满足 $E(h) \\leq C_{0}\\, h^{p}$。\n\n任务：编写一个完整程序，对每个提供的测试用例，以数学上合理且计算上可验证的方式执行以下步骤。\n\n1. 从相容性、零稳定性和阶数定义（$p$ 阶）的基本原理出发，推导出选择步长 $h$ 所需的不等式，以保证最大节点全局误差 $E(h)$ 至多为用户指定的目标值 $\\epsilon$。使用提供的阶数 $p$ 和界常数 $C_{0}$，但不要假设任何未经证明的快捷公式。\n2. 使用推导出的关系式，计算一个初始步长 $h_{\\text{pred}}$，然后选择一个整数步数 $N_{0}$，使得 $h_{0}=T/N_{0}$ 不超过 $h_{\\text{pred}}$。这确保了网格与区间 $[0,T]$ 对齐，并遵循目标界的逻辑。在此网格上计算数值解，并测量最大节点全局误差 $E(h_{0})=\\max_{0\\leq n \\leq N_{0}} \\left| y_{n}-y(t_{n}) \\right|$，其中 $t_{n}=n h_{0}$，$y_{n}$ 是数值解的值。\n3. 通过将步数加倍至 $N_{1}=2N_{0}$ 来把步长减半，得到 $h_{1}=T/N_{1}$。重新计算数值解并测量 $E(h_{1})$。\n4. 使用计算出的两个误差，并认识到对于足够小的 $h$，存在渐近行为 $E(h) \\approx K\\, h^{p}$，来估计一个实测的渐近误差常数 $K_{\\text{meas}}$。使用一个不会低估该常数的保守估计。\n5. 使用实测常数 $K_{\\text{meas}}$，计算一个调整后的步长 $h_{\\text{adj}}$ 以满足目标误差 $\\epsilon$。选择一个整数步数 $N_{\\text{adj}}$，使得 $h_{\\text{adj}}=T/N_{\\text{adj}}$ 不超过根据 $K_{\\text{meas}}$ 的预测值。通过计算验证得到的最大节点全局误差 $E(h_{\\text{adj}})$ 是否满足目标 $\\epsilon$。\n6. 对每个测试用例，返回列表 $[h_{0}, E(h_{0}), h_{1}, E(h_{1}), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$，其中 $\\text{meets\\_target}$ 是一个布尔值，指示 $E(h_{\\text{adj}}) \\leq \\epsilon$ 是否成立。\n\n您必须实现两种方法：经典四阶 Runge-Kutta 方法和显式 Euler 方法，并测量网格点上的最大节点全局误差。当出现三角函数时，角度以弧度处理。\n\n测试套件：\n- 用例 A（理想情况，光滑自治问题）：\n  - 微分方程：$y^{\\prime}(t)=-y(t)$，精确解 $y(t)=e^{-t}$。\n  - 区间：$T=1$。\n  - 初始条件：$y_{0}=1$。\n  - 方法：经典四阶 Runge-Kutta。\n  - 阶数：$p=4$。\n  - 误差目标：$\\epsilon=10^{-6}$。\n  - 已知界常数：$C_{0}=2\\times 10^{-2}$。\n- 用例 B（带三角函数系数的非自治问题，角度以弧度为单位）：\n  - 微分方程：$y^{\\prime}(t)=y(t)\\cos(t)$，精确解 $y(t)=\\exp(\\sin(t))$。\n  - 区间：$T=\\pi$。\n  - 初始条件：$y_{0}=1$。\n  - 方法：经典四阶 Runge-Kutta。\n  - 阶数：$p=4$。\n  - 误差目标：$\\epsilon=5\\times 10^{-7}$。\n  - 已知界常数：$C_{0}=2\\times 10^{-1}$。\n- 用例 C（使用一阶方法的边界情况）：\n  - 微分方程：$y^{\\prime}(t)=-y(t)$，精确解 $y(t)=e^{-t}$。\n  - 区间：$T=1$。\n  - 初始条件：$y_{0}=1$。\n  - 方法：显式 Euler。\n  - 阶数：$p=1$。\n  - 误差目标：$\\epsilon=10^{-2}$。\n  - 已知界常数：$C_{0}=8\\times 10^{-1}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个条目，其中每个条目是列表 $[h_{0}, E(h_{0}), h_{1}, E(h_{1}), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$。例如，打印出的行应类似于 $[[\\ldots],[\\ldots],[\\ldots]]$。没有物理单位；所有量都是无量纲的。所有角度均以弧度为单位。", "solution": "该问题经评估是有效的。它在科学上基于常微分方程数值分析的原理，是适定的，提供了所有必要信息，并使用客观、正式的语言进行陈述。各项任务在计算上是可验证的，并且直接涉及全局截断误差和步长选择的主题。\n\n解决方案首先推导必要的数学关系式，然后将它们计算应用于每个指定的测试用例。\n\n### 1. 理论推导\n\n该问题围绕求解以下形式的初值问题 (IVP)：\n$$\ny^{\\prime}(t) = f(t, y(t)), \\quad y(0) = y_0\n$$\n在有限区间 $[0, T]$ 上。我们已知一个单步数值方法的收敛阶为 $p$，这意味着对于小步长 $h$，其最大节点全局误差 $E(h)$ 的渐近行为如下：\n$$\nE(h) = \\max_{0 \\le n \\le N} |y_n - y(t_n)| \\approx K h^p\n$$\n其中 $y_n$ 是在网格点 $t_n = n h$ 处对精确解 $y(t_n)$ 的数值近似，$K$ 是一个依赖于方法和具体 IVP 的渐近误差常数。问题提供了一个已知的上界常数 $C_0$，使得在渐近区域内 $E(h) \\le C_0 h^p$ 成立。\n\n#### 1.1. 步长选择\n我们的首要目标是推导出一个关于步长 $h$ 的关系式，该关系式能保证全局误差 $E(h)$ 不会超过指定的容差 $\\epsilon$。使用提供的界：\n$$\nE(h) \\le C h^p\n$$\n为确保 $E(h) \\le \\epsilon$，我们必须施加以下条件：\n$$\nC h^p \\le \\epsilon\n$$\n对此不等式求解 $h$ 可得：\n$$\nh^p \\le \\frac{\\epsilon}{C} \\implies h \\le \\left(\\frac{\\epsilon}{C}\\right)^{1/p}\n$$\n这个不等式是选择步长的基本关系式。给定一个常数 $C$（初始界 $C_0$ 或实测常数 $K_{\\text{meas}}$），允许的最大预测步长为 $h_{\\text{pred}} = (\\epsilon/C)^{1/p}$。为确保网格点与区间 $[0, T]$ 对齐，我们必须选择整数步数 $N$。步长则为 $h = T/N$。为了满足推导出的约束条件，我们需要 $T/N \\le h_{\\text{pred}}$，这意味着 $N \\ge T/h_{\\text{pred}}$。为了使用尊重该界限的尽可能大的步长（从而使用最少的步数），我们选择满足此条件的最小整数 $N$：\n$$\nN = \\left\\lceil \\frac{T}{h_{\\text{pred}}} \\right\\rceil\n$$\n其中 $\\lceil \\cdot \\rceil$ 是上取整函数。那么实际使用的步长为 $h = T/N$。\n\n#### 1.2. 渐近误差常数的估计\n在使用步长 $h_0$ 和 $h_1 = h_0/2$ 执行两次计算，得到误差 $E(h_0)$ 和 $E(h_1)$ 之后，我们可以估计真实的渐近常数 $K$。假设两次计算都处于渐近区域内：\n$$\nE(h_0) \\approx K h_0^p\n$$\n$$\nE(h_1) \\approx K h_1^p\n$$\n我们可以从每次计算中得到 $K$ 的一个估计值。例如，从第二次更精确的计算中可得：$K \\approx E(h_1) / h_1^p$。为保守起见且不低估该常数（如问题所建议），审慎的做法是计算两个估计值 $K_{\\text{est},0} = E(h_0)/h_0^p$ 和 $K_{\\text{est},1} = E(h_1)/h_1^p$，并取两者中较大的一个作为我们的实测常数：\n$$\nK_{\\text{meas}} = \\max\\left(\\frac{E(h_0)}{h_0^p}, \\frac{E(h_1)}{h_1^p}\\right)\n$$\n这个实测常数 $K_{\\text{meas}}$ 是根据方法在具体问题上的实际表现凭经验推导出来的，通常比一般的理论界 $C_0$ 是一个更紧的估计。\n\n### 2. 算法流程\n每个测试用例的总体流程如下：\n\n1.  **初始步长计算**：\n    *   使用提供的界 $C_0$ 计算初始预测步长：$h_{\\text{pred},0} = (\\epsilon / C_0)^{1/p}$。\n    *   确定步数：$N_0 = \\lceil T / h_{\\text{pred},0} \\rceil$。\n    *   设置初始步长：$h_0 = T/N_0$。\n\n2.  **第一次数值求解与误差计算**：\n    *   使用指定的数值方法（显式 Euler 或 RK4）以 $N_0$ 步在 $[0, T]$ 上求解常微分方程。\n    *   计算最大节点全局误差：$E(h_0) = \\max_{0 \\le n \\le N_0} |y_n - y(t_n)|$。\n\n3.  **第二次数值求解与误差计算**：\n    *   设置 $N_1 = 2N_0$ 和 $h_1 = T/N_1 = h_0/2$。\n    *   以 $N_1$ 步再次求解常微分方程。\n    *   计算相应的误差：$E(h_1) = \\max_{0 \\le n \\le N_1} |y_n - y(t_n)|$。\n\n4.  **估计渐近常数**：\n    *   使用上面推导的保守公式计算实测常数 $K_{\\text{meas}}$：$K_{\\text{meas}} = \\max(E(h_0)/h_0^p, E(h_1)/h_1^p)$。\n\n5.  **调整步长与最终验证**：\n    *   使用 $K_{\\text{meas}}$ 计算调整后的预测步长：$h_{\\text{pred,adj}} = (\\epsilon / K_{\\text{meas}})^{1/p}$。\n    *   确定调整后的步数：$N_{\\text{adj}} = \\lceil T / h_{\\text{pred,adj}} \\rceil$。\n    *   设置调整后的步长：$h_{\\text{adj}} = T/N_{\\text{adj}}$。\n    *   以 $N_{\\text{adj}}$ 步最后一次求解常微分方程。\n    *   计算最终误差：$E(h_{\\text{adj}}) = \\max_{0 \\le n \\le N_{\\text{adj}}} |y_n - y(t_n)|$。\n    *   验证是否达到误差目标：检查 $E(h_{\\text{adj}}) \\le \\epsilon$ 是否成立。\n\n6.  **报告结果**：对每个测试用例，汇总列表 $[h_0, E(h_0), h_1, E(h_1), K_{\\text{meas}}, h_{\\text{adj}}, E(h_{\\text{adj}}), \\text{meets\\_target}]$。\n\n### 3. 数值方法\n所需的两种单步方法由其更新规则定义。\n\n*   **显式 Euler 方法（$p=1$ 阶）**：\n    $$\n    y_{n+1} = y_n + h f(t_n, y_n)\n    $$\n\n*   **经典四阶 Runge-Kutta 方法（RK4，$p=4$ 阶）**：\n    \\begin{align*}\n    k_1 = f(t_n, y_n) \\\\\n    k_2 = f(t_n + h/2, y_n + (h/2) k_1) \\\\\n    k_3 = f(t_n + h/2, y_n + (h/2) k_2) \\\\\n    k_4 = f(t_n + h, y_n + h k_3) \\\\\n    y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n    \\end{align*}\n\n这些步骤和公式将为提供的每个测试用例实现。", "answer": "```python\nimport numpy as np\n\ndef solve_ode(method_name, f, y0, T, N):\n    \"\"\"\n    Solves an ODE y'(t) = f(t, y) using a specified one-step method.\n\n    Args:\n        method_name (str): Name of the method ('euler' or 'rk4').\n        f (callable): Function f(t, y).\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        N (int): Number of steps.\n\n    Returns:\n        tuple: (numpy.ndarray of time points, numpy.ndarray of solution values).\n    \"\"\"\n    h = T / N\n    t = np.linspace(0, T, N + 1)\n    y = np.zeros(N + 1)\n    y[0] = y0\n\n    if method_name == 'euler':\n        for n in range(N):\n            y[n + 1] = y[n] + h * f(t[n], y[n])\n    elif method_name == 'rk4':\n        for n in range(N):\n            k1 = f(t[n], y[n])\n            k2 = f(t[n] + h / 2, y[n] + h / 2 * k1)\n            k3 = f(t[n] + h / 2, y[n] + h / 2 * k2)\n            k4 = f(t[n] + h, y[n] + h * k3)\n            y[n + 1] = y[n] + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n    else:\n        raise ValueError(\"Unknown method specified.\")\n        \n    return t, y\n\ndef calculate_max_error(t, y_num, y_exact_func):\n    \"\"\"Calculates the maximum nodal global error.\"\"\"\n    y_exact_vals = y_exact_func(t)\n    return np.max(np.abs(y_num - y_exact_vals))\n\ndef solve():\n    \"\"\"\n    Main function to process test cases and generate the final output.\n    \"\"\"\n    # Test Suite Definition\n    test_cases = [\n        # Case A\n        {\n            \"f\": lambda t, y: -y,\n            \"y_exact\": lambda t: np.exp(-t),\n            \"T\": 1.0,\n            \"y0\": 1.0,\n            \"method\": \"rk4\",\n            \"p\": 4.0,\n            \"epsilon\": 1e-6,\n            \"C0\": 2e-2\n        },\n        # Case B\n        {\n            \"f\": lambda t, y: y * np.cos(t),\n            \"y_exact\": lambda t: np.exp(np.sin(t)),\n            \"T\": np.pi,\n            \"y0\": 1.0,\n            \"method\": \"rk4\",\n            \"p\": 4.0,\n            \"epsilon\": 5e-7,\n            \"C0\": 2e-1\n        },\n        # Case C\n        {\n            \"f\": lambda t, y: -y,\n            \"y_exact\": lambda t: np.exp(-t),\n            \"T\": 1.0,\n            \"y0\": 1.0,\n            \"method\": \"euler\",\n            \"p\": 1.0,\n            \"epsilon\": 1e-2,\n            \"C0\": 8e-1\n        }\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        f = case[\"f\"]\n        y_exact = case[\"y_exact\"]\n        T = case[\"T\"]\n        y0 = case[\"y0\"]\n        method = case[\"method\"]\n        p = case[\"p\"]\n        epsilon = case[\"epsilon\"]\n        C0 = case[\"C0\"]\n\n        # 1. Initial Step Size Calculation\n        h_pred_0 = (epsilon / C0)**(1 / p)\n        N0 = int(np.ceil(T / h_pred_0))\n        h0 = T / N0\n\n        # 2. First Numerical Solution and Error\n        t0, y0_num = solve_ode(method, f, y0, T, N0)\n        E_h0 = calculate_max_error(t0, y0_num, y_exact)\n\n        # 3. Second Numerical Solution and Error\n        N1 = 2 * N0\n        h1 = T / N1\n        t1, y1_num = solve_ode(method, f, y0, T, N1)\n        E_h1 = calculate_max_error(t1, y1_num, y_exact)\n\n        # 4. Estimate Asymptotic Constant\n        # Handle cases where error is zero to avoid division by zero\n        K_est_0 = E_h0 / (h0**p) if h0 > 0 else 0\n        K_est_1 = E_h1 / (h1**p) if h1 > 0 else 0\n        K_meas = max(K_est_0, K_est_1)\n        # Prevent K_meas from being zero if errors are zero\n        if K_meas == 0:\n            K_meas = 1e-12 # A small non-zero value\n\n        # 5. Adjusted Step Size and Final Verification\n        h_pred_adj = (epsilon / K_meas)**(1 / p)\n        N_adj = int(np.ceil(T / h_pred_adj))\n        h_adj = T / N_adj\n        \n        t_adj, y_adj_num = solve_ode(method, f, y0, T, N_adj)\n        E_h_adj = calculate_max_error(t_adj, y_adj_num, y_exact)\n        \n        meets_target = bool(E_h_adj = epsilon)\n\n        # 6. Report Results\n        case_results = [h0, E_h0, h1, E_h1, K_meas, h_adj, E_h_adj, meets_target]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as required.\n    # Convert boolean to lowercase string for printing.\n    # Format floats to a consistent representation.\n    def format_list(lst):\n        items = []\n        for item in lst:\n            if isinstance(item, bool):\n                items.append(str(item).lower())\n            else:\n                items.append(f\"{item:.10g}\")\n        return \"[\" + \",\".join(items) + \"]\"\n\n    output_str = \"[\" + \",\".join(map(format_list, all_results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3236664"}]}