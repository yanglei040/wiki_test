{"hands_on_practices": [{"introduction": "在数值积分中，我们自然地认为步长 $h$ 越小，结果越精确。然而，这一直觉在实践中存在一个关键的限制。本练习将引导你探索一个核心概念：总误差是两种误差来源之间权衡的结果，即由方法近似引起的截断误差和由计算机有限精度算术引起的舍入误差。通过使用经典的四阶龙格-库塔方法解决一个已知精确解的初值问题[@problem_id:3259605]，你将亲手绘制出误差随步长变化的“U”形曲线，并凭经验找出那个能最小化最终误差的最佳固定步长 $h^*$。", "problem": "考虑一个由常微分方程 $y^{\\prime}(t) = f(t,y)$ 和初始条件 $y(t_{0}) = y_{0}$ 定义的初值问题 (IVP)。一个步长固定为 $h$ 的单步法仅使用当前步的信息，将 $t_{n}$ 处的近似值 $y_{n}$推进到 $t_{n+1} = t_{n} + h$ 处的 $y_{n+1}$。对于这类方法，在固定的最终时间 $T$ 上的总误差通常来自两个来源：由方法的有限阶数引起的截断误差和由有限精度运算产生的浮点舍入误差。截断误差依赖于 $h$、方法的阶数以及 $f$ 的光滑性，而舍入误差则依赖于步数 $N = T/h$ 和所使用的算术精度。您的任务是，对于特定的初值问题和一种单步法，通过平衡截断误差和浮点舍入误差，数值化地找到使绝对最终误差最小化的固定步长 $h$。\n\n基本依据：\n- IVP 的定义：$y^{\\prime}(t) = f(t,y)$ 及 $y(t_{0}) = y_{0}$。\n- 单步法的定义，例如经典的四阶 Runge–Kutta 方法，它使用一个固定的公式，根据 $(t_{n}, y_{n})$ 和 $h$ 来构造 $y_{n+1}$。\n- 一个经过充分检验的事实：对于一个在固定区间上应用的 $p$ 阶方法，当 $h$ 足够小且解足够光滑时，其全局截断误差与一个常数乘以 $h^{p}$ 成比例。\n- 一个经过充分检验的事实：浮点舍入误差会在多次算术运算中累积，对于固定的区间 $[0,T]$，步数 $N$ 与 $T/h$ 成比例。\n\n您的程序必须对所有测试用例使用经典的四阶 Runge–Kutta (RK4) 方法作为单步积分器。您不能使用任何内置的常微分方程求解器。对于每个指定的测试用例，您必须：\n- 对于给定候选列表中的每个 $N$，使用固定的步长 $h = T/N$ 从 $t_{0}$ 积分到 $T$。\n- 使用为该测试用例提供的精确解 $y_{\\text{true}}(t)$ 计算绝对最终误差 $\\left|y_{N} - y_{\\text{true}}(T)\\right|$。\n- 从候选步长中选择使绝对最终误差最小的步长 $h^{\\star}$。如果有两个或多个候选步长产生的最终误差在数值上无法在 $10^{-18}$ 的绝对容差内区分，则选择这些并列候选者中最大的 $h$。\n\n角度单位：每当出现 $\\sin(\\cdot)$ 或 $\\cos(\\cdot)$ 时，其参数都应解释为弧度。\n\n使用双精度浮点运算。不允许使用随机性。\n\n测试套件：\n- 用例 1（增长，预期内部最小值）：\n  - $f(t,y) = y$, $y(0) = 1$, $T = 50$。精确解 $y_{\\text{true}}(t) = e^{t}$。\n- 用例 2（衰减，预期边界行为）：\n  - $f(t,y) = -2\\,y$, $y(0) = 1$, $T = 50$。精确解 $y_{\\text{true}}(t) = e^{-2t}$。\n- 用例 3（受迫线性，有界解）：\n  - $f(t,y) = \\sin(t) - y$, $y(0) = 1$, $T = 30$。精确解 $y_{\\text{true}}(t) = \\tfrac{3}{2} e^{-t} + \\tfrac{1}{2}(\\sin t - \\cos t)$。\n\n对于每个用例，评估以下候选的划分数 $N \\in \\{50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600, 51200\\}$，并由此计算 $h = T/N$。对于每个 $N$，执行恰好 $N$ 个固定大小的 RK4 步骤以达到时间 $T$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述测试用例的顺序排列。具体来说，输出必须是列表 $[h^{\\star}_{1}, h^{\\star}_{2}, h^{\\star}_{3}]$，其中每个 $h^{\\star}_{i}$ 是为用例 $i$ 选择的最优 $h$。条目必须打印为十进制浮点数。不涉及单位。\n\n重要约束：\n- 明确实现 RK4 单步法。不要重用任何库中的时间步进器。\n- 确保每个候选步长 $h$ 都产生恰好 $N$ 个均匀的步骤，以便最终时间恰好是 $T$。\n- 使用上面给出的精确解来准确计算 $\\left|y_{N} - y_{\\text{true}}(T)\\right|$。\n\n最终输出格式必须只有一行：例如，$[h^{\\star}_{1},h^{\\star}_{2},h^{\\star}_{3}]$。", "solution": "用户提供了一个问题，要求在使用经典的四阶 Runge-Kutta (RK4) 方法求解几个初值问题 (IVP) 时，找到最优的固定步长 $h$。优化准则是最小化在固定最终时间 $T$ 的绝对误差，这涉及到平衡方法的截断误差与累积的浮点舍入误差。\n\n### 第 1 步：提取已知条件\n\n- **IVP 定义**：$y^{\\prime}(t) = f(t,y)$ 及初始条件 $y(t_{0}) = y_{0}$。\n- **数值方法**：使用经典的四阶 Runge-Kutta (RK4) 方法。\n- **任务**：对于给定的候选步数 $N$ 列表，找到使绝对最终误差 $\\left|y_{N} - y_{\\text{true}}(T)\\right|$ 最小化的步长 $h = T/N$。\n- **候选划分数 $N$**：步数的候选集合为 $N \\in \\{50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600, 51200\\}$。\n- **平局决胜规则**：如果多个 $h$ 的候选值产生了最小误差（其值在 $10^{-18}$ 的绝对容差内），则必须选择其中最大的 $h$。\n- **算术**：双精度浮点运算。\n- **测试用例 1**：\n  - $f(t,y) = y$\n  - $y(0) = 1$\n  - $T = 50$\n  - 精确解：$y_{\\text{true}}(t) = e^{t}$\n- **测试用例 2**：\n  - $f(t,y) = -2y$\n  - $y(0) = 1$\n  - $T = 50$\n  - 精确解：$y_{\\text{true}}(t) = e^{-2t}$\n- **测试用例 3**：\n  - $f(t,y) = \\sin(t) - y$\n  - $y(0) = 1$\n  - $T = 30$\n  - 精确解：$y_{\\text{true}}(t) = \\tfrac{3}{2} e^{-t} + \\tfrac{1}{2}(\\sin t - \\cos t)$\n- **角度单位**：三角函数的参数以弧度为单位。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据验证标准对问题进行审查：\n\n- **科学基础**：该问题在根本上是合理的。它探讨了数值分析中的一个经典概念：截断误差（随步长 $h$ 减小而减小）与舍入误差（随计算步数 $N=T/h$ 增多而累积）之间的权衡。RK4 方法是求解常微分方程 (ODE) 的标准且易于理解的算法。所选的 ODE 是具有已知解析解的典型例子，适合进行误差分析。\n- **适定性**：问题是适定的。它提供了所有必要组成部分：微分方程、初始条件、特定的数值方法、一个离散的待测试步长集合，以及一个明确的目标函数（最小化绝对最终误差）。明确的平局决胜规则确保了解决方案的唯一性。\n- **客观性**：问题以客观的数学术语陈述。评估基于定量的误差计算，没有主观解释的余地。\n\n所有其他检查（完整性、一致性、可行性等）均通过。该问题未表现出任何已定义的缺陷。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案设计\n\n问题的核心是实现一个数值实验。对于三个 IVP 中的每一个，我们都必须使用 RK4 方法在一系列步长上模拟解的演化，并确定哪个步长在最终时间 $T$ 产生最准确的结果。\n\n**四阶 Runge-Kutta (RK4) 方法**\n给定一个 IVP $y'(t) = f(t,y)$，$y(t_n) = y_n$，RK4 方法通过以下计算序列来计算在时间 $t_{n+1} = t_n + h$ 的近似值 $y_{n+1}$：\n$$\nk_1 = f(t_n, y_n)\n$$\n$$\nk_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right)\n$$\n$$\nk_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right)\n$$\n$$\nk_4 = f\\left(t_n + h, y_n + hk_3\\right)\n$$\n下一个值 $y_{n+1}$ 则由这些中间斜率的加权平均给出：\n$$\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n$$\n此公式被迭代应用 $N$ 次，将解从初始条件 $(t_0, y_0)$ 推进到最终时间 $T = t_0 + N \\cdot h$。\n\n**误差动态学**\n在最终时间 $T$ 的总绝对误差，记为 $E(h)$，是两个主要误差源的组合：\n1.  **全局截断误差 ($E_T$)**：此误差是该方法逼近真实解时固有的。对于四阶方法 RK4，此误差与步长的四次方成比例，即 $E_T \\propto h^4$。当 $h \\to 0$ 时，此误差迅速减小。\n2.  **舍入误差 ($E_R$)**：此误差源于浮点运算的有限精度。RK4 方法的每一步都会引入一个小的舍入误差。这些误差在 $N = (T-t_0)/h$ 步中累积。一个简化的模型表明，总舍入误差随步数增长，因此 $E_R \\propto N \\propto 1/h$。\n总误差可以建模为 $E(h) \\approx C_1 h^4 + C_2/h$。这个函数具有一个特征形状：当 $h$ 较大时（截断误差占主导），它很大；随着 $h$ 的减小，它会减小；在最优步长 $h^{\\star}$ 处达到最小值；然后当 $h$ 非常小时（舍入误差开始占主导），它又会再次增大。我们的任务是从一个离散的候选集合中凭经验找到这个 $h^{\\star}$。\n\n**计算流程**\n对于三个测试用例中的每一个，执行以下算法：\n1.  计算一次最终时间 $T$ 的真实解 $y_{\\text{true}}(T)$，以作参考。\n2.  一个循环遍历提供的列表 $\\{50, 100, \\dots, 51200\\}$ 中的每个候选步数 $N$。\n3.  在循环内部，对于每个 $N$：\n    a.  计算步长 $h = (T - t_0) / N$。请注意，对于所有用例，$t_0=0$，所以 $h = T/N$。\n    b.  执行 RK4 积分，从 $t_0$ 的 $y_0$ 开始，精确执行 $N$ 步，以获得在时间 $T$ 的数值近似值 $y_N$。\n    c.  计算绝对误差：$\\epsilon = |y_N - y_{\\text{true}}(T)|$。\n    d.  存储序对 $(h, \\epsilon)$。\n4.  测试完所有候选值 $N$ 后，分析收集到的 $(h, \\epsilon)$ 序对列表，找到最小误差 $\\epsilon_{min}$。\n5.  根据平局决胜规则，找出所有满足 $|\\epsilon - \\epsilon_{min}| \\le 10^{-18}$ 的候选序对 $(h, \\epsilon)$。\n6.  在这些并列的候选者中，选择 $h$ 值最大的那个作为最优步长 $h^{\\star}$。\n7.  收集每个测试用例得到的三个最优步长，并格式化为最终输出。\n此流程被系统地应用，以确定每个 IVP 的最优步长，揭示了数值积分中误差权衡的实际效果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef rk4_solver(f, t0, y0, T, N):\n    \"\"\"\n    Solves an IVP y'(t) = f(t, y) using the classical RK4 method.\n\n    Args:\n        f (callable): The function f(t, y) defining the ODE.\n        t0 (float): The initial time.\n        y0 (float): The initial value y(t0).\n        T (float): The final time.\n        N (int): The number of steps to take.\n\n    Returns:\n        float: The numerical approximation of y(T).\n    \"\"\"\n    h = (T - t0) / float(N)\n    t = float(t0)\n    y = float(y0)\n\n    for _ in range(N):\n        k1 = f(t, y)\n        k2 = f(t + 0.5 * h, y + 0.5 * h * k1)\n        k3 = f(t + 0.5 * h, y + 0.5 * h * k2)\n        k4 = f(t + h, y + h * k3)\n        y += (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n        t += h\n        \n    return y\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and find the optimal step size h.\n    \"\"\"\n    test_cases = [\n        {\n            \"f\": lambda t, y: y,\n            \"y_true\": lambda t: np.exp(t),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 50.0,\n        },\n        {\n            \"f\": lambda t, y: -2.0 * y,\n            \"y_true\": lambda t: np.exp(-2.0 * t),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 50.0,\n        },\n        {\n            \"f\": lambda t, y: np.sin(t) - y,\n            \"y_true\": lambda t: 1.5 * np.exp(-t) + 0.5 * (np.sin(t) - np.cos(t)),\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"T\": 30.0,\n        },\n    ]\n\n    N_candidates = [50, 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600, 51200]\n    optimal_hs = []\n    TIE_TOLERANCE = 1e-18\n\n    for case in test_cases:\n        f = case[\"f\"]\n        y_true_func = case[\"y_true\"]\n        t0, y0, T = case[\"t0\"], case[\"y0\"], case[\"T\"]\n        \n        y_exact_at_T = y_true_func(T)\n        \n        results_for_case = []\n        for N in N_candidates:\n            h = (T - t0) / float(N)\n            y_N = rk4_solver(f, t0, y0, T, N)\n            error = np.abs(y_N - y_exact_at_T)\n            results_for_case.append({\"h\": h, \"error\": error})\n\n        # Find the minimum error among all candidates\n        if not results_for_case:\n            continue\n            \n        min_error = min(r['error'] for r in results_for_case)\n        \n        # Identify all candidates that are tied for the minimum error\n        # A tie is defined as being within an absolute tolerance of the minimum\n        tied_candidates = [\n            r for r in results_for_case \n            if np.isclose(r['error'], min_error, rtol=0, atol=TIE_TOLERANCE)\n        ]\n        \n        # From the tied candidates, select the one with the largest step size h\n        if not tied_candidates: # Should not happen if results_for_case is not empty\n             continue\n\n        optimal_h = max(r['h'] for r in tied_candidates)\n        optimal_hs.append(optimal_h)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, optimal_hs))}]\")\n\nsolve()\n```", "id": "3259605"}, {"introduction": "对于振荡系统（如行星轨道或分子振动）的长期模拟，仅仅关注局部精度是不够的。更重要的是数值方法能否保持系统的定性特征，例如能量守恒或相位同步。本练习[@problem_id:3259724]通过模拟简谐振子，让你直观地比较不同单步方法（如耗散性的欧拉法、保辛的蛙跳法和高阶的RK4法）在许多周期后累积的相位误差。通过这个实践，你将深刻理解为何选择合适的积分器对获得有物理意义的长期模拟结果至关重要。", "problem": "考虑一个由简谐振子给出的初值问题 (IVP)，该问题由以下常微分方程组定义\n$$\\frac{dx}{dt} = v,\\quad \\frac{dv}{dt} = -\\omega^2 x,$$\n初始条件为\n$$x(0) = 1,\\quad v(0) = 0,$$\n其中 $\\omega$ 是角频率，单位为弧度/秒。其精确解是周期性的，周期为 $$T = \\frac{2\\pi}{\\omega}.$$\n精确运动在通过映射 $x \\mapsto x$ 和 $v \\mapsto v/\\omega$ 得到的缩放相空间中描绘出一个圆，因此精确状态满足\n$$x(t) = \\cos(\\omega t),\\quad \\frac{v(t)}{\\omega} = -\\sin(\\omega t).$$\n将时刻 $t$ 的精确相角定义为\n$$\\phi_{\\mathrm{exact}}(t) = \\omega t,$$\n并将离散时间 $t_n = n h$ 处的数值相角定义为\n$$\\phi_n = \\operatorname{atan2}\\!\\left(\\frac{v_n}{\\omega}, x_n\\right),$$\n其中 $h$ 是时间步长，$(x_n, v_n)$ 是对 $(x(t_n), v(t_n))$ 的数值近似。在时间 $t_n$ 处的相位误差是环绕差\n$$\\Delta\\phi_n = \\mathrm{wrap}_{(-\\pi,\\pi]}\\!\\left(\\phi_n - \\phi_{\\mathrm{exact}}(t_n)\\right),$$\n其中 $\\mathrm{wrap}_{(-\\pi,\\pi]}(\\theta)$ 返回 $\\theta$ 模 $2\\pi$ 在区间 $(-\\pi,\\pi]$ 内的唯一代表值。所有角度都必须以弧度表示。\n\n从 IVP 单步法的基本定义出发，即一个仅使用 $t_n$ 时刻的信息以及可能在同一步内进行的求值，将状态从 $t_n$ 推进到 $t_{n+1} = t_n + h$ 的映射，为该系统实现以下单步数值积分器：\n- 显式欧拉法。\n- 以单步速度 Verlet 形式实现的蛙跳法，该方法使用当前状态和步内求值，在单一步骤内将 $(x_n, v_n)$ 推进到 $(x_{n+1}, v_{n+1})$。\n- 经典四阶龙格-库塔法。\n\n您的程序必须计算每种方法在多个周期后的相位误差。为此，对于指定的整数 $m$，使用恒定时间步长 $h = 2\\pi/m$ 积分至 $t_{\\mathrm{end}} = N_{\\mathrm{periods}}\\,T$，并仅报告在 $t_{\\mathrm{end}}$ 处的最终相位误差 $\\Delta\\phi_{n_{\\mathrm{final}}}$。使用 $\\omega = 1$，因此 $T = 2\\pi$，且在 $t_{\\mathrm{end}}$ 处的精确最终相位为 $\\phi_{\\mathrm{exact}}(t_{\\mathrm{end}}) = 2\\pi N_{\\mathrm{periods}}$，该值模 $2\\pi$ 同余于 $0$。\n\n测试套件：\n对于方法集合 $\\{\\text{Euler}, \\text{Leapfrog}, \\text{RK4}\\}$ 中按固定顺序排列的每种方法，以及对于每个步长参数 $m \\in \\{4, 20, 200\\}$，计算两种时长 $N_{\\mathrm{periods}} \\in \\{10, 100\\}$（即在 $t_{\\mathrm{end}} = N_{\\mathrm{periods}} \\cdot 2\\pi$ 时）的最终相位误差。这定义了一个包含 18 个案例的测试套件。每个案例的预期输出是代表 $\\Delta\\phi_{n_{\\mathrm{final}}}$（以弧度为单位）的单个实数。所有角度量都必须以弧度为单位。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含 18 个测试案例的结果，形式为用方括号括起来的逗号分隔列表，并遵循以下固定顺序：\n- 对于方法 $\\text{Euler}$：$(m=4, N_{\\mathrm{periods}}=10)$，$(m=4, N_{\\mathrm{periods}}=100)$，$(m=20, N_{\\mathrm{periods}}=10)$，$(m=20, N_{\\mathrm{periods}}=100)$，$(m=200, N_{\\mathrm{periods}}=10)$，$(m=200, N_{\\mathrm{periods}}=100)$。\n- 对于方法 $\\text{Leapfrog}$：按相同的 $m$ 和 $N_{\\mathrm{periods}}$ 顺序排列的同样六个案例。\n- 对于方法 $\\text{RK4}$：按相同的 $m$ 和 $N_{\\mathrm{periods}}$ 顺序排列的同样六个案例。\n\n最终打印的行必须严格遵循\n$$[\\Delta\\phi_1,\\Delta\\phi_2,\\ldots,\\Delta\\phi_{18}]$$\n的格式，不得包含任何额外文本。所有值都必须以弧度为单位。除弧度外，不涉及其他物理单位，并且角度不得以百分号表示。", "solution": "问题陈述已经过验证，被认为是常微分方程数值方法领域中一个适定的、有科学依据的问题。所有必要信息均已提供，目标明确且可形式化。\n\n任务是计算三种不同的单步数值积分器——显式欧拉法、蛙跳法 (速度 Verlet) 和显式四阶龙格-库塔法 (RK4)——应用于简谐振子问题时的相位误差。\n\n简谐振子的一阶常微分方程组 (ODEs) 如下：\n$$\n\\frac{dx}{dt} = v \\\\\n\\frac{dv}{dt} = -\\omega^2 x\n$$\n给定角频率 $\\omega=1\\,\\mathrm{rad/s}$，因此方程组简化为：\n$$\n\\frac{dx}{dt} = v \\\\\n\\frac{dv}{dt} = -x\n$$\n这可以写成向量形式 $\\mathbf{y}'(t) = \\mathbf{f}(\\mathbf{y}(t))$，其中 $\\mathbf{y} = \\begin{pmatrix} x \\\\ v \\end{pmatrix}$，函数 $\\mathbf{f}$ 为：\n$$\n\\mathbf{f}(x, v) = \\begin{pmatrix} v \\\\ -x \\end{{pmatrix}\n$$\n初始条件为 $\\mathbf{y}(0) = \\begin{pmatrix} x(0) \\\\ v(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。\n\n单步数值方法使用时刻 $t_n$ 的状态（记为 $\\mathbf{y}_n = \\begin{pmatrix} x_n \\\\ v_n \\end{pmatrix}$）来近似时刻 $t_{n+1} = t_n + h$ 的解。我们现在将详细说明每种所需方法的实现。\n\n**1. 显式欧拉法**\n这是一种一阶方法。其更新规则为 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_n)$。写成分量形式为：\n$$\nx_{n+1} = x_n + h v_n \\\\\nv_{n+1} = v_n + h (-x_n) = v_n - h x_n\n$$\n\n**2. 蛙跳法 (速度 Verlet 形式)**\n该方法是一种二阶辛积分器。在其单步速度 Verlet 形式中，它按如下方式将状态 $(x_n, v_n)$ 推进到 $(x_{n+1}, v_{n+1})$：\n首先，计算半步处的中间速度 $v_{n+1/2}$。加速度为 $a(x) = -x$。\n$$ v_{n+1/2} = v_n + \\frac{h}{2} a(x_n) = v_n - \\frac{h}{2} x_n $$\n接下来，使用这个中间速度将位置更新到完整步长：\n$$ x_{n+1} = x_n + h v_{n+1/2} $$\n最后，使用新位置处的加速度 $a(x_{n+1})$ 将速度从半步更新到完整步长：\n$$ v_{n+1} = v_{n+1/2} + \\frac{h}{2} a(x_{n+1}) = v_{n+1/2} - \\frac{h}{2} x_{n+1} $$\n这些步骤在单次时间步积分内按顺序执行。\n\n**3. 经典四阶龙格-库塔法 (RK4)**\n这是一种四阶方法。其更新规则为 $\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)$，其中各阶段 $\\mathbf{k}_i$ 是具有 $x$ 和 $v$ 分量的向量。对于我们的特定系统 $\\mathbf{f}(x,v) = (v, -x)$：\n\n阶段 1：\n$$ \\mathbf{k}_1 = \\mathbf{f}(x_n, v_n) = \\begin{pmatrix} v_n \\\\ -x_n \\end{pmatrix} $$\n阶段 2：\n$$ \\mathbf{k}_2 = \\mathbf{f}\\left(x_n + \\frac{h}{2} k_{1,x}, v_n + \\frac{h}{2} k_{1,v}\\right) = \\mathbf{f}\\left(x_n + \\frac{h}{2} v_n, v_n - \\frac{h}{2} x_n\\right) = \\begin{pmatrix} v_n - \\frac{h}{2} x_n \\\\ -\\left(x_n + \\frac{h}{2} v_n\\right) \\end{pmatrix} $$\n阶段 3：\n$$ \\mathbf{k}_3 = \\mathbf{f}\\left(x_n + \\frac{h}{2} k_{2,x}, v_n + \\frac{h}{2} k_{2,v}\\right) = \\begin{pmatrix} v_n + \\frac{h}{2}k_{2,v} \\\\ -\\left(x_n + \\frac{h}{2}k_{2,x}\\right) \\end{pmatrix} $$\n阶段 4：\n$$ \\mathbf{k}_4 = \\mathbf{f}\\left(x_n + h k_{3,x}, v_n + h k_{3,v}\\right) = \\begin{pmatrix} v_n + h k_{3,v} \\\\ -\\left(x_n + h k_{3,x}\\right) \\end{pmatrix} $$\n\n最终状态 $(x_{n+1}, v_{n+1})$ 则为：\n$$\nx_{n+1} = x_n + \\frac{h}{6} (k_{1,x} + 2k_{2,x} + 2k_{3,x} + k_{4,x}) \\\\\nv_{n+1} = v_n + \\frac{h}{6} (k_{1,v} + 2k_{2,v} + 2k_{3,v} + k_{4,v})\n$$\n\n**相位误差计算**\n对于由方法、步长参数 $m$ 和周期数 $N_{\\mathrm{periods}}$ 定义的每个测试案例：\n1.  时间步长为 $h = 2\\pi/m$。\n2.  最终积分时间为 $t_{\\mathrm{end}} = N_{\\mathrm{periods}} \\cdot T = N_{\\mathrm{periods}} \\cdot 2\\pi$（因为 $T=2\\pi/\\omega$ 且 $\\omega=1$）。\n3.  总步数为 $N_{\\mathrm{steps}} = t_{\\mathrm{end}}/h = (N_{\\mathrm{periods}} \\cdot 2\\pi) / (2\\pi/m) = N_{\\mathrm{periods}} \\cdot m$。\n4.  从 $(x_0, v_0) = (1, 0)$ 开始，将所选积分器应用 $N_{\\mathrm{steps}}$ 次，以获得最终数值状态 $(x_{n_{\\mathrm{final}}}, v_{n_{\\mathrm{final}}})$。\n5.  最终数值相角计算如下 $\\phi_{n_{\\mathrm{final}}} = \\operatorname{atan2}(v_{n_{\\mathrm{final}}}/\\omega, x_{n_{\\mathrm{final}}}) = \\operatorname{atan2}(v_{n_{\\mathrm{final}}}, x_{n_{\\mathrm{final}}})$。\n6.  最终时刻的精确相角为 $\\phi_{\\mathrm{exact}}(t_{\\mathrm{end}}) = \\omega t_{\\mathrm{end}} = 1 \\cdot (N_{\\mathrm{periods}} \\cdot 2\\pi) = 2\\pi N_{\\mathrm{periods}}$。\n7.  最终相位误差是环绕差：\n    $$ \\Delta\\phi_{n_{\\mathrm{final}}} = \\mathrm{wrap}_{(-\\pi,\\pi]}\\!\\left(\\phi_{n_{\\mathrm{final}}} - \\phi_{\\mathrm{exact}}(t_{\\mathrm{end}})\\right) $$\n    环绕函数 $\\mathrm{wrap}_{(-\\pi,\\pi]}(\\theta)$ 将角度 $\\theta$ 映射到其在区间 $(-\\pi, \\pi]$ 中的唯一等效值。这可以通过变换 $\\theta' = ((\\theta + \\pi) \\pmod{2\\pi}) - \\pi$ 在数值上实现，并需要特殊处理将任何 $-\\pi$ 的结果映射到 $\\pi$ 以匹配指定区间。\n\n程序将对所有 18 个测试案例执行此过程，并报告所得的相位误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of calculating the final phase error for three numerical\n    methods applied to the simple harmonic oscillator.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    methods = [\"Euler\", \"Leapfrog\", \"RK4\"]\n    m_values = [4, 20, 200]\n    n_periods_values = [10, 100]\n    \n    test_cases = []\n    for method in methods:\n        for m in m_values:\n            for n_periods in n_periods_values:\n                test_cases.append({'method': method, 'm': m, 'n_periods': n_periods})\n    \n    results = []\n\n    def wrap_to_pi(theta):\n        \"\"\"\n        Wraps an angle theta in radians to the interval (-pi, pi].\n        \"\"\"\n        val = (theta + np.pi) % (2 * np.pi) - np.pi\n        # The modulo operation gives a result in [-pi, pi).\n        # We map -pi to pi to match the interval (-pi, pi].\n        if np.isclose(val, -np.pi):\n            return np.pi\n        return val\n\n    # ODE definition: x' = v, v' = -omega^2 * x. Here omega = 1.\n    omega = 1.0\n\n    # ----- Integrator Implementations -----\n\n    def euler_step(x, v, h):\n        \"\"\"Performs a single step of the Explicit Euler method.\"\"\"\n        x_new = x + h * v\n        v_new = v - h * (omega**2) * x\n        return x_new, v_new\n\n    def leapfrog_verlet_step(x, v, h):\n        \"\"\"Performs a single step of the Leapfrog (Velocity Verlet) method.\"\"\"\n        # Acceleration at current position\n        a_n = -(omega**2) * x\n        # Half-step velocity update\n        v_half = v + 0.5 * h * a_n\n        # Full-step position update\n        x_new = x + h * v_half\n        # Acceleration at new position\n        a_n1 = -(omega**2) * x_new\n        # Final velocity update\n        v_new = v_half + 0.5 * h * a_n1\n        return x_new, v_new\n\n    def rk4_step(x, v, h):\n        \"\"\"Performs a single step of the classical RK4 method.\"\"\"\n        \n        def f(x_in, v_in):\n            return v_in, -(omega**2) * x_in\n\n        # k1\n        k1_x, k1_v = f(x, v)\n        \n        # k2\n        k2_x, k2_v = f(x + 0.5 * h * k1_x, v + 0.5 * h * k1_v)\n        \n        # k3\n        k3_x, k3_v = f(x + 0.5 * h * k2_x, v + 0.5 * h * k2_v)\n        \n        # k4\n        k4_x, k4_v = f(x + h * k3_x, v + h * k3_v)\n        \n        # Update\n        x_new = x + (h / 6.0) * (k1_x + 2*k2_x + 2*k3_x + k4_x)\n        v_new = v + (h / 6.0) * (k1_v + 2*k2_v + 2*k3_v + k4_v)\n        \n        return x_new, v_new\n\n    integrators = {\n        \"Euler\": euler_step,\n        \"Leapfrog\": leapfrog_verlet_step,\n        \"RK4\": rk4_step,\n    }\n\n    for case in test_cases:\n        method = case['method']\n        m = case['m']\n        n_periods = case['n_periods']\n\n        # Setup simulation parameters\n        h = 2.0 * np.pi / m\n        t_end = n_periods * 2.0 * np.pi\n        num_steps = int(round(t_end / h))\n        \n        # Initial conditions\n        x, v = 1.0, 0.0\n\n        # Select integration function\n        step_func = integrators[method]\n\n        # Run simulation\n        for _ in range(num_steps):\n            x, v = step_func(x, v, h)\n        \n        # Calculate final phase error\n        # Final numerical phase\n        phi_numerical = np.arctan2(v / omega, x)\n        \n        # Final exact phase\n        phi_exact = omega * t_end\n        \n        # Phase error is the wrapped difference\n        phase_error = wrap_to_pi(phi_numerical - phi_exact)\n        \n        results.append(phase_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15f}' for r in results)}]\")\n\nsolve()\n```", "id": "3259724"}, {"introduction": "前面的练习揭示了固定步长方法的局限性：一个对整个积分区间都“最佳”的步长几乎不存在。现实世界的解决方案是让求解器“智能”地调整步长：在解变化平缓时采用大步长，在解剧烈变化时则采用小步长。本练习[@problem_id:3259704]将指导你实现一个自适应步长求解器的核心机制，即嵌入式龙格-库塔方法（如 Bogacki–Shampine 2(3) 对）。你将学习如何利用高阶和低阶解的差异来估计局部误差，并构建一个步长控制算法来动态调整步长，从而在满足预设精度要求的同时最大化计算效率。", "problem": "考虑一个由常微分方程 (ODE) $y'(t) = f(t,y)$ 和初始条件 $y(t_0) = y_0$ 定义的初值问题 (IVP)。单步法仅使用当前步的信息将解从 $(t,y)$推进到 $(t+h, y_{\\text{new}})$。在显式 Runge-Kutta (RK) 方法中，增量由各阶段导数的加权组合构成。嵌入式 RK 对根据相同的阶段计算提供两种不同阶的近似值，从而能够进行局部误差估计以实现自适应步长控制。\n\n您的任务是实现一个与 Bogacki–Shampine $2(3)$ 构造一致的嵌入式 Runge-Kutta 对，并用它来驱动一个自适应步长选择算法。该算法必须：\n\n- 在每一步计算阶段导数，并生成一个高阶近似值 $y^{[p]}$ 和一个低阶近似值 $y^{[q]}$，其中 $p>q$。\n- 根据差值 $y^{[p]} - y^{[q]}$ 估计局部截断误差。\n- 当缩放后的误差范数小于或等于 $1$ 时接受一个步长，否则拒绝。\n- 利用误差和步长之间的渐进缩放关系来调整步长 $h$，通过应用安全因子并限制 $h$ 的增长和衰减来确保数值稳定性。\n- 尊重最终时间 $t_f$，必要时减小最后一步的步长，以使 $t$ 恰好达到 $t_f$。\n\n您必须为标量 ODE 实现自适应积分器，每步使用以下缩放误差范数：\n$$\nE = \\frac{|y^{[p]} - y^{[q]}|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[p]}|)},\n$$\n其中 $\\mathrm{atol}$ 是绝对公差，$\\mathrm{rtol}$ 是相对公差。如果 $E \\leq 1$，则接受该步。步长控制器必须基于以下原理：阶为 $h^{m}$ 的误差意味着 $h_{\\text{new}} \\propto h\\,E^{-1/m}$，其中整数 $m$ 与误差估计器的阶数相匹配。包括一个乘法安全因子，并通过预设的界限来限制增长和衰减。\n\n当出现三角函数时，角度量必须解释为弧度。\n\n实现该自适应求解器，并将其应用于以下 IVP 测试套件。对于每种情况，以浮点数形式返回 $y(t_f)$ 的数值近似值。\n\n- 情况 $1$（理想路径，指数稳定）：\n  - $f(t,y) = -y$, $y(0) = 1$, $t_0 = 0$, $t_f = 5$.\n  - 公差： $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$.\n  - 基本原理：测试在平滑问题上的一般性能和稳定性。\n\n- 情况 $2$（带三角函数强迫项的时间相关增长，弧度）：\n  - $f(t,y) = y\\sin(t)$, $y(0) = 1$, $t_0 = 0$, $t_f = 3$.\n  - 公差： $\\mathrm{rtol} = 10^{-7}$, $\\mathrm{atol} = 10^{-10}$.\n  - 基本原理：测试对时间相关系数的处理，并要求角度以弧度为单位。\n\n- 情况 $3$（中度类刚性线性衰减）：\n  - $f(t,y) = -15\\,y$, $y(0) = 1$, $t_0 = 0$, $t_f = 1$.\n  - 公差： $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$.\n  - 基本原理：测试在较快衰减下的步长自适应能力。\n\n- 情况 $4$（奇点附近的非线性增长）：\n  - $f(t,y) = y^2$, $y(0) = 1$, $t_0 = 0$, $t_f = 0.9$.\n  - 公差： $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$.\n  - 基本原理：测试在 $t=1$ 处发生爆破附近的鲁棒性。\n\n- 情况 $5$（零动态，边界情况）：\n  - $f(t,y) = 0$, $y(0) = 5$, $t_0 = 0$, $t_f = 10$.\n  - 公差： $\\mathrm{rtol} = 10^{-8}$, $\\mathrm{atol} = 10^{-12}$.\n  - 基本原理：测试当估计误差恒为零时控制器的行为。\n\n所有情况共用的控制器参数：\n- 安全因子 $s = 0.9$,\n- 最小增长因子 $g_{\\min} = 0.2$,\n- 最大增长因子 $g_{\\max} = 5.0$,\n- 初始步长 $h_0 = 10^{-3}$,\n- 最小步长 $h_{\\min} = 10^{-12}$,\n- 最大步长 $h_{\\max} = (t_f - t_0)$.\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况 $1$ 到情况 $5$ 的顺序排列结果，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是情况 $i$ 的 $y(t_f)$ 的浮点近似值。", "solution": "此任务的核心是根据初值问题 (IVP)、Runge-Kutta (RK) 方法和局部截断误差的定义，从第一性原理出发构建一个自适应单步积分器。\n\n一个 IVP 指定了 $y'(t) = f(t,y)$ 及 $y(t_0) = y_0$。单步法使用单个步长 $h_n$ 从 $(t_n,y_n)$ 计算 $y_{n+1}$，而不参考更早的历史记录。在显式 Runge-Kutta (RK) 方法中，新值是各阶段导数的加权组合。通用显式 RK 构造如下：\n$$\nk_1 = f(t_n, y_n),\\quad\nk_2 = f(t_n + c_2 h, y_n + h a_{21} k_1),\\quad \\dots,\\quad\nk_s = f(t_n + c_s h, y_n + h \\sum_{j=1}^{s-1} a_{sj} k_j),\n$$\n一个 $p$ 阶近似为\n$$\ny^{[p]}_{n+1} = y_n + h \\sum_{j=1}^s b_j k_j.\n$$\n嵌入式对提供两组权重 $(b_j)$ 和 $(\\hat b_j)$，它们使用相同的阶段进行评估，以得到 $p>q$ 的 $y^{[p]}$ 和 $y^{[q]}$。差值\n$$\n\\Delta = y^{[p]}_{n+1} - y^{[q]}_{n+1}\n$$\n的计算开销可以忽略不计，并且它会随 $h$ 的某个已知幂次进行缩放，该幂次由构造决定。\n\n对于 Bogacki–Shampine $2(3)$ 对，该方法使用 $s=4$ 个阶段，节点为 $c_2 = \\tfrac{1}{2}$、$c_3 = \\tfrac{3}{4}$、$c_4 = 1$。内部系数为 $a_{21} = \\tfrac{1}{2}$、$a_{32} = \\tfrac{3}{4}$（其中 $a_{31} = 0$）以及 $a_{41} = \\tfrac{2}{9}$、$a_{42} = \\tfrac{1}{3}$、$a_{43} = \\tfrac{4}{9}$。高阶（$p=3$ 阶）权重为\n$$\nb_1 = \\tfrac{2}{9},\\quad b_2 = \\tfrac{1}{3},\\quad b_3 = \\tfrac{4}{9},\\quad b_4 = 0,\n$$\n而低阶（$q=2$ 阶）权重为\n$$\n\\hat b_1 = \\tfrac{7}{24},\\quad \\hat b_2 = \\tfrac{1}{4},\\quad \\hat b_3 = \\tfrac{1}{3},\\quad \\hat b_4 = \\tfrac{1}{8}.\n$$\n阶段和近似值的计算如下\n$$\n\\begin{aligned}\nk_1 = f(t, y),\\\\\nk_2 = f\\Big(t + \\tfrac{1}{2}h,\\, y + h\\,\\tfrac{1}{2}\\,k_1\\Big),\\\\\nk_3 = f\\Big(t + \\tfrac{3}{4}h,\\, y + h\\,\\tfrac{3}{4}\\,k_2\\Big),\\\\\ny^{[3]} = y + h\\Big(\\tfrac{2}{9}k_1 + \\tfrac{1}{3}k_2 + \\tfrac{4}{9}k_3\\Big),\\\\\nk_4 = f\\Big(t + h,\\, y^{[3]}\\Big),\\\\\ny^{[2]} = y + h\\Big(\\tfrac{7}{24}k_1 + \\tfrac{1}{4}k_2 + \\tfrac{1}{3}k_3 + \\tfrac{1}{8}k_4\\Big).\n\\end{aligned}\n$$\n嵌入式差值 $\\Delta = y^{[3]} - y^{[2]}$ 提供了一个误差估计器，其主导行为为 $O(h^3)$；也就是说，对于平滑的 $f$，它像 $C h^3$ 一样缩放。这种缩放特性使得形式为\n$$\nh_{\\text{new}} = h \\cdot s \\cdot E^{-1/3},\n$$\n的控制器是合理的，其中 $s$ 是一个安全因子，$E$ 是一个缩放后的误差范数。为确保数值鲁棒性，我们将乘法增长/衰减因子限制在 $g_{\\min} \\leq s E^{-1/3} \\leq g_{\\max}$ 范围内，并且还将 $h_{\\text{new}}$ 裁剪到 $[h_{\\min}, h_{\\max}]$。当 $E \\leq 1$ 时，该步被接受，$y$ 前进到 $y^{[3]}$；否则，该步被拒绝，并用一个更小的 $h$ 重新计算。\n\n对于标量问题，选择缩放后的误差范数以平衡绝对公差和相对公差：\n$$\nE = \\frac{|\\Delta|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[3]}|)}.\n$$\n这确保了接受准则 $E \\leq 1$ 能相对于解的量级控制误差，同时防止当 $y$ 接近零时出现被极小数除的情况。\n\n从 $t_0$ 积分到 $t_f$ 的算法步骤：\n- 初始化 $t = t_0$，$y = y_0$，在 $[h_{\\min}, h_{\\max}]$ 中选择 $h$（例如给定的 $h_0$），并设置控制器参数 $s$、$g_{\\min}$、$g_{\\max}$。\n- 当 $t < t_f$ 时：\n  - 如果 $t + h > t_f$，则设置 $h = t_f - t$ 以精确到达 $t_f$。\n  - 计算 $k_1$、$k_2$、$k_3$、$y^{[3]}$、$k_4$ 和 $y^{[2]}$。\n  - 根据 $y$、$y^{[3]}$、$y^{[2]}$、$\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 计算 $E$。\n  - 如果 $E \\leq 1$，接受该步：设置 $t \\gets t + h$，$y \\gets y^{[3]}$。\n  - 计算候选增长因子 $g = s \\cdot E^{-1/3}$；如果 $E=0$，则设置 $g = g_{\\max}$。\n  - 将 $g$ 限制在 $[g_{\\min}, g_{\\max}]$ 范围内，然后更新 $h \\gets \\mathrm{clip}(h \\cdot g, h_{\\min}, h_{\\max})$。\n  - 如果一个步长被拒绝 ($E > 1$)，则如上更新 $h$ 并重新计算，但不推进 $t$ 或 $y$。\n- 返回 $y(t_f)$。\n\n我们现在简要分析每个测试用例及其预期行为：\n- 情况 $1$：$y'(t) = -y$，精确解为 $y(t) = e^{-t}$，因此 $y(5) = e^{-5}$。该方法应采取适中的步长并快速收敛。\n- 情况 $2$：$y'(t) = y\\sin(t)$（弧度制），精确解为 $y(t) = \\exp(1 - \\cos t)$，得出 $y(3) = \\exp(1 - \\cos 3)$。算法必须平滑地处理与时间相关的强迫项。\n- 情况 $3$：$y'(t) = -15y$，精确解为 $y(1) = e^{-15}$，由于快速衰减，最初需要较小的步长，但随着 $y$ 变小，控制器会增加 $h$。\n- 情况 $4$：$y'(t) = y^2$，当 $t<1$ 时精确解为 $y(t) = \\frac{1}{1 - t}$，因此 $y(0.9) = 10$。当 $t$ 接近 $t=1$ 处的爆破点时，方法必须自适应地减小 $h$。\n- 情况 $5$：$y'(t) = 0$ 产生常数解 $y(t) = 5$；误差估计器恒为零，控制器将把 $h$ 增大到 $h_{\\max}$。\n\n通过实现 Bogacki–Shampine $2(3)$ 阶段和从 $O(h^3)$ 误差估计推导出的控制器，该自适应求解器将为所有情况提供 $y(t_f)$，并以指定格式打印。", "answer": "```python\n# Python 3.12, numpy 1.23.5 allowed; no other libraries.\nimport numpy as np\n\ndef rk23_bogacki_shampine_step(f, t, y, h):\n    \"\"\"\n    Perform one Bogacki-Shampine 2(3) step for a scalar ODE y' = f(t,y).\n    Returns (y_high, y_low) where y_high is the 3rd-order solution, y_low is the 2nd-order embedded solution.\n    \"\"\"\n    k1 = f(t, y)\n    k2 = f(t + 0.5 * h, y + h * 0.5 * k1)\n    k3 = f(t + 0.75 * h, y + h * 0.75 * k2)\n    # 3rd-order solution\n    y3 = y + h * ( (2.0/9.0) * k1 + (1.0/3.0) * k2 + (4.0/9.0) * k3 )\n    # Stage 4 evaluated at t+h, y3\n    k4 = f(t + h, y3)\n    # 2nd-order embedded solution\n    y2 = y + h * ( (7.0/24.0) * k1 + (1.0/4.0) * k2 + (1.0/3.0) * k3 + (1.0/8.0) * k4 )\n    return y3, y2\n\ndef integrate_adaptive(f, t0, tf, y0, rtol, atol,\n                       h0=1e-3, hmin=1e-12, hmax=None,\n                       safety=0.9, growth_min=0.2, growth_max=5.0):\n    \"\"\"\n    Adaptive integrator using Bogacki-Shampine 2(3) pair for scalar ODEs.\n    \"\"\"\n    t = float(t0)\n    y = float(y0)\n    if hmax is None:\n        hmax = abs(tf - t0)\n    h = max(hmin, min(h0, hmax))\n    # Direction of integration\n    direction = 1.0 if tf >= t0 else -1.0\n    h *= direction\n    hmin_signed = hmin * direction\n    hmax_signed = hmax * direction\n\n    # Main integration loop\n    # Guard for max iterations to prevent infinite loops in pathological cases\n    max_steps = 10_000_000\n    steps = 0\n    while (direction > 0 and t < tf) or (direction < 0 and t > tf):\n        steps += 1\n        if steps > max_steps:\n            # Fallback: give current y\n            break\n\n        # Adjust step to not overshoot tf\n        remaining = tf - t\n        if direction * h > direction * remaining:\n            h = remaining\n\n        # Take one RK23 step\n        y3, y2 = rk23_bogacki_shampine_step(f, t, y, h)\n\n        # Scaled error norm (scalar)\n        scale = atol + rtol * max(abs(y), abs(y3))\n        # Prevent zero scale\n        if scale == 0.0:\n            scale = atol\n        err = abs(y3 - y2) / scale\n\n        # Accept or reject\n        if err <= 1.0:\n            # Accept the step\n            t = t + h\n            y = y3\n            # Compute growth factor; estimator scales ~ h^3\n            if err == 0.0:\n                g = growth_max\n            else:\n                g = safety * err ** (-1.0 / 3.0)\n            # Bound growth factor\n            g = max(growth_min, min(g, growth_max))\n            # Update h and clip\n            h = h * g\n            # Clip to [hmin, hmax] with sign\n            if direction > 0:\n                h = min(max(h, hmin_signed), hmax_signed)\n            else:\n                h = max(min(h, hmin_signed), hmax_signed)\n        else:\n            # Reject step; decrease h\n            g = safety * err ** (-1.0 / 3.0)\n            g = max(growth_min, min(g, growth_max))\n            h = h * g\n            # Ensure not below minimum\n            if direction > 0:\n                h = max(h, hmin_signed)\n            else:\n                h = min(h, hmin_signed)\n            # If h becomes too small, break to avoid infinite loop\n            if abs(h) < hmin:\n                # Cannot reduce further; accept and break\n                # This is a conservative fallback\n                t = t + h\n                y = y3\n                break\n\n    return y\n\ndef solve():\n    # Define the test cases\n    # Case 1: y' = -y, y(0) = 1, tf = 5\n    def f1(t, y): return -y\n\n    # Case 2: y' = y*sin(t), radians, y(0) = 1, tf = 3\n    def f2(t, y): return y * np.sin(t)\n\n    # Case 3: y' = -15 y, y(0) = 1, tf = 1\n    def f3(t, y): return -15.0 * y\n\n    # Case 4: y' = y^2, y(0) = 1, tf = 0.9\n    def f4(t, y): return y * y\n\n    # Case 5: y' = 0, y(0) = 5, tf = 10\n    def f5(t, y): return 0.0\n\n    test_cases = [\n        # (f, t0, tf, y0, rtol, atol)\n        (f1, 0.0, 5.0, 1.0, 1e-6, 1e-9),\n        (f2, 0.0, 3.0, 1.0, 1e-7, 1e-10),\n        (f3, 0.0, 1.0, 1.0, 1e-6, 1e-9),\n        (f4, 0.0, 0.9, 1.0, 1e-6, 1e-9),\n        (f5, 0.0, 10.0, 5.0, 1e-8, 1e-12),\n    ]\n\n    results = []\n    for f, t0, tf, y0, rtol, atol in test_cases:\n        ytf = integrate_adaptive(\n            f=f, t0=t0, tf=tf, y0=y0, rtol=rtol, atol=atol,\n            h0=1e-3, hmin=1e-12, hmax=abs(tf - t0),\n            safety=0.9, growth_min=0.2, growth_max=5.0\n        )\n        results.append(ytf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3259704"}]}