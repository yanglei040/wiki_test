{"hands_on_practices": [{"introduction": "这个练习是理解刚性问题的经典入门。我们将通过一个简单的线性常微分方程（ODE）开始，该方程的解包含两个在截然不同时间尺度上变化的组分。通过推导其精确解，并与显式（前向欧拉法）和隐式（后向欧拉法）数值方法的结果进行比较，你将亲身体会到为何对于刚性问题，稳定性而非精度往往主导着步长的选择，并理解为何隐式方法是必不可少的。[@problem_id:3198039]", "problem": "考虑常微分方程 (ODE) 的初值问题 (IVP)：$y^{\\prime}(t) = -\\dfrac{1}{\\epsilon} y(t) + \\sin(t)$，区间为 $t \\in [0, 10]$，初始条件为 $y(0) = 0$。参数 $\\epsilon$ 是一个小的正常数，由 $\\epsilon = 10^{-6}$ 给出，并且正弦函数中 $t$ 的角度单位是弧度。由于项 $-\\dfrac{1}{\\epsilon} y(t)$ 的存在，该初值问题表现出刚性，这一项在解中引入了一个快速衰减的分量。\n\n从基本定义和经过充分检验的事实出发，完成以下任务：\n\n1. 基于线性 ODE 结构，使用积分因子法推导给定 IVP 的精确解析解 $y(t)$。您的推导必须从一阶线性 ODE 的定义和积分因子的构造开始，并且不得依赖任何提供给您的快捷公式。\n\n2. 使用导数作为差商极限的定义以及使用固定步长 $h$ 进行时间离散化的思想，推导：\n   - 通过在每个时间步的左端点近似 $y^{\\prime}(t)$ 来推导显式前向欧拉更新规则。\n   - 通过在每个时间步的右端点近似 $y^{\\prime}(t)$ 来推导隐式后向欧拉更新规则。\n   两个推导都必须源于定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\dfrac{y(t+h) - y(t)}{h}$，并且不得假定任何预先形成的离散更新公式。\n\n3. 使用 Dahlquist 测试方程 $y^{\\prime} = \\lambda y$ 的线性稳定性分析，解释为什么当 $\\epsilon$ 很小时，该 IVP 是刚性的，以及这对显式方法允许的步长有何影响。特别是，从第一性原理出发，确定对显式方法中 $h$ 的约束，并将其与隐式方法的行为进行对比。\n\n4. 实现所推导的两种方法，在一组固定的时间步长 $h$ 下，对 $t \\in [0, 10]$ 上的 $y(t)$ 进行数值逼近。对于每种方法和每个时间步长，计算离散网格点上相对于您推导的精确解的最大绝对误差。如果在显式积分过程中数值解变为非有限值（例如由于溢出），则将该情况下的最大误差视为 $+\\infty$。\n\n角度单位说明：所有三角函数求值必须使用弧度。\n\n测试套件：\n- 参数：$\\epsilon = 10^{-6}$。\n- 初始条件：$y(0) = 0$。\n- 区间：$[0, 10]$。\n- 步长：$h \\in \\{1.0, 0.1, 0.01, 0.001\\}$。\n\n对于上述集合中的每个步长 $h$，评估：\n- 显式前向欧拉法在离散时间网格 $\\{0, h, 2h, \\dots, 10\\}$ 上的最大绝对误差。\n- 隐式后向欧拉法在同一网格上的最大绝对误差。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，\"[result1,result2,result3,...]\"）。该列表必须按以下顺序汇总结果：对于每个按升序排列的 $h$，首先是显式方法的最大误差，然后是隐式方法的最大误差，因此最终输出有八个条目，按顺序对应于 $h = 0.001$，$h = 0.01$，$h = 0.1$ 和 $h = 1.0$。", "solution": "该问题被评估为有效，因为它具有科学依据、良定、客观且自洽。它提出了一个刚性常微分方程（ODE）的典型例子，并要求进行计算科学领域基础的推导和分析。问题陈述没有矛盾或谬误。\n\n解答分为四个部分，对应于问题描述中列出的任务。\n\n### 1. 精确解析解的推导\n\n给定的初值问题 (IVP) 是：\n$$\ny^{\\prime}(t) = -\\frac{1}{\\epsilon} y(t) + \\sin(t), \\quad y(0) = 0, \\quad t \\in [0, 10]\n$$\n这是一个一阶线性 ODE。此类方程的标准形式是 $y' + p(t)y = q(t)$。通过重新排列给定的 ODE，我们确定相应的项：\n$$\ny^{\\prime}(t) + \\frac{1}{\\epsilon} y(t) = \\sin(t)\n$$\n这里，$p(t) = \\frac{1}{\\epsilon}$ 且 $q(t) = \\sin(t)$。\n\n为了求解它，我们使用积分因子法。积分因子 $I(t)$ 定义为：\n$$\nI(t) = e^{\\int p(t) dt}\n$$\n对于本问题，积分为：\n$$\n\\int p(t) dt = \\int \\frac{1}{\\epsilon} dt = \\frac{t}{\\epsilon}\n$$\n因此，积分因子是 $I(t) = e^{t/\\epsilon}$。我们将 ODE 的标准形式乘以 $I(t)$：\n$$\ne^{t/\\epsilon} y^{\\prime}(t) + \\frac{1}{\\epsilon} e^{t/\\epsilon} y(t) = e^{t/\\epsilon} \\sin(t)\n$$\n根据乘法法则，左侧是 $y(t)I(t)$ 的导数：\n$$\n\\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) = e^{t/\\epsilon} \\sin(t)\n$$\n为了求 $y(t)$，我们对两边关于 $t$ 进行积分：\n$$\n\\int \\frac{d}{dt} \\left( y(t) e^{t/\\epsilon} \\right) dt = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n$$\ny(t) e^{t/\\epsilon} = \\int e^{t/\\epsilon} \\sin(t) dt\n$$\n右侧的积分可以通过两次分部积分法求解。形如 $\\int e^{at}\\sin(bt)dt$ 的积分通解为 $\\frac{e^{at}}{a^2+b^2}(a\\sin(bt) - b\\cos(bt))$。令 $a = 1/\\epsilon$ 和 $b = 1$，我们有：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1/\\epsilon)^2 + 1^2} \\left( \\frac{1}{\\epsilon}\\sin(t) - 1\\cos(t) \\right) + C\n$$\n其中 $C$ 是积分常数。简化此表达式：\n$$\n\\int e^{t/\\epsilon} \\sin(t) dt = \\frac{e^{t/\\epsilon}}{(1+\\epsilon^2)/\\epsilon^2} \\left( \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} \\right) + C = \\frac{\\epsilon^2 e^{t/\\epsilon}}{1+\\epsilon^2} \\frac{\\sin(t) - \\epsilon\\cos(t)}{\\epsilon} + C\n$$\n$$\n= \\frac{\\epsilon e^{t/\\epsilon}}{1+\\epsilon^2} (\\sin(t) - \\epsilon\\cos(t)) + C = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n将此结果代入 $y(t)e^{t/\\epsilon}$ 的方程中：\n$$\ny(t) e^{t/\\epsilon} = \\frac{e^{t/\\epsilon}}{1+\\epsilon^2} (\\epsilon\\sin(t) - \\epsilon^2\\cos(t)) + C\n$$\n通过乘以 $e^{-t/\\epsilon}$ 解出 $y(t)$：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + C e^{-t/\\epsilon}\n$$\n现在，我们应用初始条件 $y(0) = 0$ 来求常数 $C$：\n$$\ny(0) = 0 = \\frac{\\epsilon\\sin(0) - \\epsilon^2\\cos(0)}{1+\\epsilon^2} + C e^{0}\n$$\n$$\n0 = \\frac{0 - \\epsilon^2(1)}{1+\\epsilon^2} + C \\implies C = \\frac{\\epsilon^2}{1+\\epsilon^2}\n$$\n将 $C$ 的值代回，得到 IVP 的精确解析解：\n$$\ny(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}\n$$\n\n### 2. 数值方法的推导\n\n我们从导数的极限定义 $y^{\\prime}(t) = \\lim_{h \\to 0} \\frac{y(t+h) - y(t)}{h}$ 推导数值更新规则。我们考虑一个离散时间网格 $t_n = n h$，其中 $n=0, 1, 2, \\dots$，$h$ 是步长。设 $y_n$ 是 $y(t_n)$ 的数值近似。\n\n**显式前向欧拉法**\n前向欧拉法在时间步的开始 $t_n$ 处近似导数 $y'(t)$。使用基于极限定义的一阶前向差商：\n$$\ny^{\\prime}(t_n) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此代入 ODE，$y'(t) = f(t, y(t)) = -\\frac{1}{\\epsilon} y(t) + \\sin(t)$，在时间 $t_n$ 处：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_n + \\sin(t_n)\n$$\n解出 $y_{n+1}$，得到显式前向欧拉更新规则：\n$$\ny_{n+1} = y_n + h \\left( -\\frac{1}{\\epsilon} y_n + \\sin(t_n) \\right)\n$$\n此规则是“显式”的，因为 $y_{n+1}$ 是直接从时间 $t_n$ 的已知值计算出来的。\n\n**隐式后向欧拉法**\n后向欧拉法通过在时间步的末尾 $t_{n+1}$ 处评估 ODE 来近似导数。导数 $y'(t_{n+1})$ 使用后向差商来近似：\n$$\ny^{\\prime}(t_{n+1}) \\approx \\frac{y(t_{n+1}) - y(t_n)}{h}\n$$\n将此代入时间 $t_{n+1}$ 处的 ODE：\n$$\n\\frac{y_{n+1} - y_n}{h} = -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1})\n$$\n这个方程是“隐式”的，因为未知数 $y_{n+1}$ 出现在方程的两边。我们必须解出 $y_{n+1}$：\n$$\ny_{n+1} - y_n = h \\left( -\\frac{1}{\\epsilon} y_{n+1} + \\sin(t_{n+1}) \\right)\n$$\n$$\ny_{n+1} - y_n = -\\frac{h}{\\epsilon} y_{n+1} + h\\sin(t_{n+1})\n$$\n收集包含 $y_{n+1}$ 的项：\n$$\ny_{n+1} + \\frac{h}{\\epsilon} y_{n+1} = y_n + h\\sin(t_{n+1})\n$$\n$$\ny_{n+1} \\left( 1 + \\frac{h}{\\epsilon} \\right) = y_n + h\\sin(t_{n+1})\n$$\n最后，解出 $y_{n+1}$ 得到隐式后向欧拉更新规则：\n$$\ny_{n+1} = \\frac{y_n + h\\sin(t_{n+1})}{1 + h/\\epsilon}\n$$\n\n### 3. 稳定性分析与刚性\n\n刚性的概念通过 Dahlquist 测试方程 $y' = \\lambda y$ 进行分析，其中 $\\text{Re}(\\lambda)  0$。对于给定的 ODE，其动态主要由齐次部分 $y' = -\\frac{1}{\\epsilon} y$ 决定。因此，我们确定 $\\lambda = -1/\\epsilon$。由于 $\\epsilon = 10^{-6}$ 是一个小的正常数，$\\lambda = -10^6$ 是一个大的负实数。\n\n**前向欧拉稳定性**\n将前向欧拉规则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_n) = (1+h\\lambda) y_n\n$$\n为使数值解保持有界（即稳定），放大因子 $R(h\\lambda) = 1+h\\lambda$ 必须满足 $|R(h\\lambda)| \\le 1$。\n$$\n|1 + h\\lambda| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这变为 $|1 - h/\\epsilon| \\le 1$。此不等式等价于 $-1 \\le 1 - h/\\epsilon \\le 1$。\n右侧，$1 - h/\\epsilon \\le 1$，意味着 $h/\\epsilon \\ge 0$，对于正的 $h$ 和 $\\epsilon$ 总是成立的。\n左侧，$-1 \\le 1 - h/\\epsilon$，意味着 $h/\\epsilon \\le 2$，或 $h \\le 2\\epsilon$。\n对于 $\\epsilon=10^{-6}$，步长必须满足 $h \\le 2 \\times 10^{-6}$。这是一个非常严格的限制。对于任何步长 $h > 2\\epsilon$，数值解将变得无界，呈现指数增长的振荡。\n\n**后向欧拉稳定性**\n将后向欧拉规则应用于 $y'=\\lambda y$：\n$$\ny_{n+1} = y_n + h(\\lambda y_{n+1}) \\implies y_{n+1}(1 - h\\lambda) = y_n \\implies y_{n+1} = \\frac{1}{1-h\\lambda} y_n\n$$\n放大因子是 $R(h\\lambda) = \\frac{1}{1-h\\lambda}$。为了稳定，我们需要 $|R(h\\lambda)| \\le 1$。\n$$\n\\left| \\frac{1}{1-h\\lambda} \\right| \\le 1\n$$\n当 $\\lambda = -1/\\epsilon$ 时，这是 $\\left| \\frac{1}{1+h/\\epsilon} \\right|$。由于 $h > 0$ 且 $\\epsilon > 0$，分母 $1+h/\\epsilon$ 总是大于 1。因此，其倒数的绝对值总是小于 1。该方法对于任何 $h > 0$ 的选择都是稳定的。这个性质被称为 A-稳定性。\n\n**刚性解释**\n该 IVP 是刚性的，因为精确解 $y(t) = \\frac{\\epsilon\\sin(t) - \\epsilon^2\\cos(t)}{1+\\epsilon^2} + \\frac{\\epsilon^2}{1+\\epsilon^2} e^{-t/\\epsilon}$ 包含两个时间尺度差异巨大的分量。\n1. 一个快速衰减的瞬态分量，与 $e^{-t/\\epsilon}$ 成正比，其特征时间尺度为 $\\tau_{fast} = \\epsilon = 10^{-6}$。该分量几乎瞬间变得可以忽略不计。\n2. 一个缓慢变化的分量，其振荡时间尺度约为 $\\tau_{slow} \\approx 2\\pi$。\n\n刚性的产生是因为像前向欧拉法这样的显式方法的稳定性受最快时间尺度 ($\\tau_{fast}$) 控制，即使在快速分量消失很久之后，仍强制使用不切实际的小步长 ($h \\le 2\\epsilon$)。而像后向欧拉法这样的隐式方法，对于本问题是无条件稳定的，其稳定性不受 $\\tau_{fast}$ 的限制。它可以使用由捕捉慢分量的精度要求决定的更大的步长 $h$，这使其在处理刚性问题时效率高得多。\n\n### 4. 实现与误差分析\n\n实现了前向和后向欧拉法，用于在步长 $h \\in \\{0.001, 0.01, 0.1, 1.0\\}$ 下求解 $t \\in [0, 10]$ 上的 IVP。由于所有这些步长都违反了前向欧拉稳定性条件 ($h > 2 \\times 10^{-6}$)，预计显式方法将产生数值不稳定的解，该解会无界增长，导致无穷大的最大误差。隐式方法由于是稳定的，应该会产生准确的结果，且误差随着 $h$ 的减小而减小。对于每种情况，在网格点上计算数值解与精确解之间的最大绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a stiff ODE using Forward and Backward Euler methods,\n    and calculates the maximum absolute error against the exact solution.\n    \"\"\"\n    \n    # Define problem parameters from the statement\n    epsilon = 1e-6\n    t_end = 10.0\n    y0 = 0.0\n    \n    # Test suite of step sizes, in increasing order as required for output.\n    h_values = [0.001, 0.01, 0.1, 1.0]\n    \n    # List to store the results in the specified order.\n    results = []\n\n    # Exact solution derived via integrating factor\n    # y(t) = (epsilon*sin(t) - epsilon^2*cos(t))/(1 + epsilon^2) \n    #        + (epsilon^2 / (1 + epsilon^2)) * exp(-t/epsilon)\n    def y_exact(t, eps):\n        term1 = (eps * np.sin(t) - eps**2 * np.cos(t)) / (1 + eps**2)\n        term2 = (eps**2 / (1 + eps**2)) * np.exp(-t / eps)\n        return term1 + term2\n\n    # Loop over each step size\n    for h in h_values:\n        # Create a stable time grid from 0 to t_end\n        # Using np.linspace is more robust against floating point errors than np.arange\n        num_steps = int(round(t_end / h))\n        t_points = np.linspace(0, t_end, num_steps + 1)\n        \n        # --- Explicit Forward Euler Method ---\n        y_fe = np.zeros(num_steps + 1)\n        y_fe[0] = y0\n        is_finite_fe = True\n        \n        for n in range(num_steps):\n            # y_{n+1} = y_n + h * f(t_n, y_n)\n            # f(t,y) = -y/epsilon + sin(t)\n            y_fe[n+1] = y_fe[n] + h * (-y_fe[n] / epsilon + np.sin(t_points[n]))\n            # Check for overflow at each step to prevent warnings and handle correctly.\n            if not np.isfinite(y_fe[n+1]):\n                is_finite_fe = False\n                break\n        \n        # Calculate maximum absolute error for Forward Euler\n        if is_finite_fe:\n            y_true = y_exact(t_points, epsilon)\n            error_fe = np.max(np.abs(y_fe - y_true))\n        else:\n            # As per problem, if solution is non-finite, error is +inf\n            error_fe = float('inf')\n        \n        results.append(error_fe)\n        \n        # --- Implicit Backward Euler Method ---\n        y_be = np.zeros(num_steps + 1)\n        y_be[0] = y0\n        \n        for n in range(num_steps):\n            # y_{n+1} = (y_n + h*sin(t_{n+1})) / (1 + h/epsilon)\n            numerator = y_be[n] + h * np.sin(t_points[n+1])\n            denominator = 1 + h / epsilon\n            y_be[n+1] = numerator / denominator\n\n        # Calculate maximum absolute error for Backward Euler\n        y_true = y_exact(t_points, epsilon)\n        error_be = np.max(np.abs(y_be - y_true))\n        results.append(error_be)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3198039"}, {"introduction": "在我们认识到隐式方法对于求解刚性问题的必要性之后，现在我们来处理一个更贴近现实的场景：非线性常微分方程。当像后向欧拉法这样的隐式方法应用于非线性函数时，其更新规则本身会变成一个需要求解的非线性代数方程。这个练习将引导你使用标准技术——牛顿法，在每个时间步中求解这个方程，这是从理想到实践的关键一步。[@problem_id:2442982]", "problem": "给定一个标量常微分方程 (ODE)\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3,\n$$\n其初始条件为\n$$\ny(0) = y_0,\n$$\n在区间\n$$\nt \\in [0,T], \\quad t_n = n\\,h, \\quad n=0,1,\\dots,N, \\quad \\text{with } Nh = T \\text{ and } h0.\n$$\n上的均匀时间网格中。\n函数 $\\sin t$ 中的角度必须以弧度解释。在每一步，使用隐式单步更新\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1}),\n$$\n并使用牛顿法求解得到的关于 $y_{n+1}$ 的非线性代数方程，残差或牛顿步长的绝对停止容差为 $10^{-12}$，且每个时间步最多迭代 50 次。在每一步中，使用 $y_{n}$ 初始化牛顿法。\n\n实现一个程序，对下面测试套件中的每组参数，使用上述方法将数值解从 $t=0$ 推进到 $t=T$，并返回 $y(T)$ 的近似值。\n\n测试套件（每个元组为 $(k,b,y_0,T,h)$）：\n- 情况 A（刚性、非线性、受迫）： $(1000, 10, 0, 0.1, 0.001)$。\n- 情况 B（刚性、线性、受迫）： $(1000, 0, 1, 0.1, 0.001)$。\n- 情况 C（单大步长、刚性、非线性）： $(1000, 5, 1, 0.05, 0.05)$。\n- 情况 D（非刚性、纯非线性）： $(0, 50, 1, 0.02, 0.005)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的条目是按 A、B、C、D 顺序排列的 $y(T)$ 的近似值，每个值都四舍五入到恰好 $8$ 位小数。例如，包含四个结果的输出必须如下所示\n$$\n[\\text{res}_A,\\text{res}_B,\\text{res}_C,\\text{res}_D].\n$$", "solution": "所给问题是一个形如 $\\frac{dy}{dt} = f(t,y)$ 的标量常微分方程（ODE），需要进行数值求解。该问题定义明确，科学上合理，并包含了通过指定算法获得唯一解所需的所有信息。因此，我将着手解决此问题。\n\n控制方程为：\n$$\n\\frac{dy}{dt} = f(t,y) = -k\\,(y - \\sin t) - b\\,y^3, \\quad y(0) = y_0\n$$\n该方程描述了一个系统，其包含一个以速率 $k$ 趋向正弦驱动函数 $\\sin t$ 的线性松弛项，以及一个与 $y^3$ 成正比的非线性阻尼项。$k$ 的大小决定了方程的刚性。对于大的 $k$，显式数值方法需要极小的时间步长 $h \\ll 1/k$ 来维持稳定性。该问题正确地指定了使用隐式方法来处理这种刚性。\n\n数值积分采用隐式单步后向欧拉法进行。对于均匀时间网格 $t_n = n\\,h$，从时间 $t_n$ 到 $t_{n+1}$ 的更新规则由下式给出：\n$$\ny_{n+1} = y_n + h\\,f(t_{n+1}, y_{n+1})\n$$\n其中 $y_n$ 是 $y(t_n)$ 的近似值。该方程是隐式的，因为未知值 $y_{n+1}$ 出现在方程的两边。为了在每个时间步求解 $y_{n+1}$，我们必须解一个非线性代数方程。这个方程可以通过定义一个我们寻求其根的残差函数 $R(x)$ 来表示：\n$$\nR(x) = x - y_n - h\\,f(t_{n+1}, x) = 0\n$$\n其中 $x$ 代表未知的 $y_{n+1}$。\n\n为了找到 $R(x)=0$ 的根，我们采用牛顿法，这是一个由下式定义的迭代过程：\n$$\nx^{(j+1)} = x^{(j)} - \\frac{R(x^{(j)})}{R'(x^{(j)})}\n$$\n其中 $x^{(j)}$ 是第 $j$ 次迭代时根的猜测值，而 $R'(x) = \\frac{dR}{dx}$ 是残差函数关于 $x$ 的导数。每个时间步的初始猜测值被指定为上一步的值，即 $x^{(0)} = y_n$。\n\n$R'(x)$ 的导数计算如下：\n$$\nR'(x) = \\frac{d}{dx} \\left( x - y_n - h\\,f(t_{n+1}, x) \\right) = 1 - h\\,\\frac{\\partial f}{\\partial y}(t_{n+1}, x)\n$$\n对于给定的函数 $f(t,y)$，其关于 $y$ 的偏导数为：\n$$\n\\frac{\\partial f}{\\partial y}(t,y) = \\frac{\\partial}{\\partial y} \\left( -k\\,(y - \\sin t) - b\\,y^3 \\right) = -k - 3\\,b\\,y^2\n$$\n将此代入 $R'(x)$ 的表达式中，我们得到：\n$$\nR'(x) = 1 - h\\,(-k - 3\\,b\\,x^2) = 1 + h\\,k + 3\\,h\\,b\\,x^2\n$$\n因此，求解 $y_{n+1}$ 的牛顿迭代是一个循环过程，它不断更新猜测值 $x^{(j)}$，直到满足停止准则。准则是残差的绝对值 $|R(x^{(j)})|$ 或牛顿步长的绝对值 $|x^{(j+1)} - x^{(j)}|$ 的绝对容差为 $10^{-12}$。如果在 $50$ 次迭代内未达到收敛，则终止该过程。\n\n每个测试用例的总体算法如下：\n1.  初始化参数 $(k, b, y_0, T, h)$ 并计算总步数 $N = T/h$。\n2.  设置初始解 $y = y_0$ 和初始时间 $t = 0$。\n3.  从 $n=0$ 循环到 $N-1$：\n    a.  确定下一个时间点 $t_{n+1} = (n+1)h$。\n    b.  将牛顿法求解 $y_{n+1}$ 的初始猜测值设为 $x^{(0)} = y_n$。\n    c.  使用牛顿法迭代最多 50 步，以找到解 $R(x)=0$ 的 $x$。在每次迭代 $j$ 中：\n        i.  计算残差 $R(x^{(j)})$。如果其绝对值小于 $10^{-12}$，则已达到收敛。该时间步的结果为 $x^{(j)}$。\n        ii. 计算导数 $R'(x^{(j)})$。\n        iii. 计算牛顿步长 $\\Delta x = -R(x^{(j)}) / R'(x^{(j)})$。\n        iv. 更新猜测值：$x^{(j+1)} = x^{(j)} + \\Delta x$。\n        v.  如果步长 $|\\Delta x|$ 的绝对值小于 $10^{-12}$，则已达到收敛。该时间步的结果为 $x^{(j+1)}$。\n    d.  更新下一个时间步的解：$y_{n+1} = x_{converged}$。\n4.  经过 $N$ 步后 $y$ 的最终值即为所求的 $y(T)$ 的近似值。对所有指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(k, b, y0, T, h):\n    \"\"\"\n    Solves the ODE dy/dt = -k*(y - sin(t)) - b*y^3 using Backward Euler\n    with Newton's method for the nonlinear solve.\n    \n    Args:\n        k (float): Stiffness parameter.\n        b (float): Nonlinearity parameter.\n        y0 (float): Initial condition y(0).\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The numerical solution y(T).\n    \"\"\"\n\n    # Define the ODE function f(t, y)\n    def f(t, y, k, b):\n        return -k * (y - np.sin(t)) - b * y**3\n\n    # Define the partial derivative of f with respect to y, df/dy\n    def df_dy(t, y, k, b):\n        return -k - 3 * b * y**2\n\n    # Ensure n_steps is integer\n    n_steps = int(round(T / h))\n    if not np.isclose(n_steps * h, T):\n        # This case is not expected based on the problem statement's test cases\n        # but is good practice.\n        raise ValueError(\"T must be an integer multiple of h.\")\n\n    y_current = y0\n\n    # Main time-stepping loop\n    for n in range(n_steps):\n        t_next = (n + 1) * h\n        y_guess = y_current\n        \n        # Newton's method to solve y_next = y_current + h * f(t_next, y_next)\n        # This is equivalent to finding the root of R(y_next) = 0 where\n        # R(y_next) = y_next - y_current - h * f(t_next, y_next)\n        for _ in range(50): # Maximum of 50 iterations\n            \n            # Calculate residual at the current guess\n            residual = y_guess - y_current - h * f(t_next, y_guess, k, b)\n\n            # Check for convergence on residual\n            if abs(residual)  1e-12:\n                break\n                \n            # Calculate Jacobian of the residual function\n            # R'(y) = 1 - h * df/dy\n            jac_residual = 1.0 - h * df_dy(t_next, y_guess, k, b)\n            \n            # Avoid division by zero, although not an issue for this problem's parameters\n            if jac_residual == 0:\n                break\n\n            # Calculate Newton step\n            step = -residual / jac_residual\n            \n            # Update the guess\n            y_guess += step\n            \n            # Check for convergence on the step size\n            if abs(step)  1e-12:\n                break\n        \n        y_current = y_guess\n\n    return y_current\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite: (k, b, y0, T, h)\n    test_cases = [\n        (1000, 10, 0, 0.1, 0.001),     # Case A\n        (1000, 0, 1, 0.1, 0.001),      # Case B\n        (1000, 5, 1, 0.05, 0.05),       # Case C\n        (0, 50, 1, 0.02, 0.005)        # Case D\n    ]\n\n    results = []\n    for params in test_cases:\n        y_final = run_simulation(*params)\n        results.append(y_final)\n\n    # Format output as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2442982"}, {"introduction": "既然我们已经掌握了如何实现隐式方法，一个自然的问题是：所有隐式方法都同样好用吗？这个练习旨在探索它们在定性行为上的细微但重要的差异。我们将比较同样是A稳定的梯形法则与后向欧拉法在一个高度刚性问题上的表现，你将发现即使是A稳定的方法也可能产生非物理的数值振荡，这引出了对稳健刚性求解器更严格的要求：L-稳定性。[@problem_id:3279333]", "problem": "考虑由常微分方程 $y'(t) = -k\\,(y(t) - s)$ 定义的标量初值问题，其中 $k > 0$，$s$ 为常数，初始条件为 $y(0) = y_0$。该模型是一个典型的线性弛豫模型，当 $k$ 相对于感兴趣的时间尺度较大时，该模型会变得刚性，因为精确解 $y(t)$ 在由 $1/k$ 决定的快速时间尺度上单调地趋近于平衡态 $s$。刚性系统的数值积分应保持其定性特征，例如单调弛豫，而不引入精确解中不存在的振荡。\n\n你的任务是：\n\n1. 从梯形法则的定义出发，该法则通过强制步长内右端项的积分平均值来将解从 $t_n$ 更新到 $t_{n+1}$。推导线性弛豫模型的梯形法则更新公式。设 $f(y) = -k\\,(y - s)$，并使用基本恒等式 $y_{n+1} = y_n + h\\,\\frac{f(y_n) + f(y_{n+1})}{2}$，其中 $h$ 是时间步长。展示如何精确求解这个关于 $y_{n+1}$ 的隐式线性方程，并确定在梯形法则下弛豫误差 $e_n = y_n - s$ 的离散演化。从基本原理出发，解释为什么精确解 $e(t) = (y(t) - s)$ 满足 $e(t) = e(0)\\,\\mathrm{e}^{-k t}$，因此当 $k > 0$ 且 $e(0) \\neq 0$ 时，严格单调趋向于 $0$。\n\n2. 从后向欧拉法的定义出发，该方法通过 $y_{n+1} = y_n + h\\,f(y_{n+1})$ 进行更新。推导同一模型的后向欧拉法更新公式，并表达出 $e_n = y_n - s$ 的离散演化。\n\n3. 利用你的推导，分析在 $h k$ 较大时梯形法则与后向欧拉法的定性行为：确定梯形法则在何种情况下会产生符号交替的 $e_n$（振荡），尽管精确解是单调的，并解释后向欧拉法如何避免这种行为。将其与大刚度下的极限稳定性概念联系起来，该性质定义为：对于具有负实部的 $\\lambda$，当 $\\lvert h \\lambda \\rvert \\to \\infty$ 时，线性检验方程的放大因子趋于 $0$，这表明对快模态有强阻尼作用。\n\n4. 实现一个程序，对模型 $y'(t) = -k\\,(y(t) - s)$（其中 $s = 1$，$y_0 = 0$），在具有 $N$ 个步长和时间步长 $h=T/N$ 的均匀网格上，使用梯形法则和后向欧拉法从 $t=0$ 积分到 $t=T$。对于每种方法，计算误差序列 $e_n = y_n - s$ 并报告：\n   - 误差序列是否出现任何符号变化（当某个 $n$ 满足 $e_n \\cdot e_{n+1}  0$ 时，计为一次符号变化），这表明相对于单调的精确解存在非物理振荡。\n   - 在时间 $T$ 时的最终误差大小 $e_N$。\n\n使用以下参数值测试套件来评估不同区域：\n- 测试用例 A（非振荡区域）：$k = 10$, $T = 1$, $N = 100$（因此 $h = 0.01$ 且 $h k = 0.1$）。\n- 测试用例 B（边界情况）：$k = 200$, $T = 1$, $N = 100$（因此 $h = 0.01$ 且 $h k = 2$）。\n- 测试用例 C（强刚性区域）：$k = 5000$, $T = 1$, $N = 100$（因此 $h = 0.01$ 且 $h k = 50$）。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是包含四个项目的列表，顺序为：$[$trapezoidal\\_oscillates, backwardEuler\\_oscillates, trapezoidal\\_final\\_error, backwardEuler\\_final\\_error$]$，其中前两项是布尔值，后两项是浮点数。将三个测试用例的结果聚合到一个外部列表中，打印的字符串中不含空格。例如，输出格式必须为 $[[\\dots],[\\dots],[\\dots]]$ 的形式，各项之间用逗号分隔。", "solution": "该问题是有效的，因为它提出了一个在刚性常微分方程数值方法研究中标准的、适定的、有科学依据且完整的任务。它基于典型的线性弛豫模型，要求对两种基本的隐式数值方法进行严格的推导和比较分析，并进行计算验证。\n\n该问题的核心是由常微分方程（ODE）给出的标量初值问题（IVP）：\n$$y'(t) = -k\\,(y(t) - s)$$\n其初始条件为 $y(0) = y_0$。参数 $k$ 和 $s$ 是常数，且 $k > 0$。该方程模拟了一个系统向稳态 $s$ 弛豫的过程。弛豫速率由 $k$ 决定。当 $k$ 很大时，系统弛豫得非常快，该常微分方程被称为“刚性”的。\n\n首先，我们分析精确解的行为。设偏离平衡态的误差为 $e(t) = y(t) - s$。对时间求导得到 $e'(t) = y'(t)$。将此代入常微分方程，得到一个更简单的误差方程：\n$$e'(t) = -k\\, e(t)$$\n这是一个标准的一阶线性齐次常微分方程。其解为 $e(t) = C e^{-kt}$，其中 $C$ 是某个常数。利用初始条件，我们发现 $e(0) = y(0) - s = y_0 - s$，所以 $C = e(0)$。因此，误差的精确演化为：\n$$e(t) = e(0)\\,\\mathrm{e}^{-k t} = (y_0 - s)\\,\\mathrm{e}^{-k t}$$\n由于 $k > 0$，项 $\\mathrm{e}^{-k t}$ 是一个严格为正且随 $t$ 单调递减的函数。因此，当 $t \\to \\infty$ 时，$e(t)$ 单调衰减至 $0$。对于所有 $t \\ge 0$，$e(t)$ 的符号是恒定的，且与初始误差 $e(0)$ 的符号相同。精确解从不表现出振荡。一个有效的数值方法理想情况下应能再现这种定性单调性。\n\n### 1. 梯形法则分析\n\n将解从时间 $t_n$ 更新到 $t_{n+1} = t_n + h$ 的梯形法则由下式给出：\n$$y_{n+1} = y_n + \\frac{h}{2} \\left[ f(y_n) + f(y_{n+1}) \\right]$$\n对于我们特定的右端项 $f(y) = -k(y-s)$，该式变为：\n$$y_{n+1} = y_n + \\frac{h}{2} \\left[ -k(y_n - s) - k(y_{n+1} - s) \\right]$$\n这是一个关于 $y_{n+1}$ 的隐式方程。我们可以通过整理各项来求解 $y_{n+1}$：\n$$y_{n+1} + \\frac{hk}{2} y_{n+1} = y_n - \\frac{hk}{2} y_n + \\frac{hk}{2} s + \\frac{hk}{2} s$$\n$$y_{n+1} \\left( 1 + \\frac{hk}{2} \\right) = y_n \\left( 1 - \\frac{hk}{2} \\right) + hk s$$\n解出 $y_{n+1}$ 得到显式更新公式：\n$$y_{n+1} = \\frac{1 - hk/2}{1 + hk/2} y_n + \\frac{hk}{1 + hk/2} s$$\n为了找到数值误差 $e_n = y_n - s$ 的演化，我们从两边减去 $s$：\n$$y_{n+1} - s = \\frac{1 - hk/2}{1 + hk/2} y_n + \\frac{hk}{1 + hk/2} s - s$$\n$$e_{n+1} = \\frac{1 - hk/2}{1 + hk/2} y_n + s \\left( \\frac{hk}{1 + hk/2} - 1 \\right)$$\n$$e_{n+1} = \\frac{1 - hk/2}{1 + hk/2} y_n + s \\left( \\frac{hk - (1 + hk/2)}{1 + hk/2} \\right) = \\frac{1 - hk/2}{1 + hk/2} y_n + s \\left( \\frac{hk/2 - 1}{1 + hk/2} \\right)$$\n$$e_{n+1} = \\frac{1 - hk/2}{1 + hk/2} (y_n - s)$$\n因此，在梯形法则下，离散误差的演化是一个几何级数：\n$$e_{n+1} = \\left( \\frac{1 - hk/2}{1 + hk/2} \\right) e_n$$\n其中项 $R_{trap}(hk) = \\frac{1 - hk/2}{1 + hk/2}$ 是放大因子。\n\n### 2. 后向欧拉法分析\n\n后向欧拉法由全隐式更新规则定义：\n$$y_{n+1} = y_n + h f(y_{n+1})$$\n代入 $f(y) = -k(y-s)$：\n$$y_{n+1} = y_n + h [-k(y_{n+1} - s)] = y_n - hk(y_{n+1} - s)$$\n同样，我们求解这个关于 $y_{n+1}$ 的线性方程：\n$$y_{n+1} + hk y_{n+1} = y_n + hk s$$\n$$y_{n+1} (1 + hk) = y_n + hk s$$\n$$y_{n+1} = \\frac{1}{1 + hk} y_n + \\frac{hk}{1 + hk} s$$\n为了找到误差递推关系，我们再次令 $e_n = y_n - s$ 并从更新规则中减去 $s$：\n$$y_{n+1} - s = \\frac{1}{1 + hk} y_n + \\frac{hk}{1 + hk} s - s$$\n$$e_{n+1} = \\frac{1}{1 + hk} y_n + s \\left( \\frac{hk - (1 + hk)}{1 + hk} \\right) = \\frac{1}{1 + hk} y_n - \\frac{s}{1 + hk}$$\n$$e_{n+1} = \\frac{1}{1 + hk} (y_n - s)$$\n这给出了后向欧拉法的离散误差演化：\n$$e_{n+1} = \\left( \\frac{1}{1 + hk} \\right) e_n$$\n其放大因子为 $R_{BE}(hk) = \\frac{1}{1 + hk}$。\n\n### 3. 定性行为与 L-稳定性\n\n我们现在基于它们的放大因子来比较这两种方法的行为，特别是在大步长 $h$ 或大刚性参数 $k$ 的情况下，即大的 $hk$ 值。\n\n**梯形法则：** 误差递推关系为 $e_{n+1} = R_{trap}(hk) e_n$。如果误差项 $e_n$ 从一步到下一步符号发生改变，就会出现非物理振荡，这当且仅当放大因子 $R_{trap}(hk)$ 为负时发生。\n由于 $h > 0$ 且 $k > 0$，分母 $1 + hk/2$ 总是正的。因此，放大因子的符号由其分子 $1 - hk/2$ 决定。\n$$R_{trap}(hk)  0 \\quad \\iff \\quad 1 - \\frac{hk}{2}  0 \\quad \\iff \\quad hk > 2$$\n因此，每当步长和刚性参数的乘积超过 $2$ 时，梯形法则就会产生伪振荡。该方法是 A-稳定的，意味着对于所有 $hk \\ge 0$，放大因子的模 $|R_{trap}(hk)| \\le 1$，所以误差大小不会增长。然而，它在大刚度极限下的稳定性很差。当 $hk \\to \\infty$ 时，\n$$\\lim_{hk \\to \\infty} R_{trap}(hk) = \\lim_{hk \\to \\infty} \\frac{1 - hk/2}{1 + hk/2} = -1$$\n这意味着对于非常刚性的分量，该方法会以几乎相同大小的振荡来响应，未能阻尼解的快速瞬态部分。这种未能阻尼高频分量的现象是 L-稳定性的缺失。\n\n**后向欧拉法：** 误差递推关系为 $e_{n+1} = R_{BE}(hk) e_n$。放大因子为 $R_{BE}(hk) = \\frac{1}{1 + hk}$。\n由于 $h > 0$ 且 $k > 0$，我们有 $hk > 0$。因此，分母 $1 + hk > 1$。这意味着：\n$$0  R_{BE}(hk)  1$$\n放大因子总是正的且小于 $1$。因此，$e_{n+1}$ 的符号总是与 $e_n$ 相同，且其大小总是减小的。对于任何 $h > 0$ 和 $k > 0$ 的选择，后向欧拉法都能正确地再现误差的单调衰减。它从不引入非物理振荡。\n\n此外，我们考察其极限稳定性。当 $hk \\to \\infty$ 时：\n$$\\lim_{hk \\to \\infty} R_{BE}(hk) = \\lim_{hk \\to \\infty} \\frac{1}{1 + hk} = 0$$\n这个性质被称为 L-稳定性。它表明对于非常刚性的分量（大 $k$），数值方法会引入强阻尼，有效地将解在一个步长内投影到慢流形（平衡态 $s$）上。这使得后向欧拉法特别适用于刚性问题，因为它能正确地耗散快速瞬态而不会产生振荡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the stiff relaxation problem using Trapezoidal and Backward Euler methods\n    and analyzes their qualitative behavior for different stiffness regimes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple (k, T, N).\n    test_cases = [\n        (10.0, 1.0, 100),   # Test case A: non-oscillatory regime (hk = 0.1)\n        (200.0, 1.0, 100),  # Test case B: boundary case (hk = 2.0)\n        (5000.0, 1.0, 100), # Test case C: strongly stiff regime (hk = 50.0)\n    ]\n\n    # Constants for the IVP model y' = -k(y - s)\n    s = 1.0\n    y_0 = 0.0\n\n    all_results = []\n\n    for k, T, N in test_cases:\n        h = T / N\n        \n        # Initialize arrays to store the solution trajectories\n        # Index 0 is for t=0, index N is for t=T\n        y_trap = np.zeros(N + 1)\n        y_be = np.zeros(N + 1)\n        \n        # Set initial conditions\n        y_trap[0] = y_0\n        y_be[0] = y_0\n        \n        # Pre-compute stability-related terms for efficiency\n        hk = h * k\n        \n        # Trapezoidal rule update coefficients\n        trap_factor_y = (1.0 - hk / 2.0) / (1.0 + hk / 2.0)\n        trap_factor_s = hk / (1.0 + hk / 2.0)\n\n        # Backward Euler update coefficients\n        be_factor_y = 1.0 / (1.0 + hk)\n        be_factor_s = hk / (1.0 + hk)\n\n        # Time-stepping loop\n        for n in range(N):\n            # Trapezoidal Rule update\n            y_trap[n+1] = trap_factor_y * y_trap[n] + trap_factor_s * s\n\n            # Backward Euler update\n            y_be[n+1] = be_factor_y * y_be[n] + be_factor_s * s\n\n        # Compute error sequences e_n = y_n - s\n        e_trap = y_trap - s\n        e_be = y_be - s\n\n        # Check for oscillations (sign change in error sequence)\n        # A sign change occurs if e_n * e_{n+1}  0.\n        # We check if this is true for any n in the sequence.\n        # np.any returns a numpy.bool_, which we cast to a standard bool.\n        trap_oscillates = bool(np.any(e_trap[:-1] * e_trap[1:]  0))\n        be_oscillates = bool(np.any(e_be[:-1] * e_be[1:]  0))\n\n        # Get the final error magnitude at t=T\n        final_error_trap = e_trap[-1]\n        final_error_be = e_be[-1]\n\n        # Store results for this test case\n        case_result = [trap_oscillates, be_oscillates, final_error_trap, final_error_be]\n        all_results.append(case_result)\n\n    # Format the final output string as specified\n    sub_results_str = []\n    for res in all_results:\n        # res is [bool, bool, float, float]\n        # Format booleans as lowercase 'true'/'false'\n        s = f\"[{str(res[0]).lower()},{str(res[1]).lower()},{res[2]},{res[3]}]\"\n        sub_results_str.append(s)\n    \n    final_output = f\"[{','.join(sub_results_str)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "3279333"}]}