{"hands_on_practices": [{"introduction": "自适应步长控制的核心在于根据每一步的估算误差来动态调整步长 $h$。这个练习将引导你进行一次基本但至关重要的计算，即如何基于当前步长的误差来确定理想的下一步步长，从而让你掌握控制所有自适应积分器行为的基本原则。通过解决这个问题 ([@problem_id:1659045])，你将亲身体验到步长调整算法的“心脏”。", "problem": "在计算科学领域，数值方法被用来近似求解常微分方程（ODEs）。现代求解器的一个关键方面是自适应步长控制，它通过调整积分步长 $h$ 来在保持所需精度的同时最小化计算成本。\n\n考虑一个 $p$ 阶的数值积分方法。单步产生的局部截断误差 $\\epsilon$ 已知与步长的 $(p+1)$ 次方成正比。这个关系可以表示为 $\\epsilon \\propto h^{p+1}$。\n\n一位工程师正在使用一个阶数为 $p=4$ 的方法来运行这样的求解器。该求解器被配置了一个用于局部误差的恒定目标容差 $tol$。在采用步长 $h_{old}$ 进行一步计算后，误差估计模块报告的局部误差为 $\\epsilon_{old} = \\frac{1}{2} tol$。为了准备下一个积分步骤，控制算法必须提出一个新的步长 $h_{new}$。新步长的选择应使得下一步的预测误差 $\\epsilon_{new}$ 恰好等于目标容差 $tol$。\n\n假设在这两个连续步骤之间，误差与步长之间的比例常数没有显著变化，请确定所提出的新步长 $h_{new}$ 关于旧步长 $h_{old}$ 的表达式。", "solution": "一个 $p$ 阶方法的局部截断误差满足 $\\epsilon = C h^{p+1}$，其中 $C$ 是连续步骤之间近似恒定的比例因子。对于旧步长，\n$$\n\\epsilon_{old} = C h_{old}^{p+1} = \\frac{1}{2} tol.\n$$\n对于所提出的新步长，我们要求\n$$\n\\epsilon_{new} = C h_{new}^{p+1} = tol.\n$$\n取两式之比，\n$$\n\\frac{\\epsilon_{new}}{\\epsilon_{old}} = \\frac{C h_{new}^{p+1}}{C h_{old}^{p+1}} = \\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = \\frac{tol}{\\frac{1}{2} tol} = 2.\n$$\n因此，\n$$\n\\left(\\frac{h_{new}}{h_{old}}\\right)^{p+1} = 2 \\quad \\Rightarrow \\quad \\frac{h_{new}}{h_{old}} = 2^{\\frac{1}{p+1}}.\n$$\n当 $p=4$ 时，我们得到\n$$\nh_{new} = 2^{\\frac{1}{5}} h_{old}.\n$$", "answer": "$$\\boxed{2^{\\frac{1}{5}} h_{old}}$$", "id": "1659045"}, {"introduction": "从基本公式到完整的实现是掌握任何算法的关键。这个实践将引导你为一个常用的嵌入式龙格-库塔方法推导误差估计器，并构建一个功能完备的自适应求解器。通过这项动手编程练习 ([@problem_id:3203842])，你将把误差估计、容差控制和步长更新等理论概念转化为实际可行的代码。", "problem": "要求您推导并实现一个基于阶数为 $(p, p-1)$ 的嵌入式龙格-库塔 (Runge-Kutta, RK) 对的自适应步长控制机制，并在标量初值问题 $y'(t)=-10\\,y(t)$ 上使用不同的相对和绝对容差来测试所得到的局部误差估计器。其目标是从第一性原理出发，展示局部误差估计器如何从嵌入式对中产生，以及它如何控制步长的接受和步长选择。\n\n从初值问题 $y'(t)=f(t,y(t))$（其中 $y(t_0)=y_0$）以及通过布彻表 (Butcher tableau) 和级 (stage) 计算定义的显式龙格-库塔方法开始。一个嵌入式对共享相同的级，但使用两组不同的权重提供两个不同阶数的不同输出公式。高阶输出的局部误差估计器是通过比较两个输出并分析截断误差的阶来获得的。\n\n您必须：\n\n- 从显式龙格-库塔方法的定义和精确解的泰勒展开出发，推导出嵌入式 RK 对 $(p, p-1)$ 的局部误差估计器，即两个嵌入式输出之差，展示其阶数并解释为什么它能控制高阶解的步长接受。\n- 将您的实现具体化为一个具体的嵌入式对，其中 $(p, p-1)=(3,2)$，即 Bogacki–Shampine $3(2)$ 方法，使用以下共享的级和权重：\n  - 级 (Stages)：\n    - $k_1=f(t,y)$，\n    - $k_2=f\\!\\left(t+\\frac{1}{2}h,\\;y+\\frac{1}{2}h\\,k_1\\right)$，\n    - $k_3=f\\!\\left(t+\\frac{3}{4}h,\\;y+\\frac{3}{4}h\\,k_2\\right)$，\n    - $k_4=f\\!\\left(t+h,\\;y_{\\text{high}}\\right)$，其中 $y_{\\text{high}}$ 定义如下。\n  - 高阶 ($p=3$) 输出：\n    $$y_{\\text{high}}=y+h\\left(\\frac{2}{9}k_1+\\frac{1}{3}k_2+\\frac{4}{9}k_3\\right)。$$\n  - 低阶 ($p-1=2$) 嵌入式输出：\n    $$y_{\\text{low}}=y+h\\left(\\frac{7}{24}k_1+\\frac{1}{4}k_2+\\frac{1}{3}k_3+\\frac{1}{8}k_4\\right)。$$\n- 使用标量局部误差估计 $e=y_{\\text{high}}-y_{\\text{low}}$ 以及带绝对和相对容差的标准标量缩放：\n  $$\\varepsilon=\\frac{|e|}{ATOL+RTOL\\cdot |y_{\\text{high}}|},$$\n  如果 $\\varepsilon\\leq 1$，则接受一个步长。\n- 对于接受或拒绝的步长，使用基于阶数的步长更新，其中 $p=3$，安全因子为 $0.9$，最小因子为 $0.2$，最大因子为 $5.0$：\n  $$h_{\\text{new}}=h\\cdot \\min\\!\\left(5.0,\\;\\max\\!\\left(0.2,\\;0.9\\cdot \\varepsilon^{-\\frac{1}{3}}\\right)\\right)。$$\n- 在区间 $[0,1]$ 上积分标量问题 $y'(t)=-10\\,y(t)$，$y(0)=y_0$，使用初始步长 $h_0=10^{-2}$ 和最小步长 $h_{\\min}=10^{-12}$。\n\n测试套件：\n实现上述内容并对以下五个测试用例运行求解器，以探究控制机制的不同方面：\n1. $RTOL=10^{-3}$，$ATOL=0$，$y_0=1$。\n2. $RTOL=0$，$ATOL=10^{-6}$，$y_0=1$。\n3. $RTOL=10^{-6}$，$ATOL=10^{-12}$，$y_0=1$。\n4. $RTOL=10^{-3}$，$ATOL=0$，$y_0=10^{-6}$。\n5. $RTOL=10^{-2}$，$ATOL=10^{-8}$，$y_0=1$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个条目是按上文所列顺序，相应测试用例达到 $t=1$ 所需的接受步长总数（一个整数），例如： `[n_1,n_2,n_3,n_4,n_5]`。\n不允许有其他输出。", "solution": "该问题要求推导并实现一个用于求解初值问题 (IVP) 的自适应步长控制算法。该方法基于一个嵌入式龙格-库塔 (RK) 对。我们将首先验证问题陈述，然后提供详细的推导和算法实现。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n*   **IVP**：$y'(t)=f(t,y(t))$，初始条件为 $y(t_0)=y_0$。\n*   **方法**：阶数为 $(p, p-1)$ 的嵌入式龙格-库塔对。\n*   **具体方法**：Bogacki–Shampine $3(2)$ 对，即 $p=3$。\n*   **级 (stages)**：\n    *   $k_1=f(t,y)$\n    *   $k_2=f(t+\\frac{1}{2}h, y+\\frac{1}{2}h k_1)$\n    *   $k_3=f(t+\\frac{3}{4}h, y+\\frac{3}{4}h k_2)$\n    *   $k_4=f(t+h, y_{\\text{high}})$\n*   **输出**：\n    *   高阶 ($p=3$)：$y_{\\text{high}}=y+h(\\frac{2}{9}k_1+\\frac{1}{3}k_2+\\frac{4}{9}k_3)$。\n    *   低阶 ($p-1=2$)：$y_{\\text{low}}=y+h(\\frac{7}{24}k_1+\\frac{1}{4}k_2+\\frac{1}{3}k_3+\\frac{1}{8}k_4)$。\n*   **误差估计**：\n    *   局部误差估计：$e=y_{\\text{high}}-y_{\\text{low}}$。\n    *   缩放误差：$\\varepsilon=\\frac{|e|}{ATOL+RTOL\\cdot |y_{\\text{high}}|}$。\n    *   接受准则：$\\varepsilon\\leq 1$。\n*   **步长控制**：\n    *   更新公式：$h_{\\text{new}}=h\\cdot \\min(5.0, \\max(0.2, 0.9\\cdot \\varepsilon^{-\\frac{1}{3}}))$。\n    *   安全因子：$0.9$。\n    *   最小/最大因子：$0.2$, $5.0$。\n*   **测试问题**：\n    *   常微分方程 (ODE)：$y'(t)=-10 y(t)$。\n    *   初始条件：$y(0)=y_0$。\n    *   积分区间：$[0,1]$。\n    *   初始步长：$h_0=10^{-2}$。\n    *   最小步长：$h_{\\min}=10^{-12}$。\n*   **测试套件**：五个具有不同 $RTOL$、$ATOL$ 和 $y_0$ 的测试用例。\n    1.  $RTOL=10^{-3}$，$ATOL=0$，$y_0=1$。\n    2.  $RTOL=0$，$ATOL=10^{-6}$，$y_0=1$。\n    3.  $RTOL=10^{-6}$，$ATOL=10^{-12}$，$y_0=1$。\n    4.  $RTOL=10^{-3}$，$ATOL=0$，$y_0=10^{-6}$。\n    5.  $RTOL=10^{-2}$，$ATOL=10^{-8}$，$y_0=1$。\n*   **要求输出**：每个测试用例接受的步长总数的整数数组。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n该问题具有科学依据，是数值分析中的一个标准课题。它是适定的，为确定性算法提供了所有必要的数据和参数。语言客观精确。指定的 Bogacki-Shampine 方法和自适应控制策略是标准的，并与现有文献一致。该问题不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n\n问题有效。将提供完整解答。\n\n### 推导与算法设计\n\n**1. 嵌入式龙格-库塔方法的局部误差估计**\n\n考虑一个初值问题 $y'(t) = f(t, y(t))$，其中 $y(t_n) = y_n$。设 $y(t_n+h)$ 是在时间 $t_n+h$ 时的精确解。一个 $p$ 阶的数值单步方法会产生一个近似值 $y_{n+1}$，使得其局部截断误差 (LTE)，即单步产生的误差，为 $p+1$ 阶。也就是说，\n$$ LTE = y(t_n+h) - y_{n+1} = O(h^{p+1}) $$\n一个嵌入式龙格-库塔对由两个方法组成，它们共享相同的函数求值（级），但具有不同的精度阶数。设这对方法的阶数为 $p$ 和 $p-1$。这为步长为 $h$ 的一步结束时的解提供了两个近似值：\n1.  一个来自 $p$ 阶方法的高阶近似值，$y_{\\text{high}}$。\n2.  一个来自 $p-1$ 阶方法的低阶近似值，$y_{\\text{low}}$。\n\n我们来分析它们与精确解 $y(t_n+h)$ 的关系，假设步长从精确值 $y_n = y(t_n)$ 开始。根据阶数的定义，我们可以将局部截断误差写成 $h$ 的泰勒级数：\n$$ y_{\\text{high}} = y(t_n+h) - C_{p+1}h^{p+1} - O(h^{p+2}) $$\n$$ y_{\\text{low}} = y(t_n+h) - C_{p}h^{p} - O(h^{p+1}) $$\n这里，$C_{p}$ 和 $C_{p+1}$ 是与主误差项相关的系数，并依赖于 $f$ 的导数。我们假设 $C_p \\neq 0$。\n\n局部误差估计器 $e$ 定义为这两个数值解之差：\n$$ e = y_{\\text{high}} - y_{\\text{low}} $$\n代入上面的表达式：\n$$ e = (y(t_n+h) - C_{p+1}h^{p+1} - \\dots) - (y(t_n+h) - C_{p}h^{p} - \\dots) $$\n$$ e = C_{p}h^{p} - C_{p+1}h^{p+1} - O(h^{p+2}) $$\n对于足够小的步长 $h$，项 $C_{p}h^{p}$ 占主导地位。因此，\n$$ e \\approx C_{p}h^{p} $$\n这表明差值 $e$ 提供了低阶方法 $y_{\\text{low}}$ 的局部截断误差主导项的估计。其量级为 $p$ 阶，即 $|e| = O(h^p)$。\n\n在一种称为“局部外推”的策略中，我们使用这个误差估计来控制步长，但使用更高精度的近似值 $y_{n+1} = y_{\\text{high}}$ 来推进解。估计值 $e$ 可作为 $y_{\\text{high}}$ 的真实但未知的局部误差的可计算代理。\n\n**2. 步长控制机制**\n\n自适应步长控制的目标是调整步长 $h$，使得每步的局部误差估计值与预设的容差相匹配。设一个步长的期望误差容差为 $S$。我们有一个对当前步长 $h$ 的误差估计，即 $|e| \\approx |C_p|h^p$。我们想找到一个新的步长 $h_{\\text{new}}$，使得相应的误差 $|e_{\\text{new}}|$ 满足 $|e_{\\text{new}}| \\approx S$。\n假设系数 $C_p$ 在步长之间没有显著变化，我们有：\n$$ |e_{\\text{new}}| \\approx |C_p|h_{\\text{new}}^p $$\n取期望误差与当前误差之比：\n$$ \\frac{|e_{\\text{new}}|}{|e|} \\approx \\frac{|C_p|h_{\\text{new}}^p}{|C_p|h^p} = \\left(\\frac{h_{\\text{new}}}{h}\\right)^p $$\n设置 $|e_{\\text{new}}| = S$，我们得到：\n$$ \\left(\\frac{h_{\\text{new}}}{h}\\right)^p \\approx \\frac{S}{|e|} \\implies h_{\\text{new}} \\approx h \\left(\\frac{S}{|e|}\\right)^{1/p} $$\n问题定义了一个混合绝对和相对容差方案。步长的容差根据解的量级进行缩放：\n$$ S = ATOL + RTOL \\cdot |y_{\\text{high}}| $$\n其中 $ATOL$ 和 $RTOL$ 分别是绝对和相对容差。使用 $|y_{\\text{high}}|$ 作为缩放因子是一个标准的选择。\n缩放误差 $\\varepsilon$ 定义为误差估计值与容差之比：\n$$ \\varepsilon = \\frac{|e|}{S} $$\n如果 $\\varepsilon \\leq 1$，则认为步长成功。将此代入步长更新公式，得到：\n$$ h_{\\text{new}} \\approx h \\left(\\frac{1}{\\varepsilon}\\right)^{1/p} = h \\cdot \\varepsilon^{-1/p} $$\n为获得可靠平稳的性能，这个理论公式通过安全因子和对步长变化量的限制器进行了修改。问题指定了公式：\n$$ h_{\\text{new}}=h\\cdot \\min(\\text{max\\_factor}, \\max(\\text{min\\_factor}, \\text{safety\\_factor} \\cdot \\varepsilon^{-1/p})) $$\n对于给定的 Bogacki-Shampine 3(2) 方法的参数（$p=3$，安全因子 $0.9$，最小因子 $0.2$，最大因子 $5.0$），公式变为：\n$$ h_{\\text{new}}=h\\cdot \\min(5.0, \\max(0.2, 0.9 \\cdot \\varepsilon^{-1/3})) $$\n如果步长被接受（$\\varepsilon \\leq 1$），则解推进到 $t_{n+1} = t_n+h$，其中 $y_{n+1} = y_{\\text{high}}$，并以由 $h_{\\text{new}}$ 决定的步长尝试下一步。如果步长被拒绝（$\\varepsilon > 1$），解不被推进，并从同一点 $(t_n, y_n)$ 以由 $h_{\\text{new}}$ 给出的更小的步长重试该步。\n\n**3. Bogacki–Shampine 3(2) 方法的实现**\n\n从 $t=0$ 到 $t=1$ 的积分总体算法如下：\n1.  初始化时间 $t=0$，解 $y=y_0$，以及步长 $h=h_0$。问题指定 $h_0=10^{-2}$。\n2.  Bogacki-Shampine 方法具有第一步与上一步的最后一步相同 (First Step Same As Last, FSAL) 的性质。在一个步长中计算的最后一个级，$k_4=f(t_n+h, y_{\\text{high}})$，与后续步长的第一个级，$k_1 = f(t_{n+1}, y_{n+1})$，是相同的，前提是该步长被接受并从 $t_{n+1}=t_n+h, y_{n+1}=y_{\\text{high}}$ 开始。我们可以利用这一点，每个接受的步长可以节省一次函数求值。我们首先计算一个初始的 $k_1 = f(t,y)$。\n3.  循环直到 $t \\geq 1$：\n    a. 检查当前步长 $h$ 是否会超过最终时间 $t=1$。如果是，则设置 $h = 1-t$。\n    b. 使用当前的 $(t, y, h)$ 以及上一个接受步长（或初始步长）的 $k_1$，计算级 $k_2, k_3$。\n    c. 计算高阶解 $y_{\\text{high}}$。\n    d. 使用 $y_{\\text{high}}$ 计算级 $k_4$。这是下一步可能的 $k_1$。\n    e. 计算低阶解 $y_{\\text{low}}$。\n    f. 计算误差估计 $e = y_{\\text{high}} - y_{\\text{low}}$。\n    g. 计算缩放误差 $\\varepsilon = |e| / (ATOL + RTOL \\cdot |y_{\\text{high}}|)$。\n    h. 如果 $\\varepsilon \\leq 1$ (步长接受)：\n        i. 增加已接受步长的计数器。\n        ii. 推进时间：$t \\leftarrow t+h$。\n        iii. 更新解：$y \\leftarrow y_{\\text{high}}$。\n        iv. 对于下一步，将其第一个级设置为 $k_1 \\leftarrow k_4$ (FSAL)。\n        v. 使用控制公式计算新的步长 $h_{\\text{new}}$，并设置 $h \\leftarrow \\max(h_{\\min}, h_{\\text{new}})$。\n    i. 如果 $\\varepsilon > 1$ (步长拒绝)：\n        i. 不更新 $t$、$y$ 或步长计数器。\n        ii. 用于重试的 $k_1$ 保持不变，因为它仅依赖于未改变的 $(t,y)$。\n        iii. 计算一个新的、更小的步长 $h_{\\text{new}}$ 并设置 $h \\leftarrow \\max(h_{\\min}, h_{\\text{new}})$。然后循环从同一点以这个更小的 $h$ 重试该步。\n4.  返回接受的步长总数。\n\n该算法为在各种容差设置下解决指定的测试问题提供了一种鲁棒的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef adaptive_bs32_solver(f, t0, y0, t_final, h0, h_min, rtol, atol):\n    \"\"\"\n    Implements an adaptive step-size Runge-Kutta solver using the\n    Bogacki-Shampine 3(2) embedded pair.\n\n    Args:\n        f (callable): The function defining the ODE, y' = f(t, y).\n        t0 (float): Initial time.\n        y0 (float): Initial value.\n        t_final (float): Final time for integration.\n        h0 (float): Initial step size.\n        h_min (float): Minimum allowed step size.\n        rtol (float): Relative tolerance.\n        atol (float): Absolute tolerance.\n\n    Returns:\n        int: The total number of accepted steps.\n    \"\"\"\n    t = t0\n    y = y0\n    h = h0\n    \n    accepted_steps = 0\n    \n    # Coefficients for Bogacki-Shampine 3(2) method\n    c2, a21 = 1/2, 1/2\n    c3, a31, a32 = 3/4, 0, 3/4\n    \n    b_high = np.array([2/9, 1/3, 4/9, 0])\n    b_low = np.array([7/24, 1/4, 1/3, 1/8])\n    \n    # Safety factors and step-size limits\n    safety_factor = 0.9\n    min_factor = 0.2\n    max_factor = 5.0\n    p = 3 # Order of the higher-order method\n\n    # FSAL: k1 for the first step is computed here.\n    k1 = f(t, y)\n\n    while t  t_final:\n        is_last_step = False\n        if t + h  t_final:\n            h = t_final - t\n            is_last_step = True\n\n        # Compute stages using k1 from the previous step (or initial)\n        k2 = f(t + c2 * h, y + h * (a21 * k1))\n        k3 = f(t + c3 * h, y + h * (a31 * k1 + a32 * k2))\n        \n        y_high = y + h * (b_high[0] * k1 + b_high[1] * k2 + b_high[2] * k3)\n        \n        # k4 uses y_high. This is the stage for the FSAL property.\n        k4 = f(t + h, y_high)\n        \n        y_low = y + h * (b_low[0] * k1 + b_low[1] * k2 + b_low[2] * k3 + b_low[3] * k4)\n        \n        # Error estimation\n        error = abs(y_high - y_low)\n        \n        # Scale for tolerance checking\n        scale = atol + rtol * abs(y_high)\n        \n        if scale  1e-30: # Avoid division by zero if tolerances and y are zero\n            epsilon = float('inf') if error  0 else 0.0\n        else:\n            epsilon = error / scale\n        \n        # Step size control\n        if epsilon = 1.0: # Step is accepted\n            accepted_steps += 1\n            t = t + h\n            y = y_high\n            \n            # Use k4 from this step as k1 for the next (FSAL)\n            k1 = k4\n            \n            if is_last_step:\n                break\n            \n            # Calculate optimal h for the next step\n            if epsilon == 0.0:\n                h_factor = max_factor\n            else:\n                h_factor = safety_factor * (epsilon**(-1.0 / p))\n            \n            h_new = h * min(max_factor, max(min_factor, h_factor))\n            h = max(h_min, h_new)\n\n        else: # Step is rejected\n            if is_last_step:\n                is_last_step = False # Allow for more steps with smaller h\n                \n            # Calculate a new, smaller h for the retry\n            h_factor = safety_factor * (epsilon**(-1.0 / p))\n            h_new = h * min(max_factor, max(min_factor, h_factor))\n            h = max(h_min, h_new)\n            \n            # Check for stagnation\n            if t + h == t:\n                # Could happen if h shrinks below machine epsilon relative to t\n                raise RuntimeError(\"Step size has stagnated.\")\n\n    return accepted_steps\n\ndef solve():\n    # Define the ODE: y'(t) = -10*y(t)\n    def f(t, y):\n        return -10.0 * y\n\n    # Problem parameters\n    t0 = 0.0\n    t_final = 1.0\n    h0 = 1e-2\n    h_min = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'rtol': 1e-3, 'atol': 0.0, 'y0': 1.0},\n        {'rtol': 0.0, 'atol': 1e-6, 'y0': 1.0},\n        {'rtol': 1e-6, 'atol': 1e-12, 'y0': 1.0},\n        {'rtol': 1e-3, 'atol': 0.0, 'y0': 1e-6},\n        {'rtol': 1e-2, 'atol': 1e-8, 'y0': 1.0}\n    ]\n\n    results = []\n    for case in test_cases:\n        num_steps = adaptive_bs32_solver(f, t0, case['y0'], t_final, h0, h_min, case['rtol'], case['atol'])\n        results.append(num_steps)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3203842"}, {"introduction": "在学会如何控制局部截断误差后，理解它对求解区间上累积的总误差（即全局误差）有何影响至关重要。这个练习 ([@problem_id:3203789]) 探讨了不同类型的动力学系统，旨在说明一个关键概念：即使局部误差得到完美控制，在不稳定系统中，全局误差仍可能失控增长。这是在实际应用中必须警惕的一个重要限制。", "problem": "一个常微分方程（ODE）初值问题（IVP）在一个有限区间上使用一种带有自适应步长控制的显式嵌入式龙格-库塔（RK）方法进行数值求解，该方法强制要求每步的局部截断误差估计不超过一个给定的容差 $tol$。假设该常微分方程的右端项是连续可微的，从而围绕一条轨迹的线性化是有效的，并且回想一下，对扰动的敏感性是由线性化动力学的稳定性所决定的，其中扰动可以根据线性化的符号和结构被放大或衰减。\n\n考虑以下初值问题，每一个都将使用上述自适应方法在其给定的时间区间上从给定的初始条件开始求解：\n\n- A. $y'(t) = 20\\,y(t)$，满足 $y(0) = 1$，区间为 $[0,10]$。\n- B. $y'(t) = -20\\,y(t)$，满足 $y(0) = 1$，区间为 $[0,10]$。\n- C. $y'(t) = -20\\,y(t) + \\sin(t)$，满足 $y(0) = 0$，区间为 $[0,10]$。\n- D. $\\mathbf{z}'(t) = A\\,\\mathbf{z}(t)$，其中 $A = \\begin{pmatrix}20  500 \\\\ 0  20\\end{pmatrix}$ 且 $\\mathbf{z}(0) = \\begin{pmatrix}1 \\\\ 0\\end{pmatrix}$，区间为 $[0,1]$。\n\n选择所有的初值问题，对于这些问题，尽管求解器在整个积分过程中强制执行标准的每步局部误差容差 $tol$，但由于系统对扰动的敏感性，其最终时刻的全局误差仍可能比 $tol$ 大几个数量级。你的论证应基于第一性原理：流的线性化、齐次部分的稳定性，以及由诱导动力学产生的随时间推移的扰动增长基本界限，而非任何依赖于特定方法的公式。", "solution": "这个问题的核心在于区分稳定和不稳定的动力系统。在数值积分中，自适应步长控制旨在将每一步的*局部截断误差*控制在容差 $tol$ 之内。然而，这些局部误差会累积成*全局误差*。全局误差的增长行为取决于系统自身的动力学特性，特别是围绕真实解轨迹的线性化系统的稳定性。\n\n- **对于稳定系统**：由数值方法引入的扰动（局部误差）会随着时间的推移被系统的动力学所抑制或衰减。因此，全局误差的量级通常与局部误差容差 $tol$ 保持在同一水平。\n- **对于不稳定系统**：扰动会被系统的动力学放大。即使每一步的局部误差很小，这些误差也会累积并被指数级（或更快）放大，导致在积分区间末端的全局误差远大于 $tol$。\n\n我们来分析每个选项：\n\n- **A. $y'(t) = 20y(t)$**: 这是一个不稳定的线性ODE。其解为 $y(t) = e^{20t}$。线性化动力学由特征值 $\\lambda = 20$ 决定。由于 $\\lambda > 0$，任何扰动都会被因子 $e^{20t}$ 放大。因此，全局误差会爆炸式增长，远超 $tol$。\n- **B. $y'(t) = -20y(t)$**: 这是一个稳定的线性ODE。其解为 $y(t) = e^{-20t}$。特征值 $\\lambda = -20  0$。扰动会被因子 $e^{-20t}$ 快速衰减。全局误差将得到良好控制。\n- **C. $y'(t) = -20y(t) + \\sin(t)$**: 这是一个稳定的、带外部驱动的线性ODE。其齐次部分与B相同，是稳定的。扰动同样会被衰减。全局误差将得到良好控制。\n- **D. $\\mathbf{z}'(t) = A\\mathbf{z}(t)$**: 这是一个二维线性系统。矩阵 $A$ 是一个上三角矩阵，其对角线元素即为特征值：$\\lambda_1 = \\lambda_2 = 20$。由于特征值均为正，该系统是强不稳定的。此外，由于这是一个有重根但几何重数不足的“缺陷”矩阵，其解的增长形式包含 $t e^{20t}$ 项，增长比单纯的指数增长更快。扰动会被急剧放大。因此，全局误差将远超 $tol$。\n\n综上所述，系统 A 和 D 是不稳定的，会导致全局误差的失控增长。", "answer": "$$\\boxed{AD}$$", "id": "3203789"}]}