{"hands_on_practices": [{"introduction": "在深入研究代码实现之前，让我们先通过一个思想实验来磨练直觉。位移逆幂法会收敛到距离所选位移量 $\\sigma$ 最近的特征值，但这一定符合我们的初步猜测吗？这个练习将挑战你仅用这一核心原理来预测算法的最终结果，通过计算你会发现，一个看似合理的位移量可能会导向一个意想不到的特征值 ([@problem_id:3273240])。", "problem": "考虑实对称矩阵\n$$\nA=\\begin{pmatrix}\n-9  0  0 \\\\[4pt]\n0  \\frac{137}{50}  \\frac{42}{25} \\\\[4pt]\n0  \\frac{42}{25}  \\frac{44}{25}\n\\end{pmatrix}.\n$$\n一位工程师希望找到谱中间的一个内部特征值，他观察到中间的对角线元素为 $1.76$，因此选择了一个合理的偏移量 $\\sigma=1.8$。从一个在所有特征向量方向上都有非零分量的通用初始向量开始，带偏移量的反幂法通过重复求解 $(A-\\sigma I)$ 并进行归一化来迭代。\n\n仅使用特征值和特征向量的基本定义和性质，确定在这种 $\\sigma$ 的选择下，对于几乎所有的初始向量，带偏移量的反幂法将收敛到的 $A$ 的单个特征值。请给出一个实数作为答案。在你的推理过程中不应执行数值迭代，并且最终答案不需要四舍五入。", "solution": "问题要求在给定偏移量 $\\sigma=1.8$ 的情况下，确定带偏移量的反幂法将收敛到的矩阵 $A$ 的特征值。\n\n带偏移量的反幂法是一种用于寻找矩阵 $A$ 的特征值-特征向量对 $(\\lambda, v)$ 的迭代算法。其迭代公式为 $x_{k+1} = (A - \\sigma I)^{-1} x_k$，其中 $\\sigma$ 是一个选定的偏移量。这等价于对矩阵 $M = (A - \\sigma I)^{-1}$ 应用幂法。幂法收敛到与 $M$ 的模最大的特征值相对应的特征向量。\n\n设 $A$ 的特征值为 $\\lambda_i$。那么 $M = (A - \\sigma I)^{-1}$ 的特征值为 $\\mu_i = \\frac{1}{\\lambda_i - \\sigma}$。该算法将收敛到与满足 $|\\mu_j| = \\max_i |\\mu_i|$ 的特征值 $\\mu_j$ 相关联的特征向量。这个条件等价于找到 $A$ 的一个特征值 $\\lambda_j$，它在复平面上到偏移量 $\\sigma$ 的距离最小，即 $|\\lambda_j - \\sigma| = \\min_i |\\lambda_i - \\sigma|$。\n\n对于一个通用初始向量（即在所有特征向量方向上都有非零分量的向量），该方法收敛到离偏移量 $\\sigma$ 最近的 $A$ 的特征值。因此，任务简化为：\n1. 找到矩阵 $A$ 的所有特征值。\n2. 对于每个特征值 $\\lambda_i$ 和给定的偏移量 $\\sigma=1.8$，计算距离 $|\\lambda_i - \\sigma|$。\n3. 确定使该距离最小的特征值 $\\lambda_j$。\n\n首先，我们求矩阵 $A$ 的特征值：\n$$\nA=\\begin{pmatrix}\n-9   0  0\\\\\n0   \\tfrac{137}{50}   \\tfrac{42}{25}\\\\\n0   \\tfrac{42}{25}   \\tfrac{44}{25}\n\\end{pmatrix}\n$$\n矩阵 $A$ 是分块对角矩阵。它的特征值是其对角块的特征值。第一个块是 $1 \\times 1$ 矩阵 $(-9)$，所以我们立即确定一个特征值为 $\\lambda_1 = -9$。\n\n剩下的两个特征值是 $2 \\times 2$ 子矩阵的特征值：\n$$\nB = \\begin{pmatrix}\n\\tfrac{137}{50}   \\tfrac{42}{25}\\\\\n\\tfrac{42}{25}   \\tfrac{44}{25}\n\\end{pmatrix}\n$$\n为了简化计算，我们可以通过将矩阵重写为公分母形式来提出因子 $\\frac{1}{50}$：\n$$\nB = \\begin{pmatrix}\n\\tfrac{137}{50}   \\tfrac{84}{50}\\\\\n\\tfrac{84}{50}   \\tfrac{88}{50}\n\\end{pmatrix} = \\frac{1}{50} \\begin{pmatrix}\n137   84\\\\\n84   88\n\\end{pmatrix}\n$$\n设矩阵为 $B' = \\begin{pmatrix} 137   84 \\\\ 84   88 \\end{pmatrix}$。如果 $\\mu$ 是 $B'$ 的一个特征值，那么 $\\lambda = \\frac{\\mu}{50}$ 就是 $B$ 的一个特征值。$B'$ 的特征值是其特征方程 $\\det(B' - \\mu I) = 0$ 的根，即 $\\mu^2 - \\text{tr}(B')\\mu + \\det(B') = 0$。\n\n$B'$ 的迹是：\n$$\n\\text{tr}(B') = 137 + 88 = 225\n$$\n$B'$ 的行列式是：\n$$\n\\det(B') = (137)(88) - (84)(84) = 12056 - 7056 = 5000\n$$\n关于 $\\mu$ 的特征方程是：\n$$\n\\mu^2 - 225\\mu + 5000 = 0\n$$\n我们解这个关于 $\\mu$ 的二次方程：\n$$\n\\mu = \\frac{225 \\pm \\sqrt{(-225)^2 - 4(1)(5000)}}{2} = \\frac{225 \\pm \\sqrt{50625 - 20000}}{2} = \\frac{225 \\pm \\sqrt{30625}}{2}\n$$\n平方根是 $\\sqrt{30625} = 175$。因此，$B'$ 的特征值是：\n$$\n\\mu_2 = \\frac{225 + 175}{2} = \\frac{400}{2} = 200\n$$\n$$\n\\mu_3 = \\frac{225 - 175}{2} = \\frac{50}{2} = 25\n$$\n子矩阵 $B$ 的特征值则为：\n$$\n\\lambda_2 = \\frac{\\mu_2}{50} = \\frac{200}{50} = 4\n$$\n$$\n\\lambda_3 = \\frac{\\mu_3}{50} = \\frac{25}{50} = \\frac{1}{2} = 0.5\n$$\n所以，矩阵 $A$ 的特征值集合是 $\\{\\lambda_1, \\lambda_2, \\lambda_3\\} = \\{-9, 4, 0.5\\}$。\n\n接下来，我们计算每个特征值到偏移量 $\\sigma = 1.8$ 的距离。\n1. 对于 $\\lambda_1 = -9$：\n   $$\n   |\\lambda_1 - \\sigma| = |-9 - 1.8| = |-10.8| = 10.8\n   $$\n2. 对于 $\\lambda_2 = 4$：\n   $$\n   |\\lambda_2 - \\sigma| = |4 - 1.8| = |2.2| = 2.2\n   $$\n3. 对于 $\\lambda_3 = 0.5$：\n   $$\n   |\\lambda_3 - \\sigma| = |0.5 - 1.8| = |-1.3| = 1.3\n   $$\n比较这些距离，我们发现 $1.3  2.2  10.8$。最小的距离是 $1.3$，对应于特征值 $\\lambda_3 = 0.5$。\n\n因此，对于几乎所有的初始向量，使用偏移量 $\\sigma = 1.8$ 的带偏移量的反幂法将收敛到特征值 $\\lambda_3 = 0.5$。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3273240"}, {"introduction": "最理想的位移量 $\\sigma$ 就是特征值本身，但这完美的设定却带来了一个理论上的悖论：矩阵 $(A - \\sigma I)$ 会变得奇异，其逆矩阵无从谈起。这个问题从理论层面深入剖析了当位移量精确命中一个特征值时所产生的后果，探讨了线性系统的可解性与解的唯一性 ([@problem_id:3273177])。理解这种奇异性是设计稳健数值算法的关键一步。", "problem": "考虑一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，其具有相异的特征值 $\\lambda_{1}  \\lambda_{2}  \\cdots  \\lambda_{n}$ 和一组标准正交的特征向量基 $\\{v_{1}, v_{2}, \\dots, v_{n}\\}$，使得 $A v_{i} = \\lambda_{i} v_{i}$ 且 $A = V \\Lambda V^{\\top}$，其中 $V = [v_{1}\\ \\cdots\\ v_{n}]$ 且 $\\Lambda = \\mathrm{diag}(\\lambda_{1}, \\dots, \\lambda_{n})$。带位移 $\\sigma \\in \\mathbb{R}$ 的位移反幂法在每次迭代 $k$ 中，尝试求解线性系统 $(A - \\sigma I) y_{k} = x_{k}$ 以得到 $y_{k}$，然后归一化 $x_{k+1} = y_{k} / \\|y_{k}\\|_{2}$。假设进行精确计算。\n\n分析当位移恰好等于其中一个特征值时，即对于某个固定的 $j \\in \\{1, \\dots, n\\}$ 有 $\\sigma = \\lambda_{j}$ 时，该方法的行为。基于基本原理，包括特征值和特征向量的定义、实对称矩阵的性质以及奇异矩阵的值域和零空间的结构，判断下列哪些陈述是正确的。你可以假设，只要 $(A - \\lambda_{j} I) y = x$ 可解，就存在无穷多个解，因为 $(A - \\lambda_{j} I)$ 是奇异的。\n\nA. 线性系统 $(A - \\lambda_{j} I) y = x$ 有解当且仅当 $x$ 与 $v_{j}$ 正交。\n\nB. 如果系统 $(A - \\lambda_{j} I) y = x$ 可解，则解 $y$ 是唯一的。\n\nC. 如果初始向量 $x_{0}$ 沿 $v_{j}$ 的分量非零，则第一次求解 $(A - \\lambda_{j} I) y_{0} = x_{0}$ 无解，因此位移反幂迭代无法进行。\n\nD. 如果 $x_{0}$ 与 $v_{j}$ 正交，并且在每一步都选择一个也与 $v_{j}$ 正交的解 $y_{k}$，则迭代简化为在与 $v_{j}$ 正交的不变子空间上的反幂迭代，并收敛到与 $\\{\\lambda_{i} : i \\neq j\\}$ 中最接近 $\\lambda_{j}$ 的特征值相关联的特征向量。\n\nE. 对于任何不与 $v_{j}$ 正交的初始向量 $x_{0}$，该方法在一步内收敛到 $v_{j}$。\n\n选择所有正确的陈述。", "solution": "该问题要求分析当位移 $\\sigma$ 被选为实对称矩阵 $A$ 的一个特征值时，位移反幂法的行为。设矩阵为 $A \\in \\mathbb{R}^{n \\times n}$，其具有相异的特征值 $\\lambda_1  \\lambda_2  \\dots  \\lambda_n$ 和一组对应的标准正交特征向量基 $\\{v_1, v_2, \\dots, v_n\\}$。迭代步骤包括求解 $(A - \\sigma I) y_k = x_k$ 并设置 $x_{k+1} = y_k / \\|y_k\\|_2$。我们给定了一个特殊情况，即对于某个 $j \\in \\{1, \\dots, n\\}$，有 $\\sigma = \\lambda_j$。\n\n我们将线性系统的矩阵定义为 $B = A - \\lambda_j I$。我们首先建立该矩阵 $B$ 的基本性质。\n1.  **对称性**：由于 $A$ 是一个实对称矩阵，而 $\\lambda_j I$ 也是一个对称矩阵，它们的差 $B = A - \\lambda_j I$ 也是一个实对称矩阵。\n2.  **特征结构**：$B$ 的特征向量与 $A$ 的特征向量相同，即 $\\{v_i\\}_{i=1}^n$。$B$ 的特征值记为 $\\mu_i$，由 $\\mu_i = \\lambda_i - \\lambda_j$ 给出。\n3.  **奇异性**：由于 $j \\in \\{1, \\dots, n\\}$，$B$ 的一个特征值是 $\\mu_j = \\lambda_j - \\lambda_j = 0$。具有零特征值的矩阵是奇异的。\n4.  **零空间**：$B$ 的零空间，记为 $\\mathrm{null}(B)$，是满足 $Bz=0$ 的向量 $z$ 的集合。这等价于 $(A - \\lambda_j I)z = 0$，或 $Az = \\lambda_j z$。根据定义，这是对应于特征值 $\\lambda_j$ 的特征空间。由于 $A$ 的特征值是相异的，这个特征空间是一维的，由特征向量 $v_j$ 张成。所以，$\\mathrm{null}(B) = \\mathrm{span}\\{v_j\\}$。\n5.  **值域**：对于一个对称矩阵 $B$，其值域（或像/列空间）是其零空间的正交补。因此，$\\mathrm{range}(B) = (\\mathrm{null}(B))^{\\perp}$。利用第4点的结果，我们有 $\\mathrm{range}(B) = (\\mathrm{span}\\{v_j\\})^{\\perp}$。这意味着一个向量 $x$ 在 $B$ 的值域中，当且仅当 $x$ 与 $v_j$ 正交，即 $v_j^\\top x = 0$。\n\n建立了这些性质后，我们可以分析线性系统 $(A - \\lambda_j I) y = x$。该系统存在解，当且仅当右侧向量 $x$ 属于矩阵 $A - \\lambda_j I$ 的值域。根据我们的发现，这当且仅当 $x$ 与 $v_j$ 正交时成立。\n\n现在我们来评估每个陈述。\n\n**A. 线性系统 $(A - \\lambda_{j} I) y = x$ 有解当且仅当 $x$ 与 $v_{j}$ 正交。**\n这个陈述是 Fredholm 择一定理在对称算子 $A - \\lambda_j I$ 上的直接应用。如上文第5点所述，系统有解当且仅当 $x \\in \\mathrm{range}(A - \\lambda_j I)$。对于一个对称矩阵，值域是零空间的正交补。$A - \\lambda_j I$ 的零空间是 $\\mathrm{span}\\{v_j\\}$。因此，解存在当且仅当 $x$ 在 $\\mathrm{span}\\{v_j\\}$ 的正交补中，这意味着 $x$ 必须与 $v_j$ 正交。\n该陈述是**正确的**。\n\n**B. 如果系统 $(A - \\lambda_{j} I) y = x$ 可解，则解 $y$ 是唯一的。**\n矩阵 $A - \\lambda_j I$ 是奇异的，因为它有一个零特征值。一个带有奇异矩阵的线性系统，如果可解，则有无穷多个解。具体来说，如果 $y_p$ 是一个特解，那么通解是 $y = y_p + z$，其中 $z$ 是 $\\mathrm{null}(A - \\lambda_j I)$ 中的任意向量。由于 $\\mathrm{null}(A - \\lambda_j I) = \\mathrm{span}\\{v_j\\}$，通解是 $y = y_p + c v_j$，其中 $c \\in \\mathbb{R}$ 是任意标量。因为 $v_j$ 是一个非零向量，所以解不是唯一的。\n该陈述是**不正确的**。\n\n**C. 如果初始向量 $x_{0}$ 沿 $v_{j}$ 的分量非零，则第一次求解 $(A - \\lambda_{j} I) y_{0} = x_{0}$ 无解，因此位移反幂迭代无法进行。**\n向量 $x_0$ 可以在标准正交的特征向量基中唯一表示为 $x_0 = \\sum_{i=1}^n c_i v_i$，其中系数 $c_i = v_i^\\top x_0$。$x_0$ 沿 $v_j$ 的分量是 $c_j v_j$。该分量非零的条件意味着 $c_j \\neq 0$。这等价于说 $v_j^\\top x_0 \\neq 0$，即 $x_0$ 不与 $v_j$ 正交。\n根据对陈述 A 的分析，系统 $(A - \\lambda_j I) y_0 = x_0$ 有解当且仅当 $x_0$ 与 $v_j$ 正交。由于 $x_0$ 不与 $v_j$ 正交，它不在 $(A - \\lambda_j I)$ 的值域中，因此系统无解。迭代的第一步需要求解这个系统，这是不可能的。因此，迭代无法进行。\n该陈述是**正确的**。\n\n**D. 如果 $x_{0}$ 与 $v_{j}$ 正交，并且在每一步都选择一个也与 $v_{j}$ 正交的解 $y_{k}$，则迭代简化为在与 $v_{j}$ 正交的不变子空间上的反幂迭代，并收敛到与 $\\{\\lambda_{i} : i \\neq j\\}$ 中最接近 $\\lambda_{j}$ 的特征值相关联的特征向量。**\n令 $S = (\\mathrm{span}\\{v_j\\})^\\perp = \\mathrm{span}\\{v_i : i \\neq j\\}$。子空间 $S$ 在 $A$ 下是不变的。\n1.  **初始步骤**：我们从 $x_0 \\in S$ 开始。由于 $x_0 \\perp v_j$，系统 $(A - \\lambda_j I)y_0 = x_0$ 是可解的。\n2.  **解的选择**：通解是 $y_0 = y_p + c v_j$。我们被告知要选择一个同样在 $S$ 中（与 $v_j$ 正交）的解。这需要设置 $c=0$ 并找到一个特解 $y_p \\in S$。设 $x_k = \\sum_{i \\neq j} c_i^{(k)} v_i$。我们寻求一个解 $y_k = \\sum_{i \\neq j} d_i^{(k)} v_i$。应用算子，$(A - \\lambda_j I)y_k = \\sum_{i \\neq j} d_i^{(k)}(\\lambda_i - \\lambda_j)v_i$。将其与 $x_k$ 相等，得到对于所有 $i \\neq j$，有 $d_i^{(k)} = c_i^{(k)}/(\\lambda_i - \\lambda_j)$。由于所有 $\\lambda_i$ 都是相异的，对于 $i \\neq j$，有 $\\lambda_i - \\lambda_j \\neq 0$，因此这给出了一个唯一的解 $y_k \\in S$。\n3.  **迭代**：这个过程是良定义的。如果 $x_k \\in S$，我们会找到一个唯一的 $y_k \\in S$。然后 $x_{k+1} = y_k / \\|y_k\\|_2$ 也将在 $S$ 中。迭代被限制在子空间 $S$ 内。\n4.  **收敛性**：在子空间 $S$ 上，算子 $A - \\lambda_j I$ 是可逆的。迭代等价于 $y_k = (A_S - \\lambda_j I_S)^{-1} x_k$，其中 $A_S$ 和 $I_S$ 是 $A$ 和 $I$ 在 $S$ 上的限制。这正是对算子 $A_S$ 使用位移 $\\lambda_j$ 的位移反幂法。$A_S$ 的特征值是 $\\{\\lambda_i : i \\neq j\\}$。标准的反幂迭代理论指出，该方法收敛到与最接近位移的 $A_S$ 特征值相对应的特征向量。在这种情况下，它将收敛到特征向量 $v_m$，其中 $\\lambda_m$ 是集合 $\\{\\lambda_i : i \\neq j\\}$ 中使距离 $|\\lambda_m - \\lambda_j|$ 最小化的特征值。\n该陈述是**正确的**。\n\n**E. 对于任何不与 $v_{j}$ 正交的初始向量 $x_{0}$，该方法在一步内收敛到 $v_{j}$。**\n如在陈述 C 的分析中所确立的，如果初始向量 $x_0$ 不与 $v_j$ 正交，线性系统 $(A-\\lambda_j I)y_0=x_0$ 无解。该算法无法执行，甚至一步都无法执行。因此，它不能收敛到任何东西。该陈述的前提是该方法可以进行，这是错误的。\n该陈述是**不正确的**。", "answer": "$$\\boxed{ACD}$$", "id": "3273177"}, {"introduction": "理论与实践在此交汇，我们将把前一个练习中探讨的“奇异性困境”从一个理论问题转化为一个实用特性。在这个编码练习中，你将实现一个数值稳定的位移逆幂法版本，用于验证一个给定的值是否确实是矩阵的特征值 ([@problem_id:3273273])。这要求你通过正则化等技巧，直接处理当位移量就是特征值时系统奇异的情况，从而构建一个真正可靠的计算工具。", "problem": "你的任务是验证一个全谱求解器声称的单个特征值是否确实是给定实矩阵的一个特征值。验证方法是使用带位移的逆幂法，其中位移等于该声称值。其理论基础如下：根据定义，一个标量 $\\lambda$ 是方阵 $A \\in \\mathbb{R}^{n \\times n}$ 的特征值，当且仅当存在一个非零向量 $x \\in \\mathbb{R}^{n}$ 使得 $A x = \\lambda x$。验证将基于构建一个迭代过程，当位移等于真实特征值时，该过程会产生一个向量，其残差在指定容差范围内满足 $A x - \\lambda x \\approx 0$。如果位移等于真实特征值，则算子 $A - \\lambda I$ 是奇异的，因此必须使用一个数值上稳健的方案来定义和求解出现的线性系统。\n\n设计并实现一个程序，使用位移为 $\\sigma = \\lambda_{\\text{test}}$ 的带位移逆幂法来验证几个矩阵的 $\\lambda_{\\text{test}}$。你的程序必须遵循以下规范：\n\n- 对于每个测试用例，从一个确定的初始向量 $x_{0}$ 开始，该向量通过使用固定的伪随机数生成器种子构建，并将结果向量归一化为单位 $2$-范数。\n- 在迭代索引 $k \\ge 1$ 时，求解形如 $(A - \\sigma I) y_{k} = x_{k-1}$ 的线性系统以得到 $y_{k}$，然后设置 $x_{k} = y_{k} / \\lVert y_{k} \\rVert_{2}$。当 $(A - \\sigma I)$ 是奇异的或数值不稳定的，你必须仍然通过使用以下任一可接受的机制以稳定的方式定义 $y_{k}$：(i) Tikhonov 型正则化，即求解 $\\big((A - \\sigma I) + \\mu I\\big) y_{k} = x_{k-1}$，其中 $\\mu  0$ 是一个小数，或 (ii) 通过数值稳定方法（如奇异值分解 (SVD)）计算的最小二乘解。你的实现可以在这些机制之间自适应地选择，以确保迭代的进行。\n- 在每次迭代中，计算瑞利商 $\\rho_{k} = \\dfrac{x_{k}^{\\top} A x_{k}}{x_{k}^{\\top} x_{k}}$ 和残差 $r_{\\sigma,k} = \\lVert A x_{k} - \\sigma x_{k} \\rVert_{2}$ 及 $r_{\\rho,k} = \\lVert A x_{k} - \\rho_{k} x_{k} \\rVert_{2}$。\n- 当 $r_{\\sigma,k} \\le \\tau_{\\text{res}}$ 或达到最大迭代次数 $k_{\\max}$ 时终止。此外，报告最终的 $r_{\\sigma,k}$ 和最后的瑞利商 $\\rho_{k}$。\n\n在所有测试中使用以下常量：$\\tau_{\\text{res}} = 10^{-8}$，用于可选交叉检查的瑞利商绝对接近容差 $\\tau_{\\text{rq}} = 10^{-8}$，以及 $k_{\\max} = 30$。当需要正则化时，你可以选择一个基线值 $\\mu = 10^{-8} \\max(1,\\lVert A \\rVert_{F})$，并在必要时进行调整以成功求解。初始向量必须通过从具有固定种子的标准正态分布中抽取元素来创建，并归一化为单位 $2$-范数。\n\n验证规则：当且仅当终止时的最终 $r_{\\sigma,k}$ 小于或等于 $\\tau_{\\text{res}}$ 时，才将 $\\lambda_{\\text{test}}$ 声明为已验证。你可以选择性地要求 $\\lvert \\rho_{k} - \\sigma \\rvert \\le \\tau_{\\text{rq}}$ 作为第二重检查；如果使用此第二重检查，则两个条件必须同时满足。\n\n测试套件。对于每个测试用例，你将获得 $(A, \\lambda_{\\text{test}})$：\n\n- 测试 $1$：$A_{1} = \\begin{bmatrix} 2  1  0 \\\\ 1  2  1 \\\\ 0  1  2 \\end{bmatrix}$，$\\lambda_{\\text{test},1} = 2$。\n- 测试 $2$：$A_{2} = \\begin{bmatrix} 1  2  3 \\\\ 0  4  5 \\\\ 0  0  6 \\end{bmatrix}$，$\\lambda_{\\text{test},2} = 4$。\n- 测试 $3$：$A_{3} = A_{1}$ (来自测试 $1$)，$\\lambda_{\\text{test},3} = 2.5$。\n- 测试 $4$：$A_{4} = \\operatorname{diag}(1.0, 1.001, 10.0)$，$\\lambda_{\\text{test},4} = 1.001$。\n\n对于每个测试用例，你的程序必须运行所述的验证过程，并为每个测试用例生成一个结果，包含：\n- 一个布尔值，说明 $\\lambda_{\\text{test}}$ 是否根据上述规则被验证。\n- 最终的瑞利商 $\\rho_{k}$，作为一个浮点数。\n- 最终的残差 $r_{\\sigma,k}$，作为一个浮点数。\n- 执行的迭代次数，作为一个整数。\n\n最终输出格式。你的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个单独的测试结果以 $[\\text{布尔值}, \\rho_{k}, r_{\\sigma,k}, k]$ 的列表形式出现。例如，一个包含两个假设结果的输出看起来像 $[[\\text{True},1.0,1\\mathrm{e}{-9},7],[\\text{False},0.0,1.23,30]]$。此问题中没有物理单位，也没有角度；所有数值都是标准浮点格式的实数。程序不得读取任何输入，并且必须确定性地执行。", "solution": "用户想要解决一个问题。用户希望我扮演一位严谨苛刻的 STEM 领域教授。我需要首先验证问题陈述。\n\n## 问题验证\n\n### 步骤 1：提取已知条件\n- **任务**：使用位移为 $\\sigma = \\lambda_{\\text{test}}$ 的带位移逆幂法，验证一个声称的特征值 $\\lambda_{\\text{test}}$ 是否为实矩阵 $A$ 的特征值。\n- **初始向量**：一个确定的向量 $x_0$，由一个带有固定种子的标准正态分布生成，并归一化为单位 $2$-范数。\n- **迭代 ($k \\ge 1$)**：\n    1. 求解 $(A - \\sigma I) y_k = x_{k-1}$ 得到 $y_k$。\n    2. 归一化：$x_k = y_k / \\lVert y_k \\rVert_2$。\n- **奇异性处理**：对于奇异或不稳定的 $(A - \\sigma I)$，使用以下方法之一：\n    1. Tikhonov 正则化：求解 $\\big((A - \\sigma I) + \\mu I\\big) y_{k} = x_{k-1}$，其中 $\\mu  0$ 是一个小数。建议的基线值：$\\mu = 10^{-8} \\max(1, \\lVert A \\rVert_F)$。\n    2. 通过稳定方法（如 SVD）计算的最小二乘解。\n- **度量指标**：在每次迭代中，计算：\n    - 瑞利商：$\\rho_k = \\frac{x_k^\\top A x_k}{x_k^\\top x_k}$。\n    - 残差：$r_{\\sigma,k} = \\lVert A x_k - \\sigma x_k \\rVert_2$ 和 $r_{\\rho,k} = \\lVert A x_k - \\rho_k x_k \\rVert_2$。\n- **终止条件**：当 $r_{\\sigma,k} \\le \\tau_{\\text{res}}$ 或 $k = k_{\\max}$ 时停止。\n- **常量**：\n    - $\\tau_{\\text{res}} = 10^{-8}$\n    - $\\tau_{\\text{rq}} = 10^{-8}$ (用于可选检查)\n    - $k_{\\max} = 30$\n- **验证规则**：当且仅当最终的 $r_{\\sigma,k} \\le \\tau_{\\text{res}}$ 时，$\\lambda_{\\text{test}}$ 被验证。一个关于 $\\lvert \\rho_k - \\sigma \\rvert$ 的可选次要检查被提及但非必需。\n- **测试套件**：\n    - 测试 1: $A_1 = \\begin{bmatrix} 2  1  0 \\\\ 1  2  1 \\\\ 0  1  2 \\end{bmatrix}$, $\\lambda_{\\text{test},1} = 2$。\n    - 测试 2: $A_2 = \\begin{bmatrix} 1  2  3 \\\\ 0  4  5 \\\\ 0  0  6 \\end{bmatrix}$, $\\lambda_{\\text{test},2} = 4$。\n    - 测试 3: $A_3 = A_1$, $\\lambda_{\\text{test},3} = 2.5$。\n    - 测试 4: $A_4 = \\operatorname{diag}(1.0, 1.001, 10.0)$, $\\lambda_{\\text{test},4} = 1.001$。\n- **输出**：对每个测试，输出一个列表 `[verified (bool), final_rho_k (float), final_r_sigma_k (float), iterations (int)]`。最终输出是这些列表的列表。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在数值线性代数，特别是特征值算法方面有坚实的科学基础。带位移的逆幂法是一种标准技术。当位移等于特征值时出现的奇异系统挑战是该方法的一个关键实践方面，而建议的补救措施（正则化、最小二乘法）是标准的数值实践。问题是适定的，所有参数、条件和测试用例都已明确定义，从而可以得到一个确定性且可验证的解。语言客观而精确。问题陈述通过了所有验证标准。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个合理的解决方案。\n\n## 解决方案\n\n该问题要求实现带位移的逆幂法，以验证给定值 $\\sigma = \\lambda_{\\text{test}}$ 是否为矩阵 $A$ 的一个特征值。该算法的核心是对一个向量迭代应用预解算子 $(A-\\sigma I)^{-1}$。\n\n### 带位移逆幂法原理\n带位移逆幂法是一种寻找矩阵 $A$ 的特征向量的算法，该特征向量对应于最接近所选位移 $\\sigma$ 的特征值 $\\lambda_j$。该方法依赖于这样一个性质：如果 $A$ 的特征值是 $\\{\\lambda_i\\}$，那么矩阵 $(A-\\sigma I)^{-1}$ 的特征值就是 $\\{(\\lambda_i - \\sigma)^{-1}\\}$。当幂法应用于 $(A-\\sigma I)^{-1}$ 时，它会收敛到与其最大模特征值相关联的特征向量。这对应于值 $(\\lambda_j - \\sigma)^{-1}$，其中 $|\\lambda_j - \\sigma|$ 被最小化。迭代步骤定义为求解 $(A-\\sigma I)y_k = x_{k-1}$ 得到 $y_k$，然后归一化以获得下一个迭代向量 $x_k = y_k / \\lVert y_k \\rVert_2$。\n\n### 奇异性问题\n当位移 $\\sigma$ 是 $A$ 的一个实际特征值时，会出现一个关键的复杂问题。在这种情况下，矩阵 $A - \\sigma I$ 是奇异的，其逆矩阵未定义。线性系统 $(A-\\sigma I)y_k = x_{k-1}$ 变得不适定。必须采用一个稳健的数值方法来处理这种情况。问题陈述提出了两种此类机制：Tikhonov 正则化和最小二乘解。\n\n### 对所提机制的分析\n1.  **Tikhonov 正则化**：此方法将系统修改为 $((A - \\sigma I) + \\mu I) y_k = x_{k-1}$，其中 $\\mu$ 是一个小的正参数。这等价于求解 $(A - (\\sigma - \\mu) I) y_k = x_{k-1}$，这是一个带有轻微扰动位移 $\\sigma_{\\text{eff}} = \\sigma - \\mu$ 的标准逆幂迭代。由于 $\\sigma$ 是一个特征值 $\\lambda_j$，且 $\\mu$ 很小，$\\sigma_{\\text{eff}}$ 非常接近 $\\lambda_j$。预解算子 $(A - \\sigma_{\\text{eff}} I)^{-1}$ 是良定义的（假设 $\\sigma - \\mu$ 不是另一个特征值，对于一个小的固定 $\\mu$ 来说这极不可能），并且有一个非常大的特征值 $(\\lambda_j - (\\sigma - \\mu))^{-1} = \\mu^{-1}$。因此，该方法将迅速收敛到与 $\\lambda_j$ 对应的期望特征向量。这种方法在数学上是可靠且稳健的。\n\n2.  **最小二乘解**：这涉及寻找一个向量 $y_k$ 来最小化残差范数 $\\lVert (A - \\sigma I) y_k - x_{k-1} \\rVert_2$。用于解决此问题的标准数值求解器，例如基于奇异值分解 (SVD) 的求解器，通常会找到唯一的最小欧几里得范数解。该解与 $(A - \\sigma I)^T$ 的零空间正交。如果 $A$ 是对称的，这意味着解与我们试图寻找的特征向量正交，这是适得其反的。对于非对称矩阵，情况更为复杂，但该方法不保证会放大期望特征向量的分量。\n\n### 选定的实现策略\n考虑到一位严谨教授的角色，必须选择最正确和最可靠的方法。Tikhonov 正则化方法在此应用中明显更优。我们将采用一种统一的策略，在所有情况下都应用正则化。通过用一个固定的、小的 $\\mu$ 求解 $(A - \\sigma I + \\mu I) y_k = x_{k-1}$，算法可以稳健地处理两种情况：\n- 如果 $\\sigma$ 是一个特征值，正则化使系统良定，并确保收敛到正确的特征向量。\n- 如果 $\\sigma$ 不是一个特征值，$\\mu I$ 项是对一个已经非奇异的系统的小扰动，迭代过程基本上与标准带位移逆迭代相同。\n\n这种策略简单、优雅，并避免了最小范数最小二乘法的陷阱。我们将使用建议的正则化参数基线值 $\\mu = 10^{-8} \\max(1, \\lVert A \\rVert_F)$。\n\n验证过程如下：\n对于每个测试用例 $(A, \\lambda_{\\text{test}})$，我们设置 $\\sigma = \\lambda_{\\text{test}}$ 并生成一个确定的初始单位向量 $x_0$。然后我们迭代最多 $k_{\\max}$ 次。在每次迭代 $k$ 中，我们求解正则化线性系统得到 $y_k$，将其归一化得到 $x_k$，并计算残差 $r_{\\sigma,k} = \\lVert A x_k - \\sigma x_k \\rVert_2$。如果 $r_{\\sigma,k}$ 下降到容差 $\\tau_{\\text{res}} = 10^{-8}$ 以下，迭代终止，$\\lambda_{\\text{test}}$ 被声明为“已验证”。否则，过程继续直到 $k=k_{\\max}$，此时报告最终状态。瑞利商 $\\rho_k = x_k^{\\top} A x_k$ 也在每一步计算，并报告其最终值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_verification(A: np.ndarray, lambda_test: float, k_max: int, tau_res: float, seed: int) - list:\n    \"\"\"\n    Verifies a claimed eigenvalue using the shifted inverse power method.\n\n    Args:\n        A: The square matrix.\n        lambda_test: The claimed eigenvalue to test (used as the shift).\n        k_max: Maximum number of iterations.\n        tau_res: Residual tolerance for convergence.\n        seed: Seed for the pseudorandom number generator for the initial vector.\n\n    Returns:\n        A list containing [verified, final_rho, final_r_sigma, iterations].\n    \"\"\"\n    n = A.shape[0]\n    sigma = lambda_test\n\n    # 1. Initialization\n    # Set seed for a deterministic initial vector\n    np.random.seed(seed)\n    # Create and normalize initial vector from a standard normal distribution\n    x_prev = np.random.randn(n)\n    x_prev = x_prev / np.linalg.norm(x_prev)\n\n    # Use Tikhonov regularization a priori for a unified, robust approach.\n    # This is equivalent to a slightly perturbed shift sigma_eff = sigma - mu.\n    mu = 1.0e-8 * max(1.0, np.linalg.norm(A, 'fro'))\n    M = A - sigma * np.identity(n) + mu * np.identity(n)\n\n    # Initialize variables to be reported\n    x_k = np.copy(x_prev)\n    rho_k = 0.0\n    r_sigma_k = np.inf\n    k = 0\n\n    # 2. Iteration Loop\n    for k_iter in range(1, k_max + 1):\n        k = k_iter\n\n        try:\n            # Solve the regularized system: (A - sigma*I + mu*I) * y_k = x_{k-1}\n            y_k = np.linalg.solve(M, x_prev)\n        except np.linalg.LinAlgError:\n            # This case is extremely unlikely if mu is chosen properly, but as a safeguard,\n            # we report failure by breaking the loop with a high residual.\n            r_sigma_k = np.inf\n            break\n        \n        y_norm = np.linalg.norm(y_k)\n\n        # If y_k is a zero vector, iteration cannot proceed.\n        if y_norm  np.finfo(float).eps:\n            break\n\n        # Normalize to get the next iterate\n        x_k = y_k / y_norm\n\n        # 3. Compute Metrics\n        Ax_k = A @ x_k\n        # Rayleigh quotient (since x_k is unit norm, x_k.T @ x_k = 1)\n        rho_k = x_k.T @ Ax_k\n        # Residual with respect to the shift sigma\n        r_sigma_k = np.linalg.norm(Ax_k - sigma * x_k)\n\n        # Update for the next iteration\n        x_prev = x_k\n\n        # 4. Termination Condition\n        if r_sigma_k = tau_res:\n            break\n\n    # 5. Finalization\n    # The verification rule is based on the final residual\n    verified = r_sigma_k = tau_res\n\n    return [verified, rho_k, r_sigma_k, k]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define constants from the problem statement\n    TAU_RES = 1.0e-8\n    K_MAX = 30\n    # A single fixed seed is used to generate the initial vector for all tests,\n    # ensuring full reproducibility of the entire script.\n    SEED = 42\n\n    # Define the test cases from the problem statement\n    A1 = np.array([[2.0, 1.0, 0.0], [1.0, 2.0, 1.0], [0.0, 1.0, 2.0]])\n    lambda1 = 2.0\n\n    A2 = np.array([[1.0, 2.0, 3.0], [0.0, 4.0, 5.0], [0.0, 0.0, 6.0]])\n    lambda2 = 4.0\n\n    A3 = A1\n    lambda3 = 2.5\n\n    A4 = np.diag([1.0, 1.001, 10.0])\n    lambda4 = 1.001\n\n    test_cases = [\n        (A1, lambda1),\n        (A2, lambda2),\n        (A3, lambda3),\n        (A4, lambda4),\n    ]\n\n    results = []\n    for A, lambda_test in test_cases:\n        result = run_verification(A, lambda_test, K_MAX, TAU_RES, SEED)\n        results.append(result)\n\n    # Final print statement in the exact required format\n    result_strings = []\n    for res in results:\n        verified_str = str(res[0])\n        rho_k_str = f\"{res[1]:.15g}\"\n        r_sigma_k_str = f\"{res[2]:.15g}\"\n        k_str = str(res[3])\n        result_strings.append(f\"[{verified_str},{rho_k_str},{r_sigma_k_str},{k_str}]\")\n\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n\n```", "id": "3273273"}]}