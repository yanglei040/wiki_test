{"hands_on_practices": [{"introduction": "Schur分解不仅是一种构造性的存在性证明，它更揭示了矩阵内在属性与其上三角形式之间的深刻联系。本练习将探讨一个特殊的矩阵类别——幂零矩阵，并利用Schur分解来揭示其上三角矩阵$T$的一个确定性结构特征。通过这个练习[@problem_id:1388411]，你将深化对“Schur分解的对角元即为矩阵特征值”这一核心性质的理解。", "problem": "在线性代数中，一个具有复数项的方阵 $A$ 如果存在一个正整数 $k$ 使得 $A^k$ 为零矩阵，则称该矩阵为**幂零**矩阵。舒尔分解定理指出，任何复方阵 $A$ 都可以分解为 $A = UTU^*$，其中 $U$ 是一个酉矩阵（即 $U^*U = UU^* = I$），$T$ 是一个上三角矩阵。矩阵 $U^*$ 表示 $U$ 的共轭转置。\n\n考虑一个非零的幂零矩阵 $A \\in \\mathbb{C}^{n \\times n}$。根据幂零矩阵的性质和舒尔分解，关于 $A$ 的舒尔分解中的上三角矩阵 $T$，以下哪个陈述必定为真？\n\nA. $T$ 必定是零矩阵。\n\nB. $T$ 必定是对角矩阵。\n\nC. $T$ 的对角线元素必定全为零。\n\nD. $T$ 必定是单位矩阵。\n\nE. $T$ 必定是对称矩阵（即 $T = T^T$）。", "solution": "一个矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 是幂零的，如果存在一个正整数 $k$ 使得 $A^{k}=0$。设 $\\lambda$ 是 $A$ 的任意一个特征值，其对应的特征向量为 $v \\neq 0$，因此有 $Av=\\lambda v$。那么\n$$\nA^{k}v=\\lambda^{k}v.\n$$\n因为 $A^{k}=0$，所以 $A^{k}v=0$，因此 $\\lambda^{k}v=0$。由于 $v \\neq 0$，我们必须有 $\\lambda^{k}=0$，这意味着 $\\lambda=0$。因此，$A$ 的所有特征值都等于 $0$。\n\n根据舒尔分解，存在一个酉矩阵 $U$ 和一个上三角矩阵 $T$ 使得\n$$\nA=UTU^{*}。\n$$\n相似变换不改变特征值，所以 $A$ 和 $T$ 具有相同的特征值多重集。对于一个上三角矩阵 $T$，其特征值恰好是其对角线元素。因此，$T$ 的所有对角线元素都必须为零。\n\n现在评估这些陈述：\n- A. $T$ 必定是零矩阵：不一定，因为 $A$ 是非零的；$T$ 可以是严格上三角且非零的。\n- B. $T$ 必定是对角矩阵：不一定；对角线元素为零的上三角矩阵不一定是对角矩阵。\n- C. $T$ 的对角线元素必定全为零：如上所示，这必定为真。\n- D. $T$ 必定是单位矩阵：错误，因为那将导致非零的特征值。\n- E. $T$ 必定是对称矩阵：如果 $T$ 是对称矩阵且是上三角矩阵，那么它将是对角矩阵；再结合对角线元素为零的条件，这将迫使 $T=0$，而这并非必要条件。\n\n因此，只有陈述C必定为真。", "answer": "$$\\boxed{C}$$", "id": "1388411"}, {"introduction": "对于一类被称为“正规矩阵”的特殊矩阵（满足 $A A^* = A^* A$），Schur分解会呈现出一种更简洁、更强大的形式——谱分解，其中上三角矩阵$T$实际上是对角矩阵。本练习要求你为一个具体的$2 \\times 2$正规矩阵找到其Schur分解中的酉矩阵$U$。这不仅是一次计算实践[@problem_id:1388405]，更是一个绝佳的机会，让你去理解为何正规矩阵的Schur分解必然是对角分解，以及酉矩阵$U$的列为何必须由正交的特征向量构成。", "problem": "考虑复矩阵 $A$ 如下：\n$$A = \\begin{pmatrix} 1 & i \\\\ i & 1 \\end{pmatrix}$$\n方阵 $A$ 的舒尔分解 (Schur decomposition) 是形如 $A = UTU^*$ 的因式分解，其中 $U$ 是一个酉矩阵 (unitary matrix)，$T$ 是一个上三角矩阵 (upper triangular matrix)。符号 $U^*$ 表示 $U$ 的共轭转置。\n\n在矩阵 $A$ 的一个有效舒尔分解中，下列哪个矩阵可以是矩阵 $U$？\n\nA. $U = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix}$\n\nB. $U = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$\n\nC. $U = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ i & -i \\end{pmatrix}$\n\nD. $U = \\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix}$", "solution": "我们需要一个酉矩阵 $U$ 使得 $T = U^{*} A U$ 是上三角矩阵。一个矩阵 $U$ 是酉矩阵当且仅当 $U^{*} U = I$。此外，由于\n$$\nA = \\begin{pmatrix} 1 & i \\\\ i & 1 \\end{pmatrix}, \\quad A^{*} = \\begin{pmatrix} 1 & -i \\\\ -i & 1 \\end{pmatrix},\n$$\n我们计算\n$$\nA A^{*} = \\begin{pmatrix} 1 & i \\\\ i & 1 \\end{pmatrix} \\begin{pmatrix} 1 & -i \\\\ -i & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} = A^{*} A.\n$$\n因此 $A$ 是正规矩阵，在任何舒尔分解中，$U^{*} A U$ 都必须是对角矩阵（因此也是上三角矩阵）。\n\n选项 A: $U = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix}$。其列向量为\n$$\nu_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}, \\quad u_{2} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n它们是标准正交的，所以 $U^{*} U = I$ 且 $U$ 是酉矩阵。此外，\n$$\nA \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} = \\begin{pmatrix} 1 - i \\\\ i - 1 \\end{pmatrix} = (1 - i) \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}, \\quad\nA \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 + i \\\\ i + 1 \\end{pmatrix} = (1 + i) \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n因此，这些列向量是 $A$ 的特征向量，且\n$$\nU^{*} A U = \\begin{pmatrix} 1 - i & 0 \\\\ 0 & 1 + i \\end{pmatrix},\n$$\n这是一个对角矩阵（因此也是上三角矩阵）。所以选项 A 是有效的。\n\n选项 B: $U = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix}$。这个矩阵是酉矩阵，但是\n$$\nU^{*} A U = A = \\begin{pmatrix} 1 & i \\\\ i & 1 \\end{pmatrix},\n$$\n并且由于位置 $(2,1)$ 的元素等于 $i \\neq 0$，所以 $A$ 不是上三角矩阵。所以选项 B 是无效的。\n\n选项 C: $U = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & 1 \\\\ i & -i \\end{pmatrix}$。其列向量是标准正交的，因此 $U$ 是酉矩阵。通过列向量计算 $T = U^{*} A U$：\n$$\nu_{1} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \\\\ i \\end{pmatrix}, \\quad u_{2} = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 \\\\ -i \\end{pmatrix},\n$$\n$$\nA u_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 0 \\\\ 2i \\end{pmatrix}, \\quad A u_{2} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix}.\n$$\n使用\n$$\nU^{*} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix},\n$$\n我们得到 $T$ 的列向量：\n$$\nT e_{1} = U^{*} (A u_{1}) = \\frac{1}{2} \\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 2i \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}, \\quad\nT e_{2} = U^{*} (A u_{2}) = \\frac{1}{2} \\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n因此\n$$\nT = \\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix},\n$$\n由于位置 $(2,1)$ 上的元素非零，它不是一个上三角矩阵。由于 $A$ 是正规矩阵，任何舒尔形式都必须是对角矩阵；这个 $U$ 不能将 $A$ 对角化。所以选项 C 是无效的。\n\n选项 D: $U = \\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix}$。计算\n$$\nU^{*} U = \\begin{pmatrix} 1 & -1 \\\\ 1 & 1 \\end{pmatrix} \\begin{pmatrix} 1 & 1 \\\\ -1 & 1 \\end{pmatrix} = \\begin{pmatrix} 2 & 0 \\\\ 0 & 2 \\end{pmatrix} \\neq I,\n$$\n所以 $U$ 不是酉矩阵。所以选项 D 是无效的。\n\n只有选项 A 产生了一个酉矩阵 $U$，使得 $U^{*} A U$ 是上三角矩阵（实际上是对角矩阵）。", "answer": "$$\\boxed{A}$$", "id": "1388405"}, {"introduction": "在科学计算中，处理实数矩阵时，我们通常更希望得到一个完全由实数构成的分解，以避免复数运算的复杂性并提高效率。虽然Schur分解在理论上保证存在一个复数的酉矩阵$Q$和上三角矩阵$T$，但对于实矩阵$A$，我们可以将其转化为“实Schur分解”$A=ZRZ^T$。本练习[@problem_id:3271057]是一个进阶的编程任务，要求你实现一个算法，将一个给定实矩阵的复Schur形式$(Q,T)$转换为其实Schur形式$(Z,R)$，这是理解和构建稳健数值算法的关键一步。", "problem": "一个实方阵 $A \\in \\mathbb{R}^{n \\times n}$ 存在复舒尔分解 (Complex Schur Decomposition)，该分解指出，存在一个酉矩阵 $Q \\in \\mathbb{C}^{n \\times n}$ 和一个上三角矩阵 $T \\in \\mathbb{C}^{n \\times n}$，使得 $A = Q T Q^{*}$，其中 $Q^{*}$ 表示 $Q$ 的共轭转置。一个实方阵也存在实舒尔分解 (Real Schur Decomposition)，该分解指出，存在一个正交矩阵 $Z \\in \\mathbb{R}^{n \\times n}$ 和一个准上三角矩阵 $R \\in \\mathbb{R}^{n \\times n}$（一个对角线上由 $1 \\times 1$ 和 $2 \\times 2$ 实数块构成，且在第一副对角线下方严格为零的矩阵），使得 $A = Z R Z^{\\top}$，其中 $Z^{\\top}$ 表示 $Z$ 的转置。对于实矩阵 $A$，其复特征值成共轭对出现；因此，通过为与实特征值相关的不变子空间（一维子空间）和与复共轭对相关的不变子空间（二维实不变子空间）选择合适的实基，可以将复舒尔形式 (Complex Schur Form) 转换为实舒尔形式 (Real Schur Form)。\n\n从上述线性代数的基本事实出发，编写一个完整的程序，实现一个函数，该函数在给定一个实矩阵 $A$ 的复舒尔形式 $(Q, T)$ 的情况下，构造出相应的实舒尔形式 $(Z, R)$。该函数必须：\n- 接受满足 $A = Q T Q^{*}$（对于某个实矩阵 $A$）的 $Q \\in \\mathbb{C}^{n \\times n}$ 和 $T \\in \\mathbb{C}^{n \\times n}$。\n- 假设 $T$ 的对角线元素已排序，使得复共轭特征值连续出现（每对形如 $\\lambda = \\alpha + i \\beta$ 后跟 $\\overline{\\lambda} = \\alpha - i \\beta$），而实特征值则单独出现。\n- 生成正交矩阵 $Z \\in \\mathbb{R}^{n \\times n}$ 和准上三角矩阵 $R \\in \\mathbb{R}^{n \\times n}$，使得 $A = Z R Z^{\\top}$。\n\n您的算法应基于以下原理：\n- 对于实特征值 $\\lambda \\in \\mathbb{R}$，一维不变子空间由相应的舒尔向量 $q \\in \\mathbb{C}^{n}$ 张成；因为 $A$ 是实矩阵，可以通过调整该向量的相位使其变为实向量，然后进行归一化，从而得到 $Z$ 的一个实数列。\n- 对于复共轭对 $\\lambda = \\alpha + i \\beta$ 和 $\\overline{\\lambda} = \\alpha - i \\beta$（其中 $\\beta \\neq 0$），相应的二维不变子空间可以由一个正交实基表示，该基由与 $\\lambda$ 关联的一个舒尔向量 $q \\in \\mathbb{C}^{n}$ 的实部和虚部构造，然后进行实数正交规范化（例如，使用标准的 Gram–Schmidt 过程）。\n\n为了使任务具体化和可测试，您的程序必须为以下测试矩阵 $A$ 构造复舒尔形式 $(Q, T)$，利用正规矩阵著名的酉对角化性质（即，对于这些选择，$A = Q \\Lambda Q^{*}$，其中 $\\Lambda$ 是对角矩阵），其中标准特征分解得到的特征向量被归一化以形成酉矩阵 $Q$，而 $T$ 则设置为按规定顺序排列的特征值对角矩阵：\n- 测试 1 (二乘二复数对): $A_{1} = \\begin{bmatrix} 1 & 2 \\\\ -2 & 1 \\end{bmatrix}$。\n- 测试 2 (一个实特征值和一个复数对): $A_{2} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 2 \\end{bmatrix}, \\begin{bmatrix} 1 & 3 \\\\ -3 & 1 \\end{bmatrix}\\right)$，得到一个三乘三矩阵。\n- 测试 3 (两个复数对): $A_{3} = \\operatorname{block\\_diag}\\!\\left(\\begin{bmatrix} 0 & 2 \\\\ -2 & 0 \\end{bmatrix}, \\begin{bmatrix} -1 & 1 \\\\ -1 & -1 \\end{bmatrix}\\right)$，得到一个四乘四矩阵。\n- 测试 4 (所有实特征值，对称): $A_{4} = \\begin{bmatrix} 2 & 1 & 0 \\\\ 1 & 3 & 1 \\\\ 0 & 1 & 4 \\end{bmatrix}$。\n\n对于每个测试矩阵 $A$，执行以下步骤：\n- 如上所述计算 $(Q, T)$（酉特征向量矩阵 $Q$ 和对角矩阵 $T$，其特征值排序方式为复共轭对连续出现，实特征值先于复数对）。\n- 按规定将 $(Q, T)$ 转换为 $(Z, R)$。\n- 计算以下四个定量诊断指标（每个都是实数）：\n    $1.$ 正交性误差: $\\left\\|Z^{\\top} Z - I\\right\\|_{F}$，其中 $I$ 是单位矩阵，$\\|\\cdot\\|_{F}$ 表示 Frobenius 范数。\n    $2.$ 准上三角性误差: $R$ 中严格位于第一副对角线下方的元素（即对于索引 $i - j > 1$ 的 $\\left\\| R_{i j} \\right\\|_{F}$）的 Frobenius 范数。\n    $3.$ 重构误差: $\\left\\| A - Z R Z^{\\top} \\right\\|_{F}$。\n    $4.$ 特征值匹配误差: 对于 $A$ 的特征值 $\\{\\mu_{k}\\}$ 和 $R$ 的特征值 $\\{\\nu_{k}\\}$，计算 $\\max_{k} \\min_{\\ell} \\left| \\mu_{k} - \\nu_{\\ell} \\right|$。\n\n您的程序应生成一行输出，其中包含一个以逗号分隔的列表，列表用方括号括起来，每个测试用例贡献一个包含上述四个浮点值的列表。例如，格式必须为 $\\left[ [e_{11}, e_{12}, e_{13}, e_{14}], [e_{21}, e_{22}, e_{23}, e_{24}], [e_{31}, e_{32}, e_{33}, e_{34}], [e_{41}, e_{42}, e_{43}, e_{44}] \\right]$。不涉及物理单位或角度单位，也不需要百分比；所有答案都是实数。", "solution": "用户希望实现一个程序，将实矩阵 $A$ 的复舒尔形式 $(Q, T)$ 转换为实舒尔形式 $(Z, R)$。该程序必须在四个特定的矩阵上进行测试，并且对每个矩阵，都必须计算并报告一组四个诊断误差。\n\n### 第 1 步：理论基础与算法设计\n\n一个实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的特征值要么是实数，要么以复共轭对的形式出现。舒尔分解 $A = U S U^*$，其中 $U$ 是酉矩阵，$S$ 是上三角矩阵，其对角线上是 $A$ 的特征值。如果 $A$ 是实矩阵，我们可以找到一个*实*正交矩阵 $Z$，使得 $A = Z R Z^\\top$，其中 $R$ 是一个实准上三角矩阵。$R$ 的对角线由对应实特征值的 $1 \\times 1$ 块和对应复共轭对的 $2 \\times 2$ 块组成。\n\n任务是将给定的复舒尔形式 $(Q, T)$ 转换为实舒尔形式 $(Z, R)$。已知 $A = Q T Q^*$ 是实矩阵，$Q$ 是酉矩阵，$T$ 是上三角矩阵（对于所提供的正规测试矩阵来说是对角矩阵），并且其对角线元素的排序方式是实特征值分组在一起，复共轭对相邻。\n\n转换算法通过迭代遍历 $T$ 的对角线，并应用局部酉变换将 $Q$ 的列转换为实向量，这些实向量将构成新的实正交矩阵 $Z$ 的列。同样的变换也应用于 $T$ 以保持等式成立，从而得到准上三角矩阵 $R$。\n\n设 $Z_0 = Q$ 和 $R_0 = T$。我们迭代地构造一系列酉矩阵 $U_k$ 以生成 $Z_{k+1} = Z_k U_k$ 和 $R_{k+1} = U_k^* R_k U_k$，使得 $Z_k$ 逐渐变为实矩阵。最终的 $Z$ 将是 $Z = Q U_0 U_1 \\dots$，而 $R$ 将是 $R = \\dots U_1^* U_0^* T U_0 U_1 \\dots$。\n\n该过程迭代遍历 $T$ 的对角元素（特征值）：\n1.  **实特征值**：如果 $T_{kk} = \\lambda_k \\in \\mathbb{R}$，相应的舒尔向量 $q_k$（$Q$ 的第 $k$ 列）张成一个一维实不变子空间。这意味着 $q_k$ 可以通过乘以一个合适的相位因子 $e^{i\\phi}$ 变为实数。我们找到一个模最大的分量 $q_{jk}$，并选择 $e^{i\\phi}$ 使该分量变为实数。由于 $A$ 和 $\\lambda_k$ 都是实数，$A q_k = \\lambda_k q_k$ 意味着如果 $q_k$ 的一个分量变为实数，整个向量都会变为实数。这对应于一个变换 $U_k$，该变换是单位矩阵，但在位置 $(k, k)$ 处有一个相位因子。更新后的 $Q$ 变为 $Q U_k$，$T$ 变为 $U_k^* T U_k$。\n\n2.  **复共轭对**：如果 $T_{kk} = \\lambda = \\alpha + i\\beta$（其中 $\\beta \\neq 0$），那么根据指定的排序，$T_{k+1, k+1} = \\overline{\\lambda} = \\alpha - i\\beta$。相应的舒尔向量 $q_k$ 和 $q_{k+1}$ 张成一个二维不变子空间。可以为该子空间构造一个实正交规范基。例如，如果我们假设 $q_{k+1} \\approx \\overline{q_k}$（对于实矩阵的特征向量来说是这种情况），我们可以构成两个新的实正交规范向量：$z_k = \\frac{1}{\\sqrt{2}}(q_k + q_{k+1})$ 和 $z_{k+1} = \\frac{1}{i\\sqrt{2}}(q_k - q_{k+1})$。这个基变换通过一个应用于 $Q$ 的第 $k$ 列和第 $k+1$ 列的 $2 \\times 2$ 酉变换 $V = \\frac{1}{\\sqrt{2}}\\begin{pmatrix} 1 & -i \\\\ 1 & i \\end{pmatrix}$ 来完成。对 $T$ 的 $2 \\times 2$ 对角块进行相应的相似变换为：\n    $$ V^* \\begin{pmatrix} \\lambda & 0 \\\\ 0 & \\overline{\\lambda} \\end{pmatrix} V = \\begin{pmatrix} \\alpha & \\beta \\\\ -\\beta & \\alpha \\end{pmatrix} $$\n    这就在 $R$ 中得到了所需的 $2 \\times 2$ 实数块。完整的变换 $U_k$ 是一个在索引 $(k,k+1)$ 处有此 $V$ 块的单位矩阵。\n\n这个过程被迭代应用，直到 $Q$ 的所有列都被处理完毕，从而得到一个实正交矩阵 $Z$ 和一个实准上三角矩阵 $R$。\n\n### 第 2 步：实现策略\n\n程序将按以下结构组织：\n1.  一个主函数 `solve()` 将协调四个测试用例的整个过程。\n2.  定义测试矩阵 $A_1, A_2, A_3, A_4$。\n3.  对于每个矩阵 $A$：\n    a.  使用 `numpy.linalg.eig` 计算特征分解 $(V, \\Lambda)$。\n    b.  问题指出，对于这些正规矩阵，复舒尔形式 $(Q, T)$ 可以取为酉特征向量矩阵和对角特征值矩阵。特征值和特征向量被排序，以使实数值排在前面，后面是复共轭对。一个自定义的排序键确保对于一对 $\\alpha \\pm i\\beta$，带有正虚部的特征值 $\\alpha+i\\beta$ 先出现。\n    c.  排序后的特征向量构成酉矩阵 $Q$ 的列，排序后的特征值构成上三角矩阵 $T$ 的对角线。\n    d.  调用一个函数 `complex_to_real_schur(Q, T)` 来执行转换，该函数基于上述算法。此函数迭代遍历 $T$ 的对角线，并对 $Q$ 和 $T$ 应用适当的 $1 \\times 1$ 相位或 $2 \\times 2$ 块变换，得到 $Z$ 和 $R$。\n    e.  计算四个指定的诊断指标：\n        i.   **正交性误差**：计算 $\\|Z^\\top Z - I\\|_F$ 以验证 $Z$ 是正交的。\n        ii.  **准上三角性误差**：计算 $R$ 中严格位于第一副对角线下方的元素（即 $i-j > 1$ 的 $R_{ij}$）的 Frobenius 范数。\n        iii. **重构误差**：计算 $\\|A - Z R Z^\\top\\|_F$ 以验证分解。\n        iv.  **特征值匹配误差**：计算 $A$ 和 $R$ 的特征值，并计算误差 $\\max_{k} \\min_{\\ell} |\\mu_k(A) - \\nu_\\ell(R)|$。\n4.  收集所有测试用例的结果，并以指定的列表的列表格式打印出来。\n\n这个实现计划是将理论原理直接转化为具体的数值算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef complex_to_real_schur(Q, T):\n    \"\"\"\n    Converts a Complex Schur form (Q, T) of a real matrix to a Real Schur Form (Z, R).\n    \n    Args:\n        Q (np.ndarray): Unitary matrix from Complex Schur form.\n        T (np.ndarray): Upper-triangular matrix from Complex Schur form.\n        \n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple (Z, R) representing the Real Schur form,\n                                       where Z is real orthogonal and R is real quasi-upper-triangular.\n    \"\"\"\n    Z = Q.copy().astype(np.complex128)\n    R = T.copy().astype(np.complex128)\n    n = Z.shape[0]\n    k = 0\n    tol = 1e-9\n\n    while k  n:\n        # Check if eigenvalue is complex\n        if abs(np.imag(R[k, k])) > tol:\n            # Complex conjugate pair case. The problem guarantees they are adjacent.\n            if k + 1 >= n:\n                # This should not be reached with proper input ordering.\n                k += 1\n                continue\n            \n            # Unitary transformation for a 2x2 block\n            V = (1 / np.sqrt(2)) * np.array([[1, -1j], [1, 1j]], dtype=np.complex128)\n            \n            # Apply transformation to Z: Z_new = Z_old @ U_k\n            Z[:, k:k+2] = Z[:, k:k+2] @ V\n            \n            # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n            R[:, k:k+2] = R[:, k:k+2] @ V\n            R[k:k+2, :] = V.conj().T @ R[k:k+2, :]\n            \n            k += 2\n        else:\n            # Real eigenvalue case\n            # Re-phase column k of Z to be real.\n            Z_col = Z[:, k]\n            \n            # Only apply correction if there's a significant imaginary part\n            if np.linalg.norm(np.imag(Z_col)) > tol:\n                # Find element with largest magnitude to define the phase\n                j = np.argmax(np.abs(Z_col))\n                phase_val = Z_col[j]\n                \n                # Phase correction factor to make Z_col[j] real\n                c = phase_val.conj() / np.abs(phase_val) if np.abs(phase_val) > tol else 1.0\n                \n                # Apply transformation to Z: Z_new = Z_old @ U_k where U_k is diag(1,..,c,..)\n                Z[:, k] *= c\n                \n                # Apply similarity transformation to R: R_new = U_k^* @ R_old @ U_k\n                R[:, k] *= c\n                R[k, :] *= c.conj()\n            \n            k += 1\n\n    # Discard small imaginary parts resulting from floating-point noise\n    Z_real = np.real(Z)\n    R_real = np.real(R)\n\n    return Z_real, R_real\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[1., 2.], [-2., 1.]]),\n        np.array([[2., 0., 0.], [0., 1., 3.], [0., -3., 1.]]),\n        np.array([[0., 2., 0., 0.], [-2., 0., 0., 0.], [0., 0., -1., 1.], [0., 0., -1., -1.]]),\n        np.array([[2., 1., 0.], [1., 3., 1.], [0., 1., 4.]])\n    ]\n\n    all_results = []\n    tol = 1e-9\n\n    for A in test_cases:\n        n = A.shape[0]\n        \n        # Step 1: Compute eigendecomposition of A. For normal matrices, this is a Schur form.\n        eigvals, eigvecs = np.linalg.eig(A)\n\n        # Step 2: Sort eigenvalues and eigenvectors according to the problem specification.\n        # Real eigenvalues precede complex conjugate pairs.\n        # Pairs are ordered by real part, then |imaginary part|.\n        # Within a pair, the eigenvalue with the positive imaginary part comes first.\n        e_list = sorted(list(zip(eigvals, eigvecs.T)), \n                        key=lambda e: (abs(e[0].imag) > tol, e[0].real, abs(e[0].imag), -e[0].imag))\n\n        # Unpack the sorted list to get the initial Complex Schur form (Q, T)\n        sorted_eigvals, sorted_eigvecs_T = zip(*e_list)\n        Q = np.array(sorted_eigvecs_T, dtype=np.complex128).T\n        T = np.diag(np.array(sorted_eigvals, dtype=np.complex128))\n\n        # Step 3: Convert the Complex Schur form (Q, T) to a Real Schur form (Z, R)\n        Z, R = complex_to_real_schur(Q, T)\n\n        # Step 4: Compute the four quantitative diagnostics.\n        # 1. Orthogonality error of Z\n        ortho_err = np.linalg.norm(Z.T @ Z - np.eye(n), 'fro')\n\n        # 2. Quasi-upper-triangularity error of R (norm of elements below the first subdiagonal)\n        tri_err = np.linalg.norm(np.tril(R, k=-2))\n        \n        # 3. Reconstruction error\n        recon_err = np.linalg.norm(A - Z @ R @ Z.T, 'fro')\n\n        # 4. Eigenvalue matching error between A and R\n        mu = np.linalg.eigvals(A)\n        nu = np.linalg.eigvals(R)\n        \n        # Compute max_k min_l |mu_k - nu_l| using broadcasting\n        dists = np.abs(mu[:, np.newaxis] - nu)\n        min_dists_for_mu = np.min(dists, axis=1)\n        eig_match_err = np.max(min_dists_for_mu)\n        \n        all_results.append([ortho_err, tri_err, recon_err, eig_match_err])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(str(res) for res in all_results)}]\")\n\nsolve()\n```", "id": "3271057"}]}