{"hands_on_practices": [{"introduction": "在大规模科学模拟中，我们常常需要对多个向量重复应用一个经过变换的算子。这就引出了一个关键的实际问题：一次性显式地构建出这个新算子，然后反复使用它，是否比每次都隐式地应用其构成部分更有效率？[@problem_id:3273924] 这个练习将引导你使用标准的浮点运算计数（flops）模型，进行一次经典的成本效益分析，从而揭示在不同情况下最优的计算策略。", "problem": "考虑一个实数稠密矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个实数稠密非奇异矩阵 $P \\in \\mathbb{R}^{n \\times n}$。相似变换矩阵 $B$ 定义为 $B = P^{-1} A P$，该变换保持矩阵 $A$ 的特征值不变。在一次数值模拟中，您必须将由 $B$ 代表的线性算子应用于 $m$ 个不同的向量 $x^{(1)}, x^{(2)}, \\dots, x^{(m)} \\in \\mathbb{R}^{n}$。您正在考虑两种策略：\n\n- 策略 1（显式构建）：显式地构建矩阵 $B$，然后将 $B$ 应用于每个向量。\n- 策略 2（隐式应用）：不构建矩阵 $B$；而是通过复合映射 $x \\mapsto P^{-1}(A(Px))$ 将该算子应用于每个向量。\n\n假设稠密线性代数采用以下标准且经过充分检验的运算计数模型：\n- 一个 $n \\times n$ 稠密矩阵的 LU 分解（Lower-Upper factorization）需要 $\\frac{2}{3} n^{3}$ 次浮点运算 (flops)。\n- 两个 $n \\times n$ 稠密矩阵的矩阵-矩阵乘法需要 $2 n^{3}$ flops。\n- 求解一个具有 $n$ 个右侧向量的 $n \\times n$ 三角系统，每个三角因子需要 $n^{3}$ flops。\n- 一个 $n \\times n$ 稠密矩阵与向量的矩阵-向量乘法需要 $2 n^{2}$ flops。\n- 求解一个具有单个右侧向量的 $n \\times n$ 三角系统，每个三角因子需要 $n^{2}$ flops。\n\n对于策略 1，使用 $P$ 的 LU 因子和三角求解来构建 $B$（不要显式计算 $P^{-1}$），然后将 $B$ 应用于每个向量。对于策略 2，对 $P$ 进行一次分解，然后对于每个向量，使用矩阵-向量乘法和三角求解来应用映射 $x \\mapsto P^{-1}(A(Px))$。\n\n请仅使用这些模型和相似性的核心定义，推导出每种策略的总浮点运算次数（作为 $n$ 和 $m$ 的函数），并确定确切的收支平衡点值 $m^{\\ast}(n)$，在该点上策略 1 的总成本等于策略 2 的总成本。请将您的最终答案表示为关于 $n$ 的单个封闭形式表达式。无需进行四舍五入。", "solution": "用户要求我分析两种将相似变换矩阵 $B = P^{-1}AP$ 应用于 $m$ 个向量集合的计算策略。\n\n我需要：\n1.  验证问题陈述的有效性。\n2.  如果有效，计算每种策略的总浮点运算 (flop) 次数。\n3.  令两种策略的 flop 次数相等。\n4.  求解向量数量 $m$，我将其称为 $m^{\\ast}(n)$。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n-   $A \\in \\mathbb{R}^{n \\times n}$ 是一个实数稠密矩阵。\n-   $P \\in \\mathbb{R}^{n \\times n}$ 是一个实数稠密非奇异矩阵。\n-   $B = P^{-1} A P$ 是相似变换矩阵。\n-   我们需要计算 $B x^{(i)}$，其中 $i = 1, 2, \\dots, m$ 且 $x^{(i)} \\in \\mathbb{R}^{n}$。\n-   **运算计数模型：**\n    -   $n \\times n$ 矩阵的 LU 分解：$\\frac{2}{3} n^{3}$ flops。\n    -   稠密 $n \\times n$ 矩阵-矩阵乘法：$2 n^{3}$ flops。\n    -   求解具有 $n$ 个右侧向量的 $n \\times n$ 三角系统：每个三角因子 $n^{3}$ flops。\n    -   稠密 $n \\times n$ 矩阵-向量乘法：$2 n^{2}$ flops。\n    -   求解具有单个右侧向量的 $n \\times n$ 三角系统：每个三角因子 $n^{2}$ flops。\n-   **策略 1（显式构建）：**\n    1.  显式构建 $B$。问题陈述要求使用 $P$ 的 LU 因子和三角求解来完成，而不是显式计算 $P^{-1}$。\n    2.  将 $B$ 应用于 $m$ 个向量中的每一个。\n-   **策略 2（隐式应用）：**\n    1.  不构建 $B$。\n    2.  对 $P$ 分解一次。\n    3.  对于每个向量 $x^{(i)}$，使用矩阵-向量乘法和三角求解来应用映射 $x \\mapsto P^{-1}(A(Px))$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n1.  **科学上是否成立？** 是。该问题属于数值线性代数领域。相似变换、LU 分解和运算计数模型的定义都是标准且正确的。没有伪科学。flop 计数是标准的渐近主导项。\n2.  **是否适定？** 是。目标定义清晰：找到收支平衡点值 $m^{\\ast}(n)$。输入已指定，每种策略的方法也已阐明。预期有唯一解。\n3.  **是否客观？** 是。语言精确且技术性强。没有主观陈述。\n4.  **缺陷清单：**\n    -   **科学/事实不健全？** 否。所有模型和定义在数值分析中都是标准的。\n    -   **不可形式化/不相关？** 否。该问题是计算成本分析中的经典问题，与数值方法直接相关。\n    -   **不完整/矛盾？** 问题是自洽的。方法已指定。但是，让我仔细检查一下策略 1 中构建 $B$ 的说明。“使用 $P$ 的 LU 因子和三角求解来构建 $B$”。$B = P^{-1}AP$。要计算这个，我们可以先计算乘积 $C = AP$。然后我们需要计算 $B = P^{-1}C$。这等价于求解矩阵 $B$ 的线性系统 $PB = C$。为了求解 $PB=C$，我们首先得到 $P$ 的 LU 分解（即 $P=LU$，为简单起见假设没有主元选择，或者 $PA=LU$ 带主元选择，但给定的成本模型没有考虑主元选择的置换管理，所以我们坚持使用简单的 $LU$ 形式）。所以，$LU B = C$。我们首先求解 $LY = C$ 得到 $Y$（前向替换），然后求解 $UB = Y$ 得到 $B$（后向替换）。\n        -   $C = AP$ 的成本：一次矩阵-矩阵乘法，$2n^3$ flops。\n        -   $P$ 的 LU 分解成本：$\\frac{2}{3}n^3$ flops。\n        -   求解 $LY = C$ 的成本：这是求解 $n$ 个三角系统（$Y$ 和 $C$ 的每一列对应一个）。对于具有 $n$ 个右侧向量的三角系统，给定的成本是 $n^3$。所以这是 $n^3$ flops。\n        -   求解 $UB = Y$ 的成本：同样是 $n$ 个三角系统。这是另外 $n^3$ flops。\n        -   构建 $B$ 的总成本：$2n^3 + \\frac{2}{3}n^3 + n^3 + n^3 = (2 + \\frac{2}{3} + 1 + 1)n^3 = (\\frac{14}{3})n^3$ flops。这似乎与说明一致。\n    -   **不切实际/不可行？** 否。这种设置在科学计算中非常常见。\n    -   **病态/结构不良？** 否。问题结构清晰。\n    -   **伪深刻/微不足道？** 否。这是一个标准但并非微不足道的计算成本分析练习。\n    -   **超出科学可验证性范围？** 否。计算是直接且可验证的。\n\n问题看起来是有效的。我可以继续进行求解。\n\n**求解推导**\n\n**策略 1：显式构建**\n\n让我们仔细计算策略 1 的 flop 数量。\n\n*   **步骤 1.1：构建矩阵 $B = P^{-1}AP$。**\n    *   问题陈述要求使用 $P$ 的 LU 分解。这意味着我们求解矩阵方程 $P B = A P$。\n    *   首先，计算乘积 $C = AP$。这是一个稠密矩阵-矩阵乘法。\n        *   $C = AP$ 的成本：$2 n^3$ flops。\n    *   接下来，求解 $PB = C$ 以得到 $B$。为此，我们首先计算 $P$ 的 LU 分解。为简单起见，我们假设 $P=LU$（成本模型是针对这种情况给出的）。\n        *   $P$ 的 LU 分解成本：$\\frac{2}{3} n^3$ flops。\n    *   现在我们有 $L(UB) = C$。令 $Y = UB$。我们首先求解 $LY = C$ 以得到 $Y$。这涉及到求解 $n$ 个线性系统 $Ly_j = c_j$，其中 $y_j$ 和 $c_j$ 分别是 $Y$ 和 $C$ 的第 $j$ 列。这是对 $n$ 个右侧向量的前向替换过程。\n        *   问题给出的“求解一个具有 $n$ 个右侧向量的 $n \\times n$ 三角系统”的成本是“每个三角因子 $n^3$ flops”。这有点模棱两可。让我们来解释一下。求解一个系统 $Lx=b$ 需要 $n^2$ flops（前向替换）。所以求解 $n$ 个右侧向量应该是 $n \\times n^2 = n^3$。短语“每个三角因子”可能意味着 $L$ 一个，$U$ 一个。让我们检查一下给定的成本：“求解一个具有单个右侧向量的 $n \\times n$ 三角系统，每个三角因子需要 $n^2$ flops”。这也有些奇怪。通常，使用 $PA=LU$ 求解一次 $Ax=b$ 需要 $n^2$ 用于前向替换（$Ly=Pb$），$n^2$ 用于后向替换（$Ux=y$），总共 $2n^2$。这里说的是“每个三角因子 $n^2$”。这很可能意味着前向求解需要 $n^2$，后向求解需要 $n^2$。所以，单次求解 $P^{-1}v$ 的成本是 $\\frac{2}{3} n^3$（一次性分解）+ $2n^2$（求解）。成本模型似乎分开了求解成本。$Ly=b$ 需要 $n^2$，$Ux=y$ 需要 $n^2$。好的。\n        *   求解 $LY=C$ 的成本（前向替换）：$n^3$ flops。\n        *   求解 $UB=Y$ 的成本（后向替换）：$n^3$ flops。\n    *   构建 $B$ 的总成本：\n        $C_{form} = (\\text{cost of } AP) + (\\text{cost of LU of } P) + (\\text{cost of solving } LY=C) + (\\text{cost of solving } UB=Y)$\n        $C_{form} = 2n^3 + \\frac{2}{3}n^3 + n^3 + n^3 = (2 + \\frac{2}{3} + 1 + 1)n^3 = \\frac{14}{3}n^3$ flops。\n        这部分是一次性成本，与 $m$ 无关。\n\n*   **步骤 1.2：将 $B$ 应用于 $m$ 个向量中的每一个。**\n    *   对于每个向量 $x^{(i)}$，我们计算 $y^{(i)} = B x^{(i)}$。这是一个稠密矩阵-向量乘法。\n    *   每个向量的成本：$2 n^2$ flops。\n    *   $m$ 个向量的总成本：$m \\cdot (2 n^2)$ flops。\n\n*   **策略 1 的总成本：**\n    $C_1(n, m) = C_{form} + m(2n^2) = \\frac{14}{3}n^3 + 2mn^2$。\n\n**策略 2：隐式应用**\n\n*   **步骤 2.1：一次性设置。**\n    *   该策略要求“对 $P$ 分解一次”。这是对 $P$ 进行 LU 分解。\n    *   $P$ 的 LU 分解成本：$\\frac{2}{3} n^3$ flops。这是一次性成本。\n\n*   **步骤 2.2：对 $m$ 个向量中的每一个进行应用循环。**\n    *   对于每个向量 $x^{(i)}$，我们需要计算 $y^{(i)} = P^{-1}(A(Px^{(i)}))$。这分三步完成：\n        1.  计算 $z^{(i)} = P x^{(i)}$。这是一个稠密矩阵-向量乘法。\n            *   成本：$2 n^2$ flops。\n        2.  计算 $w^{(i)} = A z^{(i)}$。这是另一个稠密矩阵-向量乘法。\n            *   成本：$2 n^2$ flops。\n        3.  计算 $y^{(i)} = P^{-1} w^{(i)}$。这等价于求解系统 $P y^{(i)} = w^{(i)}$。由于我们有 $P$ 的 LU 因子（$P=LU$），我们分两步求解：a) 求解 $L v^{(i)} = w^{(i)}$（前向替换）和 b) 求解 $U y^{(i)} = v^{(i)}$（后向替换）。\n            *   成本模型指出：“求解一个具有单个右侧向量的 $n \\times n$ 三角系统，每个三角因子需要 $n^2$ flops。”\n            *   这意味着前向替换的成本是 $n^2$，后向替换的成本是 $n^2$。\n            *   求解 $y^{(i)}$ 的总成本：$n^2 + n^2 = 2n^2$ flops。\n    *   策略 2 每个向量的总成本：\n        $C_{per\\_vector} = (\\text{cost of } Px) + (\\text{cost of } Az) + (\\text{cost of } P^{-1}w)$\n        $C_{per\\_vector} = 2n^2 + 2n^2 + 2n^2 = 6n^2$ flops。\n    *   应用于 $m$ 个向量的总成本：$m \\cdot (6n^2)$ flops。\n\n*   **策略 2 的总成本：**\n    $C_2(n, m) = (\\text{one-time LU cost}) + (\\text{total application cost})$\n    $C_2(n, m) = \\frac{2}{3}n^3 + 6mn^2$。\n\n**寻找收支平衡点 $m^{\\ast}(n)$**\n\n我需要找到使总成本相等的 $m$ 值，我将其称为 $m^{\\ast}$。\n$C_1(n, m^{\\ast}) = C_2(n, m^{\\ast})$\n\n$\\frac{14}{3}n^3 + 2m^{\\ast}n^2 = \\frac{2}{3}n^3 + 6m^{\\ast}n^2$\n\n现在，我需要解这个方程以求出 $m^{\\ast}$。\n\n首先，将含有 $m^{\\ast}$ 的项和含有 $n^3$ 的项分组。\n$\\frac{14}{3}n^3 - \\frac{2}{3}n^3 = 6m^{\\ast}n^2 - 2m^{\\ast}n^2$\n\n$\\frac{12}{3}n^3 = 4m^{\\ast}n^2$\n\n$4n^3 = 4m^{\\ast}n^2$\n\n现在，我可以将两边都除以 $4n^2$。因为 $n$ 是矩阵的维度，我们可以假设 $n \\ge 1$。\n$m^{\\ast} = \\frac{4n^3}{4n^2}$\n\n$m^{\\ast} = n$\n\n所以，收支平衡点值是 $m^{\\ast}(n) = n$。\n\n我们来复核一下逻辑。\n\n**策略 1 成本：**\n-   一次性成本（构建 $B = P^{-1}AP$）：\n    -   $C_A = AP$：矩阵-矩阵乘法，$2n^3$ flops。\n    -   $P=LU$：LU 分解，$\\frac{2}{3}n^3$ flops。\n    -   求解 $PB=C_A$。这是 $n$ 个方程组。\n        -   $n$ 次前向替换（$LY=C_A$）：$n \\times n^2 = n^3$ flops。\n        -   $n$ 次后向替换（$UB=Y$）：$n \\times n^2 = n^3$ flops。\n    -   总一次性成本：$2n^3 + \\frac{2}{3}n^3 + n^3 + n^3 = \\frac{14}{3}n^3$。正确。\n-   每个向量的成本（计算 $y=Bx$）：\n    -   矩阵-向量乘法：$2n^2$ flops。\n-   总成本 $C_1(n,m) = \\frac{14}{3}n^3 + 2mn^2$。正确。\n\n**策略 2 成本：**\n-   一次性成本：\n    -   $P=LU$：LU 分解，$\\frac{2}{3}n^3$ flops。正确。\n-   每个向量的成本（计算 $y = P^{-1}(A(Px))$）：\n    -   $z = Px$：矩阵-向量乘法，$2n^2$ flops。\n    -   $w = Az$：矩阵-向量乘法，$2n^2$ flops。\n    -   $y = P^{-1}w$：使用 LU 因子求解 $Py=w$。\n        -   前向替换（$Lv=w$）：$n^2$ flops。\n        -   后向替换（$Uy=v$）：$n^2$ flops。\n        -   求解总成本：$2n^2$ flops。\n    -   每个向量的总成本：$2n^2 + 2n^2 + 2n^2 = 6n^2$。正确。\n-   总成本 $C_2(n,m) = \\frac{2}{3}n^3 + 6mn^2$。正确。\n\n**收支平衡点计算：**\n$\\frac{14}{3}n^3 + 2mn^2 = \\frac{2}{3}n^3 + 6mn^2$\n$(\\frac{14}{3} - \\frac{2}{3})n^3 = (6-2)mn^2$\n$\\frac{12}{3}n^3 = 4mn^2$\n$4n^3 = 4mn^2$\n$m = n$\n\n基于所提供的成本模型，计算过程直接明了，看起来是正确的。\n\n最终答案是 $m^{\\ast}(n) = n$。\n我应该遵循所有规则仔细格式化解决方案。\n- 所有数学公式使用 LaTeX。\n- 无 markdown 标题。\n- 符号推理。\n- 最终答案在 `\\boxed{...}` 中。\n问题要求的是 $m^{\\ast}(n)$，所以答案应该是关于 $n$ 的表达式。结果是 $n$。\n解决方案的结构将是：\n1.  陈述目标：推导 flop 计数并找到收支平衡点。\n2.  分析策略 1。将成本分解为构建成本和应用成本。求和。\n3.  分析策略 2。将成本分解为设置成本和应用成本。求和。\n4.  令两个总成本函数相等。\n5.  求解得到的方程，得到 $m$，并表示为 $m^{\\ast}(n)$。\n这个结构是合乎逻辑的，从原理到结论构建了论证。\n问题定义明确，除了给定的条件外不需要任何假设。分析完全是基于所提供的成本模型的代数运算。\n最终答案格式：`$$\\boxed{n}$$`\n逻辑已确认。我准备好编写解决方案了。", "answer": "$$\\boxed{n}$$", "id": "3273924"}, {"introduction": "我们知道相似矩阵具有相同的迹、行列式和特征多项式，但反过来是否成立呢？[@problem_id:3273917] 这个练习旨在挑战一个常见的误解，要求你构建一个反例。通过这个过程，你将被引导去深入探究那些真正定义相似性的结构属性，例如约当标准型（Jordan Normal Form），从而对相似关系建立更深刻的理解。", "problem": "设 $A$ 和 $B$ 是实 $4 \\times 4$ 矩阵。仅使用关于相似变换和矩阵不变量的核心定义和公认事实，构造两个显式矩阵 $A$ 和 $B$，使它们彼此不相似，但共享以下所有性质：\n- 相同的迹，\n- 相同的行列式，\n- 相同的特征多项式，\n- 相同的弗罗贝尼乌斯范数。\n\n你必须从第一性原理出发，证明为什么 $A$ 和 $B$ 不相似，以及为什么所列的四个量对于这两个矩阵是相等的。你可以使用以下事实：对于三角矩阵，特征值是其对角线元素；迹是对角线元素之和，行列式是对角线元素之积；弗罗贝尼乌斯范数定义为 $\\|X\\|_{F} = \\sqrt{\\sum_{i,j} x_{ij}^{2}} = \\sqrt{\\mathrm{trace}(X^{\\mathsf{T}} X)}$。\n\n最后，报告你所构造矩阵的共同弗罗贝尼乌斯范数的精确值。你的答案必须是一个单一的封闭形式表达式，不要四舍五入。", "solution": "问题要求构造两个实 $4 \\times 4$ 矩阵 $A$ 和 $B$，它们不相似，但具有相同的迹、行列式、特征多项式和弗罗贝尼乌斯范数。我们必须从第一性原理出发证明这些性质中的每一个。\n\n线性代数的一个核心原则是，两个矩阵相似当且仅当它们在不同基下表示同一个线性变换。这意味着相似矩阵共享许多性质，这些性质被称为相似不变量，包括特征多项式、特征值、迹和行列式。然而，反之不成立；共享这些性质并不能保证相似性。决定相似性的关键不变量是若尔当标准型。两个矩阵相似当且仅当它们具有相同的若尔当标准型（若尔当块的排列次序除外）。\n\n我们的策略是构造两个矩阵 $A$ 和 $B$，使它们具有相同的特征值但不同的若尔当块结构。这将确保它们具有相同的特征多项式（因此具有相同的迹和行列式），但彼此不相似。我们将特别以若尔当标准型的形式构造它们，这简化了分析。最后的约束是确保它们也具有相同的弗罗贝尼乌斯范数。\n\n让我们为我们的 $4 \\times 4$ 矩阵选择特征值。为简单起见，我们选择所有特征值都为 $0$。任何此类矩阵的特征多项式必须是 $p(\\lambda) = (\\lambda-0)^4 = \\lambda^4$。可能的若尔当标准型对应于 $4$ 的整数分拆。我们将选择 $4$ 的两种不同分拆，它们恰好产生相同的弗罗贝尼乌斯范数。考虑分拆 $3+1$ 和 $2+2$。\n\n设矩阵 $A$ 是对应于特征值 $\\lambda=0$ 和分拆 $3+1$ 的若尔当标准型。该形式有一个大小为 $3$ 的若尔当块和一个大小为 $1$ 的若尔当块：\n$$ A = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n设矩阵 $B$ 是对应于特征值 $\\lambda=0$ 和分拆 $2+2$ 的若尔当标准型。该形式有两个大小为 $2$ 的若尔当块：\n$$ B = \\begin{pmatrix} 0  1  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  1 \\\\ 0  0  0  0 \\end{pmatrix} $$\n$A$ 和 $B$ 都是实 $4 \\times 4$ 矩阵。我们现在将验证它们是否满足所有要求的条件。\n\n1.  **特征多项式：** 特征多项式定义为 $p(\\lambda) = \\det(M - \\lambda I)$。对于三角矩阵，行列式是其对角线元素的乘积。\n    *   对于矩阵 $A$，$A - \\lambda I$ 是一个上三角矩阵，其对角线元素为 $(-\\lambda, -\\lambda, -\\lambda, -\\lambda)$。因此，其特征多项式为 $p_A(\\lambda) = (-\\lambda)(-\\lambda)(-\\lambda)(-\\lambda) = \\lambda^4$。$A$ 的特征值全部为 $0$。\n    *   对于矩阵 $B$，$B - \\lambda I$ 也是一个上三角矩阵，其对角线元素为 $(-\\lambda, -\\lambda, -\\lambda, -\\lambda)$。因此，其特征多项式为 $p_B(\\lambda) = (-\\lambda)(-\\lambda)(-\\lambda)(-\\lambda) = \\lambda^4$。$B$ 的特征值全部为 $0$。\n    因此，$A$ 和 $B$ 具有相同的特征多项式：$p_A(\\lambda) = p_B(\\lambda) = \\lambda^4$。\n\n2.  **迹：** 矩阵的迹是其对角线元素之和。\n    *   $\\mathrm{trace}(A) = 0 + 0 + 0 + 0 = 0$。\n    *   $\\mathrm{trace}(B) = 0 + 0 + 0 + 0 = 0$。\n    因此，$\\mathrm{trace}(A) = \\mathrm{trace}(B)$。这也与迹是特征值之和这一事实相符。\n\n3.  **行列式：** 三角矩阵的行列式是其对角线元素的乘积。\n    *   $\\det(A) = 0 \\times 0 \\times 0 \\times 0 = 0$。\n    *   $\\det(B) = 0 \\times 0 \\times 0 \\times 0 = 0$。\n    因此，$\\det(A) = \\det(B)$。这也与行列式是特征值之积这一事实相符。\n\n4.  **弗罗贝尼乌斯范数：** 弗罗贝尼乌斯范数定义为 $\\|X\\|_F = \\sqrt{\\sum_{i,j=1}^4 x_{ij}^2}$。\n    *   对于矩阵 $A$，唯一的非零元素是 $A_{12}=1$ 和 $A_{23}=1$。元素平方和为 $1^2 + 1^2 = 2$。\n        $$ \\|A\\|_F = \\sqrt{1^2 + 1^2} = \\sqrt{2} $$\n    *   对于矩阵 $B$，唯一的非零元素是 $B_{12}=1$ 和 $B_{34}=1$。元素平方和为 $1^2 + 1^2 = 2$。\n        $$ \\|B\\|_F = \\sqrt{1^2 + 1^2} = \\sqrt{2} $$\n    因此，$\\|A\\|_F = \\|B\\|_F = \\sqrt{2}$。\n\n5.  **不相似性：** 如果两个矩阵在任何相似不变量上存在差异，那么它们就不相似。一个基本的不变量是最小多项式。矩阵 $M$ 的最小多项式 $m_M(\\lambda)$ 是使得 $m_M(M) = 0$ 的次数最低的首一多项式。相似矩阵必须具有相同的最小多项式。\n    *   对于矩阵 $A$，我们计算它的幂：\n        $$ A^2 = A \\cdot A = \\begin{pmatrix} 0  0  1  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} $$\n        $$ A^3 = A^2 \\cdot A = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} = 0_{4 \\times 4} $$\n        由于 $A^2 \\neq 0$ 且 $A^3 = 0$，所以 $A$ 的最小多项式是 $m_A(\\lambda) = \\lambda^3$。\n    *   对于矩阵 $B$，我们计算它的幂：\n        $$ B^2 = B \\cdot B = \\begin{pmatrix} 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\\\ 0  0  0  0 \\end{pmatrix} = 0_{4 \\times 4} $$\n        由于 $B \\neq 0$ 且 $B^2 = 0$，所以 $B$ 的最小多项式是 $m_B(\\lambda) = \\lambda^2$。\n    *   因为 $m_A(\\lambda) \\neq m_B(\\lambda)$，所以矩阵 $A$ 和 $B$ 不相似。这反映了它们不同的若尔当结构：最小多项式中因子 $(\\lambda - \\lambda_i)$ 的次数对应于特征值 $\\lambda_i$ 的最大若尔当块的大小。对于 $A$，最大的块大小为 $3$，而对于 $B$，最大的块大小为 $2$。\n\n我们成功地构造了满足所有给定条件的两个矩阵 $A$ 和 $B$。这些矩阵的共同弗罗贝尼乌斯范数是 $\\sqrt{2}$。", "answer": "$$\n\\boxed{\\sqrt{2}}\n$$", "id": "3273917"}, {"introduction": "在精确的数学世界里，相似变换完美地保持了矩阵的特征值。然而，我们的计算机使用的是有限精度的浮点运算。[@problem_id:3273831] 这个数值实验将生动地展示，一个理论上无懈可击的相似变换，如果其变换矩阵是“病态的”（ill-conditioned），可能会导致计算出的特征值严重失真。这个练习揭示了数值稳定性这一核心概念在科学计算中的重要性。", "problem": "你需要通过数值方法研究一个使用近奇异的基变换矩阵进行的相似变换，在浮点运算中如何影响计算出的特征值，尽管理论上特征值在相似变换下是不变的。整个过程应完全基于纯粹数学和数值线性代数。从以下基本定义和事实出发，不依赖任何预先推导的快捷公式：如果一个方阵 $A \\in \\mathbb{C}^{n \\times n}$ 通过一个可逆矩阵 $P \\in \\mathbb{C}^{n \\times n}$ 与矩阵 $B \\in \\mathbb{C}^{n \\times n}$ 相似，即 $B = P^{-1} A P$，那么 $A$ 和 $B$ 具有完全相同的特征值多重集。在有限精度算术（例如由电气和电子工程师协会（IEEE）754 标准化的算术）中，算术运算会受到舍入误差的扰动。因此，当你在浮点运算中根据 $A$ 和 $P$ 计算 $B$，然后计算 $A$ 和 $B$ 的特征值时，两个计算出的特征值多重集可能会有所不同。你的任务是针对由一个小标量 $\\varepsilon$ 参数化的一个特定的近奇异矩阵族 $P$，来量化这种偏差。\n\n构造一个固定的矩阵 $A \\in \\mathbb{R}^{4 \\times 4}$，作为首一多项式（其根为 $1,2,3,4$）的友矩阵，即\n$$\nA \\;=\\;\n\\begin{bmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n-24  50  -35  10\n\\end{bmatrix}.\n$$\n理论上，$A$ 的特征值恰好是根 $1,2,3,4$。\n\n对于给定的标量 $\\varepsilon \\in \\mathbb{R}$ 且 $\\varepsilon > 0$，定义对角矩阵\n$$\nP(\\varepsilon) \\;=\\; \\mathrm{diag}(1,\\,1,\\,1,\\,\\varepsilon),\n$$\n该矩阵对于任何正数 $\\varepsilon$ 都是可逆的，并且随着 $\\varepsilon \\to 0^+$ 变得越来越病态。构成相似变换\n$$\nB(\\varepsilon) \\;=\\; P(\\varepsilon)^{-1}\\,A\\,P(\\varepsilon).\n$$\n在精确算术中，$A$ 和 $B(\\varepsilon)$ 是相似的，因此共享相同的特征值多重集。在浮点运算中，计算 $A$ 和 $B(\\varepsilon)$ 的特征值，然后使用以下置换不变度量来测量两个计算出的特征值多重集之间的偏差。设 $\\{\\lambda_i(A)\\}_{i=1}^4$ 是 $A$ 的计算特征值，$\\{\\lambda_i(B(\\varepsilon))\\}_{i=1}^4$ 是 $B(\\varepsilon)$ 的计算特征值。定义\n$$\n\\Delta(\\varepsilon) \\;=\\; \\min_{\\pi \\in S_4}\\;\\max_{1 \\le i \\le 4}\\; \\left|\\, \\lambda_i(A) \\;-\\; \\lambda_{\\pi(i)}(B(\\varepsilon)) \\,\\right|,\n$$\n其中 $S_4$ 是 $\\{1,2,3,4\\}$ 的所有置换的集合，而 $|\\cdot|$ 表示复数的模。该度量以最佳方式对两组特征值多重集进行配对，并报告在该配对下的最大绝对差异。\n\n实现一个程序，该程序：\n- 按给定方式构造 $A$。\n- 对于测试套件中的每个测试值 $\\varepsilon$，构造 $P(\\varepsilon)$，在浮点运算中形成 $B(\\varepsilon)$，使用标准的稠密矩阵算法计算 $A$ 和 $B(\\varepsilon)$ 的特征值，并通过对所有置换 $\\pi \\in S_4$ 进行穷举搜索来精确计算上面定义的 $\\Delta(\\varepsilon)$。\n- 按顺序输出与指定测试套件相对应的列表 $[\\Delta(\\varepsilon_1), \\Delta(\\varepsilon_2), \\ldots]$。\n\n测试套件：\n- 使用 $\\varepsilon$ 值 $1$、$10^{-1}$、$10^{-4}$、$10^{-8}$ 和 $10^{-12}$。\n\n覆盖性设计：\n- $\\varepsilon = 1$ 测试良态的基变换。\n- $\\varepsilon = 10^{-1}$ 测试轻度病态的情况。\n- $\\varepsilon = 10^{-4}$ 和 $\\varepsilon = 10^{-8}$ 测试日益病态的情况。\n- $\\varepsilon = 10^{-12}$ 测试典型双精度动态范围内的强病态边界。\n\n答案规范：\n- 对于测试套件中的每个 $\\varepsilon$，结果是如上定义的实非负标量 $\\Delta(\\varepsilon)$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，“[0.0,1.23,4.56]”）。\n\n不涉及物理单位，因此不需要单位规范。不使用角度。不使用百分比。预期的教育水平是本科高年级，问题侧重于推导相似变换下特征值的不变性，理解为什么浮点运算在计算中会破坏精确的不变性，并用一种有原则的、置换不变的度量来量化偏差。", "solution": "问题陈述被评估为有效。它在科学上基于数值线性代数的原理，问题设定良好，目标明确，包含所有必要信息，并且没有矛盾或含糊之处。任务是研究在使用病态矩阵进行相似变换时特征值的数值稳定性，这是科学计算中的一个标准且重要的课题。\n\n解题过程如下：\n首先，我们将建立相似变换下特征值不变性的理论基础。其次，我们将分析在有限精度浮点运算中，特别是当基变换矩阵是病态时，这种不变性是如何被破坏的。第三，我们将推导变换后矩阵的具体形式。最后，我们将概述计算指定偏差度量 $\\Delta(\\varepsilon)$ 的算法。\n\n如果存在一个可逆矩阵 $P \\in \\mathbb{C}^{n \\times n}$ 使得 $B = P^{-1}AP$，则方阵 $A \\in \\mathbb{C}^{n \\times n}$ 与矩阵 $B \\in \\mathbb{C}^{n \\times n}$ 相似。$A$ 和 $B$ 的特征值分别是它们各自特征多项式 $\\det(A - \\lambda I) = 0$ 和 $\\det(B - \\lambda I) = 0$ 的根。在精确算术中，这些多项式是相同的：\n$$\n\\begin{align*}\n\\det(B - \\lambda I) = \\det(P^{-1}AP - \\lambda I) \\\\\n= \\det(P^{-1}AP - \\lambda P^{-1}P) \\\\\n= \\det(P^{-1}(A - \\lambda I)P) \\\\\n= \\det(P^{-1}) \\det(A - \\lambda I) \\det(P) \\\\\n= \\det(A - \\lambda I)\n\\end{align*}\n$$\n由于特征多项式相同，矩阵 $A$ 和 $B$ 必须具有相同的特征值多重集。\n\n在实践中，计算是使用浮点运算执行的，这会引入舍入误差。当我们计算 $B = P^{-1}AP$ 时，结果是一个矩阵 $\\hat{B}$，它只是真实 $B$ 的一个近似值。如果矩阵 $P$ 是病态的，误差 $\\hat{B} - B$ 可能会很大。矩阵 $P$ 的条件数，记为 $\\kappa(P)$，衡量了线性系统 $Px=b$ 的解对 $b$ 中扰动的敏感程度。一个大的 $\\kappa(P)$ 意味着 $P$ 是“近奇异的”。对于相似变换，一个大的条件数 $\\kappa(P) = \\|P\\| \\|P^{-1}\\|$ 会放大舍入误差对计算出的矩阵 $\\hat{B}$ 的影响。因此，从 $\\hat{B}$ 计算出的特征值可能与 $A$ 的特征值有很大差异。\n\n问题将矩阵 $A$ 指定为根为 $1, 2, 3, 4$ 的多项式的友矩阵：\n$$\nA =\n\\begin{bmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  1 \\\\\n-24  50  -35  10\n\\end{bmatrix}\n$$\n因此，理论上 $A$ 的特征值为 $\\{\\lambda_1, \\lambda_2, \\lambda_3, \\lambda_4\\} = \\{1, 2, 3, 4\\}$。\n\n基变换矩阵由 $P(\\varepsilon) = \\mathrm{diag}(1, 1, 1, \\varepsilon)$ 给出，其中 $\\varepsilon > 0$ 是某个小值。它的逆是 $P(\\varepsilon)^{-1} = \\mathrm{diag}(1, 1, 1, 1/\\varepsilon)$。在无穷范数下，条件数为 $\\kappa_{\\infty}(P(\\varepsilon)) = \\|P(\\varepsilon)\\|_{\\infty} \\|P(\\varepsilon)^{-1}\\|_{\\infty} = 1 \\cdot (1/\\varepsilon) = 1/\\varepsilon$。随着 $\\varepsilon \\to 0^+$，条件数无界增长，表明 $P(\\varepsilon)$ 变得越来越病态。\n\n我们可以显式地计算矩阵 $B(\\varepsilon) = P(\\varepsilon)^{-1} A P(\\varepsilon)$。对于对角矩阵 $P$，该变换等价于逐元素缩放：$(B)_{ij} = (P^{-1})_{ii} A_{ij} (P)_{jj}$。\n设 $P(\\varepsilon) = \\mathrm{diag}(p_1, p_2, p_3, p_4) = \\mathrm{diag}(1, 1, 1, \\varepsilon)$。那么 $B(\\varepsilon)_{ij} = A_{ij} p_j / p_i$。\n将此应用于 $A$ 得到：\n$$\nB(\\varepsilon) =\n\\begin{bmatrix}\nA_{11}\\frac{p_1}{p_1}  A_{12}\\frac{p_2}{p_1}  A_{13}\\frac{p_3}{p_1}  A_{14}\\frac{p_4}{p_1} \\\\\nA_{21}\\frac{p_1}{p_2}  A_{22}\\frac{p_2}{p_2}  A_{23}\\frac{p_3}{p_2}  A_{24}\\frac{p_4}{p_2} \\\\\nA_{31}\\frac{p_1}{p_3}  A_{32}\\frac{p_2}{p_3}  A_{33}\\frac{p_3}{p_3}  A_{34}\\frac{p_4}{p_3} \\\\\nA_{41}\\frac{p_1}{p_4}  A_{42}\\frac{p_2}{p_4}  A_{43}\\frac{p_3}{p_4}  A_{44}\\frac{p_4}{p_4}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0  1  0  0 \\\\\n0  0  1  0 \\\\\n0  0  0  \\varepsilon \\\\\n-24/\\varepsilon  50/\\varepsilon  -35/\\varepsilon  10\n\\end{bmatrix}\n$$\n随着 $\\varepsilon \\to 0^+$，$B(\\varepsilon)$ 最后一行的元素变得非常大。数值特征值算法（如 QR 算法）对具有数量级差异巨大的元素的矩阵很敏感，这可能导致精度损失。\n\n为了量化偏差，我们使用度量 $\\Delta(\\varepsilon) = \\min_{\\pi \\in S_4} \\max_{1 \\le i \\le 4} | \\lambda_i(A) - \\lambda_{\\pi(i)}(B(\\varepsilon)) |$。该度量将两个计算出的特征值多重集 $\\{\\lambda_i(A)\\}$ 和 $\\{\\lambda_i(B(\\varepsilon))\\}$ 之间的距离定义为，在所有可能的配对中，对应特征值之间最大差距的最小值。对于 $n=4$，对称群 $S_4$ 有 $4! = 24$ 个置换，使得穷举搜索在计算上是可行的。\n\n算法如下：\n1.  定义矩阵 $A$。\n2.  使用标准的数值库函数计算 $A$ 的特征值 $\\{\\lambda_i(A)\\}_{i=1}^4$。这些将作为参考集。将它们按固定顺序存储。\n3.  对于测试套件中的每个 $\\varepsilon$ 值：\n    a. 使用推导出的公式构造矩阵 $B(\\varepsilon)$。\n    b. 计算 $B(\\varepsilon)$ 的特征值 $\\{\\lambda_i(B(\\varepsilon))\\}_{i=1}^4$。\n    c. 初始化一个变量 `min_max_diff` 为无穷大。\n    d. 生成索引 $\\{1, 2, 3, 4\\}$ 的所有置换 $\\pi$。\n    e. 对于每个置换 $\\pi$，计算该配对的最大绝对差：$M_{\\pi} = \\max_i |\\lambda_i(A) - \\lambda_{\\pi(i)}(B(\\varepsilon))|$。\n    f. 更新 `min_max_diff = min(min_max_diff,` $M_{\\pi})$。\n    g. 最终的 `min_max_diff` 就是 $\\Delta(\\varepsilon)$ 的值。\n4.  收集所有测试值的计算结果 $\\Delta(\\varepsilon)$，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom itertools import permutations\n\ndef solve():\n    \"\"\"\n    Investigates the effect of a nearly singular similarity transformation\n    on the computed eigenvalues of a matrix.\n    \"\"\"\n    # Define the test suite for epsilon.\n    test_cases = [1.0, 1e-1, 1e-4, 1e-8, 1e-12]\n\n    # Construct the fixed matrix A, which is the companion matrix for a\n    # polynomial with roots 1, 2, 3, 4.\n    A = np.array([\n        [0.0, 1.0, 0.0, 0.0],\n        [0.0, 0.0, 1.0, 0.0],\n        [0.0, 0.0, 0.0, 1.0],\n        [-24.0, 50.0, -35.0, 10.0]\n    ], dtype=np.float64)\n\n    # Compute eigenvalues of A once. These are the reference eigenvalues.\n    # The eigenvalues are complex numbers. We sort them to provide a canonical\n    # ordering for the matching process.\n    eigs_A = np.linalg.eigvals(A)\n    eigs_A.sort() # Sorts in-place, primarily by real part.\n\n    results = []\n    for eps in test_cases:\n        # For each epsilon, construct the matrix B(epsilon).\n        # The formula B = P_inv @ A @ P with P = diag(1,1,1,eps) is used.\n        # This is implemented directly for better numerical stability than\n        # forming P_inv and performing matrix multiplications.\n        B_eps = np.array([\n            [0.0, 1.0, 0.0, 0.0],\n            [0.0, 0.0, 1.0, 0.0],\n            [0.0, 0.0, 0.0, eps],\n            [-24.0/eps, 50.0/eps, -35.0/eps, 10.0]\n        ], dtype=np.float64)\n\n        # Compute eigenvalues of B(epsilon).\n        eigs_B = np.linalg.eigvals(B_eps)\n        \n        # Calculate Delta(epsilon) by exhaustive search over all permutations.\n        # This solves the bottleneck assignment problem for the two sets of eigenvalues.\n        min_max_diff = float('inf')\n        \n        # itertools.permutations generates all possible pairings between the\n        # canonical reference eigenvalues of A and the computed eigenvalues of B.\n        indices = range(len(eigs_A))\n        for p in permutations(indices):\n            # p represents a permutation of the indices of eigs_B.\n            # We pair eigs_A[i] with eigs_B[p[i]].\n            # A more direct way is to permute eigs_B and compute max difference.\n            permuted_eigs_B = eigs_B[list(p)]\n            max_diff = np.max(np.abs(eigs_A - permuted_eigs_B))\n            \n            if max_diff  min_max_diff:\n                min_max_diff = max_diff\n        \n        results.append(min_max_diff)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3273831"}]}