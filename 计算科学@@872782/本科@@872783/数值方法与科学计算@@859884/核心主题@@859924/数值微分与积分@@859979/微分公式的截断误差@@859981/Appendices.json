{"hands_on_practices": [{"introduction": "任何有限差分公式的精度都由其截断误差决定，而泰勒级数展开是分析这种误差的核心工具。本练习将引导你完整地走过推导一个多点单边差分公式截断误差的全过程。通过构建并求解线性方程组来确定公式的系数，你将能够巩固对于如何构造特定精度阶数公式的理解[@problem_id:3284691]。", "problem": "设 $f$ 是一个在包含点 $x$ 的区间上至少有六阶连续导数的函数。考虑一个间距为 $h>0$ 的均匀网格，其节点为 $x_{j}=x+jh$，其中 $j\\in\\{0,1,2,3\\}$。您的任务是构造二阶导数 $f''(x)$ 的一个单边、前向、四点有限差分近似，其形式为\n$$\n\\frac{1}{h^{2}}\\sum_{j=0}^{3} a_{j}\\, f(x+jh),\n$$\n其中系数 $a_{0},a_{1},a_{2},a_{3}$ 是实数，其选择要使该近似与 $f''(x)$ 相容。\n\n仅使用 $f(x+jh)$ 在 $x$ 点的泰勒级数展开和多项式的性质，确定当 $h\\to 0$ 时此近似的局部截断误差的主项。将您的最终答案表示为关于 $h$ 和 $f$ 在 $x$ 点的导数的单个解析表达式（不使用大-$O$ 符号）。您可以假设函数具有所有必要的光滑性，以使所有级数操作均有效。最终答案必须是单个表达式。不需要四舍五入，也不涉及单位。", "solution": "用户要求推导二阶导数 $f''(x)$ 的单边四点有限差分近似的局部截断误差的主项。\n\n首先验证问题，以确保其具有科学依据、良定性和客观性。\n1.  **提取的已知条件**：\n    -   函数 $f$ 至少有六阶连续导数。\n    -   $f''(x)$ 的近似形式为 $D_h f(x) = \\frac{1}{h^{2}}\\sum_{j=0}^{3} a_{j}\\, f(x+jh)$。\n    -   网格点为 $x_{j}=x+jh$，其中 $j \\in \\{0, 1, 2, 3\\}$，间距为 $h>0$。\n    -   选择系数 $a_0, a_1, a_2, a_3$ 以使近似与 $f''(x)$ 相容。\n    -   任务是求出当 $h\\to 0$ 时局部截断误差 $\\tau(x) = D_h f(x) - f''(x)$ 的主项。\n\n2.  **验证**：\n    -   该问题具有科学依据，因为它是基于 Taylor 定理的数值分析中的一个标准练习。\n    -   它是良定的。相容性条件，结合使用四个点，意味着应选择系数以最大化精度阶数，这提供了一组唯一的系数和一个唯一的误差项。\n    -   问题是客观的，并使用精确的数学语言。\n    -   未发现任何缺陷。问题是有效的。\n\n求解过程如下。局部截断误差定义为 $\\tau(x) = D_h f(x) - f''(x)$。\n$$\n\\tau(x) = \\frac{1}{h^2} \\left[ a_0 f(x) + a_1 f(x+h) + a_2 f(x+2h) + a_3 f(x+3h) \\right] - f''(x)\n$$\n为了确定系数 $a_j$ 和误差，我们将每个函数求值 $f(x+jh)$ 在点 $x$ 附近展开为 Taylor 级数。鉴于 $f$ 至少有六阶连续导数，我们可以将展开式写到包含 $f^{(5)}(x)$ 的项，余项为 $O(h^6)$ 阶。\n$$\nf(x) = f(x)\n$$\n$$\nf(x+h) = f(x) + hf'(x) + \\frac{h^2}{2}f''(x) + \\frac{h^3}{6}f'''(x) + \\frac{h^4}{24}f^{(4)}(x) + \\frac{h^5}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x+2h) = f(x) + (2h)f'(x) + \\frac{(2h)^2}{2}f''(x) + \\frac{(2h)^3}{6}f'''(x) + \\frac{(2h)^4}{24}f^{(4)}(x) + \\frac{(2h)^5}{120}f^{(5)}(x) + O(h^6)\n$$\n$$\nf(x+3h) = f(x) + (3h)f'(x) + \\frac{(3h)^2}{2}f''(x) + \\frac{(3h)^3}{6}f'''(x) + \\frac{(3h)^4}{24}f^{(4)}(x) + \\frac{(3h)^5}{120}f^{(5)}(x) + O(h^6)\n$$\n将这些展开式代入 $D_h f(x)$ 的表达式中，并按 $f(x)$ 的导数收集各项：\n\\begin{align*}\nD_h f(x) = \\frac{1}{h^2} \\bigg[ a_0 f(x) + a_1 \\left( f(x) + hf'(x) + \\dots \\right) + a_2 \\left( f(x) + 2hf'(x) + \\dots \\right) + a_3 \\left( f(x) + 3hf'(x) + \\dots \\right) \\bigg] \\\\\n= \\frac{f(x)}{h^2} (a_0 + a_1 + a_2 + a_3) \\\\\n\\quad+ \\frac{f'(x)}{h} (a_1 + 2a_2 + 3a_3) \\\\\n\\quad+ f''(x) \\frac{1}{2!} (a_1 + 4a_2 + 9a_3) \\\\\n\\quad+ h f'''(x) \\frac{1}{3!} (a_1 + 8a_2 + 27a_3) \\\\\n\\quad+ h^2 f^{(4)}(x) \\frac{1}{4!} (a_1 + 16a_2 + 81a_3) \\\\\n\\quad+ h^3 f^{(5)}(x) \\frac{1}{5!} (a_1 + 32a_2 + 243a_3) + O(h^4)\n\\end{align*}\n为了使该表达式成为 $f''(x)$ 的一个相容近似，并具有四点所能达到的最高精度阶数，我们必须选择系数 $a_0, a_1, a_2, a_3$，使得低阶导数的系数与目标 $f''(x)$ 匹配，并且尽可能多的高阶项为零。这导出了以下线性方程组：\n1.  $f(x)$ 的系数： $\\quad a_0 + a_1 + a_2 + a_3 = 0$\n2.  $f'(x)$ 的系数： $\\quad a_1 + 2a_2 + 3a_3 = 0$\n3.  $f''(x)$ 的系数： $\\quad \\frac{1}{2}(a_1 + 4a_2 + 9a_3) = 1 \\implies a_1 + 4a_2 + 9a_3 = 2$\n4.  $f'''(x)$ 的系数： $\\quad \\frac{1}{6}(a_1 + 8a_2 + 27a_3) = 0 \\implies a_1 + 8a_2 + 27a_3 = 0$\n\n我们求解这个包含四个未知系数的四方程组。首先，我们求解关于 $a_1, a_2, a_3$ 的子系统：\n(3) $-$ (2): $(a_1 + 4a_2 + 9a_3) - (a_1 + 2a_2 + 3a_3) = 2 - 0 \\implies 2a_2 + 6a_3 = 2 \\implies a_2 + 3a_3 = 1$ (5)\n(4) $-$ (3): $(a_1 + 8a_2 + 27a_3) - (a_1 + 4a_2 + 9a_3) = 0 - 2 \\implies 4a_2 + 18a_3 = -2 \\implies 2a_2 + 9a_3 = -1$ (6)\n\n现在我们求解由 (5) 和 (6) 组成的方程组。由 (5) 可得 $a_2 = 1 - 3a_3$。将其代入 (6)：\n$2(1 - 3a_3) + 9a_3 = -1 \\implies 2 - 6a_3 + 9a_3 = -1 \\implies 3a_3 = -3 \\implies a_3 = -1$。\n将 $a_3 = -1$ 代回 (5)：$a_2 + 3(-1) = 1 \\implies a_2 = 4$。\n将 $a_2 = 4$ 和 $a_3 = -1$ 代入 (2)：$a_1 + 2(4) + 3(-1) = 0 \\implies a_1 + 8 - 3 = 0 \\implies a_1 = -5$。\n最后，使用 (1) 求 $a_0$：$a_0 + (-5) + 4 + (-1) = 0 \\implies a_0 - 2 = 0 \\implies a_0 = 2$。\n\n这些系数是 $a_0=2$、$a_1=-5$、$a_2=4$ 和 $a_3=-1$。\n使用这些系数，对应于 $f(x), f'(x)$ 和 $f'''(x)$ 的项消失，而 $f''(x)$ 的系数为 $1$。$D_h f(x)$ 的展开式变为：\n$$\nD_h f(x) = f''(x) + h^2 f^{(4)}(x) \\frac{1}{24}(a_1 + 16a_2 + 81a_3) + O(h^3)\n$$\n局部截断误差为 $\\tau(x) = D_h f(x) - f''(x)$。该误差的主项是展开式中的第一个非零项。\n$$\n\\text{主项} = h^2 f^{(4)}(x) \\frac{1}{24} (a_1 + 16a_2 + 81a_3)\n$$\n我们将求得的系数值代入此表达式：\n$$\na_1 + 16a_2 + 81a_3 = (-5) + 16(4) + 81(-1) = -5 + 64 - 81 = 59 - 81 = -22\n$$\n因此，局部截断误差的主项是：\n$$\n\\tau(x) \\approx \\frac{-22}{24} h^2 f^{(4)}(x) = -\\frac{11}{12} h^2 f^{(4)}(x)\n$$\n这就是所要求的截断误差主项的表达式。", "answer": "$$\n\\boxed{-\\frac{11}{12}h^{2}f^{(4)}(x)}\n$$", "id": "3284691"}, {"introduction": "标准的截断误差分析通常假设函数是充分光滑的，即拥有足够多的连续导数。但当这个条件不被满足时，会发生什么呢？本练习通过将中心差分公式应用于一个在原点附近缺乏高阶光滑性的函数，来探讨了这种情况[@problem_id:3284729]。你将发现，公式的理论精度阶会发生退化，并学习如何从第一性原理出发，直接推导其实际误差行为，从而更深刻地理解标准误差公式的应用前提。", "problem": "设 $f(x)=|x|^{\\alpha}$，其中 $\\alpha\\in(1,2)$ 为非整数。考虑使用步长为 $h$ 的中心差分 (Central Difference, CD) 公式，在点 $x=h>0$ 处逼近一阶导数 $f'(x)$，该公式定义为\n$$\nD_{\\text{CD}} f(x;h)=\\frac{f(x+h)-f(x-h)}{2h}.\n$$\n将截断误差定义为\n$$\n\\mathrm{TE}(x;h)=D_{\\text{CD}} f(x;h)-f'(x).\n$$\n仅使用导数的定义和 $f(x)$ 的显式形式，推导当 $h\\to 0^{+}$ 时 $\\mathrm{TE}(h;h)$ 的主阶渐近行为，并确定指数 $p(\\alpha)$，使得\n$$\n\\mathrm{TE}(h;h)=C(\\alpha)\\,h^{p(\\alpha)}+o\\!\\left(h^{p(\\alpha)}\\right)\\quad\\text{当}\\quad h\\to 0^{+},\n$$\n其中 $C(\\alpha)$ 是某个依赖于 $\\alpha$ 的非零常数。你的最终答案必须是 $p(\\alpha)$ 关于 $\\alpha$ 的单一解析表达式。", "solution": "该问题提法恰当，有科学依据，且客观。所有必要信息均已提供，各项术语定义明确。对于 $\\alpha \\in (1,2)$ 的函数 $f(x)=|x|^{\\alpha}$，其在 $x=0$ 处的微分性不足，无法直接应用基于标准 Taylor 级数的中心差分公式误差分析，但这并不使问题无效。相反，它需要一种更基本的方法，而这正是问题要求使用基本定义所引导的方向。该问题是有效的。\n\n问题要求的是当 $h \\to 0^{+}$ 时，截断误差 $\\mathrm{TE}(h;h)$ 的主阶渐近行为。中心差分 (CD) 公式的截断误差定义为：\n$$\n\\mathrm{TE}(x;h) = D_{\\text{CD}} f(x;h) - f'(x)\n$$\n其中 CD 算子由下式给出：\n$$\nD_{\\text{CD}} f(x;h) = \\frac{f(x+h) - f(x-h)}{2h}\n$$\n我们被要求在点 $x=h$ 处，并使用同样等于 $h$ 的步长来计算这个值。将 $x=h$ 代入截断误差的表达式，得到：\n$$\n\\mathrm{TE}(h;h) = D_{\\text{CD}} f(h;h) - f'(h)\n$$\n我们分别计算右侧的每一项。\n\n首先，我们计算 CD 逼近值 $D_{\\text{CD}} f(h;h)$：\n$$\nD_{\\text{CD}} f(h;h) = \\frac{f(h+h) - f(h-h)}{2h} = \\frac{f(2h) - f(0)}{2h}\n$$\n函数给定为 $f(x) = |x|^{\\alpha}$。由于问题规定 $h>0$，则自变量 $2h$ 也为正。因此，$f(2h) = |2h|^{\\alpha} = (2h)^{\\alpha} = 2^{\\alpha}h^{\\alpha}$。\n$x=0$ 处的值为 $f(0) = |0|^{\\alpha} = 0$。这是有定义的，因为 $\\alpha \\in (1,2)$，所以 $\\alpha > 0$。\n将这些值代回 $D_{\\text{CD}} f(h;h)$ 的表达式中：\n$$\nD_{\\text{CD}} f(h;h) = \\frac{2^{\\alpha}h^{\\alpha} - 0}{2h} = \\frac{2^{\\alpha}}{2} \\frac{h^{\\alpha}}{h} = 2^{\\alpha-1}h^{\\alpha-1}\n$$\n\n接下来，我们计算精确导数 $f'(h)$。函数为 $f(x)=|x|^{\\alpha}$。对于任意 $x>0$，我们有 $f(x)=x^{\\alpha}$。其关于 $x$ 的导数为：\n$$\nf'(x) = \\frac{d}{dx}(x^{\\alpha}) = \\alpha x^{\\alpha-1}\n$$\n由于 $h>0$，我们可以在 $x=h$ 处计算导数：\n$$\nf'(h) = \\alpha h^{\\alpha-1}\n$$\n\n现在，我们可以整合出截断误差 $\\mathrm{TE}(h;h)$ 的完整表达式：\n$$\n\\mathrm{TE}(h;h) = D_{\\text{CD}} f(h;h) - f'(h) = 2^{\\alpha-1}h^{\\alpha-1} - \\alpha h^{\\alpha-1}\n$$\n将 $h^{\\alpha-1}$ 项提取出来，我们得到误差的精确表达式：\n$$\n\\mathrm{TE}(h;h) = (2^{\\alpha-1} - \\alpha) h^{\\alpha-1}\n$$\n问题要求渐近形式 $\\mathrm{TE}(h;h) = C(\\alpha)h^{p(\\alpha)} + o(h^{p(\\alpha)})$ (当 $h \\to 0^{+}$ 时) 中的指数 $p(\\alpha)$，其中 $C(\\alpha)$ 是一个非零常数。\n从我们的精确表达式中，我们可以确定：\n$$\nC(\\alpha) = 2^{\\alpha-1} - \\alpha\n$$\n和\n$$\np(\\alpha) = \\alpha-1\n$$\n为了确认这是主阶项，我们必须验证 $C(\\alpha)$ 在指定的定义域 $\\alpha \\in (1,2)$ 上非零。我们来分析函数 $g(\\alpha) = 2^{\\alpha-1} - \\alpha$。\n我们在区间 $[1,2]$ 的端点处计算 $g(\\alpha)$ 的值：\n$g(1) = 2^{1-1} - 1 = 2^0 - 1 = 1 - 1 = 0$。\n$g(2) = 2^{2-1} - 2 = 2^1 - 2 = 2 - 2 = 0$。\n为了确定 $g(\\alpha)$ 在 $\\alpha \\in (1,2)$ 上的行为，我们考察它的导数。一阶导数是：\n$$\ng'(\\alpha) = \\frac{d}{d\\alpha}(2^{\\alpha-1} - \\alpha) = \\ln(2) \\cdot 2^{\\alpha-1} - 1\n$$\n二阶导数是：\n$$\ng''(\\alpha) = \\frac{d}{d\\alpha}(\\ln(2) \\cdot 2^{\\alpha-1} - 1) = (\\ln(2))^2 \\cdot 2^{\\alpha-1}\n$$\n由于对于 $\\alpha \\in (1,2)$，$\\ln(2) > 0$ 且 $2^{\\alpha-1} > 0$，我们有 $g''(\\alpha) > 0$。这意味着 $g(\\alpha)$ 在区间 $(1,2)$ 上是一个严格凸函数。一个在区间端点处为零的严格凸函数，在该区间内的所有点上必为负值。因此，对于所有的 $\\alpha \\in (1,2)$，$g(\\alpha)  0$。\n这证实了 $C(\\alpha) = g(\\alpha)$ 在指定的 $\\alpha$ 范围内是非零的。\n\n因此，表达式 $\\mathrm{TE}(h;h) = (2^{\\alpha-1} - \\alpha) h^{\\alpha-1}$ 正确地表示了主阶行为，且指数 $p(\\alpha)$ 为 $\\alpha-1$。注意，对于 $\\alpha \\in (1,2)$，精度阶数 $p(\\alpha)=\\alpha-1$ 介于 $0$ 和 $1$ 之间。这比中心差分公式的标准 $O(h^2)$ 精度要低，其原因是其中一个采样点 $x-h=0$ 与函数高阶导数奇异的一个点重合。\n\n所求的量是指数 $p(\\alpha)$。\n$$\np(\\alpha) = \\alpha-1\n$$", "answer": "$$\\boxed{\\alpha-1}$$", "id": "3284729"}, {"introduction": "在数值计算的真实世界里，截断误差并非唯一的误差来源，由有限精度算术引起的舍入误差同样至关重要。总误差是这两个相互竞争因素的综合体现。这个实践将理论带入现实世界，让你通过数值实验来研究截断误差与浮点舍入误差之间的相互作用[@problem_id:3284592]。你将亲自探索当步长 $h$ 变化时这两种误差如何相互竞争，并经验性地找到最小化总误差的最佳步长 $h_{opt}$，并通过比较不同浮点精度下的结果，直观地理解计算精度对数值微分结果的深刻影响。", "problem": "考虑截断误差和舍入误差之间的相互作用。截断误差产生于用有限差分代替极限，而舍入误差产生于有限精度的浮点运算。使用泰勒级数展开作为基本依据来推导一致的数值微分公式，并使用浮点舍入误差的标准模型，即一个由机器ε限定的乘性扰动。具体来说，将实数上基本算术运算的舍入建模为 $$\\operatorname{fl}(a \\,\\circ\\, b) = (a \\,\\circ\\, b)(1 + \\delta), \\quad |\\delta| \\le \\varepsilon,$$ 其中 $\\circ$ 表示 $+$、$-$、$\\times$ 或 $\\div$，$\\varepsilon$ 是工作格式的机器ε。请勿引入超出此模型的特定误差项。\n\n您的任务是数值上演示，在 binary64 (双精度) 和 binary32 (单精度) 算术之间切换时，使得近似 $f'(x_0)$ 的总绝对误差最小化的最优步长 $h$ 是如何变化的。使用两种由泰勒展开构造的微分公式：\n- 一个一阶精度的单边差分公式，\n- 一个二阶精度的对称差分公式。\n\n对于每种公式，截断误差是由被忽略的高阶泰勒项决定的 $h$ 的代数函数，而舍入误差则因为相近数相减和除以 $h$ 放大了浮点扰动而增长。您必须：\n1. 从泰勒级数推导这两种微分公式，并仅基于此证明其主截断误差项的阶数。\n2. 使用舍入模型解释为什么当 $h$ 减小时，舍入误差的贡献会增加。\n3. 设计并实现一个数值实验，对两种公式和两种精度，扫描一个对数间隔的 $h$ 值网格，以经验性地找到最小化绝对误差 $|D_h f(x_0) - f'(x_0)|$ 的 $h$ 值，其中 $D_h f(x_0)$ 是在指定精度下计算的所选有限差分近似。\n\n您必须通过控制每个实验中所有算术运算的数据类型来使用 Institute of Electrical and Electronics Engineers (IEEE) binary64 (双精度) 和 binary32 (单精度) 算术。以匹配的精度计算 $f$，并将数值导数与高精度的精确导数进行比较以构成绝对误差。三角函数的角度必须以弧度为单位。\n\n测试套件：\n- 测试用例1 (正常路径，平滑指数函数)：$f(x) = e^x$，$f'(x) = e^x$，$x_0 = 1$，使用一阶单边差分公式。\n- 测试用例2 (正常路径，平滑指数函数)：$f(x) = e^x$，$f'(x) = e^x$，$x_0 = 1$，使用二阶对称差分公式。\n- 测试用例3 (三角函数，非零曲率；角度以弧度为单位)：$f(x) = \\sin(x)$，$f'(x) = \\cos(x)$，$x_0 = \\pi/4$，使用一阶单边差分公式。\n- 测试用例4 (三角函数，非零曲率；角度以弧度为单位)：$f(x) = \\sin(x)$，$f'(x) = \\cos(x)$，$x_0 = \\pi/4$，使用二阶对称差分公式。\n\n$h$ 的扫描范围必须是对数间隔的，并选择以包围每种精度和公式的最优 $h$：\n- 对于 binary64 和一阶公式：$h \\in [10^{-16}, 10^{-1}]$。\n- 对于 binary32 和一阶公式：$h \\in [10^{-8}, 10^{-1}]$。\n- 对于 binary64 和二阶公式：$h \\in [10^{-12}, 10^{-1}]$。\n- 对于 binary32 和二阶公式：$h \\in [10^{-7}, 10^{-1}]$。\n在每个范围内至少使用 $300$ 个网格点。\n\n您的程序必须为每个测试用例计算：\n- binary64 中的经验最优步长，$h_{\\text{opt,64}}$，\n- binary32 中的经验最优步长，$h_{\\text{opt,32}}$，\n- 移位因子 $h_{\\text{opt,32}} / h_{\\text{opt,64}}$，\n- binary64 中的最小绝对误差，$E_{\\min,64}$，\n- binary32 中的最小绝对误差，$E_{\\min,32}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，该列表包含四个条目 (每个测试用例一个)，每个条目是按 $[h_{\\text{opt,64}}, h_{\\text{opt,32}}, h_{\\text{opt,32}}/h_{\\text{opt,64}}, E_{\\min,64}, E_{\\min,32}]$ 顺序排列的五个浮点数列表。整个输出必须用方括号括起来。例如：\"[[h64_case1,h32_case1,ratio1,E64_case1,E32_case1],[h64_case2,h32_case2,ratio2,E64_case2,E32_case2],[h64_case3,h32_case3,ratio3,E64_case3,E32_case3],[h64_case4,h32_case4,ratio4,E64_case4,E32_case4]]\"。", "solution": "该问题要求对有限差分近似中的最优步长进行理论推导和数值演示，同时考虑不同浮点精度下截断误差和舍入误差之间的权衡。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n\n*   **浮点误差模型**：$\\operatorname{fl}(a \\circ b) = (a \\circ b)(1 + \\delta)$，其中 $|\\delta| \\le \\varepsilon$ (机器ε)。\n*   **精度**：IEEE binary64 (双精度) 和 IEEE binary32 (单精度)。\n*   **微分公式**：\n    1.  一个一阶精度的单边差分公式。\n    2.  一个二阶精度的对称差分公式。\n*   **数值任务**：对于每个公式和精度，通过扫描对数间隔的 $h$ 值网格，找到使绝对误差 $|D_h f(x_0) - f'(x_0)|$ 最小化的步长 $h$。\n*   **测试用例**：\n    1.  $f(x) = e^x$，$f'(x) = e^x$，$x_0 = 1$，一阶公式。\n    2.  $f(x) = e^x$，$f'(x) = e^x$，$x_0 = 1$，二阶公式。\n    3.  $f(x) = \\sin(x)$，$f'(x) = \\cos(x)$，$x_0 = \\pi/4$，一阶公式。\n    4.  $f(x) = \\sin(x)$，$f'(x) = \\cos(x)$，$x_0 = \\pi/4$，二阶公式。\n*   **$h$ 的扫描范围 ($300+$ 个点)**：\n    *   binary64，一阶：$h \\in [10^{-16}, 10^{-1}]$\n    *   binary32，一阶：$h \\in [10^{-8}, 10^{-1}]$\n    *   binary64，二阶：$h \\in [10^{-12}, 10^{-1}]$\n    *   binary32，二阶：$h \\in [10^{-7}, 10^{-1}]$\n*   **每个测试用例的所需输出**：$h_{\\text{opt,64}}$、$h_{\\text{opt,32}}$、$h_{\\text{opt,32}} / h_{\\text{opt,64}}$、$E_{\\min,64}}$、$E_{\\min,32}}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学依据**：该问题是数值分析中的一个经典练习。它正确地将泰勒级数确定为截断误差的基础，并将标准乘性模型用于舍入误差。灾难性抵消、机器ε以及误差源之间的权衡等概念是科学计算的基础。\n*   **适定性**：该问题是适定的。函数是无限可微的，确保了泰勒级数展开的存在。目标明确定义：在指定域上找到误差函数的最小值。预计会有一个唯一的最小值，因为总误差函数是 $h$ 的一个单调递增函数 (截断误差) 和一个单调递减函数 (舍入误差) 的和。\n*   **客观性**：该问题以精确、客观的数学术语陈述。所有参数、函数和所需的计算都已明确定义。\n\n**步骤3：结论与行动**\n\n该问题是有效的。它是一个定义明确、科学上合理的数值方法问题。我将继续进行解答。\n\n**理论分析**\n\n数值微分公式中的总误差是两个分量的和：截断误差，这是近似公式的内在误差；以及舍入误差，它源于计算机算术的有限精度。\n\n**1. 公式推导与截断误差**\n\n我们使用一个足够光滑的函数 $f(x)$ 在点 $x_0$ 附近的泰勒级数展开。\n$$f(x_0 + h) = f(x_0) + f'(x_0)h + \\frac{f''(x_0)}{2!}h^2 + \\frac{f'''(x_0)}{3!}h^3 + \\dots$$\n\n**一阶单边公式 (向前差分)：**\n为了推导这个公式，我们重新整理 $f(x_0 + h)$ 的泰勒展开式以求解 $f'(x_0)$：\n$$f'(x_0) = \\frac{f(x_0 + h) - f(x_0)}{h} - \\frac{f''(x_0)}{2}h - O(h^2)$$\n向前差分近似定义为：\n$$D_{h,1}f(x_0) = \\frac{f(x_0 + h) - f(x_0)}{h}$$\n因此，截断误差 $E_{\\text{trunc},1} = f'(x_0) - D_{h,1}f(x_0)$ 为：\n$$E_{\\text{trunc},1} = - \\frac{f''(x_0)}{2}h - O(h^2)$$\n主误差项与 $h$ 成正比，因此该公式为一阶精度。绝对截断误差约为 $|E_{\\text{trunc},1}| \\approx C_1 h$，其中 $C_1 = |f''(x_0)|/2$。\n\n**二阶对称公式 (中心差分)：**\n对于这个公式，我们使用两个泰勒展开式：\n$$f(x_0 + h) = f(x_0) + f'(x_0)h + \\frac{f''(x_0)}{2}h^2 + \\frac{f'''(x_0)}{6}h^3 + O(h^4)$$\n$$f(x_0 - h) = f(x_0) - f'(x_0)h + \\frac{f''(x_0)}{2}h^2 - \\frac{f'''(x_0)}{6}h^3 + O(h^4)$$\n从第一个方程中减去第二个方程，消去了 $h$ 的偶次幂项：\n$$f(x_0 + h) - f(x_0 - h) = 2f'(x_0)h + \\frac{f'''(x_0)}{3}h^3 + O(h^5)$$\n求解 $f'(x_0)$ 得：\n$$f'(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h} - \\frac{f'''(x_0)}{6}h^2 - O(h^4)$$\n中心差分近似为：\n$$D_{h,2}f(x_0) = \\frac{f(x_0 + h) - f(x_0 - h)}{2h}$$\n截断误差 $E_{\\text{trunc},2} = f'(x_0) - D_{h,2}f(x_0)$ 为：\n$$E_{\\text{trunc},2} = - \\frac{f'''(x_0)}{6}h^2 - O(h^4)$$\n主误差项与 $h^2$ 成正比，使得该公式为二阶精度。绝对截断误差约为 $|E_{\\text{trunc},2}| \\approx C_2 h^2$，其中 $C_2 = |f'''(x_0)|/6$。\n\n**2. 舍入误差分析**\n\n舍入误差源于用有限精度表示实数。当我们计算 $f(x)$ 时，我们得到一个浮点数 $\\operatorname{fl}(f(x)) \\approx f(x)(1+\\delta)$，其中 $|\\delta| \\le \\varepsilon$。因此，函数求值的误差由 $\\varepsilon |f(x)|$ 界定。\n\n我们来分析向前差分公式 $D_{h,1}f(x_0)$ 的舍入误差。分子涉及到两个量的相减，当 $h \\to 0$ 时，这两个量变得非常接近。设 $\\hat{f_0} = \\operatorname{fl}(f(x_0)) \\approx f(x_0) + e_0$ 且 $\\hat{f_1} = \\operatorname{fl}(f(x_0+h)) \\approx f(x_0+h) + e_1$，其中对于小的 $h$，误差 $|e_0|$ 和 $|e_1|$ 大约由 $\\varepsilon|f(x_0)|$ 界定。\n\n计算出的差值是 $\\operatorname{fl}(\\hat{f_1} - \\hat{f_0})$。这次减法的绝对误差大约由 $|e_1| + |e_0| \\approx 2\\varepsilon|f(x_0)|$ 界定。这种结果的相对误差远大于输入的相对误差的现象，被称为灾难性抵消。\n\n该公式随后需要除以 $h$。最终结果中的舍入误差 $E_{\\text{round}}$ 主要受此效应影响：\n$$|E_{\\text{round},1}| \\approx \\frac{2\\varepsilon|f(x_0)|}{h}$$\n对于中心差分公式，类似的分析表明：\n$$|E_{\\text{round},2}| \\approx \\frac{2\\varepsilon|f(x_0)|}{2h} = \\frac{\\varepsilon|f(x_0)|}{h}$$\n在两种情况下，舍入误差的贡献 $|E_{\\text{round}}|$ 都与 $1/h$ 成正比。因此，随着 $h$ 的减小，舍入误差会增加。\n\n**3. 总误差与最优步长**\n\n总绝对误差 $|E_{\\text{total}}|$ 是截断误差和舍入误差大小之和。\n\n对于一阶公式：\n$$|E_{\\text{total},1}(h)| \\approx \\frac{|f''(x_0)|}{2}h + \\frac{2\\varepsilon|f(x_0)|}{h}$$\n为了找到最小化此误差的最优 $h$，我们对 $h$ 求导并令结果为零：\n$$\\frac{d}{dh}|E_{\\text{total},1}(h)| = \\frac{|f''(x_0)|}{2} - \\frac{2\\varepsilon|f(x_0)|}{h^2} = 0$$\n$$h_{\\text{opt},1}^2 = \\frac{4\\varepsilon|f(x_0)|}{|f''(x_0)|} \\implies h_{\\text{opt},1} \\propto \\sqrt{\\varepsilon}$$\n\n对于二阶公式：\n$$|E_{\\text{total},2}(h)| \\approx \\frac{|f'''(x_0)|}{6}h^2 + \\frac{\\varepsilon|f(x_0)|}{h}$$\n求导并令其为零：\n$$\\frac{d}{dh}|E_{\\text{total},2}(h)| = \\frac{|f'''(x_0)|}{3}h - \\frac{\\varepsilon|f(x_0)|}{h^2} = 0$$\n$$h_{\\text{opt},2}^3 = \\frac{3\\varepsilon|f(x_0)|}{|f'''(x_0)|} \\implies h_{\\text{opt},2} \\propto \\sqrt[3]{\\varepsilon}$$\n\n该分析预测最优步长 $h_{\\text{opt}}$ 取决于机器ε。具体来说，当从 binary64 ($\\varepsilon_{64}$) 切换到 binary32 ($\\varepsilon_{32}$) 时，对于一阶公式，最优步长应移动一个因子 $\\sqrt{\\varepsilon_{32}/\\varepsilon_{64}}$；对于二阶公式，应移动一个因子 $\\sqrt[3]{\\varepsilon_{32}/\\varepsilon_{64}}$。数值实验旨在验证这一理论预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical differentiation problem by finding optimal step sizes\n    for different precisions and formulas.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda x: np.exp(x),\n            \"df_exact_func\": lambda x: np.exp(x),\n            \"x0\": 1.0,\n            \"formula\": \"forward\",\n            \"h_range_64\": (-16, -1),\n            \"h_range_32\": (-8, -1),\n        },\n        {\n            \"f\": lambda x: np.exp(x),\n            \"df_exact_func\": lambda x: np.exp(x),\n            \"x0\": 1.0,\n            \"formula\": \"central\",\n            \"h_range_64\": (-12, -1),\n            \"h_range_32\": (-7, -1),\n        },\n        {\n            \"f\": lambda x: np.sin(x),\n            \"df_exact_func\": lambda x: np.cos(x),\n            \"x0\": np.pi / 4,\n            \"formula\": \"forward\",\n            \"h_range_64\": (-16, -1),\n            \"h_range_32\": (-8, -1),\n        },\n        {\n            \"f\": lambda x: np.sin(x),\n            \"df_exact_func\": lambda x: np.cos(x),\n            \"x0\": np.pi / 4,\n            \"formula\": \"central\",\n            \"h_range_64\": (-12, -1),\n            \"h_range_32\": (-7, -1),\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Calculate the exact derivative once in high precision for reference.\n        df_exact_val = case[\"df_exact_func\"](case[\"x0\"])\n\n        # Run experiment for binary64 (double precision)\n        h_opt64, E_min64 = find_optimal_h(\n            f=case[\"f\"],\n            x0=case[\"x0\"],\n            df_exact_val=df_exact_val,\n            formula=case[\"formula\"],\n            dtype=np.float64,\n            h_range_log=case[\"h_range_64\"]\n        )\n\n        # Run experiment for binary32 (single precision)\n        h_opt32, E_min32 = find_optimal_h(\n            f=case[\"f\"],\n            x0=case[\"x0\"],\n            df_exact_val=df_exact_val,\n            formula=case[\"formula\"],\n            dtype=np.float32,\n            h_range_log=case[\"h_range_32\"]\n        )\n        \n        shift_factor = h_opt32 / h_opt64\n        \n        results.append([h_opt64, h_opt32, shift_factor, E_min64, E_min32])\n\n    # Final print statement in the exact required format.\n    # The format string ensures list representation within the main list.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef find_optimal_h(f, x0, df_exact_val, formula, dtype, h_range_log):\n    \"\"\"\n    Finds the optimal step size h by scanning a log-spaced grid.\n\n    Args:\n        f (callable): The function to differentiate.\n        x0 (float): The point at which to differentiate.\n        df_exact_val (float): The exact value of the derivative for error calculation.\n        formula (str): 'forward' or 'central'.\n        dtype (numpy.dtype): The floating point precision (np.float64 or np.float32).\n        h_range_log (tuple): A tuple (log10_start, log10_end) for the h grid.\n\n    Returns:\n        tuple: A tuple containing the optimal h and the minimum error.\n    \"\"\"\n    num_points = 300\n    h_vals = np.logspace(h_range_log[0], h_range_log[1], num_points)\n    x0_prec = dtype(x0)\n    \n    errors = np.zeros(num_points)\n\n    for i, h in enumerate(h_vals):\n        h_prec = dtype(h)\n        numerical_derivative = dtype(0.0)\n\n        if formula == 'forward':\n            # One-sided (forward) difference formula\n            # D_h f(x) = (f(x+h) - f(x)) / h\n            # Operations are performed in the specified precision `dtype`\n            # because inputs (x0_prec, h_prec) have that type.\n            f_x0_plus_h = f(x0_prec + h_prec)\n            f_x0 = f(x0_prec)\n            numerical_derivative = (f_x0_plus_h - f_x0) / h_prec\n        \n        elif formula == 'central':\n            # Symmetric (central) difference formula\n            # D_h f(x) = (f(x+h) - f(x-h)) / (2h)\n            f_x0_plus_h = f(x0_prec + h_prec)\n            f_x0_minus_h = f(x0_prec - h_prec)\n            two_h = dtype(2.0) * h_prec\n            numerical_derivative = (f_x0_plus_h - f_x0_minus_h) / two_h\n\n        # The absolute error is calculated against the high-precision reference value.\n        # numpy will automatically promote the lower precision `numerical_derivative`\n        # to match the higher precision `df_exact_val` for subtraction.\n        errors[i] = np.abs(numerical_derivative - df_exact_val)\n\n    min_error_idx = np.argmin(errors)\n    optimal_h = h_vals[min_error_idx]\n    min_error = errors[min_error_idx]\n    \n    return optimal_h, min_error\n\nsolve()\n```", "id": "3284592"}]}