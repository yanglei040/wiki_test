{"hands_on_practices": [{"introduction": "理论分析告诉我们，对于足够光滑的函数，复合梯形法则的误差收敛阶为 $O(h^2)$，而复合辛普森法则的误差收敛阶为 $O(h^4)$。本实践旨在通过数值实验来经验性地验证这一核心理论。通过对一个表现良好的函数（如 $f(x)=e^x$）进行积分，并分析误差如何随步长 $h$ 减小而变化，你将学习如何通过对数-对数坐标图上的线性回归来估计收敛阶和误差常数，从而在理论与计算实践之间建立一座桥梁。[@problem_id:3224834]", "problem": "考虑区间 $[0,1]$ 上的函数 $f(x)=e^x$。令 $I=\\int_{0}^{1} f(x)\\,dx$ 表示其精确积分。对于具有 $n$ 个子区间的均匀剖分，步长为 $h=(1-0)/n$，我们通过其在节点 $x_k=0+kh$（其中 $k=0,1,\\dots,n$）上的标准求和定义，来定义复化梯形法则近似值 $T_n$ 和复化辛普森法则近似值 $S_n$：\n- 复化梯形法则：\n$$\nT_n = h\\left(\\frac{f(0)}{2} + \\sum_{k=1}^{n-1} f(x_k) + \\frac{f(1)}{2}\\right).\n$$\n- 复化辛普森法则（要求 $n$ 为偶数）：\n$$\nS_n = \\frac{h}{3}\\left(f(0) + f(1) + 4\\sum_{k=1,\\,k\\text{ odd}}^{n-1} f(x_k) + 2\\sum_{k=2,\\,k\\text{ even}}^{n-2} f(x_k)\\right).\n$$\n\n从数值积分的基本定义以及函数 $f(x)=e^x$ 的光滑性出发，当 $h$ 足够小时，每个复化法则的全局误差 $E(h)$ 作为 $h$ 的函数表现出渐近幂律行为 $E(h)\\approx C\\,h^p$，其中 $p$ 是收敛阶，而 $C$ 是一个依赖于函数 $f$ 和所用规则的非零常数。可以使用 $f$ 在 $[0,1]$ 上的适当阶导数的上确界来建立全局误差的理论上界，具体来说，复化梯形法则使用 $\\sup_{x\\in[0,1]}|f''(x)|$，复化辛普森法则使用 $\\sup_{x\\in[0,1]}|f^{(4)}(x)|$。\n\n您的程序必须：\n1. 根据指数函数的定义和微积分基本定理，精确计算 $I$。\n2. 对于下面测试套件中每个指定的 $n$ 值列表，计算 $T_n$ 和 $S_n$（辛普森法则仅适用于偶数 $n$）、它们的绝对全局误差 $|I-T_n|$ 和 $|I-S_n|$，以及步长 $h=1/n$。\n3. 对于每个法则和每个 $n$ 值列表，对数据对 $\\left(\\log(h),\\log(|E(h)|)\\right)$ 使用自然对数进行线性回归，以估计最佳拟合直线的斜率 $p$ 和截距 $\\log(C)$，从而获得 $p$ 和 $C=e^{\\text{截距}}$ 的经验估计值。\n4. 计算理论导数上确界 $\\sup_{x\\in[0,1]}|f''(x)|$ 和 $\\sup_{x\\in[0,1]}|f^{(4)}(x)|$，并使用包含这些上确界的标准全局误差上界形式，对每个列表中的每个 $n$，检查相应法则的绝对全局误差是否小于或等于其界限。报告一个布尔值，指示列表中所有 $n$ 的两个法则的界限是否同时成立。\n\n测试套件：\n- 情况 A（常规路径）：$n\\in\\{4,8,16,32,64\\}$。\n- 情况 B（中等粗糙）：$n\\in\\{2,4,6,8,10,12\\}$。\n- 情况 C（细密网格）：$n\\in\\{128,256,512,1024\\}$。\n\n最终输出规格：\n- 对于每种情况，生成一个列表 $[p_T, C_T, p_S, C_S, \\text{bound\\_ok}]$，其中 $p_T$ 和 $C_T$ 是复化梯形法则的经验斜率和常数，$p_S$ 和 $C_S$ 是复化辛普森法则的经验斜率和常数，而 $\\text{bound\\_ok}$ 是一个布尔值，当且仅当在该情况下所有 $n$ 的 $|I-T_n|$ 和 $|I-S_n|$ 都小于或等于它们各自从 $\\sup_{x\\in[0,1]}|f''(x)|$ 和 $\\sup_{x\\in[0,1]}|f^{(4)}(x)|$ 推导出的理论上界时，该值为真。\n- 您的程序应生成单行输出，其中包含三个情况的结果，形式为方括号括起来的逗号分隔列表，例如：\n$$\n[\\,[p_T^{(A)},C_T^{(A)},p_S^{(A)},C_S^{(A)},\\text{bound\\_ok}^{(A)}],\\,[p_T^{(B)},C_T^{(B)},p_S^{(B)},C_S^{(B)},\\text{bound\\_ok}^{(B)}],\\,[p_T^{(C)},C_T^{(C)},p_S^{(C)},C_S^{(C)},\\text{bound\\_ok}^{(C)}]\\,].\n$$\n所有数值结果必须在此聚合列表中以原始浮点数和布尔值的形式报告。此问题不涉及物理单位或角度单位。", "solution": "该问题要求分析在区间 $[0,1]$ 上对函数 $f(x) = e^x$ 使用复化梯形法则和辛普森数值积分法则的收敛性质。此分析涉及计算数值近似值及其误差，将它们与理论界限进行比较，并经验性地估计收敛阶。\n\n首先，我们确定积分的精确值。待积函数为 $f(x) = e^x$，积分区间为 $[0,1]$。积分的精确值（记为 $I$）使用微积分基本定理计算：\n$$\nI = \\int_{0}^{1} e^x \\,dx = \\left[e^x\\right]_{0}^{1} = e^1 - e^0 = e - 1\n$$\n该值将作为比较数值近似值 $T_n$ 和 $S_n$ 的基准。\n\n接下来，我们建立理论误差界。复化梯形法则和辛普森法则的标准误差界公式依赖于函数 $f(x)$ 在积分区间上某些阶导数幅值的上确界。积分区间为 $[a,b]=[0,1]$，步长为 $h=(b-a)/n = 1/n$。\n\n对于复化梯形法则，误差界涉及二阶导数。\n$f(x)=e^x$ 的导数为 $f'(x)=e^x$，$f''(x)=e^x$，依此类推。所有阶导数均为 $e^x$。\n函数 $e^x$ 在 $[0,1]$ 上是正且单调递增的。因此，其导数在该区间上的上确界在 $x=1$ 处取得。\n$$\nM_2 = \\sup_{x\\in[0,1]}|f''(x)| = \\sup_{x\\in[0,1]}|e^x| = e^1 = e\n$$\n复化梯形法则的理论误差界为：\n$$\n|I - T_n| \\le \\frac{(b-a)h^2}{12} M_2 = \\frac{1 \\cdot (1/n)^2}{12} e = \\frac{e}{12n^2}\n$$\n对于复化辛普森法则，误差界涉及四阶导数。\n$$\nM_4 = \\sup_{x\\in[0,1]}|f^{(4)}(x)| = \\sup_{x\\in[0,1]}|e^x| = e^1 = e\n$$\n复化辛普森法则（对于偶数 $n$）的理论误差界为：\n$$\n|I - S_n| \\le \\frac{(b-a)h^4}{180} M_4 = \\frac{1 \\cdot (1/n)^4}{180} e = \\frac{e}{180n^4}\n$$\n程序必须对每个测试用例中的每个 $n$ 值进行验证，检查计算出的绝对误差 $|I-T_n|$ 和 $|I-S_n|$ 是否小于或等于它们各自的理论界限。\n\n该问题还要求从渐近关系 $|E(h)| \\approx C h^p$ 中经验性地估计收敛阶 $p$ 和误差常数 $C$，其中 $E(h)$ 是给定步长 $h$ 的全局误差。对两边取自然对数，得到一个线性关系：\n$$\n\\ln(|E(h)|) \\approx \\ln(C) + p \\ln(h)\n$$\n该方程形如 $y = m x + c$，其中 $y = \\ln(|E(h)|)$，$x = \\ln(h)$，斜率为 $m=p$，y轴截距为 $c=\\ln(C)$。通过计算一系列步长 $h_i=1/n_i$ 的误差，我们可以生成一组数据点 $(\\ln(h_i), \\ln(|E(h_i)|))$。对这些点进行简单的线性回归，可以得到斜率 $p$ 和截距 $\\ln(C)$ 的估计值，由此可以求出 $C = e^{\\ln(C)}$。该过程对梯形法则和辛普森法则分别执行。\n\n每个测试用例的计算过程如下：\n1. 定义精确积分 $I=e-1$ 和导数上确界 $M_2=e$ 及 $M_4=e$。初始化一个布尔标志 `bound_ok` 为 true。\n2. 对于给定列表中的每个子区间数 $n$：\n    a. 计算步长 $h=1/n$。\n    b. 生成节点 $x_k = kh$（其中 $k=0, 1, \\dots, n$）并计算 $y_k = f(x_k)$。\n    c. 使用其求和公式计算梯形近似值 $T_n$。\n    d. 计算绝对误差 $|E_{T_n}| = |I-T_n|$ 和理论误差界 $B_{T_n} = e h^2 / 12$。如果 $|E_{T_n}| > B_{T_n}$，则将 `bound_ok` 设置为 false。\n    e. 如果 $n$ 是偶数，计算辛普森近似值 $S_n$、其误差 $|E_{S_n}|=|I-S_n|$ 及其界限 $B_{S_n} = e h^4 / 180$。如果 $|E_{S_n}| > B_{S_n}$，则将 `bound_ok` 设置为 false。\n    f. 存储 $h$、 $|E_{T_n}|$ 以及（如果适用）$|E_{S_n}|$ 以用于回归分析。\n3. 对收集到的梯形法则的自然对数-对数数据进行线性回归，以找到其经验参数 $p_T$ 和 $C_T$。\n4. 对收集到的辛普森法则的自然对数-对数数据进行线性回归，以找到其经验参数 $p_S$ 和 $C_S$。\n5. 将结果合并到列表 $[p_T, C_T, p_S, C_S, \\text{bound\\_ok}]$ 中。\n对三个指定的测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical integration error analysis problem for three test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        [4, 8, 16, 32, 64],        # Case A\n        [2, 4, 6, 8, 10, 12],      # Case B\n        [128, 256, 512, 1024],      # Case C\n    ]\n\n    # The function to integrate f(x) = e^x\n    f = lambda x: np.exp(x)\n    \n    # Exact value of the integral over [0, 1]\n    I_exact = np.e - 1.0\n\n    # Supremum of derivatives on [0, 1] for error bounds\n    # f''(x) = e^x, sup|f''(x)| = e^1 = e\n    # f^(4)(x) = e^x, sup|f^(4)(x)| = e^1 = e\n    M2 = np.e\n    M4 = np.e\n\n    interval_a = 0.0\n    interval_b = 1.0\n\n    all_results = []\n\n    for n_values in test_cases:\n        h_T_vals, errors_T = [], []\n        h_S_vals, errors_S = [], []\n        bounds_hold = True\n\n        for n in n_values:\n            h = (interval_b - interval_a) / n\n            x_nodes = np.linspace(interval_a, interval_b, n + 1)\n            y_values = f(x_nodes)\n\n            # Composite Trapezoidal Rule\n            T_n = h * (np.sum(y_values[1:-1]) + (y_values[0] + y_values[-1]) / 2.0)\n            error_T = np.abs(I_exact - T_n)\n            \n            # Theoretical bound for Trapezoidal Rule\n            bound_T = M2 * h**2 / 12.0\n            if error_T > bound_T:\n                bounds_hold = False\n            \n            h_T_vals.append(h)\n            errors_T.append(error_T)\n\n            # Composite Simpson's Rule (for even n)\n            if n % 2 == 0:\n                # S_n = h/3 * (f(x_0) + f(x_n) + 4*sum(odd terms) + 2*sum(even terms))\n                # Odd terms indices: 1, 3, ..., n-1\n                # Even terms indices: 2, 4, ..., n-2\n                odd_sum = np.sum(y_values[1:n:2])\n                even_sum = np.sum(y_values[2:n-1:2])\n                S_n = (h / 3.0) * (y_values[0] + y_values[-1] + 4.0 * odd_sum + 2.0 * even_sum)\n                error_S = np.abs(I_exact - S_n)\n                \n                # Theoretical bound for Simpson's Rule\n                bound_S = M4 * h**4 / 180.0\n                if error_S > bound_S:\n                    bounds_hold = False\n                \n                h_S_vals.append(h)\n                errors_S.append(error_S)\n        \n        # Perform linear regression on log-log data\n        # For Trapezoidal Rule\n        log_h_T = np.log(np.array(h_T_vals))\n        log_err_T = np.log(np.array(errors_T))\n        p_T, log_C_T = np.polyfit(log_h_T, log_err_T, 1)\n        C_T = np.exp(log_C_T)\n\n        # For Simpson's Rule\n        log_h_S = np.log(np.array(h_S_vals))\n        log_err_S = np.log(np.array(errors_S))\n        p_S, log_C_S = np.polyfit(log_h_S, log_err_S, 1)\n        C_S = np.exp(log_C_S)\n        \n        case_result = [p_T, C_T, p_S, C_S, bounds_hold]\n        all_results.append(case_result)\n\n\n    # Final print statement in the exact required format.\n    # We convert the list of lists to its string representation and remove spaces for compactness.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3224834"}, {"introduction": "辛普森法则的收敛阶更高，通常意味着在相同的分割数下它会比梯形法则更精确。然而，这个结论并非无条件成立。本练习将挑战这一普遍认知，要求你设计一个特定的函数，使得在相同的函数求值点上，阶数较低的梯形法则反而比辛普森法则给出了更准确的结果。通过构建这样一个反例，你将深刻理解数值方法背后的基本假设（即函数在局部能被低阶多项式很好地近似），并揭示当函数频率与网格采样率不匹配时可能出现的“混叠”现象。[@problem_id:3284359]", "problem": "考虑在一个固定预算（即 9 次函数求值）下，对区间 $[0,1]$ 上的一个光滑函数进行数值积分。求值点为均匀间隔的节点 $x_j = j/8$，其中 $j = 0,1,\\dots,8$。对于此节点集，可以通过用多项式对 $f(x)$ 进行局域插值，然后对这些插值多项式进行积分来构造复合求积公式，以近似定积分 $\\int_{0}^{1} f(x)\\,dx$。两种广泛使用的此类法则是基于均匀网格上的线性插值（复合梯形法则）和二次插值（复合辛普森法则）。\n\n请严格从数值求积的这些核心定义（即在均匀节点上构建的插值型公式）出发，且不使用任何预先给定的误差常数或闭式误差公式，设计一个在 $[0,1]$ 上具体的、连续可微的函数 $f(x)$，使得当两种法则在节点 $\\{x_j\\}_{j=0}^{8}$ 上使用相同的 9 次函数求值时，复合梯形法则对 $\\int_{0}^{1} f(x)\\,dx$ 的近似结果比复合辛普森法则更精确。\n\n你的答案必须是 $f(x)$ 的一个显式解析表达式，并且你必须在推理中证明，对于这个 $f(x)$ 和指定的节点，复合梯形法则严格地比复合辛普森法则更接近真实积分值。无需四舍五入，也不涉及单位；请在推理中提供精确值。", "solution": "目标是找到一个在 $[0,1]$ 上连续可微的函数 $f(x)$，使得在给定的 9 点均匀网格下，复合梯形法则对 $I = \\int_0^1 f(x) dx$ 的近似比复合辛普森法则更精确。网格间距为 $h = (1-0)/8 = 1/8$，节点为 $x_j = j/8$，其中 $j \\in \\{0, 1, \\dots, 8\\}$。\n\n我们必须证明 $|I - T|  |I - S|$。在不使用预先给定的误差公式的情况下，解决问题的途径是提出一个合适的候选函数，然后显式计算真实积分 $I$ 和两种近似值 $T$ 和 $S$，以验证该不等式。\n\n一个关键的洞见是，这些法则的精度与它们所依赖的多项式插值函数捕捉原函数行为的优劣程度有关。辛普森法则在宽度为 $2h$ 的区间上使用分段二次插值，而梯形法则在宽度为 $h$ 的区间上使用分段线性插值。如果一个函数的行为在给定的节点间距下难以被二次插值捕捉，但能被线性插值很好地近似，那么它就是一个有希望的候选者。高度振荡的函数可以表现出这种特性。\n\n让我们提出函数 $f(x) = \\cos(8\\pi x)$。该函数在 $[0,1]$ 上是连续可微的（实际上是 $C^\\infty$）。\n\n首先，我们在指定节点 $x_j = j/8$ 上计算函数值：\n$$f(x_j) = f\\left(\\frac{j}{8}\\right) = \\cos\\left(8\\pi \\frac{j}{8}\\right) = \\cos(j\\pi) = (-1)^j$$\n函数值序列 $\\{f_j\\}_{j=0}^8$ 是：\n$$f_0=1, f_1=-1, f_2=1, f_3=-1, f_4=1, f_5=-1, f_6=1, f_7=-1, f_8=1$$\n\n接下来，我们计算积分的精确值 $I$：\n$$I = \\int_{0}^{1} \\cos(8\\pi x) \\,dx = \\left[ \\frac{\\sin(8\\pi x)}{8\\pi} \\right]_{0}^{1} = \\frac{\\sin(8\\pi) - \\sin(0)}{8\\pi} = \\frac{0-0}{8\\pi} = 0$$\n\n现在，我们使用复合梯形法则计算近似值 $T$。该法则定义为：\n$$T = h \\left( \\frac{f_0 + f_8}{2} + \\sum_{j=1}^{7} f_j \\right)$$\n使用 $h=1/8$ 和节点值：\n$$ T = \\frac{1}{8} \\left( \\frac{1 + 1}{2} + \\sum_{j=1}^{7} (-1)^j \\right) = \\frac{1}{8} \\left( 1 + (-1+1-1+1-1+1-1) \\right) $$\n$$ T = \\frac{1}{8} \\left( 1 + (-1) \\right) = 0 $$\n\n接下来，我们使用复合辛普森法则计算近似值 $S$。对于 $N=8$ 个子区间（偶数），该法则为：\n$$S = \\frac{h}{3} \\left( f_0 + 4f_1 + 2f_2 + 4f_3 + 2f_4 + 4f_5 + 2f_6 + 4f_7 + f_8 \\right)$$\n使用我们的节点值：\n$$S = \\frac{1/8}{3} \\left( 1 + 4(-1) + 2(1) + 4(-1) + 2(1) + 4(-1) + 2(1) + 4(-1) + 1 \\right)$$\n$$S = \\frac{1}{24} \\left( 1 - 4 + 2 - 4 + 2 - 4 + 2 - 4 + 1 \\right)$$\n$$S = \\frac{1}{24} \\left( (1+2+2+2+1) + (4 \\times (-4)) \\right) = \\frac{1}{24} (8 - 16) = -\\frac{8}{24} = -\\frac{1}{3}$$\n\n最后，我们比较绝对误差。\n梯形法则的绝对误差为：\n$$|E_T| = |I - T| = |0 - 0| = 0$$\n辛普森法则的绝对误差为：\n$$|E_S| = |I - S| = \\left|0 - \\left(-\\frac{1}{3}\\right)\\right| = \\left|\\frac{1}{3}\\right| = \\frac{1}{3}$$\n比较两个绝对误差，我们发现：\n$$0  \\frac{1}{3}$$\n因此， $|E_T|  |E_S|$。\n\n函数 $f(x)=\\cos(8\\pi x)$ 是连续可微的，并且对于给定的节点，复合梯形法则完全精确，而复合辛普森法则产生了显著的误差。这表明在这种特定情况下，梯形法则比辛普森法则更精确，满足了问题的所有条件。这种情况的发生是因为函数的频率恰好是网格的奈奎斯特频率 $1/(2h)$。梯形法则是精确的，因为每个子区间上的误差项 $\\int_{x_j}^{x_{j+1}} (f(x) - L_j(x))dx$ 由于余弦函数在每个子区间内的对称性而恰好为零。然而，辛普森法则是为多项式设计的，并且相对于其三点采样区间，函数的振荡性质会严重误导该法则，从而导致较大的误差。", "answer": "$$\\boxed{\\cos(8\\pi x)}$$", "id": "3284359"}, {"introduction": "我们已经看到，辛普森法则在处理光滑函数时表现出色，而梯形法则在面对非光滑或急剧变化的函数时可能更为稳健。本实践将引导你综合这些认识，设计一种更智能的混合积分方案。你将创建一个算法，它能通过一个局部“光滑度检测器”自动诊断函数的行为，并在光滑区域应用高精度的辛普森法则，在检测到“尖点”或剧烈振荡的区域则自动切换到更稳健的梯形法则。这个练习让你从一个数值方法的使用者转变为设计者，体验如何构建一个能够适应不同函数特性的实用计算工具。[@problem_id:3215316]", "problem": "您需要设计并实现一个在闭区间 $\\left[a,b\\right]$ 上的混合数值积分方案，该方案能在局部平滑区域自适应地选择复合辛普森法则，在检测到的剧烈变化附近选择复合梯形法则。目标是从第一性原理出发：从定积分作为黎曼和极限的定义开始，将辛普森法则解释为二次插值函数在局部分区间上的精确积分，将梯形法则解释为线性插值函数在单个子区间上的精确积分，然后将这些元素与一个基于有限差分的、有原理依据的光滑度检测器相结合。\n\n您的混合方案必须满足以下设计要求。\n\n- 首先，将 $\\left[a,b\\right]$ 均匀划分为 $N$ 个宽度为 $h = \\dfrac{b-a}{N}$ 的子区间，节点为 $x_i = a + i h$，其中 $i=0,1,\\dots,N$，$N$ 是一个偶数。令 $f_i = f(x_i)$ 表示函数 $f$ 在节点上的采样值。\n- 对于每组相邻的三个节点 $\\left(x_i,x_{i+1},x_{i+2}\\right)$，定义一个无量纲曲率指标\n$$\n\\kappa_i \\;=\\; \\frac{\\left|\\, f_i - 2 f_{i+1} + f_{i+2}\\,\\right|}{\\max\\!\\left(1,\\; \\left|f_i\\right| + \\left|f_{i+1}\\right| + \\left|f_{i+2}\\right|\\right)} \\, .\n$$\n直观上，分子是一个缩放后的二阶有限差分，对于某个在 $\\left[x_i,x_{i+2}\\right]$ 区间内的 $\\xi$，该值与 $h^2 f''(\\xi)$ 成正比；而分母通过一个局部振幅尺度进行归一化，使得 $\\kappa_i$ 成为无量纲量，并且对于不同的函数和量级都具有鲁棒性。\n- 在每对连续子区间 $\\left[x_i,x_{i+2}\\right]$ 上（其中 $i=0,2,4,\\dots,N-2$），按如下方式决定局部求积法则：\n    - 如果 $\\kappa_i \\le \\tau$（其中 $\\tau > 0$ 是一个给定的阈值），则通过对经过点 $\\left(x_i,f_i\\right)$、$\\left(x_{i+1},f_{i+1}\\right)$ 和 $\\left(x_{i+2},f_{i+2}\\right)$ 的二次插值函数进行积分来近似 $\\int_{x_i}^{x_{i+2}} f(x)\\,dx$。\n    - 否则，通过将在 $\\left[x_i,x_{i+1}\\right]$ 和 $\\left[x_{i+1},x_{i+2}\\right]$ 上的线性插值函数的积分求和来近似 $\\int_{x_i}^{x_{i+2}} f(x)\\,dx$。\n- 在 $\\left[a,b\\right]$ 上的完整混合积分是所有子区间对 $\\left[x_i,x_{i+2}\\right]$ 上所选局部近似值的总和。\n- 为了进行比较，还需在相同的网格上计算：\n    - 在每个偶数 $i$ 的区间对 $\\left[x_i,x_{i+2}\\right]$ 上都使用二次插值函数的复合辛普森法则近似值。\n    - 在每个子区间 $\\left[x_i,x_{i+1}\\right]$ 上都使用线性插值函数的复合梯形法则近似值。\n\n角度单位要求：当出现三角函数时，角度必须以弧度为单位进行解释。\n\n您的程序必须实现这个混合方案，并在以下测试套件上进行评估。在每种情况下，计算三个近似值：混合积分、复合辛普森积分和复合梯形积分。然后计算每个近似值相对于精确积分的绝对误差。下面给出的所有输入值都是精确的，必须按原样使用。\n\n测试套件：\n- 情况 A（平滑的指数变化）：$f(x) = e^{x}$ 于 $\\left[a,b\\right] = \\left[0,1\\right]$，其中 $N = 200$ 且 $\\tau = 0.010$。精确积分：$\\int_{0}^{1} e^{x}\\,dx = e - 1$。\n- 情况 B（非光滑扭折）：$f(x) = \\left|x\\right|$ 于 $\\left[a,b\\right] = \\left[-1,1\\right]$，其中 $N = 200$ 且 $\\tau = 0.005$。精确积分：$\\int_{-1}^{1} \\left|x\\right|\\,dx = 1$。\n- 情况 C（快速振荡；角度单位为弧度）：$f(x) = \\sin\\!\\left(50 x\\right)$ 于 $\\left[a,b\\right] = \\left[0,2\\pi\\right]$，其中 $N = 2000$ 且 $\\tau = 0.020$。精确积分：$\\int_{0}^{2\\pi} \\sin\\!\\left(50 x\\right)\\,dx = 0$。\n- 情况 D（端点奇异导数）：$f(x) = \\sqrt{x}$ 于 $\\left[a,b\\right] = \\left[0,1\\right]$，其中 $N = 200$ 且 $\\tau = 0.010$。精确积分：$\\int_{0}^{1} \\sqrt{x}\\,dx = \\dfrac{2}{3}$。\n- 情况 E（有理衰减）：$f(x) = \\dfrac{1}{1+x^{2}}$ 于 $\\left[a,b\\right] = \\left[-5,5\\right]$，其中 $N = 400$ 且 $\\tau = 0.010$。精确积分：$\\int_{-5}^{5} \\dfrac{1}{1+x^{2}}\\,dx = 2 \\arctan(5)$。\n- 情况 F（边界尺寸划分；角度单位为弧度）：$f(x) = \\cos(x)$ 于 $\\left[a,b\\right] = \\left[0,\\pi\\right]$，其中 $N = 2$ 且 $\\tau = 0.010$。精确积分：$\\int_{0}^{\\pi} \\cos(x)\\,dx = 0$。\n\n最终输出格式要求：\n- 对于每个情况，按以下顺序生成一个包含六个浮点数的列表：$\\left[I_{\\text{hybrid}}, I_{\\text{Simpson}}, I_{\\text{trapezoid}}, E_{\\text{hybrid}}, E_{\\text{Simpson}}, E_{\\text{trapezoid}}\\right]$，其中 $E_{\\cdot}$ 表示相对于精确积分的绝对误差。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个情况的六元组本身也是一个用方括号括起来的、以逗号分隔的列表。例如：$[\\,[\\cdots],\\,[\\cdots],\\,[\\cdots]\\,]$。\n- 为保证数值可复现性，每个浮点数应打印为恰好保留 $10$ 位小数的格式。", "solution": "我们从区间 $\\left[a,b\\right]$ 上函数 $f$ 的黎曼积分开始，它被定义为当划分的网格尺寸趋于零时黎曼和的极限。在一个包含 $N$ 个子区间的均匀网格上，令 $h = \\dfrac{b-a}{N}$，节点为 $x_i = a + i h$，$i=0,1,\\dots,N$。对 $\\int_{a}^{b} f(x)\\,dx$ 进行数值近似，相当于用一些我们可以精确积分的、更简单的局部替代函数来替换 $f$。\n\n梯形法则是通过在局部用通过端点值 $x_i$ 和 $x_{i+1}$ 的唯一线性插值函数 $\\ell(x)$ 来近似 $f$ 而得到的。由于 $\\ell(x)$ 是线性的，其在 $\\left[x_i,x_{i+1}\\right]$ 上的积分恰好为\n$$\n\\int_{x_i}^{x_{i+1}} \\ell(x)\\,dx \\;=\\; \\frac{h}{2}\\Big(f(x_i) + f(x_{i+1})\\Big),\n$$\n因此复合梯形法则是将此结果在所有子区间上求和：\n$$\nI_{\\text{trap}} \\;=\\; \\sum_{i=0}^{N-1} \\frac{h}{2}\\Big(f_i + f_{i+1}\\Big).\n$$\n通过在 $x_i$ 附近进行泰勒展开，并考虑到 $x_{i+1} = x_i + h$，可以证明单个子区间上的局部截断误差与 $- \\dfrac{h^3}{12} f''(\\xi_i)$ 成正比（其中某个 $\\xi_i \\in \\left[x_i,x_{i+1}\\right]$），这导致对于足够光滑的函数 $f$，全局误差为 $\\mathcal{O}(h^2)$ 阶。\n\n辛普森法则是通过在子区间对 $\\left[x_i,x_{i+2}\\right]$ 上，用通过三个点 $\\left(x_i,f_i\\right)$、$\\left(x_{i+1},f_{i+1}\\right)$ 和 $\\left(x_{i+2},f_{i+2}\\right)$ 的唯一二次插值函数 $q(x)$ 来近似 $f$ 得到的。使用拉格朗日插值多项式或直接构造 $q(x)$ 并积分，可以推导出 $q$ 在 $\\left[x_i,x_{i+2}\\right]$ 上的精确积分为：\n$$\n\\int_{x_i}^{x_{i+2}} q(x)\\,dx \\;=\\; \\frac{h}{3}\\,\\Big(f_i + 4 f_{i+1} + f_{i+2}\\Big).\n$$\n对偶数索引 $i=0,2,\\dots,N-2$ 求和，便得到复合辛普森法则\n$$\nI_{\\text{simp}} \\;=\\; \\sum_{\\substack{i=0 \\\\ i\\text{ even}}}^{N-2} \\frac{h}{3}\\,\\Big(f_i + 4 f_{i+1} + f_{i+2}\\Big).\n$$\n泰勒级数分析表明，辛普森法则的局部误差与 $-\\dfrac{h^5}{90} f^{(4)}(\\xi_i)$ 成正比（其中某个 $\\xi_i \\in \\left[x_i,x_{i+2}\\right]$），这导致对于具有连续四阶导数的足够光滑的函数 $f$，全局误差为 $\\mathcal{O}(h^4)$ 阶。\n\n在不可微点或剧烈变化附近，二次插值可能变得不可靠：更高阶的公式是以局部光滑性为前提的。为了在这些替代函数之间自适应地选择，我们使用二阶有限差分设计一个光滑度指标。在均匀网格上，中心二阶有限差分\n$$\n\\Delta^2 f_{i+1} \\;=\\; f_i - 2 f_{i+1} + f_{i+2}\n$$\n满足 $\\Delta^2 f_{i+1} \\approx h^{2} f''(\\xi_i)$（对于某个 $\\xi_i \\in \\left[x_i,x_{i+2}\\right]$），前提是函数足够光滑。其大小反映了局部曲率。为了使这个检测无量纲化，并且对于不同振幅的函数都具有尺度鲁棒性，我们通过一个局部振幅尺度进行归一化，得到\n$$\n\\kappa_i \\;=\\; \\frac{\\left|\\, f_i - 2 f_{i+1} + f_{i+2}\\,\\right|}{\\max\\!\\left(1,\\; \\left|f_i\\right| + \\left|f_{i+1}\\right| + \\left|f_{i+2}\\right|\\right)}.\n$$\n当 $f$ 在 $\\left[x_i,x_{i+2}\\right]$ 上局部近似线性或平缓弯曲时，我们预期 $\\kappa_i$ 会很小（因为 $\\Delta^2 f_{i+1} = \\mathcal{O}(h^2)$ 且分母至少为 $\\mathcal{O}(1)$）。相反，在尖点、急剧曲率或快速变化附近，$\\kappa_i$ 将会相对较大。我们选择一个用户指定的阈值 $\\tau > 0$，并对每对区间 $\\left[x_i,x_{i+2}\\right]$（其中 $i$ 为偶数）应用以下规则：\n- 如果 $\\kappa_i \\le \\tau$，我们在 $\\left[x_i,x_{i+2}\\right]$ 上使用辛普森二次替代。\n- 如果 $\\kappa_i > \\tau$，我们回退到在 $\\left[x_i,x_{i+1}\\right]$ 和 $\\left[x_{i+1},x_{i+2}\\right]$ 上使用两个梯形法则的总和，这对应于对线性替代函数进行积分，它们在不可微性附近更为鲁棒。\n\n这就得到了混合近似\n$$ I_{\\text{hyb}} \\;=\\; \\sum_{\\substack{i=0 \\\\ i\\text{ even}}}^{N-2} \\begin{cases} \\dfrac{h}{3}\\,\\Big(f_i + 4 f_{i+1} + f_{i+2}\\Big),  \\text{if } \\kappa_i \\le \\tau \\\\ \\dfrac{h}{2}\\,\\Big(f_i + 2 f_{i+1} + f_{i+2}\\Big),  \\text{if } \\kappa_i > \\tau \\end{cases} $$\n其中，该区间对上的梯形贡献是两个子区间梯形积分之和：\n$$\n\\frac{h}{2}\\Big(f_i + f_{i+1}\\Big) + \\frac{h}{2}\\Big(f_{i+1} + f_{i+2}\\Big) \\;=\\; \\frac{h}{2}\\,\\Big(f_i + 2 f_{i+1} + f_{i+2}\\Big).\n$$\n\n算法设计：\n- 输入：一个函数句柄 $f$、端点 $a$ 和 $b$、一个偶数 $N$ 以及阈值 $\\tau$。\n- 计算 $h = \\dfrac{b-a}{N}$ 并采样 $f_i = f(a + i h)$。\n- 初始化 $I_{\\text{hyb}}$、$I_{\\text{simp}}$ 和 $I_{\\text{trap}}$ 的和。\n- 对于 $i=0,2,\\dots,N-2$：\n    - 根据 $\\left(f_i,f_{i+1},f_{i+2}\\right)$ 计算 $\\kappa_i$。\n    - 如果 $\\kappa_i \\le \\tau$，则将辛普森法则对的贡献加到 $I_{\\text{hyb}}$；否则，将两个梯形法则的贡献相加。\n    - 不论 $\\kappa_i$ 的值如何，都将辛普森法则对的贡献加到 $I_{\\text{simp}}$。\n- 单独地，通过对所有 $i=0,1,\\dots,N-1$ 的单个子区间上的梯形积分求和来计算 $I_{\\text{trap}}$。\n- 对于每个测试函数，使用基本原函数计算精确积分 $I_{\\text{exact}}$：\n    - 对于 $f(x) = e^{x}$ 在 $\\left[0,1\\right]$ 上：$I_{\\text{exact}} = e - 1$。\n    - 对于 $f(x) = \\left|x\\right|$ 在 $\\left[-1,1\\right]$ 上：根据对称性，$I_{\\text{exact}} = 1$。\n    - 对于 $f(x) = \\sin\\!\\left(50 x\\right)$ 在 $\\left[0,2\\pi\\right]$ 上：在完整周期数上的积分为 $0$（角度单位为弧度），因此 $I_{\\text{exact}} = 0$。\n    - 对于 $f(x) = \\sqrt{x}$ 在 $\\left[0,1\\right]$ 上：原函数为 $\\dfrac{2}{3} x^{3/2}$，因此 $I_{\\text{exact}} = \\dfrac{2}{3}$。\n    - 对于 $f(x) = \\dfrac{1}{1+x^{2}}$ 在 $\\left[-5,5\\right]$ 上：原函数为 $\\arctan(x)$，得出 $I_{\\text{exact}} = \\arctan(5) - \\arctan(-5) = 2 \\arctan(5)$。\n    - 对于 $f(x) = \\cos(x)$ 在 $\\left[0,\\pi\\right]$ 上：原函数为 $\\sin(x)$，得出 $I_{\\text{exact}} = 0$。\n- 计算绝对误差 $E_{\\text{hyb}} = \\left|I_{\\text{hyb}} - I_{\\text{exact}}\\right|$，并类似地计算辛普森和梯形法则的误差。\n\n复杂度和行为：\n- 该算法的复杂度为 $\\mathcal{O}(N)$，需要对样本进行单次遍历，且每个子区间或子区间对的工作量为常数。\n- 在光滑区域，当 $f^{(4)}$有界且相对于局部振幅较小时，$\\kappa_i$ 倾向于很小，因此辛普森法则（全局精度为 $\\mathcal{O}(h^4)$）占主导地位。\n- 在尖点、拐角或陡峭的局部过渡附近，$\\kappa_i$ 倾向于超过阈值，触发梯形法则回退，这对于缺乏足够光滑度以致二次插值不可靠的函数更为鲁棒。\n- 阈值 $\\tau$ 在对曲率的敏感度与假阳性之间取得平衡；因为 $\\kappa_i$ 是无量纲的，并且包含了通过局部振幅的归一化，所以同一个 $\\tau$ 可以用于多种不同的函数。\n\n对于每个测试用例，输出必须列出三个近似值及其绝对误差，四舍五入到恰好10位小数，并汇总成单行，格式为由方括号括起来的、以逗号分隔的六元组列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef composite_trapezoid(f_vals, a, b, N):\n    h = (b - a) / N\n    # Using pre-computed values\n    s = h * (np.sum(f_vals[1:-1]) + (f_vals[0] + f_vals[-1]) / 2.0)\n    return s\n\ndef composite_simpson(f_vals, a, b, N):\n    # N must be even\n    h = (b - a) / N\n    # S_n = h/3 * (f(x_0) + f(x_n) + 4*sum(odd terms) + 2*sum(even terms))\n    odd_sum = np.sum(f_vals[1:N:2])\n    even_sum = np.sum(f_vals[2:N:2])\n    s = (h / 3.0) * (f_vals[0] + f_vals[-1] + 4.0 * odd_sum + 2.0 * even_sum)\n    return s\n\ndef hybrid_simpson_trapezoid(f_vals, a, b, N, tau):\n    # N must be even\n    h = (b - a) / N\n    s = 0.0\n    for i in range(0, N, 2):\n        f0 = f_vals[i]\n        f1 = f_vals[i + 1]\n        f2 = f_vals[i + 2]\n        denom = max(1.0, abs(f0) + abs(f1) + abs(f2))\n        kappa = abs(f0 - 2.0 * f1 + f2) / denom\n        if kappa = tau:\n            s += (h / 3.0) * (f0 + 4.0 * f1 + f2)\n        else:\n            s += 0.5 * h * (f0 + 2.0 * f1 + f2)\n    return s\n\ndef format_number(x):\n    # Round and format to exactly 10 decimal places without scientific notation\n    return f\"{x:.10f}\"\n\ndef format_results_no_spaces(results):\n    # results is a list of lists of floats\n    inner_strings = []\n    for res in results:\n        nums = \",\".join(format_number(v) for v in res)\n        inner_strings.append(f\"[{nums}]\")\n    return \"[\" + \",\".join(inner_strings) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: function f, a, b, N (even), tau, exact integral exact_val\n    test_cases = [\n        # Case A: f(x) = exp(x), [0,1], N=200, tau=0.010, exact = e - 1\n        (lambda x: float(np.exp(x)), 0.0, 1.0, 200, 0.010, float(np.e - 1.0)),\n        # Case B: f(x) = |x|, [-1,1], N=200, tau=0.005, exact = 1\n        (lambda x: abs(x), -1.0, 1.0, 200, 0.005, 1.0),\n        # Case C: f(x) = sin(50 x) radians, [0, 2*pi], N=2000, tau=0.020, exact = 0\n        (lambda x: float(np.sin(50.0 * x)), 0.0, float(2.0 * np.pi), 2000, 0.020, 0.0),\n        # Case D: f(x) = sqrt(x), [0,1], N=200, tau=0.010, exact = 2/3\n        (lambda x: float(np.sqrt(x)) if x >= 0 else 0, 0.0, 1.0, 200, 0.010, 2.0 / 3.0),\n        # Case E: f(x) = 1/(1+x^2), [-5,5], N=400, tau=0.010, exact = 2*atan(5)\n        (lambda x: 1.0 / (1.0 + x * x), -5.0, 5.0, 400, 0.010, float(2.0 * np.arctan(5.0))),\n        # Case F: f(x) = cos(x), [0,pi], N=2, tau=0.010, exact = 0\n        (lambda x: float(np.cos(x)), 0.0, float(np.pi), 2, 0.010, 0.0),\n    ]\n\n    results = []\n    for f, a, b, N, tau, exact_val in test_cases:\n        # Precompute function values\n        xs = np.linspace(a, b, N + 1)\n        f_vals = np.array([f(x) for x in xs], dtype=float)\n        \n        # Hybrid\n        I_hyb = hybrid_simpson_trapezoid(f_vals, a, b, N, tau)\n        # Simpson\n        I_simp = composite_simpson(f_vals, a, b, N)\n        # Trapezoid\n        I_trap = composite_trapezoid(f_vals, a, b, N)\n        # Errors\n        E_hyb = abs(I_hyb - exact_val)\n        E_simp = abs(I_simp - exact_val)\n        E_trap = abs(I_trap - exact_val)\n        results.append([I_hyb, I_simp, I_trap, E_hyb, E_simp, E_trap])\n\n    # Final print statement in the exact required format: one line, bracketed, comma-separated, no spaces,\n    # each number printed to exactly 10 decimal places.\n    print(format_results_no_spaces(results))\n\nsolve()\n```", "id": "3215316"}]}