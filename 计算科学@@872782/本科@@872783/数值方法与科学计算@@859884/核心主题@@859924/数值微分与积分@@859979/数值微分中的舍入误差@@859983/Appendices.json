{"hands_on_practices": [{"introduction": "在数值微分中，核心挑战在于截断误差（源于数学近似）与舍入误差（源于有限精度计算）之间的权衡。本练习将通过对这两种误差进行建模，并利用微积分工具寻找总误差最小时的“最佳点”，即最优步长 $h$，为我们奠定理论基础。这个练习对于理解问题的本质至关重要。[@problem_id:2167887]", "problem": "在数值分析领域，一个基本的挑战是平衡（由数学近似引起的）截断误差和（由有限精度硬件引起的）舍入误差。考虑使用中心差分公式计算函数 $f(x) = \\sin(x)$ 在任意点 $x=a$ 处的导数。\n\n总误差 $E_{total}(h)$ 作为步长 $h$ 的函数，被建模为这两种误差大小之和。\n对于中心差分法，截断误差的大小由以下表达式给出：\n$$|E_{trunc}(h)| = \\frac{h^2}{6} |f'''(a)|$$\n由浮点运算的限制导致的舍入误差的大小被建模为：\n$$|E_{round}(h)| = \\frac{\\epsilon}{h}$$\n此处，$\\epsilon$ 是一个小的正常数，表示单次函数求值绝对误差的上界。\n\n因此，总误差可近似为 $E_{total}(h) = |E_{trunc}(h)| + |E_{round}(h)|$。你的任务是找到使该总误差最小化的最优步长 $h_{opt}$。\n\n请以参数 $a$ 和 $\\epsilon$ 的形式，提供一个闭式解析表达式作为你的答案。你可以假设 $\\cos(a) \\neq 0$。", "solution": "给定函数 $f(x) = \\sin(x)$ 和中心差分总误差模型\n$$E_{total}(h) = |E_{trunc}(h)| + |E_{round}(h)| = \\frac{h^{2}}{6}\\,|f'''(a)| + \\frac{\\epsilon}{h}.$$\n对于 $f(x) = \\sin(x)$，其三阶导数为 $f'''(x) = -\\cos(x)$，因此 $|f'''(a)| = |\\cos(a)|$。所以，\n$$E_{total}(h) = \\frac{h^{2}}{6}\\,|\\cos(a)| + \\frac{\\epsilon}{h}, \\quad h0.$$\n为找到使误差最小化的步长，我们对 $h$ 求导并将导数设为零：\n$$\\frac{dE_{total}}{dh} = \\frac{2h}{6}\\,|\\cos(a)| - \\frac{\\epsilon}{h^{2}} = \\frac{h}{3}\\,|\\cos(a)| - \\frac{\\epsilon}{h^{2}}.$$\n令 $\\frac{dE_{total}}{dh}=0$ 可得\n$$\\frac{h}{3}\\,|\\cos(a)| = \\frac{\\epsilon}{h^{2}} \\quad \\Longrightarrow \\quad \\frac{|\\cos(a)|}{3}\\,h^{3} = \\epsilon \\quad \\Longrightarrow \\quad h^{3} = \\frac{3\\epsilon}{|\\cos(a)|}.$$\n因此，\n$$h_{opt} = \\left(\\frac{3\\epsilon}{|\\cos(a)|}\\right)^{\\frac{1}{3}}.$$\n为验证这是一个最小值点，我们计算二阶导数：\n$$\\frac{d^{2}E_{total}}{dh^{2}} = \\frac{1}{3}\\,|\\cos(a)| + \\frac{2\\epsilon}{h^{3}},$$\n对于 $h0$，该二阶导数严格为正，这确认了该临界点是一个极小值点。因此，最优步长为\n$$h_{opt} = \\left(\\frac{3\\epsilon}{|\\cos(a)|}\\right)^{\\frac{1}{3}}.$$", "answer": "$$\\boxed{\\left(\\frac{3\\epsilon}{|\\cos(a)|}\\right)^{\\frac{1}{3}}}$$", "id": "2167887"}, {"introduction": "在理解了舍入误差的来源后，本练习将展示一种强有力的缓解技术。我们将看到，通过对差商公式进行简单的代数重构，可以有效避免因两个相近数相减而导致的灾难性抵消。这个练习强调了公式的表达形式与公式本身同样重要。[@problem_id:3269410]", "problem": "考虑使用前向差分对函数 $f(x)=\\sqrt{x}$ 在点 $x=1$ 处的导数进行数值近似。设浮点运算遵循标准模型 $\\,\\mathrm{fl}(a \\,\\circ\\, b) = (a \\,\\circ\\, b)(1+\\delta)$，其中对于每个基本运算 $\\,\\circ\\,$（加、减、乘、除），都有 $|\\delta|\\leq u$。并设平方根满足 $\\mathrm{fl}(\\sqrt{z})=\\sqrt{z}\\,(1+\\delta)$，其中 $|\\delta|\\leq u$。这里 $u$ 表示单位舍入误差。假设计算在电气与电子工程师协会（IEEE）754 双精度下进行，其单位舍入误差为 $u=2^{-53}$，在 $x=1$ 处的间距为 $2^{-52}$，因此当且仅当 $h\\geq 2^{-52}$ 时，有 $\\mathrm{fl}(1+h)1$。\n\n您将分析函数 $f$ 在 $x=1$ 处的前向差分商的两种代数等价实现：\n- 朴素差分商，计算为 $(\\sqrt{1+h}-\\sqrt{1})/h$，以及\n- 一种避免了两个相近数相减的代数变换后的差分商。\n\n仅从导数的定义、光滑函数的基本泰勒展开事实以及上述浮点模型出发，完成以下任务：\n- 通过纯代数操作，推导出一个前向差分商的等价形式，该形式消除了 $\\sqrt{1+h}$ 和 $\\sqrt{1}$ 的直接相减。\n- 确定前向差分近似 $f'(1)$ 的截断误差关于 $h$ 的主阶项。\n- 在浮点模型下，使用一阶舍入误差传播，为两种实现方式推导以 $h$ 和 $u$ 为函数的绝对舍入误差主阶项模型。您的模型应清楚地表明哪种实现会遭受 $O(u/h)$ 的放大效应，哪种实现产生 $O(u)$ 的贡献。\n- 结合截断误差和舍入误差项，为朴素实现建立一个主阶总绝对误差模型，并确定使该总误差最小化的步长 $h_{\\ast}$（用 $u$ 表示）。\n- 最后，具体到 IEEE 754 双精度，其中 $u=2^{-53}$，并以科学记数法报告 $h_{\\ast}$ 的数值。将您的答案四舍五入到四位有效数字。不要包含单位。", "solution": "该问题陈述是数值分析中一个适定且标准的练习，涉及数值微分中截断误差和舍入误差之间的权衡。所有提供的信息在科学上都是合理的、自洽的且一致的。因此，该问题是有效的，并将提供解答。\n\n任务是分析函数 $f(x)=\\sqrt{x}$ 在 $x=1$ 处导数的前向差分近似。确切的导数是 $f'(x) = \\frac{1}{2\\sqrt{x}}$，所以在 $x=1$ 处，确切值为 $f'(1) = \\frac{1}{2}$。\n\n### 差分商的等价形式\n朴素前向差分商由下式给出\n$$\nD_h = \\frac{f(1+h) - f(1)}{h} = \\frac{\\sqrt{1+h} - \\sqrt{1}}{h} = \\frac{\\sqrt{1+h} - 1}{h}\n$$\n对于小的正数 $h$，分子涉及两个相近数（$\\sqrt{1+h} \\approx 1$）的相减，这种情况被称为相消误差（subtractive cancellation），会导致浮点运算中相对精度的损失。为了推导出一个避免这种情况的代数等价形式，我们将分子和分母同乘以分子的共轭项，即 $\\sqrt{1+h} + 1$：\n$$\nD_h = \\frac{\\sqrt{1+h} - 1}{h} \\times \\frac{\\sqrt{1+h} + 1}{\\sqrt{1+h} + 1} = \\frac{(\\sqrt{1+h})^2 - 1^2}{h(\\sqrt{1+h} + 1)} = \\frac{(1+h) - 1}{h(\\sqrt{1+h} + 1)} = \\frac{h}{h(\\sqrt{1+h} + 1)}\n$$\n对于 $h \\neq 0$，我们可以消去分子和分母中的 $h$ 以获得稳定化的公式：\n$$\nD_h = \\frac{1}{\\sqrt{1+h} + 1}\n$$\n在精确算术中，此形式与原始形式等价。在浮点运算中，它在数值上是稳定的，因为它只涉及加法，并避免了相近量的相减。\n\n### 截断误差\n截断误差 $E_{\\text{trunc}}$ 是在假设精确算术的情况下，近似公式固有的误差。它定义为 $E_{\\text{trunc}}(h) = D_h - f'(1)$。我们使用 $f(1+h)$ 在 $h=0$ 附近的泰勒展开。对于 $f(x) = \\sqrt{x}$，其导数为 $f'(x) = \\frac{1}{2}x^{-1/2}$ 和 $f''(x) = -\\frac{1}{4}x^{-3/2}$。\n在 $x=1$ 处，我们有 $f(1)=1$，$f'(1)=\\frac{1}{2}$，以及 $f''(1)=-\\frac{1}{4}$。\n$f(1+h)$ 的泰勒展开式为：\n$$\nf(1+h) = f(1) + f'(1)h + \\frac{f''(1)}{2!}h^2 + O(h^3) = 1 + \\frac{1}{2}h - \\frac{1}{8}h^2 + O(h^3)\n$$\n将此代入朴素差分商公式：\n$$\nD_h = \\frac{(1 + \\frac{1}{2}h - \\frac{1}{8}h^2 + O(h^3)) - 1}{h} = \\frac{\\frac{1}{2}h - \\frac{1}{8}h^2 + O(h^3)}{h} = \\frac{1}{2} - \\frac{1}{8}h + O(h^2)\n$$\n那么截断误差为：\n$$\nE_{\\text{trunc}}(h) = D_h - f'(1) = \\left(\\frac{1}{2} - \\frac{1}{8}h + O(h^2)\\right) - \\frac{1}{2} = -\\frac{1}{8}h + O(h^2)\n$$\n主阶截断误差为 $-\\frac{1}{8}h$。\n\n### 舍入误差模型\n我们在给定的浮点模型下分析两种实现的舍入误差传播。设 $u$ 为单位舍入误差。\n\n**朴素实现：** $D_h = (\\sqrt{1+h}-1)/h$。\n计算出的近似值 $\\hat{D}_{\\text{naive}}$ 大约为\n$$\n\\hat{D}_{\\text{naive}} \\approx \\frac{( \\sqrt{1+h}(1+\\delta_1) - 1 )(1+\\delta_2)}{h} (1+\\delta_3)\n$$\n其中 $|\\delta_i| \\le u$ 分别代表由平方根、减法和除法产生的误差。更详细的一阶误差分析表明，计算分子 $N = \\sqrt{1+h}-1$ 的误差主要由函数值的初始计算主导。计算出的分子 $\\hat{N}$ 的绝对误差 $|\\hat{N}-N|$ 大致与被减数的量级成正比，而不是它们的差。由于 $\\sqrt{1+h} \\approx 1$，分子的绝对误差量级为 $u \\cdot |1| = u$。更仔细的分析将分子误差界定为约 $2u$。当这个误差被小的步长 $h$ 除时，它会被放大。因此，绝对舍入误差 $E_{\\text{round, naive}}$ 主要由这一项主导：\n$$\n|E_{\\text{round, naive}}| \\approx \\frac{C \\cdot u}{h}\n$$\n其中 $C$ 是某个量级为 $1$ 的常数。这是由相消误差引起的典型的 $O(u/h)$ 误差放大。\n\n**稳定实现：** $D_h = 1/(\\sqrt{1+h}+1)$。\n计算出的近似值 $\\hat{D}_{\\text{stable}}$ 大约为\n$$\n\\hat{D}_{\\text{stable}} \\approx \\frac{1}{(\\sqrt{1+h}(1+\\delta_1) + 1)(1+\\delta_2)} (1+\\delta_3)\n$$\n在这里，分母约等于 $2$。所涉及的运算是正数相加和开平方根，这些在数值上是良性的。计算分母 $Den = \\sqrt{1+h}+1$ 的绝对误差量级为 $u \\cdot |Den| \\approx 2u$。当我们取倒数时，相对误差得以保持。因此，最终结果的绝对误差约为 $u \\cdot |D_h| \\approx u/2$。主阶绝对舍入误差为：\n$$\n|E_{\\text{round, stable}}| \\approx C' \\cdot u\n$$\n其中 $C'$ 是某个量级为 $1$ 的常数。这种实现避免了误差放大，产生的误差贡献量级为 $O(u)$。\n\n### 朴素实现的最优步长\n对于朴素实现，总绝对误差 $|E_{\\text{total}}|$ 是截断误差和舍入误差的绝对值之和。\n$$\n|E_{\\text{total}}(h)| \\approx |E_{\\text{trunc}}(h)| + |E_{\\text{round, naive}}(h)|\n$$\n使用前面推导出的主阶项，我们有：\n$$\n|E_{\\text{trunc}}(h)| = |-\\frac{1}{8}h| = \\frac{h}{8}\n$$\n对于舍入误差，一个标准模型使用 $|E_{\\text{round}}| \\approx \\frac{\\epsilon(|f(x+h)|+|f(x)|)}{h}$，其中 $\\epsilon$ 是机器精度，即 $2u$。对于本问题，更直接的说法是分子 $f(1+h)-f(1)$ 中的误差由 $u|f(1+h)|+u|f(1)| \\approx u(1+1) = 2u$ 界定。因此，\n$$\n|E_{\\text{round, naive}}(h)| \\approx \\frac{2u}{h}\n$$\n需要最小化的总误差函数是：\n$$\nE(h) = \\frac{h}{8} + \\frac{2u}{h}\n$$\n为了找到使该误差最小化的步长 $h_{\\ast}$，我们将 $E(h)$ 对 $h$ 求导，并令其导数为零：\n$$\n\\frac{dE}{dh} = \\frac{1}{8} - \\frac{2u}{h^2} = 0\n$$\n求解 $h$：\n$$\n\\frac{1}{8} = \\frac{2u}{h^2} \\implies h^2 = 16u \\implies h = \\sqrt{16u} = 4\\sqrt{u}\n$$\n所以，最优步长是 $h_{\\ast} = 4\\sqrt{u}$。\n\n### $h_{\\ast}$ 的数值\n对于 IEEE 754 双精度，单位舍入误差为 $u = 2^{-53}$。我们将此值代入 $h_{\\ast}$ 的表达式中：\n$$\nh_{\\ast} = 4\\sqrt{2^{-53}} = 2^2 \\times (2^{-53})^{1/2} = 2^2 \\times 2^{-53/2} = 2^{2 - 26.5} = 2^{-24.5}\n$$\n为了求出数值，我们计算：\n$$\nh_{\\ast} = 2^{-24.5} = \\frac{1}{2^{24.5}} = \\frac{1}{2^{24}\\sqrt{2}} = \\frac{1}{16777216\\sqrt{2}}\n$$\n使用计算器，$h_{\\ast} \\approx 4.2146301... \\times 10^{-8}$。\n四舍五入到四位有效数字，我们得到：\n$$\nh_{\\ast} \\approx 4.215 \\times 10^{-8}\n$$\n这个值远大于相对于 $1$ 的机器精度（问题中指出为 $2^{-52} \\approx 2.22 \\times 10^{-16}$），因此浮点数 $\\mathrm{fl}(1+h_{\\ast})$ 确实大于 $1$，验证了分析的一个关键假设。", "answer": "$$\n\\boxed{4.215 \\times 10^{-8}}\n$$", "id": "3269410"}, {"introduction": "有时，尽管我们尽了最大努力，选择的步长 $h$ 仍可能过小，以至于浮点运算使得差商的分子变为零。最后一个练习将从静态公式转向动态算法。我们将设计并实现一种自适应方法，通过逐步增大 $h$ 来摆脱这种“归零”困境，确保能够计算出有意义的导数近似值，这展示了一种面向实际应用的稳健编程策略。[@problem_id:3269293]", "problem": "要求您研究在符合电气与电子工程师协会 (IEEE) 754 标准的浮点（FP）运算中，舍入误差如何与使用对称有限差分的数值微分相互作用。其基本依据是导数作为对称差商极限的定义：对于一个可微函数 $f$，其在点 $x$ 处的导数为 $f^{\\prime}(x) = \\lim_{h \\to 0} \\dfrac{f(x+h) - f(x-h)}{2h}$。在有限精度运算中，当 $h$ 相对于 $x$ 极小时，浮点和 $x+h$ 与 $x-h$ 可能会精确地舍入为 $x$，导致 $f(x+h) - f(x-h)$ 的计算结果为零。您将设计并实现一个算法，该算法能检测到这种情况，并以乘法方式增加 $h$，直到出现非零差值，然后使用第一个产生非零差值的 $h$ 来计算对称差商。您还将量化所获得导数估计值与已知解析导数之间的偏差（绝对误差）。\n\n实现一个程序，完成以下操作。\n\n1) 实现一个函数，给定一个函数 $f$、一个点 $x_0$、一个初始步长 $h_0$、一个乘法增长因子 $r$（$r  1$）以及最大增长步数 $N_{\\max}$，该函数尝试通过以下过程计算在 $x_0$ 处的对称有限差分导数：\n   - 使用当前的 $h$ 计算分子 $f(x_0 + h) - f(x_0 - h)$。\n   - 如果分子在数值上等于零，则将 $h$ 替换为 $r h$ 并重复，同时计入一个增长步。\n   - 在分子首次为非零时的 $h$ 处停止，或者当增长步数达到 $N_{\\max}$ 时停止。\n   - 返回在停止时的 $h$ 处计算的导数估计值 $(f(x_0 + h) - f(x_0 - h))/(2h)$、实际使用的 $h$、所用的增长步数，以及一个布尔标志，指示循环是否因达到 $N_{\\max}$ 但分子仍为零（停滞）而终止。所有三角函数的参数必须以弧度为单位解释。\n\n2) 对于下面的每个测试用例，计算并报告绝对偏差，其定义为 $| \\widehat{f^{\\prime}}(x_0) - f^{\\prime}(x_0) |$，其中 $\\widehat{f^{\\prime}}(x_0)$ 是您的数值估计值，$f^{\\prime}(x_0)$ 是在 $x_0$ 处的精确解析导数。\n\n3) 使用以下旨在覆盖不同情况的测试套件：\n   - A情况（由于$|h_0|$远小于局部间距而导致初始为零）：$f(x) = e^{x}$，$x_0 = 1$，$h_0 = 10^{-20}$，$r = 2$，$N_{\\max} = 60$。\n   - B情况（由于$x_0$可以精确表示且在零附近间距密集而没有初始零）：$f(x) = \\sin(x)$，$x_0 = 0$，$h_0 = 10^{-20}$，$r = 2$，$N_{\\max} = 60$。角度使用弧度。\n   - C情况（对于所有$h$，分子结构性为零，而不是舍入造成的假象）：$f(x) = \\cos(x)$，$x_0 = 0$，$h_0 = 10^{-20}$，$r = 2$，$N_{\\max} = 60$。角度使用弧度。\n   - D情况（$x_0$的量级很大而$h_0$很小，导致$x_0 \\pm h$初始时舍入为同一个浮点数）：$f(x) = x^{2}$，$x_0 = 10^{8}$，$h_0 = 10^{-20}$，$r = 2$，$N_{\\max} = 60$。\n\n   对于每种情况，用于计算偏差的精确解析导数分别为：对于 $e^{x}$ 是 $f^{\\prime}(x) = e^{x}$，对于 $\\sin(x)$ 是 $f^{\\prime}(x) = \\cos(x)$，对于 $\\cos(x)$ 是 $f^{\\prime}(x) = -\\sin(x)$，对于 $x^{2}$ 是 $f^{\\prime}(x) = 2x$。\n\n4) 最终输出格式：您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号括起来的逗号分隔列表。每个用例的结果必须是包含五个项目的列表，顺序如下：实际使用的 $h$（浮点数）、所用的增长步数（整数）、停滞标志（布尔值）、导数估计值（浮点数）和绝对偏差（浮点数）。因此，完整的输出是一行，格式如下\n   [$[h_{\\mathrm{A}},n_{\\mathrm{A}},\\mathrm{stall}_{\\mathrm{A}},\\widehat{d}_{\\mathrm{A}},b_{\\mathrm{A}}],[h_{\\mathrm{B}},n_{\\mathrm{B}},\\mathrm{stall}_{\\mathrm{B}},\\widehat{d}_{\\mathrm{B}},b_{\\mathrm{B}}],[h_{\\mathrm{C}},n_{\\mathrm{C}},\\mathrm{stall}_{\\mathrm{C}},\\widehat{d}_{\\mathrm{C}},b_{\\mathrm{C}}],[h_{\\mathrm{D}},n_{\\mathrm{D}},\\mathrm{stall}_{\\mathrm{D}},\\widehat{d}_{\\mathrm{D}},b_{\\mathrm{D}}]$]\n   其中，此描述中的每个数学实体都将由您的程序进行数值计算。\n\n科学真实性与推导重点：将您的推理建立在导数的极限定义、IEEE 754 双精度语义下浮点加法 $x \\pm h$ 中的舍入行为，以及 $f$ 在 $x_0$ 附近的泰勒展开之上，以理解当 $h$ 增加时产生的偏差。不要在问题陈述中引用任何预先推导的误差平衡公式。不涉及物理单位。如适用，角度必须以弧度为单位，如上所述。", "solution": "我们从导数的基本极限定义开始。对于在 $x_0$ 处可微的函数 $f$，其导数满足\n$$\nf^{\\prime}(x_0) \\;=\\; \\lim_{h \\to 0} \\frac{f(x_0 + h) - f(x_0 - h)}{2h}.\n$$\n选择对称商是因为它能消除泰勒展开中的主要奇数阶项，从而减少截断误差。具体来说，使用泰勒定理，\n$$\n\\begin{aligned}\nf(x_0 + h) = f(x_0) + f^{\\prime}(x_0) h + \\frac{f^{\\prime\\prime}(x_0)}{2} h^{2} + \\frac{f^{(3)}(x_0)}{6} h^{3} + \\mathcal{O}(h^{4}),\\\\\nf(x_0 - h) = f(x_0) - f^{\\prime}(x_0) h + \\frac{f^{\\prime\\prime}(x_0)}{2} h^{2} - \\frac{f^{(3)}(x_0)}{6} h^{3} + \\mathcal{O}(h^{4}).\n\\end{aligned}\n$$\n两式相减得到\n$$\nf(x_0 + h) - f(x_0 - h) \\;=\\; 2 f^{\\prime}(x_0) h + \\frac{f^{(3)}(x_0)}{3} h^{3} + \\mathcal{O}(h^{5}).\n$$\n两边除以 $2h$ 得到经典的中心差分导数及其截断偏差\n$$\n\\frac{f(x_0 + h) - f(x_0 - h)}{2h} \\;=\\; f^{\\prime}(x_0) + \\frac{f^{(3)}(x_0)}{6} h^{2} + \\mathcal{O}(h^{4}).\n$$\n因此，从第一性原理出发，截断偏差与 $h^2$ 成比例，其系数与 $f^{(3)}(x_0)$ 有关。\n\n在电气与电子工程师协会 (IEEE) 754 双精度模型下的浮点（FP）运算中，每个实数 $x$ 由一个邻近的机器数表示，而像 $x \\pm h$ 这样的运算会被舍入到最近的可表示数。在非零 $x$ 周围，实数轴上相邻可表示数之间存在一个间距 $\\operatorname{ulp}(x)$。如果 $|h|  \\tfrac{1}{2}\\operatorname{ulp}(x)$，那么 $x+h$ 和 $x-h$ 的浮点计算结果都会精确地舍入为 $x$。当这种情况发生时，函数求值是在相同的自变量上进行的，因此在数值上 $f(x+h) - f(x-h) = 0$，尽管数学上的差值可能不为零。这不是微积分的失败，而是离散表示和舍入的结果。\n\n算法设计原则：检测零分子的情况，并通过增加 $h$ 来摆脱它。\n- 从 $h = h_0$ 开始。\n- 使用浮点运算计算 $y_{+} = f(x_0 + h)$ 和 $y_{-} = f(x_0 - h)$。\n- 如果数值上 $y_{+} - y_{-} = 0$，这表明 (a) $x_0 \\pm h$ 舍入为同一个浮点数（在 $|h|$ 相对于 $|x_0|$ 过小时很常见），或者 (b) 函数本身是对称的，以至于对所有 $h$ 都有 $f(x_0 + h) = f(x_0 - h)$（例如，在 $x_0=0$ 处的 $f(x) = \\cos(x)$）。在情况(a)下，我们应该增加 $h$，而在情况(b)下增加 $h$ 永远无法打破相等。因此，算法将 $h$ 乘以一个固定因子 $r  1$ 并重试，最多进行 $N_{\\max}$ 次增长。\n- 循环在出现第一个非零分子时结束，或者在达到 $N_{\\max}$ 次增长后分子仍为零时结束；在后一种“停滞”情况下，我们报告算法未能找到非零差值。\n\n算法增加 $h$ 时的偏差分析：从上面推导的泰勒展开可知，一旦获得非零差值，中心差分估计的截断偏差约为 $\\tfrac{f^{(3)}(x_0)}{6} h^{2}$。因为算法会增加 $h$ 直到观察到非零差值，所选的 $h$ 通常接近局部的可表示间距阈值。这保证了分子可以被分辨出来，但与理想的无穷小极限相比，它也增加了 $h$，从而增大了截断偏差。在 $f(x_0 + h) - f(x_0 - h)$ 中存在来自相消误差的竞争性舍入贡献；然而，本算法的主要作用是脱离两个自变量完全相同的舍入区域，同时仍保持 $h$ 合理地小。在具体测试中观察到的总偏差可以量化为 $|\\widehat{f^{\\prime}}(x_0) - f^{\\prime}(x_0)|$。\n\n测试套件覆盖范围的基本原理：\n- A情况，$f(x) = e^{x}$ 在 $x_0 = 1$ 处，使用 $h_0 = 10^{-20}$ 和 $r = 2$，迫使 $x_0 \\pm h$ 初始时舍入为 $x_0$，因为 $x_0=1$ 附近的单位舍入值约为 $2^{-52} \\approx 2.22 \\times 10^{-16}$。算法必须将 $h$ 增加数次，分子才会变为非零。这用于探测预期的检测与逃逸行为。\n- B情况，$f(x) = \\sin(x)$ 在 $x_0 = 0$ 处，使用 $h_0 = 10^{-20}$，会立即产生不同的 $x_0 \\pm h$，因为零附近的间距是绝对的且非常精细；对于任何非零 $h$，$\\sin(h) - \\sin(-h)$ 都不为零。这证实了算法在不必要时不会改变 $h$。角度以弧度为单位。\n- C情况，$f(x) = \\cos(x)$ 在 $x_0 = 0$ 处，由于偶对称性，对于所有 $h$ 都会产生 $f(x_0 + h) - f(x_0 - h) = 0$，这并非由舍入引起。算法将达到 $N_{\\max}$ 并设置停滞标志。真实导数为 $0$，返回的估计值也是 $0$，因此偏差为 $0$，同时仍能正确报告停滞。\n- D情况，$f(x) = x^{2}$ 在 $x_0 = 10^{8}$ 处，使用 $h_0 = 10^{-20}$，同样会迫使 $h$ 多次增加，因为在一个大的 $x_0$ 附近，局部间距很大（与 $|x_0|$ 成正比）。这用于检验在大数量级下的行为。对于二次多项式，在精确算术中对称差分是精确的，因此观察到的任何偏差都源于浮点效应而非截断。\n\n实现的算法细节：\n- 通过默认的 NumPy 浮点类型使用双精度算术。\n- 在每一步，计算 $y_{+} = f(x_0 + h)$ 和 $y_{-} = f(x_0 - h)$，形成 $\\Delta = y_{+} - y_{-}$，并测试 $\\Delta$ 作为一个浮点数是否精确为零。\n- 如果 $\\Delta \\neq 0$，则返回 $\\widehat{f^{\\prime}}(x_0) = \\Delta/(2h)$，以及所用的 $h$、增长步数和设置为 false 的停滞标志。\n- 如果循环在 $N_{\\max}$ 次增长后以 $\\Delta = 0$ 结束，则返回估计值 0（因为 $\\Delta = 0$）并将停滞标志设置为 true。\n- 对于每个测试用例，计算解析导数 $f^{\\prime}(x_0)$ 和绝对偏差 $|\\widehat{f^{\\prime}}(x_0) - f^{\\prime}(x_0)|$。\n- 将四个用例的结果打印为包含四个列表的单个列表，每个内部列表包含 $[h_{\\text{used}}, \\text{steps}, \\text{stall}, \\widehat{f^{\\prime}}(x_0), \\text{bias}]$。\n\n该过程直接源于导数的定义和浮点运算的离散性质。增加 $h$ 时的偏差行为遵循泰勒展开，该展开显示对称差分存在一个 $\\mathcal{O}(h^{2})$ 的截断项，这意味着较大的 $h$ 会增加截断偏差，而过小的 $h$ 会因舍入导致分子为零。所提出的算法确保分子变得可分辨，同时在所选的几何增长下使 $h$ 尽可能小。", "answer": "```python\n# Execution environment:\n# - language: Python 3.12\n# - libraries: numpy 1.23.5 only (plus standard library)\nimport numpy as np\n\ndef central_diff_with_growth(f, x0, h0, r, max_steps):\n    \"\"\"\n    Compute symmetric finite difference derivative at x0 using step h,\n    increasing h geometrically by factor r  1 until the numerator\n    f(x0+h) - f(x0-h) is nonzero or until max_steps is reached.\n\n    Returns:\n        h_used (float): The final h used to compute the derivative.\n        steps (int): The number of growth steps taken (0 means used initial h0).\n        stalled (bool): True if max_steps reached with zero numerator; False otherwise.\n        derivative_est (float): The derivative estimate (0.0 if stalled with zero numerator).\n    \"\"\"\n    h = float(h0)\n    steps = 0\n    stalled = False\n\n    # Defensive: ensure r  1; if not, force a minimal growth factor\n    if not (r  1.0):\n        r = 2.0\n\n    # Try up to max_steps increases\n    for k in range(max_steps + 1):\n        # Compute numerator in floating-point arithmetic\n        y_plus = f(x0 + h)\n        y_minus = f(x0 - h)\n        delta = y_plus - y_minus\n\n        if delta != 0.0:\n            # Found a usable h\n            derivative_est = delta / (2.0 * h)\n            return h, steps, False, float(derivative_est)\n\n        # If here, delta == 0.0\n        if k == max_steps:\n            stalled = True\n            break\n        else:\n            h *= r\n            steps += 1\n\n    # If stalled, derivative estimate defaults to zero (since numerator is zero)\n    return h, steps, stalled, 0.0\n\ndef run_test_cases():\n    # Define functions and their exact derivatives\n    def f_exp(x): return np.exp(x)\n    def df_exp(x): return np.exp(x)\n\n    def f_sin(x): return np.sin(x)  # radians\n    def df_sin(x): return np.cos(x)\n\n    def f_cos(x): return np.cos(x)  # radians\n    def df_cos(x): return -np.sin(x)\n\n    def f_sq(x): return x * x\n    def df_sq(x): return 2.0 * x\n\n    test_cases = [\n        # Each case: (f, df, x0, h0, r, max_steps)\n        (f_exp, df_exp, 1.0, 1e-20, 2.0, 60),       # Case A\n        (f_sin, df_sin, 0.0, 1e-20, 2.0, 60),       # Case B\n        (f_cos, df_cos, 0.0, 1e-20, 2.0, 60),       # Case C\n        (f_sq,  df_sq,  1.0e8, 1e-20, 2.0, 60),     # Case D\n    ]\n\n    results = []\n    for f, df, x0, h0, r, max_steps in test_cases:\n        h_used, steps, stalled, d_est = central_diff_with_growth(f, x0, h0, r, max_steps)\n        true_deriv = df(x0)\n        bias = abs(d_est - true_deriv)\n        results.append([h_used, int(steps), bool(stalled), float(d_est), float(bias)])\n    return results\n\ndef solve():\n    results = run_test_cases()\n    # Print as a single line in the exact required format: a list of lists\n    print(str(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3269293"}]}