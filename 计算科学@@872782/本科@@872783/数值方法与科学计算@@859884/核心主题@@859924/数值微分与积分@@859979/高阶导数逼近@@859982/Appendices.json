{"hands_on_practices": [{"introduction": "本练习是数值方法学习中的一个核心实践，它将从泰勒级数推导有限差分公式的理论与其实际性能表现联系起来。通过亲手实现这些公式，并将其计算结果与已知解析解进行比较，您将对截断误差和精度阶等概念获得具体的理解。这个过程将教会您如何通过数值实验来验证一个近似方案是否如理论所预期的那样工作。 [@problem_id:3238903]", "problem": "考虑函数 $f(x) = \\exp(-x^2)$。您的任务是使用中心有限差分模板来近似高阶导数，从第一性原理推导截断误差阶数，并与解析导数进行对比，以验证观测到的收敛率。\n\n您必须基于以下基础进行操作：\n- 使用 $f(x \\pm kh)$ 在点 $x = x_0$ 附近的 Taylor 级数展开（其中 $k \\in \\mathbb{Z}$ 且 $h > 0$ 是一个小数）来构造一致的导数中心有限差分近似。具体来说，使用 Taylor 展开式\n$$\nf(x_0 \\pm kh) = \\sum_{n=0}^{\\infty} \\frac{(\\pm kh)^n}{n!} f^{(n)}(x_0).\n$$\n- 使用截断误差阶数的定义：如果对量 $Q$ 的一个近似 $A_h$ 满足 $A_h = Q + C h^p + \\mathcal{O}(h^{p+1})$（其中常数 $C \\neq 0$），则我们称该近似为 $p$ 阶。\n- 使用两个步长 $h_1$ 和 $h_2$ 对应的误差 $E(h_1)$ 和 $E(h_2)$ 的观测阶数定义，即\n$$\np_{\\mathrm{obs}} = \\frac{\\log\\big(E(h_1)/E(h_2)\\big)}{\\log(h_1/h_2)}.\n$$\n\n任务：\n1. 通过直接微分，推导 $f(x) = \\exp(-x^2)$ 的解析二阶和四阶导数 $f^{(2)}(x)$ 和 $f^{(4)}(x)$ 的符号表达式。\n2. 使用 Taylor 级数，推导以下各项的中心有限差分模板及其主截断误差：\n   - $f^{(2)}(x_0)$ 的标准中心 $3$ 点近似，\n   - 比 $3$ 点模板精度更高的 $f^{(2)}(x_0)$ 的中心 $5$ 点近似，\n   - $f^{(4)}(x_0)$ 的中心 $5$ 点近似。\n   不要假设任何预先已知的系数；通过在 $x_0$ 处匹配 Taylor 级数项来推导它们。\n3. 实现一个程序，在特定点上评估近似值，并通过计算与任务1中解析导数的误差以及当 $h$ 减半时的误差比率得到的观测阶数，来验证收敛阶数。\n\n测试套件：\n- 使用网格间距序列 $h_k = 0.2 \\cdot 2^{-k}$，其中 $k \\in \\{0,1,2,3,4,5\\}$。\n- 对于以下每种情况，计算误差 $E(h_k)$（即数值近似与在 $x_0$ 处的解析导数之间的绝对差），然后使用连续的步长对 $(h_{k-1}, h_k)$ 计算观测阶数 $p_k$，其中 $k \\in \\{1,2,3,4,5\\}$。\n- 为确保稳健性，将每种情况报告的观测阶数定义为最后三个值 $\\{p_3, p_4, p_5\\}$ 的中位数。\n- 验证以下四种情况及其预期阶数和点：\n  - 情况 A：$f^{(2)}(x_0)$ 在 $x_0 = 0.7$ 处的中心 $3$ 点模板，预期阶数 $2$。\n  - 情况 B：$f^{(2)}(x_0)$ 在 $x_0 = 1.3$ 处的中心 $5$ 点模板，预期阶数 $4$。\n  - 情况 C：$f^{(4)}(x_0)$ 在 $x_0 = 0.0$ 处的中心 $5$ 点模板，预期阶数 $2$。\n  - 情况 D（边缘数值情况）：$f^{(2)}(x_0)$ 在 $x_0 = 2.0$ 处的中心 $5$ 点模板，预期阶数 $4$。\n\n每种情况的通过-失败标准：\n- 设 $\\tilde{p}$ 为报告的观测阶数（$\\{p_3, p_4, p_5\\}$ 的中位数）。如果 $|\\tilde{p} - p_{\\mathrm{expected}}| \\le 0.3$，则该情况通过，否则失败，其中 $p_{\\mathrm{expected}}$ 是该情况的预期阶数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]，其中每个条目是该情况的布尔结果，例如，“[True,True,False,True]”。\n- 此问题不需要用户输入，也不涉及物理单位或角度单位。所有数值都是无量纲的。", "solution": "该问题经评估为有效，因为它在数值分析方面有科学依据，问题提出得当，目标明确，且没有不一致或含糊之处。我们接下来给出一个完整的解决方案。\n\n解决方案分为三个部分，与问题陈述中概述的任务相对应。首先，我们推导所需导数的解析表达式。其次，我们使用 Taylor 级数推导有限差分模板及其截断误差。第三，我们概述将在最终代码中实现的数值验证过程。\n\n### 第1部分：解析导数\n\n给定函数 $f(x) = \\exp(-x^2)$。我们将通过直接微分计算其二阶和四阶导数 $f^{(2)}(x)$ 和 $f^{(4)}(x)$。为简化中间步骤，我们使用撇号表示法（即 $f'(x)$、$f''(x)$ 等）来表示对 $x$ 的导数。\n\n一阶导数为：\n$$\nf'(x) = \\frac{d}{dx} \\exp(-x^2) = -2x \\exp(-x^2) = -2x f(x)\n$$\n\n使用乘法法则求二阶导数：\n$$\nf''(x) = \\frac{d}{dx} (-2x f(x)) = -2 f(x) - 2x f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf''(x) = -2 f(x) - 2x (-2x f(x)) = (-2 + 4x^2) f(x)\n$$\n因此，二阶导数的解析表达式为：\n$$\nf^{(2)}(x) = (4x^2 - 2) \\exp(-x^2)\n$$\n\n为了求四阶导数，我们首先计算三阶导数：\n$$\nf'''(x) = \\frac{d}{dx} \\left( (4x^2 - 2) f(x) \\right) = (8x) f(x) + (4x^2 - 2) f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf'''(x) = 8x f(x) + (4x^2 - 2) (-2x f(x)) = (8x - 8x^3 + 4x) f(x) = (-8x^3 + 12x) f(x)\n$$\n\n最后，通过对 $f'''(x)$ 微分来计算四阶导数：\n$$\nf^{(4)}(x) = \\frac{d}{dx} \\left( (-8x^3 + 12x) f(x) \\right) = (-24x^2 + 12) f(x) + (-8x^3 + 12x) f'(x)\n$$\n代入 $f'(x) = -2x f(x)$：\n$$\nf^{(4)}(x) = (-24x^2 + 12) f(x) + (-8x^3 + 12x) (-2x f(x)) = (-24x^2 + 12 + 16x^4 - 24x^2) f(x)\n$$\n因此，四阶导数的解析表达式为：\n$$\nf^{(4)}(x) = (16x^4 - 48x^2 + 12) \\exp(-x^2)\n$$\n\n### 第2部分：有限差分模板和截断误差\n\n我们通过构建点 $x_0$ 附近 Taylor 级数展开的线性组合来推导中心有限差分公式及其主截断误差项。设 $f_0^{(n)}$ 表示 $f^{(n)}(x_0)$。相关的展开式为：\n$$\nf(x_0 \\pm h) = f_0 \\pm h f_0' + \\frac{h^2}{2} f_0'' + \\frac{\\pm h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\frac{\\pm h^5}{120} f_0^{(5)} + \\frac{h^6}{720} f_0^{(6)} + \\mathcal{O}(h^7)\n$$\n$$\nf(x_0 \\pm 2h) = f_0 \\pm 2h f_0' + \\frac{(2h)^2}{2} f_0'' + \\frac{\\pm (2h)^3}{6} f_0''' + \\frac{(2h)^4}{24} f_0^{(4)} + \\frac{\\pm (2h)^5}{120} f_0^{(5)} + \\frac{(2h)^6}{720} f_0^{(6)} + \\mathcal{O}(h^7)\n$$\n\n**2a. $f^{(2)}(x_0)$ 的 $3$ 点中心模板**\n我们寻求形如 $f_0'' \\approx \\frac{c_{-1}f(x_0-h) + c_0 f(x_0) + c_1 f(x_0+h)}{h^2}$ 的近似。对于中心模板，对称性要求 $c_{-1}=c_1$。\n考虑组合 $f(x_0+h) - 2f(x_0) + f(x_0-h)$：\n$$\n(f_0 + h f_0' + \\frac{h^2}{2} f_0'' + \\frac{h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\mathcal{O}(h^6)) - 2f_0 + (f_0 - h f_0' + \\frac{h^2}{2} f_0'' - \\frac{h^3}{6} f_0''' + \\frac{h^4}{24} f_0^{(4)} + \\mathcal{O}(h^6))\n$$\n合并各项，奇数次幂的导数项相互抵消：\n$$\n= (1-2+1)f_0 + (1-1)h f_0' + (\\frac{1}{2}+\\frac{1}{2})h^2 f_0'' + (\\frac{1}{6}-\\frac{1}{6})h^3 f_0''' + (\\frac{1}{24}+\\frac{1}{24})h^4 f_0^{(4)} + \\mathcal{O}(h^6)\n$$\n$$\n= h^2 f_0'' + \\frac{h^4}{12} f_0^{(4)} + \\mathcal{O}(h^6)\n$$\n除以 $h^2$，我们得到近似式：\n$$\n\\frac{f(x_0-h) - 2f(x_0) + f(x_0+h)}{h^2} = f_0'' + \\frac{h^2}{12} f_0^{(4)} + \\mathcal{O}(h^4)\n$$\n模板为 $\\frac{1}{h^2}[f(x_0-h) - 2f(x_0) + f(x_0+h)]$。主截断误差为 $E_T = \\frac{h^2}{12} f_0^{(4)}$，因此该方法的阶数为 $p=2$。\n\n**2b. $f^{(2)}(x_0)$ 的 $5$ 点中心模板**\n我们寻求一个更精确的近似，形式为 $\\frac{1}{h^2} \\sum_{j=-2}^{2} c_j f(x_0+jh)$。对称性意味着 $c_{-j}=c_j$。线性组合是 $c_2(f(x_0-2h)+f(x_0+2h)) + c_1(f(x_0-h)+f(x_0+h)) + c_0 f(x_0)$。我们使用求和后的展开式：\n$$\nf(x_0-h) + f(x_0+h) = 2f_0 + h^2 f_0'' + \\frac{h^4}{12} f_0^{(4)} + \\frac{h^6}{360}f_0^{(6)} + \\mathcal{O}(h^8)\n$$\n$$\nf(x_0-2h)+f(x_0+2h) = 2f_0 + 4h^2 f_0'' + \\frac{4h^4}{3} f_0^{(4)} + \\frac{8h^6}{45}f_0^{(6)} + \\mathcal{O}(h^8)\n$$\n我们通过匹配导数的系数来构建一个方程组，以确定 $c_0, c_1, c_2$：\n$$\n\\text{Numerator} = (2c_2 + 2c_1 + c_0)f_0 + (4c_2 + c_1)h^2 f_0'' + (\\frac{4}{3}c_2 + \\frac{1}{12}c_1)h^4 f_0^{(4)} + \\dots\n$$\n为近似 $h^2 f_0''$，我们需要：\n\\begin{enumerate}\n    \\item $f_0$ 的系数：$2c_2 + 2c_1 + c_0 = 0$\n    \\item $f_0''$ 的系数：$4c_2 + c_1 = 1$\n    \\item 为达到更高阶精度，我们消去下一个误差项（$f_0^{(4)}$）：$\\frac{4}{3}c_2 + \\frac{1}{12}c_1 = 0$\n\\end{enumerate}\n由(3)式，$16c_2 + c_1 = 0 \\implies c_1 = -16c_2$。\n代入(2)式：$4c_2 + (-16c_2) = 1 \\implies -12c_2 = 1 \\implies c_2 = -1/12$。\n则 $c_1 = -16(-1/12) = 4/3$。\n由(1)式：$c_0 = -2c_1 - 2c_2 = -2(4/3) - 2(-1/12) = -8/3 + 1/6 = -16/6 + 1/6 = -15/6 = -5/2$。\n系数为 $c_2=-1/12, c_1=4/3, c_0=-5/2$。模板为：\n$$\n\\frac{-\\frac{1}{12}f(x_0-2h) + \\frac{4}{3}f(x_0-h) - \\frac{5}{2}f(x_0) + \\frac{4}{3}f(x_0+h) - \\frac{1}{12}f(x_0+2h)}{h^2}\n$$\n分子展开式中的下一项涉及 $f_0^{(6)}$：$(\\frac{8}{45}c_2 + \\frac{1}{360}c_1)h^6 f_0^{(6)}$。\n代入数值：$(\\frac{8}{45}(-\\frac{1}{12}) + \\frac{1}{360}(\\frac{4}{3})) h^6 f_0^{(6)} = (-\\frac{2}{135} + \\frac{1}{270})h^6 f_0^{(6)} = -\\frac{3}{270}h^6 f_0^{(6)} = -\\frac{1}{90}h^6 f_0^{(6)}$。\n该近似为 $f_0'' - \\frac{h^4}{90}f_0^{(6)} + \\mathcal{O}(h^6)$。截断误差为 $E_T = -\\frac{h^4}{90}f_0^{(6)}$，因此该方法的阶数为 $p=4$。\n\n**2c. $f^{(4)}(x_0)$ 的 $5$ 点中心模板**\n我们寻求一个形如 $\\frac{1}{h^4} \\sum_{j=-2}^{2} c_j f(x_0+jh)$ 的 $f_0^{(4)}$ 近似。我们使用与 2b 中相同的分子展开式，但以不同的方式匹配系数以分离出 $f_0^{(4)}$：\n$$\n\\text{Numerator} = (2c_2 + 2c_1 + c_0)f_0 + (4c_2 + c_1)h^2 f_0'' + (\\frac{4}{3}c_2 + \\frac{1}{12}c_1)h^4 f_0^{(4)} + \\dots\n$$\n为近似 $h^4 f_0^{(4)}$，我们需要：\n\\begin{enumerate}\n    \\item $f_0$ 的系数：$2c_2 + 2c_1 + c_0 = 0$\n    \\item $f_0''$ 的系数：$4c_2 + c_1 = 0 \\implies c_1 = -4c_2$\n    \\item $f_0^{(4)}$ 的系数：$\\frac{4}{3}c_2 + \\frac{1}{12}c_1 = 1$\n\\end{enumerate}\n由(2)式，将 $c_1 = -4c_2$ 代入(3)式：$\\frac{4}{3}c_2 + \\frac{1}{12}(-4c_2) = 1 \\implies \\frac{4}{3}c_2 - \\frac{1}{3}c_2 = 1 \\implies c_2 = 1$。\n则 $c_1 = -4(1) = -4$。\n由(1)式：$c_0 = -2c_1 - 2c_2 = -2(-4) - 2(1) = 8 - 2 = 6$。\n系数为 $c_2=1, c_1=-4, c_0=6$。模板为：\n$$\n\\frac{f(x_0-2h) - 4f(x_0-h) + 6f(x_0) - 4f(x_0+h) + f(x_0+2h)}{h^4}\n$$\n分子展开式中的下一项涉及 $f_0^{(6)}$：$(\\frac{8}{45}c_2 + \\frac{1}{360}c_1)h^6 f_0^{(6)}$。\n代入数值：$(\\frac{8}{45}(1) + \\frac{1}{360}(-4))h^6 f_0^{(6)} = (\\frac{64}{360} - \\frac{4}{360})h^6 f_0^{(6)} = \\frac{60}{360}h^6 f_0^{(6)} = \\frac{1}{6}h^6 f_0^{(6)}$。\n该近似为 $f_0^{(4)} + \\frac{h^2}{6}f_0^{(6)} + \\mathcal{O}(h^4)$。截断误差为 $E_T = \\frac{h^2}{6}f_0^{(6)}$，因此该方法的阶数为 $p=2$。\n\n### 第3部分：数值验证策略\n\n理论推导将通过计算进行验证。对于指定的四个测试用例中的每一个：\n\\begin{enumerate}\n    \\item 使用一系列步长 $h_k = 0.2 \\cdot 2^{-k}$，其中 $k \\in \\{0, 1, 2, 3, 4, 5\\}$。\n    \\item 对于每个 $h_k$，在指定点 $x_0$ 计算相应的有限差分近似值。\n    \\item 使用第1部分中的解析公式计算在 $x_0$ 处的导数的真实值。\n    \\item 绝对误差 $E(h_k)$ 计算为数值近似值与解析值之间的绝对差。\n    \\item 使用连续误差对计算收敛的观测阶数 $p_k$，其中 $k \\in \\{1, 2, 3, 4, 5\\}$：\n    $$\n    p_k = \\frac{\\log(E(h_{k-1})/E(h_k))}{\\log(h_{k-1}/h_k)} = \\frac{\\log(E(h_{k-1})/E(h_k))}{\\log(2)}\n    $$\n    \\item 每种情况报告的观测阶数 $\\tilde{p}$ 定义为最后三个计算出的阶数 $\\{p_3, p_4, p_5\\}$ 的中位数。这提供了当 $h \\to 0$ 时渐近收敛率的稳定估计。\n    \\item 最后，使用标准 $|\\tilde{p} - p_{\\mathrm{expected}}| \\le 0.3$ 对每种情况的预期理论阶数 $p_{\\mathrm{expected}}$ 进行验证。\n\\end{enumerate}\n此过程将封装在一个 Python 程序中，以生成最终的布尔结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of approximating higher derivatives and verifying convergence orders.\n    \"\"\"\n\n    # Part 1: Analytic Functions\n    def f(x: float) -> float:\n        \"\"\"The base function f(x) = exp(-x^2).\"\"\"\n        return np.exp(-x**2)\n\n    def f_d2(x: float) -> float:\n        \"\"\"The analytic second derivative of f(x).\"\"\"\n        return (4 * x**2 - 2) * np.exp(-x**2)\n\n    def f_d4(x: float) -> float:\n        \"\"\"The analytic fourth derivative of f(x).\"\"\"\n        return (16 * x**4 - 48 * x**2 + 12) * np.exp(-x**2)\n\n    # Part 2: Finite Difference Stencils\n    def approx_d2_3pt(func, x0: float, h: float) -> float:\n        \"\"\"3-point centered difference approximation for the 2nd derivative.\"\"\"\n        return (func(x0 - h) - 2 * func(x0) + func(x0 + h)) / h**2\n\n    def approx_d2_5pt(func, x0: float, h: float) -> float:\n        \"\"\"5-point centered difference approximation for the 2nd derivative (order 4).\"\"\"\n        return (-func(x0 - 2 * h) + 16 * func(x0 - h) - 30 * func(x0) + 16 * func(x0 + h) - func(x0 + 2 * h)) / (12 * h**2)\n\n    def approx_d4_5pt(func, x0: float, h: float) -> float:\n        \"\"\"5-point centered difference approximation for the 4th derivative (order 2).\"\"\"\n        return (func(x0 - 2 * h) - 4 * func(x0 - h) + 6 * func(x0) - 4 * func(x0 + h) + func(x0 + 2 * h)) / h**4\n\n    # Part 3: Numerical Verification\n    h_values = [0.2 * (2**-k) for k in range(6)]\n    \n    # Test cases: (approximation_function, analytic_function, evaluation_point_x0, expected_order)\n    test_cases = [\n        # Case A: 3-point f''(0.7), expected order 2\n        (approx_d2_3pt, f_d2, 0.7, 2),\n        # Case B: 5-point f''(1.3), expected order 4\n        (approx_d2_5pt, f_d2, 1.3, 4),\n        # Case C: 5-point f^(4)(0.0), expected order 2\n        (approx_d4_5pt, f_d4, 0.0, 2),\n        # Case D: 5-point f''(2.0) edge case, expected order 4\n        (approx_d2_5pt, f_d2, 2.0, 4),\n    ]\n\n    final_results = []\n    for approx_func, analytic_func, x0, p_expected in test_cases:\n        errors = []\n        for h in h_values:\n            approx_val = approx_func(f, x0, h)\n            analytic_val = analytic_func(x0)\n            error = np.abs(approx_val - analytic_val)\n            errors.append(error)\n\n        observed_orders = []\n        # Calculate observed orders p_k for k in {1,2,3,4,5}\n        for k in range(1, len(h_values)):\n            # Ratio of step sizes is 2\n            h_ratio = h_values[k-1] / h_values[k]\n            \n            # Avoid division by zero if error becomes numerically zero\n            if errors[k] > 0 and errors[k-1] > 0:\n                error_ratio = errors[k-1] / errors[k]\n                order = np.log(error_ratio) / np.log(h_ratio)\n                observed_orders.append(order)\n            else:\n                # If error is zero, convergence is perfect/infinite.\n                # This case isn't expected to be hit, but we handle it.\n                observed_orders.append(np.inf)\n\n        # Per problem, use median of last three observed orders {p_3, p_4, p_5}\n        # These correspond to indices 2, 3, 4 of observed_orders list\n        # which has 5 elements (p_1 to p_5).\n        if len(observed_orders) >= 5:\n            last_three_orders = observed_orders[2:5]\n            reported_order = np.median(last_three_orders)\n            \n            # Apply pass-fail criterion\n            passed = np.abs(reported_order - p_expected) <= 0.3\n            final_results.append(passed)\n        else:\n            # This path should not be taken given the problem setup\n            final_results.append(False)\n\n    # Format the final output as specified\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "3238903"}, {"introduction": "虽然标准的差分格式很有用，但在实际问题中，您可能会遇到需要为非均匀网格或特定精度要求定制差分格式的情况。本练习将引导您从使用预定义公式，转向构建一个能够为*任何*给定模板点集生成权重的通用工具。通过建立并求解基于矩匹配条件的线性方程组，您将掌握所有有限差分方法背后最核心的构建原理。 [@problem_id:3238803]", "problem": "您的任务是实现并测试一个通用例程，该例程使用一组给定的模板节点来生成用于逼近高阶导数的精确有限差分权重。推导的基本依据必须是光滑函数的泰勒级数展开和由此产生的矩条件。您的实现必须求解一个从多项式精确性条件推导出的方形线性系统，并尽可能使用精确有理数算术。\n\n设 $f$ 为一个光滑函数，$x \\in \\mathbb{R}$ 为一个点，$h \\in \\mathbb{R}$ 为一个步长，并设模板由不同的节点 $s_0, s_1, \\dots, s_{n-1} \\in \\mathbb{R}$ 给出。目标是构造权重 $w_0, w_1, \\dots, w_{n-1}$，使得有限差分公式\n$$\n\\frac{1}{h^p} \\sum_{j=0}^{n-1} w_j \\, f(x + h s_j)\n$$\n对于所有最高次数为 $n-1$ 的多项式，都能精确地再现其 $p$ 阶导数 $f^{(p)}(x)$。\n\n从泰勒级数展开式开始\n$$\nf(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k,\n$$\n对次数 $k = 0, 1, \\dots, n-1$ 施加多项式精确性（矩）条件：\n$$\n\\sum_{j=0}^{n-1} w_j s_j^k =\n\\begin{cases}\n0,  \\text{if } k \\neq p, \\\\\np!,  \\text{if } k = p.\n\\end{cases}\n$$\n这些条件产生了一个关于 $n$ 个未知数 $w_j$ 的 $n$ 个方程的线性系统。该系统的矩阵是一个方形范德蒙型矩阵，其元素为 $s_j^k$。\n\n您的程序必须：\n- 为通用导数阶数 $p$ 和所有互不相同的通用模板节点 $s_j$ 构建并求解该线性系统。\n- 当节点为整数时，通过标准库工具在有理数域上运算，使用精确有理数算术，从而使得到的权重是精确的有理数。如果无法进行精确符号求解（例如，节点非整数），则可接受浮点求解，但对于本任务，所有提供的模板节点都是整数。\n- 验证输入并通过受控方式引发或发出错误信号来处理无效配置。无效情况包括重复的模板节点以及 $p$ 超出范围 $0 \\leq p < n-1$。\n\n测试套件规范：\n在您的程序中实现以下测试用例，并根据最终输出格式要求汇总结果。\n\n1.  中心一阶导数权重，其中 $p = 1$，节点为 $[-1, 0, 1]$（此处 $n = 3$，$h = 1$ 用于生成权重）。计算权重并将其与期望的精确有理数值 $\\left[-\\frac{1}{2}, 0, \\frac{1}{2}\\right]$ 进行比较。以浮点数形式报告最大绝对差。\n\n2.  中心二阶导数权重，其中 $p = 2$，节点为 $[-1, 0, 1]$（$h = 1$ 用于生成权重）。计算权重并将其与期望的精确有理数值 $[1, -2, 1]$ 进行比较。以浮点数形式报告最大绝对差。\n\n3.  前向五阶导数权重，其中 $p = 5$，节点为 $[0, 1, 2, 3, 4, 5]$（$h = 1$ 用于生成权重）。将计算出的权重与期望的精确整数序列 $[-1, 5, -10, 10, -5, 1]$ 进行比较。报告一个表示是否完全相等的布尔值。\n\n4.  使用前向五阶导数权重对光滑函数进行数值逼近的精度。使用测试用例3中的权重，设 $x = 0$, $h = 10^{-3}$，以及 $f(x) = e^x$。计算对 $f^{(5)}(0)$ 逼近的绝对误差，对于 $f(x) = e^x$ 该值等于 $1$。以浮点数形式报告绝对误差。\n\n5.  在非均匀模板上的多项式精确性。设 $p = 2$，节点为 $[-2, -1, 0, 1, 3, 4]$（六个不同的整数节点），$x = 0$，以及 $h = 0.1$。使用生成的权重来逼近 $f(x) = x^2$ 在 $x = 0$ 处的二阶导数。因为该方案被构造成对最高次数为 $n-1$ 的多项式是精确的，所以结果应该精确地为 $f^{(2)}(0) = 2$。报告一个表示与 $2$ 的绝对差是否低于 $10^{-12}$ 的布尔值。\n\n6.  无效的导数阶数。尝试使用节点 $[0, 1]$ 和 $p = 3$ 生成权重。由于 $p \\geq n$ 是无效的，例程必须发出错误信号。报告一个表示是否正确检测到错误的布尔值。\n\n7.  重复节点（奇异系统）。尝试使用节点 $[0, 0, 1]$ 和 $p = 1$ 生成权重。由于重复节点会导致奇异矩阵，例程必须发出错误信号。报告一个表示是否正确检测到错误的布尔值。\n\n最终输出格式要求：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按上述测试套件的顺序排列：\n1.  测试用例1的浮点数最大绝对差。\n2.  测试用例2的浮点数最大绝对差。\n3.  测试用例3的布尔结果。\n4.  测试用例4的浮点数绝对误差。\n5.  测试用例5的布尔结果。\n6.  测试用例6的布尔结果。\n7.  测试用例7的布尔结果。\n\n例如，输出应如下所示：\n\"[r1,r2,r3,r4,r5,r6,r7]\".", "solution": "目标是确定有限差分公式的权重 $w_0, w_1, \\dots, w_{n-1}$，该公式用于逼近一个足够光滑的函数 $f(x)$ 在点 $x$ 处的 $p$ 阶导数。该公式如下：\n$$\nf^{(p)}(x) \\approx \\frac{1}{h^p} \\sum_{j=0}^{n-1} w_j f(x + h s_j)\n$$\n其中 $\\{s_j\\}_{j=0}^{n-1}$ 是一个由 $n$ 个不同的无量纲节点组成的模板，$h$ 是步长。推导权重的方法是要求该公式对所有最高次数为 $n-1$ 的多项式都是精确的。\n\n我们从 $f(x + \\Delta x)$ 在点 $x$ 附近的泰勒级数展开式开始：\n$$\nf(x + \\Delta x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (\\Delta x)^k\n$$\n对模板中的每个节点，代入 $\\Delta x = h s_j$，我们有：\n$$\nf(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k\n$$\n现在，我们将此展开式代入有限差分公式的求和部分：\n$$\n\\sum_{j=0}^{n-1} w_j f(x + h s_j) = \\sum_{j=0}^{n-1} w_j \\left( \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(x)}{k!} (h s_j)^k \\right)\n$$\n假设一致收敛允许交换求和顺序：\n$$\n\\sum_{j=0}^{n-1} w_j f(x + h s_j) = \\sum_{k=0}^{\\infty} \\frac{h^k f^{(k)}(x)}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right)\n$$\n完整的有限差分公式旨在逼近 $f^{(p)}(x)$，这意味着上述方程的右侧在除以 $h^p$ 后，应简化为 $f^{(p)}(x)$。因此，我们期望：\n$$\n\\frac{1}{h^p} \\sum_{k=0}^{\\infty} \\frac{h^k f^{(k)}(x)}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right) = f^{(p)}(x)\n$$\n为了使这个等式对任意函数 $f(x)$（或更具体地说，对其泰勒级数表示）成立，左侧每个导数项 $f^{(k)}(x)$ 的系数必须与右侧相应的项匹配。右侧只包含 $f^{(p)}(x)$ 项。因此，对于 $k \\neq p$，$f^{(k)}(x)$ 的系数必须为零，而 $f^{(p)}(x)$ 的系数必须为 $1$。这给了我们关于内层和（矩）的以下条件：\n- 对于 $k = p$：$f^{(p)}(x)$ 的系数是 $\\frac{1}{h^p} \\frac{h^p}{p!} \\left( \\sum_{j=0}^{n-1} w_j s_j^p \\right)$。我们将其设为 $1$。\n$$\n\\frac{1}{p!} \\left( \\sum_{j=0}^{n-1} w_j s_j^p \\right) = 1 \\implies \\sum_{j=0}^{n-1} w_j s_j^p = p!\n$$\n- 对于 $k \\neq p$：$f^{(k)}(x)$ 的系数是 $\\frac{1}{h^p} \\frac{h^k}{k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right)$。我们将其设为 $0$。\n$$\n\\frac{h^k}{h^p k!} \\left( \\sum_{j=0}^{n-1} w_j s_j^k \\right) = 0 \\implies \\sum_{j=0}^{n-1} w_j s_j^k = 0\n$$\n对 $k = 0, 1, \\dots, n-1$ 施加这些条件。这提供了一个关于 $n$ 个未知权重 $w_0, w_1, \\dots, w_{n-1}$ 的 $n$ 个线性方程组。该系统可以用矩阵形式写成 $\\mathbf{A} \\mathbf{w} = \\mathbf{b}$，其中：\n$$\n\\mathbf{A} =\n\\begin{pmatrix}\ns_0^0  & s_1^0  & \\dots  & s_{n-1}^0 \\\\\ns_0^1  & s_1^1  & \\dots  & s_{n-1}^1 \\\\\n\\vdots  & \\vdots  & \\ddots  & \\vdots \\\\\ns_0^{n-1}  & s_1^{n-1}  & \\dots  & s_{n-1}^{n-1}\n\\end{pmatrix}\n, \\quad\n\\mathbf{w} =\n\\begin{pmatrix}\nw_0 \\\\\nw_1 \\\\\n\\vdots \\\\\nw_{n-1}\n\\end{pmatrix}\n, \\quad\n\\mathbf{b} =\n\\begin{pmatrix}\n0 \\\\\n\\vdots \\\\\np! \\\\\n\\vdots \\\\\n0\n\\end{pmatrix}\n$$\n矩阵 $\\mathbf{A}$ 是一个范德蒙矩阵。当且仅当所有节点 $s_j$ 互不相同时，其行列式非零。问题陈述保证了对于有效输入，这一点是成立的，从而确保权重 $\\mathbf{w}$ 有唯一解。向量 $\\mathbf{b}$ 是一个零向量，除了索引为 $p$ 的位置（第 $(p+1)$ 行）的元素为 $p!$。\n\n问题指出，输入的模板节点是整数。为获得精确的权重，必须使用有理数算术来求解线性系统。这涉及到用有理数构造矩阵 $\\mathbf{A}$ 和向量 $\\mathbf{b}$，并使用像高斯消元法这样的算法在有理数域上进行运算。Python的 `fractions` 模块为此提供了必要的工具。\n\n实现将包括一个主例程，用于验证输入、构建线性系统并求解。\n输入验证必须确保两个条件：\n1.  所有模板节点 $s_j$ 必须是互不相同的。如果 `len(set(s))` 不等于 `len(s)`，则范德蒙矩阵 $\\mathbf{A}$ 是奇异的，不存在唯一解。\n2.  导数的阶数 $p$ 必须在范围 $0 \\leq p < n$ 内，其中 $n$ 是模板点的数量。这是因为 $n$ 个点可以唯一确定一个最高次数为 $n-1$ 的多项式，而这 $n$ 个约束条件被用来确定 $n$ 个权重。不可能满足导数阶数 $p \\geq n$ 的矩条件。\n\n对于有效的输入，程序如下：\n1.  定义 $n$ 为模板 $s$ 中的节点数。\n2.  构造 $n \\times n$ 矩阵 $\\mathbf{A}$，其中 $A_{kj} = s_j^k$ 对于 $k, j \\in \\{0, \\dots, n-1\\}$。每个元素都表示为一个有理数。\n3.  构造 $n \\times 1$ 向量 $\\mathbf{b}$，其中 $b_k = 0$ 对于 $k \\neq p$，$b_p = p!$。每个元素也是一个有理数。\n4.  使用基于有理数算术的线性求解器（如带回代的高斯消元法）求解线性系统 $\\mathbf{A} \\mathbf{w} = \\mathbf{b}$ 以得到 $\\mathbf{w}$。\n得到的向量 $\\mathbf{w}$ 将包含指定有限差分方案的精确有理数权重。然后，这些权重将用于执行测试套件所要求的计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom fractions import Fraction\nimport math\n\nclass FiniteDifferenceError(ValueError):\n    \"\"\"Custom exception for finite difference routine errors.\"\"\"\n    pass\n\ndef _solve_rational_system(A, b):\n    \"\"\"\n    Solves a linear system Ax=b where A and b contain Fraction objects.\n    Uses Gaussian elimination with back substitution.\n    \"\"\"\n    n = len(b)\n    # Create an augmented matrix\n    M = [row + [val] for row, val in zip(A, b)]\n\n    # Forward elimination\n    for i in range(n):\n        # Find a non-zero pivot\n        pivot_row = i\n        while pivot_row < n and M[pivot_row][i] == Fraction(0):\n            pivot_row += 1\n        \n        if pivot_row == n:\n            # This case is pre-empted by the duplicate node check,\n            # but is included for solver robustness.\n            raise np.linalg.LinAlgError(\"Singular matrix\")\n\n        # Swap the current row with the pivot row\n        M[i], M[pivot_row] = M[pivot_row], M[i]\n        \n        # Eliminate entries below the pivot\n        pivot_val = M[i][i]\n        for j in range(i + 1, n):\n            factor = M[j][i] / pivot_val\n            # M[j][i] = Fraction(0) # Not strictly necessary\n            for k in range(i + 1, n + 1):\n                M[j][k] -= factor * M[i][k]\n\n    # Backward substitution\n    x = [Fraction(0)] * n\n    for i in range(n - 1, -1, -1):\n        s = sum(M[i][j] * x[j] for j in range(i + 1, n))\n        x[i] = (M[i][n] - s) / M[i][i]\n        \n    return x\n\ndef generate_weights(s, p):\n    \"\"\"\n    Generates finite difference weights for a given stencil and derivative order.\n    \n    Args:\n        s (list or tuple of int): The stencil nodes.\n        p (int): The order of the derivative.\n        \n    Returns:\n        list of Fraction: The calculated weights.\n    \n    Raises:\n        FiniteDifferenceError: If inputs are invalid.\n    \"\"\"\n    n = len(s)\n    \n    # Input validation\n    if len(set(s)) != n:\n        raise FiniteDifferenceError(\"Stencil nodes must be distinct.\")\n    if not (0 <= p < n):\n        raise FiniteDifferenceError(f\"Derivative order p must be in [0, n-1]. Got p={p}, n={n}.\")\n\n    # Construct the Vandermonde matrix A\n    A = []\n    for k in range(n):\n        A.append([Fraction(node)**k for node in s])\n\n    # Construct the right-hand side vector b\n    b = [Fraction(0)] * n\n    b[p] = Fraction(math.factorial(p))\n    \n    # The system is A_transpose * w = b. Solve A.T w = b, which is w.T A = b.T\n    # This means we solve A^T x = b for x, where A is the matrix from the loop above.\n    # The matrix in the problem is A_kj = s_j^k. The system is sum_j A_kj w_j = b_k.\n    # So A is the coefficient matrix directly.\n    # The problem description's matrix form A_ij = s_j^i has rows indexed by k and columns by j.\n    # My _solve_rational_system expects rows of A. So, I will transpose it to match my solver.\n    # Let's fix the generation of A instead. My solver solves A w = b where A_ij w_j = b_i.\n    # The system is sum_{j=0}^{n-1} w_j s_j^k = b_k.\n    # So A[k][j] should be s_j^k. My generation is A[k] is the k-th row, A[k][j] is s_j^k.\n    # So this is correct. No transpose needed.\n    \n    # The matrix A with A[k][j] = s_j^k is actually the transpose of a Vandermonde matrix.\n    # Let's call it A_gen. The system is A_gen w = b.\n    A_gen = []\n    for k in range(n):\n        A_gen.append([Fraction(node)**k for node in s])\n        \n    # The `_solve_rational_system` solves the system `A x = b` where `A` is a list of lists (rows).\n    # The system is `sum_j A_kj w_j = b_k`. In our case, `A_kj = s_j^k`.\n    # Let's check my solver input. `M` is augmented matrix, `M[row][col]`.\n    # `A` is list of rows. So `A[i]` is i-th row. `A[i][j]` is element at row i, col j.\n    # Our system matrix element `A_kj` should be `s_j^k`.\n    # This means row index is `k`, column index is `j`.\n    # So the matrix A should be constructed as `A[k][j] = s_j^k`.\n    # The inner loop iterates over `s`, which are the columns `j`.\n    # The outer loop iterates over `k`, which are the rows.\n    # The `A.append` creates a new row. So `A` is `[[s_0^0, s_1^0, ...], [s_0^1, s_1^1, ...]]`.\n    # This is correct. The `A_gen` is not needed.\n\n    return _solve_rational_system(A, b)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the final results.\n    \"\"\"\n    results = []\n\n    # Test Case 1: Central first derivative\n    p1 = 1\n    s1 = [-1, 0, 1]\n    expected_w1 = [Fraction(-1, 2), Fraction(0), Fraction(1, 2)]\n    computed_w1 = generate_weights(s1, p1)\n    diff1 = max(abs(float(c) - float(e)) for c, e in zip(computed_w1, expected_w1))\n    results.append(diff1)\n\n    # Test Case 2: Central second derivative\n    p2 = 2\n    s2 = [-1, 0, 1]\n    expected_w2 = [Fraction(1), Fraction(-2), Fraction(1)]\n    computed_w2 = generate_weights(s2, p2)\n    diff2 = max(abs(float(c) - float(e)) for c, e in zip(computed_w2, expected_w2))\n    results.append(diff2)\n\n    # Test Case 3: Forward fifth derivative\n    p3 = 5\n    s3 = [0, 1, 2, 3, 4, 5]\n    expected_w3 = [Fraction(v) for v in [-1, 5, -10, 10, -5, 1]]\n    computed_w3 = generate_weights(s3, p3)\n    exact_match3 = (computed_w3 == expected_w3)\n    results.append(exact_match3)\n\n    # Test Case 4: Numerical accuracy\n    p4 = 5\n    s4 = [0, 1, 2, 3, 4, 5]\n    h4 = 1e-3\n    x4 = 0.0\n    weights4 = generate_weights(s4, p4)\n    # f(x) = e^x, f^(5)(x) = e^x, f^(5)(0) = 1\n    approx4 = sum(float(w) * np.exp(x4 + h4 * node) for w, node in zip(weights4, s4)) / (h4**p4)\n    exact4 = 1.0\n    error4 = abs(approx4 - exact4)\n    results.append(error4)\n\n    # Test Case 5: Polynomial exactness on nonuniform stencil\n    p5 = 2\n    s5 = [-2, -1, 0, 1, 3, 4]\n    h5 = 0.1\n    x5 = 0.0\n    weights5 = generate_weights(s5, p5)\n    # f(x) = x^2, f''(x) = 2, f''(0) = 2\n    # The formula should be exact for polynomials of degree  n=6\n    f_vals5 = [(x5 + h5 * node)**2 for node in s5]\n    approx5 = sum(float(w) * fv for w, fv in zip(weights5, f_vals5)) / (h5**p5)\n    exact5 = 2.0\n    poly_exact5 = abs(approx5 - exact5)  1e-12\n    results.append(poly_exact5)\n\n    # Test Case 6: Invalid derivative order\n    error_detected6 = False\n    try:\n        generate_weights(s=[0, 1], p=3)\n    except FiniteDifferenceError:\n        error_detected6 = True\n    results.append(error_detected6)\n\n    # Test Case 7: Duplicate nodes\n    error_detected7 = False\n    try:\n        generate_weights(s=[0, 0, 1], p=1)\n    except FiniteDifferenceError:\n        error_detected7 = True\n    results.append(error_detected7)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3238803"}, {"introduction": "有限差分法建立在函数光滑性的假设之上。本练习将以绝对值函数 $f(x) = |x|$ 为关键案例，探索当这一基本假设被违背时会发生什么。您将诊断标准中心差分格式在函数“拐点”处的灾难性失效，并设计一种更稳健的自适应方法，从而在数值方法的实际应用中吸取至关重要的一课。 [@problem_id:3239009]", "problem": "考虑在间距为 $h  0$ 的均匀网格上，对函数 $f(x) = |x|$ 的三阶导数 $f^{(3)}(x)$ 进行数值逼近的问题。该问题的基本基础是足够光滑的函数 $f$ 在点 $x$ 附近的泰勒展开，即对于任意整数 $k \\ge 0$：\n$$\nf(x + j h) = \\sum_{m=0}^{\\infty} \\frac{f^{(m)}(x)}{m!} (j h)^m,\n$$\n其中 $j$ 是索引网格点的整数。一个在 $x$ 点处、模板偏移量为 $\\{j_0, j_1, \\dots, j_{n-1}\\}$ 的 $m$ 阶通用有限差分估计量，旨在寻找满足矩匹配条件的权重 $\\{a_0, a_1, \\dots, a_{n-1}\\}$：\n$$\n\\sum_{i=0}^{n-1} a_i j_i^k = \\begin{cases}\nm!  \\text{if } k = m, \\\\\n0  \\text{if } 0 \\le k \\le n-1,\\ k \\ne m,\n\\end{cases}\n$$\n使得有限差分逼近\n$$\nD_m[f](x; h) = \\frac{1}{h^m} \\sum_{i=0}^{n-1} a_i f(x + j_i h)\n$$\n对最高为 $n-1$ 次的多项式是精确的，并且截断误差为 $O(h^{n-m})$，当模板的对称性导致额外的偶数阶矩抵消时，误差会更小。当 $f$ 不光滑时，泰勒展开在不可微点或跨越不可微点时不再成立，而跨越这些点的有限差分估计量可能会灾难性地失败。\n\n您的任务是：\n- 使用不包含 $x$ 本身的对称模板（具体偏移量为 $\\{-2, -1, 1, 2\\}$）为 $f^{(3)}(x)$ 构建一个中心有限差分估计量。以泰勒展开为基础，通过满足最高3次的矩匹配条件来推导权重。\n- 诊断当该中心估计量的模板跨越函数 $f(x) = |x|$ 的非光滑点 $x=0$ 时的失效情况。解释为什么由于缺乏光滑性，该逼近会产生巨大的虚假值或误导性的抵消。\n- 设计一个改进的局部估计量，通过使用单边模板来避开奇点，这些模板被选择为完全位于尖点的一个光滑侧。当 $x \\ge 0$ 时，使用前向偏移 $\\{0, 1, 2, 3, 4\\}$；当 $x  0$ 时，使用后向偏移 $\\{-4, -3, -2, -1, 0\\}$。使用相同的矩匹配原理推导单边权重。\n- 实现一个诊断程序，使用区间测试 $[x - 2h, x + 2h]$ 是否包含 $0$ 来检测中心模板是否跨越非光滑点。此外，计算尺度归一化的二阶差分\n$$\nS(x; h) = \\frac{|f(x+h) - 2 f(x) + f(x-h)|}{h},\n$$\n并讨论对于 $f(x) = |x|$，当 $h$ 细化时，其在 $x=0$ 附近的行为如何区分光滑与非光滑行为。\n- 对于每个测试用例，计算：\n    1. 使用偏移量 $\\{-2, -1, 1, 2\\}$ 的中心估计量值 $D_3^{\\text{central}}[f](x; h)$。\n    2. 使用偏移量 $\\{-4, -3, -2, -1, 0\\}$ 的左单边估计量 $D_3^{\\text{left}}[f](x; h)$。\n    3. 使用偏移量 $\\{0, 1, 2, 3, 4\\}$ 的右单边估计量 $D_3^{\\text{right}}[f](x; h)$。\n    4. 改进的局部估计量 $D_3^{\\text{mod}}[f](x; h)$，当 $x \\ge 0$ 时选择右单边估计量，当 $x  0$ 时选择左单边估计量，否则在模板不跨越 $0$ 时选择中心估计量。\n    5. 一个布尔值，指示中心模板是否跨越 $0$，即 $x - 2h \\le 0 \\le x + 2h$ 是否成立。\n- 使用函数 $f(x) = |x|$，无角度和无单位。\n\n测试套件：\n- 情况 1：$x = 1.0$，$h = 0.1$（远离 $0$ 的光滑区域；中心模板不跨越尖点）。\n- 情况 2：$x = 0.05$，$h = 0.1$（靠近 $0$；中心模板跨越尖点）。\n- 情况 3：$x = 0.0$，$h = 0.1$（恰好在尖点处；中心模板包含对称环绕 $0$ 的点）。\n- 情况 4：$x = 0.05$，$h = 0.01$（靠近 $0$，但由于 $h$ 很小，中心模板不跨越）。\n- 情况 5：$x = -0.075$，$h = 0.05$（负半轴；中心模板跨越尖点）。\n\n答案类型：\n- 对于每个测试用例，项目 1 到 4 的输出为浮点数，项目 5 的输出为布尔值。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个包含五个子列表的列表，每个子列表对应一个测试用例，且每个子列表中的元素顺序固定为\n$$\n\\left[ D_3^{\\text{central}},\\ D_3^{\\text{left}},\\ D_3^{\\text{right}},\\ D_3^{\\text{mod}},\\ \\text{kink\\_crossed} \\right],\n$$\n整个列表应精确地以 Python 列表字面量的形式打印，例如\n$$\n\\big[ [\\dots], [\\dots], [\\dots], [\\dots], [\\dots] \\big].\n$$", "solution": "该问题要求对函数 $f(x) = |x|$ 的三阶导数 $f^{(3)}(x)$ 推导、分析和实现有限差分估计量。问题的核心在于解决标准估计量在 $x=0$ 这一不可微点处的失效问题。\n\n### **1. $f^{(3)}(x)$ 的中心有限差分估计量**\n\nm 阶导数的有限差分估计量 $D_m[f](x; h)$ 是通过对附近网格点上的函数值进行加权求和来构建的。对于一个使用对称模板偏移量 $\\{j_i\\} = \\{-2, -1, 1, 2\\}$ 的 $f^{(3)}(x)$ 估计量，我们寻求权重 $\\{a_{-2}, a_{-1}, a_1, a_2\\}$，使得该逼近对低次多项式是精确的。这被形式化为矩匹配条件：\n$$\n\\sum_{j \\in \\{-2, -1, 1, 2\\}} a_j j^k = 3! \\cdot \\delta_{k3} \\quad \\text{for } k=0, 1, 2, 3.\n$$\n这为权重导出了一个线性方程组：\n\\begin{itemize}\n    \\item $k=0$ (常数多项式): $a_{-2} + a_{-1} + a_1 + a_2 = 0$\n    \\item $k=1$ (线性多项式): $-2a_{-2} - a_{-1} + a_1 + 2a_2 = 0$\n    \\item $k=2$ (二次多项式): $4a_{-2} + a_{-1} + a_1 + 4a_2 = 0$\n    \\item $k=3$ (三次多项式): $-8a_{-2} - a_{-1} + a_1 + 8a_2 = 3! = 6$\n\\end{itemize}\n对于逼近奇数阶导数（$m=3$）的对称模板，权重必须是反对称的，即 $a_{-j} = -a_j$。因此，$a_{-2} = -a_2$ 且 $a_{-1} = -a_1$。\n将此对称性代入方程组：\n\\begin{itemize}\n    \\item $k=0$: $(-a_2) + (-a_1) + a_1 + a_2 = 0$。此式自动满足。\n    \\item $k=1$: $-2(-a_2) - (-a_1) + a_1 + 2a_2 = 2a_2 + a_1 + a_1 + 2a_2 = 4a_2 + 2a_1 = 0 \\implies a_1 = -2a_2$。\n    \\item $k=2$: $4(-a_2) + (-a_1) + a_1 + 4a_2 = 0$。此式自动满足。\n    \\item $k=3$: $-8(-a_2) - (-a_1) + a_1 + 8a_2 = 8a_2 + a_1 + a_1 + 8a_2 = 16a_2 + 2a_1 = 6$。\n\\end{itemize}\n将 $a_1 = -2a_2$ 代入 $k=3$ 的方程得到：\n$$\n16a_2 + 2(-2a_2) = 12a_2 = 6 \\implies a_2 = \\frac{1}{2}.\n$$\n由此，我们求得其他权重：$a_1 = -2a_2 = -1$，$a_{-1} = -a_1 = 1$，以及 $a_{-2} = -a_2 = -\\frac{1}{2}$。\n因此，模板 $\\{-2, -1, 1, 2\\}$ 的权重为 $\\{-\\frac{1}{2}, 1, -1, \\frac{1}{2}\\}$。中心估计量为：\n$$\nD_3^{\\text{central}}[f](x; h) = \\frac{1}{h^3} \\left( -\\frac{1}{2}f(x-2h) + f(x-h) - f(x+h) + \\frac{1}{2}f(x+2h) \\right)\n$$\n这可以重写为：\n$$\nD_3^{\\text{central}}[f](x; h) = \\frac{-f(x-2h) + 2f(x-h) - 2f(x+h) + f(x+2h)}{2h^3}.\n$$\n\n### **2. 中心估计量对 $f(x) = |x|$ 的失效分析**\n\n有限差分公式的推导依赖于泰勒级数展开在整个模板上对函数 $f$ 均有效。函数 $f(x)=|x|$ 在 $x=0$ 处有一个“尖点”；它的一阶导数是不连续的（$f'(x) = \\text{sgn}(x)$），且其更高阶的导数在 $x=0$ 处在经典意义下是未定义的。在远离 $x=0$ 的地方，所有高于一阶的导数均为零。\n\n当中心模板 $[x-2h, x+2h]$ 包含点 $x=0$ 时，光滑性的假设被违反。该公式将尖点处的急剧变化误解为存在巨大三阶导数的证据。例如，对于 $x=0.05$ 和 $h=0.1$，模板为 $[-0.15, 0.25]$，它跨越了 $0$。该估计量得出：\n$$\nD_3^{\\text{central}}[f](0.05; 0.1) = \\frac{-|-0.15| + 2|-0.05| - 2|0.15| + |0.25|}{2(0.1)^3} = \\frac{-0.15 + 0.1 - 0.3 + 0.25}{0.002} = \\frac{-0.1}{0.002} = -50.\n$$\n这个巨大的虚假值与对于任何 $x0$ 都成立的真实导数值 $0$ 大相径庭。一个特殊情况发生在 $x=0$ 处，此时 $f(x)=|x|$ 的对称性和算子的反对称性导致了抵消，得出 $D_3^{\\text{central}}[f](0; h) = 0$。虽然这个结果恰好是正确的，但它是一种对称性的巧合，而非稳健性的体现。\n\n### **3. 改进的单边估计量**\n\n为避免奇点，改进的估计量可以使用完全位于函数光滑部分的单边模板。\n\n**右侧（前向）估计量：** 对于 $x \\ge 0$，我们可以使用正半轴上的模板，例如 $\\{0, 1, 2, 3, 4\\}$。我们通过求解方程组 $\\sum_{i=0}^4 a_i j_i^k = 3! \\delta_{k3}$（其中 $k=0, \\dots, 4$）来寻找权重 $\\{a_0, a_1, a_2, a_3, a_4\\}$。这是一个 $5 \\times 5$ 的范德蒙型线性系统。求解该系统得到的权重为：\n$$\n\\{a_0, a_1, a_2, a_3, a_4\\} = \\left\\{-\\frac{5}{2}, 9, -12, 7, -\\frac{3}{2}\\right\\}.\n$$\n右侧估计量为：\n$$\nD_3^{\\text{right}}[f](x; h) = \\frac{1}{h^3} \\left(-\\frac{5}{2}f(x) + 9f(x+h) - 12f(x+2h) + 7f(x+3h) - \\frac{3}{2}f(x+4h)\\right).\n$$\n\n**左侧（后向）估计量：** 对于 $x  0$，我们使用负半轴上的模板，例如 $\\{-4, -3, -2, -1, 0\\}$。根据对称性，其权重是前向权重的相反数并反向排列：\n$$\n\\{a_{-4}, a_{-3}, a_{-2}, a_{-1}, a_0\\} = \\left\\{\\frac{3}{2}, -7, 12, -9, \\frac{5}{2}\\right\\}.\n$$\n左侧估计量为：\n$$\nD_3^{\\text{left}}[f](x; h) = \\frac{1}{h^3} \\left(\\frac{3}{2}f(x-4h) - 7f(x-3h) + 12f(x-2h) - 9f(x-h) + \\frac{5}{2}f(x)\\right).\n$$\n由于这些单边模板完全位于光滑区域内（其中 $f(x)=x$ 或 $f(x)=-x$），并且两个公式对最高4次的多项式都是精确的，它们将正确地计算出三阶导数为 $0$。\n\n问题为改进的估计量 $D_3^{\\text{mod}}$ 给出的规则略显模糊。最合理的解释，与自适应模板的标准数值实践一致，是当中心模板不含 $x=0$ 处的奇点时使用中心估计量，否则切换到合适的单边估计量。实现的逻辑是：如果中心模板区间 $[x-2h, x+2h]$ 包含 $0$，则对于 $x \\ge 0$ 使用右侧估计量，对于 $x  0$ 使用左侧估计量；否则，使用中心估计量。\n\n### **4. 尖点检测与尺度归一化的二阶差分**\n\n检测中心模板是否跨越 $x=0$ 处尖点的一个简单诊断方法是检查区间 $[x-2h, x+2h]$ 是否包含 $0$，这当且仅当 $x-2h \\le 0$ 且 $x+2h \\ge 0$ 时成立，即 $|x| \\le 2h$。\n\n尺度归一化的二阶差分 $S(x; h) = \\frac{|f(x+h) - 2 f(x) + f(x-h)|}{h}$ 提供了另一种诊断非光滑性的方法。\n\\begin{itemize}\n    \\item 对于光滑函数 $f$，分子约等于 $h^2 f''(x)$，因此 $S(x; h) \\approx h |f''(x)|$，当 $h \\to 0$ 时趋于 $0$。\n    \\item 对于 $f(x)=|x|$ 在 $x=0$ 处，我们有 $S(0; h) = \\frac{|h - 0 + h|}{h} = \\frac{2h}{h} = 2$。该值是常数且非零。\n    \\item 对于 $f(x)=|x|$，在模板避开尖点的情况下（即 $|x|h$），函数是局部线性的，所以 $f(x+h) - 2f(x) + f(x-h) = 0$，因此 $S(x;h)=0$。\n\\end{itemize}\n在某点 $x$，$S(x; h)$ 在 $h \\to 0$ 时不收敛于 $0$，这清楚地表明 $f''(x)$ 在经典意义下不存在。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical differentiation problem for f(x)=|x| for a suite of test cases.\n    \"\"\"\n\n    # Define the function f(x) = |x|.\n    f = np.abs\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 0.1),    # Case 1\n        (0.05, 0.1),   # Case 2\n        (0.0, 0.1),    # Case 3\n        (0.05, 0.01),  # Case 4\n        (-0.075, 0.05) # Case 5\n    ]\n\n    all_results = []\n\n    for x, h in test_cases:\n        # 1. Central estimator: D_3^central\n        # Stencil: {-2, -1, 1, 2}, Weights: {-1/2, 1, -1, 1/2} normalized by 1/h^3.\n        # Formula: (-f(x-2h) + 2f(x-h) - 2f(x+h) + f(x+2h)) / (2h^3)\n        numerator_central = -f(x - 2*h) + 2*f(x - h) - 2*f(x + h) + f(x + 2*h)\n        d3_central = numerator_central / (2 * h**3)\n\n        # 2. Left one-sided estimator: D_3^left\n        # Stencil: {-4, -3, -2, -1, 0}, Weights: {3/2, -7, 12, -9, 5/2}\n        numerator_left = (3/2)*f(x - 4*h) - 7*f(x - 3*h) + 12*f(x - 2*h) - 9*f(x - h) + (5/2)*f(x)\n        d3_left = numerator_left / h**3\n\n        # 3. Right one-sided estimator: D_3^right\n        # Stencil: {0, 1, 2, 3, 4}, Weights: {-5/2, 9, -12, 7, -3/2}\n        numerator_right = -(5/2)*f(x) + 9*f(x + h) - 12*f(x + 2*h) + 7*f(x + 3*h) - (3/2)*f(x + 4*h)\n        d3_right = numerator_right / h**3\n        \n        # 5. Kink crossed diagnostic\n        # The central stencil [x - 2h, x + 2h] crosses the kink at 0.\n        kink_crossed = (x - 2*h = 0) and (x + 2*h = 0)\n\n        # 4. Modified localized estimator: D_3^mod\n        # If the central stencil crosses the kink, use a one-sided estimator that avoids it.\n        # Otherwise, use the more accurate central estimator.\n        if kink_crossed:\n            if x = 0:\n                d3_mod = d3_right\n            else:\n                d3_mod = d3_left\n        else:\n            d3_mod = d3_central\n\n        # Collect results for this case in the specified order.\n        case_result = [d3_central, d3_left, d3_right, d3_mod, kink_crossed]\n        all_results.append(case_result)\n\n    # Format the final output as a Python list literal string representation.\n    # To avoid spaces and use Python's native bool representation (True/False),\n    # we convert each list to its string representation and then join them.\n    result_strings = []\n    for res in all_results:\n        # Manually format each sub-list to match specification, ensuring no spaces\n        # and correct boolean representation.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]}]\"\n        result_strings.append(res_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "3239009"}]}