{"hands_on_practices": [{"introduction": "让我们从雅可比法开始，这是最基本的迭代技术之一。这项练习将指导你完成求解一个简单 $2 \\times 2$ 线性方程组的最初几个步骤。通过亲手计算，你将具体理解雅可比迭代如何使用前一步的值来同时更新所有变量[@problem_id:2182317]。", "problem": "在一个简化的经济模型中，两种相互依存的产品（我们称之为产品1和产品2）的均衡价格由一个线性方程组描述。设 $p_1$ 是产品1的价格，$p_2$ 是产品2的价格。当下列方程组成立时，达到均衡条件：\n\n$$\n5p_1 - 2p_2 = 11\n$$\n$$\n-p_1 + 4p_2 = 7\n$$\n\n为求得这些价格而不直接对矩阵求逆，可以使用一种迭代数值方法。从初始猜测值 $\\mathbf{p}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始，执行两次完整的雅可比方法迭代来近似求解均衡价格。\n\n计算向量估计值 $\\mathbf{p}^{(2)} = \\begin{pmatrix} p_1^{(2)} \\\\ p_2^{(2)} \\end{pmatrix}$。您的答案应该是一个包含两个分量 $p_1^{(2)}$ 和 $p_2^{(2)}$ 的行矩阵，按此顺序排列，并以精确分数形式表示。", "solution": "我们将线性系统写成分量形式，并重新整理每个方程，将变量分离到左边：\n$$\n5p_{1}-2p_{2}=11 \\;\\;\\Rightarrow\\;\\; p_{1}=\\frac{11+2p_{2}}{5}, \\qquad -p_{1}+4p_{2}=7 \\;\\;\\Rightarrow\\;\\; p_{2}=\\frac{7+p_{1}}{4}.\n$$\n雅可比迭代仅使用前一次的迭代值来更新每个分量。从初始值 $\\mathbf{p}^{(0)}=\\begin{pmatrix}0 \\\\ 0\\end{pmatrix}$ 开始，第一次迭代为\n$$\np_{1}^{(1)}=\\frac{11+2p_{2}^{(0)}}{5}=\\frac{11+0}{5}=\\frac{11}{5}, \\qquad\np_{2}^{(1)}=\\frac{7+p_{1}^{(0)}}{4}=\\frac{7+0}{4}=\\frac{7}{4}.\n$$\n在第二次迭代中使用这些值，\n$$\np_{1}^{(2)}=\\frac{11+2p_{2}^{(1)}}{5}=\\frac{11+2\\cdot\\frac{7}{4}}{5}=\\frac{11+\\frac{7}{2}}{5}=\\frac{\\frac{22}{2}+\\frac{7}{2}}{5}=\\frac{\\frac{29}{2}}{5}=\\frac{29}{10},\n$$\n$$\np_{2}^{(2)}=\\frac{7+p_{1}^{(1)}}{4}=\\frac{7+\\frac{11}{5}}{4}=\\frac{\\frac{35}{5}+\\frac{11}{5}}{4}=\\frac{\\frac{46}{5}}{4}=\\frac{46}{20}=\\frac{23}{10}.\n$$\n因此，经过两次雅可比迭代后，\n$$\n\\mathbf{p}^{(2)}=\\begin{pmatrix}\\frac{29}{10} \\\\ \\frac{23}{10}\\end{pmatrix}.\n$$\n作为包含按顺序排列的两个分量的行矩阵，结果为 $\\begin{pmatrix}\\frac{29}{10}  \\frac{23}{10}\\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{29}{10}  \\frac{23}{10} \\end{pmatrix}}$$", "id": "2182317"}, {"introduction": "在雅可比法的基础上，高斯-赛德尔法通常能提供更快的收敛速度。在本练习中，你将应用高斯-赛德尔迭代，并特别关注其关键特征：在当前迭代中，一旦有新的分量值可用，就立即使用它[@problem_id:2182363]。这种即时反馈机制是它与雅可比法的主要区别。", "problem": "一家物流公司正在分析其三个相互连接的仓库的稳态库存水平。库存水平用向量 $\\mathbf{x} = (x_1, x_2, x_3)$ 表示，并满足以下线性方程组：\n$$5x_1 - x_2 + 2x_3 = 12$$\n$$2x_1 + 8x_2 - x_3 = -25$$\n$$-x_1 + x_2 + 4x_3 = 15$$\n为了近似求解，公司的分析师决定使用高斯-赛德尔迭代法。他们从库存水平的初始估计向量 $\\mathbf{x}^{(0)} = (1, 2, 3)$ 开始。\n\n你的任务是基于所提供的初始猜测值，计算第一次迭代的结果 $\\mathbf{x}^{(1)} = (x_1^{(1)}, x_2^{(1)}, x_3^{(1)})$。请将向量 $\\mathbf{x}^{(1)}$ 的分量表示为最简分数形式。", "solution": "我们将每个方程解出其主变量：\n$$x_{1}=\\frac{12+x_{2}-2x_{3}}{5},\\quad x_{2}=\\frac{-25-2x_{1}+x_{3}}{8},\\quad x_{3}=\\frac{15+x_{1}-x_{2}}{4}.$$\n高斯-赛德尔法使用最新的可用值进行顺序更新。以 $\\mathbf{x}^{(0)}=(1,2,3)$ 开始计算：\n首先，使用 $x_{2}^{(0)}$ 和 $x_{3}^{(0)}$，\n$$x_{1}^{(1)}=\\frac{12+x_{2}^{(0)}-2x_{3}^{(0)}}{5}=\\frac{12+2-2\\cdot 3}{5}=\\frac{8}{5}.$$\n接下来，使用 $x_{1}^{(1)}$ 和 $x_{3}^{(0)}$，\n$$x_{2}^{(1)}=\\frac{-25-2x_{1}^{(1)}+x_{3}^{(0)}}{8}=\\frac{-25-2\\cdot \\frac{8}{5}+3}{8}=\\frac{-126/5}{8}=-\\frac{63}{20}.$$\n最后，使用 $x_{1}^{(1)}$ 和 $x_{2}^{(1)}$，\n$$x_{3}^{(1)}=\\frac{15+x_{1}^{(1)}-x_{2}^{(1)}}{4}=\\frac{15+\\frac{8}{5}-\\left(-\\frac{63}{20}\\right)}{4}=\\frac{395/20}{4}=\\frac{79}{16}.$$\n因此，$\\mathbf{x}^{(1)}=\\left(\\frac{8}{5},-\\frac{63}{20},\\frac{79}{16}\\right)$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{8}{5}  -\\frac{63}{20}  \\frac{79}{16}\\end{pmatrix}}$$", "id": "2182363"}, {"introduction": "虽然像高斯-赛德尔这样的方法很强大，但它们的收敛性并非总是得到保证，特别是对于非对角占优的系统。这项高级实践将从手动计算过渡到计算探索，展示了迭代求解器一个至关重要的实际问题：方程的顺序可以极大地影响收敛性[@problem_id:3245080]。通过测试不同的行排列，你将亲眼看到一个简单的重新排序如何决定一个解是否能被找到。", "problem": "考虑线性系统 $A x = b$，其中 $A \\in \\mathbb{R}^{3 \\times 3}$ 和 $b \\in \\mathbb{R}^{3}$ 由下式给出\n$$\nA = \\begin{bmatrix}\n0  1  4 \\\\\n2  1  -1 \\\\\n1  -3  2\n\\end{bmatrix}, \\quad\nb = \\begin{bmatrix}\n3 \\\\\n-1 \\\\\n2\n\\end{bmatrix}.\n$$\n该系统不是行严格对角占优的。高斯-赛德尔方法源于将矩阵 $A$ 分裂为 $A = D + L + U$，其中 $D$ 是 $A$ 的对角部分，$L$ 是 $A$ 的严格下三角部分，$U$ 是 $A$ 的严格上三角部分。高斯-赛德尔迭代定义为\n$$\n(D + L) x^{(k+1)} = b - U x^{(k)}.\n$$\n这定义了高斯-赛德尔迭代矩阵\n$$\nT_{\\mathrm{GS}} = - (D + L)^{-1} U,\n$$\n以及误差迭代 $e^{(k+1)} = T_{\\mathrm{GS}} e^{(k)}$，其中 $e^{(k)} = x^{(k)} - x^\\star$ 且 $x^\\star$ 是精确解。如果谱半径 $\\rho(T_{\\mathrm{GS}})  1$，则该方法的范数收敛性得到保证。对于对称正定 (SPD) 矩阵，收敛性是有保证的，但对于一般的非对角占优矩阵，收敛性可能取决于方程和未知数的排序。\n\n在本问题中，您将探究行重排（方程重排）对上述特定非对角占优系统的高斯-赛德尔方法收敛性的影响。行重排由一个置换矩阵 $P$ 表示，它重排 $A$ 和 $b$ 的行以产生置换后的系统\n$$\nA_p = P A, \\quad b_p = P b.\n$$\n对于每个置换，高斯-赛德尔方法应用于置换后的系统 $A_p x = b_p$，使用相同的变量顺序（即列不进行置换）。如果来自矩阵分裂 $A_p = D_p + L_p + U_p$ 的 $(D_p + L_p)$ 是奇异的，则高斯-赛德尔步骤不是良定义的，迭代将中断。\n\n实现一个程序，对下面测试套件中的每个置换执行以下操作：\n- 构造置换后的系统 $A_p x = b_p$。\n- 计算高斯-赛德尔迭代矩阵 $T_{\\mathrm{GS}} = - (D_p + L_p)^{-1} U_p$ 及其谱半径 $\\rho(T_{\\mathrm{GS}})$。如果 $(D_p + L_p)$ 是奇异的，则将 $\\rho(T_{\\mathrm{GS}})$ 报告为非数字 (NaN)。\n- 从初始猜测 $x^{(0)} = \\begin{bmatrix} 0  0  0 \\end{bmatrix}^\\top$ 开始运行高斯-赛德尔方法，最大迭代次数为 $N_{\\max} = 200$，残差的欧几里得范数 $\\|A_p x^{(k)} - b_p\\|_2$ 的容差为 $\\varepsilon = 10^{-8}$。如果残差范数低于 $\\varepsilon$，则声明收敛。如果由于 $(D_p + L_p)$ 奇异导致迭代矩阵未良定义，则声明不收敛并将残差报告为 NaN。\n\n测试套件（行置换指定为索引顺序）：\n- 情况 0：$(0, 1, 2)$，单位行序。\n- 情况 1：$(1, 0, 2)$，交换前两行。\n- 情况 2：$(2, 1, 0)$，反转行序。\n\n对于每种情况，按顺序产生三个输出：\n- $\\rho(T_{\\mathrm{GS}})$，以浮点数形式（如果未定义则为 NaN），\n- 一个布尔值，指示高斯-赛德尔方法是否在 $N_{\\max}$ 次迭代内对容差 $\\varepsilon$ 收敛，\n- 最终残差范数 $\\|A_p x^{(k)} - b_p\\|_2$，以浮点数形式（如果未定义则为 NaN）。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序如下\n$$\n[\\rho_0, \\mathrm{conv}_0, r_0, \\rho_1, \\mathrm{conv}_1, r_1, \\rho_2, \\mathrm{conv}_2, r_2],\n$$\n其中 $\\rho_i$ 是情况 $i$ 的谱半径，$\\mathrm{conv}_i$ 是情况 $i$ 的布尔收敛指示符，而 $r_i$ 是情况 $i$ 的最终残差范数。此问题不涉及物理单位。不使用角度。不使用百分比。", "solution": "该问题要求分析用于求解线性系统 $A x = b$ 的高斯-赛德尔迭代法，其中矩阵 $A$ 和向量 $b$ 由下式给出：\n$$\nA = \\begin{bmatrix}\n0  1  4 \\\\\n2  1  -1 \\\\\n1  -3  2\n\\end{bmatrix}, \\quad\nb = \\begin{bmatrix}\n3 \\\\\n-1 \\\\\n2\n\\end{bmatrix}.\n$$\n问题的核心是研究重排方程（即 $A$ 和 $b$ 的行）如何影响该方法的收敛性。将对 3 种特定的行置换进行分析。对于每种置换，我们必须计算高斯-赛德尔迭代矩阵的谱半径，确定该方法是否收敛，并报告最终的残差范数。\n\n高斯-赛德尔方法基于将矩阵 $A$ 分裂为 $A = D + L + U$，其中 $D$ 是对角部分，$L$ 是严格下三角部分，$U$ 是严格上三角部分。对于一个置换后的系统 $A_p x = b_p$，其中 $A_p = P A$ 且 $b_p = P b$（$P$ 为置换矩阵），其分裂为 $A_p = D_p + L_p + U_p$。高斯-赛德尔迭代定义为：\n$$\nx^{(k+1)} = (D_p + L_p)^{-1} (b_p - U_p x^{(k)}).\n$$\n此迭代仅当矩阵 $(D_p + L_p)$ 可逆时才是良定义的。由于 $(D_p + L_p)$ 是一个下三角矩阵，其行列式是对角元素的乘积。这些元素与 $A_p$ 的对角元素相同。因此，当且仅当置换后矩阵 $A_p$ 的所有对角元素都非零时，该迭代才是良定义的。\n\n如果迭代是良定义的，其收敛性由迭代矩阵 $T_{\\mathrm{GS}} = -(D_p + L_p)^{-1} U_p$ 的谱半径 $\\rho(T_{\\mathrm{GS}})$ 决定。当且仅当 $\\rho(T_{\\mathrm{GS}})  1$ 时，该方法对任何初始猜测都保证收敛。\n\n迭代过程从初始猜测 $x^{(0)} = \\begin{bmatrix} 0  0  0 \\end{bmatrix}^\\top$ 开始。如果残差的欧几里得范数 $\\|r^{(k)}\\|_2 = \\|A_p x^{(k)} - b_p\\|_2$ 小于容差 $\\varepsilon = 10^{-8}$，或者迭代次数达到最大值 $N_{\\max} = 200$，则迭代终止。\n\n我们现在分析 3 种指定情况。\n\n**情况 0：单位置换 $(0, 1, 2)$**\n\n系统保持不变：$A_p = A$ 且 $b_p = b$。\n$$\nA_p = \\begin{bmatrix}\n0  1  4 \\\\\n2  1  -1 \\\\\n1  -3  2\n\\end{bmatrix}\n$$\n$A_p$ 的第一个对角元素是 $a_{00} = 0$。矩阵 $(D_p + L_p)$ 为：\n$$\nD_p + L_p = \\begin{bmatrix} 0  0  0 \\\\ 2  1  0 \\\\ 1  -3  2 \\end{bmatrix}\n$$\n该矩阵的行列式为 $\\det(D_p + L_p) = 0 \\cdot 1 \\cdot 2 = 0$，因此它是奇异的。逆矩阵 $(D_p + L_p)^{-1}$ 不存在，高斯-赛德尔迭代矩阵 $T_{\\mathrm{GS}}$ 不是良定义的。因此，无法执行迭代。\n\n-   谱半径 $\\rho(T_{\\mathrm{GS}})$：非数字 (NaN)。\n-   收敛性：假 (False)，因为方法中断。\n-   最终残差范数：非数字 (NaN)。\n\n**情况 1：置换 $(1, 0, 2)$**\n\n此置换交换了 $A$ 和 $b$ 的前两行。\n$$\nA_p = \\begin{bmatrix}\n2  1  -1 \\\\\n0  1  4 \\\\\n1  -3  2\n\\end{bmatrix}, \\quad\nb_p = \\begin{bmatrix}\n-1 \\\\\n3 \\\\\n2\n\\end{bmatrix}\n$$\n$A_p$ 的对角元素为 $2$、$1$ 和 $2$，均为非零值。迭代是良定义的。矩阵分裂得到：\n$$\nD_p + L_p = \\begin{bmatrix} 2  0  0 \\\\ 0  1  0 \\\\ 1  -3  2 \\end{bmatrix}, \\quad\nU_p = \\begin{bmatrix} 0  1  -1 \\\\ 0  0  4 \\\\ 0  0  0 \\end{bmatrix}\n$$\n$(D_p + L_p)$ 的逆矩阵为：\n$$\n(D_p + L_p)^{-1} = \\begin{bmatrix} 1/2  0  0 \\\\ 0  1  0 \\\\ -1/4  3/2  1/2 \\end{bmatrix}\n$$\n迭代矩阵 $T_{\\mathrm{GS}}$ 为：\n$$\nT_{\\mathrm{GS}} = - (D_p + L_p)^{-1} U_p = - \\begin{bmatrix} 1/2  0  0 \\\\ 0  1  0 \\\\ -1/4  3/2  1/2 \\end{bmatrix} \\begin{bmatrix} 0  1  -1 \\\\ 0  0  4 \\\\ 0  0  0 \\end{bmatrix} = \\begin{bmatrix} 0  -1/2  1/2 \\\\ 0  0  -4 \\\\ 0  1/4  -25/4 \\end{bmatrix}\n$$\n$T_{\\mathrm{GS}}$ 的特征值 $\\lambda$ 可通过 $\\det(T_{\\mathrm{GS}} - \\lambda I) = 0$ 求得。一个特征值是 $\\lambda_1 = 0$。另外两个是右下角 $2 \\times 2$ 子矩阵的特征值，由特征方程 $\\lambda^2 + (25/4)\\lambda + 1 = 0$ 给出。其根为 $\\lambda_{2,3} = \\frac{-25 \\pm \\sqrt{561}}{8}$。\n谱半径是这些特征值绝对值的最大值：\n$$\n\\rho(T_{\\mathrm{GS}}) = \\max \\left( |0|, \\left| \\frac{-25 + \\sqrt{561}}{8} \\right|, \\left| \\frac{-25 - \\sqrt{561}}{8} \\right| \\right) = \\frac{25 + \\sqrt{561}}{8} \\approx 6.0855\n$$\n由于 $\\rho(T_{\\mathrm{GS}})  1$，高斯-赛德尔方法对于此置换将发散。\n\n-   谱半径 $\\rho(T_{\\mathrm{GS}})$: $\\approx 6.0855$。\n-   收敛性：假 (False)。\n-   最终残差范数：一个很大的值，通过运行发散的迭代 $N_{\\max} = 200$ 步确定。\n\n**情况 2：置换 $(2, 1, 0)$**\n\n此置换反转了行的顺序。\n$$\nA_p = \\begin{bmatrix} 1  -3  2 \\\\ 2  1  -1 \\\\ 0  1  4 \\end{bmatrix}, \\quad\nb_p = \\begin{bmatrix} 2 \\\\ -1 \\\\ 3 \\end{bmatrix}\n$$\n对角元素为 $1$、$1$ 和 $4$，均为非零值。迭代是良定义的。\n$$\nD_p + L_p = \\begin{bmatrix} 1  0  0 \\\\ 2  1  0 \\\\ 0  1  4 \\end{bmatrix}, \\quad\nU_p = \\begin{bmatrix} 0  -3  2 \\\\ 0  0  -1 \\\\ 0  0  0 \\end{bmatrix}\n$$\n$(D_p + L_p)$ 的逆矩阵为：\n$$\n(D_p + L_p)^{-1} = \\begin{bmatrix} 1  0  0 \\\\ -2  1  0 \\\\ 1/2  -1/4  1/4 \\end{bmatrix}\n$$\n迭代矩阵 $T_{\\mathrm{GS}}$ 为：\n$$\nT_{\\mathrm{GS}} = - (D_p + L_p)^{-1} U_p = - \\begin{bmatrix} 1  0  0 \\\\ -2  1  0 \\\\ 1/2  -1/4  1/4 \\end{bmatrix} \\begin{bmatrix} 0  -3  2 \\\\ 0  0  -1 \\\\ 0  0  0 \\end{bmatrix} = \\begin{bmatrix} 0  3  -2 \\\\ 0  -6  5 \\\\ 0  3/2  -5/4 \\end{bmatrix}\n$$\n特征值为 $\\lambda_1 = 0$ 以及 $\\lambda^2 + (29/4)\\lambda = 0$ 的根，即 $\\lambda_2 = 0$ 和 $\\lambda_3 = -29/4 = -7.25$。特征值为 $\\{0, 0, -7.25\\}$。\n谱半径为：\n$$\n\\rho(T_{\\mathrm{GS}}) = \\max(|0|, |0|, |-7.25|) = 7.25\n$$\n由于 $\\rho(T_{\\mathrm{GS}})  1$，该方法对于此置换也将发散。\n\n-   谱半径 $\\rho(T_{\\mathrm{GS}})$：$7.25$。\n-   收敛性：假 (False)。\n-   最终残差范数：一个很大的值，通过运行发散的迭代 $N_{\\max} = 200$ 步确定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the Gauss-Seidel method for a linear system under different row permutations.\n    \"\"\"\n    A = np.array([\n        [0., 1., 4.],\n        [2., 1., -1.],\n        [1., -3., 2.]\n    ])\n    b = np.array([3., -1., 2.])\n\n    test_cases = [\n        (0, 1, 2),  # Case 0: Identity\n        (1, 0, 2),  # Case 1: Swap rows 0, 1\n        (2, 1, 0),  # Case 2: Reverse rows\n    ]\n    \n    N_max = 200\n    epsilon = 1e-8\n\n    results = []\n    \n    for perm in test_cases:\n        # Construct the permuted system\n        Ap = A[list(perm), :]\n        bp = b[list(perm)]\n\n        rho = float('nan')\n        converged = False\n        final_residual_norm = float('nan')\n        \n        # Check if Gauss-Seidel is well-defined\n        if np.any(np.diag(Ap) == 0):\n            # D_p + L_p is singular\n            results.extend([rho, converged, final_residual_norm])\n            continue\n\n        # If well-defined, proceed with analysis\n        Dp = np.diag(np.diag(Ap))\n        Lp = np.tril(Ap, k=-1)\n        Up = np.triu(Ap, k=1)\n        \n        D_plus_L_inv = np.linalg.inv(Dp + Lp)\n        T_gs = -D_plus_L_inv @ Up\n        \n        # Calculate spectral radius\n        eigenvalues = np.linalg.eigvals(T_gs)\n        rho = np.max(np.abs(eigenvalues))\n        \n        # Run Gauss-Seidel iteration\n        x = np.zeros_like(bp, dtype=float)\n        converged = False\n\n        for k in range(N_max):\n            # Check for convergence before the update step\n            residual = bp - Ap @ x\n            res_norm = np.linalg.norm(residual)\n            if res_norm  epsilon:\n                converged = True\n                final_residual_norm = res_norm\n                break\n\n            # Perform the update using forward substitution\n            x_new = np.copy(x)\n            for i in range(Ap.shape[0]):\n                sigma1 = np.dot(Ap[i, :i], x_new[:i])\n                sigma2 = np.dot(Ap[i, i+1:], x[i+1:])\n                x_new[i] = (bp[i] - sigma1 - sigma2) / Ap[i, i]\n            x = x_new\n\n        # If loop finished without convergence, set converged to False\n        # and calculate the final residual\n        if not converged:\n            final_residual_norm = np.linalg.norm(bp - Ap @ x)\n        \n        results.extend([rho, converged, final_residual_norm])\n\n    # Final print statement in the exact required format.\n    # Custom mapping for boolean values to lowercase 'true'/'false'\n    # and nan to 'nan' as str(float('nan')) does.\n    def format_val(v):\n        if isinstance(v, bool):\n            return str(v).lower()\n        return str(v)\n\n    print(f\"[{','.join(map(format_val, results))}]\")\n\nsolve()\n\n```", "id": "3245080"}]}