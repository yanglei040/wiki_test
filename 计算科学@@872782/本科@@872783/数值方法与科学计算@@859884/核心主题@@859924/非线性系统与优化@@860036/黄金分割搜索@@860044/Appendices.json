{"hands_on_practices": [{"introduction": "要真正掌握黄金分割搜索法，我们从一个基础的分析练习开始。这个练习 [@problem_id:3237350] 将引导你从第一性原理出发，推导该算法的核心机制，将其应用于一个简单的函数，并计算其可预测的收敛速度。通过亲手进行数学推导，你将对每次迭代中区间如何精确地缩小建立起坚实的直觉。", "problem": "考虑使用黄金分割法在一个闭区间上进行最小化。在区间 $[0,1]$ 上定义一个分段线性单峰函数为\n$$\nf(x) = |x - m|, \\quad m = \\frac{3}{7}.\n$$\n这个函数 $f(x)$ 在 $x=m$ 处有唯一的全局最小值。令黄金比例常数 $\\varphi$ 由代数恒等式 $\\varphi^{2}=\\varphi+1$（其中 $\\varphi0$）定义，并令 $\\tau=\\varphi^{-1}$。黄金分割搜索法初始化一个区间 $[a_{0},b_{0}]=[0,1]$，并在第 $k$ 次迭代时，在两个内部点处计算 $f$ 的值。这两个点的选择方式是，当前区间的长度与两个子区间中较大者的长度之比等于 $\\varphi$。在每次迭代中，区间的一个端点被舍弃，另一个被保留，同时确保 $m$ 始终位于新区间内。\n\n任务：\n1. 从黄金比例常数的定义性质出发（不使用任何关于内部点的快捷公式），推导任意迭代次数 $k$ 下内部点 $c_{k}$ 和 $d_{k}$ 关于 $a_{k}$、$b_{k}$ 和 $\\tau$ 的精确闭式表达式。然后，仅基于 $f(c_{k})$ 和 $f(d_{k})$ 的比较，推导区间端点 $[a_{k+1},b_{k+1}]$ 的精确更新规则。\n2. 使用函数 $f(x)=|x-m|$（其中 $m=3/7$），确定 $m$、$c_{0}$ 和 $d_{0}$ 的顺序，并说明在第一次迭代中哪个端点被舍弃。以精确的符号形式（仅包含 $\\tau$ 的表达式）展示更新后的区间 $[a_{1},b_{1}]$以及新的内部点 $c_{1}$ 和 $d_{1}$。\n3. 从第一性原理和 $\\tau$ 的定义出发，证明经过 $n$ 次迭代后的区间长度是一个关于 $n$ 的几何级数，并给出其精确的闭式解。利用此结果，推导使区间长度小于或等于 $\\varepsilon = 1.0 \\times 10^{-8}$ 所需的最小整数迭代次数 $n$。\n4. 将任务3中分析预测的迭代次数与从 $[0,1]$ 开始对特定函数 $f(x)=|x-3/7|$ 进行确定性区间更新所隐含的观测迭代次数进行比较。说明这两个迭代次数之间的差异，并解释为什么会（或不会）产生这种差异。\n\n将你在任务3中找到的单个整数 $n$ 作为最终答案。无需进行四舍五入，因为最小整数 $n$ 是精确的。", "solution": "该问题陈述科学严谨、定义明确且客观。它为分析应用于特定单峰函数的黄金分割搜索算法提供了一个完整且一致的框架。该问题是有效的，并且可以解决。\n\n黄金比例常数 $\\varphi$ 由 $\\varphi^2 = \\varphi + 1$（其中 $\\varphi  0$）定义。其解为 $\\varphi = \\frac{1+\\sqrt{5}}{2}$。常数 $\\tau$ 定义为 $\\tau = \\varphi^{-1} = \\frac{\\sqrt{5}-1}{2}$。恒等式 $\\varphi^2 = \\varphi + 1$ 两边同除以 $\\varphi^2$ 后，可得 $1 = \\frac{1}{\\varphi} + \\frac{1}{\\varphi^2}$，即 $1 = \\tau + \\tau^2$。此恒等式将在整个解答过程中使用。\n\n### 任务1：内部点和更新规则的推导\n\n设第 $k$ 次迭代的搜索区间为 $[a_k, b_k]$，其长度为 $L_k = b_k - a_k$。该算法在两个内部点 $c_k$ 和 $d_k$ 处计算函数值，满足 $a_k  c_k  d_k  b_k$。\n\n黄金分割搜索法的定义性质是，整个区间的长度与由一个内点分割出的两个子区间中较大者的长度之比为 $\\varphi$。这导致了两个内点的对称放置。设点 $c_k$ 和 $d_k$ 的位置使得总区间长度 $L_k$ 与子区间 $[a_k, d_k]$ 和 $[c_k, b_k]$ 的长度之比均为 $\\varphi$。\n$$\n\\frac{b_k - a_k}{d_k - a_k} = \\varphi \\quad \\text{和} \\quad \\frac{b_k - a_k}{b_k - c_k} = \\varphi\n$$\n从这些关系中，我们推导出 $c_k$ 和 $d_k$ 的位置：\n$$\nd_k - a_k = \\frac{b_k - a_k}{\\varphi} = \\tau(b_k - a_k) \\implies d_k = a_k + \\tau(b_k - a_k)\n$$\n$$\nb_k - c_k = \\frac{b_k - a_k}{\\varphi} = \\tau(b_k - a_k) \\implies c_k = b_k - \\tau(b_k - a_k)\n$$\n这些就是内部点 $c_k$ 和 $d_k$ 关于 $a_k$、$b_k$ 和 $\\tau$ 的闭式表达式。\n\n区间端点的更新规则基于函数值 $f(c_k)$ 和 $f(d_k)$ 的比较。由于函数 $f(x)$ 是单峰的，最小值必定位于包含函数值较小的点的子区间内。\n1. 如果 $f(c_k) \\le f(d_k)$：最小值位于区间 $[a_k, d_k]$ 内（因为 $c_k  d_k$ 且函数是单峰的）。新区间变为 $[a_{k+1}, b_{k+1}] = [a_k, d_k]$。\n2. 如果 $f(c_k)  f(d_k)$：最小值位于区间 $[c_k, b_k]$ 内。新区间变为 $[a_{k+1}, b_{k+1}] = [c_k, b_k]$。\n\n这一对规则定义了仅基于 $f(c_k)$ 和 $f(d_k)$ 比较的区间端点更新方法。\n\n### 任务2：第一次迭代分析\n\n给定函数为 $f(x) = |x - m|$，其中 $m = \\frac{3}{7}$，初始区间为 $[a_0, b_0] = [0, 1]$。\n\n首先，我们使用任务1中的公式计算初始内部点 $c_0$ 和 $d_0$：\n$$\nc_0 = b_0 - \\tau(b_0 - a_0) = 1 - \\tau(1 - 0) = 1 - \\tau\n$$\n$$\nd_0 = a_0 + \\tau(b_0 - a_0) = 0 + \\tau(1 - 0) = \\tau\n$$\n为确定 $m$、$c_0$ 和 $d_0$ 的顺序，我们比较它们的值：\n$m = \\frac{3}{7} \\approx 0.42857$\n$\\tau = \\frac{\\sqrt{5}-1}{2} \\approx 0.61803$\n$c_0 = 1 - \\tau = 1 - \\frac{\\sqrt{5}-1}{2} = \\frac{3-\\sqrt{5}}{2} \\approx 0.38197$。注意 $1-\\tau = \\tau^2$。\n所以，我们有 $c_0  m  d_0$。顺序为 $\\frac{3-\\sqrt{5}}{2}  \\frac{3}{7}  \\frac{\\sqrt{5}-1}{2}$。\n\n接下来，我们比较这些点的函数值：\n$f(c_0) = |c_0 - m| = |(1-\\tau) - \\frac{3}{7}|$。因为 $c_0  m$，所以结果是 $m - c_0 = \\frac{3}{7} - (1-\\tau) = \\tau - \\frac{4}{7}$。\n$f(d_0) = |d_0 - m| = |\\tau - \\frac{3}{7}|$。因为 $d_0 > m$，所以结果是 $d_0 - m = \\tau - \\frac{3}{7}$。\n\n比较这两个值：\n因为 $-\\frac{4}{7}  -\\frac{3}{7}$，我们有 $\\tau - \\frac{4}{7}  \\tau - \\frac{3}{7}$。\n因此，$f(c_0)  f(d_0)$。\n\n根据更新规则，由于 $f(c_0)  f(d_0)$，我们舍弃右端点 $b_0$。更新后的区间是 $[a_1, b_1] = [a_0, d_0] = [0, \\tau]$。\n\n对于区间 $[a_1, b_1] = [0, \\tau]$，新的内部点 $c_1$ 和 $d_1$ 是：\n$$\nc_1 = b_1 - \\tau(b_1 - a_1) = \\tau - \\tau(\\tau - 0) = \\tau - \\tau^2\n$$\n$$\nd_1 = a_1 + \\tau(b_1 - a_1) = 0 + \\tau(\\tau - 0) = \\tau^2\n$$\n所以，更新后的区间是 $[a_1, b_1] = [0, \\tau]$，新的内部点是 $c_1 = \\tau - \\tau^2$ 和 $d_1 = \\tau^2$。\n\n### 任务3：区间长度与迭代次数\n\n设 $L_k = b_k - a_k$ 为第 $k$ 次迭代时区间的长度。\n在每一步 $k$，新区间长度 $L_{k+1}$ 是 $[a_k, d_k]$ 或 $[c_k, b_k]$ 的长度。\n$[a_k, d_k]$ 的长度是 $d_k - a_k = (a_k + \\tau(b_k-a_k)) - a_k = \\tau(b_k-a_k) = \\tau L_k$。\n$[c_k, b_k]$ 的长度是 $b_k - c_k = b_k - (b_k - \\tau(b_k-a_k)) = \\tau(b_k-a_k) = \\tau L_k$。\n在两种情况下，区间的长度都以相同的因子 $\\tau$ 缩减：\n$$\nL_{k+1} = \\tau L_k\n$$\n这表明区间长度序列 $\\{L_k\\}$ 是一个公比为 $\\tau$ 的几何级数。经过 $n$ 次迭代后的长度的闭式表达式为 $L_n = \\tau^n L_0$。\n给定初始区间 $[0, 1]$，初始长度为 $L_0 = 1 - 0 = 1$。\n因此，经过 $n$ 次迭代后的区间长度为 $L_n = \\tau^n$。\n\n我们要找到最小的整数迭代次数 $n$，使得区间长度小于或等于 $\\varepsilon = 1.0 \\times 10^{-8}$。\n$$\nL_n \\le \\varepsilon \\implies \\tau^n \\le 10^{-8}\n$$\n对两边取自然对数：\n$$\n\\ln(\\tau^n) \\le \\ln(10^{-8})\n$$\n$$\nn \\ln(\\tau) \\le -8 \\ln(10)\n$$\n因为 $\\tau = \\frac{\\sqrt{5}-1}{2} \\approx 0.618$，它在 $0$ 和 $1$ 之间，这意味着 $\\ln(\\tau)$ 是负数。除以 $\\ln(\\tau)$ 会使不等号反向：\n$$\nn \\ge \\frac{-8 \\ln(10)}{\\ln(\\tau)}\n$$\n我们可以写成 $\\ln(\\tau) = \\ln(\\varphi^{-1}) = -\\ln(\\varphi)$。\n$$\nn \\ge \\frac{-8 \\ln(10)}{-\\ln(\\varphi)} = \\frac{8 \\ln(10)}{\\ln(\\varphi)}\n$$\n现在，我们可以代入数值进行计算：\n$$\nn \\ge \\frac{8 \\ln(10)}{\\ln\\left(\\frac{1+\\sqrt{5}}{2}\\right)} \\approx \\frac{8 \\times 2.302585}{0.481212} \\approx \\frac{18.42068}{0.481212} \\approx 38.27904\n$$\n由于 $n$ 必须是整数，所需的最小迭代次数是大于或等于此值的最小整数，即 $\\lceil 38.27904 \\rceil = 39$。\n\n### 任务4：预测与观测的迭代次数比较\n\n任务3中分析预测的迭代次数是 $n=39$。这是确保区间长度 $L_n$ 不大于 $\\varepsilon = 1.0 \\times 10^{-8}$ 所需的迭代次数。\n\n对于特定函数 $f(x)=|x-3/7|$，“观测”到的迭代次数是区间长度变得小于或等于 $\\varepsilon$ 后的实际迭代次数。\n\n如任务3所推导，每次迭代 $k$ 后的区间长度遵循确定性规则 $L_{k+1} = \\tau L_k$，对于 $L_0=1$ 的情况，这简化为 $L_k = \\tau^k$。这种长度的缩减是黄金分割搜索算法本身的几何性质，与被最小化的单峰函数无关。函数 $f(x)$ 决定了选择*哪个*子区间（即下一个区间的位置），但并不决定其*长度*。\n\n因此，对于在给定初始区间上应用的任何黄金分割搜索，区间长度的序列是固定的。达到某一长度容差 $\\varepsilon$ 所需的迭代次数仅取决于初始长度 $L_0$、$\\varepsilon$ 以及常数因子 $\\tau$。它不依赖于每一步基于函数值所做的具体选择。\n\n因此，分析预测的迭代次数并非长度缩减的“最坏情况”或“平均情况”；它是长度收缩到指定容差所需的精确迭代次数。对于特定函数 $f(x)=|x-3/7|$ 的观测迭代次数将与计算出的次数完全相同。\n\n这两个迭代次数之间的差异是 $39 - 39 = 0$。没有差异的原因是，在黄金分割搜索中，区间长度的收敛率在每次迭代中都是一个常数 $\\tau$，与函数的行为无关（只要它保持单峰性）。", "answer": "$$\\boxed{39}$$", "id": "3237350"}, {"introduction": "在牢固掌握了理论之后，让我们将其转化为一个实用的计算工具。这个动手编程练习 [@problem_id:3237407] 要求你实现黄金分割搜索算法，并在一个其最小值点不可导的函数上测试其威力。这突显了无导数方法在处理现实世界中平滑性无法保证的优化问题时的关键优势。", "problem": "考虑设计并分析一个无导数搜索算法，用以定位一个单峰函数的最小值。如果一个函数在某个区间上只有一个局部最小值，则称该函数在该区间上是单峰的。在此任务中，您将构建一个特定的单峰函数，其最小值出现在一阶导数不存在的点上，然后实现一个基于黄金比例的区间收缩法来定位该最小值。\n\n构建函数\n$$\nf(x) = \\lvert x - \\mu \\rvert + \\beta \\,(x - \\mu)^2,\n$$\n其中 $\\mu \\in \\mathbb{R}$ 和 $\\beta \\in [0,\\infty)$ 是参数。点 $x = \\mu$ 是唯一的极小值点，并且该函数是单峰的，因为它在 $(-\\infty,\\mu)$ 上严格递减，在 $(\\mu,\\infty)$ 上严格递增；此外，由于绝对值的存在，$f$ 在 $x = \\mu$ 处不可微。这种设定确保了任何基于导数的方法都会遇到一个不可微点，而像黄金分割搜索这样的无导数方法仍然适用。\n\n从单峰函数的基本性质出发——即，如果 $f$ 在 $[a,b]$ 上是单峰的，那么对于任意两个内部点 $c$ 和 $d$（满足 $a  c  d  b$），$f(c) - f(d)$ 的符号指示了哪个子区间包含最小值——您必须实现一个黄金分割搜索算法。黄金分割搜索对称地选择 $c$ 和 $d$，以便在缩小区间后，可以在下一次迭代中重用一次函数求值。该算法应：\n- 从一个包含极小值点的区间 $[a,b]$ 开始，满足 $a  \\mu  b$。\n- 使用黄金比例在 $(a,b)$ 中放置点 $c$ 和 $d$，并基于比较 $f(c)$ 和 $f(d)$ 来迭代地缩小包含极小值点的区间。\n- 当区间宽度 $b-a$ 小于预设的容差或达到最大迭代次数时终止。\n- 返回近似的极小值点，即 $(a+b)/2$。\n\n请实现该算法，并在一系列参数集上进行测试，每个测试用例为一个元组 $(\\mu,\\beta,a,b,\\text{tol})$：\n1. $(\\mu,\\beta,a,b,\\text{tol}) = (1.23456789, 0.1, -2.0, 5.0, 10^{-8})$。\n2. $(\\mu,\\beta,a,b,\\text{tol}) = (-3.5, 0.0, -10.0, -1.0, 10^{-7})$。\n3. $(\\mu,\\beta,a,b,\\text{tol}) = (0.0, 5.0, -0.001, 0.002, 10^{-12})$。\n4. $(\\mu,\\beta,a,b,\\text{tol}) = (2.0, 0.2, 1.5, 6.0, 10^{-10})$。\n5. $(\\mu,\\beta,a,b,\\text{tol}) = (1000.0, 0.02, 900.0, 1100.0, 10^{-6})$。\n\n假设所有情况的最大迭代次数为 $1000$。此问题不涉及物理单位和角度。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如 $[r_1,r_2,\\dots,r_5]$），其中每个 $r_i$ 是黄金分割搜索针对第 $i$ 个测试用例返回的近似极小值点。输出必须是浮点数。", "solution": "已对用户提供的问题进行了分析和验证。\n\n### 步骤1：提取已知条件\n- **待最小化的函数：** $f(x) = \\lvert x - \\mu \\rvert + \\beta \\,(x - \\mu)^2$\n- **参数：** $\\mu \\in \\mathbb{R}$ 和 $\\beta \\in [0,\\infty)$。\n- **函数性质：** 在 $\\mathbb{R}$ 上是单峰函数，在 $x = \\mu$ 处有唯一最小值。该函数在 $x=\\mu$ 处不可微。\n- **算法：** 黄金分割搜索。\n- **初始条件：** 一个包含极小值点的区间 $[a, b]$，满足 $a  \\mu  b$。\n- **终止标准：**\n    1. 区间宽度 $b - a$ 小于容差 $\\text{tol}$。\n    2. 达到最大迭代次数 $1000$ 次。\n- **算法输出：** 近似极小值点由最终区间的中点 $(a+b)/2$ 给出。\n- **测试用例：** 包含五个测试用例的套件，每个测试用例由一个元组 $(\\mu, \\beta, a, b, \\text{tol})$ 定义：\n    1.  $(1.23456789, 0.1, -2.0, 5.0, 10^{-8})$\n    2.  $(-3.5, 0.0, -10.0, -1.0, 10^{-7})$\n    3.  $(0.0, 5.0, -0.001, 0.002, 10^{-12})$\n    4.  $(2.0, 0.2, 1.5, 6.0, 10^{-10})$\n    5.  $(1000.0, 0.02, 900.0, 1100.0, 10^{-6})$\n\n### 步骤2：使用提取的已知条件进行验证\n该问题经过了严格的验证过程。\n- **科学依据：** 该问题在科学和数学上是合理的。函数 $f(x) = \\lvert x - \\mu \\rvert + \\beta \\,(x - \\mu)^2$ 是一个有效的数学构造。其声称的性质是正确的：\n    - 对于 $x > \\mu$，$f(x) = (x-\\mu) + \\beta(x-\\mu)^2$。其导数为 $f'(x) = 1 + 2\\beta(x-\\mu)$。由于 $\\beta \\ge 0$ 且 $x > \\mu$，所以 $f'(x) > 0$，函数严格递增。\n    - 对于 $x  \\mu$，$f(x) = -(x-\\mu) + \\beta(x-\\mu)^2$。其导数为 $f'(x) = -1 + 2\\beta(x-\\mu)$。由于 $x  \\mu$，所以 $f'(x)  0$，函数严格递减。\n    - 这证实了该函数是单峰的，并在 $x=\\mu$ 处有最小值。\n    - 在 $\\mu$ 处的左导数为 $-1$，右导数为 $1$，证实了在最小值点处不可微。\n- **适定性：** 问题是适定的。黄金分割搜索是用于单峰函数的收敛算法，保证存在唯一解。初始条件（$a  \\mu  b$）和终止标准都已明确指定且一致。\n- **客观性：** 问题使用精确、客观的数学语言陈述，没有歧义或主观元素。\n- **完整性和一致性：** 为每个测试用例提供了所有必要的参数（$\\mu, \\beta$）、初始区间 $[a, b]$ 和容差 (`tol`)。条件 $a  \\mu  b$ 对所有用例均成立。整个设定是自洽的，没有矛盾。\n\n### 步骤3：结论与操作\n此问题是**有效的**。它是一个定义明确的数值优化任务，可以通过算法解决。\n\n### 解法推导\n解决方案涉及实现黄金分割搜索算法，以找到给定函数 $f(x)$ 的最小值。\n\n**黄金分割搜索的原理**\n黄金分割搜索是一种无导数优化技术，用于在闭区间上寻找单峰函数的最小值。它通过迭代地缩小包含最小值的区间来运作。该方法因其使用黄金比例而得名，这确保了每一步区间长度的缩减是最佳的，并允许重用前一次迭代中的一个函数求值，从而提高效率。\n\n**算法设计**\n设包含最小值的区间为 $[a, b]$。算法引入两个内部点 $c$ 和 $d$，使得 $a  c  d  b$。它们的位置由黄金比例共轭 $\\tau = (\\sqrt{5}-1)/2 \\approx 0.618034$ 决定。这两个点被对称地放置：\n$$\nc = b - \\tau(b-a)\n$$\n$$\nd = a + \\tau(b-a)\n$$\n这种布置确保了较大子区间（例如 $[a, d]$）与整个区间 $[a, b]$ 的长度之比等于 $\\tau$。\n\n迭代过程如下：\n1.  初始化区间端点 $[a, b]$，并计算初始内部点 $c$ 和 $d$。在这些点上计算函数值，得到 $f(c)$ 和 $f(d)$。\n2.  比较函数值：\n    - 如果 $f(c)  f(d)$，由于函数是单峰的，最小值必定位于区间 $(a, d)$ 内。搜索区间更新为 $[a', b'] \\leftarrow [a, d]$。黄金分割搜索的关键特性是，旧的点 $c$ 相对于新区间成为新的点 $d'$，因此我们只需要计算一个新的点 $c'$ 和一个新的函数值。具体来说，新的赋值是：\n      - $b \\leftarrow d$\n      - $d \\leftarrow c$\n      - $f_d \\leftarrow f_c$\n      - $c \\leftarrow b - \\tau(b-a)$\n      - $f_c \\leftarrow f(c)$\n    - 如果 $f(c) \\ge f(d)$，最小值必定位于区间 $(c, b)$ 内。搜索区间更新为 $[a', b'] \\leftarrow [c, b]$。旧的点 $d$ 成为新的点 $c'$。新的赋值是：\n      - $a \\leftarrow c$\n      - $c \\leftarrow d$\n      - $f_c \\leftarrow f_d$\n      - $d \\leftarrow a + \\tau(b-a)$\n      - $f_d \\leftarrow f(d)$\n3.  重复此过程，直到区间宽度 $(b-a)$ 小于指定的容差 $\\text{tol}$，或超过最大迭代次数（$1000$）。\n4.  极小值点的最终估计值为最终区间的中点 $(a+b)/2$。\n\n该算法将被实现并应用于所提供的五个测试用例。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and tests the golden section search algorithm for a specified\n    unimodal function with a non-differentiable minimum.\n    \"\"\"\n\n    def f(x, mu, beta):\n        \"\"\"\n        The unimodal function to be minimized.\n        f(x) = |x - mu| + beta * (x - mu)^2\n        \"\"\"\n        return np.abs(x - mu) + beta * (x - mu)**2\n\n    def golden_section_search(func, a, b, tol, max_iter=1000):\n        \"\"\"\n        Finds the minimum of a unimodal function 'func' on the interval [a, b]\n        using the golden section search method.\n\n        Args:\n            func: The unimodal function to minimize.\n            a: The lower bound of the initial interval.\n            b: The upper bound of the initial interval.\n            tol: The desired tolerance for the interval width.\n            max_iter: The maximum number of iterations.\n\n        Returns:\n            The approximate location of the minimum.\n        \"\"\"\n        # Define the golden ratio conjugate\n        tau = (np.sqrt(5.0) - 1.0) / 2.0\n\n        # Set up the initial interior points\n        c = b - tau * (b - a)\n        d = a + tau * (b - a)\n\n        # Evaluate the function at the interior points\n        fc = func(c)\n        fd = func(d)\n\n        for _ in range(max_iter):\n            # Check for termination\n            if (b - a)  tol:\n                break\n            \n            # Compare function values and shrink the interval\n            if fc  fd:\n                # The minimum is in the interval [a, d]\n                b = d\n                d = c\n                fd = fc\n                c = b - tau * (b - a)\n                fc = func(c)\n            else:\n                # The minimum is in the interval [c, b]\n                a = c\n                c = d\n                fc = fd\n                d = a + tau * (b - a)\n                fd = func(d)\n        \n        # Return the midpoint of the final interval\n        return (a + b) / 2.0\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.23456789, 0.1, -2.0, 5.0, 1e-8),\n        (-3.5, 0.0, -10.0, -1.0, 1e-7),\n        (0.0, 5.0, -0.001, 0.002, 1e-12),\n        (2.0, 0.2, 1.5, 6.0, 1e-10),\n        (1000.0, 0.02, 900.0, 1100.0, 1e-6),\n    ]\n\n    results = []\n    for mu, beta, a, b, tol in test_cases:\n        # Create a callable function instance for the current set of parameters\n        current_f = lambda x: f(x, mu, beta)\n        \n        # Calculate the result for the current case\n        approximated_minimizer = golden_section_search(current_f, a, b, tol, max_iter=1000)\n        results.append(approximated_minimizer)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nsolve()\n```", "id": "3237407"}, {"introduction": "现在，让我们通过将黄金分割搜索法应用于一个新领域来拓展我们的算法思维。这个高级实践 [@problem_id:3237530] 挑战你修改算法，使其适用于离散整数域，这在资源分配或计算机科学中的参数调整等领域很常见。这个练习强调了核心的区间收缩原理在连续函数之外的通用性。", "problem": "设 $f:\\mathbb{Z}\\to\\mathbb{R}$ 是一个在离散整数域 $\\{a,a+1,\\dots,b\\}$ 上的单峰函数，其中单峰性指的是存在一个整数最小值点 $x^\\star\\in\\{a,a+1,\\dots,b\\}$，使得当 $x\\le x^\\star$ 时 $f(x)$ 是非递增的，当 $x\\ge x^\\star$ 时 $f(x)$ 是非递减的。从单峰函数最小化的区间套基本思想出发，并基于每次迭代通过保持恒定的区间收缩比来重用一次函数评估的要求，推导出一个适用于整数域 $\\{a,a+1,\\dots,b\\}$ 的黄金分割搜索的改进算法。你的算法必须 (i) 定义如何使用由恒定比例原则产生的区间收缩因子来放置内部测试点 $x_1$ 和 $x_2$；(ii) 将这些点四舍五入为整数，同时保持 $a \\le x_1  x_2 \\le b$ 的不变量。算法还必须定义明确的终止条件和平局处理规则。当区间缩小到3个点或更少时，应通过穷举搜索找到最终的最小值点。\n\n如果存在多个具有相同最小函数值的整数最小值点（形成一个“平台区”），你的算法必须返回其中最小的那个整数。\n\n请实现该算法，并在一系列函数和区间上进行测试，每个测试用例为一个元组 `(函数, a, b)`：\n1.  $f_1(x)=(x-7)^2+3$ 在区间 $[0, 20]$ 上。\n2.  $f_2(x)=\\max(0, \\lvert x-5\\rvert-1)$ 在区间 $[0, 12]$ 上。\n3.  $f_3(x)=2x+11$ 在区间 $[-10, 5]$ 上。\n4.  $f_4(x)=-3x+7$ 在区间 $[-5, 8]$ 上。\n5.  $f_5(x)=(x-2)^2$ 在区间 $[1, 3]$ 上。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的整数列表，用方括号括起来（例如 `[x_star_1, x_star_2, ..., x_star_5]`），其中每个 `x_star_i` 是针对第 `i` 个测试用例找到的最小整数最小值点。", "solution": "用户想要推导并实现一个离散版本的黄金分割搜索算法。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n-   **待最小化的函数**：$f:\\mathbb{Z}\\to\\mathbb{R}$，一个在整数域 $\\{a, a+1, \\dots, b\\}$ 上的单峰函数。\n-   **单峰性定义**：存在一个整数最小值点 $x^\\star \\in \\{a, a+1, \\dots, b\\}$，使得当 $x \\le x^\\star$ 时 $f(x)$ 是非递增的，当 $x \\ge x^\\star$ 时 $f(x)$ 是非递减的。\n-   **核心原则**：算法必须从区间套思想推导而来，并满足通过保持恒定的区间收缩比来在每次迭代中重用一次函数评估的要求。\n-   **离散化要求**：\n    1.  定义一种方法，使用从恒定比例原则推导出的收缩因子来放置内部测试点 $x_1$ 和 $x_2$。\n    2.  将这些点四舍五入为整数，同时保持不变量 $a \\le x_1  x_2 \\le b$。\n    3.  指定在 $f(x_1) = f(x_2)$ 的情况下与单峰性一致的平局处理方式。\n    4.  定义一个终止规则：当区间大小（整数数量）最多为 $3$ 时，执行穷举检查以找到最小值点。\n-   **最小值点的平局打破规则**：如果存在多个最小值点（一个平台区），算法必须返回最小的整数最小值点。\n-   **测试用例**：\n    1.  $f_1(x)=(x-7)^2+3$，区间为 $a=0, b=20$。\n    2.  $f_2(x)=\\max(0,\\lvert x-5\\rvert-1)$，区间为 $a=0, b=12$。\n    3.  $f_3(x)=2x+11$，区间为 $a=-10, b=5$。\n    4.  $f_4(x)=-3x+7$，区间为 $a=-5, b=8$。\n    5.  $f_5(x)=(x-2)^2$，区间为 $a=1, b=3$。\n-   **输出格式**：一行包含逗号分隔的整数最小值点列表：$[x^\\star_1,x^\\star_2,x^\\star_3,x^\\star_4,x^\\star_5]$。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n-   **科学依据**：该问题涉及数值优化的一个标准主题——将连续优化算法（黄金分割搜索）应用于离散域。单峰性、区间缩减和函数评估重用的概念在数学上是可靠且公认的。\n-   **适定性**：该问题是适定的。单峰性假设保证了最小值点的存在。问题指定了明确的终止条件和平局打破规则（最小的整数最小值点），确保可以找到唯一的解。这些约束指导了特定类别算法的推导。\n-   **客观性**：问题使用精确、客观的数学语言陈述，没有歧义或主观论断。\n-   **完整性与一致性**：问题提供了所有必要的组成部分：函数属性、定义域、算法约束、终止条件和测试用例。没有矛盾之处。\n-   **结论**：该问题是有效的，因为它具有科学依据、适定、客观和完整。\n\n**步骤 3：判定与行动**\n\n问题是**有效的**。开始解决问题。\n\n### 算法推导与设计\n\n黄金分割搜索的核心是在区间 $[a, b]$ 内巧妙地放置两个内部点 $x_1$ 和 $x_2$，使得经过一次比较和区间缩减后，其中一个旧点可以作为新缩小区间内的一个内部点被重用。这是通过根据黄金比例放置点来实现的。\n\n设目标区间包含从 $a$ 到 $b$ 的整数。区间的跨度为 $h = b-a$。黄金比例的共轭是 $\\rho = (\\sqrt{5}-1)/2 \\approx 0.618$。在连续情况下，内部点是 $x_1 = a + (1-\\rho)h$ 和 $x_2 = a + \\rho h$。注意 $1-\\rho = \\rho^2$。\n\n对于离散整数域，我们必须对此进行调整。一个关键的洞见是，为了能够重用点，必须保持点的几何结构。实现这一点的最简单方法是强制对称性。我们将两个内部点 $x_1$ 和 $x_2$ 放置在相对于端点 $a$ 和 $b$ 对称的位置。也就是说，$x_1 - a = b - x_2$，这意味着 $x_1 + x_2 = a + b$。\n\n**1. 点的放置：**\n我们可以使用黄金比例计算一个点，然后使用对称条件计算另一个点。我们定义点以满足 $a \\le x_1  x_2 \\le b$。可以设置：\n$$x_2 = a + \\text{round}(\\rho (b-a))$$\n$$x_1 = a + b - x_2$$\n这确保了点相对于区间中心是对称的。然而，由于整数取整，特别是对于小区间，可能会出现 $x_1 \\ge x_2$ 的情况。算法必须检测并处理这种情况。一个稳健的方法是，如果这些点不唯一且顺序不正确，则退回到穷举搜索，因为这表明区间已经变得太小，几何假设不再成立。我们指定的终止条件（区间大小 $\\le 3$）处理了大多数这类小区间情况。\n\n**2. 区间缩减和点重用：**\n设定义区间的四个点为 $(a, x_1, x_2, b)$。我们评估 $f(x_1)$ 和 $f(x_2)$。\n-   如果 $f(x_1) \\le f(x_2)$：由于单峰性，最小值点 $x^\\star$ 不可能在范围 $(x_2, b]$ 内。新的搜索区间变为 $[a, x_2]$。重用评估的关键洞见是观察到旧点 $x_1$ 在这个新区间内。新的四点区间变为 $(a', x'_1, x'_2, b')$，其中 $a'=a$，$b'=x_2$，并且 $x'_2=x_1$。我们只需要计算一个新点 $x'_1$。为了在新区间 $[a', b']$ 中保持对称性，我们设置 $x'_1 = a' + b' - x'_2 = a + x_2 - x_1$。然后我们只需要一次新的函数评估，即对 $f(x'_1)$ 进行评估。\n\n-   如果 $f(x_1) > f(x_2)$：对称地，最小值点 $x^\\star$ 不可能在 $[a, x_1)$ 内。新区间是 $[x_1, b]$。新区间变为 $(a', x'_1, x'_2, b')$，其中 $a'=x_1$，$b'=b$，并且 $x'_1=x_2$。新点是 $x'_2 = a' + b' - x'_1 = x_1 + b - x_2$。我们评估 $f(x'_2)$。\n\n**3. 平局处理 ($f(x_1) = f(x_2)$)：**\n问题要求返回最小的整数最小值点。如果 $f(x_1)=f(x_2)$，最小值点可能在 $x_1$ 和 $x_2$ 之间的任何位置。为了偏向较小值的最小值点，我们应该消除搜索空间的右侧部分。因此，$f(x_1) = f(x_2)$ 的情况由 $f(x_1) \\le f(x_2)$ 分支处理，该分支将区间更新为 $[a, x_2]$。\n\n**4. 终止规则：**\n只要区间中的点数 $b-a+1$ 大于 $3$，迭代过程就继续。当区间大小变为 $3$ 或更小时，由于整数算术（例如 $x_1$ 和 $x_2$ 重合），固定比例逻辑可能会失效。在此阶段，我们对少数剩余点 $\\{a, a+1, \\dots, b\\}$ 进行简单的穷举搜索，以找到具有最小函数值的点，同时遵守最小整数的平局打破规则。如果在更新过程中新点 $x_1, x_2$ 发生重合（$x_1 \\ge x_2$），算法也会终止，因为这也标志着几何假设的失效。\n\n这个推导出的算法构成了整数域上“黄金分割搜索的修改版”。它使用黄金比例来启发其结构，保持了每次迭代重用一次函数评估的关键属性，并包含了对离散整数算术现实情况的特定处理。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements a discrete golden section search algorithm to find the\n    integer minimizer of several unimodal functions.\n    \"\"\"\n\n    # --- Test Case Functions ---\n    def f1(x: int) - float:\n        return float((x - 7)**2 + 3)\n\n    def f2(x: int) - float:\n        return float(np.maximum(0, np.abs(x - 5) - 1))\n\n    def f3(x: int) - float:\n        return float(2 * x + 11)\n\n    def f4(x: int) - float:\n        return float(-3 * x + 7)\n    \n    def f5(x: int) - float:\n        return float((x - 2)**2)\n\n    def discrete_golden_section_search(f, a: int, b: int) - int:\n        \"\"\"\n        Finds the integer minimizer of a unimodal function f on the interval [a, b].\n        \"\"\"\n        # --- Exhaustive search for small final intervals ---\n        def exhaustive_search(f_search, a_search, b_search):\n            min_val = f_search(a_search)\n            min_x = a_search\n            for x_i in range(a_search + 1, b_search + 1):\n                val = f_search(x_i)\n                # In case of a plateau, the first x (smallest) is kept as the minimizer\n                if val  min_val:\n                    min_val = val\n                    min_x = x_i\n            return min_x\n\n        # The golden ratio conjugate\n        rho = (np.sqrt(5) - 1) / 2\n\n        # Initial point placement\n        x1, x2 = 0, 0\n        if b - a + 1 > 3:\n            h = b - a\n            # Place points symmetrically using the golden ratio\n            x2 = a + int(np.round(rho * h))\n            x1 = a + b - x2\n            # Handle potential collision on small intervals\n            if x1 >= x2:\n                return exhaustive_search(f, a, b)\n        else:\n            return exhaustive_search(f, a, b)\n            \n        f1_val = f(x1)\n        f2_val = f(x2)\n\n        # Main loop: reduce interval while it's large enough\n        while b - a + 1 > 3:\n            if f1_val = f2_val:  # Tie-breaking favors left side to find smallest minimizer\n                b = x2\n                x2 = x1\n                f2_val = f1_val\n                x1 = a + b - x2\n                \n                if x1 >= x2: break # Points collided, terminate iteration\n                \n                f1_val = f(x1)\n            else: # f1_val > f2_val\n                a = x1\n                x1 = x2\n                f1_val = f2_val\n                x2 = a + b - x1\n\n                if x1 >= x2: break # Points collided, terminate iteration\n\n                f2_val = f(x2)\n        \n        # Final exhaustive search on the small remaining bracket\n        return exhaustive_search(f, a, b)\n\n    test_cases = [\n        (f1, 0, 20),\n        (f2, 0, 12),\n        (f3, -10, 5),\n        (f4, -5, 8),\n        (f5, 1, 3),\n    ]\n\n    results = []\n    for f, a, b in test_cases:\n        minimizer = discrete_golden_section_search(f, a, b)\n        results.append(minimizer)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3237530"}]}