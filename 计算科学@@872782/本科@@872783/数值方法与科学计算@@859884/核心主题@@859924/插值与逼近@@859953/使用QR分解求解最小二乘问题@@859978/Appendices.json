{"hands_on_practices": [{"introduction": "理论知识的学习最终要应用于解决实际问题。这个练习将展示线性代数中的抽象概念，如矩阵的零空间，如何被用来解决化学中的一个具体问题：化学反应配平。通过为原子和电荷守恒定律建立一个线性方程组，我们将配平问题转化为寻找一个系数矩阵 $A$ 的零空间 $\\mathcal{N}(A)$ [@problem_id:3275534]。此练习旨在阐明如何利用 $A$ 的转置矩阵 $A^{\\mathsf{T}}$ 的QR分解来系统地揭示其零空间的基，从而找到化学计量系数。", "problem": "一位化学家正在分析酸性水溶液中高锰酸盐对草酸盐的氧化反应。未配平的反应式为\n$$\\mathrm{MnO_{4}^{-}} + \\mathrm{C_{2}O_{4}^{2-}} + \\mathrm{H^{+}} \\rightarrow \\mathrm{Mn^{2+}} + \\mathrm{CO_{2}} + \\mathrm{H_{2}O}.$$\n利用原子守恒和电荷守恒，将此反应编码为一个齐次线性系统 $A x = 0$，其中 $x$ 是未知化学计量系数的向量，其顺序为\n$$x = \\begin{pmatrix}x_{1}  x_{2}  x_{3}  x_{4}  x_{5}  x_{6}\\end{pmatrix}^{\\mathsf{T}} = \\begin{pmatrix}\\mathrm{MnO_{4}^{-}}  \\mathrm{C_{2}O_{4}^{2-}}  \\mathrm{H^{+}}  \\mathrm{Mn^{2+}}  \\mathrm{CO_{2}}  \\mathrm{H_{2}O}\\end{pmatrix}^{\\mathsf{T}}.$$\n在矩阵 $A$ 中用负值表示生成物，从而将元素和电荷守恒写成和为零的线性约束。\n\n从每种元素和净电荷的守恒定律这一基本原理出发，并根据矩阵的 Q–R 分解 (QR) 的定义，解释 Q–R 分解如何揭示约束矩阵 $A$ 的零空间 $\\mathcal{N}(A)$ 的一组基，并由此得到化学计量系数。然后，确定配平后方程式中 $\\mathrm{H^{+}}$ 的最小正整数化学计量系数。\n\n你的最终答案必须是一个实数。无需四舍五入。最终答案应表示为无单位的纯数字。", "solution": "该问题提法合理且有科学依据，是线性代数在化学计量学中的一个标准应用。所有必要信息均已提供。\n\n问题要求通过找到最小的正整数系数 $x_i$ 来配平化学反应\n$$x_{1}\\,\\mathrm{MnO_{4}^{-}} + x_{2}\\,\\mathrm{C_{2}O_{4}^{2-}} + x_{3}\\,\\mathrm{H^{+}} \\rightarrow x_{4}\\,\\mathrm{Mn^{2+}} + x_{5}\\,\\mathrm{CO_{2}} + x_{6}\\,\\mathrm{H_{2}O}$$\n这等价于为约束矩阵 $A$ 的零空间找到一个具有最小整数分量的基向量。系数向量为 $x = \\begin{pmatrix}x_{1}  x_{2}  x_{3}  x_{4}  x_{5}  x_{6}\\end{pmatrix}^{\\mathsf{T}}$。约束条件来自于每种元素的守恒和总电荷的守恒。生成物用负系数建模。\n\n1.  **锰 (Mn) 元素守恒：** 两边的 Mn 原子数必须相等。\n    $$1 \\cdot x_{1} - 1 \\cdot x_{4} = 0$$\n2.  **氧 (O) 元素守恒：**\n    $$4 \\cdot x_{1} + 4 \\cdot x_{2} - 2 \\cdot x_{5} - 1 \\cdot x_{6} = 0$$\n3.  **碳 (C) 元素守恒：**\n    $$2 \\cdot x_{2} - 1 \\cdot x_{5} = 0$$\n4.  **氢 (H) 元素守恒：**\n    $$1 \\cdot x_{3} - 2 \\cdot x_{6} = 0$$\n5.  **电荷守恒：** 两边的净电荷必须相等。\n    $$(-1) \\cdot x_{1} + (-2) \\cdot x_{2} + (1) \\cdot x_{3} - (2) \\cdot x_{4} = 0$$\n\n这五个线性方程构成一个齐次系统 $Ax = 0$，其中 $A$ 是一个 $5 \\times 6$ 的系数矩阵，$x \\in \\mathbb{R}^6$ 是化学计量系数的向量。\n\n$$A = \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 4  4  0  0  -2  -1 \\\\ 0  2  0  0  -1  0 \\\\ 0  0  1  0  0  -2 \\\\ -1  -2  1  -2  0  0 \\end{pmatrix}$$\n\n这个化学配平问题的解是矩阵 $A$ 的零空间 $\\mathcal{N}(A)$ 中的一个向量 $x$。\n\n问题要求解释如何使用 Q–R 分解来找到 $\\mathcal{N}(A)$ 的一组基。设 $A$ 是一个 $m \\times n$ 矩阵。$A$ 的*转置*矩阵 $A^{\\mathsf{T}}$ 的 Q–R 分解为 $A^{\\mathsf{T}} = QR$，其中 $Q$ 是一个 $n \\times n$ 的正交矩阵（$Q^{\\mathsf{T}}Q = I$），$R$ 是一个 $n \\times m$ 的上梯形矩阵。$Q$ 的列构成了 $\\mathbb{R}^n$ 的一组标准正交基。\n\n设 $r = \\mathrm{rank}(A) = \\mathrm{rank}(A^{\\mathsf{T}})$。$Q$ 的前 $r$ 列构成了 $A^{\\mathsf{T}}$ 的列空间的一组标准正交基，这正是 $A$ 的行空间 $\\mathrm{Row}(A)$。我们将 $Q$ 分块为 $Q = \\begin{pmatrix} Q_1  Q_2 \\end{pmatrix}$，其中 $Q_1$ 由前 $r$ 列组成，$Q_2$ 由剩下的 $n-r$ 列组成。\n\n根据线性代数基本定理，$A$ 的零空间是 $A$ 的行空间的正交补：$\\mathcal{N}(A) = (\\mathrm{Row}(A))^{\\perp}$。由于 $Q_1$ 的列构成了 $\\mathrm{Row}(A)$ 的一组基，而 $Q$ 的列构成了整个空间 $\\mathbb{R}^n$ 的一组标准正交基，因此 $Q_2$ 中剩下的列必须构成 $\\mathrm{Row}(A)$ 的正交补的一组标准正交基。所以，$Q_2$ 的列构成了 $A$ 的零空间的一组标准正交基。\n\n在这个具体问题中，$A$ 是一个 $5 \\times 6$ 的矩阵。我们预期 $A$ 的秩为 $r=5$，因此零空间的维数为 $n-r = 6-5=1$。因此，对 $6 \\times 5$ 矩阵 $A^{\\mathsf{T}}$ 进行 Q–R 分解，将得到一个 $6 \\times 6$ 的正交矩阵 $Q$。$Q$ 的最后一列 $q_6$ 将构成 $A$ 的一维零空间的一组基。任何有效的化学计量系数向量 $x$ 都必须是这个基向量 $q_6$ 的标量倍。\n\n为了找到这个基向量，我们可以使用高斯消元法求解系统 $Ax=0$，这在操作上等同于求解 $Ux=0$，其中 $U$ 是消元过程得到的上三角矩阵。\n\n该系统的增广矩阵是 $[A|0]$。我们对 $A$ 进行行化简：\n$$ \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 4  4  0  0  -2  -1 \\\\ 0  2  0  0  -1  0 \\\\ 0  0  1  0  0  -2 \\\\ -1  -2  1  -2  0  0 \\end{pmatrix} \\xrightarrow{R_2 \\leftarrow R_2-4R_1, R_5 \\leftarrow R_5+R_1} \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 0  4  0  4  -2  -1 \\\\ 0  2  0  0  -1  0 \\\\ 0  0  1  0  0  -2 \\\\ 0  -2  1  -3  0  0 \\end{pmatrix} $$\n$$ \\xrightarrow{R_3 \\leftarrow R_2-2R_3, R_5 \\leftarrow R_2+2R_5} \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 0  4  0  4  -2  -1 \\\\ 0  0  0  4  0  -1 \\\\ 0  0  1  0  0  -2 \\\\ 0  0  2  -2  -2  -1 \\end{pmatrix} \\xrightarrow{\\text{交换 } R_3, R_4} \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 0  4  0  4  -2  -1 \\\\ 0  0  1  0  0  -2 \\\\ 0  0  0  4  0  -1 \\\\ 0  0  2  -2  -2  -1 \\end{pmatrix} $$\n$$ \\xrightarrow{R_5 \\leftarrow R_5-2R_3} \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 0  4  0  4  -2  -1 \\\\ 0  0  1  0  0  -2 \\\\ 0  0  0  4  0  -1 \\\\ 0  0  0  -2  -2  3 \\end{pmatrix} \\xrightarrow{R_5 \\leftarrow R_4+2R_5} \\begin{pmatrix} 1  0  0  -1  0  0 \\\\ 0  4  0  4  -2  -1 \\\\ 0  0  1  0  0  -2 \\\\ 0  0  0  4  0  -1 \\\\ 0  0  0  0  -4  5 \\end{pmatrix} $$\n系统现在处于行阶梯形。我们有 $5$ 个主元和 $1$ 个自由变量 $x_6$。设 $x_6 = t$，其中 $t$ 是一个参数。我们通过回代求解其他变量。\n\n根据第 5 行：$-4x_5 + 5x_6 = 0 \\implies -4x_5 + 5t = 0 \\implies x_5 = \\frac{5}{4}t$。\n根据第 4 行：$4x_4 - x_6 = 0 \\implies 4x_4 - t = 0 \\implies x_4 = \\frac{1}{4}t$。\n根据第 3 行：$x_3 - 2x_6 = 0 \\implies x_3 - 2t = 0 \\implies x_3 = 2t$。\n根据第 2 行：$4x_2 + 4x_4 - 2x_5 - x_6 = 0 \\implies 4x_2 + 4(\\frac{1}{4}t) - 2(\\frac{5}{4}t) - t = 0 \\implies 4x_2 + t - \\frac{5}{2}t - t = 0 \\implies 4x_2 = \\frac{5}{2}t \\implies x_2 = \\frac{5}{8}t$。\n根据第 1 行：$x_1 - x_4 = 0 \\implies x_1 = x_4 = \\frac{1}{4}t$。\n\n通解为 $x = t \\begin{pmatrix} 1/4  5/8  2  1/4  5/4  1 \\end{pmatrix}^{\\mathsf{T}}$。\n为了找到最小的正整数系数，我们必须选择使 $x$ 的所有分量都成为整数的最小正值 $t$。分母是 $4, 8, 1, 4, 4, 1$。最小公倍数是 $\\mathrm{lcm}(4, 8) = 8$。我们设 $t=8$。\n\n$x_1 = \\frac{1}{4}(8) = 2$\n$x_2 = \\frac{5}{8}(8) = 5$\n$x_3 = 2(8) = 16$\n$x_4 = \\frac{1}{4}(8) = 2$\n$x_5 = \\frac{5}{4}(8) = 10$\n$x_6 = 1(8) = 8$\n\n最小整数系数向量为 $x = \\begin{pmatrix} 2  5  16  2  10  8 \\end{pmatrix}^{\\mathsf{T}}$。配平后的方程式为：\n$$2\\,\\mathrm{MnO_{4}^{-}} + 5\\,\\mathrm{C_{2}O_{4}^{2-}} + 16\\,\\mathrm{H^{+}} \\rightarrow 2\\,\\mathrm{Mn^{2+}} + 10\\,\\mathrm{CO_{2}} + 8\\,\\mathrm{H_{2}O}$$\n$\\mathrm{H^{+}}$ 的系数是 $x_3$。该系数的最小正整数值为 $16$。", "answer": "$$\\boxed{16}$$", "id": "3275534"}, {"introduction": "从理论算法到可靠的数值软件，一个关键步骤是处理真实世界数据带来的挑战。这个动手实践将探讨一个常见问题：当数据矩阵 $A$ 的各列具有混合单位或尺度差异巨大时，最小二乘解的数值稳定性会受到严重影响 [@problem_id:3275437]。你将实现一个基于Householder变换的QR分解求解器，并通过对矩阵进行物理单位缩放和列归一化这两种预处理，来研究它们对问题条件数以及最终解的准确性和可解释性的影响。", "problem": "您需要设计并实现一个程序，该程序使用数值稳定的正交分解方法，在特征列存在混合单位的情况下，解决超定线性最小二乘问题。该程序必须显式地构造并使用基于 Householder 的分解来对一个行数多于列数的实数矩阵进行因式分解，然后求解相关的上三角系统，而不是依赖于黑箱求解器。\n\n请从以下基本原理出发：对于实数矩阵 $A \\in \\mathbb{R}^{m \\times n}$（其中 $m \\ge n$）和实数向量 $b \\in \\mathbb{R}^m$，最小二乘问题旨在最小化欧几里得范数的平方 $\\lVert A x - b \\rVert_2^2$；正交变换保持欧几里得范数不变；任何实数矩阵 $A$ 都允许通过连续的正交变换进行分解，将次对角线元素置零，从而生成一个上三角因子。您的实现必须利用这些事实来设计算法。\n\n您必须显式地处理混合单位问题。假设 $A$ 的一列以公里为单位，而另一列以米为单位。为了获得对系数 $x$ 的一致物理解释，您应该构造一个对角缩放矩阵 $D_{\\text{phys}}$，将以公里为单位的列转换为米（例如，将公里列乘以 $1000$）。此外，为了在不考虑物理单位的情况下检验数值稳定性，您应该构造一个列归一化缩放矩阵 $S_{\\text{norm}}$，该矩阵将每一列缩放为单位 $\\ell_2$ 范数。给定一个缩放后的矩阵 $A S$ 和一个最小化 $\\lVert A S \\, y - b \\rVert_2$ 的解 $y$，在原始混合单位坐标系下的系数向量为 $x = S y$。您的程序必须在三种场景下评估求得的解：未经缩放的混合单位、物理单位一致、以及列归一化单位，并比较这三种场景下的残差范数和条件数，同时为了可解释性，将系数映射回相同的原始坐标系。\n\n实现以下功能：\n- 对给定的 $A$ 构造一个基于 Householder 的正交分解，将相关的正交变换应用于 $b$ 以获得 $Q^\\top b$，并求解得到的上三角系统 $R x = Q^\\top b$ 以获得最小二乘解 $x$，其中 $A = Q R$，$Q$ 为正交矩阵，$R$ 为上三角矩阵。\n- 对于物理缩放，通过将每个公里列乘以 $1000$ 将其转换为米来定义 $D_{\\text{phys}}$，并保持米列和偏置列不变。对于归一化缩放，定义 $S_{\\text{norm}} = \\operatorname{diag}(1/\\lVert a_1 \\rVert_2, \\dots, 1/\\lVert a_n \\rVert_2)$，其中 $a_j$ 是 $A$ 的第 $j$ 列。映射回原始混合单位坐标系下的系数为 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$ 和 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$。\n- 计算三种场景下的残差范数 $\\lVert A x_{\\text{mix}} - b \\rVert_2$、$\\lVert A x_{\\text{phys}} - b \\rVert_2$ 和 $\\lVert A x_{\\text{norm}} - b \\rVert_2$。同时计算 $2$-范数条件数 $\\kappa_2(A)$、$\\kappa_2(A D_{\\text{phys}})$ 和 $\\kappa_2(A S_{\\text{norm}})$。最后，计算相对差异 $\\delta_{\\text{phys}} = \\lVert x_{\\text{mix}} - x_{\\text{phys}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$ 和 $\\delta_{\\text{norm}} = \\lVert x_{\\text{mix}} - x_{\\text{norm}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$。\n\n所有输出必须是无量纲的十进制数。将所有报告的浮点数四舍五入到 $6$ 位小数。\n\n测试套件。使用以下三个测试用例。在每个用例中，矩阵 $A$ 有三列：第一列以米为单位，第二列以公里为单位，第三列是值为1的偏置列。向量 $b$ 已明确给出。\n\n测试用例 $1$（中等条件数，混合单位）：\n$$\nA_1 = \\begin{bmatrix}\n120  0.2  1 \\\\\n340  0.5  1 \\\\\n560  0.9  1 \\\\\n780  1.3  1 \\\\\n910  1.6  1 \\\\\n1050  2.0  1\n\\end{bmatrix},\\quad\nb_1 = \\begin{bmatrix}\n356 \\\\\n778 \\\\\n1325 \\\\\n1859 \\\\\n2253.5 \\\\\n2751.5\n\\end{bmatrix}.\n$$\n\n测试用例 $2$（列之间存在极端的尺度差异）：\n$$\nA_2 = \\begin{bmatrix}\n0.4  150  1 \\\\\n0.6  300  1 \\\\\n0.9  450  1 \\\\\n1.2  600  1 \\\\\n1.5  750  1\n\\end{bmatrix},\\quad\nb_2 = \\begin{bmatrix}\n75999.6 \\\\\n151002.9 \\\\\n225999.35 \\\\\n301002.8 \\\\\n376002.25\n\\end{bmatrix}.\n$$\n\n测试用例 $3$（米列和公里列近乎共线性，但矩阵为满秩）：\n$$\nA_3 = \\begin{bmatrix}\n960  0.95  1 \\\\\n1035  1.05  1 \\\\\n1220  1.20  1 \\\\\n1295  1.30  1 \\\\\n1500  1.50  1 \\\\\n1790  1.80  1 \\\\\n2105  2.10  1\n\\end{bmatrix},\\quad\nb_3 = \\begin{bmatrix}\n396 \\\\\n401 \\\\\n480 \\\\\n486 \\\\\n549 \\\\\n634 \\\\\n731\n\\end{bmatrix}.\n$$\n\n对于每个测试用例 $i \\in \\{1,2,3\\}$，令 $A_i$ 和 $b_i$ 如上所述。您的程序必须对每个 $i$ 执行以下操作：\n- 在混合单位下，通过基于 Householder 的正交分解求解最小二乘问题，得到 $x_{\\text{mix}}$。\n- 在物理缩放后，对 $A_i D_{\\text{phys}}$ 求解最小二乘问题得到 $y_{\\text{phys}}$，然后映射回 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$。\n- 在列归一化后，对 $A_i S_{\\text{norm}}$ 求解最小二乘问题得到 $y_{\\text{norm}}$，然后映射回 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$。\n- 按以下顺序计算并报告该用例的八个浮点数：\n$$\n\\big[\n\\lVert A_i x_{\\text{mix}} - b_i \\rVert_2,\\;\n\\lVert A_i x_{\\text{phys}} - b_i \\rVert_2,\\;\n\\lVert A_i x_{\\text{norm}} - b_i \\rVert_2,\\;\n\\kappa_2(A_i),\\;\n\\kappa_2(A_i D_{\\text{phys}}),\\;\n\\kappa_2(A_i S_{\\text{norm}}),\\;\n\\delta_{\\text{phys}},\\;\n\\delta_{\\text{norm}}\n\\big].\n$$\n\n最终输出格式。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，不含空格。顶层列表应包含三个与三个测试用例相对应的子列表，每个子列表按指定顺序包含八个四舍五入后的浮点数。例如，输出必须如下所示：\n$$\n\\big[\\,[f_{11},f_{12},\\dots,f_{18}],\\,[f_{21},f_{22},\\dots,f_{28}],\\,[f_{31},f_{32},\\dots,f_{38}]\\,\\big]\n$$\n其中每个 $f_{jk}$ 是一个格式化为 $6$ 位小数的十进制数。不得打印任何其他文本。", "solution": "该问题要求设计并实现一个数值稳定的求解器，用于求解超定线性最小二乘问题 $\\min_{x} \\lVert A x - b \\rVert_2$，其中 $A \\in \\mathbb{R}^{m \\times n}$，$m \\ge n$，$b \\in \\mathbb{R}^m$。指定的方法是使用 Householder 变换的 QR 分解。问题的关键在于研究通过缩放对矩阵 $A$ 进行预处理的效果，以解决由混合物理单位和悬殊的列范数引起的问题。\n\n其基本原理是欧几里得范数在正交变换下保持不变。如果 $Q \\in \\mathbbR^{m \\times m}$ 是一个正交矩阵（即 $Q^\\top Q = I$），那么对于任何向量 $z \\in \\mathbb{R}^m$，都有 $\\lVert Q z \\rVert_2 = \\lVert z \\rVert_2$。我们可以利用此性质，将矩阵 $A$ 分解为一个正交矩阵 $Q$ 和一个上三角矩阵 $R$ 的乘积，即 $A=QR$。最小二乘问题可以重写为：\n$$\n\\lVert A x - b \\rVert_2^2 = \\lVert Q R x - b \\rVert_2^2 = \\lVert Q^\\top (Q R x - b) \\rVert_2^2 = \\lVert R x - Q^\\top b \\rVert_2^2\n$$\n矩阵 $R \\in \\mathbb{R}^{m \\times n}$ 具有上三角结构。由于 $m \\ge n$，它可以被分块为：\n$$\nR = \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix}, \\quad \\text{其中 } R_1 \\in \\mathbb{R}^{n \\times n} \\text{ 是上三角矩阵。}\n$$\n同样，变换后的向量 $Q^\\top b$ 可以被分块为：\n$$\nQ^\\top b = \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix}, \\quad \\text{其中 } c_1 \\in \\mathbb{R}^n \\text{ 且 } c_2 \\in \\mathbb{R}^{m-n}.\n$$\n因此，最小化问题转化为：\n$$\n\\min_{x} \\left\\lVert \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix} x - \\begin{bmatrix} c_1 \\\\ c_2 \\end{bmatrix} \\right\\rVert_2^2 = \\min_{x} \\left( \\lVert R_1 x - c_1 \\rVert_2^2 + \\lVert c_2 \\rVert_2^2 \\right)\n$$\n项 $\\lVert c_2 \\rVert_2^2$ 与 $x$ 无关。当 $\\lVert R_1 x - c_1 \\rVert_2^2 = 0$ 时，该表达式达到最小值。假设 $A$ 的列是线性无关的，则 $A$ 具有满秩，且 $R_1$ 是可逆的。因此，唯一的最小二乘解 $x$ 可以通过求解方阵上三角系统得到：\n$$\nR_1 x = c_1\n$$\n这个系统可以使用回代法高效求解。最终残差的范数平方为 $\\lVert A x - b \\rVert_2^2 = \\lVert c_2 \\rVert_2^2$。\n\nQR 分解是通过一系列 Householder 变换来构造的。Householder 变换是关于一个超平面的反射，由矩阵 $H = I - 2 \\frac{v v^\\top}{v^\\top v}$ 表示，其中 $v \\in \\mathbb{R}^k$ 为非零向量。对于任意向量 $z \\in \\mathbb{R}^k$，我们可以选择一个向量 $v$ 使得 $H z$ 是标准基向量 $e_1 = [1, 0, \\dots, 0]^\\top$ 的倍数。具体来说，向量 $v$ 选择为 $v = z + \\alpha e_1$，其中 $\\alpha = \\text{sgn}(z_1) \\lVert z \\rVert_2$。选择这个符号是为了避免当 $z$ 与 $e_1$ 近乎平行时发生灾难性抵消。\n\n对 $A$ 进行 QR 分解的算法逐列进行。对于从 $1$ 到 $n$ 的每一列 $j$：\n$1$. 考虑由第 $j$ 列从对角线及以下元素组成的向量 $z$，即 $A_{j:m, j}$。\n$2$. 构造相应的 Householder 向量 $v_j$ 和变换矩阵 $H_j$。\n$3$. 将此变换应用于 $A$ 的从第 $j$ 行到第 $m$ 行、从第 $j$ 列到第 $n$ 列的子矩阵。这将在第 $j$ 列的对角线下方引入零。相同的变换必须应用于向量 $b$ 的相应元素。\n经过 $n$ 步后，矩阵 $A$ 被转换为上三角矩阵 $R$，向量 $b$ 被转换为 $Q^\\top b$。形式上，$R = H_n \\cdots H_2 H_1 A$ 且 $Q^\\top b = H_n \\cdots H_2 H_1 b$，其中 $Q = H_1 H_2 \\cdots H_n$。该算法不需要显式地构造矩阵 $Q$。\n\n该问题研究了基于矩阵缩放的三种场景：\n$1$. **混合单位**：使用给定的矩阵 $A$ 求解问题。解为 $x_{\\text{mix}}$。\n$2$. **物理缩放**：矩阵 $A$ 右乘一个对角缩放矩阵 $D_{\\text{phys}}$。对于给定问题，第二列以公里为单位，而其他列以米为单位或无量纲。为将公里转换为米，我们设置 $D_{\\text{phys}} = \\text{diag}(1, 1000, 1)$。为缩放后的矩阵 $\\hat{A}_{\\text{phys}} = A D_{\\text{phys}}$ 求解最小二乘问题以找到解 $y_{\\text{phys}}$。在原始未缩放坐标系中的解通过 $x_{\\text{phys}} = D_{\\text{phys}} y_{\\text{phys}}$ 恢复。\n$3$. **列归一化**：矩阵 $A$ 右乘一个对角矩阵 $S_{\\text{norm}} = \\text{diag}(1/\\lVert a_1 \\rVert_2, \\dots, 1/\\lVert a_n \\rVert_2)$，其中 $a_j$ 是 $A$ 的第 $j$ 列。这种缩放使得新矩阵 $\\hat{A}_{\\text{norm}} = A S_{\\text{norm}}$ 的每一列都具有单位 $\\ell_2$-范数。为 $\\hat{A}_{\\text{norm}}$ 求解最小二乘问题以找到 $y_{\\text{norm}}$，原始解通过 $x_{\\text{norm}} = S_{\\text{norm}} y_{\\text{norm}}$ 恢复。\n\n分析需要为每个场景计算几个指标：\n- **残差范数**：$\\lVert A x - b \\rVert_2$，其中 $x \\in \\{x_{\\text{mix}}, x_{\\text{phys}}, x_{\\text{norm}}\\}$。在精确算术中，这些值将是相同的，但在浮点运算中，由于底层问题的数值稳定性不同，它们可能会有所不同。\n- **条件数**：$2$-范数条件数 $\\kappa_2(M) = \\sigma_{\\max}(M) / \\sigma_{\\min}(M)$，衡量解对数据扰动的敏感度。我们计算 $\\kappa_2(A)$、$\\kappa_2(A D_{\\text{phys}})$ 和 $\\kappa_2(A S_{\\text{norm}})$。较低的条件数通常意味着一个数值更稳定的问题。\n- **相对差异**：$\\delta_{\\text{phys}} = \\lVert x_{\\text{mix}} - x_{\\text{phys}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$ 和 $\\delta_{\\text{norm}} = \\lVert x_{\\text{mix}} - x_{\\text{norm}} \\rVert_2 / \\lVert x_{\\text{mix}} \\rVert_2$。这些量化了从缩放矩阵得到的解与未缩放矩阵得到的解之间的数值偏差。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the least squares problems for the given test cases.\n    \"\"\"\n\n    def householder_qr_solve(A, b):\n        \"\"\"\n        Solves the least squares problem min ||Ax - b||_2 using Householder QR factorization.\n\n        Args:\n            A (np.ndarray): The matrix A (m x n).\n            b (np.ndarray): The vector b (m,).\n\n        Returns:\n            np.ndarray: The solution vector x (n,).\n        \"\"\"\n        m, n = A.shape\n        R = A.copy()\n        c = b.copy().flatten()\n\n        for j in range(n):\n            # Extract the j-th column from the diagonal down\n            z = R[j:, j].copy()\n            \n            # Compute the Householder vector v\n            # Use `np.copysign` to handle the sign of 0 correctly\n            norm_z = np.linalg.norm(z)\n            alpha = -np.copysign(norm_z, z[0]) if norm_z != 0 else 0.0\n            \n            v = z.copy()\n            v[0] -= alpha\n            \n            norm_v = np.linalg.norm(v)\n            if norm_v  1e-12: # Check to avoid division by zero\n                v = v / norm_v  # Normalize v to a unit vector u\n\n                # Apply reflection to the remaining submatrix of R\n                sub_matrix_R = R[j:, j:]\n                R[j:, j:] -= 2 * np.outer(v, v.T @ sub_matrix_R)\n\n                # Apply reflection to the corresponding part of b\n                sub_c = c[j:]\n                c[j:] -= 2 * v * (v.T @ sub_c)\n\n        # Extract the upper triangular matrix R1 and the vector c1\n        R1 = R[:n, :n]\n        c1 = c[:n]\n\n        # Solve the upper triangular system R1 @ x = c1 using back substitution\n        x = np.zeros(n)\n        for i in range(n - 1, -1, -1):\n            s = c1[i] - np.dot(R1[i, i + 1:], x[i + 1:])\n            x[i] = s / R1[i, i]\n            \n        return x\n\n    test_cases = [\n        (\n            np.array([\n                [120., 0.2, 1.], [340., 0.5, 1.], [560., 0.9, 1.],\n                [780., 1.3, 1.], [910., 1.6, 1.], [1050., 2.0, 1.]\n            ]),\n            np.array([356., 778., 1325., 1859., 2253.5, 2751.5])\n        ),\n        (\n            np.array([\n                [0.4, 150., 1.], [0.6, 300., 1.], [0.9, 450., 1.],\n                [1.2, 600., 1.], [1.5, 750., 1.]\n            ]),\n            np.array([75999.6, 151002.9, 225999.35, 301002.8, 376002.25])\n        ),\n        (\n            np.array([\n                [960., 0.95, 1.], [1035., 1.05, 1.], [1220., 1.20, 1.],\n                [1295., 1.30, 1.], [1500., 1.50, 1.], [1790., 1.80, 1.],\n                [2105., 2.10, 1.]\n            ]),\n            np.array([396., 401., 480., 486., 549., 634., 731.])\n        )\n    ]\n\n    all_results = []\n    \n    for A, b in test_cases:\n        # Scenario 1: Mixed Units (unscaled)\n        x_mix = householder_qr_solve(A, b)\n        res_norm_mix = np.linalg.norm(A @ x_mix - b.flatten())\n        cond_mix = np.linalg.cond(A, 2)\n\n        # Scenario 2: Physical Scaling\n        # Column 2 is in km, convert to m by multiplying by 1000.\n        D_phys = np.diag([1.0, 1000.0, 1.0])\n        A_phys = A @ D_phys\n        y_phys = householder_qr_solve(A_phys, b)\n        x_phys = D_phys @ y_phys\n        res_norm_phys = np.linalg.norm(A @ x_phys - b.flatten())\n        cond_phys = np.linalg.cond(A_phys, 2)\n        \n        # Scenario 3: Column Normalization Scaling\n        col_norms = np.linalg.norm(A, axis=0)\n        S_norm = np.diag(1.0 / col_norms)\n        A_norm = A @ S_norm\n        y_norm = householder_qr_solve(A_norm, b)\n        x_norm = S_norm @ y_norm\n        res_norm_norm = np.linalg.norm(A @ x_norm - b.flatten())\n        cond_norm = np.linalg.cond(A_norm, 2)\n\n        # Relative differences in solutions\n        delta_phys = np.linalg.norm(x_mix - x_phys) / np.linalg.norm(x_mix)\n        delta_norm = np.linalg.norm(x_mix - x_norm) / np.linalg.norm(x_mix)\n\n        case_results = [\n            res_norm_mix, res_norm_phys, res_norm_norm,\n            cond_mix, cond_phys, cond_norm,\n            delta_phys, delta_norm\n        ]\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified.\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_floats = [f\"{val:.6f}\" for val in case_res]\n        formatted_cases.append(f\"[{','.join(formatted_floats)}]\")\n    \n    print(f\"[{','.join(formatted_cases)}]\")\n\nsolve()\n```", "id": "3275437"}, {"introduction": "标准的最小二乘法解决了无约束的优化问题，但在许多科学和工程应用中，我们还需要解满足特定线性等式约束。这个练习将最小二乘法推广到等式约束最小二乘（ECLS）问题：在满足 $Cx=d$ 的条件下，最小化 $\\|Ax-b\\|_2$ [@problem_id:3275428]。你将学习并实现一种强大的“零空间法”，该方法利用约束矩阵 $C$ 的QR分解，将复杂的约束问题巧妙地转化为一个更小的、无约束的最小二乘问题来求解。", "problem": "要求您设计并实现一个完整的、可运行的程序，通过正交分解和零空间约简来求解等式约束最小二乘（LS）问题。问题是在线性约束 $C x = d$ 下，最小化欧几里得范数目标 $\\|A x - b\\|_2$。程序必须基于以下基本原理构建一个有原则的数值解法：\n- 欧几里得范数的定义 $\\|y\\|_2 = \\sqrt{y^\\top y}$。\n- LS的定义：对于给定的矩阵 $A$ 和向量 $b$，找到一个 $x$ 以最小化 $\\|A x - b\\|_2$。\n- 正交矩阵 $Q$ 的定义，满足 $Q^\\top Q = I$。\n- 一个实数矩阵 $M$ 分解为一个正交因子和一个上三角因子的QR分解的存在性；将此分解应用于约束矩阵的转置 $C^\\top$，以导出其列空间及其正交补的一组标准正交基。\n- C 的零空间的概念，记为 $\\mathcal{N}(C) = \\{x : C x = 0\\}$。\n\n您的程序必须：\n- 基于 $C^\\top$ 的QR分解获得一个标准正交分解，用它来参数化 $C x = d$ 的可行集，将有约束的LS问题简化为一个变量更少的无约束LS问题，并再次使用QR分解求解该简化问题，从而构建一个算法解决方案。\n- 避免使用特设公式；设计必须基于上述基本定义和性质。\n\n输入固定在程序内部；不要从文件或标准输入读取。程序必须能够直接运行，并产生单行输出。\n\n测试套件：\n实现求解器并在以下四个测试用例上进行评估。每个用例都明确定义了 $A$、$b$、$C$ 和 $d$。\n\n用例1（理想情况，超定 $A$，部分约束）：\n令 $A \\in \\mathbb{R}^{6 \\times 4}$，$b \\in \\mathbb{R}^{6}$，$C \\in \\mathbb{R}^{2 \\times 4}$，$d \\in \\mathbb{R}^{2}$ 为\n$$\nA =\n\\begin{bmatrix}\n2  -1  0  0 \\\\\n1  3  -2  1 \\\\\n0  1  4  -1 \\\\\n3  0  1  2 \\\\\n0  2  0  1 \\\\\n1  0  -1  1\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 3 \\\\ 0 \\\\ -1 \\\\ 4\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  1  0 \\\\\n0  1  -1  2\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n1 \\\\ 0.5\n\\end{bmatrix}.\n$$\n\n用例2（无约束，无约束LS）：\n令 $A \\in \\mathbb{R}^{5 \\times 3}$，$b \\in \\mathbb{R}^{5}$，$C \\in \\mathbb{R}^{0 \\times 3}$，$d \\in \\mathbb{R}^{0}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  2  0 \\\\\n0  1  1 \\\\\n3  -1  2 \\\\\n0  0  1 \\\\\n2  1  0\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 0 \\\\ 4 \\\\ -1 \\\\ 2\n\\end{bmatrix},\\quad\nC = \\text{一个 } 0 \\text{ 行 } 3 \\text{ 列的空矩阵}，\\quad\nd = \\text{一个空向量}。\n$$\n\n用例3（完全约束，$m = n$）：\n令 $A \\in \\mathbb{R}^{4 \\times 3}$，$b \\in \\mathbb{R}^{4}$，$C \\in \\mathbb{R}^{3 \\times 3}$，$d \\in \\mathbb{R}^{3}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  0  2 \\\\\n0  1  -1 \\\\\n2  -1  0 \\\\\n1  1  1\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n3 \\\\ -1 \\\\ 2 \\\\ 0\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n0  0  1\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n0.5 \\\\ -1.0 \\\\ 2.0\n\\end{bmatrix}.\n$$\n\n用例4（单约束，较大的 $n$）：\n令 $A \\in \\mathbb{R}^{7 \\times 5}$，$b \\in \\mathbb{R}^{7}$，$C \\in \\mathbb{R}^{1 \\times 5}$，$d \\in \\mathbb{R}^{1}$ 为\n$$\nA =\n\\begin{bmatrix}\n1  0  2  -1  0 \\\\\n0  1  0  2  -1 \\\\\n2  -1  1  0  1 \\\\\n0  0  1  1  0 \\\\\n1  2  -1  0  2 \\\\\n3  0  0  -2  1 \\\\\n0  1  1  0  0\n\\end{bmatrix},\\quad\nb =\n\\begin{bmatrix}\n1 \\\\ 2 \\\\ 0 \\\\ -1 \\\\ 3 \\\\ 4 \\\\ 0.5\n\\end{bmatrix},\\quad\nC =\n\\begin{bmatrix}\n1  0  -1  0  2\n\\end{bmatrix},\\quad\nd =\n\\begin{bmatrix}\n1.0\n\\end{bmatrix}.\n$$\n\n输出规范：\n对于每个测试用例，计算解向量 $x^\\star$，残差范数 $r = \\|A x^\\star - b\\|_2$ 和约束违反度 $v = \\|C x^\\star - d\\|_2$。将所有浮点数四舍五入到六位小数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果本身也是一个浮点数列表，按 $[x_1,\\ldots,x_n,r,v]$ 的顺序排列，其中 $n$ 是对应案例的维度。\n\n例如，最终输出格式必须类似于\n$$\n\\texttt{[[x_1,x_2,\\ldots,x_n,r,v],[...],[...],[...]]}\n$$\n所有浮点数都四舍五入到六位小数。\n\n角度单位和物理单位不适用于这个纯数学问题；输出中不要包含任何单位。", "solution": "问题是找到向量 $x \\in \\mathbb{R}^n$，在一组线性等式约束 $C x = d$ 下，最小化残差的欧几里得范数 $\\|A x - b\\|_2$。这里，$A \\in \\mathbb{R}^{m \\times n}$，$b \\in \\mathbb{R}^m$，$C \\in \\mathbb{R}^{p \\times n}$，$d \\in \\mathbb{R}^p$。这是一个等式约束最小二乘（ECLS）问题。一个稳健且有原则的解决方法是零空间法，它将约束问题转换为一个更小的无约束问题。推导过程如下，基于问题描述中概述的基本原理。\n\n首先，我们刻画满足约束 $C x = d$ 的所有向量 $x$ 的集合。这个集合是 $\\mathbb{R}^n$ 的一个仿射子空间。任何解 $x$都可以表示为一个特解 $x_p$（满足 $C x_p = d$）和一个齐次解 $x_h$（满足 $C x_h = 0$）的和。齐次解 $x_h$ 必须位于 $C$ 的零空间中，记为 $\\mathcal{N}(C)$。\n$$\nx = x_p + x_h, \\quad \\text{where } x_h \\in \\mathcal{N}(C)\n$$\n\n该方法的核心是找到零空间 $\\mathcal{N}(C)$ 的一组标准正交基和一个合适的特解 $x_p$。问题指定使用约束矩阵转置 $C^\\top$ 的QR分解。令 $C^\\top \\in \\mathbb{R}^{n \\times p}$ 的QR分解为：\n$$\nC^\\top = QR\n$$\n其中 $Q \\in \\mathbb{R}^{n \\times n}$ 是一个正交矩阵（$Q^\\top Q = I_n$），$R \\in \\mathbb{R}^{n \\times p}$ 是一个上梯形矩阵。我们假设约束矩阵 $C$ 具有满行秩，即 $\\text{rank}(C)=p$。这意味着 $C^\\top$ 具有满列秩。\n\n我们将正交矩阵 $Q$ 分成两个块：\n$$\nQ = \\begin{bmatrix} Q_1  Q_2 \\end{bmatrix}\n$$\n其中 $Q_1 \\in \\mathbb{R}^{n \\times p}$ 且 $Q_2 \\in \\mathbb{R}^{n \\times (n-p)}$。$Q_1$ 的列构成了 $C^\\top$ 的值域 $\\mathcal{R}(C^\\top)$ 的一组标准正交基。$Q_2$ 的列构成了 $\\mathcal{R}(C^\\top)$ 的正交补的一组标准正交基，而这恰好是 $C$ 的零空间 $\\mathcal{N}(C)$。因此，任何齐次解 $x_h$ 都可以写成 $Q_2$ 的列的线性组合：\n$$\nx_h = Q_2 z\n$$\n其中 $z \\in \\mathbb{R}^{n-p}$ 是某个自由参数向量。\n\n接下来，我们寻找一个特解 $x_p$。一个方便的选择是 $C x = d$ 的最小范数解，该解完全位于 $C^\\top$ 的值域中。因此，我们可以将其表示为 $x_p = Q_1 y$，其中 $y \\in \\mathbb{R}^p$ 是某个向量。为了求出 $y$，我们将其代入约束方程：\n$$\nC x_p = d \\implies C (Q_1 y) = d\n$$\n根据QR分解，我们有 $C = (QR)^\\top = R^\\top Q^\\top$。矩阵 $R$ 可以分块为 $R = \\begin{bmatrix} R_1 \\\\ 0 \\end{bmatrix}$，其中 $R_1 \\in \\mathbb{R}^{p \\times p}$ 是上三角矩阵并且可逆（因为 $\\text{rank}(C)=p$）。将此代入前面的方程得到：\n$$\nR^\\top Q^\\top (Q_1 y) = \\begin{bmatrix} R_1^\\top  0 \\end{bmatrix} \\begin{bmatrix} Q_1^\\top \\\\ Q_2^\\top \\end{bmatrix} (Q_1 y) = R_1^\\top Q_1^\\top Q_1 y = d\n$$\n由于 $Q_1^\\top Q_1 = I_p$，该方程简化为一个关于 $y$ 的下三角系统：\n$$\nR_1^\\top y = d\n$$\n这个方程组可以使用前向替换法求解 $y$。然后特解为 $x_p = Q_1 y$。\n\n利用完整的参数化表示 $x = x_p + Q_2 z$，我们将其代回原始的最小二乘目标函数：\n$$\n\\min_{x} \\|A x - b\\|_2 \\quad \\implies \\quad \\min_{z} \\|A (x_p + Q_2 z) - b\\|_2\n$$\n重新整理各项，我们得到：\n$$\n\\min_{z} \\| (A Q_2) z - (b - A x_p) \\|_2\n$$\n这是一个关于未知向量 $z \\in \\mathbb{R}^{n-p}$ 的无约束最小二乘问题。令 $\\hat{A} = A Q_2$ 和 $\\hat{b} = b - A x_p$。现在问题是找到 $z^\\star$ 以最小化 $\\|\\hat{A} z - \\hat{b}\\|_2$。\n\n这个标准的最小二乘问题可以通过其自身的QR分解来求解。令 $\\hat{A}$ 的分解为 $\\hat{A} = \\hat{Q} \\hat{R}$，其中 $\\hat{Q}$ 是正交的，$\\hat{R}$ 是上梯形的。目标函数变为：\n$$\n\\|\\hat{Q} \\hat{R} z - \\hat{b}\\|_2 = \\|\\hat{Q}^\\top(\\hat{Q} \\hat{R} z - \\hat{b})\\|_2 = \\|\\hat{R} z - \\hat{Q}^\\top \\hat{b}\\|_2\n$$\n令 $\\hat{R}_1$ 为 $\\hat{R}$ 的上三角部分，令 $c_1$ 为向量 $\\hat{c} = \\hat{Q}^\\top \\hat{b}$ 的相应部分。通过使用回代法求解上三角系统 $\\hat{R}_1 z = c_1$ 来找到解 $z^\\star$。\n\n最后，通过组合特解和齐次解部分，重构原始ECLS问题的最优解 $x^\\star$：\n$$\nx^\\star = x_p + Q_2 z^\\star\n$$\n残差范数计算为 $r = \\|A x^\\star - b\\|_2$，约束违反度范数计算为 $v = \\|C x^\\star - d\\|_2$。根据构造， $v$ 应该接近于机器精度。\n\n这种使用正交分解的、有原则的、逐步简化的方法，为求解等式约束最小二乘问题提供了一种数值稳定且精确的方法。该算法能够优雅地处理边缘情况，例如没有约束的问题（$p=0$）或解完全由约束确定的问题（$p=n$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_ecls(A, b, C, d):\n    \"\"\"\n    Solves an equality-constrained least squares problem using the null-space method.\n\n    Problem: minimize ||A*x - b||_2 subject to C*x = d.\n\n    Args:\n        A (np.ndarray): Matrix A of size m x n.\n        b (np.ndarray): Vector b of size m.\n        C (np.ndarray): Constraint matrix C of size p x n.\n        d (np.ndarray): Constraint vector d of size p.\n\n    Returns:\n        tuple: A tuple containing:\n            - x_star (np.ndarray): The solution vector of size n.\n            - residual_norm (float): The final residual norm ||A*x_star - b||_2.\n            - constraint_violation (float): The constraint violation ||C*x_star - d||_2.\n    \"\"\"\n    m, n = A.shape\n    p = C.shape[0]\n\n    if p == 0:\n        # Case with no constraints: reduces to a standard least squares problem.\n        # This branch aligns with the general logic by setting up identity transformations.\n        xp = np.zeros(n)\n        Q2 = np.eye(n)\n        A_hat = A\n        b_hat = b\n    else:\n        # Perform QR factorization on the transpose of the constraint matrix C\n        # C is p x n, so C.T is n x p.\n        Q, R = np.linalg.qr(C.T, mode='complete')\n\n        # Partition Q and R\n        # Q is n x n, R is n x p\n        Q1 = Q[:, :p]\n        Q2 = Q[:, p:]\n        R1 = R[:p, :]\n\n        # Find the particular solution xp to C*x = d\n        # Solve the lower triangular system R1.T * y = d\n        y = np.linalg.solve(R1.T, d)\n        xp = Q1 @ y\n\n        # Form the reduced unconstrained least squares problem\n        # min ||(A*Q2)*z - (b - A*xp)||_2\n        A_hat = A @ Q2\n        b_hat = b - A @ xp\n\n    # Solve the reduced unconstrained LS problem for the coefficients z of the null space\n    k = A_hat.shape[1]  # This is n-p\n    if k  0:\n        # Use QR factorization of A_hat to solve for z\n        Q_hat, R_hat = np.linalg.qr(A_hat, mode='reduced')\n\n        # Solve R_hat * z = Q_hat.T * b_hat\n        c_hat = Q_hat.T @ b_hat\n        z_star = np.linalg.solve(R_hat, c_hat)\n    else:\n        # Trivial case where the null space is empty (n=p)\n        z_star = np.array([])\n    \n    # Reconstruct the final solution\n    # Q2 @ z_star produces a vector of zeros if z_star is empty\n    x_star = xp + Q2 @ z_star\n\n    # Calculate final norms for verification and output\n    residual_norm = np.linalg.norm(A @ x_star - b)\n    if p  0:\n        constraint_violation = np.linalg.norm(C @ x_star - d)\n    else:\n        constraint_violation = 0.0\n\n    return x_star, residual_norm, constraint_violation\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and print results in the specified format.\n    \"\"\"\n    # Case 1\n    A1 = np.array([\n        [2., -1., 0., 0.], [1., 3., -2., 1.], [0., 1., 4., -1.],\n        [3., 0., 1., 2.], [0., 2., 0., 1.], [1., 0., -1., 1.]\n    ])\n    b1 = np.array([1., 2., 3., 0., -1., 4.])\n    C1 = np.array([[1., 0., 1., 0.], [0., 1., -1., 2.]])\n    d1 = np.array([1., 0.5])\n\n    # Case 2\n    A2 = np.array([\n        [1., 2., 0.], [0., 1., 1.], [3., -1., 2.],\n        [0., 0., 1.], [2., 1., 0.]\n    ])\n    b2 = np.array([1., 0., 4., -1., 2.])\n    C2 = np.empty((0, 3))\n    d2 = np.empty(0)\n\n    # Case 3\n    A3 = np.array([\n        [1., 0., 2.], [0., 1., -1.], [2., -1., 0.], [1., 1., 1.]\n    ])\n    b3 = np.array([3., -1., 2., 0.])\n    C3 = np.array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]])\n    d3 = np.array([0.5, -1.0, 2.0])\n\n    # Case 4\n    A4 = np.array([\n        [1., 0., 2., -1., 0.], [0., 1., 0., 2., -1.], [2., -1., 1., 0., 1.],\n        [0., 0., 1., 1., 0.], [1., 2., -1., 0., 2.], [3., 0., 0., -2., 1.],\n        [0., 1., 1., 0., 0.]\n    ])\n    b4 = np.array([1., 2., 0., -1., 3., 4., 0.5])\n    C4 = np.array([[1., 0., -1., 0., 2.]])\n    d4 = np.array([1.0])\n\n    test_cases = [\n        (A1, b1, C1, d1),\n        (A2, b2, C2, d2),\n        (A3, b3, C3, d3),\n        (A4, b4, C4, d4),\n    ]\n\n    all_results = []\n    for A, b, C, d in test_cases:\n        x_star, r, v = solve_ecls(A, b, C, d)\n        case_result = list(x_star) + [r, v]\n        all_results.append(case_result)\n    \n    # Format the final output string exactly as specified.\n    list_strs = []\n    for case_res in all_results:\n        num_strs = [f\"{x:.6f}\" for x in case_res]\n        list_strs.append(f\"[{','.join(num_strs)}]\")\n    final_output = f\"[{','.join(list_strs)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3275428"}]}