{"hands_on_practices": [{"introduction": "要真正掌握B样条，最好的方法就是亲手实现它。这个练习将引导您将B样条的核心数学定义转化为一个可工作的计算机程序。您将直接根据Cox-de Boor递推公式实现B样条的求值算法，并用它来验证一个关键属性：固定端点的节点向量（clamped knot vector）如何确保样条曲线精确地通过其首尾两个控制点。[@problem_id:3207506]", "problem": "你需要编写一个完整、可运行的程序，用于构建和评估一条基样条（B-spline）曲线，并保证该曲线能够插值其第一个和最后一个控制点。你的设计必须从 B-spline 基函数的核心递归定义出发，并进而实现一个兼顾数值稳定性和正确性的算法。\n\n从以下基本原理开始：B-spline 基函数的 Cox–de Boor 递归定义。对于一个给定的非递减节点向量 $\\{t_0, t_1, \\dots, t_m\\}$ 和次数 $p \\ge 0$，基函数 $N_{i,p}(u)$ 通过以下方式递归定义\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  t_i \\le u  t_{i+1} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n对于 $p \\ge 1$，\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u),\n$$\n约定分母为零的项视为零。参数曲线则由下式给出\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i,\n$$\n其中 $\\{\\mathbf{P}_0,\\dots,\\mathbf{P}_n\\}$ 是控制点。当节点向量是钳位（clamped）（也称为开放（open））的，即第一个和最后一个节点各重复 $p+1$ 次时，可以保证曲线在其参数域的两端插值第一个和最后一个控制点。你的任务是实现一个使用这些定义的求值算法，并通过一个测试套件来证明你的曲线精确地通过其第一个和最后一个控制点。\n\n要求：\n- 基于上述递归基函数定义，实现 B-spline 曲线求值，采用适合高等本科数值方法课程的数值稳定方法。你必须通过在两端使用重复度为 $p+1$ 的钳位节点向量来确保端点插值。\n- 求值域必须是 $[t_p, t_{m-p}]$。在 $u = t_p$ 和 $u = t_{m-p}$ 处，曲线必须分别返回 $\\mathbf{P}_0$ 和 $\\mathbf{P}_n$。\n- 使用欧几里得距离比较向量相等性，容差为 $10^{-9}$，相对容差为零。如果范数差小于或等于 $10^{-9}$，则视为相等。\n\n测试套件和参数：\n对于下面的每个测试用例，在左端点 $u = t_p$ 和右端点 $u = t_{m-p}$ 处对曲线进行求值，并检查这些点是否在容差范围内与第一个和最后一个控制点匹配。你的程序应该为每个测试用例生成一个布尔值，表示两个端点检查是否都通过。\n\n设每个控制点 $\\mathbf{P}_i$ 是一个二维或三维坐标向量，具体维度按规定。节点向量要么是明确给出的，要么必须构造成钳位开放均匀（clamped open-uniform）节点向量。一个长度为 $m+1 = n + p + 2$ 的开放均匀钳位节点向量，其前 $p+1$ 个元素等于 $0$，后 $p+1$ 个元素等于 $1$，内部节点在 $(0,1)$ 区间内均匀分布。\n\n- 测试用例 1（正常情况，二维，二次钳位开放均匀）：\n  - 次数 $p = 2$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_4$: $\\{(0,0),(1,2),(2,0.5),(3,3),(4,0)\\}$。\n  - 为 $n=4, p=2$ 构建一个钳位开放均匀节点向量。\n- 测试用例 2（内部节点最少的边界情况，三次钳位开放均匀，类贝塞尔）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_3$: $\\{(0,0),(1,2),(3,2),(4,0)\\}$。\n  - 为 $n=3, p=3$ 构建一个钳位开放均匀节点向量。\n- 测试用例 3（非均匀钳位，二维）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_6$: $\\{(0,0),(1,1),(2,-1),(3,2),(4,-0.5),(5,1.5),(6,0)\\}$。\n  - 显式钳位非均匀节点向量：$\\{0,0,0,0,0.15,0.6,0.85,1,1,1,1\\}$。\n- 测试用例 4（边缘情况，线性钳位开放均匀）：\n  - 次数 $p = 1$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_2$: $\\{(0,1),(1,0),(2,1.5)\\}$。\n  - 为 $n=2, p=1$ 构建一个钳位开放均匀节点向量。\n- 测试用例 5（三维，三次钳位开放均匀）：\n  - 次数 $p = 3$。\n  - 控制点 $\\mathbf{P}_0,\\dots,\\mathbf{P}_5$: $\\{(0,0,0),(1,2,1),(2,-1,2),(3,3,2),(4,0,1),(5,1,0)\\}$。\n  - 为 $n=5, p=3$ 构建一个钳位开放均匀节点向量。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $\\texttt{[true,false,true]}$。请使用小写的 Python 布尔值格式。该列表必须按上述顺序列出每个测试用例的布尔结果。", "solution": "该问题要求实现并验证 B-spline 曲线的求值，并展示钳位节点向量的端点插值属性。解决方案直接源于问题陈述中提供的 B-spline 基函数的基本递归定义。\n\n一条次数为 $p$ 的 B-spline 曲线 $\\mathbf{C}(u)$ 是一个参数曲线，定义为 $n+1$ 个控制点 $\\{\\mathbf{P}_0, \\dots, \\mathbf{P}_n\\}$ 的加权和：\n$$\n\\mathbf{C}(u) = \\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i\n$$\n权重是 B-spline 基函数 $N_{i,p}(u)$，它们是次数为 $p$ 的分段多项式。其定义依赖于一个称为节点向量的非递减实数序列 $T = \\{t_0, t_1, \\dots, t_m\\}$，其中必须满足关系式 $m = n+p+1$。基函数由 Cox–de Boor 递归公式定义。\n\n对于 $p=0$：\n$$\nN_{i,0}(u) = \n\\begin{cases}\n1,  \\text{if } t_i \\le u  t_{i+1} \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n该定义意味着对于任何零长度区间，即 $t_i = t_{i+1}$，基函数 $N_{i,0}(u)$ 恒为 $0$。需要对参数值 $u$ 在定义域的最末端进行特殊考虑。如果曲线定义域为 $[t_p, t_{n+1}]$，那么当 $u = t_{n+1}$ 时，相关的非零 0 次基函数取为 $N_{n,0}(t_{n+1})=1$。\n\n对于 $p \\ge 1$：\n$$\nN_{i,p}(u) = \\frac{u - t_i}{t_{i+p} - t_i} N_{i,p-1}(u) + \\frac{t_{i+p+1} - u}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(u)\n$$\n问题规定，如果此表达式中的分母为零，则相应项被视为零。\n\n任务的核心是基于这些定义实现 $\\mathbf{C}(u)$ 的算法，并验证对于钳位节点向量，$\\mathbf{C}(t_p) = \\mathbf{P}_0$ 和 $\\mathbf{C}(t_{n+1}) = \\mathbf{P}_n$ 成立。钳位节点向量的首尾各有 $p+1$ 个节点相等。这种结构确保了 $N_{0,p}(t_p)=1$ 和 $N_{n,p}(t_{n+1})=1$，而所有其他基函数 $N_{i,p}$ 在各自的端点处为零，从而实现插值。\n\n对于每个测试用例，总体算法流程如下：\n1.  **参数设置**：定义次数 $p$ 和 $n+1$ 个控制点集合 $\\{\\mathbf{P}_i\\}$。\n2.  **节点向量构建**：构建节点向量 $T$。对于需要钳位开放均匀节点向量的情况，前 $p+1$ 个节点设为 $0$，后 $p+1$ 个节点设为 $1$，而 $n-p$ 个内部节点在区间 $(0,1)$ 内均匀分布。节点数量为 $m+1 = n+p+2$。\n3.  **端点处的曲线求值**：\n    *   在曲线定义域的左端点 $u_{left} = t_p$ 处进行求值。\n    *   在曲线定义域的右端点 $u_{right} = t_{n+1}$ 处进行求值。\n    *   求值本身，即 $\\mathbf{C}(u)$，由一个计算 $\\sum_{i=0}^{n} N_{i,p}(u)\\,\\mathbf{P}_i$ 的函数执行。\n4.  **基函数计算**：每个基函数 $N_{i,p}(u)$ 的值通过一个直接实现 Cox-de Boor 公式的递归函数计算。为确保计算可行性，该递归函数被记忆化（一种动态规划形式），以防止对相同基函数值的重复计算。基例 $N_{i,0}(u)$ 的实现必须仔细处理半开区间以及在定义域右端点的特殊情况。\n5.  **验证**：将计算出的点 $\\mathbf{C}(u_{left})$ 与第一个控制点 $\\mathbf{P}_0$ 进行比较，并将 $\\mathbf{C}(u_{right})$ 与最后一个控制点 $\\mathbf{P}_n$ 进行比较。比较是通过计算向量之间的欧几里得距离来完成的。如果两个端点的距离都在指定的 $10^{-9}$ 容差范围内，则该测试用例视为通过。\n\n实现封装了这些步骤。一个主函数遍历测试套件，调用辅助函数来构建节点向量并评估 B-spline 曲线。求值函数 `b_spline_eval` 使用一个嵌套的辅助函数 `_basis_function` 来递归计算基函数。这种嵌套结构使得递归函数保持简洁，同时能够访问参数 $u$、节点向量 $T$ 和记忆化字典，从而避免了使用全局状态。每个测试用例的结果（一个布尔值）被收集起来，并以指定的格式打印。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef build_clamped_uniform_knot_vector(n, p):\n    \"\"\"\n    Constructs a clamped open-uniform knot vector.\n    The domain for the interior knots is (0, 1).\n    \n    Args:\n        n (int): The number of control points minus 1.\n        p (int): The degree of the B-spline.\n        \n    Returns:\n        np.ndarray: The knot vector of length n + p + 2.\n    \"\"\"\n    num_knots = n + p + 2\n    T = np.zeros(num_knots, dtype=float)\n    \n    num_interior_knots = n - p\n    if num_interior_knots  0:\n      denominator = float(n - p + 1)\n      T[p + 1 : n + 1] = np.arange(1, num_interior_knots + 1) / denominator\n    \n    T[n + 1:] = 1.0\n    return T\n\ndef b_spline_eval(u, p, control_points, T):\n    \"\"\"\n    Evaluates the B-spline curve at a parameter value u using the recursive\n    Cox-de Boor basis function definition with memoization.\n    \n    Args:\n        u (float): The parameter value.\n        p (int): The degree of the B-spline.\n        control_points (np.ndarray): Array of control points.\n        T (np.ndarray): The knot vector.\n        \n    Returns:\n        np.ndarray: The computed point on the curve.\n    \"\"\"\n    n = len(control_points) - 1\n    memo = {}\n\n    def _basis_function(i, deg):\n        \"\"\"\n        Computes the value of the B-spline basis function N_i,deg(u) via\n        a memoized recursion. This is a nested function to capture u, T, n, and memo.\n        \"\"\"\n        if (i, deg) in memo:\n            return memo[(i, deg)]\n\n        if deg == 0:\n            # The curve domain is [t_p, t_{n+1}]. At the right boundary u = t_{n+1},\n            # the convention is that u falls in the last interval [t_n, t_{n+1}],\n            # making N_{n,0}(t_{n+1}) = 1.\n            if u == T[n + 1] and i == n:\n                res = 1.0\n            else:\n                # Standard definition for half-open interval [t_i, t_{i+1}).\n                # This is 0 if t_i == t_{i+1}.\n                res = 1.0 if T[i] = u  T[i + 1] else 0.0\n            memo[(i, deg)] = res\n            return res\n\n        # Recursive step\n        term1 = 0.0\n        den1 = T[i + deg] - T[i]\n        if den1 != 0.0:\n            term1 = ((u - T[i]) / den1) * _basis_function(i, deg - 1)\n\n        term2 = 0.0\n        den2 = T[i + deg + 1] - T[i + 1]\n        if den2 != 0.0:\n            term2 = ((T[i + deg + 1] - u) / den2) * _basis_function(i + 1, deg - 1)\n\n        res = term1 + term2\n        memo[(i, deg)] = res\n        return res\n\n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(n + 1):\n        basis_val = _basis_function(i, p)\n        # Optimization: only add if the basis function is non-zero\n        if basis_val  1e-12: # Check against small tolerance\n            curve_point += basis_val * control_points[i]\n            \n    return curve_point\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and verify endpoint interpolation.\n    \"\"\"\n    test_cases = [\n        # Case 1: 2D quadratic\n        {\n            \"p\": 2,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [2, 0.5], [3, 3], [4, 0]\n            ]),\n            \"knot_vector\": None \n        },\n        # Case 2: 2D cubic, Bezier-like\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 2], [3, 2], [4, 0]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 3: 2D cubic, non-uniform knots\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0], [1, 1], [2, -1], [3, 2], [4, -0.5], [5, 1.5], [6, 0]\n            ]),\n            \"knot_vector\": np.array([0, 0, 0, 0, 0.15, 0.6, 0.85, 1, 1, 1, 1])\n        },\n        # Case 4: 2D linear\n        {\n            \"p\": 1,\n            \"control_points\": np.array([\n                [0, 1], [1, 0], [2, 1.5]\n            ]),\n            \"knot_vector\": None\n        },\n        # Case 5: 3D cubic\n        {\n            \"p\": 3,\n            \"control_points\": np.array([\n                [0, 0, 0], [1, 2, 1], [2, -1, 2], [3, 3, 2], [4, 0, 1], [5, 1, 0]\n            ]),\n            \"knot_vector\": None\n        }\n    ]\n\n    results = []\n    tolerance = 1e-9\n\n    for case in test_cases:\n        p = case[\"p\"]\n        P = case[\"control_points\"]\n        n = len(P) - 1\n\n        if case[\"knot_vector\"] is None:\n            T = build_clamped_uniform_knot_vector(n, p)\n        else:\n            T = case[\"knot_vector\"]\n        \n        # Endpoints of the parametric domain for a clamped knot vector\n        u_left = T[p]\n        u_right = T[n + 1]\n\n        # Evaluate curve at endpoints\n        C_left = b_spline_eval(u_left, p, P, T)\n        C_right = b_spline_eval(u_right, p, P, T)\n\n        # Verify interpolation\n        dist_left = np.linalg.norm(C_left - P[0])\n        dist_right = np.linalg.norm(C_right - P[-1])\n\n        check_left = dist_left = tolerance\n        check_right = dist_right = tolerance\n        \n        results.append(check_left and check_right)\n\n    # Format output as required\n    print(f\"[{','.join(map(str, results))}]\".lower())\n\nsolve()\n```", "id": "3207506"}, {"introduction": "在掌握了B样条的基本求值方法之后，下一步是学习如何控制其形状。本练习探讨了B样条最强大的功能之一：通过节点重复度（knot multiplicity）进行局部形状控制。您将进行一个数值实验，亲眼观察增加节点的重复度如何影响曲线的连续性，从而产生更尖锐的角点或将曲线拉向控制点，使得重复度 $m$ 与光滑度 $C^{p-m}$ 之间的抽象关系变得具体可感。[@problem_id:3099558]", "problem": "您将研究在三次B样条中增加节点重数如何影响局部形状，包括相对于基准曲线可能产生的过冲以及尖角或平坦点的形成。工作将完全在纯数学环境中进行，使用二维控制点和标准的B样条定义。您的程序必须是一个完整、可运行的实现，它从第一性原理出发评估曲线及其导数，并为一个小规模的测试套件计算量化指标。\n\n基本基础和定义：\n- 一个次数为 $p$、控制点为 $\\{\\mathbf{P}_i\\}_{i=0}^{N-1}$、非递减节点向量为 $\\{t_j\\}_{j=0}^{N+p}$ 的B样条曲线定义为\n$$\n\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i,\n$$\n其中 $N_{i,p}(t)$ 是由 Cox–de Boor 递归公式定义的B样条基函数：\n$$\nN_{i,0}(t) =\n\\begin{cases}\n1,  t_i \\le t  t_{i+1},\\\\\n0,  \\text{其它情况},\n\\end{cases}\n$$\n且对于 $p \\ge 1$\n$$\nN_{i,p}(t) = \\frac{t - t_i}{t_{i+p} - t_i} N_{i,p-1}(t) + \\frac{t_{i+p+1} - t}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n约定分母为零的项贡献为 $0$。\n- 曲线的导数使用基函数的导数：\n$$\n\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i,\n$$\n其中\n$$\n\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t),\n$$\n同样，将除以零的情况解释为贡献为 $0$。\n- 对于一个次数为 $p$ 的B样条曲线中重数为 $m$ 的节点，曲线在该节点的连续性为 $C^{p-m}$，意味着前 $p-m$ 阶导数是连续的，而第 $(p-m+1)$ 阶导数通常会有一个跳跃。特别地，如果 $m = p+1$，曲线在该节点处会断开（没有位置连续性）。\n\n场景与建模设置：\n- 使用次数 $p = 3$（三次）和 $\\mathbb{R}^2$ 中的 $N = 8$ 个控制点。\n- 使用两端重复的开放式节点向量：\n$$\n\\underbrace{0,0,0,0}_{p+1\\text{ 次}}, \\text{内部节点}, \\underbrace{1,1,1,1}_{p+1\\text{ 次}}.\n$$\n- 令我们关心的内部节点位置为 $u_0 = 0.5$。内部节点条目的总数为 $N - p - 1 = 4$。对于在 $u_0$ 处选择的重数 $m \\in \\{1,2,3,4\\}$，按如下方式构建内部节点多重集。包含 $m$ 个 $u_0$ 的副本，并从固定列表 $\\{0.25,\\,0.33,\\,0.75\\}$ 中使用剩余的 $4 - m$ 个条目，从该列表中取出最小的 $4-m$ 个元素，然后对所有内部条目进行排序。这为每个 $m$ 值都恰好产生四个内部节点条目。\n- 定义两种控制点场景：\n  - 场景 A (驼峰状)：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 1.0)$,\n    - $\\mathbf{P}_2=(2.0, 2.0)$,\n    - $\\mathbf{P}_3=(3.0, 4.0)$,\n    - $\\mathbf{P}_4=(4.0, 2.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.5)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 1.1)$.\n  - 场景 B (局部平坦区域)：\n    - $\\mathbf{P}_0=(0.0, 0.0)$,\n    - $\\mathbf{P}_1=(1.0, 0.5)$,\n    - $\\mathbf{P}_2=(2.0, 1.0)$,\n    - $\\mathbf{P}_3=(3.0, 1.0)$,\n    - $\\mathbf{P}_4=(4.0, 1.0)$,\n    - $\\mathbf{P}_5=(5.0, 1.0)$,\n    - $\\mathbf{P}_6=(6.0, 1.2)$,\n    - $\\mathbf{P}_7=(7.0, 2.0)$.\n\n需要计算的量：\n- 定义基准曲线为在 $u_0=0.5$ 处重数 $m=1$ 的三次B样条曲线，使用上述内部节点构造方法。将此基准曲线记为 $\\mathbf{C}_{\\mathrm{base}}(t)$。\n- 对于每个场景和每个 $m \\in \\{1,2,3,4\\}$，构建相应的节点向量并计算：\n  1. 在参数值的均匀样本上与基准曲线的最大绝对偏差：\n     $$\n     D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2.\n     $$\n     使用欧几里得范数。令样本 $\\mathcal{T}$ 为开区间 $(0,1)$ 内的 $4001$ 个等距点，例如，$t_k$ 从 $10^{-6}$ 到 $1-10^{-6}$ 线性间隔，以避免恰好在节点处求值。\n  2. 内部节点 $u_0$ 处斜率不连续性的数值度量：\n     $$\n     J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2.\n     $$\n     为了评估单边导数而不恰好碰到节点，选择\n     $$\n     \\delta = \\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right),\n     $$\n     其中 $u_\\text{L}$ 是所构造的节点向量中严格小于 $u_0$ 的最大节点，而 $u_\\text{R}$ 是严格大于 $u_0$ 的最小节点。然后，通过使用上面的基函数导数公式评估 $\\mathbf{C}_m'(u_0 - \\delta)$ 和 $\\mathbf{C}_m'(u_0 + \\delta)$ 来近似单边导数。它们差的欧几里得范数即为 $J(m)$。\n\n测试套件和要求的输出：\n- 使用场景 A 和场景 B 的控制点。\n- 对于每个场景，评估 $m = 1, 2, 3, 4$ 时的序对 $\\left(D_{\\max}(m), J(m)\\right)$。\n- 将报告的每个浮点数结果四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含两个场景的所有结果，形式为方括号内以逗号分隔的列表。顺序必须是：\n  - 场景 A: $D_{\\max}(1)$, $J(1)$, $D_{\\max}(2)$, $J(2)$, $D_{\\max}(3)$, $J(3)$, $D_{\\max}(4)$, $J(4)$,\n  - 随后是按相同顺序排列的场景 B。\n即，输出格式为\n$$\n[\\;D_{\\max}^{A}(1),J^{A}(1),D_{\\max}^{A}(2),J^{A}(2),D_{\\max}^{A}(3),J^{A}(3),D_{\\max}^{A}(4),J^{A}(4),D_{\\max}^{B}(1),J^{B}(1),D_{\\max}^{B}(2),J^{B}(2),D_{\\max}^{B}(3),J^{B}(3),D_{\\max}^{B}(4),J^{B}(4)\\;].\n$$\n不需要单位，因为所有量都是无量纲的。", "solution": "用户提供了一个关于B样条曲线性质的定义明确的计算问题。我将首先验证问题陈述，然后基于基本原理提供一个全面的解决方案。\n\n### 问题验证\n\n1.  **提取已知条件**：\n    - **曲线类型**：次数为 $p=3$、在 $\\mathbb{R}^2$ 中有 $N=8$ 个控制点的B样条曲线。\n    - **曲线定义**：$\\mathbf{C}(t) = \\sum_{i=0}^{N-1} N_{i,p}(t)\\,\\mathbf{P}_i$，基函数 $N_{i,p}(t)$ 由 Cox–de Boor 递归公式定义。\n    - **曲线导数**：$\\mathbf{C}'(t) = \\sum_{i=0}^{N-1} \\frac{d N_{i,p}(t)}{dt}\\,\\mathbf{P}_i$，其中 $\\frac{d N_{i,p}(t)}{dt} = \\frac{p}{t_{i+p} - t_i} N_{i,p-1}(t) - \\frac{p}{t_{i+p+1} - t_{i+1}} N_{i+1,p-1}(t)$。\n    - **节点向量**：开放式节点向量，在 $0$ 处有 $p+1=4$ 个节点，在 $1$ 处有 $4$ 个节点。它包含 $N-p-1=4$ 个内部节点。\n    - **内部节点构造**：对于在 $u_0 = 0.5$ 处重数为 $m \\in \\{1,2,3,4\\}$ 的情况，四个内部节点由 $m$ 个 $0.5$ 的副本和从集合 $\\{0.25, 0.33, 0.75\\}$ 中取出的 $4-m$ 个最小值组成，然后排序。\n    - **控制点场景**：提供了两组控制点，场景A（驼峰状）和场景B（局部平坦区域）。\n    - **度量指标**：\n        1.  $D_{\\max}(m) = \\max_{t \\in \\mathcal{T}} \\left\\lVert \\mathbf{C}_m(t) - \\mathbf{C}_{\\mathrm{base}}(t) \\right\\rVert_2$，其中 $\\mathbf{C}_{\\mathrm{base}}$ 是 $m=1$ 时的曲线。评估网格 $\\mathcal{T}$ 在 $(0,1)$ 中有 $4001$ 个点。\n        2.  $J(m) = \\left\\lVert \\mathbf{C}_m'(u_0^+) - \\mathbf{C}_m'(u_0^-) \\right\\rVert_2$，其中单边导数在 $u_0 \\pm \\delta$ 处近似计算。$\\delta$ 定义为 $\\min\\left(0.1\\,(u_0 - u_\\text{L}),\\, 0.1\\,(u_\\text{R} - u_0),\\, 10^{-3}\\right)$。\n    - **输出格式**：包含一个逗号分隔列表的单行文本，该列表包含16个浮点数值，四舍五入到六位小数，代表两种场景中每个 $m \\in \\{1,2,3,4\\}$ 的 $(D_{\\max}(m), J(m))$。\n\n2.  **依据标准进行验证**：\n    - **科学依据**：该问题植根于B样条曲线的标准数学理论，这是计算科学和计算机辅助几何设计的核心主题。所有定义和公式都是正确的。\n    - **适定性**：问题的规定非常精确。所有参数、数据、构造规则以及待计算量的公式都已明确给出。整个设置是自洽的，足以产生一个唯一的、确定性的解。\n    - **客观性**：问题陈述完全客观，使用了精确的数学语言和量化定义。没有主观或含糊的元素。\n    - **其他标准**：该问题并非微不足道，因为它需要一个从第一性原理出发的、对一个非平凡算法的正确实现。它没有矛盾、不切实际或不适定的地方。\n\n3.  **结论与行动**：\n    问题陈述是**有效的**。我将继续制定并实施一个解决方案。\n\n### 解决方案设计\n\n该解决方案要求根据提供的基本定义实现B样条曲线及其导数的评估。直接递归实现 Cox-de Boor 公式在计算上是低效的。将采用一种更稳健、性能更好的方法，该方法基于标准文献（例如，Piegl 和 Tiller 的《The NURBS Book》）中的算法。这符合“从第一性原理出发”的要求，因为这些算法是数学定义的直接实现。\n\n1.  **核心算法**：\n    - **节点区间搜索**：将实现一个函数 `find_span` 来高效地定位包含给定参数值 $t$ 的节点区间（span）。这是高效评估基函数的前提，通常使用二分搜索实现。\n    - **基函数评估**：将实现一个函数 `basis_funs`，采用迭代的动态规划方法（来自《The NURBS Book》的算法 A2.2）来计算在给定参数 $t$ 的节点区间内，所有非零的给定次数基函数的值。这比朴素的递归方法效率高得多。\n    - **曲线评估**：函数 `evaluate_bspline` 将结合 `find_span` 和 `basis_funs` 来计算曲线上的一点 $\\mathbf{C}(t)$。它找到相关的节点区间，计算非零基函数，然后与相应的控制点进行加权求和。\n    - **曲线导数评估**：函数 `evaluate_bspline_derivative` 将通过直接实现求和 $\\sum_i \\frac{d N_{i,p}(t)}{dt} \\mathbf{P}_i$ 来计算 $\\mathbf{C}'(t)$。基函数的导数 $\\frac{d N_{i,p}(t)}{dt}$ 将使用提供的公式计算，这反过来又需要次数为 $p-1$ 的基函数。这些将使用相同的 `basis_funs` 算法高效计算。\n\n2.  **单个案例（$m$，场景）的工作流程**：\n    - **节点向量构造**：通过连接起始的重复节点（$p+1$ 个零）、四个指定的内部节点和结尾的重复节点（$p+1$ 个一），构造出长度为 $N+p+1=12$ 的完整节点向量。\n    - **为计算 $D_{\\max}$ 进行曲线评估**：对于每个 $m$，在 $(0,1)$ 区间的 $4001$ 个采样点上评估曲线 $\\mathbf{C}_m(t)$。对于 $m=1$，这些点定义了基准曲线 $\\mathbf{C}_{\\mathrm{base}}$。对于 $m1$，计算与相应基准点的欧几里得距离，这些距离的最大值即为 $D_{\\max}(m)$。根据定义，$D_{\\max}(1)=0$。\n    - **为计算 $J(m)$ 进行导数跳跃计算**：根据问题规则确定小偏移量 $\\delta$。在 $u_0 - \\delta$ 和 $u_0 + \\delta$ 处评估导数 $\\mathbf{C}_m'(t)$。这两个导数向量之差的欧几里得范数即为跳跃值 $J(m)$。B样条的连续性性质表明，$J(1)$ 和 $J(2)$ 应接近于零，而 $J(3)$ 和 $J(4)$ 可能显著不为零，这为实现提供了一个很好的健全性检查。\n\n3.  **总体结构**：\n    主程序将遍历两种控制点场景。在每个场景内，它将遍历重数 $m$ 从 $1$ 到 $4$。在每个子案例中，它将构建适当的节点向量，计算序对 $(D_{\\max}(m), J(m))$，并存储结果。最后，所有 16 个标量结果将按要求格式化为单个字符串。", "answer": "```python\nimport numpy as np\n\ndef find_span(num_cp, degree, t, knots):\n    \"\"\"\n    Finds the knot span index for a given parameter t.\n    num_cp: number of control points (N).\n    degree: degree of the curve (p).\n    t: parameter value.\n    knots: knot vector.\n    Returns the index k such that knots[k] = t  knots[k+1].\n    \"\"\"\n    # For t=1.0, which can occur at the end of the domain for an open knot vector.\n    # The valid parameter range is [knots[p], knots[N]]. For an open knot vector,\n    # this is [0, 1]. The last span index is N-1.\n    if t = knots[num_cp]:\n        return num_cp - 1\n    \n    # Binary search for the span. The search space is [p, N-1].\n    low = degree\n    high = num_cp\n    \n    while low  high:\n        mid = (low + high) // 2\n        if t  knots[mid]:\n            high = mid\n        else:\n            low = mid + 1\n    return low - 1\n\ndef basis_funs(span, t, degree, knots):\n    \"\"\"\n    Computes the non-zero B-spline basis functions for a given parameter t.\n    (Algorithm A2.2 from The NURBS Book by Piegl and Tiller).\n    span: knot span index.\n    t: parameter value.\n    degree: degree of the curve.\n    knots: knot vector.\n    Returns an array of p+1 basis function values, N_{span-degree, degree}, ..., N_{span, degree}.\n    \"\"\"\n    basis = np.zeros(degree + 1)\n    left = np.zeros(degree + 1)\n    right = np.zeros(degree + 1)\n    \n    basis[0] = 1.0\n    for j in range(1, degree + 1):\n        left[j] = t - knots[span + 1 - j]\n        right[j] = knots[span + j] - t\n        saved = 0.0\n        for r in range(j):\n            den = knots[span + r + 1] - knots[span + r + 1 - j]\n            if den == 0.0:\n                temp = 0.0\n            else:\n                temp = basis[r] / den\n            basis[r] = saved + right[r + 1] * temp\n            saved = left[j - r] * temp\n        basis[j] = saved\n    return basis\n\ndef evaluate_bspline(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        if t = knots[degree]: return control_points[0]\n        else: return control_points[-1]\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values = basis_funs(span, t, degree, knots)\n    \n    curve_point = np.zeros_like(control_points[0], dtype=float)\n    for i in range(degree + 1):\n        curve_point += basis_values[i] * control_points[span - degree + i]\n    return curve_point\n\ndef evaluate_bspline_derivative(t, num_cp, degree, knots, control_points):\n    \"\"\"\n    Evaluates the derivative of a B-spline curve at a given parameter t.\n    \"\"\"\n    if t  knots[degree] or t  knots[num_cp]:\n        return np.zeros_like(control_points[0], dtype=float)\n\n    span = find_span(num_cp, degree, t, knots)\n    basis_values_p_minus_1 = basis_funs(span, t, degree - 1, knots)\n    \n    deriv_point = np.zeros_like(control_points[0], dtype=float)\n    \n    for i in range(span - degree, span + 1):\n        # Contribution from control point P_i\n        # dN_{i,p}/dt = p/(t_{i+p}-t_i) * N_{i,p-1} - p/(t_{i+p+1}-t_{i+1}) * N_{i+1,p-1}\n        \n        # Term 1: involving N_{i, p-1}\n        num1 = 0.0\n        # The non-zero basis functions of degree p-1 for span k are N_{k-(p-1),p-1} to N_{k,p-1}\n        # In our case, span=span, degree=p-1. So N_{span-(p-1),p-1} to N_{span,p-1}.\n        if (span - (degree - 1)) = i = span:\n            num1 = basis_values_p_minus_1[i - (span - (degree - 1))]\n        \n        den1 = knots[i + degree] - knots[i]\n        term1 = 0.0\n        if den1 != 0.0:\n            term1 = degree * num1 / den1\n\n        # Term 2: involving N_{i+1, p-1}\n        num2 = 0.0\n        if (span - (degree - 1)) = (i + 1) = span:\n            num2 = basis_values_p_minus_1[i + 1 - (span - (degree - 1))]\n\n        den2 = knots[i + degree + 1] - knots[i + 1]\n        term2 = 0.0\n        if den2 != 0.0:\n            term2 = degree * num2 / den2\n        \n        d_basis = term1 - term2\n        deriv_point += d_basis * control_points[i]\n        \n    return deriv_point\n\n\ndef solve():\n    p = 3\n    N = 8\n    u0 = 0.5\n    \n    P_A = np.array([\n        [0.0, 0.0], [1.0, 1.0], [2.0, 2.0], [3.0, 4.0],\n        [4.0, 2.0], [5.0, 1.5], [6.0, 1.2], [7.0, 1.1]\n    ], dtype=float)\n    \n    P_B = np.array([\n        [0.0, 0.0], [1.0, 0.5], [2.0, 1.0], [3.0, 1.0],\n        [4.0, 1.0], [5.0, 1.0], [6.0, 1.2], [7.0, 2.0]\n    ], dtype=float)\n\n    scenarios = [(\"A\", P_A), (\"B\", P_B)]\n    interior_knot_pool = [0.25, 0.33, 0.75]\n    \n    t_samples = np.linspace(1e-6, 1.0 - 1e-6, 4001)\n    \n    all_results = []\n    \n    for _, P in scenarios:\n        C_base_pts = None\n        \n        for m in range(1, 5):\n            # 1. Construct knot vector\n            num_other_knots = 4 - m\n            interior_knots = sorted(interior_knot_pool[:num_other_knots] + [u0] * m)\n            knots = np.concatenate((np.zeros(p + 1, dtype=float), np.array(interior_knots, dtype=float), np.ones(p + 1, dtype=float)))\n\n            # 2. Compute curve points for D_max calculation\n            C_m_pts = np.array([evaluate_bspline(t, N, p, knots, P) for t in t_samples])\n            \n            if m == 1:\n                C_base_pts = C_m_pts\n                D_max = 0.0\n            else:\n                deviations = np.linalg.norm(C_m_pts - C_base_pts, axis=1)\n                D_max = np.max(deviations)\n\n            # 3. Compute slope discontinuity J(m)\n            unique_knots = sorted(list(set(knots)))\n            u_L_idx = np.searchsorted(unique_knots, u0, side='left') - 1\n            u_R_idx = np.searchsorted(unique_knots, u0, side='right')\n            u_L = unique_knots[u_L_idx] if u_L_idx = 0 else knots[0]\n            u_R = unique_knots[u_R_idx] if u_R_idx  len(unique_knots) else knots[-1]\n            \n            term_L = 0.1 * (u0 - u_L) if u_L  u0 else np.inf\n            term_R = 0.1 * (u_R - u0) if u_R  u0 else np.inf\n            delta = min(term_L, term_R, 1e-3)\n            \n            dC_left = evaluate_bspline_derivative(u0 - delta, N, p, knots, P)\n            dC_right = evaluate_bspline_derivative(u0 + delta, N, p, knots, P)\n            J_m = np.linalg.norm(dC_right - dC_left)\n            \n            all_results.extend([D_max, J_m])\n            \n    print(f\"[{','.join(f'{r:.6f}' for r in all_results)}]\")\n\nsolve()\n```", "id": "3099558"}, {"introduction": "最后的这个练习将展示B样条在科学计算中的一个最重要应用：作为函数逼近的基函数。您将需要把一个给定的函数 $L^2$ 投影到一个B样条函数空间上，并进行收敛性研究。这个练习将B样条与数值分析中的基本概念（如有限元方法）联系起来，并验证其可预测且强大的逼近能力。[@problem_id:3099508]", "problem": "您的任务是设计并实现一个数值实验，在计算科学导论的背景下，展示 B 样条的逼近能力。该实验必须通过一个完整的、可运行的程序来定义、执行并报告其结果。该实验的重点是将一个光滑目标函数投影到一个样条空间上，并研究逼近误差在均匀网格加密下的变化规律。\n\n定义域为闭区间 $[0,1]$。目标函数为 $f(x) = \\sin(10 x)$，其中正弦函数的自变量以弧度为单位。样条空间是次数为 $p$、在 $[0,1]$ 上具有开放均匀节点向量的 B 样条空间。节点向量应包含 $M$ 个均匀单元，其中网格尺寸 $h = 1/M$，端点 $0$ 和 $1$ 各重复 $p+1$ 次，内部节点位于均匀剖分点 $x = i h$ 处，其中 $i = 1,2,\\ldots,M-1$。该空间中的基函数数量为 $n = M + p$。\n\n该投影是 $L^2$（平方可积）投影。令 $S_{p,h}$ 表示次数为 $p$、网格尺寸为 $h$ 的样条空间。$f$ 的 $L^2$ 投影 $s \\in S_{p,h}$ 由关于样条基的 Galerkin 正交条件刻画：对于每个基函数 $v \\in S_{p,h}$，残差满足 $\\int_0^1 (f(x) - s(x)) \\, v(x) \\, dx = 0$。您必须使用标准的递归定义（Cox–de Boor 递归）从头开始实现归一化 B 样条基的求值，并组装线性系统，以对 $s$ 的系数强制施加这些正交条件。组装和误差计算中的所有积分都必须在每个子区间上使用足够高阶的高斯求积进行数值计算，以使求积误差相对于样条逼近误差可以忽略不计。在每个单元上使用 Gauss–Legendre 求积，每个单元至少有 $50$ 个求积点。所有计算都必须使用双精度。角度必须以弧度解释，范数和积分不带任何物理单位，因为定义域和函数都是无量纲的。\n\n$L^2$ 误差是差 $f - s$ 的 $L^2$ 范数，定义为 $\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 (f(x) - s(x))^2 \\, dx \\right)^{1/2}$。通过逐单元的高斯求积实现该误差的可靠数值计算。\n\n您必须进行一项收敛性研究，其中 $h$ 被均匀加密，并对每次加密测量误差。对于固定的次数 $p$，考虑对应于 $M \\in \\{8, 16, 32, 64\\}$ 的网格尺寸。对于每个次数 $p \\in \\{0, 1, 2, 3\\}$，计算这些网格尺寸下的 $L^2$ 误差列表，然后通过对 $\\log(\\text{误差})$ 与 $\\log(h)$ 进行线性最小二乘拟合来计算观测收敛率；拟合的斜率即为观测率。对于光滑的 $f$，渐近期望是收敛率约等于 $p+1$。\n\n您的程序必须实现：\n- 为给定的 $p$ 和 $M$ 构建开放均匀节点向量。\n- 通过 Cox–de Boor 递归在给定点集上计算所有次数为 $p$ 的归一化 B 样条基函数的值。\n- 使用数值求积组装 $L^2$ 投影线性系统。\n- 求解线性系统以获得样条系数，并通过求积计算 $L^2$ 误差。\n- 从 $(h, \\text{误差})$ 数据计算观测收敛率。\n\n测试套件规范：\n- 情况 1：$p = 0$，$M \\in \\{8, 16, 32, 64\\}$。\n- 情况 2：$p = 1$，$M \\in \\{8, 16, 32, 64\\}$。\n- 情况 3：$p = 2$，$M \\in \\{8, 16, 32, 64\\}$。\n- 情况 4：$p = 3$，$M \\in \\{8, 16, 32, 64\\}$。\n\n对于每种情况，将观测收敛率报告为一个四舍五入到三位小数的浮点数。这四个值共同构成了最终输出。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按 $p$ 递增排序的四个观测率，格式为方括号括起来的逗号分隔列表，例如 $[r_0,r_1,r_2,r_3]$，其中每个 $r_p$ 是一个四舍五入到三位小数的浮点数。不应打印额外的文本或行。", "solution": "我们从 B 样条和 $L^2$ 投影的基本定义开始。\n\n将 $[0,1]$ 均匀剖分为 $M$ 个单元，网格尺寸为 $h = 1/M$。对于给定的次数 $p \\in \\mathbb{N}_0$，我们考虑开放均匀节点向量。将节点向量表示为 $\\{t_i\\}_{i=0}^{K-1}$，其中端点重复 $p+1$ 次，内部节点位于 $i h$ 处，其中 $i=1,2,\\ldots,M-1$。具体来说，\n$$\nt_0 = t_1 = \\cdots = t_p = 0,\\quad\nt_{p+1} = h,\\quad\nt_{p+2} = 2h,\\quad \\ldots,\\quad t_{p+M-1} = (M-1)h,\\quad\nt_{K-p-1} = t_{K-p} = \\cdots = t_{K-1} = 1,\n$$\n其中 $K = (M-1) + 2(p+1)$，基函数的数量为 $n = K - p - 1 = M + p$。归一化 B 样条基函数 $\\{N_{i,p}(x)\\}_{i=0}^{n-1}$ 由 Cox–de Boor 递归式递归定义。对于分段常数（$p = 0$）的基本情况是半开支撑区间的指示函数：\n$$\nN_{i,0}(x) = \n\\begin{cases}\n1  \\text{if } t_i \\le x  t_{i+1}, \\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n对于 $p \\ge 1$ 的递归定义为\n$$\nN_{i,p}(x) = \\alpha_{i,p}(x)\\, N_{i,p-1}(x) + \\beta_{i,p}(x)\\, N_{i+1,p-1}(x),\n$$\n其中混合系数为\n$$\n\\alpha_{i,p}(x) = \n\\begin{cases}\n\\dfrac{x - t_i}{t_{i+p} - t_i}  \\text{if } t_{i+p}  t_i,\\\\\n0  \\text{otherwise},\n\\end{cases}\n\\qquad\n\\beta_{i,p}(x) =\n\\begin{cases}\n\\dfrac{t_{i+p+1} - x}{t_{i+p+1} - t_{i+1}}  \\text{if } t_{i+p+1}  t_{i+1},\\\\\n0  \\text{otherwise}.\n\\end{cases}\n$$\n这些定义意味着基函数是非负的，在 $[t_i, t_{i+p+1}]$ 上具有最小局部支撑，并在 $[0,1]$ 上构成单位分解。\n\n令 $S_{p,h} = \\operatorname{span}\\{N_{i,p}\\}_{i=0}^{n-1}$ 为样条空间。给定函数 $f$ 的 $L^2$ 投影 $s \\in S_{p,h}$ 由 Galerkin 正交性定义：\n$$\n\\int_0^1 \\left( f(x) - s(x) \\right) v(x) \\, dx = 0 \\quad \\text{for all } v \\in S_{p,h}.\n$$\n记 $s(x) = \\sum_{i=0}^{n-1} c_i\\, N_{i,p}(x)$ 并选择测试函数 $v = N_{j,p}$（$j = 0,1,\\ldots,n-1$），我们得到线性系统\n$$\n\\sum_{i=0}^{n-1} c_i \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\\quad j=0,\\ldots,n-1.\n$$\n定义质量矩阵 $M \\in \\mathbb{R}^{n \\times n}$ 和右端项 $b \\in \\mathbb{R}^n$ 为\n$$\nM_{j,i} = \\int_0^1 N_{i,p}(x) N_{j,p}(x) \\, dx,\\qquad\nb_j = \\int_0^1 f(x) N_{j,p}(x) \\, dx,\n$$\n系数 $c = (c_0,\\ldots,c_{n-1})^\\top$ 满足\n$$\nM c = b.\n$$\n于是 $L^2$ 逼近误差为\n$$\n\\| f - s \\|_{L^2(0,1)} = \\left( \\int_0^1 \\left( f(x) - \\sum_{i=0}^{n-1} c_i N_{i,p}(x) \\right)^2 \\, dx \\right)^{1/2}.\n$$\n\n数值积分通过在每个单元上使用 $q$ 阶 Gauss–Legendre 求积来执行。设 $[-1,1]$ 上的参考 Gauss–Legendre 点和权为 $\\{\\xi_k, w_k\\}_{k=1}^q$。对于单元区间 $[a,b]$，仿射映射 $x = \\frac{b-a}{2} \\xi + \\frac{a+b}{2}$ 产生物理求积点 $\\{x_k\\}$ 和权 $\\{ \\hat{w}_k = \\frac{b-a}{2} w_k \\}$。对所有单元求和，$[0,1]$ 上的积分近似为\n$$\n\\int_0^1 g(x)\\, dx \\approx \\sum_{e=1}^{M} \\sum_{k=1}^q \\hat{w}_{e,k}\\, g(x_{e,k}).\n$$\n在我们的设置中，我们取 $q \\ge 50$ 以确保求积误差可以忽略；这一选择可以可靠地处理质量矩阵中的多项式乘积和右端项中的振荡项 $\\sin(10 x)$。\n\n算法步骤如下：\n1. 对于给定的 $p$ 和 $M$，构建开放均匀节点向量 $\\{t_i\\}$ 并计算基函数数量 $n$。\n2. 通过遍历单元并将 $q$ 点 Gauss–Legendre 法则映射到每个单元来创建全局求积点和权。\n3. 使用 Cox–de Boor 递归在所有求积点上计算所有基函数 $\\{N_{i,p}\\}_{i=0}^{n-1}$ 的值。将计算结果组织成一个矩阵 $B \\in \\mathbb{R}^{n \\times N_q}$，其中 $N_q = M \\cdot q$ 是总求积点数。\n4. 使用加权内积组装质量矩阵，\n$$\nM = B \\, \\operatorname{diag}(w) \\, B^\\top,\n$$\n其中 $w \\in \\mathbb{R}^{N_q}$ 是全局求积权重。\n5. 通过 $b = B \\left( w \\odot f(x) \\right)$ 组装右端项，其中 $f(x) = \\sin(10 x)$ 在求积点处求值，$\\odot$ 表示逐点乘法。\n6. 以双精度求解线性系统 $M c = b$ 以获得系数 $c$。\n7. 通过 $s(x) = \\sum_i c_i N_{i,p}(x)$ 计算样条逼近在求积点处的值，其向量化形式为 $s = B^\\top c$。\n8. 通过\n$$\n\\| f - s \\|_{L^2(0,1)} \\approx \\left( \\sum_{k=1}^{N_q} w_k \\left( f(x_k) - s(x_k) \\right)^2 \\right)^{1/2}.\n$$\n计算 $L^2$ 误差。\n9. 对于每个次数 $p \\in \\{0,1,2,3\\}$ 和网格尺寸 $M \\in \\{8,16,32,64\\}$，计算误差，然后对 $\\log(\\text{误差})$ 与 $\\log(h)$ 进行最小二乘拟合以估计斜率 $r_p$。具体来说，如果我们记 $X = \\log(h)$ 和 $Y = \\log(\\text{误差})$，则拟合斜率为\n$$\nr_p = \\frac{\\sum_i (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_i (X_i - \\bar{X})^2},\n$$\n其中求和遍历所有加密级别，横线表示平均值。在实践中，这通过一次多项式拟合获得。\n\n根据样条空间的逼近理论，对于足够光滑的 $f$ 和均匀加密， $L^2$ 投影误差满足\n$$\n\\| f - s \\|_{L^2(0,1)} \\le C\\, h^{p+1} \\, |f|_{H^{p+1}(0,1)},\n$$\n其中 $C$ 是某个与 $h$ 无关的常数，这意味着观测到的收敛率接近 $p+1$。测试套件包括 $p=0$（分段常数）作为一个重要的边缘情况，以及逐渐增高到 $p=3$ 的次数，其网格范围从相对较粗的网格（$M=8$）到较细的网格（$M=64$），通过开放节点构造覆盖了理想路径和端点处的边界条件。\n\n程序输出四个观测到的收敛率，四舍五入到三位小数，格式为按 $p$ 递增排序、用方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef open_uniform_knots(M: int, p: int) - np.ndarray:\n    \"\"\"\n    Construct open uniform knot vector on [0,1] with M elements and degree p.\n    Endpoints are repeated p+1 times. Interior knots are at i/M for i=1..M-1.\n    \"\"\"\n    interior = np.linspace(0.0, 1.0, M + 1)\n    # Exclude endpoints from interior\n    interior = interior[1:-1]\n    # Build knot vector\n    knots = np.concatenate([\n        np.zeros(p + 1),\n        interior,\n        np.ones(p + 1)\n    ])\n    return knots\n\ndef bspline_basis_matrix(knots: np.ndarray, p: int, x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Evaluate all normalized B-spline basis functions of degree p defined by 'knots'\n    at points x using Cox-de Boor recursion. Returns shape (n_basis, len(x)).\n    \"\"\"\n    K = len(knots)\n    n_basis = K - p - 1\n    N = np.zeros((n_basis, x.size), dtype=np.float64)\n\n    # Base case p=0: indicator of half-open intervals [t_i, t_{i+1})\n    # Gauss-Legendre points lie inside elements, so endpoint handling is minimal.\n    for i in range(n_basis):\n        left = knots[i]\n        right = knots[i + 1]\n        # Indicator: include left, exclude right\n        mask = (x = left)  (x  right)\n        N[i, mask] = 1.0\n    # Handle the very end point x == 1 (if present) to ensure partition of unity\n    # Assign to the last basis.\n    if np.any(np.isclose(x, knots[-1])):\n        N[-1, np.isclose(x, knots[-1])] = 1.0\n\n    # Recursion for p=1\n    for d in range(1, p + 1):\n        N_next = np.zeros_like(N)\n        for i in range(n_basis):\n            # First term\n            denom1 = knots[i + d] - knots[i]\n            if denom1  0.0:\n                coeff1 = (x - knots[i]) / denom1\n                N_next[i, :] += coeff1 * N[i, :]\n            # Second term (uses N_{i+1, d-1})\n            if i + 1  n_basis:\n                denom2 = knots[i + d + 1] - knots[i + 1]\n                if denom2  0.0:\n                    coeff2 = (knots[i + d + 1] - x) / denom2\n                    N_next[i, :] += coeff2 * N[i + 1, :]\n        N = N_next\n\n    return N\n\ndef element_quadrature_points_weights(M: int, q: int) - tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Build global quadrature points and weights by mapping q-point Gauss-Legendre\n    rule to each of the M uniform elements on [0,1].\n    \"\"\"\n    # Gauss-Legendre on [-1,1]\n    xi, w = np.polynomial.legendre.leggauss(q)\n    points = []\n    weights = []\n    h = 1.0 / M\n    for e in range(M):\n        a = e * h\n        b = (e + 1) * h\n        # Affine map: x = 0.5*(b-a)*xi + 0.5*(b+a)\n        x_e = 0.5 * (b - a) * xi + 0.5 * (b + a)\n        w_e = 0.5 * (b - a) * w\n        points.append(x_e)\n        weights.append(w_e)\n    x_all = np.concatenate(points)\n    w_all = np.concatenate(weights)\n    return x_all, w_all\n\ndef l2_projection_error(p: int, M: int, q: int = 50) - float:\n    \"\"\"\n    Compute L2 projection of f(x)=sin(10x) onto spline space of degree p with M elements,\n    and return the L2 error norm via high-order Gaussian quadrature.\n    \"\"\"\n    # Build knots and basis dimension\n    knots = open_uniform_knots(M, p)\n    # Global quadrature\n    xq, wq = element_quadrature_points_weights(M, q)\n    # Evaluate basis matrix\n    B = bspline_basis_matrix(knots, p, xq)  # shape (n_basis, Nq)\n    # Assemble mass matrix M = B * diag(wq) * B^T\n    BW = B * wq[np.newaxis, :]\n    Mmat = BW @ B.T\n    # Assemble RHS b = B * (wq * f(xq))\n    fx = np.sin(10.0 * xq)  # radians\n    b = B @ (wq * fx)\n    # Solve for coefficients\n    c = np.linalg.solve(Mmat, b)\n    # Approximation values at quadrature points\n    sx = B.T @ c\n    # L2 error\n    err = np.sqrt(np.sum(wq * (fx - sx) ** 2))\n    return float(err)\n\ndef convergence_rate(p: int, Ms: list[int], q: int = 50) - float:\n    \"\"\"\n    Compute observed convergence rate via least-squares fit of log(error) vs log(h).\n    \"\"\"\n    hs = np.array([1.0 / M for M in Ms], dtype=np.float64)\n    errs = np.array([l2_projection_error(p, M, q=q) for M in Ms], dtype=np.float64)\n    X = np.log(hs)\n    Y = np.log(errs)\n    # Least squares slope\n    slope = np.polyfit(X, Y, 1)[0]\n    return float(slope)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_degrees = [0, 1, 2, 3]\n    Ms = [8, 16, 32, 64]\n    q = 50  # quadrature points per element\n\n    results = []\n    for p in test_degrees:\n        rate = convergence_rate(p, Ms, q=q)\n        results.append(f\"{rate:.3f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3099508"}]}