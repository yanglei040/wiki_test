{"hands_on_practices": [{"introduction": "要真正掌握一个数学工具，我们首先需要深入理解其基本属性。这个练习将范德蒙矩阵、多项式插值和克莱姆法则巧妙地联系在一起，通过一个精心设计的思想实验，我们不仅可以练习行列式的计算，还能体会到唯一插值多项式这一基本原理的强大之处。这是一个锻炼代数技巧和概念理解的绝佳机会。[@problem_id:968114]", "problem": "考虑对函数 $ f(x) = x^4 $ 在不同的节点 $ x_0 = 0 $, $ x_1 = a $, $ x_2 = 2a $, $ x_3 = 3a $, $ x_4 = 4a $（其中 $ a $ 为非零实数）上进行插值。插值系统使用一个大小为 $ 5 \\times 5 $ 的范德蒙矩阵 $ V $。根据克莱姆法则，插值多项式中 $ x^4 $ 的系数由行列式的比值给出。利用插值多项式恰好为 $ x^4 $ 这一事实，确定 $ V $ 的行列式。", "solution": "对于节点 $ [x_0, x_1, x_2, x_3, x_4] $ 的范德蒙矩阵 $ V $ 是：\n$$\nV = \\begin{bmatrix}\n1  x_0  x_0^2  x_0^3  x_0^4 \\\\\n1  x_1  x_1^2  x_1^3  x_1^4 \\\\\n1  x_2  x_2^2  x_2^3  x_2^4 \\\\\n1  x_3  x_3^2  x_3^3  x_3^4 \\\\\n1  x_4  x_4^2  x_4^3  x_4^4\n\\end{bmatrix} = \\begin{bmatrix}\n1  0  0  0  0 \\\\\n1  a  a^2  a^3  a^4 \\\\\n1  2a  4a^2  8a^3  16a^4 \\\\\n1  3a  9a^2  27a^3  81a^4 \\\\\n1  4a  16a^2  64a^3  256a^4\n\\end{bmatrix}.\n$$\n函数值向量为 $ \\mathbf{y} = [f(x_0), f(x_1), f(x_2), f(x_3), f(x_4)]^\\top = [0, a^4, 16a^4, 81a^4, 256a^4]^\\top $。根据克莱姆法则，$ x^4 $ 的系数 $ c_4 $ 为：\n$$\nc_4 = \\frac{\\det(V_4)}{\\det(V)},\n$$\n其中 $ V_4 $ 是将 $ V $ 的第五列替换为 $ \\mathbf{y} $ 得到的矩阵。\n我们来计算 $\\det(V_4)$：\n$$\nV_4 = \\begin{bmatrix}\n1  0  0  0  0 \\\\\n1  a  a^2  a^3  a^4 \\\\\n1  2a  4a^2  8a^3  16a^4 \\\\\n1  3a  9a^2  27a^3  81a^4 \\\\\n1  4a  16a^2  64a^3  256a^4\n\\end{bmatrix}.\n$$\n沿第一行展开 $ \\det(V_4) $。第一行中唯一的非零项是第一个元素 (1)，因此：\n$$\n\\det(V_4) = 1 \\cdot (-1)^{1+1} \\det(M_{11}) = \\det \\begin{bmatrix}\na  a^2  a^3  a^4 \\\\\n2a  4a^2  8a^3  16a^4 \\\\\n3a  9a^2  27a^3  81a^4 \\\\\n4a  16a^2  64a^3  256a^4\n\\end{bmatrix}.\n$$\n从第一列提出因子 $ a $，第二列提出 $ a^2 $，第三列提出 $ a^3 $，第四列提出 $ a^4 $：\n$$\n= a \\cdot a^2 \\cdot a^3 \\cdot a^4 \\cdot \\det \\begin{bmatrix}\n1  1  1  1 \\\\\n2  4  8  16 \\\\\n3  9  27  81 \\\\\n4  16  64  256\n\\end{bmatrix} = a^{10} \\det(W), \\quad W = \\begin{bmatrix}\n1  1  1  1 \\\\\n2  4  8  16 \\\\\n3  9  27  81 \\\\\n4  16  64  256\n\\end{bmatrix}.\n$$\n从 $ W $ 的每一行提出常数因子：\n- 第一行：提出因子 1 → $ 1 \\cdot [1, 1, 1, 1] $\n- 第二行：提出因子 2 → $ 2 \\cdot [1, 2, 4, 8] $\n- 第三行：提出因子 3 → $ 3 \\cdot [1, 3, 9, 27] $\n- 第四行：提出因子 4 → $ 4 \\cdot [1, 4, 16, 64] $\n因此：\n$$\n\\det(W) = (1 \\cdot 2 \\cdot 3 \\cdot 4) \\det \\begin{bmatrix}\n1  1  1  1 \\\\\n1  2  4  8 \\\\\n1  3  9  27 \\\\\n1  4  16  64\n\\end{bmatrix} = 24 \\det(V_{\\text{std}}),\n$$\n其中 $ V_{\\text{std}} $ 是节点 $ [1, 2, 3, 4] $ 对应的范德蒙矩阵（幂次从0到3）。其行列式为：\n$$\n\\det(V_{\\text{std}}) = \\prod_{1 \\leq i  j \\leq 4} (j - i) = (2-1)(3-1)(4-1)(3-2)(4-2)(4-3) = 1 \\cdot 2 \\cdot 3 \\cdot 1 \\cdot 2 \\cdot 1 = 12.\n$$\n所以 $ \\det(W) = 24 \\cdot 12 = 288 $，且 $ \\det(V_4) = a^{10} \\cdot 288 $。由于函数值 $y_i = x_i^4$，替换 $V$ 的第五列（即 $x_i^4$ 列）以形成 $V_4$ 不会改变矩阵，因此 $V_4=V$。所以，我们直接得到了 $\\det(V) = \\det(V_4) = 288 a^{10}$。", "answer": "$$ \\boxed{288 a^{10}} $$", "id": "968114"}, {"introduction": "理论必须与实践相结合。在这个动手编程练习中，我们将使用范德蒙矩阵来解决一个多项式插值问题，并揭示一个在信号处理中至关重要的现象：混叠（aliasing）。你将亲眼看到，即使插值多项式完美地穿过了所有采样点，它也可能完全误解了原始高频信号的真实行为，这个练习强调了采样率的重要性。[@problem_id:3285621]", "problem": "您将编写一个完整的程序，该程序使用范德蒙系统进行多项式插值，以演示正弦信号的混叠现象。您必须从采样和多项式插值的基本定义出发，并量化当采样过慢时，所得到的插值函数如何无法消除高频信号混叠到低频的歧义。\n\n基本基础：\n- 以速率 $f_s$ 进行均匀采样意味着采样时间为 $t_n = n/f_s$，其中 $n$ 为整数。对于任何实数频率 $f$，离散时间复指数 $e^{i 2\\pi f t_n}$ 在 $f$ 上是周期性的，周期为 $f_s$，因此对于任何整数 $k$，$e^{i 2\\pi f t_n} = e^{i 2\\pi (f + k f_s) t_n}$。由于 $\\sin(\\cdot)$ 和 $\\cos(\\cdot)$ 是此类指数的虚部和实部，离散时间正弦波在混叠下是无法区分的。一个常见的基带混叠映射是 $f \\mapsto f_{\\text{alias}} \\in [0, f_s/2]$，它通过离散时间频率的周期性将 $f$ 折叠到主区间内来定义。这概括了 Shannon–Nyquist 采样定理，即如果 $f \\geq f_s/2$，则无法从均匀样本中唯一重建连续时间正弦波。\n- 对于多项式插值，给定不同的节点 $x_0,\\dots,x_{N-1}$ 和值 $y_0,\\dots,y_{N-1}$，存在一个唯一的次数最多为 $N-1$ 的多项式 $p(x)$，使得对所有 $n$ 都有 $p(x_n)=y_n$。写作 $p(x)=\\sum_{k=0}^{N-1} c_k x^k$，系数 $c_k$ 是范德蒙线性系统 $V c = y$ 的解，其中 $V_{n,k} = x_n^k$。\n\n任务：\n- 对于每个测试用例，考虑一个连续时间信号 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$，在时间 $t_n = n/f_s$（$n=0,1,\\dots,N-1$）进行采样。通过求解以节点 $t_n$ 和数据 $y_n = s(t_n)$ 构成的范德蒙系统，构建次数为 $(N-1)$ 的插值多项式 $p(t)$。\n- 根据上述离散时间频率的周期性，通过折叠 $f_{\\text{high}}$ 计算基带混叠频率 $f_{\\text{alias}} \\in [0, f_s/2]$。\n- 使用线性最小二乘模型 $y_n \\approx A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$ 对采样数据 $y_n$ 进行频率为 $f_{\\text{alias}}$ 的正弦波拟合，以确定使残差平方和最小的系数 $A$ 和 $B$。这体现了任何频率的采样正弦波（在混叠下）都可以表示为其基带混叠的同相和正交正弦波的线性组合。\n- 在样本所跨越的区间上，在一个由 $M$ 个点组成的密集网格上，评估：\n  1. 真实的连续信号 $s(t)$。\n  2. 拟合的混叠正弦波 $\\tilde{s}_{\\text{alias}}(t) = A \\sin(2\\pi f_{\\text{alias}} t) + B \\cos(2\\pi f_{\\text{alias}} t)$。\n  3. 来自范德蒙系统的插值多项式 $p(t)$。\n\n对于每个测试用例，计算并报告以下可量化的指标：\n- $E_1$：在采样时间点，测量样本与拟合的混叠正弦波之间的最大绝对失配，$E_1 = \\max_n \\left| y_n - \\left(A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)\\right) \\right|$。\n- $E_2$：在采样时间点的最大绝对插值误差，$E_2 = \\max_n | y_n - p(t_n) |$。\n- $\\kappa(V)$：在 $\\{t_n\\}$ 上构建的范德蒙矩阵 $V$ 的 $2$-范数条件数。\n- $E_3$：在密集网格上，真实连续信号与拟合的混叠正弦波之间的均方根差，$E_3 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( s(t_m) - \\tilde{s}_{\\text{alias}}(t_m) \\right)^2 }$。\n- $E_4$：在密集网格上，插值多项式与真实连续信号之间的均方根差，$E_4 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( p(t_m) - s(t_m) \\right)^2 }$。\n\n测试套件：\n提供三个测试用例以探测不同情况：\n- 用例 1（混叠）：$f_s = 10.0$ 赫兹, $N = 8$, $f_{\\text{high}} = 9.0$ 赫兹。这里 $f_{\\text{high}} > f_s/2$，因此采样不足，应混叠到一个低频正弦波。\n- 用例 2（充分采样）：$f_s = 50.0$ 赫兹, $N = 12$, $f_{\\text{high}} = 9.0$ 赫兹。这里 $f_{\\text{high}}  f_s/2$，因此拟合的混叠频率应与真实频率一致。\n- 用例 3（Nyquist 边界）：$f_s = 20.0$ 赫兹, $N = 11$, $f_{\\text{high}} = 10.0$ 赫兹。这是 Nyquist 极限 $f_{\\text{high}} = f_s/2$，其中在 $t_n = n/f_s$ 处采样的纯正弦波对所有整数 $n$ 都产生 $y_n = \\sin(\\pi n) = 0$，突显了极端的模糊性。\n\n实现细节：\n- 时间单位统一使用秒，频率单位统一使用赫兹。\n- 使用 $x_n = t_n$ 和单项式基 $\\{1, x, x^2, \\dots, x^{N-1}\\}$ 构建范德蒙系统；求解 $V c = y$ 以获得 $c$。\n- 使用一个从最小采样时间到最大采样时间的、包含 $M = 1001$ 个点的密集均匀网格。\n- 将所有浮点输出保留到 $10$ 位小数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含所有测试用例的结果列表。每个测试用例必须贡献一个包含五个浮点数的列表，顺序为 $[E_1, E_2, \\kappa(V), E_3, E_4]$，并保留到 $10$ 位小数。总输出必须是这些单用例列表的列表，打印为单行，不含额外文本。例如，打印的结构应如下所示：\n[[e11,e12,e13,e14,e15],[e21,e22,e23,e24,e25],[e31,e32,e33,e34,e35]]", "solution": "用户提供的问题陈述已经过分析和验证。\n\n### 步骤 1：提取已知条件\n- **信号**：连续时间信号为 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$。\n- **采样**：以均匀速率 $f_s$ 在时间 $t_n = n/f_s$（$n=0, 1, \\dots, N-1$）进行采样。采样值为 $y_n = s(t_n)$。\n- **混叠频率**：基带混叠频率 $f_{\\text{alias}}$ 在范围 $[0, f_s/2]$ 内，通过基于离散时间信号的周期性（即对于任何整数 $k$，$e^{i 2\\pi f t_n} = e^{i 2\\pi (f + k f_s) t_n}$）折叠高频 $f_{\\text{high}}$ 来确定。\n- **多项式插值**：找到一个唯一的、次数最多为 $N-1$ 的多项式 $p(t)$，使得 $p(t_n) = y_n$。$p(t)=\\sum_{k=0}^{N-1} c_k t^k$ 的系数 $c_k$ 通过求解范德蒙系统 $V c = y$ 得到，其中矩阵 $V$ 的元素为 $V_{n,k} = t_n^k$。\n- **混叠正弦波拟合**：确定系数 $A$ 和 $B$ 以最小化模型 $y_n \\approx A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$ 的残差平方和。最终拟合的正弦波为 $\\tilde{s}_{\\text{alias}}(t) = A \\sin(2\\pi f_{\\text{alias}} t) + B \\cos(2\\pi f_{\\text{alias}} t)$。\n- **密集网格**：使用一个包含 $M = 1001$ 个均匀间隔点的评估网格，该网格跨越从 $t_0$ 到 $t_{N-1}$ 的区间。\n- **指标**：\n    1.  在采样点上，混叠拟合的最大误差：$E_1 = \\max_n \\left| y_n - \\tilde{s}_{\\text{alias}}(t_n) \\right|$。\n    2.  在采样点上，多项式插值的最大误差：$E_2 = \\max_n | y_n - p(t_n) |$。\n    3.  范德蒙矩阵的条件数：$\\kappa(V)$，使用 2-范数。\n    4.  在密集网格上，真实信号与混叠拟合之间的均方根误差：$E_3 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( s(t_m) - \\tilde{s}_{\\text{alias}}(t_m) \\right)^2 }$。\n    5.  在密集网格上，真实信号与多项式插值函数之间的均方根误差：$E_4 = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} \\left( p(t_m) - s(t_m) \\right)^2 }$。\n- **测试用例**：\n    - 用例 1：$f_s = 10.0$ Hz, $N = 8$, $f_{\\text{high}} = 9.0$ Hz。\n    - 用例 2：$f_s = 50.0$ Hz, $N = 12$, $f_{\\text{high}} = 9.0$ Hz。\n    - 用例 3：$f_s = 20.0$ Hz, $N = 11$, $f_{\\text{high}} = 10.0$ Hz。\n- **取整**：所有最终的浮点指标必须保留到 $10$ 位小数。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据验证标准对问题进行评估。\n- **科学上成立（关键）**：该问题在根本上是合理的。它建立在数字信号处理（Shannon-Nyquist 采样定理、混叠）和数值分析（通过范德蒙系统进行多项式插值、线性最小二乘法）的核心原则之上。所有概念都是标准的且事实正确。\n- **适定性**：该问题是适定的。对于不同的采样时间 $t_n$，范德蒙矩阵 $V$ 是非奇异的，保证了唯一的插值多项式存在。用于混叠正弦波拟合的线性最小二乘问题也是明确定义的，即使在其中一个基函数在采样点上恒为零的特殊边界情况（用例 3）下也是如此。计算过程明确规定，并能得出一组唯一的指标。\n- **客观性（关键）**：该问题以精确、量化和无偏见的语言陈述。所有任务都是基于所提供数据的确定性计算。\n- **其他缺陷**：该问题是自包含、一致且计算可行的。它没有表现出验证清单中列出的任何缺陷，例如非形式化、不完整、不切实际、病态或过于简单。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供完整解决方案。\n\n### 基于原则的设计\n解决方案将通过为每个测试用例实现一个计算过程来构建，遵循数字信号处理和数值线性代数的原则。\n\n#### 1. 采样与混叠\n对于每个具有参数 $f_s$、$N$ 和 $f_{\\text{high}}$ 的测试用例，我们首先建立信号的离散表示。\n- 在区间 $[0, (N-1)/f_s]$ 上生成采样时间 $t_n = n/f_s$，其中 $n \\in \\{0, 1, \\dots, N-1\\}$。\n- 连续信号为 $s(t) = \\sin(2\\pi f_{\\text{high}} t)$。样本计算为 $y_n = s(t_n)$。\n- 必须确定混叠频率 $f_{\\text{alias}}$。对于一个连续频率 $f$，其离散时间混叠等效频率是周期性的，周期为 $f_s$。我们找到唯一的频率 $f' \\in [-f_s/2, f_s/2]$，使得 $f \\equiv f' \\pmod{f_s}$。基带混叠频率则为 $f_{\\text{alias}} = |f'|$。这个映射可以系统地计算为 $f_{\\text{alias}} = | \\text{mod}(f_{\\text{high}} + f_s/2, f_s) - f_s/2 |$，其中 $\\text{mod}$ 是浮点余数运算。\n\n#### 2. 使用范德蒙系统的多项式插值\n目标是找到唯一的、次数最多为 $N-1$ 的多项式 $p(t) = \\sum_{k=0}^{N-1} c_k t^k$，该多项式穿过 $N$ 个采样点 $(t_n, y_n)$。这个条件 $p(t_n) = y_n$ 对所有 $n$ 成立，为 $N$ 个未知系数 $c_k$ 生成了一个包含 $N$ 个线性方程的系统：\n$$\n\\begin{pmatrix}\nt_0^0  t_0^1  \\dots  t_0^{N-1} \\\\\nt_1^0  t_1^1  \\dots  t_1^{N-1} \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\nt_{N-1}^0  t_{N-1}^1  \\dots  t_{N-1}^{N-1}\n\\end{pmatrix}\n\\begin{pmatrix}\nc_0 \\\\ c_1 \\\\ \\vdots \\\\ c_{N-1}\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{N-1}\n\\end{pmatrix}\n$$\n这就是范德蒙系统 $V c = y$。我们将：\n- 构建范德蒙矩阵 $V$，其中 $V_{n,k} = t_n^k$。\n- 使用标准线性求解器求解该系统以获得系数向量 $c$。\n- 计算 2-范数条件数 $\\kappa(V)$，以评估这个历来被认为是病态的范德蒙矩阵的数值稳定性。\n\n#### 3. 通过最小二乘法进行混叠正弦波拟合\n已知样本 $y_n$ 与频率为 $f_{\\text{alias}}$ 的正弦波的样本无法区分。我们将此关系建模为 $y_n \\approx \\tilde{s}_{\\text{alias}}(t_n) = A \\sin(2\\pi f_{\\text{alias}} t_n) + B \\cos(2\\pi f_{\\text{alias}} t_n)$。我们找到使平方误差和 $\\sum_{n=0}^{N-1} (y_n - \\tilde{s}_{\\text{alias}}(t_n))^2$ 最小化的系数 $A$ 和 $B$。这是一个形式为 $M x \\approx y$ 的线性最小二乘问题，其中：\n$$\nM = \\begin{pmatrix}\n\\sin(2\\pi f_{\\text{alias}} t_0)  \\cos(2\\pi f_{\\text{alias}} t_0) \\\\\n\\sin(2\\pi f_{\\text{alias}} t_1)  \\cos(2\\pi f_{\\text{alias}} t_1) \\\\\n\\vdots  \\vdots \\\\\n\\sin(2\\pi f_{\\text{alias}} t_{N-1})  \\cos(2\\pi f_{\\text{alias}} t_{N-1})\n\\end{pmatrix}, \\quad\nx = \\begin{pmatrix} A \\\\ B \\end{pmatrix}, \\quad\ny = \\begin{pmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_{N-1} \\end{pmatrix}\n$$\n解 $x$ 通过求解正规方程组 $(M^T M) x = M^T y$ 得到。\n\n#### 4. 误差量化\n最后，我们计算五个指定的指标，以量化混叠的影响以及插值函数的行为。\n- $E_1$：衡量样本 $y_n$ 与混叠频率下的正弦波的匹配程度。对于真正的混叠，它们应该是相同的，因此 $E_1$ 应接近机器精度。\n- $E_2$：衡量在采样节点处多项式插值的准确性。根据插值的定义，这个误差应该接近机器精度，可作为 $Vc=y$ 数值解的合理性检查。\n- $\\kappa(V)$：表征范德蒙矩阵的病态性。这个值通常很大，表明 $y_n$ 中的小误差可能导致系数 $c_k$ 的大误差。\n- $E_3$：衡量在连续区间上，真实高频信号与其低频混叠表示之间的均方根差。值越大表明尽管它们在采样点上匹配，但它们是不同的函数。\n- $E_4$：衡量真实信号与插值多项式之间的均方根差。这揭示了被迫匹配样本的多项式在样本点之间对底层连续函数的逼近程度。在混叠的情况下，预计此误差会很大，因为多项式倾向于跟随低频混叠而不是真实的高频信号。\n\n该过程将应用于三个测试用例中的每一个，这些用例旨在探测混叠现象（$f_{\\text{high}} > f_s/2$）、充分采样（$f_{\\text{high}}  f_s/2$）以及临界 Nyquist 边界情况（$f_{\\text{high}} = f_s/2$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef process_case(fs, N, f_high):\n    \"\"\"\n    Performs the full analysis for a single test case of signal aliasing.\n    \n    Args:\n        fs (float): Sampling frequency in Hertz.\n        N (int): Number of samples.\n        f_high (float): Frequency of the continuous-time signal in Hertz.\n        \n    Returns:\n        list: A list of five metrics [E1, E2, kappa_V, E3, E4], rounded.\n    \"\"\"\n    M = 1001 # Number of points for the dense grid\n\n    # 1. Sampling and Signal Generation\n    t_n = np.arange(N) / fs\n    y_n = np.sin(2 * np.pi * f_high * t_n)\n\n    # 2. Polynomial Interpolation via Vandermonde System\n    # The problem defines V_nk = t_n^k, which corresponds to increasing=True.\n    V = np.vander(t_n, N, increasing=True)\n    \n    # Solve Vc = y_n for polynomial coefficients c\n    # These coefficients are for the basis {1, t, t^2, ...}\n    try:\n        c = np.linalg.solve(V, y_n)\n    except np.linalg.LinAlgError:\n        # This should not happen for distinct t_n, but as a safeguard\n        return [np.nan] * 5\n\n    # Compute condition number of V\n    kappa_V = np.linalg.cond(V)\n\n    # 3. Alias Sinusoid Fitting\n    # Calculate alias frequency in the baseband [0, fs/2]\n    f_prime = np.mod(f_high + fs / 2.0, fs) - fs / 2.0\n    f_alias = np.abs(f_prime)\n    \n    # Set up and solve the linear least squares problem:\n    # y_n approx A*sin(...) + B*cos(...)\n    A_matrix = np.column_stack([\n        np.sin(2 * np.pi * f_alias * t_n),\n        np.cos(2 * np.pi * f_alias * t_n)\n    ])\n    \n    # lstsq returns (coeffs, residuals, rank, singular_values)\n    coeffs_ab, _, _, _ = np.linalg.lstsq(A_matrix, y_n, rcond=None)\n    A, B = coeffs_ab[0], coeffs_ab[1]\n    \n    # Fitted alias sinusoid function\n    s_alias_func = lambda t: A * np.sin(2 * np.pi * f_alias * t) + B * np.cos(2 * np.pi * f_alias * t)\n\n    # 4. Evaluation on Dense Grid\n    t_min, t_max = t_n[0], t_n[-1]\n    t_dense = np.linspace(t_min, t_max, M)\n    \n    # Evaluate signals on the dense grid\n    s_true_dense = np.sin(2 * np.pi * f_high * t_dense)\n    s_alias_dense = s_alias_func(t_dense)\n    # np.polyval expects coefficients in descending order of power\n    p_dense = np.polyval(c[::-1], t_dense)\n\n    # 5. Compute Metrics\n    # E1: Max absolute mismatch of alias fit at sample times\n    s_alias_at_samples = s_alias_func(t_n)\n    E1 = np.max(np.abs(y_n - s_alias_at_samples))\n\n    # E2: Max absolute interpolation error at sample times\n    # This should be close to machine epsilon by definition of interpolation\n    p_at_samples = np.polyval(c[::-1], t_n)\n    E2 = np.max(np.abs(y_n - p_at_samples))\n    \n    # E3: RMS difference between true signal and alias fit on dense grid\n    E3 = np.sqrt(np.mean((s_true_dense - s_alias_dense)**2))\n    \n    # E4: RMS difference between interpolating polynomial and true signal on dense grid\n    E4 = np.sqrt(np.mean((p_dense - s_true_dense)**2))\n\n    # Return rounded metrics\n    return [\n        np.round(E1, 10),\n        np.round(E2, 10),\n        np.round(kappa_V, 10),\n        np.round(E3, 10),\n        np.round(E4, 10)\n    ]\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (Aliasing)\n        (10.0, 8, 9.0),\n        # Case 2 (Adequate sampling)\n        (50.0, 12, 9.0),\n        # Case 3 (Nyquist boundary)\n        (20.0, 11, 10.0)\n    ]\n\n    results = []\n    for i, case in enumerate(test_cases):\n        fs, N, f_high = case\n        case_results = process_case(fs, N, f_high)\n        results.append(case_results)\n\n    # Convert each inner list to its string representation\n    # and join them with commas for the final output format.\n    # e.g., [[1.0, 2.0], [3.0, 4.0]] -> '[[1.0, 2.0],[3.0, 4.0]]'\n    final_output_str = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n```", "id": "3285621"}, {"introduction": "我们已经看到了范德蒙矩阵的应用，但它在数值计算中有一个著名的“阿喀琉斯之踵”——数值不稳定性。这个编程实验将让你亲自量化这个问题，通过比较基于单项式基（产生范德蒙矩阵）和基于正交多项式基（如勒让德多项式）的线性系统的条件数，你将经验性地证明选择正确的基对于获得可靠的数值解是多么关键。这个练习为你打开了通往更高级、更稳健的数值方法的大门。[@problem_id:3285634]", "problem": "设计并实现一个数值实验，比较用于实数区间上数据拟合的两种多项式基的数值条件：单项式基和正交多项式基。单项式基产生经典的 Vandermonde 矩阵。所用的正交基是闭区间 $\\left[-1,1\\right]$ 上的 Legendre 多项式基。对于几个指定的测试用例，你的程序必须构建相应的设计矩阵，计算它们在谱矩阵范数下的条件数，并报告条件数的比率，从而通过经验证明其相对数值稳定性。\n\n基本概念：\n- 对于节点 $\\left\\{x_i\\right\\}_{i=0}^{n-1}$ 和多项式次数 $m$，Vandermonde 矩阵是一个设计矩阵 $V \\in \\mathbb{R}^{n \\times (m+1)}$，其元素为 $V_{i,k} = x_i^k$，其中 $k=0,1,\\dots,m$。\n- 在 $\\left[-1,1\\right]$ 上的 Legendre 多项式 $\\left\\{P_k\\right\\}_{k=0}^m$ 是通过相对于标准内积 $\\langle f,g \\rangle = \\int_{-1}^{1} f(x) g(x) \\, dx$ 的正交性定义的，归一化条件为 $P_0(x)=1$，$P_1(x)=x$，以及对于 $k \\ge 1$ 经过充分检验的三项递推关系：\n$$\n(k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x).\n$$\nLegendre 设计矩阵 $L \\in \\mathbb{R}^{n \\times (m+1)}$ 的元素为 $L_{i,k} = P_k(x_i)$，其中 $k=0,1,\\dots,m$。\n- 一个列满秩矩阵 $A$ 的谱（矩阵 $2$-范数）条件数定义为 $\\kappa_2(A) = \\sigma_{\\max}(A)/\\sigma_{\\min}(A)$，其中 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别是 $A$ 的最大和最小奇异值。在有限精度算术中，较大的 $\\kappa_2(A)$ 表示最小二乘解对数据扰动的敏感度更高，因此数值稳定性更差。\n\n任务：\n- 对下面指定的每个测试用例，给定次数 $m$ 和节点集 $\\left\\{x_i\\right\\}$，构建：\n  1. Vandermonde 矩阵 $V$，其列是在节点处求值的 $\\left\\{1,x,x^2,\\dots,x^m\\right\\}$。\n  2. Legendre 矩阵 $L$，其列是使用上述三项递推关系在节点处求值的 $\\left\\{P_0(x),P_1(x),\\dots,P_m(x)\\right\\}$。\n- 计算每种情况下 $\\kappa_2(V)$ 和 $\\kappa_2(L)$ 的值。\n- 对每种情况，输出比率 $r = \\kappa_2(V) / \\kappa_2(L)$，结果为四舍五入到 $6$ 位有效数字的浮点数。\n\n角度单位：所有三角函数的参数均使用弧度。\n\n测试套件：\n- 情况 $1$（方阵，等距节点，中等次数）：$m=10$，$n=m+1$，节点 $x_i = -1 + \\dfrac{2i}{m}$，其中 $i=0,1,\\dots,m$。\n- 情况 $2$（方阵，等距节点，较高次数）：$m=15$，$n=m+1$，节点 $x_i = -1 + \\dfrac{2i}{m}$，其中 $i=0,1,\\dots,m$。\n- 情况 $3$（方阵，Chebyshev–Lobatto 节点）：$m=15$，$n=m+1$，节点 $x_i = \\cos\\!\\left(\\dfrac{\\pi i}{m}\\right)$，其中 $i=0,1,\\dots,m$。\n- 情况 $4$（方阵，节点聚集在零附近）：$m=15$，$n=m+1$，节点 $x_i = 10^{-3}\\left(-1 + \\dfrac{2i}{m}\\right)$，其中 $i=0,1,\\dots,m$。\n- 情况 $5$（超定，Chebyshev–Lobatto 节点）：$m=10$，$n=50$，节点 $x_i = \\cos\\!\\left(\\dfrac{\\pi i}{n-1}\\right)$，其中 $i=0,1,\\dots,n-1$。\n\n输出规格：\n- 你的程序应生成单行输出，包含按顺序排列的情况 $1$ 到 $5$ 的 $5$ 个比率，形式为用方括号括起来的逗号分隔列表。例如：$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$。\n- 每个 $\\text{result}_k$ 都必须是四舍五入到 $6$ 位有效数字的浮点数。\n\n科学真实性与覆盖范围说明：\n- 等距节点情况测试了 Vandermonde 系统的已知病态性以及使用正交基所预期的改善效果。\n- Chebyshev–Lobatto 节点情况测试了理论上更适合多项式逼近并能减少病态性的节点。\n- 节点聚集在零附近的情况通过在较高次幂之间产生近似线性相关性，对单项式基构成了压力测试。\n- 超定情况说明了最小二乘设计矩阵的条件数问题。", "solution": "问题陈述已经过分析，并被确定为**有效**。这是一个适定、具有科学依据的数值分析问题，所有必要的数据和定义均已提供。任务是进行一个数值实验，比较由单项式基（Vandermonde 矩阵）和正交多项式基（Legendre 多项式）派生的设计矩阵的条件数。\n\n解决方案是通过实现一个数值程序来继续，该程序为每个指定的测试用例计算所需的条件数比率。方法如下：\n\n首先，对于每个测试用例，我们给定一个多项式次数 $m$，一个样本点数 $n$，以及在区间 $[-1, 1]$ 上的节点集 $\\{x_i\\}_{i=0}^{n-1}$。我们构建两个大小为 $n \\times (m+1)$ 的设计矩阵。\n\n第一个矩阵是 Vandermonde 矩阵 $V$，它源于使用单项式基 $\\{1, x, x^2, \\dots, x^m\\}$。$V$ 的第 $i$ 行第 $k$ 列（行和列使用从0开始的索引）的元素由下式给出：\n$$\nV_{i,k} = x_i^k \\quad \\text{其中 } i=0, \\dots, n-1 \\text{ 且 } k=0, \\dots, m.\n$$\n该矩阵是为给定的节点集 $\\{x_i\\}$ 构建的。\n\n第二个矩阵是 Legendre 设计矩阵 $L$，它源于使用 Legendre 多项式基 $\\{P_0(x), P_1(x), \\dots, P_m(x)\\}$。$L$ 的元素由下式给出：\n$$\nL_{i,k} = P_k(x_i) \\quad \\text{其中 } i=0, \\dots, n-1 \\text{ 且 } k=0, \\dots, m.\n$$\nLegendre 多项式 $P_k(x_i)$ 的值是数值计算得出的。前两个多项式定义为 $P_0(x) = 1$ 和 $P_1(x) = x$。对于 $k \\ge 1$ 的后续多项式，使用指定的三项递推关系生成：\n$$\n(k+1) P_{k+1}(x) = (2k+1) x P_k(x) - k P_{k-1}(x).\n$$\n这个递推关系被迭代地应用于 $k=1, 2, \\dots, m-1$，以计算每个节点 $x_i$ 上所有必要基多项式的值，从而填充矩阵 $L$ 的列。\n\n接下来，计算两个矩阵 $V$ 和 $L$ 的谱条件数 $\\kappa_2$。一个列满秩矩阵 $A$ 的谱条件数定义为其最大奇异值 $\\sigma_{\\max}(A)$ 与其最小奇异值 $\\sigma_{\\min}(A)$ 的比值：\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)}.\n$$\n这个值量化了线性系统或最小二乘问题的解对输入数据扰动的敏感度。一个更大的条件数表示数值不稳定性更高。奇异值是使用标准的奇异值分解（SVD）算法计算的，该算法在像 NumPy 这样的数值库中可用。\n\n最后，对每个测试用例，计算两个条件数的比率 $r$：\n$$\nr = \\frac{\\kappa_2(V)}{\\kappa_2(L)}.\n$$\n这个比率为多项式数据拟合中使用正交多项式基代替标准单项式基所获得的数值稳定性改善提供了一个定量度量。对所有五个测试用例重复此过程，并收集所得的比率。每个比率在被包含到最终输出之前，都会格式化为 $6$ 位有效数字。该实验证明了 Vandermonde 矩阵已知的病态条件，尤其是在等距节点和较高次数的情况下，以及由正交 Legendre 基所带来的显著改善。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the numerical experiment problem by comparing the conditioning of\n    Vandermonde and Legendre matrices for several test cases.\n    \"\"\"\n\n    # Helper function to evaluate Legendre polynomials P_k(x) for k=0...m\n    # at a given set of nodes x.\n    def evaluate_legendre_basis(x: np.ndarray, m: int) - np.ndarray:\n        \"\"\"\n        Computes the Legendre matrix L where L[i, k] = P_k(x[i]).\n\n        Args:\n            x: A 1D numpy array of nodes.\n            m: The maximum degree of the polynomial basis.\n\n        Returns:\n            A 2D numpy array of shape (len(x), m + 1) containing the\n            evaluations of Legendre polynomials.\n        \"\"\"\n        n = len(x)\n        L_matrix = np.zeros((n, m + 1))\n\n        # P_0(x) = 1\n        L_matrix[:, 0] = 1.0\n\n        if m  0:\n            # P_1(x) = x\n            L_matrix[:, 1] = x\n\n        # Recurrence relation for k = 1:\n        # (k+1) * P_{k+1}(x) = (2k+1) * x * P_k(x) - k * P_{k-1}(x)\n        for k in range(1, m):\n            p_k = L_matrix[:, k]\n            p_k_minus_1 = L_matrix[:, k-1]\n            p_k_plus_1 = ((2 * k + 1) * x * p_k - k * p_k_minus_1) / (k + 1)\n            L_matrix[:, k + 1] = p_k_plus_1\n        \n        return L_matrix\n\n    # Helper function to process a single test case\n    def compute_condition_number_ratio(m: int, nodes: np.ndarray) - float:\n        \"\"\"\n        Constructs Vandermonde and Legendre matrices and computes the ratio\n        of their condition numbers.\n\n        Args:\n            m: The maximum degree of the polynomial basis.\n            nodes: A 1D numpy array of nodes.\n\n        Returns:\n            The ratio kappa(V) / kappa(L).\n        \"\"\"\n        # 1. Construct the Vandermonde matrix (monomial basis)\n        # Columns are [1, x, x^2, ..., x^m]\n        V = np.vander(nodes, N=m + 1, increasing=True)\n        \n        # 2. Construct the Legendre matrix (orthogonal basis)\n        L = evaluate_legendre_basis(nodes, m)\n        \n        # 3. Compute the spectral (2-norm) condition numbers\n        cond_V = np.linalg.cond(V)\n        cond_L = np.linalg.cond(L)\n        \n        # 4. Return the ratio\n        if cond_L == 0:\n            # Avoid division by zero, though unlikely in these cases\n            return float('inf')\n        return cond_V / cond_L\n\n    # Define the test suite as specified in the problem\n    test_cases = [\n        # Case 1: m=10, n=11, equispaced\n        {'m': 10, 'n': 11, 'node_gen': lambda i, m, n: -1 + 2 * i / m},\n        # Case 2: m=15, n=16, equispaced\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: -1 + 2 * i / m},\n        # Case 3: m=15, n=16, Chebyshev-Lobatto\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: np.cos(np.pi * i / m)},\n        # Case 4: m=15, n=16, clustered near zero\n        {'m': 15, 'n': 16, 'node_gen': lambda i, m, n: 1e-3 * (-1 + 2 * i / m)},\n        # Case 5: m=10, n=50, overdetermined Chebyshev-Lobatto\n        {'m': 10, 'n': 50, 'node_gen': lambda i, m, n: np.cos(np.pi * i / (n - 1))}\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n = case['m'], case['n']\n        node_gen = case['node_gen']\n        \n        indices = np.arange(n)\n        nodes = node_gen(indices, m, n)\n        \n        ratio = compute_condition_number_ratio(m, nodes)\n        \n        # Format the result to 6 significant figures\n        results.append(f\"{ratio:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "3285634"}]}