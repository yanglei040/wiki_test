{"hands_on_practices": [{"introduction": "要真正掌握一个算法，最好的方法莫过于亲手执行它。这项练习将引导你逐步完成霍纳算法的每一步计算。通过追踪一个具体多项式求值过程中的中间值，你将对该方法的递推关系建立起一个具体而清晰的认识，并理解其结果是如何通过一系列高效的乘加运算逐步构建起来的。[@problem_id:2177814]", "problem": "一个次数为 $n$ 的多项式的一般形式为 $P(x) = \\sum_{i=0}^{n} a_i x^i = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0$。一种用于计算此多项式在特定点 $x=c$ 处的值的高效计算方法是霍纳方法。该方法定义一个中间值序列 $\\{b_k\\}_{k=0}^n$，其计算过程如下：\n- 初始化：$b_n = a_n$\n- 递推：对于 $k = n-1, n-2, \\dots, 0$，计算 $b_k = a_k + c \\cdot b_{k+1}$。\n此递推的最终结果 $b_0$ 是多项式在 $c$ 处的值，即 $P(c) = b_0$。\n\n对于多项式 $P(x) = 4x^3 - 2x^2 + 5x - 1$，请确定当在点 $x=2$ 处计算 $P(x)$ 时，通过此方法生成的完整值序列 $(b_3, b_2, b_1, b_0)$。", "solution": "给定多项式 $P(x) = 4x^{3} - 2x^{2} + 5x - 1$，其次数为 $n=3$。因此，其系数为 $a_{3} = 4$, $a_{2} = -2$, $a_{1} = 5$ 和 $a_{0} = -1$。我们使用霍纳递推在 $c=2$ 处求值。\n根据递推关系 $b_k = a_k + c \\cdot b_{k+1}$：\n- 初始化：$b_3 = a_3 = 4$\n- 逐步计算：\n$$b_2 = a_2 + 2 \\cdot b_3 = -2 + 2(4) = 6$$\n$$b_1 = a_1 + 2 \\cdot b_2 = 5 + 2(6) = 17$$\n$$b_0 = a_0 + 2 \\cdot b_1 = -1 + 2(17) = 33$$\n因此，该序列为 $(b_3, b_2, b_1, b_0) = (4, 6, 17, 33)$，并且 $P(2) = b_0 = 33$。", "answer": "$$\\boxed{\\begin{pmatrix} 4  6  17  33 \\end{pmatrix}}$$", "id": "2177814"}, {"introduction": "理解了霍纳算法的“如何做”之后，下一个关键问题是“为什么它如此重要”。这个练习将揭示霍纳算法与多项式代数基本定理之间的深刻联系，特别是多项式余数定理。你将通过从第一性原理推导该方法，并将其应用于整数根的检验，从而体会到它不仅仅是一种计算技巧，更是一个优雅且强大的代数工具。[@problem_id:3239198]", "problem": "一个整系数多项式可以在一个整数点上进行求值，而无需任何浮点运算，只需通过适当地重组各项，使得每一步只需要加法和乘法。考虑多项式\n$$\np(x) = 3x^{5} - 11x^{4} + x^{3} + 39x^{2} - 30x - 24\n$$\n和整数候选根 $r = 2$。\n\n任务：\n1) 从多项式作为带系数的单项式有限和的定义出发，仅使用加法和乘法的分配律和结合律，推导出一个嵌套求值过程，该过程通过一系列从最高次系数到常数项应用的“先乘后加”步骤来计算 $p(r)$。你的推导必须从一般形式 $p(x) = \\sum_{k=0}^{n} a_{k} x^{k}$ 开始，并且不得假定任何现成的算法。\n2) 证明如果所有系数 $a_{k}$ 都是整数且 $r$ 是一个整数，那么你的嵌套过程产生的每个中间值也都是整数。你的证明必须仅依赖于整数在加法和乘法下的封闭性。\n3) 将你推导出的过程应用于给定的 $p(x)$ 和 $r$，仅使用整数运算计算 $p(x)$ 除以 $x - r$ 的余数。将此余数报告为单个整数。不要使用任何浮点运算，也不要四舍五入；答案是精确的。", "solution": "解答分为三个部分，对应问题陈述中的三个任务。\n\n### 任务1：嵌套求值过程的推导\n\n设 $p(x)$ 是一个次数为 $n$ 的多项式，其系数为 $a_k$，其中 $k=0, 1, \\dots, n$。该多项式的标准定义是单项式的有限和：\n$$\np(x) = \\sum_{k=0}^{n} a_{k} x^{k} = a_n x^n + a_{n-1} x^{n-1} + \\dots + a_1 x + a_0\n$$\n为了仅使用分配律和结合律推导出一个嵌套求值过程，我们可以策略性地、顺序地提取变量 $x$。一个关键的洞见是，Horner 方法更自然地可以表达为递推关系。\n\n我们首先通过从除常数项 $a_0$ 之外的所有项中提取 $x$ 来重组 $p(x)$ 的各项：\n$$\np(x) = (a_n x^{n-1} + a_{n-1} x^{n-2} + \\dots + a_2 x + a_1)x + a_0\n$$\n这是分配律的直接应用。括号内的表达式本身是一个次数为 $n-1$ 的多项式。我们可以重复这个过程。让我们从新的括号表达式中提取 $x$，不包括其常数项 $a_1$：\n$$\np(x) = ((a_n x^{n-2} + a_{n-1} x^{n-3} + \\dots + a_2)x + a_1)x + a_0\n$$\n继续这个过程，直到我们只剩下最高次系数 $a_n$，我们得到多项式的完全嵌套形式：\n$$\np(x) = (\\dots((a_n x + a_{n-1})x + a_{n-2})x + \\dots + a_1)x + a_0\n$$\n这种嵌套结构表明了一个顺序计算过程。为了将其形式化，我们定义一个中间值序列，记作 $y_k$，它对应于从最内层向外求值的嵌套括号的值。\n\n设要求计算的值为 $p(r)$。我们如下定义该序列：\n1. 从最高次项的系数开始：\n   $$y_n = a_n$$\n2. 通过将前一个结果乘以 $r$ 并加上按次数降序排列的下一个系数，递归地计算下一个值：\n   $$y_{n-1} = y_n \\cdot r + a_{n-1} = a_n r + a_{n-1}$$\n3. 继续这个过程：\n   $$y_{n-2} = y_{n-1} \\cdot r + a_{n-2} = (a_n r + a_{n-1})r + a_{n-2} = a_n r^2 + a_{n-1} r + a_{n-2}$$\n这个序列中对于 $k$ 从 $n-1$ 降到 $0$ 的一般步骤是：\n$$\ny_k = y_{k+1} \\cdot r + a_k\n$$\n通过反复代入 $y_{k+1}$ 的定义，我们可以看到最终值 $y_0$ 对应于在 $r$ 点求值的完整多项式：\n\\begin{align*} y_0 = y_1 \\cdot r + a_0 \\\\ = (y_2 \\cdot r + a_1)r + a_0 \\\\ = (\\dots(y_n \\cdot r + a_{n-1})r + \\dots + a_1)r + a_0 \\\\ = (\\dots((a_n)r + a_{n-1})r + \\dots + a_1)r + a_0 \\\\ = a_n r^n + a_{n-1} r^{n-1} + \\dots + a_1 r + a_0 \\\\ = p(r) \\end{align*}\n因此，计算 $p(r)$ 的嵌套求值过程如下：\n1. 初始化一个结果变量，我们称之为 $y$，其值为最高次系数 $a_n$。\n2. 从 $k = n-1$ 迭代到 $0$。在每一步中，使用规则 $y \\leftarrow y \\cdot r + a_k$ 更新 $y$。\n3. 循环完成后（即，在 $k=0$ 的步骤之后），$y$ 的最终值就是 $p(r)$。\n这个过程只使用了所要求的“先乘后加”步骤序列。\n\n### 任务2：整数封闭性的证明\n\n我们要证明，如果所有系数 $a_k$ 都是整数 ($a_k \\in \\mathbb{Z}$) 并且求值点 $r$ 是一个整数 ($r \\in \\mathbb{Z}$)，那么由任务1中推导的过程所生成的每个中间值 $y_k$ 也都是整数。该证明依赖于整数集合 $\\mathbb{Z}$ 在加法和乘法下的封闭性。\n\n该过程由以下递推关系定义：\n$$\ny_n = a_n\n$$\n$$\ny_k = y_{k+1} \\cdot r + a_k \\quad \\text{for } k = n-1, n-2, \\dots, 0\n$$\n\n我们将对从 $y_n$ 开始并向下进行到 $y_0$ 的计算序列使用归纳法证明。\n\n**基础情形：** 计算的第一个中间值是 $y_n$。根据过程定义，$y_n = a_n$。根据问题的假设，所有系数 $a_k$ 都是整数。因此，$a_n \\in \\mathbb{Z}$，这意味着 $y_n \\in \\mathbb{Z}$。基础情形成立。\n\n**归纳假设：** 假设对于某个满足 $0  j \\le n$ 的整数 $j$，中间值 $y_j$ 是一个整数，即 $y_j \\in \\mathbb{Z}$。\n\n**归纳步骤：** 我们必须证明序列中的下一个值 $y_{j-1}$ 也是一个整数。该过程将 $y_{j-1}$ 定义为：\n$$\ny_{j-1} = y_j \\cdot r + a_{j-1}\n$$\n我们分析等式右边的各项：\n1. 根据归纳假设，$y_j$ 是一个整数 ($y_j \\in \\mathbb{Z}$)。\n2. 根据问题的假设，$r$ 是一个整数 ($r \\in \\mathbb{Z}$)。\n3. 整数集合 $\\mathbb{Z}$ 在乘法下是封闭的。这意味着任意两个整数的乘积是整数。因此，项 $y_j \\cdot r$ 是一个整数。\n4. 根据问题的假设，系数 $a_{j-1}$ 是一个整数 ($a_{j-1} \\in \\mathbb{Z}$)。\n5. 整数集合 $\\mathbb{Z}$ 在加法下是封闭的。这意味着任意两个整数的和是整数。因此，和 $(y_j \\cdot r) + a_{j-1}$ 是一个整数。\n\n这意味着 $y_{j-1} \\in \\mathbb{Z}$。\n\n**结论：** 因为基础情形 ($y_n \\in \\mathbb{Z}$) 成立，并且归纳步骤正确地证明了如果 $y_j \\in \\mathbb{Z}$ 则 $y_{j-1} \\in \\mathbb{Z}$，所以根据数学归纳法原理，所有中间值 $y_k$（其中 $k = n, n-1, \\dots, 0$）都是整数。\n\n### 任务3：应用于给定多项式\n\n我们被要求应用推导出的过程来计算 $p(x)$ 除以 $x-r$ 的余数。根据多项式余数定理，这个余数等于 $p(r)$。\n\n给定的多项式是：\n$$\np(x) = 3x^{5} - 11x^{4} + 1x^{3} + 39x^{2} - 30x - 24\n$$\n系数从最高次到最低次分别为：\n$a_5 = 3$\n$a_4 = -11$\n$a_3 = 1$\n$a_2 = 39$\n$a_1 = -30$\n$a_0 = -24$\n\n整数候选根是 $r = 2$。\n\n我们现在应用该过程，仅使用整数运算来计算中间值序列 $y_k$。\n\n步骤1：用 $a_5$ 初始化。\n$y_5 = a_5 = 3$\n\n步骤2：计算 $y_4$。\n$y_4 = y_5 \\cdot r + a_4 = 3 \\cdot 2 + (-11) = 6 - 11 = -5$\n\n步骤3：计算 $y_3$。\n$y_3 = y_4 \\cdot r + a_3 = (-5) \\cdot 2 + 1 = -10 + 1 = -9$\n\n步骤4：计算 $y_2$。\n$y_2 = y_3 \\cdot r + a_2 = (-9) \\cdot 2 + 39 = -18 + 39 = 21$\n\n步骤5：计算 $y_1$。\n$y_1 = y_2 \\cdot r + a_1 = 21 \\cdot 2 + (-30) = 42 - 30 = 12$\n\n步骤6：计算 $y_0$。\n$y_0 = y_1 \\cdot r + a_0 = 12 \\cdot 2 + (-24) = 24 - 24 = 0$\n\n最终值为 $y_0 = 0$。这个值是 $p(2)$，也就是 $p(x)$ 除以 $x-2$ 的余数。所有的中间值（$-5$, $-9$, $21$, $12$）都是整数，正如任务2的证明所预测的那样。\n\n余数是 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "3239198"}, {"introduction": "科学计算中的许多问题都涉及多变量函数。这项练习将挑战你将霍纳算法的核心思想——嵌套求值——推广到更复杂的二维情况。通过为二元多项式设计并实现一个高效的求值算法，你将看到霍纳方法的可扩展性与普适性，并体验将其应用于解决实际计算问题的过程。[@problem_id:3239322]", "problem": "给定一个由指数到系数的映射定义的二元多项式。设 $P(x,y)$ 为有限和\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j},\n$$\n其中 $a_{ij} \\in \\mathbb{R}$ 并且 $(m,n)$ 是非负整数。仅从多项式的定义和为避免显式求幂而采用的重复因式分解原理出发，推导一个算法来评估 $P(x,y)$。该算法通过对一个变量应用单变量线性时间方案以获得中间系数，然后对另一个变量应用相同的方案。然后将此算法实现为一个程序，用于为几个指定的输入计算 $P(x,y)$ 的值。\n\n要求和约束：\n- 你的推导必须基于多项式的基本定义以及通过合并同类幂来避免使用重复乘法显式计算 $x^i$ 和 $y^j$ 的思想。\n- 你必须组织计算过程：首先将 $P(x,y)$ 视为一个变量的求和，其系数是另一个变量的多项式，然后仅使用加法和乘法按顺序对这些多项式求值。\n- 实现一个函数，该函数接受一个实系数的矩形数组 $(a_{ij})$，并遵循行索引 $i$ 对应于 $x$ 的幂，列索引 $j$ 对应于 $y$ 的幂的约定。这意味着第 $i$ 行第 $j$ 列的条目等于 $a_{ij}$，即 $x^{i} y^{j}$ 的系数。\n- 通过避免对 $x$ 或 $y$ 进行显式求幂，并以嵌套求值顺序仅使用加法和乘法来确保数值稳定性。\n- 你的实现必须使用嵌套求值顺序，即首先对每个固定的 $i$ 就 $y$ 进行求值以产生中间值 $b_i(y)$，然后使用 $b_i(y)$ 作为系数就 $x$ 进行求值。\n\n测试套件：\n- 使用以下五个测试用例。对于每个测试用例，都指定了系数矩阵以及求值点 $(x,y)$。此处，矩阵按行写入。\n  - 测试用例 $1$：\n    $A^{(1)} = \\begin{bmatrix} 3  4  0 \\\\ 2  5  0 \\\\ 0  0  1 \\end{bmatrix}$, $x^{(1)} = 1.5$, $y^{(1)} = -0.75$。\n  - 测试用例 $2$：\n    $A^{(2)} = \\begin{bmatrix} 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$, $x^{(2)} = -2.3$, $y^{(2)} = 4.1$。\n  - 测试用例 $3$：\n    $A^{(3)} = \\begin{bmatrix} 1  2  3 \\\\ 0  0  0 \\\\ 0  0  0 \\end{bmatrix}$, $x^{(3)} = 0$, $y^{(3)} = 2$。\n  - 测试用例 $4$：\n    $A^{(4)} = \\begin{bmatrix} 1  -1 \\\\ 2  0.5 \\\\ -3  4 \\end{bmatrix}$, $x^{(4)} = 2$, $y^{(4)} = 0$。\n  - 测试用例 $5$：\n    $A^{(5)} = \\begin{bmatrix} 0.5  -1  0.25  -0.125 \\\\ 2  0  -0.5  0 \\\\ 0  1.5  0  -0.25 \\\\ -1  0  0  0.0625 \\end{bmatrix}$, $x^{(5)} = 0.75$, $y^{(5)} = -1.2$。\n\n输入和输出规范：\n- 无需读取输入。请在程序中硬编码上述测试套件。\n- 你的程序必须使用所述的嵌套求值顺序为上述每个测试用例计算 $P(x,y)$。\n- 最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。将每个数值结果四舍五入到 $10$ 位小数，使用标准的就近舍入，若出现平局则舍入到最接近的可表示的偶数小数。例如，格式必须为 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_k$ 都四舍五入到 $10$ 位小数。\n- 本问题不涉及物理单位和角度。\n\n交付成果：\n- 提供一个完整的、可运行的程序，该程序实现所述算法并以上述确切格式打印测试套件的结果。打印的最后一行必须是所描述的单一列表，且不得包含任何附加文本。", "solution": "该问题要求推导并实现一个高效算法，用于计算一个二元多项式 $P(x,y)$ 的值，其定义如下：\n$$\nP(x,y) = \\sum_{i=0}^{m} \\sum_{j=0}^{n} a_{ij} \\, x^{i} y^{j}\n$$\n推导过程必须基于重复因式分解原理，类似于单变量的霍纳法则（Horner's method），以避免对 $x^i$ 和 $y^j$ 进行代价高昂且可能不稳定的显式求幂计算。该算法必须遵循特定的嵌套求值顺序：首先对 $y$ 求值，然后对 $x$ 求值。\n\n让我们从给定的多项式定义开始。核心思想是改变求和顺序并对各项进行分组。问题指定将 $P(x,y)$ 视为一个单变量（比如 $x$）的多项式，其系数本身是另一个变量 $y$ 的多项式。我们可以通过提出 $x$ 的幂来重写这个双重求和：\n$$\nP(x,y) = \\sum_{i=0}^{m} \\left( \\sum_{j=0}^{n} a_{ij} y^j \\right) x^i\n$$\n这个表达式将 $P(x,y)$ 表示为变量 $x$ 的多项式。让我们将括号中的项定义为 $b_i(y)$，它是一个对于固定索引 $i$ 的关于 $y$ 的多项式：\n$$\nb_i(y) = \\sum_{j=0}^{n} a_{ij} y^j = a_{i0} + a_{i1}y + a_{i2}y^2 + \\dots + a_{in}y^n\n$$\n对于从 $0$ 到 $m$ 的每个整数 $i$，$b_i(y)$ 是一个关于 $y$ 的单变量多项式。$b_i(y)$ 的系数由系数矩阵 $A$ 的第 $i$ 行给出，即 $(a_{i0}, a_{i1}, \\dots, a_{in})$。\n\n根据这个定义，原始多项式 $P(x,y)$ 可以表示为：\n$$\nP(x,y) = \\sum_{i=0}^{m} b_i(y) x^i = b_0(y) + b_1(y)x^1 + b_2(y)x^2 + \\dots + b_m(y)x^m\n$$\n这种结构为给定的点 $(x,y)$ 提供了一个两阶段的求值过程。\n\n**第一阶段：中间系数的求值**\n\n首先，对于给定的 $y$ 值，我们必须计算系数 $b_0(y), b_1(y), \\dots, b_m(y)$ 的数值。每个 $b_i(y)$ 都是一个单变量多项式，可以使用单变量的霍纳法则高效地求值。霍纳法则（也称为嵌套乘法）通过将多项式 $Q(z) = c_k z^k + c_{k-1} z^{k-1} + \\dots + c_1 z + c_0$ 因式分解为以下形式来求值：\n$$\nQ(z) = c_0 + z(c_1 + z(c_2 + \\dots + z(c_{k-1} + c_k z)\\dots))\n$$\n在算法上，这是通过用最高次系数 $c_k$ 初始化一个结果，并向下迭代来计算的：\n`结果` $\\leftarrow$ $c_k$\n对于 $l$ 从 $k-1$ 递减到 $0$：\n`结果` $\\leftarrow$ `结果` $\\times z + c_l$\n\n对于我们的问题，为了计算 $b_i(y) = \\sum_{j=0}^{n} a_{ij} y^j$，我们对变量 $y$ 和系数 $(a_{i0}, a_{i1}, \\dots, a_{in})$ 应用此方法。$y$ 的降幂系数是 $(a_{in}, a_{i,n-1}, \\dots, a_{i0})$。令 $B_i$ 表示计算出的数值 $b_i(y)$。我们对从 $0$ 到 $m$ 的每个 $i$ 执行此求值，从而得到一组中间数值系数 $\\{B_0, B_1, \\dots, B_m\\}$。\n\n**第二阶段：最终多项式求值**\n\n一旦中间系数 $B_i = b_i(y)$ 计算完毕，问题就简化为计算一个新的关于 $x$ 的单变量多项式：\n$$\nP(x,y) = \\sum_{i=0}^{m} B_i x^i = B_0 + B_1 x + B_2 x^2 + \\dots + B_m x^m\n$$\n我们再次应用霍纳法则，这次是应用于变量 $x$ 和刚刚计算出的系数 $\\{B_0, B_1, \\dots, B_m\\}$。对应于 $x$ 的降幂系数是 $(B_m, B_{m-1}, \\dots, B_0)$。求值过程如下：\n`最终结果` $\\leftarrow$ $B_m$\n对于 $i$ 从 $m-1$ 递减到 $0$：\n`最终结果` $\\leftarrow$ `最终结果` $\\times x + B_i$\n\n`最终结果` 的最终值就是 $P(x,y)$ 的值。\n\n**算法总结**\n\n完整的算法，遵循指定的嵌套求值顺序，如下所示：\n\n1.  输入：一个 $(m+1) \\times (n+1)$ 的系数矩阵 $A$（其中 $A_{ij} = a_{ij}$）和一个点 $(x,y)$。\n2.  初始化一个大小为 $m+1$ 的数组 `B` 来存储中间系数。\n3.  对于从 $0$ 到 $m$ 的每个行索引 $i$：\n    a. 提取 $A$ 的第 $i$ 行，该行包含多项式 $b_i(y)$ 的系数 $(a_{i0}, a_{i1}, \\dots, a_{in})$。\n    b. 使用霍纳法则计算在给定 $y$ 值下的 $b_i(y)$。\n    c. 将结果存储在 `B[i]` 中。\n4.  现在，数组 `B` 持有关于 $x$ 的多项式的数值系数 $(B_0, B_1, \\dots, B_m)$。\n5.  使用霍纳法则计算在给定 $x$ 值下的多项式 $\\sum_{i=0}^{m} B_i x^i$。\n6.  这第二次求值的结果就是 $P(x,y)$ 的最终值。\n\n此过程仅以嵌套方式使用加法和乘法，完全避免了显式求幂，从而确保了更好的数值稳定性和效率，其时间复杂度为 $O(mn)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef evaluate_bivariate_poly(A, x, y):\n    \"\"\"\n    Evaluates a bivariate polynomial P(x, y) using a nested Horner's scheme.\n\n    The polynomial is defined as P(x,y) = sum_{i=0 to m} sum_{j=0 to n} a_ij * x^i * y^j.\n    The coefficient a_ij is located at A[i, j].\n\n    The evaluation first computes intermediate coefficients B_i(y) for each power of x,\n    and then evaluates the final polynomial in x with these coefficients.\n\n    Args:\n        A (np.ndarray): A 2D numpy array of shape (m+1, n+1) containing the\n                        coefficients a_ij. A[i, j] is the coefficient of x^i * y^j.\n        x (float): The value of x at which to evaluate the polynomial.\n        y (float): The value of y at which to evaluate the polynomial.\n\n    Returns:\n        float: The value of P(x, y).\n    \"\"\"\n    # The number of rows (m+1) corresponds to the degree of x plus 1.\n    # The number of columns (n+1) corresponds to the degree of y plus 1.\n    m_plus_1, n_plus_1 = A.shape\n\n    # Stage 1: Evaluate intermediate polynomials in y for each row i.\n    # Each row A[i, :] contains the coefficients (a_i0, a_i1, ..., a_in)\n    # for a polynomial in y: b_i(y) = a_i0 + a_i1*y + ... + a_in*y^n.\n    # np.polyval expects coefficients for decreasing powers, so we reverse each row.\n    B = []\n    for i in range(m_plus_1):\n        row_coeffs = A[i, :]\n        # Coefficients for np.polyval: [a_in, a_i(n-1), ..., a_i0]\n        b_i_y = np.polyval(row_coeffs[::-1], y)\n        B.append(b_i_y)\n\n    # Stage 2: Evaluate the final polynomial in x.\n    # The coefficients are the computed B_i values: [B_0, B_1, ..., B_m].\n    # This corresponds to the polynomial P(x,y) = B_0 + B_1*x + ... + B_m*x^m.\n    # np.polyval expects coefficients for decreasing powers of x, so we reverse B.\n    # Coefficients for np.polyval: [B_m, B_(m-1), ..., B_0]\n    final_value = np.polyval(B[::-1], x)\n    \n    return final_value\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the evaluation for each case, and prints\n    the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (np.array([[3, 4, 0], [2, 5, 0], [0, 0, 1]], dtype=float), 1.5, -0.75),\n        (np.array([[0, 0, 0], [0, 0, 0]], dtype=float), -2.3, 4.1),\n        (np.array([[1, 2, 3], [0, 0, 0], [0, 0, 0]], dtype=float), 0, 2),\n        (np.array([[1, -1], [2, 0.5], [-3, 4]], dtype=float), 2, 0),\n        (np.array([\n            [0.5, -1, 0.25, -0.125],\n            [2, 0, -0.5, 0],\n            [0, 1.5, 0, -0.25],\n            [-1, 0, 0, 0.0625]\n        ], dtype=float), 0.75, -1.2)\n    ]\n\n    results = []\n    for A, x, y in test_cases:\n        result = evaluate_bivariate_poly(A, x, y)\n        # Round the result to 10 decimal places.\n        rounded_result = round(result, 10)\n        results.append(str(rounded_result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver.\nsolve()\n```", "id": "3239322"}]}