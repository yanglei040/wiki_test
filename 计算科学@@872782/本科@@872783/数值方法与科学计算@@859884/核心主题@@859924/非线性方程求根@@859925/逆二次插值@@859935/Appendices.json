{"hands_on_practices": [{"introduction": "理解任何数值方法都始于对其基本机理的把握。本练习将引导你手动完成逆二次插值的一个计算步骤，直接应用拉格朗日插值的基本原理 [@problem_id:3244092]。通过处理函数 $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$，你将亲身体验 IQI 如何为一个其真实逆函数非多项式的函数构建二次近似模型，从而对近似过程获得具体而深入的感受。", "problem": "考虑函数 $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$ 的非线性求根问题，其唯一实根位于 $x = 0$。逆二次插值 (IQI) 通过构建一个唯一的二次多项式 $\\widehat{x}(y)$ 来对数据点 $(y_i, x_i)$（其中 $y_i = f(x_i)$）进行插值，然后将下一个迭代值设为 $x_{k+1} = \\widehat{x}(0)$，从而生成一个新的迭代值。从初始横坐标 $x_0 = -1$，$x_1 = 2$ 和 $x_2 = 3$ 开始，执行以下操作：\n\n- 仅使用“存在唯一二次多项式对三个不同数据点进行插值”以及“在插值模型下，于指定纵坐标处对此插值多项式求值可得到相应横坐标”这一基本事实，根据数据 $(y_0, x_0)$、$(y_1, x_1)$、$(y_2, x_2)$（其中 $y_i = f(x_i)$）构建 $\\widehat{x}(y)$，除标准多项式插值原理外，不使用任何预先推导的简化公式。\n- 计算 $\\widehat{x}(0)$ 以获得第一个 IQI 更新值 $x_3$。\n\n将您的最终答案以根式表示的精确闭式代数表达式形式给出；不要进行小数化或四舍五入。最终答案必须是关于 $x_3$ 的单个表达式。", "solution": "用户提供了一个定义明确的数值分析问题。\n\n### 步骤 1: 提取已知条件\n- 函数: $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$\n- 求根问题: $f(x) = 0$\n- 方法: 逆二次插值 (IQI)\n- 初始横坐标: $x_0 = -1$, $x_1 = 2$, $x_2 = 3$\n- IQI 更新的定义: 下一个迭代值 $x_{k+1}$ 是 $\\widehat{x}(0)$，其中 $\\widehat{x}(y)$ 是对点 $(y_i, x_i)$（对于 $i=k-2, k-1, k$）进行插值的唯一二次多项式。\n- 任务: 为初始点构建 $\\widehat{x}(y)$ 并计算 $\\widehat{x}(0)$ 以求得 $x_3$。\n\n### 步骤 2: 使用提取的已知条件进行验证\n该问题在数值方法领域具有科学依据。函数 $f(x)$ 定义良好。为使逆二次插值有良好定义，三个纵坐标 $y_i = f(x_i)$ 必须是互不相同的。我们来计算它们：\n- $y_0 = f(x_0) = f(-1) = \\mathrm{sign}(-1)\\sqrt{|-1|} = (-1)\\sqrt{1} = -1$\n- $y_1 = f(x_1) = f(2) = \\mathrm{sign}(2)\\sqrt{|2|} = (1)\\sqrt{2} = \\sqrt{2}$\n- $y_2 = f(x_2) = f(3) = \\mathrm{sign}(3)\\sqrt{|3|} = (1)\\sqrt{3} = \\sqrt{3}$\n纵坐标 $y_0 = -1$，$y_1 = \\sqrt{2}$ 和 $y_2 = \\sqrt{3}$ 是互不相同的。因此，存在一个唯一的二次多项式 $\\widehat{x}(y)$ 对点 $(y_0, x_0)$、$(y_1, x_1)$ 和 $(y_2, x_2)$ 进行插值。该问题是自洽、一致且适定的。\n\n### 步骤 3: 结论与行动\n问题有效。将提供解答。\n\n### 解答\n目标是求出函数 $f(x) = \\mathrm{sign}(x)\\sqrt{|x|}$ 的根的逆二次插值 (IQI) 方法的下一个迭代值 $x_3$，初始值为 $x_0 = -1$，$x_1 = 2$ 和 $x_2 = 3$。\n\nIQI 方法用一个二次多项式来为反函数 $x = f^{-1}(y)$ 建模。我们已知函数 $f(x)$ 图像上的三个点：$(x_0, y_0)$、$(x_1, y_1)$、$(x_2, y_2)$。对于反函数，这些点对应于 $(y_0, x_0)$、$(y_1, x_1)$ 和 $(y_2, x_2)$。用于逆插值的数据点如下：\n- 点 0: $(y_0, x_0) = (-1, -1)$\n- 点 1: $(y_1, x_1) = (\\sqrt{2}, 2)$\n- 点 2: $(y_2, x_2) = (\\sqrt{3}, 3)$\n\n题目要求从基本原理出发构建插值多项式 $\\widehat{x}(y)$。我们将使用拉格朗日形式的插值多项式，它将通过这三个点的唯一二次多项式表示为：\n$$ \\widehat{x}(y) = x_0 L_0(y) + x_1 L_1(y) + x_2 L_2(y) $$\n其中 $L_0(y)$、$L_1(y)$ 和 $L_2(y)$ 是拉格朗日基多项式：\n$$ L_0(y) = \\frac{(y - y_1)(y - y_2)}{(y_0 - y_1)(y_0 - y_2)}, \\quad L_1(y) = \\frac{(y - y_0)(y - y_2)}{(y_1 - y_0)(y_1 - y_2)}, \\quad L_2(y) = \\frac{(y - y_0)(y - y_1)}{(y_2 - y_0)(y_2 - y_1)} $$\n下一个 IQI 迭代值 $x_3$ 是根的新近似值，通过在 $y=0$ 处对逆插值多项式求值得到（因为根 $x$ 满足 $f(x)=0$，这意味着 $x=f^{-1}(0)$）。\n$$ x_3 = \\widehat{x}(0) = x_0 L_0(0) + x_1 L_1(0) + x_2 L_2(0) $$\n我们在 $y=0$ 处对基多项式求值：\n$$ L_0(0) = \\frac{y_1 y_2}{(y_0 - y_1)(y_0 - y_2)} $$\n$$ L_1(0) = \\frac{y_0 y_2}{(y_1 - y_0)(y_1 - y_2)} $$\n$$ L_2(0) = \\frac{y_0 y_1}{(y_2 - y_0)(y_2 - y_1)} $$\n将这些代入 $x_3$ 的表达式，得到 IQI 更新的通用公式：\n$$ x_3 = x_0 \\frac{y_1 y_2}{(y_0 - y_1)(y_0 - y_2)} + x_1 \\frac{y_0 y_2}{(y_1 - y_0)(y_1 - y_2)} + x_2 \\frac{y_0 y_1}{(y_2 - y_0)(y_2 - y_1)} $$\n现在，我们代入指定的值：$x_0 = -1$，$x_1 = 2$，$x_2 = 3$ 以及 $y_0 = -1$，$y_1 = \\sqrt{2}$，$y_2 = \\sqrt{3}$。\n$$ x_3 = (-1) \\frac{(\\sqrt{2})(\\sqrt{3})}{(-1 - \\sqrt{2})(-1 - \\sqrt{3})} + (2) \\frac{(-1)(\\sqrt{3})}{(\\sqrt{2} - (-1))(\\sqrt{2} - \\sqrt{3})} + (3) \\frac{(-1)(\\sqrt{2})}{(\\sqrt{3} - (-1))(\\sqrt{3} - \\sqrt{2})} $$\n$$ x_3 = - \\frac{\\sqrt{6}}{(1 + \\sqrt{2})(1 + \\sqrt{3})} - \\frac{2\\sqrt{3}}{(1 + \\sqrt{2})(\\sqrt{2} - \\sqrt{3})} - \\frac{3\\sqrt{2}}{(1 + \\sqrt{3})(\\sqrt{3} - \\sqrt{2})} $$\n为了简化，我们注意到 $\\sqrt{3}-\\sqrt{2} = -(\\sqrt{2}-\\sqrt{3})$。\n$$ x_3 = - \\frac{\\sqrt{6}}{(1 + \\sqrt{2})(1 + \\sqrt{3})} - \\frac{2\\sqrt{3}}{(1 + \\sqrt{2})(\\sqrt{2} - \\sqrt{3})} + \\frac{3\\sqrt{2}}{(1 + \\sqrt{3})(\\sqrt{2} - \\sqrt{3})} $$\n我们将各项通分，公分母为 $D = (1 + \\sqrt{2})(1 + \\sqrt{3})(\\sqrt{2} - \\sqrt{3})$：\n$$ D = (1+\\sqrt{2}) \\left( \\sqrt{2}-\\sqrt{3}+\\sqrt{6}-3 \\right) = \\sqrt{2}-\\sqrt{3}+\\sqrt{6}-3 + 2-\\sqrt{6}+\\sqrt{12}-3\\sqrt{2} = \\sqrt{3} - 2\\sqrt{2} - 1 $$\n分子 $N$ 为：\n$$ N = -\\sqrt{6}(\\sqrt{2} - \\sqrt{3}) - 2\\sqrt{3}(1+\\sqrt{3}) + 3\\sqrt{2}(1+\\sqrt{2}) $$\n$$ N = (-\\sqrt{12} + \\sqrt{18}) - (2\\sqrt{3} + 6) + (3\\sqrt{2} + 6) $$\n$$ N = -2\\sqrt{3} + 3\\sqrt{2} - 2\\sqrt{3} - 6 + 3\\sqrt{2} + 6 = 6\\sqrt{2} - 4\\sqrt{3} $$\n因此，我们得到：\n$$ x_3 = \\frac{N}{D} = \\frac{6\\sqrt{2} - 4\\sqrt{3}}{\\sqrt{3} - 2\\sqrt{2} - 1} $$\n为了使分母有理化，我们将其分组为 $(\\sqrt{3}-1) - 2\\sqrt{2}$，然后将分子和分母同乘以其共轭式 $(\\sqrt{3}-1) + 2\\sqrt{2}$：\n$$ D_{\\text{rationalized}} = ((\\sqrt{3}-1) - 2\\sqrt{2})((\\sqrt{3}-1) + 2\\sqrt{2}) = (\\sqrt{3}-1)^2 - (2\\sqrt{2})^2 = (3 - 2\\sqrt{3} + 1) - 8 = -4 - 2\\sqrt{3} = -2(2+\\sqrt{3}) $$\n$$ N_{\\text{rationalized}} = (6\\sqrt{2} - 4\\sqrt{3})((\\sqrt{3}-1) + 2\\sqrt{2}) = (6\\sqrt{6} - 6\\sqrt{2} - 12 + 4\\sqrt{3}) + (24 - 8\\sqrt{6}) = 12 - 6\\sqrt{2} + 4\\sqrt{3} - 2\\sqrt{6} $$\n所以，\n$$ x_3 = \\frac{12 - 6\\sqrt{2} + 4\\sqrt{3} - 2\\sqrt{6}}{-2(2+\\sqrt{3})} = -\\frac{6 - 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6}}{2+\\sqrt{3}} $$\n最后，我们通过将分子和分母同乘以 $(2 - \\sqrt{3})$ 来对剩余的分母进行有理化：\n$$ \\text{Denominator} = (2+\\sqrt{3})(2-\\sqrt{3}) = 4-3 = 1 $$\n$$ \\text{Numerator} = -(6 - 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6})(2 - \\sqrt{3}) $$\n$$ = -[ (12 - 6\\sqrt{3}) - (6\\sqrt{2} - 3\\sqrt{6}) + (4\\sqrt{3} - 6) - (2\\sqrt{6} - \\sqrt{18}) ] $$\n$$ = -[ 12 - 6\\sqrt{3} - 6\\sqrt{2} + 3\\sqrt{6} + 4\\sqrt{3} - 6 - 2\\sqrt{6} + 3\\sqrt{2} ] $$\n合并括号内的项：\n$$ (12-6) + (-6\\sqrt{2}+3\\sqrt{2}) + (-6\\sqrt{3}+4\\sqrt{3}) + (3\\sqrt{6}-2\\sqrt{6}) = 6 - 3\\sqrt{2} - 2\\sqrt{3} + \\sqrt{6} $$\n$x_3$ 的最终表达式是这个量的相反数：\n$$ x_3 = -(6 - 3\\sqrt{2} - 2\\sqrt{3} + \\sqrt{6}) = -6 + 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6} $$\n这就是通过逆二次插值得到的第一个迭代值 $x_3$。", "answer": "$$ \\boxed{-6 + 3\\sqrt{2} + 2\\sqrt{3} - \\sqrt{6}} $$", "id": "3244092"}, {"introduction": "在掌握了单步计算之后，下一步自然是将其自动化，并观察该方法的实际动态表现。本练习将指导你用代码完整地实现 IQI 迭代算法，其中还包括为保证算法稳健性所必需的回退机制 [@problem_id:3243989]。为了让你体会其效率，你将把它与经典的不动点迭代法在求解一个典型非线性方程时的性能进行比较，从而直观地认识到 IQI 的快速收敛特性。", "problem": "考虑标量非线性方程 $f(x)=0$，其中 $f(x)=x-\\exp(-x)$。该方程有唯一的实数解，因为 $f(x)$ 在 $\\mathbb{R}$ 上是连续且严格递增的，并且 $\\lim_{x\\to-\\infty}f(x)=-\\infty$ 和 $\\lim_{x\\to+\\infty}f(x)=+\\infty$。目标是为此方程构建并比较两种无导数求解器：逆二次插值和不动点迭代。\n\n您必须从插值和不动点迭代的核心定义出发，根据第一性原理推导并实现以下两种迭代方法：\n\n1. 逆二次插值 (IQI)：给定三个不同的迭代点 $x_0$、$x_1$ 和 $x_2$ 及其对应的函数值 $f(x_0)$、$f(x_1)$ 和 $f(x_2)$，构建一个关于变量 $y$ 的唯一二次多项式，该多项式对反函数关系进行插值，即多项式 $Q(y)$ 满足 $Q(f(x_i))=x_i$ (其中 $i\\in\\{0,1,2\\}$)。使用这个插值函数，通过在 $y=0$ 处求值来产生下一个迭代点，即 $x_{\\text{new}}=Q(0)$。为了避免在构造过程是病态时（例如，任何一对 $f(x_i)$ 值几乎相等，导致插值公式中的分母变得极小）出现数值不稳定性，您的实现必须能检测到此类情况，并回退到使用最近的两个迭代点计算的割线法更新，前提是它们的函数值差异足够大。如果由于函数值几乎相等而连割线法更新都不可行，则在该步骤中必须保持当前迭代点不变。\n\n2. 不动点迭代：将方程改写为不动点形式 $x=g(x)$，其中 $g(x)=\\exp(-x)$。从一个初始猜测值 $x_0$ 开始，迭代 $x_{k+1}=g(x_k)$ 直至收敛。这是一种无导数的方法，仅使用 $g(x)$ 的函数求值。\n\n对于这两种方法，请使用相同的收敛逻辑。定义函数绝对容差 $\\varepsilon_f=10^{-12}$ 和步长容差 $\\varepsilon_x=10^{-12}$。如果满足 $|f(x_k)|\\le \\varepsilon_f$ 或 $|x_k-x_{k-1}|\\le \\varepsilon_x$（对于 $k\\ge 1$），则认为迭代点 $x_k$ 已收敛。设置最大迭代次数为 $N_{\\max}=1000$。计算直到首次满足停止准则时实际执行的迭代次数；如果达到最大迭代次数仍未满足准则，则报告最后的迭代点和迭代次数 $N_{\\max}$。\n\n您的程序必须实现这两种求解器，并将其应用于下面的测试套件。对于每个测试用例，使用指定的三个初始点 $(x_0,x_1,x_2)$ 运行IQI，并使用指定的初始点 $x_0$ 运行不动点迭代。对于每种方法和每个测试用例，返回最终的近似根和所用的迭代次数。\n\n测试套件：\n- 案例 1：IQI 使用 $(x_0,x_1,x_2)=(0.0,1.0,0.5)$，不动点迭代使用 $x_0=0.0$。\n- 案例 2：IQI 使用 $(x_0,x_1,x_2)=(0.55,0.57,0.60)$，不动点迭代使用 $x_0=0.55$。\n- 案例 3：IQI 使用 $(x_0,x_1,x_2)=(-2.0,2.0,3.0)$，不动点迭代使用 $x_0=3.0$。\n- 案例 4：IQI 使用 $(x_0,x_1,x_2)=(0.56,0.565,0.57)$，不动点迭代使用 $x_0=0.56$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每个案例，按此严格顺序附加四个条目：\n- IQI 的最终根近似值，四舍五入到 $12$ 位小数。\n- IQI 的迭代次数，为整数。\n- 不动点迭代的最终根近似值，四舍五入到 $12$ 位小数。\n- 不动点迭代的迭代次数，为整数。\n\n因此，最终输出是一个包含 $16$ 个条目的单一列表，按案例 1 到 4 的顺序排列，每个案例贡献其四个条目，例如 $[x^{\\text{IQI}}_1,n^{\\text{IQI}}_1,x^{\\text{FP}}_1,n^{\\text{FP}}_1,\\dots,x^{\\text{IQI}}_4,n^{\\text{IQI}}_4,x^{\\text{FP}}_4,n^{\\text{FP}}_4]$。\n\n此问题不涉及任何物理单位或角度单位；所有量均为实标量。数值容差 $\\varepsilon_f$ 和 $\\varepsilon_x$ 分别是关于 $f(x)$ 和步长的绝对容差。程序必须是自包含的，并且不得需要任何用户输入或外部文件。", "solution": "该问题要求推导、实现并比较两种无导数数值方法——逆二次插值（IQI）和不动点迭代——用于求解非线性方程 $f(x) = x - \\exp(-x) = 0$ 的唯一实根。\n\n### **函数与根的分析**\n函数为 $f(x) = x - e^{-x}$。它对所有 $x \\in \\mathbb{R}$ 都是连续且可微的函数。其导数为 $f'(x) = 1 + e^{-x}$。由于对于所有实数 $x$，$e^{-x} > 0$，我们有 $f'(x) > 1$，这意味着 $f(x)$ 是严格单调递增的。此外，$\\lim_{x\\to-\\infty} f(x) = -\\infty$ 且 $\\lim_{x\\to\\infty} f(x) = +\\infty$。根据介值定理，必定存在一个唯一的实根 $\\alpha$ 使得 $f(\\alpha)=0$。这个根是方程 $\\alpha = e^{-\\alpha}$ 的解，由朗伯W函数（Lambert W function）给出，$\\alpha = W(1) \\approx 0.56714329041$。\n\n### **方法一：逆二次插值 (IQI)**\n\n#### **从第一性原理推导**\n逆二次插值是一种求根算法，它使用三个先前的迭代点来构建*反*函数的二次模型，然后使用此模型来估计根。设三个不同的点为 $(x_0, y_0)$、$(x_1, y_1)$ 和 $(x_2, y_2)$，其中 $y_i = f(x_i)$。我们寻求一个二次多项式 $Q(y)$，使得 $Q(y_i) = x_i$ 对 $i \\in \\{0, 1, 2\\}$ 成立。这是一个标准的插值问题。唯一的二次插值多项式可以使用拉格朗日基多项式表示：\n$$\nQ(y) = x_0 \\frac{(y-y_1)(y-y_2)}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{(y-y_0)(y-y_2)}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{(y-y_0)(y-y_1)}{(y_2-y_0)(y_2-y_1)}\n$$\n原始函数 $f(x)$ 的根对应于其反函数 $x=f^{-1}(y)$ 在 $y=0$ 处的值。我们通过在 $y=0$ 处计算我们的插值函数 $Q(y)$ 来近似这个值。这给出了下一个迭代点 $x_{\\text{new}}$：\n$$\nx_{\\text{new}} = Q(0) = x_0 \\frac{(-y_1)(-y_2)}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{(-y_0)(-y_2)}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{(-y_0)(-y_1)}{(y_2-y_0)(y_2-y_1)}\n$$\n简化此表达式可得到IQI的更新公式：\n$$\nx_{\\text{new}} = x_0 \\frac{y_1 y_2}{(y_0-y_1)(y_0-y_2)} + x_1 \\frac{y_0 y_2}{(y_1-y_0)(y_1-y_2)} + x_2 \\frac{y_0 y_1}{(y_2-y_0)(y_2-y_1)}\n$$\n此公式要求函数值 $y_0, y_1, y_2$ 是互不相同的，否则分母会变为零。\n\n#### **算法设计与回退策略**\n迭代过程从三个初始点 $(x_a, x_b, x_c)$ 及其函数值 $(y_a, y_b, y_c)$ 开始。在每次迭代中，计算一个新的点 $x_{\\text{new}}$，并丢弃最旧的点。下一次迭代的点集变为 $(x_b, x_c, x_{\\text{new}})$。\n\n一个稳健的IQI实现的关键部分是处理方法病态的情况，这种情况发生在任意两个函数值 $(y_a, y_b, y_c)$ 几乎相等时。问题指定了一种回退策略：\n1.  **尝试IQI**：使用上述公式计算 $x_{\\text{new}}$。只有当函数值 $y_a$、$y_b$ 和 $y_c$ 足够不同时才执行此操作。在数值上，我们检查对于所有 $i \\neq j$， $|y_i - y_j|$ 是否大于一个小的容差。\n2.  **回退到割线法**：如果IQI更新不稳定（即函数值不唯一），算法将回退到使用最近的两个点 $(x_b, y_b)$ 和 $(x_c, y_c)$ 的割线法。下一个迭代点的割线法公式为：\n    $$\n    x_{\\text{new}} = x_c - y_c \\frac{x_c - x_b}{y_c - y_b}\n    $$\n    仅当 $y_c$ 和 $y_b$ 足够不同时才执行此操作。\n3.  **二次回退（保留迭代点）**：如果IQI和割线法都不稳定（因为 $y_b \\approx y_c$），算法不计算新点，而只是将最近的迭代点向前传递：$x_{\\text{new}} = x_c$。这可以防止除以一个接近零的数，并保持稳定性。\n\n### **方法二：不动点迭代**\n\n#### **从第一性原理推导**\n不动点迭代是寻找方程 $f(x)=0$ 的根的一种方法，通过将其重新排列成 $x=g(x)$ 的形式。该方程的解是函数 $g$ 的一个“不动点”。给定一个初始猜测值 $x_0$，该方法使用递推关系 $x_{k+1} = g(x_k)$ 生成一个迭代序列。\n\n对于给定的方程 $f(x) = x - e^{-x} = 0$，一个自然的重排是：\n$$\nx = e^{-x}\n$$\n这给出了迭代函数 $g(x) = e^{-x}$。因此，迭代格式为：\n$$\nx_{k+1} = g(x_k) = \\exp(-x_k)\n$$\n该方法的收敛性由压缩映射定理决定。如果在一个区间内对所有 $x$ 都有 $|g'(x)|  1$，则保证迭代收敛到该区间内唯一的不动点。对于我们的问题，$g'(x) = -e^{-x}$。根 $\\alpha \\approx 0.56714$ 位于区间 $[0, 1]$ 内。在此区间上，$|g'(x)| = e^{-x} \\le e^0 = 1$。在根处，$|g'(\\alpha)| = e^{-\\alpha} = \\alpha  1$。收敛条件 $|g'(x)|  1$ 意味着 $e^{-x}  1$，即 $x > 0$。因此，对于任何初始猜测值 $x_0 > 0$，该方法都将收敛。例如，对于 $x_0 \\ge 0$，所有后续的迭代点都将保持非负，并且方法将收敛到正根。\n\n#### **算法设计**\n该算法从一个初始值 $x_0$ 开始。然后迭代计算 $x_1 = g(x_0)$、$x_2=g(x_1)$，依此类推，直到满足停止准则。\n\n### **收敛与终止**\n两种方法使用相同的终止准则。对于给定的容差 $\\varepsilon_f = 10^{-12}$ 和 $\\varepsilon_x = 10^{-12}$，如果满足以下任一条件，则迭代点 $x_k$ 被认为是收敛解：\n1.  **函数值容差**：残差接近于零：$|f(x_k)| \\leq \\varepsilon_f$。\n2.  **步长容差**：连续迭代点之间的变化很小：$|x_k - x_{k-1}| \\leq \\varepsilon_x$（对于 $k \\ge 1$）。\n\n如果在最多 $N_{\\max} = 1000$ 次迭代后仍未达到收敛，则过程终止，并返回最后计算的迭代点。迭代次数是生成的新点的计数。如果在计算任何新点之前初始猜测值就满足准则，则对应于 $0$ 次迭代。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares Inverse Quadratic Interpolation and Fixed-Point Iteration\n    for solving the nonlinear equation f(x) = x - exp(-x) = 0.\n    \"\"\"\n    \n    # Define the primary function f(x) and the fixed-point function g(x)\n    def f(x):\n        return x - np.exp(-x)\n\n    def g(x):\n        return np.exp(-x)\n\n    # Set common parameters for the solvers\n    EPS_F = 1e-12\n    EPS_X = 1e-12\n    N_MAX = 1000\n    DENOM_TOL = 1e-20 # A small tolerance for checking denominators\n\n    def iqi_solver(x0, x1, x2):\n        \"\"\"\n        Solves f(x) = 0 using Inverse Quadratic Interpolation with fallback.\n        \n        Args:\n            x0, x1, x2 (float): Three initial distinct guesses for the root.\n            \n        Returns:\n            tuple: (final root approximation, number of iterations).\n        \"\"\"\n        xa, xb, xc = x0, x1, x2\n\n        # Check initial points for convergence before starting iterations\n        # The prompt implies that n=0 if one of the initial points is the solution.\n        # Check the 'most recent' point x2 first.\n        if abs(f(xc)) = EPS_F or abs(xc - xb) = EPS_X:\n            return xc, 0\n\n        for n in range(1, N_MAX + 1):\n            ya, yb, yc = f(xa), f(xb), f(xc)\n\n            # Check for ill-conditioning: if any f-values are too close\n            if abs(ya - yb)  DENOM_TOL or abs(ya - yc)  DENOM_TOL or abs(yb - yc)  DENOM_TOL:\n                # IQI fails, fallback to secant method on the two most recent points\n                if abs(yc - yb)  DENOM_TOL:\n                    # Secant method also fails, retain the current iterate\n                    x_new = xc\n                else:\n                    x_new = xc - yc * (xc - xb) / (yc - yb)\n            else:\n                # IQI update formula derived from Lagrange interpolation Q(0)\n                term0 = xa * yb * yc / ((ya - yb) * (ya - yc))\n                term1 = xb * ya * yc / ((yb - ya) * (yb - yc))\n                term2 = xc * ya * yb / ((yc - ya) * (yc - yb))\n                x_new = term0 + term1 + term2\n\n            # Update points for the next iteration\n            xa, xb, xc = xb, xc, x_new\n\n            # Check for convergence on the newly computed point\n            if abs(f(xc)) = EPS_F or abs(xc - xb) = EPS_X:\n                return xc, n\n\n        return xc, N_MAX\n\n    def fp_solver(x0):\n        \"\"\"\n        Solves f(x) = 0 using Fixed-Point Iteration.\n        \n        Args:\n            x0 (float): Initial guess for the root.\n            \n        Returns:\n            tuple: (final root approximation, number of iterations).\n        \"\"\"\n        x_prev = x0\n        \n        # Check if the initial guess is already the solution\n        if abs(f(x_prev)) = EPS_F:\n            return x_prev, 0\n\n        for n in range(1, N_MAX + 1):\n            x_curr = g(x_prev)\n            \n            # Check for convergence\n            if abs(f(x_curr)) = EPS_F or abs(x_curr - x_prev) = EPS_X:\n                return x_curr, n\n            \n            x_prev = x_curr\n        \n        return x_curr, N_MAX\n\n    # Define the test cases from the problem statement\n    test_cases = [\n        # Case 1\n        {'iqi_initial': (0.0, 1.0, 0.5), 'fp_initial': 0.0},\n        # Case 2\n        {'iqi_initial': (0.55, 0.57, 0.60), 'fp_initial': 0.55},\n        # Case 3\n        {'iqi_initial': (-2.0, 2.0, 3.0), 'fp_initial': 3.0},\n        # Case 4\n        {'iqi_initial': (0.56, 0.565, 0.57), 'fp_initial': 0.56},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Run IQI solver\n        iqi_root, iqi_iters = iqi_solver(*case['iqi_initial'])\n        results.append(f\"{iqi_root:.12f}\")\n        results.append(str(iqi_iters))\n\n        # Run Fixed-Point solver\n        fp_root, fp_iters = fp_solver(case['fp_initial'])\n        results.append(f\"{fp_root:.12f}\")\n        results.append(str(fp_iters))\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3243989"}, {"introduction": "一个强大的算法，其可靠性取决于其实现的稳定性。最后的这个练习将探讨数值计算中至关重要的稳定性概念，并为你呈现一个标准 IQI 公式因浮点误差而失效的典型场景 [@problem_id:3244093]。你将需要推导并实现一个代数上等价但数值上更优越的公式，从中学习如何编写能够避免灾难性抵消的高质量科学计算代码。", "problem": "考虑使用三个先前计算的点，通过单步逆二次插值来计算标量函数的单根位置的任务。逆二次插值基于三个数据对 $(x_0,f_0)$, $(x_1,f_1)$, 和 $(x_2,f_2)$（其中 $f_i = f(x_i)$）为逆映射 $x(f)$ 构建一个二次多项式，然后通过计算该多项式在 $f=0$ 处的值来估计根。该问题的基础是使用 Lagrange 形式或 Newton 形式表示的函数的多项式插值定义，以及 Lagrange 基函数之和为一的事实。您必须从这些经过充分检验的事实和定义出发，自行推导所需的任何工作公式。\n\n您的程序必须实现逆二次插值步骤的两个版本，以根据 $(x_0,f_0)$、$(x_1,f_1)$、$(x_2,f_2)$ 计算根的估计值 $\\hat{x}$：\n\n- 一个基于 $x(f)$ 在 $f=0$ 处的二阶插值多项式的标准构造的直接求值方法，已知当函数值彼此非常接近时，该方法容易受到浮点抵消的影响。\n\n- 一个您从第一性原理推导出的重排求值方法，利用 $x(f)$ 的 Lagrange 基函数之和为一的性质，以减少在组合大的、几乎相反的项时发生的灾难性抵消。\n\n您必须通过一个科学上合理的场景来证明，标准公式会因浮点抵消而出现数值计算失败，而重排后的公式能提高数值稳定性。所有算术运算都应遵循美国电气和电子工程师协会（Institute of Electrical and Electronics Engineers）的浮点标准（IEEE 754），以双精度进行。\n\n为以下测试套件实现这两个版本。在所有情况下，未知的精确根为 $r=0$，需要报告的误差是绝对误差 $|\\hat{x}-r|$，以浮点数形式表示：\n\n- 测试用例 $1$（在小偏移量附近易于发生抵消的点簇）：设 $f(x)=x^3$。选择 $a=1\\times 10^{-8}$ 和 $h=1\\times 10^{-16}$。设置 $x_0=a$，$x_1=a+h$，$x_2=a-h$，并定义 $f_i=f(x_i)$。此配置使得 $f_0$、$f_1$ 和 $f_2$ 极其接近，应当会在直接求值中引发浮点抵消。\n\n- 测试用例 $2$（良态线性映射）：设 $f(x)=x$。设置 $x_0=-1$，$x_1=0.3$，$x_2=2$，并定义 $f_i=f(x_i)$。此配置应表现良好，并生成准确的估计值，不会出现抵消问题。\n\n- 测试用例 $3$（一个点靠近根）：设 $f(x)=x^3$。设置 $x_0=-1\\times 10^{-6}$，$x_1=1\\times 10^{-6}$，$x_2=1\\times 10^{-12}$，并定义 $f_i=f(x_i)$。此配置将一个函数值置于非常接近零的位置。\n\n对于每个测试用例，计算：\n- 直接求值的绝对误差，$E_{\\text{direct}}=|\\hat{x}_{\\text{direct}}-r|$。\n- 重排求值的绝对误差，$E_{\\text{rearr}}=|\\hat{x}_{\\text{rearr}}-r|$。\n\n您的程序应生成单行输出，其中包含三个测试用例的六个浮点数结果，按顺序排列在一个用方括号括起来的逗号分隔列表中：\n$[E_{\\text{direct},1},E_{\\text{rearr},1},E_{\\text{direct},2},E_{\\text{rearr},2},E_{\\text{direct},3},E_{\\text{rearr},3}]$。", "solution": "该问题要求实现并比较用于单步逆二次插值的两个公式。目标是在给定三个点 $(x_0, f_0), (x_1, f_1), (x_2, f_2)$（其中 $f_i = f(x_i)$）的情况下，为函数 $f(x)$ 的根找到一个估计值 $\\hat{x}$。根的估计值是通过构建一个穿过三个点 $(f_i, x_i)$ 的二次多项式 $x(f)$，并计算其在 $f=0$ 处的值来找到的。\n\n分析将分两步进行：\n1.  推导所需的两个公式：一个“直接”公式和一个“重排”公式。\n2.  在提供的测试用例上实现并评估这些公式。\n\n### 插值公式的推导\n\n设给定的三个数据点为 $(f_0, x_0)$、$(f_1, x_1)$ 和 $(f_2, x_2)$。我们寻求穿过这些点的唯一二次多项式 $x(f)$ 在 $x(0)$ 处的值。\n\n#### 1. 直接求值公式\n\n插值多项式的标准构造形式是 Lagrange 形式。多项式 $x(f)$ 由下式给出：\n$$\nx(f) = x_0 L_0(f) + x_1 L_1(f) + x_2 L_2(f)\n$$\n其中 $L_i(f)$ 是 Lagrange 基多项式：\n$$\nL_0(f) = \\frac{(f - f_1)(f - f_2)}{(f_0 - f_1)(f_0 - f_2)}, \\quad\nL_1(f) = \\frac{(f - f_0)(f - f_2)}{(f_1 - f_0)(f_1 - f_2)}, \\quad\nL_2(f) = \\frac{(f - f_0)(f - f_1)}{(f_2 - f_0)(f_2 - f_1)}\n$$\n根的估计值 $\\hat{x}$ 是通过计算 $x(f)$ 在 $f=0$ 处的值得到的：\n$$\n\\hat{x} = x(0) = x_0 L_0(0) + x_1 L_1(0) + x_2 L_2(0)\n$$\n将 $f=0$ 代入基多项式可得：\n$$\nL_0(0) = \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)}, \\quad\nL_1(0) = \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)}, \\quad\nL_2(0) = \\frac{f_0 f_1}{(f_2 - f_0)(f_2 - f_1)}\n$$\n这导出了直接求值公式：\n$$\n\\hat{x}_{\\text{direct}} = x_0 \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)} + x_1 \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)} + x_2 \\frac{f_0 f_1}{(f_2 - f_0)(f_2 - f_1)}\n$$\n当函数值 $f_0, f_1, f_2$ 彼此接近但均不接近于零时，该公式在数值上是不稳定的。在这种情况下，分母 $(f_i - f_j)$ 会变得很小，导致各项的值变得很大。最终的估计值 $\\hat{x}$（本应接近 $x_i$ 的值）是通过对这些大的、几乎相互抵消的项求和来计算的，这个过程被称为灾难性抵消，可能导致精度的严重损失。\n\n#### 2. 重排求值公式\n\n问题指出，可以利用 Lagrange 基多项式之和为一的性质推导出更稳定的公式：\n$$\n\\sum_{i=0}^{2} L_i(f) = 1\n$$\n此恒等式对任何 $f$ 值都成立，包括 $f=0$。我们可以用它来将估计值 $\\hat{x}$ 表示为对某个初始点（例如 $x_2$）的修正。我们写出：\n$$\n\\hat{x} = x_2 + (\\hat{x} - x_2)\n$$\n利用求和性质，我们可以写出 $x_2 = x_2 \\cdot 1 = x_2 \\sum_{i=0}^{2} L_i(0)$。将此式和 $\\hat{x}$ 的 Lagrange 公式代入：\n$$\n\\hat{x} - x_2 = \\left( \\sum_{i=0}^{2} x_i L_i(0) \\right) - \\left( x_2 \\sum_{i=0}^{2} L_i(0) \\right)\n$$\n$$\n\\hat{x} - x_2 = \\sum_{i=0}^{2} (x_i - x_2) L_i(0) = (x_0 - x_2)L_0(0) + (x_1 - x_2)L_1(0) + (x_2 - x_2)L_2(0)\n$$\n$i=2$ 的项消失，留下修正项的公式：\n$$\n\\hat{x} - x_2 = (x_0 - x_2)L_0(0) + (x_1 - x_2)L_1(0)\n$$\n这给出了重排求值公式：\n$$\n\\hat{x}_{\\text{rearr}} = x_2 + (x_0 - x_2) \\frac{f_1 f_2}{(f_0 - f_1)(f_0 - f_2)} + (x_1 - x_2) \\frac{f_0 f_2}{(f_1 - f_0)(f_1 - f_2)}\n$$\n该公式将估计值计算为一个基准值 $x_2$ 加上一个修正量。虽然它在代数上与直接公式等价，但其数值特性可能有所不同。在计算修正项时，仍然存在几乎相等的 $x_i$ 和 $f_i$ 值相减的情况。然而，这种形式以不同的方式构造计算。在 $x_i$ 点聚集的情况下，$(x_i - x_2)$ 项很小，该公式通过将一个可能很小的修正量加到初始猜测值 $x_2$ 上来计算最终结果。这可能比直接公式中对三个可能很大的、不相关的项求和更具鲁棒性。\n\n### 实现与数值验证\n\n将实现这两个公式 $\\hat{x}_{\\text{direct}}$ 和 $\\hat{x}_{\\text{rearr}}$，并使用提供的测试套件进行测试。所有计算均采用标准的双精度浮点算术（IEEE 754）进行。对于所有测试用例，真实根为 $r=0$，因此绝对误差就是 $|\\hat{x}|$。\n\n测试用例如下：\n*   **测试用例 1（易于发生抵消的点簇）：** $f(x)=x^3$，其中 $x_0=a$，$x_1=a+h$，$x_2=a-h$，且 $a=1\\times 10^{-8}$，$h=1\\times 10^{-16}$。函数值 $f_i$ 极其接近，为灾难性抵消提供了条件。\n*   **测试用例 2（良态）：** $f(x)=x$，其中 $x_0=-1$，$x_1=0.3$，$x_2=2$。对于线性函数，插值是精确的，两个公式都应得出正确的根 $\\hat{x}=0$（在机器精度范围内）。\n*   **测试用例 3（一个点靠近根）：** $f(x)=x^3$，其中 $x_0=-1\\times 10^{-6}$，$x_1=1\\times 10^{-6}$，$x_2=1\\times 10^{-12}$。此处，一个点 $(x_2, f_2)$ 极其接近根 $(0,0)$。重排公式是作为对 $x_2$ 的修正而构建的，预期会表现得非常好。\n\n这些计算的结果将展示两种公式在数值稳定性上的差异。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef direct_evaluation(x0, x1, x2, f0, f1, f2):\n    \"\"\"\n    Computes the root estimate using the direct evaluation of the\n    Lagrange interpolation formula at f=0.\n    \"\"\"\n    # Check for non-distinct function values which would lead to division by zero.\n    if f0 == f1 or f0 == f2 or f1 == f2:\n        # This case is ill-defined for quadratic interpolation.\n        # In a real root-finder, one would fall back to a different method.\n        # For this problem's test cases, it indicates an issue if it occurs.\n        return np.nan\n\n    # Lagrange basis polynomials L_i(f) evaluated at f=0\n    term0 = x0 * f1 * f2 / ((f0 - f1) * (f0 - f2))\n    term1 = x1 * f0 * f2 / ((f1 - f0) * (f1 - f2))\n    term2 = x2 * f0 * f1 / ((f2 - f0) * (f2 - f1))\n    \n    return term0 + term1 + term2\n\ndef rearranged_evaluation(x0, x1, x2, f0, f1, f2):\n    \"\"\"\n    Computes the root estimate using the rearranged formula, derived\n    from the fact that the sum of Lagrange basis polynomials is 1.\n    \"\"\"\n    # Check for non-distinct function values.\n    if f0 == f1 or f0 == f2 or f1 == f2:\n        return np.nan\n\n    # Lagrange basis polynomials L_0(f) and L_1(f) evaluated at f=0\n    L0_at_0 = f1 * f2 / ((f0 - f1) * (f0 - f2))\n    L1_at_0 = f0 * f2 / ((f1 - f0) * (f1 - f2))\n    \n    # Correction term added to the base point x2\n    correction = (x0 - x2) * L0_at_0 + (x1 - x2) * L1_at_0\n    \n    return x2 + correction\n\ndef solve():\n    \"\"\"\n    Executes the inverse quadratic interpolation for the test suite\n    and prints the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1: Cancellation-prone cluster\n        {\n            \"f\": lambda x: x**3,\n            \"x_coords\": (1e-8, 1e-8 + 1e-16, 1e-8 - 1e-16),\n            \"root\": 0.0\n        },\n        # Test case 2: Well-conditioned linear mapping\n        {\n            \"f\": lambda x: x,\n            \"x_coords\": (-1.0, 0.3, 2.0),\n            \"root\": 0.0\n        },\n        # Test case 3: One point near the root\n        {\n            \"f\": lambda x: x**3,\n            \"x_coords\": (-1e-6, 1e-6, 1e-12),\n            \"root\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        func = case[\"f\"]\n        x0, x1, x2 = case[\"x_coords\"]\n        r = case[\"root\"]\n\n        # All computations use standard Python floats (IEEE 754 double precision)\n        f0 = func(x0)\n        f1 = func(x1)\n        f2 = func(x2)\n\n        # Calculate estimate using the direct formula\n        x_hat_direct = direct_evaluation(x0, x1, x2, f0, f1, f2)\n        error_direct = abs(x_hat_direct - r)\n        results.append(error_direct)\n\n        # Calculate estimate using the rearranged formula\n        x_hat_rearranged = rearranged_evaluation(x0, x1, x2, f0, f1, f2)\n        error_rearranged = abs(x_hat_rearranged - r)\n        results.append(error_rearranged)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244093"}]}