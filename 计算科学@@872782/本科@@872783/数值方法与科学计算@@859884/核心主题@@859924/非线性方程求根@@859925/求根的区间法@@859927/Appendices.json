{"hands_on_practices": [{"introduction": "理解不同求根方法之间的差异与学习这些方法本身同样重要。本练习 [@problem_id:2157489] 要求您直接对二分法和试位法的首次近似值进行定量比较，从而深入了解它们在逼近根时采用的不同策略。通过计算第一步的误差，您可以直观地感受到哪种方法在特定情况下收敛得更快。", "problem": "考虑在区间 $[1, 2]$ 内为函数 $f(x) = x^3 - 5$ 寻找一个根的任务。\n\n完成此任务的两种常用迭代求根区间法是二分法和试位法（也称为伪位置法）。\n\n令 $c_B$ 为对初始区间 $[1, 2]$ 应用一次二分法迭代所得到的根的首次近似值。\n令 $c_{RF}$ 为对相同的初始区间 $[1, 2]$ 应用一次试位法迭代所得到的根的首次近似值。\n\n该函数的真根是 $x_{true} = \\sqrt[3]{5}$。为方便本题计算，您可以使用近似值 $x_{true} \\approx 1.709976$。\n\n计算这两种方法的近似误差之间的绝对差。也就是说，计算 $| |c_B - x_{true}| - |c_{RF} - x_{true}| |$ 的值。将您的最终答案保留四位有效数字。", "solution": "给定函数 $f(x) = x^{3} - 5$ 在区间 $[1,2]$ 上，且有 $f(1) = -4$ 和 $f(2) = 3$，因此根位于区间 $[1,2]$ 内。\n\n对于一步二分法迭代，中点是\n$$\nc_{B} = \\frac{1 + 2}{2} = \\frac{3}{2}.\n$$\n\n对于从 $(a,f(a)) = (1,-4)$ 和 $(b,f(b)) = (2,3)$ 开始的一步试位法迭代，线性插值求得的根是\n$$\nc_{RF} = a - f(a)\\,\\frac{b - a}{f(b) - f(a)} = 1 - (-4)\\,\\frac{2 - 1}{3 - (-4)} = 1 + \\frac{4}{7} = \\frac{11}{7}.\n$$\n\n由于函数 $f$ 在 $[1,2]$ 上是严格单调递增的，且 $x_{true} \\in [1,2]$，我们有 $c_{B}  x_{true}$ 和 $c_{RF}  x_{true}$，因此\n$$\n|c_{B} - x_{true}| = x_{true} - \\frac{3}{2}, \\quad |c_{RF} - x_{true}| = x_{true} - \\frac{11}{7}.\n$$\n所以，误差的绝对差为\n$$\n\\left||c_{B} - x_{true}| - |c_{RF} - x_{true}|\\right| = \\left|(x_{true} - \\tfrac{3}{2}) - (x_{true} - \\tfrac{11}{7})\\right| = \\left|\\frac{11}{7} - \\frac{3}{2}\\right| = \\left|\\frac{22 - 21}{14}\\right| = \\frac{1}{14}.\n$$\n\n从数值上计算，\n$$\n\\frac{1}{14} \\approx 0.071428571\\ldots,\n$$\n保留四位有效数字后为 $0.07143$。", "answer": "$$\\boxed{0.07143}$$", "id": "2157489"}, {"introduction": "一个稳健的数值方法是否能成功运行，往往取决于其前提条件是否得到满足。本练习 [@problem_id:2157544] 是一个思想实验，旨在检验您对二分法核心要求（即区间两端函数值异号）的理解。它探讨了当这一关键条件不满足时，机械地应用该算法会产生什么出人意料的结果，从而加深您对算法适用边界的认识。", "problem": "一名学生被要求寻找一个函数 $f(x)$ 的根，已知该函数在整个实数轴上是连续的。该学生还被告知 $f(x)$ 是一个偶函数，即对所有 $x$ 都有 $f(x) = f(-x)$。\n\n该学生决定应用二分法，从对称区间 $[-k, k]$ 开始，其中 $k$ 为某个正常数。他们计算了函数在区间端点处的值，发现 $f(k)$ 不为零。该学生观察到，在区间 $[a, b]$ 上应用二分法的标准先决条件 $f(a)f(b)  0$ 对他们选择的区间不成立。\n\n尽管如此，他们决定继续进行二分法的第一次迭代的推测性、机械性应用，看看会发生什么。选择下一个区间的算法如下：\n1. 计算中点 $c = (a+b)/2$。\n2. 如果 $f(c) = 0$，则找到了根。\n3. 如果 $f(a)f(c)  0$，新区间为 $[a, c]$。\n4. 如果 $f(c)f(b)  0$，新区间为 $[c, b]$。\n\n假设第一个中点不是根（即 $f(0) \\ne 0$），以下哪个陈述最准确地描述了这第一次迭代的结果？\n\nA. 第一个中点是 $c_1 = 0$，且无论 $f(0)$ 的值是多少，算法都会选择 $[-k, 0]$ 作为下一个搜索区间。\n\nB. 第一个中点是 $c_1 = 0$，且无论 $f(0)$ 的值是多少，算法都会选择 $[0, k]$ 作为下一个搜索区间。\n\nC. 第一个中点是 $c_1 = 0$。然而，选择下一个区间的标准要么同时被两个可能的子区间满足，要么两个都不满足，这使得基于该方法的核心原则的选择变得模棱两可或不可能。\n\nD. 下一个区间的计算失败，因为初始端点 $f(-k)$ 和 $f(k)$ 的符号相同，导致更新步骤中出现除以零的情况。\n\nE. 不知道具体函数 $f(x)$ 就无法确定第一个中点。", "solution": "给定一个在 $\\mathbb{R}$ 上的连续偶函数 $f$，因此对所有 $x$ 都有 $f(x)=f(-x)$。学生从对称区间 $[a,b]=[-k,k]$ 开始，其中 $k0$ 且 $f(k)\\neq 0$。因为 $f$ 是偶函数，我们有\n$$\nf(-k)=f(k).\n$$\n标准的二分法先决条件 $f(a)f(b)0$ 变为\n$$\nf(-k)f(k)=f(k)^{2}0,\n$$\n因此该条件不满足。\n\n机械地进行二分法的第一步迭代：\n1. 中点是\n$$\nc=\\frac{a+b}{2}=\\frac{-k+k}{2}=0.\n$$\n2. 题目告知 $f(0)\\neq 0$，所以中点不是根。\n3. 选择左子区间的检验条件是\n$$\nf(a)f(c)0 \\quad \\Longleftrightarrow \\quad f(-k)f(0)0 \\quad \\Longleftrightarrow \\quad f(k)f(0)0,\n$$\n这里使用了偶函数的性质 $f(-k)=f(k)$。\n4. 选择右子区间的检验条件是\n$$\nf(c)f(b)0 \\quad \\Longleftrightarrow \\quad f(0)f(k)0.\n$$\n这两个条件是完全相同的，因为 $f(k)f(0)=f(0)f(k)$。因此，要么两个子区间 $[-k,0]$ 和 $[0,k]$ 同时满足符号改变的条件（当 $f(k)f(0)0$ 时），要么两个都不满足（当 $f(k)f(0)0$ 时）。因为 $f(0)\\neq 0$ 且 $f(k)\\neq 0$，所以等号成立的情况不会发生。\n\n因此，考虑到对称性以及初始符号改变条件的不满足，二分法选择下一个区间的规则要么是模棱两可的（两个子区间都符合条件），要么是不可能的（两个子区间都不符合条件）。这与陈述 C 相符。", "answer": "$$\\boxed{C}$$", "id": "2157544"}, {"introduction": "这个综合性实践将引导您从纸笔练习过渡到计算实现。本任务 [@problem_id:3211594] 不仅要求您编写经典的试位法 (regula falsi) 代码，还要求您实现一种常见的改进算法（伊利诺伊法），以解决前者已知的性能缺陷。通过这个过程，您将把教科书中的理论算法与现实世界中高效、稳健的代码实践联系起来。", "problem": "实现一个完整、可运行的程序，该程序从介值定理和线性插值出发，构建两种区间求根方法，并在一个精心选择的测试套件上比较它们的行为。这两种方法是经典的试位法（也称为 regula falsi）和伊利诺伊改进法。你的程序必须完成以下所有任务。\n\n首先，仅使用以下基本原理。\n- 介值定理：如果一个实值函数 $f$ 在闭区间 $[a,b]$ 上是连续的，并且 $f(a)\\,f(b)\\le 0$，那么在 $[a,b]$ 中至少存在一个点 $x^\\star$ 使得 $f(x^\\star)=0$。\n- 线性插值：通过两点 $(x_0,y_0)$ 和 $(x_1,y_1)$ 的唯一仿射函数是与这两个值都匹配的直线。当其零点存在时，该零点可为对应连续函数的根提供一个近似值。\n\n其次，以纯粹的区间形式实现这两种算法。\n- 经典 regula falsi：在每次迭代中，给定一个满足 $f(a)\\,f(b)0$ 的求根区间 $[a,b]$，用穿过当前端点的割线的零点替换其中一个端点，以保持符号变化。当当前近似点处的函数绝对值小于或等于预设阈值，或区间长度小于或等于预设阈值，或达到最大迭代次数时，算法终止。\n- 伊利诺伊改进法：使用与上述相同的区间和割线构造，但如果在连续两次迭代中替换了同一个端点，则在构造下一条割线之前，将对侧（未改变的）端点处的函数值乘以 $1/2$。此修改旨在避免经典 regula falsi 方法的“端点停滞”行为，即一个端点在许多步中保持固定，而另一个端点反复移动。\n\n第三，采用以下精确规范。\n- 每个测试用例的输入：一个连续函数 $f:\\mathbb{R}\\to\\mathbb{R}$，一个满足 $f(a)\\,f(b)0$ 的有效初始区间 $[a,b]$，一个绝对区间长度容差 $x_{\\text{tol}}0$，一个绝对函数值容差 $f_{\\text{tol}}0$，以及最大迭代次数 $N_{\\max}\\in\\mathbb{N}$。\n- 终止条件：在任一方法中，当第 $k$ 次迭代得到近似值 $c_k$ 时，如果 $|f(c_k)|\\le f_{\\text{tol}}$ 或 $|b_k-a_k|\\le x_{\\text{tol}}$，则停止。如果在 $N_{\\max}$ 次迭代内两个条件都未满足，则返回最后的近似值和计数 $N_{\\max}$。\n- 每个测试用例的返回值：报告伊利诺伊方法得到的根的近似值（四舍五入到 $12$ 位小数）、伊利诺伊方法所用的总迭代次数，以及在相同停止标准和 $N_{\\max}$ 下，经典 regula falsi 方法所用的总迭代次数。\n- 角度单位：当出现三角函数时，所有角度均以弧度处理。\n\n第四，使用以下测试套件。每个 $f_i$ 在给定区间上都是连续的，并且满足区间求根条件。\n- 用例 $\\,$$1$：$f_1(x)=\\cos(x)-x$，区间为 $[0,1]$，$x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。角度以弧度为单位。\n- 用例 $\\,$$2$：$f_2(x)=x^2-2$，区间为 $[0,2]$，$x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。\n- 用例 $\\,$$3$：$f_3(x)=e^{-x}-x$，区间为 $[0,1]$，$x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=1000$。该用例是平滑且单调的，用于在非多项式环境下测试通用性能。\n- 用例 $\\,$$4$：$f_4(x)=x^{10}-1$，区间为 $[0,2]$，$x_{\\text{tol}}=10^{-12}$，$f_{\\text{tol}}=10^{-12}$，$N_{\\max}=10000$。这个用例是特别构造的，使得经典 regula falsi 方法会展现“端点停滞”现象，而伊利诺伊改进法则通过重新加权来避免该现象。在经典方法下，左端点会反复移动，而右端点倾向于保持固定，导致收敛非常缓慢；伊利诺伊改进法通过在对侧端点连续更新后将未变动端点的函数值减半来应对这种情况。\n\n第五，输出格式。你的程序应该产生单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。对于每个测试用例（按上述顺序），生成一个形如 $[r, n_{\\mathrm{Ill}}, n_{\\mathrm{RF}}]$ 的子列表，其中 $r$ 是伊利诺伊方法得到的根的近似值（四舍五入到 $12$ 位小数），$n_{\\mathrm{Ill}}$ 是伊利诺伊方法的迭代次数，$n_{\\mathrm{RF}}$ 是经典 regula falsi 方法的迭代次数。因此，最终输出应该是一个包含 4 个子列表的列表，与上述用例顺序相同，无需单位。例如，一个语法上有效的形式是 $[[r_1,n_{\\mathrm{Ill},1},n_{\\mathrm{RF},1}],[r_2,n_{\\mathrm{Ill},2},n_{\\mathrm{RF},2}],[r_3,n_{\\mathrm{Ill},3},n_{\\mathrm{RF},3}],[r_4,n_{\\mathrm{Ill},4},n_{\\mathrm{RF},4}]]$.", "solution": "该问题要求实现并比较两种区间求根算法：经典的试位法（regula falsi）及其伊利诺伊改进法。解决方案按要求从第一性原理出发进行开发。\n\n任何区间法的理论基础是**介值定理 (IVT)**。IVT 指出，对于一个在闭区间 $[a, b]$ 上连续的实值函数 $f$，如果 $f(a)$ 和 $f(b)$ 的值异号（即 $f(a)f(b) \\le 0$），那么在 $[a, b]$ 中必然存在至少一个点 $x^\\star$ 使得 $f(x^\\star) = 0$。该定理保证了在任何函数值在端点变号的区间内根的存在性，从而证明了在该区间内搜索根的合理性。两种算法都利用了这一点，确保在每一步中，更新后的区间继续包含一个根。\n\n核心的构造原理是**线性插值**。给定函数 $y=f(x)$ 曲线上两点 $(a, f(a))$ 和 $(b, f(b))$，我们可以用一条穿过这两点的直线（一条割线）来近似该函数。这个唯一的仿射函数 $L(x)$ 的方程是：\n$$L(x) = f(a) + \\frac{f(b) - f(a)}{b - a}(x - a)$$\n$f(x)$ 的根的近似值可以通过求解 $L(x)$ 的根来找到，即找到值 $c$ 使得 $L(c) = 0$。\n$$0 = f(a) + \\frac{f(b) - f(a)}{b - a}(c - a)$$\n求解 $c$ 可得出用于根近似的割线公式：\n$$c = a - f(a) \\frac{b - a}{f(b) - f(a)}$$\n一个代数上等价且通常数值上更稳定的形式是：\n$$c = \\frac{a f(b) - b f(a)}{f(b) - f(a)}$$\n这个值 $c$ 就成为根 $x^\\star$ 的新估计值。\n\n**1. 经典试位法 (Regula Falsi)**\n\nregula falsi 算法使用割线近似值 $c$ 来迭代地优化求根区间 $[a, b]$。\n在每次迭代 $k$ 中，给定一个满足 $f(a_k)f(b_k)  0$ 的区间 $[a_k, b_k]$：\n1.  使用割线公式计算根的近似值 $c_k$：$c_k = \\frac{a_k f(b_k) - b_k f(a_k)}{f(b_k) - f(a_k)}$。\n2.  计算 $f(c_k)$ 的值。\n3.  更新区间以保持符号变化，确保根仍被包含在内。\n    - 如果 $f(a_k)f(c_k)  0$，则根位于 $[a_k, c_k]$ 内，因此新区间为 $[a_{k+1}, b_{k+1}] = [a_k, c_k]$。\n    - 否则，必然有 $f(c_k)f(b_k)  0$（假设 $f(c_k) \\ne 0$），因此新区间为 $[a_{k+1}, b_{k+1}] = [c_k, b_k]$。\n4.  当近似值足够精确时，过程终止。精确度由 $|f(c_k)| \\le f_{\\text{tol}}$ 或区间宽度 $|b_k - a_k| \\le x_{\\text{tol}}$ 来衡量，或者当达到最大迭代次数 $N_{\\max}$ 时也终止。\n\nregula falsi 的一个已知弱点出现在根附近曲率不改变符号的函数（例如，凸函数或凹函数）上。在这种情况下，区间的一个端点可能会变得“停滞”，在多次迭代中保持不变。近似值 $c_k$ 将只从一侧逼近根，导致收敛速度缓慢，呈线性收敛，而不是预期的超线性收敛。\n\n**2. 伊利诺伊改进法**\n\n伊利诺伊算法修改了 regula falsi 以解决“端点停滞”问题。其操作方式与 regula falsi 完全相同，但增加了一条关键规则：\n- 如果一个端点（比如 $b$）被新的近似值 $c_k$ 替换，算法会记下这一点。如果在随后的迭代中，端点 $b$ 再次被替换（这意味着端点 $a$ 已连续两步保持静止），算法会推断出 $a$ 是“停滞”的端点。\n- 为了打破这种停滞，在计算*下一个*割线近似值之前，停滞端点处的函数值会被人为地减小。具体来说，如果端点 $a$ 停滞，我们设置 $f(a) \\leftarrow f(a)/2$。对称地，如果端点 $b$ 停滞，我们设置 $f(b) \\leftarrow f(b)/2$。\n\n这种修改有效地“拉平”了割线相对于静止端点的斜率，从而迫使下一个近似值 $c_{k+1}$ 更靠近该端点，提高了收敛速度。这种启发式方法有助于打破单侧收敛的模式，并通常能恢复更高的收敛阶。\n\n实现将遵循这些原则，创建两个函数 `regula_falsi` 和 `illinois_method`，然后将它们应用于指定的测试套件，以比较它们的性能，特别是在那些旨在凸显经典方法缺陷的用例上。其结果——伊利诺伊方法的根近似值，以及两种方法的迭代次数——将被收集并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares the classical regula falsi and Illinois methods for\n    root finding on a specified test suite, formatting the output as required.\n    \"\"\"\n\n    def regula_falsi(f, a, b, xtol, ftol, nmax):\n        \"\"\"\n        Implements the classical regula falsi (false position) method.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb >= 0:\n            # According to the problem statement, this path is not taken.\n            return (a + b) / 2, -1 \n\n        c = a  # Placeholder for the root approximation\n\n        for k in range(1, nmax + 1):\n            # The secant formula for the new approximation 'c'.\n            # This form is often more numerically stable than c = b - fb * (b - a) / (fb - fa).\n            c = (a * fb - b * fa) / (fb - fa)\n            fc = f(c)\n\n            # Termination condition 1: function value is close to zero\n            if abs(fc) = ftol:\n                return c, k\n\n            # Update the bracket [a, b] by replacing one endpoint\n            if fa * fc  0:\n                b = c\n                fb = fc\n            else:\n                a = c\n                fa = fc\n\n            # Termination condition 2: bracket width is small enough\n            if abs(b - a) = xtol:\n                return c, k\n\n        # If the loop completes, max iterations were reached\n        return c, nmax\n\n    def illinois_method(f, a, b, xtol, ftol, nmax):\n        \"\"\"\n        Implements the Illinois modification of the regula falsi method.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb >= 0:\n            return (a + b) / 2, -1\n\n        c = a\n        # A state variable to track which endpoint was last replaced.\n        # 0: initial state, 1: 'a' was replaced, 2: 'b' was replaced.\n        last_replaced = 0 \n\n        for k in range(1, nmax + 1):\n            # Calculate the new approximation 'c' using the secant formula.\n            c = (a * fb - b * fa) / (fb - fa)\n            fc = f(c)\n\n            # Termination condition 1\n            if abs(fc) = ftol:\n                return c, k\n\n            # Update the bracket and apply the Illinois modification heuristic.\n            if fa * fc  0:  # Root is in [a, c], so 'b' is the endpoint to be replaced\n                b = c\n                fb = fc\n                if last_replaced == 2:  # 'b' was also replaced last time, so 'a' is the stuck endpoint\n                    fa *= 0.5\n                last_replaced = 2\n            else:  # Root is in [c, b], so 'a' is the endpoint to be replaced\n                a = c\n                fa = fc\n                if last_replaced == 1:  # 'a' was also replaced last time, so 'b' is the stuck endpoint\n                    fb *= 0.5\n                last_replaced = 1\n\n            # Termination condition 2\n            if abs(b - a) = xtol:\n                return c, k\n        \n        return c, nmax\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'f': lambda x: np.cos(x) - x, 'a': 0.0, 'b': 1.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: x**2 - 2, 'a': 0.0, 'b': 2.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: np.exp(-x) - x, 'a': 0.0, 'b': 1.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 1000},\n        {'f': lambda x: x**10 - 1, 'a': 0.0, 'b': 2.0, 'xtol': 1e-12, 'ftol': 1e-12, 'nmax': 10000}\n    ]\n\n    results_as_strings = []\n    for case in test_cases:\n        # Unpack parameters for the current test case\n        f, a, b, xtol, ftol, nmax = case['f'], case['a'], case['b'], case['xtol'], case['ftol'], case['nmax']\n\n        # Run the Illinois method to get root and iteration count\n        r_ill, n_ill = illinois_method(f, a, b, xtol, ftol, nmax)\n        \n        # Run the classical regula falsi method to get its iteration count\n        _, n_rf = regula_falsi(f, a, b, xtol, ftol, nmax)\n        \n        # Per problem specification, round Illinois root to 12 decimal places\n        r_ill_rounded = round(r_ill, 12)\n\n        # Format the sublist for this test case\n        results_as_strings.append(f\"[{str(r_ill_rounded)},{n_ill},{n_rf}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "3211594"}]}