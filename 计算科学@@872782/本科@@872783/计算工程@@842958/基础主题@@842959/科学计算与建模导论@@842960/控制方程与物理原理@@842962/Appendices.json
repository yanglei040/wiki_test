{"hands_on_practices": [{"introduction": "反应-扩散方程是描述从化学反应到热传导等多种物理现象的基本模型。当我们将这些连续的偏微分方程离散化以进行数值求解时，一个至关重要的问题是确保我们的数值格式本身是稳定的，不会产生非物理的振荡或发散。本练习将引导你使用冯·诺依曼稳定性分析这一基本工具，来确定一个显式有限差分格式的稳定性边界，这是将控制方程成功转化为可靠计算算法的关键一步。 [@problem_id:2398003]", "problem": "考虑一个周期性域上的一维反应扩散偏微分方程 (PDE) $u_t = D\\,u_{xx} + u\\,(1 - u)$，其中扩散系数 $D \\gt 0$ 为常数。令 $x_j = j\\,\\Delta x$ 表示均匀空间网格，$t^n = n\\,\\Delta t$ 表示均匀时间网格。以下全显式有限差分格式将节点解 $u_j^n \\approx u(x_j,t^n)$ 在时间上推进：\n$$\nu_j^{n+1} = u_j^n + \\Delta t\\left[ D\\,\\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{\\Delta x^2} + u_j^n\\left(1 - u_j^n\\right) \\right].\n$$\n请从第一性原理出发，确定保证该格式对于均匀稳态 $u \\equiv 1$ 周围的无穷小扰动具有线性稳定性的最大时间步长 $\\Delta t_{\\max}$，该稳定性需对周期性网格所支持的所有空间波数都成立。请用 $D$ 和 $\\Delta x$ 将您的答案表示为单个闭式解析表达式。答案中不应包含单位。无需进行数值舍入。", "solution": "所述问题在科学上是合理的、适定的、客观的，并包含足够的信息以得到唯一解。这是偏微分方程数值方法分析中的一个标准问题。因此，我们将着手求解。\n\n任务是确定给定的反应扩散方程 $u_t = D\\,u_{xx} + u\\,(1 - u)$ 的全显式有限差分格式的线性稳定性极限。分析将围绕均匀稳态 $u(x,t) \\equiv 1$ 的小扰动进行。\n\n首先，我们验证 $u \\equiv 1$ 确实是一个稳态解。将 $u=1$ 代入偏微分方程得到 $0 = D \\cdot 0 + 1 \\cdot (1 - 1)$，化简为 $0=0$。因此，$u \\equiv 1$ 是一个有效的稳态。\n\n接下来，我们围绕该稳态对有限差分格式进行线性化。设网格点 $j$ 和时间步 $n$ 的数值解表示为稳态与一个小扰动 $\\epsilon_j^n$ 的和：\n$$u_j^n = 1 + \\epsilon_j^n$$\n其中假设 $|\\epsilon_j^n| \\ll 1$。我们将此代入给定的格式：\n$$\nu_j^{n+1} = u_j^n + \\Delta t\\left[ D\\,\\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{\\Delta x^2} + u_j^n\\left(1 - u_j^n\\right) \\right]\n$$\n将 $u_j^n = 1 + \\epsilon_j^n$ 代入每一项：\n左边项变为：\n$$u_j^{n+1} = 1 + \\epsilon_j^{n+1}$$\n右边的扩散项变为：\n$$\nD\\,\\frac{(1+\\epsilon_{j+1}^n) - 2(1+\\epsilon_j^n) + (1+\\epsilon_{j-1}^n)}{\\Delta x^2} = D\\,\\frac{\\epsilon_{j+1}^n - 2\\epsilon_j^n + \\epsilon_{j-1}^n}{\\Delta x^2}\n$$\n右边的反应项变为：\n$$\nu_j^n(1 - u_j^n) = (1 + \\epsilon_j^n)(1 - (1 + \\epsilon_j^n)) = (1 + \\epsilon_j^n)(-\\epsilon_j^n) = -\\epsilon_j^n - (\\epsilon_j^n)^2\n$$\n将这些代换组合成完整的方程：\n$$\n1 + \\epsilon_j^{n+1} = (1 + \\epsilon_j^n) + \\Delta t \\left[ D\\,\\frac{\\epsilon_{j+1}^n - 2\\epsilon_j^n + \\epsilon_{j-1}^n}{\\Delta x^2} - \\epsilon_j^n - (\\epsilon_j^n)^2 \\right]\n$$\n对于线性稳定性分析，我们忽略 $(\\epsilon_j^n)^2$ 阶及更高阶的项。两边的常数项 $1$ 相互抵消。这样就得到了扰动 $\\epsilon_j^n$ 演化的线性化方程：\n$$\n\\epsilon_j^{n+1} = \\epsilon_j^n + \\Delta t \\left[ D\\,\\frac{\\epsilon_{j+1}^n - 2\\epsilon_j^n + \\epsilon_{j-1}^n}{\\Delta x^2} - \\epsilon_j^n \\right]\n$$\n现在我们对这个线性方程应用冯·诺依曼稳定性分析。我们考虑周期性网格上扰动的单个傅里叶模态，其形式为：\n$$\n\\epsilon_j^n = A(k)^n e^{i k x_j} = A(k)^n e^{i k j \\Delta x}\n$$\n其中 $k$ 是空间波数，$A(k)^n$ 是时间步 $n$ 时该模态的振幅，$i = \\sqrt{-1}$。格式的稳定性取决于增长因子 $G(k) = A(k)^{n+1} / A(k)^n$。为使格式稳定，对于任何波数 $k$，该因子的模都不能超过1，即 $|G(k)| \\le 1$。\n\n将傅里叶模态代入线性化方程得到：\n$$\nA(k)^{n+1} e^{i k j \\Delta x} = A(k)^n e^{i k j \\Delta x} + \\Delta t \\left[ D\\,\\frac{A(k)^n e^{i k (j+1) \\Delta x} - 2A(k)^n e^{i k j \\Delta x} + A(k)^n e^{i k (j-1) \\Delta x}}{\\Delta x^2} - A(k)^n e^{i k j \\Delta x} \\right]\n$$\n将整个方程除以 $A(k)^n e^{i k j \\Delta x}$，得到增长因子 $G(k)$ 的表达式：\n$$\nG(k) = 1 + \\Delta t \\left[ D\\,\\frac{e^{i k \\Delta x} - 2 + e^{-i k \\Delta x}}{\\Delta x^2} - 1 \\right]\n$$\n使用恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们化简扩散项的分子：\n$$\ne^{i k \\Delta x} - 2 + e^{-i k \\Delta x} = 2\\cos(k \\Delta x) - 2\n$$\n使用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\theta/2)$，我们可以写出：\n$$\n2\\cos(k \\Delta x) - 2 = -2(1 - \\cos(k \\Delta x)) = -4\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)\n$$\n将此代回 $G(k)$ 的表达式中：\n$$\nG(k) = 1 + \\Delta t \\left[ D\\,\\frac{-4\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)}{\\Delta x^2} - 1 \\right] = 1 - \\Delta t \\left[ \\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) + 1 \\right]\n$$\n增长因子 $G(k)$ 是一个实数。因此，稳定性条件 $|G(k)| \\le 1$ 等价于 $-1 \\le G(k) \\le 1$。\n\n由于 $D0$，$\\Delta x^2  0$ 且 $\\sin^2(\\cdot) \\ge 0$，方括号中的项是非负项之和。又因为 $\\Delta t  0$，所以从 1 中减去的整个项是正的。因此，$G(k) \\le 1$ 总是满足的。\n\n因此，稳定性由下界 $G(k) \\ge -1$ 决定：\n$$\n1 - \\Delta t \\left[ \\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) + 1 \\right] \\ge -1\n$$\n$$\n2 \\ge \\Delta t \\left[ \\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) + 1 \\right]\n$$\n重新整理以找到对 $\\Delta t$ 的约束条件：\n$$\n\\Delta t \\le \\frac{2}{\\frac{4D}{\\Delta x^2}\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) + 1}\n$$\n这个不等式必须对网格支持的所有空间波数 $k$ 都成立。为了找到对 $\\Delta t$ 最严格的条件，我们必须找到使不等式右侧最小化的 $k$ 值。这等价于找到使分母最大化的 $k$。当 $\\sin^2\\left(\\frac{k \\Delta x}{2}\\right)$ 项达到其最大值时，分母达到最大值。\n\n$\\sin^2(\\theta)$ 的最大值是 $1$。这发生在网格支持的最高频率模态下，此时 $\\frac{k \\Delta x}{2} = \\frac{\\pi}{2}$，对应于奈奎斯特波数 $k \\Delta x = \\pi$。对于这类显式格式，这些是所有模态中最不稳定的。\n\n将 $\\sin^2\\left(\\frac{k \\Delta x}{2}\\right) = 1$ 代入不等式，得到对 $\\Delta t$ 最严格的条件：\n$$\n\\Delta t \\le \\frac{2}{\\frac{4D}{\\Delta x^2}(1) + 1}\n$$\n因此，保证对所有波数都稳定的最大时间步长 $\\Delta t_{\\max}$ 是此不等式的上界。\n$$\n\\Delta t_{\\max} = \\frac{2}{\\frac{4D}{\\Delta x^2} + 1}\n$$\n为了以要求的闭式形式呈现，我们化简该表达式：\n$$\n\\Delta t_{\\max} = \\frac{2}{\\frac{4D + \\Delta x^2}{\\Delta x^2}} = \\frac{2 \\Delta x^2}{4D + \\Delta x^2}\n$$\n这就是最大允许时间步长的最终解析表达式。", "answer": "$$\\boxed{\\frac{2 \\Delta x^2}{4D + \\Delta x^2}}$$", "id": "2398003"}, {"introduction": "许多物理系统，特别是力学系统，可以用哈密顿框架来描述，其一个标志性特征是能量守恒。然而，在进行长时间数值模拟时，标准的数值积分方法（如龙格-库塔法）通常会引入系统性的能量漂移，导致模拟结果偏离真实物理行为。本练习旨在通过比较一种“辛”积分器和一种非辛积分器的长期表现，让你亲手验证并理解保结构算法在模拟守恒定律方面为何具有无可比拟的优势。 [@problem_id:2398024]", "problem": "您的任务是，仅使用第一性原理，为用于哈密顿动力学的积分器设计并实现一个关于长时间能量行为的数值诊断程序。考虑一个单自由度的哈密顿系统，其广义坐标为 $q$，共轭动量为 $p$，由哈密顿量\n$$\nH(q,p) \\;=\\; \\frac{p^2}{2 m} \\;+\\; \\frac{k}{2}\\,q^2 \\;+\\; \\frac{\\lambda}{4}\\,q^4,\n$$\n所支配，其中 $m$、$k$ 和 $\\lambda$ 是正常数。其连续动力学由哈密顿方程指定\n$$\n\\dot{q} \\;=\\; \\frac{\\partial H}{\\partial p}, \n\\qquad\n\\dot{p} \\;=\\; -\\frac{\\partial H}{\\partial q}.\n$$\n在无量纲单位下，取 $m = 1$，$k = 1$ 和 $\\lambda = 1$。使用初始条件 $q(0) = 0.7$ 和 $p(0) = 0$。\n\n根据第一性原理，能量是运动的第一积分。记初始能量为 $H_0 = H(q(0),p(0))$。对于一个在总时间 $T = N h$ 内由大小为 $h$ 的时间步长生成的离散时间数值轨迹 $\\{(q_n,p_n)\\}_{n=0}^{N}$，定义以下量化的能量诊断指标：\n- 最大相对能量偏差\n$$\n\\Delta_{\\max} \\;=\\; \\max_{0 \\le n \\le N} \\frac{\\left| H(q_n,p_n) - H_0 \\right|}{\\left| H_0 \\right|}.\n$$\n- 归一化线性漂移幅度，通过将离散能量值 $\\{H(q_n,p_n)\\}$ 作为时间 $\\{t_n\\}$（其中 $t_n = n h$）的函数，用最小二乘法拟合到一个仿射模型 $H(t) \\approx a + b t$，然后定义\n$$\nD \\;=\\; \\frac{|b|}{|H_0|}.\n$$\n\n如果一个积分器对于该系统同时满足\n$$\n\\Delta_{\\max} \\le \\varepsilon_{\\max}\n\\quad\\text{和}\\quad\nD \\le \\varepsilon_{\\text{drift}}\n$$\n两个判据，则称其“在长时间尺度上能量守恒”，其中阈值为 $\\varepsilon_{\\max} = 0.05$ 和 $\\varepsilon_{\\text{drift}} = 5\\times 10^{-5}$。\n\n实现一个程序，给定方法类别标志 $M \\in \\{0,1\\}$、时间步长 $h$ 和最终时间 $T$，该程序执行以下操作：\n- 如果 $M = 1$，使用适用于形式为 $H(q,p) = T(p) + V(q)$ 的可分哈密顿量的任意相容辛时间积分器来推进动力学。\n- 如果 $M = 0$，对相同的常微分方程（ODE）系统，使用任意相容的显式非辛单步法来推进动力学。\n- 在两种情况下，都计算数值轨迹，在每个时间层级上评估 $H(q_n,p_n)$，计算 $\\Delta_{\\max}$ 和 $D$，并且当且仅当同时满足上述两个判据时返回布尔值 $\\,\\text{True}\\,$，否则返回 $\\,\\text{False}\\,$。\n\n测试套件。您的程序必须运行以下五个参数集，并按指定的输出格式汇总五个布尔值。在所有情况下，均使用相同的初始条件 $q(0) = 0.7$、$p(0) = 0$，参数 $m = 1$、$k = 1$、$\\lambda = 1$，以及最终时间 $T = 4000$：\n- 情况 1：$(M,h,T) = (1,\\,0.02,\\,4000)$。\n- 情况 2：$(M,h,T) = (1,\\,0.05,\\,4000)$。\n- 情况 3：$(M,h,T) = (1,\\,0.10,\\,4000)$。\n- 情况 4：$(M,h,T) = (0,\\,0.02,\\,4000)$。\n- 情况 5：$(M,h,T) = (0,\\,0.05,\\,4000)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，[True,False,True,False,True]）。此问题中没有物理单位，因为所有量在构造上都是无量纲的。问题不涉及角度，因此不需要角度单位。所有答案都必须是布尔值。最终输出必须只有一行。", "solution": "该问题要求设计并实现一个数值诊断程序，用于评估数值积分器对特定哈密顿系统的长时间能量守恒性。这首先需要对问题陈述进行严格的验证。\n\n该问题具有科学依据，是适定的、客观的。它涉及对一个单自由度系统的哈密顿方程进行数值积分，其哈密顿量为 $H(q,p) = \\frac{p^2}{2m} + \\frac{k}{2}q^2 + \\frac{\\lambda}{4}q^4$。控制方程 $\\dot{q} = \\partial H / \\partial p$ 和 $\\dot{p} = - \\partial H / \\partial q$ 是经典力学的基本原理。参数 $m=1, k=1, \\lambda=1$ 和初始条件 $q(0)=0.7, p(0)=0$ 均已指定，使问题自成体系。诊断指标 $\\Delta_{\\max}$ 和 $D$ 是能量误差和漂移的标准定量度量。“能量守恒”的判据通过数值阈值 $\\varepsilon_{\\max}=0.05$ 和 $\\varepsilon_{\\text{drift}}=5 \\times 10^{-5}$ 明确定义。任务是实现一个程序，将这些诊断指标应用于由两类积分器生成的轨迹：一类是辛方法（$M=1$），另一类是非辛方法（$M=0$）。该问题是计算物理学中一个有效且经典的练习。\n\n我们开始求解。所考虑的系统由具有无量纲参数 $m=1$、$k=1$ 和 $\\lambda=1$ 的哈密顿量指定：\n$$\nH(q,p) = \\frac{p^2}{2} + \\frac{q^2}{2} + \\frac{q^4}{4}.\n$$\n相应的哈密顿运动方程为：\n$$\n\\dot{q} = \\frac{\\partial H}{\\partial p} = p,\n$$\n$$\n\\dot{p} = -\\frac{\\partial H}{\\partial q} = -(q + q^3).\n$$\n该系统构成了一组两个耦合的一阶常微分方程（ODEs）。对于任意初始条件 $(q_0, p_0)$，精确解轨迹 $(q(t), p(t))$ 能量守恒，即 $H(q(t),p(t))$ 对所有时间 $t$ 都是常数。初始能量为 $H_0 = H(q(0), p(0)) = H(0.7, 0) = \\frac{0^2}{2} + \\frac{0.7^2}{2} + \\frac{0.7^4}{4} = 0.305025$。\n\n数值积分器用在时间 $t_n = n h$ 的离散时间序列 $(q_n, p_n)$ 来近似连续时间解。此问题的关键区别在于积分器的几何性质。\n\n对于 $M=1$ 的情况，需要一个辛积分器。这些积分器专为哈密顿系统设计，能精确保持辛2-形式，这是哈密顿流的一个基本几何性质。虽然它们不能精确地守恒原始哈密顿量 $H$，但它们能精确地守恒一个附近的“影子”哈密顿量 $H_h = H + O(h^p)$，其中 $p$ 是方法的阶数。这意味着能量误差 $|H(q_n,p_n) - H_0|$ 在指数级长的时间内保持有界，不表现出长期漂移。对于形式为 $H=T(p)+V(q)$ 的可分哈密顿量，一个标准的选择是二阶 Störmer-Verlet（或蛙跳）方法。我们选择 velocity-Verlet 变体，其对于我们的系统形式如下：\n$$\np_{n+1/2} = p_n + \\frac{h}{2} F(q_n)\n$$\n$$\nq_{n+1} = q_n + h \\, p_{n+1/2}\n$$\n$$\np_{n+1} = p_{n+1/2} + \\frac{h}{2} F(q_{n+1})\n$$\n其中力为 $F(q) = -\\frac{dV}{dq} = -(q + q^3)$。\n\n对于 $M=0$ 的情况，需要一个相容的显式非辛单步法。标准的 ODE 求解器，如 Runge-Kutta 族，就属于这一类。尽管它们对于通用问题通常具有高精度，但它们不保持辛结构。当应用于哈密顿系统时，它们通常会引入系统性的能量漂移，即数值能量 $H(q_n, p_n)$ 会随时间发生长期增长或衰减。我们选择经典的四阶 Runge-Kutta 方法（RK4），这是该类方法中一个广泛使用且高度精确的成员。对于一个系统 $\\dot{\\mathbf{y}} = \\mathbf{f}(\\mathbf{y})$，其中 $\\mathbf{y}=[q, p]^T$，其更新规则是：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中\n$$\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{y}_n), \\quad \\mathbf{k}_2 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_1), \\quad \\mathbf{k}_3 = \\mathbf{f}(\\mathbf{y}_n + \\frac{h}{2}\\mathbf{k}_2), \\quad \\mathbf{k}_4 = \\mathbf{f}(\\mathbf{y}_n + h\\mathbf{k}_3).\n$$\n这里，$\\mathbf{f}(q, p) = [p, -(q+q^3)]^T$。\n\n程序的核心在于为给定的方法类型 $M$、步长 $h$ 和最终时间 $T=Nh$ 生成一条数值轨迹 $\\{(q_n,p_n)\\}_{n=0}^N$。在生成轨迹之后，计算两个指定的诊断指标。\n\n$1$。最大相对能量偏差 $\\Delta_{\\max}$ 计算如下：\n$$\n\\Delta_{\\max} = \\frac{\\max_{0 \\le n \\le N} |H(q_n, p_n) - H_0|}{|H_0|}.\n$$\n这度量了能量与其初始值的最大偏离。\n\n$2$。计算归一化线性漂移幅度 $D$。这需要将能量值的时间序列 $\\{H_n = H(q_n,p_n)\\}$ 与时间序列 $\\{t_n = nh\\}$ 使用最小二乘法拟合到一个线性模型 $H(t) \\approx a + bt$。斜率 $b$ 量化了在整个积分过程中的平均能量变化率。对于 $N+1$ 个数据点 $(t_n, H_n)$ 的简单线性回归，斜率 $b$ 的公式为：\n$$\nb = \\frac{(N+1) \\sum_{n=0}^N (t_n H_n) - (\\sum_{n=0}^N t_n)(\\sum_{n=0}^N H_n)}{(N+1) \\sum_{n=0}^N t_n^2 - (\\sum_{n=0}^N t_n)^2}.\n$$\n该值可以方便地使用标准数值库函数获得。然后诊断指标 $D$ 定义为：\n$$\nD = \\frac{|b|}{|H_0|}.\n$$\n这个量是专门为检测长期漂移而设计的，这是非辛积分器的典型特征。\n\n最后，所实现的程序对每个测试用例评估是否同时满足 $\\Delta_{\\max} \\le \\varepsilon_{\\max}$ 和 $D \\le \\varepsilon_{\\text{drift}}$ 两个条件，并返回一个布尔结果。对 5 个指定的测试用例的结果会被汇总到一个列表中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # System parameters and thresholds are fixed as per the problem statement.\n    # m = 1, k = 1, lambda = 1.\n    # q(0) = 0.7, p(0) = 0.\n    # eps_max = 0.05, eps_drift = 5e-5.\n\n    test_cases = [\n        (1, 0.02, 4000),  # Case 1: Symplectic, h=0.02\n        (1, 0.05, 4000),  # Case 2: Symplectic, h=0.05\n        (1, 0.10, 4000),  # Case 3: Symplectic, h=0.10\n        (0, 0.02, 4000),  # Case 4: Non-symplectic, h=0.02\n        (0, 0.05, 4000),  # Case 5: Non-symplectic, h=0.05\n    ]\n\n    results = []\n    for case in test_cases:\n        M, h, T = case\n        result = run_and_diagnose(M, h, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef H(q, p, m, k, lambda_):\n    \"\"\"\n    Computes the Hamiltonian H(q,p).\n    \"\"\"\n    return p**2 / (2 * m) + k/2 * q**2 + lambda_/4 * q**4\n\ndef run_and_diagnose(M, h, T):\n    \"\"\"\n    Runs a single simulation and computes the energy diagnostics.\n\n    Args:\n        M (int): Method flag (1 for symplectic, 0 for non-symplectic).\n        h (float): Time step size.\n        T (float): Total integration time.\n\n    Returns:\n        bool: True if energy conservation criteria are met, False otherwise.\n    \"\"\"\n    # Parameters and initial conditions\n    m, k, lambda_ = 1.0, 1.0, 1.0\n    q0, p0 = 0.7, 0.0\n    eps_max = 0.05\n    eps_drift = 5e-5\n\n    N = int(T / h)\n    q_traj = np.zeros(N + 1)\n    p_traj = np.zeros(N + 1)\n    q_traj[0], p_traj[0] = q0, p0\n\n    # Perform the time integration\n    if M == 1:\n        # Symplectic integrator: Velocity-Verlet (Störmer-Verlet)\n        for n in range(N):\n            q, p = q_traj[n], p_traj[n]\n            force = -(k * q + lambda_ * q**3)\n            p_half = p + 0.5 * h * force\n            q_next = q + h * (p_half / m)\n            force_next = -(k * q_next + lambda_ * q_next**3)\n            p_next = p_half + 0.5 * h * force_next\n            q_traj[n+1], p_traj[n+1] = q_next, p_next\n    elif M == 0:\n        # Non-symplectic integrator: Classical Runge-Kutta 4th order (RK4)\n        def f(y_vec):\n            q, p = y_vec\n            return np.array([p / m, -(k * q + lambda_ * q**3)])\n        \n        y = np.array([q0, p0])\n        for n in range(N):\n            k1 = f(y)\n            k2 = f(y + 0.5 * h * k1)\n            k3 = f(y + 0.5 * h * k2)\n            k4 = f(y + h * k3)\n            y = y + (h / 6.0) * (k1 + 2*k2 + 2*k3 + k4)\n            q_traj[n+1], p_traj[n+1] = y\n\n    # Compute diagnostics\n    H_traj = H(q_traj, p_traj, m, k, lambda_)\n    H0 = H_traj[0]\n\n    # This problem's initial conditions ensure H0 is not zero\n    # delta_max calculation\n    delta_max = np.max(np.abs(H_traj - H0)) / np.abs(H0)\n\n    # D (drift) calculation\n    t_vals = np.linspace(0, T, N + 1)\n    # Fit H(t) = b*t + a, np.polyfit returns [b, a]\n    b, _ = np.polyfit(t_vals, H_traj, 1)\n    D = np.abs(b) / np.abs(H0)\n\n    # Check criteria\n    return delta_max = eps_max and D = eps_drift\n\nsolve()\n```", "id": "2398024"}, {"introduction": "在工程和科学实践中，我们常常需要解决“逆问题”：即利用观测到的结果来推断其背后的未知原因或初始状态。本练习将带你挑战一个经典的热传导逆问题，即仅根据杆中点后续的温度测量数据，来重构整个杆的初始温度分布。通过这个过程，你将接触到逆问题的“不适定性”概念，并学习使用正则化等关键技术来获得稳定且有物理意义的解，这对于处理现实世界中不完整或带噪声的数据至关重要。 [@problem_id:2398006]", "problem": "给定一个符合能量守恒和傅里叶热传导定律的一维热传导反问题。一根长度为 $L$ 的均匀金属棒，其两端始终保持零温度，其温度根据一维热方程演化。控制偏微分方程 (PDE) 为\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 T}{\\partial x^2}(x,t), \\quad 0  x  L,\\ t  0,\n$$\n边界条件为\n$$\nT(0,t)=0,\\quad T(L,t)=0,\\quad t0,\n$$\n以及未知的初始温度分布\n$$\nT(x,0) = T_0(x), \\quad 0  x  L.\n$$\n此处，$T$ 是温度（单位：$\\mathrm{K}$），$x$ 是位置（单位：$\\mathrm{m}$），$t$ 是时间（单位：$\\mathrm{s}$），$\\alpha$ 是热扩散系数（单位：$\\mathrm{m^2/s}$）。仅测量中点的温度时间历史：\n$$\ny(t_i) = T(L/2, t_i), \\quad i=1,\\dots,m.\n$$\n假设该金属棒是均匀的，具有恒定的 $\\alpha$ 值，并且没有内部热源。您必须通过假设初始温度 $T_0(x)$ 位于满足边界条件的前 $M$ 个奇正弦本征函数的张成空间中来重建其近似值：\n$$\nT_0(x) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\!\\left(\\frac{(2k+1)\\pi x}{L}\\right),\n$$\n其中，未知系数 $b_{2k+1}$（单位：$\\mathrm{K}$）将根据中点测量值 $y(t_i)$ 来确定。使用从控制方程和边界条件推导出的基于原理的方法，将 $y(t)$ 表示为未知系数和已知参数的函数，然后建立并求解一个线性反问题来估计 $b_{2k+1}$。由于该反问题是不适定的，如果需要，请使用带吉洪诺夫正则化的线性最小二乘法：\n$$\n\\min_{\\mathbf{b}} \\ \\|A\\mathbf{b} - \\mathbf{y}\\|_2^2 + \\lambda_{\\mathrm{reg}}^2 \\|\\mathbf{b}\\|_2^2,\n$$\n其中 $A$ 是从物理原理推导出的设计矩阵，$\\mathbf{b}$ 是未知系数向量 $[b_1,b_3,\\dots,b_{2M-1}]^\\top$，$\\mathbf{y}$ 汇集了测量值，$\\lambda_{\\mathrm{reg}} \\ge 0$ 是正则化参数。\n\n实现一个完整且可运行的程序，该程序能为下方的测试套件中的每种情况重建奇正弦系数向量。每个系数以 $\\mathrm{K}$ 为单位表示，并四舍五入到三位小数。任何三角函数求值中的角度都必须解释为弧度。\n\n测试套件（每种情况提供了长度 $L$（单位：$\\mathrm{m}$）、热扩散系数 $\\alpha$（单位：$\\mathrm{m^2/s}$）、时间网格（单位：$\\mathrm{s}$）、测量的中点温度（单位：$\\mathrm{K}$）、奇模态数 $M$ 和正则化参数 $\\lambda_{\\mathrm{reg}}$）：\n- 情况 A（理想路径，单一模态，无噪声）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 100, 300, 500]\\ \\mathrm{s}$，\n  - 测量值 $y = [10.00000, 9.06018, 7.43722, 6.10497]\\ \\mathrm{K}$，\n  - $M=1$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n- 情况 B（两个可识别模态，无噪声）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 50, 200, 500]\\ \\mathrm{s}$，\n  - 测量值 $y = [6.00000, 7.57583, 8.83511, 7.25528]\\ \\mathrm{K}$，\n  - $M=2$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n- 情况 C（三个模态，含噪声数据，不同的棒材属性）：\n  - $L = 0.8\\ \\mathrm{m}$，$\\alpha = 7.0\\times 10^{-5}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 40, 120, 240, 400]\\ \\mathrm{s}$，\n  - 测量值 $y = [4.01230, 3.42575, 3.55080, 3.55920, 3.19240]\\ \\mathrm{K}$，\n  - $M=3$，\n  - $\\lambda_{\\mathrm{reg}} = 1.0\\times 10^{-3}$。\n- 情况 D（边界情况：不可观测的偶模态，零信号）：\n  - $L = 1.0\\ \\mathrm{m}$，$\\alpha = 1.0\\times 10^{-4}\\ \\mathrm{m^2/s}$，\n  - 时间 $t = [0, 10, 20, 50, 100]\\ \\mathrm{s}$，\n  - 测量值 $y = [0.0, 0.0, 0.0, 0.0, 0.0]\\ \\mathrm{K}$，\n  - $M=3$，\n  - $\\lambda_{\\mathrm{reg}} = 0.0$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含所有情况的结果列表，每个情况的结果是重建的奇系数 $[b_1,b_3,\\dots,b_{2M-1}]$（单位：$\\mathrm{K}$）的列表，每个系数都四舍五入到三位小数。例如，\n$[[b_{1}^{(A)},b_{3}^{(A)},\\dots],[b_{1}^{(B)},b_{3}^{(B)},\\dots],\\dots]$,\n其中每个内部列表根据对应情况的 $M$ 值被截断为相应长度。程序必须严格按照此格式打印一行输出。", "solution": "所提出的问题是一个有效的热传导反问题。它在科学上基于 Fourier 定律和能量守恒原理，这些原理被包含在一维热方程中。该问题对于数值求解是良置的，因为它指定了一种标准的正则化技术来处理反问题的内在不适定性。所有必需的参数和数据均已提供，且目标定义明确，没有歧义。\n\n任务是重建长度为 $L$ 的均匀棒的初始温度分布 $T_0(x)$。温度演化由以下偏微分方程 (PDE) 控制：\n$$\n\\frac{\\partial T}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 T}{\\partial x^2}(x,t), \\quad \\text{for } x \\in (0, L) \\text{ and } t  0\n$$\n边界条件为齐次 Dirichlet 边界条件：\n$$\nT(0,t) = 0, \\quad T(L,t) = 0, \\quad \\text{for } t  0\n$$\n该边值问题的一般解可以通过分离变量法求得。它表示为一个 Fourier 正弦级数：\n$$\nT(x,t) = \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n\\pi x}{L}\\right) e^{-\\alpha \\left(\\frac{n\\pi}{L}\\right)^2 t}\n$$\n系数 $c_n$ 由初始条件 $T(x,0) = T_0(x)$ 确定，此时级数变为：\n$$\nT_0(x) = \\sum_{n=1}^{\\infty} c_n \\sin\\left(\\frac{n\\pi x}{L}\\right)\n$$\n问题指出，$T_0(x)$ 将由前 $M$ 个奇正弦本征函数的有限和来近似：\n$$\nT_0(x) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi x}{L}\\right)\n$$\n通过将此近似与初始条件的一般形式进行比较，我们将傅里叶系数 $c_n$ 与未知系数 $b_{2k+1}$ 等同起来。具体而言，我们假设对于 $k \\in \\{0, 1, \\dots, M-1\\}$，有 $c_{2k+1} = b_{2k+1}$，并且所有其他系数，包括所有偶数索引的系数 $c_{2k}$，均为零。这是一个合理的假设，因为任何偶模态 $\\sin(\\frac{2k\\pi x}{L})$ 在中点 $x=L/2$ 处都为零，因此这些模态无法通过中点测量观测到。\n\n将此近似代回到 $T(x,t)$ 的时变解中，我们得到：\n$$\nT(x,t) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi x}{L}\\right) e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t}\n$$\n可用数据包括在离散时间 $t_i$（$i \\in \\{1, \\dots, m\\}$）于棒的中点 $x = L/2$ 处的温度测量值 $y(t_i)$。在 $x=L/2$ 处计算我们的近似解可得：\n$$\ny(t_i) = T(L/2, t_i) \\approx \\sum_{k=0}^{M-1} b_{2k+1} \\sin\\left(\\frac{(2k+1)\\pi (L/2)}{L}\\right) e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t_i}\n$$\n正弦项可简化为：\n$$\n\\sin\\left(\\frac{(2k+1)\\pi}{2}\\right) = (-1)^k\n$$\n这给出了测量值 $y(t_i)$ 和未知系数 $b_{2k+1}$ 之间的直接关系：\n$$\ny(t_i) \\approx \\sum_{k=0}^{M-1} (-1)^k b_{2k+1} e^{-\\alpha \\left(\\frac{(2k+1)\\pi}{L}\\right)^2 t_i}\n$$\n这构成了一个关于 $M$ 个未知系数的 $m$ 个线性方程组。设系数向量为 $\\mathbf{b} = [b_1, b_3, \\dots, b_{2M-1}]^\\top$，测量向量为 $\\mathbf{y} = [y(t_1), y(t_2), \\dots, y(t_m)]^\\top$。该系统可以写成矩阵形式 $A\\mathbf{b} \\approx \\mathbf{y}$。设计矩阵 $A$ 是一个 $m \\times M$ 矩阵，其中元素 $A_{ij}$（对应第 $i$ 个时间点和第 $j$ 个模态，其中 $j=k+1$）是系数 $b_{2j-1}$ 的乘数：\n$$\nA_{ij} = (-1)^{j-1} e^{-\\alpha \\left(\\frac{(2j-1)\\pi}{L}\\right)^2 t_i}\n$$\n其中 $i \\in \\{1, \\dots, m\\}$ 且 $j \\in \\{1, \\dots, M\\}$。\n\n为了找到系数向量 $\\mathbf{b}$，我们必须求解这个线性系统。如前所述，这个反问题通常是不适定的，这意味着测量向量 $\\mathbf{y}$ 中的小误差可能导致解 $\\mathbf{b}$ 的巨大变化。采用吉洪诺夫正则化通过增加一个与解向量的欧几里得范数平方成正比的惩罚项来稳定解。因此，问题是找到使以下目标函数最小化的 $\\mathbf{b}$：\n$$\n\\min_{\\mathbf{b}} \\|A\\mathbf{b} - \\mathbf{y}\\|_2^2 + \\lambda_{\\mathrm{reg}}^2 \\|\\mathbf{b}\\|_2^2\n$$\n其中 $\\lambda_{\\mathrm{reg}} \\ge 0$ 是正则化参数。这个正则化最小二乘问题的解由正规方程给出：\n$$\n(A^\\top A + \\lambda_{\\mathrm{reg}}^2 I) \\mathbf{b} = A^\\top \\mathbf{y}\n$$\n其中 $I$ 是 $M \\times M$ 的单位矩阵。为了数值稳定性，最好避免直接计算 $A^\\top A$。一种更稳定的方法是求解一个等价的增广系统上的标准最小二乘问题。我们定义一个增广矩阵 $\\tilde{A}$ 和一个增广测量向量 $\\tilde{\\mathbf{y}}$：\n$$\n\\tilde{A} = \\begin{pmatrix} A \\\\ \\lambda_{\\mathrm{reg}} I \\end{pmatrix}, \\quad \\tilde{\\mathbf{y}} = \\begin{pmatrix} \\mathbf{y} \\\\ \\mathbf{0} \\end{pmatrix}\n$$\n其中 $\\mathbf{0}$ 是一个长度为 $M$ 的零向量。原始的最小化问题等价于最小化 $\\|\\tilde{A}\\mathbf{b} - \\tilde{\\mathbf{y}}\\|_2^2$。这是一个标准的线性最小二乘问题，可以使用数值库稳健地求解。这个单一的框架可以正确处理正则化（$\\lambda_{\\mathrm{reg}}  0$）和非正则化（$\\lambda_{\\mathrm{reg}} = 0$）两种情况。\n\n对于每个测试用例，实现将按以下步骤进行：\n1. 根据给定的参数 $L$、$\\alpha$ 和时间网格 $t_i$ 构建 $m \\times M$ 矩阵 $A$。\n2. 使用正则化参数 $\\lambda_{\\mathrm{reg}}$ 构建增广矩阵 $\\tilde{A}$ 和增广向量 $\\tilde{\\mathbf{y}}$。\n3. 求解线性最小二乘问题 $\\tilde{A}\\mathbf{b} \\approx \\tilde{\\mathbf{y}}$ 以找到系数向量 $\\mathbf{b}$。\n4. 将得到的系数四舍五入到三位小数，并收集起来用于最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef reconstruct_coefficients(L, alpha, times, measurements, M, lambda_reg):\n    \"\"\"\n    Reconstructs the initial temperature distribution coefficients from midpoint measurements.\n\n    Args:\n        L (float): Length of the bar in meters.\n        alpha (float): Thermal diffusivity in m^2/s.\n        times (list or np.ndarray): Measurement times in seconds.\n        measurements (list or np.ndarray): Measured temperatures at the midpoint in Kelvin.\n        M (int): Number of odd sine modes to use for the approximation.\n        lambda_reg (float): Tikhonov regularization parameter.\n\n    Returns:\n        list: A list of the reconstructed coefficients [b_1, b_3, ...], rounded to three decimals.\n    \"\"\"\n    times = np.asarray(times)\n    measurements = np.asarray(measurements)\n    m = len(times)\n\n    # Construct the design matrix A\n    A = np.zeros((m, M))\n    for i in range(m):  # Loop over time points\n        for j in range(M):  # Loop over odd modes (k=j in the formula)\n            mode_index = 2 * j + 1\n            sine_term = (-1)**j\n            exponent = -alpha * (mode_index * np.pi / L)**2 * times[i]\n            A[i, j] = sine_term * np.exp(exponent)\n\n    # Solve the regularized least squares problem using an augmented system\n    # This is numerically more stable than forming A.T @ A\n    A_aug = np.vstack((A, np.eye(M) * lambda_reg))\n    y_aug = np.concatenate((measurements, np.zeros(M)))\n\n    # Use numpy's least squares solver\n    b, _, _, _ = np.linalg.lstsq(A_aug, y_aug, rcond=None)\n\n    # Round the results to three decimal places\n    return np.round(b, 3).tolist()\n\ndef solve():\n    \"\"\"\n    Runs the reconstruction for all test cases and prints the results in the required format.\n    \"\"\"\n    test_cases = [\n        # Case A\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 100, 300, 500],\n            \"y\": [10.00000, 9.06018, 7.43722, 6.10497],\n            \"M\": 1, \"lambda_reg\": 0.0\n        },\n        # Case B\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 50, 200, 500],\n            \"y\": [6.00000, 7.57583, 8.83511, 7.25528],\n            \"M\": 2, \"lambda_reg\": 0.0\n        },\n        # Case C\n        {\n            \"L\": 0.8, \"alpha\": 7.0e-5, \"times\": [0, 40, 120, 240, 400],\n            \"y\": [4.01230, 3.42575, 3.55080, 3.55920, 3.19240],\n            \"M\": 3, \"lambda_reg\": 1.0e-3\n        },\n        # Case D\n        {\n            \"L\": 1.0, \"alpha\": 1.0e-4, \"times\": [0, 10, 20, 50, 100],\n            \"y\": [0.0, 0.0, 0.0, 0.0, 0.0],\n            \"M\": 3, \"lambda_reg\": 0.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        coeffs = reconstruct_coefficients(\n            L=case[\"L\"],\n            alpha=case[\"alpha\"],\n            times=case[\"times\"],\n            measurements=case[\"y\"],\n            M=case[\"M\"],\n            lambda_reg=case[\"lambda_reg\"]\n        )\n        results.append(coeffs)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398006"}]}