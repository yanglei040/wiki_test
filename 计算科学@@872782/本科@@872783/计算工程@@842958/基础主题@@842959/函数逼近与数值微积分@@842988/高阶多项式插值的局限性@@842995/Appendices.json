{"hands_on_practices": [{"introduction": "龙格现象 (Runge's phenomenon) 是高次多项式插值失败的典型例证，它表明对于等距节点，增加多项式次数并不总能提高拟合精度，插值误差反而可能在区间端点附近急剧增大。这个练习 [@problem_id:2436036] 将引导你通过编程，数值化地计算出误差开始增大的“临界阶数”，从而对这一重要限制建立具体而定量的理解。", "problem": "考虑在闭区间 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+a x^{2}}$，其中参数 $a0$。对于每个整数次数 $n \\ge 0$，令 $P_{n}(x)$ 表示在 $n+1$ 个等距节点 $x_{k}=-1+\\dfrac{2k}{n}$（其中 $k=0,1,\\dots,n$）上对 $f(x)$ 进行插值的唯一多项式，其次数至多为 $n$。定义积分绝对插值误差为\n$$\nE(n)=\\int_{-1}^{1}\\left|f(x)-P_{n}(x)\\right|\\,dx.\n$$\n定义交叉次数 $N_{\\text{crit}}$ 为指定搜索范围内的最小整数 $n$，使得增加一个等距插值节点会严格增大积分误差，具体定义如下：\n$$\nE(n+1)  \\left(1+\\tau\\right) E(n),\n$$\n其中 $\\tau$ 是一个固定的相对裕度。如果在指定范围内不存在这样的 $n$，则设 $N_{\\text{crit}}=-1$。\n\n你的任务是为下面列出的每个测试用例计算 $N_{\\text{crit}}$。定义 $E(n)$ 的积分必须在 $[-1,1]$ 上进行数值计算，其绝对误差不大于 $10^{-6}$。\n\n测试套件（每一项是一个三元组 $(a,n_{\\min},n_{\\max})$，指定了龙格参数和包含端点的次数搜索范围）：\n- 情况 $1$：$(a,n_{\\min},n_{\\max})=(25,2,80)$\n- 情况 $2$：$(a,n_{\\min},n_{\\max})=(5,2,80)$\n- 情况 $3$：$(a,n_{\\min},n_{\\max})=(100,2,80)$\n- 情况 $4$：$(a,n_{\\min},n_{\\max})=(1,2,10)$\n\n在 $N_{\\text{crit}}$ 的定义中使用相对裕度 $\\tau=10^{-4}$。对于每种情况，确定满足 $n_{\\min} \\le n  n_{\\max}$ 且 $E(n+1)\\left(1+\\tau\\right)E(n)$ 的最小整数 $n$；如果在指定范围内不存在这样的 $n$，则报告 $-1$。\n\n最终输出格式：你的程序应产生一行输出，其中按顺序包含四个结果，形式为用逗号分隔并用方括号括起来的列表，例如 $[N_{\\text{crit},1},N_{\\text{crit},2},N_{\\text{crit},3},N_{\\text{crit},4}]$，其中每个 $N_{\\text{crit},j}$ 都是一个整数。", "solution": "所提出的问题是计算物理和数值分析领域中的一个有效练习。该问题是适定的，有科学依据，并包含获得唯一解所需的所有必要信息。该任务涉及研究龙格函数 $f(x)=\\dfrac{1}{1+ax^2}$ 在区间 $[-1,1]$ 上的多项式插值中的龙格现象。具体来说，我们要确定“交叉次数”$N_{\\text{crit}}$，它被定义为在指定范围 $[n_{\\min}, n_{\\max}-1]$ 内，使得积分绝对误差 $E(n+1)$ 相较于 $E(n)$ 有显著增加的最小整数次数 $n$。这种现象——即使用高次多项式在等距节点上进行插值时，误差在区间边界附近会发散——是一个基本概念，它说明了朴素插值策略的局限性。\n\n解决此问题的方法是对所提供定义的直接计算实现。对于每个以参数 $a$ 和搜索范围 $[n_{\\min}, n_{\\max}]$ 为特征的测试用例，我们必须系统地计算次数为 $n$ 和 $n+1$ 时的积分误差 $E(n)$，并检查指定条件。\n\n首先，我们定义核心量，即对于给定次数 $n$ 的积分绝对插值误差：\n$$\nE(n) = \\int_{-1}^{1} \\left|f(x) - P_{n}(x)\\right|\\,dx\n$$\n此处，$f(x) = \\dfrac{1}{1+ax^2}$ 是待插值的函数。项 $P_n(x)$ 表示次数至多为 $n$ 的唯一插值多项式，该多项式穿过 $f(x)$ 曲线上的 $n+1$ 个特定点。这些点由 $n+1$ 个等距节点集合确定：\n$$\nx_k = -1 + \\frac{2k}{n}, \\quad k = 0, 1, \\dots, n\n$$\n对应的值为 $y_k = f(x_k)$。多项式 $P_n(x)$ 可以使用这些点对 $(x_k, y_k)$ 来构造。虽然拉格朗日 (Lagrange) 形式是经典的表示方法，但重心形式在数值上更稳定且计算效率更高，是高质量数值库中的标准选择。\n\n定义 $E(n)$ 的积分通常没有简单的解析闭式解。因此，其计算必须通过数值方法进行。一个稳健的自适应求积算法是合适的，例如 `scipy.integrate.quad` 中实现的算法，该算法基于 QUADPACK 例程。为了满足问题要求——即积分的计算绝对误差不大于 $10^{-6}$——数值积分子程序必须配置足够小的容差，例如，绝对容差为 $10^{-9}$。\n\n对于每个测试用例 $(a, n_{\\min}, n_{\\max})$ 和固定的相对裕度 $\\tau = 10^{-4}$，总体算法如下：\n1. 初始化交叉次数 $N_{\\text{crit}} = -1$。\n2. 遍历整数次数 $n$，从 $n_{\\min}$ 到 $n_{\\max}-1$。\n3. 在每次迭代中，计算误差积分 $E(n)$ 和 $E(n+1)$。为了优化，可以重用上一次迭代的 $E(n)$ 值。对于第一次迭代 $n=n_{\\min}$，必须同时计算 $E(n_{\\min})$ 和 $E(n_{\\min}+1)$。对于后续的迭代 $n  n_{\\min}$，$E(n)$ 的值已在上一步中作为 $E((n-1)+1)$ 计算过了。\n4. 检查交叉条件：\n   $$\n   E(n+1)  (1+\\tau) E(n)\n   $$\n5. 如果满足此条件，则当前次数 $n$ 就是满足条件的最小整数。我们设置 $N_{\\text{crit}} = n$ 并终止对该测试用例的搜索。\n6. 如果循环完成而条件从未被满足，$N_{\\text{crit}}$ 保持其初始值 $-1$。\n\n对所有四个测试用例重复此计算过程，并收集得到的 $N_{\\text{crit}}$ 值。参数 $a$ 控制 $f(x)$ 中峰值的尖锐程度。较大的 $a$ 值会导致更显著的龙格现象，我们预计误差会在较低的次数 $n$ 时开始发散，从而导致较小的 $N_{\\text{crit}}$。相反地，较小的 $a$ 会使函数更平滑，从而延迟发散的开始，这应该对应于较大的 $N_{\\text{crit}}$ 或在给定范围内没有交叉。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import BarycentricInterpolator\nfrom scipy.integrate import quad\n\ndef solve():\n    \"\"\"\n    Solves for the crossover degree N_crit for the Runge function interpolation error\n    across several test cases.\n    \"\"\"\n\n    def calculate_error(n: int, a: float) - float:\n        \"\"\"\n        Calculates the integrated absolute interpolation error E(n) for a given degree n and parameter a.\n\n        Args:\n            n: The degree of the interpolating polynomial.\n            a: The parameter of the Runge function.\n\n        Returns:\n            The value of the integral E(n).\n        \"\"\"\n        if n  0:\n            # A degree cannot be negative.\n            raise ValueError(\"Degree n must be non-negative.\")\n\n        # Define the Runge function f(x)\n        runge_func = lambda x: 1.0 / (1.0 + a * x**2)\n\n        # Generate n+1 equispaced nodes in [-1, 1]\n        x_nodes = np.linspace(-1.0, 1.0, n + 1)\n        y_nodes = runge_func(x_nodes)\n\n        # Construct the barycentric interpolating polynomial P_n(x)\n        poly = BarycentricInterpolator(x_nodes, y_nodes)\n\n        # Define the absolute error function |f(x) - P_n(x)|\n        error_func = lambda x: np.abs(runge_func(x) - poly(x))\n\n        # Numerically integrate the error function from -1 to 1.\n        # Set a small absolute tolerance to ensure the result is accurate to 1e-6 as required.\n        integral_val, _ = quad(error_func, -1.0, 1.0, epsabs=1e-9)\n\n        return integral_val\n\n    def find_Ncrit(a: float, n_min: int, n_max: int, tau: float) - int:\n        \"\"\"\n        Finds the smallest integer n in [n_min, n_max-1] such that E(n+1)  (1+tau)E(n).\n        \n        Args:\n            a: The parameter of the Runge function.\n            n_min: The minimum degree to start the search from.\n            n_max: The exclusive upper bound for the search degree n.\n            tau: The relative margin for error increase.\n            \n        Returns:\n            The crossover degree N_crit, or -1 if not found.\n        \"\"\"\n        N_crit = -1\n\n        # Check for valid range\n        if n_min = n_max:\n            return N_crit\n\n        # Use an error cache to avoid recomputing integrals\n        error_cache = {}\n\n        def get_E(n_val):\n            if n_val not in error_cache:\n                error_cache[n_val] = calculate_error(n_val, a)\n            return error_cache[n_val]\n        \n        # Loop n from n_min to n_max\n        for n in range(n_min, n_max):\n            E_n = get_E(n)\n            E_n_plus_1 = get_E(n + 1)\n\n            if E_n_plus_1  (1.0 + tau) * E_n:\n                N_crit = n\n                break  # Found the smallest n, terminate search for this case\n        \n        return N_crit\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (25, 2, 80),   # Case 1\n        (5, 2, 80),    # Case 2\n        (100, 2, 80),  # Case 3\n        (1, 2, 10),    # Case 4\n    ]\n    \n    # Relative margin\n    tau = 1e-4\n\n    results = []\n    for a, n_min, n_max in test_cases:\n        result = find_Ncrit(a, n_min, n_max, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436036"}, {"introduction": "在工程实践中，我们不仅用插值来拟合函数，还经常用它来估计导数，例如从位移数据计算速度。然而，高次插值多项式的振荡和不稳定性在求导时会被放大，使得导数估计变得不可靠，尤其是在处理含噪声数据时。这个练习 [@problem_id:2409024] 旨在探究误差在导数计算中的传播规律，并揭示了使用策略性放置的切比雪夫（Chebyshev）节点相较于等距节点所能带来的显著改进。", "problem": "一位计算工程师记录了一个机械系统在时间区间 $[-1,1]$ 上的一维位移信号 $s(t)$。已知该信号足够光滑，具体来说，对于某个 $m \\ge 2$，$s \\in C^{m}([-1,1])$。该工程师在 $[-1,1]$ 内的 $n+1$ 个不同节点 $x_0, x_1, \\dots, x_n$ 上对 $s(t)$ 进行采样，并构造一个次数至多为 $n$ 的唯一多项式 $p_n(t)$，该多项式对测量数据 $\\{(x_i, y_i)\\}_{i=0}^n$ 进行插值，其中 $y_i = s(x_i) + \\eta_i$。考虑了两种噪声模式：\n- 有界噪声：$|\\eta_i| \\le \\varepsilon$，其中 $\\varepsilon  0$ 为一固定值。\n- 随机噪声：$\\eta_i$ 是独立的、零均值的随机变量，其方差为 $\\operatorname{Var}(\\eta_i) = \\sigma^2$。\n\n工程师使用导数 $p_n'(t)$ 作为真实速度 $v(t) = s'(t)$ 的近似，并且在力计算的背景下，如果再次微分，则作为加速度的近似。假设工程师关心的是在一个固定的内点 $x_0 \\in (-1,1)$ 处的 $p_n'(x_0)$ 的值。考虑在 $[-1,1]$ 上选择等距节点和第一类 Chebyshev 节点两种情况。\n\n下列关于误差传播到 $p_n'(x_0)$ 中的陈述中，哪些是正确的？选择所有适用项。\n\nA. 对于 $[-1,1]$ 上的等距节点和一个固定的内点 $x_0$，从数据扰动 $\\{\\eta_i\\}$（其中 $|\\eta_i| \\le \\varepsilon$）到导数误差 $|p_n'(x_0) - \\tilde p_n'(x_0)|$（其中 $\\tilde p_n$ 是扰动数据的插值多项式）的映射，其算子范数随着 $n$ 的增加而无界增长。\n\nB. 从等距节点切换到 Chebyshev 节点可以减少数据扰动到 $p_n'(x_0)$ 的最坏情况放大；特别是，使用 Chebyshev 节点的放大率最多以 $n$ 的多项式（而非指数）级别增长。\n\nC. 即使数据精确（$\\eta_i = 0$），如果 $s$ 在 $[-1,1]$ 上是解析的，并且节点是等距的，那么最大逐点导数误差 $\\max_{x \\in [-1,1]} |s'(x) - p_n'(x)|$ 必定随着 $n$ 的增加而单调递减至 $0$。\n\nD. 在独立、零均值、相同方差 $\\sigma^2$ 的随机噪声模型下，有 $\\operatorname{Var}(p_n'(x_0)) = \\sigma^2 \\sum_{i=0}^n \\left(\\ell_i'(x_0)\\right)^2$，其中 $\\ell_i$ 是所选节点的 Lagrange 基多项式。因此，对于等距节点，$p_n'(x_0)$ 的标准差会随着 $n$ 的增加而显著增长。", "solution": "首先必须验证问题陈述的科学合理性和一致性。\n\n### 第一步：提取已知条件\n- 一个位移信号 $s(t)$，它是 $C^{m}([-1,1])$ 类中的一个函数，其中整数 $m \\ge 2$。\n- 时间区间为 $[-1,1]$。\n- 在区间 $[-1,1]$ 内的一组 $n+1$ 个不同的插值节点 $\\{x_i\\}_{i=0}^n$。\n- 测量数据为 $(x_i, y_i)$，$i=0, \\dots, n$。\n- 测量数据与真实信号之间的关系是 $y_i = s(x_i) + \\eta_i$，其中 $\\eta_i$ 是一个噪声项。\n- 考虑了两种噪声模型：\n    1. 有界噪声：$|\\eta_i| \\le \\varepsilon$，其中 $\\varepsilon  0$ 为一个常数。\n    2. 随机噪声：$\\eta_i$ 是独立的、零均值（$\\mathbb{E}[\\eta_i] = 0$）的随机变量，具有相同方差 $\\operatorname{Var}(\\eta_i) = \\sigma^2$。\n- 通过数据点 $\\{(x_i, y_i)\\}_{i=0}^n$ 构造了一个次数至多为 $n$ 的插值多项式 $p_n(t)$。\n- 插值多项式的导数 $p_n'(t)$ 被用作真实速度 $s'(t)$ 的近似。\n- 分析集中于一个固定的内点 $x_0 \\in (-1,1)$ 处的导数误差。问题似乎暗示这个求值点 $x_0$ 也是插值节点之一。这是一个我们将尊重的记号选择。\n- 考虑了两组节点：$[-1,1]$ 上的等距节点和第一类 Chebyshev 节点。\n\n### 第二步：使用提取的已知条件进行验证\n该问题描述了数值分析和计算科学中的一个经典场景：使用多项式插值对带噪数据进行微分。在许多需要从采样测量中估计导数的工程应用中，这项任务是基础性的。\n\n- **科学依据**：该问题深深植根于多项式插值、数值微分和误差分析的理论。Lagrange 多项式、Chebyshev 节点、Runge 现象和误差传播等概念都是数学和工程学中标准、公认的主题。该问题在科学上是合理的。\n- **适定性**：对于 $n+1$ 个不同的节点，插值多项式 $p_n(t)$ 的存在性和唯一性是有保证的。所提出的问题是关于当节点数 $n$ 增加时误差度量的渐近行为，这些都是明确定义的数学问题。\n- **客观性**：问题以精确、客观的数学语言陈述。没有主观或含糊的术语。使用 $x_0$ 来表示一个特定节点和节点序列中的第一个元素，这个记号选择有点令人困惑，但不会造成逻辑矛盾，因为节点可以任意标记。对于 $[-1,1]$ 上的任何节点集，只要 $n1$，等距节点集和 Chebyshev 节点集都包含内点。可以选择其中一个点指定为 $x_0$ 进行分析。\n\n### 第三步：结论与行动\n问题陈述是有效的。这是一个数值分析领域中适定的、有科学依据的问题。现在可以推导解答。\n\n通过点 $\\{(x_i, y_i)\\}_{i=0}^n$ 的插值多项式 $p_n(t)$ 可以用 Lagrange 基写成：\n$$p_n(t) = \\sum_{i=0}^n y_i \\ell_i(t)$$\n其中 $\\ell_i(t)$ 是 Lagrange 基多项式，定义为\n$$\\ell_i(t) = \\prod_{j=0, j \\neq i}^n \\frac{t-x_j}{x_i-x_j}$$\n插值多项式的导数是：\n$$p_n'(t) = \\sum_{i=0}^n y_i \\ell_i'(t)$$\n设 $p_n^*(t)$ 是精确、无噪声数据的假设插值多项式，即 $p_n^*(t) = \\sum_{i=0}^n s(x_i) \\ell_i(t)$。对带噪数据进行插值的多项式是 $p_n(t) = \\sum_{i=0}^n (s(x_i) + \\eta_i) \\ell_i(t)$。由数据噪声 $\\eta_i$ 引起的多项式导数误差为：\n$$\\Delta p_n'(t) \\equiv p_n'(t) - p_n^{*\\prime}(t) = \\sum_{i=0}^n \\eta_i \\ell_i'(t)$$\n问题询问的是在一个固定内点 $x_0 \\in (-1,1)$ 处这个误差的大小。选项中将 $\\tilde{p}_n$ 称为扰动数据的插值多项式；我们将问题陈述中的 $p_n$ 等同于 $\\tilde{p}_n$，并将 $p_n^*$ 等同于未扰动的那个。因此，选项 A 中的量 $|p_n'(x_0) - \\tilde{p}_n'(x_0)|$ 对应于 $|\\Delta p_n'(x_0)| = |\\sum_{i=0}^n \\eta_i \\ell_i'(x_0)|$，其中一组数据具有 $\\eta_i=0$。\n\n现在我们逐一评估每个选项。\n\n**A. 对于 $[-1,1]$ 上的等距节点和一个固定的内点 $x_0$，从数据扰动 $\\{\\eta_i\\}$（其中 $|\\eta_i| \\le \\varepsilon$）到导数误差 $|p_n'(x_0) - \\tilde p_n'(x_0)|$（其中 $\\tilde p_n$ 是扰动数据的插值多项式）的映射，其算子范数随着 $n$ 的增加而无界增长。**\n\n导数的误差为 $\\Delta p_n'(x_0) = \\sum_{i=0}^n \\eta_i \\ell_i'(x_0)$。在有界噪声模型下，$|\\eta_i| \\le \\varepsilon$。最坏情况下的误差通过对所有可能的扰动取最大值得到：\n$$\\max_{|\\eta_i| \\le \\varepsilon} |\\Delta p_n'(x_0)| = \\max_{|\\eta_i| \\le \\varepsilon} \\left| \\sum_{i=0}^n \\eta_i \\ell_i'(x_0) \\right| = \\varepsilon \\sum_{i=0}^n |\\ell_i'(x_0)|$$\n从扰动向量 $\\vec{\\eta} = (\\eta_0, \\dots, \\eta_n)$（使用 $\\ell_\\infty$ 范数 $\\|\\vec{\\eta}\\|_\\infty = \\max_i |\\eta_i|$）到标量输出 $\\Delta p_n'(x_0)$ 的线性映射的算子范数是放大因子 $\\sum_{i=0}^n |\\ell_i'(x_0)|$。这个量是在点 $x_0$ 进行微分的条件数。\n对于 $[-1,1]$ 上的等距节点，数值分析中一个公认的结论是，这个条件数随 $n$呈指数增长。其根本原因与 Runge 现象有关；Lagrange 基函数的导数变得非常大，尤其是在边界附近，但即使在内点，增长也是指数级的。由于指数增长是无界的，所以该陈述是正确的。\n**结论：正确。**\n\n**B. 从等距节点切换到 Chebyshev 节点可以减少数据扰动到 $p_n'(x_0)$ 的最坏情况放大；特别是，使用 Chebyshev 节点的放大率最多以 $n$ 的多项式（而非指数）级别增长。**\n\n最坏情况下的放大因子是 $\\sum_{i=0}^n |\\ell_i'(x_0)|$。正如在 A 中所证，对于等距节点，该因子呈指数增长。对于第一类 Chebyshev 节点（$x_i = \\cos(\\frac{(2i+1)\\pi}{2(n+1)})$），插值多项式及其导数的行为要好得多。Lebesgue 常数 $\\Lambda_n = \\max_{x \\in [-1,1]} \\sum_{i=0}^n |\\ell_i(x)|$ 仅以 $O(\\log n)$ 的速度增长。微分的条件数 $\\sum_{i=0}^n |\\ell_i'(x_0)|$ 的表现也要好得多。对于任何固定点 $x_0 \\in [-1,1]$，已知这个和被一个关于 $n$ 的多项式所界定。具体来说，对于一个内点 $x_0 \\in (-1,1)$，该和的增长率为 $O(n^2)$。\n从等距节点的指数增长切换到 Chebyshev 节点的多项式（$O(n^2)$）增长，是误差放大率的一个显著降低。因此，该陈述是正确的。\n**结论：正确。**\n\n**C. 即使数据精确（$\\eta_i = 0$），如果 $s$ 在 $[-1,1]$ 上是解析的，并且节点是等距的，那么最大逐点导数误差 $\\max_{x \\in [-1,1]} |s'(x) - p_n'(x)|$ 必定随着 $n$ 的增加而单调递减至 $0$。**\n\n该陈述涉及的是近似误差，而不是数据噪声的传播。它声称对于任何解析函数 $s(t)$，基于等距节点的插值多项式导数 $p_n'(t)$ 都会一致且单调地收敛到真实导数 $s'(t)$。这是错误的。\n众所周知，对于等距节点，多项式插值并不能保证对所有解析函数都一致收敛。经典的反例是 Runge 函数，$s(x) = 1/(1+25x^2)$，对于该函数，最大插值误差 $\\max_{x \\in [-1,1]}|s(x) - p_n(x)|$ 在 $n \\to \\infty$ 时是发散的。导数的误差 $|s'(x) - p_n'(x)|$ 通常表现更差，因为微分会放大误差 $s(x) - p_n(x)$ 的高频振荡。因此，不能保证导数一致收敛到零。\n关于误差“必定单调递减”的附加声明也是错误的。数值方法中的误差很少表现出严格的单调行为；当参数 $n$ 改变时，它通常会振荡。\n**结论：不正确。**\n\n**D. 在独立、零均值、相同方差 $\\sigma^2$ 的随机噪声模型下，有 $\\operatorname{Var}(p_n'(x_0)) = \\sigma^2 \\sum_{i=0}^n \\left(\\ell_i'(x_0)\\right)^2$，其中 $\\ell_i$ 是所选节点的 Lagrange 基多项式。因此，对于等距节点，$p_n'(x_0)$ 的标准差会随着 $n$ 的增加而显著增长。**\n\n插值多项式的导数为 $p_n'(x_0) = \\sum_{i=0}^n y_i \\ell_i'(x_0)$。数据点为 $y_i = s(x_i) + \\eta_i$。由于 $s(x_i)$ 和 $\\ell_i'(x_0)$ 是确定性常数，因此 $p_n'(x_0)$ 的方差完全来自于噪声项 $\\eta_i$。\n$$\\operatorname{Var}(p_n'(x_0)) = \\operatorname{Var}\\left(\\sum_{i=0}^n (s(x_i) + \\eta_i) \\ell_i'(x_0)\\right) = \\operatorname{Var}\\left(\\sum_{i=0}^n \\eta_i \\ell_i'(x_0)\\right)$$\n由于噪声项 $\\eta_i$ 是独立的，和的方差等于方差的和：\n$$\\operatorname{Var}(p_n'(x_0)) = \\sum_{i=0}^n \\operatorname{Var}(\\eta_i \\ell_i'(x_0)) = \\sum_{i=0}^n (\\ell_i'(x_0))^2 \\operatorname{Var}(\\eta_i)$$\n已知对于所有 $i$ 都有 $\\operatorname{Var}(\\eta_i) = \\sigma^2$，我们得到：\n$$\\operatorname{Var}(p_n'(x_0)) = \\sum_{i=0}^n (\\ell_i'(x_0))^2 \\sigma^2 = \\sigma^2 \\sum_{i=0}^n (\\ell_i'(x_0))^2$$\n陈述的第一部分是正确的。\n标准差为 $\\operatorname{StdDev}(p_n'(x_0)) = \\sqrt{\\operatorname{Var}(p_n'(x_0))} = \\sigma \\sqrt{\\sum_{i=0}^n (\\ell_i'(x_0))^2}$。\n项 $\\sqrt{\\sum_{i=0}^n (\\ell_i'(x_0))^2}$ 是在 $x_0$ 处求值的导数基函数向量的欧几里得范数（$\\ell_2$-范数）。正如在 A 部分所确立的，对于等距节点，该向量的 $\\ell_1$-范数 $\\sum_{i=0}^n |\\ell_i'(x_0)|$ 呈指数增长。根据有限维向量空间（$\\mathbb{R}^{n+1}$ 上的 $\\|\\cdot\\|_1$ 和 $\\|\\cdot\\|_2$）中范数的等价性，我们有 $\\|\\mathbf{v}\\|_2 \\le \\|\\mathbf{v}\\|_1 \\le \\sqrt{n+1}\\|\\mathbf{v}\\|_2$。由于 $\\|\\mathbf{v}\\|_1$ 呈指数增长，而 $\\sqrt{n+1}$ 仅呈多项式增长，因此 $\\|\\mathbf{v}\\|_2$ 也必须呈指数增长。因此，导数误差的标准差呈指数增长，即“显著”增长。陈述的第二部分也是正确的。\n**结论：正确。**", "answer": "$$\\boxed{ABD}$$", "id": "2409024"}, {"introduction": "除了龙格现象等理论限制外，有限精度的计算机算术这一实际因素也加剧了高次插值的困境。在实践中，诸如为密集节点计算均差等操作，可能会引发灾难性抵消（catastrophic cancellation），从而摧毁计算出的多项式系数的准确性。通过这个编码挑战 [@problem_id:2409001]，你将研究浮点误差如何导致插值方案彻底失败，即便在理论上它们本应表现良好，这凸显了数值稳定性在计算方法中的关键作用。", "problem": "一项计算任务是量化有限精度算术在使用均差表示的牛顿基中，对高阶插值多项式的构建和求值有何影响。请在由美国电气和电子工程师协会（IEEE）$754$ binary64 格式指定的标准双精度算术下工作，并将所有运算和结果视为在该模型中发生。对于给定的节点集 $\\{x_k\\}_{k=0}^n \\subset \\mathbb{R}$ 和函数 $f:\\mathbb{R}\\to\\mathbb{R}$，在牛顿基中次数至多为 $n$ 的唯一插值多项式 $p_n$ 定义为\n$$\np_n(x) \\;=\\; \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j),\n$$\n其中 $c_k$ 是标准数学意义上的第 $k$ 阶均差 $f[x_0,\\dots,x_k]$。所有量必须以双精度进行数值计算和求值。\n\n对于下述每个测试用例，为指定的函数 $f$ 和节点构建 $p_n$，然后在所述区间的 $m$ 个点组成的均匀求值网格上对 $p_n$ 和 $f$ 进行求值，并计算最大绝对求值误差\n$$\nE \\;=\\; \\max_{t \\in T} \\big|p_n(t) - f(t)\\big|,\n$$\n其中 $T$ 是求值网格。如果在任何阶段出现非有限值（例如，任何系数 $c_k$ 不是有限的，或 $p_n$ 的任何求值结果不是有限的），则该测试用例报告 $E = +\\infty$。\n\n测试套件：\n- 用例 A（等距节点和已知在等距插值下会振荡的函数的一般行为）：在 $[-1,1]$ 上，$f(x) = \\dfrac{1}{1+25x^2}$，节点 $x_k$ 在 $[-1,1]$ 上等距分布，$n=20$（即 $21$ 个节点），以及 $m=1001$ 个在 $[-1,1]$ 上均匀分布的求值点。\n- 用例 B（解析函数的良态节点）：在 $[-1,1]$ 上，$f(x) = e^x$，节点为 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{n}\\right)$（第二类 Chebyshev 节点），$n=30$，以及 $m=1001$ 个在 $[-1,1]$ 上均匀分布的求值点。\n- 用例 C（强节点聚集以探究均差的敏感性）：在 $[0,1]$ 上，$f(x) = \\sin(x)$，节点为 $x_k = 10^{-k}$，$k=18,17,\\dots,0$（即从 $10^{-18}$ 严格递增到 $10^0$），$n=18$，以及 $m=1001$ 个在 $[0,1]$ 上均匀分布的求值点。\n- 用例 D（解析函数使用良态节点的非常高次插值）：在 $[-1,1]$ 上，$f(x) = e^x$，节点为 $x_k = \\cos\\!\\left(\\dfrac{k\\pi}{n}\\right)$，$n=80$，以及 $m=1001$ 个在 $[-1,1]$ 上均匀分布的求值点。\n\n您的程序必须按顺序产生对应于上述用例的四个结果，每个结果是该用例定义的标量 $E$。最终输出格式必须是单行，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[E_A,E_B,E_C,E_D]$。", "solution": "所提出的问题要求在有限精度算术的约束下验证多项式插值方法，这是计算工程和数值分析中的一个基本课题。任务是为给定的函数和节点集，在牛顿基中构建插值多项式 $p_n(x)$，然后在精细的求值网格上量化其与真实函数的最大绝对误差 $E$。所有计算都将使用标准的 IEEE $754$ 双精度浮点算术执行。\n\n穿过 $n+1$ 个点 $\\{(x_k, f(x_k))\\}_{k=0}^n$ 的次数至多为 $n$ 的插值多项式 $p_n(x)$ 是唯一确定的。在牛顿基中，其形式为：\n$$\np_n(x) \\;=\\; \\sum_{k=0}^{n} c_k \\prod_{j=0}^{k-1} (x - x_j)\n$$\n对于数值构建而言，这种表示通常优于单项式基，因为后者常导致一个严重病态的范德蒙矩阵。\n\n系数 $c_k$ 是均差，定义为 $c_k = f[x_0, \\dots, x_k]$。它们通过递归计算得出：\n$$\nf[x_i] \\;=\\; f(x_i)\n$$\n$$\nf[x_i, \\dots, x_j] \\;=\\; \\frac{f[x_{i+1}, \\dots, x_j] - f[x_i, \\dots, x_{j-1}]}{x_j - x_i}\n$$\n在数值上，这些系数是通过构建一个均差表生成的。所需的系数 $c_k = f[x_0, \\dots, x_k]$ 构成了此表的顶层对角线。\n\n一旦确定了系数 $\\{c_k\\}_{k=0}^n$，就在指定的求值网格 $T$ 中的每个点 $t$ 处对多项式 $p_n(x)$ 进行求值。为了数值稳定性和效率，求值过程使用霍纳方法（嵌套求值）进行：\n$$\np_n(t) = ((\\dots(c_n(t-x_{n-1}) + c_{n-1})(t-x_{n-2}) + \\dots) + c_1)(t-x_0) + c_0\n$$\n与直接对各项求和相比，该方法能最小化算术运算次数，并减少浮点误差的累积。\n\n最终误差计算为 $E = \\max_{t \\in T} |p_n(t) - f(t)|$。如果在任何阶段产生了非有限值（如 `Infinity` 或 `NaN`），该用例的误差将报告为 $E = +\\infty$。\n\n四个测试用例旨在探究此数值过程的不同方面：\n\n用例 A：$f(x) = \\frac{1}{1+25x^2}$，在 $[-1, 1]$ 上有 $n=20$ 个等距节点。这是 Runge 现象的典型例子。对于此函数，使用等距节点的高阶多项式插值在区间端点附近会发散，导致剧烈振荡和巨大的误差 $E$。这本身是近似的一个性质，而有限精度效应会加剧该问题。\n\n用例 B：$f(x) = e^x$，在 $[-1, 1]$ 上有 $n=30$ 个 Chebyshev 节点。函数 $e^x$ 在整个复平面上是解析的。在精确算术中，已知对解析函数使用 Chebyshev 节点进行插值会以指数级速度收敛。Chebyshev 节点 $x_k = \\cos(k\\pi/n)$ 在端点附近聚集，这正是抵消 Runge 现象所需要的。因此，预计会得到一个非常小的误差 $E$，表明这是一个良态问题。\n\n用例 C：$f(x) = \\sin(x)$，$n=18$，节点为 $x_k = 10^{-k}$，$k=18,17,\\dots,0$。这些节点在 $x=0$ 附近极度聚集。均差的递归计算涉及形式为 $x_j - x_i$ 的分母，其值会非常小。此外，分子代表了几乎相等的值的差，会遭受灾难性抵消，导致相对精度的严重损失。这种严重的数值不稳定性预计会破坏系数 $c_k$，可能使其变为非有限值或产生一个巨大且无意义的误差 $E$。\n\n用例 D：$f(x) = e^x$，在 $[-1, 1]$ 上有 $n=80$ 个 Chebyshev 节点。此用例将用例 B 扩展到了一个更高的次数。尽管理论预测会继续收敛，但该测试挑战了双精度算术下稳定性的极限。即使使用最优节点，对于像 $n=80$ 这样的高次，经过多次运算后微小浮点误差的累积也可能变得显著。此用例将揭示即使在有利条件下高阶插值的实际限制。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_newton_coeffs(x_nodes: np.ndarray, y_nodes: np.ndarray) - np.ndarray:\n    \"\"\"\n    Computes the coefficients of the Newton interpolating polynomial.\n    \n    Args:\n        x_nodes: The interpolation nodes (n+1 points).\n        y_nodes: The function values at the interpolation nodes (n+1 values).\n    \n    Returns:\n        An array of the n+1 Newton coefficients.\n    \"\"\"\n    n = len(x_nodes)\n    # Use a copy to avoid modifying the original y_nodes array if it was passed.\n    # Ensure all calculations are done in float64.\n    coeffs = np.copy(y_nodes).astype(np.float64)\n    \n    # Iterate to compute the divided differences\n    for j in range(1, n):\n        for i in range(n - 1, j - 1, -1):\n            denominator = x_nodes[i] - x_nodes[i - j]\n            # The problem statement guarantees distinct nodes, but in a general\n            # setting, a zero denominator would lead to non-finite results.\n            # numpy handles division by zero, resulting in inf, which is\n            # handled later as per the problem requirements.\n            coeffs[i] = (coeffs[i] - coeffs[i - 1]) / denominator\n            \n    return coeffs\n\ndef evaluate_newton_poly(x_nodes: np.ndarray, coeffs: np.ndarray, t_eval: np.ndarray) - np.ndarray:\n    \"\"\"\n    Evaluates the Newton polynomial at given points using Horner's method.\n    \n    Args:\n        x_nodes: The interpolation nodes.\n        coeffs: The Newton coefficients.\n        t_eval: The points at which to evaluate the polynomial.\n        \n    Returns:\n        The polynomial values at the evaluation points.\n    \"\"\"\n    n = len(coeffs)\n    p_values = np.zeros_like(t_eval, dtype=np.float64)\n    \n    for i, t in enumerate(t_eval):\n        # Horner's method for a single evaluation point t\n        val = coeffs[n - 1]\n        for k in range(n - 2, -1, -1):\n            val = val * (t - x_nodes[k]) + coeffs[k]\n        p_values[i] = val\n        \n    return p_values\n\ndef solve():\n    \"\"\"\n    Solves the interpolation problem for all four specified test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Runge's phenomenon\n        {\n            'f': lambda x: 1.0 / (1.0 + 25.0 * x**2),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 20,\n            'node_type': 'equidistant',\n            'm': 1001\n        },\n        # Case B: Well-conditioned problem\n        {\n            'f': lambda x: np.exp(x),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 30,\n            'node_type': 'chebyshev',\n            'm': 1001\n        },\n        # Case C: Extreme node clustering\n        {\n            'f': lambda x: np.sin(x),\n            'interval': np.array([0.0, 1.0], dtype=np.float64),\n            'n': 18,\n            'node_type': 'custom_clustered',\n            'm': 1001\n        },\n        # Case D: Very high degree with good nodes\n        {\n            'f': lambda x: np.exp(x),\n            'interval': np.array([-1.0, 1.0], dtype=np.float64),\n            'n': 80,\n            'node_type': 'chebyshev',\n            'm': 1001\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        n = case['n']\n        f = case['f']\n        interval = case['interval']\n        m = case['m']\n\n        # Step 1: Generate interpolation nodes\n        if case['node_type'] == 'equidistant':\n            x_nodes = np.linspace(interval[0], interval[1], n + 1, dtype=np.float64)\n        elif case['node_type'] == 'chebyshev':\n            k = np.arange(n + 1, dtype=np.float64)\n            # Chebyshev nodes of the second kind on [-1, 1]\n            x_nodes = np.cos(k * np.pi / n)\n        elif case['node_type'] == 'custom_clustered':\n            k = np.arange(18, -1, -1, dtype=np.float64)\n            x_nodes = 10.0**(-k)\n        \n        y_nodes = f(x_nodes)\n\n        # Step 2: Compute Newton coefficients\n        coeffs = compute_newton_coeffs(x_nodes, y_nodes)\n\n        # Check for non-finite coefficients\n        if not np.all(np.isfinite(coeffs)):\n            results.append(np.inf)\n            continue\n            \n        # Step 3: Evaluate polynomial and true function on the grid\n        t_eval = np.linspace(interval[0], interval[1], m, dtype=np.float64)\n        p_values = evaluate_newton_poly(x_nodes, coeffs, t_eval)\n\n        # Check for non-finite evaluation results\n        if not np.all(np.isfinite(p_values)):\n            results.append(np.inf)\n            continue\n            \n        f_values = f(t_eval)\n\n        # Step 4: Compute the maximum absolute error\n        error = np.max(np.abs(p_values - f_values))\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2409001"}]}