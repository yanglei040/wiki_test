{"hands_on_practices": [{"introduction": "高斯求积的“魔力”源于其与正交多项式的深厚联系。这个练习将通过编程实践，让你亲手验证这一核心理论。通过使用高斯-勒让德求积法则来计算勒让德多项式的内积，你将直接观察到求积法则的精度阶是如何确保当被积函数是特定阶数的多项式时，数值积分能够达到机器精度 [@problem_id:2419561]。", "problem": "实现一个程序，对于指定的阶数对，使用高斯求积法 (GQ) 数值计算两个勒让德多项式的内积积分。设 $P_n(x)$ 表示在区间 $[-1,1]$ 上的 $n$ 阶勒让德多项式，其标准归一化为 $P_n(1)=1$。定义内积为\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx.\n$$\n您的任务是使用在 $[-1,1]$ 上的 $N$ 点高斯-勒让德求积法则（即在 $[-1,1]$ 上权重函数为 $w(x)=1$ 的高斯求积法）计算 $J_{m,n}$ 的数值近似值。高斯求积和的形式为\n$$\nQ_N[f] \\equiv \\sum_{i=1}^{N} w_i\\,f(x_i),\n$$\n其中 $\\{x_i\\}_{i=1}^N \\subset (-1,1)$ 是高斯-勒让德节点，$\\{w_i\\}_{i=1}^N$ 是相应的正权重。\n\n从第一性原理出发，回顾与此任务相关的以下基本依据：\n- 勒让德多项式 $\\{P_n(x)\\}_{n\\ge 0}$ 在 $[-1,1]$ 上相对于常数权重 $w(x)=1$ 形成一个正交序列。\n- $N$ 点高斯-勒让德求积法则对于所有阶数至多为 $d$ 的多项式都是精确的，其中 $d$ 取决于 $N$ 和该法则的构造，并使用 $P_N(x)$ 的根作为节点。\n\n您的程序必须：\n- 对于每个测试用例 $(m,n,N)$，使用数值生成的高斯-勒让德节点和权重来计算 $Q_N[P_m P_n]$。\n- 返回原始求积值（浮点数），除了标准的双精度算术外，不进行任何后处理或舍入。\n\n测试套件：\n- 用例 1：$(m,n,N)=(2,3,3)$。\n- 用例 2：$(m,n,N)=(0,1,1)$。\n- 用例 3：$(m,n,N)=(10,9,10)$。\n- 用例 4：$(m,n,N)=(4,6,2)$。\n- 用例 5：$(m,n,N)=(7,7,8)$。\n\n覆盖性设计：\n- 用例 1、2 和 3 使用足够多的节点，以通过高斯求积法捕捉作为多项式的 $P_m(x)P_n(x)$ 的积分，并探测不同的奇偶性组合以及更高的阶数。\n- 用例 4 故意使用过少的节点，以揭示欠积分对偶函数被积函数的影响。\n- 用例 5 使用相等的阶数来探测由求积法捕获的非零自身内积。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含按上述测试套件顺序排列的结果，格式为方括号内以逗号分隔的列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_k$ 是对应案例的求积法返回的浮点值。", "solution": "如题所述，问题是使用 $N$ 点高斯-勒让德求积法则来数值逼近两个勒让德多项式的内积积分，该积分定义为\n$$\nJ_{m,n} \\equiv \\int_{-1}^{1} P_m(x)\\,P_n(x)\\,dx\n$$\n要积分的函数是 $f(x) = P_m(x) P_n(x)$。数值近似由以下求和给出\n$$\nQ_N[f] = \\sum_{i=1}^{N} w_i\\,f(x_i)\n$$\n其中 $\\{x_i\\}_{i=1}^N$ 是求积节点，$\\{w_i\\}_{i=1}^N$ 是在区间 $[-1, 1]$ 上对应的权重。\n\n首先，我们必须回顾支配这个问题的基本原理。勒让德多项式，对于阶数 $n \\ge 0$ 表示为 $P_n(x)$，在区间 $[-1, 1]$ 上相对于单位权重函数 $w(x) = 1$，构成了平方可积函数空间的完备正交基。其正交关系由下式给出\n$$\n\\int_{-1}^{1} P_m(x) P_n(x) dx = \\frac{2}{2n+1} \\delta_{mn}\n$$\n其中 $\\delta_{mn}$ 是克罗内克δ函数，当 $m=n$ 时为 $1$，当 $m \\neq n$ 时为 $0$。这是积分 $J_{m,n}$ 的精确解析值。\n\n其次，$N$ 点高斯-勒让德求积法的构造使其对于任何阶数最高为 $2N-1$ 的多项式都是精确的。我们问题中的被积函数 $f(x) = P_m(x) P_n(x)$ 本身是一个阶数为 $m+n$ 的多项式。因此，当且仅当被积函数的阶数不超过求积法则的精度阶数时，数值求积 $Q_N[P_m P_n]$ 将得出积分 $J_{m,n}$ 的精确值。也就是说，如果满足以下条件，则近似是精确的\n$$\nm+n \\le 2N-1\n$$\n当满足此条件时，数值结果必须与正交性所决定的解析结果相匹配。如果 $m+n > 2N-1$，则不能保证求积是精确的，并且会产生一个其精度取决于 $N$ 和被积函数具体性质的近似值。\n\n我们现在将此理论框架应用于每个测试用例。\n\n**用例 1: $(m,n,N) = (2,3,3)$**\n被积函数的阶数是 $m+n = 2+3 = 5$。\n$N=3$ 点求积的精确阶数是 $2N-1 = 2(3)-1 = 5$。\n由于 $m+n \\le 2N-1$（具体来说，$5 \\le 5$），求积是精确的。\n因为 $m=2 \\neq n=3$，积分的解析值为 $J_{2,3} = 0$。\n因此，计算值 $Q_3[P_2 P_3]$ 在浮点精度限制内必须为 $0$。\n\n**用例 2: $(m,n,N) = (0,1,1)$**\n被积函数的阶数是 $m+n = 0+1 = 1$。\n$N=1$ 点求积的精确阶数是 $2N-1 = 2(1)-1 = 1$。\n满足条件 $m+n \\le 2N-1$（$1 \\le 1$），所以求积是精确的。\n因为 $m=0 \\neq n=1$，解析值为 $J_{0,1} = 0$。\n计算值 $Q_1[P_0 P_1]$ 必须为 $0$。\n\n**用例 3: $(m,n,N) = (10,9,10)$**\n被积函数的阶数是 $m+n = 10+9 = 19$。\n$N=10$ 点求积的精确阶数是 $2N-1 = 2(10)-1 = 19$。\n满足条件 $m+n \\le 2N-1$（$19 \\le 19$），所以求积是精确的。\n因为 $m=10 \\neq n=9$，解析值为 $J_{10,9} = 0$。\n计算值 $Q_{10}[P_{10} P_9]$ 必须为 $0$。\n\n**用例 4: $(m,n,N) = (4,6,2)$**\n被积函数的阶数是 $m+n = 4+6 = 10$。\n$N=2$ 点求积的精确阶数是 $2N-1 = 2(2)-1 = 3$。\n这里，$m+n > 2N-1$ ($10 > 3$)，所以求积**不**精确。我们预期一个非零结果，这展示了欠积分的后果。解析结果是 $J_{4,6} = 0$，但数值方法不足以捕捉到这一点。\n对于 $N=2$，节点是 $P_2(x) = \\frac{1}{2}(3x^2-1)$ 的根，即 $x_{1,2} = \\pm 1/\\sqrt{3}$。权重是 $w_{1,2} = 1$。\n求积和为 $Q_2[P_4 P_6] = w_1 P_4(x_1)P_6(x_1) + w_2 P_4(x_2)P_6(x_2)$。\n$Q_2[P_4 P_6] = (1) \\cdot P_4(-1/\\sqrt{3})P_6(-1/\\sqrt{3}) + (1) \\cdot P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$。\n因为当 $n$ 为偶数时，$P_n(x)$ 是一个偶函数，所以 $P_n(-x) = P_n(x)$。因此，和简化为 $2 P_4(1/\\sqrt{3})P_6(1/\\sqrt{3})$。\n使用标准定义 $P_4(x) = \\frac{1}{8}(35x^4 - 30x^2 + 3)$ 和 $P_6(x) = \\frac{1}{16}(231x^6 - 315x^4 + 105x^2 - 5)$，我们在 $x=1/\\sqrt{3}$ 处求值：\n$P_4(1/\\sqrt{3}) = \\frac{1}{8}\\left(35(\\frac{1}{9}) - 30(\\frac{1}{3}) + 3\\right) = \\frac{1}{8}\\left(\\frac{35}{9} - 10 + 3\\right) = \\frac{1}{8}\\left(\\frac{35-63}{9}\\right) = -\\frac{28}{72} = -\\frac{7}{18}$。\n$P_6(1/\\sqrt{3}) = \\frac{1}{16}\\left(231(\\frac{1}{27}) - 315(\\frac{1}{9}) + 105(\\frac{1}{3}) - 5\\right) = \\frac{1}{16}\\left(\\frac{77}{9} - 35 + 35 - 5\\right) = \\frac{1}{16}\\left(\\frac{77-45}{9}\\right) = \\frac{32}{144} = \\frac{2}{9}$。\n结果是 $Q_2[P_4 P_6] = 2 \\cdot (-\\frac{7}{18}) \\cdot (\\frac{2}{9}) = -\\frac{28}{162} = -\\frac{14}{81} \\approx -0.1728395$。\n\n**用例 5: $(m,n,N) = (7,7,8)$**\n被积函数的阶数是 $m+n = 7+7 = 14$。\n$N=8$ 点求积的精确阶数是 $2N-1 = 2(8)-1 = 15$。\n满足条件 $m+n \\le 2N-1$（$14 \\le 15$），所以求积是精确的。\n因为 $m=n=7$，解析值非零：\n$J_{7,7} = \\frac{2}{2(7)+1} = \\frac{2}{15}$。\n计算值 $Q_8[P_7 P_7]$ 必须等于 $\\frac{2}{15} \\approx 0.133333...$。\n\n计算过程将涉及：对于给定的 $N$ 请求相应的高斯-勒让德节点和权重，在这些节点上计算两个指定勒让德多项式的乘积，并执行加权求和。像 `SciPy` 这样的库为生成求积法则和勒让德多项式提供了稳健的实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import legendre, roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations of the inner product of Legendre polynomials\n    using Gauss-Legendre quadrature for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (m, n, N) where m and n are the polynomial\n    # degrees and N is the number of quadrature points.\n    test_cases = [\n        (2, 3, 3),   # Case 1\n        (0, 1, 1),   # Case 2\n        (10, 9, 10), # Case 3\n        (4, 6, 2),   # Case 4\n        (7, 7, 8),   # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        m, n, N = case\n\n        # Generate the N-point Gauss-Legendre quadrature nodes and weights.\n        # roots_legendre(N) returns the roots of P_N(x) and the corresponding weights.\n        nodes, weights = roots_legendre(N)\n        \n        # Create callable Legendre polynomial functions for degrees m and n.\n        # The standard normalization P_k(1) = 1 is default in scipy.special.legendre.\n        P_m = legendre(m)\n        P_n = legendre(n)\n\n        # Evaluate the integrand, which is the product of the two polynomials,\n        # at the quadrature nodes.\n        integrand_values = P_m(nodes) * P_n(nodes)\n\n        # Compute the quadrature sum: sum(w_i * f(x_i)).\n        # This is the numerical approximation of the integral.\n        # np.dot is an efficient way to compute the sum of element-wise products.\n        integral_approximation = np.dot(weights, integrand_values)\n        \n        results.append(integral_approximation)\n\n    # Final print statement in the exact required format.\n    # The format is a comma-separated list of floating-point numbers\n    # enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2419561"}, {"introduction": "从理想的多项式情形过渡到更现实的场景，我们经常需要处理复杂的非多项式函数。在这种情况下，高斯求积提供的是一个近似值，而理解其误差是至关重要的。本练习将指导你对一个超越函数的积分进行完整的误差分析，包括计算实际误差并将其与理论误差界限进行比较 [@problem_id:2419598]，这个过程会让你深刻理解高斯求积在实际应用中的精度和可靠性。", "problem": "考虑定义在实数 $x$ 上的函数 $f(x) = e^{\\cos(x)}$，其中角度以弧度为单位。令 $[a,b] = [0,2\\pi]$，并令 $n$ 表示应用于近似定积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)}\\,dx$ 的高斯-勒让德求积法则中的节点数。对于每个指定的 $n$ 值，从第一性原理出发，以数学上一致的方式执行以下所有任务：\n\n1. 在区间 $[0,2\\pi]$ 上，使用 $n$ 点高斯-勒让德法则计算 $I$ 的高斯求积近似值 $Q_n$。\n2. 以标准特殊函数的形式计算积分 $I$ 的精确值的闭式解，并将其用作数值评估的基准真相（ground truth）。\n3. 计算绝对误差 $E_{\\mathrm{abs}} = |I - Q_n|$。\n4. 根据 $n$ 点高斯-勒让德法则的经典误差理论，计算 $|I - Q_n|$ 的一个严格上界 $B_n$。该上界必须用 $f$ 的 $(2n)$ 阶导数在 $x \\in [0,2\\pi]$ 上的绝对值的上确界以及区间长度来表示，这是高斯-勒让德求积误差分析的标准做法。任何能够获得此上确界的正确数值的数学上有效的方法都是可接受的。\n5. 判断 $E_{\\mathrm{abs}} \\le B_n$ 是否成立。\n\n所有浮点结果必须报告为无量纲量。角度必须以弧度处理。\n\n测试套件。使用以下三种情况：\n- 情况1：$n = 1$。\n- 情况2：$n = 3$。\n- 情况3：$n = 5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个列表，每个测试用例对应一个条目，并按上面列出的顺序排列。每个条目本身必须是一个形式为 $[n, Q_n, I, E_{\\mathrm{abs}}, B_n, \\mathrm{within}]$ 的列表，其中 $n$ 是一个整数，$Q_n$、$I$、$E_{\\mathrm{abs}}$ 和 $B_n$ 是四舍五入到十二位小数的浮点数，如果 $E_{\\mathrm{abs}} \\le B_n$，则 $\\mathrm{within}$ 是整数 $1$，否则为 $0$。因此，整行必须具有以下形式：\n[ [n1,Qn1,I1,Eabs1,Bn1,within1], [n2,Qn2,I2,Eabs2,Bn2,within2], [n3,Qn3,I3,Eabs3,Bn3,within3] ]。", "solution": "问题陈述已经过分析，并被认为是有效的。这是一个数值分析中的适定问题，它基于成熟的数学原理，并包含获得唯一解所需的所有必要信息。我们将基于第一性原理，进行系统性的、分步的求解。\n\n问题的核心是使用 $n$ 点高斯-勒让德求积法则来近似定积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)}\\,dx$，并将所得的绝对误差与其理论上界进行比较。\n\n首先，我们定义相关的函数和积分区间：\n- 被积函数是 $f(x) = e^{\\cos(x)}$。\n- 积分区间是 $[a, b] = [0, 2\\pi]$。\n\n对于每个指定的 $n$ 值，求解过程需要进行五项不同的计算：求积近似值 $Q_n$、积分精确值 $I$、绝对误差 $E_{\\mathrm{abs}}$、理论误差界 $B_n$ 以及对该界的验证。\n\n1.  **高斯-勒让德求积近似值 ($Q_n$)**\n    标准的 $n$ 点高斯-勒让德求积法则定义在区间 $[-1, 1]$ 上的积分为：\n    $$ \\int_{-1}^{1} g(t) \\,dt \\approx \\sum_{i=1}^{n} w_i g(t_i) $$\n    此处，$t_i$ 是 $n$ 阶勒让德多项式 $P_n(t)$ 的 $n$ 个根（节点），而 $w_i$ 是相应的权重。\n\n    为了将此法则应用于我们的积分 $I = \\int_{a}^{b} f(x) \\,dx$，我们必须对变量 $x \\in [a, b]$ 进行线性变换，将其转换为新变量 $t \\in [-1, 1]$。该变换为：\n    $$ x(t) = \\frac{b-a}{2}t + \\frac{a+b}{2} $$\n    微分元变换为 $dx = \\frac{b-a}{2}dt$。\n    对于我们的特定区间 $[0, 2\\pi]$，有 $a=0$ 和 $b=2\\pi$。该变换简化为：\n    $$ x(t) = \\frac{2\\pi-0}{2}t + \\frac{0+2\\pi}{2} = \\pi t + \\pi = \\pi(t+1) $$\n    微分是 $dx = \\pi dt$。\n\n    将此代入积分可得：\n    $$ I = \\int_{0}^{2\\pi} f(x) \\,dx = \\int_{-1}^{1} f(\\pi(t+1)) \\pi \\,dt $$\n    将高斯-勒让德求积法则应用于变换后的积分，得到近似值 $Q_n$：\n    $$ Q_n = \\pi \\sum_{i=1}^{n} w_i f(\\pi(t_i+1)) = \\pi \\sum_{i=1}^{n} w_i e^{\\cos(\\pi(t_i+1))} $$\n    节点 $t_i$ 和权重 $w_i$ 是标准的列表值，我们将通过计算获得。\n\n2.  **积分的精确值 ($I$)**\n    积分 $I = \\int_{0}^{2\\pi} e^{\\cos(x)} \\,dx$ 可以使用阶数为 $\\nu$ 的第一类修正Bessel函数（记为 $I_{\\nu}(z)$）的积分表示来求得闭式解：\n    $$ I_{\\nu}(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} \\cos(\\nu \\theta) \\,d\\theta $$\n    当阶数 $\\nu=0$ 时，上式简化为：\n    $$ I_0(z) = \\frac{1}{\\pi} \\int_{0}^{\\pi} e^{z \\cos(\\theta)} \\,d\\theta $$\n    被积函数 $e^{\\cos(x)}$ 是一个周期为 $2\\pi$ 的周期函数。在区间 $[0, 2\\pi]$ 上，它也关于 $x=\\pi$ 对称，因为 $\\cos(x) = \\cos(2\\pi - x)$。因此，在 $[0, 2\\pi]$ 上的积分是在 $[0, \\pi]$ 上积分的两倍：\n    $$ I = \\int_{0}^{2\\pi} e^{\\cos(x)} \\,dx = 2 \\int_{0}^{\\pi} e^{\\cos(x)} \\,dx $$\n    通过在 $I_0(z)$ 的定义中令 $z=1$，我们发现 $\\int_{0}^{\\pi} e^{\\cos(x)} \\,dx = \\pi I_0(1)$。\n    因此，积分的精确值为：\n    $$ I = 2\\pi I_0(1) $$\n    该值将作为我们的基准真相（ground truth）。\n\n3.  **绝对误差 ($E_{\\mathrm{abs}}$)**\n    绝对误差可以简单地计算为精确值 $I$ 和我们的近似值 $Q_n$ 之间的绝对差：\n    $$ E_{\\mathrm{abs}} = |I - Q_n| $$\n\n4.  **理论误差界 ($B_n$)**\n    应用于积分 $\\int_{a}^{b} f(x) \\,dx$ 的 $n$ 点高斯-勒让德求积法则的经典误差公式由下式给出：\n    $$ I - Q_n = \\frac{(b-a)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} f^{(2n)}(\\eta) $$\n    其中 $\\eta \\in (a, b)$。只要 $f(x)$ 在 $[a, b]$ 上是 $2n$ 次连续可微的，这样的 $\\eta$ 的存在性就得到保证，而我们的函数 $f(x) = e^{\\cos(x)}$ 满足此条件。\n\n    为了找到绝对误差的上界，我们取区间上导数项绝对值的上确界：\n    $$ B_n = \\frac{(b-a)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} \\sup_{x \\in [a,b]} |f^{(2n)}(x)| $$\n    对于我们的问题，当 $[a, b] = [0, 2\\pi]$ 时，上式变为：\n    $$ B_n = \\frac{(2\\pi)^{2n+1} (n!)^4}{(2n+1) [(2n)!]^3} \\sup_{x \\in [0, 2\\pi]} |f^{(2n)}(x)| $$\n    主要的挑战是计算 $(2n)$ 阶导数 $f^{(2n)}(x)$ 并找到其上确界。直接的解析方法极为繁琐。因此我们设计一种计算策略。\n\n    令 $D_k(x) = \\frac{f^{(k)}(x)}{e^{\\cos(x)}}$。使用乘积法则，我们可以推导出 $D_k(x)$ 的递推关系：\n    $$ f^{(k+1)}(x) = \\frac{d}{dx} \\left( e^{\\cos(x)} D_k(x) \\right) = e^{\\cos(x)}(-\\sin(x))D_k(x) + e^{\\cos(x)}D_k'(x) $$\n    两边除以 $e^{\\cos(x)}$ 得到递推式：\n    $$ D_{k+1}(x) = D_k'(x) - \\sin(x)D_k(x) $$\n    初始条件为 $D_0(x) = f^{(0)}(x)/f(x) = 1$。每个 $D_k(x)$ 都是一个关于 $\\sin(x)$ 和 $\\cos(x)$ 的多项式。我们将实现一个类符号微分过程来生成 $D_{2n}(x)$ 所需的系数。\n\n    一旦获得 $D_{2n}(x)$ 的表达式，就可以对函数 $g(x) = |f^{(2n)}(x)| = |e^{\\cos(x)} D_{2n}(x)|$ 进行数值评估。然后可以使用数值优化技术找到上确界 $\\sup_{x \\in [0, 2\\pi]} g(x)$。由于 $f^{(2n)}(x)$ 是一个周期为 $2\\pi$ 的偶函数，其在 $[0, 2\\pi]$ 上的上确界与其在 $[0, \\pi]$ 上的上确界相同。我们将通过计算找出 $g(x)$ 在 $[0, \\pi]$ 上的最大值，根据问题陈述，这是一种有效的方法。\n\n5.  **界验证**\n    最后一步是比较计算出的绝对误差 $E_{\\mathrm{abs}}$ 与理论界 $B_n$，并确定不等式 $E_{\\mathrm{abs}} \\le B_n$ 是否成立。如果成立，我们将一个二进制标志设置为 $1$，否则设置为 $0$。\n\n这样就完成了理论框架。实现将通过对每个测试用例（$n=1, 3, 5$）执行这些步骤来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import i0, roots_legendre, factorial\nfrom scipy.optimize import minimize_scalar\nfrom collections import defaultdict\n\ndef solve():\n    \"\"\"\n    Solves the Gaussian quadrature problem for f(x) = e^cos(x) on [0, 2*pi].\n    \"\"\"\n\n    class SinCosPoly:\n        \"\"\"\n        A class to represent and manipulate polynomials of sin(x) and cos(x).\n        A polynomial is stored as a dictionary mapping (sin_power, cos_power)\n        to a coefficient.\n        \"\"\"\n        def __init__(self, terms=None):\n            self.terms = defaultdict(float)\n            if terms:\n                self.terms.update(terms)\n\n        def __add__(self, other):\n            new_terms = self.terms.copy()\n            for k, v in other.terms.items():\n                new_terms[k] += v\n            return SinCosPoly(new_terms)\n\n        def __sub__(self, other):\n            new_terms = self.terms.copy()\n            for k, v in other.terms.items():\n                new_terms[k] -= v\n            return SinCosPoly(new_terms)\n\n        def differentiate(self):\n            \"\"\"Differentiates the polynomial with respect to x.\"\"\"\n            new_terms = defaultdict(float)\n            for (i, j), c in self.terms.items():\n                if i > 0: # a*sin(x)^(a-1)*cos(x)\n                    new_terms[(i - 1, j + 1)] += c * i\n                if j > 0: # -b*sin(x)^(b+1)*cos(x)^(b-1)\n                    new_terms[(i + 1, j - 1)] -= c * j\n            return SinCosPoly(new_terms)\n\n        def multiply_by_sin(self):\n            \"\"\"Multiplies the polynomial by sin(x).\"\"\"\n            new_terms = defaultdict(float)\n            for (i, j), c in self.terms.items():\n                new_terms[(i + 1, j)] = c\n            return SinCosPoly(new_terms)\n\n        def evaluate(self, x):\n            \"\"\"Evaluates the polynomial at a given x.\"\"\"\n            sin_x = np.sin(x)\n            cos_x = np.cos(x)\n            total = 0.0\n            for (i, j), c in self.terms.items():\n                total += c * (sin_x ** i) * (cos_x ** j)\n            return total\n\n    # Memoization cache for the derivative polynomials D_k\n    d_poly_cache = {}\n    \n    def get_d_poly(k):\n        \"\"\"\n        Computes the k-th derivative polynomial D_k using recurrence.\n        D_{k+1} = D_k' - sin(x)*D_k\n        \"\"\"\n        if k in d_poly_cache:\n            return d_poly_cache[k]\n        if k == 0:\n            d_poly_cache[0] = SinCosPoly({(0, 0): 1.0})\n            return d_poly_cache[0]\n        \n        d_k_minus_1 = get_d_poly(k - 1)\n        d_k = d_k_minus_1.differentiate() - d_k_minus_1.multiply_by_sin()\n        d_poly_cache[k] = d_k\n        return d_k\n\n    def get_f_derivative(k):\n        \"\"\"\n        Returns a function that computes the k-th derivative of f(x) = e^cos(x).\n        \"\"\"\n        d_k_poly = get_d_poly(k)\n        \n        def f_k(x):\n            return np.exp(np.cos(x)) * d_k_poly.evaluate(x)\n            \n        return f_k\n\n    # Problem parameters\n    a, b = 0.0, 2 * np.pi\n    test_cases = [1, 3, 5]\n    results = []\n    \n    # Exact integral value I = 2*pi*I_0(1)\n    I_exact = 2 * np.pi * i0(1)\n\n    for n in test_cases:\n        # Task 1: Compute Gaussian quadrature approximation Q_n\n        nodes, weights = roots_legendre(n)\n        x_nodes = np.pi * (nodes + 1)\n        f_values = np.exp(np.cos(x_nodes))\n        Q_n = np.pi * np.sum(weights * f_values)\n\n        # Task 2: Exact value I (already computed)\n        \n        # Task 3: Compute absolute error E_abs\n        E_abs = np.abs(I_exact - Q_n)\n        \n        # Task 4: Compute theoretical error bound B_n\n        m = 2 * n\n        \n        # Factorial calculations\n        n_fact = factorial(n)\n        m_fact = factorial(m)\n\n        # Constant part of the error bound formula\n        bound_constant = ((b - a)**(m + 1) * n_fact**4) / \\\n                         ((m + 1) * m_fact**3)\n\n        # Find supremum of |f^(2n)(x)| on [0, 2*pi]\n        # Since f^(2n) is even and 2pi-periodic, we search on [0, pi]\n        f_2n = get_f_derivative(m)\n        \n        # We need to maximize |f_2n(x)|, which is equivalent to\n        # minimizing -|f_2n(x)|.\n        opt_res = minimize_scalar(lambda x: -np.abs(f_2n(x)),\n                                  bounds=(0, np.pi), method='bounded')\n        \n        # Supremum is the max of values at boundaries and found minimum\n        sup_f_2n_abs = max(np.abs(f_2n(0)), np.abs(f_2n(np.pi)), -opt_res.fun)\n\n        B_n = bound_constant * sup_f_2n_abs\n        \n        # Task 5: Determine if E_abs <= B_n\n        is_within_bound = 1 if E_abs <= B_n else 0\n\n        # Format results for output, rounding floats to 12 decimal places\n        case_result = [\n            n,\n            round(Q_n, 12),\n            round(I_exact, 12),\n            round(E_abs, 12),\n            round(B_n, 12),\n            is_within_bound\n        ]\n        results.append(case_result)\n\n    # Format the final output string exactly as specified.\n    # We construct the string representation manually to avoid unwanted characters.\n    inner_strings = []\n    for res in results:\n        # Format numbers to string with 12 decimal places\n        formatted_floats = [f\"{v:.12f}\" for v in res[1:5]]\n        inner_strings.append(f\"[{res[0]},{','.join(formatted_floats)},{res[5]}]\")\n    \n    output_str = f\"[{','.join(inner_strings)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2419598"}, {"introduction": "在工程和物理学中，我们常常会遇到在积分区间内存在奇点的积分，这对标准数值方法构成了挑战。本练习将展示高斯求积框架的灵活性和强大功能。你将学习一种关键技巧——通过变量替换，将一个含有对数奇点 $\\ln(x)$ 的积分变换为一种适合使用高斯-拉盖尔求积法则解决的形式 [@problem_id:2419634]，从而高效地处理这类“棘手”的积分问题。", "problem": "设计并实现一个完整的程序，推导并应用一种自定义的高斯求积法，以精确近似如下形式的积分：\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx,$$\n其中 $f$ 在 $[0,1]$ 上是光滑的，并且被积函数在 $x=0$ 处具有对数奇异性。您的推导必须从适用于计算工程和数值分析的基本原理出发，即：定积分的变量替换公式、正交多项式的性质，以及针对给定权函数的高斯求积的基本定义。您不得预先假设或陈述任何直接针对对数奇异性的特殊求积法则；相反，您必须通过将积分变换为一个在无限区间上具有标准非负权重的积分，然后应用适当的高斯求积法来推导此法则。该方法必须基于所述的基本原理进行逻辑论证，并且必须在科学上是现实的。\n\n实现要求：\n- 从 $I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$ 出发，推导一个变量变换，将对数项移入一个定义在 $[0,\\infty)$ 上的积分的权函数中。\n- 识别在 $[0,\\infty)$ 上与变换后积分相匹配的正交多项式族和权函数，并解释为什么相应的高斯求积法是适用的。\n- 实现一个函数，对于给定的正整数 $n$，该函数使用为推导出的权函数定制的 $n$ 点高斯求积法，返回 $I[f]$ 的一个求积近似值 $Q_{n}[f]$。您可以使用编程环境中的任何标准例程来获取高斯求积的节点和权重。\n\n角度单位要求：\n- 当函数 $f$ 涉及正弦函数时，应将其参数解释为弧度。例如，在 $f(x) = \\sin(\\pi x)$ 中，$\\pi$ 以弧度为单位。\n\n测试套件：\n- 您的程序必须计算并返回以下五个测试用例的求积近似值 $Q_{n}[f]$：\n  1. $f(x) = 1$，其中 $n = 2$。\n  2. $f(x) = x$，其中 $n = 8$。\n  3. $f(x) = \\sin(\\pi x)$，其中 $n = 8$。\n  4. $f(x) = \\sin(\\pi x)$，其中 $n = 16$。\n  5. $f(x) = \\sin(\\pi x)$，其中 $n = 32$。\n- 所有计算都是无量纲的；没有物理单位。如前所述，对于三角函数，角度以弧度为单位。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表项为按上述测试用例顺序排列的结果。\n- 每个浮点数必须四舍五入到恰好 $12$ 位小数。\n- 例如，格式必须类似于\n$[\\text{value\\_1},\\text{value\\_2},\\text{value\\_3},\\text{value\\_4},\\text{value\\_5}]$，\n其中每个 $\\text{value\\_k}$ 都四舍五入到 $12$ 位小数，并且不打印任何额外文本。\n\n该问题具有普遍适用性：使用任何现代编程语言的开发人员都可以实现变量替换，获取在 $[0,\\infty)$ 上针对适当权函数的高斯求积节点和权重，在变换后的节点上评估 $f$，并构成加权和以生成所需的输出。最终答案是浮点数，因此是可量化的。\n\n您的最终程序必须是完整且可运行的，无需任何用户输入或外部数据，并且必须遵循上述确切的输出格式。", "solution": "该问题要求设计并实现一个数值求积方案，以近似积分\n$$I[f] = \\int_{0}^{1} \\ln(x)\\, f(x)\\, dx$$\n其中函数 $f(x)$ 在区间 $[0,1]$ 上是光滑的。被积函数在 $x=0$ 处具有对数奇异性，这使得标准的数值积分方法变得复杂。推导必须从基本原理出发，通过将积分变换为适合标准高斯求积法则的形式。\n\n问题陈述已经过验证，被认为是具有科学依据、良定且客观的。它为计算工程和数值分析中的一个标准问题提供了一套清晰、自洽的要求。因此，我们可以着手进行推导和求解。\n\n该方法的核心是应用变量替换，将给定的、定义在有限区间 $[0,1]$ 上且包含一个有问题的对数项的积分，转换为一个在无限区间 $[0, \\infty)$ 上、具有适用于高斯求积的非负权函数的等价积分。\n\n让我们引入替换 $x = e^{-t}$。由此可得 $dx = -e^{-t}\\, dt$。积分上下限也必须进行变换：\n- 当 $x \\to 0^{+}$ 时，我们有 $e^{-t} \\to 0^{+}$，这意味着 $t \\to \\infty$。\n- 当 $x \\to 1^{-}$ 时，我们有 $e^{-t} \\to 1^{-}$，这意味着 $t \\to 0^{+}$。\n\n将这些代入原始积分表达式中，我们得到：\n$$I[f] = \\int_{\\infty}^{0} \\ln(e^{-t})\\, f(e^{-t})\\, (-e^{-t}\\, dt)$$\n项 $\\ln(e^{-t})$ 化简为 $-t$。表达式变为：\n$$I[f] = \\int_{\\infty}^{0} (-t)\\, f(e^{-t})\\, (-e^{-t}\\, dt) = \\int_{\\infty}^{0} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\n通过反转积分上下限，我们引入一个负号：\n$$I[f] = - \\int_{0}^{\\infty} t\\, e^{-t}\\, f(e^{-t})\\, dt$$\n这个变换后的积分形式为 $-\\int_{0}^{\\infty} w(t) g(t) dt$，其中权函数为 $w(t) = e^{-t}$，新的被积函数为 $g(t) = t\\, f(e^{-t})$。权函数 $w(t) = e^{-t}$ 在定义域 $[0, \\infty)$ 上是非负的，这满足了应用标准高斯求积理论的要求。\n\n高斯求积是基于正交多项式族构建的。在区间 $[0, \\infty)$ 上关于权函数 $w(t) = e^{-t}$ 正交的多项式族是**拉盖尔 (Laguerre) 多项式**，记为 $L_n(t)$。相关的求积法则被称为**高斯-拉盖尔 (Gauss-Laguerre) 求积**。\n\n$n$ 点高斯-拉盖尔求积公式将形如 $\\int_{0}^{\\infty} e^{-t} h(t) dt$ 的积分近似为一个加权和：\n$$\\int_{0}^{\\infty} e^{-t}\\, h(t)\\, dt \\approx \\sum_{i=1}^{n} w_i\\, h(t_i)$$\n其中 $t_i$ 是 $n$ 次拉盖尔 (Laguerre) 多项式 $L_n(t)$ 的根（节点），而 $w_i$ 是相应的求积权重。如果 $h(t)$ 是一个次数至多为 $2n-1$ 的多项式，那么这个近似是精确的。由于函数 $f(x)$ 被指定为光滑的，变换后的函数 $g(t) = t\\, f(e^{-t})$ 也是光滑的，我们可以预期随着 $n$ 的增加，该求积法会快速收敛。\n\n将此应用于我们变换后的积分，我们设 $h(t) = g(t) = t\\, f(e^{-t})$。因此，$I[f]$ 的求积近似值，我们记为 $Q_n[f]$，是：\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, g(t_i)$$\n代入 $g(t_i)$ 的表达式：\n$$Q_n[f] = - \\sum_{i=1}^{n} w_i\\, t_i\\, f(e^{-t_i})$$\n这是该自定义求积法则的最终公式。计算 $Q_n[f]$ 的步骤如下：\n1. 对于给定的点数 $n$，获取 $n$ 点高斯-拉盖尔求积法则的节点 $t_i$ 和权重 $w_i$（针对标准权函数 $w(t)=e^{-t}$）。这些可以从标准数值库中获得。\n2. 对于每个节点 $t_i$，计算相应的值 $x_i = e^{-t_i}$。\n3. 在这些点上计算函数 $f$ 的值，$f(x_i)$。\n4. 计算和 $\\sum_{i=1}^{n} w_i\\, t_i\\, f(x_i)$。\n5. 最终结果是这个和的负值。\n\n该过程被实现以评估指定的测试用例。对于 $f(x)=1$ 的解析解是 $I[1] = \\int_0^1 \\ln(x) dx = [x \\ln(x) - x]_0^1 = -1$。一个 $n$ 点高斯-拉盖尔求积法对于次数最高为 $2n-1$ 的多项式是精确的。对于 $f(x)=1$，变换后的函数是 $g(t) = t f(e^{-t}) = t$。这是一个次数为 $1$ 的多项式。当 $n=2$ 时，该求积法对于次数最高为 $2(2)-1=3$ 的多项式是精确的。由于 $1 < 3$，第一个测试用例的求积结果必须恰好是 $-1$。对于其他函数，该求积法提供一个近似值，其精度随 $n$ 的增加而提高。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_laguerre\n\ndef solve():\n    \"\"\"\n    Derives and applies a custom Gaussian quadrature for integrals with a logarithmic singularity.\n    \"\"\"\n\n    # Define the functions for the test suite.\n    def f1(x):\n        return 1.0\n\n    def f2(x):\n        return x\n\n    def f3(x):\n        return np.sin(np.pi * x)\n\n    # Test cases as tuples of (function, number of quadrature points n).\n    # The functions are passed as callables.\n    test_cases = [\n        (f1, 2),\n        (f2, 8),\n        (f3, 8),\n        (f3, 16),\n        (f3, 32),\n    ]\n\n    results = []\n    \n    for f_func, n in test_cases:\n        # Step 1: Obtain nodes (t_i) and weights (w_i) for n-point Gauss-Laguerre quadrature.\n        # The weight function for standard Laguerre polynomials is exp(-t) on [0, inf).\n        # This corresponds to alpha=0 in the generalized Laguerre polynomial L_n^(alpha).\n        nodes, weights = roots_laguerre(n)\n\n        # Step 2: Transform nodes t_i to x_i = exp(-t_i).\n        # The original integration variable x is on [0, 1].\n        x_vals = np.exp(-nodes)\n\n        # Step 3: Evaluate the function f at the transformed points x_i.\n        f_vals = f_func(x_vals)\n\n        # Step 4: Compute the quadrature sum.\n        # The formula is Q_n[f] = - sum_{i=1 to n} w_i * t_i * f(exp(-t_i)).\n        # Here, nodes are t_i, weights are w_i, and f_vals are f(exp(-t_i)).\n        quadrature_sum = np.sum(weights * nodes * f_vals)\n        \n        # Step 5: The final approximation is the negative of the sum.\n        result = -quadrature_sum\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Each floating-point number is formatted to 12 decimal places.\n    print(f\"[{','.join([f'{r:.12f}' for r in results])}]\")\n\nsolve()\n```", "id": "2419634"}]}