{"hands_on_practices": [{"introduction": "辛普森法则 (Simpson's rule) 是数值积分的常用工具，以其高阶收敛性而著称。本次实践旨在通过一个经典的计算任务——估算 $\\pi$ 的值——来直观地展示并验证这一重要特性。通过编程实现复合辛普森法则并分析误差如何随区间数量的增加而减小，你将亲身体验该方法的效率和精度。[@problem_id:2419339]", "problem": "您需要通过一个完整指定的计算任务来研究使用闭合 Newton–Cotes 公式的数值积分。令 $I$ 表示定积分\n$$\nI \\;=\\; \\int_{0}^{1} \\frac{4}{1+x^{2}}\\,dx,\n$$\n根据 $\\frac{4}{1+x^{2}}$ 的反导数，该积分等于 $\\pi$。使用2阶闭合 Newton–Cotes 公式（复合 Simpson 法则），将区间分为 $N$ 个等宽子区间（其中 $N$ 为偶数），计算 $I$ 的近似值 $S_{N}$，并量化其精度。对于每个指定的 $N$，计算绝对误差 $E_{N} = \\lvert S_{N} - \\pi \\rvert$。对于测试组中的每个连续对 $\\left(N_{k},N_{k+1}\\right)$，计算观测收敛阶\n$$\np_{k} \\;=\\; \\log_{2}\\!\\left(\\frac{E_{N_{k}}}{E_{N_{k+1}}}\\right),\n$$\n该值衡量了当区间从 $N_{k}$ 加密到 $N_{k+1}$ 时误差的变化情况。\n\n测试组：\n- 使用以下子区间数量 $N$ 的值：$\\{2,4,8,16,32,64\\}$。该集合覆盖了最小允许的偶数情况 $N=2$，几次连续的以2为因子的加密，以及一个中等精细的分辨率。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，包含一个嵌套的、无空格的逗号分隔列表，格式如下\n$[ [S_{N_{1}},S_{N_{2}},\\dots], [E_{N_{1}},E_{N_{2}},\\dots], [p_{1},p_{2},\\dots] ]$，\n即一个包含三个列表的列表：按测试组顺序排列的近似值 $S_{N}$，按相同顺序排列的相应绝对误差 $E_{N}$，以及测试组中每个连续对 $(N_{k},N_{k+1})$ 的观测阶 $p_{k}$。因此，第三个列表比前两个列表少一个条目。例如，其语法形式（而非数值）为\n\"[[S_{1},S_{2},\\dots],[E_{1},E_{2},\\dots],[p_{1},p_{2},\\dots]]\"\n该行中任何地方都没有空格。\n\n所有答案都是纯数（无量纲实数）。不使用角度，也不涉及物理单位。程序必须是自包含的，不需要任何输入。", "solution": "问题陈述已经过验证，被认为是适定的、有科学依据且无歧义的。这是一个数值分析中的标准练习。我们将开始进行求解。\n\n任务是使用复合 Simpson 法则，通过一系列的区间分割来近似定积分\n$$\nI = \\int_{0}^{1} f(x) \\,dx \\quad \\text{其中} \\quad f(x) = \\frac{4}{1+x^2}\n$$\n并分析该近似的收敛性。已知该积分的精确值为 $I = \\pi$。\n\n复合 Simpson 法则，即2阶闭合 Newton-Cotes 公式，通过将积分区间 $[a, b]$ 分成 $N$ 个等宽子区间（$N$为偶数，宽度为 $h = (b-a)/N$）来近似积分。其公式为：\n$$\nS_N = \\frac{h}{3} \\left[ f(x_0) + 4\\sum_{i=1, i \\text{ odd}}^{N-1} f(x_i) + 2\\sum_{i=2, i \\text{ even}}^{N-2} f(x_i) + f(x_N) \\right]\n$$\n其中 $x_i = a + ih$，$i = 0, 1, \\dots, N$。对于本问题，积分区间是 $[0, 1]$，因此 $a=0$，$b=1$，步长为 $h=1/N$。求值点，或称节点，为 $x_i = i/N$。\n\n对于给定的 $N$，此近似的精度由绝对误差衡量，定义为：\n$$\nE_N = \\lvert S_N - \\pi \\rvert\n$$\n\n为了量化当 $N$ 增加时的收敛速度，我们对测试组 $\\{2, 4, 8, 16, 32, 64\\}$ 中的每一对连续子区间数 $(N_k, N_{k+1})$ 计算观测收敛阶 $p_k$。该度量的公式为：\n$$\np_{k} = \\log_{2}\\!\\left(\\frac{E_{N_{k}}}{E_{N_{k+1}}}\\right)\n$$\n该计算与特定的加密策略相关，其中每一步都将区间数量加倍，即 $N_{k+1} = 2N_k$。\n\n对于一个足够光滑的函数，复合 Simpson 法则的误差由 Euler-Maclaurin 公式的首项给出，即：\n$$\nI - S_N = -\\frac{(b-a)h^4}{180} f^{(4)}(\\xi)\n$$\n对于某个 $\\xi \\in (a,b)$。这意味着误差依赖关系为 $E_N \\propto h^4$，或等价地，$E_N \\propto N^{-4}$。当我们把子区间数量加倍，使得 $N_{k+1} = 2N_k$ 时，步长减半，即 $h_{k+1} = h_k/2$。因此，当 $N \\to \\infty$ 时，连续误差的比值预计会趋近于一个常数：\n$$\n\\frac{E_{N_k}}{E_{N_{k+1}}} \\approx \\frac{C \\cdot h_k^4}{C \\cdot (h_k/2)^4} = 2^4 = 16\n$$\n因此，理论收敛阶为 $p = \\log_2(16) = 4$。当 $N$ 变大且渐近误差行为占主导时，计算出的 $p_k$ 值预计将趋近于 $4$。对于较小的 $N$，预期会出现与该值的偏差，这是由于高阶误差项的影响以及四阶导数 $f^{(4)}(x)$ 在区间 $[0, 1]$ 上的非恒定性。\n\n计算步骤如下：\n1. 定义被积函数 $f(x) = \\frac{4}{1+x^2}$。\n2. 对于集合 $\\{2, 4, 8, 16, 32, 64\\}$ 中的每个子区间数 $N$：\n   a. 计算步长 $h = 1/N$。\n   b. 生成节点 $x_i = i \\cdot h$，其中 $i = 0, \\dots, N$。\n   c. 在所有节点上计算 $f(x_i)$ 的值。\n   d. 使用复合 Simpson 法则公式计算总和 $S_N$。\n   e. 使用数值库提供的高精度 $\\pi$ 值计算绝对误差 $E_N = |S_N - \\pi|$。\n3. 存储计算出的值序列 $\\{S_N\\}$ 和 $\\{E_N\\}$。\n4. 使用序列 $\\{E_N\\}$ 计算观测阶序列 $\\{p_k\\}$，其中 $k=1, \\dots, 5$。\n5. 最终结果将按照问题陈述中的规定，以一个包含这三个数值序列的嵌套列表形式呈现。至此，解决方案的正式设计完成。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes an approximation of pi using the composite Simpson's rule\n    and analyzes its convergence properties.\n    \"\"\"\n    # Define the set of subinterval counts for the test suite.\n    subinterval_counts = [2, 4, 8, 16, 32, 64]\n\n    # The exact value of the integral is pi. Use numpy's high-precision value.\n    pi_exact = np.pi\n\n    # Define the integrand function f(x) = 4 / (1 + x^2).\n    def f(x):\n        return 4.0 / (1.0 + x**2)\n\n    # Lists to store the results: approximations, errors, and convergence orders.\n    approximations = []\n    errors = []\n    \n    # Iterate through each specified number of subintervals N.\n    for N in subinterval_counts:\n        # The integration interval is [0, 1].\n        a, b = 0.0, 1.0\n        \n        # Calculate the step size h.\n        h = (b - a) / N\n        \n        # Generate N+1 equally spaced nodes from a to b.\n        x_nodes = np.linspace(a, b, N + 1)\n        \n        # Evaluate the function at the nodes.\n        y_values = f(x_nodes)\n        \n        # Apply the composite Simpson's rule formula:\n        # S_N = (h/3) * [f(x_0) + 4*f(x_1) + 2*f(x_2) + ... + f(x_N)]\n        # The sum is structured as: y[0] + y[-1] + 4*sum(odd_indices) + 2*sum(even_indices)\n        s_approx = (h / 3.0) * (\n            y_values[0] \n            + y_values[-1] \n            + 4.0 * np.sum(y_values[1:-1:2]) \n            + 2.0 * np.sum(y_values[2:-1:2])\n        )\n        \n        # Store the computed approximation.\n        approximations.append(s_approx)\n        \n        # Calculate the absolute error and store it.\n        error = np.abs(s_approx - pi_exact)\n        errors.append(error)\n\n    # Compute the observed convergence orders for successive pairs of errors.\n    # The list of orders will have one fewer element than the lists of errors/approximations.\n    orders = []\n    for k in range(len(errors) - 1):\n        # p_k = log2(E_{N_k} / E_{N_{k+1}})\n        order = np.log2(errors[k] / errors[k+1])\n        orders.append(order)\n\n    # Format the results into the required single-line string format.\n    # e.g., \"[[S1,S2,...],[E1,E2,...],[p1,p2,...]]\" with no spaces.\n    s_str = \",\".join(map(str, approximations))\n    e_str = \",\".join(map(str, errors))\n    p_str = \",\".join(map(str, orders))\n    \n    final_output = f\"[[{s_str}],[{e_str}],[{p_str}]]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2419339"}, {"introduction": "在工程应用中，我们不仅需要知道数值方法的误差会减小，更常常需要在计算开始前就确保最终结果能达到预设的精度要求。本次练习将你的关注点从经验性分析转向先验误差估计 (a priori error estimation)。你将运用辛普森3/8法则 (Simpson's 3/8 rule) 的理论误差界，来确定保证所需计算精度必须的最少子区间数量。[@problem_id:2419302]", "problem": "一个阶数为$3$的闭合Newton-Cotes公式，即复合辛普森八分之三法则，将被用于等间距子区间来近似定积分\n$$\n\\int_{0}^{\\pi} \\sin(x)\\,dx,\n$$\n其中$x$的单位是弧度。令$n$表示子区间的数量，步长为$h = (\\pi - 0)/n$。对于此求积方法，$n$必须是$3$的整数倍。确定能够保证复合辛普森八分之三法则近似的绝对误差严格小于$10^{-6}$的最小$n$值。以整数形式提供$n$的值。", "solution": "首先将对问题的科学性、适定性和客观性进行验证。\n\n**步骤 1：提取已知条件**\n- 使用的公式：复合辛普森八分之三法则，一个阶数为$3$的闭合Newton-Cotes公式。\n- 待近似的积分：$\\int_{0}^{\\pi} \\sin(x)\\,dx$。\n- 变量$n$：子区间的数量。\n- 步长$h$：$h = (\\pi - 0)/n = \\pi/n$。\n- 对$n$的约束：$n$必须是$3$的整数倍。\n- 误差条件：绝对误差必须严格小于$10^{-6}$。\n- 目标：确定满足给定条件的最小整数$n$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题是数值分析中的一个标准练习，数值分析是计算工程和应用数学的一个子领域。\n- **科学依据**：该问题基于已建立的数学原理，特别是Newton-Cotes公式的数值积分理论和误差分析。所有概念，包括正弦函数的积分和辛普森法则，在事实上都是正确的。\n- **适定性**：问题定义清晰。它要求满足由特定数值方法的误差界导出的精确不等式的最小整数$n$。此类问题具有唯一、稳定且有意义的解。\n- **客观性**：问题使用精确、无歧义的数学语言陈述。没有主观或基于意见的陈述。\n- **完整性和一致性**：问题提供了所有必要信息：函数、积分区间、数值方法、误差容限以及对参数$n$的所有约束。没有矛盾之处。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。下面将提供一个严谨的解法。\n\n对于函数$f(x)$在区间$[a, b]$上使用$n$个子区间（其中$n$是$3$的倍数）的复合辛普森八分之三法则，其误差项$E_n$由以下公式给出：\n$$\nE_n = -\\frac{(b-a)^5}{80 n^4} f^{(4)}(\\xi)\n$$\n其中$\\xi$是开区间$(a, b)$中的某个值。\n\n在本问题中，我们已知：\n- 函数$f(x) = \\sin(x)$。\n- 积分区间$[a, b] = [0, \\pi]$。\n\n首先，我们必须计算$f(x)$的四阶导数：\n$$\nf(x) = \\sin(x)\n$$\n$$\nf'(x) = \\cos(x)\n$$\n$$\nf''(x) = -\\sin(x)\n$$\n$$\nf'''(x) = -\\cos(x)\n$$\n$$\nf^{(4)}(x) = \\sin(x)\n$$\n将这些分量代入误差公式，得到绝对误差$|E_n|$的表达式：\n$$\n|E_n| = \\left| -\\frac{(\\pi - 0)^5}{80 n^4} \\sin(\\xi) \\right| = \\frac{\\pi^5}{80 n^4} |\\sin(\\xi)|\n$$\n其中$\\xi \\in (0, \\pi)$。\n\n为保证误差小于指定的容差，我们必须找到$|E_n|$的一个上界。这需要找到$|f^{(4)}(\\xi)| = |\\sin(\\xi)|$在积分区间上的最大值。对于$\\xi \\in [0, \\pi]$，函数$\\sin(\\xi)$是非负的，所以$|\\sin(\\xi)| = \\sin(\\xi)$。$\\sin(\\xi)$在$[0, \\pi]$上的最大值是$1$，在$\\xi = \\frac{\\pi}{2}$处取得。\n因此，绝对误差的一个上界是：\n$$\n|E_n| \\le \\frac{\\pi^5}{80 n^4} \\max_{\\xi \\in [0, \\pi]}|\\sin(\\xi)| = \\frac{\\pi^5}{80 n^4}\n$$\n问题要求绝对误差严格小于$10^{-6}$。我们将此条件施加于我们导出的上界：\n$$\n\\frac{\\pi^5}{80 n^4}  10^{-6}\n$$\n我们现在求解这个关于整数$n$的不等式。\n$$\nn^4  \\frac{\\pi^5}{80} \\times 10^6\n$$\n对两边取四次方根，得到：\n$$\nn  \\left( \\frac{\\pi^5 \\times 10^6}{80} \\right)^{1/4}\n$$\n计算右侧表达式的值，我们得到：\n$$\nn  (3825246.03...)^{1/4}\n$$\n$$\nn  44.2235...\n$$\n问题规定$n$必须是整数，并且必须是$3$的倍数。\n根据不等式$n > 44.2235...$， $n$的最小整数值为$45$。我们必须验证这个整数是否满足第二个条件。数字$45$是$3$的倍数，因为$45 = 3 \\times 15$。\n由于$45$是大于$44.2235...$的最小整数，并且它也是$3$的倍数，因此它是保证指定精度所需的最小子区间数。任何更小的$3$的倍数，如$n=42$，都会导致误差界大于或等于$10^{-6}$。\n\n因此，最小子区间数$n$为$45$。", "answer": "$$\n\\boxed{45}\n$$", "id": "2419302"}, {"introduction": "牛顿-科茨公式 (Newton-Cotes formulas) 并不仅仅是一系列孤立的“配方”。本次高级实践将揭示这些公式之间深刻的内在联系，展示如何从一个低阶方法（如梯形法则）系统地推导出一个高阶方法（如辛普森法则）。你将学习通过理查森外推法 (Richardson extrapolation) 来消除主导误差项，这是一种在科学计算中极为强大的通用技术。[@problem_id:2419361]", "problem": "给定一个在闭区间 $[a,b]$ 上，使用两种步长为 $h$ 和 $h/2$ 的均匀网格计算的定积分的复合梯形近似序列。将这些近似值分别记为 $T(h)$ 和 $T(h/2)$。请从第一性原理出发，不引用任何已命名的方法，构造一个 $T(h)$ 和 $T(h/2)$ 的线性组合，从而产生一个新的近似值 $\\widehat{I}(h)$。当被积函数足够光滑时，该新近似值的截断误差阶严格高于复合梯形法则的截断误差阶。将此构造应用于以下测试套件，并报告相对于精确积分值的绝对误差。所有三角函数均使用弧度制。\n\n设 $f:[a,b]\\to\\mathbb{R}$ 为可积函数，设 $n\\in\\mathbb{N}$ 为用于定义粗糙均匀网格步长 $h=(b-a)/n$ 的子区间数量，因此精细网格使用 $2n$ 个子区间。对于下方的每个测试用例，用 $n$ 个子区间计算 $T(h)$，用 $2n$ 个子区间计算 $T(h/2)$，并根据上述描述从这两个值构造出高阶近似值 $\\widehat{I}(h)$，然后计算绝对误差 $|\\widehat{I}(h)-I_{\\text{exact}}|$。无需四舍五入；请报告原始浮点数值。\n\n测试套件：\n- 案例 $\\mathsf{A}$ (通用光滑指数函数): $f_{\\mathsf{A}}(x)=e^{x}$，区间为 $[a,b]=[0,1]$，其中 $n=10$。精确积分值为 $I_{\\text{exact}}=e-1$。\n- 案例 $\\mathsf{B}$ (三次多项式，阶数至多为 $3$): $f_{\\mathsf{B}}(x)=3x^{3}-2x^{2}+x-5$，区间为 $[a,b]=[-2,2]$，其中 $n=8$。精确积分值为 $I_{\\text{exact}}=-\\dfrac{92}{3}$。\n- 案例 $\\mathsf{C}$ (零长度区间边界条件): $f_{\\mathsf{C}}(x)=\\cos(x)$，区间为 $[a,b]=[\\pi,\\pi]$，其中 $n=4$。精确积分值为 $I_{\\text{exact}}=0$。\n- 案例 $\\mathsf{D}$ (振荡三角函数，角度为弧度): $f_{\\mathsf{D}}(x)=\\sin(5x)$，区间为 $[a,b]=[0,\\pi]$，其中 $n=16$。精确积分值为 $I_{\\text{exact}}=\\dfrac{2}{5}$。\n- 案例 $\\mathsf{E}$ (非光滑绝对值函数): $f_{\\mathsf{E}}(x)=|x|$，区间为 $[a,b]=[-1,1]$，其中 $n=64$。精确积分值为 $I_{\\text{exact}}=1$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含案例 $\\mathsf{A}$ 到 $\\mathsf{E}$ 的绝对误差，按顺序排列，形式为用方括号括起来的逗号分隔列表（例如，$[\\text{result}_{\\mathsf{A}},\\text{result}_{\\mathsf{B}},\\text{result}_{\\mathsf{C}},\\text{result}_{\\mathsf{D}},\\text{result}_{\\mathsf{E}}]$）。每个条目必须是浮点数。", "solution": "设 $I=\\int_{a}^{b} f(x)\\,dx$ 表示足够光滑函数 $f$ 的精确积分。在步长为 $h=(b-a)/n$ 的均匀网格上的复合梯形近似为\n$$\nT(h)=h\\left(\\frac{f(a)}{2}+\\sum_{k=1}^{n-1} f(a+kh)+\\frac{f(b)}{2}\\right).\n$$\n在足够的平滑性条件下，复合梯形法则的全局误差允许一个关于 $h$ 的偶数次幂的渐近展开，\n$$\nT(h)=I + C_{2}h^{2}+C_{4}h^{4}+C_{6}h^{6}+\\cdots,\n$$\n其中常数 $C_{2m}$ 取决于 $f$ 及其在端点处的导数（这可由 Euler–Maclaurin 求和公式得出）。在步长为 $h/2$ 的精细网格上评估相同的近似值可得\n$$\nT\\!\\left(\\frac{h}{2}\\right)=I + C_{2}\\left(\\frac{h}{2}\\right)^{2}+C_{4}\\left(\\frac{h}{2}\\right)^{4}+C_{6}\\left(\\frac{h}{2}\\right)^{6}+\\cdots \\,=\\, I + \\frac{C_{2}}{4}h^{2}+\\frac{C_{4}}{16}h^{4}+\\frac{C_{6}}{64}h^{6}+\\cdots.\n$$\n\n我们寻求一个线性组合\n$$\n\\widehat{I}(h)=\\alpha\\,T\\!\\left(\\frac{h}{2}\\right)+\\beta\\,T(h),\n$$\n其系数 $\\alpha$ 和 $\\beta$ 的选择旨在消除与 $h^{2}$ 成比例的主误差项，同时保持常数项的精确性。施加条件\n$$\n\\alpha+\\beta=1 \\quad\\text{and}\\quad \\frac{\\alpha}{4}+\\beta=0,\n$$\n我们求解 $\\alpha$ 和 $\\beta$。将第二个方程乘以4后，用第一个方程减去它，得到\n$$\n\\alpha+\\beta=1, \\quad \\alpha+4\\beta=0 \\;\\Rightarrow\\; (\\alpha+4\\beta)-(\\alpha+\\beta)=0-1 \\;\\Rightarrow\\; 3\\beta=-1 \\;\\Rightarrow\\; \\beta=-\\frac{1}{3},\n$$\n因此\n$$\n\\alpha=1-\\beta=1+\\frac{1}{3}=\\frac{4}{3}.\n$$\n因此，$\\widehat{I}(h)=\\frac{4\\,T\\!\\left(\\frac{h}{2}\\right)-T(h)}{3}=I+\\mathcal{O}(h^{4})$, 这是一个四阶精确的近似。此构造与在精细网格上求值的经典 Simpson 复合公式相吻合，但它是直接从渐近误差展开和线性组合约束推导出来的，没有命名任何特定的算法。\n\n每个测试用例的算法实现：\n- 给定 $f$、$a$、$b$ 和 $n$，计算 $h=(b-a)/n$ 和复合梯形近似 $T(h)$。\n- 通过使用 $2n$ 个子区间计算复合梯形法则来计算 $T(h/2)$。\n- 构造高阶估计 $\\widehat{I}(h)=\\left(4\\,T(h/2)-T(h)\\right)/3$。\n- 使用提供的精确积分 $I_{\\text{exact}}$ 计算绝对误差 $|\\widehat{I}(h)-I_{\\text{exact}}|$。\n\n在测试套件上的验证：\n- 案例 $\\mathsf{A}$：$f_{\\mathsf{A}}(x)=e^{x}$ 在 $[0,1]$上，$I_{\\text{exact}}=e-1$。对于足够光滑的 $f$，误差应与 $h^{4}$ 成比例缩放。\n- 案例 $\\mathsf{B}$：$f_{\\mathsf{B}}(x)=3x^{3}-2x^{2}+x-5$ 在 $[-2,2]$上。由于构造的估计对阶数至多为3的多项式是精确的，我们期望在浮点舍入误差范围内 $|\\widehat{I}(h)-I_{\\text{exact}}|=0$。\n- 案例 $\\mathsf{C}$：$[a,b]=[\\pi,\\pi]$ 意味着 $h=0$，因此 $T(h)=T(h/2)=0$ 且 $\\widehat{I}(h)=0$，与 $I_{\\text{exact}}=0$ 相符。\n- 案例 $\\mathsf{D}$：$f_{\\mathsf{D}}(x)=\\sin(5x)$ 在 $[0,\\pi]$上，$I_{\\text{exact}}=2/5$。函数光滑且具有振荡性；与相同粗糙网格上的复合梯形法则相比，高阶估计显著减小了误差。\n- 案例 $\\mathsf{E}$：$f_{\\mathsf{E}}(x)=|x|$ 在 $[-1,1]$上，$I_{\\text{exact}}=1$。函数在 $x=0$ 处不可微，因此可能观察不到理论误差阶；尽管如此，该构造仍然有效，并产生一个具有明确定义的绝对误差的有限近似值。\n\n程序按指定顺序计算这些绝对误差，并将其打印为单个用方括号括起来的逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef composite_trapezoid(f, a, b, n):\n    \"\"\"Composite trapezoidal rule on [a,b] with n subintervals.\"\"\"\n    if n == 0 or a == b:\n        # Handle zero-length interval or non-positive n robustly\n        return 0.0\n    x = np.linspace(a, b, n + 1)\n    fx = f(x)\n    h = (b - a) / n\n    # Trapezoidal sum: h * (0.5*f(a) + sum_{i=1}^{n-1} f(x_i) + 0.5*f(b))\n    return h * (0.5 * fx[0] + fx[1:-1].sum() + 0.5 * fx[-1])\n\ndef higher_order_from_trap(f, a, b, n):\n    \"\"\"Construct higher-order estimate from T(h) and T(h/2).\"\"\"\n    T_h = composite_trapezoid(f, a, b, n)\n    T_h2 = composite_trapezoid(f, a, b, 2 * n if n > 0 else 0)\n    # Linear combination that cancels the leading h^2 error term\n    return (4.0 * T_h2 - T_h) / 3.0\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Angles are in radians.\n    test_cases = [\n        # Case A: f(x) = exp(x) on [0,1], n=10, exact = e - 1\n        {\n            \"f\": lambda x: np.exp(x),\n            \"a\": 0.0,\n            \"b\": 1.0,\n            \"n\": 10,\n            \"I_exact\": np.e - 1.0,\n        },\n        # Case B: f(x) = 3x^3 - 2x^2 + x - 5 on [-2,2], n=8, exact = -92/3\n        {\n            \"f\": lambda x: 3.0 * x**3 - 2.0 * x**2 + x - 5.0,\n            \"a\": -2.0,\n            \"b\": 2.0,\n            \"n\": 8,\n            \"I_exact\": -92.0 / 3.0,\n        },\n        # Case C: f(x) = cos(x) on [pi, pi], n=4, exact = 0\n        {\n            \"f\": lambda x: np.cos(x),\n            \"a\": float(np.pi),\n            \"b\": float(np.pi),\n            \"n\": 4,\n            \"I_exact\": 0.0,\n        },\n        # Case D: f(x) = sin(5x) on [0, pi], n=16, exact = 2/5\n        {\n            \"f\": lambda x: np.sin(5.0 * x),\n            \"a\": 0.0,\n            \"b\": float(np.pi),\n            \"n\": 16,\n            \"I_exact\": 2.0 / 5.0,\n        },\n        # Case E: f(x) = |x| on [-1,1], n=64, exact = 1\n        {\n            \"f\": lambda x: np.abs(x),\n            \"a\": -1.0,\n            \"b\": 1.0,\n            \"n\": 64,\n            \"I_exact\": 1.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case[\"f\"]\n        a = case[\"a\"]\n        b = case[\"b\"]\n        n = case[\"n\"]\n        exact = case[\"I_exact\"]\n        I_hat = higher_order_from_trap(f, a, b, n)\n        abs_err = abs(I_hat - exact)\n        results.append(abs_err)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2419361"}]}