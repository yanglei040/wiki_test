{"hands_on_practices": [{"introduction": "在工程和科学领域，我们经常需要根据离散的实验数据点来估计未知点的函数值。牛顿差商插值法为此提供了一种强大而系统的方法。这个练习将指导你完成核心过程：构建差商表，确定插值多项式的系数，并利用它来预测一个新数据点的值。[@problem_id:2189672]", "problem": "一个材料科学实验室正在表征一种用于高性能热交换器的新型金属合金。该合金的热导率 $k$ 在几个不同的温度 $T$ 下进行了测量。实验数据如下：\n\n- 在 $T_0 = 100$ K 时，热导率为 $k_0 = 400$ W/(m·K)。\n- 在 $T_1 = 200$ K 时，热导率为 $k_1 = 390$ W/(m·K)。\n- 在 $T_2 = 400$ K 时，热导率为 $k_2 = 350$ W/(m·K)。\n- 在 $T_3 = 600$ K 时，热导率为 $k_3 = 300$ W/(m·K)。\n\n为了预测合金在中间温度下的行为，一位工程师决定使用一个通过所有四个数据点的牛顿形式的三次插值多项式 $P_3(T)$ 来模拟热导率。\n\n您的任务是从差商表中确定该多项式的系数，然后使用霍纳（Horner）嵌套求值法来估算合金在温度 $T = 300$ K 时的热导率。\n\n将您的最终热导率答案以 W/(m·K) 为单位表示，并四舍五入到四位有效数字。", "solution": "我们给定数据点 $(T_{0},k_{0})=(100,400)$，$(T_{1},k_{1})=(200,390)$，$(T_{2},k_{2})=(400,350)$，$(T_{3},k_{3})=(600,300)$，我们构建三次牛顿插值多项式\n$$\nP_{3}(T)=f[T_{0}]+f[T_{0},T_{1}](T-T_{0})+f[T_{0},T_{1},T_{2}](T-T_{0})(T-T_{1})+f[T_{0},T_{1},T_{2},T_{3}](T-T_{0})(T-T_{1})(T-T_{2})。\n$$\n逐步计算差商。一阶差商：\n$$\nf[T_{0},T_{1}]=\\frac{k_{1}-k_{0}}{T_{1}-T_{0}}=\\frac{390-400}{200-100}=-\\frac{1}{10},\n$$\n$$\nf[T_{1},T_{2}]=\\frac{k_{2}-k_{1}}{T_{2}-T_{1}}=\\frac{350-390}{400-200}=-\\frac{1}{5},\n$$\n$$\nf[T_{2},T_{3}]=\\frac{k_{3}-k_{2}}{T_{3}-T_{2}}=\\frac{300-350}{600-400}=-\\frac{1}{4}.\n$$\n二阶差商：\n$$\nf[T_{0},T_{1},T_{2}]=\\frac{f[T_{1},T_{2}]-f[T_{0},T_{1}]}{T_{2}-T_{0}}=\\frac{-\\frac{1}{5}-\\left(-\\frac{1}{10}\\right)}{400-100}=-\\frac{1}{3000},\n$$\n$$\nf[T_{1},T_{2},T_{3}]=\\frac{f[T_{2},T_{3}]-f[T_{1},T_{2}]}{T_{3}-T_{1}}=\\frac{-\\frac{1}{4}-\\left(-\\frac{1}{5}\\right)}{600-200}=-\\frac{1}{8000}.\n$$\n三阶差商：\n$$\nf[T_{0},T_{1},T_{2},T_{3}]=\\frac{f[T_{1},T_{2},T_{3}]-f[T_{0},T_{1},T_{2}]}{T_{3}-T_{0}}=\\frac{-\\frac{1}{8000}-\\left(-\\frac{1}{3000}\\right)}{600-100}=\\frac{1}{2400000}.\n$$\n因此，牛顿形式的系数为\n$$\na_{0}=f[T_{0}]=400,\\quad a_{1}=f[T_{0},T_{1}]=-\\frac{1}{10},\\quad a_{2}=f[T_{0},T_{1},T_{2}]=-\\frac{1}{3000},\\quad a_{3}=f[T_{0},T_{1},T_{2},T_{3}]=\\frac{1}{2400000}.\n$$\n因此\n$$\nP_{3}(T)=400-\\frac{1}{10}(T-100)-\\frac{1}{3000}(T-100)(T-200)+\\frac{1}{2400000}(T-100)(T-200)(T-400).\n$$\n在 $T=300$ 处使用霍纳嵌套求值法：\n$P_{3}(300) = \\left( \\left( a_3 (300-T_2) + a_2 \\right) (300-T_1) + a_1 \\right) (300-T_0) + a_0$\n$P_{3}(300) = \\left( \\left( \\frac{1}{2400000} (300-400) - \\frac{1}{3000} \\right) (300-200) - \\frac{1}{10} \\right) (300-100) + 400$\n$P_{3}(300) = \\left( \\left( -\\frac{1}{24000} - \\frac{8}{24000} \\right) (100) - \\frac{1}{10} \\right) (200) + 400$\n$P_{3}(300) = \\left( \\left( -\\frac{9}{24000} \\right) (100) - \\frac{1}{10} \\right) (200) + 400$\n$P_{3}(300) = \\left( -\\frac{9}{240} - \\frac{1}{10} \\right) (200) + 400$\n$P_{3}(300) = \\left( -\\frac{3}{80} - \\frac{8}{80} \\right) (200) + 400$\n$P_{3}(300) = \\left( -\\frac{11}{80} \\right) (200) + 400 = -\\frac{2200}{80} + 400 = -27.5 + 400 = 372.5$\n\n四舍五入到四位有效数字，得到 $372.5$ W/(m·K)。", "answer": "$$\\boxed{372.5}$$", "id": "2189672"}, {"introduction": "差商表不仅是构建插值多项式的计算工具，它本身也蕴含了关于数据内在结构的重要信息。通过观察高阶差商的行为，我们可以判断这些数据点是否可能源自一个低阶多项式。这个练习将让你亲身体验如何利用这一特性，仅通过分析差商表来确定生成一组数据点的多项式的最低次数。[@problem_id:2386657]", "problem": "一个由标量对 $(x_i, y_i)$ 组成的数据集在五个不同的节点上被记录下来，用于计算工程中的一个代理模型。这些节点和值是：\n$(-2, -17)$, $(-1, 0)$, $(0, 4)$, $(1, 4)$, $(2, 9)$.\n仅根据差商所反映的多项式的数学性质，选择关于能精确生成所有五个数据点的单变量多项式最小次数的最精确陈述。\n\nA. 数据与一个次数至多为 $2$ 的多项式一致。\n\nB. 数据与一个次数至多为 $3$ 的多项式一致，但与任何次数至多为 $2$ 的多项式不一致。\n\nC. 数据与一个次数至多为 $4$ 的多项式一致，但与任何次数至多为 $3$ 的多项式不一致。\n\nD. 没有次数至多为 $4$ 的多项式可以插值所有这些点。", "solution": "拟合一组给定数据点的多项式的最小次数可以通过构建一个牛顿差商表来确定。对于一个次数为 $n$ 的多项式，其 $n$ 阶差商是常数，其 $(n+1)$ 阶差商为零。\n\n设给定的数据点为 $(x_i, y_i)$，其中 $i=0, 1, 2, 3, 4$。\n$x_0 = -2, y_0 = -17$\n$x_1 = -1, y_1 = 0$\n$x_2 = 0, y_2 = 4$\n$x_3 = 1, y_3 = 4$\n$x_4 = 2, y_4 = 9$\n\n零阶差商是函数值本身，$f[x_i] = y_i$。\n\n一阶差商计算如下：\n$f[x_0, x_1] = \\frac{y_1 - y_0}{x_1 - x_0} = \\frac{0 - (-17)}{-1 - (-2)} = \\frac{17}{1} = 17$\n$f[x_1, x_2] = \\frac{y_2 - y_1}{x_2 - x_1} = \\frac{4 - 0}{0 - (-1)} = \\frac{4}{1} = 4$\n$f[x_2, x_3] = \\frac{y_3 - y_2}{x_3 - x_2} = \\frac{4 - 4}{1 - 0} = \\frac{0}{1} = 0$\n$f[x_3, x_4] = \\frac{y_4 - y_3}{x_4 - x_3} = \\frac{9 - 4}{2 - 1} = \\frac{5}{1} = 5$\n\n二阶差商为：\n$f[x_0, x_1, x_2] = \\frac{f[x_1, x_2] - f[x_0, x_1]}{x_2 - x_0} = \\frac{4 - 17}{0 - (-2)} = \\frac{-13}{2}$\n$f[x_1, x_2, x_3] = \\frac{f[x_2, x_3] - f[x_1, x_2]}{x_3 - x_1} = \\frac{0 - 4}{1 - (-1)} = \\frac{-4}{2} = -2$\n$f[x_2, x_3, x_4] = \\frac{f[x_3, x_4] - f[x_2, x_3]}{x_4 - x_2} = \\frac{5 - 0}{2 - 0} = \\frac{5}{2}$\n\n三阶差商为：\n$f[x_0, x_1, x_2, x_3] = \\frac{f[x_1, x_2, x_3] - f[x_0, x_1, x_2]}{x_3 - x_0} = \\frac{-2 - (-\\frac{13}{2})}{1 - (-2)} = \\frac{- \\frac{4}{2} + \\frac{13}{2}}{3} = \\frac{\\frac{9}{2}}{3} = \\frac{3}{2}$\n$f[x_1, x_2, x_3, x_4] = \\frac{f[x_2, x_3, x_4] - f[x_1, x_2, x_3]}{x_4 - x_1} = \\frac{\\frac{5}{2} - (-2)}{2 - (-1)} = \\frac{\\frac{5}{2} + \\frac{4}{2}}{3} = \\frac{\\frac{9}{2}}{3} = \\frac{3}{2}$\n\n三阶差商为常数且非零。这已经表明多项式的最小次数是 $3$。为了确认，我们计算四阶差商。\n\n四阶差商为：\n$f[x_0, x_1, x_2, x_3, x_4] = \\frac{f[x_1, x_2, x_3, x_4] - f[x_0, x_1, x_2, x_3]}{x_4 - x_0} = \\frac{\\frac{3}{2} - \\frac{3}{2}}{2 - (-2)} = \\frac{0}{4} = 0$\n\n由于三阶差商为常数且等于 $\\frac{3}{2} \\neq 0$，而四阶差商为 $0$，因此数据精确地对应于一个次数为 $3$ 的多项式。该多项式的牛顿形式为 $P_3(x) = f[x_0] + f[x_0,x_1](x-x_0) + f[x_0,x_1,x_2](x-x_0)(x-x_1) + f[x_0,x_1,x_2,x_3](x-x_0)(x-x_1)(x-x_2)$。最高次项 $x^3$ 的系数是 $f[x_0,x_1,x_2,x_3] = \\frac{3}{2}$，为非零值。因此，最小次数恰好为 $3$。\n\n现在我们评估给定的选项。\n\nA. 数据与一个次数至多为 $2$ 的多项式一致。\n这个陈述意味着数据可以由一个次数为 $2$、$1$ 或 $0$ 的多项式表示。要使其为真，所有三阶差商必须为零。我们的计算表明三阶差商为 $\\frac{3}{2}$，不为零。因此，多项式的最小次数必须大于 $2$。\n结论：**错误**。\n\nB. 数据与一个次数至多为 $3$ 的多项式一致，但与任何次数至多为 $2$ 的多项式不一致。\n这个陈述由两个主张组成。首先，“与一个次数至多为 $3$ 的多项式一致”。如果四阶差商为零，则该主张为真。我们发现 $f[x_0, x_1, x_2, x_3, x_4] = 0$，证实了这一部分。其次，“与任何次数至多为 $2$ 的多项式不一致”。这是正确的，因为三阶差商非零。由于两个主张都正确，该陈述准确地描述了插值多项式的最小次数恰好为 $3$。\n结论：**正确**。\n\nC. 数据与一个次数至多为 $4$ 的多项式一致，但与任何次数至多为 $3$ 的多项式不一致。\n第一部分，“与一个次数至多为 $4$ 的多项式一致”，对于任意五个点来说是平凡成立的。一个次数为 $3$ 的多项式是次数至多为 $4$ 的多项式的一个特例（其 $x^4$ 项系数为零）。然而，第二部分，“与任何次数至多为 $3$ 的多项式不一致”，是错误的。正如我们所证明的，数据可以被一个次数为 $3$ 的多项式完美描述。\n结论：**错误**。\n\nD. 没有次数至多为 $4$ 的多项式可以插值所有这些点。\n这个陈述与多项式插值基本定理相矛盾，该定理保证对于任意 $n+1$ 个不同的点，都存在一个唯一的、次数至多为 $n$ 的多项式穿过它们。这里我们有 $5$ 个点，所以 $n=4$。一个次数至多为 $4$ 的唯一多项式必然存在。我们已经明确地发现它是一个次数为 $3$ 的多项式。\n结论：**错误**。", "answer": "$$\\boxed{B}$$", "id": "2386657"}, {"introduction": "尽管多项式插值非常有用，但在实践中也存在陷阱，尤其是在使用高阶多项式和等距节点时。臭名昭著的龙格现象（Runge phenomenon）表明，这种组合可能导致在区间端点附近出现剧烈的振荡和巨大的误差。本练习将通过一个经典的编程任务，让你直面这一挑战，并探索如何通过使用切比雪夫节点（Chebyshev nodes）来有效抑制这种振荡，从而实现更稳定和准确的插值。[@problem_id:2426405]", "problem": "您需要使用两种节点生成策略，为龙格函数（Runge function）实现牛顿形式（Newton form）的多项式插值。从基本定义出发：对于 $n+1$ 个不同的节点 $\\{x_0,\\dots,x_n\\}$ 和函数值 $\\{f(x_0),\\dots,f(x_n)\\}$，存在一个唯一的次数至多为 $n$ 的多项式 $p_n(x)$，满足对所有 $i$ 都有 $p_n(x_i)=f(x_i)$。使用差商（divided differences）的递归定义和牛顿基（Newton basis）来推导一个数值稳定的求值算法。目标函数是区间 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$。所有角度必须以弧度为单位。\n\n您的任务是：\n- 实现一个函数，为节点 $\\{x_i\\}_{i=0}^n$ 和函数值 $\\{f(x_i)\\}_{i=0}^n$ 计算差商，从而得到 $p_n(x)$ 的牛顿形式系数 $\\{c_0,\\dots,c_n\\}$。\n- 实现一个函数，使用基于牛顿基 $\\{1,(x-x_0),(x-x_0)(x-x_1),\\dots\\}$ 和先前计算出的系数 $\\{c_k\\}_{k=0}^n$ 的嵌套乘法（nested multiplication），在任意点 $x$ 处对牛顿形式的插值多项式求值。\n- 对于每个次数 $n$，在区间 $[-1,1]$ 上生成两组插值节点：\n  - 等距节点：$x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。\n  - 第一类切比雪夫节点（Chebyshev nodes of the first kind）（极值点）在 $[-1,1]$ 上：$x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。使用弧度。\n- 对于每个插值多项式，在 $[-1,1]$ 上的一个由 $M$ 个均匀分布点组成的密集网格上计算 $p_n(x)$ 的值，并计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$，其中 $\\mathcal{G}$ 是求值网格。\n- 所有算术运算均使用双精度浮点数。\n\n测试套件规范：\n- 使用区间 $[-1,1]$ 上的龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$。\n- 使用一个包含 $M=10001$ 个在 $[-1,1]$ 上等距分布的点的求值网格 $\\mathcal{G}$。\n- 使用以下次数（每个次数对应 $n+1$ 个节点）：$n\\in\\{0,1,5,10,20\\}$。\n- 对于上述集合中的每个 $n$，计算两个数值：等距节点的 $E_{\\max}^{\\text{eq}}(n)$ 和切比雪夫节点的 $E_{\\max}^{\\text{ch}}(n)$（角度使用弧度）。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序包含实数：\n  - $\\big[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)\\big]$。\n- 输出必须是单行，且不得包含任何其他文本。", "solution": "该问题从插值的核心定义开始：给定 $n+1$ 个不同的节点 $\\{x_0,\\dots,x_n\\}$ 和数据值 $\\{y_0,\\dots,y_n\\}$（其中 $y_i=f(x_i)$），存在一个唯一的次数至多为 $n$ 的多项式 $p_n(x)$，使得对 $i=0,\\dots,n$ 都有 $p_n(x_i)=y_i$。一种构造性的表示方法是牛顿形式，它结合了两个基本部分：差商和牛顿基。牛顿基的递归定义为 $N_0(x)=1$，当 $k\\ge 1$ 时 $N_k(x)=(x-x_{k-1})N_{k-1}(x)$，由此可得 $N_k(x)=\\prod_{j=0}^{k-1}(x-x_j)$。插值多项式可以表示为 $p_n(x)=\\sum_{k=0}^n c_k N_k(x)$，其中系数 $c_k$ 是差商 $c_k=f[x_0,\\dots,x_k]$。差商通过递归从数据中确定：$f[x_i]=y_i$，并且对于 $k\\ge 1$，$f[x_i,\\dots,x_{i+k}]=\\dfrac{f[x_{i+1},\\dots,x_{i+k}]-f[x_i,\\dots,x_{i+k-1}]}{x_{i+k}-x_i}$。这种构造通过对 $i$ 进行归纳，直接编码了数据约束 $p_n(x_i)=y_i$，从而保证了存在性和唯一性。\n\n算法设计如下。首先，计算差商。我们可以在一个初始化为 $d_i^{(0)}=y_i$ 的数组 $d$ 上就地实现递归。对于每个阶数 $k=1,\\dots,n$ 和索引 $i=0,\\dots,n-k$，更新 $d_i^{(k)}=\\dfrac{d_{i+1}^{(k-1)}-d_i^{(k-1)}}{x_{i+k}-x_i}$。完成所有阶的计算后，牛顿系数为 $c_k=d_0^{(k)}$，其中 $k=0,\\dots,n$。这是一个 $O(n^2)$ 的操作，并且仅使用核心递归。\n\n其次，通过嵌套乘法（一种适用于牛顿基的类霍纳（Horner-like）方案）来高效且稳定地对插值多项式求值。从 $v=c_n$ 开始，对 $k=n-1,\\dots,0$ 累加 $v \\leftarrow c_{k}+ (x-x_k)\\,v$。这源于基的恒等式 $N_k(x)=(x-x_k)N_{k+1}(x)$ 重新排列后以嵌套形式表示 $p_n$：$p_n(x)=c_0+(x-x_0)\\left(c_1+(x-x_1)\\left(\\dots+(x-x_{n-1})c_n\\right)\\right)$。这种求值方法对每个点是 $O(n)$ 的，并且相对于朴素的基展开是数值稳定的。\n\n对于节点布局，我们比较了在 $[-1,1]$ 上的两种策略。等距节点使用 $x_i=-1+\\dfrac{2i}{n}$，其中 $i=0,\\dots,n$。第一类切比雪夫节点（极值点）是 $x_i=\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$，其中 $i=0,\\dots,n$。这些节点在端点附近聚集，并且已知能减少解析函数的最大插值误差。按照规定，所有三角计算都使用弧度。龙格函数 $f(x)=\\dfrac{1}{1+25x^2}$ 在 $[-1,1]$ 及其周围是解析的，但当使用等距节点进行插值时，它会著名地表现出龙格现象（Runge phenomenon）：随着 $n$ 的增加，由于在 $x=\\pm 1$ 附近的振荡，最大误差 $E_{\\max}$ 可能会恶化。切比雪夫节点通过最小化勒贝格常数（Lebesgue constant）的增长并将节点密度分布在最需要的地方来缓解这一问题。\n\n为了量化其行为，我们在 $[-1,1]$ 上的一个由 $M=10001$ 个等距点组成的密集网格 $\\mathcal{G}$ 上进行求值。对于每个 $n\\in\\{0,1,5,10,20\\}$ 和每种节点策略，我们在 $\\mathcal{G}$ 上计算插值多项式 $p_n(x)$，然后计算最大绝对误差 $E_{\\max}=\\max_{x\\in\\mathcal{G}}|p_n(x)-f(x)|$。程序在单行上输出序列 $[E_{\\max}^{\\text{eq}}(0),E_{\\max}^{\\text{ch}}(0),E_{\\max}^{\\text{eq}}(1),E_{\\max}^{\\text{ch}}(1),E_{\\max}^{\\text{eq}}(5),E_{\\max}^{\\text{ch}}(5),E_{\\max}^{\\text{eq}}(10),E_{\\max}^{\\text{ch}}(10),E_{\\max}^{\\text{eq}}(20),E_{\\max}^{\\text{ch}}(20)]$。我们预计，由于龙格现象，$E_{\\max}^{\\text{eq}}(n)$ 会随着 $n$ 的增加先减小后增大，而 $E_{\\max}^{\\text{ch}}(n)$ 则应更稳定地减小。\n\n实现细节确保了数值鲁棒性：\n- 差商使用双精度数组就地计算，以避免不必要的拷贝。\n- 求值过程在网格上使用向量化的嵌套乘法以提高效率。\n- 对于切比雪夫节点生成器，$n=0$ 的情况被明确处理，产生单个节点 $x_0=\\cos(0)=1$。\n- 对于 $n\\ge 1$，生成节点 $\\cos\\!\\left(\\dfrac{i\\pi}{n}\\right)$（其中 $i=0,\\dots,n$）并按升序排序；当系数针对排序后的顺序重新计算时，排序不会改变插值多项式，并且它能在不同策略间产生一致的顺序。\n\n这种有原则的方法直接反映了插值和差商的核心定义，利用牛顿基获得了高效的算法，并在固定网格上计算了所要求的误差度量，以便在不同节点集和次数之间进行客观比较。", "answer": "```python\nimport numpy as np\n\ndef runge_function(x: np.ndarray) -> np.ndarray:\n    # f(x) = 1 / (1 + 25 x^2)\n    return 1.0 / (1.0 + 25.0 * x * x)\n\ndef divided_differences(x: np.ndarray, y: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Compute Newton divided differences coefficients.\n    x: nodes (n+1,)\n    y: values at nodes (n+1,)\n    Returns coefficients c such that p(x) = c0 + c1*(x-x0) + ... in Newton form.\n    \"\"\"\n    n = x.size - 1\n    coeffs = y.astype(float).copy()\n    for k in range(1, n + 1):\n        coeffs[k:] = (coeffs[k:] - coeffs[k-1:-1]) / (x[k:] - x[:-k])\n    return coeffs\n\ndef newton_evaluate(x_eval: np.ndarray, x_nodes: np.ndarray, coeffs: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Evaluate Newton-form polynomial with given nodes and coefficients at x_eval.\n    Uses nested multiplication (Horner-like) for Newton basis.\n    \"\"\"\n    # Start from highest-order coefficient\n    p = np.full_like(x_eval, fill_value=coeffs[-1], dtype=float)\n    # Iterate backwards over nodes\n    for k in range(len(coeffs) - 2, -1, -1):\n        p = coeffs[k] + (x_eval - x_nodes[k]) * p\n    return p\n\ndef equispaced_nodes(n: int) -> np.ndarray:\n    # n+1 nodes from -1 to 1 inclusive\n    return np.linspace(-1.0, 1.0, n + 1, dtype=float)\n\ndef chebyshev_extrema_nodes(n: int) -> np.ndarray:\n    # Chebyshev nodes of the first kind (extrema): x_i = cos(i*pi/n), i=0..n\n    if n == 0:\n        nodes = np.array([1.0], dtype=float)\n    else:\n        i = np.arange(0, n + 1, dtype=float)\n        nodes = np.cos(np.pi * i / float(n))\n    # Sort ascending for consistency, newton form is invariant to node order\n    # but the evaluation algorithm expects x_nodes[k] to match coeffs[k] derivation.\n    return np.sort(nodes)\n\ndef max_abs_error_on_grid(n: int, node_strategy: str, grid: np.ndarray) -> float:\n    if node_strategy == \"equispaced\":\n        x_nodes = equispaced_nodes(n)\n    elif node_strategy == \"chebyshev\":\n        x_nodes = chebyshev_extrema_nodes(n)\n    else:\n        raise ValueError(\"Unknown node strategy\")\n\n    y_nodes = runge_function(x_nodes)\n    \n    # Sort nodes if they aren't already, and sort y_nodes accordingly.\n    # This is critical for the vectorized divided_differences function.\n    sort_idx = np.argsort(x_nodes)\n    x_nodes_sorted = x_nodes[sort_idx]\n    y_nodes_sorted = y_nodes[sort_idx]\n    \n    coeffs = divided_differences(x_nodes_sorted, y_nodes_sorted)\n    p_vals = newton_evaluate(grid, x_nodes_sorted, coeffs)\n    f_vals = runge_function(grid)\n    err = np.abs(p_vals - f_vals)\n    return float(np.max(err))\n\ndef solve():\n    # Define the test cases: degrees n\n    n_values = [0, 1, 5, 10, 20]\n    # Evaluation grid of M=10001 points on [-1,1]\n    M = 10001\n    grid = np.linspace(-1.0, 1.0, M, dtype=float)\n\n    results = []\n    for n in n_values:\n        e_eq = max_abs_error_on_grid(n, \"equispaced\", grid)\n        e_ch = max_abs_error_on_grid(n, \"chebyshev\", grid)\n        results.append(e_eq)\n        results.append(e_ch)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.15g}' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2426405"}]}