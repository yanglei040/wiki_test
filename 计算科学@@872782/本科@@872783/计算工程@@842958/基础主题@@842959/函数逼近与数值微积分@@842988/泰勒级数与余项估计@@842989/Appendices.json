{"hands_on_practices": [{"introduction": "在计算工程中，许多重要的函数（如误差函数 $\\operatorname{erf}(x)$）无法用初等函数表示，因此必须依赖数值近似。本练习将泰勒级数作为一种强大的工具，用于近似这类函数，并让您掌握一项核心技能。通过这个练习，您将学会如何利用拉格朗日余项来严格确定需要多少项级数才能达到预设的计算精度，这是设计可靠数值算法的基石。[@problem_id:2442184]", "problem": "在计算工程中，误差函数 (erf) 对实数输入的定义为\n$$\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp\\!\\left(-t^{2}\\right)\\, dt.$$\n对于 $\\operatorname{erf}(x)$ 的麦克劳林级数，考虑其截断\n$$S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1},$$\n其中 $c_{n}$ 是从 $\\operatorname{erf}(x)$ 在 $x=0$ 处的麦克劳林展开式中得到的系数。确定最小的整数 $N$，使得在 $S_{N}(x)$ 处截断能保证对于 $x=0$ 到 $x=0.5$ 的绝对近似误差满足\n$$\\left|\\operatorname{erf}(0.5) - S_{N}(0.5)\\right|  1.0 \\times 10^{-8}.$$\n只需提供整数 $N$ 作为最终答案。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- 误差函数定义为 $\\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_{0}^{x} \\exp(-t^{2})\\, dt$。\n- 截断的麦克劳林级数为 $S_{N}(x) = \\sum_{n=0}^{N} c_{n}\\, x^{2n+1}$。\n- 求值点为 $x=0.5$。\n- 要求的绝对误差容限为 $|\\operatorname{erf}(0.5) - S_{N}(0.5)|  1.0 \\times 10^{-8}$。\n- 目标是找到满足此条件的最小整数 $N$。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法恰当且客观。\n- **科学依据**：误差函数、其级数展开以及截断误差的分析是数学物理、数值分析和计算工程中的标准课题。所有定义都是标准和正确的。\n- **提法恰当性**：该问题要求找到满足特定不等式的最小整数 $N$。级数的性质确保了这样的整数存在且唯一。\n- **客观性**：该问题使用精确的数学语言陈述，没有歧义或主观内容。\n\n**步骤 3：结论与行动**\n该问题被认为是有效的。将制定一个完整的解决方案。\n\n求解过程首先要确定 $\\operatorname{erf}(x)$ 的麦克劳林级数。该过程从已知的指数函数的麦克劳林级数开始：\n$$ \\exp(u) = \\sum_{k=0}^{\\infty} \\frac{u^{k}}{k!} $$\n通过代入 $u = -t^2$，我们得到被积函数的级数：\n$$ \\exp(-t^2) = \\sum_{k=0}^{\\infty} \\frac{(-t^2)^{k}}{k!} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} $$\n该级数具有无穷收敛半径，这允许在任何有限区间上进行逐项积分。从 $t=0$ 到 $t=x$ 积分：\n$$ \\int_{0}^{x} \\exp(-t^{2})\\, dt = \\int_{0}^{x} \\left( \\sum_{k=0}^{\\infty} \\frac{(-1)^k t^{2k}}{k!} \\right) dt = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\int_{0}^{x} t^{2k}\\, dt $$\n$$ = \\sum_{k=0}^{\\infty} \\frac{(-1)^k}{k!} \\left[ \\frac{t^{2k+1}}{2k+1} \\right]_{0}^{x} = \\sum_{k=0}^{\\infty} \\frac{(-1)^k x^{2k+1}}{k!(2k+1)} $$\n乘以 $\\operatorname{erf}(x)$ 定义中的常数因子 $\\frac{2}{\\sqrt{\\pi}}$，得到其麦克劳林级数。为了与问题的符号表示一致，我们使用索引 $n$ 代替 $k$：\n$$ \\operatorname{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=0}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n截断级数由 $S_N(x) = \\sum_{n=0}^{N} c_n x^{2n+1}$ 给出，其中系数为 $c_n = \\frac{2}{\\sqrt{\\pi}} \\frac{(-1)^n}{n!(2n+1)}$。近似误差是余项 $R_N(x) = \\operatorname{erf}(x) - S_N(x)$。\n$$ R_N(x) = \\frac{2}{\\sqrt{\\pi}} \\sum_{n=N+1}^{\\infty} \\frac{(-1)^n x^{2n+1}}{n!(2n+1)} $$\n对于任何固定的 $x  0$，$\\operatorname{erf}(x)$ 的麦克劳林级数是一个交错级数。为了应用交错级数余项定理，我们必须验证对于 $x=0.5$，级数项的绝对值是单调递减趋于零的。令 $a_n = \\frac{2}{\\sqrt{\\pi}} \\frac{x^{2n+1}}{n!(2n+1)}$。连续项的绝对值之比为：\n$$ \\frac{a_{n+1}}{a_n} = \\frac{x^{2(n+1)+1}}{(n+1)!(2(n+1)+1)} \\cdot \\frac{n!(2n+1)}{x^{2n+1}} = \\frac{x^2 (2n+1)}{(n+1)(2n+3)} $$\n对于 $x=0.5$，该比值变为：\n$$ \\frac{(0.5)^2 (2n+1)}{(n+1)(2n+3)} = \\frac{0.25(2n+1)}{2n^2+5n+3} $$\n对于所有 $n \\ge 0$，分母 $2n^2+5n+3$ 严格大于分子 $0.5n+0.25$。因此，该比值始终小于 $1$，这证实了各项的绝对值是单调递减的。由于分母中有阶乘，当 $n \\to \\infty$ 时，项的极限为零。\n\n交错级数余项定理指出，绝对误差 $|R_N(x)|$ 小于被舍弃的第一项的绝对值，该项对应于 $n=N+1$。\n$$ |\\operatorname{erf}(0.5) - S_N(0.5)| = |R_N(0.5)| \\le \\left| c_{N+1} (0.5)^{2(N+1)+1} \\right| $$\n$$ |R_N(0.5)| \\le \\frac{2}{\\sqrt{\\pi}} \\frac{(0.5)^{2N+3}}{(N+1)!(2N+3)} $$\n我们要求这个误差界小于 $1.0 \\times 10^{-8}$：\n$$ \\frac{2}{\\sqrt{\\pi}} \\frac{1}{2^{2N+3}(N+1)!(2N+3)}  10^{-8} $$\n这可以简化为：\n$$ \\frac{1}{\\sqrt{\\pi} \\cdot 2^{2N+2}(N+1)!(2N+3)}  10^{-8} $$\n我们必须找到满足此不等式的最小整数 $N$。我们测试 $N$ 的值。\n对于 $N=5$：\n误差界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{12} \\cdot 6! \\cdot (13)} = \\frac{1}{\\sqrt{\\pi} \\cdot 4096 \\cdot 720 \\cdot 13} = \\frac{1}{\\sqrt{\\pi} \\cdot 38338560}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 38338560 \\approx 6.795 \\times 10^7$。\n误差界约等于 $\\frac{1}{6.795 \\times 10^7} \\approx 1.47 \\times 10^{-8}$。\n由于 $1.47 \\times 10^{-8} > 1.0 \\times 10^{-8}$，$N=5$ 是不够的。\n\n对于 $N=6$：\n误差界为 $\\frac{1}{\\sqrt{\\pi} \\cdot 2^{14} \\cdot 7! \\cdot (15)} = \\frac{1}{\\sqrt{\\pi} \\cdot 16384 \\cdot 5040 \\cdot 15} = \\frac{1}{\\sqrt{\\pi} \\cdot 1238630400}$。\n使用 $\\sqrt{\\pi} \\approx 1.77245$，分母约等于 $1.77245 \\times 1238630400 \\approx 2.196 \\times 10^9$。\n误差界约等于 $\\frac{1}{2.196 \\times 10^9} \\approx 4.55 \\times 10^{-10}$。\n由于 $4.55 \\times 10^{-10}  1.0 \\times 10^{-8}$，$N=6$ 是足够的。\n\n因此，保证所需精度的最小整数值 $N$ 是 $6$。", "answer": "$$ \\boxed{6} $$", "id": "2442184"}, {"introduction": "一个常见的直觉是，在泰勒展开中包含的项数越多，近似效果就越好。然而，在实际的误差分析中，情况可能更为微妙。本练习引导您进行一个思想实验，通过比较一阶和二阶泰勒近似的先验误差上界，揭示近似阶数与近似半径之间的权衡关系。您将推导出一个临界条件，在该条件下，高阶近似的保证误差反而可能比低阶近似更差，这对于理解模型选择和误差控制至关重要。[@problem_id:2442165]", "problem": "在计算工程的降阶建模程序中，一个标量响应函数 $f:\\mathbb{R}\\to\\mathbb{R}$ 将在点 $a\\in\\mathbb{R}$ 附近用泰勒多项式进行近似。假设 $f$ 在闭区间 $[a-r,a+r]$ 上是 $3$ 次连续可微的，其中半径 $r0$。对于此区间内的所有 $x$，只给出以下导数界：\n- $\\lvert f^{\\prime\\prime}(x)\\rvert\\leq M_{2}$，\n- $\\lvert f^{\\prime\\prime\\prime}(x)\\rvert\\leq M_{3}$，\n其中 $M_{2}0$ 和 $M_{3}0$ 是已知常数。\n\n令 $T_{1}$ 和 $T_{2}$ 分别表示 $f$ 关于点 $a$ 的一阶和二阶泰勒多项式。对于每个半径 $r0$，定义量 $E_{k}(r)$ 为仅使用给定的界，能够保证的 $T_{k}$ 在闭邻域 $\\{x\\in\\mathbb{R}:\\lvert x-a\\rvert\\leq r\\}$ 上的绝对截断误差的最小一致上界，其中 $k\\in\\{1,2\\}$。\n\n确定最小半径 $r_{c}=r_{c}(M_{2},M_{3})$，使得对于每个 $rr_{c}$，二阶多项式的先验最坏情况绝对截断误差界严格大于一阶多项式的误差界；即 $E_{2}(r)E_{1}(r)$。以 $M_{2}$ 和 $M_{3}$ 的闭式解析表达式形式给出你的最终答案。无需进行数值四舍五入。", "solution": "问题要求确定一个临界半径 $r_{c}$，当半径超过该值时，二阶泰勒近似的保证误差界将超过一阶近似的误差界。我们将通过建立这些误差界的表达式来求解。\n\n函数 $f: \\mathbb{R} \\to \\mathbb{R}$ 在闭区间 $[a-r, a+r]$ 上是 $3$ 次连续可微的。$f$ 关于点 $a$ 展开的一阶和二阶泰勒多项式，分别记为 $T_{1}(x)$ 和 $T_{2}(x)$，是：\n$$T_{1}(x) = f(a) + f^{\\prime}(a)(x-a)$$\n$$T_{2}(x) = f(a) + f^{\\prime}(a)(x-a) + \\frac{f^{\\prime\\prime}(a)}{2!}(x-a)^{2}$$\n\n相应的截断误差或余项由 $R_{1}(x) = f(x) - T_{1}(x)$ 和 $R_{2}(x) = f(x) - T_{2}(x)$ 给出。根据带有拉格朗日余项形式的泰勒定理，对于所研究域中的任何 $x$，都存在数 $\\xi_{1}$ 和 $\\xi_{2}$，两者都严格位于 $a$ 和 $x$ 之间，使得：\n$$R_{1}(x) = \\frac{f^{\\prime\\prime}(\\xi_{1})}{2!}(x-a)^{2}$$\n$$R_{2}(x) = \\frac{f^{\\prime\\prime\\prime}(\\xi_{2})}{3!}(x-a)^{3}$$\n\n量 $E_{k}(r)$ 被定义为仅使用给定的导数界，在邻域 $\\{x \\in \\mathbb{R} : |x-a| \\leq r\\}$ 上对绝对截断误差 $|R_{k}(x)|$ 的最小保证一致上界。\n\n对于一阶近似 ($k=1$)，绝对误差为：\n$$|R_{1}(x)| = \\left| \\frac{f^{\\prime\\prime}(\\xi_{1})}{2!}(x-a)^{2} \\right| = \\frac{|f^{\\prime\\prime}(\\xi_{1})|}{2}|x-a|^{2}$$\n为建立一致界 $E_{1}(r)$，我们必须找到该表达式对于所有满足 $|x-a| \\leq r$ 的 $x$ 的上确界。给定的界是对于此邻域中的所有 $x$ 都有 $|f^{\\prime\\prime}(x)| \\leq M_{2}$。项 $|x-a|^{2}$ 在邻域的边界处取得最大值，即 $|x-a| = r$。因此，可以被保证的最紧的一致界是：\n$$E_{1}(r) = \\sup_{|x-a|\\leq r} \\frac{|f^{\\prime\\prime}(\\xi_{1})|}{2}|x-a|^{2} = \\frac{M_{2}}{2}r^{2}$$\n\n类似地，对于二阶近似 ($k=2$)，绝对误差为：\n$$|R_{2}(x)| = \\left| \\frac{f^{\\prime\\prime\\prime}(\\xi_{2})}{3!}(x-a)^{3} \\right| = \\frac{|f^{\\prime\\prime\\prime}(\\xi_{2})|}{6}|x-a|^{3}$$\n使用给定的界 $|f^{\\prime\\prime\\prime}(x)| \\leq M_{3}$ 并在邻域上最大化 $|x-a|^{3}$（在 $|x-a|=r$ 处取得），我们得到保证的一致界：\n$$E_{2}(r) = \\sup_{|x-a|\\leq r} \\frac{|f^{\\prime\\prime\\prime}(\\xi_{2})|}{6}|x-a|^{3} = \\frac{M_{3}}{6}r^{3}$$\n\n问题要求找到最小的半径 $r_{c}$，使得对于所有 $r  r_{c}$，不等式 $E_{2}(r)  E_{1}(r)$ 成立。我们用推导出的表达式构建这个不等式：\n$$\\frac{M_{3}}{6}r^{3}  \\frac{M_{2}}{2}r^{2}$$\n问题指明 $r  0$，并且给定的常数 $M_{2}$ 和 $M_{3}$ 是正的。因此，我们可以将不等式两边同时除以正量 $r^{2}$ 而不改变不等号的方向：\n$$\\frac{M_{3}}{6}r  \\frac{M_{2}}{2}$$\n为分离出 $r$，我们将两边同时乘以正常数 $\\frac{6}{M_{3}}$：\n$$r  \\frac{M_{2}}{2} \\cdot \\frac{6}{M_{3}}$$\n$$r  \\frac{3M_{2}}{M_{3}}$$\n这个不等式指明了 $r$ 必须满足的条件。问题要求的是最小的值 $r_{c}$，使得对于任何大于 $r_{c}$ 的半径 $r$，该条件都成立。满足所推导不等式的所有 $r$ 值的集合是开区间 $(\\frac{3M_{2}}{M_{3}}, \\infty)$。可以作为所有这些 $r$ 的下界的最小数 $r_{c}$ 是这个集合的下确界。\n因此，临界半径为：\n$$r_{c} = \\frac{3M_{2}}{M_{3}}$$", "answer": "$$\\boxed{\\frac{3M_{2}}{M_{3}}}$$", "id": "2442165"}, {"introduction": "将理论知识转化为可靠的代码是计算工程的核心。直接使用麦克劳林级数计算 $\\sin(x)$ 这样看似简单的任务，在输入值 $|x|$ 较大时会遭遇灾难性的数值不稳定性。本练习要求您不仅要运用余项估计来控制截断误差，还要设计并实现一个“参数约简”策略来克服这个问题。通过对比朴素实现和稳健实现，您将深刻体会到理论分析与高质量数值软件开发之间的联系。[@problem_id:2442233]", "problem": "你需要编写一个完整、可运行的程序，该程序使用麦克劳林级数计算正弦函数，并严格控制截断误差，同时分析这种方法对于大宗量的数值稳定性。计算过程完全使用弧度制。\n\n从以下基本原理出发：\n- 解析函数的麦克劳林级数定义以及拉格朗日余项形式。对于一个足够可微的函数 $f$，其在 $x=0$ 处的 $m$ 次麦克劳林多项式的余项为 $R_{m}(x) = \\dfrac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n- 三角函数的周期性和奇偶性恒等式：对于任意整数 $k$，有 $ \\sin(x + 2\\pi k) = \\sin(x)$；以及和角与象限对称性，这些对称性将 $ \\sin(x)$ 与 $ \\sin(r)$ 或 $ \\cos(r)$ 相关联，其中 $r$ 是通过减去 $ \\dfrac{\\pi}{2}$ 的整数倍进行归约后得到的小余量。\n\n你的任务：\n1) 根据麦克劳林定义和拉格朗日余项公式，推导一个用于截断 $ \\sin(x)$ 和 $ \\cos(x)$ 麦克劳林级数的停止准则，以达到用户指定的绝对误差容限 $ \\varepsilon  0$。特别地，利用 $ \\sin(x)$ 或 $ \\cos(x)$ 的任意阶导数的绝对值在实数轴上至多为 $1$ 这一性质，来证明如下形式的界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}, \n\\qquad\n\\left| R_{2N}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!},\n$$\n然后，制定一个过程，对于给定的小宗量 $z$，找到最小的整数 $N \\ge 0$，使得相应的余项界小于或等于 $ \\varepsilon$。\n\n2) 设计并实现一个宗量归约策略。对于任意实数 $x$，该策略使用 $ \\dfrac{\\pi}{2}$ 的整数倍将 $x$ 映射到一个位于区间 $[-\\dfrac{\\pi}{4}, \\dfrac{\\pi}{4}]$ 内的余量 $r$ 和一个象限索引 $q \\in \\{0,1,2,3\\}$，使得：\n$$\n\\sin(x) = \n\\begin{cases}\n\\phantom{-}\\sin(r),  q \\equiv 0 \\ (\\text{mod } 4),\\\\\n\\phantom{-}\\cos(r),  q \\equiv 1 \\ (\\text{mod } 4),\\\\\n-\\sin(r),  q \\equiv 2 \\ (\\text{mod } 4),\\\\\n-\\cos(r),  q \\equiv 3 \\ (\\text{mod } 4).\n\\end{cases}\n$$\n使用此映射关系来选择在小余量 $r$ 处计算哪一个麦克劳林级数（正弦或余弦）。利用任务 $1$ 中的停止准则来确定保证截断误差不超过 $ \\varepsilon$ 所需的最小级数项数。\n\n3) 从第一性原理出发，解释为什么对大的 $|x|$ 直接进行麦克劳林求值是数值不稳定的：分析在阶乘增长占主导地位之前，中间项的量级如何变化，以及有限精度算术如何加剧抵消效应。然后，将其与宗量归约策略的稳定性进行对比，并解释其局限性，即对于极大的 $|x|$，由于尾数位的限制，浮点归约 $x \\mapsto r$ 本身可能损失精度。\n\n4) 为一个输入测试集实现以下程序化输出。对于每个测试用例参数对 $(x, \\varepsilon)$：\n- 使用你的宗量归约麦克劳林方法计算 $s_{\\text{approx}}$。\n- 计算一个布尔值 $b_{\\text{ok}}$，当且仅当 $|s_{\\text{approx}} - \\sin(x)| \\le \\varepsilon$ 时为真，其中右侧的 $ \\sin(x)$ 使用高质量的库函数作为参考值进行计算。\n- 报告为所选级数实际求和的最小非零麦克劳林项数，记为 $T$（对于 $ \\sin$，这是对应于次数 $1,3,\\dots,2N+1$ 的 $T = N+1$ 项；对于 $ \\cos$，这是对应于次数 $0,2,\\dots,2N$ 的 $T = N+1$ 项）。\n- 评估在相同容限下，对 $ \\sin(x)$ 的朴素、未归约的麦克劳林级数是否实际不可用。评估方法是检查在余项界降到 $ \\varepsilon$ 以下之前，是否必须超过 $T_{\\max} = 1000$ 个非零项的上限，或者中间项是否溢出为非有限值。如果不可用，则将布尔值 $b_{\\text{naive\\_impractical}}$ 记录为真，否则为假。\n\n角度单位：弧度。没有物理单位。所有百分比（如有）必须表示为小数。\n\n测试集：\n- 用例 1：$(x, \\varepsilon) = (100.0, 10^{-12})$。\n- 用例 2：$(x, \\varepsilon) = (10^{6} + 0.1, 10^{-12})$。\n- 用例 3：$(x, \\varepsilon) = (10^{16} + 0.1, 10^{-12})$。\n- 用例 4：$(x, \\varepsilon) = \\left(\\dfrac{\\pi}{2} + 10^{-8}, 10^{-15}\\right)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于上述顺序中的第 $k$ 个测试用例，输出三元组 $[b_{\\text{ok}}, T, b_{\\text{naive\\_impractical}}]$，并将这些三元组按测试用例的顺序展开成一个单一列表。例如，最后一行应类似于\n$[b_{\\text{ok},1}, T_{1}, b_{\\text{naive\\_impractical},1}, b_{\\text{ok},2}, T_{2}, b_{\\text{naive\\_impractical},2}, b_{\\text{ok},3}, T_{3}, b_{\\text{naive\\_impractical},3}, b_{\\text{ok},4}, T_{4}, b_{\\text{naive\\_impractical},4}]$。", "solution": "所述问题定义明确、内部一致，并基于数值分析和微积分的基本原理。它既不模棱两可，也非科学上不成立。因此，我们将按要求进行严格的推导和实现。\n\n任务是实现一种数值稳定的方法，利用麦克劳林级数展开来计算正弦函数 $\\sin(x)$，并分析其相对于朴素直接计算的性能。解决方案分为三个主要部分：级数截断准则的推导、宗量归约策略的开发以及数值稳定性的分析。\n\n**1. 截断准则的推导**\n\n解析函数 $f(x)$ 在 $x=0$ 附近展开的麦克劳林级数由 $f(x) = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(0)}{k!} x^k$ 给出。当这个级数在 $m$ 次项后被截断时，结果是麦克劳林多项式 $P_m(x)$，误差是余项 $R_m(x)$。根据拉格朗日余项形式，$R_m(x) = \\frac{f^{(m+1)}(\\xi)}{(m+1)!} x^{m+1}$，其中 $\\xi$ 介于 $0$ 和 $x$ 之间。\n\n对于 $f(x) = \\sin(x)$，其导数是周期性的：$\\sin'(x) = \\cos(x)$，$\\sin''(x) = -\\sin(x)$，依此类推。关键的是，对于任意整数 $k \\ge 0$，其 $k$ 阶导数满足 $|f^{(k)}(x)| \\le 1$ 对所有实数 $x$ 成立。$\\sin(x)$ 的麦克劳林级数只包含 $x$ 的奇次幂：\n$$\n\\sin(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k+1)!} x^{2k+1} + R_{2N+1}(x)\n$$\n这里，我们在对应于 $k=N$（即次数为 $2N+1$）的项之后截断级数。其多项式部分 $P_{2N+1}(x)$ 与 $P_{2N+2}(x)$ 相同，因为 $x^{2N+2}$ 的系数为零。因此，余项是 $R_{2N+2}(x)$，由下式给出：\n$$\nR_{2N+2}(x) = \\frac{f^{(2N+3)}(\\xi)}{(2N+3)!} x^{2N+3}\n$$\n其中 $f^{(2N+3)}(x)$ 是 $\\pm\\sin(x)$ 或 $\\pm\\cos(x)$。利用界 $|f^{(2N+3)}(\\xi)| \\le 1$，我们为在 $2N+1$ 次截断的正弦级数建立了误差界：\n$$\n\\left| R_{2N+1}^{\\sin}(x) \\right| = \\left| R_{2N+2}^{\\sin}(x) \\right| \\le \\frac{|x|^{2N+3}}{(2N+3)!}\n$$\n这证实了问题陈述中给出的不等式。\n\n对于 $f(x) = \\cos(x)$，其麦克劳林级数只包含 $x$ 的偶次幂：\n$$\n\\cos(x) = \\sum_{k=0}^{N} \\frac{(-1)^k}{(2k)!} x^{2k} + R_{2N}(x)\n$$\n多项式 $P_{2N}(x)$ 与 $P_{2N+1}(x)$ 相同。余项是 $R_{2N+1}(x)$：\n$$\nR_{2N+1}(x) = \\frac{f^{(2N+2)}(\\xi)}{(2N+2)!} x^{2N+2}\n$$\n同样，利用界 $|f^{(2N+2)}(\\xi)| \\le 1$，我们得到在 $2N$ 次截断的余弦级数的误差界：\n$$\n\\left| R_{2N}^{\\cos}(x) \\right| = \\left| R_{2N+1}^{\\cos}(x) \\right| \\le \\frac{|x|^{2N+2}}{(2N+2)!}\n$$\n这也证实了问题的表述。\n\n为了满足对小宗量 $z$ 指定的绝对误差容限 $\\varepsilon  0$，我们必须找到最小的非负整数 $N$，使得误差界不超过 $\\varepsilon$。\n对于 $\\sin(z)$，我们必须找到最小的 $N \\ge 0$，使得 $\\frac{|z|^{2N+3}}{(2N+3)!} \\le \\varepsilon$。\n对于 $\\cos(z)$，我们必须找到最小的 $N \\ge 0$，使得 $\\frac{|z|^{2N+2}}{(2N+2)!} \\le \\varepsilon$。\n这需要一个迭代搜索，从 $N=0$ 开始，递增 $N$ 直到条件满足。要求和的非零项数则为 $T = N+1$。\n\n**2. 宗量归约策略**\n\n对于大的 $|x|$，直接计算麦克劳林级数是低效且数值不稳定的。一种标准且稳健的技术是宗量归约，它利用了三角函数的周期性。任何实数 $x$ 都可以表示为 $x = q \\cdot \\frac{\\pi}{2} + r$，其中 $q$ 是一个整数，$r$ 是一个小余量。我们选择 $q$ 为最接近 $x / (\\pi/2)$ 值的整数，这确保了余量 $r$ 位于区间 $[-\\frac{\\pi}{4}, \\frac{\\pi}{4}]$ 内。\n过程如下：\n1. 计算 $y = x / (\\pi/2)$。\n2. 找到最接近的整数 $q = \\text{round}(y)$。\n3. 计算余量 $r = x - q \\cdot (\\pi/2)$。根据构造，有 $|r| \\le \\frac_1{2} \\cdot \\frac{\\pi}{2} = \\frac{\\pi}{4}$。\n\n$\\sin(x)$ 的值随后与 $\\sin(r)$ 或 $\\cos(r)$ 相关，具体取决于 $q$ 模 4 的值。令 $q_{\\text{mod} 4} = q \\pmod 4$。我们使用和角恒等式：\n- 如果 $q_{\\text{mod} 4} = 0$：$\\sin(x) = \\sin(4k \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + r) = \\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 1$：$\\sin(x) = \\sin((4k+1) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{\\pi}{2} + r) = \\cos(r)$。\n- 如果 $q_{\\text{mod} 4} = 2$：$\\sin(x) = \\sin((4k+2) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\pi + r) = -\\sin(r)$。\n- 如果 $q_{\\text{mod} 4} = 3$：$\\sin(x) = \\sin((4k+3) \\cdot \\frac{\\pi}{2} + r) = \\sin(2k\\pi + \\frac{3\\pi}{2} + r) = -\\cos(r)$。\n\n该策略将计算任意 $x$ 的 $\\sin(x)$ 问题，归约为计算小宗量 $|r| \\le \\pi/4$ 的 $\\sin(r)$ 或 $\\cos(r)$。对于这样的小宗量，麦克劳林级数收敛迅速，并且可以高效地应用前一节推导的截断准则来确定所需的项数。\n\n**3. 数值稳定性分析**\n\n对大 $|x|$ 直接计算麦克劳林级数在数值上是不稳定的，这主要源于两个问题：中间项溢出和灾难性抵消。\n\n- **中间项增长与溢出**：$\\sin(x)$ 级数的第 $k$ 项是 $t_k = \\frac{(-1)^k x^{2k+1}}{(2k+1)!}$。这些项的量级初始时随 $k$ 迅速增长。最大项量级出现在比率 $|t_{k+1}/t_k| = \\frac{|x|^2}{(2k+2)(2k+3)} \\approx 1$ 时，这意味着 $2k+2 \\approx |x|$。对于像 $x=100$ 这样的大值，这些项会增长到天文数字般的大小（例如，当 $k=49$ 时，项的量级约为 $100^{99}/99!$，这很容易超出标准双精度浮点数的范围，约 $10^{308}$）。\n\n- **灾难性抵消**：最终结果 $\\sin(x)$ 必须位于 $[-1, 1]$ 区间内。对于大 $x$ 的级数求值过程涉及对非常大的正项和负项求和以产生一个小的最终结果。标准浮点数具有固定数量的有效数字（即尾数）。当两个大小相近的大数相减时，前导的有效数字会相互抵消，导致结果的有效数字位数大大减少。这种相对精度的损失被称为灾难性抵消，它会使最终结果变得毫无意义。\n\n宗量归约策略完全规避了这些问题。宗量 $r$ 很小（$|r| \\le \\pi/4 \\approx 0.785$），因此麦克劳林级数项 $\\frac{r^k}{k!}$ 的量级从一开始就是单调递减的。中间项不会增长，因此不会发生灾难性抵消。该方法是数值稳定的。\n\n然而，宗量归约本身也有一个局限性。当 $x$ 极大时，步骤 $r = x - q \\cdot (\\pi/2)$ 可能会遭受灾难性抵消。原因是 $\\pi$ 的标准浮点表示具有有限的精度。对于一个非常大的 $x$（例如，$x=10^{16}+0.1$），在标准 `float64` 算术中，$x$ 本身可能就会被舍入（对于 $10^{16}$，其末位单位大于 $0.1$，所以 $10^{16}+0.1$ 被存储为精确的 $10^{16}$）。即使 $x$ 是可表示的，乘积 $q \\cdot (\\pi/2)$ 也将是一个接近 $x$ 的大数。`float64` 表示的 $\\pi$ 的有限精度会给这个乘积引入一个与 $q$ 成比例的绝对误差。当 $x$ 很大时，$q$ 也很大，这个误差可能变得非常显著，甚至可能大于 $\\pi/2$ 本身。此时，减法 $x - q \\cdot (\\pi/2)$ 会抵消掉大部分有效数字，得到的 $r$ 值几乎没有（或完全没有）正确的数字。这展示了使用定点精度算术进行计算时，对于极大宗量所面临的基本限制。预计这种现象将导致 $x = 10^{16} + 0.1$ 的测试用例无法通过精度检查。\n\n所提供的程序实现了这些原理，以计算正弦函数并分析其在指定测试用例下的数值特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef get_required_terms_sin(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the sin Maclaurin series.\n    The error bound after T terms (degree 2T-1) is |z|^(2T+1)/(2T+1)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 1)\n    bound = (z_abs**3) / 6.0\n    T = 1\n    \n    denom_fac1 = 4\n    denom_fac2 = 5\n    \n    while bound > ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T > 1000: # Safety break\n            return T\n            \n    return T\n\ndef get_required_terms_cos(z_abs, ε):\n    \"\"\"\n    Calculates the minimum number of terms T for the cos Maclaurin series.\n    The error bound after T terms (degree 2T-2) is |z|^(2T)/(2T)!.\n    \"\"\"\n    if z_abs == 0.0:\n        return 1\n    \n    z2 = z_abs * z_abs\n    \n    # Bound for T=1 term (degree 0)\n    bound = z2 / 2.0\n    T = 1\n    \n    denom_fac1 = 3\n    denom_fac2 = 4\n\n    while bound > ε:\n        T += 1\n        bound *= z2 / (denom_fac1 * denom_fac2)\n        denom_fac1 += 2\n        denom_fac2 += 2\n        if T > 1000: # Safety break\n            return T\n            \n    return T\n\ndef eval_sin_series(z, T):\n    \"\"\"Evaluates the sin Maclaurin series for T terms.\"\"\"\n    if z == 0.0:\n        return 0.0\n\n    z2 = z * z\n    term = z\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k)(2k+1))\n        term *= -z2 / ((2 * k) * (2 * k + 1))\n        total += term\n    return total\n\ndef eval_cos_series(z, T):\n    \"\"\"Evaluates the cos Maclaurin series for T terms.\"\"\"\n    z2 = z * z\n    term = 1.0\n    total = term\n    for k in range(1, T):\n        # term_k = -term_{k-1} * z^2 / ((2k-1)(2k))\n        term *= -z2 / ((2 * k - 1) * (2 * k))\n        total += term\n    return total\n\ndef compute_sin_reduced(x, ε):\n    \"\"\"\n    Computes sin(x) using argument reduction and Maclaurin series.\n    Returns the computed value and the number of terms used.\n    \"\"\"\n    pi_over_2 = np.pi / 2.0\n    \n    # Argument reduction\n    q_float = x / pi_over_2\n    q = np.round(q_float)\n    r = x - q * pi_over_2\n    \n    q_int = int(q)\n    quadrant = q_int % 4\n    \n    r_abs = abs(r)\n\n    if quadrant == 0:  # sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return val, T\n    elif quadrant == 1:  # cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return val, T\n    elif quadrant == 2:  # -sin(r)\n        T = get_required_terms_sin(r_abs, ε)\n        val = eval_sin_series(r, T)\n        return -val, T\n    else:  # quadrant == 3, -cos(r)\n        T = get_required_terms_cos(r_abs, ε)\n        val = eval_cos_series(r, T)\n        return -val, T\n\ndef check_naive_impractical(x, ε, T_max):\n    \"\"\"\n    Checks if a naive Maclaurin series evaluation of sin(x) is impractical.\n    Impractical if > T_max terms are needed or if intermediate terms overflow.\n    \"\"\"\n    x_abs = abs(x)\n    if x_abs == 0.0:\n        return False\n        \n    x2 = x_abs * x_abs\n    \n    # Check terms and remainder bound iteratively for T = 1, 2, ...\n    \n    # T=1 term magnitude (|x|)\n    term_mag = x_abs\n    if np.isinf(term_mag):\n        return True # Overflow\n\n    # Remainder bound for T=1 term\n    remainder_bound = term_mag * x2 / 6.0\n    if remainder_bound = ε:\n        return False # Practical\n    \n    for T in range(2, T_max + 1):\n        # Magnitude of the T-th term\n        # term_mag(T) = term_mag(T-1) * x^2 / ((2T-2)*(2T-1))\n        term_mag *= x2 / ((2*T - 2) * (2*T - 1))\n        if np.isinf(term_mag):\n            return True # Overflow of intermediate term\n\n        # Remainder bound for T terms\n        # bound(T) = term_mag(T) * x^2 / ((2T)*(2T+1))\n        remainder_bound = term_mag * x2 / ((2*T) * (2*T + 1))\n        if np.isinf(remainder_bound):\n            # This can happen if term_mag is huge but finite\n            # and gets multiplied by a large x2\n            return True\n            \n        if remainder_bound = ε:\n            return False # Practical, convergence within T_max terms\n\n    return True # Not converged within T_max terms\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and produce the final output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 1e-12),\n        (10**6 + 0.1, 1e-12),\n        (10**16 + 0.1, 1e-12),\n        (np.pi/2 + 1e-8, 1e-15),\n    ]\n\n    results = []\n    for x, ε in test_cases:\n        # 1. Compute s_approx and T using the reduced method.\n        s_approx, T = compute_sin_reduced(x, ε)\n        \n        # 2. Compute b_ok by comparing with a high-quality reference.\n        # Use np.longdouble for reference calculation where precision matters\n        ref_val = np.sin(np.longdouble(x))\n        b_ok = np.abs(s_approx - ref_val) = ε\n        \n        # 3. Assess if naive method is impractical.\n        T_max = 1000\n        b_naive_impractical = check_naive_impractical(x, ε, T_max)\n        \n        results.extend([b_ok, T, b_naive_impractical])\n\n    # Final print statement in the exact required format.\n    # Python's str() for a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2442233"}]}