{"hands_on_practices": [{"introduction": "这个练习为理解不同的插值策略提供了一个具体的起点。通过使用简单的分段线性模型和更平滑的自然三次样条计算插值，你将直接体会到计算简便性与结果曲线平滑度之间的权衡。在模拟柔性杆弯曲等物理现象时，这种洞察力至关重要，因为平滑度是其关键属性。[@problem_id:2164998]", "problem": "一位工程师正在为一个细柔性杆的形状建模，该杆被约束以穿过二维笛卡尔平面中的三个点：$P_0=(-1, 1)$、$P_1=(0, 0)$ 和 $P_2=(1, 1)$。提出了两种简单的模型来估计杆在其他水平位置 $x$ 处的垂直位置 $y$。\n\n模型 A 是分段线性插值，它用直线段连接指定的点。\n模型 B 是自然三次样条，它通过在内点匹配一阶和二阶导数来确保曲线光滑，并且在端点处具有零二阶导数。\n\n计算由模型 A 和模型 B 预测的杆在 $x=0.5$ 处的垂直位置。令这些值分别为 $y_A$ 和 $y_B$。将您的答案表示为一对精确分数 $(y_A, y_B)$。", "solution": "我们将节点标记为 $x_{0}=-1$、$x_{1}=0$、$x_{2}=1$，其对应值为 $y_{0}=1$、$y_{1}=0$、$y_{2}=1$。\n\n模型 A (分段线性插值)：对于 $x \\in [x_{1},x_{2}]$，经过 $(0,0)$ 和 $(1,1)$ 的直线的斜率为\n$$\nm=\\frac{y_{2}-y_{1}}{x_{2}-x_{1}}=\\frac{1-0}{1-0}=1,\n$$\n所以插值函数为\n$$\ny(x)=y_{1}+m(x-x_{1})=0+1\\cdot(x-0)=x.\n$$\n在 $x=\\frac{1}{2}$ 处求值得\n$$\ny_{A}=y\\!\\left(\\frac{1}{2}\\right)=\\frac{1}{2}.\n$$\n\n模型 B (自然三次样条)：令 $M_{i}=S''(x_{i})$。自然边界条件给出 $M_{0}=0$ 和 $M_{2}=0$。当 $h_{0}=x_{1}-x_{0}=1$ 和 $h_{1}=x_{2}-x_{1}=1$ 时，在内部节点 $i=1$ 处的三次样条方程组为\n$$\nh_{0}M_{0}+2(h_{0}+h_{1})M_{1}+h_{1}M_{2}=6\\left(\\frac{y_{2}-y_{1}}{h_{1}}-\\frac{y_{1}-y_{0}}{h_{0}}\\right).\n$$\n代入数值，\n$$\n1\\cdot 0+2(1+1)M_{1}+1\\cdot 0=6\\left(\\frac{1-0}{1}-\\frac{0-1}{1}\\right)=6(1-(-1))=12,\n$$\n所以\n$$\n4M_{1}=12 \\quad \\Rightarrow \\quad M_{1}=3.\n$$\n在区间 $[x_{1},x_{2}]=[0,1]$ 上，样条函数为\n$$\nS(x)=\\frac{M_{1}}{6h_{1}}(x_{2}-x)^{3}+\\frac{M_{2}}{6h_{1}}(x-x_{1})^{3}+\\left(y_{1}-\\frac{M_{1}h_{1}^{2}}{6}\\right)\\frac{x_{2}-x}{h_{1}}+\\left(y_{2}-\\frac{M_{2}h_{1}^{2}}{6}\\right)\\frac{x-x_{1}}{h_{1}}.\n$$\n当 $h_{1}=1$、$M_{1}=3$、$M_{2}=0$、$y_{1}=0$ 且 $y_{2}=1$ 时，上式简化为\n$$\nS(x)=\\frac{3}{6}(1-x)^{3}+0+\\left(0-\\frac{3}{6}\\right)(1-x)+\\left(1-0\\right)x\n=\\frac{1}{2}(1-x)^{3}-\\frac{1}{2}(1-x)+x.\n$$\n展开并合并同类项，\n$$\nS(x)=\\frac{1}{2}-\\frac{3}{2}x+\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}-\\frac{1}{2}+\\frac{1}{2}x+x\n=\\frac{3}{2}x^{2}-\\frac{1}{2}x^{3}.\n$$\n在 $x=\\frac{1}{2}$ 处求值得\n$$\ny_{B}=S\\!\\left(\\frac{1}{2}\\right)=\\frac{3}{2}\\left(\\frac{1}{2}\\right)^{2}-\\frac{1}{2}\\left(\\frac{1}{2}\\right)^{3}\n=\\frac{3}{2}\\cdot\\frac{1}{4}-\\frac{1}{2}\\cdot\\frac{1}{8}\n=\\frac{3}{8}-\\frac{1}{16}\n=\\frac{5}{16}.\n$$\n\n因此，所求的数对为 $\\left(\\frac{1}{2},\\frac{5}{16}\\right)$。", "answer": "$$\\boxed{\\left(\\frac{1}{2}, \\frac{5}{16}\\right)}$$", "id": "2164998"}, {"introduction": "从手动计算转向算法实现，这个练习旨在解决一个基本的数值任务：求根。你将开发一个稳健的算法，以定位分段线性插值函数与零轴相交的所有点。这需要对各种情况进行仔细的逻辑处理，例如区间内的根、数据点上的根，甚至整个根区间，从而搭建起从数学理论到实际编程的桥梁。[@problem_id:2423755]", "problem": "给定一个有限的网格点集 $\\{(x_i,f_i)\\}_{i=0}^n$，其横坐标 $x_0 < x_1 < \\cdots < x_n$ 严格递增，纵坐标 $f_i$ 为实数。对于每个 $i \\in \\{0,\\ldots,n-1\\}$，在闭区间 $[x_i,x_{i+1}]$ 上，通过对连续数据点进行线性插值来定义分段线性插值函数 $\\widehat{f}(x)$。在 $[x_0,x_n]$ 之外，该函数无定义。根集 $\\mathcal{Z}$ 是 $[x_0,x_n]$ 中使得 $\\widehat{f}(x)=0$ 的子集。根集可以包含孤立点，并且如果 $\\widehat{f}(x)$ 在一个非平凡区间上恒等于零，则根集也可以包含闭区间。位于两个线段共享端点处的孤立根必须只计算一次。如果多个零值线段是相邻或重叠的，它们必须合并成一个单一的闭区间。定义域的端点 $x_0$ 和 $x_n$ 必须被包含在内处理。\n\n编写一个程序，对于每个指定的测试用例，返回 $\\mathcal{Z}$ 的完整描述。该描述为一个有序列表，包含：\n- 表示孤立根的实数，以及\n- 表示闭合零值区间（其中对于所有 $x \\in [a,b]$ 都有 $\\widehat{f}(x)=0$）的双元素列表 $[a,b]$（其中 $a < b$）。", "solution": "问题陈述已经过验证，并被确定为有效。它在科学上基于数值分析的原理，特别是分段线性插值。该问题是适定的，所有术语、条件和目标都具有足够的数学精度定义，从而可以得出一个唯一的、可验证的解。因此，我们可以着手推导解决方案。\n\n问题的核心是为分段线性插值函数 $\\widehat{f}(x)$ 找到其根集 $\\mathcal{Z} = \\{x \\in [x_0, x_n] \\mid \\widehat{f}(x) = 0\\}$。函数 $\\widehat{f}(x)$ 定义在一组网格点 $\\{(x_i, f_i)\\}_{i=0}^n$ 上，其中 $x_0 < x_1 < \\cdots < x_n$。\n\n对于任意给定的 $i \\in \\{0, \\ldots, n-1\\}$ 的闭区间 $[x_i, x_{i+1}]$，插值函数 $\\widehat{f}(x)$ 由连接点 $(x_i, f_i)$ 和 $(x_{i+1}, f_{i+1})$ 的线性函数描述。在此线段上 $\\widehat{f}(x)$ 的方程为：\n$$ \\widehat{f}(x) = f_i + (f_{i+1} - f_i) \\frac{x - x_i}{x_{i+1} - x_i}, \\quad x \\in [x_i, x_{i+1}] $$\n为求根，我们必须在整个定义域 $[x_0, x_n]$ 上求解 $\\widehat{f}(x) = 0$。这需要分析每个线段 $[x_i, x_{i+1}]$ 对根集 $\\mathcal{Z}$ 的三种可能的贡献类型：\n\n1.  **内部根：** 当且仅当端点处的函数值符号相反时，在开区间 $(x_i, x_{i+1})$ 内存在一个孤立根。根据介值定理，符号变化（即 $f_i \\cdot f_{i+1} < 0$）保证了根的存在。由于函数在该线段上是线性的，这个根是唯一的。我们对 $x$ 求解 $\\widehat{f}(x) = 0$：\n    $$ x_{\\text{root}} = x_i - f_i \\frac{x_{i+1} - x_i}{f_{i+1} - f_i} $$\n    该公式有效，因为 $f_i \\cdot f_{i+1} < 0$ 意味着 $f_i \\neq f_{i+1}$。\n\n2.  **根区间：** 当且仅当两个端点的函数值都为零（即 $f_i = 0$ 且 $f_{i+1} = 0$）时，函数 $\\widehat{f}(x)$ 在整个闭区间 $[x_i, x_{i+1}]$ 上恒等于零。在这种情况下，整个区间 $[x_i, x_{i+1}]$ 是 $\\mathcal{Z}$ 的一个子集。\n\n3.  **网格点根：** 如果 $f_k = 0$，则网格点 $x_k$ 是一个根。这些点可以是孤立根，也可以是零值区间的端点。\n\n基于此分析，我们构建一个系统性算法来识别并正确格式化根集 $\\mathcal{Z}$ 的所有元素。\n\n**算法：**\n\n1.  **初始化：** 初始化两个数据结构：一个集合 `isolated_roots`，用于存储唯一的孤立根值；一个列表 `zero_intervals`，用于存储 $\\widehat{f}(x)$ 恒等于零的区间 $[a, b]$。\n\n2.  **线段分析：** 遍历从 $0$ 到 $n-1$ 的每个 $i$ 对应的线段 $[x_i, x_{i+1}]$：\n    -   如果 $f_i \\cdot f_{i+1} < 0$，则存在一个内部根。使用上述公式计算其值并将其添加到 `isolated_roots` 集合中。\n    -   如果 $f_i = 0$ 且 $f_{i+1} = 0$，则线段 $[x_i, x_{i+1}]$ 是一个零值区间。将此区间添加到 `zero_intervals` 列表中。\n\n3.  **网格点分析：** 遍历从 $0$ 到 $n$ 的所有 $k$ 对应的网格点 $(x_k, f_k)$。如果 $f_k = 0$，则将值 $x_k$ 添加到 `isolated_roots` 集合中。使用集合可以自动处理共享端点处的根只包含一次的要求。\n\n4.  **区间合并：** `zero_intervals` 列表可能包含相邻或重叠的区间（例如 $[x_i, x_{i+1}]$ 和 $[x_{i+1}, x_{i+2}]$）。这些区间必须合并。\n    -   根据 `zero_intervals` 中区间的起始点对其进行排序。\n    -   遍历排序后的列表，如果任何区间 $[c,d]$ 满足 $c \\le b$，则将其与当前已合并的区间 $[a,b]$ 合并。合并后的区间变为 $[a, \\max(b,d)]$。此过程将产生一个新的不相交闭区间列表 `merged_intervals`。\n\n5.  **根的筛选：** `isolated_roots` 集合可能包含属于 `merged_intervals` 的点（例如端点）。这些点不得单独列出。\n    -   创建一个新列表 `final_isolated_roots`。\n    -   对于 `isolated_roots` 中的每个根 $r$，检查它是否包含在 `merged_intervals` 的任何区间 $[a,b]$ 内（即，是否 $a \\le r \\le b$）。\n    -   如果 $r$ 未包含在任何区间内，则将其添加到 `final_isolated_roots`。\n\n6.  **最终组合：** 完整的根集 $\\mathcal{Z}$ 是 `final_isolated_roots` 和 `merged_intervals` 的并集。\n    -   将这两个集合合并成一个单一列表。\n    -   按递增顺序对最终列表进行排序。为排序目的，区间 $[a,b]$ 按其左端点 $a$ 排序。\n    -   根据输出规范格式化结果列表，将所有数值四舍五入到10位小数。\n\n此过程严谨地构建了完整的根集，满足了问题陈述中给出的所有约束条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([-2.0, -1.0, 0.5, 2.0]), \n            np.array([1.0, -1.0, 2.0, -2.0])\n        ),\n        (\n            np.array([0.0, 1.0, 2.0, 3.0]), \n            np.array([3.0, 0.0, -1.0, 2.0])\n        ),\n        (\n            np.array([0.0, 1.0, 2.0, 3.0]), \n            np.array([1.0, 0.0, 0.0, -1.0])\n        ),\n    ]\n\n    results = []\n    for x_coords, f_values in test_cases:\n        result = find_root_set(x_coords, f_values)\n        results.append(format_case_output(result))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef find_root_set(x, f):\n    \"\"\"\n    Calculates the root set for a given piecewise linear function.\n\n    Args:\n        x (np.ndarray): Array of x-coordinates (abscissae), strictly increasing.\n        f (np.ndarray): Array of function values (ordinates).\n\n    Returns:\n        list: A sorted list of isolated roots (floats) and zero intervals ([a, b]).\n    \"\"\"\n    n = len(x)\n    isolated_roots = set()\n    zero_intervals = []\n\n    # Step 2: Segment Analysis for interior roots and zero intervals\n    for i in range(n - 1):\n        x_i, f_i = x[i], f[i]\n        x_i1, f_i1 = x[i+1], f[i+1]\n\n        if f_i * f_i1  0:\n            # Interior root\n            root = x_i - f_i * (x_i1 - x_i) / (f_i1 - f_i)\n            isolated_roots.add(root)\n        elif f_i == 0 and f_i1 == 0:\n            # Zero interval\n            zero_intervals.append([x_i, x_i1])\n\n    # Step 3: Grid Point Analysis\n    for i in range(n):\n        if f[i] == 0:\n            isolated_roots.add(x[i])\n            \n    # Step 4: Interval Merging\n    if not zero_intervals:\n        merged_intervals = []\n    else:\n        zero_intervals.sort(key=lambda interval: interval[0])\n        merged_intervals = [zero_intervals[0]]\n        for i in range(1, len(zero_intervals)):\n            current_interval = zero_intervals[i]\n            last_merged_interval = merged_intervals[-1]\n            \n            # Check for contiguity or overlap\n            if current_interval[0] = last_merged_interval[1]:\n                last_merged_interval[1] = max(last_merged_interval[1], current_interval[1])\n            else:\n                merged_intervals.append(current_interval)\n\n    # Step 5: Root Filtering\n    final_isolated_roots = []\n    sorted_roots = sorted(list(isolated_roots))\n    \n    for root in sorted_roots:\n        is_covered = False\n        for interval in merged_intervals:\n            # Check if root is within or at the boundary of an interval\n            if interval[0] = root = interval[1]:\n                is_covered = True\n                break\n        if not is_covered:\n            final_isolated_roots.append(root)\n            \n    # Step 6: Final Assembly\n    final_result = final_isolated_roots + merged_intervals\n    \n    # Sort final list: intervals by their start point, points by their value\n    final_result.sort(key=lambda item: item if isinstance(item, (int, float)) else item[0])\n    \n    return final_result\n\ndef format_case_output(result_list):\n    \"\"\"\n    Formats the result of a single case into the required string representation.\n    \"\"\"\n    formatted_items = []\n    for item in result_list:\n        if isinstance(item, list):\n            # It's an interval [a, b]\n            formatted_items.append(f\"[{item[0]:.10f},{item[1]:.10f}]\")\n        else:\n            # It's an isolated root (float)\n            formatted_items.append(f\"{item:.10f}\")\n    return f\"[{','.join(formatted_items)}]\"\n\nsolve()\n```", "id": "2423755"}, {"introduction": "最后的这个练习将探索计算工程中最强大的概念之一：自适应方法。你将设计一个能够智能加密插值网格的算法，只在最需要的地方——即曲率高的区域——增加更多的点。这个练习展示了如何构建高效的数值工具，通过优化计算资源来达到预期的精度要求，这是现代仿真软件的核心原则。[@problem_id:2423835]", "problem": "给定一个闭区间上的一族标量函数，请您构建一个用于分段线性插值的自适应网格生成器，该生成器应在二阶导数幅值（记为 $\\lvert f^{\\prime\\prime}(x) \\rvert$）的可计算估计值较大的地方进行加密。您必须从基本定义和经过充分检验的事实出发，并实现一个可在固定测试套件上进行验证的完全确定性算法。三角函数中使用的所有角度均以弧度为单位。此问题不涉及任何物理单位。\n\n您的程序必须实现以下要求。\n\n- 输入与初始化：\n  - 一个函数 $f:[a,b]\\to\\mathbb{R}$，一个区间 $[a,b]$（其中 $a  b$），一个初始节点数 $m_0 \\ge 3$，一个误差容差 $\\mathrm{tol}  0$，以及一个最大节点数 $N_{\\max}$。\n  - 算法从一个在 $[a,b]$ 上具有 $m_0$ 个节点的初始均匀网格开始。\n\n- 误差指标与加密：\n  - 对于每个区间 $[x_i, x_{i+1}]$，误差指标定义为 $e_i = s_i (x_{i+1} - x_i)^2$，其中 $s_i$ 是对该区间上或其附近的 $\\lvert f^{\\prime\\prime}(x) \\rvert$ 的估计。\n  - 对于网格中的每个内部节点 $x_k$ ($k \\in \\{1, \\dots, n-2\\}$)，二阶导数 $f^{\\prime\\prime}(x_k)$ 通过一个穿过 $(x_{k-1}, f(x_{k-1}))$、$(x_k, f(x_k))$ 和 $(x_{k+1}, f(x_{k+1}))$ 的二次多项式的二阶导数 $D2_k$ 来近似。\n  - 对于区间 $[x_i, x_{i+1}]$，$s_i$ 的定义如下：$s_i = \\lvert D2_1 \\rvert$（对于第一个区间），$s_i = \\max(\\lvert D2_i \\rvert, \\lvert D2_{i+1} \\rvert)$（对于内部区间），以及 $s_i = \\lvert D2_{n-2} \\rvert$（对于最后一个区间）。\n  - 在每次迭代中，找到具有最大误差指标 $e_{i^{\\star}}$ 的区间。如果多个区间并列，则选择索引最小的那个。通过在其中心点插入一个新节点来加密该区间。\n\n- 终止与评估：\n  - 当最大误差指标 $\\max_i e_i \\le \\mathrm{tol}$ 或网格中的节点总数达到 $N_{\\max}$ 时，算法终止。\n  - 最后，通过在 $[a,b]$ 上的 $10001$ 个均匀测试点上采样，计算最终分段线性插值函数 $L(x)$ 与真实函数 $f(x)$ 之间的最大绝对差 $E = \\lVert f - L \\rVert_{\\infty}$。\n  - 对于每个测试用例，返回包含最终节点数 $n$ 和估计误差 $E$ 的列表 $[n, E]$。", "solution": "该问题陈述经过了严格验证，被认为是科学上可靠、适定、客观和完整的。它描述了一种用于分段线性插值的标准自适应网格加密算法。该问题是有效的。下面提供了一个完整的解决方案。\n\n自适应网格生成背后的基本原理是有效地分布有限数量的网格点，在待插值函数变化剧烈的区域密集放置网格点，在函数平滑的区域稀疏放置网格点。对于分段线性插值，区间 $[x_i, x_{i+1}]$ 上的插值误差由函数二阶导数的幅值 $\\lvert f^{\\prime\\prime}(x)\\rvert$ 和区间长度 $h_i = x_{i+1} - x_i$ 控制。标准误差界由以下公式给出：\n$$ \\max_{x \\in [x_i, x_{i+1}]} \\lvert f(x) - L(x) \\rvert \\le \\frac{h_i^2}{8} \\max_{z \\in [x_i, x_{i+1}]} \\lvert f^{\\prime\\prime}(z) \\rvert $$\n其中 $L(x)$ 是该区间上的线性插值函数。这启发我们为每个区间 $I_i = [x_i, x_{i+1}]$ 设计一个形式为 $e_i = s_i h_i^2$ 的误差指标，其中 $s_i$ 是对该区间上或其附近二阶导数幅值的估计。\n\n算法流程如下：\n1.  在区间 $[a, b]$ 上初始化一个包含 $m_0$ 个点的粗略均匀网格。\n2.  基于局部误差指标迭代地加密网格。在每一步中，将具有最大误差指标的区间二等分。\n3.  当最大误差指标低于指定的容差 $\\mathrm{tol}$，或网格点总数达到最大限制 $N_{\\max}$ 时，过程终止。\n\n算法的核心是计算误差指标 $e_i$。这需要对二阶导数进行数值估计，因为我们不假设 $f^{\\prime\\prime}(x)$ 的解析形式是可用的。问题指定了一种基于局部二次插值的方法。\n\n对于每一组连续的节点 $(x_{k-1}, y_{k-1})$、$(x_k, y_k)$、$(x_{k+1}, y_{k+1})$，我们构造一个唯一穿过这些点的二次多项式 $P_k(x)$。该多项式的二阶导数 $P_k^{\\prime\\prime}(x)$ 是一个常数，并作为 $f^{\\prime\\prime}(x_k)$ 的近似值。该近似值记为 $D2_k$。\n$D2_k$ 的公式可以从牛顿形式的插值多项式推导出来。二阶差商由下式给出：\n$$ f[x_{k-1}, x_k, x_{k+1}] = \\frac{f[x_k, x_{k+1}] - f[x_{k-1}, x_k]}{x_{k+1} - x_{k-1}} $$\n其中 $f[x_i, x_j] = (y_j - y_i) / (x_j - x_i)$。插值二次多项式的二阶导数为 $P_k^{\\prime\\prime}(x) = 2 f[x_{k-1}, x_k, x_{k+1}]$。令 $h_{k-1} = x_k - x_{k-1}$ 且 $h_k = x_{k+1} - x_k$。$D2_k$ 的公式变为：\n$$ D2_k = 2 \\frac{ \\frac{y_{k+1} - y_k}{h_k} - \\frac{y_k - y_{k-1}}{h_{k-1}} }{ x_{k+1} - x_{k-1} } = \\frac{2}{h_k + h_{k-1}} \\left( \\frac{y_{k+1} - y_k}{h_k} - \\frac{y_k - y_{k-1}}{h_{k-1}} \\right) $$\n对于一个有 $n$ 个点的网格，该公式对每个内部网格点 $x_k$ (其中 $k \\in \\{1, 2, \\dots, n-2\\}$) 都有定义。\n\n计算出 $D2_k$ 的值后，问题为每个区间 $I_i=[x_i,x_{i+1}]$ 定义了一个标量曲率指标 $s_i$。该指标汇总了区间端点处（或对于边界区间，是最近的内部点）的二阶导数信息。对于一个有 $n$ 个节点（$n-1$ 个区间）的网格，定义如下：\n-   对于第一个区间 $I_0$：$s_0 = \\lvert D2_1 \\rvert$\n-   对于内部区间 $I_i$，$i \\in \\{1, \\dots, n-3\\}$：$s_i = \\max\\{\\lvert D2_i \\rvert, \\lvert D2_{i+1} \\rvert\\}$\n-   对于最后一个区间 $I_{n-2}$：$s_{n-2} = \\lvert D2_{n-2} \\rvert$\n\n于是，区间误差指标为 $e_i = s_i h_i^2$。\n\n加密策略是一种贪婪算法。在每次迭代中，我们识别出具有最大误差指标 $e_{i^{\\star}} = \\max_j e_j$ 的区间 $I_{i^{\\star}}$。如果多个区间共享此最大值，则选择索引最小的 $i^{\\star}$。通过将该区间的中点 $m = (x_{i^{\\star}} + x_{i^{\\star}+1})/2$ 作为新节点插入，来二等分此区间。计算函数值 $f(m)$，并更新网格数据数组。\n\n此迭代过程持续进行，直到满足停止准则：$\\max_i e_i \\le \\mathrm{tol}$ 或节点数 $n = N_{\\max}$。\n\n最后，为评估所得网格的质量，近似计算插值误差的上确界范数 $\\lVert f-L \\rVert_{\\infty}$。这是通过在大量均匀分布于 $[a,b]$ 上的测试点 $\\{x^{\\mathrm{test}}_j\\}_{j=0}^{10000}$ 上对真实函数 $f(x)$ 和最终的分段线性插值函数 $L(x)$ 进行采样来完成的。将最大绝对差计算为误差估计 $E$：\n$$ E = \\max_{0 \\le j \\le 10000} \\lvert f(x^{\\mathrm{test}}_j) - L(x^{\\mathrm{test}}_j) \\rvert $$\n每个测试用例的最终输出由最终节点数 $n$ 和这个估计误差 $E$ 组成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_adaptive_interpolation(f, a, b, m0, tol, N_max):\n    \"\"\"\n    Constructs an adaptive grid for piecewise linear interpolation.\n\n    Args:\n        f (callable): The function to interpolate, f(x).\n        a (float): The start of the interval.\n        b (float): The end of the interval.\n        m0 (int): The initial number of grid points.\n        tol (float): The error tolerance for stopping.\n        N_max (int): The maximum number of grid points.\n\n    Returns:\n        list: A list containing the final number of nodes and the maximum error, [n, E].\n    \"\"\"\n    # 1. Initialization\n    # Using lists for efficient insertion of new nodes\n    x_nodes = np.linspace(a, b, m0).tolist()\n    y_nodes = [f(x) for x in x_nodes]\n\n    # 2. Refinement Loop\n    while len(x_nodes)  N_max:\n        n = len(x_nodes)\n        \n        # Guard against grids too small to compute second derivatives\n        if n  3:\n            break\n\n        # Compute D2_k values for all interior nodes\n        D2_values = []\n        for k in range(1, n - 1):\n            x_km1, x_k, x_kp1 = x_nodes[k-1], x_nodes[k], x_nodes[k+1]\n            y_km1, y_k, y_kp1 = y_nodes[k-1], y_nodes[k], y_nodes[k+1]\n            \n            h_km1 = x_k - x_km1\n            h_k = x_kp1 - x_k\n            \n            # This should not happen with a strictly increasing grid\n            if h_km1 = 0 or h_k = 0 or (h_k + h_km1) == 0:\n                D2_k = 0.0\n            else:\n                term1 = (y_kp1 - y_k) / h_k\n                term2 = (y_k - y_km1) / h_km1\n                D2_k = 2.0 * (term1 - term2) / (h_k + h_km1)\n            D2_values.append(D2_k)\n\n        # Compute error indicators e_i for each interval\n        errors = []\n        num_intervals = n - 1\n        for i in range(num_intervals):\n            h_i = x_nodes[i+1] - x_nodes[i]\n            \n            # Compute curvature indicator s_i\n            if num_intervals == 1: # Only two points, D2 cannot be computed.\n                # This case is avoided by m0=3, so n-2 = 1, D2_values is non-empty.\n                # If n=3, num_intervals=2. Then D2_values has 1 element.\n                s_i = abs(D2_values[0])\n            elif i == 0: # First interval\n                s_i = abs(D2_values[0]) # |D2_1|\n            elif i == num_intervals - 1: # Last interval\n                s_i = abs(D2_values[-1]) # |D2_{n-2}|\n            else: # Interior intervals\n                # s_i = max(|D2_i|, |D2_{i+1}|)\n                # D2_values[k-1] corresponds to D2_k\n                s_i = max(abs(D2_values[i-1]), abs(D2_values[i]))\n            \n            e_i = s_i * h_i**2\n            errors.append(e_i)\n        \n        # Check stopping criterion\n        max_error_indicator = max(errors)\n        if max_error_indicator = tol:\n            break\n\n        # Refine grid: find smallest index i_star with max error and insert midpoint\n        i_star = errors.index(max_error_indicator)\n        \n        m = (x_nodes[i_star] + x_nodes[i_star+1]) / 2.0\n        fm = f(m)\n        \n        x_nodes.insert(i_star + 1, m)\n        y_nodes.insert(i_star + 1, fm)\n\n    # 3. Final Quality Assessment\n    n_final = len(x_nodes)\n    x_test = np.linspace(a, b, 10001)\n    y_true = np.array([f(x) for x in x_test])\n    \n    x_nodes_np = np.array(x_nodes)\n    y_nodes_np = np.array(y_nodes)\n    y_interp = np.interp(x_test, x_nodes_np, y_nodes_np)\n    \n    E = np.max(np.abs(y_true - y_interp))\n    \n    return [n_final, E]\n    \n\ndef solve():\n    \"\"\"\n    Runs the adaptive interpolation algorithm on a predefined test suite.\n    \"\"\"\n    # Define test functions\n    f1 = lambda x: np.sin(6 * x)\n    f2 = lambda x: 2 * x + 3\n    f3 = lambda x: np.arctan(50 * (x - 0.5))\n    f4 = lambda x: np.exp(x)\n    f5 = lambda x: np.sin(x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, 1.0, 5, 0.02, 200),\n        (f2, 0.0, 1.0, 3, 1e-6, 50),\n        (f3, 0.0, 1.0, 5, 0.005, 200),\n        (f4, 0.0, 5.0, 5, 0.5, 300),\n        (f5, 0.0, 0.01, 3, 1e-4, 50)\n    ]\n\n    results = []\n    for case in test_cases:\n        # Unpack case parameters and call the solver\n        f, a, b, m0, tol, N_max = case\n        result = run_adaptive_interpolation(f, a, b, m0, tol, N_max)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'[{n},{E}]' for n, E in results])}]\")\n\nsolve()\n\n```", "id": "2423835"}]}