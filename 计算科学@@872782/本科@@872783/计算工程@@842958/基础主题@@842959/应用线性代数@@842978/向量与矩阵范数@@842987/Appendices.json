{"hands_on_practices": [{"introduction": "这个练习旨在揭示不同矩阵范数的物理和几何意义。我们将以一个在计算工程中广泛用于引入零元素的吉文斯旋转矩阵为例。通过计算其多种范数，你将亲身体会到，即使是对于同一个矩阵，不同的范数也会从不同角度衡量其“大小”，从而揭示矩阵变换的不同特性。", "problem": "在计算工程的数值线性代数中，Givens 旋转用于在矩阵中引入零元素，同时保持欧几里得长度。设 $n \\ge 2$ 为一个整数，考虑一个 $n \\times n$ 的 Givens 旋转矩阵 $G$，它作用于坐标索引 $p$ 和 $q$（其中 $1 \\le p  q \\le n$），通过将行和列 $\\{p,q\\}$ 上的 $2 \\times 2$ 主子矩阵替换为\n$$\n\\begin{pmatrix}\n\\cos\\theta  \\sin\\theta \\\\\n-\\sin\\theta  \\cos\\theta\n\\end{pmatrix},\n$$\n并保持所有其他对角线元素为 $1$，所有其他非对角线元素为 $0$。仅使用诱导矩阵范数和 Frobenius 范数的定义，确定矩阵的 $1$-范数 $\\|G\\|_{1}$、 $2$-范数 $\\|G\\|_{2}$、 $\\infty$-范数 $\\|G\\|_{\\infty}$ 和 Frobenius 范数 $\\|G\\|_{F}$ 的精确表达式，这些表达式是关于 $n$ 和 $\\theta$ 的函数。请以精确的解析表达式形式给出你的最终答案。无需四舍五入。最后，简要解释你的结果，说明其在长度保持性和范数依赖性方面的意义。", "solution": "首先对问题陈述进行验证。\n\n**步骤 1：提取问题要素**\n- $n$ 是整数，$n \\ge 2$。\n- $G$ 是一个 $n \\times n$ 的 Givens 旋转矩阵。\n- 该矩阵作用于坐标索引 $p$ 和 $q$，其中 $1 \\le p  q \\le n$。\n- 在行和列 $\\{p,q\\}$ 上的 $2 \\times 2$ 主子矩阵是 $\\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}$。\n- 所有其他对角线元素为 $1$。\n- 所有其他非对角线元素为 $0$。\n- 任务是仅使用范数的定义来确定 $\\|G\\|_{1}$、$\\|G\\|_{2}$、$\\|G\\|_{\\infty}$ 和 $\\|G\\|_{F}$ 的精确表达式。\n- 需要对结果进行解释。\n\n**步骤 2：使用提取的要素进行验证**\n- **科学性：** 该问题基于数值线性代数中的标准、定义明确的概念，特别是 Givens 旋转和矩阵范数。这些是计算工程中的基本工具。\n- **适定性：** 对于任何有效的 $n, p, q, \\theta$，矩阵 $G$ 的定义都是明确无歧义的。矩阵范数是标准的数学函数，对于任何给定的矩阵都有唯一的输出。该问题是适定的。\n- **客观性：** 问题使用精确的数学语言陈述，没有主观性或歧义。\n\n**步骤 3：结论与行动**\n该问题具有科学性、适定性、客观性和完整性。因此，它被判定为**有效**。我们可以继续进行求解。\n\nGivens 旋转矩阵 $G$ 是一个 $n \\times n$ 矩阵，它与单位矩阵 $I_n$ 相同，只有四个元素不同。 $G$ 的元素（记作 $g_{ij}$）为：\n$g_{pp} = \\cos\\theta$\n$g_{qq} = \\cos\\theta$\n$g_{pq} = \\sin\\theta$\n$g_{qp} = -\\sin\\theta$\n$g_{ii} = 1$ 对于 $i \\in \\{1, \\dots, n\\} \\setminus \\{p, q\\}$\n$g_{ij} = 0$ 对于所有其他 $i \\ne j$ 的下标对 $(i, j)$。\n\n我们现在将根据它们的基本定义来计算所需的范数。\n\n**1. 矩阵 $1$-范数 ($\\|G\\|_{1}$)**\n矩阵 $1$-范数，或称列和范数，定义为最大绝对列和：\n$$ \\|G\\|_{1} = \\max_{1 \\le j \\le n} \\sum_{i=1}^{n} |g_{ij}| $$\n我们考察 $G$ 的各列：\n- 对于任何满足 $j \\ne p$ 且 $j \\ne q$ 的列 $j$，唯一的非零元素是 $g_{jj} = 1$。该列的绝对值之和为 $|1| = 1$。\n- 对于第 $p$ 列，非零元素是 $g_{pp} = \\cos\\theta$ 和 $g_{qp} = -\\sin\\theta$。其和为 $|g_{pp}| + |g_{qp}| = |\\cos\\theta| + |-\\sin\\theta| = |\\cos\\theta| + |\\sin\\theta|$。\n- 对于第 $q$ 列，非零元素是 $g_{pq} = \\sin\\theta$ 和 $g_{qq} = \\cos\\theta$。其和为 $|g_{pq}| + |g_{qq}| = |\\sin\\theta| + |\\cos\\theta|$。\n\n$1$-范数是这些和的最大值：\n$$ \\|G\\|_{1} = \\max(1, |\\cos\\theta| + |\\sin\\theta|) $$\n我们知道对于任意实数 $\\theta$，都有 $|\\cos\\theta| + |\\sin\\theta| \\ge \\sqrt{\\cos^2\\theta + \\sin^2\\theta} = 1$。当 $\\theta$ 是 $\\frac{\\pi}{2}$ 的整数倍时，等号成立。因此，最大值总是 $|\\cos\\theta| + |\\sin\\theta|$。\n$$ \\|G\\|_{1} = |\\cos\\theta| + |\\sin\\theta| $$\n\n**2. 矩阵 $\\infty$-范数 ($\\|G\\|_{\\infty}$)**\n矩阵 $\\infty$-范数，或称行和范数，定义为最大绝对行和：\n$$ \\|G\\|_{\\infty} = \\max_{1 \\le i \\le n} \\sum_{j=1}^{n} |g_{ij}| $$\n我们考察 $G$ 的各行：\n- 对于任何满足 $i \\ne p$ 且 $i \\ne q$ 的行 $i$，唯一的非零元素是 $g_{ii} = 1$。该行的绝对值之和为 $|1| = 1$。\n- 对于第 $p$ 行，非零元素是 $g_{pp} = \\cos\\theta$ 和 $g_{pq} = \\sin\\theta$。其和为 $|g_{pp}| + |g_{pq}| = |\\cos\\theta| + |\\sin\\theta|$。\n- 对于第 $q$ 行，非零元素是 $g_{qp} = -\\sin\\theta$ 和 $g_{qq} = \\cos\\theta$。其和为 $|g_{qp}| + |g_{qq}| = |-\\sin\\theta| + |\\cos\\theta| = |\\sin\\theta| + |\\cos\\theta|$。\n\n根据与 $1$-范数相同的逻辑，这些和的最大值是：\n$$ \\|G\\|_{\\infty} = |\\cos\\theta| + |\\sin\\theta| $$\n\n**3. 矩阵 $2$-范数 ($\\|G\\|_{2}$)**\n矩阵 $2$-范数，或称谱范数，定义为矩阵 $G^T G$ 的最大特征值的平方根：\n$$ \\|G\\|_{2} = \\sqrt{\\lambda_{\\max}(G^T G)} $$\n矩阵 $G$ 是一个正交矩阵。我们通过计算 $G^T G$ 来验证这一点。转置矩阵 $G^T$ 与 $G$ 相同，只是 $g_{pq}$ 和 $g_{qp}$ 的角色互换了。因此，$g_{pq}^T = g_{qp} = -\\sin\\theta$ 且 $g_{qp}^T = g_{pq} = \\sin\\theta$。\n乘积 $G^T G$ 将是单位矩阵。要理解这一点，可以考虑子矩阵的作用。$G$ 的 $2 \\times 2$ 子矩阵是 $R(\\theta) = \\begin{pmatrix} \\cos\\theta  \\sin\\theta \\\\ -\\sin\\theta  \\cos\\theta \\end{pmatrix}$。其转置是 $R(\\theta)^T = \\begin{pmatrix} \\cos\\theta  -\\sin\\theta \\\\ \\sin\\theta  \\cos\\theta \\end{pmatrix}$。\n乘积为：\n$$ R(\\theta)^T R(\\theta) = \\begin{pmatrix} \\cos^2\\theta + \\sin^2\\theta  \\cos\\theta\\sin\\theta - \\sin\\theta\\cos\\theta \\\\ \\sin\\theta\\cos\\theta - \\cos\\theta\\sin\\theta  \\sin^2\\theta + \\cos^2\\theta \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} $$\n由于 $G$ 的所有其他行和列都是标准基向量，完整的矩阵乘积 $G^T G$ 的结果是 $n \\times n$ 的单位矩阵 $I_n$。\n$I_n$ 的特征值全部等于 $1$。因此，$\\lambda_{\\max}(G^T G) = 1$。\n因此，$2$-范数为：\n$$ \\|G\\|_{2} = \\sqrt{1} = 1 $$\n\n**4. Frobenius 范数 ($\\|G\\|_{F}$)**\nFrobenius 范数定义为所有元素模的平方和的平方根：\n$$ \\|G\\|_{F} = \\sqrt{\\sum_{i=1}^{n} \\sum_{j=1}^{n} |g_{ij}|^2} $$\n我们对 $G$ 的所有非零元素的平方求和：\n- 有 $(n-2)$ 个元素等于 $1$（即除了 $p$ 和 $q$ 之外的索引对应的对角线元素）。它们对平方和的贡献是 $(n-2) \\times 1^2 = n-2$。\n- $\\{p,q\\}$ 子块中的四个元素是 $\\cos\\theta$、$\\sin\\theta$、$-\\sin\\theta$ 和 $\\cos\\theta$。它们对平方和的贡献是 $(\\cos\\theta)^2 + (\\sin\\theta)^2 + (-\\sin\\theta)^2 + (\\cos\\theta)^2 = 2\\cos^2\\theta + 2\\sin^2\\theta = 2(\\cos^2\\theta + \\sin^2\\theta) = 2$。\n\n平方和的总和为 $(n-2) + 2 = n$。\n因此，Frobenius 范数为：\n$$ \\|G\\|_{F} = \\sqrt{n} $$\n\n**结果解释**\n问题要求从长度保持性和范数依赖性的角度进行解释。\n- **长度保持性：** 结果 $\\|G\\|_{2} = 1$ 是 Givens 旋转在欧几里得空间中是等距变换这一几何性质的数学表述。矩阵的 $2$-范数衡量了它能将一个向量的欧几里得长度（$\\|x\\|_2$）拉伸的最大因子。值为 $1$ 意味着没有向量的长度被改变，即对于所有 $x \\in \\mathbb{R}^n$ 都有 $\\|Gx\\|_{2} = \\|x\\|_{2}$。这正是“保持欧几里得长度”的确切含义。\n- **范数依赖性：** 结果表明，矩阵 $G$ 的“大小”取决于所选择的范数。虽然在欧几里得意义上（$\\|G\\|_2=1$）它是一个大小为 $1$ 的纯旋转，但其 $1$-范数和 $\\infty$-范数，$\\|G\\|_{1} = \\|G\\|_{\\infty} = |\\cos\\theta| + |\\sin\\theta|$，依赖于旋转角 $\\theta$，并且最大可达 $\\sqrt{2}$。这表明，对于欧几里得范数而言是纯旋转的变换，在用其他范数（例如 $1$-范数或 $\\infty$-范数）衡量时，可能起到放大向量的作用。Frobenius 范数 $\\|G\\|_{F}=\\sqrt{n}$ 只依赖于空间的维度 $n$，而与角度 $\\theta$ 无关。这是因为旋转仅仅是在活动子块内重新分配了矩阵元素的模的平方值，使其总和保持不变，而该范数计算了所有元素，包括对角线上 $n-2$ 个不变的单位元素。不同范数得出不同结果，这突显了对于线性变换的“大小”并不存在单一、普适的度量；该度量依赖于所使用的度规。", "answer": "$$ \\boxed{\\begin{pmatrix} |\\cos\\theta| + |\\sin\\theta|  1  |\\cos\\theta| + |\\sin\\theta|  \\sqrt{n} \\end{pmatrix}} $$", "id": "2449542"}, {"introduction": "在理论上，有限维空间中的所有范数都是等价的，但这种等价性可能隐藏着一个在计算中至关重要的陷阱。这个练习将引导你构造一个矩阵序列，以探索范数等价常数与维度的依赖关系[@problem_id:2449576]。通过这个看似抽象的练习，你将理解为什么在高维问题中（例如，在有限元分析或大规模数据处理中），选择哪种范数来评估误差或收敛性可能产生截然不同的结论。", "problem": "在计算工程中，性能与稳定性分析通常会比较不同范数，这些范数定义在维度随离散化参数增长的空间上。对于每个正整数 $n \\in \\mathbb{N}$，考虑矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$，其元素定义为：当 $j = 1$ 时 $[A_n]_{i j} = 1$，当 $j \\neq 1$ 时 $[A_n]_{i j} = 0$。设矩阵 $A$ 的诱导1-范数定义为 $\\|A\\|_1 = \\max_{x \\in \\mathbb{R}^n \\setminus \\{0\\}} \\frac{\\|A x\\|_1}{\\|x\\|_1}$，其中向量1-范数为 $\\|x\\|_1 = \\sum_{i=1}^{n} |x_i|$。设弗罗贝尼乌斯范数定义为 $\\|A\\|_F = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A]_{i j})^2}$。\n\n计算比值 $r(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}$，结果表示为 $n$ 的一个闭式函数。请以关于 $n$ 的单个解析表达式的形式给出最终答案。无需进行四舍五入。", "solution": "所述问题是有效的。这是一个计算工程领域内适定的数学练习，没有任何科学、逻辑或事实上的缺陷。所有术语都是标准的，并且定义精确。下面我们进行求解。\n\n该问题要求计算特定矩阵族 $A_n \\in \\mathbb{R}^{n \\times n}$ 的比值 $r(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}$。对于每个正整数 $n$，矩阵 $A_n$ 的元素定义如下：\n$$\n[A_n]_{i j} = \\begin{cases} 1  \\text{if } j = 1 \\\\ 0  \\text{if } j \\neq 1 \\end{cases}\n$$\n这意味着对于任意给定的 $n$，矩阵 $A_n$ 的第一列元素全为1，而其他所有列的元素均为0。\n$$\nA_n = \\begin{pmatrix}\n1  0  \\dots  0 \\\\\n1  0  \\dots  0 \\\\\n\\vdots  \\vdots  \\ddots  \\vdots \\\\\n1  0  \\dots  0\n\\end{pmatrix}\n$$\n\n首先，我们计算诱导1-范数 $\\|A_n\\|_1$。问题中给出的定义是 $\\|A\\|_1 = \\max_{x \\neq 0} \\frac{\\|Ax\\|_1}{\\|x\\|_1}$。线性代数中有一个标准结论，即矩阵的诱导1-范数等于其最大绝对列和。也就是说，对于任意矩阵 $A \\in \\mathbb{R}^{m \\times n}$：\n$$\n\\|A\\|_1 = \\max_{1 \\le j \\le n} \\sum_{i=1}^{m} |[A]_{ij}|\n$$\n我们将此公式应用于我们的矩阵 $A_n \\in \\mathbb{R}^{n \\times n}$。我们必须计算每一列元素的绝对值之和，并找出这些和中的最大值。\n\n对于第一列（$j=1$）：\n$$\n\\sum_{i=1}^{n} |[A_n]_{i1}| = \\sum_{i=1}^{n} |1| = \\sum_{i=1}^{n} 1 = n\n$$\n对于任何其他列（$j  1$）：\n$$\n\\sum_{i=1}^{n} |[A_n]_{ij}| = \\sum_{i=1}^{n} |0| = 0\n$$\n列和的集合是 $\\{n, 0, 0, \\ldots, 0\\}$。这个集合的最大值显然是 $n$。\n因此，$A_n$ 的诱导1-范数是：\n$$\n\\|A_n\\|_1 = n\n$$\n\n接下来，我们计算弗罗贝尼乌斯范数 $\\|A_n\\|_F$。给出的定义是：\n$$\n\\|A\\|_F = \\sqrt{\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A]_{i j})^2}\n$$\n我们将此定义应用于我们的矩阵 $A_n$。$A_n$ 的非零元素为 $[A_n]_{i1} = 1$（对于 $i=1, \\ldots, n$）。所有其他元素均为0。\n所有元素的平方和为：\n$$\n\\sum_{i=1}^{n}\\sum_{j=1}^{n} ([A_n]_{i j})^2 = \\sum_{i=1}^{n} ([A_n]_{i 1})^2 + \\sum_{i=1}^{n} \\sum_{j=2}^{n} ([A_n]_{i j})^2\n$$\n代入元素的值：\n$$\n\\sum_{i=1}^{n} (1)^2 + \\sum_{i=1}^{n} \\sum_{j=2}^{n} (0)^2 = \\sum_{i=1}^{n} 1 + 0 = n\n$$\n弗罗贝尼乌斯范数是这个和的平方根。\n$$\n\\|A_n\\|_F = \\sqrt{n}\n$$\n\n最后，我们计算所求的比值 $r(n)$。\n$$\nr(n) = \\frac{\\|A_n\\|_1}{\\|A_n\\|_F}\n$$\n代入我们为范数找到的表达式：\n$$\nr(n) = \\frac{n}{\\sqrt{n}}\n$$\n由于 $n$ 是正整数，因此 $n \\ge 1$，我们可以简化此表达式。\n$$\nr(n) = \\frac{(\\sqrt{n})^2}{\\sqrt{n}} = \\sqrt{n}\n$$\n该比值作为 $n$ 的函数是 $\\sqrt{n}$。", "answer": "$$\n\\boxed{\\sqrt{n}}\n$$", "id": "2449576"}, {"introduction": "矩阵范数最关键的应用之一是分析数值算法的稳定性和精度。这个动手编程练习将让你直面计算线性代数中的一个核心问题：病态系统[@problem_id:2449583]。你将设计一个实验，用范数来精确度量输入数据的微小扰动如何被一个“病态”矩阵放大，从而导致解产生巨大误差，深刻理解矩阵条件数的实际意义。", "problem": "设计并实现一个完整的、可运行的程序，该程序执行一项数值实验，以证明对于一个病态矩阵 $A$，线性系统 $A x = b$ 中 $b$ 的一个微小相对误差可能导致解 $x$ 的一个巨大相对误差。该实验必须严格基于基本原理：范数、相对误差和线性求解的定义。所有量都必须使用向量和矩阵的2-范数。对于每个指定的测试用例，程序必须计算定义如下的放大因子\n$$\nr \\;=\\; \\frac{\\|x_{\\epsilon} - x^\\star\\|_{2} / \\|x^\\star\\|_{2}}{\\|\\delta b\\|_{2} / \\|b\\|_{2}},\n$$\n其中 $x^\\star$ 是对应于未受扰动的右端项 $b$ 的精确解，$\\delta b$ 是 $b$ 的一个扰动，而 $x_{\\epsilon}$ 是 $A x = b + \\delta b$ 的解。对于每个测试用例，程序必须使用以下实验设置：\n- 令 $x^\\star$ 为 $\\mathbb{R}^n$ 中所有分量都等于 $1$ 的向量。\n- 令 $b = A x^\\star$。\n- 令扰动方向 $v \\in \\mathbb{R}^n$ 按分量定义为 $v_i = \\frac{(-1)^{i-1}}{\\sqrt{n}}$（对于 $i = 1, \\dots, n$），因此 $\\|v\\|_2 = 1$。\n- 令 $\\delta b = \\epsilon \\, \\|b\\|_2 \\, v$，其中 $\\epsilon$ 是为该测试规定的相对扰动幅度。\n- 令 $x_{\\epsilon}$ 为 $A x = b + \\delta b$ 的解。\n\n您的程序必须为每个测试用例计算放大因子 $r$（作为浮点数）。测试用例集如下，每个用例由其用例编号标识，并按所列顺序执行：\n- 用例1：$A$ 是 Hilbert 矩阵 $H \\in \\mathbb{R}^{5 \\times 5}$，其元素为 $H_{ij} = \\frac{1}{i + j - 1}$（对于 $i, j \\in \\{1,\\dots,5\\}$），且 $\\epsilon = 10^{-8}$。\n- 用例2：$A$ 是 Hilbert 矩阵 $H \\in \\mathbb{R}^{10 \\times 10}$，其元素为 $H_{ij} = \\frac{1}{i + j - 1}$（对于 $i, j \\in \\{1,\\dots,10\\}$），且 $\\epsilon = 10^{-8}$。\n- 用例3：$A$ 是单位矩阵 $I \\in \\mathbb{R}^{8 \\times 8}$，且 $\\epsilon = 10^{-8}$。\n- 用例4：$A \\in \\mathbb{R}^{2 \\times 2}$ 由下式给出\n$$\nA = \\begin{bmatrix}\n1  1 \\\\\n1  1 + 10^{-10}\n\\end{bmatrix},\n$$\n且 $\\epsilon = 10^{-12}$。\n\n所有范数必须是2-范数。不涉及物理单位。不使用角度。不得使用百分比；所有比率和幅度必须表示为十进制浮点数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[r1,r2,r3,r4]”）。每个条目必须是相应案例的放大因子 $r$，四舍五入到 $6$ 位有效数字，并按用例 $1$ 到 $4$ 的顺序排列。", "solution": "该实验是根据线性代数和基于范数的误差分析的基本原理设计的。我们考虑一个具有精确数据的线性系统 $A x = b$ 及其受扰动的对应系统 $A x = b + \\delta b$。对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 和精确解向量 $x^\\star \\in \\mathbb{R}^n$，我们定义 $b = A x^\\star$。然后我们如下构造一个具有规定相对幅度 $\\epsilon$ 的扰动 $\\delta b$。令 $v \\in \\mathbb{R}^n$，其元素为 $v_i = \\frac{(-1)^{i-1}}{\\sqrt{n}}$（对于 $i = 1, \\dots, n$）。根据构造，此 $v$ 满足 $\\|v\\|_2 = 1$：\n$$\n\\|v\\|_2^2 = \\sum_{i=1}^n \\left(\\frac{1}{\\sqrt{n}}\\right)^2 = \\frac{n}{n} = 1.\n$$\n我们设置 $\\delta b = \\epsilon \\, \\|b\\|_2 \\, v$。那么 $b$ 中的相对扰动恰好为 $\\frac{\\|\\delta b\\|_2}{\\|b\\|_2} = \\epsilon$，因为\n$$\n\\|\\delta b\\|_2 = \\epsilon \\, \\|b\\|_2 \\, \\|v\\|_2 = \\epsilon \\, \\|b\\|_2.\n$$\n令 $x_\\epsilon$ 表示受扰动系统 $A x = b + \\delta b$ 的解。解中的误差等于\n$$\nx_\\epsilon - x^\\star = A^{-1}\\,(b+\\delta b) - A^{-1} b = A^{-1}\\,\\delta b.\n$$\n因此 $x$ 中的相对误差为\n$$\n\\frac{\\|x_\\epsilon - x^\\star\\|_2}{\\|x^\\star\\|_2} = \\frac{\\|A^{-1}\\,\\delta b\\|_2}{\\|x^\\star\\|_2}.\n$$\n程序为每个用例报告的放大因子 $r$ 是\n$$\nr = \\frac{\\|x_{\\epsilon} - x^\\star\\|_{2} / \\|x^\\star\\|_{2}}{\\|\\delta b\\|_{2} / \\|b\\|_{2}}.\n$$\n根据范数性质和矩阵2-范数的定义，我们可以将此放大与矩阵2-范数下的条件数 $\\kappa_2(A) = \\|A\\|_2 \\, \\|A^{-1}\\|_2$ 联系起来。具体来说，使用 $\\|A^{-1} \\delta b\\|_2 \\le \\|A^{-1}\\|_2 \\, \\|\\delta b\\|_2$ 和 $\\|b\\|_2 = \\|A x^\\star\\|_2 \\le \\|A\\|_2 \\, \\|x^\\star\\|_2$，我们得到\n$$\n\\frac{\\|x_\\epsilon - x^\\star\\|_2}{\\|x^\\star\\|_2} \\le \\|A^{-1}\\|_2 \\, \\|\\delta b\\|_2 \\,\\frac{1}{\\|x^\\star\\|_2}\n\\le \\|A^{-1}\\|_2 \\, \\|A\\|_2 \\, \\frac{\\|\\delta b\\|_2}{\\|b\\|_2} = \\kappa_2(A) \\, \\frac{\\|\\delta b\\|_2}{\\|b\\|_2}.\n$$\n因此\n$$\nr \\le \\kappa_2(A).\n$$\n这个不等式表明，解的相对误差最多可被放大到大约为条件数的程度。对于良态矩阵，如单位矩阵 $I$，我们有 $\\kappa_2(I) = 1$，因此 $r$ 应该接近于 $1$。对于病态矩阵，如 Hilbert 矩阵，$\\kappa_2(A)$ 非常大，即使一个非常小的 $\\epsilon$ 也可能导致 $x$ 中产生巨大的相对误差，从而产生一个大的 $r$。\n\n该测试套件涵盖了几个范围：\n- 用例1使用一个大小为5的 Hilbert 矩阵，该矩阵是病态的，但规模适中。\n- 用例2使用一个大小为10的 Hilbert 矩阵，该矩阵病态性更强，通常会产生更大的放大因子 $r$。\n- 用例3使用一个大小为8的单位矩阵，该矩阵是完美良态的，因此 $r$ 应该约等于1。\n- 用例4使用一个近奇异的 $2 \\times 2$ 矩阵，其中一个元素与其他元素相差 $10^{-10}$，从而产生非常大的放大效果。\n\n对于每个用例，程序构造 $x^\\star$、$b$、单位范数扰动方向 $v$、具有指定 $\\epsilon$ 的扰动 $\\delta b$，求解 $x_\\epsilon$，计算相对误差，并报告四舍五入到6位有效数字的 $r$。最终输出是包含列表 $[r_1, r_2, r_3, r_4]$ 的单行，顺序不变。这个过程直接且清晰地展示了 $A$ 中的病态性如何将 $b$ 中的微小相对扰动放大为解 $x$ 中的巨大相对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hilbert(n: int) - np.ndarray:\n    # H[i,j] = 1 / (i + j + 1) with zero-based i,j; but use one-based formula directly\n    i = np.arange(1, n + 1).reshape(-1, 1)\n    j = np.arange(1, n + 1).reshape(1, -1)\n    return 1.0 / (i + j - 1.0)\n\ndef alternating_unit_vector(n: int) - np.ndarray:\n    # v_i = (-1)^(i-1) / sqrt(n), i = 1..n\n    signs = (-1.0) ** np.arange(n)\n    v = signs / np.sqrt(n)\n    # Ensure unit norm numerically\n    return v / np.linalg.norm(v, 2)\n\ndef amplification_factor(A: np.ndarray, eps: float) - float:\n    n = A.shape[0]\n    x_star = np.ones(n, dtype=float)\n    b = A @ x_star\n    nb = np.linalg.norm(b, 2)\n    if nb == 0.0:\n        # Degenerate, but not expected with provided tests; return NaN-like large value\n        return float('nan')\n    v = alternating_unit_vector(n)\n    delta_b = eps * nb * v\n    b_tilde = b + delta_b\n    # Solve for perturbed solution\n    x_tilde = np.linalg.solve(A, b_tilde)\n    # Relative errors\n    rel_b = np.linalg.norm(delta_b, 2) / nb\n    rel_x = np.linalg.norm(x_tilde - x_star, 2) / np.linalg.norm(x_star, 2)\n    # Amplification factor\n    return rel_x / rel_b\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (A_matrix, epsilon)\n    A1 = hilbert(5)\n    eps1 = 1e-8\n\n    A2 = hilbert(10)\n    eps2 = 1e-8\n\n    A3 = np.eye(8, dtype=float)\n    eps3 = 1e-8\n\n    A4 = np.array([[1.0, 1.0],\n                   [1.0, 1.0 + 1e-10]], dtype=float)\n    eps4 = 1e-12\n\n    test_cases = [\n        (A1, eps1),\n        (A2, eps2),\n        (A3, eps3),\n        (A4, eps4),\n    ]\n\n    results = []\n    for A, eps in test_cases:\n        r = amplification_factor(A, eps)\n        # Round to 6 significant digits\n        if np.isnan(r) or np.isinf(r):\n            results.append(\"nan\")\n        else:\n            results.append(f\"{r:.6g}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2449583"}]}