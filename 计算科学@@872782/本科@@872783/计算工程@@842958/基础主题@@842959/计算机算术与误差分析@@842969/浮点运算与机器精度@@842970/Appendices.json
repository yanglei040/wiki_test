{"hands_on_practices": [{"introduction": "我们对浮点运算实践的探索，始于一个令人惊讶的演示。我们将探究一个简单的递归过程，它与数学直觉相反，可能永远无法达到其目标值。这个练习 [@problem_id:2393700] 突显了对浮点数使用直接相等性检查的严重危险，并揭示了诸如表示误差和精度吸收（absorption）等基本限制。", "problem": "考虑符合电气和电子工程师协会 (IEEE) $754$ binary64 标准的双精度浮点计算，采用“舍入到最近，偶数优先”的舍入模式。令 $\\operatorname{fl}(\\cdot)$ 表示根据此规则舍入后的单次浮点运算结果。定义一个由序列 $\\{x_k\\}_{k \\ge 0}$ 构成的递归过程，其初始值为 $x_0 \\in \\mathbb{R}$，增量为 $d \\in \\mathbb{R}$，具体如下：\n$$\nx_{k+1} = \\operatorname{fl}(x_k + d).\n$$\n该过程预计在满足浮点相等条件 $x_k = y$ 的最小非负整数 $k$ 处终止，其中 $y \\in \\mathbb{R}$ 是一个给定的目标值。如果在规定的递归限制 $N_{\\max} \\in \\mathbb{N}$ 内不存在这样的 $k$，则宣布该过程对于给定参数是不终止的。\n\n您的任务是编写一个完整的、可运行的程序，该程序对下面测试套件中的每个参数集 $(x_0, d, y, N_{\\max})$，仅使用编程语言的浮点语义，严格按照规定执行递归，并为每种情况报告：\n- 一个布尔值，指示递归是否因在某个 $k \\le N_{\\max}$ 处满足 $x_k = y$ 而终止，\n- 实际执行的整数步数 $k_{\\text{out}}$（等于首次出现终止时的 $k$，如果未终止则为 $N_{\\max}$），\n- 最终的浮点值 $x_{k_{\\text{out}}}$，以及\n- 浮点绝对误差 $|x_{k_{\\text{out}}} - y|$。\n\n不涉及物理单位或角度。所有计算都是纯数值的。程序不得读取任何输入。\n\n参数值的测试套件：\n1. $(x_0, d, y, N_{\\max}) = (0.0, 0.5, 1.0, 10)$\n2. $(x_0, d, y, N_{\\max}) = (0.0, 0.1, 1.0, 50)$\n3. $(x_0, d, y, N_{\\max}) = (1.0, 2^{-55}, 1.0 + 2^{-52}, 900)$\n4. $(x_0, d, y, N_{\\max}) = (1.0, -0.5, 0.0, 10)$\n5. $(x_0, d, y, N_{\\max}) = (1.0, -0.1, 0.0, 50)$\n\n在情况3中，目标值 $y$ 是大于1.0的下一个可表示的浮点数，即在binary64中 $y = \\operatorname{nextafter}(1.0, +\\infty) = 1.0 + 2^{-52}$。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是一个形如 $[\\text{terminated}, k_{\\text{out}}, x_{k_{\\text{out}}}, |x_{k_{\\text{out}}} - y|]$ 的列表。例如，整体输出必须类似于\n$[[\\text{bool}, \\text{int}, \\text{float}, \\text{float}], \\ldots]$\n并且位于单行上，每个内部列表对应一个测试用例，顺序与上文一致。", "solution": "问题陈述经评估有效。它在科学上基于计算工程的原理，特别是IEEE $754$ 标准所定义的浮点算术。该问题是适定的、客观的，并包含足够的信息以推导出唯一、可验证的解。\n\n任务是模拟一个由序列 $x_{k+1} = \\operatorname{fl}(x_k + d)$ 定义的递归过程，其中 $\\operatorname{fl}(\\cdot)$ 代表一次浮点运算。该模拟必须遵循binary64（双精度）算术的语义。在大多数平台上，Python中的标准`float`类型及其相关的算术运算（`+`）都符合IEEE $754$ binary64标准，并采用默认的“舍入到最近，偶数优先”的舍入模式。因此，在Python中直接实现该递推关系将能准确地模拟指定的过程。\n\n对于每个测试用例 $(x_0, d, y, N_{\\max})$，算法按以下步骤进行：\n$1$. 初始化状态变量：序列的当前值 $x_{\\text{current}} \\leftarrow x_0$，已执行的步数 $k_{\\text{out}} \\leftarrow 0$，以及一个终止标志 `terminated` $\\leftarrow$ `False`。所有数值参数（$x_0, d, y$）都被视为binary64浮点数。\n\n$2$. 检查是否立即终止。如果初始值 $x_0$ 等于目标值 $y$（在浮点比较中），则将 `terminated` 设置为 `True`。步数为 $0$。\n\n$3$. 如果在 $k=0$ 时没有终止，则开始一个从 $k=1$ 到 $N_{\\max}$ 的迭代循环。在每次迭代中（对应于递归的一步）：\n    a. 更新序列值：$x_{\\text{current}} \\leftarrow x_{\\text{current}} + d$。此操作直接实现了 $x_k \\leftarrow \\operatorname{fl}(x_{k-1} + d)$。\n    b. 设置 $k_{\\text{out}} \\leftarrow k$。\n    c. 检查终止条件：如果 $x_{\\text{current}} = y$。如果为真，则将 `terminated` 设置为 `True` 并退出循环。\n\n$4$. 循环结束后（无论是通过终止还是达到限制 $N_{\\max}$），收集最终结果：布尔值 `terminated`、整数 $k_{\\text{out}}$、最终值 $x_{k_{\\text{out}}}$ 以及最终的绝对误差 $|x_{k_{\\text{out}}} - y|$。\n\n这个模拟提供了对浮点运算基本行为的深入了解：\n- **精确可表示性**：在测试用例1和4中，初始值、增量（$0.5 = 2^{-1}$）和目标值都是可以精确表示为有限二进制分数的。算术是精确的，过程按预期终止。\n- **表示与舍入误差**：在测试用例2和5中，增量 $d = \\pm 0.1$ 在二进制中是一个循环小数（$0.000110011..._2$），无法精确表示。$d$ 的存储值是一个近似值。重复加算这个近似值会导致累积舍入误差，使得序列 $x_k$ 永远不会精确地等于目标值（$1.0$ 或 $0.0$）。因此，该过程在迭代限制内不会终止。\n- **吸收**：测试用例3展示了一种现象，即小的增量被“吸收”。序列的值为 $x_k \\approx 1.0$。在binary64中，对于1.0附近的数字，其末位单位 (ULP) 是 $2^{-52}$。增量是 $d = 2^{-55}$，它小于1.0的半个ULP（即 $2^{-55}  0.5 \\times \\text{ulp}(1.0) = 2^{-53}$）。根据“舍入到最近”规则，精确和 $1.0 + 2^{-55}$ 的结果会被舍入回最接近的可表示数，即1.0。因此，$x_{k+1} = \\operatorname{fl}(x_k + d) = \\operatorname{fl}(1.0 + 2^{-55}) = 1.0$。序列值保持在1.0不变，永远不会达到目标值 $y = 1.0 + 2^{-52}$，即1.0之后的下一个可表示数。\n\n程序将对每个案例执行此直接模拟，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(x0: float, d: float, y: float, n_max: int):\n    \"\"\"\n    Performs the recursive floating-point simulation for a single test case.\n\n    Args:\n        x0 (float): The initial value x_0.\n        d (float): The increment d.\n        y (float): The target value y.\n        n_max (int): The maximum number of recursion steps.\n\n    Returns:\n        A list containing [terminated, k_out, x_final, error].\n    \"\"\"\n    x_current = float(x0)\n    terminated = False\n    k_out = 0\n\n    # Check for termination at k=0\n    if x_current == y:\n        terminated = True\n    else:\n        # Loop from k=1 up to N_max\n        for k in range(1, n_max + 1):\n            x_current = x_current + d\n            k_out = k\n            if x_current == y:\n                terminated = True\n                break\n\n    # Calculate final absolute error\n    abs_error = abs(x_current - y)\n\n    return [terminated, k_out, x_current, abs_error]\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the simulation for each, printing the\n    results in the specified format.\n    \"\"\"\n    # Test suite of parameter values: (x_0, d, y, N_max)\n    # The value for y in Case 3 is the next representable double-precision\n    # float after 1.0, which is precisely 1.0 + 2**-52.\n    # While np.nextafter(1.0, np.inf) could be used, the explicit form is clearer\n    # and avoids a dependency if numpy wasn't strictly needed otherwise.\n    # Given numpy is allowed, we use the explicit expression for clarity.\n    test_cases = [\n        (0.0, 0.5, 1.0, 10),\n        (0.0, 0.1, 1.0, 50),\n        (1.0, 2**-55, 1.0 + 2**-52, 900),\n        (1.0, -0.5, 0.0, 10),\n        (1.0, -0.1, 0.0, 50),\n    ]\n\n    results = []\n    for case in test_cases:\n        x0, d, y, n_max = case\n        result = run_simulation(x0, d, y, n_max)\n        results.append(result)\n\n    # Format the final output string as a list of lists.\n    # The str() of a list automatically handles bools and formats floats.\n    result_strings = [str(res) for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2393700"}, {"introduction": "数值误差最臭名昭著的来源之一是“灾难性抵消”，它发生在两个几乎相等的数相减时。本实践 [@problem_id:2393724] 挑战你诊断并修复一个常见数学函数中的此问题。通过使用泰勒级数和三角恒等式等工具，你将学会如何将一个不稳定的表达式重构为数值上稳健的等价形式，这是任何计算工程师的关键技能。", "problem": "一位计算工程师必须在数值模拟中对实数 $x$（包括 $x$ 接近 $x=0$ 的值）评估函数 $f(x) = \\dfrac{\\cos(x) - 1}{x^{2}}$。实现目标是符合电气和电子工程师协会 (IEEE) $754$ 双精度标准并采用舍入到最近值的算术，其中单位舍入误差为 $u = 2^{-53}$。仅从余弦函数在 $x=0$ 处的泰勒级数和基本三角恒等式出发，完成以下任务：\n\n- 使用 $\\cos(x)$ 的泰勒级数定义，判断 $f(x)$ 在 $x=0$ 处是否具有可去奇点，并求其在 $x \\to 0$ 时的极限。\n- 解释为什么直接按原式计算 $f(x)$ 会在 $|x|$ 很小时遭遇灾难性抵消，方法是将 $\\cos(x) - 1$ 的量级与 $1$ 附近的浮点数间距联系起来。\n- 使用泰勒级数展开和代数运算，推导出一个 $f(x)$ 的闭式解析表达式，该表达式对于所有实数 $x$ 都与 $f(x)$ 完全相等，在 $x=0$ 处有明确定义的有限极限，并且避免了对两个几乎相等的数进行相减。您的推理应能证明为什么这种重构在 $x=0$ 附近是数值稳定的。\n\n仅报告您最终重构的 $f(x)$ 的闭式表达式作为答案。无需舍入，无单位适用。", "solution": "所述问题需要进行验证。\n\n已知条件逐字提取如下：\n- 函数：$f(x) = \\dfrac{\\cos(x) - 1}{x^{2}}$，对于实数 $x$。\n- 关注域：$x$ 接近 $x=0$ 的值。\n- 算术：IEEE $754$ 双精度，舍入到最近值。\n- 单位舍入误差：$u = 2^{-53}$。\n- 允许的方法：余弦函数在 $x=0$ 处的泰勒级数和基本三角恒等式。\n- 任务1：分析 $x=0$ 处的奇点并求极限 $\\lim_{x \\to 0} f(x)$。\n- 任务2：解释在 $|x|$ 很小时发生的灾难性抵消。\n- 任务3：推导一个数值稳定的 $f(x)$ 的闭式解析表达式。\n- 要求输出：最终重构的闭式表达式。\n\n该问题具有科学依据，涉及数值分析中的标准课题，如函数求值、浮点误差和灾难性抵消。该问题是适定的，目标明确，信息充分，足以推导出唯一且有意义的解。语言客观、精确。问题自成体系且逻辑一致。因此，该问题被认为是有效的，并将提供解答。\n\n我们首先分析函数 $f(x)$ 在 $x=0$ 附近的行为。$\\cos(x)$ 在 $x=0$ 处展开的泰勒级数由下式给出：\n$$ \\cos(x) = \\sum_{n=0}^{\\infty} \\frac{(-1)^{n}x^{2n}}{(2n)!} = 1 - \\frac{x^{2}}{2!} + \\frac{x^{4}}{4!} - \\frac{x^{6}}{6!} + \\dots $$\n将此式代入 $f(x)$ 的分子，得到：\n$$ \\cos(x) - 1 = \\left(1 - \\frac{x^{2}}{2!} + \\frac{x^{4}}{4!} - \\dots\\right) - 1 = - \\frac{x^{2}}{2!} + \\frac{x^{4}}{4!} - \\dots = \\sum_{n=1}^{\\infty} \\frac{(-1)^{n}x^{2n}}{(2n)!} $$\n现在，我们可以用这个级数来表示 $f(x)$：\n$$ f(x) = \\frac{1}{x^{2}} \\left( - \\frac{x^{2}}{2} + \\frac{x^{4}}{24} - \\frac{x^{6}}{720} + \\dots \\right) = - \\frac{1}{2} + \\frac{x^{2}}{24} - \\frac{x^{4}}{720} + \\dots $$\n为了求 $x \\to 0$ 时的极限，我们计算该级数在 $x=0$ 处的值：\n$$ \\lim_{x \\to 0} f(x) = \\lim_{x \\to 0} \\left( - \\frac{1}{2} + \\frac{x^{2}}{24} - \\frac{x^{4}}{720} + \\dots \\right) = -\\frac{1}{2} $$\n由于极限是有限的，函数 $f(x)$ 在 $x=0$ 处有一个可去奇点。\n\n接下来，我们解释直接计算 $f(x) = \\frac{\\cos(x) - 1}{x^{2}}$ 在 $|x|$ 很小时的数值不稳定性。对于 $|x| \\ll 1$，$\\cos(x)$ 的值非常接近 $1$。在 IEEE $754$ 双精度算术中，$\\cos(x)$ 的计算值，我们记为 $\\text{fl}(\\cos(x))$，将是一个接近 $1$ 的浮点数。令 $\\cos(x) = 1 - \\delta$，其中对于很小的 $x$，$\\delta \\approx \\frac{x^2}{2}$。$\\cos(x)$ 的浮点表示具有一个与单位舍入误差 $u = 2^{-53}$ 同量级的固有相对误差。因此，$\\text{fl}(\\cos(x))$ 中的绝对误差约为 $u \\cdot |\\cos(x)| \\approx u$。操作 $\\cos(x) - 1$ 于是成为两个几乎相等的数的减法。这次减法的真实结果是 $-\\delta \\approx -x^2/2$。计算得到的结果 $\\text{fl}(\\cos(x)) - 1$ 的绝对误差约为 $u$。因此，计算出的分子的相对误差约为 $\\frac{u}{|-x^2/2|} = \\frac{2u}{x^2}$。当 $x \\to 0$ 时，这个相对误差无界增长，导致有效数字的完全丧失。这种现象被称为灾难性抵消。\n\n为了解决这个问题，我们必须重构该表达式以避免减去几乎相等的量。我们使用半角三角恒等式：\n$$ \\sin^{2}\\left(\\frac{\\theta}{2}\\right) = \\frac{1 - \\cos(\\theta)}{2} $$\n令 $\\theta = x$，我们有 $1 - \\cos(x) = 2\\sin^{2}(x/2)$。这意味着 $\\cos(x) - 1 = -2\\sin^{2}(x/2)$。这个恒等式对所有实数 $x$ 都精确成立。将此代入 $f(x)$ 的原始表达式中：\n$$ f(x) = \\frac{-2\\sin^{2}(x/2)}{x^{2}} $$\n这种形式仍然呈现一个 $0/0$ 的不定形式，但它消除了有问题的减法。为了获得最佳的数值稳定性并使 $x=0$ 附近的行为明确，我们进行进一步的代数操作：\n$$ f(x) = \\frac{-2\\sin^{2}(x/2)}{x^{2}} = -\\frac{1}{2} \\cdot \\frac{4\\sin^{2}(x/2)}{x^{2}} = -\\frac{1}{2} \\cdot \\frac{(2\\sin(x/2))^{2}}{x^2} = -\\frac{1}{2} \\left(\\frac{2\\sin(x/2)}{x}\\right)^2 $$\n我们可以重写括号内的分母，使其与正弦函数的参数相匹配：\n$$ f(x) = -\\frac{1}{2} \\left(\\frac{\\sin(x/2)}{x/2}\\right)^{2} $$\n这个最终表达式在解析上对于所有 $x \\neq 0$ 都与原表达式相同。它对于小的 $|x|$ 是数值稳定的，因为有问题的减法已被行为良好的运算所取代。对于小的 $y=x/2$，$\\sin(y)$ 的求值是准确的，并且除法 $\\sin(y)/y$ 在 $y \\to 0$ 时趋近于 $1$。这个与 $\\operatorname{sinc}$ 函数相关的比值是计算上良态的。随后的平方和乘以 $-1/2$ 不会引入显著的相对误差。该表达式在 $x=0$ 处具有正确的极限 $-\\frac{1}{2}$ 并且是良定义的，为跨所有实数 $x$ 的数值实现提供了一个鲁棒的公式。", "answer": "$$ \\boxed{-\\frac{1}{2} \\left(\\frac{\\sin(x/2)}{x/2}\\right)^{2}} $$", "id": "2393724"}, {"introduction": "虽然单次运算可能存在问题，但误差也可能在许多步骤中累积，逐渐降低结果的准确性。这个动手实践问题 [@problem_id:2393714] 聚焦于求和这一基本任务，将朴素的方法与优雅的 Kahan 求和算法进行对比。通过实现和测试这些方法，你将对补偿算法如何能显著提高迭代计算中的数值精度有一个具体的理解。", "problem": "您的任务是通过对比朴素的逐项求和与一种补偿求和方法，来研究浮点数加法中舍入误差的累积情况。您必须实现一个完整、可运行的程序，该程序针对一个固定的测试集，使用 Kahan 求和算法计算朴素浮点数和与补偿和，并将两者与使用精确有理数算术计算的高精度参考值进行比较。您的程序不得读取任何输入，且必须按照下文指定格式打印单行输出。\n\n使用的基本原理是标准的浮点数算术舍入误差模型（采用四舍五入到最近值）：对于任意两个实数 $a$ 和 $b$，计算出的浮点数加法满足 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta|\\le u$，$u$ 是所选格式的单位舍入误差。您也可以利用这样一个事实：对 $n$ 个项进行朴素求和，在最坏情况下会累积 $O(nu)$ 数量级的舍入误差，而补偿求和技术旨在通过显式地考虑因舍入而丢失的低位比特来减少主阶误差的累积。\n\n要求：\n- 实现两个对双精度实数列表进行操作的求和例程：\n  - 一个朴素求和，对每一项 $x_i$ 通过 $s \\leftarrow s + x_i$ 迭代更新一个累加和。\n  - 一个 Kahan 补偿求和，使用一个补偿变量来结转每次加法中丢失的低位信息。\n- 为了得到高精度参考值，请使用精确有理数算术（例如，使用一种将每一项 $x_i$ 表示为分数并进行精确求和的有理数类型）来计算每个列表的精确和。该参考值作为实数算术中的基准真相。\n\n测试集：\n- 使用以下四个测试用例，每个用例都指定为一个有序列表。每个列表都包含大数量级项和小数量级项的混合，以暴露灾难性抵消和有效数字损失问题。\n  1. $[\\,10^{16},\\,1,\\,-10^{16}\\,]$。\n  2. $[\\,10^{16},\\,\\underbrace{1,\\,1,\\,\\dots,\\,1}_{\\text{100000 次}},\\,-10^{16}\\,]$。精确的数学和为 $100000$。\n  3. $[\\,1,\\,\\underbrace{10^{-16},\\,10^{-16},\\,\\dots,\\,10^{-16}}_{\\text{100000 次}},\\,-1\\,]$。精确的数学和为 $100000\\cdot 10^{-16}=10^{-11}$。\n  4. $[\\,10^{16},\\,\\underbrace{10^{-6},\\,10^{-6},\\,\\dots,\\,10^{-6}}_{\\text{100000 次}},\\,-10^{16}\\,]$。精确的数学和为 $100000\\cdot 10^{-6}=10^{-1}$。\n\n计算与比较：\n- 对于每个测试用例，计算：\n  - 朴素浮点数和 $s_{\\text{naive}}\\in\\mathbb{R}$。\n  - Kahan 浮点数和 $s_{\\text{kahan}}\\in\\mathbb{R}$。\n  - 使用精确有理数算术计算的精确参考和 $s_{\\star}\\in\\mathbb{R}$。\n- 对于每个测试用例，计算绝对误差 $e_{\\text{naive}}=\\lvert s_{\\text{naive}}-s_{\\star}\\rvert$ 和 $e_{\\text{kahan}}=\\lvert s_{\\text{kahan}}-s_{\\star}\\rvert$，并确定一个布尔标志 $\\text{better}$，当且仅当 $e_{\\text{kahan}}  e_{\\text{naive}}$。对于每个测试用例，将朴素和、Kahan和、精确参考和以及 $\\text{better}$ 标志收集到一个形如 `$[s_{\\text{naive}}, s_{\\text{kahan}}, s_{\\star}, \\text{better}]$` 的列表中。您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个由方括号括起来的逗号分隔列表。", "solution": "所述问题是有效的。它在科学上基于数值分析的既定原则，特别是浮点数算术。该问题是适定的，为要实现的算法提供了清晰的定义，配备了一套完整的测试数据和明确的输出格式。问题是客观的，没有矛盾或信息缺失。我们可以着手解决。\n\n所要解决的根本问题是，计算机浮点数加法不满足结合律，并且会产生舍入误差。对于两个实数 $a$ 和 $b$，它们的浮点和模型为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中相对误差 $\\lvert\\delta\\rvert$ 受单位舍入误差 $u$ 的限制。当对一个数列求和时，这些微小的误差会累积。本分析将对比一种朴素求和方法与一种旨在减轻这种误差累积的补偿方法。\n\n**1. 朴素求和**\n\n最直接的方法是遍历数字列表 $\\{x_i\\}_{i=1}^n$，并将和累加到一个浮点变量 $s$ 中。更新规则为 $s \\leftarrow \\operatorname{fl}(s + x_i)$。该方法的主要弱点是**大数吞小数（swamping）**。如果累加和 $s$ 的数量级远大于待加项 $x_i$，那么 $x_i$ 的贡献可能会在舍入过程中部分或完全丢失。例如，在标准双精度算術中，如果 $s \\approx 10^{16}$ 且 $x_i = 1$，操作 $\\operatorname{fl}(10^{16} + 1)$ 的结果为 $10^{16}$，因为精度不足以精确表示结果。项 $x_i$ 被有效丢弃了。\n\n**2. Kahan 补偿求和**\n\nKahan 求和算法是一种能显著减少舍入误差累积的技术。它维护第二个变量，即一个补偿值 $c$，用于累积每一步中产生的误差。对于输入序列中的每一项 $x_i$，该算法执行以下操作：\n1.  校正当前项：$y \\leftarrow x_i - c$。此步骤从当前项中减去先前加法累积的误差。\n2.  加到总和中：$t \\leftarrow s + y$。这是一个标准的浮点加法，如果 $s$ 很大， $y$ 的低位比特可能会丢失。\n3.  恢复误差：$c \\leftarrow (t - s) - y$。这是关键步骤。项 $(t - s)$ 代表了 $y$ 中成功加到 $s$ 的部分。通过减去原始（校正后）的项 $y$，我们分离出了加法 $s+y$ 所产生的舍入误差的相反数。这个误差存储在 $c$ 中。\n4.  更新总和：$s \\leftarrow t$。\n\n这个迭代过程将每次加法中丢失的“零头”结转到下一次计算中，从而确保最终累积的误差远小于朴素求和的情况。Kahan 求和的误差界约为 $O(u + N\\epsilon u)$ 数量级，其中 $\\epsilon$ 与机器精度有关，这与朴素求和最坏情况下的 $O(Nu)$ 误差相比是一个巨大的改进。\n\n**3. 精确有理数算术**\n\n为了建立一个权威的基准真相（记为 $s_{\\star}$），我们必须在没有任何浮点误差的情况下计算总和。这可以通过使用精确有理数算术来实现。每个作为浮点值给出的输入数字，首先被转换为其精确的有理数表示，即一个分数 $p/q$，其中 $p, q \\in \\mathbb{Z}$。所有后续的加法都使用精确的分数算術规则执行，例如 $\\frac{a}{b} + \\frac{c}{d} = \\frac{ad+bc}{bd}$。此过程不受浮点系统的表示和计算误差的影响，从而得出输入值的真实数学和。\n\n**评估过程**\n\n对于四个指定的测试用例中的每一个，我们计算朴素和 $s_{\\text{naive}}$、Kahan 和 $s_{\\text{kahan}}$ 以及精确参考和 $s_{\\star}$。这些测试用例经过专门设计，通过混合数量级差异巨大的数字，来暴露朴素求和的失效模式，特别是大数吞小数和灾难性抵消。然后我们计算绝对误差 $e_{\\text{naive}} = \\lvert s_{\\text{naive}} - s_{\\star} \\rvert$ 和 $e_{\\text{kahan}} = \\lvert s_{\\text{kahan}} - s_{\\star} \\rvert$。当且仅当 $e_{\\text{kahan}}  e_{\\text{naive}}$ 时，布尔标志 $\\text{better}$ 设置为 $\\text{True}$，这定量地证明了对于给定的输入，Kahan 算法具有更高的准确性。最终输出被构造成一个记录列表，每个记录包含 $[s_{\\text{naive}}, s_{\\text{kahan}}, s_{\\star}, \\text{better}]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport scipy\nfrom fractions import Fraction\n\ndef naive_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the sum of a list of numbers using a naive iterative approach.\n    \"\"\"\n    s = 0.0\n    for x in numbers:\n        s += x\n    return s\n\ndef kahan_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the sum of a list of numbers using the Kahan summation algorithm\n    to reduce the accumulation of floating-point error.\n    \"\"\"\n    s = 0.0  # The running sum.\n    c = 0.0  # The compensation for lost low-order bits.\n    for x in numbers:\n        y = x - c    # c is the error from the previous sum.\n        t = s + y    # s is large, y is small, so low-order digits of y are lost.\n        c = (t - s) - y  # (t - s) recovers the high-order part of y.\n                         # Subtracting y recovers the low part, negated.\n        s = t        # Algebraically, c should be 0. But with rounding, it's not.\n    return s\n\ndef exact_sum(numbers: list[float]) - float:\n    \"\"\"\n    Computes the exact sum of a list of floating-point numbers by\n    converting them to Fractions and using rational arithmetic.\n    \"\"\"\n    s = Fraction(0)\n    for x in numbers:\n        s += Fraction(x)\n    return float(s)\n\ndef solve():\n    \"\"\"\n    Runs the full test suite, comparing naive and Kahan summation against\n    an exact rational arithmetic reference, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: A simple case of catastrophic cancellation.\n        [1e16, 1.0, -1e16],\n        # Case 2: Summing many small numbers in the presence of a large one.\n        [1e16] + [1.0] * 100000 + [-1e16],\n        # Case 3: Summing many tiny numbers that are smaller than machine epsilon\n        # relative to the initial sum.\n        [1.0] + [1e-16] * 100000 + [-1.0],\n        # Case 4: A similar case to #2, but with smaller additions.\n        [1e16] + [1e-6] * 100000 + [-1e16],\n    ]\n\n    results = []\n    for case_data in test_cases:\n        # Compute the sum using all three methods.\n        s_naive = naive_sum(case_data)\n        s_kahan = kahan_sum(case_data)\n        s_star = exact_sum(case_data)\n        \n        # Calculate the absolute errors for both floating-point methods.\n        e_naive = abs(s_naive - s_star)\n        e_kahan = abs(s_kahan - s_star)\n        \n        # Determine if Kahan's method produced a smaller error.\n        better = e_kahan  e_naive\n        \n        # Store the record for this test case.\n        record = [s_naive, s_kahan, s_star, better]\n        results.append(record)\n\n    # Final print statement in the exact required format.\n    # The format template from the prompt is used: print(f\"[{','.join(map(str, results))}]\")\n    # str(list) in Python automatically includes spaces, which matches the example\n    # format diagram '[ [ . , . , . , . ], ... ]'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2393714"}]}