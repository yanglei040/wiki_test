{"hands_on_practices": [{"introduction": "病态线性系统的核心危险在于其对微小扰动的极端敏感性。这个练习将通过一个具体的、分步的计算，清晰地展示有限的数值精度如何导致截然不同且不准确的结果。通过分别使用模拟的单精度和双精度浮点运算求解同一个病态系统，我们将亲眼见证这种误差放大效应，从而深刻理解为何高精度计算在处理此类问题时至关重要。[@problem_id:2203807]", "problem": "在计算科学中，一个常见的任务是求解形如 $Ax = b$ 的线性方程组。然而，数字计算机使用有限精度浮点运算，这会引入误差，尤其是在系统是病态的情况下（即，输入数据的微小变化会导致解的巨大变化）。\n\n考虑以下病态线性方程组 $Ax=b$：\n$$\n\\begin{pmatrix}\n1  1 \\\\\n1  1.00001\n\\end{pmatrix}\n\\begin{pmatrix}\nx_1 \\\\\nx_2\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n1 \\\\\n1.0000066667\n\\end{pmatrix}\n$$\n向量 $b$ 的构造使得该方程组的精确解析解已知为 $x_{\\text{true}} = \\begin{pmatrix} 1/3 \\\\ 2/3 \\end{pmatrix}$。\n\n你的任务是研究数值精度对解的影响。你将使用不带主元选取的高斯消去法，在两种不同的模拟浮点运算模型下求解该系统：\n\n1.  **单精度**：所有初始值、中间计算和最终结果都四舍五入到6位有效数字。\n2.  **双精度**：所有初始值、中间计算和最终结果都四舍五入到12位有效数字。\n\n在得到数值解 $x_{\\text{single}}$ 和 $x_{\\text{double}}$ 后，计算每个解相对于精确解 $x_{\\text{true}}$ 的相对误差。相对误差使用无穷范数（$\\| \\cdot \\|_{\\infty}$）定义如下：\n$$\nE = \\frac{\\|x_{\\text{computed}} - x_{\\text{true}}\\|_{\\infty}}{\\|x_{\\text{true}}\\|_{\\infty}}\n$$\n其中对于向量 $v = \\begin{pmatrix} v_1 \\\\ v_2 \\end{pmatrix}$，无穷范数为 $\\|v\\|_{\\infty} = \\max(|v_1|, |v_2|)$。\n\n确定单精度情况下的相对误差 $E_{\\text{single}}$ 和双精度情况下的相对误差 $E_{\\text{double}}$。按顺序提供你对 $E_{\\text{single}}$ 和 $E_{\\text{double}}$ 的答案，每个答案都四舍五入到三位有效数字。", "solution": "我们通过不带主元选取的高斯消去法求解该方程组，在每次算术运算后将所有存储的值四舍五入到指定的有效数字位数。\n\n给定\n$$\nA=\\begin{pmatrix}1  1\\\\ 1  1.00001\\end{pmatrix},\\quad\nb=\\begin{pmatrix}1\\\\ 1.0000066667\\end{pmatrix},\\quad\nx_{\\text{true}}=\\begin{pmatrix}\\frac{1}{3}\\\\ \\frac{2}{3}\\end{pmatrix}.\n$$\n\n单精度（6位有效数字）：\n- 将初始数据四舍五入到6位有效数字：\n$$\na_{11}=1,\\ a_{12}=1,\\ a_{21}=1,\\ a_{22}=1.00001,\\ b_{1}=1,\\ b_{2}=\\operatorname{round}_{6\\text{sf}}(1.0000066667)=1.00001.\n$$\n- 消元乘子：\n$$\nm_{21}=\\operatorname{round}_{6\\text{sf}}\\!\\left(\\frac{a_{21}}{a_{11}}\\right)=\\operatorname{round}_{6\\text{sf}}(1)=1.\n$$\n- 对第2行进行行更新：\n$$\na_{21}'=\\operatorname{round}_{6\\text{sf}}(a_{21}-m_{21}a_{11})=\\operatorname{round}_{6\\text{sf}}(0)=0,\n$$\n$$\na_{22}'=\\operatorname{round}_{6\\text{sf}}(a_{22}-m_{21}a_{12})=\\operatorname{round}_{6\\text{sf}}(1.00001-1)=\\operatorname{round}_{6\\text{sf}}(0.00001)=0.00001,\n$$\n$$\nb_{2}'=\\operatorname{round}_{6\\text{sf}}(b_{2}-m_{21}b_{1})=\\operatorname{round}_{6\\text{sf}}(1.00001-1)=0.00001.\n$$\n- 回代：\n$$\nx_{2}=\\operatorname{round}_{6\\text{sf}}\\!\\left(\\frac{b_{2}'}{a_{22}'}\\right)=\\operatorname{round}_{6\\text{sf}}\\!\\left(\\frac{0.00001}{0.00001}\\right)=1,\n$$\n$$\nx_{1}=\\operatorname{round}_{6\\text{sf}}\\!\\left(\\frac{b_{1}-a_{12}x_{2}}{a_{11}}\\right)=\\operatorname{round}_{6\\text{sf}}(1-1)=0.\n$$\n因此 $x_{\\text{single}}=\\begin{pmatrix}0\\\\ 1\\end{pmatrix}$。无穷范数下的相对误差为\n$$\n\\|x_{\\text{single}}-x_{\\text{true}}\\|_{\\infty}=\\max\\!\\left(\\left|0-\\frac{1}{3}\\right|,\\left|1-\\frac{2}{3}\\right|\\right)=\\frac{1}{3},\n$$\n$$\n\\|x_{\\text{true}}\\|_{\\infty}=\\max\\!\\left(\\left|\\frac{1}{3}\\right|,\\left|\\frac{2}{3}\\right|\\right)=\\frac{2}{3},\n$$\n$$\nE_{\\text{single}}=\\frac{\\frac{1}{3}}{\\frac{2}{3}}=\\frac{1}{2}=0.5.\n$$\n\n双精度（12位有效数字）：\n- 将初始数据四舍五入到12位有效数字：\n$$\na_{11}=1,\\ a_{12}=1,\\ a_{21}=1,\\ a_{22}=1.00001,\\ b_{1}=1,\\ b_{2}=1.0000066667.\n$$\n- 消元乘子：\n$$\nm_{21}=\\operatorname{round}_{12\\text{sf}}(1)=1.\n$$\n- 对第2行进行行更新：\n$$\na_{21}'=\\operatorname{round}_{12\\text{sf}}(0)=0,\\quad\na_{22}'=\\operatorname{round}_{12\\text{sf}}(1.00001-1)=\\operatorname{round}_{12\\text{sf}}(0.00001)=0.00001,\n$$\n$$\nb_{2}'=\\operatorname{round}_{12\\text{sf}}(1.0000066667-1)=\\operatorname{round}_{12\\text{sf}}(0.0000066667)=0.0000066667.\n$$\n- 回代：\n$$\nx_{2}=\\operatorname{round}_{12\\text{sf}}\\!\\left(\\frac{0.0000066667}{0.00001}\\right)=\\operatorname{round}_{12\\text{sf}}(0.66667)=0.66667=\\frac{66667}{100000},\n$$\n$$\nx_{1}=\\operatorname{round}_{12\\text{sf}}(1-0.66667)=\\operatorname{round}_{12\\text{sf}}(0.33333)=0.33333=\\frac{33333}{100000}.\n$$\n因此 $x_{\\text{double}}=\\begin{pmatrix}\\frac{33333}{100000}\\\\ \\frac{66667}{100000}\\end{pmatrix}$。无穷范数误差为\n$$\n\\|x_{\\text{double}}-x_{\\text{true}}\\|_{\\infty}\n=\\max\\!\\left(\\left|\\frac{33333}{100000}-\\frac{1}{3}\\right|,\\left|\\frac{66667}{100000}-\\frac{2}{3}\\right|\\right)\n=\\max\\!\\left(\\left|-\\frac{1}{300000}\\right|,\\left|\\frac{1}{300000}\\right|\\right)=\\frac{1}{300000}.\n$$\n因此\n$$\nE_{\\text{double}}=\\frac{\\frac{1}{300000}}{\\frac{2}{3}}=\\frac{1}{300000}\\cdot\\frac{3}{2}=\\frac{1}{200000}=5\\times 10^{-6}.\n$$\n\n最后，将每个结果四舍五入到三位有效数字，得到\n$$\nE_{\\text{single}}=0.500,\\quad E_{\\text{double}}=5.00\\times 10^{-6}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}0.500  5.00 \\times 10^{-6}\\end{pmatrix}}$$", "id": "2203807"}, {"introduction": "为了在实践中诊断病态问题，我们需要一个定量的度量工具，即条件数。这个编程练习旨在探讨条件数 $\\kappa$ 如何随矩阵结构的变化而变化，特别是针对在多项式插值中常见的、以病态著称的范德蒙德矩阵。通过为不同的节点分布构建范德蒙德矩阵并计算其条件数，我们将揭示矩阵的内在结构（如此处的节点选择）是如何直接决定其数值稳定性的。[@problem_id:2400727]", "problem": "您的任务是编写一个完整的程序，该程序为几个指定的节点集构建一个方形范德蒙矩阵，并计算其在三种矩阵范数下的条件数。对于节点向量 $\\mathbf{x} = (x_0, x_1, \\dots, x_{n-1}) \\in \\mathbb{R}^{n}$，方形范德蒙矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 定义为 $V_{i,j} = x_i^{j}$，其中 $i \\in \\{0,1,\\dots,n-1\\}$ 且 $j \\in \\{0,1,\\dots,n-1\\}$，这对应于幂次递增的单项式基底。对于给定的矩阵 $A \\in \\mathbb{R}^{n \\times n}$，矩阵 $p$-范数 $\\|A\\|_{p}$ 以标准方式定义为 $\\mathbb{R}^{n}$ 上的诱导算子范数，其中 $p \\in \\{1,2,\\infty\\}$。矩阵 $A$ 关于 $p$-范数的条件数定义为 $\\kappa_{p}(A) = \\|A\\|_{p}\\,\\|A^{-1}\\|_{p}$。特别地，$\\kappa_{2}(A) = \\sigma_{\\max}(A) / \\sigma_{\\min}(A)$，其中 $\\sigma_{\\max}$ 和 $\\sigma_{\\min}$ 分别是 $A$ 的最大和最小奇异值。\n\n对于以下每个测试用例，您的程序必须从指定的节点 $\\{x_i\\}_{i=0}^{n-1}$ 构建一个大小为 $n \\times n$ 的范德蒙矩阵 $V$，并计算三元组 $\\left[\\kappa_{1}(V),\\ \\kappa_{2}(V),\\ \\kappa_{\\infty}(V)\\right]$。最终输出必须四舍五入到 $6$ 位有效数字，并以 $10$ 为底的科学记数法表示。\n\n测试套件定义（以下顺序即为输出中要使用的顺序）：\n\n- 用例 1：$n = 8$，节点为 $x_i = \\dfrac{i}{n-1}$，其中 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 用例 2：$n = 12$，节点为 $x_i = -1 + \\dfrac{2i}{n-1}$，其中 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 用例 3：$n = 10$，节点为 $x_i = 1 - 10^{-3} \\, i$，其中 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 用例 4：$n = 16$，使用 $[-1,1]$ 上的 Chebyshev 节点，由 $x_i = \\cos\\!\\left(\\dfrac{(2i+1)\\pi}{2n}\\right)$ 给出，其中 $i \\in \\{0,1,\\dots,n-1\\}$。\n- 用例 5：$n = 1$，单个节点为 $x_0 = 0.37$。\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个长度为 $5$ 的列表。该列表的第 $k$ 个条目必须是一个长度为 $3$ 的列表，其值为第 $k$ 个测试用例的 $\\left[\\kappa_{1}(V),\\ \\kappa_{2}(V),\\ \\kappa_{\\infty}(V)\\right]$，并按此顺序排列。所有数值条目必须以 $10$ 为底的科学记数法打印，并四舍五入到 $6$ 位有效数字。例如，整体输出的形式必须是 $[[a_{1},b_{1},c_{1}],[a_{2},b_{2},c_{2}],\\dots,[a_{5},b_{5},c_{5}]]$，其中每个 $a_{k}, b_{k}, c_{k}$ 都是一个四舍五入到 $6$ 位有效数字的科学记数法浮点数。", "solution": "问题陈述已经过严格验证，并被确定为是合理的。这是一个计算线性代数中的适定问题，没有科学或逻辑上的不一致之处。所有的定义、变量和测试用例都足够清晰和精确，可以得到唯一且可验证的解。\n\n目标是计算范德蒙矩阵 $V$ 对于 $p$-范数（其中 $p \\in \\{1, 2, \\infty\\}$）的条件数 $\\kappa_p(V)$。该问题指定了五个不同的测试用例，每个用例都由一个大小 $n$ 和一组节点 $\\{x_i\\}_{i=0}^{n-1}$ 定义。\n\n首先，我们回顾范德蒙矩阵的定义。对于一个给定的包含 $n$ 个节点的向量 $\\mathbf{x} = (x_0, x_1, \\dots, x_{n-1})$，相应的方形范德蒙矩阵 $V \\in \\mathbb{R}^{n \\times n}$ 由其元素定义：\n$$ V_{i,j} = x_i^j, \\quad \\text{for } i, j \\in \\{0, 1, \\dots, n-1\\} $$\n该矩阵在多项式插值的背景下自然产生，即寻找一个通过一组点的多项式。\n\n一个非奇异矩阵 $A$ 关于矩阵范数 $\\|\\cdot\\|_p$ 的条件数由以下公式给出：\n$$ \\kappa_p(A) = \\|A\\|_p \\|A^{-1}\\|_p $$\n这个量度量了线性系统 $A\\mathbf{x} = \\mathbf{b}$ 的解对输入数据 $A$ 或 $\\mathbf{b}$ 中扰动的敏感性。大的条件数表示一个病态问题，其中输入中的小相对误差可能导致输出中的大相对误差。对于 $2$-范数的特殊情况，条件数与矩阵的奇异值有直接关系：\n$$ \\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)} $$\n其中 $\\sigma_{\\max}(A)$ 和 $\\sigma_{\\min}(A)$ 分别是 $A$ 的最大和最小奇异值。$1$-范数和 $\\infty$-范数分别是最大绝对列和与最大绝对行和。\n\n解决每个测试用例的计算过程如下：\n1.  **节点生成**：对于一个给定的维度为 $n$ 的测试用例，根据指定的公式生成节点向量 $\\mathbf{x} = (x_0, x_1, \\dots, x_{n-1})$。\n2.  **矩阵构建**：使用生成的节点构建 $n \\times n$ 的范德蒙矩阵 $V$。可以使用标准的数值库函数，例如 Python 中的 `numpy.vander` 并设置参数 `increasing=True`，来高效地完成此构建，确保 $V_{i,j} = x_i^j$。\n3.  **条件数计算**：利用一个鲁棒的数值线性代数库，特别是 `numpy.linalg.cond` 函数，来计算条件数。该函数提供了一种精确且稳定的方法来计算 $p \\in \\{1, 2, \\infty\\}$ 时的 $\\kappa_p(V)$。对于 $2$-范数，它使用奇异值分解，这是保证数值稳定性的首选方法。对于 $1$-范数和 $\\infty$-范数，它计算 $V$ 及其显式逆矩阵 $V^{-1}$ 的矩阵范数。\n4.  **格式化**：计算出的条件数必须按要求四舍五入到 $6$ 位有效数字，并以 $10$ 为底的科学记数法表示。\n\n此过程将应用于所有五个测试用例。注意节点分布的特性非常重要。\n-   **用例 1** 和 **用例 2** 使用均匀间隔的节点。由此类节点构建的范德蒙矩阵是出了名的病态，其条件数随矩阵大小 $n$ 呈指数级增长。\n-   **用例 3** 使用紧密聚集在值 $1$ 附近的节点。这种聚集使得范德蒙矩阵的列（即节点的幂 $x_i^j$）几乎线性相关，从而导致一个异常大的条件数。\n-   **用例 4** 使用 Chebyshev 节点。这些节点是 Chebyshev 多项式的根，并且已知对于许多多项式插值问题是最佳的。它们的分布（在区间端点附近更密集）使得生成的范德蒙矩阵比由均匀节点生成的矩阵条件要好得多。\n-   **用例 5** 是一个 $n=1$ 的平凡情况。矩阵为 $V = [x_0^0] = [1]$。其逆矩阵也是 $V^{-1} = [1]$。对于任何 $p$-范数，$\\|V\\|_p = 1$ 且 $\\|V^{-1}\\|_p = 1$。因此，对于所有 $p$，$\\kappa_p(V) = 1 \\times 1 = 1$。这为实现提供了一个简单的健全性检查。\n\n最终的程序将为每个测试用例系统地执行这些步骤，并按规定将输出格式化为单个字符串。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs Vandermonde matrices for specified node sets and computes their\n    1-norm, 2-norm, and infinity-norm condition numbers.\n    \"\"\"\n\n    # test_cases defines the parameters for each problem case.\n    # Each entry is a tuple (n, node_generator_function).\n    test_cases = [\n        # Case 1: n = 8, nodes x_i = i/(n-1) on [0, 1]\n        (8, lambda n: np.arange(n) / (n - 1)),\n        # Case 2: n = 12, nodes x_i = -1 + 2i/(n-1) on [-1, 1]\n        (12, lambda n: -1.0 + 2.0 * np.arange(n) / (n - 1)),\n        # Case 3: n = 10, nodes x_i = 1 - 1e-3 * i, clustered near 1\n        (10, lambda n: 1.0 - 1e-3 * np.arange(n)),\n        # Case 4: n = 16, Chebyshev nodes on [-1, 1]\n        (16, lambda n: np.cos((2 * np.arange(n) + 1) * np.pi / (2 * n))),\n        # Case 5: n = 1, single node x_0 = 0.37\n        (1, lambda n: np.array([0.37]))\n    ]\n\n    all_results = []\n    \n    for n, node_func in test_cases:\n        # Generate the nodes for the current case\n        nodes = node_func(n)\n        \n        # Construct the Vandermonde matrix V with V_ij = x_i^j\n        # np.vander with increasing=True matches this definition.\n        V = np.vander(nodes, increasing=True)\n        \n        # Ensure matrix is of float type for precision\n        V = V.astype(np.float64)\n\n        # Compute the condition numbers for p=1, 2, and infinity\n        kappa_1 = np.linalg.cond(V, 1)\n        kappa_2 = np.linalg.cond(V, 2)\n        kappa_inf = np.linalg.cond(V, np.inf)\n        \n        case_results = [kappa_1, kappa_2, kappa_inf]\n        \n        # Format the results to 6 significant digits in scientific notation\n        # The format specifier '.5e' means 1 digit before and 5 after the decimal point.\n        formatted_results = [f\"{res:.5e}\" for res in case_results]\n        \n        all_results.append(f\"[{','.join(formatted_results)}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2400727"}, {"introduction": "仅仅诊断出问题是不够的，我们还需要有效的策略来求解病态系统。这个练习将展示病态问题如何导致像GMRES（广义最小残差法）这样的迭代求解器收敛停滞，以及一种称为“预条件”的简单技术如何能显著加速收敛。通过对比未使用和使用对角预条件两种情况下GMRES的性能，我们将直观地理解预条件在改善迭代求解效率和鲁棒性方面的强大作用。[@problem_id:2400723]", "problem": "考虑使用广义最小残差方法 (GMRES) 求解形式为 $A x = b$ 的线性系统，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个方阵，$b \\in \\mathbb{R}^{n}$ 是一个向量。设初始猜测为 $x_0 = 0$，阶数为 $k$ 的克雷洛夫子空间 (Krylov subspace) 为 $ \\mathcal{K}_k(A,r_0) = \\mathrm{span}\\{ r_0, A r_0, \\dots, A^{k-1} r_0 \\}$，其中 $r_0 = b - A x_0 = b$。GMRES 的迭代解 $x_k$ 是 $x_0 + \\mathcal{K}_k(A,r_0)$ 中使残差范数 $\\| b - A x \\|_2$ 最小化的向量。定义第 $k$ 次迭代的相对残差为 $\\rho_k = \\| b - A x_k \\|_2 / \\|b\\|_2$。对于给定的容差 $\\tau > 0$ 和迭代次数上限 $K \\in \\mathbb{N}$，将达到的迭代次数定义为满足 $\\rho_k \\le \\tau$ 的最小 $k \\in \\{1,2,\\dots,K\\}$。如果直到 $K$ 次迭代都不存在这样的 $k$，则报告达到的迭代次数为 $-1$，并报告在 $K$ 次迭代时达到的最终 $\\rho_K$。同时考虑使用对角 (Jacobi) 预条件子 $M = \\mathrm{diag}(A)$ 进行左预处理，即用 GMRES 求解 $M^{-1} A x = M^{-1} b$，初始猜测仍为 $x_0 = 0$。类似地定义预处理后的 GMRES 迭代解 $x_k^{(M)}$，以及相对残差 $\\rho_k^{(M)} = \\| b - A x_k^{(M)} \\|_2 / \\|b\\|_2$ 和在相同的 $\\tau$ 和 $K$ 下达到的迭代次数。对于下面的每个问题实例，计算未预处理和预处理情况下达到的迭代次数以及相应的最终相对残差。\n\n测试套件。对于每种情况，完全按照指定构造 $A$ 和 $b$，其中 $b = A x^{\\star}$ 且 $x^{\\star} = \\mathbf{1}$ (适当长度的全1向量)。所有情况下均使用 $x_0 = 0$。\n\n- 情况 A (病态对称正定)：设 $n = 12$，且 $A = H_n$ 为希尔伯特矩阵 (Hilbert matrix)，其元素为 $[H_n]_{i,j} = 1/(i+j-1)$，其中 $i,j \\in \\{1,\\dots,n\\}$。使用容差 $\\tau = 10^{-8}$ 和迭代次数上限 $K = 12$。\n\n- 情况 B (严重缩放、非正规的上三角加对角矩阵)：设 $n = 40$。定义对角矩阵 $D \\in \\mathbb{R}^{n \\times n}$，其元素为 $D_{i,i} = 10^{\\,8 \\cdot (1 - (i-1)/(n-1))}$，其中 $i \\in \\{1,\\dots,n\\}$，并设 $U \\in \\mathbb{R}^{n \\times n}$ 为严格上三角矩阵，其中若 $i < j$ 则 $U_{i,j} = 1$，否则 $U_{i,j} = 0$。设 $A = D + U$。使用容差 $\\tau = 10^{-6}$ 和迭代次数上限 $K = 40$。\n\n- 情况 C (边界健全性，具有少数不同特征值的对角矩阵)：设 $n = 15$。设 $A$ 的对角线元素按顺序循环取三个值 $\\{1, 10^{2}, 10^{4}\\}$，根据需要重复以达到长度 $n$；即 $A = \\mathrm{diag}(1, 10^{2}, 10^{4}, 1, 10^{2}, 10^{4}, \\dots)$，尺寸为 $n \\times n$。使用容差 $\\tau = 10^{-12}$ 和迭代次数上限 $K = 15$。\n\n对于每种情况，您必须输出一个包含四个条目的列表：$[\\kappa_{\\mathrm{un}}, \\kappa_{\\mathrm{pre}}, \\rho_{\\mathrm{un}}, \\rho_{\\mathrm{pre}}]$，其中 $\\kappa_{\\mathrm{un}}$ 是未预处理 GMRES 达到的迭代次数 (如果在 $K$ 次内未达到则为 $-1$)，$\\kappa_{\\mathrm{pre}}$ 是预处理 GMRES 达到的迭代次数 (如果在 $K$ 次内未达到则为 $-1$)，$\\rho_{\\mathrm{un}}$ 是未预处理运行达到的最终相对残差 (如果 $\\kappa_{\\mathrm{un}} \\neq -1$ 则等于 $\\rho_{\\kappa_{\\mathrm{un}}}$，否则等于 $\\rho_K$)，$\\rho_{\\mathrm{pre}}$ 是预处理运行的类似量。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按 A、B、C 三种情况的顺序排列结果。每种情况的结果本身必须是如上所述的方括号括起来的逗号分隔列表。因此，最终输出的形式应为 $[[\\kappa_{\\mathrm{un}}^{(A)}, \\kappa_{\\mathrm{pre}}^{(A)}, \\rho_{\\mathrm{un}}^{(A)}, \\rho_{\\mathrm{pre}}^{(A)}], [\\kappa_{\\mathrm{un}}^{(B)}, \\kappa_{\\mathrm{pre}}^{(B)}, \\rho_{\\mathrm{un}}^{(B)}, \\rho_{\\mathrm{pre}}^{(B)}], [\\kappa_{\\mathrm{un}}^{(C)}, \\kappa_{\\mathrm{pre}}^{(C)}, \\rho_{\\mathrm{un}}^{(C)}, \\rho_{\\mathrm{pre}}^{(C)}]]$，其中每个 $\\rho$ 必须以科学记数法打印为浮点数，至少有三位有效数字，每个 $\\kappa$ 必须为整数。", "solution": "问题按如下方式进行验证。\n\n### 步骤 1：提取给定信息\n- **线性系统**：$A x = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$b \\in \\mathbb{R}^{n}$。\n- **方法**：广义最小残差 (GMRES) 方法。\n- **初始猜测**：$x_0 = 0$。\n- **克雷洛夫子空间**：$\\mathcal{K}_k(A,r_0) = \\mathrm{span}\\{ r_0, A r_0, \\dots, A^{k-1} r_0 \\}$，其中 $r_0 = b - A x_0 = b$。\n- **GMRES 迭代解**：$x_k$ 是 $x_0 + \\mathcal{K}_k(A,r_0)$ 中使 $\\| b - A x \\|_2$ 最小化的向量。\n- **相对残差 (未预处理)**：$\\rho_k = \\| b - A x_k \\|_2 / \\|b\\|_2$。\n- **收敛准则**：找到满足 $\\rho_k \\le \\tau$ 的最小 $k \\in \\{1,2,\\dots,K\\}$。这是“达到的迭代次数”。\n- **失败条件**：如果在迭代上限 $K$ 内不存在这样的 $k$，则达到的迭代次数为 $-1$，最终相对残差为 $\\rho_K$。\n- **预处理**：使用 Jacobi 预条件子 $M = \\mathrm{diag}(A)$ 进行左预处理。求解的系统是 $M^{-1} A x = M^{-1} b$。\n- **预处理迭代解**：$x_k^{(M)}$ 是为预处理系统类似定义的。\n- **相对残差 (预处理)**：$\\rho_k^{(M)} = \\| b - A x_k^{(M)} \\|_2 / \\|b\\|_2$。注意，残差是相对于原始系统而不是预处理系统来度量的。\n- **问题实例**：\n    - **情况 A**：$n = 12$，$A = H_n$ (希尔伯特矩阵, $[H_n]_{i,j} = 1/(i+j-1)$)，容差 $\\tau = 10^{-8}$，迭代上限 $K = 12$。\n    - **情况 B**：$n = 40$，$A = D + U$，其中 $D_{i,i} = 10^{\\,8 \\cdot (1 - (i-1)/(n-1))}$，$U$ 是严格上三角矩阵且元素为1。容差 $\\tau = 10^{-6}$，迭代上限 $K = 40$。\n    - **情况 C**：$n = 15$，$A = \\mathrm{diag}(1, 10^{2}, 10^{4}, 1, \\dots)$。容差 $\\tau = 10^{-12}$，迭代上限 $K = 15$。\n- **右端项**：在所有情况下，$b = A x^{\\star}$，其中 $x^{\\star} = \\mathbf{1}$ (全1向量)。\n- **输出**：对于每种情况，一个列表 $[\\kappa_{\\mathrm{un}}, \\kappa_{\\mathrm{pre}}, \\rho_{\\mathrm{un}}, \\rho_{\\mathrm{pre}}]$。$\\kappa$ 是达到的迭代次数，$\\rho$ 是最终的相对残差。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题基于公认的求解线性系统的 GMRES 方法，这是数值线性代数和计算工程中的一个基本课题。所有矩阵和程序都是标准的。该问题在科学上是合理的。\n- **适定性**：每个测试案例都明确定义了所有必要参数 ($A, b, x_0, \\tau, K$)。GMRES 的定义及其收敛准则是标准的，确保了所请求的输出存在唯一且有意义的解。\n- **客观性**：问题陈述精确、量化，且无主观语言。定义是数学的、无歧义的。\n- **其他标准**：该问题不违反任何其他验证标准。它是一个完整、一致且可形式化的计算任务。\n\n### 步骤 3：结论与行动\n问题有效。将提供一个解决方案。\n\n广义最小残差 (GMRES) 方法是一种求解线性方程组 $Ax=b$ 的迭代算法。它对非对称矩阵 $A$ 特别有效。GMRES 的核心原理是在第 $k$ 次迭代时，从仿射子空间 $x_0 + \\mathcal{K}_k(A, r_0)$ 中找到一个近似解 $x_k$，该解能最小化残差的欧几里得范数 $\\|r_k\\|_2 = \\|b-Ax_k\\|_2$。这里，$x_0$ 是一个初始猜测，$\\mathcal{K}_k(A, r_0)$ 是由 $A$ 和初始残差 $r_0 = b-Ax_0$ 生成的 $k$ 阶克雷洛夫子空间。\n\n最小化是在一个不断扩大的子空间上进行的。GMRES 的一个关键组成部分是 Arnoldi 迭代，它为克雷洛夫子空间 $\\mathcal{K}_{k+1}(A, r_0)$ 生成一个标准正交基 $V_{k+1} = [v_1, v_2, \\dots, v_{k+1}]$。第一个向量是 $v_1 = r_0 / \\|r_0\\|_2$。Arnoldi 过程产生矩阵关系 $AV_k = V_{k+1}\\tilde{H}_k$，其中 $\\tilde{H}_k$ 是一个 $(k+1) \\times k$ 的上海森堡矩阵 (upper Hessenberg matrix)。\n\n迭代解 $x_k$ 可以写成 $x_k = x_0 + z_k$，其中 $z_k \\in \\mathcal{K}_k(A, r_0)$。由于 $V_k$ 是 $\\mathcal{K}_k(A, r_0)$ 的一个基，我们可以将 $z_k$ 写成 $z_k = V_k y$，其中 $y \\in \\mathbb{R}^k$ 是某个向量。最小化问题变为：\n$$ \\min_{y \\in \\mathbb{R}^k} \\| b - A(x_0 + V_k y) \\|_2 = \\min_{y \\in \\mathbb{R}^k} \\| r_0 - AV_k y \\|_2 $$\n使用 $r_0 = \\|r_0\\|_2 v_1 = \\beta v_1$ 和 Arnoldi 关系，我们代入得到：\n$$ \\min_{y \\in \\mathbb{R}^k} \\| \\beta v_1 - V_{k+1} \\tilde{H}_k y \\|_2 $$\n由于 $V_{k+1}$ 的列是标准正交的，这等价于求解一个小的最小二乘问题：\n$$ \\min_{y \\in \\mathbb{R}^k} \\| \\beta e_1 - \\tilde{H}_k y \\|_2 $$\n其中 $e_1$ 是 $\\mathbb{R}^{k+1}$ 中的第一个标准基向量。这个子问题可以高效求解，例如，使用 $\\tilde{H}_k$ 的 QR 分解。一旦找到 $y$，解就是 $x_k = x_0 + V_k y$。\n\n对于预处理的情况，我们求解左预处理系统 $M^{-1}Ax = M^{-1}b$，其中 $M = \\mathrm{diag}(A)$ 是 Jacobi 预条件子。GMRES 应用于算子 $A' = M^{-1}A$ 和右端项 $b' = M^{-1}b$。克雷洛夫子空间现在是 $\\mathcal{K}_k(M^{-1}A, M^{-1}r_0)$。该算法最小化预处理残差的范数，即 $\\|r'_k\\|_2 = \\|M^{-1}(b-Ax_k)\\|_2$。\n\n问题陈述中的一个关键细节是，预处理情况下的收敛准则是基于**真实**相对残差 $\\rho_k^{(M)} = \\|b - Ax_k^{(M)}\\|_2 / \\|b\\|_2$，而不是预处理后的残差。这要求在每一步显式计算迭代解 $x_k^{(M)}$ 和真实残差来检查收敛性，而不是使用计算成本更低的来自最小二乘子问题的残差范数。\n\n实现将遵循此逻辑。对于从 $1$ 到 $K$ 的每次迭代 $k$，我们将：\n1.  扩展 Arnoldi 分解以获得 $V_{k+1}$ 和 $\\tilde{H}_k$。\n2.  求解 $(k+1) \\times k$ 的最小二乘问题以获得 $y$。\n3.  构造解 $x_k = x_0 + V_k y$。\n4.  计算真实相对残差 $\\|b - Ax_k\\|_2 / \\|b\\|_2$。\n5.  如果残差低于容差 $\\tau$，我们记录迭代次数 $k$ 和最终残差，然后终止。\n6.  如果循环完成而未收敛，我们记录迭代次数为 $-1$，并记录在第 $K$ 次迭代时的残差。\n\n这三个测试案例探讨了病态的不同来源：\n- **情况 A**：希尔伯特矩阵，由于其列向量几乎共线而具有内禀的病态性。其条件数随尺寸呈指数级增长。\n- **情况 B**：一个严重缩放的矩阵。对角线元素跨越多个数量级。Jacobi 预处理正是为通过缩放系统行来解决此问题而设计的。\n- **情况 C**：一个具有少量不同特征值的对角矩阵。对于这样的矩阵，GMRES 保证在等于 $A$ 相对于 $r_0$ 的最小多项式次数的迭代次数内找到精确解，这个次数最多为不同特征值的数量。用 $M=A$ 进行预处理，系统算子变为单位矩阵，GMRES 将在单次迭代中收敛。", "answer": "```python\nimport numpy as np\n\ndef run_gmres(A, b, x0, tol, maxiter, M=None):\n    \"\"\"\n    Custom implementation of the Generalized Minimal Residual (GMRES) method.\n\n    This implementation solves the least-squares problem at each iteration to \n    compute the current iterate x_k and its true residual, as required by the\n    problem statement for both preconditioned and unpreconditioned cases.\n\n    Args:\n        A (np.ndarray): The square matrix of the linear system Ax=b.\n        b (np.ndarray): The right-hand side vector.\n        x0 (np.ndarray): The initial guess for the solution.\n        tol (float): The convergence tolerance for the relative residual.\n        maxiter (int): The maximum number of iterations.\n        M (np.ndarray, optional): The preconditioner matrix. If provided,\n                                  the left-preconditioned system is solved.\n\n    Returns:\n        tuple[int, float]: A tuple containing:\n            - The number of iterations to convergence, or -1 if not converged.\n            - The final relative residual.\n    \"\"\"\n    n = A.shape[0]\n    is_preconditioned = M is not None\n    norm_b = np.linalg.norm(b)\n    if norm_b == 0:\n        return 0, 0.0\n\n    initial_r = b - A @ x0\n    \n    if is_preconditioned:\n        # For M^{-1}Ax = M^{-1}b, the initial residual for Arnoldi is M^{-1}r_0\n        # M is diagonal so we can do element-wise division.\n        r0_precond = initial_r / np.diag(M)\n        beta = np.linalg.norm(r0_precond)\n        v1 = r0_precond / beta\n    else:\n        beta = np.linalg.norm(initial_r)\n        v1 = initial_r / beta\n\n    V = np.zeros((n, maxiter + 1), dtype=np.float64)\n    V[:, 0] = v1\n    H = np.zeros((maxiter + 1, maxiter), dtype=np.float64)\n    \n    e1 = np.zeros(maxiter + 1)\n    e1[0] = 1.0\n\n    final_rel_res = np.linalg.norm(initial_r) / norm_b\n\n    for k in range(maxiter):\n        # Arnoldi iteration step\n        if is_preconditioned:\n            w = A @ V[:, k]\n            # Apply preconditioner M^{-1}\n            w_precond = w / np.diag(M)\n        else:\n            w_precond = A @ V[:, k]\n        \n        # Modified Gram-Schmidt\n        for j in range(k + 1):\n            H[j, k] = np.dot(w_precond, V[:, j])\n            w_precond -= H[j, k] * V[:, j]\n            \n        H[k + 1, k] = np.linalg.norm(w_precond)\n        \n        # Form and solve the least-squares subproblem: min ||beta*e1 - H_k*y||\n        H_k = H[:k+2, :k+1]\n        rhs = beta * e1[:k+2]\n        \n        # Solve for y_k\n        y, _, _, _ = np.linalg.lstsq(H_k, rhs, rcond=None)\n        \n        # Compute the corresponding solution x_k\n        x_k = x0 + V[:, :k+1] @ y\n        \n        # Compute the true relative residual and check for convergence\n        true_res_norm = np.linalg.norm(b - A @ x_k)\n        rel_res = true_res_norm / norm_b\n        final_rel_res = rel_res\n        \n        if rel_res = tol:\n            return k + 1, rel_res\n            \n        # Check for breakdown (Arnoldi process terminates)\n        if H[k + 1, k]  1e-15:\n            return k + 1, rel_res\n        \n        # Normalize to get the next basis vector for the Krylov subspace\n        V[:, k + 1] = w_precond / H[k + 1, k]\n\n    # If the loop finishes, tolerance was not met within maxiter\n    return -1, final_rel_res\n\n\ndef solve():\n    \"\"\"\n    Main function to define, solve, and report results for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case A: Hilbert matrix\n        {'n': 12, 'tau': 1e-8, 'K': 12},\n        # Case B: Badly scaled non-normal matrix\n        {'n': 40, 'tau': 1e-6, 'K': 40},\n        # Case C: Diagonal matrix\n        {'n': 15, 'tau': 1e-12, 'K': 15},\n    ]\n\n    all_results = []\n\n    # --- Case A ---\n    params_A = test_cases[0]\n    n_A = params_A['n']\n    A_A = np.zeros((n_A, n_A), dtype=np.float64)\n    # Hilbert matrix indices are 1-based in the problem, but 0-based in Python\n    for i in range(n_A):\n        for j in range(n_A):\n            A_A[i, j] = 1.0 / (i + j + 1)\n    x_star_A = np.ones(n_A)\n    b_A = A_A @ x_star_A\n    x0_A = np.zeros(n_A)\n    M_A = np.diag(np.diag(A_A))\n    \n    k_un_A, r_un_A = run_gmres(A_A, b_A, x0_A, params_A['tau'], params_A['K'])\n    k_pre_A, r_pre_A = run_gmres(A_A, b_A, x0_A, params_A['tau'], params_A['K'], M=M_A)\n    all_results.append([k_un_A, k_pre_A, f\"{r_un_A:.3e}\", f\"{r_pre_A:.3e}\"])\n\n    # --- Case B ---\n    params_B = test_cases[1]\n    n_B = params_B['n']\n    # Python indices are 0 to n-1, matches problem's i-1\n    diag_entries_B = 10.0**(8.0 * (1.0 - np.arange(n_B) / (n_B - 1)))\n    D_B = np.diag(diag_entries_B)\n    U_B = np.triu(np.ones((n_B, n_B)), k=1)\n    A_B = D_B + U_B\n    x_star_B = np.ones(n_B)\n    b_B = A_B @ x_star_B\n    x0_B = np.zeros(n_B)\n    M_B = D_B\n\n    k_un_B, r_un_B = run_gmres(A_B, b_B, x0_B, params_B['tau'], params_B['K'])\n    k_pre_B, r_pre_B = run_gmres(A_B, b_B, x0_B, params_B['tau'], params_B['K'], M=M_B)\n    all_results.append([k_un_B, k_pre_B, f\"{r_un_B:.3e}\", f\"{r_pre_B:.3e}\"])\n\n    # --- Case C ---\n    params_C = test_cases[2]\n    n_C = params_C['n']\n    diag_vals = np.array([1, 1e2, 1e4])\n    diag_entries_C = np.array([diag_vals[i % 3] for i in range(n_C)])\n    A_C = np.diag(diag_entries_C)\n    x_star_C = np.ones(n_C)\n    b_C = A_C @ x_star_C\n    x0_C = np.zeros(n_C)\n    M_C = A_C\n    \n    k_un_C, r_un_C = run_gmres(A_C, b_C, x0_C, params_C['tau'], params_C['K'])\n    k_pre_C, r_pre_C = run_gmres(A_C, b_C, x0_C, params_C['tau'], params_C['K'], M=M_C)\n    all_results.append([k_un_C, k_pre_C, f\"{r_un_C:.3e}\", f\"{r_pre_C:.3e}\"])\n\n    # Format the final output string\n    result_str = \",\".join(\n        f\"[{','.join(map(str, case_res))}]\" for case_res in all_results\n    )\n    print(f\"[{result_str}]\")\n\nsolve()\n\n```", "id": "2400723"}]}