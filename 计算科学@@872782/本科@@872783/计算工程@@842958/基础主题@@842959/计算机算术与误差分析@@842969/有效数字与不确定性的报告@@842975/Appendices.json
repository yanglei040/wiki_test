{"hands_on_practices": [{"introduction": "在科学与工程计算中，有效数字的规则并非凭空而来，而是与测量的不确定性紧密相连。这个练习将通过一个简单的温度转换任务，向你展示如何正确地传递不确定性，并以此为依据来决定最终结果的有效数字位数。掌握这一基本原则是确保我们的计算结果忠实反映物理现实的第一步[@problem_id:2952336]。", "problem": "一台以摄氏温标校准的定容温度计，报告一个与充分搅拌的恒温浴处于平衡状态的液体样品的温度为 $25.0 \\pm 0.2\\,^{\\circ}\\mathrm{C}$。利用1开尔文的大小与1摄氏度的大小完全相等，以及开尔文温标和摄氏温标之间相差一个精确的偏移量这一事实，将此测量值转换为开尔文温标，并正确地传递其绝对不确定度。然后，通过遵循带有不确定度的测量量的有效数字的基本定义，以及加上一个常数时不确定度的传递规则，确定报告的开尔文值中应保留多少位有效数字。将引用的 $\\pm 0.2$ 解释为已经过适当舍入的绝对对称不确定度，不要再次对其进行舍入。\n\n只报告根据您的不确定度分析确定有效数字位数并进行舍入后的开尔文中心值。以 $\\mathrm{K}$ 为单位，将您的最终答案表示为一个数字。您的舍入必须由不确定度（并因此由有效数字）来证明其合理性，而不是由固定的十进制小数位数规则决定。", "solution": "该问题要求将一个温度测量值从摄氏温标转换为开尔文温标，并伴随严格的不确定度传递计算，以及确定最终结果的适当有效数字位数。\n\n初始测量值以摄氏度为单位给出，记为 $T_C$，其相关联的绝对不确定度为 $\\delta T_C$。\n$$T_C = 25.0 \\,^{\\circ}\\mathrm{C}$$\n$$\\delta T_C = 0.2 \\,^{\\circ}\\mathrm{C}$$\n\n开尔文温标 ($T_K$) 和摄氏温标 ($T_C$) 之间的关系由一个精确的加法偏移量定义。1开尔文的大小与1摄氏度的大小相同。转换公式为：\n$$T_K = T_C + 273.15$$\n在此定义中，$273.15$ 是一个精确常数，意味着它的不确定度为零（$\\delta(273.15) = 0$）。\n\n首先，我们转换温度的中心值：\n$$T_K = 25.0 + 273.15 = 298.15 \\, \\mathrm{K}$$\n\n接下来，我们必须传递不确定度。对于函数 $Z = f(X, Y, \\dots)$，不确定度传递的通用公式（假设变量独立）由每个变量贡献的平方和给出：\n$$(\\delta Z)^2 = \\left(\\frac{\\partial f}{\\partial X}\\right)^2 (\\delta X)^2 + \\left(\\frac{\\partial f}{\\partial Y}\\right)^2 (\\delta Y)^2 + \\dots$$\n在我们的例子中，函数是 $T_K = T_C + K_0$，其中 $K_0 = 273.15$ 是一个常数。唯一具有不确定度的变量是 $T_C$。$K_0$ 的不确定度为零，即 $\\delta K_0 = 0$。\n因此，开尔文温度的传递不确定度 $\\delta T_K$ 为：\n$$(\\delta T_K)^2 = \\left(\\frac{\\partial T_K}{\\partial T_C}\\right)^2 (\\delta T_C)^2 + \\left(\\frac{\\partial T_K}{\\partial K_0}\\right)^2 (\\delta K_0)^2$$\n偏导数为：\n$$\\frac{\\partial T_K}{\\partial T_C} = \\frac{\\partial}{\\partial T_C}(T_C + K_0) = 1$$\n$$\\frac{\\partial T_K}{\\partial K_0} = \\frac{\\partial}{\\partial K_0}(T_C + K_0) = 1$$\n将这些代入不确定度公式：\n$$(\\delta T_K)^2 = (1)^2 (\\delta T_C)^2 + (1)^2 (0)^2 = (\\delta T_C)^2$$\n因此，开尔文温度的绝对不确定度与摄氏温度的绝对不确定度相同：\n$$\\delta T_K = \\delta T_C = 0.2 \\, \\mathrm{K}$$\n\n在考虑有效数字的约定之前，开尔文温度的完整结果是：\n$$T_K = 298.15 \\pm 0.2 \\, \\mathrm{K}$$\n\n报告测量量的基本原则是，中心值的最后一位有效数字应与其不确定度的最高有效位处于相同的小数位。这确保了值的表述精度与其计算或测量的不确定度相一致。\n\n在我们的结果中，不确定度 $\\delta T_K = 0.2 \\, \\mathrm{K}$ 的最高有效（也是唯一）数字在十分位上。因此，温度的中心值必须四舍五入到十分位。\n\n计算出的中心值是 $298.15 \\, \\mathrm{K}$。将此值四舍五入到十分位，得到：\n$$298.15 \\rightarrow 298.2$$\n包含不确定度的最终报告结果应为 $T_K = 298.2 \\pm 0.2 \\, \\mathrm{K}$。中心值 $298.2$ 有四位有效数字。这个有效数字位数之所以合理，不是通过计算输入数据中的位数得出的，而是通过正确的不确定度传递得出的。\n\n问题要求给出根据此分析确定有效数字位数并进行舍入后的开尔文中心值。该值为 $298.2$。", "answer": "$$\\boxed{298.2}$$", "id": "2952336"}, {"introduction": "在从测量不确定性转向计算误差的来源后，我们来探讨一个常见的陷阱：“灾难性相消”（catastrophic cancellation）。当两个几乎相等的数相减时，这个现象会严重损害计算精度。这个动手实践 [@problem_id:2432439] 让你亲身体验一个看似正确的公式如何在实际中失效，以及更重要的，如何通过几何重构问题来设计出一个数值稳定的算法。", "problem": "一个平面成像测量仪用于检查一个加工零件上两个几乎相切的圆孔之间的微小重叠（“薄片”）。这些孔被建模为半径为 $R_1$ 和 $R_2$ 的圆，其圆心相距为 $d$。测量值和一倍标准差的标准不确定度如下：\n- $R_1 = 50.000 \\ \\mathrm{mm}$，其 $u_{R_1} = 0.001 \\ \\mathrm{mm}$，\n- $R_2 = 80.000 \\ \\mathrm{mm}$，其 $u_{R_2} = 0.001 \\ \\mathrm{mm}$，\n- $d = 129.950 \\ \\mathrm{mm}$，其 $u_{d} = 0.001 \\ \\mathrm{mm}$。\n\n微小的重叠区域（一个透镜状的薄片）是两个圆盘的交集。你需要计算其面积两次：\n1) 从平面几何的第一性原理出发：将每个弓形的面积写成（扇形面积）减去（等腰三角形面积），用几何构型表示扇形角，然后将两个弓形的面积相加得到精确的透镜面积。所有三角函数均使用弧度制。\n2) 通过重新表述几何关系以避免小重叠情况下的灾难性抵消：用弓高 $h$ 对每个弓形进行参数化，并从微小角度展开开始，推导出以 $R$ 和 $h$ 表示的弓形面积的主阶稳定表达式。对两个圆计算此稳定近似值并求和。\n\n然后，使用一个适用于小重叠的、经过适当简化且具有物理合理性的近似公式，通过偏导数将 $R_1$、$R_2$ 和 $d$ 的不确定度进行一阶（线性）传播，计算透镜面积的不确定度。\n\n根据你的不确定度估计，为报告面积选择适当数量的有效数字。在本问题中，将最终报告的面积四舍五入到两位有效数字。最终面积以 $\\mathrm{mm}^2$ 表示。\n\n你的最终数值答案必须是一个实数。不要在最终的方框值中包含单位。始终使用弧度制。", "solution": "任务是计算半径为 $R_1$ 和 $R_2$、圆心距为 $d$ 的两个圆的相交面积（透镜），首先使用精确几何方法，然后使用针对小重叠情况的数值稳定近似方法。最后，我们传播测量不确定度并设定适当的有效数字。\n\n基本几何基础：\n- 半径为 $R$、中心角为 $2\\theta$（以弧度为单位）的扇形面积是 $R^2 \\theta$。\n- 边长为 $R$、$R$、夹角为 $2\\theta$ 的相关等腰三角形的面积是 $\\tfrac{1}{2} R^2 \\sin(2\\theta)$。\n- 因此，从半径为 $R$ 的圆上由一个对向角为 $2\\theta$ 的弦切出的弓形面积是 $R^2\\left(\\theta - \\sin\\theta \\cos\\theta\\right)$，因为 $\\sin\\theta \\cos\\theta = \\tfrac{1}{2}\\sin(2\\theta)$。\n- 根据在由两个圆心和任一交点组成的三角形中应用余弦定理，与透镜的两个弓形相对应的中心半角 $\\theta_1$ 和 $\\theta_2$ 满足：\n$$\n\\cos\\theta_1 = \\frac{d^2 + R_1^2 - R_2^2}{2 d R_1}, \\qquad\n\\cos\\theta_2 = \\frac{d^2 + R_2^2 - R_1^2}{2 d R_2}.\n$$\n\n精确计算（标准公式，在小重叠时易出现抵消误差）：\n- 给定 $R_1 = 50.000 \\ \\mathrm{mm}$、$R_2 = 80.000 \\ \\mathrm{mm}$、$d = 129.950 \\ \\mathrm{mm}$，计算\n$$\nd^2 = (129.950)^2 = 16887.0025 \\ \\mathrm{mm}^2.\n$$\n则\n$$\n\\cos\\theta_1 = \\frac{16887.0025 + 50.000^2 - 80.000^2}{2\\cdot 129.950 \\cdot 50.000}\n= \\frac{16887.0025 + 2500 - 6400}{12995}\n= \\frac{12987.0025}{12995} \\approx 0.9993843,\n$$\n$$\n\\cos\\theta_2 = \\frac{16887.0025 + 80.000^2 - 50.000^2}{2\\cdot 129.950 \\cdot 80.000}\n= \\frac{16887.0025 + 6400 - 2500}{20792}\n= \\frac{20787.0025}{20792} \\approx 0.9997600.\n$$\n因此\n$$\n\\theta_1 \\approx \\arccos(0.9993843) \\approx 0.03509 \\ \\text{rad}, \\qquad\n\\theta_2 \\approx \\arccos(0.9997600) \\approx 0.02192 \\ \\text{rad}.\n$$\n两个弓形的面积是\n$$\nA_1^{\\mathrm{exact}} = R_1^2\\left(\\theta_1 - \\sin\\theta_1 \\cos\\theta_1\\right), \\qquad\nA_2^{\\mathrm{exact}} = R_2^2\\left(\\theta_2 - \\sin\\theta_2 \\cos\\theta_2\\right),\n$$\n透镜的总面积为 $A^{\\mathrm{exact}} = A_1^{\\mathrm{exact}} + A_2^{\\mathrm{exact}}$。\n\n在数值上，对于每个弓形，中间的扇形和三角形项都很大且几乎相等：\n- 对于第一个圆，$R_1^2 \\theta_1 \\approx 2500 \\times 0.03509 \\approx 87.7 \\ \\mathrm{mm}^2$，而 $R_1^2 \\sin\\theta_1 \\cos\\theta_1 \\approx 2500 \\times \\tfrac{1}{2}\\sin(2\\theta_1) \\approx 87.6 \\ \\mathrm{mm}^2$。它们的差仅约为 $\\approx 0.072 \\ \\mathrm{mm}^2$。\n- 对于第二个圆，$R_2^2 \\theta_2 \\approx 6400 \\times 0.02192 \\approx 140.3 \\ \\mathrm{mm}^2$，而 $R_2^2 \\sin\\theta_2 \\cos\\theta_2 \\approx 6400 \\times \\tfrac{1}{2}\\sin(2\\theta_2) \\approx 140.2 \\ \\mathrm{mm}^2$。它们的差仅约为 $\\approx 0.045 \\ \\mathrm{mm}^2$。\n\n两个相近大数相减在数值上是病态的，容易导致有效数字的损失（相减抵消），尤其是在重叠非常小的时候。组合的精确值（如果用足够高的精度计算）是\n$$\nA^{\\mathrm{exact}} \\approx 0.11695 \\ \\mathrm{mm}^2,\n$$\n但如果直接计算，此路径对舍入误差很敏感。\n\n针对小重叠的稳定几何重构：\n引入两个弓形的弓高 $h_1$ 和 $h_2$。设 $x_1$ 是从圆1的圆心沿圆心连线到公共弦的距离。根据几何关系，\n$$\nx_1 = \\frac{d^2 + R_1^2 - R_2^2}{2d}, \\qquad h_1 = R_1 - x_1,\n$$\n类似地，$x_2 = d - x_1$，$h_2 = R_2 - x_2$。代入给定数值，\n$$\nx_1 = \\frac{16887.0025 + 2500 - 6400}{2\\cdot 129.950} = \\frac{12987.0025}{259.9} \\approx 49.96923 \\ \\mathrm{mm},\n$$\n$$\nh_1 = 50.000 - 49.96923 \\approx 0.030771 \\ \\mathrm{mm}, \\quad\nx_2 = 129.950 - 49.96923 \\approx 79.98077 \\ \\mathrm{mm}, \\quad\nh_2 = 80.000 - 79.98077 \\approx 0.019229 \\ \\mathrm{mm}.\n$$\n对于半径为 $R$、弓高为 $h$ 的一个非常小的弓形，从精确的弓形面积公式 $R^2\\left(\\theta - \\sin\\theta \\cos\\theta\\right)$ 出发，其中 $\\cos\\theta = (R-h)/R$，并对小 $\\theta$ 进行展开：\n$$\n\\sin\\theta \\cos\\theta = \\tfrac{1}{2}\\sin(2\\theta) = \\theta - \\frac{2}{3}\\theta^3 + O(\\theta^5),\n$$\n所以\n$$\n\\theta - \\sin\\theta \\cos\\theta = \\frac{2}{3}\\theta^3 + O(\\theta^5).\n$$\n由于 $h = R(1 - \\cos\\theta) = \\tfrac{1}{2}R \\theta^2 + O(\\theta^4)$，主阶关系 $\\theta \\approx \\sqrt{2h/R}$ 产生稳定的主阶弓形面积\n$$\nA_{\\mathrm{seg}}(R,h) \\approx \\frac{4}{3} \\sqrt{2R} \\, h^{3/2}.\n$$\n对每个圆进行计算：\n$$\nA_1^{\\mathrm{stab}} \\approx \\frac{4}{3}\\sqrt{2\\cdot 50.000}\\,(0.030771)^{3/2}\n= \\frac{40}{3}\\,(0.030771)^{3/2} \\approx 0.07198 \\ \\mathrm{mm}^2,\n$$\n$$\nA_2^{\\mathrm{stab}} \\approx \\frac{4}{3}\\sqrt{2\\cdot 80.000}\\,(0.019229)^{3/2}\n\\approx 16.86548 \\times (0.019229)^{3/2} \\approx 0.04497 \\ \\mathrm{mm}^2.\n$$\n求和，\n$$\nA^{\\mathrm{stab}} = A_1^{\\mathrm{stab}} + A_2^{\\mathrm{stab}} \\approx 0.11695 \\ \\mathrm{mm}^2.\n$$\n小角度展开中被忽略的主项是 $O(\\theta^5)$，在此处产生的相对误差约为 $0.1 \\%$ 或更小，与接下来要估计的测量不确定度相比可以忽略不计。\n\n不确定度传播和有效数字：\n对于几乎相切的圆，方便的做法是用重叠深度 $\\epsilon = R_1 + R_2 - d$ 和半径和 $S = R_1 + R_2$ 将稳定近似重写为紧凑形式。使用 $h_1 \\approx \\epsilon \\, R_2/S$ 和 $h_2 \\approx \\epsilon \\, R_1/S$（在 $\\epsilon/S$ 的一阶上是精确的），总和在代数上简化为\n$$\nA \\approx \\frac{4}{3} \\sqrt{\\frac{2 R_1 R_2}{S}} \\, \\epsilon^{3/2}, \\quad \\text{其中} \\quad \\epsilon = R_1 + R_2 - d, \\ S = R_1 + R_2.\n$$\n为了进行不确定度传播，将 $R_1$、$R_2$ 和 $d$ 视为独立的。使用 $A(R_1,R_2,d)$ 的偏导数进行一阶（线性）传播，\n$$\n\\frac{\\partial A}{\\partial d} = -\\frac{3}{2}\\frac{A}{\\epsilon}, \\quad\n\\frac{\\partial A}{\\partial R_1} = A\\left[\\frac{1}{2}\\left(\\frac{1}{R_1} - \\frac{1}{S}\\right) + \\frac{3}{2}\\frac{1}{\\epsilon}\\right], \\quad\n\\frac{\\partial A}{\\partial R_2} = A\\left[\\frac{1}{2}\\left(\\frac{1}{R_2} - \\frac{1}{S}\\right) + \\frac{3}{2}\\frac{1}{\\epsilon}\\right].\n$$\n当 $R_1 = 50.000 \\ \\mathrm{mm}$、$R_2 = 80.000 \\ \\mathrm{mm}$、$S = 130.000 \\ \\mathrm{mm}$、$\\epsilon = 0.050 \\ \\mathrm{mm}$ 且 $A \\approx 0.11695 \\ \\mathrm{mm}^2$ 时，\n$$\n\\left|\\frac{\\partial A}{\\partial d}\\right| \\approx \\frac{3}{2}\\frac{0.11695}{0.050} \\approx 3.5085 \\ \\mathrm{mm},\n$$\n$$\n\\left|\\frac{\\partial A}{\\partial R_1}\\right| \\approx 0.11695\\left[ \\frac{1}{2}\\left(\\frac{1}{50} - \\frac{1}{130}\\right) + \\frac{3}{2}\\frac{1}{0.050} \\right] \\approx 3.509 \\ \\mathrm{mm},\n$$\n$$\n\\left|\\frac{\\partial A}{\\partial R_2}\\right| \\approx 0.11695\\left[ \\frac{1}{2}\\left(\\frac{1}{80} - \\frac{1}{130}\\right) + \\frac{3}{2}\\frac{1}{0.050} \\right] \\approx 3.509 \\ \\mathrm{mm}.\n$$\n当 $u_{R_1} = u_{R_2} = u_d = 0.001 \\ \\mathrm{mm}$ 时，组合标准不确定度为\n$$\nu_A \\approx \\sqrt{\\left(\\frac{\\partial A}{\\partial R_1}u_{R_1}\\right)^2 + \\left(\\frac{\\partial A}{\\partial R_2}u_{R_2}\\right)^2 + \\left(\\frac{\\partial A}{\\partial d}u_d\\right)^2}\n\\approx \\sqrt{(0.003509)^2 + (0.003509)^2 + (0.003509)^2}\n\\approx 0.00608 \\ \\mathrm{mm}^2.\n$$\n相对标准不确定度为 $u_A/A \\approx 0.00608/0.11695 \\approx 0.052 \\ (\\text{约 } 5.2\\%)$，这支持将面积报告为大约两位有效数字。\n\n因此，采用数值稳定的值，并根据问题说明将最终面积四舍五入到两位有效数字，即可得到报告的面积。\n\n最终数值（按要求在方框中不含单位）：以 $\\mathrm{mm}^2$ 表示时为 $0.12$。", "answer": "$$\\boxed{0.12}$$", "id": "2432439"}, {"introduction": "现在，我们将视野从单一计算扩展到整个方程组。某些问题本质上是“病态的”（ill-conditioned），这意味着即使是输入数据中极小的误差（包括不可避免的浮点表示误差），也会在输出结果中被极大地放大。这个练习 [@problem_id:2432471] 使用臭名昭著的希尔伯特矩阵（Hilbert matrix），让你从定量的角度直观地看到病态问题是如何摧毁数值解的可靠性的。对于任何依赖计算求解器的人来说，这都是至关重要的一课。", "problem": "一位工程师需要评估一个具有病态系数矩阵的线性系统的数值解中有多少位有效数字是可信的。考虑一个 $n$ 阶 Hilbert 矩阵，其定义为 $H \\in \\mathbb{R}^{n \\times n}$，矩阵元素为 $H_{i,j} = \\dfrac{1}{i + j - 1}$，$1 \\leq i,j \\leq n$。当 $n = 8$ 时，设精确解为 $x^{\\mathrm{true}} \\in \\mathbb{R}^{8}$，其所有分量 $x^{\\mathrm{true}}_i = 1$，并定义 $b = H x^{\\mathrm{true}}$。在所有计算中，假设采用由 Institute of Electrical and Electronics Engineers (IEEE) $754$ binary64 格式定义的标准双精度浮点运算。\n\n定义计算解 $\\hat{x}$ 相对于精确解 $x^{\\mathrm{true}}$ 的正确有效数字位数 $s$ 为\n$$\ns = \\max\\left(0,\\; -\\log_{10}\\left(\\frac{\\lVert \\hat{x} - x^{\\mathrm{true}} \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2}\\right)\\right).\n$$\n\n您的任务是编写一个完整的程序，针对以下四个测试用例，通过求解 $H \\hat{x} = \\tilde{b}$ 计算出 $\\hat{x}$，然后报告每种情况下的 $s$ 值：\n\n- 测试用例 1（基准）：$\\tilde{b} = b$。\n- 测试用例 2（舍入右端项）：$\\tilde{b}$ 是通过将 $b$ 的每个分量舍入到 $k = 8$ 位有效十进制数字得到的。\n- 测试用例 3（更严格的舍入）：$\\tilde{b}$ 是通过将 $b$ 的每个分量舍入到 $k = 6$ 位有效十进制数字得到的。\n- 测试用例 4（确定性分量级相对扰动）：$\\tilde{b}$ 按分量定义为 $\\tilde{b}_i = b_i + \\delta b_i$，其中 $\\delta b_i = 10^{-12} \\cdot (-1)^i \\cdot |b_i|$，$i = 1,2,\\dots,8$。\n\n要求与约定：\n- 根据其定义 $H_{i,j} = \\dfrac{1}{i + j - 1}$ 构建 $n=8$ 的矩阵 $H$。\n- 使用所有分量均为 $1$ 的 $x^{\\mathrm{true}}$，因此 $b = H x^{\\mathrm{true}}$ 可由 $H$ 和 $x^{\\mathrm{true}}$ 精确确定。\n- 对于实数 $y \\neq 0$，将舍入到 $k$ 位有效数字的操作实现为将 $y$ 舍入到具有 $k$ 位有效数字的最近小数，并将 $0$ 映为 $0$。\n- 使用欧几里得范数 $\\lVert \\cdot \\rVert_2$ 根据上述公式计算 $s$。\n\n测试套件与输出规范：\n- 四个测试用例的定义与上文完全一致，并且必须按 $1,2,3,4$ 的顺序进行评估。\n- 对于每个测试用例，将 $s$ 计算为浮点数。\n- 您的程序应生成单行输出，其中包含一个 Python 风格的列表，内含四个 $s$ 值，这些值需四舍五入到 3 位小数，并按照与测试用例 1 到 4 对应的顺序排列为 $[s_1,s_2,s_3,s_4]$。\n- 不涉及物理单位。不出现角度。不使用百分比；所有量均为实数。\n\n您的最终程序必须是自包含的，无需任何输入。它必须按指定格式精确输出一行。", "solution": "所提出的问题是数值线性代数中一个有效且适定的练习，专门探讨病态性对线性系统解精度的影响。它具有科学依据，没有歧义，并为获得唯一的计算解提供了所有必要信息。该问题要求分析线性系统 $H\\hat{x} = \\tilde{b}$ 右端向量的扰动如何影响解 $\\hat{x}$，其中 $H$ 是以病态闻名的 Hilbert 矩阵。这是数值不稳定性的一个经典演示，而数值不稳定性是计算工程中的一个关键概念。\n\n问题的核心在于系数矩阵的性质。阶数为 $n$、元素为 $H_{ij} = (i+j-1)^{-1}$ 的 Hilbert 矩阵是一个对称正定矩阵。然而，其条件数 $\\kappa(H) = \\lVert H \\rVert \\lVert H^{-1} \\rVert$ 随阶数 $n$ 的增长而急剧增大。对于指定的阶数 $n=8$，相对于欧几里得范数的条件数 $\\kappa_2(H_8)$ 约为 $1.5 \\times 10^{10}$。\n\n线性系统扰动理论中的一个基本结果指出，对于右端向量 $b$ 的扰动 $\\delta b$，解 $x$ 中产生的相对误差有如下界限：\n$$\n\\frac{\\lVert \\delta x \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2} \\leq \\kappa_2(H) \\frac{\\lVert \\delta b \\rVert_2}{\\lVert b \\rVert_2}\n$$\n其中 $\\delta x = \\hat{x} - x^{\\mathrm{true}}$ 且 $\\delta b = \\tilde{b} - b$。此不等式表明，条件数充当了输入数据相对误差的放大因子。标准双精度（binary64）运算提供大约 $15$ 到 $17$ 位的十进制精度。当条件数约为 $10^{10}$ 时，即使不考虑对右端项的任何显式扰动，我们也可以预见到至少会损失 $\\log_{10}(1.5 \\times 10^{10}) \\approx 10.2$ 位的十进制精度。\n\n求解过程如下：\n\n1.  **矩阵和向量的构建**：首先，我们根据定义 $H_{ij} = (i+j-1)^{-1}$ 构建 $8 \\times 8$ 的 Hilbert 矩阵 $H$。在数组实现中，我们必须使用从 0 开始的索引，因此位于 `(row, col)` 索引 `i`、`j` 处的元素是 $1.0 / (i + j + 1)$，其中 $i,j \\in \\{0, 1, \\dots, 7\\}$。精确解是一个全为 1 的向量，$x^{\\mathrm{true}} = [1, 1, \\dots, 1]^T \\in \\mathbb{R}^8$。相应的“真实”右端向量 $b$ 通过矩阵-向量乘积 $b = H x^{\\mathrm{true}}$ 计算得出。由于 $x^{\\mathrm{true}}$ 的结构， $b$ 实际上就是 $H$ 的行和向量，即 $b_i = \\sum_{j=1}^8 H_{ij}$。\n\n2.  **测试用例评估**：对于四个测试用例中的每一个，我们定义受扰动的右端向量 $\\tilde{b}$，并求解线性系统 $H \\hat{x} = \\tilde{b}$ 以获得计算解 $\\hat{x}$。这可以通过使用标准的数值求解器来完成，例如基于 LU 分解的求解器，通常通过 `numpy.linalg.solve` 调用。\n\n    *   **用例 1 (基准)**：$\\tilde{b} = b$。在此情况下，唯一的误差来源是浮点运算的有限精度。$H$ 的表示和 $b$ 的计算会引入微小的舍入误差。线性求解器本身也会引入进一步的误差。$\\hat{x}$ 与 $x^{\\mathrm{true}}$ 之间的偏差几乎完全是由于 $H$ 的巨大条件数放大了这些固有的表示和算术误差所致。\n\n    *   **用例 2 (舍入到 $k=8$ 位)**：我们通过将计算出的向量 $b$ 的每个分量舍入到 8 位有效十进制数字来获得 $\\tilde{b}$。这引入了一个量级约为 $10^{-8}$ 的显式相对扰动 $\\delta b / b$。经 $\\kappa_2(H_8) \\approx 10^{10}$ 放大后，解的预期相对误差将在 $10^{10} \\times 10^{-8} = 100$ 的量级。大于 1 的相对误差意味着精度的完全丧失。\n\n    *   **用例 3 (舍入到 $k=6$ 位)**：舍入更为严重。$b$ 中的相对扰动量级约为 $10^{-6}$。解的预期相对误差会更大，约为 $10^{10} \\times 10^{-6} = 10^4$。同样，预计会完全丧失精度。\n\n    *   **用例 4 (确定性扰动)**：扰动被定义为一个微小的、交替的相对变化：$\\tilde{b}_i = b_i (1 + 10^{-12} \\cdot (-1)^i)$。$b$ 中的相对扰动幅度为 $10^{-12}$。解的预期相对误差量级约为 $10^{10} \\times 10^{-12} = 10^{-2}$。\n\n3.  **精度计算**：在计算出每种情况下的 $\\hat{x}$ 后，我们使用正确有效数字位数 $s$ 来量化精度，其定义为：\n    $$\n    s = \\max\\left(0,\\; -\\log_{10}\\left(\\frac{\\lVert \\hat{x} - x^{\\mathrm{true}} \\rVert_2}{\\lVert x^{\\mathrm{true}} \\rVert_2}\\right)\\right)\n    $$\n    对数内的项是解的相对误差。精确解的欧几里得范数是 $\\lVert x^{\\mathrm{true}} \\rVert_2 = \\sqrt{8}$。我们计算误差向量 $\\hat{x} - x^{\\mathrm{true}}$，求其欧几里得范数，然后代入 $s$ 的公式。\n\n该实现需要一个函数来执行舍入到指定有效数字位数的操作。对于非零数 $y$ 和 $k$ 位有效数字，这可以通过将 $y$ 舍入到 $d = k - 1 - \\lfloor\\log_{10}|y|\\rfloor$ 位小数来实现。\n\n这一系统化步骤使得我们能够定量评估一个病态系统（工程和科学计算中的常见风险）如何因各种误差源而降低数值解的质量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Computes the number of correct significant digits in the solution of a\n    linear system with the 8x8 Hilbert matrix under various perturbations\n    to the right-hand side vector.\n    \"\"\"\n\n    def round_to_k_significant_digits(y, k):\n        \"\"\"\n        Rounds a number y to k significant digits.\n        \"\"\"\n        if y == 0:\n            return 0.0\n        # Determine the number of decimal places needed for rounding\n        # based on the magnitude of the number.\n        d = k - 1 - math.floor(math.log10(abs(y)))\n        # Python's round() uses round-half-to-even.\n        return round(y, int(d))\n\n    # Define problem parameters\n    n = 8  # Order of the Hilbert matrix\n\n    # Construct the Hilbert matrix H.\n    # H_ij = 1 / (i + j - 1) for 1-based indexing.\n    # For 0-based indices, this is H_ij = 1 / ((i+1) + (j+1) - 1) = 1 / (i+j+1).\n    H = np.zeros((n, n), dtype=np.float64)\n    for i in range(n):\n        for j in range(n):\n            H[i, j] = 1.0 / (i + j + 1)\n\n    # Define the true solution x_true (a vector of ones).\n    x_true = np.ones(n, dtype=np.float64)\n\n    # Calculate the true right-hand side vector b = H * x_true.\n    # Since x_true is all ones, b is the vector of row sums of H.\n    b = H @ x_true\n\n    # The Euclidean norm of the true solution is sqrt(n).\n    norm_x_true = np.linalg.norm(x_true, 2)\n\n    # List to store the results (s values) for each test case.\n    results = []\n    \n    # Define test cases as a list of perturbed right-hand side vectors.\n    # Test Case 1: Baseline (no explicit perturbation)\n    b_tilde_1 = b\n\n    # Test Case 2: Rounding to 8 significant digits\n    b_tilde_2 = np.array([round_to_k_significant_digits(val, 8) for val in b])\n\n    # Test Case 3: Rounding to 6 significant digits\n    b_tilde_3 = np.array([round_to_k_significant_digits(val, 6) for val in b])\n\n    # Test Case 4: Deterministic component-wise relative perturbation\n    # delta_b_i = 10^-12 * (-1)^i * |b_i| for i=1..8\n    # For 0-based index j=0..7, this is (-1)^(j+1).\n    delta_b_4 = np.array([1e-12 * ((-1)**(i + 1)) * abs(b[i]) for i in range(n)])\n    b_tilde_4 = b + delta_b_4\n    \n    test_cases_b = [b_tilde_1, b_tilde_2, b_tilde_3, b_tilde_4]\n\n    for b_tilde in test_cases_b:\n        # Solve the linear system H * x_hat = b_tilde.\n        x_hat = np.linalg.solve(H, b_tilde)\n\n        # Calculate the relative error of the solution.\n        # rel_err = ||x_hat - x_true|| / ||x_true||\n        error_norm = np.linalg.norm(x_hat - x_true, 2)\n        relative_error = error_norm / norm_x_true\n\n        # Calculate the number of correct significant digits, s.\n        # s = max(0, -log10(relative_error))\n        # A check for relative_error == 0 is theoretically needed but\n        # practically impossible in this floating-point context.\n        s = max(0.0, -math.log10(relative_error))\n        \n        # Store the result, rounded to 3 decimal places.\n        results.append(round(s, 3))\n\n    # Format the final output as specified.\n    output_str = \"[\" + \",\".join(map(str, results)) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "2432471"}]}