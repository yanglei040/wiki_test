{"hands_on_practices": [{"introduction": "要想有效地应用方差缩减技术，我们必须首先理解其数学基础。第一个实践提供了一个关于控制变量的基础分析练习，你将通过解析推导来确定一个估计量的最优性能。通过完成这个推导，你将具体理解如何利用一个已知均值的相关量来显著降低估计量的方差。", "problem": "设 $X$ 是一个正态分布的随机变量，其均值为 $\\,\\mu\\,$，方差为 $\\,\\sigma^{2}\\,$，其中 $\\,\\mu \\neq 0\\,$ 且 $\\,\\sigma^{2}  0\\,$。目标是使用 $\\,n\\,$ 个独立同分布（i.i.d.）的样本 $\\,X_{1},\\dots,X_{n}\\,$，通过蒙特卡洛方法估计 $\\,\\theta = \\mathbb{E}[X^{2}]\\,$。\n\n考虑以下关于 $\\,\\theta\\,$ 的无偏估计量：\n- 直接估计量 $\\,\\hat{\\theta}_{\\mathrm{dir}} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}^{2}\\,$。\n- 控制变量（CV）估计量 $\\,\\hat{\\theta}_{\\mathrm{cv}} = \\frac{1}{n}\\sum_{i=1}^{n} \\left(X_{i}^{2} - \\beta\\,(X_{i}-\\mu)\\right)\\,$，其中 $\\,\\mu = \\mathbb{E}[X]\\,$ 已知，且系数 $\\,\\beta\\,$ 的选择是为了最小化估计量的方差。\n\n推导精确比率 $\\,\\frac{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})}{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{dir}})}\\,$ 的闭式解，形式为一个仅含 $\\,\\mu\\,$ 和 $\\,\\sigma^{2}\\,$ 的简化表达式（该表达式不能依赖于 $\\,n\\,$）。请将您的最终答案表示为单个解析表达式。请勿近似。", "solution": "问题陈述需经过验证。\n\n**步骤1：提取已知条件**\n- 随机变量 $X$ 服从均值为 $\\mu$、方差为 $\\sigma^{2}$ 的正态分布。\n- 约束条件：$\\mu \\neq 0$ 且 $\\sigma^{2}  0$。\n- 待估计参数为 $\\theta = \\mathbb{E}[X^{2}]$。\n- 估计过程使用 $n$ 个独立同分布（i.i.d.）的样本 $X_{1}, \\dots, X_{n}$。\n- 直接估计量为 $\\hat{\\theta}_{\\mathrm{dir}} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}^{2}$。\n- 控制变量（CV）估计量为 $\\hat{\\theta}_{\\mathrm{cv}} = \\frac{1}{n}\\sum_{i=1}^{n} \\left(X_{i}^{2} - \\beta\\,(X_{i}-\\mu)\\right)$。\n- 均值 $\\mu = \\mathbb{E}[X]$ 已知。\n- 系数 $\\beta$ 的选择是为了最小化 $\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})$。\n- 目标是推导精确比率 $\\frac{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})}{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{dir}})}$，并将其表示为仅含 $\\mu$ 和 $\\sigma^{2}$ 的简化表达式。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题是计算统计学中的一个标准练习，涉及使用控制变量法降低蒙特卡洛估计量的方差。所有概念——正态分布、期望、方差和估计量——在基础上都是合理的。\n- **适定性：** 该问题是适定的。它提供了确定最优控制变量系数 $\\beta$ 并随后计算所需方差比率的所有必要信息。解的存在性和唯一性由线性回归和方差最小化原理保证。\n- **客观性：** 该问题使用精确、客观的数学语言陈述。\n\n**步骤3：结论与行动**\n该问题是有效的。它是计算工程和统计学中一个标准的、定义明确的问题。我将继续进行推导。\n\n目标是计算 $\\theta = \\mathbb{E}[X^2]$ 的两个估计量方差之比。\n直接估计量为 $\\hat{\\theta}_{\\mathrm{dir}} = \\frac{1}{n}\\sum_{i=1}^{n} X_{i}^{2}$。由于样本 $X_i$ 是独立同分布的，其方差为：\n$$\n\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{dir}}) = \\mathrm{Var}\\left(\\frac{1}{n}\\sum_{i=1}^{n} X_{i}^{2}\\right) = \\frac{1}{n^{2}}\\sum_{i=1}^{n} \\mathrm{Var}(X_{i}^{2}) = \\frac{1}{n}\\mathrm{Var}(X^{2})\n$$\n控制变量估计量为 $\\hat{\\theta}_{\\mathrm{cv}} = \\frac{1}{n}\\sum_{i=1}^{n} Y_{i}$，其中 $Y_{i} = X_{i}^{2} - \\beta(X_{i}-\\mu)$。其方差为：\n$$\n\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}}) = \\frac{1}{n}\\mathrm{Var}(Y_1) = \\frac{1}{n}\\mathrm{Var}(X^{2} - \\beta(X-\\mu))\n$$\n因此，需要计算的比率为：\n$$\n\\frac{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})}{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{dir}})} = \\frac{\\frac{1}{n}\\mathrm{Var}(X^{2} - \\beta(X-\\mu))}{\\frac{1}{n}\\mathrm{Var}(X^{2})} = \\frac{\\mathrm{Var}(X^{2} - \\beta(X-\\mu))}{\\mathrm{Var}(X^{2})}\n$$\n必须选择系数 $\\beta$ 以最小化 $\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})$。最优系数（记为 $\\beta^{*}$）由著名公式给出：\n$$\n\\beta^{*} = \\frac{\\mathrm{Cov}(X^{2}, X-\\mu)}{\\mathrm{Var}(X-\\mu)}\n$$\n我们必须计算此表达式的各个组成部分。分母就是 $\\mathrm{Var}(X-\\mu) = \\mathrm{Var}(X) = \\sigma^{2}$。\n对于分子，我们计算协方差：\n$$\n\\mathrm{Cov}(X^{2}, X-\\mu) = \\mathbb{E}[X^{2}(X-\\mu)] - \\mathbb{E}[X^{2}]\\mathbb{E}[X-\\mu]\n$$\n由于 $\\mathbb{E}[X-\\mu] = \\mathbb{E}[X] - \\mu = \\mu - \\mu = 0$，第二项消失。\n$$\n\\mathrm{Cov}(X^{2}, X-\\mu) = \\mathbb{E}[X^{3} - \\mu X^{2}] = \\mathbb{E}[X^{3}] - \\mu \\mathbb{E}[X^{2}]\n$$\n为了计算这些矩，我们定义一个标准正态变量 $Z = \\frac{X-\\mu}{\\sigma}$，因此 $X = \\mu + \\sigma Z$。$Z$ 的各阶矩为 $\\mathbb{E}[Z]=0$，$\\mathbb{E}[Z^2]=1$，$\\mathbb{E}[Z^3]=0$ 和 $\\mathbb{E}[Z^4]=3$。\n$X$ 的二阶矩为 $\\mathbb{E}[X^{2}] = \\mathrm{Var}(X) + (\\mathbb{E}[X])^{2} = \\sigma^{2} + \\mu^{2}$。\n$X$ 的三阶矩为：\n$$\n\\mathbb{E}[X^{3}] = \\mathbb{E}[(\\mu + \\sigma Z)^{3}] = \\mathbb{E}[\\mu^{3} + 3\\mu^{2}\\sigma Z + 3\\mu\\sigma^{2}Z^{2} + \\sigma^{3}Z^{3}]\n$$\n利用期望的线性性质和 $Z$ 的各阶矩：\n$$\n\\mathbb{E}[X^{3}] = \\mu^{3} + 3\\mu^{2}\\sigma\\mathbb{E}[Z] + 3\\mu\\sigma^{2}\\mathbb{E}[Z^{2}] + \\sigma^{3}\\mathbb{E}[Z^{3}] = \\mu^{3} + 0 + 3\\mu\\sigma^{2}(1) + 0 = \\mu^{3} + 3\\mu\\sigma^{2}\n$$\n现在，将各阶矩代回协方差表达式：\n$$\n\\mathrm{Cov}(X^{2}, X-\\mu) = (\\mu^{3} + 3\\mu\\sigma^{2}) - \\mu(\\sigma^{2} + \\mu^{2}) = \\mu^{3} + 3\\mu\\sigma^{2} - \\mu\\sigma^{2} - \\mu^{3} = 2\\mu\\sigma^{2}\n$$\n因此，最优系数为：\n$$\n\\beta^{*} = \\frac{2\\mu\\sigma^{2}}{\\sigma^{2}} = 2\\mu\n$$\n使用最优 $\\beta^{*}$，控制变量项的方差由下式给出：\n$$\n\\mathrm{Var}(X^{2} - \\beta^{*}(X-\\mu)) = \\mathrm{Var}(X^{2}) - \\frac{(\\mathrm{Cov}(X^{2}, X-\\mu))^{2}}{\\mathrm{Var}(X-\\mu)}\n$$\n我们需要计算 $\\mathrm{Var}(X^{2})$。\n$$\n\\mathrm{Var}(X^{2}) = \\mathbb{E}[X^{4}] - (\\mathbb{E}[X^{2}])^{2}\n$$\n首先，计算 $X$ 的四阶矩：\n$$\n\\mathbb{E}[X^{4}] = \\mathbb{E}[(\\mu + \\sigma Z)^{4}] = \\mathbb{E}[\\mu^{4} + 4\\mu^{3}\\sigma Z + 6\\mu^{2}\\sigma^{2}Z^{2} + 4\\mu\\sigma^{3}Z^{3} + \\sigma^{4}Z^{4}]\n$$\n$$\n\\mathbb{E}[X^{4}] = \\mu^{4} + 4\\mu^{3}\\sigma\\mathbb{E}[Z] + 6\\mu^{2}\\sigma^{2}\\mathbb{E}[Z^{2}] + 4\\mu\\sigma^{3}\\mathbb{E}[Z^{3}] + \\sigma^{4}\\mathbb{E}[Z^{4}]\n$$\n$$\n\\mathbb{E}[X^{4}] = \\mu^{4} + 0 + 6\\mu^{2}\\sigma^{2}(1) + 0 + \\sigma^{4}(3) = \\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4}\n$$\n现在我们可以计算 $\\mathrm{Var}(X^{2})$：\n$$\n\\mathrm{Var}(X^{2}) = (\\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4}) - (\\sigma^{2} + \\mu^{2})^{2}\n$$\n$$\n\\mathrm{Var}(X^{2}) = (\\mu^{4} + 6\\mu^{2}\\sigma^{2} + 3\\sigma^{4}) - (\\sigma^{4} + 2\\mu^{2}\\sigma^{2} + \\mu^{4}) = 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}\n$$\n根据这个结果，我们找到控制变量项的最小化方差：\n$$\n\\mathrm{Var}(X^{2} - \\beta^{*}(X-\\mu)) = (4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}) - \\frac{(2\\mu\\sigma^{2})^{2}}{\\sigma^{2}}\n$$\n$$\n= (4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}) - \\frac{4\\mu^{2}\\sigma^{4}}{\\sigma^{2}} = 4\\mu^{2}\\sigma^{2} + 2\\sigma^{4} - 4\\mu^{2}\\sigma^{2} = 2\\sigma^{4}\n$$\n最后，我们组合方差之比：\n$$\n\\frac{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{cv}})}{\\mathrm{Var}(\\hat{\\theta}_{\\mathrm{dir}})} = \\frac{\\mathrm{Var}(X^{2} - \\beta^{*}(X-\\mu))}{\\mathrm{Var}(X^{2})} = \\frac{2\\sigma^{4}}{4\\mu^{2}\\sigma^{2} + 2\\sigma^{4}}\n$$\n由于 $\\sigma^{2}  0$，我们可以通过将分子和分母同时除以 $2\\sigma^{2}$ 来简化表达式：\n$$\n\\frac{2\\sigma^{4}}{2\\sigma^{2}(2\\mu^{2} + \\sigma^{2})} = \\frac{\\sigma^{2}}{2\\mu^{2} + \\sigma^{2}}\n$$\n这就是方差比率的最终简化表达式。根据要求，它只依赖于 $\\mu$ 和 $\\sigma^{2}$。", "answer": "$$\n\\boxed{\\frac{\\sigma^{2}}{2\\mu^{2} + \\sigma^{2}}}\n$$", "id": "2449189"}, {"introduction": "虽然解析推导至关重要，但这些方法的真正威力在于实际应用。本实践将我们带入一个计算问题，演示“共同随机数”($\\text{CRN}$)这一技术。你将通过编写一个仿真程序来比较两种金融期权，亲眼见证同步随机输入如何能够极大地减少估计差异的方差。", "problem": "设在风险中性概率测度下，一个几何布朗运动 (GBM) 由随机微分方程 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$ 定义，其中 $S_t$ 是时间 $t$ 的资产价格，$r$ 是连续复利率，$\\sigma$ 是波动率，$W_t$ 是标准布朗运动。考虑一个执行价格为 $K$、到期日为 $T$ 的欧式看涨期权，在给定利率 $r$ 的情况下，其在时间 $T$ 的折现收益为 $e^{-rT} \\max(S_T - K, 0)$。\n\n您的任务是使用称为公共随机数的方差缩减技术，构建一个比较蒙特卡洛估计量，以估计在两个不同利率下，折现看涨期权收益的成对路径差异的方差。具体来说，对于固定的样本量 $N$ 和指定的整数种子 $s$，生成一组 $N$ 个标准正态随机变量，并用它来驱动几何布朗运动在利率分别为 $r_1$ 和 $r_2$ 时的两个终端价值 $S_T^{(r_1)}$ 和 $S_T^{(r_2)}$。对每个结果，计算折现看涨期权收益 $C^{(r_1)}$ 和 $C^{(r_2)}$，形成成对差异 $D = C^{(r_1)} - C^{(r_2)}$，并计算 $D$ 的经验无偏样本方差。此外，为进行比较，请使用对每个利率进行独立抽样的方法估计均值差估计量的方差：使用种子 $s+1$ 为 $r_1$ 抽取 $N$ 个独立标准正态随机变量，使用种子 $s+2$ 为 $r_2$ 抽取 $N$ 个独立标准正态随机变量，计算相应的折现看涨期权收益，并通过两个样本方差之和除以 $N$ 来估计 $\\operatorname{Var}(\\bar{C}^{(r_1)} - \\bar{C}^{(r_2)})$。总结来说，对于每个测试用例，您必须输出以下四个量：\n- 成对差异 $D$ 的无偏经验样本方差 $s_D^2$（使用公共随机数），\n- 在公共随机数下，均值差估计量的估计方差，$s_D^2/N$，\n- 在独立抽样下，均值差估计量的估计方差，$s_{C^{(r_1)}}^2/N + s_{C^{(r_2)}}^2/N$，\n- 独立抽样估计量方差与公共随机数估计量方差之比。如果公共随机数估计量方差在数值上为零，则输出比值为浮点无穷大。\n\n您的构建应基于 GBM、风险中性定价原理和蒙特卡洛模拟的核心定义。不要在问题陈述中使用快捷公式；在您的解决方案中，从这些基础推导出任何必要的关系。所有量都必须表示为无量纲实数。\n\n使用以下参数值的测试套件，其中每个元组代表 $(S_0, K, \\sigma, T, r_1, r_2, N, s)$:\n- 案例 A（一般比较）：$(100.0, 100.0, 0.2, 1.0, 0.01, 0.05, 200000, 271828)$，\n- 案例 B（利率相同的边界情况）：$(100.0, 100.0, 0.2, 1.0, 0.03, 0.03, 100000, 314159)$，\n- 案例 C（短到期时间，大利率差异）：$(100.0, 100.0, 0.2, 0.01, 0.0, 0.10, 300000, 161803)$，\n- 案例 D（深度价外）：$(50.0, 100.0, 0.4, 2.0, 0.02, 0.08, 250000, 141421)$。\n\n您的程序必须生成单行输出，其中包含按以下顺序排列的所有结果，格式为方括号内的逗号分隔列表：\n$[s_{D,A}^2, v_{\\text{CRN},A}, v_{\\text{IND},A}, \\rho_A, s_{D,B}^2, v_{\\text{CRN},B}, v_{\\text{IND},B}, \\rho_B, s_{D,C}^2, v_{\\text{CRN},C}, v_{\\text{IND},C}, \\rho_C, s_{D,D}^2, v_{\\text{CRN},D}, v_{\\text{IND},D}, \\rho_D]$,\n其中 $s_{D,\\cdot}^2$ 表示指定案例的成对差异的无偏样本方差，$v_{\\text{CRN},\\cdot} = s_{D,\\cdot}^2/N$ 表示公共随机数估计量方差，$v_{\\text{IND},\\cdot}$ 表示独立抽样估计量方差，$\\rho_{\\cdot} = v_{\\text{IND},\\cdot} / v_{\\text{CRN},\\cdot}$ 表示指定案例的方差比。", "solution": "该问题要求对两种欧式看涨期权价格之差的估计量进行方差比较，这两种期权价格仅在无风险利率 $r$ 上有所不同。比较在两种蒙特卡洛模拟方案之间进行：一种是为每个期权价格估计使用独立的随机数流，另一种是使用公共随机数（CRN），这是一种方差缩减技术。\n\n首先，我们必须建立终端资产价格 $S_T$ 的模拟公式。规定资产价格在风险中性测度下遵循几何布朗运动（GBM），由随机微分方程（SDE）描述：\n$$\ndS_t = r S_t \\, dt + \\sigma S_t \\, dW_t\n$$\n其中 $S_t$ 是时间 $t$ 的资产价格，$r$ 是无风险利率，$\\sigma$ 是波动率，$W_t$ 是标准维纳过程（布朗运动）。\n\n为了找到 $S_T$ 的解，我们对函数 $f(S_t) = \\ln(S_t)$ 应用 Itô 引理。其导数为 $f'(S_t) = 1/S_t$ 和 $f''(S_t) = -1/S_t^2$。根据 Itô 引理，微分 $d(\\ln S_t)$ 为：\n$$\nd(\\ln S_t) = f'(S_t) dS_t + \\frac{1}{2} f''(S_t) (dS_t)^2\n$$\n二次变分项 $(dS_t)^2$ 通过对 SDE 平方得到，根据 Itô 演算规则只保留 $dt$ 的最低阶项（$dt^2 \\to 0$，$dt dW_t \\to 0$，$(dW_t)^2 \\to dt$）：\n$$\n(dS_t)^2 = (r S_t \\, dt + \\sigma S_t \\, dW_t)^2 = \\sigma^2 S_t^2 (dW_t)^2 = \\sigma^2 S_t^2 dt\n$$\n将 $dS_t$ 和 $(dS_t)^2$ 代入引理得到：\n$$\nd(\\ln S_t) = \\frac{1}{S_t}(r S_t \\, dt + \\sigma S_t \\, dW_t) + \\frac{1}{2} \\left(-\\frac{1}{S_t^2}\\right)(\\sigma^2 S_t^2 dt)\n$$\n$$\nd(\\ln S_t) = (r \\, dt + \\sigma \\, dW_t) - \\frac{1}{2} \\sigma^2 dt = \\left(r - \\frac{1}{2}\\sigma^2\\right)dt + \\sigma dW_t\n$$\n对两边从 $t=0$ 到 $t=T$ 积分：\n$$\n\\int_0^T d(\\ln S_t) = \\int_0^T \\left(r - \\frac{1}{2}\\sigma^2\\right)dt + \\int_0^T \\sigma dW_t\n$$\n$$\n\\ln(S_T) - \\ln(S_0) = \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma (W_T - W_0)\n$$\n鉴于 $W_0=0$ 且随机变量 $W_T$ 服从均值为 $0$、方差为 $T$ 的正态分布，我们可以写成 $W_T = \\sqrt{T}Z$，其中 $Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。对两边取指数即可得到终端资产价格的解：\n$$\nS_T = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z \\right)\n$$\n该公式是蒙特卡洛模拟终端资产价格的基础。\n\n欧式看涨期权的价格是在风险中性测度下其折现收益的期望值：\n$$\nC(r) = E\\left[ e^{-rT} \\max(S_T - K, 0) \\right]\n$$\n该价格的一个蒙特卡洛估计是在 $N$ 条模拟路径上的样本均值：\n$$\n\\bar{C}(r) = \\frac{1}{N} \\sum_{i=1}^N C_i(r) = \\frac{1}{N} \\sum_{i=1}^N e^{-rT} \\max(S_{T,i} - K, 0)\n$$\n其中每个 $S_{T,i}$ 都是使用从 $N(0,1)$ 中独立抽取的 $Z_i$ 生成的。\n\n我们的目标是估计两种利率 $r_1$ 和 $r_2$ 下期权价格的差异，即 $\\Delta = C(r_1) - C(r_2)$。自然的估计量是 $\\hat{\\Delta} = \\bar{C}(r_1) - \\bar{C}(r_2)$。我们关心的是这个估计量的方差 $\\operatorname{Var}(\\hat{\\Delta})$。\n\n首先，考虑**独立抽样**的情况。我们生成两组独立的 $N$ 个标准正态随机变量 $\\{Z_i^{(1)}\\}_{i=1}^N$ 和 $\\{Z_i^{(2)}\\}_{i=1}^N$，分别用于计算 $\\bar{C}(r_1)$ 和 $\\bar{C}(r_2)$。因为估计量是独立的，它们差的方差是它们方差的和：\n$$\n\\operatorname{Var}(\\hat{\\Delta})_{\\text{IND}} = \\operatorname{Var}(\\bar{C}(r_1) - \\bar{C}(r_2)) = \\operatorname{Var}(\\bar{C}(r_1)) + \\operatorname{Var}(\\bar{C}(r_2))\n$$\n样本均值的方差是总体方差除以样本量，即 $\\operatorname{Var}(\\bar{C}(r)) = \\operatorname{Var}(C(r))/N$。我们使用无偏样本方差 $s_{C(r)}^2 = \\frac{1}{N-1}\\sum_{i=1}^N(C_i(r) - \\bar{C}(r))^2$ 来估计它。因此，均值差估计量的估计方差为：\n$$\nv_{\\text{IND}} = \\frac{s_{C(r_1)}^2}{N} + \\frac{s_{C(r_2)}^2}{N}\n$$\n\n接下来，考虑**公共随机数（CRN）**技术。我们使用同一组 $N$ 个标准正态随机变量 $\\{Z_i\\}_{i=1}^N$ 来生成两个收益序列 $\\{C_i(r_1)\\}_{i=1}^N$ 和 $\\{C_i(r_2)\\}_{i=1}^N$。然后我们通过计算成对差异的均值来估计 $\\Delta$，即 $\\bar{D} = \\frac{1}{N} \\sum_{i=1}^N D_i$，其中 $D_i = C_i(r_1) - C_i(r_2)$。该估计量的方差为：\n$$\n\\operatorname{Var}(\\bar{D}) = \\frac{1}{N} \\operatorname{Var}(D) = \\frac{1}{N} \\operatorname{Var}(C(r_1) - C(r_2))\n$$\n$$\nv_{\\text{CRN}} = \\frac{1}{N} \\operatorname{Var}(C(r_1) - C(r_2)) = \\frac{1}{N} \\left( \\operatorname{Var}(C(r_1)) + \\operatorname{Var}(C(r_2)) - 2\\operatorname{Cov}(C(r_1), C(r_2)) \\right)\n$$\n我们用差异的样本方差 $s_D^2 = \\frac{1}{N-1}\\sum_{i=1}^N(D_i - \\bar{D})^2$ 来估计它。那么估计量的估计方差为 $v_{\\text{CRN}} = s_D^2 / N$。注意 $s_D^2$ 是要求输出的量之一。\n\nCRN 的有效性取决于协方差项。对于一个固定的冲击 $Z$，终端价格 $S_T(r) = S_0 \\exp\\left( (r - \\frac{1}{2}\\sigma^2)T + \\sigma\\sqrt{T}Z \\right)$ 是 $r$ 的单调递增函数。看涨期权收益 $\\max(S_T - K, 0)$ 在 $S_T$ 上是单调的。贴现因子 $e^{-rT}$ 在 $r$ 上是单调递减的。组合函数 $C(r, Z) = e^{-rT} \\max(S_T(r,Z) - K, 0)$ 在其定义域的很大一部分上也倾向于关于 $r$ 是单调的。这导致收益序列 $C_i(r_1)$ 和 $C_i(r_2)$ 之间存在强正相关。因此，$\\operatorname{Cov}(C(r_1), C(r_2))$ 是正的且较大，这显著减小了方差 $v_{\\text{CRN}}$（相比于 $v_{\\text{IND}}$）。比率 $\\rho = v_{\\text{IND}} / v_{\\text{CRN}}$ 量化了这种方差缩减，预计会大于 1。\n\n对于 $r_1=r_2$ 的特殊情况（案例 B），对于任何给定的冲击 $Z_i$，我们将有 $S_{T,i}^{(r_1)} = S_{T,i}^{(r_2)}$，因此 $C_i^{(r_1)} = C_i^{(r_2)}$。这意味着每个成对差异 $D_i = C_i^{(r_1)} - C_i^{(r_2)}$ 都将恰好为 0。因此，差异的样本方差 $s_D^2$ 将为 0。CRN 估计量的方差 $v_{\\text{CRN}} = s_D^2/N$ 也为 0。在这种情况下，比率 $\\rho = v_{\\text{IND}} / v_{\\text{CRN}}$ 变为无穷大，表明方差缩减是完美的，正如预期的那样。\n\n每个测试用例 $(S_0, K, \\sigma, T, r_1, r_2, N, s)$ 的计算步骤如下：\n1.  **公共随机数：**\n    a. 使用种子 $s$ 初始化一个随机数生成器。生成 $N$ 个标准正态随机变量 $Z_i$。\n    b. 对于每个 $Z_i$，计算 $S_{T,i}^{(r_1)}$、$S_{T,i}^{(r_2)}$，然后计算折现收益 $C_i^{(r_1)}$、$C_i^{(r_2)}$。\n    c. 形成差异 $D_i = C_i^{(r_1)} - C_i^{(r_2)}$。\n    d. 计算无偏样本方差 $s_D^2 = \\operatorname{Var}(D_1, \\dots, D_N)$（分母为 $N-1$）。\n    e. 计算估计量方差 $v_{\\text{CRN}} = s_D^2 / N$。\n2.  **独立抽样：**\n    a. 使用种子 $s+1$ 初始化一个生成器。生成 $N$ 个随机变量 $Z_i^{(1)}$ 并计算相应的收益 $C_i^{(r_1)}$。计算它们的样本方差 $s_{C(r_1)}^2$。\n    b. 使用种子 $s+2$ 初始化一个生成器。生成 $N$ 个随机变量 $Z_i^{(2)}$ 并计算相应的收益 $C_i^{(r_2)}$。计算它们的样本方差 $s_{C(r_2)}^2$。\n    c. 计算估计量方差 $v_{\\text{IND}} = s_{C(r_1)}^2/N + s_{C(r_2)}^2/N$。\n3.  **比率：** 计算 $\\rho = v_{\\text{IND}} / v_{\\text{CRN}}$。如果 $v_{\\text{CRN}} = 0$，则比率为正无穷大。\n\n对每个测试用例实施这些步骤，以产生所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating and comparing variances for Monte Carlo\n    estimators using both common random numbers and independent sampling.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, sigma, T, r1, r2, N, s)\n        (100.0, 100.0, 0.2, 1.0, 0.01, 0.05, 200000, 271828), # Case A\n        (100.0, 100.0, 0.2, 1.0, 0.03, 0.03, 100000, 314159), # Case B\n        (100.0, 100.0, 0.2, 0.01, 0.0, 0.10, 300000, 161803), # Case C\n        (50.0, 100.0, 0.4, 2.0, 0.02, 0.08, 250000, 141421),  # Case D\n    ]\n\n    results = []\n    \n    for S0, K, sigma, T, r1, r2, N, s in test_cases:\n        \n        # --- 1. Common Random Numbers (CRN) Calculation ---\n        rng_crn = np.random.default_rng(s)\n        Z = rng_crn.standard_normal(N)\n\n        # Calculate terminal prices for both rates using the same random numbers\n        drift1 = (r1 - 0.5 * sigma**2) * T\n        drift2 = (r2 - 0.5 * sigma**2) * T\n        diffusion = sigma * np.sqrt(T) * Z\n        \n        ST1_crn = S0 * np.exp(drift1 + diffusion)\n        ST2_crn = S0 * np.exp(drift2 + diffusion)\n        \n        # Calculate discounted call payoffs\n        C1_crn = np.exp(-r1 * T) * np.maximum(ST1_crn - K, 0)\n        C2_crn = np.exp(-r2 * T) * np.maximum(ST2_crn - K, 0)\n        \n        # Calculate paired differences\n        D = C1_crn - C2_crn\n        \n        # Unbiased empirical sample variance of the paired differences\n        s_D_sq = np.var(D, ddof=1)\n        \n        # Estimated variance of the difference-of-means estimator under CRN\n        v_crn = s_D_sq / N\n        \n        # --- 2. Independent Sampling Calculation ---\n        # Rate 1\n        rng_ind1 = np.random.default_rng(s + 1)\n        Z1_ind = rng_ind1.standard_normal(N)\n        ST1_ind = S0 * np.exp(drift1 + sigma * np.sqrt(T) * Z1_ind)\n        C1_ind = np.exp(-r1 * T) * np.maximum(ST1_ind - K, 0)\n        s_C1_sq = np.var(C1_ind, ddof=1)\n\n        # Rate 2\n        rng_ind2 = np.random.default_rng(s + 2)\n        Z2_ind = rng_ind2.standard_normal(N)\n        ST2_ind = S0 * np.exp(drift2 + sigma * np.sqrt(T) * Z2_ind)\n        C2_ind = np.exp(-r2 * T) * np.maximum(ST2_ind - K, 0)\n        s_C2_sq = np.var(C2_ind, ddof=1)\n        \n        # Estimated variance of the difference-of-means estimator under independent sampling\n        v_ind = (s_C1_sq / N) + (s_C2_sq / N)\n        \n        # --- 3. Ratio Calculation ---\n        if v_crn == 0:\n            rho = float('inf')\n        else:\n            rho = v_ind / v_crn\n            \n        results.extend([s_D_sq, v_crn, v_ind, rho])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3005265"}, {"introduction": "我们的最终实践将探索一种更复杂且功能强大的技术：自适应重要性采样。你将不再使用固定的采样策略，而是设计一种算法，该算法能够迭代地学习和改进其建议分布，以更好地匹配被积函数。这个练习展示了一种解决复杂积分问题的先进方法，并强调了在整个自适应过程中确保估计量无偏的重要性。", "problem": "你需要实现一个自适应蒙特卡洛重要性采样估计器，以数值方式评估一组非负积分。该估计器必须使用一个参数化采样分布，该分布可以在迭代之间根据先前生成的样本进行更新，但需遵循下述约束条件。最终程序必须为每个测试用例计算一个标量估计值，并将结果打印在单行中。\n\n任务是为每个测试用例估计一个形如下式的标量积分\n$$\nI = \\int_{\\mathcal{D}} f(x)\\,dx,\n$$\n其中 $f(x) \\ge 0$ 在其定义域 $\\mathcal{D}$ 上。\n\n你必须构建一个基于重要性采样的蒙特卡洛估计器。对于每个被积函数，使用其定义域所指定的参数族中的一个提议分布 $q(x;\\theta)$，并允许参数向量 $\\theta$ 仅使用已生成的样本和函数评估值在迭代之间进行更新。该估计器必须满足以下要求：\n- 对于 $I$，该估计器必须是无偏的。\n- 对于每次迭代 $t$， $q(\\cdot;\\theta_t)$ 的支撑集必须包含在 $\\mathcal{D}$ 内，并且在 $f(x)  0$ 的任何地方都有 $q(x;\\theta_t)  0$。\n- 每个测试用例的最终估计值必须将所有迭代中生成的所有样本信息汇总成一个单一的标量。\n\n关于定义域和可接受的提议分布族：\n- 如果 $\\mathcal{D} = \\mathbb{R}$，使用高斯分布族 $q(x;\\theta) = \\mathcal{N}(\\mu,\\sigma^2)$，参数为 $\\theta = (\\mu,\\sigma)$，其中 $\\sigma  0$。\n- 如果 $\\mathcal{D} = (0,\\infty)$，使用对数正态分布族，其密度为 $q(x;\\theta) = \\mathrm{Lognormal}(\\mu,\\sigma^2)$，即 $\\log X \\sim \\mathcal{N}(\\mu,\\sigma^2)$，参数为 $\\theta = (\\mu,\\sigma)$，其中 $\\sigma  0$。\n\n你必须使用以下测试套件。在每种情况下，程序必须使用给定的迭代次数 $T$、每次迭代的样本数 $M$、初始参数向量 $\\theta_0$ 以及伪随机数生成器的随机种子 $s$。输出的顺序必须与下面案例的顺序相匹配。\n\n- 案例 1（$\\mathbb{R}$ 上的理想情况）：\n  - 定义域：$\\mathcal{D} = \\mathbb{R}$。\n  - 被积函数：$f_1(x) = \\exp\\!\\big(-\\tfrac{1}{2}(x - 2)^2\\big)$。\n  - 真实值（不用于输出，仅供内部验证）：$\\sqrt{2\\pi}$。\n  - 迭代次数：$T = 5$。\n  - 每次迭代的样本数：$M = 4000$。\n  - 初始参数：$\\theta_0 = (\\mu_0,\\sigma_0) = (0,\\,1.5)$。\n  - 种子：$s = 123$。\n\n- 案例 2（$(0,\\infty)$ 上的边界支撑情况）：\n  - 定义域：$\\mathcal{D} = (0,\\infty)$。\n  - 被积函数：$f_2(x) = x^2 e^{-x}$。\n  - 真实值（不用于输出，仅供内部验证）：$2$。\n  - 迭代次数：$T = 5$。\n  - 每次迭代的样本数：$M = 4000$。\n  - 初始参数：$\\theta_0 = (\\mu_0,\\sigma_0) = (0,\\,1)$。\n  - 种子：$s = 456$。\n\n- 案例 3（$\\mathbb{R}$ 上的多峰被积函数）：\n  - 定义域：$\\mathcal{D} = \\mathbb{R}$。\n  - 被积函数：\n    $$\n    f_3(x) = 0.5 \\exp\\!\\left(-\\frac{(x - 3)^2}{2 \\cdot 0.2^2}\\right) + 0.5 \\exp\\!\\left(-\\frac{(x + 3)^2}{2 \\cdot 0.2^2}\\right).\n    $$\n  - 真实值（不用于输出，仅供内部验证）：$0.2\\sqrt{2\\pi}$。\n  - 迭代次数：$T = 6$。\n  - 每次迭代的样本数：$M = 3000$。\n  - 初始参数：$\\theta_0 = (\\mu_0,\\sigma_0) = (0,\\,1)$。\n  - 种子：$s = 789$。\n\n- 案例 4（$\\mathbb{R}$ 上的偏移峰值）：\n  - 定义域：$\\mathcal{D} = \\mathbb{R}$。\n  - 被积函数：$f_4(x) = \\exp\\!\\big(-\\tfrac{1}{2}(x - 8)^2\\big)$。\n  - 真实值（不用于输出，仅供内部验证）：$\\sqrt{2\\pi}$。\n  - 迭代次数：$T = 5$。\n  - 每次迭代的样本数：$M = 3000$。\n  - 初始参数：$\\theta_0 = (\\mu_0,\\sigma_0) = (0,\\,1)$。\n  - 种子：$s = 321$。\n\n你的程序必须：\n- 对每个案例，生成 $T$ 次迭代，每次迭代从 $q(\\cdot;\\theta_t)$ 中抽取 $M$ 个样本，并在每次迭代后，仅使用截至第 $t$ 次迭代（含）的样本和评估值来更新 $\\theta_{t+1}$，同时满足上述约束。\n- 通过汇总所有迭代中生成的所有样本，为每个案例生成一个无偏的蒙特卡洛估计值。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的四个估计值列表，用方括号括起来，并与上述案例顺序相同，例如 $[r_1,r_2,r_3,r_4]$。\n- 每个 $r_i$ 必须是一个实数（浮点值）。不涉及单位，也没有强制规定舍入规则；任何标准的浮点格式都是可接受的。", "solution": "该问题要求实现一个自适应重要性采样蒙特卡洛估计器，以计算非负函数 $f(x)$ 的积分值 $I = \\int_{\\mathcal{D}} f(x)\\,dx$。该估计器必须是无偏的，并且必须汇总所有生成的样本信息。提议分布 $q(x; \\theta)$ 是参数化的，并在迭代之间进行更新。\n\n重要性采样的基本原理是将积分 $I$ 表示为关于某个提议分布 $q(x)$ 的期望。假设 $q(x)$ 的支撑集包含 $f(x)  0$ 时 $f(x)$ 的支撑集，我们有：\n$$\nI = \\int_{\\mathcal{D}} f(x) \\, dx = \\int_{\\mathcal{D}} \\frac{f(x)}{q(x; \\theta)} q(x; \\theta) \\, dx = E_{X \\sim q(\\cdot; \\theta)}\\left[\\frac{f(X)}{q(X; \\theta)}\\right]\n$$\n一个基于 $M$ 个样本 $X_i \\sim q(\\cdot; \\theta)$ 的标准蒙特卡洛估计是 $\\hat{I}_M = \\frac{1}{M} \\sum_{i=1}^M \\frac{f(X_i)}{q(X_i; \\theta)}$。\n\n问题指定了一个具有 $T$ 次迭代和每次迭代 $M$ 个样本的自适应过程。设 $\\theta_t$ 是在迭代 $t \\in \\{1, \\dots, T\\}$ 时提议分布 $q(\\cdot; \\theta_t)$ 的参数向量。设 $\\{X_{t,i}\\}_{i=1}^M$ 是在迭代 $t$ 时从 $q(\\cdot; \\theta_t)$ 抽取的样本。生成的总样本数为 $N_{total} = T \\times M$。\n\n为满足最终估计器必须是无偏的且必须汇总所有样本的约束，我们将估计器定义为所有迭代中所有样本的重要性采样比的平均值：\n$$\n\\hat{I} = \\frac{1}{N_{total}} \\sum_{t=1}^T \\sum_{i=1}^M \\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)}\n$$\n这个估计器是无偏的。为了证明这一点，我们分析和中单项的期望 $E\\left[\\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)}\\right]$。参数向量 $\\theta_t$ 由迭代 $1, \\dots, t-1$ 的结果决定。设 $\\mathcal{H}_{t-1}$ 表示直到迭代 $t-1$ 结束时生成的所有随机变量的历史。参数向量 $\\theta_t$ 是 $\\mathcal{H}_{t-1}$ 的函数。使用全期望定律：\n$$\nE\\left[\\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)}\\right] = E_{\\mathcal{H}_{t-1}}\\left[ E\\left[ \\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)} \\bigg| \\mathcal{H}_{t-1} \\right] \\right]\n$$\n给定历史 $\\mathcal{H}_{t-1}$，$\\theta_t$ 是固定的。样本 $X_{t,i}$ 是从 $q(\\cdot; \\theta_t)$ 中抽取的。因此，内部期望是：\n$$\nE\\left[ \\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)} \\bigg| \\mathcal{H}_{t-1} \\right] = \\int_{\\mathcal{D}} \\frac{f(x)}{q(x; \\theta_t)} q(x; \\theta_t) \\, dx = I\n$$\n由于 $I$ 是一个常数，外部期望是 $E_{\\mathcal{H}_{t-1}}[I] = I$。这对每个样本 $(t,i)$ 都成立。根据期望的线性性质，最终估计器的期望是：\n$$\nE[\\hat{I}] = \\frac{1}{N_{total}} \\sum_{t=1}^T \\sum_{i=1}^M E\\left[\\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)}\\right] = \\frac{1}{N_{total}} \\sum_{t=1}^T \\sum_{i=1}^M I = \\frac{N_{total} \\cdot I}{N_{total}} = I\n$$\n因此，该估计器被证明是无偏的，满足了一个关键要求。\n\n问题陈述中没有指定参数 $\\theta_t$ 的自适应机制。一种标准的、有原则的方法是基于前一次迭代样本的加权矩来更新参数。这使得提议分布能够逐渐更好地逼近被积函数 $f(x)$ 的形状。\n\n对于迭代 $t = 1, \\dots, T-1$，我们如下更新 $\\theta_t$ 到 $\\theta_{t+1}$：\n$1$. 在迭代 $t$，我们有从 $q(\\cdot; \\theta_t)$ 抽取的样本 $\\{X_{t,i}\\}_{i=1}^M$。\n$2$. 我们计算这些样本的重要性权重：$w_{t,i} = \\frac{f(X_{t,i})}{q(X_{t,i}; \\theta_t)}$。\n$3$. 我们将这些权重归一化以形成一个离散概率分布：$\\bar{w}_{t,i} = \\frac{w_{t,i}}{\\sum_{j=1}^M w_{t,j}}$。如果所有权重都为零，我们不更新参数，设置 $\\theta_{t+1} = \\theta_t$。\n$4$. 我们使用样本的加权均值和加权方差来计算新参数 $\\theta_{t+1} = (\\mu_{t+1}, \\sigma_{t+1})$。\n\n具体的更新规则取决于提议分布族：\n- 对于 $\\mathcal{D} = \\mathbb{R}$ 和提议分布族 $q(x; \\theta) = \\mathcal{N}(\\mu, \\sigma^2)$：\n  $$\n  \\mu_{t+1} = \\sum_{i=1}^M \\bar{w}_{t,i} X_{t,i}\n  $$\n  $$\n  \\sigma_{t+1}^2 = \\sum_{i=1}^M \\bar{w}_{t,i} (X_{t,i} - \\mu_{t+1})^2\n  $$\n- 对于 $\\mathcal{D} = (0,\\infty)$ 和提议分布族 $q(x; \\theta) = \\mathrm{Lognormal}(\\mu, \\sigma^2)$：\n  这里，$\\log(X) \\sim \\mathcal{N}(\\mu, \\sigma^2)$。我们自适应底层正态分布的参数 $\\mu$ 和 $\\sigma$。令 $Y_{t,i} = \\log(X_{t,i})$。\n  $$\n  \\mu_{t+1} = \\sum_{i=1}^M \\bar{w}_{t,i} Y_{t,i}\n  $$\n  $$\n  \\sigma_{t+1}^2 = \\sum_{i=1}^M \\bar{w}_{t,i} (Y_{t,i} - \\mu_{t+1})^2\n  $$\n\n为确保数值稳定性并防止提议分布退化，计算出的方差 $\\sigma_{t+1}^2$ 将被限制在一个小的正最小值，例如 $10^{-9}$。\n\n每个测试用例的总体算法如下：\n$1$. 根据问题陈述初始化参数 $\\theta_1 = \\theta_0$。\n$2$. 初始化一个空列表，用于存储所有样本的值 $v_{t,i} = f(X_{t,i})/q(X_{t,i}; \\theta_t)$。\n$3$. 对于 $t = 1, \\dots, T$：\n    a. 从提议分布 $q(\\cdot; \\theta_t)$ 中抽取 $M$ 个样本 $\\{X_{t,i}\\}_{i=1}^M$。\n    b. 对于每个样本 $X_{t,i}$，计算 $v_{t,i}$ 并将其追加到值列表中。\n    c. 如果 $t  T$，计算权重 $\\{w_{t,i}\\}_{i=1}^M$ 并使用上述加权矩公式更新 $\\theta_{t+1} = (\\mu_{t+1}, \\sigma_{t+1})$。\n$4$. 循环结束后，通过取所有存储值 $v_{t,i}$ 的算术平均值来计算最终估计值 $\\hat{I}$。\n\n这个设计在科学上是合理的，直接解决了问题的所有约束，并依赖于蒙特卡洛方法的既定原则。实现将使用 `numpy` 进行数值运算和随机数生成，并使用 `scipy.stats` 获取概率密度函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm, lognorm\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive importance sampling for all test cases.\n    \"\"\"\n\n    # Define the integrands for each case.\n    def f1(x):\n        return np.exp(-0.5 * (x - 2.0)**2)\n\n    def f2(x):\n        return (x**2) * np.exp(-x)\n\n    def f3(x):\n        term1 = 0.5 * np.exp(-(x - 3.0)**2 / (2.0 * 0.2**2))\n        term2 = 0.5 * np.exp(-(x + 3.0)**2 / (2.0 * 0.2**2))\n        return term1 + term2\n\n    def f4(x):\n        return np.exp(-0.5 * (x - 8.0)**2)\n\n    integrands = [f1, f2, f3, f4]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"id\": 1,\n            \"domain\": \"R\",\n            \"integrand\": integrands[0],\n            \"T\": 5,\n            \"M\": 4000,\n            \"theta0\": (0.0, 1.5),\n            \"seed\": 123\n        },\n        {\n            \"id\": 2,\n            \"domain\": \"(0,inf)\",\n            \"integrand\": integrands[1],\n            \"T\": 5,\n            \"M\": 4000,\n            \"theta0\": (0.0, 1.0),\n            \"seed\": 456\n        },\n        {\n            \"id\": 3,\n            \"domain\": \"R\",\n            \"integrand\": integrands[2],\n            \"T\": 6,\n            \"M\": 3000,\n            \"theta0\": (0.0, 1.0),\n            \"seed\": 789\n        },\n        {\n            \"id\": 4,\n            \"domain\": \"R\",\n            \"integrand\": integrands[3],\n            \"T\": 5,\n            \"M\": 3000,\n            \"theta0\": (0.0, 1.0),\n            \"seed\": 321\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_adaptive_is(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\n\ndef run_adaptive_is(case_params):\n    \"\"\"\n    Runs the adaptive importance sampling simulation for a single test case.\n    \"\"\"\n    T = case_params[\"T\"]\n    M = case_params[\"M\"]\n    theta0 = case_params[\"theta0\"]\n    seed = case_params[\"seed\"]\n    f = case_params[\"integrand\"]\n    domain = case_params[\"domain\"]\n\n    rng = np.random.default_rng(seed)\n    \n    theta_current = theta0\n    all_values = []\n    \n    # Minimum variance to prevent proposal collapse\n    MIN_VAR = 1e-9\n\n    for t in range(T):\n        mu, sigma = theta_current\n        \n        # 1. Sample from the proposal distribution q_t\n        if domain == \"R\":\n            # Gaussian proposal\n            samples = rng.normal(loc=mu, scale=sigma, size=M)\n            q_pdf_values = norm.pdf(samples, loc=mu, scale=sigma)\n        elif domain == \"(0,inf)\":\n            # Lognormal proposal\n            # scipy.stats.lognorm(s=sigma, scale=exp(mu)) corresponds to log X ~ N(mu, sigma^2)\n            samples = rng.lognormal(mean=mu, sigma=sigma, size=M)\n            q_pdf_values = lognorm.pdf(samples, s=sigma, scale=np.exp(mu))\n        \n        # 2. Compute integrand values and raw estimator terms\n        f_values = f(samples)\n        \n        # Avoid division by zero if q_pdf_values is zero for some reason\n        # and f_values is non-zero (unlikely if support condition holds).\n        # We also handle cases where f(x)=0, making weights zero.\n        with np.errstate(divide='ignore', invalid='ignore'):\n            values = np.divide(f_values, q_pdf_values)\n            values[q_pdf_values == 0] = 0.0 # If f>0 but q=0, results in Inf. True estimator requires q>0.\n        \n        all_values.extend(values)\n\n        # 3. Adapt parameters for the next iteration (if not the last one)\n        if t  T - 1:\n            weights = values  # In this formulation, weights are the same as values\n            \n            sum_weights = np.sum(weights)\n\n            if sum_weights > 0 and np.isfinite(sum_weights):\n                normalized_weights = weights / sum_weights\n                \n                if domain == \"R\":\n                    # Update parameters for Gaussian proposal\n                    new_mu = np.sum(normalized_weights * samples)\n                    new_var = np.sum(normalized_weights * (samples - new_mu)**2)\n                    new_sigma = np.sqrt(max(new_var, MIN_VAR))\n                    theta_current = (new_mu, new_sigma)\n                elif domain == \"(0,inf)\":\n                    # Update parameters for Lognormal proposal (in log-space)\n                    log_samples = np.log(samples)\n                    new_mu_log = np.sum(normalized_weights * log_samples)\n                    new_var_log = np.sum(normalized_weights * (log_samples - new_mu_log)**2)\n                    new_sigma_log = np.sqrt(max(new_var_log, MIN_VAR))\n                    theta_current = (new_mu_log, new_sigma_log)\n            # If sum_weights is zero or non-finite, we don't update theta.\n            # This happens if all samples land where f(x) is zero.\n\n    # 4. Compute the final estimate\n    final_estimate = np.mean(all_values)\n    return final_estimate\n\nsolve()\n```", "id": "2449255"}]}