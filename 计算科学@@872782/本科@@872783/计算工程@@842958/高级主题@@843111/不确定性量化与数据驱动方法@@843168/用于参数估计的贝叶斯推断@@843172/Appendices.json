{"hands_on_practices": [{"introduction": "这个练习将带领我们应用贝叶斯推断来解决一个实际的工程问题：从带有噪声的实验数据中估计热接触电阻。我们将结合傅里叶热传导定律建立的物理模型与高斯噪声假设，通过数值方法计算参数的后验分布。这项实践[@problem_id:2374140]旨在让你掌握将物理模型与贝叶斯框架相结合的基本流程，并为更复杂的参数估计问题打下坚实的基础。", "problem": "考虑一个涉及两个固体接触的一维稳态热传导实验。界面处微观粗糙度的净效应被建模为接触热阻，记作 $R$，单位为 $\\mathrm{m^2\\,K/W}$。在通过界面的均匀热通量 $q$（单位为 $\\mathrm{W/m^2}$）作用下，跨界面的温降定义为 $\\Delta T = T^{-} - T^{+}$，其中 $T^{-}$ 和 $T^{+}$ 是两侧的极限界面温度。从傅里叶热传导定律和界面热阻的定义出发，界面跳跃条件为跨界面的温降满足 $\\Delta T = q\\,R$。\n\n在实践中，测量是有噪声的。假设第 $i$ 个实验条件观测到的温降 $\\Delta T_i^{\\mathrm{obs}}$ 服从一个加性高斯噪声模型\n$$\n\\Delta T_i^{\\mathrm{obs}} = q_i\\,R + \\varepsilon_i,\\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma^2),\n$$\n其测量噪声标准差 $\\sigma$（单位为 $\\mathrm{K}$）已知。给定 $R$ 时，各次测量是条件独立的。对 $R$ 采用一个由对数正态分布给出的严格正先验：$R \\sim \\mathrm{LogNormal}(\\mu_0, s_0^2)$，意味着 $\\ln R \\sim \\mathcal{N}(\\mu_0, s_0^2)$。使用自然对数。对数正态先验密度为\n$$\n\\pi(R) = \\frac{1}{R\\,s_0\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln R - \\mu_0)^2}{2 s_0^2}\\right),\\quad R>0。\n$$\n\n您的任务是通过计算后验均值\n$$\n\\mathbb{E}[R \\mid \\{\\Delta T_i^{\\mathrm{obs}}, q_i\\}_{i=1}^{n}],\n$$\n从数据中执行贝叶斯推断来估计 $R$，方法是在对数间隔网格上对 $R \\in [R_{\\min}, R_{\\max}]$ 进行数值积分。使用贝叶斯法则在该网格上构建未归一化的后验密度，对其进行数值归一化，然后通过数值求积计算后验均值。所有计算必须在国际单位制（SI）中进行。将 $R$ 的最终估计值以普通十进制浮点数形式表示，单位为 $\\mathrm{m^2\\,K/W}$。\n\n建模基本依据：\n- 一维稳态传导的傅里叶定律：$q = -k\\,\\mathrm{d}T/\\mathrm{d}x$。\n- 源于接触热阻定义的界面跳跃条件：温降与热通量成正比，比例系数为 $R$，因此 $\\Delta T = q\\,R$。\n- 温降的独立高斯测量误差，导致高斯似然。\n\n实现要求：\n- 使用对数间隔网格，其中 $R_{\\min} = 10^{-6}\\,\\mathrm{m^2\\,K/W}$ 和 $R_{\\max} = 10^{-2}\\,\\mathrm{m^2\\,K/W}$。网格必须足够密集以产生稳定的数值积分。\n- 计算每个网格点上的未归一化对数后验，其值为对数先验与对数似然之和，在进行指数化之前减去最大对数后验值以保证稳定，然后使用关于 $R$ 的数值求积法则进行归一化。\n- 计算后验均值 $\\mathbb{E}[R \\mid \\text{data}]$，其值为两个关于 $R$ 的数值积分之比：$R$ 乘以以后验密度的积分除以后验密度的积分。\n\n先验参数：\n- $\\mu_0 = \\ln(1.5\\times 10^{-4})$，\n- $s_0 = 0.5$。\n\n测试套件：\n对于下述每个测试用例，使用指定的 $\\{q_i\\}$ 数组（单位 $\\mathrm{W/m^2}$）、观测到的温降 $\\{\\Delta T_i^{\\mathrm{obs}}\\}$（单位 $\\mathrm{K}$）以及噪声标准差 $\\sigma$（单位 $\\mathrm{K}$）。\n\n- 情况 $1$（良态，多热通量水平）：\n  - $q = [1.00\\times 10^{4},\\, 1.20\\times 10^{4},\\, 0.80\\times 10^{4},\\, 1.50\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [2.12,\\, 2.45,\\, 1.50,\\, 3.08]$,\n  - $\\sigma = 0.10$。\n- 情况 $2$（更宽的热通量范围）：\n  - $q = [0.50\\times 10^{4},\\, 2.00\\times 10^{4},\\, 3.00\\times 10^{4},\\, 4.00\\times 10^{4},\\, 1.00\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [0.58,\\, 2.47,\\, 3.55,\\, 4.95,\\, 1.21]$,\n  - $\\sigma = 0.10$。\n- 情况 $3$（边缘情况：信息量低，单一低热通量，较大噪声）：\n  - $q = [0.20\\times 10^{4}]$,\n  - $\\Delta T^{\\mathrm{obs}} = [0.64]$,\n  - $\\sigma = 0.30$。\n\n角度单位不适用。此问题中不含百分比。\n\n您的程序必须输出一行，其中包含对应于三种情况的三个 $R$ 的后验均值估计值，格式为逗号分隔的 Python 风格列表，并用方括号括起，例如 $[r_1,r_2,r_3]$，其中每个 $r_i$ 是一个单位为 $\\mathrm{m^2\\,K/W}$ 的浮点数。", "solution": "问题陈述已经过分析并被认为是有效的。这是一个适定的贝叶斯参数估计问题，基于热传递和统计推断的原理。所提供的数据和模型在科学上是合理的、完整的且一致的。我们将继续进行推导和数值求解。\n\n目标是给定一组 $n$ 次带噪声的测量值，计算接触热阻 $R$ 的后验均值。该问题由以下几个部分定义：\n\n1.  **物理模型：** 跨界面的温降 $\\Delta T$ 通过 $\\Delta T = qR$ 与热通量 $q$ 相关。\n2.  **观测模型：** 对于第 $i$ 次测量，观测到的温降 $\\Delta T_i^{\\mathrm{obs}}$ 被建模为 $\\Delta T_i^{\\mathrm{obs}} = q_i R + \\varepsilon_i$，其中噪声项 $\\varepsilon_i$ 从均值为 $0$、已知方差为 $\\sigma^2$ 的正态分布中抽取，即 $\\varepsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n3.  **先验分布：** 参数 $R$ 假定为严格正数。为其指定一个对数正态先验：$R \\sim \\mathrm{LogNormal}(\\mu_0, s_0^2)$，这意味着 $\\ln R \\sim \\mathcal{N}(\\mu_0, s_0^2)$。\n\n令收集到的数据表示为 $\\mathcal{D} = \\{\\Delta T_i^{\\mathrm{obs}}, q_i\\}_{i=1}^{n}$。我们的目标是计算 $R$ 的后验均值：\n$$\n\\mathbb{E}[R \\mid \\mathcal{D}] = \\int_0^\\infty R \\, p(R \\mid \\mathcal{D}) \\, dR\n$$\n其中 $p(R \\mid \\mathcal{D})$ 是 $R$ 的后验概率密度函数。\n\n根据贝叶斯定理，后验密度与似然和先验密度的乘积成正比：\n$$\np(R \\mid \\mathcal{D}) \\propto p(\\mathcal{D} \\mid R) \\, \\pi(R)\n$$\n其中 $p(\\mathcal{D} \\mid R)$ 是似然，$\\pi(R)$ 是先验。\n\n**似然函数**\n根据观测模型，每次测量 $\\Delta T_i^{\\mathrm{obs}}$ 都是从正态分布 $\\mathcal{N}(q_i R, \\sigma^2)$ 中独立抽取的。单次观测的概率密度为：\n$$\np(\\Delta T_i^{\\mathrm{obs}} \\mid R) = \\frac{1}{\\sigma\\sqrt{2\\pi}} \\exp\\left( -\\frac{(\\Delta T_i^{\\mathrm{obs}} - q_i R)^2}{2\\sigma^2} \\right)\n$$\n由于给定 $R$ 时各次测量是条件独立的，数据集 $\\mathcal{D}$ 的总似然是各独立密度的乘积：\n$$\np(\\mathcal{D} \\mid R) = \\prod_{i=1}^n p(\\Delta T_i^{\\mathrm{obs}} \\mid R)\n$$\n为了数值稳定性，我们使用对数似然。在忽略一个与 $R$ 无关的加性常数的情况下，对数似然为：\n$$\n\\ln p(\\mathcal{D} \\mid R) \\propto -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}} - q_i R)^2\n$$\n\n**先验分布**\n$R$ 的先验是一个参数为 $\\mu_0$ 和 $s_0^2$ 的对数正态分布，其密度函数由下式给出：\n$$\n\\pi(R) = \\frac{1}{R\\,s_0\\sqrt{2\\pi}} \\exp\\left(-\\frac{(\\ln R - \\mu_0)^2}{2 s_0^2}\\right) \\quad \\text{for } R > 0\n$$\n在忽略一个加性常数的情况下，对数先验为：\n$$\n\\ln \\pi(R) \\propto -\\ln R - \\frac{(\\ln R - \\mu_0)^2}{2s_0^2}\n$$\n\n**后验分布**\n未归一化的对数后验是对数似然和对数先验之和：\n$$\n\\ln p(R \\mid \\mathcal{D}) \\propto -\\frac{1}{2\\sigma^2} \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}} - q_i R)^2 - \\ln R - \\frac{(\\ln R - \\mu_0)^2}{2s_0^2}\n$$\n\n**数值计算**\n后验均值通过在 $R$ 的离散化网格上进行数值求积来计算。我们定义一个覆盖区间 $[R_{\\min}, R_{\\max}]$ 的点网格 $\\{R_j\\}$。问题指定了使用对数间隔网格。\n\n后验均值是两个积分的比值：\n$$\n\\mathbb{E}[R \\mid \\mathcal{D}] = \\frac{\\int_{R_{\\min}}^{R_{\\max}} R \\, p_{\\text{unnorm}}(R \\mid \\mathcal{D}) \\, dR}{\\int_{R_{\\min}}^{R_{\\max}} p_{\\text{unnorm}}(R \\mid \\mathcal{D}) \\, dR}\n$$\n其中 $p_{\\text{unnorm}}(R \\mid \\mathcal{D}) = \\exp(\\ln p_{\\text{unnorm}}(R \\mid \\mathcal{D}))$ 是未归一化的后验密度。\n\n算法步骤如下：\n1.  定义一个从 $R_{\\min} = 10^{-6}$ 到 $R_{\\max} = 10^{-2}$ 的对数间隔网格，包含 $N_{grid}$ 个点 $\\{R_j\\}$。\n2.  为提高计算效率，预先计算似然项所需的和：$S_{qq} = \\sum_{i=1}^n q_i^2$，$S_{qT} = \\sum_{i=1}^n q_i \\Delta T_i^{\\mathrm{obs}}$，以及 $S_{TT} = \\sum_{i=1}^n (\\Delta T_i^{\\mathrm{obs}})^2$。对数似然项变为 $-\\frac{1}{2\\sigma^2}(S_{TT} - 2R S_{qT} + R^2 S_{qq})$。\n3.  在每个网格点 $R_j$ 处，评估未归一化的对数后验 $\\mathcal{L}(R_j)$。\n4.  为防止指数化过程中的数值下溢，通过减去其最大值来稳定对数后验：$\\mathcal{L}_{\\text{stab}}(R_j) = \\mathcal{L}(R_j) - \\max_j\\{\\mathcal{L}(R_j)\\}$。\n5.  计算网格上的未归一化后验值：$p_{\\text{unnorm}}(R_j) = \\exp(\\mathcal{L}_{\\text{stab}}(R_j))$。\n6.  使用梯形法则在非均匀网格 $\\{R_j\\}$ 上近似计算分子和分母（归一化常数）的积分。令 $P_j = p_{\\text{unnorm}}(R_j)$。\n    - 归一化常数：$Z = \\int p_{\\text{unnorm}}(R) \\, dR \\approx \\text{trapz}(\\{P_j\\}, \\{R_j\\})$。\n    - 分子积分：$N = \\int R \\, p_{\\text{unnorm}}(R) \\, dR \\approx \\text{trapz}(\\{R_j \\cdot P_j\\}, \\{R_j\\})$。\n7.  然后后验均值计算为 $\\mathbb{E}[R \\mid \\mathcal{D}] \\approx N/Z$。\n\n此过程将应用于所提供的三个测试用例中的每一个。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import trapezoid\n\ndef solve():\n    \"\"\"\n    Main function to solve the Bayesian inference problem for all test cases.\n    \"\"\"\n    # Prior parameters\n    mu_0 = np.log(1.5e-4) # mu_0 = ln(1.5 * 10^-4)\n    s_0 = 0.5            # s_0 = 0.5\n\n    # Numerical integration parameters\n    R_min = 1e-6         # R_min = 10^-6 m^2K/W\n    R_max = 1e-2         # R_max = 10^-2 m^2K/W\n    N_grid = 20001       # Number of grid points for integration\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"q\": np.array([1.00e4, 1.20e4, 0.80e4, 1.50e4]), # W/m^2\n            \"delta_T_obs\": np.array([2.12, 2.45, 1.50, 3.08]), # K\n            \"sigma\": 0.10, # K\n        },\n        {\n            \"q\": np.array([0.50e4, 2.00e4, 3.00e4, 4.00e4, 1.00e4]), # W/m^2\n            \"delta_T_obs\": np.array([0.58, 2.47, 3.55, 4.95, 1.21]), # K\n            \"sigma\": 0.10, # K\n        },\n        {\n            \"q\": np.array([0.20e4]), # W/m^2\n            \"delta_T_obs\": np.array([0.64]), # K\n            \"sigma\": 0.30, # K\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_posterior_mean(\n            case[\"q\"],\n            case[\"delta_T_obs\"],\n            case[\"sigma\"],\n            mu_0,\n            s_0,\n            R_min,\n            R_max,\n            N_grid\n        )\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{r:.10f}' for r in results)}]\")\n\ndef compute_posterior_mean(q, delta_T_obs, sigma, mu_0, s_0, R_min, R_max, N_grid):\n    \"\"\"\n    Computes the posterior mean of R using numerical integration.\n\n    Args:\n        q (np.ndarray): Array of heat flux values [W/m^2].\n        delta_T_obs (np.ndarray): Array of observed temperature drops [K].\n        sigma (float): Standard deviation of measurement noise [K].\n        mu_0 (float): Mean of the logarithm of R for the Log-Normal prior.\n        s_0 (float): Standard deviation of the logarithm of R for the Log-Normal prior.\n        R_min (float): Minimum value for the integration grid for R [m^2K/W].\n        R_max (float): Maximum value for the integration grid for R [m^2K/W].\n        N_grid (int): Number of points in the integration grid.\n\n    Returns:\n        float: The posterior mean of R [m^2K/W].\n    \"\"\"\n    # 1. Create a logarithmically spaced grid for R.\n    R_grid = np.logspace(np.log10(R_min), np.log10(R_max), N_grid)\n\n    # 2. Compute log-likelihood.\n    # Pre-calculate summary statistics for efficiency.\n    S_qq = np.sum(q**2)\n    S_qT = np.sum(q * delta_T_obs)\n    S_TT = np.sum(delta_T_obs**2)\n    \n    # The term in the likelihood sum is a quadratic in R: S_TT - 2*R*S_qT + R^2*S_qq\n    likelihood_quadratic = S_TT - 2 * R_grid * S_qT + R_grid**2 * S_qq\n    log_likelihood = -0.5 / (sigma**2) * likelihood_quadratic\n\n    # 3. Compute log-prior.\n    log_R_grid = np.log(R_grid)\n    log_prior = -log_R_grid - (log_R_grid - mu_0)**2 / (2 * s_0**2)\n\n    # 4. Compute unnormalized log-posterior.\n    log_posterior = log_likelihood + log_prior\n    \n    # 5. Stabilize log-posterior to avoid numerical underflow.\n    log_posterior_stable = log_posterior - np.max(log_posterior)\n    \n    # 6. Exponentiate to get unnormalized posterior.\n    posterior_unnorm = np.exp(log_posterior_stable)\n\n    # 7. Compute integrals using the trapezoidal rule.\n    # Numerator integral: integral of R * posterior(R) dR\n    numerator_integral = trapezoid(R_grid * posterior_unnorm, R_grid)\n    \n    # Denominator integral (normalization constant): integral of posterior(R) dR\n    norm_constant = trapezoid(posterior_unnorm, R_grid)\n\n    # 8. Compute the posterior mean.\n    posterior_mean = numerator_integral / norm_constant\n\n    return posterior_mean\n\nsolve()\n```", "id": "2374140"}, {"introduction": "在许多工程应用中，我们不仅需要估计模型的关键参数，还需要同时量化测量噪声的不确定性。这个练习[@problem_id:2374101]将带你进入贝叶斯线性回归的世界，同时估计回归系数和未知的噪声方差 $\\sigma^2$。你将学习并应用共轭先验（正态-逆伽马分布）这一强大工具，它能使后验分布具有解析形式，从而优雅地得到参数的估计值，深刻理解贝叶斯分析的数学之美。", "problem": "给定一个信号加噪声模型，其中观测数据 $\\{(x_i, y_i)\\}_{i=1}^n$ 满足\n$y_i = f(x_i; \\theta) + \\epsilon_i$，\n其中 $\\epsilon_i$ 是独立同分布的高斯噪声项，均值为 $0$，方差 $\\sigma^2$ 未知。考虑参数化情况，其中 $f$ 对参数是线性的，具体为 $f(x_i; \\theta) = \\theta_0 + \\theta_1 x_i$，且 $\\theta = [\\theta_0, \\theta_1]^\\top$。\n\n任务是执行贝叶斯推断，以同时估计参数 $\\theta$ 和噪声方差 $\\sigma^2$。使用一个共轭正态-逆伽马先验，其定义如下：\n- 给定方差时参数的条件先验：$\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 S_0)$，其中 $m_0 \\in \\mathbb{R}^2$ 且 $S_0 \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵。\n- 方差的先验：$\\sigma^2 \\sim \\text{Inverse-Gamma}(\\alpha_0, \\beta_0)$，其中逆伽马分布的密度为 $p(\\sigma^2 \\mid \\alpha, \\beta) \\propto (\\sigma^2)^{-(\\alpha+1)} \\exp(-\\beta/\\sigma^2)$，对于 $\\sigma^2 > 0$。\n\n您的任务是：\n- 仅从贝叶斯定理、独立观测的高斯似然、多元正态分布的定义和逆伽马分布的定义出发，推导 $(\\theta, \\sigma^2)$ 的后验分布（忽略归一化常数）。避免依赖任何无法从这些基础推导出的预记公式。\n- 基于您的推导，设计一个算法来计算后验均值 $\\mathbb{E}[\\theta \\mid \\mathcal{D}]$ 和 $\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}]$，其中 $\\mathcal{D}$ 表示数据集。将这些均值完全用先验超参数、数据和基本的线性代数运算来表示。\n- 实现一个完整、可运行的程序，该程序对以下测试套件中的每个数据集，计算并输出 $\\theta_0$、$\\theta_1$ 和 $\\sigma^2$ 的后验均值。所有输出必须是保留 $6$ 位小数的实数。\n\n对所有测试用例使用以下先验超参数：\n- $m_0 = [0, 0]^\\top$，\n- $S_0 = \\mathrm{diag}(100, 100)$，\n- $\\alpha_0 = 2$，\n- $\\beta_0 = 1$。\n\n测试套件（每个用例提供观测输入 $x$ 和输出 $y$）：\n- A 用例（良态，中等噪声）：\n  - $x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]$,\n  - $y = [1.5, 0.9, 0.04, -0.58, -1.34, -1.92, -2.72, -3.34, -4.18, -4.76]$。\n- B 用例（小样本，几乎只有噪声）：\n  - $x = [0.0, 0.1, 0.2]$,\n  - $y = [0.002, -0.001, 0.0005]$。\n- C 用例（中等斜率，中等噪声，轻度杠杆效应）：\n  - $x = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]$,\n  - $y = [2.03, 2.44, 3.015, 3.5, 4.06, 4.47, 4.985, 5.545]$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。\n- 对每个用例，按 $\\mathbb{E}[\\theta_0 \\mid \\mathcal{D}]$、$\\mathbb{E}[\\theta_1 \\mid \\mathcal{D}]$、$\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}]$ 的顺序报告后验均值。\n- 按 A 用例、B 用例、C 用例的顺序连接结果，形成一个包含 $9$ 个数字的单层列表。\n- 每个数字必须保留 $6$ 位小数。\n- 结构模板示例（非实际值）：$[a_1,a_2,a_3,a_4,a_5,a_6,a_7,a_8,a_9]$。", "solution": "该问题要求推导并实现一个用于带高斯噪声的线性模型参数的贝叶斯推断算法。分析必须从第一性原理出发。\n\n设观测数据为 $\\mathcal{D} = \\{ (x_i, y_i) \\}_{i=1}^n$。模型由 $y_i = \\theta_0 + \\theta_1 x_i + \\epsilon_i$ 给出，其中噪声项 $\\epsilon_i$ 独立同分布于均值为 $0$、方差 $\\sigma^2$ 未知的高斯分布，即 $\\epsilon_i \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n该模型可以表示为向量形式。令 $y = [y_1, \\dots, y_n]^\\top$ 为观测向量，$\\theta = [\\theta_0, \\theta_1]^\\top$ 为参数向量，$X$ 为 $n \\times 2$ 的设计矩阵，其中第 $i$ 行为 $[1, x_i]$。则模型为 $y = X\\theta + \\epsilon$，其中 $\\epsilon \\sim \\mathcal{N}(0, \\sigma^2 I_n)$，$I_n$ 是 $n \\times n$ 的单位矩阵。\n\n在给定参数 $\\theta$ 和方差 $\\sigma^2$ 的条件下，数据的似然是模型下观测到 $y$ 的概率密度：\n$$\np(y \\mid X, \\theta, \\sigma^2) = (2\\pi\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y - X\\theta)^\\top(y - X\\theta)\\right)\n$$\n\n该问题为 $(\\theta, \\sigma^2)$ 指定了一个共轭正态-逆伽马先验。联合先验分布 $p(\\theta, \\sigma^2)$ 分解为 $p(\\theta \\mid \\sigma^2)p(\\sigma^2)$。\n$\\theta$ 的条件先验是一个多元正态分布，$\\theta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 S_0)$，其中 $k=2$ 是 $\\theta$ 的维度：\n$$\np(\\theta \\mid \\sigma^2) = (2\\pi\\sigma^2)^{-k/2} |\\det(S_0)|^{-1/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)\\right)\n$$\n方差 $\\sigma^2$ 的先验是一个逆伽马分布，$\\sigma^2 \\sim \\text{Inverse-Gamma}(\\alpha_0, \\beta_0)$，其指定的密度为：\n$$\np(\\sigma^2) \\propto (\\sigma^2)^{-(\\alpha_0+1)} \\exp(-\\beta_0/\\sigma^2)\n$$\n\n根据贝叶斯定理，参数的联合后验分布与似然和先验的乘积成正比：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto p(y \\mid X, \\theta, \\sigma^2) p(\\theta \\mid \\sigma^2) p(\\sigma^2)\n$$\n对于给定的数据集 $\\mathcal{D}=(X,y)$，代入表达式：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto \\left[ (\\sigma^2)^{-n/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(y - X\\theta)^\\top(y - X\\theta)\\right) \\right] \\times \\left[ (\\sigma^2)^{-k/2} \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)\\right) \\right] \\times \\left[ (\\sigma^2)^{-(\\alpha_0+1)} \\exp(-\\beta_0/\\sigma^2) \\right]\n$$\n常数因子 $(2\\pi)^{-n/2}$、$(2\\pi)^{-k/2}$ 和 $|\\det(S_0)|^{-1/2}$ 被吸收到比例常数中。合并各项得到：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ (y - X\\theta)^\\top(y - X\\theta) + (\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0) + 2\\beta_0 \\right] \\right\\}\n$$\n为了识别后验分布的结构，我们分析指数中关于 $\\theta$ 的二次项。设该二次型为 $Q(\\theta) = (y - X\\theta)^\\top(y - X\\theta) + (\\theta - m_0)^\\top S_0^{-1}(\\theta - m_0)$。展开并收集关于 $\\theta$ 的项：\n$$\n\\begin{aligned}\nQ(\\theta) = (y^\\top y - 2y^\\top X \\theta + \\theta^\\top X^\\top X \\theta) + (\\theta^\\top S_0^{-1}\\theta - 2\\theta^\\top S_0^{-1}m_0 + m_0^\\top S_0^{-1}m_0) \\\\\n= \\theta^\\top(X^\\top X + S_0^{-1})\\theta - 2\\theta^\\top(X^\\top y + S_0^{-1}m_0) + y^\\top y + m_0^\\top S_0^{-1}m_0\n\\end{aligned}\n$$\n这个表达式可以对 $\\theta$ 进行配方。定义后验精度矩阵 $S_n^{-1}$ 和后验均值向量 $m_n$ 如下：\n$$\nS_n^{-1} = X^\\top X + S_0^{-1}\n$$\n$$\nm_n = (S_n^{-1})^{-1}(X^\\top y + S_0^{-1}m_0)\n$$\n注意 $S_n = (X^\\top X + S_0^{-1})^{-1}$。二次型 $Q(\\theta)$ 变为：\n$$\nQ(\\theta) = (\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n) - m_n^\\top S_n^{-1} m_n + y^\\top y + m_0^\\top S_0^{-1}m_0\n$$\n将此代回后验表达式中：\n$$\np(\\theta, \\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ (\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n) + y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n + 2\\beta_0 \\right] \\right\\}\n$$\n该表达式表明后验分布也具有正态-逆伽马形式。我们可以将其分解为 $p(\\theta, \\sigma^2 \\mid \\mathcal{D}) = p(\\theta \\mid \\sigma^2, \\mathcal{D}) p(\\sigma^2 \\mid \\mathcal{D})$。\n\n$\\theta$ 的条件后验分布为：\n$$\np(\\theta \\mid \\sigma^2, \\mathcal{D}) \\propto \\exp\\left(-\\frac{1}{2\\sigma^2}(\\theta - m_n)^\\top S_n^{-1}(\\theta - m_n)\\right)\n$$\n这是多元正态分布的核，$\\theta \\mid \\sigma^2, \\mathcal{D} \\sim \\mathcal{N}(m_n, \\sigma^2 S_n)$。\n\n$\\sigma^2$ 的边缘后验分布是通过对 $\\theta$ 积分得到的。通过识别高斯核的积分，我们发现：\n$$\np(\\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_0 + n/2 + k/2 + 1)} (\\sigma^2)^{k/2} \\exp\\left\\{ -\\frac{1}{2\\sigma^2} \\left[ 2\\beta_0 + y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n \\right] \\right\\}\n$$\n$$\np(\\sigma^2 \\mid \\mathcal{D}) \\propto (\\sigma^2)^{-(\\alpha_n+1)} \\exp(-\\beta_n/\\sigma^2)\n$$\n其中后验超参数 $\\alpha_n$ 和 $\\beta_n$ 为：\n$$\n\\alpha_n = \\alpha_0 + \\frac{n}{2}\n$$\n$$\n\\beta_n = \\beta_0 + \\frac{1}{2}\\left(y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1}m_n\\right)\n$$\n这是逆伽马分布的核，$\\sigma^2 \\mid \\mathcal{D} \\sim \\text{Inverse-Gamma}(\\alpha_n, \\beta_n)$。\n\n后验均值是根据这些分布的性质计算得出的。\n$\\theta$ 的后验均值使用全期望定律求得：\n$$\n\\mathbb{E}[\\theta \\mid \\mathcal{D}] = \\mathbb{E}[\\mathbb{E}[\\theta \\mid \\sigma^2, \\mathcal{D}]] = \\mathbb{E}[m_n] = m_n\n$$\n$\\sigma^2$ 的后验均值是 Inverse-Gamma$(\\alpha_n, \\beta_n)$ 分布的均值，当 $\\alpha_n > 1$ 时为 $\\frac{\\beta_n}{\\alpha_n - 1}$。给定 $\\alpha_0=2$ 和 $n \\ge 1$，则 $\\alpha_n = 2 + n/2 > 1$，因此该均值有明确定义。\n$$\n\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}] = \\frac{\\beta_n}{\\alpha_n - 1}\n$$\n\n计算后验均值的算法如下：\n1.  给定数据 $\\{ (x_i, y_i) \\}_{i=1}^n$ 和先验超参数 $m_0, S_0, \\alpha_0, \\beta_0$。\n2.  构建设计矩阵 $X$（大小为 $n \\times 2$）和观测向量 $y$（大小为 $n \\times 1$）。\n3.  计算 $S_0^{-1}$。\n4.  计算后验参数 $S_n^{-1} = X^\\top X + S_0^{-1}$。\n5.  计算 $\\theta$ 的后验均值：$m_n = (S_n^{-1})^{-1}(X^\\top y + S_0^{-1}m_0)$。这就得到了 $\\mathbb{E}[\\theta \\mid \\mathcal{D}]$。\n6.  计算后验参数 $\\alpha_n = \\alpha_0 + n/2$。\n7.  计算后验参数 $\\beta_n = \\beta_0 + \\frac{1}{2}(y^\\top y + m_0^\\top S_0^{-1}m_0 - m_n^\\top S_n^{-1} m_n)$。最后一项的一个计算上更简单的形式是 $m_n^\\top(X^\\top y + S_0^{-1}m_0)$。\n8.  计算 $\\sigma^2$ 的后验均值：$\\mathbb{E}[\\sigma^2 \\mid \\mathcal{D}] = \\frac{\\beta_n}{\\alpha_n - 1}$。\n\n这为计算所需的后验期望提供了一个完整且有原则的步骤。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs Bayesian inference for a linear model to estimate parameters\n    theta = [theta_0, theta_1] and noise variance sigma^2.\n    \"\"\"\n    # Prior hyperparameters\n    m0 = np.array([0.0, 0.0])\n    S0 = np.array([[100.0, 0.0], [0.0, 100.0]])\n    alpha0 = 2.0\n    beta0 = 1.0\n\n    # Test suite\n    test_cases = [\n        # Case A (well-conditioned, moderate noise)\n        {\n            \"x\": np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n            \"y\": np.array([1.5, 0.9, 0.04, -0.58, -1.34, -1.92, -2.72, -3.34, -4.18, -4.76]),\n        },\n        # Case B (small sample, near-noise-only)\n        {\n            \"x\": np.array([0.0, 0.1, 0.2]),\n            \"y\": np.array([0.002, -0.001, 0.0005]),\n        },\n        # Case C (moderate slope, moderate noise, mild leverage)\n        {\n            \"x\": np.array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5]),\n            \"y\": np.array([2.03, 2.44, 3.015, 3.5, 4.06, 4.47, 4.985, 5.545]),\n        },\n    ]\n\n    results = []\n\n    # Pre-compute S0 inverse\n    S0_inv = np.linalg.inv(S0)\n\n    for case in test_cases:\n        x_data = case[\"x\"]\n        y_data = case[\"y\"]\n        n = len(x_data)\n\n        # 1. Construct design matrix X and observation vector y\n        X = np.vstack((np.ones(n), x_data)).T\n        y = y_data.reshape(-1, 1)\n\n        # 2. Compute components for posterior updates\n        XTX = X.T @ X\n        XTy = X.T @ y\n\n        # 3. Compute posterior hyperparameters for theta\n        Sn_inv = XTX + S0_inv\n        Sn = np.linalg.inv(Sn_inv)\n        \n        # S0_inv @ m0 is a zero vector since m0 is zero\n        mn = Sn @ XTy\n        \n        # 4. Compute posterior hyperparameters for sigma^2\n        alpha_n = alpha0 + n / 2.0\n        \n        # y.T @ y + m0.T @ S0_inv @ m0 - mn.T @ Sn_inv @ mn\n        # The m0 term is zero\n        # The term mn.T @ Sn_inv @ mn simplifies to mn.T @ (XTy + S0_inv @ m0)\n        # which is mn.T @ XTy since m0 is zero\n        yTy = y.T @ y\n        mnT_Sn_inv_mn = mn.T @ XTy\n        \n        beta_n = beta0 + 0.5 * (yTy - mnT_Sn_inv_mn)\n\n        # 5. Compute posterior means\n        E_theta = mn\n        E_sigma2 = beta_n / (alpha_n - 1)\n\n        # Append results rounded to 6 decimal places\n        results.append(f\"{E_theta[0, 0]:.6f}\")\n        results.append(f\"{E_theta[1, 0]:.6f}\")\n        results.append(f\"{E_sigma2[0, 0]:.6f}\")\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2374101"}, {"introduction": "最后，我们将挑战一个更前沿的课题：从混沌系统的观测数据中反推其内在参数。在这个练习[@problem_id:2374071]中，模型的建立涉及到求解洛伦兹系统的常微分方程（ODEs），这使得似然函数的计算变得非常昂贵。通过在参数空间上进行网格搜索，你将体验到贝叶斯方法在处理复杂非线性动力学系统时的强大威力，这也是计算工程领域中进行模型校准和验证的核心技术之一。", "problem": "给定一个由确定性连续时间动力学系统（即 Lorenz 系统）生成的单个状态变量的短时含噪时间序列。Lorenz 系统由以下常微分方程定义：\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\n其中 $\\sigma$、$\\rho$ 和 $\\beta$ 是未知的正参数。您将仅在离散时间点上观测存在加性噪声的 $x$ 分量。假设观测模型为\n$$\ny_i = x(t_i \\mid \\sigma,\\rho,\\beta) + \\varepsilon_i, \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\tau^2),\n$$\n其中噪声标准差 $\\tau$、初始条件 $(x(0),y(0),z(0))$ 以及均匀时间步长 $\\Delta t$ 均已知，因此 $t_i = i \\Delta t$。前向映射 $(\\sigma,\\rho,\\beta) \\mapsto x(t_i \\mid \\sigma,\\rho,\\beta)$ 的定义为：从初始条件出发，在指定的时间网格上对 Lorenz 系统进行数值积分。对于数值积分，请使用步长等于 $\\Delta t$ 的定步长四阶 Runge–Kutta 方法。\n\n假设参数的先验分布为独立的均匀分布：\n$$\n\\sigma \\sim \\mathrm{Uniform}([5,15]), \\quad \\rho \\sim \\mathrm{Uniform}([0,40]), \\quad \\beta \\sim \\mathrm{Uniform}([2,3])。\n$$\n使用张量积参数网格，其中 $n_\\sigma = 11$ 个线性间隔点覆盖 $[5,15]$，$n_\\rho = 17$ 个线性间隔点覆盖 $[0,40]$，以及 $n_\\beta = 11$ 个线性间隔点覆盖 $[2,3]$。将此先验分布与观测模型所隐含的高斯似然函数相结合，得到 $(\\sigma,\\rho,\\beta)$ 的后验分布。使用该网格近似后验分布，并报告每个测试用例中各参数的后验均值。\n\n测试套件包含 3 个用例，分别指定了用于生成合成观测数据的真实参数、初始状态、时间步长、观测区间数量、观测噪声标准差以及一个固定的随机种子。对于每个用例，通过使用真实参数模拟 Lorenz 系统，并使用给定的种子添加独立的高斯噪声，从而在内部生成观测数据。然后，仅使用含噪观测数据（而非真实参数），对 $(\\sigma,\\rho,\\beta)$ 执行上述贝叶斯推断，并输出每个参数的后验均值。\n\n测试套件：\n- 用例 1（混沌，中等噪声）：\n  - 真实参数：$\\sigma^\\star = 10$, $\\rho^\\star = 28$, $\\beta^\\star = 8/3$。\n  - 初始条件：$(x(0),y(0),z(0)) = (-8, 8, 27)$。\n  - 时间步长：$\\Delta t = 0.02$。\n  - 区间数量：$N = 60$（因此有 $N+1 = 61$ 个观测时间 $t_i$）。\n  - 噪声标准差：$\\tau = 1.0$。\n  - 随机种子：$314159$。\n- 用例 2（混沌，短序列，较高噪声）：\n  - 真实参数：$\\sigma^\\star = 12$, $\\rho^\\star = 35$, $\\beta^\\star = 2.5$。\n  - 初始条件：$(x(0),y(0),z(0)) = (0, 1, 1.05)$。\n  - 时间步长：$\\Delta t = 0.02$。\n  - 区间数量：$N = 40$（因此有 $N+1 = 41$ 个观测时间 $t_i$）。\n  - 噪声标准差：$\\tau = 2.0$。\n  - 随机种子：$271828$。\n- 用例 3（非混沌，低噪声）：\n  - 真实参数：$\\sigma^\\star = 9$, $\\rho^\\star = 5$, $\\beta^\\star = 2.2$。\n  - 初始条件：$(x(0),y(0),z(0)) = (1, 1, 1)$。\n  - 时间步长：$\\Delta t = 0.02$。\n  - 区间数量：$N = 40$（因此有 $N+1 = 41$ 个观测时间 $t_i$）。\n  - 噪声标准差：$\\tau = 0.2$。\n  - 随机种子：$42$。\n\n重要实现约束：\n- 使用步长为 $\\Delta t$ 的定步长四阶 Runge–Kutta 积分器来获得 $i=0,\\dots,N$ 的 $x(t_i \\mid \\sigma,\\rho,\\beta)$。请勿使用任何自适应方案。\n- 使用指定的张量积网格，其点数为 $n_\\sigma = 11$，$n_\\rho = 17$，$n_\\beta = 11$。\n- 通过对网格上未归一化的后验权重进行归一化来计算每个参数的后验均值。必要时使用数值稳定的求幂策略。\n- 对于每个用例，返回四舍五入到 3 位小数的 $(\\sigma,\\rho,\\beta)$ 的后验均值。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个含三个列表的列表，每个内部列表对应一个测试用例，其中包含该用例的三个后验均值，顺序为 $[\\hat{\\sigma},\\hat{\\rho},\\hat{\\beta}]$。格式必须严格如下：\n$$\n[[\\hat{\\sigma}_1,\\hat{\\rho}_1,\\hat{\\beta}_1],[\\hat{\\sigma}_2,\\hat{\\rho}_2,\\hat{\\beta}_2],[\\hat{\\sigma}_3,\\hat{\\rho}_3,\\hat{\\beta}_3]]\n$$\n每个数字四舍五入到 3 位小数，且无空格。", "solution": "所提出的问题是关于一个常微分方程系统（具体为 Lorenz 系统）的贝叶斯参数估计练习。任务是从单个状态变量 $x(t)$ 的含噪观测数据中推断参数 $(\\sigma, \\rho, \\beta)$。在进行求解之前，必须对问题陈述进行严格的验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n\n问题提供了以下信息：\n- **动力学系统**：Lorenz 系统，由以下方程定义：\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z\n$$\n- **观测模型**：在离散时间点 $t_i = i \\Delta t$ 对状态变量 $x$ 的含噪观测值 $y_i$：\n$$\ny_i = x(t_i \\mid \\sigma,\\rho,\\beta) + \\varepsilon_i, \\quad \\text{其中 } \\varepsilon_i \\sim \\mathcal{N}(0,\\tau^2)\n$$\n- **已知量**：对于推断任务，初始条件 $(x(0),y(0),z(0))$、均匀时间步长 $\\Delta t$ 和噪声标准差 $\\tau$ 是已知的。\n- **数值方法**：前向映射 $(\\sigma,\\rho,\\beta) \\mapsto x(t_i)$ 应使用步长为 $\\Delta t$ 的定步长四阶 Runge-Kutta 方法计算。\n- **先验分布**：假设参数服从独立的均匀先验分布：\n$$\n\\sigma \\sim \\mathrm{Uniform}([5,15]), \\quad \\rho \\sim \\mathrm{Uniform}([0,40]), \\quad \\beta \\sim \\mathrm{Uniform}([2,3])\n$$\n- **参数网格**：一个张量积网格，包含 $n_\\sigma = 11$、$n_\\rho = 17$ 和 $n_\\beta = 11$ 个线性间隔点，覆盖先验分布的支撑集。\n- **任务**：为三个测试用例计算每个参数 $(\\sigma, \\rho, \\beta)$ 的后验均值。\n- **测试用例**：\n    - **用例 1**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (10, 28, 8/3)$。初始条件 $(x(0),y(0),z(0)) = (-8, 8, 27)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 60$。噪声 $\\tau = 1.0$。随机种子 $= 314159$。\n    - **用例 2**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (12, 35, 2.5)$。初始条件 $(x(0),y(0),z(0)) = (0, 1, 1.05)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 40$。噪声 $\\tau = 2.0$。随机种子 $= 271828$。\n    - **用例 3**：真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star) = (9, 5, 2.2)$。初始条件 $(x(0),y(0),z(0)) = (1, 1, 1)$。时间步长 $\\Delta t = 0.02$。区间数量 $N = 40$。噪声 $\\tau = 0.2$。随机种子 $= 42$。\n- **输出格式**：一个单行字符串，表示一个包含三个列表的列表，每个内部列表包含对应案例的后验均值 $[\\hat{\\sigma}, \\hat{\\rho}, \\hat{\\beta}]$，四舍五入到 3 位小数。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据既定标准对问题进行评估：\n1.  **科学依据充分**：该问题基于标准原理。Lorenz 系统是混沌理论中的一个经典模型，贝叶斯推断是统计学的基本方法，而 Runge-Kutta 方法是常微分方程数值分析的基石。该问题在科学上是合理的。\n2.  **良构的**：该问题是良构的。它要求基于一个完全指定的模型、数据生成过程和计算算法（基于网格的近似）来计算后验均值。指令精确，对于给定的随机种子会产生唯一、确定的结果。\n3.  **客观性**：该问题以清晰、客观的数学语言陈述，没有歧义或主观解释。\n4.  **完整性与一致性**：该问题是自包含的。所有必要组成部分——模型、先验、似然、数值方法、数据生成参数和网格规格——都已明确提供。没有矛盾之处。\n5.  **可行性**：指定的任务是一个合成数据实验，是方法验证的标准实践。计算负荷涉及对一个小型常微分方程系统在短时间范围（$N \\le 60$ 步）内进行 $11 \\times 17 \\times 11 = 2057$ 次积分，这在现代硬件上是完全可行的。\n\n**步骤 3：结论与行动**\n\n问题陈述有效、完整且良构。我们可以着手求解。\n\n**求解推导**\n\n目标是在给定一组含噪观测数据 $Y = \\{y_0, y_1, \\dots, y_N\\}$ 的情况下，计算参数 $\\theta = (\\sigma, \\rho, \\beta)$ 的后验均值。\n\n**1. 贝叶斯框架**\n根据贝叶斯定理，给定数据时参数的后验概率分布为：\n$$\np(\\theta | Y) = \\frac{p(Y | \\theta) p(\\theta)}{p(Y)} \\propto p(Y | \\theta) p(\\theta)\n$$\n其中 $p(Y | \\theta)$ 是似然函数，$p(\\theta)$ 是先验分布。\n\n先验分布 $p(\\theta)$ 被指定为在一个超矩形上的均匀分布：\n$$\np(\\theta) = p(\\sigma)p(\\rho)p(\\beta) \\propto \\mathbb{I}(\\sigma \\in [5,15]) \\cdot \\mathbb{I}(\\rho \\in [0,40]) \\cdot \\mathbb{I}(\\beta \\in [2,3])\n$$\n其中 $\\mathbb{I}(\\cdot)$ 是指示函数。由于计算网格完全位于此支撑集内，因此对于所有网格点，先验是恒定的，在计算后验比例时可以忽略。\n\n似然函数 $p(Y | \\theta)$ 由观测模型决定。噪声项 $\\varepsilon_i$ 是独立同分布的，服从高斯分布 $\\mathcal{N}(0, \\tau^2)$。对于给定的参数集 $\\theta$，观测到数据序列 $Y$ 的似然是每次观测概率的乘积：\n$$\np(Y | \\theta) = \\prod_{i=0}^{N} p(y_i | \\theta) = \\prod_{i=0}^{N} \\frac{1}{\\sqrt{2\\pi\\tau^2}} \\exp\\left( -\\frac{(y_i - x(t_i | \\theta))^2}{2\\tau^2} \\right)\n$$\n其中 $x(t_i | \\theta)$ 是 Lorenz 系统在时间 $t_i$ 使用参数 $\\theta$ 时 $x$ 分量的解。\n\n为了数值稳定性，最好使用对数似然：\n$$\n\\log p(Y | \\theta) = \\sum_{i=0}^{N} \\left( -\\frac{1}{2}\\log(2\\pi\\tau^2) - \\frac{(y_i - x(t_i | \\theta))^2}{2\\tau^2} \\right)\n$$\n由于在网格上后验分布与似然函数成正比，我们有：\n$$\np(\\theta | Y) \\propto \\exp\\left( -\\frac{1}{2\\tau^2} \\sum_{i=0}^{N} (y_i - x(t_i | \\theta))^2 \\right)\n$$\n$\\sum_{i=0}^{N} (y_i - x(t_i | \\theta))^2$ 这一项是观测值与参数为 $\\theta$ 的模型预测值之间的残差平方和 (SSE)。\n\n**2. 数值近似**\n连续参数空间被离散化为有限网格。设网格点表示为 $\\theta_j$，其中 $j=1, \\dots, M$，$M = n_\\sigma n_\\rho n_\\beta$。\n\n- **前向模型仿真**：对于每个网格点 $\\theta_j = (\\sigma, \\rho, \\beta)$，从给定的初始条件对 Lorenz 系统进行数值积分，以获得预测轨迹 $\\{x(t_i | \\theta_j)\\}_{i=0}^N$。问题指定使用定步长为 $\\Delta t$ 的四阶 Runge-Kutta (RK4) 方法。对于状态向量 $\\mathbf{s} = (x,y,z)$ 和常微分方程 $\\frac{d\\mathbf{s}}{dt} = f(t, \\mathbf{s})$，RK4 的一个步骤是：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(t_n, \\mathbf{s}_n) \\\\\n\\mathbf{k}_2 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{s}_n + \\frac{\\Delta t}{2}\\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(t_n + \\frac{\\Delta t}{2}, \\mathbf{s}_n + \\frac{\\Delta t}{2}\\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(t_n + \\Delta t, \\mathbf{s}_n + \\Delta t\\mathbf{k}_3) \\\\\n\\mathbf{s}_{n+1} = \\mathbf{s}_n + \\frac{\\Delta t}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n\\end{aligned}\n$$\n\n- **后验权重计算**：对于每个网格点 $\\theta_j$，我们计算未归一化的对数后验值 $S_j = -\\frac{1}{2\\tau^2} \\text{SSE}(\\theta_j)$。未归一化的后验权重是 $w_j = \\exp(S_j)$。为防止数值上溢或下溢，我们使用一种稳定化技术。设 $S_{\\max} = \\max_j S_j$。稳定化的权重计算为 $w'_j = \\exp(S_j - S_{\\max})$。\n\n- **后验均值估计**：每个参数的后验均值的离散近似是网格上的加权平均值。对于参数 $\\sigma$，这是：\n$$\n\\hat{\\sigma} = \\mathbb{E}[\\sigma | Y] \\approx \\frac{\\sum_j \\sigma_j w'_j}{\\sum_j w'_j}\n$$\n$\\hat{\\rho}$ 和 $\\hat{\\beta}$ 的计算公式类似。\n\n**3. 算法流程**\n\n对于三个测试用例中的每一个：\n1.  **生成数据**：使用指定的真实参数 $(\\sigma^\\star, \\rho^\\star, \\beta^\\star)$、初始条件、时间步长 $\\Delta t$ 和区间数 $N$，用 RK4 积分器模拟 Lorenz 系统以生成真实轨迹 $\\{x(t_i)\\}_{i=0}^N$。使用提供的随机种子添加标准差为 $\\tau$ 的高斯噪声，以产生观测集 $\\{y_i\\}_{i=0}^N$。\n2.  **定义参数网格**：使用指定的范围和点数，为 $\\sigma$、$\\rho$ 和 $\\beta$ 构建参数值数组。\n3.  **遍历网格**：对于张量积网格中的每个点 $(\\sigma_k, \\rho_l, \\beta_m)$：\n    a. 使用这些参数和 RK4 积分器模拟 Lorenz 系统，得到预测轨迹 $\\{\\hat{x}_i\\}_{i=0}^N$。\n    b. 计算 SSE：$\\sum_{i=0}^{N} (y_i - \\hat{x}_i)^2$。\n    c. 计算并存储未归一化的对数后验值：$S_{klm} = -\\frac{\\text{SSE}}{2\\tau^2}$。\n4.  **计算后验均值**：\n    a. 找到所有计算出的对数后验值的最大值 $S_{\\max}$。\n    b. 计算归一化的后验权重：$W_{klm} = \\exp(S_{klm} - S_{\\max}) / \\sum_{k',l',m'} \\exp(S_{k'l'm'} - S_{\\max})$。\n    c. 将后验均值计算为加权和：\n    $$\n    \\hat{\\sigma} = \\sum_{k,l,m} \\sigma_k W_{klm}, \\quad \\hat{\\rho} = \\sum_{k,l,m} \\rho_l W_{klm}, \\quad \\hat{\\beta} = \\sum_{k,l,m} \\beta_m W_{klm}\n    $$\n5.  **存储并格式化结果**：存储四舍五入到三位小数的三元组 $[\\hat{\\sigma}, \\hat{\\rho}, \\hat{\\beta}]$。处理完所有用例后，将收集到的结果格式化为所需的字符串表示形式。\n将实施此系统化程序以得出最终答案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef lorenz_rhs(state, sigma, rho, beta):\n    \"\"\"\n    Computes the derivatives of the Lorenz system.\n    Note: The system is autonomous, so the time `t` is not used.\n    \"\"\"\n    x, y, z = state\n    dx_dt = sigma * (y - x)\n    dy_dt = x * (rho - z) - y\n    dz_dt = x * y - beta * z\n    return np.array([dx_dt, dy_dt, dz_dt])\n\ndef rk4_integrator(rhs, initial_state, num_steps, dt, *params):\n    \"\"\"\n    Fixed-step fourth-order Runge-Kutta integrator.\n    Produces a trajectory of num_steps + 1 states.\n    \"\"\"\n    num_vars = len(initial_state)\n    states = np.zeros((num_steps + 1, num_vars))\n    states[0] = initial_state\n    \n    current_state = initial_state.copy()\n    \n    for i in range(num_steps):\n        k1 = rhs(current_state, *params)\n        k2 = rhs(current_state + 0.5 * dt * k1, *params)\n        k3 = rhs(current_state + 0.5 * dt * k2, *params)\n        k4 = rhs(current_state + dt * k3, *params)\n        \n        current_state += (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n        states[i + 1] = current_state\n        \n    return states\n\ndef solve():\n    \"\"\"\n    Main function to solve the Bayesian inference problem for the Lorenz system.\n    \"\"\"\n    test_cases = [\n        # Case 1 (chaotic, moderate noise)\n        {\n            \"true_params\": (10.0, 28.0, 8.0/3.0),\n            \"initial_cond\": np.array([-8.0, 8.0, 27.0]),\n            \"dt\": 0.02,\n            \"N\": 60,\n            \"tau\": 1.0,\n            \"seed\": 314159\n        },\n        # Case 2 (chaotic, short series, higher noise)\n        {\n            \"true_params\": (12.0, 35.0, 2.5),\n            \"initial_cond\": np.array([0.0, 1.0, 1.05]),\n            \"dt\": 0.02,\n            \"N\": 40,\n            \"tau\": 2.0,\n            \"seed\": 271828\n        },\n        # Case 3 (non-chaotic, low noise)\n        {\n            \"true_params\": (9.0, 5.0, 2.2),\n            \"initial_cond\": np.array([1.0, 1.0, 1.0]),\n            \"dt\": 0.02,\n            \"N\": 40,\n            \"tau\": 0.2,\n            \"seed\": 42\n        }\n    ]\n\n    # Define the parameter grid\n    n_sigma, n_rho, n_beta = 11, 17, 11\n    sigma_vals = np.linspace(5, 15, n_sigma)\n    rho_vals = np.linspace(0, 40, n_rho)\n    beta_vals = np.linspace(2, 3, n_beta)\n\n    all_results = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic observations\n        rng = np.random.default_rng(case[\"seed\"])\n        true_trajectory = rk4_integrator(\n            lorenz_rhs, \n            case[\"initial_cond\"], \n            case[\"N\"], \n            case[\"dt\"], \n            *case[\"true_params\"]\n        )\n        x_true = true_trajectory[:, 0]\n        noise = rng.normal(loc=0.0, scale=case[\"tau\"], size=case[\"N\"] + 1)\n        observations_y = x_true + noise\n        \n        # 2. Perform grid search to compute posterior distribution\n        log_posterior = np.zeros((n_sigma, n_rho, n_beta))\n        \n        for i, sigma_val in enumerate(sigma_vals):\n            for j, rho_val in enumerate(rho_vals):\n                for k, beta_val in enumerate(beta_vals):\n                    # Simulate forward model for this grid point\n                    sim_params = (sigma_val, rho_val, beta_val)\n                    sim_trajectory = rk4_integrator(\n                        lorenz_rhs,\n                        case[\"initial_cond\"],\n                        case[\"N\"],\n                        case[\"dt\"],\n                        *sim_params\n                    )\n                    x_sim = sim_trajectory[:, 0]\n                    \n                    # Calculate Sum of Squared Errors (SSE)\n                    sse = np.sum((observations_y - x_sim)**2)\n                    \n                    # Calculate log posterior (proportional to -SSE), ignoring constants\n                    log_posterior[i, j, k] = -sse / (2 * case[\"tau\"]**2)\n\n        # 3. Calculate posterior means from the grid-based posterior\n        # Use log-sum-exp trick for numerical stability\n        log_posterior -= np.max(log_posterior)\n        posterior_weights = np.exp(log_posterior)\n        \n        total_weight = np.sum(posterior_weights)\n        \n        # Use numpy broadcasting to compute weighted sums efficiently\n        sigma_mean = np.sum(posterior_weights * sigma_vals[:, None, None]) / total_weight\n        rho_mean = np.sum(posterior_weights * rho_vals[None, :, None]) / total_weight\n        beta_mean = np.sum(posterior_weights * beta_vals[None, None, :]) / total_weight\n        \n        case_results = [\n            round(sigma_mean, 3), \n            round(rho_mean, 3), \n            round(beta_mean, 3)\n        ]\n        all_results.append(case_results)\n\n    # 4. Format the final output string\n    # Using str() and replace() to ensure the exact format without spaces\n    output_str = str(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "2374071"}]}