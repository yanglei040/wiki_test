{"hands_on_practices": [{"introduction": "福克-普朗克方程描述了粒子系综的概率密度演化。但这一宏观图像与单个粒子的随机游走之间有何关联？本实践将直接架起这座桥梁 [@problem_id:2444416]。你将首先从福克-普朗克方程出发，推导系统统计矩（如平均位置 $\\langle x \\rangle$ 和均方位移 $\\langle x^2 \\rangle$）的演化方程，然后通过编写一个基于朗之万方程的数值模拟来验证这些理论预测，从而具体地确认这两种描述之间深刻的内在联系。", "problem": "考虑一个描述朗之万粒子的一维 Itô 随机微分方程 (SDE)，\n$$\ndX_t = a(X_t)\\,dt + b\\,dW_t,\n$$\n其中 $W_t$ 是一个标准维纳过程，$a(x)$ 是漂移项，$b$ 是扩散振幅。本问题中，我们限定于线性漂移、常数扩散模型\n$$\na(x) = u - k x,\\quad b = \\sqrt{2D},\n$$\n其参数为 $k \\ge 0$，$u \\in \\mathbb{R}$ 和 $D \\ge 0$。与此过程相关的概率密度函数 $p(x,t)$ 的 Fokker–Planck 方程 (FPE) 为\n$$\n\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}.\n$$\n假设初始分布具有有限矩，并且其衰减速度足够快，以至于在计算矩时，所有由分部积分产生的边界项均为零。\n\n任务 1 (推导)：从 Fokker–Planck 方程以及一阶矩和二阶矩的定义出发，\n$$\n\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx,\\quad \\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx,\n$$\n针对指定的 $a(x)$ 和 $D$，推导出控制 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 演化的封闭常微分方程组 (ODE)。然后求解这些 ODE，以获得 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 的显式表达式（用初始均值 $\\langle x \\rangle(0)$ 和初始方差 $\\mathrm{Var}(X_0)$ 表示），并确保覆盖 $k>0$ 的情况以及 $k \\to 0$ 的极限情况。所有量均为无量纲量。\n\n任务 2 (计算)：实现一个程序，该程序能够：\n- 使用 Euler–Maruyama 方法（时间步长为 $\\Delta t$），从一个均值为 $m_0$、方差为 $v_0$ 的初始系综 $X_0$ 出发，模拟 SDE 的 $N$ 条独立轨迹（使用均值为 $m_0$、方差为 $v_0$ 的高斯分布进行初始化；当 $v_0 = 0$ 时，将所有粒子初始化在确定性值 $m_0$ 处）。\n- 将状态推进到时间 $T$，并根据时间 $T$ 的模拟系综计算经验一阶矩和二阶矩。\n- 使用任务 1 中推导出的矩解，并代入相同的有效模拟时间 $T_{\\mathrm{eff}} = n_{\\mathrm{steps}}\\,\\Delta t$（其中 $n_{\\mathrm{steps}}$ 是执行的整数步数），计算理论上的 $\\langle x \\rangle(T)$ 和 $\\langle x^2 \\rangle(T)$。\n- 通过绝对误差 $e_1 = \\big|\\langle x \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$ 和 $e_2 = \\big|\\langle x^2 \\rangle_{\\mathrm{emp}}(T_{\\mathrm{eff}}) - \\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})\\big|$ 来比较经验矩和理论矩。\n- 对每个测试用例，输出一个布尔值，该值表示两个误差是否都满足 $e_1 \\le \\varepsilon$ 和 $e_2 \\le \\varepsilon$（对于指定的容差 $\\varepsilon$）。\n\n使用以下测试套件，其中所有量均为无量纲量：\n- 测试用例 1 (带常数驱动的通用 Ornstein–Uhlenbeck 过程)：$k = 0.7$, $u = 0.3$, $D = 0.5$, $m_0 = 1.2$, $v_0 = 0.8$, $T = 2.3$, $\\Delta t = 0.005$, $N = 20000$。\n- 测试用例 2 (纯扩散边界情况)：$k = 0$, $u = 0$, $D = 0.2$, $m_0 = 0.0$, $v_0 = 0.0$, $T = 1.5$, $\\Delta t = 0.003$, $N = 20000$。\n- 测试用例 3 (刚性弛豫)：$k = 5.0$, $u = 0.0$, $D = 0.4$, $m_0 = -0.7$, $v_0 = 0.3$, $T = 0.6$, $\\Delta t = 0.0005$, $N = 8000$。\n\n对所有用例均使用容差 $\\varepsilon = 0.03$。\n\n你的程序应生成单行输出，其中包含布尔结果，格式为方括号内以逗号分隔的列表（例如 $[{\\tt True},{\\tt False},{\\tt True}]$），其顺序与上述测试套件的顺序相同。不应打印任何其他文本。", "solution": "在尝试任何求解之前，首先对问题陈述进行验证。\n\n给定条件逐字提取如下：\n- 随机微分方程 (SDE)：$dX_t = a(X_t)\\,dt + b\\,dW_t$\n- 漂移项：$a(x) = u - k x$\n- 扩散振幅：$b = \\sqrt{2D}$\n- 参数约束：$k \\ge 0$，$u \\in \\mathbb{R}$，$D \\ge 0$\n- Fokker-Planck 方程 (FPE)：$\\frac{\\partial p}{\\partial t} = -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2}$\n- 矩定义：$\\langle x \\rangle(t) = \\int_{-\\infty}^{\\infty} x\\,p(x,t)\\,dx$, $\\langle x^2 \\rangle(t) = \\int_{-\\infty}^{\\infty} x^2\\,p(x,t)\\,dx$\n- 边界条件假设：由于 $p(x,t)$ 在 $x \\to \\pm\\infty$ 时衰减足够快，所有分部积分产生的边界项均为零。\n- 任务 1：推导并求解 $\\langle x \\rangle(t)$ 和 $\\langle x^2 \\rangle(t)$ 的 ODE。\n- 任务 2：使用 Euler-Maruyama 方法实现数值模拟，并与任务 1 中推导的理论结果进行比较。\n- 提供了测试用例和容差 $\\varepsilon = 0.03$。\n\n验证结论：该问题是 **有效的**。它在科学上基于随机过程理论，特别是作为统计物理及相关领域基石的 Ornstein-Uhlenbeck 过程。该问题是适定的，提供了推导唯一解析解和执行相应数值验证所需的所有必要信息、定义和约束。其语言客观而精确。该问题是可形式化的，并且与计算工程中的 Fokker-Planck 方程主题直接相关。未发现科学、逻辑或结构上的缺陷。\n\n我们继续进行求解。\n\n**任务 1：矩方程的推导与求解**\n\n任意矩 $\\langle f(x) \\rangle(t) = \\int f(x) p(x,t) dx$ 的演化由 FPE 控制。其时间导数为：\n$$\n\\frac{d}{dt}\\langle f(x) \\rangle = \\int f(x) \\frac{\\partial p}{\\partial t} dx = \\int f(x) \\left[ -\\frac{\\partial}{\\partial x}\\big(a(x)\\,p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n\n**一阶矩 $\\langle x \\rangle(t)$**\n\n令 $f(x) = x$。均值 $\\langle x \\rangle(t)$ 的时间导数为：\n$$\n\\frac{d\\langle x \\rangle}{dt} = \\int x \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n我们分别计算积分中的两项。\n\n第 1 项：\n$$\n-\\int_{-\\infty}^{\\infty} x \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\n使用分部积分法 $\\int v\\,du' = [vu']_{-\\infty}^{\\infty} - \\int v'u\\,dx$，令 $v=x$ 且 $u'=\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big)$：\n$$\n-\\left[ x(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} (u-kx)p \\, dx\n$$\n根据假设，边界项为零。剩下的积分为：\n$$\n\\int (u-kx)p \\, dx = u \\int p \\, dx - k \\int xp \\, dx = u \\cdot 1 - k\\langle x \\rangle = u - k\\langle x \\rangle\n$$\n因为 $\\int p(x,t) dx = 1$。\n\n第 2 项：\n$$\n\\int_{-\\infty}^{\\infty} x D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\n我们进行两次分部积分。首先，令 $v=x$ 且 $u' = D \\frac{\\partial^2 p}{\\partial x^2}$：\n$$\n\\left[ xD\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} D\\frac{\\partial p}{\\partial x} dx\n$$\n边界项为零。积分为 $-D[p]_{-\\infty}^{\\infty}$，也为零。因此，这整项为零。\n\n综合以上结果，我们得到一阶矩的 ODE：\n$$\n\\frac{d\\langle x \\rangle}{dt} = u - k\\langle x \\rangle\n$$\n\n**二阶矩 $\\langle x^2 \\rangle(t)$**\n\n令 $f(x) = x^2$。二阶矩 $\\langle x^2 \\rangle(t)$ 的时间导数为：\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = \\int x^2 \\left[ -\\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) + D\\,\\frac{\\partial^2 p}{\\partial x^2} \\right] dx\n$$\n第 1 项：\n$$\n-\\int_{-\\infty}^{\\infty} x^2 \\frac{\\partial}{\\partial x}\\big((u-kx)p\\big) dx\n$$\n使用分部积分法，令 $v=x^2$：\n$$\n-\\left[ x^2(u-kx)p \\right]_{-\\infty}^{\\infty} + \\int_{-\\infty}^{\\infty} 2x(u-kx)p \\, dx\n$$\n边界项为零。剩下的积分为：\n$$\n\\int (2ux - 2kx^2)p \\, dx = 2u \\int xp \\, dx - 2k \\int x^2p \\, dx = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle\n$$\n\n第 2 项：\n$$\n\\int_{-\\infty}^{\\infty} x^2 D \\frac{\\partial^2 p}{\\partial x^2} dx\n$$\n使用分部积分法，令 $v=x^2$：\n$$\n\\left[ x^2 D\\frac{\\partial p}{\\partial x} \\right]_{-\\infty}^{\\infty} - \\int_{-\\infty}^{\\infty} 2x D\\frac{\\partial p}{\\partial x} dx\n$$\n边界项为零。剩下 $-2D \\int x \\frac{\\partial p}{\\partial x} dx$。再次使用分部积分法：\n$$\n-2D \\left( [xp]_{-\\infty}^{\\infty} - \\int p \\, dx \\right) = -2D(0 - 1) = 2D\n$$\n综合以上结果，得到二阶矩的 ODE：\n$$\n\\frac{d\\langle x^2 \\rangle}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D\n$$\n这些矩构成一个封闭的线性 ODE 系统。推导方差 $\\mathrm{Var}(X_t) \\equiv V(t) = \\langle x^2 \\rangle(t) - \\langle x \\rangle(t)^2$ 的方程会更简洁。\n$$\n\\frac{dV}{dt} = \\frac{d\\langle x^2 \\rangle}{dt} - 2\\langle x \\rangle \\frac{d\\langle x \\rangle}{dt} = (2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D) - 2\\langle x \\rangle (u - k\\langle x \\rangle)\n$$\n$$\n\\frac{dV}{dt} = 2u\\langle x \\rangle - 2k\\langle x^2 \\rangle + 2D - 2u\\langle x \\rangle + 2k\\langle x \\rangle^2 = -2k(\\langle x^2 \\rangle - \\langle x \\rangle^2) + 2D\n$$\n这可以简化为一个关于方差的独立 ODE：\n$$\n\\frac{dV}{dt} = -2kV + 2D\n$$\n\n**求解 ODE**\n\n令 $m(t) = \\langle x \\rangle(t)$，$m_0 = \\langle x \\rangle(0)$，以及 $v_0 = \\mathrm{Var}(X_0)$。\n\n情况 1：$k > 0$。\n均值的 ODE 是 $\\frac{dm}{dt} + km = u$。这是一个一阶线性 ODE，其解为：\n$$\nm(t) = m_0 e^{-kt} + \\frac{u}{k}(1-e^{-kt})\n$$\n方差的 ODE 是 $\\frac{dV}{dt} + 2kV = 2D$。其解为：\n$$\nV(t) = v_0 e^{-2kt} + \\frac{D}{k}(1-e^{-2kt})\n$$\n\n情况 2：$k = 0$。\n均值的 ODE 变为 $\\frac{dm}{dt} = u$，其解为：\n$$\nm(t) = m_0 + ut\n$$\n方差的 ODE 变为 $\\frac{dV}{dt} = 2D$，其解为：\n$$\nV(t) = v_0 + 2Dt\n$$\n$k=0$ 时的这些结果与 $k>0$ 的表达式在 $k \\to 0$ 时的极限是一致的，这可以通过对指数函数进行泰勒展开来验证。\n\n二阶矩可以从均值和方差中恢复：\n$$\n\\langle x^2 \\rangle(t) = V(t) + [m(t)]^2\n$$\n至此，任务 1 的推导完成。\n\n**任务 2：计算实现**\n\nSDE $dX_t = (u - kX_t)dt + \\sqrt{2D}dW_t$ 使用 Euler-Maruyama 方法进行模拟。对于单个粒子在时间步 $n$ 的位置 $X_n$，其离散化更新规则为：\n$$\nX_{n+1} = X_n + (u - kX_n)\\Delta t + \\sqrt{2D\\Delta t} Z_n\n$$\n其中 $\\Delta t$ 是时间步长，$Z_n$ 是从标准正态分布 $N(0,1)$ 中抽取的随机变量。\n\n算法流程如下：\n1. 对每个测试用例，初始化 $N$ 条独立的粒子轨迹。初始位置 $X_0$ 构成一个从均值为 $m_0$、方差为 $v_0$ 的高斯分布中抽样的系综。如果 $v_0 = 0$，则所有粒子都在确定性位置 $m_0$ 处初始化。\n2. 计算模拟步数 $n_{\\mathrm{steps}} = \\mathrm{round}(T/\\Delta t)$，以尽量接近目标时间 $T$。有效总时间为 $T_{\\mathrm{eff}} = n_{\\mathrm{steps}} \\Delta t$。\n3. 根据 Euler-Maruyama 规则，迭代 $n_{\\mathrm{steps}}$ 次，在每一步更新所有 $N$ 个粒子的位置。每一步都会生成一组新的 $N$ 个随机数 $Z_n$。\n4. 在最终时间 $T_{\\mathrm{eff}}$，从 $N$ 个最终粒子位置组成的系综中计算经验均值和二阶矩：\n$$\n\\langle x \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N X_i(T_{\\mathrm{eff}}) \\quad \\text{和} \\quad \\langle x^2 \\rangle_{\\mathrm{emp}} = \\frac{1}{N}\\sum_{i=1}^N [X_i(T_{\\mathrm{eff}})]^2\n$$\n5. 使用上面推导的解析公式计算理论矩 $\\langle x \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$ 和 $\\langle x^2 \\rangle_{\\mathrm{theory}}(T_{\\mathrm{eff}})$。\n6. 计算绝对误差 $e_1 = |\\langle x \\rangle_{\\mathrm{emp}} - \\langle x \\rangle_{\\mathrm{theory}}|$ 和 $e_2 = |\\langle x^2 \\rangle_{\\mathrm{emp}} - \\langle x^2 \\rangle_{\\mathrm{theory}}|$。\n7. 如果两个误差都在指定的容差 $\\varepsilon = 0.03$ 范围内，则测试用例通过。最终输出是一个布尔值列表，指示每个测试用例的通过/失败状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running simulations for each test case and comparing\n    empirical results with theoretical derivations.\n    \"\"\"\n\n    test_cases = [\n        # (k, u, D, m0, v0, T, dt, N)\n        (0.7, 0.3, 0.5, 1.2, 0.8, 2.3, 0.005, 20000),\n        (0.0, 0.0, 0.2, 0.0, 0.0, 1.5, 0.003, 20000),\n        (5.0, 0.0, 0.4, -0.7, 0.3, 0.6, 0.0005, 8000),\n    ]\n    epsilon = 0.03\n    results = []\n\n    for k, u, D, m0, v0, T, dt, N in test_cases:\n        # Run simulation to get empirical moments\n        emp_mean, emp_second_moment, eff_T = run_simulation(\n            k, u, D, m0, v0, T, dt, N\n        )\n\n        # Calculate theoretical moments\n        theory_mean, theory_second_moment = theoretical_moments(\n            k, u, D, m0, v0, eff_T\n        )\n\n        # Compare and check against tolerance\n        e1 = np.abs(emp_mean - theory_mean)\n        e2 = np.abs(emp_second_moment - theory_second_moment)\n        \n        is_within_tolerance = (e1 = epsilon) and (e2 = epsilon)\n        results.append(is_within_tolerance)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_simulation(k, u, D, m0, v0, T, dt, N):\n    \"\"\"\n    Simulates N trajectories of the Langevin SDE using Euler-Maruyama method.\n\n    Returns:\n        tuple: (empirical mean, empirical second moment, effective simulation time)\n    \"\"\"\n    num_steps = int(np.round(T / dt))\n    eff_T = num_steps * dt\n\n    # Initial ensemble generation from a Gaussian distribution\n    # np.random.normal's 'scale' parameter is standard deviation (sqrt of variance)\n    if v0 >= 0:\n        std_dev = np.sqrt(v0)\n        x = np.random.normal(loc=m0, scale=std_dev, size=N)\n    else:\n        # This case should not happen based on problem constraints but is good practice\n        raise ValueError(\"Initial variance v0 must be non-negative.\")\n\n    # Pre-calculate constant term for efficiency\n    sde_noise_term = np.sqrt(2 * D * dt)\n\n    # Simulation loop\n    for _ in range(num_steps):\n        # Generate standard normal random numbers for this step\n        Z = np.random.normal(size=N)\n        \n        # Euler-Maruyama step for all N particles\n        drift = (u - k * x) * dt\n        diffusion = sde_noise_term * Z\n        x += drift + diffusion\n    \n    # Compute empirical moments from the final state of the ensemble\n    emp_mean = np.mean(x)\n    emp_second_moment = np.mean(x**2)\n    \n    return emp_mean, emp_second_moment, eff_T\n\ndef theoretical_moments(k, u, D, m0, v0, t):\n    \"\"\"\n    Calculates the theoretical first and second moments at time t.\n\n    Returns:\n        tuple: (theoretical mean, theoretical second moment)\n    \"\"\"\n    if k > 0:\n        # Case for Ornstein-Uhlenbeck process (k > 0)\n        exp_kt = np.exp(-k * t)\n        exp_2kt = np.exp(-2 * k * t)\n        \n        mean_t = m0 * exp_kt + (u / k) * (1 - exp_kt)\n        var_t = v0 * exp_2kt + (D / k) * (1 - exp_2kt)\n    else: # k == 0\n        # Case for pure Wiener process with drift (k = 0)\n        mean_t = m0 + u * t\n        var_t = v0 + 2 * D * t\n    \n    # Second moment is Var(X) + E[X]^2\n    second_moment_t = var_t + mean_t**2\n    \n    return mean_t, second_moment_t\n\nsolve()\n\n```", "id": "2444416"}, {"introduction": "在许多现实场景中，从分子寻找受体位点到电子逃离量子点，一个核心问题是：一个随机运动的粒子首次到达目标需要多长时间？这个被称为“平均首达时间”（Mean First Passage Time, MFPT）的物理量是扩散理论的核心概念之一，它由向后科尔莫戈罗夫方程所支配 [@problem_id:2444438]。本练习将要求你计算一个受限空间内粒子的平均首达时间，并探索不同类型的边界条件——反射边界与吸收边界——是如何从根本上改变系统的逃逸动力学的。", "problem": "一个一维粒子在闭区间内进行具有恒定漂移的过阻尼扩散。其位置 $X_t$ 在区间 $\\,[0,L]\\,$ 上遵循随机微分方程 (SDE) $\\,\\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t\\,$，其中 $v$ 是恒定漂移速度，$D$ 是恒定扩散系数，$W_t$ 是标准维纳过程。粒子从位置 $X_0 = x_0$ 开始，其中 $0 \\le x_0 \\le L$。\n\n定义平均首达时间 (MFPT) $\\,T\\,$ 为在以下两种边界构型下，从区间 $\\,[0,L]\\,$ 离开的时间 $\\,\\tau\\,$ 的期望值：\n\n- 构型 $\\mathcal{R}\\mathcal{A}$：在 $x=0$ 处为反射边界，在 $x=L$ 处为吸收边界。在此构型中，离开时间为 $\\tau = \\inf\\{t \\ge 0 : X_t = L\\}$，因为在 $x=0$ 处的反射阻止了粒子从 $x=0$ 离开。\n- 构型 $\\mathcal{A}\\mathcal{A}$：在 $x=0$ 和 $x=L$ 处均为吸收边界。在此构型中，离开时间为 $\\tau = \\inf\\{t \\ge 0 : X_t \\in \\{0,L\\}\\}$。\n\n对于每种构型，分别将 MFPT 定义为 $\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)\\,$ 和 $\\,T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,$。所有时间都必须以秒为单位表示。\n\n任务：对于下面的参数集，计算每个测试用例的三元组结果 $[\\,T_{\\mathcal{R}\\mathcal{A}}(x_0),\\,T_{\\mathcal{A}\\mathcal{A}}(x_0),\\,T_{\\mathcal{R}\\mathcal{A}}(x_0)-T_{\\mathcal{A}\\mathcal{A}}(x_0)\\,]$。所有输出必须以秒为单位表示，并四舍五入到六位小数。\n\n使用以下测试套件，其中 $L$ 的单位是米，$D$ 的单位是平方米/秒，$v$ 的单位是米/秒，$x_0$ 的单位是米：\n\n- 测试用例 1：$L=1.0$, $D=0.1$, $v=0.5$, $x_0=0.2$。\n- 测试用例 2：$L=1.0$, $D=0.1$, $v=0.0$, $x_0=0.3$。\n- 测试用例 3：$L=1.0$, $D=0.05$, $v=-0.2$, $x_0=0.6$。\n- 测试用例 4：$L=2.0$, $D=0.2$, $v=0.3$, $x_0=0.0$。\n- 测试用例 5：$L=1.5$, $D=0.15$, $v=0.1$, $x_0=1.5$。\n\n最终输出格式：您的程序应生成一行输出，其中包含所有测试用例的结果，形式为一个逗号分隔的三元组列表，并用一对单独的方括号括起来。每个三元组的形式必须为 $[\\,T_{\\mathcal{R}\\mathcal{A}},\\,T_{\\mathcal{A}\\mathcal{A}},\\,T_{\\mathcal{R}\\mathcal{A}}-T_{\\mathcal{A}\\mathcal{A}}\\,]$，每个条目四舍五入到六位小数，例如 $[\\, [\\,t_{1,\\mathcal{R}\\mathcal{A}},t_{1,\\mathcal{A}\\mathcal{A}},\\Delta_1\\,], [\\,t_{2,\\mathcal{R}\\mathcal{A}},t_{2,\\mathcal{A}\\mathcal{A}},\\Delta_2\\,], \\ldots \\,]$，其中 $t_{k,\\mathcal{R}\\mathcal{A}}$、$t_{k,\\mathcal{A}\\mathcal{A}}$ 和 $\\Delta_k$ 表示测试用例 $k$ 的三个四舍五入结果。", "solution": "所述问题具有科学依据，是适定的、客观的。它基于扩散过程的基本理论和平均首达时间，这是统计物理和计算工程中的一个标准课题。所有参数都已明确定义，且前提符合事实。我们将进行形式化的推导和求解。\n\n粒子的运动由一维郎之万方程描述，更正式地说是随机微分方程 (SDE)：\n$$ \\mathrm{d}X_t = v\\,\\mathrm{d}t + \\sqrt{2D}\\,\\mathrm{d}W_t $$\n其中 $X_t$ 是在时间 $t$ 的位置，$v$ 是恒定漂移速度，$D$ 是恒定扩散系数，$W_t$ 是标准维纳过程。\n\n平均首达时间 (MFPT)，记为 $T(x_0)$，是粒子从 $X_0 = x_0$ 开始，首次到达给定区域边界所需时间 $\\tau$ 的期望值。对于一个一般的一维伊藤过程 $ \\mathrm{d}X_t = a(X_t)\\,\\mathrm{d}t + b(X_t)\\,\\mathrm{d}W_t $，作为起始位置 $x$ 的函数的 MFPT $T(x)$ 满足逆向柯尔莫哥洛夫方程，这是一个二阶常微分方程：\n$$ a(x) \\frac{\\mathrm{d}T}{\\mathrm{d}x} + \\frac{1}{2} b^2(x) \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\n对于问题中给定的特定 SDE，漂移系数为 $a(x) = v$，扩散项为 $b(x) = \\sqrt{2D}$，因此 $b^2(x) = 2D$。因此，我们问题的逆向柯尔莫哥洛夫方程为：\n$$ v \\frac{\\mathrm{d}T}{\\mathrm{d}x} + D \\frac{\\mathrm{d}^2T}{\\mathrm{d}x^2} = -1 $$\n我们必须在区间 $[0, L]$ 上针对两种指定的边界构型求解这个常微分方程 (ODE)。\n\n**构型 $\\mathcal{R}\\mathcal{A}$：在 $x=0$ 处反射，在 $x=L$ 处吸收**\n\n区域为 $[0, L]$。MFPT $T_{\\mathcal{R}\\mathcal{A}}(x)$ 表示到达 $x=L$ 处边界的时间。\n边界条件为：\n1.  在 $x=L$ 处的吸收边界：如果粒子从吸收边界开始，离开时间为零。因此，$T_{\\mathcal{R}\\mathcal{A}}(L) = 0$。\n2.  在 $x=0$ 处的反射边界：反射边界对概率密度施加了零通量条件，这转化为 MFPT 的零梯度条件。因此，$\\frac{\\mathrm{d}T_{\\mathcal{R}\\mathcal{A}}}{\\mathrm{d}x}\\bigg|_{x=0} = 0$。\n\n我们来求解 $D T'' + v T' = -1$。\n首先，考虑 $v \\neq 0$ 的情况。设 $U(x) = T'(x)$。$U(x)$ 的方程是 $D U' + v U = -1$，这是一个一阶线性常微分方程。其通解为 $U(x) = C_1 e^{-vx/D} - 1/v$。\n使用条件 $U(0) = T'(0) = 0$，我们得到 $C_1 - 1/v = 0 \\Rightarrow C_1 = 1/v$。\n因此，$T'(x) = \\frac{1}{v}(e^{-vx/D} - 1)$。\n对 $x$ 积分得到 $T(x) = \\int \\frac{1}{v}(e^{-vx/D} - 1) \\mathrm{d}x = \\frac{1}{v}(-\\frac{D}{v}e^{-vx/D} - x) + C_2$。\n使用条件 $T(L)=0$，我们求解 $C_2$：$0 = -\\frac{D}{v^2}e^{-vL/D} - \\frac{L}{v} + C_2 \\Rightarrow C_2 = \\frac{D}{v^2}e^{-vL/D} + \\frac{L}{v}$。\n将 $C_2$ 代回，我们得到 $v \\neq 0$ 时的解：\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right) $$\n对于 $v=0$ 的情况，ODE 变为 $D T'' = -1$。积分两次得到 $T(x) = -x^2/(2D) + C_1 x + C_2$。\n边界条件是 $T'(0)=0$ 和 $T(L)=0$。\n$T'(x) = -x/D + C_1$。由 $T'(0)=0$，我们得到 $C_1=0$。\n则 $T(L) = -L^2/(2D) + C_2 = 0$，所以 $C_2 = L^2/(2D)$。\n$v = 0$ 时的解是：\n$$ T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D} $$\n\n**构型 $\\mathcal{A}\\mathcal{A}$：在 $x=0$ 和 $x=L$ 处均为吸收边界**\n\n区域为 $[0, L]$。MFPT $T_{\\mathcal{A}\\mathcal{A}}(x)$ 表示到达 $x=0$ 或 $x=L$ 处任一边界的时间。\n边界条件为：\n1.  在 $x=0$ 处的吸收边界：$T_{\\mathcal{A}\\mathcal{A}}(0) = 0$。\n2.  在 $x=L$ 处的吸收边界：$T_{\\mathcal{A}\\mathcal{A}}(L) = 0$。\n\n我们求解相同的 ODE，$D T'' + v T' = -1$。\n首先，考虑 $v \\neq 0$ 的情况。通解为 $T(x) = C_1 + C_2 e^{-vx/D} - x/v$。\n应用边界条件：\n1.  $T(0) = C_1 + C_2 = 0 \\Rightarrow C_1 = -C_2$。\n2.  $T(L) = C_1 + C_2 e^{-vL/D} - L/v = 0$。\n将 $C_1=-C_2$ 代入第二个方程得到 $-C_2 + C_2 e^{-vL/D} = L/v$，从而得出 $C_2 = \\frac{L/v}{e^{-vL/D}-1}$。\n则 $C_1 = -\\frac{L/v}{e^{-vL/D}-1}$。\n将常数代回通解并化简得到：\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right) $$\n对于 $v=0$ 的情况，ODE 为 $D T'' = -1$，通解为 $T(x) = -x^2/(2D) + C_1 x + C_2$。\n边界条件为 $T(0)=0$ 和 $T(L)=0$。\n$T(0) = C_2 = 0$。\n$T(L) = -L^2/(2D) + C_1 L = 0 \\Rightarrow C_1 = L/(2D)$。\n$v = 0$ 时的解是：\n$$ T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D} $$\n\n**计算公式总结**\n\n对于每个具有参数 $(L, D, v, x_0)$ 的测试用例：\n\n1.  **构型 $\\mathcal{R}\\mathcal{A}$ 的平均首达时间：**\n    - 若 $v=0$：$T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L^2 - x_0^2}{2D}$\n    - 若 $v \\neq 0$：$T_{\\mathcal{R}\\mathcal{A}}(x_0) = \\frac{L-x_0}{v} + \\frac{D}{v^2} \\left( e^{-vL/D} - e^{-vx_0/D} \\right)$\n    - 注意，如果 $x_0 = L$，粒子已在吸收边界上，因此 $T_{\\mathcal{R}\\mathcal{A}}(L) = 0$。\n\n2.  **构型 $\\mathcal{A}\\mathcal{A}$ 的平均首达时间：**\n    - 若 $v=0$：$T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{x_0(L-x_0)}{2D}$\n    - 若 $v \\neq 0$：$T_{\\mathcal{A}\\mathcal{A}}(x_0) = \\frac{1}{v} \\left( L \\frac{1 - e^{-vx_0/D}}{1 - e^{-vL/D}} - x_0 \\right)$\n    - 注意，如果 $x_0 = 0$ 或 $x_0 = L$，粒子在吸收边界上，因此 $T_{\\mathcal{A}\\mathcal{A}}(0) = 0$ 且 $T_{\\mathcal{A}\\mathcal{A}}(L) = 0$。\n\n这些公式被用来计算给定测试用例所需的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Mean First Passage Time (MFPT) for a particle in a 1D interval\n    with two different boundary configurations.\n    \"\"\"\n    test_cases = [\n        # (L, D, v, x_0)\n        (1.0, 0.1, 0.5, 0.2),\n        (1.0, 0.1, 0.0, 0.3),\n        (1.0, 0.05, -0.2, 0.6),\n        (2.0, 0.2, 0.3, 0.0),\n        (1.5, 0.15, 0.1, 1.5),\n    ]\n\n    results = []\n    for L, D, v, x0 in test_cases:\n        # Configuration RA: Reflecting at x=0, Absorbing at x=L\n        t_ra = 0.0\n        # If starting at the absorbing boundary, time is 0.\n        if np.isclose(x0, L):\n            t_ra = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_ra = (L**2 - x0**2) / (2 * D)\n        else:\n            # Formula for v!=0\n            term1 = (L - x0) / v\n            term2 = (D / v**2) * (np.exp(-v * L / D) - np.exp(-v * x0 / D))\n            t_ra = term1 + term2\n\n        # Configuration AA: Absorbing at x=0, Absorbing at x=L\n        t_aa = 0.0\n        # If starting at either absorbing boundary, time is 0.\n        if np.isclose(x0, 0.0) or np.isclose(x0, L):\n            t_aa = 0.0\n        elif np.isclose(v, 0.0):\n            # Formula for v=0\n            t_aa = x0 * (L - x0) / (2 * D)\n        else:\n            # Formula for v!=0\n            # Numerator and denominator of the probability term\n            num = 1 - np.exp(-v * x0 / D)\n            den = 1 - np.exp(-v * L / D)\n            term1 = L * (num / den)\n            t_aa = (1 / v) * (term1 - x0)\n        \n        delta_t = t_ra - t_aa\n        \n        # Format triplet as a string \"[val1,val2,val3]\"\n        triplet_str = f\"[{t_ra:.6f},{t_aa:.6f},{delta_t:.6f}]\"\n        results.append(triplet_str)\n\n    # Final print statement in the exact required format \"[triplet1,triplet2,...]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2444438"}, {"introduction": "现在，我们将平均首达时间的概念应用于化学物理学中的一个基石问题：计算粒子跨越能垒的转变速率。双阱势是化学反应的经典模型，其中粒子必须通过随机涨落获得足够的能量，才能从“反应物”状态“逃逸”出来 [@problem_id:2444390]。通过求解粒子逃离一个势阱的平均首达时间，你将能计算出系统的转变速率，从而将微观的扩散理论与宏观的化学动力学定律联系起来。", "problem": "要求您设计并实现一个数值方法，用于估计在由 $V(x) = x^4 - 2x^2$ 给出的一维双势阱中演化的过阻尼扩散过程的阱间跃迁速率。请完全在无量纲单位下进行计算。粒子位置 $x(t)$ 遵循 Itô 过阻尼朗之万动力学\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\n其中 $D \\gt 0$ 是（无量纲）扩散系数，$W_t$ 是标准维纳过程。相应的概率密度函数 $p(x,t)$ 的 Fokker–Planck 方程 (FPE) 是与上述随机微分方程相关联的正向演化方程。\n\n从 Fokker–Planck 方程和后向 (Kolmogorov) 算子的定义出发，推导从起始位置 $x \\in [x_{\\min}, x_{\\max}]$ 到势垒顶部的吸收边界的平均首达时间 $m(x)$ 的一个适定边值问题。使用以下物理上一致的设置：\n- 势：$V(x) = x^4 - 2x^2$，在 $x = \\pm 1$ 附近有极小值点，在 $x=0$ 处有一个鞍点。\n- 定义域：$[x_{\\min}, x_{\\max}] = [-2.0, 0.0]$。\n- 初始位置：$x_0 = -1.0$。\n- 边界条件：在 $x_{\\min}$ 处为反射边界，在 $x_{\\max}$ 处为吸收边界。\n\n在推导出 $m(x)$ 的边值问题后，实现一个稳定的数值求解策略（例如，在均匀网格上对后向方程进行二阶中心有限差分格式离散化，并恰当实现反射和吸收边界条件，或者使用从相同推导中得出的解析等价的求积表示）。根据计算出的初始位置处的平均首达时间 $m(x_0)$，将跃迁速率定义为 $k = 1/m(x_0)$，单位为无量纲时间的倒数。\n\n您的程序必须计算并报告以下测试集中每个扩散系数对应的跃迁速率 $k$：\n- $D = 0.1$ (小噪声，稀有跃迁；理想情况)。\n- $D = 0.2$ (中等噪声)。\n- $D = 0.5$ (噪声增大)。\n- $D = 1.0$ (噪声与势垒高度相当)。\n- $D = 1.5$ (大噪声；边界情况)。\n\n要求：\n- 将所有量视为无量纲。以浮点数形式报告跃迁速率 $k$，单位为无量纲时间的倒数。\n- 您的离散化必须足够精确，以捕捉 $k$ 作为 $D$ 函数的变化趋势，并对上述所有测试用例保持数值稳定。\n- 最终输出格式：您的程序应生成单行输出，其中包含按上述 $D$ 值顺序排列的结果，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到八位小数（例如，\"[0.12345678,0.23456789,0.34567890,0.45678901,0.56789012]\"）。", "solution": "我们从过阻尼朗之万方程开始\n$$\ndx(t) = -V'(x(t))\\,dt + \\sqrt{2D}\\,dW_t,\n$$\n该方程导出正向 Fokker–Planck 方程\n$$\n\\partial_t p(x,t) = \\partial_x\\!\\left(V'(x)\\,p(x,t)\\right) + D\\,\\partial_{xx} p(x,t).\n$$\n对于该过程的泛函，与生成元相关联的后向 (Kolmogorov) 算子是\n$$\n\\mathcal{L} f(x) = -V'(x)\\,f'(x) + D\\,f''(x).\n$$\n设 $m(x)$ 表示从起始点 $x$ 到达吸收边界 $x_{\\max}$ 的平均首达时间 (MFPT)，其中在 $x_{\\min}$ 处为反射边界。标准首达理论指出，$m(x)$ 满足边值问题\n$$\n\\mathcal{L} m(x) = -1 \\quad \\text{for } x \\in (x_{\\min}, x_{\\max}),\n$$\n其边界条件为\n$$\nm'(x_{\\min}) = 0 \\quad \\text{(反射)}, \\qquad m(x_{\\max}) = 0 \\quad \\text{(吸收)}.\n$$\n对于当前问题，我们设定 $x_{\\min} = -2.0$，$x_{\\max} = 0.0$，初始位置 $x_0 = -1.0$。将算子代入后向方程，得到常微分方程\n$$\nD\\,m''(x) - V'(x)\\,m'(x) = -1, \\quad x \\in (-2,0),\n$$\n以及\n$$\nm'(-2) = 0, \\qquad m(0) = 0.\n$$\n\n有两种高效且数学上一致的数值策略可以求解此一维边值问题：\n\n1) 有限差分法。用均匀网格离散化区间 $[x_{\\min}, x_{\\max}]$，在内部使用中心差分近似 $m''(x)$ 和 $m'(x)$，在 $x_{\\min}$ 处使用单边二阶公式施加诺伊曼边界条件，并在 $x_{\\max}$ 处直接施加狄利克雷条件。这将得到关于 $m(x)$ 节点值的稀疏线性系统，该系统可用标准线性代数求解器求解。\n\n2) 通过积分因子得到求积表示。该常微分方程可以解析地化简为嵌套积分。定义 $\\phi(x) = V(x)/D$。将方程重写为\n$$\nm''(x) - \\phi'(x)\\,m'(x) = -\\frac{1}{D}.\n$$\n令 $y(x) = m'(x)$。则有\n$$\ny'(x) - \\phi'(x)\\,y(x) = -\\frac{1}{D}.\n$$\n两边乘以积分因子 $e^{-\\phi(x)}$ 得到\n$$\n\\frac{d}{dx}\\!\\left(e^{-\\phi(x)} y(x)\\right) = -\\frac{1}{D} e^{-\\phi(x)}.\n$$\n从 $x_{\\min}$ 积分到 $x$，并使用反射边界条件 $m'(x_{\\min}) = 0$，得到\n$$\nm'(x) = -\\frac{e^{\\phi(x)}}{D}\\int_{x_{\\min}}^{x} e^{-\\phi(z)}\\,dz.\n$$\n再次从 $x$ 积分到 $x_{\\max}$，并使用 $m(x_{\\max}) = 0$，得到经典的一维 MFPT 公式\n$$\nm(x) = \\frac{1}{D} \\int_{x}^{x_{\\max}} e^{\\phi(y)} \\left[\\int_{x_{\\min}}^{y} e^{-\\phi(z)}\\,dz \\right] dy.\n$$\n此表示法在解析上等价于边值问题的有限差分解，并且对于当前的势和测试参数，在均匀网格上使用标准求积法则进行计算是数值稳定的。值得注意的是，在区间 $[x_0, x_{\\max}] = [-1,0]$ 上，$V(y) \\le 0$，这使得 $e^{\\phi(y)} \\le 1$，有助于保持外层积分的数值稳定性。随着 $D$ 的减小，内层积分会增大，这正确地反映了 MFPT 的增长。\n\n算法设计：\n- 在 $[x_{\\min}, x_{\\max}]$ 上构建一个间距为 $\\Delta x$ 的均匀网格 $x_i$。\n- 预计算 $V(x_i) = x_i^4 - 2 x_i^2$。\n- 对于测试集中的每个 $D$，计算 $\\phi_i = V(x_i)/D$。\n- 通过使用累加和的梯形法则计算内层累积积分 $A(y) = \\int_{x_{\\min}}^{y} e^{-\\phi(z)} dz$，以 $\\mathcal{O}(N)$ 的时间复杂度获得所有 $A(x_i)$。\n- 在网格上构造 $B(y) = e^{\\phi(y)} A(y)$。\n- 使用从右到左的累积梯形和计算所有 $x$ 的外层积分 $C(x) = \\int_{x}^{x_{\\max}} B(y) dy$。然后 $m(x) = C(x)/D$。\n- 在网格上定位 $x_0$ 并计算 $m(x_0)$。跃迁速率为 $k = 1/m(x_0)$。\n\n数值考量：\n- 所选网格大小必须在精度和运行时间之间取得平衡；在 $[-2,0]$ 上使用 $N = 10001$ 个点的均匀网格，可得 $\\Delta x = 2/10000$，这对于所有测试扩散系数下精确计算嵌套的梯形积分是足够的。\n- 所有计算均采用双精度；对于测试集中最小的 $D$ ($D = 0.1$)，$e^{1/D}$ 的值仍在安全的浮点数范围内。\n- 算法通过累加和实现完全向量化，以确保效率。\n\n最后，我们计算并报告测试扩散系数 $D \\in \\{0.1, 0.2, 0.5, 1.0, 1.5\\}$ 对应的跃迁速率 $k$，单位为无量纲时间的倒数。程序以指定格式打印一行，包含五个速率值，每个值都四舍五入到八位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef potential(x):\n    # V(x) = x^4 - 2 x^2\n    return x**4 - 2.0 * x**2\n\ndef compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0):\n    # Compute phi = V/D\n    phi = Vx / D\n\n    # Grid spacing (assume uniform)\n    h = x_grid[1] - x_grid[0]\n    N = x_grid.size\n\n    # Inner integral A(y) = \\int_{x_min}^y exp(-phi(z)) dz using cumulative trapezoid\n    exp_neg_phi = np.exp(-phi)\n    # Trapezoidal cumulative integral: A[0] = 0; for i>=1, A[i] = sum_{k=0..i-1} 0.5*(f[k]+f[k+1])*h\n    A = np.zeros(N)\n    if N > 1:\n        A[1:] = h * np.cumsum(0.5 * (exp_neg_phi[:-1] + exp_neg_phi[1:]))\n\n    # Outer integrand B(y) = exp(phi(y)) * A(y)\n    exp_phi = np.exp(phi)\n    B = exp_phi * A\n\n    # Outer integral C(x) = \\int_{x}^{x_max} B(y) dy using right-to-left cumulative trapezoid\n    # Define mid-interval averages for trapezoid\n    mid = 0.5 * (B[:-1] + B[1:])  # length N-1\n    # Suffix cumulative sum via reversed cumsum\n    s_rev = np.cumsum(mid[::-1])  # length N-1\n    C = np.zeros(N)\n    if N > 1:\n        # Map back: for node i in [0..N-2], C[i] = h * sum_{j=i}^{N-2} mid[j] = h * s_rev[N-2 - i]\n        C[:-1] = h * s_rev[::-1]\n        C[-1] = 0.0\n\n    # MFPT m(x) = C(x)/D\n    m = C / D\n\n    # Interpolate (or directly index) at x0\n    h_inv = 1.0 / h\n    idx_float = (x0 - x_min) * h_inv\n    idx = int(round(idx_float))\n    idx = max(0, min(N - 1, idx))\n    # If x0 is not exactly on a grid node due to rounding, do linear interpolation\n    x_idx = x_grid[idx]\n    if abs(x_idx - x0)  1e-12 or idx == 0 or idx == N - 1:\n        m_x0 = m[idx]\n    else:\n        if x_idx  x0 and idx + 1  N:\n            t = (x0 - x_idx) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx + 1]\n        elif x_idx > x0 and idx - 1 >= 0:\n            t = (x_idx - x0) * h_inv\n            m_x0 = (1 - t) * m[idx] + t * m[idx - 1]\n        else:\n            m_x0 = m[idx]\n\n    # Transition rate k = 1 / m(x0)\n    # Guard against zero or negative (should not occur for well-posed MFPT)\n    if m_x0 = 0:\n        return float('nan')\n    return 1.0 / m_x0\n\ndef solve():\n    # Domain and initial position (dimensionless)\n    x_min = -2.0\n    x_max = 0.0\n    x0 = -1.0\n\n    # Uniform grid with sufficient resolution for stable and accurate quadrature\n    N = 10001  # ensures x0 aligns exactly with grid for this domain\n    x_grid = np.linspace(x_min, x_max, N)\n    Vx = potential(x_grid)\n\n    # Test suite diffusion coefficients (dimensionless)\n    test_cases = [0.1, 0.2, 0.5, 1.0, 1.5]\n\n    results = []\n    for D in test_cases:\n        rate = compute_rate_via_quadrature(D, x_grid, Vx, x_min, x_max, x0)\n        # Round to eight decimals as specified\n        results.append(f\"{rate:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2444390"}]}