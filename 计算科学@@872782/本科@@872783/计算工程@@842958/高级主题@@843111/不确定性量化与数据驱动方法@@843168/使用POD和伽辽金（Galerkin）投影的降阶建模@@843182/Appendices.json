{"hands_on_practices": [{"introduction": "本练习旨在深入探讨伽辽金投影（Galerkin projection）的基本机理。通过对经典的一维对流-扩散方程进行解析推导，我们将观察到物理过程（如对流和扩散）如何被转化为具有独特数学性质和能量作用的降阶矩阵。这项实践将帮助你建立对降阶模型（ROM）内在结构的核心理解 [@problem_id:2432108]。", "problem": "考虑空间区间 $x \\in (0,1)$ 上具有齐次狄利克雷边界条件的一维对流扩散方程\n$$\n\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = \\nu\\,\\frac{\\partial^2 u}{\\partial x^2}, \\quad u(0,t)=u(1,t)=0,\n$$\n其中 $a0$ 是恒定的对流速度，$\\nu0$ 是恒定的运动粘度。假设一个本征正交分解 (POD) 基是可用的，并且它与狄利克雷拉普拉斯算子的前 $r$ 个正弦本征函数一致，即\n$$\n\\phi_k(x) = \\sqrt{2}\\,\\sin(k\\pi x), \\quad k=1,\\dots,r,\n$$\n它们在 $L^2(0,1)$ 内积下是标准正交的。使用标准的伽辽金投影方法，将方程投影到由 $L^2(0,1)$ 内积定义的 $\\text{span}\\{\\phi_1,\\dots,\\phi_r\\}$ 空间上，为由 ansatz 定义的广义坐标 $q_k(t)$ 推导降阶模型 (ROM)\n$$\nu(x,t) \\approx \\sum_{k=1}^r q_k(t)\\,\\phi_k(x).\n$$\n通过将 ROM 表示为以下形式，确定降阶对流矩阵和降阶扩散矩阵\n$$\nM\\,\\dot{\\boldsymbol{q}}(t) + a\\,C\\,\\boldsymbol{q}}(t) + \\nu\\,K\\,\\boldsymbol{q}}(t) = \\boldsymbol{0},\n$$\n其中 $M$ 是降阶质量矩阵，$C$ 是降阶对流矩阵，$K$ 是降阶扩散（刚度）矩阵。然后，根据由 $\\frac{1}{2}\\|\\boldsymbol{q}(t)\\|_2^2$ 定义的降阶动能的演化，分析 $C$ 和 $K$ 的能量作用。\n\n最后，令 $r=4$ 并定义以下无量纲标量，它在降阶层面上量化了对流与扩散强度的最坏情况比率：\n$$\n\\rho_4 \\equiv \\frac{a\\,\\max_{1\\leq i\\neq j\\leq 4} |C_{ij}|}{\\nu\\,\\max_{1\\leq i\\leq 4} K_{ii}}.\n$$\n计算 $\\rho_4$ 关于 $a$、$\\nu$ 和 $\\pi$ 的闭式解析表达式。您的最终答案必须是单一表达式。不需要四舍五入，最终表达式中不应包含单位。", "solution": "在尝试任何解答之前，需要对问题陈述进行验证。\n\n步骤1：提取已知条件\n-   偏微分方程 (PDE)：在定义域 $x \\in (0,1)$ 上为 $\\frac{\\partial u}{\\partial t} + a\\,\\frac{\\partial u}{\\partial x} = \\nu\\,\\frac{\\partial^2 u}{\\partial x^2}$。\n-   边界条件 (BCs)：$u(0,t)=u(1,t)=0$。\n-   常数：对流速度 $a0$，运动粘度 $\\nu0$。\n-   本征正交分解 (POD) 基：$\\phi_k(x) = \\sqrt{2}\\,\\sin(k\\pi x)$，对于 $k=1,\\dots,r$。该基被指定在 $L^2(0,1)$ 内积下是标准正交的，即 $\\langle f, g \\rangle = \\int_0^1 f(x)g(x)\\,dx$。\n-   降阶模型 (ROM) 的 ansatz：$u(x,t) \\approx \\sum_{k=1}^r q_k(t)\\,\\phi_k(x)$。\n-   投影方法：使用 $L^2(0,1)$ 内积的标准伽辽金投影。\n-   目标 ROM 形式：$M\\,\\dot{\\boldsymbol{q}}(t) + a\\,C\\,\\boldsymbol{q}}(t) + \\nu\\,K\\,\\boldsymbol{q}}(t) = \\boldsymbol{0}$。\n-   任务1：推导矩阵 $M$、$C$ 和 $K$。\n-   任务2：分析 $C$ 和 $K$ 对降阶动能 $\\frac{1}{2}\\|\\boldsymbol{q}(t)\\|_2^2$ 演化的能量作用。\n-   任务3：对于 $r=4$，计算无量纲比率 $\\rho_4 \\equiv \\frac{a\\,\\max_{1\\leq i\\neq j\\leq 4} |C_{ij}|}{\\nu\\,\\max_{1\\leq i\\leq 4} K_{ii}}$。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，是适定且客观的。它涉及将标准模型降阶技术（POD 和伽辽金投影）应用于工程和物理学中的一个基本模型方程（对流扩散方程）。该问题是自洽的，提供了所有必要的定义、方程和基函数。这些任务在数学上是精确的，并能导出一个唯一的、可验证的解。不存在科学或逻辑上的缺陷，没有歧义，也不依赖于主观论断。\n\n步骤3：结论和行动\n问题有效。将构建一个解答。\n\n降阶模型 (ROM) 的推导\n\n我们将 ansatz $u(x,t) = \\sum_{k=1}^r q_k(t)\\phi_k(x)$ 代入控制偏微分方程：\n$$\n\\frac{\\partial}{\\partial t}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right) + a\\,\\frac{\\partial}{\\partial x}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right) = \\nu\\,\\frac{\\partial^2}{\\partial x^2}\\left(\\sum_{k=1}^r q_k(t)\\phi_k(x)\\right)\n$$\n根据导数的线性性质，这变成：\n$$\n\\sum_{k=1}^r \\dot{q}_k(t)\\phi_k(x) + a\\sum_{k=1}^r q_k(t)\\frac{d\\phi_k}{dx}(x) - \\nu\\sum_{k=1}^r q_k(t)\\frac{d^2\\phi_k}{dx^2}(x) = 0\n$$\n伽辽金投影要求该方程的残差对于每个基函数 $\\phi_j(x)$ ($j=1,\\dots,r$) 都是正交的。这可以用 $L^2(0,1)$ 内积 $\\langle \\cdot, \\cdot \\rangle$ 表示：\n$$\n\\left\\langle \\sum_{k=1}^r \\dot{q}_k\\phi_k + a\\sum_{k=1}^r q_k\\frac{d\\phi_k}{dx} - \\nu\\sum_{k=1}^r q_k\\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle = 0 \\quad \\text{for } j=1,\\dots,r\n$$\n利用内积的线性性质，我们得到一个常微分方程组：\n$$\n\\sum_{k=1}^r \\langle \\phi_k, \\phi_j \\rangle \\dot{q}_k(t) + a \\sum_{k=1}^r \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle q_k(t) - \\nu \\sum_{k=1}^r \\left\\langle \\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle q_k(t) = 0\n$$\n通过如下定义矩阵元素，该方程组可以写成矩阵形式 $M\\dot{\\boldsymbol{q}} + aC\\boldsymbol{q} + \\nu K\\boldsymbol{q} = \\boldsymbol{0}$：\n$M_{jk} = \\langle \\phi_k, \\phi_j \\rangle$\n$C_{jk} = \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle$\n$K_{jk} = -\\left\\langle \\frac{d^2\\phi_k}{dx^2}, \\phi_j \\right\\rangle$\n\n现在我们计算每个矩阵的元素。\n降阶质量矩阵 $M$：由于基 $\\{\\phi_k\\}$ 是标准正交的，$M_{jk} = \\langle \\phi_k, \\phi_j \\rangle = \\delta_{jk}$，其中 $\\delta_{jk}$ 是克罗内克 δ。因此，$M$ 是 $r \\times r$ 的单位矩阵 $I$。\n\n降阶刚度（扩散）矩阵 $K$：基函数是带有狄利克雷边界条件的负拉普拉斯算子的本征函数。首先，我们计算 $\\phi_k(x)$ 的二阶导数：\n$$\n\\frac{d^2\\phi_k}{dx^2} = \\frac{d^2}{dx^2}\\left(\\sqrt{2}\\sin(k\\pi x)\\right) = -(k\\pi)^2 \\sqrt{2}\\sin(k\\pi x) = -(k\\pi)^2 \\phi_k(x)\n$$\n将此代入 $K_{jk}$ 的定义中：\n$$\nK_{jk} = -\\langle -(k\\pi)^2\\phi_k, \\phi_j \\rangle = (k\\pi)^2 \\langle \\phi_k, \\phi_j \\rangle = (k\\pi)^2 \\delta_{jk}\n$$\n因此，矩阵 $K$ 是一个对角矩阵，其元素为 $K_{kk} = (k\\pi)^2$。\n\n降阶对流矩阵 $C$：其元素由以下积分给出：\n$$\nC_{jk} = \\left\\langle \\frac{d\\phi_k}{dx}, \\phi_j \\right\\rangle = \\int_0^1 \\left(\\frac{d}{dx}(\\sqrt{2}\\sin(k\\pi x))\\right)(\\sqrt{2}\\sin(j\\pi x))\\,dx = 2k\\pi \\int_0^1 \\cos(k\\pi x)\\sin(j\\pi x)\\,dx\n$$\n使用积化和差恒等式 $\\sin(A)\\cos(B) = \\frac{1}{2}(\\sin(A+B)+\\sin(A-B))$，我们得到：\n$$\nC_{jk} = k\\pi \\int_0^1 \\left( \\sin((j+k)\\pi x) + \\sin((j-k)\\pi x) \\right)\\,dx\n$$\n如果 $j=k$，被积函数是 $\\sin(2k\\pi x)$，其在 $[0,1]$ 上的积分为 $0$。因此，$C_{kk}=0$。这与由于齐次边界条件导致 $C$ 是斜对称的（$C_{jk} = -C_{kj}$）这一普遍性质是一致的，这可以通过分部积分法证明：$C_{jk} = \\int_0^1 \\phi_j \\phi_k' dx = [\\phi_j \\phi_k]_0^1 - \\int_0^1 \\phi_j' \\phi_k dx = 0 - C_{kj}$。\n如果 $j \\neq k$：\n$$\nC_{jk} = k\\pi \\left[ -\\frac{\\cos((j+k)\\pi x)}{(j+k)\\pi} - \\frac{\\cos((j-k)\\pi x)}{(j-k)\\pi} \\right]_0^1 = -k \\left( \\frac{(-1)^{j+k}-1}{j+k} + \\frac{(-1)^{j-k}-1}{j-k} \\right)\n$$\n由于 $(-1)^{j-k} = (-1)^{j+k}$，我们简化：\n$$\nC_{jk} = -k ((-1)^{j+k}-1) \\left( \\frac{1}{j+k} + \\frac{1}{j-k} \\right) = -k ((-1)^{j+k}-1) \\frac{2j}{j^2-k^2} = \\frac{2jk}{k^2-j^2}((-1)^{j+k}-1)\n$$\n如果 $j+k$ 是偶数，则 $(-1)^{j+k}-1=0$，所以 $C_{jk}=0$。\n如果 $j+k$ 是奇数，则 $(-1)^{j+k}-1=-2$，所以 $C_{jk} = \\frac{2jk}{k^2-j^2}(-2) = \\frac{4jk}{j^2-k^2}$。\n\n$C$ 和 $K$ 的能量分析\n降阶系统为 $\\dot{\\boldsymbol{q}}(t) + a\\,C\\,\\boldsymbol{q}}(t) + \\nu\\,K\\,\\boldsymbol{q}}(t) = \\boldsymbol{0}$。降阶动能为 $E(t) = \\frac{1}{2}\\|\\boldsymbol{q}(t)\\|_2^2 = \\frac{1}{2}\\boldsymbol{q}(t)^T\\boldsymbol{q}(t)$。其时间导数为：\n$$\n\\frac{dE}{dt} = \\frac{1}{2}(\\dot{\\boldsymbol{q}}^T\\boldsymbol{q} + \\boldsymbol{q}^T\\dot{\\boldsymbol{q}}) = \\boldsymbol{q}^T\\dot{\\boldsymbol{q}}\n$$\n代入 $\\dot{\\boldsymbol{q}} = -aC\\boldsymbol{q} - \\nu K\\boldsymbol{q}$：\n$$\n\\frac{dE}{dt} = \\boldsymbol{q}^T(-aC\\boldsymbol{q} - \\nu K\\boldsymbol{q}) = -a\\,\\boldsymbol{q}^T C \\boldsymbol{q} - \\nu\\,\\boldsymbol{q}^T K \\boldsymbol{q}\n$$\n-   $C$ 的作用：矩阵 $C$ 是斜对称的，即 $C^T = -C$。对于任意向量 $\\boldsymbol{q}$，二次型 $\\boldsymbol{q}^T C \\boldsymbol{q}$ 总是为零。这是因为 $\\boldsymbol{q}^T C \\boldsymbol{q} = (\\boldsymbol{q}^T C \\boldsymbol{q})^T = \\boldsymbol{q}^T C^T \\boldsymbol{q} = -\\boldsymbol{q}^T C \\boldsymbol{q}$，这意味着 $2\\boldsymbol{q}^T C \\boldsymbol{q}=0$。因此，对流项 $-a\\,\\boldsymbol{q}^T C \\boldsymbol{q}$ 对能量的变化没有贡献。降阶对流算子是能量守恒的。\n-   $K$ 的作用：矩阵 $K$ 是一个对角矩阵，其元素为 $(k\\pi)^2  0$。因此，$K$ 是对称且正定的。二次型为 $\\boldsymbol{q}^T K \\boldsymbol{q} = \\sum_{k=1}^r (k\\pi)^2 q_k^2 \\ge 0$。此项仅在 $\\boldsymbol{q}=\\boldsymbol{0}$ 时为零。由于 $\\nu0$，扩散项 $-\\nu\\,\\boldsymbol{q}^T K \\boldsymbol{q}$ 总是小于或等于零。降阶扩散算子是纯耗散的，除非系统处于静止状态，否则它会不断地从系统中移除能量。\n\n$\\rho_4$ 的计算\n需要计算的表达式是 $\\rho_4 = \\frac{a\\,\\max_{1\\leq i\\neq j\\leq 4} |C_{ij}|}{\\nu\\,\\max_{1\\leq i\\leq 4} K_{ii}}$，其中 $r=4$。\n\n分母：$K$ 的对角元素为 $K_{ii} = (i\\pi)^2$。我们需要 $i \\in \\{1,2,3,4\\}$ 的最大值。\n$$\n\\max_{1\\leq i\\leq 4} K_{ii} = \\max\\{(1\\pi)^2, (2\\pi)^2, (3\\pi)^2, (4\\pi)^2\\} = (4\\pi)^2 = 16\\pi^2\n$$\n\n分子：我们需要找到 $|C_{ij}|$ 在 $1 \\leq i \\neq j \\leq 4$ 范围内的最大值。我们只需要检查 $i+j$ 为奇数的数对 $(i,j)$。由于 $|C_{ij}|=|C_{ji}|$，我们只考虑 $ij$ 的情况：\n- $i=1, j=2$ ($i+j=3$): $|C_{12}| = |\\frac{4(1)(2)}{2^2-1^2}| = \\frac{8}{3} \\approx 2.67$\n- $i=1, j=4$ ($i+j=5$): $|C_{14}| = |\\frac{4(1)(4)}{4^2-1^2}| = \\frac{16}{15} \\approx 1.07$\n- $i=2, j=3$ ($i+j=5$): $|C_{23}| = |\\frac{4(2)(3)}{3^2-2^2}| = \\frac{24}{5} = 4.8$\n- $i=3, j=4$ ($i+j=7$): $|C_{34}| = |\\frac{4(3)(4)}{4^2-3^2}| = \\frac{48}{7} \\approx 6.86$\n其他组合（如 $i=1,j=3$ 或 $i=2,j=4$）的 $i+j$ 是偶数，因此 $C_{ij}=0$。\n最大值是 $|C_{34}| = \\frac{48}{7}$。\n\n因此，$\\rho_4$ 的值为：\n$$\n\\rho_4 = \\frac{a \\cdot \\frac{48}{7}}{\\nu \\cdot 16\\pi^2} = \\frac{48a}{7 \\cdot 16\\pi^2\\nu} = \\frac{3a}{7\\pi^2\\nu}\n$$", "answer": "$$\n\\boxed{\\frac{3a}{7\\nu\\pi^{2}}}\n$$", "id": "2432108"}, {"introduction": "从理论走向实践，本练习将引导你完成构建数据驱动降阶模型的完整计算流程。我们将处理一个更复杂的二维L型域上的热扩散问题，涵盖从全阶模型仿真和快照数据收集，到本征正交分解（POD）基生成和ROM评估的每一步。这项实践将巩固你实现和分析降阶模型的实用技能 [@problem_id:2432054]。", "problem": "考虑一个 L 形区域上的二维热方程。设空间域为去除右上角四分之一的开放单位正方形，即\n$$\n\\Omega_L = (0,1)\\times(0,1)\\setminus([0.5,1]\\times[0.5,1])。\n$$\n令 $u(x,y,t)$ 满足齐次狄利克雷初边值问题\n$$\n\\frac{\\partial u}{\\partial t}(x,y,t) = \\kappa \\,\\Delta u(x,y,t)\\ \\text{for}\\ (x,y)\\in \\Omega_L,\\ t0,\\quad\nu(x,y,t)=0\\ \\text{for}\\ (x,y)\\in \\partial \\Omega_L,\\ t\\ge 0,\\quad\nu(x,y,0)=u_0(x,y),\n$$\n其中扩散系数 $\\kappa = 1$，初始条件为\n$$\nu_0(x,y)=\\exp\\!\\left(-\\frac{(x-0.5)^2+(y-0.5)^2}{\\sigma^2}\\right),\\quad \\sigma=0.12。\n$$\n在每个空间方向上使用 $N=41$ 个点的均匀笛卡尔网格对 $\\Omega_L$ 进行离散化，均匀间距为 $h=1/(N-1)$，并将索引为 $i,j\\in\\{1,2,\\dots,N-2\\}$ 的内部网格节点视为未知量。一个节点 $(x_i,y_j)$ 被包含在计算集中，当且仅当它属于 $\\Omega_L$，即满足 $\\neg(x_i\\ge 0.5\\ \\wedge\\ y_j\\ge 0.5)$。使用标准的五点离散拉普拉斯算子，并通过对 $\\Omega_L$ 外部或外边界上的邻点代入零来施加齐次狄利克雷条件。这将产生一个对称负半定矩阵算子 $L\\in\\mathbb{R}^{n\\times n}$，其对角线元素为 $-4/h^2$，对于网格图中每个存在的邻点，其非对角线元素为 $1/h^2$，其中 $n$ 是所包含节点的数量。\n\n使用后向欧拉法（也称为隐式欧拉法）和均匀时间步长对半离散系统进行时间推进。设时间步长为 $\\Delta t=5\\times 10^{-4}$，时间步数为 $N_t=240$，因此最终时间为 $T=N_t\\,\\Delta t=0.12$。每隔 $s_{\\text{skip}}=6$ 步收集一次状态快照序列，生成包含 $m=40$ 个快照的快照矩阵 $X\\in\\mathbb{R}^{n\\times m}$。\n\n从 $X$ 中，将在 $\\mathbb{R}^n$ 上的标准欧几里得内积（在此网格上，这与离散 $L^2$ 内积相差一个常数因子 $h^2$）下 $X$ 的前 $r$ 个左奇异向量定义为秩为 $r$ 的固有正交分解 (POD) 基。令 $V_r\\in\\mathbb{R}^{n\\times r}$ 表示由这些标准正交列组成的矩阵。通过将半离散算子伽辽金投影到 POD 子空间上，定义降阶模型 (ROM)，其降阶算子为\n$$\nA_r = V_r^\\top L V_r\\in\\mathbb{R}^{r\\times r},\n$$\n降阶状态 $a(t)\\in\\mathbb{R}^r$ 根据 $a'(t)=A_r a(t)$ 演化，初始条件为 $a(0)=V_r^\\top u_0$，并使用与全阶模型相同的后向欧拉格式和时间步长推进到时间 $T$。令 $u(T)\\in\\mathbb{R}^n$ 表示在时间 $T$ 的全离散状态，而 $u_r(T)=V_r a(T)$ 表示在时间 $T$ 的 ROM 重构。\n\n对于给定的秩 $r$，定义：\n- POD 能量捕获\n$$\nE_r=\\frac{\\sum_{i=1}^{r}\\sigma_i^2}{\\sum_{i=1}^{m}\\sigma_i^2},\n$$\n其中 $\\{\\sigma_i\\}$ 是 $X$ 的按非增序排列的奇异值。\n- 最终时刻相对状态误差\n$$\nR_r=\\frac{\\lVert u(T)-u_r(T)\\rVert_2}{\\lVert u(T)\\rVert_2}。\n$$\n- 主导 POD 模态 $v_1$ 的角点集中度度量，用于量化凹角 $(0.5,0.5)$ 附近的能量：\n$$\nC_r(\\rho)=\\frac{\\sum_{k: \\sqrt{(x_k-0.5)^2+(y_k-0.5)^2}\\le \\rho} \\left(v_1\\right)_k^2}{\\sum_{k=1}^{n} \\left(v_1\\right)_k^2},\n$$\n其中 $(x_k,y_k)$ 是对应第 $k$ 个自由度的网格节点的物理坐标。如果 $r=0$，按约定定义 $C_0(\\rho)=0$。如果 $r$ 超过 $X$ 的数值秩，则使用所有可用模态。\n\n测试组。使用上述固定的离散化和时间积分参数，并针对以下四种情况评估三元组 $(E_r,R_r,C_r(\\rho))$：\n1. $r=0$, $\\rho=0.10$。\n2. $r=1$, $\\rho=0.08$。\n3. $r=5$, $\\rho=0.12$。\n4. $r=20$, $\\rho=0.15$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含 12 个浮点数结果，形式为一个扁平的、逗号分隔的列表，并用方括号括起来，顺序如下：\n$$\n[E_{r_1},R_{r_1},C_{r_1}(\\rho_1),E_{r_2},R_{r_2},C_{r_2}(\\rho_2),E_{r_3},R_{r_3},C_{r_3}(\\rho_3),E_{r_4},R_{r_4},C_{r_4}(\\rho_4)]。\n$$\n每个浮点值必须四舍五入到六位小数。没有物理单位；所有量均为无量纲。不使用角度。不得使用百分比；将 $E_r$ 和 $R_r$ 报告为小数。", "solution": "该问题要求针对一个特定的 L 形区域上的二维热方程，构建并评估一个降阶模型 (ROM)。这将通过一系列明确定义的步骤来完成：进行空间和时间离散化以创建全阶模型 (FOM)，仿真 FOM 以生成状态数据，应用固有正交分解 (POD) 以提取低维基，最后，使用伽辽金投影来构建和求解 ROM。ROM 的准确性和属性将使用一组指定的度量指标进行量化。\n\n首先，我们处理全阶模型 (FOM)。控制偏微分方程是在区域 $\\Omega_L = (0,1)\\times(0,1)\\setminus([0.5,1]\\times[0.5,1])$ 上的热方程 $\\frac{\\partial u}{\\partial t} = \\kappa \\Delta u$，其中扩散系数 $\\kappa=1$ 并采用齐次狄利克雷边界条件。该区域使用每个方向上 $N=41$ 个点的均匀笛卡尔网格进行离散化，得到的网格间距为 $h = 1/(N-1) = 1/40$。我们模型的自由度是内部网格节点上的温度 $u$ 的值。通过排除所有满足 $x_i \\geq 0.5$ 且 $y_j \\geq 0.5$ 的内部节点 $(x_i, y_j)$ 来实现区域的 L 形。这总共得到 $n=1121$ 个内部节点。我们为这 $n$ 个节点的二维网格索引 $(i,j)$ 与一维索引 $k \\in \\{0, 1, \\dots, n-1\\}$ 之间建立一个映射，这使我们能够将系统状态表示为一个向量 $\\mathbf{u}(t) \\in \\mathbb{R}^n$。\n\n空间算子，即拉普拉斯算子 $\\Delta$，使用标准的五点有限差分模板进行离散化。这会得到一个线性常微分方程组 (ODEs)，这是一种称为线法（method of lines）的半离散化方法：$\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}(t)$。在这里，$L \\in \\mathbb{R}^{n \\times n}$ 是离散拉普拉斯算子的矩阵表示。对于每个节点 $k$，对应的对角线元素是 $L_{kk} = -4/h^2$。对于每个同样在计算域内的邻近节点 $k'$，非对角线元素是 $L_{k'k} = L_{kk'} = 1/h^2$。由于齐次狄利克雷边界条件，边界上或区域外的邻点对该方程组没有贡献。得到的矩阵 $L$ 是对称且负半定的，正确地反映了连续算子的性质。\n\n对于时间积分，我们采用后向欧拉法。给定在时间 $t_k$ 的状态 $\\mathbf{u}_k$，在时间 $t_{k+1}=t_k+\\Delta t$ 的状态 $\\mathbf{u}_{k+1}$ 是通过求解线性系统 $(\\mathbf{u}_{k+1} - \\mathbf{u}_k)/\\Delta t = L\\mathbf{u}_{k+1}$ 得到的。整理后得到 $(I - \\Delta t L)\\mathbf{u}_{k+1} = \\mathbf{u}_k$。矩阵 $A_{BE} = I - \\Delta t L$ 是稀疏、对称且正定的，并且在整个仿真过程中保持不变。我们可以预先对其进行分解（例如，使用 LU 或 Cholesky 分解）以便在每个时间步高效地求解 $\\mathbf{u}_{k+1}$。使用指定的时间步长 $\\Delta t = 5 \\times 10^{-4}$，将 FOM 从 $t=0$ 仿真到最终时间 $T=0.12$。初始条件是在网格节点上评估的高斯脉冲 $\\mathbf{u}(0) = \\mathbf{u}_0$。在仿真过程中，我们每隔 $s_{\\text{skip}}=6$ 步收集一次状态向量的快照，形成一个快照矩阵 $X = [\\mathbf{u}^{(1)}, \\mathbf{u}^{(2)}, \\dots, \\mathbf{u}^{(m)}] \\in \\mathbb{R}^{n \\times m}$，其中 $m=40$。\n\n接下来，我们构建 ROM。ROM 的基础是 POD 基，它为快照数据提供了最优的低秩近似。该基是通过计算快照矩阵的奇异值分解 (SVD) 得到的，$X = U \\Sigma W^\\top$。$U \\in \\mathbb{R}^{n \\times m}$ 矩阵的列是左奇异向量，也称为 POD 模态。这些模态是标准正交的，并按照它们从快照中捕获的能量大小进行排序，能量大小由 $\\Sigma$ 对角线上的相应奇异值 $\\sigma_i$ 来量化。秩为 $r$ 的 POD 基，记为 $V_r \\in \\mathbb{R}^{n \\times r}$，由取 $U$ 的前 $r$ 列构成。\n\nROM 是使用伽辽金投影推导出来的。我们寻求形式为 $\\mathbf{u}(t) \\approx V_r \\mathbf{a}(t)$ 的近似解，其中 $\\mathbf{a}(t) \\in \\mathbb{R}^r$ 是降阶坐标向量。将此拟设代入半离散 FOM 方程得到 $V_r \\frac{d\\mathbf{a}}{dt} \\approx L V_r \\mathbf{a}(t)$。为了求解 $\\mathbf{a}(t)$，我们将该方程投影到由基向量张成的子空间上。由于基是标准正交的 ($V_r^\\top V_r = I_r$)，这会产生降阶常微分方程组：$\\frac{d\\mathbf{a}}{dt} = (V_r^\\top L V_r) \\mathbf{a}(t) = A_r \\mathbf{a}(t)$。降阶算子 $A_r \\in \\mathbb{R}^{r \\times r}$ 比 $L$ 小得多。ROM 的初始条件是完整初始条件的投影：$\\mathbf{a}(0) = V_r^\\top \\mathbf{u}_0$。然后使用相同的后向欧拉格式对这个小的 $r \\times r$ 系统进行时间积分，以求得最终时刻的降阶状态 $\\mathbf{a}(T)$。然后，近似的全状态解被重构为 $\\mathbf{u}_r(T) = V_r \\mathbf{a}(T)$。\n\n最后，我们为每个测试案例 $(r, \\rho)$ 评估指定的度量指标。\nPOD 能量捕获，$E_r = (\\sum_{i=1}^{r} \\sigma_i^2) / (\\sum_{i=1}^{m} \\sigma_i^2)$，衡量前 $r$ 个模态捕获的快照数据中总方差的比例。对于 $r=0$，$E_0=0$。\n最终时刻相对状态误差，$R_r = \\lVert \\mathbf{u}(T) - \\mathbf{u}_r(T) \\rVert_2 / \\lVert \\mathbf{u}(T) \\rVert_2$，量化 ROM 解的准确性。对于 $r=0$，ROM 基是空的，所以 $\\mathbf{u}_0(T)=\\mathbf{0}$，导致 $R_0 = 1$。\n角点集中度度量，$C_r(\\rho) = (\\sum_{k: d_k \\le \\rho} (v_1)_k^2) / (\\sum_{k=1}^{n} (v_1)_k^2)$，其中 $d_k$ 是节点 $k$ 到凹角 $(0.5, 0.5)$ 的距离，$v_1$ 是主导 POD 模态。由于 $v_1$ 是单位向量，分母为 1。按照约定，$C_0(\\rho)=0$。对于 $r0$，该度量量化了最主导的动态模态的“能量”在区域角点奇点半径 $\\rho$ 范围内的集中程度。\n\n实现过程将首先建立网格和 FOM 算子 $L$。然后，将仿真 FOM 以生成快照和最终状态 $\\mathbf{u}(T)$。对快照矩阵进行 SVD 将得到 POD 模态 $U$ 和奇异值 $\\sigma$。对于每个测试案例，将使用这些预先计算的量来计算相应的度量指标，并在必要时通过仿真相应的 ROM 来完成计算。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import splu\nfrom scipy.linalg import lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Solves the problem of reduced-order modeling for the 2D heat equation\n    on an L-shaped domain.\n    \"\"\"\n    #\n    # === 1. Problem Parameters and Grid Setup ===\n    #\n    N = 41\n    h = 1.0 / (N - 1)\n    kappa = 1.0\n    sigma_ic = 0.12\n    dt = 5.0e-4\n    Nt = 240\n    T_final = Nt * dt\n    s_skip = 6\n    m = Nt // s_skip\n\n    # Define test cases\n    test_cases = [\n        {'r': 0, 'rho': 0.10},\n        {'r': 1, 'rho': 0.08},\n        {'r': 5, 'rho': 0.12},\n        {'r': 20, 'rho': 0.15},\n    ]\n\n    # Generate grid and identify interior nodes for the L-shaped domain\n    interior_nodes = []\n    node_map = {}\n    \n    # Grid coordinates including boundaries\n    x_coords = np.linspace(0, 1, N)\n    y_coords = np.linspace(0, 1, N)\n\n    # Interior indices are from 1 to N-2\n    for j in range(1, N - 1):\n        for i in range(1, N - 1):\n            x, y = i * h, j * h\n            if not (x = 0.5 and y = 0.5):\n                node_idx = len(interior_nodes)\n                interior_nodes.append({'glob_idx': (i, j), 'coords': (x, y)})\n                node_map[(i, j)] = node_idx\n    \n    n = len(interior_nodes) # Number of degrees of freedom\n\n    #\n    # === 2. Full-Order Model (FOM) Assembly ===\n    #\n    L = sparse.lil_matrix((n, n), dtype=np.float64)\n    h2_inv = 1.0 / (h * h)\n    \n    for k, node_info in enumerate(interior_nodes):\n        i, j = node_info['glob_idx']\n        L[k, k] = -4.0 * h2_inv\n        \n        neighbors = [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]\n        for neighbor_glob_idx in neighbors:\n            if neighbor_glob_idx in node_map:\n                neighbor_k = node_map[neighbor_glob_idx]\n                L[k, neighbor_k] = 1.0 * h2_inv\n\n    # Convert to CSC format for efficient computations\n    L_csc = L.tocsc()\n\n    #\n    # === 3. FOM Time Integration and Snapshot Collection ===\n    #\n    u0 = np.zeros(n, dtype=np.float64)\n    for k, node_info in enumerate(interior_nodes):\n        x, y = node_info['coords']\n        u0[k] = np.exp(-((x - 0.5)**2 + (y - 0.5)**2) / sigma_ic**2)\n\n    A_BE = sparse.identity(n, format='csc') - dt * kappa * L_csc\n    solver = splu(A_BE)\n\n    snapshots = []\n    u_current = u0.copy()\n    \n    # Store initial state if t=0 snapshots are included (not the case here)\n    # The first snapshot is at t=dt*s_skip\n    \n    for step in range(1, Nt + 1):\n        u_current = solver.solve(u_current)\n        if step % s_skip == 0:\n            snapshots.append(u_current)\n\n    uT_fom = u_current\n    X = np.array(snapshots).T # Shape (n, m)\n\n    #\n    # === 4. POD Basis Computation ===\n    #\n    # full_matrices=False is important for efficiency\n    U, s, _ = np.linalg.svd(X, full_matrices=False)\n    \n    s_sq = s**2\n    total_energy = np.sum(s_sq)\n    \n    #\n    # === 5. ROM Simulation and Metrics Calculation ===\n    #\n    results = []\n\n    # Get coordinate array for C_r calculation\n    node_coordinates = np.array([node['coords'] for node in interior_nodes])\n    distances_from_corner = np.linalg.norm(node_coordinates - np.array([0.5, 0.5]), axis=1)\n    \n    # The leading POD mode v1 is the first column of U\n    v1 = U[:, 0]\n    # Denominator for C_r is norm(v1)^2 which is 1\n    v1_sq = v1**2\n\n    uT_fom_norm = np.linalg.norm(uT_fom)\n\n    for case in test_cases:\n        r, rho = case['r'], case['rho']\n\n        # --- Handle r=0 case ---\n        if r == 0:\n            E_r = 0.0\n            # For r=0, ROM solution u_r(T) is the zero vector.\n            # R_r = ||u(T) - 0|| / ||u(T)|| = 1\n            R_r = 1.0\n            # C_r is defined as 0 for r=0\n            C_r = 0.0\n            results.extend([E_r, R_r, C_r])\n            continue\n            \n        # --- Handle r  0 cases ---\n        \n        # Metric E_r\n        E_r = np.sum(s_sq[:r]) / total_energy\n        \n        # Metric R_r: Needs ROM simulation\n        Vr = U[:, :r]\n        a0_rom = Vr.T @ u0\n        \n        # Build and simulate ROM\n        # Note: L @ Vr is a dense matrix multiplication\n        Ar = Vr.T @ (L_csc @ Vr)\n        Ar_BE = np.identity(r) - dt * kappa * Ar\n        \n        # Dense LU factorization for the small ROM system\n        lu_r, piv_r = lu_factor(Ar_BE)\n        \n        a_current_rom = a0_rom.copy()\n        for _ in range(Nt):\n            a_current_rom = lu_solve((lu_r, piv_r), a_current_rom)\n        \n        aT_rom = a_current_rom\n        uT_rom = Vr @ aT_rom\n        \n        R_r = np.linalg.norm(uT_fom - uT_rom) / uT_fom_norm\n\n        # Metric C_r\n        # This metric always uses the leading mode v1, irrespective of r  0\n        indices_in_radius = np.where(distances_from_corner = rho)[0]\n        C_r = np.sum(v1_sq[indices_in_radius])\n        \n        results.extend([E_r, R_r, C_r])\n\n    #\n    # === 6. Final Output ===\n    #\n    formatted_results = [f\"{x:.6f}\" for x in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432054"}, {"introduction": "一个好的降阶模型不仅应能近似系统的状态，还应保持其关键的动态特性，例如稳定性。然而，本高级练习揭示了一个重要的陷阱：一个稳定全阶系统的伽辽金投影降阶模型有时会变得不稳定。通过研究一个非正规（non-normal）系统，你将深入了解标准伽辽金投影的局限性，并认识到确保降阶模型稳定性的重要性 [@problem_id:2432128]。", "problem": "要求您在降阶建模中实现一个完整的数值实验，以证明以下现象：一个本征正交分解（Proper Orthogonal Decomposition, POD）基对于重构一个稳定的全阶线性时不变系统的训练快照可能表现优异，但通过伽辽金投影（Galerkin-projected）得到的降阶模型（reduced-order model, ROM）在进行时间积分时却可能产生不稳定的、会发生爆破（blow up）的动力学行为。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数上进行，使用标准的欧几里得内积。您将全程使用 $n=2$。\n\n基本定义和要求：\n- 本征正交分解（POD）基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解（SVD）$\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取为 $\\mathbf{U}$ 的前 $r$ 列。\n- 伽辽金投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}。\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化遵循\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t)。\n$$\n- 时间积分：对全阶模型和 ROM 均使用经典的四阶龙格-库塔（Runge–Kutta）方法，采用固定的时间步长 $h0$。设置初始条件为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照收集：在训练时间域 $[0,T_{\\text{train}}]$ 上以恒定的时间步长 $h$ 对全阶模型进行积分，在每一步采样状态以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示弗罗贝尼乌斯范数（Frobenius norm）。\n- 爆破检测：在测试时间域 $[0,T_{\\text{test}}]$ 上使用相同的 $h$ 对全阶模型和 ROM 进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或者任何分量变为非数字（not-a-number）或无穷大，则宣告解“已爆破”。使用阈值 $M=10^6$。\n\n为引发 ROM 不稳定性而构造的强迫项：\n- 对于每次测试，您必须按如下方式构造常数强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（若有多个，则以确定性的方式任意选择一个）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}。\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，使用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 获得的一维 ROM 的降阶动力学为 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}0$ 且 $b_r=-a_r$，这是不稳定的，并且会从 $z(0)=0$ 发散。\n\n所有测试通用的数值设定：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典四阶龙格-库塔方法。\n- 对所有向量范数使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试套件：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上收集快照以构成 $\\mathbf{Q}$，然后构建 ROM 并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 1（高度非正规，秩为 1 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 2（高度非正规，秩为 2 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 3（对称负定，秩为 1 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 4（更高度非正规，秩为 1 的 POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求的输出：\n- 对于每个测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$，四舍五入到六位小数，\n  - 一个布尔值，指示 ROM 是否在 $[0,T_{\\text{test}}]$ 上发生爆破，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破。\n- 将所有测试的结果汇总到一行，作为一个用方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$。", "solution": "用户提出了一个计算工程领域的问题，具体涉及通过本征正交分解（POD）和伽辽金投影得到的降阶模型（ROMs）的稳定性。任务是通过数值实验来证明一种已知的失效模式：尽管全阶模型（FOM）是稳定的，降阶模型却可能变得不稳定。这种现象是受高度非正规算子支配的系统的典型特征。\n\n问题陈述已经过验证，被认为是科学上合理、适定且完整的。所有定义、参数和步骤都已明确指定，足以得到唯一且可验证的解。我们将继续进行分析和实现。\n\n问题的核心在于矩阵 $\\mathbf{A}$ 的谱（spectrum）与其数值范围（numerical range，或称值域 field of values）之间的区别，数值范围定义为 $W(\\mathbf{A}) = \\{\\mathbf{v}^\\dagger\\mathbf{A}\\mathbf{v} : \\mathbf{v} \\in \\mathbb{C}^n, \\lVert\\mathbf{v}\\rVert_2 = 1\\}$。对于线性时不变系统 $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x}$，其稳定性由 $\\mathbf{A}$ 的特征值（谱，$\\sigma(\\mathbf{A})$）决定。如果所有特征值的实部都为负，则系统是稳定的，且当 $t\\to\\infty$ 时 $\\lVert\\mathbf{x}(t)\\rVert \\to 0$。然而，如果 $\\mathbf{A}$ 是非正规的（即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$），则可能出现瞬态增长。数值范围为这种瞬态行为提供了洞察。数值范围的实部由矩阵的对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$ 控制，因为 $\\text{Re}(\\mathbf{v}^\\top\\mathbf{A}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{S}\\mathbf{v}$。$\\mathbf{S}$ 的一个正特征值意味着 $\\mathbf{A}$ 的数值范围延伸到右半平面，这表明存在瞬态能量增长的潜力。\n\n使用秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 进行伽辽金投影，将 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 转换为 ROM $\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r\\mathbf{z} + \\mathbf{b}_r$，其中 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。ROM 的稳定性由降阶矩阵 $\\mathbf{A}_r$ 的特征值决定。关键在于，$\\mathbf{A}_r$ 的特征值包含在 $\\mathbf{A}$ 的数值范围之内，但不一定在其谱的凸包之内。如果数值范围 $W(\\mathbf{A})$ 跨入右半平面，就有可能找到一个投影子空间（基为 $\\mathbf{Q}$），使得 $\\mathbf{A}_r$ 具有实部为正的特征值，从而导致 ROM 不稳定。\n\n该问题的构造旨在暴露这种病态现象。FOM 是稳定的（$\\mathbf{A}$ 的特征值为 $\\{-0.1, -1.0\\}$）。强迫项 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$ 的选择使得 FOM 的稳态为 $\\mathbf{x}_{\\infty} = \\mathbf{q}$，其中 $\\mathbf{q}$ 是与 $\\mathbf{S}$ 的最大特征值对应的特征向量。这将系统动力学推向最大瞬态增长的方向。由此产生的快照将由这个方向主导，导致主 POD 模态（$\\mathbf{Q}$ 的第一列）与 $\\mathbf{q}$ 对齐。对于秩为 1 的 ROM ($r=1$)，降阶矩阵 $\\mathbf{A}_r$ 变为标量 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$。如果 $\\mathbf{Q} \\approx \\mathbf{q}$，则 $a_r \\approx \\mathbf{q}^\\top\\mathbf{A}\\mathbf{q} = \\mathbf{q}^\\top\\mathbf{S}\\mathbf{q} = \\lambda_{\\max}(\\mathbf{S})$。对于测试 1 和测试 4 中的非正规矩阵，$\\lambda_{\\max}(\\mathbf{S})  0$，从而导致一个不稳定的 ROM。\n\n每个测试案例的计算流程如下：\n1. 定义系统参数：矩阵 $\\mathbf{A}$、ROM 秩 $r$、以及时间域 $T_{\\text{train}}$ 和 $T_{\\text{test}}$。维度为 $n=2$，时间步长为 $h=10^{-3}$。\n2. 构造强迫项：计算对称部分 $\\mathbf{S} = \\frac{1}{2}(\\mathbf{A} + \\mathbf{A}^\\top)$。找到其特征值和特征向量。设 $\\mathbf{q}$ 为对应最大特征值的归一化特征向量。设置 $\\mathbf{b} = -\\mathbf{A}\\mathbf{q}$。\n3. 生成训练数据：使用经典的四阶龙格-库塔方法，从 $\\mathbf{x}(0)=\\mathbf{0}$ 开始，在时间区间 $[0, T_{\\text{train}}]$ 上对 FOM $\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b}$ 进行积分。将每个时间步的状态收集到快照矩阵 $\\mathbf{X}$ 中。\n4. 计算 POD 基：对快照矩阵 $\\mathbf{X}$ 进行奇异值分解（SVD），$\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}$ 由 $\\mathbf{U}$ 的前 $r$ 列构成。\n5. 计算重构误差：相对弗罗贝尼乌斯范数误差计算为 $\\varepsilon_{\\text{rec}} = \\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F / \\lVert \\mathbf{X}\\rVert_F$。\n6. 构建 ROM：降阶系统矩阵为 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 和 $\\mathbf{b}_r = \\mathbf{Q}^\\top\\mathbf{b}$。\n7. 进行时间积分以进行测试：FOM 和 ROM 都从零初始条件（$\\mathbf{x}(0)=\\mathbf{0}$，$\\mathbf{z}(0)=\\mathbf{0}$）开始，在区间 $[0, T_{\\text{test}}]$ 上进行积分。在积分过程中，每一步都检查状态向量的欧几里得范数是否超过爆破阈值 $M=10^6$。\n8. 记录结果：该测试的最终输出是计算出的 $\\varepsilon_{\\text{rec}}$、一个指示 ROM 是否爆破的布尔值，以及一个指示 FOM 是否爆破的布尔值。\n\n各测试的预期结果：\n- **测试 1**：（$\\mathbf{A}$ 非正规, $r=1$）：$\\mathbf{A}$ 是稳定的。$\\mathbf{b}$ 的构造和 $r=1$ 的选择旨在产生一个不稳定的 ROM。我们预期 $\\varepsilon_{\\text{rec}}$ 会很小，ROM 会发生爆破，而 FOM 不会。\n- **测试 2**：（$\\mathbf{A}$ 非正规, $r=2$）：这里 $r=n=2$。POD 基 $\\mathbf{Q}$ 将是 $\\mathbb{R}^2$ 的一个完备标准正交基。因此，$\\mathbf{Q}\\mathbf{Q}^\\top = \\mathbf{I}$，意味着重构误差 $\\varepsilon_{\\text{rec}}$ 将为零（或在机器精度级别）。ROM 在动力学上等价于 FOM，只是在不同的基下表示。由于 FOM 是稳定的，ROM 也将是稳定的。我们预期 $\\varepsilon_{\\text{rec}} \\approx 0$，ROM 和 FOM 都不会发生爆破。\n- **测试 3**：（$\\mathbf{A}$ 对称, $r=1$）：$\\mathbf{A}$ 是一个正规矩阵。其数值范围是其特征值 $\\{-1.0, -2.0\\}$ 的凸包，即实轴上的区间 $[-2.0, -1.0]$。降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 必定为负。ROM 将是稳定的。我们预期两个模型都不会发生爆破。\n- **测试 4**：（$\\mathbf{A}$ 更高度非正规, $r=1$）：与测试 1 类似，但具有更大的非对角项 $\\alpha=120.0$。这增加了非正规性，导致 $\\mathbf{S}$ 有一个更大的正特征值。ROM 的不稳定性应该更加显著。我们预期 $\\varepsilon_{\\text{rec}}$ 会很小，ROM 会发生爆破，而 FOM 不会。\n\n现在将实现上述逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if not blew_up and (np.linalg.norm(y)  M or not np.all(np.isfinite(y))):\n                blew_up = True\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1]1:\n         norm_X_sq = np.sum(s**2)\n         if norm_X_sq  0:\n            norm_err_sq = np.sum(s[r:]**2)\n            eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n         else:\n            eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false' for JS-like format\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432128"}]}