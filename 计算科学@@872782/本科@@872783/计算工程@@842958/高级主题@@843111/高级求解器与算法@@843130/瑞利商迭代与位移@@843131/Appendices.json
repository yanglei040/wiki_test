{"hands_on_practices": [{"introduction": "瑞利商迭代 (RQI) 是一个强大的迭代过程。为了完全理解它，我们首先需要掌握其最关键的计算步骤：求解移位线性系统。这个练习将该核心步骤分离出来，为我们深入理解算法的内部机制提供了一个清晰、可控的切入点。[@problem_id:2196922]", "problem": "在数值线性代数的背景下，瑞利商迭代是一种用于寻找矩阵特征值-特征向量对的算法。在每次以 $k$ 为索引的迭代中，一个关键步骤涉及求解一个形如 $(A - \\sigma_k I) y_{k+1} = x_k$ 的线性方程组。在此方程中，$A$ 是所研究的矩阵，$I$ 是单位矩阵，$\\sigma_k$ 是当前的特征值估计（称为位移），$x_k$ 是当前的特征向量近似。\n\n考虑实矩阵 $A = \\begin{pmatrix} 5  0 \\\\ 0  1 \\end{pmatrix}$。设第一次迭代（对应于 $k=0$）的初始状态由特征向量近似 $x_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 和位移 $\\sigma_0 = 4$ 定义。\n\n执行这第一次迭代的“求解”步骤，以求得向量 $y_1$。请按顺序写出向量 $y_1$ 的两个分量作为答案。", "solution": "给定瑞利商迭代的“求解”步骤：\n$$(A - \\sigma_{0} I) y_{1} = x_{0}.$$\n根据 $A = \\begin{pmatrix} 5  0 \\\\ 0  1 \\end{pmatrix}$，$\\sigma_{0} = 4$ 和 $x_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，计算\n$$A - \\sigma_{0} I = \\begin{pmatrix} 5  0 \\\\ 0  1 \\end{pmatrix} - 4 \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} = \\begin{pmatrix} 1  0 \\\\ 0  -3 \\end{pmatrix}.$$\n由于 $\\det(A - \\sigma_{0} I) = (1)(-3) \\neq 0$，该矩阵是可逆的，因此\n$$y_{1} = (A - \\sigma_{0} I)^{-1} x_{0} = \\begin{pmatrix} 1  0 \\\\ 0  -\\frac{1}{3} \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ -\\frac{1}{3} \\end{pmatrix}.$$\n因此，$y_{1}$ 的两个分量按顺序为 $1$ 和 $-\\frac{1}{3}$。", "answer": "$$\\boxed{\\begin{pmatrix} 1 \\\\ -\\frac{1}{3} \\end{pmatrix}}$$", "id": "2196922"}, {"introduction": "在掌握了单步计算之后，我们现在来研究完整迭代序列的动态行为。虽然瑞利商迭代通常具有强大的收敛性，但它并非总是万无一失的。本练习通过一个精心挑选的矩阵和初始向量，展示了迭代陷入一个循环而不是收敛到单个特征向量的特殊情况，这突显了初始猜测和问题结构的重要性。[@problem_id:2431711]", "problem": "考虑一个实矩阵的瑞利商迭代 (RQI)。给定一个单位向量 $x_{k} \\in \\mathbb{R}^{n}$，定义瑞利商 $\\mu_{k}$ 为\n$$\n\\mu_{k} \\equiv \\frac{x_{k}^{\\mathsf{T}} A x_{k}}{x_{k}^{\\mathsf{T}} x_{k}},\n$$\n并通过求解线性系统\n$$\n\\left(A - \\mu_{k} I\\right) y_{k} = x_{k},\n$$\n得到下一个迭代向量 $x_{k+1}$，然后归一化得到 $x_{k+1} \\equiv \\dfrac{y_{k}}{\\|y_{k}\\|_{2}}$。\n\n设\n$$\nA = \\begin{pmatrix} 2  0 \\\\ 0  -2 \\end{pmatrix}, \\quad x_{0} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n假设进行精确计算，并且 $\\left(A - \\mu_{k} I\\right)$ 在每一步都是可逆的。确定最小的正整数 $p$，使得由 RQI 生成的序列 $\\{x_{k}\\}_{k \\ge 0}$ 对所有 $k \\ge 0$ 都满足 $x_{k+p} = x_{k}$。请以单个整数形式提供您的答案。无需四舍五入。", "solution": "该问题要求我们确定对于给定的矩阵 $A$ 和初始向量 $x_{0}$，由瑞利商迭代 (RQI) 生成的序列 $\\{x_{k}\\}_{k \\ge 0}$ 的最小正整数周期 $p$。该问题是良定的，需要直接计算。\n\nRQI 算法由以下步骤定义，从一个单位向量 $x_{k}$ 开始：\n1. 计算瑞利商：$\\mu_{k} = x_{k}^{\\mathsf{T}} A x_{k}$。由于 $x_k$ 是一个单位向量，因此 $x_{k}^{\\mathsf{T}} x_{k} = 1$。\n2. 求解关于 $y_{k}$ 的线性系统：$(A - \\mu_{k} I) y_{k} = x_{k}$。\n3. 归一化以找到序列中的下一个向量：$x_{k+1} = \\frac{y_{k}}{\\|y_{k}\\|_{2}}$。\n\n给定的矩阵和初始向量为：\n$$\nA = \\begin{pmatrix} 2  0 \\\\ 0  -2 \\end{pmatrix}, \\quad x_{0} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n\n我们通过计算序列的前几项来进行。\n\n**$k=0$ 时的步骤：**\n\n首先，我们计算瑞利商 $\\mu_0$：\n$$\n\\mu_{0} = x_{0}^{\\mathsf{T}} A x_{0} = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1  1 \\end{pmatrix} \\right) \\begin{pmatrix} 2  0 \\\\ 0  -2 \\end{pmatrix} \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 1  1 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ -2 \\end{pmatrix} = \\frac{1}{2}(2 - 2) = 0.\n$$\n接下来，我们求解系统 $(A - \\mu_{0} I) y_{0} = x_{0}$。当 $\\mu_0=0$ 时，该式简化为 $A y_{0} = x_{0}$。矩阵 $A$ 是对角矩阵，其逆矩阵很容易计算：\n$$\nA^{-1} = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ 0  -\\frac{1}{2} \\end{pmatrix}.\n$$\n问题陈述假设 $(A - \\mu_{k} I)$ 是可逆的，这在这里是成立的，因为 $\\det(A - 0 \\cdot I) = \\det(A) = -4 \\neq 0$。\n我们求解 $y_0$：\n$$\ny_{0} = A^{-1} x_{0} = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ 0  -\\frac{1}{2} \\end{pmatrix} \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\frac{1}{2} \\\\ -\\frac{1}{2} \\end{pmatrix} = \\frac{1}{2\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n最后，我们归一化 $y_0$ 来得到 $x_1$：\n$$\n\\|y_{0}\\|_{2} = \\sqrt{\\left(\\frac{1}{2\\sqrt{2}}\\right)^2 + \\left(-\\frac{1}{2\\sqrt{2}}\\right)^2} = \\sqrt{\\frac{1}{8} + \\frac{1}{8}} = \\sqrt{\\frac{2}{8}} = \\sqrt{\\frac{1}{4}} = \\frac{1}{2}.\n$$\n$$\nx_{1} = \\frac{y_{0}}{\\|y_{0}\\|_{2}} = \\frac{\\frac{1}{2\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}}{\\frac{1}{2}} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n\n**$k=1$ 时的步骤：**\n\n现在我们用 $x_1$ 重复这个过程。首先，我们计算 $\\mu_1$：\n$$\n\\mu_{1} = x_{1}^{\\mathsf{T}} A x_{1} = \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1  -1 \\end{pmatrix} \\right) \\begin{pmatrix} 2  0 \\\\ 0  -2 \\end{pmatrix} \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right) = \\frac{1}{2} \\begin{pmatrix} 1  -1 \\end{pmatrix} \\begin{pmatrix} 2 \\\\ 2 \\end{pmatrix} = \\frac{1}{2}(2 - 2) = 0.\n$$\n同样地，$\\mu_1 = 0$，所以我们求解 $A y_{1} = x_{1}$：\n$$\ny_{1} = A^{-1} x_{1} = \\begin{pmatrix} \\frac{1}{2}  0 \\\\ 0  -\\frac{1}{2} \\end{pmatrix} \\left( \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix} \\right) = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} \\frac{1}{2} \\\\ \\frac{1}{2} \\end{pmatrix} = \\frac{1}{2\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n我们归一化 $y_1$ 来得到 $x_2$：\n$$\n\\|y_{1}\\|_{2} = \\sqrt{\\left(\\frac{1}{2\\sqrt{2}}\\right)^2 + \\left(\\frac{1}{2\\sqrt{2}}\\right)^2} = \\sqrt{\\frac{1}{8} + \\frac{1}{8}} = \\sqrt{\\frac{1}{4}} = \\frac{1}{2}.\n$$\n$$\nx_{2} = \\frac{y_{1}}{\\|y_{1}\\|_{2}} = \\frac{\\frac{1}{2\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}}{\\frac{1}{2}} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}.\n$$\n\n**确定周期：**\n\n通过将 $x_2$ 与 $x_0$ 比较，我们观察到它们是相同的：\n$$\nx_{2} = x_{0}.\n$$\n由于序列中的每一项 $x_{k+1}$ 仅由其前一项 $x_{k}$ 确定，因此 $x_2 = x_0$ 的事实意味着该序列是周期的。该向量序列将是 $x_0, x_1, x_0, x_1, \\dots$。\n更正式地说，如果 $x_{k+2} = x_k$ 对 $k=0$ 成立，那么 $x_3$ 将以与 $x_1$ 从 $x_0$ 生成相同的方式从 $x_2$ 生成。由于 $x_2=x_0$，必然有 $x_3=x_1$。通过归纳法，对所有 $k \\ge 0$ 都有 $x_{k+2} = x_k$。\n问题要求的是最小的正整数 $p$，使得对所有 $k \\ge 0$ 都有 $x_{k+p} = x_{k}$。我们已经发现 $p=2$ 是可行的。\n我们必须检查 $p=1$ 是否是一个有效的周期。这将要求对所有 $k$ 都有 $x_{k+1} = x_k$。对于 $k=0$，这意味着 $x_1 = x_0$。然而，我们计算得出：\n$$\nx_{0} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} \\quad \\text{和} \\quad x_{1} = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 \\\\ -1 \\end{pmatrix}.\n$$\n显然，$x_{1} \\neq x_{0}$。因此，周期不可能是 $1$。\n使该关系成立的最小正整数 $p$ 是 $2$。\n$(A - \\mu_k I)$ 可逆的条件总是被满足，因为我们已经证明了对所有 $k \\ge 0$ 都有 $\\mu_k = 0$，并且 $A$ 是可逆的。\n因此，最小周期是 $p=2$。", "answer": "$$\\boxed{2}$$", "id": "2431711"}, {"introduction": "现在我们将理论与实践联系起来。这个综合性练习要求你通过编程实现完整的瑞利商迭代算法。通过将其应用于复埃尔米特矩阵并凭经验测量每一步的误差减小情况，你将亲眼见证使 RQI 成为数值线性代数中首选算法之一的惊人三次收敛速度。[@problem_id:2431729]", "problem": "实现一个程序，对于每个给定的复厄米特矩阵和初始向量，执行瑞利商迭代来近似一个特征对，并凭经验估计局部收敛阶。设 $A \\in \\mathbb{C}^{n \\times n}$ 是一个厄米特矩阵，一个非零向量 $v \\in \\mathbb{C}^n$ 的瑞利商定义为\n$$\n\\mu(v) = \\frac{v^* A v}{v^* v}.\n$$\n给定一个初始非零向量 $v_0 \\in \\mathbb{C}^n$，将瑞利商迭代定义为序列 $\\{(v_k,\\mu_k)\\}_{k \\ge 0}$，其中每一步 $v_k$ 都被归一化为单位2范数，$\\mu_k = \\mu(v_k)$，并且更新通过求解移位的线性系统给出\n$$\n(A - \\mu_k I) w_k = v_k,\n$$\n然后设置\n$$\nv_{k+1} = \\frac{w_k}{\\|w_k\\|_2}, \\quad \\mu_{k+1} = \\mu(v_{k+1}).\n$$\n当残差范数满足以下条件时终止迭代\n$$\n\\|A v_k - \\mu_k v_k\\|_2 \\le \\tau,\n$$\n或达到最大迭代次数 $m$ 时。在本问题中，取 $\\tau = 10^{-12}$ 和 $m = 50$。对于每个测试用例，在终止后，设 $\\lambda_\\star$ 为 $A$ 的特征值中与最终瑞利商 $\\mu_K$ 最接近（绝对差最小）的那个，并设 $x_\\star$ 为相应的单位范数特征向量。将第 $k$ 次迭代时基于角度的误差定义为\n$$\ne_k = \\sqrt{1 - \\left|\\langle x_\\star, v_k \\rangle\\right|^2},\n$$\n其中 $\\langle \\cdot, \\cdot \\rangle$ 表示 $\\mathbb{C}^n$ 上的标准复内积，因此 $e_k = \\sin(\\theta_k)$，这里 $\\theta_k$ 是 $v_k$ 和 $x_\\star$ 之间主角。使用最后三个连续的、严格为正且有限的有效误差 $e_{k-1}$、$e_k$、$e_{k+1}$，通过以下公式估计局部收敛阶\n$$\np \\approx \\frac{\\ln(e_{k+1}/e_k)}{\\ln(e_k/e_{k-1})}.\n$$\n如果可用的有效误差少于三个，则该测试用例返回数值 $3$。\n\n使用以下测试套件。对于每种情况，厄米特矩阵 $A$ 定义为 $A = \\tfrac{1}{2}(B + B^*)$，其中 $B$ 是给定的。每个初始向量 $v_0$ 在开始迭代前必须被归一化为单位2范数。\n\n- 测试用例 1：\n  - $B_1 = \\begin{bmatrix}\n  4 + 0\\mathrm{i}  1 + 2\\mathrm{i}  0 + 0\\mathrm{i}  -1 + 0.5\\mathrm{i} \\\\\n  1 - 2\\mathrm{i}  3 + 0\\mathrm{i}  -\\mathrm{i}  2 + 0\\mathrm{i} \\\\\n  0 + 0\\mathrm{i}  \\mathrm{i}  5 + 0\\mathrm{i}  -2 + \\mathrm{i} \\\\\n  -1 - 0.5\\mathrm{i}  2 + 0\\mathrm{i}  -2 - \\mathrm{i}  6 + 0\\mathrm{i}\n  \\end{bmatrix}$，\n  - $v_{0,1} = \\begin{bmatrix} 1 + 0.5\\mathrm{i} \\\\ -0.3 + 0.7\\mathrm{i} \\\\ 0.2 - 0.4\\mathrm{i} \\\\ 0.9 + 0\\mathrm{i} \\end{bmatrix}$。\n\n- 测试用例 2：\n  - $B_2 = \\begin{bmatrix}\n  2 + 0\\mathrm{i}  1 - \\mathrm{i}  0 + 0.5\\mathrm{i} \\\\\n  1 + \\mathrm{i}  2.1 + 0\\mathrm{i}  0.8 - 0.2\\mathrm{i} \\\\\n  0 - 0.5\\mathrm{i}  0.8 + 0.2\\mathrm{i}  2.05 + 0\\mathrm{i}\n  \\end{bmatrix}$，\n  - $v_{0,2} = \\begin{bmatrix} 0.6 - 0.1\\mathrm{i} \\\\ -0.2 + 0.5\\mathrm{i} \\\\ 0.7 + 0.3\\mathrm{i} \\end{bmatrix}$。\n\n- 测试用例 3：\n  - $B_3 = \\begin{bmatrix}\n  7 + 0\\mathrm{i}  2 + \\mathrm{i}  0 + 0\\mathrm{i}  0.5 - \\mathrm{i}  -1 + 0.2\\mathrm{i} \\\\\n  2 - \\mathrm{i}  6 + 0\\mathrm{i}  -1 + 2\\mathrm{i}  0 + 0\\mathrm{i}  0.3 + 0.1\\mathrm{i} \\\\\n  0 + 0\\mathrm{i}  -1 - 2\\mathrm{i}  5 + 0\\mathrm{i}  1 + 0.4\\mathrm{i}  0 - 0.7\\mathrm{i} \\\\\n  0.5 + \\mathrm{i}  0 + 0\\mathrm{i}  1 - 0.4\\mathrm{i}  4 + 0\\mathrm{i}  1.2 - 0.6\\mathrm{i} \\\\\n  -1 - 0.2\\mathrm{i}  0.3 - 0.1\\mathrm{i}  0.7\\mathrm{i}  1.2 + 0.6\\mathrm{i}  3.5 + 0\\mathrm{i}\n  \\end{bmatrix}$，\n  - $v_{0,3} = \\begin{bmatrix} 0.9 + 0.1\\mathrm{i} \\\\ -0.3 + 0.8\\mathrm{i} \\\\ 0.2 - 0.5\\mathrm{i} \\\\ 0.1 + 0.4\\mathrm{i} \\\\ -0.7 + 0.2\\mathrm{i} \\end{bmatrix}$。\n\n对于每个测试用例，生成一个浮点数，其值等于根据上述规定的最后一个可用的有效误差三元组计算出的估计局部收敛阶 $p$。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3]$）。不涉及物理单位。在误差定义中通过正弦函数隐式引用的角度是无量纲的，无需用度或弧度表示。", "solution": "在尝试解决方案之前，需对问题进行验证。\n\n第 1 步：提取已知条件\n- **算法**：瑞利商迭代。\n- **矩阵**：$A \\in \\mathbb{C}^{n \\times n}$ 是一个厄米特矩阵。\n- **瑞利商**：对于一个非零向量 $v \\in \\mathbb{C}^n$，$\\mu(v) = \\frac{v^* A v}{v^* v}$。\n- **迭代定义**：给定一个初始非零向量 $v_0 \\in \\mathbb{C}^n$，序列为 $\\{(v_k,\\mu_k)\\}_{k \\ge 0}$。\n- **归一化**：在每一步，$v_k$ 都被归一化，使其2-范数为1。\n- **状态更新**：$\\mu_k = \\mu(v_k)$。更新步骤涉及求解线性系统 $(A - \\mu_k I) w_k = v_k$。下一个迭代向量是 $v_{k+1} = \\frac{w_k}{\\|w_k\\|_2}$，下一个瑞利商是 $\\mu_{k+1} = \\mu(v_{k+1})$。\n- **终止条件**：当残差范数 $\\|A v_k - \\mu_k v_k\\|_2 \\le \\tau$ 或迭代次数达到最大值 $m$ 时，迭代停止。\n- **常数**：容差为 $\\tau = 10^{-12}$，最大迭代次数为 $m = 50$。\n- **收敛性分析**：\n    - 终止后，设 $\\mu_K$ 为最终的瑞利商。找出 $A$ 的特征值中与 $\\mu_K$ 最接近的那个，记为 $\\lambda_\\star$。设 $x_\\star$ 为对应的单位范数特征向量。\n    - 第 $k$ 次迭代的误差定义为 $e_k = \\sqrt{1 - \\left|\\langle x_\\star, v_k \\rangle\\right|^2}$，其中 $\\langle \\cdot, \\cdot \\rangle$ 是标准复内积。\n    - 局部收敛阶 $p$ 使用最后三个连续的、严格为正且有限的误差来估计：$p \\approx \\frac{\\ln(e_{k+1}/e_k)}{\\ln(e_k/e_{k-1})}$。\n    - 如果没有足够的三个有效误差，$p$ 被赋值为 $3$。\n- **输入数据**：\n    - 厄米特矩阵 $A$ 由给定矩阵 $B$ 构造为 $A = \\tfrac{1}{2}(B + B^*)$。\n    - 提供了三个测试用例，每个用例都有一个矩阵 $B$ 和一个初始向量 $v_0$。\n    - 初始向量 $v_0$ 在第一次迭代前必须归一化为单位2-范数。\n- **输出**：一个单行，包含一个用方括号括起来的逗号分隔列表，其中是每个测试用例估计的收敛阶 $p$。\n\n第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题在科学上是合理的。瑞利商迭代是数值线性代数中计算特征对的一个基本且成熟的算法。瑞利商的公式、迭代更新、误差度量以及收敛阶估计在计算工程和数值分析中都是标准方法。\n- **适定性**：该问题是适定的。它提供了一个确定性算法、清晰的终止准则和明确的计算所需输出的程序。对于一个厄米特矩阵和一个不与任何特征向量正交的泛型初始向量，迭代保证会收敛，通常收敛到与初始状态 $(\\mu_0, v_0)$ 最接近的特征对。已知其收敛是三次的，这确保了解决方案的稳定性和意义。\n- **客观性**：该问题使用精确的数学语言客观陈述，没有歧义或主观断言。\n- **缺陷分析**：\n    1.  没有科学上的不合理之处。\n    2.  问题是可形式化的，并且与指定主题直接相关。\n    3.  问题是自洽的，提供了所有必要信息。内积 $\\langle \\cdot, \\cdot \\rangle$ 的定义在某些上下文中可能含糊不清，但由于使用了模的平方 $|\\langle u, w \\rangle|^2$，结果与哪个参数是共轭线性的约定无关。\n    4.  条件在计算上是可行的。如果 $\\mu_k$ 是一个精确的特征值，移位矩阵 $(A - \\mu_k I)$ 可能会变得奇异。这是该算法的一个已知特性，代表着收敛，可以通过鲁棒的线性求解器或终止迭代来处理。\n    5.  问题结构良好，不是病态的。\n    6.  结果可以通过独立实现和执行指定算法进行科学验证。\n\n第 3 步：结论与行动\n该问题有效。将提供一个合理的解决方案。\n\n该问题要求实现瑞利商迭代（RQI）算法，以近似给定复厄米特矩阵的特征对，并凭经验估计其收敛阶。\n\n瑞利商迭代是一种源于反迭代法的强大方法。标准反迭代法寻找与固定位移 $\\sigma$ 最近的特征值对应的特征向量。它通过求解 $(A - \\sigma I)w_k = v_k$ 并进行归一化来计算 $v_{k+1}$。RQI 通过使用自适应位移来增强这一点：在每一步 $k$，位移被更新为当前对特征值的最佳估计，即瑞利商 $\\mu_k = \\mu(v_k) = (v_k)^* A v_k / (v_k)^* v_k$。由于我们强制 $\\|v_k\\|_2=1$，这可以简化为 $\\mu_k = (v_k)^* A v_k$。这种自适应位移策略导致了极快的局部收敛。对于厄米特矩阵，收敛速度通常是三次的，相比于幂法或固定位移反迭代法的线性收敛，这是一个显著的改进。\n\n每个测试用例的步骤如下：\n\n1.  **初始化**：\n    - 给定矩阵 $B$，通过公式 $A = \\frac{1}{2}(B + B^*)$ 构造相应的厄米特矩阵 $A$，其中 $B^*$ 是 $B$ 的共轭转置。这种构造保证了 $A$ 是厄米特矩阵，即 $A = A^*$。\n    - 提供的初始向量 $v_{0, \\text{raw}}$ 被归一化以具有单位2范数：$v_0 = v_{0, \\text{raw}} / \\|v_{0, \\text{raw}}\\|_2$。\n    - 初始化一个迭代向量历史记录 `vs`，用于存储每个 $v_k$。\n\n2.  **迭代过程**：\n    - 迭代从 $k = 0, 1, 2, \\dots$ 进行，最多到 $m-1 = 49$。\n    - 在每一步 $k$，存储当前向量 $v_k$。\n    - 计算瑞利商 $\\mu_k = (v_k)^* A v_k$。\n    - 通过计算残差向量 $r_k = A v_k - \\mu_k v_k$ 的范数来检查终止条件。如果 $\\|r_k\\|_2 \\le \\tau = 10^{-12}$，则迭代终止。\n    - 如果未满足条件，则计算下一个迭代向量。这涉及求解移位线性系统 $(A - \\mu_k I) w_k = v_k$ 以得到向量 $w_k$。矩阵 $A - \\mu_k I$ 保证是厄米特矩阵，但可能是不定的。为此使用通用线性求解器。如果该矩阵在数值上是奇异的，则表明 $\\mu_k$ 是特征值的极佳近似，可以终止迭代。\n    - 通过归一化 $w_k$ 获得后续的迭代向量 $v_{k+1}$：$v_{k+1} = w_k / \\|w_k\\|_2$。\n    - 使用更新后的向量 $v_{k+1}$ 重复此过程。\n\n3.  **迭代后分析与收敛估计**：\n    - 在第 $K$ 次迭代终止时，最终状态由近似特征对 $(\\mu_K, v_K)$ 描述。为了估计收敛阶，我们必须将迭代向量与真实特征对进行比较。\n    - 计算矩阵 $A$ 的完整特征系统。由于 $A$ 是厄米特矩阵，其特征值是实数，其特征向量构成一个标准正交基。\n    - 通过在 $A$ 的所有特征值 $\\lambda_j$ 中最小化绝对差 $|\\lambda_j - \\mu_K|$，来确定与最终计算的瑞利商 $\\mu_K$ 最接近的真实特征值 $\\lambda_\\star$。\n    - 检索相应的单位范数特征向量 $x_\\star$。\n    - 对所有存储的迭代向量 $v_k$，使用公式 $e_k = \\sqrt{1 - |(x_\\star)^* v_k|^2}$ 计算误差序列 $\\{e_k\\}$。此误差表示迭代向量 $v_k$ 与真实特征向量 $x_\\star$ 之间角度的正弦值。\n    - 为了估计收敛阶 $p$，我们在序列中寻找最后三个连续的、严格为正且有限的误差，例如在索引 $j-2, j-1, j$ 处的误差。设这些误差为 $e_{j-2}, e_{j-1}, e_j$。然后将阶数 $p$ 估计为 $p \\approx \\frac{\\ln(e_j/e_{j-1})}{\\ln(e_{j-1}/e_{j-2})}$。\n    - 如果迭代收敛得非常快，以至于生成的合格误差少于三个，则无法计算出确切的估计值。在这种情况下，根据问题规范，我们返回 RQI 在厄米特矩阵上的理论期望值，即 $p=3$。\n\n将此综合程序应用于每个测试用例，以得出估计的局部收敛阶。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements Rayleigh quotient iteration to find an eigenpair of a Hermitian\n    matrix and estimates the local order of convergence.\n    \"\"\"\n\n    test_cases = [\n        (\n            np.array([\n                [4 + 0j, 1 + 2j, 0 + 0j, -1 + 0.5j],\n                [1 - 2j, 3 + 0j, -1j, 2 + 0j],\n                [0 + 0j, 1j, 5 + 0j, -2 + 1j],\n                [-1 - 0.5j, 2 + 0j, -2 - 1j, 6 + 0j]\n            ]),\n            np.array([1 + 0.5j, -0.3 + 0.7j, 0.2 - 0.4j, 0.9 + 0j])\n        ),\n        (\n            np.array([\n                [2 + 0j, 1 - 1j, 0 + 0.5j],\n                [1 + 1j, 2.1 + 0j, 0.8 - 0.2j],\n                [0 - 0.5j, 0.8 + 0.2j, 2.05 + 0j]\n            ]),\n            np.array([0.6 - 0.1j, -0.2 + 0.5j, 0.7 + 0.3j])\n        ),\n        (\n            np.array([\n                [7 + 0j, 2 + 1j, 0 + 0j, 0.5 - 1j, -1 + 0.2j],\n                [2 - 1j, 6 + 0j, -1 + 2j, 0 + 0j, 0.3 + 0.1j],\n                [0 + 0j, -1 - 2j, 5 + 0j, 1 + 0.4j, 0 - 0.7j],\n                [0.5 + 1j, 0 + 0j, 1 - 0.4j, 4 + 0j, 1.2 - 0.6j],\n                [-1 - 0.2j, 0.3 - 0.1j, 0.7j, 1.2 + 0.6j, 3.5 + 0j]\n            ]),\n            np.array([0.9 + 0.1j, -0.3 + 0.8j, 0.2 - 0.5j, 0.1 + 0.4j, -0.7 + 0.2j])\n        )\n    ]\n\n    results = []\n    tau = 1e-12\n    m = 50\n\n    for B, v0_unnormalized in test_cases:\n        # Step 1: Initialization\n        A = 0.5 * (B + B.T.conj())\n        n = A.shape[0]\n        v_current = v0_unnormalized / np.linalg.norm(v0_unnormalized)\n\n        v_history = []\n        \n        # Step 2: Rayleigh Quotient Iteration\n        mu_current = 0.0 # Will be updated in the first loop iteration\n        for k in range(m):\n            v_history.append(v_current)\n            mu_current = np.vdot(v_current, A @ v_current).real\n\n            residual_norm = np.linalg.norm(A @ v_current - mu_current * v_current)\n            if residual_norm <= tau:\n                break\n\n            try:\n                shift_matrix = A - mu_current * np.identity(n)\n                w_next = np.linalg.solve(shift_matrix, v_current)\n            except np.linalg.LinAlgError:\n                # If matrix is singular, mu_current is an exact eigenvalue.\n                # The iteration has converged.\n                break\n            \n            v_next = w_next / np.linalg.norm(w_next)\n            v_current = v_next\n        \n        # After loop termination, mu_final corresponds to the last v_current\n        mu_final = np.vdot(v_current, A @ v_current).real\n\n        # Step 3: Post-processing to find true eigenpair\n        eigvals, eigvecs = np.linalg.eigh(A)\n        idx_closest = np.argmin(np.abs(eigvals - mu_final))\n        lambda_star = eigvals[idx_closest]\n        x_star = eigvecs[:, idx_closest]\n        \n        # Step 4: Calculate error history\n        errors = []\n        for v_k in v_history:\n            # e_k = sin(theta_k) = sqrt(1 - cos^2(theta_k))\n            cos_theta_sq = np.abs(np.vdot(x_star, v_k))**2\n            # Clamp to 1.0 to avoid small negative numbers due to floating point error\n            if cos_theta_sq > 1.0:\n                cos_theta_sq = 1.0\n            error = np.sqrt(1.0 - cos_theta_sq)\n            errors.append(error)\n\n        # Step 5: Estimate convergence order p\n        p = 3.0  # Default value\n        p_val_found = False\n        # Search backwards for the last three consecutive, positive, finite errors\n        for i in range(len(errors) - 1, 1, -1):\n            e_k_plus_1 = errors[i]\n            e_k = errors[i-1]\n            e_k_minus_1 = errors[i-2]\n\n            if (e_k_plus_1 > 0 and np.isfinite(e_k_plus_1) and\n                e_k > 0 and np.isfinite(e_k) and\n                e_k_minus_1 > 0 and np.isfinite(e_k_minus_1)):\n                \n                # Check for non-decreasing error to avoid log(=1) in denominator\n                if e_k >= e_k_minus_1:\n                    continue\n\n                log_ratio_num = np.log(e_k_plus_1 / e_k)\n                log_ratio_den = np.log(e_k / e_k_minus_1)\n\n                if np.abs(log_ratio_den) > 1e-15:\n                    p = log_ratio_num / log_ratio_den\n                    p_val_found = True\n                    break\n        \n        results.append(p)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431729"}]}