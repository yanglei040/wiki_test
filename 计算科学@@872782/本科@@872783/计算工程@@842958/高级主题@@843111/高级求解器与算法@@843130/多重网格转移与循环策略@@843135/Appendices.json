{"hands_on_practices": [{"introduction": "理解复杂算法的最佳途径之一就是从一个巧妙的思想实验开始。本练习将多重网格 V-cycle 简化为其最核心的形式，假设我们拥有一个“完美”的平滑器，即系统矩阵的精确逆。通过分析这个理想化的场景 [@problem_id:2416049]，您将深刻洞察为何平滑是多重网格方法的“引擎”，并理解它与粗网格校正之间的协同作用。", "problem": "考虑一个由对称正定离散化产生的线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$，$u \\in \\mathbb{R}^{n}$，$b \\in \\mathbb{R}^{n}$。构建一个多重网格 $V$ 循环，其在每一层上有一个预平滑步骤和一个后平滑步骤，相邻层之间有任意的限制算子 $R$ 和延拓算子 $P$，并且粗网格算子由伽辽金积 $A_{H} = R A P$ 定义。最粗网格问题被精确求解。任意层上的平滑更新由下式给出\n$$\nu \\leftarrow u + S \\left(b - A u\\right),\n$$\n其中 $S$ 是该层上的一个固定线性算子。定义精确解 $u^{\\star}$ 满足 $A u^{\\star} = b$，误差为 $e = u - u^{\\star}$。$V$ 循环的渐近收敛因子被定义为：对任意初始误差应用一次完整的 $V$ 循环后，其线性误差传播算子 $E$ 的谱半径 $\\rho(E)$。\n\n现在假设在每一层上，平滑子都是精确逆，即在该层上有 $S = A^{-1}$。确定渐近收敛因子 $\\rho(E)$。以单一实数的形式提供您的答案。无需四舍五入，也不涉及任何单位。", "solution": "### 解答\n目标是确定多重网格 V 循环误差传播算子 $E$ 的渐近收敛因子 $\\rho(E)$，其特定条件为：在任意层上，平滑子都是该层系统矩阵的精确逆。\n\n让我们分析单个 V 循环对任意初始误差 $e_{\\text{in}} = u_{\\text{in}} - u^{\\star}$ 的影响，其中 $u_{\\text{in}}$ 是初始迭代值，$u^{\\star}$ 是精确解。V 循环包括预平滑、粗网格校正和后平滑。\n\n**1. 预平滑步骤**\n问题说明有一个预平滑步骤（$\\nu_1 = 1$）。迭代值 $u$ 的更新规则为：\n$$\nu_{\\text{new}} = u_{\\text{old}} + S(b - A u_{\\text{old}})\n$$\n让我们分析误差的传播。新误差 $e_{\\text{new}} = u_{\\text{new}} - u^{\\star}$ 与旧误差 $e_{\\text{old}} = u_{\\text{old}} - u^{\\star}$ 的关系如下：\n$$\ne_{\\text{new}} = \\left( u_{\\text{old}} + S(b - A u_{\\text{old}}) \\right) - u^{\\star}\n$$\n代入 $u_{\\text{old}} = e_{\\text{old}} + u^{\\star}$ 和 $b = A u^{\\star}$：\n$$\ne_{\\text{new}} = (e_{\\text{old}} + u^{\\star}) + S(A u^{\\star} - A (e_{\\text{old}} + u^{\\star})) - u^{\\star}\n$$\n$$\ne_{\\text{new}} = e_{\\text{old}} + S(A u^{\\star} - A e_{\\text{old}} - A u^{\\star}) = e_{\\text{old}} - S A e_{\\text{old}}\n$$\n$$\ne_{\\text{new}} = (I - S A) e_{\\text{old}}\n$$\n单个平滑步骤的误差传播算子是 $K = I - SA$。\n\n问题指定在每一层上，平滑子都是该层系统矩阵的精确逆。对于我们正在考虑的细网格问题，这意味着 $S = A^{-1}$。将此代入 $K$ 的表达式中：\n$$\nK = I - A^{-1} A = I - I = 0\n$$\n预平滑步骤的误差传播算子是零算子。设预平滑后的误差为 $e_{1}$。对于任何初始误差 $e_{\\text{in}}$，我们有：\n$$\ne_{1} = K e_{\\text{in}} = 0 \\cdot e_{\\text{in}} = 0\n$$\n这意味着单个预平滑步骤，在给定的理想平滑子下，完全消除了误差。此步骤后的迭代值 $u_1$ 就是精确解 $u^{\\star}$。\n\n**2. 粗网格校正步骤**\nV 循环的后续步骤作用于预平滑器产生的状态。\n-   **残差计算**：为当前迭代值 $u_1$ 计算残差：\n    $$\n    r_1 = b - A u_1\n    $$\n    由于预平滑使迭代值变得精确，$u_1 = u^{\\star}$，残差为：\n    $$\n    r_1 = b - A u^{\\star} = 0\n    $$\n-   **限制**：将残差限制到粗网格上：\n    $$\n    r_H = R r_1 = R \\cdot 0 = 0\n    $$\n-   **粗网格问题**：粗网格上的问题是 $A_H e_H = r_H$，它变为：\n    $$\n    A_H e_H = 0\n    $$\n    无论这个问题是精确求解（在最粗层上）还是通过另一个 V 循环递归求解，校正量 $e_H$ 的解都显然是 $e_H = 0$。（这里假设 $A_H$ 是可逆的，这在标准的多重网格构造中成立，其中 $A$ 是对称正定矩阵，$P$ 是满列秩且 $R=P^T$。）\n-   **延拓和校正**：将校正量延拓回细网格并应用于迭代值。延拓后的校正量为：\n    $$\n    e_{\\text{corr}} = P e_H = P \\cdot 0 = 0\n    $$\n    迭代值更新为：$u_2 = u_1 + e_{\\text{corr}} = u^{\\star} + 0 = u^{\\star}$。粗网格校正后的误差 $e_2 = u_2 - u^{\\star}$ 仍然是 $0$。\n\n**3. 后平滑步骤**\n问题说明有一个后平滑步骤（$\\nu_2=1$）。此步骤应用于迭代值 $u_2$：\n$$\nu_{\\text{out}} = u_2 + S(b - A u_2)\n$$\n由于 $u_2 = u^{\\star}$，括号中的项为零：\n$$\nu_{\\text{out}} = u^{\\star} + S(b - A u^{\\star}) = u^{\\star} + S(0) = u^{\\star}\n$$\n最终迭代值 $u_{\\text{out}}$ 是精确解。最终误差为 $e_{\\text{out}} = u_{\\text{out}} - u^{\\star} = 0$。\n\n**关于误差传播算子的结论**\n我们已经证明，对于任意初始误差 $e_{\\text{in}}$，经过一个完整的 V 循环后，误差为 $e_{\\text{out}} = 0$。总的误差传播算子 $E$ 由关系式 $e_{\\text{out}} = E e_{\\text{in}}$ 定义。因此：\n$$\nE e_{\\text{in}} = 0 \\quad \\forall e_{\\text{in}} \\in \\mathbb{R}^{n}\n$$\n这意味着 $E$ 是零算子，$E=0$。\n\n渐近收敛因子是 $E$ 的谱半径，记为 $\\rho(E)$。零算子的特征值全为 $0$。谱半径是特征值绝对值的最大值。\n$$\n\\rho(E) = \\rho(0) = 0\n$$\n因此，渐近收敛因子是 $0$。", "answer": "$$\n\\boxed{0}\n$$", "id": "2416049"}, {"introduction": "理解了平滑器的关键作用后，我们接着探索连接不同层级网格的传递算子。本实践 [@problem_id:2416021] 聚焦于限制算子，通过一个特殊的模板来研究它如何处理残差中的不同频率分量。这个编程练习将帮助您直观地理解一个核心概念：限制算子的设计目标是高效地捕捉平滑器难以消除的“光滑”误差分量，并将其传递到粗网格上。", "problem": "给定一个在周期性域上的一维离散泊松方程模型。设域为单位圆，由 $n$ 个等距点离散化，点间距为 $h = 1/n$，其中 $n$ 为偶数。定义具有周期性边界条件的离散负拉普拉斯算子 $A \\in \\mathbb{R}^{n \\times n}$ 为\n$$(A \\mathbf{u})_i = \\frac{2 u_i - u_{i-1} - u_{i+1}}{h^2}, \\quad i \\in \\{0,1,\\dots,n-1\\},$$\n其中索引以 $n$ 为模进行计算。对于任意离散场 $\\mathbf{u} \\in \\mathbb{R}^n$ 和强迫项 $\\mathbf{f} \\in \\mathbb{R}^n$，定义残差 $\\mathbf{r}(\\mathbf{u}) = \\mathbf{f} - A \\mathbf{u}$。考虑一个限制算子 $R: \\mathbb{R}^n \\to \\mathbb{R}^{n/2}$，该算子使用一个权重和为零的三点模板，具体定义为\n$$(R \\mathbf{r})_I = w_{-1}\\, r_{2I-1} + w_0\\, r_{2I} + w_{+1}\\, r_{2I+1}, \\quad I \\in \\{0,1,\\dots,\\tfrac{n}{2}-1\\},$$\n其中索引是周期性的，权重为 $(w_{-1}, w_0, w_{+1}) = (1,-2,1)$，因此 $w_{-1} + w_0 + w_{+1} = 0$。\n\n您的任务是实现一个程序，对于下面指定的测试套件，为初始猜测 $\\mathbf{u} = \\mathbf{0}$ 构建残差 $\\mathbf{r}(\\mathbf{u})$，然后计算标量值\n$$\\gamma = \\frac{\\lVert R \\mathbf{r}(\\mathbf{0}) \\rVert_2}{\\lVert \\mathbf{r}(\\mathbf{0}) \\rVert_2}.$$\n三角函数定义中使用的角度必须以弧度为单位。不涉及物理单位；量 $\\gamma$ 是无量纲的。\n\n测试套件：\n- 情况 1：$n = 64$，$\\mathbf{f}$ 是所有分量 $f_i = 1$ 的常数向量。\n- 情况 2：$n = 64$，$\\mathbf{f}$ 定义为 $f_i = \\sin(2 \\pi x_i)$，其中 $x_i = i h$ 且 $h = 1/n$。\n- 情况 3：$n = 64$，$\\mathbf{f}$ 定义为 $f_i = (-1)^i$。\n- 情况 4：$n = 8$，$\\mathbf{f}$ 是所有分量 $f_i = 1$ 的常数向量。\n\n对于每种情况，程序必须输出相应的 $\\gamma$ 值，格式为浮点数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[a,b,c,d]”），结果顺序与上述测试用例的顺序一致。答案必须是浮点数。不需要用户输入，程序必须是完全独立且确定性的。", "solution": "### 解题推导\n目标是为四种不同情况计算量 $\\gamma$。$\\gamma$ 的定义是：\n$$ \\gamma = \\frac{\\lVert R \\mathbf{r}(\\mathbf{0}) \\rVert_2}{\\lVert \\mathbf{r}(\\mathbf{0}) \\rVert_2} $$\n初始猜测给定为 $\\mathbf{u} = \\mathbf{0}$。残差 $\\mathbf{r}(\\mathbf{u})$ 定义为 $\\mathbf{f} - A\\mathbf{u}$。代入 $\\mathbf{u} = \\mathbf{0}$，我们得到：\n$$ \\mathbf{r}(\\mathbf{0}) = \\mathbf{f} - A\\mathbf{0} = \\mathbf{f} $$\n因此，残差就是强迫向量 $\\mathbf{f}$。$\\gamma$ 的表达式简化为：\n$$ \\gamma = \\frac{\\lVert R \\mathbf{f} \\rVert_2}{\\lVert \\mathbf{f} \\rVert_2} $$\n每个测试用例的计算分三步进行：\n1.  构造强迫向量 $\\mathbf{f} \\in \\mathbb{R}^n$。\n2.  计算限制后的向量 $R\\mathbf{f} \\in \\mathbb{R}^{n/2}$。\n3.  计算两个向量的 L2 范数及其比率。\n\n限制后的向量（我们表示为 $\\mathbf{v} = R\\mathbf{f}$）的分量由以下公式给出：\n$$ v_I = (R\\mathbf{f})_I = f_{2I-1} - 2f_{2I} + f_{2I+1} $$\n对于 $I \\in \\{0, 1, \\dots, \\frac{n}{2}-1\\}$。$\\mathbf{f}$ 分量的索引必须周期性处理，即索引 $j$ 对应于 $j \\pmod n$。\n\n让我们分析不同类型强迫向量的行为。\n\n**情况 1 和 4：常数强迫向量**\n这里，$f_i = c$ 对所有 $i$ 成立，其中 $c=1$。情况 1 的大小为 $n=64$，情况 4 的大小为 $n=8$。\n限制后的向量 $R\\mathbf{f}$ 的分量是：\n$$ (R\\mathbf{f})_I = f_{2I-1} - 2f_{2I} + f_{2I+1} = c - 2c + c = 0 $$\n限制后的向量 $R\\mathbf{f}$ 是零向量。其范数 $\\lVert R\\mathbf{f} \\rVert_2$ 为 $0$。分母 $\\lVert \\mathbf{f} \\rVert_2 = \\sqrt{\\sum_{i=0}^{n-1} c^2} = \\sqrt{n c^2}$ 不为零。因此，对于任何常数强迫向量，$\\gamma = 0$。这证实了情况 1 和情况 4 的结果将是 $0.0$。\n\n**情况 3：高频强迫向量**\n这里，$n=64$ 且 $f_i = (-1)^i$。这代表了网格上可分辨的最高频率模式 $\\cos(\\pi i)$。\n限制后的向量 $R\\mathbf{f}$ 的分量通过考虑索引的奇偶性来计算：\n$$ f_{2I} = (-1)^{2I} = 1 $$\n$$ f_{2I-1} = (-1)^{2I-1} = -1 $$\n$$ f_{2I+1} = (-1)^{2I+1} = -1 $$\n代入这些值：\n$$ (R\\mathbf{f})_I = (-1) - 2(1) + (-1) = -4 $$\n限制后的向量 $R\\mathbf{f}$ 是一个大小为 $m=n/2=32$ 的常数向量，所有分量都等于 $-4$。\n$\\mathbf{f}$ 的 L2 范数是 $\\lVert \\mathbf{f} \\rVert_2 = \\sqrt{\\sum_{i=0}^{63} ((-1)^i)^2} = \\sqrt{64} = 8$。\n$R\\mathbf{f}$ 的 L2 范数是 $\\lVert R\\mathbf{f} \\rVert_2 = \\sqrt{\\sum_{I=0}^{31} (-4)^2} = \\sqrt{32 \\times 16} = \\sqrt{512} = 16\\sqrt{2}$。\n比率是 $\\gamma = \\frac{16\\sqrt{2}}{8} = 2\\sqrt{2}$。\n\n**情况 2：低频强迫向量**\n这里，$n=64$ 且 $f_i = \\sin(2 \\pi x_i) = \\sin(2 \\pi i / n)$。这是网格上最平滑的非恒定傅里叶模式。\n$\\mathbf{f}$ 的 L2 范数由 $\\lVert \\mathbf{f} \\rVert_2 = \\sqrt{\\sum_{i=0}^{n-1} \\sin^2(2 \\pi i / n)}$ 给出。使用标准离散傅里叶级数恒等式 $\\sum_{k=0}^{N-1} \\sin^2(2 \\pi jk/N) = N/2$（对于整数 $j$ 且 $1 \\le j  N/2$），我们有 $\\lVert \\mathbf{f} \\rVert_2 = \\sqrt{n/2} = \\sqrt{64/2} = \\sqrt{32}$。\n限制后的向量的分量是：\n$$ (R\\mathbf{f})_I = \\sin\\left(\\frac{2\\pi(2I-1)}{n}\\right) - 2\\sin\\left(\\frac{2\\pi(2I)}{n}\\right) + \\sin\\left(\\frac{2\\pi(2I+1)}{n}\\right) $$\n令 $\\theta_I = \\frac{2\\pi(2I)}{n}$ 且 $\\Delta\\theta = \\frac{2\\pi}{n}$。表达式变为 $(\\sin(\\theta_I-\\Delta\\theta) + \\sin(\\theta_I+\\Delta\\theta)) - 2\\sin(\\theta_I)$。使用和差化积恒等式，这等于 $2\\sin(\\theta_I)\\cos(\\Delta\\theta) - 2\\sin(\\theta_I) = 2\\sin(\\theta_I)(\\cos(\\Delta\\theta)-1)$。\n使用半角恒等式 $1-\\cos(x) = 2\\sin^2(x/2)$，这简化为：\n$$ (R\\mathbf{f})_I = -4 \\sin^2\\left(\\frac{\\Delta\\theta}{2}\\right) \\sin(\\theta_I) = -4 \\sin^2\\left(\\frac{\\pi}{n}\\right) \\sin\\left(\\frac{4\\pi I}{n}\\right) $$\n$R\\mathbf{f}$ 的范数是 $\\lVert R\\mathbf{f} \\rVert_2 = \\left|-4 \\sin^2\\left(\\frac{\\pi}{n}\\right)\\right| \\sqrt{\\sum_{I=0}^{n/2 - 1} \\sin^2\\left(\\frac{4\\pi I}{n}\\right)}$。\n该和为 $\\sum_{I=0}^{m-1} \\sin^2\\left(\\frac{2\\pi I}{m}\\right)$，其中 $m=n/2=32$。此和为 $m/2 = (n/2)/2 = n/4 = 16$。\n因此，$\\lVert R\\mathbf{f} \\rVert_2 = 4 \\sin^2(\\pi/n) \\sqrt{n/4} = 4 \\sin^2(\\pi/64) \\sqrt{16} = 16 \\sin^2(\\pi/64)$。\n比率是 $\\gamma = \\frac{16 \\sin^2(\\pi/64)}{\\sqrt{32}} = \\frac{16 \\sin^2(\\pi/64)}{4\\sqrt{2}} = \\frac{4}{\\sqrt{2}} \\sin^2(\\pi/64) = 2\\sqrt{2} \\sin^2(\\pi/64)$。\n\n该实现将以数值方式构造这些向量并计算范数，以找到每种情况下的 $\\gamma$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_gamma(n, f_vector):\n    \"\"\"\n    Calculates the ratio gamma for a given grid size n and forcing vector f.\n\n    The quantity is defined as gamma = ||R*r||_2 / ||r||_2, where r = f for u=0.\n    The restriction operator R is defined by (R*r)_I = r_{2I-1} - 2*r_{2I} + r_{2I+1}.\n\n    Args:\n        n (int): The number of grid points, must be even.\n        f_vector (np.ndarray): The forcing vector of size n.\n\n    Returns:\n        float: The computed value of gamma.\n    \"\"\"\n    \n    # For u=0, the residual r is simply the forcing vector f.\n    r = f_vector\n    \n    # Calculate the denominator: the L2 norm of the residual vector.\n    norm_r = np.linalg.norm(r)\n    \n    # If the norm of the residual is zero, gamma is undefined or 0.\n    # In this context (non-zero f), we can treat it as 0.\n    if norm_r == 0:\n        return 0.0\n\n    # The coarse grid has n/2 points.\n    n_coarse = n // 2\n    restricted_r = np.zeros(n_coarse)\n\n    # Apply the restriction operator R to the residual vector r.\n    # (R*r)_I = r_{2I-1} - 2*r_{2I} + r_{2I+1}, with periodic indexing.\n    for I in range(n_coarse):\n        # Python's % operator correctly handles negative numbers for periodic indexing.\n        # e.g., -1 % 64 = 63.\n        idx_minus_1 = (2 * I - 1) % n\n        idx_0 = (2 * I) % n\n        idx_plus_1 = (2 * I + 1) % n\n\n        restricted_r[I] = r[idx_minus_1] - 2 * r[idx_0] + r[idx_plus_1]\n    \n    # Calculate the numerator: the L2 norm of the restricted residual.\n    norm_restricted_r = np.linalg.norm(restricted_r)\n    \n    # Compute the final ratio.\n    gamma = norm_restricted_r / norm_r\n    \n    return gamma\n\ndef solve():\n    \"\"\"\n    Solves the problem for the four specified test cases and prints the results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases_params = [\n        {'n': 64, 'id': 1},\n        {'n': 64, 'id': 2},\n        {'n': 64, 'id': 3},\n        {'n': 8,  'id': 4},\n    ]\n\n    results = []\n    for params in test_cases_params:\n        n = params['n']\n        case_id = params['id']\n        f = None\n\n        if case_id == 1: # n=64, f_i = 1\n            f = np.ones(n)\n        elif case_id == 2: # n=64, f_i = sin(2*pi*x_i)\n            h = 1.0 / n\n            x = np.arange(n) * h\n            f = np.sin(2 * np.pi * x)\n        elif case_id == 3: # n=64, f_i = (-1)^i\n            f = np.power(-1.0, np.arange(n))\n        elif case_id == 4: # n=8, f_i = 1\n            f = np.ones(n)\n        \n        gamma = calculate_gamma(n, f)\n        results.append(gamma)\n\n    # Final print statement in the exact required format.\n    # The format specifier ensures that the numbers are printed as floats (e.g., 0.0).\n    print(f\"[{','.join(map(str, [float(r) for r in results]))}]\")\n\nsolve()\n```", "id": "2416021"}, {"introduction": "现在，让我们将所有组件——平滑、限制和延拓——整合起来，构建一个完整的多层级求解器。这项综合性实践 [@problem_id:2416031] 要求您实现一个灵活的 V-cycle 和 W-cycle 算法，其中平滑步骤的次数可以根据网格层级的不同而变化。通过实验不同的平滑策略，您将为解决实际问题培养出设计高效且稳健的多重网格循环策略的直觉。", "problem": "要求您设计并实现一种可变光滑多重网格循环，其中光滑步数取决于网格层级。在一维空间中，考虑单位区间上具有齐次 Dirichlet 边界条件的泊松方程给出的边值问题，该问题通过二阶中心有限差分进行离散化。由此得到的线性系统是​​对称正定的，在每个内部网格点上，表现为一个三对角算子的作用。您的实现必须基于以下基本要素：\n- 连续模型为一维泊松方程，带有齐次 Dirichlet 边界条件，写作 $-u''(x)=g(x)$，其中 $x\\in(0,1)$，且 $u(0)=u(1)=0$。\n- 在间距为 $h$ 的均匀网格上使用二阶中心有限差分近似，会得到层级 $l$ 上的线性系统 $A^{(l)} u^{(l)} = f^{(l)}$，其中 $A^{(l)}$ 是一个三对角算子，其对角线上的元素为 $2/h_l^2$，紧邻的次对角线上的元素为 $-1/h_l^2$，并且 $h_l = 1/(n_l+1)$，$n_l$ 是层级 $l$ 上的内部未知数数量。\n- 加权 Jacobi 光滑由迭代 $u^{(l)} \\leftarrow u^{(l)} + \\omega \\left(D^{(l)}\\right)^{-1}\\left(f^{(l)} - A^{(l)} u^{(l)}\\right)$ 定义，其中 $\\omega$ 是选定的松弛参数，$D^{(l)}$ 是 $A^{(l)}$ 的对角部分。\n- 相邻层级之间的限制和延拓分别使用标准的全加权限制和线性插值延拓。如果 $r^{(l)}$ 是一个细网格向量，其中 $n_l = 2 n_{l+1} + 1$，则限制操作为 $(r^{(l+1)})_j = \\frac{1}{4} r^{(l)}_{2j} + \\frac{1}{2} r^{(l)}_{2j+1} + \\frac{1}{4} r^{(l)}_{2j+2}$，其中 $j=0,\\dots,n_{l+1}-1$；延拓操作则是在奇数索引处进行注入，在偶数索引处进行线性插值。\n- V-循环在每次访问中执行一次递归的粗网格校正，而 W-循环则执行两次递归的粗网格校正。用循环指数 $\\gamma$ 表示，V-循环为 $\\gamma=1$，W-循环为 $\\gamma=2$。\n\n您的任务是实现一个多重网格循环，其中光滑步数 $ \\nu(l)$ 取决于网格层级 $ l$。层级编号必须为：最细网格为 $l=0$，最粗网格为 $l=L-1$，其中 $L$ 是层级总数。在每个层级上，使用相同数量的前光滑和后光滑步骤，其数量等于 $\\nu(l)$。\n\n网格层次结构从一个最细网格开始构建，该网格包含 $N$ 个内部点，其中 $N = 2^L - 1$，$L \\ge 2$ 为某个整数。最粗层级的问题必须通过直接求解对应的三对角线性系统来精确求解。设右端项为常数，即 $g(x)\\equiv 1$，这对应于最细层级上所有内部点 $i$ 的 $f^{(0)}_i = 1$，并使用齐次 Dirichlet 边界条件。将最细层级的近似解 $u^{(0)}$ 初始化为零向量。\n\n通过以下族之一来定义光滑方案 $\\nu(l)$，每种情况下都确保 $\\nu(l)$ 是一个整数且至少为 $1$：\n- 常数型：$\\nu(l) = \\mathrm{round}(c)$。\n- 线性型：$\\nu(l) = \\max\\{1,\\ \\mathrm{round}(a + b\\,l)\\}$。\n- 几何型：$\\nu(l) = \\max\\{1,\\ \\mathrm{round}(a\\,b^{\\,l})\\}$。\n\n使用加权 Jacobi 光滑，松弛参数为 $\\omega = 2/3$。\n\n对于给定的 $N$、$\\gamma$、$\\nu(l)$ 的族及其参数，从最细层级上的零初始猜测 $u^{(0)}=0$ 开始，运行 $K$ 个循环。令 $\\lVert r_k \\rVert_2$ 表示完成 $k$ 个循环后最细层级残差的欧几里得范数，令 $\\lVert r_0 \\rVert_2$ 为初始范数（当 $u^{(0)}=0$ 时）。报告观测到的每循环平均缩减因子\n$$\n\\rho_\\mathrm{obs} = \\left(\\frac{\\lVert r_K \\rVert_2}{\\lVert r_0 \\rVert_2}\\right)^{1/K}.\n$$\n您的程序必须为下面的每个测试用例计算 $\\rho_\\mathrm{obs}$，并将结果打印在一行中，形式为用方括号括起来的逗号分隔列表，每个数字四舍五入到小数点后六位。不需要物理单位。\n\n测试套件：\n- 用例 1（正常路径）：$N=63$，$\\gamma=1$ (V-循环)，常数型 $\\nu(l)$，$c=2$，以及 $K=8$。\n- 用例 2（层级相关的粗网格加重型）：$N=63$，$\\gamma=1$ (V-循环)，线性型 $\\nu(l)$，$a=1$，$b=1$，以及 $K=8$。\n- 用例 3（W-循环与更强的粗网格光滑）：$N=63$，$\\gamma=2$ (W-循环)，线性型 $\\nu(l)$，$a=1$，$b=2$，以及 $K=6$。\n- 用例 4（光滑步数几何增长及更大的最细网格）：$N=127$，$\\gamma=1$ (V-循环)，几何型 $\\nu(l)$，$a=1$，$b=1.5$，以及 $K=6$。\n\n为确保科学真实性的算法要求：\n- 在每个层级上使用由中心有限差分模板 $(-1,2,-1)/h_l^2$ 所确定的精确三对角算子 $A^{(l)}$ 来形成残差，并在最粗层级上进行求解。\n- 在相邻层级之间使用如上所述的全加权限制和线性插值延拓。\n- 对前光滑和后光滑均使用加权 Jacobi 方法，$\\omega=2/3$，每个层级上的光滑次数 $\\nu(l)$ 相同。\n- 根据定义的 $\\gamma$ 实现 V-循环和 W-循环。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序排列结果，例如 $[\\rho_1,\\rho_2,\\rho_3,\\rho_4]$，其中每个 $\\rho_i$ 都四舍五入到小数点后六位。程序不得读取任何输入，且必须只产生这一行输出。", "solution": "该问题要求为一维泊松方程 $-u''(x) = g(x)$（其中 $x \\in (0, 1)$）设计并实现一种多重网格方法，该方程具有齐次 Dirichlet 边界条件 $u(0) = u(1) = 0$。其关键特征是一种可变光滑策略，即光滑迭代的次数取决于网格层级。\n\n首先，我们对问题进行离散化。我们建立一个网格层次结构，用层级 $l$ 进行索引，其中 $l=0$ 对应最细网格，$l=L-1$ 对应最粗网格。最细网格有 $N$ 个内部点，其中 $N=2^L-1$，$L \\ge 2$ 为某个整数。采用标准的粗化策略，层级 $l$ 上的内部点数 $n_l$ 由 $n_l = 2^{L-l}-1$ 给出。因此，下一个更粗层级上的点数为 $n_{l+1} = (n_l-1)/2$。层级 $l$ 上的网格间距为 $h_l = 1/(n_l+1)$。\n\n对二阶导数使用二阶中心有限差分近似，我们得到了关于内部网格点上未知值 $u^{(l)}$ 的线性方程组：$A^{(l)} u^{(l)} = f^{(l)}$。矩阵 $A^{(l)}$ 是一个 $n_l \\times n_l$ 的对称正定三对角矩阵，其元素为：\n$$\nA^{(l)}_{i,j} = \\frac{1}{h_l^2}\n\\begin{cases}\n2,   i=j \\\\\n-1,  |i-j|=1 \\\\\n0,   \\text{otherwise}\n\\end{cases}\n$$\n最细层级上的右端向量 $f^{(l)}$ 由 $g(x) \\equiv 1$ 导出，因此对于所有 $i$，有 $f^{(0)}_i = 1$。在更粗的层级上，$f^{(l)}$ 将是来自下一个更细层级的限制后的残差。\n\n多重网格方法的核心是一个递归循环。在层级 $l$ 上近似求解 $A^{(l)} u^{(l)} = f^{(l)}$ 的单个循环包含三个主要步骤：\n\n1.  **前光滑**：通过应用光滑算子来改进当前近似解 $u^{(l)}$。我们使用 $\\nu(l)$ 次加权 Jacobi 方法的迭代：\n    $$\n    u^{(l)} \\leftarrow u^{(l)} + \\omega (D^{(l)})^{-1} (f^{(l)} - A^{(l)} u^{(l)})\n    $$\n    这里，$D^{(l)}$ 是 $A^{(l)}$ 的对角部分，所以 $(D^{(l)})^{-1}_{ii} = h_l^2/2$。给定的松弛参数为 $\\omega=2/3$。光滑步数 $\\nu(l)$ 是层级 $l$ 的函数，由所提供的常数型、线性型或几何型方案之一来定义。\n\n2.  **粗网格校正**：此步骤在更粗的网格上求解误差，此时问题规模更小，计算成本更低。\n    a. 计算细网格上的残差：$r^{(l)} = f^{(l)} - A^{(l)} u^{(l)}$。\n    b. 将残差限制到下一个更粗的网格 $l+1$ 上：$r^{(l+1)} = R^{(l \\to l+1)} r^{(l)}$。限制算子 $R^{(l \\to l+1)}$ 是全加权算子，在一维情况下其模板为 $[1/4, 1/2, 1/4]$。它作用于细网格向量 $v^{(l)}$ 的方式是：\n    $$\n    (v^{(l+1)})_j = \\frac{1}{4} v^{(l)}_{2j} + \\frac{1}{2} v^{(l)}_{2j+1} + \\frac{1}{4} v^{(l)}_{2j+2}, \\quad j = 0, \\dots, n_{l+1}-1.\n    $$\n    c. 求解粗网格残差方程 $A^{(l+1)} e^{(l+1)} = r^{(l+1)}$。如果层级 $l+1$ 是最粗网格（$l+1 = L-1$），则直接求解该方程。在我们的情况下，最粗网格只有一个未知数 $n_{L-1}=1$，所以这是一个平凡的标量方程。如果层级 $l+1$ 不是最粗的，则通过从初始猜测 $e^{(l+1)}=0$ 开始应用 $\\gamma$ 次多重网格循环来递归求解该方程。对于 V-循环，$\\gamma=1$；对于 W-循环，$\\gamma=2$。\n    d. 将粗网格误差校正延拓回细网格：$e^{(l)} = P^{(l+1 \\to l)} e^{(l+1)}$。延拓算子 $P^{(l+1 \\to l)}$ 是线性插值，它是全加权限制算子转置的 2 倍：$P^{(l+1 \\to l)} = 2 (R^{(l \\to l+1)})^T$。对于一个粗网格向量 $v^{(l+1)}$，其作用定义为在细网格的奇数索引处进行注入，在偶数索引处进行平均，同时遵守零边界条件：\n    $$\n    (v^{(l)})_{2j+1} = v^{(l+1)}_j \\\\\n    (v^{(l)})_{2j} = \\frac{1}{2} (v^{(l+1)}_{j-1} + v^{(l+1)}_j)\n    $$\n    其中边界值取为零（例如，$v^{(l+1)}_{-1} = 0$）。\n    e. 更新细网格解：$u^{(l)} \\leftarrow u^{(l)} + e^{(l)}$。\n\n3.  **后光滑**：为了抑制延拓步骤引入的高频误差，我们再次对更新后的近似解 $u^{(l)}$ 应用 $\\nu(l)$ 次加权 Jacobi 光滑迭代。\n\n整个过程从最细层级（$l=0$）以初始猜测 $u^{(0)}=0$ 开始。在执行指定数量的循环 $K$ 次后，评估其收敛性。性能通过残差欧几里得范数的每循环平均缩减因子 $\\rho_{\\text{obs}}$ 来衡量。这是根据初始残差范数 $\\lVert r_0 \\rVert_2 = \\lVert f^{(0)} - A^{(0)} u^{(0)}_0 \\rVert_2$ 和 $K$ 次循环后的最终残差范数 $\\lVert r_K \\rVert_2 = \\lVert f^{(0)} - A^{(0)} u^{(0)}_K \\rVert_2$ 使用以下公式计算的：\n$$\n\\rho_{\\mathrm{obs}} = \\left(\\frac{\\lVert r_K \\rVert_2}{\\lVert r_0 \\rVert_2}\\right)^{1/K}\n$$\n实现部分将构建必要的算子，并为每个指定的测试用例执行递归循环，相应地计算 $\\rho_{\\mathrm{obs}}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\n\n# ===== Multigrid Component Implementations =====\n\ndef create_operator_A(n):\n    \"\"\"Creates the 1D Poisson matrix for a grid with n interior points.\"\"\"\n    h = 1.0 / (n + 1)\n    main_diag = np.full(n, 2.0 / h**2)\n    off_diag = np.full(n - 1, -1.0 / h**2)\n    return diags([off_diag, main_diag, off_diag], [-1, 0, 1], format='csr')\n\ndef apply_smoother(u, f, A, nu, omega):\n    \"\"\"Applies nu steps of the weighted Jacobi smoother.\"\"\"\n    u_new = np.copy(u)\n    # The diagonal of A is constant, so D_inv is a scalar multiplication.\n    # D_ii = 2 / h^2, so D_inv_ii = h^2 / 2\n    n = len(u)\n    h_sq = (1.0 / (n + 1))**2\n    D_inv_val = h_sq / 2.0\n    \n    for _ in range(nu):\n        residual = f - A @ u_new\n        u_new += omega * D_inv_val * residual\n    return u_new\n\ndef apply_restriction(r_fine):\n    \"\"\"Applies full-weighting restriction.\"\"\"\n    # Stencil is [1/4, 1/2, 1/4]\n    # Vectorized implementation for speed\n    n_fine = len(r_fine)\n    if n_fine == 1:\n        return np.array([])\n    r_coarse = 0.25 * r_fine[:-2:2] + 0.5 * r_fine[1:-1:2] + 0.25 * r_fine[2::2]\n    return r_coarse\n\ndef apply_prolongation(e_coarse, n_fine):\n    \"\"\"Applies linear interpolation prolongation.\"\"\"\n    n_coarse = len(e_coarse)\n    e_fine = np.zeros(n_fine)\n    \n    # Injection at odd indices\n    e_fine[1::2] = e_coarse\n    \n    # Interpolation at even indices (including boundaries)\n    padded_coarse = np.concatenate(([0], e_coarse, [0]))\n    e_fine[::2] = 0.5 * (padded_coarse[:-1] + padded_coarse[1:])\n    \n    return e_fine\n\ndef calculate_nu(level, family, params):\n    \"\"\"Calculates the number of smoothing steps for a given level.\"\"\"\n    if family == 'constant':\n        val = params['c']\n    elif family == 'linear':\n        val = params['a'] + params['b'] * level\n    elif family == 'geometric':\n        val = params['a'] * (params['b'] ** level)\n    else:\n        raise ValueError(f\"Unknown smoothing schedule family: {family}\")\n    \n    return max(1, int(np.round(val)))\n\ndef mg_cycle(level, u, f, grid_params):\n    \"\"\"Performs one recursive multigrid cycle.\"\"\"\n    ns, As, nus, gamma, omega = grid_params\n    \n    # Base case: on the coarsest level, solve exactly\n    if level == len(ns) - 1:\n        # For n=1, this is a 1x1 system A u = f -> u = f / A[0,0]\n        return f / As[level][0, 0]\n\n    # 1. Pre-smoothing\n    u = apply_smoother(u, f, As[level], nus[level], omega)\n\n    # 2. Coarse-grid correction\n    residual_fine = f - As[level] @ u\n    residual_coarse = apply_restriction(residual_fine)\n    \n    error_coarse = np.zeros_like(residual_coarse)\n    \n    # Recursive calls to solve the coarse-grid error equation\n    for _ in range(gamma):\n        error_coarse = mg_cycle(level + 1, error_coarse, residual_coarse, grid_params)\n        \n    error_fine = apply_prolongation(error_coarse, ns[level])\n    u += error_fine\n\n    # 3. Post-smoothing\n    u = apply_smoother(u, f, As[level], nus[level], omega)\n\n    return u\n\ndef solve():\n    \"\"\"Main function to run test cases and print results.\"\"\"\n    test_cases = [\n        {'N': 63, 'gamma': 1, 'nu_family': 'constant', 'nu_params': {'c': 2}, 'K': 8},\n        {'N': 63, 'gamma': 1, 'nu_family': 'linear', 'nu_params': {'a': 1, 'b': 1}, 'K': 8},\n        {'N': 63, 'gamma': 2, 'nu_family': 'linear', 'nu_params': {'a': 1, 'b': 2}, 'K': 6},\n        {'N': 127, 'gamma': 1, 'nu_family': 'geometric', 'nu_params': {'a': 1, 'b': 1.5}, 'K': 6},\n    ]\n\n    results = []\n    omega = 2.0 / 3.0\n\n    for case in test_cases:\n        N = case['N']\n        gamma = case['gamma']\n        nu_family = case['nu_family']\n        nu_params = case['nu_params']\n        K = case['K']\n\n        # 1. Setup grid hierarchy\n        L = int(np.log2(N + 1))\n        ns = [2**(L - l) - 1 for l in range(L)]\n        As = [create_operator_A(n) for n in ns]\n        nus = [calculate_nu(l, nu_family, nu_params) for l in range(L)]\n        \n        grid_params = (ns, As, nus, gamma, omega)\n\n        # 2. Initial state\n        u = np.zeros(N)\n        f = np.ones(N)\n\n        # 3. Calculate initial residual norm\n        r0_norm = np.linalg.norm(f) # Since u is zero, initial residual is f\n\n        # 4. Run K multigrid cycles\n        u_k = u\n        for _ in range(K):\n            u_k = mg_cycle(0, u_k, f, grid_params)\n\n        # 5. Calculate final residual norm and convergence factor\n        rK_norm = np.linalg.norm(f - As[0] @ u_k)\n        \n        if r0_norm == 0:\n             rho_obs = 0.0 if rK_norm == 0 else float('inf')\n        else:\n             rho_obs = (rK_norm / r0_norm)**(1.0 / K)\n        \n        results.append(f\"{rho_obs:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416031"}]}