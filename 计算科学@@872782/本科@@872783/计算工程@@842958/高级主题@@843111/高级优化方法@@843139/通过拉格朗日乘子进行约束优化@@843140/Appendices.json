{"hands_on_practices": [{"introduction": "现实世界中的工程优化问题往往不止有等式约束，还包含不等式限制，例如“产量不低于某个值”或“排放量不超过某个上限”。这个练习 [@problem_id:2380580] 是一个很好的起点，它将我们带入带不等式约束的优化领域。我们将应用作为拉格朗日乘子法推广的卡罗需-库恩-塔克（KKT）条件，来为一家工厂的运营进行建模，并找到最具成本效益的生产策略。", "problem": "一家工厂运营两条平行的生产线，其决策变量为 $x$ 和 $y$，分别代表生产线 $1$ 和 $2$ 的产量（单位）。总生产成本由二次函数建模：\n$$\nC(x,y) \\;=\\; x^{2} \\;+\\; y^{2} \\;+\\; \\frac{1}{2}\\,x\\,y.\n$$\n总产量为 $P(x,y)=x+y$（单位），总排放量为 $E(x,y)=x+2y$（排放单位）。工厂必须满足产量要求 $P(x,y)\\ge N$（其中 $N=10$）和排放上限 $E(x,y)\\le E_{\\max}$（其中 $E_{\\max}=14$）。产量为非负数：$x\\ge 0$ 和 $y\\ge 0$。\n\n在这些约束条件下，确定可实现的最低总成本 $C_{\\min}$。请用成本单位（Cost Units (CU)）表示您的最终答案。请提供一个精确值（不要四舍五入）。", "solution": "所给出的问题是一个约束优化问题，这是计算工程和运筹学中的一个标准任务。该问题是适定的，并具有科学依据。我现在将进行其形式化求解。\n\n目标是在一组线性不等式约束下，最小化成本函数 $C(x,y) = x^2 + y^2 + \\frac{1}{2}xy$。\n约束条件如下：\n$1.$ 产量要求：$x+y \\ge 10$\n$2.$ 排放上限：$x+2y \\le 14$\n$3.$ 生产线1的产量非负：$x \\ge 0$\n$4.$ 生产线2的产量非负：$y \\ge 0$\n\n首先，我们来描述由这些不等式定义的可行域。该区域是 $xy$ 平面上的一个凸多边形。该多边形的顶点由边界线的交点确定。\n边界线为 $x+y=10$、$x+2y=14$、$x=0$ 和 $y=0$。\n- $y=0$ 和 $x+y=10$ 的交点：得到点 $(10, 0)$。我们验证其可行性：$10+2(0)=10 \\le 14$。该点是可行的。我们称之为 $V_1 = (10, 0)$。\n- $y=0$ 和 $x+2y=14$ 的交点：得到点 $(14, 0)$。我们验证其可行性：$14+0=14 \\ge 10$。该点是可行的。我们称之为 $V_2 = (14, 0)$。\n- $x+y=10$ 和 $x+2y=14$ 的交点：用第二个方程减去第一个方程得到 $(x+2y)-(x+y) = 14-10$，简化为 $y=4$。将 $y=4$ 代入第一个方程得到 $x+4=10$，因此 $x=6$。这给出了点 $(6, 4)$。我们验证其可行性：$x=6 \\ge 0$ 且 $y=4 \\ge 0$。该点是可行的。我们称之为 $V_3 = (6, 4)$。\n\n可行域是一个以 $V_1(10,0)$、$V_2(14,0)$ 和 $V_3(6,4)$ 为顶点的三角形。\n\n目标函数是 $C(x,y) = x^2 + y^2 + \\frac{1}{2}xy$。为判断此函数是否为凸函数，我们考察其海森矩阵 $H$：\n$$ H(x,y) = \\begin{pmatrix} \\frac{\\partial^2 C}{\\partial x^2}  \\frac{\\partial^2 C}{\\partial x \\partial y} \\\\ \\frac{\\partial^2 C}{\\partial y \\partial x}  \\frac{\\partial^2 C}{\\partial y^2} \\end{pmatrix} = \\begin{pmatrix} 2  \\frac{1}{2} \\\\ \\frac{1}{2}  2 \\end{pmatrix} $$\n一阶主子式为 $2  0$。二阶主子式是行列式 $\\det(H) = (2)(2) - (\\frac{1}{2})(\\frac{1}{2}) = 4 - \\frac{1}{4} = \\frac{15}{4}  0$。由于海森矩阵对所有 $(x,y)$ 都是正定的，函数 $C(x,y)$ 是严格凸函数。\n\n一个严格凸函数在一个紧凸集（我们的三角形可行域）上的最小值是唯一的。由于无约束最小值 $(0,0)$ 在可行域之外，因此全局最小值必然出现在可行域的边界上。对于一个凸规划问题，最优解由KKT条件给出。我们可以先检查可行域的顶点，因为它们是极值点的常见候选位置。\n\n- 在 $V_1(10,0)$ 处：\n$C(10,0) = 10^2 + 0^2 + \\frac{1}{2}(10)(0) = 100$。\n\n- 在 $V_2(14,0)$ 处：\n$C(14,0) = 14^2 + 0^2 + \\frac{1}{2}(14)(0) = 196$。\n\n- 在 $V_3(6,4)$ 处：\n$C(6,4) = 6^2 + 4^2 + \\frac{1}{2}(6)(4) = 36 + 16 + 12 = 64$。\n\n比较这些值，顶点处的最小成本为 $64$，出现在点 $(x,y)=(6,4)$ 处。现在我们用KKT条件来验证这一点。\n\n我们将约束重写为标准形式 $g_i(x,y) \\le 0$：\n$g_1(x,y) = 10 - x - y \\le 0$\n$g_2(x,y) = x + 2y - 14 \\le 0$\n$g_3(x,y) = -x \\le 0$\n$g_4(x,y) = -y \\le 0$\n\n拉格朗日函数是：\n$$ \\mathcal{L}(x, y, \\lambda_1, \\lambda_2, \\mu_1, \\mu_2) = x^2 + y^2 + \\frac{1}{2}xy + \\lambda_1(10-x-y) + \\lambda_2(x+2y-14) - \\mu_1 x - \\mu_2 y $$\n其中 $\\lambda_1, \\lambda_2, \\mu_1, \\mu_2$ 是非负的拉格朗日乘子。\n\n在点 $(x,y)=(6,4)$ 处，约束 $g_1(x,y) = 10 - 6 - 4 = 0$ 和 $g_2(x,y) = 6 + 2(4) - 14 = 0$ 是激活的。非负约束是非激活的，因此根据互补松弛性，它们对应的乘子为零：$\\mu_1 = 0$ 和 $\\mu_2 = 0$。\nKKT平稳性条件是：\n$$ \\frac{\\partial \\mathcal{L}}{\\partial x} = 2x + \\frac{1}{2}y - \\lambda_1 + \\lambda_2 - \\mu_1 = 0 $$\n$$ \\frac{\\partial \\mathcal{L}}{\\partial y} = 2y + \\frac{1}{2}x - \\lambda_1 + 2\\lambda_2 - \\mu_2 = 0 $$\n代入 $(x,y)=(6,4)$ 和 $\\mu_1=\\mu_2=0$：\n$2(6) + \\frac{1}{2}(4) - \\lambda_1 + \\lambda_2 = 0 \\implies 14 - \\lambda_1 + \\lambda_2 = 0 \\implies \\lambda_1 - \\lambda_2 = 14$。\n$2(4) + \\frac{1}{2}(6) - \\lambda_1 + 2\\lambda_2 = 0 \\implies 11 - \\lambda_1 + 2\\lambda_2 = 0 \\implies \\lambda_1 - 2\\lambda_2 = 11$。\n\n我们求解这个关于 $\\lambda_1$ 和 $\\lambda_2$ 的方程组。用第一个方程减去第二个方程得到：\n$(\\lambda_1 - \\lambda_2) - (\\lambda_1 - 2\\lambda_2) = 14 - 11 \\implies \\lambda_2 = 3$。\n将 $\\lambda_2=3$ 代入第一个方程：$\\lambda_1 - 3 = 14 \\implies \\lambda_1 = 17$。\n\n我们找到了乘子 $\\lambda_1=17$ 和 $\\lambda_2=3$。所有激活约束的乘子都是非负的，满足对偶可行性。原始可行性和互补松弛性通过构造得到满足。\n由于 $(x,y)=(6,4)$ 满足凸优化问题的KKT条件，因此它是全局最小值点。\n\n可实现的最低总成本是 $C_{\\min} = C(6,4) = 64$。", "answer": "$$\n\\boxed{64}\n$$", "id": "2380580"}, {"introduction": "从解析解法过渡到计算方法，我们来解决一个现代通信工程中的实际问题。这个练习 [@problem_id:2380493] 旨在优化无线网络性能，它展示了如何将一个物理场景转化为一个凸优化问题。通过这种方式，我们可以利用强大的数值计算工具高效地找到最佳中继器位置，这凸显了问题建模在连接理论与实践中的核心作用。", "problem": "一个无线接入点位于坐标为 $\\,(A_x,A_y)\\,$ 米的固定位置，一个用户设备位于坐标为 $\\,(U_x,U_y)\\,$ 米的固定位置。一个 Wi-Fi 中继器必须通过一根最大长度为 $\\;L\\;$ 米的电源线，从坐标为 $\\,(O_x,O_y)\\,$ 米的墙壁插座供电。中继器可以放置在平面上任何满足可行性条件 $\\;\\|(x,y)-(O_x,O_y)\\|\\leq L\\,$ 的位置 $\\,(x,y)\\,$，其中 $\\;\\|\\cdot\\|\\;$ 表示欧几里得范数。位于位置 $\\,(p_x,p_y)\\,$ 的任意发射器与位于位置 $\\,(q_x,q_y)\\,$ 的任意接收器之间的大尺度路径损耗被建模为接收功率与 $\\;\\| (p_x,p_y)-(q_x,q_y)\\|^{-\\alpha}\\;$ 成正比，其中 $\\;\\alpha0\\;$ 是路径损耗指数。假设两跳链路的端到端信号质量受限于两跳（从接入点到中继器以及从中继器到用户）中较弱的一跳，因此需要最大化的性能指标是\n$$\nt \\;=\\; \\min\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|^{-\\alpha},\\;\\|(x,y)-(U_x,U_y)\\|^{-\\alpha}\\;\\Big\\}.\n$$\n您必须确定中继器的放置位置 $\\,(x^\\star,y^\\star)\\,$（以米为单位），该位置在满足电缆长度约束 $\\;\\|(x,y)-(O_x,O_y)\\|\\leq L\\,$ 的前提下，能够最大化 $\\;t\\;$。如果存在多个最优位置，您必须返回 x 坐标最小的那个；如果仍然存在并列，则选择 y 坐标最小的那个。所有坐标均以米表示，并四舍五入到六位小数。\n\n对于数值评估，请使用以下参数值测试套件，每个套件指定为一个元组 $\\;\\big((A_x,A_y),(U_x,U_y),(O_x,O_y),L,\\alpha\\big)\\;$：\n\n- 测试 $\\;1$: $\\;\\big((0,0),(10,0),(5,3),3,2\\big)$。\n- 测试 $\\;2$: $\\;\\big((0,0),(10,0),(20,0),3,2\\big)$。\n- 测试 $\\;3$: $\\;\\big((0,0),(10,0),(5,0),5,3.5\\big)$。\n- 测试 $\\;4$: $\\;\\big((-2,1),(4,7),(4,1),2,2.7\\big)$。\n\n您的程序必须为每个测试计算 $\\,(x^\\star,y^\\star)\\,$，并生成单行输出，其中包含四个结果，形式为用方括号括起来的逗号分隔列表，每个结果是双元素列表 $\\,[x^\\star,y^\\star]\\,$。例如，要求的输出格式是\n$$\n\\texttt{[[x\\_1,y\\_1],[x\\_2,y\\_2],[x\\_3,y\\_3],[x\\_4,y\\_4]]}\n$$\n其中每个 $\\,x_i\\,$ 和 $\\,y_i\\,$ 均以米为单位，并四舍五入到六位小数。不得打印任何额外文本。", "solution": "我们将此任务形式化为一个关于中继器位置 $\\,(x,y)\\,$ 的约束优化问题。长度为 $\\;r\\;$ 的一跳上的接收功率与 $\\;r^{-\\alpha}\\;$ 成比例，其中 $\\;\\alpha  0\\;$。端到端指标是\n$$\nt(x,y)\\;=\\;\\min\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|^{-\\alpha},\\;\\|(x,y)-(U_x,U_y)\\|^{-\\alpha}\\;\\Big\\}.\n$$\n由于函数 $\\;r\\mapsto r^{-\\alpha}\\;$ 对于 $\\;\\alpha  0\\;$ 是严格递减的，因此最大化 $\\;t(x,y)\\;$ 等价于最小化\n$$\ns(x,y)\\;=\\;\\max\\Big\\{\\;\\|(x,y)-(A_x,A_y)\\|,\\;\\|(x,y)-(U_x,U_y)\\|\\;\\Big\\}.\n$$\n因此，一个等价的凸优化表述引入了一个辅助标量 $\\;s\\ge 0\\;$，其形式如下\n$$\n\\begin{aligned}\n\\min_{x,y,s}\\quad  s \\\\\n\\text{约束条件}\\quad  \\|(x,y)-(A_x,A_y)\\|\\;\\le\\;s,\\\\\n \\|(x,y)-(U_x,U_y)\\|\\;\\le\\;s,\\\\\n \\|(x,y)-(O_x,O_y)\\|\\;\\le\\;L.\n\\end{aligned}\n$$\n每个约束 $\\;\\|(x,y)-(P_x,P_y)\\|\\le s\\;$ 都是凸的，因为它是一个二阶（欧几里得范数）锥约束，且目标函数 $\\;s\\;$ 是线性的。可行集 $\\;\\{(x,y):\\|(x,y)-(O_x,O_y)\\|\\le L\\}\\;$ 是一个闭圆盘，也是凸的。因此，该问题是一个凸二阶锥规划，任何局部最优解都是全局最优解。\n\n为了从基本原理出发求解，我们分析 Karush-Kuhn-Tucker (KKT) 最优性条件，对于具有适当约束规范的凸规划，这些条件是充要的。令\n$$\ng_A(x,y,s)=\\|(x,y)-(A_x,A_y)\\|-s,\\quad\ng_U(x,y,s)=\\|(x,y)-(U_x,U_y)\\|-s,\n$$\n$$\ng_O(x,y)=\\|(x,y)-(O_x,O_y)\\|-L.\n$$\n为这些不等式约束引入拉格朗日乘子 $\\;\\lambda_A\\ge 0,\\;\\lambda_U\\ge 0,\\;\\lambda_O\\ge 0\\;$。拉格朗日函数为\n$$\n\\mathcal{L}(x,y,s,\\lambda_A,\\lambda_U,\\lambda_O)\n\\;=\\; s\\;+\\;\\lambda_A\\big(\\|(x,y)-(A_x,A_y)\\|-s\\big)\\;+\\;\\lambda_U\\big(\\|(x,y)-(U_x,U_y)\\|-s\\big)\\;+\\;\\lambda_O\\big(\\|(x,y)-(O_x,O_y)\\|-L\\big).\n$$\n关于 $\\;s\\;$ 和 $\\;(x,y)\\;$ 的平稳性条件给出\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial s}=1-\\lambda_A-\\lambda_U=0\\quad\\Longrightarrow\\quad \\lambda_A+\\lambda_U=1,\n$$\n和\n$$\n\\frac{\\partial\\mathcal{L}}{\\partial(x,y)}=\n\\lambda_A\\,\\frac{(x,y)-(A_x,A_y)}{\\|(x,y)-(A_x,A_y)\\|}\n+\\lambda_U\\,\\frac{(x,y)-(U_x,U_y)}{\\|(x,y)-(U_x,U_y)\\|}\n+\\lambda_O\\,\\frac{(x,y)-(O_x,O_y)}{\\|(x,y)-(O_x,O_y)\\|}=\\mathbf{0},\n$$\n其中相应的分母不为零。互补松弛性和原始可行性要求\n$$\n\\lambda_A\\,g_A(x,y,s)=0,\\quad \\lambda_U\\,g_U(x,y,s)=0,\\quad \\lambda_O\\,g_O(x,y)=0,\n$$\n$$\ng_A(x,y,s)\\le 0,\\quad g_U(x,y,s)\\le 0,\\quad g_O(x,y)\\le 0,\\quad \\lambda_A,\\lambda_U,\\lambda_O\\ge 0.\n$$\n\n定性结构。在最优点，通常有 $\\;g_A=0\\;$ 和 $\\;g_U=0\\;$（两段链路的距离等于最小化的半径 $\\;s\\;$），除非插座位置和电缆约束迫使中继器离一个端点太近，以至于另一个约束单独决定了 $\\;s\\;$。如果插座约束非激活（$\\;\\lambda_O=0\\;$），平稳性条件简化为\n$$\n\\lambda_A\\,\\mathbf{u}_A+\\lambda_U\\,\\mathbf{u}_U=\\mathbf{0},\\quad \\lambda_A+\\lambda_U=1,\n$$\n其中 $\\;\\mathbf{u}_A=\\frac{(x,y)-(A_x,A_y)}{\\|(x,y)-(A_x,A_y)\\|}\\;$ 且 $\\;\\mathbf{u}_U=\\frac{(x,y)-(U_x,U_y)}{\\|(x,y)-(U_x,U_y)\\|}\\;$。这意味着 $\\;\\mathbf{u}_A=-\\mathbf{u}_U\\;$ 且 $\\;\\lambda_A=\\lambda_U=\\tfrac12\\;$，将 $\\;(x,y)\\;$ 置于 $\\;(A_x,A_y)\\;$ 和 $\\;(U_x,U_y)\\;$ 的垂直平分线上，并且在可行的情况下，为了最小化 $\\;s\\;$，将其置于它们的中点。如果插座约束激活（$\\;\\lambda_O > 0\\;$），则中继器位于圆 $\\;\\|(x,y)-(O_x,O_y)\\|=L\\;$ 上，并且平稳性条件通过 $\\;\\lambda_A,\\lambda_U,\\lambda_O\\;$ 重新加权，平衡了朝向三个中心的单位向量。出现以下特殊情况：\n\n- 如果 $\\;g_A=0,\\;g_U0\\;$，则 $\\;\\lambda_U=0,\\;\\lambda_A=1\\;$ 且 $\\;\\lambda_O\\ge 0\\;$，得到 $\\;\\mathbf{u}_A+\\lambda_O\\,\\mathbf{u}_O=\\mathbf{0}\\;$，即插座圆上离 $\\;(A_x,A_y)\\;$ 最近的点。\n- 如果 $\\;g_U=0,\\;g_A0\\;$，类似地，为插座圆上离 $\\;(U_x,U_y)\\;$ 最近的点。\n- 如果 $\\;g_A=0$ 且 $\\;g_U=0\\;$ 且 $\\;\\lambda_O > 0\\;$，解位于插座圆和两个端点垂直平分线的交点上，且在使公共距离最小化的一侧。\n\n由于凸性，这些 KKT 特征是充分的。在数值上，可以直接求解变量为 $\\;(x,y,s)\\;$ 的凸规划。\n\n对测试套件的解析评估：\n\n- 测试 $\\;1$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(5,3),\\;L=3\\;$。垂直平分线是 $\\;x=5\\;$。与圆 $\\;(x-5)^2+(y-3)^2=3^2\\;$ 相交得到 $\\;(x,y)=(5,0)\\;$ 和 $\\;(x,y)=(5,6)\\;$。在 $\\;(5,0)\\;$ 处到两端点的公共距离是 $\\;5\\;$，而在 $\\;(5,6)\\;$ 处是 $\\;\\sqrt{25+36}\\;$。最小化选择 $\\;(x^\\star,y^\\star)=(5,0)\\;$。四舍五入到六位小数：$\\;[5.000000,0.000000]\\;$。\n\n- 测试 $\\;2$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(20,0),\\;L=3\\;$。可行域为圆盘 $(x-20)^2+y^2 \\le 9$。对于此圆盘内的任意点 $(x,y)$，其 $x$ 坐标满足 $17 \\le x \\le 23$。因此，该点离 $A(0,0)$ 的距离总是大于其离 $U(10,0)$ 的距离。这意味着目标函数简化为 $\\max\\{\\|R-A\\|, \\|R-U\\|\\} = \\|R-A\\|$。因此，问题转化为在可行圆盘内找到一个使到 $A$ 的距离最小化的点。这个点就是圆盘上离 $A$ 最近的点，即 $(17,0)$。因此 $\\;(x^\\star,y^\\star)=(17,0)\\;$，即 $\\;[17.000000,0.000000]\\;$。\n\n- 测试 $\\;3$：$\\;(A_x,A_y)=(0,0),\\;(U_x,U_y)=(10,0),\\;(O_x,O_y)=(5,0),\\;L=5\\;$。垂直平分线是 $\\;x=5\\;$。与圆 $\\;(x-5)^2+y^2=25\\;$ 相交得到 $\\;(5,5)\\;$ 和 $\\;(5,-5)\\;$，两者都与端点等距，目标函数值相等。根据平局规则选择较小的 $\\;x\\;$（两者相等），然后选择较小的 $\\;y\\;$，即 $\\;-5\\;$。因此 $\\;[5.000000,-5.000000]\\;$。\n\n- 测试 $\\;4$：$\\;(A_x,A_y)=(-2,1),\\;(U_x,U_y)=(4,7),\\;(O_x,O_y)=(4,1),\\;L=2\\;$。接入点和用户之间线段的垂直平分线是直线 $\\;x+y=5\\;$。无约束最优解（线段中点）不在可行圆盘 $\\;(x-4)^2+(y-1)^2 \\le 4\\;$ 内。因此，最优解位于圆盘的边界上，并且是离无约束最优点最近的点。该点位于连接圆心 $(4,1)$ 和中点 $(1,4)$ 的线段上。从插座到中点的单位方向与 $\\;(-1,1)\\;$ 成比例，因此最优点是\n$$\n(x^\\star,y^\\star) \\;=\\; (4,1)\\;+\\;2\\;\\frac{(-1,1)}{\\sqrt{2}} \\;=\\; \\big(4-\\sqrt{2},\\;1+\\sqrt{2}\\big),\n$$\n四舍五入为 $\\;[2.585786,2.414214]\\;$。\n\n这些位置的确定与路径损耗指数 $\\;\\alpha\\;$ 无关，因为对于任何固定的 $\\;\\alpha > 0\\;$，最大化 $\\;\\min\\{\\|R-A\\|^{-\\alpha},\\|R-U\\|^{-\\alpha}\\}\\;$ 等价于最小化 $\\;\\max\\{\\|R-A\\|,\\|R-U\\|\\;\\}$。\n\n附带的程序为每个测试用例求解了所述的凸问题，并应用了平局打破规则，以要求的输出格式返回四舍五入到六位小数的坐标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve_case(A, U, O, L, alpha):\n    # A, U, O are (x, y) tuples; L, alpha are floats\n    Ax, Ay = A\n    Ux, Uy = U\n    Ox, Oy = O\n\n    # Objective: minimize s subject to ||R - A|| = s, ||R - U|| = s, ||R - O|| = L, s = 0\n    def objective(z):\n        # z = [x, y, s]\n        return z[2]\n\n    def cons_A(z):\n        x, y, s = z\n        return s - np.hypot(x - Ax, y - Ay)  # = 0 for feasibility form in SLSQP\n\n    def cons_U(z):\n        x, y, s = z\n        return s - np.hypot(x - Ux, y - Uy)\n\n    def cons_O(z):\n        x, y, s = z\n        return L - np.hypot(x - Ox, y - Oy)\n\n    constraints_template = [\n        {'type': 'ineq', 'fun': cons_A},\n        {'type': 'ineq', 'fun': cons_U},\n        {'type': 'ineq', 'fun': cons_O},\n    ]\n\n    # Generate multiple initial guesses to handle symmetry and nonconvex numerics (though problem is convex)\n    initials = []\n\n    # Midpoint projection to circle (if needed)\n    Mx, My = (0.5 * (Ax + Ux), 0.5 * (Ay + Uy))\n    vecMO = np.array([Mx - Ox, My - Oy])\n    normMO = np.hypot(vecMO[0], vecMO[1])\n    if normMO  1e-12:\n        R0 = np.array([Ox, Oy]) + min(L, normMO) * vecMO / normMO\n    else:\n        # Midpoint equals outlet; pick a point on circle along +x\n        R0 = np.array([Ox + L, Oy])\n    s0 = max(np.hypot(R0[0] - Ax, R0[1] - Ay), np.hypot(R0[0] - Ux, R0[1] - Uy))\n    initials.append(np.array([R0[0], R0[1], s0]))\n\n    # Add several points on the outlet circle\n    if L  0:\n        for theta in np.linspace(0.0, 2.0 * np.pi, 12, endpoint=False):\n            x = Ox + L * np.cos(theta)\n            y = Oy + L * np.sin(theta)\n            s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n            initials.append(np.array([x, y, s]))\n    else:\n        # L == 0: The only feasible R is at the outlet\n        x = Ox\n        y = Oy\n        s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n        initials.append(np.array([x, y, s]))\n\n    # Bounds: x, y unbounded; s = 0\n    bounds = [(None, None), (None, None), (0.0, None)]\n\n    candidates = []\n    best_obj = None\n\n    for z0 in initials:\n        res = minimize(\n            objective, z0, method='SLSQP',\n            bounds=bounds,\n            constraints=constraints_template,\n            options={'ftol': 1e-12, 'maxiter': 500}\n        )\n        if not res.success:\n            # Even if not successful, consider if it's nearly feasible; skip otherwise\n            continue\n        x, y, s = res.x\n        # Feasibility check with tolerance\n        feas = (\n            s + 1e-7 = np.hypot(x - Ax, y - Ay) and\n            s + 1e-7 = np.hypot(x - Ux, y - Uy) and\n            L + 1e-7 = np.hypot(x - Ox, y - Oy) and\n            s = -1e-7\n        )\n        if not feas:\n            continue\n        obj = s\n        candidates.append((obj, x, y, s))\n\n        if best_obj is None or obj  best_obj:\n            best_obj = obj\n\n    if not candidates:\n        # Fallback: enforce at least the outlet point (L could be zero)\n        x = Ox\n        y = Oy\n        s = max(np.hypot(x - Ax, y - Ay), np.hypot(x - Ux, y - Uy))\n        return [x, y]\n\n    # Filter near-optimal candidates within tolerance\n    tol = max(1e-8, 1e-8 * (1.0 + best_obj))\n    near_opt = [(x, y) for (obj, x, y, s) in candidates if obj = best_obj + tol]\n\n    # Deduplicate near-opt points by proximity\n    unique_pts = []\n    for (x, y) in near_opt:\n        if not any((abs(x - ux) = 1e-7 and abs(y - uy) = 1e-7) for (ux, uy) in unique_pts):\n            unique_pts.append((x, y))\n\n    # Apply tie-breaking: smallest x, then smallest y\n    unique_pts.sort(key=lambda p: (p[0], p[1]))\n    x_star, y_star = unique_pts[0]\n    return [x_star, y_star]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: ((Ax,Ay),(Ux,Uy),(Ox,Oy), L, alpha)\n    test_cases = [\n        ((0.0, 0.0), (10.0, 0.0), (5.0, 3.0), 3.0, 2.0),\n        ((0.0, 0.0), (10.0, 0.0), (20.0, 0.0), 3.0, 2.0),\n        ((0.0, 0.0), (10.0, 0.0), (5.0, 0.0), 5.0, 3.5),\n        ((-2.0, 1.0), (4.0, 7.0), (4.0, 1.0), 2.0, 2.7),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, U, O, L, alpha = case\n        x_star, y_star = solve_case(A, U, O, L, alpha)\n        # Round to six decimals as required\n        x_out = float(np.round(x_star, 6))\n        y_out = float(np.round(y_star, 6))\n        results.append([x_out, y_out])\n\n    # Final print statement in the exact required format.\n    # Ensure fixed decimal representation with six decimals.\n    def fmt_pair(p):\n        return f\"[{p[0]:.6f},{p[1]:.6f}]\"\n    print(f\"[{','.join(fmt_pair(p) for p in results)}]\")\n\nsolve()\n```", "id": "2380493"}, {"introduction": "在掌握了如何建立模型并使用工具求解后，我们现在将深入探索优化算法的“引擎盖”之下。这个练习 [@problem_id:2380561] 要求我们亲手实现增强拉格朗日方法，这是一种求解约束优化问题的强大迭代算法。通过这个过程，你不仅能理解算法如何逐步逼近最优解，还能体会到算法参数（如罚项系数 $\\rho$）对收敛性能的关键影响。", "problem": "考虑一个具有等式约束的、包含两个实变量的二次优化问题。设目标函数为\n$$\nf(\\boldsymbol{x}) \\;=\\; \\tfrac{1}{2}\\,\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} \\;+\\; \\boldsymbol{c}^\\top \\boldsymbol{x},\n$$\n其中 $Q \\in \\mathbb{R}^{2 \\times 2}$ 是对称正定矩阵，$\\boldsymbol{c} \\in \\mathbb{R}^{2}$。线性等式约束为\n$$\nA\\,\\boldsymbol{x} \\;=\\; b,\n$$\n其中 $A \\in \\mathbb{R}^{1 \\times 2}$，$b \\in \\mathbb{R}$。使用以下具体数据\n$$\nQ \\;=\\; \\begin{bmatrix} 4  1 \\\\ 1  3 \\end{bmatrix}, \\quad \\boldsymbol{c} \\;=\\; \\begin{bmatrix} -1 \\\\ -2 \\end{bmatrix}, \\quad A \\;=\\; \\begin{bmatrix} 1  2 \\end{bmatrix}, \\quad b \\;=\\; 1.\n$$\n设初始原始迭代值为\n$$\n\\boldsymbol{x}_0 \\;=\\; \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix},\n$$\n等式约束的初始对偶迭代值（拉格朗日乘子）为\n$$\n\\lambda_0 \\;=\\; 0.\n$$\n将在迭代点 $(\\boldsymbol{x}, \\lambda)$ 处的 Karush–Kuhn–Tucker (KKT) 残差定义为原始残差\n$$\nr_p \\;=\\; \\lVert A\\,\\boldsymbol{x} - b \\rVert_2,\n$$\n和平稳性残差\n$$\nr_s \\;=\\; \\lVert Q\\,\\boldsymbol{x} + \\boldsymbol{c} + A^\\top \\lambda \\rVert_2.\n$$\n当满足以下条件时，算法被宣告收敛\n$$\n\\max\\{\\, r_p,\\, r_s \\,\\} \\;\\le\\; \\varepsilon,\n$$\n收敛容差为\n$$\n\\varepsilon \\;=\\; 10^{-9}.\n$$\n设定最大外层迭代次数为\n$$\nk_{\\max} \\;=\\; 10000.\n$$\n对于罚参数值（测试集）\n$$\n\\boldsymbol{\\rho}_{\\text{test}} \\;=\\; \\big[\\, 0.01,\\, 0.1,\\, 1.0,\\, 10.0,\\, 1000.0 \\,\\big],\n$$\n对该问题应用数值增广拉格朗日方法，对于 $\\boldsymbol{\\rho}_{\\text{test}}$ 中的每个 $\\rho$ 值，都从 $\\boldsymbol{x}_0$ 和 $\\lambda_0$ 开始。对于每个 $\\rho$，计算满足上述收敛准则所需的外层迭代次数。如果在 $k_{\\max}$ 次迭代内未达到收敛，则报告该情况下的迭代次数为 $k_{\\max}$。\n\n您的程序必须生成单行输出，其中包含与 $\\boldsymbol{\\rho}_{\\text{test}}$ 中条目顺序相同的迭代次数，形式为用方括号括起来的逗号分隔列表。例如，如果计数为 $k_1, k_2, k_3, k_4, k_5$，则输出必须是\n$$\n[\\,k_1,k_2,k_3,k_4,k_5\\,].\n$$\n所有数值答案均无量纲，且必须以整数形式返回。此问题不涉及物理单位，也不使用角度。", "solution": "所给问题是一个标准的、适定的带等式约束的二次优化问题。所有必要的数据、初始条件和收敛准则均已提供，并且该问题基于计算工程中数值优化的既定原则。因此，它是有效的，并且允许直接求解。\n\n任务是最小化二次目标函数\n$$\nf(\\boldsymbol{x}) = \\frac{1}{2}\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} + \\boldsymbol{c}^\\top \\boldsymbol{x}\n$$\n同时满足线性等式约束\n$$\nA\\,\\boldsymbol{x} - b = 0.\n$$\n该问题将使用增广拉格朗日方法（也称为乘子法）来求解。这种迭代方法将拉格朗日函数与一个针对约束违反的二次惩罚项相结合。\n\n此问题的增广拉格朗日函数 $L_{\\rho}(\\boldsymbol{x}, \\lambda)$ 定义为：\n$$\nL_{\\rho}(\\boldsymbol{x}, \\lambda) = f(\\boldsymbol{x}) + \\lambda (A\\,\\boldsymbol{x} - b) + \\frac{\\rho}{2}(A\\,\\boldsymbol{x} - b)^2\n$$\n此处，$\\lambda \\in \\mathbb{R}$ 是与等式约束相关的拉格朗日乘子，$\\rho  0$ 是罚参数。增广拉格朗日方法通过一系列“外层”迭代进行，迭代次数由 $k$ 索引，从初始猜测 $(\\boldsymbol{x}_0, \\lambda_0)$ 开始。每次迭代包括两个主要步骤：\n\n1.  **原始更新（x-最小化）：**对于给定的乘子估计值 $\\lambda_k$，通过最小化关于 $\\boldsymbol{x}$ 的增广拉格朗日函数来找到下一个原始迭代值 $\\boldsymbol{x}_{k+1}$：\n    $$\n    \\boldsymbol{x}_{k+1} = \\operatorname*{arg\\,min}_{\\boldsymbol{x}} L_{\\rho}(\\boldsymbol{x}, \\lambda_k)\n    $$\n    由于 $L_{\\rho}(\\boldsymbol{x}, \\lambda_k)$ 是关于 $\\boldsymbol{x}$ 的严格凸二次函数（因为 $Q$ 是正定的且 $\\rho  0$），这个最小化子问题有唯一解。该解通过将 $L_{\\rho}$ 关于 $\\boldsymbol{x}$ 的梯度设置为零来找到：\n    $$\n    \\nabla_{\\boldsymbol{x}} L_{\\rho}(\\boldsymbol{x}_{k+1}, \\lambda_k) = \\boldsymbol{0}\n    $$\n    计算梯度可得：\n    $$\n    \\nabla_{\\boldsymbol{x}} \\left( \\frac{1}{2}\\boldsymbol{x}^\\top Q\\,\\boldsymbol{x} + \\boldsymbol{c}^\\top \\boldsymbol{x} + \\lambda_k (A\\,\\boldsymbol{x} - b) + \\frac{\\rho}{2}(A\\,\\boldsymbol{x} - b)^2 \\right) = Q\\boldsymbol{x} + \\boldsymbol{c} + A^\\top\\lambda_k + \\rho A^\\top(A\\boldsymbol{x} - b) = \\boldsymbol{0}\n    $$\n    为了求解 $\\boldsymbol{x}_{k+1}$，我们将各项重新排列成一个线性方程组：\n    $$\n    (Q + \\rho A^\\top A)\\boldsymbol{x}_{k+1} = - \\boldsymbol{c} - A^\\top\\lambda_k + \\rho A^\\top b\n    $$\n    矩阵 $(Q + \\rho A^\\top A)$ 是对称正定的，这保证了该线性系统可以被可靠地求解，从而得到唯一的 $\\boldsymbol{x}_{k+1}$。\n\n2.  **对偶更新（乘子更新）：**在找到 $\\boldsymbol{x}_{k+1}$ 之后，根据以下规则更新拉格朗日乘子：\n    $$\n    \\lambda_{k+1} = \\lambda_k + \\rho(A\\boldsymbol{x}_{k+1} - b)\n    $$\n    这个更新规则旨在随着迭代的进行将原始残差 $(A\\boldsymbol{x} - b)$ 驱动至零。\n\n迭代过程从给定的初始值 $\\boldsymbol{x}_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}$ 和 $\\lambda_0 = 0$ 开始。在每次外层迭代 $k$ 中，我们通过评估 Karush–Kuhn–Tucker (KKT) 残差来判断收敛性。原始残差 $r_p = \\lVert A\\,\\boldsymbol{x}_{k+1} - b \\rVert_2$衡量当前迭代值的可行性，而平稳性残差 $r_s = \\lVert Q\\,\\boldsymbol{x}_{k+1} + \\boldsymbol{c} + A^\\top \\lambda_{k+1} \\rVert_2$衡量迭代值距离满足拉格朗日平稳性条件的程度。\n\n当条件 $\\max\\{r_p, r_s\\} \\le \\varepsilon$ 满足时，算法终止，其中容差 $\\varepsilon = 10^{-9}$。记录下达到此条件所需的外层迭代次数。如果在 $k_{\\max} = 10000$ 次迭代内未达到收敛，则停止该过程，并将迭代次数报告为 $k_{\\max}$。\n\n对于所提供测试集 $\\boldsymbol{\\rho}_{\\text{test}} = [0.01, 0.1, 1.0, 10.0, 1000.0]$ 中的每个罚参数 $\\rho$，都独立执行这整个过程。对于每个 $\\rho$，算法都会重置为初始条件 $(\\boldsymbol{x}_0, \\lambda_0)$，并计算收敛所需的迭代次数。最终输出是这些迭代次数的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the equality-constrained quadratic optimization problem using\n    the augmented Lagrangian method for a range of penalty parameters.\n    \"\"\"\n    # Define problem data\n    Q = np.array([[4., 1.], [1., 3.]])\n    c = np.array([[-1.], [-2.]])\n    A = np.array([[1., 2.]])\n    b = 1.0\n\n    # Initial conditions\n    x0 = np.array([[0.], [0.]])\n    lambda0 = 0.0\n\n    # Algorithm parameters\n    epsilon = 1e-9\n    k_max = 10000\n    rho_test = [0.01, 0.1, 1.0, 10.0, 1000.0]\n\n    # Pre-compute constant matrices\n    At = A.T\n    AtA = At @ A\n\n    def run_augmented_lagrangian(rho):\n        \"\"\"\n        Executes the augmented Lagrangian algorithm for a given penalty parameter rho.\n\n        Returns the number of outer iterations required for convergence.\n        \"\"\"\n        x = x0.copy()\n        lam = lambda0\n        k = 0\n\n        # Pre-compute the system matrix M which depends on rho\n        M = Q + rho * AtA\n        \n        while k = k_max:\n            # 1. Check for convergence at the current iterate (x, lam)\n            # Use the updated lambda for stationarity residual check\n            # For this problem, we check at the beginning of the loop\n            # with values from the previous iteration. So use x and lam.\n            # To be precise, check (x_k, lambda_k)\n            # Primal residual for x_k\n            primal_residual_vec = A @ x - b\n            rp = np.linalg.norm(primal_residual_vec)\n            \n            # Stationarity residual for (x_k, lambda_k)\n            stationarity_residual_vec = Q @ x + c + At * lam\n            rs = np.linalg.norm(stationarity_residual_vec)\n\n            if max(rp, rs) = epsilon:\n                return k\n\n            if k == k_max:\n                break\n            \n            # 2. Perform the update step to get (x_{k+1}, lambda_{k+1})\n            # Primal update (x-minimization)\n            d = -c - lam * At + rho * b * At\n            x_next = np.linalg.solve(M, d)\n            \n            # Dual update (lambda-update)\n            # The expression A @ x_next - b results in a 1x1 array\n            lam_next = lam + rho * (A @ x_next - b)[0, 0]\n\n            # Update iterates for the next loop\n            x = x_next\n            lam = lam_next\n            k += 1\n            \n        return k_max\n\n    results = []\n    for rho in rho_test:\n        iterations = run_augmented_lagrangian(rho)\n        results.append(iterations)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2380561"}]}