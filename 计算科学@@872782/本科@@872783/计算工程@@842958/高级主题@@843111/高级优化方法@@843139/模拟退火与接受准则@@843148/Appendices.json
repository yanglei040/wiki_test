{"hands_on_practices": [{"introduction": "本次练习将带领我们将模拟退火算法追溯到其在统计物理学中的根源。我们将使用经典的二维伊辛模型 (Ising model) 作为我们的试验场，这是一个描述磁性物质相变的基石模型。通过实现模拟退火来寻找该系统的基态能量，并比较不同类型冷却策略（如指数、线性和对数冷却）的效果，你将对算法的核心机制以及温度控制的重要性建立起直观的理解。[@problem_id:2435206]", "problem": "考虑一个大小为 $N \\times N$ 的方形晶格上的二维伊辛模型，其自旋 $s_{i,j} \\in \\{-1,+1\\}$，能量为\n$$\nE(\\mathbf{s}) \\;=\\; -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'} \\;-\\; B \\sum_{i=1}^{N} \\sum_{j=1}^{N} s_{i,j},\n$$\n其中第一个求和是对所有无序的最近邻对进行的，$B$ 是一个外部磁场。在本任务中，设 $B=0$ 且 $J>0$（铁磁耦合）。系统采用开放边界条件（无环绕邻居）或周期性边界条件（两个坐标方向上都有环绕邻居）。在能量计算中，每条键只计算一次。\n\n模拟退火过程定义如下。从一个自旋初始构型开始，该构型中的自旋是从 $\\{-1,+1\\}$ 中独立均匀选择的。在离散步骤 $k \\in \\{0,1,2,\\dots\\}$，随机均匀地选择一个位点 $(i,j)$，并提出翻转建议 $s_{i,j} \\mapsto -s_{i,j}$。令 $\\Delta E_k$ 表示由这次单自旋翻转导致的能量 $E$ 的变化。该建议以概率被接受\n$$\nA_k \\;=\\; \\min\\!\\left(1, \\exp\\!\\left(-\\frac{\\Delta E_k}{T_k}\\right)\\right),\n$$\n其中 $T_k$ 是步骤 $k$ 时的温度。温度方案是一个长度为 $K$ 的正序列 $\\{T_k\\}_{k=0}^{K-1}$，本任务的过程在每个温度下使用固定次数的扫描。一次扫描定义为在相同温度下进行 $N^2$ 次独立的单自旋翻转提议。总提议次数等于 $K$ 乘以每个温度的扫描次数再乘以 $N^2$。为保证可复现性，每次运行时必须在开始时用种子 $0$ 初始化伪随机数生成器。\n\n对于 $B=0$ 和 $J>0$ 的情况，根据模型定义的第一性原理，确定给定晶格尺寸 $N$、耦合常数 $J$ 和边界条件 $\\mathrm{bc} \\in \\{\\text{open},\\text{periodic}\\}$ 下的解析基态能量 $E_{\\mathrm{gs}}(N,J,\\mathrm{bc})$。然后，对于下面指定的每个方案和参数集，运行上述模拟退火过程，并记录在整个运行过程中达到的最小能量 $E_{\\min}$。对于每个测试用例，计算绝对差\n$$\nD \\;=\\; \\big| E_{\\min} \\;-\\; E_{\\mathrm{gs}}(N,J,\\mathrm{bc}) \\big|.\n$$\n\n在所有情况下均使用 $J=1$。使用以下方案和参数，其中 $K$ 是温度的数量，每个温度在指定的扫描次数内保持恒定。方案如下：\n- 指数型：$T_k = T_0 \\,\\alpha^k$，参数为 $T_0>0$ 和 $\\alpha \\in (0,1)$。\n- 线性：$T_k = \\dfrac{T_0}{1 + c k}$，参数为 $T_0>0$ 和 $c>0$。\n- 对数型：$T_k = \\dfrac{T_0}{\\log(2 + k)}$，参数为 $T_0>0$。\n\n测试套件（每个项目符号代表一次独立运行）：\n- 情况1：$N=6$，周期性边界条件，指数型方案，参数为 $T_0=4.0$, $\\alpha=0.98$, $K=500$，每个温度扫描 $1$ 次。\n- 情况2：$N=7$，开放边界条件，线性方案，参数为 $T_0=5.0$, $c=0.01$, $K=700$，每个温度扫描 $1$ 次。\n- 情况3：$N=1$，开放边界条件，指数型方案，参数为 $T_0=1.0$, $\\alpha=0.5$, $K=5$，每个温度扫描 $1$ 次。\n- 情况4：$N=3$，周期性边界条件，对数型方案，参数为 $T_0=5.0$, $K=600$，每个温度扫描 $2$ 次。\n\n您的程序应生成一行输出，其中包含结果，格式为方括号括起来的逗号分隔列表，顺序与上述情况一致：\n$$\n[D_1, D_2, D_3, D_4].\n$$\n每个 $D_i$ 都必须是浮点数。不涉及物理单位。不使用角度。请将任何分数值表示为小数。", "solution": "该问题要求对一个在 $N \\times N$ 方形晶格上的二维铁磁伊辛模型进行分析和模拟，并对其应用模拟退火过程。目标是计算模拟过程中找到的最小能量 $E_{\\min}$ 与解析确定的基态能量 $E_{\\mathrm{gs}}$ 之间的绝对差。\n\n首先，我们确定解析基态能量 $E_{\\mathrm{gs}}$。系统的哈密顿量由下式给出\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'} - B \\sum_{i=1}^{N} \\sum_{j=1}^{N} s_{i,j}\n$$\n问题指定了零外部磁场 $B=0$ 和正耦合常数 $J>0$（铁磁相互作用）。能量表达式简化为\n$$\nE(\\mathbf{s}) = -J \\sum_{\\langle (i,j),(i',j') \\rangle} s_{i,j}\\, s_{i',j'}\n$$\n为了最小化此能量，必须最大化求和项 $\\sum s_{i,j}\\,s_{i',j'}$。由于每个自旋 $s_{i,j}$ 只能是 $+1$ 或 $-1$，一对相邻自旋的乘积 $s_{i,j}\\,s_{i',j'}$ 在其等于 $+1$ 时达到最大值，这发生在 $s_{i,j} = s_{i',j'}$ 的情况下。因此，当所有自旋都对齐时，即所有 $s_{i,j} = +1$ 或所有 $s_{i,j} = -1$ 时，系统达到基态。在这种构型下，求和中的每一项都贡献 $+1$。因此，基态能量为 $E_{\\mathrm{gs}} = -J \\times (\\text{最近邻键的总数})$。\n\n键的数量取决于边界条件：\n1.  **周期性边界条件**：晶格是一个环面。$N^2$ 个位点中的每一个都有四个邻居（两个水平和两个垂直）。为了每个键只计算一次，我们将每个位点的邻居数相加再除以二。键的总数为 $\\frac{1}{2} (N^2 \\times 4) = 2N^2$。基态能量为\n    $$E_{\\mathrm{gs}}(N,J,\\mathrm{periodic}) = -J \\cdot 2N^2$$\n2.  **开放边界条件**：晶格有边界。有 $N$ 行，每行有 $N-1$ 个水平键，总共有 $N(N-1)$ 个水平键。同样，有 $N$ 列，每列有 $N-1$ 个垂直键，总共有 $N(N-1)$ 个垂直键。键的总数为 $N(N-1) + N(N-1) = 2N(N-1)$。基态能量为\n    $$E_{\\mathrm{gs}}(N,J,\\mathrm{open}) = -J \\cdot 2N(N-1)$$\n\n接下来，我们讨论模拟退火过程。这是一种用于寻找函数全局最小值的概率优化算法。该过程从一个随机的自旋构型开始。在每一步中，通过翻转一个随机选择的单个自旋来提出一个新状态。计算由此翻转产生的能量变化 $\\Delta E$。在位点 $(i,j)$ 处将状态从 $s_{i,j}$ 翻转为 $-s_{i,j}$ 会使能量改变\n$$\n\\Delta E = E_{\\text{new}} - E_{\\text{old}} = \\left(-J \\sum_{k \\in \\text{neigh}} (-s_{i,j})s_k \\right) - \\left(-J \\sum_{k \\in \\text{neigh}} s_{i,j}s_k \\right) = 2J s_{i,j} \\sum_{k \\in \\text{neigh}} s_k\n$$\n其中求和是针对位点 $(i,j)$ 的邻居的自旋 $s_k$。这种高效的计算方法避免了在每一步都重新计算系统的总能量。\n\n根据 Metropolis 准则，提出的翻转以概率 $A_k = \\min(1, \\exp(-\\Delta E_k / T_k))$ 被接受。这里，$T_k$ 是步骤 $k$ 的温度。如果 $\\Delta E_k \\le 0$，移动总是被接受。如果 $\\Delta E_k > 0$，则移动被接受的概率随着温度 $T_k$ 的降低而减小。\n\n温度根据一个方案 $\\{T_k\\}_{k=0}^{K-1}$ 逐渐降低。对于方案中的每个温度 $T_k$，执行固定次数的扫描，其中一次扫描包括 $N^2$ 次自旋翻转提议。在整个模拟过程中，记录遇到的最小能量 $E_{\\min}$。\n\n指定的三个温度方案是：\n-   **指数型**：$T_k = T_0 \\alpha^k$\n-   **线性**：$T_k = T_0 / (1 + ck)$\n-   **对数型**：$T_k = T_0 / \\log(2+k)$\n\n实现过程首先使用导出的公式（$J=1$）为每个测试用例计算 $E_{\\mathrm{gs}}$。然后，为每个情况运行一个独立的模拟。为了可复现性，伪随机数生成器用种子 $0$ 进行初始化。一个 $N \\times N$ 的自旋网格被随机初始化。然后模拟会遍历指定方案中的 $K$ 个温度。对于每个温度，它执行所需次数的扫描，每次扫描包含 $N^2$ 个蒙特卡洛步骤（提议、计算 $\\Delta E$、接受/拒绝）。当前能量和迄今为止找到的最小能量会相应更新。最后，计算绝对差 $D = |E_{\\min} - E_{\\mathrm{gs}}|$。对所有四个测试用例重复此过程。一个特殊情况是 $N=1$ 且为开放边界，它没有键，因此其能量始终为 $0$，无论自旋构型或退火过程如何。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef calculate_analytical_gs_energy(N, J, bc):\n    \"\"\"Calculates the analytical ground state energy for the Ising model.\"\"\"\n    if N == 0:\n        return 0.0\n    if bc == 'periodic':\n        # For a periodic lattice, each of N^2 sites has 4 neighbors.\n        # Number of bonds = (N^2 * 4) / 2 = 2 * N^2\n        return -J * 2.0 * N**2\n    elif bc == 'open':\n        # For an open lattice, there are N*(N-1) horizontal and N*(N-1) vertical bonds.\n        # Number of bonds = 2 * N * (N - 1)\n        return -J * 2.0 * N * (N - 1)\n    else:\n        raise ValueError(\"Invalid boundary condition specified.\")\n\ndef calculate_total_energy(spins, N, J, bc):\n    \"\"\"Calculates the total energy of the spin configuration. Used for initialization.\"\"\"\n    energy = 0.0\n    for r in range(N):\n        for c in range(N):\n            spin = spins[r, c]\n            if bc == 'periodic':\n                # Sum over right and down neighbors to count each bond once\n                right_neighbor = spins[r, (c + 1) % N]\n                down_neighbor = spins[(r + 1) % N, c]\n                energy += -J * spin * right_neighbor\n                energy += -J * spin * down_neighbor\n            elif bc == 'open':\n                if c  N - 1:\n                    right_neighbor = spins[r, c + 1]\n                    energy += -J * spin * right_neighbor\n                if r  N - 1:\n                    down_neighbor = spins[r + 1, c]\n                    energy += -J * spin * down_neighbor\n    return energy\n\ndef get_neighbor_sum(spins, pos, N, bc):\n    \"\"\"Calculates the sum of spins of the neighbors of a given site.\"\"\"\n    r, c = pos\n    neighbor_sum = 0.0\n    if bc == 'periodic':\n        neighbor_sum += spins[(r - 1) % N, c]\n        neighbor_sum += spins[(r + 1) % N, c]\n        neighbor_sum += spins[r, (c - 1) % N]\n        neighbor_sum += spins[r, (c + 1) % N]\n    elif bc == 'open':\n        if r > 0: neighbor_sum += spins[r - 1, c]\n        if r  N - 1: neighbor_sum += spins[r + 1, c]\n        if c > 0: neighbor_sum += spins[r, c - 1]\n        if c  N - 1: neighbor_sum += spins[r, c + 1]\n    return neighbor_sum\n\ndef run_simulation(params):\n    \"\"\"Runs a single simulated annealing case.\"\"\"\n    N = params['N']\n    J = params['J']\n    bc = params['bc']\n    schedule_type = params['schedule_type']\n    schedule_params = params['schedule_params']\n    K = params['K']\n    sweeps_per_temp = params['sweeps_per_temp']\n\n    # Seed the RNG for reproducibility for each independent run\n    np.random.seed(0)\n\n    # Initialize spin configuration\n    spins = np.random.choice([-1, 1], size=(N, N)).astype(float)\n    \n    if N == 0:\n        return 0.0\n    \n    current_energy = calculate_total_energy(spins, N, J, bc)\n    min_energy = current_energy\n\n    # Generate temperature schedule\n    temps = np.zeros(K)\n    T0 = schedule_params.get('T0')\n    if schedule_type == 'exponential':\n        alpha = schedule_params['alpha']\n        for k in range(K):\n            temps[k] = T0 * (alpha**k)\n    elif schedule_type == 'linear':\n        c = schedule_params['c']\n        for k in range(K):\n            temps[k] = T0 / (1.0 + c * k)\n    elif schedule_type == 'logarithmic':\n        for k in range(K):\n            temps[k] = T0 / np.log(2.0 + k)\n    \n    steps_per_temp = sweeps_per_temp * N**2\n\n    # Simulated Annealing process\n    for k in range(K):\n        T_k = temps[k]\n        if T_k == 0: continue # Avoid division by zero\n        for _ in range(steps_per_temp):\n            # Propose a flip\n            r, c = np.random.randint(N), np.random.randint(N)\n            \n            # Calculate energy change\n            s_ij = spins[r, c]\n            sum_neighbors = get_neighbor_sum(spins, (r, c), N, bc)\n            delta_E = 2.0 * J * s_ij * sum_neighbors\n\n            # Metropolis acceptance criterion\n            if delta_E = 0 or np.random.rand()  np.exp(-delta_E / T_k):\n                spins[r, c] *= -1\n                current_energy += delta_E\n                if current_energy  min_energy:\n                    min_energy = current_energy\n    \n    return min_energy\n\ndef solve():\n    \"\"\"Main solver function to run all test cases and print results.\"\"\"\n    J_val = 1.0\n\n    test_cases = [\n        {'N': 6, 'bc': 'periodic', 'schedule_type': 'exponential', 'schedule_params': {'T0': 4.0, 'alpha': 0.98}, 'K': 500, 'sweeps_per_temp': 1},\n        {'N': 7, 'bc': 'open', 'schedule_type': 'linear', 'schedule_params': {'T0': 5.0, 'c': 0.01}, 'K': 700, 'sweeps_per_temp': 1},\n        {'N': 1, 'bc': 'open', 'schedule_type': 'exponential', 'schedule_params': {'T0': 1.0, 'alpha': 0.5}, 'K': 5, 'sweeps_per_temp': 1},\n        {'N': 3, 'bc': 'periodic', 'schedule_type': 'logarithmic', 'schedule_params': {'T0': 5.0}, 'K': 600, 'sweeps_per_temp': 2},\n    ]\n\n    results = []\n    for case in test_cases:\n        case['J'] = J_val\n        E_gs = calculate_analytical_gs_energy(case['N'], case['J'], case['bc'])\n        E_min = run_simulation(case)\n        D = abs(E_min - E_gs)\n        results.append(D)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2435206"}, {"introduction": "现实世界中的优化问题常常具有“欺骗性”的能量景观，其中充满着能够困住贪心算法的局部最优解。本次练习将使用一个精心设计的二次无约束二元优化 (QUBO) 问题来模拟这一挑战。通过在这个欺骗性景观上测试不同的退火策略，你将亲眼见证为何一个缓慢且审慎的降温过程对于逃离局部陷阱、最终找到全局最优解是至关重要的。[@problem_id:2435212]", "problem": "要求您在一个特意设计的二次无约束二元优化 (QUBO) 问题的欺骗性实例上，实现并分析模拟退火 (SA) 的接受准则方案。您的程序必须是一个完整的、可运行的实现，它能在同一个问题实例上评估多种接受准则方案，并报告成功率。目标是从第一性原理出发，推理为何不同的接受准则方案在局部最优与全局最优分离很远的能量景观上表现不同。\n\n使用的基本原理：\n- Metropolis 接受准则源于统计力学中的玻尔兹曼分布，其中在温度 $T$ 下，能量为 $E(x)$ 的构型 $x$ 出现的概率正比于 $\\exp(-E(x)/T)$。Metropolis 准则以概率 $\\exp(-\\Delta E/T)$ 接受一个能量增加的移动，其中 $\\Delta E$ 是提议状态与当前状态之间的能量差。如果 $\\Delta E \\le 0$，则确定性地接受该移动。\n- 一个满足细致平衡条件并具有遍历性提议核的马尔可夫链，在固定温度 $T$ 下，接受玻尔兹曼分布作为其平稳分布。当 $T$ 足够缓慢地降低时，该链会集中在低能量状态附近。\n- 理论上的对数降温速率在理想化条件下保证了极限情况下的收敛。实用的方案包括几何降温和线性降温，它们在有限的预算下平衡了探索与利用。\n\n问题定义：\n- 考虑一个 QUBO 问题，其二元向量为 $x \\in \\{0,1\\}^n$，对称矩阵为 $Q \\in \\mathbb{R}^{n \\times n}$。能量为 $E(x) = x^\\top Q x$。\n- 使用以下维度为 $n = 16$ 的特定构造：\n  - 令 $c = 1.0$ 且 $w = 0.2$。\n  - 定义 $Q_{ii} = c$，对于所有 $i \\in \\{1,\\dots,n\\}$。\n  - 定义 $Q_{ij} = -\\tfrac{w}{2}$，对于所有 $i \\ne j$。\n  - 这得到 $E(x) = c \\sum_{i=1}^n x_i - w \\sum_{1 \\le i  j \\le n} x_i x_j$，这是一个稠密的、平均场 QUBO，通常是 NP-难 优化的。其能量景观具有欺骗性，因为它包含遥远的吸引盆地：对于给定的参数，$x = \\mathbf{0}$ 在单比特翻转下是一个局部最小值，而 $x = \\mathbf{1}$ 是全局最小值，两者之间的汉明距离为 $n$。\n- 初始化：对于每次独立的 SA 运行，从 $\\{0,1\\}^n$ 中均匀随机地抽取初始状态 $x$。\n- 邻域：在每次迭代中，从 $\\{1,\\dots,n\\}$ 中均匀选择一个比特进行翻转作为提议。\n- 接受准则：使用温度为 $T$ 的 Metropolis 准则：如果 $\\Delta E \\le 0$，则接受；否则以概率 $\\exp(-\\Delta E/T)$ 接受。\n\n需要实现的接受准则方案：\n- 几何（也称指数）方案：$T_k = T_0 \\,\\alpha^k$，其中 $0  \\alpha  1$。\n- 线性方案：$T_k = \\max\\{T_{\\min}, T_0 \\,(1 - k/K)\\}$，其中迭代指数 $k \\in \\{0,\\dots,K-1\\}$，总预算为 $K$。\n- 对数方案：$T_k = \\dfrac{T_0}{\\log(b + k + 1)}$，其中 $\\log$ 表示自然对数。\n\n成功标准：\n- 如果在其 $K$ 次迭代中至少有一次精确地达到了全局最小能量，则该次运行被计为成功。对于此问题实例，在运行 SA 之前，您必须通过对所有 $2^n$ 个二元向量 $x$ 进行穷举来精确计算出真正的全局最小能量。您可以使用任何正确的方法来评估每个 $x$ 的 $E(x)$；例如，直接计算 $E(x) = x^\\top Q x$。\n\n测试套件：\n实现以下四个测试用例。在每个用例中，使用列出的方案和参数运行 $R$ 次独立的 SA，并使用指定的伪随机种子初始化随机数生成器。此问题不涉及角度；没有物理单位。为每个用例报告成功运行的比例，以小数形式表示。\n\n- 案例 1 (几何降温，足够慢):\n  - 方案：几何降温，$T_0 = 2.0$，$\\alpha = 0.995$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$123$。\n- 案例 2 (线性降温，过快):\n  - 方案：线性降温，$T_0 = 2.0$，$T_{\\min} = 0.001$。\n  - 迭代次数：$K = 1500$。\n  - 运行次数：$R = 64$。\n  - 种子：$456$。\n- 案例 3 (对数降温，非常慢):\n  - 方案：对数降温，$T_0 = 4.0$，$b = 2.0$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$789$。\n- 案例 4 (几何降温，冷启动):\n  - 方案：几何降温，$T_0 = 0.05$，$\\alpha = 0.99$。\n  - 迭代次数：$K = 6000$。\n  - 运行次数：$R = 64$。\n  - 种子：$13579$。\n\n所需输出：\n- 对于每个用例，计算至少有一次精确达到全局最小能量的运行比例（一个在 $[0,1]$ 区间内的实数）。\n- 您的程序应生成单行输出，其中包含四个结果，以逗号分隔的列表形式并用方括号括起来，每个比例值四舍五入到小数点后三位，顺序为案例 $1,2,3,4$（例如，$\\texttt{[0.734,0.000,0.578,0.016]}$）。\n\n实现约束：\n- 严格按照所述使用 Metropolis 接受准则。\n- 严格按照所述使用邻域和初始化方法。\n- 通过为每个测试用例的伪随机数生成器设置指定的种子来确保可复现性；运行之间的内部分配由您决定，但必须是确定性的。\n- 您的解决方案必须是自包含的，并且不需要任何输入。它必须能在典型的现代计算机上在合理的时间内运行。", "solution": "所呈现的问题陈述经过了严格验证，并被认定是有效的。它在科学上基于统计力学和计算优化的原理，特别是关于使用模拟退火 (SA) 元启发式算法解决二次无约束二元优化 (QUBO) 问题。该问题是良构的，所有参数、约束和目标都得到了清晰、客观的定义。它是一个自包含且数值上可行的任务。因此，将提供一个合理的解决方案。\n\n目标是在一个特意构造的欺骗性 QUBO 问题实例上，实现并分析三种不同的模拟退火降温方案——几何、线性和对数——的性能。其目的是从第一性原理出发，理解方案的选择如何影响算法在具有远离全局最小值的显著局部最小值的能量景观上定位全局最优解的能力。\n\n首先，我们对能量景观进行形式化。问题定义在维度为 $n=16$ 的二元向量 $x \\in \\{0, 1\\}^n$ 上。能量函数由 $E(x) = x^\\top Q x$ 给出，其中 $Q$ 是一个对称的 $n \\times n$ 矩阵。矩阵 $Q$ 的构造方式为：对角元素 $Q_{ii} = c = 1.0$，非对角元素 $Q_{ij} = -w/2 = -0.1$ (对于 $i \\neq j$)。对于满足 $x_i^2 = x_i$ 的二元变量，能量函数可以写为：\n$$\nE(x) = \\sum_{i=1}^n \\sum_{j=1}^n Q_{ij} x_i x_j = \\sum_{i=1}^n Q_{ii} x_i^2 + \\sum_{i \\neq j} Q_{ij} x_i x_j = c \\sum_{i=1}^n x_i - \\frac{w}{2} \\sum_{i \\neq j} x_i x_j\n$$\n考虑到求和的对称性，$\\sum_{i \\neq j} x_i x_j = 2 \\sum_{1 \\le i  j \\le n} x_i x_j$，这等价于所提供的表达式：\n$$\nE(x) = c \\sum_{i=1}^n x_i - w \\sum_{1 \\le i  j \\le n} x_i x_j\n$$\n状态 $x$ 的能量仅取决于非零元素的数量，我们称之为汉明权重 $k = \\sum_{i=1}^n x_i$。满足 $i  j$ 且 $x_i=1$ 和 $x_j=1$ 的数对 $(i, j)$ 的数量为 $\\binom{k}{2}$。因此，能量是 $k$ 的函数：\n$$\nE(k) = c k - w \\frac{k(k-1)}{2}\n$$\n代入给定的参数 $n=16$、$c=1.0$ 和 $w=0.2$，我们得到：\n$$\nE(k) = 1.0 \\cdot k - 0.2 \\frac{k(k-1)}{2} = k - 0.1(k^2 - k) = -0.1 k^2 + 1.1 k\n$$\n这是一个关于 $k$ 的开口向下的抛物线。为了找到整数 $k \\in [0, 16]$ 的最小能量，我们计算函数在其边界处的值。\n对于 $k=0$（状态 $x=\\mathbf{0}$），能量为 $E(0) = 0$。\n对于 $k=16$（状态 $x=\\mathbf{1}$），能量为 $E(16) = -0.1(16^2) + 1.1(16) = -25.6 + 17.6 = -8.0$。\n问题陈述指出，$x=\\mathbf{0}$ 在单比特翻转下是一个局部最小值。我们来验证这一点。从 $x=\\mathbf{0}$ 翻转一个比特对应于从 $k=0$ 变为 $k=1$。能量变为 $E(1) = -0.1(1)^2 + 1.1(1) = 1.0$。由于 $E(1) > E(0)$，任何从 $x=\\mathbf{0}$ 出发的单比特翻转都会增加能量，这证实了它是一个局部最小值。分析证实，状态 $x=\\mathbf{1}$ 是全局最小值，能量为 $E_{min} = -8.0$，而 $x=\\mathbf{0}$ 是一个局部最小值，能量为 $E=0$。这两个状态被最大可能的汉明距离 $n=16$ 分隔，形成了一个对局部搜索算法具有挑战性的“欺骗性”景观。需要对所有 $2^{16}$ 个状态进行穷举搜索，以严格确认此全局最小值，这将在实现中完成。\n\n模拟退火算法的流程如下。从一个随机初始状态 $x$ 和一个初始温度 $T_0$ 开始，它通过翻转一个随机选择的比特来迭代地提议一个新状态 $x'$。计算能量变化 $\\Delta E = E(x') - E(x)$。如果 $\\Delta E \\le 0$，则接受该移动。如果 $\\Delta E > 0$，则根据 Metropolis 准则以概率 $P(\\text{接受}) = \\exp(-\\Delta E / T_k)$ 接受该移动，其中 $T_k$ 是第 $k$ 次迭代的温度。温度根据降温方案逐渐降低。高效地计算 $\\Delta E$ 至关重要。如果比特 $j$ 从其当前状态 $x_j$ 翻转到 $1-x_j$，能量的变化是：\n$$\n\\Delta E = ( (1-x_j) - x_j ) \\left[ c - w \\sum_{i \\neq j} x_i \\right]\n$$\n这种 $O(n)$ 的计算避免了完全重新计算能量所需的 $O(n^2)$ 复杂度。\n\n我们现在基于这些原理分析四个指定的测试用例。\n案例 1：几何降温 ($T_0=2.0, \\alpha=0.995, K=6000, R=64$)。初始温度 $T_0=2.0$ 足够高，允许跨越能垒；例如，一个 $\\Delta E=1.0$ 的移动被接受的概率约为 $\\exp(-1.0/2.0) \\approx 0.61$。降温因子 $\\alpha=0.995$ 接近 1，导致温度缓慢指数衰减。迭代次数 $K=6000$ 很大。这种组合在高温下提供了较长的探索阶段以逃离初始的局部最小值，随后随着温度下降进入逐渐的利用阶段，从而允许向全局最小值收敛。预计此方案将是有效的，并产生高成功率。\n\n案例 2：线性降温 ($T_0=2.0, T_{min}=0.001, K=1500, R=64$)。初始温度与案例 1 相同，但迭代预算 $K=1500$ 要小得多，并且温度线性下降。这种降温是迅速的，一种常被称为“淬火”的方案。系统会迅速失去克服巨大能量壁垒所需的热能。搜索很有可能会陷入其遇到的第一个局部最小值的吸引盆地中，这取决于随机的初始状态。鉴于其欺骗性的景观，找到遥远的全局最小值的概率非常低。预计此方案表现会很差。\n\n案例 3：对数降温 ($T_0=4.0, b=2.0, K=6000, R=64$)。此方案 $T_k = T_0 / \\log(b+k+1)$ 已知在无限次迭代（$K \\to \\infty$）的极限下保证收敛到全局最优解。然而，在有限次运行中，其行为取决于它的降温速度。降温过程异常缓慢。初始温度为 $T_0' = 4.0/\\log(3) \\approx 3.64$。在最后一次迭代 $k=5999$ 时，温度为 $T_{5999} = 4.0/\\log(6002) \\approx 0.46$。在整个过程中，温度都保持在较高水平。虽然这允许对状态空间进行广泛的探索，但它阻碍了利用。系统可能会找到全局最小值的吸引盆地，但也可能有足够的热能逃离它。此方案可能比快速线性淬火更成功，但可能不如调优良好的几何方案，因为它未能充分冷却以实现最终收敛。\n\n案例 4：几何降温冷启动 ($T_0=0.05, \\alpha=0.99, K=6000, R=64$)。在这里，初始温度 $T_0=0.05$ 极低。接受即使是小的能量增加移动的概率也可以忽略不计。对于 $\\Delta E = 1.0$（逃离 $x=\\mathbf{0}$ 最小值的能垒），接受概率为 $\\exp(-1.0/0.05) = \\exp(-20) \\approx 2 \\times 10^{-9}$。该算法的行为将几乎与贪婪局部搜索相同，从其随机起点下降到最近的局部最小值并被永久地困住。它几乎没有能力探索景观和克服能垒来找到全局最小值。预计该方案的成功率接近于零。\n\n实现将执行这四个测试用例，为每个用例计算成功运行的次数，并报告成功比例，这应该会验证这一理论分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Simulated Annealing (SA) acceptance schedules\n    on a deceptive QUBO problem instance.\n    \"\"\"\n    n = 16\n    c = 1.0\n    w = 0.2\n\n    # Construct the Q matrix for E(x) = x^T Q x\n    Q = np.full((n, n), -w / 2.0)\n    np.fill_diagonal(Q, c)\n\n    def calculate_energy(x, Q_mat):\n        # Using the sum form is faster than matrix multiplication for sparse vectors,\n        # but x.T @ Q_mat @ x is fine for dense numpy arrays.\n        return x.T @ Q_mat @ x\n\n    # Exhaustive search for the global minimum energy\n    # This is feasible for n=16 (2^16 = 65536 states)\n    global_min_energy = float('inf')\n    num_states = 1  n\n    for i in range(num_states):\n        # Create binary vector x from integer i\n        x = np.array([int(b) for b in bin(i)[2:].zfill(n)])\n        energy = calculate_energy(x, Q)\n        if energy  global_min_energy:\n            global_min_energy = energy\n\n    test_cases = [\n        {\n            \"name\": \"Case 1\", \"schedule\": \"geometric\", \"T0\": 2.0, \"alpha\": 0.995,\n            \"K\": 6000, \"R\": 64, \"seed\": 123, \"Tmin\": None, \"b\": None\n        },\n        {\n            \"name\": \"Case 2\", \"schedule\": \"linear\", \"T0\": 2.0, \"Tmin\": 0.001,\n            \"K\": 1500, \"R\": 64, \"seed\": 456, \"alpha\": None, \"b\": None\n        },\n        {\n            \"name\": \"Case 3\", \"schedule\": \"logarithmic\", \"T0\": 4.0, \"b\": 2.0,\n            \"K\": 6000, \"R\": 64, \"seed\": 789, \"alpha\": None, \"Tmin\": None\n        },\n        {\n            \"name\": \"Case 4\", \"schedule\": \"geometric\", \"T0\": 0.05, \"alpha\": 0.99,\n            \"K\": 6000, \"R\": 64, \"seed\": 13579, \"Tmin\": None, \"b\": None\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        np.random.seed(case[\"seed\"])\n        success_count = 0\n        \n        K = case[\"K\"]\n        R = case[\"R\"]\n        T0 = case[\"T0\"]\n        \n        for r in range(R):\n            # Initialization\n            x_current = np.random.randint(0, 2, size=n)\n            e_current = calculate_energy(x_current, Q)\n            \n            found_global_min = np.isclose(e_current, global_min_energy)\n            \n            T = T0\n            \n            for k in range(K):\n                # Propose new state by flipping one bit\n                bit_to_flip = np.random.randint(0, n)\n                \n                # Efficiently calculate energy difference (Delta E)\n                x_val = x_current[bit_to_flip]\n                # sum_neighbors is sum of x_i where i is not bit_to_flip\n                sum_neighbors = np.sum(x_current) - x_val\n                delta_e = (1 - 2 * x_val) * (c - w * sum_neighbors)\n\n                # Metropolis acceptance criterion\n                if delta_e = 0 or np.random.rand()  np.exp(-delta_e / T):\n                    x_current[bit_to_flip] = 1 - x_current[bit_to_flip]\n                    e_current += delta_e\n\n                if not found_global_min and np.isclose(e_current, global_min_energy):\n                    found_global_min = True\n                \n                # Update temperature based on schedule\n                if case[\"schedule\"] == \"geometric\":\n                    T = T0 * (case[\"alpha\"] ** (k + 1))\n                elif case[\"schedule\"] == \"linear\":\n                    T = max(case[\"Tmin\"], T0 * (1 - (k + 1) / K))\n                elif case[\"schedule\"] == \"logarithmic\":\n                    T = T0 / np.log(case[\"b\"] + k + 1 + 1) # k+2 for k=0..K-1\n            \n            if found_global_min:\n                success_count += 1\n                \n        success_rate = success_count / R\n        results.append(f\"{success_rate:.3f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2435212"}, {"introduction": "既然我们已经认识到冷却策略的关键作用，下一个自然而然的问题就是：如何为特定问题选择最佳的策略？这个高级练习将你引入元优化 (meta-optimization) 的概念，即对优化算法本身进行优化。你不再将冷却策略的参数视为给定的输入，而是将其作为待优化的变量，通过系统性的搜索来寻找能够在一个标准测试函数上达到最佳性能的退火方案。[@problem_id:2435176]", "problem": "给定一个用于最小化二维多峰目标的模拟退火程序。该算法使用源自 Boltzmann 分布的 Metropolis 接受准则，温度由参数化冷却方案控制。您的任务是将冷却方案本身作为优化对象。具体来说，考虑一个双参数指数冷却方案 $T(k) = p_1 \\exp(-p_2 k)$，其中 $p_1 \\in \\mathbb{R}_{>0}$ 且 $p_2 \\in \\mathbb{R}_{\\ge 0}$，并确定 $p_1$ 和 $p_2$ 的值，以在固定的计算预算下，最小化模拟退火在固定测试目标上运行的平均终端性能。测试目标是二维 Rastrigin 函数，定义为\n$$\nf(\\mathbf{x}) = A n + \\sum_{i=1}^{n} \\left(x_i^2 - A \\cos(2 \\pi x_i)\\right),\n$$\n其中 $n=2$，$A=10$，且余弦函数以弧度为单位。搜索域为盒子 $\\left[-5.12, 5.12\\right]^2$。\n\n模拟退火程序遵循以下基本组成部分：\n- 初始化：从 $\\left[-5.12, 5.12\\right]^2$ 中均匀抽取 $\\mathbf{x}_0$。\n- 第 $k$ 步的提议：提议 $\\mathbf{x}' = \\mathbf{x} + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$，然后如果 $\\mathbf{x}'$ 的任何分量超出域，则将其限制回 $\\left[-5.12, 5.12\\right]$ 内。\n- 接受：令 $\\Delta = f(\\mathbf{x}') - f(\\mathbf{x})$。如果 $\\Delta \\le 0$，则接受 $\\mathbf{x}'$。否则，以概率 $\\exp(-\\Delta/T(k))$ 接受，其中 $T(k) = p_1 \\exp(-p_2 k)$。\n- 迄今最优追踪：维持 $f^\\star_k = \\min\\{f(\\mathbf{x}_0), f(\\mathbf{x}_1), \\dots, f(\\mathbf{x}_k)\\}$，并在长度为 $N$ 次提议的运行结束时报告 $f^\\star_{N}$。\n\n为评估一个方案 $(p_1,p_2)$，将性能泛函定义为在固定的随机种子列表上，终端迄今最优目标值的样本均值：\n$$\nJ(p_1,p_2) = \\frac{1}{S} \\sum_{s \\in \\mathcal{S}} f^\\star_{N}(s; p_1,p_2),\n$$\n其中 $\\mathcal{S}$ 是给定的种子集合，$S = |\\mathcal{S}|$。对于每个种子 $s \\in \\mathcal{S}$，使用 $s$ 初始化一个可复现的独立随机数生成器，以驱动初始点以及所有后续的高斯和均匀抽样。您的程序必须在指定的有限网格 $\\mathcal{P}_1 \\times \\mathcal{P}_2$ 上搜索，并返回使 $J(p_1,p_2)$ 最小化的对 $(p_1,p_2) \\in \\mathcal{P}_1 \\times \\mathcal{P}_2$。如果 $J$ 值出现平局，选择 $p_1$ 最小的对；如果仍然平局，选择 $p_2$ 最小的对。\n\n角度单位：所有三角函数均使用弧度。\n\n为保证数值稳定性和确定性：\n- 每次评估均使用指定的独立种子，不使用其他随机源。\n- 指数函数应照常使用浮点算术进行评估；接受概率为 $\\min\\{1, \\exp(-\\Delta/T(k))\\}$。\n\n您的任务是实现一个程序，对下面的每个测试用例，在 $(p_1,p_2)$ 上执行穷举网格搜索，并输出最优的 $p_1$、$p_2$ 以及 $J(p_1,p_2)$ 的最小值，每个值都四舍五入到 $6$ 位小数。\n\n测试套件（每个测试用例定义了 $(N, \\sigma, \\mathcal{S}, \\mathcal{P}_1, \\mathcal{P}_2)$）：\n- 用例 1（一般情况）：\n  - $N = 500$\n  - $\\sigma = 0.5$\n  - $\\mathcal{S} = [7, 11, 19]$\n  - $\\mathcal{P}_1 = [0.5, 1.0, 2.0, 5.0]$\n  - $\\mathcal{P}_2 = [0.001, 0.01, 0.05]$\n- 用例 2（边界包含恒定温度）：\n  - $N = 300$\n  - $\\sigma = 0.3$\n  - $\\mathcal{S} = [101, 202, 303]$\n  - $\\mathcal{P}_1 = [0.2, 0.8, 1.5, 3.0]$\n  - $\\mathcal{P}_2 = [0.0, 0.02, 0.1]$\n- 用例 3（更长的运行和更大的提议）：\n  - $N = 1000$\n  - $\\sigma = 0.8$\n  - $\\mathcal{S} = [5, 6]$\n  - $\\mathcal{P}_1 = [1.0, 3.0, 6.0]$\n  - $\\mathcal{P}_2 = [0.001, 0.005, 0.02]$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。按数字顺序连接各用例的三元组。对于每个用例，附加 $p_1^\\star$、$p_2^\\star$ 和 $J^\\star$（最小化的平均终端最优值），每个值都四舍五入到 $6$ 位小数。例如，最终输出应如下所示：\n$[p_{1,1}^\\star,p_{2,1}^\\star,J_1^\\star,p_{1,2}^\\star,p_{2,2}^\\star,J_2^\\star,p_{1,3}^\\star,p_{2,3}^\\star,J_3^\\star]$,\n不含任何附加文本。", "solution": "所呈现的问题是一项元优化任务，具体来说是模拟退火算法的超参数调优。目标是确定指数冷却方案 $T(k) = p_1 \\exp(-p_2 k)$ 的最优参数 $(p_1, p_2)$，以在优化二维 Rastrigin 函数时最小化平均终端性能。对这些最优参数的搜索被限制在所提供的有限集合 $\\mathcal{P}_1$ 和 $\\mathcal{P}_2$ 上的穷举网格搜索。\n\n解决方案的核心是实现一个确定性过程，用于为任何给定的方案参数对评估性能泛函 $J(p_1,p_2)$。该泛函被定义为从一组独立的模拟退火运行中获得的最佳目标值 $f^\\star_N$ 的样本均值，每次运行由给定集合 $\\mathcal{S}$ 中的唯一随机种子区分。\n$$\nJ(p_1,p_2) = \\frac{1}{S} \\sum_{s \\in \\mathcal{S}} f^\\star_{N}(s; p_1,p_2)\n$$\n其中 $S = |\\mathcal{S}|$ 是运行次数。使用固定种子确保了 $J(p_1,p_2)$ 的评估是完全确定性和可复现的。\n\n计算 $f^\\star_N(s; p_1,p_2)$ 的每个独立模拟退火运行的结构如下：\n\n1. **初始化**：使用特定值 $s \\in \\mathcal{S}$ 为随机数生成器设定种子。初始状态 $\\mathbf{x}_0 \\in \\mathbb{R}^2$ 从域 $[-5.12, 5.12]^2$ 上的均匀分布中抽取。在 $\\mathbf{x}_0$ 处评估目标函数，即 $A=10$ 的二维 Rastrigin 函数，\n$$\nf(\\mathbf{x}) = 20 + \\sum_{i=1}^{2} \\left(x_i^2 - 10 \\cos(2 \\pi x_i)\\right)\n$$\n这个初始值 $f(\\mathbf{x}_0)$ 也用于初始化迄今最优值 $f^\\star_0$。\n\n2. **迭代搜索**：算法进行固定步数 $N$。对于从 $0$ 到 $N-1$ 的每一步 $k$：\n    a. 根据冷却方案计算温度 $T(k)$：$T(k) = p_1 \\exp(-p_2 k)$。\n    b. 通过用各向同性高斯噪声扰动当前状态 $\\mathbf{x}_k$ 来生成候选状态 $\\mathbf{x}'$：$\\mathbf{x}' = \\mathbf{x}_k + \\boldsymbol{\\eta}$，其中 $\\boldsymbol{\\eta} \\sim \\mathcal{N}(\\mathbf{0}, \\sigma^2 \\mathbf{I})$。$\\mathbf{x}'$ 的任何落在域 $[-5.12, 5.12]$ 之外的分量都将被限制到相应的边界值。\n    c. 应用 Metropolis 接受准则。我们计算目标函数的变化量 $\\Delta = f(\\mathbf{x}') - f(\\mathbf{x}_k)$。如果 $\\Delta \\le 0$，则无条件接受候选状态 ($\\mathbf{x}_{k+1} = \\mathbf{x}'$)。如果 $\\Delta > 0$，则以概率 $P_{\\text{accept}} = \\exp(-\\Delta / T(k))$ 接受它。如果未被接受，状态保持不变 ($\\mathbf{x}_{k+1} = \\mathbf{x}_k$)。这是通过抽取一个随机数 $u \\sim \\mathcal{U}(0,1)$ 并在 $u  P_{\\text{accept}}$ 时接受来实现的。\n    d. 更新迄今为止所见最优目标函数值的记录：$f^\\star_{k+1} = \\min(f^\\star_k, f(\\mathbf{x}_{k+1}))$。\n\n3. **终止**：经过 $N$ 步后，返回最终的迄今最优值 $f^\\star_N$。\n\n程序的最外层在指定的参数网格上执行此评估。对于每个测试用例，它遍历所有对 $(p_1, p_2) \\in \\mathcal{P}_1 \\times \\mathcal{P}_2$。它为每对计算 $J(p_1, p_2)$ 并跟踪使该值最小化的对 $(p_1^\\star, p_2^\\star)$。为确保唯一确定的最优解，问题指定了平局打破规则：如果两对产生相同的最小 $J$ 值，则选择 $p_1$ 较小的一对。如果 $p_1$ 也相同，则选择 $p_2$ 较小的一对。\n\n最终程序为三个测试用例中的每一个实现了这一完整逻辑，收集每个用例的最优三元组 $(p_1^\\star, p_2^\\star, J^\\star)$。然后将这些结果格式化并打印为单个逗号分隔的列表。数值计算使用 `numpy` 库执行，并遵循指定的依赖关系。", "answer": "```python\nimport numpy as np\n\n# Define problem constants\nA = 10.0\nN_DIMS = 2\nDOMAIN_MIN = -5.12\nDOMAIN_MAX = 5.12\n\ndef rastrigin(x: np.ndarray) -> float:\n    \"\"\"\n    Computes the Rastrigin function for a 2D vector.\n    f(x) = An + sum(xi^2 - A*cos(2*pi*xi))\n    \"\"\"\n    if x.shape != (N_DIMS,):\n        raise ValueError(\"Input must be a 2D vector.\")\n    \n    constant_term = A * N_DIMS\n    sum_term = np.sum(x**2 - A * np.cos(2 * np.pi * x))\n    return constant_term + sum_term\n\ndef run_simulated_annealing(N: int, sigma: float, p1: float, p2: float, seed: int) -> float:\n    \"\"\"\n    Performs one full run of the simulated annealing algorithm.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # Initialization\n    x_current = rng.uniform(DOMAIN_MIN, DOMAIN_MAX, size=N_DIMS)\n    f_current = rastrigin(x_current)\n    best_f_so_far = f_current\n\n    # Simulation loop\n    for k in range(N):\n        # Calculate temperature for step k\n        T_k = p1 * np.exp(-p2 * k)\n\n        # Generate proposal state\n        eta = rng.normal(loc=0.0, scale=sigma, size=N_DIMS)\n        x_proposal = x_current + eta\n        # Clamp proposal to the domain\n        x_proposal = np.clip(x_proposal, DOMAIN_MIN, DOMAIN_MAX)\n\n        f_proposal = rastrigin(x_proposal)\n        delta_f = f_proposal - f_current\n\n        # Metropolis acceptance criterion\n        accepted = False\n        if delta_f = 0:\n            accepted = True\n        else:\n            # Avoid division by zero, although p1>0 and exp() is always >0\n            if T_k > 1e-12:\n                prob_acceptance = np.exp(-delta_f / T_k)\n                if rng.random()  prob_acceptance:\n                    accepted = True\n\n        if accepted:\n            x_current = x_proposal\n            f_current = f_proposal\n\n        # Update the best-so-far objective value found\n        if f_current  best_f_so_far:\n            best_f_so_far = f_current\n            \n    return best_f_so_far\n\ndef evaluate_schedule(N: int, sigma: float, seeds: list[int], p1: float, p2: float) -> float:\n    \"\"\"\n    Evaluates the performance functional J(p1, p2) by averaging over runs.\n    \"\"\"\n    total_f_star = 0.0\n    for seed in seeds:\n        f_star_N = run_simulated_annealing(N, sigma, p1, p2, seed)\n        total_f_star += f_star_N\n    return total_f_star / len(seeds)\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"N\": 500, \"sigma\": 0.5, \"S\": [7, 11, 19],\n            \"P1\": [0.5, 1.0, 2.0, 5.0], \"P2\": [0.001, 0.01, 0.05]\n        },\n        # Case 2\n        {\n            \"N\": 300, \"sigma\": 0.3, \"S\": [101, 202, 303],\n            \"P1\": [0.2, 0.8, 1.5, 3.0], \"P2\": [0.0, 0.02, 0.1]\n        },\n        # Case 3\n        {\n            \"N\": 1000, \"sigma\": 0.8, \"S\": [5, 6],\n            \"P1\": [1.0, 3.0, 6.0], \"P2\": [0.001, 0.005, 0.02]\n        }\n    ]\n\n    final_results = []\n    \n    for case in test_cases:\n        N, sigma, S_seeds, P1_grid, P2_grid = case[\"N\"], case[\"sigma\"], case[\"S\"], case[\"P1\"], case[\"P2\"]\n        \n        best_p1 = -1.0\n        best_p2 = -1.0\n        min_J = float('inf')\n\n        # Grid search over p1 and p2\n        for p1 in P1_grid:\n            for p2 in P2_grid:\n                current_J = evaluate_schedule(N, sigma, S_seeds, p1, p2)\n\n                # Check for new minimum, applying tie-breaking rules\n                is_better = False\n                if current_J  min_J:\n                    is_better = True\n                elif np.isclose(current_J, min_J):\n                    if p1  best_p1:\n                        is_better = True\n                    elif np.isclose(p1, best_p1) and p2  best_p2:\n                        is_better = True\n                \n                if is_better:\n                    min_J = current_J\n                    best_p1 = p1\n                    best_p2 = p2\n        \n        # Append results for the current case\n        final_results.extend([best_p1, best_p2, min_J])\n\n    # Format the final output string\n    # A small adjustment in tie-breaking logic due to floating point comparisons\n    # The logic used in loop is correct, but let's re-state it:\n    # A new result is better if it's strictly smaller, OR if it's almost equal and tie-breaking rules apply.\n    # The code implements this logic correctly.\n    # The use of np.isclose in final check is for robustness in case of float issues.\n    \n    formatted_results = [f\"{val:.6f}\" for val in final_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "2435176"}]}