{"hands_on_practices": [{"introduction": "多面体的几何性质可以通过线性规划（Linear Programming, LP）的语言来精确描述和优化。本练习旨在通过一个直观的几何问题——在一个由线性不等式定义的多边形内部寻找最大内切球（即切比雪夫中心）——来训练你的建模能力。通过将几何距离约束转化为一系列线性约束，你将掌握把复杂的空间问题转化为标准线性规划问题的核心技巧，这在机器人路径规划和工程设计等领域中至关重要。[@problem_id:2410361]", "problem": "考虑由以下线性不等式组定义的多面体 $P \\subset \\mathbb{R}^{2}$\n$$\n-x \\leq 0,\\quad -y \\leq 0,\\quad x \\leq 4,\\quad y \\leq 3,\\quad x + y \\leq 5.\n$$\n在 $\\mathbb{R}^{2}$ 中，一个以 $c \\in \\mathbb{R}^{2}$ 为球心、半径为 $r \\geq 0$ 的欧几里得球是集合 $B(c,r) = \\{ z \\in \\mathbb{R}^{2} : \\| z - c \\|_{2} \\leq r \\}$。确定完全包含在 $P$ 中的任意欧几里得球的最大半径 $r^{\\star}$。将你的最终答案表示为一个单一的精确解析表达式（不得四舍五入）。", "solution": "该问题旨在找到一个完全包含在多面体 $P$ 内的欧几里得球的最大半径。这个问题可以被构建为一个线性规划（LP）问题。设球心为 $c = (c_x, c_y)$，半径为 $r$。我们的目标是最大化 $r$。\n\n球 $B(c,r)$ 被包含在多面体 $P$ 中的条件是，球心 $c$ 到定义 $P$ 的每个边界超平面（在此二维情况下为直线）的距离至少为 $r$。\n\n多面体 $P$ 由以下五个不等式定义：\n1.  $x \\ge 0$\n2.  $y \\ge 0$\n3.  $x \\le 4$\n4.  $y \\le 3$\n5.  $x + y \\le 5$\n\n我们将这些几何约束转化为关于球心 $(c_x, c_y)$ 和半径 $r$ 的线性约束：\n1.  点 $(c_x, c_y)$ 到直线 $x=0$ 的距离为 $c_x$。约束为 $c_x \\ge r$。\n2.  点 $(c_x, c_y)$ 到直线 $y=0$ 的距离为 $c_y$。约束为 $c_y \\ge r$。\n3.  点 $(c_x, c_y)$ 到直线 $x=4$ 的距离为 $4 - c_x$。约束为 $4 - c_x \\ge r \\implies c_x + r \\le 4$。\n4.  点 $(c_x, c_y)$ 到直线 $y=3$ 的距离为 $3 - c_y$。约束为 $c_y + r \\le 3$。\n5.  点 $(c_x, c_y)$ 到直线 $x+y-5=0$ 的距离为 $\\frac{|c_x + c_y - 5|}{\\sqrt{1^2+1^2}}$。由于球心必须在多面体内，我们知道 $c_x + c_y - 5 \\le 0$，所以距离为 $\\frac{5 - c_x - c_y}{\\sqrt{2}}$。约束为 $\\frac{5 - c_x - c_y}{\\sqrt{2}} \\ge r \\implies c_x + c_y + \\sqrt{2}r \\le 5$。\n\n因此，该问题可以被构建为以下线性规划：\n$$\n\\begin{aligned}\n\\text{最大化} \\quad & r \\\\\n\\text{约束于} \\quad & c_x - r \\ge 0 \\\\\n& c_y - r \\ge 0 \\\\\n& c_x + r \\le 4 \\\\\n& c_y + r \\le 3 \\\\\n& c_x + c_y + \\sqrt{2}r \\le 5 \\\\\n& r \\ge 0\n\\end{aligned}\n$$\n在最优解处，球通常会同时接触多个边界。一个合理的猜测是，最大内切球的球心将等距于某些定义 $P$ 的“最紧”的边界。让我们假设球心等距于三个边界：$x=0$，$y=0$ 和 $x+y=5$。这三个等距条件意味着：\n1.  $c_x = r$\n2.  $c_y = r$\n3.  $\\frac{5 - c_x - c_y}{\\sqrt{2}} = r$\n\n将前两个等式代入第三个，我们得到：\n$$ \\frac{5 - r - r}{\\sqrt{2}} = r \\implies 5 - 2r = \\sqrt{2}r $$\n求解 $r$：\n$$ 5 = (2+\\sqrt{2})r \\implies r = \\frac{5}{2+\\sqrt{2}} $$\n为了简化分母，我们乘以共轭项 $(2-\\sqrt{2})$：\n$$ r = \\frac{5(2-\\sqrt{2})}{(2+\\sqrt{2})(2-\\sqrt{2})} = \\frac{5(2-\\sqrt{2})}{4-2} = \\frac{5(2-\\sqrt{2})}{2} $$\n现在我们必须验证这个解 $(r, c_x, c_y) = (\\frac{5(2-\\sqrt{2})}{2}, \\frac{5(2-\\sqrt{2})}{2}, \\frac{5(2-\\sqrt{2})}{2})$ 是否满足所有 LP 约束。\n$r \\approx \\frac{5(2-1.414)}{2} \\approx 1.465$。所以 $c_x = c_y \\approx 1.465$。\n- $c_x - r \\ge 0 \\implies r - r = 0 \\ge 0$ (满足)\n- $c_y - r \\ge 0 \\implies r - r = 0 \\ge 0$ (满足)\n- $c_x + r \\le 4 \\implies 2r \\le 4 \\implies r \\le 2$。因为 $1.465  2$，所以满足。\n- $c_y + r \\le 3 \\implies 2r \\le 3 \\implies r \\le 1.5$。因为 $1.465  1.5$，所以满足。\n- $c_x + c_y + \\sqrt{2}r \\le 5 \\implies r + r + \\sqrt{2}r = (2+\\sqrt{2})r = 5$ (满足)\n\n所有约束都满足，因此该解是可行的。这表明我们找到的最优半径 $r^{\\star}$ 是正确的。", "answer": "$$\\boxed{\\frac{5(2-\\sqrt{2})}{2}}$$", "id": "2410361"}, {"introduction": "网络流问题是组合优化中的一个基石，在物流、通信和电路设计等领域有广泛应用。这个实践练习将引导你为最大流问题建立线性规划（LP）模型，并推导其对偶问题，从而揭示优美而深刻的最大流最小割定理。通过这个过程，你将体会到对偶理论的强大之处：对偶变量并非抽象的数学构造，而是对原问题（在此例中为网络分割）有着明确的物理解释。[@problem_id:2410395]", "problem": "考虑一个有向网络（图），其节点集为 $V=\\{v_1,v_2,v_3,v_4,v_5,v_6\\}$，源点为 $s=v_1$，汇点为 $t=v_6$。每条有向弧 $(i,j)$ 都有一个非负容量 $c_{ij}$。非零容量如下：\n- $v_1 \\to v_2$ 的容量为 $c_{12}=7$， $v_1 \\to v_3$ 的容量为 $c_{13}=3$， $v_1 \\to v_4$ 的容量为 $c_{14}=4$。\n- $v_2 \\to v_3$ 的容量为 $c_{23}=2$， $v_2 \\to v_4$ 的容量为 $c_{24}=3$， $v_2 \\to v_5$ 的容量为 $c_{25}=5$。\n- $v_3 \\to v_4$ 的容量为 $c_{34}=4$， $v_3 \\to v_5$ 的容量为 $c_{35}=6$， $v_3 \\to v_6$ 的容量为 $c_{36}=2$。\n- $v_4 \\to v_5$ 的容量为 $c_{45}=2$， $v_4 \\to v_6$ 的容量为 $c_{46}=5$。\n- $v_5 \\to v_6$ 的容量为 $c_{56}=8$。\n\n在有向网络上使用流和割的第一性原理定义，在线性规划（LP）的框架内完成以下任务：\n1) 通过指定决策变量、目标函数和所有约束，为该网络构建最大 s-t 流的LP模型。\n2) 推导您最大流公式的LP对偶，并根据最小 s-t 割的LP对其进行解释，明确对偶变量与割结构之间的对应关系。\n3) 确定该网络的最小 s-t 割的容量。\n\n答案要求：仅报告最小 s-t 割的容量，形式为单个实数。无需四舍五入，不涉及单位。", "solution": "该问题需要对给定的有向网络进行三部分分析：将最大流问题构建为线性规划（LP），推导并解释其对偶问题，以及确定最小割的容量。\n\n设节点集为 $V = \\{1, 2, 3, 4, 5, 6\\}$，源点 $s=1$，汇点 $t=6$。有向弧的集合记为 $E$。对于每条弧 $(i,j) \\in E$，都有一个给定的容量 $c_{ij} \\ge 0$。\n\n**1. 最大 s-t 流的LP构建**\n\n决策变量：令 $x_{ij}$ 表示弧 $(i,j) \\in E$ 上的流量。\n目标函数：目标是最大化从源点 $s$ 流出的总流量，或者等价地，流入汇点 $t$ 的总流量。我们引入一个变量 $F$ 代表总流量值。\n$$ \\text{最大化 } F $$\n约束：\n- **容量约束**：任何弧 $(i,j)$ 上的流量不能超过其容量。\n  $$ 0 \\le x_{ij} \\le c_{ij} \\quad \\forall (i,j) \\in E $$\n- **流量守恒约束**：对于任何节点 $i \\in V$，进入该节点的总流量必须等于离开该节点的总流量，除了源点和汇点。这可以统一写成：\n  $$ \\sum_{j:(j,i) \\in E} x_{ji} - \\sum_{k:(i,k) \\in E} x_{ik} = \\begin{cases} -F  \\text{若 } i=s=1 \\\\ F  \\text{若 } i=t=6 \\\\ 0  \\text{其他} \\end{cases} \\quad \\forall i \\in V $$\n\n**2. LP对偶及其作为最小割的解释**\n\n为了推导对偶问题，我们为原问题（Primal, P）中的每个约束引入对偶变量。设与每个节点 $i \\in V$ 的流量守恒约束相关的对偶变量为 $p_i$（称为节点势）。设与每条弧 $(i,j) \\in E$ 的容量约束 $x_{ij} \\le c_{ij}$ 相关的对偶变量为 $z_{ij} \\ge 0$。\n\n该线性规划的对偶问题（Dual, D）是：\n(D)\n$$ \\text{最小化} \\quad \\sum_{(i,j)\\in E} c_{ij} z_{ij} $$\n约束于：\n$$ p_j - p_i + z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E \\quad (\\text{来自变量 } x_{ij} \\text{ 的约束}) $$\n$$ p_1 - p_6 \\ge 1 \\quad (\\text{来自变量 } F \\text{ 的约束}) $$\n$$ z_{ij} \\ge 0 \\quad \\forall (i,j) \\in E $$\n由于目标是最小化且所有 $c_{ij} \\ge 0$，在最优解处，对于给定的 $p_i$ 值，我们会选择满足约束的最小的 $z_{ij}$ 值，即 $z_{ij} = \\max(0, p_i - p_j)$。将此代入目标函数，对偶问题变为：\n$$ \\text{最小化} \\quad \\sum_{(i,j)\\in E} c_{ij} \\max(0, p_i - p_j) $$\n约束于 $p_1 - p_6 \\ge 1$。\n这个公式可以被直接解释为最小 s-t 割问题。一个 s-t 割是将顶点集 $V$ 划分为两个不相交的集合 $S$ 和 $T$，使得 $s \\in S$ 且 $t \\in T$。割 $(S,T)$ 的容量是跨越割的所有弧（从 $S$ 到 $T$）的容量之和，即 $\\sum_{i \\in S, j \\in T, (i,j) \\in E} c_{ij}$。\n如果我们为对偶问题增加约束，要求 $p_i$ 只能取 0 或 1，并设置 $p_1=1, p_6=0$（这满足 $p_1 - p_6 \\ge 1$），那么对偶变量 $p_i$ 就定义了一个割：$S = \\{i \\in V \\mid p_i=1\\}$ 和 $T = \\{i \\in V \\mid p_i=0\\}$。此时，项 $\\max(0, p_i - p_j)$ 只有在 $p_i=1$ 且 $p_j=0$（即弧 $(i,j)$ 从 $S$ 跨到 $T$）时才为 1，其他情况都为 0。因此，目标函数就变成了割 $(S,T)$ 的容量。\n对偶LP可以被看作是最小割问题的“松弛”，因为它允许 $p_i$ 取任意实数值。然而，由于最大流问题的约束矩阵具有全幺模性（Totally Unimodular），其对偶LP的最优解会自动取整数值（在此情况下为0或1）。这意味着对偶LP实际上精确地求解了最小 s-t 割问题。这就是著名的最大流最小割定理的线性规划证明。\n\n**3. 确定最小 s-t 割的容量**\n\n根据最大流最小割定理，最小 s-t 割的容量等于最大 s-t 流的值。我们可以通过识别一个割并找到一个值与之相等的流来证明其最优性。\n\n考虑割 $(S,T)$，其中 $S=\\{v_1\\}$ 且 $T=\\{v_2, v_3, v_4, v_5, v_6\\}$。从 $S$ 到 $T$ 跨越此割的弧是 $(v_1, v_2)$、$(v_1, v_3)$ 和 $(v_1, v_4)$。\n该割的容量为：\n$$ C(S,T) = c_{12} + c_{13} + c_{14} = 7 + 3 + 4 = 14 $$\n现在，我们构造一个值为14的流来证明这个割是最小割：\n1.  从源点 $v_1$：发送流 $x_{12}=7$, $x_{13}=3$, $x_{14}=4$。这饱和了所有从源点出发的弧。总流量为 $7+3+4=14$。\n2.  在节点 $v_2$：流入量为 $x_{12}=7$。我们发送 $x_{25}=5$（饱和）和 $x_{24}=2$。总流出量为 $5+2=7$。流量守恒。\n3.  在节点 $v_3$：流入量为 $x_{13}+x_{23}=3+0=3$。我们发送 $x_{36}=2$（饱和）和 $x_{35}=1$。总流出量为 $2+1=3$。流量守恒。\n4.  在节点 $v_4$：流入量为 $x_{14}+x_{24}+x_{34} = 4+2+0=6$。我们发送 $x_{46}=5$（饱和）和 $x_{45}=1$。总流出量为 $5+1=6$。流量守恒。\n5.  在节点 $v_5$：流入量为 $x_{25}+x_{35}+x_{45} = 5+1+1=7$。我们发送 $x_{56}=7$。总流出量为 $7$。流量守恒。\n6.  到汇点 $v_6$：流入量为 $x_{36}+x_{46}+x_{56} = 2+5+7=14$。这与从源点发出的总流量相匹配。\n\n所有流量守恒和容量约束均已满足。我们构造了一个总值为14的有效流。\n既然我们找到了一个值为14的流和一个容量为14的割，根据最大流最小割定理，最大流为14，最小割容量也为14。", "answer": "$$\n\\boxed{14}\n$$", "id": "2410395"}, {"introduction": "许多现实世界中的优化问题本质上是整数规划（Integer Programming, IP）问题，它们通常是NP难的。一个常见的求解策略是将其“松弛”为线性规划（LP）问题。本编程练习将让你亲手实现算法，来计算一个图的最小顶点覆盖（一个整数线性规划问题）、其LP松弛以及松弛问题的对偶（分数匹配）的最优值。通过在不同类型的图上进行测试，你将能够通过计算直观地理解“积分性差距”（integrality gap）的概念，并验证对偶理论的正确性，这是设计近似算法的关键一步。[@problem_id:2410323]", "problem": "构建一个程序，对于每个给定的简单无向图，计算三个密切相关的优化模型的最优目标值并进行比较。设顶点集索引为 $V=\\{0,1,\\dots,n-1\\}$，边集为 $E\\subseteq \\{\\{u,v\\}\\mid u,v\\in V, u\\neq v\\}$。考虑为图 $G=(V,E)$ 定义的以下三个模型：\n\n1. 最小顶点覆盖的整数线性规划 (ILP) 模型：\n   最小化 $\\sum_{i\\in V} x_i$，约束条件为：对于所有 $\\{u,v\\}\\in E$，有 $x_u + x_v \\ge 1$；对于所有 $i\\in V$，有 $x_i \\in \\{0,1\\}$。\n\n2. 最小顶点覆盖的线性规划 (LP) 松弛：\n   最小化 $\\sum_{i\\in V} x_i$，约束条件为：对于所有 $\\{u,v\\}\\in E$，有 $x_u + x_v \\ge 1$；对于所有 $i\\in V$，有 $0 \\le x_i \\le 1$。\n\n3. 对偶 LP (分数匹配)：\n   最大化 $\\sum_{e\\in E} y_e$，约束条件为：对于所有 $v\\in V$，有 $\\sum_{e\\ni v} y_e \\le 1$；对于所有 $e\\in E$，有 $y_e \\ge 0$。\n\n对于下面测试套件中的每个图，你的程序必须计算：\n- $s_{\\mathrm{int}}$，ILP 的最优目标值（最小顶点覆盖的大小）。\n- $s_{\\mathrm{lp}}$，LP 松弛的最优目标值。\n- $m_{\\mathrm{frac}}$，对偶 LP (分数匹配) 的最优目标值。\n- 一个布尔值 $b_{\\mathrm{dual}}$，指示 $|s_{\\mathrm{lp}}-m_{\\mathrm{frac}}| \\le 10^{-6}$ 是否成立。\n- 一个布尔值 $b_{\\mathrm{int}}$，指示 $|s_{\\mathrm{int}}-s_{\\mathrm{lp}}| \\le 10^{-6}$ 是否成立。\n- 一个布尔值 $b_{\\mathrm{bip}}$，指示图是否为二分图。\n\n你的程序必须使用以下图的测试套件，每个图由顶点数 $n$ 和作为无序对的边列表 $E$ 给出：\n- 测试 $1$ (二分图, 完全二分图 $K_{2,3}$): $n=5$, $E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$。\n- 测试 $2$ (非二分图奇圈 $C_3$): $n=3$, $E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$。\n- 测试 $3$ (空图): $n=4$, $E=\\emptyset$。\n- 测试 $4$ (带一个孤立顶点的单边图): $n=3$, $E=\\{\\{0,1\\}\\}$。\n\n对数值输出的要求：\n- 所有浮点值必须使用标准舍入规则四舍五入到小数点后三位。\n- 不涉及物理单位。\n- 浮点值之间的任何相等性比较都必须使用上面指定的容差 $10^{-6}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个列表的列表，按上述测试的顺序排列。对于每个测试，输出列表 $[s_{\\mathrm{int}}, s_{\\mathrm{lp}}, m_{\\mathrm{frac}}, b_{\\mathrm{dual}}, b_{\\mathrm{int}}, b_{\\mathrm{bip}}]$。\n- 总输出必须是表示这些逐测试列表的列表的单行，例如 $[[a_1,b_1,c_1,d_1,e_1,f_1],[a_2,b_2,c_2,d_2,e_2,f_2],\\dots]$，其中 $a_i$ 和 $b_i$ 是整数或浮点数，而 $d_i,e_i,f_i$ 是布尔值。\n\n覆盖性设计：\n- 测试 $1$ 使用一个二分图，其中 ILP 和 LP 的最优解重合。\n- 测试 $2$ 使用一个非二分图，其中 LP 松弛解可能严格小于 ILP 最优解。\n- 测试 $3$ 是一个没有边的边界情况。\n- 测试 $4$ 是一个带有一条边的最小连通情况。", "solution": "我们从第一性原理出发。图 $G=(V,E)$ 的一个顶点覆盖是一个集合 $C\\subseteq V$，使得每条边 $\\{u,v\\}\\in E$ 至少有一个端点在 $C$ 中。最小顶点覆盖问题旨在在所有这样的 $C$ 中最小化 $|C|$。通过为每个顶点 $i\\in V$ 引入二进制决策变量 $x_i$ (如果 $i\\in C$ 则 $x_i=1$，否则 $x_i=0$)，这可以很自然地表示为一个整数线性规划 (ILP) 模型。对于每条边 $\\{u,v\\}\\in E$ 的覆盖条件是 $x_u + x_v \\ge 1$。因此，ILP 模型为：\n$$\n\\begin{aligned}\n\\min \\quad  \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad  x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n x_i \\in \\{0,1\\} \\quad \\forall i\\in V.\n\\end{aligned}\n$$\n线性规划 (LP) 松弛将整数约束替换为界限 $0\\le x_i \\le 1$：\n$$\n\\begin{aligned}\n\\min \\quad  \\sum_{i\\in V} x_i \\\\\n\\text{s.t.} \\quad  x_u + x_v \\ge 1 \\quad \\forall \\{u,v\\}\\in E, \\\\\n 0 \\le x_i \\le 1 \\quad \\forall i\\in V.\n\\end{aligned}\n$$\n与此松弛对应的对偶 LP 是分数匹配问题。为每条边 $e\\in E$ 引入对偶变量 $y_e$，得到：\n$$\n\\begin{aligned}\n\\max \\quad  \\sum_{e\\in E} y_e \\\\\n\\text{s.t.} \\quad  \\sum_{e\\ni v} y_e \\le 1 \\quad \\forall v\\in V, \\\\\n y_e \\ge 0 \\quad \\forall e\\in E.\n\\end{aligned}\n$$\n根据线性规划对偶性，在两个问题都可行且有界的情况下，LP 松弛和分数匹配对偶的最优目标值相等。这表达了顶点覆盖多面体的 LP 松弛和匹配多面体的 LP 松弛互为对偶的多面体关系。\n\n对于二分图，其点边关联矩阵是全幺模的，这意味着顶点覆盖的 LP 松弛具有整数极点。因此，对于二分图，ILP 最优解等于 LP 最优解，也等于分数匹配对偶的最优解，这与 Kőnig 定理一致。对于非二分图，LP 松弛可能产生一个严格小于 ILP 最优解的值，这反映了整数性差距。\n\n计算所需输出的算法设计如下：\n- 通过按基数递增的顺序评估所有子集 $C\\subseteq V$ 来精确计算 $s_{\\mathrm{int}}$，直到找到一个顶点覆盖为止；其正确性直接源于顶点覆盖的定义和对 $|C|$ 的最小化。\n- 通过求解 LP 松弛来计算 $s_{\\mathrm{lp}}$。为了将其转换为数值求解器的标准不等式形式，将 $x_u + x_v \\ge 1$ 重写为 $-x_u - x_v \\le -1$，并附带界限 $0\\le x_i \\le 1$。\n- 通过求解对偶 LP 来计算 $m_{\\mathrm{frac}}$。为了适应最小化求解器，通过最小化 $-\\sum y_e$ 来最大化 $\\sum y_e$，约束条件为 $\\sum_{e\\ni v} y_e \\le 1$ 和 $y_e \\ge 0$。\n- 通过检查 $|s_{\\mathrm{lp}} - m_{\\mathrm{frac}}| \\le 10^{-6}$ 来计算 $b_{\\mathrm{dual}}$，这是由可行且有界实例的强对偶性所蕴含的。\n- 通过检查 $|s_{\\mathrm{int}} - s_{\\mathrm{lp}}| \\le 10^{-6}$ 来计算 $b_{\\mathrm{int}}$。\n- 通过二着色广度优先搜索测试来计算 $b_{\\mathrm{bip}}$ 以判断二分性。\n\n现在我们将此应用于测试套件。\n\n测试 $1$：$K_{2,3}$，$n=5$，$E=\\{\\{0,2\\},\\{0,3\\},\\{0,4\\},\\{1,2\\},\\{1,3\\},\\{1,4\\}\\}$。\n- 最小顶点覆盖为 $\\{0,1\\}$，大小为 $|C|=2$，因此 $s_{\\mathrm{int}}=2$。\n- 在二分图中，LP 松弛具有一个值相同的整数最优解；因此 $s_{\\mathrm{lp}}=2.0$。\n- 在 $K_{2,3}$ 中，最大匹配的大小为 $2$，分数匹配的最优值也等于这个值；因此 $m_{\\mathrm{frac}}=2.0$。\n- 因此，$b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，且 $b_{\\mathrm{bip}}=\\text{True}$。\n\n测试 $2$：$C_3$，$n=3$，$E=\\{\\{0,1\\},\\{1,2\\},\\{2,0\\}\\}$。\n- 最小顶点覆盖的大小为 $2$，因此 $s_{\\mathrm{int}}=2$。\n- LP 松弛允许 $x_0=x_1=x_2=\\tfrac{1}{2}$，目标值为 $\\tfrac{3}{2}$，这是最优的；因此 $s_{\\mathrm{lp}}=1.5$。\n- 分数匹配设置 $y_{\\{0,1\\}}=y_{\\{1,2\\}}=y_{\\{2,0\\}}=\\tfrac{1}{2}$，目标值为 $\\tfrac{3}{2}$，因此 $m_{\\mathrm{frac}}=1.5$。\n- 因此，$b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{False}$，且 $b_{\\mathrm{bip}}=\\text{False}$。\n\n测试 $3$：空图，$n=4$，$E=\\emptyset$。\n- 空集是一个顶点覆盖，因此 $s_{\\mathrm{int}}=0$。\n- LP 松弛有零解，目标值为 $0$，因此 $s_{\\mathrm{lp}}=0.0$。\n- 分数匹配没有边，目标值为 $0$，因此 $m_{\\mathrm{frac}}=0.0$。\n- 因此，$b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，且 $b_{\\mathrm{bip}}=\\text{True}$。\n\n测试 $4$：带一个孤立顶点的单边图，$n=3$，$E=\\{\\{0,1\\}\\}$。\n- 最小顶点覆盖的大小为 $1$，因此 $s_{\\mathrm{int}}=1$。\n- LP 松弛的值也为 $1.0$；因此 $s_{\\mathrm{lp}}=1.0$。\n- 分数匹配设置 $y_{\\{0,1\\}}=1$，目标值为 $1$，因此 $m_{\\mathrm{frac}}=1.0$。\n- 因此，$b_{\\mathrm{dual}}=\\text{True}$，$b_{\\mathrm{int}}=\\text{True}$，且 $b_{\\mathrm{bip}}=\\text{True}$。\n\n将浮点数四舍五入到三位小数后，每个测试的列表为 $[2,2.000,2.000,\\text{True},\\text{True},\\text{True}]$、$[2,1.500,1.500,\\text{True},\\text{False},\\text{False}]$、$[0,0.000,0.000,\\text{True},\\text{True},\\text{True}]$ 和 $[1,1.000,1.000,\\text{True},\\text{True},\\text{True}]$。程序必须根据定义通用地计算这些值，并按指定格式将它们生成为一个单行的列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import linprog\nfrom itertools import combinations, product, chain\nfrom collections import deque\n\nTOL = 1e-6\n\ndef is_bipartite(n, edges):\n    if n == 0:\n        return True\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    color = [None] * n\n    for s in range(n):\n        if color[s] is None:\n            color[s] = 0\n            q = deque([s])\n            while q:\n                u = q.popleft()\n                for v in adj[u]:\n                    if color[v] is None:\n                        color[v] = 1 - color[u]\n                        q.append(v)\n                    elif color[v] == color[u]:\n                        return False\n    return True\n\ndef min_vertex_cover_integer(n, edges):\n    # Brute-force exact solution by increasing cardinality subsets\n    # Early exit once a cover is found\n    edge_list = list(edges)\n    if not edge_list:\n        return 0\n    # Precompute for fast checking\n    for k in range(n + 1):\n        for subset in combinations(range(n), k):\n            subset_set = set(subset)\n            is_cover = True\n            for (u, v) in edge_list:\n                if (u not in subset_set) and (v not in subset_set):\n                    is_cover = False\n                    break\n            if is_cover:\n                return k\n    return n  # fallback, full set is always a cover\n\ndef lp_vertex_cover_value(n, edges):\n    # Minimize sum x_i subject to x_u + x_v >= 1, 0 = x_i = 1\n    c = np.ones(n, dtype=float)\n    edge_list = list(edges)\n    m = len(edge_list)\n    if m == 0:\n        return 0.0\n    A = np.zeros((m, n), dtype=float)\n    b = np.full(m, -1.0, dtype=float)\n    for idx, (u, v) in enumerate(edge_list):\n        A[idx, u] = -1.0\n        A[idx, v] = -1.0\n    bounds = [(0.0, 1.0)] * n\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        # Fallback for simple cases if solver fails\n        if n > 0 and m == 0: return 0.0\n        raise RuntimeError(\"LP vertex cover did not converge\")\n    val = float(res.fun)\n    # Clean small negative zeros\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef fractional_matching_value(n, edges):\n    # Maximize sum y_e subject to sum_{e incident to v} y_e = 1, y_e >= 0\n    edge_list = list(edges)\n    m = len(edge_list)\n    if m == 0:\n        return 0.0\n    c = -np.ones(m, dtype=float)  # maximize -> minimize negative\n    A = np.zeros((n, m), dtype=float)\n    b = np.ones(n, dtype=float)\n    for j, (u, v) in enumerate(edge_list):\n        A[u, j] += 1.0\n        A[v, j] += 1.0\n    bounds = [(0.0, None)] * m\n    res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method=\"highs\")\n    if not res.success:\n        if m == 0: return 0.0\n        raise RuntimeError(\"Fractional matching LP did not converge\")\n    val = -float(res.fun)\n    if abs(val)  1e-12:\n        val = 0.0\n    return val\n\ndef format_float(x):\n    # Standard rounding to 3 decimal places\n    return float(f\"{x:.3f}\")\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (n, edges as tuples)\n    test_cases = [\n        (5, frozenset({(0,2),(0,3),(0,4),(1,2),(1,3),(1,4)})), # K_{2,3}\n        (3, frozenset({(0,1),(1,2),(2,0)})),                  # C3\n        (4, frozenset()),                                    # Empty graph\n        (3, frozenset({(0,1)})),                              # Single edge with isolated vertex\n    ]\n\n    results_list = []\n    for n, edges in test_cases:\n        s_int = min_vertex_cover_integer(n, edges)\n        s_lp = lp_vertex_cover_value(n, edges)\n        m_frac = fractional_matching_value(n, edges)\n        b_dual = abs(s_lp - m_frac) = TOL\n        b_int = abs(s_int - s_lp) = TOL\n        b_bip = is_bipartite(n, edges)\n        \n        results_list.append([\n            s_int, \n            format_float(s_lp), \n            format_float(m_frac), \n            b_dual, \n            b_int, \n            b_bip\n        ])\n\n    # Print the final list of lists as a single line string representation.\n    # This matches the specified output format requirement.\n    print(str(results_list).replace(\"'\", \"\"))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2410323"}]}