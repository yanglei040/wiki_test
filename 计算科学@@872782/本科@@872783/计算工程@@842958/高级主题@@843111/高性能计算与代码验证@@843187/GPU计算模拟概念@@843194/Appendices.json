{"hands_on_practices": [{"introduction": "本练习将探讨分块矩阵乘法，这是GPU计算中的一项基础技术。通过将大矩阵分解成可以载入高速共享内存的小数据块，我们可以显著减少从较慢的全局内存中移动数据的次数，这是释放GPU大规模并行潜力的关键。本次实践[@problem_id:2398448]将引导你对一个分块GEMM（通用矩阵乘法）核进行建模，计算其内存占用并分析其算术强度，从而让你从第一性原理层面理解如何为GPU架构设计算法。", "problem": "要求您设计并实现一个程序，用于为科学模拟中的图形处理器（GPU）计算所使用的经典分块通用矩阵乘法（GEMM）内核的内存流量和算术强度建模。其背景是具有非方形维度的矩阵乘积 $C = A \\times B$，其中 $A \\in \\mathbb{R}^{M \\times K}$，$B \\in \\mathbb{R}^{K \\times N}$，$C \\in \\mathbb{R}^{M \\times N}$。假设的数值类型是单精度浮点数（$32$位），因此每个矩阵元素在内存中占用 $4$ 个字节。推理的数学基础是矩阵乘法的定义、基于该定义的浮点运算计数，以及高性能计算中使用的简单分块概念。\n\n从以下基本原理开始：\n- 矩阵乘法的定义：对于每个 $i \\in \\{1,\\dots,M\\}$ 和 $j \\in \\{1,\\dots,N\\}$，$C_{ij} = \\sum_{k=1}^{K} A_{ik} B_{kj}$。\n- 矩阵乘法的浮点运算计数：计算 $C = A \\times B$ 执行 $M \\times N \\times K$ 次乘加对（每次包含一次乘法和一次加法），即 $2 \\times M \\times N \\times K$ 次浮点运算。\n- 在分块算法中，输出矩阵 $C$ 被划分为大小为 $T_M \\times T_N$ 的块。对于每个输出块，内核以大小为 $T_K$ 的块遍历 $K$ 维度，从全局内存中加载一个大小为 $T_M \\times T_K$ 的 $A$ 块和一个大小为 $T_K \\times T_N$ 的 $B$ 块到片上共享内存中，计算部分和，最后将该块的 $T_M \\times T_N$ 个结果一次性写入全局内存。\n\n用于建模内存移动和并行分解的假设：\n- 不同线程块之间没有缓存或共享内存重用；仅利用块内跨 $K$ 维度扫描的重用。因此，为一个输出块获取的数据不会被其他块重用。\n- 每块的共享内存占用主要由同时驻留的 $A$ 和 $B$ 的块决定，即 $A$ 的 $T_M \\times T_K$ 个元素和 $B$ 的 $T_K \\times T_N$ 个元素。\n- 每个矩阵元素占用 $4$ 个字节。\n- 沿 $M$ 和 $N$ 维度的分块使用上取整除法：沿 $M$ 的块（tile）数量为 $\\lceil M / T_M \\rceil$，沿 $N$ 的为 $\\lceil N / T_N \\rceil$。当维度不能被块大小整除时，边界上的块可能被部分填充。\n- 所有大小均以字节表示。不出现物理单位。不出现角度。不需要百分比。\n\n任务：\n- 根据上述基础，推导出以下表达式：\n  - 以块为单位的网格维度，即沿 $M$ 和 $N$ 的块数。\n  - 总块数。\n  - 每块的共享内存使用量（以字节为单位），假设 $A$ 块和 $B$ 块同时驻留。\n  - 一个布尔值，指示每块的共享内存使用量是否在给定的共享内存预算 $S_{\\max}$（以字节为单位）之内。\n  - 在无块间重用假设下，内核传输的总全局内存字节数，计算所有块和所有 $K$ 块在整个乘法过程中的所有读写操作。\n  - 算术强度，定义为总浮点运算次数除以整个乘法过程中传输的总全局内存字节数。\n- 实现一个程序，对下面的每个测试用例，计算并输出：\n  - $\\lceil M / T_M \\rceil$，\n  - $\\lceil N / T_N \\rceil$，\n  - $\\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil$，\n  - 每块共享内存（以字节为单位），\n  - 相对于 $S_{\\max}$ 的适配布尔值，\n  - 传输的总全局内存字节数，\n  - 算术强度（浮点数，四舍五入到 $10^{-6}$）。\n- 程序不得读取任何输入。它必须计算嵌入代码中的测试套件的结果，并打印包含所有结果的单行。\n\n测试套件：\n- 情况 1：$M = 1000$，$K = 750$，$N = 1100$，$T_M = 64$，$T_N = 64$，$T_K = 16$，$S_{\\max} = 49152$ 字节。\n- 情况 2：$M = 1000$，$K = 750$，$N = 1100$，$T_M = 128$，$T_N = 32$，$T_K = 32$，$S_{\\max} = 16384$ 字节。\n- 情况 3：$M = 1000$，$K = 750$，$N = 1100$，$T_M = 32$，$T_N = 128$，$T_K = 32$，$S_{\\max} = 49152$ 字节。\n- 情况 4：$M = 2048$，$K = 256$，$N = 96$，$T_M = 128$，$T_N = 16$，$T_K = 64$，$S_{\\max} = 49152$ 字节。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个每个测试用例记录的列表，其中每个记录本身是按顺序 $[\\lceil M / T_M \\rceil,\\ \\lceil N / T_N \\rceil,\\ \\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil,\\ \\text{shared\\_bytes},\\ \\text{fits},\\ \\text{total\\_bytes},\\ \\text{arithmetic\\_intensity}]$ 排列的列表。\n- 打印的行必须是严格的单个 Python 风格列表，例如：$[[\\dots],[\\dots],\\dots]$。\n- 算术强度必须四舍五入到 $10^{-6}$。", "solution": "所提出的问题是关于并行算法性能建模的一个定义明确的练习，特别是针对图形处理器（GPU）上的分块通用矩阵乘法（GEMM）。它在科学上基于计算线性代数和计算机体系结构的原理。所有必要的参数都已提供，假设也已明确陈述，这使得问题有效且可解。我们接下来推导所需的性能指标。\n\n问题背景是矩阵乘法 $C = A \\times B$，其中 $A \\in \\mathbb{R}^{M \\times K}$，$B \\in \\mathbb{R}^{K \\times N}$，$C \\in \\mathbb{R}^{M \\times N}$。每个矩阵元素是一个单精度浮点数，占用 $S_{elem} = 4$ 字节。该算法将输出矩阵 $C$ 划分为大小为 $T_M \\times T_N$ 的瓦片（tile）或块（block）。\n\n1.  **网格维度和总块数**\n    计算网格是线程块的二维排列，其中每个块负责计算输出矩阵 $C$ 的一个 $T_M \\times T_N$ 大小的块。\n    沿 $M$ 维度所需的块数，我们表示为 $GridDim_{M}$，取决于需要多少个高度为 $T_M$ 的块来覆盖矩阵的 $M$ 行。这需要使用上取整除法。\n    $$GridDim_{M} = \\lceil M / T_M \\rceil$$\n    类似地，沿 $N$ 维度的块数 $GridDim_{N}$ 是：\n    $$GridDim_{N} = \\lceil N / T_N \\rceil$$\n    网格中的总块数 $N_{blocks}$ 是这两个维度的乘积：\n    $$N_{blocks} = GridDim_{M} \\times GridDim_{N} = \\lceil M / T_M \\rceil \\times \\lceil N / T_N \\rceil$$\n\n2.  **每块共享内存使用量**\n    对于每个输出块，一个线程块以大小为 $T_K$ 的步长遍历 $K$ 维度。在每一步中，它将一个大小为 $T_M \\times T_K$ 的 $A$ 的微块和一个大小为 $T_K \\times T_N$ 的 $B$ 的微块加载到其片上共享内存中。问题指出，共享内存占用主要由这两个块的同时驻留决定。\n    来自 $A$ 的块的元素数量是 $T_M \\times T_K$。\n    来自 $B$ 的块的元素数量是 $T_K \\times T_N$。\n    所需的总共享内存（以字节为单位）$S_{shared}$ 是这两个块大小的总和：\n    $$S_{shared} = ( (T_M \\times T_K) + (T_K \\times T_N) ) \\times S_{elem}$$\n    $$S_{shared} = T_K \\times (T_M + T_N) \\times 4$$\n\n3.  **共享内存适配布尔值**\n    这是一个简单的逻辑验证。计算出的所需共享内存 $S_{shared}$ 不得超过每块可用的共享内存预算 $S_{\\max}$。布尔值 $B_{fit}$ 由以下条件确定：\n    $$B_{fit} = (S_{shared} \\le S_{\\max})$$\n\n4.  **总全局内存字节传输量**\n    我们在不同线程块之间无数据重用的假设下，分析 GPU 全局内存和处理单元之间的总数据移动。\n    -   **从矩阵 A 读取：** 整个矩阵 $A$（大小为 $M \\times K$）都必须被读取。考虑 $C$ 的分块。对于 $C$ 中的每一列块，都必须加载整个矩阵 $A$。共有 $GridDim_{N} = \\lceil N / T_N \\rceil$ 个这样的块列。因此，$A$ 的每个元素被读取 $\\lceil N / T_N \\rceil$ 次。\n        从 A 读取的总字节数：$Bytes_{A} = M \\times K \\times \\lceil N / T_N \\rceil \\times S_{elem}$。\n    -   **从矩阵 B 读取：** 类似地，对于 $C$ 中的每一行块，都必须读取整个矩阵 $B$（大小为 $K \\times N$）。共有 $GridDim_{M} = \\lceil M / T_M \\rceil$ 个这样的块行。因此，$B$ 的每个元素被读取 $\\lceil M / T_M \\rceil$ 次。\n        从 B 读取的总字节数：$Bytes_{B} = K \\times N \\times \\lceil M / T_M \\rceil \\times S_{elem}$。\n    -   **向矩阵 C 写入：** 输出矩阵 $C$（大小为 $M \\times N$）被计算并恰好一次写入全局内存。\n        向 C 写入的总字节数：$Bytes_{C} = M \\times N \\times S_{elem}$。\n\n    总全局内存传输量 $B_{total}$ 是所有读写操作的总和：\n    $$B_{total} = Bytes_{A} + Bytes_{B} + Bytes_{C}$$\n    $$B_{total} = (M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N) \\times S_{elem}$$\n\n5.  **算术强度**\n    算术强度 $I$ 是总浮点运算次数（FLOPs）与从全局内存传输的总字节数之比。\n    标准矩阵乘法的总 FLOPs 数 $F$ 为 $2 \\times M \\times N \\times K$，计入每个内循环乘积的一次乘法和一次加法。\n    $$F = 2 \\times M \\times N \\times K$$\n    因此，算术强度为：\n    $$I = \\frac{F}{B_{total}} = \\frac{2 \\times M \\times N \\times K}{(M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N) \\times 4}$$\n    简化因子 $2$ 后：\n    $$I = \\frac{M \\times N \\times K}{2 \\times (M \\times K \\times \\lceil N / T_N \\rceil + K \\times N \\times \\lceil M / T_M \\rceil + M \\times N)}$$\n    该表达式量化了从全局内存移动的每字节数据所执行的运算次数，这是衡量算法在像 GPU 这样受内存带宽限制的架构上效率的关键指标。更高的值是更理想的。\n\n这些推导出的公式足以解决给定测试用例的问题。我们现在将进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates performance metrics for a tiled GEMM kernel based on a simplified GPU memory model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (M, K, N, T_M, T_N, T_K, S_max)\n    test_cases = [\n        (1000, 750, 1100, 64, 64, 16, 49152),\n        (1000, 750, 1100, 128, 32, 32, 16384),\n        (1000, 750, 1100, 32, 128, 32, 49152),\n        (2048, 256, 96, 128, 16, 64, 49152),\n    ]\n\n    results = []\n    \n    # Size of a single-precision float in bytes\n    S_elem = 4\n\n    # Helper function for integer ceiling division\n    def ceil_div(a, b):\n        return (a + b - 1) // b\n\n    for case in test_cases:\n        M, K, N, T_M, T_N, T_K, S_max = case\n\n        # 1. Grid dimensions\n        grid_dim_m = ceil_div(M, T_M)\n        grid_dim_n = ceil_div(N, T_N)\n\n        # 2. Total number of blocks\n        total_blocks = grid_dim_m * grid_dim_n\n\n        # 3. Per-block shared memory usage in bytes\n        shared_bytes = (T_M * T_K + T_K * T_N) * S_elem\n\n        # 4. Shared memory fit boolean\n        fits = shared_bytes = S_max\n\n        # 5. Total global-memory bytes transferred\n        # Bytes read from A: each element of A is read grid_dim_n times\n        bytes_read_A = M * K * grid_dim_n * S_elem\n        # Bytes read from B: each element of B is read grid_dim_m times\n        bytes_read_B = K * N * grid_dim_m * S_elem\n        # Bytes written to C: C is written once\n        bytes_written_C = M * N * S_elem\n        total_bytes = bytes_read_A + bytes_read_B + bytes_written_C\n\n        # 6. Arithmetic intensity\n        # Total floating-point operations\n        flops = 2 * M * N * K\n        # Intensity = FLOPs / Byte\n        # Avoid division by zero, though total_bytes should always be positive for valid inputs\n        if total_bytes > 0:\n            arithmetic_intensity = flops / total_bytes\n        else:\n            arithmetic_intensity = 0.0\n\n        # Round intensity to 10^-6\n        rounded_intensity = round(arithmetic_intensity, 6)\n\n        # Assemble the results for the current case\n        case_result = [\n            grid_dim_m,\n            grid_dim_n,\n            total_blocks,\n            shared_bytes,\n            fits,\n            total_bytes,\n            rounded_intensity\n        ]\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    print(results)\n\nsolve()\n```", "id": "2398448"}, {"introduction": "在理解了共享内存的优势之后，我们现在来深入探讨一个至关重要的性能细节：bank冲突。共享内存被划分为多个bank以支持并行访问，但如果一个warp中的多个线程同时访问同一bank中的不同数据，这些访问将被串行化，从而丧失速度优势。本练习[@problem_id:2398488]使用一个非平凡的对角线访问模式，帮助你建模并量化bank冲突，教会你如何设计能最大化并行吞吐量的内存访问模式。", "problem": "您需要对图形处理单元 (GPU) 共享内存中的存储体冲突进行建模和量化。该冲突发生在单个 warp 中，由二维网格上的对角模板引发一种非显而易见的访问模式。考虑一个包含 $W$ 个线程的 warp，它访问存储在具有 $B$ 个存储体的共享内存中的一个 tile。该 tile 的每个元素恰好占用一个存储体宽度的单元，并且 tile 的基地址已对齐，使得线性索引为 $0$ 的元素映射到存储体 $0$。内存布局为行主序，前导维度（行步长）为 $L$ 个元素。对于线程通道索引 $\\ell \\in \\{0,1,\\dots,W-1\\}$，所访问的 tile 坐标由下式给出：\n- 行索引 $r(\\ell) = (r_0 + \\ell) \\bmod T_r$，\n- 列索引 $c(\\ell) = (c_0 + \\ell \\cdot d) \\bmod T_c$，\n\n其中 $T_r$ 和 $T_c$ 分别是 tile 的行维度和列维度，$r_0$ 和 $c_0$ 是 tile 内的基准行和列偏移量，$d$ 是对角步长。线程 $\\ell$ 寻址的线性元素索引为：\n$$\n\\mathrm{idx}(\\ell) = r(\\ell)\\cdot L + c(\\ell),\n$$\n存储体索引为：\n$$\n\\mathrm{bank}(\\ell) = \\mathrm{idx}(\\ell) \\bmod B.\n$$\n\n冲突建模假设如下：\n- 在一条内存指令中，每个存储体在每个周期只能服务一个不同的元素。如果 warp 中的 $m$ 个线程同时访问映射到同一存储体的 $m$ 个不同元素索引，这些访问将被串行化，对于该存储体需要 $m$ 个周期。\n- 如果多个线程同时访问同一存储体内的相同元素索引，这被视为一次广播，对于该存储体需要 $1$ 个周期。\n- 对于该内存指令，warp 的冲突度定义为\n$$\nC = \\max_{b \\in \\{0,1,\\dots,B-1\\}} \\left(\\text{在所有满足 }\\mathrm{bank}(\\ell)=b\\text{ 的线程中，不同 }\\mathrm{idx}(\\ell)\\text{ 的数量}\\right)。\n$$\n\n您的任务是编写一个完整的程序，对每个提供的测试用例，计算上述定义的整数冲突度 $C$。\n\n使用以下测试套件，其中每个测试用例都是一个元组 $(B, W, L, T_r, T_c, d, r_0, c_0)$：\n- 案例 1 (由于填充导致的轻微冲突的对角访问)：$(32, 32, 33, 32, 32, 1, 0, 0)$。\n- 案例 2 (无广播情况下单个存储体内的最坏情况串行化)：$(32, 32, 32, 32, 32, 0, 0, 0)$。\n- 案例 3 (对角访问形成存储体的一种排列，无冲突)：$(32, 32, 33, 32, 32, 0, 0, 0)$。\n- 案例 4 (退化的对角访问导致单个存储体内的广播)：$(32, 32, 64, 1, 64, 0, 0, 0)$。\n- 案例 5 (半个 warp 的对角访问，步长导致偶数存储体映射，但由于每个存储体仅使用一次而无冲突)：$(32, 16, 33, 16, 16, 1, 0, 0)$。\n\n您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表，结果顺序与测试用例顺序相同，例如 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是相应测试用例的整数冲突度 $C$。", "solution": "我们从共享内存存储体机制的第一性原理出发，对存储体冲突进行建模。共享内存被分为 $B$ 个存储体，每个元素占用一个存储体宽度的单元。在这些假设和基地址对齐的情况下，线性索引为 $\\mathrm{idx}$ 的元素的存储体映射为 $\\mathrm{bank} = \\mathrm{idx} \\bmod B$。对于一个包含 $W$ 个线程的 warp，每个线程通道 $\\ell \\in \\{0,1,\\dots,W-1\\}$ 访问 tile 坐标处的元素：\n$$\nr(\\ell) = (r_0 + \\ell) \\bmod T_r,\\quad c(\\ell) = (c_0 + \\ell \\cdot d) \\bmod T_c,\n$$\n因此线性索引为：\n$$\n\\mathrm{idx}(\\ell) = r(\\ell)\\cdot L + c(\\ell),\n$$\n存储体为：\n$$\n\\mathrm{bank}(\\ell) = \\mathrm{idx}(\\ell) \\bmod B.\n$$\n\n根据定义，warp 的冲突度 $C$ 是在同一条指令中，映射到某个存储体的不同请求索引数量在所有存储体中的最大值：\n$$\nC = \\max_{b \\in \\{0,1,\\dots,B-1\\}} \\left|\\left\\{ \\mathrm{idx}(\\ell) \\,\\big|\\, \\mathrm{bank}(\\ell)=b,\\ \\ell \\in \\{0,1,\\dots,W-1\\} \\right\\}\\right|.\n$$\n这个定义自然地涵盖了广播行为：如果多个线程寻址同一存储体内的相同 $\\mathrm{idx}$，它们对该存储体的计数只贡献 1。\n\n我们通过枚举 $\\ell \\in \\{0,\\dots,W-1\\}$，计算 $r(\\ell)$、$c(\\ell)$、$\\mathrm{idx}(\\ell)$ 和 $\\mathrm{bank}(\\ell)$，然后按存储体分组，计算每个存储体的不同索引数，并取这些计数的最大值，从而为每个测试用例计算 $C$。\n\n我们也可以对提供的案例进行解析推导：\n\n- 案例 1：$(B,W,L,T_r,T_c,d,r_0,c_0) = (32,32,33,32,32,1,0,0)$。对于 $\\ell \\in \\{0,\\dots,31\\}$，\n$$\nr(\\ell) = \\ell \\bmod 32 = \\ell,\\quad c(\\ell) = \\ell \\bmod 32 = \\ell,\n$$\n所以 $\\mathrm{idx}(\\ell) = \\ell\\cdot 33 + \\ell = \\ell\\cdot 34$。那么\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 34) \\bmod 32 = \\ell\\cdot (34 \\bmod 32) \\bmod 32 = \\ell\\cdot 2 \\bmod 32.\n$$\n因此只使用了偶数存储体 $0,2,4,\\dots,30$。对于 $\\ell$ 和 $\\ell+16$，我们有\n$$\n\\mathrm{bank}(\\ell+16) = 2(\\ell+16) \\bmod 32 = (2\\ell + 32) \\bmod 32 = 2\\ell \\bmod 32 = \\mathrm{bank}(\\ell),\n$$\n并且 $\\mathrm{idx}(\\ell+16) = (\\ell+16)\\cdot 34 \\neq \\ell\\cdot 34$，所以每个偶数存储体都恰好接收到两个不同的索引。因此 $C=2$。\n\n- 案例 2：$(32,32,32,32,32,0,0,0)$。此处 $r(\\ell)=\\ell$，$c(\\ell)=0$，所以 $\\mathrm{idx}(\\ell)=\\ell\\cdot 32$。那么\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 32) \\bmod 32 = 0,\n$$\n所以所有线程都映射到存储体 $0$，并且索引各不相同（因为 $\\ell$ 不同）。因此 $C=32$。\n\n- 案例 3：$(32,32,33,32,32,0,0,0)$。此处 $r(\\ell)=\\ell$，$c(\\ell)=0$，所以 $\\mathrm{idx}(\\ell)=\\ell\\cdot 33$。那么\n$$\n\\mathrm{bank}(\\ell) = (\\ell\\cdot 33) \\bmod 32 = \\ell\\cdot (33 \\bmod 32) \\bmod 32 = \\ell \\bmod 32 = \\ell.\n$$\n每个存储体 $b\\in\\{0,\\dots,31\\}$ 恰好接收一个索引。因此 $C=1$。\n\n- 案例 4：$(32,32,64,1,64,0,0,0)$。此处 $T_r=1$，所以对所有 $\\ell$ 都有 $r(\\ell)=0$，并且 $d=0$ 所以 $c(\\ell)=0$。那么 $\\mathrm{idx}(\\ell)=0$，$\\mathrm{bank}(\\ell)=0$。所有线程访问同一个元素，这是一个广播，所以存储体 $0$ 中不同索引的计数为 $1$。因此 $C=1$。\n\n- 案例 5：$(32,16,33,16,16,1,0,0)$。对于 $\\ell \\in \\{0,\\dots,15\\}$，$r(\\ell)=\\ell \\bmod 16 = \\ell$，$c(\\ell)=\\ell \\bmod 16 = \\ell$，所以 $\\mathrm{idx}(\\ell)=\\ell\\cdot 34$，并且 $\\mathrm{bank}(\\ell)=2\\ell \\bmod 32$。偶数存储体 $0,2,\\dots,30$ 每个都恰好接收一个索引（因为 $\\ell$ 只在 $16$ 个值上取值），因此 $C=1$。\n\n因此，这五个案例的冲突度为 $[2, 32, 1, 1, 1]$。程序实现了上述枚举过程，计算每个存储体的不同索引集合，并以指定的单行列表格式输出这些整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef conflict_degree(B, W, L, T_r, T_c, d, r0, c0):\n    # Compute bank mapping and conflict degree C as defined in the problem.\n    # Base address aligned; element size equals bank width unit; bank = idx % B.\n    banks = {}  # bank_id - set of distinct indices (to model broadcast)\n    for ell in range(W):\n        r = (r0 + ell) % T_r\n        c = (c0 + (ell * d)) % T_c\n        idx = r * L + c\n        bank = idx % B\n        if bank not in banks:\n            banks[bank] = set()\n        banks[bank].add(idx)\n    # Conflict degree is the maximum number of distinct indices per bank.\n    if not banks:\n        return 0\n    return max((len(s) for s in banks.values()), default=0)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case: (B, W, L, T_r, T_c, d, r0, c0)\n    test_cases = [\n        (32, 32, 33, 32, 32, 1, 0, 0),  # Case 1\n        (32, 32, 32, 32, 32, 0, 0, 0),  # Case 2\n        (32, 32, 33, 32, 32, 0, 0, 0),  # Case 3\n        (32, 32, 64, 1, 64, 0, 0, 0),   # Case 4\n        (32, 16, 33, 16, 16, 1, 0, 0),  # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        B, W, L, T_r, T_c, d, r0, c0 = case\n        result = conflict_degree(B, W, L, T_r, T_c, d, r0, c0)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2398488"}, {"introduction": "许多模拟计算都涉及对大型记录进行排序，而排序键通常只占数据结构的一小部分。直接对整个大型记录数组进行排序，会因海量的数据传输而变得极其低效。本练习[@problem_id:2398440]介绍了一种强大的优化策略：创建一个轻量级的“键-索引”对数组，对其进行排序，然后对原始的大型记录执行一次置换操作。你将分析这种方法所节省的内存带宽，从而掌握一种处理GPU上带宽受限问题的关键算法策略。", "problem": "您正在为图形处理单元 (GPU) 设计一个带宽高效的排序流水线，用于对物理模拟中的一个记录数组进行排序。每条记录都是一个固定大小的结构体，包含一个 32 位键和一个大载荷。该模拟仅需要根据键进行排序。目标是设计一个能够隔离内存带宽瓶颈的内核方案，并使用一个基于屋顶线视角的第一性原理模型来估算执行时间。\n\n基本原理：\n- 屋顶线模型指出，对于一个受内存带宽限制的内核，其执行时间的下限是传输的总字节数与持续设备内存带宽之比。如果一个内核通过设备内存移动了总共 $X$ 字节，且持续带宽为每秒 $B$ 字节，则时间 $T$ 满足 $T \\ge X / B$。\n- 对一个 $w$ 位的键进行最低有效位并行基数排序，每遍处理 $r$ 位，需要 $p = w / r$ 遍。\n- 在稳定并行基数排序的全局内存乒乓实现中，每一遍都会对被排序的数组执行一次完整的读取和一次完整的写入。\n\n场景与定义：\n- 设 $N$ 为元素数量。\n- 设 $S$ 为结构体大小（以字节为单位）。\n- 设 $K$ 为键大小（以字节为单位），对于 32 位键，$K = 4$。\n- 设 $I$ 为索引大小（以字节为单位），对于 $N \\le 2^{32}$，使用 $I = 4$。\n- 设 $w = 32$ 为键的位宽。\n- 设 $r$ 为每遍基数排序处理的位数，因此遍数为 $p = w / r$。\n- 设 $B$ 为持续设备内存带宽（以字节/秒为单位）。\n- 所有时间必须以秒表示。所有角度均不适用。不使用百分比。\n\n两种策略：\n- 策略 A（完整结构体排序）：直接对大小为 $S$ 字节的结构体数组执行稳定基数排序。在乒乓模型下，忽略直方图开销，每一遍都会读取和写入整个数组，因此移动的总字节数为\n$$\nX_{\\mathrm{A}}(N,S,p) = N \\cdot (2 S) \\cdot p.\n$$\n带宽限制下的时间估算为\n$$\nT_{\\mathrm{A}} = \\frac{X_{\\mathrm{A}}}{B}.\n$$\n- 策略 B（键与索引排序后排列，隔离带宽）：物化一个独立的键与索引对数组，对这个更轻量的数组进行排序，然后对大的结构体执行一次单独的排列操作。假设物化操作从每个结构体元素中读取 $K$ 字节，并向键索引数组中为每个元素写入 $K+I$ 字节。键索引对的排序，在每一遍中，需要为每个元素读取和写入 $K+I$ 字节。最终的结构体排列操作为每个元素执行一次读取和一次写入 $S$ 字节。移动的总字节数为\n$$\nX_{\\mathrm{B}}(N,S,K,I,p) = N \\cdot \\Big( (2K + I) + 2 (K+I) p + 2 S \\Big).\n$$\n带宽限制下的时间估算为\n$$\nT_{\\mathrm{B}} = \\frac{X_{\\mathrm{B}}}{B}.\n$$\n策略 B 相对于策略 A 的预测加速比是\n$$\n\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{X_{\\mathrm{A}}}{X_{\\mathrm{B}}}.\n$$\n\n实现要求：\n- 实现一个程序，为以下每个测试用例计算 $T_{\\mathrm{A}}$、$T_{\\mathrm{B}}$ 和加速比。不要分配大小为 $N$ 的数组；使用上述公式进行解析计算。\n- 单位：以秒为单位报告时间 $T_{\\mathrm{A}}$ 和 $T_{\\mathrm{B}}$。所有浮点数输出格式化为小数点后恰好六位。\n- 此外，在一个小型合成案例上验证该算法转换：构建一个微小的结构体数组，分别通过完整结构体排序和通过键与索引排序加排列（使用中央处理器 (CPU) 代码）进行排序，并检查最终的键顺序是否匹配。此正确性检查必须产生一个布尔值。\n- 对于所有情况，使用 $w = 32$ 位和 $K = 4$ 字节。使用 $I = 4$ 字节。使用 $p = w / r$。\n\n测试套件：\n- 情况 $1$：$N = 10^9$，$S = 128$ 字节，$r = 8$ 位/遍，$B = 900 \\times 10^9$ 字节/秒。\n- 情况 $2$：$N = 10^9$，$S = 64$ 字节，$r = 4$ 位/遍，$B = 900 \\times 10^9$ 字节/秒。\n- 情况 $3$：$N = 5 \\times 10^7$，$S = 192$ 字节，$r = 8$ 位/遍，$B = 450 \\times 10^9$ 字节/秒。\n- 情况 $4$：$N = 2 \\times 10^8$，$S = 16$ 字节，$r = 8$ 位/遍，$B = 1.6 \\times 10^{12}$ 字节/秒。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[T_{\\mathrm{A}}^{(1)}, T_{\\mathrm{B}}^{(1)}, \\text{Speedup}^{(1)}, T_{\\mathrm{A}}^{(2)}, T_{\\mathrm{B}}^{(2)}, \\text{Speedup}^{(2)}, T_{\\mathrm{A}}^{(3)}, T_{\\mathrm{B}}^{(3)}, \\text{Speedup}^{(3)}, T_{\\mathrm{A}}^{(4)}, T_{\\mathrm{B}}^{(4)}, \\text{Speedup}^{(4)}, \\text{Correct}]$\n其中上标 $(i)$ 表示测试用例 $i$，每个时间和加速比都是一个小数点后有六位数字的浮点数，而 $\\text{Correct}$ 是一个布尔值，如果小规模案例验证显示两种策略处理后键的顺序相同，则为 true。不应打印任何其他文本。", "solution": "问题陈述已经过严格评估，被认为是有效的。它在科学上基于计算性能建模的原理，特别是应用于 GPU 内存带宽的屋顶线模型。该问题定义明确、客观，并为获得唯一解提供了所有必要的数据和公式。我们将按要求进行解析求解和算法验证。\n\n目标是比较两种策略，用于根据一个 $w$ 位的键对一个包含 $N$ 条记录的数组进行排序，每条记录大小为 $S$ 字节。该比较是在内存带宽受限的假设下，通过估算执行时间来进行的。\n\n关键参数定义如下：\n- $N$：记录数量。\n- $S$：单条记录（结构体）的大小，以字节为单位。\n- $K$：排序键的大小，以字节为单位，给定 $K=4$。\n- $I$：索引的大小，以字节为单位，给定 $I=4$。\n- $w$：键的位宽，以位为单位，给定 $w=32$。\n- $r$：基数排序每遍处理的位数。\n- $p$：基数排序的遍数，计算为 $p=w/r$。\n- $B$：持续设备内存带宽，以字节/秒为单位。\n\n使用屋顶线模型估算一个受内存带宽限制的内核的执行时间 $T$ 如下：\n$$T \\ge \\frac{X}{B}$$\n其中 $X$ 表示与设备内存之间传输的总字节数。我们将使用等式 $T = X/B$ 进行估算。\n\n**策略 A：完整结构体排序**\n\n此策略直接对记录数组执行稳定基数排序。根据所提供的乒乓模型，基数排序的 $p$ 遍中的每一遍都涉及读取整个包含 $N$ 条记录的数组，并将其写回内存。\n数组的大小为 $N \\cdot S$ 字节。\n一遍的内存流量为一次完整读取和一次完整写入：$N \\cdot S + N \\cdot S = 2 N S$ 字节。\n对于 $p$ 遍，总内存流量 $X_{\\mathrm{A}}$ 为：\n$$X_{\\mathrm{A}}(N, S, p) = N \\cdot (2S) \\cdot p$$\n相应的估算执行时间 $T_{\\mathrm{A}}$ 为：\n$$T_{\\mathrm{A}} = \\frac{2NSp}{B}$$\n\n**策略 B：键-索引排序与排列**\n\n此策略旨在通过对数据的轻量级表示进行排序，并在最后一步将结果顺序应用于完整记录，从而最小化内存流量。该过程包括三个阶段：\n\n1.  **物化键-索引对：** 创建一个临时的（键，索引）对数组。这需要一个内核，从 $N$ 个原始结构体中读取键，并写出一个由键和元素的原始索引组成的新对。\n    - 读取字节数：$N \\cdot K$。\n    - 写入字节数：$N \\cdot (K+I)$。\n    - 此阶段总流量：$N \\cdot (K + (K+I)) = N \\cdot (2K+I)$。\n\n2.  **排序键-索引对：** 对包含 $N$ 个键-索引对的数组执行稳定基数排序。每对的大小为 $(K+I)$ 字节。\n    - 一遍的内存流量（读和写）：$N \\cdot (K+I) + N \\cdot (K+I) = 2N(K+I)$。\n    - $p$ 遍的总流量：$p \\cdot 2N(K+I)$。\n\n3.  **排列完整结构体：** 利用已排序的键-索引数组中编码的排序顺序，将原始的大型结构体重新排列成一个新的已排序数组。该模型将这个复杂的收集操作简化为对结构体数组的一次完整读取和一次完整写入。\n    - 排列的总流量：$N \\cdot S (\\text{读取}) + N \\cdot S (\\text{写入}) = 2NS$。\n\n策略 B 的总内存流量 $X_{\\mathrm{B}}$ 是所有三个阶段流量的总和：\n$$X_{\\mathrm{B}}(N, S, K, I, p) = N \\cdot (2K+I) + N \\cdot 2p(K+I) + N \\cdot 2S$$\n$$X_{\\mathrm{B}}(N, S, K, I, p) = N \\cdot \\Big( (2K+I) + 2p(K+I) + 2S \\Big)$$\n相应的估算执行时间 $T_{\\mathrm{B}}$ 为：\n$$T_{\\mathrm{B}} = \\frac{X_{\\mathrm{B}}}{B}$$\n\n**加速比计算**\n\n策略 B 相对于策略 A 的加速比是它们执行时间的比率：\n$$\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{X_{\\mathrm{A}}/B}{X_{\\mathrm{B}}/B} = \\frac{X_{\\mathrm{A}}}{X_{\\mathrm{B}}}$$\n\n**算法正确性验证**\n\n为验证策略 B 产生与策略 A 相同的排序结果，将执行一个小规模测试。创建一个带有随机键的初始记录数组。使用两种方法对其进行排序：\n1.  直接对记录数组应用稳定排序，按键字段排序。\n2.  创建一个（键，原始索引）对的数组，按键进行稳定排序，并使用得到的已排序索引将原始数组排列成一个新数组。\n比较两种方法得到的最终已排序数组是否相等。一个布尔值表示结果是否匹配。\n\n**计算示例（情况 1）**\n\n- 给定：$N=10^9$，$S=128$，$r=8$，$B=900 \\times 10^9$。\n- 常量：$w=32$，$K=4$，$I=4$。\n- 遍数：$p = w/r = 32/8 = 4$。\n\n- **策略 A：**\n  $X_{\\mathrm{A}} = 10^9 \\cdot (2 \\cdot 128) \\cdot 4 = 1.024 \\times 10^{12}$ 字节。\n  $T_{\\mathrm{A}} = \\frac{1.024 \\times 10^{12}}{900 \\times 10^9} \\approx 1.137778$ 秒。\n\n- **策略 B：**\n  $X_{\\mathrm{B}} = 10^9 \\cdot \\Big( (2 \\cdot 4 + 4) + 2 \\cdot 4 \\cdot (4+4) + 2 \\cdot 128 \\Big) = 10^9 \\cdot (12 + 64 + 256) = 3.32 \\times 10^{11}$ 字节。\n  $T_{\\mathrm{B}} = \\frac{3.32 \\times 10^{11}}{900 \\times 10^9} \\approx 0.368889$ 秒。\n\n- **加速比：**\n  $\\text{Speedup} = \\frac{T_{\\mathrm{A}}}{T_{\\mathrm{B}}} = \\frac{1.137778}{0.368889} \\approx 3.084337$。\n\n对所有测试用例应用相同的过程，并将结果汇编到最终输出中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes performance estimates for two sorting strategies and verifies\n    algorithmic correctness on a small case.\n    \"\"\"\n\n    # --- Part 1: Algorithmic Correctness Verification ---\n\n    def verify_correctness():\n        \"\"\"\n        Verify that sorting keys-and-indices then permuting produces the\n        same result as sorting the full structs directly.\n        \"\"\"\n        # Create a small, synthetic dataset of structs (records)\n        # A struct has a 'key' and a 'payload'\n        num_records = 20\n        # Use a seed for reproducibility\n        rng = np.random.default_rng(seed=42)\n        # Generate some duplicate keys to test for stability\n        keys = rng.integers(0, 10, size=num_records, dtype=np.uint32)\n        \n        # Create the structured array\n        struct_dtype = np.dtype([('key', np.uint32), ('payload', np.uint8, (12,))])\n        structs = np.zeros(num_records, dtype=struct_dtype)\n        structs['key'] = keys\n        # Assign a unique payload to each record to check permutation\n        for i in range(num_records):\n            structs[i]['payload'] = i\n\n        # --- Strategy A: Sort full structs ---\n        # Use a stable sort to respect original order of duplicate keys\n        result_a = np.sort(structs, order='key', kind='stable')\n\n        # --- Strategy B: Sort key-index pairs, then permute ---\n        # 1. Materialize key-index pairs\n        key_index_dtype = np.dtype([('key', np.uint32), ('index', np.uint32)])\n        key_index_pairs = np.empty(num_records, dtype=key_index_dtype)\n        key_index_pairs['key'] = structs['key']\n        key_index_pairs['index'] = np.arange(num_records, dtype=np.uint32)\n\n        # 2. Sort key-index pairs (stably)\n        sorted_key_index_pairs = np.sort(key_index_pairs, order='key', kind='stable')\n\n        # 3. Permute original structs according to sorted indices\n        # This is a gather operation: result_b[i] = structs[old_index]\n        permuted_indices = sorted_key_index_pairs['index']\n        result_b = structs[permuted_indices]\n\n        # 4. Verification: check if the two results are identical\n        return np.array_equal(result_a, result_b)\n\n    correctness_check_passed = verify_correctness()\n\n    # --- Part 2: Performance Estimation for Test Cases ---\n    \n    # Define constants from the problem statement\n    w = 32  # key width in bits\n    K = 4   # key size in bytes\n    I = 4   # index size in bytes\n\n    # Define the test cases\n    test_cases = [\n        # (N, S, r, B)\n        (10**9, 128, 8, 900 * 10**9),\n        (10**9, 64, 4, 900 * 10**9),\n        (5 * 10**7, 192, 8, 450 * 10**9),\n        (2 * 10**8, 16, 8, 1.6 * 10**12),\n    ]\n\n    results = []\n    \n    for N, S, r, B in test_cases:\n        N, S, r, B = float(N), float(S), float(r), float(B)\n        \n        # Number of radix sort passes\n        p = w / r\n\n        # Strategy A: full-struct sort\n        X_A = N * (2 * S) * p\n        T_A = X_A / B\n\n        # Strategy B: keys-and-indices then permute\n        X_B = N * ((2 * K + I) + 2 * p * (K + I) + 2 * S)\n        T_B = X_B / B\n        \n        # Speedup\n        speedup = T_A / T_B if T_B > 0 else 0.0\n\n        results.extend([T_A, T_B, speedup])\n\n    # Format results to six decimal places\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    \n    # Append the boolean correctness check result\n    formatted_results.append(str(correctness_check_passed).lower())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2398440"}]}