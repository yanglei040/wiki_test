{"hands_on_practices": [{"introduction": "理论是理解可扩展性的基础，但真正的掌握来自于实践。这个练习将带你分析一个常见的计算场景：并行编译大型软件项目。通过将编译过程分解为可并行化和固有串行的部分，你将运用阿姆达尔定律（Amdahl's Law）的基本原则来量化串行瓶颈对整体性能提升的限制。这个练习旨在让你亲身体会，即使拥有无限的处理器，性能提升也存在一个硬性上限 [@problem_id:2433433]。", "problem": "一个大型软件项目使用支持并行作业执行的依赖感知构建工具进行构建，其最大并发数为 $N$ 个作业（通过类似于 \"make -j N\" 的标志调用）。在单核上，仔细的性能分析得出了单个可执行文件一次完整构建的端到端时间线如下：\n\n- 预构建依赖发现、规则扩展和全局任务图构建：$12$ 秒。此阶段由单线程工具实现。\n- 编译本身（每个翻译单元的预处理、解析、优化和代码生成）：$340$ 秒的中央处理器（CPU）时间，一旦输入存在，这部分时间可以被划分为独立的任务。\n- 源文件和头文件的输入/输出（I/O）：$48$ 秒的总时间，由于在此环境中存在单个共享存储设备和串行化的文件系统路径，增加更多的CPU核也无法加速。将其视为固有的串行部分。\n- 最终链接和打包以生成可执行文件：$20$ 秒。此步骤只有一个消费者，它在所有目标文件都存在后才开始，并按顺序进行。\n\n假设只有CPU密集型的编译工作可以在 $N$ 个完全负载均衡的相同核心上并行化，除了所描述的阶段外，没有额外的运行时开销。在此环境中，所有其他阶段都是固有串行的。\n\n仅使用第一性原理（求解时间和加速比的定义）和上述场景，推导理论加速比作为 $N$ 的函数表达式，然后在 $N=12$ 时求值。将最终答案表示为一个无单位的数字，并四舍五入到四位有效数字。", "solution": "对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 最大并发数：$N$ 个作业\n- 预构建阶段时间（串行）：$T_{pre-build} = 12$ 秒\n- 编译CPU时间（可并行化）：$T_{compile,cpu} = 340$ 秒\n- 源文件和头文件I/O时间（串行）：$T_{io} = 48$ 秒\n- 最终链接和打包时间（串行）：$T_{link} = 20$ 秒\n- 编译工作被假设为可以在 $N$ 个核心上完美并行化。\n- 所有其他指定阶段都是固有串行的。\n- 任务是推导理论加速比 $S$ 作为 $N$ 的函数，并计算当 $N=12$ 时的值，结果四舍五入到四位有效数字。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，提法恰当且客观。它描述了一个应用阿姆达尔定律（Amdahl's Law）的经典场景，这是计算工程和并行计算中的一个基本原则。所提供的数据是自洽、一致且合理的。诸如完美负载均衡和零开销等假设是标准的理想化处理，用于分离出由串行瓶颈引起的可伸缩性限制这一核心概念。该问题没有缺陷；这是一个直接的性能建模练习。\n\n步骤3：结论和行动\n问题有效。将提供解答。\n\n完成一个任务的总时间可以分解为两个部分：一部分是固有串行的，另一部分是可并行的。设 $T_{serial}$ 为串行任务消耗的总时间，设 $T_{parallel}$ 为可并行任务在单核上执行时消耗的时间。\n\n根据问题陈述，总串行时间是预构建、I/O和链接阶段的时间总和：\n$$T_{serial} = T_{pre-build} + T_{io} + T_{link}$$\n$$T_{serial} = 12\\,\\text{s} + 48\\,\\text{s} + 20\\,\\text{s} = 80\\,\\text{s}$$\n\n可以并行化的工作部分是编译本身，在单核上需要 $T_{parallel} = 340\\,\\text{s}$ 的CPU时间。\n\n在单核上求解的总时间，我们记为 $T(1)$，是串行和并行部分的总和：\n$$T(1) = T_{serial} + T_{parallel} = 80\\,\\text{s} + 340\\,\\text{s} = 420\\,\\text{s}$$\n\n当任务在 $N$ 个核心上执行时，串行部分的时间保持不变。在完美并行化和负载均衡的假设下，可并行化部分的时间减少为原来的 $1/N$。因此，在 $N$ 个核心上求解的总时间 $T(N)$ 为：\n$$T(N) = T_{serial} + \\frac{T_{parallel}}{N}$$\n代入已知值，我们得到求解时间作为 $N$ 的函数的表达式：\n$$T(N) = 80 + \\frac{340}{N}$$\n\n理论加速比 $S(N)$ 定义为在单个处理器上求解的时间与在 $N$ 个处理器上求解的时间之比。\n$$S(N) = \\frac{T(1)}{T(N)}$$\n\n使用推导出的 $T(1)$ 和 $T(N)$ 的表达式，我们得到加速比的通用公式：\n$$S(N) = \\frac{T_{serial} + T_{parallel}}{T_{serial} + \\frac{T_{parallel}}{N}}$$\n将数值代入此表达式可得：\n$$S(N) = \\frac{420}{80 + \\frac{340}{N}}$$\n这就是所要求的理论加速比作为 $N$ 的函数的表达式。\n\n问题要求计算当 $N=12$ 时该加速比的值。\n$$S(12) = \\frac{420}{80 + \\frac{340}{12}}$$\n我们首先计算分母：\n$$80 + \\frac{340}{12} = 80 + \\frac{85}{3} = \\frac{240}{3} + \\frac{85}{3} = \\frac{325}{3}$$\n现在我们计算加速比：\n$$S(12) = \\frac{420}{\\frac{325}{3}} = \\frac{420 \\times 3}{325} = \\frac{1260}{325}$$\n为简化此分数，我们可以将分子和分母同除以它们的最大公约数。两者都可以被 $5$ 整除：\n$$S(12) = \\frac{252}{65}$$\n执行除法以获得小数值：\n$$S(12) = 3.876923...$$\n问题要求将答案四舍五入到四位有效数字。\n$$S(12) \\approx 3.877$$\n这个结果与阿姆达尔定律（Amdahl's Law）一致，该定律表明加速比最终受代码串行部分的限制。在这种情况下，串行部分占比为 $\\frac{80}{420} \\approx 0.19$，这导致无论使用多少核心，最大理论加速比都被限制为 $\\frac{1}{0.19...} = \\frac{420}{80} = 5.25$。我们得到的 $N=12$ 时的结果正确地低于此限制。", "answer": "$$\\boxed{3.877}$$", "id": "2433433"}, {"introduction": "在并行计算中，“易并行”（embarrassingly parallel）任务通常被认为是理想情况，但现实世界往往更为复杂。本练习以蒙特卡洛模拟为例，深入探讨了易并行任务中隐藏的性能瓶颈。你将构建一个更精细的性能模型，该模型不仅考虑了计算本身，还包括了共享硬件资源的争用（如并行随机数生成器）和最终结果归约的通信开销。通过这个练习，你将学会识别和量化那些超越简单串行/并行划分的复杂性能限制因素 [@problem_id:2433427]。", "problem": "蒙特卡洛估计器通过对独立试验的贡献进行平均来计算一个量。考虑一个执行总共 $N$ 次独立试验的实现，其中每次试验：\n- 使用随机数生成 (RNG) 抽取 $k$ 个独立的随机数，以及\n- 对这 $k$ 个数执行一个计算内核。\n\n假设有以下硬件和软件特性：\n- 在中央处理器 (CPU) 上，每次试验的计算内核时间为 $t_{c}$ 秒。\n- CPU 上的软件 RNG 每个随机数需要 $t_{r,\\mathrm{cpu}}$ 秒。\n- 此外，还有一个共享的硬件 RNG 服务，其总吞吐量为每秒 $\\Theta$ 个随机数，可供所有进程共同使用。生成随机数的时间受限于 CPU 软件 RNG 能力和共享硬件 RNG 吞吐量中较慢的一个。\n- 所有试验完成后，通过使用深度为 $\\lceil \\log_{2}(p) \\rceil$ 的二叉树对 $p$ 个部分和进行归约，从而获得一个单一的全局标量结果，其中每个归约步骤会产生 $\\alpha$ 秒的延迟和与消息大小 $m$ 字节成正比的时间 $\\beta m$。\n- 存在一个无法并行的串行播种和设置成本 $t_{0}$ 秒。\n\n将在 $p$ 个并行进程上的加速比定义为 $S(p) = \\dfrac{T(1)}{T(p)}$，其中 $T(p)$ 是使用 $p$ 个进程完成所有 $N$ 次试验，然后执行归约得到单一结果所需的总墙上时钟时间。\n\n使用以下参数：\n- $N = 10^{8}$，\n- $k = 2$，\n- $t_{c} = 3.0 \\times 10^{-8}$ 秒，\n- $t_{r,\\mathrm{cpu}} = 1.5 \\times 10^{-8}$ 秒，\n- $\\Theta = 2.0 \\times 10^{9}$ 随机数/秒，\n- $\\alpha = 1.0 \\times 10^{-6}$ 秒，\n- $\\beta = 5.0 \\times 10^{-10}$ 秒/字节，\n- $m = 16$ 字节，\n- $t_{0} = 5.0 \\times 10^{-2}$ 秒。\n\n假设 $N$ 次试验在 $p$ 个进程中平均分配，每次试验的计算内核和 RNG 时间相加，归约使用上述的二叉树，并且共享硬件 RNG 吞吐量 $\\Theta$ 是所有 $p$ 个进程的单一全局限制。\n\n计算当 $p = 128$ 时的加速比 $S(p)$。将最终加速比表示为一个无单位的数字，并将你的答案四舍五入到四位有效数字。", "solution": "问题要求计算在 $p$ 个并行进程上蒙特卡洛模拟的加速比 $S(p)$，定义为 $S(p) = \\frac{T(1)}{T(p)}$。为了计算这个值，我们必须首先为总墙上时钟时间 $T(p)$ 建立一个形式化模型。\n\n总时间 $T(p)$ 是三个按顺序执行的不同阶段的总和：一个串行设置阶段，一个并行试验执行阶段，以及一个最终的并行归约阶段。\n$$T(p) = T_{\\text{setup}} + T_{\\text{trials}}(p) + T_{\\text{reduction}}(p)$$\n\n这些组成部分定义如下：\n$1$. 串行设置时间是一个常数，给定为 $T_{\\text{setup}} = t_{0}$。这个部分不随进程数 $p$ 的增加而扩展。\n\n$2$. 并行试验执行时间 $T_{\\text{trials}}(p)$ 是完成分布在 $p$ 个进程上的所有 $N$ 次试验所需的时间。由于 $N$ 次试验被平均分配，每个进程处理 $N/p$ 次试验。此阶段的时间由最后一个完成的进程决定。由于工作负载是均衡的，所有进程会同时完成。每次试验内部的工作包括随机数生成 (RNG) 和一个计算内核。问题陈述它们的执行时间是相加的。因此，试验阶段的总时间是计算时间和 RNG 时间之和。\n\n计算部分是完全并行的。总计算工作量是 $N t_c$。在 $p$ 个进程上，这需要：\n$$T_{\\text{compute}}(p) = \\frac{N t_c}{p}$$\n\nRNG 部分更为复杂。总共需要生成 $N k$ 个随机数。时间受限于两个资源中较慢的一个：每个 CPU 上的分布式软件 RNG 和共享的硬件 RNG。\n- 如果仅受软件 RNG 限制，时间将是一个进程生成其部分随机数所需的时间，即 $\\frac{N}{p} k t_{r,\\mathrm{cpu}}$。\n- 如果仅受共享硬件 RNG 限制，时间由其总吞吐量 $\\Theta$ 决定。生成 $N k$ 个随机数的总时间是 $\\frac{N k}{\\Theta}$。这是一个全局瓶颈，不随 $p$ 扩展。\nRNG 的实际时间是这两个值的最大值，因为进程的完成速度不能快于其最严格的约束。\n$$T_{\\text{RNG}}(p) = \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right)$$\n因此，试验阶段的总时间是：\n$$T_{\\text{trials}}(p) = T_{\\text{compute}}(p) + T_{\\text{RNG}}(p) = \\frac{N t_c}{p} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right)$$\n\n$3$. 最终的归约时间 $T_{\\text{reduction}}(p)$ 涉及使用二叉树对 $p$ 个部分和进行归约。这样一棵树的深度是 $\\lceil \\log_{2}(p) \\rceil$。每个归约步骤都有一个延迟 $\\alpha$ 和一个数据传输时间 $\\beta m$。对于 $p  1$，总归约时间是：\n$$T_{\\text{reduction}}(p) = \\lceil \\log_{2}(p) \\rceil (\\alpha + \\beta m)$$\n对于 $p=1$ 的基本情况，不需要在进程之间进行归约，所以 $T_{\\text{reduction}}(1) = 0$，这与 $\\lceil \\log_{2}(1) \\rceil = 0$ 是一致的。\n\n结合这些组成部分，总时间的完整表达式是：\n$$T(p) = t_{0} + \\frac{N t_c}{p} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{p}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(p) \\rceil (\\alpha + \\beta m)$$\n\n现在，我们代入给定的参数值：\n- $N = 10^{8}$\n- $k = 2$\n- $t_{c} = 3.0 \\times 10^{-8}$ $s$\n- $t_{r,\\mathrm{cpu}} = 1.5 \\times 10^{-8}$ $s$\n- $\\Theta = 2.0 \\times 10^{9}$ $s^{-1}$\n- $\\alpha = 1.0 \\times 10^{-6}$ $s$\n- $\\beta = 5.0 \\times 10^{-10}$ $s/byte$\n- $m = 16$ $bytes$\n- $t_{0} = 5.0 \\times 10^{-2}$ $s$\n- $p = 128$\n\n首先，我们计算串行时间 $T(1)$：\n$$T(1) = t_{0} + N t_c + \\max\\left(N k t_{r,\\mathrm{cpu}}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(1) \\rceil (\\alpha + \\beta m)$$\n各个项分别为：\n- $t_{0} = 0.05$ $s$\n- $N t_c = 10^{8} \\times (3.0 \\times 10^{-8}) = 3.0$ $s$\n- 软件 RNG 时间：$N k t_{r,\\mathrm{cpu}} = 10^{8} \\times 2 \\times (1.5 \\times 10^{-8}) = 3.0$ $s$\n- 硬件 RNG 时间限制：$\\frac{N k}{\\Theta} = \\frac{10^{8} \\times 2}{2.0 \\times 10^{9}} = \\frac{2 \\times 10^{8}}{2 \\times 10^{9}} = 0.1$ $s$\n- $\\max(3.0, 0.1) = 3.0$ $s$\n- 归约时间：$\\lceil \\log_{2}(1) \\rceil (\\dots) = 0$\n所以，$T(1) = 0.05 + 3.0 + 3.0 + 0 = 6.05$ $s$。\n\n接下来，我们计算并行时间 $T(128)$：\n$$T(128) = t_{0} + \\frac{N t_c}{128} + \\max\\left(\\frac{N k t_{r,\\mathrm{cpu}}}{128}, \\frac{N k}{\\Theta}\\right) + \\lceil \\log_{2}(128) \\rceil (\\alpha + \\beta m)$$\n各个项分别为：\n- $t_{0} = 0.05$ $s$\n- 并行计算时间：$\\frac{N t_c}{128} = \\frac{3.0}{128} = 0.0234375$ $s$\n- 并行软件 RNG 时间：$\\frac{N k t_{r,\\mathrm{cpu}}}{128} = \\frac{3.0}{128} = 0.0234375$ $s$\n- 硬件 RNG 时间限制：$\\frac{N k}{\\Theta} = 0.1$ $s$\n- $\\max(0.0234375, 0.1) = 0.1$ $s$。这表明 RNG 受到了硬件瓶颈的限制。\n- 归约时间：\n  - $\\lceil \\log_{2}(128) \\rceil = 7$\n  - 每步时间：$\\alpha + \\beta m = 1.0 \\times 10^{-6} + (5.0 \\times 10^{-10} \\times 16) = 1.0 \\times 10^{-6} + 8.0 \\times 10^{-9} = 1.008 \\times 10^{-6}$ $s$\n  - 总归约时间：$7 \\times (1.008 \\times 10^{-6}) = 7.056 \\times 10^{-6}$ $s$\n所以，$T(128) = 0.05 + 0.0234375 + 0.1 + 0.000007056 = 0.173444556$ $s$。\n\n最后，我们计算加速比 $S(128)$：\n$$S(128) = \\frac{T(1)}{T(128)} = \\frac{6.05}{0.173444556} \\approx 34.88053$$\n四舍五入到四位有效数字，加速比为 $34.88$。", "answer": "$$\\boxed{34.88}$$", "id": "2433427"}, {"introduction": "从理论模型到分析真实世界的性能数据，是计算工程师的关键一步。当你在不同并发级别下测量一个系统的吞吐量时，所得到的性能曲线揭示了其可扩展性的内在特征。本练习要求你扮演性能分析师的角色，利用冈瑟的通用可扩展性定律（Gunther's Universal Scalability Law, USL）来解读一组真实的性能测量数据。你需要区分系统是受资源争用（contention）限制还是受数据一致性（coherency）开销的拖累，并预测其在更高并发下的行为，特别是理解为何性能有时会随着处理器数量的增加而下降（即“倒退式扩展”）[@problem_id:2433475]。", "problem": "一个软件服务部署在多核中央处理器（CPU）上，并使用一个工作线程池来处理独立的请求。随着线程数的变化，请求组合和代码路径保持不变。在固定的外部负载生成器下，您测量了稳态吞吐量 $X(N)$（单位为每秒事务数）作为并发工作线程数 $N$ 的函数。得到以下数据点：$(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$。将加速比定义为 $S(N) = X(N)/X(1)$。假设通用可伸缩性定律（USL）在此场景下适用，并且其参数分别反映了系数为 $\\sigma$ 的竞争效应和系数为 $\\kappa$ 的一致性效应。\n\n仅使用上述测量值以及吞吐量和加速比的基本定义，判断哪种定性状况与数据最一致，以及它对 $N  16$ 时的扩展性意味着什么。选择唯一最佳选项。\n\nA. 系统主要受竞争限制，一致性效应可忽略（即 $\\sigma  0$, $\\kappa \\approx 0$）；吞吐量将单调增加，趋向于一个高于 $X(16)$ 的有限渐近线，并且不会随着 $N$ 的增加而减少。\n\nB. 系统主要受一致性限制，具有不可忽略的成对交互成本（即 $\\kappa  0$ 且不受 $\\sigma$ 主导）；吞吐量在 $N \\approx 12$ 附近表现出最大值，并会随着 $N$ 的增大而减小。\n\nC. 系统表现出近乎完美的线性可伸缩性（即 $\\sigma \\approx 0$ 且 $\\kappa \\approx 0$）；在观测范围内，吞吐量约等于 $X(N) \\approx N \\cdot X(1)$。\n\nD. 系统受到 Amdahl 定律意义下的固定串行部分的限制；吞吐量随 $N$ 次线性但严格单调增加，并且不会在更大的 $N$ 值下减少。", "solution": "必须首先验证问题陈述的科学性和逻辑完整性。\n\n**步骤1：提取已知条件**\n- 系统是一个在多核CPU上运行的软件服务，使用工作线程池来处理独立请求。\n- 随着线程数的变化，请求组合和代码路径保持不变。\n- 吞吐量 $X(N)$ 作为并发工作线程数 $N$ 的函数进行测量。\n- 施加了固定的外部负载。\n- 测得的数据点为 $(N, X(N)) \\in \\{(1, 100), (2, 190), (4, 360), (8, 680), (12, 820), (16, 780)\\}$，其中 $X(N)$ 的单位是每秒事务数。\n- 加速比定义为 $S(N) = X(N)/X(1)$。\n- 假设通用可伸缩性定律（USL）适用。\n- USL 参数 $\\sigma$ 代表竞争，$\\kappa$ 代表一致性。\n\n**步骤2：使用已知条件进行验证**\n该问题具有科学依据。通用可伸缩性定律是分析并行和并发系统性能的广泛接受的模型。所描述的实验设置——测量多核CPU上线程化服务的吞吐量——是此类分析的标准应用领域。所提供的数据对于一个真实世界的系统是合理的，表现出初始加速后在更高并发下性能下降的现象。问题是适定的（well-posed），提供了足够的数据和一个明确的理论框架（USL）来评估系统的定性行为。术语定义明确。没有矛盾、事实错误或主观论断。\n\n**步骤3：结论与行动**\n问题陈述有效。我将继续进行解答。\n\n**推导**\n\n通用可伸缩性定律（USL）将加速比 $S(N)$ 建模为处理器或线程数 $N$ 的函数。其标准形式为：\n$$S(N) = \\frac{N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\n此处，$\\sigma$ 表示因争用共享资源而串行化的工作部分，而 $\\kappa$ 表示维护数据一致性带来的额外开销，该开销通常随工作单元数量呈二次方扩展（由于成对交互）。\n\n吞吐量 $X(N)$ 通过所给定义与加速比 $S(N)$ 相关联：$S(N) = X(N)/X(1)$。因此，吞吐量的 USL 模型为：\n$$X(N) = X(1) \\cdot S(N) = \\frac{X(1) \\cdot N}{1 + \\sigma(N-1) + \\kappa N(N-1)}$$\n根据数据，我们有 $X(1) = 100$ 事务/秒。\n\n我们必须在此模型的背景下分析测量的吞吐量数据的行为。让我们为每个测量点计算加速比：\n- 对于 $N=1$：$X(1) = 100$。$S(1) = 100/100 = 1.0$。这是根据定义得出的。\n- 对于 $N=2$：$X(2) = 190$。$S(2) = 190/100 = 1.9$。\n- 对于 $N=4$：$X(4) = 360$。$S(4) = 360/100 = 3.6$。\n- 对于 $N=8$：$X(8) = 680$。$S(8) = 680/100 = 6.8$。\n- 对于 $N=12$：$X(12) = 820$。$S(12) = 820/100 = 8.2$。\n- 对于 $N=16$：$X(16) = 780$。$S(16) = 780/100 = 7.8$。\n\n关键的观察是，吞吐量增加到 $N=12$ 时达到峰值，然后在 $N=16$ 时下降，因为 $X(16) = 780  X(12) = 820$。这种现象被称为“回退扩展”（retrograde scaling）。\n\n让我们分析 USL 方程以理解导致这种行为的原因。吞吐量 $X(N)$ 是 $N$ 的一个有理函数。其在大 $N$ 值的行为由分子和分母中的最高阶项决定。\n- 分子是 $N$ 的线性函数。\n- 分母是 $N$ 的二次函数：$\\kappa N^2 + (\\sigma - \\kappa)N + (1 - \\sigma)$。\n\n如果一致性效应可以忽略（$\\kappa \\approx 0$），USL 就简化为 Amdahl 定律（或仅考虑竞争的模型）：\n$$X(N) \\approx \\frac{X(1) \\cdot N}{1 + \\sigma(N-1)}$$\n在这种情况下，对于 $\\sigma > 0$，函数 $X(N)$ 随 $N$ 严格单调递增。当 $N \\to \\infty$ 时，吞吐量趋向于一个有限的渐近线：\n$$\\lim_{N\\to\\infty} X(N) = \\lim_{N\\to\\infty} \\frac{X(1) \\cdot N}{\\sigma N} = \\frac{X(1)}{\\sigma}$$\n这个模型无法解释吞吐量的下降。\n\n如果一致性效应不可忽略（$\\kappa > 0$），对于大的 $N$ 值，分母由 $\\kappa N^2$ 项主导。吞吐量的行为如下：\n$$X(N) \\sim \\frac{X(1) \\cdot N}{\\kappa N^2} = \\frac{X(1)}{\\kappa N}$$\n当 $N \\to \\infty$ 时，$X(N) \\to 0$。由于 $X(N)$ 从 $X(1) > 0$ 开始，并最终趋向于0，它必须在某个有限的 $N$ 值处达到最大值。这个峰值的位置 $N_{peak}$，可以通过将 $N$ 视为连续变量并将导数 $dX(N)/dN$ 设为零来找到。计算得出 $N_{peak} \\approx \\sqrt{(1-\\sigma)/\\kappa}$。当且仅当 $\\kappa > 0$ 且 $\\sigma  1$ 时，对于有限的实数 $N > 1$ 存在峰值。\n\n观测到的数据 $X(16)  X(12)$ 明确表明系统已经越过了其可伸缩性峰值。这只在一致性参数 $\\kappa$ 为正且显著的情况下才可能发生。\n\n**逐项分析**\n\nA. 这对应于一个 $\\kappa \\approx 0$ 的模型。如上所述，这样的模型预测吞吐量是严格单调增加的。数据明确反驳了这一预测，因为吞吐量从 $N=12$ 到 $N=16$ 时减少了。\n结论：**不正确**。\n\nB. 该选项假设存在不可忽略的一致性效应（$\\kappa > 0$）。如前所述，这是吞吐量呈现最大值然后下降的必要条件。数据显示，最大吞吐量出现在 $N=12$ 或其附近，随后出现下降。这与一个显著的 $\\kappa$ 项的理论含义完全一致。陈述“会随着 N 的增大而减小”是基于 $\\kappa > 0$ 的 USL 模型的正确推断。\n结论：**正确**。\n\nC. 这意味着 $S(N) \\approx N$。与数据对比显示出巨大偏差。例如，当 $N=12$ 时，线性可伸缩性预测 $X(12) = 12 \\cdot X(1) = 12 \\cdot 100 = 1200$。而测量值为 $820$，这是一个显著的次线性。对于 $N=16$，线性可伸缩性预测 $X(16) = 1600$，而测量值为 $780$。该模型显然拟合不佳。\n结论：**不正确**。\n\nD. Amdahl 定律是 USL 在 $\\kappa = 0$ 时的特例。这与选项 A 中描述的物理模型相同。它只考虑了竞争，而没有考虑一致性。因此，它无法解释观测到的吞吐量下降。数据证明，在该范围内，系统不能用 Amdahl 定律来描述。\n结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "2433475"}]}