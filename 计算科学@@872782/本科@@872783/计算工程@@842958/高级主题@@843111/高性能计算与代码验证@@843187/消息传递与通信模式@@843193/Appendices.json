{"hands_on_practices": [{"introduction": "许多复杂的并行计算任务可以被构建为“主从（Master-Worker）”模式，即一个主进程向一组工作进程分发独立的任务。本练习将指导你通过离散事件模拟来预测这类系统的性能。通过构建这样一个模型，你将学习如何在没有真实并行硬件的情况下，分析通信延迟、网络带宽和计算负载等因素如何共同影响系统的总完成时间（makespan），这对于理解和优化现实世界中的分布式应用至关重要 [@problem_id:2413700]。", "problem": "实现一个主/从（master/worker）计算的离散事件模拟，以研究消息传递和通信模式。主节点使用非阻塞发送方式将独立的任务分配给一个固定的工作节点池。每个任务包括一个从主节点到工作节点的请求消息、在工作节点上的计算，以及一个从工作节点返回主节点的结果消息。主节点在发送时不会阻塞；它可以在同一模拟时间瞬间发布多个发送操作。工作节点一次最多处理一个任务，并在完成计算后立即变为空闲状态；结果消息的发送不会延迟工作节点的可用性。您的目标是为一组给定的场景计算总完成时间（makespan）。\n\n基本原理与假设：\n- 使用消息传递系统（如 Message Passing Interface (MPI)）中的标准定义。特别地，非阻塞发送会立即将控制权返还给调用者，而无需等待消息传输完成。我们使用固定的延迟和带宽项来模拟网络传输时间。\n- 设 $L$ 为单向延迟（秒），$B$ 为带宽（字节/秒），$s$ 为消息大小（字节）。单向传输时间为\n$$\nT(s) = L + \\frac{s}{B},\n$$\n约定如果 $B = \\infty$，则 $\\frac{s}{B} = 0$。\n- 对于每个任务 $i$，其工作节点计算时间为 $c_i$（秒），在计算前有一个从主节点发送到工作节点的大小为 $s_\\mathrm{req}$ 的请求消息，计算后有一个从工作节点发送到主节点的大小为 $s_\\mathrm{resp}$ 的结果消息。因此，如果一个任务在时间 $t$ 被分配给一个工作节点，它在时间 $t + T(s_\\mathrm{req})$ 开始计算，并在时间 $t + T(s_\\mathrm{req}) + c_i$ 完成计算。其结果在时间 $t + T(s_\\mathrm{req}) + c_i + T(s_\\mathrm{resp})$ 到达主节点。\n- 主节点使用非阻塞发送。一旦一个工作节点变为空闲并且有待处理的任务，主节点就在那个确切的模拟时间向该工作节点发布一个发送操作。该发送操作不会阻塞主节点，分配时间即为工作节点变为空闲的时刻。工作节点的可用性不会因发送其结果而延迟，因为假定工作节点的发送也是非阻塞的。\n- 工作节点一次最多处理一个任务。主节点在时间 $t=0$ 开始，最多分配 $\\min(W, N)$ 个任务，其中 $W$ 是工作节点数量， $N$ 是任务数量。任务不可被抢占。\n\n需要计算的量：\n- 对于每个场景，计算完工时间（makespan）$T_\\mathrm{end}$，定义为主节点接收到最后一个结果消息的时间。形式上，\n$$\nT_\\mathrm{end} = \\max_{i=1,\\dots,N} \\left( t_i^\\mathrm{assign} + T(s_\\mathrm{req}) + c_i + T(s_\\mathrm{resp}) \\right),\n$$\n其中 $t_i^\\mathrm{assign}$ 是主节点将任务 $i$ 分配给某个工作节点的时间（由上述事件驱动的调度决定）。\n\n算法要求：\n- 基于上述定义实现一个离散事件模拟。一个正确且高效的方法是使用一个优先队列来模拟工作节点的可用性，该队列以每个工作节点的下一个计算完成时间为键，并在工作节点变为空闲的确切时刻发布新的分配。您不得依赖任何外部库进行消息传递；这是一个纯粹的模拟。\n\n单位和数值规范：\n- 所有时间必须以秒表示。\n- 所有消息大小必须以字节表示。\n- 所有带宽必须以字节/秒表示。\n- 您的程序必须输出每个完工时间（秒），四舍五入到六位小数。\n\n测试套件：\n对于每个测试用例，指定 $(W, \\{c_i\\}, L, B, s_\\mathrm{req}, s_\\mathrm{resp})$ 并计算 $T_\\mathrm{end}$。\n\n- 测试 1 (一般情况):\n  - $W = 3$\n  - $\\{c_i\\} = [2.0, 3.0, 7.0, 1.0, 4.0]$ (秒)\n  - $L = 0.1$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 1000$ (字节)\n  - $s_\\mathrm{resp} = 1000$ (字节)\n- 测试 2 (零通信成本的边界情况):\n  - $W = 1$\n  - $\\{c_i\\} = [1.0, 2.0, 3.0]$ (秒)\n  - $L = 0.0$ (秒)\n  - $B = \\infty$ (字节/秒)\n  - $s_\\mathrm{req} = 100$ (字节)\n  - $s_\\mathrm{resp} = 100$ (字节)\n- 测试 3 (延迟主导的微任务):\n  - $W = 2$\n  - $\\{c_i\\} = [0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05, 0.05]$ (秒)\n  - $L = 0.2$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 100$ (字节)\n  - $s_\\mathrm{resp} = 100$ (字节)\n- 测试 4 (大量工作节点，少量任务):\n  - $W = 10$\n  - $\\{c_i\\} = [5.0, 1.0, 2.0]$ (秒)\n  - $L = 0.05$ (秒)\n  - $B = 10^6$ (字节/秒)\n  - $s_\\mathrm{req} = 500$ (字节)\n  - $s_\\mathrm{resp} = 500$ (字节)\n- 测试 5 (带宽主导的消息):\n  - $W = 4$\n  - $\\{c_i\\} = [0.5, 1.5, 0.7, 2.0, 1.2, 0.3, 0.9]$ (秒)\n  - $L = 0.02$ (秒)\n  - $B = 2 \\times 10^3$ (字节/秒)\n  - $s_\\mathrm{req} = 4000$ (字节)\n  - $s_\\mathrm{resp} = 8000$ (字节)\n\n最终输出格式：\n- 您的程序必须生成一行输出，包含对应于五个测试的五个完工时间，格式为逗号分隔的列表并用方括号括起来，例如 $[x_1, x_2, x_3, x_4, x_5]$，其中每个 $x_k$ 是以秒为单位、四舍五入到六位小数的完工时间。\n- 您的程序必须是自包含的，不得读取任何输入，也不得访问外部文件或网络。", "solution": "所提出的问题是一个有效且定义明确的计算系统建模练习。它是一个主/从并行计算模式的标准表述，植根于离散事件模拟和网络性能建模的基本原则。参数定义清晰，目标函数明确指定，调度策略是确定性的，这保证了唯一解。问题提供了一套具体的测试用例以供验证。我们将基于这些原则进行求解。\n\n系统动态由事件决定，特别是工作节点完成计算这一事件。这使得离散事件模拟成为自然且正确的方法。我们通过跟踪每个工作节点的可用性以及待调度任务的队列来对系统状态进行建模。管理工作节点可用性的最有效方法是使用优先队列，其中每个事件的优先级是其时间戳。\n\n设 $W$ 为工作节点数， $N$ 为任务数。任务 $i$ 的计算时间为 $c_i$。网络特性由单向延迟 $L$ 和带宽 $B$ 决定。大小为 $s$ 的请求消息的单向传输时间由线性模型 $T(s) = L + s/B$ 给出。我们约定如果 $B = \\infty$，则 $s/B$ 项为 $0$。\n\n由此，我们定义请求传输时间 $T_\\mathrm{req} = T(s_\\mathrm{req})$ 和响应传输时间 $T_\\mathrm{resp} = T(s_\\mathrm{resp})$。\n\n一个在时间 $t_\\mathrm{assign}$ 分配的任务将在时间 $t_\\mathrm{assign} + T_\\mathrm{req}$ 在工作节点上开始计算。计算本身需要 $c_i$ 秒。因此，工作节点在时间 $t_\\mathrm{finish\\_compute} = t_\\mathrm{assign} + T_\\mathrm{req} + c_i$ 完成计算。完成后，工作节点立即变得可用，可以被分配新任务。然后发送结果消息，在时间 $t_\\mathrm{result\\_arrival} = t_\\mathrm{finish\\_compute} + T_\\mathrm{resp}$ 到达主节点。总目标是找到完工时间 $T_\\mathrm{end}$，即主节点接收到最后一个结果消息的时间：\n$$\nT_\\mathrm{end} = \\max_{i=1,\\dots,N} \\{t_\\mathrm{result\\_arrival}^{(i)}\\}\n$$\n其中 $t_\\mathrm{result\\_arrival}^{(i)}$ 是任务 $i$ 的结果到达时间。\n\n我们模拟的核心是一个优先队列，我们称之为 `worker_events`。这个数据结构将存储对应于工作节点完成其计算的事件。队列中的每个元素都是一个元组 $(t, w)$，表示工作节点 $w$ 将在时间 $t$ 完成其当前计算。优先队列按时间 $t$ 排序，因此我们总能高效地检索到下一个变为空闲的工作节点。\n\n模拟过程如下：\n\n1.  **初始化**：\n    *   初始化一个变量 `makespan` 为 $0$。\n    *   初始化一个未分配任务的队列，按其给定的顺序排列。设 `next_task_idx` 是下一个要分配的任务的索引。\n    *   在模拟时间 $t=0$ 时，主节点分配前 $\\min(W, N)$ 个任务。对于这些初始任务中的每一个 $i \\in \\{0, 1, \\dots, \\min(W, N)-1\\}$，分配给工作节点 $i$：\n        *   分配时间为 $t_i^\\mathrm{assign} = 0$。\n        *   计算完成时间为 $t_{i}^\\mathrm{finish\\_compute} = 0 + T_\\mathrm{req} + c_i$。\n        *   将事件 $(t_{i}^\\mathrm{finish\\_compute}, i)$ 推入 `worker_events` 优先队列。\n        *   结果到达时间为 $t_{i}^\\mathrm{result\\_arrival} = t_{i}^\\mathrm{finish\\_compute} + T_\\mathrm{resp}$。\n        *   更新 `makespan` = $\\max(\\text{makespan}, t_{i}^\\mathrm{result\\_arrival})$。\n    *   设置 `next_task_idx` 为 $\\min(W, N)$。\n\n2.  **模拟循环**：\n    *   只要还有待分配的任务（即 `next_task_idx`  $N$），此循环就继续。\n    *   从 `worker_events` 中提取时间最小的事件。这给出 $(t_\\mathrm{finish}, w_\\mathrm{free})$，即工作节点 $w_\\mathrm{free}$ 变为空闲的时间。\n    *   问题陈述，新任务在工作节点变为空闲的确切时刻被分配。因此，下一个任务（假设其索引为 $j = \\text{next\\_task\\_idx}$）的分配时间是 $t_j^\\mathrm{assign} = t_\\mathrm{finish}$。\n    *   在工作节点 $w_\\mathrm{free}$ 上调度这个新任务 $j$：\n        *   该工作节点新的计算完成时间为 $t_{j}^\\mathrm{finish\\_compute} = t_j^\\mathrm{assign} + T_\\mathrm{req} + c_j$。\n        *   将新事件 $(t_{j}^\\mathrm{finish\\_compute}, w_\\mathrm{free})$ 推入 `worker_events` 优先队列。\n        *   任务 $j$ 的结果到达时间为 $t_{j}^\\mathrm{result\\_arrival} = t_{j}^\\mathrm{finish\\_compute} + T_\\mathrm{resp}$。\n        *   更新 `makespan` = $\\max(\\text{makespan}, t_{j}^\\mathrm{result\\_arrival})$。\n    *   递增 `next_task_idx`。\n\n3.  **终止**：\n    *   当 `next_task_idx` 达到 $N$ 时，循环终止，意味着所有任务都已调度。`makespan` 变量持有的最终值是所有结果到达时间的最大值，这正是 $T_\\mathrm{end}$ 的定义。\n\n该算法正确地模拟了指定的系统，并将被实现以解决给定的测试用例。Python的 `heapq` 模块提供了合适的最小优先队列实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print results.\n    \"\"\"\n    # Test cases defined as tuples:\n    # (W, {c_i}, L, B, s_req, s_resp)\n    test_cases = [\n        # Test 1 (general case)\n        (3, [2.0, 3.0, 7.0, 1.0, 4.0], 0.1, 1e6, 1000, 1000),\n        # Test 2 (boundary with zero communication cost)\n        (1, [1.0, 2.0, 3.0], 0.0, np.inf, 100, 100),\n        # Test 3 (latency-dominated micro-tasks)\n        (2, [0.05] * 10, 0.2, 1e6, 100, 100),\n        # Test 4 (many workers, few tasks)\n        (10, [5.0, 1.0, 2.0], 0.05, 1e6, 500, 500),\n        # Test 5 (bandwidth-dominated messages)\n        (4, [0.5, 1.5, 0.7, 2.0, 1.2, 0.3, 0.9], 0.02, 2e3, 4000, 8000),\n    ]\n\n    results = []\n    for case in test_cases:\n        makespan = simulate_master_worker(*case)\n        results.append(f\"{makespan:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef simulate_master_worker(W, c_tasks, L, B, s_req, s_resp):\n    \"\"\"\n    Implements a discrete-event simulation of a master/worker computation.\n\n    Args:\n        W (int): Number of workers.\n        c_tasks (list[float]): List of compute times for each task.\n        L (float): One-way network latency in seconds.\n        B (float): Network bandwidth in bytes per second.\n        s_req (float): Request message size in bytes.\n        s_resp (float): Response message size in bytes.\n\n    Returns:\n        float: The total completion time (makespan) in seconds.\n    \"\"\"\n    num_tasks = len(c_tasks)\n    if num_tasks == 0:\n        return 0.0\n\n    # Calculate one-way transfer times for request and response messages\n    if B == np.inf:\n        t_req = L\n        t_resp = L\n    else:\n        t_req = L + s_req / B\n        t_resp = L + s_resp / B\n\n    # Priority queue stores events of workers finishing computation.\n    # Each item is a tuple: (finish_compute_time, worker_id).\n    worker_events = []\n    \n    # Track the overall makespan (time last result is received by master).\n    makespan = 0.0\n    \n    # Index for the next task to be assigned from the c_tasks list.\n    next_task_idx = 0\n\n    # Initial phase: Assign tasks to all available workers at time t=0.\n    num_initial_tasks = min(W, num_tasks)\n    for i in range(num_initial_tasks):\n        c_i = c_tasks[i]\n        worker_id = i\n        \n        # Assignment time is 0 for the initial batch of tasks.\n        t_assign = 0.0\n        \n        # A worker finishes its computation at t_assign + network_delay + compute_time.\n        finish_compute_time = t_assign + t_req + c_i\n        \n        # The result for this task arrives at the master after the response message is sent.\n        result_arrival_time = finish_compute_time + t_resp\n        \n        # Update the makespan with the latest result arrival.\n        makespan = max(makespan, result_arrival_time)\n        \n        # Add a \"worker free\" event to the priority queue.\n        heapq.heappush(worker_events, (finish_compute_time, worker_id))\n        \n        next_task_idx += 1\n\n    # Main simulation loop: process events until all tasks are assigned.\n    while next_task_idx  num_tasks:\n        # Get the next worker to become free from the priority queue.\n        # This event defines the current simulation time for the new assignment.\n        finish_compute_time, worker_id = heapq.heappop(worker_events)\n        \n        # The worker becomes free at finish_compute_time. This is the assignment\n        # time for the next task scheduled on this worker.\n        t_assign = finish_compute_time\n        \n        # Get the compute time for the next task in the queue.\n        c_i = c_tasks[next_task_idx]\n        \n        # Schedule the new task on the now-free worker.\n        new_finish_compute_time = t_assign + t_req + c_i\n        new_result_arrival_time = new_finish_compute_time + t_resp\n        \n        # Update the overall makespan.\n        makespan = max(makespan, new_result_arrival_time)\n        \n        # Add the new event for this worker finishing its new task.\n        heapq.heappush(worker_events, (new_finish_compute_time, worker_id))\n        \n        next_task_idx += 1\n        \n    return makespan\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2413700"}, {"introduction": "在掌握了基本通信模式后，理解消息传递中的常见陷阱也同样重要。本练习将深入探讨“死锁（deadlock）”这一灾难性问题——当多个进程在循环等待彼此持有的资源时，系统将无法继续向前推进。通过模拟一个简单的环形通信场景，你将亲眼观察到有限的系统资源（如通信缓冲区）是如何导致死锁的，并从第一性原理出发，学习如何精确计算避免死锁所需的最小资源量 [@problem_id:2413727]。", "problem": "考虑一个离散、确定性的模拟，该模拟涉及$n$个排列成单向环的顺序进程之间的阻塞式消息传递。每个进程按固定顺序精确执行两个操作：(i) 向其后继进程阻塞式发送一个大小为$m$字节的单条消息，然后 (ii) 从其前驱进程阻塞式接收一个大小为$m$字节的单条消息。进程$i$的后继是$(i+1)\\bmod n$，前驱是$(i-1)\\bmod n$。存在一个大小为$S$字节的单一全局系统缓冲池，由所有发送操作共享。当且仅当全局缓冲池中当前至少有$m$字节可用时，发送操作才会成功；如果成功，它会将消息入队到目标的收件箱，并从缓冲池中精确消耗$m$字节。当且仅当接收者的收件箱当前至少包含一条消息时，接收操作才会成功；成功后，它会移除该消息并将$m$字节返回到全局缓冲池。所有信道都是可靠且无损的。没有进程会改变其操作顺序，也没有进程会执行任何其他操作。\n\n将死锁定义为这样一种状态：至少有一个进程尚未完成，且在当前全局缓冲区使用情况和收件箱内容的条件下，没有进程能够完成其下一步操作。模拟以确定性的轮询扫描方式重复地对进程$0,1,\\dots,n-1,0,1,\\dots$进行操作。在每次扫描中，每个进程都尝试执行其当前操作；如果操作的条件未满足，该进程在本次尝试中将保持对该操作的阻塞状态。模拟在所有进程都完成两个操作时终止，或者在至少有一个进程尚未完成的情况下，整次扫描没有任何操作成功（即发生死锁）时终止。\n\n任务：编写一个完整的程序，完全按照上述规范模拟此系统。对于下面的每个测试用例，运行模拟两次：\n- 首先，使用提供的元组$(n,m,S)$运行，并记录模拟是否以死锁结束（死锁记录布尔值$true$，否则记录$false$）。\n- 其次，在不改变发送/接收顺序或轮询调度的情况下，将$S$替换为保证此工作负载不会出现死锁的最小全局缓冲区大小$S_{\\text{fix}}$（以字节为单位），并记录在此修复配置下模拟是否以死锁结束。您必须从第一性原理出发确定$S_{\\text{fix}}$。\n\n所有字节量都应按字面意义解释为字节。此问题中没有其他单位。您的程序必须生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，顺序如下所述。对于每个测试用例，将布尔值对$[b_{\\text{orig}},b_{\\text{fix}}]$按测试用例列出的相同顺序平铺成一个列表输出。\n\n测试套件（每个元组为$(n,m,S)$，所有量纲均为字节）：\n- $(2,10,10)$\n- $(2,10,20)$\n- $(3,8,8)$\n- $(4,8,15)$\n- $(5,7,35)$\n\n因此，所要求的单行输出必须包含与这5个测试用例相对应的10个布尔值，每个测试用例按规定顺序贡献2个布尔值。输出格式必须严格为单行：\n\"[b1,b2,b3,b4,b5,b6,b7,b8,b9,b10]\"\n其中每个$b_i$是\"True\"或\"False\"。", "solution": "问题陈述需经过验证。\n\n步骤1：提取已知条件\n- 进程数量：$n$。\n- 进程排列成单向环，索引为$i \\in \\{0, 1, \\dots, n-1\\}$。\n- 进程$i$的后继是$(i+1)\\bmod n$。\n- 进程$i$的前驱是$(i-1)\\bmod n$。\n- 每个进程按顺序执行两个固定操作：(i) 阻塞式发送，然后 (ii) 阻塞式接收。\n- 消息大小：$m$字节。\n- 全局系统缓冲池大小：$S$字节。\n- 发送操作条件：如果可用缓冲区至少为$m$字节，则成功。成功时，从缓冲池中消耗$m$字节。\n- 接收操作条件：如果接收者的收件箱中至少有一条消息，则成功。成功时，向缓冲池返回$m$字节。\n- 模拟调度：对进程$0, 1, \\dots, n-1$进行确定性轮询扫描。\n- 死锁定义：至少有一个进程未完成，且整次扫描中没有任何成功的操作。\n- 终止条件：(i) 所有进程完成两个操作，或 (ii) 发生死锁。\n- 任务：对于每个给定的元组$(n,m,S)$：\n    1.  使用$(n,m,S)$进行模拟，并记录死锁状态$b_{\\text{orig}}$。\n    2.  确定不会导致死锁的最小缓冲区大小$S_{\\text{fix}}$。\n    3.  使用$(n,m,S_{\\text{fix}})$进行模拟，并记录死锁状态$b_{\\text{fix}}$。\n- 测试套件：$(2,10,10)$, $(2,10,20)$, $(3,8,8)$, $(4,8,15)$, $(5,7,35)$。\n\n步骤2：使用提取的已知条件进行验证\n- **科学性**：该问题描述了并发系统中的一个典型资源分配场景，特别是对通信死锁进行建模。该模型是计算机科学和计算工程中一个成熟的抽象概念。它是科学合理的。\n- **适定性**：系统的初始状态是隐式定义的（所有进程都处于`send`阶段，缓冲区处于满容量$S$，所有收件箱为空）。状态转换规则是确定且无歧义的。终止条件是明确的。对于任何给定的参数集，都存在一个唯一且有意义的结果。\n- **客观性**：问题陈述使用了精确、形式化的语言（“阻塞式发送”、“确定性轮询”、“当且仅当”）。所有参数都是定量的。它没有主观或含糊不清的术语。\n\n所有其他验证标准均已满足。该问题并非不健全、不可形式化、不完整、不现实、不适定或不可验证。\n\n步骤3：结论与行动\n问题有效。将提供解决方案。\n\n所描述的系统是通信顺序进程的离散时间模拟。这个问题的关键在于可能发生的死锁，即对共享资源的循环依赖。在这里，资源是全局缓冲区空间和消息本身。我们必须首先分析导致死锁的条件，以确定保证防止死锁的最小缓冲区大小$S_{\\text{fix}}$。然后，我们构建一个模拟程序来验证给定测试用例的行为。\n\n让我们分析系统动态。每个进程$i$的状态可以是三种之一：`SEND`、`RECEIVE`或`DONE`。初始时，所有$n$个进程都处于`SEND`状态，缓冲区持有$S$字节，所有消息收件箱都为空。模拟以扫描的方式进行，进程$0, 1, \\dots, n-1$按顺序尝试其操作。\n\n当且仅当系统达到一个状态，其中没有进程可以继续进行，但并非所有进程都处于`DONE`状态时，就会发生死锁。如果缓冲区中的字节数少于$m$，进程将在`SEND`上阻塞。如果进程的收件箱为空，它将在`RECEIVE`上阻塞。\n\n考虑初始的几次扫描。在第一次扫描中，所有进程都尝试发送。设$k_{\\max}$为在缓冲区耗尽前可以顺序发送的最大进程数。一个`SEND`操作消耗$m$字节，所以$k_{\\max}$次成功的发送会消耗$k_{\\max} \\cdot m$字节。这在$S \\ge k_{\\max} \\cdot m$时是可能的。第$(k_{\\max}+1)$个进程会失败，如果$S - k_{\\max} \\cdot m  m$。因此，$k_{\\max} = \\lfloor S/m \\rfloor$。为了使问题具有非平凡性，我们假设$S \\ge m$且$n \\ge 2$。因此，$k_{\\max} \\ge 1$。\n\n在基于轮询调度$0, 1, \\dots, n-1$的第一轮发送尝试之后：\n- 进程$0, 1, \\dots, k_{\\max}-1$成功发送并转换到`RECEIVE`状态。\n- 进程$k_{\\max}, \\dots, n-1$发送失败并保持在`SEND`状态阻塞。\n- 缓冲区大小减少到$S' = S - k_{\\max} \\cdot m$。根据$k_{\\max}$的定义，我们有$S'  m$。\n- 对于每个$i \\in \\{1, \\dots, k_{\\max}\\}$，进程$i$的收件箱中包含一条消息。其他收件箱为空。\n\n现在，考虑下一次扫描。\n- 任何进程$j \\in \\{k_{\\max}, \\dots, n-1\\}$都在`SEND`上阻塞，因为缓冲区大小$S'$小于$m$。\n- 如果进程$i \\in \\{0, \\dots, k_{\\max}-1\\}$的收件箱为空，它将在`RECEIVE`上阻塞。这意味着它的前驱进程$(i-1) \\bmod n$尚未成功发送消息。\n- 让我们检查`RECEIVE`状态的进程：\n    - 进程$0$正在等待来自进程$n-1$的消息。如果$k_{\\max}  n$，则进程$n-1$在`SEND`上阻塞。因此，进程$0$在`RECEIVE`上阻塞。\n    - 进程$i \\in \\{1, \\dots, k_{\\max}-1\\}$正在等待来自进程$i-1$的消息。在第一次扫描中，进程$i-1$已成功发送消息。因此，进程$i$的收件箱不为空。进程$i$可以成功接收。\n\n如果没有进程可以取得进展，就会发生死锁。`SEND`阻塞的进程无法进展。`RECEIVE`阻塞的进程只有在至少有一个可以接收的情况下才能进展。如上分析，进程$1, \\dots, k_{\\max}-1$能够接收。当且仅当这个可接收进程的集合为空时，才会发生死锁。\n集合$\\{1, \\dots, k_{\\max}-1\\}$为空的条件是$k_{\\max}-1  1$，简化为$k_{\\max}  2$。由于我们假设$S \\ge m$，$k_{\\max}$必须至少为$1$。因此，如果$k_{\\max} = 1$，则必然发生死锁。\n\n条件$k_{\\max} = 1$等价于$1 \\le S/m  2$，即$m \\le S  2m$。在这种情况下，只有进程$0$发送消息。然后它会阻塞，等待来自进程$n-1$的消息。所有其他进程$1, \\dots, n-1$都因缓冲区不足而在`SEND`上阻塞。没有进程可以继续进行，系统陷入死锁。\n\n为保证不发生死锁，我们必须确保避免这种情况。我们必须有$k_{\\max} \\ge 2$。这要求$S/m \\ge 2$，即$S \\ge 2m$。如果$S \\ge 2m$，那么至少进程$0$和$1$可以发送。在下一次扫描中，进程$1$可以接收，这会向缓冲区返回$m$字节。这可能允许进程$2$（如果它被阻塞了）发送，一个解锁事件的连锁反应会在系统中传播，最终导致所有进程完成。\n\n因此，对于任意数量的进程$n \\ge 2$，保证不发生死锁的最小全局缓冲区大小是$S_{\\text{fix}} = 2m$。\n\n程序将实现对该系统的直接模拟。对于每个测试用例$(n, m, S)$，它将首先使用提供的$S$运行模拟以找到$b_{\\text{orig}}$。然后它将计算$S_{\\text{fix}} = 2m$并使用该值再次运行模拟以找到$b_{\\text{fix}}$。模拟函数将维护每个进程的状态、每个收件箱的内容以及可用的缓冲区大小，执行扫描直到达到终止状态（所有进程`DONE`或死锁）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef simulate(n, m, S):\n    \"\"\"\n    Simulates the message passing system as described.\n\n    Args:\n        n (int): Number of processes.\n        m (int): Message size in bytes.\n        S (int): Global buffer size in bytes.\n\n    Returns:\n        bool: True if deadlock occurs, False otherwise.\n    \"\"\"\n    # States: 0=SEND, 1=RECEIVE, 2=DONE\n    process_states = [0] * n\n    inboxes = [[] for _ in range(n)]\n    buffer_size = S\n    \n    # Handle the trivial case where no process can ever send.\n    if S  m:\n        return True\n\n    while True:\n        num_done = sum(1 for state in process_states if state == 2)\n        if num_done == n:\n            return False  # Success, all processes are done\n\n        progress_in_sweep = False\n        for i in range(n):\n            state = process_states[i]\n\n            if state == 0:  # SEND\n                if buffer_size >= m:\n                    buffer_size -= m\n                    successor = (i + 1) % n\n                    inboxes[successor].append(1)  # Message content is irrelevant\n                    process_states[i] = 1\n                    progress_in_sweep = True\n            \n            elif state == 1:  # RECEIVE\n                if len(inboxes[i]) > 0:\n                    inboxes[i].pop(0)\n                    buffer_size += m\n                    process_states[i] = 2\n                    progress_in_sweep = True\n        \n        if not progress_in_sweep:\n            # If no progress was made, check if we are done or deadlocked.\n            # The check for all_done is at the start of the loop.\n            # So if we are here with no progress, it must be a deadlock.\n            return True  # Deadlock\n\ndef solve():\n    \"\"\"\n    Runs the simulation for all test cases and prints the results.\n    \"\"\"\n    test_cases = [\n        # (n, m, S)\n        (2, 10, 10),\n        (2, 10, 20),\n        (3, 8, 8),\n        (4, 8, 15),\n        (5, 7, 35),\n    ]\n\n    results = []\n    for n, m, S in test_cases:\n        # Run original simulation\n        b_orig = simulate(n, m, S)\n        results.append(b_orig)\n\n        # Determine S_fix and run fixed simulation\n        # As derived, the minimal buffer size to avoid deadlock for n >= 2\n        # is 2*m, as this ensures at least two processes can send,\n        # allowing the second one to eventually receive and replenish the buffer.\n        S_fix = 2 * m\n        b_fix = simulate(n, m, S_fix)\n        results.append(b_fix)\n\n    # Format output as a single line: \"[True,False,True,...]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2413727"}, {"introduction": "在点对点消息传递的基础上，我们可以构建更强大、更高级的抽象。最后的这个练习将挑战你仅使用基本的发送和接收操作来实现一个功能强大的集体操作——$\\mathrm{MPI\\_Allreduce}$。这个练习将揭示高性能计算库背后优雅的并行算法（如“递归倍增法”），并展示如何高效且可扩展地构建复杂的全局数据操作，这对于编写可扩展到大规模处理器的并行代码至关重要 [@problem_id:2413720]。", "problem": "给定一个消息传递接口（MPI）的计算模型，该模型仅限于点对点操作。考虑一组 $P$ 个逻辑进程，其秩为 $r \\in \\{0,1,\\dots,P-1\\}$，其中 $P$ 是 $2$ 的幂。每个进程 $r$ 最初持有一个整数值 $x_r$。进程以同步轮次执行，轮次索引为 $k \\in \\{0,1,\\dots,R-1\\}$，其中 $R=\\log_2 P$。在每一轮 $k$ 中，进程 $r$ 被允许执行恰好一次点对点发送和一次点对点接收。在第 $k$ 轮中，进程 $r$ 允许的通信伙伴是进程 $r \\oplus 2^k$，其中 $\\oplus$ 表示按位异或。第 $k$ 轮的通信定义如下：进程 $r$ 必须将其当前整数发送给进程 $r \\oplus 2^k$，并且必须从进程 $r \\oplus 2^k$ 接收一个整数。在第 $k$ 轮接收完成后，进程 $r$ 必须通过整数加法将其当前整数与接收到的整数相加来更新其值。\n\n在 $R$ 轮之后，要求每个进程中的最终整数等于全局总和 $S=\\sum_{i=0}^{P-1} x_i$。点对点消息的数量定义为所有进程在所有轮次中的发送总数。在上述约束下，总轮次数为 $R=\\log_2 P$，并且在每一轮中恰好发生 $P$ 次发送，因此预期的消息总数为 $P \\log_2 P$。\n\n您的任务是编写一个完整的程序，精确地模拟上述模型，并为下面的每个测试用例返回一个布尔值。当且仅当以下两个条件都成立时，该值为真：(i) 在最后一轮之后，每个进程都持有正确的最终整数 $S$，以及 (ii) 点对点消息的总数等于 $P \\log_2 P$。否则，为该测试用例返回假。\n\n测试套件：\n- 情况 A：$P=1$，初始值 $[42]$。预期 $R=\\log_2 1=0$ 轮和 $P \\log_2 P = 1 \\cdot 0 = 0$ 条消息。\n- 情况 B：$P=2$，初始值 $[5,-3]$。预期 $R=\\log_2 2 = 1$ 轮和 $P \\log_2 P = 2 \\cdot 1 = 2$ 条消息。\n- 情况 C：$P=4$，初始值 $[-10,20,0,5]$。预期 $R=\\log_2 4 = 2$ 轮和 $P \\log_2 P = 4 \\cdot 2 = 8$ 条消息。\n- 情况 D：$P=8$，初始值 $[1,2,3,4,5,6,7,8]$。预期 $R=\\log_2 8 = 3$ 轮和 $P \\log_2 P = 8 \\cdot 3 = 24$ 条消息。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含四个测试用例的结果，格式为方括号内以逗号分隔的布尔值列表，无空格，顺序为 A、B、C、D。例如，如果所有四个条件都满足，则输出单行“[True,True,True,True]”。", "solution": "问题陈述已经过严格验证，并被认定为有效。\n\n**第 1 步：提取已知信息**\n\n- 一组 $P$ 个逻辑进程，其秩为 $r \\in \\{0, 1, \\dots, P-1\\}$。\n- $P$ 是 $2$ 的幂。\n- 每个进程 $r$ 最初拥有一个整数值 $x_r$。\n- 模拟以同步轮次进行，轮次索引为 $k \\in \\{0, 1, \\dots, R-1\\}$，其中 $R=\\log_2 P$。\n- 在每一轮 $k$ 中，进程 $r$ 执行一次向进程 $r \\oplus 2^k$ 的发送操作和一次从该进程的接收操作，其中 $\\oplus$ 是按位异或运算符。\n- 进程 $r$ 在第 $k$ 轮接收到一个值后的更新规则是将其当前整数与接收到的整数相加。\n- 最终条件要求在 $R$ 轮后，每个进程 $r$ 都持有全局总和 $S=\\sum_{i=0}^{P-1} x_i$。\n- 点对点消息的数量是所有进程在所有轮次中的发送总数。预期的总数是 $P \\log_2 P$。\n- 任务是为每个测试用例返回一个布尔值，当且仅当最终值条件和总消息计数条件都满足时，该值为真。\n- 测试用例：\n  - A：$P=1$，初始值 $[42]$。\n  - B：$P=2$，初始值 $[5,-3]$。\n  - C：$P=4$，初始值 $[-10,20,0,5]$。\n  - D：$P=8$，初始值 $[1,2,3,4,5,6,7,8]$。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n- **科学依据**：该问题描述了一种著名的并行算法，特别是在超立方体拓扑上的全归约（all-reduce）操作。进程及其秩可以看作是 $d$ 维超立方体的顶点，其中 $d = \\log_2 P$。通信伙伴规则 $r \\leftrightarrow r \\oplus 2^k$ 定义了沿着该超立方体第 $k$ 维的通信。指定的更新规则是基于前缀和的全归约操作的标准过程。该问题在科学上和算法上都是合理的。\n- **适定性**：初始状态、通信规则和更新规则都是确定性的。对于任何给定的输入，系统的最终状态是唯一的。验证标准是客观且可量化的。\n- **完整性和一致性**：问题是自包含的。所有必要的参数（$P$、初始值）和规则都已提供。定义是精确的。特殊情况 $P=1$ 意味着 $R=\\log_2 1 = 0$ 轮和 $P \\log_2 P = 0$ 条消息，这在数学上是一致的，并且可以通过零迭代循环正确处理。没有矛盾之处。\n\n**第 3 步：结论与行动**\n\n该问题是有效的。它是一个适定的、有科学依据的问题，要求模拟和验证一个标准的并行算法。将提供一个解决方案。\n\n**解决方案设计**\n\n该问题要求直接模拟所描述的消息传递模型。解决方案的核心是在 $R = \\log_2 P$ 个同步轮次中准确地模拟 $P$ 个进程的状态。\n\n系统在任何时刻的状态都可以用一个包含 $P$ 个整数的向量（一个数组）表示，我们可以将其表示为 $\\mathbf{x}$。最初，这个向量是 $\\mathbf{x}[0] = [x_0, x_1, \\dots, x_{P-1}]$。\n\n模拟对从 $0$ 到 $R-1$ 的每一轮 $k$ 进行迭代。同步模型的一个关键方面是，一轮内的所有通信都基于该轮开始时的状态。因此，更新不能“就地”应用，因为这会产生数据竞争，即一个进程可能会使用在同一轮内已经被更新的值。为了防止这种情况，需要一个临时缓冲区或第二个向量，比如 $\\mathbf{x}'$，来存储当前轮计算的结果。\n\n对于每一轮 $k \\in \\{0, 1, \\dots, R-1\\}$：\n1. 初始化一个临时向量 $\\mathbf{x}'$ 以保存下一轮的值。\n2. 对于每个进程 $r \\in \\{0, 1, \\dots, P-1\\}$：\n   a. 识别通信伙伴：$p = r \\oplus 2^k$。\n   b. 进程 $r$ 从进程 $p$ 接收到的值是进程 $p$ 在该轮开始时持有的值，即 $x_p[k]$。\n   c. 根据更新规则计算进程 $r$ 的新值：$x'_r = x_r[k] + x_p[k]$。\n3. 在所有进程都更新完毕后，将下一轮的状态 $\\mathbf{x}[k+1]$ 设置为计算出的临时向量 $\\mathbf{x}'$。\n\n这个迭代过程重复进行 $R = \\log_2 P$ 轮。\n\n点对点消息的总数也会被跟踪。在 $R$ 轮中的每一轮， $P$ 个进程中的每一个都执行恰好一次发送操作。因此，每一轮都会为总计数贡献 $P$ 条消息。在 $R$ 轮中，消息总数为 $P \\times R = P \\log_2 P$，这与问题中陈述的预期相符。\n\n在所有 $R$ 轮完成后，必须验证两个条件：\n1. **最终值条件**：每个进程中的最终值 $x_r[R]$ 必须等于全局总和 $S = \\sum_{i=0}^{P-1} x_i[0]$。通过从初始值计算 $S$ 并将其与最终状态向量 $\\mathbf{x}[R]$ 的每个元素进行比较来执行此检查。\n2. **消息计数条件**：累积的消息总数必须等于理论值 $P \\log_2 P$。\n\n当且仅当这两个条件都满足时，测试用例的评估结果为真。将实现模拟以对每个提供的测试用例运行。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Simulates a message passing model and verifies the outcome against specified conditions.\n    \"\"\"\n    test_cases = [\n        # Case A\n        (1, [42]),\n        # Case B\n        (2, [5, -3]),\n        # Case C\n        (4, [-10, 20, 0, 5]),\n        # Case D\n        (8, [1, 2, 3, 4, 5, 6, 7, 8]),\n    ]\n    \n    results = []\n\n    for case in test_cases:\n        P, initial_x = case\n        \n        # Use 64-bit integers to avoid overflow with large sums, although\n        # Python's native integers have arbitrary precision. Numpy is used\n        # for convenience and adherence to problem constraints.\n        values = np.array(initial_x, dtype=np.int64)\n        \n        # Calculate the number of rounds, R = log2(P).\n        # For P=1, log2(1)=0, so R=0 rounds.\n        # This is safe because P is guaranteed to be a power of 2.\n        R = 0\n        if P > 1:\n            R = int(np.log2(P))\n\n        total_messages = 0\n        \n        # Simulate R synchronous rounds.\n        for k in range(R):\n            # A temporary array is necessary to store the results of the synchronous round\n            # to prevent data races (i.e., using a value updated in the same round).\n            next_values = np.zeros_like(values)\n            \n            for r in range(P):\n                # Determine the communication partner in round k.\n                # The partner is r XOR 2^k. (1  k) is a fast way to compute 2^k.\n                partner = r ^ (1  k)\n                \n                # Each process r sends its current value to its partner and receives\n                # the partner's value. The new value is the sum of its own old value\n                # and the received value.\n                # Note: values[partner] refers to the value at the start of the round.\n                received_value = values[partner]\n                next_values[r] = values[r] + received_value\n            \n            # After all processes compute their next value, update the state for the next round.\n            values = next_values\n            \n            # In each round, P processes each perform one send.\n            total_messages += P\n\n        # --- Verification ---\n\n        # Condition 1: Verify all processes hold the correct global sum.\n        expected_sum = np.sum(np.array(initial_x, dtype=np.int64))\n        final_values_correct = np.all(values == expected_sum)\n        \n        # Condition 2: Verify the total number of messages.\n        expected_messages = P * R\n        message_count_correct = (total_messages == expected_messages)\n        \n        # The result is True if and only if both conditions are met.\n        result = final_values_correct and message_count_correct\n        results.append(result)\n\n    # Format the final output as specified: a comma-separated list of booleans.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2413720"}]}