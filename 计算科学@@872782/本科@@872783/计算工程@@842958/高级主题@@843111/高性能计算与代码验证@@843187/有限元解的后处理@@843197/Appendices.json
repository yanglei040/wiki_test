{"hands_on_practices": [{"introduction": "在获得有限元分析结果后，一个关键的后处理步骤是验证其物理合理性。本练习将通过一个简单的热传导问题，让你亲手验证一个基本物理原理：能量守恒。你将使用傅里叶定律，根据给定的节点温度计算进出内部节点的净热流率，从而直观地理解有限元法如何在离散层面确保守恒定律的成立 ([@problem_id:2426726])。", "problem": "考虑沿 $x$ 轴排列的复合杆中的稳态一维热传导，该复合杆由两个线性有限元组成，节点位置分别为 $x_0=0$ m、$x_1=0.3$ m 和 $x_2=0.5$ m。横截面积恒定，为 $A=0.01 \\text{ m}^2$。热导率是分段恒定的：在区间 $[x_0,x_1]$ 上为 $k_1=48 \\text{ W m}^{-1} \\text{ K}^{-1}$，在区间 $[x_1,x_2]$ 上为 $k_2=32 \\text{ W m}^{-1} \\text{ K}^{-1}$。杆内任何地方都没有内部热源，内部节点 $x_1$ 处也没有集中的热源或热汇。一次有限元分析得出了以下节点温度：$x_0$ 处为 $T_0=120$ K，$x_1$ 处为 $T_1=100$ K，$x_2$ 处为 $T_2=80$ K。\n\n将进入节点 $x_1$ 的净热流率定义为从左侧单元进入的热流率与从右侧单元进入的热流率的代数和（规定进入节点的热量为正）。仅使用第一性原理，根据给定的节点温度和材料数据，确定进入节点 $x_1$ 的净热流率。最终答案以瓦特（W）为单位表示，并四舍五入至四位有效数字。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n步骤1：提取已知条件\n问题陈述中提供了以下数据：\n- 节点位置：$x_0 = 0$ m、$x_1 = 0.3$ m、$x_2 = 0.5$ m。\n- 横截面积：$A = 0.01 \\text{ m}^2$（恒定）。\n- 单元1（在 $[x_0, x_1]$ 上）的热导率：$k_1 = 48 \\text{ W m}^{-1} \\text{ K}^{-1}$。\n- 单元2（在 $[x_1, x_2]$ 上）的热导率：$k_2 = 32 \\text{ W m}^{-1} \\text{ K}^{-1}$。\n- 条件：无内部热源。\n- 条件：节点 $x_1$ 处无集中热源或热汇。\n- 有限元分析得出的节点温度：$T_0 = 120$ K、$T_1 = 100$ K、$T_2 = 80$ K。\n- 定义：进入节点 $x_1$ 的净热流率是从左侧单元进入的热流率和从右侧单元进入的热流率的代数和。\n- 符号约定：正号表示热量进入节点。\n\n步骤2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于稳态热传导的基本原理，特别是傅里叶定律。使用线性有限元是计算工程中的一种标准技术。这是一个适定问题；它提供了计算所求量所需的所有信息——几何、材料和热学信息。语言客观而精确。所有术语都有明确的定义。问题不包含任何科学上的不准确、矛盾或模糊之处。所提供的数据在物理上是一致的。该问题要求基于一组给定的数据进行计算，这是工程分析中的标准程序。\n\n步骤3：结论与行动\n问题被认为是有效的。将提供解答。\n\n控制一维稳态热传导的基本原理是傅里叶定律，该定律指出热流率 $q$ 与面积 $A$ 和温度梯度 $\\frac{dT}{dx}$ 成正比。其表达式为：\n$$q = -kA \\frac{dT}{dx}$$\n对于线性有限元，温度在节点之间呈线性变化。因此，单元内的温度梯度是恒定的，可以近似为节点温度差除以单元长度。\n\n我们必须计算进入节点 $x_1$ 的净热流率。这是从左侧单元（单元1）进入的热流率与从右侧单元（单元2）进入的热流率之和。\n\n首先，考虑从单元1进入节点 $x_1$ 的热流率，该单元跨越区间 $[x_0, x_1]$。我们将此热流率表示为 $q_{1 \\to 1}$。这是在 $x = x_1$ 处评估的沿正 $x$ 方向的热流。单元1的长度为 $L_1 = x_1 - x_0 = 0.3 - 0 = 0.3$ m。该单元内的温度梯度为：\n$$\\left(\\frac{dT}{dx}\\right)_1 = \\frac{T_1 - T_0}{L_1} = \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = \\frac{-20}{0.3} \\text{ K/m}$$\n在正 $x$ 方向上流过单元1的热流率是恒定的，由傅里叶定律给出：\n$$q_{1 \\to 1} = -k_1 A \\left(\\frac{dT}{dx}\\right)_1 = -k_1 A \\frac{T_1 - T_0}{L_1}$$\n代入给定值：\n$$q_{1 \\to 1} = -(48 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{100 \\text{ K} - 120 \\text{ K}}{0.3 \\text{ m}} = -0.48 \\left(\\frac{-20}{0.3}\\right) \\text{ W} = 32 \\text{ W}$$\n由于 $q_{1 \\to 1}$ 为正，这表示热量沿正 $x$ 方向流动，因此是从左侧进入节点 $x_1$。\n\n接下来，考虑从单元2进入节点 $x_1$ 的热流率，该单元跨越区间 $[x_1, x_2]$。我们将此热流率表示为 $q_{2 \\to 1}$。单元2的长度为 $L_2 = x_2 - x_1 = 0.5 - 0.3 = 0.2$ m。该单元内的温度梯度为：\n$$\\left(\\frac{dT}{dx}\\right)_2 = \\frac{T_2 - T_1}{L_2} = \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = \\frac{-20}{0.2} \\text{ K/m} = -100 \\text{ K/m}$$\n流经单元2的沿正 $x$ 方向的热流率，我们称之为 $q_2$，为：\n$$q_2 = -k_2 A \\left(\\frac{dT}{dx}\\right)_2 = -k_2 A \\frac{T_2 - T_1}{L_2}$$\n这个量 $q_2$ 代表离开节点 $x_1$ 流入单元2的热量。根据指定的符号约定，从单元2进入节点 $x_1$ 的热流率是 $q_2$ 的负值。\n$$q_{2 \\to 1} = -q_2 = - \\left( -k_2 A \\frac{T_2 - T_1}{L_2} \\right) = k_2 A \\frac{T_2 - T_1}{L_2}$$\n代入给定值：\n$$q_{2 \\to 1} = (32 \\text{ W m}^{-1} \\text{K}^{-1})(0.01 \\text{ m}^2) \\frac{80 \\text{ K} - 100 \\text{ K}}{0.2 \\text{ m}} = 0.32 \\left(\\frac{-20}{0.2}\\right) \\text{ W} = -32 \\text{ W}$$\n负号表示热量从节点 $x_1$ 流出并进入单元2。这与温度情况一致，因为热量从较热的节点 $T_1 = 100$ K 流向较冷的节点 $T_2 = 80$ K。\n\n进入节点 $x_1$ 的净热流率，记为 $Q_{net,1}$，是从每个单元进入该节点的各热流率的代数和：\n$$Q_{net,1} = q_{1 \\to 1} + q_{2 \\to 1}$$\n$$Q_{net,1} = 32 \\text{ W} + (-32 \\text{ W}) = 0 \\text{ W}$$\n这个结果是符合预期的。对于一个没有内部热源、内部节点处也没有集中热源或热汇的稳态问题，能量守恒原理规定流入该节点的净热流必须为零。给定的节点温度是有限元方程的精确解，这些方程在每个内部节点上强制执行这种能量平衡。\n\n问题要求答案四舍五入到四位有效数字。由于结果恰好为零，应以反映此精度的格式表示。\n$$Q_{net,1} = 0.0000 \\text{ W}$$", "answer": "$$\\boxed{0.0000}$$", "id": "2426726"}, {"introduction": "有限元分析通常得到的是基于单元的、在单元边界上可能不连续的结果（例如应力）。为了生成平滑的云图以便于可视化，需要将这些数据处理成连续的节点值。本练习要求你通过编程实现一种常见的后处理技术——节点平均法，其中节点值是其所有相邻单元值的加权平均 [@problem_id:2426709]。通过这个实践，你将揭示后处理软件从原始单元数据生成平滑云图的内在机制。", "problem": "在二维域上的有限元计算会产生以单元为中心的标量值。对于每个单元 $e$，给定一个单一的标量值 $q_e$（例如，平均单元应力或能量密度）。考虑具有三个节点的线性三角形单元和具有四个节点的轴对齐矩形四边形单元。将单元 $e$ 对节点 $i$ 的贡献面积 $A_{e,i}$ 定义为与节点 $i$ 关联的单元标量形函数在整个单元上的积分。对于所考虑的单元类型，此贡献面积等于单元面积除以单元节点数。节点 $i$ 处的节点平均标量 $q_i$ 应定义为所有相连单元值的加权平均值，权重为贡献面积：\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}},\n$$\n其中 $\\mathcal{E}(i)$ 是包含节点 $i$ 的单元集合。对于面积为 $A_e$ 的线性三角形， $A_{e,i} = A_e/3$。对于面积为 $A_e$ 的轴对齐矩形， $A_{e,i} = A_e/4$。\n\n设顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$ 的三角形面积 $A_e$ 通过以下公式计算\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,x_1\\,(y_2 - y_3) + x_2\\,(y_3 - y_1) + x_3\\,(y_1 - y_2)\\,\\right|.\n$$\n设顶点为 $(x_1,y_1)$、$(x_2,y_2)$、$(x_3,y_3)$、$(x_4,y_4)$（按逆时针或顺时针顺序列出）的矩形面积 $A_e$ 通过多边形公式计算\n$$\nA_e \\;=\\; \\frac{1}{2}\\,\\left|\\,\\sum_{k=1}^{4} x_k\\,y_{k+1} - y_k\\,x_{k+1}\\,\\right|, \\quad \\text{with } (x_{5},y_{5}) \\equiv (x_1,y_1).\n$$\n假设测试中的所有矩形都是轴对齐的。\n\n给定以下包含独立网格的测试套件，每个网格都包含节点坐标、单元连接关系、单元中心标量和一个指定的目标节点，请为每个网格计算指定节点上的节点平均标量。在单元连接关系中使用从零开始的节点索引。\n\n测试用例 1 (矩形和三角形混合，共享节点):\n- 节点:\n  - 节点 0: $(0,0)$\n  - 节点 1: $(2,0)$\n  - 节点 2: $(2,1)$\n  - 节点 3: $(0,1)$\n  - 节点 4: $(3,0)$\n  - 节点 5: $(3,1)$\n- 单元:\n  - 单元 0: 类型 quad4，连接关系 $[0,1,2,3]$，$q_{0} = 10$\n  - 单元 1: 类型 tri3，连接关系 $[2,4,5]$，$q_{1} = 4$\n- 目标节点: $2$\n\n测试用例 2 (单个三角形与目标节点关联):\n- 节点:\n  - 节点 0: $(0,0)$\n  - 节点 1: $(1,0)$\n  - 节点 2: $(0,2)$\n- 单元:\n  - 单元 0: 类型 tri3，连接关系 $[0,1,2]$，$q_{0} = 7$\n- 目标节点: $0$\n\n测试用例 3 (两个三角形组成一个正方形，面积相等，单元值不同):\n- 节点:\n  - 节点 0: $(0,0)$\n  - 节点 1: $(1,0)$\n  - 节点 2: $(1,1)$\n  - 节点 3: $(0,1)$\n- 单元:\n  - 单元 0: 类型 tri3，连接关系 $[0,1,2]$，$q_{0} = 9$\n  - 单元 1: 类型 tri3，连接关系 $[0,2,3]$，$q_{1} = 3$\n- 目标节点: $2$\n\n测试用例 4 (单个矩形与目标节点关联):\n- 节点:\n  - 节点 0: $(0,0)$\n  - 节点 1: $(3,0)$\n  - 节点 2: $(3,2)$\n  - 节点 3: $(0,2)$\n- 单元:\n  - 单元 0: 类型 quad4，连接关系 $[0,1,2,3]$，$q_{0} = 5$\n- 目标节点: $1$\n\n您的程序必须严格按照定义实现节点平均方案，使用上述面积公式，并按顺序为每个测试用例计算指定节点上的值 $q_i$。最终输出必须是单行，其中包含一个用括号括起来的、以逗号分隔的浮点数列表，每个数字在小数点后打印恰好六位，按顺序对应于测试用例 1 到 4。例如，您的程序应打印一行形如\n$[v_1,v_2,v_3,v_4]$\n的内容，其中每个 $v_k$ 的格式为小数点后恰好六位数字。不应打印任何额外文本。", "solution": "问题陈述经过了验证，并被认定是有效的。它具有科学依据、内容自洽且适定。它描述了一种在有限元分析结果的后处理中常用的标准节点平均程序。所提供的数据、定义和公式在数学上是一致的，足以推导出每个测试用例的唯一解。\n\n核心任务是通过对连接到特定节点 $i$ 的所有单元的标量值 $q_e$ 进行加权平均，来计算该节点上的节点标量值 $q_i$。公式如下：\n$$\nq_i \\;=\\; \\frac{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}\\, q_e}{\\sum_{e \\in \\mathcal{E}(i)} A_{e,i}}\n$$\n此处，$\\mathcal{E}(i)$ 是连接到节点 $i$ 的单元集合，而 $A_{e,i}$ 是单元 $e$ 对节点 $i$ 的贡献面积。这个贡献面积定义为单元面积 $A_e$ 除以其节点数 $n_e$。对于线性三角形（`tri3`），$n_e=3$。对于轴对齐四边形（`quad4`），$n_e=4$。\n\n对于任意顶点按序列出的多边形 $(x_1, y_1), (x_2, y_2), \\dots, (x_N, y_N)$，其面积 $A_e$ 可使用鞋带公式计算：\n$$\nA_e = \\frac{1}{2} \\left| \\sum_{k=1}^{N} (x_k y_{k+1} - x_{k+1} y_k) \\right|, \\quad \\text{with } (x_{N+1}, y_{N+1}) \\equiv (x_1, y_1)\n$$\n该公式适用于指定的三角形和矩形单元。\n\n每个测试用例的步骤如下：\n1.  识别目标节点 $i$。\n2.  识别相连单元的集合 $\\mathcal{E}(i)$。\n3.  对于每个单元 $e \\in \\mathcal{E}(i)$：\n    a. 确定其顶点并计算其面积 $A_e$。\n    b. 确定其节点数 $n_e$。\n    c. 计算贡献面积 $A_{e,i} = A_e / n_e$。\n    d. 计算该单元对分子 $A_{e,i} q_e$ 和分母 $A_{e,i}$ 的贡献。\n4.  将所有相连单元的贡献相加，得到总分子和总分母。\n5.  计算最终的节点值 $q_i$。\n\n现在我们将此步骤应用于每个测试用例。\n\n**测试用例 1**\n目标节点: $i=2$。\n包含节点 2 的单元集合为 $\\mathcal{E}(2) = \\{0, 1\\}$。\n\n单元 0 (类型 `quad4`, $n_0 = 4$, $q_0 = 10$):\n- 顶点: $(0,0), (2,0), (2,1), (0,1)$。\n- 面积: $A_0 = | (0 \\cdot 0 - 2 \\cdot 0) + (2 \\cdot 1 - 2 \\cdot 0) + (2 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0) | / 2 = |2 + 2| / 2 = 2.0$。\n- 贡献面积: $A_{0,2} = A_0 / n_0 = 2.0 / 4 = 0.5$。\n- 分子贡献: $A_{0,2} q_0 = 0.5 \\times 10 = 5.0$。\n- 分母贡献: $A_{0,2} = 0.5$。\n\n单元 1 (类型 `tri3`, $n_1 = 3$, $q_1 = 4$):\n- 顶点: $(2,1), (3,0), (3,1)$。\n- 面积: $A_1 = | (2 \\cdot 0 - 3 \\cdot 1) + (3 \\cdot 1 - 3 \\cdot 0) + (3 \\cdot 1 - 2 \\cdot 1) | / 2 = |-3 + 3 + 1| / 2 = 0.5$。\n- 贡献面积: $A_{1,2} = A_1 / n_1 = 0.5 / 3 = 1/6$。\n- 分子贡献: $A_{1,2} q_1 = (1/6) \\times 4 = 4/6 = 2/3$。\n- 分母贡献: $A_{1,2} = 1/6$。\n\n节点 2 处的节点平均值:\n- $\\sum A_{e,2} q_e = 5.0 + 2/3 = 15/3 + 2/3 = 17/3$。\n- $\\sum A_{e,2} = 0.5 + 1/6 = 3/6 + 1/6 = 4/6 = 2/3$。\n- $q_2 = (17/3) / (2/3) = 17/2 = 8.5$。\n\n**测试用例 2**\n目标节点: $i=0$。\n包含节点 0 的单元集合为 $\\mathcal{E}(0) = \\{0\\}$。\n由于只有一个单元连接到目标节点，加权平均值简化为该单元自身的值：$q_0 = q_e = 7$。\n计算以确认：\n- 单元 0 (类型 `tri3`, $n_0 = 3$, $q_0 = 7$):\n- 顶点: $(0,0), (1,0), (0,2)$。\n- 面积: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 2 - 0 \\cdot 0) + (0 \\cdot 0 - 0 \\cdot 2)| / 2 = |2| / 2 = 1.0$。\n- 贡献面积: $A_{0,0} = A_0 / n_0 = 1.0 / 3 = 1/3$。\n- $q_0 = (A_{0,0} q_0) / A_{0,0} = q_0 = 7.0$。\n\n**测试用例 3**\n目标节点: $i=2$。\n包含节点 2 的单元集合为 $\\mathcal{E}(2) = \\{0, 1\\}$。\n\n单元 0 (类型 `tri3`, $n_0 = 3$, $q_0 = 9$):\n- 顶点: $(0,0), (1,0), (1,1)$。\n- 面积: $A_0 = |(0 \\cdot 0 - 1 \\cdot 0) + (1 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 0 - 0 \\cdot 1)| / 2 = |1| / 2 = 0.5$。\n- 贡献面积: $A_{0,2} = A_0 / 3 = 0.5 / 3 = 1/6$。\n- 分子贡献: $A_{0,2} q_0 = (1/6) \\times 9 = 9/6 = 1.5$。\n- 分母贡献: $A_{0,2} = 1/6$。\n\n单元 1 (类型 `tri3`, $n_1 = 3$, $q_1 = 3$):\n- 顶点: $(0,0), (1,1), (0,1)$。\n- 面积: $A_1 = |(0 \\cdot 1 - 1 \\cdot 0) + (1 \\cdot 1 - 0 \\cdot 1) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |1| / 2 = 0.5$。\n- 贡献面积: $A_{1,2} = A_1 / 3 = 0.5 / 3 = 1/6$。\n- 分子贡献: $A_{1,2} q_1 = (1/6) \\times 3 = 3/6 = 0.5$。\n- 分母贡献: $A_{1,2} = 1/6$。\n\n节点 2 处的节点平均值:\n- $\\sum A_{e,2} q_e = 1.5 + 0.5 = 2.0$。\n- $\\sum A_{e,2} = 1/6 + 1/6 = 2/6 = 1/3$。\n- $q_2 = 2.0 / (1/3) = 6.0$。\n由于贡献面积相等（$A_{0,2} = A_{1,2}$），结果为单元值的算术平均值：$(9+3)/2 = 6.0$。\n\n**测试用例 4**\n目标节点: $i=1$。\n包含节点 1 的单元集合为 $\\mathcal{E}(1) = \\{0\\}$。\n与用例 2 一样，节点值即为单元值：$q_1 = q_e = 5$。\n计算以确认：\n- 单元 0 (类型 `quad4`, $n_0 = 4$, $q_0 = 5$):\n- 顶点: $(0,0), (3,0), (3,2), (0,2)$。\n- 面积: $A_0 = |(0 \\cdot 0 - 3 \\cdot 0) + (3 \\cdot 2 - 3 \\cdot 0) + (3 \\cdot 2 - 0 \\cdot 2) + (0 \\cdot 0 - 0 \\cdot 0)| / 2 = |6 + 6| / 2 = 6.0$。\n- 贡献面积: $A_{0,1} = A_0 / n_0 = 6.0 / 4 = 1.5$。\n- $q_1 = (A_{0,1} q_0) / A_{0,1} = q_0 = 5.0$。\n\n最终计算出的值为：$8.5$、$7.0$、$6.0$ 和 $5.0$。输出时必须格式化为六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# No other libraries are required for this problem.\n\ndef get_polygon_area(vertices):\n    \"\"\"\n    Calculates the area of a polygon given its vertices using the Shoelace formula.\n    Args:\n        vertices (list of tuples): A list of (x, y) coordinates for the polygon's vertices,\n                                   ordered sequentially (clockwise or counter-clockwise).\n    Returns:\n        float: The area of the polygon.\n    \"\"\"\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0\n\ndef solve():\n    \"\"\"\n    Solves the nodal averaging problem for a predefined suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test Case 1\n        ({0: (0.0, 0.0), 1: (2.0, 0.0), 2: (2.0, 1.0), 3: (0.0, 1.0), 4: (3.0, 0.0), 5: (3.0, 1.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 10.0},\n          {\"type\": \"tri3\", \"conn\": [2, 4, 5], \"q\": 4.0}],\n         2),\n        # Test Case 2\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (0.0, 2.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 7.0}],\n         0),\n        # Test Case 3\n        ({0: (0.0, 0.0), 1: (1.0, 0.0), 2: (1.0, 1.0), 3: (0.0, 1.0)},\n         [{\"type\": \"tri3\", \"conn\": [0, 1, 2], \"q\": 9.0},\n          {\"type\": \"tri3\", \"conn\": [0, 2, 3], \"q\": 3.0}],\n         2),\n        # Test Case 4\n        ({0: (0.0, 0.0), 1: (3.0, 0.0), 2: (3.0, 2.0), 3: (0.0, 2.0)},\n         [{\"type\": \"quad4\", \"conn\": [0, 1, 2, 3], \"q\": 5.0}],\n         1),\n    ]\n\n    results = []\n    for case in test_cases:\n        node_coords, elements, node_idx = case\n\n        numerator = 0.0\n        denominator = 0.0\n        \n        # Find all elements connected to the node of interest and compute their contributions.\n        for elem in elements:\n            if node_idx in elem[\"conn\"]:\n                q_e = elem[\"q\"]\n                conn = elem[\"conn\"]\n                \n                # Get the coordinates of the element's vertices.\n                vertices = [node_coords[node_id] for node_id in conn]\n                \n                # Calculate the element area using the general polygon area formula.\n                A_e = get_polygon_area(vertices)\n                \n                # The number of nodes determines the denominator for the tributary area.\n                n_nodes = len(conn)\n                A_ei = A_e / n_nodes\n                \n                # Accumulate the weighted sum for the numerator and the sum of weights for the denominator.\n                numerator += A_ei * q_e\n                denominator += A_ei\n\n        # The problem statement guarantees the node of interest is part of at least\n        # one element, so the denominator will not be zero.\n        q_i = numerator / denominator\n        results.append(q_i)\n\n    # Format the final output as a bracketed, comma-separated list of floating-point numbers\n    # with exactly six digits after the decimal point.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2426709"}, {"introduction": "任何模拟都面临一个核心问题：“我的结果有多准确？”。后验误差估计为此提供了量化有限元解误差的方法。本练习将引导你实现经典的Zienkiewicz-Zhu (ZZ) 误差估计器，这是一种强大的后处理技术 [@problem_id:2426760]。你将通过对原始的、不连续的有限元梯度场进行“恢复”，构造一个更平滑、更精确的梯度场，并以二者之差作为误差的度量。这项实践让你亲身体验用于验证解的可靠性和指导自适应网格划分的关键技术。", "problem": "给定一个二维稳态热传导问题，其热导率 $k$ 为标量、各向同性且恒定。该问题作用于一个由三个线性三角形有限元组成的单元片上。考虑有限元法 (FEM) 的温度近似解 $u_h$，它在整个三角剖分上是连续的分片线性函数。对于每个顶点索引为 $(i,j,\\ell)$ 的三角形 $\\Omega_e$，设其单元常梯度为 $\\nabla u_h|_{\\Omega_e}$。Zienkiewicz–Zhu (ZZ) 恢复梯度场 $\\widehat{\\nabla u}$ 是一个连续的分片线性矢量场，通过对节点恢复梯度进行线性插值得到。对于单元片中的每个节点 $n$，其节点恢复梯度定义为与该节点关联的所有单元的常梯度以面积为权重的加权平均值：\n$$\n\\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\nabla u_h|_{\\Omega_e}}{\\sum\\limits_{e \\ni n} A_e},\n$$\n其中 $A_e$ 是单元 $\\Omega_e$ 的面积。在一个具有局部节点 $(i,j,\\ell)$ 和线性形函数 $(N_i,N_j,N_\\ell)$ 的单元 $\\Omega_e$ 内，恢复梯度场为\n$$\n\\widehat{\\nabla u}(x,y)\\Big|_{\\Omega_e} \\;=\\; N_i(x,y)\\,\\widehat{\\nabla u}^{(i)} \\;+\\; N_j(x,y)\\,\\widehat{\\nabla u}^{(j)} \\;+\\; N_\\ell(x,y)\\,\\widehat{\\nabla u}^{(\\ell)}.\n$$\n将该单元片的 ZZ 能量范数误差定义为\n$$\n\\left\\|e\\right\\|_{ZZ} \\;=\\; \\left(\\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega \\right)^{1/2}.\n$$\n\n本问题中所有量均为无量纲。您的任务是为以下三个测试用例计算 $\\left\\|e\\right\\|_{ZZ}$。在每个用例中，有限元网格都是一个由三个三角形组成的单元片，它们共享索引为 $0$ 的中心节点，并且单元连接关系为 $\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$。FEM 节点温度值 $u_h$ 应取为给定解析场 $u(x,y)$ 在网格节点处的精确逐点值。\n\n对于每个测试，请使用指定的节点坐标、热导率 $k$ 和解析温度场 $u(x,y)$：\n- 测试 1（精确线性场；在精确算术下预期误差为零）：\n  - 节点：$0:(0.0,\\,0.0)$，$1:(1.0,\\,0.0)$，$2:(-0.2,\\,1.1)$，$3:(-0.8,\\,-0.4)$。\n  - 连接关系：$\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$。\n  - 热导率：$k=1.0$。\n  - 场：$u(x,y)=2x - y$。\n- 测试 2（在中等形状单元片上的非线性场）：\n  - 节点：$0:(0.1,\\,0.2)$，$1:(0.9,\\,0.1)$，$2:(0.0,\\,1.0)$，$3:(-0.8,\\,0.2)$。\n  - 连接关系：$\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$。\n  - 热导率：$k=2.0$。\n  - 场：$u(x,y)=x^2 + y$。\n- 测试 3（包含一个细长三角形的非线性场）：\n  - 节点：$0:(0.0,\\,0.0)$，$1:(0.001,\\,0.0)$，$2:(0.002,\\,0.05)$，$3:(-0.8,\\,0.001)$。\n  - 连接关系：$\\big[(0,1,2),\\,(0,2,3),\\,(0,3,1)\\big]$。\n  - 热导率：$k=0.5$。\n  - 场：$u(x,y)=\\sin(x)+0.5\\,y$。\n\n必需的约定和定义：\n- 对于顶点坐标为 $(x_i,y_i)$、$(x_j,y_j)$、$(x_\\ell,y_\\ell)$ 的三角形，令其有符号二倍面积为\n$$\n2A_{\\mathrm{sign}} \\;=\\; (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i),\n$$\n且（正）面积为 $A \\,=\\, |A_{\\mathrm{sign}}|/2$。\n- 对于线性形函数，三角形 $\\Omega_e$ 中 $u_h$ 的单元常梯度为\n$$\n\\nabla u_h\\Big|_{\\Omega_e} = \\frac{1}{2A_{\\mathrm{sign}}} \\begin{bmatrix} y_j-y_\\ell  y_\\ell-y_i  y_i-y_j \\\\ x_\\ell-x_j  x_i-x_\\ell  x_j-x_i \\end{bmatrix} \\begin{bmatrix} u_i \\\\ u_j \\\\ u_\\ell \\end{bmatrix}\n$$\n\n您的程序必须为每个测试用例计算标量 $\\left\\|e\\right\\|_{ZZ}$，并使用定义中隐含的单元积分的精确算术。将三个结果汇总成单行输出，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到小数点后恰好六位。例如，一个带有占位符值的输出可能看起来像 $[0.000000,0.123456,0.654321]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[r_1,r_2,r_3]$）。", "solution": "提交分析的问题陈述经过了严格审查，并被证实是有效的。其科学基础在于有限元法（FEM）的原理，特别是关于使用 Zienkiewicz-Zhu (ZZ) 恢复技术的后验误差估计。该问题是适定的，提供了所有必要的数据，包括网格几何形状、连接关系、材料属性以及用于设定节点值的解析场。所用语言客观且数学上精确。不存在矛盾、歧义或违反基本原理的情况。因此，将提供一个合理的解决方案。\n\n目标是为三个不同的测试用例，计算一个由三个线性三角形单元组成的单元片的 Zienkiewicz-Zhu 能量范数误差 $\\left\\|e\\right\\|_{ZZ}$。总误差的平方是每个单元 $\\Omega_e$ 贡献的总和：\n$$\n\\left\\|e\\right\\|_{ZZ}^2 \\;=\\; \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; \\sum_{e=1}^{3} \\int_{\\Omega_e} k\\,\\big\\|\\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}\\big\\|_2^2\\,\\mathrm{d}\\Omega\n$$\n计算过程遵循一系列逻辑步骤。\n\n**步骤 1：节点温度求值**\n有限元近似解 $u_h$ 是连续的分片线性函数。问题规定，温度场的节点值 $u_i$ 是通过在每个网格节点 $n_i=(x_i, y_i)$ 的坐标处对给定的精确解析场 $u(x,y)$ 进行采样来确定的。\n$$\nu_i = u(x_i, y_i)\n$$\n对单元片中的所有四个节点 $n_0, n_1, n_2, n_3$ 执行此操作。\n\n**步骤 2：计算单元常梯度**\n在每个线性三角形单元 $\\Omega_e$ 内，有限元解的梯度 $\\nabla u_h|_{\\Omega_e}$ 是一个常数向量。对于一个顶点为 $(i,j,\\ell)$、坐标为 $(x_i,y_i)$、$(x_j,y_j)$、$(x_\\ell,y_\\ell)$ 且节点温度为 $(u_i,u_j,u_\\ell)$ 的单元，这个梯度向量 $\\mathbf{g}_e = \\nabla u_h|_{\\Omega_e}$ 使用提供的公式计算：\n$$\n\\mathbf{g}_e = \\nabla u_h\\Big|_{\\Omega_e} = \\frac{1}{2A_{e,\\mathrm{sign}}} \\begin{bmatrix} y_j-y_\\ell  y_\\ell-y_i  y_i-y_j\\\\ x_\\ell-x_j  x_i-x_\\ell  x_j-x_i \\end{bmatrix} \\begin{bmatrix} u_i\\\\ u_j\\\\ u_\\ell \\end{bmatrix}\n$$\n其中 $2A_{e,\\mathrm{sign}} = (x_j-x_i)(y_\\ell-y_i) - (x_\\ell-x_i)(y_j-y_i)$ 是单元的有符号二倍面积。对单元片中的三个单元分别重复此计算，得到梯度向量 $\\mathbf{g}_1, \\mathbf{g}_2, \\mathbf{g}_3$。每个单元的（正）面积为 $A_e = \\frac{1}{2}|2A_{e,\\mathrm{sign}}|$。\n\n**步骤 3：计算节点恢复梯度**\nZienkiewicz-Zhu 过程通过首先计算网格节点处的平均梯度来构建一个连续的、改进的梯度场 $\\widehat{\\nabla u}$。节点 $n$ 处的恢复梯度，记为 $\\widehat{\\nabla u}^{(n)}$ 或 $\\mathbf{G}_n$，是与该节点关联的所有单元的常梯度以面积为权重的加权平均值：\n$$\n\\mathbf{G}_n = \\widehat{\\nabla u}^{(n)} \\;=\\; \\frac{\\sum\\limits_{e \\ni n} A_e\\,\\mathbf{g}_e}{\\sum\\limits_{e \\ni n} A_e}\n$$\n对四个节点中的每一个执行此计算。例如，中心节点 $n_0$ 被所有三个单元共享，因此其恢复梯度为：\n$$\n\\mathbf{G}_0 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_2\\,\\mathbf{g}_2 + A_3\\,\\mathbf{g}_3}{A_1+A_2+A_3}\n$$\n一个外部节点，如 $n_1$，仅被单元 $1$ 和 $3$ 共享，因此其恢复梯度为：\n$$\n\\mathbf{G}_1 \\;=\\; \\frac{A_1\\,\\mathbf{g}_1 + A_3\\,\\mathbf{g}_3}{A_1+A_3}\n$$\n相应地计算恢复梯度 $\\mathbf{G}_0, \\mathbf{G}_1, \\mathbf{G}_2, \\mathbf{G}_3$。\n\n**步骤 4：计算单元误差积分**\n任务的核心是计算每个单元对总误差贡献的积分。令 $\\boldsymbol{\\delta}(x,y) = \\widehat{\\nabla u}(x,y)-\\nabla u_h|_{\\Omega_e}$。在一个具有节点 $(i,j,\\ell)$ 的单元 $\\Omega_e$ 内，该差值场是线性的，因为 $\\widehat{\\nabla u}$ 和 $u_h$ 都是分片线性的。它可以使用单元形函数 $(N_i, N_j, N_\\ell)$ 表示：\n$$\n\\boldsymbol{\\delta}(x,y) = N_i(x,y)\\,\\boldsymbol{\\delta}_i + N_j(x,y)\\,\\boldsymbol{\\delta}_j + N_\\ell(x,y)\\,\\boldsymbol{\\delta}_\\ell\n$$\n其中 $\\boldsymbol{\\delta}_n = \\mathbf{G}_n - \\mathbf{g}_e$ 是节点 $n$ 处的差值向量。单元 $e$ 的积分为：\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 \\;=\\; k \\int_{\\Omega_e} \\left\\| \\boldsymbol{\\delta}(x,y) \\right\\|_2^2 \\,\\mathrm{d}\\Omega = k \\int_{\\Omega_e} \\left( \\delta_x(x,y)^2 + \\delta_y(x,y)^2 \\right) \\,\\mathrm{d}\\Omega\n$$\n一个线性标量场 $f(x,y) = N_i f_i + N_j f_j + N_\\ell f_\\ell$ 的平方在三角形单元上的积分有精确的解析解：\n$$\n\\int_{\\Omega_e} f(x,y)^2 \\,\\mathrm{d}\\Omega = \\frac{A_e}{12}(2f_i^2+2f_j^2+2f_\\ell^2 + 2f_if_j + 2f_if_\\ell + 2f_jf_\\ell) = \\mathbf{f}^T \\mathbf{M} \\mathbf{f}\n$$\n其中 $\\mathbf{f} = [f_i, f_j, f_\\ell]^T$ 是节点值的向量，$\\mathbf{M}$ 是线性三角形的单元质量矩阵：\n$$\n\\mathbf{M} = \\frac{A_e}{12}\n\\begin{pmatrix}\n2  1  1 \\\\\n1  2  1 \\\\\n1  1  2\n\\end{pmatrix}\n$$\n将此应用于 $\\boldsymbol{\\delta}(x,y)$ 的两个分量，我们得到：\n$$\n\\left\\|e\\right\\|_{ZZ,e}^2 = k \\left( \\boldsymbol{\\delta}_x^T \\mathbf{M} \\boldsymbol{\\delta}_x + \\boldsymbol{\\delta}_y^T \\mathbf{M} \\boldsymbol{\\delta}_y \\right)\n$$\n其中 $\\boldsymbol{\\delta}_x = [\\delta_{ix}, \\delta_{jx}, \\delta_{\\ell x}]^T$ 和 $\\boldsymbol{\\delta}_y = [\\delta_{iy}, \\delta_{jy}, \\delta_{\\ell y}]^T$ 是节点差值分量的向量。该精确公式用于计算。\n\n**步骤 5：汇总与最终结果**\n总误差的平方是上一步中计算的各单元误差平方之和。\n$$\n\\left\\|e\\right\\|_{ZZ}^2 = \\sum_{e=1}^{3} \\left\\|e\\right\\|_{ZZ,e}^2\n$$\n最终的 ZZ 误差范数是此总和的平方根：\n$$\n\\left\\|e\\right\\|_{ZZ} = \\sqrt{\\left\\|e\\right\\|_{ZZ}^2}\n$$\n将此完整过程以编程方式实现，并应用于三个测试用例中的每一个，以获得所需的数值结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Zienkiewicz-Zhu energy-norm error for three test cases\n    of a 2D steady heat conduction problem on a 3-element patch.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (1.0, 0.0), 2: (-0.2, 1.1), 3: (-0.8, -0.4)},\n            \"k\": 1.0,\n            \"u_func\": lambda x, y: 2.0 * x - y\n        },\n        {\n            \"nodes\": {0: (0.1, 0.2), 1: (0.9, 0.1), 2: (0.0, 1.0), 3: (-0.8, 0.2)},\n            \"k\": 2.0,\n            \"u_func\": lambda x, y: x**2 + y\n        },\n        {\n            \"nodes\": {0: (0.0, 0.0), 1: (0.001, 0.0), 2: (0.002, 0.05), 3: (-0.8, 0.001)},\n            \"k\": 0.5,\n            \"u_func\": lambda x, y: np.sin(x) + 0.5 * y\n        }\n    ]\n    \n    # Mesh connectivity is the same for all test cases.\n    connectivity = [(0, 1, 2), (0, 2, 3), (0, 3, 1)]\n    \n    results = []\n\n    for case in test_cases:\n        nodes_coords = case[\"nodes\"]\n        k = case[\"k\"]\n        u_func = case[\"u_func\"]\n        \n        # Step 1: Compute nodal temperatures from the analytical field.\n        nodal_temps = {n: u_func(x, y) for n, (x, y) in nodes_coords.items()}\n\n        elem_data = {}\n        # Step 2: Compute constant element gradients and areas for all elements.\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            n_i, n_j, n_l = elem_nodes\n            (xi, yi), (xj, yj), (xl, yl) = nodes_coords[n_i], nodes_coords[n_j], nodes_coords[n_l]\n\n            # Calculate signed doubled area and positive area.\n            two_A_sign = (xj - xi) * (yl - yi) - (xl - xi) * (yj - yi)\n            area = 0.5 * abs(two_A_sign)\n\n            # Assemble the B matrix for gradient calculation.\n            B_matrix = np.array([\n                [yj - yl, yl - yi, yi - yj],\n                [xl - xj, xi - xl, xj - xi]\n            ])\n            \n            # Vector of nodal temperatures for the element.\n            u_vec = np.array([nodal_temps[n_i], nodal_temps[n_j], nodal_temps[n_l]])\n            \n            # Calculate the constant element gradient.\n            grad_e = (1.0 / two_A_sign) * (B_matrix @ u_vec)\n            \n            elem_data[elem_idx] = {\"nodes\": elem_nodes, \"area\": area, \"grad\": grad_e}\n\n        # Step 3: Compute nodal recovered gradients.\n        # First, map each node to its incident elements.\n        node_to_elems = {n: [] for n in nodes_coords}\n        for elem_idx, elem_nodes in enumerate(connectivity):\n            for node_idx in elem_nodes:\n                node_to_elems[node_idx].append(elem_idx)\n        \n        nodal_recovered_grads = {}\n        for n in nodes_coords:\n            incident_elems = node_to_elems[n]\n            \n            # Perform area-weighted averaging.\n            sum_A_grad = np.zeros(2)\n            sum_A = 0.0\n            for elem_idx in incident_elems:\n                sum_A_grad += elem_data[elem_idx][\"area\"] * elem_data[elem_idx][\"grad\"]\n                sum_A += elem_data[elem_idx][\"area\"]\n            \n            nodal_recovered_grads[n] = sum_A_grad / sum_A\n\n        # Step 4  5: Compute element error integrals and aggregate.\n        total_E_squared = 0.0\n        for i in range(len(connectivity)):\n            data = elem_data[i]\n            n_i, n_j, n_l = data[\"nodes\"]\n            area = data[\"area\"]\n            g_e = data[\"grad\"]\n            \n            # Get the nodal recovered gradients for the current element's nodes.\n            G_i = nodal_recovered_grads[n_i]\n            G_j = nodal_recovered_grads[n_j]\n            G_l = nodal_recovered_grads[n_l]\n            \n            # Compute the difference between recovered gradient and FEM gradient at each node.\n            delta_i = G_i - g_e\n            delta_j = G_j - g_e\n            delta_l = G_l - g_e\n            \n            # Assemble vectors of x and y components of the differences.\n            delta_x = np.array([delta_i[0], delta_j[0], delta_l[0]])\n            delta_y = np.array([delta_i[1], delta_j[1], delta_l[1]])\n            \n            # Define the element mass matrix for a linear triangle.\n            M = (area / 12.0) * np.array([\n                [2.0, 1.0, 1.0],\n                [1.0, 2.0, 1.0],\n                [1.0, 1.0, 2.0]\n            ])\n            \n            # Evaluate the integral of the squared error field using the mass matrix.\n            integral_x_sq = delta_x.T @ M @ delta_x\n            integral_y_sq = delta_y.T @ M @ delta_y\n            \n            # The squared error energy for the element.\n            E_e_squared = k * (integral_x_sq + integral_y_sq)\n            total_E_squared += E_e_squared\n            \n        # Final ZZ error norm is the square root of the total squared error energy.\n        zz_error = np.sqrt(total_E_squared)\n        results.append(f\"{zz_error:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2426760"}]}