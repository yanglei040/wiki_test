{"hands_on_practices": [{"introduction": "我们从最基础的练习开始：手动计算离散小波变换 (Discrete Wavelet Transform, DWT) 及其逆变换。这个纸笔练习将揭开算法的神秘面纱，展示信号如何被分解到不同尺度，然后又被完美地重构。这项实践对于建立对快速小波变换 (Fast Wavelet Transform, FWT) 的滤波器组实现的扎实直觉至关重要 [@problem_id:2866836]。", "problem": "考虑使用正交 Haar 系统实现的离散小波变换 (DWT)，该变换作为一个临界采样的双通道滤波器组。正交 Haar 分析滤波器包括低通尺度滤波器 $h[0]=\\frac{1}{\\sqrt{2}}$, $h[1]=\\frac{1}{\\sqrt{2}}$ 和高通小波滤波器 $g[0]=\\frac{1}{\\sqrt{2}}$, $g[1]=-\\frac{1}{\\sqrt{2}}$。使用标准的临界采样树结构，在每一层进行 $2$ 倍下采样，并且不进行边界扩展（即，对于长度可被 $2^{L}$ 整除的序列，成对分组有效），并使用相应的正交合成滤波器进行逆变换。设输入序列为 $x[n]=[3,1,0,4,8,6,2,0]$，其中索引 $n=0,1,\\dots,7$。\n\n任务：\n- 手动计算 $x[n]$ 的 $3$ 级 Haar DWT，得到第 $3$ 级的近似系数和第 $1、2、3$ 级的细节系数。\n- 使用逆双通道正交 Haar 滤波器组从这些系数重构 $\\hat{x}[n]$。\n- 定义标量误差能量\n$$E=\\sum_{n=0}^{7}\\left|x[n]-\\hat{x}[n]\\right|^{2}.$$\n报告 $E$ 的值。\n\n提供 $E$ 的精确值（不进行四舍五入）。无需单位。在首次使用时定义所有缩写：离散小波变换 (DWT)，快速小波变换 (FWT)，完美重构 (PR)。", "solution": "该问题要求计算一个信号经过 3 级离散小波变换 (DWT) 及其逆变换处理后的重构误差能量，其中使用正交 Haar 小波基。问题指定了一个临界采样的双通道滤波器组，这是快速小波变换 (FWT) 的标准结构。所要检验的关键属性是完美重构 (PR)，这是正交滤波器组在没有任何信息损失（如量化）情况下的一个基本特性。我们将通过显式计算正变换和逆变换，然后计算误差能量来进行求解。\n\n输入信号为 $x[n] = [3, 1, 0, 4, 8, 6, 2, 0]$，其中 $n \\in \\{0, 1, \\dots, 7\\}$。信号长度为 $N=8$。\n正交 Haar 分析滤波器是低通尺度滤波器 $h[n]$ 和高通小波滤波器 $g[n]$：\n$$h[n] = \\frac{1}{\\sqrt{2}}\\delta[n] + \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\n$$g[n] = \\frac{1}{\\sqrt{2}}\\delta[n] - \\frac{1}{\\sqrt{2}}\\delta[n-1]$$\nDWT 的实现方式是将信号与这些滤波器进行卷积，然后进行 2 倍下采样。对于 Haar 系统，这简化为成对求均值和差值。我们将第 $j$ 级的近似系数表示为 $c_j$，细节系数表示为 $d_j$。输入信号为 $c_0[n] = x[n]$。\n\n**第 1 部分：正向 DWT (分析)**\n\n**第 1 级分解：**\n输入为 $c_0 = [3, 1, 0, 4, 8, 6, 2, 0]$。我们成对处理样本。\n近似系数 $c_1[k]$ 计算如下：\n$c_1[0] = \\frac{c_0[0] + c_0[1]}{\\sqrt{2}} = \\frac{3+1}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[1] = \\frac{c_0[2] + c_0[3]}{\\sqrt{2}} = \\frac{0+4}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$c_1[2] = \\frac{c_0[4] + c_0[5]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$c_1[3] = \\frac{c_0[6] + c_0[7]}{\\sqrt{2}} = \\frac{2+0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$。\n\n细节系数 $d_1[k]$ 计算如下：\n$d_1[0] = \\frac{c_0[0] - c_0[1]}{\\sqrt{2}} = \\frac{3-1}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[1] = \\frac{c_0[2] - c_0[3]}{\\sqrt{2}} = \\frac{0-4}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\n$d_1[2] = \\frac{c_0[4] - c_0[5]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n$d_1[3] = \\frac{c_0[6] - c_0[7]}{\\sqrt{2}} = \\frac{2-0}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$d_1 = [\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$。\n\n**第 2 级分解：**\n输入是上一级的近似系数，$c_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$。\n$c_2[0] = \\frac{c_1[0] + c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + 2\\sqrt{2}}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$c_2[1] = \\frac{c_1[2] + c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n因此，$c_2 = [4, 8]$。\n\n$d_2[0] = \\frac{c_1[0] - c_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - 2\\sqrt{2}}{\\sqrt{2}} = 0$\n$d_2[1] = \\frac{c_1[2] - c_1[3]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\n因此，$d_2 = [0, 6]$。\n\n**第 3 级分解：**\n输入为 $c_2 = [4, 8]$。\n$c_3[0] = \\frac{c_2[0] + c_2[1]}{\\sqrt{2}} = \\frac{4+8}{\\sqrt{2}} = \\frac{12}{\\sqrt{2}} = 6\\sqrt{2}$\n因此，$c_3 = [6\\sqrt{2}]$。\n\n$d_3[0] = \\frac{c_2[0] - c_2[1]}{\\sqrt{2}} = \\frac{4-8}{\\sqrt{2}} = -\\frac{4}{\\sqrt{2}} = -2\\sqrt{2}$\n因此，$d_3 = [-2\\sqrt{2}]$。\n\n$x[n]$ 的 3 级 DWT 由 $\\{c_3, d_3, d_2, d_1\\}$ 组成。\n\n**第 2 部分：逆 DWT (合成)**\n\n逆变换逐级重构信号。对于正交滤波器组，合成操作是分析操作的伴随操作。对于 Haar 基，这导致了简单的重构公式：\n$c_{j-1}[2k] = \\frac{c_j[k] + d_j[k]}{\\sqrt{2}}$\n$c_{j-1}[2k+1] = \\frac{c_j[k] - d_j[k]}{\\sqrt{2}}$\n我们将重构的近似系数表示为 $\\hat{c}_j$。\n\n**第 3 级到第 2 级的合成：**\n我们从 $c_3=[6\\sqrt{2}]$ 和 $d_3=[-2\\sqrt{2}]$ 重构 $\\hat{c}_2$。\n$\\hat{c}_2[0] = \\frac{c_3[0] + d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n$\\hat{c}_2[1] = \\frac{c_3[0] - d_3[0]}{\\sqrt{2}} = \\frac{6\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n因此，$\\hat{c}_2 = [4, 8]$，与原始的 $c_2$ 相同。\n\n**第 2 级到第 1 级的合成：**\n我们从 $\\hat{c}_2=[4, 8]$ 和 $d_2=[0, 6]$ 重构 $\\hat{c}_1$。\n对于 $k=0$：\n$\\hat{c}_1[0] = \\frac{\\hat{c}_2[0] + d_2[0]}{\\sqrt{2}} = \\frac{4+0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n$\\hat{c}_1[1] = \\frac{\\hat{c}_2[0] - d_2[0]}{\\sqrt{2}} = \\frac{4-0}{\\sqrt{2}} = \\frac{4}{\\sqrt{2}} = 2\\sqrt{2}$\n对于 $k=1$：\n$\\hat{c}_1[2] = \\frac{\\hat{c}_2[1] + d_2[1]}{\\sqrt{2}} = \\frac{8+6}{\\sqrt{2}} = \\frac{14}{\\sqrt{2}} = 7\\sqrt{2}$\n$\\hat{c}_1[3] = \\frac{\\hat{c}_2[1] - d_2[1]}{\\sqrt{2}} = \\frac{8-6}{\\sqrt{2}} = \\frac{2}{\\sqrt{2}} = \\sqrt{2}$\n因此，$\\hat{c}_1 = [2\\sqrt{2}, 2\\sqrt{2}, 7\\sqrt{2}, \\sqrt{2}]$，与原始的 $c_1$ 相同。\n\n**第 1 级到第 0 级的合成：**\n我们从 $\\hat{c}_1$ 和 $d_1=[\\sqrt{2}, -2\\sqrt{2}, \\sqrt{2}, \\sqrt{2}]$ 重构最终信号 $\\hat{x}[n] = \\hat{c}_0[n]$。\n对于 $k=0$：\n$\\hat{x}[0] = \\frac{\\hat{c}_1[0] + d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{3\\sqrt{2}}{\\sqrt{2}} = 3$\n$\\hat{x}[1] = \\frac{\\hat{c}_1[0] - d_1[0]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{\\sqrt{2}}{\\sqrt{2}} = 1$\n对于 $k=1$：\n$\\hat{x}[2] = \\frac{\\hat{c}_1[1] + d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} + (-2\\sqrt{2})}{\\sqrt{2}} = 0$\n$\\hat{x}[3] = \\frac{\\hat{c}_1[1] - d_1[1]}{\\sqrt{2}} = \\frac{2\\sqrt{2} - (-2\\sqrt{2})}{\\sqrt{2}} = \\frac{4\\sqrt{2}}{\\sqrt{2}} = 4$\n对于 $k=2$：\n$\\hat{x}[4] = \\frac{\\hat{c}_1[2] + d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{8\\sqrt{2}}{\\sqrt{2}} = 8$\n$\\hat{x}[5] = \\frac{\\hat{c}_1[2] - d_1[2]}{\\sqrt{2}} = \\frac{7\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = \\frac{6\\sqrt{2}}{\\sqrt{2}} = 6$\n对于 $k=3$：\n$\\hat{x}[6] = \\frac{\\hat{c}_1[3] + d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} + \\sqrt{2}}{\\sqrt{2}} = \\frac{2\\sqrt{2}}{\\sqrt{2}} = 2$\n$\\hat{x}[7] = \\frac{\\hat{c}_1[3] - d_1[3]}{\\sqrt{2}} = \\frac{\\sqrt{2} - \\sqrt{2}}{\\sqrt{2}} = 0$\n重构的信号是 $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n\n**第 3 部分：误差能量计算**\n原始信号为 $x[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n重构的信号为 $\\hat{x}[n]=[3, 1, 0, 4, 8, 6, 2, 0]$。\n显然，对于所有 $n \\in \\{0, 1, \\dots, 7\\}$，$\\hat{x}[n] = x[n]$。\n误差信号为 $e[n] = x[n] - \\hat{x}[n] = [0, 0, 0, 0, 0, 0, 0, 0]$。\n标量误差能量 $E$ 定义为：\n$$E = \\sum_{n=0}^{7} |x[n] - \\hat{x}[n]|^2 = \\sum_{n=0}^{7} |e[n]|^2$$\n代入误差信号：\n$$E = \\sum_{n=0}^{7} |0|^2 = 0$$\n结果 $E=0$ 是预料之中的。问题设置描述了一个正交滤波器组，在分析和合成阶段之间没有对系数进行任何修改（例如，量化、阈值处理）。此类系统具有完美重构特性，意味着输出与输入完全相同，因此重构误差为零。计算证实了这一基本原理。", "answer": "$$\\boxed{0}$$", "id": "2866836"}, {"introduction": "在理解了DWT的内部机理后，我们来探究小波为何如此强大。本练习将比较小波变换与经典的傅里叶变换在表示不同类型信号时的效率。通过编写一个简单的程序，你将亲身体会到，对于包含剧烈变化或局部事件的信号，小波能够提供更稀疏（即更高效）的表示，这是信号压缩和特征检测中的一个核心概念 [@problem_id:2450300]。", "problem": "您需要编写一个完整、可运行的程序，该程序构建特定的离散时间信号，使用正交 Haar 基分析它们在离散傅里叶变换 (DFT) 域和离散小波变换 (DWT) 域中的表示稀疏性，并汇总给定测试套件的结果。三角函数中使用的所有角度都必须是弧度。不涉及物理单位。\n\n定义和要求：\n1) 设一个实值离散时间信号由长度为 $N$ 的有限序列 $\\{x[n]\\}_{n=0}^{N-1}$ 表示，其中 $N$ 是一个正偶数。\n2) $\\{x[n]\\}$ 的离散傅里叶变换 (DFT) 是序列 $\\{X[k]\\}_{k=0}^{N-1}$，定义为\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}} \\quad \\text{for} \\quad k=0,1,\\dots,N-1.\n$$\n3) $\\{x[n]\\}$ 的正交 Haar 离散小波变换 (DWT) 是通过重复应用长度为 2 的正交分析滤波器递归定义的。在每一层，对于长度为偶数 $M$ 的输入序列 $\\{u[m]\\}_{m=0}^{M-1}$，定义近似系数 $\\{a[j]\\}_{j=0}^{\\frac{M}{2}-1}$ 和细节系数 $\\{d[j]\\}_{j=0}^{\\frac{M}{2}-1}$ 如下\n$$\na[j] = \\frac{u[2j] + u[2j+1]}{\\sqrt{2}}, \\quad d[j] = \\frac{u[2j] - u[2j+1]}{\\sqrt{2}},\n$$\n对于 $j=0,1,\\dots,\\frac{M}{2}-1$。将近似系数用作下一层的输入 $\\{u[m]\\}$，并继续此过程，直到只剩下一个近似系数。完整的 Haar DWT 系数集由最终的单个近似系数以及所有层级的所有细节系数组成。该变换是正交且能量保持的。\n4) 对于所选域（DFT 模值或 Haar DWT 系数）中的任意系数向量 $\\{c[\\ell]\\}$，其总能量定义为\n$$\nE = \\sum_{\\ell} |c[\\ell]|^2.\n$$\n给定能量捕获分数 $\\alpha \\in (0,1]$，定义该系数向量的稀疏计数 $S_\\alpha$ 为最小的非负整数 $K$，使得 $K$ 个最大模值（按绝对值）系数的平方和大于或等于 $\\alpha E$。如果 $E=0$，则定义 $S_\\alpha = 0$。\n5) 对于一个信号 $\\{x[n]\\}$，令 $S_\\alpha^{\\text{DFT}}$ 表示从 DFT 模值 $\\{|X[k]|\\}$ 计算出的稀疏计数，令 $S_\\alpha^{\\text{DWT}}$ 表示从完整的 Haar DWT 系数集计算出的稀疏计数。在本问题中，使用 $\\alpha = 0.95$。\n\n测试套件：\n使用 $N=256$ 和以下四个信号 $\\{x^{(q)}[n]\\}$，其中 $q \\in \\{A,B,C,D\\}$，$n=0,1,\\dots,N-1$。\n- 情况 A（两个余弦之和，频率单位为周期/记录）：令 $f_1 = 5$ 且 $f_2 = 13$。定义\n$$\nx^{(A)}[n] = \\cos\\!\\left(2\\pi \\frac{f_1 n}{N}\\right) + 0.5 \\cos\\!\\left(2\\pi \\frac{f_2 n}{N}\\right).\n$$\n- 情况 B（分段常数，二进分割）：定义\n$$\nx^{(B)}[n] =\n\\begin{cases}\n0,  0 \\le n  64,\\\\\n2,  64 \\le n  128,\\\\\n-1.5,  128 \\le n  192,\\\\\n0.5,  192 \\le n  256.\n\\end{cases}\n$$\n- 情况 C（零信号）：定义 $x^{(C)}[n] = 0$ 对所有 $n$ 成立。\n- 情况 D（具有线性增加瞬时频率的线性调频信号）：令 $f_0 = 3$ 且 $f_1 = 60$。定义 $t_n = \\frac{n}{N}$ 和相位\n$$\n\\phi[n] = 2\\pi \\left( f_0 \\, t_n + \\frac{1}{2}(f_1 - f_0) \\, t_n^2 \\right),\n$$\n并设\n$$\nx^{(D)}[n] = \\sin\\!\\big(\\phi[n]\\big).\n$$\n\n角度单位声明：所有三角函数的参数均以弧度为单位。\n\n对于每种情况 $q \\in \\{A,B,C,D\\}$，计算序对 $\\big(S_{0.95}^{\\text{DFT}}(x^{(q)}), S_{0.95}^{\\text{DWT}}(x^{(q)})\\big)$ 并计算两个布尔指标：\n- 傅里叶更稀疏指标：$S_{0.95}^{\\text{DFT}}(x^{(q)})  S_{0.95}^{\\text{DWT}}(x^{(q)})$。\n- 小波更稀疏指标：$S_{0.95}^{\\text{DWT}}(x^{(q)})  S_{0.95}^{\\text{DFT}}(x^{(q)})$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个按 $[A,B,C,D]$ 顺序排列的四个结果的列表。每个结果必须是 $[K_F, K_W, F\\_sparser, W\\_sparser]$ 形式的列表，其中 $K_F$ 是 $S_{0.95}^{\\text{DFT}}$，$K_W$ 是 $S_{0.95}^{\\text{DWT}}$，$F\\_sparser$ 是傅里叶更稀疏布尔值，$W\\_sparser$ 是小波更稀疏布尔值。整个输出必须是单行，形式如下\n$[[K_{F,A},K_{W,A},F\\_A,W\\_A],[K_{F,B},K_{W,B},F\\_B,W\\_B],[K_{F,C},K_{W,C},F\\_C,W\\_C],[K_{F,D},K_{W,D},F\\_D,W\\_D]]$\n且无附加文本。", "solution": "所提出的问题是一个定义明确的信号处理计算练习，具体涉及信号表示稀疏性的分析。它要求比较两种基本变换——离散傅里叶变换 (DFT) 和使用 Haar 基的离散小波变换 (DWT)——在表示不同类型信号方面的表现。问题陈述在科学上是合理的，在数学上是明确的，并包含了解决该问题所需的所有必要信息。因此，我认为该问题是有效的，并将继续提供完整的解决方案。\n\n需要展示的核心原理是，信号表示的效率关键取决于基函数的选择。在特定基中“稀疏”的信号可以使用少量非零系数进行精确表示或近似。这一特性是现代数据压缩和分析技术的基础。DFT 提供了复正弦基，对于由少数周期性分量组成的信号，该基是最优稀疏的。另一方面，Haar DWT 提供了分段常数函数（缩放和平移的方波）的基，对于本身具有二进结构的分段常数信号，该基是最优稀疏的。\n\n每个测试用例的解决方法论包括四个主要步骤：\n1.  根据指定的数学公式生成信号。\n2.  计算信号在 DFT 域和 Haar DWT 域中的表示。\n3.  计算两种表示的稀疏计数 $S_{0.95}$。\n4.  比较两个稀疏计数，以确定哪个基提供了更稀疏的表示。\n\n设信号为 $\\{x[n]\\}_{n=0}^{N-1}$，其中 $N=256$。\n\n首先，我们使用以下公式计算 DFT 系数 $\\{X[k]\\}_{k=0}^{N-1}$：\n$$\nX[k] = \\sum_{n=0}^{N-1} x[n] \\, e^{-i \\, 2\\pi \\, \\frac{n k}{N}}\n$$\n这可以使用快速傅里叶变换 (FFT) 算法高效实现。\n\n其次，我们计算正交 Haar DWT 系数。该过程是递归的。设初始信号为 $u_0 = x$。对于每一层 $j=1, 2, \\dots, \\log_2(N)$，我们取前一层的近似系数 $u_{j-1}$ 作为输入。新的近似系数 $a_j$ 和细节系数 $d_j$ 计算如下：\n$$\na_j[m] = \\frac{u_{j-1}[2m] + u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\n$$\nd_j[m] = \\frac{u_{j-1}[2m] - u_{j-1}[2m+1]}{\\sqrt{2}}\n$$\n下一层的输入是 $u_j = a_j$。重复此过程，直到只剩下一个近似系数 $a_{\\log_2(N)}$。完整的 DWT 系数向量是最终近似系数和每一层所有细节系数的集合：$\\{a_{\\log_2(N)}, d_{\\log_2(N)}, d_{\\log_2(N)-1}, \\dots, d_1\\}$。对于 $N=256$，有 $\\log_2(256)=8$ 层分解。\n\n第三，对于每组系数 $\\{c[\\ell]\\}$（无论是 DFT 模值 $\\{|X[k]|\\}$ 还是 Haar DWT 系数），我们计算 $\\alpha = 0.95$ 时的稀疏计数 $S_\\alpha$。总能量定义为 $E = \\sum_{\\ell} |c[\\ell]|^2$。稀疏计数 $S_\\alpha$ 是系数的最小数量 $K$，其平方模值的总和至少为 $\\alpha E$。为了找到 $K$，我们将平方模值 $|c[\\ell]|^2$ 按降序排序，并找到最小的 $K$，使得前 $K$ 项的累积和达到或超过阈值 $0.95 E$。如果 $E=0$，则 $S_\\alpha = 0$。\n\n让我们在计算前分析每种情况：\n- **情况 A（余弦之和）**：信号 $x^{(A)}[n] = \\cos(2\\pi \\frac{5 n}{256}) + 0.5 \\cos(2\\pi \\frac{13 n}{256})$ 是两个纯正弦波之和，其整数频率为 $f_1=5$ 和 $f_2=13$。一个余弦函数 $\\cos(2\\pi \\frac{f n}{N})$ 的 DFT 由位于频率 $k=f$ 和 $k=N-f$ 的两个脉冲组成。因此，$x^{(A)}[n]$ 的 DFT 几乎所有的能量都集中在对应于 $k \\in \\{5, 13, 256-13, 256-5\\}$ 的四个系数中。DFT 表示将极其稀疏。相反，信号的光滑正弦特性与块状的 Haar 小波不匹配，需要许多 DWT 系数才能进行精确表示。我们预测 $S_{0.95}^{\\text{DFT}}  S_{0.95}^{\\text{DWT}}$。\n\n- **情况 B（分段常数）**：信号 $x^{(B)}[n]$ 在四个连续的、长度各为 64 的块上是恒定的。边界位于 $n=64$，$n=128$ 和 $n=192$，这些都是 $N/4 = 256/4 = 64$ 的整数倍。这种二进结构与 Haar 基函数完美对齐。通过逐步应用 DWT 滤波器方程可以表明，只有极少数与不连续点相对应的 Haar 系数是非零的。我们的分析显示恰好有 4 个非零 DWT 系数。相比之下，信号中的急剧不连续性会将能量广泛地散布在整个频谱上，导致密集的 DFT 表示。我们预测 $S_{0.95}^{\\text{DWT}}  S_{0.95}^{\\text{DFT}}$。\n\n- **情况 C（零信号）**：$x^{(C)}[n] = 0$。零信号的 DFT 和 DWT 都是零向量。两个域中的能量都是 $E=0$。根据定义，两者的稀疏计数都为 $S_\\alpha = 0$。因此，$S_{0.95}^{\\text{DFT}} = S_{0.95}^{\\text{DWT}} = 0$。两者均不比对方更稀疏。\n\n- **情况 D（线性调频）**：信号 $x^{(D)}[n] = \\sin(\\phi[n])$ 的瞬时频率从 $f_0=3$ 线性变化到 $f_1=60$。该信号非周期且平滑。其能量在 DFT 域中分布在很宽的频率范围内，因此 $S_{0.95}^{\\text{DFT}}$ 会很大。它也不是分段常数，因此其 Haar DWT 表示也将是密集的，使得 $S_{0.95}^{\\text{DWT}}$ 很大。两个基都不适合。相对性能无法先验地确定，将通过计算来决定。小波经常被引用于分析此类时变信号的能力，但与更平滑的小波相比，基本的 Haar 小波对于此任务而言是一个较差的选择。\n\n最后一步是在一个程序中实现此逻辑，以找出每种情况下 $S_{0.95}^{\\text{DFT}}$ 和 $S_{0.95}^{\\text{DWT}}$ 的精确量化值以及相应的布尔指标。最终答案部分提供的代码执行了这些计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Constructs, analyzes, and reports the sparsity of four test signals\n    in the DFT and Haar DWT domains.\n    \"\"\"\n\n    def haar_dwt(x: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the full 1D orthonormal Haar Discrete Wavelet Transform.\n        \"\"\"\n        u = x.astype(np.float64)\n        coeffs = []\n        while len(u)  1:\n            u_even = u[::2]\n            u_odd = u[1::2]\n            a = (u_even + u_odd) / np.sqrt(2)\n            d = (u_even - u_odd) / np.sqrt(2)\n            coeffs.insert(0, d)\n            u = a\n        \n        # The final structure is [a_final, d_logN, d_logN-1, ..., d_1]\n        full_coeffs = [u]\n        for d_level in coeffs:\n            full_coeffs.append(d_level)\n            \n        return np.concatenate(full_coeffs)\n\n    def calculate_sparsity(coeffs: np.ndarray, alpha: float) - int:\n        \"\"\"\n        Calculates the sparsity count S_alpha for a given coefficient vector.\n        \"\"\"\n        if coeffs.size == 0:\n            return 0\n\n        # Use squared magnitudes for energy calculation\n        coeffs_mag_sq = np.abs(coeffs)**2\n        total_energy = np.sum(coeffs_mag_sq)\n\n        if total_energy == 0:\n            return 0\n\n        target_energy = alpha * total_energy\n        \n        # Sort squared magnitudes in descending order\n        sorted_mag_sq = np.sort(coeffs_mag_sq)[::-1]\n        \n        # Find the number of coefficients needed to capture the target energy\n        cumulative_energy = np.cumsum(sorted_mag_sq)\n        \n        # K is the smallest count such that the energy condition is met.\n        # np.searchsorted finds the index to insert to maintain order.\n        # If the target is met at index i, we need i+1 coefficients.\n        K = np.searchsorted(cumulative_energy, target_energy, side='left') + 1\n        \n        return int(K)\n\n    # General parameters from the problem statement\n    N = 256\n    alpha = 0.95\n    n = np.arange(N)\n\n    # Test Case A: Sum of two cosines\n    f1_A, f2_A = 5, 13\n    x_A = np.cos(2 * np.pi * f1_A * n / N) + 0.5 * np.cos(2 * np.pi * f2_A * n / N)\n\n    # Test Case B: Piecewise-constant signal\n    x_B = np.zeros(N)\n    x_B[64:128] = 2.0\n    x_B[128:192] = -1.5\n    x_B[192:256] = 0.5\n\n    # Test Case C: Zero signal\n    x_C = np.zeros(N)\n\n    # Test Case D: Linear chirp\n    f0_D, f1_D = 3, 60\n    t_n = n / N\n    phase_D = 2 * np.pi * (f0_D * t_n + 0.5 * (f1_D - f0_D) * t_n**2)\n    x_D = np.sin(phase_D)\n    \n    signals = {'A': x_A, 'B': x_B, 'C': x_C, 'D': x_D}\n    all_results = []\n    \n    # Process each case in the required order\n    for key in ['A', 'B', 'C', 'D']:\n        x = signals[key]\n        \n        # DFT Sparsity Calculation\n        dft_coeffs = np.fft.fft(x)\n        K_F = calculate_sparsity(dft_coeffs, alpha)\n        \n        # DWT Sparsity Calculation\n        dwt_coeffs = haar_dwt(x)\n        K_W = calculate_sparsity(dwt_coeffs, alpha)\n        \n        # Sparsity Comparison Indicators\n        F_sparser = K_F  K_W\n        W_sparser = K_W  K_F\n        \n        all_results.append([K_F, K_W, F_sparser, W_sparser])\n\n    # Format the output string exactly as specified\n    case_strings = []\n    for result_case in all_results:\n        kf, kw, fs, ws = result_case\n        case_strings.append(f\"[{kf},{kw},{str(fs)},{str(ws)}]\")\n    \n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2450300"}, {"introduction": "最后的这项实践将我们的知识应用于一个真实的计算工程场景：模型验证。你将使用DWT来分析实验数据与仿真模型之间的残差信号。这个练习展示了多分辨率分析如何不仅让我们发现模型存在误差，还能精确定位模型在哪些特征尺度上失效，从而为模型改进提供宝贵的诊断信息 [@problem_id:2450301]。", "problem": "给定一个离散时间实验信号和一个计算模型的输出，两者均为等长的实值序列。设残差定义为 $r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$，其中 $n \\in \\{0,1,\\dots,N-1\\}$。考虑一种基于 Haar 小波的正交离散小波变换 (DWT)。单层变换将长度为 $N$ 的序列 $x[n]$ 映射为长度为 $N/2$ 的近似系数序列 $a^{(1)}[k]$ 和细节系数序列 $d^{(1)}[k]$，其计算公式如下：\n$$\na^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[2k] + x[2k+1]\\right),\n$$\n$$\nd^{(1)}[k] = \\frac{1}{\\sqrt{2}}\\left(x[2k] - x[2k+1]\\right),\n$$\n其中 $k \\in \\{0,1,\\dots,N/2-1\\}$。对于深度为 $J$ 的多层分解，通过对 $a^{(j-1)}$ 应用相同的变换来递归定义 $a^{(j)}$（其中 $a^{(0)} \\equiv x$），并在每一层 $j \\in \\{1,2,\\dots,J\\}$ 收集 $d^{(j)}$。对于每一层 $j$，定义细节能量\n$$\nE_j = \\sum_{k=0}^{N/2^j-1} \\left(d^{(j)}[k]\\right)^2.\n$$\n设总细节能量为 $E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$。定义主导层级指数\n$$\nj^{\\star} = \n\\begin{cases}\n\\arg\\max_{j \\in \\{1,\\dots,J\\}} E_j,  \\text{if } E_{\\mathrm{tot}} > 0,\\\\\n0,  \\text{if } E_{\\mathrm{tot}} = 0,\n\\end{cases}\n$$\n并约定如果多个层级达到最大值，则选择其中最小的 $j$。同时定义主导比率\n$$\n\\rho = \n\\begin{cases}\n\\frac{E_{j^{\\star}}}{E_{\\mathrm{tot}}},  \\text{if } E_{\\mathrm{tot}} > 0,\\\\\n0,  \\text{if } E_{\\mathrm{tot}} = 0.\n\\end{cases}\n$$\n\n您的任务是，对于下方的每个测试用例，确定数对 $[j^{\\star}, \\rho]$，该数对表征了残差能量最集中的尺度以及该尺度的显著程度。三角函数中的角度必须以弧度为单位。使用多层分解深度 $J = 5$ 和信号长度 $N = 256$。\n\n测试套件（每个用例指定了 $n \\in \\{0,1,\\dots,N-1\\}$ 的 $y_{\\mathrm{exp}}[n]$ 和 $y_{\\mathrm{model}}[n]$）：\n\n- 用例 $1$（低频正弦残差）：\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 4 \\cdot \\frac{n}{N}\\right)$，\n  - $y_{\\mathrm{model}}[n] = 0$ 对于所有 $n$。\n\n- 用例 $2$（高频正弦残差）：\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 40 \\cdot \\frac{n}{N}\\right)$，\n  - $y_{\\mathrm{model}}[n] = 0$ 对于所有 $n$。\n\n- 用例 $3$（完美模型，零残差）：\n  - $y_{\\mathrm{exp}}[n] = \\sin\\!\\left(2\\pi \\cdot 10 \\cdot \\frac{n}{N}\\right)$，\n  - $y_{\\mathrm{model}}[n] = \\sin\\!\\left(2\\pi \\cdot 10 \\cdot \\frac{n}{N}\\right)$。\n\n- 用例 $4$（局部瞬态残差）：\n  - $y_{\\mathrm{exp}}[n] = \\exp\\!\\left(-\\frac{(n - 100)^2}{2 \\cdot 5^2}\\right)$，\n  - $y_{\\mathrm{model}}[n] = 0$ 对于所有 $n$。\n\n您的程序必须为每个用例计算 $r[n]$，执行深度为 $J = 5$ 的 Haar DWT，计算 $j \\in \\{1,2,3,4,5\\}$ 的 $E_j$，然后根据上述定义计算 $j^{\\star}$ 和 $\\rho$。要求的最终输出格式为单行文本，其中包含四个测试用例的结果列表。每个结果是一个数对 $[j^{\\star}, \\rho]$，其中整数 $j^{\\star}$ 和浮点数 $\\rho$ 需四舍五入到小数点后恰好六位。该行必须格式化为有效的方括号列表，各项之间用逗号分隔，例如：\n$[[j^{\\star}_1,\\rho_1],[j^{\\star}_2,\\rho_2],[j^{\\star}_3,\\rho_3],[j^{\\star}_4,\\rho_4]]$。", "solution": "用户提供了一个问题，要求使用 Haar 小波对残差信号进行多层离散小波变换（DWT）分析。目标是为几个测试用例确定残差中能量集中的主导尺度。从问题验证到求解的整个过程都严格遵守科学和数学的正确性。\n\n### 步骤 1：问题验证\n\n首先对问题陈述进行严格的验证过程。\n\n- **提取已知条件**：所有定义、常数和公式都逐字提取：\n    - 信号长度 $N=256$，分解深度 $J=5$。\n    - 残差信号：$r[n] = y_{\\mathrm{exp}}[n] - y_{\\mathrm{model}}[n]$。\n    - 对于长度为 $M$ 的序列 $x$ 的单层 Haar DWT 公式：\n        - 近似：$a^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[2k] + x[2k+1])$\n        - 细节：$d^{(1)}[k] = \\frac{1}{\\sqrt{2}}(x[2k] - x[2k+1])$\n        - 变换的递归应用意味着对于第 $j$ 层，变换应用于长度为 $M = N/2^{j-1}$ 的 $a^{(j-1)}$。\n    - 第 $j$ 层的细节能量：$E_j = \\sum_{k} (d^{(j)}[k])^2$。\n    - 总细节能量：$E_{\\mathrm{tot}} = \\sum_{j=1}^{J} E_j$。\n    - 主导层级指数 $j^{\\star}$ 和主导比率 $\\rho$，以及针对 $E_{\\mathrm{tot}}=0$ 情况的特定规则和 $\\arg\\max$ 的平局决胜规则。\n    - 四个具有 $y_{\\mathrm{exp}}[n]$ 和 $y_{\\mathrm{model}}[n]$ 显式函数的测试用例。\n\n- **验证结论**：问题是**有效的**。\n    - 它在科学上**基于成熟的小波分析理论**。\n    - 它**定义明确** (well-posed)，所有定义、算法和参数都已指定，从而导向唯一解。$j^\\star$ 和 $\\rho$ 的定义是明确的。\n    - 它是**客观的**，完全基于数学公式和数值计算。\n    - 它是**完整且一致的**。递归 DWT 的定义清晰。\n    - 该问题完全属于计算工程中小波变换的指定主题范畴。\n\n### 步骤 2：求解推导\n\n解决方案是通过遵循问题陈述中提供的定义来实现的。每个测试用例的总体流程如下：\n1.  计算残差信号 $r[n]$。\n2.  对 $r[n]$ 执行 $J=5$ 层的 DWT，以获得 $j=1, \\dots, 5$ 的细节系数 $d^{(j)}$。\n3.  计算每个细节层的能量 $E_j$。\n4.  计算总细节能量 $E_{\\mathrm{tot}}$。\n5.  根据提供的规则确定主导层级 $j^{\\star}$ 和主导比率 $\\rho$。\n\n**1. 残差信号生成**\n对于每个测试用例，通过从实验信号 $y_{\\mathrm{exp}}[n]$ 中减去模型输出 $y_{\\mathrm{model}}[n]$ 来计算长度为 $N=256$ 的残差信号 $r[n]$，对每个样本 $n \\in \\{0, 1, \\dots, 255\\}$ 进行计算。\n\n**2. 多层 Haar DWT**\n设计一个函数来执行单层 Haar DWT。输入是长度为 $M$ 的信号 $x$。输出是近似系数 $a$ 和细节系数 $d$，两者长度均为 $M/2$。所提供的公式可简化为成对操作。对于 $k \\in \\{0, 1, \\dots, M/2-1\\}$：\n$$\na[k] = \\frac{1}{\\sqrt{2}}(x[2k] + x[2k+1])\n$$\n$$\nd[k] = \\frac{1}{\\sqrt{2}}(x[2k] - x[2k+1])\n$$\n此操作可使用 `numpy` 中的向量化运算高效实现。多层分解从残差信号 $r[n]$ 开始，将其作为初始近似系数 $a^{(0)}$。然后递归应用单层 DWT 共 $J=5$ 次。在每一层 $j$ 中，近似系数 $a^{(j-1)}$ 被分解为 $a^{(j)}$ 和 $d^{(j)}$。收集每一层的细节系数 $d^{(j)}$。\n\n**3. 能量计算**\n对于每组细节系数 $d^{(j)}$，根据定义 $E_j = \\sum_{k} (d^{(j)}[k])^2$ 通过对其元素平方求和来计算相应的能量 $E_j$。这等同于系数向量的 $L^2$ 范数的平方。总细节能量 $E_{\\mathrm{tot}}$ 是这些单个层级能量的总和。\n\n**4. 主导尺度和比率计算**\n最终分析取决于 $E_{\\mathrm{tot}}$ 的值。\n- 如果 $E_{\\mathrm{tot}}$ 实际上为零（低于一个小的浮点容差，例如 $10^{-12}$），则根据定义，$j^{\\star} = 0$ 且 $\\rho = 0$。这种情况适用于残差信号为常数（包括零）时，因为此时所有 Haar 细节系数都将为零。\n- 如果 $E_{\\mathrm{tot}}  0$，则通过识别具有最大能量的层级来找到主导层级 $j^{\\star}$，即 $j^{\\star} = \\arg\\max_{j \\in \\{1,\\dots,5\\}} E_j$。问题规定，在出现平局的情况下，选择最小的 $j$。`numpy.argmax` 函数通过返回第一个最大值的索引自然满足了这一要求。然后计算主导比率 $\\rho = E_{j^{\\star}} / E_{\\mathrm{tot}}$。\n\n**5. 测试用例分析**\n- **用例 1（低频）：** 残差是一个频率为 $f=4$ 周期/记录的正弦波，归一化频率为 $f/N = 4/256 = 1/64$。DWT 充当一个滤波器组，该频率落在与细节层级 $j=5$ 对应的频带内（该频带大致覆盖 $[1/64, 1/32]$ 的归一化频率）。因此，我们预期 $j^{\\star}=5$。\n- **用例 2（高频）：** 残差是一个频率为 $f=40$ 周期/记录的正弦波，归一化频率为 $f/N = 40/256 = 5/32 = 0.15625$。该频率在与细节层级 $j=2$ 对应的频带内（该频带大致覆盖 $[1/8, 1/4]$ 或 $[0.125, 0.25]$ 的归一化频率）。因此，我们预期 $j^{\\star}=2$。\n- **用例 3（零残差）：** 残差恒为零。所有细节系数和能量都将为零。因此，$E_{\\mathrm{tot}}=0$，导致 $j^{\\star}=0$ 和 $\\rho=0$。\n- **用例 4（局部瞬态）：** 残差是一个窄高斯脉冲。这种特征在时间上是局部的，在频率上是宽带的，意味着其能量分布在多个尺度上。该特征的尺度（宽度 $\\sigma=5$）与大小相似的小波尺度最匹配。层级 $j$ 对应于大小为 $2^j$ 的特征。由于 $2^2=4$ 和 $2^3=8$，能量预计将集中在层级 $j=2$ 和 $j=3$ 附近。计算将揭示哪个是主导的。\n\n最终计算出的值按照规定格式化为字符串，其中浮点数 $\\rho$ 使用标准四舍五入约定（五入）表示，保留六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dwt_level(x: np.ndarray) - tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes one level of the Haar Discrete Wavelet Transform.\n    The implementation is a vectorized version of the formulas given in the problem.\n    \"\"\"\n    # The formulas are x[2k] and x[2k+1], which corresponds to even and odd indices.\n    x_even = x[0::2]\n    x_odd = x[1::2]\n    \n    inv_sqrt2 = 1.0 / np.sqrt(2.0)\n    \n    # Approximation coefficients\n    a_next = (x_even + x_odd) * inv_sqrt2\n    \n    # Detail coefficients\n    d_next = (x_even - x_odd) * inv_sqrt2\n    \n    return a_next, d_next\n\ndef analyze_residual(r: np.ndarray, J: int) - list:\n    \"\"\"\n    Performs a J-level DWT on the residual signal r and computes\n    the dominant level index j_star and dominance ratio rho.\n    \"\"\"\n    # Perform J-level DWT and collect detail coefficients\n    all_details = []\n    a_current = r.copy()\n    for _ in range(J):\n        a_current, d_next = dwt_level(a_current)\n        all_details.append(d_next)\n    \n    # Compute energies for each level\n    # E_j = sum(d_j[k]^2)\n    energies = [np.sum(d**2) for d in all_details]\n    \n    # Compute total detail energy\n    total_energy = np.sum(energies)\n    \n    # A small tolerance for floating-point comparison with zero\n    if total_energy > 1e-12:\n        max_energy = np.max(energies)\n        # np.argmax returns the first index of the maximum value,\n        # satisfying the tie-breaking rule (smallest j).\n        # Levels are 1-indexed, so we add 1.\n        j_star = np.argmax(energies) + 1\n        rho = max_energy / total_energy\n    else:\n        # If total energy is zero, use the specified values.\n        j_star = 0\n        rho = 0.0\n        \n    return [j_star, rho]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final result.\n    \"\"\"\n    # Global parameters from the problem statement\n    N = 256\n    J = 5\n    n = np.arange(N)\n    \n    # Define the test cases\n    test_cases = [\n        # Case 1: Low-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 4 * n / N),\n            np.zeros(N)\n        ),\n        # Case 2: High-frequency sinusoidal residual\n        (\n            np.sin(2 * np.pi * 40 * n / N),\n            np.zeros(N)\n        ),\n        # Case 3: Perfect model, zero residual\n        (\n            np.sin(2 * np.pi * 10 * n / N),\n            np.sin(2 * np.pi * 10 * n / N)\n        ),\n        # Case 4: Localized transient residual\n        (\n            np.exp(-(n - 100)**2 / (2 * 5**2)),\n            np.zeros(N)\n        )\n    ]\n\n    results = []\n    for y_exp, y_mod in test_cases:\n        # Calculate the residual signal for the current case\n        residual = y_exp - y_mod\n        \n        # Analyze the residual and get [j*, rho]\n        result = analyze_residual(residual, J)\n        results.append(result)\n\n    # Format the final output string precisely as required: [[j1,rho1],[j2,rho2],...]\n    # The format string {res[1]:.6f} ensures rho is rounded to 6 decimal places.\n    result_strings = [f\"[{res[0]},{res[1]:.6f}]\" for res in results]\n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2450301"}]}