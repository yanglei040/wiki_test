{"hands_on_practices": [{"introduction": "移动平均滤波器是数字信号处理中最基础且广泛应用的工具之一，它通过平均最近的信号样本来平滑数据。本练习将从两个核心角度探索其特性：首先，在时域中推导其高效的递归实现，这在实时应用中至关重要；其次，在变换域中确定其传递函数 $H(z)$。这项实践旨在建立时域操作直觉与z变换分析框架之间的桥梁，让你掌握分析滤波器行为和优化其计算的关键技能。[@problem_id:2436705]", "problem": "一个因果长度为 $M$ 的移动平均滤波器，也称为矩形或箱型平滑器，其对于离散时间输入 $x[n]$ 的输出定义为\n$$\ny[n] \\triangleq \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-k],\n$$\n其中整数 $M \\geq 2$。假设对于所有 $n0$，$x[n]=0$ 且 $y[n]=0$。仅从该定义出发，推导一个仅使用 $y[n-1]$、$x[n]$ 和 $x[n-M]$ 来计算 $y[n]$ 的单步递推公式。然后，使用双边 $z$ 变换（ZT）的定义，确定该滤波器的传递函数 $H(z) \\triangleq \\frac{Y(z)}{X(z)}$ 的闭合形式。将最终答案表示为关于 $z^{-1}$ 的单一简化有理函数。无需数值取整，也不涉及物理单位。只需提供 $H(z)$ 的最终符号表达式作为答案。", "solution": "问题陈述已被解析和验证。它被认为是自洽的、科学上合理的且格式良好的。这是一个数字信号处理理论中的标准练习。我们开始推导。\n\n该问题要求基于因果长度为 $M$ 的移动平均滤波器的定义进行两部分的推导：\n$$\ny[n] \\triangleq \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-k]\n$$\n其中 $M$ 是一个满足 $M \\geq 2$ 的整数。\n\n首先，我们推导 $y[n]$ 的单步递推公式。\n在时间步 $n$ 的输出定义为：\n$$\ny[n] = \\frac{1}{M} \\left( x[n] + x[n-1] + \\dots + x[n-M+1] \\right)\n$$\n我们写出前一时间步 $n-1$ 的输出表达式：\n$$\ny[n-1] = \\frac{1}{M} \\sum_{k=0}^{M-1} x[n-1-k]\n$$\n展开这个求和式得到：\n$$\ny[n-1] = \\frac{1}{M} \\left( x[n-1] + x[n-2] + \\dots + x[n-1-(M-1)] \\right)\n$$\n$$\ny[n-1] = \\frac{1}{M} \\left( x[n-1] + x[n-2] + \\dots + x[n-M] \\right)\n$$\n为了找到 $y[n]$ 和 $y[n-1]$ 之间的关系，我们通过分离出最新的样本 $x[n]$ 来重排 $y[n]$ 的表达式：\n$$\nM \\cdot y[n] = x[n] + \\sum_{k=1}^{M-1} x[n-k]\n$$\n现在，我们重排 $y[n-1]$ 的表达式，以分离出出现在 $y[n]$ 方程中的求和项。让我们在 $y[n-1]$ 的定义中进行指标变换 $j = k+1$：\n$$\nM \\cdot y[n-1] = \\sum_{k=0}^{M-1} x[n-1-k] = \\sum_{j=1}^{M} x[n-j]\n$$\n这个求和式可以写成：\n$$\nM \\cdot y[n-1] = \\left( \\sum_{j=1}^{M-1} x[n-j] \\right) + x[n-M]\n$$\n由此，我们可以用 $y[n-1]$ 和 $x[n-M]$ 来表示求和项 $\\sum_{j=1}^{M-1} x[n-j]$：\n$$\n\\sum_{j=1}^{M-1} x[n-j] = M \\cdot y[n-1] - x[n-M]\n$$\n求和指标是哑变量，因此 $\\sum_{k=1}^{M-1} x[n-k] = \\sum_{j=1}^{M-1} x[n-j]$。我们将此表达式代回到 $M \\cdot y[n]$ 的方程中：\n$$\nM \\cdot y[n] = x[n] + (M \\cdot y[n-1] - x[n-M])\n$$\n两边除以 $M$ 得到所需的单步递推公式：\n$$\ny[n] = y[n-1] + \\frac{1}{M} \\left( x[n] - x[n-M] \\right)\n$$\n这种形式计算效率很高，因为无论滤波器长度 $M$ 为多少，每个输出样本只需要两次加法和一次乘法。\n\n其次，我们使用双边 $z$ 变换的定义来确定传递函数 $H(z) = \\frac{Y(z)}{X(z)}$。传递函数是滤波器冲激响应 $h[n]$ 的 $z$ 变换。冲激响应是当输入为离散时间单位冲激信号 $x[n] = \\delta[n]$ 时滤波器的输出。\n将 $x[n]=\\delta[n]$ 代入滤波器定义，得到 $h[n]$：\n$$\nh[n] = \\frac{1}{M} \\sum_{k=0}^{M-1} \\delta[n-k]\n$$\n项 $\\delta[n-k]$ 仅在 $n-k=0$ 时（即 $k=n$ 时）等于 $1$，否则为零。求和的范围是 $k$ 从 $0$ 到 $M-1$。因此，对于给定的 $n$，仅当 $n$ 在范围 $[0, M-1]$ 内时，求和才不为零。如果 $n$ 在此范围内，求和中恰好有一项（即 $k=n$ 的那一项）不为零且等于 $1$。\n因此，冲激响应为：\n$$\nh[n] = \\begin{cases} \\frac{1}{M}  \\text{对于 } 0 \\le n \\le M-1 \\\\ 0  \\text{否则} \\end{cases}\n$$\n现在，我们将双边 $z$ 变换的定义应用于 $h[n]$ 以求得 $H(z)$：\n$$\nH(z) = \\sum_{n=-\\infty}^{\\infty} h[n] z^{-n}\n$$\n代入 $h[n]$ 的表达式限制了求和范围：\n$$\nH(z) = \\sum_{n=0}^{M-1} \\left(\\frac{1}{M}\\right) z^{-n} = \\frac{1}{M} \\sum_{n=0}^{M-1} z^{-n}\n$$\n该求和是一个形式为 $\\sum_{n=0}^{N-1} r^n$ 的有限几何级数，其中有 $N=M$ 项，公比为 $r = z^{-1}$。这种级数的和由公式 $\\frac{1-r^N}{1-r}$ 给出。\n应用此公式，我们得到：\n$$\n\\sum_{n=0}^{M-1} (z^{-1})^n = \\frac{1 - (z^{-1})^M}{1 - z^{-1}} = \\frac{1 - z^{-M}}{1 - z^{-1}}\n$$\n将此结果代回到 $H(z)$ 的表达式中，我们得到以 $z^{-1}$ 的有理函数表示的传递函数的最终简化形式：\n$$\nH(z) = \\frac{1}{M} \\frac{1 - z^{-M}}{1 - z^{-1}}\n$$\n该表达式表示了系统在 $z$ 域中的行为。", "answer": "$$\n\\boxed{\\frac{1}{M} \\frac{1 - z^{-M}}{1 - z^{-1}}}\n$$", "id": "2436705"}, {"introduction": "傅里叶变换是信号处理的基石，它使我们能够从频率内容的角度审视信号。通过将信号转换到频域，我们可以轻松识别并移除不期望的成分，例如噪声。这个实践性的编码练习将指导你实现一个强大的去噪工作流：你将对一个含噪信号进行变换，在频域中应用阈值来“净化”频谱，然后通过逆变换恢复出更清晰的信号，从而获得频谱滤波的直接经验。[@problem_id:2383381]", "problem": "设一个离散时间信号定义在一个包含 $N$ 个样本的均匀采样网格上，采样频率为 $F_s$（单位为赫兹）。该网格为 $t_n = \\dfrac{n}{F_s}$，其中 $n \\in \\{0,1,\\dots,N-1\\}$，所有角度均以弧度为单位。考虑一个纯净的音符，其模型为一个单位振幅、频率为 $f_0$（单位为赫兹）的单个正弦波 $s_n = \\sin(2\\pi f_0 t_n)$。观测信号是纯净音符与一个由两个正弦波组成的确定性加性噪声之和：\n$$\nx_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\n对于一个序列 $\\{x_n\\}_{n=0}^{N-1}$，定义离散傅里叶变换 (DFT) 及其逆变换如下：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\n对于给定的阈值分数 $\\tau \\in [0,1]$，通过将所有幅值低于最大谱幅值 $\\tau$ 倍的系数置零来定义滤波后的频谱：\n$$\nM = \\max_{0 \\le k \\le N-1} |X_k|,\\qquad\nY_k = \\begin{cases}\nX_k, \\text{if } |X_k| \\ge \\tau M,\\\\\n0, \\text{otherwise.}\n\\end{cases}\n$$\n滤波后的时域信号由下式给出：\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\n对每个测试用例，计算滤波后信号与纯净信号之间的均方根误差 (RMSE)，\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} \\left(y_n - s_n\\right)^2},\n$$\n该值是无量纲的。\n\n所有三角函数中的角度参数必须以弧度为单位。频率单位为赫兹。输出不需要其他物理单位。\n\n测试套件：\n- 情况 $1$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.25)$。\n- 情况 $2$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 512,\\ 0.90)$。\n- 情况 $3$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 440,\\ 0.00)$。\n- 情况 $4$：$(F_s, N, f_0, \\tau) = (8192,\\ 1024,\\ 2048,\\ 0.75)$。\n\n你的程序必须：\n- 对每个测试用例，使用相应的 $F_s$、$N$ 和 $f_0$ 严格按照上述定义构建 $s_n$ 和 $x_n$。\n- 计算 $x_n$ 的 DFT $X_k$，应用由 $\\tau$ 参数化的频谱阈值规则，计算逆变换以获得 $y_n$，然后计算相对于 $s_n$ 的 $\\mathrm{RMSE}$。\n\n最终输出格式：\n- 生成单行输出，其中包含对应于上述情况的四个 $\\mathrm{RMSE}$ 值，四舍五入到恰好 $6$ 位小数，格式为用方括号括起来的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_j$ 在小数点后恰好有 $6$ 位数字。", "solution": "该问题要求将一个带噪正弦信号变换到频域，去除相对于最大谱幅值而言幅值较小的谱分量，然后变换回时域，通过计算与纯净信号的均方根误差 (RMSE) 来评估去噪性能。这直接依赖于离散傅里叶变换 (DFT) 及其逆变换的定义。\n\n从基本定义开始。对于 $N$ 个时间样本 $\\{x_n\\}_{n=0}^{N-1}$，离散傅里叶变换 (DFT) 为：\n$$\nX_k = \\sum_{n=0}^{N-1} x_n\\, e^{-i 2\\pi kn/N},\\quad k=0,1,\\dots,N-1,\n$$\n其逆变换为：\n$$\n\\widehat{x}_n = \\frac{1}{N} \\sum_{k=0}^{N-1} X_k\\, e^{i 2\\pi kn/N},\\quad n=0,1,\\dots,N-1.\n$$\nDFT 是一个线性基变换，将时域序列转换为频率为 $2\\pi k/N$ 的离散复指数之和的表示形式。对于实数序列，谱分量以共轭对称对的形式出现，但上述通用形式在所有情况下都成立。\n\n信号模型。纯净信号为 $s_n = \\sin(2\\pi f_0 t_n)$，具有单位振幅和频率 $f_0$，在 $t_n = n/F_s$ 处采样。噪声是确定性的，定义为两个正弦波之和：\n$$\nn_n = 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n).\n$$\n观测信号为 $x_n = s_n + n_n$。由于 $F_s = 8192$ 且 $N = 1024$，频率分辨率为 $\\Delta f = F_s/N = 8$。所选频率 $f_0 \\in \\{440, 512, 2048\\}$ 以及噪声频率 $1000$ 和 $3000$ 都是 $\\Delta f$ 的整数倍，这确保了在 $N$ 个样本内每个正弦波都完成整数个周期。这使得相应的 DFT 能量集中在精确的频率仓中，并强制了不同正弦波在有限序列上的正交性。特别地，在情况 $3$ 中，$\\tau = 0$，不执行任何滤波，此时相对于纯净信号的 RMSE 等于噪声的均方根：\n$$\n\\mathrm{RMSE}_{\\tau=0} = \\sqrt{\\frac{1}{N}\\sum_{n=0}^{N-1} n_n^2} = \\sqrt{\\frac{(0.15)^2}{2} + \\frac{(0.10)^2}{2}},\n$$\n因为这些正弦波是正交的，并且 $\\sin^2$ 在整数个周期内的平均值为 $1/2$。\n\n滤波规则。给定频谱 $X_k$，定义 $M = \\max_k |X_k|$，并通过仅保留那些满足 $|X_k| \\ge \\tau M$ 的谱系数来进行阈值处理。滤波后的频谱是\n$$\nY_k = \\begin{cases}\nX_k, |X_k| \\ge \\tau M,\\\\\n0, \\text{otherwise.}\n\\end{cases}\n$$\n滤波后的时域信号通过逆变换获得：\n$$\ny_n = \\frac{1}{N} \\sum_{k=0}^{N-1} Y_k\\, e^{i 2\\pi kn/N}.\n$$\n去噪性能由均方根误差量化\n$$\n\\mathrm{RMSE} = \\sqrt{\\frac{1}{N} \\sum_{n=0}^{N-1} (y_n - s_n)^2}.\n$$\n\n高效计算。根据定义直接计算 DFT 及其逆变换的复杂度为 $\\mathcal{O}(N^2)$。对于 $N$ 是 2 的幂的情况，可以通过将求和递归地划分为偶数和奇数索引的子序列，并使用旋转因子 $e^{-i 2\\pi k/N}$ 将它们组合起来，从而在 $\\mathcal{O}(N \\log_2 N)$ 时间内评估变换。这就是基-2分治法的原理。令 $x^{(e)}_m = x_{2m}$ 和 $x^{(o)}_m = x_{2m+1}$，其中 $m=0,\\dots,N/2-1$。那么\n$$\nX_k = E_k + W_N^k O_k,\\quad X_{k+N/2} = E_k - W_N^k O_k,\\quad k=0,\\dots,N/2-1,\n$$\n其中 $E_k$ 和 $O_k$ 分别是偶数和奇数子序列的 DFT，而 $W_N^k = e^{-i 2\\pi k/N}$。逆变换可以类似地计算，或通过共轭和缩放来计算：\n$$\n\\mathrm{iDFT}(X)_n = \\frac{1}{N} \\overline{\\mathrm{DFT}(\\overline{X})_n}.\n$$\n\n基于第一性原理的实现计划：\n- 对每个测试用例，构建 $t_n = n/F_s$，$s_n = \\sin(2\\pi f_0 t_n)$，以及 $x_n = s_n + 0.15\\,\\sin(2\\pi \\cdot 1000\\, t_n) + 0.10\\,\\sin(2\\pi \\cdot 3000\\, t_n)$。\n- 使用基-2分治法计算 $N=1024$ 时 DFT 的 $X_k$。\n- 计算 $M = \\max_k |X_k|$ 并根据阈值规则 $|X_k| \\ge \\tau M$ 定义 $Y_k$。\n- 通过逆变换计算 $y_n$ 并提取其实部（虚部是数值舍入误差）。\n- 按定义计算 $\\mathrm{RMSE}$。\n- 将每个 $\\mathrm{RMSE}$ 四舍五入到恰好 $6$ 位小数，并将四个结果打印为单个列表 $[r_1,r_2,r_3,r_4]$。\n\n该过程为每个测试用例生成一组四个浮点值，量化了在指定的确定性噪声下，阈值参数 $\\tau$ 和音符频率 $f_0$ 如何影响去噪质量。$\\tau = 0$ 的情况再现了未滤波的基线，而较大的 $\\tau$ 值会抑制较弱的谱内容，并且对于这些具有频率仓对齐正弦波的信号，能更有效地保留主导的音符分量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fft_radix2(x: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the DFT of a 1-D complex array x using a radix-2 Cooley–Tukey algorithm.\n    Length of x must be a power of two.\n    \"\"\"\n    x = np.asarray(x, dtype=np.complex128)\n    N = x.shape[0]\n    if N == 1:\n        return x.copy()\n    if N % 2 != 0:\n        raise ValueError(\"Input length must be a power of two for radix-2 FFT.\")\n    # Recursively compute FFT of even and odd indexed elements\n    X_even = fft_radix2(x[::2])\n    X_odd = fft_radix2(x[1::2])\n    # Twiddle factors\n    k = np.arange(N // 2, dtype=np.float64)\n    twiddle = np.exp(-2j * np.pi * k / N)\n    top = X_even + twiddle * X_odd\n    bottom = X_even - twiddle * X_odd\n    return np.concatenate((top, bottom))\n\ndef ifft_radix2(X: np.ndarray) - np.ndarray:\n    \"\"\"\n    Compute the inverse DFT using the conjugate trick and the radix-2 FFT.\n    \"\"\"\n    X = np.asarray(X, dtype=np.complex128)\n    N = X.shape[0]\n    # iDFT(x) = conj(DFT(conj(x))) / N\n    return np.conjugate(fft_radix2(np.conjugate(X))) / N\n\ndef is_power_of_two(n: int) - bool:\n    return n  0 and (n  (n - 1)) == 0\n\ndef generate_signals(Fs: int, N: int, f0: float):\n    \"\"\"\n    Generate clean sinusoid s_n and observed x_n = s_n + deterministic noise.\n    Noise frequencies are 1000 Hz and 3000 Hz with amplitudes 0.15 and 0.10, respectively.\n    \"\"\"\n    if not is_power_of_two(N):\n        raise ValueError(\"N must be a power of two.\")\n    t = np.arange(N, dtype=np.float64) / float(Fs)\n    s = np.sin(2.0 * np.pi * f0 * t)\n    noise = 0.15 * np.sin(2.0 * np.pi * 1000.0 * t) + 0.10 * np.sin(2.0 * np.pi * 3000.0 * t)\n    x = s + noise\n    return s, x\n\ndef spectral_threshold_filter(x: np.ndarray, tau: float) - np.ndarray:\n    \"\"\"\n    Apply frequency-domain thresholding: zero coefficients below tau * max |X_k|.\n    Returns the filtered time-domain signal y (real-valued).\n    \"\"\"\n    X = fft_radix2(x.astype(np.complex128))\n    mags = np.abs(X)\n    M = mags.max() if X.size  0 else 0.0\n    threshold = tau * M\n    mask = mags = threshold\n    Y = X * mask\n    y = ifft_radix2(Y)\n    # Numerical residual imaginary part may appear due to finite precision.\n    return np.real(y)\n\ndef rmse(a: np.ndarray, b: np.ndarray) - float:\n    diff = a - b\n    return float(np.sqrt(np.mean(diff * diff)))\n\ndef solve():\n    # Define the test cases from the problem statement: (Fs, N, f0, tau)\n    test_cases = [\n        (8192, 1024, 440.0, 0.25),\n        (8192, 1024, 512.0, 0.90),\n        (8192, 1024, 440.0, 0.00),\n        (8192, 1024, 2048.0, 0.75),\n    ]\n\n    results = []\n    for Fs, N, f0, tau in test_cases:\n        s, x = generate_signals(Fs, N, f0)\n        y = spectral_threshold_filter(x, tau)\n        value = rmse(y, s)\n        results.append(f\"{value:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383381"}, {"introduction": "虽然快速傅里叶变换 (FFT) 是分析整个频谱的强大工具，但它并非总是最高效的选择。在某些应用中，我们只关心某个特定频率是否存在，例如在电话的按键音（DTMF）检测中。在这种情况下，直接评估离散时间傅里叶变换 (DTFT) 在该单一频率点的值，提供了一种更为高效的解决方案。本练习将挑战你实现一种目标明确的频率检测算法，通过专注于单一频率，你将体会到通用工具（如FFT）与针对性算法之间的权衡，并加深对DTFT基本定义的理解。[@problem_id:2436633]", "problem": "你需要编写一个完整的、可运行的程序。对于给定的一组离散时间信号和参数，该程序通过将离散时间傅里叶变换在单一角频率上的平方幅值与预设阈值进行比较，来判断指定的频率分量是否存在。所有推导都必须基于第一性原理。频率必须以赫兹（Hz）表示，时长以秒表示，相位以弧度表示。当涉及随机噪声时，它必须是零均值、白高斯噪声，具有指定的方差，并使用固定的种子 $0$ 生成以确保确定性。\n\n对于每个测试案例，你必须：\n1. 在采样频率 $f_s$ Hz下，合成一个长度为 $N$ 个样本的实值离散时间信号 $x[n]$。该信号是一个有限数量、具有给定幅值、频率和相位的实正弦波之和，再加上具有指定方差的加性噪声。\n2. 设目标频率为 $f_t$ Hz，对应的角频率为 $\\omega_t = 2\\pi f_t / f_s$ 弧度/样本。\n3. 计算 $x[n]$ 的离散时间傅里叶变换在 $\\omega_t$ 处的值的平方幅值，即等于该单频率变换的复数量的平方幅值。\n4. 将此非负实数与给定的阈值 $\\Theta$ 进行比较。当且仅当计算值严格大于 $\\Theta$ 时，声明该频率分量存在。\n\n你的程序必须处理以下所有测试案例，并输出单行文本，其中包含一个用方括号括起来的、以逗号分隔的布尔值列表，其顺序与测试案例的顺序相同（例如，[True,False,True]）。\n\n测试套件（除非另有说明，所有相位均为 $0$ 弧度）：\n- 案例 A (理想情况，精确匹配，整数周期)：$f_s = 8000$ Hz，$N = 800$，目标频率 $f_t = 800$ Hz。信号分量：一个频率为 $800$ Hz、幅值为 $0.5$ 的余弦波。噪声方差 $0$。阈值 $\\Theta = 10000$。\n- 案例 B (不存在情况，正交音调，整数周期)：$f_s = 8000$ Hz，$N = 800$，目标频率 $f_t = 800$ Hz。信号分量：一个频率为 $1000$ Hz、幅值为 $0.5$ 的余弦波。噪声方差 $0$。阈值 $\\Theta = 10000$。\n- 案例 C (邻近频率，短窗口，无噪声)：$f_s = 8000$ Hz，$N = 205$，目标频率 $f_t = 697$ Hz。信号分量：一个频率为 $700$ Hz、幅值为 $0.5$ 的余弦波。噪声方差 $0$。阈值 $\\Theta = 2700$。\n- 案例 D (直流分量)：$f_s = 4000$ Hz，$N = 400$，目标频率 $f_t = 0$ Hz。信号分量：一个幅值为 $0.3$ 的恒定偏移。噪声方差 $0$。阈值 $\\Theta = 3600$。\n- 案例 E (奈奎斯特频率分量)：$f_s = 4000$ Hz，$N = 400$，目标频率 $f_t = 2000$ Hz。信号分量：一个频率为 $2000$ Hz、幅值为 $0.4$ 的余弦波。噪声方差 $0$。阈值 $\\Theta = 6400$。\n- 案例 F (带噪声的短窗口，精确匹配，整数周期)：$f_s = 8000$ Hz，$N = 80$，目标频率 $f_t = 1000$ Hz。信号分量：一个频率为 $1000$ Hz、幅值为 $0.4$ 的余弦波。噪声方差 $0.01$。阈值 $\\Theta = 128$。\n\n任何相位的角度单位均为弧度。你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表形式的结果（例如，[True,False,True]）。", "solution": "此问题要求判断一个离散时间信号中是否存在特定的频率分量。该方法基于数字信号处理的一个基础工具：离散时间傅里叶变换 (DTFT)。具体流程是计算 DTFT 在单一目标频率上的平方幅值，并将此能量值与给定阈值进行比较。该问题是适定的，并且在科学上是合理的，允许直接的解析解和计算解。\n\n我们首先建立数学框架。\n\n一个实值离散时间信号 $x[n]$（定义域为 $n \\in \\{0, 1, \\dots, N-1\\}$）被合成为一个确定性信号 $s[n]$ 和一个加性噪声分量 $w[n]$ 的和。\n$$x[n] = s[n] + w[n]$$\n确定性部分 $s[n]$ 是 $M$ 个正弦分量的叠加：\n$$s[n] = \\sum_{k=1}^{M} A_k \\cos(2\\pi \\frac{f_k}{f_s} n + \\phi_k) = \\sum_{k=1}^{M} A_k \\cos(\\omega_k n + \\phi_k)$$\n其中 $A_k$、$f_k$ 和 $\\phi_k$ 分别是第 $k$ 个正弦波的振幅、频率（单位为 Hz）和相位（单位为弧度）。采样频率为 $f_s$（单位为 Hz），$\\omega_k = 2\\pi f_k / f_s$ 是角频率（单位为弧度/样本）。\n噪声 $w[n]$ 是一个零均值、白高斯过程，其方差为 $\\sigma^2$，记作 $w[n] \\sim \\mathcal{N}(0, \\sigma^2)$。\n\n信号 $x[n]$ 的离散时间傅里叶变换是频率 $\\omega$ 的一个复值函数，由下式给出：\n$$X(e^{j\\omega}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega n}$$\n该变换将 $N$ 点时域信号 $x[n]$ 映射到其频域表示。为了测试在目标频率 $f_t$（或角频率 $\\omega_t = 2\\pi f_t / f_s$）处是否存在频率分量，我们在 $\\omega = \\omega_t$ 处计算 DTFT：\n$$X(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$$\n这个复数的平方幅值 $|X(e^{j\\omega_t})|^2$ 代表了信号在频率 $\\omega_t$ 处的能量。决策规则是，当且仅当该值严格大于指定的阈值 $\\Theta$ 时，声明该频率分量存在：\n$$\\text{存在} \\iff |X(e^{j\\omega_t})|^2  \\Theta$$\n\n根据 DTFT 的线性性质，我们可以写出：\n$$X(e^{j\\omega_t}) = S(e^{j\\omega_t}) + W(e^{j\\omega_t})$$\n其中 $S(e^{j\\omega_t})$ 和 $W(e^{j\\omega_t})$ 分别是信号分量和噪声分量的 DTFT。每一项都可以进行分析。对于单个正弦分量 $s[n] = A \\cos(\\omega_0 n)$，其 DTFT 为：\n$$S(e^{j\\omega}) = \\frac{A}{2} \\left[ \\sum_{n=0}^{N-1} e^{j(\\omega_0 - \\omega)n} + \\sum_{n=0}^{N-1} e^{-j(\\omega_0 + \\omega)n} \\right]$$\n此变换的幅值在 $\\omega = \\omega_0$ 和 $\\omega = -\\omega_0$ 处有尖锐的峰值。如果信号频率 $f_0$ 和采样点数 $N$ 使得整数个周期恰好落在观测窗口内（即 $f_0 \\cdot N/f_s = k$，其中 k 为整数），那么 $f_0$ 就是一个 N 点离散傅里叶变换 (DFT) 的“谱线中心”。在这种特殊情况下，如果我们在 $\\omega_t = \\omega_0$（且 $\\omega_0$ 不为 $0$ 或 $\\pi$）处进行测试，幅值将达到最大，且 $|S(e^{j\\omega_0})|^2 = (A N/2)^2$。如果我们在另一个谱线中心 $\\omega_t \\neq \\omega_0$ 处进行测试，那么由于 DFT 基向量的正交性，$S(e^{j\\omega_t}) = 0$。对于不位于谱线中心的频率，能量会“泄漏”到相邻的频率中，这种现象被称为频谱泄漏。\n\n噪声的变换 $W(e^{j\\omega_t}) = \\sum_{n=0}^{N-1} w[n] e^{-j\\omega_t n}$ 是缩放后的高斯随机变量之和。其期望值为 $0$，对于足够大的 $N$，其特性是众所周知的。然而，对于使用固定种子的单次实现，它是一个确定性的复数，会加到信号的变换值上。\n\n每个测试案例的计算过程如下：\n1. 定义时间向量 $n = [0, 1, \\dots, N-1]$。\n2. 根据指定的参数，通过对给定的正弦分量求和来合成信号 $s[n]$。\n3. 如果噪声方差 $\\sigma^2  0$，使用以种子 $0$ 初始化的随机数生成器生成噪声向量 $w[n]$。生成器的标准差将是 $\\sigma = \\sqrt{\\sigma^2}$。\n4. 形成最终信号 $x[n] = s[n] + w[n]$。\n5. 计算目标角频率 $\\omega_t = 2\\pi f_t / f_s$。\n6. 通过执行求和 $\\sum_{n=0}^{N-1} x[n] e^{-j\\omega_t n}$ 来计算复数 DTFT 值 $X(e^{j\\omega_t})$。\n7. 计算其平方幅值 $|X(e^{j\\omega_t})|^2 = (\\text{Re}\\{X(e^{j\\omega_t})\\})^2 + (\\text{Im}\\{X(e^{j\\omega_t})\\})^2$。\n8. 将结果与阈值 $\\Theta$ 进行比较，以做出最终的布尔决策。\n\n此过程构成了解决该问题的完整算法。实现将对每个提供的测试案例精确地遵循这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the frequency component detection problem for a suite of test cases.\n    \"\"\"\n    \n    # Test cases defined as tuples:\n    # (f_s, N, f_t, components, noise_variance, threshold)\n    # where components is a list of (amplitude, frequency, phase) tuples.\n    test_cases = [\n        # Case A: happy path, exact match, integer cycles\n        (8000, 800, 800, [(0.5, 800, 0)], 0, 10000),\n        # Case B: absence case, orthogonal tone, integer cycles\n        (8000, 800, 800, [(0.5, 1000, 0)], 0, 10000),\n        # Case C: nearby frequency, short window, no noise\n        (8000, 205, 697, [(0.5, 700, 0)], 0, 2700),\n        # Case D: direct current component\n        (4000, 400, 0, [(0.3, 0, 0)], 0, 3600),\n        # Case E: Nyquist frequency component\n        (4000, 400, 2000, [(0.4, 2000, 0)], 0, 6400),\n        # Case F: short window with noise, exact match, integer cycles\n        (8000, 80, 1000, [(0.4, 1000, 0)], 0.01, 128)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        f_s, N, f_t, components, noise_var, threshold = case\n        \n        # 1. Synthesize the discrete-time signal x[n]\n        \n        # Time vector from n=0 to N-1\n        n = np.arange(N)\n        \n        # Initialize signal s[n] with zeros\n        s_n = np.zeros(N)\n        \n        # Add sinusoidal components\n        for amp, freq, phase in components:\n            # Angular frequency of the component: omega = 2*pi*f/f_s\n            omega_k = 2 * np.pi * freq / f_s\n            s_n += amp * np.cos(omega_k * n + phase)\n            \n        # Add additive white Gaussian noise (AWGN) if specified\n        if noise_var  0:\n            # Set the seed for reproducibility. It is reset for each case involving noise.\n            np.random.seed(0)\n            std_dev = np.sqrt(noise_var)\n            w_n = np.random.normal(0, std_dev, N)\n            x_n = s_n + w_n\n        else:\n            x_n = s_n\n            \n        # 2. Define the target angular frequency omega_t\n        omega_t = 2 * np.pi * f_t / f_s\n        \n        # 3. Compute the squared magnitude of the DTFT at omega_t\n        \n        # Complex exponential term for the DTFT calculation\n        # exp(-j * omega_t * n)\n        complex_exp = np.exp(-1j * omega_t * n)\n        \n        # DTFT value X(exp(j*omega_t)) = sum(x[n] * exp(-j*omega_t*n))\n        dtft_val = np.sum(x_n * complex_exp)\n        \n        # Squared magnitude\n        squared_magnitude = np.abs(dtft_val)**2\n        \n        # 4. Compare with the threshold and store the boolean result\n        is_present = squared_magnitude  threshold\n        results.append(is_present)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) converts boolean values True/False to strings \"True\"/\"False\".\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2436633"}]}