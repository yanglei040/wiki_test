{"hands_on_practices": [{"introduction": "我们的第一个动手实践将引导你完成一个典型的代码验证流程。我们将以二维泊松方程（一个基础的椭圆偏微分方程）为目标，应用制造解方法。这个练习 [@problem_id:2444940] 的核心是验证一个有限差分求解器的实现是否正确，通过在一个网格细化研究中计算误差并确认其收敛阶，来检验代码是否达到了其理论精度。", "problem": "考虑方形区域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松方程，\n$$\\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in \\Omega,$$\n其狄利克雷边界条件由人造解 $u_{m}(x,y)$ 指定，\n$$u(x,y)\\big|_{\\partial \\Omega} = u_{m}(x,y),$$\n其中\n$$u_{m}(x,y) = \\sin(\\pi x)\\,\\cosh(y) + x^2 y^3.$$\n所有三角函数的参数都必须解释为弧度。\n\n您的任务是使用人造解方法来验证一个泊松方程的数值求解器。具体而言：\n- 通过对人造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2$，精确推导源项 $f(x,y)$。\n- 对于指定的 $N$ 值，在包含边界的 $N \\times N$ 个节点的均匀笛卡尔网格上，使用推导出的 $f(x,y)$ 求解该边值问题。\n- 在每个网格上，通过在 $\\partial \\Omega$ 上将 $u(x,y)$ 设置为等于 $u_{m}(x,y)$，来精确地施加狄利克雷边界条件。\n- 将计算出的数值解 $u_{\\text{num}}$ 与网格节点上的精确人造解 $u_{m}$ 进行比较，以量化误差。\n\n对于一个具有 $N \\times N$ 个节点和均匀间距 $h = 1/(N-1)$ 的网格，定义以下误差度量：\n- 在所有网格节点上的离散最大范数（无穷范数），\n$$E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} \\left| u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right|.$$\n- 在所有网格节点上的离散 $L^2$ 范数，\n$$E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} \\left( u_{\\text{num}}(x_i,y_j) - u_{m}(x_i,y_j) \\right)^2 \\, h^2 \\right)^{1/2}.$$\n\n使用离散 $L^2$ 误差，计算两个尺寸分别为 $N_1$ 和 $N_2$（其中 $N_2 = 2N_1 - 1$，使得网格间距减半）的网格之间的观测精度阶 $p$，如下所示：\n$$p = \\frac{\\log\\left( \\dfrac{E_{2}(N_1)}{E_{2}(N_2)} \\right)}{\\log(2)}.$$\n\n角度单位说明：所有角度均以弧度为单位。\n\n测试套件和要求的输出：\n- 测试用例 1：$N = 3$。报告 $E_{\\infty}(3)$。\n- 测试用例 2：$N = 9$。报告 $E_{2}(9)$。\n- 测试用例 3：$N_1 = 17$ 和 $N_2 = 33$。报告根据上述公式由 $E_{2}(17)$ 和 $E_{2}(33)$ 计算出的观测阶数 $p$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，顺序为 $[E_{\\infty}(3), E_{2}(9), p]$。\n- 每个数值条目必须格式化为十进制数，小数点后精确到 10 位。\n- 例如，一个有效的输出行格式为：$[0.1234567890,0.0123456789,1.9876543210]$。", "solution": "所述问题构成了一个适定的、有科学依据的任务，用于验证一种数值方法。它遵循计算工程的既定原则，特别是使用人造解方法来验证泊松方程有限差分求解器的实现。所有必要的数据、方程和定义均已提供，且不存在内部矛盾或与科学相悖的事实。因此，该问题是有效的，我们将构建一个解决方案。\n\n该方法包括两个主要阶段：首先，解析推导人造解所需的源项；其次，对得到的边值问题进行数值求解并计算误差度量。\n\n首先，我们通过对指定的人造解 $u_{m}(x,y)$ 应用拉普拉斯算子 $\\nabla^2 = \\frac{\\partial^2}{\\partial x^2} + \\frac{\\partial^2}{\\partial y^2}$ 来推导源项 $f(x,y)$。\n人造解由下式给出：\n$$u_{m}(x,y) = \\sin(\\pi x)\\cosh(y) + x^2 y^3$$\n我们计算关于 $x$ 和 $y$ 的偏导数。\n对于 $x$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial x} = \\pi \\cos(\\pi x)\\cosh(y) + 2x y^3 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial x^2} = -\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3 $$\n对于 $y$ 的导数：\n$$ \\frac{\\partial u_{m}}{\\partial y} = \\sin(\\pi x)\\sinh(y) + 3x^2 y^2 $$\n$$ \\frac{\\partial^2 u_{m}}{\\partial y^2} = \\sin(\\pi x)\\cosh(y) + 6x^2 y $$\n源项 $f(x,y)$ 是这些二阶导数的和：\n$$ f(x,y) = \\nabla^2 u_{m} = \\frac{\\partial^2 u_{m}}{\\partial x^2} + \\frac{\\partial^2 u_{m}}{\\partial y^2} $$\n$$ f(x,y) = \\left(-\\pi^2 \\sin(\\pi x)\\cosh(y) + 2 y^3\\right) + \\left(\\sin(\\pi x)\\cosh(y) + 6x^2 y\\right) $$\n合并各项可得到精确的源函数：\n$$ f(x,y) = (1 - \\pi^2)\\sin(\\pi x)\\cosh(y) + 6x^2 y + 2y^3 $$\n\n其次，我们在覆盖区域 $\\Omega = [0,1] \\times [0,1]$ 的 $N \\times N$ 个节点的均匀笛卡尔网格上求解泊松方程 $\\nabla^2 u(x,y) = f(x,y)$。网格坐标为 $x_j = j h$ 和 $y_i = i h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 1/(N-1)$。令 $U_{i,j}$ 表示 $u(y_i, x_j)$ 的数值近似。在每个内部节点 $(y_i, x_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$），使用二阶中心有限差分格式来近似拉普拉斯算子：\n$$ \\frac{U_{i,j+1} - 2U_{i,j} + U_{i,j-1}}{h^2} + \\frac{U_{i+1,j} - 2U_{i,j} + U_{i-1,j}}{h^2} = f(y_i, x_j) $$\n重新整理这个差分格式，可以得到每个内部节点的线性方程：\n$$ U_{i,j-1} + U_{i,j+1} + U_{i-1,j} + U_{i+1,j} - 4U_{i,j} = h^2 f(y_i, x_j) $$\n这组针对 $(N-2)^2$ 个未知内部节点值的 $(N-2)^2$ 个方程构成了一个形如 $A \\mathbf{u} = \\mathbf{b}$ 的线性系统。向量 $\\mathbf{u}$ 包含未知值 $U_{i,j}$，这些值例如按行主序排列。矩阵 $A$ 是一个稀疏的块三对角矩阵，表示有限差分格式的连通性。右端向量 $\\mathbf{b}$ 包含根据已知边界条件调整后的 $h^2 f(y_i, x_j)$ 的值。对于一个与边界相邻的内部节点 $(y_i, x_j)$，差分格式中的相应项（例如，如果 $i=1$，则为 $U_{0,j}$）是一个来自狄利克雷条件 $u_m(y_0, x_j)$ 的已知值，并被移到方程的右侧。\n\n完整的数值解 $u_{\\text{num}}$ 是通过求解这个线性系统得到内部节点的值，并将其与由 $u_m(x,y)$ 指定的精确边界值组合而成的。\n\n使用指定的离散范数对误差进行量化。离散最大范数 $E_{\\infty}(N)$ 的计算公式如下：\n$$ E_{\\infty}(N) = \\max_{0 \\le i,j \\le N-1} | u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) | $$\n离散 $L^2$ 范数 $E_{2}(N)$ 的计算公式如下：\n$$ E_{2}(N) = \\left( \\sum_{i=0}^{N-1} \\sum_{j=0}^{N-1} ( u_{\\text{num}}(y_i, x_j) - u_{m}(y_i, x_j) )^2 h^2 \\right)^{1/2} $$\n然后，通过比较两个相继加密的网格（$N_1$ 和 $N_2=2N_1-1$，这对应于将网格间距 $h$ 减半）上的 $L^2$ 误差，来计算观测精度阶 $p$：\n$$ p = \\frac{\\log( E_{2}(N_1) / E_{2}(N_2) )}{\\log(2)} $$\n该值预期约为 $2$，这与有限差分格式的二阶精度一致。\n\n该实现将为指定的 $N$ 值（$N=3, 9, 17, 33$）构建并求解线性系统，以计算所要求的误差度量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the solution process for all test cases.\n    \"\"\"\n    \n    # Define PI for use in trigonometric functions.\n    PI = np.pi\n\n    def u_m(x, y):\n        \"\"\"\n        Computes the manufactured solution u_m(x,y).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        return np.sin(PI * x) * np.cosh(y) + x**2 * y**3\n\n    def f_source(x, y):\n        \"\"\"\n        Computes the source term f(x,y) derived from grad^2(u_m).\n        - x, y can be NumPy arrays.\n        \"\"\"\n        term1 = (1.0 - PI**2) * np.sin(PI * x) * np.cosh(y)\n        term2 = 6.0 * x**2 * y\n        term3 = 2.0 * y**3\n        return term1 + term2 + term3\n\n    def solve_poisson(N):\n        \"\"\"\n        Solves the Poisson equation on an N x N grid using finite differences.\n        \n        Args:\n            N (int): The number of nodes along one dimension of the grid.\n\n        Returns:\n            tuple: A tuple containing:\n                - u_num (np.ndarray): The N x N numerical solution array.\n                - u_exact (np.ndarray): The N x N exact manufactured solution array.\n                - h (float): The grid spacing.\n        \"\"\"\n        if N  2:\n            raise ValueError(\"Grid size N must be at least 2.\")\n        if N == 2: # No interior points\n            h = 1.0\n            x = np.linspace(0.0, 1.0, N)\n            y = np.linspace(0.0, 1.0, N)\n            xx, yy = np.meshgrid(x, y, indexing='xy')\n            u_exact = u_m(xx, yy)\n            return u_exact, u_exact, h\n\n        # 1. Grid setup\n        h = 1.0 / (N - 1)\n        x = np.linspace(0.0, 1.0, N)\n        y = np.linspace(0.0, 1.0, N)\n        xx, yy = np.meshgrid(x, y, indexing='xy')\n\n        # 2. Evaluate exact solution and source term\n        u_exact = u_m(xx, yy)\n        f_vals = f_source(xx, yy)\n\n        # 3. Setup linear system Ax = b for interior points\n        num_interior_nodes_1d = N - 2\n        num_unknowns = num_interior_nodes_1d**2\n        \n        A = np.zeros((num_unknowns, num_unknowns))\n        b = np.zeros(num_unknowns)\n\n        # The mapping from 2D interior grid index (i_int, j_int) to 1D vector index k\n        # is row-major: k = i_int * num_interior_nodes_1d + j_int\n        # This corresponds to full grid index (i, j) where i = i_int + 1, j = j_int + 1\n        for k in range(num_unknowns):\n            i_int = k // num_interior_nodes_1d\n            j_int = k % num_interior_nodes_1d\n            \n            i = i_int + 1\n            j = j_int + 1\n\n            # Main diagonal coefficient for -4*U_ij\n            A[k, k] = -4.0\n\n            # Right-hand side from source term f(y_i, x_j)\n            b[k] = h**2 * f_vals[i, j]\n\n            # Neighbor contribution (x-direction, j-1)\n            if j == 1:\n                b[k] -= u_exact[i, 0]\n            else:\n                A[k, k - 1] = 1.0\n\n            # Neighbor contribution (x-direction, j+1)\n            if j == N - 2:\n                b[k] -= u_exact[i, N - 1]\n            else:\n                A[k, k + 1] = 1.0\n\n            # Neighbor contribution (y-direction, i-1)\n            if i == 1:\n                b[k] -= u_exact[0, j]\n            else:\n                A[k, k - num_interior_nodes_1d] = 1.0\n\n            # Neighbor contribution (y-direction, i+1)\n            if i == N - 2:\n                b[k] -= u_exact[N - 1, j]\n            else:\n                A[k, k + num_interior_nodes_1d] = 1.0\n\n        # 4. Solve the linear system\n        u_interior_flat = np.linalg.solve(A, b)\n        u_interior = u_interior_flat.reshape((num_interior_nodes_1d, num_interior_nodes_1d))\n\n        # 5. Construct the full numerical solution grid\n        u_num = np.copy(u_exact)  # Initialize with correct boundary values\n        u_num[1:N-1, 1:N-1] = u_interior\n\n        return u_num, u_exact, h\n\n    # Test case 1: N = 3, compute E_infinity\n    u_num_3, u_exact_3, _ = solve_poisson(N=3)\n    e_inf_3 = np.max(np.abs(u_num_3 - u_exact_3))\n\n    # Test case 2: N = 9, compute E_2\n    u_num_9, u_exact_9, h_9 = solve_poisson(N=9)\n    e_2_9 = np.sqrt(np.sum((u_num_9 - u_exact_9)**2) * h_9**2)\n\n    # Test case 3: N1=17, N2=33, compute order of accuracy p\n    # Compute E_2 for N=17\n    u_num_17, u_exact_17, h_17 = solve_poisson(N=17)\n    e_2_17 = np.sqrt(np.sum((u_num_17 - u_exact_17)**2) * h_17**2)\n    \n    # Compute E_2 for N=33\n    u_num_33, u_exact_33, h_33 = solve_poisson(N=33)\n    e_2_33 = np.sqrt(np.sum((u_num_33 - u_exact_33)**2) * h_33**2)\n    \n    # Compute order of accuracy p\n    p = np.log(e_2_17 / e_2_33) / np.log(2.0)\n    \n    # Compile and format results\n    results = [e_inf_3, e_2_9, p]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{x:.10f}' for x in results)}]\")\n\nsolve()\n```", "id": "2444940"}, {"introduction": "在验证了收敛阶之后，一个自然的问题是：我们的数值解能否在某些情况下与精确解完全一致？这个练习 [@problem_id:2444972] 揭示了一个巧妙的技巧。通过精心构造一个低阶多项式解，我们可以使得有限差分格式的截断误差恰好为零，从而数值解应在机器精度内与精确解完全相同。这为我们提供了一个极其灵敏的调试工具，任何显著的误差都直接指向程序实现中的缺陷，而非离散化本身带来的误差。", "problem": "考虑单位正方形域 $\\Omega = [0,1] \\times [0,1]$ 上的二维泊松问题，其带有狄利克雷边界条件。您需要应用制造解方法进行代码验证，具体如下。设制造解为二次多项式\n$$\nu_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f,\n$$\n其中 $a$、$b$、$c$、$d$、$e$ 和 $f$ 是实数常量。定义源项 $s(x,y)$，使得 $u_m$ 精确满足带有负拉普拉斯算子的泊松方程，\n$$\n- \\Delta u(x,y) = s(x,y) \\quad \\text{in } \\Omega,\n$$\n以及狄利克雷边界条件\n$$\nu(x,y) = u_m(x,y) \\quad \\text{for } (x,y) \\in \\partial \\Omega.\n$$\n在均匀笛卡尔网格上，使用标准的二阶中心有限差分格式对 $-\\Delta$ 进行离散化，每个空间方向有 $N$ 个内部节点，网格间距为 $h = \\frac{1}{N+1}$。设内部网格点为 $\\{(x_i,y_j)\\}_{i,j=1}^N$，其中 $x_i = i h$ 且 $y_j = j h$。需要对每个内部节点 $(i,j)$ 强制执行的离散内部方程为，\n$$\n\\frac{-u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1} + 4 u_{i,j}}{h^2} = s(x_i,y_j),\n$$\n其中狄利克雷边界值由 $\\partial \\Omega$ 上的 $u_m$ 指定。这里 $u_{i,j}$ 表示 $u(x_i,y_j)$ 的离散近似值。\n\n对于下方的每个测试用例，计算包括边界节点在内的整个网格上的离散解，然后报告最大绝对节点误差\n$$\nE_\\infty = \\max_{0 \\le i \\le N+1,\\; 0 \\le j \\le N+1} \\left| u_{i,j} - u_m(x_i,y_j) \\right|.\n$$\n不涉及物理单位。所有可能出现的角度（如果有的话）都必须以弧度解释，但此处不需要。\n\n测试套件（每个用例为 $(N, a, b, c, d, e, f)$）：\n- 用例 1：$(\\,10,\\, 1.0,\\, 0.5,\\, 2.0,\\, -1.0,\\, 0.25,\\, -0.75\\,)$\n- 用例 2：$(\\,15,\\, 0.0,\\, 3.0,\\, 0.0,\\, 0.0,\\, 0.0,\\, 0.0\\,)$\n- 用例 3：$(\\,8,\\, 0.0,\\, 0.0,\\, 0.0,\\, -2.0,\\, 1.5,\\, 0.1\\,)$\n- 用例 4：$(\\,12,\\, -0.7,\\, 0.0,\\, 0.4,\\, 0.0,\\, 0.0,\\, 2.0\\,)$\n\n您的程序必须按以上列出的顺序为每个用例计算 $E_\\infty$，并生成一行输出，其中包含用方括号括起来的四个结果的逗号分隔列表，例如“[$r_1$,$r_2$,$r_3$,$r_4$]”。每个 $r_k$ 都必须是浮点数。不允许有其他输出。", "solution": "用户提供了一个计算工程问题，要求应用制造解方法（MMS）进行代码验证。任务是计算二维泊松方程有限差分解的最大节点误差，其中精确解是一个选定的制造多项式。\n\n**问题验证**\n\n首先，我必须对问题进行严格的验证。\n\n**步骤 1：提取已知条件**\n- **控制方程**：二维泊松方程 $-\\Delta u(x,y) = s(x,y)$，定义在 $\\Omega = [0,1] \\times [0,1]$ 上。\n- **制造解**：$u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。\n- **源项**：$s(x,y)$ 从 $-\\Delta u_m(x,y)$ 推导而来。\n- **边界条件**：狄利克雷边界条件，$u(x,y) = u_m(x,y)$ 在 $\\partial \\Omega$ 上。\n- **离散化**：在均匀网格上采用二阶中心有限差分格式。\n- **网格**：每个方向有 $N$ 个内部节点，间距 $h = 1/(N+1)$。网格点为 $(x_i, y_j) = (ih, jh)$。\n- **离散方程**：$\\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = s(x_i,y_j)$，适用于内部节点 $i,j \\in \\{1, \\dots, N\\}$。\n- **误差度量**：$E_\\infty = \\max_{0 \\le i,j \\le N+1} | u_{i,j} - u_m(x_i,y_j) |$。\n- **测试用例**：提供了四组参数 $(N, a, b, c, d, e, f)$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题在根本上是合理的。它使用了泊松方程、制造解方法和有限差分法，这些都是数值分析和计算工程中的标准概念。\n- **适定性**：该问题是适定的。带狄利克雷条件的泊松方程有唯一解。有限差分离散化得到的相应线性系统是非奇异的，并且也有唯一解。计算误差的要求是代码验证中的一个标准程序。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有歧义或主观因素。\n\n该问题是自包含的、一致的且科学有效的。所有必要信息都已提供。\n\n**步骤 3：结论与行动**\n问题有效。我将继续进行求解。\n\n**基于原理的求解设计**\n\n这个问题的核心在于理解有限差分格式的截断误差。制造解方法是专门设计用来测试代码实现的，它提供了一个精确解已知的问题。\n\n1.  **源项的推导**：\n    制造解为 $u_m(x,y) = a x^2 + b x y + c y^2 + d x + e y + f$。我们必须首先计算其拉普拉斯算子来定义源项 $s(x,y) = -\\Delta u_m(x,y)$。\n    偏导数如下：\n    $\\frac{\\partial u_m}{\\partial x} = 2ax + by + d$\n    $\\frac{\\partial^2 u_m}{\\partial x^2} = 2a$\n    $\\frac{\\partial u_m}{\\partial y} = bx + 2cy + e$\n    $\\frac{\\partial^2 u_m}{\\partial y^2} = 2c$\n    拉普拉斯算子为 $\\Delta u_m = \\frac{\\partial^2 u_m}{\\partial x^2} + \\frac{\\partial^2 u_m}{\\partial y^2} = 2a + 2c$。\n    因此，源项是一个常数：$s(x,y) = -(2a + 2c)$。\n\n2.  **截断误差分析**：\n    负拉普拉斯算子的离散算子是 $L_h u_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}$。\n    此算子的截断误差 $\\tau$ 由 $\\tau = L_h u - (-\\Delta u)$ 给出。对于一个足够光滑的函数 $u$，泰勒级数展开表明 $\\tau = -\\frac{h^2}{12}(\\frac{\\partial^4 u}{\\partial x^4} + \\frac{\\partial^4 u}{\\partial y^4}) + \\mathcal{O}(h^4)$。\n    该格式是二阶精确的。然而，对于我们特定的制造解 $u_m(x,y)$（一个二次多项式），所有三阶及更高阶的偏导数都恒为零。\n    具体来说，$\\frac{\\partial^4 u_m}{\\partial x^4} = 0$ 和 $\\frac{\\partial^4 u_m}{\\partial y^4} = 0$。\n    这意味着截断误差的主项为零。事实上，所有高阶项也为零。对于二次多项式，截断误差精确为零：$\\tau = 0$。\n    这意味着当应用于任何二次多项式时，有限差分算子能精确地再现连续微分算子：\n    $$\n    L_h u_m(x_i, y_j) = -\\Delta u_m(x_i, y_j) = s(x_i, y_j)\n    $$\n    这个恒等式是问题的关键。它表明，在网格点上求值的制造解是离散方程组的精确解。\n\n3.  **数值实现策略**：\n    任务是计算离散解 $u_{i,j}$ 并将其与精确解 $u_m(x_i, y_j)$ 进行比较。步骤如下：\n    a.  **网格设置**：定义一个包含 $(N+2) \\times (N+2)$ 个点的均匀网格，覆盖域 $[0,1] \\times [0,1]$。\n    b.  **系统构建**：为内部网格点上的 $N^2$ 个未知值构建线性系统 $A \\mathbf{u} = \\mathbf{b}$。矩阵 $A$ 表示 5 点模板的系数（对角线上为 4，相邻点为 -1）。向量 $\\mathbf{b}$ 包含源项值 $h^2 s(x_i,y_j)$ 和从 $u_m$ 导出的已知边界值。\n    c.  **系统求解**：求解稀疏线性系统，得到内部未知数向量 $\\mathbf{u}$。\n    d.  **误差计算**：通过将解出的内部值与指定的边界值相结合，重构完整的解网格 $u_{i,j}$。然后，计算此数值解与在网格上求值的制造解之间的最大绝对差：$E_\\infty = \\max |u_{i,j} - u_m(x_i,y_j)|$。\n\n    鉴于截断误差为零，数值解 $u_{i,j}$ 必须在所有网格点上与 $u_m(x_i,y_j)$ 相同，直至浮点精度的极限。因此，预期误差 $E_\\infty$ 将是一个非常小的数，量级约为机器ε。一个非零的结果将表明线性系统求解器或问题设置的实现中存在错误。所提供的代码稳健地实现了这个过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # (N, a, b, c, d, e, f)\n        (10, 1.0, 0.5, 2.0, -1.0, 0.25, -0.75),\n        (15, 0.0, 3.0, 0.0, 0.0, 0.0, 0.0),\n        (8, 0.0, 0.0, 0.0, -2.0, 1.5, 0.1),\n        (12, -0.7, 0.0, 0.4, 0.0, 0.0, 2.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, a, b, c, d, e, f = case\n        error = calculate_max_error(N, a, b, c, d, e, f)\n        results.append(f\"{error:.15e}\")\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_max_error(N, a, b, c, d, e, f):\n    \"\"\"\n    Calculates the maximum absolute nodal error for a single test case by\n    setting up and solving the discrete Poisson equation.\n    \"\"\"\n    h = 1.0 / (N + 1)\n\n    # 1. Set up the grid and coordinates.\n    # The grid is indexed by (j, i) corresponding to (y, x) for standard\n    # row-major array ordering.\n    x_coords = np.linspace(0.0, 1.0, N + 2)\n    y_coords = np.linspace(0.0, 1.0, N + 2)\n    X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n\n    # 2. Define manufactured solution and evaluate on the grid.\n    u_m_func = lambda x, y: a*x**2 + b*x*y + c*y**2 + d*x + e*y + f\n    u_m_grid = u_m_func(X, Y)\n\n    # The source term s(x,y) = -Laplacian(u_m) = -(2a + 2c) is a constant.\n    s_val = -(2*a + 2*c)\n\n    # 3. Set up the linear system A*u = b for interior nodes.\n    # The N*N unknowns correspond to interior grid points, flattened using\n    # row-major ordering: k = (j-1)*N + (i-1).\n    \n    # Construct the sparse matrix A for the 5-point stencil:\n    # 4*u_ji - u_{j,i-1} - u_{j,i+1} - u_{j-1,i} - u_{j+1,i}\n    \n    d_main = np.full(N*N, 4.0)\n    d_h_off = np.full(N*N - 1, -1.0)\n    d_v_off = np.full(N*N - N, -1.0)\n    \n    # Zero out connections between the end of a grid row and the start of the next.\n    for j in range(1, N):\n        d_h_off[j*N - 1] = 0.0\n    \n    diagonals = [d_main, d_h_off, d_h_off, d_v_off, d_v_off]\n    offsets = [0, -1, 1, -N, N]\n    A = diags(diagonals, offsets, shape=(N*N, N*N), format='csr')\n\n    # 4. Construct the RHS vector b.\n    b = np.zeros(N*N)\n    for j in range(1, N + 1):      # y-index on grid\n        for i in range(1, N + 1):  # x-index on grid\n            k = (j - 1) * N + (i - 1)  # row-major vector index\n            \n            # Source term contribution\n            b[k] = h**2 * s_val\n            \n            # Add contributions from known boundary values\n            if i == 1:   # Left boundary (x=0)\n                b[k] += u_m_grid[j, 0]\n            if i == N:   # Right boundary (x=1)\n                b[k] += u_m_grid[j, N+1]\n            if j == 1:   # Bottom boundary (y=0)\n                b[k] += u_m_grid[0, i]\n            if j == N:   # Top boundary (y=1)\n                b[k] += u_m_grid[N+1, i]\n\n    # 5. Solve the linear system for interior node values.\n    u_interior_vec = spsolve(A, b)\n\n    # 6. Reconstruct the full solution grid.\n    u_discrete = np.zeros((N + 2, N + 2))\n    \n    # Set boundary values from manufactured solution\n    u_discrete[0, :] = u_m_grid[0, :]\n    u_discrete[N+1, :] = u_m_grid[N+1, :]\n    u_discrete[:, 0] = u_m_grid[:, 0]\n    u_discrete[:, N+1] = u_m_grid[:, N+1]\n    \n    # Fill interior with the solved values, reshaped according to row-major order.\n    u_discrete[1:N+1, 1:N+1] = u_interior_vec.reshape((N, N), order='C')\n\n    # 7. Calculate the maximum absolute error over the entire grid.\n    error = np.max(np.abs(u_discrete - u_m_grid))\n    \n    return error\n\nsolve()\n\n```", "id": "2444972"}, {"introduction": "掌握了稳态问题的验证后，我们将把制造解方法扩展到更复杂的瞬态问题。这个实践 [@problem_id:2445001] 聚焦于一维热传导方程，这是一个典型的抛物型偏微分方程。你将学习如何将MMS应用于包含时间演化的系统中，处理与时间推进格式（如Crank-Nicolson方法）相关的源项，并最终验证代码在时空两个维度上的准确性。", "problem": "您将应用制造解方法（Method of Manufactured Solutions, MMS）来验证一个用于瞬态热方程的一维数值求解器。考虑在有限区间上的带有源项的无量纲热方程，\n$$\nu_t = \\alpha\\,u_{xx} + s(x,t), \\quad x \\in [0,L], \\ t \\in [0,T],\n$$\n其具有狄利克雷边界条件（Dirichlet boundary conditions）和已知的初始条件。制造解方法（MMS）指定选择一个光滑的精确解 $u_m(x,t)$，将其代入微分方程，并定义源项 $s(x,t)$，使得 $u_m(x,t)$ 恒满足该方程。这通过将数值解与 $u_m(x,t)$ 进行比较，实现了客观的代码验证。\n\n使用制造解\n$$\nu_m(x,t) = e^{-k t}\\,\\cos(a x),\n$$\n其中 $a \\ge 0$ 和 $k \\ge 0$ 是实数参数，$\\cos(\\cdot)$ 的参数以弧度为单位。所有量均为无量纲。任务是：\n\n- 仅使用微积分和微分算子定义，推导由 $u_m(x,t)$ 的选择所蕴含的源项 $s(x,t)$。\n- 在均匀网格上，使用时间上的 Crank–Nicolson 方法和空间上的二阶中心差分来离散化偏微分方程。从 $u_m(x,t)$ 施加狄利克雷边界条件，并从 $u(x,0)=u_m(x,0)$ 施加初始条件。时间步长 $\\Delta t$ 必须选择与 $\\Delta x$ 成正比，以平衡时间和空间误差。\n- 对于每个测试用例，在两个连续加密的网格上计算最终时间 $t=T$ 时的数值解，这两个网格的空间区间数量相差2倍，并通过下式估算观测到的精度阶 $p$：\n$$\np \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)},\n$$\n其中 $E$ 是在 $t=T$ 时所有网格节点上的离散均方根误差，\n$$\nE \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2},\n$$\n其中 $N$ 是空间区间的数量，$x_j=j\\,\\Delta x$，$u_j^N$ 是节点 $j$ 和时间层 $N$ 处的数值解。\n- 您的时间步长选择必须近似满足 $\\Delta t = \\gamma\\,\\Delta x$，具体实现为取 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 个时间步，然后设置 $\\Delta t = T/N_t$。使用 Crank–Nicolson 格式，其中源项通过时间上的梯形法则进行评估。\n\n您的推导应仅基于以下基本事实：\n- 偏导数的定义以及时间和空间的链式法则。\n- $\\cos(a x)$ 在空间上的二阶导数是 $-a^2 \\cos(a x)$。\n- Crank–Nicolson 方法是应用于半离散系统的时间梯形法则，并且二阶中心差分近似 $u_{xx}$。\n\n角度单位说明：计算 $\\cos(\\cdot)$ 时，其参数以弧度为单位。\n\n测试套件：\n- 情况 $1$ (一般情况): $\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$。\n- 情况 $2$ (弱扩散): $\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$。\n- 情况 $3$ (空间常数解): $\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$。\n\n对于每种情况，使用两种网格：具有 $N_{\\text{coarse}}$ 个空间区间的粗网格和具有 $2N_{\\text{coarse}}$ 个区间的细网格，时间步长按前述方法选择。根据在 $t=T$ 时的两个误差计算观测到的精度阶 $p$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的观测精度阶，格式为方括号内以逗号分隔的列表，每个值四舍五入到三位小数，例如 $\\texttt{[2.001,1.998,2.004]}$。", "solution": "首先对问题陈述进行严格验证。\n\n**步骤1：提取已知条件**\n- **控制方程：** $u_t = \\alpha\\,u_{xx} + s(x,t)$，对于 $x \\in [0,L]$ 和 $t \\in [0,T]$。\n- **制造解：** $u_m(x,t) = e^{-k t}\\,\\cos(a x)$，其中 $a \\ge 0$，$k \\ge 0$。\n- **观测精度阶公式：** $p \\;=\\; \\frac{\\log\\left(E_{\\mathrm{coarse}}/E_{\\mathrm{fine}}\\right)}{\\log(2)}$。\n- **误差度量：** 离散均方根误差为 $E \\;=\\; \\sqrt{\\frac{1}{N+1}\\sum_{j=0}^{N}\\left(u_j^N - u_m(x_j,T)\\right)^2}$。\n- **数值方法：** 时间上采用 Crank–Nicolson 方法，空间上采用二阶中心差分。从 $u_m(x,t)$ 施加狄利克雷边界条件和初始条件。\n- **时间步长规则：** $\\Delta t = \\gamma\\,\\Delta x$ 近似成立，通过 $N_t = \\lceil T/(\\gamma\\,\\Delta x)\\rceil$ 和 $\\Delta t = T/N_t$ 实现。源项通过时间上的梯形法则进行评估。\n- **测试套件：**\n    - 情况 $1$：$\\alpha=0.7$, $a=3.0$, $k=2.5$, $L=\\pi$, $T=0.2$, $N_{\\text{coarse}}=50$, $\\gamma=0.4$。\n    - 情况 $2$：$\\alpha=0.001$, $a=4.0$, $k=0.5$, $L=\\pi$, $T=0.05$, $N_{\\text{coarse}}=60$, $\\gamma=0.4$。\n    - 情况 $3$：$\\alpha=0.9$, $a=0.0$, $k=1.2$, $L=1.0$, $T=0.3$, $N_{\\text{coarse}}=40$, $\\gamma=0.4$。\n\n**步骤2：使用提取的已知条件进行验证**\n根据既定的有效性标准对问题陈述进行评估。\n- **科学依据：** 该问题基于一维热方程，这是物理学中的一个基本偏微分方程。制造解方法（MMS）是计算科学中用于代码验证的一种标准、公认的技术。指定的数值方法——Crank-Nicolson 法和中心差分法——是经典且易于理解的算法。该问题在科学上是合理的。\n- **适定性与完备性：** 该问题描述了一个适定的初边值问题。所有必要的参数、函数、边界条件和离散化规则都已明确定义。计算观测精度阶的任务是明确的。该问题是自洽且完备的。\n- **客观性：** 该问题以精确、客观的数学语言陈述，没有主观或模糊的解释。\n\n**步骤3：结论与行动**\n问题有效。这是验证偏微分方程数值方法的标准练习。我们继续进行求解。\n\n**源项的推导**\n\n定义源项 $s(x,t)$ 以确保制造解 $u_m(x,t)$ 恒满足该偏微分方程。我们重排偏微分方程以求解 $s(x,t)$：\n$$\ns(x,t) = u_t - \\alpha\\,u_{xx}\n$$\n制造解为 $u_m(x,t) = e^{-k t}\\,\\cos(a x)$。我们计算它关于时间和空间的偏导数。\n\n关于时间 $t$ 的偏导数是：\n$$\nu_t = \\frac{\\partial}{\\partial t}\\left(e^{-k t}\\,\\cos(a x)\\right) = -k\\,e^{-k t}\\,\\cos(a x)\n$$\n关于空间 $x$ 的一阶偏导数是：\n$$\nu_x = \\frac{\\partial}{\\partial x}\\left(e^{-k t}\\,\\cos(a x)\\right) = -a\\,e^{-k t}\\,\\sin(a x)\n$$\n关于空间 $x$ 的二阶偏导数是：\n$$\nu_{xx} = \\frac{\\partial}{\\partial x}\\left(-a\\,e^{-k t}\\,\\sin(a x)\\right) = -a^2\\,e^{-k t}\\,\\cos(a x)\n$$\n将 $u_t$ 和 $u_{xx}$ 的表达式代入 $s(x,t)$ 的方程，得到：\n$$\ns(x,t) = \\left(-k\\,e^{-k t}\\,\\cos(a x)\\right) - \\alpha\\,\\left(-a^2\\,e^{-k t}\\,\\cos(a x)\\right)\n$$\n提出公因式，我们得到源项的最终表达式：\n$$\ns(x,t) = (\\alpha\\,a^2 - k)\\,e^{-k t}\\,\\cos(a x)\n$$\n\n**数值离散化**\n\n在空间步长为 $\\Delta x = L/N$、时间步长为 $\\Delta t = T/N_t$ 的均匀网格上对偏微分方程进行离散化。令 $u_j^n$ 近似网格点 $x_j=j\\Delta x$ 和时间 $t_n=n\\Delta t$ 处的解 $u(x_j, t_n)$。\n\n将 Crank-Nicolson 方法应用于半离散方程 $u_t = F(u,t)$，其中 $F(u,t) = \\alpha u_{xx} + s(x,t)$。这导致：\n$$\n\\frac{u^{n+1} - u^n}{\\Delta t} = \\frac{1}{2}\\left( F(u^n, t_n) + F(u^{n+1}, t_{n+1}) \\right)\n$$\n空间导数 $u_{xx}$ 使用二阶中心差分进行近似：\n$$\n(u_{xx})_j \\approx \\frac{u_{j+1} - 2u_j + u_{j-1}}{(\\Delta x)^2}\n$$\n将此代入 Crank-Nicolson 格式，得到内部节点 $j \\in \\{1, 2, \\dots, N-1\\}$ 的全离散方程：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\frac{\\alpha}{2}\\left( \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} + \\frac{u_{j+1}^{n+1} - 2u_j^{n+1} + u_{j-1}^{n+1}}{(\\Delta x)^2} \\right) + \\frac{1}{2}(s_j^n + s_j^{n+1})\n$$\n其中 $s_j^n = s(x_j, t_n)$。我们重排方程，将时间层 $n+1$ 的未知项组合在左侧（LHS），将时间层 $n$ 的已知项组合在右侧（RHS）。定义无量纲参数 $\\lambda = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。\n$$\n-\\lambda u_{j-1}^{n+1} + (1+2\\lambda)u_j^{n+1} - \\lambda u_{j+1}^{n+1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n这构成了一个关于内部节点值未知向量 $\\mathbf{u}_{\\text{int}}^{n+1} = [u_1^{n+1}, u_2^{n+1}, \\dots, u_{N-1}^{n+1}]^T$ 的三对角线性方程组。该系统的形式为 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$。矩阵 $A$ 是一个 $(N-1) \\times (N-1)$ 的三对角矩阵，其主对角线元素为 $(1+2\\lambda)$，次对角线元素为 $-\\lambda$。\n\n右侧向量 $\\mathbf{d}$ 取决于时间 $n$ 的解和时间 $n+1$ 的边界条件。狄利克雷边界条件由制造解给出：\n$$\nu_0^{n+1} = u_m(0, t_{n+1}) \\quad \\text{和} \\quad u_N^{n+1} = u_m(L, t_{n+1})\n$$\n右侧向量 $\\mathbf{d}$ 的第 $j$ 个分量（对于 $j \\in \\{1, \\dots, N-1\\}$）是：\n$$\nd_{j-1} = \\lambda u_{j-1}^n + (1-2\\lambda)u_j^n + \\lambda u_{j+1}^n + \\frac{\\Delta t}{2}(s_j^n + s_j^{n+1})\n$$\n来自左侧的边界项被移到右侧。对于第一个方程（$j=1$），项 $-\\lambda u_0^{n+1}$ 被移动，因此我们将 $\\lambda u_0^{n+1}$ 加到 $d_0$ 上。对于最后一个方程（$j=N-1$），项 $-\\lambda u_N^{n+1}$ 被移动，因此我们将 $\\lambda u_N^{n+1}$ 加到 $d_{N-2}$ 上。\n\n总体算法如下：\n1. 对于给定的测试用例，设置参数 $\\alpha, a, k, L, T, N, \\gamma$。\n2. 计算网格参数：$\\Delta x = L/N$，$N_t = \\lceil T/(\\gamma \\Delta x) \\rceil$，$\\Delta t = T/N_t$。\n3. 初始化 $t=0$ 时的解：$u_j^0 = u_m(x_j, 0)$，对于所有 $j \\in \\{0, \\dots, N\\}$。\n4. 构建常数三对角矩阵 $A$。\n5. 从 $n=0$ 迭代到 $N_t-1$：\n   a. 使用解 $u^n$ 和 $t_{n+1}$ 时的边界值构建右侧向量 $\\mathbf{d}$。\n   b. 求解线性系统 $A \\mathbf{u}_{\\text{int}}^{n+1} = \\mathbf{d}$，得到内部节点的值。为提高效率，使用专门的三对角求解器。\n   c. 用新计算的内部值和已知的边界值更新完整的解向量 $u^{n+1}$。\n6. 在最后一个时间步之后，通过将数值解 $u^{N_t}$ 与精确解 $u_m(x, T)$ 进行比较，计算均方根误差 $E$。\n7. 对粗网格（$N_{\\text{coarse}}$）和细网格（$2N_{\\text{coarse}}$）重复步骤1-6，以获得 $E_{\\text{coarse}}$ 和 $E_{\\text{fine}}$。\n8. 使用提供的公式计算观测到的精度阶 $p$。\n\nCrank-Nicolson 格式在空间和时间上都是二阶的。当 $\\Delta t \\propto \\Delta x$ 时，预期的精度阶为 $p=2$。这将对所有测试用例进行验证，包括 $a=0$ 的情况，此时空间依赖性消失。对于 $a=0$，空间离散误差恒为零，问题简化为求解一个常微分方程，对此梯形法则（Crank-Nicolson）也是二阶精确的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the Method of Manufactured Solutions verification.\n    \"\"\"\n    test_cases = [\n        # Case 1 (general)\n        {'alpha': 0.7, 'a': 3.0, 'k': 2.5, 'L': np.pi, 'T': 0.2, 'N_coarse': 50, 'gamma': 0.4},\n        # Case 2 (weak diffusion)\n        {'alpha': 0.001, 'a': 4.0, 'k': 0.5, 'L': np.pi, 'T': 0.05, 'N_coarse': 60, 'gamma': 0.4},\n        # Case 3 (spatially constant solution)\n        {'alpha': 0.9, 'a': 0.0, 'k': 1.2, 'L': 1.0, 'T': 0.3, 'N_coarse': 40, 'gamma': 0.4},\n    ]\n\n    orders_of_accuracy = []\n\n    for case in test_cases:\n        N_coarse = case['N_coarse']\n        N_fine = 2 * N_coarse\n\n        error_coarse = run_simulation(N=N_coarse, **case)\n        error_fine = run_simulation(N=N_fine, **case)\n\n        # Handle potential zero errors, which can occur with perfect solutions\n        if error_fine == 0.0 or error_coarse == 0.0:\n            # If the solution is exact, the notion of convergence order is moot.\n            # We can consider it to be infinite, but for practical reporting,\n            # a large number or a special value is appropriate.\n            # Given the problem's focus on 2nd-order schemes, a perfect result\n            # far exceeds expectations. Here, we report 0.0 as it implies no error.\n            p = 0.0 \n        else:\n            p = np.log(error_coarse / error_fine) / np.log(2.0)\n        \n        orders_of_accuracy.append(p)\n\n    # Format the final output string\n    formatted_results = [f\"{p:.3f}\" for p in orders_of_accuracy]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef run_simulation(N, alpha, a, k, L, T, gamma, **kwargs):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation and returns the RMS error.\n    \n    Args:\n        N (int): Number of spatial intervals.\n        alpha (float): Thermal diffusivity.\n        a (float): Spatial frequency in manufactured solution.\n        k (float): Temporal decay rate in manufactured solution.\n        L (float): Length of the spatial domain [0, L].\n        T (float): Final time of the simulation.\n        gamma (float): Proportionality constant for time step (dt ~ gamma * dx).\n\n    Returns:\n        float: The discrete L2 norm of the error at the final time T.\n    \"\"\"\n    # Manufactured solution and its derivatives\n    def u_m(x, t):\n        return np.exp(-k * t) * np.cos(a * x)\n\n    def s(x, t):\n        return (alpha * a**2 - k) * np.exp(-k * t) * np.cos(a * x)\n\n    # Grid parameters\n    dx = L / N\n    # The number of time steps must be an integer, ceil ensures we reach T\n    Nt = int(np.ceil(T / (gamma * dx)))\n    dt = T / Nt\n    x = np.linspace(0.0, L, N + 1)\n    \n    # Crank-Nicolson parameter\n    lambda_cn = alpha * dt / (2.0 * dx**2)\n\n    # Initialize solution u at t=0\n    u_n = u_m(x, 0.0)\n    \n    # Set up the tridiagonal matrix A for the linear system in banded format\n    # The system is for N-1 internal points\n    N_internal = N - 1\n    if N_internal > 0:\n        A_banded = np.zeros((3, N_internal))\n        A_banded[0, 1:] = -lambda_cn  # Upper diagonal\n        A_banded[1, :] = 1.0 + 2.0 * lambda_cn  # Main diagonal\n        A_banded[2, :-1] = -lambda_cn  # Lower diagonal\n\n    # Time-stepping loop\n    for n in range(Nt):\n        t_n = n * dt\n        t_np1 = (n + 1) * dt\n        \n        u_np1 = np.zeros_like(u_n)\n\n        # Boundary conditions at time t_np1\n        u0_np1 = u_m(0.0, t_np1)\n        uN_np1 = u_m(L, t_np1)\n        u_np1[0] = u0_np1\n        u_np1[-1] = uN_np1\n\n        if N_internal > 0:\n            # Construct the RHS vector d\n            u_internal = u_n[1:-1]\n            x_internal = x[1:-1]\n            \n            # Contribution from known solution at time t_n\n            rhs = (lambda_cn * u_n[:-2] +\n                   (1.0 - 2.0 * lambda_cn) * u_internal +\n                   lambda_cn * u_n[2:])\n            \n            # Contribution from source term\n            s_n = s(x_internal, t_n)\n            s_np1 = s(x_internal, t_np1)\n            rhs += (dt / 2.0) * (s_n + s_np1)\n            \n            # Add boundary condition contributions from LHS\n            rhs[0] += lambda_cn * u0_np1\n            rhs[-1] += lambda_cn * uN_np1\n            \n            # Solve the tridiagonal system for internal nodes\n            u_internal_np1 = solve_banded((1, 1), A_banded, rhs)\n            u_np1[1:-1] = u_internal_np1\n        \n        u_n = u_np1\n\n    # Final solution at t=T\n    u_numerical = u_n\n    u_exact = u_m(x, T)\n\n    # Calculate RMS error over all nodes (including boundaries)\n    error = np.sqrt(np.mean((u_numerical - u_exact)**2))\n    \n    return error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2445001"}]}