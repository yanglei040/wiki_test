{"hands_on_practices": [{"introduction": "谱方法的核心优势在于其处理光滑周期性问题时能达到极高的精度。本练习旨在通过一个基础的一维泊松方程，让您亲手验证这一点，并同时揭示当傅里叶谱方法被应用于非周期性边界条件时所面临的挑战。通过对比周期性与非周期性两种情况下的误差，您将深刻理解谱基函数的选择与问题边界条件的匹配是何等重要，并直观地认识到著名的吉布斯现象 (Gibbs phenomenon) [@problem_id:2437055]。", "problem": "考虑未知函数 $u(x)$ 的一维边值问题，\n$$u''(x) = f(x), \\quad x \\in (0,1),$$\n其边界数据可以是周期性的，也可以是非周期性的。令 $u_{\\mathrm{per}}$ 表示满足周期性边界数据 $u(0)=u(1)$ 和 $u'(0)=u'(1)$ 的解，令 $u_{\\mathrm{D}}$ 表示满足非周期性 Dirichlet 边界数据 $u(0)=0$ 和 $u(1)=0$ 的解。\n\n对于任意正偶数 $N$，定义等距网格 $\\{x_j\\}_{j=0}^{N-1}$，其中 $x_j = j/N$。令 $f_N$ 为 $f$ 在此网格上的限制。定义 $u_N$ 为唯一的 1-周期三角多项式（空间平均值为零），其在三角多项式意义下的离散二阶导数等于移除了离散平均值的 $f_N$。更准确地说，在对应于该网格的离散傅里叶表示中，对于整数 $m$，波数为 $k_m = 2\\pi m$，$u_N$ 满足\n$$-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{对于所有 } m \\neq 0 \\text{ 的模式，}$$\n且 $\\widehat{u}_0 = 0$，其中帽子符号表示在 $N$ 点网格上的离散傅里叶系数，波数的运算在模 $N$ 的意义下进行。角度应以弧度为单位。\n\n对于下述每个测试用例，您必须计算 $u_N$ 相对于网格上指定的目标解 $u_\\star$ 的离散 $L^2$ 误差，定义为\n$$E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2}.$$\n所有答案必须是无单位的实数。\n\n使用以下包含四个用例的测试套件，并按所列顺序生成误差 $E_N$。每个用例都指定了 $f$、目标解 $u_\\star$ 和 $N$：\n\n- 用例 1（周期性，理想情况）：$f(x) = \\sin(2\\pi x)$，目标解 $u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。\n- 用例 2（非周期性 Dirichlet，常数强迫项）：$f(x) = -2$，目标解 $u_\\star(x) = x(1-x)$，$N = 64$。\n- 用例 3（非周期性 Dirichlet，端点导数不匹配）：$f(x) = -\\pi^2 \\sin(\\pi x)$，目标解 $u_\\star(x) = \\sin(\\pi x)$，$N = 64$。\n- 用例 4（用例 2 的细化）：$f(x) = -2$，目标解 $u_\\star(x) = x(1-x)$，$N = 128$。\n\n您的程序应生成单行输出，其中包含一个用逗号分隔并用方括号括起来的结果列表，顺序为 $[E_{64}^{(1)},E_{64}^{(2)},E_{64}^{(3)},E_{128}^{(4)}]$，列表中的每个条目是相应情况下对应的离散 $L^2$ 误差 $E_N$。", "solution": "在尝试任何解答之前，需对问题陈述进行验证。\n\n### 第 1 步：提取已知条件\n- **控制方程**：$u''(x) = f(x)$，对于 $x \\in (0,1)$。\n- **未知函数**：$u(x)$。\n- **边界条件**：\n    - 周期性：$u_{\\mathrm{per}}(0)=u_{\\mathrm{per}}(1)$ 和 $u'_{\\mathrm{per}}(0)=u'_{\\mathrm{per}}(1)$。\n    - Dirichlet：$u_{\\mathrm{D}}(0)=0$ 和 $u_{\\mathrm{D}}(1)=0$。\n- **离散化**：\n    - 网格：对于正偶数 $N$，等距点 $\\{x_j\\}_{j=0}^{N-1}$，其中 $x_j = j/N$。\n    - 离散函数：$f_N$ 是 $f(x)$ 在网格上的限制。\n- **数值解定义**：$u_N$ 是一个 1-周期三角多项式，其空间平均值为零（$\\widehat{u}_0 = 0$）。它由离散傅里叶空间中的关系定义：\n  $$-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m \\quad \\text{对于所有 } m \\neq 0 \\text{ 的模式}$$\n  其中 $\\widehat{u}_m$ 和 $\\widehat{f}_m$ 是离散傅里叶系数，$k_m = 2\\pi m$ 是波数。右侧项被表述为对应“移除了离散平均值的 $f_N$”，这通过仅求解 $m \\neq 0$ 的模式来隐式处理。\n- **误差度量**：离散 $L^2$ 误差，$E_N = \\left(\\frac{1}{N} \\sum_{j=0}^{N-1} \\left(u_N(x_j) - u_\\star(x_j)\\right)^2 \\right)^{1/2}$。\n- **测试用例**：\n    1.  $f(x) = \\sin(2\\pi x)$，$u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。\n    2.  $f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 64$。\n    3.  $f(x) = -\\pi^2 \\sin(\\pi x)$，$u_\\star(x) = \\sin(\\pi x)$，$N = 64$。\n    4.  $f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 128$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n\n- **科学性**：该问题描述了应用傅里叶谱方法求解一维泊松方程。这是计算科学与工程中的一项基本且标准的技术。该方法和原理均已成熟。此标准已满足。\n- **适定性**：连续边值问题（周期性和 Dirichlet）都是适定的。数值格式也是适定的。傅里叶系数的方程 $-(k_m)^2 \\widehat{u}_m = \\widehat{f}_m$ 对于所有非零波数（$k_m \\neq 0$）都可以求解 $\\widehat{u}_m$。$k_0 = 0$ 处的奇异点通过周期性泊松方程的可解性条件（要求强迫项的平均值为零，数值方法强制执行了这一点）以及通过将解的平均值设为零（$\\widehat{u}_0 = 0$）来施加唯一解来处理。此标准已满足。\n- **客观性**：问题陈述使用了精确的数学语言和定义，没有主观或模糊的术语。此标准已满足。\n- **完整性与一致性**：问题提供了构建解决方案所需的所有函数、参数和定义。所提供的信息中没有矛盾。此标准已满足。\n\n### 第 3 步：结论与行动\n问题是有效的。它科学合理、适定、客观且自洽。将提供解决方案。\n\n### 解答\n该问题要求使用傅里叶谱方法在域 $x \\in (0,1)$ 上求解一维泊松方程 $u''(x) = f(x)$。傅里叶谱方法的核心原理是在傅里叶空间中将微分算子转换为代数算子。\n\n在 1-周期域上，函数 $u(x)$ 的傅里叶级数表示为 $u(x) = \\sum_{m=-\\infty}^{\\infty} \\check{u}_m e^{i 2\\pi m x}$。对 $x$ 求导对应于将第 $m$ 个傅里叶系数 $\\check{u}_m$ 乘以 $i 2\\pi m$。因此，二阶导数 $u''(x)$ 的傅里叶系数为 $(- (2\\pi m)^2) \\check{u}_m = -k_m^2 \\check{u}_m$，其中 $k_m = 2\\pi m$ 是波数。\n\n所规定的数值方法是这一原理的离散模拟。算法流程如下：\n\n1.  **离散化**：对于给定的偶数 $N$，将域 $[0,1)$ 离散化为 $N$ 个等距点的网格，$x_j = j/N$，其中 $j = 0, 1, \\dots, N-1$。\n\n2.  **强迫项求值**：在这些网格点上计算强迫函数 $f(x)$，得到一个数值向量 $\\mathbf{f} = [f(x_0), f(x_1), \\dots, f(x_{N-1})]^T$。\n\n3.  **正向傅里叶变换**：使用离散傅里叶变换（DFT）将向量 $\\mathbf{f}$ 变换到傅里叶空间，通常通过快速傅里叶变换（FFT）算法实现。这会产生离散傅里叶系数的向量 $\\hat{\\mathbf{f}}$：\n    $$ \\widehat{f}_m = \\sum_{j=0}^{N-1} f(x_j) e^{-i 2\\pi m j / N} $$\n    索引 $m$ 对应于离散频率，对于长度为 $L=1$ 的域，这些频率是整数。标准数值库提供例程来正确排序这些频率，通常为 $m \\in \\{0, 1, \\dots, N/2-1, -N/2, \\dots, -1\\}$。\n\n4.  **在傅里叶空间求解**：微分方程 $u''(x) = f(x)$ 变为关于离散傅里叶系数的代数方程。离散二阶导数算子对应于乘以 $-(k_m)^2$，其中 $k_m$ 是与离散频率 $m$ 相关联的波数。对于长度为 1 的域，$k_m = 2\\pi m$。关于系数 $\\widehat{u}_m$ 的问题是：\n    $$ -(k_m)^2 \\widehat{u}_m = \\widehat{f}_m $$\n    根据规定，此方程仅对非零模式（$m \\neq 0$）求解。对于零频率模式（$m=0$），波数 $k_0$ 为零，导致奇异性。这反映了一个事实：周期性泊松问题有解的充要条件是强迫项的积分（或离散和）为零。此外，解在相差一个加性常数的情况下才是唯一的。该问题通过指定解 $u_N$ 必须具有零平均值来解决此问题，这等效于将其零阶傅里叶系数设置为零：$\\widehat{u}_0 = 0$。\n    因此，解系数的向量 $\\hat{\\mathbf{u}}$ 计算如下：\n    $$ \\widehat{u}_m = \\begin{cases} 0   \\text{if } m = 0 \\\\ -\\frac{\\widehat{f}_m}{k_m^2}  \\text{if } m \\neq 0 \\end{cases} $$\n\n5.  **逆傅里叶变换**：通过对系数向量 $\\hat{\\mathbf{u}}$ 应用逆离散傅里叶变换（通过 IFFT 实现），可以恢复物理空间中的数值解 $u_N(x_j)$：\n    $$ u_N(x_j) = \\frac{1}{N} \\sum_{m=0}^{N-1} \\widehat{u}_m e^{i 2\\pi m j / N} $$\n    由于原始强迫函数 $f(x)$ 是实值的，解 $u_N(x_j)$ 也必须是实数。取 IFFT 结果的实部以舍弃由浮点算术误差产生的可忽略的虚部。\n\n6.  **误差计算**：在网格 $x_j$ 上计算目标解 $u_\\star(x)$ 以得到 $\\mathbf{u}_\\star$。然后，离散 $L^2$ 误差 $E_N$ 计算为数值解 $\\mathbf{u}_N$ 和目标解 $\\mathbf{u}_\\star$ 之间的均方根误差：\n    $$ E_N = \\sqrt{\\frac{1}{N} \\sum_{j=0}^{N-1} (u_N(x_j) - u_\\star(x_j))^2} $$\n\n### 测试用例分析\n- **用例 1**：$f(x) = \\sin(2\\pi x)$，$u_\\star(x) = -\\sin(2\\pi x)/(2\\pi)^2$，$N = 64$。函数 $f(x)$ 是一个单一的、平均值为零的 1-周期傅里叶模式。目标解 $u_\\star(x)$ 是平均值为零的精确周期解。对于其解包含在三角多项式基中的问题，傅里叶谱方法是精确的。因此，误差 $E_{64}$ 预计将接近机器精度。\n\n- **用例 2**：$f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 64$。目标解 $u_\\star(x)$ 满足 Dirichlet 边界条件 $u_\\star(0) = u_\\star(1) = 0$。然而，它不是一个 1-周期函数，因为其在边界处的导数不匹配：$u'_\\star(0) = 1$ 而 $u'_\\star(1) = -1$。谱方法计算的是一个周期解 $u_N$。误差 $u_N - u_\\star$ 主要源于周期性三角多项式无法精确表示非周期目标函数，尤其是在边界处。这种边界条件不匹配导致收敛缓慢（吉布斯现象），因此误差 $E_{64}$ 将会很大。\n\n- **用例 3**：$f(x) = -\\pi^2 \\sin(\\pi x)$，$u_\\star(x) = \\sin(\\pi x)$，$N = 64$。此用例与用例 2 类似。目标解 $u_\\star(x)$ 满足 Dirichlet 边界条件，但不满足周期性条件，因为 $u'_\\star(0) = \\pi \\neq u'_\\star(1) = -\\pi$。出于相同的原因，预计误差会很大。\n\n- **用例 4**：$f(x) = -2$，$u_\\star(x) = x(1-x)$，$N = 128$。这是用例 2 的网格细化。虽然预计误差会很大，但增加 $N$ 应该会减小误差。误差减小的速率将是代数级的（对于某个小的 $p0$，为 $O(N^{-p})$），而不是像光滑周期性问题那样观察到的指数级收敛。将此结果与用例 2 进行比较将显示这种次优的收敛性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the discrete L2 error for a Fourier spectral solution to u''=f\n    for four different test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1 (periodic, happy path)\n        (lambda x: np.sin(2 * np.pi * x), \n         lambda x: -np.sin(2 * np.pi * x) / (2 * np.pi)**2, \n         64),\n        # Case 2 (non-periodic Dirichlet, constant forcing)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         64),\n        # Case 3 (non-periodic Dirichlet, endpoint-derivative mismatch)\n        (lambda x: -(np.pi**2) * np.sin(np.pi * x), \n         lambda x: np.sin(np.pi * x), \n         64),\n        # Case 4 (refinement of Case 2)\n        (lambda x: -2.0 + 0*x, \n         lambda x: x * (1 - x), \n         128),\n    ]\n\n    results = []\n    for f_func, u_star_func, N in test_cases:\n        # 1. Define the grid\n        # x_j = j/N for j = 0, ..., N-1\n        x = np.arange(N) / N\n\n        # 2. Evaluate the forcing function on the grid\n        f_vals = f_func(x)\n\n        # 3. Compute the DFT of the forcing function\n        f_hat = np.fft.fft(f_vals)\n\n        # 4. Define wavenumbers and solve in Fourier space\n        # Frequencies m = [0, 1, ..., N/2-1, -N/2, ..., -1] for L=1\n        # The grid spacing d = 1/N\n        freqs = np.fft.fftfreq(N, d=1.0/N)\n        # Wavenumbers k_m = 2*pi*m\n        k = 2 * np.pi * freqs\n        \n        # The equation for Fourier coefficients is -(k_m)^2 * u_hat_m = f_hat_m\n        # We solve for u_hat_m = -f_hat_m / k_m^2 for m != 0\n        # and set u_hat_0 = 0\n        \n        # To avoid division by zero for k_0 = 0, we can use np.divide with a 'where' clause.\n        # Initialize u_hat to zeros.\n        u_hat = np.zeros_like(f_hat, dtype=complex)\n        \n        # Calculate k^2, avoiding direct computation at k=0 to prevent warnings.\n        k_squared = k**2\n        \n        # The condition k != 0 is equivalent to freqs != 0\n        nonzero_mask = (freqs != 0)\n        \n        u_hat[nonzero_mask] = -f_hat[nonzero_mask] / k_squared[nonzero_mask]\n\n        # 5. Transform back to physical space via Inverse FFT\n        u_N_vals = np.fft.ifft(u_hat)\n        \n        # The solution should be real; take the real part to discard numerical noise.\n        u_N_vals = u_N_vals.real\n\n        # 6. Evaluate the target solution and compute the error\n        u_star_vals = u_star_func(x)\n        \n        # Discrete L2 error (Root Mean Square Error)\n        error = np.sqrt(np.mean((u_N_vals - u_star_vals)**2))\n        results.append(error)\n\n    # Format and print the final output\n    print(f\"[{','.join(f'{r:.10e}' for r in results)}]\")\n\nsolve()\n```", "id": "2437055"}, {"introduction": "谱方法的思想远不止局限于傅里叶级数或多项式展开，它可以推广到更广义的几何结构，例如非结构化的网络或图。本练习将引导您使用图拉普拉斯算子 ($L$) 的特征函数作为基，来求解一个定义在图上的偏微分方程（热扩散方程）。这个过程展示了如何将谱分析应用于离散和非欧几里得空间，这在分析社交网络、交通系统和生物网络等复杂系统中至关重要 [@problem_id:2436990]。", "problem": "考虑一个包含 $N=5$ 个节点（标记为 $\\{0,1,2,3,4\\}$）的无向、加权、连通图。其边集和权重如下所示（每条无向边 $\\{i,j\\}$ 具有对称权重 $w_{ij}=w_{ji}$）：\n- $\\{0,1\\}$，权重为 $1.0$，\n- $\\{0,2\\}$，权重为 $0.4$，\n- $\\{0,4\\}$，权重为 $0.2$，\n- $\\{1,2\\}$，权重为 $0.3$，\n- $\\{1,3\\}$，权重为 $0.8$，\n- $\\{2,4\\}$，权重为 $0.6$，\n- $\\{3,4\\}$，权重为 $0.5$。\n\n定义加权邻接矩阵 $A \\in \\mathbb{R}^{5 \\times 5}$，其中如果节点 $i$ 和 $j$ 之间存在边，则 $A_{ij}=w_{ij}$，否则 $A_{ij}=0$，并且对于所有 $i$，有 $A_{ii}=0$。定义对角度矩阵 $D \\in \\mathbb{R}^{5 \\times 5}$，其中 $D_{ii}=\\sum_{j=0}^{4} A_{ij}$。组合图拉普拉斯矩阵为 $L=D-A$。\n\n设 $u(t) \\in \\mathbb{R}^{5}$ 是网络上线性时不变偏微分方程（PDE）的解\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0,\n$$\n其中 $\\alpha \\ge 0$ 是一个标量扩散参数，$b \\in \\mathbb{R}^{5}$ 是一个恒定源向量，$u_0 \\in \\mathbb{R}^{5}$ 是初始条件。对于下方的每个测试用例，计算在指定的最终时间 $T$ 时的状态 $u(T)$。\n\n根据上述图构建 $L$，并对每个测试用例，精确计算 $u(T)$（允许数值舍入误差），然后将 $u(T)$ 的每个分量四舍五入到小数点后六位。\n\n测试套件（每个元组为 $(\\alpha, T, u_0, b)$，所有向量均按节点顺序 $[0,1,2,3,4]$ 排列）：\n1. $\\left(1.0,\\;1.0,\\;[1.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0],\\;[0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0]\\right)$\n2. $\\left(0.0,\\;2.5,\\;[-1.0,\\,2.0,\\,0.0,\\,1.0,\\,0.0],\\;[0.3,\\,-0.2,\\,0.1,\\,0.0,\\,-0.1]\\right)$\n3. $\\left(2.0,\\;0.0,\\;[0.5,\\,-0.5,\\,1.0,\\,0.0,\\,2.0],\\;[1.0,\\,-1.0,\\,0.0,\\,0.5,\\,-0.5]\\right)$\n4. $\\left(0.7,\\;0.8,\\;[0.0,\\,0.0,\\,0.0,\\,0.0,\\,0.0],\\;[1.0,\\,-0.5,\\,0.0,\\,0.25,\\,-0.25]\\right)$\n\n最终输出格式：\n您的程序必须打印单行输出，该行包含一个由方括号括起来的逗号分隔列表。列表中的每个条目对应给定顺序的一个测试用例，其本身是一个包含 $u(T)$ 的 5 个分量（按节点顺序 $[0,1,2,3,4]$ 排列并四舍五入）的列表。输出中不得包含任何空格。具体而言，输出格式必须为\n[ [x_{1,0},x_{1,1},x_{1,2},x_{1,3},x_{1,4}], [x_{2,0},...,x_{2,4}], [x_{3,0},...,x_{3,4}], [x_{4,0},...,x_{4,4}] ]\n但不含空格，且每个 $x_{k,i}$ 都四舍五入到小数点后六位。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且完整的。它描述了一个关于线性常微分方程组的标准初值问题，该问题代表了图上的一个扩散过程。所有必要的数据和定义均已提供，不存在内部矛盾或含糊不清之处。因此，我将提供一个完整的解决方案。\n\n控制方程是一个线性时不变（LTI）系统，由下式给出\n$$\n\\frac{d}{dt}u(t) = -\\alpha L\\,u(t) + b, \\quad u(0)=u_0\n$$\n其中 $u(t) \\in \\mathbb{R}^{N}$ 是状态向量，$L \\in \\mathbb{R}^{N \\times N}$ 是组合图拉普拉斯矩阵，$\\alpha \\ge 0$ 是标量扩散参数，$b \\in \\mathbb{R}^{N}$ 是恒定源向量，$u_0 \\in \\mathbb{R}^{N}$ 是初始条件。此处 $N=5$。\n\n该系统的解析解可以通过特征分解法求得，这是适用的，因为无向图的图拉普拉斯矩阵 $L$ 是一个实对称矩阵。因此，$L$ 可以被其特征向量构成的正交矩阵 $V$ 对角化：\n$$\nL = V \\Lambda V^T\n$$\n其中 $\\Lambda$ 是由 $L$ 的实特征值 $\\lambda_i$ 构成的对角矩阵，而 $V$ 是一个正交矩阵（$V^T V = V V^T = I$），其列是对应的标准正交特征向量。这种分解是图谱方法的核心。\n\n我们通过将状态向量 $u(t)$ 投影到 $L$ 的特征基上引入变量替换：\n$$\nv(t) = V^T u(t) \\quad \\iff \\quad u(t) = V v(t)\n$$\n将此代入控制方程得到：\n$$\n\\frac{d}{dt}(V v(t)) = -\\alpha (V \\Lambda V^T) (V v(t)) + b\n$$\n$$\nV \\frac{d v(t)}{dt} = -\\alpha V \\Lambda v(t) + b\n$$\n从左侧乘以 $V^T$ 并利用 $V$ 的正交性：\n$$\n\\frac{d v(t)}{dt} = -\\alpha \\Lambda v(t) + V^T b\n$$\n这将原始的耦合系统转化为 $N$ 个独立的标量线性常微分方程。令 $c = V^T b$。第 $i$ 个方程为：\n$$\n\\frac{d v_i(t)}{dt} = -\\alpha \\lambda_i v_i(t) + c_i, \\quad v_i(0) = (V^T u_0)_i\n$$\n每个分量 $v_i(t)$ 的解取决于 $\\lambda_i$ 的值。对于连通图，拉普拉斯矩阵 $L$ 有一个单特征值 $\\lambda_0 = 0$，所有其他特征值均为严格正值（对于 $i > 0$ 有 $\\lambda_i > 0$）。\n\n情况 1：$\\alpha \\lambda_i \\neq 0$。解为\n$$\nv_i(t) = e^{-\\alpha \\lambda_i t} v_i(0) + \\frac{1 - e^{-\\alpha \\lambda_i t}}{\\alpha \\lambda_i} c_i\n$$\n情况 2：$\\alpha \\lambda_i = 0$。方程变为 $\\frac{d v_i(t)}{dt} = c_i$，其解为\n$$\nv_i(t) = v_i(0) + c_i t\n$$\n这种情况适用于 $\\alpha=0$ 或 $\\lambda_i=0$。所提供的测试用例包含 $\\alpha=0$ 和 $T=0$ 的情况，这些作为简单的特例处理：\n- 若 $T=0$，解显然为 $u(T) = u(0) = u_0$。\n- 若 $\\alpha=0$，方程简化为 $\\frac{d u(t)}{dt} = b$，其解为 $u(T) = u_0 + bT$。\n\n一旦在最终时间 $T$ 计算出向量 $v(T)=[v_0(T), v_1(T), \\dots, v_{N-1}(T)]^T$，就可以通过逆变换恢复原始基下的解：\n$$\nu(T) = V v(T)\n$$\n实现时将首先根据给定的图结构构建拉普拉斯矩阵 $L$。然后，对每个测试用例，它将应用上面推导出的相应公式来计算解 $u(T)$。对于需要特征分解的一般情况，我们将使用数值上稳健的线性代数例程。最终 $u(T)$ 的分量将根据问题规范进行四舍五入和格式化。\n\n该图由 $N=5$ 个节点和以下边及权重定义：$w_{01}=1.0$，$w_{02}=0.4$，$w_{04}=0.2$，$w_{12}=0.3$，$w_{13}=0.8$，$w_{24}=0.6$，$w_{34}=0.5$。\n邻接矩阵 $A$ 为：\n$$\nA = \\begin{pmatrix}\n0.0  1.0  0.4  0.0  0.2 \\\\\n1.0  0.0  0.3  0.8  0.0 \\\\\n0.4  0.3  0.0  0.0  0.6 \\\\\n0.0  0.8  0.0  0.0  0.5 \\\\\n0.2  0.0  0.6  0.5  0.0\n\\end{pmatrix}\n$$\n对角度矩阵 $D$ 通过对 $A$ 的行求和得到：$D_{00}=1.6$，$D_{11}=2.1$，$D_{22}=1.3$，$D_{33}=1.3$，$D_{44}=1.3$。\n图拉普拉斯矩阵 $L=D-A$ 为：\n$$\nL = \\begin{pmatrix}\n 1.6  -1.0  -0.4   0.0  -0.2 \\\\\n-1.0   2.1  -0.3  -0.8   0.0 \\\\\n-0.4  -0.3   1.3   0.0  -0.6 \\\\\n 0.0  -0.8   0.0   1.3  -0.5 \\\\\n-0.2   0.0  -0.6  -0.5   1.3\n\\end{pmatrix}\n$$\n该矩阵将用于所有测试用例的计算。", "answer": "```python\nimport numpy as np\n\ndef compute_u_T(L, alpha, T, u0, b):\n    \"\"\"\n    Computes the solution u(T) for the differential equation du/dt = -alpha*L*u + b.\n    \"\"\"\n    N = L.shape[0]\n\n    # Handle special cases for T=0 and alpha=0\n    if np.isclose(T, 0.0):\n        return u0\n    \n    if np.isclose(alpha, 0.0):\n        return u0 + b * T\n\n    # General case: alpha  0 and T  0\n    # The solution is found via eigendecomposition of L.\n    # L = V Lambda V^T\n    # u(T) = V [exp(-alpha*Lambda*T) V^T u0 + G V^T b]\n    # where G is a diagonal matrix with elements g_i.\n    \n    # Eigendecomposition of the symmetric matrix L\n    lambdas, V = np.linalg.eigh(L)\n    \n    # Transform initial condition and source term to the eigenbasis\n    v0 = V.T @ u0\n    c = V.T @ b\n    \n    # Compute the solution v(T) in the eigenbasis\n    vt = np.zeros(N, dtype=np.float64)\n    \n    for i in range(N):\n        lam = lambdas[i]\n        \n        # Homogeneous part of the solution for v_i(T)\n        hom_part = np.exp(-alpha * lam * T) * v0[i]\n        \n        # Inhomogeneous part of the solution for v_i(T)\n        inhom_part = 0.0\n        # The form of the inhomogeneous term depends on whether lambda_i is zero\n        if np.isclose(lam, 0.0):\n            # For lambda_i = 0, the coefficient of c_i is T\n            inhom_part = c[i] * T\n        else:\n            # For lambda_i != 0, the coefficient is (1-exp(-a*l*T))/(a*l)\n            # We use a numerically stable implementation using np.expm1(x) for e^x-1\n            x = -alpha * lam * T\n            coeff = -np.expm1(x) / (alpha * lam)\n            inhom_part = c[i] * coeff\n            \n        vt[i] = hom_part + inhom_part\n        \n    # Transform the solution back to the original basis\n    uT = V @ vt\n    \n    return uT\n\ndef solve():\n    \"\"\"\n    Main function to define the problem, run test cases, and print the output.\n    \"\"\"\n    # Define graph properties\n    N = 5\n    edges_with_weights = {\n        (0, 1): 1.0, (0, 2): 0.4, (0, 4): 0.2,\n        (1, 2): 0.3, (1, 3): 0.8,\n        (2, 4): 0.6,\n        (3, 4): 0.5\n    }\n\n    # Construct the adjacency matrix A\n    A = np.zeros((N, N))\n    for (i, j), w in edges_with_weights.items():\n        A[i, j] = A[j, i] = w\n\n    # Construct the degree matrix D\n    D = np.diag(np.sum(A, axis=1))\n\n    # Construct the combinatorial graph Laplacian L\n    L = D - A\n\n    # Test suite from the problem description\n    test_cases = [\n        (1.0, 1.0, [1.0, 0.0, 0.0, 0.0, 0.0], [0.0, 0.0, 0.0, 0.0, 0.0]),\n        (0.0, 2.5, [-1.0, 2.0, 0.0, 1.0, 0.0], [0.3, -0.2, 0.1, 0.0, -0.1]),\n        (2.0, 0.0, [0.5, -0.5, 1.0, 0.0, 2.0], [1.0, -1.0, 0.0, 0.5, -0.5]),\n        (0.7, 0.8, [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, -0.5, 0.0, 0.25, -0.25])\n    ]\n\n    all_results = []\n    for case in test_cases:\n        alpha, T, u0_list, b_list = case\n        u0 = np.array(u0_list, dtype=np.float64)\n        b = np.array(b_list, dtype=np.float64)\n        \n        u_T = compute_u_T(L, alpha, T, u0, b)\n        \n        # Append the result vector to the list of all results\n        all_results.append(u_T)\n\n    # Format the final output string as specified\n    formatted_results = []\n    for res_vec in all_results:\n        # Format each number to exactly six decimal places\n        str_vec = [f\"{x:.6f}\" for x in res_vec]\n        formatted_results.append(f\"[{','.join(str_vec)}]\")\n    \n    final_output_str = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output_str)\n\nsolve()\n```", "id": "2436990"}, {"introduction": "在将谱方法应用于多维问题时，一个巨大的障碍是“维度灾难” (curse of dimensionality)，即计算成本随维度数量呈指数级增长。本练习将带您直面这一挑战，并探索一种强大的解决方案：稀疏网格 (sparse grids)。您将通过实现和对比标准的全张量积求积与基于 Smolyak 构造的稀疏网格求积，来量化分析后者如何在大幅减少计算点数（即函数求值次数）的同时，仍能保持高维积分的精度 [@problem_id:2437029]。", "problem": "考虑在一个超立方体上，使用张量积谱求积法则和 Smolyak 稀疏网格构造，对一个光滑、可分离的函数进行数值积分。设空间维度由 $d \\in \\mathbb{N}$ 表示，并考虑函数\n$$\nf(\\mathbf{x}) = \\prod_{i=1}^{d} \\cos\\big(\\alpha_i x_i\\big), \\quad \\mathbf{x} = (x_1,\\dots,x_d) \\in [-1,1]^d,\n$$\n其中参数向量 $\\boldsymbol{\\alpha} = (\\alpha_1,\\dots,\\alpha_d) \\in \\mathbb{R}^d$ 是预先设定的。$d$ 维超立方体 $[-1,1]^d$ 上的精确积分为\n$$\nI_{\\text{exact}}(d,\\boldsymbol{\\alpha}) = \\int_{[-1,1]^d} f(\\mathbf{x}) \\,\\mathrm{d}\\mathbf{x} \\;=\\; \\prod_{i=1}^{d} \\left( \\int_{-1}^{1} \\cos(\\alpha_i x)\\,\\mathrm{d}x \\right) \\;=\\; \\prod_{i=1}^{d} \\begin{cases}\n\\displaystyle \\frac{2\\sin(\\alpha_i)}{\\alpha_i},  \\alpha_i \\neq 0, \\\\[1ex]\n\\displaystyle 2,  \\alpha_i = 0.\n\\end{cases}\n$$\n\n令 $\\{Q^{(\\ell)}\\}_{\\ell\\ge 1}$表示 $[-1,1]$ 上精度严格递增的一维高斯求积法则的固定序列，其中 $Q^{(\\ell)}$ 是具有 $N(\\ell)$ 个点的 Gauss–Legendre 法则，且\n$$\nN(\\ell) = 2\\ell - 1,\n$$\n因此 $Q^{(1)}$ 有 $N(1)=1$ 个节点，$Q^{(\\ell)}$ 能精确积分所有次数最高为 $2N(\\ell)-1$ 的多项式。对于给定的稀疏水平 $L \\in \\mathbb{N}$ 和空间维度 $d \\in \\mathbb{N}$，Smolyak 稀疏网格求积 $A(L,d)$ 定义为\n$$\nA(L,d) \\,=\\, \\sum_{\\substack{\\boldsymbol{\\ell}\\in \\mathbb{N}^d \\\\ \\lvert \\boldsymbol{\\ell}\\rvert \\le L}} \\bigotimes_{i=1}^{d} \\Delta^{(\\ell_i)}, \n\\quad \\text{其中 } \\lvert \\boldsymbol{\\ell}\\rvert = \\sum_{i=1}^d \\ell_i \\text{ 且 } \\Delta^{(\\ell)} = Q^{(\\ell)} - Q^{(\\ell-1)},\n$$\n并约定 $Q^{(0)} \\equiv 0$。等价地，$A(L,d)$ 可以表示为张量积法则的线性组合\n$$\nA(L,d) \\,=\\, \\sum_{s=s_{\\min}}^{L} \\; \\sum_{\\substack{\\boldsymbol{\\ell}\\in \\mathbb{N}^d \\\\ \\lvert \\boldsymbol{\\ell}\\rvert = s}} \nc(L,d,s)\\, \\bigotimes_{i=1}^{d} Q^{(\\ell_i)},\n\\quad \\text{其中}\\quad s_{\\min}=\\max(d,\\,L-d+1),\n$$\n组合系数为\n$$\nc(L,d,s) = (-1)^{\\,L-s}\\,\\binom{d-1}{\\,L-s\\,}.\n$$\n\n对于下面指定的每个测试用例，您必须计算以下量：\n- 稀疏网格近似值 $I_{\\text{sparse}} = A(L,d)[f]$。\n- 完全张量积近似值 $I_{\\text{full}} = \\big( \\bigotimes_{i=1}^{d} Q^{(L)} \\big)[f]$，在每个维度上都使用 $Q^{(L)}$。\n- 每种近似值相对于精确值 $I_{\\text{exact}}(d,\\boldsymbol{\\alpha})$ 的绝对误差，即 $E_{\\text{sparse}} = \\lvert I_{\\text{sparse}} - I_{\\text{exact}}\\rvert$ 和 $E_{\\text{full}} = \\lvert I_{\\text{full}} - I_{\\text{exact}}\\rvert$。\n- Smolyak 稀疏网格构造所使用的函数求值次数，计算为 $A(L,d)$ 上述线性组合中出现的所有张量网格中所有点的并集的基数（也就是说，在所有张量网格中，每个在 $[-1,1]^d$ 内的不同点只计数一次）。将此计数表示为 $N_{\\text{sparse}}$。\n- 完全张量积法则所使用的函数求值次数，即 $N_{\\text{full}} = \\big(N(L)\\big)^d = \\big(2L-1\\big)^d$。\n\n您的程序必须评估并报告以下元组\n$$\n\\big[\\,N_{\\text{sparse}},\\; N_{\\text{full}},\\; E_{\\text{sparse}},\\; E_{\\text{full}}\\,\\big]\n$$\n对于每个测试用例。\n\n测试套件：\n- 用例1：$d=3$, $L=5$, $\\boldsymbol{\\alpha}=(1.3,\\,2.1,\\,0.9)$。\n- 用例2：$d=1$, $L=5$, $\\boldsymbol{\\alpha}=(3.0)$。\n- 用例3：$d=4$, $L=6$, $\\boldsymbol{\\alpha}=(0.7,\\,1.1,\\,1.5,\\,2.0)$。\n- 用例4：$d=2$, $L=3$, $\\boldsymbol{\\alpha}=(0.0,\\,3.3)$。\n\n角度量以弧度为单位。本问题不涉及物理单位。\n\n最终输出格式：您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素是编码为无空格、用方括号括起来的逗号分隔列表的四元组。因此，输出必须采用以下形式\n$$\n\\big[ [N_{\\text{sparse}}^{(1)},N_{\\text{full}}^{(1)},E_{\\text{sparse}}^{(1)},E_{\\text{full}}^{(1)}],\\; [N_{\\text{sparse}}^{(2)},N_{\\text{full}}^{(2)},E_{\\text{sparse}}^{(2)},E_{\\text{full}}^{(2)}],\\; [N_{\\text{sparse}}^{(3)},N_{\\text{full}}^{(3)},E_{\\text{sparse}}^{(3)},E_{\\text{full}}^{(3)}],\\; [N_{\\text{sparse}}^{(4)},N_{\\text{full}}^{(4)},E_{\\text{sparse}}^{(4)},E_{\\text{full}}^{(4)}] \\big].\n$$", "solution": "问题陈述经过了严格验证，被认为是适定的、科学上合理的，并且在计算上是可行的。它完全属于计算工程和数值分析领域，特别是关于谱方法和稀疏网格方法。所有的定义、参数和目标都以足够的清晰度和精确度进行了规定，从而可以得到一个唯一的、可验证的解。因此，我们可以继续进行分析和计算工作。\n\n任务是计算可分离函数 $f(\\mathbf{x}) = \\prod_{i=1}^{d} \\cos(\\alpha_i x_i)$ 在超立方体 $[-1,1]^d$ 上的定积分的近似值。我们将评估 Smolyak 稀疏网格求积相对于完全张量积网格的性能。性能通过绝对误差和求积点数（函数求值次数）来衡量。\n\n求解过程结构如下：\n1.  计算精确积分 $I_{\\text{exact}}$。\n2.  计算完全张量积近似值 $I_{\\text{full}}$ 及其对应的点数 $N_{\\text{full}}$。\n3.  计算 Smolyak 稀疏网格近似值 $I_{\\text{sparse}}$ 及其点数 $N_{\\text{sparse}}$。\n4.  计算绝对误差 $E_{\\text{full}}$ 和 $E_{\\text{sparse}}$。\n\n下面我们详细说明每个步骤。\n\n**1. 精确积分**\n\n函数 $f(\\mathbf{x})$ 是可分离的，这使得 $d$ 维积分可以表示为一维积分的乘积：\n$$\nI_{\\text{exact}}(d,\\boldsymbol{\\alpha}) = \\int_{[-1,1]^d} \\prod_{i=1}^{d} \\cos(\\alpha_i x_i) \\,\\mathrm{d}\\mathbf{x} = \\prod_{i=1}^{d} \\int_{-1}^{1} \\cos(\\alpha_i x)\\,\\mathrm{d}x\n$$\n这个一维积分是初等的：\n$$\n\\int_{-1}^{1} \\cos(\\alpha_i x)\\,\\mathrm{d}x = \\left[ \\frac{\\sin(\\alpha_i x)}{\\alpha_i} \\right]_{-1}^{1} = \\frac{\\sin(\\alpha_i) - \\sin(-\\alpha_i)}{\\alpha_i} = \\frac{2\\sin(\\alpha_i)}{\\alpha_i}, \\quad \\text{对于 } \\alpha_i \\neq 0.\n$$\n在 $\\alpha_i = 0$ 的特殊情况下，被积函数为 $\\cos(0) = 1$，积分为 $\\int_{-1}^{1} 1\\,\\mathrm{d}x = 2$。这就得到了问题陈述中给出的公式。\n\n**2. 完全张量积求积**\n\n水平为 $L$ 的完全张量积近似在 $d$ 个维度中的每一个维度都使用一维 Gauss-Legendre 求积法则 $Q^{(L)}$。$Q^{(L)}$ 中的点数为 $N(L) = 2L-1$。因此，完全张量网格中的总点数为：\n$$\nN_{\\text{full}} = (N(L))^d = (2L-1)^d\n$$\n由于函数的可分离性，积分近似值是一维求积结果的乘积：\n$$\nI_{\\text{full}} = \\left( \\bigotimes_{i=1}^{d} Q^{(L)} \\right)[f] = \\prod_{i=1}^{d} Q^{(L)}[\\cos(\\alpha_i x_i)]\n$$\n每个一维求積 $Q^{(L)}[g]$ 计算为其节点 $\\{x_j, w_j\\}_{j=1}^{N(L)}$ 上的加权和：\n$$\nQ^{(L)}[\\cos(\\alpha_i x_i)] = \\sum_{j=1}^{N(L)} w_j \\cos(\\alpha_i x_j)\n$$\nGauss-Legendre 求积法则的节点和权重是使用标准数值库获得的，特别是 `scipy.special.roots_legendre`。\n\n**3. Smolyak 稀疏网格求积**\n\nSmolyak 近似 $A(L,d)$ 以张量积法则的线性组合形式给出：\n$$\nA(L,d)[f] = \\sum_{s=s_{\\min}}^{L} c(L,d,s) \\sum_{\\substack{\\boldsymbol{\\ell}\\in \\mathbb{N}^d \\\\ |\\boldsymbol{\\ell}| = s}} \\left( \\bigotimes_{i=1}^{d} Q^{(\\ell_i)} \\right)[f]\n$$\n其中 $|\\boldsymbol{\\ell}| = \\sum_{i=1}^d \\ell_i$，$s_{\\min}=\\max(d, L-d+1)$，以及 $c(L,d,s) = (-1)^{L-s}\\binom{d-1}{L-s}$。\n再次利用函数的可分离性，我们有：\n$$\n\\left( \\bigotimes_{i=1}^{d} Q^{(\\ell_i)} \\right)[f] = \\prod_{i=1}^{d} Q^{(\\ell_i)}[\\cos(\\alpha_i x_i)]\n$$\n实现策略如下：\n- 首先，我们预计算并缓存所有必要的一维积分结果 $I_i(\\ell) = Q^{(\\ell)}[\\cos(\\alpha_i x_i)]$，针对每个维度 $i \\in \\{1, \\dots, d\\}$ 和每个水平 $\\ell \\in \\{1, \\dots, L\\}$。\n- 然后，我们从 $s_{\\min}$ 到 $L$ 遍历 $s$。对于每个 $s$，我们计算系数 $c(L,d,s)$。\n- 对于每个 $s$，我们必须生成所有多重索引 $\\boldsymbol{\\ell} = (\\ell_1, \\dots, \\ell_d)$，使得 $\\ell_i \\ge 1$ 且其和 $|\\boldsymbol{\\ell}|$ 为 $s$。这是一个将整数 $s$ 分解为 $d$ 个部分的组合问题。为此实现了一个递归生成器。\n- 对于每个生成的多重索引 $\\boldsymbol{\\ell}$，我们使用预先计算的值来计算乘积 $\\prod_{i=1}^{d} I_i(\\ell_i)$。\n- 将这些乘积针对固定的 $s$求和，乘以 $c(L,d,s)$，然后累加得到 $I_{\\text{sparse}}$ 的最终值。\n\n稀疏网格点数 $N_{\\text{sparse}}$ 是求和式中出现的张量积法则的所有求积点集的并集的基数。相关的法则是 $\\bigotimes_{i=1}^{d} Q^{(\\ell_i)}$，其中多重索引 $\\boldsymbol{\\ell}$ 满足 $s_{\\min} \\le |\\boldsymbol{\\ell}| \\le L$。因此，点集为 $\\mathcal{P} = \\bigcup_{s=s_{\\min}}^{L} \\bigcup_{|\\boldsymbol{\\ell}|=s} \\mathcal{G}(\\boldsymbol{\\ell})$，其中 $\\mathcal{G}(\\boldsymbol{\\ell})$ 是对应于 $\\boldsymbol{\\ell}$ 的张量积网格。\n\n一个关键的观察是 Gauss-Legendre 法则的点集不是嵌套的。然而，它们也不是完全不相交的。对于任何水平 $\\ell \\ge 1$，点数 $N(\\ell) = 2\\ell - 1$ 是奇数，并且相应的 Legendre 多项式 $P_{N(\\ell)}$ 在 $x=0$ 处有一个根。因此，点 $x=0$ 是每个一维求积法则 $Q^{(\\ell)}$ 的成员。因此，如果张量积网格 $\\mathcal{G}(\\boldsymbol{\\ell})$ 和 $\\mathcal{G}(\\boldsymbol{\\ell'})$ 的任何坐标为零（例如，它们都包含原点 $\\mathbf{0}$），它们就会共享点。简单地对网格大小 $\\prod N(\\ell_i)$ 求和会导致重复计数。\n\n为了正确确定 $N_{\\text{sparse}}$，我们必须显式地构造点集的并集。算法如下：\n- 初始化一个空集合数据结构。\n- 遍历所有满足 $s_{\\min} \\le |\\boldsymbol{\\ell}| \\le L$ 的多重索引 $\\boldsymbol{\\ell}$。\n- 对于每个这样的 $\\boldsymbol{\\ell}$，生成相应张量积网格中的所有点。这是一维节点集 $\\{X^{(\\ell_1)}, \\dots, X^{(\\ell_d)}\\}$ 的笛卡尔积。\n- 将每个生成的点（表示为元组）添加到集合中。集合会自动处理重复项。\n- 集合的最终大小即为 $N_{\\text{sparse}}$ 的值。\n\n**4. 误差计算**\n\n最后，按规定计算绝对误差：\n$$\nE_{\\text{sparse}} = \\lvert I_{\\text{sparse}} - I_{\\text{exact}} \\rvert\n$$\n$$\nE_{\\text{full}} = \\lvert I_{\\text{full}} - I_{\\text{exact}} \\rvert\n$$\n\n这个综合过程在下面的 Python 程序中实现，以解决给定的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, comb\nfrom math import sin\nfrom itertools import product\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases.\n    \"\"\"\n    test_cases = [\n        {'d': 3, 'L': 5, 'alpha': (1.3, 2.1, 0.9)},\n        {'d': 1, 'L': 5, 'alpha': (3.0,)},\n        {'d': 4, 'L': 6, 'alpha': (0.7, 1.1, 1.5, 2.0)},\n        {'d': 2, 'L': 3, 'alpha': (0.0, 3.3)},\n    ]\n\n    results = []\n    for case in test_cases:\n        solver = SmolyakQuadrature(**case)\n        result = solver.run()\n        results.append(result)\n\n    # Format the final output string as specified\n    formatted_results = [\n        f\"[{res[0]},{res[1]},{res[2]:.15e},{res[3]:.15e}]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nclass SmolyakQuadrature:\n    \"\"\"\n    Solves the Smolyak quadrature problem for a given set of parameters.\n    \"\"\"\n    def __init__(self, d, L, alpha):\n        self.d = d\n        self.L = L\n        self.alpha = np.array(alpha)\n        \n        # Caches for memoization\n        self._quad_rules_cache = {}\n        self._1d_integrals_cache = {}\n        self._compositions_cache = {}\n\n        self._precompute_quad_rules()\n        self._precompute_1d_integrals()\n\n    def _get_quad_rule(self, level):\n        \"\"\"Returns Gauss-Legendre nodes and weights for a given level.\"\"\"\n        if level not in self._quad_rules_cache:\n            num_points = 2 * level - 1\n            nodes, weights = roots_legendre(num_points)\n            self._quad_rules_cache[level] = (nodes, weights)\n        return self._quad_rules_cache[level]\n\n    def _precompute_quad_rules(self):\n        \"\"\"Pre-computes and caches 1D quadrature rules up to level L.\"\"\"\n        for l in range(1, self.L + 1):\n            self._get_quad_rule(l)\n\n    def _precompute_1d_integrals(self):\n        \"\"\"Pre-computes and caches 1D integrals for each dimension and level.\"\"\"\n        for i in range(self.d):\n            self._1d_integrals_cache[i] = {}\n            for l in range(1, self.L + 1):\n                nodes, weights = self._get_quad_rule(l)\n                # Integrand is cos(alpha_i * x)\n                f_values = np.cos(self.alpha[i] * nodes)\n                integral_val = np.sum(weights * f_values)\n                self._1d_integrals_cache[i][l] = integral_val\n    \n    def _generate_compositions(self, s, d):\n        \"\"\"Generates all compositions of integer s into d parts = 1.\"\"\"\n        if (s, d) in self._compositions_cache:\n            return self._compositions_cache[(s, d)]\n        \n        if d == 1:\n            if s = 1:\n                return [(s,)]\n            else:\n                return []\n        \n        compositions = []\n        for i in range(1, s - (d - 1) + 1):\n            for rest in self._generate_compositions(s - i, d - 1):\n                compositions.append((i,) + rest)\n        \n        self._compositions_cache[(s, d)] = compositions\n        return compositions\n\n    def compute_exact_integral(self):\n        \"\"\"Computes the exact integral of the separable function.\"\"\"\n        val = 1.0\n        for i in range(self.d):\n            a = self.alpha[i]\n            if a == 0.0:\n                val *= 2.0\n            else:\n                val *= (2.0 * sin(a)) / a\n        return val\n\n    def compute_full_tensor(self):\n        \"\"\"Computes the full tensor product approximation and point count.\"\"\"\n        num_points_1d = 2 * self.L - 1\n        N_full = num_points_1d ** self.d\n        \n        I_full = 1.0\n        for i in range(self.d):\n            I_full *= self._1d_integrals_cache[i][self.L]\n            \n        return I_full, N_full\n\n    def compute_sparse_grid(self):\n        \"\"\"Computes the Smolyak sparse grid approximation and point count.\"\"\"\n        s_min = max(self.d, self.L - self.d + 1)\n        \n        I_sparse = 0.0\n        point_set = set()\n        \n        for s in range(s_min, self.L + 1):\n            # Binomial coefficient for Smolyak formula\n            # Use exact=True for integer arithmetic where possible\n            c = ((-1)**(self.L - s)) * comb(self.d - 1, self.L - s, exact=True)\n            if c == 0:\n                continue\n\n            # Generate multi-indices l = (l_1, ..., l_d) with sum(l) = s\n            multi_indices = self._generate_compositions(s, self.d)\n            \n            sum_for_s = 0.0\n            for ell in multi_indices:\n                product_integral = 1.0\n                for i in range(self.d):\n                    product_integral *= self._1d_integrals_cache[i][ell[i]]\n                sum_for_s += product_integral\n                \n                # Add points for this grid to the set for N_sparse calculation\n                node_sets_for_ell = [self._get_quad_rule(l)[0] for l in ell]\n                for p in product(*node_sets_for_ell):\n                    # Rounding points to a high precision to handle floating point noise\n                    # when adding to set.\n                    point_set.add(tuple(np.round(pi, 15) for pi in p))\n\n            I_sparse += c * sum_for_s\n            \n        N_sparse = len(point_set)\n        \n        return I_sparse, N_sparse\n\n    def run(self):\n        \"\"\"Executes all computations and returns the final tuple.\"\"\"\n        I_exact = self.compute_exact_integral()\n        I_full, N_full = self.compute_full_tensor()\n        \n        # Special case for d=1: sparse grid is identical to full tensor product\n        if self.d == 1:\n            I_sparse, N_sparse = I_full, N_full\n        else:\n            I_sparse, N_sparse = self.compute_sparse_grid()\n        \n        E_full = abs(I_full - I_exact)\n        E_sparse = abs(I_sparse - I_exact)\n        \n        return [N_sparse, N_full, E_sparse, E_full]\n\nif __name__ == \"__main__\":\n    # Modified solve function to output as string for direct copy-paste.\n    test_cases = [\n        {'d': 3, 'L': 5, 'alpha': (1.3, 2.1, 0.9)},\n        {'d': 1, 'L': 5, 'alpha': (3.0,)},\n        {'d': 4, 'L': 6, 'alpha': (0.7, 1.1, 1.5, 2.0)},\n        {'d': 2, 'L': 3, 'alpha': (0.0, 3.3)},\n    ]\n    results_list = []\n    for case_params in test_cases:\n        solver_instance = SmolyakQuadrature(**case_params)\n        res_tuple = solver_instance.run()\n        results_list.append(f\"[{res_tuple[0]},{res_tuple[1]},{res_tuple[2]},{res_tuple[3]}]\")\n    # print(f\"[{','.join(results_list)}]\") # This is just for local testing if needed\n```", "id": "2437029"}]}