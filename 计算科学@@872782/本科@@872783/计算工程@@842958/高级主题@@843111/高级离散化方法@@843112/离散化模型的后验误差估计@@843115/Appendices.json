{"hands_on_practices": [{"introduction": "后验误差估计的核心在于使用已知的近似解来估算未知的真实误差。这个过程依赖于两个关键的可计算量：单元残差（衡量偏微分方程在每个单元内部被满足的程度）和通量跳跃（衡量跨单元边界的通量匹配程度）。本练习 ([@problem_id:2370198]) 提供了一个直接的实践机会，让您在一个简洁明了的有限元问题上，亲手计算这些基本构成部分。通过这个例子，您将对误差估计器中的各项来源建立起一个具体而深刻的理解。", "problem": "考虑单位正方形域 $\\Omega = [0,1]^{2}$ 上的标量扩散模型问题（一个泊松型偏微分方程（PDE）），其带有齐次狄利克雷边界条件：\n求 $u \\in H_{0}^{1}(\\Omega)$ 使得\n$\\,-\\Delta u = f \\,$ in $\\Omega$，且 $\\,u = 0\\,$ on $\\partial \\Omega$，\n其中对于所有 $(x,y) \\in \\Omega$，$f(x,y) = 1$。设 $u_{h} \\in V_{h} \\subset H_{0}^{1}(\\Omega)$ 是在三角剖分 $\\mathcal{T}_{h}$ 上的协调有限元法（FEM）近似解，该三角剖分是通过使用从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形分割成 $2$ 个全等的直角三角形得到的，其中 $V_{h}$ 由从属于 $\\mathcal T_{h}$ 的连续分片线性（$P_{1}$）函数组成。\n\n从弱形式以及单元强残差和内部边通量跳跃的定义出发，构造一个显式的基于残差的后验误差估计量 $\\eta$，该估计量针对梯度误差范数 $\\|\\nabla(u - u_{h})\\|_{L^{2}(\\Omega)}$，并用单元残差和内部边通量跳跃表示。然后，在该网格和数据上评估你构造的估计量 $\\eta$。将最终的估计量值 $\\eta$ 表示为一个精确的实数。不要四舍五入。", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **PDE**：在 $\\Omega$ 中 $-\\Delta u = f$。\n- **区域**：$\\Omega = [0,1]^{2}$。\n- **边界条件**：在 $\\partial \\Omega$ 上 $u = 0$（齐次狄利克雷）。\n- **源项**：对于所有 $(x,y) \\in \\Omega$，$f(x,y) = 1$。\n- **精确解空间**：$u \\in H_{0}^{1}(\\Omega)$。\n- **有限元近似**：$u_{h} \\in V_{h} \\subset H_{0}^{1}(\\Omega)$，其中 $V_h$ 由连续分片线性（$P_1$）函数组成。\n- **网格**：三角剖分 $\\mathcal{T}_{h}$ 是通过使用从 $(0,0)$ 到 $(1,1)$ 的对角线将单位正方形分割成 2 个全等的直角三角形形成的。\n- **任务**：为梯度误差范数 $\\|\\nabla(u - u_{h})\\|_{L^{2}(\\Omega)}$ 构造并评估一个显式的基于残差的后验误差估计量 $\\eta$。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据**：该问题是有限元法后验误差估计的一个标准应用，这是计算工程和偏微分方程数值分析中一个成熟的课题。它在根本上是合理的。\n- **适定性**：在凸域上带有齐次狄利克雷条件的泊松问题是适定的。为一个给定的简单网格和数据构造和评估一个特定的误差估计量的任务定义清晰，并会导出一个唯一的解。\n- **客观性**：问题使用精确的数学术语陈述，没有歧义或主观论断。\n- **完整性和一致性**：所有必要组成部分——PDE、区域、边界条件、源项、网格和有限元空间——都已完全指定并且相互一致。\n\n**第 3 步：结论与行动**\n问题是有效的。将构造一个解。\n\n目标是为能量范数下的误差 $e = u - u_h$ 构造并评估一个基于残差的后验误差估计量，对于本问题，能量范数为 $\\|\\nabla e\\|_{L^2(\\Omega)}$。\n\n该问题的弱形式是求 $u \\in H_0^1(\\Omega)$ 使得\n$$a(u, v) = L(v) \\quad \\forall v \\in H_0^1(\\Omega)$$\n其中双线性形式为 $a(w,v) = \\int_\\Omega \\nabla w \\cdot \\nabla v \\, d\\mathbf{x}$，线性形式为 $L(v) = \\int_\\Omega f v \\, d\\mathbf{x}$。相应的有限元问题是求 $u_h \\in V_h$ 使得\n$$a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h$$\n将这两个方程相减，得到误差 $e = u - u_h$ 的Galerkin正交性：\n$$a(e, v_h) = 0 \\quad \\forall v_h \\in V_h$$\n误差的能量范数平方为 $a(e,e)$。我们有 $a(e,e) = a(u,e) - a(u_h,e) = L(e) - a(u_h,e)$。\n在每个单元 $K \\in \\mathcal{T}_h$上进行分部积分：\n$$a(u_h, e) = \\sum_{K \\in \\mathcal{T}_h} \\int_K \\nabla u_h \\cdot \\nabla e \\, d\\mathbf{x} = \\sum_{K \\in \\mathcal{T}_h} \\left( -\\int_K (\\Delta u_h) e \\, d\\mathbf{x} + \\int_{\\partial K} (\\nabla u_h \\cdot n_K) e \\, ds \\right)$$\n其中 $n_K$ 是单元 $K$ 边界 $\\partial K$ 的单位外法向量。\n因此，误差方程变为：\n$$\\|\\nabla e\\|_{L^2(\\Omega)}^2 = a(e,e) = \\sum_{K \\in \\mathcal{T}_h} \\int_K (f + \\Delta u_h) e \\, d\\mathbf{x} - \\sum_{K \\in \\mathcal{T}_h} \\int_{\\partial K} (\\nabla u_h \\cdot n_K) e \\, ds$$\n边界积分的和可以分解为来自内部边 $\\mathcal{E}_I$ 和边界边 $\\mathcal{E}_\\partial$ 的贡献。由于 $e \\in H_0^1(\\Omega)$，在 $\\partial\\Omega$ 上 $e=0$，因此在 $\\mathcal{E}_\\partial$ 上的积分为零。对于由单元 $K_1$ 和 $K_2$ 共享的内部边 $E$，其贡献为 $\\int_E ((\\nabla u_h|_{K_1} \\cdot n_1) + (\\nabla u_h|_{K_2} \\cdot n_2)) e \\, ds$。我们定义跨越 $E$ 的通量跳跃为 $J_E = [\\nabla u_h \\cdot n] = \\nabla u_h|_{K_1} \\cdot n_1 + \\nabla u_h|_{K_2} \\cdot n_2$。单元残差为 $R_K = f + \\Delta u_h$。\n于是误差方程为\n$$\\|\\nabla e\\|_{L^2(\\Omega)}^2 = \\sum_{K \\in \\mathcal{T}_h} \\int_K R_K e \\, d\\mathbf{x} + \\sum_{E \\in \\mathcal{E}_I} \\int_E J_E e \\, ds$$\n为了方便起见，我们在最后的求和中重新标记了跳跃方向。\n通过应用柯西-施瓦茨不等式和插值估计，可以证明可靠性估计 $\\|\\nabla e\\|_{L^2(\\Omega)} \\leq C \\eta$，其中 $\\eta$ 是误差估计量。一个标准的显式基于残差的后验误差估计量是根据这些残差项构造的。我们通过其平方来定义总估计量 $\\eta$：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} \\eta_K^2 = \\sum_{K \\in \\mathcal{T}_h} \\left( h_K^2 \\|R_K\\|_{L^2(K)}^2 + \\frac{1}{2} \\sum_{E \\in \\partial K \\cap \\mathcal{E}_I} h_E \\|J_E\\|_{L^2(E)}^2 \\right)$$\n这里 $h_K$ 是单元 $K$ 的直径，$h_E$ 是边 $E$ 的长度。由于 $u_h$ 是分片线性的，对于所有 $K \\in \\mathcal{T}_h$，单元上的拉普拉斯算子 $\\Delta u_h = 0$。源项为 $f=1$。因此，单元残差为 $R_K = 1$。估计量简化为：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} \\left( h_K^2 \\|1\\|_{L^2(K)}^2 + \\frac{1}{2} \\sum_{E \\in \\partial K \\cap \\mathcal{E}_I} h_E \\|J_E\\|_{L^2(E)}^2 \\right)$$\n\n现在，我们为给定问题评估该估计量。\n区域 $\\Omega = [0,1]^2$被划分为两个三角形：\n- $K_1$：顶点为 $(0,0), (1,0), (1,1)$。\n- $K_2$：顶点为 $(0,0), (0,1), (1,1)$。\n内部边集合 $\\mathcal{E}_I$ 包含一条沿对角线从 $(0,0)$ 到 $(1,1)$ 的边 $E_{12}$。\n\n有限元空间 $V_h$ 由连续分片线性函数组成。网格的节点是正方形的四个角点：$(0,0)$, $(1,0)$, $(0,1)$ 和 $(1,1)$。所有这些节点都位于边界 $\\partial \\Omega$ 上。由于齐次狄利克雷条件 $u=0$ on $\\partial\\Omega$，离散解 $u_h$ 在所有这些节点上必须为零。三角形上的线性函数由其三个顶点处的值唯一确定。由于 $u_h$ 在 $K_1$ 和 $K_2$ 的所有顶点上都为零，因此对于所有 $\\mathbf{x} \\in \\Omega$，都有 $u_h(\\mathbf{x}) = 0$。\n因此，梯度也为零：对于所有 $\\mathbf{x} \\in \\Omega$，$\\nabla u_h(\\mathbf{x}) = \\mathbf{0}$。\n\n当 $u_h \\equiv 0$ 时，跨越任何内部边的通量跳跃为零：\n$$J_E = [\\nabla u_h \\cdot n] = [\\mathbf{0} \\cdot n] = 0$$\n因此，估计量中的第二项消失。估计量简化为单元残差项之和：\n$$\\eta^2 = \\sum_{K \\in \\mathcal{T}_h} h_K^2 \\|1\\|_{L^2(K)}^2$$\n\n我们为每个单元计算各分量。\n对于单元 $K_1$：\n- 顶点为 $(0,0)$, $(1,0), (1,1)$。边长分别为 $1$，$1$ 和 $\\sqrt{(1-0)^2 + (1-0)^2} = \\sqrt{2}$。\n- 单元直径是最长边的长度，所以 $h_{K_1} = \\sqrt{2}$。\n- $K_1$ 的面积是 $\\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n- 残差的 $L^2$-范数平方为 $\\|1\\|_{L^2(K_1)}^2 = \\int_{K_1} 1^2 \\, d\\mathbf{x} = \\text{Area}(K_1) = \\frac{1}{2}$。\n- 来自 $K_1$ 的贡献为 $\\eta_{K_1}^2 = h_{K_1}^2 \\|1\\|_{L^2(K_1)}^2 = (\\sqrt{2})^2 \\times \\frac{1}{2} = 2 \\times \\frac{1}{2} = 1$。\n\n对于单元 $K_2$：\n- 顶点为 $(0,0)$, $(0,1), (1,1)$。边长也分别为 $1$，$1$ 和 $\\sqrt{2}$。\n- 单元直径为 $h_{K_2} = \\sqrt{2}$。\n- $K_2$ 的面积是 $\\frac{1}{2} \\times 1 \\times 1 = \\frac{1}{2}$。\n- 残差的 $L^2$-范数平方为 $\\|1\\|_{L^2(K_2)}^2 = \\int_{K_2} 1^2 \\, d\\mathbf{x} = \\text{Area}(K_2) = \\frac{1}{2}$。\n- 来自 $K_2$ 的贡献为 $\\eta_{K_2}^2 = h_{K_2}^2 \\|1\\|_{L^2(K_2)}^2 = (\\sqrt{2})^2 \\times \\frac{1}{2} = 2 \\times \\frac{1}{2} = 1$。\n\n总估计量值的平方是来自每个单元的贡献之和：\n$$\\eta^2 = \\eta_{K_1}^2 + \\eta_{K_2}^2 = 1 + 1 = 2$$\n因此，估计量的值为：\n$$\\eta = \\sqrt{2}$$", "answer": "$$\\boxed{\\sqrt{2}}$$", "id": "2370198"}, {"introduction": "计算出误差估计值后，一个核心应用便是指导自适应网格加密（AMR），即在估计误差较大的区域选择性地细化网格。然而，选择哪种范数来衡量误差——例如，是关注解本身的 $L^2$ 范数，还是关注其梯度的 $H^1$ 范数——会显著影响加密的位置。本编程练习 ([@problem_id:2370210]) 让您能亲身探索这一原理。您将实现一个自适应加密策略，并观察在求解一个具有尖锐内禀层的函数时，不同的误差范数如何导致截然不同的网格分布，从而深刻体会为特定问题选择合适误差度量的关键性。", "problem": "要求您实现一项自适应网格加密研究，比较对于一个具有尖锐内层的一维函数，误差范数的选择如何影响网格加密的位置。该研究必须从第一性原理出发：范数的定义、一个插值算子，以及一个可从当前网格数据计算的单元后验误差指标。该实现必须在数学上是通用的，并且除了标准的数值积分外，不依赖于任何特定的计算平台。\n\n考虑开区间 $\\left(0,1\\right)$ 和标量函数\n$$\nu(x) \\;=\\; \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\dfrac{x-x_{0}}{\\varepsilon}\\right)\\right),\n$$\n其中 $x \\in \\left[0,1\\right]$，$x_{0} \\in \\left(0,1\\right)$ 定位了内层的位置，而 $\\varepsilon \\in \\left(0,1\\right)$ 控制层的厚度。当 $\\varepsilon$ 很小时，此模型在 $x=x_{0}$ 附近创建一个尖锐的内层。\n\n您需要将区间 $\\left[0,1\\right]$ 离散化为线段（单元）的划分，并通过在网格节点上对 $u$ 进行采样来定义的连续分段线性插值 $I_{h}u$ 来近似 $u$。对于一个单元 $K = [a,b]$，基于 $L^{2}$ 范数和 $H^{1}$ 半范数的精确定义，定义两个局部后验误差指标：\n\n- 基于 $L^{2}$ 的指标：\n$$\n\\eta_{K}^{L^{2}} \\;=\\; \\left(\\int_{a}^{b} \\left(u(x) - I_{h}u(x)\\right)^{2} \\, dx \\right)^{1/2}.\n$$\n\n- 基于 $H^{1}$ 的指标（在单元上使用 $H^{1}$ 半范数）：\n$$\n\\eta_{K}^{H^{1}} \\;=\\; \\left(\\int_{a}^{b} \\left(u'(x) - \\left(I_{h}u\\right)'(x)\\right)^{2} \\, dx \\right)^{1/2}.\n$$\n\n这里 $u'(x)$ 是 $u(x)$ 的经典导数，而 $\\left(I_{h}u\\right)'(x)$ 在单元 $K$ 上等于常数斜率 $\\dfrac{u(b)-u(a)}{b-a}$。为了确保对于小 $\\varepsilon$ 值的稳定和精确结果，积分必须使用足够高阶的高斯求积法进行数值计算。\n\n从 $\\left[0,1\\right]$ 上的一个包含 $N_{0}$ 个等长单元的均匀网格开始，通过以下通用过程执行 $S$ 步迭代自适应加密，分别使用 $\\eta_{K}^{L^{2}}$ 和 $\\eta_{K}^{H^{1}}$ 各一次：\n\n1. 在当前网格上，为每个单元 $K$ 计算所选的指标 $\\eta_{K}$。\n2. 标记指标值最大的前 $\\theta$ 比例（其中 $0<\\theta<1$）的单元。\n3. 通过在每个被标记单元的中点处将其二等分来进行加密，从而创建一个嵌套网格。\n\n完成 $S$ 步加密后，通过计算定义为如下的集中度比率 $C$ 来量化网格在内层周围的集中程度\n$$\nC \\;=\\; \\frac{\\#\\left\\{K : \\text{the midpoint of }K\\text{ satisfies } |x_{\\text{mid}} - x_{0}| \\le \\delta \\right\\}}{\\#\\{\\text{all elements}\\}},\n$$\n其中 $\\delta = m_{\\delta}\\,\\varepsilon$ 且 $m_{\\delta}>0$ 是一个选定的乘数。为两次自适应运行计算 $C^{L^{2}}$ 和 $C^{H^{1}}$，并报告两者。所有比率必须以小数形式报告，而不是百分比。\n\n实现一个程序，执行上述过程，并对每个测试用例输出序对 $\\left[C^{L^{2}},\\,C^{H^{1}}\\right]$。\n\n使用以下测试套件。每个测试用例指定参数 $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right)$：\n\n- 测试用例 1（内层居中，尖锐）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.02,\\, 0.5,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n- 测试用例 2（内层靠近边界，非常尖锐）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.01,\\, 0.05,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n- 测试用例 3（较缓和的层）：$\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.10,\\, 0.5,\\, 8,\\, 4,\\, 0.3,\\, 3\\right)$。\n\n最终输出格式：您的程序应生成单行输出，包含一个长度为 3 的列表，其中每个条目是对应测试用例的一个包含两个条目的列表 $\\left[C^{L^{2}}, C^{H^{1}}\\right]$。将每个小数格式化为小数点后恰好六位数字，并以方括号括起来的逗号分隔列表形式打印整个结果，例如：\n$$\n\\left[\\left[c_{1}^{L^{2}},c_{1}^{H^{1}}\\right],\\left[c_{2}^{L^{2}},c_{2}^{H^{1}}\\right],\\left[c_{3}^{L^{2}},c_{3}^{H^{1}}\\right]\\right].\n$$\n此问题不涉及单位，并且按照数学惯例，所有角度（如有）均以弧度为单位。输出必须是如上指定的小数。", "solution": "所述问题需要进行验证。\n\n逐字提取的已知条件如下：\n- 关注域：开区间 $\\left(0,1\\right)$，离散化在闭区间 $\\left[0,1\\right]$ 上。\n- 标量函数：$u(x) \\;=\\; \\tfrac{1}{2}\\left(1 + \\tanh\\!\\left(\\dfrac{x-x_{0}}{\\varepsilon}\\right)\\right)$，其中 $x \\in \\left[0,1\\right]$, $x_{0} \\in \\left(0,1\\right)$ 且 $\\varepsilon \\in \\left(0,1\\right)$。\n- 离散化：将 $\\left[0,1\\right]$ 划分为线段单元。\n- 近似：在网格节点上对 $u$ 采样的连续分段线性插值 $I_{h}u$。\n- 单元 $K = [a,b]$ 的误差指标：\n  - $L^{2}$ 基：$\\eta_{K}^{L^{2}} \\;=\\; \\left(\\int_{a}^{b} \\left(u(x) - I_{h}u(x)\\right)^{2} \\, dx \\right)^{1/2}$。\n  - $H^{1}$ 基：$\\eta_{K}^{H^{1}} \\;=\\; \\left(\\int_{a}^{b} \\left(u'(x) - \\left(I_{h}u\\right)'(x)\\right)^{2} \\, dx \\right)^{1/2}$，其中 $\\left(I_{h}u\\right)'(x) = \\dfrac{u(b)-u(a)}{b-a}$。\n- 自适应加密过程：\n  - 初始状态：$N_{0}$ 个单元的均匀网格。\n  - 步数：$S$。\n  - 标记策略：标记指标值最大的前 $\\theta$ 比例的单元。\n  - 加密方法：在每个被标记单元的中点处将其二等分。\n- 分析度量：集中度比率 $C \\;=\\; \\frac{\\#\\left\\{K : |x_{\\text{mid}} - x_{0}| \\le \\delta \\right\\}}{\\#\\{\\text{all elements}\\}}$，其中 $\\delta = m_{\\delta}\\,\\varepsilon$。\n- 测试用例：\n  1. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.02,\\, 0.5,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n  2. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.01,\\, 0.05,\\, 8,\\, 6,\\, 0.3,\\, 3\\right)$。\n  3. $\\left(\\varepsilon, x_{0}, N_{0}, S, \\theta, m_{\\delta}\\right) = \\left(0.10,\\, 0.5,\\, 8,\\, 4,\\, 0.3,\\, 3\\right)$。\n\n该问题是计算工程和数值分析中的一个标准练习，具体涉及离散化模型的后验误差估计。它在科学上基于有限元方法和泛函分析的理论。该过程是适定的、客观的，并且所有参数都已指定。因此，该问题是有效的，并将提供一个解决方案。\n\n解决方案按要求从第一性原理构建。\n\n首先，我们分析模型函数 $u(x)$ 及其导数。函数 $u(x) = \\frac{1}{2}\\left(1 + \\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)\\right)$ 表示在以 $x_0$ 为中心、宽度与 $\\varepsilon$ 成正比的区域内，从大约 $0$ 到 $1$ 的平滑过渡。其一阶导数是 $u'(x) = \\frac{1}{2\\varepsilon} \\text{sech}^2\\left(\\frac{x-x_0}{\\varepsilon}\\right)$。该函数是一个正的、对称的钟形曲线，在 $x=x_0$ 处有尖峰，代表了高梯度的内层。二阶导数是 $u''(x) = -\\frac{1}{\\varepsilon^2} \\text{sech}^2\\left(\\frac{x-x_0}{\\varepsilon}\\right) \\tanh\\left(\\frac{x-x_0}{\\varepsilon}\\right)$。该函数关于 $x=x_0$ 是反对称的，在 $x=x_0$ 处为零，并在 $x \\approx x_0 \\pm 0.88\\varepsilon$ 处有两个符号相反的极值。二阶导数量化了函数的曲率。\n\n其次，我们考虑离散化和插值。区间 $\\left[0,1\\right]$ 被节点 $0=z_0 < z_1 < \\dots < z_M=1$ 划分。一个单元是一个区间 $K_i = [z_{i-1}, z_i]$。在每个单元 $K_i$ 上，精确解 $u(x)$ 由连接点 $(z_{i-1}, u(z_{i-1}))$ 和 $(z_i, u(z_i))$ 的线性多项式 $I_h u(x)$ 近似。其显式形式为 $I_h u(x) = u(z_{i-1}) + \\frac{u(z_i)-u(z_{i-1})}{z_i-z_{i-1}}(x - z_{i-1})$，对于 $x \\in K_i$。因此，导数 $(I_h u)'(x)$ 是分段常数，在每个单元 $K_i$ 上等于斜率 $\\frac{u(z_i)-u(z_{i-1})}{z_i-z_{i-1}}$。\n\n第三，我们分析两个后验误差指标。这些指标被定义为在两种不同范数下测量的精确局部插值误差。\n基于 $L^2$ 的指标 $\\eta_K^{L^2}$ 测量函数值本身的均方根误差。线性单元的标准插值理论指出，误差 $u - I_h u$ 与单元尺寸 $h_K$ 和函数的二阶导数成比例，即 $\\|u - I_h u\\|_{L^2(K)} \\sim h_K^2 \\|u''\\|_{L^2(K)}$。由于 $|u''(x)|$ 在层的“肩部”（即偏离 $x_0$ 的位置）达到最大值，因此基于 $L^2$ 的指标将在位于这些区域的单元中最大。因此，由 $\\eta_K^{L^2}$ 驱动的自适应加密将优先在层的中心两侧插入新节点，而不是直接在其最陡峭的点。\n基于 $H^1$ 的指标 $\\eta_K^{H^1}$ 测量导数的均方根误差。被积函数是 $(u'(x) - (I_h u)'(x))^2$。真导数 $u'(x)$ 是一个尖峰函数，而近似导数 $(I_h u)'(x)$ 仅仅是单元上的一个常数割线斜率。该积分的主要贡献来自于 $u'(x)$ 本身值较大的区域。由于 $u'(x)$ 在 $x=x_0$ 处最为集中，$\\eta_K^{H^1}$ 指标将在包含或紧邻 $x_0$ 的少数单元中最大。因此，由 $\\eta_K^{H^1}$ 驱动的加密将使网格点非常紧密地集中在内层的中心周围。\n\n第四，数值实现需要一个自适应网格加密（AMR）循环的算法。从一个包含 $N_0$ 个单元的均匀网格开始，以下步骤重复 $S$ 次：\n1.  对于当前网格中的每个单元 $K$，计算所选的误差指标 $\\eta_K^{L^2}$ 或 $\\eta_K^{H^1}$。这需要数值求积，因为这些积分在解析上并不简单。为了准确评估积分，特别是当 $\\varepsilon$ 很小且被积函数高度局部化时，需要一个鲁棒的自适应求积方法，例如 `scipy.integrate.quad` 提供的方法。\n2.  识别要加密的单元。这通过 Dörfler 标记策略完成：按指标值对单元进行排序，并标记前 $\\lceil \\theta \\cdot M \\rceil$ 个单元，其中 $M$ 是当前单元数。\n3.  通过将被标记单元的中点添加到现有节点集中来生成新网格。生成的节点集必须排序并去除重复项，以定义下一级网格。\n\n最后，在 $S$ 步加密之后，计算集中度比率 $C$。该度量量化了加密策略在将网格集中于感兴趣特征周围的有效性。计算过程包括统计中点 $x_{\\text{mid}}$ 落在区间 $[x_0 - \\delta, x_0 + \\delta]$ 内的最终单元数量，然后除以总单元数。我们预计，在所有测试用例中，$C^{H^1}$ 将始终大于 $C^{L^2}$，这表明基于 $H^1$ 的指标在解析尖锐梯度方面具有更优越的局部化特性。\n对于所提供的三个测试用例中的每一个，实现都将精确地遵循这一逻辑。", "answer": "```python\nimport numpy as np\nfrom scipy import integrate\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to run the adaptive mesh refinement study for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # (epsilon, x0, N0, S, theta, m_delta)\n        (0.02, 0.5, 8, 6, 0.3, 3),\n        (0.01, 0.05, 8, 6, 0.3, 3),\n        (0.10, 0.5, 8, 4, 0.3, 3),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        eps, x0, N0, S, theta, m_delta = case\n        \n        # Run refinement for L2 indicator\n        C_L2 = run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type='L2')\n        \n        # Run refinement for H1 indicator\n        C_H1 = run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type='H1')\n\n        all_results.append([C_L2, C_H1])\n\n    # Format the final output string as per problem specification.\n    formatted_results = []\n    for c_l2, c_h1 in all_results:\n        formatted_results.append(f\"[{c_l2:.6f},{c_h1:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\ndef u(x, x0, eps):\n    \"\"\"The exact function u(x).\"\"\"\n    return 0.5 * (1.0 + np.tanh((x - x0) / eps))\n\ndef du_dx(x, x0, eps):\n    \"\"\"The exact derivative u'(x).\"\"\"\n    val = (x - x0) / eps\n    return 0.5 / eps * (1.0 / np.cosh(val))**2\n\ndef run_refinement(eps, x0, N0, S, theta, m_delta, indicator_type):\n    \"\"\"\n    Performs the adaptive mesh refinement procedure for a given indicator type.\n    \"\"\"\n    # Initial uniform mesh\n    nodes = np.linspace(0.0, 1.0, N0 + 1)\n\n    for _ in range(S):\n        num_elements = len(nodes) - 1\n        indicators = np.zeros(num_elements)\n        elements = []\n\n        # Compute indicators for all elements\n        for i in range(num_elements):\n            a, b = nodes[i], nodes[i+1]\n            elements.append((a, b))\n            ua, ub = u(a, x0, eps), u(b, x0, eps)\n            \n            if b == a:  # Should not happen with proper refinement\n                indicators[i] = 0.0\n                continue\n            \n            slope = (ub - ua) / (b - a)\n\n            if indicator_type == 'L2':\n                integrand = lambda x: (u(x, x0, eps) - (ua + slope * (x - a)))**2\n            elif indicator_type == 'H1':\n                integrand = lambda x: (du_dx(x, x0, eps) - slope)**2\n            else:\n                raise ValueError(\"Invalid indicator type.\")\n\n            # Numerical integration\n            integral_val, _ = integrate.quad(integrand, a, b, limit=100)\n            indicators[i] = math.sqrt(integral_val)\n\n        # Mark elements for refinement\n        num_to_refine = math.ceil(theta * num_elements)\n        if num_to_refine > 0:\n            # Get indices of elements with largest indicators\n            refine_indices = np.argsort(indicators)[-num_to_refine:]\n        else:\n            refine_indices = []\n\n        # Refine marked elements by bisection\n        new_nodes_to_add = []\n        for index in refine_indices:\n            a, b = elements[index]\n            midpoint = (a + b) / 2.0\n            new_nodes_to_add.append(midpoint)\n        \n        # Create new sorted mesh\n        nodes = np.union1d(nodes, new_nodes_to_add)\n\n    # Compute concentration ratio C\n    delta = m_delta * eps\n    num_final_elements = len(nodes) - 1\n    concentrated_count = 0\n\n    for i in range(num_final_elements):\n        midpoint = (nodes[i] + nodes[i+1]) / 2.0\n        if abs(midpoint - x0) = delta:\n            concentrated_count += 1\n    \n    concentration_ratio = concentrated_count / num_final_elements if num_final_elements > 0 else 0.0\n    \n    return concentration_ratio\n\nsolve()\n\n```", "id": "2370210"}, {"introduction": "在有限元方法中，连续空间中的范数（如 $L^2$ 或 $H^1$ 范数）通过质量矩阵和刚度矩阵，在离散的向量空间中找到了它们的对应形式。误差本身是一个高维向量，其大小由这些矩阵决定。最后的这个练习 ([@problem_id:2370222]) 将逆转我们的思考过程：您不再是计算一个已有的误差估计，而是需要构造一个“伪”误差向量，使其在选定的离散范数下的“长度”恰好等于一个预设值。这项任务将巩固范数的抽象概念与其通过矩阵向量乘法实现的具体操作之间的联系，从而加深您对计算模型中误差离散本质的理解。", "problem": "您的任务是为离散化的一维模型构建一个合理的代理精确解 $\\;u_{\\text{fake}}\\;$，使得误差范数 $\\;\\lVert u_{\\text{fake}} - u_h \\rVert\\;$ 与一个指定的误差大小 $\\;\\eta\\;$ 相匹配，其中 $\\;u_h\\;$ 是一个给定的计算解。请完全在由标准一维线性有限元在区间 $\\;[0,1]\\;$ 上通过包含 $\\;n\\;$ 个节点的均匀网格所引发的有限维设定中进行操作。您的构建方法必须遵循基本原理：它必须源于对称正定矩阵诱导的范数的基本定义，并且必须尊重所选范数的离散结构。\n\n基本依据：\n- 在 $\\;\\mathbb{R}^m\\;$ 上，由一个对称正定矩阵 $\\;N \\in \\mathbb{R}^{m \\times m}\\;$ 诱导的范数定义为\n$$\n\\lVert v \\rVert_N \\equiv \\sqrt{v^{\\mathsf{T}} N v}.\n$$\n- 对于均匀网格上的连续分片线性有限元，其网格尺寸为 $\\;h = \\frac{1}{n-1}\\;$，节点为 $\\;x_i = i h\\;$（其中 $\\;i=0,\\dots,n-1\\;$）：\n  - 离散 $\\;L^2\\;$ 范数由全局质量矩阵 $\\;M \\in \\mathbb{R}^{n \\times n}\\;$ 诱导，该矩阵由单元质量矩阵组装而成\n  $$\n  M^{(e)} = \\frac{h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}.\n  $$\n  - 与泊松双线性形式 $\\;a(u,v) = \\int_0^1 u'(x) v'(x)\\,dx\\;$ 以及在 $\\;x=0\\;$ 和 $\\;x=1\\;$ 处的齐次狄利克雷边界条件相关联的离散能量范数，是由规约刚度矩阵 $\\;K_{\\text{int}} \\in \\mathbb{R}^{(n-2) \\times (n-2)}\\;$ 在内部自由度上诱导的，该矩阵由单元刚度矩阵组装而成\n  $$\n  K^{(e)} = \\frac{1}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}.\n  $$\n  对于边界项为零的向量 $\\;w \\in \\mathbb{R}^{n}\\;$，其能量半范数为\n  $$\n  \\lVert w \\rVert_{K} \\equiv \\sqrt{w_{\\text{int}}^{\\mathsf{T}} K_{\\text{int}} w_{\\text{int}}},\n  $$\n  其中 $\\;w_{\\text{int}} \\in \\mathbb{R}^{n-2}\\;$ 汇集了 $\\;w\\;$ 的内部份量。\n\n任务：\n- 对于下述每个测试用例，构建一个方法，在给定 $\\;u_h\\;$ 和 $\\;\\eta\\;$ 的情况下，返回一个向量 $\\;u_{\\text{fake}}\\;$，使得误差 $\\;e = u_{\\text{fake}} - u_h\\;$ 的所选离散范数等于 $\\;\\eta\\;$（在数值上合理的容差范围内）。您的构建方法必须从第一性原理推导：从诱导范数的定义开始，选择一个与所选范数兼容的非零方向，并缩放该方向，以使最终的范数等于 $\\;\\eta\\;$。除上述诱导范数的定义和有限元组装规则外，不要假设或使用任何预先推导的快捷公式。\n\n- 科学真实性要求：当使用能量范数时，通过仅对内部自由度进行操作来强制施加齐次狄利克雷边界条件，并在边界节点处用零扩展。当使用 $\\;L^2\\;$ 范数时，使用全部 $\\;n\\;$ 个节点。\n\n程序必须实现的数值细节：\n- 在 $\\;[0,1]\\;$ 上构建包含 $\\;n\\;$ 个节点的均匀网格。\n- 根据上述单元矩阵组装全局质量矩阵 $\\;M\\;$ 和规约刚度矩阵 $\\;K_{\\text{int}}\\;$。\n- 对于 $\\;L^2\\;$ 范数，计算 $\\;\\lVert e \\rVert_{M} = \\sqrt{e^{\\mathsf{T}} M e}\\;$。\n- 对于能量范数，计算 $\\;\\lVert e \\rVert_{K} = \\sqrt{e_{\\text{int}}^{\\mathsf{T}} K_{\\text{int}} e_{\\text{int}}}\\;$，其中 $\\;e_{\\text{int}}\\;$ 是 $\\;e\\;$ 的内部项。\n- 为每种范数选择一个兼容的非零方向，并对其进行缩放，使得在精确算术中，误差的诱导范数恰好等于 $\\;\\eta\\;$。通过返回 $\\;u_{\\text{fake}} = u_h\\;$ 来处理 $\\;\\eta = 0\\;$ 的情况。\n\n测试套件：\n对于以下每个用例，通过在网格节点 $\\;x_i\\;$ 处对指定函数进行采样来构建 $\\;u_h\\;$。\n\n- 用例 $\\;1\\;$ (理想情况, $\\;L^2\\;$ 范数):\n  - 范数类型: $\\;L^2\\;$\n  - $\\;n = 6\\;$\n  - $u_h(x) = \\sin(\\pi x)$\n  - $\\;\\eta = 0.4\\;$\n- 用例 $\\;2\\;$ (理想情况, 能量范数, 带齐次狄利克雷边界条件):\n  - 范数类型: 能量\n  - $\\;n = 8\\;$\n  - $u_h(x) = x(1-x)$\n  - $\\;\\eta = 0.2\\;$\n- 用例 $\\;3\\;$ (边界情况, 零误差目标, $\\;L^2\\;$ 范数):\n  - 范数类型: $\\;L^2\\;$\n  - $\\;n = 5\\;$\n  - $u_h(x) = 0$\n  - $\\;\\eta = 0.0\\;$\n- 用例 $\\;4\\;$ (边界情况, 极小误差目标, 能量范数):\n  - 范数类型: 能量\n  - $\\;n = 10\\;$\n  - $u_h(x) = \\sin(2\\pi x)$\n  - $\\;\\eta = 10^{-12}\\;$\n- 用例 $\\;5\\;$ (小网格, 任意误差目标, $\\;L^2\\;$ 范数):\n  - 范数类型: $\\;L^2\\;$\n  - $\\;n = 3\\;$\n  - $u_h(x) = x$\n  - $\\;\\eta = 1.2345\\;$\n\n输出规格：\n- 对每个测试用例，返回一个布尔值，表示所构建的 $\\;u_{\\text{fake}}\\;$ 是否在以下容差范围内达到了目标误差大小\n$$\n\\text{tol} = 10^{-12} + 10^{-10} \\max(1, \\eta).\n$$\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$\\;[{\\rm True},{\\rm False},{\\rm True}]\\;$）。不应打印任何额外文本。", "solution": "所述问题是有效的。这是一个在计算工程领域内，特别是在有限元方法和后验误差分析方面，提法明确、有科学依据的练习。所有定义和参数都是标准的且自洽的。因此，我们开始进行求解。\n\n任务是构建一个代理精确解 $u_{\\text{fake}}$，使得误差 $e = u_{\\text{fake}} - u_h$ 具有指定的范数 $\\lVert e \\rVert = \\eta$，其中 $u_h$ 是给定的离散解。这将针对两种类型的范数进行：由质量矩阵 $M$ 诱导的离散 $L^2$ 范数，以及由刚度矩阵 $K$ 诱导的离散能量范数。\n\n指导原则是在 $\\mathbb{R}^m$ 上由对称正定（SPD）矩阵 $N \\in \\mathbb{R}^{m \\times m}$ 诱导的范数的定义：\n$$\n\\lVert v \\rVert_N \\equiv \\sqrt{v^{\\mathsf{T}} N v}.\n$$\n我们的目标是构建一个误差向量 $e$，使得 $\\lVert e \\rVert_N = \\eta$。一旦确定了这样的误差向量，代理精确解就可以通过简单的向量加法 $u_{\\text{fake}} = u_h + e$ 得到。\n\n所要求的方法是选择一个非零方向向量 $d$ 并对其进行缩放，以获得所需的误差向量 $e$。让我们设 $e = \\alpha d$，其中 $\\alpha \\in \\mathbb{R}$ 为某个标量。我们必须找到 $\\alpha$ 以满足范数条件。将 $e = \\alpha d$ 代入范数定义，我们得到：\n$$\n\\lVert e \\rVert_N = \\lVert \\alpha d \\rVert_N = \\sqrt{(\\alpha d)^{\\mathsf{T}} N (\\alpha d)} = \\sqrt{\\alpha^2 d^{\\mathsf{T}} N d} = |\\alpha| \\sqrt{d^{\\mathsf{T}} N d} = |\\alpha| \\lVert d \\rVert_N.\n$$\n我们要求这个值等于目标误差大小 $\\eta$，这导出了方程：\n$$\n|\\alpha| \\lVert d \\rVert_N = \\eta.\n$$\n对于 $\\eta  0$ 的情况，我们必须选择一个方向向量 $d$，使其范数 $\\lVert d \\rVert_N$ 不为零。由于质量矩阵 $M$ 和规约刚度矩阵 $K_{\\text{int}}$ 都是对称正定的，对于任何非零向量 $d$，条件 $\\lVert d \\rVert_N  0$ 都成立。因此，我们可以毫无歧义地解出 $|\\alpha|$：\n$$\n|\\alpha| = \\frac{\\eta}{\\lVert d \\rVert_N}.\n$$\n我们可以选择正标量，$\\alpha = \\frac{\\eta}{\\lVert d \\rVert_N}$。误差向量则为 $e = \\frac{\\eta}{\\lVert d \\rVert_N} d$。\n\n在 $\\eta = 0$ 的平凡情况下，范数的性质决定了 $e$ 必须是零向量。因此，$u_{\\text{fake}} = u_h$。\n\n这概述了一个完整且有理有据的过程。我们现在将为每种范数类型指定细节。\n\n**离散 $L^2$ 范数的构建**\n该范数作用于 $\\mathbb{R}^n$ 中的向量，定义为 $\\lVert v \\rVert_M = \\sqrt{v^{\\mathsf{T}} M v}$，其中 $M \\in \\mathbb{R}^{n \\times n}$ 是全局质量矩阵。\n1.  **矩阵组装**：全局质量矩阵 $M$ 是在均匀网格的 $n-1$ 个单元上由单元质量矩阵 $M^{(e)} = \\frac{h}{6} \\begin{bmatrix} 2  1 \\\\ 1  2 \\end{bmatrix}$ 组装而成的，其中 $h = 1/(n-1)$。这将产生一个 $n \\times n$ 的三对角对称正定矩阵。\n2.  **方向向量**：任何非零向量 $d \\in \\mathbb{R}^n$ 都是允许的。为确定起见，我们选择一个在中心节点处有单个非零项的向量：$d_k = 1$（对于 $k = \\lfloor n/2 \\rfloor$），而 $d_i=0$（对于 $i \\neq k$）。\n3.  **构建**：如果 $\\eta=0$，则 $u_{\\text{fake}} = u_h$。如果 $\\eta  0$，我们计算缩放因子 $\\alpha = \\eta / \\sqrt{d^{\\mathsf{T}} M d}$ 并设置 $u_{\\text{fake}} = u_h + \\alpha d$。\n\n**离散能量范数的构建**\n该范数是为满足齐次狄利克雷边界条件的函数定义的，这转化为向量 $e$ 满足 $e_0 = 0$ 和 $e_{n-1} = 0$。范数仅使用 $n-2$ 个内部自由度来计算：$\\lVert e \\rVert_K = \\sqrt{e_{\\text{int}}^{\\mathsf{T}} K_{\\text{int}} e_{\\text{int}}}$，其中 $K_{\\text{int}} \\in \\mathbb{R}^{(n-2) \\times (n-2)}$ 是规约刚度矩阵。\n1.  **矩阵组装**：首先由单元矩阵 $K^{(e)} = \\frac{1}{h} \\begin{bmatrix} 1  -1 \\\\ -1  1 \\end{bmatrix}$ 组装一个全局刚度矩阵 $K \\in \\mathbb{R}^{n \\times n}$。规约矩阵 $K_{\\text{int}}$ 是 $K$ 中对应于内部节点（索引从 $1$ 到 $n-2$）的子矩阵。这个过程产生一个 $(n-2) \\times (n-2)$ 的三对角对称正定矩阵。\n2.  **方向向量**：方向向量 $d \\in \\mathbb{R}^n$ 必须尊重边界条件。我们选择一个简单的向量，其在第一个内部节点处有单个非零分量：$d_1=1$，所有其他分量为零。相应的内部向量 $d_{\\text{int}} \\in \\mathbb{R}^{n-2}$ 因此是第一个标准基向量。\n3.  **构建**：如果 $\\eta=0$，则 $u_{\\text{fake}} = u_h$。如果 $\\eta  0$，我们使用内部向量计算缩放因子：$\\alpha = \\eta / \\sqrt{d_{\\text{int}}^{\\mathsf{T}} K_{\\text{int}} d_{\\text{int}}}$。完整的误差向量是 $e = \\alpha d$，代理精确解是 $u_{\\text{fake}} = u_h + e$。问题规定，对于能量范数的情况，给定的 $u_h$ 已经满足边界条件，因此 $u_{\\text{fake}}$ 也将满足。\n\n以下程序实现了这一逻辑，以解决所提供的测试用例，并验证所构建的误差在指定容差范围内与目标大小 $\\eta$ 相匹配。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef assemble_mass_matrix(n, h):\n    \"\"\"Assembles the global mass matrix M for n nodes.\"\"\"\n    M = np.zeros((n, n), dtype=float)\n    M_elem = (h / 6.0) * np.array([[2, 1], [1, 2]])\n    for i in range(n - 1):\n        M[i:i+2, i:i+2] += M_elem\n    return M\n\ndef assemble_stiffness_matrix_interior(n, h):\n    \"\"\"Assembles the reduced stiffness matrix K_int for n-2 interior nodes.\"\"\"\n    K = np.zeros((n, n), dtype=float)\n    K_elem = (1.0 / h) * np.array([[1, -1], [-1, 1]])\n    for i in range(n - 1):\n        K[i:i+2, i:i+2] += K_elem\n    K_int = K[1:-1, 1:-1]\n    return K_int\n\ndef construct_and_validate(params):\n    \"\"\"\n    Constructs the surrogate solution u_fake and validates the error norm.\n    \"\"\"\n    norm_type, n, u_h_func, eta = params\n\n    # 1. Define mesh and compute u_h\n    h = 1.0 / (n - 1)\n    x = np.linspace(0.0, 1.0, n)\n    u_h = u_h_func(x)\n\n    # 2. Handle trivial case eta = 0\n    if eta == 0.0:\n        u_fake = u_h.copy()\n        e_norm_computed = 0.0\n    else:\n        # 3. Construct error vector e for eta > 0\n        if norm_type == 'L2':\n            M = assemble_mass_matrix(n, h)\n            \n            # Choose a non-zero direction vector d\n            d = np.zeros(n)\n            d[n // 2] = 1.0\n            \n            # Compute norm of d\n            norm_d_sq = d.T @ M @ d\n            norm_d = np.sqrt(norm_d_sq)\n            \n            # Scale d to create the error vector e\n            alpha = eta / norm_d\n            e = alpha * d\n            \n            # Construct u_fake\n            u_fake = u_h + e\n            \n            # Verification\n            e_check = u_fake - u_h\n            e_norm_computed = np.sqrt(e_check.T @ M @ e_check)\n            \n        elif norm_type == 'energy':\n            K_int = assemble_stiffness_matrix_interior(n, h)\n            \n            # Choose a non-zero direction vector d respecting BCs\n            d = np.zeros(n)\n            d[1] = 1.0  # Non-zero at first interior node\n            d_int = d[1:-1]\n            \n            # Compute norm of d\n            norm_d_sq = d_int.T @ K_int @ d_int\n            norm_d = np.sqrt(norm_d_sq)\n            \n            # Scale d to create the error vector e\n            alpha = eta / norm_d\n            e = alpha * d\n            \n            # Construct u_fake\n            u_fake = u_h + e\n            \n            # Verification\n            e_check = u_fake - u_h\n            e_check_int = e_check[1:-1]\n            e_norm_computed = np.sqrt(e_check_int.T @ K_int @ e_check_int)\n        else:\n            raise ValueError(\"Unknown norm type\")\n\n    # 4. Validate the result against tolerance\n    tolerance = 1e-12 + 1e-10 * max(1.0, eta)\n    return np.abs(e_norm_computed - eta) = tolerance\n\ndef solve():\n    \"\"\"\n    Main solver function that processes all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: L2 norm, happy path\n        ('L2', 6, lambda x: np.sin(np.pi * x), 0.4),\n        # Case 2: Energy norm, happy path\n        ('energy', 8, lambda x: x * (1 - x), 0.2),\n        # Case 3: L2 norm, zero error\n        ('L2', 5, lambda x: np.zeros_like(x), 0.0),\n        # Case 4: Energy norm, small error\n        ('energy', 10, lambda x: np.sin(2 * np.pi * x), 1e-12),\n        # Case 5: L2 norm, small mesh\n        ('L2', 3, lambda x: x, 1.2345),\n    ]\n\n    results = []\n    for case in test_cases:\n        is_valid = construct_and_validate(case)\n        results.append(str(is_valid))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2370222"}]}