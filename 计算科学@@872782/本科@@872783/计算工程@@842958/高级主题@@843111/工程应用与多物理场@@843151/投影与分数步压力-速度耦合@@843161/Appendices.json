{"hands_on_practices": [{"introduction": "在着手实现任何显式时间积分方案之前，首要任务是理解其数值稳定性限制。本练习将引导你分析一种用于对流-扩散方程的常见显式离散格式，并推导其稳定时间步长的计算方法 [@problem_id:2428893]。掌握这一基础，是确保数值模拟不会因时间步长 $\\Delta t$ 选择不当而导致计算结果发散的关键第一步。", "problem": "考虑一个$2$维不可压缩牛顿流体，其运动粘度为 $\\nu$，位于间距为 $\\Delta x$ 和 $\\Delta y$ 的均匀矩形网格上，并在两个方向上均采用周期性边界条件。假设压力-速度耦合通过投影法（分数步法）进行：一个显式速度预测步通过显式处理对流和扩散项来推进动量方程，随后进行压力投影以强制执行离散无散约束。假设速度场已在其分量的恒定界限附近进行了线性化，其最大值为 $|u| \\le U_{\\max}$ 和 $|v| \\le V_{\\max}$，其中 $U_{\\max}$ 和 $V_{\\max}$ 是给定的常数。显式预测器采用单步前向欧拉法推进速度，其中对流导数使用一阶迎风差分，扩散项使用标准的$5$点拉普拉斯算子。投影步是一个到离散无散子空间上的 $\\ell^2$ 正交投影。\n\n数值稳定性的定义如下：对于周期性边界条件，单步更新不得增加预测器任何离散傅里叶模态的 $\\ell^2$ 范数；此外，随后的压力投影也不得增加 $\\ell^2$ 范数。\n\n对于下述测试套件中的每一组参数，确定最大稳定时间步长 $\\Delta t_{\\max}$（单位为秒），即对于所有网格允许的波数，上述稳定性要求都成立的最大 $\\Delta t$。每个答案以 $\\mathrm{s}$ 为单位，表示为浮点数。\n\n使用以下测试套件，其中每种情况都是一个元组 $(\\Delta x,\\Delta y,U_{\\max},V_{\\max},\\nu)$，$\\Delta x$ 和 $\\Delta y$ 的单位为 $\\mathrm{m}$，$U_{\\max}$ 和 $V_{\\max}$ 的单位为 $\\mathrm{m/s}$，$\\nu$ 的单位为 $\\mathrm{m^2/s}$：\n\n- 情况 $1$：$(0.01, 0.02, 1.0, 0.5, 10^{-3})$\n- 情况 $2$：$(0.005, 0.005, 0.0, 0.0, 10^{-4})$\n- 情况 $3$：$(0.1, 0.05, 2.0, 1.0, 0.0)$\n- 情况 $4$：$(0.01, 0.01, 0.3, 0.1, 10^{-3})$\n- 情况 $5$：$(0.005, 0.005, 0.1, 0.1, 10^{-2})$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[x_1,x_2,x_3,x_4,x_5]$），其中 $x_i$ 是为情况 $i$ 计算出的 $\\Delta t_{\\max}$，单位为 $\\mathrm{s}$。", "solution": "所提出的问题具有科学依据，是适定且客观的。它提出了一个在计算工程相关的偏微分方程数值分析中的标准问题。因此，我们寻求一个严谨的解法。\n\n该问题要求为求解周期性域上$2$维不可压缩 Navier-Stokes 方程的数值格式找到最大稳定时间步长 $\\Delta t_{\\max}$。控制方程为：\n$$\n\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} = -\\nabla p + \\nu \\nabla^2 \\mathbf{u}\n$$\n$$\n\\nabla \\cdot \\mathbf{u} = 0\n$$\n这里，$\\mathbf{u}=(u,v)$ 是速度矢量，$p$ 是运动压力（压力除以恒定密度 $\\rho$），$\\nu$ 是运动粘度。\n\n该解法采用分数步（或投影）法。此方法将速度和压力的更新解耦。\n$1$。预测步：通过显式推进动量方程（省略压力梯度项）来计算中间速度场 $\\mathbf{u}^*$。\n$$\n\\frac{\\mathbf{u}^* - \\mathbf{u}^n}{\\Delta t} = -(\\mathbf{u}^n \\cdot \\nabla) \\mathbf{u}^n + \\nu \\nabla^2 \\mathbf{u}^n\n$$\n$2$。投影步：将中间速度 $\\mathbf{u}^*$ 投影到离散无散矢量场空间上，以获得新时间步的速度 $\\mathbf{u}^{n+1}$。此步强制执行不可压缩性约束。\n\n问题基于离散傅里叶模态的 $\\ell^2$ 范数定义稳定性。投影步是一个 $\\ell^2$ 正交投影，它是一个非扩张算子；其算子范数最多为 $1$。因此，投影步不会放大任何傅里叶模态，也不会引入不稳定性。所以，该格式的整体稳定性完全由显式预测步的稳定性决定。\n\n预测步的稳定性通过 von Neumann 稳定性分析进行评估。该分析在线性化的预测器方程上进行，其中非线性对流项 $(\\mathbf{u} \\cdot \\nabla)\\mathbf{u}$ 被替换为 $(\\mathbf{U} \\cdot \\nabla)\\mathbf{u}$，$\\mathbf{U}=(U,V)$ 是一个恒定速度。为确保在给定界限内的任何流动条件下都保持稳定，我们必须考虑最坏情况，即 $|U| = U_{\\max}$ 和 $|V| = V_{\\max}$。\n\n速度的标量分量（记为 $\\phi$）的预测步采用时间上的前向欧拉法、对流项的一阶迎风格式和扩散项的标准$5$点模板进行离散。在网格点 $(j,l)$ 处的全离散方程为：\n$$\n\\frac{\\phi_{j,l}^{n+1} - \\phi_{j,l}^{n}}{\\Delta t} = - \\left( U\\frac{\\phi_{j,l}^n - \\phi_{j-\\sigma_x,l}^n}{\\sigma_x\\Delta x} + V\\frac{\\phi_{j,l}^n - \\phi_{j,l-\\sigma_y}^n}{\\sigma_y\\Delta y} \\right) + \\nu \\left( \\frac{\\phi_{j+1,l}^n - 2\\phi_{j,l}^n + \\phi_{j-1,l}^n}{\\Delta x^2} + \\frac{\\phi_{j,l+1}^n - 2\\phi_{j,l}^n + \\phi_{j,l-1}^n}{\\Delta y^2} \\right)\n$$\n其中 $\\sigma_x = \\text{sgn}(U)$ 且 $\\sigma_y = \\text{sgn}(V)$。为了进行稳定性分析，我们使用其绝对值 $|U|$ 和 $|V|$。该方程可以写为：\n$$\n\\phi_{j,l}^{n+1} = \\phi_{j,l}^{n} - \\Delta t \\left( \\frac{|U|}{\\Delta x}(\\phi_{j,l}^n - \\phi_{j-\\sigma_x,l}^n) + \\frac{|V|}{\\Delta y}(\\phi_{j,l}^n - \\phi_{j,l-\\sigma_y}^n) \\right) + \\Delta t \\nu [\\nabla_h^2 \\phi^n]_{j,l}\n$$\n我们代入单个傅里叶模态 $\\phi_{j,l}^n = \\hat{\\phi}^n(\\theta_x, \\theta_y) e^{i(j\\theta_x + l\\theta_y)}$，其中 $\\theta_x = k_x\\Delta x$ 和 $\\theta_y = k_y\\Delta y$ 是无量纲波数。放大因子 $G = \\hat{\\phi}^{n+1}/\\hat{\\phi}^n$ 可求得为：\n$$\nG(\\theta_x, \\theta_y) = 1 - \\frac{|U|\\Delta t}{\\Delta x}(1-e^{-i\\sigma_x\\theta_x}) - \\frac{|V|\\Delta t}{\\Delta y}(1-e^{-i\\sigma_y\\theta_y}) + \\frac{\\nu\\Delta t}{\\Delta x^2}(2\\cos\\theta_x-2) + \\frac{\\nu\\Delta t}{\\Delta y^2}(2\\cos\\theta_y-2)\n$$\n令 $C_x = \\frac{|U|\\Delta t}{\\Delta x}$，$C_y = \\frac{|V|\\Delta t}{\\Delta y}$ 为库朗数，令 $D_x = \\frac{\\nu\\Delta t}{\\Delta x^2}$，$D_y = \\frac{\\nu\\Delta t}{\\Delta y^2}$ 为扩散数。\n$$\nG = 1 - C_x(1-\\cos\\theta_x) - C_y(1-\\cos\\theta_y) - 2D_x(1-\\cos\\theta_x) - 2D_y(1-\\cos\\theta_y) - i(C_x \\sigma_x \\sin\\theta_x + C_y \\sigma_y \\sin\\theta_y)\n$$\n稳定性要求对于所有 $\\theta_x, \\theta_y \\in [-\\pi, \\pi]$ 都有 $|G| \\le 1$。最严格的条件通常出现在最高频模态，即 $\\theta_x \\to \\pm\\pi$ 且 $\\theta_y \\to \\pm\\pi$。我们考察 $\\theta_x=\\pi, \\theta_y=\\pi$ 的情况。此时，$\\sin\\theta_x = \\sin\\theta_y = 0$ 且 $1-\\cos\\theta_x = 1-\\cos\\theta_y = 2$。\n放大因子变为纯实数：\n$$\nG(\\pi,\\pi) = 1 - 2C_x - 2C_y - 4D_x - 4D_y = 1 - 2(C_x+C_y+2D_x+2D_y)\n$$\n稳定性条件 $|G| \\le 1$ 变为 $-1 \\le G \\le 1$。\n$G \\le 1$ 总是成立，因为所有项 $C_x, C_y, D_x, D_y$ 都是非负的。\n条件 $G \\ge -1$ 要求：\n$$\n1 - 2(C_x+C_y+2D_x+2D_y) \\ge -1\n$$\n$$\n2 \\ge 2(C_x+C_y+2D_x+2D_y)\n$$\n$$\n1 \\ge C_x+C_y+2D_x+2D_y\n$$\n代入 $C_x, C_y, D_x, D_y$ 的定义，并使用最大速度值 $U_{\\max}$ 和 $V_{\\max}$：\n$$\n1 \\ge \\frac{U_{\\max}\\Delta t}{\\Delta x} + \\frac{V_{\\max}\\Delta t}{\\Delta y} + \\frac{2\\nu\\Delta t}{\\Delta x^2} + \\frac{2\\nu\\Delta t}{\\Delta y^2}\n$$\n将 $\\Delta t$ 因子提出，我们得到稳定性约束：\n$$\n\\Delta t \\left( \\frac{U_{\\max}}{\\Delta x} + \\frac{V_{\\max}}{\\Delta y} + 2\\nu \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right) \\right) \\le 1\n$$\n这个从最不稳定模态推导出的条件，可以被证明是该格式对于所有波数 $L_2$-稳定的充分必要条件。\n当等式成立时，获得最大稳定时间步长 $\\Delta t_{\\max}$：\n$$\n\\Delta t_{\\max} = \\frac{1}{\\frac{U_{\\max}}{\\Delta x} + \\frac{V_{\\max}}{\\Delta y} + 2\\nu \\left(\\frac{1}{\\Delta x^2} + \\frac{1}{\\Delta y^2}\\right)}\n$$\n此公式用于计算每个测试用例的结果。如果分母为零（即 $U_{\\max}=V_{\\max}=\\nu=0$），则 $\\Delta t_{\\max}$ 为无穷大，因为平凡系统 $\\partial \\mathbf{u} / \\partial t = 0$ 是无条件稳定的。对于所有给定的测试用例，分母均为正。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the maximum stable time step for a 2D incompressible\n    Navier-Stokes solver using an explicit fractional-step method.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (delta_x, delta_y, U_max, V_max, nu)\n    test_cases = [\n        (0.01, 0.02, 1.0, 0.5, 1e-3),\n        (0.005, 0.005, 0.0, 0.0, 1e-4),\n        (0.1, 0.05, 2.0, 1.0, 0.0),\n        (0.01, 0.01, 0.3, 0.1, 1e-3),\n        (0.005, 0.005, 0.1, 0.1, 1e-2)\n    ]\n\n    results = []\n    for case in test_cases:\n        dx, dy, u_max, v_max, nu = case\n\n        # Numerator of the stability condition is 1. We compute the denominator.\n        \n        # Convective constraint term\n        # This corresponds to the CFL condition part.\n        conv_term = u_max / dx + v_max / dy\n\n        # Diffusive constraint term\n        # This corresponds to the explicit diffusion stability part.\n        diff_term = 0.0\n        if nu > 0:\n            diff_term = 2.0 * nu * (1.0 / dx**2 + 1.0 / dy**2)\n\n        # The overall stability constraint is the sum of the inverses of the\n        # time steps from each physical process.\n        denominator = conv_term + diff_term\n\n        # The maximum stable time step is the reciprocal of this sum.\n        if denominator == 0:\n            # This case occurs if U_max, V_max, and nu are all zero.\n            # The scheme is unconditionally stable, so dt_max is infinite.\n            dt_max = float('inf')\n        else:\n            dt_max = 1.0 / denominator\n        \n        results.append(dt_max)\n\n    # Final print statement in the exact required format.\n    # A comma-separated list of floating-point numbers in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2428893"}, {"introduction": "投影方法的核心是通过求解一个压力泊松方程（Pressure Poisson Equation, PPE）来强制速度场的无散性。在实际应用中，求解这个大型线性系统往往采用迭代法，其解的精确度直接影响质量守恒的效果 [@problem_id:2428935]。这个练习将让你亲手实现投影算法的关键步骤，并通过改变迭代次数，直观地观察压力求解的精度如何影响最终速度场的散度误差。", "problem": "考虑一个周期性方形区域内的二维不可压缩流投影。设区域为 $\\Omega = [0,1] \\times [0,1]$，在两个方向上都具有周期性边界条件。设 $\\rho > 0$ 表示常数密度，$\\nu \\ge 0$ 表示运动粘度。设 $N \\in \\mathbb{N}$ 为每个方向上均匀分布的网格点数，网格间距为 $h = 1/N$。使用同位网格、单元中心离散化方法，其离散算子由具有周期性边界处理的二阶中心差分构建：\n\n- 离散梯度 $\\nabla_h$ 和散度 $\\nabla_h \\cdot$ 逐分量地使用步长为 $h$ 的中心差分进行计算。\n- 离散拉普拉斯算子 $\\Delta_h$ 是标准的五点模板\n$$\n(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4 \\phi_{i,j}}{h^2},\n$$\n其中 $(i \\pm 1)$ 和 $(j \\pm 1)$ 使用周期性索引。\n\n从在单元中心 $x_j = (j + \\tfrac{1}{2}) h$，$y_i = (i + \\tfrac{1}{2}) h$ 采样的离散流函数 $\\psi$ 定义初始离散速度场 $u^0 = (u^0_x, u^0_y)$：\n$$\nu^0_x = \\frac{\\partial \\psi}{\\partial y}\\Big|_h, \\quad u^0_y = -\\frac{\\partial \\psi}{\\partial x}\\Big|_h,\n$$\n其中 $\\psi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$，而 $\\tfrac{\\partial}{\\partial x}\\big|_h$ 和 $\\tfrac{\\partial}{\\partial y}\\big|_h$ 是中心差分算子。这种构造方法产生一个满足 $\\nabla_h \\cdot u^0 = 0$ 的离散场。\n\n设 $\\phi(x,y) = \\sin(2\\pi x)\\sin(2\\pi y)$ 是在相同网格点上采样的离散标量势，并定义离散强迫项 $f = (f_x,f_y)$ 为离散梯度 $f = \\alpha \\nabla_h \\phi$，其中 $\\alpha \\in \\mathbb{R}$ 为标量振幅。考虑一个时间步长为 $\\Delta t > 0$ 的单步显式分数步法：\n- 预测速度\n$$\nu^\\star = u^0 + \\Delta t\\left(\\nu\\, \\Delta_h u^0 + f\\right).\n$$\n- 通过离散泊松方程更新压力\n$$\n\\Delta_h p^{1} = \\frac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star,\n$$\n满足周期性边界条件，并附加约束条件：$p^{1}$ 在网格上的离散平均值为零。\n- 速度修正\n$$\nu^{1} = u^\\star - \\frac{\\Delta t}{\\rho}\\, \\nabla_h p^{1}.\n$$\n\n投影后质量守恒的质量通过修正后速度散度的离散 $L^2$ 范数来量化，\n$$\nE = \\left( h^2 \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[\\left(\\nabla_h \\cdot u^{1}\\right)_{i,j}\\right]^2 \\right)^{1/2}.\n$$\n\n在实践中，$p^{1}$ 是通过对线性系统 $\\Delta_h p^{1} = \\tfrac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$ 应用迭代求解器来计算的。在此任务中，必须通过精确应用 $k \\in \\mathbb{N}$ 次以下任一方法的扫描来近似 $p^{1}$：\n- 逐点 Jacobi 迭代，\n- 或逐点 Gauss–Seidel 迭代，\n用于具有周期性邻点的五点拉普拉斯算子，从零初始猜测开始，并在每次扫描后对 $p^{1}$ 强制执行零均值。\n\n你的程序必须：\n- 实现上述定义的具有周期性边界条件的算子 $\\nabla_h$、$\\nabla_h \\cdot$ 和 $\\Delta_h$。\n- 如上所述，从 $\\psi$ 构建 $u^0$，从 $\\phi$ 构建 $f$。\n- 形成 $u^\\star$，构建右侧项 $\\tfrac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$，并使用指定迭代方法精确进行 $k$ 次迭代计算 $p^1$，每次扫描后强制执行零均值。\n- 计算 $u^{1}$ 和质量守恒误差 $E$。\n\n使用以下测试套件，其中每个案例由一个元组 $(N, \\Delta t, \\nu, \\rho, \\alpha, k, \\text{solver})$ 指定：\n- 案例 1：$(N, \\Delta t, \\nu, \\rho, \\alpha, k, \\text{solver}) = (32, 0.01, 0.01, 1.0, 1.0, 1, \\text{\"jacobi\"})$。\n- 案例 2：$(32, 0.01, 0.01, 1.0, 1.0, 20, \\text{\"jacobi\"})$。\n- 案例 3：$(32, 0.01, 0.01, 1.0, 1.0, 2000, \\text{\"jacobi\"})$。\n- 案例 4：$(32, 0.01, 0.01, 1.0, 1.0, 20, \\text{\"gauss-seidel\"})$。\n- 案例 5：$(8, 0.01, 0.01, 1.0, 1.0, 100, \\text{\"jacobi\"})$。\n\n所有物理量和数值量均为无量纲。你的程序的最终输出必须是单行，包含一个 Python 风格的列表，其中有 5 个浮点数结果 $E$，按顺序对应上述案例，每个结果都采用科学记数法格式化，并精确到六位有效数字。例如，所需格式为 $[a,b,c,d,e]$，其中 $a,b,c,d,e$ 中的每一个都以 $\\texttt{1.234567e-03}$ 的形式打印。\n\n你的程序必须以这种格式精确产生一行输出，并且不得读取任何输入。", "solution": "问题陈述经评估有效。它描述了一个定义明确的计算流体动力学数值实验，该实验基于不可压缩流分数步法的既定原理。所有参数、算子和过程的规定均无歧义或矛盾，使其具有科学依据、适定性和客观性。任务是实现此数值方案，并为一组给定的测试案例计算特定的误差度量。\n\n解决方案按以下结构化步骤实现：\n\n1.  **离散化与离散算子**\n    连续区域 $\\Omega = [0,1] \\times [0,1]$ 被离散化为 $N \\times N$ 单元的均匀网格。网格间距为 $h = 1/N$。所有标量场和矢量场都在单元中心定义，其坐标为 $(x_j, y_i) = ((j + 0.5)h, (i + 0.5)h)$，其中 $i,j \\in \\{0, \\dots, N-1\\}$。\n\n    具有周期性边界条件的离散微分算子实现如下：\n    -   **梯度 ($\\nabla_h$)**：对于标量场 $\\phi$，梯度 $(\\nabla_h \\phi)_{i,j} = ((\\partial_x \\phi)_h, (\\partial_y \\phi)_h)_{i,j}$ 使用二阶中心差分计算：\n        $$(\\partial_x \\phi)_h = \\frac{\\phi_{i,j+1} - \\phi_{i,j-1}}{2h}, \\quad (\\partial_y \\phi)_h = \\frac{\\phi_{i+1,j} - \\phi_{i-1,j}}{2h}$$\n    -   **散度 ($\\nabla_h \\cdot$)**：对于矢量场 $u = (u_x, u_y)$，散度 $(\\nabla_h \\cdot u)_{i,j}$ 为：\n        $$(\\nabla_h \\cdot u)_{i,j} = \\frac{(u_x)_{i,j+1} - (u_x)_{i,j-1}}{2h} + \\frac{(u_y)_{i+1,j} - (u_y)_{i-1,j}}{2h}$$\n    -   **拉普拉斯算子 ($\\Delta_h$)**：对于标量场 $\\phi$，拉普拉斯算子由标准的五点模板给出：\n        $$(\\Delta_h \\phi)_{i,j} = \\frac{\\phi_{i+1,j} + \\phi_{i-1,j} + \\phi_{i,j+1} + \\phi_{i,j-1} - 4\\phi_{i,j}}{h^2}$$\n    所有算子都使用周期性索引（例如，$\\phi_{N,j} = \\phi_{0,j}$，$\\phi_{i,-1} = \\phi_{i,N-1}$）。\n\n2.  **状态初始化**\n    -   从离散流函数 $\\psi = \\sin(2\\pi x)\\sin(2\\pi y)$ 构建初始速度场 $u^0$，以确保其离散无散度（$\\nabla_h \\cdot u^0 = 0$）。其分量定义为：\n        $$u^0_x = \\frac{\\partial \\psi}{\\partial y}\\Big|_h, \\quad u^0_y = -\\frac{\\partial \\psi}{\\partial x}\\Big|_h$$\n    -   强迫项 $f$ 定义为标量势 $\\phi = \\sin(2\\pi x)\\sin(2\\pi y)$ 的梯度，振幅为 $\\alpha$：\n        $$f = \\alpha \\nabla_h \\phi$$\n\n3.  **分数步法算法**\n    投影法的单个时间步包含三个主要部分：\n    -   **预测步**：通过显式欧拉步在时间上推进动量方程，计算出预测速度场 $u^\\star$。此步骤包含粘性项和强迫项，但忽略了未知的压力梯度项。\n        $$u^\\star = u^0 + \\Delta t\\left(\\nu\\, \\Delta_h u^0 + f\\right)$$\n        得到的场 $u^\\star$ 通常不是无散度的。\n\n    -   **投影步**：此步骤通过将 $u^\\star$ 投影到无散度场空间来强制执行不可压缩性约束。这是通过找到一个修正速度的类压力场 $p^1$ 来完成的。场 $p^1$ 是离散泊松方程的解：\n        $$\\Delta_h p^{1} = \\frac{\\rho}{\\Delta t}\\, \\nabla_h \\cdot u^\\star$$\n        该方程是通过对修正后的速度 $u^1 = u^\\star - \\frac{\\Delta t}{\\rho} \\nabla_h p^1$ 施加条件 $\\nabla_h \\cdot u^1 = 0$ 推导出来的。在周期性区域上，算子 $\\Delta_h$ 是奇异的。通过施加其离散空间平均值为零的约束，即 $\\sum_{i,j} p^1_{i,j} = 0$，可以获得 $p^1$ 的唯一解。\n\n        通过从初始猜测 $p^1=0$ 开始，使用以下方法之一精确进行 $k$ 次迭代，来近似求解 $p^1$ 的线性系统：\n        -   **逐点 Jacobi 迭代**：一种显式更新规则，其中下一次迭代 $p^{n+1}$ 在每个网格点的值仅取决于当前迭代 $p^n$ 的值。网格点 $(i,j)$ 的更新规则为：\n            $$p_{i,j}^{n+1} = \\frac{1}{4}\\left( p_{i+1,j}^n + p_{i-1,j}^n + p_{i,j+1}^n + p_{i,j-1}^n - h^2 (\\tfrac{\\rho}{\\Delta t} \\nabla_h \\cdot u^\\star)_{i,j} \\right)$$\n        -   **逐点 Gauss-Seidel 迭代**：一种隐式更新规则，其中每个网格点的计算立即使用当前迭代中最新的可用值。对于光栅扫描顺序，更新规则为：\n            $$p_{i,j}^{n+1} = \\frac{1}{4}\\left( p_{i-1,j}^{n+1} + p_{i,j-1}^{n+1} + p_{i+1,j}^n + p_{i,j+1}^n - h^2 (\\tfrac{\\rho}{\\Delta t} \\nabla_h \\cdot u^\\star)_{i,j} \\right)$$\n        每次迭代（扫描）后，通过从压力场中减去平均值来强制执行零均值约束。\n\n    -   **修正步**：通过使用计算出的压力 $p^1$ 的梯度来修正预测速度 $u^\\star$，从而获得该时间步的最终速度场 $u^1$：\n        $$u^{1} = u^\\star - \\frac{\\Delta t}{\\rho}\\, \\nabla_h p^{1}$$\n        根据构造，此场 $u^1$ 能更好地逼近无散度条件。\n\n4.  **误差量化**\n    质量守恒的质量通过最终速度场 $u^1$ 散度的离散 $L^2$ 范数来衡量。误差 $E$ 计算如下：\n    $$E = \\left( h^2 \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} \\left[\\left(\\nabla_h \\cdot u^{1}\\right)_{i,j}\\right]^2 \\right)^{1/2}$$\n    较小的 $E$ 值表示对不可压缩性约束的执行更为精确。所提供的程序实现了这个完整的算法，以计算每个测试用例的 $E$。", "answer": "```python\nimport numpy as np\n\ndef grad(phi, h):\n    \"\"\"Computes the 2D gradient of a scalar field using central differences.\"\"\"\n    dphi_dx = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * h)\n    dphi_dy = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * h)\n    return dphi_dx, dphi_dy\n\ndef div(u, h):\n    \"\"\"Computes the 2D divergence of a vector field using central differences.\"\"\"\n    ux, uy = u\n    dux_dx = (np.roll(ux, -1, axis=1) - np.roll(ux, 1, axis=1)) / (2 * h)\n    duy_dy = (np.roll(uy, -1, axis=0) - np.roll(uy, 1, axis=0)) / (2 * h)\n    return dux_dx + duy_dy\n\ndef laplace(phi, h):\n    \"\"\"Computes the 2D Laplacian of a scalar field using a five-point stencil.\"\"\"\n    return (np.roll(phi, 1, axis=0) + np.roll(phi, -1, axis=0) +\n            np.roll(phi, 1, axis=1) + np.roll(phi, -1, axis=1) - 4 * phi) / h**2\n\ndef jacobi_sweep(p, b, h):\n    \"\"\"Performs one sweep of the Jacobi iteration for the Poisson equation.\"\"\"\n    p_new = 0.25 * (np.roll(p, 1, axis=0) + np.roll(p, -1, axis=0) +\n                    np.roll(p, 1, axis=1) + np.roll(p, -1, axis=1) - h**2 * b)\n    return p_new\n\ndef gauss_seidel_sweep(p, b, h):\n    \"\"\"Performs one sweep of the Gauss-Seidel iteration using raster scan.\"\"\"\n    N = p.shape[0]\n    # This function modifies p in place\n    for i in range(N):\n        for j in range(N):\n            # Neighbors are accessed from the single array 'p'. For a raster scan,\n            # (i-1) and (j-1) elements have already been updated in this sweep.\n            neighbors = (p[(i - 1) % N, j] + p[(i + 1) % N, j] +\n                         p[i, (j - 1) % N] + p[i, (j + 1) % N])\n            p[i, j] = 0.25 * (neighbors - h**2 * b[i, j])\n    return p\n\ndef run_simulation(N, dt, nu, rho, alpha, k, solver_type):\n    \"\"\"\n    Executes one full fractional-step simulation and returns the divergence error E.\n    \"\"\"\n    # 1. Grid setup\n    h = 1.0 / N\n    x = (np.arange(N) + 0.5) * h\n    y = (np.arange(N) + 0.5) * h\n    # Use 'xy' indexing for standard matrix layout: array[i, j] -> (y_i, x_j)\n    xx, yy = np.meshgrid(x, y, indexing='xy')\n\n    # 2. Initial and Forcing Fields\n    psi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    grad_psi_x, grad_psi_y = grad(psi, h)\n    u0x = grad_psi_y\n    u0y = -grad_psi_x\n    u0 = (u0x, u0y)\n\n    phi = np.sin(2 * np.pi * xx) * np.sin(2 * np.pi * yy)\n    grad_phi_x, grad_phi_y = grad(phi, h)\n    fx = alpha * grad_phi_x\n    fy = alpha * grad_phi_y\n    f = (fx, fy)\n\n    # 3. Tentative Velocity (Prediction Step)\n    lap_u0x = laplace(u0x, h)\n    lap_u0y = laplace(u0y, h)\n    u_star_x = u0x + dt * (nu * lap_u0x + fx)\n    u_star_y = u0y + dt * (nu * lap_u0y + fy)\n    u_star = (u_star_x, u_star_y)\n\n    # 4. Pressure Poisson (Projection Step)\n    div_u_star = div(u_star, h)\n    poisson_rhs = (rho / dt) * div_u_star\n    \n    p1 = np.zeros((N, N))\n    if solver_type == \"jacobi\":\n        for _ in range(k):\n            p1 = jacobi_sweep(p1, poisson_rhs, h)\n            p1 -= np.mean(p1)  # Enforce zero mean\n    elif solver_type == \"gauss-seidel\":\n        for _ in range(k):\n            p1 = gauss_seidel_sweep(p1, poisson_rhs, h)\n            p1 -= np.mean(p1)  # Enforce zero mean\n            \n    # 5. Velocity Correction\n    grad_p1_x, grad_p1_y = grad(p1, h)\n    u1_x = u_star_x - (dt / rho) * grad_p1_x\n    u1_y = u_star_y - (dt / rho) * grad_p1_y\n    u1 = (u1_x, u1_y)\n\n    # 6. Error Calculation\n    div_u1 = div(u1, h)\n    error_E = np.sqrt(h**2 * np.sum(np.square(div_u1)))\n    \n    return error_E\n\ndef solve():\n    test_cases = [\n        # (N, Δt, ν, ρ, α, k, solver)\n        (32, 0.01, 0.01, 1.0, 1.0, 1, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 20, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 2000, \"jacobi\"),\n        (32, 0.01, 0.01, 1.0, 1.0, 20, \"gauss-seidel\"),\n        (8, 0.01, 0.01, 1.0, 1.0, 100, \"jacobi\"),\n    ]\n\n    results = []\n    for case in test_cases:\n        E = run_simulation(*case)\n        results.append(E)\n\n    formatted_results = [f\"{res:.6e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2428935"}, {"introduction": "掌握了投影方法的基本实现后，我们可以进一步探究如何评估和提升整个求解器的精度。本练习采用一个具有精确解的经典验证案例——泰勒-格林涡（Taylor-Green vortex），来检验你的求解器 [@problem_id:2428920]。通过比较不同阶数的时间积分格式（如二阶 Adams-Bashforth 和三阶 Runge-Kutta）所产生的误差，你将学会如何进行定量的算法验证与精度分析。", "problem": "考虑在周期性方形区域 $\\Omega = [0,2\\pi]\\times[0,2\\pi]$ 上的二维不可压缩 Navier–Stokes 方程，其运动粘度为 $\\nu$，密度为 $\\rho=1$：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u},\\quad \\nabla\\cdot \\boldsymbol{u} = 0,\n$$\n其中 $\\boldsymbol{u}(x,y,t) = (u(x,y,t),v(x,y,t))$ 是速度场，$p(x,y,t)$ 是运动压力。使用 Taylor–Green 涡作为时间 $t=0$ 时的初始条件：\n$$\nu(x,y,0) = U_0 \\sin(x)\\cos(y),\\quad v(x,y,0) = -U_0 \\cos(x)\\sin(y),\n$$\n在 $\\partial\\Omega$ 上具有周期性边界条件。对于所有 $t\\ge 0$，其精确解为\n$$\nu(x,y,t) = U_0 \\sin(x)\\cos(y)\\, e^{-2\\nu t},\\quad v(x,y,t) = -U_0 \\cos(x)\\sin(y)\\, e^{-2\\nu t},\n$$\n$$\np(x,y,t) = \\frac{U_0^2}{4}\\left(\\cos(2x)+\\cos(2y)\\right)e^{-4\\nu t} + C(t),\n$$\n对于某个空间上均匀的 $C(t)$。\n\n使用分数步（投影）压力-速度耦合方法对速度进行时间推进，该方法通过仅对对流-扩散算子进行积分来计算中间速度，然后通过压力修正来施加不可压缩性。具体来说，对于从 $t^n$ 到 $t^{n+1}=t^n+\\Delta t$ 的每个时间步，从以下方程计算中间速度 $\\boldsymbol{u}^\\star$：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} = -(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nu \\nabla^2 \\boldsymbol{u},\n$$\n对右端项使用以下时间离散化选项之一：\n- 选项 A（二阶 Adams–Bashforth，AB2）：一种二阶两步显式多步法。对于第一步，使用任何阶数至少为二的相容单步法来启动多步序列。\n- 选项 B（三阶 Runge–Kutta，RK3）：一种全局三阶的三级显式 Runge–Kutta 方法。\n\n获得 $\\boldsymbol{u}^\\star$ 后，通过求解满足以下方程的标量势 $\\phi$ 来施加不可压缩性：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t}\\nabla\\cdot \\boldsymbol{u}^\\star,\n$$\n然后设置\n$$\n\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi.\n$$\n假设边界条件为周期性，压力为零均值（将 $\\phi$ 的空间平均值设为零）。不需要物理单位；将所有量视为无量纲。\n\n对于以下所有测试，使用 $N=32$ 的均匀 $N\\times N$ 网格，区域 $\\Omega=[0,2\\pi]^2$，初始振幅 $U_0=1$，粘度 $\\nu=0.01$，最终时间 $T=0.2$。对于每个测试，计算在 $t=T$ 时速度的离散相对 $L^2$-误差：\n$$\nE = \\left(\\frac{\\sum_{i,j}\\left[(u_{i,j}-u^{\\text{exact}}_{i,j})^2+(v_{i,j}-v^{\\text{exact}}_{i,j})^2\\right]}{\\sum_{i,j}\\left[(u^{\\text{exact}}_{i,j})^2+(v^{\\text{exact}}_{i,j})^2\\right]}\\right)^{1/2},\n$$\n其中 $(u^{\\text{exact}},v^{\\text{exact}})$ 是 $t=T$ 时的 Taylor–Green 精确解。\n\n测试组参数（每个测试是一个指定平流步的时间离散化方法和时间步长的配对）：\n1. 方法 AB2, $\\Delta t = 0.01$。\n2. 方法 RK3, $\\Delta t = 0.01$。\n3. 方法 AB2, $\\Delta t = 0.005$。\n4. 方法 RK3, $\\Delta t = 0.005$。\n5. 方法 AB2, $\\Delta t = 0.0025$。\n6. 方法 RK3, $\\Delta t = 0.0025$。\n\n您的程序必须计算每个测试的相对误差 $E$，并生成一行输出，其中包含用方括号括起来的六个结果的逗号分隔列表（例如，$[e_1,e_2,e_3,e_4,e_5,e_6]$）。输出必须是实值浮点数。不应打印任何其他文本。", "solution": "所提出的问题是一个适定的、用于二维不可compressi Navier-Stokes 方程数值求解器的标准验证案例。所有必需的物理参数、初始条件、边界条件和数值规格都已提供。该问题在科学上是合理的，基于流体动力学的基本方程和已有的数值方法。因此，我将继续提供完整的解决方案。\n\n问题的核心是求解 Navier-Stokes 方程：\n$$\n\\frac{\\partial \\boldsymbol{u}}{\\partial t} + (\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} = -\\nabla p + \\nu \\nabla^2 \\boldsymbol{u}\n$$\n$$\n\\nabla\\cdot \\boldsymbol{u} = 0\n$$\n在一个二维周期性区域 $\\Omega=[0,2\\pi]^2$ 上。周期性边界条件使得使用傅里叶谱方法进行空间离散化非常有利，因为它提供了高精度和高计算效率。\n\n**空间离散化：伪谱法**\n\n我们使用一个 $N \\times N$（其中 $N=32$）的均匀网格来离散化区域 $\\Omega$。网格点为 $(x_j, y_l) = (j h, l h)$，其中 $j, l \\in \\{0, 1, \\dots, N-1\\}$，网格间距为 $h = 2\\pi/N$。此网格上的函数 $f(x,y)$ 由其值 $f_{j,l} = f(x_j, y_l)$ 表示。\n\n空间导数在傅里叶空间中计算。二维离散傅里叶变换 (DFT) 及其逆变换 (IDFT) 用于在物理空间表示和谱空间表示之间切换。设 $\\hat{f}(k_x, k_y)$ 为 $f(x,y)$ 的 DFT。与网格对应的波数是经过适当缩放的 $k_x, k_y \\in \\{0, 1, \\dots, N-1\\}$。对于长度为 $L=2\\pi$ 的区域，整数波数为 $m, n \\in \\{-N/2, \\dots, N/2-1\\}$。空间导数算子在傅里葉空間中是对角的：\n$$\n\\frac{\\widehat{\\partial f}}{\\partial x} = i k_x \\hat{f}, \\quad \\frac{\\widehat{\\partial f}}{\\partial y} = i k_y \\hat{f}\n$$\n类似地，拉普拉斯算子变为：\n$$\n\\widehat{\\nabla^2 f} = -(k_x^2 + k_y^2) \\hat{f} = -| \\boldsymbol{k} |^2 \\hat{f}\n$$\n为了计算导数，我们执行一次正向 FFT，乘以适当的波数因子（例如，$i k_x$），然后执行一次逆向 IFFT。非线性平流项 $(\\boldsymbol{u} \\cdot \\nabla) \\boldsymbol{u}$ 使用伪谱法计算：在傅里叶空间中计算导数，变换回物理空间，相乘，然后将结果变换回傅里叶空间以进行时间积分。这避免了纯谱方法所需的计算成本高昂的卷积和。\n\n**时间离散化：分数步投影法**\n\n通过不可压缩约束 $\\nabla \\cdot \\boldsymbol{u} = 0$ 实现的速度 $\\boldsymbol{u}$ 和压力 $p$ 之间的耦合由分数步投影法处理。从 $t^n$到 $t^{n+1} = t^n + \\Delta t$ 的每个时间步分为两个阶段。\n\n**阶段 1：平流-扩散步**\n\n首先，通过推进不含压力梯度项的动量方程来计算中间速度场 $\\boldsymbol{u}^\\star$：\n$$\n\\frac{\\boldsymbol{u}^\\star - \\boldsymbol{u}^n}{\\Delta t} \\approx -(\\boldsymbol{u}\\cdot\\nabla)\\boldsymbol{u} + \\nu \\nabla^2 \\boldsymbol{u} \\equiv \\boldsymbol{R}(\\boldsymbol{u})\n$$\n右端项 $\\boldsymbol{R}(\\boldsymbol{u})$ 包含非线性平流项和粘性扩散项。我们按照指定使用两种显式方法对此常微分方程进行离散化。\n\n对于一个一般的常微分方程 $\\frac{d\\boldsymbol{y}}{dt} = f(t, \\boldsymbol{y})$：\n\n1.  **三阶 Runge-Kutta (RK3)：**使用一种三级三阶显式方法。一个常见的选择，也是此处实现的选择，是经典的 Kutta 三阶格式：\n    $$\n    \\boldsymbol{k}_1 = \\boldsymbol{R}(\\boldsymbol{u}^n)\n    $$\n    $$\n    \\boldsymbol{k}_2 = \\boldsymbol{R}(\\boldsymbol{u}^n + \\frac{\\Delta t}{2}\\boldsymbol{k}_1)\n    $$\n    $$\n    \\boldsymbol{k}_3 = \\boldsymbol{R}(\\boldsymbol{u}^n - \\Delta t \\boldsymbol{k}_1 + 2\\Delta t \\boldsymbol{k}_2)\n    $$\n    $$\n    \\boldsymbol{u}^\\star = \\boldsymbol{u}^n + \\frac{\\Delta t}{6}(\\boldsymbol{k}_1 + 4\\boldsymbol{k}_2 + \\boldsymbol{k}_3)\n    $$\n\n2.  **二阶 Adams-Bashforth (AB2)：**这是一种两步线性多步法。\n    $$\n    \\boldsymbol{u}^\\star = \\boldsymbol{u}^n + \\Delta t \\left( \\frac{3}{2}\\boldsymbol{R}(\\boldsymbol{u}^n) - \\frac{1}{2}\\boldsymbol{R}(\\boldsymbol{u}^{n-1}) \\right)\n    $$\n    此方法不是自启动的；它需要前两个时间层 $t^n$ 和 $t^{n-1}$ 的解。对于第一个时间步（从 $t^0$ 到 $t^1$），我们使用 RK3 方法生成 $\\boldsymbol{u}^1$，这与问题要求使用一个阶数至少为二的启动方法是一致的。\n\n**阶段 2：投影步**\n\n中间速度 $\\boldsymbol{u}^\\star$ 通常不满足不可压缩约束。第二阶段将 $\\boldsymbol{u}^\\star$ 投影到无散矢量场空间上，以获得最终速度 $\\boldsymbol{u}^{n+1}$。Hodge 分解定理保证了 $\\boldsymbol{u}^\\star$ 可以唯一地分解为一个无散部分和一个标量势的梯度。\n$$\n\\boldsymbol{u}^\\star = \\boldsymbol{u}^{n+1} + \\nabla \\phi'\n$$\n其中 $\\nabla \\cdot \\boldsymbol{u}^{n+1} = 0$。对此方程求散度可得：\n$$\n\\nabla \\cdot \\boldsymbol{u}^\\star = \\nabla^2 \\phi'\n$$\n问题将速度更新定义为 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla \\phi$，这意味着 $\\phi' = \\Delta t \\phi$。将其代入泊松方程可得：\n$$\n\\nabla^2 \\phi = \\frac{1}{\\Delta t} \\nabla \\cdot \\boldsymbol{u}^\\star\n$$\n这个关于势 $\\phi$ 的泊松方程在傅里叶空间中可以高效求解。对该方程进行变换可得：\n$$\n-|\\boldsymbol{k}|^2 \\hat{\\phi} = \\frac{1}{\\Delta t} \\widehat{\\nabla \\cdot \\boldsymbol{u}^\\star} = \\frac{1}{\\Delta t} (i k_x \\hat{u}^\\star + i k_y \\hat{v}^\\star)\n$$\n势的傅里叶系数解为：\n$$\n\\hat{\\phi} = - \\frac{i}{|\\boldsymbol{k}|^2 \\Delta t} (k_x \\hat{u}^\\star + k_y \\hat{v}^\\star)\n$$\n对于零波数模式 ($k_x = k_y = 0$)， $|\\boldsymbol{k}|^2=0$。问题指定了零均值压力，这对应于零均值势，因此我们设置 $\\hat{\\phi}(0,0)=0$。对于所有其他模式，$|\\boldsymbol{k}|^2 > 0$。\n\n最终速度更新 $\\boldsymbol{u}^{n+1} = \\boldsymbol{u}^\\star - \\Delta t \\nabla\\phi$ 也在傅里葉空間中执行以优化性能。更新的傅里葉表示为：\n$$\n\\hat{\\boldsymbol{u}}^{n+1} = \\hat{\\boldsymbol{u}}^\\star - \\Delta t (i\\boldsymbol{k}) \\hat{\\phi}\n$$\n代入 $\\hat{\\phi}$ 的表达式，我们直接得到投影操作：\n$$\n\\hat{\\boldsymbol{u}}^{n+1} = \\hat{\\boldsymbol{u}}^\\star - \\frac{\\boldsymbol{k}(\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}^\\star)}{|\\boldsymbol{k}|^2}\n$$\n此操作将傅里葉变换后的中间速度矢量 $\\hat{\\boldsymbol{u}}^\\star$ 投影到垂直于波数矢量 $\\boldsymbol{k}$ 的平面上，从而强制执行无散条件 $\\boldsymbol{k} \\cdot \\hat{\\boldsymbol{u}}^{n+1}=0$。在此投影之后，通过一次逆向 FFT 即可在物理空间中得到最终的无散速度场 $\\boldsymbol{u}^{n+1}$。\n\n**算法摘要**\n\n1.  使用 $t=0$ 时的 Taylor-Green 涡解来初始化速度场 $\\boldsymbol{u}^0(x,y)$。\n2.  在傅里叶空间中设置计算网格、波数 $\\boldsymbol{k}$ 和拉普拉斯算子的逆 $1/|\\boldsymbol{k}|^2$。\n3.  从 $t=0$到 $T$ 以步长 $\\Delta t$ 进行时间步循环：\n    a. 计算平流-扩散项 $\\boldsymbol{R}(\\boldsymbol{u}^n)$，如果使用 AB2，则检索 $\\boldsymbol{R}(\\boldsymbol{u}^{n-1})$。\n    b. 使用 RK3 或 AB2 格式进行时间推进，以找到中间速度 $\\boldsymbol{u}^\\star$。\n    c. 将 $\\boldsymbol{u}^\\star$ 变换到傅里叶空间以得到 $\\hat{\\boldsymbol{u}}^\\star$。\n    d. 在傅里叶空间中应用投影算子以施加不可压缩性，得到 $\\hat{\\boldsymbol{u}}^{n+1}$。\n    e. 将 $\\hat{\\boldsymbol{u}}^{n+1}$ 变换回物理空间以得到 $\\boldsymbol{u}^{n+1}$。\n4.  在最终时间 $t=T$ 时，计算网格上的精确解。\n5.  计算数值解和精确解之间的离散相对 $L^2$-误差 $E$。\n6.  对所有指定的测试用例重复上述过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 2D incompressible Navier-Stokes equations for the Taylor-Green\n    vortex problem using a fractional-step projection method with a\n    pseudospectral spatial discretization.\n    \"\"\"\n\n    def run_simulation(method, dt, N, U0, nu, T):\n        \"\"\"\n        Runs a single simulation for a given set of parameters.\n\n        Args:\n            method (str): Time integration method, 'AB2' or 'RK3'.\n            dt (float): Time step size.\n            N (int): Grid resolution (N x N).\n            U0 (float): Initial velocity amplitude.\n            nu (float): Kinematic viscosity.\n            T (float): Final time.\n\n        Returns:\n            float: The relative L2 error at the final time.\n        \"\"\"\n        # Grid and wavenumbers\n        L = 2 * np.pi\n        h = L / N\n        x = np.arange(N) * h\n        X, Y = np.meshgrid(x, x, indexing='ij')\n\n        k_ = np.fft.fftfreq(N) * N\n        Kx, Ky = np.meshgrid(k_, k_, indexing='ij')\n        K2 = Kx**2 + Ky**2\n        \n        # Precompute inverse Laplacian for projection step\n        K2_inv = np.zeros_like(K2)\n        K2_inv[K2 > 0] = 1.0 / K2[K2 > 0]\n\n        # Initial condition\n        u = U0 * np.sin(X) * np.cos(Y)\n        v = -U0 * np.cos(X) * np.sin(Y)\n\n        def compute_rhs(u_field, v_field):\n            \"\"\"Computes the advection-diffusion term R(u).\"\"\"\n            u_hat = np.fft.fft2(u_field)\n            v_hat = np.fft.fft2(v_field)\n\n            # Derivatives in Fourier space\n            dudx_hat = 1j * Kx * u_hat\n            dudy_hat = 1j * Ky * u_hat\n            dvdx_hat = 1j * Kx * v_hat\n            dvdy_hat = 1j * Ky * v_hat\n\n            # Transform derivatives to physical space\n            dudx = np.fft.ifft2(dudx_hat).real\n            dudy = np.fft.ifft2(dudy_hat).real\n            dvdx = np.fft.ifft2(dvdx_hat).real\n            dvdy = np.fft.ifft2(dvdy_hat).real\n\n            # Nonlinear advection term\n            conv_u = u_field * dudx + v_field * dudy\n            conv_v = u_field * dvdx + v_field * dvdy\n\n            # Viscous diffusion term\n            lap_u = np.fft.ifft2(-K2 * u_hat).real\n            lap_v = np.fft.ifft2(-K2 * v_hat).real\n            \n            # Combine terms for RHS\n            rhs_u = -conv_u + nu * lap_u\n            rhs_v = -conv_v + nu * lap_v\n            \n            return rhs_u, rhs_v\n\n        def project(u_star, v_star):\n            \"\"\"Projects the intermediate velocity onto a divergence-free field.\"\"\"\n            u_star_hat = np.fft.fft2(u_star)\n            v_star_hat = np.fft.fft2(v_star)\n            \n            # Enforce divergence-free condition in Fourier space\n            k_dot_u_star = Kx * u_star_hat + Ky * v_star_hat\n            proj_factor = k_dot_u_star * K2_inv\n            \n            u_next_hat = u_star_hat - Kx * proj_factor\n            v_next_hat = v_star_hat - Ky * proj_factor\n            \n            u_next = np.fft.ifft2(u_next_hat).real\n            v_next = np.fft.ifft2(v_next_hat).real\n            \n            return u_next, v_next\n\n        num_steps = int(np.ceil(T / dt))\n        t = 0.0\n        \n        # Time-stepping loop\n        if method == 'AB2':\n            # Startup step using RK3\n            k1_u, k1_v = compute_rhs(u, v)\n            \n            u_tmp = u + 0.5 * dt * k1_u\n            v_tmp = v + 0.5 * dt * k1_v\n            k2_u, k2_v = compute_rhs(u_tmp, v_tmp)\n\n            u_tmp2 = u - dt * k1_u + 2.0 * dt * k2_u\n            v_tmp2 = v - dt * k1_v + 2.0 * dt * k2_v\n            k3_u, k3_v = compute_rhs(u_tmp2, v_tmp2)\n\n            u_star = u + (dt / 6.0) * (k1_u + 4.0 * k2_u + k3_u)\n            v_star = v + (dt / 6.0) * (k1_v + 4.0 * k2_v + k3_v)\n\n            u, v = project(u_star, v_star)\n            t += dt\n            \n            rhs_u_prev, rhs_v_prev = k1_u, k1_v\n\n            for _ in range(1, num_steps):\n                rhs_u_curr, rhs_v_curr = compute_rhs(u, v)\n                u_star = u + dt * (1.5 * rhs_u_curr - 0.5 * rhs_u_prev)\n                v_star = v + dt * (1.5 * rhs_v_curr - 0.5 * rhs_v_prev)\n                \n                u, v = project(u_star, v_star)\n                rhs_u_prev, rhs_v_prev = rhs_u_curr, rhs_v_curr\n                t += dt\n\n        elif method == 'RK3':\n            for _ in range(num_steps):\n                k1_u, k1_v = compute_rhs(u, v)\n                \n                u_tmp = u + 0.5 * dt * k1_u\n                v_tmp = v + 0.5 * dt * k1_v\n                k2_u, k2_v = compute_rhs(u_tmp, v_tmp)\n\n                u_tmp2 = u - dt * k1_u + 2.0 * dt * k2_u\n                v_tmp2 = v - dt * k1_v + 2.0 * dt * k2_v\n                k3_u, k3_v = compute_rhs(u_tmp2, v_tmp2)\n\n                u_star = u + (dt / 6.0) * (k1_u + 4.0 * k2_u + k3_u)\n                v_star = v + (dt / 6.0) * (k1_v + 4.0 * k2_v + k3_v)\n\n                u, v = project(u_star, v_star)\n                t += dt\n\n        # Final time might not be exactly T, but problem seems to imply fixed steps\n        final_time = num_steps * dt\n\n        # Exact solution at final time T\n        decay = np.exp(-2.0 * nu * final_time)\n        u_exact = U0 * np.sin(X) * np.cos(Y) * decay\n        v_exact = -U0 * np.cos(X) * np.sin(Y) * decay\n\n        # Compute relative L2 error\n        error_num = np.sum((u - u_exact)**2 + (v - v_exact)**2)\n        error_den = np.sum(u_exact**2 + v_exact**2)\n        \n        return np.sqrt(error_num / error_den)\n\n    # Test suite parameters\n    N = 32\n    U0 = 1.0\n    nu = 0.01\n    T = 0.2\n\n    test_cases = [\n        ('AB2', 0.01),\n        ('RK3', 0.01),\n        ('AB2', 0.005),\n        ('RK3', 0.005),\n        ('AB2', 0.0025),\n        ('RK3', 0.0025),\n    ]\n\n    results = []\n    for method, dt in test_cases:\n        error = run_simulation(method, dt, N, U0, nu, T)\n        results.append(error)\n\n    # Print results in the specified format\n    print(f\"[{','.join([f'{r:.6e}' for r in results])}]\")\n\nsolve()\n```", "id": "2428920"}]}