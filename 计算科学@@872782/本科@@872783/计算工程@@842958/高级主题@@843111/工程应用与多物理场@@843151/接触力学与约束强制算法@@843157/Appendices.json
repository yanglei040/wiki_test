{"hands_on_practices": [{"introduction": "本节的实践旨在通过一个简单直观的例子来介绍约束强制的核心思想。我们将不从复杂的接触问题开始，而是从一个更易于理解的驱动器限制问题入手。这个练习 [@problem_id:2380886] 为约束强制的基本逻辑提供了一个平缓的入门。通过对一个有扭矩限制的马达进行建模，你将学习到“计算并钳位”（calculate-and-clamp）这一模式，这是更复杂接触算法中投影操作的一种简化形式。", "problem": "一个单自由度 (SDOF) 电机驱动的旋转关节，其绕轴的转动惯量为 $I$，由电机扭矩驱动，并受到一个外部扭矩的作用。由于执行器的限制，电机扭矩的大小被一个最大允许值 $\\tau_{\\max}$ 所界定。目标是在一个时长为 $h$ 的单时间步内，使用一种基于原则的约束强制方法，在将关节驱动至指定目标角速度 $\\omega^{\\star}$ 的同时，强制执行此边界。物理单位如下：惯量单位为 $\\mathrm{kg \\cdot m^2}$，扭矩单位为 $\\mathrm{N \\cdot m}$，角速度单位为 $\\mathrm{rad/s}$，时间单位为 $\\mathrm{s}$。所有角度和角速度必须分别以弧度和 $\\mathrm{rad/s}$ 为单位处理。\n\n推导过程应基于牛顿第二旋转定律和标准的时间步进思想。具体来说，使用基本定律 $I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$，其中 $\\tau_{\\mathrm{ext}}$ 是外部扭矩，$\\tau_{\\mathrm{motor}}$ 是电机扭矩，并对时长为 $h$ 的一个时间步内的角速度进行一致的离散更新。将电机行为视为一个基于约束的速度伺服，试图在时间步结束时强制执行速度级条件 $\\omega_{k+1} \\approx \\omega^{\\star}$，其中电机扭矩表示为一个决策变量，必须服从箱式约束 $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$。将其与物理上合理的投影或拉格朗日乘子解释联系起来，但不要假设任何预先推导的伺服或投影公式；相反，应从离散动力学和速度级目标中推导出扭矩决策的适当表达式。\n\n实现一个程序，针对每个提供的测试用例，计算在遵守边界条件的情况下施加的电机扭矩，并使用离散动力学计算得到的下一步角速度 $\\omega_{k+1}$。最终程序必须仅输出得到的下一步角速度，每个测试用例一个，聚合成一个单行列表，形式为用逗号分隔并由方括号括起的列表。每个结果必须四舍五入到六位小数，并以 $\\mathrm{rad/s}$ 表示。\n\n用于覆盖典型、边界和边缘条件的测试套件：\n- 案例 1 (在存在非零外部扭矩情况下的非饱和伺服跟踪)：$I = 1.5 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\ \\mathrm{s}$，$\\omega_k = 1.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 1.02 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 5.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.5 \\ \\mathrm{N \\cdot m}$。\n- 案例 2 (强正向饱和)：$I = 0.5 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.01 \\ \\mathrm{s}$，$\\omega_k = 0.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 10.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 2.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$。\n- 案例 3 (抵抗外部扭矩的强负向饱和)：$I = 1.2 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\ \\mathrm{s}$，$\\omega_k = 5.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = -5.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 1.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.2 \\ \\mathrm{N \\cdot m}$。\n- 案例 4 (零电机能力，仅有外部扭矩)：$I = 1.0 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.05 \\ \\mathrm{s}$，$\\omega_k = 2.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 0.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 0.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = -0.5 \\ \\mathrm{N \\cdot m}$。\n- 案例 5 (边界相等，即边界值恰好足够)：$I = 2.0 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.10 \\ \\mathrm{s}$，$\\omega_k = 1.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 1.50 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 10.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$。\n\n您的程序必须：\n- 对每个案例，使用遵守 $-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$ 的 principled constraint enforcement 方法计算下一步的角速度（单位为 $\\mathrm{rad/s}$）。\n- 将五个下一步的角速度汇总成一个列表。\n- 精确打印一行，包含该列表，格式为 $[\\text{v}_1,\\text{v}_2,\\text{v}_3,\\text{v}_4,\\text{v}_5]$，其中每个 $\\text{v}_i$ 四舍五入到六位小数，单位为 $\\mathrm{rad/s}$。", "solution": "该问题已经过验证。\n\n**步骤 1：提取已知条件**\n- 控制微分方程：$I \\, \\dot{\\omega} = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}$\n- 转动惯量：$I$\n- 时间步长：$h$\n- 步骤 $k$ 时的角速度：$\\omega_k$\n- 目标角速度：$\\omega^{\\star}$\n- 最大电机扭矩大小：$\\tau_{\\max}$\n- 外部扭矩：$\\tau_{\\mathrm{ext}}$\n- 电机扭矩约束：$-\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max}$\n- 控制目标：实现 $\\omega_{k+1} \\approx \\omega^{\\star}$\n- 测试案例：\n    1. $I = 1.5 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\ \\mathrm{s}$，$\\omega_k = 1.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 1.02 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 5.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.5 \\ \\mathrm{N \\cdot m}$。\n    2. $I = 0.5 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.01 \\ \\mathrm{s}$，$\\omega_k = 0.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 10.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 2.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$。\n    3. $I = 1.2 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.02 \\ \\mathrm{s}$，$\\omega_k = 5.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = -5.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 1.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.2 \\ \\mathrm{N \\cdot m}$。\n    4. $I = 1.0 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.05 \\ \\mathrm{s}$，$\\omega_k = 2.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 0.00 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 0.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = -0.5 \\ \\mathrm{N \\cdot m}$。\n    5. $I = 2.0 \\ \\mathrm{kg \\cdot m^2}$，$h = 0.10 \\ \\mathrm{s}$，$\\omega_k = 1.00 \\ \\mathrm{rad/s}$，$\\omega^{\\star} = 1.50 \\ \\mathrm{rad/s}$，$\\tau_{\\max} = 10.0 \\ \\mathrm{N \\cdot m}$，$\\tau_{\\mathrm{ext}} = 0.0 \\ \\mathrm{N \\cdot m}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题基于牛顿第二旋转定律，这是力学的一个基本原理。离散时间步进和执行器饱和的使用在计算动力学和控制学中是标准做法。其物理原理是可靠的。\n- **适定性：** 问题定义清晰，为每个案例提供了所有必需的参数。目标明确，可以导向一个唯一的解。\n- **客观性：** 问题以精确的、定量的术语陈述，没有主观或推测性内容。\n- **结论：** 问题具有科学依据、适定、客观且完整。因此，该问题是有效的。\n\n**步骤 3：裁定与行动**\n该问题有效。将推导并提供解答。\n\n推导从旋转动力学的基本原理——牛顿第二定律开始，该定律指出施加于物体的净扭矩等于其转动惯量乘以其角加速度。\n$$ I \\dot{\\omega}(t) = \\tau_{\\text{total}}(t) $$\n总扭矩 $\\tau_{\\text{total}}$ 是外部扭矩 $\\tau_{\\mathrm{ext}}$ 和来自电机的控制扭矩 $\\tau_{\\mathrm{motor}}$ 的总和。\n$$ I \\dot{\\omega}(t) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\n为了构建计算算法，我们必须将这个连续时间方程离散化。对于前向动力学仿真，一个一致且简单的选择是显式欧拉积分方案。角速度的时间导数 $\\dot{\\omega}$ 在一个时长为 $h$ 的有限时间步长内近似为：\n$$ \\dot{\\omega} \\approx \\frac{\\omega_{k+1} - \\omega_k}{h} $$\n其中 $\\omega_k$ 和 $\\omega_{k+1}$ 分别是时间步开始和结束时的角速度。将此代入运动方程，得到离散时间动力学方程：\n$$ I \\left( \\frac{\\omega_{k+1} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}} $$\n控制目标是选择一个电机扭矩 $\\tau_{\\mathrm{motor}}$，使得产生的速度 $\\omega_{k+1}$ 与目标速度 $\\omega^{\\star}$ 相匹配。我们首先确定能够完美实现此目标的理想、无约束扭矩，记为 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$。我们在离散动力学方程中设置 $\\omega_{k+1} = \\omega^{\\star}$：\n$$ I \\left( \\frac{\\omega^{\\star} - \\omega_k}{h} \\right) = \\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}^{\\text{ideal}} $$\n解出这个理想电机扭矩：\n$$ \\tau_{\\mathrm{motor}}^{\\text{ideal}} = \\frac{I}{h}(\\omega^{\\star} - \\omega_k) - \\tau_{\\mathrm{ext}} $$\n此表达式代表了在显式欧拉离散化下，系统在单个时间步内达到目标角速度所需的扭矩。\n\n然而，电机受到物理限制，表示为箱式约束：\n$$ -\\tau_{\\max} \\le \\tau_{\\mathrm{motor}} \\le \\tau_{\\max} $$\n理想扭矩 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$ 可能会超出这些限制。物理上正确的方法是，如果发生饱和，则沿理想扭矩的方向施加可能的最大扭矩。这对应于在允许区间 $[-\\tau_{\\max}, \\tau_{\\max}]$ 内找到最接近 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$ 的扭矩 $\\tau_{\\mathrm{motor}}$。这是将理想扭矩投影到有效集合上。在数学上，这个操作是一个钳位或饱和函数：\n$$ \\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max}) \\equiv \\max(-\\tau_{\\max}, \\min(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, \\tau_{\\max})) $$\n这个公式并非凭空捏造；它是解决在不等式约束 $\\tau \\le \\tau_{\\max}$ 和 $-\\tau \\le \\tau_{\\max}$ 下最小化与理想扭矩偏差 $J(\\tau) = (\\tau - \\tau_{\\mathrm{motor}}^{\\text{ideal}})^2$ 的约束优化问题的正确解。通过 Karush-Kuhn-Tucker (KKT) 条件得到的解证实了这种投影是最优选择。\n\n确定了受约束的、可实现的电机扭矩 $\\tau_{\\mathrm{motor}}$ 后，我们现在可以计算下一个时间步实际产生的角速度 $\\omega_{k+1}$。我们重新整理离散动力学方程以求解 $\\omega_{k+1}$：\n$$ \\omega_{k+1} = \\omega_k + \\frac{h}{I} (\\tau_{\\mathrm{ext}} + \\tau_{\\mathrm{motor}}) $$\n如果 $\\tau_{\\mathrm{motor}} = \\tau_{\\mathrm{motor}}^{\\text{ideal}}$（即没有饱和），将其代回方程会正确地得到 $\\omega_{k+1} = \\omega^{\\star}$。如果发生饱和，$\\tau_{\\mathrm{motor}}$ 将是 $\\tau_{\\max}$ 或 $-\\tau_{\\max}$，而 $\\omega_{k+1}$ 将是在最大执行器努力下达到的速度。\n\n最终算法如下：\n1. 对于给定的参数集 $\\{I, h, \\omega_k, \\omega^{\\star}, \\tau_{\\max}, \\tau_{\\mathrm{ext}}\\}$，计算理想电机扭矩 $\\tau_{\\mathrm{motor}}^{\\text{ideal}}$。\n2. 应用饱和约束，找到实际的电机扭矩 $\\tau_{\\mathrm{motor}} = \\text{clamp}(\\tau_{\\mathrm{motor}}^{\\text{ideal}}, -\\tau_{\\max}, \\tau_{\\max})$。\n3. 使用受约束的扭矩 $\\tau_{\\mathrm{motor}}$ 计算新的角速度 $\\omega_{k+1}$。\n对每个测试案例应用此过程，以找到对应的下一步角速度。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the next-step angular velocity for a motor-driven revolute joint,\n    enforcing motor torque limits using a principled constraint method.\n    \"\"\"\n    # Test cases defined in the problem statement.\n    # Each case is a tuple: (I, h, omega_k, omega_star, tau_max, tau_ext)\n    test_cases = [\n        # Case 1: Unsaturated servo tracking\n        (1.5, 0.02, 1.00, 1.02, 5.0, 0.5),\n        # Case 2: Strong positive saturation\n        (0.5, 0.01, 0.00, 10.00, 2.0, 0.0),\n        # Case 3: Strong negative saturation opposing external torque\n        (1.2, 0.02, 5.00, -5.00, 1.0, 0.2),\n        # Case 4: Zero motor capability, external torque only\n        (1.0, 0.05, 2.00, 0.00, 0.0, -0.5),\n        # Case 5: Boundary equality where the bound is just sufficient\n        (2.0, 0.10, 1.00, 1.50, 10.0, 0.0),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        I, h, omega_k, omega_star, tau_max, tau_ext = case\n\n        # Step 1: Calculate the ideal motor torque to reach omega_star in one step.\n        # This is derived from I * (omega_k+1 - omega_k) / h = tau_ext + tau_motor\n        # by setting omega_k+1 = omega_star and solving for tau_motor.\n        tau_motor_ideal = (I / h) * (omega_star - omega_k) - tau_ext\n        \n        # Step 2: Enforce the motor torque constraint. The applied torque is the\n        # ideal torque projected (clamped) onto the valid interval [-tau_max, tau_max].\n        tau_motor_actual = np.clip(tau_motor_ideal, -tau_max, tau_max)\n        \n        # Step 3: Calculate the actual next-step angular velocity using the\n        # constrained torque and the discrete dynamics equation.\n        # omega_k+1 = omega_k + (h / I) * (tau_ext + tau_motor)\n        omega_next = omega_k + (h / I) * (tau_ext + tau_motor_actual)\n        \n        results.append(omega_next)\n\n    # Format the final output as a single-line, comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    # The format string '{r:.6f}' ensures rounding to six decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2380886"}, {"introduction": "在理解了基本的投影概念之后，我们将把它应用到一个完整的三维摩擦接触问题中。这个练习的核心是使用投影高斯-赛德尔（Projected Gauss-Seidel, PGS）方法求解一个线性互补问题（Linear Complementarity Problem, LCP），它同时处理了法向的单边非侵彻约束和切向的库仑摩擦约束。这项实践 [@problem_id:2380912] 是现代计算接触力学的核心。为一个单接触点实现PGS求解器，将让你直接体验驱动许多物理引擎的迭代方法，并学习如何同时强制法向力的非负性和摩擦力的上限。", "problem": "你需要实现一个投影高斯-赛德尔 (PGS) 求解器，用于求解一个以包含库仑摩擦的线性互补问题 (LCP) 形式表述的、单接触、三维摩擦接触时间步进问题。物理情景为一个质量为 $m$ 的刚性块在重力作用下于三维空间中运动，可能与一个单位法向量为 $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$ 的水平面接触。只考虑该块的平移运动（忽略旋转），时间步进方案在接触冲量上是隐式的，在外力上是显式的，时间步长为 $h$。\n\n从以下基本原理和核心定义出发：\n- 时间步长内的冲量形式的牛顿第二定律：$\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$，其中 $\\mathbf{M}$ 是质量矩阵，$\\mathbf{v}^{-}$ 和 $\\mathbf{v}^{+}$ 分别是步前和步后速度，$\\mathbf{f}_{\\mathrm{ext}}$ 是外力，$\\mathbf{J}$ 是接触雅可比矩阵，$\\mathbf{p}$ 是接触冲量。\n- 速度层级的单边不可穿透性与互补性：$0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$，其中 $p_{n}$ 是法向冲量，$\\gamma_{n}^{+}$ 是步后法向相对速度。\n- 通过摩擦锥的库仑摩擦模型：$\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$，其中 $\\mathbf{p}_{t}$ 是切向冲量，$\\mu$ 是摩擦系数，以及最大耗散原理，该原理强制在锥内时发生粘滞（$\\gamma_{t}^{+} = \\mathbf{0}$），在锥边界上时发生带投影的滑动。\n\n对于刚性块与平面之间的单个接触，定义一个局部接触标架，其基向量为 $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$，其中 $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ 和 $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$。平移质量矩阵为 $\\mathbf{M} = m \\mathbf{I}_{3}$。使用冲量-动量离散化，令 $\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p})$。接触点处在局部标架下的相对速度为 $\\boldsymbol{\\gamma}^{+} = \\mathbf{J} \\mathbf{v}^{+}$。证明在该设定下，有效 Delassus 算子（也称接触点处的逆质量）简化为 $\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$，并且 PGS 迭代可以对 $3 \\times 1$ 的冲量向量 $\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$ 执行，使用：\n- 法向互补更新：$p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$，\n- 切向无约束梯度步，后跟投影到半径为 $\\mu p_{n}$ 的摩擦盘上：$\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$，\n其中 $\\boldsymbol{\\gamma} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$，而 $\\mathbf{c}$ 聚合了来自步前速度和外力的已知项。\n\n使用重力 $\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$，其中 $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ 且 $g > 0$。时间步长为 $h > 0$。局部“自由”接触速度向量为 $\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right)$，在此设置中计算为 $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$。使用 PGS 求解 $\\mathbf{p}$ 后，计算步后速度\n$$\n\\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}}\\mathbf{p} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}.\n$$\n\n你的任务：\n- 为这个单接触问题实现一个基本的投影高斯-赛德尔 (PGS) 求解器，作为一个完整的程序。使用固定的迭代次数（例如，$N_{\\mathrm{iter}} = 50$），如果 $\\mathbf{p}$ 的变化量低于一个小的容差（例如，$10^{-12}$），则提前终止。你的实现必须足够通用，以处理 $m$、$h$、$g$、$\\mu$ 和 $\\mathbf{v}^{-}$ 的任何容许输入，尽管对于此问题，你将只求解指定的测试套件。\n- 对于下面的每个测试用例，计算并报告四个量：步后法向速度 $v^{+}_{y}$（单位 $\\mathrm{m/s}$），步后切向速率 $\\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}$（单位 $\\mathrm{m/s}$），法向冲量 $p_{n}$（单位 $\\mathrm{N\\cdot s}$），以及切向冲量的大小 $\\sqrt{p_{t1}^{2} + p_{t2}^{2}}$（单位 $\\mathrm{N\\cdot s}$）。所有输出均使用指定单位，并将每个报告的数字四舍五入到恰好六位小数。\n\n角度单位不适用。百分比不适用。\n\n测试套件（所有量均采用国际单位制）：\n- 用例 1 (滑动): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$.\n- 用例 2 (粘滞): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$.\n- 用例 3 (无摩擦): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$.\n- 用例 4 (分离，无接触): $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$.\n- 用例 5 (重块，混合): $m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$.\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果本身必须是一个包含四个四舍五入浮点数的列表，顺序为 $[v^{+}_{y}, \\sqrt{(v^{+}_{x})^{2} + (v^{+}_{z})^{2}}, p_{n}, \\sqrt{p_{t1}^{2} + p_{t2}^{2}}]$。例如，一个包含两个假设结果的输出将类似于 $[[a_{1},b_{1},c_{1},d_{1}],[a_{2},b_{2},c_{2},d_{2}]]$，其中每个条目都四舍五入到六位小数。", "solution": "该问题需要经过验证。\n\n### 第 1 步：提取已知条件\n- **物理系统**：一个质量为 $m$ 的刚性块在三维空间中进行平移运动，可能与一个水平面接触。\n- **接触几何**：该平面的单位法向量为 $\\mathbf{n} = [0,1,0]^{\\mathsf{T}}$。局部接触标架的基向量为 $\\{\\mathbf{n}, \\mathbf{t}_{1}, \\mathbf{t}_{2}\\}$，其中 $\\mathbf{t}_{1} = [1,0,0]^{\\mathsf{T}}$ 且 $\\mathbf{t}_{2} = [0,0,1]^{\\mathsf{T}}$。\n- **动力学**：\n    - 质量矩阵：$\\mathbf{M} = m \\mathbf{I}_{3}$。\n    - 外力：重力，$\\mathbf{f}_{\\mathrm{ext}} = m \\mathbf{g}$，其中 $\\mathbf{g} = [0, -g, 0]^{\\mathsf{T}}$ 且 $g > 0$。\n    - 时间步长：$h > 0$。\n- **时间步进公式**：\n    - 冲量-动量方程：$\\mathbf{M} (\\mathbf{v}^{+} - \\mathbf{v}^{-}) = h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}$。\n    - 接触雅可比矩阵 $\\mathbf{J}$ 将全局速度 $\\mathbf{v}$ 映射到局部相对速度 $\\boldsymbol{\\gamma}$。\n    - 接触冲量（局部标架）：$\\mathbf{p} = [p_{n}, p_{t1}, p_{t2}]^{\\mathsf{T}}$。\n- **接触定律**：\n    - 单边不可穿透性：$0 \\le p_{n} \\perp \\gamma_{n}^{+} \\ge 0$。\n    - 库仑摩擦：$\\|\\mathbf{p}_{t}\\| \\le \\mu p_{n}$，其中 $\\mathbf{p}_{t} = [p_{t1}, p_{t2}]^{\\mathsf{T}}$，$\\mu$ 是摩擦系数。\n- **线性互补问题 (LCP) 公式**：\n    - 步后相对速度：$\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$。\n    - Delassus 算子：$\\mathbf{A} = \\mathbf{J}\\mathbf{M}^{-1}\\mathbf{J}^{\\mathsf{T}} = \\frac{1}{m}\\mathbf{I}_{3}$。\n    - 自由速度项：$\\mathbf{c} = \\mathbf{J} \\left(\\mathbf{v}^{-} + \\mathbf{M}^{-1} h \\mathbf{f}_{\\mathrm{ext}}\\right) = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$。\n- **投影高斯-赛德尔 (PGS) 更新规则**：\n    - 法向更新：$p_{n} \\leftarrow \\max\\{0, p_{n} - \\gamma_{n} / A_{nn}\\}$。\n    - 切向更新：$\\mathbf{p}_{t} \\leftarrow \\operatorname{Proj}_{\\|\\cdot\\| \\le \\mu p_{n}}(\\mathbf{p}_{t} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_{t})$。\n- **步后速度计算**：\n    - $\\mathbf{v}^{+} = \\mathbf{v}^{-} + [0, -h g, 0]^{\\mathsf{T}} + \\frac{1}{m}[p_{t1}, p_{n}, p_{t2}]^{\\mathsf{T}}$。\n- **求解器参数**：\n    - 固定迭代次数：$N_{\\mathrm{iter}} = 50$。\n    - 收敛容差：$\\epsilon = 10^{-12}$。\n- **测试套件**：\n    - 用例 1: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [2.0,-1.0,0.0]^{\\mathsf{T}}$。\n    - 用例 2: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 1.0$, $\\mathbf{v}^{-} = [0.05,-0.01,0.0]^{\\mathsf{T}}$。\n    - 用例 3: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.0$, $\\mathbf{v}^{-} = [1.0,-0.2,0.0]^{\\mathsf{T}}$。\n    - 用例 4: $m = 1.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.5$, $\\mathbf{v}^{-} = [0.0,0.5,0.0]^{\\mathsf{T}}$。\n    - 用例 5: $m = 1000.0$, $h = 0.01$, $g = 9.81$, $\\mu = 0.6$, $\\mathbf{v}^{-} = [3.0,-0.3,4.0]^{\\mathsf{T}}$。\n\n### 第 2 步：使用提取的已知条件进行验证\n根据验证标准对问题进行评估：\n- **科学基础扎实**：该问题基于经典力学的基本原理（牛顿定律）和计算接触力学中的标准模型（库仑摩擦、互补条件、LCP 公式）。隐式时间步进方案和 PGS 方法是成熟的技术。该问题具有科学合理性。\n- **适定性**：问题要求实现一个特定的、定义明确的算法 (PGS) 来解决一个摩擦接触问题。对于给定的设置（单接触、对角 Delassus 算子），PGS 方法保证收敛到唯一解。该问题是适定的。\n- **客观性**：问题陈述使用了精确、无歧义的数学和物理术语。没有主观或基于意见的元素。该问题是客观的。\n- **完整且一致**：所有必要的方程、参数和边界条件都已提供。问题陈述中给出的 $\\mathbf{A}$ 和 $\\mathbf{c}$ 的推导与底层物理以及 $\\mathbf{J}$、$\\mathbf{M}$ 和 $\\mathbf{f}_{\\text{ext}}$ 的定义是一致的。该设置是完整且内部一致的。\n\n### 第 3 步：结论与行动\n问题有效。这是一个计算力学中的标准、定义明确的问题。将提供解决方案。\n\n目标是为一个单接触摩擦问题实现一个投影高斯-赛德尔 (PGS) 求解器。该问题被表述为一个线性互补问题 (LCP)，其中未知量是接触冲量 $\\mathbf{p} = [p_n, p_{t1}, p_{t2}]^{\\mathsf{T}}$。\n\n首先，我们定义 LCP 系统。步后相对接触速度 $\\boldsymbol{\\gamma}^{+}$ 通过仿射关系 $\\boldsymbol{\\gamma}^{+} = \\mathbf{A}\\mathbf{p} + \\mathbf{c}$ 与冲量 $\\mathbf{p}$ 相关联，其中 $\\mathbf{A}$ 是 Delassus 算子，$\\mathbf{c}$ 是自由速度项。问题指出，对于这个特定系统，$\\mathbf{A} = \\frac{1}{m}\\mathbf{I}_3$，是一个对角矩阵。自由速度向量 $\\mathbf{c}$ 收集了所有与未知冲量 $\\mathbf{p}$ 无关的项，并由 $\\mathbf{c} = [v_{y}^{-} - h g, v_{x}^{-}, v_{z}^{-}]^{\\mathsf{T}}$ 给出。我们将 $\\mathbf{c}$ 的分量表示为 $c_n = v_{y}^{-} - h g$，$c_{t1} = v_{x}^{-}$ 和 $c_{t2} = v_{z}^{-}$。\n\nPGS 方法是一种迭代算法，它通过顺序更新解向量 $\\mathbf{p}$ 的分量并将其投影以满足约束来求解 LCP。我们将冲量向量初始化为零，$\\mathbf{p}^{(0)} = \\mathbf{0}$。对于每次迭代 $k$，我们基于 $\\mathbf{p}^{(k)}$ 计算一个新的估计值 $\\mathbf{p}^{(k+1)}$。迭代对法向和切向分量使用分块更新策略。\n\n**1. 法向冲量更新：**\nPGS 扫描的第一步是更新法向冲量 $p_n$。法向的互补条件是 $0 \\le p_n \\perp \\gamma_n \\ge 0$。PGS 更新执行一个类梯度下降步，并将结果投影到可行集上，对于 $p_n$ 来说，可行集是非负实数线。\n更新规则是 $p_n^{(k+1)} = \\max\\{0, p_n^{(k)} - A_{nn}^{-1}\\gamma_n^{(k)}\\}$。相对速度 $\\gamma_n$ 是使用可用的最新冲量值计算的，但由于 $\\mathbf{A}$ 是对角矩阵，这简化了计算。\n$$ \\gamma_n = (\\mathbf{A}\\mathbf{p}^{(k)} + \\mathbf{c})_n = A_{nn}p_n^{(k)} + c_n = \\frac{1}{m}p_n^{(k)} + c_n $$\n将此代入更新规则：\n$$ p_n^{(k+1)} = \\max\\left\\{0, p_n^{(k)} - \\frac{\\frac{1}{m}p_n^{(k)} + c_n}{1/m}\\right\\} = \\max\\left\\{0, p_n^{(k)} - (p_n^{(k)} + m c_n)\\right\\} = \\max\\{0, -m c_n\\} $$\n这表明对于这个对角系统，法向冲量在一步内就收敛到其最终值。然而，实现必须遵循指定的迭代形式。\n\n**2. 切向冲量更新：**\n接下来，我们更新切向冲量向量 $\\mathbf{p}_t = [p_{t1}, p_{t2}]^{\\mathsf{T}}$。库仑摩擦定律规定，切向冲量必须位于切向平面内半径为 $R = \\mu p_n$ 的圆盘内：$\\|\\mathbf{p}_t\\| \\le \\mu p_n$。以高斯-赛德尔方式，我们使用最新计算的法向冲量 $p_n^{(k+1)}$ 来定义当前迭代中摩擦盘的半径。更新通过一个无约束步骤后跟一个到该圆盘上的投影来执行。\n切向块的无约束更新为：$\\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - \\mathbf{A}_{tt}^{-1}\\boldsymbol{\\gamma}_t^{(k)}$。\n切向相对速度为 $\\boldsymbol{\\gamma}_t^{(k)} = \\mathbf{A}_{tt}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t$。给定 $\\mathbf{A}_{tt} = \\frac{1}{m}\\mathbf{I}_2$，其逆为 $\\mathbf{A}_{tt}^{-1} = m\\mathbf{I}_2$。\n$$ \\mathbf{p}_t^{unc} = \\mathbf{p}_t^{(k)} - m\\left(\\frac{1}{m}\\mathbf{p}_t^{(k)} + \\mathbf{c}_t\\right) = -m\\mathbf{c}_t $$\n最终的切向冲量通过将 $\\mathbf{p}_t^{unc}$ 投影到半径为 $R = \\mu p_n^{(k+1)}$ 的圆盘上获得：\n$$ \\mathbf{p}_t^{(k+1)} = \\operatorname{Proj}_{\\|\\cdot\\| \\le R}(\\mathbf{p}_t^{unc}) $$\n投影定义为：\n$$ \\mathbf{p}_t^{(k+1)} = \\begin{cases} \\mathbf{p}_t^{unc}  \\text{if } \\|\\mathbf{p}_t^{unc}\\| \\le R \\\\ R \\frac{\\mathbf{p}_t^{unc}}{\\|\\mathbf{p}_t^{unc}\\|}  \\text{if } \\|\\mathbf{p}_t^{unc}\\| > R \\end{cases} $$\n这对应于如果所需的摩擦冲量在锥内则发生粘滞，否则发生滑动。\n\n迭代过程重复进行固定次数的迭代 $N_{\\mathrm{iter}}$，或者直到冲量向量的变化量（用无穷范数 $\\|\\mathbf{p}^{(k+1)} - \\mathbf{p}^{(k)}\\|_{\\infty}$ 衡量）小于指定的容差 $\\epsilon$。\n\n**3. 后处理：**\n在 PGS 求解器收敛到最终冲量 $\\mathbf{p}$ 后，使用冲量-动量关系计算步后速度 $\\mathbf{v}^{+}$：\n$$ \\mathbf{v}^{+} = \\mathbf{v}^{-} + \\mathbf{M}^{-1} (h \\mathbf{f}_{\\mathrm{ext}} + \\mathbf{J}^{\\mathsf{T}} \\mathbf{p}) $$\n根据提供的定义，这变为：\n$$ \\begin{bmatrix} v_x^{+} \\\\ v_y^{+} \\\\ v_z^{+} \\end{bmatrix} = \\begin{bmatrix} v_x^{-} \\\\ v_y^{-} \\\\ v_z^{-} \\end{bmatrix} + \\begin{bmatrix} 0 \\\\ -h g \\\\ 0 \\end{bmatrix} + \\frac{1}{m} \\begin{bmatrix} p_{t1} \\\\ p_n \\\\ p_{t2} \\end{bmatrix} $$\n由此，计算所需的输出量：\n- 步后法向速度：$v_y^{+}$\n- 步后切向速率：$\\sqrt{(v_x^{+})^2 + (v_z^{+})^2}$\n- 法向冲量：$p_n$\n- 切向冲量的大小：$\\sqrt{p_{t1}^2 + p_{t2}^2}$\n\n实现将针对每个提供的测试用例遵循此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the specified test cases for the frictional contact problem.\n    \"\"\"\n    \n    # Test suite (m, h, g, mu, v_minus)\n    # All quantities are in SI units.\n    test_cases = [\n        (1.0, 0.01, 9.81, 0.5, np.array([2.0, -1.0, 0.0])),  # Case 1 (sliding)\n        (1.0, 0.01, 9.81, 1.0, np.array([0.05, -0.01, 0.0])),  # Case 2 (sticking)\n        (1.0, 0.01, 9.81, 0.0, np.array([1.0, -0.2, 0.0])),    # Case 3 (frictionless)\n        (1.0, 0.01, 9.81, 0.5, np.array([0.0, 0.5, 0.0])),   # Case 4 (separating)\n        (1000.0, 0.01, 9.81, 0.6, np.array([3.0, -0.3, 4.0])),# Case 5 (heavy block, mixed)\n    ]\n\n    results = []\n    for case in test_cases:\n        m, h, g, mu, v_minus = case\n        result = run_pgs_solver(m, h, g, mu, v_minus)\n        # Round each number in the result to 6 decimal places\n        rounded_result = [round(x, 6) for x in result]\n        results.append(rounded_result)\n\n    # Format the final output string as specified\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_pgs_solver(m, h, g, mu, v_minus):\n    \"\"\"\n    Implements the Projected Gauss-Seidel solver for a single-contact LCP.\n\n    Args:\n        m (float): Mass of the block.\n        h (float): Time step duration.\n        g (float): Acceleration due to gravity.\n        mu (float): Coefficient of friction.\n        v_minus (np.ndarray): Pre-step velocity vector [vx, vy, vz].\n\n    Returns:\n        list: A list of four floats:\n              [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude].\n    \"\"\"\n    \n    # Solver parameters\n    N_iter = 50\n    tolerance = 1e-12\n\n    # Pre-computation of the free velocity vector 'c'\n    # c = [v_y^- - h*g, v_x^-, v_z^-]^T\n    c_n = v_minus[1] - h * g\n    c_t = np.array([v_minus[0], v_minus[2]])\n    \n    # Initialize impulse vector p = [p_n, p_t1, p_t2]^T\n    p = np.zeros(3)\n    \n    # Delassus operator is diagonal A = (1/m) * I\n    # inv_A_nn = m, inv_A_tt = m * I_2\n    inv_A_nn = m\n    \n    # PGS iteration loop\n    for _ in range(N_iter):\n        p_old = p.copy()\n        \n        # 1. Normal impulse update (component p_n)\n        # gamma_n = (1/m)*p_n + c_n\n        gamma_n = (1.0 / m) * p[0] + c_n\n        # p_n_new = max(0, p_n - inv_A_nn * gamma_n)\n        p[0] = max(0.0, p[0] - inv_A_nn * gamma_n)\n        \n        # 2. Tangential impulse update (block p_t)\n        # The update is based on the most recent p_n\n        friction_radius = mu * p[0]\n        \n        # Unconstrained tangential impulse: p_t_unc = -inv_A_tt * c_t = -m * c_t\n        p_t_unc = -m * c_t\n        norm_p_t_unc = np.linalg.norm(p_t_unc)\n        \n        # Project onto friction disk\n        if norm_p_t_unc = friction_radius:\n            # Sticking\n            p[1:] = p_t_unc\n        else:\n            # Sliding\n            if norm_p_t_unc > 1e-15: # Avoid division by zero\n                p[1:] = friction_radius * p_t_unc / norm_p_t_unc\n            else:\n                p[1:] = np.zeros(2)\n\n        # 3. Check for convergence\n        # The change is measured using the infinity norm\n        change = np.linalg.norm(p - p_old, np.inf)\n        if change  tolerance:\n            break\n            \n    p_n = p[0]\n    p_t = p[1:]\n    \n    # Post-processing: Compute post-step velocity v_plus\n    # v+ = v- + [0, -hg, 0]^T + (1/m)*[p_t1, p_n, p_t2]^T\n    v_plus = np.zeros(3)\n    v_plus[0] = v_minus[0] + p_t[0] / m\n    v_plus[1] = v_minus[1] - h * g + p_n / m\n    v_plus[2] = v_minus[2] + p_t[1] / m\n    \n    # Calculate required output quantities\n    v_plus_y = v_plus[1]\n    tangential_speed_plus = np.linalg.norm(np.array([v_plus[0], v_plus[2]]))\n    p_t_magnitude = np.linalg.norm(p_t)\n    \n    return [v_plus_y, tangential_speed_plus, p_n, p_t_magnitude]\n\nsolve()\n```", "id": "2380912"}, {"introduction": "最后的练习将约束原理应用到涉及冲击的动态仿真场景中。我们将注意力转向在一个时间步进循环中集成单边约束，这涉及一种“预测-校正”（predict-correct）方案，即首先计算自由运动，然后在违反约束（如关节限位）时进行校正。这个练习 [@problem_id:2380890] 搭建了从静态约束求解到动态仿真的桥梁。通过对一个带间隙的关节进行建模，你将看到诸如 $g(x) \\ge 0$ 的非侵彻约束和冲击响应是如何随时间处理的，从而深入了解具有间歇性接触的系统的仿真方法。", "problem": "考虑一个用于模拟对称间隙松动关节中相对位移的单自由度模型。设标量坐标为 $x(t)$（单位：米），质量为 $m$（单位：千克），施加的外部恒定力为 $F$（单位：牛顿）。该关节具有半宽为 $\\delta$ 米的死区间隙，这意味着当 $x(t) \\in [-\\delta,\\delta]$ 时，不存在约束反力。当与限位块之间的间隙闭合时，会发生碰撞，并通过一个反作用冲量来强制实现非穿透。假设接触面无摩擦，碰撞为无摩擦碰撞，法向恢复系数为 $e \\in [0,1]$。\n\n该动力学由牛顿第二定律以及通过互补性关系描述的单边约束所支配。设上、下间隙分别为 $g_u(x) = \\delta - x$ 和 $g_\\ell(x) = \\delta + x$，对应的非负拉格朗日乘子（法向反作用力）为 $\\lambda_u(t) \\ge 0$ 和 $\\lambda_\\ell(t) \\ge 0$。方程为\n$$\nm\\,\\ddot{x}(t) = F - \\lambda_u(t) + \\lambda_\\ell(t),\n$$\n$$\ng_u(x(t)) \\ge 0,\\quad \\lambda_u(t) \\ge 0,\\quad g_u(x(t))\\,\\lambda_u(t) = 0,\n$$\n$$\ng_\\ell(x(t)) \\ge 0,\\quad \\lambda_\\ell(t) \\ge 0,\\quad g_\\ell(x(t))\\,\\lambda_\\ell(t) = 0.\n$$\n因此，在死区 $x(t) \\in (-\\delta,\\delta)$ 内，有 $\\lambda_u(t)=\\lambda_\\ell(t)=0$，没有约束力作用。当接触到一个限位块时（间隙为零），法向反作用力强制实现非穿透。在与限位块发生瞬时碰撞时，设 $v^{-}$ 和 $v^{+}$ 分别表示接触构型下的碰撞前和碰撞后速度。法向碰撞定律是牛顿恢复定律，\n$$\nv^{+} = -\\,e\\,v^{-},\n$$\n当物体以指向限位块法向外侧的接近速度 $v^{-}$ 撞击限位块时应用此定律。\n\n基于这些原理，推导一个一阶时间步进算法，该算法使用固定的时间步长 $\\Delta t$ 秒来推进状态 $(x,v)$，具体步骤如下：\n- 在 $[t_n,t_{n+1}]$ 上进行无约束力的自由飞行更新，\n- 然后每步最多执行一次非穿透处理：将位置投影到最近的活动边界上，如果碰撞时的运动是向外的，则通过与上述碰撞定律一致的冲量来校正速度。\n\n您的程序必须在纯数学术语中实现以下算法：\n- 基于牛顿第二定律 $m\\,\\dot{v} = F$（$F$在步长内为常数），进行自由飞行的半隐式更新，以获得一个试验状态 $(x^{\\mathrm{free}},v^{\\mathrm{free}})$。\n- 如果 $x^{\\mathrm{free}} \\in [-\\delta,\\delta]$，则接受 $(x^{\\mathrm{free}},v^{\\mathrm{free}})$。\n- 如果 $x^{\\mathrm{free}} > \\delta$，则设置 $x^{+} = \\delta$。如果 $v^{\\mathrm{free}} > 0$，应用碰撞定律设置 $v^{+} = -\\,e\\,v^{\\mathrm{free}}$；否则设置 $v^{+} = v^{\\mathrm{free}}$。\n- 如果 $x^{\\mathrm{free}}  -\\delta$，则设置 $x^{+} = -\\delta$。如果 $v^{\\mathrm{free}}  0$，应用碰撞定律设置 $v^{+} = -\\,e\\,v^{\\mathrm{free}}$；否则设置 $v^{+} = v^{\\mathrm{free}}$。\n\n在 $t=0$ 时使用以下初始条件校正：如果 $x(0)$ 位于 $[-\\delta,\\delta]$ 之外，则将其投影到最近的边界上，并且如果初始速度相对于该边界是向外的，则立即应用相同的碰撞定律。\n\n您的任务是实现这个时间步进方案，并计算下面给出的每个测试用例的最终状态 $(x(T),v(T))$。所有物理量都必须使用国际单位制（SI）：米、千克、秒和牛顿。如果存在角度，请以弧度表示。输出必须是数值，位置单位为米，速度单位为米/秒。将每个数值输出值四舍五入到 $6$ 位小数。\n\n所有测试通用的固定参数如下：\n- 质量 $m = 1.0$ 千克。\n- 间隙半宽 $\\delta = 0.01$ 米。\n- 时间步长 $\\Delta t = 0.0005$ 秒。\n- 最终时间 $T = 0.2$ 秒。\n\n测试套件包含四个用例，用于检验不同的行为：\n- 用例 A（在时间范围内无接触）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=0.2$ 牛顿，$e=0.6$。\n- 用例 B（与上限位块单次碰撞，部分回弹）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=1.0$ 牛顿，$e=0.5$。\n- 用例 C（与下限位块单次碰撞，弹性）：$x(0)=0.0$ 米，$v(0)=0.0$ 米/秒，$F=-1.0$ 牛顿，$e=1.0$。\n- 用例 D（初始穿透通过投影解决，然后静止）：$x(0)=0.015$ 米，$v(0)=0.0$ 米/秒，$F=0.0$ 牛顿，$e=0.0$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表是按 A、B、C、D 顺序排列的一个用例的最终状态 $[x(T),v(T)]$。确切的所需格式为：\n\"[ [x_A,v_A],[x_B,v_B],[x_C,v_C],[x_D,v_D] ]\"\n每个数字都四舍五入到 $6$ 位小数。", "solution": "所提出的问题具有科学依据，提法恰当且客观。这是一个计算力学领域的标准练习，涉及带单边约束系统的数值积分。基于牛顿第二定律和接触互补公式的物理模型是合理的。指定的数值算法，即一种带约束实施投影法的一阶时间步进方案，定义清晰且可实现。所有必要的数据均已提供。因此，该问题是有效的，并将在此给出一个解决方案。\n\n目标是通过数值积分其运动方程，确定一个单自由度质点系统的最终状态 $(x(T), v(T))$。该系统受到一个恒定的外力和定义了间隙的单边约束。\n\n系统的动力学由关于位置 $x(t)$ 的牛顿第二定律支配：\n$$\nm \\ddot{x}(t) = F + F_{\\text{contact}}(t)\n$$\n其中 $m$ 是质量，$F$ 是恒定外力，$F_{\\text{contact}}(t)$ 代表来自约束的反作用力。约束由半宽为 $\\delta$ 的间隙定义，因此允许的位置为 $x(t) \\in [-\\delta, \\delta]$。当质点严格处于间隙内部时，即 $x(t) \\in (-\\delta, \\delta)$，接触力为零。在边界 $x=\\delta$ 和 $x=-\\delta$ 处，发生接触。该问题使用由牛顿恢复定律支配的瞬时碰撞来模拟这种接触，恢复系数为 $e$。\n\n使用固定的时间步长 $\\Delta t$ 构建数值解。系统在时间 $t_n = n \\Delta t$ 的状态由数对 $(x_n, v_n)$ 给出，分别代表位置和速度。将状态从 $t_n$ 推进到 $t_{n+1}$ 的算法是一种两步预测-校正方法。\n\n1.  **自由飞行预测步骤**：首先，通过忽略约束并仅在外部力 $F$ 的作用下积分运动，计算出 $t_{n+1}$ 时刻的一个试验状态 $(x^{\\mathrm{free}}, v^{\\mathrm{free}})$。加速度是恒定的，$a = F/m$。指定使用半隐式欧拉格式：\n    $$\n    v^{\\mathrm{free}} = v_n + a \\Delta t\n    $$\n    $$\n    x^{\\mathrm{free}} = x_n + v^{\\mathrm{free}} \\Delta t\n    $$\n\n2.  **约束实施（校正）步骤**：将预测位置 $x^{\\mathrm{free}}$ 与允许区域 $[-\\delta, \\delta]$ 进行比较。如果位置超出此区域（处于穿透状态），则将其投影回最近的边界，并校正速度以模拟碰撞。其逻辑如下：\n\n    - 如果 $x^{\\mathrm{free}} \\in [-\\delta, \\delta]$（无穿透）：接受自由飞行的预测结果。\n      $$\n      x_{n+1} = x^{\\mathrm{free}}, \\quad v_{n+1} = v^{\\mathrm{free}}\n      $$\n\n    - 如果 $x^{\\mathrm{free}} > \\delta$（穿透上边界）：将位置投影到 $x_{n+1} = \\delta$。根据碰撞定律更新速度，该定律仅在预测速度 $v^{\\mathrm{free}}$ 对应于朝向边界的接近运动（$v^{\\mathrm{free}} > 0$）时适用。\n      $$\n      x_{n+1} = \\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} > 0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\le 0 \\end{cases}\n      $$\n\n    - 如果 $x^{\\mathrm{free}}  -\\delta$（穿透下边界）：将位置投影到 $x_{n+1} = -\\delta$。更新速度，对接近速度（$v^{\\mathrm{free}}  0$）应用碰撞定律。\n      $$\n      x_{n+1} = -\\delta, \\quad v_{n+1} = \\begin{cases} -e \\, v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}}  0 \\\\ v^{\\mathrm{free}}  \\text{if } v^{\\mathrm{free}} \\ge 0 \\end{cases}\n      $$\n\n**初始条件校正**：在时间步进循环开始之前，检查初始状态 $(x(0), v(0))$。如果 $x(0)$ 已经处于穿透状态，则立即使用与上述校正步骤中描述的相同的投影和碰撞逻辑进行校正。\n\n该算法针对四个指定的测试用例分别实现并执行。模拟从 $t=0$ 运行到最终时间 $T=0.2$ 秒，使用的固定参数为：质量 $m=1.0$ 千克，间隙半宽 $\\delta=0.01$ 米，时间步长 $\\Delta t=0.0005$ 秒。这对应于总共 $N = T/\\Delta t = 400$ 个积分步。最终答案中提供的代码计算了每种情况下状态 $(x(T), v(T))$，将数值四舍五入到 $6$ 位小数，并按指定格式化输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a first-order time-stepping algorithm for a 1-DOF system with clearance\n    and computes the final state for several test cases.\n    \"\"\"\n\n    # Fixed physical and simulation parameters\n    m = 1.0  # mass in kg\n    delta = 0.01  # clearance half-width in m\n    dt = 0.0005  # time step in s\n    T = 0.2  # final time in s\n\n    # Test suite: (initial position x0, initial velocity v0, force F, coefficient of restitution e)\n    test_cases = [\n        # Case A: No contact\n        {'x0': 0.0, 'v0': 0.0, 'F': 0.2, 'e': 0.6},\n        # Case B: Single impact, partial rebound\n        {'x0': 0.0, 'v0': 0.0, 'F': 1.0, 'e': 0.5},\n        # Case C: Single impact, elastic\n        {'x0': 0.0, 'v0': 0.0, 'F': -1.0, 'e': 1.0},\n        # Case D: Initial penetration, no force\n        {'x0': 0.015, 'v0': 0.0, 'F': 0.0, 'e': 0.0},\n    ]\n\n    all_final_states = []\n\n    # Calculate the total number of steps\n    num_steps = int(T / dt)\n\n    for case in test_cases:\n        x, v = case['x0'], case['v0']\n        F, e = case['F'], case['e']\n\n        # Step 0: Initial condition correction\n        if x > delta:\n            x = delta\n            # Apply impact law if velocity is outward\n            if v > 0:\n                v = -e * v\n        elif x  -delta:\n            x = -delta\n            # Apply impact law if velocity is outward\n            if v  0:\n                v = -e * v\n        \n        # Calculate constant acceleration\n        accel = F / m\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Step 1: Free-flight prediction (semi-implicit Euler)\n            v_free = v + accel * dt\n            x_free = x + v_free * dt\n\n            # Step 2: Constraint enforcement (projection and correction)\n            if x_free > delta:\n                x = delta\n                if v_free > 0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            elif x_free  -delta:\n                x = -delta\n                if v_free  0:  # Impact condition\n                    v = -e * v_free\n                else:  # Already separating\n                    v = v_free\n            else:  # No penetration\n                x = x_free\n                v = v_free\n        \n        # Store the final state, rounded to 6 decimal places\n        all_final_states.append([round(x, 6), round(v, 6)])\n\n    # Format the final output string as per the problem specification\n    # e.g., [[x_A,v_A],[x_B,v_B],...] -> \"[[x_A,v_A],[x_B,v_B],...]\"\n    result_strings = [f\"[{state[0]},{state[1]}]\" for state in all_final_states]\n    final_output = f\"[{','.join(result_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2380890"}]}