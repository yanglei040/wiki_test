{"hands_on_practices": [{"introduction": "在多物理场耦合的计算实践中，分裂格式是最核心和基础的方法之一。为了深入理解这些方法的行为，我们从一个简化的热力耦合问题入手，直接比较两种最经典的分裂格式：Jacobi 迭代和 Gauss-Seidel 迭代。通过这个练习，你将亲手计算并分析它们的迭代矩阵和谱半径，从而量化地理解它们的收敛速度差异，为后续更复杂的耦合问题分析打下坚实的基础。[@problem_id:2416751]", "problem": "考虑一个杆的一维、线性、稳态热力耦合问题，在空间离散化后，该问题具有单一的机械自由度和单一的热自由度。未知量为轴向位移 $u$ 和温度 $T$。耦合的代数平衡方程可以写成如下的分块形式\n$$\n\\begin{bmatrix}\nk_u  -h \\\\\n-g  k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix},\n$$\n其中 $k_u > 0$ 和 $k_T > 0$ 分别表示机械和热的正刚度类系数，$h \\ge 0$ 和 $g \\ge 0$ 量化了热子系统和机械子系统之间的耦合。右端项 $f_u$ 和 $f_T$ 是给定的载荷。所有参数均为实数。\n\n针对此 $2 \\times 2$ 系统，从初始猜测 $(u^{(0)},T^{(0)})$ 开始，定义两种分区定点耦合方案：\n- 一种雅可比(Jacobi)分区方案：在每次迭代中，两个子问题都只使用另一个场的上一次迭代结果。\n- 一种高斯-赛德尔(Gauss-Seidel)分区方案：在每次迭代中，机械子问题首先更新，然后热子问题在同一次迭代中使用最新的机械更新结果。\n\n对于每种方案，线性迭代可以写成如下形式\n$$\n\\begin{bmatrix}\nu^{(k+1)} \\\\\nT^{(k+1)}\n\\end{bmatrix}\n=\n\\mathbf{M}\n\\begin{bmatrix}\nu^{(k)} \\\\\nT^{(k)}\n\\end{bmatrix}\n+\n\\mathbf{c},\n$$\n其中 $\\mathbf{M}$ 是迭代矩阵，$\\mathbf{c}$ 是一个与迭代无关的向量。线性收敛因子是谱半径 $\\rho(\\mathbf{M})$，它是一个无量纲的量。当且仅当 $\\rho(\\mathbf{M})  1$ 时，迭代收敛。\n\n任务：对于下面测试套件中列出的参数集，设 $f_u=0$ 和 $f_T=0$（$f_u$ 和 $f_T$ 的值不影响谱半径）。对于每种情况，计算以下量：\n1. 雅可比(Jacobi)分区迭代矩阵的谱半径 $\\rho_J$（无量纲）。\n2. 高斯-赛德尔(Gauss-Seidel)分区迭代矩阵的谱半径 $\\rho_{GS}$（无量纲）。\n3. 一个布尔值，指示雅可比(Jacobi)方案是否收敛，定义为 $\\rho_J  1$。\n4. 一个布尔值，指示高斯-赛德尔(Gauss-Seidel)方案是否收敛，定义为 $\\rho_{GS}  1$。\n5. 一个比较收敛速率的整数代码：如果高斯-赛德尔(Gauss-Seidel)方案严格更快（即 $\\rho_{GS}  \\rho_J$），则输出 $1$；如果雅可比(Jacobi)方案严格更快（即 $\\rho_J  \\rho_{GS}$），则输出 $2$；如果它们的谱半径在 $10^{-12}$ 的容差内相等，则输出 $0$。\n\n测试套件（每种情况都是一个元组 $(k_u,k_T,h,g)$，为了便于比较，所有量均无量纲）：\n- 情况 A：$(100.0,50.0,10.0,5.0)$。\n- 情况 B：$(100.0,100.0,0.0,50.0)$。\n- 情况 C：$(1.0,1.0,1.0,1.0)$。\n- 情况 D：$(2.0,3.0,2.0,4.0)$。\n- 情况 E：$(10^6,1.0,100.0,100.0)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例贡献一个形式为 $[\\rho_J,\\rho_{GS},\\text{JacobiConverges},\\text{GaussSeidelConverges},\\text{Winner}]$ 的子列表。浮点值 $\\rho_J$ 和 $\\rho_{GS}$ 必须四舍五入到小数点后六位。布尔值必须打印为 $True$ 或 $False$。例如，对于两个假设的用例，一个有效的整体输出将如下所示：\n$[[0.125000,0.062500,True,True,1],[1.000000,1.000000,False,False,0]]$。", "solution": "所提出的问题是耦合线性系统迭代方法分析中的一个标准练习，这是计算工程学中的一个基本课题。该问题是适定的、科学上合理的，并包含唯一解所需的所有信息。我们将继续推导所需的量。\n\n控制线性代数方程组为：\n$$\n\\begin{bmatrix}\nk_u  -h \\\\\n-g  k_T\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\nT\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nf_u \\\\\nf_T\n\\end{bmatrix}\n$$\n该系统可以抽象地写为 $\\mathbf{A}\\mathbf{x} = \\mathbf{b}$，其中 $\\mathbf{x} = [u, T]^T$ 是未知量向量，$\\mathbf{A}$ 是系统矩阵。对于雅可比(Jacobi)和高斯-赛德尔(Gauss-Seidel)类型的迭代方法，矩阵 $\\mathbf{A}$ 被分解为其对角、严格下三角和严格上三角部分：$\\mathbf{A} = \\mathbf{D} + \\mathbf{L} + \\mathbf{U}$。根据给定的系统，这些矩阵是：\n$$\n\\mathbf{D} = \\begin{bmatrix} k_u  0 \\\\ 0  k_T \\end{bmatrix}, \\quad\n\\mathbf{L} = \\begin{bmatrix} 0  0 \\\\ -g  0 \\end{bmatrix}, \\quad\n\\mathbf{U} = \\begin{bmatrix} 0  -h \\\\ 0  0 \\end{bmatrix}\n$$\n约束条件为 $k_u > 0$、$k_T > 0$、$h \\ge 0$ 和 $g \\ge 0$。这确保了对角矩阵 $\\mathbf{D}$ 是可逆的。\n\n首先，我们分析雅可比(Jacobi)分区方案。迭代更新由 $\\mathbf{D}\\mathbf{x}^{(k+1)} = -(\\mathbf{L}+\\mathbf{U})\\mathbf{x}^{(k)} + \\mathbf{b}$ 定义。因此，迭代矩阵 $\\mathbf{M}_J$ 为 $\\mathbf{M}_J = -\\mathbf{D}^{-1}(\\mathbf{L}+\\mathbf{U})$。\n$$\n\\mathbf{D}^{-1} = \\begin{bmatrix} 1/k_u  0 \\\\ 0  1/k_T \\end{bmatrix}\n$$\n$$\n-(\\mathbf{L}+\\mathbf{U}) = - \\begin{bmatrix} 0  -h \\\\ -g  0 \\end{bmatrix} = \\begin{bmatrix} 0  h \\\\ g  0 \\end{bmatrix}\n$$\n$$\n\\mathbf{M}_J = \\begin{bmatrix} 1/k_u  0 \\\\ 0  1/k_T \\end{bmatrix} \\begin{bmatrix} 0  h \\\\ g  0 \\end{bmatrix} = \\begin{bmatrix} 0  h/k_u \\\\ g/k_T  0 \\end{bmatrix}\n$$\n雅可比(Jacobi)方案的收敛性由谱半径 $\\rho(\\mathbf{M}_J)$ 决定，即其特征值的最大绝对值。特征值 $\\lambda$ 由特征方程 $\\det(\\mathbf{M}_J - \\lambda\\mathbf{I}) = 0$ 求得：\n$$\n\\det \\begin{bmatrix} -\\lambda  h/k_u \\\\ g/k_T  -\\lambda \\end{bmatrix} = \\lambda^2 - \\frac{hg}{k_u k_T} = 0\n$$\n这给出了特征值 $\\lambda_{1,2} = \\pm \\sqrt{\\frac{hg}{k_u k_T}}$。因此，谱半径为：\n$$\n\\rho_J = \\rho(\\mathbf{M}_J) = \\sqrt{\\frac{hg}{k_u k_T}}\n$$\n\n接下来，我们分析高斯-赛德尔(Gauss-Seidel)分区方案。问题陈述中说明机械变量 $u$ 首先更新，这对应于前向高斯-赛德尔(Gauss-Seidel)迭代。更新规则为 $(\\mathbf{D}+\\mathbf{L})\\mathbf{x}^{(k+1)} = -\\mathbf{U}\\mathbf{x}^{(k)} + \\mathbf{b}$。迭代矩阵 $\\mathbf{M}_{GS}$ 为 $\\mathbf{M}_{GS} = -(\\mathbf{D}+\\mathbf{L})^{-1}\\mathbf{U}$。\n首先，我们求 $(\\mathbf{D}+\\mathbf{L})$ 的逆：\n$$\n(\\mathbf{D}+\\mathbf{L}) = \\begin{bmatrix} k_u  0 \\\\ -g  k_T \\end{bmatrix} \\implies (\\mathbf{D}+\\mathbf{L})^{-1} = \\frac{1}{k_u k_T} \\begin{bmatrix} k_T  0 \\\\ g  k_u \\end{bmatrix} = \\begin{bmatrix} 1/k_u  0 \\\\ g/(k_u k_T)  1/k_T \\end{bmatrix}\n$$\n现在，我们计算 $\\mathbf{M}_{GS}$：\n$$\n\\mathbf{M}_{GS} = - \\begin{bmatrix} 1/k_u  0 \\\\ g/(k_u k_T)  1/k_T \\end{bmatrix} \\begin{bmatrix} 0  -h \\\\ 0  0 \\end{bmatrix} = \\begin{bmatrix} 1/k_u  0 \\\\ g/(k_u k_T)  1/k_T \\end{bmatrix} \\begin{bmatrix} 0  h \\\\ 0  0 \\end{bmatrix} = \\begin{bmatrix} 0  h/k_u \\\\ 0  \\frac{hg}{k_u k_T} \\end{bmatrix}\n$$\n矩阵 $\\mathbf{M}_{GS}$ 是上三角矩阵，因此其特征值是其对角线元素：$\\lambda_1 = 0$ 和 $\\lambda_2 = \\frac{hg}{k_u k_T}$。谱半径是它们绝对值的最大值：\n$$\n\\rho_{GS} = \\rho(\\mathbf{M}_{GS}) = \\left| \\frac{hg}{k_u k_T} \\right| = \\frac{hg}{k_u k_T}\n$$\n由于 $h,g,k_u,k_T$ 均为非负数，绝对值是多余的。\n\n通过比较推导出的谱半径，我们观察到一个直接关系：\n$$\n\\rho_{GS} = \\frac{hg}{k_u k_T} = \\left(\\sqrt{\\frac{hg}{k_u k_T}}\\right)^2 = (\\rho_J)^2\n$$\n这个关系 $\\rho_{GS} = (\\rho_J)^2$ 是对于协调排序矩阵的一个经典结果，而该 $2 \\times 2$ 系统矩阵 $\\mathbf{A}$ 正是如此。这个关系决定了相对收敛速率。当且仅当谱半径严格小于 $1$ 时，迭代收敛。\n\n- 如果 $\\rho_J  1$，那么 $\\rho_{GS} = (\\rho_J)^2  \\rho_J$。两种方案都收敛，且高斯-赛德尔(Gauss-Seidel)严格更快。\n- 如果 $\\rho_J = 1$，那么 $\\rho_{GS} = (\\rho_J)^2 = 1$。两种方案都不收敛，且它们的谱半径相等。\n- 如果 $\\rho_J > 1$，那么 $\\rho_{GS} = (\\rho_J)^2 > \\rho_J$。两种方案都发散，且高斯-赛德尔(Gauss-Seidel)的“发散速率”更差，这意味着在这种情况下，雅可比(Jacobi)被认为“更快”。\n\n基于这些公式，可以编写一个程序来计算测试套件中提供的每组参数 $(k_u, k_T, h, g)$ 所需的量。该程序将计算 $\\rho_J$ 和 $\\rho_{GS}$，通过检查 $\\rho  1$ 来确定每种方案的收敛性，并比较谱半径以确定哪种方案更快。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the thermo-mechanical coupling problem by analyzing Jacobi and Gauss-Seidel\n    partitioned schemes for a set of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (ku, kT, h, g).\n    test_cases = [\n        # Case A\n        (100.0, 50.0, 10.0, 5.0),\n        # Case B\n        (100.0, 100.0, 0.0, 50.0),\n        # Case C\n        (1.0, 1.0, 1.0, 1.0),\n        # Case D\n        (2.0, 3.0, 2.0, 4.0),\n        # Case E\n        (10**6, 1.0, 100.0, 100.0),\n    ]\n\n    results = []\n    # Tolerance for comparing floating-point numbers for equality.\n    TOLERANCE = 1e-12\n\n    for case in test_cases:\n        ku, kT, h, g = case\n\n        # The core parameter governing convergence is the non-dimensional product 'x'.\n        # The problem constraints ku > 0 and kT > 0 prevent division by zero.\n        x = (h * g) / (ku * kT)\n\n        # Calculate the spectral radius for the Jacobi scheme.\n        # Since h, g, ku, kT are non-negative, x is non-negative, so sqrt is safe.\n        rho_j = np.sqrt(x)\n\n        # Calculate the spectral radius for the Gauss-Seidel scheme.\n        # For this 2x2 system, rho_gs is simply x.\n        rho_gs = x\n\n        # Determine convergence for each scheme. Convergence holds if rho  1.\n        jacobi_converges = rho_j  1.0\n        gauss_seidel_converges = rho_gs  1.0\n\n        # Compare the convergence rates based on the spectral radii.\n        winner = 0  # Default: rates are equal\n        if rho_gs  rho_j - TOLERANCE:\n            winner = 1  # Gauss-Seidel is strictly faster\n        elif rho_j  rho_gs - TOLERANCE:\n            winner = 2  # Jacobi is strictly faster\n        \n        # Format the floating-point results to exactly six decimal places.\n        formatted_rho_j = f\"{rho_j:.6f}\"\n        formatted_rho_gs = f\"{rho_gs:.6f}\"\n\n        # Append the list of results for the current case.\n        # Booleans will be automatically converted to \"True\" or \"False\".\n        case_result = (\n            f\"[{formatted_rho_j},{formatted_rho_gs},\"\n            f\"{jacobi_converges},{gauss_seidel_converges},{winner}]\"\n        )\n        results.append(case_result)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of the individual case results,\n    # all enclosed in a single pair of square brackets.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2416751"}, {"introduction": "理解了基本迭代格式后，一个自然的问题是：哪些因素会影响收敛的快慢？物理场之间的耦合强度是一个关键因素。本练习通过一个简化的孔隙弹性模型，让你探究物理耦合强度（由 Biot 系数 $\\alpha$ 代表）如何直接影响分裂格式的收敛性能。你将通过计算达到收敛所需的迭代次数，直观地看到耦合越强，对数值求解方法的挑战越大的这一核心概念。[@problem_id:2416720]", "problem": "考虑一个无量纲的线性双场多孔弹性模型，该模型在经过空间离散和时间离散后，在单个空间自由度上捕捉力学和流动的耦合。对于一个时间步，其单体线性系统通过一个带有对称块的 $2 \\times 2$ 线性系统将位移 $u$ 和孔隙压力 $p$ 耦合起来，\n$$\n\\begin{bmatrix}\n1  \\alpha \\\\\n\\alpha  1\n\\end{bmatrix}\n\\begin{bmatrix}\nu \\\\\np\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nr_1 \\\\\nr_2\n\\end{bmatrix},\n$$\n其中 $\\alpha \\in [0,1]$ 是 Biot 系数，并且该系统已经过无量纲化处理，使得对角块为 $1$，非对角耦合项与 $\\alpha$ 成正比。考虑以下分块高斯-赛德尔不动点格式（一次完整的耦合迭代包括以下两个子步骤）：\n$$\nu^{k+1} = r_1 - \\alpha\\, p^{k}, \\quad\np^{k+1} = r_2 - \\alpha\\, u^{k+1},\n$$\n从任意初始猜测 $(u^{0}, p^{0})$ 开始。将第 $k$ 次迭代的误差定义为 $e_u^{k} = u^{k} - u^{\\star}$ 和 $e_p^{k} = p^{k} - p^{\\star}$，其中 $(u^{\\star}, p^{\\star})$ 表示上述单体系统的精确解。设分块格式的最坏情况下的线性收敛因子为一次完整耦合迭代所引起的从 $e_p^{k}$ 到 $e_p^{k+1}$ 的标量映射的大小，并将其表示为 $\\rho(\\alpha)$。假设 $p$ 的初始误差大小为 $1$，即 $|e_p^{0}| = 1$。对于给定的容差 $\\varepsilon = 10^{-6}$（无量纲），将最小完整耦合迭代次数 $k_{\\min}(\\alpha)$ 定义为使得经过 $k$ 次完整耦合迭代后的最坏情况误差满足 $|e_p^{k}| \\le \\varepsilon$ 的最小非负整数 $k$。如果对于给定的 $\\alpha$，分块格式不减小最坏情况下的误差（即，不收敛），则定义 $k_{\\min}(\\alpha) = -1$。本问题中的所有量都是无量纲的，因此不需要物理单位。\n\n待评估的Biot系数值测试集：\n- $\\alpha = 0$\n- $\\alpha = 0.2$\n- $\\alpha = 0.5$\n- $\\alpha = 0.9$\n- $\\alpha = 0.99$\n- $\\alpha = 1$\n\n您的任务是编写一个完整、可运行的程序，根据上述定义，使用指定的分块高斯-赛德尔格式，计算测试集中每个 $\\alpha$ 对应的 $k_{\\min}(\\alpha)$。最终的程序输出必须是单行文本，包含一个用方括号括起来的、以逗号分隔的整数列表，其顺序与测试集相同，例如 $[k_1,k_2,k_3,k_4,k_5,k_6]$。", "solution": "该问题要求我们分析一个简化的孔隙弹性问题的分块高斯-赛德尔格式的收敛性。该格式的迭代步骤为：\n1.  $u^{k+1} = r_1 - \\alpha p^{k}$\n2.  $p^{k+1} = r_2 - \\alpha u^{k+1}$\n\n为了分析收敛性，我们研究误差的传播。精确解 $(u^{\\star}, p^{\\star})$ 满足：\n$u^{\\star} = r_1 - \\alpha p^{\\star}$\n$p^{\\star} = r_2 - \\alpha u^{\\star}$\n\n定义第 $k$ 次迭代的误差为 $e_u^{k} = u^{k} - u^{\\star}$ 和 $e_p^{k} = p^{k} - p^{\\star}$。从迭代公式中减去精确解的方程，我们得到误差的递推关系：\n$e_u^{k+1} = u^{k+1} - u^{\\star} = (r_1 - \\alpha p^{k}) - (r_1 - \\alpha p^{\\star}) = -\\alpha (p^{k} - p^{\\star}) = -\\alpha e_p^{k}$\n$e_p^{k+1} = p^{k+1} - p^{\\star} = (r_2 - \\alpha u^{k+1}) - (r_2 - \\alpha u^{\\star}) = -\\alpha (u^{k+1} - u^{\\star}) = -\\alpha e_u^{k+1}$\n\n将第一个方程代入第二个方程，我们得到一个关于压力误差 $e_p$ 的独立递推关系：\n$e_p^{k+1} = -\\alpha (-\\alpha e_p^{k}) = \\alpha^2 e_p^{k}$\n\n这个关系表明，在每次完整的高斯-赛德尔迭代后，压力误差会乘以一个因子 $\\alpha^2$。因此，该格式的线性收敛因子为 $\\rho(\\alpha) = \\alpha^2$。\n\n迭代收敛的条件是收敛因子严格小于 1，即 $\\rho(\\alpha) = \\alpha^2  1$，这对于所有 $\\alpha \\in [0, 1)$ 都成立。当 $\\alpha = 1$ 时，$\\rho(\\alpha) = 1$，误差不会减小，因此格式不收敛。\n\n我们要求解的是最小迭代次数 $k_{\\min}$，使得 $|e_p^{k}| \\le \\varepsilon$，其中初始误差 $|e_p^{0}| = 1$，容差 $\\varepsilon = 10^{-6}$。\n由于 $|e_p^{k}| = \\rho(\\alpha)^k |e_p^{0}| = (\\alpha^2)^k$，我们需要求解 $(\\alpha^2)^k \\le \\varepsilon$。\n- 如果 $\\alpha = 1$，则 $\\rho=1$，不等式变为 $1 \\le \\varepsilon$，这是错误的。因此，迭代不收敛，$k_{\\min}=-1$。\n- 如果 $\\alpha \\in [0, 1)$，我们可以对不等式两边取对数：\n  $k \\log(\\alpha^2) \\le \\log(\\varepsilon)$\n  因为 $\\alpha  1$，所以 $\\log(\\alpha^2)$ 是负数。因此，当我们除以它时，不等号的方向会反转：\n  $k \\ge \\frac{\\log(\\varepsilon)}{\\log(\\alpha^2)}$\n由于 $k$ 必须是整数，我们需要的最小迭代次数是该值的上取整：\n$k_{\\min}(\\alpha) = \\lceil \\frac{\\log(\\varepsilon)}{\\log(\\alpha^2)} \\rceil$。\n\n对于 $\\alpha=0$ 的特殊情况，$\\rho=0$。$e_p^1 = 0 \\cdot e_p^0 = 0$。因此在一次迭代后误差就为零，满足收敛条件。所以 $k_{\\min}(0) = 1$。\n基于此分析，我们可以为测试集中的每个 $\\alpha$ 值计算 $k_{\\min}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the minimal number of full coupling iterations k_min(alpha)\n    for a partitioned Gauss-Seidel scheme to reach a given tolerance.\n    \"\"\"\n    # Test suite of Biot coefficient values to evaluate.\n    test_cases = [0.0, 0.2, 0.5, 0.9, 0.99, 1.0]\n    \n    # Tolerance for convergence.\n    epsilon = 1e-6\n    \n    results = []\n    \n    for alpha in test_cases:\n        # The convergence factor rho(alpha) is alpha^2, as derived from\n        # the error propagation equation e_p^(k+1) = alpha^2 * e_p^k.\n        \n        # Case 1: alpha = 1.0. rho = 1, scheme does not converge.\n        if alpha == 1.0:\n            k_min = -1\n        # Case 2: alpha = 0.0. rho = 0.\n        # The error becomes 0 after one iteration.\n        # For k=0, error is 1. For k=1, error is 0. So k_min = 1.\n        elif alpha == 0.0:\n            k_min = 1\n        # Case 3: 0  alpha  1. The scheme converges.\n        else:\n            # The convergence factor.\n            rho = alpha**2\n            \n            # We need to find the smallest non-negative integer k such that:\n            # |e_p^k| = epsilon\n            # Since |e_p^0| = 1, we have |e_p^k| = rho^k.\n            # So, we solve rho^k = epsilon for k.\n            # k * log(rho) = log(epsilon)\n            # k >= log(epsilon) / log(rho) (inequality flips as log(rho) is negative)\n            \n            # Since k must be an integer, we take the ceiling.\n            k_min_float = np.log(epsilon) / np.log(rho)\n            k_min = int(np.ceil(k_min_float))\n            \n        results.append(k_min)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2416720"}, {"introduction": "当面对强耦合问题导致收敛缓慢甚至发散时，我们并非束手无策。引入松弛技术是应对这一挑战的有力工具。本练习通过一个流固耦合（FSI）的线性代理模型，让你实践如何运用欠松弛（under-relaxation）方法来控制和改善收敛性。你将通过调节松弛因子 $\\omega$，亲眼见证一个发散的迭代过程如何转变为收敛，或一个缓慢收敛的过程如何被加速，这是计算工程师必须掌握的一项实用技能。[@problem_id:2416670]", "problem": "给定一个在单界面自由度上的分区流固耦合（FSI）定点耦合的线性代理模型。界面变量由一个标量 $u \\in \\mathbb{R}$ 表示。该分区耦合将当前界面值 $u^{(k)}$ 映射到一个新的预测值 $g(u^{(k)})$，该预测值编码了流体和结构子问题的响应。对于此问题，使用一个线性化代理模型\n$$\ng(u) = \\alpha u + \\beta,\n$$\n其中常数 $\\alpha \\in \\mathbb{R}$ 和 $\\beta \\in \\mathbb{R}$。使用参数 $\\omega \\in (0,1]$ 的欠松弛定义了迭代更新\n$$\nu^{(k+1)} = u^{(k)} + \\omega \\left(g(u^{(k)}) - u^{(k)}\\right).\n$$\n将非线性残差定义为\n$$\nr^{(k)} = g(u^{(k)}) - u^{(k)}.\n$$\n对于给定的参数集，当 $\\lvert r^{(k)} \\rvert \\le \\varepsilon$ 时，称耦合迭代已收敛，其中 $\\varepsilon  0$ 是一个预设的容差。如果迭代在 $N_{\\max}$ 次迭代内不收敛，则对于该参数集，将其视为不收敛。\n\n实现一个程序，对于下面列出的每个测试用例，计算从初始猜测 $u^{(0)} = 0$ 开始，对于指定集合中的每个 $\\omega$ 值，满足 $\\lvert r^{(k)} \\rvert \\le \\varepsilon$ 所需的耦合迭代次数。如果在 $N_{\\max}$ 次迭代内未达到收敛，则为该 $(\\alpha,\\omega)$ 对记录值 $-1$。\n\n对所有测试用例使用以下共享常量：\n- 初始猜测 $u^{(0)} = 0$。\n- 容差 $\\varepsilon = 10^{-8}$。\n- 最大迭代次数 $N_{\\max} = 200000$。\n- 松弛参数集 $\\Omega = \\{\\,0.1,\\,0.3,\\,0.5,\\,0.7,\\,0.9,\\,1.0\\,\\}$。\n\n使用以下参数值的测试套件：\n- 测试用例 1：$\\alpha = 0.2$，$\\beta = 1.0$。\n- 测试用例 2：$\\alpha = 0.8$，$\\beta = 1.0$。\n- 测试用例 3：$\\alpha = 0.99$，$\\beta = 1.0$。\n- 测试用例 4：$\\alpha = 1.05$，$\\beta = 1.0$。\n\n对于每个测试用例，生成与 $\\omega \\in \\Omega$ 的有序值相对应的迭代计数的序列。您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的列表的列表（无空格）。具体来说，输出必须是\n$$\n[\\,[n_{1,1},n_{1,2},n_{1,3},n_{1,4},n_{1,5},n_{1,6}],\\,[n_{2,1},\\dots,n_{2,6}],\\,[n_{3,1},\\dots,n_{3,6}],\\,[n_{4,1},\\dots,n_{4,6}]\\,],\n$$\n其中 $n_{i,j}$ 是测试用例 $i$ 和松弛参数 $\\omega$ 等于 $\\Omega$ 的第 $j$ 个元素时的迭代次数，如果不收敛则为 $-1$。此问题不涉及物理单位，也不需要角度或百分比。", "solution": "所提出的问题是数值分析中一个定义明确的练习，具体涉及带欠松弛的定点迭代的收敛特性。严谨的数学验证证实了该问题是科学上合理、自洽且客观的。因此，我们可以着手进行有原则的求解。\n\n该问题描述了一个用于寻找方程 $u = g(u)$ 解 $u$ 的定点迭代，其中 $g(u)$ 是由下式给出的线性代理函数：\n$$\ng(u) = \\alpha u + \\beta\n$$\n迭代更新规则由欠松弛参数 $\\omega \\in (0,1]$ 定义：\n$$\nu^{(k+1)} = u^{(k)} + \\omega \\left(g(u^{(k)}) - u^{(k)}\\right)\n$$\n量 $r^{(k)} = g(u^{(k)}) - u^{(k)}$ 被定义为第 $k$ 次迭代时的残差。当给定容差 $\\varepsilon > 0$ 时，如果满足 $|r^{(k)}| \\le \\varepsilon$，则达到收敛。该过程从初始猜测 $u^{(0)} = 0$ 开始。\n\n首先，我们分析残差的动力学。使用线性代理模型的残差为：\n$$\nr^{(k)} = (\\alpha u^{(k)} + \\beta) - u^{(k)} = (\\alpha - 1)u^{(k)} + \\beta\n$$\n状态变量 $u$ 的更新规则可以紧凑地表示为 $u^{(k+1)} = u^{(k)} + \\omega r^{(k)}$。利用这一点，我们可以推导出残差本身的递推关系：\n$$\nr^{(k+1)} = (\\alpha - 1)u^{(k+1)} + \\beta = (\\alpha - 1)(u^{(k)} + \\omega r^{(k)}) + \\beta\n$$\n$$\nr^{(k+1)} = ((\\alpha - 1)u^{(k)} + \\beta) + \\omega(\\alpha - 1)r^{(k)}\n$$\n认识到括号中的项正是 $r^{(k)}$，我们得到了一个关于残差的简单几何级数：\n$$\nr^{(k+1)} = r^{(k)} \\left(1 + \\omega(\\alpha - 1)\\right)\n$$\n这个递推关系的解是 $r^{(k)} = r^{(0)} C^k$，其中 $C = 1 + \\omega(\\alpha - 1)$ 是收缩因子。初始残差，在 $u^{(0)} = 0$ 的情况下，是 $r^{(0)} = (\\alpha-1)(0) + \\beta = \\beta$。因此，任意一次迭代的残差由下式给出：\n$$\nr^{(k)} = \\beta \\left(1 + \\omega(\\alpha - 1)\\right)^k\n$$\n为了使迭代收敛，残差的绝对值必须趋于零，这要求收缩因子的绝对值严格小于一：\n$$\n|C| = |1 + \\omega(\\alpha - 1)|  1\n$$\n这个不等式等价于 $-1  1 + \\omega(\\alpha - 1)  1$，可以简化为 $-2  \\omega(\\alpha - 1)  0$。由于问题指定 $\\omega \\in (0,1]$，我们可以除以 $\\omega$ 来得到关于 $\\alpha$ 的条件：\n$$\n1 - \\frac{2}{\\omega}  \\alpha  1\n$$\n这个条件使我们能够预测每个测试用例的行为：\n1.  对于测试用例1、2和3，其中 $\\alpha$ 分别为 0.2、0.8 和 0.99，条件 $\\alpha  1$ 得到满足。左侧不等式 $\\omega  \\frac{2}{1-\\alpha}$ 对于所有指定的 $\\omega \\in \\Omega = \\{0.1, 0.3, 0.5, 0.7, 0.9, 1.0\\}$ 也得到满足，因为 $\\omega$ 的相应上界分别为 2.5、10 和 200。因此，在这三种情况下，预计所有参数组合都会收敛。\n2.  对于测试用例4，其中 $\\alpha = 1.05$，条件 $\\alpha  1$ 被违反。收缩因子 $|C| = |1 + \\omega(0.05)| = 1 + 0.05\\omega$ 对于任何 $\\omega > 0$ 都将严格大于 1。残差的绝对值将增长，迭代将发散。\n\n计算任务是实现迭代过程并计算直到收敛的步数。对于每对参数 $(\\alpha, \\beta)$ 和每个松弛因子 $\\omega$ 的算法如下：\n1.  初始化迭代计数器 $k = 0$ 和状态变量 $u \\leftarrow u^{(0)} = 0$。\n2.  对 $k$ 从 $0$ 到 $N_{\\max} = 200000$ 进行循环。\n3.  在循环内部，在步骤 $k$：\n    a. 计算当前残差 $r \\leftarrow (\\alpha - 1)u + \\beta$。\n    b. 检查收敛准则：如果 $|r| \\le \\varepsilon = 10^{-8}$，则迭代已收敛。所需的迭代次数为 $k$。记录此值并终止当前参数集的循环。\n    c. 如果未收敛，则更新状态变量以进行下一次迭代：$u \\leftarrow u + \\omega r$。\n4.  如果循环完成了所有 $N_{\\max}+1$ 次检查（从 $k=0$ 到 $k=N_{\\max}$）而未满足收敛准则，则该过程被视为不收敛。记录值 $-1$。\n\n将对所有测试用例和集合 $\\Omega$ 中的所有 $\\omega$ 值执行此算法，以生成所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef solve():\n    \"\"\"\n    Computes the number of iterations for a partitioned fixed-point coupling\n    scheme to converge for a set of test cases.\n    \"\"\"\n    # Define the constants shared by all test cases.\n    u_initial = 0.0\n    epsilon = 1e-8\n    N_max = 200000\n    omegas = [0.1, 0.3, 0.5, 0.7, 0.9, 1.0]\n\n    # Define the test suite of parameter values.\n    test_cases = [\n        (0.2, 1.0),   # Test case 1\n        (0.8, 1.0),   # Test case 2\n        (0.99, 1.0),  # Test case 3\n        (1.05, 1.0),  # Test case 4\n    ]\n\n    all_results = []\n    for alpha, beta in test_cases:\n        case_results = []\n        for omega in omegas:\n            u = u_initial\n            converged = False\n\n            # The loop runs for k from 0 to N_max.\n            # At iteration k, we inspect the state u_k and residual r_k.\n            # If convergence is not met, we perform an update to get u_{k+1}.\n            # If we perform N_max updates, we have checked up to k=N_max.\n            for k in range(N_max + 1):\n                # Calculate the residual: r_k = g(u_k) - u_k\n                residual = (alpha - 1.0) * u + beta\n\n                # Check for convergence\n                if abs(residual) = epsilon:\n                    case_results.append(k)\n                    converged = True\n                    break\n\n                # Update the interface variable for the next iteration\n                u = u + omega * residual\n\n            # If the loop finished without convergence\n            if not converged:\n                case_results.append(-1)\n        \n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified in the problem statement.\n    # The format requirement is a comma-separated list of lists with no spaces.\n    # e.g., [[n1,n2],[n3,n4]]\n    output_str = f\"[{','.join(f'[{\",\".join(map(str, res))}]' for res in all_results)}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2416670"}]}