{"hands_on_practices": [{"introduction": "水平集方法通过平流一个标量函数 $\\phi$ 来演化界面。然而，平流过程可能使 $\\phi$ 函数偏离其理想的符号距离函数属性，从而影响曲率等几何量的精确计算。这项实践 [@problem_id:2408606] 将引导你模拟一个旋转的圆形，以探究周期性重新初始化作为维持计算精度的关键步骤，其重要作用。", "problem": "考虑一个用于追踪界面的二维水平集方法。设计算域为正方形 $[-1,1] \\times [-1,1]$，在两个方向上均采用周期性边界条件。令 $\\phi(x,y,t)$ 表示一个水平集函数，其零水平集 $\\{\\,(x,y)\\,:\\,\\phi(x,y,t)=0\\,\\}$ 代表一条在给定欧拉速度场下演化的闭合曲线。$\\phi$ 的演化由线性平流方程决定\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v}(x,y)\\cdot \\nabla \\phi = 0,\n$$\n其中 $\\mathbf{v}(x,y) = \\big(-\\omega\\,y,\\ \\omega\\,x\\big)$（$\\omega = 2\\pi$）是一个无散旋转速度场。\n\n初始条件是到以原点为中心、半径为 $R=0.5$ 的圆的符号距离函数：\n$$\n\\phi(x,y,0) = \\sqrt{x^2 + y^2} - R,\n$$\n使得在圆外 $\\phi0$，在圆内 $\\phi0$。最终物理时间为 $T=1$，对应于在给定 $\\omega$ 下的一次完整旋转。\n\n为了减轻平流过程中 $\\phi$ 偏离符号距离函数的失真，以预设的整数频率应用重置化。定义一个重置化算子 $\\mathcal{R}[\\phi]$，它将 $\\phi$ 替换为其当前零水平集的符号距离函数，并精确保留集合 $\\{(x,y):\\phi=0\\}$。给定一个正整数 $f$（重置化频率），规则是：每 $f$ 个物理时间步后，替换 $\\phi \\leftarrow \\mathcal{R}[\\phi]$。特殊情况 $f=0$ 表示在 $t=0$ 之后不执行重置化。\n\n由水平集函数 $\\phi$ 计算出的零水平集的平均曲率 $\\kappa$ 定义为\n$$\n\\kappa = \\nabla \\cdot \\left(\\frac{\\nabla \\phi}{\\lVert \\nabla \\phi \\rVert}\\right).\n$$\n对于半径为 $R$ 的圆，界面上的精确平均曲率为常数 $\\kappa_{\\mathrm{ref}} = 1/R$。在最终时间 $T$，定义窄带集\n$$\n\\mathcal{B}_h = \\{(x_i,y_j): |\\phi(x_i,y_j,T)| \\le 2h\\},\n$$\n其中 $h$ 是均匀网格间距。如果 $\\mathcal{B}_h$ 为空，则使用备用集 $\\mathcal{B}_{3h} = \\{(x_i,y_j): |\\phi(x_i,y_j,T)| \\le 3h\\}$。则在时间 $T$ 的曲率均方根误差为\n$$\nE = \\left( \\frac{1}{|\\mathcal{B}|} \\sum_{(i,j)\\in \\mathcal{B}} \\big(\\kappa_{ij} - \\kappa_{\\mathrm{ref}}\\big)^2 \\right)^{1/2},\n$$\n其中 $\\mathcal{B}$ 表示所选的带集， $|\\mathcal{B}|$ 为其基数，$\\kappa_{ij}$ 表示在网格节点 $(x_i,y_j)$ 处由最终时间 $\\phi$ 计算出的离散曲率。\n\n在 $[-1,1]$ 上使用均匀笛卡尔网格，每个空间方向有 $N=81$ 个节点，因此 $h = 2/(N-1)$。选择一个常数 Courant–Friedrichs–Lewy 数 $c=0.3$ 并将时间步长设置为\n$$\n\\Delta t = \\frac{c\\,h}{V_{\\max}},\n$$\n其中 $V_{\\max} = \\max_{(x,y)\\in [-1,1]^2} \\|\\mathbf{v}(x,y)\\| = \\omega \\sqrt{2}$。使用所需数量的时间步，以使总时间恰好等于 $T$。\n\n测试套件：\n- 网格大小 $N=81$，最终时间 $T=1$，旋转速率 $\\omega=2\\pi$，圆半径 $R=0.5$，Courant 数 $c=0.3$。\n- 重置化频率 $f \\in \\{1,5,20,0\\}$。\n\n对于测试套件中的每个 $f$，计算在时间 $T$ 的曲率误差 $E$，如上定义。\n\n您的程序应生成单行输出，其中包含四个曲率误差，按频率 $\\{1,5,20,0\\}$ 的顺序排列，每个误差四舍五入到 $6$ 位小数，以逗号分隔并用方括号括起，例如 $[\\text{e1},\\text{e2},\\text{e3},\\text{e4}]$。不涉及物理单位；所有量均为无量纲。角度（在 $\\omega$ 中隐含）以弧度为单位。最终输出必须遵循所述的精确格式。", "solution": "所提出的问题是计算工程领域中一个适定的数值练习，具体涉及用于界面追踪的水平集方法。它具有科学依据，是客观的，并包含足够的信息来构建唯一的数值解。我将进行严谨的求解。\n\n该问题要求对水平集函数 $\\phi(x,y,t)$ 的线性平流方程进行数值求解，该方程由下式给出\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\mathbf{v}(x,y)\\cdot \\nabla \\phi = 0\n$$\n在具有周期性边界条件的域 $\\Omega = [-1,1] \\times [-1,1]$ 上。速度场 $\\mathbf{v}(x,y) = (-\\omega y, \\omega x)$（$\\omega = 2\\pi$）描述了围绕原点的刚体旋转。初始条件是针对以原点为中心、半径为 $R=0.5$ 的圆的符号距离函数（SDF）：\n$$\n\\phi(x,y,0) = \\sqrt{x^2 + y^2} - R.\n$$\n模拟将运行至最终时间 $T=1$，这恰好对应一次完整的旋转。核心任务是分析以不同频率 $f$ 应用的重置化过程对最终时间零水平集计算出的平均曲率 $\\kappa$ 精度的影响。\n\n首先，我们必须建立一个合适的数值格式。该域使用均匀笛卡尔网格进行离散化，每个方向有 $N=81$ 个节点。因此，网格间距为 $h = 2/(N-1)$。二维点网格 $(x_i, y_j)$ 定义为 $x_i = -1 + i h$ 和 $y_j = -1 + j h$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。\n\n对于时间积分，显式时间步进格式是合适的。我们使用前向欧拉法。时间步长 $\\Delta t$ 必须满足 Courant–Friedrichs–Lewy (CFL) 条件以确保稳定性。问题指定了一个常数 CFL 数 $c=0.3$，从而得到时间步长 $\\Delta t = c \\cdot h / V_{\\max}$，其中 $V_{\\max}$ 是域上的最大速度大小。对于给定的速度场 $\\mathbf{v}$，最大速度大小出现在域的角点，例如在 $(x,y)=(1,1)$ 处，得到 $V_{\\max} = \\lVert(-\\omega,\\omega)\\rVert = \\omega\\sqrt{2}$。为确保总模拟时间恰好为 $T$，我们首先计算名义时间步长 $\\Delta t_{\\text{nom}} = c h / V_{\\max}$，然后计算所需的步数 $N_{\\text{steps}} = \\lceil T / \\Delta t_{\\text{nom}} \\rceil$，最后使用调整后的时间步长 $\\Delta t=T/N_{\\text{steps}}$。\n\n空间导数项 $\\mathbf{v} \\cdot \\nabla \\phi$ 使用一阶迎风有限差分格式进行离散化。这一选择对于平流方程数值解的稳定性至关重要。对于网格点 $(i,j)$，该项近似为：\n$$\n(\\mathbf{v} \\cdot \\nabla \\phi)|_{i,j} \\approx v_{x,ij}^+ \\frac{\\phi_{i,j} - \\phi_{i-1,j}}{h} + v_{x,ij}^- \\frac{\\phi_{i+1,j} - \\phi_{i,j}}{h} + v_{y,ij}^+ \\frac{\\phi_{i,j} - \\phi_{i,j-1}}{h} + v_{y,ij}^- \\frac{\\phi_{i,j+1} - \\phi_{i,j}}{h}\n$$\n其中 $v_x^+ = \\max(v_x, 0)$，$v_x^- = \\min(v_x, 0)$，$v_y$ 也类似。周期性边界条件通过在域边界处对有限差分模板使用环绕索引来强制执行。\n\n因此，数值循环的核心变为：$\\phi^{n+1}_{i,j} = \\phi^n_{i,j} - \\Delta t (\\mathbf{v} \\cdot \\nabla \\phi)^n_{i,j}$。此循环执行 $N_{\\text{steps}}$ 次。\n\n平流格式倾向于扭曲水平集函数，使其不再是真正的符号距离函数（SDF）。为抵消此影响，应用了一个表示为 $\\mathcal{R}[\\phi]$ 的重置化过程。问题规定，每 $f$ 个时间步后，场 $\\phi$ 被替换为 $\\mathcal{R}[\\phi]$，即 $\\phi$ 当前零水平集的精确符号距离函数。对于 $f=0$，不执行重置化。一种数值上高效且准确的执行重置化的方法是使用距离变换。我们将利用 `scipy.ndimage.distance_transform_edt` 函数，该函数计算精确的欧几里得距离变换。过程如下：\n1. 识别 $\\phi \\ge 0$ 和 $\\phi  0$ 的区域。\n2. 计算 $\\phi \\ge 0$ 区域中每个点到 $\\phi  0$ 区域中最近点的距离。记为 $d_+$。\n3. 计算 $\\phi  0$ 区域中每个点到 $\\phi \\ge 0$ 区域中最近点的距离。记为 $d_-$。\n4. 那么，重置化后的符号距离函数由 $\\phi_{\\text{new}} = d_+ - d_-$ 给出。\n\n在最终时间 $T$，我们从最终的水平集场 $\\phi_T$ 计算平均曲率 $\\kappa$。曲率的公式为 $\\kappa = \\nabla \\cdot (\\nabla \\phi / \\lVert \\nabla \\phi \\rVert)$。为了进行数值计算，我们对所有空间导数使用二阶中心差分以确保更高的精度。步骤如下：\n1. 使用中心差分计算梯度分量 $\\phi_x = \\partial \\phi / \\partial x$ 和 $\\phi_y = \\partial \\phi / \\partial y$。例如，$(\\phi_x)_{i,j} = (\\phi_{i+1,j} - \\phi_{i-1,j})/(2h)$。\n2. 计算梯度的大小 $\\lVert \\nabla \\phi \\rVert = \\sqrt{\\phi_x^2 + \\phi_y^2}$。在平方根下添加一个小的正则化参数 $\\epsilon$（例如 $10^{-12}$）以防止在 $\\nabla \\phi = 0$ 处出现除以零的情况。\n3. 计算法向量场的分量：$n_x = \\phi_x / \\lVert \\nabla \\phi \\rVert$ 和 $n_y = \\phi_y / \\lVert \\nabla \\phi \\rVert$。\n4. 再次使用中心差分计算法向量场的散度 $\\kappa = \\partial n_x / \\partial x + \\partial n_y / \\partial y$。\n\n最后，计算均方根误差 $E$。误差在界面周围的一个窄带 $\\mathcal{B}$ 上进行评估。该带定义为 $\\mathcal{B}_h = \\{(x_i,y_j): |\\phi(x_i,y_j,T)| \\le 2h\\}$，如果主带为空，则回退到更宽的带 $\\mathcal{B}_{3h}$。半径为 $R$ 的圆的参考曲率为 $\\kappa_{\\mathrm{ref}} = 1/R = 1/0.5 = 2$。则误差为：\n$$\nE = \\left( \\frac{1}{|\\mathcal{B}|} \\sum_{(i,j)\\in \\mathcal{B}} \\big(\\kappa_{ij} - \\kappa_{\\mathrm{ref}}\\big)^2 \\right)^{1/2}\n$$\n其中 $|\\mathcal{B}|$ 是带中网格点的数量。\n\n该算法将对每个指定的重置化频率 $f \\in \\{1, 5, 20, 0\\}$ 执行，并且生成的曲率误差将以规定的格式报告。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.ndimage import distance_transform_edt\n\ndef solve():\n    \"\"\"\n    Solves the level-set advection problem and computes curvature errors for\n    different reinitialization frequencies.\n    \"\"\"\n    # Define problem parameters from the statement\n    N = 81\n    R = 0.5\n    omega = 2.0 * np.pi\n    T = 1.0\n    c = 0.3\n    frequencies = [1, 5, 20, 0]\n\n    # Derived parameters\n    domain_length = 2.0\n    h = domain_length / (N - 1)\n    kappa_ref = 1.0 / R\n\n    # Setup computational grid\n    x = np.linspace(-1.0, 1.0, N)\n    y = np.linspace(-1.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='ij')\n\n    # Initial condition: signed distance function for a circle\n    phi_initial = np.sqrt(X**2 + Y**2) - R\n\n    # Velocity field\n    vx = -omega * Y\n    vy = omega * X\n\n    # Time step calculation\n    V_max = omega * np.sqrt(2.0)\n    dt_nominal = c * h / V_max\n    num_steps = int(np.ceil(T / dt_nominal))\n    dt = T / num_steps\n\n    def advect_step(phi, vx, vy, dt, h):\n        \"\"\"Performs one step of advection using first-order upwinding.\"\"\"\n        # Forward and backward differences for phi_x\n        phi_x_fwd = (np.roll(phi, -1, axis=0) - phi) / h\n        phi_x_bwd = (phi - np.roll(phi, 1, axis=0)) / h\n        # Forward and backward differences for phi_y\n        phi_y_fwd = (np.roll(phi, -1, axis=1) - phi) / h\n        phi_y_bwd = (phi - np.roll(phi, 1, axis=1)) / h\n\n        # Upwind scheme based on velocity sign\n        vx_pos = np.maximum(vx, 0)\n        vx_neg = np.minimum(vx, 0)\n        vy_pos = np.maximum(vy, 0)\n        vy_neg = np.minimum(vy, 0)\n\n        # Gradient term using upwinding\n        grad_phi_x = vx_pos * phi_x_bwd + vx_neg * phi_x_fwd\n        grad_phi_y = vy_pos * phi_y_bwd + vy_neg * phi_y_fwd\n\n        # Forward Euler time step\n        phi_new = phi - dt * (grad_phi_x + grad_phi_y)\n        return phi_new\n\n    def reinitialize(phi, h):\n        \"\"\"Reinitializes phi to a signed distance function.\"\"\"\n        # Note: distance_transform_edt computes distance to the nearest 0-pixel.\n        # We want distance to the interface (zero-crossing).\n        # We can compute the distance from outside-points to inside-points,\n        # and from inside-points to outside-points.\n        # The new SDF is the difference between these two distances.\n        neg_mask = phi  0\n        pos_mask = phi >= 0\n        \n        # The `sampling` argument scales the output distances by the grid spacing.\n        dist_to_neg = distance_transform_edt(pos_mask, sampling=[h, h])\n        dist_to_pos = distance_transform_edt(neg_mask, sampling=[h, h])\n        \n        phi_reinit = dist_to_neg - dist_to_pos\n        return phi_reinit\n\n    def calculate_curvature(phi, h):\n        \"\"\"Calculates curvature using central differences.\"\"\"\n        # Gradient of phi (central differences)\n        phi_x = (np.roll(phi, -1, axis=0) - np.roll(phi, 1, axis=0)) / (2 * h)\n        phi_y = (np.roll(phi, -1, axis=1) - np.roll(phi, 1, axis=1)) / (2 * h)\n\n        # Norm of the gradient (with regularization)\n        grad_norm = np.sqrt(phi_x**2 + phi_y**2 + 1e-12)\n\n        # Normal vector components\n        nx = phi_x / grad_norm\n        ny = phi_y / grad_norm\n\n        # Divergence of the normal field (central differences)\n        nx_x = (np.roll(nx, -1, axis=0) - np.roll(nx, 1, axis=0)) / (2 * h)\n        ny_y = (np.roll(ny, -1, axis=1) - np.roll(ny, 1, axis=1)) / (2 * h)\n\n        kappa = nx_x + ny_y\n        return kappa\n\n    results = []\n    for f in frequencies:\n        phi = phi_initial.copy()\n\n        for step in range(1, num_steps + 1):\n            phi = advect_step(phi, vx, vy, dt, h)\n            \n            if f > 0 and step % f == 0:\n                phi = reinitialize(phi, h)\n        \n        # Final calculations at time T\n        kappa = calculate_curvature(phi, h)\n        \n        # Define narrow band for error calculation\n        band = np.abs(phi) = 2 * h\n        if not np.any(band):\n            band = np.abs(phi) = 3 * h\n\n        # Calculate RMS error in curvature on the band\n        kappa_on_band = kappa[band]\n        error = np.sqrt(np.mean((kappa_on_band - kappa_ref)**2))\n        results.append(error)\n\n    # Format the final output\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2408606"}, {"introduction": "由 Allen-Cahn 方程描述的相场系统的演化，本质上是一个总自由能最小化的过程，这一能量耗散原理是该方法的基石。通过本练习 [@problem_id:2408607]，你将对 Allen-Cahn 动力学进行数值模拟，并验证 Ginzburg-Landau 自由能 $\\mathcal{F}[\\phi]$ 确实随时间单调递减，从而证实其梯度流的性质。", "problem": "考虑一个一维周期域上的标量相场 $ \\phi(x,t) $ 的 Ginzburg–Landau 自由能泛函，\n$$\n\\mathcal{F}[\\phi] \\;=\\; \\int_{0}^{L} \\left( \\frac{\\varepsilon^2}{2}\\, |\\partial_x \\phi|^2 \\;+\\; \\frac{1}{4}\\,(\\phi^2 - 1)^2 \\right)\\, \\mathrm{d}x,\n$$\n其中迁移率 $ M  0 $，界面厚度参数 $ \\varepsilon  0 $。Allen–Cahn 动力学是 $ \\mathcal{F} $ 的 $L^2$ 梯度流，即偏微分方程（PDE）\n$$\n\\partial_t \\phi \\;=\\; -\\, M \\,\\frac{\\delta \\mathcal{F}}{\\delta \\phi}\n\\;=\\; -\\, M \\,\\Big( -\\,\\varepsilon^2 \\,\\partial_{xx}\\phi \\;+\\; \\phi^3 \\;-\\; \\phi \\Big),\n$$\n在 $ x \\in [0,L] $ 上满足周期性边界条件。假设初始条件为\n$$\n\\phi(x,0) \\;=\\; 0.3\\,\\sin\\!\\Big(\\frac{2\\pi x}{L}\\Big) \\;+\\; 0.2\\,\\sin\\!\\Big(\\frac{4\\pi x}{L}\\Big).\n$$\n设时间范围为 $ t \\in [0, T] $，以均匀步长 $ \\Delta t  0 $ 进行采样，空间域用 $ N \\in \\mathbb{N} $ 个点均匀离散，并满足周期性边界条件。定义化学势\n$$\n\\mu \\;=\\; \\frac{\\delta \\mathcal{F}}{\\delta \\phi} \\;=\\; -\\,\\varepsilon^2 \\,\\partial_{xx}\\phi \\;+\\; \\phi^3 \\;-\\; \\phi.\n$$\n根据第一性原理，有\n$$\n\\frac{\\mathrm{d}}{\\mathrm{d}t}\\,\\mathcal{F}[\\phi(t)] \\;=\\; -\\, M \\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x \\;\\le\\; 0,\n$$\n因此该动力学是 $ \\mathcal{F} $ 的梯度下降。\n\n任务：编写一个完整且可运行的程序，对下面的每个测试用例，模拟 $ t \\in [0,T] $ 上的 $ \\phi(x,t) $，计算沿轨迹的离散自由能 $ \\mathcal{F} $，并返回：\n- 一个布尔值，指示计算出的离散能量序列在容差 $ \\tau_{\\mathrm{mono}} $ 内是否非增，要求是在所有离散时间点上满足 $ \\mathcal{F}(t_{n+1}) \\le \\mathcal{F}(t_n) + \\tau_{\\mathrm{mono}} $，其中 $ \\tau_{\\mathrm{mono}} = 10^{-8}\\,\\mathcal{F}(t_0) $，\n- 一个浮点数，等于净能量下降与梯度下降恒等式预测的时间积分耗散之间的相对差异，即\n$$\nr \\;=\\; \\frac{\\big| \\, \\big( \\mathcal{F}(T) - \\mathcal{F}(0) \\big) \\;+\\; M \\int_{0}^{T}\\!\\!\\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x\\,\\mathrm{d}t \\,\\big|}{\\max\\!\\big(1,\\,|\\mathcal{F}(0)|\\big)}.\n$$\n\n所有量均为无量纲；不需要物理单位。三角函数中的角度（如果存在）以弧度为单位。你使用的数值近似方法必须与上述定义一致。\n\n测试集（每个用例是一个元组（L, N, ε, M, Δt, T））：\n- 用例 $1$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 256,\\, 0.02,\\, 1.0,\\, 5\\times 10^{-5},\\, 0.02)$。\n- 用例 $2$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 128,\\, 0.03,\\, 0.5,\\, 5\\times 10^{-5},\\, 0.015)$。\n- 用例 $3$：$(L, N, \\varepsilon, M, \\Delta t, T) = (1.0,\\, 256,\\, 0.05,\\, 1.0,\\, 1\\times 10^{-4},\\, 0.03)$。\n\n你的程序必须生成单行输出，其中包含测试集的汇总结果，格式为方括号括起来的逗号分隔列表，顺序必须严格为 $[\\text{is\\_decreasing}_{1}, r_{1}, \\text{is\\_decreasing}_{2}, r_{2}, \\text{is\\_decreasing}_{3}, r_{3}]$，其中 $ \\text{is\\_decreasing}_{i} $ 是用例 $ i $ 的布尔值，$ r_i $ 是对应的浮点数。", "solution": "该问题要求对一维周期域上的 Allen-Cahn 偏微分方程（PDE）进行数值模拟。该方程描述了标量相场 $\\phi(x,t)$ 的时间演化，并代表了 Ginzburg-Landau 自由能泛函 $\\mathcal{F}[\\phi]$ 的 $L^2$ 梯度流。目标是使用数值方案验证该梯度流的两个基本性质：自由能的单调递减性和将总能量变化与时间积分耗散联系起来的守恒定律。\n\n求解 Allen-Cahn 方程需要一种稳健的数值方法，因为它是一个刚性的非线性反应扩散方程。刚性源于拉普拉斯项 $\\varepsilon^2 \\partial_{xx}\\phi$，特别是当界面厚度参数 $\\varepsilon$ 很小时，因为它引入了与不同空间频率相关的广泛时间尺度。\n\n此处采用的数值策略基于用于空间离散的傅里叶伪谱法和用于时间积分的一阶隐式-显式（IMEX）格式。对于周期域上的此类问题，这种组合非常有效。\n\n首先，我们将空间域 $x \\in [0, L]$ 离散为 $N$ 个等距点 $x_j = j \\Delta x$，其中 $j = 0, 1, \\ldots, N-1$，网格间距为 $\\Delta x = L/N$。相场由向量 $\\boldsymbol{\\phi}(t)$ 表示，其中分量 $\\phi_j(t)$ 近似于 $\\phi(x_j, t)$。\n\n傅里叶伪谱法因其在周期性边界条件下近似空间导数的谱精度而被选用。我们使用离散傅里叶变换（DFT）及其逆变换，分别表示为 $\\mathcal{F}_k$ 和 $\\mathcal{F}_k^{-1}$。相场向量 $\\boldsymbol{\\phi}$ 的 DFT 为 $\\hat{\\boldsymbol{\\phi}} = \\mathcal{F}_k[\\boldsymbol{\\phi}]$。然后，在傅里叶空间中可以高效地计算空间导数。具体来说，二阶导数 $\\partial_{xx}\\phi$ 的计算方式如下：\n$$\n\\partial_{xx}\\boldsymbol{\\phi} = \\mathcal{F}_k^{-1}[-k_m^2 \\hat{\\boldsymbol{\\phi}}]\n$$\n其中 $k_m = \\frac{2\\pi m}{L}$ 是对应于 DFT 离散频率 $m$ 的角波数。\n\n对于时间积分，我们将偏微分方程 $\\partial_t \\phi = M(\\varepsilon^2 \\partial_{xx}\\phi - \\phi^3 + \\phi)$ 分裂为一个刚性线性部分和一个非刚性非线性部分：\n$$\n\\partial_t \\phi = \\underbrace{M\\varepsilon^2 \\partial_{xx}\\phi}_{\\text{线性，刚性}} + \\underbrace{M(\\phi - \\phi^3)}_{\\text{非线性，非刚性}}\n$$\n我们应用一阶 IMEX 格式，对刚性线性项进行隐式处理（使用后向欧拉法），对非刚性非线性项进行显式处理（使用前向欧拉法）。对于从 $t_n$ 到 $t_{n+1} = t_n + \\Delta t$ 的一个时间步，该格式为：\n$$\n\\frac{\\boldsymbol{\\phi}^{n+1} - \\boldsymbol{\\phi}^n}{\\Delta t} = M\\varepsilon^2 \\partial_{xx}\\boldsymbol{\\phi}^{n+1} + M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)\n$$\n将此方程变换到傅里叶空间，可以得到一个关于下一时间步解的傅里叶系数 $\\hat{\\boldsymbol{\\phi}}^{n+1}$ 的代数方程：\n$$\n\\frac{\\hat{\\boldsymbol{\\phi}}^{n+1} - \\hat{\\boldsymbol{\\phi}}^n}{\\Delta t} = M\\varepsilon^2(-k_m^2) \\hat{\\boldsymbol{\\phi}}^{n+1} + \\mathcal{F}_k[M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)]\n$$\n这允许对每个傅里叶模式进行直接求解：\n$$\n\\hat{\\boldsymbol{\\phi}}^{n+1} = \\frac{\\hat{\\boldsymbol{\\phi}}^n + \\Delta t \\, \\mathcal{F}_k[M(\\boldsymbol{\\phi}^n - (\\boldsymbol{\\phi}^n)^3)]}{1 + \\Delta t M \\varepsilon^2 k_m^2}\n$$\n然后通过逆 DFT 恢复更新后的场 $\\boldsymbol{\\phi}^{n+1}$。该格式相对于刚性扩散项是无条件稳定的，因此允许比完全显式方法更大的时间步长。\n\n为了评估所需的量，我们必须离散化泛函 $\\mathcal{F}[\\phi]$ 和耗散积分。自由能 $\\mathcal{F}[\\phi]$ 在每个时间步使用数值求积法计算。空间积分通过对网格点求和并以 $\\Delta x$ 加权来近似：\n$$\n\\mathcal{F}[\\boldsymbol{\\phi}] \\approx \\Delta x \\sum_{j=0}^{N-1} \\left( \\frac{\\varepsilon^2}{2} (\\partial_x \\phi_j)^2 + \\frac{1}{4}(\\phi_j^2 - 1)^2 \\right)\n$$\n为与求解器保持一致，空间导数 $\\partial_x \\phi_j$ 通过 $\\partial_x \\boldsymbol{\\phi} = \\mathcal{F}_k^{-1}[i k_m \\hat{\\boldsymbol{\\phi}}]$ 进行谱方法计算。\n\n能量平衡需要计算空间积分后的化学势平方的时间积分，即 $M \\int_{0}^{T}\\int_{0}^{L} \\mu(x,t)^2 \\,\\mathrm{d}x\\,\\mathrm{d}t$。化学势 $\\mu = -\\varepsilon^2 \\partial_{xx}\\phi + \\phi^3 - \\phi$ 在每个时间步 $t_n$ 的每个网格点上计算，其中拉普拉斯算子也使用谱方法计算。令 $D(t_n) = M \\int_{0}^{L} \\mu(x,t_n)^2 \\,\\mathrm{d}x \\approx M \\Delta x \\sum_{j=0}^{N-1} \\mu_j(t_n)^2$。然后使用梯形法则近似时间积分：\n$$\n\\int_0^T D(t) \\,\\mathrm{d}t \\approx \\Delta t \\sum_{n=0}^{N_t-1} \\frac{D(t_n) + D(t_{n+1})}{2}\n$$\n其中 $N_t = T/\\Delta t$ 是总时间步数。这提供了积分的二阶精确近似，适用于验证偏微分方程的能量耗散性质。\n\n算法流程如下：\n1. 初始化空间网格、波数和初始相场 $\\boldsymbol{\\phi}^0$。\n2. 计算并存储初始能量 $\\mathcal{F}(t_0)$ 和初始耗散率项 $D(t_0)$。\n3. 对 $n$ 从 $0$ 到 $N_t-1$ 进行循环：\n    a. 在实空间中计算非线性项。\n    b. 将当前状态 $\\boldsymbol{\\phi}^n$ 和非线性项变换到傅里叶空间。\n    c. 在傅里叶空间中应用 IMEX 更新公式得到 $\\hat{\\boldsymbol{\\phi}}^{n+1}$。\n    d. 变换回实空间以获得 $\\boldsymbol{\\phi}^{n+1}$。\n    e. 计算并存储能量 $\\mathcal{F}(t_{n+1})$ 和耗散率项 $D(t_{n+1})$。\n4. 模拟结束后，根据指定的容差 $\\tau_{\\mathrm{mono}}$ 验证存储的能量序列的单调性。\n5. 使用初始和最终能量以及耗散率项的梯形法则积分来计算相对差异 $r$。\n\n这种有原则的方法确保了问题的数值解是可靠的，从而能够精确验证系统指定的物理性质。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Allen-Cahn equation for given test cases and verifies\n    energy properties.\n    \"\"\"\n    test_cases = [\n        # Case 1: (L, N, ε, M, Δt, T)\n        (1.0, 256, 0.02, 1.0, 5e-5, 0.02),\n        # Case 2: (L, N, ε, M, Δt, T)\n        (1.0, 128, 0.03, 0.5, 5e-5, 0.015),\n        # Case 3: (L, N, ε, M, Δt, T)\n        (1.0, 256, 0.05, 1.0, 1e-4, 0.03),\n    ]\n\n    # Use scipy.fft if available, fall back to numpy.fft\n    try:\n        from scipy.fft import fft, ifft, fftfreq\n    except ImportError:\n        from numpy.fft import fft, ifft, fftfreq\n\n    def run_simulation(L, N, epsilon, M, dt, T):\n        \"\"\"\n        Performs a single simulation run for a given set of parameters.\n        \"\"\"\n        # 1. Discretization and Initialization\n        dx = L / N\n        x = np.linspace(0, L, N, endpoint=False)\n        num_steps = int(round(T / dt))\n\n        # Wavenumbers for Fourier transforms\n        k = 2 * np.pi * fftfreq(N, d=dx)\n        k_sq = k**2\n\n        # Initial condition\n        phi = 0.3 * np.sin(2 * np.pi * x / L) + 0.2 * np.sin(4 * np.pi * x / L)\n\n        # Helper functions for diagnostics\n        def compute_energy(phi_vec):\n            phi_hat = fft(phi_vec)\n            d_phi_dx_hat = 1j * k * phi_hat\n            d_phi_dx = ifft(d_phi_dx_hat).real\n            \n            grad_energy_density = (epsilon**2 / 2) * d_phi_dx**2\n            potential_energy_density = 0.25 * (phi_vec**2 - 1)**2\n            \n            return np.sum(grad_energy_density + potential_energy_density) * dx\n\n        def compute_mu(phi_vec):\n            phi_hat = fft(phi_vec)\n            d2_phi_dx2_hat = -k_sq * phi_hat\n            d2_phi_dx2 = ifft(d2_phi_dx2_hat).real\n            \n            mu = -epsilon**2 * d2_phi_dx2 + phi_vec**3 - phi_vec\n            return mu\n\n        # Store results\n        energies = np.zeros(num_steps + 1)\n        dissipation_integrals = np.zeros(num_steps + 1)\n\n        # Initial state diagnostics\n        energies[0] = compute_energy(phi)\n        mu_0 = compute_mu(phi)\n        dissipation_integrals[0] = M * np.sum(mu_0**2) * dx\n\n        # Denominator for the IMEX scheme update\n        imex_denominator = 1 + dt * M * epsilon**2 * k_sq\n\n        # 2. Time-stepping loop\n        phi_current = phi.copy()\n        for i in range(num_steps):\n            # Explicit part (nonlinear term)\n            nl_term = M * (phi_current - phi_current**3)\n            \n            # Update in Fourier space\n            phi_hat = fft(phi_current)\n            nl_term_hat = fft(nl_term)\n            \n            phi_hat_new = (phi_hat + dt * nl_term_hat) / imex_denominator\n            \n            # Update in real space\n            phi_current = ifft(phi_hat_new).real\n            \n            # Diagnostics at the new time step\n            energies[i + 1] = compute_energy(phi_current)\n            mu_current = compute_mu(phi_current)\n            dissipation_integrals[i + 1] = M * np.sum(mu_current**2) * dx\n\n        # 3. Post-processing\n        # Monotonicity check\n        F0 = energies[0]\n        tau_mono = 1e-8 * F0\n        is_decreasing = np.all(energies[1:] = energies[:-1] + tau_mono)\n\n        # Relative discrepancy 'r'\n        delta_F_actual = energies[-1] - energies[0]\n        \n        # Integrate dissipation using trapezoidal rule\n        integrated_dissipation = np.trapz(dissipation_integrals, dx=dt)\n        \n        numerator = np.abs(delta_F_actual + integrated_dissipation)\n        denominator = np.max([1.0, np.abs(F0)])\n        relative_discrepancy = numerator / denominator\n\n        return bool(is_decreasing), relative_discrepancy\n\n    results = []\n    for case in test_cases:\n        L, N, epsilon, M, dt, T = case\n        is_dec, r_val = run_simulation(L, N, epsilon, M, dt, T)\n        results.extend([is_dec, r_val])\n\n    # Final print statement in the exact required format.\n    # The boolean values are automatically converted to 'True' or 'False'.\n    output_str = ','.join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2408607"}]}