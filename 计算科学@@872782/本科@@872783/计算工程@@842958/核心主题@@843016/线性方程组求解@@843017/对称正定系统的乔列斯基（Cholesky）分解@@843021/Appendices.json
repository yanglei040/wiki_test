{"hands_on_practices": [{"introduction": "我们将从零开始实现 Cholesky 算法，以此开启我们的动手实践之旅。这项练习将正定性的理论要求与实际的计算检验直接联系起来，你将看到算法中对主元进行开平方根的需要，如何自然地成为判断一个对称矩阵是否为正定矩阵的有效测试。通过亲手编写代码，并在正定性边界附近的矩阵上进行测试，你将对该算法的内在机制及其作为诊断工具的角色，获得深刻而直观的理解 [@problem_id:2376407]。", "problem": "您需要从第一性原理出发，实现并分析用于对称正定 (SPD) 系统的 Cholesky 分解。一个 $n \\times n$ 的实矩阵 $A$ 是对称正定 (SPD) 的，如果它满足 $A = A^{\\mathsf{T}}$ 且对于所有非零向量 $x \\in \\mathbb{R}^n$ 都有 $x^{\\mathsf{T}} A x > 0$。一个经过充分检验的数学事实是，一个 SPD 矩阵允许唯一的 Cholesky 分解 $A = L L^{\\mathsf{T}}$，其中 $L$ 是下三角矩阵，且 $L$ 的所有对角线元素都严格为正。另一个经过充分检验的事实（Sylvester 判据）是，一个对称矩阵是 SPD 的，当且仅当其所有主子式都为正。\n\n您的任务：\n\n1. 实现一个例程，在没有任何主元选择的情况下，尝试对给定的对称矩阵 $A$ 计算 Cholesky 分解 $A = L L^{\\mathsf{T}}$。该例程必须显式地检查每个计算出的对角主元平方值的正性，并且在任何步骤中一旦出现非正值，就声明失败。该实现不得依赖于黑盒的 SPD 检查；它应纯粹基于计算出的中间量来检测失败。\n\n2. 使用以下对称矩阵的参数族：\n   $$ A(r) = \\begin{bmatrix} 1  r \\\\ r  1 \\end{bmatrix}, $$\n   其中 $r \\in \\mathbb{R}$。该族包含的矩阵会随着单个非对角元素 $r$ 的微小变化而从 SPD 矩阵变为非 SPD 矩阵。在一组参数值的测试套件上评估您的例程\n   $$ r \\in \\{\\, 0.9,\\; 0.999999,\\; 1.0,\\; 1.000001 \\,\\}. $$\n   为每个测试记录一个布尔值，指示 Cholesky 例程是成功（返回 $\\,\\text{True}\\,$）还是失败（返回 $\\,\\text{False}\\,$）。\n\n3. 作为一个额外的“happy path”（顺利通过）覆盖案例，测试以下根据 Sylvester 判据已知为 SPD 的固定 $3 \\times 3$ 对称矩阵：\n   $$ B = \\begin{bmatrix} 4  1  1 \\\\ 1  3  1 \\\\ 1  1  2 \\end{bmatrix}. $$\n   记录一个布尔值，指示 Cholesky 例程在处理 $B$ 时是否成功。\n\n4. 输出规范。您的程序必须生成单行输出，其中包含一个 Python 风格的列表字面量，该列表按以下顺序包含所有测试的布尔值：四个 $A(r)$ 案例（$r$ 分别等于 $0.9$, $0.999999$, $1.0$, $1.000001$），然后是单个案例 $B$。例如，要求的格式是：\n   $$ [\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5] $$\n   其中每个 $\\text{result}_i$ 是 $\\text{True}$ 或 $\\text{False}$。\n\n注意事项和约束：\n\n- 您的推理应基于 SPD 矩阵的定义和上面陈述的 Cholesky 分解的存在条件。不要假设任何未陈述的性质。\n- 不涉及物理单位。\n- 角度单位不适用。\n- 唯一可接受的输出是按所述确切顺序排列的单行布尔值列表。", "solution": "所述问题定义明确、自成体系且科学合理，其基础是数值线性代数中的既定原则。因此，该问题是有效的，我们接下来将给出完整解答。该任务要求实现一个 Cholesky 分解例程，并将其应用于一组指定的测试矩阵。\n\n其基本原理是将一个对称正定 (SPD) 矩阵 $A$ 分解为乘积 $A = LL^{\\mathsf{T}}$，其中 $L$ 是一个下三角矩阵。$L$ 的元素（记为 $L_{ij}$）可以直接从此方程计算得出。对于一个 $n \\times n$ 矩阵 $A$，其元素 $A_{ij}$ 由 $L$ 的第 $i$ 行与 $L^{\\mathsf{T}}$ 的第 $j$ 列（即 $L$ 的第 $j$ 行）的点积给出：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} \\quad \\text{for } i \\ge j $$\n由于 $A$ 是对称的，因此 $A_{ij} = A_{ji}$，我们只需要计算 $i \\ge j$ 的 $L_{ij}$。\n\n该算法按顺序计算 $L$ 的各列，从 $j=1$到 $j=n$。对于每一列 $j$，我们首先计算对角元素 $L_{jj}$，然后计算 $i > j$ 的非对角元素 $L_{ij}$。\n\n考虑对角元素 $A_{jj}$：\n$$ A_{jj} = \\sum_{k=1}^{j} L_{jk}^2 = \\left( \\sum_{k=1}^{j-1} L_{jk}^2 \\right) + L_{jj}^2 $$\n由此，我们解出 $L$ 的对角元素的平方：\n$$ L_{jj}^2 = A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2 $$\n要使 Cholesky 分解存在一个具有正对角线元素的实值矩阵 $L$，则在每一步 $j$ 中，$L_{jj}^2$ 项必须严格为正。如果对于任何 $j$，$L_{jj}^2 \\le 0$，则该矩阵不是正定的，分解失败。这就是我们的例程必须检查的条件。如果 $L_{jj}^2 > 0$，则有 $L_{jj} = \\sqrt{A_{jj} - \\sum_{k=1}^{j-1} L_{jk}^2}$。\n\n接下来，考虑 $i > j$ 的非对角元素 $A_{ij}$：\n$$ A_{ij} = \\sum_{k=1}^{j} L_{ik} L_{jk} = \\left( \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) + L_{ij} L_{jj} $$\n求解 $L_{ij}$，我们得到：\n$$ L_{ij} = \\frac{1}{L_{jj}} \\left( A_{ij} - \\sum_{k=1}^{j-1} L_{ik} L_{jk} \\right) $$\n只要 $L_{jj} \\ne 0$，这个计算就是可行的，而如果 $L_{jj}^2 > 0$，这一点就得到了保证。\n\n我们现在基于此算法分析指定的测试案例。\n\n1.  **参数族 $A(r) = \\begin{bmatrix} 1  r \\\\ r  1 \\end{bmatrix}$**\n\n    我们对这个 $2 \\times 2$ 矩阵应用该算法。\n    \n    对于列 $j=1$：\n    对角元素的平方为 $L_{11}^2 = A_{11} = 1$。由于 $1 > 0$，此步骤成功，我们得到 $L_{11} = 1$。\n    非对角元素为 $L_{21} = \\frac{1}{L_{11}} (A_{21}) = \\frac{r}{1} = r$。\n    \n    对于列 $j=2$：\n    对角元素的平方为 $L_{22}^2 = A_{22} - L_{21}^2 = 1 - r^2$。\n    分解成功的充要条件是这个量严格为正：$1 - r^2 > 0$，这等价于 $r^2 < 1$，或者说 $|r| < 1$。\n\n    我们评估指定的 $r$ 值：\n    - 对于 $r = 0.9$：$L_{22}^2 = 1 - (0.9)^2 = 1 - 0.81 = 0.19 > 0$。例程成功。结果：$\\text{True}$。\n    - 对于 $r = 0.999999$：$L_{22}^2 = 1 - (0.999999)^2 > 0$。该值为正，尽管很小。例程成功。结果：$\\text{True}$。\n    - 对于 $r = 1.0$：$L_{22}^2 = 1 - (1.0)^2 = 0$。这个值不是严格为正。例程必须失败。结果：$\\text{False}$。\n    - 对于 $r = 1.000001$：$L_{22}^2 = 1 - (1.000001)^2 < 0$。例程必须失败。结果：$\\text{False}$。\n\n2.  **固定矩阵 $B = \\begin{bmatrix} 4  1  1 \\\\ 1  3  1 \\\\ 1  1  2 \\end{bmatrix}$**\n\n    我们将该算法应用于这个 $3 \\times 3$ 矩阵。\n\n    对于列 $j=1$：\n    $L_{11}^2 = B_{11} = 4$。由于 $4 > 0$，我们继续。$L_{11} = 2$。\n    $L_{21} = B_{21} / L_{11} = 1/2$。\n    $L_{31} = B_{31} / L_{11} = 1/2$。\n\n    对于列 $j=2$：\n    $L_{22}^2 = B_{22} - L_{21}^2 = 3 - (1/2)^2 = 3 - 1/4 = 11/4$。由于 $11/4 > 0$，我们继续。$L_{22} = \\sqrt{11}/2$。\n    $L_{32} = \\frac{1}{L_{22}}(B_{32} - L_{31}L_{21}) = \\frac{1}{\\sqrt{11}/2}(1 - (1/2)(1/2)) = \\frac{2}{\\sqrt{11}}(3/4) = \\frac{3}{2\\sqrt{11}}$。\n\n    对于列 $j=3$：\n    $L_{33}^2 = B_{33} - (L_{31}^2 + L_{32}^2) = 2 - \\left( (1/2)^2 + \\left(\\frac{3}{2\\sqrt{11}}\\right)^2 \\right) = 2 - \\left( \\frac{1}{4} + \\frac{9}{44} \\right) = 2 - \\left( \\frac{11}{44} + \\frac{9}{44} \\right) = 2 - \\frac{20}{44} = 2 - \\frac{5}{11} = \\frac{17}{11}$。\n    由于 $17/11 > 0$，最后一步成功。\n\n    由于所有对角主元的平方都严格为正，矩阵 $B$ 的 Cholesky 分解成功。结果：$\\text{True}$。\n\n因此，五个测试案例按指定顺序的布尔结果序列为：$\\text{True}$，$\\text{True}$，$\\text{False}$，$\\text{False}$，$\\text{True}$。最终答案中的程序将实现此逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements the Cholesky factorization from first principles,\n    tests it on several matrices, and prints the results.\n    \"\"\"\n\n    def cholesky_factorization_attempt(A: np.ndarray) -> bool:\n        \"\"\"\n        Attempts to compute the Cholesky factorization of a symmetric matrix A.\n\n        The routine follows the standard column-wise algorithm. It explicitly\n        checks for the strict positivity of the squared diagonal pivots (L_jj^2).\n        If a non-positive pivot is encountered, the matrix is not positive-definite,\n        and the factorization fails.\n\n        Args:\n            A (np.ndarray): The n x n symmetric matrix to factorize.\n\n        Returns:\n            bool: True if the factorization succeeds, False otherwise.\n        \"\"\"\n        n = A.shape[0]\n        L = np.zeros_like(A, dtype=float)\n\n        for j in range(n):\n            # Compute the sum of squares of elements in the j-th row of L up to column j-1.\n            # This corresponds to sum_{k=0}^{j-1} L[j, k]^2\n            s1 = np.dot(L[j, :j], L[j, :j])\n\n            # Compute the squared diagonal element L[j, j]^2.\n            squared_pivot = A[j, j] - s1\n\n            # The core condition for positive-definiteness in Cholesky factorization:\n            # The pivot must be strictly positive.\n            if squared_pivot = 0:\n                return False\n\n            L[j, j] = np.sqrt(squared_pivot)\n\n            # Compute the elements in the j-th column below the diagonal.\n            if j  n - 1:\n                # This corresponds to the sum sum_{k=0}^{j-1} L[i, k] * L[j, k] for each i > j.\n                s2 = np.dot(L[j + 1:n, :j], L[j, :j])\n                L[j + 1:n, j] = (A[j + 1:n, j] - s2) / L[j, j]\n\n        return True\n\n    # 1. Define the parametric test cases A(r).\n    r_values = [0.9, 0.999999, 1.0, 1.000001]\n    test_matrices = [np.array([[1.0, r], [r, 1.0]]) for r in r_values]\n\n    # 2. Define the fixed 3x3 test case B.\n    B_matrix = np.array([\n        [4.0, 1.0, 1.0],\n        [1.0, 3.0, 1.0],\n        [1.0, 1.0, 2.0]\n    ])\n    test_matrices.append(B_matrix)\n\n    # 3. Evaluate the routine on all test cases.\n    results = []\n    for matrix in test_matrices:\n        success = cholesky_factorization_attempt(matrix)\n        results.append(success)\n\n    # 4. Print the final results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2376407"}, {"introduction": "既然我们已经能够计算 Cholesky 因子 $L$，让我们来探索它除了求解线性方程组之外的实际应用。这个实践将演示如何通过先计算 Cholesky 因子 $L$ 来高效且数值稳定地计算矩阵的逆 $A^{-1}$。你将利用 $A^{-1} = (L^{-1})^{\\mathsf{T}} L^{-1}$ 这一性质，从而避免直接对 $A$ 进行求逆这一成本更高且可能不稳定的操作。这项任务凸显了分解方法在数值线性代数中的强大威力，展示了将一个问题分解为涉及三角矩阵的多个步骤如何能够带来更优越的算法 [@problem_id:2376430]。", "problem": "给定一个实对称正定 (SPD) 矩阵 $\\boldsymbol{A} \\in \\mathbb{R}^{n \\times n}$，它存在一个 Cholesky 分解 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$，其中 $\\boldsymbol{L}$ 是一个对角线元素为严格正数的下三角矩阵。对于每个给定的测试用例，只提供 Cholesky 因子 $\\boldsymbol{L}$（而不是 $\\boldsymbol{A}$）。您的任务是实现一个程序，对每个测试用例，仅使用 $\\boldsymbol{L}$ 和基本运算来计算逆矩阵 $\\boldsymbol{A}^{-1}$，而不直接对 $\\boldsymbol{A}$ 求逆。计算出 $\\boldsymbol{A}^{-1}$ 后，通过构建 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 并计算残差矩阵 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$ 来验证其正确性，其中 $\\boldsymbol{I}$ 是相应大小的单位矩阵。对于每个测试用例，报告 $\\boldsymbol{R}$ 的最大绝对值元素，定义为 $\\max_{i,j} |R_{ij}|$。\n\n使用以下下三角 Cholesky 因子 $\\boldsymbol{L}$ 的测试套件：\n\n- 测试用例 $1$（边界情况 $1 \\times 1$）：\n  $$\\boldsymbol{L}_1 = \\begin{bmatrix} 3 \\end{bmatrix}.$$\n\n- 测试用例 $2$（大小 $2 \\times 2$）：\n  $$\\boldsymbol{L}_2 = \\begin{bmatrix} 2  0 \\\\ 1  \\sqrt{2} \\end{bmatrix}.$$\n\n- 测试用例 $3$（大小 $3 \\times 3$）：\n  $$\\boldsymbol{L}_3 = \\begin{bmatrix}\n  1.5  0  0 \\\\\n  0.4  2.0  0 \\\\\n  -0.3  0.5  1.2\n  \\end{bmatrix}.$$\n\n- 测试用例 $4$（大小 $4 \\times 4$，病态但仍为 SPD）：\n  $$\\boldsymbol{L}_4 = \\begin{bmatrix}\n  10^{-3}  0  0  0 \\\\\n  2\\times 10^{-4}  10^{-1}  0  0 \\\\\n  -10^{-4}  3\\times 10^{-2}  1.0  0 \\\\\n  5\\times 10^{-5}  -2\\times 10^{-2}  4\\times 10^{-1}  10.0\n  \\end{bmatrix}.$$\n\n程序要求：\n\n- 对每个测试用例，仅使用给定的 $\\boldsymbol{L}$ 和基本线性代数运算来计算 $\\boldsymbol{A}^{-1}$，而不直接对 $\\boldsymbol{A}$ 求逆。\n- 为了验证，构建 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 并计算残差 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$。\n- 对每个测试用例，输出标量 $\\rho = \\max_{i,j} |R_{ij}|$。\n- 最终输出必须为单行，包含所有四个 $\\rho$ 值，按测试 1 到 4 的顺序排列，四舍五入到 $12$ 位小数，并以方括号括起来的逗号分隔列表形式呈现，例如 \"$[r_1,r_2,r_3,r_4]$\"。\n\n此问题不涉及物理量，因此不需要物理单位。所有角度（如有）均与此任务无关。您的程序不得读取任何输入；它应按原样运行并生成所需的单行输出。", "solution": "问题陈述是有效的。这是一个数值线性代数中的适定问题，其基础是成熟的矩阵分解理论。\n\n该任务要求在给定对称正定 (SPD) 矩阵 $\\boldsymbol{A}$ 的 Cholesky 因子 $\\boldsymbol{L}$（其中 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$）的情况下，计算其逆矩阵。一个关键约束是，求逆过程必须在不直接计算 $\\boldsymbol{A}$ 的逆的情况下进行。这一要求在高性能科学计算中是标准做法，因为它指向一种具有更优数值稳定性和计算效率的方法。\n\n其基本原理基于矩阵求逆和转置的代数性质。两个可逆矩阵 $\\boldsymbol{X}$ 和 $\\boldsymbol{Y}$ 的乘积的逆遵循规则 $(\\boldsymbol{X}\\boldsymbol{Y})^{-1} = \\boldsymbol{Y}^{-1}\\boldsymbol{X}^{-1}$。此外，矩阵转置的逆等于矩阵逆的转置，表示为 $(\\boldsymbol{X}^{\\mathsf{T}})^{-1} = (\\boldsymbol{X}^{-1})^{\\mathsf{T}}$。\n\n将这些原理应用于 Cholesky 分解 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$，我们可以正式推导出 $\\boldsymbol{A}^{-1}$ 的表达式：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}})^{-1}\n$$\n使用乘积求逆的规则，我们得到：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}^{\\mathsf{T}})^{-1} \\boldsymbol{L}^{-1}\n$$\n最后，将转置-求逆交换规则应用于项 $(\\boldsymbol{L}^{\\mathsf{T}})^{-1}$，得到所需的表达式：\n$$\n\\boldsymbol{A}^{-1} = (\\boldsymbol{L}^{-1})^{\\mathsf{T}} \\boldsymbol{L}^{-1}\n$$\n这个最终方程提供了计算 $\\boldsymbol{A}^{-1}$ 的算法。该过程在数值上是稳健的，因为它操作于 Cholesky 因子 $\\boldsymbol{L}$。由于 $\\boldsymbol{L}$ 是一个对角线元素为严格正数的下三角矩阵，它总是可逆的。它的逆矩阵 $\\boldsymbol{L}^{-1}$ 也是下三角矩阵，可以通过等价于求解矩阵方程 $\\boldsymbol{L}\\boldsymbol{X} = \\boldsymbol{I}$（其中 $\\boldsymbol{I}$ 是单位矩阵）的前向代入法来高效地计算。\n\n这种方法是首选的，因为 Cholesky 因子 $\\boldsymbol{L}$ 的条件数 $\\kappa(\\boldsymbol{L})$ 是原始矩阵 $\\boldsymbol{A}$ 条件数 $\\kappa(\\boldsymbol{A})$ 的平方根，即 $\\kappa(\\boldsymbol{L}) = \\sqrt{\\kappa(\\boldsymbol{A})}$。因此，对 $\\boldsymbol{L}$ 求逆比直接对 $\\boldsymbol{A}$ 求逆是一个条件好得多的数值问题，这对于像测试用例 4 中的病态矩阵尤其重要。\n\n为解决此问题而实现的算法如下：\n1.  对于每个给定的下三角 Cholesky 因子 $\\boldsymbol{L}$，计算其逆矩阵，我们将其表示为 $\\boldsymbol{M} = \\boldsymbol{L}^{-1}$。\n2.  使用推导出的公式 $\\boldsymbol{A}^{-1} = \\boldsymbol{M}^{\\mathsf{T}}\\boldsymbol{M}$ 计算原始矩阵 $\\boldsymbol{A}$ 的逆。\n3.  为了验证，通过计算乘积 $\\boldsymbol{A} = \\boldsymbol{L}\\boldsymbol{L}^{\\mathsf{T}}$ 来显式地构建矩阵 $\\boldsymbol{A}$。\n4.  计算残差矩阵 $\\boldsymbol{R} = \\boldsymbol{A}\\boldsymbol{A}^{-1} - \\boldsymbol{I}$。理想情况下，$\\boldsymbol{R}$ 应该是零矩阵，但由于浮点运算，其元素将是微小的非零值。\n5.  计算出的逆矩阵的质量通过寻找残差矩阵的最大绝对值元素 $\\rho = \\max_{i,j} |R_{ij}|$ 来评估。为每个测试用例报告此值。\n\n所提供的程序使用 `numpy` 库进行基本线性代数运算，为每个测试用例执行这些步骤。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the inverse of a matrix A from its Cholesky factor L\n    and reports the maximum absolute residual.\n    \"\"\"\n    #\n    # Execution Environment:\n    # language: Python\n    # version: 3.12\n    # libraries:\n    #     - name: numpy, version: 1.23.5\n    #     - name: scipy, version: 1.11.4\n    #\n\n    # Define the test cases from the problem statement.\n    # L1: 1x1 boundary case\n    L1 = np.array([[3.0]])\n\n    # L2: 2x2 case\n    L2 = np.array([\n        [2.0, 0.0],\n        [1.0, np.sqrt(2)]\n    ])\n\n    # L3: 3x3 case\n    L3 = np.array([\n        [1.5, 0.0, 0.0],\n        [0.4, 2.0, 0.0],\n        [-0.3, 0.5, 1.2]\n    ])\n\n    # L4: 4x4 ill-scaled case\n    L4 = np.array([\n        [1.0e-3, 0.0,    0.0,  0.0],\n        [2.0e-4, 1.0e-1, 0.0,  0.0],\n        [-1.0e-4, 3.0e-2, 1.0,  0.0],\n        [5.0e-5, -2.0e-2, 0.4, 10.0]\n    ])\n\n    test_cases = [L1, L2, L3, L4]\n\n    results = []\n    for L in test_cases:\n        # The problem requires computing A_inv from L without inverting a dense A.\n        # The method is A_inv = (L_inv)^T * L_inv, where L_inv is the inverse of L.\n        # Inverting a triangular matrix L is a fundamental and stable operation.\n        \n        # Step 1: Compute the inverse of the lower-triangular matrix L.\n        L_inv = np.linalg.inv(L)\n        \n        # Step 2: Compute A_inv using the formula A_inv = (L_inv.T) @ L_inv.\n        A_inv = L_inv.T @ L_inv\n        \n        # Step 3 (Verification): Form A = L @ L.T\n        A = L @ L.T\n        \n        # Step 4 (Verification): Compute the residual matrix R = A * A_inv - I\n        I = np.identity(A.shape[0])\n        R = A @ A_inv - I\n        \n        # Step 5: Find the maximum absolute value of the entries in R.\n        rho = np.max(np.abs(R))\n        \n        results.append(rho)\n\n    # Final print statement in the exact required format.\n    # Output must be a single line: [r_1,r_2,r_3,r_4] with 12 decimal places.\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2376430"}, {"introduction": "作为我们实践的结尾，我们将把 Cholesky 分解推广到复数域。工程和物理学中的许多应用，例如信号处理和量子力学，都涉及厄米特 (Hermitian) 正定矩阵。这项练习将 Cholesky 分解应用于这类更广泛的矩阵，其中转置操作被共轭转置所替代 ($A = LL^{*}$)。通过在一个更抽象的背景下应用核心概念，这个实践将巩固你的理解，并展示 Cholesky 分解在计算科学中的通用性和基础性 [@problem_id:2376461]。", "problem": "设 $A \\in \\mathbb{C}^{n \\times n}$ 是一个厄米特正定矩阵，即 $A^{*} = A$ 且对于每个非零向量 $x \\in \\mathbb{C}^{n}$ 都有 $x^{*} A x \\in \\mathbb{R}_{0}$。对于这样的矩阵，存在一个唯一的下三角矩阵 $L \\in \\mathbb{C}^{n \\times n}$，其对角线元素为严格正实数，使得 $A = L L^{*}$。对于下面提供的每种情况，您必须完全按照规定构造矩阵 $A$，然后计算一个满足 $A = L L^{*}$ 且对角线元素为正实数的相应下三角矩阵 $L$。对于每种情况，报告其相对重构残差 $r = \\lVert A - L L^{*} \\rVert_{F} \\big/ \\lVert A \\rVert_{F}$，其中 $\\lVert \\cdot \\rVert_{F}$ 表示弗罗贝尼乌斯范数。报告的每种情况的 $r$ 值必须四舍五入到 $10$ 位小数。\n\n给定一个包含 $4$ 种情况的测试套件。在每种情况下，都会提供一个下三角矩阵 $B \\in \\mathbb{C}^{n \\times n}$，您需要利用它来构造 $A = B B^{*}$，根据构造方式，$A$ 是厄米特正定的。\n\n情况 $1$ ($n = 3$): \n$$\nB_{1} =\n\\begin{bmatrix}\n2 + 0\\mathrm{i}  0  0 \\\\\n1 + 1\\mathrm{i}  1 + 0\\mathrm{i}  0 \\\\\n2 - 1\\mathrm{i}  -1 + 2\\mathrm{i}  3 + 0\\mathrm{i}\n\\end{bmatrix}.\n$$\n\n情况 $2$ ($n = 1$): \n$$\nB_{2} =\n\\begin{bmatrix}\n2 + 3\\mathrm{i}\n\\end{bmatrix}.\n$$\n\n情况 $3$ ($n = 2$)（在构造 $A = B B^{*}$ 时是病态的，但仍为厄米特正定）：\n$$\nB_{3} =\n\\begin{bmatrix}\n10^{-6} + 0\\mathrm{i}  0 \\\\\n1 - 1\\mathrm{i}  10^{-6} + 0\\mathrm{i}\n\\end{bmatrix}.\n$$\n\n情况 $4$ ($n = 4$): \n$$\nB_{4} =\n\\begin{bmatrix}\n3 + 0\\mathrm{i}  0  0  0 \\\\\n2 - 1\\mathrm{i}  2 + 0\\mathrm{i}  0  0 \\\\\n0.5 + 0.5\\mathrm{i}  -1 + 2\\mathrm{i}  1.5 + 0\\mathrm{i}  0 \\\\\n1 + 2\\mathrm{i}  0.25 - 0.75\\mathrm{i}  -0.5 + 1\\mathrm{i}  4 + 0\\mathrm{i}\n\\end{bmatrix}.\n$$\n\n对于每种情况 $k \\in \\{1,2,3,4\\}$：\n- 构造 $A_{k} = B_{k} B_{k}^{*}$。\n- 计算一个对角线元素为正实数的下三角矩阵 $L_{k}$，使得 $A_{k} = L_{k} L_{k}^{*}$。\n- 计算相对重构残差 $r_{k} = \\lVert A_{k} - L_{k} L_{k}^{*} \\rVert_{F} \\big/ \\lVert A_{k} \\rVert_{F}$，并四舍五入到 $10$ 位小数。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，即 $[r_{1},r_{2},r_{3},r_{4}]$，其中每个 $r_{k}$ 是一个四舍五入到 $10$ 位小数的浮点数。", "solution": "问题陈述已经过验证，被认为是科学可靠、定义明确且客观的。它概述了数值线性代数中的一个标准程序，特别是厄米特正定矩阵的 Cholesky 分解。我们将继续进行求解。\n\n其基本原理是 Cholesky 分解定理，该定理指出，任何厄米特正定矩阵 $A \\in \\mathbb{C}^{n \\times n}$ 都可以唯一地分解为 $A = L L^{*}$，其中 $L \\in \\mathbb{C}^{n \\times n}$ 是一个对角线元素为严格正实数的下三角矩阵，而 $L^{*}$ 是其共轭转置。\n\n问题要求我们对 $4$ 个独立的情况执行此分解。对于每种情况 $k \\in \\{1, 2, 3, 4\\}$，我们给定一个下三角矩阵 $B_k \\in \\mathbb{C}^{n \\times n}$。待分解的矩阵 $A_k$ 是通过乘积 $A_k = B_k B_k^{*}$ 构造的。这种构造方法保证了 $A_k$ 是厄米特且正定的。\n- **厄米特性 (Hermitian)**：$A_k^{*} = (B_k B_k^{*})^{*} = (B_k^{*})^{*} B_k^{*} = B_k B_k^{*} = A_k$。\n- **正定性 (Positive-Definite)**：对于任何非零向量 $x \\in \\mathbb{C}^{n}$，我们有 $x^{*} A_k x = x^{*} (B_k B_k^{*}) x = (B_k^{*} x)^{*} (B_k^{*} x) = \\lVert B_k^{*} x \\rVert_2^2$。由于给定的每个 $B_k$ 都是可逆的（因为对角线上没有零元素），所以 $B_k^{*}$ 也是可逆的。因此，如果 $x \\neq 0$，则 $B_k^{*} x \\neq 0$，从而 $\\lVert B_k^{*} x \\rVert_2^2  0$。\n\n每种情况的求解过程如下：\n$1$. 使用提供的矩阵 $B_k$ 构造矩阵 $A_k = B_k B_k^{*}$。\n$2$. 计算 $A_k$ 的 Cholesky 因子 $L_k$。此任务使用高质量、数值稳定的算法执行，例如 SciPy 库中提供的算法，该库是底层 LAPACK 例程的接口。该算法计算出满足 $A_k \\approx L_k L_k^{*}$ 且对角线元素为正实数的下三角矩阵 $L_k$。\n$3$. 计算相对重构残差。该量度量了数值分解的后向误差。它定义为 $r_k = \\lVert A_k - L_k L_k^{*} \\rVert_{F} \\big/ \\lVert A_k \\rVert_{F}$，其中 $\\lVert \\cdot \\rVert_{F}$ 表示弗罗贝尼乌斯范数。由于有限精度浮点运算的限制，该残差预计不会完全为零，而应是一个与机器精度（对于双精度数，约为 $10^{-16}$）同量级的小值。\n\n此过程系统地应用于所有 $4$ 种情况。$n=1$ 的情况足够简单，可以手动验证。情况 $3$ 中的病态矩阵用于测试 Cholesky 分解算法的数值稳定性，已知该算法的后向误差很小，与条件数无关。对于 $B_k$ 的对角线元素已经是正实数的情况，给定的矩阵 $B_k$ 本身就是唯一的 Cholesky 因子 $L_k$。即使在这些情况下，数值过程也涉及构造 $A_k$ 并对其进行重新分解，这会引入微小的计算误差，而残差计算将捕捉到这些误差。最后，按要求将计算出的每个残差 $r_k$ 四舍五入到 $10$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import cholesky\n\ndef solve():\n    \"\"\"\n    Solves the Cholesky factorization problem for the 4 given cases.\n    For each case, it constructs a Hermitian positive-definite matrix A = B B*,\n    computes its Cholesky factor L, and then calculates the relative\n    reconstruction residual.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (n = 3)\n        (np.array([\n            [2.+0.j, 0.+0.j, 0.+0.j],\n            [1.+1.j, 1.+0.j, 0.+0.j],\n            [2.-1.j, -1.+2.j, 3.+0.j]\n        ], dtype=np.complex128)),\n\n        # Case 2 (n = 1)\n        (np.array([\n            [2.+3.j]\n        ], dtype=np.complex128)),\n\n        # Case 3 (n = 2)\n        (np.array([\n            [1e-6+0.j, 0.+0.j],\n            [1.-1.j, 1e-6+0.j]\n        ], dtype=np.complex128)),\n\n        # Case 4 (n = 4)\n        (np.array([\n            [3.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],\n            [2.-1.j, 2.+0.j, 0.+0.j, 0.+0.j],\n            [0.5+0.5j, -1.+2.j, 1.5+0.j, 0.+0.j],\n            [1.+2.j, 0.25-0.75j, -0.5+1.j, 4.+0.j]\n        ], dtype=np.complex128))\n    ]\n\n    results = []\n    for B in test_cases:\n        # Step 1: Form A = B B*\n        # This construction guarantees A is Hermitian positive-definite.\n        A = B @ B.conj().T\n\n        # Step 2: Compute the Cholesky factorization L of A.\n        # scipy.linalg.cholesky is a robust implementation based on LAPACK.\n        # It returns a lower-triangular matrix with positive real diagonal\n        # entries by default.\n        L = cholesky(A, lower=True)\n\n        # Step 3: Compute the relative reconstruction residual.\n        # r = ||A - L L*||_F / ||A||_F\n        norm_A = np.linalg.norm(A, 'fro')\n\n        # The norm of A will be non-zero for the given test cases.\n        if norm_A == 0:\n            residual = 0.0\n        else:\n            # The reconstruction error is due to finite-precision arithmetic.\n            reconstruction_error_matrix = A - (L @ L.conj().T)\n            norm_reconstruction_error = np.linalg.norm(reconstruction_error_matrix, 'fro')\n            residual = norm_reconstruction_error / norm_A\n\n        # Round the result to 10 decimal places as specified.\n        results.append(round(residual, 10))\n\n    # Final print statement in the exact required format.\n    # The output should be a list of floating-point numbers.\n    # Formatting with f-string to ensure 10 decimal places.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2376461"}]}