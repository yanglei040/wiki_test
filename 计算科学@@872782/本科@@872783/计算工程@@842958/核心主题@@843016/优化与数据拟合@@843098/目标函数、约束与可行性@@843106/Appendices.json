{"hands_on_practices": [{"introduction": "我们首先通过一个物理系统平衡问题，来实践约束优化的核心分析工具。通过将蜘蛛网节点的平衡状态建模为在约束下最小化其弹性势能，本练习将引导你手动推导并求解 Karush-Kuhn-Tucker (KKT) 条件。这不仅能加深你对 KKT 条件背后物理意义的理解，也是掌握非线性规划问题解析解法的关键一步。[@problem_id:2407324]", "problem": "蜘蛛网的一个平面连接节点被建模为一个点 $q \\in \\mathbb{R}^{2}$，通过三根弹性丝线（理想线性弹簧）连接到三个固定锚点 $a_{1}, a_{2}, a_{3} \\in \\mathbb{R}^{2}$。刚度为 $k$、静止长度为零的线性弹簧的应变能由经过充分验证的公式 $U = \\tfrac{1}{2} k \\| \\Delta \\|^{2}$ 给出。通过选择一套一致的单位制和缩放，我们将所有弹簧刚度取为 $k=1$，因此三根丝线的总弹性势能为\n$$\nE(q) = \\frac{1}{2} \\sum_{i=1}^{3} \\| q - a_{i} \\|^{2}.\n$$\n为确保材料安全，每根丝线的长度都受到一个最大允许值 $d_{i} > 0$ 的限制，这被建模为不等式约束\n$$\n\\| q - a_{i} \\| \\le d_{i}, \\quad i \\in \\{1,2,3\\}.\n$$\n这就将连接节点的平衡问题定义为一个约束能量最小化问题。\n\n任务：\n- 使用显式函数 $g_{i}(\\cdot)$，根据目标函数 $E(q)$ 和不等式约束 $g_{i}(q) \\le 0$ 来表述该约束优化问题。\n- 从约束优化的第一性原理出发，推导此问题的 Karush–Kuhn–Tucker (KKT) 条件（平稳性、原始可行性、对偶可行性和互补松弛性）。不要假定任何快捷公式；从拉格朗日函数开始，并显式地求梯度。\n- 针对以下给定数据：$a_{1} = (0,0)$，$a_{2} = (2,0)$，$a_{3} = (0,2)$，以及边界 $d_{1} = \\tfrac{1}{2}$，$d_{2} = 2$，$d_{3} = 2$。求解 KKT 系统，找出唯一的优化节点位置 $q^{\\star} = (x^{\\star}, y^{\\star})$ 和非零的拉格朗日乘子。请提供精确值，不要四舍五入。如果有多个拉格朗日乘子非零，则报告所有非零乘子；如果只有一个非零，则只报告那一个。\n\n答案格式：\n- 您的最终答案必须是单一的闭式解析表达式。按顺序报告三元组 $(x^{\\star}, y^{\\star}, \\lambda_{1}^{\\star})$。无需单位。不要四舍五入。", "solution": "所述问题具有科学依据、是良定的、客观且自洽的。它代表了计算力学中一个标准的约束优化问题。因此，该问题是有效的，并将推导求解。\n\n任务是通过最小化总弹性势能来找到连接节点的平衡位置 $q^\\star = (x^\\star, y^\\star)$，并满足连接丝线的长度约束。\n\n首先，我们建立约束优化问题。优化变量是节点的位置 $q = (x, y) \\in \\mathbb{R}^{2}$。\n需要最小化的目标函数是总弹性势能：\n$$\nE(q) = \\frac{1}{2} \\sum_{i=1}^{3} \\| q - a_{i} \\|^{2}\n$$\n不等式约束由 $\\| q - a_{i} \\| \\le d_{i}$（$i \\in \\{1, 2, 3\\}$）给出。为确保约束函数处处可微，我们对不等式两边进行平方，这是一个等价变换，因为两边都是非负的。这样就得到了标准形式 $g_{i}(q) \\le 0$，其中：\n$$\ng_{i}(q) = \\| q - a_{i} \\|^{2} - d_{i}^{2} \\le 0\n$$\n因此，问题是：\n$$\n\\min_{q \\in \\mathbb{R}^2} E(q) \\quad \\text{subject to} \\quad g_{i}(q) \\le 0, \\quad i \\in \\{1, 2, 3\\}\n$$\n\n接下来，我们从第一性原理推导 Karush-Kuhn-Tucker (KKT) 条件。此问题的拉格朗日函数 $\\mathcal{L}$ 定义为：\n$$\n\\mathcal{L}(q, \\lambda) = E(q) + \\sum_{i=1}^{3} \\lambda_{i} g_{i}(q)\n$$\n其中 $\\lambda = (\\lambda_{1}, \\lambda_{2}, \\lambda_{3})$ 是拉格朗日乘子向量。对于一个最优解 $(q^\\star, \\lambda^\\star)$，必须满足以下 KKT 条件：\n$1$. 平稳性：拉格朗日函数关于 $q$ 的梯度必须为零。\n$$\n\\nabla_{q} \\mathcal{L}(q^{\\star}, \\lambda^{\\star}) = \\nabla_{q} E(q^{\\star}) + \\sum_{i=1}^{3} \\lambda_{i}^{\\star} \\nabla_{q} g_{i}(q^{\\star}) = 0\n$$\n$2$. 原始可行性：解 $q^\\star$ 必须满足所有约束。\n$$\ng_{i}(q^{\\star}) \\le 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n$3$. 对偶可行性：所有拉格朗日乘子必须为非负。\n$$\n\\lambda_{i}^{\\star} \\ge 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n$4$. 互补松弛性：每个乘子与其对应约束函数的乘积必须为零。\n$$\n\\lambda_{i}^{\\star} g_{i}(q^{\\star}) = 0, \\quad \\forall i \\in \\{1, 2, 3\\}\n$$\n我们计算必要的梯度。\n目标函数的梯度是：\n$$\n\\nabla_{q} E(q) = \\nabla_{q} \\left( \\frac{1}{2} \\sum_{i=1}^{3} (q - a_{i}) \\cdot (q - a_{i}) \\right) = \\sum_{i=1}^{3} (q - a_{i}) = 3q - \\sum_{i=1}^{3} a_{i}\n$$\n约束函数的梯度是：\n$$\n\\nabla_{q} g_{i}(q) = \\nabla_{q} \\left( \\|q - a_{i}\\|^{2} - d_{i}^{2} \\right) = 2(q - a_{i})\n$$\n将这些代入平稳性条件得到：\n$$\n\\left( 3q^{\\star} - \\sum_{i=1}^{3} a_{i} \\right) + \\sum_{i=1}^{3} \\lambda_{i}^{\\star} (2(q^{\\star} - a_{i})) = 0\n$$\n\n现在，我们针对给定的数据求解 KKT 系统：$a_{1} = (0,0)$，$a_{2} = (2,0)$，$a_{3} = (0,2)$，以及 $d_{1} = \\frac{1}{2}$，$d_{2} = 2$，$d_{3} = 2$。\n令 $q = (x,y)$。目标函数为：\n$$\nE(x,y) = \\frac{1}{2} \\left[ (x^{2} + y^{2}) + ((x-2)^{2} + y^{2}) + (x^{2} + (y-2)^{2}) \\right] = \\frac{1}{2} (3x^{2} - 4x + 3y^{2} - 4y + 8)\n$$\n约束条件为：\n$g_{1}(x,y) = x^{2} + y^{2} - (\\frac{1}{2})^{2} = x^{2} + y^{2} - \\frac{1}{4} \\le 0$\n$g_{2}(x,y) = (x-2)^{2} + y^{2} - 2^{2} = (x-2)^{2} + y^{2} - 4 \\le 0$\n$g_{3}(x,y) = x^{2} + (y-2)^{2} - 2^{2} = x^{2} + (y-2)^{2} - 4 \\le 0$\n\n首先，我们通过令 $E(q)$ 的梯度为零来求其无约束最小值：\n$\\nabla_{q} E(q) = (3x-2, 3y-2) = (0,0)$。\n这得到无约束解 $q_{unc} = (\\frac{2}{3}, \\frac{2}{3})$。\n我们通过评估约束条件来检查该解是否可行：\n$g_{1}(q_{unc}) = (\\frac{2}{3})^{2} + (\\frac{2}{3})^{2} - \\frac{1}{4} = \\frac{4}{9} + \\frac{4}{9} - \\frac{1}{4} = \\frac{8}{9} - \\frac{1}{4} = \\frac{32-9}{36} = \\frac{23}{36} > 0$。\n第一个约束被违反。因此，最优解必定位于可行域的边界上。\n$g_{2}(q_{unc}) = (\\frac{2}{3}-2)^{2} + (\\frac{2}{3})^{2} - 4 = (-\\frac{4}{3})^{2} + \\frac{4}{9} - 4 = \\frac{16}{9} + \\frac{4}{9} - 4 = \\frac{20}{9} - \\frac{36}{9} = -\\frac{16}{9}  0$。\n$g_{3}(q_{unc}) = (\\frac{2}{3})^{2} + (\\frac{2}{3}-2)^{2} - 4 = \\frac{4}{9} + (-\\frac{4}{3})^{2} - 4 = -\\frac{16}{9}  0$。\n由于无约束解仅违反了第一个约束，可以合理地假设约束最优解 $q^{\\star}$ 只有第一个约束是激活的。这意味着 $g_{1}(q^{\\star})=0$，且 $g_{2}(q^{\\star})  0, g_{3}(q^{\\star})  0$。\n根据互补松弛性，这意味着 $\\lambda_{1}^{\\star} > 0$，$\\lambda_{2}^{\\star}=0$ 且 $\\lambda_{3}^{\\star}=0$。\n\n平稳性条件简化为 $\\nabla_{q} E(q^{\\star}) + \\lambda_{1}^{\\star} \\nabla_{q} g_{1}(q^{\\star}) = 0$。\n代入梯度的表达式：\n$(3x^{\\star}-2, 3y^{\\star}-2) + \\lambda_{1}^{\\star} (2x^{\\star}, 2y^{\\star}) = (0,0)$。\n这给出了一个由两个方程组成的方程组：\n$1$. $3x^{\\star} - 2 + 2\\lambda_{1}^{\\star} x^{\\star} = 0 \\implies x^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2$\n$2$. $3y^{\\star} - 2 + 2\\lambda_{1}^{\\star} y^{\\star} = 0 \\implies y^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2$\n从这些方程中，我们可以看出 $x^{\\star} = y^{\\star}$（因为 $\\lambda_1^\\star > 0$，所以 $3+2\\lambda_1^\\star$ 不可能为零）。\n我们使用激活约束条件 $g_{1}(q^{\\star}) = 0$：\n$(x^{\\star})^{2} + (y^{\\star})^{2} - \\frac{1}{4} = 0$。\n代入 $y^{\\star} = x^{\\star}$：\n$2(x^{\\star})^{2} = \\frac{1}{4} \\implies (x^{\\star})^{2} = \\frac{1}{8}$。\n这得到 $x^{\\star} = \\pm \\frac{1}{\\sqrt{8}} = \\pm \\frac{1}{2\\sqrt{2}} = \\pm \\frac{\\sqrt{2}}{4}$。\n无约束最小值 $(\\frac{2}{3}, \\frac{2}{3})$ 位于第一象限。约束最小值必然是圆 $x^{2}+y^{2}=\\frac{1}{4}$ 上距离 $(\\frac{2}{3}, \\frac{2}{3})$ 最近的点，该点也必须位于第一象限。因此，我们选择正解。\n$x^{\\star} = \\frac{\\sqrt{2}}{4}$ 且 $y^{\\star} = \\frac{\\sqrt{2}}{4}$。\n所以，$q^{\\star} = (\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$。\n\n现在我们从平稳性方程中解出 $\\lambda_{1}^{\\star}$：\n$x^{\\star}(3 + 2\\lambda_{1}^{\\star}) = 2 \\implies 3 + 2\\lambda_{1}^{\\star} = \\frac{2}{x^{\\star}} = \\frac{2}{\\sqrt{2}/4} = \\frac{8}{\\sqrt{2}} = 4\\sqrt{2}$。\n$2\\lambda_{1}^{\\star} = 4\\sqrt{2} - 3 \\implies \\lambda_{1}^{\\star} = \\frac{4\\sqrt{2} - 3}{2}$。\n\n我们必须验证我们的解 $(q^{\\star}, \\lambda^{\\star})$，其中 $q^{\\star}=(\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$ 且 $\\lambda^{\\star}=(\\frac{4\\sqrt{2}-3}{2}, 0, 0)$，满足所有 KKT 条件。\n$1$. 平稳性：根据构造已满足。\n$2$. 对偶可行性：$\\lambda_2^\\star=0, \\lambda_3^\\star=0$。对于 $\\lambda_1^\\star$，因为 $4\\sqrt{2} = \\sqrt{32}$ 且 $3 = \\sqrt{9}$，我们有 $4\\sqrt{2} > 3$，所以 $\\lambda_{1}^{\\star} > 0$。条件满足。\n$3$. 原始可行性：\n$g_{1}(q^\\star) = (\\frac{\\sqrt{2}}{4})^2 + (\\frac{\\sqrt{2}}{4})^2 - \\frac{1}{4} = \\frac{2}{16} + \\frac{2}{16} - \\frac{1}{4} = \\frac{4}{16} - \\frac{1}{4} = 0$。（满足）\n$g_{2}(q^\\star) = (\\frac{\\sqrt{2}}{4}-2)^2 + (\\frac{\\sqrt{2}}{4})^2 - 4 = \\frac{2-16\\sqrt{2}+64}{16} + \\frac{2}{16} - 4 = \\frac{68-16\\sqrt{2}}{16} - 4 = \\frac{17-4\\sqrt{2}}{4} - \\frac{16}{4} = \\frac{1 - 4\\sqrt{2}}{4}$。由于 $4\\sqrt{2} > 1$，该值为负。（满足）\n$g_{3}(q^\\star) = (\\frac{\\sqrt{2}}{4})^2 + (\\frac{\\sqrt{2}}{4}-2)^2 - 4 = g_{2}(q^\\star) = \\frac{1 - 4\\sqrt{2}}{4}  0$。（满足）\n$4$. 互补松弛性：\n$\\lambda_1^\\star g_1(q^\\star) = \\lambda_1^\\star \\cdot 0 = 0$。（满足）\n$\\lambda_2^\\star g_2(q^\\star) = 0 \\cdot g_2(q^\\star) = 0$。（满足）\n$\\lambda_3^\\star g_3(q^\\star) = 0 \\cdot g_3(q^\\star) = 0$。（满足）\n\n所有 KKT 条件均得到满足。由于目标函数是严格凸函数，且可行域（闭圆盘的交集）是凸集，因此 KKT 条件是存在唯一全局最小值的充分条件。最优节点位置为 $q^{\\star} = (\\frac{\\sqrt{2}}{4}, \\frac{\\sqrt{2}}{4})$，唯一的非零拉格朗日乘子为 $\\lambda_{1}^{\\star} = \\frac{4\\sqrt{2}-3}{2}$。\n\n最终答案是三元组 $(x^{\\star}, y^{\\star}, \\lambda_{1}^{\\star})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\frac{\\sqrt{2}}{4}  \\frac{\\sqrt{2}}{4}  \\frac{4\\sqrt{2}-3}{2}\n\\end{pmatrix}\n}\n$$", "id": "2407324"}, {"introduction": "接下来，我们将探讨一个计算几何领域的优化问题，即寻找一个区域的“中心点”。这个练习的核心价值在于展示如何通过理论洞察来简化一个看似复杂的问题：将一个针对无穷点集（多边形区域）的优化，转化为一个针对有限点集（凸包顶点）的计算问题。通过这个实践，你将学会如何利用问题的几何与凸性特性来大幅降低求解的复杂度。[@problem_id:2420377]", "problem": "给定平面上一族由简单多边形的并集描述的可行域。对于每个区域，将其极小化极大中心（minimax center）定义为欧几里得平面中使其到该区域内任意点的最大欧几里得距离最小化的点。形式上，对于一个非空紧可行集 $\\mathcal{S} \\subset \\mathbb{R}^2$，定义目标函数\n$$\nf(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2,\n$$\n并将极小化极大中心定义为 $f(\\mathbf{x})$ 的任意一个最小化点 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$。相应的最优目标值是极小化极大半径 $r^\\star = f(\\mathbf{x}^\\star)$。请注意，$\\mathbf{x}^\\star$ 不必属于 $\\mathcal{S}$。\n\n您的任务是编写一个完整的程序，为每个指定的测试用例计算极小化极大中心 $\\mathbf{x}^\\star$ 和极小化极大半径 $r^\\star$，并以数值形式报告它们。\n\n每个测试用例的可行域是 $\\mathbb{R}^2$ 中一个或多个简单多边形的并集，这些多边形由其顶点的逆时针顺序列表给出。每个多边形是由连接连续顶点（最后一个顶点连接回第一个顶点）的直线边所围成的填充区域。所有坐标均以无量纲笛卡尔单位表示。\n\n您必须遵守以下要求：\n\n- 纯粹从数学角度处理问题：给定作为多边形并集的 $\\mathcal{S}$，计算最小化上述定义的 $f(\\mathbf{x})$ 的 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$ 和 $r^\\star \\in \\mathbb{R}_{\\ge 0}$。\n- 答案不需要物理单位，也不需要角度。\n- 您的程序不得硬编码答案。它必须为所描述的任务实现一个通用求解器。\n\n需要实现和求解的测试套件：\n\n- 案例 $\\mathbf{1}$（两个不相交正方形的非凸并集）：\n  - 多边形 $\\mathbf{A}$ 顶点：$\\left(-4,-1\\right)$、$\\left(-2,-1\\right)$、$\\left(-2,1\\right)$、$\\left(-4,1\\right)$。\n  - 多边形 $\\mathbf{B}$ 顶点：$\\left(2,-1\\right)$、$\\left(4,-1\\right)$、$\\left(4,1\\right)$、$\\left(2,1\\right)$。\n\n- 案例 $\\mathbf{2}$（近乎共线的薄矩形，一个边界条件）：\n  - 单个多边形，顶点为：$\\left(0,0\\right)$、$\\left(10,0\\right)$、$\\left(10,0.001\\right)$、$\\left(0,0.001\\right)$。\n\n- 案例 $\\mathbf{3}$（凹U形多边形）：\n  - 单个多边形，顶点为：$\\left(-3,-2\\right)$、$\\left(3,-2\\right)$、$\\left(3,2\\right)$、$\\left(1,2\\right)$、$\\left(1,0\\right)$、$\\left(-1,0\\right)$、$\\left(-1,2\\right)$、$\\left(-3,2\\right)$。\n\n- 案例 $\\mathbf{4}$（由三个点确定最优解的锐角三角形）：\n  - 单个多边形，顶点为：$\\left(0,0\\right)$、$\\left(2,0\\right)$、$\\left(1,\\sqrt{3}\\right)$。\n\n您的程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于每个案例，按上述案例顺序输出一个包含三个浮点数 $\\left[x^\\star, y^\\star, r^\\star\\right]$ 的列表，并精确到 $6$ 位小数。因此，最终输出必须是以下形式：\n$$\n\\left[\\left[x^\\star_1,y^\\star_1,r^\\star_1\\right],\\left[x^\\star_2,y^\\star_2,r^\\star_2\\right],\\left[x^\\star_3,y^\\star_3,r^\\star_3\\right],\\left[x^\\star_4,y^\\star_4,r^\\star_4\\right]\\right].\n$$\n例如，输出格式应类似于 $\\left[\\left[0.000000,0.000000,1.234567\\right],\\ldots\\right]$，不含空格。\n\n您的实现必须是一个完整的、可运行的程序，该程序在内部构建上述测试用例并打印所需的单行输出。", "solution": "所述问题是有效的。这是一个在计算几何领域内适定的优化问题，其表述客观而精确。所有必要的数据都已提供。我将着手解决。\n\n该问题要求为给定的紧集 $\\mathcal{S} \\subset \\mathbb{R}^2$ 计算极小化极大中心 $\\mathbf{x}^\\star \\in \\mathbb{R}^2$ 和相应的极小化极大半径 $r^\\star \\in \\mathbb{R}_{\\ge 0}$。集合 $\\mathcal{S}$ 被描述为简单多边形的并集。极小化极大中心是使得到 $\\mathcal{S}$ 中任意点的最大欧几里得距离最小化的点。这在形式上表述为找到 $\\mathbf{x}^\\star = \\arg\\min_{\\mathbf{x} \\in \\mathbb{R}^2} f(\\mathbf{x})$，其中目标函数为 $f(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$。这等价于寻找集合 $\\mathcal{S}$ 的最小包围圆的圆心和半径。\n\n凸分析的一个基本原理解释了求解路径。对于任何固定点 $\\mathbf{x}$，函数 $g(\\mathbf{y}) = \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2$ 是关于 $\\mathbf{y}$ 的凸函数。定义在紧集上的凸函数在其凸包的极点处达到其最大值。给定的集合 $\\mathcal{S}$ 是多边形的并集，它是一个紧集。令 $\\text{conv}(\\mathcal{S})$ 表示 $\\mathcal{S}$ 的凸包。$\\text{conv}(\\mathcal{S})$ 的极点是输入多边形顶点的一个子集。\n\n设 $V$ 为构成 $\\mathcal{S}$ 的所有多边形的所有顶点的集合。$\\mathcal{S}$ 的凸包与其顶点的凸包相同，即 $\\text{conv}(\\mathcal{S}) = \\text{conv}(V)$。设 $V_{\\text{ext}} \\subseteq V$ 是构成 $\\text{conv}(V)$ 边界的顶点集。因此，目标函数可以被简化，因为从 $\\mathbf{x}$ 到 $\\mathcal{S}$ 中任意点的最大距离将是到这些极值顶点之一的最大距离：\n$$\nf(\\mathbf{x}) = \\max_{\\mathbf{y} \\in \\mathcal{S}} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2 = \\max_{\\mathbf{y} \\in \\text{conv}(\\mathcal{S})} \\lVert \\mathbf{x} - \\mathbf{y} \\rVert_2 = \\max_{\\mathbf{v} \\in V_{\\text{ext}}} \\lVert \\mathbf{x} - \\mathbf{v} \\rVert_2\n$$\n这将问题从处理 $\\mathcal{S}$ 中无限个点简化为处理一个有限点集 $V_{\\text{ext}}$。现在的任务是为这个有限点集 $V_{\\text{ext}}$ 找到最小包围圆。\n\n这个问题可以被构建为一个凸优化问题。设圆的未知中心为 $\\mathbf{x} = (x, y)$，半径为 $r$。我们想要最小化 $r$，这等价于最小化 $r^2$。约束条件是所有点 $\\mathbf{v}_i \\in V_{\\text{ext}}$ 都必须位于该圆的内部或边界上。用数学形式表示为：\n$$\n\\lVert \\mathbf{x} - \\mathbf{v}_i \\rVert_2 \\le r \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n为了给标准求解器创建一个更方便的公式，我们使用半径的平方 $R = r^2$ 和距离的平方：\n$$\n\\lVert \\mathbf{x} - \\mathbf{v}_i \\rVert_2^2 \\le R \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n令 $\\mathbf{v}_i = (v_{ix}, v_{iy})$，则优化问题为：\n$$\n\\min_{x, y, R} R\n$$\n约束条件为：\n$$\n(x - v_{ix})^2 + (y - v_{iy})^2 - R \\le 0 \\quad \\forall \\mathbf{v}_i \\in V_{\\text{ext}}\n$$\n$$\nR \\ge 0\n$$\n这是一个二次约束规划（QCP），具有线性目标函数和凸二次约束。它可以使用标准优化算法进行数值求解。\n\n算法流程如下：\n$1$. 对于每个测试用例，将所有给定多边形的顶点聚合到一个点集 $V$ 中。\n$2$. 计算点集 $V$ 的凸包以识别极值顶点 $V_{\\text{ext}}$。这是通过 `scipy.spatial` 库中的 `ConvexHull` 函数完成的。\n$3$. 解决上述QCP问题。我们使用 `scipy.optimize` 中的 `minimize` 函数，采用序列最小二乘规划（`SLSQP`）方法。优化变量是 $(x, y, R)$。\n$4$. 传递给求解器的目标函数就是 $R$。\n$5$. 约束被构建为一系列函数，每个顶点 $\\mathbf{v}_i \\in V_{\\text{ext}}$ 对应一个，以确保 $(x - v_{ix})^2 + (y - v_{iy})^2 - R \\le 0$。同时对 $R$ 施加非负性边界。\n$6$. 构建一个优化的初始猜测值。使用 $V_{\\text{ext}}$ 的质心作为初始中心 $(x_0, y_0)$，初始半径平方 $R_0$ 是从此质心到 $V_{\\text{ext}}$ 中任意顶点的最大平方距离。\n$7$. 求解器迭代优化此猜测值，以找到最优解 $(x^\\star, y^\\star, R^\\star)$。\n$8$. 最终的极小化极大中心是 $\\mathbf{x}^\\star = (x^\\star, y^\\star)$，极小化极大半径是 $r^\\star = \\sqrt{R^\\star}$。对问题描述中的每个测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.spatial import ConvexHull\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the minimax center problem for the given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: non-convex union of two disjoint squares\n        [[(-4,-1), (-2,-1), (-2,1), (-4,1)],\n         [(2,-1), (4,-1), (4,1), (2,1)]],\n        # Case 2: nearly colinear thin rectangle\n        [[ (0,0), (10,0), (10,0.001), (0,0.001)]],\n        # Case 3: concave U-shaped polygon\n        [[(-3,-2), (3,-2), (3,2), (1,2), (1,0), (-1,0), (-1,2), (-3,2)]],\n        # Case 4: acute triangle\n        [[(0,0), (2,0), (1,math.sqrt(3))]]\n    ]\n\n    def compute_minimax_center(polygons):\n        \"\"\"\n        Computes the minimax center and radius for a set of polygons.\n\n        The problem is reduced to finding the smallest enclosing circle of the\n        set of vertices of the convex hull of the union of the polygons. This\n        is solved as a convex optimization problem.\n        \"\"\"\n        # 1. Aggregate all vertices from all polygons\n        all_vertices = np.vstack([np.array(p, dtype=float) for p in polygons])\n        \n        # Handle cases with few points where ConvexHull would fail\n        unique_vertices = np.unique(all_vertices, axis=0)\n        \n        if unique_vertices.shape[0]  2:\n            center = unique_vertices[0]\n            return center[0], center[1], 0.0\n\n        if unique_vertices.shape[0] == 2:\n            p1, p2 = unique_vertices[0], unique_vertices[1]\n            center = (p1 + p2) / 2.0\n            radius = np.linalg.norm(p1 - p2) / 2.0\n            return center[0], center[1], radius\n\n        # 2. Compute the convex hull of the vertices\n        try:\n            hull = ConvexHull(unique_vertices)\n            hull_vertices = unique_vertices[hull.vertices]\n        except: # QhullError often for colinear points\n             # For colinear points, the smallest enclosing circle's diameter\n             # is the distance between the two extreme points.\n            max_dist = 0\n            p1_max, p2_max = None, None\n            for i in range(len(unique_vertices)):\n                for j in range(i + 1, len(unique_vertices)):\n                    dist = np.linalg.norm(unique_vertices[i] - unique_vertices[j])\n                    if dist > max_dist:\n                        max_dist = dist\n                        p1_max = unique_vertices[i]\n                        p2_max = unique_vertices[j]\n            center = (p1_max + p2_max) / 2.0\n            radius = max_dist / 2.0\n            return center[0], center[1], radius\n\n        # 3. Set up the optimization problem\n        # Variables: p = [x, y, r_squared]\n\n        # Initial guess based on the centroid of the hull vertices\n        initial_center = np.mean(hull_vertices, axis=0)\n        initial_r_squared = np.max(np.sum((hull_vertices - initial_center)**2, axis=1))\n        p0 = np.array([initial_center[0], initial_center[1], initial_r_squared])\n\n        # Objective function: minimize r_squared (p[2])\n        objective = lambda p: p[2]\n\n        # Constraints: (x - v_x)^2 + (y - v_y)^2 = r_squared for each v in hull_vertices\n        # The form for SLSQP is fun(p) >= 0.\n        constraints = []\n        for v in hull_vertices:\n            constraints.append({\n                'type': 'ineq',\n                'fun': lambda p, v_pt=v: p[2] - ((p[0] - v_pt[0])**2 + (p[1] - v_pt[1])**2)\n            })\n\n        # Bounds for variables: r_squared must be non-negative\n        bounds = [(None, None), (None, None), (0, None)]\n\n        # 4. Run the optimizer\n        result = minimize(\n            objective,\n            p0,\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12, # High tolerance for precision\n            options={'maxiter': 1000}\n        )\n        \n        if not result.success:\n            raise RuntimeError(f\"Optimization failed: {result.message}\")\n\n        # 5. Extract and return the results\n        x_star, y_star, r_squared_star = result.x\n        r_star = np.sqrt(r_squared_star)\n\n        return x_star, y_star, r_star\n\n    results = []\n    for case_polygons in test_cases:\n        x_star, y_star, r_star = compute_minimax_center(case_polygons)\n        results.append(f\"[{x_star:.6f},{y_star:.6f},{r_star:.6f}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2420377"}, {"introduction": "最后，我们来解决一个融合了优化与制造约束的现代计算工程设计问题。与寻找单个最优点不同，这里我们的目标是设计一个最优的“结构”，这通常需要在一个巨大的可能性空间中进行搜索。本练习将向你介绍动态规划这一强大的算法思想，它能自底向上地系统性构建最优解，并确保在增材制造（如3D打印）等逐层构建过程中每一步都满足可行性。[@problem_id:2420423]", "problem": "您必须编写一个完整的程序，该程序在给定一个离散化的二维桥梁设计空间的情况下，计算一个在逐层可制造性约束下连接两个基座锚点的最小质量自支撑结构。最终结构在每个中间打印阶段都必须是可行的。\n\n数学模型。考虑一个由立方体素组成的矩形晶格，其水平索引为 $i \\in \\{0,1,\\dots,W-1\\}$，垂直层索引为 $j \\in \\{0,1,\\dots,H\\}$，其中 $W$ 是域宽度，$H$ 是基板（第 $j=0$ 层）上方允许打印的最大层数。一个二进制设计变量 $x_{i,j} \\in \\{0,1\\}$ 表示坐标 $(i,j)$ 处的体素是否被打印。目标是最小化总质量，总质量建模为所有被打印体素的总和，\n$$\n\\min \\; M(x) = \\sum_{j=0}^{H}\\sum_{i=0}^{W-1} x_{i,j}.\n$$\n可制造性是通过一个离散的自支撑约束来实现的，该约束源于熔融沉积成型（FDM）的逐层特性。具体来说，对于给定的每层最大水平支撑偏移量 $s \\in \\mathbb{Z}_{\\ge 1}$，每个在基板上方的被打印体素必须在紧邻的下一层中，在水平距离至多为 $s$ 的范围内，至少有一个支撑体素：\n$$\n\\forall\\, j \\in \\{1,\\dots,H\\}, \\; \\forall\\, i \\in \\{0,\\dots,W-1\\}:\\quad\nx_{i,j} = 1 \\;\\Rightarrow\\; \\sum_{k=\\max(0,i-s)}^{\\min(W-1,i+s)} x_{k,j-1} \\ge 1.\n$$\n第 $j=0$ 层的基础体素被认为由构建板支撑，因此不受上述约束的限制。桥梁必须连接位于 $(0,0)$ 和 $(W-1,0)$ 的两个基座锚点。连通性通过向上的自支撑步长来定义：一条自支撑路径是一个被占据体素的序列 $\\{(i_t,j_t)\\}_{t=0}^{T}$，对于所有的 $t$ 都满足 $j_{t+1}=j_t+1$ 和 $|i_{t+1}-i_t| \\le s$。如果存在两条自支撑路径，一条从 $(0,0)$ 开始，另一条从 $(W-1,0)$ 开始，它们终止于一个共同的体素，并且所有被打印的体素都满足自支撑规则，那么该设计是可行的。在所有此类可行设计中，质量 $M(x)$ 必须被最小化。所有参数均为整数，其中 $W \\in \\mathbb{Z}_{\\ge 1}$，$H \\in \\mathbb{Z}_{\\ge 0}$，$s \\in \\mathbb{Z}_{\\ge 1}$。\n\n您的任务。从上述基本定义出发，推导出一个算法，该算法在给定 $(W,H,s)$ 的情况下，如果问题是可行的，则返回 $M(x)$ 的最小可能值；如果约束下不存在可行的设计，则返回 $-1$。您的算法必须对所有满足所述界限的输入都是正确的。不涉及任何物理单位。\n\n测试套件。您的程序必须为以下参数集计算结果，每个参数集以三元组 $(W,H,s)$ 的形式提供：\n- 案例 A: $(W,H,s) = (9,5,1)$\n- 案例 B: $(W,H,s) = (13,3,2)$\n- 案例 C: $(W,H,s) = (11,4,1)$\n- 案例 D: $(W,H,s) = (1,0,1)$\n- 案例 E: $(W,H,s) = (20,4,3)$\n\n最终输出格式。您的程序应生成单行输出，其中包含以逗号分隔的列表形式的结果，并用方括号括起来，顺序与上述案例相同。每个条目必须是一个整数：如果可行，则为最小质量；如果不可行，则为 $-1$。例如，输出可能看起来像 $[3,5,-1,7,9]$（这只是一个示例，不是给定案例的正确答案）。", "solution": "所提出的问题陈述是计算工程领域内一个良构的优化问题。它具有科学依据，是客观的，并包含足够的信息来推导出唯一的解。定义精确且无矛盾。因此，该问题是有效的，并且可以推导出严谨的解。\n\n任务是在一个 $W \\times (H+1)$ 的体素网格上找到一个最小质量的结构，该结构连接两个锚点 $(0,0)$ 和 $(W-1,0)$，并受逐层自支撑约束的限制。\n\n目标是最小化总质量，即激活体素 $x_{i,j}=1$ 的数量：\n$$\nM(x) = \\sum_{j=0}^{H}\\sum_{i=0}^{W-1} x_{i,j}\n$$\n\n一个可行的结构必须满足两个条件：\n$1$. 连通性要求：必须存在两条自支撑路径，一条从左锚点 $(0,0)$ 开始，另一条从右锚点 $(W-1,0)$ 开始，它们在一个共同的体素处相遇。一条自支撑路径是一个体素序列 $\\{(i_t, j_t)\\}_{t=0}^{T}$，其中每个后续体素 $(i_{t+1}, j_{t+1})$ 都满足 $j_{t+1} = j_t+1$ 和 $|i_{t+1}-i_t| \\le s$。\n$2$. 全局自支撑规则：对于 $j \\ge 1$，每个激活体素 $x_{i,j}=1$ 必须由下方层中水平距离 $s$ 范围内至少一个激活体素支撑。这表示为：\n$$\nx_{i,j} = 1 \\implies \\exists k \\in [\\max(0, i-s), \\min(W-1, i+s)] \\text{ such that } x_{k,j-1} = 1\n$$\n\n最优性原理要求最小质量结构不包含任何多余的体素。任何不属于连接路径或不提供必要支撑的体素都将被移除以减少质量。因此，最小结构恰好由两条自支撑路径的并集构成。问题因此等价于找到两条这样的路径，使其体素的并集最小。\n\n这种问题结构适合使用动态规划。我们通过层索引以及两条生长中路径端点的水平位置来定义一个状态。设 $dp[j][i_L][i_R]$ 为由两条分别源于 $(0,0)$ 和 $(W-1,0)$ 的自支撑路径组成的结构的最小可能质量，这两条路径终止于第 $j$ 层，水平位置分别为 $i_L$ 和 $i_R$。\n\n状态空间定义为 $j \\in \\{0, \\dots, H\\}$，$i_L \\in \\{0, \\dots, W-1\\}$ 和 $i_R \\in \\{0, \\dots, W-1\\}$。\n\n基本情况在第 $j=0$ 层。两条路径必须从锚点开始。\n如果 $W=1$，锚点是相同的。位于 $(0,0)$ 的单个体素构成一个质量为 $1$ 的有效连通结构。$dp[0][0][0] = 1$。\n如果 $W>1$，路径从 $(0,0)$ 和 $(W-1,0)$ 开始。初始结构包含两个体素。因此，$dp[0][0][W-1] = 2$。\n在 $j=0$ 时的所有其他状态都是不可达的，因此它们的成本初始化为无穷大：\n$$\ndp[0][i_L][i_R] = \\infty \\quad \\forall (i_L, i_R) \\neq \\begin{cases} (0,0)  \\text{if } W=1 \\\\ (0,W-1)  \\text{if } W>1 \\end{cases}\n$$\n\n对于递推关系，考虑 $j>0$ 时的状态 $dp[j][i_L][i_R]$。路径从下方层的一些有效位置 $(p_L, j-1)$ 和 $(p_R, j-1)$ 到达 $(i_L, j)$ 和 $(i_R, j)$。自支撑约束要求 $|i_L-p_L| \\le s$ 和 $|i_R-p_R| \\le s$。从第 $j-1$ 层的状态转移到第 $j$ 层的状态的成本是在第 $j$ 层新增的体素数量。如果 $i_L \\neq i_R$，则为 $2$；如果 $i_L = i_R$，则为 $1$。\n\n为了在 $(j, i_L, i_R)$ 处达到最小质量，我们必须从第 $j-1$ 层中成本最低的有效前驱状态转移而来。因此，递推关系为：\n$$\ndp[j][i_L][i_R] = \\left(2 - \\delta_{i_L, i_R}\\right) + \\min_{\\substack{p_L \\in [\\max(0, i_L-s), \\min(W-1, i_L+s)] \\\\ p_R \\in [\\max(0, i_R-s), \\min(W-1, i_R+s)]}} \\left\\{ dp[j-1][p_L][p_R] \\right\\}\n$$\n其中 $\\delta_{i_L, i_R}$ 是克罗内克 delta，如果 $i_L=i_R$ 则为 $1$，否则为 $0$。\n\n最小化项代表了在 $dp[j-1]$ 成本矩阵的一个矩形区域上的二维范围最小值查询。这可以被高效地计算。对于每个状态 $(j, i_L, i_R)$，我们在由支撑约束定义的 $dp[j-1]$ 子矩阵中找到最小值。\n\n在填充了从 $j=1$ 到 $H$ 的整个 DP 表之后，通过在所有可行的最终结构中确定最小质量来找到解。一个可行的结构是路径相遇的结构，即 $i_L = i_R$。相遇可以发生在任何体素 $(i, j)$，其中 $j \\in \\{0, \\dots, H\\}$ 且 $i \\in \\{0, \\dots, W-1\\}$。这种结构的成本由 $dp[j][i][i]$ 给出。总的最小质量是这些值在所有可能的相遇点上的最小值。\n$$\nM_{min} = \\min_{\\substack{j \\in \\{0, \\dots, H\\} \\\\ i \\in \\{0, \\dots, W-1\\}}} \\left\\{ dp[j][i][i] \\right\\}\n$$\n\n如果这个最小值为无穷大，则意味着在给定的约束（$W, H, s$）内路径不可能相遇，问题是不可行的。在这种情况下，指定的输出为 $-1$。\n\n算法摘要：\n$1$. 处理 $W=1$ 的平凡情况：质量为 $1$。\n$2$. 用 $\\infty$ 初始化一个三维 DP 表 $dp[H+1][W][W]$。\n$3$. 设置基本情况：$dp[0][0][W-1] = 2$。\n$4$. 从 $1$ 到 $H$ 迭代 $j$。对于每个 $j$，使用递推关系基于 $dp[j-1]$ 计算 $dp[j]$ 矩阵。对每个状态 $(i_L, i_R)$ 的最小化是在 $dp[j-1]$ 矩阵中一个尺寸最大为 $(2s+1) \\times (2s+1)$ 的矩形窗口上执行。\n$5$. DP 表完成后，找到所有层矩阵对角线上的最小值：对于所有 $i$ 的 $\\min(dp[:, i, i])$。\n$6$. 如果得到的最小值为 $\\infty$，则返回 $-1$。否则，返回最小质量（作为整数）。该算法能为任何有效输入正确地确定最小质量。", "answer": "```python\nimport numpy as np\n\ndef solve_case(W, H, s):\n    \"\"\"\n    Computes the minimal mass of a self-supporting bridge structure.\n\n    This function uses dynamic programming to solve the problem. The state is\n    defined as dp[j][i_L][i_R], representing the minimum mass of a structure\n    with two paths ending at layer j, at horizontal positions i_L and i_R.\n    \"\"\"\n    if W = 0 or H  0 or s = 0:\n        # Invalid parameters based on problem constraints\n        return -1\n\n    if W == 1:\n        # If width is 1, anchors are at the same point. A single voxel is sufficient.\n        return 1\n\n    # dp[j][i_L][i_R]: min mass for paths ending at (i_L, j) and (i_R, j)\n    # Using np.inf for unreachable states.\n    dp = np.full((H + 1, W, W), np.inf, dtype=np.float64)\n\n    # Base case at j=0 (build plate)\n    # The two paths start at the anchors (0,0) and (W-1,0). Mass is 2.\n    dp[0, 0, W - 1] = 2.0\n\n    # Iterate through layers from 1 to H\n    for j in range(1, H + 1):\n        # We can optimize the search for the minimum in the previous layer's window.\n        # Instead of a complex sliding window, a direct slicing approach with NumPy\n        # is clear and fast enough for the given constraints.\n        prev_dp = dp[j - 1, :, :]\n        \n        # This part can be slow if written with Python loops.\n        # Let's vectorize or use efficient lookups.\n        # A 2D range minimum query structure would be optimal, but let's precompute.\n        \n        # Precompute horizontal sliding window minimums\n        h_min_vals = np.full((W, W), np.inf)\n        for r in range(W):\n            if np.all(np.isinf(prev_dp[r, :])):\n                continue\n            # Deque-based sliding window minimum for O(W) per row\n            q = []\n            # Simple (but slower O(W*s)) implementation of sliding window min for each row\n            for c in range(W):\n                c_min = max(0, c - s)\n                c_max = min(W, c + s + 1)\n                h_min_vals[r, c] = np.min(prev_dp[r, c_min:c_max])\n\n        # Precompute vertical sliding window minimums on the result of horizontal mins\n        min_prev_dp = np.full((W, W), np.inf)\n        for c in range(W):\n            if np.all(np.isinf(h_min_vals[:, c])):\n                continue\n            for r in range(W):\n                r_min = max(0, r - s)\n                r_max = min(W, r + s + 1)\n                min_prev_dp[r, c] = np.min(h_min_vals[r_min:r_max, c])\n        \n        # Compute dp for current layer j\n        for i_L in range(W):\n            for i_R in range(W):\n                min_cost = min_prev_dp[i_L, i_R]\n                if np.isinf(min_cost):\n                    continue\n                \n                cost_increment = 2.0 if i_L != i_R else 1.0\n                dp[j, i_L, i_R] = min_cost + cost_increment\n\n    # The minimal mass is the minimum of all states where the paths meet (i_L == i_R)\n    min_mass = np.inf\n    for j in range(H + 1):\n        for i in range(W):\n            min_mass = min(min_mass, dp[j, i, i])\n    \n    if np.isinf(min_mass):\n        return -1\n    else:\n        return int(min_mass)\n\ndef solve():\n    \"\"\"\n    Runs the solver for the given test suite and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        (9, 5, 1),   # Case A\n        (13, 3, 2),  # Case B\n        (11, 4, 1),  # Case C\n        (1, 0, 1),   # Case D\n        (20, 4, 3),  # Case E\n    ]\n\n    results = []\n    for W, H, s in test_cases:\n        result = solve_case(W, H, s)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420423"}]}