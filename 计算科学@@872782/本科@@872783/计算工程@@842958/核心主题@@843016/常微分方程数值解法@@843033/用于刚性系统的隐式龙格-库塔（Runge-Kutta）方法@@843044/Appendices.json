{"hands_on_practices": [{"introduction": "理解数值方法的稳定性是掌握刚性系统的关键。这个练习 [@problem_id:2402097] 通过一个引人注目的例子，即尝试将一个刚性方程进行时间反向积分，来清晰地展示这一点。在这种情况下，显式方法会灾难性地失败，从而突显了隐式龙格-库塔方法卓越的稳定性。", "problem": "考虑由 $y'(t) = \\lambda\\, y(t)$ 给出的线性刚性常微分方程（ODE），其指定终端值为 $y(T) = 1$。目标是通过使用负步长从 $t = T$ 反向积分到 $t = 0$ 来计算 $y(0)$。其精确解为 $y(t) = \\exp(\\lambda (t - T))$，因此 $y(0) = \\exp(-\\lambda T)$。\n\n为从 $t_n$ 到 $t_{n+1} = t_n + h$ 的单步定义一族单步法如下，其中 $h  0$ 表示负时间步长，$z = h \\lambda$：\n- 显式前向欧拉法为 $y_{n+1} = y_n + h \\lambda y_n = (1 + z)\\, y_n$。\n- 所用的隐式龙格-库塔（IRK）方法是两阶段单对角隐式龙格-库塔（SDIRK）格式，其参数为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。其 Butcher 表为\n$$\n\\begin{array}{c|cc}\n\\gamma   \\gamma   0 \\\\\n1   1-\\gamma   \\gamma \\\\\n\\hline\n  1-\\gamma   \\gamma\n\\end{array}\n$$\n对于标量线性测试方程 $y' = \\lambda y$，该 SDIRK 方法的稳定性函数为\n$$\nR(z) = \\frac{1 + (1 - 2\\gamma)\\, z}{(1 - \\gamma z)^2},\n$$\n因此一步映射为 $y_{n+1} = R(z)\\, y_n$。\n\n您的程序必须对每个测试用例，从 $y_N = y(T) = 1$ 开始，使用大小为 $h = -T/N$ 的 $N$ 个均匀步长反向步进到 $t = 0$，一次使用显式前向欧拉更新因子 $(1 + z)$，另一次使用 SDIRK 稳定性函数 $R(z)$。令 $t = 0$ 处的两个数值近似值分别表示为 $y_{\\text{explicit}}(0)$ 和 $y_{\\text{IRK}}(0)$。令精确值为 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。对每个测试用例，计算绝对误差\n$$\ne_{\\text{IRK}} = \\left| y_{\\text{IRK}}(0) - y_{\\text{exact}}(0) \\right|,\\quad\ne_{\\text{explicit}} = \\left| y_{\\text{explicit}}(0) - y_{\\text{exact}}(0) \\right|.\n$$\n\n使用以下参数测试套件 $(\\lambda, T, N)$：\n- 测试 1（刚性，中等大小的反向步长）：$(\\lambda, T, N) = (1000, 0.1, 5)$。\n- 测试 2（单步反向积分下显式欧拉法的稳定性边界）：$(\\lambda, T, N) = (2, 1, 1)$。\n- 测试 3（非常刚性，中等大小的反向步长）：$(\\lambda, T, N) = (5000, 0.05, 5)$。\n\n所有量均为无量纲；不涉及物理单位。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[e_{\\text{IRK}}^{(1)}, e_{\\text{explicit}}^{(1)}, e_{\\text{IRK}}^{(2)}, e_{\\text{explicit}}^{(2)}, e_{\\text{IRK}}^{(3)}, e_{\\text{explicit}}^{(3)}]$，其中上标表示测试用例索引。每个条目必须是浮点数。", "solution": "问题陈述已经过严格评估，被认为是有效的。它构成了计算数学中一个适定问题，特别是在刚性常微分方程的数值分析领域。所有给出的定义、常数和方程均符合既定原则。任务是比较一个显式和一个隐式龙格-库塔 (Runge-Kutta) 方法在刚性问题上的性能，这是演示数值稳定性概念的典型练习。\n\n问题的核心在于求解线性常微分方程（ODE）$y'(t) = \\lambda y(t)$，其终端条件为 $y(T) = 1$。积分是随时间从 $t=T$ 反向进行到 $t=0$。这个初值问题的精确解是 $y(t) = C \\exp(\\lambda t)$。利用终端条件，我们得到 $1 = C \\exp(\\lambda T)$，这意味着 $C = \\exp(-\\lambda T)$。因此，精确解是 $y(t) = \\exp(\\lambda(t-T))$。在初始时间 $t=0$ 的精确值因此是 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。\n\n我们需要使用两种数值格式，通过 $N$ 个均匀步长来近似该解。从 $t=T$ 到 $t=0$ 的反向积分时间步长为负，由 $h = (0 - T) / N = -T/N$ 给出。\n\n对于标量线性测试方程 $y'=\\lambda y$，单步法从 $y_n$ 到 $y_{n+1}$ 的一步可以表示为 $y_{n+1} = R(z) y_n$，其中 $R(z)$ 是方法的稳定性函数，$z = h\\lambda$。因此，从初值 $y_0 = y(T) = 1$ 开始经过 $N$ 步后，在最终时间 $t_N = T+Nh = T+N(-T/N) = 0$ 的数值近似由 $y_{\\text{num}}(0) = [R(z)]^N y_0 = [R(z)]^N$ 给出。\n\n数值积分的稳定性取决于稳定性函数的大小，即 $|R(z)|$。为了计算稳定，我们需要 $|R(z)| \\leq 1$。如果 $|R(z)| > 1$，数值解将会发散，误差呈指数级增长。所给的测试用例涉及大的正 $\\lambda$ 值和负的 $h$ 值，导致 $z = h\\lambda$ 成为大的负值。这代表了一个刚性问题情景。\n\n要比较的两种方法是：\n$1$. 显式前向欧拉法。其稳定性函数为 $R_{\\text{explicit}}(z) = 1 + z$。在 $t=0$ 的数值近似为 $y_{\\text{explicit}}(0) = (1 + h\\lambda)^N$。该方法的稳定域是 $|1+z| \\le 1$，这是复平面上以 $z=-1$ 为中心、半径为 $1$ 的圆盘。对于实数 $z$，这对应于区间 $[-2, 0]$。\n\n$2$. 两阶段单对角隐式龙格-库塔（SDIRK）方法。稳定性函数由 $R_{\\text{IRK}}(z) = \\frac{1 + (1 - 2\\gamma)z}{(1 - \\gamma z)^2}$ 给出，参数为 $\\gamma = 1 - \\frac{1}{\\sqrt{2}}$。在 $t=0$ 的数值近似为 $y_{\\text{IRK}}(0) = [R_{\\text{IRK}}(h\\lambda)]^N$。该方法是 L-稳定的，意味着它是 A-稳定的（其稳定域包含整个左半复平面，即 $\\text{Re}(z) \\le 0$），并且还满足 $\\lim_{z \\to -\\infty} |R(z)| = 0$。这个性质对于刚性问题非常理想，因为它能有效地衰减高频（瞬态）分量。\n\n每个测试用例 $(\\lambda, T, N)$ 的计算过程如下：\n$1$. 计算步长 $h = -T/N$ 和参数 $z = h\\lambda$。\n$2$. 计算数值解 $y_{\\text{explicit}}(0) = (1+z)^N$ 和 $y_{\\text{IRK}}(0) = [R_{\\text{IRK}}(z)]^N$。\n$3$. 计算精确解 $y_{\\text{exact}}(0) = \\exp(-\\lambda T)$。\n$4$. 计算绝对误差 $e_{\\text{explicit}} = | y_{\\text{explicit}}(0) - y_{\\text{exact}}(0) |$ 和 $e_{\\text{IRK}} = | y_{\\text{IRK}}(0) - y_{\\text{exact}}(0) |$。\n\n此过程将针对三个指定的测试用例分别执行，并将结果以要求的格式呈现。刚性情况（测试1和3）预计会显示显式方法由于不稳定性（$|z| > 2$）而出现严重失败，而 L-稳定的 SDIRK 方法应产生一个小的、可控的误差。测试2将显式方法置于其稳定域的边界上，预计与 SDIRK 方法相比，其结果也会很差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the error of explicit Euler and a SDIRK method\n    for a stiff ODE integrated backward in time.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1000.0, 0.1, 5),   # Test 1 (stiff, moderately large backward step)\n        (2.0, 1.0, 1),      # Test 2 (boundary of explicit Euler stability)\n        (5000.0, 0.05, 5),  # Test 3 (very stiff, moderately large backward steps)\n    ]\n\n    results = []\n    \n    # Define the SDIRK method parameter gamma\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n\n    for case in test_cases:\n        lambda_val, T, N = case\n\n        # Calculate the uniform negative step size h and the parameter z\n        h = -T / N\n        z = h * lambda_val\n\n        # --- Method 1: Explicit Forward Euler ---\n        # The stability function for forward Euler is R(z) = 1 + z.\n        R_explicit = 1.0 + z\n        # The numerical solution at t=0 is obtained by applying the update N times, starting from y(T)=1.\n        y_explicit_0 = R_explicit**N\n\n        # --- Method 2: SDIRK ---\n        # The stability function for the SDIRK method is R(z) = (1 + (1-2g)z) / (1 - gz)^2.\n        R_irk_numerator = 1.0 + (1.0 - 2.0 * gamma) * z\n        R_irk_denominator = (1.0 - gamma * z)**2\n        R_irk = R_irk_numerator / R_irk_denominator\n        # The numerical solution at t=0 after N steps.\n        y_irk_0 = R_irk**N\n\n        # --- Exact Solution ---\n        # The exact solution is y(t) = exp(lambda * (t - T)), so y(0) = exp(-lambda*T).\n        y_exact_0 = np.exp(-lambda_val * T)\n\n        # --- Compute Absolute Errors ---\n        # error = | y_numerical(0) - y_exact(0) |\n        e_irk = np.abs(y_irk_0 - y_exact_0)\n        e_explicit = np.abs(y_explicit_0 - y_exact_0)\n\n        results.append(e_irk)\n        results.append(e_explicit)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2402097"}, {"introduction": "在我们理解了为何需要隐式方法之后，这个实践将重点转向具体的实现细节。该练习 [@problem_id:2402149] 指导您为一个特定的单对角隐式龙格-库塔（Singly Diagonally Implicit Runge-Kutta, SDIRK）方法构建求解器，以在各种基准测试案例上验证您的实现。", "problem": "给定一个由常微分方程 $y'(t) = f(t,y)$ 和初始条件 $y(t_0) = y_0$ 定义的初值问题，其中 $y \\in \\mathbb{R}^d$。实现一个固定步长、两阶段的单对角隐式龙格-库塔方法（Singly Diagonally Implicit Runge–Kutta (SDIRK)，这是一类对角隐式龙格-库塔方法），该方法由以下 Butcher 积分表定义，其对角系数为 $\\gamma = 1 - 1/\\sqrt{2}$：\n$$\n\\begin{array}{c|cc}\n\\gamma   \\gamma   0 \\\\\n1   1 - 2\\gamma   \\gamma \\\\\n\\hline\n   \\tfrac{1}{2}   \\tfrac{1}{2}\n\\end{array}\n$$\n即，$A = \\begin{bmatrix} \\gamma   0 \\\\ 1 - 2\\gamma   \\gamma \\end{bmatrix}$，$b = \\begin{bmatrix} \\tfrac{1}{2}   \\tfrac{1}{2} \\end{bmatrix}$，$c = \\begin{bmatrix} \\gamma   1 \\end{bmatrix}^\\top$，其中 $\\gamma = 1 - 1/\\sqrt{2}$。对于大小为 $h > 0$ 的每个时间步，计算内嵌阶段并构成更新式 $y_{n+1} = y_n + h \\sum_{i=1}^2 b_i f(t_n + c_i h, Y_i)$。阶段 $Y_i$ 的非线性代数方程必须在无穷范数下求解，绝对容差为 $10^{-12}$。假设每个测试用例的雅可比矩阵 $\\partial f/\\partial y$ 都是可用的。\n\n您的实现必须对维度 $d \\ge 1$ 具有通用性，使用一个固定的步长 $h$，该步长可以整除 $T - t_0$ 以使得步数 $N = (T - t_0)/h$ 为整数，并且必须适用于刚性问题。\n\n测试套件。实现求解器并将其应用于以下五个测试用例，每个用例都由函数 $f(t,y)$、其雅可比矩阵 $J(t,y) = \\partial f/\\partial y$、初始数据、区间和步长定义：\n\n- 测试 $1$（标量线性刚性衰减）：\n  - 维度：$d = 1$。\n  - 右端项：$f(t,y) = -\\lambda y$，其中 $\\lambda = 1000$。\n  - 雅可比矩阵：$J(t,y) = [-\\lambda]$。\n  - 初始条件：$y_0 = 1$ 于 $t_0 = 0$。\n  - 终止时间：$T = 1$。\n  - 步长：$h = 0.1$。\n\n- 测试 $2$（刚性 Van der Pol 振子）：\n  - 维度：$d = 2$，其中 $y = [x, v]^\\top$。\n  - 参数：$\\mu = 100$。\n  - 右端项：$f(t, [x, v]^\\top) = \\begin{bmatrix} v \\\\ \\mu (1 - x^2) v - x \\end{bmatrix}$。\n  - 雅可比矩阵：$J(t, [x, v]^\\top) = \\begin{bmatrix} 0   1 \\\\ -2\\mu x v - 1   \\mu (1 - x^2) \\end{bmatrix}$。\n  - 初始条件：$y_0 = [2, 0]^\\top$ 于 $t_0 = 0$。\n  - 终止时间：$T = 0.3$。\n  - 步长：$h = 0.001$。\n  - 要求报告的量：第一个分量 $x(T)$。\n\n- 测试 $3$（Robertson 化学动力学，刚性，三种物质）：\n  - 维度：$d = 3$，其中 $y = [y_1, y_2, y_3]^\\top$。\n  - 右端项：\n    $$\n    \\begin{aligned}\n    f_1 = -0.04 y_1 + 10^4 y_2 y_3, \\\\\n    f_2 = 0.04 y_1 - 10^4 y_2 y_3 - 3 \\cdot 10^7 y_2^2, \\\\\n    f_3 = 3 \\cdot 10^7 y_2^2.\n    \\end{aligned}\n    $$\n  - 雅可比矩阵：\n    $$\n    J = \\begin{bmatrix}\n    -0.04   10^4 y_3   10^4 y_2 \\\\\n    0.04   -10^4 y_3 - 6 \\cdot 10^7 y_2   -10^4 y_2 \\\\\n    0   6 \\cdot 10^7 y_2   0\n    \\end{bmatrix}.\n    $$\n  - 初始条件：$y_0 = [1, 0, 0]^\\top$ 于 $t_0 = 0$。\n  - 终止时间：$T = 10^{-4}$。\n  - 步长：$h = 10^{-6}$。\n  - 要求报告的量：第三个分量 $y_3(T)$。\n\n- 测试 $4$（零向量场，不变性检查）：\n  - 维度：$d = 1$。\n  - 右端项：$f(t,y) = 0$。\n  - 雅可比矩阵：$J(t,y) = [0]$。\n  - 初始条件：$y_0 = -5.5$ 于 $t_0 = 0$。\n  - 终止时间：$T = 3.7$。\n  - 步长：$h = 0.37$。\n\n- 测试 $5$（线性、非正规、中度刚性 $2 \\times 2$ 系统）：\n  - 维度：$d = 2$，其中 $y = [y_1, y_2]^\\top$。\n  - 矩阵：$A = \\begin{bmatrix} -50   49 \\\\ 0   -1 \\end{bmatrix}$。\n  - 右端项：$f(t,y) = A y$。\n  - 雅可比矩阵：$J(t,y) = A$。\n  - 初始条件：$y_0 = [1, 1]^\\top$ 于 $t_0 = 0$。\n  - 终止时间：$T = 1$。\n  - 步长：$h = 0.05$。\n  - 要求报告的量：第一个分量 $y_1(T)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，按测试 1 到 5 的顺序排列，其中每个条目都是一个四舍五入到 $10$ 位小数的实数。对于测试 2 和 5，报告最终时间的第一个分量；对于测试 3，报告最终时间的第三个分量；对于测试 1 和 4，报告最终时间的标量状态。例如，输出格式必须严格为\n$[r_1,r_2,r_3,r_4,r_5]$\n不含空格，其中每个 $r_i$ 都按规定四舍五入到 $10$ 位小数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于常微分方程的数值方法理论，是一个信息完备的适定问题，并且表述客观。所提供的测试用例是刚性积分器的标准基准。我们可以着手进行求解。\n\n任务是实现一个特定的两阶段单对角隐式龙格-库塔 (SDIRK) 方法，用于求解初值问题 $y'(t) = f(t,y)$, $y(t_0) = y_0$。该方法由 Butcher 积分表定义：\n$$\n\\begin{array}{c|cc}\n\\gamma   \\gamma   0 \\\\\n1   1 - 2\\gamma   \\gamma \\\\\n\\hline\n   \\tfrac{1}{2}   \\tfrac{1}{2}\n\\end{array}\n$$\n其中参数 $\\gamma = 1 - 1/\\sqrt{2}$。这对应于系数 $c_1 = \\gamma$, $c_2 = 1$；$b_1 = 1/2$, $b_2 = 1/2$；以及矩阵 $A = \\begin{bmatrix} \\gamma   0 \\\\ 1 - 2\\gamma   \\gamma \\end{bmatrix}$。\n\n一个通用的 $s$ 阶段龙格-库塔方法通过以下公式将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$ y_{n+1} = y_n + h \\sum_{i=1}^s b_i k_i $$\n其中阶段导数 $k_i$ 与阶段值 $Y_i$ 通过 $k_i = f(t_n + c_i h, Y_i)$ 相关联。阶段 $Y_i$ 由以下方程组隐式定义：\n$$ Y_i = y_n + h \\sum_{j=1}^s a_{ij} k_j = y_n + h \\sum_{j=1}^s a_{ij} f(t_n + c_j h, Y_j) $$\n对于指定的方法，阶段由以下公式给出：\n$$ Y_1 = y_n + h \\gamma k_1 $$\n$$ Y_2 = y_n + h (1 - 2\\gamma) k_1 + h \\gamma k_2 $$\n代入 $k_i$ 的定义，得到关于阶段导数 $k_1, k_2 \\in \\mathbb{R}^d$ 的方程组：\n$$ k_1 = f(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n$$ k_2 = f(t_n + h, y_n + h(1 - 2\\gamma)k_1 + h \\gamma k_2) $$\n矩阵 $A$ 的下三角结构允许这些方程可以顺序求解。这类方法被称为对角隐式龙格-库塔 (DIRK) 方法。因为对角元素 $a_{11}$ 和 $a_{22}$ 相同 ($a_{ii} = \\gamma$)，所以这是一种单对角隐式龙格-库塔 (SDIRK) 方法，它为刚性系统提供了计算优势。\n\n实现的核心是在每个时间步求解这些关于 $k_1$ 和 $k_2$ 的非线性代数方程。对于刚性问题，其雅可比矩阵 $\\partial f / \\partial y$ 具有大特征值，这些方程不能通过简单的函数迭代来求解。相反，需要一个如牛顿法之类的鲁棒求根算法。\n\n对于第一阶段，我们必须找到函数 $G_1(k_1) = 0$ 的根，其中：\n$$ G_1(k_1) = k_1 - f(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n$k_1$ 的牛顿迭代由下式给出：\n$$ k_1^{(m+1)} = k_1^{(m)} - [J_{G_1}(k_1^{(m)})]^{-1} G_1(k_1^{(m)}) $$\n其中 $m$ 是迭代指数，$J_{G_1}$ 是 $G_1$ 关于 $k_1$ 的雅可比矩阵：\n$$ J_{G_1}(k_1) = \\frac{\\partial G_1}{\\partial k_1} = I - h \\gamma \\frac{\\partial f}{\\partial y}(t_n + \\gamma h, y_n + h \\gamma k_1) $$\n这里，$I$ 是维度为 $d$ 的单位矩阵。每次迭代都需要求解一个线性系统以获得修正量 $\\Delta k_1^{(m)}$：\n$$ (I - h \\gamma J_f) \\Delta k_1^{(m)} = -G_1(k_1^{(m)}) $$\n其中 $J_f$ 是 $f$ 的雅可比矩阵，在 $(t_n + \\gamma h, y_n + h \\gamma k_1^{(m)})$ 处求值。迭代从一个初始猜测（如 $k_1^{(0)} = \\mathbf{0}$）开始，直到残差的无穷范数 $\\|G_1(k_1^{(m)})\\|_\\infty$ 小于指定的容差 $10^{-12}$。\n\n一旦 $k_1$ 收敛，我们通过找到 $G_2(k_2) = 0$ 的根来求解第二阶段的导数 $k_2$：\n$$ G_2(k_2) = k_2 - f(t_n + h, y_n + h(1-2\\gamma)k_1 + h \\gamma k_2) $$\n$k_2$ 的牛顿迭代是类似的。对应的修正量 $\\Delta k_2^{(m)}$ 的线性系统是：\n$$ (I - h \\gamma J_f) \\Delta k_2^{(m)} = -G_2(k_2^{(m)}) $$\n其中 $J_f$ 现在在 $(t_n + h, y_n + h(1-2\\gamma)k_1 + h \\gamma k_2^{(m)})$ 处求值。该线性系统的矩阵 $I - h\\gamma J_f$ 对两个阶段具有相同的结构，这是 SDIRK 方法的定义特征。为了获得最大的鲁棒性，将使用完整的牛顿法，即在每次迭代中重新计算雅可比矩阵 $J_f$。\n\n在 $k_1$ 和 $k_2$ 都计算到所需容差后，解向前推进：\n$$ y_{n+1} = y_n + \\frac{h}{2} (k_1 + k_2) $$\n整个过程重复指定的步数 $N = (T-t_0)/h$，以获得在最终时间 $T$ 的解。该实现必须对任何维度 $d \\ge 1$ 都是通用的。为每个测试用例提供解析雅可比矩阵对于牛顿求解器的效率和准确性至关重要，特别是对于刚性系统。最终呈现的代码严格遵循了这一逻辑和数值分析框架。", "answer": "```python\nimport numpy as np\n\ndef sdirk_solver(f, jac, y0, t0, T, h):\n    \"\"\"\n    Solves an initial value problem using a 2-stage SDIRK method.\n\n    Args:\n        f (callable): The right-hand side function f(t, y).\n        jac (callable): The Jacobian of f, J(t, y).\n        y0 (np.ndarray): The initial condition vector.\n        t0 (float): The initial time.\n        T (float): The final time.\n        h (float): The fixed step size.\n\n    Returns:\n        np.ndarray: The solution vector at time T.\n    \"\"\"\n    gamma = 1.0 - 1.0 / np.sqrt(2.0)\n    b1, b2 = 0.5, 0.5\n    a11 = gamma\n    a21 = 1.0 - 2.0 * gamma\n    a22 = gamma\n    c1, c2 = gamma, 1.0\n    tol = 1e-12\n    max_newton_iter = 50\n    dim = len(y0)\n    identity = np.eye(dim)\n\n    # Use np.isclose for robust comparison with floating point numbers\n    num_steps = round((T - t0) / h)\n    if not np.isclose(t0 + num_steps * h, T):\n        raise ValueError(\"Step size h must divide the interval T-t0 exactly.\")\n        \n    t = t0\n    y = y0.copy()\n\n    for _ in range(num_steps):\n        # Stage 1\n        k1 = np.zeros(dim)\n        for _ in range(max_newton_iter):\n            y1_arg = y + h * a11 * k1\n            t1_arg = t + c1 * h\n            g1 = k1 - f(t1_arg, y1_arg)\n            \n            if np.linalg.norm(g1, ord=np.inf)  tol:\n                break\n                \n            j_f_val = jac(t1_arg, y1_arg)\n            m_matrix = identity - h * a11 * j_f_val\n            delta_k1 = np.linalg.solve(m_matrix, -g1)\n            k1 += delta_k1\n        else:\n            raise RuntimeError(\"Newton's method failed to converge for stage 1.\")\n\n        # Stage 2\n        k2 = np.zeros(dim)\n        for _ in range(max_newton_iter):\n            y2_arg = y + h * a21 * k1 + h * a22 * k2\n            t2_arg = t + c2 * h\n            g2 = k2 - f(t2_arg, y2_arg)\n\n            if np.linalg.norm(g2, ord=np.inf)  tol:\n                break\n\n            j_f_val = jac(t2_arg, y2_arg)\n            m_matrix = identity - h * a22 * j_f_val\n            delta_k2 = np.linalg.solve(m_matrix, -g2)\n            k2 += delta_k2\n        else:\n            raise RuntimeError(\"Newton's method failed to converge for stage 2.\")\n            \n        y += h * (b1 * k1 + b2 * k2)\n        t += h\n        \n    return y\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite for the SDIRK solver.\n    \"\"\"\n    test_cases = [\n        {\n            \"id\": 1,\n            \"f\": lambda t, y: -1000.0 * y,\n            \"jac\": lambda t, y: np.array([[-1000.0]]),\n            \"y0\": np.array([1.0]),\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.1,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 2,\n            \"f\": (lambda mu: lambda t, y: np.array([y[1], mu * (1 - y[0]**2) * y[1] - y[0]]))(100.0),\n            \"jac\": (lambda mu: lambda t, y: np.array([[0, 1.0], [-2*mu*y[0]*y[1] - 1.0, mu*(1-y[0]**2)]]))(100.0),\n            \"y0\": np.array([2.0, 0.0]),\n            \"t0\": 0.0,\n            \"T\": 0.3,\n            \"h\": 0.001,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 3,\n            \"f\": lambda t, y: np.array([\n                -0.04 * y[0] + 1e4 * y[1] * y[2],\n                0.04 * y[0] - 1e4 * y[1] * y[2] - 3e7 * y[1]**2,\n                3e7 * y[1]**2\n            ]),\n            \"jac\": lambda t, y: np.array([\n                [-0.04, 1e4 * y[2], 1e4 * y[1]],\n                [0.04, -1e4 * y[2] - 6e7 * y[1], -1e4 * y[1]],\n                [0.0, 6e7 * y[1], 0.0]\n            ]),\n            \"y0\": np.array([1.0, 0.0, 0.0]),\n            \"t0\": 0.0,\n            \"T\": 1e-4,\n            \"h\": 1e-6,\n            \"report_idx\": 2,\n        },\n        {\n            \"id\": 4,\n            \"f\": lambda t, y: 0.0 * y,\n            \"jac\": lambda t, y: np.array([[0.0]]),\n            \"y0\": np.array([-5.5]),\n            \"t0\": 0.0,\n            \"T\": 3.7,\n            \"h\": 0.37,\n            \"report_idx\": 0,\n        },\n        {\n            \"id\": 5,\n            \"f\": (lambda A: lambda t, y: A @ y)(np.array([[-50.0, 49.0], [0.0, -1.0]])),\n            \"jac\": (lambda A: lambda t, y: A)(np.array([[-50.0, 49.0], [0.0, -1.0]])),\n            \"y0\": np.array([1.0, 1.0]),\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.05,\n            \"report_idx\": 0,\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        y_final = sdirk_solver(case[\"f\"], case[\"jac\"], case[\"y0\"], case[\"t0\"], case[\"T\"], case[\"h\"])\n        results.append(y_final[case[\"report_idx\"]])\n\n    # Format output as specified: list of strings rounded to 10 decimal places.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2402149"}, {"introduction": "在实现了通用求解器之后，本练习旨在通过比较两种不同的二阶隐式方法来加深理解。通过分析它们在刚性线性系统上的表现 [@problem_id:2402175]，我们可以探索方法的布彻表 (Butcher tableau) 与其数值行为之间的联系，并引入一种处理线性系统的优雅数学形式。", "problem": "您需要实现并比较两种代数阶数相同的不同隐式龙格-库塔方法，并将其应用于一个刚性线性系统。此比较必须是定量的，使用数学上定义的误差度量，并且最终程序必须按照要求的输出格式为指定的测试套件生成结果。\n\n基本问题是针对自治、线性、刚性常微分方程系统的初值问题 (IVP)，定义如下\n$$\n\\frac{d\\mathbf{y}}{dt} = \\mathbf{J}\\,\\mathbf{y}, \\quad \\mathbf{y}(0)=\\mathbf{y}_0,\n$$\n其中 $\\mathbf{y}(t)\\in\\mathbb{R}^n$，$\\mathbf{J}\\in\\mathbb{R}^{n\\times n}$ 是常数矩阵，其精确解为\n$$\n\\mathbf{y}(t) = \\exp(t\\,\\mathbf{J})\\,\\mathbf{y}_0.\n$$\n对于待求解的具体问题，设 $n=2$，$\\mathbf{y}_0 = [1,\\,1]^\\top$，并且\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n-1000  999\\\\\n0      -999\n\\end{bmatrix}.\n$$\n对于此系统，精确解的分量为\n$$\ny_2(t) = e^{-999 t}, \\qquad\ny_1(t) = 999\\,e^{-999 t} - 998\\,e^{-1000 t}.\n$$\n\n您必须以其通用形式实现一个单步隐式龙格-库塔时间积分器。给定步长 $h>0$ 和具有 $s$ 个级的布彻 (Butcher) 系数 $(\\mathbf{A},\\mathbf{b},\\mathbf{c})$，内部的级值 $\\mathbf{Y}_i \\in \\mathbb{R}^n$ 满足\n$$\n\\mathbf{Y}_i = \\mathbf{y}_n + h \\sum_{j=1}^{s} a_{ij}\\, f(\\mathbf{Y}_j), \\quad i=1,\\dots,s,\n$$\n并且步长更新公式为\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, f(\\mathbf{Y}_i),\n$$\n对于本问题，其中 $f(\\mathbf{y})=\\mathbf{J}\\mathbf{y}$。对于线性自治系统，这可以写成矩阵形式的块线性系统\n$$\n\\left(\\mathbf{I}_{sn} - h\\,\\mathbf{A}\\otimes \\mathbf{J}\\right)\\, \\mathbf{Y} = \\mathbf{1}_s \\otimes \\mathbf{y}_n,\n$$\n其中 $\\mathbf{Y}\\in\\mathbb{R}^{sn}$ 是堆叠的级向量，$\\mathbf{I}_{sn}$ 是大小为 $sn \\times sn$ 的单位矩阵，$\\otimes$ 表示克罗内克积 (Kronecker product)，$\\mathbf{1}_s$ 是全为 1 的 $s$ 维向量。求解出 $\\mathbf{Y}$ 后，更新公式为\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, \\mathbf{J}\\mathbf{Y}_i.\n$$\n\n实现并比较以下两种代数阶数均为 2 的隐式龙格-库塔方法：\n- 隐式中点法（在 $c_1=\\tfrac{1}{2}$ 处的一级高斯-勒让德 (Gauss–Legendre) 配置法），其布彻表系数为\n$$\n\\mathbf{A} = \\begin{bmatrix} \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix} 1 \\end{bmatrix}, \\quad\n\\mathbf{c} = \\begin{bmatrix} \\tfrac{1}{2} \\end{bmatrix}.\n$$\n\n- 梯形法则（在 $c_1=0$, $c_2=1$ 处的两级洛巴托 IIIA (Lobatto IIIA) 配置法），其布彻表系数为\n$$\n\\mathbf{A} = \\begin{bmatrix} 0   0 \\\\ \\tfrac{1}{2}   \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{b} = \\begin{bmatrix} \\tfrac{1}{2} \\\\ \\tfrac{1}{2} \\end{bmatrix}, \\quad\n\\mathbf{c} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}.\n$$\n\n使用在最终时刻的全局误差的无穷范数，定义为\n$$\n\\|\\mathbf{e}\\|_{\\infty} = \\max\\left( |e_1|, |e_2| \\right), \\quad \\mathbf{e} = \\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{exact}}(T),\n$$\n其中 $\\mathbf{y}_{\\text{num}}(T)$ 是以步长 $h$ 进行 $N$ 步（其中 $N = T/h$）后的数值解，$\\mathbf{y}_{\\text{exact}}(T)$ 是如上所述的精确解。\n\n测试套件和要求输出：\n- 对所有测试，令最终时间为 $T=1$。对于每个指定的步长 $h$，从相同的初始条件开始，分别使用每种方法执行 $N=T/h$ 个均匀步长，并计算每种方法在 $t=T$ 时的误差的无穷范数。\n- 对于每个测试用例，计算比率\n$$\nr(h) = \\frac{\\|\\mathbf{e}\\|_{\\infty}^{\\text{midpoint}}}{\\|\\mathbf{e}\\|_{\\infty}^{\\text{trapezoidal}}}.\n$$\n\n使用以下三个测试用例，它们分别涵盖了大步长、典型中等步长和精细步长的情况：\n- 测试 1：$h = 1$。\n- 测试 2：$h = 0.1$。\n- 测试 3：$h = 0.01$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列的三个比率，格式为方括号内以逗号分隔的列表（例如，`[r1,r2,r3]`）。不应打印任何其他文本。所有值均为无量纲；不涉及角度或百分比。", "solution": "所提出的问题已经过验证，被认为是科学上合理、适定且客观的。它构成了刚性常微分方程数值分析领域的一个标准练习。所有必要的数据和定义都已提供，不存在矛盾或含糊之处。因此，我将继续提供一个完整的解决方案。\n\n该问题要求在刚性线性初值问题 (IVP) 上实现并比较两种不同的二阶隐式龙格-库塔 (IRK) 方法。解决方案的核心是基于所提供的针对线性自治系统的矩阵公式，构建一个通用的时间步进函数，然后使用每种方法特有的布彻表系数来应用它。\n\n控制性 IVP 由 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{J}\\,\\mathbf{y}$ 给出，其中 $\\mathbf{y}(t) \\in \\mathbb{R}^2$，$\\mathbf{y}(0) = [1, 1]^\\top$，常数雅可比矩阵为\n$$\n\\mathbf{J} =\n\\begin{bmatrix}\n-1000  999\\\\\n0      -999\n\\end{bmatrix}.\n$$\n在时间 $t$ 的精确解为 $\\mathbf{y}_{\\text{exact}}(t) = \\exp(t\\mathbf{J})\\mathbf{y}_0$。\n\n一个通用的 $s$ 级 IRK 方法在时间步长 $h$ 内从 $\\mathbf{y}_n$ 到 $\\mathbf{y}_{n+1}$ 的单步是由内部级 $\\mathbf{Y}_i$ 和更新规则定义的。对于线性系统 $f(\\mathbf{y}) = \\mathbf{J}\\mathbf{y}$，各级的方程可以合并为一个单一的块线性系统：\n$$\n\\left(\\mathbf{I}_{sn} - h\\,\\mathbf{A}\\otimes \\mathbf{J}\\right)\\, \\mathbf{Y} = \\mathbf{1}_s \\otimes \\mathbf{y}_n.\n$$\n这里，$s$ 是级的数量，$n=2$ 是 ODE 系统的维数，$\\mathbf{A}$ 是来自布彻表的 $s \\times s$ 矩阵，$\\otimes$ 表示克罗内克积，$\\mathbf{I}_{sn}$ 是大小为 $sn$ 的单位矩阵，$\\mathbf{1}_s$ 是 $s$ 维全一向量，$\\mathbf{Y} \\in \\mathbb{R}^{sn}$ 是所有级解的展开向量，$\\mathbf{Y} = [\\mathbf{Y}_1^\\top, \\dots, \\mathbf{Y}_s^\\top]^\\top$。\n\n该算法的基石是在每个时间步求解这个 $sn \\times sn$ 的线性系统以得到 $\\mathbf{Y}$。一旦找到 $\\mathbf{Y}$，解就使用更新公式推进到下一个时间层级：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, f(\\mathbf{Y}_i) = \\mathbf{y}_n + h \\sum_{i=1}^{s} b_i\\, \\mathbf{J}\\mathbf{Y}_i,\n$$\n其中系数 $b_i$ 是来自布彻表的权重。这为任何 IRK 方法提供了一个统一的算法框架。\n\n需要比较的两种方法是：\n1.  **隐式中点法**：一种 $s=1$ 级的高斯-勒让德方法，其系数为 $\\mathbf{A} = [\\frac{1}{2}]$, $\\mathbf{b} = [1]$。其级的线性系统大小为 $1 \\cdot 2 = 2$。\n2.  **梯形法则**：一种 $s=2$ 级的洛巴托 IIIA 方法，其系数为 $\\mathbf{A} = \\begin{bmatrix} 0   0 \\\\ \\frac{1}{2}   \\frac{1}{2} \\end{bmatrix}$, $\\mathbf{b} = [\\frac{1}{2}, \\frac{1}{2}]^\\top$。其级的线性系统大小为 $2 \\cdot 2 = 4$。\n\n对于形如 $\\dot{\\mathbf{y}} = \\mathbf{J}\\mathbf{y}$ 的线性问题，一步之后的数值解可以表示为 $\\mathbf{y}_{n+1} = R(h\\mathbf{J})\\mathbf{y}_n$，其中 $R(z)$ 是方法的稳定性函数。对于隐式中点法和梯形法则，其稳定性函数都是指数函数的 $(1,1)$-帕德 (Padé) 近似，即 $R(z) = (1 + z/2)/(1 - z/2)$。因此，对于任何线性问题，这两种方法理论上会产生完全相同的解序列 $\\{\\mathbf{y}_n\\}$。然而，它们在通用框架和各自不同的布彻表指导下的计算实现，会涉及不同的中间步骤和矩阵大小。因此，所要求的比较将揭示这些不同计算路径中由浮点运算引起的任何差异。\n\n实现过程如下：\n首先，创建一个通用函数 `irk_step(yn, h, J, A, b)`。该函数为各级 $\\mathbf{Y}$ 构建并求解线性系统，然后计算更新值 $\\mathbf{y}_{n+1}$，完全遵循数学规范。\n\n其次，一个模拟函数 `run_simulation(h, A, b)` 会重复调用 `irk_step` 函数 $N=T/h$ 次，以将解从 $t=0$ 积分到 $t=T=1$。\n\n第三，对于由步长 $h \\in \\{1, 0.1, 0.01\\}$ 定义的每个测试用例，两种方法都将进行模拟。使用提供的解析公式计算精确解 $\\mathbf{y}_{\\text{exact}}(T)$。计算每种方法的全局误差 $\\mathbf{e} = \\mathbf{y}_{\\text{num}}(T) - \\mathbf{y}_{\\text{exact}}(T)$，并确定其无穷范数 $\\|\\mathbf{e}\\|_\\infty$。\n\n最后，对每个 $h$ 计算误差范数的比率 $r(h) = \\|\\mathbf{e}\\|_{\\infty}^{\\text{midpoint}} / \\|\\mathbf{e}\\|_{\\infty}^{\\text{trapezoidal}}$。这些比率的集合构成了最终结果。鉴于这两种方法对于此问题在理论上是等价的，预计该比率将非常接近 1。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and compares implicit midpoint and trapezoidal Runge-Kutta methods\n    on a stiff linear system, as specified in the problem statement.\n    \"\"\"\n\n    # Define problem parameters\n    J = np.array([[-1000.0, 999.0], [0.0, -999.0]])\n    Y0 = np.array([1.0, 1.0])\n    T_FINAL = 1.0\n\n    def y_exact(t: float) -> np.ndarray:\n        \"\"\"\n        Computes the exact solution of the IVP at a given time t.\n\n        Args:\n            t: The time at which to evaluate the solution.\n\n        Returns:\n            The solution vector y(t).\n        \"\"\"\n        if t  0:\n            raise ValueError(\"Time must be non-negative.\")\n        \n        # For large negative exponents, np.exp underflows to 0.0, which is correct.\n        exp_m999t = np.exp(-999.0 * t)\n        exp_m1000t = np.exp(-1000.0 * t)\n        \n        y2 = exp_m999t\n        y1 = 999.0 * exp_m999t - 998.0 * exp_m1000t\n        \n        return np.array([y1, y2])\n\n    def irk_step(yn: np.ndarray, h: float, J_matrix: np.ndarray, A: np.ndarray, b: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Performs a single step of a generic implicit Runge-Kutta method for a\n        linear system dy/dt = J*y.\n\n        Args:\n            yn: Solution vector at the beginning of the step.\n            h: Step size.\n            J_matrix: The constant Jacobian matrix of the linear system.\n            A: The 'A' matrix from the Butcher tableau.\n            b: The 'b' vector from the Butcher tableau.\n\n        Returns:\n            The solution vector at the end of the step.\n        \"\"\"\n        s = A.shape[0]\n        n = J_matrix.shape[0]\n\n        # Form the linear system for the stages Y:\n        # (I_sn - h * A kron J) * Y_stacked = 1_s kron yn\n        M = np.eye(s * n) - h * np.kron(A, J_matrix)\n        rhs = np.kron(np.ones((s, 1)), yn.reshape(-1, 1))\n\n        # Solve for the stacked stage vector Y_stacked\n        Y_stacked = np.linalg.solve(M, rhs)\n\n        # Reshape Y_stacked into s stage vectors of size n\n        Y_stages = Y_stacked.reshape(s, n)\n\n        # Compute the update using the formula:\n        # y_{n+1} = y_n + h * sum(b_i * J * Y_i)\n        update_sum = np.zeros(n)\n        for i in range(s):\n            update_sum += b[i] * np.dot(J_matrix, Y_stages[i])\n\n        yn_plus_1 = yn + h * update_sum\n        return yn_plus_1\n\n    def run_simulation(h: float, A: np.ndarray, b: np.ndarray) -> np.ndarray:\n        \"\"\"\n        Runs the full simulation from t=0 to T_FINAL with a given step size h\n        and a specific IRK method.\n\n        Args:\n            h: The step size.\n            A: The Butcher 'A' matrix for the method.\n            b: The Butcher 'b' vector for the method.\n\n        Returns:\n            The numerical solution at T_FINAL.\n        \"\"\"\n        # The problem implies T/h is an integer number of steps.\n        # Use round to handle potential floating-point inaccuracies in division.\n        num_steps = int(round(T_FINAL / h))\n        \n        y = Y0.copy()\n        for _ in range(num_steps):\n            y = irk_step(y, h, J, A, b)\n        \n        return y\n\n    # Define Butcher tableaus for the two methods\n    # Method 1: Implicit Midpoint (s=1, order 2)\n    A_midpoint = np.array([[0.5]])\n    b_midpoint = np.array([1.0])\n\n    # Method 2: Trapezoidal Rule (s=2, order 2)\n    A_trap = np.array([[0.0, 0.0], [0.5, 0.5]])\n    b_trap = np.array([0.5, 0.5])\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        1.0,    # Test 1\n        0.1,    # Test 2\n        0.01,   # Test 3\n    ]\n\n    results = []\n    \n    # Calculate exact solution at final time\n    y_exact_final = y_exact(T_FINAL)\n\n    for h in test_cases:\n        # Run simulation for both methods\n        y_num_midpoint = run_simulation(h, A_midpoint, b_midpoint)\n        y_num_trap = run_simulation(h, A_trap, b_trap)\n\n        # Calculate the infinity norm of the global error for each method\n        error_midpoint = np.max(np.abs(y_num_midpoint - y_exact_final))\n        error_trap = np.max(np.abs(y_num_trap - y_exact_final))\n\n        # Compute the ratio of the errors\n        if error_trap == 0.0:\n            # This case occurs if the trapezoidal method is numerically exact.\n            # If midpoint error is also zero, ratio is 1. Otherwise, it's infinite.\n            ratio = 1.0 if error_midpoint == 0.0 else np.inf\n        else:\n            ratio = error_midpoint / error_trap\n            \n        results.append(ratio)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2402175"}]}