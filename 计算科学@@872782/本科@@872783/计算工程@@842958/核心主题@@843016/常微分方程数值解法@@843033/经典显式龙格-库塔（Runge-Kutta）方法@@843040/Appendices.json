{"hands_on_practices": [{"introduction": "理论是指导，但实践出真知。一个数值方法的“阶”($p$)决定了当步长$h$缩小时，其全局误差$E$减小的速度（即 $E \\approx C h^p$），这是衡量其性能的核心指标。本练习将指导你通过“人造解”方法编写一个程序，以实验方式验证几种常见龙格-库塔方法的理论收敛阶。这个实践不仅能让你熟悉如何实现和测试数值求解器，还将加深你对收敛阶这一基本概念的理解。[@problem_id:2376768]", "problem": "编写一个完整的程序，给定几种以 Butcher 表格形式表示的显式 Runge–Kutta (RK) 方法，通过在一个常微分方程 (ODE) 初值问题的构造解上进行测试，来数值验证每种方法的精度阶。构造解定义如下：设对于 $t \\in [0,1]$，精确解为 $y(t)=\\exp(\\sin t)$，其中角度以弧度为单位。该 ODE 为 $y'(t)=f(t,y(t))$，其中 $f(t,y)=\\cos(t)\\,y$，初始条件为 $y(0)=1$，终止时间为 $T=1$。使用终止时间 $t=T$ 时的全局误差来量化精度。\n\n使用以下显式 Runge–Kutta 方法，每种方法均由其 Butcher 表格 $(A,b,c)$ 指定：\n- 方法 $1$ (显式 Euler，期望阶数 $1$): $s=1$, $A=\\begin{bmatrix}0\\end{bmatrix}$, $b=\\begin{bmatrix}1\\end{bmatrix}$, $c=\\begin{bmatrix}0\\end{bmatrix}$。\n- 方法 $2$ (显式中点法，期望阶数 $2$): $s=2$, $A=\\begin{bmatrix}0  0\\\\ \\tfrac{1}{2}  0\\end{bmatrix}$, $b=\\begin{bmatrix}0  1\\end{bmatrix}$, $c=\\begin{bmatrix}0  \\tfrac{1}{2}\\end{bmatrix}$。\n- 方法 $3$ (Kutta 三阶方法，期望阶数 $3$): $s=3$, $A=\\begin{bmatrix}0  0  0\\\\ \\tfrac{1}{2}  0  0\\\\ -1  2  0\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{6}  \\tfrac{2}{3}  \\tfrac{1}{6}\\end{bmatrix}$, $c=\\begin{bmatrix}0  \\tfrac{1}{2}  1\\end{bmatrix}$。\n- 方法 $4$ (经典 RK4，期望阶数 $4$): $s=4$, $A=\\begin{bmatrix}0  0  0  0\\\\ \\tfrac{1}{2}  0  0  0\\\\ 0  \\tfrac{1}{2}  0  0\\\\ 0  0  1  0\\end{bmatrix}$, $b=\\begin{bmatrix}\\tfrac{1}{6}  \\tfrac{1}{3}  \\tfrac{1}{3}  \\tfrac{1}{6}\\end{bmatrix}$, $c=\\begin{bmatrix}0  \\tfrac{1}{2}  \\tfrac{1}{2}  1\\end{bmatrix}$。\n\n对于每种方法，在 $[0,1]$ 上执行时间积分，使用大小为 $h=1/N$ 的均匀时间步长，其中 $N$ 取自测试集 $\\{10,20,40,80,160,320\\}$。对于每个 $N$，计算在 $t=1$ 时的数值近似解 $y_N$，计算全局误差 $E(h)=\\lvert y_N - y(1)\\rvert$，然后通过对测试集中所有 $N$ 值得到的数据点 $(\\log h,\\log E(h))$ 进行线性拟合，将所得直线的最小二乘斜率作为观测阶数 $p$ 的估计值。使用自然对数计算 $\\log$。\n\n您的程序必须在单行中输出一个用方括号括起来的逗号分隔列表，其中包含分别对应方法 1 到 4 的四个估计阶数 $(p_1,p_2,p_3,p_4)$，每个阶数均四舍五入到两位小数。不应打印任何其他文本。\n\n测试集与答案规范：\n- 测试集包含上述四种方法，每种方法均使用 $N \\in \\{10,20,40,80,160,320\\}$ 进行测试。\n- 最终答案是四个浮点数 $p_1, p_2, p_3, p_4$，分别是相应方法的观测阶数估计值。\n- 最终输出格式必须严格为 $\\texttt{[p1,p2,p3,p4]}$ 的单行形式，其中每个 $p_k$ 都四舍五入到两位小数，并以十进制数形式打印。", "solution": "对问题陈述进行了严谨的分析。该问题具有科学依据，是适定的，并包含得出唯一且有意义解所需的所有必要信息。所指定的常微分方程、其构造的解析解、通过 Butcher 表格定义的 Runge-Kutta 方法，以及用于数值验证精度阶的程序，都是标准的、正确的且自洽的。该问题是有效的。我们现在将构建解决方案。\n\n基本任务是求解一个形式如下的初值问题 (IVP)：\n$$ y'(t) = f(t, y(t)), \\quad y(t_0) = y_0 $$\n适用于 $t \\in [t_0, T]$。问题提供了具体的函数 $f(t, y) = \\cos(t) y$、初始条件 $y(0) = 1$ 以及时间区间 $[0, 1]$。精确解被给出为 $y(t) = \\exp(\\sin t)$，这可以通过微分轻松验证：$y'(t) = \\exp(\\sin t) \\cdot \\cos(t) = y(t)\\cos(t)$，以及通过检查初始条件验证：$y(0) = \\exp(\\sin 0) = \\exp(0) = 1$。\n\n一个 $s$ 阶显式 Runge-Kutta (RK) 方法通过以步长 $h$ 向前推进时间来近似求解。从时刻 $t_n$ 的解 $y_n$ 出发，计算出时刻 $t_{n+1} = t_n + h$ 的解 $y_{n+1}$。该方法由一组排列在 Butcher 表格中的系数定义：\n$$\n\\begin{array}{c|c}\nc  A \\\\\n\\hline\n   b^T\n\\end{array} \\quad \\text{其中 } c \\in \\mathbb{R}^s, b \\in \\mathbb{R}^s, A \\in \\mathbb{R}^{s \\times s}\n$$\n对于显式方法，矩阵 $A$ 是严格下三角矩阵，即对于 $j \\ge i$ 有 $a_{ij} = 0$。计算分阶段进行。首先，计算 $s$ 个阶段导数 $k_i$（对于 $i=1, 2, \\dots, s$）：\n$$ k_i = f\\left(t_n + c_i h, y_n + h \\sum_{j=1}^{i-1} a_{ij} k_j\\right) $$\n然后使用这些阶段导数的加权平均值来推进解：\n$$ y_{n+1} = y_n + h \\sum_{i=1}^{s} b_i k_i $$\n\n一个数值方法的精度由其收敛阶 $p$ 来表征。对于一个 $p$ 阶方法，在固定的终止时间 $T$ 时的全局误差（记为 $E(h)$）预期会随着步长 $h$ 的减小而按以下关系式减小：\n$$ E(h) = |y_N - y(T)| \\approx C h^p $$\n其中 $y_N$ 是在 $T=Nh$ 时的数值解，$C$ 是一个取决于方法和问题但与 $h$ 无关的常数。\n\n为了数值验证阶数 $p$，我们可以通过对两边取自然对数来变换这个关系式：\n$$ \\ln(E(h)) \\approx \\ln(C) + p \\ln(h) $$\n该方程形式为 $Y = mX + B$，其中 $Y = \\ln(E(h))$, $X = \\ln(h)$，斜率为 $m = p$，截距为 $B = \\ln(C)$。这种线性关系意味着 $\\ln(E(h))$ 相对于 $\\ln(h)$ 的图将近似于一条直线，其斜率即为该方法的阶数 $p$。\n\n指定的步骤如下：\n$1$. 对给定的四种 RK 方法中的每一种，必须在区间 $[0, 1]$ 上执行一系列数值积分。\n$2$. 积分将使用一系列递减的步长 $h = 1/N$，其中 $N \\in \\{10, 20, 40, 80, 160, 320\\}$。\n$3$. 对于每次使用特定步长 $h$ 的积分，计算在终止时间时的数值近似解 $y_N$。\n$4$. 全局误差计算为 $E(h) = |y_N - y(1)|$，其中精确值为 $y(1) = \\exp(\\sin 1)$。\n$5$. 在计算完所有步长的误差后，收集数据对 $(\\ln(h), \\ln(E(h)))$。\n$6$. 对这些数据点执行线性最小二乘回归。所得最佳拟合线的斜率提供了精度阶 $p$ 的实验估计值。对于一组数据点 $(x_i, y_i)$，斜率 $p$ 由下式给出：\n$$ p = \\frac{\\sum_{i=1}^{M} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{M} (x_i - \\bar{x})^2} $$\n其中 $x_i = \\ln(h_i)$，$y_i = \\ln(E(h_i))$，$\\bar{x}$ 和 $\\bar{y}$ 是平均值，而 $M=6$ 是测试集中步长的数量。\n\n将对提供的四个 Butcher 表格中的每一个实施此程序，从而得出四个估计的精度阶 $(p_1, p_2, p_3, p_4)$，预期这些值将分别接近其理论值 1、2、3 和 4。最终结果将是这四个值，并四舍五入到两位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Numerically verifies the order of accuracy of several explicit Runge-Kutta methods.\n    \"\"\"\n    # Define the Ordinary Differential Equation and its analytical solution\n    f = lambda t, y: np.cos(t) * y\n    t_start = 0.0\n    y_start = 1.0\n    t_end = 1.0\n    \n    # Pre-calculate the exact solution at the final time for error computation\n    y_exact_final = np.exp(np.sin(t_end))\n\n    # Define the Butcher tableaus for the four RK methods\n    methods = [\n        {\n            # Method 1: Explicit Euler (Order 1)\n            'A': np.array([[0.0]]),\n            'b': np.array([1.0]),\n            'c': np.array([0.0])\n        },\n        {\n            # Method 2: Explicit Midpoint (Order 2)\n            'A': np.array([[0.0, 0.0], [0.5, 0.0]]),\n            'b': np.array([0.0, 1.0]),\n            'c': np.array([0.0, 0.5])\n        },\n        {\n            # Method 3: Kutta's third-order method (Order 3)\n            'A': np.array([[0.0, 0.0, 0.0], [0.5, 0.0, 0.0], [-1.0, 2.0, 0.0]]),\n            'b': np.array([1.0/6.0, 2.0/3.0, 1.0/6.0]),\n            'c': np.array([0.0, 0.5, 1.0])\n        },\n        {\n            # Method 4: Classical RK4 (Order 4)\n            'A': np.array([\n                [0.0, 0.0, 0.0, 0.0],\n                [0.5, 0.0, 0.0, 0.0],\n                [0.0, 0.5, 0.0, 0.0],\n                [0.0, 0.0, 1.0, 0.0]\n            ]),\n            'b': np.array([1.0/6.0, 1.0/3.0, 1.0/3.0, 1.0/6.0]),\n            'c': np.array([0.0, 0.5, 0.5, 1.0])\n        }\n    ]\n\n    # Test suite of step counts\n    N_values = [10, 20, 40, 80, 160, 320]\n    h_values = np.array([1.0 / N for N in N_values])\n\n    estimated_orders = []\n\n    for method in methods:\n        A, b, c = method['A'], method['b'], method['c']\n        s = len(b)  # Number of stages\n        errors = []\n\n        for N in N_values:\n            h = (t_end - t_start) / N\n            y_current = y_start\n            \n            # Time integration loop\n            for n in range(N):\n                t_n = t_start + n * h\n                k_stages = np.zeros(s)\n                \n                # Calculate stage derivatives k_i\n                for i in range(s):\n                    stage_sum = 0.0\n                    for j in range(i):\n                        stage_sum += A[i, j] * k_stages[j]\n                    \n                    y_stage_input = y_current + h * stage_sum\n                    t_stage_input = t_n + c[i] * h\n                    k_stages[i] = f(t_stage_input, y_stage_input)\n                \n                # Update solution\n                y_current += h * np.dot(b, k_stages)\n            \n            # Store the global error at t=T\n            errors.append(np.abs(y_current - y_exact_final))\n\n        # Use natural logarithm for the log-log plot\n        log_h = np.log(h_values)\n        log_E = np.log(np.array(errors))\n        \n        # Perform linear regression (polynomial fit of degree 1)\n        # The slope of the line is the estimated order of accuracy\n        # np.polyfit returns [slope, intercept]\n        slope = np.polyfit(log_h, log_E, 1)[0]\n        estimated_orders.append(slope)\n        \n    # Format the output as specified: [p1,p2,p3,p4]\n    formatted_results = [f'{p:.2f}' for p in estimated_orders]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2376768"}, {"introduction": "我们通常认为，越高阶的数值方法性能越好。然而，这个直觉并非总是正确，因为收敛阶描述的是当步长$h \\to 0$时的渐进行为。本练习将通过一个精心设计的场景来挑战这一假设。通过直接的笔算，你将发现一个四阶方法的误差在特定条件下竟会大于二阶方法，从而揭示出在选择数值方法时，收敛阶与数值稳定性之间至关重要的权衡关系，尤其是在步长较大时。[@problem_id:2376761]", "problem": "在计算工程实践中，由于稳定性函数的行为，一个形式上精度阶数更高的方法在给定的步长下表现可能更差。考虑初值问题\n$$\ny'(t)=\\lambda\\,y(t),\\qquad y(0)=1,\n$$\n其中常数系数 $\\lambda=-5$。使用从 $t=0$ 到 $t=h$ 的单个时间步，步长为 $h=1$，分别使用经典的四阶龙格-库塔方法和显式中点两步二阶龙格-库塔方法来近似 $y(h)$。令\n$$\n\\rho=\\frac{\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right|}{\\left|y_{\\mathrm{mid}}(h)-y(h)\\right|}。\n$$\n计算 $\\rho$ 并以纯数字形式给出其值。将答案四舍五入到 $4$ 位有效数字。", "solution": "问题陈述已经过验证，被认为是计算工程和数值分析领域中一个有效、适定的问题。我们开始进行解答。\n\n该初值问题 (IVP) 由以下线性常微分方程给出：\n$$\ny'(t) = \\lambda y(t), \\quad y(0) = 1\n$$\n其中常数系数 $\\lambda = -5$。我们需要使用两种不同的显式龙格-库塔方法计算在 $t=h=1$ 处的近似值，并比较它们的误差。\n\n首先，我们确定该 IVP 的精确解。这是一个标准的一阶线性齐次微分方程，其解的形式为 $y(t) = C \\exp(\\lambda t)$。使用初始条件 $y(0)=1$，我们得到 $1 = C \\exp(\\lambda \\cdot 0)$，这意味着 $C=1$。因此，精确解为：\n$$\ny(t) = \\exp(\\lambda t)\n$$\n在时间 $t=h=1$ 且 $\\lambda = -5$ 时，精确值为：\n$$\ny(h) = \\exp(-5 \\cdot 1) = \\exp(-5)\n$$\n\n接下来，我们分析将显式龙格-库塔 (RK) 方法应用于此测试问题的情况。对于形式为 $y' = f(t,y)$ 的常微分方程，显式 RK 方法的单步计算形式为 $y_{n+1} = y_n + h \\Phi(t_n, y_n, h)$。当应用于 $y' = \\lambda y$（其中 $f(t,y) = \\lambda y$ 与 $t$ 无关）时，公式得以简化。下一步 $y_1$ 通过一个稳定性函数 $R(z)$ 与上一步 $y_0$ 相关联，该函数是关于 $z=h\\lambda$ 的多项式：\n$$\ny_1 = R(h\\lambda) y_0\n$$\n在我们的问题中，$y_0 = y(0) = 1$ 且 $z = h\\lambda = 1 \\cdot (-5) = -5$。因此，在 $t=h$ 处的近似值就是该方法的稳定性函数在 $z=-5$ 处的取值。\n\n我们来计算使用经典的四阶龙格-库塔 (RK4) 方法得到的近似值。RK4 方法的稳定性函数是指数函数在 4 次的泰勒多项式：\n$$\nR_{\\mathrm{RK4}}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}\n$$\n我们计算其在 $z=-5$ 处的值：\n$$\ny_{\\mathrm{RK4}}(h) = R_{\\mathrm{RK4}}(-5) = 1 + (-5) + \\frac{(-5)^2}{2} + \\frac{(-5)^3}{6} + \\frac{(-5)^4}{24}\n$$\n$$\ny_{\\mathrm{RK4}}(h) = 1 - 5 + \\frac{25}{2} - \\frac{125}{6} + \\frac{625}{24}\n$$\n为了对这些分数求和，我们使用公分母 $24$：\n$$\ny_{\\mathrm{RK4}}(h) = \\frac{24}{24} - \\frac{120}{24} + \\frac{300}{24} - \\frac{500}{24} + \\frac{625}{24} = \\frac{24 - 120 + 300 - 500 + 625}{24} = \\frac{329}{24}\n$$\n\n现在，我们计算使用显式两步二阶中点法得到的近似值。该方法的稳定性函数是指数函数在 2 次的泰勒多项式：\n$$\nR_{\\mathrm{mid}}(z) = 1 + z + \\frac{z^2}{2!}\n$$\n我们计算其在 $z=-5$ 处的值：\n$$\ny_{\\mathrm{mid}}(h) = R_{\\mathrm{mid}}(-5) = 1 + (-5) + \\frac{(-5)^2}{2} = 1 - 5 + \\frac{25}{2} = -4 + 12.5 = 8.5 = \\frac{17}{2}\n$$\n\n问题要求计算绝对误差的比值 $\\rho$：\n$$\n\\rho = \\frac{\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right|}{\\left|y_{\\mathrm{mid}}(h)-y(h)\\right|}\n$$\n代入计算出的值：\n$$\n\\rho = \\frac{\\left|\\frac{329}{24} - \\exp(-5)\\right|}{\\left|\\frac{17}{2} - \\exp(-5)\\right|}\n$$\n为了计算最终的数值，我们使用以下近似值：\n$\\exp(-5) \\approx 0.006737947$\n$\\frac{329}{24} \\approx 13.7083333$\n$\\frac{17}{2} = 8.5$\n\n分子是 RK4 方法的绝对误差：\n$$\n\\left|y_{\\mathrm{RK4}}(h)-y(h)\\right| = |13.7083333... - 0.0067379...| \\approx 13.7015954\n$$\n分母是中点法的绝对误差：\n$$\n\\left|y_{\\mathrm{mid}}(h)-y(h)\\right| = |8.5 - 0.0067379...| \\approx 8.4932621\n$$\n因此，比值 $\\rho$ 为：\n$$\n\\rho \\approx \\frac{13.7015954}{8.4932621} \\approx 1.613245\n$$\n这个结果展示了数值分析中的一个关键概念。步长 $h=1$ 导致 $z = h\\lambda = -5$，这个值位于两种方法的绝对稳定区域之外（RK4 的绝对稳定区域约为 $[-2.78, 0]$，中点法的绝对稳定区域约为 $[-2, 0]$）。当 $|R(z)| > 1$ 时，数值解是不稳定的并且会增长，而真实解 $y(t) = \\exp(-5t)$ 是衰减的。在这个不稳定区域，稳定性函数幅值 $|R(z)|$ 更大的方法会产生更大的误差。这里， $|R_{\\mathrm{RK4}}(-5)| = \\frac{329}{24} \\approx 13.71$ 显著大于 $|R_{\\mathrm{mid}}(-5)| = 8.5$。因此，对于这个大步长，四阶方法得到的结果不如二阶方法准确，这一点由 $\\rho > 1$ 所证实。\n\n将 $\\rho$ 的值四舍五入到 $4$ 位有效数字，我们得到 $1.613$。", "answer": "$$\n\\boxed{1.613}\n$$", "id": "2376761"}, {"introduction": "在掌握了收敛阶和稳定性的基本概念后，最后的这个练习将这些知识融会贯通于一个综合性的编程挑战中。你将需要实现从一阶到四阶的多种龙格-库塔方法，并用它们求解一个非线性常微分方程。通过在不同条件下分析计算结果的准确性、单调性和稳定性，你将获得关于方法阶数和步长如何共同影响数值解性能的宝贵实践经验。[@problem_id:2376808]", "problem": "考虑由常微分方程 $y'(t)=-y(t)^3$ 定义的初值问题，初始条件为 $y(0)=1$。其唯一精确解为 $y(t)=\\dfrac{1}{\\sqrt{1+2t}}$。令 $f(t,y)=-y^3$。\n\n定义四种经典的显式龙格-库塔方法，使用均匀时间步长 $h>0$ 将近似值 $y_n \\approx y(t_n)$ 推进到 $y_{n+1} \\approx y(t_{n+1})$：\n- $RK1$：前向欧拉法 (一阶)。\n- $RK2$：显式中点法 (二阶)。\n- $RK3$：库塔三阶法 (三阶)。\n- $RK4$：经典四阶法 (四阶)。\n\n对于下面指定的每个测试用例，从 $t_0=0$, $y_0=1$ 开始，使用均匀步长 $h$ 经过 $N=T/h$ 步 (假设 $T/h$ 为整数) 到达最终时间 $T$。对于每个测试用例，计算以下四个量：\n1. 最终时间的绝对误差 $E=\\lvert y_N - y(T)\\rvert$，其中 $y(T)=1/\\sqrt{1+2T}$。报告 $E$，四舍五入到10位小数。\n2. 一个布尔值，指示序列 $\\{y_n\\}_{n=0}^N$ 是否单调非增，即对于所有 $n$，满足 $y_{n+1}\\le y_n+\\varepsilon$，其中 $\\varepsilon=10^{-12}$。\n3. 一个布尔值，指示所有迭代值是否在容差范围内非负，即对于所有 $n$，满足 $y_n\\ge -\\varepsilon$，其中 $\\varepsilon=10^{-12}$。\n4. 到达 $T$ 所需的时间步数，整数 $N$。\n\n使用以下测试套件，其中每个用例以三元组 $(\\text{方法},T,h)$ 的形式给出，其中 $T$ 的单位是时间， $h$ 的单位是时间：\n- 用例 $1$：$(RK1,\\,T=10,\\,h=1)$。\n- 用例 $2$：$(RK2,\\,T=10,\\,h=1)$。\n- 用例 $3$：$(RK3,\\,T=10,\\,h=1)$。\n- 用例 $4$：$(RK4,\\,T=10,\\,h=1)$。\n- 用例 $5$：$(RK1,\\,T=10,\\,h=2)$。\n- 用例 $6$：$(RK4,\\,T=10,\\,h=0.5)$。\n- 用例 $7$：$(RK1,\\,T=10,\\,h=0.5)$。\n- 用例 $8$：$(RK2,\\,T=100,\\,h=1)$。\n- 用例 $9$：$(RK3,\\,T=100,\\,h=1)$。\n- 用例 $10$：$(RK4,\\,T=100,\\,h=1)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表应按上述顺序为每个测试用例包含一个条目。每个条目本身必须是四个值的列表 $[E,\\,\\text{monotone},\\,\\text{nonnegative},\\,N]$，如上文所定义，其中 $E$ 是一个四舍五入到10位小数的浮点数，$\\text{monotone}$ 和 $\\text{nonnegative}$ 是布尔值，$N$ 是一个整数。例如，整体输出格式必须为\n$$\n\\big[\\,[E_1,\\text{mon}_1,\\text{nonneg}_1,N_1],\\,[E_2,\\text{mon}_2,\\text{nonneg}_2,N_2],\\,\\dots,\\,[E_{10},\\text{mon}_{10},\\text{nonneg}_{10},N_{10}]\\,\\big].\n$$\n不涉及角度或物理单位；所有量均为无量纲。所有浮点输出必须遵守上述四舍五入规范。", "solution": "问题陈述已经过严格审查，并被确定为有效。这是一个适定的、具有科学依据的计算工程领域问题，具体涉及常微分方程的数值求解。所有必要的数据、定义和边界条件均已提供，不存在矛盾或歧义。\n\n任务是求解由以下常微分方程(ODE)定义的初值问题(IVP)：\n$$\ny'(t) = -y(t)^3\n$$\n初始条件为 $y(0)=1$。右侧函数为 $f(t,y) = -y^3$。该方程是一个可分离常微分方程，对于给定的初始条件，其唯一精确解为：\n$$\ny(t) = \\frac{1}{\\sqrt{1+2t}}\n$$\n我们需要使用四种经典的显式龙格-库塔(RK)方法来近似该解。在时间 $t_n$ 的近似值 $y_n$ 通过均匀时间步长 $h > 0$推进到时间 $t_{n+1} = t_n + h$ 的近似值 $y_{n+1}$。每个测试用例的模拟从 $t_0=0$ 和 $y_0=1$ 开始，进行 $N=T/h$ 步到达最终时间 $T$。\n\n四种指定的RK方法如下：\n$1$。**RK1 (前向欧拉法，1阶):**\n$$\ny_{n+1} = y_n + h f(t_n, y_n)\n$$\n\n$2$。**RK2 (显式中点法，2阶):**\n$$\n\\begin{aligned}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\ny_{n+1} = y_n + h k_2\n\\end{aligned}\n$$\n\n$3$。**RK3 (库塔三阶法，3阶):**\n$$\n\\begin{aligned}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\nk_3 = f\\left(t_n + h, y_n - h k_1 + 2h k_2\\right) \\\\\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 4k_2 + k_3)\n\\end{aligned}\n$$\n\n$4$。**RK4 (经典四阶法，4阶):**\n$$\n\\begin{aligned}\nk_1 = f(t_n, y_n) \\\\\nk_2 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_1\\right) \\\\\nk_3 = f\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2} k_2\\right) \\\\\nk_4 = f\\left(t_n + h, y_n + h k_3\\right) \\\\\ny_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4)\n\\end{aligned}\n$$\n\n对于由元组 $(\\text{方法}, T, h)$ 定义的每个测试用例，执行以下算法：\n首先，用 $t_0=0$, $y_0=1$ 初始化模拟。总步数为 $N = T/h$。初始化一个列表以存储近似值序列 $\\{y_n\\}_{n=0}^N$。\n然后，一个循环从 $n=0$ 运行到 $N-1$。在每次迭代中，使用指定RK方法的公式从 $y_n$ 计算出 $y_{n+1}$ 的值。新值 $y_{n+1}$ 被附加到历史列表中。\n\n完成所有 $N$ 步后，计算四个量：\n$1$。最终时间 $T$ 的绝对误差 $E$，计算公式为 $E = \\lvert y_N - y(T) \\rvert$，其中 $y_N$ 是最终的数值近似值，$y(T)$ 是在 $T$ 处求值的精确解。报告该值，四舍五入到10位小数。\n$2$。一个布尔值，指示计算出的序列 $\\{y_n\\}$ 是否单调非增。这通过检查对于所有 $n \\in \\{0, 1, \\dots, N-1\\}$ 是否满足 $y_{n+1} \\le y_n + \\varepsilon$ 来验证，其中 $\\varepsilon = 10^{-12}$ 是一个用于考虑浮点误差的小容差。精确解是严格递减的，因此稳定的数值解应具有此性质。\n$3$。一个布尔值，指示所有迭代值是否为非负。这通过检查对于所有 $n \\in \\{0, 1, \\dots, N\\}$ 是否满足 $y_n \\ge -\\varepsilon$ 来验证。精确解是严格为正的，因此任何负值都是数值假象，通常由不稳定性引起。\n$4$。完成模拟所需的整数时间步数 $N$。\n\n此过程应用于所提供的10个测试用例中的每一个。然后将结果汇总到单个列表的列表中以供最终输出。该实现将使用指定的 Python 环境和库。", "answer": "```python\nimport numpy as np\n\ndef f(t, y):\n    \"\"\"\n    Implements the right-hand side of the ODE y' = -y^3.\n    The parameter t is unused as the ODE is autonomous.\n    \"\"\"\n    return -y**3\n\ndef exact_solution(t):\n    \"\"\"\n    Calculates the exact solution y(t) = 1/sqrt(1 + 2t).\n    \"\"\"\n    return 1.0 / np.sqrt(1.0 + 2.0 * t)\n\ndef step_rk1(y_n, h):\n    \"\"\"Performs one step of the Forward Euler (RK1) method.\"\"\"\n    return y_n + h * f(0, y_n)\n\ndef step_rk2(y_n, h):\n    \"\"\"Performs one step of the explicit midpoint (RK2) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    return y_n + h * k2\n\ndef step_rk3(y_n, h):\n    \"\"\"Performs one step of Kutta's third-order (RK3) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    k3 = f(0, y_n - h * k1 + 2.0 * h * k2)\n    return y_n + (h / 6.0) * (k1 + 4.0 * k2 + k3)\n\ndef step_rk4(y_n, h):\n    \"\"\"Performs one step of the classical fourth-order (RK4) method.\"\"\"\n    k1 = f(0, y_n)\n    k2 = f(0, y_n + h / 2.0 * k1)\n    k3 = f(0, y_n + h / 2.0 * k2)\n    k4 = f(0, y_n + h * k3)\n    return y_n + (h / 6.0) * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n\ndef run_simulation(method, T, h):\n    \"\"\"\n    Runs the simulation for a given method, final time T, and step size h.\n    \"\"\"\n    steppers = {\n        'RK1': step_rk1,\n        'RK2': step_rk2,\n        'RK3': step_rk3,\n        'RK4': step_rk4,\n    }\n    stepper = steppers[method]\n    \n    y0 = 1.0\n    epsilon = 1e-12\n    # The problem statement guarantees T/h is an integer.\n    N = int(T / h)\n\n    y_history = [y0]\n    y_current = y0\n    for _ in range(N):\n        y_current = stepper(y_current, h)\n        y_history.append(y_current)\n    \n    y_N = y_history[-1]\n    y_exact_T = exact_solution(T)\n    \n    # 1. Absolute error at the final time, rounded to 10 decimal places.\n    E = abs(y_N - y_exact_T)\n    E_rounded = round(E, 10)\n    \n    # 2. Monotonically nonincreasing check.\n    is_monotone = all(y_history[i+1] <= y_history[i] + epsilon for i in range(len(y_history) - 1))\n            \n    # 3. Nonnegative check.\n    is_nonnegative = all(y_val >= -epsilon for y_val in y_history)\n            \n    return [E_rounded, is_monotone, is_nonnegative, N]\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    test_cases = [\n        ('RK1', 10.0, 1.0),\n        ('RK2', 10.0, 1.0),\n        ('RK3', 10.0, 1.0),\n        ('RK4', 10.0, 1.0),\n        ('RK1', 10.0, 2.0),\n        ('RK4', 10.0, 0.5),\n        ('RK1', 10.0, 0.5),\n        ('RK2', 100.0, 1.0),\n        ('RK3', 100.0, 1.0),\n        ('RK4', 100.0, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        method, T, h = case\n        result = run_simulation(method, T, h)\n        results.append(result)\n        \n    # Format the final output string as specified.\n    # The str() representation of a list is \"[item1, item2, ...]\"\n    # which matches the required sub-format for each test case result.\n    result_strings = [str(r) for r in results]\n    output_string = f\"[{','.join(result_strings)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2376808"}]}