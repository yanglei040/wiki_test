{"hands_on_practices": [{"introduction": "这项练习是局部截断误差定义的直接应用。通过精确求解一个特定的常微分方程，然后将真实解与前向欧拉法单步计算的结果进行比较，我们可以计算出产生的确切误差。这个练习将局部截断误差的抽象概念置于具体的计算之中，突出了连续解路径与离散数值近似之间的差异。[@problem_id:2185646]", "problem": "考虑由以下一阶常微分方程给出的初值问题 (IVP)：\n$$\ny'(t) = \\alpha y(t) - \\beta t^2\n$$\n其初始条件为 $y(0) = y_0$。在此方程中，$\\alpha$、$\\beta$ 和 $y_0$ 是给定的非零实常数。\n\n该 IVP 将使用步长为 $h$ 的欧拉方法进行数值求解。欧拉方法在第 $(i+1)$ 步的局部截断误差定义为 $\\tau_{i+1} = y(t_{i+1}) - \\left[y(t_i) + h f(t_i, y(t_i))\\right]$，其中 $y(t)$ 表示该 IVP 的精确解。\n\n计算该方法第一步（从 $t_0 = 0$ 到 $t_1 = h$）中出现的局部截断误差 $\\tau_1$ 的精确值。请用一个关于 $\\alpha$、$\\beta$、$y_0$ 和 $h$ 的单一闭式解析表达式来表示你的答案。", "solution": "问题要求计算将欧拉方法应用于初值问题 $y'(t) = \\alpha y(t) - \\beta t^2$（初始条件为 $y(0) = y_0$）时，第一步的精确局部截断误差 $\\tau_1$。\n\n第一步（从 $t_0=0$ 到 $t_1=h$）的局部截断误差定义为：\n$$\n\\tau_1 = y(t_1) - \\left[y(t_0) + h f(t_0, y(t_0))\\right]\n$$\n其中 $y(t)$ 是该常微分方程的精确解。\n\n首先，我们确定此定义中的各项：\n- $t_0 = 0$ 且 $t_1 = h$。\n- $y(t_0) = y(0) = y_0$。\n- $f(t,y) = \\alpha y - \\beta t^2$。因此，$f(t_0, y(t_0)) = f(0, y_0) = \\alpha y_0 - \\beta (0)^2 = \\alpha y_0$。\n\n将这些代入 $\\tau_1$ 的定义中，我们得到：\n$$\n\\tau_1 = y(h) - \\left[y_0 + h(\\alpha y_0)\\right] = y(h) - y_0(1 + \\alpha h)\n$$\n为了求出 $\\tau_1$ 的精确值，我们必须首先求出该常微分方程的精确解 $y(t)$，然后在 $t=h$ 处对其求值。\n\n该常微分方程为 $y'(t) = \\alpha y(t) - \\beta t^2$，这是一个一阶线性常微分方程。我们可以将其改写为标准形式 $y' - \\alpha y = -\\beta t^2$。\n积分因子 $I(t)$ 由下式给出：\n$$\nI(t) = \\exp\\left(\\int -\\alpha \\, dt\\right) = \\exp(-\\alpha t)\n$$\n将常微分方程的标准形式乘以 $I(t)$：\n$$\n\\exp(-\\alpha t)y' - \\alpha \\exp(-\\alpha t)y = -\\beta t^2 \\exp(-\\alpha t)\n$$\n左边是乘积 $I(t)y(t)$ 的导数：\n$$\n\\frac{d}{dt}\\left(y(t) \\exp(-\\alpha t)\\right) = -\\beta t^2 \\exp(-\\alpha t)\n$$\n对两边关于 $t$ 积分：\n$$\ny(t) \\exp(-\\alpha t) = -\\beta \\int t^2 \\exp(-\\alpha t) \\, dt\n$$\n右侧的积分需要进行两次分部积分。设 $J = \\int t^2 \\exp(-\\alpha t) \\, dt$。\n对于第一次分部积分，设 $u = t^2$ 且 $dv = \\exp(-\\alpha t) dt$。则 $du = 2t \\, dt$ 且 $v = -\\frac{1}{\\alpha}\\exp(-\\alpha t)$。\n$$\nJ = t^2 \\left(-\\frac{1}{\\alpha}\\exp(-\\alpha t)\\right) - \\int \\left(-\\frac{1}{\\alpha}\\exp(-\\alpha t)\\right) (2t \\, dt) = -\\frac{t^2}{\\alpha}\\exp(-\\alpha t) + \\frac{2}{\\alpha} \\int t \\exp(-\\alpha t) \\, dt\n$$\n对于剩余的积分 $\\int t \\exp(-\\alpha t) \\, dt$，我们再次使用分部积分。设 $u = t$ 且 $dv = \\exp(-\\alpha t) dt$。则 $du = dt$ 且 $v = -\\frac{1}{\\alpha}\\exp(-\\alpha t)$。\n$$\n\\int t \\exp(-\\alpha t) \\, dt = t\\left(-\\frac{1}{\\alpha}\\exp(-\\alpha t)\\right) - \\int \\left(-\\frac{1}{\\alpha}\\exp(-\\alpha t)\\right) dt = -\\frac{t}{\\alpha}\\exp(-\\alpha t) - \\frac{1}{\\alpha^2}\\exp(-\\alpha t)\n$$\n将此结果代回到 $J$ 的表达式中：\n$$\nJ = -\\frac{t^2}{\\alpha}\\exp(-\\alpha t) + \\frac{2}{\\alpha} \\left(-\\frac{t}{\\alpha}\\exp(-\\alpha t) - \\frac{1}{\\alpha^2}\\exp(-\\alpha t)\\right) = -\\left(\\frac{t^2}{\\alpha} + \\frac{2t}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right)\\exp(-\\alpha t)\n$$\n现在我们可以写出 $y(t) \\exp(-\\alpha t)$ 的解：\n$$\ny(t) \\exp(-\\alpha t) = -\\beta J + C = \\beta\\left(\\frac{t^2}{\\alpha} + \\frac{2t}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right)\\exp(-\\alpha t) + C\n$$\n其中 $C$ 是积分常数。\n乘以 $\\exp(\\alpha t)$ 得到 $y(t)$ 的通解：\n$$\ny(t) = \\beta\\left(\\frac{t^2}{\\alpha} + \\frac{2t}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) + C \\exp(\\alpha t)\n$$\n我们使用初始条件 $y(0) = y_0$ 来求解 $C$：\n$$\ny(0) = y_0 = \\beta\\left(0 + 0 + \\frac{2}{\\alpha^3}\\right) + C \\exp(0) = \\frac{2\\beta}{\\alpha^3} + C\n$$\n所以，$C = y_0 - \\frac{2\\beta}{\\alpha^3}$。\n\n该初值问题的精确解是：\n$$\ny(t) = \\beta\\left(\\frac{t^2}{\\alpha} + \\frac{2t}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) + \\left(y_0 - \\frac{2\\beta}{\\alpha^3}\\right) \\exp(\\alpha t)\n$$\n现在，我们在 $t=h$ 处计算这个精确解的值：\n$$\ny(h) = \\beta\\left(\\frac{h^2}{\\alpha} + \\frac{2h}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) + \\left(y_0 - \\frac{2\\beta}{\\alpha^3}\\right) \\exp(\\alpha h)\n$$\n最后，我们将 $y(h)$ 的这个表达式代入局部截断误差 $\\tau_1$ 的公式中：\n$$\n\\tau_1 = y(h) - y_0(1 + \\alpha h)\n$$\n$$\n\\tau_1 = \\left[ \\beta\\left(\\frac{h^2}{\\alpha} + \\frac{2h}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) + \\left(y_0 - \\frac{2\\beta}{\\alpha^3}\\right) \\exp(\\alpha h) \\right] - y_0(1 + \\alpha h)\n$$\n这就是精确局部截断误差的最终表达式。为了清晰起见，我们可以稍微重新整理一下：\n$$\n\\tau_1 = \\left(y_0 - \\frac{2\\beta}{\\alpha^3}\\right) \\exp(\\alpha h) + \\beta\\left(\\frac{h^2}{\\alpha} + \\frac{2h}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) - y_0 - y_0 \\alpha h\n$$", "answer": "$$\\boxed{\\left(y_0 - \\frac{2\\beta}{\\alpha^3}\\right) \\exp(\\alpha h) + \\beta\\left(\\frac{h^2}{\\alpha} + \\frac{2h}{\\alpha^2} + \\frac{2}{\\alpha^3}\\right) - y_0(1 + \\alpha h)}$$", "id": "2185646"}, {"introduction": "为了更深刻地理解为什么前向欧拉法的局部截断误差是 $O(h^2)$ 阶，我们可以进行一个思想实验。这个问题要求你考虑一个假设情景，即某个常微分方程的真实解是一个简单的二次多项式。通过分析这个简化案例，你将能推导出一个精确、简洁的局部截断误差表达式，从而揭示其与解的曲率和步长之间的直接关系。[@problem_id:2395171]", "problem": "考虑一个由 $y^{\\prime}(t)=f(t,y(t))$ 给出的常微分方程（ODE）的初值问题，其在一个区间上的精确解为二次多项式 $y(t)=a t^{2}+b t+c$，其中 $a$、$b$ 和 $c$ 是实常数。从 $t_{n}$ 到 $t_{n+1}=t_{n}+h$ 应用步长为 $h0$ 的单步前向欧拉法。将第 $n$ 步的局部截断误差（LTE）定义为\n$$\\tau_{n+1}=y(t_{n+1})-\\big(y(t_{n})+h\\,f(t_{n},y(t_{n}))\\big).$$\n确定 $\\tau_{n+1}$ 作为 $a$ 和 $h$ 的函数的精确闭式表达式。以单个解析表达式的形式给出你的最终答案。", "solution": "在尝试求解之前，需要对问题陈述进行严格验证。\n\n第 1 步：提取已知条件\n已知条件如下：\n- 初值问题是针对一个常微分方程（ODE）：$y^{\\prime}(t)=f(t,y(t))$。\n- 该 ODE 的精确解是一个二次多项式：$y(t)=a t^{2}+b t+c$，其中 $a$、$b$ 和 $c$ 是实常数。\n- 数值方法是步长为 $h0$ 的单步前向欧拉法，从 $t_{n}$ 到 $t_{n+1}=t_{n}+h$。\n- 局部截断误差（LTE）的定义为：$\\tau_{n+1}=y(t_{n+1})-\\big(y(t_{n})+h\\,f(t_{n},y(t_{n}))\\big)$。\n- 目标是找到 $\\tau_{n+1}$ 作为 $a$ 和 $h$ 的函数的精确闭式表达式。\n\n第 2 步：使用提取的已知条件进行验证\n对问题进行验证：\n- **科学依据**：该问题基于常微分方程数值分析的基本概念，特别是前向欧拉法及其局部截断误差。这些是计算科学与工程领域的标准、成熟的课题。问题的前提在事实上是合理的。\n- **适定性**：该问题提供了所有必要的定义和信息。函数 $f(t,y)$ 由精确解 $y(t)$ 隐式定义，因为条件 $y'(t) = f(t,y(t))$ 必须在区间内对所有 $t$ 成立。目标明确，且预期存在唯一解。\n- **客观性**：该问题以精确的数学语言陈述，没有歧义或主观陈述。\n\n该问题没有表现出科学上不合理、信息缺失或逻辑矛盾等任何缺陷。这是其领域内一个标准的适定问题。\n\n第 3 步：结论与行动\n该问题是有效的。将提供解答。\n\n前向欧拉法单步的局部截断误差（LTE）定义为：\n$$\n\\tau_{n+1} = y(t_{n+1}) - \\left( y(t_n) + h f(t_n, y(t_n)) \\right)\n$$\n此处，$y(t)$ 代表常微分方程 $y'(t) = f(t, y(t))$ 的精确解。因此，函数 $f$ 在精确解轨迹上一点 $(t_n, y(t_n))$ 的值，就是精确解在该点的导数 $y'(t_n)$。\n$$\nf(t_n, y(t_n)) = y'(t_n)\n$$\n将此代入局部截断误差的定义，我们得到：\n$$\n\\tau_{n+1} = y(t_{n+1}) - y(t_n) - h y'(t_n)\n$$\n问题陈述指出，精确解是二次多项式：\n$$\ny(t) = a t^2 + b t + c\n$$\n我们必须首先计算 $y(t)$ 的导数：\n$$\ny'(t) = \\frac{d}{dt}(a t^2 + b t + c) = 2 a t + b\n$$\n现在，我们使用这些表达式来计算 $y(t_{n+1})$、$y(t_n)$ 和 $y'(t_n)$ 的值。点 $t_{n+1}$ 定义为 $t_{n+1} = t_n + h$。\n精确解在 $t_n$ 处的值是：\n$$\ny(t_n) = a t_n^2 + b t_n + c\n$$\n精确解在 $t_{n+1}$ 处的值是：\n$$\ny(t_{n+1}) = y(t_n + h) = a(t_n + h)^2 + b(t_n + h) + c\n$$\n展开这个表达式，我们得到：\n$$\ny(t_{n+1}) = a(t_n^2 + 2 t_n h + h^2) + b t_n + b h + c = a t_n^2 + 2 a t_n h + a h^2 + b t_n + b h + c\n$$\n精确解的导数在 $t_n$ 处的值是：\n$$\ny'(t_n) = 2 a t_n + b\n$$\n现在，我们将这三个表达式代入 $\\tau_{n+1}$ 的公式中：\n$$\n\\tau_{n+1} = (a t_n^2 + 2 a t_n h + a h^2 + b t_n + b h + c) - (a t_n^2 + b t_n + c) - h(2 a t_n + b)\n$$\n我们进行代数化简。首先，分配 $-h$ 项：\n$$\n\\tau_{n+1} = a t_n^2 + 2 a t_n h + a h^2 + b t_n + b h + c - a t_n^2 - b t_n - c - 2 a t_n h - b h\n$$\n接下来，我们对项进行分组和抵消：\n$$\n\\tau_{n+1} = (a t_n^2 - a t_n^2) + (2 a t_n h - 2 a t_n h) + (b t_n - b t_n) + (b h - b h) + (c - c) + a h^2\n$$\n除了 $a h^2$ 外，所有项都抵消了。\n$$\n\\tau_{n+1} = a h^2\n$$\n这个结果与 $t_n$、$b$ 和 $c$ 无关，仅取决于二次项的系数 $a$ 和步长 $h$。这就是所要求的局部截断误差的精确闭式表达式。该结果与数值方法的一般理论相一致，该理论指出前向欧拉法的局部截断误差为 $O(h^2)$ 阶，具体为 $\\tau_{n+1} = \\frac{h^2}{2} y''(t_n) + O(h^3)$。对于 $y(t) = a t^2 + b t + c$，我们有 $y''(t) = 2a$，且所有更高阶的导数都为零，因此一般公式给出 $\\tau_{n+1} = \\frac{h^2}{2} (2a) = a h^2$，这证实了我们的直接计算。", "answer": "$$\\boxed{a h^{2}}$$", "id": "2395171"}, {"introduction": "在实际应用中，我们很少知道常微分方程的精确解，这使得直接计算局部截断误差变得不可能。然而，我们仍然可以通过实验来验证一个求解器的精度阶数。这个计算练习将指导你使用一种标准技术来估计局部截断误差的阶数，即比较单次大步长和两次小半步长的计算结果。这个过程展示了如何将理论误差分析转化为一种实用的验证工具。[@problem_id:2395168]", "problem": "考虑形式为 $\\dfrac{dy}{dt} = f(t,y)$ 且满足 $y(t_0)=y_0$ 的初值问题，以及一个将 $(t_n,y_n)$ 映射到 $(t_{n+1},y_{n+1})$（其中 $t_{n+1}=t_n+h$）的单步求解器。局部截断误差 (LTE) 定义为从精确状态开始，在单个步长内产生的误差，即在 $t_0+h$ 处的精确解与从 $(t_0,y(t_0))$ 开始的求解器单步输出之间的差值。您只能访问求解器在不同步长下的输出，并且必须从基本原理出发，判断当 $h \\to 0$ 时，LTE 是否按 $O(h^2)$ 缩放，这是前向欧拉法的一个特征。\n\n您的任务是：\n- 构建一个可观测量，该量仅依赖于从 $t_0$ 处的相同初始数据出发、在步长 $h$ 和 $h/2$ 下求解器的输出，并能反映在 $[t_0,t_0+h]$ 上的单步不精确性。\n- 对于一个步长序列 $(h_j)$（其中 $h_{j+1} = h_j/2$），当 $h \\to 0$ 时，经验性地拟合一个形式为 $\\lVert \\text{observable}(h) \\rVert \\approx C h^r$ 的幂律，并通过在对数尺度上进行最小二乘拟合来估计指数 $r$。对于标量问题使用绝对值，对于向量值问题使用欧几里得范数。\n- 当且仅当估计的指数 $r$ 约等于 $2$（在数值容差范围内）时，得出 LTE 为 $O(h^2)$ 的结论。\n\n设计您的程序，对四个测试用例进行此分析。在所有情况下，角度（如果有）均以弧度为单位。\n\n测试套件：\n- 测试 $1$ (标量，线性): $f(t,y) = -2y$, $t_0=0$, $y_0=1$, 步长 $h \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- 测试 $2$ (标量，非线性): $f(t,y) = y^2 - y$, $t_0=0$, $y_0=0.3$, 步长 $h \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- 测试 $3$ (向量，线性旋转): 对于 $y=\\begin{bmatrix}y_1\\\\y_2\\end{bmatrix}$，$f(t,y) = \\begin{bmatrix}-y_2 \\\\ y_1\\end{bmatrix}$，$t_0=0$, $y_0=\\begin{bmatrix}1\\\\0\\end{bmatrix}$，步长 $h \\in \\{0.2, 0.1, 0.05, 0.025, 0.0125\\}$。\n- 测试 $4$ (标量，小步长压力测试): $f(t,y) = -2y$, $t_0=0$, $y_0=1$, 步长 $h \\in \\{2^{-10}, 2^{-11}, 2^{-12}, 2^{-13}, 2^{-14}\\}$。\n\n实现要求：\n- 将求解器视为黑箱；您只能使用从 $(t_0,y_0)$ 开始，在指定步长下的单步输出来为每个 $h$ 构建您的可观测量。\n- 对每个测试，通过对所有给定的 $h$ 值，对 $\\log(\\lVert \\text{observable}(h) \\rVert)$ 与 $\\log(h)$ 进行最小二乘拟合，来计算估计的指数 $r$。\n- 您的程序必须生成单行输出，其中包含四个估计的指数，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到三位小数（例如，$[2.000,2.000,2.000,2.000]$）。\n\n您的输出必须是数值型且无单位。不提供外部输入；所有计算必须按上述规定在程序内部执行。最终输出格式严格为一行，采用所描述的列表表示法。", "solution": "所述问题是有效的。它在科学上基于常微分方程的数值分析原理，是适定的，具有明确的目标和方法，并且没有矛盾或歧义。我们将进行正式求解。\n\n目标是设计并实现一个数值程序，以验证一个被假定为前向欧拉法的单步求解器的局部截断误差 (LTE) 的阶。假设是 LTE 的阶为 $O(h^2)$，其中 $h$ 是步长。\n\n一个初值问题 (IVP) 由微分方程 $\\dfrac{dy}{dt} = f(t,y)$ 和初始条件 $y(t_0)=y_0$ 给出。前向欧拉法在离散时间点 $t_n = t_0 + nh$ 上生成对精确解 $y(t_n)$ 的近似序列 $y_n$。其更新规则是：\n$$y_{n+1} = y_n + h f(t_n, y_n)$$\n\n局部截断误差，我们记为 $\\tau(h)$，是在单个步骤中产生的误差，假设该步骤从精确解 $y_n = y(t_n)$ 开始。其定义为：\n$$\\tau(h) = y(t_n + h) - y_{n+1}$$\n为了确定这个误差的阶，我们对精确解 $y(t_n + h)$ 在 $t_n$ 周围进行泰勒级数展开：\n$$y(t_n + h) = y(t_n) + h y'(t_n) + \\frac{h^2}{2} y''(t_n) + O(h^3)$$\n根据 IVP 的定义，$y'(t_n) = f(t_n, y(t_n))$。将此式和前向欧拉法的 $y_{n+1}$ 公式代入 LTE 的定义，我们得到：\n$$ \\tau(h) = \\left( y(t_n) + h f(t_n, y(t_n)) + \\frac{h^2}{2} y''(t_n) + O(h^3) \\right) - \\left( y(t_n) + h f(t_n, y(t_n)) \\right) $$\n$$ \\tau(h) = \\frac{h^2}{2} y''(t_n) + O(h^3) $$\n这证实了前向欧拉法的 LTE 确实是 $O(h^2)$ 阶的。\n\n问题的核心是在无法获得精确解 $y(t_n+h)$ 及其导数的情况下验证此性质。我们的任务是仅使用“黑箱”求解器的输出来构建一个可观测的量。一种标准技术是比较从相同初始状态 $(t_0, y_0)$ 出发，单步长为 $h$ 的结果与连续两步步长为 $h/2$ 的结果。\n\n让我们定义在时间 $t_0+h$ 处解的两个近似值：\n$1$. 步长为 $h$ 的单步：\n$$y_h = y_0 + h f(t_0, y_0)$$\n$2$. 步长为 $h/2$ 的两个连续步骤：\n$$y'_{h/2} = y_0 + \\frac{h}{2} f(t_0, y_0)$$\n$$y_{h/2,2} = y'_{h/2} + \\frac{h}{2} f\\left(t_0 + \\frac{h}{2}, y'_{h/2}\\right)$$\n我们的可观测量 $E(h)$ 是这两个近似值之间的差：\n$$E(h) = y_h - y_{h/2,2}$$\n为了找到 $E(h)$ 的阶，我们对 $y_{h/2,2}$ 使用 $f$ 在 $(t_0, y_0)$ 周围的泰勒级数展开：\n$$f\\left(t_0 + \\frac{h}{2}, y'_{h/2}\\right) = f(t_0, y_0) + \\frac{h}{2} \\frac{\\partial f}{\\partial t} + (y'_{h/2} - y_0) \\frac{\\partial f}{\\partial y} + O(h^2)$$\n代入 $y'_{h/2} - y_0 = \\frac{h}{2} f(t_0, y_0)$ 得到：\n$$f\\left(t_0 + \\frac{h}{2}, y'_{h/2}\\right) = f_0 + \\frac{h}{2} \\left( \\frac{\\partial f}{\\partial t} + f_0 \\frac{\\partial f}{\\partial y} \\right) + O(h^2) = f_0 + \\frac{h}{2} y''(t_0) + O(h^2)$$\n其中 $f_0 = f(t_0, y_0)$。将此结果代回 $y_{h/2,2}$ 的表达式中：\n$$y_{h/2,2} = \\left(y_0 + \\frac{h}{2}f_0\\right) + \\frac{h}{2}\\left(f_0 + \\frac{h}{2} y''(t_0) + O(h^2)\\right) = y_0 + h f_0 + \\frac{h^2}{4} y''(t_0) + O(h^3)$$\n现在我们计算可观测量 $E(h)$：\n$$E(h) = (y_0 + h f_0) - \\left(y_0 + h f_0 + \\frac{h^2}{4} y''(t_0) + O(h^3)\\right) = - \\frac{h^2}{4} y''(t_0) + O(h^3)$$\n这表明对于小的 $h$，我们的可观测量的范数与 $h$ 的二次方成比例：\n$$\\lVert E(h) \\rVert \\approx K h^2$$\n其中 $K = \\frac{1}{4} \\lVert y''(t_0) \\rVert$。为了估计指数（我们称之为 $r$），我们分析关系 $\\lVert E(h) \\rVert \\approx K h^r$。通过对两边取自然对数，我们得到一个线性关系：\n$$\\log(\\lVert E(h) \\rVert) \\approx \\log(K) + r \\log(h)$$\n这是一个形式为 $Y = A + rX$ 的方程，其中 $Y = \\log(\\lVert E(h) \\rVert)$，$X = \\log(h)$，以及 $A = \\log(K)$。给定一系列递减步长 $h_j$ 的测量值 $(h_j, \\lVert E(h_j) \\rVert)$，我们可以对转换后的数据点 $(\\log(h_j), \\log(\\lVert E(h_j) \\rVert))$ 进行线性最小二乘回归，以找到斜率 $r$。如果 $r$ 约等于 $2$，我们可以得出结论，可观测量按 $h^2$ 缩放，这反过来支持求解器的 LTE 是 $O(h^2)$ 的假设。\n\n程序将对四个指定的测试用例实现此过程。对于每个用例，它将：\n$1$. 遍历给定的步长序列 $h_j$。\n$2$. 对于每个 $h_j$，使用前向欧拉法计算 $y_{h_j}$ 和 $y_{h_j/2, 2}$。\n$3$. 计算可观测量 $E(h_j) = y_{h_j} - y_{h_j/2, 2}$ 的范数。使用欧几里得范数，对于标量问题，这对应于绝对值。\n$4$. 收集范数的对数值和步长的对数值。\n$5$. 对对数-对数数据进行一次多项式（线性）拟合，以找到斜率 $r$。\n$6$. 报告每个测试用例估计的指数 $r$，四舍五入到三位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Performs an analysis to numerically estimate the order of the local\n    truncation error for the forward Euler method on four test cases.\n    \"\"\"\n\n    # Define the right-hand side functions for the ODEs dy/dt = f(t, y)\n    def f_case1(t, y):\n        return -2 * y\n\n    def f_case2(t, y):\n        return y**2 - y\n\n    def f_case3(t, y):\n        # y is expected to be a numpy array [y1, y2]\n        return np.array([-y[1], y[0]])\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": f_case1,\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"h_values\": np.array([0.2, 0.1, 0.05, 0.025, 0.0125]),\n        },\n        {\n            \"f\": f_case2,\n            \"t0\": 0.0,\n            \"y0\": 0.3,\n            \"h_values\": np.array([0.2, 0.1, 0.05, 0.025, 0.0125]),\n        },\n        {\n            \"f\": f_case3,\n            \"t0\": 0.0,\n            \"y0\": np.array([1.0, 0.0]),\n            \"h_values\": np.array([0.2, 0.1, 0.05, 0.025, 0.0125]),\n        },\n        {\n            \"f\": f_case1,  # Same f as Test 1\n            \"t0\": 0.0,\n            \"y0\": 1.0,\n            \"h_values\": np.array([2**-10, 2**-11, 2**-12, 2**-13, 2**-14]),\n        },\n    ]\n\n    estimated_exponents = []\n    for case in test_cases:\n        f = case[\"f\"]\n        t0 = case[\"t0\"]\n        y0 = case[\"y0\"]\n        h_values = case[\"h_values\"]\n        \n        observable_norms = []\n        \n        for h in h_values:\n            # The 'black-box' solver is the forward Euler method. We apply it\n            # once for a step of size h, and twice for steps of size h/2.\n            \n            # 1. One step of size h\n            y_h = y0 + h * f(t0, y0)\n            \n            # 2. Two steps of size h/2\n            h_half = h / 2.0\n            y_h_half_1 = y0 + h_half * f(t0, y0)  # First half-step\n            y_h_half_2 = y_h_half_1 + h_half * f(t0 + h_half, y_h_half_1) # Second half-step\n            \n            # 3. Construct the observable and compute its norm.\n            # The observable is the difference between the two approximations.\n            observable = y_h - y_h_half_2\n            \n            # The norm is the Euclidean norm (absolute value for scalars).\n            norm_obs = np.linalg.norm(observable)\n            observable_norms.append(norm_obs)\n        \n        # 4. Perform least-squares fit on logarithmic scales.\n        # The equation is log(norm) = r * log(h) + log(C).\n        # We find the slope 'r' of this linear relationship.\n        log_h = np.log(h_values)\n        log_err = np.log(np.array(observable_norms))\n        \n        # np.polyfit for a degree 1 polynomial returns [slope, intercept].\n        # The slope is the desired exponent 'r'.\n        slope, _ = np.polyfit(log_h, log_err, 1)\n        \n        estimated_exponents.append(slope)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{r:.3f}\" for r in estimated_exponents]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2395168"}]}