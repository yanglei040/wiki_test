{"hands_on_practices": [{"introduction": "理解刚性问题的核心在于分析数值方法如何与系统中存在的不同时间尺度相互作用。这个练习将引导你运用线性稳定性理论，剖析一个经典的刚性问题，并揭示为何显式方法会失效，而隐式方法却能成功。这是一个基础性的理论练习，旨在深化你对刚性问题本质的理解 [@problem_id:2439060]。", "problem": "一个代表耦合耗散过程的线性时不变系统由常微分方程 $\\mathbf{u}'(t)=\\mathbf{A}\\mathbf{u}(t)$ 给出，其中\n$$\n\\mathbf{A}=\\begin{bmatrix} -1  0 \\\\ 0  -900 \\end{bmatrix}, \\quad \\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}, \\quad t\\in[0,2].\n$$\n一位工程师建议使用固定步长 $h=0.004$，并采用经典的四阶龙格-库塔(RK4)方法或后向欧拉(BE)方法来对该系统进行积分。根据应用于标量测试方程 $y'(t)=\\lambda y(t)$ 的单步法的线性稳定性定义以及矩阵 $\\mathbf{A}$ 的谱映射进行推理，选出所有正确的陈述。\n\nA. 对于步长 $h=0.004$，经典的四阶龙格-库塔(RK4)方法在 $t\\in[0,2]$ 上对 $\\mathbf{A}$ 的两个特征模态都能产生线性稳定的更新。\n\nB. 对于步长 $h=0.004$，经典的四阶龙格-库塔(RK4)方法对于 $\\mathbf{A}$ 的快特征模态是线性不稳定的，因此即使真实解是衰减的，数值解也可能增长。\n\nC. 对于任意步长 $h0$，后向欧拉(BE)方法对该系统都是线性稳定的。\n\nD. 该系统在标准的计算工程意义上是刚性的：显式步长的限制是由快模态决定的，而不是由解析慢模态所需的精度决定的。\n\nE. 因为两个特征值都在开左半平面，所以任何相容的显式龙格-库塔方法对于任意 $h0$ 在此问题上都是无条件稳定的。", "solution": "首先对问题陈述进行验证。\n\n### 步骤 1: 提取已知条件\n- 控制常微分方程(ODE)是一个线性时不变系统：$\\mathbf{u}'(t)=\\mathbf{A}\\mathbf{u}(t)$。\n- 系统矩阵为 $\\mathbf{A}=\\begin{bmatrix} -1  0 \\\\ 0  -900 \\end{bmatrix}$。\n- 初始条件为 $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$。\n- 时间域为 $t\\in[0,2]$。\n- 建议采用固定步长：$h=0.004$。\n- 考虑两种数值积分方法：经典的四阶龙格-库塔(RK4)方法和后向欧拉(BE)方法。\n- 分析必须基于应用于标量测试方程 $y'(t)=\\lambda y(t)$ 的线性稳定性理论以及矩阵 $\\mathbf{A}$ 的谱。\n\n### 步骤 2: 使用提取的已知条件进行验证\n所给出的问题是常微分方程数值分析领域一个标准的、定义明确的初值问题。\n- **科学上成立：** 该问题使用了线性代数、微分方程和数值稳定性（RK4、后向欧拉、刚性）等基本概念，这些都是计算科学与工程中已确立的原则。这是一个用来阐明刚性概念的教科书式例子。\n- **适定性：** 该问题为一个带初始条件的线性ODE系统提供了完整的描述，该系统拥有唯一的、稳定的解析解。所提出的问题是具体的，并且可以根据标准的稳定性理论得到明确的答案。\n- **客观性：** 问题陈述使用精确的数学和技术语言表述，没有歧义、主观性或非科学性的论断。\n- **完整性与一致性：** 所有必要信息（矩阵 $\\mathbf{A}$、初始条件 $\\mathbf{u}(0)$、时间区间 $t \\in [0,2]$、步长 $h$、所用方法）都已提供。不存在矛盾之处。\n\n### 步骤 3: 结论与行动\n该问题是有效的。可以继续进行严谨的求解和选项评估。\n\n### 推导\n对于系统 $\\mathbf{u}' = \\mathbf{A}\\mathbf{u}$，一个数值方法的稳定性取决于它在标量测试问题 $y' = \\lambda y$ 上的表现，其中 $\\lambda$ 是 $\\mathbf{A}$ 的特征值。矩阵 $\\mathbf{A}$ 是对角矩阵，所以其特征值即为对角线元素：$\\lambda_1 = -1$ 和 $\\lambda_2 = -900$。给定初始条件 $\\mathbf{u}(0)=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，系统的精确解为 $\\mathbf{u}(t) = \\begin{bmatrix}e^{\\lambda_1 t} \\\\ e^{\\lambda_2 t}\\end{bmatrix} = \\begin{bmatrix}e^{-t} \\\\ e^{-900t}\\end{bmatrix}$。随着 $t$ 的增加，解的两个分量都衰减。\n\n对于一个真实解衰减的问题，如果其数值解不增长，则称该单步数值方法是线性稳定的。对于测试方程 $y' = \\lambda y$，数值更新为 $y_{n+1} = R(z) y_n$，其中 $z = h\\lambda$，$R(z)$ 是该方法的稳定性函数。线性稳定性的条件是 $|R(z)| \\le 1$。\n\n建议的步长为 $h = 0.004$。我们必须对两个特征值计算 $z = h\\lambda$：\n- 对于与 $\\lambda_1 = -1$ 相关的“慢”模态：$z_1 = h \\lambda_1 = 0.004 \\times (-1) = -0.004$。\n- 对于与 $\\lambda_2 = -900$ 相关的“快”模态：$z_2 = h \\lambda_2 = 0.004 \\times (-900) = -3.6$。\n\n现在我们来分析这两种方法。\n\n1.  **经典的四阶龙格-库塔(RK4)方法：**\n    RK4的稳定性函数是指数函数的截断泰勒级数，$R_{RK4}(z) = 1 + z + \\frac{z^2}{2!} + \\frac{z^3}{3!} + \\frac{z^4}{4!}$。对于实负数 $z$，其绝对稳定区域 $\\{z \\in \\mathbb{C} : |R_{RK4}(z)| \\le 1\\}$ 约对应于区间 $[-2.785, 0]$。\n    - 对于慢模态：$z_1 = -0.004$。该值位于区间 $[-2.785, 0]$ 内。因此，该方法对此模态是稳定的。\n    - 对于快模态：$z_2 = -3.6$。该值位于区间 $[-2.785, 0]$ 之外，因为 $z_2 = -3.6  -2.785$。该方法对此模态是不稳定的。\n\n2.  **后向欧拉(BE)方法：**\n    其稳定性函数为 $R_{BE}(z) = (1-z)^{-1}$。绝对稳定区域为 $\\{z \\in \\mathbb{C} : |R_{BE}(z)| \\le 1\\}$，这等价于 $\\{z \\in \\mathbb{C} : |1-z| \\ge 1\\}$。该区域包含整个开左半平面 $\\text{Re}(z)  0$。具有此性质的方法称为A-稳定方法。\n    - 对于两个特征值 $\\lambda_1 = -1$ 和 $\\lambda_2 = -900$，以及任意步长 $h > 0$，值 $z_1 = h\\lambda_1$ 和 $z_2 = h\\lambda_2$ 都是实数且为负。它们总是位于左半平面。因此，对于任意 $h > 0$，后向欧拉方法对两个模态都是稳定的。\n\n### 逐项分析选项\n\n**A. 对于步长 $h=0.004$，经典的四阶龙格-库塔(RK4)方法在 $t\\in[0,2]$ 上对 $\\mathbf{A}$ 的两个特征模态都能产生线性稳定的更新。**\n如上推导，对于快特征模态，其特征值为 $\\lambda_2 = -900$，稳定性参数为 $z_2 = -3.6$。该值位于RK4方法的稳定性区间 $[-2.785, 0]$ 之外。因此，快模态的更新是不稳定的。该陈述声称对*两个*特征模态都稳定，这是错误的。\n**结论：不正确。**\n\n**B. 对于步长 $h=0.004$，经典的四阶龙格-库塔(RK4)方法对于 $\\mathbf{A}$ 的快特征模态是线性不稳定的，因此即使真实解是衰减的，数值解也可能增长。**\n如前所示，RK4方法对快模态确实是线性不稳定的，因为 $z_2 = -3.6$ 在稳定区域之外。当一个方法线性不稳定时，对应于该模态的数值解分量的幅度在每一步都会被放大，即 $|R_{RK4}(-3.6)| > 1$。这会导致数值解中的误差呈指数级增长，并最终主导计算，尽管真实解分量 $e^{-900t}$ 会迅速衰减至零。这个陈述正确地描述了违反稳定性条件的后果。\n**结论：正确。**\n\n**C. 对于任意步长 $h0$，后向欧拉(BE)方法对该系统都是线性稳定的。**\n后向欧拉方法是A-稳定的。其绝对稳定区域包含整个复数左半平面 $\\{z \\in \\mathbb{C} : \\text{Re}(z) \\le 0\\}$。系统矩阵 $\\mathbf{A}$ 的特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -900$，两者都在开左半平面。对于任意 $h > 0$，乘积 $h\\lambda_1$ 和 $h\\lambda_2$ 也将位于开左半平面。因此，它们将始终位于后向欧拉方法的稳定区域内。该方法对于此问题是无条件稳定的。\n**结论：正确。**\n\n**D. 该系统在标准的计算工程意义上是刚性的：显式步长的限制是由快模态决定的，而不是由解析慢模态所需的精度决定的。**\n当时间尺度存在巨大差异时，就会出现刚性问题。在这里，时间尺度为 $\\tau_1 = 1/|\\lambda_1| = 1$ 秒 和 $\\tau_2 = 1/|\\lambda_2| = 1/900 \\approx 0.0011$ 秒。比率 $\\tau_1/\\tau_2 = 900 \\gg 1$。经过一个非常短暂的瞬态周期（$\\tau_2$ 的几倍），快分量 $e^{-900t}$ 变得可以忽略不计，解的行为类似于 $e^{-t}$。为了精确地解析这种慢行为，一个相对较大的步长（例如 $h=0.1$）就足够了。然而，为了使像RK4这样的显式方法保持稳定，步长必须满足 $h \\le 2.785/|\\lambda_2| = 2.785/900 \\approx 0.0031$。这个步长是由快速的、瞬态模态的稳定性决定的，而不是由慢速的、持续模态的精度要求决定的。这正是刚性系统的定义。\n**结论：正确。**\n\n**E. 因为两个特征值都在开左半平面，所以任何相容的显式龙格-库塔方法对于任意 $h0$ 在此问题上都是无条件稳定的。**\n这个陈述从根本上是错误的。没有显式龙格-库塔方法可以是A-稳定的。显式方法的稳定性函数 $R(z)$ 是一个关于 $z$ 的多项式。当 $|z| \\to \\infty$ 时，任何多项式都是无界的，所以 $|R(z)|$ 不可能对于左半平面中所有的 $z$ 都小于或等于 $1$。显式方法的稳定区域总是有界的。因此，对于任何此类方法和任何 $\\lambda  0$，总存在一个足够大的步长 $h$，使得 $h\\lambda$ 落在稳定区域之外。因此，对于刚性问题，所有显式方法对 $h$ 都有一个条件稳定性限制。\n**结论：不正确。**", "answer": "$$\\boxed{BCD}$$", "id": "2439060"}, {"introduction": "理论分析之后，亲手实践是检验理解的最佳方式。这个练习将让你通过编程，在一个非刚性问题和两个刚性问题上运行一个标准的显式自适应步长积分器 [@problem_id:2439135]。你将亲眼观察到刚性问题如何导致求解器步长急剧减小，从而培养通过观察求解器行为来诊断刚性问题的实用技能。", "problem": "构造一个程序，用于分析显式自适应积分器在表现出刚性的初值问题上的步长行为。对于每个给定的初值问题，对系统进行积分，并记录积分过程中的最小可接受时间步长。使用一个五阶显式 Runge–Kutta–Fehlberg 方法，该方法带有一个嵌入的四阶估计器（Runge–Kutta–Fehlberg (RKF45)），并采用标准的绝对和相对误差控制。对于所有问题，要求绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$。将可接受的步长定义为：其嵌入式局部误差估计满足一个标准的加权均方根准则，即小于或等于 $1$。将“极端步长减小”定义为：在指定的积分区间内，出现了严格小于 $10^{-4}$ 的最小可接受时间步长。\n\n您必须评估以下初值问题测试套件：\n\n- 测试 A（非刚性标量）：$$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- 测试 B（刚性标量，强迫线性）：$$y'(t) = -10000y(t) + 30000 - 20000e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- 测试 C（刚性线性双分量系统）：$$\\begin{aligned} y_1'(t) = -15y_1(t), \\\\ y_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\n对于每个测试，计算在积分过程中遇到的最小可接受步长 $h_{\\min}$，并根据 $h_{\\min}  10^{-4}$ 是否成立来确定一个布尔值。最终所需的输出是一行，其中包含一个用方括号括起来的、按 $\\text{[A,B,C]}$ 顺序排列的、由逗号分隔的这三个布尔结果列表。例如，形如 $\\text{[False,True,True]}$ 的输出表示测试 B 和测试 C 发生了极端步长减小，而测试 A 没有。\n\n本问题中没有物理单位，不出现角度，也不使用百分比。您的程序必须生成一行输出，其中包含用方括号括起来的、按上述 $\\text{[A,B,C]}$ 顺序排列的、以逗号分隔的结果列表。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据，是适定的、客观的，并包含了构建唯一、可验证解所需的所有必要信息。该问题属于计算工程和数值分析领域，具体涉及常微分方程（ODEs）中的刚性概念。\n\n初值问题中的刚性，是指当解包含在截然不同的时间尺度上变化的多个分量时出现的现象。这对显式数值积分方法构成了重大挑战。尽管快速衰减的分量（瞬态）可能很快变得可以忽略不计，但它们在系统雅可比矩阵中的存在，会继续对积分器的步长施加严格限制，以维持数值稳定性。即使当解的光滑、慢变部分的精度要求允许使用大得多的步长时，步长仍然受到最快时间尺度的限制。这导致了计算效率低下的积分过程，因为求解器被迫采取了过多的极小步长。\n\n本任务旨在通过分析一个显式自适应积分器在三个不同常微分方程问题上的步长行为来展示这一现象。所选的积分器是一个五阶 Runge-Kutta-Fehlberg 方法，它带有一个嵌入的四阶误差估计器，通常称为 RKF45。此类方法的一个现代、高质量的实现是 Dormand-Prince 5(4) 对，它在 `scipy` 库中以 `scipy.integrate.solve_ivp` 的形式提供，并使用 `method='RK45'` 参数。这将是用于数值积分的工具。\n\n积分过程使用基于局部误差估计的自适应步长控制。在每一步中，通过比较五阶解与嵌入的四阶解来估计误差。这个误差 $E$ 使用加权均方根范数进行度量，并且只有在 $E \\le 1$ 时，该步长才被接受。权重是指定的绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$ 的函数。具体来说，对于解向量 $y$，误差由 $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$ 进行缩放。在一个大小为 $h$ 的步长被接受后，选择下一个步长以使估计误差接近目标值 $1$。如果误差过大，该步长将被拒绝，并用一个更小的 $h$ 进行重试。\n\n我们将分析三个初值问题，并记录每个问题的最小可接受步长 $h_{\\min}$。“极端步长减小”的条件定义为 $h_{\\min}  10^{-4}$。\n\n测试 A：非刚性标量问题\nODE 为 $y'(t) = -y(t)$，其中 $y(0)=1$，$t \\in [0, 10]$。\n系统的雅可比矩阵只是标量 $J = [-1]$。唯一的特征值是 $\\lambda = -1$，对应的时间常数为 $\\tau = 1/|\\lambda| = 1$。解为 $y(t) = e^{-t}$。只有一个时间尺度，而且不是特别快。自适应积分器选择的步长将主要由 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 定义的精度要求决定。我们不期望稳定性会迫使步长变得病态地小。因此，预测 $h_{\\min}$ 不会低于 $10^{-4}$ 的阈值。\n\n测试 B：刚性标量问题\nODE 为 $y'(t) = -10000y(t) + 30000 - 20000e^{-t}$，其中 $y(0)=0$，$t \\in [0, 0.1]$。\n雅可比矩阵为 $J = [-10000]$。特征值为 $\\lambda = -10000$，对应一个极快的时间常数 $\\tau = 1/|\\lambda| = 10^{-4}$ s。显式 Runge-Kutta 方法的稳定性区域要求步长 $h$ 和特征值 $\\lambda$ 的乘积位于复平面内的一个有界区域中。对于实负特征值，这施加了一个形式为 $h \\lesssim C/|\\lambda|$ 的约束，其中 $C$ 是一个数量级为 $1$ 的常数。对于本问题，该约束为 $h \\lesssim C \\times 10^{-4}$。即使与该特征值相关的初始瞬态已经衰减（这在 $10^{-4}$ 的几倍时间内非常快地发生），这个稳定性约束对于显式积分器仍然有效。因此，在整个积分区间内，步长将受到严重限制。强烈预测 $h_{\\min}$ 将小于 $10^{-4}$。\n\n测试 C：刚性线性系统\n系统由下式给出：\n$$\n\\begin{aligned}\ny_1'(t) = -15y_1(t) \\\\\ny_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{其中} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{在} \\quad t \\in [0, 0.2] \\text{上}。\n$$\n该系统的雅可比矩阵是：\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15  0 \\\\ 10000  -10000 \\end{bmatrix}\n$$\n由于该矩阵是下三角矩阵，其特征值是其对角线元素：$\\lambda_1 = -15$ 和 $\\lambda_2 = -10000$。这对应两个截然不同的时间尺度：一个慢尺度 $\\tau_1 = 1/15 \\approx 0.067$ 和一个非常快的尺度 $\\tau_2 = 1/10000 = 10^{-4}$。特征值幅值的比率，即刚性比，为 $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$，这个值很大，证实了该系统是刚性的。与测试 B 一样，显式积分器的稳定性由幅值最大的特征值 $\\lambda_2 = -10000$ 决定。步长 $h$ 将受到与此特征值相关的稳定性极限的约束，迫使 $h$ 保持在 $10^{-4}$ 或更小的数量级。因此，预测 $h_{\\min}  10^{-4}$。\n\n程序将通过对每种情况调用 `scipy.integrate.solve_ivp` 来实现此分析。返回的解对象包含一个数组 `sol.t`，其中包含了计算解的时间点。然后，通过计算该数组中的连续差值 `np.diff(sol.t)` 来得到可接受步长的序列。这些值中的最小值是 $h_{\\min}$，然后将其与 $10^{-4}$ 阈值进行比较，以生成所需的布尔输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t)  2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) exists, there are no steps.\n            # We can treat this as no extreme reduction, or handle as an error.\n            # For this problem's context, it indicates no steps were taken or needed,\n            # so no small steps were taken.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min  step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    # Python's `str(bool)` converts True to 'True' and False to 'False',\n    # which is not what the example output shows. The problem asks for a list\n    # of boolean values, which is commonly represented textually as true/false\n    # or True/False. We will stick to the standard Python representation.\n    # The example [False,True,True] uses capitalized boolean literals.\n    # Let's format it exactly as specified.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2439135"}, {"introduction": "在分析并观察了刚性问题后，最后一步是应用一种有效的求解策略。这个高级练习将指导你为一个常见的刚性来源——反应扩散系统——实现一种半隐式（IMEX）方法 [@problem_id:2439136]。通过这个实践，你将掌握一种强大的技术：对问题中的刚性与非刚性部分区别对待，这是现代数值方法的重要基石。", "problem": "考虑一个半离散反应扩散系统的初值问题，该系统通过对一维空间域进行均匀二阶中心差分格式离散化得到。设空间域为闭区间 $\\left[0,1\\right]$，具有齐次狄利克雷边界条件。对于一个整数 $N \\ge 1$，定义一个包含 $N$ 个内点的均匀网格，这些点的位置为 $x_j = \\dfrac{j}{N+1}$，其中 $j = 1,2,\\ldots,N$，间距为 $\\Delta x = \\dfrac{1}{N+1}$。定义状态向量 $y(t) \\in \\mathbb{R}^N$，其分量 $y_j(t)$ 近似于在 $x_j$ 处的解。该半离散常微分方程（ODE）系统为\n$$\n\\frac{d y}{d t} = A y + g(y),\n$$\n其中，扩散矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是具有齐次狄利克雷边界条件的标准离散拉普拉斯算子，\n$$\nA = \\frac{D}{\\left(\\Delta x\\right)^2} \\operatorname{tridiag}\\left(1, -2, 1\\right),\n$$\n$D \\ge 0$ 是扩散系数，非线性反应项 $g: \\mathbb{R}^N \\to \\mathbb{R}^N$ 以分量形式作用，即\n$$\n\\left[g(y)\\right]_j = \\lambda \\left(y_j - y_j^3\\right),\n$$\n$\\lambda \\in \\mathbb{R}$ 是反应系数。初始条件为\n$$\ny_j(0) = \\sin\\!\\left(\\pi x_j\\right), \\quad j = 1,2,\\ldots,N.\n$$\n\n对于给定的最终时间 $T  0$ 和时间步长 $h  0$（使得 $M = \\dfrac{T}{h}$ 为整数），定义时间网格 $t_n = n h$，其中 $n = 0,1,\\ldots,M$。考虑满足以下条件的唯一序列 $\\{y^n\\}_{n=0}^M \\subset \\mathbb{R}^N$\n$$\n\\left(I - h A\\right) y^{n+1} = y^n + h g\\left(y^n\\right), \\quad n = 0,1,\\ldots,M-1,\n$$\n其中 $y^0$ 由初始条件给出。对于每个指定的参数集，计算最终状态 $y^M$ 的离散欧几里得范数（也称为 $L^2$ 范数），定义为\n$$\n\\left\\|y^M\\right\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N \\left(y_j^M\\right)^2 }.\n$$\n\n本问题中的所有量均为无量纲，不需要物理单位。\n\n测试集。对于以下每个参数集 $(N, D, \\lambda, T, h)$，计算 $\\left\\|y^M\\right\\|_{2,\\Delta x}$ 的值：\n- 情况 1：$(50, 1.0, 5.0, 0.1, 0.001)$。\n- 情况 2：$(50, 1.0, 5.0, 0.1, 0.00005)$。\n- 情况 3：$(1, 1.0, 10.0, 0.1, 0.01)$。\n- 情况 4：$(50, 0.0, 5.0, 0.1, 0.01)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个结果，按上述顺序对应每种情况，四舍五入到 $8$ 位小数，以逗号分隔的列表形式用方括号括起来。例如，输出格式必须与以下完全一样\n$$\n\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right].\n$$", "solution": "问题陈述已经过评估，被确定为有效。该问题具有科学依据、适定且客观。它提出了一个在偏微分方程数值分析领域的明确计算任务，具体涉及一个半离散反应扩散系统的求解。该问题包括使用指定的数值格式模拟系统演化，并为几组参数集计算最终状态的范数。\n\n控制方程是一个形式为 $\\frac{d y}{d t} = A y + g(y)$ 的常微分方程（ODE）系统，它源于一维反应扩散偏微分方程的空间离散化（直线法）。项 $A y$ 代表扩散过程，其中 $A$ 是离散拉普拉斯矩阵；$g(y)$ 是一个 Allen-Cahn 类型的非线性反应项，$ [g(y)]_j = \\lambda (y_j - y_j^3) $。这类系统是刚性微分方程的经典例子，因为与扩散相关的时间尺度（与 $A$ 的特征值相关）可能比反应的时间尺度快得多。\n\n为时间积分指定的数值方法是 $(I - h A) y^{n+1} = y^n + h g(y^n)$。这是一种半隐式或隐式-显式（IMEX）格式。刚性线性扩散项 $A y$ 被隐式处理（使用后向欧拉法），而非线性且可能非刚性的反应项 $g(y)$ 被显式处理（使用前向欧拉法）。这种方法非常适用于刚性系统，因为对刚性部分的隐式处理允许使用比完全显式方法更大的时间步长 $h$，而不会遇到数值不稳定性。该方法的稳定性由显式部分决定，这要求 $h$ 相对于反应项 $g(y)$ 的动态足够小。\n\n对于每个给定的参数集 $(N, D, \\lambda, T, h)$，求解算法流程如下。首先，我们建立计算网格和参数：空间点数 $N$，空间步长 $\\Delta x = \\frac{1}{N+1}$，以及时间步数 $M = T/h$。根据初始条件 $y_j(0) = \\sin(\\pi x_j)$，在网格点 $x_j = j \\Delta x$（其中 $j=1, \\ldots, N$）上构造初始状态向量 $y^0 \\in \\mathbb{R}^N$。算法的核心是一个从 $n=0$ 到 $M-1$ 的时间步进循环。在每一步中，我们必须求解一个线性系统以获得下一个状态 $y^{n+1}$。该方程可以重排为 $L y^{n+1} = b$，其中 $L = (I - hA)$ 是系统矩阵，而 $b = y^n + hg(y^n)$ 是根据当前状态 $y^n$ 计算出的右端向量。矩阵 $A = \\frac{D}{(\\Delta x)^2} \\operatorname{tridiag}(1, -2, 1)$ 是三对角的，这意味着矩阵 $L$ 也是三对角的，其主对角线元素为 $1 + \\frac{2hD}{(\\Delta x)^2}$，非对角线元素为 $-\\frac{hD}{(\\Delta x)^2}$。此类三对角系统可以使用专门的算法高效求解；在我们的实现中，我们将使用 `scipy.linalg.solve_banded` 函数。这个循环执行 $M$ 次，将解从初始时间 $t=0$ 推进到最终时间 $t=T$。最后，在最后一个时间步之后，我们获得最终状态向量 $y^M$。所需的量，即离散欧几里得范数 $\\|y^M\\|_{2,\\Delta x}$，使用其定义 $\\|y^M\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N (y_j^M)^2 }$ 进行计算。对所有四个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_one_case(N, D, lambda_val, T, h):\n    \"\"\"\n    Solves the semidiscrete reaction-diffusion system for one set of parameters.\n\n    Args:\n        N (int): Number of interior spatial grid points.\n        D (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The discrete Euclidean norm of the terminal state.\n    \"\"\"\n    # 1. Setup grid and parameters\n    dx = 1.0 / (N + 1)\n    # The problem statement guarantees M = T/h is an integer.\n    # Using round() guards against potential floating-point inaccuracies.\n    M = int(round(T / h))\n    x_grid = np.linspace(dx, 1.0 - dx, N)\n\n    # 2. Set initial condition y^0\n    y = np.sin(np.pi * x_grid)\n\n    # 3. Construct the time-stepping matrix L = (I - hA)\n    # The matrix A is D/dx^2 * tridiag(1, -2, 1).\n    # The matrix L is tridiagonal with diagonals:\n    # Main: 1 + 2*h*D/dx^2\n    # Off-diagonals: -h*D/dx^2\n    # This matrix is represented in the 'ab' banded format for scipy.linalg.solve_banded.\n    # The format requires a (3, N) array for a tridiagonal matrix.\n    \n    # Constant for off-diagonals\n    c = -h * D / (dx**2)\n    \n    # 'ab' matrix for solve_banded (l=1, u=1)\n    # Row 0: Super-diagonal (padded with one 0 at the start)\n    # Row 1: Main diagonal\n    # Row 2: Sub-diagonal (padded with one 0 at the end)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = c\n    ab[1, :] = 1.0 - 2.0 * c \n    ab[2, :-1] = c\n    \n    # 4. Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side: y^n + h*g(y^n)\n        g_y = lambda_val * (y - y**3)\n        rhs = y + h * g_y\n        \n        # Solve the linear system (I - hA)y^{n+1} = rhs for y^{n+1}\n        y = solve_banded((1, 1), ab, rhs, check_finite=False)\n\n    # 5. Compute the final discrete L^2 norm\n    # norm = sqrt(dx * sum(y_j^M)^2)\n    final_norm = np.sqrt(dx * np.sum(y**2))\n    \n    return final_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 1.0, 5.0, 0.1, 0.001),     # Case 1\n        (50, 1.0, 5.0, 0.1, 0.00005),   # Case 2\n        (1, 1.0, 10.0, 0.1, 0.01),      # Case 3\n        (50, 0.0, 5.0, 0.1, 0.01),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lambda_val, T, h = case\n        result = compute_one_case(N, D, lambda_val, T, h)\n        # Format the result to 8 decimal places as required.\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2439136"}]}