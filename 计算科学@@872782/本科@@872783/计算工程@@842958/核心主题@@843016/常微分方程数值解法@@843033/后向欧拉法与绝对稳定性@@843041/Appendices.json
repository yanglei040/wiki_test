{"hands_on_practices": [{"introduction": "刚性常微分方程系统包含变化速率差异巨大的多个尺度，这对数值求解构成了巨大挑战。显式方法（如前向欧拉法）的稳定性受限于系统中变化最快的动力学过程，这迫使其采用极小的时间步长。本练习将通过一个典型的刚性系统，直观地展示隐式后向欧拉法如何克服这一限制，即使在使用远大于前向欧拉法稳定极限的时间步长时，也能保持数值稳定。[@problem_id:2372859]", "problem": "考虑由 $\\dot{x}(t)=A\\,x(t)$ 给出的线性自治常微分方程（ODE）系统，其中 $A\\in\\mathbb{R}^{2\\times 2}$ 是常数矩阵，且 $x(t)\\in\\mathbb{R}^{2}$。将使用两种单步法进行时间推进。显式方法定义为 $x_{n+1}=x_{n}+h\\,A\\,x_{n}$，步长为 $h0$。隐式方法定义为 $x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$，步长为 $H0$，当逆矩阵存在时，可等价地写为 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$。\n\n您的任务是编写一个完整的程序，对于下面指定的每个测试用例，针对给定的 $2\\times 2$ 矩阵 $A$、初始向量 $x_{0}$ 和小步长 $h$ 执行以下操作：\n\n1. 从 $x_{0}$ 开始，使用更新规则 $x_{n+1}=x_{n}+h\\,A\\,x_{n}$ 和步长 $h$ 计算 $N_{\\mathrm{FE}}$ 步的显式迭代，以获得 $x_{\\mathrm{FE,final}}$。\n2. 定义大步长 $H=1000\\,h$。从 $x_{0}$ 开始，使用更新规则 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$ 和步长 $H$ 计算 $N_{\\mathrm{BE}}$ 步的隐式迭代，以获得 $x_{\\mathrm{BE,final}}$。\n3. 令 $\\lVert\\cdot\\rVert$ 表示 $\\mathbb{R}^{2}$ 上的欧几里得范数。定义显式方法“爆炸”的条件为 $\\lVert x_{\\mathrm{FE,final}}\\rVert10\\,\\lVert x_{0}\\rVert$，隐式方法“阻尼”的条件为 $\\lVert x_{\\mathrm{BE,final}}\\rVert  \\lVert x_{0}\\rVert$。对于每种情况，输出一个布尔值，当且仅当这两个条件都成立时，该值为真。\n\n使用以下测试套件：\n\n- 情况 $\\mathbf{1}$（理想情况，对角刚性系统）：\n  - $A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$，\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，\n  - $h=0.003$，\n  - $H=1000\\,h=3$，\n  - $N_{\\mathrm{FE}}=12$，\n  - $N_{\\mathrm{BE}}=3$。\n- 情况 $\\mathbf{2}$（接近显式稳定性边界的边界条件）：\n  - $A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$，\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，\n  - $h=0.002$，\n  - $H=1000\\,h=2$，\n  - $N_{\\mathrm{FE}}=12$，\n  - $N_{\\mathrm{BE}}=3$。\n- 情况 $\\mathbf{3}$（耦合刚性系统）：\n  - $A=\\begin{bmatrix}-1  100 \\\\ 0  -1000\\end{bmatrix}$，\n  - $x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，\n  - $h=0.003$，\n  - $H=1000\\,h=3$，\n  - $N_{\\mathrm{FE}}=12$，\n  - $N_{\\mathrm{BE}}=3$。\n\n最终输出格式：您的程序应生成单行输出，其中包含按顺序排列的三个情况的布尔结果，以逗号分隔并用方括号括起（例如，[${\\rm True},{\\rm False},{\\rm True}]$）。不应打印任何其他文本。", "solution": "如题所述，需要分析两种求解线性常微分方程组 $\\dot{x}(t) = A x(t)$ 的数值方法。这是计算工程和数值分析领域的标准问题。我将首先验证问题陈述的有效性。\n\n### 步骤 1：提取给定条件\n\n给定条件如下：\n- ODE 系统：$\\dot{x}(t)=A\\,x(t)$，其中 $A\\in\\mathbb{R}^{2\\times 2}$ 且 $x(t)\\in\\mathbb{R}^{2}$。\n- 显式方法（前向欧拉法）：$x_{n+1}=x_{n}+h\\,A\\,x_{n} = (I + hA)x_n$，步长 $h0$。\n- 隐式方法（后向欧拉法）：$x_{n+1}=x_{n}+H\\,A\\,x_{n+1}$，等价于 $x_{n+1}=(I-H\\,A)^{-1}x_{n}$，步长 $H0$。\n- 大步长定义为 $H=1000\\,h$。\n- 显式方法“爆炸”的条件定义为 $\\lVert x_{\\mathrm{FE,final}}\\rVert10\\,\\lVert x_{0}\\rVert$，其中 $\\lVert\\cdot\\rVert$ 是欧几里得范数。\n- 隐式方法“阻尼”的条件定义为 $\\lVert x_{\\mathrm{BE,final}}\\rVert  \\lVert x_{0}\\rVert$。\n- 每个情况的最终布尔输出为真，当且仅当“爆炸”条件和“阻尼”条件都成立。\n\n提供的测试用例如下：\n- **情况 1**：$A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$，$x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，$h=0.003$，$H=3$，$N_{\\mathrm{FE}}=12$，$N_{\\mathrm{BE}}=3$。\n- **情况 2**：$A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$，$x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，$h=0.002$，$H=2$，$N_{\\mathrm{FE}}=12$，$N_{\\mathrm{BE}}=3$。\n- **情况 3**：$A=\\begin{bmatrix}-1  100 \\\\ 0  -1000\\end{bmatrix}$，$x_{0}=\\begin{bmatrix}1\\\\1\\end{bmatrix}$，$h=0.003$，$H=3$，$N_{\\mathrm{FE}}=12$，$N_{\\mathrm{BE}}=3$。\n\n### 步骤 2：使用提取的给定条件进行验证\n\n该问题具有科学依据，是客观且适定的。\n- **科学依据**：该问题探讨了刚性常微分方程数值稳定性的基本概念，比较了条件稳定的前向欧拉法和 A-稳定的后向欧拉法。这些都是数值分析中的经典课题。\n- **适定性**：所有参数（$A$, $x_0$, $h$, $H$, $N_{\\mathrm{FE}}$, $N_{\\mathrm{BE}}$）都为每个测试用例精确定义。“爆炸”和“阻尼”的标准是明确的。每种情况都存在唯一的结果。对于所有给定的情况，矩阵 $(I-HA)$ 都是可逆的，因为 $HA$ 的特征值不等于 $1$。\n- **客观性**：该问题以客观的数学语言陈述，没有任何主观解释的余地。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。我将继续提供完整解答。\n\n此问题的核心在于刚性系统数值稳定性的概念。如果矩阵 $A$ 的特征值的实部均为非正数，且数量级相差很大，则系统 $\\dot{x}=Ax$ 被认为是刚性的。数值方法的稳定性由其增长因子 $G$ 决定，该因子控制着数值解的传播：$x_{n+1} = G x_n$。为使解保持有界，增长因子的谱半径 $\\rho(G)$ 必须满足 $\\rho(G) \\le 1$。\n\n对于显式前向欧拉法，增长矩阵为 $G_{\\mathrm{FE}} = I + hA$。稳定性条件为 $\\rho(I+hA) \\le 1$，对于 $A$ 的所有特征值 $\\lambda_i$，这可转化为 $|1+h\\lambda_i| \\le 1$。这为乘积 $h\\lambda$ 在复平面上定义了一个稳定域。对于稳定系统（其中 $\\mathrm{Re}(\\lambda_i) \\le 0$），该方法仅是条件稳定的；它要求步长 $h$ 足够小，通常受最大模特征值的限制。\n\n对于隐式后向欧拉法，增长矩阵为 $G_{\\mathrm{BE}} = (I - HA)^{-1}$。稳定性条件为 $\\rho((I-HA)^{-1}) \\le 1$，对于 $A$ 的所有特征值 $\\lambda_i$，这可转化为 $|(1-H\\lambda_i)^{-1}| \\le 1$。只要 $\\mathrm{Re}(\\lambda_i) \\leq 0$，对于任何 $H  0$ 该条件都成立。此性质称为 A-稳定性，使得该方法对于刚性系统是无条件稳定的。它允许使用更大的步长 $H$ 而不会出现数值不稳定性，这在计算上是有利的。\n\n现在，我们分析每种情况。\n\n**情况 1**：$A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$。特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.003$。\n- **前向欧拉法**：我们检查稳定性条件 $|1+h\\lambda_i| \\le 1$。\n  - 对于 $\\lambda_1 = -1$：$|1 + (0.003)(-1)| = |0.997| = 0.997 \\le 1$。该分量稳定。\n  - 对于 $\\lambda_2 = -1000$：$|1 + (0.003)(-1000)| = |1 - 3| = |-2| = 2  1$。该分量不稳定。\n  由于不稳定的模式，数值解将呈指数级增长，我们预计在 $N_{\\mathrm{FE}}=12$ 步后，“爆炸”条件会得到满足。\n- **后向欧拉法**：步长为 $H=3$。该方法是 A-稳定的。特征模式的增长因子为：\n  - 对于 $\\lambda_1 = -1$：$|(1 - (3)(-1))^{-1}| = |1/4| = 0.25  1$。该分量被强烈阻尼。\n  - 对于 $\\lambda_2 = -1000$：$|(1 - (3)(-1000))^{-1}| = |1/3001| \\approx 3.33 \\times 10^{-4}  1$。该分量被非常强烈地阻尼。\n  解向量的范数将会减小。因此，我们预计“阻尼”条件会得到满足。\n- **结论**：预计两个条件都为真。情况 1 的结果是 `True`。\n\n**情况 2**：$A=\\begin{bmatrix}-1  0 \\\\ 0  -1000\\end{bmatrix}$。特征值为 $\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.002$。\n- **前向欧拉法**：我们检查稳定性条件 $|1+h\\lambda_i| \\le 1$。\n  - 对于 $\\lambda_1 = -1$：$|1 + (0.002)(-1)| = |0.998| = 0.998 \\le 1$。该分量稳定。\n  - 对于 $\\lambda_2 = -1000$：$|1 + (0.002)(-1000)| = |1 - 2| = |-1| = 1 \\le 1$。该分量位于稳定域的边界上。\n  解的范数不会呈指数级增长。解的第二个分量将以恒定振幅振荡，而第一个分量则衰减。总范数预计不会增长到 10 倍。“爆炸”条件将为假。\n- **后向欧拉法**：步长为 $H=2$。该方法是 A-稳定的。\n  - 对于 $\\lambda_1 = -1$ 的增长因子：$|(1 - (2)(-1))^{-1}| = |1/3|  1$。\n  - 对于 $\\lambda_2 = -1000$ 的增长因子：$|(1 - (2)(-1000))^{-1}| = |1/2001|  1$。\n  解将被阻尼。\n- **结论**：“爆炸”条件为假，因此组合条件为假。情况 2 的结果是 `False`。\n\n**情况 3**：$A=\\begin{bmatrix}-1  100 \\\\ 0  -1000\\end{bmatrix}$。这是一个上三角矩阵，因此其特征值是其对角线元素：$\\lambda_1 = -1$ 和 $\\lambda_2 = -1000$。步长为 $h=0.003$。\n- **前向欧拉法**：稳定性分析仅取决于特征值，与情况 1 相同。当 $h=0.003$ 时，特征值 $\\lambda_2 = -1000$ 产生 $|1 + (0.003)(-1000)| = 2  1$，因此该方法是不稳定的。耦合项 $A_{12}=100$ 会将能量从不稳定模式传递到稳定模式，但整体解将由不稳定特征分量的指数增长所主导。预计“爆炸”条件会得到满足。\n- **后向欧拉法**：步长为 $H=3$。该方法是 A-稳定的，不受耦合影响。增长因子由特征值决定，与情况 1 中的相同。解将被“阻尼”。\n- **结论**：预计两个条件都为真。情况 3 的结果是 `True`。\n\n总之，理论分析预测三个情况的结果分别为 `True`、`False` 和 `True`。以下程序将执行直接数值模拟以验证此结论。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the given problem by simulating two numerical methods for a system of ODEs\n    and checking for specific stability-related conditions.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 0], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.002,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        },\n        {\n            \"A\": np.array([[-1, 100], [0, -1000]]),\n            \"x0\": np.array([1, 1]),\n            \"h\": 0.003,\n            \"N_FE\": 12,\n            \"N_BE\": 3\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A = case[\"A\"]\n        x0 = case[\"x0\"].astype(float)\n        h = case[\"h\"]\n        N_FE = case[\"N_FE\"]\n        N_BE = case[\"N_BE\"]\n        \n        # The large stepsize H is defined as 1000*h\n        H = 1000 * h\n\n        # Calculate initial norm\n        norm_x0 = np.linalg.norm(x0)\n\n        # 1. Explicit method (Forward Euler) simulation\n        x_fe = x0.copy()\n        for _ in range(N_FE):\n            x_fe = x_fe + h * (A @ x_fe)\n        \n        norm_fe_final = np.linalg.norm(x_fe)\n        explodes = norm_fe_final > 10 * norm_x0\n\n        # 2. Implicit method (Backward Euler) simulation\n        x_be = x0.copy()\n        # Pre-compute the inverse of (I - H*A)\n        # I is the 2x2 identity matrix\n        I = np.identity(2)\n        inv_mat_be = np.linalg.inv(I - H * A)\n        \n        for _ in range(N_BE):\n            x_be = inv_mat_be @ x_be\n        \n        norm_be_final = np.linalg.norm(x_be)\n        damped = norm_be_final  norm_x0\n        \n        # 3. Check if both conditions hold\n        results.append(explodes and damped)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372859"}, {"introduction": "鉴于后向欧拉法卓越的稳定性，我们很自然地会想，是否可以无限制地增大时间步长来加速计算。本练习旨在揭示一个关键的细微之处：数值稳定性与计算精度是两个不同的概念。通过一个放射性衰变模型，您将量化并发现，尽管该方法在很大的时间步长下依然稳定，但对于系统中慢衰变的物理过程，其计算结果的误差可能会大到无法接受。[@problem_id:2372906]", "problem": "考虑一个双同位素、非耦合的放射性衰变模型，该模型由以下常微分方程(ODE)组描述\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s,\n$$\n其初始条件为\n$$\nc_f(0)=c_{f,0},\\qquad c_s(0)=c_{s,0},\n$$\n其中，$c_f$ 和 $c_s$ 分别表示快速衰变和慢速衰变同位素的浓度，$\\lambda_f$ 和 $\\lambda_s$ 是正的衰变率，且满足 $\\lambda_f  \\lambda_s$。每种同位素的精确解为\n$$\nc_f(t)=c_{f,0}\\,e^{-\\lambda_f t},\\qquad c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}.\n$$\n你需要使用后向欧拉法(Backward Euler, BE)，以恒定时间步长 $h$ 从 $t=0$ 到最终时间 $t=T$ 对解进行近似。假设 $T/h$ 是一个整数，因此总步数为整数 $N=T/h$。所有量均为无量纲；不要在任何数值后附加单位。\n\n对于每个测试用例，计算慢同位素组分的以下两个量：\n1. 应用于慢组分的单步映射的稳定性指标 $s$。如果每步放大因子的绝对值小于或等于 1，则定义 $s=1$，否则 $s=0$。\n2. 在时间 $T$ 时的绝对误差 $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$。\n\n使用以下参数集的测试套件 $(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)$：\n- 测试 A：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(10,0.1,1,1,1,5)$。\n- 测试 B：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(50,0.2,2,2,10,50)$。\n- 测试 C：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(1,0.01,3,1,100,100)$。\n- 测试 D：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(5,10^{-6},1,1.5,10^{6},10^{6})$。\n\n你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例贡献一个双元素列表 $[s,E]$，其中 $s$ 是一个整数，$E$ 是一个浮点数。总体输出格式必须为\n$$\n[\\,[s_A,E_A],[s_B,E_B],[s_C,E_C],[s_D,E_D]\\,],\n$$\n测试用例按 A、B、C、D 的顺序排列，且不含多余的空格或文本。例如，使用占位符值的输出将如下所示\n$$\n[[1,0.0],[1,0.0],[1,0.0],[1,0.0]].\n$$", "solution": "对问题陈述进行验证。\n\n**第 1 步：提取已知条件**\n- **控制方程**：用于放射性衰变的两个非耦合常微分方程(ODE)组：\n$$\n\\frac{dc_f}{dt} = -\\lambda_f\\,c_f,\\qquad \\frac{dc_s}{dt} = -\\lambda_s\\,c_s\n$$\n- **初始条件**：$c_f(0)=c_{f,0}$ 和 $c_s(0)=c_{s,0}$。\n- **参数**：$c_f$ 和 $c_s$ 是浓度。$\\lambda_f$ 和 $\\lambda_s$ 是正的衰变率，且满足 $\\lambda_f  \\lambda_s$。\n- **精确解**：$c_f(t)=c_{f,0}\\,e^{-\\lambda_f t}$ 和 $c_s(t)=c_{s,0}\\,e^{-\\lambda_s t}$。\n- **数值方法**：后向欧拉(BE)法，使用恒定时间步长 $h$ 从 $t=0$ 到 $t=T$。$N=T/h$ 是整数。\n- **待计算量**：对于慢同位素组分($c_s$)：\n    1. 稳定性指标 $s$：如果每步放大因子的绝对值小于或等于 1，则 $s=1$；否则 $s=0$。\n    2. 在最终时间 $T$ 时的绝对误差 $E=\\lvert c_s^{\\text{BE}}(T)-c_s^{\\text{exact}}(T)\\rvert$。\n- **测试用例**：\n    - 测试 A：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(10, 0.1, 1, 1, 1, 5)$\n    - 测试 B：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(50, 0.2, 2, 2, 10, 50)$\n    - 测试 C：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(1, 0.01, 3, 1, 100, 100)$\n    - 测试 D：$(\\lambda_f,\\lambda_s,c_{f,0},c_{s,0},h,T)=(5, 10^{-6}, 1, 1.5, 10^{6}, 10^{6})$\n\n**第 2 步：使用提取的已知条件进行验证**\n该问题具有科学依据，用一种经典的数值方法（后向欧拉法）对一个标准的物理过程（放射性衰变）进行建模。该问题是适定的、客观的且自洽的。所有必要的数据都已提供，并且没有内部矛盾。对于每个测试用例，比率 $T/h$ 诚如所述是一个整数。该问题的表述是常微分方程数值分析中的一个标准练习。注意到存在快速衰变同位素的参数($c_f$, $\\lambda_f$)，但由于该常微分方程组是非耦合的，这些参数与所要求的慢速衰变同位素($c_s$)的计算无关。这不构成缺陷，而是为了检验对该系统的正确理解。\n\n**第 3 步：结论与行动**\n该问题有效。将提供解答。\n\n该问题要求分析由以下 ODE 控制的慢衰变同位素浓度 $c_s$：\n$$\n\\frac{dc_s}{dt} = -\\lambda_s c_s\n$$\n初始条件为 $c_s(0) = c_{s,0}$。与快速衰变同位素 $c_f$ 相关的参数对于此任务是无关紧要的，因为两个 ODE 是非耦合的。\n\n我们将应用后向欧拉法。设 $c_s^n$ 是在时间 $t_n = n h$ 处对 $c_s(t_n)$ 的数值近似，其中 $h$ 是时间步长。该 ODE 的后向欧拉离散化形式为：\n$$\n\\frac{c_s^{n+1} - c_s^n}{h} = -\\lambda_s c_s^{n+1}\n$$\n为了找到更新规则，我们求解 $c_s^{n+1}$：\n$$\nc_s^{n+1}(1 + h\\lambda_s) = c_s^n\n$$\n$$\nc_s^{n+1} = \\left(\\frac{1}{1 + h\\lambda_s}\\right) c_s^n\n$$\n此方程定义了从一个时间层级到下一个时间层级的单步映射。\n\n**1. 稳定性指标 $s$**\n每步放大因子 $g$ 是将上一步的解相乘以获得当前步解的项：\n$$\ng = \\frac{1}{1 + h\\lambda_s}\n$$\n该方法的稳定性取决于此因子的大小 $|g|$。问题陈述中说明，如果 $|g| \\le 1$，则稳定性指标 $s$ 为 $1$，否则为 $0$。\n根据问题的已知条件，衰变率 $\\lambda_s$ 是正的，时间步长 $h$ 也是正的。因此，它们的乘积 $h\\lambda_s$ 严格为正。这意味着：\n$$\n1 + h\\lambda_s  1\n$$\n$$\n0  \\frac{1}{1 + h\\lambda_s}  1\n$$\n因此，放大因子 $g$ 满足 $0  g  1$，这意味着无论如何选择 $h  0$ 和 $\\lambda_s  0$，其绝对值 $|g|$ 始终小于 1。这是后向欧拉法应用于此类问题时众所周知的 A-稳定性属性。因此，对于所有指定的测试用例，都满足稳定性条件，稳定性指标 $s$ 将为 1。\n\n**2. 绝对误差 $E$**\n为了求得最终时间 $T$ 的数值解，我们将单步映射应用 $N$ 次，其中 $N=T/h$。从初始条件 $c_s^0 = c_{s,0}$ 开始，我们得到一个几何级数：\n$$\nc_s^N = g^N c_s^0 = \\left(\\frac{1}{1 + h\\lambda_s}\\right)^N c_{s,0}\n$$\n因此，$t=T$ 时的数值解为：\n$$\nc_s^{\\text{BE}}(T) = c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h}\n$$\n$t=T$ 时的精确解由下式给出：\n$$\nc_s^{\\text{exact}}(T) = c_{s,0} e^{-\\lambda_s T}\n$$\n绝对误差 $E$ 是在 $t=T$ 时数值解与精确解之差的绝对值：\n$$\nE = \\lvert c_s^{\\text{BE}}(T) - c_s^{\\text{exact}}(T) \\rvert = \\left| c_{s,0} \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - c_{s,0} e^{-\\lambda_s T} \\right|\n$$\n由于在所有测试用例中给出的 $c_{s,0}$ 都是正的，我们可以写成：\n$$\nE = c_{s,0} \\left| \\left(\\frac{1}{1 + h\\lambda_s}\\right)^{T/h} - e^{-\\lambda_s T} \\right|\n$$\n对每个测试用例实施这些公式，以计算所需的配对 $[s, E]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes stability indicator and absolute error for a radioactive decay\n    model using the Backward Euler method for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Format: (lambda_f, lambda_s, c_f0, c_s0, h, T)\n    test_cases = [\n        (10.0, 0.1, 1.0, 1.0, 1.0, 5.0),          # Test A\n        (50.0, 0.2, 2.0, 2.0, 10.0, 50.0),         # Test B\n        (1.0, 0.01, 3.0, 1.0, 100.0, 100.0),       # Test C\n        (5.0, 1e-6, 1.0, 1.5, 1e6, 1e6),           # Test D\n    ]\n\n    # Store formatted results for each test case\n    formatted_results = []\n    \n    for case in test_cases:\n        # Unpack parameters. The fast-decaying isotope parameters (lambda_f, c_f0)\n        # are not used as the system is uncoupled.\n        _lambda_f, lambda_s, _c_f0, c_s0, h, T = case\n\n        # 1. Compute the stability indicator s\n        # The amplification factor for Backward Euler on dc/dt = -lambda*c is g = 1 / (1 + h*lambda).\n        # Since lambda_s > 0 and h > 0, g is always between 0 and 1.\n        # Thus, the method is unconditionally stable, and s=1 for all cases.\n        amplification_factor = 1.0 / (1.0 + h * lambda_s)\n        s = 1 if np.abs(amplification_factor) = 1.0 else 0\n\n        # 2. Compute the absolute error E at time T\n        \n        # The problem statement guarantees N = T/h is an integer.\n        N = int(T / h)\n\n        # Numerical solution using Backward Euler after N steps\n        c_s_be = c_s0 * (amplification_factor ** N)\n\n        # Exact solution at time T\n        c_s_exact = c_s0 * np.exp(-lambda_s * T)\n\n        # Absolute error\n        error_E = np.abs(c_s_be - c_s_exact)\n        \n        # Format the result pair as a string \"[s,E]\"\n        formatted_results.append(f\"[{s},{error_E}]\")\n\n    # Final print statement in the exact required format.\n    # e.g., [[s_A,E_A],[s_B,E_B],...]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2372906"}, {"introduction": "后向欧拉法的稳定性源于其固有的数值耗散特性，这有助于抑制高频振荡。然而，这一特性对于需要精确保持能量等物理量的保守系统（如哈密顿系统）而言，却是一个缺点。本练习将使用一个简单的单摆模型，来演示后向欧拉法如何人为地耗散系统总能量，从而强调了选择与问题物理特性相匹配的数值方法的重要性。[@problem_id:2372896]", "problem": "考虑一个被建模为哈密顿系统的单摆，其广义位置为 $ \\theta $（以弧度为单位的角度），正则动量为 $ p $（角动量）。设质量 $ m $ 的单位为千克，长度 $ \\ell $ 的单位为米，重力加速度 $ g $ 的单位为米每平方秒，时间 $ t $ 的单位为秒。从哈密顿力学推导出的连续时间运动方程为\n$$\n\\frac{d\\theta}{dt} \\;=\\; \\frac{p}{m\\,\\ell^2}, \n\\qquad\n\\frac{dp}{dt} \\;=\\; -\\,m\\,g\\,\\ell\\,\\sin(\\theta),\n$$\n其哈密顿量（总能量）为\n$$\nH(\\theta,p) \\;=\\; \\frac{p^2}{2\\,m\\,\\ell^2} \\;+\\; m\\,g\\,\\ell\\,\\bigl(1-\\cos(\\theta)\\bigr).\n$$\n使用固定时间步长 $ h  0 $ 的后向欧拉时间离散化方法，从给定的初始条件 $ \\theta(0)=\\theta_0 $ 和 $ p(0)=p_0 $ 开始，将解从 $ t=0 $ 推进到 $ t=T $。对于下述每个测试用例，对系统进行数值积分，计算初始能量 $ H(\\theta_0,p_0) $ 和最终能量 $ H(\\theta(T),p(T)) $，并报告能量比\n$$\nR \\;=\\; \\frac{H(\\theta(T),p(T))}{H(\\theta_0,p_0)}.\n$$\n角度必须以弧度为单位。能量必须以焦耳（$ \\mathrm{J} $）为单位计算。您的程序必须输出四舍五入到六位小数的比值 $ R $。\n\n测试套件：\n- 用例 $ 1 $ (正常路径): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=9.81\\,\\mathrm{m/s^2} $, $ \\theta_0=1.0\\,\\mathrm{rad} $, $ p_0=0.0\\,\\mathrm{kg\\,m^2/s} $, $ h=0.1\\,\\mathrm{s} $, $ T=10.0\\,\\mathrm{s} $。\n- 用例 $ 2 $ (更粗的步长，更强的耗散): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=9.81\\,\\mathrm{m/s^2} $, $ \\theta_0=1.0\\,\\mathrm{rad} $, $ p_0=0.0\\,\\mathrm{kg\\,m^2/s} $, $ h=0.5\\,\\mathrm{s} $, $ T=10.0\\,\\mathrm{s} $。\n- 用例 $ 3 $ (零重力边界情况): $ m=1\\,\\mathrm{kg} $, $ \\ell=1\\,\\mathrm{m} $, $ g=0.0\\,\\mathrm{m/s^2} $, $ \\theta_0=0.3\\,\\mathrm{rad} $, $ p_0=0.5\\,\\mathrm{kg\\,m^2/s} $, $ h=0.4\\,\\mathrm{s} $, $ T=8.0\\,\\mathrm{s} $。\n\n要求的最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，结果按测试用例的顺序排列，例如 $ [R_1,R_2,R_3] $，其中每个 $ R_k $ 是一个四舍五入到六位小数的浮点数。", "solution": "所给问题是计算力学中一个标准的初值问题，要求对一个哈密顿系统进行数值积分。该问题在科学上是合理的、适定的，并包含了获得唯一解所需的所有信息。我的验证结论是该问题有效。我们将继续进行解的推导和实现。\n\n该系统描述了一个单摆，其广义位置 $\\theta$ 和正则动量 $p$ 的运动方程为：\n$$\n\\frac{d\\theta}{dt} = \\frac{p}{m\\ell^2}\n$$\n$$\n\\frac{dp}{dt} = -mg\\ell\\sin(\\theta)\n$$\n该系统可以写成紧凑形式 $\\frac{d\\mathbf{y}}{dt} = \\mathbf{f}(\\mathbf{y})$，其中状态向量为 $\\mathbf{y} = [\\theta, p]^T$，向量场 $\\mathbf{f}$ 由下式给出：\n$$\n\\mathbf{f}(\\mathbf{y}) = \\begin{bmatrix} p / (m\\ell^2) \\\\ -mg\\ell\\sin(\\theta) \\end{bmatrix}\n$$\n\n任务是采用后向欧拉法，这是一种一阶隐式数值积分格式。对于时间步长 $h  0$，第 $n+1$ 步的状态由第 $n$ 步的状态通过以下关系式确定：\n$$\n\\mathbf{y}_{n+1} = \\mathbf{y}_n + h \\mathbf{f}(\\mathbf{y}_{n+1})\n$$\n其中 $\\mathbf{y}_n \\approx \\mathbf{y}(t_n)$ 且 $t_n = n h$。\n\n将此格式应用于单摆系统，得到一对关于未知状态 $\\mathbf{y}_{n+1} = [\\theta_{n+1}, p_{n+1}]^T$ 的耦合非线性代数方程组：\n$$\n\\theta_{n+1} = \\theta_n + h \\left( \\frac{p_{n+1}}{m\\ell^2} \\right) \\quad (1)\n$$\n$$\np_{n+1} = p_n - h \\, mg\\ell \\sin(\\theta_{n+1}) \\quad (2)\n$$\n\n为了在每个时间步求解这个方程组，我们先将其解耦。我们重排方程 ($1$)，将 $p_{n+1}$ 表示为 $\\theta_{n+1}$ 的函数：\n$$\np_{n+1} = \\frac{m\\ell^2}{h} (\\theta_{n+1} - \\theta_n)\n$$\n然后将此表达式代入方程 ($2$)：\n$$\n\\frac{m\\ell^2}{h} (\\theta_{n+1} - \\theta_n) = p_n - h \\, mg\\ell \\sin(\\theta_{n+1})\n$$\n通过将所有项移到一边，我们构建了一个关于 $\\theta_{n+1}$ 的标量求根问题。令 $x = \\theta_{n+1}$，问题就变为求解函数 $F(x) = 0$ 的根，其中：\n$$\nF(x) \\equiv x - \\theta_n - \\frac{h p_n}{m\\ell^2} + \\frac{h^2 g}{\\ell} \\sin(x) = 0\n$$\n这是一个必须通过数值方法求解的超越方程。我们将使用 Newton-Raphson 方法，它是一个由下式定义的迭代过程：\n$$\nx_{k+1} = x_k - \\frac{F(x_k)}{F'(x_k)}\n$$\n其中 $k$ 是迭代指数，$F'(x)$ 是 $F(x)$ 关于 $x$ 的导数：\n$$\nF'(x) = 1 + \\frac{h^2 g}{\\ell} \\cos(x)\n$$\n一个稳健的迭代初始猜测值是前一个时间步的值，即 $x_0 = \\theta_n$。一旦获得了 $\\theta_{n+1}$ 的收敛解，就可以使用方程 ($2$) 直接计算出相应的动量 $p_{n+1}$：\n$$\np_{n+1} = p_n - h \\, mg\\ell \\sin(\\theta_{n+1})\n$$\n该过程重复 $N = \\text{round}(T/h)$ 个时间步，以将解从 $t=0$ 时的初始状态 $(\\theta_0, p_0)$ 推进到 $t=T$ 时的最终状态 $(\\theta(T), p(T))$。\n\n最后一步是计算能量比 $R$。系统的总能量由哈密顿量给出：\n$$\nH(\\theta,p) = \\frac{p^2}{2m\\ell^2} + mg\\ell\\bigl(1-\\cos(\\theta)\\bigr)\n$$\n我们计算初始能量 $H_0 = H(\\theta_0, p_0)$ 和最终能量 $H_T = H(\\theta(T), p(T))$。然后比值为 $R = H_T / H_0$。\n\n众所周知，对于哈密顿系统，后向欧拉法是数值耗散的，这意味着计算出的能量不守恒，通常会随时间推移而减少。对于更大的时间步长 $h$，这种效应更为显著。在 $g=0$ 的特殊情况（用例 $3$）下，系统动力学变为线性的，后向欧拉法能提供精确解，从而实现完美的能量守恒，即 $R=1$。这可以作为对实现的一种验证。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import root_scalar\n\ndef solve():\n    \"\"\"\n    Solves the pendulum dynamics using backward Euler and calculates the energy ratio.\n    \"\"\"\n\n    # Test cases: (m, l, g, theta0, p0, h, T)\n    test_cases = [\n        # Case 1 (happy path)\n        (1.0, 1.0, 9.81, 1.0, 0.0, 0.1, 10.0),\n        # Case 2 (coarser step, stronger dissipation)\n        (1.0, 1.0, 9.81, 1.0, 0.0, 0.5, 10.0),\n        # Case 3 (boundary case with zero gravity)\n        (1.0, 1.0, 0.0, 0.3, 0.5, 0.4, 8.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        m, l, g, theta0, p0, h, T = case\n        \n        # Define the Hamiltonian function to compute energy\n        def hamiltonian(theta, p, m_val, l_val, g_val):\n            kinetic_energy = p**2 / (2 * m_val * l_val**2)\n            potential_energy = m_val * g_val * l_val * (1 - np.cos(theta))\n            return kinetic_energy + potential_energy\n\n        # Calculate initial energy\n        H0 = hamiltonian(theta0, p0, m, l, g)\n\n        # Initialize state variables\n        theta_n = theta0\n        p_n = p0\n        \n        # Determine the number of time steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # Define the nonlinear function F(x) = 0 to be solved for theta_{n+1}, where x = theta_{n+1}\n            # F(x) = x - theta_n - (h * p_n) / (m * l**2) + (h**2 * g / l) * sin(x)\n            \n            # Pre-compute constants for the function and its derivative\n            const1 = (h**2 * g) / l\n            const2 = (h * p_n) / (m * l**2)\n            \n            # Define F and its derivative F' for the root-finding algorithm\n            def F(x):\n                return x - theta_n - const2 + const1 * np.sin(x)\n\n            def F_prime(x):\n                return 1 + const1 * np.cos(x)\n            \n            # Use Newton's method from SciPy's root_scalar to find theta_{n+1}\n            # The initial guess is the value from the previous step.\n            sol = root_scalar(F, x0=theta_n, fprime=F_prime, method='newton', xtol=1e-12, rtol=1e-12)\n            theta_next = sol.root\n            \n            # Calculate p_{n+1} using the newly found theta_{n+1}\n            p_next = p_n - h * m * g * l * np.sin(theta_next)\n            \n            # Update the state for the next iteration\n            theta_n = theta_next\n            p_n = p_next\n\n        # The final state corresponds to time T\n        theta_T = theta_n\n        p_T = p_n\n        \n        # Calculate the final energy\n        HT = hamiltonian(theta_T, p_T, m, l, g)\n        \n        # Calculate the energy ratio. Handle the case H0=0 to avoid division by zero.\n        if H0 == 0:\n            ratio = 1.0 if HT == 0 else np.inf\n        else:\n            ratio = HT / H0\n            \n        results.append(round(ratio, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372896"}]}