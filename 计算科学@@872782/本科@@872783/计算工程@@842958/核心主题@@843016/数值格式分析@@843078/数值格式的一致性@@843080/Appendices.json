{"hands_on_practices": [{"introduction": "在计算科学中，验证代码的正确性是至关重要的一步。“人造解方法”（Method of Manufactured Solutions, MMS）是验证数值格式收敛阶的黄金标准。这个练习将指导你完成MMS的整个流程：选择一个平滑的函数作为“人造解”，推导出相应的源项和边界条件，然后通过在一系列加密网格上求解问题并测量误差来数值地验证你的离散格式是否达到了理论精度 [@problem_id:2380147]。", "problem": "你需要编写一个完整的程序，通过制造解方法 (MMS) 来数值验证一个有限差分格式的相容阶。考虑以下针对偏微分方程 (PDE) 及其一维模拟的边值问题，这些问题都定义在单位域上。将二维空间域表示为 $\\Omega = (0,1) \\times (0,1)$，一维空间域表示为 $(0,1)$。控制方程和边界条件如下：\n\n- 在二维情况下：求 $u:\\overline{\\Omega}\\to\\mathbb{R}$ 使得\n  $$\n  -\\Delta u = f \\ \\text{ in } \\ \\Omega, \n  \\quad \n  u = g \\ \\text{ on } \\ \\partial\\Omega,\n  $$\n  其中 $\\Delta$ 是拉普拉斯算子。\n\n- 在一维情况下：求 $u:[0,1]\\to\\mathbb{R}$ 使得\n  $$\n  -u'' = f \\ \\text{ in } \\ (0,1), \n  \\quad \n  u(0)=g_0, \\ u(1)=g_1.\n  $$\n\n对于下面的每个测试用例，都给出了一个光滑的制造解 $u_\\star$。通过将 $u_\\star$ 代入连续算子来定义源项 $f$，即在二维情况下使用 $f = -\\Delta u_\\star$，在一维情况下使用 $f = -u_\\star''$。并根据 $\\partial\\Omega$ 上的 $g=u_\\star$（在一维情况下为 $g_0=u_\\star(0)$ 和 $g_1=u_\\star(1)$）来定义边界数据。在网格尺寸为 $h$ 的均匀网格上，使用标准的二阶中心有限差分格式：\n- 在二维情况下，对于间距为 $h$ 的内部网格点 $(i,j)$，离散算子为\n  $$\n  \\left(-\\Delta_h u\\right)_{i,j} \n  = \\frac{4 u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2}.\n  $$\n- 在一维情况下，对于间距为 $h$ 的内部网格点 $i$，离散算子为\n  $$\n  \\left(-\\delta_{xx} u\\right)_{i} \n  = \\frac{2 u_i - u_{i+1} - u_{i-1}}{h^2}.\n  $$\n\n对于每个测试用例，对一系列加密的网格求解相应的线性系统，计算网格误差（数值解与 $u_\\star$ 在内部节点上的限制之差），并测量离散二范数（离散 $L^2$ 范数）。其定义如下：\n- 在二维情况下，对于内部误差值 $e_{i,j}$：\n  $$\n  \\|e\\|_{2,h} = \\left( h^2 \\sum_{i=1}^{N} \\sum_{j=1}^{N} e_{i,j}^2 \\right)^{1/2}.\n  $$\n- 在一维情况下，对于内部误差值 $e_{i}$：\n  $$\n  \\|e\\|_{2,h} = \\left( h \\sum_{i=1}^{N} e_{i}^2 \\right)^{1/2}.\n  $$\n\n令 $h_k$ 表示所用的网格尺寸，$E_k$ 表示相应的误差的离散二范数。将每个测试用例的观测到的相容阶 $p$ 定义为使下式\n$$\n\\sum_{k} \\left( \\log(E_k) - \\alpha - p \\log(h_k) \\right)^2\n$$\n对实数 $\\alpha$ 和 $p$ 最小化的值。报告这个 $p$ 值。\n\n测试套件（每个项目符号是一个独立处理的测试用例；设 $h = 1/(N+1)$）：\n- 测试用例 1 (二维，三角函数制造解):\n  - 制造解: $u_\\star(x,y) = \\sin(\\pi x)\\sin(\\pi y)$.\n  - 强迫项: $f(x,y) = -\\Delta u_\\star(x,y) = 2\\pi^2 \\sin(\\pi x)\\sin(\\pi y)$.\n  - 边界数据: 在 $\\partial\\Omega$ 上 $g(x,y) = u_\\star(x,y)$。\n  - 内部网格尺寸: $N \\in \\{8,16,32,64\\}$.\n\n- 测试用例 2 (二维，多项式制造解):\n  - 定义 $p(x) = x^2(1-x)^2$ 和 $p''(x) = 2 - 12x + 12x^2$。\n  - 制造解: $u_\\star(x,y) = p(x)\\,p(y)$.\n  - 强迫项: $f(x,y) = -\\Delta u_\\star(x,y) = -\\big(p''(x)p(y) + p(x)p''(y)\\big)$.\n  - 边界数据: 在 $\\partial\\Omega$ 上 $g(x,y) = u_\\star(x,y)$。\n  - 内部网格尺寸: $N \\in \\{10,20,40,80\\}$.\n\n- 测试用例 3 (一维，三角函数制造解):\n  - 制造解: $u_\\star(x) = \\sin(5\\pi x)$.\n  - 强迫项: $f(x) = -u_\\star''(x) = 25\\pi^2 \\sin(5\\pi x)$.\n  - 边界数据: $u(0) = u_\\star(0)$ 和 $u(1) = u_\\star(1)$。\n  - 内部网格尺寸: $N \\in \\{16,32,64,128\\}$.\n\n你的程序必须使用上述定义计算这三个测试用例的观测阶 $p$，并生成单行输出，其中包含三个结果，形式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$\\texttt{[2.000000,2.000000,2.000000]}$）。不应打印任何额外文本。", "solution": "所呈现的问题是偏微分方程数值方法验证中的一个标准练习，具体使用了制造解方法 (MMS)。该问题定义明确、科学上可靠且内部一致。解决该问题所需的所有数据、方程和定义均已提供。因此，我们着手求解。\n\n目标是数值确定应用于泊松边值问题的标准有限差分格式的相容阶 $p$。对于一个 $p$ 阶格式，离散化误差 $E$ 预计会随着网格尺寸 $h$ 按关系 $E \\approx C h^p$ 变化，其中 $C$ 是一个取决于制造解但与 $h$ 无关的常数。对该关系取自然对数，得到：\n$$ \\ln(E) \\approx \\ln(C) + p \\ln(h) $$\n这个方程揭示了 $\\ln(E)$ 和 $\\ln(h)$ 之间的线性关系，其斜率即为相容阶 $p$。问题要求我们通过对一系列加密网格上求解问题所获得的一组数据点 $(\\ln(h_k), \\ln(E_k))$ 进行线性最小二乘回归，来计算几个测试用例的 $p$ 值。$p$ 值是使残差平方和 $\\sum_{k} ( \\ln(E_k) - \\alpha - p \\ln(h_k) )^2$ 最小化的值，其中 $\\alpha = \\ln(C)$。\n\n对于每个测试用例，我们必须求解一个形如 $A \\mathbf{u}_h = \\mathbf{b}_h$ 的线性系统，该系统源于控制泊松方程的有限差分离散。这里，$\\mathbf{u}_h$ 是内部网格节点上未知解值的向量。\n\n**一维情况**\n\n控制方程为 $-u'' = f$ on $(0,1)$，边界条件为 $u(0)=g_0$ 和 $u(1)=g_1$。我们使用一个有 $N$ 个内部点 $x_i = i h$（$i=1, \\dots, N$）的均匀网格，其中网格尺寸为 $h=1/(N+1)$。在内部节点 $x_i$ 处，负二阶导数的二阶中心差分近似为：\n$$ (-\\delta_{xx} u)_i = \\frac{-u_{i-1} + 2u_i - u_{i+1}}{h^2} = f(x_i) $$\n这组针对 $N$ 个未知数 $u_1, \\dots, u_N$ 的 $N$ 个方程构成了线性系统 $A \\mathbf{u}_h = \\mathbf{b}_h$。矩阵 $A$ 是一个 $N \\times N$ 的矩阵，代表离散算子 $(1/h^2)(-\\delta_{xx})$：\n$$ A = \\frac{1}{h^2} \n\\begin{pmatrix}\n2   -1            \\\\\n-1   2  -1          \\\\\n    \\ddots  \\ddots  \\ddots \\\\\n       -1  2  -1 \\\\\n          -1  2\n\\end{pmatrix}\n$$\n右端向量 $\\mathbf{b}_h$ 包含了源项 $f$ 和边界条件。对于第一个内部节点（$i=1$），方程为 $(-u_0 + 2u_1 - u_2)/h^2 = f(x_1)$。由于 $u_0 = g_0$ 是已知的，我们将其移到右边：$(2u_1 - u_2)/h^2 = f(x_1) + g_0/h^2$。类似地，对于最后一个内部节点（$i=N$），我们有 $(-u_{N-1} + 2u_N)/h^2 = f(x_N) + g_{N+1}/h^2$，其中 $u_{N+1} = g_1$。对于给定的测试用例，制造解使得边界条件是齐次的，即 $g_0=g_1=0$。因此，右端向量简化为 $\\mathbf{b}_h = (f(x_1), f(x_2), \\dots, f(x_N))^T$。\n\n**二维情况**\n\n控制方程为 $-\\Delta u = f$ on $\\Omega=(0,1)\\times(0,1)$。内部网格点为 $(x_i, y_j)$，其中 $x_i=ih, y_j=jh$，$i,j=1, \\dots, N$，且 $h=1/(N+1)$。在内部节点 $(i,j)$ 处，负拉普拉斯算子的 5 点模板为：\n$$ (-\\Delta_h u)_{i,j} = \\frac{4u_{i,j} - u_{i+1,j} - u_{i-1,j} - u_{i,j+1} - u_{i,j-1}}{h^2} = f(x_i, y_j) $$\n这给出了一个关于 $N^2$ 个未知数的 $N^2$ 个线性方程组。未知数值 $u_{i,j}$ 被展开成一个长度为 $N^2$ 的单一向量 $\\mathbf{u}_h$。采用行主序，其中索引 $k$ 通过 $k = jN+i$（对于 $i,j=0,\\dots,N-1$）对应于网格点 $(i,j)$，系统矩阵 $A$ 具有块三对角结构。它可以使用克罗内克积 ($\\otimes$) 构建：\n$$ A = \\frac{1}{h^2} (I_N \\otimes T_N + T_N \\otimes I_N) $$\n其中 $T_N$ 是 $N \\times N$ 的一维离散化矩阵（即前面展示的三对角矩阵，不含 $1/h^2$ 缩放因子），$I_N$ 是 $N \\times N$ 的单位矩阵。最终得到的矩阵 $A$ 的尺寸为 $N^2 \\times N^2$。与一维情况一样，为二维测试用例提供的制造解导致齐次狄利克雷边界条件（在 $\\partial\\Omega$ 上 $u=0$）。因此，右端向量 $\\mathbf{b}_h$ 仅由内部网格点上的源项 $f(x_i, y_j)$ 的值组成，并按相同的行主序展开。\n\n**误差计算和阶估计**\n\n在求解线性系统 $A \\mathbf{u}_h = \\mathbf{b}_h$ 得到数值解向量 $\\mathbf{u}_h$ 后，我们计算误差向量 $\\mathbf{e}_h = \\mathbf{u}_h - \\mathbf{u}_{\\star,h}$，其中 $\\mathbf{u}_{\\star,h}$ 是在内部网格节点上计算的制造解向量。使用问题陈述中提供的公式，为每个网格尺寸 $h_k$ 计算误差的离散 $L^2$ 范数 $E_k = \\|\\mathbf{e}_{h_k}\\|_{2,h_k}$。最后，使用数据对 $(\\ln(h_k), \\ln(E_k))$ 的集合进行线性回归，以找到斜率 $p$，它就是我们对相容阶的估计。\n\n该过程对三个测试用例中的每一个都进行了实施。在所有情况下，矩阵 $A$ 都是稀疏、对称和正定的，因此我们采用高效的稀疏线性代数程序来求解该系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity, kron\nfrom scipy.sparse.linalg import spsolve\n\ndef compute_order(dim, u_star, f, N_values):\n    \"\"\"\n    Computes the observed order of consistency for a given problem configuration.\n\n    Args:\n        dim (int): The spatial dimension of the problem (1 or 2).\n        u_star (callable): The manufactured solution function.\n        f (callable): The corresponding source term function.\n        N_values (list of int): A list of interior grid sizes for the convergence study.\n\n    Returns:\n        float: The computed order of consistency.\n    \"\"\"\n    h_list, E_list = [], []\n\n    for N in N_values:\n        h = 1.0 / (N + 1)\n\n        if dim == 1:\n            # 1D Solver\n            # Grid points (interior)\n            x_coords = np.linspace(h, 1 - h, N)\n\n            # Assemble matrix A for -u'' (scaled by 1/h^2)\n            # A is a tridiagonal matrix: [-1, 2, -1]\n            A = (1 / h**2) * diags([-1, 2, -1], [-1, 0, 1], shape=(N, N), format='csr')\n\n            # Assemble RHS vector b.\n            # For the given test cases, boundary conditions are homogeneous.\n            b = f(x_coords)\n            \n            # Solve the linear system\n            u_num = spsolve(A, b)\n\n            # Compute error\n            u_exact = u_star(x_coords)\n            error_vec = u_num - u_exact\n            error_norm = np.sqrt(h * np.sum(error_vec**2))\n\n        elif dim == 2:\n            # 2D Solver\n            # Assemble matrix A for -Delta_h using Kronecker products\n            # This assumes C-style (row-major) flattening of the grid.\n            T_N = diags([-1, 2, -1], [-1, 0, 1], shape=(N, N), format='csr')\n            I_N = identity(N, format='csr')\n            A = (1 / h**2) * (kron(I_N, T_N) + kron(T_N, I_N))\n            \n            # Create grid and assemble RHS vector b\n            x_coords = np.linspace(h, 1 - h, N)\n            y_coords = np.linspace(h, 1 - h, N)\n            # 'xy' indexing is consistent with C-style flattening.\n            X, Y = np.meshgrid(x_coords, y_coords, indexing='xy')\n            \n            # Boundary conditions are homogeneous for all test cases.\n            F = f(X, Y)\n            b = F.flatten()  # Default is 'C' order (row-major)\n            \n            # Solve the linear system\n            u_flat = spsolve(A, b)\n            u_num = u_flat.reshape((N, N)) # Reshape with 'C' order\n\n            # Compute error\n            u_exact = u_star(X, Y)\n            error_matrix = u_num - u_exact\n            error_norm = np.sqrt(h**2 * np.sum(error_matrix**2))\n        else:\n            raise ValueError(\"Dimension must be 1 or 2.\")\n            \n        h_list.append(h)\n        E_list.append(error_norm)\n    \n    # Perform linear regression on log-log data to find the order p\n    log_h = np.log(np.array(h_list))\n    log_E = np.log(np.array(E_list))\n    \n    # np.polyfit finds coefficients [p, alpha] for log(E) = p*log(h) + alpha\n    p, _ = np.polyfit(log_h, log_E, 1)\n    \n    return p\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"dim\": 2,\n            \"u_star\": lambda x, y: np.sin(np.pi * x) * np.sin(np.pi * y),\n            \"f\": lambda x, y: 2 * np.pi**2 * np.sin(np.pi * x) * np.sin(np.pi * y),\n            \"N_values\": [8, 16, 32, 64]\n        },\n        {\n            \"dim\": 2,\n            \"u_star\": lambda x, y: (x**2 * (1 - x)**2) * (y**2 * (1 - y)**2),\n            \"f\": lambda x, y: -((12*x**2 - 12*x + 2) * (y**2 * (1 - y)**2) + \\\n                                (x**2 * (1 - x)**2) * (12*y**2 - 12*y + 2)),\n            \"N_values\": [10, 20, 40, 80]\n        },\n        {\n            \"dim\": 1,\n            \"u_star\": lambda x: np.sin(5 * np.pi * x),\n            \"f\": lambda x: 25 * np.pi**2 * np.sin(5 * np.pi * x),\n            \"N_values\": [16, 32, 64, 128]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        p = compute_order(case[\"dim\"], case[\"u_star\"], case[\"f\"], case[\"N_values\"])\n        results.append(p)\n\n    # Format output as specified: a list of floats with 6 decimal places.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "2380147"}, {"introduction": "理论与实践的脱节是数值模拟中常见的问题。假设你的代码使用了理论上二阶精度的内部格式，但数值实验（如“人造解方法”测试）却显示出明显的一阶收敛行为。这个练习将让你扮演一个“数值侦探”，通过分析不同可能性，找出导致全局精度从 $O(h^2)$ 意外下降到 $O(h)$ 的根本原因 [@problem_id:2380129]。", "problem": "考虑区间 $[0,1]$ 上的标量边值问题：\n$$-u''(x)=f(x),\\quad x\\in(0,1),$$\n其混合边界条件为\n$$u'(0)=\\alpha,\\qquad u(1)=\\beta,$$\n其中 $f$、$\\alpha$ 和 $\\beta$ 是给定数据，且精确解 $u$ 假定在 $[0,1]$ 上是光滑的（例如，$u\\in C^{\\infty}([0,1])$）。在一个步长为 $h=1/N$ 的均匀网格 $x_i=ih$ 上，一个标准的有限差分格式在内部节点处使用 $u''$ 的中心二阶近似（$h$ 的 $2$ 阶精度），并通过将边界未知量设为 $\\beta$ 来精确施加 $x=1$ 处的狄利克雷边界条件。\n\n严格的分析已经证明，如果边界处理是 $2$ 阶的并且格式是稳定的，那么在最大范数下的全局误差表现为 $O(h^2)$。然而，对于光滑的构造解，在不断加密的均匀网格上进行的数值实验却显示出明显的 $O(h)$ 收敛率（在误差对 $h$ 的双对数图上，斜率约为 $1$）。\n\n以下哪一个与边界相关的假设最能解释观测到的阶数下降至 $O(h)$ 的现象？\n\nA. $x=0$ 处的诺伊曼边界条件采用了例如 $(u_1-u_0)/h=\\alpha$ 的一阶向前差分进行离散化，因此边界上的局部截断误差是 $O(h)$，它主导了全局误差，从而导致了整体的 $O(h)$ 收敛。\n\nB. $x=1$ 处的狄利克雷边界值被精确施加为 $u_N=\\beta$，这必然会将任何内部中心差分模板的精度阶数降低一阶，从而导致 $O(h)$ 收敛。\n\nC. 均匀网格间距 $h$ 选择得太小，导致舍入误差占主导地位，并在测试范围内，在误差对 $h$ 的图上产生了接近 $1$ 的表观斜率。\n\nD. 无论边界如何处理，由于色散效应，对称的内部二阶差分模板在边界附近无法保持 $2$ 阶精度，因此整个格式内在的最高精度只有一阶，即 $O(h)$。", "solution": "分析一个数值格式的收敛性质需要严格地检验其相容性和稳定性。连接局部误差与全局误差的基本原理指出，对于一个稳定的格式，全局误差的阶数由计算域中任何地方（包括边界处）的局部截断误差（LTE）的最低阶数决定。\n\n该问题描述了微分方程 $-u''(x)=f(x)$ 在 $x \\in (0,1)$ 上的一个二阶有限差分格式。内部离散化采用标准的中心差分公式：\n$$\n-\\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2} = f_i, \\quad \\text{for } i \\in \\{1, 2, \\dots, N-1\\}\n$$\n其中 $u_i \\approx u(x_i)$。对于一个足够光滑的解 $u(x)$，在内部节点 $x_i$ 处的局部截断误差 $\\tau_i$ 可以通过将精确解代入数值公式得到：\n$$\n\\tau_i = -\\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} - f(x_i)\n$$\n利用 $u(x_{i-1})$ 和 $u(x_{i+1})$ 在 $x_i$ 处的泰勒级数展开，并利用 $-u''(x_i) = f(x_i)$ 这一事实，我们得到：\n$$\n\\tau_i = -\\left( u''(x_i) + \\frac{h^2}{12}u^{(4)}(x_i) + O(h^4) \\right) + u''(x_i) = -\\frac{h^2}{12}u^{(4)}(x_i) + O(h^4)\n$$\n因此，如问题所述，内部的局部截断误差是 $O(h^2)$。\n\n问题还指出，$x=1$ 处的狄利克雷边界条件 $u(1)=\\beta$ 是通过设置 $u_N = \\beta$ 来精确施加的。这个过程不引入任何截断误差。\n\n$O(h^2)$ 全局收敛的理论预期取决于整个格式（包括所有边界条件的实现）至少是二阶精确的。观测到的 $O(h)$ 收敛强烈暗示格式的相容性在某处被破坏，使其降至一阶。由于内部和 $x=1$ 处的狄利克雷边界都得到了足够精确的处理，阶数下降的来源必定是 $x=0$ 处诺伊曼边界条件 $u'(0)=\\alpha$ 的处理方式。\n\n现在我们来评估每个假设。\n\nA. $x=0$ 处的诺伊曼边界条件采用了例如 $(u_1-u_0)/h=\\alpha$ 的一阶向前差分进行离散化，因此边界上的局部截断误差是 $O(h)$，它主导了全局误差，从而导致了整体的 $O(h)$ 收敛。\n\n这个假设提出了使用如下近似：\n$$\n\\frac{u_1 - u_0}{h} = \\alpha\n$$\n为了求出这个边界近似的局部截断误差，我们将精确解 $u(x)$ 代入，并对 $u(x_1) = u(h)$ 在 $x_0=0$ 处进行泰勒展开：\n$$\nu(h) = u(0) + h u'(0) + \\frac{h^2}{2}u''(0) + O(h^3)\n$$\n重新整理以匹配有限差分的形式，得到：\n$$\n\\frac{u(h) - u(0)}{h} = u'(0) + \\frac{h}{2}u''(0) + O(h^2)\n$$\n边界上的局部截断误差 $\\tau_0$ 是导数的数值近似与精确值之间的差：\n$$\n\\tau_0 = \\left( \\frac{u(h) - u(0)}{h} \\right) - u'(0) = \\frac{h}{2}u''(0) + O(h^2)\n$$\n该局部截断误差是 $O(h)$ 阶的。因此，离散系统的整体局部截断误差是 $\\min(O(h^2)_{\\text{内部}}, O(h)_{\\text{边界}}) = O(h)$。对于一个稳定的格式，例如基于此椭圆问题的离散拉普拉斯算子的格式， $O(h)$ 的局部截断误差会导致 $O(h)$ 的全局误差。这个假设为观测到的阶数下降提供了直接且正确的解释。\n**结论：正确。**\n\nB. $x=1$ 处的狄利克雷边界值被精确施加为 $u_N=\\beta$，这必然会将任何内部中心差分模板的精度阶数降低一阶，从而导致 $O(h)$ 收敛。\n\n这个陈述是错误的。在边界节点上施加解的值是处理狄利克雷条件最标准、最精确的方法。它不引入任何截断误差。在相邻的内部节点 $i=N-1$ 处的中心差分模板是 $-\\frac{u_{N-2} - 2u_{N-1} + u_N}{h^2} = f_{N-1}$。代入已知值 $u_N = \\beta$ 不会改变差分模板的数学形式或其 $O(h^2)$ 的截断误差。精度得以保持。\n**结论：不正确。**\n\nC. 均匀网格间距 $h$ 选择得太小，导致舍入误差占主导地位，并在测试范围内，在误差对 $h$ 的图上产生了接近 $1$ 的表观斜率。\n\n这个假设误解了舍入误差的影响。总误差是离散误差和舍入误差之和。离散误差通常表现为 $C h^p$，而舍入误差会随着 $h$ 的减小而累积和增长，通常表现为 $D h^{-k}$（其中 $k>0$）。在误差对 $h$ 的双对数图上，离散误差表现为一条斜率为 $p$ 的直线。相比之下，舍入误差表现为一条斜率为 $-k$ 的直线。总误差曲线首先下降（离散误差主导区域），然后在 $h$ 非常小时开始上升（舍入误差主导区域）。问题描述的是，对于“不断加密的均匀网格”，斜率始终约为 $1$，这意味着误差始终是*减小*的，即 $E \\propto h^1$。这是一阶离散误差的特征，而不是舍入误差占主导的特征。\n**结论：不正确。**\n\nD. 无论边界如何处理，由于色散效应，对称的内部二阶差分模板在边界附近无法保持 $2$ 阶精度，因此整个格式内在的最高精度只有一阶，即 $O(h)$。\n\n这个陈述是根本错误的。在数值分析中，一个经典结论是，对于这个问题，二阶全局精度是*可以*实现的。这要求使用局部截断误差至少为 $O(h^2)$ 的方法来实现边界条件（或在某些特定的矩阵结构中为 $O(h)$，但边界需要高精度的原则仍然成立）。一种为诺伊曼条件实现 $O(h^2)$ 精度的常用技术是使用“虚拟点”（ghost point）和中心差分，即在边界节点 $x_0$ 应用差分模板，并用 $u'(0) = (u_1-u_{-1})/(2h)$ 来近似。声称格式“内在的最高精度只有一阶”是错误的。此外，“色散”是一个主要与双曲方程中的波传播现象相关的概念，而不是这个椭圆边值问题中阶数下降的主要机制。\n**结论：不正确。**\n\n综上所述，对于一个内部为 $O(h^2)$ 的格式，观测到 $O(h)$ 收敛的唯一科学上合理的解释是使用了对诺伊曼边界条件的一阶近似。", "answer": "$$\\boxed{A}$$", "id": "2380129"}, {"introduction": "为了具体地展示局部误差如何影响全局收敛性，这个练习要求你故意在边界上引入一个不一致的项。你将设计一个在内部节点为二阶精度，但在一个边界点上仅为零阶精度的格式。通过观察这个单一的、$O(1)$ 的边界误差如何污染整个解并最终导致全局误差在网格加密时停滞不前，你将深刻理解为什么格式在域内所有点（包括边界）都保持一致性是如此重要 [@problem_id:2380200]。", "problem": "考虑闭区间 $\\left[0,1\\right]$ 上的两点边值问题：\n$$\nu''(x) = f(x), \\quad x \\in (0,1), \\qquad u(0) = 0,\\quad u(1) = 0.\n$$\n设精确解为 $u(x) = \\sin(\\pi x)$，因此 $f(x) = -\\pi^2 \\sin(\\pi x)$。请设计一个在均匀网格上的离散数值格式，该格式在内部是二阶精确的，但在边界 $x=0$ 处通过强制执行以下条件而仅为零阶精确：\n- 使用具有 $N$ 个子区间、间距为 $h = 1/N$ 的均匀网格，节点为 $x_i = i h$，其中 $i=0,1,\\dots,N$。\n- 对于内部节点 $i=1,2,\\dots,N-1$，通过二阶中心差分来离散化 $u''(x_i)$，即要求\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i),\n$$\n其中 $U_i$ 是 $u(x_i)$ 的近似值。\n- 在 $x=1$ 处，施加精确的狄利克雷边界值 $U_N = u(1) = 0$。\n- 在 $x=0$ 处，通过以下方式施加一个故意的零阶精确边界值：\n$$\nU_0 = u(0) + b = b,\n$$\n其中 $b$ 是一个不依赖于 $h$ 的常数。\n\n您的程序必须为下面的每个测试配置计算离散解 $\\{U_i\\}_{i=0}^N$，并量化 $x=0$ 处的零阶边界对全局误差的影响。\n\n定义和要求：\n- 对于每个网格，定义全局最大范数误差\n$$\nE_\\infty(N,b) = \\max_{0 \\le i \\le N} \\left| U_i - u(x_i) \\right|.\n$$\n- 对于具有 $N$ 和 $2N$ 个子区间且 $b$ 值相同的两个连续网格，定义实验收敛阶 (EOC) 为\n$$\n\\mathrm{EOC}(N\\to 2N,b) = \\frac{\\log\\left(\\frac{E_\\infty(N,b)}{E_\\infty(2N,b)}\\right)}{\\log(2)}.\n$$\n\n测试套件：\n- 边界偏移量 $b \\in \\{\\,0,\\ 1,\\ 0.1\\,\\}$。\n- 网格参数 $N \\in \\{\\,16,\\ 32,\\ 64,\\ 128\\,\\}$。\n\n任务：\n- 对于每个 $b \\in \\{\\,0,\\ 1,\\ 0.1\\,\\}$，计算所有 $N \\in \\{\\,16,\\ 32,\\ 64,\\ 128\\,\\}$ 的 $E_\\infty(N,b)$。\n- 对于每个 $b$，使用 $N=64$ 和 $N=128$ 时的误差计算 $\\mathrm{EOC}(64\\to 128,b)$。\n- 对于每个 $b$，按以下顺序报告两个量：\n    1. $E_\\infty(128,b)$,\n    2. $\\mathrm{EOC}(64\\to 128,b)$.\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个方括号括起来的、逗号分隔的列表。该列表包含所有结果，并按照 $b$ 值序列 $b=0, b=1, b=0.1$ 的顺序排列。因此，六个输出必须是\n$$\n\\left[\\,E_\\infty(128,0),\\ \\mathrm{EOC}(64\\to 128,0),\\ E_\\infty(128,1),\\ \\mathrm{EOC}(64\\to 128,1),\\ E_\\infty(128,0.1),\\ \\mathrm{EOC}(64\\to 128,0.1)\\,\\right].\n$$\n所有报告的值必须是无单位的实数，并按指定顺序打印在单行上。", "solution": "所述问题是有效的。这是一个在数值分析领域中定义明确的练习，具体涉及用于二阶边值问题的有限差分格式的收敛性质。该问题在数学上和科学上都是合理的、自洽的，并且所有术语都有明确的定义。其中没有矛盾或事实错误。因此，我们可以着手求解。\n\n该问题要求我们分析以下两点边值问题的数值解：\n$$\nu''(x) = f(x), \\quad x \\in (0,1)\n$$\n其狄利克雷边界条件为 $u(0) = 0$ 和 $u(1) = 0$。给定精确解为 $u(x) = \\sin(\\pi x)$，这意味着强迫函数必须是 $f(x) = u''(x) = -\\pi^2 \\sin(\\pi x)$。\n\n我们使用一个具有 $N$ 个子区间、步长为 $h = 1/N$ 的均匀网格来离散化定义域 $[0,1]$，节点为 $x_i = i h$，其中 $i=0, 1, \\dots, N$。数值解用 $\\{U_i\\}_{i=0}^N$ 表示，是精确解 $\\{u(x_i)\\}_{i=0}^N$ 的一个近似。\n\n该数值格式的核心是在内部节点 $i=1, \\dots, N-1$ 处对二阶导数使用的二阶中心差分近似：\n$$\n\\frac{U_{i-1} - 2U_i + U_{i+1}}{h^2} = f(x_i)\n$$\n这组方程可以重排为一个线性系统。设内部网格点的未知数值向量为 $\\mathbf{U}_{\\text{int}} = [U_1, U_2, \\dots, U_{N-1}]^T$。关于这些未知数的方程组如下：\n对于 $i=1$：$U_0 - 2U_1 + U_2 = h^2 f(x_1)$\n对于 $i=2, \\dots, N-2$：$U_{i-1} - 2U_i + U_{i+1} = h^2 f(x_i)$\n对于 $i=N-1$：$U_{N-2} - 2U_{N-1} + U_N = h^2 f(x_{N-1})$\n\n边界条件给定为：\n$U_N = u(1) = 0$\n$U_0 = u(0) + b = b$\n这里，$b$ 是在 $x=0$ 边界处施加的一个常数偏移量。\n\n将这些边界值代入方程组，我们得到一个大小为 $(N-1) \\times (N-1)$ 的线性系统 $A \\mathbf{U}_{\\text{int}} = \\mathbf{d}$：\n矩阵 $A$ 是一个三对角矩阵，定义如下：\n$$\nA = \\begin{pmatrix}\n-2   1  0  \\cdots  0 \\\\\n1  -2  1  \\cdots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n\\vdots  \\cdots  1  -2  1 \\\\\n0  \\cdots  0  1  -2\n\\end{pmatrix}\n$$\n该矩阵是对称且负定的，因此是可逆的，这保证了 $\\mathbf{U}_{\\text{int}}$ 存在唯一解。\n\n右端向量 $\\mathbf{d} = [d_1, d_2, \\dots, d_{N-1}]^T$ 的构造如下：\n$$\nd_i = h^2 f(x_i) \\quad \\text{对于 } i=2, \\dots, N-1\n$$\n$$\nd_1 = h^2 f(x_1) - U_0 = h^2 f(x_1) - b\n$$\n$$\nd_{N-1} = h^2 f(x_{N-1}) - U_N = h^2 f(x_{N-1})\n$$\n一旦系统求解出 $\\mathbf{U}_{\\text{int}}$，完整的数值解就可以组装为 $\\{U_0, U_1, \\dots, U_{N-1}, U_N\\}$。\n\n我们必须分析该格式的收敛性。全局误差在最大范数下度量，即 $E_\\infty(N,b) = \\max_{0 \\le i \\le N} |U_i - u(x_i)|$。实验收敛阶 (EOC) 根据两个网格上的解计算得出：$\\mathrm{EOC}(N\\to 2N,b) = \\log_2(E_\\infty(N,b) / E_\\infty(2N,b))$。\n\n情况 1：$b=0$。\n在这种情况下，$U_0 = 0$ 和 $U_N = 0$，这正是精确的边界值。中心差分格式的局部截断误差 (LTE) 为 $\\tau_i = \\frac{u(x_{i-1}) - 2u(x_i) + u(x_{i+1})}{h^2} - u''(x_i) = \\frac{h^2}{12}u^{(4)}(\\xi_i)$，其中 $\\xi_i \\in (x_{i-1}, x_{i+1})$。局部截断误差是 $O(h^2)$ 阶的。由于格式是稳定的，并且在所有内部点上的 LTE 都是 $O(h^2)$ 阶（在边界上为零），标准数值分析理论预测全局误差也将是 $O(h^2)$ 阶的。因此，$E_\\infty(N,0) \\propto h^2 \\propto N^{-2}$。我们预期 EOC 将接近于 2。\n\n情况 2：$b \\neq 0$。\n此处，在边界 $x=0$ 处故意引入了一个误差。这个单点的误差是 $e_0 = U_0 - u(0) = b - 0 = b$。这是一个零阶误差，因为它不依赖于 $h$。边界上的局部化误差会传播到定义域内部。全局误差 $e_i = U_i - u(x_i)$ 是两个分量的叠加：一个由边界误差引起，另一个由内部截断误差引起。对于边界条件为 $e_0 = b$ 和 $e_N = 0$ 的齐次差分方程 $e_{i-1} - 2e_i + e_{i+1} = 0$，其解是线性函数 $e_i^{(h)} = b(1 - i/N) = b(1-x_i)$。由 $O(h^2)$ 阶内部截断误差引起的分量 $e_i^{(p)}$ 是 $O(h^2)$ 阶的。总误差为 $e_i = e_i^{(h)} + e_i^{(p)} = b(1-x_i) + O(h^2)$。全局误差是 $E_\\infty(N,b) = \\max_i |b(1-x_i) + O(h^2)|$。对于 $b \\neq 0$ 和足够大的 $N$（即小的 $h$），$O(h^2)$ 项与 $O(1)$ 项 $b(1-x_i)$ 相比可以忽略不计。$|b(1-x_i)|$ 在网格 $[0,1]$ 上的最大值出现在 $x_i=0$ 处，其值为 $|b|$。在其他网格点，$|b(1-x_i)|$ 严格小于 $|b|$。因此，最大误差将出现在 $i=0$ 处，且等于 $|b|$。$E_\\infty(N,b) = |b|$。由于误差不随 $N$ 的增加而减小，该格式是零阶收敛的。预期的 EOC 为 $\\log_2(|b|/|b|) = \\log_2(1) = 0$。\n\n程序将实现所述的有限差分方法，并计算误差和 EOC 以验证此分析。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the BVP for different configurations and report results.\n    \"\"\"\n    \n    # Define the problem parameters and test suite.\n    b_values = [0.0, 1.0, 0.1]\n    N_values = [16, 32, 64, 128]\n    \n    # Store the final calculated values for printing.\n    final_results = []\n    \n    for b in b_values:\n        errors = {}\n        for N in N_values:\n            # 1. Set up the grid and functions.\n            h = 1.0 / N\n            # Grid points x_i = i*h for i = 0, ..., N.\n            x = np.linspace(0.0, 1.0, N + 1)\n            # Exact solution u(x) = sin(pi*x).\n            u_exact = np.sin(np.pi * x)\n            # Forcing function f(x) = -pi^2 * sin(pi*x).\n            f_vals = -np.pi**2 * np.sin(np.pi * x)\n\n            # 2. Construct the linear system A * U_int = d for interior points.\n            # The dimension of the system is (N-1) x (N-1).\n            dim = N - 1\n            if dim == 0:\n                errors[N] = np.max(np.abs(np.array([b, 0.0]) - u_exact))\n                continue\n\n            # Assemble the tridiagonal matrix A.\n            A = np.zeros((dim, dim))\n            # Main diagonal with -2.\n            np.fill_diagonal(A, -2.0)\n            # Sub-diagonal and super-diagonal with 1.\n            np.fill_diagonal(A[1:], 1.0)\n            np.fill_diagonal(A[:, 1:], 1.0)\n\n            # 3. Construct the right-hand side vector d.\n            # It incorporates f(x) and boundary conditions.\n            d = h**2 * f_vals[1:N]\n            d[0] -= b  # Contribution from U_0 = b.\n            # d[-1] -= 0, contribution from U_N = 0, no change needed.\n\n            # 4. Solve the linear system for the interior solution U_interior.\n            U_interior = np.linalg.solve(A, d)\n\n            # 5. Assemble the full numerical solution U.\n            U = np.zeros(N + 1)\n            U[0] = b\n            U[1:N] = U_interior\n            U[N] = 0.0\n\n            # 6. Calculate the maximum norm of the global error.\n            error = np.max(np.abs(U - u_exact))\n            errors[N] = error\n\n        # 7. Calculate required quantities for reporting.\n        # E_infinity for N=128.\n        E_inf_128 = errors[128]\n\n        # EOC using N=64 and N=128.\n        E_inf_64 = errors[64]\n\n        # Handle cases where error does not change or is zero to avoid log issues.\n        if E_inf_128 == 0.0 or E_inf_64 == 0.0 or E_inf_64 == E_inf_128:\n            eoc = 0.0\n        else:\n            eoc = np.log(E_inf_64 / E_inf_128) / np.log(2.0)\n\n        final_results.append(E_inf_128)\n        final_results.append(eoc)\n\n    # 8. Print the final results in the specified format.\n    # We use '.10g' for a clean representation of the floating point numbers.\n    print(f\"[{','.join(f'{val:.10g}' for val in final_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2380200"}]}