{"hands_on_practices": [{"introduction": "掌握任何数值方法的第一步，都是将其应用于一个典型问题。本练习将指导您为一维热方程实现 Crank-Nicolson 格式，这是学习抛物型偏微分方程的经典起点。通过将梯形法则应用于半离散化的热方程，您会发现该隐式格式在每个时间步都需要求解一个三对角线性系统，从而将数值分析与线性代数紧密联系起来。亲手实现求解器，将使您对整个求解流程获得深刻的理解。[@problem_id:2397387]", "problem": "你的任务是编写一个完整、可运行的程序，该程序使用隐式 Crank–Nicolson 方法来推进一维热方程，并在每个时间步长，使用带部分主元的高斯消元法来求解所得到的三对角线性系统。从热方程的基本原理以及有限差分和梯形法则的定义出发。考虑一维热方程的初边值问题\n$$\n\\frac{\\partial u}{\\partial t}(x,t) = \\alpha \\frac{\\partial^2 u}{\\partial x^2}(x,t),\n$$\n其空间域为 $x \\in (0,1)$，时间区间为 $t \\in [0,T]$，边界条件为齐次 Dirichlet 边界条件\n$$\nu(0,t) = 0,\\quad u(1,t) = 0 \\quad \\text{for all } t \\ge 0,\n$$\n初始条件为\n$$\nu(x,0) = \\sin(\\pi x),\n$$\n其中所有角度均以弧度为单位。参数 $\\alpha$ 是一个正的扩散系数。空间网格使用 $N$ 个内部点，其位置为 $x_i = i h$ (其中 $i \\in \\{1,2,\\dots,N\\}$)，间距为 $h = 1/(N+1)$；时间网格使用 $M$ 个步长，时间步长为 $\\Delta t$，因此 $t^n = n \\Delta t$ (其中 $n \\in \\{0,1,\\dots,M\\}$) 且 $T = M \\Delta t$。\n\n从空间二阶导数的二阶中心差分和时间积分的梯形法则的定义出发，推导出关联内部点 $i \\in \\{1,2,\\dots,N\\}$ 处的值 $u_i^{n+1}$ 和 $u_i^n$ 的 Crank–Nicolson 更新方程。证明在每个时间步长，此更新方程为内部未知量向量 $u^{n+1}$ 定义了一个系数矩阵为三对角矩阵的线性系统。你必须使用带部分主元的高斯消元法 (GEPP) 来实现线性求解器，即在每个消元步骤中，根据当前列中可用的最大绝对值进行行主元选择。你不能调用任何直接求解线性系统或执行分解的库函数；而是必须自己实现 GEPP。\n\n为了验证正确性，请将最终时间 $T$ 时的数值解与给定初始条件下通过分离变量法得到的解析解进行比较，该解析解为：\n$$\nu(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x).\n$$\n对于下面指定的每个测试用例，计算在时间 $T$ 时所有内部网格点上的最大绝对误差\n$$\nE_{\\max} = \\max_{1 \\le i \\le N} \\left| u_i^{\\text{num}}(T) - u(x_i,T) \\right|,\n$$\n并将此值报告为一个无物理单位（无量纲）的浮点数。正弦函数中的所有角度必须以弧度为单位。你的程序必须打印单行输出，包含所有测试用例的结果列表，格式为方括号内由逗号分隔的列表，每个数字采用科学记数法，小数点后精确到八位（例如 $[1.23456789\\text{e}{-}04,2.34567890\\text{e}{-}05]$）。不允许有其他输出。\n\n使用以下测试套件，其中每个元组为 $(\\alpha, N, \\Delta t, T)$，并且在每种情况下 $T/\\Delta t$ 都是整数：\n- 测试 1：$(\\alpha, N, \\Delta t, T) = (1.0, 10, 0.01, 0.10)$。\n- 测试 2：$(\\alpha, N, \\Delta t, T) = (1.0, 2, 0.05, 0.10)$。\n- 测试 3：$(\\alpha, N, \\Delta t, T) = (1.0, 50, 0.001, 0.10)$。\n- 测试 4：$(\\alpha, N, \\Delta t, T) = (0.1, 20, 0.10, 0.50)$。\n\n你的程序应产生单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[r_1,r_2,r_3,r_4]$）。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它具有科学依据，是适定的、客观的、自洽的，并且没有矛盾或含糊之处。该问题描述了一个标准的一维热方程初边值问题，并要求使用自定义的、采用带部分主元的高斯消元法 (GEPP) 的线性求解器来实现 Crank-Nicolson 方法。所有必要的参数和条件都已提供。\n\n问题的核心是求解一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\nCrank-Nicolson 方法是通过对时间积分应用梯形法则和对空间导数应用二阶中心差分来推导的。时间导数在时间区间 $[t^n, t^{n+1}]$ 的中点处进行近似：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} \\approx \\left. \\frac{\\partial u}{\\partial t} \\right|_{x_i, t^{n+1/2}}\n$$\n其中 $u_i^n$ 是 $u(x_i, t^n)$ 的数值近似。梯形法则通过平均其在时间 $t^n$ 和 $t^{n+1}$ 的值来近似右侧项：\n$$\n\\left. \\alpha \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1/2}} \\approx \\frac{\\alpha}{2} \\left( \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^n} + \\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i, t^{n+1}} \\right)\n$$\n空间二阶导数使用二阶中心差分格式进行近似：\n$$\n\\left. \\frac{\\partial^2 u}{\\partial x^2} \\right|_{x_i} \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{h^2}\n$$\n其中 $h$ 是空间步长。结合这些近似，得到 Crank-Nicolson 有限差分方程：\n$$\n\\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2h^2} \\left( (u_{i-1}^{n+1} - 2u_i^{n+1} + u_{i+1}^{n+1}) + (u_{i-1}^n - 2u_i^n + u_{i+1}^n) \\right)\n$$\n设无量纲参数为 $\\lambda = \\frac{\\alpha \\Delta t}{h^2}$。我们重新整理方程，将时间层 $n+1$ 的未知项置于左侧 (LHS)，将时间层 $n$ 的已知项置于右侧 (RHS)：\n$$\n-\\frac{\\lambda}{2} u_{i-1}^{n+1} + (1 + \\lambda) u_i^{n+1} - \\frac{\\lambda}{2} u_{i+1}^{n+1} = \\frac{\\lambda}{2} u_{i-1}^n + (1 - \\lambda) u_i^n + \\frac{\\lambda}{2} u_{i+1}^n\n$$\n该方程对所有内部网格点 $i \\in \\{1, 2, \\dots, N\\}$ 均有效。齐次 Dirichlet 边界条件意味着对所有 $n$ 都有 $u_0^n = u_{N+1}^n = 0$。\n\n这个关于内部值未知向量 $\\mathbf{u}^{n+1} = [u_1^{n+1}, \\dots, u_N^{n+1}]^T$ 的 $N$ 个线性方程组可以写成矩阵形式 $A \\mathbf{u}^{n+1} = B \\mathbf{u}^n$。代表左侧 (LHS) 的矩阵 $A$ 是一个 $N \\times N$ 的对称三对角矩阵：\n$$\nA = \\begin{pmatrix}\n1+\\lambda  -\\lambda/2  0  \\dots  0 \\\\\n-\\lambda/2  1+\\lambda  -\\lambda/2  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots   -\\lambda/2  1+\\lambda  -\\lambda/2 \\\\\n0  \\dots  0  -\\lambda/2  1+\\lambda\n\\end{pmatrix}\n$$\n类似地，作用于已知向量 $\\mathbf{u}^n$ 的矩阵 $B$ 也是一个 $N \\times N$ 的对称三对角矩阵：\n$$\nB = \\begin{pmatrix}\n1-\\lambda  \\lambda/2  0  \\dots  0 \\\\\n\\lambda/2  1-\\lambda  \\lambda/2  \\dots  0 \\\\\n0  \\ddots  \\ddots  \\ddots  0 \\\\\n\\vdots   \\lambda/2  1-\\lambda  \\lambda/2 \\\\\n0  \\dots  0  \\lambda/2  1-\\lambda\n\\end{pmatrix}\n$$\n在每个时间步长，我们必须求解线性系统 $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$，其中右侧向量为 $\\mathbf{d}^n = B \\mathbf{u}^n$。按照要求，该系统将使用带部分主元的高斯消元法 (GEPP) 求解。GEPP 算法包括两个阶段：前向消元和后向代入。\n在前向消元阶段，对于从 $0$ 到 $N-2$ 的每一列 $k$：\n1. 我们在当前列 $k$ 中从第 $k$ 行向下搜索绝对值最大的元素。该元素即为主元。\n2. 将包含主元的行与当前行 $k$ 交换。这一步，即部分主元法，可以增强数值稳定性。\n3. 通过从后续行中减去主元行的适当倍数，来消除列 $k$ 中主元下方的元素。\n前向消元后，矩阵 $A$ 被转换为一个上三角矩阵 $U$。系统变为 $U \\mathbf{u}^{n+1} = \\mathbf{d}'$，其中 $\\mathbf{d}'$ 是相应变换后的右侧向量。\n然后，后向代入阶段求解这个上三角系统，从最后一个未知数 $u_N^{n+1}$ 开始，逐步求解其他未知数，直到 $u_1^{n+1}$。\n\n整体算法流程如下：\n1. 离散化定义域：定义空间步长 $h = 1/(N+1)$ 和时间步数 $M = T/\\Delta t$。\n2. 使用初始条件 $u(x,0) = \\sin(\\pi x)$ 在内部网格点 $x_i = ih$（其中 $i=1,\\dots,N$）处初始化解向量 $\\mathbf{u}^0$。\n3. 构造常数矩阵 $A$。\n4. 对 $n$ 从 $0$ 到 $M-1$ 进行循环：\n    a. 计算右侧向量 $\\mathbf{d}^n = B \\mathbf{u}^n$。\n    b. 使用自定义的 GEPP 实现求解系统 $A \\mathbf{u}^{n+1} = \\mathbf{d}^n$ 以得到 $\\mathbf{u}^{n+1}$。\n    c. 为下一次迭代更新解：$\\mathbf{u}^n \\leftarrow \\mathbf{u}^{n+1}$。\n5. 循环结束后，最终向量 $\\mathbf{u}^M$ 是时间 $T$ 时的数值解。\n6. 通过与给定的解析解 $u(x,T) = e^{-\\alpha \\pi^2 T} \\sin(\\pi x)$ 进行比较，计算最大绝对误差 $E_{\\max} = \\max_{1 \\le i \\le N} |u_i^M - u(x_i, T)|$。\n对每个提供的测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_gepp(A, b):\n    \"\"\"\n    Solves the linear system Ax = b using Gaussian Elimination with Partial Pivoting.\n\n    Args:\n        A (np.ndarray): The N x N coefficient matrix.\n        b (np.ndarray): The N-element right-hand side vector.\n\n    Returns:\n        np.ndarray: The solution vector x.\n    \"\"\"\n    n = len(b)\n    # Create an augmented matrix to work on\n    Ab = np.hstack([A.astype(float), b.reshape(-1, 1).astype(float)])\n\n    # Forward elimination\n    for k in range(n - 1):\n        # Partial Pivoting: find the row with the largest pivot\n        pivot_row = k\n        for i in range(k + 1, n):\n            if abs(Ab[i, k]) > abs(Ab[pivot_row, k]):\n                pivot_row = i\n        \n        # Swap rows if necessary\n        if pivot_row != k:\n            Ab[[k, pivot_row]] = Ab[[pivot_row, k]]\n\n        pivot_val = Ab[k, k]\n        # Check for singularity (not expected in this problem, but good practice)\n        if abs(pivot_val)  1e-15:\n            # For a strictly diagonally dominant matrix, this should not occur.\n            raise ValueError(\"Matrix is singular or near-singular.\")\n\n        # Elimination\n        for i in range(k + 1, n):\n            factor = Ab[i, k] / pivot_val\n            Ab[i, k:] -= factor * Ab[k, k:]\n\n    # Backward substitution\n    x = np.zeros(n)\n    for i in range(n - 1, -1, -1):\n        sum_ax = np.dot(Ab[i, i + 1:n], x[i + 1:n])\n        x[i] = (Ab[i, n] - sum_ax) / Ab[i, i]\n        \n    return x\n\ndef run_simulation(alpha, N, dt, T):\n    \"\"\"\n    Runs the Crank-Nicolson simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): The thermal diffusivity.\n        N (int): The number of interior spatial points.\n        dt (float): The time step size.\n        T (float): The final time.\n\n    Returns:\n        float: The maximum absolute error at the final time T.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    num_steps = int(round(T / dt))\n    \n    # Spatial grid (interior points only)\n    x = np.linspace(h, 1.0 - h, N)\n\n    # Dimensionless parameter lambda\n    lambda_val = alpha * dt / (h * h)\n\n    # Initial condition\n    u_current = np.sin(np.pi * x)\n\n    # Construct matrix A (LHS)\n    A = np.zeros((N, N))\n    diag_A = 1.0 + lambda_val\n    off_diag_A = -lambda_val / 2.0\n    for i in range(N):\n        A[i, i] = diag_A\n        if i > 0:\n            A[i, i - 1] = off_diag_A\n        if i  N - 1:\n            A[i, i + 1] = off_diag_A\n            \n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct RHS vector d = B * u_current\n        d = np.zeros(N)\n        diag_B = 1.0 - lambda_val\n        off_diag_B = lambda_val / 2.0\n        \n        # First element\n        if N > 1:\n            d[0] = diag_B * u_current[0] + off_diag_B * u_current[1]\n        else: # N=1 case\n            d[0] = diag_B * u_current[0]\n        \n        # Middle elements\n        for i in range(1, N - 1):\n            d[i] = off_diag_B * u_current[i - 1] + diag_B * u_current[i] + off_diag_B * u_current[i + 1]\n        \n        # Last element\n        if N > 1:\n            d[N - 1] = off_diag_B * u_current[N - 2] + diag_B * u_current[N - 1]\n\n        # Solve the linear system A * u_next = d\n        u_next = solve_gepp(A, d)\n        \n        u_current = u_next\n\n    # Final numerical solution\n    u_numerical = u_current\n\n    # Analytic solution at time T\n    u_analytic = np.exp(-alpha * np.pi**2 * T) * np.sin(np.pi * x)\n\n    # Calculate maximum absolute error\n    max_error = np.max(np.abs(u_numerical - u_analytic))\n    \n    return max_error\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    # (alpha, N, dt, T)\n    test_cases = [\n        (1.0, 10, 0.01, 0.10),\n        (1.0, 2, 0.05, 0.10),\n        (1.0, 50, 0.001, 0.10),\n        (0.1, 20, 0.10, 0.50),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, N, dt, T = case\n        error = run_simulation(alpha, N, dt, T)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [f\"{res:.8e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2397387"}, {"introduction": "在掌握了基本求解器的实现后，我们可以用它来探索其模拟的物理现象。扩散过程的一个标志性特征是对初始的不规则性具有平滑效应。本实践通过一个不连续的阶跃函数作为初始条件，来直观地展示热方程的平滑特性。您将学习使用总变差（Total Variation, TV）等量化指标来追踪解在时间演化中如何变得更加平滑，从而将数值输出与物理直觉联系起来。[@problem_id:2443569]", "problem": "考虑周期性域上的一维热方程，其偏微分方程 (PDE) 如下：\n$$\n\\frac{\\partial u}{\\partial t}(x,t) \\;=\\; \\nu \\,\\frac{\\partial^2 u}{\\partial x^2}(x,t), \\quad x \\in [0,1), \\; t  0,\n$$\n其边界条件为周期性边界条件 $u(0,t) = u(1,t)$ 和 $\\frac{\\partial u}{\\partial x}(0,t) = \\frac{\\partial u}{\\partial x}(1,t)$（对所有 $t \\ge 0$ 成立），扩散系数 $\\nu = 1$（无量纲）。初始条件为不连续的阶跃函数：\n$$\nu(x,0) \\;=\\; \\begin{cases}\n1,  \\text{if } x \\in [0.5,1),\\\\\n0,  \\text{if } x \\in [0,0.5),\n\\end{cases}\n$$\n该函数在 $[0,1)$ 上被周期性地解释。\n\n设空间域在 $[0,1)$ 上用 $N$ 个均匀间隔的网格点进行离散化，网格间距为 $\\Delta x = 1/N$，并设离散拉普拉斯算子采用标准的带周期性的二阶中心有限差分：\n$$\n(\\mathcal{L} \\mathbf{u})_i \\;=\\; \\mathbf{u}_{i-1} - 2 \\mathbf{u}_i + \\mathbf{u}_{i+1}, \\quad \\text{索引模 } N。\n$$\n设时间网格为 $t^n = n\\,\\Delta t$，时间步长 $\\Delta t  0$，总时间 $T = n_{\\text{steps}}\\,\\Delta t$ 为 $\\Delta t$ 的整数倍。使用时间上的梯形法则（Crank–Nicolson 格式）进行时间离散化，并应用于由上述有限差分空间算子定义的半离散系统。\n\n定义网格函数 $\\mathbf{u} \\in \\mathbb{R}^N$ 的离散全变分为\n$$\n\\mathrm{TV}(\\mathbf{u}) \\;=\\; \\sum_{i=0}^{N-1} \\left| \\mathbf{u}_{i+1} - \\mathbf{u}_i \\right|,\n$$\n其中索引模 $N$，并定义离散二阶差分欧几里得范数为\n$$\n\\mathrm{SD}(\\mathbf{u}) \\;=\\; \\left( \\sum_{i=0}^{N-1} \\left( \\mathbf{u}_{i-1} - 2\\,\\mathbf{u}_i + \\mathbf{u}_{i+1} \\right)^2 \\right)^{1/2},\n$$\n同样，索引模 $N$。\n\n实现一个程序，对于下面列出的每个测试用例 $(N,\\Delta t,T)$，在网格上构建初始条件，使用指定的空间离散化和时间上的梯形法则将解推进到时间 $T$，然后计算比率\n$$\nR_{\\mathrm{TV}} \\;=\\; \\frac{\\mathrm{TV}(\\mathbf{u}(T))}{\\mathrm{TV}(\\mathbf{u}(0))}, \n\\qquad\nR_{\\mathrm{SD}} \\;=\\; \\frac{\\mathrm{SD}(\\mathbf{u}(T))}{\\mathrm{SD}(\\mathbf{u}(0))}.\n$$\n所有量都是无量纲的。将每个比率报告为四舍五入到六位小数的浮点数。\n\n测试套件（每个用例均使用 $\\nu = 1$）：\n- 用例 1：$N = 64$，$\\Delta t = 10^{-4}$，$T = 10^{-2}$。\n- 用例 2：$N = 64$，$\\Delta t = 10^{-3}$，$T = 5\\times 10^{-2}$。\n- 用例 3：$N = 16$，$\\Delta t = 10^{-3}$，$T = 10^{-2}$。\n- 用例 4：$N = 128$，$\\Delta t = 5\\times 10^{-5}$，$T = 5\\times 10^{-3}$。\n- 用例 5：$N = 64$，$\\Delta t = 10^{-5}$，$T = 2\\times 10^{-5}$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，由以下序列组成\n$$\n\\left[ R_{\\mathrm{TV}}^{(1)}, R_{\\mathrm{SD}}^{(1)}, R_{\\mathrm{TV}}^{(2)}, R_{\\mathrm{SD}}^{(2)}, \\ldots, R_{\\mathrm{TV}}^{(5)}, R_{\\mathrm{SD}}^{(5)} \\right],\n$$\n其中上标表示用例编号。每个条目必须四舍五入到六位小数。", "solution": "用户提供了一个问题陈述，在尝试解决之前需要进行验证。\n\n### 步骤 1：提取给定条件\n\n- **偏微分方程 (PDE)**：$\\frac{\\partial u}{\\partial t}(x,t) = \\nu \\frac{\\partial^2 u}{\\partial x^2}(x,t)$\n- **域**：$x \\in [0,1)$，$t  0$\n- **边界条件 (BCs)**：周期性，$u(0,t) = u(1,t)$ 和 $\\frac{\\partial u}{\\partial x}(0,t) = \\frac{\\partial u}{\\partial x}(1,t)$，对 $t \\ge 0$ 成立。\n- **扩散系数**：$\\nu = 1$（无量纲）。\n- **初始条件 (IC)**：\n  $$\n  u(x,0) = \\begin{cases}\n  1,  \\text{if } x \\in [0.5,1),\\\\\n  0,  \\text{if } x \\in [0,0.5).\n  \\end{cases}\n  $$\n- **空间离散化**：具有 $N$ 个点的均匀网格，间距 $\\Delta x = 1/N$。\n- **离散拉普拉斯算子**：带周期性的二阶中心有限差分，$(\\mathcal{L} \\mathbf{u})_i = \\mathbf{u}_{i-1} - 2 \\mathbf{u}_i + \\mathbf{u}_{i+1}$，索引模 $N$。\n- **时间离散化**：梯形法则（Crank–Nicolson 格式），时间步长为 $\\Delta t$。总时间 $T$ 是 $\\Delta t$ 的整数倍。\n- **度量定义**：\n  - 离散全变分：$\\mathrm{TV}(\\mathbf{u}) = \\sum_{i=0}^{N-1} \\left| \\mathbf{u}_{i+1} - \\mathbf{u}_i \\right|$（索引模 $N$）。\n  - 离散二阶差分范数：$\\mathrm{SD}(\\mathbf{u}) = \\left( \\sum_{i=0}^{N-1} \\left( \\mathbf{u}_{i-1} - 2\\,\\mathbf{u}_i + \\mathbf{u}_{i+1} \\right)^2 \\right)^{1/2}$（索引模 $N$）。\n- **要求输出**：比率 $R_{\\mathrm{TV}} = \\frac{\\mathrm{TV}(\\mathbf{u}(T))}{\\mathrm{TV}(\\mathbf{u}(0))}$ 和 $R_{\\mathrm{SD}} = \\frac{\\mathrm{SD}(\\mathbf{u}(T))}{\\mathrm{SD}(\\mathbf{u}(0))}$。\n- **测试套件**：\n  - 用例 1：$N = 64$，$\\Delta t = 10^{-4}$，$T = 10^{-2}$。\n  - 用例 2：$N = 64$，$\\Delta t = 10^{-3}$，$T = 5\\times 10^{-2}$。\n  - 用例 3：$N = 16$，$\\Delta t = 10^{-3}$，$T = 10^{-2}$。\n  - 用例 4：$N = 128$，$\\Delta t = 5\\times 10^{-5}$，$T = 5\\times 10^{-3}$。\n  - 用例 5：$N = 64$，$\\Delta t = 10^{-5}$，$T = 2\\times 10^{-5}$。\n\n### 步骤 2：使用提取的给定条件进行验证\n\n根据验证标准对问题进行分析。\n\n- **科学依据**：该问题基于一维热方程，这是物理学和工程学中的一个基本偏微分方程。指定的数值方法——空间的中心有限差分和时间的 Crank–Nicolson 格式——是求解抛物线型偏微分方程的标准、成熟的技术。该问题是科学严谨的。\n- **适定的**：该问题指定了偏微分方程、域、初始条件和边界条件，它们共同构成了一个适定的初边值问题。数值任务也是适定的；它提供了所有必要的参数和对所需输出的明确定义。Crank–Nicolson 格式是无条件稳定的，确保了对于给定参数存在稳定的数值解。\n- **客观性**：该问题使用精确的数学语言陈述，没有任何主观性或模糊性。\n- **完整性和一致性**：该问题提供了所有必要的信息。没有缺失的参数或矛盾的约束。周期性域上的空间离散化与周期性边界条件一致。度量的定义是明确的。\n\n该问题没有任何验证清单中列出的缺陷。这是一个标准的数值分析问题。\n\n### 步骤 3：结论与行动\n\n该问题是**有效的**。将推导并实现一个解决方案。\n\n问题的核心是使用 Crank-Nicolson 方法求解半离散化的热方程。空间离散化在 $N$ 个点的周期性网格上使用中心有限差分格式，$x_i = i\\Delta x$，$i \\in \\{0, 1, \\dots, N-1\\}$，其中 $\\Delta x = 1/N$。半离散方程是一个常微分方程组 (ODEs)：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\nu}{\\Delta x^2} \\mathcal{L} \\mathbf{u} \\equiv \\mathbf{A} \\mathbf{u}\n$$\n这里，$\\mathbf{u}(t) \\in \\mathbb{R}^N$ 是在时间 $t$ 时网格点上解值的向量，$\\mathbf{A}$ 是表示缩放后的离散拉普拉斯算子 $\\frac{\\nu}{\\Delta x^2}\\mathcal{L}$ 的矩阵。由于周期性边界条件，$\\mathbf{A}$ 是一个循环矩阵。$\\mathbf{A}$ 的第一行由 $\\frac{\\nu}{\\Delta x^2} \\begin{pmatrix} -2  1  0  \\dots  0  1 \\end{pmatrix}$ 给出。\n\nCrank–Nicolson 方法，作为梯形法则在此常微分方程组上的应用，由下式给出：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}\\left( \\mathbf{A}\\mathbf{u}^{n+1} + \\mathbf{A}\\mathbf{u}^n \\right)\n$$\n其中 $\\mathbf{u}^n$ 表示在时间 $t^n = n\\Delta t$ 时的解向量。重新整理以求解下一个时间步的解 $\\mathbf{u}^{n+1}$，得到一个线性系统：\n$$\n\\left(\\mathbf{I} - \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{u}^{n+1} = \\left(\\mathbf{I} + \\frac{\\Delta t}{2}\\mathbf{A}\\right)\\mathbf{u}^n\n$$\n其中 $\\mathbf{I}$ 是单位矩阵。在每个时间步求解这个系统计算成本会很高。然而，矩阵 $\\mathbf{A}$ 的循环特性允许使用离散傅里叶变换 (DFT) 进行高效求解。循环矩阵可由 DFT 矩阵 $\\mathbf{F}$ 对角化。如果 $\\hat{\\mathbf{u}} = \\mathbf{F}\\mathbf{u}$ 表示 $\\mathbf{u}$ 的 DFT，则该系统在傅里叶空间中变为对角系统。\n\n周期性网格的离散拉普拉斯矩阵 $\\mathcal{L}$ 的特征值已知为：\n$$\n\\lambda_k(\\mathcal{L}) = -4 \\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad \\text{for } k = 0, 1, \\dots, N-1.\n$$\n因此，系统矩阵 $\\mathbf{A}$ 的特征值为：\n$$\n\\lambda_k(\\mathbf{A}) = \\frac{\\nu}{\\Delta x^2} \\lambda_k(\\mathcal{L}) = -\\frac{4\\nu}{\\Delta x^2} \\sin^2\\left(\\frac{\\pi k}{N}\\right).\n$$\n在傅里叶空间中，时间步进方程变为关于每个模式 $k$ 的一组解耦的标量方程：\n$$\n\\left(1 - \\frac{\\Delta t}{2}\\lambda_k(\\mathbf{A})\\right)\\hat{u}_k^{n+1} = \\left(1 + \\frac{\\Delta t}{2}\\lambda_k(\\mathbf{A})\\right)\\hat{u}_k^n.\n$$\n这给出了通过乘以一个放大因子 $G_k$ 的更新规则：\n$$\n\\hat{u}_k^{n+1} = G_k \\, \\hat{u}_k^n, \\quad \\text{where} \\quad G_k = \\frac{1 + \\frac{\\Delta t}{2}\\lambda_k(\\mathbf{A})}{1 - \\frac{\\Delta t}{2}\\lambda_k(\\mathbf{A})}.\n$$\n由于算子是时不变的，我们可以在傅里叶空间中一步将解从时间 $t=0$ 演化到时间 $T=n_{\\text{steps}}\\Delta t$：\n$$\n\\hat{\\mathbf{u}}(T) = \\mathbf{G}^{n_{\\text{steps}}} \\hat{\\mathbf{u}}(0),\n$$\n其中 $\\mathbf{G}$ 是由放大因子 $G_k$ 构成的对角矩阵，且 $n_{\\text{steps}} = T/\\Delta t$。\n\n对于每个测试用例 $(N, \\Delta t, T)$ 的总体算法如下：\n1.  构建初始条件向量 $\\mathbf{u}(0) \\in \\mathbb{R}^N$。对于给定的阶跃函数，当 $i   N/2$ 时 $\\mathbf{u}_i(0) = 0$，当 $i \\ge N/2$ 时 $\\mathbf{u}_i(0) = 1$。\n2.  计算初始度量 $\\mathrm{TV}(\\mathbf{u}(0))$ 和 $\\mathrm{SD}(\\mathbf{u}(0))$。对于阶跃函数初始条件，$\\mathrm{TV}(\\mathbf{u}(0))=2$ 和 $\\mathrm{SD}(\\mathbf{u}(0))=2$，这可以通过解析方法验证。\n3.  计算 $k=0, \\dots, N-1$ 的特征值 $\\lambda_k(\\mathbf{A})$。\n4.  计算每步的放大因子 $G_k$。\n5.  计算总步数，$n_{\\text{steps}} = \\text{round}(T/\\Delta t)$。\n6.  计算时间 $T$ 的总放大因子为 $G_k^{\\text{total}} = (G_k)^{n_{\\text{steps}}}$。\n7.  计算初始条件的 DFT：$\\hat{\\mathbf{u}}(0) = \\mathrm{FFT}(\\mathbf{u}(0))$。\n8.  在傅里叶空间中演化解：$\\hat{u}_k(T) = G_k^{\\text{total}} \\cdot \\hat{u}_k(0)$。\n9.  通过应用逆 DFT 计算时间 $T$ 的解：$\\mathbf{u}(T) = \\mathrm{IFFT}(\\hat{\\mathbf{u}}(T))$。结果必须是实数；任何虚部都是由数值噪声引起的，应予以舍弃。\n10. 使用提供的定义计算最终度量 $\\mathrm{TV}(\\mathbf{u}(T))$ 和 $\\mathrm{SD}(\\mathbf{u}(T))$。\n11. 计算并存储比率 $R_{\\mathrm{TV}} = \\mathrm{TV}(\\mathbf{u}(T))/\\mathrm{TV}(\\mathbf{u}(0))$ 和 $R_{\\mathrm{SD}} = \\mathrm{SD}(\\mathbf{u}(T))/\\mathrm{SD}(\\mathbf{u}(0))$，四舍五入到六位小数。\n\n将对每个测试用例实施此程序以产生最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D periodic heat equation using a Fourier-space Crank-Nicolson scheme\n    and computes the specified metrics for several test cases.\n    \"\"\"\n\n    test_cases = [\n        # (N, dt, T)\n        (64, 1e-4, 1e-2),\n        (64, 1e-3, 5e-2),\n        (16, 1e-3, 1e-2),\n        (128, 5e-5, 5e-3),\n        (64, 1e-5, 2e-5),\n    ]\n\n    results = []\n    \n    for N, dt, T in test_cases:\n        # 1. Define constants and grid\n        nu = 1.0\n        dx = 1.0 / N\n\n        # 2. Construct initial condition u(x, 0)\n        u0 = np.zeros(N, dtype=float)\n        # u(x,0)=1 for x in [0.5, 1), so for grid points i/N >= 0.5 => i >= N/2\n        u0[N // 2:] = 1.0\n\n        # 3. Compute initial metrics TV(u(0)) and SD(u(0))\n        # TV(u) = sum(|u_{i+1} - u_i|)\n        tv0 = np.sum(np.abs(np.roll(u0, -1) - u0))\n        \n        # SD(u) = ||u_{i-1} - 2u_i + u_{i+1}||_2\n        sd0_vec = np.roll(u0, 1) - 2 * u0 + np.roll(u0, -1)\n        sd0 = np.linalg.norm(sd0_vec)\n        \n        # Analytically, for this step function, tv0 = 2 and sd0 = 2.\n        # We proceed with the computed values to be fully general.\n\n        # 4. Set up the Fourier space solver\n        # Number of time steps\n        n_steps = int(round(T / dt))\n\n        # Discrete wave numbers for an N-point DFT\n        k = np.arange(N)\n        \n        # Eigenvalues of the discrete Laplacian matrix L\n        # lambda_L_k = -4 * sin^2(pi*k/N)\n        lambda_L = -4.0 * (np.sin(np.pi * k / N))**2\n        \n        # Eigenvalues of the system matrix A = (nu/dx^2) * L\n        lambda_A = (nu / dx**2) * lambda_L\n\n        # 5. Compute Crank-Nicolson amplification factors G_k\n        # G_k = (1 + 0.5 * dt * lambda_A_k) / (1 - 0.5 * dt * lambda_A_k)\n        numerator = 1.0 + 0.5 * dt * lambda_A\n        denominator = 1.0 - 0.5 * dt * lambda_A\n        # Avoid division by zero if a denominator is zero, though unlikely here.\n        # np.divide handles this by returning inf, which is acceptable.\n        amp_factors = np.divide(numerator, denominator, out=np.ones_like(numerator), where=(denominator!=0))\n        \n        # 6. Evolve solution in Fourier space over total time T\n        # Total amplification is G_k ^ n_steps\n        total_amp_factors = amp_factors ** n_steps\n\n        # FFT of initial condition\n        u0_hat = np.fft.fft(u0)\n        \n        # Apply total amplification\n        uT_hat = u0_hat * total_amp_factors\n\n        # Inverse FFT to get solution at time T\n        uT = np.fft.ifft(uT_hat).real\n\n        # 7. Compute final metrics TV(u(T)) and SD(u(T))\n        tvT = np.sum(np.abs(np.roll(uT, -1) - uT))\n        sdT_vec = np.roll(uT, 1) - 2 * uT + np.roll(uT, -1)\n        sdT = np.linalg.norm(sdT_vec)\n\n        # 8. Compute and store ratios\n        # Handle potential division by zero for trivial initial conditions\n        R_TV = tvT / tv0 if tv0 != 0 else (1.0 if tvT == 0 else np.inf)\n        R_SD = sdT / sd0 if sd0 != 0 else (1.0 if sdT == 0 else np.inf)\n\n        results.append(R_TV)\n        results.append(R_SD)\n\n    # Final print statement in the exact required format.\n    # The output format string ensures rounding to exactly 6 decimal places.\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2443569"}, {"introduction": "计算科学的一个重要方面是理解我们数值工具的局限性。Crank-Nicolson 格式虽然是无条件稳定的，但并非没有缺陷，尤其是在时间步长相对于空间尺度较大时。本练习旨在揭示该方法的一个潜在陷阱：当使用较大的扩散数 $r$ 处理包含急剧变化的初始数据时，可能会产生非物理的振荡。通过这个思想实验，您将认识到稳定性并不总能保证物理上的准确性，这对于进行可靠的科学模拟至关重要。[@problem_id:2443615]", "problem": "考虑一维热方程\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t  0,\n$$\n其具有齐次狄利克雷边界条件\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0,\n$$\n以及由紧支集高帽剖面给出的初始条件\n$$\nu(x,0) = \\begin{cases}\n1,  |x - 1/2| \\le w/2,\\\\\n0,  \\text{otherwise},\n\\end{cases}\n$$\n其中宽度为 $w = 0.1$。在 $[0,1]$ 上使用具有 $M$ 个相等子区间的均匀空间网格，因此空间步长为 $\\Delta x = 1/M$，网格点为 $x_i = i \\,\\Delta x$，$i = 0,1,\\ldots,M$。内部未知数位于索引 $i = 1,2,\\ldots,M-1$ 处。时间积分将通过对由空间二阶中心有限差分产生的半离散系统应用梯形法则（也称为 Crank–Nicolson 格式）来执行。令扩散数为\n$$\nr = \\frac{\\alpha \\,\\Delta t}{(\\Delta x)^2},\n$$\n固定 $\\alpha = 1$。使用由指定的 $r$ 值确定的恒定时间步长 $\\Delta t$，将数值解从 $t=0$ 演化到 $t = T_{\\text{end}}$。目标是检测对于大的 $r$ 可能出现的不符合物理规律的时间振荡，其表现为尽管在给定条件下精确解在 $t0$ 时保持非负，但数值解中却出现了负值。\n\n为给定的参数集定义一个“检测到振荡”的布尔值，如下所示：在每个时间步之后，如果在任何时间 $t \\in (0, T_{\\text{end}}]$，任何内部网格值严格低于 $-10^{-10}$ 的容差阈值，则将该布尔值设为 $\\text{True}$；否则设为 $\\text{False}$。$x=0$ 和 $x=1$ 处的边界值固定为 $0$，不应用于检测标准。\n\n您的程序必须为以下参数值 $(M, r, T_{\\text{end}})$ 的测试套件实现上述数学模型和检测规则，其中 $\\alpha = 1$ 和 $w = 0.1$ 保持不变：\n- 测试 A (理想路径，小扩散数)：$(M, r, T_{\\text{end}}) = (100, 0.1, 0.05)$。\n- 测试 B (符号改变阈值附近的边界情况)：$(M, r, T_{\\text{end}}) = (100, 0.5, 0.05)$。\n- 测试 C (中等大扩散数)：$(M, r, T_{\\text{end}}) = (100, 0.6, 0.05)$。\n- 测试 D (非常大的扩散数)：$(M, r, T_{\\text{end}}) = (100, 5.0, 0.05)$。\n\n对于每个测试，唯一的结果是如上定义的布尔值“检测到振荡”。您的程序应生成单行输出，其中包含测试 A–D 的四个布尔结果，按顺序排列，以逗号分隔并用方括号括起来（例如，“[False,True,True,False]”）。输出中不需要物理单位。不涉及角度。不涉及百分比。输出必须严格遵守指定的格式。", "solution": "所提出的问题是有效的。这是一个在计算科学中定义明确的问题，基于偏微分方程数值分析的基本原理。所有必要的参数和条件都已提供，没有科学或逻辑上的矛盾。我们将继续进行求解。\n\n该问题要求数值求解一维热方程：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\quad t  0\n$$\n热扩散系数给定为 $\\alpha = 1$。边界条件为齐次狄利克雷类型：\n$$\nu(0,t) = 0, \\quad u(1,t) = 0, \\quad t \\ge 0\n$$\n初始条件是宽度为 $w = 0.1$ 的高帽函数：\n$$\nu(x,0) = \\begin{cases}\n1,  \\text{if } |x - 1/2| \\le 0.1/2 \\\\\n0,  \\text{otherwise}\n\\end{cases}\n$$\n这对应于 $x \\in [0.45, 0.55]$ 时 $u(x,0)=1$。\n\n首先，我们在空间上进行半离散化。空间域 $[0,1]$ 被离散化为 $M$ 个等长的子区间，长度为 $\\Delta x = 1/M$。网格点为 $x_i = i \\Delta x$，$i = 0, 1, \\ldots, M$。令 $u_i(t)$ 为 $u(x_i, t)$ 的数值近似。二阶空间导数使用二阶中心差分公式近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x=x_i} \\approx \\frac{u_{i+1}(t) - 2u_i(t) + u_{i-1}(t)}{(\\Delta x)^2}\n$$\n将其应用于内部网格点 $i = 1, 2, \\ldots, M-1$，我们得到一个常微分方程组 (ODEs)：\n$$\n\\frac{d u_i}{dt} = \\frac{\\alpha}{(\\Delta x)^2} (u_{i+1} - 2u_i + u_{i-1})\n$$\n令 $\\mathbf{u}(t) = [u_1(t), u_2(t), \\ldots, u_{M-1}(t)]^T$ 为内部点的解向量。该常微分方程组可以写成矩阵形式：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}\n$$\n其中 $L_{1D}$ 是表示带有齐次狄利克雷边界条件的离散拉普拉斯算子的 $(M-1) \\times (M-1)$ 三对角矩阵：\n$$\nL_{1D} = \\begin{pmatrix}\n-2  1  0  \\dots  0 \\\\\n1  -2  1  \\dots  0 \\\\\n0  1  -2  \\dots  0 \\\\\n\\vdots  \\ddots  \\ddots  \\ddots  \\vdots \\\\\n0  \\dots  0  1  -2\n\\end{pmatrix}\n$$\n\n接下来，我们使用梯形法则（也称为 Crank-Nicolson 方法）在时间上进行离散化。给定时间步长 $\\Delta t$，令 $\\mathbf{u}^n$ 表示在时间 $t_n = n \\Delta t$ 的解向量。该格式为：\n$$\n\\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2} \\left( \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^{n+1} + \\frac{\\alpha}{(\\Delta x)^2} L_{1D} \\mathbf{u}^n \\right)\n$$\n引入扩散数 $r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}$，我们可以重新整理方程以求解 $\\mathbf{u}^{n+1}$：\n$$\n\\left(I - \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^{n+1} = \\left(I + \\frac{r}{2} L_{1D}\\right) \\mathbf{u}^n\n$$\n其中 $I$ 是 $(M-1) \\times (M-1)$ 的单位矩阵。在每个时间步，我们必须求解一个形式为 $A \\mathbf{x} = \\mathbf{b}$ 的线性系统，其中：\n- 系统矩阵是 $A_{CN} = I - \\frac{r}{2} L_{1D}$。\n- 未知向量是 $\\mathbf{x} = \\mathbf{u}^{n+1}$。\n- 右侧向量是 $\\mathbf{b}_{CN} = (I + \\frac{r}{2} L_{1D}) \\mathbf{u}^n$。\n\n矩阵 $A_{CN}$ 是三对角矩阵，主对角线上的元素为 $(1+r)$，次对角线和超对角线上的元素为 $-r/2$。对于任何 $r  0$，该系统都是非奇异且对角占优的，因此可以使用针对三对角系统的算法（如 Thomas 算法）高效求解。\n\n模拟过程如下：\n1.  对于每个由 $(M, r, T_{\\text{end}})$ 指定的测试用例，我们设置 $\\alpha=1$ 和 $w=0.1$。\n2.  空间步长为 $\\Delta x = 1/M$。时间步长由扩散数确定，$\\Delta t = r (\\Delta x)^2 / \\alpha$。\n3.  通过在内部网格点 $x_i$（$i=1, \\ldots, M-1$）上对高帽函数进行采样来构建初始解向量 $\\mathbf{u}^0$。\n4.  构建 Crank-Nicolson 步骤的矩阵。左侧矩阵 $A_{CN}$ 在整个模拟过程中是恒定的。\n5.  一个时间步进循环将解从 $t=0$ 演化到 $t=T_{\\text{end}}$。在每个步骤中：\n    a. 通过将算子 $(I + \\frac{r}{2} L_{1D})$ 应用于当前解 $\\mathbf{u}^n$ 来计算右侧向量 $\\mathbf{b}_{CN}$。\n    b. 求解线性系统 $A_{CN} \\mathbf{u}^{n+1} = \\mathbf{b}_{CN}$ 以得到 $\\mathbf{u}^{n+1}$。\n    c. 检查新的解向量 $\\mathbf{u}^{n+1}$ 是否有振荡。如果其任何分量小于容差 $-10^{-10}$，则将布尔标志 `oscillation_detected` 设置为 `True`，并终止此测试用例的模拟。\n6.  如果时间循环完成而标志未被设置，其值保持为 `False`。\n\nCrank-Nicolson 格式在 $L_2$ 范数意义下对于任何 $r  0$ 都是无条件稳定的。然而，对于非光滑的初始条件，除非时间步长足够小，否则它可能无法保持正定性并可能引入伪振荡。对非负性的傅里叶稳定性分析表明，如果所有模式的放大因子都为非负，则可以避免振荡。对于最高频率模式，这导致条件 $1 - 2r \\ge 0$，即 $r \\le 0.5$。因此，我们预计在 $r  0.5$ 的测试用例中会检测到振荡。具体来说，对于测试 C ($r=0.6$) 和测试 D ($r=5.0$)，我们期望发现负值。对于测试 A ($r=0.1$) 和测试 B ($r=0.5$)，我们期望解保持非负。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n\n    def run_simulation(M, r, T_end, alpha, w):\n        \"\"\"\n        Solves the 1D heat equation using the Crank-Nicolson method for one set of parameters.\n\n        Args:\n            M (int): Number of spatial subintervals.\n            r (float): Diffusion number.\n            T_end (float): End time for the simulation.\n            alpha (float): Thermal diffusivity.\n            w (float): Width of the initial top-hat profile.\n\n        Returns:\n            bool: True if oscillations are detected, False otherwise.\n        \"\"\"\n        # --- 1. Setup simulation parameters ---\n        dx = 1.0 / M\n        dt = r * dx**2 / alpha\n        num_steps = int(np.ceil(T_end / dt))\n        tol = -1.0e-10\n        \n        # --- 2. Create spatial grid and initial condition ---\n        # Grid consists of M-1 interior points.\n        x_interior = np.linspace(dx, 1.0 - dx, M - 1)\n        \n        u = np.zeros(M - 1)\n        left_bound = 0.5 - w / 2.0\n        right_bound = 0.5 + w / 2.0\n        \n        # Set initial condition u(x,0) based on the top-hat profile.\n        # N.B. Using a small epsilon for float comparison safety is good practice,\n        # but for M=100, the boundaries 0.45 and 0.55 are exact grid points.\n        u[(x_interior >= left_bound)  (x_interior = right_bound)] = 1.0\n        \n        # --- 3. Construct matrices for the Crank-Nicolson scheme ---\n        # The scheme is (I - r/2 * L) u_next = (I + r/2 * L) u_current\n        # Let A = (I - r/2 * L) and B = (I + r/2 * L). We solve A * u_next = B * u_current.\n        \n        # A matrix in banded form for Scipy's solver.\n        # It has 1 lower, 1 upper diagonal. Shape (3, M-1).\n        # Row 0: super-diagonal, Row 1: main diagonal, Row 2: sub-diagonal.\n        A_banded = np.zeros((3, M - 1))\n        A_banded[0, 1:] = -r / 2.0\n        A_banded[1, :] = 1.0 + r\n        A_banded[2, :-1] = -r / 2.0\n        \n        # --- 4. Time-stepping loop ---\n        u_current = u\n        oscillation_detected = False\n        \n        for _ in range(num_steps):\n            # Calculate the right-hand side vector: rhs = B * u_current\n            # B is tridiagonal with (1-r) on the main diagonal and r/2 on off-diagonals.\n            # We compute the matrix-vector product efficiently without forming B.\n            rhs = np.zeros(M - 1)\n            \n            # For interior points of the u_current vector (indices 1 to M-3)\n            rhs[1:-1] = (r / 2.0) * u_current[:-2] + \\\n                        (1.0 - r) * u_current[1:-1] + \\\n                        (r / 2.0) * u_current[2:]\n            \n            # Handle endpoints with homogeneous Dirichlet BCs (u_0=0, u_M=0)\n            if M - 1 > 0: # Ensure u_current is not empty\n                rhs[0] = (1.0 - r) * u_current[0] + (r / 2.0) * u_current[1] if M - 1 > 1 else (1.0 - r) * u_current[0]\n            if M - 1 > 1:\n                rhs[-1] = (r / 2.0) * u_current[-2] + (1.0 - r) * u_current[-1]\n            \n            # Solve the tridiagonal system A * u_next = rhs\n            u_next = solve_banded((1, 1), A_banded, rhs)\n            \n            # Check for oscillations\n            if np.any(u_next  tol):\n                oscillation_detected = True\n                break\n            \n            u_current = u_next\n            \n        return oscillation_detected\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 0.1, 0.05),  # Test A\n        (100, 0.5, 0.05),  # Test B\n        (100, 0.6, 0.05),  # Test C\n        (100, 5.0, 0.05),  # Test D\n    ]\n\n    # Fixed parameters\n    alpha = 1.0\n    w = 0.1\n    \n    results = []\n    for case in test_cases:\n        M, r, T_end = case\n        result = run_simulation(M, r, T_end, alpha, w)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443615"}]}