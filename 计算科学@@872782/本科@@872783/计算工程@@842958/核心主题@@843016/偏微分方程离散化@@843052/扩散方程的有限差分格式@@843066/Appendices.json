{"hands_on_practices": [{"introduction": "理解数值格式的稳定性是计算工程中的一个核心概念。通过冯·诺依曼稳定性分析，我们可以推导出显式格式（如FTCS）的稳定性条件。这个练习 [@problem_id:2392558] 将引导你运用该分析方法，精确找出在不稳定情况下增长最快的傅里叶模式，从而深化对数值不稳定性机理的认识。", "problem": "考虑一维扩散方程 $u_{t}=\\alpha u_{xx}$，其中扩散系数 $\\alpha>0$ 为常数，定义在一个长度为 $L>0$ 的空间周期性区域上。使用偶数个 $N$ 均匀间隔的网格点 $x_{j}=j\\,\\Delta x$ 对空间进行离散化，其中 $j\\in\\{0,1,\\ldots,N-1\\}$，$\\Delta x=L/N$，并使用前向时间中心空间（FTCS）格式以步长 $\\Delta t>0$ 在时间上推进\n$$\nu_{j}^{n+1}=u_{j}^{n}+\\frac{\\alpha\\,\\Delta t}{\\Delta x^{2}}\\left(u_{j+1}^{n}-2\\,u_{j}^{n}+u_{j-1}^{n}\\right),\n$$\n采用周期性边界条件。假设选择的时间步长和网格间距满足 $\\alpha\\,\\Delta t/\\Delta x^{2}>1/2$，因此该格式是不稳定的。\n\n在网格和周期性所允许的所有离散空间傅里叶模式中，找出在该格式下其模经历最大单步幅值放大的单个波数 $\\kappa^{\\star}$（单位为弧度/米）。报告从主区间 $(-\\pi/\\Delta x,\\pi/\\Delta x]$ 中选择的 $\\kappa^{\\star}$。将最终答案表示为以 $\\Delta x$ 表示的闭式解析表达式。不需要四舍五入，并以弧度/米为单位表示波数。", "solution": "问题要求在不稳定条件下，找出应用于一维扩散方程的前向时间中心空间（FTCS）格式中，其空间傅里叶模式的幅值放大最大的波数 $\\kappa^{\\star}$。\n\n一维扩散方程由下式给出\n$$u_{t} = \\alpha u_{xx}$$\n其中 $u(x,t)$ 是扩散的物理量，$t$ 是时间，$x$ 是空间坐标，$\\alpha > 0$ 是常数扩散系数。区域是周期性的，长度为 $L$。\n\nFTCS离散格式为\n$$u_{j}^{n+1} = u_{j}^{n} + \\frac{\\alpha \\Delta t}{\\Delta x^{2}}(u_{j+1}^{n} - 2u_{j}^{n} + u_{j-1}^{n})$$\n其中 $u_j^n \\approx u(j\\Delta x, n\\Delta t)$，$\\Delta x = L/N$ 是空间步长，$N$ 为偶数，$\\Delta t$ 是时间步长。我们定义扩散数 $r = \\frac{\\alpha \\Delta t}{\\Delta x^{2}}$。问题陈述该格式是不稳定的，这对应于条件 $r > \\frac{1}{2}$。\n\n为了分析该格式的稳定性，我们使用冯·诺依曼稳定性分析。我们考虑单个傅里叶模式作为解：\n$$u_{j}^{n} = \\hat{u}^{n}(\\kappa) e^{i \\kappa x_{j}} = \\hat{u}^{n}(\\kappa) e^{i \\kappa j \\Delta x}$$\n其中 $\\kappa$ 是波数，$\\hat{u}^{n}(\\kappa)$ 是该模式在时间步 $n$ 的振幅。该模式从一个时间步到下一个时间步的放大由放大因子 $G(\\kappa) = \\frac{\\hat{u}^{n+1}(\\kappa)}{\\hat{u}^{n}(\\kappa)}$ 给出。\n\n将傅里叶模式代入FTCS格式：\n$$\\hat{u}^{n+1}(\\kappa) e^{i \\kappa j \\Delta x} = \\hat{u}^{n}(\\kappa) e^{i \\kappa j \\Delta x} + r \\left( \\hat{u}^{n}(\\kappa) e^{i \\kappa (j+1) \\Delta x} - 2\\hat{u}^{n}(\\kappa) e^{i \\kappa j \\Delta x} + \\hat{u}^{n}(\\kappa) e^{i \\kappa (j-1) \\Delta x} \\right)$$\n除以 $\\hat{u}^{n}(\\kappa) e^{i \\kappa j \\Delta x}$（假设为非平凡模式），我们得到放大因子 $G(\\kappa)$：\n$$G(\\kappa) = 1 + r (e^{i \\kappa \\Delta x} - 2 + e^{-i \\kappa \\Delta x})$$\n使用欧拉恒等式 $e^{i\\theta} + e^{-i\\theta} = 2\\cos(\\theta)$，我们可以简化表达式：\n$$G(\\kappa) = 1 + r (2\\cos(\\kappa \\Delta x) - 2) = 1 - 2r(1 - \\cos(\\kappa \\Delta x))$$\n使用半角三角恒等式 $1 - \\cos(\\theta) = 2\\sin^2(\\frac{\\theta}{2})$，放大因子变为：\n$$G(\\kappa) = 1 - 4r \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right)$$\n我们的任务是找到波数 $\\kappa^{\\star}$，它能在主区间 $\\kappa \\in (-\\pi/\\Delta x, \\pi/\\Delta x]$ 内使放大因子 $|G(\\kappa)|$ 的幅值最大化。由于 $\\kappa$ 是实数，$G(\\kappa)$ 也是实数。因此，我们寻求最大化 $|G(\\kappa)| = \\left|1 - 4r \\sin^2\\left(\\frac{\\kappa \\Delta x}{2}\\right)\\right|$。\n\n设变量 $\\theta = \\frac{\\kappa \\Delta x}{2}$。当 $\\kappa$ 在 $(-\\pi/\\Delta x, \\pi/\\Delta x]$ 范围内变化时，$\\theta$ 在 $(-\\pi/2, \\pi/2]$ 范围内变化。\n设 $S = \\sin^2(\\theta)$。对于 $\\theta \\in (-\\pi/2, \\pi/2]$，$\\sin(\\theta)$ 的值从略大于 $-1$ 到 $1$，所以 $S = \\sin^2(\\theta)$ 的取值范围是区间 $[0, 1]$。具体来说，当 $\\theta=0$（即 $\\kappa=0$）时，$S=0$；当 $\\theta=\\pm\\pi/2$（即 $\\kappa=\\pm\\pi/\\Delta x$）时，$S=1$。值 $\\theta=\\pi/2$ 包含在定义域中。\n\n问题简化为在给定条件 $r > \\frac{1}{2}$ 下，求函数 $f(S) = |1 - 4rS|$ 在区间 $S \\in [0, 1]$ 上的最大值。\n函数 $g(S) = 1 - 4rS$ 是关于 $S$ 的线性函数。其幅值 $|g(S)|$ 在闭区间上的最大值必定在区间的某个端点处取得。\n让我们计算 $f(S)$ 在端点 $S=0$ 和 $S=1$ 处的值：\n1. 在 $S=0$ 处：$f(0) = |1 - 4r(0)| = |1| = 1$。\n2. 在 $S=1$ 处：$f(1) = |1 - 4r(1)| = |1 - 4r|$。\n鉴于 $r > \\frac{1}{2}$，可得 $4r > 2$，因此 $1 - 4r  1 - 2 = -1$。\n因此，$|1 - 4r| = -(1 - 4r) = 4r - 1$。\n比较这两个值，由于 $r  \\frac{1}{2}$，我们有 $4r - 1  4(\\frac{1}{2}) - 1 = 2-1 = 1$。\n因此，放大因子的最大幅值为 $4r - 1$，它在 $S=1$ 时出现。\n\n我们寻求的波数 $\\kappa^{\\star}$ 是满足 $S = \\sin^2\\left(\\frac{\\kappa^{\\star} \\Delta x}{2}\\right) = 1$ 的那个。\n这意味着 $\\sin\\left(\\frac{\\kappa^{\\star} \\Delta x}{2}\\right) = \\pm 1$。\n对此，通解为 $\\frac{\\kappa^{\\star} \\Delta x}{2} = \\frac{\\pi}{2} + n\\pi$，其中 $n$ 为任意整数。\n解出 $\\kappa^{\\star}$：\n$$\\kappa^{\\star} \\Delta x = \\pi + 2n\\pi = (2n+1)\\pi$$\n$$\\kappa^{\\star} = \\frac{(2n+1)\\pi}{\\Delta x}$$\n我们必须选择落在指定主区间 $\\kappa^{\\star} \\in (-\\pi/\\Delta x, \\pi/\\Delta x]$ 内的 $\\kappa^{\\star}$ 值。\n- 如果 $n=0$，$\\kappa^{\\star} = \\frac{\\pi}{\\Delta x}$。这个值在区间内，因为 $\\pi/\\Delta x \\in (-\\pi/\\Delta x, \\pi/\\Delta x]$。\n- 如果 $n=-1$，$\\kappa^{\\star} = \\frac{-\\pi}{\\Delta x}$。这个值不在区间内，因为下界是开的。\n- 对于任何其他整数 $n$，$\\kappa^{\\star}$ 的值将落在区间之外。\n\n因此，在给定区间内对应最大放大的唯一波数是 $\\kappa^{\\star} = \\frac{\\pi}{\\Delta x}$。这个波数对应于网格上可以表示的最高频率模式，其波长为 $\\lambda = 2\\Delta x$。这是空间网格的奈奎斯特频率。该模式具有 $u_j \\propto (-1)^j$ 的形态，这在 $r  1/2$ 时被认为是FTCS格式最不稳定的模式。\n问题陈述网格点数为偶数 $N$。这样一个网格所支持的离散波数集合是 $\\kappa_m = \\frac{2\\pi m}{N\\Delta x}$，对于 $m \\in \\{-N/2+1, \\dots, N/2\\}$。波数 $\\kappa^{\\star} = \\frac{\\pi}{\\Delta x}$ 是这个离散集合的一部分，对应于索引 $m=N/2$。因此，我们的解与问题的离散性质是一致的。\n最终答案是这个波数的表达式。", "answer": "$$\\boxed{\\frac{\\pi}{\\Delta x}}$$", "id": "2392558"}, {"introduction": "将理论知识应用于实际工程问题是至关重要的一步。这个练习 [@problem_id:2392562] 要求你在一个带内孔的复杂二维域上求解稳态扩散问题（拉普拉斯方程）。通过该实践，你将掌握如何处理复杂边界、构建并求解由偏微分方程离散化产生的大型稀疏线性系统，这是工程仿真中的一项基本技能。", "problem": "考虑一个标量场 $u(x,y)$ 在一个带有内部圆形孔洞的二维方形区域 $\\Omega$ 内的稳态扩散过程，其扩散系数 $k$ 为常数。从通量守恒和 Fick 定律出发，无体积源项的稳态扩散的控制偏微分方程 (PDE) 为\n$$\n-\\nabla \\cdot (k \\nabla u) = 0 \\quad \\text{in } \\Omega \\setminus \\mathcal{H},\n$$\n其中 $\\mathcal{H}$ 是孔洞的内部。在外部方形边界 $\\partial \\Omega$ 和内部边界 $\\partial \\mathcal{H}$ 上，均施加狄利克雷 (Dirichlet) 边界条件 $u=g(x,y)$，其中 $g(x,y)$ 是给定的。为进行数值验证，使用人造解法，并指定精确解为\n$$\nu^{\\star}(x,y) = e^{x}\\cos(y),\n$$\n并设 $k=1$。那么与 $u^{\\star}(x,y)$ 兼容的源项满足\n$$\n-\\nabla \\cdot (k \\nabla u^{\\star}) = 0,\n$$\n因此，PDE 在 $\\Omega \\setminus \\mathcal{H}$ 内部保持齐次，且在两个边界上的狄利克雷数据为 $u=g=u^{\\star}$。使用 $N\\times N$ 个节点的均匀笛卡尔网格对区域 $\\Omega=[-1,1]\\times[-1,1]$ 进行离散化，其中 $N$ 是一个大于或等于 $5$ 的给定整数，网格间距为 $h = \\frac{2}{N-1}$。设节点坐标为 $x_i=-1+ih$ 和 $y_j=-1+jh$，其中 $i,j\\in\\{0,1,\\dots,N-1\\}$。通过其中心 $(x_c,y_c)$ 和半径 $r$ 来定义圆形孔洞。内部边界按如下方式处理：\n- 将中心满足 $(x_i-x_c)^2+(y_j-y_c)^2  r^2$ 的节点归类为“孔洞节点”，并从计算域中排除。\n- 非孔洞节点若其四个基本邻居（左、右、上、下）中至少有一个是孔洞节点，则被归类为“内部边界节点”。\n- 位于方形域边界（$i=0, N-1$ 或 $j=0, N-1$）的节点是“外部边界节点”。\n- 在所有边界节点（内部和外部）上，均施加狄利克雷条件 $u_{i,j} = u^{\\star}(x_i,y_j)$。\n- 所有其他节点均为“未知节点”，其值需通过求解由拉普拉斯方程的五点中心差分格式构成的线性方程组来确定。\n\n**任务**：为四个测试用例（在提供的答案代码中指定）计算并返回未知节点上的最大绝对误差 $E_{\\infty} = \\max|u_{i,j} - u^{\\star}(x_i,y_j)|$。", "solution": "对问题陈述进行了严格审查，认定其有效。该问题具有科学依据、适定、客观且自洽。它描述了计算工程中的一个标准问题：使用有限差分法在复杂域上求解拉普拉斯方程，并采用人造解进行验证。\n\n在扩散系数 $k=1$ 为常数且无源项的情况下，稳态扩散的控制偏微分方程是二维拉普拉斯方程：\n$$\n\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n$$\n此方程在区域 $\\Omega \\setminus \\mathcal{H}$ 内成立，其中 $\\Omega = [-1,1] \\times [-1,1]$ 是一个正方形，$\\mathcal{H}$ 是一个内部圆形孔洞。在外部边界 $\\partial\\Omega$ 和内部边界 $\\partial\\mathcal{H}$ 上，使用人造解 $u^{\\star}(x,y) = e^{x}\\cos(y)$ 施加狄利克雷 (Dirichlet) 边界条件。\n\n该区域使用一个 $N \\times N$ 个节点的均匀笛卡尔网格进行离散化。对于 $i,j \\in \\{0, 1, \\dots, N-1\\}$，节点 $(i,j)$ 的坐标由 $(x_i, y_j)$ 给出，其中 $x_i = -1 + ih$ 且 $y_j = -1 + jh$。网格间距为 $h = \\frac{2}{N-1}$。令 $u_{i,j}$ 表示 $u(x_i, y_j)$ 的数值近似。\n\n在内部节点 $(x_i, y_j)$ 处，拉普拉斯算子使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i-1,j} - 2u_{i,j} + u_{i+1,j}}{h^2}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial y^2}\\bigg|_{(x_i, y_j)} \\approx \\frac{u_{i,j-1} - 2u_{i,j} + u_{i,j+1}}{h^2}\n$$\n将这些近似代入拉普拉斯方程并乘以 $h^2$，得到五点有限差分格式：\n$$\n(u_{i-1,j} - 2u_{i,j} + u_{i+1,j}) + (u_{i,j-1} - 2u_{i,j} + u_{i,j+1}) = 0\n$$\n整理各项，得到每个未知内部节点的方程：\n$$\n4u_{i,j} - u_{i-1,j} - u_{i+1,j} - u_{i,j-1} - u_{i,j+1} = 0\n$$\n\n数值程序的核心是对每个网格节点 $(i,j)$ 进行分类，以确定其值 $u_{i,j}$ 是待求解的未知量还是已知的边界值。我们定义三类节点：\n1.  **孔洞节点**：其坐标 $(x_i, y_j)$ 满足 $(x_i - x_c)^2 + (y_j - y_c)^2  r^2$ 的节点。这些节点被排除在计算之外。\n2.  **边界节点**：在这些节点上 $u$ 的值是给定的。此类别包括：\n    (a) 位于 $\\partial\\Omega$ 上的外部边界节点，其中 $i \\in \\{0, N-1\\}$ 或 $j \\in \\{0, N-1\\}$。\n    (b) 内部边界节点，它们是非孔洞节点，但其四个基本邻居（左、右、上、下）中至少有一个被分类为孔洞节点。\n    对所有边界节点，其值被设定为精确解，$u_{i,j} = u^{\\star}(x_i, y_j)$。\n3.  **未知节点**：这些是区域 $\\Omega \\setminus \\mathcal{H}$ 内所有未被分类为边界节点的节点。这些节点上的值 $u_{i,j}$ 是问题的未知量。\n\n假设有 $M$ 个未知节点。我们构建一个大小为 $M \\times M$ 的线性方程组 $A\\mathbf{u}_{\\text{unk}} = \\mathbf{b}$。向量 $\\mathbf{u}_{\\text{unk}}$ 包含 $M$ 个未知的 $u$ 值。在未知节点的二维索引 $(i,j)$ 与一维索引 $k \\in \\{0, 1, \\dots, M-1\\}$ 之间建立一个映射。\n\n对于每个具有相应索引 $k$ 的未知节点 $(i,j)$，我们根据五点格式写出线性系统的第 $k$ 个方程。矩阵 $A$ 和向量 $\\mathbf{b}$ 的组装方式如下：\n- 对角线元素为 $A_{k,k} = 4$。\n- 右侧向量的元素 $b_k$ 初始化为 $0$。\n- 对于 $(i,j)$ 的四个邻居中的每一个，设其索引为 $(i', j')$：\n    - 如果邻居也是一个索引为 $p$ 的未知节点，我们设置非对角线元素 $A_{k,p} = -1$。\n    - 如果邻居是一个边界节点（内部或外部），其值 $u_{i',j'}$ 是已知的。这个已知值被移到方程的右侧。因此，我们将其值加到 $b_k$上：$b_k \\leftarrow b_k + u^{\\star}(x_{i'}, y_{j'})$。\n\n得到的矩阵 $A$ 是稀疏、对称且对角占优的，这保证了唯一解的存在。使用稀疏线性代数求解器可以高效地求解该系统以得到 $\\mathbf{u}_{\\text{unk}}$。\n\n在所有未知节点上获得数值解 $u_{i,j}$ 后，计算最大绝对误差 $E_{\\infty}$ 以评估该方法的准确性。该误差是相对于已知的人造解 $u^{\\star}$ 计算的：\n$$\nE_{\\infty} = \\max_{(i,j) \\in \\mathcal{U}} | u_{i,j} - u^{\\star}(x_i,y_j) |\n$$\n其中 $\\mathcal{U}$ 是对应于所有未知节点的索引集合。此过程被实现并应用于指定的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom scipy.ndimage import binary_dilation\n\ndef solve_one_case(N, xc, yc, r):\n    \"\"\"\n    Solves the 2D Laplace equation on a square domain with a circular hole\n    for a single set of parameters.\n    \"\"\"\n    # Node type constants\n    HOLE = -1\n    UNKNOWN = 0\n    BOUNDARY = 1\n\n    # 1. Grid Generation and Node Classification\n    x = np.linspace(-1, 1, N)\n    y = np.linspace(-1, 1, N)\n    xx, yy = np.meshgrid(x, y, indexing='ij')\n\n    node_type = np.full((N, N), UNKNOWN, dtype=int)\n\n    # Classify hole nodes\n    is_hole = (xx - xc)**2 + (yy - yc)**2  r**2\n    node_type[is_hole] = HOLE\n\n    # Classify boundary nodes (both external and internal)\n    is_boundary = np.zeros_like(node_type, dtype=bool)\n    \n    # External boundaries\n    is_boundary[0, :] = True\n    is_boundary[N - 1, :] = True\n    is_boundary[:, 0] = True\n    is_boundary[:, N - 1] = True\n    \n    # Internal boundaries (nodes adjacent to the hole)\n    # A 5-point cross-shaped structuring element identifies cardinal neighbors.\n    struct = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=bool)\n    dilated_hole = binary_dilation(is_hole, structure=struct)\n    is_internal_boundary = dilated_hole  ~is_hole\n    is_boundary |= is_internal_boundary\n\n    # Apply boundary classification, ensuring hole nodes are not overwritten.\n    node_type[is_boundary  ~is_hole] = BOUNDARY\n\n    # 2. Map unknown nodes to linear indices for the linear system\n    unknown_indices = np.where(node_type == UNKNOWN)\n    num_unknowns = len(unknown_indices[0])\n    \n    map_ij_to_k = { (i, j): k for k, (i, j) in enumerate(zip(*unknown_indices)) }\n\n    # 3. Assemble the linear system Ax = b\n    # LIL format is efficient for building the sparse matrix\n    A = lil_matrix((num_unknowns, num_unknowns), dtype=float)\n    b = np.zeros(num_unknowns, dtype=float)\n    \n    u_exact = np.exp(xx) * np.cos(yy)\n\n    for k in range(num_unknowns):\n        i, j = unknown_indices[0][k], unknown_indices[1][k]\n        \n        # Diagonal term from the 5-point stencil\n        A[k, k] = 4.0\n        \n        # Consider the four cardinal neighbors\n        for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            neighbor_type = node_type[ni, nj]\n            \n            if neighbor_type == UNKNOWN:\n                # Off-diagonal term for an unknown neighbor\n                p = map_ij_to_k[(ni, nj)]\n                A[k, p] = -1.0\n            elif neighbor_type == BOUNDARY:\n                # Known value from a boundary neighbor contributes to the RHS\n                b[k] += u_exact[ni, nj]\n\n    # 4. Solve the sparse linear system\n    # Convert to CSR format for efficient solving\n    A_csr = A.tocsr()\n    u_vec_numeric = spsolve(A_csr, b)\n\n    # 5. Compute the maximum absolute error\n    u_vec_exact = u_exact[unknown_indices]\n    max_abs_error = np.max(np.abs(u_vec_numeric - u_vec_exact))\n    \n    return max_abs_error\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, xc, yc, r)\n        (65, 0.2, -0.1, 0.35),\n        (65, 0.0, 0.0, 0.12),\n        (33, -0.3, 0.4, 0.30),\n        (97, 0.55, 0.0, 0.40),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_one_case(*case)\n        results.append(error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{e:.8e}' for e in results)}]\")\n\nsolve()\n```", "id": "2392562"}, {"introduction": "随着问题变得更加复杂，我们需要更高级的数值格式，例如交替方向隐式（ADI）格式。这个练习 [@problem_id:2392607] 探讨了当扩散方程包含混合导数项时，ADI格式的稳定性问题。你将通过推导放大因子，并编写程序来数值化地搜索其最大模，学习如何分析和验证高级数值格式的稳定性，这是开发和评估新算法时的一项关键能力。", "problem": "考虑在两个方向上间距相等的均匀笛卡尔网格上，具有常系数和混合二阶导数的二维扩散方程，该方程由以下偏微分方程控制\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^{2} u}{\\partial x^{2}} + \\beta \\frac{\\partial^{2} u}{\\partial y^{2}} + \\gamma \\frac{\\partial^{2} u}{\\partial x \\partial y},\n$$\n其中 $u = u(x,y,t)$，$\\alpha  0$，$\\beta  0$，$\\gamma \\in \\mathbb{R}$，空间步长 $h  0$，时间步长 $\\Delta t  0$。假设网格均匀、边界为周期性，并且所有二阶导数均使用中心差分近似，包括纯二阶导数的标准$5$点格式和混合导数的标准$4$点中心格式。定义无量纲比率 $r = \\Delta t / h^{2}$，$r_{x} = \\alpha r$，$r_{y} = \\beta r$ 和 $r_{xy} = \\gamma r$。考虑以下交替方向隐式 (ADI) 格式，该格式在每半步中都显式处理混合导数项：\n- 第一半步：\n$$\n\\left(I - \\frac{\\Delta t}{2} \\,\\alpha D_{xx}^{h}\\right) u^{\\star} = \\left(I + \\frac{\\Delta t}{2}\\, \\beta D_{yy}^{h}\\right) u^{n} + \\frac{\\Delta t}{2}\\, \\gamma D_{xy}^{h} \\, u^{n}.\n$$\n- 第二半步：\n$$\n\\left(I - \\frac{\\Delta t}{2} \\,\\beta D_{yy}^{h}\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2}\\, \\alpha D_{xx}^{h}\\right) u^{\\star} + \\frac{\\Delta t}{2}\\, \\gamma D_{xy}^{h} \\, u^{\\star}.\n$$\n此处，$D_{xx}^{h}$、$D_{yy}^{h}$ 和 $D_{xy}^{h}$ 分别表示在间距为 $h$ 的均匀网格上，对应于 $\\partial^{2}/\\partial x^{2}$、$\\partial^{2}/\\partial y^{2}$ 和 $\\partial^{2}/\\partial x \\partial y$ 的标准中心差分算子。假设为无限周期网格，以便应用傅里叶 (von Neumann) 分析。\n\n任务：\n- 从 von Neumann (傅里叶) 稳定性分析的定义和均匀网格上中心差分算子的符号出发，推导单个傅里叶模态的标量放大因子 $G(\\theta_{x}, \\theta_{y}; r_{x}, r_{y}, r_{xy})$，其中 $\\theta_{x}$ 和 $\\theta_{y}$ 分别是 $x$ 和 $y$ 方向上的无量纲波数，均在区间 $[-\\pi, \\pi]$ 内。\n- 用放大因子陈述稳定性条件，并解释 $r_{x}$、$r_{y}$ 和 $r_{xy}$ 的作用。\n- 设计一个算法，对于给定的 $(\\alpha,\\beta,\\gamma,r)$，通过在 $N \\times N$（其中 $N=801$）点的方形网格上进行均匀采样，计算在 $(\\theta_{x},\\theta_{y}) \\in [-\\pi,\\pi] \\times [-\\pi,\\pi]$ 上的放大因子的最大模。使用此最大值，通过条件 $\\max_{\\theta_{x},\\theta_{y}} |G| \\le 1$ 来判断稳定性。\n- 本问题中无需报告物理单位；所有量根据其构造都是无量纲的。\n\n测试套件：\n- 使用以下四组参数集 $(\\alpha,\\beta,\\gamma,r)$：\n    - 情况 1：$(1.0, 1.0, 0.0, 5.0)$。\n    - 情况 2：$(1.0, 1.0, 1.0, 0.25)$。\n    - 情况 3：$(1.0, 1.0, 1.5, 4.0)$。\n    - 情况 4：$(1.0, 2.0, 1.8, 1.0)$。\n- 对每种情况，计算放大因子的最大模，并使用上述判据确定其稳定性。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于按给定顺序排列的每种情况，该列表必须首先包含四舍五入到六位小数的最大放大因子，然后是一个布尔稳定性指标。例如，输出格式必须为\n$$\n[\\text{max}_{1}, \\text{stable}_{1}, \\text{max}_{2}, \\text{stable}_{2}, \\text{max}_{3}, \\text{stable}_{3}, \\text{max}_{4}, \\text{stable}_{4}],\n$$\n的形式，其中每个 $\\text{max}_{k}$ 是一个小数点后有六位数的小数，每个 $\\text{stable}_{k}$ 是 $\\text{True}$ 或 $\\text{False}$。", "solution": "本问题要求对一个用于含混合导数项的二维扩散方程的特定交替方向隐式 (ADI) 格式进行严格的 von Neumann 稳定性分析。分析将系统地进行，从推导放大因子开始。\n\n首先，我们建立分析工具。von Neumann 分析假设计算网格上的解为单个傅里叶模态。对于时间 $t_n = n \\Delta t$ 时的网格点 $(x_j, y_k) = (j h, k h)$，此模态表示为：\n$$\nu_{j,k}^n = \\hat{u}^n e^{i(k_x x_j + k_y y_k)} = \\hat{u}^n e^{i(j \\theta_x + k \\theta_y)}\n$$\n其中 $\\hat{u}^n$ 是在时间步 $n$ 时模态的复振幅，$k_x$ 和 $k_y$ 是波数，而 $\\theta_x = k_x h$ 和 $\\theta_y = k_y h$ 是无量纲波数，且 $\\theta_x, \\theta_y \\in [-\\pi, \\pi]$。线性差分算子作用于此模态，等效于将其振幅乘以一个被称为算子符号的复数。\n\n我们现在推导指定的中心差分算子的符号。\n关于 $x$ 的二阶偏导数由 $D_{xx}^h$ 近似：\n$$\nD_{xx}^h u_{j,k}^n = \\frac{u_{j+1,k}^n - 2u_{j,k}^n + u_{j-1,k}^n}{h^2}\n$$\n将此应用于傅里叶模态，可得：\n$$\nD_{xx}^h \\left(\\hat{u}^n e^{ij\\theta_x} e^{ik\\theta_y}\\right) = \\frac{\\hat{u}^n e^{ik\\theta_y} (e^{i(j+1)\\theta_x} - 2e^{ij\\theta_x} + e^{i(j-1)\\theta_x})}{h^2} = \\left(\\frac{e^{i\\theta_x} - 2 + e^{-i\\theta_x}}{h^2}\\right) u_{j,k}^n\n$$\n因此，算子 $D_{xx}^h$ 的符号（记作 $\\widehat{D_{xx}^h}$）是：\n$$\n\\widehat{D_{xx}^h} = \\frac{2\\cos(\\theta_x) - 2}{h^2} = -\\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta_x}{2}\\right)\n$$\n根据对称性，$D_{yy}^h$ 的符号是：\n$$\n\\widehat{D_{yy}^h} = -\\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta_y}{2}\\right)\n$$\n混合导数由4点中心格式 $D_{xy}^h$ 近似：\n$$\nD_{xy}^h u_{j,k}^n = \\frac{u_{j+1,k+1}^n - u_{j+1,k-1}^n - u_{j-1,k+1}^n + u_{j-1,k-1}^n}{4h^2}\n$$\n此算子的符号 $\\widehat{D_{xy}^h}$ 推导如下：\n$$\n\\widehat{D_{xy}^h} = \\frac{e^{i(\\theta_x+\\theta_y)} - e^{i(\\theta_x-\\theta_y)} - e^{i(-\\theta_x+\\theta_y)} + e^{i(-\\theta_x-\\theta_y)}}{4h^2} = \\frac{(e^{i\\theta_x} - e^{-i\\theta_x})(e^{i\\theta_y} - e^{-i\\theta_y})}{4h^2} = \\frac{(2i\\sin\\theta_x)(2i\\sin\\theta_y)}{4h^2}\n$$\n$$\n\\widehat{D_{xy}^h} = -\\frac{\\sin\\theta_x \\sin\\theta_y}{h^2}\n$$\n请注意，这三个符号都是纯实数量。\n\n接下来，我们将 ADI 格式的两个半步变换到傅里叶空间。傅里叶模态在第 $n$ 步、中间步 $\\star$ 和第 $n+1$ 步的振幅分别表示为 $\\hat{u}^n$、$\\hat{u}^\\star$ 和 $\\hat{u}^{n+1}$。\n第一半步是：\n$$\n\\left(I - \\frac{\\Delta t}{2} \\alpha D_{xx}^{h}\\right) u^{\\star} = \\left(I + \\frac{\\Delta t}{2} \\beta D_{yy}^{h} + \\frac{\\Delta t}{2} \\gamma D_{xy}^{h}\\right) u^{n}\n$$\n在傅里叶空间中，这变成一个代数方程：\n$$\n\\left(1 - \\frac{\\Delta t}{2} \\alpha \\widehat{D_{xx}^h}\\right) \\hat{u}^{\\star} = \\left(1 + \\frac{\\Delta t}{2} \\beta \\widehat{D_{yy}^h} + \\frac{\\Delta t}{2} \\gamma \\widehat{D_{xy}^h}\\right) \\hat{u}^{n}\n$$\n第二半步是：\n$$\n\\left(I - \\frac{\\Delta t}{2} \\beta D_{yy}^{h}\\right) u^{n+1} = \\left(I + \\frac{\\Delta t}{2} \\alpha D_{xx}^{h} + \\frac{\\Delta t}{2} \\gamma D_{xy}^{h}\\right) u^{\\star}\n$$\n在傅里叶空间中：\n$$\n\\left(1 - \\frac{\\Delta t}{2} \\beta \\widehat{D_{yy}^h}\\right) \\hat{u}^{n+1} = \\left(1 + \\frac{\\Delta t}{2} \\alpha \\widehat{D_{xx}^h} + \\frac{\\Delta t}{2} \\gamma \\widehat{D_{xy}^h}\\right) \\hat{u}^{\\star}\n$$\n为简化起见，我们代入符号并使用无量纲比率 $r_x = \\alpha \\Delta t/h^2$、$r_y = \\beta \\Delta t/h^2$ 和 $r_{xy} = \\gamma \\Delta t/h^2$。\n我们定义以下实值项：\n$$\nA = \\frac{\\Delta t}{2} \\alpha \\widehat{D_{xx}^h} = \\frac{\\Delta t \\alpha}{2} \\left(-\\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta_x}{2}\\right)\\right) = -2 r_x \\sin^2\\left(\\frac{\\theta_x}{2}\\right)\n$$\n$$\nB = \\frac{\\Delta t}{2} \\beta \\widehat{D_{yy}^h} = \\frac{\\Delta t \\beta}{2} \\left(-\\frac{4}{h^2}\\sin^2\\left(\\frac{\\theta_y}{2}\\right)\\right) = -2 r_y \\sin^2\\left(\\frac{\\theta_y}{2}\\right)\n$$\n$$\nC = \\frac{\\Delta t}{2} \\gamma \\widehat{D_{xy}^h} = \\frac{\\Delta t \\gamma}{2} \\left(-\\frac{\\sin\\theta_x \\sin\\theta_y}{h^2}\\right) = -\\frac{r_{xy}}{2}\\sin\\theta_x\\sin\\theta_y\n$$\n使用这些定义，方程组简化为：\n$$\n(1 - A) \\hat{u}^{\\star} = (1 + B + C) \\hat{u}^{n}\n$$\n$$\n(1 - B) \\hat{u}^{n+1} = (1 + A + C) \\hat{u}^{\\star}\n$$\n放大因子是 $G = \\hat{u}^{n+1} / \\hat{u}^{n}$。我们通过消去 $\\hat{u}^\\star$ 来求解 $G$。从第一个方程可得 $\\hat{u}^{\\star} = \\frac{1+B+C}{1-A}\\hat{u}^{n}$。将其代入第二个方程得到：\n$$\n(1 - B) \\hat{u}^{n+1} = (1 + A + C) \\frac{1+B+C}{1-A}\\hat{u}^{n}\n$$\n因此，放大因子是：\n$$\nG(\\theta_x, \\theta_y) = \\frac{(1 + A + C)(1 + B + C)}{(1 - A)(1 - B)}\n$$\n将 $A$、$B$ 和 $C$ 的表达式代回此方程，得到放大因子的完整公式：\n$$\nG(\\theta_x, \\theta_y; r_x, r_y, r_{xy}) = \\frac{\\left(1 - 2r_x\\sin^2\\left(\\frac{\\theta_x}{2}\\right) - \\frac{r_{xy}}{2}\\sin\\theta_x\\sin\\theta_y\\right)\\left(1 - 2r_y\\sin^2\\left(\\frac{\\theta_y}{2}\\right) - \\frac{r_{xy}}{2}\\sin\\theta_x\\sin\\theta_y\\right)}{\\left(1 + 2r_x\\sin^2\\left(\\frac{\\theta_x}{2}\\right)\\right)\\left(1 + 2r_y\\sin^2\\left(\\frac{\\theta_y}{2}\\right)\\right)}\n$$\n该数值格式的稳定性由 von Neumann 判据决定，该判据要求对于任何傅里叶模态，放大因子的模都不能超过1：\n$$\n\\max_{\\theta_x, \\theta_y \\in [-\\pi, \\pi]} |G(\\theta_x, \\theta_y)| \\le 1\n$$\n参数 $r_x$ 和 $r_y$ 控制纯扩散项的强度。在这种 ADI 公式中，这些项在每个半步中在一个方向上是隐式处理，在另一个方向上是显式处理。如果混合导数项不存在（$\\gamma = 0$，因此 $r_{xy} = 0$），该格式将简化为 Peaceman-Rachford ADI 方法，该方法对于扩散方程是无条件稳定的（即，对于所有 $r_x, r_y  0$ 都有 $|G| \\le 1$）。\n然而，参数 $r_{xy}$ 对应于混合导数项，而在此特定格式的两个半步中，该项都是显式处理的。对导数项的显式处理通常会引入条件稳定性。因此，我们预计该格式的稳定性将取决于 $|r_{xy}|$ 的大小，并可能与 $r_x$ 和 $r_y$ 相关。一个较大的 $|r_{xy}|$ 值可能导致 $|G|  1$，从而引起不稳定性。\n\n评估给定参数集 $(\\alpha, \\beta, \\gamma, r)$ 的稳定性的算法如下：\n1.  计算无量纲比率 $r_x = \\alpha r$、$r_y = \\beta r$ 和 $r_{xy} = \\gamma r$。\n2.  在域 $[-\\pi, \\pi] \\times [-\\pi, \\pi]$ 上为 $(\\theta_x, \\theta_y)$ 定义一个 $N \\times N$ 点的离散均匀网格，其中 $N=801$。\n3.  对此网格上的每个点，使用推导出的公式计算放大因子 $G$。\n4.  计算每个网格点上 $G$ 的模 $|G|$。\n5.  确定整个网格上 $|G|$ 的最大值。这提供了 $\\max_{\\theta_x, \\theta_y} |G|$ 的数值估计。\n6.  将此最大模与 $1$ 进行比较。如果最大值小于或等于 $1$，则认为该格式对于给定的参数是稳定的。否则，它是不稳定的。\n将执行此程序来测试所给定的情况。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of determining the stability of an ADI scheme for a 2D diffusion\n    equation with a mixed derivative term.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (alpha, beta, gamma, r)\n        (1.0, 1.0, 0.0, 5.0),    # Case 1\n        (1.0, 1.0, 1.0, 0.25),   # Case 2\n        (1.0, 1.0, 1.5, 4.0),   # Case 3\n        (1.0, 2.0, 1.8, 1.0),   # Case 4\n    ]\n\n    results = []\n    \n    # Grid parameters for the von Neumann analysis\n    N = 801\n    theta_vals = np.linspace(-np.pi, np.pi, N)\n    THETA_X, THETA_Y = np.meshgrid(theta_vals, theta_vals)\n\n    # Pre-compute trigonometric terms for efficiency\n    SIN2_HALF_X = np.sin(THETA_X / 2)**2\n    SIN2_HALF_Y = np.sin(THETA_Y / 2)**2\n    SIN_X = np.sin(THETA_X)\n    SIN_Y = np.sin(THETA_Y)\n\n    for case in test_cases:\n        alpha, beta, gamma, r = case\n        \n        # Calculate dimensionless ratios\n        rx = alpha * r\n        ry = beta * r\n        rxy = gamma * r\n\n        # The amplification factor G is given by:\n        # G = ( (1 + A + C) * (1 + B + C) ) / ( (1 - A) * (1 - B) )\n        # where:\n        # A = -2 * rx * sin^2(theta_x / 2)\n        # B = -2 * ry * sin^2(theta_y / 2)\n        # C = -0.5 * rxy * sin(theta_x) * sin(theta_y)\n        \n        # Numerator calculation\n        # The terms in the numerator are (1 - 2*rx*S_x - C_xy) and (1 - 2*ry*S_y - C_xy)\n        c_xy_term = 0.5 * rxy * SIN_X * SIN_Y\n        \n        num_term_1 = 1.0 - 2.0 * rx * SIN2_HALF_X - c_xy_term\n        num_term_2 = 1.0 - 2.0 * ry * SIN2_HALF_Y - c_xy_term\n        numerator = num_term_1 * num_term_2\n        \n        # Denominator calculation\n        # The terms are (1 + 2*rx*S_x) and (1 + 2*ry*S_y)\n        den_term_1 = 1.0 + 2.0 * rx * SIN2_HALF_X\n        den_term_2 = 1.0 + 2.0 * ry * SIN2_HALF_Y\n        denominator = den_term_1 * den_term_2\n        \n        # Compute amplification factor over the grid\n        # Avoid division by zero, although with rx, ry > 0, denominator is >= 1\n        g_grid = numerator / denominator\n        \n        # Find the maximum modulus of the amplification factor\n        max_abs_g = np.max(np.abs(g_grid))\n        \n        # Determine stability based on the von Neumann criterion\n        is_stable = max_abs_g = 1.0\n        \n        results.append(f\"{max_abs_g:.6f}\")\n        results.append(str(is_stable))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2392607"}]}