{"hands_on_practices": [{"introduction": "高阶基函数的一个核心优势是能用更少的单元精确地表示复杂解。本练习将通过一个经典的流体动力学问题——泊肃叶流动——来展示这一优势。我们将看到，仅使用一个二次单元（$p=2$），有限元法就能精确捕捉到该问题的抛物线速度分布，而这是线性单元（$p=1$）无法做到的。[@problem_id:2399658]", "problem": "考虑在位于 $y=0$ 和 $y=H$ 的两个平行板之间，沿 $x$ 方向的稳态、充分发展的平面 Poiseuille 流。设恒定压力梯度为 $g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$，动力粘度为 $\\mu > 0$。轴向速度 $u(y)$ 满足一维边值问题\n$$-\\mu \\, u''(y) = g \\quad \\text{for } y \\in (0,H), \\qquad u(0)=0, \\quad u(H)=0.$$\n使用标准的 Galerkin 有限元法（FEM），在区间 $[0,H]$ 上使用一个多项式次数为 $p=2$ 的单个二次单元，并采用与节点 $y=0$、$y=H/2$ 和 $y=H$ 相关联的 Lagrange 基函数。在边界节点上强施加本质边界条件。\n\n确定通过此离散化产生的节点值的三分量向量 $\\big(u(0),\\,u(H/2),\\,u(H)\\big)$。将您的最终答案报告为一个无量纲的 $1 \\times 3$ 行向量，该向量通过将每个分量除以 $(g H^{2}/\\mu)$ 得到。无需进行数值四舍五入，报告的向量中也不应包含单位。", "solution": "首先对问题进行验证。\n\n**第 1 步：提取已知条件**\n- 控制方程：$-\\mu \\, u''(y) = g$，对于 $y \\in (0,H)$。\n- 常数：$g \\equiv -\\mathrm{d}p/\\mathrm{d}x > 0$ 和 $\\mu > 0$。\n- 边界条件：$u(0)=0$, $u(H)=0$。\n- 方法：标准 Galerkin 有限元法 (FEM)。\n- 离散化：在域 $[0,H]$ 上的一个二次单元（$p=2$）。\n- 节点坐标：$y=0$, $y=H/2$, $y=H$。\n- 基函数：与节点相关联的 Lagrange 基函数。\n- 边界条件施加：在边界节点上强施加。\n- 要求输出：节点值 $\\big(u(0), u(H/2), u(H)\\big)$ 在除以 $(g H^{2}/\\mu)$ 后的无量纲 $1 \\times 3$ 行向量。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学依据：** 该问题描述了平面 Poiseuille 流，这是流体动力学中的一个基本概念。控制方程是 Navier-Stokes 方程在这种流动状态下的一个有效简化。该问题在科学上是合理的。\n- **适定性：** 该问题是一个带 Dirichlet 边界条件的一维二阶椭圆边值问题。保证存在唯一且稳定的解。有限元格式也是标准且适定的。\n- **客观性：** 该问题使用精确的数学和物理术语进行陈述，没有任何主观性或模糊性。\n- **完整性和一致性：** 该问题提供了所有必要的信息（控制方程、域、边界条件和离散化细节），并且不包含内部矛盾。\n\n**第 3 步：结论与行动**\n该问题是有效的。它是一个在计算工程中明确定义的问题，具有科学依据、适定性和完整性。可以推导出严谨的解。\n\n边值问题的弱形式是通过将控制方程乘以一个来自合适空间的试函数 $v(y)$ 并在域 $\\Omega = (0,H)$ 上积分得到的。\n$$\n\\int_{0}^{H} -\\mu u''(y) v(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\n对左侧应用分部积分得到：\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy - \\big[ \\mu u'(y) v(y) \\big]_{0}^{H} = \\int_{0}^{H} g v(y) \\, dy\n$$\n试函数 $v(y)$ 必须属于积分有定义且满足齐次本质边界条件（即 $v(0)=0$ 和 $v(H)=0$）的函数空间。因此，边界项 $\\big[ \\mu u'(y) v(y) \\big]_{0}^{H}$ 为零。弱形式为：求满足本质边界条件的 $u(y)$，使得\n$$\n\\int_{0}^{H} \\mu u'(y) v'(y) \\, dy = \\int_{0}^{H} g v(y) \\, dy\n$$\n对所有容许的试函数 $v(y)$ 成立。\n\n在有限元法中，未知函数 $u(y)$ 由基函数的线性组合近似，$u_h(y) = \\sum_{j=1}^{3} U_j N_j(y)$，其中 $U_j$ 是未知的节点值，$N_j(y)$ 是基函数。问题指定了一个在节点 $y_1=0$, $y_2=H/2$ 和 $y_3=H$ 处的单个二次单元。满足 $N_j(y_i) = \\delta_{ij}$ 的相应 Lagrange 基函数是：\n$$\nN_1(y) = \\frac{(y - H/2)(y - H)}{(0 - H/2)(0 - H)} = \\frac{2}{H^2} \\left(y^2 - \\frac{3}{2}Hy + \\frac{H^2}{2}\\right)\n$$\n$$\nN_2(y) = \\frac{(y - 0)(y - H)}{(H/2 - 0)(H/2 - H)} = -\\frac{4}{H^2} (y^2 - Hy)\n$$\n$$\nN_3(y) = \\frac{(y - 0)(y - H/2)}{(H - 0)(H - H/2)} = \\frac{2}{H^2} \\left(y^2 - \\frac{1}{2}Hy\\right)\n$$\n问题陈述本质边界条件 $u(0)=0$ 和 $u(H)=0$ 被强施加。这意味着边界上的节点值是固定的：$U_1 = u(0) = 0$ 和 $U_3 = u(H) = 0$。速度场的近似简化为 $u_h(y) = U_2 N_2(y)$，因为包含 $N_1(y)$ 和 $N_3(y)$ 的项为零。\n\n在 Galerkin 方法中，试函数从与基函数相同的集合中选取。对于单个未知数 $U_2$，我们只需要一个方程，该方程通过选择试函数 $v(y) = N_2(y)$ 获得。这是唯一一个在内部节点非零且在边界处为零的基函数。将 $u_h(y)$ 和 $v(y)=N_2(y)$ 代入弱形式得到：\n$$\n\\int_{0}^{H} \\mu (U_2 N_2'(y)) (N_2'(y)) \\, dy = \\int_{0}^{H} g N_2(y) \\, dy\n$$\n这是一个关于未知数 $U_2$ 的单个线性方程：\n$$\n\\left( \\mu \\int_{0}^{H} (N_2'(y))^2 \\, dy \\right) U_2 = g \\int_{0}^{H} N_2(y) \\, dy\n$$\n我们必须计算这两个积分。首先是 $N_2(y)$ 的导数：\n$$\nN_2'(y) = \\frac{d}{dy}\\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) = -\\frac{8y}{H^2} + \\frac{4}{H}\n$$\n左侧的积分是：\n$$\n\\int_{0}^{H} (N_2'(y))^2 \\, dy = \\int_{0}^{H} \\left(\\frac{4}{H} - \\frac{8y}{H^2}\\right)^2 \\, dy = \\int_{0}^{H} \\left(\\frac{16}{H^2} - \\frac{64y}{H^3} + \\frac{64y^2}{H^4}\\right) \\, dy\n$$\n$$\n= \\left[ \\frac{16y}{H^2} - \\frac{32y^2}{H^3} + \\frac{64y^3}{3H^4} \\right]_{0}^{H} = \\frac{16}{H} - \\frac{32}{H} + \\frac{64}{3H} = \\left(16 - 32 + \\frac{64}{3}\\right)\\frac{1}{H} = \\left(-16 + \\frac{64}{3}\\right)\\frac{1}{H} = \\frac{-48+64}{3H} = \\frac{16}{3H}\n$$\n右侧的积分是：\n$$\n\\int_{0}^{H} N_2(y) \\, dy = \\int_{0}^{H} \\left(-\\frac{4y^2}{H^2} + \\frac{4y}{H}\\right) \\, dy = \\left[ -\\frac{4y^3}{3H^2} + \\frac{2y^2}{H} \\right]_{0}^{H} = -\\frac{4H}{3} + 2H = \\frac{2H}{3}\n$$\n将这些结果代回 $U_2$ 的方程中：\n$$\n\\left( \\mu \\frac{16}{3H} \\right) U_2 = g \\frac{2H}{3}\n$$\n求解 $U_2$：\n$$\nU_2 = \\frac{g \\cdot 2H/3}{\\mu \\cdot 16/(3H)} = \\frac{2gH}{3} \\cdot \\frac{3H}{16\\mu} = \\frac{6gH^2}{48\\mu} = \\frac{1}{8} \\frac{gH^2}{\\mu}\n$$\n节点值向量为 $\\big(U_1, U_2, U_3\\big) = \\left(0, \\frac{1}{8}\\frac{gH^2}{\\mu}, 0\\right)$。\n为得到所需的无量纲向量，每个分量都除以缩放因子 $(gH^2/\\mu)$：\n$$\n\\left( \\frac{0}{gH^2/\\mu}, \\frac{\\frac{1}{8}gH^2/\\mu}{gH^2/\\mu}, \\frac{0}{gH^2/\\mu} \\right) = \\left(0, \\frac{1}{8}, 0\\right)\n$$\n这个结果是精确的，因为该问题的解析解 $u(y) = \\frac{g}{2\\mu}(Hy - y^2)$ 是一个二次多项式，它可以被离散化中使用的二次基函数精确表示。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0 & \\frac{1}{8} & 0\n\\end{pmatrix}\n}\n$$", "id": "2399658"}, {"introduction": "高阶基函数虽然强大，但也对数值积分的精度提出了更高要求。在有限元方法中，单元刚度矩阵和载荷向量的计算都依赖于数值积分（通常是高斯积分）。本练习旨在通过编程实践，揭示当积分点数量不足以精确积分高阶多项式时会发生什么，即所谓的“混叠误差”。[@problem_id:2399644]", "problem": "您的任务是研究一维情况下使用高阶基函数时，由于积分不足（under-integration）而产生的混叠误差。考虑区间 $[-1,1]$ 上的 $p$ 次 Legendre 多项式，记为 $P_{p}(x)$，其中 $P_{0}(x)=1$ 且 $P_{p}(x)$ 满足 Legendre 多项式的标准三项递推关系。其内积为区间 $[-1,1]$ 上权重为 $1$ 的标准 $L^{2}$ 内积。多项式 $P_{p}(x)$ 的次数为 $p$。在 $[-1,1]$ 上使用 $n$ 个 Gauss-Legendre 点的 Gaussian Quadrature (GQ) 对于次数最高为 $2n-1$ 的所有多项式都是精确的。\n\n您的任务是编写一个程序，该程序：\n- 基于 $P_{p}(x)$ 的正交性和归一化，通过解析推导计算积分 $\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx$ 的精确值。\n- 使用 $[-1,1]$ 上的 $n$ 点 Gauss-Legendre 求积法近似计算相同的积分。\n- 将绝对混叠误差量化为求积近似值与精确值之间的绝对差。\n\n推导的基本依据：\n- Legendre 多项式 $\\{P_{k}(x)\\}_{k\\ge 0}$ 在区间 $[-1,1]$ 上构成一个关于权重 $1$ 的正交基。\n- $n$ 点 Gauss-Legendre 求积法对于次数至多为 $2n-1$ 的所有多项式都是精确的。\n\n在一个独立的、自包含的程序中实现该算法。对于解析值，不要使用任何数值积分；仅使用 $P_{p}(x)$ 作为 $L^{2}([-1,1])$ 中的基所具有的正交性和归一化性质。\n\n测试套件：\n- 使用以下 $(p,n)$ 对来测试一般、精确和积分不足（混叠）的情况：$(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$。\n- 对于每对 $(p,n)$，计算绝对误差 $E(p,n)=\\left|\\;\\text{GQ}_{n}\\left[\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\right]-\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx\\;\\right|$。\n- 将每个 $E(p,n)$ 报告为四舍五入到 $12$ 位小数的浮点数。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表的结果（例如，[$r_{1}$,$r_{2}$,$r_{3}$]），其顺序与上述测试套件的顺序相同。\n- 不应打印任何额外文本。\n\n角度单位不适用。不涉及物理单位。所有计算都是无量纲的。程序不得要求任何用户输入或外部文件，并且必须在标准环境中确定性地运行。", "solution": "我们从适用于一维高阶基函数的基本原理入手，特别是 Legendre 多项式和 Gaussian Quadrature (GQ)。Legendre 多项式 $\\{P_{p}(x)\\}_{p\\ge 0}$ 构成了一个在区间 $[-1,1]$ 上关于权重函数 $w(x)=1$ 的平方可积函数的完备正交基。正交性意味着对于整数 $p\\neq q$，\n$$\n\\int_{-1}^{1} P_{p}(x)\\,P_{q}(x)\\,dx=0.\n$$\n此外，$P_{p}(x)$ 是一个 $p$ 次多项式，按照惯例 $P_{0}(x)=1$ 和 $P_{p}(1)=1$ 进行归一化。$P_{p}$ 在 $[-1,1]$ 上的精确 $L^{2}$ 范数平方由经过充分检验的标准恒等式给出\n$$\n\\int_{-1}^{1} \\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\n这个归一化常数可以通过 Rodrigues 公式和分部积分法来证明。Rodrigues 公式表述为\n$$\nP_{p}(x)=\\frac{1}{2^{p}p!}\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}.\n$$\n于是\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left[\\frac{d^{p}}{dx^{p}}\\left(x^{2}-1\\right)^{p}\\right]P_{p}(x)\\,dx.\n$$\n进行 $p$ 次分部积分，将导数从 $\\left(x^{2}-1\\right)^{p}$ 移到 $P_{p}(x)$ 上，边界项的贡献为零，因为 $\\left(x^{2}-1\\right)^{p}$ 在 $x=\\pm 1$ 处有 $p$ 阶零点。这得到\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\frac{d^{p}}{dx^{p}}P_{p}(x)\\,dx.\n$$\n由于 $P_{p}(x)$ 是一个 $p$ 次多项式，其首项系数为 $\\frac{1}{2^{p}}\\binom{2p}{p}$，它的 $p$ 阶导数是一个常数\n$$\n\\frac{d^{p}}{dx^{p}}P_{p}(x)=p!\\cdot\\frac{1}{2^{p}}\\binom{2p}{p}=\\frac{(2p)!}{2^{p}p!}.\n$$\n因此，\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{1}{(2^{p}p!)^{2}}\\cdot\\frac{(2p)!}{2^{p}p!}\\int_{-1}^{1}\\left(x^{2}-1\\right)^{p}\\,dx.\n$$\n利用被积函数的偶性、Beta 函数恒等式或直接计算，可以得到闭式解\n$$\n\\int_{-1}^{1}\\left(P_{p}(x)\\right)^{2}\\,dx=\\frac{2}{2p+1}.\n$$\n这个精确值将作为解析基准。\n\n接下来，考虑在 $[-1,1]$ 上的 $n$ 点 Gauss-Legendre 求积法。Gauss-Legendre 求积法的一个基本性质是对于次数至多为 $2n-1$ 的多项式是精确的。函数 $f(x)=\\left(P_{p}(x)\\right)^{2}$ 是一个 $2p$ 次多项式。因此：\n- 如果 $2p\\le 2n-1$，即 $n\\ge p+1$，则求积法对 $f$ 是精确的，数值积分值在舍入误差范围内等于解析值 $\\frac{2}{2p+1}$。\n- 如果 $2p>2n-1$，即 $n\\le p$，则求积法对 $f$ 积分不足。在这种积分不足的情况下，求积法则无法精确表示 $f$ 的高次分量，这些分量在离散意义上有效地混叠到低次模态中。这就是混叠误差：求积法返回的是 $f$ 在次数至多为 $2n-1$ 的多项式内的最佳逼近的精确积分，而不是 $f$ 的真实积分。\n\n算法规划：\n- 对于给定的整数 $p$ 和 $n$，定义 $f(x)=\\left(P_{p}(x)\\right)^{2}$。\n- 计算精确值 $I_{\\text{exact}}(p)=\\frac{2}{2p+1}$。\n- 计算 $[-1,1]$ 上的 $n$ 点 Gauss-Legendre 求积节点 $\\{x_{i}\\}_{i=1}^{n}$ 和权重 $\\{w_{i}\\}_{i=1}^{n}$。计算\n$$\nI_{\\text{GQ}}(p,n)=\\sum_{i=1}^{n}w_{i}\\,f(x_{i}).\n$$\n- 报告绝对误差 $E(p,n)=\\left|I_{\\text{GQ}}(p,n)-I_{\\text{exact}}(p)\\right|$。\n\n实现细节：\n- 使用稳定的 Legendre 多项式基函数求值程序来计算 $P_{p}(x)$；在代码中，可以使用 $P_{p}(x)$ 的基表示和求值函数。\n- 通过编程方式获取 Gauss-Legendre 节点和权重。\n- 对于测试套件 $(p,n)\\in\\{(0,1),(1,1),(1,2),(3,3),(3,4),(5,5),(5,6),(10,5),(10,11)\\}$，计算 $E(p,n)$ 并按顺序打印它们，每个值四舍五入到 $12$ 位小数时，作为一个单一的、用方括号括起来的逗号分隔列表。\n\n预期的定性行为：\n- $n\\ge p+1$ 的情况应产生接近机器精度的误差，当四舍五入到 $12$ 位小数时，约为 $0$。\n- $n\\le p$ 的情况会表现出非零的混叠误差，因为 $2p>2n-1$。\n\n这种方法将高阶基函数 $P_{p}(x)$、Gaussian Quadrature 的精确度性质以及当求积阶数不足以精确积分基函数的平方时混叠误差的表现直接联系起来。", "answer": "```python\nimport numpy as np\nfrom numpy.polynomial.legendre import leggauss, legval\n\ndef legendre_P(p, x):\n    \"\"\"\n    Evaluate the Legendre polynomial P_p(x) at x using numpy's Legendre basis.\n    \"\"\"\n    # Coefficients in the Legendre basis: c[k] corresponds to P_k(x).\n    c = np.zeros(p + 1, dtype=float)\n    c[p] = 1.0\n    return legval(x, c)\n\ndef exact_integral_Pp_squared(p):\n    \"\"\"\n    Exact value of the integral of (P_p(x))^2 over [-1,1]:\n        ∫_{-1}^{1} (P_p(x))^2 dx = 2 / (2p + 1)\n    \"\"\"\n    return 2.0 / (2 * p + 1)\n\ndef gauss_legendre_integral_Pp_squared(p, n):\n    \"\"\"\n    Compute the n-point Gauss-Legendre quadrature of (P_p(x))^2 over [-1,1].\n    \"\"\"\n    x, w = leggauss(n)\n    P_vals = legendre_P(p, x)\n    f_vals = P_vals * P_vals\n    return np.dot(w, f_vals)\n\ndef solve():\n    # Define the test cases (p, n) as specified in the problem statement.\n    test_cases = [\n        (0, 1),\n        (1, 1),\n        (1, 2),\n        (3, 3),\n        (3, 4),\n        (5, 5),\n        (5, 6),\n        (10, 5),\n        (10, 11),\n    ]\n\n    results = []\n    for p, n in test_cases:\n        I_exact = exact_integral_Pp_squared(p)\n        I_quad = gauss_legendre_integral_Pp_squared(p, n)\n        err = abs(I_quad - I_exact)\n        # Round to 12 decimal places as required\n        results.append(f\"{err:.12f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2399644"}, {"introduction": "理解基函数的近似能力，不仅要看它们如何处理光滑函数，还要看它们在面对不连续函数时的表现。本练习将探讨一个著名现象——吉布斯现象，即当使用全局多项式逼近一个有跳跃间断的函数时，在间断点附近会出现顽固的超调。我们将通过对一个阶跃函数进行 $L^2$ 投影，来量化这个超调的大小，并观察它如何随多项式阶次 $p$ 的变化而变化。[@problem_id:2399650]", "problem": "您将编写一个完整的、可运行的程序，该程序构建一个不连续函数在某个一维多项式子空间上的平方可积（勒贝格 $L^2$）正交投影，然后量化不连续点附近产生的类吉布斯过冲（Gibbs-like overshoot）与多项式阶数的关系。工作在参考区间 $[-1,1]$ 上。考虑阶跃函数 $f:[-1,1]\\to\\mathbb{R}$，定义为当 $x < 0$ 时 $f(x)=0$，当 $x\\ge 0$ 时 $f(x)=1$。对于给定的非负整数阶 $p$，定义多项式子空间 $\\mathcal{P}_p$ 为所有次数至多为 $p$ 的实多项式的集合。在 $[-1,1]$ 上使用等于 $1$ 的权重函数，将 $f$ 的 $L^2$ 投影 $u_p\\in \\mathcal{P}_p$ 定义为在所有 $u\\in\\mathcal{P}_p$ 中使 $L^2$ 误差 $\\|f-u\\|_{L^2([-1,1])}$ 最小化的唯一元素。在 $[-1,1]$ 上的勒让德多项式 $\\{P_n\\}_{n=0}^p$ 的模态基中表示 $u_p$，这些多项式在单位权重的 $L^2$ 内积下是正交的。仅从勒让德多项式的正交性和 $L^2$ 投影的定义出发，推导 $u_p$ 在此基下的系数。不要使用任何预先推导出的投影公式；推导过程必须遵循正交关系和投影的定义。然后，在一个均匀网格上计算 $u_p$，以测量在 $x=0$ 处跳跃点附近的类吉布斯过冲。对于固定的窗口半宽 $w=0.2$，定义右邻域 $\\Omega_R=(0,w]$ 和左邻域 $\\Omega_L=[-w,0)$。在一个覆盖 $[-w,w]$ 的包含 $M=20001$ 个点的均匀网格上，计算过冲幅度\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\}.\n$$\n您的程序必须对指定测试集中的每个阶数 $p$ 执行以下步骤：通过 $L^2$ 投影到勒让德基中的 $\\mathcal{P}_p$ 来构建 $u_p$，在指定的网格上计算 $u_p$，并如上定义计算 $\\Gamma_p$。使用以下多项式阶数测试集：$\\{0,1,3,5,10,20\\}$。所有计算都是无量纲的；不涉及任何物理单位。最终输出格式必须是单行，包含一个 Python 浮点值列表 $[\\Gamma_{p_1},\\Gamma_{p_2},\\dots]$，按 $[0,1,3,5,10,20]$ 的阶数顺序对应。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如 $[r_1,r_2,r_3,r_4,r_5,r_6]$）。每个 $p$ 的结果必须是浮点数。通过遵守上述精确定义来确保科学真实性，并设计您的计算，使其在指定的网格参数 $w=0.2$ 和 $M=20001$ 个点下是数值稳定且可复现的。算法必须能够从勒让德多项式的正交性和 $L^2$ 投影的定义中推导出来，而不能在问题陈述中引入任何外部的快捷公式。", "solution": "该问题要求构建和分析一个不连续函数在某个一维多项式空间上的 $L^2$ 正交投影。目标是量化吉布斯现象，具体来说是 $x=0$ 处不连续点附近的过冲，并将其作为多项式阶数 $p$ 的函数。\n\n待逼近的函数是阶跃函数 $f:[-1,1] \\to \\mathbb{R}$，定义为\n$$\nf(x) = \\begin{cases} 0 & \\text{if } x < 0 \\\\ 1 & \\text{if } x \\ge 0 \\end{cases}\n$$\n我们寻求其在次数至多为 $p$ 的多项式子空间 $\\mathcal{P}_p$ 上的 $L^2$ 投影，记为 $u_p$。空间 $\\mathcal{P}_p$ 是希尔伯特空间 $L^2([-1, 1])$ 的一个子空间，该空间配备了内积 $(g, h) = \\int_{-1}^{1} g(x)h(x)dx$ 和范数 $\\|g\\|_{L^2} = \\sqrt{(g, g)}$。根据定义，投影 $u_p \\in \\mathcal{P}_p$ 是在所有可能的 $u_p \\in \\mathcal{P}_p$ 选择中，使误差范数 $\\|f-u_p\\|_{L^2}$ 最小化的唯一元素。\n\n$L^2$ 投影的一个基本性质是误差向量 $f-u_p$ 与子空间 $\\mathcal{P}_p$ 正交。这被称为伽辽金正交性条件（Galerkin orthogonality condition）：\n$$\n(f - u_p, v) = 0, \\quad \\forall v \\in \\mathcal{P}_p.\n$$\n我们将逼近 $u_p(x)$ 表示在勒让德多项式基 $\\{P_n(x)\\}_{n=0}^p$ 中，这些多项式在区间 $[-1, 1]$ 上对于权重函数 $1$ 是正交的。展开式为\n$$\nu_p(x) = \\sum_{n=0}^{p} \\hat{f}_n P_n(x),\n$$\n其中系数 $\\{\\hat{f}_n\\}_{n=0}^p$ 待定。由于勒让德多项式 $\\{P_k(x)\\}_{k=0}^p$ 构成 $\\mathcal{P}_p$ 的一个基，伽辽金条件当且仅当误差与每个基函数正交时才满足：\n$$\n(f - u_p, P_k) = 0, \\quad \\text{for } k=0, 1, \\dots, p.\n$$\n将 $u_p$ 的展开式代入此方程，我们得到：\n$$\n\\left(f - \\sum_{n=0}^{p} \\hat{f}_n P_n, P_k\\right) = 0.\n$$\n根据内积的线性性质：\n$$\n(f, P_k) - \\sum_{n=0}^{p} \\hat{f}_n (P_n, P_k) = 0.\n$$\n现在我们使用勒让德多项式的正交关系：\n$$\n(P_n, P_k) = \\int_{-1}^{1} P_n(x) P_k(x) dx = \\frac{2}{2n+1}\\delta_{nk},\n$$\n其中 $\\delta_{nk}$ 是克罗内克（Kronecker）δ函数。由于只有当 $n=k$ 时项才非零，所以求和式简化为：\n$$\n(f, P_k) - \\hat{f}_k (P_k, P_k) = 0 \\implies (f, P_k) - \\hat{f}_k \\frac{2}{2k+1} = 0.\n$$\n求解系数 $\\hat{f}_k$ 可得投影系数的通用公式：\n$$\n\\hat{f}_k = \\frac{2k+1}{2} (f, P_k) = \\frac{2k+1}{2} \\int_{-1}^{1} f(x)P_k(x) dx.\n$$\n该推导直接源于 $L^2$ 投影的定义和基的正交性，符合问题陈述的要求。\n\n接下来，我们计算指定阶跃函数 $f(x)$ 的系数。积分变为：\n$$\n\\int_{-1}^{1} f(x)P_k(x) dx = \\int_{-1}^{0} (0) \\cdot P_k(x) dx + \\int_{0}^{1} (1) \\cdot P_k(x) dx = \\int_{0}^{1} P_k(x) dx.\n$$\n因此，系数由 $\\hat{f}_k = \\frac{2k+1}{2} \\int_{0}^{1} P_k(x) dx$ 给出。为了计算这个积分，我们使用对 $k \\ge 1$ 成立的勒让德多项式恒等式：$(2k+1)P_k(x) = P'_{k+1}(x) - P'_{k-1}(x)$。从 $0$ 到 $1$ 积分：\n$$\n\\int_{0}^{1} (2k+1)P_k(x) dx = \\left[ P_{k+1}(x) - P_{k-1}(x) \\right]_0^1.\n$$\n$$\n(2k+1)\\int_{0}^{1} P_k(x) dx = (P_{k+1}(1) - P_{k-1}(1)) - (P_{k+1}(0) - P_{k-1}(0)).\n$$\n使用对所有 $n \\ge 0$ 都成立的性质 $P_n(1) = 1$，第一项消失：$1-1=0$。这对于 $k \\ge 1$ 给出：\n$$\n\\int_{0}^{1} P_k(x) dx = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}.\n$$\n将此结果代回 $\\hat{f}_k$ 的公式中：\n$$\n\\hat{f}_k = \\frac{2k+1}{2} \\left(\\frac{P_{k-1}(0) - P_{k+1}(0)}{2k+1}\\right) = \\frac{P_{k-1}(0) - P_{k+1}(0)}{2}, \\quad \\text{for } k \\ge 1.\n$$\n对于基例 $k=0$，我们直接计算：\n$$\n\\hat{f}_0 = \\frac{2(0)+1}{2} \\int_{0}^{1} P_0(x) dx = \\frac{1}{2} \\int_{0}^{1} 1 dx = \\frac{1}{2}.\n$$\n我们还知道，对于所有奇数 $n$，$P_n(0) = 0$。因此，对于偶数索引 $k \\ge 2$， $k-1$ 和 $k+1$ 都是奇数，这意味着 $P_{k-1}(0)=0$ 和 $P_{k+1}(0)=0$。所以，对于所有偶数 $k \\ge 2$，$\\hat{f}_k = 0$。\n总之，系数为：\n$$\n\\hat{f}_k = \\begin{cases} 1/2 & \\text{if } k = 0 \\\\ 0 & \\text{if } k \\ge 2 \\text{ is even} \\\\ \\frac{P_{k-1}(0) - P_{k+1}(0)}{2} & \\text{if } k \\text{ is odd} \\end{cases}\n$$\n有了这些系数，对于任何阶数 $p$，多项式逼近 $u_p(x)$ 就被完全定义了。\n\n最后一步是为给定的阶数 $p \\in \\{0, 1, 3, 5, 10, 20\\}$ 量化过冲幅度 $\\Gamma_p$。在区间 $[-w, w]$（其中 $w=0.2$）上生成一个包含 $M=20001$ 个点的均匀网格。在网格的每个点上计算逼近 $u_p(x)$。然后根据以下公式计算过冲：\n$$\n\\Gamma_p=\\max\\left\\{\\max_{x\\in\\Omega_R}\\left(u_p(x)-1\\right),\\ \\max_{x\\in\\Omega_L}\\left(-u_p(x)\\right),\\ 0\\right\\},\n$$\n其中 $\\Omega_R=(0, w]$ 和 $\\Omega_L=[-w, 0)$。最终答案中实现的算法计算这些系数，为每个指定的阶数构建 $u_p(x)$，在网格上对其求值，并通过找到不连续点左右邻域中的最大偏差来计算 $\\Gamma_p$。在外部的 $\\max$ 函数中包含 $0$ 可确保在出现下冲（或无过冲）的情况下，报告值为 $0$。", "answer": "```python\nimport numpy as np\nfrom scipy.special import eval_legendre\nfrom numpy.polynomial.legendre import Legendre\n\ndef solve():\n    \"\"\"\n    Computes the Gibbs-like overshoot for the L2 projection of a step function\n    onto polynomial subspaces of varying degrees.\n    \"\"\"\n    # Define the test cases (polynomial degrees) from the problem statement.\n    test_cases = [0, 1, 3, 5, 10, 20]\n\n    # Grid parameters for overshoot evaluation\n    w = 0.2\n    M = 20001\n    \n    # Generate the grid on which the approximation is evaluated.\n    x_grid = np.linspace(-w, w, M)\n    results = []\n\n    for p in test_cases:\n        # Step 1: Compute coefficients of the L2 projection in the Legendre basis.\n        # This implementation follows the derivation from first principles.\n        coeffs = np.zeros(p + 1)\n        \n        # Coefficient for k=0 is always 0.5 for this step function.\n        coeffs[0] = 0.5\n        \n        # Coefficients for k > 0.\n        if p > 0:\n            for k in range(1, p + 1):\n                if k % 2 == 1:  # k is odd\n                    # Formula from derivation: f_hat_k = (P_{k-1}(0) - P_{k+1}(0)) / 2\n                    p_km1_at_0 = eval_legendre(k - 1, 0)\n                    p_kp1_at_0 = eval_legendre(k + 1, 0)\n                    coeffs[k] = (p_km1_at_0 - p_kp1_at_0) / 2.0\n                else:  # k is even and k >= 2. The coefficient is 0.\n                    coeffs[k] = 0.0\n        \n        # Step 2: Construct the polynomial approximation u_p(x) using the coefficients.\n        # The Legendre class from numpy.polynomial creates a callable polynomial object.\n        u_p = Legendre(coeffs, domain=[-1, 1])\n        \n        # Step 3: Evaluate u_p on the specified grid near the discontinuity.\n        u_p_vals = u_p(x_grid)\n        \n        # Step 4: Compute the overshoot magnitude Gamma_p.\n        # The problem defines Omega_R = (0, w] and Omega_L = [-w, 0).\n        # Using boolean masks correctly partitions the grid according to these definitions.\n        \n        # Right-neighborhood Omega_R = (0, w]\n        mask_R = x_grid > 0\n        u_p_R = u_p_vals[mask_R]\n        \n        if u_p_R.size > 0:\n            overshoot_R = np.max(u_p_R - 1.0)\n        else:\n            # This case would occur if the grid had no points > 0.\n            overshoot_R = -np.inf\n\n        # Left-neighborhood Omega_L = [-w, 0)\n        mask_L = x_grid  0\n        u_p_L = u_p_vals[mask_L]\n        \n        if u_p_L.size > 0:\n            overshoot_L = np.max(-u_p_L)\n        else:\n            # This case would occur if the grid had no points  0.\n            overshoot_L = -np.inf\n        \n        # Gamma_p is the maximum of the right overshoot, left overshoot, and zero.\n        # The max with zero ensures no negative value is reported (i.e., accounts for undershoot).\n        gamma_p = np.max([overshoot_R, overshoot_L, 0.0])\n        results.append(gamma_p)\n\n    # Final print statement must be in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2399650"}]}