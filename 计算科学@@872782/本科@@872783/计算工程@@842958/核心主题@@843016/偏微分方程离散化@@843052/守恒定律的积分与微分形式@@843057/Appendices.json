{"hands_on_practices": [{"introduction": "我们首先从一个稳态扩散问题入手。这个练习要求你应用质量守恒原理，来确定通过一个复合介质的恒定溶质通量。通过这个分析过程，你将体会到在一维稳态无源系统中，积分形式的守恒律如何简化为通量恒定的结论，这是一个运用第一性原理分析多区域输运问题的绝佳范例。[@problem_id:2404179]", "problem": "一种溶质在一个横截面积恒定的长直通道中扩散。设轴向坐标为 $x$，左边界位于 $x=-L_1$，右边界位于 $x=+L_2$，其中 $L_1>0$ 且 $L_2>0$。区域 $-L_1 \\le x  0$ 填充有扩散系数为常数 $D_10$ 的介质，区域 $0  x \\le L_2$ 填充有另一种扩散系数为常数 $D_20$ 的介质。在 $x=0$ 处，有一张厚度可忽略的理想半透膜，其单位面积的法向摩尔通量与膜两侧的浓度跳跃成线性正比。具体而言，如果 $c(0^-)$ 和 $c(0^+)$ 分别表示从膜的左侧和右侧趋近的极限浓度，那么膜通量定律为\n$$\nJ = P\\big(c(0^-) - c(0^+)\\big),\n$$\n其中膜渗透率 $P0$。系统中没有溶质的体积源或汇，且系统处于稳态。边界浓度固定为 $c(-L_1)=c_1$ 和 $c(L_2)=c_2$，其中 $c_1$ 和 $c_2$ 是给定的常数。\n\n假设在每个均质区域内为一维输运，遵循质量守恒和菲克扩散定律。定义通量的正方向为从左到右。请确定稳态下单位面积的摩尔通量 $J$ 的一个闭式符号表达式，该表达式用 $c_1$、$c_2$、$L_1$、$L_2$、$D_1$、$D_2$ 和 $P$ 表示。请以 $J$ 的单个解析表达式形式提供您的答案，不要代入数值，且最终表达式中不包含单位。", "solution": "首先必须对问题陈述进行严格的验证过程，以确保其科学上合理、适定且客观。\n\n步骤1：提取已知条件\n问题陈述中提供了以下信息：\n- 区域：沿坐标 $x$ 的一维通道，从 $x=-L_1$ 到 $x=+L_2$，其中 $L_10$ 且 $L_20$。\n- 区域1：$-L_1 \\le x  0$，扩散系数为常数 $D_10$。\n- 区域2：$0  x \\le L_2$，扩散系数为常数 $D_20$。\n- $x=0$ 处的界面：一张厚度可忽略的半透膜。\n- 膜通量定律：穿过膜的单位面积摩尔通量为 $J = P\\big(c(0^-) - c(0^+)\\big)$，其中 $P0$ 是膜渗透率，$c(0^-)$ 和 $c(0^+)$ 分别是膜左右两侧的极限浓度。\n- 体积源/汇：无。\n- 系统状态：稳态。\n- 边界条件：固定浓度 $c(-L_1)=c_1$ 和 $c(L_2)=c_2$。\n- 控制物理学：在每个均质区域内为一维输运，遵循质量守恒和菲克扩散定律。\n- 目标：确定稳态下单位面积摩尔通量 $J$ 的闭式符号表达式。\n\n步骤2：使用提取的已知条件进行验证\n根据所需标准对问题进行评估：\n- **科学依据**：该问题基于质量输运的基本原理，特别是菲克扩散和质量守恒的概念。使用具有确定渗透率的半透膜是输运现象和化学工程中一个标准的、物理上现实的构造。该设置是一个典型的一维稳态扩散问题。\n- **适定性**：该问题是适定的。它描述了两个独立区域中的一个二阶常微分方程（稳态下的扩散方程）。为了找到唯一解，需要四个条件。问题提供了两个外部边界条件（$c(-L_1)=c_1$ 和 $c(L_2)=c_2$）和两个在 $x=0$ 处的界面条件（膜通量定律和通量连续性）。这是一组足以确定积分常数和未知通量的条件，从而得到一个唯一的稳定解。\n- **客观性**：问题以精确、定量和明确的语言陈述。所有参数（$L_1$、$L_2$、$D_1$、$D_2$、$P$、$c_1$、$c_2$）都得到了清晰的定义。\n\n该问题没有违反任何无效性标准。它在科学上是合理的，完全可以形式化，内部一致，物理上可信，并且结构良好。\n\n步骤3：结论与行动\n问题有效。将推导解答。\n\n基本原理是质量守恒。对于没有体积源或汇的一维稳态系统，质量守恒定律的微分形式是：\n$$\n\\frac{dJ}{dx} = 0\n$$\n该方程意味着单位面积的摩尔通量 $J$ 在整个区域（从 $x = -L_1$ 到 $x = L_2$）内是恒定的。\n\n在每个均质区域内，通量由菲克第一扩散定律描述。\n对于区域1（$-L_1 \\le x  0$）：\n$$\nJ = -D_1 \\frac{dc}{dx}\n$$\n对于区域2（$0  x \\le L_2$）：\n$$\nJ = -D_2 \\frac{dc}{dx}\n$$\n由于 $J$、$D_1$ 和 $D_2$ 是常数，浓度梯度 $\\frac{dc}{dx}$ 在每个区域内也是恒定的。因此，浓度分布 $c(x)$ 在每个区域内是线性的。对恒定通量 $J$ 的方程进行积分得到：\n对于区域1：$c(x) = -\\frac{J}{D_1}x + A_1$\n对于区域2：$c(x) = -\\frac{J}{D_2}x + A_2$\n其中 $A_1$ 和 $A_2$ 是积分常数。\n\n我们使用给定的边界和界面条件来确定未知数 $A_1$、$A_2$ 和通量 $J$。\n外边界处的边界条件是：\n1. $c(-L_1) = c_1 \\implies c_1 = -\\frac{J}{D_1}(-L_1) + A_1 = \\frac{JL_1}{D_1} + A_1$\n2. $c(L_2) = c_2 \\implies c_2 = -\\frac{J}{D_2}(L_2) + A_2 = -\\frac{JL_2}{D_2} + A_2$\n\n从这两个方程中，我们可以用通量 $J$ 来表示积分常数：\n从 (1) 得：$A_1 = c_1 - \\frac{JL_1}{D_1}$\n从 (2) 得：$A_2 = c_2 + \\frac{JL_2}{D_2}$\n\n界面 $x=0$ 处的浓度通过取浓度分布的极限得到：\n$c(0^-) = \\lim_{x \\to 0^-} c(x) = A_1$\n$c(0^+) = \\lim_{x \\to 0^+} c(x) = A_2$\n\n现在我们使用第三个条件，即膜通量定律，它将通量与膜两侧的浓度跳跃联系起来：\n3. $J = P\\big(c(0^-) - c(0^+)\\big) = P(A_1 - A_2)$\n\n将 $A_1$ 和 $A_2$ 的表达式代入此方程：\n$$\nJ = P \\left[ \\left(c_1 - \\frac{JL_1}{D_1}\\right) - \\left(c_2 + \\frac{JL_2}{D_2}\\right) \\right]\n$$\n现在我们求解这个关于 $J$ 的代数方程。\n$$\nJ = P(c_1 - c_2) - P\\frac{JL_1}{D_1} - P\\frac{JL_2}{D_2}\n$$\n将所有含 $J$ 的项移到左侧：\n$$\nJ + \\frac{PJL_1}{D_1} + \\frac{PJL_2}{D_2} = P(c_1 - c_2)\n$$\n提出因子 $J$：\n$$\nJ \\left( 1 + \\frac{PL_1}{D_1} + \\frac{PL_2}{D_2} \\right) = P(c_1 - c_2)\n$$\n分离出 $J$ 得到表达式：\n$$\nJ = \\frac{P(c_1 - c_2)}{1 + \\frac{PL_1}{D_1} + \\frac{PL_2}{D_2}}\n$$\n这个表达式是正确的。为了得到一个更具物理洞察力的表示，我们可以将分子和分母同时除以渗透率 $P$：\n$$\nJ = \\frac{c_1 - c_2}{\\frac{1}{P} + \\frac{L_1}{D_1} + \\frac{L_2}{D_2}}\n$$\n这种形式与欧姆定律类似，其中通量 $J$（电流）由势差（$c_1 - c_2$）驱动，并与总阻力成反比。总阻力是三个串联组件的阻力之和：介质1的扩散阻力（$\\frac{L_1}{D_1}$）、介质2的扩散阻力（$\\frac{L_2}{D_2}$）和膜的阻力（$\\frac{1}{P}$）。这就是最终的表达式。", "answer": "$$\n\\boxed{\\frac{c_1 - c_2}{\\frac{L_1}{D_1} + \\frac{L_2}{D_2} + \\frac{1}{P}}}\n$$", "id": "2404179"}, {"introduction": "接下来，我们从解析推导转向数值计算。这个实践将揭示计算方法中的一个关键概念：使用守恒离散格式的重要性。你将实现一个看似合理但实际上非守恒的数值格式，并量化其在模拟过程中人为产生或湮灭的守恒量，从而让你对为何有限体积法必须基于守恒律的积分形式来构建有更具体的认识。[@problem_id:2404137]", "problem": "考虑周期性域 $[0,1]$ 上守恒形式的一维标量守恒律：\n$$\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial}{\\partial x}\\left(u(x)\\,\\phi\\right) = 0,$$\n其中 $u(x)$ 是一个给定的、光滑的、空间变化的速度，$\\phi(x,t)$ 是一个被输运的标量。对于周期性边界条件，积分守恒形式意味着 $\\phi$ 的总量，\n$$M(t) = \\int_0^1 \\phi(x,t)\\,dx,$$\n满足 $\\frac{d}{dt} M(t) = 0$，因此对于精确解，$M(t)$ 随时间保持恒定。\n\n您将分析一种在均匀网格上不执行通量差分的非守恒显式更新格式所引入的 $\\phi$ 的人为产生或耗散。设网格有 $N$ 个点，网格间距为 $\\Delta x = 1/N$，节点位置为 $x_i = i\\,\\Delta x$（其中 $i\\in\\{0,1,\\dots,N-1\\}$），并采用周期性索引。设速度为\n$$u(x) = 1 + \\tfrac{1}{2}\\,\\sin^2(2\\pi x),$$\n它在 $[0,1]$ 上严格为正。定义以下针对时间步长 $\\Delta t$ 的显式、逐点、非守恒更新格式：\n$$\\phi_i^{n+1} = \\phi_i^{n} - \\frac{\\Delta t}{\\Delta x}\\,u(x_i)\\,\\left(\\phi_i^{n} - \\phi_{i-1}^{n}\\right),$$\n其中使用周期性索引 $\\phi_{-1}^{n} \\equiv \\phi_{N-1}^{n}$。\n\n对于每次模拟，定义离散总量\n$$M^n = \\Delta x \\sum_{i=0}^{N-1} \\phi_i^n,$$\n并将模拟时间内 $\\phi$ 的人为产生或耗散量化为差值\n$$\\Delta M = M^{n_{\\text{final}}} - M^{0},$$\n其中 $n_{\\text{final}} = T/\\Delta t$ 是一个整数时间步数。正的 $\\Delta M$ 表示人为产生；负的 $\\Delta M$ 表示人为耗散。\n\n使用周期性域 $[0,1]$ 以及下面指定的两个初始条件：\n- 混合光滑初始条件：\n$$\\phi_0^{\\text{mixed}}(x) = \\exp\\!\\left(-100\\,(x-0.3)^2\\right) + \\tfrac{1}{2}\\,\\sin(2\\pi x).$$\n- 常数初始条件：\n$$\\phi_0^{\\text{const}}(x) = 1.$$\n\n测试套件。对于每个测试用例，完全按照给定的总时间 $T$、时间步长 $\\Delta t$ 和网格尺寸 $N$，从指定的初始条件开始运行模拟，并报告 $\\Delta M$：\n- 测试 $1$：$N=64$，$\\Delta t=0.001$，$T=0.2$，初始条件 $\\phi_0^{\\text{mixed}}$。\n- 测试 $2$：$N=64$，$\\Delta t=0.004$，$T=0.2$，初始条件 $\\phi_0^{\\text{mixed}}$。\n- 测试 $3$：$N=128$，$\\Delta t=0.001$，$T=1.0$，初始条件 $\\phi_0^{\\text{mixed}}$。\n- 测试 $4$：$N=16$，$\\Delta t=0.002$，$T=0.2$，初始条件 $\\phi_0^{\\text{mixed}}$。\n- 测试 $5$：$N=64$，$\\Delta t=0.001$，$T=0.0$，初始条件 $\\phi_0^{\\text{mixed}}$。\n- 测试 $6$：$N=64$，$\\Delta t=0.001$，$T=0.5$，初始条件 $\\phi_0^{\\text{const}}$。\n\n所有量均为无量纲；不需要物理单位。三角函数中的角度以弧度为单位。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序与上述测试一致。列表中的每个条目都是 $\\Delta M$ 的浮点值，四舍五入到 $12$ 位有效数字并以科学记数法表示。例如，一个有效的输出将具有以下形式\n$$[\\text{a}_1,\\text{a}_2,\\text{a}_3,\\text{a}_4,\\text{a}_5,\\text{a}_6],$$\n其中每个 $\\text{a}_k$ 是一个类似 $1.23456789012\\text{e}{-03}$ 的数字。", "solution": "问题陈述已经过严格验证，并被确定为有效。它具有科学依据、适定、客观且完整。它提出了一个数值分析中的标准问题：研究标量守恒律的离散格式的守恒性质。所有参数、初始条件和控制方程都已明确指定，没有歧义或矛盾。我们可以开始求解。\n\n这个问题的核心是分析所提供的数值格式的非守恒性质。控制偏微分方程 (PDE) 是一个一维标量守恒律：\n$$\n\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial F(\\phi, x)}{\\partial x} = 0,\n$$\n其中通量为 $F(\\phi, x) = u(x)\\phi$。该方程在周期性域 $[0,1]$ 上的一个基本性质是标量 $\\phi$ 的总量守恒，记为 $M(t) = \\int_0^1 \\phi(x,t)\\,dx$。$M(t)$ 的时间变化率为：\n$$\n\\frac{dM(t)}{dt} = \\frac{d}{dt}\\int_0^1 \\phi(x,t)\\,dx = \\int_0^1 \\frac{\\partial \\phi}{\\partial t}\\,dx = -\\int_0^1 \\frac{\\partial F}{\\partial x}\\,dx = -[F]_0^1.\n$$\n由于周期性边界条件，$F(1, t) = F(0, t)$，这意味着 $[F]_0^1 = 0$。因此，$\\frac{dM(t)}{dt}=0$，对于精确解，总量 $M(t)$ 是守恒的。\n\n所提供的数值格式是在具有 $N$ 个点 $x_i = i\\Delta x$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$）的均匀网格上的显式更新：\n$$\n\\phi_i^{n+1} = \\phi_i^{n} - \\frac{\\Delta t}{\\Delta x}\\,u(x_i)\\,\\left(\\phi_i^{n} - \\phi_{i-1}^{n}\\right).\n$$\n这里，$\\phi_i^n$ 是 $\\phi(x_i, n\\Delta t)$ 的数值近似，并使用周期性索引 $\\phi_{-1}^n \\equiv \\phi_{N-1}^n$。该格式通过对空间导数 $\\frac{\\partial \\phi}{\\partial x}$ 使用一阶向后差分来离散化 PDE 的平流（或非守恒）形式 $\\frac{\\partial \\phi}{\\partial t} + u(x)\\frac{\\partial \\phi}{\\partial x} = 0$。正确的守恒形式是 $\\frac{\\partial \\phi}{\\partial t} + \\frac{\\partial(u\\phi)}{\\partial x} = \\frac{\\partial \\phi}{\\partial t} + u\\frac{\\partial \\phi}{\\partial x} + \\phi\\frac{\\partial u}{\\partial x} = 0$。该格式省略了对应于 $\\phi\\frac{\\partial u}{\\partial x}$ 的项，当速度 $u(x)$不为常数时，这是非守恒性的来源。\n\n为证明这一缺陷，我们分析离散总量 $M^n = \\Delta x \\sum_{i=0}^{N-1} \\phi_i^n$ 的演化。将数值格式对所有网格点 $i$ 从 $0$ 到 $N-1$ 求和，得到：\n$$\n\\sum_{i=0}^{N-1} \\phi_i^{n+1} = \\sum_{i=0}^{N-1} \\phi_i^{n} - \\frac{\\Delta t}{\\Delta x} \\sum_{i=0}^{N-1} u_i (\\phi_i^{n} - \\phi_{i-1}^{n}),\n$$\n其中 $u_i = u(x_i)$。两边乘以 $\\Delta x$ 得到 $M^{n+1}$ 和 $M^n$ 之间的关系：\n$$\nM^{n+1} = M^n - \\Delta t \\sum_{i=0}^{N-1} u_i (\\phi_i^{n} - \\phi_{i-1}^{n}).\n$$\n一个时间步长内总量的变化为 $\\Delta M^{n+1} = M^{n+1} - M^n = -\\Delta t \\sum_{i=0}^{N-1} u_i (\\phi_i^{n} - \\phi_{i-1}^{n})$。为了使格式守恒，这个和必须为零。我们可以对该和重新索引以分析其结构：\n$$\n\\sum_{i=0}^{N-1} u_i (\\phi_i^{n} - \\phi_{i-1}^{n}) = \\sum_{i=0}^{N-1} u_i \\phi_i^n - \\sum_{i=0}^{N-1} u_i \\phi_{i-1}^n.\n$$\n通过按 $\\phi_i^n$ 对各项重新组合并利用周期性（$u_0$ 和 $\\phi_{N-1}^n$ 项），这变为：\n$$\n\\sum_{i=0}^{N-1} u_i \\phi_i^n - \\sum_{i=0}^{N-1} u_{i+1} \\phi_i^n = \\sum_{i=0}^{N-1} \\phi_i^n (u_i - u_{i+1}).\n$$\n除非 $u_i$ 是常数，否则这个和不是一个值为零的伸缩求和。相反，它近似于一个积分：\n$$\n\\sum_{i=0}^{N-1} \\phi_i^n (u_i - u_{i+1}) = \\sum_{i=0}^{N-1} \\phi_i^n \\left(-\\frac{u_{i+1}-u_i}{\\Delta x}\\right) \\Delta x \\approx -\\int_0^1 \\phi(x,t^n) \\frac{du}{dx} dx.\n$$\n因此，离散总质量的变化率近似为：\n$$\n\\frac{M^{n+1} - M^n}{\\Delta t} \\approx \\int_0^1 \\phi(x,t^n) \\frac{du}{dx} dx.\n$$\n这通常是非零的，导致 $\\phi$ 的人为产生或耗散，其计算方式为 $\\Delta M = M^{n_{\\text{final}}} - M^0$。\n\n测试套件中的两个特殊情况会导致质量变化为零，即 $\\Delta M = 0$：\n1.  测试 $5$：$T=0$。这意味着 $n_{\\text{final}}=0$ 个时间步。模拟不运行，因此显然 $M^{n_{\\text{final}}} = M^0$ 且 $\\Delta M = 0$。\n2.  测试 $6$：初始条件是常数 $\\phi_0^{\\text{const}}(x) = 1$，所以对所有 $i$ 都有 $\\phi_i^0 = 1$。更新规则中的空间差分项为 $\\phi_i^0 - \\phi_{i-1}^0 = 1 - 1 = 0$。因此，$\\phi_i^1 = \\phi_i^0$。通过归纳法，对于所有时间步 $n$，$\\phi_i^n = 1$。离散量 $M^n$ 保持恒定，且 $\\Delta M = 0$。这也与我们推导的表达式一致，因为对于常数 $\\phi_i^n = c$，求和 $\\sum_i c(u_i - u_{i+1}) = c \\sum_i (u_i - u_{i+1})$ 是一个伸缩求和，由于周期性其值为零。\n\n计算每个测试用例 $\\Delta M$ 的算法如下：\n1.  对于给定的网格尺寸 $N$，定义网格间距 $\\Delta x = 1/N$ 和节点位置 $x_i = i\\Delta x$。\n2.  将速度分布 $u(x)$ 离散化到网格上，得到数组 $u_i$。\n3.  将指定的初始条件 $\\phi_0(x)$ 离散化到网格上，得到初始状态 $\\phi_i^0$。\n4.  计算初始总量 $M^0 = \\Delta x \\sum_{i=0}^{N-1} \\phi_i^0$。\n5.  确定总时间步数 $n_{\\text{final}} = T/\\Delta t$。\n6.  从 $n=0$ 迭代到 $n_{\\text{final}}-1$。在每一步中，使用向量化的更新规则从当前状态 $\\phi^n$ 计算下一个状态 $\\phi^{n+1}$。对于 $\\phi_{i-1}^n$ 的周期性平移可以通过对表示 $\\phi^n$ 的数组执行循环移位操作来高效实现。\n7.  在最后一个时间步之后，计算最终总量 $M^{n_{\\text{final}}} = \\Delta x \\sum_{i=0}^{N-1} \\phi_i^{n_{\\text{final}}}$。\n8.  结果是差值 $\\Delta M = M^{n_{\\text{final}}} - M^0$。\n将为每个测试用例实施此过程以产生所需的结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef phi0_mixed(x):\n    \"\"\"\n    Computes the mixed smooth initial condition.\n    phi(x) = exp(-100*(x-0.3)^2) + 0.5*sin(2*pi*x)\n    \"\"\"\n    return np.exp(-100.0 * (x - 0.3)**2) + 0.5 * np.sin(2.0 * np.pi * x)\n\ndef phi0_const(x):\n    \"\"\"\n    Computes the constant initial condition.\n    phi(x) = 1\n    \"\"\"\n    return np.ones_like(x)\n\ndef run_simulation(N, dt, T, ic_func):\n    \"\"\"\n    Runs one simulation case for the non-conservative scheme and returns Delta M.\n\n    Args:\n        N (int): Number of grid points.\n        dt (float): Time step size.\n        T (float): Total simulation time.\n        ic_func (function): Function to generate the initial condition.\n\n    Returns:\n        float: The artificial change in total mass, Delta M.\n    \"\"\"\n    # Handle the trivial case of T=0, where no steps are taken.\n    if T == 0.0:\n        return 0.0\n\n    # 1. Define grid and velocity\n    dx = 1.0 / N\n    x = np.arange(N) * dx\n    u = 1.0 + 0.5 * np.sin(2.0 * np.pi * x)**2\n\n    # 2. Set initial condition\n    phi = ic_func(x)\n\n    # 3. Calculate initial total mass M^0\n    M0 = dx * np.sum(phi)\n\n    # 4. Determine number of time steps\n    # The problem statement guarantees this is an integer.\n    # Using round() for robustness against floating-point representation issues.\n    n_final = int(round(T / dt))\n\n    # Handle the case where the initial condition is constant.\n    # The update term will be zero, so Delta M is zero.\n    if ic_func == phi0_const:\n        return 0.0\n\n    # 5. Time-stepping loop\n    for _ in range(n_final):\n        # phi_{i-1} with periodic boundary condition\n        phi_prev = np.roll(phi, 1)\n        \n        # Apply the explicit non-conservative update rule\n        # phi_i^{n+1} = phi_i^n - (dt/dx) * u_i * (phi_i^n - phi_{i-1}^n)\n        phi = phi - (dt / dx) * u * (phi - phi_prev)\n\n    # 6. Calculate final total mass M^n_final\n    M_final = dx * np.sum(phi)\n\n    # 7. Compute the change in total mass\n    delta_M = M_final - M0\n    \n    return delta_M\n\ndef solve():\n    \"\"\"\n    Defines and runs the test suite, then prints the formatted results.\n    \"\"\"\n    # Test suite parameters: (N, dt, T, initial_condition_function)\n    test_cases = [\n        (64, 0.001, 0.2, phi0_mixed),\n        (64, 0.004, 0.2, phi0_mixed),\n        (128, 0.001, 1.0, phi0_mixed),\n        (16, 0.002, 0.2, phi0_mixed),\n        (64, 0.001, 0.0, phi0_mixed),\n        (64, 0.001, 0.5, phi0_const),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dt, T, ic_func = case\n        result = run_simulation(N, dt, T, ic_func)\n        results.append(result)\n\n    # Format results to 12 significant digits in scientific notation\n    # and print in the specified single-line format.\n    formatted_results = [f\"{res:.11e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2404137"}, {"introduction": "在认识到非守恒格式的缺陷之后，我们来比较两种基本不同但同样有效的守恒方法。这个练习要求你为同一个平流问题，分别实现基于欧拉观点的有限体积法和基于拉格朗日观点的粒子法。通过直接比较它们的守恒特性，你将更深入地理解不同数值离散化方法背后的哲学，并看到在拉格朗日方法中，质量守恒是如何通过其定义就能得到精确保证的。[@problem_id:2404184]", "problem": "考虑在周期性域上，一个以恒定速度输运的被动标量密度场的一维连续性方程。从一个固定控制体上的质量守恒积分形式出发。具体来说，设空间域为 $x \\in [0,1)$，具有周期性边界条件，并令 $\\rho(x,t)$ 表示由恒定速度 $u$ 输运的密度场。在任意固定控制体 $V = [a,b] \\subset [0,1)$ 上的积分守恒声明为\n$$\n\\frac{d}{dt}\\int_{a}^{b} \\rho(x,t)\\,dx + \\big[\\rho(x,t)\\,u\\big]\\big|_{x=a}^{x=b} = 0.\n$$\n以此为基础，推导相应的局部微分守恒定律，并设计两种忠实于该积分形式的离散化方法：\n- 一种基于网格的方法，使用有限体积法（FVM），该方法通过网格面上的守恒数值通量来更新网格平均密度。使用一阶单调通量，并根据输运速度 $u$ 的符号遵循迎风格式。\n- 一种基于粒子的方法，其拉格朗日观点受光滑粒子流体动力学（SPH）启发，其中有限的一组粒子各自携带不变的质量并以输运速度 $u$ 运动。为了进行守恒性测试，将密度场表示为一组粒子，其位置和不变质量通过对初始条件采样确定，并在给定速度场下演化粒子位置，同时保持粒子质量不变。\n\n假设为无量纲设定。初始条件为\n$$\n\\rho(x,0) = 1 + 0.5 \\sin(2\\pi x) + 0.25 \\cos(4\\pi x).\n$$\n令 $u$ 为一个恒定（可能非零）的标量速度。为公平比较，在每个测试案例中，两种方法使用相同数量的均匀时间步 $N_t$。其中，对于网格尺寸为 $\\Delta x = 1/N_x$ 的 FVM，时间步 $\\Delta t$ 根据名义上的 Courant–Friedrichs–Lewy (CFL) 数 $\\nu$ 通过 $\\Delta t = \\nu\\,\\Delta x/|u|$ 选定，然后调整 $\\Delta t$ 以均匀划分最终时间 $T$，使得 $N_t = \\lceil T/\\Delta t \\rceil$，且调整后的 $\\Delta t = T/N_t$ 被两种方法共同使用。对于粒子法，使用 $N_p$ 个等间距粒子，其初始位置位于 $[0,1)$ 均匀划分的中心，并根据初始密度乘以粒子间距来分配粒子质量。\n\n您的任务是：\n1. 从积分形式出发，推导局部微分形式，并确定此一维问题中的守恒量和通量。\n2. 使用守恒定律，基于网格界面上的守恒通量差，推导均匀网格上单元平均密度的有限体积更新公式。根据 $u$ 的符号，论证数值通量选择一阶单调迎风格式的合理性。\n3. 使用守恒定律，推导粒子法中粒子位置和质量的演化方程，并解释为什么在此动力学下总质量是守恒的。\n4. 实现两种方法来模拟演化至时间 $T$。对于 FVM，追踪离散总质量 $M_{\\text{FVM}} = \\sum_{j=0}^{N_x-1} \\rho_j\\,\\Delta x$。对于粒子法，追踪总质量 $M_{\\text{SPH}} = \\sum_{i=0}^{N_p-1} m_i$。对于每种方法，计算在 $t=T$ 时的相对质量误差，定义为\n$$\n\\varepsilon = \\frac{\\big|M_{\\text{final}} - M_{\\text{initial}}\\big|}{M_{\\text{initial}}}.\n$$\n5. 编写一个完整的、可运行的程序，对以下测试套件中的每个测试案例执行上述操作，并输出两种方法的相对质量误差。\n\n测试套件（每个元组为 $(u, N_x, N_p, \\nu, T)$）：\n- 测试 $1$：$(1.0, 100, 100, 0.9, 1.0)$。\n- 测试 $2$：$(0.75, 40, 80, 0.95, 0.5)$。\n- 测试 $3$：$(1.0, 20, 20, 1.2, 1.0)$。\n\n所有量均为无量纲；不需要物理单位。三角函数中的角度以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素对应一个测试案例，并且本身是一个双元素列表 $[e_{\\text{FVM}}, e_{\\text{SPH}}]$，两个条目都四舍五入到 $12$ 位有效数字。例如，格式应类似于 $[[e_{1,\\text{FVM}},e_{1,\\text{SPH}}],[e_{2,\\text{FVM}},e_{2,\\text{SPH}}],[e_{3,\\text{FVM}},e_{3,\\text{SPH}}]]$.", "solution": "问题陈述经过了严格验证，被认为是科学上可靠、适定且客观的。它提出了一个守恒律计算方法中的标准问题，并要求比较两种基本的离散化哲学：欧拉方法（有限体积）和拉格朗日方法（粒子）。推导和实现任务清晰，并从第一性原理出发。因此，该问题被认为是有效的。\n\n解决方案根据列举的任务进行组织。\n\n**1. 局部微分守恒定律的推导**\n\n出发点是密度为 $\\rho(x,t)$ 的量在任意固定控制体 $V = [a,b]$ 上的积分守恒定律：\n$$\n\\frac{d}{dt}\\int_{a}^{b} \\rho(x,t)\\,dx + \\big[\\rho(x,t)\\,u\\big]\\big|_{x=a}^{x=b} = 0\n$$\n这里，$u$ 是一个恒定速度。项 $\\rho u$ 代表量 $\\rho$ 的通量。令此通量表示为 $F(x,t) = \\rho(x,t)u$。根据微积分基本定理，边界项可以写成一个积分：\n$$\n\\big[F(x,t)\\big]\\big|_{x=a}^{x=b} = F(b,t) - F(a,t) = \\int_{a}^{b} \\frac{\\partial F}{\\partial x}\\,dx\n$$\n由于控制体 $[a,b]$ 在时间上是固定的，时间导数可以移到积分内部（Leibniz 积分法则）：\n$$\n\\frac{d}{dt}\\int_{a}^{b} \\rho(x,t)\\,dx = \\int_{a}^{b} \\frac{\\partial \\rho}{\\partial t}\\,dx\n$$\n将这些表达式代回积分定律得到：\n$$\n\\int_{a}^{b} \\frac{\\partial \\rho}{\\partial t}\\,dx + \\int_{a}^{b} \\frac{\\partial F}{\\partial x}\\,dx = 0\n$$\n$$\n\\int_{a}^{b} \\left( \\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial F}{\\partial x} \\right) dx = 0\n$$\n对于任意选择的区间 $[a,b]$，这个积分都必须为零。对于一个连续的被积函数，这只有在被积函数本身处处恒为零时才可能。因此，我们得到局部微分守恒定律：\n$$\n\\frac{\\partial \\rho}{\\partial t} + \\frac{\\partial F}{\\partial x} = 0\n$$\n守恒量是由其密度 $\\rho(x,t)$ 表示的标量场。通量是 $F(x,t) = \\rho(x,t)u$。由于 $u$ 是常数，该方程成为一维线性平流方程：\n$$\n\\frac{\\partial \\rho}{\\partial t} + u \\frac{\\partial \\rho}{\\partial x} = 0\n$$\n\n**2. 有限体积法 (FVM) 离散化**\n\nFVM 是作为积分守恒定律的直接离散化而构建的，保证了守恒量在数值上是守恒的。我们将域 $x \\in [0,1)$ 划分为 $N_x$ 个均匀的网格单元，$I_j = [x_{j-1/2}, x_{j+1/2}]$，其中 $j=0, \\dots, N_x-1$，每个单元的宽度为 $\\Delta x = 1/N_x$。\n\n将微分定律在网格单元 $I_j$ 上积分得到：\n$$\n\\int_{x_{j-1/2}}^{x_{j+1/2}} \\frac{\\partial \\rho}{\\partial t}\\,dx + \\int_{x_{j-1/2}}^{x_{j+1/2}} \\frac{\\partial F}{\\partial x}\\,dx = 0\n$$\n我们将单元平均密度定义为 $\\rho_j(t) = \\frac{1}{\\Delta x} \\int_{x_{j-1/2}}^{x_{j+1/2}} \\rho(x,t)\\,dx$。方程变为：\n$$\n\\frac{d \\rho_j}{dt} \\Delta x + F(x_{j+1/2}, t) - F(x_{j-1/2}, t) = 0\n$$\n除以 $\\Delta x$，我们得到单元平均值的精确演化方程：\n$$\n\\frac{d \\rho_j}{dt} + \\frac{1}{\\Delta x} \\left( F_{j+1/2} - F_{j-1/2} \\right) = 0\n$$\n为了创建一个数值格式，我们使用大小为 $\\Delta t$ 的前向欧拉步在时间上进行离散，并用数值通量函数 $\\hat{F}$ 来近似网格面上的精确通量 $F_{j \\pm 1/2}$。数值通量 $\\hat{F}_{j+1/2}$ 是相邻单元状态的函数，通常是 $\\rho_j$ 和 $\\rho_{j+1}$。\n$$\n\\frac{\\rho_j^{n+1} - \\rho_j^n}{\\Delta t} + \\frac{1}{\\Delta x} \\left( \\hat{F}_{j+1/2} - \\hat{F}_{j-1/2} \\right) = 0\n$$\n这给出了守恒更新公式：\n$$\n\\rho_j^{n+1} = \\rho_j^n - \\frac{\\Delta t}{\\Delta x} \\left( \\hat{F}_{j+1/2} - \\hat{F}_{j-1/2} \\right)\n$$\n问题指定了一阶、单调的迎风通量。通量的选择取决于信息传播的方向，该方向由速度 $u$ 的符号给出。\n- 如果 $u  0$，信息从左向右流动。面 $x_{j+1/2}$ 处的状态由“迎风”单元（即单元 $j$）决定。因此，$\\hat{F}_{j+1/2} = F(\\rho_j^n) = \\rho_j^n u$。\n- 如果 $u  0$，信息从右向左流动。面 $x_{j+1/2}$ 处的状态由“迎风”单元（即单元 $j+1$）决定。因此，$\\hat{F}_{j+1/2} = F(\\rho_{j+1}^n) = \\rho_{j+1}^n u$。\n这就是迎风通量选择原理，它尊重双曲输运的物理特性。对于这种显式格式的稳定性，Courant–Friedrichs–Lewy (CFL) 数 $\\nu_{\\text{CFL}} = \\frac{|u|\\Delta t}{\\Delta x}$ 必须小于或等于 $1$。\n\nFVM 中的总质量为 $M_{\\text{FVM}} = \\sum_{j=0}^{N_x-1} \\rho_j \\Delta x$。从时间步 $n$ 到 $n+1$ 的总质量变化为：\n$$\nM^{n+1} - M^n = \\sum_{j=0}^{N_x-1} (\\rho_j^{n+1} - \\rho_j^n) \\Delta x = -\\Delta t \\sum_{j=0}^{N_x-1} (\\hat{F}_{j+1/2} - \\hat{F}_{j-1/2})\n$$\n该和是伸缩求和。在周期性边界条件下，$\\rho_{N_x} \\equiv \\rho_0$，这意味着 $\\hat{F}_{N_x-1/2+1} \\equiv \\hat{F}_{-1/2}$。求和结果为零，意味着质量在代数上是守恒的。实践中的任何误差都源于浮点运算。\n\n**3. 粒子法推导**\n\n粒子法采用拉格朗日观点。连续场被离散为有限的 $N_p$ 个粒子，每个粒子都有一个位置 $x_i(t)$ 和一个相关的质量 $m_i$。用于质量守恒的拉格朗日方法的核心原理是，物质微团在随流运动时其质量是不变的。\n微团质量的演化方程是 $\\frac{Dm}{Dt} = 0$。对我们的粒子而言，这可转化为：\n$$\n\\frac{dm_i}{dt} = 0\n$$\n这意味着每个粒子的质量 $m_i$ 在所有时间内都是恒定的。粒子本身被速度场 $u$ 平流。粒子位置的演化方程是：\n$$\n\\frac{dx_i}{dt} = u\n$$\n因此，离散化的演化方程为：\n- $m_i^{n+1} = m_i^n$\n- $x_i^{n+1} = x_i^n + u \\Delta t$\n总质量为 $M_{\\text{SPH}} = \\sum_{i=0}^{N_p-1} m_i$。由于每个 $m_i$ 都是恒定的，总质量通过构造是守恒的：\n$$\n\\frac{dM_{\\text{SPH}}}{dt} = \\sum_{i=0}^{N_p-1} \\frac{dm_i}{dt} = \\sum_{i=0}^{N_p-1} 0 = 0\n$$\n总质量中唯一的误差来源将是浮点求和的不精确性，这通常可以忽略不计。粒子位置被更新并环绕周期性域 $x \\in [0,1)$。\n\n**4. 质量守恒分析的实现**\n\n两种方法都予以实现。初始条件 $\\rho(x,0)$ 用于为 FVM 设置初始单元平均密度 $\\rho_j(0)$，并为粒子法设置初始粒子质量 $m_i$。该域的解析总质量为 $\\int_0^1 \\rho(x,0) dx = \\int_0^1 (1 + 0.5 \\sin(2\\pi x) + 0.25 \\cos(4\\pi x)) dx = 1$。两种数值方法都被初始化以近似该总质量。系统演化至时间 $T$。\n\nFVM 依赖于迎风通量实现，该实现仅在 CFL 数 $\\nu_{\\text{CFL}} \\le 1$ 时稳定。测试案例 3 使用的名义 CFL 数为 $1.2$，因此 FVM 预计会变得不稳定，导致出现大的、非物理的密度值和潜在的浮点溢出。尽管存在这种不稳定性，FVM 公式化的代数守恒特性意味着总质量仍应守恒，除非 `inf` 或 `NaN` 值破坏了求和。\n\n对于此问题，粒子法是无条件稳定的，因为粒子轨迹被精确积分。其质量守恒是定义性的。\n\n在所有测试案例中，对两种方法都计算相对质量误差 $\\varepsilon = |M_{\\text{final}} - M_{\\text{initial}}| / |M_{\\text{initial}}|$，以量化其守恒特性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D advection problem using FVM and a particle method,\n    and computes the relative mass conservation error for each.\n    \"\"\"\n\n    def rho_initial(x):\n        \"\"\"\n        Defines the initial density profile rho(x, 0).\n        \"\"\"\n        return 1.0 + 0.5 * np.sin(2.0 * np.pi * x) + 0.25 * np.cos(4.0 * np.pi * x)\n\n    # Test suite: (u, Nx, Np, nu, T)\n    test_cases = [\n        (1.0, 100, 100, 0.9, 1.0),\n        (0.75, 40, 80, 0.95, 0.5),\n        (1.0, 20, 20, 1.2, 1.0),\n    ]\n\n    results = []\n\n    for u, Nx, Np, nu, T in test_cases:\n        # --- Time step calculation ---\n        dx = 1.0 / Nx\n        \n        # Avoid division by zero if u is 0, though problem implies non-zero u.\n        if abs(u) == 0.0:\n            # If velocity is zero, there is no advection. No time steps needed.\n            Nt = 0\n            dt = 0.0\n        elif T == 0.0:\n            Nt = 0\n            dt = 0.0\n        else:\n            dt_nominal = nu * dx / abs(u)\n            if dt_nominal == 0:\n                 # This can happen if T  0 but nu or dx are 0.\n                 # With T0, we need at least one step.\n                 Nt = 1\n            else:\n                 Nt = int(np.ceil(T / dt_nominal))\n            dt = T / Nt if Nt  0 else 0.0\n\n        # --- Finite Volume Method (FVM) ---\n        x_fvm = np.linspace(0.0, 1.0, Nx, endpoint=False) + 0.5 * dx\n        rho_fvm = rho_initial(x_fvm)\n        mass_initial_fvm = np.sum(rho_fvm) * dx\n        \n        if Nt  0:\n            cfl = u * dt / dx\n            for _ in range(Nt):\n                if u  0:\n                    rho_left = np.roll(rho_fvm, 1)\n                    flux_diff = rho_fvm - rho_left\n                else: # u = 0\n                    rho_right = np.roll(rho_fvm, -1)\n                    flux_diff = rho_right - rho_fvm\n                rho_fvm -= cfl * flux_diff\n\n        mass_final_fvm = np.sum(rho_fvm) * dx\n        \n        if abs(mass_initial_fvm)  1e-15:\n            e_fvm = np.abs(mass_final_fvm - mass_initial_fvm) / np.abs(mass_initial_fvm)\n        else:\n            e_fvm = 0.0\n\n        # --- Particle Method ---\n        dx_particle = 1.0 / Np\n        x_p = np.linspace(0.0, 1.0, Np, endpoint=False) + 0.5 * dx_particle\n        m_p = rho_initial(x_p) * dx_particle\n        mass_initial_sph = np.sum(m_p)\n        \n        if Nt  0:\n            # Evolve particle positions\n            x_p = (x_p + u * T) % 1.0\n\n        # Masses are invariant, so the final mass sum is computationally identical\n        mass_final_sph = np.sum(m_p)\n        \n        if abs(mass_initial_sph)  1e-15:\n            e_sph = np.abs(mass_final_sph - mass_initial_sph) / np.abs(mass_initial_sph)\n        else:\n            e_sph = 0.0\n\n        results.append([e_fvm, e_sph])\n\n    # Format output as specified\n    result_strings = []\n    for res in results:\n        e_fvm_str = f\"{res[0]:.12g}\"\n        e_sph_str = f\"{res[1]:.12g}\"\n        result_strings.append(f\"[{e_fvm_str},{e_sph_str}]\")\n    \n    print(f\"[{','.join(result_strings)}]\")\n\nsolve()\n```", "id": "2404184"}]}