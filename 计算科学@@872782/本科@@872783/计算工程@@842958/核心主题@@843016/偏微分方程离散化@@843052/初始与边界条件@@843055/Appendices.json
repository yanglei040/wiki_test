{"hands_on_practices": [{"introduction": "在开始求解任何偏微分方程之前，我们必须确保问题是“适定的”。本练习将通过一个简单的椭圆方程，向您展示当边界条件给定过少或过多时会发生什么，这分别导致解不唯一或解不存在。通过这个实践，您将建立起一个基础直觉：为何正确地指定条件是任何模拟中至关重要的第一步。[@problem_id:2403367]", "problem": "考虑闭区间 $[0,1]$ 上关于未知函数 $u(x)$ 的一维稳态椭圆边值问题，由以下偏微分方程 (PDE) 给出：\n$$\nu''(x) \\;=\\; -\\pi^2 \\sin(\\pi x), \\quad x \\in (0,1).\n$$\n您必须研究这个二阶椭圆问题的适定性如何依赖于边界条件。具体来说，比较以下三种边界条件情形：\n- 情形 A（欠定）：仅给定 $u(0)=0$。\n- 情形 B（适定）：同时给定两个狄利克雷条件 $u(0)=0$ 和 $u(1)=0$。\n- 情形 C（超定）：同时给定两个狄利克雷条件 $u(0)=0$ 和 $u(1)=0$，并额外施加诺伊曼条件 $u'(0)=0$。\n\n编写一个完整的、可运行的程序，尝试为每种情形计算数值解，并根据以下约定对每种情况的结果进行分类：\n- 如果存在与所有条件一致的唯一解，则输出 $0$。\n- 如果问题是欠定的，导致非唯一解，则输出 $1$。\n- 如果问题是超定的且不相容，即没有解能同时满足所有条件，则输出 $2$。\n\n您的程序必须对所有情形应用相同的底层数学模型和强迫项，并使用您选择的相同内部参数，以便以一致的方式做出分类决策。可以使用任何数学上一致的数值方法来得出分类决策，但分类本身必须由这些条件对给定的偏微分方程是否意味着唯一性、非唯一性或不相容性来决定。\n\n测试套件：\n- 情形 A：仅给定 $u(0)=0$。\n- 情形 B：给定 $u(0)=0$ 和 $u(1)=0$。\n- 情形 C：给定 $u(0)=0$，$u(1)=0$ 和 $u'(0)=0$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含情形 A、B 和 C 的分类结果，按顺序排列，形式为方括号括起来的逗号分隔列表。例如，格式为 $[c_1,c_2,c_3]$，其中 $c_1$、$c_2$ 和 $c_3$ 分别是为情形 A、B 和 C 定义的整数代码。", "solution": "所述问题是有效的。这是一个关于边值问题分析的定义明确的数学练习，是计算工程中的一个基本课题。它具有科学依据、是客观的，并包含进行严谨分析和求解所需的所有必要信息。\n\n该问题要求分析区间 $[0,1]$ 上一维椭圆边值问题的适定性：\n$$\nu''(x) = -\\pi^2 \\sin(\\pi x)\n$$\n这是一个二阶常微分方程。其通解可以通过对 $x$ 积分两次得到。\n\n第一次积分得到导数 $u'(x)$：\n$$\nu'(x) = \\int -\\pi^2 \\sin(\\pi x) \\,dx = \\pi \\cos(\\pi x) + C_1\n$$\n其中 $C_1$ 是第一个积分常数。\n\n第二次积分得到通解 $u(x)$：\n$$\nu(x) = \\int (\\pi \\cos(\\pi x) + C_1) \\,dx = \\sin(\\pi x) + C_1 x + C_2\n$$\n其中 $C_2$ 是第二个积分常数。任何特定问题实例的适定性取决于所提供的边界条件是否足以唯一确定两个常数 $C_1$ 和 $C_2$。我们现在将分析每种情形。\n\n情形A：具有一个边界条件 $u(0)=0$ 的欠定问题。\n我们将此条件应用于通解：\n$$\nu(0) = \\sin(\\pi \\cdot 0) + C_1 \\cdot 0 + C_2 = 0\n$$\n这意味着 $0 + 0 + C_2 = 0$，简化为 $C_2 = 0$。解被约束为以下形式：\n$$\nu(x) = \\sin(\\pi x) + C_1 x\n$$\n常数 $C_1$ 仍未确定。由于没有其他信息来约束 $C_1$，因此存在一个无穷解系，每个解对应于 $C_1$ 的不同选择。因此，该问题是欠定的，导致非唯一性。分类代码为 $1$。\n\n情形B：具有两个狄利克雷边界条件 $u(0)=0$ 和 $u(1)=0$ 的适定问题。\n第一个条件 $u(0)=0$ 给出 $C_2=0$，如情形A中所确定的。现在，我们将第二个条件 $u(1)=0$ 应用于部分约束的解 $u(x) = \\sin(\\pi x) + C_1 x$：\n$$\nu(1) = \\sin(\\pi \\cdot 1) + C_1 \\cdot 1 = 0\n$$\n这得出 $0 + C_1 = 0$，意味着 $C_1=0$。两个常数现在都被唯一确定：$C_1=0$ 和 $C_2=0$。这产生了唯一的解：\n$$\nu(x) = \\sin(\\pi x)\n$$\n该解与所有给定的条件一致。问题是适定的，存在唯一解。分类代码为 $0$。\n\n情形C：具有三个边界条件 $u(0)=0$，$u(1)=0$ 和 $u'(0)=0$ 的超定问题。\n根据对情形B的分析，前两个条件 $u(0)=0$ 和 $u(1)=0$ 足以确定唯一解 $u(x) = \\sin(\\pi x)$。\n\n现在，我们必须检查这个唯一解是否与第三个附加条件，即诺伊曼条件 $u'(0)=0$ 一致。我们在 $x=0$ 处计算我们唯一解的导数。导数是：\n$$\nu'(x) = \\frac{d}{dx}(\\sin(\\pi x)) = \\pi \\cos(\\pi x)\n$$\n在 $x=0$ 处，其值为：\n$$\nu'(0) = \\pi \\cos(\\pi \\cdot 0) = \\pi \\cos(0) = \\pi \\cdot 1 = \\pi\n$$\n问题施加了条件 $u'(0)=0$，但满足另外两个条件的唯一解却得出 $u'(0)=\\pi$。由于 $\\pi \\neq 0$，存在一个矛盾。没有函数可以同时满足所有三个条件。该问题是超定的且不相容。分类代码为 $2$。\n\n为了实现一个能够得出这些分类的程序，我们将采用有限差分法 (FDM)。我们将域 $[0,1]$ 离散化为 $N$ 个大小为 $h=1/N$ 的区间，网格点为 $x_i = i h$，$i=0, 1, \\dots, N$。未知函数值为 $u_i \\approx u(x_i)$。二阶导数由中心差分近似：$u''(x_i) \\approx (u_{i-1} - 2u_i + u_{i+1})/h^2$。这将微分方程转换为一个线性方程组。我们的程序将分析每种情形下该系统的属性。\n\n对于情形A，只有一个边界条件，得到的线性系统将是欠定的，对应于一个秩小于未知数数量的奇异矩阵。这表明非唯一性（代码 $1$）。\n\n对于情形B，两个狄利克雷条件产生一个方形的、非奇异的系统矩阵。存在唯一解。这可以通过矩阵满秩来检测（代码 $0$）。\n\n对于情形C，我们将首先求解情形B中的适定系统。然后，我们将检查得到的数值解是否满足第三个条件 $u'(0)=0$，该条件近似为 $(u_1 - u_0)/h = 0$。正如解析工作所示，这个条件将不会被满足，表明不相容（代码 $2$）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Analyzes the well-posedness of a 1D elliptic BVP under three different\n    boundary condition scenarios and classifies them.\n    - 0: Unique, consistent solution.\n    - 1: Under-specified, non-unique solution.\n    - 2: Over-specified, inconsistent, no solution.\n    \"\"\"\n    \n    # Numerical parameters\n    N = 100  # Number of spatial intervals\n    h = 1.0 / N  # Step size\n    x = np.linspace(0, 1, N + 1)\n    \n    # Forcing function f(x) = -pi^2 * sin(pi*x)\n    f = -np.pi**2 * np.sin(np.pi * x)\n    \n    # The size of the unknown vector u = [u_0, u_1, ..., u_N] is N+1\n    num_unknowns = N + 1\n    \n    results = []\n\n    # --- Scenario A: u(0) = 0 ---\n    # The problem is under-specified. We construct a linear system A*u = b\n    # and check if the matrix A is singular.\n    A_A = np.zeros((num_unknowns, num_unknowns))\n    b_A = np.zeros(num_unknowns)\n    \n    # Boundary condition: u_0 = 0\n    A_A[0, 0] = 1.0\n    b_A[0] = 0.0\n    \n    # Discretized PDE: u_{i-1} - 2u_i + u_{i+1} = h^2 * f_i\n    # We use the original PDE form to avoid dividing by h^2, improving stability.\n    for i in range(1, N):\n        A_A[i, i - 1] = 1.0\n        A_A[i, i] = -2.0\n        A_A[i, i + 1] = 1.0\n        b_A[i] = h**2 * f[i]\n        \n    # The last row of A_A is all zeros because there is no condition on u_N.\n    # This makes the matrix singular. A singular system with a non-trivial\n    # null space implies non-unique solutions (if a solution exists).\n    # Rank will be less than the number of unknowns.\n    rank_A = np.linalg.matrix_rank(A_A)\n    if rank_A  num_unknowns:\n        # A rank-deficient system implies either no solution or infinite solutions.\n        # Analytically, we know solutions exist, so it is non-unique.\n        results.append(1)\n    else:\n        # This case should not be reached for Scenario A.\n        results.append(0)\n\n\n    # --- Scenario B: u(0) = 0 and u(1) = 0 ---\n    # The problem is well-posed. The matrix should be non-singular.\n    A_B = np.zeros((num_unknowns, num_unknowns))\n    b_B = np.zeros(num_unknowns)\n    \n    # Boundary condition: u_0 = 0\n    A_B[0, 0] = 1.0\n    b_B[0] = 0.0\n    \n    # Discretized PDE\n    for i in range(1, N):\n        A_B[i, i - 1] = 1.0\n        A_B[i, i] = -2.0\n        A_B[i, i + 1] = 1.0\n        b_B[i] = h**2 * f[i]\n\n    # Boundary condition: u_N = 0\n    A_B[N, N] = 1.0\n    b_B[N] = 0.0\n    \n    # A full-rank square matrix implies a unique solution.\n    rank_B = np.linalg.matrix_rank(A_B)\n    if rank_B == num_unknowns:\n        results.append(0)\n    else:\n        # This case should not be reached for Scenario B.\n        results.append(1)\n\n\n    # --- Scenario C: u(0)=0, u(1)=0, and u'(0)=0 ---\n    # The problem is over-specified. We solve the well-posed subproblem (Scenario B)\n    # and check if the solution is consistent with the additional condition u'(0)=0.\n    \n    # 1. Solve the system from Scenario B to get the unique solution for the\n    #    Dirichlet conditions u(0)=0 and u(1)=0.\n    try:\n        u_sol_B = np.linalg.solve(A_B, b_B)\n\n        # 2. Check consistency with the third condition, u'(0) = 0.\n        # We approximate the derivative at x=0 using a forward difference:\n        # u'(0) approx (u_1 - u_0) / h\n        numerical_deriv_at_0 = (u_sol_B[1] - u_sol_B[0]) / h\n        \n        # The analytical derivative is pi. The numerical result should be close to pi.\n        # We check if this value is close to 0, which is the imposed condition.\n        # A tolerance is used for the floating-point comparison.\n        if np.isclose(numerical_deriv_at_0, 0.0, atol=1e-6):\n            # This would mean the solution is consistent (code 0).\n            # However, we know analytically u'(0)=pi, so this path is not expected.\n            results.append(0)\n        else:\n            # The condition is not satisfied. The problem is inconsistent.\n            results.append(2)\n            \n    except np.linalg.LinAlgError:\n        # This should not happen since matrix B is non-singular.\n        # If it did, it would imply an issue with the well-posed sub-problem.\n        # A safe fallback would be to classify as inconsistent.\n        results.append(2)\n\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2403367"}, {"introduction": "边界条件不仅仅是约束一个系统，它们还可以主动地驱动系统。本练习通过对一维波动方程施加一个随时间变化的边界条件来探索共振现象。通过将驱动频率调整到与系统的固有频率相匹配，您将亲眼见证边界输入如何导致系统响应的急剧放大，这在结构工程和声学设计中是一个核心概念。[@problem_id:2403378]", "problem": "考虑一个定义在有限区间上的一维波动方程，以无量纲形式给出以避免使用物理单位。设场为 $u(x,t)$，其中空间坐标 $x \\in [0,L]$，时间 $t \\ge 0$。控制偏微分方程 (PDE) 为\n$$\nu_{tt}(x,t) = c^2\\,u_{xx}(x,t),\n$$\n服从于狄利克雷边界条件\n$$\nu(0,t) = g(t), \\quad u(L,t) = 0,\n$$\n以及初始条件\n$$\nu(x,0) = 0, \\quad u_t(x,0) = 0.\n$$\n边界驱动是一个时变信号\n$$\ng(t) = A \\sin(\\omega t),\n$$\n其中所有角度均以弧度为单位。\n\n从相关齐次边值问题（$g(t) \\equiv 0$）的分离变量法出发，并利用特征函数的正交性，推导出该域的固有模态振型及相应的固有角频率。利用此推导定义 $\\omega$ 的一个参数化选择，使其调谐到该域的某个选定固有模态，推导过程不应依赖任何快捷公式。\n\n你的计算任务是为该带有非齐次狄利克雷边界输入 $g(t)$ 的偏微分方程设计并实现一个二阶精度的显式时域有限差分积分器，并在每个时间步强制施加边界值。使用包含 $N_x$ 个子区间的均匀网格，网格间距为 $\\Delta x = L/N_x$，并根据波动方程的 Courant–Friedrichs–Lewy (CFL) 稳定性条件选择显式时间步长 $\\Delta t$。定义 Courant 数为 $r = c\\,\\Delta t/\\Delta x$。内部点的显式中心差分更新格式应在空间和时间上都达到二阶精度。使用给定的初始条件，并以与所选更新格式一致的方式来初始化该数值格式。\n\n为给定的模拟定义以下标量性能指标：在模拟时间区间内，空间中点 $x=L/2$ 处所达到的最大绝对位移，\n$$\nM = \\max_{0 \\le n \\le N_t} \\left| u\\!\\left(\\tfrac{L}{2}, n\\,\\Delta t \\right) \\right|,\n$$\n其中 $N_t$ 是总时间步数。\n\n使用从第一性原理推导出的固有频率，通过选择以下驱动频率来激励一个选定的模态\n$$\n\\omega = \\omega_m\\,(1+\\delta),\n$$\n其中 $m$ 是你选择的一个正整数模态指数，$\\omega_m$ 是你推导出的第 $m$ 个固有角频率，$\\delta$ 是一个无量纲失谐参数。对于每次模拟，运行所选 $\\omega$ 的指定驱动周期数 $P$；即模拟至最终时间 $T = P \\cdot 2\\pi/\\omega$。所有量均为无量纲。\n\n实现该计算并报告以下每个测试用例的 $M$ 值。在所有用例中，使用相同的空间分辨率以使比较有意义。每个元组为 $(L, c, N_x, r, m, \\delta, A, P)$:\n- A用例（共振，基频模态）：$(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- B用例（轻微失谐）：$(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,1,\\; \\delta=\\,0.05,\\; A=\\,1,\\; P=\\,30\\,)$。\n- C用例（共振，在节点处测量的偶数模态）：$(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,2,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- D用例（共振，更高阶的奇数模态）：$(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,0.9,\\; m=\\,3,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n- E用例（CFL 稳定性边界）：$(\\,\\; L=\\,1,\\; c=\\,1,\\; N_x=\\,200,\\; r=\\,1,\\; m=\\,1,\\; \\delta=\\,0,\\; A=\\,1,\\; P=\\,30\\,)$。\n\n你的程序必须：\n- 根据你推导的分离变量法分析计算第 $m$ 个固有频率 $\\omega_m$，然后设置 $\\omega = \\omega_m\\,(1+\\delta)$。\n- 使用 Courant 数 $r \\le 1$ 的显式二阶格式，并在每个时间步强制施加 $u(0,t)=g(t)$ 和 $u(L,t)=0$。\n- 对每个用例，模拟至 $T = P \\cdot 2\\pi/\\omega$ 并记录如上定义的 $M$。\n\n最终输出格式：你的程序应生成单行输出，其中包含 A 到 E 各用例的结果，按顺序排列，形式为一个用方括号括起来的逗号分隔列表，每个数字四舍五入到六位小数，例如 [r_a,r_b,r_c,r_d,r_e]。", "solution": "所述问题是有效的。这是一个来自计算工程领域的适定初边值问题，其基础是波动力学和数值分析的基本原理。该问题没有矛盾、歧义或科学谬误。我们将提供一个完整的解法。\n\n该解法需要两个主要部分：首先，对系统固有频率的理论推导；其次，基于有限差分法设计并实现一个数值求解器。\n\n固有频率的第一性原理推导\n\n为了找到固有频率，我们必须分析相关的齐次问题。这对应于给定偏微分方程（PDE）在零边界条件下的情况。\nPDE 是一维波动方程：\n$$u_{tt}(x,t) = c^2 u_{xx}(x,t), \\quad x \\in [0, L], \\quad t \\ge 0$$\n相关的齐次狄利克雷边界条件是：\n$$u(0,t) = 0, \\quad u(L,t) = 0$$\n我们采用分离变量法，假设解的形式为 $u(x,t) = X(x)T(t)$。将其代入 PDE 得到：\n$$X(x)T''(t) = c^2 X''(x)T(t)$$\n整理各项以分离空间变量和时间变量，我们得到：\n$$\\frac{T''(t)}{c^2 T(t)} = \\frac{X''(x)}{X(x)}$$\n由于左侧仅依赖于时间 $t$，右侧仅依赖于空间 $x$，因此两者必须等于一个常数。我们将此分离常数记为 $-\\lambda$。选择负号是为了确保得到满足边界条件的振荡解（从而得到非平凡解）。\n$$ \\frac{X''(x)}{X(x)} = -\\lambda \\quad \\text{以及} \\quad \\frac{T''(t)}{c^2 T(t)} = -\\lambda $$\n这产生了两个常微分方程 (ODEs)：\n1.  空间 ODE： $X''(x) + \\lambda X(x) = 0$\n2.  时间 ODE： $T''(t) + \\lambda c^2 T(t) = 0$\n\n我们首先求解空间 ODE，它构成一个 Sturm-Liouville 边值问题。$u(x,t)$ 的边界条件转化为 $X(x)$ 的条件：\n$$X(0) = 0, \\quad X(L) = 0$$\n空间 ODE 的通解为 $X(x) = C_1 \\cos(\\sqrt{\\lambda}x) + C_2 \\sin(\\sqrt{\\lambda}x)$。\n应用第一个边界条件，$X(0) = 0$：\n$$C_1 \\cos(0) + C_2 \\sin(0) = C_1 \\cdot 1 + C_2 \\cdot 0 = C_1 = 0$$\n这将解简化为 $X(x) = C_2 \\sin(\\sqrt{\\lambda}x)$。\n应用第二个边界条件，$X(L) = 0$：\n$$C_2 \\sin(\\sqrt{\\lambda}L) = 0$$\n为了得到非平凡解，我们要求 $C_2 \\neq 0$，这意味着 $\\sin(\\sqrt{\\lambda}L)$ 必须为零。当正弦函数的参数是 $\\pi$ 的整数倍时，此条件得到满足：\n$$\\sqrt{\\lambda}L = m\\pi, \\quad \\text{for } m = 1, 2, 3, \\dots$$\n$m=0$ 的情况被排除，因为它导致 $\\lambda=0$ 和平凡解 $X(x)=0$。$m$ 为负整数时不会产生新的独立解。\n求解特征值 $\\lambda$，我们得到一组离散值：\n$$\\lambda_m = \\left(\\frac{m\\pi}{L}\\right)^2, \\quad m=1, 2, 3, \\dots$$\n相应的特征函数，或称固有模态振型，是：\n$$X_m(x) = \\sin\\left(\\frac{m\\pi x}{L}\\right)$$\n现在我们回到时间 ODE，代入特征值 $\\lambda_m$：\n$$T_m''(t) + \\lambda_m c^2 T_m(t) = 0$$\n这是简谐振子的方程。固有角频率 $\\omega_m$ 是 $T_m(t)$ 系数的平方根：\n$$\\omega_m^2 = \\lambda_m c^2 = \\left(\\frac{m\\pi}{L}\\right)^2 c^2$$\n取正平方根得到固有角频率：\n$$\\omega_m = \\frac{m\\pi c}{L}, \\quad m=1, 2, 3, \\dots$$\n推导至此完成。此公式将用于在数值模拟中设置驱动频率 $\\omega = \\omega_m(1+\\delta)$。\n\n时域有限差分 (FDTD) 格式\n\n我们用均匀网格将域离散化。空间坐标为 $x_i = i\\Delta x$，$i \\in \\{0, 1, \\dots, N_x\\}$，其中 $\\Delta x = L/N_x$。时间坐标为 $t_n = n\\Delta t$，$n \\in \\{0, 1, \\dots, N_t\\}$。我们将场的数值近似表示为 $u_i^n \\approx u(x_i, t_n)$。\n\nPDE $u_{tt} = c^2 u_{xx}$ 在空间和时间上均使用二阶中心差分进行近似：\n$$\\frac{u_i^{n+1} - 2u_i^n + u_i^{n-1}}{(\\Delta t)^2} = c^2 \\frac{u_{i+1}^n - 2u_i^n + u_{i-1}^n}{(\\Delta x)^2}$$\n对 $u_i^{n+1}$（下一个时间步的场）求解，得到内部网格点（$i=1, \\dots, N_x-1$）的显式更新规则：\n$$u_i^{n+1} = 2u_i^n - u_i^{n-1} + \\left(\\frac{c\\Delta t}{\\Delta x}\\right)^2 (u_{i+1}^n - 2u_i^n + u_{i-1}^n)$$\n定义 Courant 数 $r = c\\Delta t/\\Delta x$，格式简化为：\n$$u_i^{n+1} = 2(1 - r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}$$\n当 $r \\le 1$ 时，该格式是稳定的，这就是 Courant-Friedrichs-Lewy (CFL) 条件。\n\n初始条件是 $u(x,0) = 0$ 和 $u_t(x,0)=0$。\n由 $u(x,0)=0$，我们设置对所有 $i \\in \\{0, \\dots, N_x\\}$，$u_i^0 = 0$。\n时间导数 $u_t(x,0)=0$ 用于求解第一个时间步的解 $u_i^1$。我们对 $t=0$ 处的导数使用二阶中心差分：\n$$\\frac{u_i^1 - u_i^{-1}}{2\\Delta t} = u_t(x_i, 0) = 0 \\implies u_i^{-1} = u_i^1$$\n此处 $u_i^{-1}$ 是一个时间上的虚拟“鬼点”。我们将其代入 $n=0$ 时的更新规则：\n$$u_i^1 = 2(1 - r^2)u_i^0 + r^2(u_{i+1}^0 + u_{i-1}^0) - u_i^{-1}$$\n代入 $u_i^0=0$ 和 $u_i^{-1}=u_i^1$：\n$$u_i^1 = 2(1 - r^2)(0) + r^2(0+0) - u_i^1 \\implies 2u_i^1 = 0 \\implies u_i^1 = 0$$\n这对内部点成立。对于边界点，其值由边界条件决定。\n在任意时间步 $n$，边界条件被直接施加：\n$$u_0^n = g(t_n) = A \\sin(\\omega t_n)$$\n$$u_{N_x}^n = 0$$\n因此，对于初始化：\n- 时间 $n=0$：对所有 $i$，$u_i^0=0$。注意 $u_0^0=g(0)=A\\sin(0)=0$，这是一致的。\n- 时间 $n=1$：对内部点 $i=1, \\dots, N_x-1$，$u_i^1 = 0$。边界值为 $u_0^1 = g(\\Delta t)$ 和 $u_{N_x}^1 = 0$。\n\n从这些初始状态开始，通过迭代应用更新规则来推进模拟。在每个时间步记录中点 $x=L/2$（对应索引 $i=N_x/2$）处的最大绝对位移，以找到总的最大值 $M$。", "answer": "```python\nimport numpy as np\n\ndef run_simulation(L, c, Nx, r, m, delta, A, P):\n    \"\"\"\n    Solves the 1D wave equation using a finite-difference time-domain (FDTD) scheme.\n\n    Args:\n        L (float): Length of the domain.\n        c (float): Wave speed.\n        Nx (int): Number of spatial subintervals.\n        r (float): Courant number.\n        m (int): Mode index for driving frequency.\n        delta (float): Detuning parameter.\n        A (float): Amplitude of the boundary driving signal.\n        P (int): Number of drive periods to simulate.\n\n    Returns:\n        float: The maximum absolute displacement at the spatial midpoint.\n    \"\"\"\n    # 1. Setup grid and parameters\n    delta_x = L / Nx\n    \n    # 2. Calculate frequencies based on the derived formula\n    # Natural angular frequency for the m-th mode\n    omega_m = m * np.pi * c / L\n    # Driving angular frequency\n    omega = omega_m * (1.0 + delta)\n\n    # 3. Setup time stepping\n    delta_t = r * delta_x / c\n    # Final simulation time\n    if omega == 0:\n        # Avoid division by zero if frequency is zero (not in test cases but for robustness)\n        T_final = 0\n    else:\n        T_final = P * 2.0 * np.pi / omega\n    \n    # Total number of time steps (the loop will go up to Nt)\n    Nt = int(np.ceil(T_final / delta_t))\n\n    # Index of the spatial midpoint for performance metric\n    mid_point_idx = Nx // 2\n\n    # Courant number squared, used in the update rule\n    r_sq = r**2\n\n    # 4. Initialize field arrays\n    # u_prev stores the field at time step n-1\n    # u_curr stores the field at time step n\n    \n    # Per the derivation for ICs u(x,0)=0, u_t(x,0)=0:\n    # State at n=0 (t=0): u_prev array represents this.\n    # u(x,0)=0 implies u_i^0=0 for all i. The BC g(0)=A*sin(0)=0 is consistent.\n    u_prev = np.zeros(Nx + 1)\n    \n    # State at n=1 (t=delta_t): u_curr array represents this.\n    # u_i^1=0 for interior points. BCs are enforced.\n    u_curr = np.zeros(Nx + 1)\n    t = delta_t\n    u_curr[0] = A * np.sin(omega * t)\n    # u_curr[Nx] = 0 is already set by np.zeros.\n\n    # 5. Track max displacement at midpoint\n    # Initialize with the value at t=delta_t, since t=0 is zero everywhere.\n    max_disp = np.abs(u_curr[mid_point_idx])\n\n    # 6. Time-stepping loop\n    # This loop computes states for n=2, 3, ..., Nt.\n    # The loop iterates n from 1 to Nt-1 to compute u_next for time steps n+1.\n    for n in range(1, Nt):\n        # We have u_prev (n-1) and u_curr (n), compute u_next (n+1)\n        u_next = np.zeros(Nx + 1)\n\n        # Update interior points using a vectorized numpy operation for efficiency\n        # This applies the FDTD stencil: u_i^{n+1} = 2(1-r^2)u_i^n + r^2(u_{i+1}^n + u_{i-1}^n) - u_i^{n-1}\n        u_next[1:Nx] = 2.0 * (1.0 - r_sq) * u_curr[1:Nx] \\\n                      + r_sq * (u_curr[2:Nx+1] + u_curr[0:Nx-1]) \\\n                      - u_prev[1:Nx]\n\n        # Enforce boundary conditions at the next time step t = (n+1)*delta_t\n        t = (n + 1) * delta_t\n        u_next[0] = A * np.sin(omega * t)\n        u_next[Nx] = 0.0\n\n        # Update the performance metric\n        max_disp = max(max_disp, np.abs(u_next[mid_point_idx]))\n        \n        # Advance the state arrays for the next iteration\n        u_prev, u_curr = u_curr, u_next\n\n    return max_disp\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    test_cases = [\n        # (L, c, Nx, r, m, delta, A, P)\n        (1.0, 1.0, 200, 0.9, 1, 0.0,    1.0, 30),  # Case A\n        (1.0, 1.0, 200, 0.9, 1, 0.05,   1.0, 30),  # Case B\n        (1.0, 1.0, 200, 0.9, 2, 0.0,    1.0, 30),  # Case C\n        (1.0, 1.0, 200, 0.9, 3, 0.0,    1.0, 30),  # Case D\n        (1.0, 1.0, 200, 1.0, 1, 0.0,    1.0, 30),  # Case E\n    ]\n\n    results = []\n    for case_params in test_cases:\n        max_displacement = run_simulation(*case_params)\n        results.append(f\"{max_displacement:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403378"}, {"introduction": "在时空域的“角落”，即初始条件与边界条件交汇之处，常常会出现数值挑战。本练习聚焦于一个传热问题，其中域的初始状态与一个突然施加的边界条件不相容。您将研究数值解在这种不连续点附近的行为，并将其与解析解进行比较，从而深入了解数值方法如何处理这类剧烈变化。[@problem_id:2403435]", "problem": "考虑在一个近似半无限域的有限区间上的一维热方程，\n$$\n\\frac{\\partial u}{\\partial t}(x,t)=a\\,\\frac{\\partial^2 u}{\\partial x^2}(x,t),\\quad x\\in(0,L),\\ t\\in(0,T],\n$$\n其初始条件为\n$$\nu(x,0)=0,\\quad x\\in(0,L],\n$$\n以及狄利克雷边界条件\n$$\nu(0,t)=1,\\quad t\\in(0,T],\\qquad u(L,t)=0,\\quad t\\in[0,T].\n$$\n在角点 $(x,t)=(0,0)$ 处存在不相容性，因为当 $x0$ 时 $u(x,0)=0$，而当 $t0$ 时 $u(0,t)=1$。对于较小的时间且远离 $x=L$ 时，该解的行为类似于半无限域的相似解\n$$\nu_{\\text{ref}}(x,t)=\\operatorname{erfc}\\!\\left(\\frac{x}{2\\sqrt{a\\,t}}\\right),\n$$\n其中互补误差函数 (erfc) 定义为\n$$\n\\operatorname{erfc}(z)=\\frac{2}{\\sqrt{\\pi}}\\int_{z}^{\\infty} e^{-s^2}\\,ds.\n$$\n\n任务：对于下面列出的每个测试用例，数值近似初边值问题的解，直至指定时间 $t^\\ast$，并报告在指定网格位置 $x_i=i\\,\\Delta x$ 处的绝对误差。其中，均匀网格有 $N$ 个子区间，因此 $\\Delta x=L/N$。每个用例需要报告的绝对误差为\n$$\nE=\\big|u_{\\text{num}}(x_i,t^\\ast)-u_{\\text{ref}}(x_i,t^\\ast)\\big|.\n$$\n您可以使用任何数学上一致的方法来近似求解，只要该方法满足所述的初始和边界条件即可。\n\n测试组：\n- 用例 A（一般情况）：$a=1.0$, $L=1.0$, $N=200$, $\\Delta t=10^{-5}$, $t^\\ast=10^{-3}$, $i=1$。\n- 用例 B（较粗的时间分辨率以强调角点附近的平滑效应）：$a=1.0$, $L=1.0$, $N=100$, $\\Delta t=2\\times 10^{-4}$, $t^\\ast=2\\times 10^{-2}$, $i=2$。\n- 用例 C（不同的扩散系数和较短的域，在 $t^\\ast$ 时右边界影响可忽略不计）：$a=0.2$, $L=0.5$, $N=100$, $\\Delta t=5\\times 10^{-5}$, $t^\\ast=5\\times 10^{-3}$, $i=1$。\n\n所有量均为无量纲。不涉及角度。不需要百分比。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述用例的顺序排列结果。每个浮点数都应采用小数点后有 $8$ 位数字的科学记数法格式，例如：\n$$\n[\\text{result\\_A},\\text{result\\_B},\\text{result\\_C}],\n$$\n其中每个条目的格式为 $\\text{d.dddddddd}\\text{e}\\pm\\text{dd}$，使用小写字母 $e$。", "solution": "所给问题是一维热方程的一个标准初边值问题。尽管在角点 $(x,t)=(0,0)$ 处存在特定的不连续性（这是一个已知的数值挑战），但该问题是适定的且在科学上是合理的。我们着手对其进行数值求解。\n\n控制偏微分方程 (PDE) 是热方程：\n$$\n\\frac{\\partial u}{\\partial t} = a \\frac{\\partial^2 u}{\\partial x^2}\n$$\n对于定义在域 $x \\in (0,L)$ 和 $t \\in (0,T]$ 上的函数 $u(x,t)$。\n\n为了数值求解该方程，我们必须在空间和时间上对其进行离散化。我们引入一个均匀的空间网格，其上的点为 $x_j = j \\Delta x$，$j = 0, 1, \\dots, N$，其中网格间距为 $\\Delta x = L/N$。时间域被离散化为大小为 $\\Delta t$ 的步长，时间点为 $t_k = k \\Delta t$。我们将 $u(x_j, t_k)$ 的数值近似记为 $u_j^k$。\n\n二阶空间导数使用二阶中心差分公式进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{x_j, t_k} \\approx \\frac{u_{j+1}^k - 2u_j^k + u_{j-1}^k}{(\\Delta x)^2}\n$$\n\n对于时间导数，显式前向欧拉格式是条件稳定的，需要满足 Courant-Friedrichs-Lewy (CFL) 条件 $r = a \\Delta t / (\\Delta x)^2 \\le 1/2$。对于用例 B，我们计算出 $r = 1.0 \\times (2 \\times 10^{-4}) / (1.0/100)^2 = 2.0$，这违反了该条件，使得显式方法不稳定。为确保所有测试用例的无条件稳定性，我们选择隐式的后向时间、中心空间 (BTCS) 方法。\n\nBTCS 格式将有限差分应用于未来的时间步 $k+1$：\n$$\n\\frac{u_j^{k+1} - u_j^k}{\\Delta t} = a \\frac{u_{j+1}^{k+1} - 2u_j^{k+1} + u_{j-1}^{k+1}}{(\\Delta x)^2}\n$$\n该方程对内部网格点 $j = 1, 2, \\dots, N-1$ 有效。重新整理各项，将时间步 $k+1$ 的未知值组合在左侧，我们得到一个线性方程组：\n$$\n-r u_{j-1}^{k+1} + (1+2r) u_j^{k+1} - r u_{j+1}^{k+1} = u_j^k\n$$\n其中 $r = a \\Delta t / (\\Delta x)^2$ 是扩散数。\n\n这个关于 $N-1$ 个未知内部节点值 $\\{u_j^{k+1}\\}_{j=1}^{N-1}$ 的 $N-1$ 个方程组必须由边界条件来补充。\n狄利克雷边界条件为 $u(0,t)=1$ 和 $u(L,t)=0$。在我们的离散框架中，这意味着对于任何时间步 $k+1 > 0$，都有 $u_0^{k+1} = 1$ 和 $u_N^{k+1} = 0$。\n\n将边界值代入第一个 ($j=1$) 和最后一个 ($j=N-1$) 内部节点的方程中，我们得到：\n对于 $j=1$：\n$$\n-r u_0^{k+1} + (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k \\implies (1+2r) u_1^{k+1} - r u_2^{k+1} = u_1^k + r(1)\n$$\n对于 $j=N-1$：\n$$\n-r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} - r u_N^{k+1} = u_{N-1}^k \\implies -r u_{N-2}^{k+1} + (1+2r) u_{N-1}^{k+1} = u_{N-1}^k + r(0)\n$$\n得到的方程组 $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$ 有一个大小为 $(N-1) \\times (N-1)$ 的三对角矩阵 $A$，并在每个时间步进行求解。矩阵 $A$ 的下对角线元素为 $-r$，主对角线元素为 $1+2r$，上对角线元素为 $-r$。右端向量 $\\mathbf{d}^k$ 由前一时间步的内部解 $\\mathbf{u}_{\\text{int}}^k = (u_1^k, \\dots, u_{N-1}^k)^T$ 构造，并根据边界条件进行修正：$d_1 = u_1^k + r$ 以及对于 $j=2, \\dots, N-1$，$d_j = u_j^k$。\n\n算法流程如下：\n1. 在时间 $t=0$ 初始化解。根据初始条件 $u(x,0)=0$，我们设置对所有 $j=0, 1, \\dots, N$，$u_j^0 = 0$。\n2. 对于从 $t=0$ 到 $t=t^\\ast$ 的每个时间步：\n   a. 构造三对角矩阵 $A$ 和右端向量 $\\mathbf{d}^k$。\n   b. 求解线性系统 $A \\mathbf{u}_{\\text{int}}^{k+1} = \\mathbf{d}^k$ 以获得下一时间步的内部节点值 $\\mathbf{u}_{\\text{int}}^{k+1}$。使用一种高效的三对角系统求解算法，如 Thomas 算法（在 `scipy.linalg.solve_banded` 中实现）。\n   c. 更新解向量。\n3. 在最后一个时间步之后，数值解 $u_{\\text{num}}(x_i, t^\\ast)$ 由值 $u_i^K$ 给出，其中 $K = t^\\ast / \\Delta t$。\n4. 将该数值解与半无限域的参考解 $u_{\\text{ref}}(x_i, t^\\ast) = \\operatorname{erfc}(x_i / (2\\sqrt{a t^\\ast}))$ 进行比较。绝对误差计算为 $E = |u_i^K - u_{\\text{ref}}(x_i, t^\\ast)|$。\n\n将此过程应用于每个测试用例，以确定所需的绝对误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erfc\n\ndef solve_case(params):\n    \"\"\"\n    Numerically solves the 1D heat equation for a given set of parameters\n    using the Backward Time, Centered Space (BTCS) implicit method.\n\n    Args:\n        params (tuple): A tuple containing the problem parameters:\n                        (a, L, N, dt, t_star, i).\n                        a: thermal diffusivity\n                        L: length of the domain\n                        N: number of subintervals\n                        dt: time step size\n                        t_star: final time\n                        i: grid index for error calculation\n\n    Returns:\n        float: The absolute error between the numerical solution and the\n               reference semi-infinite solution at the specified point.\n    \"\"\"\n    a, L, N, dt, t_star, i = params\n\n    # Discretization parameters\n    dx = L / N\n    r = a * dt / (dx**2)\n    num_steps = int(round(t_star / dt))\n\n    # Initial condition: u(x, 0) = 0 for x in [0, L]\n    # The solution vector u has N+1 points, for j = 0, ..., N.\n    u = np.zeros(N + 1)\n\n    # Set up the tridiagonal matrix for the BTCS aystem.\n    # The system is for the N-1 interior points (j = 1, ..., N-1).\n    # The banded matrix format for scipy.linalg.solve_banded is used.\n    # It has 3 rows: upper diagonal, main diagonal, lower diagonal.\n    A_banded = np.zeros((3, N - 1))\n    A_banded[0, 1:] = -r        # Upper diagonal (shifted one to the left)\n    A_banded[1, :] = 1 + 2 * r  # Main diagonal\n    A_banded[2, :-1] = -r       # Lower diagonal (shifted one to the right)\n\n    # Time-stepping loop\n    for _ in range(num_steps):\n        # Construct the right-hand side (RHS) vector from the solution\n        # at the current time step (u).\n        # We solve for the N-1 interior points.\n        rhs = u[1:N].copy()\n\n        # Modify RHS to incorporate Dirichlet boundary conditions.\n        # For the first interior point (j=1): u(0,t)=1.\n        # The term -r*u_0^{k+1} is moved to the RHS, becoming +r*u_0^{k+1} = +r*1.\n        rhs[0] += r\n        \n        # For the last interior point (j=N-1): u(L,t)=0.\n        # The term -r*u_N^{k+1} is moved to the RHS, becoming +r*u_N^{k+1} = +r*0.\n        # So, no change is needed for rhs[-1].\n\n        # Solve the tridiagonal system A * u_next_interior = rhs\n        u_interior_next = solve_banded((1, 1), A_banded, rhs)\n\n        # Update the interior points of the solution vector for the next time step.\n        u[1:N] = u_interior_next\n        \n        # Enforce boundary conditions on the full solution vector 'u'\n        # This is implicitly done for the interior points through the solve.\n        # We need to explicitly set them for the boundaries themselves, although\n        # they are not used in the next iteration's RHS calculation, it's good practice.\n        u[0] = 1.0\n        u[N] = 0.0\n\n    # After the loop, u contains the numerical solution at time t_star.\n    x_i = i * dx\n    u_num = u[i]\n\n    # Calculate the reference semi-infinite domain solution.\n    u_ref = erfc(x_i / (2 * np.sqrt(a * t_star)))\n\n    # Calculate the absolute error.\n    error = np.abs(u_num - u_ref)\n    \n    return error\n\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: a=1.0, L=1.0, N=200, dt=10^-5, t*=10^-3, i=1\n        (1.0, 1.0, 200, 1e-5, 1e-3, 1),\n        # Case B: a=1.0, L=1.0, N=100, dt=2x10^-4, t*=2x10^-2, i=2\n        (1.0, 1.0, 100, 2e-4, 2e-2, 2),\n        # Case C: a=0.2, L=0.5, N=100, dt=5x10^-5, t*=5x10^-3, i=1\n        (0.2, 0.5, 100, 5e-5, 5e-3, 1),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_case(case)\n        # Format the result to scientific notation with 8 decimal places.\n        results.append(f\"{error:.8e}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2403435"}]}