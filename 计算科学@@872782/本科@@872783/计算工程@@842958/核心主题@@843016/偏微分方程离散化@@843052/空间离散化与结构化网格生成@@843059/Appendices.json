{"hands_on_practices": [{"introduction": "在结构化网格上求解方程之前，我们必须首先量化计算空间到物理空间的转换如何影响长度、面积和角度。这是通过度量张量 $g_{ij}$ 和雅可比行列式 $J$ 来实现的。本练习将通过几个常见的变换实例，让您亲手实践计算这些基本量，从而将抽象的数学公式转化为具体的代码实现。[@problem_id:2436332]", "problem": "给定从计算坐标系 $(\\xi,\\eta)$ 到物理坐标系 $(x,y)$ 的光滑、二维、解析变换。令 $\\boldsymbol{r}(\\xi,\\eta) = (x(\\xi,\\eta), y(\\xi,\\eta))$。协变基向量定义为 $\\boldsymbol{r}_{\\xi} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\xi}$ 和 $\\boldsymbol{r}_{\\eta} = \\dfrac{\\partial \\boldsymbol{r}}{\\partial \\eta}$。协变度量张量分量由 $g_{ij} = \\boldsymbol{r}_{i} \\cdot \\boldsymbol{r}_{j}$ 定义，其中 $i,j \\in \\{\\xi,\\eta\\}$，具体为 $g_{\\xi\\xi}$、$g_{\\xi\\eta}$ 和 $g_{\\eta\\eta}$。雅可比行列式定义为 $J = \\det\\left(\\dfrac{\\partial(x,y)}{\\partial(\\xi,\\eta)}\\right)$。所有量均为无量纲。当变换中出现角度时，必须以弧度处理。\n\n编写一个程序，对下面列出的每个变换和求值点，计算列表 $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$，并将每个条目四舍五入到 $8$ 位小数。\n\n所需的测试套件如下，其中每个参数和求值坐标都已明确给出：\n\n- 测试用例 1（仿射映射）：$x(\\xi,\\eta) = a\\,\\xi + b\\,\\eta + c$, $y(\\xi,\\eta) = d\\,\\xi + e\\,\\eta + f$，参数 $(a,b,c,d,e,f) = (\\,2,\\,1,\\,0.5,\\,-1,\\,3,\\,1\\,)$，在 $(\\xi,\\eta) = (\\,0.3,\\,-0.7\\,)$ 处求值。\n- 测试用例 2（多项式偏斜）：$x(\\xi,\\eta) = \\xi + \\alpha\\,\\xi\\,\\eta$, $y(\\xi,\\eta) = \\eta + \\beta\\,\\xi^{2}$，参数 $(\\alpha,\\beta) = (\\,0.4,\\,-0.2\\,)$，在 $(\\xi,\\eta) = (\\,0.5,\\,-1.0\\,)$ 处求值。\n- 测试用例 3（极坐标式映射）：$x(\\xi,\\eta) = r\\cos\\theta$, $y(\\xi,\\eta) = r\\sin\\theta$，其中 $(\\xi,\\eta) = (r,\\theta)$，在 $(r,\\theta) = (\\,2.0,\\,\\pi/6\\,)$ 处求值。角度以弧度为单位。\n- 测试用例 4（三角函数扭曲）：$x(\\xi,\\eta) = \\xi + A\\sin(\\pi \\xi)\\sin(\\pi \\eta)$, $y(\\xi,\\eta) = \\eta + B\\sin(\\pi \\xi)\\sin(\\pi \\eta)$，参数 $(A,B) = (\\,0.1,\\,-0.15\\,)$，在 $(\\xi,\\eta) = (\\,0.25,\\,0.75\\,)$ 处求值。\n\n你的程序必须输出一行，包含一个列表的列表，其中每个内部列表按上述顺序对应一个测试用例，且每个内部列表的形式为 $[g_{\\xi\\xi}, g_{\\xi\\eta}, g_{\\eta\\eta}, J]$，每个浮点数四舍五入到 $8$ 位小数。例如，你的输出应具有以下形式\n$[[v_{11},v_{12},v_{13},v_{14}],[v_{21},v_{22},v_{23},v_{24}],[v_{31},v_{32},v_{33},v_{34}],[v_{41},v_{42},v_{43},v_{44}]]$\n其中每个 $v_{ij}$ 是一个四舍五入到 $8$ 位小数的浮点数。不应打印任何额外文本。", "solution": "所述问题是有效的。这是一个应用微分几何中的适定问题，是计算工程领域的基础，尤其适用于结构化网格的分析。所有定义、变换和参数均已提供，科学上合理，且没有歧义或矛盾。每个测试用例都存在唯一解。将根据所提供的定义直接计算求解。\n\n从计算坐标 $(\\xi, \\eta)$ 到物理坐标 $(x, y)$ 的变换由 $\\boldsymbol{r}(\\xi, \\eta) = (x(\\xi, \\eta), y(\\xi, \\eta))$ 给出。协变基向量为 $\\boldsymbol{r}_{\\xi} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\xi} = (\\frac{\\partial x}{\\partial \\xi}, \\frac{\\partial y}{\\partial \\xi})$ 和 $\\boldsymbol{r}_{\\eta} = \\frac{\\partial \\boldsymbol{r}}{\\partial \\eta} = (\\frac{\\partial x}{\\partial \\eta}, \\frac{\\partial y}{\\partial \\eta})$。\n\n根据这些向量，可以计算出协变度量张量 $g_{ij}$ 的分量和雅可比行列式 $J$。\n度量张量分量由基向量的点积给出：\n$$g_{\\xi\\xi} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\xi} = \\left(\\frac{\\partial x}{\\partial \\xi}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\xi}\\right)^2$$\n$$g_{\\eta\\eta} = \\boldsymbol{r}_{\\eta} \\cdot \\boldsymbol{r}_{\\eta} = \\left(\\frac{\\partial x}{\\partial \\eta}\\right)^2 + \\left(\\frac{\\partial y}{\\partial \\eta}\\right)^2$$\n$$g_{\\xi\\eta} = \\boldsymbol{r}_{\\xi} \\cdot \\boldsymbol{r}_{\\eta} = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial x}{\\partial \\eta} + \\frac{\\partial y}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta}$$\n雅可比行列式代表了局部面积元素的比率，由以下公式给出：\n$$J = \\det\\left(\\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix}\\right) = \\frac{\\partial x}{\\partial \\xi}\\frac{\\partial y}{\\partial \\eta} - \\frac{\\partial x}{\\partial \\eta}\\frac{\\partial y}{\\partial \\xi}$$\n我们现在将为每个指定的测试用例计算这四个量。\n\n测试用例 1：仿射映射\n变换为 $x(\\xi,\\eta) = a\\xi + b\\eta + c$ 和 $y(\\xi,\\eta) = d\\xi + e\\eta + f$，参数为 $(a,b,c,d,e,f) = (2, 1, 0.5, -1, 3, 1)$。偏导数为常数：\n$\\frac{\\partial x}{\\partial \\xi} = a = 2$\n$\\frac{\\partial x}{\\partial \\eta} = b = 1$\n$\\frac{\\partial y}{\\partial \\xi} = d = -1$\n$\\frac{\\partial y}{\\partial \\eta} = e = 3$\n这些值与求值点 $(\\xi,\\eta) = (0.3, -0.7)$ 无关。\n$g_{\\xi\\xi} = (2)^2 + (-1)^2 = 4 + 1 = 5$\n$g_{\\eta\\eta} = (1)^2 + (3)^2 = 1 + 9 = 10$\n$g_{\\xi\\eta} = (2)(1) + (-1)(3) = 2 - 3 = -1$\n$J = (2)(3) - (1)(-1) = 6 + 1 = 7$\n所需的列表为 $[5.0, -1.0, 10.0, 7.0]$。\n\n测试用例 2：多项式偏斜\n变换为 $x(\\xi,\\eta) = \\xi + \\alpha\\xi\\eta$ 和 $y(\\xi,\\eta) = \\eta + \\beta\\xi^2$，参数为 $(\\alpha, \\beta) = (0.4, -0.2)$。\n偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + \\alpha\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = \\alpha\\xi$\n$\\frac{\\partial y}{\\partial \\xi} = 2\\beta\\xi$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n在 $(\\xi, \\eta) = (0.5, -1.0)$ 处求值：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.4)(-1.0) = 1 - 0.4 = 0.6$\n$\\frac{\\partial x}{\\partial \\eta} = (0.4)(0.5) = 0.2$\n$\\frac{\\partial y}{\\partial \\xi} = 2(-0.2)(0.5) = -0.2$\n$\\frac{\\partial y}{\\partial \\eta} = 1$\n$g_{\\xi\\xi} = (0.6)^2 + (-0.2)^2 = 0.36 + 0.04 = 0.4$\n$g_{\\eta\\eta} = (0.2)^2 + (1)^2 = 0.04 + 1 = 1.04$\n$g_{\\xi\\eta} = (0.6)(0.2) + (-0.2)(1) = 0.12 - 0.2 = -0.08$\n$J = (0.6)(1) - (0.2)(-0.2) = 0.6 + 0.04 = 0.64$\n所需的列表为 $[0.4, -0.08, 1.04, 0.64]$。\n\n测试用例 3：极坐标式映射\n变换为 $x(r,\\theta) = r\\cos\\theta$ 和 $y(r,\\theta) = r\\sin\\theta$，其中计算坐标被确定为 $(\\xi, \\eta) = (r, \\theta)$。\n关于 $\\xi=r$ 和 $\\eta=\\theta$ 的偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = \\cos\\eta$\n$\\frac{\\partial x}{\\partial \\eta} = -\\xi\\sin\\eta$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin\\eta$\n$\\frac{\\partial y}{\\partial \\eta} = \\xi\\cos\\eta$\n在 $(\\xi, \\eta) = (2.0, \\pi/6)$ 处求值：\n$\\frac{\\partial x}{\\partial \\xi} = \\cos(\\pi/6) = \\frac{\\sqrt{3}}{2}$\n$\\frac{\\partial x}{\\partial \\eta} = -2\\sin(\\pi/6) = -2(\\frac{1}{2}) = -1$\n$\\frac{\\partial y}{\\partial \\xi} = \\sin(\\pi/6) = \\frac{1}{2}$\n$\\frac{\\partial y}{\\partial \\eta} = 2\\cos(\\pi/6) = 2(\\frac{\\sqrt{3}}{2}) = \\sqrt{3}$\n$g_{\\xi\\xi} = (\\frac{\\sqrt{3}}{2})^2 + (\\frac{1}{2})^2 = \\frac{3}{4} + \\frac{1}{4} = 1$\n$g_{\\eta\\eta} = (-1)^2 + (\\sqrt{3})^2 = 1 + 3 = 4$\n$g_{\\xi\\eta} = (\\frac{\\sqrt{3}}{2})(-1) + (\\frac{1}{2})(\\sqrt{3}) = 0$\n$J = (\\frac{\\sqrt{3}}{2})(\\sqrt{3}) - (-1)(\\frac{1}{2}) = \\frac{3}{2} + \\frac{1}{2} = 2$\n所需的列表为 $[1.0, 0.0, 4.0, 2.0]$。\n\n测试用例 4：三角函数扭曲\n变换为 $x(\\xi,\\eta) = \\xi + A\\sin(\\pi\\xi)\\sin(\\pi\\eta)$ 和 $y(\\xi,\\eta) = \\eta + B\\sin(\\pi\\xi)\\sin(\\pi\\eta)$，参数为 $(A, B) = (0.1, -0.15)$。\n偏导数为：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + A\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial x}{\\partial \\eta} = A\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\xi} = B\\pi\\cos(\\pi\\xi)\\sin(\\pi\\eta)$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + B\\pi\\sin(\\pi\\xi)\\cos(\\pi\\eta)$\n在 $(\\xi, \\eta) = (0.25, 0.75)$ 处求值：\n我们有 $\\pi\\xi = \\pi/4$ 和 $\\pi\\eta = 3\\pi/4$。\n$\\cos(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\sin(\\pi/4) = \\frac{\\sqrt{2}}{2}$, $\\cos(3\\pi/4) = -\\frac{\\sqrt{2}}{2}$, $\\sin(3\\pi/4) = \\frac{\\sqrt{2}}{2}$。\n因此，$\\cos(\\pi\\xi)\\sin(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(\\frac{\\sqrt{2}}{2}) = 0.5$ 且 $\\sin(\\pi\\xi)\\cos(\\pi\\eta) = (\\frac{\\sqrt{2}}{2})(-\\frac{\\sqrt{2}}{2}) = -0.5$。\n代入这些值：\n$\\frac{\\partial x}{\\partial \\xi} = 1 + (0.1)\\pi(0.5) = 1 + 0.05\\pi$\n$\\frac{\\partial x}{\\partial \\eta} = (0.1)\\pi(-0.5) = -0.05\\pi$\n$\\frac{\\partial y}{\\partial \\xi} = (-0.15)\\pi(0.5) = -0.075\\pi$\n$\\frac{\\partial y}{\\partial \\eta} = 1 + (-0.15)\\pi(-0.5) = 1 + 0.075\\pi$\n$g_{\\xi\\xi} = (1+0.05\\pi)^2 + (-0.075\\pi)^2 = 1 + 0.1\\pi + 0.0025\\pi^2 + 0.005625\\pi^2 = 1 + 0.1\\pi + 0.008125\\pi^2 \\approx 1.39435068$\n$g_{\\eta\\eta} = (-0.05\\pi)^2 + (1+0.075\\pi)^2 = 0.0025\\pi^2 + 1 + 0.15\\pi + 0.005625\\pi^2 = 1 + 0.15\\pi + 0.008125\\pi^2 \\approx 1.55142551$\n$g_{\\xi\\eta} = (1+0.05\\pi)(-0.05\\pi) + (-0.075\\pi)(1+0.075\\pi) = -0.05\\pi - 0.0025\\pi^2 - 0.075\\pi - 0.005625\\pi^2 = -0.125\\pi - 0.008125\\pi^2 \\approx -0.47289237$\n$J = (1+0.05\\pi)(1+0.075\\pi) - (-0.05\\pi)(-0.075\\pi) = 1 + 0.125\\pi + 0.00375\\pi^2 - 0.00375\\pi^2 = 1 + 0.125\\pi \\approx 1.39269908$\n所需的列表，四舍五入到 8 位小数后为 $[1.39435068, -0.47289237, 1.55142551, 1.39269908]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the metric tensor components and Jacobian for four\n    different coordinate transformations.\n    \"\"\"\n\n    def case1():\n        \"\"\"Affine mapping.\"\"\"\n        a, b, c, d, e, f = 2, 1, 0.5, -1, 3, 1\n        # xi, eta = 0.3, -0.7 # Not needed as derivatives are constant\n        \n        # Partial derivatives\n        x_xi = a\n        x_eta = b\n        y_xi = d\n        y_eta = e\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case2():\n        \"\"\"Polynomial skew.\"\"\"\n        alpha, beta = 0.4, -0.2\n        xi, eta = 0.5, -1.0\n        \n        # Partial derivatives\n        x_xi = 1 + alpha * eta\n        x_eta = alpha * xi\n        y_xi = 2 * beta * xi\n        y_eta = 1\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case3():\n        \"\"\"Polar-type mapping.\"\"\"\n        xi, eta = 2.0, np.pi / 6.0 # (r, theta)\n        \n        # Partial derivatives\n        x_xi = np.cos(eta)       # dx/dr\n        x_eta = -xi * np.sin(eta) # dx/dtheta\n        y_xi = np.sin(eta)       # dy/dr\n        y_eta = xi * np.cos(eta)  # dy/dtheta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    def case4():\n        \"\"\"Trigonometric warp.\"\"\"\n        A, B = 0.1, -0.15\n        xi, eta = 0.25, 0.75\n        \n        pi_xi = np.pi * xi\n        pi_eta = np.pi * eta\n        \n        # Common trigonometric terms\n        cos_xi_sin_eta = np.cos(pi_xi) * np.sin(pi_eta)\n        sin_xi_cos_eta = np.sin(pi_xi) * np.cos(pi_eta)\n        \n        # Partial derivatives\n        x_xi = 1 + A * np.pi * cos_xi_sin_eta\n        x_eta = A * np.pi * sin_xi_cos_eta\n        y_xi = B * np.pi * cos_xi_sin_eta\n        y_eta = 1 + B * np.pi * sin_xi_cos_eta\n        \n        # Metric components\n        g_xixi = x_xi**2 + y_xi**2\n        g_etaeta = x_eta**2 + y_eta**2\n        g_xieta = x_xi * x_eta + y_xi * y_eta\n        \n        # Jacobian\n        J = x_xi * y_eta - x_eta * y_xi\n        \n        return [g_xixi, g_xieta, g_etaeta, J]\n\n    results = []\n    case_functions = [case1, case2, case3, case4]\n\n    for func in case_functions:\n        raw_result = func()\n        rounded_result = [round(val, 8) for val in raw_result]\n        results.append(rounded_result)\n    \n    # Generate the output string exactly as specified, without spaces\n    print(repr(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2436332"}, {"introduction": "真实世界的工程问题通常涉及复杂的几何形状，这使得曲线坐标网格的应用必不可少。本练习聚焦于一项至关重要的实践技能：如何将在物理边界上定义的条件（例如指定的通量）准确地转换到计算域中。通过运用链式法则和坐标变换的性质，您将推导出在曲线边界上施加诺伊曼条件 $\\nabla u \\cdot \\mathbf{n} = f(\\eta)$ 的数值格式，从而揭示网格度量与偏微分方程离散化之间的直接联系。[@problem_id:2436335]", "problem": "考虑一个二维标量场 $u(x,y)$，它定义在一个弯曲的物理域上。该物理域由一个从坐标为 $(\\xi,\\eta) \\in [0,L] \\times [0,\\Theta]$ 的矩形计算域出发的光滑一一映射得到。该映射由下式给出：\n$$\nx(\\xi,\\eta) = (R_0 + \\xi)\\cos \\eta, \\qquad y(\\xi,\\eta) = (R_0 + \\xi)\\sin \\eta,\n$$\n其中 $R_00$，$L0$ 和 $\\Theta \\in (0,2\\pi]$ 是常数，角度 $\\eta$ 以弧度为单位。边界 $\\xi=0$ 对应于半径为 $R_0$ 的圆弧，坐标 $\\xi$ 向区域内部（即远离边界的方向）增加。设边界 $\\xi=0$ 上的外单位法向量用 $\\mathbf{n}$ 表示，并假设在 $\\xi=0$ 上的诺伊曼（Neumann）边界条件为\n$$\n\\nabla u \\cdot \\mathbf{n} = f(\\eta),\n$$\n其中 $f(\\eta)$ 是一个给定的光滑函数。\n\n在计算域中引入一个结构化网格，其在 $\\xi$ 方向上具有均匀间距 $\\Delta \\xi$，节点在 $\\xi$ 方向上由 $i$ 索引，在 $\\eta$ 方向上由 $j$ 索引。为了在 $\\xi=0$ 处对边界条件进行二阶精确的有限差分处理，沿着每条 $\\eta=\\eta_j$ 网格线，在计算域外引入一个索引为 $i=-1$ 的虚拟点。记 $u_{i,j} \\approx u(x(\\xi_i,\\eta_j),y(\\xi_i,\\eta_j))$。\n\n仅从坐标变换的链式法则和等值面法向量的定义出发，推导一个二阶精确的关系式，该关系式通过使用中心差分计算沿 $\\xi$ 的导数来施加在 $\\xi=0$ 处的诺伊曼条件，从而消去虚拟值 $u_{-1,j}$。将您的最终结果表示为 $u_{-1,j}$ 关于 $u_{1,j}$、$\\Delta \\xi$ 和 $f(\\eta_j)$ 的闭式解析表达式，特别是针对上面给出的映射。\n\n您的最终答案必须是 $u_{-1,j}$ 作为 $u_{1,j}$、$\\Delta \\xi$ 和 $f(\\eta_j)$ 的函数的单个闭式解析表达式。", "solution": "这个问题是有效的，因为它科学地基于计算工程的原理，是适定的，并且以客观、数学精确的方式陈述。它要求在曲线网格上推导诺伊曼边界条件的有限差分格式，这是偏微分方程数值方法中的一个标准程序。\n\n目标是找到虚拟点值 $u_{-1,j}$ 的表达式，以在 $\\xi=0$ 处实现一个二阶精确的诺伊曼边界条件。边界条件在物理坐标 $(x,y)$ 中给出：\n$$\n\\nabla u \\cdot \\mathbf{n} = f(\\eta)\n$$\n其中 $\\mathbf{n}$ 是边界 $\\xi=0$ 上的外单位法向量。\n\n我们必须将这个条件转换到计算坐标 $(\\xi,\\eta)$ 中。推导过程分为几个步骤。\n\n首先，我们建立物理坐标中的梯度算子 $\\nabla = \\mathbf{i} \\frac{\\partial}{\\partial x} + \\mathbf{j} \\frac{\\partial}{\\partial y}$ 与计算坐标中的偏导数 $\\frac{\\partial}{\\partial \\xi}$ 和 $\\frac{\\partial}{\\partial \\eta}$ 之间的关系。使用链式法则，函数 $u$ 关于物理坐标 $(x,y)$ 的偏导数由下式给出：\n$$\n\\frac{\\partial u}{\\partial x} = \\frac{\\partial u}{\\partial \\xi}\\frac{\\partial \\xi}{\\partial x} + \\frac{\\partial u}{\\partial \\eta}\\frac{\\partial \\eta}{\\partial x}\n$$\n$$\n\\frac{\\partial u}{\\partial y} = \\frac{\\partial u}{\\partial \\xi}\\frac{\\partial \\xi}{\\partial y} + \\frac{\\partial u}{\\partial \\eta}\\frac{\\partial \\eta}{\\partial y}\n$$\n这使我们能够将物理梯度 $\\nabla u$ 表示为：\n$$\n\\nabla u = \\left(\\frac{\\partial u}{\\partial \\xi}\\frac{\\partial \\xi}{\\partial x} + \\frac{\\partial u}{\\partial \\eta}\\frac{\\partial \\eta}{\\partial x}\\right)\\mathbf{i} + \\left(\\frac{\\partial u}{\\partial \\xi}\\frac{\\partial \\xi}{\\partial y} + \\frac{\\partial u}{\\partial \\eta}\\frac{\\partial \\eta}{\\partial y}\\right)\\mathbf{j}\n$$\n重新整理各项，我们得到：\n$$\n\\nabla u = \\frac{\\partial u}{\\partial \\xi}\\left(\\frac{\\partial \\xi}{\\partial x}\\mathbf{i} + \\frac{\\partial \\xi}{\\partial y}\\mathbf{j}\\right) + \\frac{\\partial u}{\\partial \\eta}\\left(\\frac{\\partial \\eta}{\\partial x}\\mathbf{i} + \\frac{\\partial \\eta}{\\partial y}\\mathbf{j}\\right) = \\frac{\\partial u}{\\partial \\xi}\\nabla\\xi + \\frac{\\partial u}{\\partial \\eta}\\nabla\\eta\n$$\n$\\nabla\\xi$ 和 $\\nabla\\eta$ 是计算坐标的梯度，它们充当逆变基向量。为了求出这些，我们首先计算从 $(\\xi,\\eta)$ 到 $(x,y)$ 的给定坐标变换的雅可比(Jacobian)矩阵 $J$：\n$$\nx(\\xi,\\eta) = (R_0 + \\xi)\\cos \\eta, \\qquad y(\\xi,\\eta) = (R_0 + \\xi)\\sin \\eta\n$$\n偏导数是：\n$$\n\\frac{\\partial x}{\\partial \\xi} = \\cos \\eta, \\quad \\frac{\\partial x}{\\partial \\eta} = -(R_0 + \\xi)\\sin \\eta\n$$\n$$\n\\frac{\\partial y}{\\partial \\xi} = \\sin \\eta, \\quad \\frac{\\partial y}{\\partial \\eta} = (R_0 + \\xi)\\cos \\eta\n$$\n雅可比矩阵是：\n$$\nJ = \\begin{pmatrix} \\frac{\\partial x}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\eta} \\\\ \\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\cos \\eta  -(R_0 + \\xi)\\sin \\eta \\\\ \\sin \\eta  (R_0 + \\xi)\\cos \\eta \\end{pmatrix}\n$$\n所需的导数，例如 $\\frac{\\partial \\xi}{\\partial x}$，是逆雅可比矩阵 $J^{-1}$ 的元素。\n$$\nJ^{-1} = \\begin{pmatrix} \\frac{\\partial \\xi}{\\partial x}  \\frac{\\partial \\xi}{\\partial y} \\\\ \\frac{\\partial \\eta}{\\partial x}  \\frac{\\partial \\eta}{\\partial y} \\end{pmatrix} = \\frac{1}{\\det(J)} \\begin{pmatrix} \\frac{\\partial y}{\\partial \\eta}  -\\frac{\\partial x}{\\partial \\eta} \\\\ -\\frac{\\partial y}{\\partial \\xi}  \\frac{\\partial x}{\\partial \\xi} \\end{pmatrix}\n$$\n行列式为 $\\det(J) = (\\cos \\eta)((R_0 + \\xi)\\cos \\eta) - (-(R_0 + \\xi)\\sin \\eta)(\\sin \\eta) = (R_0 + \\xi)(\\cos^2 \\eta + \\sin^2 \\eta) = R_0 + \\xi$。\n$$\nJ^{-1} = \\frac{1}{R_0 + \\xi} \\begin{pmatrix} (R_0 + \\xi)\\cos \\eta  (R_0 + \\xi)\\sin \\eta \\\\ -\\sin \\eta  \\cos \\eta \\end{pmatrix} = \\begin{pmatrix} \\cos \\eta  \\sin \\eta \\\\ -\\frac{\\sin \\eta}{R_0 + \\xi}  \\frac{\\cos \\eta}{R_0 + \\xi} \\end{pmatrix}\n$$\n由此，我们提取 $\\nabla\\xi$ 的分量：\n$$\n\\nabla\\xi = \\frac{\\partial \\xi}{\\partial x}\\mathbf{i} + \\frac{\\partial \\xi}{\\partial y}\\mathbf{j} = \\cos\\eta \\, \\mathbf{i} + \\sin\\eta \\, \\mathbf{j}\n$$\n接下来，我们确定外单位法向量 $\\mathbf{n}$。边界是坐标函数 $\\xi$ 的一个等值面，具体为 $\\xi=0$。向量 $\\nabla\\xi$ 与 $\\xi$ 的所有等值面都垂直。问题陈述中指出，$\\xi$ 的值向区域*内部*增加，即远离边界 $\\xi=0$。这意味着区域对应于 $\\xi  0$，物理区域是一个内半径为 $R_0$ 的环形扇区。对于这样一个区域，内边界 $\\xi=0$ 上的“外”法线指向区域内部的相反方向，即朝向曲率中心（原点）。向量 $\\nabla\\xi = \\cos\\eta \\, \\mathbf{i} + \\sin\\eta \\, \\mathbf{j}$ 径向向外指，即 $\\xi$ 增加的方向。因此，外单位法向量 $\\mathbf{n}$ 的方向与 $\\nabla\\xi$ 相反。\n$$\n\\mathbf{n} = - \\frac{\\nabla\\xi}{|\\nabla\\xi|}\n$$\n$\\nabla\\xi$ 的模是 $|\\nabla\\xi| = \\sqrt{\\cos^2\\eta + \\sin^2\\eta} = 1$。所以，$\\mathbf{n} = -\\nabla\\xi$。\n\n现在我们将这些表达式代回边界条件中：\n$$\n\\nabla u \\cdot \\mathbf{n} = \\left(\\frac{\\partial u}{\\partial \\xi}\\nabla\\xi + \\frac{\\partial u}{\\partial \\eta}\\nabla\\eta\\right) \\cdot (-\\nabla\\xi) = -\\frac{\\partial u}{\\partial \\xi}(\\nabla\\xi \\cdot \\nabla\\xi) - \\frac{\\partial u}{\\partial \\eta}(\\nabla\\eta \\cdot \\nabla\\xi) = f(\\eta)\n$$\n我们需要基向量的点积。我们已经有 $\\nabla\\xi \\cdot \\nabla\\xi = |\\nabla\\xi|^2 = 1$。对于另一个点积：\n$$\n\\nabla\\eta = -\\frac{\\sin \\eta}{R_0 + \\xi} \\mathbf{i} + \\frac{\\cos \\eta}{R_0 + \\xi} \\mathbf{j}\n$$\n$$\n\\nabla\\eta \\cdot \\nabla\\xi = \\left(-\\frac{\\sin \\eta}{R_0 + \\xi}\\right)(\\cos\\eta) + \\left(\\frac{\\cos \\eta}{R_0 + \\xi}\\right)(\\sin\\eta) = 0\n$$\n这个点积为零的事实证实了 $(\\xi, \\eta)$ 坐标系是正交的。边界条件大大简化为：\n$$\n-\\frac{\\partial u}{\\partial \\xi}(1) - \\frac{\\partial u}{\\partial \\eta}(0) = f(\\eta) \\implies \\left.\\frac{\\partial u}{\\partial \\xi}\\right|_{\\xi=0} = -f(\\eta)\n$$\n这就是用计算坐标表示的诺伊曼边界条件。\n\n为了以二阶精度对此进行数值实现，我们在边界节点 $(\\xi_i, \\eta_j)$（其中 $i=0$）处使用中心差分近似来计算导数 $\\frac{\\partial u}{\\partial \\xi}$。网格点为 $\\xi_i = i \\Delta\\xi$。中心差分涉及域内点 $\\xi_1 = \\Delta\\xi$ 和域外虚拟点 $\\xi_{-1} = -\\Delta\\xi$：\n$$\n\\left.\\frac{\\partial u}{\\partial \\xi}\\right|_{\\xi=0, \\eta=\\eta_j} \\approx \\frac{u(\\xi_1, \\eta_j) - u(\\xi_{-1}, \\eta_j)}{2\\Delta\\xi} = \\frac{u_{1,j} - u_{-1,j}}{2\\Delta\\xi}\n$$\n将此式与在离散网格线 $\\eta = \\eta_j$ 处推导出的条件等同起来：\n$$\n\\frac{u_{1,j} - u_{-1,j}}{2\\Delta\\xi} = -f(\\eta_j)\n$$\n最后，我们求解虚拟点值 $u_{-1,j}$：\n$$\nu_{1,j} - u_{-1,j} = -2\\Delta\\xi f(\\eta_j)\n$$\n$$\nu_{-1,j} = u_{1,j} + 2\\Delta\\xi f(\\eta_j)\n$$\n这个表达式允许在离散化的内部方程中消去虚拟值 $u_{-1,j}$，从而以二阶精度施加诺伊曼边界条件。", "answer": "$$\n\\boxed{u_{-1,j} = u_{1,j} + 2\\Delta\\xi f(\\eta_j)}\n$$", "id": "2436335"}, {"introduction": "这项高级实践探讨了全球尺度建模中的一个关键挑战：由纬经网格在极点处的坐标奇点引起的数值刚度问题。通过在球面上离散化热传导方程并分析离散算子的特征值，您将定量地研究极点附近网格单元的汇聚如何严重限制显式时间积分方法的稳定时间步长。这个练习将网格拓扑结构与数值模拟的稳定性和效率直接联系起来，加深您对网格质量重要性的理解。[@problem_id:2436359]", "problem": "您的任务是在一个球带上构建一个结构化的纬度-经度网格，并以守恒形式离散化一个偏微分方程（PDE），以分析在极点附近产生的数值刚度。考虑单位球面上的线性扩散方程（热方程）：\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u,\n$$\n其中 $u = u(\\phi,\\lambda,t)$，$\\kappa  0$ 是一个常数扩散系数，$\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$ 是纬度（以弧度为单位），$\\lambda \\in [0,2\\pi)$ 是经度（以弧度为单位）。在纬度-经度坐标系中，单位球面上的 Laplace–Beltrami 算子为\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\n在整个过程中，角度必须以弧度处理。\n\n您的任务：\n\n1) 从 Laplace–Beltrami 算子的定义和单位球面的度量出发，在球带 $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$, $\\lambda \\in [0,2\\pi)$ 上的均匀纬度-经度网格上，推导出一个二阶精度的、守恒通量形式的中心有限差分离散格式。不要包含极冠；也就是说，强制 $\\phi_{\\max}  \\frac{\\pi}{2}$，以确保 $\\cos \\phi$ 在计算域上保持严格为正。\n\n2) 在经度方向使用周期性边界条件，在人工边界 $\\phi = \\pm \\phi_{\\max}$ 处使用零法向通量条件。零法向通量条件意味着通过边界的经向通量为零，这与从球体上切割出一个带状区域的情况相符。\n\n3) 将离散空间算子组装成一个作用于向量化网格函数值的矩阵。您的构造必须精确地遵循连续算子所隐含的度量因子。为了实现稳健且精确的谱特征分析，您的推导结构应使组装后的矩阵与一个实对称矩阵对角相似。\n\n4) 对于应用于半离散系统 $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$ 的显式（前向）Euler 时间步进法，根据 $\\kappa A$ 的谱确定其所允许的最大稳定时间步长 $\\Delta t_{\\max}$。请使用应用于具有实非正特征值的线性系统的显式 Euler 法的标准线性稳定性要求。\n\n5) 通过量化 $\\Delta t_{\\max}$ 如何随着网格接近极点（即 $\\phi_{\\max} \\to \\frac{\\pi}{2}$）以及经度分辨率的增加而变化，来研究由极点奇异性引起的数值刚度。使用离散算子计算时间步长限制所需的谱半径。\n\n构建一个程序，对于以下每个测试用例，该程序构建离散算子并返回相应的最大稳定显式 Euler 时间步长 $\\Delta t_{\\max}$（作为一个浮点数）：\n\n- 情况 1：$N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$。\n- 情况 2：$N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.02$, $\\kappa = 1$。\n- 情况 3：$N_\\phi = 24$, $N_\\lambda = 48$, $\\phi_{\\max} = \\frac{\\pi}{4}$, $\\kappa = 1$。\n- 情况 4：$N_\\phi = 24$, $N_\\lambda = 96$, $\\phi_{\\max} = \\frac{\\pi}{2} - 0.2$, $\\kappa = 1$。\n\n此处，$N_\\phi$ 和 $N_\\lambda$ 分别表示纬度和经度方向上均匀间隔的网格点数。均匀间距为 $\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ 和 $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$。\n\n最终程序必须为每个情况计算由组装算子的谱所允许的最大显式 Euler 时间步长 $\\Delta t_{\\max}$。所有角度均以弧度为单位。不涉及除弧度以外的其他物理单位。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4]”）。每个结果都必须是浮点数。程序必须是自包含的，并且不需要任何输入。四个输出必须按顺序对应于情况 1 到情况 4。", "solution": "该问题要求为球带上的线性扩散方程推导一个稳定的数值格式，然后对其数值刚度进行定量分析。分析将通过对控制偏微分方程进行严格离散化、组装离散算子以及进行谱分析来确定显式时间积分格式的稳定性极限。\n\n控制方程是单位球面上的热方程，由下式给出\n$$\n\\frac{\\partial u}{\\partial t} = \\kappa \\,\\Delta_S u\n$$\n其中 $u(\\phi, \\lambda, t)$ 是我们关心的量（例如温度），$\\kappa  0$ 是扩散系数，$\\phi$ 是纬度，$\\lambda$ 是经度，$\\Delta_S$ 是 Laplace-Beltrami 算子：\n$$\n\\Delta_S u = \\frac{1}{\\cos \\phi}\\,\\frac{\\partial}{\\partial \\phi}\\!\\left(\\cos \\phi \\,\\frac{\\partial u}{\\partial \\phi}\\right) + \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2}.\n$$\n计算域是一个由 $\\phi \\in [-\\phi_{\\max}, \\phi_{\\max}]$（其中 $\\phi_{\\max}  \\pi/2$）和 $\\lambda \\in [0, 2\\pi)$ 定义的球带。\n\n定义一个均匀网格，纬度方向有 $N_\\phi$ 个点，经度方向有 $N_\\lambda$ 个点。网格点为 $(\\phi_j, \\lambda_k)$，其中 $j=0, \\dots, N_\\phi-1$，$k=0, \\dots, N_\\lambda-1$。网格间距是均匀的：$\\Delta \\phi = \\frac{2\\phi_{\\max}}{N_\\phi - 1}$ 和 $\\Delta \\lambda = \\frac{2\\pi}{N_\\lambda}$。纬度坐标为 $\\phi_j = -\\phi_{\\max} + j\\Delta\\phi$。\n\n空间算子使用二阶中心有限差分进行离散。设 $u_{j,k} \\approx u(\\phi_j, \\lambda_k)$。\n纬向（经度）项离散为：\n$$\n\\left. \\frac{1}{\\cos^2 \\phi}\\,\\frac{\\partial^2 u}{\\partial \\lambda^2} \\right|_{j,k} \\approx \\frac{1}{\\cos^2 \\phi_j} \\frac{u_{j, k+1} - 2u_{j,k} + u_{j, k-1}}{\\Delta\\lambda^2}.\n$$\n经度方向的周期性意味着 $u_{j, N_\\lambda} = u_{j,0}$ 和 $u_{j, -1} = u_{j, N_\\lambda-1}$。\n\n经向（纬度）项是守恒形式，通过在网格线之间的中点（单元面）$\\phi_{j\\pm1/2} = \\phi_j \\pm \\Delta\\phi/2$ 定义经向通量来进行离散。通量为 $F_\\phi = \\cos\\phi \\, \\frac{\\partial u}{\\partial \\phi}$。\n$$\n\\left. F_\\phi \\right|_{\\phi_{j+1/2}} \\approx \\cos(\\phi_{j+1/2}) \\frac{u_{j+1,k} - u_{j,k}}{\\Delta\\phi}\n$$\n在网格点 $\\phi_j$ 处通量的散度则通过单元面通量的中心差分来近似：\n$$\n\\left. \\frac{1}{\\cos \\phi} \\frac{\\partial F_\\phi}{\\partial \\phi} \\right|_{j,k} \\approx \\frac{1}{\\cos \\phi_j} \\frac{F_{\\phi, j+1/2} - F_{\\phi, j-1/2}}{\\Delta\\phi}\n$$\n$$\n= \\frac{1}{\\cos \\phi_j \\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2})(u_{j+1,k} - u_{j,k}) - \\cos(\\phi_{j-1/2})(u_{j,k} - u_{j-1,k}) \\right).\n$$\n此表达式对内部点 $j = 1, \\dots, N_\\phi-2$ 有效。\n\n边界条件是在 $\\phi = \\pm\\phi_{\\max}$ 处法向通量为零。经向通量 $F_\\phi$ 在这些边界上必须为零。由于 $\\phi_{\\max}  \\pi/2$，$\\cos(\\pm\\phi_{\\max}) \\neq 0$，因此条件简化为在 $\\phi = \\pm\\phi_{\\max}$ 处 $\\frac{\\partial u}{\\partial \\phi} = 0$。\n在下边界 $\\phi_0 = -\\phi_{\\max}$ 处，流入通量 $F_{\\phi, -1/2}$ 为零。在 $j=0$ 处的离散变为：\n$$\n\\left. \\Delta_S u \\right|_{0,k} \\approx \\frac{1}{\\cos \\phi_0 \\Delta\\phi^2} \\left( \\cos(\\phi_{1/2})(u_{1,k} - u_{0,k}) \\right) + \\frac{u_{0,k+1} - 2u_{0,k} + u_{0,k-1}}{\\cos^2 \\phi_0 \\Delta\\lambda^2}.\n$$\n在上边界 $\\phi_{N_\\phi-1} = \\phi_{\\max}$ 处，流出通量 $F_{\\phi, N_\\phi-1/2}$ 为零。在 $j=N_\\phi-1$ 处的离散变为：\n$$\n\\left. \\Delta_S u \\right|_{N_\\phi-1,k} \\approx \\frac{1}{\\cos \\phi_{N_\\phi-1} \\Delta\\phi^2} \\left( -\\cos(\\phi_{N_\\phi-3/2})(u_{N_\\phi-1,k} - u_{N_\\phi-2,k}) \\right) + \\frac{u_{N_\\phi-1,k+1} - 2u_{N_\\phi-1,k} + u_{N_\\phi-1,k-1}}{\\cos^2 \\phi_{N_\\phi-1} \\Delta\\lambda^2}.\n$$\n常微分方程的半离散系统为 $\\frac{d\\mathbf{u}}{dt} = \\kappa A \\mathbf{u}$，其中 $\\mathbf{u}$ 是所有网格点值 $u_{j,k}$ 的向量，$A$ 是离散 Laplace-Beltrami 算子的矩阵表示。$A$ 的元素由上面推导的差分格式确定。矩阵 $A$ 的大小为 $(N_\\phi N_\\lambda) \\times (N_\\phi N_\\lambda)$。\n\n问题要求 $A$ 与一个实对称矩阵对角相似。连续算子 $\\Delta_S$ 对于包含曲面面积元的内积 $\\langle f, g \\rangle = \\iint f g \\cos\\phi \\,d\\phi\\,d\\lambda$ 是自伴的。此性质的离散对应是矩阵 $D A$ 应该是对称的，其中 $D$ 是一个对角矩阵，其元素为 $d_{j,k} = \\cos \\phi_j$。我们来验证这一点。将第 $j$ 行方程乘以 $\\cos\\phi_j$，经向部分变为：\n$$\n\\frac{1}{\\Delta\\phi^2} \\left( \\cos(\\phi_{j+1/2}) u_{j+1,k} - (\\cos(\\phi_{j+1/2}) + \\cos(\\phi_{j-1/2})) u_{j,k} + \\cos(\\phi_{j-1/2}) u_{j-1,k} \\right).\n$$\n对于固定的经度 $k$，这对应于一个对称三对角矩阵。纬向部分变为：\n$$\n\\frac{1}{\\cos \\phi_j \\Delta\\lambda^2} (u_{j, k+1} - 2u_{j,k} + u_{j, k-1}).\n$$\n当组装成完整矩阵 $M = D A$ 时，由这两项组成的算子是对称的。由于 $D$ 是对角矩阵，且对于 $|\\phi_j|  \\pi/2$ 其对角元 $\\cos \\phi_j  0$ 为正，因此 $A$ 与对称矩阵 $D^{1/2} A D^{-1/2} = D^{-1/2} M D^{-1/2}$ 相似。这保证了 $A$ 的特征值是实数。此外，算子 $A$ 代表扩散，所以其特征值 $\\lambda_i$ 是非正的，即 $\\lambda_i \\le 0$。\n\n对于显式（前向）Euler 格式 $\\mathbf{u}^{n+1} = (I + \\Delta t \\kappa A)\\mathbf{u}^n$ 的数值稳定性，每个特征模态的放大因子其模不得大于 1。对于实非正特征值 $\\kappa \\lambda_i$，条件是 $|1 + \\Delta t \\kappa \\lambda_i| \\le 1$。这意味着 $-2 \\le \\Delta t \\kappa \\lambda_i \\le 0$。由于 $\\Delta t, \\kappa  0$ 且 $\\lambda_i \\le 0$，这可简化为 $\\Delta t \\kappa \\lambda_{\\min} \\ge -2$，其中 $\\lambda_{\\min}$ 是 $A$ 的最小（最负）特征值。因此，最大稳定时间步长为\n$$\n\\Delta t_{\\max} = \\frac{-2}{\\kappa \\lambda_{\\min}(A)}.\n$$\n数值刚度源于纬向项中的 $1/\\cos^2\\phi$ 因子。当 $\\phi_{\\max} \\to \\pi/2$ 时，经度网格线汇聚。对于固定的 $\\Delta\\lambda$，纬向的网格点之间的物理距离 $\\cos\\phi_j \\Delta\\lambda$ 变得非常小。对 $\\Delta t$ 的稳定性限制受限于域中最小网格间距的平方，导致 $\\Delta t_{\\max} \\propto (\\cos\\phi_{\\max} \\Delta\\lambda)^2$。因此，对于延伸到靠近极点或具有高纬向分辨率（$N_\\lambda$）的网格，$\\Delta t_{\\max}$ 会变得极端小，这是数值刚度的一个典型症状。\n\n最后一步是对此过程进行计算实现：组装矩阵 $A$，找到其最小特征值，并为给定的测试用例计算 $\\Delta t_{\\max}$。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef construct_operator_and_solve(N_phi, N_lambda, phi_max, kappa):\n    \"\"\"\n    Constructs the discrete operator for the heat equation on a spherical band\n    and computes the maximum stable time step for the explicit Euler method.\n    \"\"\"\n    # 1. Define grid parameters\n    phi = np.linspace(-phi_max, phi_max, N_phi, dtype=np.float64)\n    # Ensure robust calculation of delta_phi, especially if N_phi=1\n    if N_phi  1:\n        delta_phi = (2.0 * phi_max) / (N_phi - 1)\n    else:\n        delta_phi = 1.0 # arbitrary, will not be used\n    delta_lambda = (2.0 * np.pi) / N_lambda\n\n    # 2. Assemble the discrete operator matrix A\n    N_total = N_phi * N_lambda\n    A = np.zeros((N_total, N_total), dtype=np.float64)\n\n    for j in range(N_phi):  # Latitude index from 0 to N_phi-1\n        # Precompute latitude-dependent coefficients\n        cos_phi_j = np.cos(phi[j])\n        lambda_coeff = 1.0 / (cos_phi_j**2 * delta_lambda**2)\n\n        for k in range(N_lambda):  # Longitude index from 0 to N_lambda-1\n            row_idx = j * N_lambda + k\n\n            # Zonal (longitude) part of the operator (periodic)\n            col_idx_km1 = j * N_lambda + (k - 1 + N_lambda) % N_lambda\n            col_idx_kp1 = j * N_lambda + (k + 1) % N_lambda\n            A[row_idx, col_idx_km1] += lambda_coeff\n            A[row_idx, col_idx_kp1] += lambda_coeff\n            A[row_idx, row_idx] -= 2.0 * lambda_coeff\n\n            # Meridional (latitude) part of the operator\n            if N_phi  1:\n                phi_coeff_denom = cos_phi_j * delta_phi**2\n\n                if j == 0:  # Lower boundary (j=0), zero flux\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    \n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_plus_half / phi_coeff_denom\n\n                elif j == N_phi - 1:  # Upper boundary (j=N_phi-1), zero flux\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n                    \n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= c_j_minus_half / phi_coeff_denom\n\n                else:  # Interior points\n                    phi_j_plus_half = phi[j] + delta_phi / 2.0\n                    c_j_plus_half = np.cos(phi_j_plus_half)\n                    phi_j_minus_half = phi[j] - delta_phi / 2.0\n                    c_j_minus_half = np.cos(phi_j_minus_half)\n\n                    col_idx_jm1 = (j - 1) * N_lambda + k\n                    col_idx_jp1 = (j + 1) * N_lambda + k\n                    A[row_idx, col_idx_jm1] += c_j_minus_half / phi_coeff_denom\n                    A[row_idx, col_idx_jp1] += c_j_plus_half / phi_coeff_denom\n                    A[row_idx, row_idx] -= (c_j_plus_half + c_j_minus_half) / phi_coeff_denom\n\n    # 3. Compute eigenvalues and the minimum eigenvalue\n    # The matrix A is diagonally similar to a symmetric matrix, so eigenvalues are real.\n    eigenvalues = scipy.linalg.eigvals(A)\n    # Due to floating point arithmetic, small imaginary parts might appear.\n    lambda_min = np.min(np.real(eigenvalues))\n\n    # 4. Calculate the maximum stable time step\n    # The PDE system is du/dt = kappa * A * u. Eigenvalues of (kappa*A) are kappa*lambda_i.\n    # The stability condition is dt = -2 / (kappa * lambda_min).\n    if lambda_min = 0:\n        # This case should not happen for a diffusion operator with at least 2 points.\n        # It implies the only eigenvalue is 0, e.g., for a 1-point grid.\n        # A matrix of zeros leads to lambda_min = 0, so dt_max would be infinite.\n        if N_total == 1:\n            return np.inf\n        else: # Should not happen, implies error in matrix construction\n            raise ValueError(\"Minimum eigenvalue is non-negative, invalid for diffusion.\")\n\n    dt_max = -2.0 / (kappa * lambda_min)\n    return dt_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # (N_phi, N_lambda, phi_max, kappa)\n        (24, 48, np.pi / 2.0 - 0.2, 1.0),\n        (24, 96, np.pi / 2.0 - 0.02, 1.0),\n        (24, 48, np.pi / 4.0, 1.0),\n        (24, 96, np.pi / 2.0 - 0.2, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        dt_max = construct_operator_and_solve(*case)\n        results.append(dt_max)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436359"}]}