{"hands_on_practices": [{"introduction": "拉格朗日插值提供了一种从一组数据点构建未知函数模型的强大方法。本练习不仅要求您构建多项式，还挑战您使用生成的模型来分析函数的性质。通过找出拟合给定数据的二次多项式，您将进而确定其最小值，这是优化和建模中的一项常见任务。[@problem_id:2183531]", "problem": "在一个数值模拟实验中，发现某个量 $y$ 与变量 $x$ 之间存在二次关系 $y=P(x)$，其中 $P(x)$ 是一个二次多项式。为了描述这个关系，测量了三个数据点：$(0, 5)$、$(2, 3)$ 和 $(4, 7)$。假设这些点恰好位于该多项式的曲线上，求函数 $P(x)$ 所能达到的最小值。", "solution": "设 $P(x)$ 为一个二次多项式，写作 $P(x)=ax^{2}+bx+c$，其中 $a\\neq 0$。给定的点 $(0,5)$、$(2,3)$ 和 $(4,7)$ 在其图像上，因此它们满足\n$$\nP(0)=5,\\quad P(2)=3,\\quad P(4)=7.\n$$\n从 $P(0)=5$ 我们得到 $c=5$。\n\n使用 $P(2)=3$ 可得\n$$\n4a+2b+c=3 \\;\\Longrightarrow\\; 4a+2b+5=3 \\;\\Longrightarrow\\; 4a+2b=-2 \\;\\Longrightarrow\\; 2a+b=-1.\n$$\n使用 $P(4)=7$ 可得\n$$\n16a+4b+c=7 \\;\\Longrightarrow\\; 16a+4b+5=7 \\;\\Longrightarrow\\; 16a+4b=2 \\;\\Longrightarrow\\; 8a+2b=1.\n$$\n从 $8a+2b=1$ 中减去 $2\\cdot(2a+b=-1)$（即 $4a+2b=-2$），得到\n$$\n(8a+2b)-(4a+2b)=1-(-2)\\;\\Longrightarrow\\; 4a=3 \\;\\Longrightarrow\\; a=\\frac{3}{4}.\n$$\n代入 $2a+b=-1$ 可得\n$$\n2\\cdot \\frac{3}{4}+b=-1 \\;\\Longrightarrow\\; \\frac{3}{2}+b=-1 \\;\\Longrightarrow\\; b=-\\frac{5}{2}.\n$$\n因此，\n$$\nP(x)=\\frac{3}{4}x^{2}-\\frac{5}{2}x+5.\n$$\n因为 $a=\\frac{3}{4}>0$，抛物线开口向上，所以 $P(x)$ 在顶点 $x^{*}=-\\frac{b}{2a}$ 处取得其最小值。计算\n$$\nx^{*}=-\\frac{b}{2a}=-\\frac{-\\frac{5}{2}}{2\\cdot \\frac{3}{4}}=\\frac{\\frac{5}{2}}{\\frac{3}{2}}=\\frac{5}{3}.\n$$\n当 $a>0$ 时，最小值可以用公式 $P_{\\min}=c-\\frac{b^{2}}{4a}$ 计算：\n$$\nP_{\\min}=5-\\frac{\\left(-\\frac{5}{2}\\right)^{2}}{4\\cdot \\frac{3}{4}}=5-\\frac{\\frac{25}{4}}{3}=5-\\frac{25}{12}=\\frac{60}{12}-\\frac{25}{12}=\\frac{35}{12}.\n$$\n因此，$P(x)$ 的最小值是 $\\frac{35}{12}$。", "answer": "$$\\boxed{\\frac{35}{12}}$$", "id": "2183531"}, {"introduction": "数值分析中的一项关键技能是识别能够简化复杂问题的潜在结构。本练习提出的函数表面上看起来很复杂，但其在整数节点处的行为却异常简单。您将发现，其拉格朗日插值多项式实际上是一个常数，这揭示了一个重要原理：如果数据点本身可以用一个简单的函数描述，那么唯一的插值多项式就是那个简单的函数。[@problem_id:2183548]", "problem": "设 $P_n(x)$ 为给定函数 $f(x)$ 在 $n+1$ 个不同的整数节点 $x_j = j$（其中 $j = 0, 1, 2, \\dots, n$）上次数至多为 $n$ 的唯一拉格朗日插值多项式。\n\n待插值的函数由下式给出：\n$$f(x) = C_1 \\exp\\left(\\frac{\\cos(k_1 \\pi x) - 1}{2}\\right) + C_2 \\frac{\\sin(k_2 \\pi x)}{1 + x^4}$$\n\n所涉及的参数为实常数和整数，定义如下：\n- $n$ 是一个正整数，满足 $n \\ge 1$。\n- $k_1$ 是一个非零偶数。\n- $k_2$ 是一个非零整数。\n- $C_1$ 和 $C_2$ 是任意实常数。\n\n你的任务是确定插值多项式 $P_n(x)$ 从 $0$ 到 $1$ 的定积分值。请用给定参数将答案表示为一个闭式解析表达式。", "solution": "目标是计算定积分 $I = \\int_0^1 P_n(x) dx$。多项式 $P_n(x)$ 是函数 $f(x)$ 在整数节点 $x_j = j$（其中 $j = 0, 1, \\dots, n$）上次数至多为 $n$ 的拉格朗日插值多项式。\n\n根据定义，插值多项式在每个节点上的值必须与函数值相匹配。即，对于所有 $j \\in \\{0, 1, \\dots, n\\}$，都有 $P_n(x_j) = f(x_j)$。我们来计算函数 $f(x)$ 在这些整数节点上的值。\n\n对于任意节点 $x_j = j$（其中 $j$ 是整数），我们分析 $f(x_j)$ 的两项：\n\n第一项：$T_1 = C_1 \\exp\\left(\\frac{\\cos(k_1 \\pi j) - 1}{2}\\right)$。\n给定 $k_1$ 是一个非零偶数。我们可以写成 $k_1 = 2m$，其中 $m$ 是某个非零整数。\n余弦函数的参数是 $k_1 \\pi j = 2m \\pi j$。对于任意整数 $m$ 和 $j$，其乘积 $mj$ 也是一个整数。\n$2\\pi$ 的任何整数倍的余弦值总是 1。\n因此，$\\cos(k_1 \\pi j) = \\cos(2m \\pi j) = 1$。\n将这个结果代入第一项：\n$$T_1 = C_1 \\exp\\left(\\frac{1 - 1}{2}\\right) = C_1 \\exp\\left(\\frac{0}{2}\\right) = C_1 \\exp(0) = C_1 \\cdot 1 = C_1$$\n\n第二项：$T_2 = C_2 \\frac{\\sin(k_2 \\pi j)}{1 + j^4}$。\n给定 $k_2$ 是一个非零整数。\n正弦函数的参数是 $k_2 \\pi j$。对于任意整数 $k_2$ 和 $j$，其乘积 $k_2 j$ 也是一个整数。\n$\\pi$ 的任何整数倍的正弦值总是 0。\n因此，$\\sin(k_2 \\pi j) = 0$。\n将这个结果代入第二项：\n$$T_2 = C_2 \\frac{0}{1 + j^4} = 0$$\n\n结合这两个结果，我们得到函数 $f(x)$ 在每个节点 $x_j = j$ 上的值：\n$$f(x_j) = f(j) = T_1 + T_2 = C_1 + 0 = C_1$$\n这意味着对于所有节点 $x_0, x_1, \\dots, x_n$，函数值都为同一个常数 $C_1$。插值点为 $(0, C_1), (1, C_1), (2, C_1), \\dots, (n, C_1)$。\n\n拉格朗日插值多项式 $P_n(x)$ 是通过这 $n+1$ 个点的次数至多为 $n$ 的唯一多项式。\n考虑常数多项式 $Q(x) = C_1$。这是一个 0 次多项式。由于给定 $n \\ge 1$，因此 $Q(x)$ 的次数小于或等于 $n$。\n并且，对于所有 $j=0, 1, \\dots, n$，都有 $Q(j) = C_1$。\n由于 $Q(x)$ 是一个满足插值条件且次数至多为 $n$ 的多项式，而拉格朗日插值多项式是唯一的，因此必然有 $P_n(x) = Q(x)$。\n所以，插值多项式就是 $P_n(x) = C_1$。\n\n或者，使用拉格朗日多项式的形式化定义：\n$$P_n(x) = \\sum_{j=0}^{n} f(x_j) L_j(x)$$\n其中 $L_j(x)$ 是拉格朗日基多项式。由于我们已经求得对所有 $j$ 都有 $f(x_j) = C_1$：\n$$P_n(x) = \\sum_{j=0}^{n} C_1 L_j(x) = C_1 \\sum_{j=0}^{n} L_j(x)$$\n拉格朗日基多项式的一个基本性质是它们的和为 1：$\\sum_{j=0}^{n} L_j(x) = 1$。\n因此，$P_n(x) = C_1 \\cdot 1 = C_1$。\n\n现在我们可以计算所求的积分：\n$$I = \\int_0^1 P_n(x) dx = \\int_0^1 C_1 dx$$\n由于 $C_1$ 是一个常数，我们可以将其从积分中提出：\n$$I = C_1 \\int_0^1 1 \\, dx = C_1 [x]_0^1 = C_1 (1 - 0) = C_1$$\n该定积分的值为 $C_1$。", "answer": "$$\\boxed{C_1}$$", "id": "2183548"}, {"introduction": "函数与其插值多项式之间的理论联系在计算算法中具有深远的实际应用。这项动手编程挑战要求您利用共线点可由一个次数至多为一的多项式插值这一事实。您的任务是设计一个稳健的算法来检验点的共线性，这将促使您处理现实世界中的复杂问题，如数值公差和特殊的几何情况。[@problem_id:2425948]", "problem": "给定有限个平面点集 $\\{(x_i,y_i)\\}_{i=0}^{n}$，其中 $n \\ge 1$。一个点集是共线的，当且仅当存在一条包含所有点的直线。一条直线可以表示为 $y = a x + b$（对于某些实数 $a$ 和 $b$ 的非垂直线），或表示为 $x = c$（对于某个实数 $c$ 的垂直线）。您的任务是设计并实现一个程序，通过以下方式判断共线性：对于非垂直情况，检查以拉格朗日形式构造的唯一插值多项式的次数；并结合一个逻辑上必要的前置检查来正确处理垂直情况。\n\n使用的基本原理：\n- 多项式次数的定义为具有非零系数的 $x$ 的最高指数。\n- 对于不同的横坐标 $x_0,\\dots,x_n$，存在一个次数最多为 $n$ 的唯一多项式 $p(x)$，它对数据 $(x_i,y_i)$ 进行插值，并且任何这样的多项式都恰好在 $n+1$ 个插值节点上与数据重合。\n- 平面点共线性的定义为位于同一条直线上。\n\n算法的设计要求：\n- 如果所有 $x$ 坐标在数值容差 $\\tau$ 内相等，则断定这些点在一条垂直线上共线，并返回 $\\mathrm{True}$。\n- 如果存在两个点具有相同的 $x$ 坐标但不同的 $y$ 坐标（差异大于 $\\tau$），而并非所有 $x$ 坐标都在 $\\tau$ 内相等，则断定该点集不可能位于任何单一直线上，并返回 $\\mathrm{False}$。\n- 否则，移除完全重复的点，确保剩余的插值节点具有不同的 $x$ 坐标，为 $y$ 作为 $x$ 的函数构建拉格朗日插值多项式 $p(x)$，将其转换为单项式系数，通过将绝对值 $\\le \\tau$ 的任何系数视为零来确定其有效次数，并当且仅当有效次数最多为 $1$ 时，声明该点集共线。\n- 对所有零值测试和垂直线检查使用固定的容差 $\\tau = 10^{-10}$，并使用实数算术处理所有计算。程序不得假定除此处所述之外的任何特殊结构。\n- 如果（移除重复点后）唯一点的数量最多为 $2$，则返回 $\\mathrm{True}$，因为任意两点都是共线的。\n\n您程序的输入由直接嵌入源代码中的以下测试套件固定。对于每种情况，将每对 $(x,y)$ 解释为使用无量纲单位。\n- 情况 #1（非垂直，线性）： $\\{(-1, -1), (0, 1), (2, 5)\\}$。\n- 情况 #2（非垂直，非线性）： $\\{(0, 0), (1, 1), (2, 2.1)\\}$。\n- 情况 #3（垂直线）： $\\{(3, 0), (3, 5), (3, -2)\\}$。\n- 情况 #4（包含重复点，线性）： $\\{(1, 2), (1, 2), (2, 4), (3, 6)\\}$。\n- 情况 #5（存在 $x$ 相同但 $y$ 不同的冲突点，且存在其他不同的 $x$）： $\\{(1, 2), (1, 3), (2, 4)\\}$。\n- 情况 #6（恰好两个点）： $\\{(-100, 50), (200, -250)\\}$。\n- 情况 #7（近似线性，微小扰动远低于容差）： $\\{(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 10^{-12})\\}$。\n\n输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，顺序与上述测试用例相同。每个结果必须是布尔值 $\\mathrm{True}$ 或 $\\mathrm{False}$，无空格。例如，格式必须像 $[r_A,r_B,r_C]$。\n\n约束和注意事项：\n- 仅使用实数算术，并按照规定对系数修整和相等性检查使用固定的容差 $\\tau = 10^{-10}$。\n- 实现必须是自包含的，不需要任何输入。输出必须从硬编码的测试套件计算得出。", "solution": "问题是判断给定的 $n+1$ 个平面点集 $\\{(x_i, y_i)\\}_{i=0}^{n}$（其中 $n \\ge 1$）是否共线。共线性要求所有点必须位于一条直线上，该直线可以是非垂直的（形式为 $y = ax + b$）或垂直的（形式为 $x = c$）。指定的方法是使用多项式插值，其原理是：一组点位于一条非垂直线上，当且仅当通过它们的唯一插值多项式的次数最多为 $1$。这必须辅以处理数值精度和垂直线特殊情况的逻辑。该问题是适定的且科学上合理的，因此我们着手设计一个严谨的算法。\n\n算法过程按一系列逻辑步骤构建，旨在系统地处理所有情况和数值误差。所有浮点数比较均使用数值容差 $\\tau = 10^{-10}$。\n\n首先，必须对输入数据进行净化。给定一个可能包含重复点的点集。任意两点定义一条线，因此如果唯一点的数量小于或等于 $2$，则该点集显然共线。我们首先将输入简化为一组唯一的点。设该集合为 $S$。如果 $|S| \\le 2$，我们断定这些点共线并终止。\n\n其次，我们必须处理垂直线的情况。垂直线由方程 $x=c$ 描述，其中 $c$ 为常数。这不是 $y=f(x)$ 形式的函数，因此不能用标准的 $x$ 的多项式表示。通过检查唯一集合 $S$ 中的所有点是否具有相同的 $x$ 坐标（在容差 $\\tau$ 内）来识别这种情况。令 $X = \\{x | (x, y) \\in S\\}$。如果 $\\max(X) - \\min(X) \\le \\tau$，则所有点都位于一条垂直线上，我们断定它们是共线的。\n\n第三，对于非垂直情况，这些点必须能表示一个单值函数。也就是说，对于 $S$ 中的任意两点 $(x_i, y_i)$ 和 $(x_j, y_j)$，如果 $x_i$ 与 $x_j$ 在数值上无法区分，那么 $y_i$ 也必须与 $y_j$ 在数值上无法区分。如果我们发现两点满足 $|x_i - x_j| \\le \\tau$ 但 $|y_i - y_j| > \\tau$，那么没有函数 $y=f(x)$ 能同时通过这两点。由于垂直线的情况已被排除，没有单一直线能包含这些点。因此，我们必须检查此条件，如果满足，则断定这些点不共线。此步骤也为插值准备数据。我们可以将 $x$ 坐标在 $\\tau$ 范围内的点分组。如果任何这样的组的 $y$ 坐标分布范围大于 $\\tau$，我们就找到了矛盾。否则，我们可以用一个代表点替换每组，例如通过对组内坐标求平均值。此过程产生一个新的点集 $S'$，其中所有 $x$ 坐标都是不同的（相差大于 $\\tau$）。如果在这次合并后，点的数量 $|S'| \\le 2$，则该集合再次显然共线。\n\n第四，对于一个包含 $N+1$ 个点且具有不同横坐标的净化集 $S' = \\{(x'_j, y'_j)\\}_{j=0}^{N}$（其中 $N+1 = |S'| > 2$），我们可以应用多项式插值的基本定理。存在一个次数最多为 $N$ 的唯一多项式 $p(x)$，使得对所有 $j \\in \\{0, \\dots, N\\}$ 都有 $p(x'_j) = y'_j$。这个多项式可以用拉格朗日形式构造：\n$$\np(x) = \\sum_{j=0}^{N} y'_j L_j(x), \\quad \\text{其中} \\quad L_j(x) = \\prod_{k=0, k \\ne j}^{N} \\frac{x - x'_k}{x'_j - x'_k}\n$$\n这些点是共线的，当且仅当它们位于一条直线 $y = ax+b$上，这是一个次数为 $1$ 的多项式（如果 $a=0$，则次数为 $0$）。因此，共线条件等价于唯一插值多项式 $p(x)$ 的次数最多为 $1$。\n\n为了确定次数，我们必须将 $p(x)$ 转换为其单项式表示，$p(x) = \\sum_{k=0}^{N} c_k x^k$。在用浮点数进行实际计算时，理论上为零的系数可能会显示为非常小的非零值。因此，我们必须确定多项式的“有效次数”。有效次数定义为相应系数的绝对值 $|c_k|$ 大于容差 $\\tau$ 的最大整数 $k$。如果对于 $k > 1$ 的所有系数 $c_k$ 都满足 $|c_k| \\le \\tau$，则有效次数最多为 $1$，我们断定这些点共线。否则，这些点不共线。如果所有系数都满足 $|c_k| \\le \\tau$，则有效次数被认为小于或等于 $1$，并且这些点共线（表示一条接近 $y=0$ 的水平线）。这样就完成了算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.interpolate import lagrange\n\ndef solve():\n    \"\"\"\n    Solves the collinearity problem for a predefined suite of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case #1 (non-vertical, linear)\n        [(-1, -1), (0, 1), (2, 5)],\n        # Case #2 (non-vertical, non-linear)\n        [(0, 0), (1, 1), (2, 2.1)],\n        # Case #3 (vertical line)\n        [(3, 0), (3, 5), (3, -2)],\n        # Case #4 (duplicates included, linear)\n        [(1, 2), (1, 2), (2, 4), (3, 6)],\n        # Case #5 (conflicting equal x with different y and a different x present)\n        [(1, 2), (1, 3), (2, 4)],\n        # Case #6 (exactly two points)\n        [(-100, 50), (200, -250)],\n        # Case #7 (near-linear with tiny perturbation well below tolerance)\n        [(0, 1), (1, 0.5), (2, 0), (3, -0.5 + 1e-12)],\n    ]\n\n    tolerance = 1e-10\n    \n    results = []\n    for points in test_cases:\n        result = is_collinear(points, tolerance)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef is_collinear(points, tau):\n    \"\"\"\n    Determines if a set of points is collinear based on the degree of the\n    interpolating polynomial and special case checks.\n\n    Args:\n        points (list of tuples): A list of (x, y) coordinates.\n        tau (float): The numerical tolerance for floating-point comparisons.\n\n    Returns:\n        bool: True if the points are collinear, False otherwise.\n    \"\"\"\n    # 1. Remove exact duplicates and handle trivial cases.\n    unique_points = sorted(list(set(points)))\n    if len(unique_points) = 2:\n        return True\n\n    x_coords = np.array([p[0] for p in unique_points])\n    y_coords = np.array([p[1] for p in unique_points])\n\n    # 2. Check for vertical line.\n    # np.ptp (peak-to-peak) is equivalent to max(arr) - min(arr)\n    if np.ptp(x_coords) = tau:\n        return True\n\n    # 3. Consolidate points with close x-coordinates and check for function validity.\n    # This step ensures that for each x, there is a unique y (within tolerance)\n    # and prepares a set of nodes with distinct x for interpolation.\n    consolidated_points = []\n    \n    # The unique_points are already sorted by x-coordinate (default tuple sort).\n    # We group points with numerically equal x-coordinates.\n    i = 0\n    while i  len(unique_points):\n        # Start a new group\n        group_indices = [i]\n        j = i + 1\n        while j  len(unique_points) and abs(unique_points[j][0] - unique_points[i][0]) = tau:\n            group_indices.append(j)\n            j += 1\n        \n        # Process the group\n        group_y = y_coords[group_indices]\n        if np.ptp(group_y) > tau:\n            # Contradiction: same x, different y. Not a function.\n            return False\n        \n        # The group is valid, consolidate into a single point by averaging.\n        group_x = x_coords[group_indices]\n        avg_x = np.mean(group_x)\n        avg_y = np.mean(group_y)\n        consolidated_points.append((avg_x, avg_y))\n        \n        i = j # Move to the start of the next group\n\n    if len(consolidated_points) = 2:\n        return True\n\n    # 4. Perform Lagrange interpolation and check the degree.\n    x_final = np.array([p[0] for p in consolidated_points])\n    y_final = np.array([p[1] for p in consolidated_points])\n    \n    # Construct the unique interpolating polynomial.\n    poly = lagrange(x_final, y_final)\n    \n    # 5. Determine the effective degree.\n    effective_degree = 0\n    # a_n is the coefficient of the highest power\n    coeffs = poly.coeffs\n    for i, coeff in enumerate(coeffs):\n        if abs(coeff) > tau:\n            # Degree is (number of coeffs - 1) for the first element,\n            # and decreases with index.\n            effective_degree = len(coeffs) - 1 - i\n            break\n    \n    return effective_degree = 1\n\n# Execute the solution\nsolve()\n```", "id": "2425948"}]}