{"hands_on_practices": [{"introduction": "高斯消元法是解决线性方程组的核心算法。这个练习将带你从最基础的 $2 \\times 2$ 系统入手，通过将方程组转化为增广矩阵，并利用行变换将其简化为行阶梯形，最后通过回代求解，你将掌握整个算法的基本流程。这是理解更复杂系统的关键第一步。[@problem_id:23110]", "problem": "考虑下列关于变量 $x$ 和 $y$ 的二元一次方程组：\n$$\n\\begin{cases}\n3x + 5y = 1 \\\\\n4x + 2y = 6\n\\end{cases}\n$$\n你的任务是求出变量 $x$ 的值。为此，你必须使用高斯消元法。该过程包括以下几个阶段：\n1.  将方程组表示为增广矩阵。\n2.  使用初等行变换将增广矩阵化为行阶梯形矩阵。一个矩阵是行阶梯形矩阵，如果它满足：\n    - 所有非零行都在任何全零行的上方。\n    - 非零行的首项系数（从左起第一个非零数，也称为主元）总是严格位于其上一行首项系数的右侧。\n3.  根据行阶梯形矩阵重写方程组。\n4.  使用回代法求出 $x$ 和 $y$ 的唯一解。\n\n推导出 $x$ 的值。", "solution": "我们将该方程组表示为增广矩阵：\n$$\n\\left[\\begin{array}{cc|c}\n3 & 5 & 1\\\\\n4 & 2 & 6\n\\end{array}\\right]\n$$\n\n应用消元步骤 $R_2\\leftarrow R_2-\\frac{4}{3}R_1$：\n$$\n\\left[\\begin{array}{cc|c}\n3 & 5 & 1\\\\\n0 & -\\frac{14}{3} & \\frac{14}{3}\n\\end{array}\\right]\n$$\n\n由第二行可得 $-\\tfrac{14}{3}y=\\tfrac{14}{3}$，所以 $y=-1$。将其代入第一行，\n$$\n3x+5(-1)=1\\implies3x-5=1\\implies3x=6\\implies x=2.\n$$", "answer": "$$\\boxed{2}$$", "id": "23110"}, {"introduction": "并非所有线性方程组都有唯一解。这个练习将引导你探索一个具有无穷多解的系统，这种情况在代数上表现为自由变量的存在。通过应用高斯消元法，你将学习如何识别并参数化解集，并理解其在三维空间中对应的几何形状——一条直线。[@problem_id:2175262]", "problem": "考虑以下关于三个变量 $x_1, x_2, x_3$ 的线性方程组：\n$$\n\\begin{cases}\nx_1 + x_2 + x_3 = 6 \\\\\n2x_1 - x_2 + 3x_3 = 9 \\\\\n4x_1 + x_2 + 5x_3 = 21\n\\end{cases}\n$$\n该方程组的所有解 $(x_1, x_2, x_3)$ 在三维空间 $\\mathbb{R}^3$ 中构成一个几何对象。以下哪个选项正确地描述了这个对象？\n\nA. 一个点\n\nB. 一条直线\n\nC. 一个平面\n\nD. 空集\n\nE. 整个三维空间 $\\mathbb{R}^3$", "solution": "每个线性方程在 $\\mathbb{R}^{3}$ 中代表一个平面；它们的公共解集是它们的交集。为了对交集进行分类，我们通过高斯消元法来分析该方程组。\n\n从对应于以下方程组的增广矩阵开始：\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n2x_{1} - x_{2} + 3x_{3} = 9 \\\\\n4x_{1} + x_{2} + 5x_{3} = 21\n\\end{cases}\n$$\n进行行变换：\n1) $R_{2} \\leftarrow R_{2} - 2R_{1}$ 得到 $[0,\\,-3,\\,1\\,|\\,-3]$。\n2) $R_{3} \\leftarrow R_{3} - 4R_{1}$ 得到 $[0,\\,-3,\\,1\\,|\\,-3]$。\n3) $R_{3} \\leftarrow R_{3} - R_{2}$ 得到 $[0,\\,0,\\,0\\,|\\,0]$。\n\n因此，化简后的方程组为\n$$\n\\begin{cases}\nx_{1} + x_{2} + x_{3} = 6 \\\\\n-3x_{2} + x_{3} = -3 \\\\\n0=0\n\\end{cases}\n$$\n没有出现矛盾，因此该方程组是相容的。系数矩阵的秩为 $2$（两个独立的方程），增广矩阵的秩也为 $2$。对于 $3$ 个变量和秩为 $2$ 的情况，解集的维数为 $3-2=1$，这是 $\\mathbb{R}^{3}$ 中的一条仿射直线。\n\n因此，该几何对象是一条直线。", "answer": "$$\\boxed{B}$$", "id": "2175262"}, {"introduction": "在科学与工程计算中，效率至关重要。此练习将高斯消元法置于一个实际的物理问题背景中——一维稳态热传导，并介绍一种针对大型稀疏矩阵（特别是三对角矩阵）的高效特化算法——托马斯算法。通过编程实现该算法并分析其线性时间复杂度（$O(N)$），你将体会到理论算法在解决真实世界问题时的强大威力与优化潜力。[@problem_id:2396200]", "problem": "考虑由以下边值问题描述的一维稳态热传导模型\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\n其中 $k(x)$ 是热导率，$q(x)$ 是体积源项。使用一个包含 $N$ 个内部节点的均匀网格，网格间距为 $h = \\dfrac{1}{N+1}$，节点位置为 $x_i = i\\,h$，其中 $i=1,2,\\dots,N$。在节点 $i$ 处的保守二阶有限差分离散采用界面热导率 $k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right)$ 和 $k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right)$，生成如下形式的三对角线性系统：\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\n其中 $u_0=0$ 且 $u_{N+1}=0$。当 $k(x) \\ge \\kappa_{\\min} > 0$ 且 $q(x)$有界时，系数矩阵是严格对角占优的，这保证了唯一解的存在。\n\n编写一个完整的、可运行的程序，该程序：\n- 不接受任何输入，仅使用下面指定的参数值。\n- 为每个指定情况，构建由上述离散化所隐含的三对角系统的三个对角线。\n- 通过应用专为三对角矩阵设计的直接消元法，然后进行回代来求解每个系统。\n- 为验证正确性，将计算出的解向量与使用通用求解器求解相应稠密线性系统得到的解进行比较，并报告最大绝对差。\n- 为验证计算复杂度，在保持所有其他参数固定的情况下，随着系统规模 $N$ 加倍，经验性地测量求解时间，并报告观察到的时间比率是否与线性时间 $O(N)$ 复杂度一致。\n\n使用以下参数值测试套件：\n- 情况 A (均匀属性):\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - $N = 10$。\n  - 要求结果：三对角直接求解的解与稠密矩阵通用解之间的最大绝对差，表示为浮点数。\n- 情况 B (边界尺寸边缘情况):\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - $N = 1$。\n  - 要求结果：单个内部解的值 $u_1$，表示为浮点数。\n- 情况 C (可变热导率):\n  - 对所有 $x \\in [0,1]$，$k(x) = 1 + x$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 1$，\n  - $N = 15$。\n  - 要求结果：三对角直接求解的解与稠密矩阵通用解之间的最大绝对差，表示为浮点数。\n- 情况 D (经验性复杂度验证):\n  - 对所有 $x \\in [0,1]$，$k(x) = 1$，\n  - 对所有 $x \\in [0,1]$，$q(x) = 2$，\n  - 求解规模 $N \\in \\{4000,\\,8000,\\,16000\\}$，\n  - 通过对重复求解取平均值来测量每个 $N$ 的系统求解时间，然后计算时间比率 $T(8000)/T(4000)$ 和 $T(16000)/T(8000)$。返回一个布尔值，指示两个比率是否都位于区间 $[1.6,\\,2.5]$ 内。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[\\text{情况 A 结果}, \\text{情况 B 结果}, \\text{情况 C 结果}, \\text{情况 D 结果}]$。例如，一个有效的输出形状是 $[x_1,x_2,x_3,x_4]$，其中 $x_1$、$x_2$ 和 $x_3$ 是浮点数，$x_4$ 是布尔值。", "solution": "边值问题\n$$\n-\\dfrac{d}{dx}\\!\\left(k(x)\\,\\dfrac{du}{dx}\\right) = q(x), \\quad x \\in (0,1), \\quad u(0)=0,\\; u(1)=0,\n$$\n在一个具有 $N$ 个内部节点、间距为 $h=\\dfrac{1}{N+1}$、节点为 $x_i = i\\,h$（其中 $i=1,2,\\dots,N$）的均匀网格上进行离散化。保守的有限体积或有限差分格式在半网格界面处使用调和通量。记\n$$\nk_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right), \\qquad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right).\n$$\n对围绕 $x_i$ 的单元上的通量散度进行近似，得到\n$$\n-\\dfrac{1}{h}\\left(\\dfrac{k_{i+\\tfrac{1}{2}}(u_{i+1} - u_{i})}{h} - \\dfrac{k_{i-\\tfrac{1}{2}}(u_{i} - u_{i-1})}{h}\\right) = q(x_i),\n$$\n重新整理后得到三对角线性系统\n$$\n-\\,k_{i-\\tfrac{1}{2}}\\,u_{i-1} + \\left(k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}\\right) u_i - k_{i+\\tfrac{1}{2}}\\,u_{i+1} = q(x_i)\\,h^2, \\quad i=1,2,\\dots,N,\n$$\n并满足狄利克雷条件 $u_0=0$ 和 $u_{N+1}=0$。对于 $k(x) \\ge \\kappa_{\\min} > 0$，主对角线元素满足\n$$\nk_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}} \\ge \\kappa_{\\min} + \\kappa_{\\min} = 2\\,\\kappa_{\\min},\n$$\n而非对角线元素为 $-k_{i-\\tfrac{1}{2}}$ 和 $-k_{i+\\tfrac{1}{2}}$，这意味着矩阵是严格对角占优的，并有唯一解。\n\n通过专为三对角矩阵设计的 Gaussian 消元法进行的算法求解过程如下：首先在 $O(N)$ 次算术运算内消除下次对角线，然后进行一次 $O(N)$ 的回代。设三个对角线存储为向量\n$$\n\\ell = \\left[\\ell_1,\\dots,\\ell_{N-1}\\right], \\quad d = \\left[d_1,\\dots,d_N\\right], \\quad u = \\left[u_1,\\dots,u_{N-1}\\right],\n$$\n右侧项为 $b = \\left[b_1,\\dots,b_N\\right]$。对于 $i=2$ 到 $N$ 的前向消元过程计算乘数\n$$\nm_i = \\dfrac{\\ell_{i-1}}{d_{i-1}},\n$$\n然后更新\n$$\nd_i \\leftarrow d_i - m_i\\,u_{i-1}, \\qquad b_i \\leftarrow b_i - m_i\\,b_{i-1}.\n$$\n因为 $d_{i-1} > 0$ 并且严格对角占优成立，所以不会发生除以零的情况。消元后，系统变为上三角形式，其上对角线 $u$ 不变，对角线变为修改后的 $d$。回代过程设置\n$$\nx_N = \\dfrac{b_N}{d_N}, \\qquad x_i = \\dfrac{b_i - u_i\\,x_{i+1}}{d_i} \\quad \\text{对于 } i=N-1,\\dots,1.\n$$\n这正是 Gaussian 消元法和回代法，但利用了三对角稀疏性来确保 $O(N)$ 的运行时间和 $O(N)$ 的存储空间。\n\n为了根据热方程离散化构建对角线，对每个 $i \\in \\{1,\\dots,N\\}$ 定义\n$$\nx_i = i\\,h, \\quad k_{i-\\tfrac{1}{2}} = k\\!\\left(x_i - \\dfrac{h}{2}\\right), \\quad k_{i+\\tfrac{1}{2}} = k\\!\\left(x_i + \\dfrac{h}{2}\\right).\n$$\n然后设置\n$$\n\\ell_{i-1} = -\\,k_{i-\\tfrac{1}{2}} \\quad (i\\ge 2), \\qquad d_i = k_{i-\\tfrac{1}{2}} + k_{i+\\tfrac{1}{2}}, \\qquad u_i = -\\,k_{i+\\tfrac{1}{2}} \\quad (i\\le N-1),\n$$\n以及\n$$\nb_i = q(x_i)\\,h^2.\n$$\n对于情况 A 和情况 B，其中 $k(x)=1$ 和 $q(x)=2$，有 $k_{i-\\tfrac{1}{2}}=1$ 和 $k_{i+\\tfrac{1}{2}}=1$，因此 $\\ell_i=-1$, $d_i=2$, $u_i=-1$，并且 $b_i = 2\\,h^2$。对于情况 C，其中 $k(x)=1+x$ 和 $q(x)=1$，热导率随位置线性变化但保持为正，从而保留了严格对角占优性。\n\n正确性验证通过组装稠密矩阵 $A \\in \\mathbb{R}^{N\\times N}$ 进行，其中 $A_{i,i}=d_i$，$A_{i,i-1}=\\ell_{i-1}$ (对于 $i\\ge 2$)，以及 $A_{i,i+1}=u_i$ (对于 $i\\le N-1$)，然后使用最大绝对差比较专门的三对角解 $x$ 和稠密解 $A^{-1}b$：\n$$\n\\|x - A^{-1}b\\|_{\\infty} = \\max_i |x_i - (A^{-1}b)_i|.\n$$\n\n为了经验性地验证 $O(N)$ 复杂度，在保持 $k(x)$ 和 $q(x)$ 固定的情况下，测量求解 $N \\in \\{4000,8000,16000\\}$ 所需的墙上时钟时间 $T(N)$。比率\n$$\n\\rho_1 = \\dfrac{T(8000)}{T(4000)}, \\qquad \\rho_2 = \\dfrac{T(16000)}{T(8000)}\n$$\n对于足够大的 $N$ 应接近于 $2$。为减少计时噪声，对多次重复求解的时间取平均值，并使用中位数或平均数。报告一个布尔值，指示 $\\rho_1$ 和 $\\rho_2$ 是否都位于区间 $[1.6,\\,2.5]$ 内，该区间既考虑了典型的测量变异性，又反映了线性增长。\n\n程序计算并输出：\n- 情况 A：一个浮点值，等于当 $N=10$、$k(x)=1$、$q(x)=2$ 时 $\\|x - A^{-1}b\\|_{\\infty}$ 的值。\n- 情况 B：一个浮点值，等于当 $N=1$、$k(x)=1$、$q(x)=2$ 时 $u_1$ 的值。\n- 情况 C：一个浮点值，等于当 $N=15$、$k(x)=1+x$、$q(x)=1$ 时 $\\|x - A^{-1}b\\|_{\\infty}$ 的值。\n- 情况 D：一个布尔值，等于当 $N \\in \\{4000,8000,16000\\}$、$k(x)=1$、$q(x)=2$ 时 $\\left(\\rho_1 \\in [1.6,2.5]\\right) \\wedge \\left(\\rho_2 \\in [1.6,2.5]\\right)$ 的值。\n\n最终输出是格式为 $[r_A, r_B, r_C, r_D]$ 的单行，其中 $r_A$、$r_B$ 和 $r_C$ 是浮点数，$r_D$ 是一个布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport time\n\ndef thomas_solve(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal linear system Ax = rhs where:\n    - lower: subdiagonal (length n-1)\n    - diag: main diagonal (length n)\n    - upper: superdiagonal (length n-1)\n    - rhs: right-hand side (length n)\n    Returns x (length n).\n    \"\"\"\n    n = diag.size\n    # Make working copies to preserve inputs\n    c = upper.astype(float).copy()\n    d = diag.astype(float).copy()\n    b = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        if d[i-1] == 0.0:\n            # Extremely unlikely for strictly diagonally dominant matrices\n            raise ZeroDivisionError(\"Zero pivot encountered in tridiagonal elimination.\")\n        m = lower[i-1] / d[i-1]\n        d[i] -= m * c[i-1]\n        b[i] -= m * b[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = b[-1] / d[-1]\n    for i in range(n - 2, -1, -1):\n        x[i] = (b[i] - c[i] * x[i + 1]) / d[i]\n    return x\n\ndef build_heat_tridiag(N, k_func, q_func):\n    \"\"\"\n    Build tridiagonal coefficients (lower, diag, upper) and rhs for the 1D steady heat equation:\n      -d/dx (k(x) du/dx) = q(x), u(0)=u(1)=0\n    using uniform grid with N interior points.\n    \"\"\"\n    h = 1.0 / (N + 1)\n    x = (np.arange(1, N + 1, dtype=float)) * h\n    diag = np.empty(N, dtype=float)\n    rhs = np.empty(N, dtype=float)\n    lower = np.empty(max(N - 1, 0), dtype=float)\n    upper = np.empty(max(N - 1, 0), dtype=float)\n\n    for j in range(N):\n        xi = x[j]\n        km = k_func(xi - 0.5 * h)\n        kp = k_func(xi + 0.5 * h)\n        diag[j] = km + kp\n        rhs[j] = q_func(xi) * (h ** 2)\n        if j > 0:\n            lower[j - 1] = -km\n        if j  N - 1:\n            upper[j] = -kp\n    return lower, diag, upper, rhs\n\ndef dense_from_tridiag(lower, diag, upper):\n    \"\"\"Construct a dense matrix from tridiagonal vectors.\"\"\"\n    n = diag.size\n    A = np.zeros((n, n), dtype=float)\n    A[np.arange(n), np.arange(n)] = diag\n    if n >= 2:\n        A[np.arange(1, n), np.arange(0, n - 1)] = lower\n        A[np.arange(0, n - 1), np.arange(1, n)] = upper\n    return A\n\ndef case_A():\n    # k(x)=1, q(x)=2, N=10\n    N = 10\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef case_B():\n    # Edge case N=1, k(x)=1, q(x)=2\n    N = 1\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    return float(x_tridiag[0])\n\ndef case_C():\n    # Variable conductivity k(x)=1+x, source q(x)=1, N=15\n    N = 15\n    k_func = lambda x: 1.0 + x\n    q_func = lambda x: 1.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n    x_tridiag = thomas_solve(lower, diag, upper, rhs)\n    A = dense_from_tridiag(lower, diag, upper)\n    x_dense = np.linalg.solve(A, rhs)\n    err = float(np.max(np.abs(x_tridiag - x_dense)))\n    return err\n\ndef time_one_size(N, repeats_inner=30, repeats_outer=5):\n    \"\"\"\n    Time the tridiagonal solve for a given N.\n    Build the system once and solve it repeats_inner times per outer repetition.\n    Return the median time per solve over outer repetitions.\n    \"\"\"\n    # Use constant coefficients k=1, q=2\n    k_func = lambda x: 1.0\n    q_func = lambda x: 2.0\n    lower, diag, upper, rhs = build_heat_tridiag(N, k_func, q_func)\n\n    times = []\n    for _ in range(repeats_outer):\n        t0 = time.perf_counter()\n        for _ in range(repeats_inner):\n            # Each solve copies arrays internally, so inputs are reusable\n            _ = thomas_solve(lower, diag, upper, rhs)\n        t1 = time.perf_counter()\n        times.append((t1 - t0) / repeats_inner)\n    # Median helps mitigate noise\n    return float(np.median(times))\n\ndef case_D():\n    sizes = [4000, 8000, 16000]\n    # Increase repeats_inner if needed to stabilize timing; chosen to be modest to keep runtime short.\n    t1 = time_one_size(sizes[0], repeats_inner=30, repeats_outer=5)\n    t2 = time_one_size(sizes[1], repeats_inner=30, repeats_outer=5)\n    t3 = time_one_size(sizes[2], repeats_inner=30, repeats_outer=5)\n    # Compute ratios\n    ratio1 = t2 / t1 if t1 > 0 else float('inf')\n    ratio2 = t3 / t2 if t2 > 0 else float('inf')\n    is_linear = (1.6 = ratio1 = 2.5) and (1.6 = ratio2 = 2.5)\n    return bool(is_linear)\n\ndef solve():\n    results = []\n    results.append(case_A())\n    results.append(case_B())\n    results.append(case_C())\n    results.append(case_D())\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2396200"}]}