{"hands_on_practices": [{"introduction": "第一个练习将引导您逐步了解布伦特方法的核心机制。通过手动执行几次迭代 [@problem_id:2157795]，您将具体理解该算法如何在快速的插值策略和可靠的二分法后备方案之间进行智能切换。", "problem": "布伦特法是一种流行的求根算法，它结合了二分法、割线法和逆二次插值法。考虑函数 $f(x) = J_0(x)$，其中 $J_0(x)$ 是第一类零阶贝塞尔函数。我们希望找到这个函数的第一个正根。\n\n给定根的初始区间为 $[a_0, b_0] = [2.0, 3.0]$。您的任务是应用布伦特法进行两次完整的迭代，以找到根的更精确的估计值。\n\n您必须遵循的方法逻辑如下：\n1.  在每一步中，对于当前的区间 $[a, b]$ 和第三个点 $c$（$b$ 的前一个值），首先尝试使用点 $(a, f(a))$、$(b, f(b))$ 和 $(c, f(c))$ 进行逆二次插值，以找到一个新的估计值 $s$。这仅在 $f(a)$、$f(b)$ 和 $f(c)$ 互不相同时才可能。\n2.  如果逆二次插值不可行或其结果未被接受，则退而使用点 $(a, f(a))$ 和 $(b, f(b))$ 的割线法来找到估计值 $s$。\n3.  只有当来自插值法或割线法的新估计值 $s$ 位于 $\\frac{3a+b}{4}$ 和 $b$ 之间时，才接受该估计值。\n4.  如果估计值 $s$ 未被接受，则改用二分法，其中新的估计值是中点 $s = \\frac{a+b}{2}$。\n5.  找到新的估计值 $s$ 后，根据函数值的符号更新下一次迭代的区间 $[a, b]$ 和点 $c$。新区间必须始终包围根。\n\n为进行计算，请使用以下预先计算的函数值：\n- $J_0(2.0) = 0.22389$\n- $J_0(3.0) = -0.26005$\n- $J_0(2.46264) = -0.02495$\n- $J_0(2.41146) = -0.00282$\n\n计算该方法完成两次完整迭代后的最佳根估计值。最佳估计值是最终区间中函数值更接近于零的那个端点。报告您的最终答案，四舍五入到四位有效数字。", "solution": "我们严格按照规定应用布伦特法，仅使用提供的函数值。\n\n令 $f(x)=J_{0}(x)$。初始时，$a_{0}=2.0$，$b_{0}=3.0$，有 $f(a_{0})=0.22389>0$ 和 $f(b_{0})=-0.260050$，因此区间 $[a_{0},b_{0}]$ 包围一个根。对于第一次迭代，我们取 $c_{0}=a_{0}$（因此逆二次插值不可行，因为 $a_{0}=c_{0}$）。\n\n迭代 1：\n- 由于逆二次插值不可行，使用点 $(a_{0},f(a_{0}))$ 和 $(b_{0},f(b_{0}))$ 进行割线法计算：\n$$\ns_{1}\n= b_{0} - f(b_{0})\\frac{b_{0}-a_{0}}{f(b_{0})-f(a_{0})}\n= 3.0 - \\left(-0.26005\\right)\\frac{3.0-2.0}{-0.26005-0.22389}.\n$$\n计算分母 $f(b_{0})-f(a_{0})=-0.48394$，所以\n$$\ns_{1}=3.0 - \\frac{-0.26005}{-0.48394}=3.0-0.53736=2.46264.\n$$\n- 接受性检查：$s_{1}$ 必须满足 $\\frac{3a_{0}+b_{0}}{4} \\leq s_{1} \\leq b_{0}$。此处，$\\frac{3\\cdot 2.0 + 3.0}{4}=2.25$，并且 $2.25 \\leq 2.46264 \\leq 3.0$，所以 $s_{1}$ 被接受。\n- 使用符号更新区间：$f(a_{0})\\cdot f(s_{1})=0.22389\\cdot(-0.02495)  0$，所以新的区间是 $[a_{1},b_{1}]=[a_{0},s_{1}]=[2.0,2.46264]$。设置 $c_{1}=b_{0}=3.0$。将使用提供的值 $f(b_{1})=f(2.46264)=-0.02495$。\n\n迭代 2：\n- 尝试使用点 $(a_{1},f(a_{1}))=(2.0,0.22389)$、$(b_{1},f(b_{1}))=(2.46264,-0.02495)$ 和 $(c_{1},f(c_{1}))=(3.0,-0.26005)$ 进行逆二次插值，这些点的函数值互不相同。使用逆二次插值（将 $x$ 插值为 $y=f(x)$ 的二次函数，并在 $y=0$ 处求值），公式为\n$$\ns_{2}\n= x_{0}\\frac{f_{1}f_{2}}{(f_{0}-f_{1})(f_{0}-f_{2})}\n+ x_{1}\\frac{f_{0}f_{2}}{(f_{1}-f_{0})(f_{1}-f_{2})}\n+ x_{2}\\frac{f_{0}f_{1}}{(f_{2}-f_{0})(f_{2}-f_{1})},\n$$\n其中 $(x_{0},f_{0})=(2.0,0.22389)$，$(x_{1},f_{1})=(2.46264,-0.02495)$，$(x_{2},f_{2})=(3.0,-0.26005)$。\n使用提供的值（以及与之一致的算术运算），这得到\n$$\ns_{2}=2.41146.\n$$\n- 接受性检查：$s_{2}$ 必须满足 $\\frac{3a_{1}+b_{1}}{4} \\leq s_{2} \\leq b_{1}$。此处，$\\frac{3\\cdot 2.0 + 2.46264}{4}=\\frac{8.46264}{4}=2.11566$，并且 $2.11566 \\leq 2.41146 \\leq 2.46264$，所以 $s_{2}$ 被接受。\n- 使用符号更新区间：$f(a_{1})\\cdot f(s_{2})=0.22389\\cdot(-0.00282)  0$，所以新的区间是 $[a_{2},b_{2}]=[a_{1},s_{2}]=[2.0,2.41146]$。将使用提供的值 $f(b_{2})=f(2.41146)=-0.00282$。\n\n经过两次完整迭代后，最终的区间是 $[2.0,2.41146]$，函数值为 $f(2.0)=0.22389$ 和 $f(2.41146)=-0.00282$。最佳估计值是函数值更接近于零的端点，即 $b_{2}=2.41146$。四舍五入到四位有效数字得到 $2.411$。", "answer": "$$\\boxed{2.411}$$", "id": "2157795"}, {"introduction": "在应用任何区间套法求根算法之前，关键的第一步是确保初始区间内确实存在一个根。这个思想实验 [@problem_id:2157790] 探讨了当这个基本前提条件被违反时会发生什么，从而突显了一个精心设计的数值方法中所内置的稳健性检查的重要性。", "problem": "Brent 方法是一种流行的求根算法，它结合了二分法、割线法和逆二次插值法。任何有界求根方法的一个基本先决条件是初始区间 $[a, b]$ 必须包含一个根，这通常由介值定理保证，前提是函数是连续的且 $f(a)$ 和 $f(b)$ 异号。\n\n考虑函数 $f(x) = (x-1)^{2} + 0.1$。一位分析师试图使用 Brent 方法的一个标准、稳健的实现来寻找该函数的根，错误地提供了初始区间 $[a, b] = [0, 2]$。\n\n下列哪个陈述最能描述该算法的预期行为？\n\nA. 算法将立即终止并报告错误，因为初始区间没有将根括在内（即 $f(a) \\cdot f(b) > 0$）。\n\nB. 算法不会找到根，但会收敛到函数在 $x=1$ 处的最小值位置。\n\nC. 算法将无限执行二分法步骤，将区间向 $x=1$ 缩小，直到达到机器精度。\n\nD. 算法将发散，后续迭代产生的根的估计值会落在初始区间 $[0, 2]$ 之外。\n\nE. 算法将默认使用割线法，但由于第一步出现除零错误而失败。", "solution": "我们分析该函数以及 Brent 求根方法所要求的区间限定条件。\n\n给定 $f(x) = (x-1)^{2} + 0.1$，注意到对于所有实数 $x$，\n$$(x-1)^{2} \\geq 0 \\quad \\Rightarrow \\quad f(x) = (x-1)^{2} + 0.1 \\geq 0.1 > 0.$$\n因此，方程 $f(x) = 0$ 没有解；$f$ 在任何地方都没有实根。\n\n对于给定的初始区间 $[a,b] = [0,2]$，计算端点值：\n$$f(0) = (0-1)^{2} + 0.1 = 1 + 0.1 = 1.1,$$\n$$f(2) = (2-1)^{2} + 0.1 = 1 + 0.1 = 1.1.$$\n因此，\n$$f(a)\\cdot f(b) = f(0)\\,f(2) = 1.1 \\times 1.1 = 1.21 > 0.$$\n像 Brent 方法这样的有界求根算法要求在 $[a,b]$ 上有符号变化，即 $f(a)f(b)  0$，以便通过介值定理保证根的存在，并在迭代过程中维持一个有效的有界区间。这个先决条件在这里没有被满足。\n\nBrent 求根算法的一个标准、稳健的实现会首先验证有界条件 $f(a)f(b)  0$。如果验证失败，该方法不会继续执行任何二分法、割线法或逆二次插值法的组合步骤；相反，它会立即终止并报告错误，或返回一个失败状态，表明初始区间没有将根括在内。\n\n选项评估：\n- A 是正确的：它陈述了由于 $f(a) \\cdot f(b) > 0$ 导致算法立即终止并报错。\n- B 是不正确的：收敛到 $x=1$ 处的最小值描述的是 Brent 的最小化算法，这与 Brent 的求根方法是不同的算法。\n- C 是不正确的：二分法需要符号变化来选择子区间；没有根被括在区间内，二分法无法进行。\n- D 是不正确的：Brent 求根方法是一种有界方法，不会发散到区间之外；此外，在没有有效界定的情况下，它不会进行迭代。\n- E 是不正确的：尽管由于 $f(0)=f(2)$，一个朴素的割线法步骤在这里会产生零分母，但一个稳健的 Brent 实现不会在没有首先确保有效有界区间的情况下默认使用割线法；它会因为不满足有界条件而早已终止。\n\n因此，预期的行为是由于缺少一个限定根的区间而立即终止并报错。", "answer": "$$\\boxed{A}$$", "id": "2157790"}, {"introduction": "布伦特方法因其兼具速度和可靠性而备受推崇，但其性能会因函数在根附近的行为而异。这个问题 [@problem_id:2157793] 探究了一个函数几何特性挑战快速插值法基本假设的案例，这迫使算法不得不依赖其较慢但更安全的二分法部分。", "problem": "Brent方法是一种流行的求根算法，它结合了二分法的可靠性与基于插值技术（即割线法和逆二次插值法）的速度。该算法在可能的情况下尝试使用更快的插值方法，但如果插值步骤不理想，则会退回到二分法。\n\n考虑函数 $f(x) = \\text{sign}(x-2) \\sqrt{|x-2|}$，它在 $x=2$ 处有一个根。当应用Brent方法寻找这个根时，观察到基于插值的步骤表现不佳，导致算法严重依赖二分法的回退机制，因而收敛速度远慢于预期。\n\n对于这个特定函数在其根附近，以下哪个陈述为基于插值的步骤（割线法和逆二次插值法）表现不佳提供了最准确的数学原因？\n\nA. 函数在根 $x=2$ 处不连续。\n\nB. 函数相对于根具有奇对称性，即 $f(2+h) = -f(2-h)$，这迫使算法采取对称但缓慢的步骤。\n\nC. 函数的一阶导数在根处未定义，当 $x$ 趋近于根时，其值趋近于无穷大。\n\nD. 函数的二阶导数在根处为零，这表明存在一个拐点，从而减慢了收敛速度。\n\nE. 该算法失败是因为它只能应用于多项式，而该函数包含平方根项。", "solution": "我们的目标是理解为什么Brent方法的基于插值的组成部分（割线法和逆二次插值法）对于函数 $f(x) = \\text{sign}(x-2) \\sqrt{|x-2|}$ 在其根 $x=2$ 附近表现不佳。\n\n首先，我们来分析函数 $f(x)$。该函数使用符号函数和绝对值定义。我们可以用分段形式来表示它，以便更好地理解其在根 $x=2$ 附近的行为。\n- 如果 $x > 2$，则 $x-2 > 0$，所以 $\\text{sign}(x-2) = 1$ 且 $|x-2| = x-2$。因此，$f(x) = \\sqrt{x-2}$。\n- 如果 $x  2$，则 $x-2  0$，所以 $\\text{sign}(x-2) = -1$ 且 $|x-2| = -(x-2) = 2-x$。因此，$f(x) = -\\sqrt{2-x}$。\n- 如果 $x = 2$，则 $f(2) = \\text{sign}(0)\\sqrt{0} = 0 \\times 0 = 0$。\n\nBrent算法中使用的插值方法，即割线法和逆二次插值法，之所以能实现快速收敛，是因为它们假设函数局部是光滑的，并且可以被低阶多项式（割线法是直线，逆二次插值法是二次曲线）很好地近似。这种光滑性的一个关键指标是函数在根附近的导数行为。\n\n我们来计算当 $x \\neq 2$ 时的一阶导数 $f'(x)$。\n- 对于 $x > 2$，$f'(x) = \\frac{d}{dx}(\\sqrt{x-2}) = \\frac{d}{dx}((x-2)^{1/2}) = \\frac{1}{2}(x-2)^{-1/2} = \\frac{1}{2\\sqrt{x-2}}$。\n- 对于 $x  2$，$f'(x) = \\frac{d}{dx}(-\\sqrt{2-x}) = -\\frac{1}{2}(2-x)^{-1/2}(-1) = \\frac{1}{2\\sqrt{2-x}}$。\n\n现在，我们考察当 $x$ 趋近于根 $2$ 时导数的极限。\n- 当 $x$ 从右侧趋近于 $2$（$x \\to 2^+$）时，分母 $2\\sqrt{x-2} \\to 0^+$。因此，$\\lim_{x\\to 2^+} f'(x) = +\\infty$。\n- 当 $x$ 从左侧趋近于 $2$（$x \\to 2^-$）时，分母 $2\\sqrt{2-x} \\to 0^+$。因此，$\\lim_{x\\to 2^-} f'(x) = +\\infty$。\n\n由于从两侧趋近时导数的极限都趋向于无穷大，因此导数 $f'(2)$ 未定义。从几何上看，这意味着函数在其根 $x=2$ 处有一条垂直切线。\n\n这条垂直切线是插值方法失效的主要原因：\n1.  **割线法**：该方法用连接两点 $(x_n, f(x_n))$ 和 $(x_{n-1}, f(x_{n-1}))$ 的割线来近似函数。当这些点靠近根 $x=2$ 时，函数几乎是垂直的。割线也将几乎是垂直的，其与x轴的交点（即下一个根的估计值）可能对点的微小变化高度敏感，导致不准确或不稳定的步骤。局部线性的基本假设被违反了。\n2.  **逆二次插值法 (IQI)**：该方法对*反*函数 $x = f^{-1}(y)$ 进行二次多项式拟合。如果原函数 $f(x)$ 在根处的导数为无穷大，那么反函数的导数将为零。反函数的导数为 $(f^{-1})'(y) = 1/f'(x)$。当 $x \\to 2$ 时，$f'(x) \\to \\infty$，所以 $(f^{-1})'(0) = 0$。我们来看反函数的二阶导数。反函数是 $x = 2+y|y|$。它的一阶导数是 $x'(y) = 2|y|$，二阶导数是 $x''(y) = 2 \\text{sign}(y)$，在 $y=0$ 处有一个跳跃间断点。一个二阶导数不连续的函数在该点附近无法被单个二次多项式很好地近似。\n\n由于两种插值方案都无法产生可靠且快速收敛的估计值，Brent方法的逻辑将反复拒绝它们的输出，并退回到有保证但速度较慢的二分法。\n\n现在我们来评估给出的选项：\nA. 函数在根 $x=2$ 处不连续。这是错误的。如上所示，$\\lim_{x\\to 2} f(x) = 0 = f(2)$，所以函数是连续的。\nB. 函数相对于根具有奇对称性。这个陈述是正确的，因为 $f(2+h) = \\text{sign}(h)\\sqrt{|h|}$ 且 $-f(2-h) = -(\\text{sign}(-h)\\sqrt{|-h|}) = -(-\\text{sign}(h)\\sqrt{|h|}) = \\text{sign}(h)\\sqrt{|h|}$。然而，这不是性能不佳的原因。例如，$g(x) = x-2$ 也具有这种对称性，而Brent方法对其完美有效。\nC. 函数的一阶导数在根处未定义，当 $x$ 趋近于根时，其值趋近于无穷大。这是正确的，正如我们的计算所证明的。这个无穷大的导数（垂直切线）违反了插值方法所依赖的光滑性假设，导致它们表现不佳。这是正确的解释。\nD. 函数的二阶导数在根处为零。这是错误的。一阶导数在根处甚至没有定义，所以二阶导数也不可能存在。此外，对于 $x>2$，$f''(x) = -\\frac{1}{4}(x-2)^{-3/2}$，当 $x \\to 2^+$ 时，它趋近于 $-\\infty$。\nE. 该算法失败是因为它只能应用于多项式。这是错误的。Brent方法是一种通用的求根器，适用于广泛的连续函数。\n\n因此，性能不佳的最准确原因是根处的导数为无穷大。", "answer": "$$\\boxed{C}$$", "id": "2157793"}]}