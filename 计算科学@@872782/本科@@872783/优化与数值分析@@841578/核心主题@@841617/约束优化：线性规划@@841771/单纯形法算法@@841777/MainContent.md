## 引言
单纯形法（Simplex Method）是运筹学和[数学优化](@entry_id:165540)领域中一块不朽的基石，它是解决线性规划（Linear Programming, LP）问题的最著名和最广泛应用的算法。[线性规划](@entry_id:138188)模型在商业、工程和科学中无处不在，用于解决[资源分配](@entry_id:136615)、生产计划和[网络流](@entry_id:268800)量等[优化问题](@entry_id:266749)。然而，仅仅建立模型是不够的；我们还需要一种系统性的方法来找到最优解。单纯形法正是为了填补这一空白而生，它提供了一个优雅而强大的代数框架，能够高效地导航复杂的[可行域](@entry_id:136622)以锁定最优目标。

本文将带领读者深入探索单纯形法的世界。我们将分为三个核心章节：
*   在“原理与机制”中，我们将从零开始，学习如何将一个线性规划问题转化为[标准形式](@entry_id:153058)，构建初始单纯形表，并掌握核心的枢轴变换迭代过程，理解其背后的代数和几何意义。
*   在“应用与跨学科联系”中，我们将超越计算本身，探讨单纯形法在经济学、管理科学和计算机科学等领域的深刻影响，特别是其在灵敏度分析、[对偶理论](@entry_id:143133)和大规模问题求解中的高级应用。
*   最后，在“动手实践”部分，你将有机会通过具体问题来应用和巩固所学知识，加深对算法关键步骤的理解。

让我们从算法的基本构件开始，踏上这段探索优化智慧的旅程。

## 原理与机制

在上一章中，我们介绍了线性规划（Linear Programming, LP）作为一种在给定[线性约束](@entry_id:636966)条件下优化线性目标函数的强大数学工具。本章将深入探讨解决线性规划问题的核心算法——**单纯形法（Simplex Method）**。我们将系统地阐述其基本原理、算法机制以及如何解释其结果。我们将从将问题转化为[标准形式](@entry_id:153058)开始，学习如何启动算法，理解其迭代过程的代数和几何意义，并最终识别不同类型的解。

### 将问题转化为[标准形式](@entry_id:153058)

单纯形法是一种代数方法，它要求线性规划问题具有统一的结构，即**[标准形式](@entry_id:153058)（standard form）**。一个典型的最大化问题[标准形式](@entry_id:153058)如下：

最大化 $Z = \mathbf{c}^T \mathbf{x}$
服从于：
$A\mathbf{x} = \mathbf{b}$
$\mathbf{x} \ge \mathbf{0}$
$\mathbf{b} \ge \mathbf{0}$

这个形式有三个关键特征：
1.  **目标函数**是最大化类型。（最小化问题可以通过将[目标函数](@entry_id:267263)乘以-1来转换，即 $\min(Z) = \max(-Z)$）。
2.  所有**约束条件**都是等式。
3.  所有**决策变量**都要求非负。

然而，在实际建模中，约束条件通常以不等式的形式出现（$\le$、$\ge$）。因此，将这些不等式转化为等式是应用单纯形法的第一步。

#### [松弛变量](@entry_id:268374)

对于“小于等于”（$\le$）类型的约束，我们可以通过引入一个非负的**[松弛变量](@entry_id:268374)（slack variable）**来将其转化为等式。例如，考虑一个资源约束：
$x_1 + 2x_2 \le 10$

这个约束表示 $x_1$ 和 $x_2$ 所消耗的资源不能超过10个单位。我们可以引入[松弛变量](@entry_id:268374) $s_1 \ge 0$，它代表未被使用的资源量。这样，约束就变成了：
$x_1 + 2x_2 + s_1 = 10$

如果 $x_1+2x_2 = 8$，那么 $s_1 = 2$，表示有2个单位的资源剩余。如果 $x_1+2x_2 = 10$，那么 $s_1 = 0$，表示资源被完全利用。

#### 剩余变量与[人工变量](@entry_id:164298)

对于“大于等于”（$\ge$）类型的约束，情况稍微复杂一些。例如，一个生产配额要求：
$x_A + x_B \ge Q_{min}$

我们可以引入一个非负的**剩余变量（surplus variable）** $s_1$ 来表示超出最小配额的数量。通过减去这个变量，我们可以将不等式转化为等式：
$x_A + x_B - s_1 = Q_{min}$

然而，这带来了一个新的问题。单纯形法需要一个初始的**基本可行解（Basic Feasible Solution, BFS）**来启动。一个BFS通常是通过将所有原始决策变量设为零，然后求解其余变量得到的。在引入[松弛变量](@entry_id:268374)的 $\le$ 约束中，例如 $x_1 + s_1 = 4$，当 $x_1 = 0$ 时，我们直接得到 $s_1 = 4$，这是一个有效的非负解。然而，在上述的 $\ge$ 约束中，如果我们将 $x_A$ 和 $x_B$ 设为0，会得到 $-s_1 = Q_{min}$，即 $s_1 = -Q_{min}$。由于 $Q_{min}$ 通常是正数，这就违反了 $s_1 \ge 0$ 的非负性要求。

为了解决这个问题，我们引入了**[人工变量](@entry_id:164298)（artificial variable）**。[人工变量](@entry_id:164298)是一种临时性的辅助工具，它的唯一目的是在算法开始时提供一个有效的基本变量。对于上面的约束，我们引入一个[人工变量](@entry_id:164298) $a_1 \ge 0$：
$x_A + x_B - s_1 + a_1 = Q_{min}$

现在，当我们将决策变量 $x_A$、$x_B$ 和剩余变量 $s_1$ 都设为0时，我们可以得到 $a_1 = Q_{min}$，这是一个有效的非负初始解。因此，[人工变量](@entry_id:164298)的根本目的在于为那些本身无法直接提供初始基本[可行解](@entry_id:634783)的约束（如 $\ge$ 或 $=$ 类型）提供一个“占位”的基本变量，从而使得单纯形法得以启动 [@problem_id:2220983]。

为了确保这些仅为计算服务的“人造”变量在最终的最优解中为零（因为它们在原始问题中没有物理意义），我们必须在算法中设计机制来将它们从解中排除。常用的方法包括**[大M法](@entry_id:170061)（Big M Method）**和**[两阶段法](@entry_id:166636)（Two-Phase Method）**。

### 初始基本可行解与单纯形表

单纯形法的核心思想是在[可行域的顶点](@entry_id:174284)之间移动。每个顶点都对应一个基本可行解（BFS）。算法从一个初始的BFS开始，通过一系列迭代，移动到相邻的、能使[目标函数](@entry_id:267263)值更优的顶点，直到找不到更优的顶点为止。

**单纯形表（Simplex Tableau）**是执行这些代数运算的标准格式。它本质上是[线性方程组](@entry_id:148943)的[增广矩阵](@entry_id:150523)表示。

#### 简单的初始解

对于所有约束都是 $\le$ 类型且右侧常数（RHS）均非负的标准最大化问题，找到初始BFS非常简单。引入[松弛变量](@entry_id:268374)后，[约束系统](@entry_id:164587)变为 $A\mathbf{x} + I\mathbf{s} = \mathbf{b}$。此时，[松弛变量](@entry_id:268374) $\mathbf{s}$ 的系数矩阵恰好是一个单位矩阵 $I$。我们可以选择所有[松弛变量](@entry_id:268374)作为**基本变量**，而所有原始决策变量 $\mathbf{x}$ 作为**非基本变量**。

一个**基本解**是通过将所有非基本变量设为0得到的。在此情况下，设置 $\mathbf{x} = \mathbf{0}$，[方程组](@entry_id:193238)简化为 $I\mathbf{s} = \mathbf{b}$，即 $\mathbf{s} = \mathbf{b}$。由于我们假设所有 $b_i \ge 0$，这就保证了所有基本变量（[松弛变量](@entry_id:268374)）的值也是非负的。因此，这个解既是基本的，又是可行的，构成了一个有效的初始BFS。这解释了为什么在简单的最大化问题中，原点（所有决策变量为0）是算法的天然起点 [@problem_id:2221001]。

#### 处理复杂约束：[大M法](@entry_id:170061)

当问题包含 $\ge$ 或 $=$ 约束时，我们就需要借助[人工变量](@entry_id:164298)和像[大M法](@entry_id:170061)这样的技术。[大M法](@entry_id:170061)的思想是在[目标函数](@entry_id:267263)中对[人工变量](@entry_id:164298)施加一个巨大的惩罚。对于最大化问题，我们从[目标函数](@entry_id:267263)中减去 $M \cdot a_i$，其中 $M$ 是一个非常大的正数：
$Z' = Z - M \sum a_i$

由于 $M$ 极​​大，任何使得 $a_i > 0$ 的解都会导致目标函数值急剧下降。因此，优化过程会优先将所有[人工变量](@entry_id:164298)的值驱动到零。

在构建初始单纯形表时，我们需要确保[目标函数](@entry_id:267263)行（通常称为Z行）中，所有初始基本变量（包括[人工变量](@entry_id:164298)）的系数都为0。这可能需要进行一次初始的行变换。

例如，假设一个问题包含约束 $x_1 + x_2 - s_3 + a_3 = 30$，[目标函数](@entry_id:267263)为最大化 $P = 40x_1 + 32x_2$。在使用[大M法](@entry_id:170061)时，新的目标函数为 $P' = 40x_1 + 32x_2 - M a_3$。对应的Z行方程为 $P - 40x_1 - 32x_2 + M a_3 = 0$。由于 $a_3$ 是初始基本变量，其在Z行的系数 $M$ 必须被消除。我们可以通过将包含 $a_3$ 的约束方程乘以 $M$ 并从Z行方程中减去来实现。
原始Z行：$[1, -40, -32, 0, M, 0]$ (系数对应 $P, x_1, x_2, s_3, a_3$, RHS)
约束3行：$[0, 1, 1, -1, 1, 30]$
新的Z行 = 原始Z行 - $M \times$ 约束3行。
计算结果将得到新的Z行，其中 $x_1$ 的系数变为 $-(40+M)$，$x_2$ 的系数变为 $-(32+M)$，$s_3$ 的系数变为 $M$，RHS变为 $-30M$ [@problem_id:2220997]。这个准备好的表格现在可以用于单纯形法的迭代了。

### 单纯形法的迭代过程：枢轴变换

一旦建立了初始的单纯形表，算法就通过一系列的**枢轴变换（pivot operation）**进行迭代。每一次成功的枢轴变换都对应着从[可行域](@entry_id:136622)的一个顶点移动到另一个相邻的顶点，同时保证目标函数值不会变差。

一个完整的枢轴变换包括三个步骤：

#### 1. 选择入基变量

首先，我们需要决定哪个非基本变量应该进入基，成为基本变量。这个变量被称为**入基变量（entering variable）**。我们检查单纯形表的目标函数行。对于最大化问题，如果Z行中存在负系数（在某些表示法中称为**判别数**或**既约成本**），则意味着增加对应非基本变量的值可以使目标函数值增加。

例如，在Z行方程 $Z - 5x_1 - 4x_2 = 0$ 中， $Z = 5x_1 + 4x_2$。显然，增加 $x_1$ 或 $x_2$ 都会使 $Z$ 增大。通常，我们选择Z行中具有最负系数的变量作为入基变量，因为它提供了单位增量下目标函数最快的增长率。如果Z行所有系数都非负，说明已无法再改进[目标函数](@entry_id:267263)，当前解即为最优解 [@problem_id:2221004]。

#### 2. 选择出基变量：最小比值检验

选定入基变量后，我们需要确定哪个当前的基本变量将离开基，成为非基本变量。这个变量被称为**出基变量（leaving variable）**。这个决策至关重要，因为它确保了下一次迭代的解仍然是可行的（即所有变量都非负）。

我们使用**最小比值检验（minimum ratio test）**来做此选择。对于入基变量所在列（枢轴列）的每一个正系数，我们计算其所在行的右侧（RHS）值与该系数的比值。
比值 = $\frac{\text{RHS}}{\text{枢轴列中的正系数}}$

我们选择具有最小非负比值的行。该行对应的基本变量就是出基变量。

这个检验的原理是：入基变量的值将从0开始增加，这个增加会导致当前基本变量的值发生变化。比值最小的行所对应的基本变量将是第一个减少到0的变量。如果我们让入基变量增加得更多，这个基本变量就会变成负数，从而破坏可行性。

至关重要的是，比值检验**只对枢轴列中的严格正系数进行**。为什么？
-   **如果系数为0**：入基变量的变化对该行的基本变量没有影响。因此，该约束不会限制入基变量的增加。从代数上看，用0作分母是未定义的 [@problem_id:2221016]。
-   **如果系数为负**：入基变量的增加将导致该行的基本变量也增加，而不是减少。例如，如果 $x_B = b - a \cdot x_{enter}$ 且 $a0$，则增加 $x_{enter}$ 会使 $x_B$ 变得更大，永远不会使其变为负数。因此，这个约束同样不限制入基变量的增加 [@problem_id:2221016]。

#### 3. 执行枢轴变换

选定了入基变量和出基变量后，它们[交叉](@entry_id:147634)位置的元素被称为**枢轴元素（pivot element）**。枢轴变换的目标是通过行操作（[高斯消元法](@entry_id:153590)），将枢轴元素变为1，并将枢轴列中的所有其他元素变为0。
-   首先，将枢轴所在的行（枢轴行）整体除以枢轴元素。
-   然后，通过将新的枢轴行乘以适当的倍数，加到其他行上，来将枢轴列的其他元素清零。

完成这一系列行操作后，我们就得到了一个新的单纯形表，它代表了[可行域](@entry_id:136622)的一个新的顶点。入基变量现在是基本变量，而出基变量则成了非基本变量。[目标函数](@entry_id:267263)的值也得到了更新。这个过程在几何上对应着沿着[可行域](@entry_id:136622)的一条边移动到了一个相邻的顶点 [@problem_id:2221014] [@problem_id:2221017]。

### 解释最终结果

单纯形算法的迭代过程会因以下三种情况之一而终止：

#### 1. 找到最优解

当单纯形表的Z行中所有与非基本变量对应的系数都为非负（对于最大化问题）时，[算法终止](@entry_id:143996)。这表明当前的基本可行解是最优的，因为增加任何非基本变量的值都无法使[目标函数](@entry_id:267263)值增加。

-   **唯一最优解**：如果Z行中所有非基本变量的系数都为严格正数，则最优解是唯一的。
-   **多重最优解（或称替代最优解）**：如果在最优表中，存在某个非基本变量在Z行的系数为0，这表明存在多重最优解。这个非基本变量可以进入基，而不会改变[目标函数](@entry_id:267263)的最终值，从而产生另一个具有相同最优值的不同[顶点解](@entry_id:637043)。连接这两个顶点的边上的所有点也都是最优解 [@problem_id:2221018]。

#### 2. 问题是无界的

如果在某次迭代中，我们选择了一个入基变量（其Z行系数为负），但在进行最小比值检验时，发现其所在列的所有系数都小于或等于0。这意味着该入基变量的值可以无限增加，而不会导致任何基本变量变为负数。因此，目标函数值也可以无限增长。这种情况表明，该[线性规划](@entry_id:138188)问题是**无界的（unbounded）** [@problem_id:2221026]。

#### 3. 问题是不可行的

当使用[两阶段法](@entry_id:166636)时，如果在第一阶段结束时，目标函数（即[人工变量](@entry_id:164298)之和）的最小值是一个严格的正数，这表明不可能找到一个使所有[人工变量](@entry_id:164298)都为0的解。这意味着原始问题的约束是矛盾的，因此问题是**不可行的（infeasible）**，即不存在满足所有约束的解 [@problem_id:2221010]。

### 特殊情况：退化与循环

在单纯形法的执行过程中，可能会遇到一些特殊情况，其中最著名的是**退化（degeneracy）**。

当一个基本可行解中有一个或多个基本变量的值为0时，就称该解是退化的。这通常发生在最小比值检验中出现平局（即多个行得到相同的最小比值）时。

退化本身不一定是个问题，但它可能导致一种称为**循环（cycling）**的现象。在退化的情况下，一次枢轴变换可能会选择一个值为0的基本变量作为出基变量。这样做的结果是，基发生了改变（一个变量进，一个变量出），但解（即所有变量的值）保持不变，[目标函数](@entry_id:267263)值也保持不变。如果算法的枢轴选择规则不当，它可能会在一系列不同的基之间转换，而这些基都对应着同一个退化的顶点，最终返回到之前访问过的一个基，从而陷入无限循环 [@problem_id:2221021]。

虽然循环在理论上是一个隐患，但在实际应用中非常罕见。此外，已经有成熟的**[反循环规则](@entry_id:637416)**（如Bland规则）可以保证算法在有限步内终止，从而避免了循环问题。

本章详细阐述了单纯形法的核心原理和机制。通过将问题[标准化](@entry_id:637219)，利用单纯形表进行迭代，我们能够系统地探索[可行域的顶点](@entry_id:174284)，直至找到最优解，或判断问题是无界或不可行的。理解这些机制对于有效应用线性规划解决实际[优化问题](@entry_id:266749)至关重要。