{"hands_on_practices": [{"introduction": "像 Adams-Moulton 这样的隐式方法的强大之处，往往伴随着在每一步求解一个方程的挑战。预测-校正方案为这一问题提供了一个优雅而高效的解决方案。第一个练习 [@problem_id:2152822] 将指导你完成此过程的单步计算，即使用一个显式方法来“预测”一个值，然后用一个隐式方法来“校正”它，让你对计算工作流程有切实的感受。", "problem": "考虑由常微分方程 $y'(t) = y(t) - t^2 + 1$ 定义的初值问题。假设我们使用固定步长 $h = 0.2$ 的数值方法来近似求解。我们已知近似解曲线上的前两个点：在 $t_0 = 0.0$ 时，值为 $y_0 = 0.5$；在 $t_1 = 0.2$ 时，值为 $y_1 = 0.82930$。\n\n您的任务是通过应用以下预估-校正格式的单步来计算在时间 $t_2 = 0.4$ 时的下一个值 $y_2$。\n\n首先，使用以下公式计算预估值 $y_{i+1}^*$：\n$$y_{i+1}^* = y_i + \\frac{h}{2}\\left(3f(t_i, y_i) - f(t_{i-1}, y_{i-1})\\right)$$\n其中 $f(t,y) = y'(t)$。\n\n其次，使用这个预估值，通过以下公式计算校正值 $y_{i+1}$：\n$$y_{i+1} = y_i + \\frac{h}{2}\\left(f(t_{i+1}, y_{i+1}^*) + f(t_i, y_i)\\right)$$\n\n报告最终的校正值 $y_2$。将您的最终答案四舍五入到五位有效数字。", "solution": "给定常微分方程 $y'(t)=f(t,y)=y-t^2+1$ 和步长 $h=0.2$，已知数值为 $(t_0,y_0)=(0.0,0.5)$ 和 $(t_1,y_1)=(0.2,0.82930)$。我们的目标是使用指定的预估-校正格式计算在 $t_2=0.4$ 时的 $y_2$。\n\n首先计算在已知点处的函数值：\n$$f(t_0,y_0)=y_0-t_0^2+1=0.5-0^2+1=1.5,$$\n$$f(t_1,y_1)=y_1-t_1^2+1=0.82930-0.2^2+1=1.78930.$$\n\n预估步（两步 Adams-Bashforth 方法）：\n$$y_2^*=y_1+\\frac{h}{2}\\left(3f(t_1,y_1)-f(t_0,y_0)\\right)\n=0.82930+0.1\\left(3\\cdot 1.78930-1.5\\right)=0.82930+0.1\\cdot 3.86790=1.216090.$$\n\n在预估点 $(t_2,y_2^*)=(0.4,1.216090)$ 处计算 $f$ 的值：\n$$f(t_2,y_2^*)=y_2^*-t_2^2+1=1.216090-0.4^2+1=2.056090.$$\n\n校正步（使用预估端点值的梯形步）：\n$$y_2=y_1+\\frac{h}{2}\\left(f(t_2,y_2^*)+f(t_1,y_1)\\right)\n=0.82930+0.1\\left(2.056090+1.78930\\right)\n=0.82930+0.3845390=1.2138390.$$\n\n四舍五入到五位有效数字得到 $1.2138$。", "answer": "$$\\boxed{1.2138}$$", "id": "2152822"}, {"introduction": "除了单步计算的机制，一个方法的真正效用取决于它在许多步后的累积精度。“阶数”这一概念为此提供了一个强有力的量化方式。这个练习 [@problem_id:2152827] 是一个思想实验，它探讨了方法的阶数对其全局误差的直接而显著的影响，帮助你理解像步长 $h$ 这样的选择会如何影响你模拟的最终精度。", "problem": "一位计算科学家正在模拟一个系统，其状态由函数 $y(t)$ 表示，并遵循一个性状良好的常微分方程 (ODE) 演化。为求得近似解，他们采用了四阶 Adams-Moulton 方法，这是一种常用的隐式多步法。\n\n在第一次模拟中，使用恒定的步长 $h$ 对 ODE 从初始时间 $t_0$ 积分到最终时间 $t_f$。完成后，将计算出的解与高精度的基准解进行比较，发现在最终时间 $t_f$ 处的全局误差为 $\\epsilon$。\n\n为了探究精度与计算成本之间的权衡，该科学家在相同的时间间隔内再次运行模拟，但这次使用了新的、更大的步长 $h_{new} = 2h$。假设 $h$ 和 $h_{new}$ 都足够小，处于该方法的收敛渐近区，请给出在时间 $t_f$ 处新的全局误差 $\\epsilon_{new}$ 的最佳估计。\n\nA. $2\\epsilon$\nB. $4\\epsilon$\nC. $8\\epsilon$\nD. $16\\epsilon$\nE. $32\\epsilon$", "solution": "题目告知我们所使用的方法是四阶 Adams-Moulton 方法。一个 $p$ 阶线性多步法的局部截断误差为 $\\mathcal{O}(h^{p+1})$ 阶，并且在零点稳定性和解的光滑性条件下，其全局误差为 $\\mathcal{O}(h^p)$ 阶。对于四阶 Adams-Moulton 方法，有 $p=4$。\n\n在渐近区，固定最终时间下的全局误差可以建模为\n$$\n\\epsilon \\approx C h^{p},\n$$\n其中 $C$ 是一个与问题和方法相关但与 $h$ 无关的常数。当 $p=4$ 时，该式变为\n$$\n\\epsilon \\approx C h^{4}.\n$$\n当步长加倍到 $h_{new} = 2h$ 时，新的全局误差按以下方式缩放：\n$$\n\\epsilon_{new} \\approx C (h_{new})^{4} = C (2h)^{4} = 16 C h^{4} = 16 \\epsilon.\n$$\n因此，新的全局误差的最佳估计是 $16\\epsilon$，对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "2152827"}, {"introduction": "精度至关重要，但如果数值解变得不稳定并与真实解发散，那么精度就毫无意义。最后一个更高级的练习 [@problem_id:2371562] 深入探讨了绝对稳定性的关键概念，并挑战了“阶数越高越好”这一常见假设。通过用代码构建一个特殊案例，你将亲眼见证一个低阶方法在某个问题上保持稳定，而高阶方法却失败了，这揭示了为难题选择正确工具时所涉及的微妙权衡。", "problem": "你需要构造并分析一个线性常微分方程（ODE），以揭示两种不同阶的隐式 Adams–Moulton 多步法之间一种违反直觉的稳定性行为。目标是找到一个例子，在该例子中，对于给定的步长，二阶 Adams–Moulton 方法（AM-2）是稳定的，而更高阶的四阶 Adams–Moulton 方法（AM-4）是不稳定的。你必须实现一个程序，通过将线性多步法的基本根条件应用于线性测试方程，来验证稳定性或不稳定性。\n\n基本依据和定义：\n- 考虑线性测试方程 $y' = \\lambda y$，其中复标量 $\\lambda \\in \\mathbb{C}$。对于固定的步长 $h > 0$，定义复数 $z = h \\lambda$。\n- 一个线性多步法具有形式 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$，其中 $f_{n+j} = f(t_{n+j}, y_{n+j})$。在线性测试方程 $f(t,y) = \\lambda y$ 上，该方法简化为关于放大因子 $\\xi$ 的特征方程：$\\rho(\\xi) - z \\sigma(\\xi) = 0$，其中 $\\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ 且 $\\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$。\n- 对于给定的 $z$，绝对稳定性意味着 $\\rho(\\xi) - z \\sigma(\\xi) = 0$ 的所有根 $\\xi$ 都满足 $|\\xi| \\le 1$；如果一个根位于单位圆上，它必须是单根才能是临界稳定的。你应该实现一个对根条件的数值检验，并在一个小的数值容差范围内将 $|\\xi| \\le 1$ 视为稳定。\n\n任务要求：\n1. 使用上述原理，为 $2$ 阶 Adams–Moulton 方法 (AM-2) 和 $4$ 阶 Adams–Moulton 方法 (AM-4) 实现稳定性测试。你应该使用这些方法的标准 Adams–Moulton 系数。对于每种方法，构造相应的多项式 $\\rho(\\xi)$ 和 $\\sigma(\\xi)$，并对给定的 $z$ 测试根条件。\n2. 构造一个形式为 $y' = \\lambda y$ 的标量线性 ODE，它在以下意义上是“病态的”：对于一个指定的步长 $h$，AM-2 方法是稳定的（所有根满足 $|\\xi| \\le 1$），而 AM-4 方法是不稳定的（至少有一个根满足 $|\\xi| > 1$）。你的程序应通过根条件进行数值验证，而不是借助任何外部的稳定性区域图。\n3. 通过使用标准的多项式求根器计算特征多项式的根，并在一个小的数值容差下验证模条件，来稳健地实现稳定性检查。\n\n测试套件：\n在以下三个测试用例上评估你的实现，每个用例由序对 $(\\lambda,h)$ 指定：\n- 案例 1：$\\lambda = -1.0$, $h = 0.1$。\n- 案例 2：$\\lambda = -50.0$, $h = 0.2$。\n- 案例 3：$\\lambda = 1.0$, $h = 0.1$。\n\n对于每个案例，计算 $z = h \\lambda$ 并确定两个布尔值：第一个表示 AM-2 是否稳定，第二个表示 AM-4 是否稳定，两者都根据根条件判断。“病态”行为就嵌在其中一个案例里。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表的形式为 $[b_{\\mathrm{AM2}}, b_{\\mathrm{AM4}}]$，其中包含未加引号的布尔值。例如，输出必须看起来像 $[[\\text{True},\\text{False}],[\\text{True},\\text{True}],[\\text{False},\\text{False}]]$，但实际值由你对上述测试套件的计算确定。", "solution": "所述问题是常微分方程数值分析中的一个标准练习。它有科学依据，定义明确，并包含足够的信息以继续进行。其目标是展示一个已知的现象，即高阶数值方法可能比较低阶方法具有更小的稳定性区域，从而对某些刚性问题导致违反直觉的行为。下面我将开始求解。\n\n分析的核心是线性测试方程，这是研究 ODE 数值方法稳定性的基本工具。该方程由下式给出：\n$$\ny'(t) = \\lambda y(t)\n$$\n其中 $y(t) \\in \\mathbb{C}$ 且 $\\lambda \\in \\mathbb{C}$。当一个形式为 $\\sum_{j=0}^{s} \\alpha_j y_{n+j} = h \\sum_{j=0}^{s} \\beta_j f_{n+j}$ 的线性多步法 (LMM) 应用于此方程（其中 $f(t,y) = \\lambda y$）时，会产生关于序列 $\\{y_n\\}$ 的线性常系数递推关系。该递推关系的解形式为 $y_n = \\xi^n$，其中 $\\xi$ 是特征方程的根：\n$$\n\\rho(\\xi) - z \\sigma(\\xi) = 0\n$$\n此处，$z = h\\lambda$，而 $\\rho(\\xi) = \\sum_{j=0}^{s} \\alpha_j \\xi^j$ 和 $\\sigma(\\xi) = \\sum_{j=0}^{s} \\beta_j \\xi^j$ 分别是该方法的第一和第二特征多项式。\n\n对于给定的 $z$，如果其特征方程的所有根 $\\xi_k$ 都满足 $|\\xi_k| \\le 1$，则该方法被定义为绝对稳定。任何模等于 $1$ 的根必须是单根。问题陈述允许在数值实现上稍作放宽，其中在小的容差 $\\epsilon$ 下， $|\\xi_k| \\le 1 + \\epsilon$ 被认为是稳定的。这种检查方式简化了分析，避免了对单位圆上单根的显式检查。\n\n首先，我们分析二阶 Adams-Moulton 方法（AM-2），也称为梯形法则。这是一个单步方法（$s=1$），定义为：\n$$\ny_{n+1} - y_{n} = \\frac{h}{2} (f_{n+1} + f_n)\n$$\n由此形式，我们确定系数为 $\\alpha_1=1, \\alpha_0=-1$ 和 $\\beta_1=1/2, \\beta_0=1/2$。特征多项式为：\n$$\n\\rho(\\xi) = \\xi - 1\n$$\n$$\n\\sigma(\\xi) = \\frac{1}{2}\\xi + \\frac{1}{2}\n$$\n得到的特征方程是一个关于 $\\xi$ 的线性方程：\n$$\n(\\xi - 1) - z \\left( \\frac{1}{2}\\xi + \\frac{1}{2} \\right) = 0 \\implies \\xi\\left(1 - \\frac{z}{2}\\right) = 1 + \\frac{z}{2}\n$$\n唯一的根，即放大因子，为：\n$$\n\\xi = \\frac{1 + z/2}{1 - z/2}\n$$\n为保证稳定性，我们需要 $|\\xi| \\le 1$。设 $z = x+iy$。条件 $|\\frac{2+z}{2-z}| \\le 1$ 等价于 $|2+z|^2 \\le |2-z|^2$。\n$$\n(2+x)^2 + y^2 \\le (2-x)^2 + y^2 \\implies 4+4x+x^2 \\le 4-4x+x^2 \\implies 8x \\le 0 \\implies x \\le 0\n$$\n因此，对于复平面左半部分中的所有 $z$（即 $\\text{Re}(z) \\le 0$），AM-2 方法是稳定的。此性质被称为 A-稳定性。\n\n接下来，我们分析四阶 Adams-Moulton 方法（AM-4）。这是一个三步方法（$s=3$），由以下公式给出：\n$$\ny_{n+3} - y_{n+2} = \\frac{h}{24}(9f_{n+3} + 19f_{n+2} - 5f_{n+1} + f_n)\n$$\n由此，我们提取系数。第一特征多项式有 $\\alpha_3=1, \\alpha_2=-1$，所有其他的 $\\alpha_j=0$：\n$$\n\\rho(\\xi) = \\xi^3 - \\xi^2\n$$\n第二特征多项式的系数为 $\\beta_3 = 9/24, \\beta_2 = 19/24, \\beta_1 = -5/24,$ 和 $\\beta_0 = 1/24$：\n$$\n\\sigma(\\xi) = \\frac{1}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1)\n$$\n特征方程 $\\rho(\\xi) - z \\sigma(\\xi) = 0$ 为：\n$$\n(\\xi^3 - \\xi^2) - \\frac{z}{24}(9\\xi^3 + 19\\xi^2 - 5\\xi + 1) = 0\n$$\n乘以 $24$ 并按 $\\xi$ 的幂次收集项，得到一个三次多项式方程：\n$$\n(24 - 9z)\\xi^3 + (-24 - 19z)\\xi^2 + (5z)\\xi - z = 0\n$$\n与 AM-2 不同，该方程无法通过解析方法轻易求解其稳定区域。对于给定的 $z$，AM-4 的稳定性必须通过数值方法找到该多项式的三个根，并检查它们的模是否都小于或等于 $1$ 来确定。一个已知的结果是 AM-4 不是 A-稳定的；其绝对稳定区域不包含整个左半平面。\n\n实现将按以下步骤进行。对于每个给定的序对 $(\\lambda, h)$：\n1. 计算 $z = h\\lambda$。\n2. 对于 AM-2，计算 $\\xi = (1 + z/2)/(1 - z/2)$ 并检查是否 $|\\xi| \\le 1 + \\epsilon$。\n3. 对于 AM-4，构造三次多项式 $P(\\xi) = a_3 \\xi^3 + a_2 \\xi^2 + a_1 \\xi + a_0$ 的复系数，其中 $a_3=24-9z, a_2=-24-19z, a_1=5z,$ 且 $a_0=-z$。使用标准的数值求根器获得根 $\\xi_1, \\xi_2, \\xi_3$。检查是否 $\\max(|\\xi_1|, |\\xi_2|, |\\xi_3|) \\le 1 + \\epsilon$。\n4. 一个小的容差 $\\epsilon = 10^{-9}$ 适合用于此数值检查。\n\n我们现在根据此过程评估所提供的测试用例。\n\n- **案例 1**：$(\\lambda, h) = (-1.0, 0.1) \\implies z = -0.1$。\n  - AM-2：$\\text{Re}(z) = -0.1 \\le 0$。该方法稳定。\n  - AM-4：$z = -0.1$ 是一个非常靠近原点的点。该方法是零点稳定的，并且对于小的负实数 $z$，已知是稳定的。我们预期其是稳定的。\n  - 预测结果：$[\\text{True}, \\text{True}]$。\n\n- **案例 2**：$(\\lambda, h) = (-50.0, 0.2) \\implies z = -10.0$。\n  - AM-2：$\\text{Re}(z) = -10.0 \\le 0$。该方法是 A-稳定的，因此它保持稳定。\n  - AM-4：AM-4 沿负实轴的稳定区域大约是 $(-3.0, 0)$。由于 $z = -10.0$ 远在该区间之外，我们预期至少有一个根的模大于 $1$。该方法不稳定。这就是那个病态的案例。\n  - 预测结果：$[\\text{True}, \\text{False}]$。\n\n- **案例 3**：$(\\lambda, h) = (1.0, 0.1) \\implies z = 0.1$。\n  - AM-2：$\\text{Re}(z) = 0.1 > 0$。该方法不稳定。\n  - AM-4：对于 $\\text{Re}(z) > 0$，预期是不稳定的。$\\rho(\\xi)$ 在 $\\xi=1$ 处的根会被扰动到一个大于 $1$ 的值。该方法不稳定。\n  - 预测结果：$[\\text{False}, \\text{False}]$。\n\n最终的程序将实现这一逻辑，并通过数值方式验证这些预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef check_stability_am2(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-2 method for a given z = h*lambda.\n    AM-2 is stable if the single root xi of its characteristic equation has |xi| = 1.\n    \"\"\"\n    # The characteristic polynomial for AM-2 is (1 - z/2)*xi - (1 + z/2) = 0.\n    # Avoid division by zero if z = 2.\n    if abs(z - 2.0)  tol:\n        # If z=2, the equation is degenerate. Physically, this corresponds to an\n        # infinite amplification factor, hence unstable.\n        return False\n        \n    xi = (1 + z / 2) / (1 - z / 2)\n    return np.abs(xi) = 1.0 + tol\n\ndef check_stability_am4(z: complex, tol: float = 1e-9) -> bool:\n    \"\"\"\n    Checks the stability of the AM-4 method for a given z = h*lambda.\n    AM-4 is stable if all roots xi of its characteristic equation have |xi| = 1.\n    \"\"\"\n    # Characteristic equation for AM-4:\n    # (24 - 9*z)*xi^3 + (-24 - 19*z)*xi^2 + (5*z)*xi - z = 0\n    # Coefficients of the cubic polynomial a*xi^3 + b*xi^2 + c*xi + d = 0\n    # The coefficients are complex numbers.\n    coeffs = [\n        24 - 9 * z,\n        -24 - 19 * z,\n        5 * z,\n        -z\n    ]\n    \n    # Use numpy.roots to find the roots of the polynomial.\n    # The roots will be complex.\n    try:\n        roots = np.roots(coeffs)\n    except np.linalg.LinAlgError:\n        # This can happen in degenerate cases, considered unstable.\n        return False\n\n    # Check the modulus of each root. The method is unstable if any root has\n    # a modulus greater than 1 (plus tolerance).\n    max_modulus = np.max(np.abs(roots))\n    \n    return max_modulus = 1.0 + tol\n\ndef solve():\n    \"\"\"\n    Solves the problem by evaluating the stability of AM-2 and AM-4 for given test cases.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (lambda, h).\n    test_cases = [\n        (-1.0, 0.1),\n        (-50.0, 0.2),\n        (1.0, 0.1),\n    ]\n\n    results = []\n    for lambda_val, h_val in test_cases:\n        # Calculate z = h * lambda\n        z = h_val * lambda_val\n        \n        # Check stability for AM-2 and AM-4\n        is_stable_am2 = check_stability_am2(z)\n        is_stable_am4 = check_stability_am4(z)\n        \n        results.append([is_stable_am2, is_stable_am4])\n\n    # Format the final output string exactly as specified.\n    # e.g., [[True,False],[True,True],[False,False]]\n    # No spaces within the inner lists.\n    formatted_inner_lists = [f\"[{r[0]},{r[1]}]\" for r in results]\n    output_string = f\"[{','.join(formatted_inner_lists)}]\"\n    \n    print(output_string)\n\nsolve()\n```", "id": "2371562"}]}