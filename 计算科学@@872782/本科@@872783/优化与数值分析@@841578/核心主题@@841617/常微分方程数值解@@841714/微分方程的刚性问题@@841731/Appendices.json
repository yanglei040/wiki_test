{"hands_on_practices": [{"introduction": "要有效解决刚性微分方程，我们首先需要理解为什么某些数值方法比其他方法更胜任。本练习将带你深入数值稳定性的核心，通过代数推导来分析后向欧拉法这一经典隐式方法的稳定性。这个基础练习将揭示为什么隐式方法在处理时间尺度差异巨大的问题时具有天然的优势。[@problem_id:2206441]", "problem": "在分析求解常微分方程（ODE）的数值方法的稳定性时，一个标准程序是将该方法应用于 Dahlquist 测试方程 $y'(t) = \\lambda y(t)$，其中 $\\lambda$ 是一个复常数。对于一个给定的方法，固定步长 $h > 0$，应用该方法会得到一个形式为 $y_{n+1} = G(z) y_n$ 的递推关系，其中 $z = \\lambda h$，函数 $G(z)$ 被称为放大因子。对于特定的 $h$ 和 $\\lambda$ 选择，该方法的稳定性由这个因子的模决定；如果 $|G(z)| \\le 1$，则该方法被认为是稳定的。\n\n后向欧拉法是一种隐式单步法，由公式 $y_{n+1} = y_n + h f(t_{n+1}, y_{n+1})$ 定义，其中 $y'(t) = f(t, y(t))$。\n\n设复数 $z = \\lambda h$ 由其实部和虚部表示为 $z = x + iy$。您的任务是推导后向欧拉法放大因子模的平方 $|G(z)|^2$ 的表达式。最终表达式必须纯粹用 $z$ 的实部 $x$ 和虚部 $y$ 来表示。", "solution": "我们从 Dahlquist 测试方程 $y'(t)=\\lambda y(t)$ 开始，并应用后向欧拉法 $y_{n+1}=y_{n}+h f(t_{n+1},y_{n+1})$。代入 $f(t,y)=\\lambda y$，可得\n$$\ny_{n+1}=y_{n}+h\\lambda y_{n+1}.\n$$\n整理各项，\n$$\n(1-h\\lambda)y_{n+1}=y_{n}.\n$$\n引入 $z=\\lambda h$，我们得到\n$$\n(1-z)y_{n+1}=y_{n}\\quad\\Longrightarrow\\quad y_{n+1}=G(z)y_{n},\\qquad G(z)=\\frac{1}{1-z}.\n$$\n因此，放大因子模的平方是\n$$\n|G(z)|^{2}=\\left|\\frac{1}{1-z}\\right|^{2}=\\frac{1}{|1-z|^{2}}.\n$$\n将 $z=x+iy$（其中 $x$ 和 $y$ 为实数）代入，我们有 $1-z=(1-x)-iy$。对于复数 $a+ib$，其模的平方为 $|a+ib|^{2}=a^{2}+b^{2}$，因此\n$$\n|1-z|^{2}=(1-x)^{2}+y^{2}.\n$$\n所以，\n$$\n|G(z)|^{2}=\\frac{1}{(1-x)^{2}+y^{2}}.\n$$\n该表达式按要求纯粹用 $x$ 和 $y$ 表示。", "answer": "$$\\boxed{\\frac{1}{(1-x)^{2}+y^{2}}}$$", "id": "2206441"}, {"introduction": "理论分析告诉我们显式方法在处理刚性问题时会遇到困难，但这种“困难”在实践中究竟是什么样子？本练习将让你通过编写代码亲身体验这一现象。你将使用一个标准的自适应显式求解器来求解刚性和非刚性问题，并直接观察其步长选择行为，从而学会通过计算实验来诊断刚性。[@problem_id:2439135]", "problem": "构建一个程序，用于分析显式自适应积分器在表现出刚性的初值问题上的步长行为。对于每个给定的初值问题，对系统进行积分，并记录积分过程中的最小可接受时间步长。使用一个带有嵌入式四阶估计器的五阶显式龙格-库塔-费尔伯格方法（Runge–Kutta–Fehlberg (RKF45)），并采用标准的绝对和相对误差控制。对于所有问题，要求绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$。定义一个可接受步长为：其嵌入式局部误差估计满足一个标准的加权均方根准则，即小于或等于 $1$。定义“极端步长缩减”为：在指定的积分区间内，出现的最小可接受时间步长严格小于 $10^{-4}$。\n\n您必须评估以下初值问题测试套件：\n\n- 测试 A（非刚性标量）：$$y'(t) = -y(t), \\quad y(0) = 1, \\quad t \\in [0, 10].$$\n- 测试 B（刚性标量，强迫线性）：$$y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}, \\quad y(0) = 0, \\quad t \\in [0, 0.1].$$\n- 测试 C（刚性线性双分量系统）：$$\\begin{aligned} y_1'(t) = -15\\,y_1(t), \\\\ y_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right), \\end{aligned} \\quad \\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad t \\in [0, 0.2].$$\n\n对于每个测试，计算在积分过程中遇到的最小可接受步长 $h_{\\min}$，并根据 $h_{\\min}  10^{-4}$ 是否成立来确定一个布尔值。要求的最终输出是一行，其中包含一个逗号分隔的这三个布尔结果列表，顺序为 $\\text{[A,B,C]}$，并用方括号括起来。例如，形式为 $\\text{[False,True,True]}$ 的输出表示测试 B 和测试 C 发生了极端步长缩减，而测试 A 没有。\n\n该问题中没有物理单位。不出现角度。不使用百分比。您的程序必须产生单行输出，其中包含一个逗号分隔的列表形式的结果，并用方括号括起来，严格按照上述 $\\text{[A,B,C]}$ 的顺序。", "solution": "问题陈述已经过验证，并被认为是有效的。它具有科学依据，问题设定良好、客观，并包含了构建一个唯一、可验证解所需的所有信息。该问题属于计算工程和数值分析领域，具体涉及常微分方程（ODE）中的刚性概念。\n\n当一个初值问题的解包含在差异巨大的时间尺度上变化的多个分量时，就会出现刚性。这对显式数值积分方法构成了重大挑战。虽然快速衰减的分量（瞬态）可能很快变得可以忽略不计，但它们在系统雅可比矩阵中的存在会继续对积分器的步长施加严格限制，以维持数值稳定性。步长受到最快时间尺度的限制，即使从解的光滑、慢变部分的精度考虑，本可以允许大得多的步长。这导致了计算效率低下的积分过程，因为求解器被迫采取过多极小的步长。\n\n本任务旨在通过分析一个显式自适应积分器在三个不同常微分方程问题上的步长行为来展示这一现象。所选的积分器是一个五阶龙格-库塔-费尔伯格方法，带有一个嵌入式的四阶误差估计器，通常称为 RKF45。这类方法的一个现代、高质量的实现是 Dormand-Prince 5(4) 对，它在 `scipy` 库中以 `scipy.integrate.solve_ivp` 和 `method='RK45'` 的形式提供。这将是用于数值积分的工具。\n\n积分过程使用基于局部误差估计的自适应步长控制。在每一步，通过比较五阶解与嵌入的四阶解来估计误差。这个误差 $E$ 使用加权均方根范数来度量，只有当 $E \\le 1$ 时，该步长才被接受。权重是指定的绝对容差 $\\mathrm{atol} = 10^{-9}$ 和相对容差 $\\mathrm{rtol} = 10^{-6}$ 的函数。具体来说，对于解向量 $y$，误差由 $\\mathrm{atol} + \\mathrm{rtol} \\times |y|$ 进行缩放。在一个大小为 $h$ 的可接受步长之后，选择下一个步长以使估计误差接近目标值 $1$。如果误差过大，则拒绝该步长，并用更小的 $h$ 重试。\n\n我们将分析三个初值问题，并记录每个问题的最小可接受步长 $h_{\\min}$。“极端步长缩减”的条件定义为 $h_{\\min}  10^{-4}$。\n\n测试 A：非刚性标量问题\n常微分方程为 $y'(t) = -y(t)$，初值为 $y(0)=1$，时间区间为 $t \\in [0, 10]$。\n系统的雅可比矩阵只是标量 $J = [-1]$。唯一的特征值是 $\\lambda = -1$，对应的时间常数为 $\\tau = 1/|\\lambda| = 1$。解为 $y(t) = e^{-t}$。只有一个时间尺度，且不是特别快。自适应积分器选择的步长将主要由 $\\mathrm{atol}$ 和 $\\mathrm{rtol}$ 定义的精度要求决定。我们不期望稳定性会迫使步长变得异常小。因此，预测 $h_{\\min}$ 不会低于 $10^{-4}$ 的阈值。\n\n测试 B：刚性标量问题\n常微分方程为 $y'(t) = -10000\\,y(t) + 30000 - 20000\\,e^{-t}$，初值为 $y(0)=0$，时间区间为 $t \\in [0, 0.1]$。\n雅可比矩阵为 $J = [-10000]$。特征值为 $\\lambda = -10000$，对应一个极快的时间常数 $\\tau = 1/|\\lambda| = 10^{-4}\\,$s。显式龙格-库塔方法的稳定域要求步长 $h$ 和特征值 $\\lambda$ 的乘积位于复平面中的一个有界区域内。对于实数负特征值，这施加了一个形式为 $h \\lesssim C/|\\lambda|$ 的约束，其中 $C$ 是一个数量级为 $1$ 的常数。对于此问题，即为 $h \\lesssim C \\times 10^{-4}$。即使与此特征值相关的初始瞬态已经衰减（这在 $10^{-4}$ 的几个倍数时间内很快发生），这个稳定性约束对显式积分器仍然有效。因此，步长将在整个积分区间内受到严重限制。强烈预测 $h_{\\min}$ 将小于 $10^{-4}$。\n\n测试 C：刚性线性系统\n该系统由以下方程给出：\n$$\n\\begin{aligned}\ny_1'(t) = -15\\,y_1(t) \\\\\ny_2'(t) = -10000\\left(y_2(t) - y_1(t)\\right)\n\\end{aligned}\n\\quad \\text{其中} \\quad\n\\begin{bmatrix} y_1(0) \\\\ y_2(0) \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}\n\\quad \\text{在} \\quad t \\in [0, 0.2].\n$$\n该系统的雅可比矩阵是：\n$$\nJ = \\frac{\\partial \\mathbf{f}}{\\partial \\mathbf{y}} = \\begin{bmatrix} -15  0 \\\\ 10000  -10000 \\end{bmatrix}\n$$\n由于该矩阵是下三角矩阵，其特征值是其对角线元素：$\\lambda_1 = -15$ 和 $\\lambda_2 = -10000$。这对应于两个非常不同的时间尺度：一个慢尺度 $\\tau_1 = 1/15 \\approx 0.067$ 和一个非常快的尺度 $\\tau_2 = 1/10000 = 10^{-4}$。特征值幅值的比率，即刚性比，为 $|\\lambda_2|/|\\lambda_1| = 10000/15 \\approx 667$，这个值很大，证实了该系统是刚性的。与测试 B 一样，显式积分器的稳定性由模最大的特征值 $\\lambda_2 = -10000$ 决定。步长 $h$ 将受到与此特征值相关的稳定性限制，迫使 $h$ 保持在 $10^{-4}$ 或更小的数量级。因此，预测 $h_{\\min}  10^{-4}$。\n\n程序将通过对每种情况调用 `scipy.integrate.solve_ivp` 来实现这一分析。返回的解对象包含一个数组 `sol.t`，其中包含计算解的时间点。然后，通过计算该数组中的连续差分 `np.diff(sol.t)` 来获得可接受步长的序列。这些值的最小值即为 $h_{\\min}$，然后将其与 $10^{-4}$ 阈值进行比较，以产生所需的布尔输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\ndef solve():\n    \"\"\"\n    Analyzes step-size behavior of an explicit adaptive integrator on\n    initial value problems exhibiting stiffness, as per the problem description.\n    \"\"\"\n\n    # Define common parameters for the analysis.\n    atol = 1e-9\n    rtol = 1e-6\n    step_size_threshold = 1e-4\n\n    # Define the test cases.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"fun\": lambda t, y: -y,\n            \"t_span\": [0, 10],\n            \"y0\": [1],\n        },\n        {\n            \"name\": \"B\",\n            \"fun\": lambda t, y: -10000 * y[0] + 30000 - 20000 * np.exp(-t),\n            \"t_span\": [0, 0.1],\n            \"y0\": [0],\n        },\n        {\n            \"name\": \"C\",\n            \"fun\": lambda t, y: np.array([-15 * y[0], -10000 * (y[1] - y[0])]),\n            \"t_span\": [0, 0.2],\n            \"y0\": [1, 0],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Integrate the ODE system using the specified method and tolerances.\n        # The 'RK45' method in SciPy is the Dormand-Prince 5(4) pair, a standard\n        # high-quality implementation of the class of methods described in the problem.\n        sol = solve_ivp(\n            fun=case[\"fun\"],\n            t_span=case[\"t_span\"],\n            y0=case[\"y0\"],\n            method='RK45',\n            atol=atol,\n            rtol=rtol,\n        )\n\n        # The 'sol.t' attribute contains the time points of the accepted steps.\n        # The differences between consecutive time points are the accepted step sizes.\n        if len(sol.t)  2:\n            # This case should not occur for the given problems but is a safe check.\n            # If only one point (initial) or no points exist, there are no steps.\n            h_min = np.inf\n        else:\n            step_sizes = np.diff(sol.t)\n            h_min = np.min(step_sizes)\n\n        # Determine if extreme step-size reduction occurred.\n        # The problem defines this as h_min strictly less than the threshold.\n        extreme_reduction = h_min  step_size_threshold\n        results.append(extreme_reduction)\n\n    # Format the final output string as a comma-separated list of booleans.\n    results_str = [str(r) for r in results]\n    \n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2439135"}, {"introduction": "识别问题是第一步，而高效地解决问题是最终目标。本练习将引导你从诊断转向构建解决方案，你将实现一种专为特定结构的刚性问题设计的强大数值方法——隐式-显式（IMEX）方法。通过处理一个典型的反应-扩散模型，你将学会如何将一个复杂系统分解为刚性部分和非刚性部分，并对它们应用不同的积分策略，这是现代科学计算中的一项核心技能。[@problem_id:2439136]", "problem": "考虑一个半离散反应扩散系统的初值问题，该系统由一维空间域上的均匀二阶中心差分离散化得到。设空间域为闭区间 $\\left[0,1\\right]$，边界条件为齐次狄利克雷（Dirichlet）边界条件。对于整数 $N \\ge 1$，定义一个包含 $N$ 个内部点的均匀网格，其位置为 $x_j = \\dfrac{j}{N+1}$（$j = 1,2,\\ldots,N$），网格间距为 $\\Delta x = \\dfrac{1}{N+1}$。定义状态向量 $y(t) \\in \\mathbb{R}^N$，其分量 $y_j(t)$ 近似于 $x_j$ 处的解。该半离散常微分方程（ODE）组为\n$$\n\\frac{d y}{d t} = A y + g(y),\n$$\n其中扩散矩阵 $A \\in \\mathbb{R}^{N \\times N}$ 是具有齐次狄利克雷边界条件的标准离散拉普拉斯算子，\n$$\nA = \\frac{D}{\\left(\\Delta x\\right)^2} \\operatorname{tridiag}\\left(1, -2, 1\\right),\n$$\n其中 $D \\ge 0$ 为扩散系数，非线性反应项 $g: \\mathbb{R}^N \\to \\mathbb{R}^N$ 按分量作用，其形式为\n$$\n\\left[g(y)\\right]_j = \\lambda \\left(y_j - y_j^3\\right),\n$$\n其中 $\\lambda \\in \\mathbb{R}$ 为反应系数。初始条件为\n$$\ny_j(0) = \\sin\\!\\left(\\pi x_j\\right), \\quad j = 1,2,\\ldots,N.\n$$\n\n对于给定的最终时间 $T > 0$ 和时间步长 $h > 0$（使得 $M = T/h$ 为整数），定义时间网格 $t_n = n h$（$n = 0,1,\\ldots,M$）。考虑满足以下条件的唯一序列 $\\{y^n\\}_{n=0}^M \\subset \\mathbb{R}^N$：\n$$\n\\left(I - h A\\right) y^{n+1} = y^n + h\\, g\\!\\left(y^n\\right), \\quad n = 0,1,\\ldots,M-1,\n$$\n其中 $y^0$ 由初始条件给出。对于每个指定的参数集，计算终端状态 $y^M$ 的离散欧几里得范数（也称为 $L^2$ 范数），其定义为\n$$\n\\left\\|y^M\\right\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N \\left(y_j^M\\right)^2 }.\n$$\n\n本问题中的所有量均为无量纲，无需物理单位。\n\n测试套件。对于以下每个参数集 $(N, D, \\lambda, T, h)$，计算 $\\left\\|y^M\\right\\|_{2,\\Delta x}$ 的值：\n- 案例 $1$：$(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.001\\,)$。\n- 案例 $2$：$(N, D, \\lambda, T, h) = (\\,50,\\, 1.0,\\, 5.0,\\, 0.1,\\, 0.00005\\,)$。\n- 案例 $3$：$(N, D, \\lambda, T, h) = (\\,1,\\, 1.0,\\, 10.0,\\, 0.1,\\, 0.01\\,)$。\n- 案例 $4$：$(N, D, \\lambda, T, h) = (\\,50,\\, 0.0,\\, 5.0,\\, 0.1,\\, 0.01\\,)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含四个结果，每个结果对应一个案例，按上述顺序列出，四舍五入到8位小数，并以逗号分隔的列表形式用方括号括起来。例如，输出格式必须与以下完全一样：\n$$\n\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4\\right].\n$$", "solution": "问题陈述已经过评估，并被确定为有效。它具有科学依据、是适定的且客观的。它在偏微分方程数值分析领域提出了一个明确的计算任务，具体涉及半离散反应扩散系统的求解。该问题包括使用指定的数值格式模拟系统演化，并为几组参数集计算最终状态的范数。\n\n控制方程是一个形如 $\\frac{d y}{d t} = A y + g(y)$ 的常微分方程（ODE）组，它源于对一维反应扩散偏微分方程进行空间离散化（直线法）。项 $A y$ 代表扩散过程，其中 $A$ 是离散拉普拉斯矩阵；$g(y)$ 是一个 Allen-Cahn 类型的非线性反应项，$[g(y)]_j = \\lambda (y_j - y_j^3)$。此类系统是刚性微分方程的经典例子，因为与扩散相关的时间尺度（与 $A$ 的特征值有关）可能远快于反应的时间尺度。\n\n用于时间积分的指定数值方法是 $(I - h A) y^{n+1} = y^n + h\\, g(y^n)$。这是一种半隐式或隐式-显式（IMEX）格式。刚性线性扩散项 $A y$ 被隐式处理（使用后向欧拉法），而非线性且可能非刚性的反应项 $g(y)$ 被显式处理（使用前向欧拉法）。这种方法非常适用于刚性系统，因为对刚性部分进行隐式处理，可以允许比全显式方法更大的时间步长 $h$，而不会遇到数值不稳定性。该方法的稳定性由显式部分决定，它要求 $h$ 相对于反应项 $g(y)$ 的动力学要足够小。\n\n对于每个给定的参数集 $(N, D, \\lambda, T, h)$，求解算法按以下步骤进行。首先，我们建立计算网格和参数：空间点数 $N$、空间步长 $\\Delta x = \\frac{1}{N+1}$ 以及时间步数 $M = T/h$。初始状态向量 $y^0 \\in \\mathbb{R}^N$ 是根据初始条件 $y_j(0) = \\sin(\\pi x_j)$ 在网格点 $x_j = j \\Delta x$（$j=1, \\ldots, N$）上构建的。算法的核心是一个从 $n=0$ 到 $M-1$ 的时间步进循环。在每一步中，我们必须为下一个状态 $y^{n+1}$ 求解一个线性系统。该方程可重排为 $L y^{n+1} = b$，其中 $L = (I - hA)$ 是系统矩阵，$b = y^n + hg(y^n)$ 是根据当前状态 $y^n$ 计算出的右端向量。矩阵 $A = \\frac{D}{(\\Delta x)^2} \\operatorname{tridiag}(1, -2, 1)$ 是三对角的，这意味着矩阵 $L$ 也是三对角的，其主对角线元素为 $1 + \\frac{2hD}{(\\Delta x)^2}$，非对角线元素为 $-\\frac{hD}{(\\Delta x)^2}$。此类三对角系统可以使用专用算法高效求解；在我们的实现中，我们将使用 `scipy.linalg.solve_banded` 函数。这个循环执行 $M$ 次，将解从初始时间 $t=0$ 推进到最终时间 $t=T$。最后，在最后一个时间步之后，我们得到终端状态向量 $y^M$。所需的量，即离散欧几里得范数 $\\|y^M\\|_{2,\\Delta x}$，使用其定义 $\\|y^M\\|_{2,\\Delta x} = \\sqrt{ \\Delta x \\sum_{j=1}^N (y_j^M)^2 }$ 进行计算。对所有四个提供的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef compute_one_case(N, D, lambda_val, T, h):\n    \"\"\"\n    Solves the semidiscrete reaction-diffusion system for one set of parameters.\n\n    Args:\n        N (int): Number of interior spatial grid points.\n        D (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        T (float): Final time.\n        h (float): Time step size.\n\n    Returns:\n        float: The discrete Euclidean norm of the terminal state.\n    \"\"\"\n    # 1. Setup grid and parameters\n    dx = 1.0 / (N + 1)\n    # The problem statement guarantees M = T/h is an integer.\n    # Using round() guards against potential floating-point inaccuracies.\n    M = int(round(T / h))\n    x_grid = np.linspace(dx, 1.0 - dx, N)\n\n    # 2. Set initial condition y^0\n    y = np.sin(np.pi * x_grid)\n\n    # 3. Construct the time-stepping matrix L = (I - hA)\n    # The matrix A is D/dx^2 * tridiag(1, -2, 1).\n    # The matrix L is tridiagonal with diagonals:\n    # Main: 1 + 2*h*D/dx^2\n    # Off-diagonals: -h*D/dx^2\n    # This matrix is represented in the 'ab' banded format for scipy.linalg.solve_banded.\n    # The format requires a (3, N) array for a tridiagonal matrix.\n    \n    # Constant for off-diagonals\n    c = -h * D / (dx**2)\n    \n    # 'ab' matrix for solve_banded (l=1, u=1)\n    # Row 0: Super-diagonal (padded with one 0 at the start)\n    # Row 1: Main diagonal\n    # Row 2: Sub-diagonal (padded with one 0 at the end)\n    ab = np.zeros((3, N))\n    ab[0, 1:] = c\n    ab[1, :] = 1.0 - 2.0 * c \n    ab[2, :-1] = c\n    \n    # 4. Time-stepping loop\n    for _ in range(M):\n        # Calculate the right-hand side: y^n + h*g(y^n)\n        g_y = lambda_val * (y - y**3)\n        rhs = y + h * g_y\n        \n        # Solve the linear system (I - hA)y^{n+1} = rhs for y^{n+1}\n        y = solve_banded((1, 1), ab, rhs, check_finite=False)\n\n    # 5. Compute the final discrete L^2 norm\n    # norm = sqrt(dx * sum(y_j^M)^2)\n    final_norm = np.sqrt(dx * np.sum(y**2))\n    \n    return final_norm\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (50, 1.0, 5.0, 0.1, 0.001),     # Case 1\n        (50, 1.0, 5.0, 0.1, 0.00005),   # Case 2\n        (1, 1.0, 10.0, 0.1, 0.01),      # Case 3\n        (50, 0.0, 5.0, 0.1, 0.01),      # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        N, D, lambda_val, T, h = case\n        result = compute_one_case(N, D, lambda_val, T, h)\n        # Format the result to 8 decimal places as required.\n        results.append(f\"{result:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n\n```", "id": "2439136"}]}