{"hands_on_practices": [{"introduction": "理论学习之后，最好的巩固方式莫过于实践。让我们从一个在数值线性代数中至关重要的基本任务开始：验证一个向量是否为给定矩阵的特征向量。这项练习将帮助你把算法分解为基本步骤，并通过识别其中的主导操作来分析其时间复杂度，这是评估计算效率的一项核心技能 [@problem_id:2156952]。", "problem": "在开发一个数值线性代数库时，需要一个函数来验证特征向量算法的结果。该验证函数接收一个 $n \\times n$ 的实数方阵 $A$ 和一个非零的 $n$ 维实数列向量 $x$ 作为输入。该函数必须确定 $x$ 是否是 $A$ 的一个特征向量。对于大规模计算而言，算法性能的分析至关重要。\n\n你的任务是确定执行此验证的最有效算法的最坏情况时间复杂度。时间复杂度应使用大O表示法表示为矩阵维度 $n$ 的函数。假设基本算术运算（加、减、乘、除）和比较操作都花费常数时间，即 $O(1)$。\n\n这个验证过程的最紧凑的大O时间复杂度是多少？\n\nA. $O(n)$\n\nB. $O(n \\log n)$\n\nC. $O(n^2)$\n\nD. $O(n^3)$\n\nE. $O(n!)$", "solution": "我们必须验证给定的非零向量 $x \\in \\mathbb{R}^{n}$ 是否是给定矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 的一个特征向量。根据定义，$x$ 是 $A$ 的一个特征向量，当且仅当存在一个标量 $\\lambda \\in \\mathbb{R}$ 使得\n$$\nA x = \\lambda x,\n$$\n其中给定 $x \\neq 0$。\n\n一个高效的验证算法按以下步骤进行。\n\n1) 计算矩阵-向量乘积 $y = A x$。对于每个 $i \\in \\{1,\\dots,n\\}$，\n$$\ny_{i} = \\sum_{j=1}^{n} a_{ij} x_{j}.\n$$\n这需要每行进行 $n$ 次乘法和 $n-1$ 次加法，因此总共有 $\\Theta(n^{2})$ 次算术运算。在每次算术运算为 $O(1)$ 的假设下，此步骤的成本为 $O(n^{2})$。\n\n2) 确定一个候选特征值 $\\lambda$。找到一个索引 $k$ 使得 $x_{k} \\neq 0$（因为 $x \\neq 0$，所以这样的索引必然存在）。在最坏情况下，这个搜索的成本为 $O(n)$。定义\n$$\n\\lambda = \\frac{y_{k}}{x_{k}},\n$$\n一旦找到 $k$，这需要 $O(1)$ 的时间。\n\n3) 逐分量验证等式 $y = \\lambda x$。对于每个 $j \\in \\{1,\\dots,n\\}$：\n- 如果 $x_{j} \\neq 0$，检查是否 $y_{j} = \\lambda x_{j}$。\n- 如果 $x_{j} = 0$，检查是否 $y_{j} = 0$。\n此步骤使用 $O(n)$ 次比较和至多 $O(n)$ 次乘法。\n\n因此，该算法的总运行时间为\n$$\nO(n^{2}) + O(n) + O(n) = O(n^{2}),\n$$\n主要由矩阵-向量乘法决定。\n\n为了说明在最坏情况下没有算法能渐进地做得更好，我们考虑一个下界论证。假设 $x$ 没有零元素。任何检查少于 $A$ 的全部 $n^{2}$ 个元素的算法，都会留下至少一个元素 $a_{pq}$ 未被检查。构造两个矩阵 $A$ 和 $A'$，它们在所有已检查的元素上都相同，仅在 $a_{pq}$ 上相差一个非零值 $\\delta \\neq 0$。那么\n$$\n(A' x)_{p} = (A x)_{p} + \\delta x_{q},\n$$\n由于 $x_{q} \\neq 0$，这将使第 $p$ 个分量改变一个非零量。通过适当地选择 $\\delta$，矩阵 $A$ 或 $A'$ 中的一个可以满足 $A x = \\lambda x$（对于某个 $\\lambda$），而另一个则不能。一个没有检查 $a_{pq}$ 的算法无法区分这两种情况，因此任何正确的算法在最坏情况下都必须检查 $\\Omega(n^{2})$ 个元素，这意味着时间下界为 $\\Omega(n^{2})$。\n\n结合 $O(n^{2})$ 的上界和 $\\Omega(n^{2})$ 的下界，我们得到了一个紧确的 $\\Theta(n^{2})$ 界。在大O表示法中，选项中最紧确的选择是 $O(n^{2})$，对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "2156952"}, {"introduction": "在许多科学计算应用中，我们处理的矩阵绝大多数元素都为零，这类矩阵被称为稀疏矩阵。基于上一个练习，这个实践将引导你思考数据结构如何影响算法效率，特别是如何利用数据的稀疏性来大幅降低计算复杂度 [@problem_id:2156941]。通过分析稀疏矩阵与向量的乘法，你将体会到算法与数据结构在真实世界性能优化中的紧密联系。", "problem": "在计算科学领域，许多问题涉及其中矩阵为稀疏矩阵的线性系统。如果一个矩阵的非零元素数量远小于其元素总数，则该矩阵被认为是稀疏的。为了提高性能并减少内存使用，会使用专门的数据结构和算法来处理这些矩阵。\n\n考虑一个 $n \\times n$ 的稀疏矩阵 $A$，它恰好包含 $k$ 个非零元素，其中 $k \\ll n^2$。矩阵 $A$ 使用坐标列表（COO）表示法进行存储。这种格式使用三个长度为 $k$ 的列表：一个用于存储非零元素的值，一个用于存储它们对应的行索引，另一个用于存储它们对应的列索引。\n\n你的任务是分析一个计算乘积 $y = Ax$ 的算法的时间复杂度，其中 $x$ 是一个大小为 $n$ 的稠密列向量（即，它有 $n$ 个元素，所有元素都可能为非零）。\n\n该算法的执行过程如下：\n1.  创建一个大小为 $n$ 的输出向量 $y$，并将其所有元素初始化为零。\n2.  算法接着使用COO列表对 $A$ 的 $k$ 个非零元素进行一次遍历。对于每个在行索引 $i$ 和列索引 $j$ 处值为 $v$ 的非零元素，它执行更新操作：$y_i \\leftarrow y_i + v \\cdot x_j$。\n\n该算法的最坏情况时间复杂度用大O表示法表示是什么？\n\nA. $O(n)$\n\nB. $O(k)$\n\nC. $O(n+k)$\n\nD. $O(nk)$\n\nE. $O(n^2)$\n\nF. $O(k \\log n)$", "solution": "设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个恰好有 $k$ 个非零项并以COO格式存储的矩阵，且设 $x \\in \\mathbb{R}^{n}$ 是一个稠密向量。该算法计算 $y = Ax$ 的过程如下。\n\n步骤1（初始化）：创建 $y \\in \\mathbb{R}^{n}$ 并将所有项设置为零。设置每一项都是一个常数时间操作。设每次写入的常数成本为 $c_{1}$。那么此步骤的时间为\n$$\nT_{1}(n) = c_{1} n,\n$$\n即 $\\Theta(n)$，因此是 $O(n)$。\n\n步骤2（对非零项的单次遍历）：对 $A$ 的 $k$ 个非零项进行一次遍历。对于每个非零项 $(v,i,j)$，执行更新操作 $y_{i} \\leftarrow y_{i} + v \\cdot x_{j}$。在标准RAM模型下，访问 $x_{j}$、乘以 $v$ 以及加到 $y_{i}$ 上都是常数时间操作。设每个非零项的常数成本为 $c_{2}$。那么此步骤的时间为\n$$\nT_{2}(k) = c_{2} k,\n$$\n即 $\\Theta(k)$，因此是 $O(k)$。\n\n总时间：总运行时间是两个独立步骤之和，\n$$\nT(n,k) = T_{1}(n) + T_{2}(k) = c_{1} n + c_{2} k.\n$$\n用大O表示法表示为\n$$\nT(n,k) \\in O(n + k).\n$$\n因此，最坏情况时间复杂度是 $O(n + k)$，这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "2156941"}, {"introduction": "现在，让我们将目光从迭代算法转向一种功能强大的范式：递归。许多高效的算法，如归并排序，通过将问题分解为更小的、与原问题结构相同的子问题来求解，即“分而治之”。这项练习将带你分析一个典型的分治算法，学习如何建立并求解其时间复杂度的递推关系，这是理解许多高级算法性能的关键 [@problem_id:2156959]。", "problem": "一位软件工程师正在设计一种名为'LogSynthesizer'的新算法，用于处理和整合服务器日志文件。该算法作用于一个包含 $n$ 个条目的日志文件。\n\n'LogSynthesizer'算法的设计如下：\n1. 如果日志文件只有一个条目（即，$n=1$），算法执行常数次操作后终止。\n2. 如果日志文件有多个条目，算法执行以下三个步骤：\n    a. 它将日志文件分成相等的两半，每半包含 $n/2$ 个条目。\n    b. 它对这两半中的每一半独立地递归调用自身。\n    c. 在两次递归调用返回后，它合并它们处理后的结果。这个合并步骤需要对所有原始的 $n$ 个条目进行单次遍历以确保一致性，并且这次遍历花费的总时间与 $n$ 成正比。\n\n设 $T(n)$ 是'LogSynthesizer'算法处理大小为 $n$ 的日志文件所需的总操作次数的函数。根据描述，确定该算法时间复杂度的最紧渐近上界（大O表示法）。\n\n从以下选项中选择正确的选项：\n\nA. $O(\\log n)$\n\nB. $O(n)$\n\nC. $O(n \\log n)$\n\nD. $O(n^2)$\n\nE. $O(2^n)$", "solution": "设 $T(n)$ 表示总操作次数。根据算法描述：\n- 基本情况：$T(1)=\\Theta(1)$。\n- 对于 $n1$，算法分解为两个大小为 $n/2$ 的子问题，递归地解决它们，并在线性时间内合并结果。因此存在一个常数 $c0$ 使得\n$$\nT(n)=2\\,T\\!\\left(\\frac{n}{2}\\right)+c\\,n.\n$$\n\n使用递归树方法，为简单起见，假设 $n=2^{h}$，这样树的高度为 $h=\\log_{2}(n)$。在第 $i$ 层（$0 \\leq i \\leq h-1$），有 $2^{i}$ 个大小为 $n/2^{i}$ 的子问题。第 $i$ 层的总合并成本是\n$$\n2^{i}\\cdot c\\left(\\frac{n}{2^{i}}\\right)=c\\,n.\n$$\n由于在到达叶节点之前有 $h=\\log_{2}(n)$ 个这样的层级，所有非叶节点的总成本是\n$$\nc\\,n\\,\\log_{2}(n).\n$$\n在叶节点处，有 $2^{h}=n$ 个大小为 1 的子问题，每个成本为 $\\Theta(1)$，所以总的叶节点成本是 $\\Theta(n)$。\n\n因此，\n$$\nT(n)=\\Theta\\!\\left(n\\log_{2}(n)\\right)+\\Theta(n)=\\Theta\\!\\left(n\\log_{2}(n)\\right).\n$$\n等价地，在对数底数相差一个常数因子的情况下，$T(n)=\\Theta\\!\\left(n\\log(n)\\right)$。因此最紧的渐近上界是 $O(n\\log n)$，这对应于选项 C。\n\n根据主定理，当 $a=2$、$b=2$ 且 $f(n)=c\\,n$ 时，我们有 $n^{\\log_{b}a}=n$ 且 $f(n)=\\Theta\\!\\left(n^{\\log_{b}a}\\right)$，这属于主定理的情况2，并得出相同的结果 $T(n)=\\Theta\\!\\left(n\\log n\\right)$。", "answer": "$$\\boxed{C}$$", "id": "2156959"}]}