{"hands_on_practices": [{"introduction": "灾难性相消最直接的体现，就是两个几乎相等的数相减。这个练习模拟了二分法算法中的一个常见情景，通过计算一个极窄区间的宽度，你将亲手量化有限精度运算如何导致巨大的相对误差。这个简单的例子直观地揭示了灾难性相消的根本原因及其影响。[@problem_id:2158264]", "problem": "在计算科学领域，理解浮点运算的局限性对于编写稳健的数值算法至关重要。假设有一台计算机，它使用一种规格化的十进制浮点格式来表示所有数字，该格式存储一个恰好有7位有效十进制数字的尾数。当一个超过7位有效数字的数被存储时，它会被舍入到最接近的可表示数。舍入规则如下：如果要舍弃的第一位数字大于或等于5，则保留的最后一位数字向上舍入；否则，保持不变。\n\n一名学生正在实现用二分法来寻找一个函数的根。在最后的一次迭代中，搜索区间被缩小到 $[a, b]$，其中精确的理论值为 $a = 9876.5432$ 和 $b = 9876.5441$。在进行任何计算之前，机器首先将 $a$ 和 $b$ 的值以其7位浮点格式存储。然后，它使用这些存储的近似值来计算区间宽度 $w = b - a$。\n\n你的任务是确定这种有限精度运算的影响。计算计算宽度相对于真实宽度的相对误差。相对误差定义为 $\\frac{|\\text{computed value} - \\text{true value}|}{|\\text{true value}|}$。将你的最终答案表示为保留三位有效数字的小数。", "solution": "机器以恰好7位有效十进制数字存储数字，并遵循舍入到最近的规则：如果要舍弃的第一位有效数字大于或等于5，则保留的最后一位数字向上舍入；否则，保持不变。\n\n对于 $a=9876.5432$，我们需要将其舍入到7位有效数字。第7位是 $3$，要舍弃的第8位是 $2$。因为 $2  5$，所以向下舍入（即截断）。存储的值为：\n$$\n\\hat{a}=9876.543\n$$\n对于 $b=9876.5441$，我们需要将其舍入到7位有效数字。第7位是 $4$，要舍弃的第8位是 $1$。因为 $1  5$，所以向下舍入。存储的值为：\n$$\n\\hat{b}=9876.544\n$$\n使用存储值计算的宽度为：\n$$\nw_{\\text{comp}}=\\hat{b}-\\hat{a}=9876.544-9876.543=0.001\n$$\n真实宽度为：\n$$\nw_{\\text{true}}=b-a=9876.5441-9876.5432=0.0009\n$$\n相对误差为：\n$$\n\\frac{|w_{\\text{comp}}-w_{\\text{true}}|}{|w_{\\text{true}}|}=\\frac{|0.001-0.0009|}{0.0009}=\\frac{0.0001}{0.0009}=\\frac{1}{9}\n$$\n以小数形式表示并保留三位有效数字，结果是 $0.111$。", "answer": "$$\\boxed{0.111}$$", "id": "2158264"}, {"introduction": "识别问题后，下一步是解决它。这个练习展示了一种最强大的应对策略：代数重构。通过在一个模拟的数字信号处理器上比较两个在数学上完全等价的公式，你将看到它们如何产生截然不同的计算结果。这突显了在编码前分析表达式并选择数值稳定形式的重要性。[@problem_id:2158282]", "problem": "一个假设的数字信号处理器（DSP）被设计用于处理浮点数，其尾数限制为恰好6位有效十进制数字。在该系统中，每次基本算术运算（加法、减法、乘法、除法）之后，结果会立即被归一化并舍入到6位有效数字。对于舍入，该系统采用标准的“半上舍入”规则（如果第一个被舍弃的数字大于或等于5，则最后一个保留的数字向上舍入）。\n\n一位工程师需要为一个非常小的输入信号 $x$ 计算一个值 $y$。有两个数学上等价的公式可用：\n\n公式 A：$y_A(x) = \\frac{1}{1-x} - \\frac{1}{1+x}$\n公式 B：$y_B(x) = \\frac{2x}{1-x^2}$\n\n该工程师使用 DSP 计算输入信号为 $x = 7.50000 \\times 10^{-4}$ 时的值。\n\n计算使用这两个公式由 DSP 计算出的值之间的绝对差 $|y_A(x) - y_B(x)|$。将你的最终答案舍入到三位有效数字。", "solution": "DSP 使用恰好6位有效十进制数字的尾数，并在每次基本运算后使用“半上舍入”规则进行舍入。给定的输入是 $x = 7.50000 \\times 10^{-4} = 0.00075$（在该系统中是精确值）。\n\n**计算公式 A：$y_{A}(x) = \\frac{1}{1-x} - \\frac{1}{1+x}$**\n每次运算后都进行舍入：\n- 计算 $1 - x$：精确值为 $1 - 0.00075 = 0.99925$。舍入到6位有效数字得到 $0.999250$。\n- 计算 $1 + x$：精确值为 $1 + 0.00075 = 1.00075$。它已经有6位有效数字。\n- 计算倒数并舍入：\n  - $\\frac{1}{0.999250} = 1.00075056\\dots$ 舍入到6位有效数字为 $1.00075$ (因为第7位是0)。\n  - $\\frac{1}{1.00075} = 0.99925056\\dots$ 舍入到6位有效数字为 $0.999251$ (因为第7位是5，向上舍入)。\n- 相减并舍入：$y_{A} = 1.00075 - 0.999251 = 0.001499$。保留6位有效数字后仍为 $1.49900 \\times 10^{-3}$。\n\n**计算公式 B：$y_{B}(x) = \\frac{2x}{1 - x^{2}}$**\n每次运算后都进行舍入：\n- 相乘：$2x = 2 \\times 0.00075 = 0.0015$。舍入到6位有效数字为 $1.50000 \\times 10^{-3}$。\n- 平方：$x^{2} = (0.00075)^{2} = 5.625 \\times 10^{-7}$。舍入到6位有效数字为 $5.62500 \\times 10^{-7}$。\n- 相减：$1 - x^{2} = 1 - 0.0000005625 = 0.9999994375$。舍入到6位有效数字为 $0.999999$ (因为第7位是4)。\n- 相除并舍入：$y_{B} = \\frac{0.00150000}{0.999999} = 0.0015000015\\dots$ 舍入到6位有效数字为 $0.00150000$ (因为第7位是1)，即 $1.50000 \\times 10^{-3}$。\n\n因此，DSP计算出的值是 $y_{A} = 0.001499$ 和 $y_{B} = 0.00150000$。绝对差为：\n$$|y_{A} - y_{B}| = |0.001499 - 0.00150000| = |-0.000001| = 1.00 \\times 10^{-6}$$\n舍入到三位有效数字，结果是 $1.00 \\times 10^{-6}$。", "answer": "$$\\boxed{1.00 \\times 10^{-6}}$$", "id": "2158282"}, {"introduction": "最后的练习将我们的知识应用到一个无处不在的经典问题上：求解二次方程。标准求根公式在特定条件下极易发生灾难性相消。这个练习要求你不仅要识别不稳定的情况，还要运用韦达定理 (Vieta's formulas) ——一种利用多项式根与系数关系的强大技巧——来实现一个数值稳健的替代算法。[@problem_id:2389875]", "problem": "设计并实现一个程序，用于定量模拟当 $b^2 \\gg 4ac$ 时，计算二次方程 $a x^2 + b x + c = 0$ 根的数值不稳定性。您的程序必须将二次公式的直接、朴素计算与从基本原理推导出的数值稳定计算进行比较，并且必须使用高精度参考值来测量前向相对误差。\n\n基本基础和建模假设：\n- 对基本运算使用标准浮点舍入模型，即浮点算术中的每个基本算术运算都满足 $\\operatorname{fl}(x \\circ y) = (x \\circ y)(1 + \\delta)$，其中 $|\\delta| \\le \\varepsilon$，$\\varepsilon$ 是机器ε，$\\circ$ 表示 $+$、$-$、$\\times$ 或 $\\div$。\n- 认识到减去两个几乎相等的浮点数可能会损失有效数字（灾难性相消），尤其是在 $b^2 \\gg 4ac$ 时计算 $-b + \\sqrt{b^2 - 4ac}$。\n- 使用多项式系数和根之间的关系（韦达定理）作为经过充分检验的事实：如果 $x_1$ 和 $x_2$ 是方程的根，则 $x_1 + x_2 = -b/a$ 和 $x_1 x_2 = c/a$。\n\n程序要求：\n1. 实现两种双精度计算根的方法：\n   - 一种朴素方法，在标准双精度下直接通过二次公式 $x = (-b \\pm \\sqrt{b^2 - 4ac})/(2a)$ 计算两个根。\n   - 一种数值稳定的方法，通过基于基本原理和系数与根之间关系的代数重排来避免减去几乎相等的量。您必须确保该实现能为在 $b^2 \\gg 4ac$ 时本会不稳定的那个根最小化抵消误差。\n2. 实现一个高精度的根的参考计算，使用至少 $p=80$ 位十进制数字的基-10任意精度来近似真实值。使用此参考来评估前向误差。\n3. 对于下面的每个测试用例，以高精度计算两个参考根 $x_{\\text{true},1}$ 和 $x_{\\text{true},2}$，并按它们的大小（模）将它们标记为“小”根 $x_{\\text{true},s}$（$|x|$ 较小的那个）和“大”根 $x_{\\text{true},L}$（$|x|$ 较大的那个）。对于每种方法（朴素和稳定），也将其计算出的两个根按大小标记为“小”和“大”，以按尺度对齐比较。\n4. 对于一个计算出的根 $\\hat{x}$ 和一个参考根 $x_{\\text{true}}$，将前向相对误差定义为 $E = |\\hat{x} - x_{\\text{true}}|/|x_{\\text{true}}|$（当 $x_{\\text{true}} \\ne 0$ 时），以及 $E = |\\hat{x}|$（当 $x_{\\text{true}} = 0$ 时）。\n5. 对于每个测试用例，生成一个包含四个浮点数的列表，顺序为 $[E_{\\text{naive},s}, E_{\\text{naive},L}, E_{\\text{stable},s}, E_{\\text{stable},L}]$。\n\n测试套件：\n使用以下五个测试用例，每个指定为 $(a,b,c)$：\n- $(1, 10^8, 1)$\n- $(1, -10^8, 1)$\n- $(1, 3, 1)$\n- $(1, 10^{16}, 1)$\n- $(10^{-8}, 1, 10^{-16})$\n\n最终输出格式：\n- 您的程序应生成单行输出，包含一个无空格的Python风格的列表的列表，每个内部列表对应一个测试用例，顺序与上面列出的一致。每个浮点数必须以科学记数法格式化，小数点后有十二位数字。例如，一行如 `[[1.234000000000e-12,5.678000000000e+03,...],...]`。\n- 对于每个测试用例，输出元素的顺序必须严格为 $[E_{\\text{naive},s}, E_{\\text{naive},L}, E_{\\text{stable},s}, E_{\\text{stable},L}]$。", "solution": "所述问题是有效的。这是一个在计算物理学中表述清晰、有科学依据的问题，它探讨了数值稳定性、灾难性相消和误差传播等基本概念。所有必要的数据、模型和定义都已提供，问题没有事实错误、歧义或矛盾。我们将提供一个完整的解决方案。\n\n问题的核心是解二次方程 $a x^2 + b x + c = 0$ 并分析其解的数值稳定性。根的标准公式是：\n\n$$\nx_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}\n$$\n\n我们将分析这个公式的行为并推导一个更稳定的替代方案。\n\n**1. 朴素方法中的数值不稳定性分析**\n\n朴素方法直接用上述公式计算两个根。在 $b^2 \\gg 4ac$ 的条件下会出现不稳定性。在这种情况下，判别式 $\\Delta = b^2 - 4ac$ 非常接近 $b^2$，因此 $\\sqrt{\\Delta}$ 非常接近 $|b|$。\n\n我们来分析分子 $-b \\pm \\sqrt{\\Delta}$。浮点误差模型指出，一次运算的结果是真实结果乘以 $(1+\\delta)$，其中 $|\\delta| \\le \\varepsilon$（机器ε）。当我们减去两个几乎相等的数时，结果的相对误差可能会非常大。这种现象被称为灾难性相消。\n\n考虑项 $\\sqrt{b^2 - 4ac}$。对于小的 $z = \\frac{4ac}{b^2}$，使用二项式或泰勒展开：\n$$\n\\sqrt{b^2 - 4ac} = |b|\\sqrt{1 - \\frac{4ac}{b^2}} = |b|\\left(1 - \\frac{1}{2}\\frac{4ac}{b^2} - \\frac{1}{8}\\left(\\frac{4ac}{b^2}\\right)^2 - \\dots\\right) \\approx |b|\\left(1 - \\frac{2ac}{b^2}\\right)\n$$\n其中一个根的计算将涉及从 $-b$ 中减去 $\\sqrt{\\Delta}$（或反之）。\n- 如果 $b > 0$，则 $|b|=b$。根 $x_1 = (-b + \\sqrt{b^2-4ac})/(2a)$ 涉及减法：\n$$\n-b + \\sqrt{b^2-4ac} \\approx -b + b\\left(1 - \\frac{2ac}{b^2}\\right) = -b + b - \\frac{2ac}{b} = -\\frac{2ac}{b}\n$$\n这个操作是 $-b + (\\approx b)$，是两个几乎相等的数相减，导致有效数字的损失。这个根是模较小的那个。另一个根 $x_2 = (-b - \\sqrt{b^2-4ac})/(2a)$ 涉及两个大的负数相加，这在数值上是稳定的。这个根是模较大的那个。\n\n- 如果 $b  0$，则 $|b|=-b$。根 $x_2 = (-b - \\sqrt{b^2-4ac})/(2a)$ 是不稳定的，因为 $-b > 0$ 且 $\\sqrt{b^2-4ac} \\approx \\sqrt{b^2} = |b| = -b$。这个操作是 $(\\approx -b) - (-b)$。稳定的根是 $x_1 = (-b + \\sqrt{b^2-4ac})/(2a)$，它涉及两个大的正数相加。\n\n总的来说，不稳定的计算是对于涉及 $-b + \\operatorname{sgn}(b)\\sqrt{\\Delta}$ 的根，这对应于绝对值较小的根。稳定的计算是对于涉及 $-b - \\operatorname{sgn}(b)\\sqrt{\\Delta}$ 的根，这是绝对值较大的根。\n\n**2. 数值稳定方法的推导**\n\n为了避免灾难性相消，必须设计一个稳定的算法。策略是：\na. 使用数值稳定版本的二次公式计算模较大的根，我们记为 $\\hat{x}_L$：\n$$\n\\hat{x}_L = \\frac{-b - \\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}}{2a}\n$$\n这里，项 $\\operatorname{sgn}(b)\\sqrt{b^2 - 4ac}$ 与 $b$ 有相同的符号，所以 $-b$ 和 $-\\operatorname{sgn}(b)\\sqrt{b^2-4ac}$ 有相同的符号。因此它们的和在数值上是稳定的。\n\nb. 为了找到第二个根（模较小的那个，$\\hat{x}_s$），我们使用韦达定理，它将根 $x_1, x_2$ 与多项式的系数联系起来：\n$$\nx_1 + x_2 = -\\frac{b}{a} \\quad \\text{和} \\quad x_1 x_2 = \\frac{c}{a}\n$$\n利用乘积关系，我们可以从大根计算出小根：\n$$\n\\hat{x}_s = \\frac{c/a}{\\hat{x}_L} = \\frac{c}{a\\hat{x}_L}\n$$\n这个计算是稳定的，因为 $\\hat{x}_L$ 已经被精确计算，并且作为模较大的根，它不接近于零。试图使用求和关系 $\\hat{x}_s = -b/a - \\hat{x}_L$ 是一个错误，因为它会重新引入灾难性相消，因为 $\\hat{x}_L \\approx -b/a$。\n\n**3. 实现和误差分析**\n\n程序将为每个测试用例 $(a, b, c)$ 实现三种求根过程：\n\n- **参考计算：** 使用标准二次公式计算根 $x_{\\text{true},1}$ 和 $x_{\\text{true},2}$，但采用任意精度算术。使用 $p = 85$ 个十进制数字的精度，以确保这些值可以作为可靠的基准真相。得到的根按其绝对值排序，以确定“小”真根 $x_{\\text{true},s}$ 和“大”真根 $x_{\\text{true},L}$。\n\n- **朴素计算：** 使用标准二次公式在双精度浮点算术中计算根 $\\hat{x}_{\\text{naive},1}$ 和 $\\hat{x}_{\\text{naive},2}$。然后按模排序，得到 $\\hat{x}_{\\text{naive},s}$ 和 $\\hat{x}_{\\text{naive},L}$。\n\n- **稳定计算：** 使用上面推导的稳定算法在双精度下计算根。首先计算大根 $\\hat{x}_{\\text{stable},L}$，然后使用韦达定理找到小根 $\\hat{x}_{\\text{stable},s}$。此方法内在地按模大小分离生成了根。\n\n最后，对于每种方法（朴素和稳定）和每种根类型（小和大），相对于高精度参考值计算前向相对误差。对于计算出的根 $\\hat{x}$ 和真根 $x_{\\text{true}}$，误差 $E$ 由以下公式给出：\n$$\nE = \\frac{|\\hat{x} - x_{\\text{true}}|}{|x_{\\text{true}}|} \\quad (\\text{对于 } x_{\\text{true}} \\neq 0)\n$$\n计算 $|\\hat{x} - x_{\\text{true}}|$ 时使用高精度，以避免在比较过程中因真值损失精度。最终程序遍历测试套件，为每种情况计算所需的四个误差值，并按规定格式化输出。", "answer": "```python\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical stability of naive and stable algorithms\n    for solving the quadratic equation ax^2 + bx + c = 0, particularly when b^2  4ac.\n    \"\"\"\n    # Set precision for high-precision reference calculations.\n    # p=80 decimal digits is required, 85 is used for safety.\n    decimal.getcontext().prec = 85\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1.0, 1.0e8, 1.0),\n        (1.0, -1.0e8, 1.0),\n        (1.0, 3.0, 1.0),\n        (1.0, 1.0e16, 1.0),\n        (1.0e-8, 1.0, 1.0e-16),\n    ]\n\n    all_case_results = []\n\n    def compute_relative_error(computed_val, true_val_hp):\n        \"\"\"\n        Calculates the forward relative error using a high-precision true value.\n        E = |computed - true| / |true|\n        \"\"\"\n        if true_val_hp == 0:\n            return abs(computed_val)\n        \n        # Promote the computed float to Decimal for accurate error calculation\n        error = abs(decimal.Decimal(computed_val) - true_val_hp) / abs(true_val_hp)\n        return float(error)\n\n    for a, b, c in test_cases:\n        # --- 1. High-Precision Reference Calculation ---\n        a_hp = decimal.Decimal(a)\n        b_hp = decimal.Decimal(b)\n        c_hp = decimal.Decimal(c)\n\n        delta_hp = (b_hp**2 - 4 * a_hp * c_hp).sqrt()\n        x_true1 = (-b_hp + delta_hp) / (2 * a_hp)\n        x_true2 = (-b_hp - delta_hp) / (2 * a_hp)\n\n        # Label true roots by magnitude: small (s) and large (L)\n        if abs(x_true1)  abs(x_true2):\n            x_true_s, x_true_L = x_true1, x_true2\n        else:\n            x_true_s, x_true_L = x_true2, x_true1\n\n        # --- 2. Naive Double-Precision Calculation ---\n        a_dp, b_dp, c_dp = a, b, c\n        \n        # Handle potential negative discriminant for real roots\n        discriminant_val = b_dp**2 - 4 * a_dp * c_dp\n        if discriminant_val  0:\n            # Although problem context implies real roots, this is robust\n            discriminant_val = 0\n            \n        delta_dp = np.sqrt(discriminant_val)\n        \n        x_naive1 = (-b_dp + delta_dp) / (2 * a_dp)\n        x_naive2 = (-b_dp - delta_dp) / (2 * a_dp)\n        \n        # Label naive roots by magnitude\n        if abs(x_naive1)  abs(x_naive2):\n            x_naive_s, x_naive_L = x_naive1, x_naive2\n        else:\n            x_naive_s, x_naive_L = x_naive2, x_naive1\n\n        # --- 3. Stable Double-Precision Calculation ---\n        # The sign of b is used to determine the stable formula for the large root.\n        # np.copysign is used to handle b=0 robustly.\n        sign_b = np.copysign(1.0, b_dp if b_dp != 0 else 1.0)\n        \n        # Calculate the large root first, avoiding cancellation\n        x_stable_L = (-b_dp - sign_b * delta_dp) / (2 * a_dp)\n        \n        # Calculate the small root using Vieta's formula\n        x_stable_s = (c_dp / a_dp) / x_stable_L\n\n        # --- 4. Compute Forward Relative Errors ---\n        E_naive_s = compute_relative_error(x_naive_s, x_true_s)\n        E_naive_L = compute_relative_error(x_naive_L, x_true_L)\n        \n        E_stable_s = compute_relative_error(x_stable_s, x_true_s)\n        E_stable_L = compute_relative_error(x_stable_L, x_true_L)\n\n        case_errors = [E_naive_s, E_naive_L, E_stable_s, E_stable_L]\n        all_case_results.append(case_errors)\n\n    # --- 5. Format and Print Final Output ---\n    output_parts = []\n    for errors in all_case_results:\n        formatted_errors = [f\"{e:.12e}\" for e in errors]\n        output_parts.append(f\"[{','.join(formatted_errors)}]\")\n    \n    final_output_string = f\"[{','.join(output_parts)}]\"\n    print(final_output_string)\n\nsolve()\n```", "id": "2389875"}]}