{"hands_on_practices": [{"introduction": "我们将从一个许多程序员都曾遇到过的陷阱开始：一个看似简单的循环却未能如期终止。这个练习将揭示我们在代码中写的数字与计算机实际存储它们的方式之间的根本区别，并引出表示错误（representation error）这一关键概念。通过这个实践 [@problem_id:2447428]，你将亲身体会到为什么对浮点数进行直接的相等性比较是危险的。", "problem": "给定实数标量 $s$、$h$ 和 $t$，以及一个正整数 $M$。考虑由 $x_0 = s$ 和 $x_{n+1} = x_n + h$（对于 $n \\ge 0$）定义的序列 $\\{x_n\\}_{n\\ge 0}$。当 $x_n$ 在二进制浮点运算中计算时，由于表示和舍入效应，一个检查 $x_n = t$ 是否成立的简单终止条件可能是不可靠的。您的任务是编写一个程序，为每个提供的测试用例模拟浮点序列，并报告在有界数量的模拟迭代内，$x_n = t$ 的等式是否曾经成立。\n\n对于每个测试用例，请执行以下步骤：\n1. 在双精度浮点运算中初始化 $x_0 = s$。\n2. 对于 $n = 0,1,2,\\dots$，在浮点运算中精确检查 $x_n = t$ 是否成立。如果对于某个 $n \\le M$，等式成立，记录满足条件的最小 $n$，并终止该测试用例的模拟。\n3. 如果在 $0 \\le n \\le M$ 的范围内没有出现相等的情况，则在 $M$ 次增量后终止模拟。\n4. 令 $n_{\\mathrm{exec}}$ 表示您的模拟对该测试用例实际执行的增量次数，其中 $n_{\\mathrm{exec}}$ 等于观察到相等的最小 $n$（如果存在），否则为 $M$。\n5. 使用精确实数运算计算理论精确值 $x_{\\mathrm{exact}} = s + n_{\\mathrm{exec}}\\,h$，在中间步骤不使用浮点舍入。\n6. 令 $x_{\\mathrm{float}}$ 表示您的模拟在 $n_{\\mathrm{exec}}$ 次增量后获得的浮点值。计算绝对误差 $e = |x_{\\mathrm{float}} - x_{\\mathrm{exact}}|$，结果为一个实数。\n\n对于每个测试用例，您的程序必须按顺序输出一个包含以下字段的列表：\n- 一个布尔值，指示是否存在 $n \\in \\{0,1,\\dots,M\\}$ 使得在浮点运算中 $x_n = t$。\n- 如果存在，则为满足条件的最小 $n$；否则为整数 $-1$。\n- 整数 $n_{\\mathrm{exec}}$。\n- 经过 $n_{\\mathrm{exec}}$ 次增量后的浮点值 $x_{\\mathrm{float}}$。\n- 为便于报告而转换为浮点数的理论精确值 $x_{\\mathrm{exact}}$。\n- 作为浮点数的绝对误差 $e$。\n\n使用以下五个测试用例。在所有测试用例中，不涉及角度，也没有物理单位。以十进制书写的实数（如 $0.1$）表示以十为基数的精确实数值，而涉及2的幂的表达式（如 $2^{-55}$）表示精确实数值。\n\n- 测试用例 1（使用十进制步长的典型相等性判断失败）：\n  $s = 0.0$, $h = 0.1$, $t = 1.0$, $M = 12$。\n- 测试用例 2（精确可表示的步长和可达的目标）：\n  $s = 0.0$, $h = 0.125$, $t = 1.0$, $M = 8$。\n- 测试用例 3（步长不能整除区间）：\n  $s = 0.0$, $h = 0.3$, $t = 1.0$, $M = 10$。\n- 测试用例 4（使用十进制步长向零的负步长）：\n  $s = 1.0$, $h = -0.1$, $t = 0.0$, $M = 12$。\n- 测试用例 5（增量小于一个最低有效位直到累积）：\n  $s = 1.0$, $h = 2^{-55}$, $t = 1 + 2^{-52}$, $M = 8$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是对应一个测试用例的列表，顺序与上述相同。例如，输出必须采用\n$[r_1,r_2,r_3,r_4,r_5]$\n的形式，其中每个 $r_i$ 是对应于测试用例 $i$ 的列表，并且该行中不得有任何空格。每个列表 $r_i$ 的形式必须为\n$[\\text{hit}, n_{\\min}, n_{\\mathrm{exec}}, x_{\\mathrm{float}}, x_{\\mathrm{exact}}, e]$\n，字段类型如上定义。此行上的所有数字输出都必须表示为以十为基数的浮点数或整数。", "solution": "问题陈述已经过严格验证，并被确定为有效。它在科学上基于数值计算的原理，提法恰当，过程清晰且确定，并且表述客观。它提出了一个计算工程中关于浮点运算局限性的标准但基础的问题。我们现在开始给出解决方案。\n\n这个问题的核心在于精确实数运算与基于计算机的浮点运算之间的根本区别，后者遵循 IEEE 754 双精度数标准。在模拟序列 $x_{n+1} = x_n + h$ 时，会出现两个主要的误差来源：\n\n$1$. **表示误差**：许多十进制小数，如 $0.1$ 或 $0.3$，在二进制中没有精确的有限表示。它们被存储为最接近的可表示二进制浮点数。例如，十进制数 $0.1$ 在二进制中是一个无限循环小数（$0.0001100110011\\dots_2$），必须被截断以适应双精度浮点数的 $52$ 位有效数位。这在任何计算开始之前就引入了初始误差。相反，那些是2的幂的有限和的数，例如 $0.125 = 1/8 = 2^{-3}$，则可以被精确表示。\n\n$2$. **舍入误差**：每次算术运算（在本例中是加法）都以有限精度执行。$x_n + h$ 的数学精确结果会被舍入到最接近的可表示浮点数。这个在每一步引入的小误差，会在多次迭代中累积，导致计算出的序列 $x_n$ 偏离其理论路径。\n\n所给问题要求通过模拟来展示这些效应。方法如下：\n\n首先，我们必须细致地处理输入值。提供的测试用例参数 $s$、$h$ 和 $t$ 被定义为精确的实数。为了计算理论值 $x_{\\mathrm{exact}}$，我们必须使用一个高精度算术库，以避免标准浮点数的不精确性。为此，我们使用 Python 的 `decimal` 模块，并配置足够高的精度，将所有计算当作精确计算来处理。每个测试用例的输入都被转换为这些高精度对象。\n\n其次，对每个测试用例使用标准双精度浮点运算进行模拟，这在 Python 中由 `float` 类型或 `numpy.float64` 表示。模拟遵循以下算法：\n$1$. 初始化浮点序列值 $x_{\\mathrm{float}} \\leftarrow \\text{float}(s)$。将 `hit` 初始化为 `False`，`n_min` 初始化为 $-1$。\n$2$. 使用索引 $n$ 从 $0$ 到 $M$（含）进行迭代。在每次迭代中，序列的当前值 $x_n$ 由 $x_{\\mathrm{float}}$ 表示。\n$3$. 在每一步 $n$，执行精确相等性检查：如果 $x_{\\mathrm{float}} == \\text{float}(t)$。\n$4$. 如果等式成立，则目标已命中。我们将 `hit` 设置为 `True`，将当前索引记录为 $n_{\\mathrm{min}} = n$，将已执行的增量次数设置为 $n_{\\mathrm{exec}} = n$，将 $x_{\\mathrm{float}}$ 的当前值存储为最终值，并终止该测试用例的模拟循环。\n$5$. 如果等式不成立且 $n  M$，则序列前进一个步长：$x_{\\mathrm{float}} \\leftarrow x_{\\mathrm{float}} + \\text{float}(h)$。\n$6$. 如果循环完成而没有找到相等的情况（即，对于所有 $n \\in \\{0, 1, \\dots, M\\}$），我们将 $n_{\\mathrm{exec}}$ 设置为 $M$。$x_{\\mathrm{float}}$ 的最终值是 $M$ 次增量后的结果。\n\n第三，在模拟确定了 $n_{\\mathrm{exec}}$ 和最终 $x_{\\mathrm{float}}$ 的值之后，我们计算理论量。\n$1$. 使用高精度的 `Decimal` 对象计算精确的最终值：$x_{\\mathrm{exact}} = s_{\\mathrm{exact}} + n_{\\mathrm{exec}} \\cdot h_{\\mathrm{exact}}$。\n$2$. 绝对误差则为 $e = |x_{\\mathrm{float}} - \\text{float}(x_{\\mathrm{exact}})|$。\n\n最后，将六个必需的输出字段（`hit`、$n_{\\mathrm{min}}$、$n_{\\mathrm{exec}}$、$x_{\\mathrm{float}}$、$\\text{float}(x_{\\mathrm{exact}})$ 和 $e$）收集到每个测试用例的列表中。\n\n具体的测试用例旨在说明不同的行为：\n- **案例 $1$、$3$ 和 $4$**：这些案例使用的步长（$h = \\pm 0.1$，$h = 0.3$）在二进制中无法精确表示。表示误差和舍入误差的累积将导致浮点序列精确地错过目标值 $t$。因此，我们预期 `hit` 为 `False`。\n- **案例 $2$**：这里，$s, h, t$（`0.0`, `0.125`, `1.0`）都可以精确表示，因为 $h=2^{-3}$。所有加法都是精确的。序列将在 $n=8$ 时精确命中目标 $t=1.0$。因此，我们预期 `hit` 为 `True`。\n- **案例 $5$**：这个案例很微妙。起始值为 $s=1.0$。$1.0$ 的最末一位的单位（ULP）是 $2^{-52}$。增量是 $h = 2^{-55}$，小于 $1.0$ 的 ULP 的一半。由于 IEEE 754 中的“向最近偶数舍入”规则，操作 $1.0 + 2^{-55}$ 会舍入回 $1.0$。因此，模拟的 $x_n$ 值将卡在 $1.0$，永远不会达到目标 $t = 1.0 + 2^{-52}$。然而，精确的总和确实在累积。这展示了一个显著的截断误差，其中小的增量丢失了。我们预期 `hit` 为 `False`，并且存在一个等于丢失增量总和的非零误差 $e$。", "answer": "```python\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Simulates a floating-point sequence and compares it with exact arithmetic.\n    \"\"\"\n    # Set a high precision for the Decimal module for \"exact\" calculations.\n    getcontext().prec = 100\n\n    def run_case_simulation(s_exact, h_exact, t_exact, M):\n        \"\"\"\n        Runs the simulation for a single test case.\n        \"\"\"\n        # Convert exact Decimal inputs to double-precision floats for simulation.\n        s_f = np.float64(s_exact)\n        h_f = np.float64(h_exact)\n        t_f = np.float64(t_exact)\n\n        x_n_float = s_f\n        hit = False\n        n_min = -1\n        \n        # Loop from n=0 to M, checking the sequence value x_n at each step.\n        for n in range(M + 1):\n            # Per problem, check for exact floating-point equality.\n            if x_n_float == t_f:\n                hit = True\n                n_min = n\n                n_exec = n\n                x_float_final = x_n_float\n                break\n            \n            # If not hit and not the last iteration, perform one increment.\n            if n  M:\n                x_n_float += h_f\n        else:  # This 'else' clause executes if the 'for' loop completes without a 'break'.\n            n_exec = M\n            # The final value is the result after M increments.\n            x_float_final = x_n_float\n\n        # Calculate the theoretical exact value and the absolute error.\n        x_exact_val = s_exact + Decimal(n_exec) * h_exact\n        error = np.abs(x_float_final - np.float64(x_exact_val))\n\n        return [hit, n_min, n_exec, x_float_final, np.float64(x_exact_val), error]\n\n    # Define test cases using Decimal for exact representation of inputs.\n    test_cases = [\n        # Test case 1: Canonical failure with decimal step.\n        (Decimal('0.0'), Decimal('0.1'), Decimal('1.0'), 12),\n        # Test case 2: Exactly representable step and reachable target.\n        (Decimal('0.0'), Decimal('0.125'), Decimal('1.0'), 8),\n        # Test case 3: Step does not subdivide the interval.\n        (Decimal('0.0'), Decimal('0.3'), Decimal('1.0'), 10),\n        # Test case 4: Negative step toward zero with decimal step.\n        (Decimal('1.0'), Decimal('-0.1'), Decimal('0.0'), 12),\n        # Test case 5: Increments below one ULP until accumulation.\n        (Decimal('1.0'), Decimal(1) / (Decimal(2)**55), Decimal(1) + Decimal(1) / (Decimal(2)**52), 8)\n    ]\n    \n    all_results = []\n    for case_params in test_cases:\n        s, h, t, M = case_params\n        result = run_case_simulation(s, h, t, M)\n        all_results.append(result)\n\n    # Format the output string to be a list of lists with no spaces.\n    # Each inner list is manually formatted to avoid spaces from default str(list).\n    result_strings = []\n    for res in all_results:\n        # Note: res[0] is a boolean, str(res[0]) is 'True' or 'False'.\n        res_str = f\"[{res[0]},{res[1]},{res[2]},{res[3]},{res[4]},{res[5]}]\"\n        result_strings.append(res_str)\n    \n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2447428"}, {"introduction": "在数学中，加法是满足结合律的，例如 $(a+b)+c = a+(b+c)$，但在计算机上处理浮点数时，这一定律并不总是成立。本练习 [@problem_id:2447450] 将指导你完成一个实验，看看以不同顺序——从最小到最大与从最大到最小——对一串数字求和会如何导致不同的结果，并探究哪种方式更精确。你将研究“大数吃小数”（swamping）等现象，即小数与大数相加时其值被“吞噬”而丢失。", "problem": "您必须编写一个完整、可运行的程序，以演示在浮点运算中，有限精度舍入如何导致实数求和的结果依赖于运算顺序。该研究必须基于浮点运算的标准舍入模型。在此模型中，两个实数的浮点加法表示为 $\\mathrm{fl}(x + y) = (x + y)(1 + \\delta)$，其中 $|\\delta| \\leq u|$，$u$ 是单位舍入误差（对于电气与电子工程师协会（IEEE）的二进制双精度，$u = 2^{-53}$)。程序必须对所有浮点运算使用由宿主编程语言实现的 IEEE 双精度（$64$位）浮点数。\n\n定义和要求：\n- 令 $\\{a_i\\}_{i=1}^n$ 为一个有限的实数列表。精确的实数和为 $S = \\sum_{i=1}^n a_i$。一个朴素的浮点求和通过从初始值 $s = 0$ 开始，按某种顺序迭代二元加法 $s \\leftarrow \\mathrm{fl}(s + a_i)$ 来计算 $\\hat{S}$。\n- 您将比较两种顺序：\n  1. 按绝对值升序：使用稳定排序按 $|a_i|$ 升序排序；然后从最小绝对值加到最大绝对值。将结果记为 $\\hat{S}_{\\mathrm{asc}}$。\n  2. 按绝对值降序：使用稳定排序按 $|a_i|$ 降序排序；然后从最大绝对值加到最小绝对值。将结果记为 $\\hat{S}_{\\mathrm{desc}}$。\n- 作为一个高精度参考，使用至少 $80$ 位十进制精度的任意精度十进制算术计算 $S_{\\mathrm{ref}}$，并将输入视为精确的十进制有理数。此参考值用于量化绝对误差 $|\\hat{S}_{\\mathrm{asc}} - S_{\\mathrm{ref}}|$ 和 $|\\hat{S}_{\\mathrm{desc}} - S_{\\mathrm{ref}}|$。为了在单一算术域中比较值，应在减法前将浮点结果转换为精确的十进制有理数；即，将 IEEE 双精度浮点数 $x$ 转换为其精确表示的十进制数 $\\mathrm{Decimal}(x)$，然后从 $S_{\\mathrm{ref}}$ 中减去。\n\n您的程序必须实现上述要求，并为以下四个测试用例（测试套件）生成单行输出结果。对于每个测试用例，输出三元组 $\\big[\\hat{S}_{\\mathrm{desc}} - \\hat{S}_{\\mathrm{asc}},\\, |\\hat{S}_{\\mathrm{asc}} - S_{\\mathrm{ref}}|,\\, |\\hat{S}_{\\mathrm{desc}} - S_{\\mathrm{ref}}|\\big]$，其形式为原生浮点数。\n\n测试套件（列表应被解释为精确的十进制输入；稳定排序必须在 $|a_i|$ 相等时保留原始顺序）：\n1. 用例 A（小数被大数吞噬）：$\\{1.0,\\, 10 \\text{ 个 } 10^{-16}\\}$，即列表 $\\{1.0,\\, 10^{-16},\\, 10^{-16},\\, \\dots,\\, 10^{-16}\\}$，其中包含 $10$ 个 $10^{-16}$。\n2. 用例 B（三项的灾难性抵消）：$\\{10^{16},\\, 1.0,\\, -10^{16}\\}$。\n3. 用例 C（大数抵消加中等项）：$\\{10^{16},\\, -10^{16},\\, 3.14,\\, 2.71\\}$。\n4. 用例 D（调和级数和，$n = 10{,}000$）：$\\left\\{ \\frac{1}{k} \\,:\\, k = 1, 2, \\dots, 10{,}000 \\right\\}$。\n\n实现细节：\n- 所有用于 $\\hat{S}_{\\mathrm{asc}}$ 和 $\\hat{S}_{\\mathrm{desc}}$ 的浮点求和必须使用 IEEE 双精度（$64$ 位）加法。对于两种要求的顺序，使用按绝对值的稳定排序。\n- 参考值 $S_{\\mathrm{ref}}$ 必须使用至少 $80$ 位十进制精度的任意精度十进制算术进行计算。在这种高精度算术中，每个输入 $a_i$ 在求和前必须被解释为精确的十进制有理数。\n- 对于绝对误差 $|\\hat{S} - S_{\\mathrm{ref}}|$，首先将 $\\hat{S}$ 转换为其精确的十进制表示，然后在高精度十进制域中减去 $S_{\\mathrm{ref}}$，最后将绝对值以浮点数形式报告。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素本身是对应一个测试用例的长度为 3 的列表。确切格式为 $\\big[\\,[d_1, e^{\\mathrm{asc}}_1, e^{\\mathrm{desc}}_1],\\,[d_2, e^{\\mathrm{asc}}_2, e^{\\mathrm{desc}}_2],\\,[d_3, e^{\\mathrm{asc}}_3, e^{\\mathrm{desc}}_3],\\,[d_4, e^{\\mathrm{asc}}_4, e^{\\mathrm{desc}}_4]\\,\\big]$，其中 $d_i = \\hat{S}_{\\mathrm{desc}} - \\hat{S}_{\\mathrm{asc}}$，$e^{\\mathrm{asc}}_i = |\\hat{S}_{\\mathrm{asc}} - S_{\\mathrm{ref}}|$，且 $e^{\\mathrm{desc}}_i = |\\hat{S}_{\\mathrm{desc}} - S_{\\mathrm{ref}}|$。单位不适用，所有角度（如果有）默认为弧度（此处未使用）。", "solution": "问题陈述是有效的。它在科学上是合理的，问题定义清晰，并提供了一个根植于数值分析基本原理（特别是浮点运算中舍入误差的研究）的明确、量化的任务。该问题要求演示浮点加法的不满足结合律的特性。\n\n问题的核心是使用三种不同的方法计算一个数字列表 $\\{a_i\\}_{i=1}^n$ 的和，并比较结果。前两种方法使用标准的 IEEE 754 双精度（$64$位）浮点运算，但求和顺序不同。第三种方法使用高精度算术来建立一个参考值，这里被视为“精确”和。\n\n方法论的步骤结构如下：\n\n1.  **高精度参考求和 ($S_{\\mathrm{ref}}$)**：为了建立求和的基准真相，我们首先使用任意精度十进制算术计算它。精度设置为 $100$ 个十进制位，这超过了至少 $80$ 位的要求。每个输入数字 $a_i$ 都被视为精确的十进制有理数。对于像 $1/k$ 这样的项，除法在高精度上下文中执行以保持准确性。这些高精度数字的和得出参考和 $S_{\\mathrm{ref}}$。\n\n2.  **浮点求和 ($\\hat{S}_{\\mathrm{asc}}$ 和 $\\hat{S}_{\\mathrm{desc}}$)**：有限精度的求和使用标准的双精度浮点数执行。问题指定了两种基于项的绝对值的排序：\n    *   **升序 ($\\hat{S}_{\\mathrm{asc}}$)**：数字列表 $\\{a_i\\}$ 根据其绝对值 $|a_i|$ 按升序排序。使用稳定的排序算法，确保了具有相等绝对值的数字保持其原始相对顺序。然后通过遍历这个排序后的列表来计算和，使用朴素的顺序求和累加总数：$s_0 = 0$，$s_j = \\mathrm{fl}(s_{j-1} + a'_j)$，其中 $\\{a'_j\\}$ 是排序后的列表。最终结果是 $\\hat{S}_{\\mathrm{asc}} = s_n$。\n    *   **降序 ($\\hat{S}_{\\mathrm{desc}}$)**：过程相同，只是列表按 $|a_i|$ 降序排序。得到的和记为 $\\hat{S}_{\\mathrm{desc}}$。\n\n3.  **误差分析**：该分析涉及为每个测试用例计算三个量。\n    *   两个浮点结果之间的差异，$d = \\hat{S}_{\\mathrm{desc}} - \\hat{S}_{\\mathrm{asc}}$。此减法在标准双精度算术中执行。\n    *   升序和的绝对误差，$e_{\\mathrm{asc}} = |\\hat{S}_{\\mathrm{asc}} - S_{\\mathrm{ref}}|$。\n    *   降序和的绝对误差，$e_{\\mathrm{desc}} = |\\hat{S}_{\\mathrm{desc}} - S_{\\mathrm{ref}}|$。\n    为准确计算这些误差，浮点结果 $\\hat{S}_{\\mathrm{asc}}$ 和 $\\hat{S}_{\\mathrm{desc}}$ 首先被转换为它们精确的高精度十进制表示。然后在高精度域中执行减法和绝对值运算，最后将误差值转换回标准双精度浮点数以供输出。\n\n该方法应用于四个旨在突显浮点运算特定现象的独特测试用例。\n*   **用例 A** 演示了**吞噬（swamping）**现象，即将一个小数加到一个非常大的数上会导致小数的值丢失。按升序（从小到大）求和预计会更准确，因为小数首先被累加成一个足够大的和，以至于在与最大的数相加时不会完全丢失。\n*   **用例 B** 和 **用例 C** 涉及**灾难性抵消（catastrophic cancellation）**，即两个几乎相等的大数相减。此操作可能导致有效数字的急剧损失。准确性取决于抵消相对于其他较小项的加法何时发生。如果抵消首先发生（如在按绝对值降序排序中），则随后将小项加到接近零的结果上是准确的。如果在抵消前将一个小项加到一个大数上（如在升序排序中），其值将被吞噬和丢失。\n*   **用例 D**，调和级数的部分和 $\\sum_{k=1}^{10000} \\frac{1}{k}$，涉及对大量具有广泛数量级的项求和。在这种求和中最小化累积舍入误差的一般启发式方法是从最小的数加到最大的数。因此，预计 $\\hat{S}_{\\mathrm{asc}}$ 将显著比 $\\hat{S}_{\\mathrm{desc}}$ 更准确。\n\n程序实现了这一逻辑，处理每个测试用例以计算三元组 $[d, e_{\\mathrm{asc}}, e_{\\mathrm{desc}}]$，并将最终输出格式化为这些结果的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport decimal\nimport math\n\ndef solve():\n    \"\"\"\n    Solves the problem by analyzing summation order effects in floating-point arithmetic.\n    \"\"\"\n\n    def analyze_summation(float_numbers, decimal_numbers):\n        \"\"\"\n        Computes sums in different orders and compares them to a high-precision reference.\n\n        Args:\n            float_numbers (list): A list of numbers as standard Python floats (IEEE 754 double).\n            decimal_numbers (list): A list of numbers as high-precision Decimal objects.\n\n        Returns:\n            list: A list containing [d, e_asc, e_desc] as floats.\n        \"\"\"\n        # 1. Compute the high-precision reference sum S_ref.\n        # The sum is initialized with Decimal(0) to ensure high-precision accumulation.\n        s_ref = sum(decimal_numbers, decimal.Decimal(0))\n\n        # 2. Compute floating-point sums S_asc and S_desc.\n        # The problem requires a stable sort by absolute value. Python's sorted() is stable.\n\n        # Ascending-by-magnitude summation\n        asc_sorted_floats = sorted(float_numbers, key=abs)\n        # Use np.sum for sequential summation as specified by environment.\n        s_asc_float = np.sum(np.array(asc_sorted_floats, dtype=np.float64))\n        \n        # Descending-by-magnitude summation\n        desc_sorted_floats = sorted(float_numbers, key=abs, reverse=True)\n        s_desc_float = np.sum(np.array(desc_sorted_floats, dtype=np.float64))\n\n        # 3. Calculate the required output quantities.\n        # d = S_desc - S_asc, computed in standard floating-point arithmetic.\n        d = s_desc_float - s_asc_float\n\n        # To calculate errors accurately, convert float sums to their exact Decimal representation.\n        # Decimal(float_value) creates a Decimal that exactly represents the binary float.\n        s_asc_decimal = decimal.Decimal(s_asc_float)\n        s_desc_decimal = decimal.Decimal(s_desc_float)\n        \n        # Calculate absolute errors in the high-precision domain.\n        e_asc_decimal = abs(s_asc_decimal - s_ref)\n        e_desc_decimal = abs(s_desc_decimal - s_ref)\n        \n        # Convert final error values back to float for output.\n        return [d, float(e_asc_decimal), float(e_desc_decimal)]\n\n    # Set precision for decimal calculations. 100 digits is safely above the required 80.\n    decimal.getcontext().prec = 100\n    \n    all_results = []\n    \n    # Test Case A: small numbers swamped by a large one\n    inputs_a_str = ['1.0'] + ['1e-16'] * 10\n    floats_a = [float(s) for s in inputs_a_str]\n    decimals_a = [decimal.Decimal(s) for s in inputs_a_str]\n    all_results.append(analyze_summation(floats_a, decimals_a))\n    \n    # Test Case B: catastrophic cancellation with three terms\n    inputs_b_str = ['1e16', '1.0', '-1e16']\n    floats_b = [float(s) for s in inputs_b_str]\n    decimals_b = [decimal.Decimal(s) for s in inputs_b_str]\n    all_results.append(analyze_summation(floats_b, decimals_b))\n\n    # Test Case C: large cancellation plus moderate terms\n    inputs_c_str = ['1e16', '-1e16', '3.14', '2.71']\n    floats_c = [float(s) for s in inputs_c_str]\n    decimals_c = [decimal.Decimal(s) for s in inputs_c_str]\n    all_results.append(analyze_summation(floats_c, decimals_c))\n\n    # Test Case D: harmonic sum, n = 10,000\n    n = 10000\n    # The float numbers for standard summation\n    floats_d = [1.0 / k for k in range(1, n + 1)]\n    # The high-precision decimal numbers for the reference sum.\n    # Division is performed in the high-precision context.\n    decimals_d = [decimal.Decimal(1) / decimal.Decimal(k) for k in range(1, n + 1)]\n    all_results.append(analyze_summation(floats_d, decimals_d))\n    \n    # Final print statement in the exact required format.\n    # str() on a list produces the required '[item1, item2, ...]' format.\n    formatted_results = ','.join(map(str, all_results))\n    print(f\"[{formatted_results}]\")\n\nsolve()\n```", "id": "2447450"}, {"introduction": "认识到求和顺序的重要性后，你可能会想：是否存在一种更稳健的方法来对数字进行求和，而不必过于担心它们的顺序或量级？本练习 [@problem_id:2447409] 将介绍卡汉求和算法（Kahan summation algorithm），这是一种巧妙的技术，它会追踪每一步计算中“丢失”的精度，并将其重新纳入后续计算中。通过将其结果与朴素求和进行比较，你将看到其在准确性上的显著提升。", "problem": "你必须编写一个完整、可运行的程序，用于评估实数序列求和时的舍入误差，并演示如何使用 Kahan 求和算法来减少误差。所有计算都必须使用标准的双精度二进制浮点算术进行。对于每个测试用例，计算同一序列的两个和：一个朴素的从左到右的浮点和，以及一个使用 Kahan 求和算法的补偿和。对于每个和，计算其相对于高精度参考和的绝对误差。你的程序随后必须输出一行，其中包含所有测试用例的所有绝对误差，并遵循指定的顺序和格式。\n\n将计算和 $\\hat{S}$ 相对于参考值 $S^{\\star}$ 的绝对误差定义为 $E = \\lvert \\hat{S} - S^{\\star} \\rvert$。\n\n测试套件由以下四个序列组成：\n\n- 测试用例 $1$（将许多微小的增量添加到一个大的基准值上）：\n  - 序列 $S_1$ 的长度为 $N_1 + 1$，其中 $N_1 = 10^{6}$。第一项是 $s^{(1)}_0 = 1$，其余的 $N_1$ 项是 $s^{(1)}_k = 10^{-16}$（对于 $1 \\le k \\le N_1$）。\n\n- 测试用例 $2$（重复的灾难性抵消三元组）：\n  - 设 $M = 2 \\cdot 10^{5}$。序列 $S_2$ 是由 $M$ 个包含三项 $(1, 10^{-16}, -1)$ 的块连接而成。\n\n- 测试用例 $3$（具有轻微偏差的确定性伪随机小数值）：\n  - 设模数 $m = 2^{64}$，乘数 $a = 6364136223846793005$，增量 $c = 1442695040888963407$，种子 $x_0 = 123456789123456789$。通过 $x_{k+1} \\equiv a x_k + c \\pmod{m}$（对于 $k \\ge 0$）定义一个线性同余生成器。设 $N_3 = 5 \\cdot 10^{4}$。对于 $k = 1, 2, \\dots, N_3$，定义 $u_k = \\frac{x_k}{m} - \\frac{1}{2}$ 和序列项 $s^{(3)}_k = 10^{-12} u_k + 10^{-16}$。序列 $S_3$ 由这 $N_3$ 个项组成。\n\n- 测试用例 $4$（短序列中的动态范围和抵消）：\n  - 序列 $S_4$ 有五项：$(10^{16}, 1, -10^{16}, 3, 4 \\cdot 10^{-16})$。\n\n对于每个测试用例 $i \\in \\{1,2,3,4\\}$，计算：\n- 朴素和 $\\hat{S}^{\\text{naive}}_i$：通过双精度浮点算术进行从左到右的累加。\n- Kahan 补偿和 $\\hat{S}^{\\text{Kahan}}_i$：使用 Kahan 求和算法，通过双精度浮点算术进行计算。\n- 高精度参考和 $S^{\\star}_i$：根据序列的数学定义计算得出，在可能的情况下使用精确算术，或使用至少有 $50$ 位正确小数位的十进制任意精度算术，以确保双精度舍入不会污染 $S^{\\star}_i$。\n\n对于每个测试用例 $i$，计算绝对误差 $E^{\\text{naive}}_i = \\lvert \\hat{S}^{\\text{naive}}_i - S^{\\star}_i \\rvert$ 和 $E^{\\text{Kahan}}_i = \\lvert \\hat{S}^{\\text{Kahan}}_i - S^{\\star}_i \\rvert$。\n\n最终输出格式：\n- 生成一行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须按以下顺序包含 $8$ 个数字：\n  - $E^{\\text{naive}}_1, E^{\\text{Kahan}}_1, E^{\\text{naive}}_2, E^{\\text{Kahan}}_2, E^{\\text{naive}}_3, E^{\\text{Kahan}}_3, E^{\\text{naive}}_4, E^{\\text{Kahan}}_4$。\n- 每个数字必须四舍五入到 $12$ 位有效数字，并以十进制形式表示（科学记数法也可接受）。\n- 所需单行格式示例（仅为说明）：$[e_1,e_2,e_3,e_4,e_5,e_6,e_7,e_8]$。\n\n此问题不涉及物理单位或角度单位。程序必须是自包含的，且不得需要任何用户输入或外部文件。在任何遵循标准双精度浮点语义的现代编程语言中，结果必须能够根据上述定义精确复现。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于数值分析的原理，特别是关于浮点算术和舍入误差。这是一个良态问题，所有计算唯一、可验证解所需的数据和定义均已提供。该问题是客观的，没有歧义。\n\n这个问题的核心是演示和量化在对数量级差异巨大的浮点数求和时发生的精度损失，以及如何使用补偿求和算法来减轻这种误差。\n\n所有计算均使用标准双精度浮点算术执行，这对应于 IEEE 754 $64$ 位格式。这种格式大约有 $15$ 到 $17$ 位的十进制精度。对于这种格式，机器 epsilon，$\\epsilon$，即满足 $1.0 + \\epsilon > 1.0$ 的最小数，大约为 $2.22 \\times 10^{-16}$。当两个数量级差异巨大的数相加时，较小的数可能会部分或完全丢失。这种现象被称为“淹没”(swamping)。\n\n第一种求和方法是朴素的从左到右累加。对于一个序列 $s_0, s_1, \\dots, s_N$，其和 $\\hat{S}^{\\text{naive}}$ 计算为 $(\\dots((s_0 + s_1) + s_2) + \\dots + s_N)$。这种方法极易受到舍入误差的影响。\n\n第二种方法是 Kahan 求和算法，这是一种补偿求和方法。它能显著减少对一系列有限精度浮点数求和时产生的数值误差。该算法维护一个运行中的补偿变量 $c$，用于累积本会丢失的误差。对于序列中的每一项 $s_k$，更新规则如下：\n$$y_k = s_k - c_{k-1}$$\n$$t_k = \\text{sum}_{k-1} + y_k$$\n$$c_k = (t_k - \\text{sum}_{k-1}) - y_k$$\n$$\\text{sum}_k = t_k$$\n这里，$\\text{sum}_0 = 0$ 且 $c_0 = 0$。项 $(t_k - \\text{sum}_{k-1})$ 恢复了 $y_k$ 的高位部分，而从中减去 $y_k$ 则分离出低位部分（即舍入误差），该误差存储在 $c_k$ 中，并从下一项 $s_{k+1}$ 中减去。\n\n绝对误差定义为 $E = \\lvert \\hat{S} - S^{\\star} \\rvert$，其中 $\\hat{S}$ 是计算所得的和，而 $S^{\\star}$ 是高精度参考和。\n\n测试用例分析：\n\n测试用例 $1$：\n序列是 $s^{(1)}_0 = 1$，后跟 $N_1 = 10^6$ 个项 $s^{(1)}_k = 10^{-16}$（对于 $k \\ge 1$）。\n精确和是 $S^{\\star}_1 = 1 + 10^6 \\times 10^{-16} = 1 + 10^{-10}$。\n在朴素求和中，我们计算 $1 + 10^{-16} + 10^{-16} + \\dots$。相对于 $1.0$，项 $10^{-16}$ 非常接近机器 epsilon。在双精度算术中，操作 $1.0 + 10^{-16}$ 会遭受淹没（swamping）；结果很可能会被舍入回 $1.0$。因此，大多数小项将会丢失，$\\hat{S}^{\\text{naive}}_1$ 预计会非常接近 $1.0$，导致误差接近 $10^{-10}$。\nKahan 算法会在每一步中将丢失的部分 $10^{-16}$ 捕获到补偿变量 $c$ 中并重新引入，从而得到一个非常接近 $S^{\\star}_1$ 的结果 $\\hat{S}^{\\text{Kahan}}_1$。误差 $E^{\\text{Kahan}}_1$ 应该接近机器精度。\n\n测试用例 $2$：\n序列由 $M = 2 \\cdot 10^5$ 个块 $(1, 10^{-16}, -1)$ 组成。\n一个块的精确和是 $1 + 10^{-16} - 1 = 10^{-16}$。总的精确和是 $S^{\\star}_2 = 2 \\cdot 10^5 \\times 10^{-16} = 2 \\cdot 10^{-11}$。\n朴素求和会计算 $(1 + 10^{-16}) - 1$。与第一个情况一样，$1 + 10^{-16}$ 很可能会舍入为 $1.0$，因此 $(1 + 10^{-16}) - 1$ 的计算结果为 $0$。对所有块重复此操作，$\\hat{S}^{\\text{naive}}_2$ 预计为 $0.0$，导致误差 $E^{\\text{naive}}_2$ 恰好为 $2 \\cdot 10^{-11}$。\nKahan 算法将防止这种抵消错误，产生一个非常接近 $S^{\\star}_2$ 的和 $\\hat{S}^{\\text{Kahan}}_2$，以及一个更小的误差 $E^{\\text{Kahan}}_2$。\n\n测试用例 $3$：\n序列由 $N_3 = 5 \\cdot 10^4$ 个项 $s^{(3)}_k = 10^{-12} u_k + 10^{-16}$ 组成，其中 $u_k = \\frac{x_k}{m} - \\frac{1}{2}$，$x_k$ 来自一个线性同余生成器（LCG）。\n$u_k$ 的值是 $[-0.5, 0.5)$ 范围内的伪随机数。项 $s^{(3)}_k$ 很小，并带有一个 $10^{-16}$ 的微小正偏差。\n精确和是 $S^{\\star}_3 = \\sum_{k=1}^{N_3} (10^{-12} u_k + 10^{-16}) = 10^{-12} \\sum_{k=1}^{N_3} u_k + N_3 \\cdot 10^{-16}$。\n这个和必须使用高精度算术来计算，以作为参考值 $S^{\\star}_3$。LCG 的状态 $x_{k+1} \\equiv a x_k + c \\pmod{m}$ 是使用 $64$ 位整数算术计算的。和 $\\sum x_k$ 是使用任意精度整数计算的，而 $S^{\\star}_3$ 的最终表达式是使用高精度十进制算术评估的。\n朴素求和将在 $5 \\cdot 10^4$ 次加法中累积微小的舍入误差。Kahan 算法预计会最小化这种累积，导致 $E^{\\text{Kahan}}_3 \\ll E^{\\text{naive}}_3$。\n\n测试用例 $4$：\n序列是 $(10^{16}, 1, -10^{16}, 3, 4 \\cdot 10^{-16})$。\n精确和是 $S^{\\star}_4 = (10^{16} - 10^{16}) + (1 + 3) + 4 \\cdot 10^{-16} = 4 + 4 \\cdot 10^{-16}$。\n朴素的从左到右求和按步骤计算如下：\n1. $10^{16} + 1 = 10^{16}$ (淹没，因为 $1$ 小于 $10^{16}$ 的最低有效位的单位值)。\n2. $10^{16} - 10^{16} = 0$。\n3. $0 + 3 = 3$。\n4. $3 + 4 \\cdot 10^{-16} = 3$ (淹没，因为相对于 $3$，$4 \\cdot 10^{-16}$ 小于机器 epsilon)。\n所以，$\\hat{S}^{\\text{naive}}_4 = 3$。误差是 $E^{\\text{naive}}_4 = \\lvert 3 - (4 + 4 \\cdot 10^{-16}) \\rvert \\approx 1$。\nKahan 求和算法就是为处理这种情况而设计的。第一步中 $1$ 的损失将被补偿变量捕获。最终的和 $\\hat{S}^{\\text{Kahan}}_4$ 应该非常接近真实和 $S^{\\star}_4$，从而产生一个非常小的误差 $E^{\\text{Kahan}}_4$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport decimal\n\ndef solve():\n    \"\"\"\n    Computes and prints round-off errors for naive and Kahan summations\n    for four specific test cases, adhering to the problem specification.\n    \"\"\"\n\n    def naive_sum(sequence):\n        \"\"\"Computes the naive left-to-right sum of a sequence.\"\"\"\n        s = 0.0\n        for x in sequence:\n            s += x\n        return s\n\n    def kahan_sum(sequence):\n        \"\"\"Computes the sum of a sequence using Kahan's algorithm.\"\"\"\n        s = 0.0\n        c = 0.0\n        for x in sequence:\n            y = x - c\n            t = s + y\n            c = (t - s) - y\n            s = t\n        return s\n\n    def generate_test_cases():\n        \"\"\"Generates the sequences for all four test cases.\"\"\"\n        # Test Case 1: Many tiny increments\n        N1 = 10**6\n        seq1 = np.full(N1, 1e-16, dtype=np.float64)\n        seq1 = np.insert(seq1, 0, 1.0)\n        \n        # Test Case 2: Repeated catastrophic cancellation\n        M = 2 * 10**5\n        block = np.array([1.0, 1e-16, -1.0], dtype=np.float64)\n        seq2 = np.tile(block, M)\n        \n        # Test Case 3: LCG-based sequence\n        m = 2**64\n        a = 6364136223846793005\n        c = 1442695040888963407\n        x0 = 123456789123456789\n        N3 = 5 * 10**4\n        \n        seq3 = np.zeros(N3, dtype=np.float64)\n        x_current = x0\n        for k in range(N3):\n            x_current = (a * x_current + c) % m\n            u_k = x_current / m - 0.5\n            seq3[k] = 1e-12 * u_k + 1e-16\n\n        # Test Case 4: Dynamic range and cancellation\n        seq4 = np.array([1e16, 1.0, -1e16, 3.0, 4e-16], dtype=np.float64)\n        \n        return [seq1, seq2, seq3, seq4]\n\n    def get_reference_sums():\n        \"\"\"Computes high-accuracy reference sums for all test cases.\"\"\"\n        # Set precision for Decimal calculations\n        decimal.getcontext().prec = 100\n\n        # Reference Sum 1\n        N1 = 10**6\n        s_star_1 = decimal.Decimal(1) + decimal.Decimal(N1) * decimal.Decimal('1e-16')\n\n        # Reference Sum 2\n        M = 2 * 10**5\n        s_star_2 = decimal.Decimal(M) * decimal.Decimal('1e-16')\n\n        # Reference Sum 3\n        m = 2**64\n        a = 6364136223846793005\n        c = 1442695040888963407\n        x0 = 123456789123456789\n        N3 = 5 * 10**4\n        \n        sum_x = 0\n        x_current = x0\n        for _ in range(N3):\n            x_current = (a * x_current + c) % m\n            sum_x += x_current\n        \n        D_sum_x = decimal.Decimal(sum_x)\n        D_m = decimal.Decimal(m)\n        D_N3 = decimal.Decimal(N3)\n        D_1e_12 = decimal.Decimal('1e-12')\n        D_1e_16 = decimal.Decimal('1e-16')\n        D_half = decimal.Decimal('0.5')\n        \n        sum_u = D_sum_x / D_m - D_N3 * D_half\n        s_star_3 = D_1e_12 * sum_u + D_N3 * D_1e_16\n\n        # Reference Sum 4\n        s_star_4 = decimal.Decimal('4') + decimal.Decimal('4e-16')\n        \n        return [float(s_star_1), float(s_star_2), float(s_star_3), float(s_star_4)]\n\n    sequences = generate_test_cases()\n    reference_sums = get_reference_sums()\n    \n    results = []\n    \n    for i in range(4):\n        seq = sequences[i]\n        s_star = reference_sums[i]\n        \n        # Naive sum and its error\n        s_naive = naive_sum(seq)\n        e_naive = abs(s_naive - s_star)\n        \n        # Kahan sum and its error\n        s_kahan = kahan_sum(seq)\n        e_kahan = abs(s_kahan - s_star)\n        \n        results.extend([e_naive, e_kahan])\n\n    # Format output to 12 significant digits and print\n    formatted_results = [f\"{res:.12g}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2447409"}]}