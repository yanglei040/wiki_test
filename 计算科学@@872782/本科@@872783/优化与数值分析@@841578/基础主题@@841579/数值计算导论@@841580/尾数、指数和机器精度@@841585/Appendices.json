{"hands_on_practices": [{"introduction": "要理解计算机如何处理实数，首先必须掌握浮点表示法的核心概念。这个练习 [@problem_id:2204331] 通过一个假设的 8 位系统，帮助你从第一性原理出发，亲手计算机器精度 $\\epsilon_m$。通过这个过程，你将直观地理解数字在计算机内部的离散性以及精度限制的来源。", "problem": "考虑一个为低功耗嵌入式控制器设计的假设性8位浮点数系统。在此系统中，每个数字使用1位表示符号（$S$），4位表示带偏置的指数（$E$），以及3位表示尾数的小数部分（$M$）。\n\n一个数的值由以下公式给出：\n$$V = (-1)^S \\times (1.M)_2 \\times 2^{E - \\text{bias}}$$\n\n尾数是规格化的，意味着其形式为 $(1.M)_2$，表示二进制数 $1$ 后跟3位的小数 $M$。指数偏置定义为 $\\text{bias} = 2^{k-1} - 1$，其中 $k$ 是指数字段的位数。\n\n在任何浮点系统中，都存在一个关于精度的基本限制，称为机器ε（$\\epsilon_m$）。它被定义为在该系统的表示法中，当其与1相加时，能得到一个大于1的结果的最小正数。\n\n计算这个8位浮点数系统的机器ε的值。将你的答案表示为单个十进制实数。", "solution": "我们有一个8位浮点格式，包含1个符号位，4个指数位，以及尾数中的3个小数位。其值由\n$$\nV = (-1)^{S} (1.M)_{2} 2^{E - \\text{bias}},\n$$\n给出，其中尾数是规格化的，偏置由 $\\text{bias} = 2^{k-1} - 1$ 定义（$k$为指数位数）。\n\n首先计算 $k=4$ 时的偏置：\n$$\n\\text{bias} = 2^{4-1} - 1 = 2^{3} - 1 = 7.\n$$\n数字 $1$ 通过选择 $S=0$，$E=\\text{bias}$ 和 $M=000$ 来表示，得到\n$$\nV_{1} = (1.000)_{2} \\times 2^{7-7} = 1 \\times 2^{0} = 1.\n$$\n在相同指数下，大于1的下一个可表示的数具有最小的正尾数增量，即 $M=001$。其值为\n$$\nV_{\\text{next}} = (1.001)_{2} \\times 2^{7-7} = \\left(1 + 2^{-3}\\right) \\times 2^{0} = 1 + 2^{-3}.\n$$\n根据机器ε $\\epsilon_{m}$ 的定义，即在该系统中使 $1 + \\epsilon_{m} > 1$ 成立的最小正数，我们有\n$$\n\\epsilon_{m} = V_{\\text{next}} - V_{1} = \\left(1 + 2^{-3}\\right) - 1 = 2^{-3} = \\frac{1}{8} = 0.125.\n$$\n等价地，由于精度为 $p=1+3=4$ 个有效位（包括隐含的前导$1$），通用公式 $\\epsilon_{m} = 2^{1-p}$ 给出\n$$\n\\epsilon_{m} = 2^{1-4} = 2^{-3} = 0.125,\n$$\n这与直接构造法的结果一致。", "answer": "$$\\boxed{0.125}$$", "id": "2204331"}, {"introduction": "理论知识需要通过实践来验证。在通过简化模型理解了机器精度的概念之后，这个练习 [@problem_id:2395229] 将引导你编写程序，以经验方式测定标准单精度和双精度浮点数系统中的机器精度。这个实践不仅能加深你对 IEEE 754标准的理解，还能让你掌握一种探测计算环境基本属性的实用技能。", "problem": "编写一个完整的程序，以经验方式确定单精度和双精度二进制浮点数的机器ε，并根据电气与电子工程师协会 (IEEE) 标准 $754$ 的理论预期验证结果。在此背景下，将机器ε定义为满足 $1 + \\epsilon$ 在给定精度下可表示且严格大于 $1$ 的最小正数 $\\epsilon$。仅使用确定性计算；不读取任何输入。\n\n背景与基础：根据 IEEE 标准 $754$，浮点数以基数 $b = 2$ 表示。任何规格化数都可以写成 $x = m \\times b^{e}$，其中有效数 $m$ 满足 $1 \\le m  2$，且 $e$ 是一个整数指数。对于规格化数，相邻可表示值之间的间隙仅取决于 $b$ 和有效数位数 $p$。单精度有 $p = 24$，双精度有 $p = 53$。所有舍入都遵循“向最近舍入，偶数优先”的原则。\n\n您的程序必须执行的任务：\n- 对于给定的二进制浮点类型，通过迭代减半实现一个纯粹的经验性过程来估计机器ε。在该类型中以 $\\epsilon = 1$ 开始，并重复将其减半，直到将其加到 $1$ 不再改变该类型中的值为止。返回最后一个确实改变了值的 $\\epsilon$。此操作必须分别对单精度（$32$位）和双精度（$64$位）执行。\n- 仅使用上述基本事实，根据 $b$ 和 $p$ 计算每种精度下 $1$ 与下一个更大的可表示数之间的理论间距。\n- 对于每种精度，计算经验性ε $\\epsilon_{\\mathrm{emp}}$ 与理论间距 $\\epsilon_{\\mathrm{theory}}$ 之间的相对误差，公式为 $\\left|\\epsilon_{\\mathrm{emp}} - \\epsilon_{\\mathrm{theory}}\\right| / \\epsilon_{\\mathrm{theory}}$。\n- 对于每种精度，验证在该精度下求值的边界属性 $1 + \\epsilon_{\\mathrm{emp}} > 1$ 同时 $1 + \\epsilon_{\\mathrm{emp}}/2 = 1$，并将结果报告为布尔值。\n\n测试套件和参数：\n- 使用以下类型-参数对：\n  - 单精度（$32$位），$p = 24$。\n  - 双精度（$64$位），$p = 53$。\n这两种情况共同构成了测试套件，并且都必须由您的程序处理。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按此确切顺序包含以下六个条目：\n  - $[\\epsilon_{\\mathrm{single}}, \\epsilon_{\\mathrm{double}}, r_{\\mathrm{single}}, r_{\\mathrm{double}}, \\mathrm{ok}_{\\mathrm{single}}, \\mathrm{ok}_{\\mathrm{double}}]$,\n其中 $\\epsilon_{\\mathrm{single}}$ 和 $\\epsilon_{\\mathrm{double}}$ 分别是单精度和双精度的经验性ε，$r_{\\mathrm{single}}$ 和 $r_{\\mathrm{double}}$ 是相应的相对误差（非负实数），而 $\\mathrm{ok}_{\\mathrm{single}}$ 和 $\\mathrm{ok}_{\\mathrm{double}}$ 是边界属性的布尔值。数字必须以标准十进制数字打印。例如，输出必须看起来像 $[x_1,x_2,x_3,x_4,True,True]$，并用实际计算出的值替换。\n\n角度单位和物理单位不适用于此问题。所有数值必须报告为无单位的实数或布尔值。程序必须是自包含的，且不需要任何输入。在兼容 IEEE 标准 $754$ 算术的实现中，结果必须是可复现的。", "solution": "问题要求根据电气与电子工程师协会 (IEEE) 标准 $754$ 的规定，对单精度和双精度浮点数进行机器ε的经验性测定和理论性确定。对问题陈述的验证确认了其科学合理性、一致性和完整性。因此，我们可以进行形式化的求解。\n\n该解决方案基于二进制浮点表示法的原理。根据 IEEE $754$ 标准，一个规格化的浮点数 $x$ 以基数 $b=2$ 表示为：\n$$x = (-1)^s \\times m \\times 2^e$$\n其中 $s$ 是符号位，$e$ 是指数，$m$ 是有效数（或尾数）。有效数被规格化到 $1 \\le m  2$ 的范围内，并以 $m = 1.f$ 的形式存储，其中前导位 $1$ 是隐含的，$f$ 是显式存储的小数部分。有效数的总精度位数用 $p$ 表示。这包括隐含的前导位。因此，小数部分 $f$ 由 $p-1$ 位表示。\n\n对于单精度数，参数为 $p=24$。对于双精度数，参数为 $p=53$。\n\n**理论机器ε**\n\n问题要求我们计算数字 $1$ 与下一个更大的可表示数之间的理论间距。数字 $1$ 在二进制浮点运算中是精确可表示的。其规格化表示为：\n$$1.0 = (1.000...0)_2 \\times 2^0$$\n此处，指数为 $e=0$，有效数为 $m=1$。$p-1$ 个小数位全为零。\n\n为了找到比 $1$ 大的下一个可表示浮点数，我们必须做出最小的可能改变。这通过增加有效数小数部分的最低有效位 (LSB) 来实现。LSB 对应的值为 $2^{-(p-1)}$。因此，下一个数的有效数为：\n$$m' = (1.000...01)_2 = 1 + 2^{-(p-1)}$$\n因此，下一个可表示的数 $x_{\\text{next}}$ 是：\n$$x_{\\text{next}} = (1 + 2^{-(p-1)}) \\times 2^0 = 1 + 2^{-(p-1)}$$\n理论间距，我们称之为 $\\epsilon_{\\mathrm{theory}}$，是 $x_{\\text{next}}$ 和 $1$ 之间的差：\n$$\\epsilon_{\\mathrm{theory}} = x_{\\text{next}} - 1 = (1 + 2^{-(p-1)}) - 1 = 2^{-(p-1)}$$\n\n使用给定的参数：\n- 对于单精度 ($p=24$):\n  $$\\epsilon_{\\mathrm{theory, single}} = 2^{-(24-1)} = 2^{-23}$$\n- 对于双精度 ($p=53$):\n  $$\\epsilon_{\\mathrm{theory, double}} = 2^{-(53-1)} = 2^{-52}$$\n\n**经验性估算程序**\n\n问题指定了一种迭代算法来经验性地寻找机器ε。我们从 $\\epsilon = 1$ 开始，并重复将其除以 $2$，直到满足条件 $(1 + \\epsilon)_{FP} = 1$，其中下标 $FP$ 表示浮点运算。该算法返回使 $(1 + \\epsilon)_{FP} > 1$ 成立的最后一个 $\\epsilon$ 值。\n\n让我们分析这个过程。我们正在测试值 $\\epsilon_k = 2^{-k}$，其中 $k=0, 1, 2, \\dots$。该操作是 $1$ 和 $\\epsilon_k$ 的浮点加法。精确的数学和是 $1 + 2^{-k}$。为了执行加法，操作数的指数必须对齐。数字 $1$ 是 $1.0 \\times 2^0$，而 $\\epsilon_k$ 是 $1.0 \\times 2^{-k}$。通过右移较小数的有效数来执行求和：\n$$1.0 \\times 2^0 + 1.0 \\times 2^{-k} = (1.00...0_2 + 0.00...1_2) \\times 2^0$$\n其中第二项中的 $1$ 位于二进制小数点后的第 $k$ 位。结果的有效数有 $p-1$ 个小数位用于存储。\n\n- 如果 $k  p-1$，第 $k$ 位的比特在有效数的可表示部分内。和 $1+2^{-k}$ 是精确可表示的，且结果大于 $1$。\n- 如果 $k = p-1$，和为 $1+2^{-(p-1)}$。如前所述，这是 $1$ 之后的下一个可表示数。所以，$(1+2^{-(p-1)})_{FP} = 1+2^{-(p-1)} > 1$。\n- 如果 $k=p$，数学和为 $1+2^{-p}$。该值恰好位于两个连续可表示数 $N_1=1$ 和 $N_2=1+2^{-(p-1)}$ 的中间。\n  $$1+2^{-p} = 1 + \\frac{1}{2}(2^{-(p-1)}) = \\frac{N_1 + N_2}{2}$$\n  IEEE $754$ 标准规定了“向最近舍入，偶数优先”。我们必须舍入到其有效数最低有效位为 $0$ 的那个邻近值。\n  $N_1=1$ 的有效数是 $(1.00...0)_2$。其 LSB 是 $0$。\n  $N_2=1+2^{-(p-1)}$ 的有效数是 $(1.00...1)_2$。其 LSB 是 $1$。\n  因此，平局情况向下舍入到 $N_1=1$。所以，$(1+2^{-p})_{FP} = 1$。\n- 如果 $k > p$，和 $1+2^{-k}$ 比 $1+2^{-(p-1)}$ 更接近 $1$，因此它也舍入到 $1$。\n\n问题中指定的迭代过程，“重复将其减半，直到将其加到 $1$ 不再改变该类型中的值为止...返回最后一个确实改变了值的 $\\epsilon$”，将在测试 $\\epsilon_k = 2^{-p}$ 时停止。此时，$(1+\\epsilon_k)_{FP} = 1$。算法返回前一个epsilon的值，即 $\\epsilon_{p-1}=2^{-(p-1)}$。因此，经验性确定的epsilon是：\n$$\\epsilon_{\\mathrm{emp}} = 2^{-(p-1)}$$\n\n**验证与误差计算**\n\n根据以上推导，我们有 $\\epsilon_{\\mathrm{emp}} = \\epsilon_{\\mathrm{theory}} = 2^{-(p-1)}$。\n因此，相对误差为：\n$$r = \\frac{|\\epsilon_{\\mathrm{emp}} - \\epsilon_{\\mathrm{theory}}|}{\\epsilon_{\\mathrm{theory}}} = \\frac{|2^{-(p-1)} - 2^{-(p-1)}|}{2^{-(p-1)}} = 0$$\n这对单精度和双精度都必须成立。\n\n边界属性验证需要检查两个条件：\n$1$. $(1 + \\epsilon_{\\mathrm{emp}})_{FP} > 1$:\n    即 $(1 + 2^{-(p-1)})_{FP} > 1$。由于 $1+2^{-(p-1)}$ 是精确可表示的，并且是紧随 $1$ 之后的下一个值，所以这是成立的。\n$2$. $(1 + \\epsilon_{\\mathrm{emp}}/2)_{FP} = 1$:\n    即 $(1 + 2^{-(p-1)}/2)_{FP} = (1 + 2^{-p})_{FP}$。如舍入规则分析所示，此表达式求值为 $1$。这也是成立的。\n\n因此，边界属性的布尔检查都应得出 true。\n\n**实现策略**\n\n解决方案将使用 Python 实现，并利用 `numpy` 库来访问 `np.float32`（单精度）和 `np.float64`（双精度）类型。一个函数将通过实现迭代减半循环，对给定的浮点类型执行经验计算。主程序将对 `np.float32` 和 `np.float64` 两种类型执行此操作。理论值、相对误差和边界属性布尔值将按推导的方式计算。所有六个所需的值（$\\epsilon_{\\mathrm{single}}$、$\\epsilon_{\\mathrm{double}}$、$r_{\\mathrm{single}}$、$r_{\\mathrm{double}}$、$\\mathrm{ok}_{\\mathrm{single}}$、$\\mathrm{ok}_{\\mathrm{double}}$）将被收集并以指定格式打印。计算必须确保中间浮点类型得到正确处理，例如在执行单精度测试时使用 `np.float32(1)`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Empirically determines and theoretically validates machine epsilon for single\n    and double precision floating-point numbers as per IEEE 754.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (numpy_type, significand_bits_p, name)\n    test_cases = [\n        (np.float32, 24, \"single\"),\n        (np.float64, 53, \"double\"),\n    ]\n\n    results_dict = {}\n\n    for precision_type, p, name in test_cases:\n        # Task 1: Empirically determine machine epsilon.\n        # The specified procedure is to start with epsilon = 1 and repeatedly\n        # halve it. The last epsilon for which 1 + epsilon  1 is the result.\n        # A more direct loop finds the smallest representable power of 2, epsilon,\n        # such that 1 + epsilon/2 == 1, which confirms that epsilon is the smallest\n        # representable number that makes a difference when added to 1.\n        one = precision_type(1)\n        two = precision_type(2)\n        epsilon = precision_type(1)\n        \n        while one + (epsilon / two) != one:\n            epsilon = epsilon / two\n        \n        epsilon_emp = epsilon\n        \n        # Task 2: Compute the theoretical spacing.\n        # As derived from IEEE 754 principles, the theoretical spacing between 1\n        # and the next representable number is 2^-(p-1).\n        # We use Python's native float (double precision) for this calculation\n        # to ensure high accuracy for the reference value.\n        epsilon_theory = 2.0**(-(p - 1))\n\n        # Task 3: Compute the relative error.\n        # The empirical value should be identical to the theoretical one.\n        # The relative error is computed with high-precision values.\n        relative_error = np.abs(float(epsilon_emp) - epsilon_theory) / epsilon_theory\n        \n        # Task 4: Verify the boundary property.\n        # This confirms our understanding of the epsilon value. We must check that\n        # 1 + epsilon_emp  1 but 1 + epsilon_emp/2 = 1, all in the target precision.\n        boundary_ok = (one + epsilon_emp  one) and \\\n                      (one + epsilon_emp / two == one)\n\n        # Store results for this precision.\n        results_dict[name] = {\n            \"epsilon_emp\": epsilon_emp,\n            \"relative_error\": relative_error,\n            \"boundary_ok\": boundary_ok\n        }\n\n    # Assemble the final list of results in the specified order.\n    # [eps_single, eps_double, r_single, r_double, ok_single, ok_double]\n    final_results = [\n        results_dict[\"single\"][\"epsilon_emp\"],\n        results_dict[\"double\"][\"epsilon_emp\"],\n        results_dict[\"single\"][\"relative_error\"],\n        results_dict[\"double\"][\"relative_error\"],\n        results_dict[\"single\"][\"boundary_ok\"],\n        results_dict[\"double\"][\"boundary_ok\"]\n    ]\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) function correctly converts floats and booleans to their\n    # standard string representations (e.g., \"True\", \"False\").\n    print(f\"[{','.join(map(str, final_results))}]\")\n\nsolve()\n```", "id": "2395229"}, {"introduction": "除了精度限制外，浮点数的另一个关键局限是其表示范围的有限性，这会导致“溢出”错误。本练习 [@problem_id:2186557] 将探讨这一问题，要求你估算在不超出双精度浮点数最大表示范围的情况下，可以计算的最大中心二项式系数 $\\binom{2n}{n}$。通过这个练习，你将学会如何预判计算中可能出现的溢出风险，这是编写稳健科学计算程序的重要一步。", "problem": "在科学计算中，理解浮点运算的局限性至关重要。一个常见的问题是溢出，当计算产生的结果大于可表示的最大数时，就会发生溢出。\n\n考虑一个遵循电气和电子工程师协会（IEEE）754双精度浮点数标准的计算机系统。在该系统中，可表示的最大有限正数 $V_{max}$ 可近似为 $V_{max} = 2^{1024}$。\n\n我们感兴趣的是计算中心二项式系数，其定义为 $\\binom{2n}{n} = \\frac{(2n)!}{(n!)^2}$。对于较大的整数 $n$，该系数可以通过以下公式精确近似：\n$$ \\binom{2n}{n} \\approx \\frac{4^n}{\\sqrt{\\pi n}} $$\n\n您的任务是确定最大的整数 $n$，使得 $\\binom{2n}{n}$ 的值可以存储在这种双精度格式中而不会导致溢出。为了进行计算，您可能需要一个计算器，并应使用以下自然对数值：$\\ln(\\pi) \\approx 1.1447$ 和 $\\ln(2) \\approx 0.6931$。", "solution": "我们需要中心二项式系数保持在可表示的最大有限值以下。对于较大的 $n$，使用给定的精确近似，\n$$\n\\binom{2n}{n} \\approx \\frac{4^{n}}{\\sqrt{\\pi n}},\n$$\n以及边界 $V_{\\max} \\approx 2^{1024}$，无溢出条件变为\n$$\n\\frac{4^{n}}{\\sqrt{\\pi n}} \\leq 2^{1024}.\n$$\n取自然对数并使用 $\\ln(4^{n}) = 2n\\ln 2$ 和 $\\ln\\!\\left(\\sqrt{\\pi n}\\right) = \\tfrac{1}{2}\\left(\\ln \\pi + \\ln n\\right)$，得到不等式\n$$\n2n\\ln 2 - \\frac{1}{2}\\left(\\ln \\pi + \\ln n\\right) \\leq 1024 \\ln 2.\n$$\n等价地，定义\n$$\ng(n) \\equiv 2n\\ln 2 - \\frac{1}{2}\\ln n,\n$$\n我们需要\n$$\ng(n) \\leq 1024\\ln 2 + \\frac{1}{2}\\ln \\pi.\n$$\n为找到满足此条件的最大整数 $n$，我们将等式作为阈值求解，并测试附近的整数。使用所提供的值 $\\ln(2) \\approx 0.6931$ 和 $\\ln(\\pi) \\approx 1.1447$，计算右侧：\n$$\n1024\\ln 2 + \\frac{1}{2}\\ln \\pi \\approx 1024 \\cdot 0.6931 + \\frac{1}{2}\\cdot 1.1447 = 709.7344 + 0.57235 = 710.30675.\n$$\n现在计算 $g(n) = 2n\\ln 2 - \\tfrac{1}{2}\\ln n = 1.3862\\,n - \\tfrac{1}{2}\\ln n$ 在 $n=514$ 和 $n=515$ 处的值。使用 $\\ln(512)=9\\ln 2=6.2379$ 和展开式 $\\ln(1+x)\\approx x - x^{2}/2 + x^{3}/3$，我们得到\n- $\\ln 514 = \\ln 512 + \\ln(514/512) \\approx 6.2379 + 0.00389864 = 6.24179864$，因此\n$$\ng(514) \\approx 1.3862 \\cdot 514 - \\frac{1}{2}\\cdot 6.24179864 = 712.5068 - 3.12089932 = 709.38590068,\n$$\n该值小于 $710.30675$。\n- $\\ln 515 = \\ln 512 + \\ln(515/512) \\approx 6.2379 + 0.00584228 = 6.24374228$，因此\n$$\ng(515) \\approx 1.3862 \\cdot 515 - \\frac{1}{2}\\cdot 6.24374228 = 713.8930 - 3.12187114 = 710.77112886,\n$$\n该值大于 $710.30675$。\n\n因此，阈值出现在 $n=514$ 和 $n=515$ 之间，并且（在给定的近似和 $V_{\\max} \\approx 2^{1024}$ 条件下）使得 $\\binom{2n}{n}$ 可以被存储而不会溢出的最大整数 $n$ 是 $n=514$。", "answer": "$$\\boxed{514}$$", "id": "2186557"}]}