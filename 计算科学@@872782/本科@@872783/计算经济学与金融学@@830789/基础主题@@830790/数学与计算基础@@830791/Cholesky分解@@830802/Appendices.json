{"hands_on_practices": [{"introduction": "为了真正掌握 Cholesky 分解，从一个具体的数值例子入手进行手动计算是至关重要的一步。这个练习 [@problem_id:950176] 将引导你逐个元素地构建出下三角矩阵 $L$，使得 $A = LL^T$。通过这个过程，你不仅能熟悉分解算法的力学原理，还能深刻理解为何该方法要求矩阵是正定的。", "problem": "考虑对称正定矩阵\n\n$$\nA = \\begin{bmatrix}\n4  1  2 \\\\\n1  5  0 \\\\\n2  0  6\n\\end{bmatrix}.\n$$\n  \n$A$ 的 Cholesky 分解为 $A = LL^T$，其中 $L$ 是一个对角线元素为正的下三角矩阵。计算 $L$ 的 $(3,3)$-元。", "solution": "设 \n$$L=\\begin{pmatrix}\n\\ell_{11}  0  0 \\\\\n\\ell_{21}  \\ell_{22}  0 \\\\\n\\ell_{31}  \\ell_{32}  \\ell_{33}\n\\end{pmatrix},$$\n使得 $A=LL^T$。令对应元素相等可得：\n\n1. 从 $(1,1)$‐元可得： \n$$4=\\ell_{11}^2\\quad\\Longrightarrow\\quad \\ell_{11}=\\sqrt{4}=2.$$\n\n2. 从 $(2,1)$‐元可得：\n$$1=\\ell_{21}\\,\\ell_{11}\\quad\\Longrightarrow\\quad \\ell_{21}=\\frac1{\\ell_{11}}=\\frac12.$$\n\n3. 从 $(3,1)$‐元可得：\n$$2=\\ell_{31}\\,\\ell_{11}\\quad\\Longrightarrow\\quad \\ell_{31}=\\frac2{\\ell_{11}}=1.$$\n\n4. 从 $(2,2)$‐元可得：\n$$5=\\ell_{21}^2+\\ell_{22}^2\n=\\Bigl(\\frac12\\Bigr)^2+\\ell_{22}^2\n\\quad\\Longrightarrow\\quad\n\\ell_{22}=\\sqrt{5-\\tfrac14}\n=\\sqrt{\\frac{19}{4}}\n=\\frac{\\sqrt{19}}2.$$\n\n5. 从 $(3,2)$‐元可得：\n$$0=\\ell_{31}\\,\\ell_{21}+\\ell_{32}\\,\\ell_{22}\n=\\frac12+\\ell_{32}\\,\\frac{\\sqrt{19}}2\n\\quad\\Longrightarrow\\quad\n\\ell_{32}=-\\frac{\\tfrac12}{\\tfrac{\\sqrt{19}}2}\n=-\\frac1{\\sqrt{19}}.$$\n\n6. 从 $(3,3)$‐元可得：\n$$6=\\ell_{31}^2+\\ell_{32}^2+\\ell_{33}^2\n=1^2+\\Bigl(-\\tfrac1{\\sqrt{19}}\\Bigr)^2+\\ell_{33}^2\n=1+\\frac1{19}+\\ell_{33}^2\n=\\frac{20}{19}+\\ell_{33}^2,$$\n因此\n$$\\ell_{33}^2\n=6-\\frac{20}{19}\n=\\frac{114-20}{19}\n=\\frac{94}{19}\n\\quad\\Longrightarrow\\quad\n\\ell_{33}=\\sqrt{\\frac{94}{19}}.$$", "answer": "$$\\boxed{\\sqrt{\\frac{94}{19}}}$$", "id": "950176"}, {"introduction": "在金融实践中，我们从市场数据中估计出的经验协方差矩阵，由于抽样误差或资产间的共线性，往往并非严格正定。这给需要正定输入的 Cholesky 分解带来了现实挑战。本练习 [@problem_id:2379720] 介绍了一种名为“正则化”的标准技术，通过对矩阵进行微小的调整，使其能够进行 Cholesky 分解，同时最大限度地保留其原有的相关性结构。", "problem": "考虑一个对称矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，它代表了计算经济学和金融学中资产回报的经验协方差估计。数值估计误差可能导致 $\\Sigma$ 不是严格正定的。对于给定的非负标量 $\\delta \\in \\mathbb{R}$，定义移位矩阵 $\\Sigma_{\\delta} = \\Sigma + \\delta I$，其中 $I$ 是相容维度的单位矩阵。采用下限参数为 $\\alpha = 10^{-8}$ 的数值严格正定性准则：如果一个矩阵 $M$ 的最小特征值至少为 $\\alpha$，则该矩阵被视为数值上严格正定的。任务是为每个提供的测试用例，确定最小的非负标量 $\\delta$，使得 $\\Sigma_{\\delta}$ 在此准则下是数值上严格正定的。您的程序必须为每个测试用例独立计算这个最小的 $\\delta$ 并报告结果。\n\n测试套件参数：\n- 下限参数：$\\alpha = 10^{-8}$。\n- 测试用例 $\\Sigma$ 矩阵（每个都是对称的）：\n  1. $\\Sigma^{(1)} = \\begin{bmatrix} 0.98  0.99  0.99 \\\\ 0.99  0.98  0.99 \\\\ 0.99  0.99  0.98 \\end{bmatrix}$。\n  2. $\\Sigma^{(2)} = \\begin{bmatrix} 2.0  0.0 \\\\ 0.0  3.0 \\end{bmatrix}$。\n  3. $\\Sigma^{(3)} = \\begin{bmatrix} 1.0  1.0 \\\\ 1.0  1.0 \\end{bmatrix}$。\n  4. $\\Sigma^{(4)} = \\begin{bmatrix} 1.0  0.2  0.0 \\\\ 0.2  -0.1  0.0 \\\\ 0.0  0.0  0.5 \\end{bmatrix}$。\n  5. $\\Sigma^{(5)} = \\begin{bmatrix} 1.0  0.99999999 \\\\ 0.99999999  1.0 \\end{bmatrix}$。\n\n答案规格：\n- 对于每个 $\\Sigma^{(k)}$，输出最小的非负标量 $\\delta^{(k)}$，使得 $\\Sigma^{(k)} + \\delta^{(k)} I$ 的最小特征值至少为 $\\alpha$。\n- 将每个 $\\delta^{(k)}$ 报告为小数点后恰好保留 $10$ 位的十进制数。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述顺序排列，例如 $\\left[\\delta^{(1)},\\delta^{(2)},\\dots\\right]$。", "solution": "该问题是数值线性代数中一个定义明确的练习，具体涉及对称矩阵的正则化，以确保它们在数值上是正定的。这在计算金融和统计学中是一项常见而实际的任务，其中从数据估计的协方差矩阵可能由于抽样误差或资产回报之间的多重共线性而未能严格正定。\n\n我们的目标是对于给定的对称矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，找到最小的非负标量 $\\delta$，使得矩阵 $\\Sigma_{\\delta} = \\Sigma + \\delta I$ 在数值上是严格正定的。其准则是 $\\Sigma_{\\delta}$ 的最小特征值必须大于或等于指定的下限参数 $\\alpha = 10^{-8}$。\n\n我们来分析将矩阵 $\\delta I$ 加到 $\\Sigma$ 上对 $\\Sigma$ 的特征值产生的影响。由于 $\\Sigma$ 是一个实对称矩阵，它有 $n$ 个实特征值，记为 $\\lambda_1, \\lambda_2, \\dots, \\lambda_n$。设 $v_i$ 是对应于特征值 $\\lambda_i$ 的特征向量。根据定义：\n$$\n\\Sigma v_i = \\lambda_i v_i\n$$\n现在，考虑移位矩阵 $\\Sigma_{\\delta}$ 对同一特征向量 $v_i$ 的作用：\n$$\n\\Sigma_{\\delta} v_i = (\\Sigma + \\delta I) v_i = \\Sigma v_i + \\delta I v_i = \\lambda_i v_i + \\delta v_i = (\\lambda_i + \\delta) v_i\n$$\n此方程表明 $v_i$ 也是 $\\Sigma_{\\delta}$ 的一个特征向量，其对应的特征值为 $(\\lambda_i + \\delta)$。这个关系对 $\\Sigma$ 的所有特征向量都成立。因此，$\\Sigma_{\\delta}$ 的特征值集合是 $\\{\\lambda_1 + \\delta, \\lambda_2 + \\delta, \\dots, \\lambda_n + \\delta\\}$。\n\n因此，$\\Sigma_{\\delta}$ 的最小特征值（记为 $\\lambda_{\\min}(\\Sigma_{\\delta})$）与 $\\Sigma$ 的最小特征值（记为 $\\lambda_{\\min}(\\Sigma)$）之间存在简单的加法关系：\n$$\n\\lambda_{\\min}(\\Sigma_{\\delta}) = \\lambda_{\\min}(\\Sigma) + \\delta\n$$\n问题施加了数值严格正定性的条件：\n$$\n\\lambda_{\\min}(\\Sigma_{\\delta}) \\ge \\alpha\n$$\n将我们推导出的关系代入这个不等式，得到：\n$$\n\\lambda_{\\min}(\\Sigma) + \\delta \\ge \\alpha\n$$\n我们必须找到满足此不等式的最小 $\\delta$ 值，同时满足 $\\delta$ 必须为非负的约束，即 $\\delta \\ge 0$。\n\n从不等式中分离出 $\\delta$：\n$$\n\\delta \\ge \\alpha - \\lambda_{\\min}(\\Sigma)\n$$\n为了同时满足这个条件和非负约束 $\\delta \\ge 0$，我们必须选择 $\\delta$ 为 $0$ 和 $\\alpha - \\lambda_{\\min}(\\Sigma)$ 中的最大值。任何更小的值都将违反特征值条件或非负约束。因此，最小的非负标量 $\\delta$ 由以下公式给出：\n$$\n\\delta = \\max(0, \\alpha - \\lambda_{\\min}(\\Sigma))\n$$\n这个公式提供了完整的解决方案。\n\n- 如果 $\\lambda_{\\min}(\\Sigma) \\ge \\alpha$，则矩阵 $\\Sigma$ 已经是数值上严格正定的。在这种情况下，$\\alpha - \\lambda_{\\min}(\\Sigma) \\le 0$，公式正确地得出 $\\delta = \\max(0, \\text{非正值}) = 0$。不需要进行移位。\n- 如果 $\\lambda_{\\min}(\\Sigma)  \\alpha$，则矩阵 $\\Sigma$ 不是数值上严格正定的。所需的移位是 $\\delta = \\alpha - \\lambda_{\\min}(\\Sigma) > 0$。这个移位将每个特征值精确地增加了将最小特征值提升到下限 $\\alpha$ 所需的量。\n\n解决每个测试用例 $\\Sigma^{(k)}$ 的算法如下：\n1.  对于给定的矩阵 $\\Sigma^{(k)}$，计算其所有特征值。\n2.  找出最小特征值 $\\lambda_{\\min}(\\Sigma^{(k)})$。\n3.  使用推导出的公式计算所需的最小非负移位 $\\delta^{(k)}$：\n    $$\n    \\delta^{(k)} = \\max(0, \\alpha - \\lambda_{\\min}(\\Sigma^{(k)}))\n    $$\n    其中 $\\alpha = 10^{-8}$。\n4.  报告计算出的 $\\delta^{(k)}$，并按要求格式化。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the smallest non-negative scalar delta to make a matrix numerically\n    strictly positive definite.\n    \"\"\"\n    \n    # Floor parameter for numerical strict-positivity criterion.\n    alpha = 1e-8\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([[0.98, 0.99, 0.99], [0.99, 0.98, 0.99], [0.99, 0.99, 0.98]]),\n        np.array([[2.0, 0.0], [0.0, 3.0]]),\n        np.array([[1.0, 1.0], [1.0, 1.0]]),\n        np.array([[1.0, 0.2, 0.0], [0.2, -0.1, 0.0], [0.0, 0.0, 0.5]]),\n        np.array([[1.0, 0.99999999], [0.99999999, 1.0]]),\n    ]\n    \n    results = []\n    for sigma_matrix in test_cases:\n        # For a real symmetric matrix, eigvalsh is preferred for numerical stability\n        # and efficiency. It returns the eigenvalues in ascending order.\n        eigenvalues = np.linalg.eigvalsh(sigma_matrix)\n        \n        # The smallest eigenvalue is the first element of the sorted list.\n        lambda_min = eigenvalues[0]\n        \n        # The minimal non-negative scalar delta is derived from the condition:\n        # lambda_min + delta >= alpha\n        # delta >= alpha - lambda_min\n        # Since delta must be non-negative, delta = max(0, alpha - lambda_min).\n        delta = max(0.0, alpha - lambda_min)\n        \n        results.append(delta)\n        \n    # Format the results to exactly 10 decimal places as specified.\n    formatted_results = [f\"{r:.10f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2379720"}, {"introduction": "Cholesky 分解在量化金融中的一个核心应用是通过蒙特卡罗方法为衍生品定价，其关键在于生成相关的随机变量来模拟资产价格路径。这个压轴练习 [@problem_id:2379747] 不仅展示了如何正确使用 Cholesky 因子 $L$ 来引入资产间的相关性，更巧妙地揭示了一个常见却致命的实施错误。通过比较正确与错误方法所产生的协方差结构和期权价格，你将学会如何诊断和避免这类模型风险。", "problem": "您的任务是诊断在蒙特卡洛（MC）模拟中错误使用Cholesky分解所产生的影响，该模拟用于在多资产几何布朗运动（GBM）模型下，为加权资产组合的欧式看涨期权定价。设瞬时相关矩阵为$\\mathbf{R}$，波动率向量为$\\boldsymbol{\\sigma}$，到期时间为$T$，连续复利无风险利率为$r$。将高斯对数收益创新的目标协方差矩阵定义为\n$$\n\\boldsymbol{\\Sigma} = \\left(\\operatorname{diag}(\\boldsymbol{\\sigma}) \\, \\mathbf{R} \\, \\operatorname{diag}(\\boldsymbol{\\sigma})\\right) \\, T.\n$$\n设$\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^{\\top}$是Cholesky分解，其中$\\mathbf{L}$是具有严格正对角线元素的下三角矩阵。考虑作用于独立标准正态向量$\\mathbf{z} \\sim \\mathcal{N}(\\mathbf{0},\\mathbf{I})$的两个线性映射：\n- $\\mathbf{f}(\\mathbf{z}) = \\mathbf{L}\\mathbf{z}$，\n- $\\mathbf{g}(\\mathbf{z}) = \\mathbf{L}^{\\top}\\mathbf{z}$。\n对于下述每个测试用例，抽取$N$个独立同分布的样本$\\{\\mathbf{z}^{(n)}\\}_{n=1}^{N}$，其中每个$\\mathbf{z}^{(n)} \\in \\mathbb{R}^d$都具有独立的标准正态分量，并通过将$\\mathbf{f}$和$\\mathbf{g}$逐行应用于样本矩阵$\\mathbf{Z}$（其行为$\\mathbf{z}^{(n)}$）来构建模拟的创新矩阵$\\mathbf{X}_{\\text{right}}$和$\\mathbf{X}_{\\text{wrong}}$。使用这些抽样，为每个测试用例执行以下两项操作：\n1. 计算经验协方差矩阵\n$$\n\\widehat{\\boldsymbol{\\Sigma}}_{\\text{right}} = \\frac{1}{N}\\sum_{n=1}^{N}\\left(\\mathbf{f}(\\mathbf{z}^{(n)}) - \\bar{\\mathbf{x}}_{\\text{right}}\\right)\\left(\\mathbf{f}(\\mathbf{z}^{(n)}) - \\bar{\\mathbf{x}}_{\\text{right}}\\right)^{\\top},\n\\quad\n\\bar{\\mathbf{x}}_{\\text{right}} = \\frac{1}{N}\\sum_{n=1}^{N} \\mathbf{f}(\\mathbf{z}^{(n)}),\n$$\n和\n$$\n\\widehat{\\boldsymbol{\\Sigma}}_{\\text{wrong}} = \\frac{1}{N}\\sum_{n=1}^{N}\\left(\\mathbf{g}(\\mathbf{z}^{(n)}) - \\bar{\\mathbf{x}}_{\\text{wrong}}\\right)\\left(\\mathbf{g}(\\mathbf{z}^{(n)}) - \\bar{\\mathbf{x}}_{\\text{wrong}}\\right)^{\\top},\n\\quad\n\\bar{\\mathbf{x}}_{\\text{wrong}} = \\frac{1}{N}\\sum_{n=1}^{N} \\mathbf{g}(\\mathbf{z}^{(n)}).\n$$\n使用弗罗贝尼乌斯范数（Frobenius norm）误差来衡量与目标协方差$\\boldsymbol{\\Sigma}$的不匹配程度\n$$\ne_{\\text{right}} = \\left\\| \\widehat{\\boldsymbol{\\Sigma}}_{\\text{right}} - \\boldsymbol{\\Sigma} \\right\\|_{F},\n\\quad\ne_{\\text{wrong}} = \\left\\| \\widehat{\\boldsymbol{\\Sigma}}_{\\text{wrong}} - \\boldsymbol{\\Sigma} \\right\\|_{F}.\n$$\n2. 通过模拟终端价格，为权重为$\\mathbf{w}$、执行价为$K$、初始价格为$\\mathbf{S}_0$的加权资产组合上的欧式看涨期权定价\n$$\n\\mathbf{S}_T^{\\text{right},(n)} = \\mathbf{S}_0 \\odot \\exp\\left( \\left(r\\mathbf{1} - \\tfrac{1}{2}\\boldsymbol{\\sigma}\\odot\\boldsymbol{\\sigma}\\right) T + \\mathbf{f}(\\mathbf{z}^{(n)}) \\right),\n\\quad\n\\mathbf{S}_T^{\\text{wrong},(n)} = \\mathbf{S}_0 \\odot \\exp\\left( \\left(r\\mathbf{1} - \\tfrac{1}{2}\\boldsymbol{\\sigma}\\odot\\boldsymbol{\\sigma}\\right) T + \\mathbf{g}(\\mathbf{z}^{(n)}) \\right),\n$$\n其中$\\odot$表示逐元素乘法，指数函数也逐元素应用。对于每个映射，计算资产组合$\\mathbf{w}^{\\top}\\mathbf{S}_T$上期权价格的贴现MC估计值，其收益为$\\max(\\mathbf{w}^{\\top}\\mathbf{S}_T - K, 0)$：\n$$\nP_{\\text{right}} = e^{-rT} \\cdot \\frac{1}{N} \\sum_{n=1}^{N} \\max\\!\\left(\\mathbf{w}^{\\top}\\mathbf{S}_T^{\\text{right},(n)} - K, 0\\right),\n\\quad\nP_{\\text{wrong}} = e^{-rT} \\cdot \\frac{1}{N} \\sum_{n=1}^{N} \\max\\!\\left(\\mathbf{w}^{\\top}\\mathbf{S}_T^{\\text{wrong},(n)} - K, 0\\right).\n$$\n在每个测试用例中，对两种映射使用同一组$\\{\\mathbf{z}^{(n)}\\}$。请精确使用提供的随机种子以确保可复现性。不涉及角度；无需单位转换。\n\n测试套件。对于每个测试用例，所有向量均按资产指数一致排序。\n- 测试用例 1 (维度 $d=2$):\n  - $\\mathbf{S}_0 = [\\,100.0,\\,100.0\\,]$, $\\mathbf{w} = [\\,0.5,\\,0.5\\,]$, $K = 100.0$,\n  - $\\boldsymbol{\\sigma} = [\\,0.2,\\,0.3\\,]$, \n  - $\\mathbf{R} = \\begin{bmatrix} 1  0.7 \\\\ 0.7  1 \\end{bmatrix}$,\n  - $r = 0.02$, $T = 1.0$, $N = 200000$, 随机种子 $= 20231105$。\n- 测试用例 2 (维度 $d=3$):\n  - $\\mathbf{S}_0 = [\\,95.0,\\,105.0,\\,100.0\\,]$, $\\mathbf{w} = [\\,0.2,\\,0.5,\\,0.3\\,]$, $K = 100.0$,\n  - $\\boldsymbol{\\sigma} = [\\,0.25,\\,0.4,\\,0.3\\,]$, \n  - $\\mathbf{R} = \\begin{bmatrix} 1  -0.5  0.1 \\\\ -0.5  1  0.2 \\\\ 0.1  0.2  1 \\end{bmatrix}$,\n  - $r = 0.01$, $T = 2.0$, $N = 200000$, 随机种子 $= 20231106$。\n- 测试用例 3 (维度 $d=4$):\n  - $\\mathbf{S}_0 = [\\,120.0,\\,80.0,\\,100.0,\\,110.0\\,]$, $\\mathbf{w} = [\\,0.1,\\,0.3,\\,0.4,\\,0.2\\,]$, $K = 105.0$,\n  - $\\boldsymbol{\\sigma} = [\\,0.15,\\,0.25,\\,0.2,\\,0.3\\,]$, \n  - $\\mathbf{R} = \\begin{bmatrix} 1  0.6  0.3  0.0 \\\\ 0.6  1  -0.2  0.1 \\\\ 0.3  -0.2  1  0.4 \\\\ 0.0  0.1  0.4  1 \\end{bmatrix}$,\n  - $r = 0.03$, $T = 0.5$, $N = 200000$, 随机种子 $= 20231107$。\n\n要求的最终输出。您的程序必须生成单行输出，包含一个由方括号括起来的逗号分隔列表。该列表必须按顺序包含测试用例1、2、3的四个浮点数\n$$\n\\left[e_{\\text{wrong}},\\, e_{\\text{right}},\\, P_{\\text{wrong}},\\, P_{\\text{right}}\\right],\n$$\n这三个测试用例的结果被平铺展开。具体而言，输出必须是\n$$\n\\big[ e_{\\text{wrong},1},\\, e_{\\text{right},1},\\, P_{\\text{wrong},1},\\, P_{\\text{right},1},\\, e_{\\text{wrong},2},\\, e_{\\text{right},2},\\, P_{\\text{wrong},2},\\, P_{\\text{right},2},\\, e_{\\text{wrong},3},\\, e_{\\text{right},3},\\, P_{\\text{wrong},3},\\, P_{\\text{right},3} \\big].\n$$", "solution": "该问题是计算金融领域一个有效的练习，旨在诊断在实现多资产模型的蒙特卡洛模拟时一个常见但关键的错误。本解答将首先阐述其数学原理，然后概述计算过程。\n\n核心原理是通过线性变换生成相关的随机向量。设 $\\mathbf{z}$ 为一个 $d$ 维随机向量，其分量是独立的标准正态随机变量。这意味着其期望是零向量，$\\mathbb{E}[\\mathbf{z}] = \\mathbf{0}$，其协方差矩阵是单位矩阵，$\\operatorname{Cov}(\\mathbf{z}) = \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top] = \\mathbf{I}$。我们的目标是生成一个新的随机向量 $\\mathbf{x}$，使其具有一个指定的目标协方差矩阵 $\\boldsymbol{\\Sigma}$。通过应用一个线性变换 $\\mathbf{x} = \\mathbf{A}\\mathbf{z}$（其中 $\\mathbf{A}$ 是一个 $d \\times d$ 矩阵）来实现这一目标。所得向量 $\\mathbf{x}$ 的协方差为：\n$$ \\operatorname{Cov}(\\mathbf{x}) = \\mathbb{E}[\\mathbf{x}\\mathbf{x}^\\top] = \\mathbb{E}[(\\mathbf{A}\\mathbf{z})(\\mathbf{A}\\mathbf{z})^\\top] = \\mathbb{E}[\\mathbf{A}\\mathbf{z}\\mathbf{z}^\\top\\mathbf{A}^\\top] = \\mathbf{A}\\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top]\\mathbf{A}^\\top = \\mathbf{A}\\mathbf{I}\\mathbf{A}^\\top = \\mathbf{A}\\mathbf{A}^\\top. $$\n为确保 $\\operatorname{Cov}(\\mathbf{x}) = \\boldsymbol{\\Sigma}$，我们必须找到一个矩阵 $\\mathbf{A}$ 使得 $\\mathbf{A}\\mathbf{A}^\\top = \\boldsymbol{\\Sigma}$。Cholesky 分解提供了这样一个矩阵。由于目标协方差矩阵 $\\boldsymbol{\\Sigma}$ 是对称正定的，存在一个唯一的具有严格正对角线元素的下三角矩阵 $\\mathbf{L}$，使得 $\\boldsymbol{\\Sigma} = \\mathbf{L}\\mathbf{L}^\\top$。因此，正确的变换是 $\\mathbf{f}(\\mathbf{z}) = \\mathbf{L}\\mathbf{z}$。\n\n问题中指定了一个错误的替代变换 $\\mathbf{g}(\\mathbf{z}) = \\mathbf{L}^\\top\\mathbf{z}$。我们来分析这个映射产生的协方差结构。设 $\\mathbf{y} = \\mathbf{g}(\\mathbf{z})$，其协方差矩阵为：\n$$ \\operatorname{Cov}(\\mathbf{y}) = \\mathbb{E}[(\\mathbf{L}^\\top\\mathbf{z})(\\mathbf{L}^\\top\\mathbf{z})^\\top] = \\mathbf{L}^\\top \\mathbb{E}[\\mathbf{z}\\mathbf{z}^\\top] (\\mathbf{L}^\\top)^\\top = \\mathbf{L}^\\top\\mathbf{I}\\mathbf{L} = \\mathbf{L}^\\top\\mathbf{L}. $$\n由于矩阵乘法不具有交换性，通常情况下 $\\mathbf{L}\\mathbf{L}^\\top \\neq \\mathbf{L}^\\top\\mathbf{L}$。因此，错误的变换生成的随机向量其协方差矩阵为 $\\mathbf{L}^\\top\\mathbf{L}$，而不是所期望的目标 $\\boldsymbol{\\Sigma}$。\n\n计算过程遵循此分析：\n1. 对于每个测试用例，我们首先使用提供的参数 $\\boldsymbol{\\sigma}$、$\\mathbf{R}$ 和 $T$ 构建目标协方差矩阵 $\\boldsymbol{\\Sigma}$，然后计算其 Cholesky 因子 $\\mathbf{L}$。\n2. 使用指定的随机种子，我们生成一个大小为 $N \\times d$ 的矩阵 $\\mathbf{Z}$，其中每一行都是来自 $\\mathcal{N}(\\mathbf{0},\\mathbf{I})$ 的独立样本。\n3. 我们生成两组相关的随机增量。当样本向量 $\\mathbf{z}^{(n)}$ 为行向量时，正确的变换是 $\\mathbf{z}^{(n)}\\mathbf{L}^\\top$，其协方差为 $\\mathbf{L}\\mathbf{L}^\\top=\\boldsymbol{\\Sigma}$。因此，对于所有样本组成的矩阵 $\\mathbf{Z}$，我们计算 $\\mathbf{X}_{\\text{right}} = \\mathbf{Z}\\mathbf{L}^\\top$。错误的情况是计算 $\\mathbf{X}_{\\text{wrong}} = \\mathbf{Z}\\mathbf{L}$，其协方差为 $\\mathbf{L}^\\top\\mathbf{L}$。\n4. 我们从样本矩阵 $\\mathbf{X}_{\\text{right}}$ 和 $\\mathbf{X}_{\\text{wrong}}$ 中计算经验协方差矩阵 $\\widehat{\\boldsymbol{\\Sigma}}_{\\text{right}}$ 和 $\\widehat{\\boldsymbol{\\Sigma}}_{\\text{wrong}}$。然后使用弗罗贝尼乌斯范数测量它们与目标矩阵 $\\boldsymbol{\\Sigma}$ 的偏差，得到误差 $e_{\\text{right}}$ 和 $e_{\\text{wrong}}$。我们预期 $e_{\\text{right}}$ 会很小（仅反映抽样误差），而 $e_{\\text{wrong}}$ 会很大（反映了根本的模型设定错误）。\n5. 最后，我们为多资产几何布朗运动模拟终端资产价格。使用来自 $\\mathbf{X}_{\\text{right}}$ 和 $\\mathbf{X}_{\\text{wrong}}$ 的向量作为创新项，将得到两组终端价格 $\\mathbf{S}_T^{\\text{right}}$ 和 $\\mathbf{S}_T^{\\text{wrong}}$。基于这些，我们计算资产组合价值、期权收益以及最终的贴现蒙特卡洛价格估计 $P_{\\text{right}}$ 和 $P_{\\text{wrong}}$。第二种情况中不正确的协方差结构将导致期权定价错误，我们的计算将量化这一错误。", "answer": "```python\nimport numpy as np\nimport scipy.linalg\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n\n    def run_simulation(S0, w, K, sigma, R, r, T, N, seed):\n        \"\"\"\n        Runs the Monte Carlo simulation for a single test case.\n        \n        Args:\n            S0 (np.ndarray): Initial asset prices.\n            w (np.ndarray): Asset weights in the basket.\n            K (float): Strike price of the call option.\n            sigma (np.ndarray): Vector of asset volatilities.\n            R (np.ndarray): Correlation matrix of assets.\n            r (float): Risk-free interest rate.\n            T (float): Time to maturity.\n            N (int): Number of Monte Carlo paths.\n            seed (int): Random number generator seed.\n\n        Returns:\n            tuple: A tuple containing (e_wrong, e_right, P_wrong, P_right).\n        \"\"\"\n        # Initialize a random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(seed)\n        d = len(S0)\n\n        # 1. Construct the target covariance matrix Sigma for log-return innovations.\n        # Sigma = (diag(sigma) @ R @ diag(sigma)) * T\n        diag_sigma = np.diag(sigma)\n        Sigma = (diag_sigma @ R @ diag_sigma) * T\n\n        # 2. Perform Cholesky decomposition: Sigma = L @ L.T\n        # We use scipy.linalg.cholesky for robustness, specifying lower=True.\n        L = scipy.linalg.cholesky(Sigma, lower=True)\n\n        # 3. Generate N samples of d-dimensional independent standard normal variates.\n        Z = rng.standard_normal(size=(N, d))\n\n        # 4. Generate correlated random shocks using right and wrong transformations.\n        # Right method: rows of X_right are samples with covariance L @ L.T = Sigma\n        X_right = Z @ L.T\n        # Wrong method: rows of X_wrong are samples with covariance L.T @ L\n        X_wrong = Z @ L\n\n        # 5. Compute empirical covariance matrices and their errors.\n        # The problem specifies normalization by N, so we set ddof=0.\n        Sigma_hat_right = np.cov(X_right, rowvar=False, ddof=0)\n        Sigma_hat_wrong = np.cov(X_wrong, rowvar=False, ddof=0)\n        \n        # Calculate Frobenius norm of errors relative to the target Sigma.\n        e_right = np.linalg.norm(Sigma_hat_right - Sigma, 'fro')\n        e_wrong = np.linalg.norm(Sigma_hat_wrong - Sigma, 'fro')\n\n        # 6. Price the European call option on the basket.\n        # Calculate the drift term for the GBM price simulation.\n        drift = (r - 0.5 * sigma**2) * T\n\n        # Simulate terminal asset prices for both sets of shocks.\n        S_T_right = S0 * np.exp(drift + X_right)\n        S_T_wrong = S0 * np.exp(drift + X_wrong)\n\n        # Calculate the value of the basket for each simulation path.\n        basket_val_right = S_T_right @ w\n        basket_val_wrong = S_T_wrong @ w\n\n        # Calculate the payoff of the call option for each path.\n        payoff_right = np.maximum(basket_val_right - K, 0)\n        payoff_wrong = np.maximum(basket_val_wrong - K, 0)\n\n        # Calculate the discounted average payoff (Monte Carlo price).\n        P_right = np.exp(-r * T) * np.mean(payoff_right)\n        P_wrong = np.exp(-r * T) * np.mean(payoff_wrong)\n\n        return e_wrong, e_right, P_wrong, P_right\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {\n            \"S0\": np.array([100.0, 100.0]), \"w\": np.array([0.5, 0.5]), \"K\": 100.0,\n            \"sigma\": np.array([0.2, 0.3]), \"R\": np.array([[1, 0.7], [0.7, 1]]),\n            \"r\": 0.02, \"T\": 1.0, \"N\": 200000, \"seed\": 20231105\n        },\n        # Test case 2\n        {\n            \"S0\": np.array([95.0, 105.0, 100.0]), \"w\": np.array([0.2, 0.5, 0.3]), \"K\": 100.0,\n            \"sigma\": np.array([0.25, 0.4, 0.3]),\n            \"R\": np.array([[1, -0.5, 0.1], [-0.5, 1, 0.2], [0.1, 0.2, 1]]),\n            \"r\": 0.01, \"T\": 2.0, \"N\": 200000, \"seed\": 20231106\n        },\n        # Test case 3\n        {\n            \"S0\": np.array([120.0, 80.0, 100.0, 110.0]), \"w\": np.array([0.1, 0.3, 0.4, 0.2]), \"K\": 105.0,\n            \"sigma\": np.array([0.15, 0.25, 0.2, 0.3]),\n            \"R\": np.array([[1, 0.6, 0.3, 0.0], [0.6, 1, -0.2, 0.1], [0.3, -0.2, 1, 0.4], [0.0, 0.1, 0.4, 1]]),\n            \"r\": 0.03, \"T\": 0.5, \"N\": 200000, \"seed\": 20231107\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        # Run the simulation for the current case and collect results.\n        results_tuple = run_simulation(**case)\n        all_results.extend(results_tuple)\n\n    # Print the final flattened list of results in the required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2379747"}]}