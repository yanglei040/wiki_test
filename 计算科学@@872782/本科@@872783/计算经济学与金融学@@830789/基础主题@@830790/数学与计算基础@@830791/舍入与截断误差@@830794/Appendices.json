{"hands_on_practices": [{"introduction": "在计算科学中，一些我们深信不疑的数学公式，如二次方程的求根公式，在有限精度计算环境下可能会得出灾难性的错误结果。这个练习将通过一个精心设计的二次方程求解案例，揭示“灾难性抵消”（catastrophic cancellation）这一隐蔽的陷阱，即两个几乎相等的数相减时会导致有效数字的严重损失。解决这个问题不仅需要简单地代入数值，更需要我们批判性地审视公式本身的数值稳定性，并通过巧妙的代数变换找到更稳健的计算路径。", "problem": "考虑二次多项式 $p(x) = x^2 - 10^8 x + 1$。从基本原理出发，推导 $p(x) = 0$ 的两个实数根的精确闭式表达式。然后，使用有限精度浮点运算中的基本舍入模型（如电气与电子工程师协会 (IEEE) $754$ 双精度 (binary$64$) 标准），解释两个精确闭式表达式中的哪一个在计算上是数值不稳定的，并说明原因，指出灾难性抵消的机制。最后，将不稳定的根重写为代数上等价且能避免相减抵消的精确形式。\n\n回答要求：提供两个根的精确符号表达式作为最终答案，无需进行数值近似。不需要舍入。将最终答案表示为一对精确表达式。", "solution": "在尝试任何解答之前，首先对问题陈述进行验证。\n\n首先，我们提取问题的已知条件。\n给定的二次多项式为 $p(x) = x^2 - 10^8 x + 1$。\n问题要求解方程 $p(x) = 0$ 的根。\n数值稳定性分析必须在有限精度浮点运算的背景下进行，特别是要参考电气与电子工程师协会 (IEEE) $754$ 双精度标准。\n任务包括确定从标准二次公式推导出的哪个根表达式由于“灾难性抵消”而数值不稳定，并随后为该根推导一个代数上等价但数值稳定的表达式。\n\n接下来，我们验证问题陈述。\n该问题具有科学依据，因为它涉及数值分析中的一个基本课题：两个几乎相等的数相减时发生的精度损失。这种现象被称为灾难性抵消，是浮点运算中一个被充分理解的后果。该多项式及其系数在数学上是合理的。\n该问题是适定的。它提供了求解根并分析其数值性质所需的所有必要信息（$a=1$, $b=-10^8$, $c=1$）。问题是明确的，并且会导出一组唯一的根的稳定表达式。\n问题是客观的，以精确的数学术语陈述，不含任何主观或推测性内容。\n因此，该问题被认为是有效的，并将提供解答。\n\n待解的二次方程为 $x^2 - 10^8 x + 1 = 0$。\n我们应用二次方程 $ax^2 + bx + c = 0$ 的标准求根公式，其根由 $x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 给出。\n对于给定的多项式，系数为 $a=1$, $b=-10^8$, $c=1$。\n将这些值代入公式，得到：\n$$x = \\frac{-(-10^8) \\pm \\sqrt{(-10^8)^2 - 4(1)(1)}}{2(1)}$$\n$$x = \\frac{10^8 \\pm \\sqrt{10^{16} - 4}}{2}$$\n这给出了两个精确的实数根：\n$$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$$\n$$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n\n现在，我们必须在有限精度算法中分析这些表达式的数值稳定性。潜在不稳定性的来源在于两个几乎相等的量相减。\n让我们检查所涉及项的量级。$10^{16}$ 这一项比 $4$ 大得多。因此，$\\sqrt{10^{16} - 4}$ 的值非常接近 $\\sqrt{10^{16}} = 10^8$。\n为了更清楚地看到这一点，我们可以使用二项式近似。\n$$\\sqrt{10^{16} - 4} = \\sqrt{10^{16}(1 - 4 \\times 10^{-16})} = 10^8 \\sqrt{1 - 4 \\times 10^{-16}}$$\n对于一个很小的值 $\\epsilon$，近似式 $(1 - \\epsilon)^{1/2} \\approx 1 - \\frac{1}{2}\\epsilon$ 成立。这里，$\\epsilon = 4 \\times 10^{-16}$，它非常小。\n因此，$\\sqrt{10^{16} - 4} \\approx 10^8 (1 - \\frac{1}{2}(4 \\times 10^{-16})) = 10^8 (1 - 2 \\times 10^{-16}) = 10^8 - 2 \\times 10^{-8}$。\n$\\sqrt{10^{16} - 4}$ 的值仅略小于 $10^8$。\n\n考虑 $x_1$ 的表达式：$x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个量级相似的大正数相加。在浮点运算中，此操作是数值稳定的。其和的相对误差很小，在机器精度的量级上。\n\n考虑 $x_2$ 的表达式：$x_2 = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$。该表达式涉及两个非常接近的数相减。设 $y = \\sqrt{10^{16} - 4}$。在浮点计算中，$10^8$ 和 $y$ 的计算值将在许多开头的有效数字上一致。当执行减法 $10^8 - y$ 时，这些开头的数字相互抵消，结果由剩下的、较不重要的数字决定，而这些数字又受到计算 $y$ 时产生的舍入误差的严重影响。这种相对误差的巨大增加就是灾难性抵消现象。因此，$x_2$ 的表达式是数值不稳定的，如果使用标准双精度算法直接计算，将得到一个高度不准确的结果。\n\n为了找到 $x_2$ 的一个数值稳定的表达式，我们使用韦达定理，该定理将多项式的系数与其根联系起来。对于二次方程 $ax^2 + bx + c = 0$，其根的乘积由 $x_1 x_2 = \\frac{c}{a}$ 给出。\n对于我们的方程，这给出 $x_1 x_2 = \\frac{1}{1} = 1$。\n我们可以使用其公式精确地计算稳定的根 $x_1$。然后，我们可以从关系式 $x_2 = \\frac{1}{x_1}$ 中求出 $x_2$。\n代入 $x_1$ 的稳定表达式：\n$$x_2 = \\frac{1}{\\frac{10^8 + \\sqrt{10^{16} - 4}}{2}} = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$$\n这个修改后的 $x_2$ 表达式只涉及正数相加和除法，这两种运算都是数值稳定的。它避免了相减抵消，因此是数值计算的首选形式。\n\n我们通过将其分母有理化来验证这个新形式在代数上与原来不稳定的 $x_2$ 形式是等价的：\n$$\\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\cdot \\frac{10^8 - \\sqrt{10^{16} - 4}}{10^8 - \\sqrt{10^{16} - 4}} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{(10^8)^2 - (10^{16} - 4)} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{10^{16} - 10^{16} + 4} = \\frac{2(10^8 - \\sqrt{10^{16} - 4})}{4} = \\frac{10^8 - \\sqrt{10^{16} - 4}}{2}$$\n这证实了代数恒等性。\n\n最终要求的答案包含两个根的精确符号表达式，并已重写为其数值稳定形式。\n较大的根是 $x_1 = \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}$。\n较小的根，其稳定形式为 $x_2 = \\frac{2}{10^8 + \\sqrt{10^{16} - 4}}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{10^8 + \\sqrt{10^{16} - 4}}{2}  \\frac{2}{10^8 + \\sqrt{10^{16} - 4}} \\end{pmatrix}}$$", "id": "2435764"}, {"introduction": "识别出数值计算中的问题是第一步，而更关键的是如何解决它。这个练习以一个简化的信用风险模型为背景，展示了一种在金融计算中修复数值不稳定性的强大工具：使用泰勒级数展开来近似替代函数中不稳定的部分。通过这个实践，你将学会如何在引入的 *截断误差*（truncation error）与我们试图避免的 *舍入误差*（round-off error）之间做出权衡，这是计算经济学和金融学领域一项至关重要的技能。", "problem": "在一个基于强度的违约简化形式信用风险模拟中，公司在长度为 $\\Delta t$ 的短时间步长内，在恒定风险率 $\\lambda$ 下违约的概率由精确表达式 $p(x) = 1 - \\exp(-x)$ 给出，其中 $x = \\lambda \\Delta t$。考虑两种用于计算小 $x$ 值下 $p(x)$ 的浮点算法：算法A直接计算 $1 - \\exp(-x)$，算法B使用二阶泰勒多项式 $x - x^{2}/2$。假设浮点运算采用四舍五入到最近值的方式，单位舍入误差为 $u = 2^{-53}$，并且任何单个运算或 $\\exp(\\cdot)$ 的浮点结果都可以建模为精确结果乘以 $(1 + \\delta)$，其中 $|\\delta| \\leq u$。分析中忽略 $u$ 和截断余数中的一阶以上项。仅使用这些假设和基本原理，确定正值 $x^{\\ast}$，在该值下算法A的主阶相对前向误差等于算法B的主阶相对前向误差。将您的答案四舍五入到四位有效数字。", "solution": "该问题要求找到一个值 $x^*$，在该值下，计算 $p(x) = 1 - \\exp(-x)$ 的两种算法的主阶相对前向误差相等。分析将在所提供的浮点误差模型下，针对小的正值 $x$ 进行。\n\n对于真值 $p(x)$ 的一个近似值 $\\hat{p}(x)$，其相对前向误差定义为 $\\frac{|\\hat{p}(x) - p(x)|}{|p(x)|}$。我们将为每种算法分析该误差的主阶项。\n\n算法A直接将 $p(x)$ 计算为 $f_A(x) = 1 - \\exp(-x)$。浮点运算中的计算过程建模如下。令 $fl(\\cdot)$ 表示一个浮点运算。\n计算 $\\exp(-x)$ 得到一个浮点数 $\\hat{y} = fl(\\exp(-x)) = \\exp(-x)(1 + \\delta_{1})$，其中 $|\\delta_{1}| \\leq u$。\n随后的减法运算给出最终计算值 $\\hat{p}_A(x) = fl(1 - \\hat{y}) = (1 - \\hat{y})(1 + \\delta_{2})$，其中 $|\\delta_{2}| \\leq u$。\n\n代入 $\\hat{y}$ 的表达式：\n$$\n\\hat{p}_A(x) = (1 - \\exp(-x)(1 + \\delta_{1}))(1 + \\delta_{2})\n$$\n展开此式并只保留 $\\delta_i$ 的一阶项：\n$$\n\\hat{p}_A(x) \\approx (1 - \\exp(-x) - \\delta_{1}\\exp(-x))(1 + \\delta_{2}) \\approx 1 - \\exp(-x) + \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)\n$$\n绝对误差为 $E_A(x) = \\hat{p}_A(x) - p(x)$：\n$$\nE_A(x) \\approx [1 - \\exp(-x) + \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)] - [1 - \\exp(-x)] = \\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)\n$$\n因此，算法A的相对误差为：\n$$\n\\text{RelErr}_A(x) = \\frac{|E_A(x)|}{|p(x)|} \\approx \\frac{|\\delta_{2}(1 - \\exp(-x)) - \\delta_{1}\\exp(-x)|}{|1 - \\exp(-x)|} = \\left| \\delta_{2} - \\delta_{1} \\frac{\\exp(-x)}{1 - \\exp(-x)} \\right|\n$$\n对于小的正数 $x  0$，我们有 $\\exp(-x) \\approx 1$ 且 $1 - \\exp(-x) \\approx x$。分数 $\\frac{\\exp(-x)}{1 - \\exp(-x)} \\approx \\frac{1}{x}$，当 $x \\to 0$ 时，该值变得非常大。这一项在误差中占主导地位，是灾难性抵消的典型案例。通过将 $|\\delta_{1}|$ 最大化到 $u$ 来获得主阶最坏情况相对误差：\n$$\n\\text{RelErr}_A(x) \\approx u \\frac{\\exp(-x)}{1 - \\exp(-x)}\n$$\n\n算法B使用二阶泰勒多项式 $f_B(x) = x - \\frac{x^2}{2}$。该算法的误差有两个组成部分：截断误差和舍入误差。\n截断误差源于用有限多项式近似 $p(x)$。$p(x)$ 在 $x=0$ 附近的泰勒级数为：\n$$\np(x) = 1 - \\exp(-x) = 1 - \\left(1 - x + \\frac{x^2}{2!} - \\frac{x^3}{3!} + \\dots \\right) = x - \\frac{x^2}{2} + \\frac{x^3}{6} - \\dots\n$$\n截断误差为 $T_B(x) = p(x) - f_B(x) = (\\frac{x^3}{6} - \\dots)$。主阶项是 $\\frac{x^3}{6}$。\n相应的相对截断误差为：\n$$\n\\text{RelTruncErr}_B(x) = \\frac{|T_B(x)|}{|p(x)|} \\approx \\frac{|x^3/6|}{|x|} = \\frac{x^2}{6}\n$$\n计算 $x - \\frac{x^2}{2}$ 时的舍入误差对于小 $x$ 来说很小，因为该运算不会遭受灾难性抵消。标准分析表明，相对舍入误差受单位舍入误差 $u$ 的一个小的倍数限制。对于该近似有效的小 $x$ 值，截断误差项 $\\frac{x^2}{6}$ 显著大于量级为 $u$ 的舍入误差项。因此，算法B的主阶误差是其截断误差。\n$$\n\\text{RelErr}_B(x) \\approx \\frac{x^2}{6}\n$$\n我们需要找到主阶相对误差相等时的值 $x^*$：\n$$\n\\text{RelErr}_A(x^*) = \\text{RelErr}_B(x^*) \\implies u \\frac{\\exp(-x^*)}{1 - \\exp(-x^*)} = \\frac{(x^*)^2}{6}\n$$\n为了求解 $x^*$，我们对左侧的项使用小 $x$ 近似，因为这是问题所处的范围。对于小的 $x^*$，$\\exp(-x^*) \\approx 1$ 且 $1 - \\exp(-x^*) \\approx x^*$。方程简化为：\n$$\n\\frac{u}{x^*} \\approx \\frac{(x^*)^2}{6}\n$$\n求解 $x^*$：\n$$\n(x^*)^3 = 6u\n$$\n$$\nx^* = (6u)^{1/3}\n$$\n现在，我们代入给定值 $u = 2^{-53}$：\n$$\nx^* = (6 \\cdot 2^{-53})^{1/3} = 6^{1/3} \\cdot 2^{-53/3}\n$$\n我们计算数值：\n$$\nx^* \\approx (6 \\cdot (1.110223 \\times 10^{-16}))^{1/3} = (6.661338 \\times 10^{-16})^{1/3} \\approx 8.732892 \\times 10^{-6}\n$$\n将结果四舍五入到四位有效数字得到：\n$$\nx^* \\approx 8.733 \\times 10^{-6}\n$$\n在 $x^*$ 这个值上，算法B的相对截断误差约为 $\\frac{(x^*)^2}{6} \\approx \\frac{(8.733 \\times 10^{-6})^2}{6} \\approx 1.27 \\times 10^{-11}$，这确实远大于 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。这证实了忽略算法B的舍入误差是一个有效的简化。", "answer": "$$\n\\boxed{8.733 \\times 10^{-6}}\n$$", "id": "2427694"}, {"introduction": "除了单步运算中的灾难性抵消，金融数据分析中另一个常见挑战是在处理长时间序列数据时微小误差的累积。例如，在汇总成千上万个每日资产回报率时，朴素的求和方法会因重复的舍入而逐渐丢失精度。本练习将引导你实现并评估 Kahan 求和算法，这是一种经典的补偿求和技术，它能有效追踪并修正每一步运算中“丢失”的尾数，从而在不改变求和顺序的情况下，显著提高长序列求和的准确性。", "problem": "在计算经济学和金融学中，您有一项任务是量化在聚合长序列的小额资产回报时浮点舍入误差的影响，并使用补偿求和算法来减轻这种影响。考虑一个实值回报序列 $\\{r_i\\}_{i=1}^n$，其数学上精确的累积回报是实数和 $S = \\sum_{i=1}^n r_i$。在实际的二进制浮点运算中，加法操作由标准浮点舍入模型建模：对于任意两个实数 $a$ 和 $b$，其和的计算值为 $\\operatorname{fl}(a+b) = (a+b)(1+\\delta)$，其中 $|\\delta| \\le u$，$u$ 是单位舍入误差，例如对于 64 位二进制浮点数，$u = 2^{-53}$。在包含不同数量级和符号的长序列求和中，朴素的从左到右求和会累积舍入误差，并可能丢失低位比特，尤其是在将非常小的值加到一个大得多的部分和上时。这种现象在聚合长期的小额日回报时尤为重要。\n\n您的任务是编写一个完整的、可运行的程序，该程序：\n- 实现两种方法，用浮点运算对给定的有序回报序列求和：\n  1. 一种朴素的从左到右求和，累加到一个标量中。\n  2. Kahan 提出的补偿求和方法，该方法在不改变序列顺序的情况下，跟踪并校正因舍入而丢失的低位比特。\n- 使用精确有理数算术计算数学上精确的和 $S$ 的高精度基准。方法是将每个回报解释为分母固定为 $D = 10^{16}$ 的小数，并将分子作为整数求和。具体来说，对于每个小数点后最多有 $16$ 位的小数回报 $r_i$，将其解释为精确有理数 $\\frac{\\lfloor r_i \\cdot D \\rceil}{D}$，其中对于下面提供的值，舍入是精确的（对于给定的测试套件，无需舍入）。然后用整数精确计算 $S = \\frac{1}{D}\\sum_{i=1}^n (r_i \\cdot D)$，仅为了报告绝对误差才将 $S$ 转换为浮点数。\n- 对于每个测试序列，报告两个浮点数形式的绝对误差：$|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$，以及一个布尔值，指示 Kahan 补偿误差是否严格小于朴素误差。\n\n重要说明：\n- 将回报视为无单位的十进制数（不要使用百分号）。不涉及物理单位或角度单位。\n- 所有求和必须按指定顺序执行；不允许重新排序。\n- 最终输出必须将所有测试用例的结果汇总到一行，形式为方括号内包含的逗号分隔列表。此列表的每个元素本身都必须是 $[e_n, e_k, b]$ 形式的列表，其中 $e_n$ 是朴素求和的绝对误差（一个浮点数），$e_k$ 是 Kahan 补偿求和的绝对误差（一个浮点数），如果 $e_k  e_n$，则 $b$ 为布尔值 $\\text{True}$，否则为 $\\text{False}$。例如：$[[e_{n,1}, e_{k,1}, b_1],[e_{n,2}, e_{k,2}, b_2],\\dots]$。\n\n测试套件和覆盖范围：\n- 使用以下四个有序序列，每个序列都紧凑地指定为片段 $(v, c)$ 的列表，表示值 $v$ 按该顺序连续出现 $c$ 次。所有值都是十进制字符串，所有计数都是非负整数。每个值的小数点后最多有 $16$ 位数字，因此公分母 $D = 10^{16}$ 对于精确有理数求和是有效的。\n\n  1. 正常路径但易于发生抵消的序列（大偏移量周围的小增量）：\n     - $\\left(\"1.0\",\\, 1\\right)$，然后 $\\left(\"1e-16\",\\, 1000000\\right)$，然后 $\\left(\"-1.0\",\\, 1\\right)$。数学上精确的和是 $S = 10^{6}\\cdot 10^{-16} = 10^{-10}$。\n  2. 围绕零的轻微不平衡的小额正负回报：\n     - $\\left(\"1e-8\",\\, 100000\\right)$，然后 $\\left(\"-1e-8\",\\, 99999\\right)$。数学上精确的和是 $S = 10^{-8}$。\n  3. 全为零的边界情况：\n     - $\\left(\"0.0\",\\, 50000\\right)$。数学上精确的和是 $S = 0$。\n  4. 混合数量级，伴有严重抵消和许多微小项：\n     - $\\left(\"1e-16\",\\, 300000\\right)$，然后 $\\left(\"1.0\",\\, 1\\right)$，然后 $\\left(\"-1.0\",\\, 1\\right)$，然后 $\\left(\"1e-16\",\\, 300000\\right)$，然后 $\\left(\"-1e-16\",\\, 600000\\right)$。数学上精确的和是 $S = 0$。\n\n要求：\n- 按规定实现两种求和方法和精确有理数基准。\n- 对于四个测试序列中的每一个，计算并报告三元组 $[|S_{\\text{naive}}-S|,\\, |S_{\\text{Kahan}}-S|,\\, (|S_{\\text{Kahan}}-S|  |S_{\\text{naive}}-S|)]$。\n- 您的程序应生成一行输出，其中包含这四个三元组的列表，格式完全如下：$[[e_{n,1},e_{k,1},b_1],[e_{n,2},e_{k,2},b_2],[e_{n,3},e_{k,3},b_3],[e_{n,4},e_{k,4},b_4]]$。", "solution": "我们从标准的加法浮点误差模型开始。设 $a$ 和 $b$ 为实数，并假设我们使用“舍入到最近”的二进制浮点运算来计算它们的和。计算结果满足\n$$\n\\operatorname{fl}(a+b) \\;=\\; (a+b)(1+\\delta), \\quad |\\delta| \\le u,\n$$\n其中 $u$ 是单位舍入误差。对于 64 位二进制格式，有 $u = 2^{-53} \\approx 1.11 \\times 10^{-16}$。在对长序列 $\\{r_i\\}_{i=1}^n$ 求和时，朴素的从左到右算法通过 $s \\leftarrow \\operatorname{fl}(s + r_i)$（对于 $i=1,\\dots,n$）来更新一个运行总和 $s$。朴素求和的累积前向误差可以通过后向误差分析的著名结果来界定：粗略地说，绝对误差的增长量级约为 $u$ 乘以各项绝对值之和，即\n$$\n|s_{\\text{naive}} - S| \\lesssim \\gamma_n \\sum_{i=1}^n |r_i|, \\quad \\gamma_n = \\frac{nu}{1 - nu},\n$$\n只要 $nu  1$，这突显了误差 $O(nu)$ 的增长以及对排序和抵消结构的敏感性。特别是，当将非常小的 $r_i$ 加到一个大得多的运行总和 $s$ 中时，如果 $|r_i| \\le \\tfrac{1}{2}\\operatorname{ulp}(s)$，那么 $s + r_i$ 会舍入回 $s$，而 $r_i$ 的低位比特实际上被丢弃了。当聚合大量小额日回报，且时间跨度长，并因巨额收益或损失而产生大偏移量时，这种现象在经济学上就变得很重要了。\n\n为减轻这种损失，Kahan 补偿求和算法引入了一个辅助变量 $c$，用于跟踪因舍入而丢失的低位比特的运行补偿。其思想是从下一个加数中预先减去补偿，并根据上次加法中观察到的舍入误差来更新补偿。具体来说，设 $s$ 为运行总和，$c$ 为补偿，两者都初始化为 $0$。对于每个加数 $x$，定义补偿后的加数 $y = x - c$，并形成临时和 $t = s + y$。新的补偿是 $y$ 中未被 $t$ 捕获的部分，代数上表示为 $c \\leftarrow (t - s) - y$，运行总和更新为 $s \\leftarrow t$。在精确算术中，$(t - s) = y$，所以 $c$ 会保持为零，但在浮点运算中，$(t - s)$ 可能因 $s + y$ 的舍入而与 $y$ 不同，这个差值被存储在 $c$ 中，以便在下一步反馈回来。这为丢失的低位比特提供了一阶校正，并在许多易于发生抵消的情况下显著减少了误差，其误差通常基本上受一个与 $n$ 无关的 $u$ 的常数倍所界定。\n\n为了进行基准测试，我们需要一个数学上精确的和 $S = \\sum_{i=1}^n r_i$ 的基准。由于测试序列表示为最多有 16 位小数的十进制字符串，每个 $r_i$ 都可以精确地表示为分母为 $D = 10^{16}$ 的有理数。因此，如果 $r_i$ 写成十进制字符串，那么 $r_i \\cdot D$ 是一个整数，精确的和为\n$$\nS \\;=\\; \\frac{1}{D} \\sum_{i=1}^n \\left(r_i \\cdot D\\right), \\qquad D = 10^{16}.\n$$\n我们可以通过解析每个十进制字符串 $r_i$ 并乘以 $D$ 来使用整数算术精确计算分子 $\\sum_{i=1}^n (r_i \\cdot D)$，并且只在最后将 $S$ 转换为浮点数，以便计算绝对误差 $|S_{\\text{naive}} - S|$ 和 $|S_{\\text{Kahan}} - S|$。\n\n算法设计：\n- 实现一个生成器，按给定顺序迭代每个测试序列，为朴素求和与 Kahan 求和产生浮点数值。\n- 将朴素求和实现为重复的浮点加法。\n- 实现 Kahan 补偿求和，其中变量 $s$ 和 $c$ 初始化为 $0$，更新步骤如下\n  $$\n  y \\leftarrow x - c,\\quad t \\leftarrow s + y,\\quad c \\leftarrow (t - s) - y,\\quad s \\leftarrow t.\n  $$\n- 通过对分母为 $D = 10^{16}$ 的整数分子求和来实现精确有理数基准：对于每个片段 $(v, c)$，精确计算整数 $n_v = v \\cdot D$ 并将 $c \\cdot n_v$ 加到整数累加器中。精确的和是 $S = N / D$，其中 $N$ 是整数总和。这对于给定的测试套件是有效的，因为每个 $v$ 在小数点后最多有 16 位数字，所以 $v \\cdot D$ 是一个整数。\n- 对于每个测试用例，计算绝对误差 $e_n = |S_{\\text{naive}} - S|$ 和 $e_k = |S_{\\text{Kahan}} - S|$，以及布尔值 $b = (e_k  e_n)$。\n- 为四个指定的序列按顺序生成最终的单行输出，形式为四个三元组 $[e_n, e_k, b]$ 的列表。\n\n测试套件解释：\n1. 序列 1：$\\left(\"1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 1000000\\right)$, $\\left(\"-1.0\",\\, 1\\right)$。这里 $S = 10^6 \\cdot 10^{-16} = 10^{-10}$。朴素求和在将每个 $10^{-16}$ 加到 $1.0$ 时通常会丢失它，在加上最后的 $-1.0$ 后得到一个接近 $0$ 的结果，而 Kahan 求和则在 $c$ 中恢复了低位比特，得到一个接近 $10^{-10}$ 的结果。\n2. 序列 2：$\\left(\"1e-8\",\\, 100000\\right)$, $\\left(\"-1e-8\",\\, 99999\\right)$。这里 $S = 10^{-8}$。两种方法都应该表现良好；与 $S$ 相比，绝对误差预计会非常小。\n3. 序列 3：$\\left(\"0.0\",\\, 50000\\right)$。这里 $S = 0$。在浮点运算中，两种方法都应该精确地得到 $0$，从而产生零绝对误差。\n4. 序列 4：$\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"1.0\",\\, 1\\right)$, $\\left(\"-1.0\",\\, 1\\right)$, $\\left(\"1e-16\",\\, 300000\\right)$, $\\left(\"-1e-16\",\\, 600000\\right)$。这里 $S = 0$。长串的微小项与大的抵消项交织在一起，给两种方法都带来了压力；补偿方法减少了舍入误差的累积。\n\n程序必须实现这些步骤并以完全相同的格式打印单行输出：\n$$\n\\left[\\,[e_{n,1},e_{k,1},b_1],\\,[e_{n,2},e_{k,2},b_2],\\,[e_{n,3},e_{k,3},b_3],\\,[e_{n,4},e_{k,4},b_4]\\,\\right].\n$$", "answer": "```python\nimport math\nfrom decimal import Decimal, getcontext\n\n# No external input; all parameters are embedded per the problem statement.\n\ndef naive_sum(seq_iter):\n    \"\"\"Naive left-to-right summation over an iterator of floats.\"\"\"\n    s = 0.0\n    for x in seq_iter:\n        s += x\n    return s\n\ndef kahan_sum(seq_iter):\n    \"\"\"Kahan compensated summation over an iterator of floats.\"\"\"\n    s = 0.0\n    c = 0.0\n    for x in seq_iter:\n        y = x - c\n        t = s + y\n        c = (t - s) - y\n        s = t\n    return s\n\ndef float_generator_from_segments(segments):\n    \"\"\"\n    Yield floats in the specified order for segments specified as\n    a list of tuples: (value_string, count_int).\n    \"\"\"\n    for v_str, cnt in segments:\n        x = float(v_str)\n        for _ in range(cnt):\n            yield x\n\ndef exact_sum_from_segments(segments, D=10**16):\n    \"\"\"\n    Compute the exact rational sum as N/D where D=10^16, by summing integer numerators.\n    Each value v_str must be a decimal with at most 16 digits after the decimal point.\n    Returns the exact sum as a float for error comparison.\n    \"\"\"\n    # Use high precision Decimal to convert values exactly, then multiply by D to get integer.\n    getcontext().prec = 50\n    D_dec = Decimal(D)\n    N = 0  # integer numerator\n    for v_str, cnt in segments:\n        v_dec = Decimal(v_str)\n        n_v = int((v_dec * D_dec).to_integral_exact())  # exact integer for given test suite\n        if cnt:\n            N += n_v * cnt\n    # Convert to float for error measurement; loss here is negligible vs measured errors\n    return N / D\n\ndef compute_case(segments):\n    \"\"\"Compute absolute errors for naive and Kahan sums against exact rational baseline.\"\"\"\n    true_sum = exact_sum_from_segments(segments)\n    nsum = naive_sum(float_generator_from_segments(segments))\n    ksum = kahan_sum(float_generator_from_segments(segments))\n    en = abs(nsum - true_sum)\n    ek = abs(ksum - true_sum)\n    return [en, ek, ek  en]\n\ndef solve():\n    # Define the test cases as per the problem statement.\n    test_cases = [\n        # 1) (\"1.0\", 1), (\"1e-16\", 1000000), (\"-1.0\", 1)\n        [(\"1.0\", 1), (\"1e-16\", 1_000_000), (\"-1.0\", 1)],\n        # 2) (\"1e-8\", 100000), (\"-1e-8\", 99999)\n        [(\"1e-8\", 100_000), (\"-1e-8\", 99_999)],\n        # 3) (\"0.0\", 50000)\n        [(\"0.0\", 50_000)],\n        # 4) (\"1e-16\", 300000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300000), (\"-1e-16\", 600000)\n        [(\"1e-16\", 300_000), (\"1.0\", 1), (\"-1.0\", 1), (\"1e-16\", 300_000), (\"-1e-16\", 600_000)],\n    ]\n\n    results = []\n    for segments in test_cases:\n        res = compute_case(segments)\n        results.append(res)\n\n    # Print in the exact required single-line format.\n    # Convert booleans and floats to their standard string representations.\n    def fmt(item):\n        if isinstance(item, list):\n            return \"[\" + \",\".join(fmt(x) for x in item) + \"]\"\n        if isinstance(item, bool):\n            return \"True\" if item else \"False\"\n        # float or int\n        return str(item)\n\n    print(fmt(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2427731"}]}