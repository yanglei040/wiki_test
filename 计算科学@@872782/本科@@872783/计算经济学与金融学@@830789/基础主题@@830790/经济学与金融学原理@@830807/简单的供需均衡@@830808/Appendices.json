{"hands_on_practices": [{"introduction": "经典的供需模型通常假设生产者可以灵活地生产任意数量的产品。然而，在现实世界中，工厂或企业通常存在一个最低运营产能，低于该产能则无法开工。这个练习将这种现实约束引入标准的线性供需框架，迫使我们超越简单的代数求解，进行基于逻辑条件的案例分析。你需要首先计算无约束的理论均衡点，然后检查该均衡点在最低产能的限制下是否可行，从而培养对现实世界条件如何塑造市场结果的批判性思维 [@problem_id:2429894]。", "problem": "考虑一个单一商品的竞争市场，其特征是向下倾斜的线性反需求曲线和向上倾斜的线性反供给曲线，其中唯一的供给方是一家工厂，其运营不能低于最低运营能力。设 $Q$ 表示数量，$P$ 表示价格。\n\n需求由反需求函数 $P_{D}(Q) = \\alpha - \\beta Q$（$Q \\ge 0$）给出，其中 $\\alpha  0$ 且 $\\beta  0$。窒息价格为 $P_{choke} = \\alpha$，在该价格下需求量为 $0$。\n\n供给的特点是存在最低运营能力约束：如果工厂运营，其产量必须至少为 $Q_{min}$ 单位。运营时，反供给函数为 $P_{S}(Q) = \\gamma + \\delta Q$（$Q \\ge Q_{min}$），其中 $\\gamma \\ge 0$ 且 $\\delta  0$。如果工厂不运营，市场供给为 $Q_{S} = 0$。\n\n市场均衡点 $(Q^{*}, P^{*})$ 满足市场出清和可行性条件：(i) 工厂运营，此时 $Q^{*} \\ge Q_{min}$，且 $P^{*} = P_{D}(Q^{*}) = P_{S}(Q^{*})$ 及 $P^{*} \\ge 0$；或者 (ii) 工厂不运营，此时 $Q^{*} = 0$，价格必须在需求为零时使市场出清，在这种情况下，选择能够出清市场的最小非负价格，即 $P^{*} = P_{choke} = \\alpha$。\n\n您的任务是编写一个程序，对于下面的每一组参数 $(\\alpha, \\beta, \\gamma, \\delta, Q_{min})$，根据上述定义计算均衡点对 $(Q^{*}, P^{*})$。报告的每个 $Q^{*}$ 和 $P^{*}$ 值需四舍五入到六位小数。\n\n测试集（每个元组为 $(\\alpha, \\beta, \\gamma, \\delta, Q_{min})$）：\n\n- 案例 A：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (100, 1, 10, 1, 20)$。\n- 案例 B：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (100, 1, 10, 1, 60)$。\n- 案例 C：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (90, 1.5, 30, 0.5, 20)$。\n- 案例 D（边界情况）：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (110, 2, 10, 2, 25)$。\n- 案例 E（$Q_{min} = 0$ 的标准情况）：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (80, 2, 20, 4, 0)$。\n- 案例 F（无正数量交点）：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (5, 2, 10, 3, 1)$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的数对列表，顺序与上述案例相同，每个数对格式为 $[Q^{*},P^{*}]$，且两个条目都四舍五入到六位小数。例如，一个使用占位符数字的有效输出将类似于 $[[x_{1},y_{1}],[x_{2},y_{2}],\\dots,[x_{6},y_{6}]]$。", "solution": "首先将对所提供的问题进行严格验证。\n\n### 步骤 1：提取已知信息\n问题提供了以下数据和定义：\n- **反需求函数**：$P_{D}(Q) = \\alpha - \\beta Q$（$Q \\ge 0$），参数 $\\alpha  0$，$\\beta  0$。\n- **反供给函数**：$P_{S}(Q) = \\gamma + \\delta Q$（$Q \\ge Q_{min}$），参数 $\\gamma \\ge 0$，$\\delta  0$。\n- **最低运营能力**：$Q_{min}$。如果工厂不运营，供给为 $Q_{S} = 0$。\n- **均衡定义**：市场均衡点 $(Q^{*}, P^{*})$ 是满足以下两个条件之一的数对：\n    1.  工厂运营：$Q^{*} \\ge Q_{min}$，$P^{*} = P_{D}(Q^{*}) = P_{S}(Q^{*})$，且 $P^{*} \\ge 0$。\n    2.  工厂不运营：$Q^{*} = 0$，市场出清价格为 $P^{*} = P_{choke} = \\alpha$。\n- **测试集**：\n    - 案例 A：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (100, 1, 10, 1, 20)$\n    - 案例 B：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (100, 1, 10, 1, 60)$\n    - 案例 C：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (90, 1.5, 30, 0.5, 20)$\n    - 案例 D：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (110, 2, 10, 2, 25)$\n    - 案例 E：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (80, 2, 20, 4, 0)$\n    - 案例 F：$(\\alpha, \\beta, \\gamma, \\delta, Q_{min}) = (5, 2, 10, 3, 1)$\n\n### 步骤 2：使用提取的已知信息进行验证\n根据既定标准对问题进行验证。\n\n- **科学性**：问题描述了一个带有线性函数和最低产量约束的简单供需模型。这些是微观经济学中的标准基本概念。该问题是科学合理的。\n- **良构性**：问题以数学精度进行了规定。函数、参数和均衡条件都得到了无歧义的定义。参数约束（$\\alpha  0, \\beta  0, \\delta  0, \\gamma \\ge 0$）确保了向下倾斜的需求和向上倾斜的供给具有经济学意义。均衡的两部分定义涵盖了所有可能性，并为每种情况提供了唯一的结果。该问题是良构的。\n- **客观性**：问题陈述纯粹是定量的和定义性的。它不包含任何主观语言或基于观点的断言。它是客观的。\n\n该问题没有表现出科学不合理、不完整或模棱两可等缺陷。它是在计算经济学指定领域内的一个可形式化的问题。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将制定一个解决方案。\n\n### 解决方案的构建\n市场均衡点 $(Q^*, P^*)$ 的确定需要基于所提供的定义进行系统性评估。存在两种可能的均衡类型：一种是正产量均衡，另一种是零产量（停产）均衡。\n\n首先，我们确定一个潜在的正产量均衡。根据定义，如果存在一个数量 $Q_e$ 使得市场出清，即 $P_D(Q_e) = P_S(Q_e)$，那么就存在这种均衡。这是无约束的均衡点。我们求解这个数量，并将其表示为 $Q_e$：\n$$\n\\alpha - \\beta Q_e = \\gamma + \\delta Q_e\n$$\n$$\n\\alpha - \\gamma = (\\beta + \\delta) Q_e\n$$\n$$\nQ_e = \\frac{\\alpha - \\gamma}{\\beta + \\delta}\n$$\n由于 $\\beta  0$ 且 $\\delta  0$，分母 $(\\beta + \\delta)$ 始终为正。相应的均衡价格 $P_e$ 可以通过将 $Q_e$ 代入需求或供给函数求得：\n$$\nP_e = P_D(Q_e) = \\alpha - \\beta \\left( \\frac{\\alpha - \\gamma}{\\beta + \\delta} \\right) = \\frac{\\alpha(\\beta + \\delta) - \\beta(\\alpha - \\gamma)}{\\beta + \\delta} = \\frac{\\alpha\\delta + \\beta\\gamma}{\\beta + \\delta}\n$$\n在约束条件 $\\alpha  0, \\beta  0, \\delta  0, \\gamma \\ge 0$ 下，价格 $P_e$ 始终为非负数。\n\n问题指出，对于正产量均衡，必须满足 $Q^* \\ge Q_{min}$。这种均衡的唯一候选点是 $(Q_e, P_e)$，因为只有在该点才满足条件 $P_D(Q^*) = P_S(Q^*)$。因此，核心的逻辑检验是，在给定最低产能约束 $Q_{min}$ 的情况下，这个无约束均衡点 $(Q_e, P_e)$ 是否可行。\n\n这引出了一个简单的二分逻辑：\n\n**情况 1：无约束均衡是可行的。**\n这个条件当且仅当 $Q_e \\ge Q_{min}$ 时成立。\n如果这个条件成立，工厂能够并且将会以市场出清数量 $Q_e$ 进行生产。运营均衡的所有条件都得到满足：$Q_e \\ge Q_{min}$，$P_D(Q_e) = P_S(Q_e)$，以及 $P_e \\ge 0$。因此，市场均衡点为 $(Q^*, P^*) = (Q_e, P_e)$。\n\n**情况 2：无约束均衡是不可行的。**\n这个条件当且仅当 $Q_e  Q_{min}$ 时成立。这涵盖了两种情形：\n  a) 曲线相交于一个过小的正数量（$0 \\le Q_e  Q_{min}$）。\n  b) 曲线在非负数量上不相交（$\\alpha \\le \\gamma$，导致 $Q_e \\le 0$）。\n\n在这两种情形下，唯一满足 $P_D(Q) = P_S(Q)$ 的点发生在数量小于 $Q_{min}$ 处。对于任何数量 $Q \\ge Q_{min}$，都有 $Q  Q_e$。由于函数 $P_D(Q) - P_S(Q) = (\\alpha - \\gamma) - (\\beta + \\delta)Q$ 是关于 $Q$ 的严格递减函数，因此对于任何 $Q  Q_e$，我们有 $P_D(Q)  P_S(Q)$。这意味着对于任何等于或高于最低产能的生产水平，消费者愿意支付的价格都低于供给方要求的价格。因此，在任何可行水平上的生产都是无利可图的。工厂将不会运营。\n\n在这种情况下，市场将默认为问题陈述中定义的停产均衡：市场供给为零，均衡点为 $(Q^*, P^*) = (0, \\alpha)$。\n\n**算法摘要：**\n1. 给定参数 $(\\alpha, \\beta, \\gamma, \\delta, Q_{min})$，计算无约束均衡数量 $Q_e = \\frac{\\alpha - \\gamma}{\\beta + \\delta}$。\n2. 如果 $Q_e \\ge Q_{min}$，则均衡点为 $Q^* = Q_e$ 和 $P^* = \\alpha - \\beta Q_e$。\n3. 如果 $Q_e  Q_{min}$，则均衡点为 $Q^* = 0$ 和 $P^* = \\alpha$。\n\n将实施此程序以解决给定的测试案例。所有结果将按要求四舍五入到六位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the market equilibrium for a set of supply and demand parameters\n    with a minimum production capacity constraint.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of\n    # (alpha, beta, gamma, delta, Q_min).\n    test_cases = [\n        (100.0, 1.0, 10.0, 1.0, 20.0),   # Case A\n        (100.0, 1.0, 10.0, 1.0, 60.0),   # Case B\n        (90.0, 1.5, 30.0, 0.5, 20.0),   # Case C\n        (110.0, 2.0, 10.0, 2.0, 25.0),   # Case D (boundary)\n        (80.0, 2.0, 20.0, 4.0, 0.0),    # Case E (standard with Q_min=0)\n        (5.0, 2.0, 10.0, 3.0, 1.0),    # Case F (no positive-quantity intersection)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        alpha, beta, gamma, delta, q_min = case\n\n        # The denominator (beta + delta) is always positive given the problem constraints\n        # (beta > 0, delta > 0).\n        denominator = beta + delta\n\n        # Calculate the unconstrained equilibrium quantity, Q_e, where the\n        # supply and demand curves intersect.\n        # Q_e = (alpha - gamma) / (beta + delta)\n        q_e = (alpha - gamma) / denominator\n\n        q_star, p_star = 0.0, 0.0\n\n        # The core logic is to check if the unconstrained equilibrium is feasible.\n        # An operating equilibrium is only possible at the intersection point (Q_e, P_e).\n        # If Q_e is less than the minimum required production Q_min, then no\n        # production is profitable, and the market shuts down.\n        if q_e >= q_min:\n            # Case 1: The unconstrained equilibrium is feasible.\n            # The market operates at this point.\n            q_star = q_e\n            # Calculate the price P* using the inverse demand function.\n            p_star = alpha - beta * q_star\n        else:\n            # Case 2: The unconstrained equilibrium is not feasible (Q_e  Q_min).\n            # For any Q >= Q_min, P_D(Q)  P_S(Q), so production is not viable.\n            # The market shuts down as per the problem definition.\n            q_star = 0.0\n            p_star = alpha\n        \n        # Format the result for the current case as a string \"[Q*,P*]\" with\n        # values rounded to six decimal places.\n        results.append(f\"[{q_star:.6f},{p_star:.6f}]\")\n\n    # Final print statement must produce a single line with the specified format:\n    # [[Q1,P1],[Q2,P2],...,[QN,PN]]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2429894"}, {"introduction": "尽管线性模型是理解市场均衡的绝佳起点，但真实的市场行为很少是完全线性的。本练习将我们带入一个更贴近现实的场景，其中的需求和供给关系由非线性的指数函数来描述。在这种情况下，通过代数方法精确求解均衡点通常是不可能的。这个练习旨在展示计算方法的强大之处，特别是像牛顿法这样的数值求根算法，如何帮助我们在这些更复杂、更现实的市场模型中找到均衡解 [@problem_id:2414687]。", "problem": "考虑一个单一商品的竞争性市场，其中存在单位补贴以及非线性的供给和需求。设消费者支付的价格为 $p_c \\ge 0$，单位补贴为 $s \\ge 0$，生产者收到的价格为 $p_p = p_c + s$。需求函数由 $Q_d(p_c) = A \\exp(-B p_c)$ 给出，参数 $A  0$ 且 $B  0$。供给函数由 $Q_s(p_p) = K \\left(\\exp(H p_p) - 1\\right)$ 给出，参数 $K  0$ 且 $H  0$。均衡点是一个数对 $(p_c^\\ast, q^\\ast)$，满足 $Q_d(p_c^\\ast) = q^\\ast = Q_s(p_c^\\ast + s)$，其中 $p_c^\\ast \\ge 0$。\n\n您的任务是为下面列出的每一组参数计算 $(p_c^\\ast, q^\\ast)$。对于每种情况，请报告消费者价格 $p_c^\\ast$ 和均衡数量 $q^\\ast$，结果为保留六（$6$）位小数的实数。\n\n测试集（每种情况指定了 $(A, B, K, H, s)$）：\n- 情况 $1$：$(A, B, K, H, s) = (100, 0.4, 4, 0.25, 2)$。\n- 情况 $2$：$(A, B, K, H, s) = (100, 0.4, 4, 0.25, 0)$。\n- 情况 $3$：$(A, B, K, H, s) = (120, 0.35, 6, 0.3, 3.5)$。\n- 情况 $4$：$(A, B, K, H, s) = (80, 0.6, 3, 0.5, 1)$。\n- 情况 $5$：$(A, B, K, H, s) = (60, 0.5, 2, 0.3, 8)$。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，按顺序列出所有情况的结果，形式为数对列表 $[p_c^\\ast, q^\\ast]$，每个数字保留六（$6$）位小数。输出必须为单行，没有多余的空格，格式完全如下：\n\"[[p_{c,1}^\\ast,q_1^\\ast],[p_{c,2}^\\ast,q_2^\\ast],[p_{c,3}^\\ast,q_3^\\ast],[p_{c,4}^\\ast,q_4^\\ast],[p_{c,5}^\\ast,q_5^\\ast]]\"。", "solution": "所提出的问题是计算经济学中一个定义明确的练习，要求在特定的非线性供给和需求函数以及政府补贴条件下，确定市场均衡。该问题具有科学依据，内容自洽，且逻辑一致。因此，可以通过严谨的数学分析推导出解决方案。\n\n竞争性市场均衡的基本原则是消费者需求量必须等于生产者供给量。价格会进行调整以达到这种平衡。在此模型中，消费者支付的价格 $p_c$ 和生产者收到的价格 $p_p$ 通过单位补贴 $s$ 相关联，即 $p_p = p_c + s$。\n\n需求函数由 $Q_d(p_c) = A \\exp(-B p_c)$ 给出，供给函数为 $Q_s(p_p) = K (\\exp(H p_p) - 1)$。代入 $p_p$ 的关系式，供给函数可以表示为消费者价格 $p_c$ 的函数：$Q_s(p_c + s) = K (\\exp(H (p_c + s)) - 1)$。\n\n均衡条件 $Q_d(p_c^\\ast) = Q_s(p_c^\\ast + s)$ 要求我们找到超额需求函数（我们定义为 $f(p_c)$）的根 $p_c^\\ast$：\n$$\nf(p_c) = Q_d(p_c) - Q_s(p_c + s) = A \\exp(-B p_c) - K (\\exp(H (p_c + s)) - 1) = 0\n$$\n因此，问题转化为求解单变量 $p_c$ 的求根问题。约束条件为 $p_c \\ge 0$，且所有模型参数（$A, B, K, H, s$）均为非负，其中 $A, B, K, H$ 为严格正数。\n\n为求解这个超越方程，需要使用数值方法。Newton-Raphson 方法是完成此任务的强大而高效的选择，当初始猜测值足够接近根时，该方法以其二次收敛速度而闻名。Newton-Raphson 方法的迭代公式为：\n$$\np_{c, n+1} = p_{c, n} - \\frac{f(p_{c, n})}{f'(p_{c, n})}\n$$\n其中 $p_{c, n}$ 是第 $n$ 次迭代时根的估计值，$f'(p_c)$ 是 $f(p_c)$ 关于 $p_c$ 的一阶导数。\n\n首先，我们计算导数 $f'(p_c)$：\n$$\nf'(p_c) = \\frac{d}{dp_c} \\left( A \\exp(-B p_c) - K \\exp(H (p_c + s)) + K \\right)\n$$\n$$\nf'(p_c) = -A B \\exp(-B p_c) - K H \\exp(H (p_c + s))\n$$\n由于所有参数 $A, B, K, H$ 均为正数，显然对于所有 $p_c \\ge 0$ 都有 $f'(p_c)  0$。这证实了超额需求函数 $f(p_c)$ 是严格单调递减的。一个严格单调的函数最多与横轴相交一次，这保证了如果存在根，则该根是唯一的。对函数在边界处的分析，即 $f(0) = A - K(\\exp(Hs) - 1)$，表明对于所有给定的测试用例，该值均为正。由于当 $p_c \\to \\infty$ 时，$f(p_c) \\to -\\infty$，根据介值定理，可以保证存在一个唯一的正根 $p_c^\\ast  0$。\n\n寻找均衡点的算法如下：\n1.  对于每组参数 $(A, B, K, H, s)$，定义函数 $f(p_c)$ 和 $f'(p_c)$。\n2.  为消费者价格选择一个初始猜测值 $p_{c,0}$。一个合理的选择是根据需求函数特性导出的价格，例如，需求减半时的价格，$p_{c,0} = \\frac{\\ln(2)}{B}$。\n3.  迭代应用 Newton-Raphson 公式，直到连续两次迭代之间的变化量 $|p_{c, n+1} - p_{c, n}|$ 小于指定的容差（例如 $10^{-9}$）。\n4.  一旦均衡价格 $p_c^\\ast$ 收敛，使用需求函数计算相应的均衡数量 $q^\\ast$：$q^\\ast = Q_d(p_c^\\ast) = A \\exp(-B p_c^\\ast)$。\n5.  最终结果 $(p_c^\\ast, q^\\ast)$ 按要求四舍五入到六位小数。\n\n这个过程通过一个 Python 脚本实现，该脚本利用了 `scipy.optimize.newton` 函数，它提供了 Newton-Raphson 方法的一个稳健且数值稳定的实现。这避免了手动实现可能出现的问题，并确保了可靠的收敛。对所提供的五个测试用例中的每一个都重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import optimize\n\ndef solve():\n    \"\"\"\n    Computes the equilibrium consumer price and quantity for a series of market parameters\n    using the Newton-Raphson method for root-finding.\n    \"\"\"\n    \n    # Test suite: each element is a tuple (A, B, K, H, s)\n    test_cases = [\n        (100, 0.4, 4, 0.25, 2),\n        (100, 0.4, 4, 0.25, 0),\n        (120, 0.35, 6, 0.3, 3.5),\n        (80, 0.6, 3, 0.5, 1),\n        (60, 0.5, 2, 0.3, 8),\n    ]\n\n    results_str = []\n    for params in test_cases:\n        A, B, K, H, s = params\n\n        def f(pc):\n            \"\"\"Excess demand function, f(p_c) = Q_d(p_c) - Q_s(p_p).\"\"\"\n            if pc  0: # Consumer price must be non-negative\n                return np.inf\n            return A * np.exp(-B * pc) - K * (np.exp(H * (pc + s)) - 1.0)\n\n        def f_prime(pc):\n            \"\"\"Derivative of the excess demand function.\"\"\"\n            return -A * B * np.exp(-B * pc) - K * H * np.exp(H * (pc + s))\n        \n        # An initial guess based on the price where demand is half its maximum value.\n        # This provides a reasonable starting point in the correct region.\n        p0 = np.log(2.0) / B\n        \n        # Use SciPy's Newton-Raphson solver for robustness and efficiency.\n        # A tight tolerance is used for high precision before rounding.\n        pc_star = optimize.newton(f, x0=p0, fprime=f_prime, tol=1e-12, maxiter=100)\n        \n        # Calculate the equilibrium quantity using the demand function.\n        q_star = A * np.exp(-B * pc_star)\n        \n        # Format the result pair as a string with numbers rounded to 6 decimal places.\n        pair_str = f\"[{pc_star:.6f},{q_star:.6f}]\"\n        results_str.append(pair_str)\n\n    # Assemble the final output string in the exact format required.\n    final_output = f\"[{','.join(results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2414687"}, {"introduction": "如果更高的价格反而使一种商品更具吸引力，市场会怎样？这就是“凡勃伦商品” (Veblen goods) 的奇妙之处，其价格本身就是品质或地位的象征。本练习通过使用三次多项式来模拟这类商品的需求曲线，挑战了传统的需求定律。这种更复杂的函数形式揭示了一种引人注目的可能性：市场可能存在多个均衡点。这个练习不仅要求你找出所有潜在的均衡价格和数量，还将促使你思考一个市场拥有多个稳定状态所带来的深刻经济学含义 [@problem_id:2429850]。", "problem": "考虑一个单一商品市场，其价格 $P \\ge 0$，数量 $Q \\ge 0$。竞争均衡是指任意满足 $P^{\\ast} \\ge 0$ 和 $Q^{\\ast} \\ge 0$ 的数对 $(P^{\\ast}, Q^{\\ast})$，使得在价格 $P^{\\ast}$ 时，需求量等于供给量，即 $Q_d(P^{\\ast}) = Q_s(P^{\\ast}) = Q^{\\ast}$。对于凡勃伦商品，其需求量可能在某个非空的价格区间内随价格上涨而增加。需求和供给模型如下：\n- 需求：$Q_d(P) = \\alpha - \\beta P + \\gamma P^2 - \\delta P^3$，参数为 $\\alpha  0$，$\\beta  0$，$\\gamma  0$，$\\delta  0$。该设定允许存在凡勃伦区域，因为只要二次条件 $-\\beta + 2 \\gamma P - 3 \\delta P^2  0$ 的判别式为正，需求导数 $Q_d'(P) = -\\beta + 2 \\gamma P - 3 \\delta P^2$ 就可以在一个非空区间上为正。\n- 供给：$Q_s(P) = s_0 + s_1 P$，参数为 $s_0 \\in \\mathbb{R}$ 和 $s_1  0$。\n\n你的任务是，对于下述测试套件中的每一组参数，从基本原理出发，计算所有的竞争均衡 $(P^{\\ast}, Q^{\\ast})$。一个均衡点 $(P^{\\ast}, Q^{\\ast})$ 必须满足 $P^{\\ast} \\ge 0$，$Q^{\\ast} \\ge 0$ 和 $Q_d(P^{\\ast}) = Q_s(P^{\\ast})$。如果不存在这样的数对，则该测试用例的输出为空列表。\n\n测试套件（每个用例按顺序为 $(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1)$）：\n- 用例 $1$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 20, 8)$。\n- 用例 $2$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, -33.6, 16.8)$。此用例经过校准，使得供给曲线在某个正价格上与需求曲线相切，从而产生一个有重根的边界条件。\n- 用例 $3$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 0, 25)$。\n- 用例 $4$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 250, 15)$。\n\n输出规范：\n- 对于每个测试用例，生成所有均衡点的列表，格式为 $[ [P_1^{\\ast}, Q_1^{\\ast}], [P_2^{\\ast}, Q_2^{\\ast}], \\dots ]$，按价格 $P_i^{\\ast}$ 严格递增排序，每个数字都精确到小数点后六位。\n- 将所有测试用例的输出汇总到单行中，形成一个列表的列表：$[ \\text{case1\\_list}, \\text{case2\\_list}, \\text{case3\\_list}, \\text{case4\\_list} ]$。\n- 如果一个测试用例没有均衡点，则为该用例输出空列表 $[\\ ]$。\n- 最终打印的行不得包含任何空格。例如，一个包含两个用例的输出可能看起来像 $[[[P^{\\ast}_1,Q^{\\ast}_1]],[]]$，其中每个 $P^{\\ast}_i$ 和 $Q^{\\ast}_i$ 都显示到小数点后六位。\n\n本问题不涉及物理单位。所有结果必须是实数，并遵守非负约束 $P^{\\ast} \\ge 0$ 和 $Q^{\\ast} \\ge 0$。", "solution": "该市场的竞争均衡是一个满足定义条件 $P^{\\ast} \\ge 0$、$Q^{\\ast} \\ge 0$ 和 $Q_d(P^{\\ast}) = Q_s(P^{\\ast}) = Q^{\\ast}$ 的数对 $(P^{\\ast}, Q^{\\ast})$。给定需求 $Q_d(P) = \\alpha - \\beta P + \\gamma P^2 - \\delta P^3$（其中 $\\alpha  0$，$\\beta  0$，$\\gamma  0$，$\\delta  0$）和供给 $Q_s(P) = s_0 + s_1 P$（其中 $s_1  0$），凡勃伦特性之所以出现，是因为需求导数为\n$$\nQ_d'(P) = -\\beta + 2 \\gamma P - 3 \\delta P^2,\n$$\n该导数是关于 $P$ 的凹二次函数。当其判别式为正时，存在一个非空区间 $(P_L, P_H)$，在此区间上 $Q_d'(P)  0$，且需求曲线是向上倾斜的。\n\n均衡出现在满足等式条件 $Q_d(P) = Q_s(P)$ 的价格 $P$ 处。定义\n$$\ng(P) \\equiv Q_d(P) - Q_s(P) = \\alpha - \\beta P + \\gamma P^2 - \\delta P^3 - s_0 - s_1 P.\n$$\n整理各项可得一个关于 $P$ 的三次多项式方程，\n$$\n-\\delta P^3 + \\gamma P^2 - (\\beta + s_1) P + (\\alpha - s_0) = 0.\n$$\n设 $P$ 的降序幂系数为 $[-\\delta,\\ \\gamma,\\ -(\\beta + s_1),\\ (\\alpha - s_0)]$。该多项式的实根都是候选的均衡价格。由于价格和数量必须为非负，我们施加可行性约束 $P^{\\ast} \\ge 0$ 和 $Q^{\\ast} = Q_s(P^{\\ast}) = s_0 + s_1 P^{\\ast} \\ge 0$ 来筛选掉不符合条件的根。当一个根的重数大于一（例如，相切情况），它代表一个单一的均衡价格，不应重复计算。相应的均衡数量 $Q^{\\ast}$ 则由 $Q^{\\ast} = Q_s(P^{\\ast})$ 给出。\n\n基于这些原理的算法规划：\n- 对每个测试用例，构建三次方程的系数向量 $[-\\delta,\\ \\gamma,\\ -(\\beta + s_1),\\ (\\alpha - s_0)]$。\n- 计算该三次方程的所有复根，通过要求虚部在数值上可忽略不计来提取实根，并按非递减顺序排序。\n- 施加 $P^{\\ast} \\ge 0$ 和 $Q^{\\ast} = s_0 + s_1 P^{\\ast} \\ge 0$ 以强制满足可行性。\n- 对几乎相等的价格进行去重，以处理重根（相切点）。\n- 报告所有的 $(P^{\\ast}, Q^{\\ast})$ 对，按 $P^{\\ast}$ 排序，并将每个数字四舍五入到小数点后六位。\n\n将此方法应用于测试套件：\n- 用例 $1$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 20, 8)$。三次方程为 $-0.6 P^3 + 12 P^2 - 68 P + 100 = 0$，它有三个满足 $P^{\\ast} \\ge 0$ 的不同实根。所有对应的数量 $Q^{\\ast} = 20 + 8 P^{\\ast}$ 均为非负，因此有三个可接受的均衡点。数值上，它们出现在价格分别约为 $P^{\\ast} \\approx 2.291600, P^{\\ast} \\approx 6.490000$, 和 $P^{\\ast} \\approx 11.229900$ 处，对应的数量分别为 $Q^{\\ast} \\approx 38.332800, Q^{\\ast} \\approx 71.920000$, 和 $Q^{\\ast} \\approx 109.839200$。\n- 用例 $2$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, -33.6, 16.8)$。三次方程为 $-0.6 P^3 + 12 P^2 - 76.8 P + 153.6 = 0$。这种情况是一个边界（相切）情况。确实，$Q_d'(P) = -60 + 24 P - 1.8 P^2$ 且 $Q_s'(P) = 16.8$, 所以在 $P = 8, Q_d'(8) = 16.8 = Q_s'(8)$ 且 $Q_d(8) = 100.8 = Q_s(8)$, 这表明在 $P^{\\ast} = 8$ 处存在一个重根（相切均衡点）。因式分解证实 $-0.6 (P - 8)^2 (P - 4) = 0$，因此另一个均衡点是 $P^{\\ast} = 4$，对应的 $Q^{\\ast} = 33.6$. 两个均衡点都满足非负性。\n- 用例 $3$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 0, 25)$。三次方程为 $-0.6 P^3 + 12 P^2 - 85 P + 120 = 0$。在 $P \\ge 0$ 上只有一个可接受的交点；数值上，$P^{\\ast} \\approx 1.850700$，对应的 $Q^{\\ast} = 25 \\cdot P^{\\ast} \\approx 46.267500$. 其他根在 $P \\ge 0$ 上不可接受或是复数根。\n- 用例 $4$：$(\\alpha, \\beta, \\gamma, \\delta, s_0, s_1) = (120, 60, 12, 0.6, 250, 15)$。三次方程为 $-0.6 P^3 + 12 P^2 - 75 P - 130 = 0$。对于所有 $P \\ge 0$，$Q_s(P)$ 均超过 $Q_d(P)$，因此不存在满足 $P^{\\ast} \\ge 0$ 和 $Q^{\\ast} \\ge 0$ 的可接受均衡点 $(P^{\\ast}, Q^{\\ast})$。此用例的正确输出是空列表。\n\n程序计算实根，强制满足可行性，对相切情况进行去重，按价格对均衡点排序，并打印出所要求的单行、无空格、列表的列表格式的输出，每个数字都四舍五入到小数点后六位。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_equilibria(alpha, beta, gamma, delta, s0, s1, imag_tol=1e-9, p_tol=1e-7):\n    \"\"\"\n    Solve for all competitive equilibria (P*, Q*) given parameters of\n    Qd(P) = alpha - beta*P + gamma*P**2 - delta*P**3\n    Qs(P) = s0 + s1*P\n    Returns a list of [P*, Q*] pairs with P*, Q* rounded to 6 decimals.\n    \"\"\"\n    # Coefficients for g(P) = Qd(P) - Qs(P) = 0 in descending powers of P\n    # g(P) = -delta*P^3 + gamma*P^2 - (beta + s1)*P + (alpha - s0)\n    coefs = np.array([-delta, gamma, -(beta + s1), (alpha - s0)], dtype=float)\n\n    # Compute all roots of the cubic\n    roots = np.roots(coefs)\n\n    # Extract real roots within tolerance\n    real_ps = sorted(r.real for r in roots if abs(r.imag) = imag_tol)\n\n    # Filter feasible equilibria: P >= 0 and Q >= 0\n    eqs = []\n    for p in real_ps:\n        if p >= -1e-10:  # allow tiny negative numerical noise\n            p_val = 0.0 if abs(p)  1e-12 else p\n            q_val = s0 + s1 * p_val\n            if q_val >= -1e-10:\n                eqs.append((p_val, q_val))\n\n    # Sort by price\n    eqs.sort(key=lambda x: x[0])\n\n    # Deduplicate near-equal prices (handle repeated roots/tangency)\n    dedup = []\n    for p_val, q_val in eqs:\n        if not dedup:\n            dedup.append((p_val, q_val))\n        else:\n            p_prev, q_prev = dedup[-1]\n            if abs(p_val - p_prev) = p_tol:\n                # Merge duplicates by averaging to reduce numerical jitter\n                merged_p = 0.5 * (p_prev + p_val)\n                merged_q = 0.5 * (q_prev + q_val)\n                dedup[-1] = (merged_p, merged_q)\n            else:\n                dedup.append((p_val, q_val))\n\n    # Round to 6 decimals\n    rounded = [[round(p, 6), round(s0 + s1 * p, 6)] for (p, _) in dedup]\n    return rounded\n\ndef format_output(all_results):\n    \"\"\"\n    Format nested list of results with no spaces and exactly six decimals.\n    all_results: list of test case results, each a list of [P, Q] lists.\n    \"\"\"\n    def fmt_num(x):\n        return f\"{x:.6f}\"\n\n    def fmt_case(case):\n        # case is a list of [P, Q]\n        pairs = []\n        for P, Q in case:\n            pairs.append(f\"[{fmt_num(P)},{fmt_num(Q)}]\")\n        return \"[\" + \",\".join(pairs) + \"]\"\n\n    return \"[\" + \",\".join(fmt_case(case) for case in all_results) + \"]\"\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple is (alpha, beta, gamma, delta, s0, s1)\n    test_cases = [\n        (120.0, 60.0, 12.0, 0.6, 20.0, 8.0),      # Case 1: three intersections\n        (120.0, 60.0, 12.0, 0.6, -33.6, 16.8),    # Case 2: tangency + one more\n        (120.0, 60.0, 12.0, 0.6, 0.0, 25.0),      # Case 3: single intersection\n        (120.0, 60.0, 12.0, 0.6, 250.0, 15.0),    # Case 4: no equilibrium\n    ]\n\n    results = []\n    for alpha, beta, gamma, delta, s0, s1 in test_cases:\n        equilibria = find_equilibria(alpha, beta, gamma, delta, s0, s1)\n        results.append(equilibria)\n\n    # Final print statement in the exact required format (single line, no spaces).\n    print(format_output(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2429850"}]}