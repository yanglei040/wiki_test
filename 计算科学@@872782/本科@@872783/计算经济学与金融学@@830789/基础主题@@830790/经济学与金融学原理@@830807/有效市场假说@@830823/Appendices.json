{"hands_on_practices": [{"introduction": "第一个动手实践旨在深入探讨弱式有效市场假说的核心主张：即历史回报无法预测未来回报。你将通过模拟时间序列数据并运用如 Ljung-Box 检验等统计方法，来实施一套经典的计量经济学流程，以检验收益率中是否存在自相关性 [@problem_id:2389249]。对于任何旨在评估市场是否遵循随机游走行为的量化分析师来说，这都是一项基本技能。", "problem": "考虑一个区块链在等间隔时间内的每字节平均交易费用的离散时间序列。令严格为正的费用水平在时间索引 $t \\in \\{0,1,2,\\dots,n\\}$ 时表示为 $f_t$，并定义对数费用 $y_t = \\ln(f_t)$。单步对数收益率为 $r_t = y_t - y_{t-1}$，其中 $t \\in \\{1,2,\\dots,n\\}$。根据弱式有效市场假说 (EMH)，相对于由过去值生成的信息集，过程 $\\{r_t\\}$ 是一个鞅差序列，这意味着 $E[r_t \\mid \\mathcal{I}_{t-1}] = 0$ 且对于 $\\{r_{t-1}, r_{t-2}, \\dots\\}$ 而言线性可预测性为零。等价地，在弱式有效市场假说下，$\\{r_t\\}$ 的所有非零滞后自相关均为零，且基于 $r_{t-1}$ 对 $r_t$ 的最佳单步前向线性预测器的斜率为零。\n\n你的任务是编写一个完整的程序，该程序针对以下每个测试用例，根据指定的数据生成过程模拟一个费用序列 $\\{f_t\\}$，计算收益率序列 $\\{r_t\\}$，然后在给定的显著性水平下将该序列分类为弱式有效或非弱式有效。一个序列必须被分类为弱式有效，当且仅当在给定的显著性水平 $\\alpha$ 下，数据同时支持以下两个属性：(i) 所有滞后至 $m$ 阶的自相关均为零的联合原假设不被拒绝，以及 (ii) 从 $r_{t-1}$ 到 $r_t$ 的最佳线性预测器中斜率系数为零的原假设不被拒绝。否则，将序列分类为非弱式有效。\n\n模拟应按如下方式进行。对于每个测试用例，将初始水平固定为 $f_0 = 100.0$。对于所有随机模拟，使用固定的随机种子 $123456$，以确保结果是可复现的。有两种过程设定：\n- 对数费用的随机游走（表示为 RW）：$y_t = y_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 在 $t$ 上独立同分布，这意味着 $r_t = \\varepsilon_t$。\n- 收益率的一阶自回归（表示为 AR1）：$r_t = \\phi r_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 在 $t$ 上独立同分布，且 $y_t = y_{t-1} + r_t$。对于此情况，使用 200 步的预烧期（这些步骤的数据将被丢弃）以近似 $\\{r_t\\}$ 的平稳性，然后再收集 $n$ 个保留的观测值。对于 RW，不需要预烧期。\n\n对于每个测试用例，在模拟 $\\{f_t\\}$ 和计算 $\\{r_t\\}$ 之后，应用在高斯鞅差新息的原假设下有效的统计决策规则，以确定是否在显著性水平 $\\alpha$ 下拒绝这两个属性中的每一个。使用以下测试套件，其中每个用例由元组 $(S, n, \\sigma, \\phi, \\alpha, m)$ 给出，当 $S=\\text{RW}$ 时忽略 $\\phi$：\n- 用例 A：$(\\text{RW},\\, 500,\\, 0.02,\\, 0.0,\\, 0.01,\\, 10)$\n- 用例 B：$(\\text{AR1},\\, 500,\\, 0.02,\\, 0.35,\\, 0.01,\\, 10)$\n- 用例 C：$(\\text{AR1},\\, 80,\\, 0.03,\\, 0.0,\\, 0.01,\\, 8)$\n- 用例 D：$(\\text{AR1},\\, 500,\\, 0.02,\\, -0.5,\\, 0.01,\\, 10)$\n\n你的程序必须输出一行，其中包含按顺序排列的 A 到 D 四个用例的布尔分类结果，使用方括号括起来的逗号分隔列表的精确格式，无空格，其中每个条目为 True 或 False。例如，所需的格式类似于 [True,False,True,False]。", "solution": "在弱式有效市场假说 (EMH) 下，对数费用 $r_t = y_t - y_{t-1}$ 的增量相对于自然滤子构成一个鞅差序列 (MDS)。形式上，这表示为 $E[r_t \\mid \\mathcal{I}_{t-1}] = 0$ 对所有 $t$ 成立，其中 $\\mathcal{I}_{t-1}$ 是由过去观测值生成的 sigma-代数。该陈述的两个可操作性含义是：(i) 非零滞后的自相关函数为零，以及 (ii) 基于 $r_{t-1}$ 对 $r_t$ 的最佳线性预测器的斜率为零。\n\n数据生成。对于随机游走 (RW) 设定，对数费用遵循 $y_t = y_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $r_t = \\varepsilon_t$。对于一阶自回归 (AR1) 设定，收益率遵循 $r_t = \\phi r_{t-1} + \\varepsilon_t$，其中 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$ 且 $y_t = y_{t-1} + r_t$。在所有情况下，水平为 $f_t = \\exp(y_t)$ 以确保其为正。对于 AR1，通过生成 200 步的预烧期（这些数据将被丢弃）来减轻初始化效应，以便当 $|\\phi| < 1$ 时，保留的 $n$ 个观测值近似遵循平稳分布。所有随机抽样均使用固定的种子 123456 生成，以确保可复现性。\n\n检验属性 (i)：滞后至 $m$ 阶的自相关联合为零。给定样本 $\\{r_t\\}_{t=1}^n$，定义中心化收益率 $\\tilde{r}_t = r_t - \\bar{r}$，其中 $\\bar{r} = \\frac{1}{n}\\sum_{t=1}^n r_t$。滞后 $k$ 阶的样本自协方差为 $\\hat{\\gamma}_k = \\frac{1}{n}\\sum_{t=k+1}^n \\tilde{r}_t \\tilde{r}_{t-k}$，滞后零阶的自协方差为 $\\hat{\\gamma}_0 = \\frac{1}{n}\\sum_{t=1}^n \\tilde{r}_t^2$。滞后 $k$ 阶的样本自相关为 $\\hat{\\rho}_k = \\hat{\\gamma}_k / \\hat{\\gamma}_0$。一个将这些自相关汇总至滞后 $m$ 阶的综合统计量是 Ljung–Box 统计量\n$$\nQ = n(n+2)\\sum_{k=1}^m \\frac{\\hat{\\rho}_k^2}{n-k}.\n$$\n在滞后 1 至 $m$ 阶自相关为零且条件同方差性的原假设下，$Q$ 渐近服从 $\\chi^2_m$ 分布。决策规则是计算 $p$-值 $p_{\\text{LB}} = 1 - F_{\\chi^2_m}(Q)$，如果 $p_{\\text{LB}} < \\alpha$，则拒绝原假设。\n\n检验属性 (ii)：最佳单步前向线性预测器中的斜率为零。考虑线性模型\n$$\nr_t = \\beta_0 + \\beta_1 r_{t-1} + \\varepsilon_t^{\\ast}, \\quad t=2,\\dots,n,\n$$\n通过普通最小二乘法 (OLS) 进行估计。令 $X$ 为 $(n-1)\\times 2$ 矩阵，其一列为全 1，另一列为滞后收益率 $r_{t-1}$；令 $y$ 为 $(n-1)\\times 1$ 向量，包含同期收益率 $r_t$。OLS 估计量为 $\\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y$。残差方差为 $\\hat{\\sigma}^2 = \\frac{1}{n-1-2}\\sum_{t=2}^n \\hat{\\varepsilon}_t^2$，其中 $\\hat{\\varepsilon}_t = r_t - \\hat{\\beta}_0 - \\hat{\\beta}_1 r_{t-1}$。$\\hat{\\beta}_1$ 的估计方差是 $\\hat{\\sigma}^2 (X^{\\top}X)^{-1}$ 的 $(2,2)$ 元素，记为 $\\widehat{\\mathrm{Var}}(\\hat{\\beta}_1)$。检验统计量为\n$$\nt = \\frac{\\hat{\\beta}_1}{\\sqrt{\\widehat{\\mathrm{Var}}(\\hat{\\beta}_1)}},\n$$\n在原假设 $H_0:\\beta_1=0$ 和条件同方差正态误差下，该统计量服从自由度为 $n-3$ 的学生t分布。双边 $p$-值为 $p_{\\text{REG}} = 2\\left(1 - F_{t_{n-3}}(|t|)\\right)$。如果 $p_{\\text{REG}} < \\alpha$，则拒绝原假设。\n\n分类规则。对于每个用例，计算在给定 $\\alpha$ 下的 $p_{\\text{LB}}$ 和 $p_{\\text{REG}}$。当且仅当两个原假设都未被拒绝时，即当且仅当 $p_{\\text{LB}} \\ge \\alpha$ 且 $p_{\\text{REG}} \\ge \\alpha$ 时，将序列分类为弱式有效。\n\n测试套件参数。每个测试用例由 $(S, n, \\sigma, \\phi, \\alpha, m)$ 指定，当 $S=\\text{RW}$ 时忽略 $\\phi$，并且所有模拟都使用 $f_0=100.0$ 和固定的种子 $123456$：\n- 用例 A：$(\\text{RW},\\, 500,\\, 0.02,\\, 0.0,\\, 0.01,\\, 10)$，代表对数费用的随机游走，其增量为独立同分布的高斯分布，期望上满足弱式有效市场假说。\n- 用例 B：$(\\text{AR1},\\, 500,\\, 0.02,\\, 0.35,\\, 0.01,\\, 10)$，代表正自相关的收益率，因存在线性可预测性而违反弱式有效市场假说。\n- 用例 C：$(\\text{AR1},\\, 80,\\, 0.03,\\, 0.0,\\, 0.01,\\, 8)$，代表样本量较小的非相关收益率，作为一个边界类型的用例。\n- 用例 D：$(\\text{AR1},\\, 500,\\, 0.02,\\, -0.5,\\, 0.01,\\, 10)$，代表负自相关的收益率，因存在线性可预测性而违反弱式有效市场假说。\n\n最终输出格式。你的程序应生成单行输出，其中包含 A 到 D 四个用例的四个布尔结果，格式为逗号分隔的列表，用方括号括起来，且无空格，例如：[True,False,True,False]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import chi2, t as student_t\n\ndef ljung_box_pvalue(returns: np.ndarray, m: int) -> float:\n    \"\"\"\n    Compute the Ljung-Box Q statistic p-value for autocorrelations up to lag m.\n    returns: 1D array of returns r_t\n    m: maximum lag to include\n    \"\"\"\n    r = returns.astype(float)\n    n = r.shape[0]\n    if n = m + 1:\n        # Not enough data; return p-value of 0 to force non-acceptance.\n        return 0.0\n    r_centered = r - r.mean()\n    gamma0 = np.dot(r_centered, r_centered) / n\n    if gamma0 = 0:\n        # Degenerate variance: treat as non-acceptance.\n        return 0.0\n    Q = 0.0\n    for k in range(1, m + 1):\n        num = np.dot(r_centered[k:], r_centered[:-k]) / n\n        rho_k = num / gamma0\n        Q += rho_k * rho_k / (n - k)\n    Q *= n * (n + 2)\n    p_val = 1.0 - chi2.cdf(Q, df=m)\n    # Numerical guard\n    if p_val  0.0:\n        p_val = 0.0\n    if p_val > 1.0:\n        p_val = 1.0\n    return p_val\n\ndef ols_predictability_pvalue(returns: np.ndarray) - float:\n    \"\"\"\n    Test H0: beta1 = 0 in the regression r_t = beta0 + beta1 * r_{t-1} + e_t.\n    Returns the two-sided p-value based on Student t with n-3 degrees of freedom.\n    \"\"\"\n    r = returns.astype(float)\n    n = r.shape[0]\n    # Need at least 4 observations to compute t-stat with df = n-3 >= 1\n    if n  4:\n        return 0.0\n    y = r[1:]\n    x = r[:-1]\n    X = np.column_stack([np.ones_like(x), x])\n    XtX = X.T @ X\n    # Check for invertibility\n    try:\n        XtX_inv = np.linalg.inv(XtX)\n    except np.linalg.LinAlgError:\n        return 0.0\n    beta_hat = XtX_inv @ (X.T @ y)\n    residuals = y - X @ beta_hat\n    dof = y.shape[0] - X.shape[1]\n    if dof = 0:\n        return 0.0\n    rss = float(residuals.T @ residuals)\n    sigma2_hat = rss / dof\n    var_beta = sigma2_hat * XtX_inv\n    se_beta1 = np.sqrt(max(var_beta[1, 1], 0.0))\n    if se_beta1 == 0.0:\n        # No variability; return 0 p-value to avoid false acceptance\n        return 0.0\n    t_stat = beta_hat[1] / se_beta1\n    # Two-sided p-value\n    p_val = 2.0 * (1.0 - student_t.cdf(abs(t_stat), df=dof))\n    # Numerical guard\n    if p_val  0.0:\n        p_val = 0.0\n    if p_val > 1.0:\n        p_val = 1.0\n    return p_val\n\ndef simulate_series(case, rng: np.random.Generator):\n    \"\"\"\n    Simulate fee levels and returns based on the specified test case.\n    case: tuple (S, n, sigma, phi, alpha, m)\n    rng: numpy Generator for reproducibility\n    Returns: returns array r of length n\n    \"\"\"\n    S, n, sigma, phi, alpha, m = case\n    y0 = np.log(100.0)  # initial log-fee\n    if S == \"RW\":\n        # Random walk in log fees: y_t = y_{t-1} + e_t\n        eps = rng.normal(loc=0.0, scale=sigma, size=n)\n        r = eps  # returns are the innovations\n        # Form y and f if needed (not used directly for tests)\n        # y = y0 + np.cumsum(r)\n        return r\n    elif S == \"AR1\":\n        # AR(1) in returns with burn-in for stationarity\n        burn = 200\n        total = n + burn\n        eps = rng.normal(loc=0.0, scale=sigma, size=total)\n        r_full = np.empty(total, dtype=float)\n        r_full[0] = eps[0]\n        for t in range(1, total):\n            r_full[t] = phi * r_full[t - 1] + eps[t]\n        r = r_full[burn:]\n        return r\n    else:\n        raise ValueError(\"Unknown specification S: {}\".format(S))\n\ndef classify_efficiency(case, rng: np.random.Generator) - bool:\n    \"\"\"\n    Classify a single test case as weak-form efficient (True) or not (False).\n    \"\"\"\n    S, n, sigma, phi, alpha, m = case\n    r = simulate_series(case, rng)\n    # Property (i): joint zero autocorrelations up to lag m\n    p_lb = ljung_box_pvalue(r, m)\n    # Property (ii): zero slope in linear predictability\n    p_reg = ols_predictability_pvalue(r)\n    # Efficient if both nulls are not rejected at level alpha\n    return (p_lb = alpha) and (p_reg = alpha)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"RW\", 500, 0.02, 0.0, 0.01, 10),     # Case A\n        (\"AR1\", 500, 0.02, 0.35, 0.01, 10),   # Case B\n        (\"AR1\", 80, 0.03, 0.0, 0.01, 8),      # Case C\n        (\"AR1\", 500, 0.02, -0.5, 0.01, 10),   # Case D\n    ]\n\n    rng = np.random.default_rng(123456)\n\n    results = []\n    for case in test_cases:\n        result = classify_efficiency(case, rng)\n        results.append(result)\n\n    # Final print statement in the exact required format: booleans without spaces.\n    print(\"[\" + \",\".join(\"True\" if r else \"False\" for r in results) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389249"}, {"introduction": "在超越了简单的短期相关性之后，下一个练习将探讨金融时间序列中是否存在长期记忆。你将通过对具有受控长记忆特性的模拟数据实施经典的重标极差（R/S）分析，来估计赫斯特指数（$H$）——一个衡量序列持久性的指标 [@problem_id:2389272]。如果探测到赫斯特指数显著不等于 $0.5$，则意味着价格变动并非真正的随机，这将对有效市场假说构成严峻挑战。", "problem": "考虑使用赫斯特指数检验有效市场假说 (EMH)。EMH 假设，在一个信息有效的市场中，条件期望收益为零，且收益率不存在长程依赖。在此设定下，我们将通过算法从模拟的收益率序列中估计赫斯特指数 $H$，并用它来判断基础市场是否“随机性较弱”，操作化定义为 $H  0.5$。\n\n基本原理：\n- 在 EMH 下，对数收益率的一个典型模型是独立同分布的高斯噪声。汇总后，对数价格遵循由布朗运动驱动的鞅的离散时间模拟。对于此类序列，赫斯特指数满足 $H = 0.5$。\n- 赫斯特指数 $H$ 可以通过重标极差 (R/S) 统计量来估计。对于一个零均值序列 $\\{x_t\\}_{t=1}^n$，令 $Y_j = \\sum_{i=1}^j (x_i - \\bar{x})$。定义极差 $R(n) = \\max_{1 \\le j \\le n} Y_j - \\min_{1 \\le j \\le n} Y_j$ 和样本标准差 $S(n) = \\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2}$。对于长记忆过程，重标极差的期望值按 $\\mathbb{E}[R(n)/S(n)] \\propto n^H$ 的规律进行缩放。因此，通过绘制多个 $n$ 值的 $\\log(R(n)/S(n))$ 对 $\\log(n)$ 的关系图，并拟合一条最小二乘直线，其斜率即为 $H$ 的估计值。\n\n模拟设计：\n- 为了在一个受控的、纯数学的环境中检验商品与股票的差异，我们使用参数为 $\\text{ARFIMA}(0,d,0)$ 的自回归分数阶积分移动平均 (ARFIMA) 模型来模拟收益率序列。这会产生收益率\n$$\nr_t \\;=\\; \\sum_{k=0}^{t} w_k \\,\\varepsilon_{t-k}, \\quad \\varepsilon_t \\sim \\mathcal{N}(0,1),\n$$\n其分数阶积分权重由以下递推公式定义：\n$$\nw_0 = 1, \\quad w_k = w_{k-1}\\,\\frac{k-1 + d}{k} \\text{ for } k \\ge 1.\n$$\n对于 $\\text{ARFIMA}(0,d,0)$，长记忆参数 $d$ 通过 $H = d + 0.5$ 与赫斯特指数相关联。因此，$d = 0$ 对应于 $H = 0.5$ (无长程依赖)，$d  0$ 对应于持续性 ($H  0.5$)，$d  0$ 对应于反持续性 ($H  0.5$)。这种构造是一个经过充分检验且广泛使用的长记忆模型，并且是一个纯粹的数学规范。\n\n待实现的估计器：\n- 给定收益率 $\\{r_t\\}_{t=1}^{T}$，计算多个区块大小 $n$ (在给定 $T$ 的可行范围内使用 2 的幂) 的 R/S 统计量，对每个 $n$ 值，汇总所有不重叠区块的平均 $\\log(R(n)/S(n))$，然后通过对 $\\log(R(n)/S(n))$ 与 $\\log(n)$ 进行最小二乘拟合，以所得直线的斜率作为 $H$ 的估计值。分类：当且仅当 $H  0.5$ 时，判定为“随机性较弱”。\n\n角度单位和物理单位：不适用。\n\n测试套件与答案规范：\n实现您的程序，以生成以下合成收益率序列，为每个序列估计 $H$ 值，然后为每个序列输出一个布尔值，指示 $H$ 是否大于 0.5。\n\n- 情况 A (类股票，有效)：$T = 2048$，$d = 0$，种子 $= 12345$。\n- 情况 B (类商品，持续性)：$T = 2048$，$d = 0.2$，种子 $= 24680$。\n- 情况 C (类商品，反持续性)：$T = 2048$，$d = -0.2$，种子 $= 13579$。\n- 情况 D (类股票，短样本边界)：$T = 256$，$d = 0$，种子 $= 424242$。\n- 情况 E (边界附近的温和持续性)：$T = 2048$，$d = 0.05$，种子 $= 2023$。\n\n科学真实性说明：\n- $\\text{ARFIMA}(0,d,0)$ 模型是一种标准的长记忆模型；当 $d = 0$ 时，它简化为与 EMH 一致的独立高斯收益。$d  0$ 的值会引入持续性，$d  0$ 的值会引入反持续性，从而提供可控的比较。R/S 估计器是一种经典的非参数方法，用于从第一性原理评估长记忆性。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。输出必须按 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E] 的顺序列出布尔值。例如：[False,True,False,False,True]。", "solution": "我们推导并实现了一个有原则的赫斯特指数 $H$ 估计器，并将其应用于模拟的收益率序列，这些序列旨在表示长程依赖方面的类股票和类商品行为。该设计源于有效市场假说 (EMH) 和经典的时间序列定义。\n\n基本原理：\n1. 有效市场假说 (EMH)：在一个信息有效的市场中，条件期望收益为零，且收益率在长时程上不表现出可预测的结构。与 EMH 一致的标准数学模型是均值为零的独立同分布高斯收益 $\\{\\varepsilon_t\\}$。汇总到价格上，这会产生一个类似于布朗运动的离散时间鞅，其特征为 $H = 0.5$。\n\n2. 通过重标极差缩放法计算赫斯特指数：对于序列 $\\{x_t\\}_{t=1}^n$，定义累积偏差 $Y_j = \\sum_{i=1}^j (x_i - \\bar{x})$。重标极差为\n$$\n\\frac{R(n)}{S(n)} \\;=\\; \\frac{\\max_{1\\le j\\le n} Y_j - \\min_{1\\le j\\le n} Y_j}{\\sqrt{\\frac{1}{n-1}\\sum_{i=1}^n (x_i - \\bar{x})^2}}.\n$$\n对于具有平稳增量的自相似过程，$\\mathbb{E}[R(n)/S(n)] \\propto n^H$。取对数后，$\\log \\mathbb{E}[R(n)/S(n)] = \\text{constant} + H \\log n$。因此，对多个 $n$ 值的 $\\log(R(n)/S(n))$ 与 $\\log n$ 进行最小二乘拟合，可估计出 $H$。\n\n3. 长记忆数据生成过程：自回归分数阶积分移动平均模型 $\\text{ARFIMA}(0,d,0)$ 是一种以纯数学方式编码长程依赖的典型且经过广泛验证的方法。对于新息 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$ 和分数差分参数 $d$，收益率可以写成分数移动平均\n$$\nr_t = \\sum_{k=0}^{t} w_k \\,\\varepsilon_{t-k},\n$$\n其中权重满足\n$$\nw_0 = 1, \\qquad w_k = w_{k-1}\\,\\frac{k - 1 + d}{k} \\quad \\text{for } k \\ge 1.\n$$\n此表示实现了 $(1 - L)^{-d}\\varepsilon_t$，其中 $L$ 是滞后算子，其在零频率附近的渐近谱密度表现为 $f(\\lambda) \\sim C |\\lambda|^{-2d}$ (C 为某个常数)，这是长记忆的标志。对于 $\\text{ARFIMA}(0,d,0)$，赫斯特指数通过\n$$\nH = d + 0.5.\n$$\n与 $d$ 相关联。因此，$d = 0$ 意味着 $H = 0.5$ (无长程依赖，与 EMH 一致)，$d  0$ 意味着 $H  0.5$ (持续性或“随机性较弱”)，$d  0$ 意味着 $H  0.5$ (反持续性或均值回归)。\n\n算法设计：\n- 步骤 1：对于每个测试用例，使用指定的 $T$、$d$ 和随机种子，通过 $\\text{ARFIMA}(0,d,0)$ 模型生成一个收益率序列 $\\{r_t\\}_{t=1}^{T}$。权重 $\\{w_k\\}$ 通过递推公式 $w_0 = 1, w_k = w_{k-1}\\frac{k-1+d}{k}$ 计算。该序列通过将 $\\{\\varepsilon_t\\}$ 与 $\\{w_k\\}$ 进行卷积来构造；为了计算效率和数值稳定性，使用基于快速傅里叶变换 (FFT) 的卷积。这维持了一个纯数学的设置，并通过固定的种子保证了可复现性。\n- 步骤 2：使用重标极差法从 $\\{r_t\\}$ 中估计赫斯特指数 $H$。将序列划分为大小为 $n$ 的不重叠区块，其中区块大小 $n$ 的网格选择为 2 的幂，使得 $n \\in \\{2^3, 2^4, \\dots\\}$ 且与 $T$ 相比 $n$ 不会过大 (为保证稳定性，最大取到大约 $T/8$)。对于每个 $n$，计算所有区块的 $\\log(R(n)/S(n))$ 的平均值。通过最小二乘法对数据点对 $(\\log n, \\log \\overline{R(n)/S(n)})$ 进行线性拟合；其斜率即为估计值 $\\widehat{H}$。\n- 步骤 3：当且仅当 $\\widehat{H}  0.5$ 时，将每个序列分类为“随机性较弱”。\n\n工作原理：\n- 在 EMH ($d = 0$) 下，随着 $T$ 的增长，$\\widehat{H}$ 会集中在 0.5 附近，反映了长记忆的缺失。当 $d  0$ 时，长记忆属性意味着对数-对数 R/S 图向上倾斜，从而得到 $\\widehat{H}  0.5$。相反，对于 $d  0$，该图会向下倾斜，导致 $\\widehat{H}  0.5$。\n- 该方法直接源于长记忆过程的标度性质，除了 R/S 分析和 ARFIMA 权重的定义属性外，不依赖任何快捷公式。\n\n测试套件详情：\n- 情况 A：$T = 2048$，$d = 0$，种子 $= 12345$ (类股票，与 EMH 一致)。\n- 情况 B：$T = 2048$，$d = 0.2$，种子 $= 24680$ (类商品，持续性)。\n- 情况 C：$T = 2048$，$d = -0.2$，种子 $= 13579$ (类商品，反持续性)。\n- 情况 D：$T = 256$，$d = 0$，种子 $= 424242$ (短样本类股票边界)。\n- 情况 E：$T = 2048$，$d = 0.05$，种子 $= 2023$ ($H = 0.5$ 边界附近的温和持续性)。\n\n预期定性结果：\n- 情况 A 和情况 D 应产生接近 0.5 的 $\\widehat{H}$，根据“$H  0.5$”规则，结果为 False。\n- 情况 B 应产生显著高于 0.5 的 $\\widehat{H}$，结果为 True。\n- 情况 C 应产生低于 0.5 的 $\\widehat{H}$，结果为 False。\n- 情况 E 应产生略高于 0.5 的 $\\widehat{H}$，结果为 True，从而检验在边界附近的判别能力。\n\n程序输出规范：\n- 输出单行，包含一个方括号括起来的逗号分隔的布尔值列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D, 情况 E]，编码每个情况的“$H  0.5$”判定结果。不应打印任何额外文本。\n\n这个端到端的设计从 EMH 作为基础概念开始，采用经过充分检验的长记忆模型生成数据，并使用经典的重标极差法来估计和分类 $H$，其方式是完全自洽且可通过计算验证的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef fractional_integration_weights(d: float, n: int) - np.ndarray:\n    \"\"\"\n    Compute fractional integration weights w_k for k=0..n-1\n    using the recursion: w_0 = 1, w_k = w_{k-1} * (k-1 + d) / k.\n    \"\"\"\n    w = np.empty(n, dtype=float)\n    w[0] = 1.0\n    for k in range(1, n):\n        w[k] = w[k - 1] * ((k - 1) + d) / k\n    return w\n\ndef arfima0d0_returns(n: int, d: float, seed: int) - np.ndarray:\n    \"\"\"\n    Generate ARFIMA(0,d,0) returns via FFT-based convolution of white noise\n    with fractional integration weights.\n\n    r_t = sum_{k=0}^t w_k * eps_{t-k}\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    eps = rng.normal(loc=0.0, scale=1.0, size=n)\n    w = fractional_integration_weights(d, n)\n\n    # Convolution via FFT to compute r = w * eps (causal, length n)\n    conv_len = 1\n    target_len = 2 * n - 1\n    # Next power of two for efficiency\n    while conv_len  target_len:\n        conv_len *= 2\n\n    E = np.fft.rfft(eps, n=conv_len)\n    W = np.fft.rfft(w, n=conv_len)\n    r_full = np.fft.irfft(E * W, n=conv_len)\n    r = r_full[:n]\n\n    return r\n\ndef hurst_rs(x: np.ndarray) - float:\n    \"\"\"\n    Estimate Hurst exponent H using the Rescaled Range (R/S) method.\n    Works on a one-dimensional numpy array x (e.g., returns).\n    \"\"\"\n    x = np.asarray(x, dtype=float)\n    N = x.size\n\n    # Choose window sizes as powers of 2: 8 up to N//8 (inclusive if power-of-two)\n    scales = []\n    n = 8\n    while n = max(8, N // 8):\n        scales.append(n)\n        n *= 2\n\n    log_n = []\n    log_RS = []\n\n    for n in scales:\n        K = N // n  # number of non-overlapping blocks\n        if K  1:\n            continue\n        RS_vals = []\n        for k in range(K):\n            seg = x[k * n:(k + 1) * n]\n            m = seg.mean()\n            y = np.cumsum(seg - m)\n            R = y.max() - y.min()\n            S = seg.std(ddof=1)\n            if S > 0:\n                RS_vals.append(R / S)\n        if len(RS_vals) > 0:\n            log_n.append(np.log(n))\n            log_RS.append(np.log(np.mean(RS_vals)))\n\n    if len(log_n)  2:\n        # Not enough scales to fit a line; return NaN\n        return float(\"nan\")\n\n    # Linear fit: log(R/S) = a + H * log(n)\n    slope, _ = np.polyfit(log_n, log_RS, 1)\n    return float(slope)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (label, T, d, seed)\n    test_cases = [\n        (\"Case A: equity-like, efficient\", 2048, 0.0, 12345),\n        (\"Case B: commodity-like, persistent\", 2048, 0.2, 24680),\n        (\"Case C: commodity-like, anti-persistent\", 2048, -0.2, 13579),\n        (\"Case D: equity-like, short sample\", 256, 0.0, 424242),\n        (\"Case E: mild persistence near boundary\", 2048, 0.05, 2023),\n    ]\n\n    results = []\n    for _label, T, d, seed in test_cases:\n        returns = arfima0d0_returns(T, d, seed)\n        H = hurst_rs(returns)\n        # Classification: less random if H > 0.5\n        is_less_random = (H > 0.5)\n        results.append(is_less_random)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join('True' if r else 'False' for r in results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389272"}, {"introduction": "我们的最后一个实践从统计检验转向了从头开始构建市场模型。通过建立一个基于主体的模型，我们可以探索信息优势（例如，一个更优越的波动率预测模型 GARCH）是否能转化为更高的利润 [@problem_id:2389247]。这个练习有助于我们理解市场效率的*内在机制*，以及不同能力的交易者、交易成本和风险管理是如何共同决定卓越的知识能否持续地带来超额收益。", "problem": "你的任务是设计并执行一个小型计算实验，使用基于主体的模型（Agent-Based Model, ABM）来探讨有效市场假说（Efficient Market Hypothesis, EMH）。核心思想是比较两组主体的已实现净盈利能力，这些主体交易一种具有正漂移但时变波动率的单一风险资产。一半的主体使用广义自回归条件异方差（GARCH）模型来预测波动率，而另一半则使用更简单的滚动窗口方差估计量。你必须实现一个完整的、可运行的程序，该程序模拟收益过程，生成主体的预测，计算头寸，应用交易成本，并比较累计利润。\n\n基本原理：\n- 有效市场假说（EMH）：价格完全反映了所有可用信息，这意味着条件预期超额收益不是系统性可预测的。然而，波动率在实践中可能是可预测的，并且可以影响风险管理和交易成本。\n- 条件收益模型：资产的单期收益模型为 $r_t = \\mu + \\sigma_t \\epsilon_t$，其中 $\\epsilon_t \\sim \\mathcal{N}(0,1)$ 在时间 $t$ 上独立同分布，$\\mu$ 是一个恒定的漂移，$\\sigma_t^2$ 遵循一个条件方差过程。\n- GARCH(1,1) 条件方差：$\\sigma_t^2 = \\omega + \\alpha \\, (r_{t-1} - \\mu)^2 + \\beta \\, \\sigma_{t-1}^2$，其中 $\\omega  0$，$\\alpha \\ge 0$，$\\beta \\ge 0$，且为保证协方差平稳性，$\\alpha + \\beta  1$。\n- 滚动窗口方差估计量：对于一个大小为 $W$ 的窗口，在时间 $t$ 对下一期方差的简单预测使用过去 $W$ 个去均值化收益的样本二阶矩。\n\n需实现的建模与交易规则：\n- 数据生成过程（DGP）：模拟 $T$ 个收益 $\\{r_t\\}_{t=0}^{T-1}$，其中 $r_t = \\mu + \\sigma_t \\epsilon_t$，$\\epsilon_t \\sim \\mathcal{N}(0,1)$，且 $\\sigma_t^2$ 如上所述演变。若 $\\alpha + \\beta  1$，则将 $\\sigma_0^2$ 初始化为无条件方差 $\\omega/(1-\\alpha-\\beta)$，否则初始化为 $\\omega$。\n- 波动率预测：\n  - GARCH 组（一半主体）：在每个时间 $t$，形成一步向前方差预测 $\\widehat{\\sigma}_{t+1,G}^2 = \\omega + \\alpha \\, (r_t - \\mu)^2 + \\beta \\, \\widehat{\\sigma}_{t,G}^2$。当 $\\alpha + \\beta  1$ 时，$\\widehat{\\sigma}_{0,G}^2$ 初始化为与 $\\sigma_0^2$ 相同的无条件方差，否则为 $\\omega$。\n  - 简单组（一半主体）：在每个时间 $t \\ge W-1$，将一步向前方差预测 $\\widehat{\\sigma}_{t+1,S}^2$ 计算为截至时间 $t$ 的过去 $W$ 个观测值的去均值化收益平方的滚动窗口平均值，即 $\\widehat{\\sigma}_{t+1,S}^2 = \\frac{1}{W}\\sum_{j=0}^{W-1} (r_{t-j} - \\mu)^2$。\n- 头寸规模确定与利润：\n  - 设风险目标为 $v_{\\text{target}}  0$。对于组 $g \\in \\{G,S\\}$，在时间 $t$ 将下一期头寸设置为 $x_{t+1}^{(g)} = v_{\\text{target}} / \\widehat{\\sigma}_{t+1,g}$，利用正漂移确定一个仅多头敞口。初始化 $x_0^{(g)} = 0$。\n  - 交易成本：从 $x_{t}^{(g)}$ 变动到 $x_{t+1}^{(g)}$ 会产生一个线性成本 $c \\, |x_{t+1}^{(g)} - x_{t}^{(g)}|$，其中 $c \\ge 0$。\n  - 第 $t+1$ 期的单期利润为 $\\pi_{t+1}^{(g)} = x_{t+1}^{(g)} \\, r_{t+1} - c \\, |x_{t+1}^{(g)} - x_{t}^{(g)}|$。\n  - 组 $g$ 在交易期内的累计利润是在两个预测都存在的期间内 $\\pi_{t+1}^{(g)}$ 的总和。为确保可比性，交易从 $t = W-1$ 开始，并累积至 $t = T-2$，以便 $r_{t+1}$ 可用。\n\n主体组：\n- 共有 $N$ 个主体，其中 $N/2$ 使用 GARCH 预测，N/2 使用滚动窗口预测。由于同一组内的所有主体使用相同的规则，因此组内每个主体的平均利润等于根据上述规则计算的单个主体利润。你应该报告两组之间每个主体的平均累计利润之差，定义为 $\\Pi_{\\text{diff}} = \\Pi_G - \\Pi_S$。\n\n你的任务：\n- 完全按照规定实现模拟和交易逻辑。\n- 为保证可复现性，请使用提供的随机种子。\n- 对于每个测试用例，输出 $\\Pi_{\\text{diff}}$ 的浮点数值。\n\n测试套件：\n对于每个案例，参数以 $(T,\\mu,\\omega,\\alpha,\\beta,W,c,v_{\\text{target}},\\text{seed})$ 的形式给出。\n\n- 案例 A（GARCH 世界，中等成本，典型的日度持续性）：\n  - $(T,\\mu,\\omega,\\alpha,\\beta,W,c,v_{\\text{target}},\\text{seed}) = (4000, 0.0002, 0.000005, 0.05, 0.94, 30, 0.0001, 0.02, 202311)$\n- 案例 B（相同的GARCH 世界，高成本，非常平滑的简单预测）：\n  - $(T,\\mu,\\omega,\\alpha,\\beta,W,c,v_{\\text{target}},\\text{seed}) = (4000, 0.0002, 0.000005, 0.05, 0.94, 250, 0.005, 0.02, 202311)$\n- 案例 C（同方差世界，低成本）：\n  - $(T,\\mu,\\omega,\\alpha,\\beta,W,c,v_{\\text{target}},\\text{seed}) = (4000, 0.0002, 0.0001, 0, 0, 60, 0.0001, 0.02, 202312)$\n- 案例 D（短视界，反应更快的 GARCH，非常嘈杂的简单预测）：\n  - $(T,\\mu,\\omega,\\alpha,\\beta,W,c,v_{\\text{target}},\\text{seed}) = (500, 0.0002, 0.000005, 0.08, 0.90, 5, 0.0002, 0.02, 202313)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按上述测试用例的顺序排列。每个条目必须是 $\\Pi_{\\text{diff}}$ 的浮点数值，四舍五入至6位小数。例如，一个有效的输出格式类似于 $[val_A,val_B,val_C,val_D]$，没有空格，每个值都四舍五入到6位小数。\n- 程序必须是自包含的，并且不得读取任何输入。", "solution": "问题陈述经过严格验证。\n\n步骤 1：提取给定信息\n- **收益模型**：资产在时间 $t$ 的收益为 $r_t = \\mu + \\sigma_t \\epsilon_t$，其中 $\\epsilon_t \\sim \\mathcal{N}(0,1)$ 是独立同分布的标准正态随机变量。$\\mu$ 是一个恒定的漂移。\n- **真实波动率过程 (DGP)**：条件方差 $\\sigma_t^2$ 遵循 GARCH($1,1$) 过程：$\\sigma_t^2 = \\omega + \\alpha \\, (r_{t-1} - \\mu)^2 + \\beta \\, \\sigma_{t-1}^2$。\n- **DGP 参数**：$\\omega  0$，$\\alpha \\ge 0$，$\\beta \\ge 0$，且为保证平稳性 $\\alpha + \\beta  1$。\n- **DGP 初始化**：模拟生成 $T$ 个收益，$\\{r_t\\}_{t=0}^{T-1}$。如果 $\\alpha + \\beta  1$，初始方差 $\\sigma_0^2$ 设置为无条件方差 $\\sigma_{uncond}^2 = \\omega / (1 - \\alpha - \\beta)$，否则设置为 $\\omega$。\n- **主体组**：两组主体，一个 GARCH 组 ($G$) 和一个简单组 ($S$)。\n- **GARCH 组预测**：一步向前方差预测为 $\\widehat{\\sigma}_{t+1,G}^2 = \\omega + \\alpha \\, (r_t - \\mu)^2 + \\beta \\, \\widehat{\\sigma}_{t,G}^2$。初始预测 $\\widehat{\\sigma}_{0,G}^2$ 设置为与初始真实方差 $\\sigma_0^2$ 相等。\n- **简单组预测**：对于大小为 $W$ 的窗口，在时间 $t \\ge W-1$ 时的一步向前方差预测为 $\\widehat{\\sigma}_{t+1,S}^2 = \\frac{1}{W}\\sum_{j=0}^{W-1} (r_{t-j} - \\mu)^2$。\n- **头寸规模确定**：对于组 $g \\in \\{G,S\\}$，第 $t+1$ 期的头寸为 $x_{t+1}^{(g)} = v_{\\text{target}} / \\widehat{\\sigma}_{t+1,g}$，其中 $v_{\\text{target}}  0$ 是风险目标，$\\widehat{\\sigma}_{t+1,g}$ 是预测标准差（预测方差的平方根）。初始头寸为 $x_0^{(g)} = 0$。\n- **交易成本**：当调整头寸时，会产生一个线性成本 $c \\, |x_{t+1}^{(g)} - x_{t}^{(g)}|$，其中 $c \\ge 0$。\n- **利润计算**：第 $t+1$ 期的利润为 $\\pi_{t+1}^{(g)} = x_{t+1}^{(g)} \\, r_{t+1} - c \\, |x_{t+1}^{(g)} - x_{t}^{(g)}|$。\n- **交易期**：利润累积从 $t=W-1$（对应利润期 $W$）开始，到 $t=T-2$（对应利润期 $T-1$）结束。\n- **性能指标**：最终指标是两组之间累计利润的差额，$\\Pi_{\\text{diff}} = \\sum \\pi^{(G)} - \\sum \\pi^{(S)} = \\Pi_G - \\Pi_S$。\n- **测试用例**：指定了四个案例，参数为 $(T, \\mu, \\omega, \\alpha, \\beta, W, c, v_{\\text{target}}, \\text{seed})$。\n\n步骤 2：使用提取的给定信息进行验证\n根据所需标准评估问题。\n- **科学基础**：该问题基于金融计量经济学中标准的、成熟的模型，即用于波动率聚类的 GARCH 模型和一个基本的资产收益模型。旨在检验有效市场假说某些方面的实验设计是计算金融中的标准方法。所有组成部分在科学上都是合理的。\n- **适定性**：该问题在数学上和算法上都是适定的。数据生成过程、预测规则、交易逻辑和成本结构都用精确的方程和参数进行了规定。使用固定的随机种子确保了每次模拟都有唯一且可复现的结果。\n- **客观性**：问题以客观、形式化的语言陈述，没有主观论断或含糊之处。\n\n该问题没有表现出任何无效性缺陷。它在科学上是合理的，可形式化的，并且内部一致。参数已定义，计算过程清晰。该场景是一个简化但有效的量化交易模拟的表示。\n\n步骤 3：结论与行动\n该问题被判定为**有效**。将按规定构建解决方案。\n\n解决方案首先实现资产收益的数据生成过程（DGP）。根据 GARCH($1,1$) 过程模拟一个长度为 $T$ 的收益时间序列 $\\{r_t\\}_{t=0}^{T-1}$。如果平稳性条件 $\\alpha + \\beta  1$ 成立，初始方差 $\\sigma_0^2$ 和 GARCH 主体的初始方差预测 $\\widehat{\\sigma}_{0,G}^2$ 被设置为过程的无条件方差 $\\sigma_{uncond}^2 = \\omega / (1 - \\alpha - \\beta)$。\n\n接下来，在时间序列上执行交易模拟。两组主体都对条件波动率进行一步向前的预测。\n1.  GARCH ($G$) 主体在每个时间步 $t$（从 $t=0$ 到 $t=T-2$）递归地更新他们的预测：$\\widehat{\\sigma}_{t+1,G}^2 = \\omega + \\alpha (r_t - \\mu)^2 + \\beta \\widehat{\\sigma}_{t,G}^2$。\n2.  简单 ($S$) 主体仅在有完整的 $W$ 个过去收益窗口时（即对于 $t \\ge W-1$）计算滚动窗口估计。他们的预测是 $\\widehat{\\sigma}_{t+1,S}^2 = \\frac{1}{W}\\sum_{j=0}^{W-1} (r_{t-j} - \\mu)^2$。\n\n为确保公平比较，两组的交易同时开始。头寸保持为零，直到时间 $t=W-1$，此时可以为两组确定第一个非零头寸 $x_W^{(g)}$。从 $t=W-1$ 到 $t=T-2$，两组都根据各自的波动率预测更新下一期 $t+1$ 的头寸。组 $g$ 的头寸根据波动率目标规则设置：$x_{t+1}^{(g)} = v_{\\text{target}} / \\widehat{\\sigma}_{t+1,g}$，其中 $\\widehat{\\sigma}_{t+1,g}$ 是预测方差 $\\widehat{\\sigma}_{t+1,g}^2$ 的平方根。\n\n对于从 $t+1=W$ 到 $t+1=T-1$ 的每个时期，计算净利润 $\\pi_{t+1}^{(g)}$。这是总交易利润 $x_{t+1}^{(g)} r_{t+1}$ 减去交易成本 $c |x_{t+1}^{(g)} - x_t^{(g)}|$。将这些单期利润相加，得到每个组的总累计利润 $\\Pi_G$ 和 $\\Pi_S$。\n\n最后，计算累计利润的差额 $\\Pi_{\\text{diff}} = \\Pi_G - \\Pi_S$。整个过程封装在一个函数中，该函数针对测试套件中提供的每组参数执行，并使用指定的随机种子以保证可复现性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Case A: (T, mu, omega, alpha, beta, W, c, v_target, seed)\n        (4000, 0.0002, 0.000005, 0.05, 0.94, 30, 0.0001, 0.02, 202311),\n        # Case B: (T, mu, omega, alpha, beta, W, c, v_target, seed)\n        (4000, 0.0002, 0.000005, 0.05, 0.94, 250, 0.005, 0.02, 202311),\n        # Case C: (T, mu, omega, alpha, beta, W, c, v_target, seed)\n        (4000, 0.0002, 0.0001, 0, 0, 60, 0.0001, 0.02, 202312),\n        # Case D: (T, mu, omega, alpha, beta, W, c, v_target, seed)\n        (500, 0.0002, 0.000005, 0.08, 0.90, 5, 0.0002, 0.02, 202313),\n    ]\n\n    results = []\n    for case in test_cases:\n        pi_diff = run_simulation(*case)\n        results.append(pi_diff)\n\n    # Format the final output as specified\n    formatted_results = ','.join([f'{res:.6f}' for res in results])\n    print(f\"[{formatted_results}]\")\n\ndef run_simulation(T, mu, omega, alpha, beta, W, c, v_target, seed):\n    \"\"\"\n    Executes a single simulation run for a given set of parameters.\n\n    Args:\n        T (int): Number of time steps.\n        mu (float): Constant drift of the asset return.\n        omega (float): Constant term in the GARCH process.\n        alpha (float): ARCH parameter.\n        beta (float): GARCH parameter.\n        W (int): Window size for the simple volatility estimator.\n        c (float): Transaction cost coefficient.\n        v_target (float): Target volatility for position sizing.\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        float: The difference in cumulative profits (Pi_G - Pi_S).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # 1. Data Generating Process (DGP)\n    eps = rng.normal(loc=0.0, scale=1.0, size=T)\n    sigma2 = np.zeros(T)\n    r = np.zeros(T)\n\n    if alpha + beta  1:\n        uncond_var = omega / (1 - alpha - beta)\n    else:\n        uncond_var = omega\n    \n    sigma2[0] = uncond_var\n    r[0] = mu + np.sqrt(sigma2[0]) * eps[0]\n\n    for t in range(1, T):\n        sigma2[t] = omega + alpha * (r[t-1] - mu)**2 + beta * sigma2[t-1]\n        r[t] = mu + np.sqrt(sigma2[t]) * eps[t]\n\n    # 2. Trading Simulation\n    # Initialize position arrays and cumulative profits\n    x_G = np.zeros(T)\n    x_S = np.zeros(T)\n    Pi_G, Pi_S = 0.0, 0.0\n\n    # Initialize GARCH forecast\n    sigma2_hat_G = np.zeros(T)\n    sigma2_hat_G[0] = uncond_var\n\n    # Main simulation loop for forecasting and trading\n    for t in range(T - 1):\n        # GARCH agent forecasts for period t+1\n        sigma2_hat_G[t+1] = omega + alpha * (r[t] - mu)**2 + beta * sigma2_hat_G[t]\n\n        # Trading starts at t = W-1 to ensure comparability\n        if t >= W - 1:\n            # Simple agent forecasts for period t+1\n            demeaned_sq_returns = (r[t-W+1 : t+1] - mu)**2\n            sigma2_hat_S = np.mean(demeaned_sq_returns)\n\n            # Position sizing for period t+1\n            # Denominator must be non-zero; GARCH variance forecast is positive by construction,\n            # simple forecast is non-negative, but can be zero in extreme cases.\n            # Add a small epsilon for stability, though unlikely needed with float precision.\n            epsilon = 1e-12\n            sigma_hat_G = np.sqrt(sigma2_hat_G[t+1])\n            sigma_hat_S = np.sqrt(sigma2_hat_S + epsilon)\n\n            x_G[t+1] = v_target / sigma_hat_G if sigma_hat_G > 0 else 0\n            x_S[t+1] = v_target / sigma_hat_S if sigma_hat_S > 0 else 0\n            \n            # Profit calculation for period t+1\n            profit_G = x_G[t+1] * r[t+1] - c * np.abs(x_G[t+1] - x_G[t])\n            profit_S = x_S[t+1] * r[t+1] - c * np.abs(x_S[t+1] - x_S[t])\n            \n            Pi_G += profit_G\n            Pi_S += profit_S\n\n    return Pi_G - Pi_S\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389247"}]}