{"hands_on_practices": [{"introduction": "掌握估值的第一步是细致地处理复杂的现金流结构。本练习超越了简单的年金，旨在为一种“阶梯式”债券估值，其息票支付随时间而变化。此外，它引入了一个现实中的复杂情况：基于息票金额本身的分段税收计划，这要求在进行折现之前，必须仔细地逐期计算实际收到的现金流 [@problem_id:2395387]。", "problem": "一位投资者评估一种递增息票债券，其面值为 $F = 1{,}000$ 美元，到期年限为 $N = 6$ 年。息票支付方案如下：在第 $t = 1, 2, 3$ 年，年息票利率为面值的 $0.03$；在第 $t = 4, 5, 6$ 年，年息票利率为面值的 $0.07$。息票税仅适用于息票支付，并在收到时按当期息票金额 $C$ 的阶梯函数征收：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10,  & \\text{if } 0 \\le C \\le 40, \\\\\n0.20,  & \\text{if } 40  C \\le 60, \\\\\n0.35,   \\text{if } C > 60.\n\\end{cases}\n$$\n到期时偿还的本金不征税。投资者使用固定的年有效收益率 $y = 0.06$ 对现金流进行贴现。通过以收益率 $y$ 贴现税后息票现金流和免税的本金偿还，计算该债券的现值（PV），以美元计。将您的答案四舍五入至四位有效数字。最终金额以美元表示。", "solution": "该问题已经过验证，并被认定为有效。这是一个计算金融学中定义明确的问题，基于现值分析的既定原则，并包含其求解所需的所有必要且一致的信息。\n\n债券的现值（$PV$）是其未来现金流的总和，每笔现金流都贴现至时间 $t=0$ 的价值。现金流包括定期的税后息票支付和最终的本金偿还。现值的通用公式是：\n$$\nPV = \\sum_{t=1}^{N} \\frac{CF_t}{(1+y)^t}\n$$\n其中 $CF_t$ 是在第 $t$ 年末收到的总现金流，$N$ 是到期年限，$y$ 是用于贴现的年有效收益率。\n\n首先，我们必须确定每年的现金流。该债券的面值为 $F = \\$1{,}000$，到期年限为 $N = 6$ 年。贴现收益率为 $y = 0.06$。\n\n步骤 1：计算第 $t = 1, 2, 3$ 年的息票支付和税后现金流。\n给定的年息票利率为 $0.03$。息票金额 $C_1$ 为：\n$$\nC_1 = 0.03 \\times F = 0.03 \\times 1000 = 30\n$$\n为了找到税后现金流，我们应用给定的税收函数 $\\tau(C)$：\n$$\n\\tau(C) = \n\\begin{cases}\n0.10,   \\text{if } 0 \\le C \\le 40 \\\\\n0.20,   \\text{if } 40  C \\le 60 \\\\\n0.35,   \\text{if } C > 60\n\\end{cases}\n$$\n对于 $C_1 = 30$，税率为 $\\tau(30) = 0.10$。\n前三年每年的税后现金流 $CF_1$ 为：\n$$\nCF_1 = C_1 \\times (1 - \\tau(C_1)) = 30 \\times (1 - 0.10) = 30 \\times 0.90 = \\$27\n$$\n\n步骤 2：计算第 $t = 4, 5, 6$ 年的息票支付和税后现金流。\n给定的年息票利率为 $0.07$。息票金额 $C_2$ 为：\n$$\nC_2 = 0.07 \\times F = 0.07 \\times 1000 = 70\n$$\n对于 $C_2 = 70$，税率为 $\\tau(70) = 0.35$。\n后三年每年的税后息票现金流 $CF_2$ 为：\n$$\nCF_2 = C_2 \\times (1 - \\tau(C_2)) = 70 \\times (1 - 0.35) = 70 \\times 0.65 = \\$45.50\n$$\n\n步骤 3：确定总现金流序列。\n在时间 $t$ 的现金流包括税后息票。在到期时（$t=6$），现金流还包括免税的本金偿还 $F = 1000$。\n总现金流（$CF_t$）序列如下：\n- 对于 $t = 1, 2, 3$：$CF_t = \\$27$\n- 对于 $t = 4, 5$：$CF_t = \\$45.50$\n- 对于 $t = 6$：$CF_6 = (\\text{税后息票}) + (\\text{本金}) = 45.50 + 1000 = \\$1045.50$\n\n步骤 4：计算现值。\n现值是贴现后现金流的总和：\n$$\nPV = \\frac{27}{(1+0.06)^1} + \\frac{27}{(1+0.06)^2} + \\frac{27}{(1+0.06)^3} + \\frac{45.5}{(1+0.06)^4} + \\frac{45.5}{(1+0.06)^5} + \\frac{1045.5}{(1+0.06)^6}\n$$\n这个计算可以通过将两组息票支付和最终的本金支付分开来组织。\nPV可以表示为所有六次税后息票的现值与本金的现值之和：\n$$\nPV = \\left( \\sum_{t=1}^{3} \\frac{27}{(1.06)^t} + \\sum_{t=4}^{6} \\frac{45.5}{(1.06)^t} \\right) + \\frac{1000}{(1.06)^6}\n$$\n我们使用普通年金的现值公式，$PV_A = P \\times \\frac{1 - (1+y)^{-n}}{y}$，其中 $P$ 是定期支付额。令 $a_{\\overline{n}|y} = \\frac{1 - (1+y)^{-n}}{y}$。\n\n前三次息票的现值为：\n$$\nPV_{\\text{coupons}, 1-3} = 27 \\times a_{\\overline{3}|0.06} = 27 \\times \\frac{1 - (1.06)^{-3}}{0.06} \\approx 27 \\times 2.673012 = 72.171324\n$$\n第 4、5、6 年的息票现值是一个递延年金。其价值可以通过一个 6 年期年金和一个 3 年期年金的差值来计算：\n$$\nPV_{\\text{coupons}, 4-6} = 45.5 \\times (a_{\\overline{6}|0.06} - a_{\\overline{3}|0.06})\n$$\n$a_{\\overline{6}|0.06} = \\frac{1 - (1.06)^{-6}}{0.06} \\approx 4.917324$\n$$\nPV_{\\text{coupons}, 4-6} \\approx 45.5 \\times (4.917324 - 2.673012) = 45.5 \\times 2.244312 = 102.116196\n$$\n所有税后息票的总现值为：\n$$\nPV_{\\text{coupons}} \\approx 72.171324 + 102.116196 = 174.28752\n$$\n本金偿还的现值为：\n$$\nPV_{\\text{principal}} = \\frac{1000}{(1.06)^6} \\approx 1000 \\times 0.70496054 = 704.96054\n$$\n债券的总现值是这些组成部分的总和：\n$$\nPV = PV_{\\text{coupons}} + PV_{\\text{principal}} \\approx 174.28752 + 704.96054 = 879.24806\n$$\n问题要求将答案四舍五入到四位有效数字。计算出的值为 $879.24806$。前四位有效数字是 $8, 7, 9, 2$。第五位数字是 $4$，所以我们向下舍入。\n$$\nPV \\approx 879.2\n$$\n债券的现值以美元表示。", "answer": "$$\n\\boxed{879.2}\n$$", "id": "2395387"}, {"introduction": "许多金融协议涉及有条件的支付，标准的年金公式无法直接处理。这项实践要求你编写一个程序，来为一种“或有年金”估值，其支付取决于是否达到季度利润阈值。通过实施一个算法来处理这种支付的或有性以及随时间变化的折现率，你将掌握为真实世界的金融工具建模的关键技能 [@problem_id:2395348]。", "problem": "要求您编写一个完整、可运行的程序，用于计算或有年金的现值。该年金的期末付款在未满足特定条件时将被跳过。条件是，公司的季度利润必须达到或超过给定的阈值，才会在该季度末支付一笔固定款项；否则，该季度的付款将被跳过。所有付款均在每季度末发生。所有利率必须按小数处理（不带百分号）。假设对于每个时期 $t$，单期总回报满足 $1 + r_t > 0$。程序不得要求任何用户输入。\n\n基本原理。使用以下基础：确定性、离散复利和无套利条件下的货币时间价值。具体来说，一笔现值金额 $v$ 以每期无风险利率 $r_1, r_2, \\dots, r_t$ 进行投资和复利计算，在 $t$ 个时期后会累积到 $v \\cdot \\prod_{i=1}^{t} (1 + r_i)$。请使用此基础来推导如何用现值来衡量未来日期的现金流价值。\n\n问题设定。对于一个为期 $N$ 个季度的有限期限，给定以下信息：\n- 恒定的季度末付款金额 $A$（以货币单位计）。\n- 利润序列 $\\{P_t\\}_{t=1}^{N}$，其中 $P_t$ 是在第 $t$ 季度观察到的利润。\n- 阈值 $\\theta$（单位与 $\\{P_t\\}$ 相同）。当且仅当 $P_t \\ge \\theta$ 时，才会支付第 $t$ 季度的款项；否则，付款将被跳过。\n- 每季度无风险利率的确定性序列 $\\{r_t\\}_{t=1}^{N}$（每个利率都表示为小数，而非百分比）。\n\n您的任务是计算在时间 $t = 0$ 时，该年金的现值。该年金在每个满足 $P_t \\ge \\theta$ 的季度末支付 $A$，否则支付 $0$，并使用给定的利率期限结构 $\\{r_t\\}$ 进行贴现。\n\n覆盖范围与测试套件。请实现您的程序，为以下每一组参数计算现值。在所有情况下，付款条件均使用包含性规则 $P_t \\ge \\theta$，且付款发生在每个季度 $t \\in \\{1,2,\\dots,N\\}$ 的末尾。\n\n- 测试用例 $1$（理想情况，恒定正利率，混合支付/跳过）：\n  - $A = 100$\n  - $\\theta = 2.5$\n  - $\\{P_t\\}_{t=1}^{5} = [3, 2, 4, 1, 5]$\n  - $\\{r_t\\}_{t=1}^{5} = [0.01, 0.01, 0.01, 0.01, 0.01]$\n- 测试用例 $2$（边界情况：零利率，等于阈值触发支付）：\n  - $A = 50$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{3} = [2, 2, 2]$\n  - $\\{r_t\\}_{t=1}^{3} = [0.0, 0.0, 0.0]$\n- 测试用例 $3$（从未支付）：\n  - $A = 500$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{4} = [1, 1, 1, 1]$\n  - $\\{r_t\\}_{t=1}^{4} = [0.05, 0.05, 0.05, 0.05]$\n- 测试用例 $4$（时变利率，包含一个小的负利率，多次支付）：\n  - $A = 123.45$\n  - $\\theta = 2$\n  - $\\{P_t\\}_{t=1}^{6} = [5, 0, 3, 2, 2, 10]$\n  - $\\{r_t\\}_{t=1}^{6} = [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]$\n- 测试用例 $5$（全部支付，中等正利率，等于阈值）：\n  - $A = 200$\n  - $\\theta = 10$\n  - $\\{P_t\\}_{t=1}^{2} = [10, 10]$\n  - $\\{r_t\\}_{t=1}^{2} = [0.05, 0.05]$\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个数值结果四舍五入到六位小数。例如，$[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5]$。程序必须按顺序计算并打印上述每个测试用例的一个现值。不应打印任何其他文本。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于金融数学原理，问题定义明确，包含所有必要数据和无歧义的条件，并以客观方式表述。该问题按所述方式是可解的。\n\n任务是计算一个为期 $N$ 个季度的有限期限内或有年金的现值 ($PV$)。当且仅当公司在该季度（第 $t$ 季度）的利润 $P_t$ 大于或等于一个指定阈值 $\\theta$ 时，该年金才会在季度末支付一笔金额为 $A$ 的款项。估值必须考虑一个确定性但可能随时间变化的每季度无风险利率序列 $\\{r_t\\}_{t=1}^{N}$。\n\n此计算的基本原则是现值的可加性。一系列现金流的总现值是每笔单独现金流现值的总和。\n\n首先，我们形式化地定义在每个季度 $t \\in \\{1, 2, \\dots, N\\}$ 末发生的现金流 $C_t$。根据问题的或有规则，现金流要么是 $A$，要么是 $0$。这可以用一个指示函数 $I(\\cdot)$ 在数学上表示，当其参数为真时取值为 $1$，否则为 $0$。\n\n$$C_t = A \\cdot I(P_t \\ge \\theta)$$\n\n接下来，我们必须确定每笔现金流 $C_t$ 的现值。问题指定了使用单期利率的期限结构 $\\{r_t\\}$ 的离散复利框架。在时间 $t$ 的未来值，我们称之为 $FV_t$，与它在时间 $t=0$ 的现值 $PV_0$ 通过以下公式相关联：\n\n$$FV_t = PV_0 \\cdot \\prod_{i=1}^{t} (1 + r_i)$$\n\n这个公式描述了现值金额如何随时间累积价值。为了求出在未来时间 $t$ 收到的现金流 $C_t$ 的现值，我们必须反转这个过程，这被称为贴现。通过重新整理公式， $C_t$ 的现值为：\n\n$$PV(C_t) = \\frac{C_t}{\\prod_{i=1}^{t} (1 + r_i)}$$\n\n分母中的项 $\\prod_{i=1}^{t} (1 + r_i)$ 是到时间 $t$ 为止的累积因子。它的倒数 $D_t = 1 / \\prod_{i=1}^{t} (1 + r_i)$ 是时间 $t$ 的贴现因子。问题中说明对于所有 $t$ 都有 $1 + r_t  0$，这确保了贴现因子总是有明确定义且为正值。\n\n根据价值可加性原则，整个或有年金的总现值是从 $t=1$ 到 $N$ 每个季度的现金流现值的总和：\n\n$$PV_{total} = \\sum_{t=1}^{N} PV(C_t) = \\sum_{t=1}^{N} C_t \\cdot D_t$$\n\n代入我们对 $C_t$ 和 $D_t$ 的表达式，我们得到所需现值的完整公式：\n\n$$PV_{total} = \\sum_{t=1}^{N} \\left( A \\cdot I(P_t \\ge \\theta) \\cdot \\frac{1}{\\prod_{i=1}^{t} (1 + r_i)} \\right)$$\n\n为了在算法上实现这一计算，我们对每个测试用例按以下步骤进行：\n1.  将利润序列和利率序列表示为数组 $\\{P_t\\}_{t=1}^{N}$ 和 $\\{r_t\\}_{t=1}^{N}$。\n2.  首先，我们确定或有现金流序列。对于从 $1$ 到 $N$ 的每个 $t$，我们检查是否 $P_t \\ge \\theta$。如果为真，现金流为 $A$；否则为 $0$。这样就生成了现金流序列 $\\{C_t\\}_{t=1}^{N}$。\n3.  接下来，我们计算贴现因子的期限结构。每个时期 $t$ 的贴现因子取决于总回报 $(1 + r_i)$ 的累积乘积。设 $Z_t = \\prod_{i=1}^{t} (1 + r_i)$ 为累积因子。这可以通过迭代计算得出，其中 $Z_t = Z_{t-1} \\cdot (1 + r_t)$，初始值 $Z_0=1$。贴现因子则为 $D_t = 1/Z_t$。\n4.  对于每个季度 $t$，我们通过将现金流 $C_t$ 乘以相应的贴现因子 $D_t$ 来计算贴现现金流。\n5.  最后，我们将这 $N$ 个季度的所有贴现现金流相加，得到总现值。\n\n这个基于资产估值第一性原理的程序将应用于每个提供的测试用例，以得出最终的数值解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the present value of a contingent annuity for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case 1\n        {'A': 100, 'theta': 2.5, 'P_t': [3, 2, 4, 1, 5], 'r_t': [0.01, 0.01, 0.01, 0.01, 0.01]},\n        # Test case 2\n        {'A': 50, 'theta': 2, 'P_t': [2, 2, 2], 'r_t': [0.0, 0.0, 0.0]},\n        # Test case 3\n        {'A': 500, 'theta': 10, 'P_t': [1, 1, 1, 1], 'r_t': [0.05, 0.05, 0.05, 0.05]},\n        # Test case 4\n        {'A': 123.45, 'theta': 2, 'P_t': [5, 0, 3, 2, 2, 10], 'r_t': [0.02, 0.03, -0.005, 0.01, 0.0, 0.04]},\n        # Test case 5\n        {'A': 200, 'theta': 10, 'P_t': [10, 10], 'r_t': [0.05, 0.05]}\n    ]\n\n    results = []\n    for case in test_cases:\n        # Extract parameters for the current test case\n        A = case['A']\n        theta = case['theta']\n        P_t = np.array(case['P_t'])\n        r_t = np.array(case['r_t'])\n\n        # Step 1: Determine the contingent cash flows for each period.\n        # The cash flow is 'A' if P_t = theta, and 0 otherwise.\n        # This is achieved by creating a boolean mask and multiplying by A.\n        payment_occurs_mask = (P_t = theta)\n        cash_flows = A * payment_occurs_mask\n\n        # Step 2: Calculate the discount factor for each period.\n        # The discount factor for period t is 1 / product(1+r_i) for i from 1 to t.\n        \n        # Gross returns for each period (1 + r_t)\n        gross_returns = 1 + r_t\n        \n        # Cumulative product of gross returns gives the denominator of the discount factor.\n        # np.cumprod([g1, g2, g3]) yields [g1, g1*g2, g1*g2*g3]\n        discount_denominators = np.cumprod(gross_returns)\n        \n        # Step 3: Calculate the present value of each cash flow\n        discounted_cash_flows = cash_flows / discount_denominators\n        \n        # Step 4: Sum the present values of all cash flows to get the total PV\n        total_pv = np.sum(discounted_cash_flows)\n        \n        # Format the result to six decimal places and append to the list\n        results.append(f\"{total_pv:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2395348"}, {"introduction": "现在我们进入一个动态估值模型，其中公司的增长是内生决定的。这个问题要求你为一家通过再投资部分收益来实现增长的公司估值，而该投资的回报率又取决于公司当前的规模。你将使用递归来模拟这种反馈循环，这为简单的恒定增长模型提供了一个更复杂的替代方案，并阐释了公司估值中内生成长理论的核心原理 [@problem_id:2395318]。", "problem": "一家公司在离散时间 $t \\in \\{0,1,2,\\dots\\}$ 内产生收益。设时间 $t$ 的收益为 $Y_t \\ge 0$（以货币单位计）。在每个时间点 $t$，公司支付的股息 $D_t$ 等于未进行再投资的收益部分，因此 $D_t = (1-g_t) Y_t$，其中 $g_t \\in [0,1]$ 是在时间 $t$ 的再投资率。再投资金额为 $I_t = g_t Y_t$。新投资的回报率不是恒定的：由于时间 $t$ 的再投资，下一期收益的增量比例收益由回报函数 $r(Y_t) = \\dfrac{a}{1 + b Y_t}$ 给出，其中 $a > 0$ 和 $b \\ge 0$ 是参数。收益根据递归关系 $Y_{t+1} = Y_t \\bigl(1 + r(Y_t) g_t \\bigr)$ 演变。公司现值 (PV) 以一个恒定的要求回报率 $R > 0$（以小数表示，而非百分比）进行折现，是股息的折现总和，\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t,\n$$\n其中 $\\beta = \\dfrac{1}{1+R}$。你必须使用递归计算来近似 $\\text{PV}(Y_0)$，当下一个折现后股息贡献的绝对值低于容差 $\\varepsilon > 0$（即 $\\beta^t |D_t|  \\varepsilon$）时，或当达到硬性期限 $H \\in \\mathbb{N}$ 时停止，以先发生者为准。所有比率必须以小数形式提供和解释。每个测试用例的最终答案必须是与 $Y_0$ 相同货币单位的现值，四舍五入到 $6$ 位小数。\n\n实现一个完整、可运行的程序，该程序定义并使用一个与上述描述一致的递归函数，为以下测试套件中的每个参数集计算 $\\text{PV}(Y_0)$。在每种情况下，如果提供的再投资序列 $[g_0,g_1,\\dots,g_{L-1}]$ 的长度为 $L$，那么对于所有 $t \\ge L$，使用 $g_t = g_{L-1}$。\n\n测试套件：\n- 案例 $1$（一般情况，非恒定再投资）：$Y_0 = 100.0$，$R = 0.08$，$a = 0.25$，$b = 0.01$，$[g_0,g_1,g_2] = [0.4,0.35,0.3]$，$H = 500$，$\\varepsilon = 10^{-12}$。\n- 案例 $2$（完全再投资边界）：$Y_0 = 50.0$，$R = 0.10$，$a = 0.30$，$b = 0.02$，$[g_0] = [1.0]$，$H = 500$，$\\varepsilon = 10^{-12}$。\n- 案例 $3$（小额再投资，回报迅速下降）：$Y_0 = 120.0$，$R = 0.05$，$a = 0.20$，$b = 0.05$，$[g_0] = [0.05]$，$H = 500$，$\\varepsilon = 10^{-12}$。\n- 案例 $4$（时变再投资，趋近于零）：$Y_0 = 80.0$，$R = 0.12$，$a = 0.40$，$b = 0.03$，$[g_0,g_1,g_2,g_3] = [0.6,0.2,0.1,0.0]$，$H = 500$，$\\varepsilon = 10^{-12}$。\n\n你的程序必须生成单行输出，其中包含按上述顺序列出的案例结果，形式为一个逗号分隔的列表，包含四个四舍五入后的PV值，并用方括号括起来。输出必须只包含四个四舍五入到 $6$ 位小数的浮点数，不得包含任何额外文本。", "solution": "问题陈述已被评估并确定为有效。它具有科学依据，提法明确且客观。提供了唯一确定性解所需的所有必要数据和条件。该问题是计算金融学中的一个标准练习，具体涉及使用具有非恒定增长的股息贴现模型对公司进行估值。它没有违反任何指定的无效标准。因此，我们可以着手解决。\n\n目标是根据公司未来的股息流计算其现值 $\\text{PV}$。基本原则是，一项资产的价值是其预期未来现金流折现到现在的总和。对于在每个离散时间段 $t \\in \\{0, 1, 2, \\dots\\}$ 支付股息 $D_t$ 的公司，其现值由以下公式给出：\n$$\n\\text{PV}(Y_0) = \\sum_{t=0}^{\\infty} \\beta^t D_t\n$$\n其中 $Y_0$ 是初始收益，$D_t = (1-g_t)Y_t$ 是时间 $t$ 的股息，$g_t$ 是再投资率，而 $\\beta = \\frac{1}{1+R}$ 是对应于要求回报率 $R$ 的折现因子。\n\n收益 $Y_t$ 根据以下递归关系演变：\n$$\nY_{t+1} = Y_t \\left(1 + r(Y_t) g_t\\right)\n$$\n其中新投资的回报率由 $r(Y_t) = \\frac{a}{1 + b Y_t}$ 给出。\n\n$\\text{PV}(Y_0)$ 的无限求和在计算上是难以处理的。因此，我们必须用有限和来近似它。求和根据两个条件被截断：最大时间期限 $H$ 和容差 $\\varepsilon$。如果 $t \\ge H$ 或者该时期的折现股息项 $\\beta^t |D_t|$ 小于 $\\varepsilon$，则计算在时间 $t$ 停止。\n\n为了形式化所需的递归计算，我们定义一个函数 $V(t, Y_t, \\beta_p)$，它计算从时间 $t$ 开始的折现股息总和，其中 $Y_t$ 是时间 $t$ 的收益，$\\beta_p = \\beta^t$ 是时期 $t$ 的折现因子。那么总现值就是 $V(0, Y_0, 1)$。\n\n时间 $t$ 的股息是 $D_t = (1-g_t)Y_t$。这个单一股息对总现值的贡献是 $\\Delta \\text{PV}_t = \\beta_p D_t$。\n\n递归结构基于以下逻辑：从时间 $t$ 开始的总价值等于时间 $t$ 的股息价值加上从时间 $t+1$ 开始的总价值。\n$$\nV(t, Y_t, \\beta_p) = \\Delta \\text{PV}_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta)\n$$\n这个递归关系必须包含终止条件。如果满足条件，递归终止，并且不再增加任何价值。这导致了递归步骤的以下精确定义：\n\n$V(t, Y_t, \\beta_p) = \\begin{cases} 0   \\text{if } t \\ge H \\text{ or } \\beta_p |(1-g_t)Y_t|  \\varepsilon \\\\ \\beta_p (1-g_t)Y_t + V(t+1, Y_{t+1}, \\beta_p \\cdot \\beta)   \\text{otherwise} \\end{cases}$\n\n其中 $Y_{t+1}$ 由 $Y_t$ 和 $g_t$ 计算得出。对于任何时间 $t$，再投资率 $g_t$ 由提供的序列 $[g_0, g_1, \\dots, g_{L-1}]$ 决定，规则如下：如果 $t  L$，$g_t$ 是序列的第 $t$ 个元素；否则，$g_t = g_{L-1}$。这可以通过访问索引为 $\\min(t, L-1)$ 的序列元素来实现。\n\n递归的基本情况是返回 $0$ 的条件。递归步骤计算当前项，并加上对下一个时间步调用的结果。对于给定的参数集，计算总现值的初始调用是 $V(0, Y_0, 1.0)$。这个结构为问题提供了一个完整的算法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport sys\n\n# It is good practice to set a higher recursion limit for problems involving deep recursion,\n# though the default of 1000 is sufficient for H=500.\nsys.setrecursionlimit(2000)\n\ndef compute_pv_recursive(t, current_y, current_beta_power, params):\n    \"\"\"\n    Recursively computes the Present Value of dividends from time t onwards.\n\n    Args:\n        t (int): The current time step.\n        current_y (float): The earnings at time t.\n        current_beta_power (float): The discount factor for time t, beta^t.\n        params (dict): A dictionary containing all model parameters.\n\n    Returns:\n        float: The Present Value of the dividend stream from time t onwards.\n    \"\"\"\n    # Unpack parameters\n    a = params['a']\n    b = params['b']\n    g_sequence = params['g_sequence']\n    H = params['H']\n    epsilon = params['epsilon']\n    beta = params['beta']\n    \n    # Termination condition 1: Hard horizon\n    if t = H:\n        return 0.0\n\n    # Determine the reinvestment fraction g_t\n    g_sequence_len = len(g_sequence)\n    if t  g_sequence_len:\n        g_t = g_sequence[t]\n    else:\n        g_t = g_sequence[-1]\n\n    # Calculate dividend D_t\n    d_t = (1.0 - g_t) * current_y\n    \n    # Calculate the discounted dividend term\n    term = current_beta_power * d_t\n\n    # Termination condition 2: Tolerance\n    # Since Y_t = 0 and g_t = 1, D_t is non-negative. So |D_t| = D_t.\n    if term  epsilon:\n        return 0.0\n\n    # Calculate return on investment r(Y_t)\n    r_t = a / (1.0 + b * current_y)\n\n    # Calculate earnings for the next period Y_{t+1}\n    next_y = current_y * (1.0 + r_t * g_t)\n\n    # Recursive step\n    return term + compute_pv_recursive(t + 1, next_y, current_beta_power * beta, params)\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        {'Y0': 100.0, 'R': 0.08, 'a': 0.25, 'b': 0.01, 'g_sequence': [0.4, 0.35, 0.3], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 50.0, 'R': 0.10, 'a': 0.30, 'b': 0.02, 'g_sequence': [1.0], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 120.0, 'R': 0.05, 'a': 0.20, 'b': 0.05, 'g_sequence': [0.05], 'H': 500, 'epsilon': 1e-12},\n        {'Y0': 80.0, 'R': 0.12, 'a': 0.40, 'b': 0.03, 'g_sequence': [0.6, 0.2, 0.1, 0.0], 'H': 500, 'epsilon': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initial parameters for the recursive calculation\n        t0 = 0\n        y0 = case['Y0']\n        beta = 1.0 / (1.0 + case['R'])\n        \n        # Add beta to the parameters dictionary to pass to the recursive function\n        case['beta'] = beta\n\n        # Initial call to the recursive function\n        pv = compute_pv_recursive(t0, y0, 1.0, case)\n        \n        # Round result to 6 decimal places\n        results.append(round(pv, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2395318"}]}