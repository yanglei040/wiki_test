{"hands_on_practices": [{"introduction": "传统的风险衡量标准是标准差，但它同等对待了有利的向上波动和不利的向下波动。本练习将介绍一个更符合直觉的风险度量——下行偏差（downside deviation），它只关注低于特定回报阈值的有害波动。通过这个实践，学生将能够超越标准的马科维茨模型，构建出更贴合投资者心理的优化框架 [@problem_id:2420250]。", "problem": "给定一个风险资产集合的月度收益率样本，您需要使用相对于指定阈值的下行偏差（半方差）作为风险度量，重新计算有效前沿。一个投资组合由权重 $w \\in \\mathbb{R}^N$ 表示，其中对所有 $i$ 都有 $w_i \\geq 0$，且 $\\sum_{i=1}^N w_i = 1$。给定资产收益向量 $r_t \\in \\mathbb{R}^N$ 的时间序列 $\\{r_t\\}_{t=1}^T$，样本投资组合期望收益率为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$。对于给定的阈值 $\\tau \\in \\mathbb{R}$，样本半方差为\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2,\n$$\n且下行偏差为 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$。所有收益率都是无单位的，并以小数形式表示。\n\n您的任务是，对于下面指定的每个测试用例，计算在所有满足 $w_i \\ge 0$、$\\sum_{i=1}^N w_i = 1$ 和 $\\mu(w) \\ge \\mu_{\\text{target}}$ 的投资组合 $w$ 中，最小的下行偏差 $d^\\star(\\mu_{\\text{target}},\\tau)$。\n\n数据：有 $N=3$ 种资产和 $T=12$ 个月。每种资产的月度收益率如下：\n\n- 资产1：$[-0.01,\\ 0.005,\\ 0.012,\\ 0.007,\\ -0.004,\\ 0.009,\\ 0.011,\\ 0.006,\\ 0.003,\\ 0.008,\\ 0.010,\\ 0.007]$。\n- 资产2：$[-0.015,\\ 0.012,\\ 0.018,\\ 0.010,\\ -0.006,\\ 0.015,\\ 0.020,\\ 0.011,\\ 0.004,\\ 0.013,\\ 0.019,\\ 0.012]$。\n- 资产3：$[-0.03,\\ 0.025,\\ 0.035,\\ 0.020,\\ -0.015,\\ 0.028,\\ 0.038,\\ 0.022,\\ 0.010,\\ 0.030,\\ 0.036,\\ 0.024]$。\n\n设第 $t$ 个月的资产收益为从上述序列中提取的列向量 $r_t \\in \\mathbb{R}^3$。\n\n测试套件：为以下每个参数对 $(\\mu_{\\text{target}},\\tau)$ 计算 $d^\\star(\\mu_{\\text{target}},\\tau)$：\n\n- 案例1：$(\\mu_{\\text{target}},\\tau) = (0.007,\\ 0.0)$。\n- 案例2：$(\\mu_{\\text{target}},\\tau) = (0.012,\\ 0.005)$。\n- 案例3：$(\\mu_{\\text{target}},\\tau) = (0.018,\\ 0.015)$。\n- 案例4：$(\\mu_{\\text{target}},\\tau) = (0.0185833333333,\\ 0.020)$。\n\n约定和要求：\n\n- 所有收益率均为小数；请勿使用百分号。\n- 每个案例的最终答案必须是最小化的下行偏差值 $d^\\star(\\mu_{\\text{target}},\\tau)$，每个值都表示为精确到小数点后 $6$ 位的小数。\n- 您的程序必须生成单行输出，其中包含按上述案例顺序排列的结果，形式为方括号内以逗号分隔的列表，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是案例 $i$ 的四舍五入后的小数值。\n- 您的程序必须是一个完整、可运行的程序，根据上述定义和提供的数据从基本原理计算所需值，并以确切要求的格式生成输出。不允许用户输入，也不使用外部文件。", "solution": "该问题已经过分析并被确定为有效。这是一个在计算金融领域中提法恰当、有科学依据的问题，没有任何歧义或矛盾。\n\n任务是，在给定 $T=12$ 个时期的收益率时间序列的情况下，为一个由 $N=3$ 种资产组成的投资组合找到最小下行偏差。这需要为几个指定的参数集求解一个有约束的非线性优化问题。\n\n该投资组合由权重向量 $w \\in \\mathbb{R}^N$ 定义，其中 $w_i$ 是资产 $i$ 的权重。投资组合权重的约束条件是：\n1. 非负性：对于 $i=1, 2, \\dots, N$，有 $w_i \\ge 0$。这意味着不允许卖空。\n2. 完全投资：$\\sum_{i=1}^N w_i = 1$。全部资本在这些资产中进行分配。\n\n样本投资组合期望收益率定义为 $\\mu(w) = \\frac{1}{T} \\sum_{t=1}^T w^\\top r_t$，其中 $r_t \\in \\mathbb{R}^N$ 是在时间 $t$ 的资产收益向量。这可以简化为 $\\mu(w) = w^\\top \\bar{r}$，其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^T r_t$ 是平均资产收益向量。\n\n风险度量是样本下行偏差 $d(w;\\tau) = \\sqrt{\\sigma_-^2(w;\\tau)}$，其中 $\\sigma_-^2(w;\\tau)$ 是相对于收益阈值 $\\tau$ 的样本半方差：\n$$\n\\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max\\!\\left(0,\\, \\tau - w^\\top r_t \\right)^2\n$$\n最小化下行偏差 $d(w;\\tau)$ 等同于最小化半方差 $\\sigma_-^2(w;\\tau)$，因为平方根函数对于非负值是严格单调的。这避免了在优化目标中处理平方根，从而简化了问题。\n\n对于由参数对 $(\\mu_{\\text{target}}, \\tau)$ 定义的每个测试用例，我们必须解决以下优化问题：\n$$\n\\begin{aligned}\n\\underset{w}{\\text{minimize}} \\quad  \\sigma_-^2(w;\\tau) = \\frac{1}{T} \\sum_{t=1}^T \\max(0, \\tau - w^\\top r_t)^2 \\\\\n\\text{subject to} \\quad  w \\in \\mathbb{R}^N \\\\\n \\sum_{i=1}^N w_i = 1 \\\\\n w_i \\ge 0, \\quad \\text{for } i=1, \\dots, N \\\\\n \\mu(w) \\ge \\mu_{\\text{target}}\n\\end{aligned}\n$$\n这是一个凸优化问题，因为目标函数 $\\sigma_-^2(w;\\tau)$ 是关于 $w$ 的凸函数，并且约束条件定义了一个凸可行集（一个多胞形）。因此，找到的任何局部最小值也是全局最小值。\n\n该问题将使用序列最小二乘规划（Sequential Least Squares Programming, SLSQP）算法进行数值求解，该算法非常适合有约束的非线性优化。实现将使用 Python 中的 `scipy.optimize.minimize` 函数完成。求解器的输入是：\n- 目标函数，它为给定的权重向量 $w$ 计算 $\\sigma_-^2(w;\\tau)$。\n- 约束集：权重总和的等式约束，最小目标收益率的不等式约束，以及权重非负性的边界条件。\n- 权重 $w$ 的初始猜测值，一个标准的做法是选择等权重投资组合，即 $w_i = 1/N$。\n\n每个案例的最终答案 $d^\\star(\\mu_{\\text{target}},\\tau)$ 是通过对优化器返回的最小化半方差取平方根得到的。将使用提供的资产收益数据和测试用例参数来计算所要求的四个值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Computes the minimum downside deviation for a portfolio of assets\n    subject to a target return constraint.\n    \"\"\"\n    # Define asset return data\n    asset1_returns = np.array([-0.01, 0.005, 0.012, 0.007, -0.004, 0.009, 0.011, 0.006, 0.003, 0.008, 0.010, 0.007])\n    asset2_returns = np.array([-0.015, 0.012, 0.018, 0.010, -0.006, 0.015, 0.020, 0.011, 0.004, 0.013, 0.019, 0.012])\n    asset3_returns = np.array([-0.03, 0.025, 0.035, 0.020, -0.015, 0.028, 0.038, 0.022, 0.010, 0.030, 0.036, 0.024])\n\n    # Combine into a single matrix R of shape (T, N)\n    returns_matrix = np.vstack([asset1_returns, asset2_returns, asset3_returns]).T\n    \n    T, N = returns_matrix.shape\n    mean_asset_returns = np.mean(returns_matrix, axis=0)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.007, 0.0),\n        (0.012, 0.005),\n        (0.018, 0.015),\n        (0.0185833333333, 0.020),\n    ]\n\n    results = []\n    for mu_target, tau in test_cases:\n        # Define the objective function (semi-variance) to be minimized.\n        # w: portfolio weights (optimization variable)\n        # R: matrix of asset returns\n        # T_val: number of time periods\n        # tau_val: downside deviation threshold\n        def objective_func(w, R, T_val, tau_val):\n            portfolio_returns = R @ w\n            downside_diffs = np.maximum(0, tau_val - portfolio_returns)\n            semi_variance = np.sum(downside_diffs**2) / T_val\n            return semi_variance\n\n        # Define constraints for the optimization\n        constraints = [\n            # Constraint 1: Sum of weights must be 1 (fully invested)\n            {'type': 'eq', 'fun': lambda w: np.sum(w) - 1},\n            # Constraint 2: Portfolio expected return must meet or exceed target\n            {'type': 'ineq', 'fun': lambda w: w @ mean_asset_returns - mu_target}\n        ]\n\n        # Define bounds for the weights (w_i >= 0, no short selling)\n        bounds = [(0, None) for _ in range(N)]\n\n        # Initial guess for the weights (equal weighting)\n        w0 = np.ones(N) / N\n\n        # Perform the optimization using SLSQP\n        opt_result = minimize(\n            objective_func,\n            w0,\n            args=(returns_matrix, T, tau),\n            method='SLSQP',\n            bounds=bounds,\n            constraints=constraints,\n            tol=1e-12  # Set a tight tolerance for accuracy\n        )\n\n        # The result from the optimizer is the minimized semi-variance\n        min_semi_variance = opt_result.fun\n        \n        # The required answer is the downside deviation (sqrt of semi-variance)\n        min_downside_deviation = np.sqrt(min_semi_variance)\n        \n        results.append(min_downside_deviation)\n\n    # Format the results as specified: a comma-separated list of decimals\n    # rounded to 6 places, enclosed in square brackets.\n    output_str = '[' + ','.join([f\"{r:.6f}\" for r in results]) + ']'\n    print(output_str)\n\nsolve()\n```", "id": "2420250"}, {"introduction": "投资组合优化不仅要考虑风险和回报的权衡，常常还需要满足特定的投资要求，例如限制对整体市场波动的敞口。本练习将演示如何在优化问题中整合这类约束，具体来说，就是利用贝塔系数（beta）来控制市场风险。通过求解这个问题，学生将学会如何构建满足特定策略需求的投资组合，例如市场中性或低波动性策略 [@problem_id:2420305]。", "problem": "考虑一个包含 $n$ 种风险资产的投资域，其随机收益由随机向量 $R \\in \\mathbb{R}^n$ 表示。设期望收益向量为 $\\mu \\in \\mathbb{R}^n$，协方差矩阵为 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，并假设其为对称正定矩阵。一个投资组合由权重向量 $w \\in \\mathbb{R}^n$ 表示，其中 $w_i$ 是投资于资产 $i$ 的总财富比例，预算约束为 $1^\\top w = 1$。允许卖空。市场投资组合由一个固定的权重向量 $m \\in \\mathbb{R}^n$ 表示，且满足 $1^\\top m = 1$。一个投资组合相对于市场的贝塔值定义为\n$$\n\\beta(w) \\equiv \\frac{\\operatorname{Cov}(w^\\top R, m^\\top R)}{\\operatorname{Var}(m^\\top R)} = \\frac{w^\\top \\Sigma m}{m^\\top \\Sigma m}.\n$$\n对于给定的目标期望收益 $\\mu_{\\text{target}} \\in \\mathbb{R}$ 和一个贝塔上限 $B \\in \\mathbb{R}$，确定能最小化投资组合方差的投资组合 $w^\\star$，该组合需满足预算约束、目标期望收益约束和贝塔上限不等式约束：\n$$\n\\min_{w \\in \\mathbb{R}^n} \\; w^\\top \\Sigma w \\quad \\text{subject to} \\quad 1^\\top w = 1,\\;\\; \\mu^\\top w = \\mu_{\\text{target}},\\;\\; \\beta(w) \\le B.\n$$\n所有收益均以小数表示（例如，$0.08$ 表示 $8/100$）。要求输出的是最优权重向量，每个向量均以小数表示。\n\n测试套件。对于下方的每个测试用例，计算并返回解决上述问题的最优 $w^\\star$。\n\n- 测试用例 1（理想路径，不等式不一定具有约束性）：\n  - $n = 4$，\n  - $\\mu = (0.08,\\, 0.12,\\, 0.10,\\, 0.07)^\\top$，\n  - $\\Sigma = \\begin{pmatrix}\n  0.04  0.036  0.0196  0.006928 \\\\\n  0.036  0.09  0.03675  0.015588 \\\\\n  0.0196  0.03675  0.060025  0.0106085 \\\\\n  0.006928  0.015588  0.0106085  0.029985\n  \\end{pmatrix}$，\n  - $m = (0.4,\\, 0.3,\\, 0.2,\\, 0.1)^\\top$，\n  - $\\mu_{\\text{target}} = 0.095$，\n  - $B = 0.5$。\n\n- 测试用例 2（贝塔上限很可能具有约束性）：\n  - $n$、$\\mu$、$\\Sigma$ 和 $m$ 与测试用例 1 相同，\n  - $\\mu_{\\text{target}} = 0.11$，\n  - $B = 0.3$。\n\n- 测试用例 3（贝塔上限为零的边缘情况）：\n  - $n$、$\\mu$、$\\Sigma$ 和 $m$ 与测试用例 1 相同，\n  - $\\mu_{\\text{target}} = 0.09$，\n  - $B = 0.0$。\n\n- 测试用例 4（不同的投资域）：\n  - $n = 3$，\n  - $\\mu = (0.06,\\, 0.09,\\, 0.15)^\\top$，\n  - $\\Sigma = \\begin{pmatrix}\n  0.02  0.0063245553  0.0063245553 \\\\\n  0.0063245553  0.05  0.04 \\\\\n  0.0063245553  0.04  0.2\n  \\end{pmatrix}$，\n  - $m = (0.2,\\, 0.5,\\, 0.3)^\\top$，\n  - $\\mu_{\\text{target}} = 0.10$，\n  - $B = 0.5$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个由方括号括起来的、以逗号分隔的结果列表。每个结果本身是一个包含 $n$ 个最优权重的列表，权重值需精确到小数点后 $6$ 位。例如，输出必须采用\n$[ [w^{(1)}_1,\\dots,w^{(1)}_n], [w^{(2)}_1,\\dots,w^{(2)}_n], [w^{(3)}_1,\\dots,w^{(3)}_n], [w^{(4)}_1,\\dots,w^{(4)}_n] ]$\n的格式，逗号后没有空格。每个 $w^{(k)}_i$ 都必须是小数点后有 $6$ 位数字的小数。", "solution": "我们将带有贝塔上限的均值-方差问题形式化为一个凸二次优化问题。令 $w \\in \\mathbb{R}^n$ 为决策向量。目标是最小化 $w^\\top \\Sigma w$，其约束条件为 $1^\\top w = 1$、$\\mu^\\top w = \\mu_{\\text{target}}$ 以及市场贝塔约束 $\\beta(w) \\le B$。贝塔约束可以写成关于 $w$ 的线性形式，因为 $m^\\top \\Sigma m$ 是一个正标量常数：\n$$\n\\beta(w) \\le B \\quad \\Longleftrightarrow \\quad \\frac{w^\\top \\Sigma m}{m^\\top \\Sigma m} \\le B \\quad \\Longleftrightarrow \\quad (\\Sigma m)^\\top w \\le B\\,(m^\\top \\Sigma m).\n$$\n定义 $c \\equiv \\Sigma m \\in \\mathbb{R}^n$ 和 $\\kappa \\equiv m^\\top \\Sigma m \\in \\mathbb{R}_{0}$。可行集由两个等式 $1^\\top w = 1$、$\\mu^\\top w = \\mu_{\\text{target}}$ 和一个不等式 $c^\\top w \\le B \\kappa$ 描述。\n\n因为成本函数 $w^\\top \\Sigma w$ 是严格凸的（因为 $\\Sigma$ 是正定的），且所有约束都是仿射的，所以存在唯一的全局最小值点。根据基本原理，我们建立拉格朗日函数和 Karush–Kuhn–Tucker (KKT) 条件。对于等式 $A w = b$，其中\n$$\nA = \\begin{pmatrix} 1^\\top \\\\ \\mu^\\top \\end{pmatrix} \\in \\mathbb{R}^{2 \\times n}, \\quad b = \\begin{pmatrix} 1 \\\\ \\mu_{\\text{target}} \\end{pmatrix} \\in \\mathbb{R}^2,\n$$\n拉格朗日函数（暂时忽略不等式）为\n$$\n\\mathcal{L}(w,\\lambda) = \\tfrac{1}{2} w^\\top \\Sigma w + \\lambda^\\top (A w - b),\n$$\n其中 $\\lambda \\in \\mathbb{R}^2$ 是拉格朗日乘子。一阶条件得出\n$$\n\\nabla_w \\mathcal{L} = \\Sigma w + A^\\top \\lambda = 0, \\quad A w = b.\n$$\n这些可以写成线性 KKT 系统\n$$\n\\begin{pmatrix}\n\\Sigma  A^\\top \\\\\nA  0\n\\end{pmatrix}\n\\begin{pmatrix}\nw \\\\ \\lambda\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ b\n\\end{pmatrix}.\n$$\n求解此系统可得到只含等式约束问题的唯一最小值点 $w_0$。为了纳入不等式 $c^\\top w \\le B \\kappa$，我们考虑不等式乘子 $\\nu \\ge 0$ 的 KKT 互补松弛条件：\n$$\n\\nu \\ge 0,\\quad c^\\top w - B \\kappa \\le 0,\\quad \\nu\\,(c^\\top w - B \\kappa) = 0.\n$$\n因为只有一个线性不等式且问题是严格凸的，最优解要么使得不等式非激活（松弛），此时 $\\nu = 0$ 且 $c^\\top w_0 \\le B \\kappa$；要么使得不等式激活（约束），此时 $c^\\top w^\\star = B \\kappa$。在约束情况下，问题简化为带三个等式约束的最小化问题：\n$$\n\\min_{w} \\; w^\\top \\Sigma w \\quad \\text{subject to} \\quad\n\\begin{cases}\n1^\\top w = 1, \\\\\n\\mu^\\top w = \\mu_{\\text{target}}, \\\\\nc^\\top w = B \\kappa.\n\\end{cases}\n$$\n这会产生一个 KKT 系统\n$$\n\\begin{pmatrix}\n\\Sigma  A^\\top  c \\\\\nA  0  0 \\\\\nc^\\top  0  0\n\\end{pmatrix}\n\\begin{pmatrix}\nw \\\\ \\lambda \\\\ \\nu\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ b \\\\ B \\kappa\n\\end{pmatrix},\n$$\n当贝塔约束具有约束性时，其唯一解即为 $w^\\star$。因此，从基本原理推导出的求解策略如下：\n- 求解等式约束问题以获得 $w_0$。\n- 计算 $\\beta(w_0) = \\dfrac{w_0^\\top \\Sigma m}{m^\\top \\Sigma m} = \\dfrac{c^\\top w_0}{\\kappa}$。\n- 如果 $\\beta(w_0) \\le B$，则 $w^\\star = w_0$。\n- 否则，求解三等式 KKT 系统以获得满足 $c^\\top w^\\star = B \\kappa$ 的 $w^\\star$。\n\n对于每个测试用例，我们根据给定的 $\\Sigma$ 和 $m$ 计算 $c$ 和 $\\kappa$，然后应用上述步骤。利用数值线性代数方法，并基于 $\\Sigma$ 的正定性，可以确保解的唯一性和稳定性。每个用例的输出是按要求精确到小数点后六位的最优权重向量 $w^\\star$。", "answer": "```python\nimport numpy as np\n\ndef solve_equality_qp(Sigma, Aeq, beq):\n    \"\"\"\n    Solve min (1/2) w^T Sigma w subject to Aeq w = beq.\n    Returns w.\n    \"\"\"\n    n = Sigma.shape[0]\n    meq = Aeq.shape[0]\n    # Build KKT system\n    KKT = np.block([\n        [Sigma, Aeq.T],\n        [Aeq, np.zeros((meq, meq))]\n    ])\n    rhs = np.concatenate([np.zeros(n), beq])\n    # Solve KKT system\n    try:\n        sol = np.linalg.solve(KKT, rhs)\n    except np.linalg.LinAlgError:\n        # Fallback to least squares if singular\n        sol, *_ = np.linalg.lstsq(KKT, rhs, rcond=None)\n    w = sol[:n]\n    return w\n\ndef optimal_portfolio_with_beta_cap(mu, Sigma, m, mu_target, beta_max, tol=1e-9):\n    \"\"\"\n    Minimize w^T Sigma w subject to:\n    1^T w = 1, mu^T w = mu_target, and beta(w) = beta_max.\n    If the beta inequality is slack for the equality-only solution, return it.\n    Otherwise, enforce beta equality and solve.\n    \"\"\"\n    mu = np.asarray(mu, dtype=float)\n    Sigma = np.asarray(Sigma, dtype=float)\n    m = np.asarray(m, dtype=float)\n    n = len(mu)\n    ones = np.ones(n)\n\n    # Precompute market covariance vector and variance\n    c = Sigma @ m\n    kappa = float(m @ c)  # m^T Sigma m, positive scalar\n\n    # Equality-only solution\n    Aeq = np.vstack([ones, mu])\n    beq = np.array([1.0, float(mu_target)], dtype=float)\n    w_eq = solve_equality_qp(Sigma, Aeq, beq)\n\n    beta_eq = float((w_eq @ c) / kappa)\n    if beta_eq = beta_max + tol:\n        return w_eq\n\n    # Enforce binding beta equality: c^T w = beta_max * kappa\n    Aeq_bind = np.vstack([ones, mu, c])\n    beq_bind = np.array([1.0, float(mu_target), float(beta_max) * kappa], dtype=float)\n    w_bind = solve_equality_qp(Sigma, Aeq_bind, beq_bind)\n    return w_bind\n\ndef format_weights(weights, decimals=6):\n    # Round and format, avoiding negative zero representations\n    rounded = []\n    for x in weights:\n        xr = round(float(x), decimals)\n        if abs(xr)  10**(-decimals):\n            xr = 0.0\n        rounded.append(f\"{xr:.{decimals}f}\")\n    return \"[\" + \",\".join(rounded) + \"]\"\n\ndef solve():\n    # Define test cases\n    # Test cases 1-3 use the same 4-asset universe\n    mu1 = np.array([0.08, 0.12, 0.10, 0.07], dtype=float)\n    Sigma1 = np.array([\n        [0.04,     0.036,    0.0196,    0.006928],\n        [0.036,    0.09,     0.03675,   0.015588],\n        [0.0196,   0.03675,  0.060025,  0.0106085],\n        [0.006928, 0.015588, 0.0106085, 0.029985]\n    ], dtype=float)\n    m1 = np.array([0.4, 0.3, 0.2, 0.1], dtype=float)\n\n    # Test case 4: 3-asset universe\n    mu2 = np.array([0.06, 0.09, 0.15], dtype=float)\n    Sigma2 = np.array([\n        [0.02,        0.0063245553, 0.0063245553],\n        [0.0063245553, 0.05,        0.04],\n        [0.0063245553, 0.04,        0.2]\n    ], dtype=float)\n    m2 = np.array([0.2, 0.5, 0.3], dtype=float)\n\n    test_cases = [\n        # (mu, Sigma, m, mu_target, beta_max)\n        (mu1, Sigma1, m1, 0.095, 0.5),\n        (mu1, Sigma1, m1, 0.11,  0.3),\n        (mu1, Sigma1, m1, 0.09,  0.0),\n        (mu2, Sigma2, m2, 0.10,  0.5),\n    ]\n\n    results = []\n    for mu, Sigma, m, mu_target, beta_max in test_cases:\n        w_opt = optimal_portfolio_with_beta_cap(mu, Sigma, m, mu_target, beta_max)\n        results.append(format_weights(w_opt, decimals=6))\n\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2420305"}, {"introduction": "纸面上计算出的最优投资组合是一回事，但在现实世界中执行交易以达到该组合则会产生交易成本，从而侵蚀回报。这个高级练习将引导学生解决一个实际的再平衡问题，其中交易成本是交易规模的非线性函数。这要求我们不能仅仅依赖标准的二次规划求解器，而是需要从第一性原理出发，构建一个基于梯度的迭代优化算法，以找到在改善组合和付出成本之间达到最佳平衡的交易策略 [@problem_id:2420328]。", "problem": "给定一个包含 $N$ 个资产的单周期投资组合再平衡问题，已知初始权重向量 $\\mathbf{w}^{0} \\in \\mathbb{R}^{N}$、预期收益向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$ 以及一个对称正定协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$。风险厌恶参数 $\\gamma \\in \\mathbb{R}_{+}$ 在均值-方差优化 (MVO) 目标中权衡预期收益与风险，且投资组合权重必须满足预算约束 $\\sum_{i=1}^{N} w_{i} = 1$。允许卖空，因此除了预算约束外，对 $\\mathbf{w}$ 没有不等式边界。再平衡会产生非线性交易成本，其函数为 $C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5}$，其中系数 $k \\in \\mathbb{R}_{+}$，$\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^{0}$。所有答案必须表示为无单位的纯数字。\n\n您必须仅从预期收益、方差和给定交易成本函数的定义出发，并且不使用本问题陈述中提供的任何快捷公式，完成以下任务：\n\n- 将再平衡问题表述为在预算约束下最大化预期净效用，使用平衡预期收益和方差的基本MVO目标，并减去给定的交易成本。\n- 推导目标函数关于 $\\mathbf{w}$ 的梯度，并论证目标函数的凹性和可行集的凸性。\n- 设计一种计算方法，通过依赖梯度和投影算子的迭代方法来解决该约束优化问题，该投影算子在每一步强制执行预算约束 $\\sum_{i=1}^{N} w_{i} = 1$。确保非线性成本项的数值稳定性，并证明您的线搜索或步长策略的合理性。\n\n您的程序必须实现此方法，并为以下每个测试用例计算最优的交易后权重向量 $\\mathbf{w}^{\\star}$。在所有情况下，请使用所提供的确切数字。当给定数组或矩阵时，请严格按照规定使用。对于所有情况，预算约束为 $\\sum_{i=1}^{N} w_{i} = 1$ 且允许卖空。\n\n测试套件：\n\n- 案例 $1$ (具有非零交易成本的一般凹目标):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.01$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- 案例 $2$ (交易成本为零的边界情况):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 0.0$\n  - $\\mathbf{w}^{0} = [0.25, 0.25, 0.25, 0.25]$\n\n- 案例 $3$ (高交易成本抑制再平衡):\n  - $N = 4$\n  - $\\boldsymbol{\\mu} = [0.08, 0.12, 0.10, 0.07]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.04, 0.09, 0.0625, 0.0324])$\n  - $\\gamma = 5.0$\n  - $k = 10.0$\n  - $\\mathbf{w}^{0} = [0.10, 0.50, 0.20, 0.20]$\n\n- 案例 $4$ (不同维度和参数):\n  - $N = 3$\n  - $\\boldsymbol{\\mu} = [0.15, 0.05, 0.09]$\n  - $\\boldsymbol{\\Sigma} = \\mathrm{diag}([0.1225, 0.0225, 0.04])$\n  - $\\gamma = 8.0$\n  - $k = 0.02$\n  - $\\mathbf{w}^{0} = [0.20, 0.60, 0.20]$\n\n要求的最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。\n- 每个结果必须是一个内部浮点数列表，表示相应测试用例的最优权重 $\\mathbf{w}^{\\star}$，顺序与上面列出的案例相同。\n- 将每个权重四舍五入到 $6$ 位小数。\n- 例如，输出的形状必须类似于 $[[w_{1,1}, w_{1,2}, \\dots],[w_{2,1}, \\dots],\\dots]$，并且程序必须精确地打印一行此列表。\n\n您的程序必须是完全自包含的，不需要用户输入，并且只能使用标准库和指定的允许库。答案是浮点数列表。本问题不涉及百分比、物理单位或角度单位。必须严格按照所述实现数学模型，并且优化过程必须对每个案例强制执行 $\\sum_{i=1}^{N} w_{i} = 1$。", "solution": "问题陈述经过严格验证，被认为是有效的。它在科学上基于现代投资组合理论和凸优化的原理，问题设定良好，保证有唯一解，并且所有必要参数均已客观提供。该问题要求对一个单周期投资组合再平衡问题进行建模和求解，这是一个在计算金融学中可形式化的问题。所有数据都是自包含且一致的。\n\n问题在于找到最优的投资组合权重向量 $\\mathbf{w}^{\\star} \\in \\mathbb{R}^{N}$，以最大化投资者的净效用，同时考虑预期收益、风险和交易成本。\n\n首先，我们构建优化问题。我们旨在最大化的投资者效用函数包含三个部分：投资组合预期收益、对投资组合风险（方差）的惩罚以及因再平衡而产生的交易成本。\n\n1.  **投资组合预期收益**：给定 $N$ 个资产的预期收益向量 $\\boldsymbol{\\mu} \\in \\mathbb{R}^{N}$ 和投资组合权重向量 $\\mathbf{w} \\in \\mathbb{R}^{N}$，预期收益是权重的线性函数：\n    $$ E[R_p] = \\mathbf{w}^T \\boldsymbol{\\mu} = \\sum_{i=1}^{N} w_i \\mu_i $$\n\n2.  **投资组合风险 (方差)**：给定资产收益的协方差矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{N \\times N}$，投资组合方差是权重的二次函数：\n    $$ \\text{Var}(R_p) = \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} $$\n    均值-方差优化 (MVO) 目标对该方差进行惩罚，并由风险厌恶参数 $\\gamma  0$ 进行缩放。为便于数学处理，我们采用标准形式，使用因子 $\\frac{1}{2}$，从而得到风险惩罚项 $\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$。\n\n3.  **交易成本**：从初始投资组合 $\\mathbf{w}^0$ 再平衡到新的投资组合 $\\mathbf{w}$ 会产生费用。权重的变化是 $\\Delta \\mathbf{w} = \\mathbf{w} - \\mathbf{w}^0$。指定的成本函数是非线性的：\n    $$ C(\\Delta \\mathbf{w}) = k \\sum_{i=1}^{N} |\\Delta w_{i}|^{1.5} = k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\n    其中 $k  0$ 是一个交易成本系数。\n\n需要最大化的总目标函数 $f(\\mathbf{w})$ 是预期收益减去风险惩罚和交易成本：\n$$ f(\\mathbf{w}) = \\mathbf{w}^T \\boldsymbol{\\mu} - \\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w} - k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5} $$\n该最大化问题受制于预算约束，即权重之和必须为1：\n$$ \\sum_{i=1}^{N} w_i = 1 \\quad \\text{或，用向量表示,} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\n因此，完整的优化问题是：\n$$ \\underset{\\mathbf{w} \\in \\mathbb{R}^N}{\\text{maximize}} \\quad f(\\mathbf{w}) \\quad \\text{subject to} \\quad \\mathbf{1}^T \\mathbf{w} = 1 $$\n\n接下来，我们分析该问题的性质。由约束 $\\mathbf{1}^T \\mathbf{w} = 1$ 定义的可行集是 $\\mathbb{R}^N$ 中的一个仿射超平面，它是一个闭合的凸集。\n对于目标函数 $f(\\mathbf{w})$，我们通过检查其组成部分来分析其凹性。\n-   项 $\\mathbf{w}^T \\boldsymbol{\\mu}$ 是 $\\mathbf{w}$ 的线性函数，因此它既是凹函数也是凸函数。\n-   项 $-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}$ 是一个二次型。由于 $\\boldsymbol{\\Sigma}$ 是给定的正定矩阵且 $\\gamma  0$，矩阵 $-\\frac{\\gamma}{2}\\boldsymbol{\\Sigma}$ 是负定的。这意味着该项是关于 $\\mathbf{w}$ 的严格凹函数。\n-   交易成本项是 $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$。函数 $\\phi(x) = |x|^{1.5}$ 对于 $x \\in \\mathbb{R}$ 是一个凸函数。其二阶导数 $\\phi''(x) = 0.75 |x|^{-0.5}$ 在有定义的区域是非负的。凸函数的和仍然是凸函数，因此 $\\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ 是凸函数。乘以 $-k$ (其中 $k \\ge 0$) 使得该项 $-k \\sum_{i=1}^{N} |w_i - w_i^0|^{1.5}$ 成为一个凹函数。\n\n目标函数 $f(\\mathbf{w})$ 是一个线性函数（凹）、一个严格凹函数和一个凹函数的和。一个严格凹函数与其他凹函数之和是严格凹的。因此，$f(\\mathbf{w})$ 是一个严格凹函数。在闭合、非空、凸集上最大化一个严格凹函数，其解是唯一的。\n\n为了通过计算解决此问题，我们根据要求设计一种基于投影梯度上升的迭代算法。该方法迭代地沿着目标函数梯度的方向移动一步，然后将结果点投影回可行集上。\n\n需要计算目标函数的梯度 $\\nabla f(\\mathbf{w})$。我们逐项计算：\n-   $\\nabla (\\mathbf{w}^T \\boldsymbol{\\mu}) = \\boldsymbol{\\mu}$\n-   $\\nabla (-\\frac{\\gamma}{2} \\mathbf{w}^T \\boldsymbol{\\Sigma} \\mathbf{w}) = -\\gamma \\boldsymbol{\\Sigma} \\mathbf{w}$ (利用 $\\boldsymbol{\\Sigma}$ 的对称性)\n-   对于成本项，我们求其关于 $w_i$ 的偏导数：\n    $$ \\frac{\\partial}{\\partial w_i} \\left( -k \\sum_{j=1}^{N} |w_j - w_j^0|^{1.5} \\right) = -k \\frac{d}{d w_i} |w_i - w_i^0|^{1.5} $$\n    令 $u = w_i - w_i^0$。$|u|^{1.5}$ 关于 $u$ 的导数是 $1.5 \\cdot \\text{sgn}(u) \\cdot |u|^{0.5}$，它对所有 $u \\in \\mathbb{R}$ 都是有良好定义且连续的。\n    因此，成本项的梯度是一个向量，其分量为 $-1.5k \\cdot \\text{sgn}(w_i - w_i^0) \\cdot |w_i - w_i^0|^{0.5}$。\n\n结合这些，完整的梯度是：\n$$ \\nabla f(\\mathbf{w}) = \\boldsymbol{\\mu} - \\gamma \\boldsymbol{\\Sigma} \\mathbf{w} - 1.5 k \\cdot \\mathbf{v}(\\mathbf{w}) $$\n其中 $\\mathbf{v}(\\mathbf{w})$ 是一个向量，其第 $i$ 个分量为 $v_i = \\text{sgn}(w_i - w_i^0) \\sqrt{|w_i - w_i^0|}$。在数值计算中，我们通过注意到当 $w_i - w_i^0 = 0$ 时导数为 $0$ 来处理这种情况。\n\n投影梯度上升算法的步骤如下：\n1.  初始化权重 $\\mathbf{w}^{(0)}$，确保它们满足预算约束 (例如，$\\mathbf{w}^{(0)} = \\mathbf{w}^0$)。令 $t=0$。\n2.  重复直至收敛：\n    a.  计算梯度：$\\mathbf{g}^{(t)} = \\nabla f(\\mathbf{w}^{(t)})$。\n    b.  执行更新步骤：$\\mathbf{w}_{\\text{temp}}^{(t+1)} = \\mathbf{w}^{(t)} + \\alpha_t \\mathbf{g}^{(t)}$，其中 $\\alpha_t  0$ 是步长。\n    c.  投影回可行集：$\\mathbf{w}^{(t+1)} = P(\\mathbf{w}_{\\text{temp}}^{(t+1)})$。一个点 $\\mathbf{y}$ 到超平面 $\\mathbf{1}^T\\mathbf{w}=1$ 上的投影 $P(\\mathbf{y})$ 由下式给出：\n        $$ P(\\mathbf{y}) = \\mathbf{y} + \\left( \\frac{1 - \\mathbf{1}^T \\mathbf{y}}{N} \\right) \\mathbf{1} $$\n        该公式通过最小化欧几里得距离 $||\\mathbf{w} - \\mathbf{y}||_2$ 且满足 $\\mathbf{1}^T\\mathbf{w}=1$ 推导得出。\n    d.  $t$ 自增。\n\n步长 $\\alpha_t$ 对收敛至关重要。固定的小步长虽然可行但效率低下。我们将使用回溯线搜索在每次迭代中确定一个合适的 $\\alpha_t$。这种方法确保目标函数有足够的增量，并提供稳健的收敛性。从 $\\alpha$ 的一个初始猜测值开始，我们迭代地减小它（例如，乘以一个因子 $\\beta \\in (0,1)$），直到满足 Armijo-Goldstein 条件：\n$$ f(\\mathbf{w}^{(t+1)}) \\ge f(\\mathbf{w}^{(t)}) + c \\cdot (\\mathbf{g}^{(t)})^T (\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}) $$\n对于一个常数 $c \\in (0,1)$。\n\n当迭代之间的权重向量变化可以忽略不计时，算法终止，即 $||\\mathbf{w}^{(t+1)} - \\mathbf{w}^{(t)}||_2  \\epsilon$，其中 $\\epsilon$ 是一个很小的容差。\n\n为了数值稳定性，项 $\\sqrt{|w_i - w_i^0|}$ 被实现为 `np.sqrt(np.abs(w_i - w_i^0))`，以防止浮点运算可能导致对负数取平方根的任何问题。NumPy 中的 `np.sign` 函数能正确处理参数为零的情况。\n\n以下 Python 代码实现了带有回溯线搜索的投影梯度上升算法，用于为每个给定的测试用例求解最优权重向量 $\\mathbf{w}^{\\star}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a series of portfolio rebalancing problems using\n    the Projected Gradient Ascent method with backtracking line search.\n    \"\"\"\n\n    def compute_objective(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the value of the objective function.\"\"\"\n        expected_return = w.T @ mu\n        risk_penalty = 0.5 * gamma * w.T @ Sigma @ w\n        delta_w = w - w0\n        transaction_cost = k * np.sum(np.abs(delta_w)**1.5)\n        return expected_return - risk_penalty - transaction_cost\n\n    def compute_gradient(w, mu, Sigma, gamma, k, w0):\n        \"\"\"Computes the gradient of the objective function.\"\"\"\n        delta_w = w - w0\n        # The derivative of |x|^1.5 is 1.5 * sgn(x) * |x|^0.5.\n        # np.sign(0) is 0, which is correct for the derivative at x=0.\n        grad_cost_term = 1.5 * k * np.sign(delta_w) * np.sqrt(np.abs(delta_w))\n        grad = mu - gamma * Sigma @ w - grad_cost_term\n        return grad\n\n    def project(y):\n        \"\"\"Projects a vector y onto the budget constraint hyperplane sum(w)=1.\"\"\"\n        N = len(y)\n        return y + (1 - np.sum(y)) / N * np.ones(N)\n\n    def optimize_portfolio(mu, Sigma, gamma, k, w0):\n        \"\"\"\n        Performs Projected Gradient Ascent to find the optimal portfolio.\n        \"\"\"\n        N = len(mu)\n        w = w0.copy()\n\n        # Hyperparameters for the optimization algorithm\n        max_iter = 50000\n        tolerance = 1e-12\n        alpha_init = 1.0  # Initial step size for backtracking\n        beta = 0.5      # Backtracking line search factor\n        c = 1e-4        # Armijo condition constant\n\n        for i in range(max_iter):\n            f_w = compute_objective(w, mu, Sigma, gamma, k, w0)\n            grad = compute_gradient(w, mu, Sigma, gamma, k, w0)\n            \n            alpha = alpha_init\n            while True:\n                w_temp = w + alpha * grad\n                w_new = project(w_temp)\n                \n                f_w_new = compute_objective(w_new, mu, Sigma, gamma, k, w0)\n                \n                # Armijo condition for sufficient increase\n                # Note: For maximization, we check f_new >= f_old + ...\n                if f_w_new >= f_w + c * np.dot(grad, w_new - w):\n                    break\n                \n                alpha *= beta\n                if alpha  1e-15: # Prevent infinitely small step size\n                    break\n\n            # Convergence check\n            if np.linalg.norm(w_new - w)  tolerance:\n                w = w_new\n                break\n            \n            w = w_new\n        \n        return w\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.01,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 0.0,\n            \"w0\": np.array([0.25, 0.25, 0.25, 0.25])\n        },\n        {\n            \"N\": 4,\n            \"mu\": np.array([0.08, 0.12, 0.10, 0.07]),\n            \"Sigma\": np.diag([0.04, 0.09, 0.0625, 0.0324]),\n            \"gamma\": 5.0,\n            \"k\": 10.0,\n            \"w0\": np.array([0.10, 0.50, 0.20, 0.20])\n        },\n        {\n            \"N\": 3,\n            \"mu\": np.array([0.15, 0.05, 0.09]),\n            \"Sigma\": np.diag([0.1225, 0.0225, 0.04]),\n            \"gamma\": 8.0,\n            \"k\": 0.02,\n            \"w0\": np.array([0.20, 0.60, 0.20])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        w_star = optimize_portfolio(\n            case[\"mu\"], case[\"Sigma\"], case[\"gamma\"], case[\"k\"], case[\"w0\"]\n        )\n        # Round each weight to 6 decimal places and convert to list\n        rounded_weights = np.round(w_star, 6).tolist()\n        results.append(rounded_weights)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) and join is tricky for lists of lists.\n    # We build the string representation manually.\n    result_str = \",\".join([str(res).replace(\" \", \"\") for res in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "2420328"}]}