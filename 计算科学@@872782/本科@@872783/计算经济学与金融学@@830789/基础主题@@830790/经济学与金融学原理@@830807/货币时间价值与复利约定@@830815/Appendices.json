{"hands_on_practices": [{"introduction": "虽然许多入门级问题都假设利率恒定，但现实世界的金融环境通常呈现出利率的*期限结构*，其中适用于不同时期的利率 $r_k$ 是变化的。本练习 [@problem_id:2444469] 旨在训练在这一更真实假设下对现金流进行折现的基本技能。通过该练习，你将巩固每一个现金流都必须根据其对应时间范围内的特定利率路径进行折现的核心理念。", "problem": "一个项目在 $n$ 年内每年年底支付 $A$ 美元的等额现金流，其中 $A = 12{,}000$，$n = 6$。经济具有确定的期限结构，由适用于从第 $k-1$ 年到第 $k$ 年期间的单年有效利率 $r_k$ 描述，其中 $k \\in \\{1,2,3,4,5,6\\}$。假设采用与这些特定时期有效利率一致的离散复利，并且现金流在每个期末收到。利率如下：\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n\n计算该年金在时间 $0$ 的现值。将您的答案四舍五入到四位有效数字。以美元表示最终结果。", "solution": "首先对问题陈述进行验证。\n\n按陈述提取已知条件：\n- 等额年度现金流，$A = 12000$ 美元。\n- 支付次数，$n = 6$ 年。\n- 现金流时间：$n$ 年内每年年底。\n- 利率的期限结构由适用于从第 $k-1$ 年到第 $k$ 年期间的单年有效利率 $r_k$ 给出。\n- $r_1 = 0.030$\n- $r_2 = 0.033$\n- $r_3 = 0.036$\n- $r_4 = 0.038$\n- $r_5 = 0.041$\n- $r_6 = 0.043$\n- 复利是离散的。\n- 目标是计算在时间 $t=0$ 的现值 $PV$。\n- 最终答案必须四舍五入到四位有效数字并以美元表示。\n\n问题被确定为有效。它在科学上基于金融数学的原理，特别是货币的时间价值。这是一个适定问题，为唯一解提供了所有必要数据，其术语客观且明确。没有矛盾、缺失数据或违反科学原理的情况。我们继续进行求解。\n\n一系列现金流的现值 ($PV$) 是每笔单独现金流的贴现值之和。在未来某个时间收到的现金流，使用中间时期的现行利率贴现至其在时间 $t=0$ 的价值。\n\n在此问题中，在每年年底 $k$ 收到一笔恒定的现金流 $A$，其中 $k \\in \\{1, 2, 3, 4, 5, 6\\}$。贴现率不是恒定的；它遵循一个特定的期限结构。单年有效利率 $r_j$ 适用于从第 $j-1$ 年到第 $j$ 年的区间。\n\n为了求出在第 $k$ 年年底收到的一笔现金流 $A$ 的现值，我们必须使用相应年份的单年利率将其逐年贴现回来。第 $k$ 年现金流的贴现因子是各个单年贴现因子的乘积。\n\n第 $k=1$ 年现金流的现值为：\n$$ PV_1 = \\frac{A}{1+r_1} $$\n第 $k=2$ 年现金流的现值为：\n$$ PV_2 = \\frac{A}{(1+r_1)(1+r_2)} $$\n推广开来，第 $k$ 年现金流的现值由下式给出：\n$$ PV_k = \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n该年金的总现值是 $n$ 笔现金流各自现值的总和：\n$$ PV = \\sum_{k=1}^{n} PV_k = \\sum_{k=1}^{n} \\frac{A}{\\prod_{j=1}^{k} (1+r_j)} $$\n给定 $A=12000$ 和 $n=6$，我们可以写出完整的表达式：\n$$ PV = A \\left( \\frac{1}{1+r_1} + \\frac{1}{(1+r_1)(1+r_2)} + \\dots + \\frac{1}{\\prod_{j=1}^{6} (1+r_j)} \\right) $$\n让我们定义累积贴现项 $D_k = \\prod_{j=1}^{k} (1+r_j)$。公式变为：\n$$ PV = A \\sum_{k=1}^{6} \\frac{1}{D_k} $$\n我们现在代入给定的利率来计算每个 $D_k$：\n- $r_1=0.030 \\implies D_1 = 1+0.030 = 1.030$\n- $r_2=0.033 \\implies D_2 = D_1 \\times (1+0.033) = 1.030 \\times 1.033 = 1.06399$\n- $r_3=0.036 \\implies D_3 = D_2 \\times (1+0.036) = 1.06399 \\times 1.036 = 1.10230564$\n- $r_4=0.038 \\implies D_4 = D_3 \\times (1+0.038) = 1.10230564 \\times 1.038 = 1.14419325432$\n- $r_5=0.041 \\implies D_5 = D_4 \\times (1+0.041) = 1.14419325432 \\times 1.041 = 1.19110517774712$\n- $r_6=0.043 \\implies D_6 = D_5 \\times (1+0.043) = 1.19110517774712 \\times 1.043 = 1.2423227003902556$\n\n现在我们计算贴现因子之和, $\\sum_{k=1}^{6} \\frac{1}{D_k}$：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} = \\frac{1}{1.030} + \\frac{1}{1.06399} + \\frac{1}{1.10230564} + \\frac{1}{1.14419325432} + \\frac{1}{1.19110517774712} + \\frac{1}{1.2423227003902556} $$\n$$ \\approx 0.97087379 + 0.93985846 + 0.90718532 + 0.87397753 + 0.83953959 + 0.80494899 $$\n将这些值相加得到：\n$$ \\sum_{k=1}^{6} \\frac{1}{D_k} \\approx 5.33638366 $$\n现在，我们计算总现值：\n$$ PV = 12000 \\times 5.33638366 \\approx 64036.60396 $$\n题目要求将答案四舍五入到四位有效数字。$64036.60396$ 的前四位有效数字是 $6$、$4$、$0$ 和 $3$。第五位数字是 $6$，大于或等于 $5$，所以我们将第四位有效数字向上取整。值 $3$ 变为 $4$。\n$$ PV \\approx 64040 $$\n用标准科学记数法表示，即为 $6.404 \\times 10^4$。结果以美元为单位。", "answer": "$$ \\boxed{6.404 \\times 10^4} $$", "id": "2444469"}, {"introduction": "在掌握了折现概念后，我们将其应用于资本预算决策。内部收益率（IRR）是一种广受欢迎的投资评估指标，但它也存在潜在的缺陷，尤其是在处理非传统现金流（即现金流符号发生多次变化）时。本练习 [@problem_id:2444465] 呈现了一个现实场景，其中IRR的解读变得模棱两可。通过引入修正内部收益率（MIRR）作为更稳健的替代方案，本练习旨在教会你如何处理这些复杂情况并做出可靠的投资决策。", "problem": "一个露天开采项目在时间点 $t=0,1,2,3,4$ 具有以下期末现金流（以百万货币单位 MMU 计）：$C_0=-1{,}000$，$C_1=+1{,}200$，$C_2=+1{,}200$，$C_3=+1{,}200$，以及一笔巨大的环境修复支出 $C_4=-2{,}700$。该公司的资本成本（在计算修正内部收益率时，既用作负现金流的融资利率，也用作正现金流的再投资利率）为 $10\\%$。\n\n关于该项目的内部收益率 (IRR) 和修正内部收益率 (MIRR)，以下哪个陈述是正确的？\n\nA. 该项目有一个唯一的内部收益率，约等于 $11.3\\%$，这也是其修正内部收益率；由于这大致等于 $10\\%$ 的资本成本，该项目是临界的。\n\nB. 该项目存在两个内部收益率，分别约为 $3.2\\%$ 和 $77.6\\%$。在 $10\\%$ 的融资和再投资利率下的修正内部收益率约为 $11.3\\%$，并且在 $10\\%$ 贴现率下的净现值 (NPV) 为正；尽管存在多个内部收益率，修正内部收益率在此处提供了一个唯一的、与决策一致的总结。\n\nC. 该项目没有内部收益率，因为在所有贴现率下净现值都为负；修正内部收益率也为负。\n\nD. 该项目有两个内部收益率，分别约为 $-3\\%$ 和 $30\\%$；根据其构造，修正内部收益率总是等于资本成本 $10\\%$，因此多重内部收益率问题是无关紧要的。", "solution": "将贴现率为 $r$ 时的净现值 (NPV) 定义为\n$$\n\\text{NPV}(r)\\;=\\;-1{,}000\\;+\\;\\frac{1{,}200}{(1+r)^1}\\;+\\;\\frac{1{,}200}{(1+r)^2}\\;+\\;\\frac{1{,}200}{(1+r)^3}\\;-\\;\\frac{2{,}700}{(1+r)^4}.\n$$\n根据定义，内部收益率 (IRR) 是任何满足 $\\text{NPV}(r)=0$ 的 $r$。因为现金流的符号模式是 $(-,+,+,+,-)$，存在两次符号变化，所以根据笛卡尔符号法则，可能存在 $0$ 个或 $2$ 个正的内部收益率。融资利率为 $f$、再投资利率为 $g$ 时的修正内部收益率 (MIRR) 的定义是，将以 $g$ 复利计算的正现金流的未来值（在期末）与以 $f$ 贴现的负现金流的现值（在 $t=0$ 时）经过 $n$ 期增长后相等：\n$$\n\\text{MIRR}\\;=\\;\\left(\\frac{\\text{FV of positive cash flows at }g}{\\text{PV of negative cash flows at }f}\\right)^{1/n}-1,\n$$\n这里 $n=4$。\n\n步骤 1：确定在基准利率下 $\\text{NPV}(r)$ 的符号并框定内部收益率的根。\n\n- 当 $r=0$ 时，$\\text{NPV}(0)= -1{,}000+1{,}200+1{,}200+1{,}200-2{,}700=-100$。\n\n- 当 $r=0.10$ 时，计算各项的现值：\n$\\frac{1{,}200}{1.1}=1{,}090.909$，$\\frac{1{,}200}{1.1^2}=\\frac{1{,}200}{1.21}=991.736$，$\\frac{1{,}200}{1.1^3}=\\frac{1{,}200}{1.331}\\approx 901.580$，以及 $\\frac{2{,}700}{1.1^4}=\\frac{2{,}700}{1.4641}\\approx 1{,}843.277$。\n因此，\n$$\n\\text{NPV}(0.10)\\approx -1{,}000+(1{,}090.909+991.736+901.580)-1{,}843.277\\approx 140.95>0.\n$$\n因为 $\\text{NPV}(0)  0$ 且 $\\text{NPV}(0.10)0$，所以在 $(0,0.10)$ 区间内至少存在一个内部收益率。\n\n- 当 $r=0.78$ 时，此时 $1+r=1.78$，我们有 $(1+r)^2=3.1684$，$(1+r)^3\\approx 5.6398$，$(1+r)^4\\approx 10.0359$。那么\n$\\frac{1{,}200}{1.78}\\approx 674.157$，$\\frac{1{,}200}{3.1684}\\approx 378.904$，$\\frac{1{,}200}{5.6398}\\approx 212.796$，$\\frac{2{,}700}{10.0359}\\approx 268.93$。\n因此\n$$\n\\text{NPV}(0.78)\\approx -1{,}000+(674.157+378.904+212.796)-268.93\\approx -3.070.\n$$\n\n- 当 $r=0.77$ 时，此时 $1+r=1.77$，$(1+r)^2=3.1329$，$(1+r)^3\\approx 5.545$，$(1+r)^4\\approx 9.815$。那么\n$\\frac{1{,}200}{1.77}\\approx 677.966$，$\\frac{1{,}200}{3.1329}\\approx 382.900$，$\\frac{1{,}200}{5.545}\\approx 216.460$，$\\frac{2{,}700}{9.815}\\approx 274.97$。\n因此\n$$\n\\text{NPV}(0.77)\\approx -1{,}000+(677.966+382.900+216.460)-274.97\\approx 2.360.\n$$\n因为 $\\text{NPV}(0.77)0$ 且 $\\text{NPV}(0.78)  0$，第二个内部收益率位于 $(0.77,0.78)$ 区间内。\n\n为了精确计算较低的IRR，在 $r=0.031$ 和 $r=0.032$ 附近进行评估：\n\n- 当 $r=0.031$ 时，$(1+r)=1.031$，$(1+r)^2\\approx 1.063$，$(1+r)^3\\approx 1.095$，$(1+r)^4\\approx 1.128$。那么\n$\\frac{1{,}200}{1.031}\\approx 1{,}164.89$，$\\frac{1{,}200}{1.063}\\approx 1{,}128.53$，$\\frac{1{,}200}{1.095}\\approx 1{,}095.89$，$\\frac{2{,}700}{1.128}\\approx 2{,}392.0$。\n因此\n$$\n\\text{NPV}(0.031)\\approx -1{,}000}+(1{,}164.89+1{,}128.53+1{,}095.89)-2{,}392.0\\approx -2.690.\n$$\n\n- 当 $r=0.032$ 时，$(1+r)=1.032$，$(1+r)^2\\approx 1.0650$，$(1+r)^3\\approx 1.0981$，$(1+r)^4\\approx 1.1343$。那么\n$\\frac{1{,}200}{1.032}\\approx 1{,}162.79$，$\\frac{1{,}200}{1.0650}\\approx 1{,}126.76$，$\\frac{1{,}200}{1.0981}\\approx 1{,}092.86$，$\\frac{2{,}700}{1.1343}\\approx 2{,}380.5$。\n因此\n$$\n\\text{NPV}(0.032)\\approx -1{,}000}+(1{,}162.79+1{,}126.76+1{,}092.86)-2{,}380.5\\approx 1.910.\n$$\n因此，较小的内部收益率约等于 $r\\approx 3.2\\%$。较大的内部收益率，根据上面的区间框定，约等于 $r\\approx 77.6\\%$（从区间 $(0.77,0.78)$ 数值精确得到）。\n\n步骤 2：在融资利率 $f=10\\%$、再投资利率 $g=10\\%$ 且 $n=4$ 的条件下计算 MIRR。\n\n- 在 $f=10\\%$ 时负现金流的现值：\n$$\n\\text{PV}_{-} = 1{,}000+\\frac{2{,}700}{(1.10)^4}=1{,}000+\\frac{2{,}700}{1.4641}\\approx 1{,}000+1{,}843.277=2{,}843.277.\n$$\n\n- 在 $t=4$ 时以 $g=10\\%$ 复利计算的正现金流的未来值：\n$$\n\\text{FV}_{+} = 1{,}200(1.10)^3+1{,}200(1.10)^2+1{,}200(1.10)=1{,}200(1.331+1.21+1.10)=1{,}200(3.641)=4{,}369.2.\n$$\n\n- MIRR：\n$$\n\\text{MIRR}=\\left(\\frac{\\text{FV}_{+}}{\\text{PV}_{-}}\\right)^{1/4}-1=\\left(\\frac{4{,}369.2}{2{,}843.277}\\right)^{1/4}-1\\approx (1.5362)^{0.25}-1\\approx 0.113\\;\\text{或}\\;11.3\\%.\n$$\n\n步骤 3：检查在 $10\\%$ 时的 NPV，以便使决策与 MIRR 保持一致：\n根据上述计算，\n$$\n\\text{NPV}(0.10)\\approx 140.950,\n$$\n所以在 $10\\%$ 的资本成本下，根据 NPV 标准，该项目是增值的。约 $11.3\\%$ 的 MIRR 超过了 $10\\%$ 的门槛利率，得出了相同的接受/拒绝决策。相比之下，存在两个 IRR（约 $3.2\\%$ 和约 $77.6\\%$）使得未修正的 IRR 标准变得模糊不清。\n\n逐项分析选项：\n\n- 选项 A：陈述了存在一个唯一的 IRR，约等于 $11.3\\%$ 且等于 MIRR。这是不正确的。现金流模式 $(-,+,+,+,-)$ 允许存在两个 IRR，而计算出的 MIRR $\\approx 11.3\\%$ 并不是一个 IRR。\n\n- 选项 B：报告了两个 IRR，接近 $3.2\\%$ 和 $77.6\\%$，一个 MIRR 接近 $11.3\\%$，并指出在 $10\\%$ 时的 NPV 为正，且 MIRR 提供了一个唯一的、与决策一致的总结。这与计算结果相符，是正确的。\n\n- 选项 C：声称没有 IRR 且 MIRR 为负。这与显示存在两个 IRR 的区间框定以及计算出的正的 MIRR 相矛盾。\n\n- 选项 D：给出了不合理的 IRR 值（$-3\\%$ 和 $30\\%$），并声称 MIRR 总是等于资本成本。MIRR 仅在特殊的现金流配置下才等于资本成本，而不是在一般情况下根据其构造就相等；在此例中 MIRR $\\approx 11.3\\%\\neq 10\\%$。这是不正确的。\n\n因此，正确的选项是 B。", "answer": "$$\\boxed{B}$$", "id": "2444465"}, {"introduction": "现在，我们将从概念理解转向计算实现。许多重要的金融指标，例如债券的到期收益率（YTM），并没有简单的封闭解。它们被隐式地定义为一个方程（价格 = 未来现金流的现值）的根。本练习 [@problem_id:2377925] 提供了通过实现数值求根算法（如二分法）来求解YTM的实践机会，这是将金融理论与实际应用相结合的核心计算金融技能。", "problem": "您将实现一个区间求根算法，用于计算带息债券和零息债券的到期收益率 (YTM)。YTM 是指名义年利率（按每年指定频率复利），该利率使得所有未来现金流的现值等于当前市场价格。此任务必须被构建为一个单未知数的标量求根问题，使用区间法求解一个连续函数，并从第一性原理出发进行论证。\n\n基本原理：\n- 货币时间价值：未来现金流的现值等于其金额乘以一个适当的折现因子，该折现因子由名义年收益率、复利频率和所经过的时间推导得出。\n- 连续性与单调性：对于一系列严格为正的现金流，当使用每年固定次数复利的名义年收益率进行折现时，其现值是关于该收益率的连续严格递减函数。\n- 介值定理 (IVT)：如果一个闭区间上的连续函数在两个端点处的取值符号相反，那么它在该区间内至少有一个根。\n\n按如下方式定义标量函数。设名义年收益率为未知数 $y$。设复利频率为每年 $m$ 次支付，其中 $m \\in \\mathbb{N}$，并假设 $m T \\in \\mathbb{N}$ 以使总期数为整数。对于一个票面价值为 $F$、年票息率（年化小数表示）为 $c$、到期时间为 $T$ 年、当前市场价格为 $P$ 的债券，定义 $f(y)$ 为所有未来票息支付和赎回金额的现值（使用名义年收益率 $y$ 和复利频率 $m$ 进行折现）与观测价格 $P$ 之间的差额。YTM 是任何满足 $f(y) = 0$ 且符合财务可行性条件 $1 + y/m  0$ 的 $y$。\n\n您的程序必须：\n- 实现一个求根的区间方法（例如，二分法或试位法），该方法仅使用函数求值和区间端点，并保证对存在符号变化的连续函数收敛，而不依赖于导数信息。您必须使用一个固定的初始区间 $[y_{\\min}, y_{\\max}] = [-0.99, 3.0]$，并对每个测试用例验证 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。如果初始区间未能跨越一个根，您必须在维持财务可行性条件 $1 + y/m  0$ 的前提下保守地扩大该区间，直到找到一个符号变化或达到一个合理的扩展限制。\n- 对于每只债券，通过将每笔现金流按名义年收益率 $y$ （每年复利 $m$ 次）所隐含的每期利率进行折现来计算现值，然后对所有现金流在其各自期数指数下的折现值求和。每期折现因子必须强制满足财务可行性条件 $1 + y/m  0$。\n- 使用一个停止准则，确保区间宽度小于或等于指定的容差 $\\varepsilon$，或者中点处的函数绝对值小于或等于指定的容差 $\\delta$。使用 $\\varepsilon = 10^{-12}$ 和 $\\delta = 10^{-12}$，并且每次求根最多进行 $10{,}000$ 次迭代。\n- 结果以年化小数形式表示（不带百分号）。不涉及角度。货币价值采用任意但一致的单位；无需货币符号。\n\n测试套件：\n对于每种情况，参数均以上述约定以 $(F, c, m, T, P)$ 的形式给出。假设 $m T \\in \\mathbb{N}$。\n\n- 情况 1（普通带息债券，折价发行）：$(F=\\$1000, c=0.05, m=2, T=5, P=\\$950)$。\n- 情况 2（零息债券，正收益率）：$(F=\\$1000, c=0.0, m=1, T=3, P=\\$850)$。\n- 情况 3（平价债券，一致性检验）：$(F=\\$1000, c=0.04, m=2, T=7, P=\\$1000)$。\n- 情况 4（零息债券，负收益率）：$(F=\\$1000, c=0.0, m=1, T=1, P=\\$1005)$。\n\n答案规格：\n- 对于每个测试用例，将 YTM 作为年化小数形式的浮点数输出，并精确到 $10$ 位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按情况 1 到 4 的顺序排列结果。例如，输出格式必须与 $[y_1,y_2,y_3,y_4]$ 完全一样，其中每个 $y_k$ 都四舍五入到 $10$ 位小数。", "solution": "问题陈述已经过严格验证。所有给定信息都已提取，并根据科学合理性、完整性和客观性标准进行了检查。该问题提法明确，植根于成熟的金融数学理论，不含任何模糊之处、矛盾或事实错误。为测试用例提供的参数在物理上和财务上都是合理的。因此，将提供一个解决方案。\n\n核心任务是确定一组债券的到期收益率 (YTM)，记为 $y$。YTM 是指名义年利率，它使债券未来现金流的现值等于其当前市场价格。这是一个关于收益率 $y$ 的标量函数的求根问题。\n\n首先，我们必须从第一性原理构建这个函数。设债券的票面价值为 $F$，年票息率为 $c$，到期时间为 $T$ 年，票息复利频率为每年 $m$ 次。问题规定总期数 $N = mT$ 是一个整数。\n\n债券的总现金流由两部分组成：定期的票息支付和最终的票面价值赎回。\n年票息总额为 $cF$。由于每年有 $m$ 次支付，每次票息支付金额为 $C = \\frac{cF}{m}$。这些支付发生在每个计息期末，总共有 $N = mT$ 个计息期。在最后一个计息期 $N$ 结束时，票面价值 $F$ 也被返还。因此，在第 $k$ 期末（$k \\in \\{1, 2, \\dots, N-1\\}$）的现金流为 $C_k = C$，而在最后一个计息期 $N$ 的现金流为 $C_N = C + F$。\n\n货币时间价值原理指出，未来的现金流必须经过折现才能得到其现值。设 $y$ 为名义年收益率。每期收益率为 $r = \\frac{y}{m}$。第 $k$ 期现金流的折现因子为 $(1+r)^{-k} = (1 + y/m)^{-k}$。一个关键的财务可行性条件是折现率必须有明确定义，这要求 $1 + y/m  0$。\n\n所有未来现金流的总现值 $\\text{PV}(y)$ 是每笔现金流折现值的总和：\n$$ \\text{PV}(y) = \\sum_{k=1}^{N} \\frac{C_k}{(1 + y/m)^k} $$\n代入带息债券 ($c0$) 的特定现金流：\n$$ \\text{PV}(y) = \\left( \\sum_{k=1}^{N} \\frac{C}{(1+y/m)^k} \\right) + \\frac{F}{(1+y/m)^N} $$\n其中 $C = \\frac{cF}{m}$ 且 $N=mT$。对于零息债券 ($c=0$)，票息支付为零，公式简化为单笔一次性总付的现值：\n$$ \\text{PV}(y) = \\frac{F}{(1+y/m)^N} $$\n问题将要求解的函数 $f(y)$ 定义为现金流现值与市场价格 $P$ 之间的差额：\n$$ f(y) = \\text{PV}(y) - P = 0 $$\n对于任何正现金流集合，函数 $\\text{PV}(y)$ 在其可行域 $y  -m$ 上是关于 $y$ 的连续严格递减函数。因此，$f(y)$ 也是一个连续严格递减函数。这种单调性保证了如果根存在，它就是唯一的。\n\n介值定理 (IVT) 保证了在某个区间内根的存在性。该定理指出，对于一个闭区间 $[a, b]$ 上的连续函数，如果 $f(a)$ 和 $f(b)$ 的符号相反，那么在 $(a, b)$ 内至少存在一个值 $y^*$ 使得 $f(y^*) = 0$。这是区间求根方法的理论基础。\n\n我们将实现二分法，这是一种稳健且简单的区间算法，不需要导数信息。其收敛性是有保证的，尽管收敛速率是线性的，但这对于所要求的精度是可以接受的。\n\n算法流程如下：\n1. 初始化搜索区间。问题指定了一个初始区间 $[a, b] = [y_{\\min}, y_{\\max}] = [-0.99, 3.0]$。我们必须验证该区间是否有效，即 $f(a) \\cdot f(b) \\le 0$。鉴于 $f(y)$ 是单调递减的，我们期望 $f(a)  0$ 且 $f(b)  0$。如果此条件不成立，则必须扩展区间。由于当 $y \\to -m^+$ 时 $f(y) \\to \\infty$，而当 $y \\to \\infty$ 时 $f(y) \\to -P  0$，因此保证存在满足介值定理条件的区间。扩展逻辑将在 $f(b)0$ 时增加 $b$，在 $f(a)  0$ 时减小 $a$（朝 $-m$ 方向）。对于给定的测试用例，初始区间 $[-0.99, 3.0]$ 是足够的，无需扩展。\n\n2. 迭代直至满足停止准则。在每次迭代中：\n   a. 计算当前区间的中点：$y_{\\text{mid}} = a + \\frac{b-a}{2}$。这种表达式优于 $(a+b)/2$，可以避免处理大数量级的数时可能发生的浮点溢出。\n   b. 计算中点处的函数值 $f(y_{\\text{mid}})$。\n   c. 检查停止准则。如果区间宽度足够小，即 $|b-a| \\le \\varepsilon = 10^{-12}$，或者中点处的函数值接近于零，即 $|f(y_{\\text{mid}})| \\le \\delta = 10^{-12}$，则过程终止。同时，设置了最大迭代次数（$10,000$ 次）以防止无限循环。\n   d. 更新区间。根据 $f(y_{\\text{mid}})$ 的符号，舍弃保证不包含根的那一半区间。如果 $f(y_{\\text{mid}})$ 与 $f(a)$ 同号，则新区间变为 $[y_{\\text{mid}}, b]$。否则，新区间变为 $[a, y_{\\text{mid}}]$。由于我们已确定预期 $f(a)0$，若 $f(y_{\\text{mid}})0$，则根位于 $[y_{\\text{mid}},b]$ 中，因此我们设置 $a = y_{\\text{mid}}$。若 $f(y_{\\text{mid}})0$，则根位于 $[a, y_{\\text{mid}}]$ 中，因此我们设置 $b = y_{\\text{mid}}$。\n\n3. 最终结果是最后计算出的区间的中点，它以一个有保证的误差界来近似根 $y^*$。\n\n该方法将应用于每个测试用例，以计算相应的 YTM。计算使用浮点运算执行，最终结果按要求四舍五入到 $10$ 位小数。\n\n```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# Global constants as per problem specification\nTOLERANCE_EPSILON = 1e-12\nTOLERANCE_DELTA = 1e-12\nMAX_ITERATIONS = 10000\nINITIAL_BRACKET = [-0.99, 3.0]\n\ndef calculate_f_y(y, F, c, m, T, P):\n    \"\"\"\n    Calculates the value of the price-yield function f(y) = PV(y) - P.\n    \n    Args:\n        y (float): The nominal annual yield (YTM).\n        F (float): Face value of the bond.\n        c (float): Annual coupon rate (decimal).\n        m (int): Compounding frequency per year.\n        T (int): Maturity in years.\n        P (float): Current market price.\n\n    Returns:\n        float: The value of f(y).\n    \"\"\"\n    # Financial feasibility condition: 1 + y/m > 0\n    if 1.0 + y / m = 0:\n        return float('inf')  # Return a large positive value for infeasible yields\n\n    num_periods = int(m * T)\n    coupon_per_period = c * F / m\n\n    present_value = 0.0\n    \n    # The term (1 + y/m) is used repeatedly\n    discount_base = 1.0 + y / m\n    \n    # Calculate present value of coupon payments using direct summation\n    if c > 0:\n        for k in range(1, num_periods + 1):\n            present_value += coupon_per_period / (discount_base ** k)\n\n    # Add present value of face value redemption\n    present_value += F / (discount_base ** num_periods)\n    \n    return present_value - P\n\ndef find_ytm(params):\n    \"\"\"\n    Computes the Yield-to-Maturity (YTM) for a bond using the bisection method.\n\n    Args:\n        params (tuple): A tuple containing bond parameters (F, c, m, T, P).\n\n    Returns:\n        float: The calculated YTM.\n    \"\"\"\n    F, c, m, T, P = params\n    \n    a, b = INITIAL_BRACKET[0], INITIAL_BRACKET[1]\n    \n    fa = calculate_f_y(a, F, c, m, T, P)\n    fb = calculate_f_y(b, F, c, m, T, P)\n    \n    # Bracket expansion logic as required by the problem statement.\n    # Note: For the given test cases, the initial bracket is sufficient.\n    # This logic is included for robustness as per the directive.\n    expansion_limit = 20\n    expand_iter = 0\n    while fa * fb > 0 and expand_iter  expansion_limit:\n        # f(y) is monotonically decreasing.\n        # If both are positive, root is to the right of b.\n        if fa > 0 and fb > 0:\n            b *= 2.0\n        # If both are negative, root is to the left of a.\n        elif fa  0 and fb  0:\n            # Conservatively move 'a' towards the theoretical limit -m\n            a = (a - m) / 2.0\n            if a = -m: # Ensure feasibility\n                a = -m + 1e-9\n        else: # One or both are zero, which is a root\n            return a if fa == 0 else b\n\n        fa = calculate_f_y(a, F, c, m, T, P)\n        fb = calculate_f_y(b, F, c, m, T, P)\n        expand_iter += 1\n\n    if fa * fb > 0:\n        raise ValueError(f\"Failed to find a bracketing interval for params: {params}\")\n\n    # Ensure fa is positive and fb is negative to simplify bisection logic\n    if fa  0:\n        a, b = b, a\n        fa, fb = fb, fa\n\n    # Bisection method implementation\n    for _ in range(MAX_ITERATIONS):\n        mid = a + (b - a) / 2.0\n        f_mid = calculate_f_y(mid, F, c, m, T, P)\n        \n        # Check stopping criteria\n        if (b - a) = TOLERANCE_EPSILON or abs(f_mid) = TOLERANCE_DELTA:\n            return mid\n        \n        # Update bracket\n        if f_mid > 0:  # Root is in the right half [mid, b]\n            a = mid\n            fa = f_mid\n        else:  # Root is in the left half [a, mid]\n            b = mid\n            fb = f_mid\n            \n    # If max iterations is reached, return the best estimate.\n    return a + (b - a) / 2.0\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Test suite: (F, c, m, T, P)\n    test_cases = [\n        (1000.0, 0.05, 2, 5.0, 950.0),    # Case 1: General coupon bond, discount\n        (1000.0, 0.0, 1, 3.0, 850.0),    # Case 2: Zero-coupon, positive yield\n        (1000.0, 0.04, 2, 7.0, 1000.0),   # Case 3: Par bond, consistency check\n        (1000.0, 0.0, 1, 1.0, 1005.0)     # Case 4: Zero-coupon, negative yield\n    ]\n\n    results = []\n    for case in test_cases:\n        ytm = find_ytm(case)\n        # Format to 10 decimal places as required\n        results.append(f\"{ytm:.10f}\")\n\n    # Final print statement in the exact required format.\n    # print(f\"[{','.join(results)}]\") # This is for local execution\n    # The function will be called and its result will be placed in the answer tag.\n\n# This is an illustration of how to get the answer, not for execution here.\n# solve()\n# Output: [0.0617637894,0.0556703593,0.0400000000,-0.0049751244]\n```", "answer": "$$ \\boxed{[0.0617637894,0.0556703593,0.0400000000,-0.0049751244]} $$", "id": "2377925"}]}