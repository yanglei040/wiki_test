{"hands_on_practices": [{"introduction": "永续年金背后的数学结构——无穷递缩等比数列求和——是一个非常强大的工具，其应用远超传统金融领域。这个练习 [@problem_id:2371754] 将挑战你使用永续年金模型来估算一个太阳能发电场的总生命周期能量输出。通过将年度能量产出视为“支付流”，将物理衰减率视为“贴现率”，你将亲身体会到如何运用核心金融概念巧妙地解决工程与环境科学中的问题。", "problem": "一个公用事业规模的太阳能光伏设施的铭牌容量为$100$兆瓦。其容量因子为$0.25$，一个非闰年有$8760$小时。光伏组件每年经历$0.5\\%$的恒定比例衰减，并且这种衰减使得每年产生的能量相对于前一年发生乘法性减少。假设该设施在这些条件下无限期运行，没有容量增加、退役、维护冲击或外部限制。\n\n使用一个永续年金式模型，其中年度能量输出流在所述的衰减过程下永不停止，确定未来所有年份产生的总累积能量。以兆瓦时（MWh）为单位表示您的答案，并将结果四舍五入到四位有效数字。", "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤1：提取已知条件**\n- 铭牌容量：$100$兆瓦\n- 容量因子：$0.25$\n- 非闰年小时数：$8760$\n- 比例衰减率：每年$0.5\\%$\n- 衰减效应：每年产生的能量相对于前一年发生乘法性减少。\n- 运行时间框架：无限期。\n- 模型类型：永续年金式模型。\n- 要求输出：以兆瓦时（MWh）为单位的总累积能量，四舍五入到四位有效数字。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据。铭牌容量、容量因子和年衰减率是电力系统工程和可再生能源金融领域的标准指标。给定的数值是现实的；$0.25$的容量因子对于许多地区的太阳能光伏是典型的，而$0.5\\%$的年衰减率是现代晶硅组件的标准假设。问题是适定的，描述了一个公比的绝对值小于1的无穷几何级数，这保证了它会收敛到一个唯一的有限和。语言客观而精确。使用永续年金模型是一种理想化处理，但它被明确说明为一个建模假设，并且是近似长期累积效应的有效数学技术。因此，该问题被认定为有效。\n\n**步骤3：结论与行动**\n问题有效。现在将推导出一个完整的解答。\n\n该问题要求计算一个经历恒定比例衰减的太阳能设施在无限时间范围内产生的总能量。这等同于求一个无穷几何级数的和。\n\n首先，我们确定第一年运营产生的能量，记为$E_1$。能量输出是平均功率与运行时间的乘积。平均功率是铭牌容量乘以容量因子。\n\n设$C$为铭牌容量，$f$为容量因子，$T$为一年中的小时数。\n第一年产生的能量由下式给出：\n$$E_1 = C \\times f \\times T$$\n代入给定值：\n$$C = 100 \\text{ MW}$$\n$$f = 0.25$$\n$$T = 8760 \\text{ h}$$\n因此，\n$$E_1 = 100 \\text{ MW} \\times 0.25 \\times 8760 \\text{ h} = 25 \\text{ MW} \\times 8760 \\text{ h} = 219000 \\text{ MWh}$$\n\n问题陈述，能量输出每年经历$d = 0.5\\%$的恒定比例衰减。这意味着任何一年产生的能量是前一年产生能量的一个恒定分数。设这个恒定的乘法因子为$r$。\n$$d = 0.5\\% = 0.005$$\n因子$r$为：\n$$r = 1 - d = 1 - 0.005 = 0.995$$\n\n年度能量产出的流形成一个几何序列：\n- 第1年：$E_1 = 219000 \\text{ MWh}$\n- 第2年：$E_2 = E_1 \\times r$\n- 第3年：$E_3 = E_2 \\times r = E_1 \\times r^2$\n- 第$n$年：$E_n = E_1 \\times r^{n-1}$\n\n未来所有年份产生的总累积能量，$E_{\\text{total}}$，是这个无穷几何级数的和：\n$$E_{\\text{total}} = \\sum_{n=1}^{\\infty} E_n = \\sum_{n=1}^{\\infty} E_1 \\times r^{n-1}$$\n无穷几何级数的求和公式为：\n$$S = \\frac{a}{1-r}$$\n其中$a$是首项，$r$是公比。此公式仅在$|r|  1$时有效。在本问题中，首项是$a = E_1$，公比是$r = 0.995$。由于$|0.995|  1$，级数收敛，我们可以应用该公式。\n\n$$E_{\\text{total}} = \\frac{E_1}{1-r}$$\n代入$E_1$和$r$的值：\n$$E_{\\text{total}} = \\frac{219000}{1 - 0.995} = \\frac{219000}{0.005}$$\n这等价于：\n$$E_{\\text{total}} = 219000 \\times \\frac{1}{0.005} = 219000 \\times 200$$\n$$E_{\\text{total}} = 43800000 \\text{ MWh}$$\n\n问题要求答案四舍五入到四位有效数字。计算出的值为$43,800,000$。四个最高有效数字是$4$、$3$、$8$和$0$。为了用四位有效数字以标准科学记数法表示，我们写成：\n$$E_{\\text{total}} = 4.380 \\times 10^7$$\n这是该设施在指定的衰减模型下，在其无限运营寿命内产生的总累积能量。", "answer": "$$\\boxed{4.380 \\times 10^7}$$", "id": "2371754"}, {"introduction": "现在让我们回到金融领域，但增加一层现实世界的复杂性：不确定性与增长。这个练习 [@problem_id:2371756] 要求你为一种支付流不固定，但预期会随时间增长的永续资产进行估值。你将处理一个简单的随机过程（带漂移的随机游走），并运用风险中性定价原理，从已知的市场价格中反解出其内在的贴现率，这是从“计算价格”到“校准模型”的关键一步。", "problem": "一个永续年金提供了一系列随机的年度现金支付 $\\{C_{t}\\}_{t \\geq 1}$，其初始水平 $C_{0}$ 在时间 $t=0$ 时被观测到。现金流过程遵循带漂移的随机游走：\n$$\nC_{t+1} \\;=\\; C_{t} \\;+\\; \\mu \\;+\\; \\varepsilon_{t+1}, \\quad t \\geq 0,\n$$\n其中 $\\{\\varepsilon_{t}\\}$ 是独立同分布 (i.i.d.) 的冲击，满足 $\\mathbb{E}[\\varepsilon_{t}] = 0$ 和有限方差，而 $\\mu$ 是一个恒定的漂移。假设投资者是风险中性的，每期随机折现因子是确定性的，由 $(1+r)^{-1}$ 给出，其中 $r0$ 是一个恒定的折现率。资产在时间 $0$ 的价格 $P_{0}$ 等于未来现金流的期望折现总和：\n$$\nP_{0} \\;=\\; \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}.\n$$\n假设 $P_{0} = 120$，$C_{0} = 5$，且 $\\mu = 0.2$，所有量都以相同的货币单位表示，时间单位为年。在这些假设下，求出能使观测价格合理化的隐含折现率 $r$。最终答案请给出一个小数（不带百分号），并四舍五入到 $4$ 位有效数字。", "solution": "问题陈述需进行验证。\n\n步骤1：提取已知条件\n-   现金流过程：$C_{t+1} = C_{t} + \\mu + \\varepsilon_{t+1}$，对于 $t \\geq 0$。\n-   初始现金流水平：$C_{0}$。\n-   冲击：$\\{\\varepsilon_{t}\\}$ 是独立同分布的，且 $\\mathbb{E}[\\varepsilon_{t}] = 0$。\n-   漂移：$\\mu$ 是一个常数。\n-   折现率：$r  0$ 是一个常数。\n-   定价公式：$P_{0} = \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}$。\n-   数值：$P_{0} = 120$，$C_{0} = 5$，$\\mu = 0.2$。\n\n步骤2：使用提取的已知条件进行验证\n-   **科学依据**：该问题使用了现金流的标准随机游走模型和风险中性定价框架，这两者都是金融经济学中的基本概念。该模型在科学上是合理的。\n-   **适定性**：该问题提供了足够的信息来确定未知变量 $r$。定价公式涉及一个无穷级数，对于 $r  0$（问题中指定的条件），其收敛性是有保证的。该结构导出一个可解的代数方程。\n-   **客观性**：问题以精确、定量的术语陈述，没有任何主观或模糊的语言。\n\n步骤3：结论与行动\n该问题是有效的，因为它具有科学依据、适定性和客观性。将推导求解。\n\n资产在时间 $0$ 的价格 $P_{0}$ 是未来期望现金流以恒定利率 $r$ 折现的现值。该公式为：\n$$\nP_{0} = \\sum_{t=1}^{\\infty} \\frac{\\mathbb{E}[C_{t}]}{(1+r)^{t}}\n$$\n首先，我们必须确定在时间 $t$ 的现金流的期望值 $\\mathbb{E}[C_{t}]$。现金流过程由以下递推关系给出：\n$$\nC_{t+1} = C_{t} + \\mu + \\varepsilon_{t+1}\n$$\n基于时间 $t=0$ 的信息取期望，并使用迭代期望定律，我们求出期望值。对于 $t=1$：\n$$\n\\mathbb{E}[C_{1}] = \\mathbb{E}[C_{0} + \\mu + \\varepsilon_{1}]\n$$\n由于 $C_{0}$ 在 $t=0$ 时被观测到，它是一个已知常数。冲击 $\\varepsilon_{1}$ 的期望为零。因此：\n$$\n\\mathbb{E}[C_{1}] = C_{0} + \\mu\n$$\n对于 $t=2$：\n$$\n\\mathbb{E}[C_{2}] = \\mathbb{E}[C_{1} + \\mu + \\varepsilon_{2}] = \\mathbb{E}[C_{1}] + \\mu = (C_{0} + \\mu) + \\mu = C_{0} + 2\\mu\n$$\n通过归纳法，任何未来时间 $t \\geq 1$ 的期望现金流是一个等差数列：\n$$\n\\mathbb{E}[C_{t}] = C_{0} + t\\mu\n$$\n将此表达式代入 $P_{0}$ 的定价公式中：\n$$\nP_{0} = \\sum_{t=1}^{\\infty} \\frac{C_{0} + t\\mu}{(1+r)^{t}}\n$$\n我们可以将这个求和分成两部分：\n$$\nP_{0} = C_{0} \\sum_{t=1}^{\\infty} \\left(\\frac{1}{1+r}\\right)^{t} + \\mu \\sum_{t=1}^{\\infty} t \\left(\\frac{1}{1+r}\\right)^{t}\n$$\n第一个和是一个标准的几何级数，它代表了支付恒定金额 $1$ 的永续年金的现值。其值为：\n$$\n\\sum_{t=1}^{\\infty} \\left(\\frac{1}{1+r}\\right)^{t} = \\frac{1/(1+r)}{1 - 1/(1+r)} = \\frac{1}{r}\n$$\n第二个和是一个算术-几何级数。其值可以通过考虑几何级数的导数来找到。设 $x = (1+r)^{-1}$。该和为 $\\sum_{t=1}^{\\infty} t x^{t}$。已知这个和等于 $\\frac{x}{(1-x)^2}$。代入 $x = (1+r)^{-1}$：\n$$\n\\sum_{t=1}^{\\infty} t \\left(\\frac{1}{1+r}\\right)^{t} = \\frac{1/(1+r)}{\\left(1 - \\frac{1}{1+r}\\right)^{2}} = \\frac{1/(1+r)}{(r/(1+r))^{2}} = \\frac{1+r}{r^{2}}\n$$\n这是每期支付增加 $1$ 个单位的永续年金的现值，第一笔支付在 $t=1$ 时为 $1$。\n综合这些结果，我们得到 $P_{0}$ 的表达式：\n$$\nP_{0} = C_{0}\\left(\\frac{1}{r}\\right) + \\mu\\left(\\frac{1+r}{r^{2}}\\right) = \\frac{C_{0}}{r} + \\frac{\\mu}{r^{2}} + \\frac{\\mu}{r} = \\frac{C_{0}+\\mu}{r} + \\frac{\\mu}{r^{2}}\n$$\n这个公式代表了一个等差增长永续年金的现值，其中第一笔支付是 $\\mathbb{E}[C_1] = C_0+\\mu$，支付的增长额为 $\\mu$。\n现在，我们代入给定的数值：$P_{0}=120$，$C_{0}=5$ 和 $\\mu=0.2$。\n$$\n120 = \\frac{5 + 0.2}{r} + \\frac{0.2}{r^{2}}\n$$\n$$\n120 = \\frac{5.2}{r} + \\frac{0.2}{r^{2}}\n$$\n为了解出 $r$，我们将整个方程乘以 $r^{2}$（这是允许的，因为 $r0$ 意味着 $r \\neq 0$）：\n$$\n120r^{2} = 5.2r + 0.2\n$$\n整理各项得到一个关于 $r$ 的二次方程：\n$$\n120r^{2} - 5.2r - 0.2 = 0\n$$\n我们使用二次方程求根公式 $r = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$ 来解这个方程，其中 $a=120$，$b=-5.2$，$c=-0.2$。\n$$\nr = \\frac{-(-5.2) \\pm \\sqrt{(-5.2)^{2} - 4(120)(-0.2)}}{2(120)}\n$$\n$$\nr = \\frac{5.2 \\pm \\sqrt{27.04 + 96}}{240}\n$$\n$$\nr = \\frac{5.2 \\pm \\sqrt{123.04}}{240}\n$$\n$r$ 的两个潜在解是：\n$$\nr_{1} = \\frac{5.2 + \\sqrt{123.04}}{240} \\quad \\text{和} \\quad r_{2} = \\frac{5.2 - \\sqrt{123.04}}{240}\n$$\n由于 $\\sqrt{123.04} \\approx 11.09$，第二个根 $r_{2}$ 将是负数。问题陈述指明折现率 $r$ 必须为正，因此我们只考虑正根 $r_{1}$。\n$$\nr = \\frac{5.2 + \\sqrt{123.04}}{240} \\approx \\frac{5.2 + 11.09234}{240} \\approx \\frac{16.29234}{240} \\approx 0.06788475\n$$\n题目要求答案四舍五入到 $4$ 位有效数字。\n$$\nr \\approx 0.06788\n$$", "answer": "$$\n\\boxed{0.06788}\n$$", "id": "2371756"}, {"introduction": "现实世界中的金融产品其现金流往往取决于其他经济变量的路径，无法用简单的封闭式公式来定价。这个动手编程练习 [@problem_id:2371722] 将要求你为一个结构化产品的内部收益率（IRR）进行计算，其年度息票支付与否取决于通货膨胀率。这个问题将引导你脱离公式的束缚，从第一性原理出发构建现金流模型，并使用数值方法求解IRR，这是计算金融领域的一项核心技能。", "problem": "要求您实现一个完整的程序，用于计算一种结构化产品的内部收益率（IRR）。该产品基于一个国家通货膨胀率的实现路径支付有条件票息。该程序必须仅依赖于以下基本概念：通过以恒定利率进行现值贴现来体现的货币时间价值，以及将现金流现值等同于零的利率作为内部收益率的定义。不得假定使用任何其他快捷方式或预封装公式。\n\n单个产品实例由输入元组 $\\left(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T}\\right)$ 定义，其中 $P$ 是在时间 $t=0$ 投资的初始本金， $C$ 是固定的年度票息金额， $L$ 和 $U$ 是通货膨胀区间的下限和上限， $T$ 是以年为单位的到期期限， $g$ 是到期本金担保比例， $\\{i_t\\}$ 是以小数（而非百分比）表示的年度通货膨胀率的实现序列。该结构化产品按如下方式产生现金流：\n- 在时间 $t=0$ 时，投资者支付初始流出资金 $-P$。\n- 对于每一年 $t \\in \\{1,2,\\dots,T\\}$，当且仅当该年的通货膨胀率 $i_t$ 满足 $L \\le i_t \\le U$ 时，支付金额为 $C$ 的票息；否则，该年的票息为 $0$。\n- 在到期时间 $t=T$ 时，除了按上述方式确定的任何票息外，无论通货膨胀路径如何，投资者都会收到一笔等于 $gP$ 的担保到期回报。\n\n对于每个输入元组，将内部收益率（IRR），记为 $r$，定义为贴现率（以小数表示），该贴现率使得所有现金流以利率 $r$ 贴现至时间 $t=0$ 后的总和为零。您的程序必须为每个指定的测试用例计算出这个 $r$。所有利率（通货膨胀率、IRR）都必须以小数表示（例如，使用 $0.03$ 而不是 $3\\%$）。不涉及任何物理单位。\n\n测试套件：\n为以下五个案例中的每一个计算 IRR $r$。在每个案例中，使用包含边界的区间，即当通货膨胀率 $i_t$ 等于 $L$ 或 $U$ 时，该年有资格获得票息。所有标量输入均为实数，所有通货膨胀序列均为实值列表。\n\n- 案例 1（混合区间内和区间外年份）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.03, 0.01, 0.025, 0.04, 0.033]$。\n- 案例 2（边界值触发每年票息）：\n  - $P = 1000$, $C = 40$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.02, 0.035, 0.035, 0.02, 0.025]$。\n- 案例 3（从未支付票息，到期返还全部本金）：\n  - $P = 1000$, $C = 60$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 1.0$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 4（从未支付票息，到期返还部分本金）：\n  - $P = 1000$, $C = 50$, $L = 0.02$, $U = 0.035$, $T = 5$, $g = 0.9$, $\\{i_t\\}_{t=1}^{5} = [0.05, 0.05, 0.05, 0.05, 0.05]$。\n- 案例 5（一年期产品，支付票息，返还全部本金）：\n  - $P = 1000$, $C = 100$, $L = 0.02$, $U = 0.035$, $T = 1$, $g = 1.0$, $\\{i_t\\}_{t=1}^{1} = [0.025]$。\n\n程序要求：\n- 对每个案例，根据上述定义构建现金流序列，使用给定的通货膨胀路径和边界来确定哪些票息会被支付。\n- 按上述定义计算 IRR $r$。解决方案必须通过数值计算得出；不应假定在一般情况下可以进行精确的代数简化。\n- 数值输出规范：对每个案例，将 IRR 作为浮点数输出，四舍五入到 $8$ 位小数。将所有五个案例的结果汇总到一行，以逗号分隔的列表形式并用方括号括起来，例如 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_k$ 都四舍五入到 $8$ 位小数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[0.01234567,0.00000000,-0.01234567,0.03456789,0.10000000]$）。不允许有其他输出。", "solution": "所提出的问题是计算金融学中一个明确定义的练习。它要求计算一种结构化金融产品的内部收益率（IRR），该产品的现金流取决于一个外部经济变量——通货膨胀率。所有参数和条件都已足够清晰和精确地指定，从而能够得出一个唯一且可验证的解。该问题在科学上基于货币时间价值的基本原则。\n\n验证步骤如下：\n1.  **已知条件提取**：所有输入参数 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$、现金流规则、IRR 的定义以及测试数据都已明确陈述且自成体系。\n2.  **验证**：该问题在科学上是合理的，依赖于已建立的贴现现金流分析的金融概念。该问题是适定的，因为所描述的现金流（一次初始流出，随后是一系列非负流入）通常会产生一个唯一的实值 IRR。问题陈述客观且无歧义。它可以被形式化为一个精确的数学方程，并与计算金融学中的年金和永续年金主题直接相关。\n3.  **结论**：该问题有效。将构建一个解决方案。\n\n问题的核心是找到内部收益率，我们将其表示为 $r$。根据定义，$r$ 是使结构化产品所有现金流的净现值（NPV）等于零的特定贴现率。\n\n首先，我们必须根据所提供的参数构建现金流序列 $\\{CF_t\\}_{t=0}^{T}$。\n设 $P$ 为初始本金， $C$ 为年度票息， $L$ 和 $U$ 为通货膨胀区间的下限和上限， $T$ 为以年为单位的到期期限， $g$ 为到期本金担保比例， $\\{i_t\\}_{t=1}^{T}$ 为年度通货膨胀率的实现序列。\n\n现金流确定如下：\n- 在时间 $t=0$ 时，有一笔初始投资，即流出 $P$。因此，$CF_0 = -P$。\n- 对于随后的每一年 $t$，其中 $t \\in \\{1, 2, \\dots, T\\}$，我们必须确定是否支付票息。设 $c_t$ 为时间 $t$ 的票息支付。支付条件是该年的通货膨胀率 $i_t$ 落在指定的区间内，包含其边界。\n$$\nc_t =\n\\begin{cases}\nC  \\text{if } L \\le i_t \\le U \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n- 对于每一年 $t \\in \\{1, 2, \\dots, T-1\\}$，现金流就是该年的票息支付：$CF_t = c_t$。\n- 在到期年份 $t=T$，现金流包括该年的票息 $c_T$ 和担保的到期本金回报 $gP$。\n$$\nCF_T = c_T + gP\n$$\n\n在建立了完整的现金流序列 $\\{CF_t\\}_{t=0}^{T}$ 后，我们可以将净现值定义为贴现率 $r$ 的函数：\n$$\n\\text{NPV}(r) = \\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n根据定义，IRR 是解方程 $\\text{NPV}(r) = 0$ 的利率 $r$：\n$$\n\\sum_{t=0}^{T} \\frac{CF_t}{(1+r)^t} = 0\n$$\n代入 $CF_0 = -P$，我们可以将其重写为：\n$$\n-P + \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t} = 0 \\quad \\implies \\quad P = \\sum_{t=1}^{T} \\frac{CF_t}{(1+r)^t}\n$$\n这个方程是关于变量 $v = (1+r)^{-1}$ 的一个 $T$ 次多项式。对于 $T  4$ 的情况，不存在通用的代数解法来求解其根。因此，我们必须使用数值求根算法来解出 $r$。\n\n解决此问题的步骤如下：\n1.  对于由元组 $(P, C, L, U, T, g, \\{i_t\\}_{t=1}^{T})$ 定义的每个测试用例：\n    a. 根据上述规则构建现金流向量 $CF = [CF_0, CF_1, \\dots, CF_T]$。\n    b. 定义目标函数 $f(r) = \\text{NPV}(r)$，我们需要求解 $f(r)=0$。\n    c. 利用数值求解器找到 $f(r)$ 的根。`scipy.optimize.newton` 函数实现了割线法（牛顿法的一种变体），是完成此任务的合适且稳健的选择。提供一个初始猜测值，例如 $r_0 = 0.1$，以启动迭代过程。\n2.  然后将每个案例计算出的 $r$ 值按要求四舍五入到 $8$ 位小数。\n3.  最终结果汇总成一个格式化的字符串。\n\n此方法仅依赖于 IRR 的基本定义和一个通用的数值求解器，遵守了问题陈述的所有约束。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import newton\n\ndef solve():\n    \"\"\"\n    Computes the Internal Rate of Return (IRR) for a structured product\n    across several test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (mixed in-band and out-of-band years)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.03, 0.01, 0.025, 0.04, 0.033]},\n        # Case 2 (boundary inclusions trigger coupons every year)\n        {'P': 1000, 'C': 40, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.02, 0.035, 0.035, 0.02, 0.025]},\n        # Case 3 (no coupons ever, full principal returned at maturity)\n        {'P': 1000, 'C': 60, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 1.0, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 4 (no coupons ever, partial principal returned at maturity)\n        {'P': 1000, 'C': 50, 'L': 0.02, 'U': 0.035, 'T': 5, 'g': 0.9, 'i_t': [0.05, 0.05, 0.05, 0.05, 0.05]},\n        # Case 5 (one-year product, coupon paid, full principal returned)\n        {'P': 1000, 'C': 100, 'L': 0.02, 'U': 0.035, 'T': 1, 'g': 1.0, 'i_t': [0.025]},\n    ]\n\n    def npv_function(r, cash_flows):\n        \"\"\"\n        Calculates the Net Present Value for a given discount rate r and\n        a sequence of cash flows.\n        \"\"\"\n        times = np.arange(len(cash_flows))\n        return np.sum(cash_flows / ((1 + r)**times))\n\n    def compute_irr_for_case(params):\n        \"\"\"\n        Calculates the IRR for a single structured product instance.\n        \"\"\"\n        P, C, L, U, T, g, inflation_rates = \\\n            params['P'], params['C'], params['L'], params['U'], \\\n            params['T'], params['g'], params['i_t']\n\n        # Construct the cash flow sequence\n        cash_flows = np.zeros(T + 1)\n        cash_flows[0] = -P\n\n        for t in range(1, T + 1):\n            # Inflation rates list is 0-indexed, time t is 1-indexed\n            inflation_t = inflation_rates[t - 1]\n            coupon = 0\n            if L = inflation_t = U:\n                coupon = C\n            cash_flows[t] = coupon\n        \n        # Add the terminal principal guarantee at maturity\n        cash_flows[T] += g * P\n        \n        # Use a numerical solver (secant method) to find the root of the NPV function\n        # An initial guess of 0.1 (10%) is provided.\n        try:\n            irr = newton(npv_function, x0=0.1, args=(cash_flows,))\n        except RuntimeError:\n            # In cases where the function is very flat (like IRR=0),\n            # a different starting guess might be needed.\n            try:\n                irr = newton(npv_function, x0=0.0, args=(cash_flows,))\n            except RuntimeError:\n                 # Should not happen for these well-behaved cases\n                 irr = np.nan\n\n        return irr\n\n    results = []\n    for case in test_cases:\n        result = compute_irr_for_case(case)\n        results.append(result)\n\n    # Format each result to 8 decimal places and join into the final string\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2371722"}]}