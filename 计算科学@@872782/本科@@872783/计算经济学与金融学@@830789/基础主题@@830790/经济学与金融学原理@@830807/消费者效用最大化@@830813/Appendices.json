{"hands_on_practices": [{"introduction": "在标准的消费者理论模型中，我们通常假设预算约束是线性的。然而，现实世界中的定价策略要复杂得多，例如手机流量套餐、水电费等往往采用分级定价。本练习将引导你解决在分段线性的预算约束下，如何实现效用最大化的问题。通过解决这个问题，你将学会如何将复杂的非线性问题分解为多个线性片段，并掌握检查区间内部解和“拐点”解的实用技巧，这对于构建更贴近现实的消费选择模型至关重要。[@problem_id:2384169]", "problem": "单个代表性消费者选择移动数据套餐和数据使用量，以在包含固定订阅费、分级单价和硬性数据上限的预算约束下实现效用最大化。该消费者拥有外生收入 $I \\in \\mathbb{R}_{++}$，其效用来自数据使用量 $x \\in \\mathbb{R}_{+}$ 和复合记价商品 $y \\in \\mathbb{R}_{+}$。效用函数为\n$$\nu(x,y) \\;=\\; a \\,\\ln(x + s) \\;+\\; b \\,\\ln(y),\n$$\n其中 $a \\in \\mathbb{R}_{++}$ 和 $b \\in \\mathbb{R}_{++}$ 是偏好权重，$s \\in \\mathbb{R}_{++}$ 是一个微小的平滑常数，以确保 $\\ln(x+s)$ 在 $x=0$ 时有良好定义。\n\n一个移动数据套餐 $j$ 由固定费用 $F_j \\in \\mathbb{R}_{+}$、硬性上限 $C_j \\in \\mathbb{R}_{+}$ 和一个具有断点的有限分级价格表定义\n$$\n0 \\;=\\; b_{j,0}  b_{j,1}  \\cdots  b_{j,K_j} \\;=\\; C_j,\n$$\n以及相应的单位价格 $p_{j,1},\\dots,p_{j,K_j} \\in \\mathbb{R}_{+}$，其中对于第 $k$ 档 $k \\in \\{1,\\dots,K_j\\}$，当使用量 $x \\in (b_{j,k-1}, b_{j,k}]$ 时，边际价格为 $p_{j,k}$。使用量为 $x$ 时的总数据支出是一个分段线性函数\n$$\n\\operatorname{Cost}_j(x) \\;=\\; \\sum_{k=1}^{K_j} p_{j,k} \\,\\max\\!\\left(\\min\\!\\left(x - b_{j,k-1},\\, b_{j,k}-b_{j,k-1}\\right),\\, 0\\right).\n$$\n套餐 $j$ 下的预算约束是\n$$\ny \\;=\\; I \\;-\\; F_j \\;-\\; \\operatorname{Cost}_j(x),\n$$\n其中可行性要求为 $y \\in \\mathbb{R}_{++}$（由于对数项的存在），数据使用量约束为 $0 \\le x \\le C_j$（由于硬性上限）。消费者也可以选择一个“无套餐”的外部选项，用索引 $-1$ 表示，此时 $x=0$，$y=I$，效用为 $u(0,I)=a\\ln(s)+b\\ln(I)$。\n\n你的任务是计算使效用最大化的最优套餐选择和数据使用量。该问题必须从第一性原理推导，并实现为一个能够解决固定测试套件的完整程序。\n\n推导和算法设计的基础：\n- 效用最大化原则：选择 $(x,y)$ 以在线性预算约束和非负约束下最大化 $u(x,y)$。\n- 对数的凹性意味着当 $a0$，$b0$，$s0$ 时，$u(x,y)$ 对于 $(x,y)$ 是严格凹函数。\n- 分段线性定价意味着对于给定的套餐，$(x,y)$ 空间中的预算前沿是分段线性的。\n- 带有不等式约束的拉格朗日乘子的 Kuhn–Tucker 条件对于刻画凹规划中的最优点是有效的。\n\n在套餐 $j$ 的任何边际价格恒定的第 $k$ 档内，当 $x \\in (b_{j,k-1}, b_{j,k}]$ 时，边际价格为 $p_{j,k}$。设截至 $b_{j,k-1}$ 的累计成本为\n$$\nS_{j,k-1} \\;=\\; \\sum_{i=1}^{k-1} p_{j,i}\\,\\left(b_{j,i} - b_{j,i-1}\\right),\n$$\n并定义\n$$\nA_{j,k} \\;=\\; I \\;-\\; F_j \\;-\\; S_{j,k-1} \\;+\\; p_{j,k}\\,b_{j,k-1}.\n$$\n假设在第 $k$ 档内存在内部解（即 $b_{j,k-1}  x  b_{j,k}$ 且 $y>0$），一阶最优性条件意味着\n$$\n\\frac{a}{x+s} \\;=\\; \\lambda\\,p_{j,k}, \n\\qquad \n\\frac{b}{y} \\;=\\; \\lambda,\n\\qquad \ny \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x,\n$$\n将它们结合起来得到候选内部解\n$$\nx^{\\star}_{j,k} \\;=\\; \\frac{\\frac{A_{j,k}}{p_{j,k}} \\;-\\; \\frac{b}{a}\\,s}{1 \\;+\\; \\frac{b}{a}}, \n\\qquad \ny^{\\star}_{j,k} \\;=\\; A_{j,k} \\;-\\; p_{j,k}\\,x^{\\star}_{j,k}.\n$$\n此候选解仅在 $b_{j,k-1}  x^{\\star}_{j,k}  b_{j,k}$ 且 $y^{\\star}_{j,k} > 0$ 时有效。否则，该档内的最优点位于边界上（$x=b_{j,k-1}$ 或 $x=b_{j,k}$）。对于一个给定的套餐，全局最优点是在以下各点评估的效用值的最大值：\n- 所有可行的内部候选解 $x^{\\star}_{j,k}$。\n- 所有满足 $y0$ 的档位边界 $x \\in \\{0, b_{j,1},\\dots,b_{j,K_j}\\}$。\n最后，在所有套餐和外部选项中，选择效用最高的那个选项。\n\n实现一个程序，对下面的每个测试用例，计算：\n- 所选套餐的索引（外部选项为 $-1$，否则为该测试用例中从0开始的套餐索引）。\n- 最优数据使用量 $x^{\\star}$。\n- 最优剩余金额 $y^{\\star}$。\n- 实现的效用 $u^{\\star}$。\n\n除了套餐索引是整数外，所有数值结果都必须打印为实数。为了评估目的，在最终输出中将 $x^{\\star}$、$y^{\\star}$ 和 $u^{\\star}$ 四舍五入到6位小数。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$ [r_1,r_2,\\dots]$），其中每个 $r_i$ 是对应测试用例的 $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$ 的Python列表表示形式。\n\n测试套件：\n对于每个案例，首先列出元组 $(I, a, b, s)$，然后是套餐集。每个套餐被指定为 $(F, C, \\text{tiers})$，其中 $\\text{tiers}$ 是一个 $(\\text{upper\\_breakpoint}, \\text{price})$ 对的序列，其断点严格递增并在上限处结束。\n\n- 案例 1: $(I, a, b, s) = (\\,100,\\, 0.6,\\, 0.4,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0: $(F, C, \\text{tiers}) = (\\,10,\\, 50,\\, [\\,(10,\\, 2.0),\\, (30,\\, 1.0),\\, (50,\\, 3.0)\\,]\\,)$。\n  - 套餐 1: $(F, C, \\text{tiers}) = (\\,25,\\, 120,\\, [\\,(60,\\, 0.8),\\, (120,\\, 1.5)\\,]\\,)$。\n- 案例 2: $(I, a, b, s) = (\\,8,\\, 0.5,\\, 0.5,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0: $(F, C, \\text{tiers}) = (\\,10,\\, 20,\\, [\\,(10,\\, 1.5),\\, (20,\\, 2.0)\\,]\\,)$。\n  - 套餐 1: $(F, C, \\text{tiers}) = (\\,15,\\, 100,\\, [\\,(50,\\, 1.0),\\, (100,\\, 1.0)\\,]\\,)$。\n- 案例 3: $(I, a, b, s) = (\\,60,\\, 0.9,\\, 0.1,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0: $(F, C, \\text{tiers}) = (\\,5,\\, 5,\\, [\\,(5,\\, 1.0)\\,]\\,)$。\n  - 套餐 1: $(F, C, \\text{tiers}) = (\\,5,\\, 100,\\, [\\,(100,\\, 10.0)\\,]\\,)$。\n- 案例 4: $(I, a, b, s) = (\\,40,\\, 0.6,\\, 0.4,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0: $(F, C, \\text{tiers}) = (\\,0,\\, 20,\\, [\\,(10,\\, 0.5),\\, (20,\\, 5.0)\\,]\\,)$。\n  - 套餐 1: $(F, C, \\text{tiers}) = (\\,5,\\, 20,\\, [\\,(20,\\, 1.5)\\,]\\,)$。\n- 案例 5: $(I, a, b, s) = (\\,50,\\, 0.3,\\, 0.7,\\, 0.1\\,)$，套餐如下：\n  - 套餐 0: $(F, C, \\text{tiers}) = (\\,45,\\, 100,\\, [\\,(100,\\, 0.1)\\,]\\,)$。\n  - 套餐 1: $(F, C, \\text{tiers}) = (\\,5,\\, 30,\\, [\\,(15,\\, 3.0),\\, (30,\\, 5.0)\\,]\\,)$。\n\n你的程序必须计算每个案例的最优选择并输出单行：\n- 该行必须是逐个案例结果的Python列表字面量，其中每个案例的结果是 $[\\text{plan\\_index}, x^{\\star}, y^{\\star}, u^{\\star}]$，并且 $x^{\\star}$、$y^{\\star}$ 和 $u^{\\star}$ 四舍五入到6位小数。", "solution": "用户要求解决一个涉及复杂预算约束的消费者效用最大化问题。我将首先验证问题陈述，如果问题有效，则继续进行有原则的推导和算法设计。\n\n### 步骤1：提取已知条件\n\n- **效用函数**：$u(x,y) = a \\ln(x + s) + b \\ln(y)$，其中数据使用量为 $x \\in \\mathbb{R}_{+}$，记价商品为 $y \\in \\mathbb{R}_{+}$。\n- **参数**：收入 $I \\in \\mathbb{R}_{++}$，偏好权重 $a, b \\in \\mathbb{R}_{++}$，以及平滑常数 $s \\in \\mathbb{R}_{++}$。\n- **套餐定义**：一个套餐 $j$ 由固定费用 $F_j \\in \\mathbb{R}_{+}$、硬性上限 $C_j \\in \\mathbb{R}_{+}$ 和一个分级价格表定义，该价格表具有断点 $0 = b_{j,0}  b_{j,1}  \\cdots  b_{j,K_j} = C_j$ 以及对应的边际价格 $p_{j,k} \\in \\mathbb{R}_{++}$，适用于使用量 $x \\in (b_{j,k-1}, b_{j,k}]$。\n- **成本函数**：$\\operatorname{Cost}_j(x) = \\sum_{k=1}^{K_j} p_{j,k} \\max(\\min(x - b_{j,k-1}, b_{j,k}-b_{j,k-1}), 0)$。\n- **预算约束**：$y = I - F_j - \\operatorname{Cost}_j(x)$，约束条件为 $y > 0$ 和 $0 \\le x \\le C_j$。\n- **外部选项**：一个索引为 $-1$ 的选项，产生 $x=0$，$y=I$，效用为 $u(-1) = a\\ln(s) + b\\ln(I)$。\n- **优化策略提示**：一个套餐的全局最优点是通过比较所有档位边界 $\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$ 和从各档位一阶条件导出的所有有效内部候选解 $x^{\\star}_{j,k}$ 的效用而找到的。\n- **内部候选解公式**：对于第 $k$ 档，候选解为 $$x^{\\star}_{j,k} = \\frac{\\frac{a A_{j,k}}{p_{j,k}} - b s}{a+b}$$ 其中 $A_{j,k} = I - F_j - \\sum_{i=1}^{k-1} p_{j,i}(b_{j,i} - b_{j,i-1}) + p_{j,k}b_{j,k-1}$。\n- **测试套件**：提供了五个测试用例，包含所有参数的具体数值。\n\n### 步骤2：使用提取的已知条件进行验证\n\n问题经过严格验证。\n\n1.  **科学依据**：该问题是微观经济学消费者理论中的一个标准练习。效用函数是 Cobb-Douglas 形式的变体，是严格拟凹的。预算约束是分段线性的，这是现实世界定价方案中的一个常见特征。使用一阶（Kuhn-Tucker）条件的优化方法是解决此类问题的正确且标准的方法。该问题在根本上是合理的。\n2.  **适定性**：效用函数 $u(x,y)$ 在其定义域 $\\mathbb{R}_{++} \\times \\mathbb{R}_{++}$ 上是连续且严格凹的。对于每个套餐 $j$，可行的消费束 $(x,y)$ 集合构成一个凸集。由于 $\\ln(y)$ 项，要求 $y>0$ 意味着可行集不是闭集，但关于 $y$ 的 Inada 条件（当 $y$ 趋近于零时，$y$ 的边际效用趋近于无穷大）确保了任何最优解都必须有 $y^* > 0$。因此，由于严格凹性，最优点存在且唯一。该问题是适定的。\n3.  **客观性**：所有术语都以数学精度定义。问题陈述客观，没有歧义或主观内容。\n4.  **完整性**：每个测试用例所需的所有数据（$I, a, b, s$ 和套餐结构）都已提供。问题是自洽的。提供的公式在数学上是一致的。\n5.  **结构与可行性**：问题结构是逻辑的。它要求在一个由若干线性段组成的域上求一个函数的最大值。所提出的检查段内部和边界（拐点）的方法是为给定套餐寻找全局最优点的完整方法。参数在现实的数值范围内。\n\n### 步骤3：结论与行动\n\n问题是**有效的**。这是一个在计算经济学中定义明确、可解的问题。我现在将提供一个完整的解决方案。\n\n### 基于原理的解决方案设计\n\n问题是在一个由分段线性成本函数定义的预算集上最大化一个严格凹效用函数 $u(x,y)$。消费者的最优解通过一个两阶段过程找到：首先，对于每个可用的套餐 $j$，找到最优消费束 $(x_j^*, y_j^*)$ 和相应的最大效用 $u_j^*$；其次，比较所有套餐和外部选项的这些效用，以确定全局最优点。\n\n**阶段1：求解单个套餐 $j$**\n\n对于给定的套餐 $j$，预算集为 $\\{(x,y) | y = I - F_j - \\operatorname{Cost}_j(x), 0 \\le x \\le C_j, y > 0 \\}$。总成本函数 $\\operatorname{Cost}_j(x)$ 是连续且分段线性的，在档位断点 $b_{j,k}$ 处有拐点。因此，$(x,y)$ 空间中的预算前沿也是分段线性的。\n\n在这样一个集合上，凹函数的最大值必须位于以下两种类型的位置之一：\n1.  **拐点**：这些是对应于档位边界处数据使用量的点，$x \\in \\{b_{j,0}, b_{j,1}, \\dots, b_{j,K_j}\\}$。\n2.  **线性段的内部点**：在给定的第 $k$ 档内，对于 $x \\in (b_{j,k-1}, b_{j,k})$，数据的边际价格恒定为 $p_{j,k}$。预算约束变为线性的：$y = A_{j,k} - p_{j,k}x$。如果该段内存在最优点，可以通过求解拉格朗日函数的一阶条件找到，从而得到问题陈述中给出的候选解 $x_{j,k}^{\\star}$。\n\n求解单个套餐 $j$ 的算法如下：\n\n1.  **收集候选点**：为最优数据使用量 $x$ 创建一个候选值集合。\n    -   将所有档位边界加入此集合：$\\{0, b_{j,1}, \\dots, b_{j,K_j}\\}$。注意 $b_{j,0}=0$ 且 $b_{j,K_j}=C_j$。\n    -   对于每个档位 $k \\in \\{1, \\dots, K_j\\}$：\n        -   计算线性预算段的参数：恒定价格 $p_{j,k}$ 和有效收入截距 $A_{j,k}$。\n        -   使用公式计算内部候选解 $x_{j,k}^{\\star}$：\n            $$\n            x^{\\star}_{j,k} = \\frac{\\frac{a A_{j,k}}{p_{j,k}} - b s}{a+b}\n            $$\n        -   如果此候选解严格位于该档位的边界内，即 $b_{j,k-1}  x_{j,k}^{\\star}  b_{j,k}$，则将其加入候选点集合。\n\n2.  **评估候选点**：遍历唯一的候选点集合 $x_{cand}$。\n    -   对于每个 $x_{cand}$，计算总支出 $\\operatorname{Cost}_j(x_{cand})$ 和用于记价商品的剩余收入 $y_{cand} = I - F_j - \\operatorname{Cost}_j(x_{cand})$。\n    -   检查可行性：只有当固定费用可负担 ($I > F_j$) 且所选消费束能产生正的记价商品量 ($y_{cand} > 0$) 时，该套餐才可行。效用函数中的 $\\ln(y)$ 项已经强制了这一点；任何 $y_{cand} \\le 0$ 的候选解都会因其效用为 $-\\infty$ 而被隐式拒绝。\n    -   如果可行 ($y_{cand} > 0$)，计算效用 $u(x_{cand}, y_{cand}) = a \\ln(x_{cand} + s) + b \\ln(y_{cand})$。\n\n3.  **确定套餐最优点**：套餐 $j$ 的最优束 $(x_j^*, y_j^*)$ 是产生最高效用的可行候选对 $(x_{cand}, y_{cand})$。该套餐的最大效用为 $u_j^*$。\n\n**阶段2：全局优化**\n\n1.  **建立基准**：计算“无套餐”外部选项的效用，其中 $x_{-1}^*=0$ 且 $y_{-1}^*=I$。效用为 $u_{-1}^* = a \\ln(s) + b \\ln(I)$。这作为初始的最优情况基准。\n\n2.  **迭代与比较**：对于每个套餐 $j=0, 1, \\dots$，执行阶段1以找到其最优效用 $u_j^*$。将其与迄今为止找到的最高效用进行比较。如果 $u_j^*$ 更大，则套餐 $j$ 成为新的最佳选择，并记录其最优束 $(x_j^*, y_j^*)$ 和效用 $u_j^*$。\n\n3.  **最终结果**：在评估所有套餐后，记录的最佳选择即为消费者的全局最优点。最终输出包括这个最优套餐的索引（外部选项为 $-1$）、最优数据使用量 $x^*$、最优记价商品消费量 $y^*$ 和最大化后的效用 $u^*$。\n\n这种系统性搜索保证能找到全局最大值，因为它考虑了具有分段线性边界的凹规划问题所有可能的最优解类型。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the consumer utility maximization problem for a series of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {\n            \"params\": (100, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (10, 50, [(10, 2.0), (30, 1.0), (50, 3.0)]),\n                (25, 120, [(60, 0.8), (120, 1.5)]),\n            ],\n        },\n        # Case 2\n        {\n            \"params\": (8, 0.5, 0.5, 0.1),\n            \"plans\": [\n                (10, 20, [(10, 1.5), (20, 2.0)]),\n                (15, 100, [(50, 1.0), (100, 1.0)]),\n            ],\n        },\n        # Case 3\n        {\n            \"params\": (60, 0.9, 0.1, 0.1),\n            \"plans\": [\n                (5, 5, [(5, 1.0)]),\n                (5, 100, [(100, 10.0)]),\n            ],\n        },\n        # Case 4\n        {\n            \"params\": (40, 0.6, 0.4, 0.1),\n            \"plans\": [\n                (0, 20, [(10, 0.5), (20, 5.0)]),\n                (5, 20, [(20, 1.5)]),\n            ],\n        },\n        # Case 5\n        {\n            \"params\": (50, 0.3, 0.7, 0.1),\n            \"plans\": [\n                (45, 100, [(100, 0.1)]),\n                (5, 30, [(15, 3.0), (30, 5.0)]),\n            ],\n        },\n    ]\n\n    results = []\n\n    for case in test_cases:\n        I, a, b, s = case[\"params\"]\n        plans = case[\"plans\"]\n\n        # Initialize with the outside option (\"no plan\")\n        best_option = {\n            \"plan_index\": -1,\n            \"x\": 0.0,\n            \"y\": I,\n            \"u\": a * np.log(s) + b * np.log(I),\n        }\n\n        for j, plan_spec in enumerate(plans):\n            F, C, tiers = plan_spec\n\n            if I = F:\n                continue  # Fixed fee is unaffordable\n\n            breakpoints = [0.0] + [t[0] for t in tiers]\n            prices = [t[1] for t in tiers]\n\n            # --- Stage 1: Find best option for this plan ---\n            \n            # 1. Assemble candidate points for x\n            candidate_x = set(breakpoints)\n\n            cumulative_cost_at_prev_breakpoint = 0.0\n            for k in range(len(prices)):\n                p_k = prices[k]\n                b_prev = breakpoints[k]\n                b_curr = breakpoints[k+1]\n\n                # S_{j,k-1} from problem description\n                S_prev = cumulative_cost_at_prev_breakpoint\n                # A_{j,k} from problem description\n                A_k = I - F - S_prev + p_k * b_prev\n\n                # Calculate interior candidate x_star\n                # Using formula: x_star = (a*A/p - b*s)/(a+b)\n                if p_k > 0:\n                    numerator = a * A_k / p_k - b * s\n                    if numerator > 0:\n                        x_star = numerator / (a + b)\n                        if b_prev  x_star and x_star  b_curr:\n                            candidate_x.add(x_star)\n                \n                # Update cumulative cost for the next tier\n                cumulative_cost_at_prev_breakpoint += p_k * (b_curr - b_prev)\n\n            plan_best_u = -np.inf\n            plan_best_x = 0.0\n            plan_best_y = 0.0\n\n            # 2. Evaluate all candidates\n            for x_cand in sorted(list(candidate_x)):\n                \n                # Calculate cost for x_cand\n                cost = 0.0\n                x_remaining = x_cand\n                for k in range(len(prices)):\n                    tier_start = breakpoints[k]\n                    tier_end = breakpoints[k+1]\n                    tier_price = prices[k]\n\n                    if x_remaining = 0:\n                        break\n                    \n                    usage_in_tier = min(x_remaining, tier_end - tier_start)\n                    cost += usage_in_tier * tier_price\n                    x_remaining -= usage_in_tier\n                \n                y_cand = I - F - cost\n                \n                # Check feasibility and calculate utility\n                if y_cand > 0:\n                    u_cand = a * np.log(x_cand + s) + b * np.log(y_cand)\n                    if u_cand > plan_best_u:\n                        plan_best_u = u_cand\n                        plan_best_x = x_cand\n                        plan_best_y = y_cand\n\n            # --- Stage 2: Compare plan's best with overall best ---\n            if plan_best_u > best_option[\"u\"]:\n                best_option = {\n                    \"plan_index\": j,\n                    \"x\": plan_best_x,\n                    \"y\": plan_best_y,\n                    \"u\": plan_best_u,\n                }\n\n        results.append([\n            best_option[\"plan_index\"],\n            round(best_option[\"x\"], 6),\n            round(best_option[\"y\"], 6),\n            round(best_option[\"u\"], 6),\n        ])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384169"}, {"introduction": "理论模型常常假设商品是无限可分的，但现实中许多商品（如家电、汽车）只能以整数单位购买。当这些离散商品与其它商品存在完全互补关系时，消费者的决策过程是怎样的？本练习结合了列昂惕夫（Leontief）效用函数（完全互补品）和离散选择这两个重要概念。通过这个实践，你将学习如何处理当商品不可替代且部分商品非连续时，如何调整你的优化策略，通过逻辑枚举而非单纯依赖微积分工具来寻找最优解。[@problem_id:2384153]", "problem": "考虑一个消费者选择两种非负数量的商品，$x$ 商品和 $y$ 商品，在一个线性预算约束下最大化其效用。效用函数为 Leontief（完全互补品）形式，由 $U(x,y)=\\min(a x, b y)$ 给出，其中 $a>0$ 和 $b>0$ 是固定参数。商品 $x$ 的价格为 $p_x>0$，商品 $y$ 的价格为 $p_y>0$。收入为 $m\\ge 0$。选择集受到预算 $p_x x + p_y y \\le m$、$x \\ge 0$ 以及一个供给限制的约束，即 $y$ 必须以离散整数单位选择，$y \\in \\{0,1,2,\\dots\\}$。消费者旨在选择 $(x,y)$ 以最大化 $U(x,y)$。\n\n在所有效用最大化的商品束中，选择那个能达到最大效用且具有最小整数 $y$ 的商品束。对于该选定的 $y$，选择能够达到所选效用并满足预算约束的最小非负实数值 $x$。\n\n所有变量均无单位。不涉及角度或物理单位。\n\n您的程序必须根据上述约束和选择规则，为下面的每个参数集计算效用最大化的商品束 $(x^\\star,y^\\star)$ 和相应的最大效用 $U^\\star=U(x^\\star,y^\\star)$。每个参数集所需的输出是一个三元组 $[x^\\star,y^\\star,U^\\star]$。\n\n请为以下参数集测试套件提供结果，每个参数集指定为 $(a,b,p_x,p_y,m)$：\n- $(a,b,p_x,p_y,m) = (\\, 1.0,\\, 1.0,\\, 2.0,\\, 3.0,\\, 20.0 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 2.0,\\, 1.0,\\, 3.0,\\, 5.0,\\, 11.0 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 1.5,\\, 2.0,\\, 1.0,\\, 10.0,\\, 7.0 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 2.0,\\, 1.0,\\, 3.0,\\, 4.0,\\, 9.5 \\,)$\n- $(a,b,p_x,p_y,m) = (\\, 3.0,\\, 5.0,\\, 2.0,\\, 7.0,\\, 100.0 \\,)$\n\n最终输出格式：\n- 对于每个参数集，输出一个三元组 $[x^\\star,y^\\star,U^\\star]$，其中 $x^\\star$ 和 $U^\\star$ 是四舍五入到六位小数的实数，$y^\\star$ 是一个整数。\n- 将所有参数集的结果聚合到一行，形式为方括号内以逗号分隔的列表，不含空格。例如：$[[\\!x^\\star_1,y^\\star_1,U^\\star_1],[\\!x^\\star_2,y^\\star_2,U^\\star_2],\\dots]$。", "solution": "所呈现的问题是微观经济学领域的一个约束效用最大化问题。该问题定义明确，数学上一致，并以成熟的经济学理论为基础。效用函数为 Leontief 形式，$U(x,y)=\\min(ax, by)$，代表完全互补品。消费者的选择受到预算约束 $p_x x + p_y y \\le m$ 和混合变量约束的限制，其中商品 $x$ 是一个连续非负变量 ($x \\ge 0$)，而商品 $y$ 是一个离散非负整数 ($y \\in \\{0,1,2,\\dots\\}$)。目标是找到满足这些约束以及一套特定平局决胜规则的商品束 $(x^\\star, y^\\star)$ 和相应的最大效用 $U^\\star$。\n\n分析始于 Leontief 效用函数的性质。为了最大化效用，一个理性的消费者绝不会选择 $ax \\neq by$ 的商品束。例如，如果 $ax > by$，效用完全由项 $by$ 决定。消费者可以减少 $x$ 的消费而不会有任何效用损失，从而节省收入。这部分节省的收入可以被重新分配以增加两种商品的消费，从而达到一个严格更高的效用水平。因此，任何具有正效用的最优商品束都必须满足条件 $ax = by$。这个关系定义了扩展路径，最优商品束必须位于其上。由此，我们推导出商品的最优比例为 $x = \\frac{b}{a}y$。\n\n$y$ 必须是整数的约束将问题转化为一个混合整数优化问题。我们不能再简单地求解方程组 $ax = by$ 和 $p_x x + p_y y = m$。相反，我们必须评估每个可行的整数值 $y$ 所能达到的最大可能效用。\n\n对于 $y$ 的一个整数选择，我们称之为 $y_k$，只有当其成本不超过总收入时，即 $p_y y_k \\le m$，它才是可行的。这意味着 $y$ 的可行整数集合是有限的，由 $y_k \\in \\{0, 1, 2, \\dots, \\lfloor \\frac{m}{p_y} \\rfloor \\}$ 给出。对于任何这样的可行 $y_k$，消费者将通过把所有剩余收入分配给商品 $x$ 来最大化效用。可以购买的 $x$ 的最大数量是 $x_{max} = \\frac{m - p_y y_k}{p_x}$。这个商品束 $(x_{max}, y_k)$ 的效用是 $U_k = U(x_{max}, y_k) = \\min(a \\cdot x_{max}, b \\cdot y_k)$。\n\n我们的目标是从可行集中找到使该函数 $U_k$ 最大化的整数 $y_k$。为了指导这一搜索，我们考虑一个类似的问题，其中 $y$ 是一个连续变量。当 $\\min$ 函数的两个参数相等时，效用 $U(y) = \\min(a \\frac{m - p_y y}{p_x}, by)$ 达到最大值：$a \\frac{m - p_y y}{p_x} = by$。解出 $y$ 得到连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n\n函数 $g(y) = by$ 在 $y$ 上是递增的，而函数 $f(y) = a \\frac{m - p_y y}{p_x}$ 在 $y$ 上是递减的。因此，函数 $\\min(f(y), g(y))$ 是拟凹的，在 $y  y_{cont}^*$ 时递增，在 $y > y_{cont}^*$ 时递减。因此，对于整数 $y$ 的最大效用必须出现在包围连续最优值的两个整数之一处：$y_1 = \\lfloor y_{cont}^* \\rfloor$ 或 $y_2 = \\lceil y_{cont}^* \\rceil = y_1 + 1$。\n\n求解算法如下：\n1. 计算连续最优值 $y_{cont}^* = \\frac{am}{b p_x + a p_y}$。\n2. 第一个整数候选者是 $y_1 = \\lfloor y_{cont}^* \\rfloor$。我们计算相应的最大效用 $U_1 = \\min\\left(a \\frac{m - p_y y_1}{p_x}, b y_1\\right)$。\n3. 第二个整数候选者是 $y_2 = y_1 + 1$。我们必须首先通过检查 $p_y y_2 \\le m$ 来验证其可行性。如果可行，我们计算其效用 $U_2 = \\min\\left(a \\frac{m - p_y y_2}{p_x}, b y_2\\right)$。\n4. 然后我们确定最优整数 $y^\\star$ 和最大效用 $U^\\star$。最大效用是 $U^\\star = \\max(U_1, U_2)$（如果 $y_2$ 不可行，则就是 $U_1$）。问题指定了一个平局决胜规则：如果多个商品束产生相同的最大效用，我们必须选择具有最小整数 $y^\\star$ 的那个。因此：\n    - 如果 $U_2 > U_1$，我们选择 $y^\\star = y_2$ 且 $U^\\star = U_2$。\n    - 否则（如果 $U_1 \\ge U_2$ 或者 $y_2$ 不可行），我们选择 $y^\\star = y_1$ 且 $U^\\star = U_1$。\n5. 最后，我们必须确定 $x^\\star$ 的值。第二个平局决胜规则指出，对于选定的 $y^\\star$，我们必须选择能够达到效用 $U^\\star$ 并满足预算约束的最小非负 $x$。为了达到效用 $U^\\star$，我们需要 $\\min(ax, by^\\star) \\ge U^\\star$。这意味着 $ax \\ge U^\\star$ 和 $by^\\star \\ge U^\\star$。条件 $ax \\ge U^\\star$ 给出 $x \\ge U^\\star/a$。满足此条件的最小非负 $x$ 正是 $x^\\star = U^\\star/a$。根据 $U^\\star$ 的定义，这个 $x^\\star$ 的选择保证是预算可行的。\n\n此过程根据问题的规定，提供了唯一的效用最大化商品束 $(x^\\star, y^\\star)$ 和相关的效用 $U^\\star$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the utility maximization problem for a series of test cases.\n    The utility function is Leontief U(x,y) = min(ax, by), with y being discrete.\n    \"\"\"\n    # Define the test cases from the problem statement as (a, b, p_x, p_y, m).\n    test_cases = [\n        (1.0, 1.0, 2.0, 3.0, 20.0),\n        (2.0, 1.0, 3.0, 5.0, 11.0),\n        (1.5, 2.0, 1.0, 10.0, 7.0),\n        (2.0, 1.0, 3.0, 4.0, 9.5),\n        (3.0, 5.0, 2.0, 7.0, 100.0),\n    ]\n\n    results_as_strings = []\n    for a, b, px, py, m in test_cases:\n        # Handle the trivial case of zero income.\n        if m = 0:\n            x_star, y_star, U_star = 0.0, 0, 0.0\n        else:\n            # Calculate the optimal 'y' as if it were a continuous variable.\n            # This is the point where the two components of the utility function,\n            # scaled by the budget, would be equal.\n            # y_cont_star = (a * m) / (b * p_x + a * p_y)\n            y_cont_star = (a * m) / (b * px + a * py)\n            \n            # The optimal integer y must be one of the two integers surrounding y_cont_star.\n            # Candidate 1: floor(y_cont_star)\n            y1 = int(np.floor(y_cont_star))\n            \n            # Calculate the maximum utility achievable with y1.\n            # This assumes all remaining budget is spent on x.\n            xmax1 = (m - py * y1) / px\n            U1 = min(a * xmax1, b * y1)\n            \n            # Initialize the optimal choice with the results from y1.\n            y_star = y1\n            U_star = U1\n            \n            # Candidate 2: ceil(y_cont_star) = y1 + 1\n            y2 = y1 + 1\n            \n            # Check if y2 is affordable within the budget.\n            if py * y2 = m:\n                # If affordable, calculate its corresponding maximum utility.\n                xmax2 = (m - py * y2) / px\n                U2 = min(a * xmax2, b * y2)\n                \n                # Update the optimal choice if y2 yields a strictly higher utility.\n                # If utilities are equal, the tie-breaking rule requires choosing the\n                # smaller y, which is y1, so we do nothing in case of a tie.\n                if U2 > U1:\n                    y_star = y2\n                    U_star = U2\n            \n            # The final optimal value of x is determined by the utility level U_star.\n            # To get utility U_star, we must have ax >= U_star, so the smallest x is U_star / a.\n            if a > 0:\n                x_star = U_star / a\n            else: # Should not happen based on problem constraints (a>0)\n                x_star = 0.0\n\n        # Format the result triple [x*, y*, U*] as a string.\n        res_str = f\"[{x_star:.6f},{y_star},{U_star:.6f}]\"\n        results_as_strings.append(res_str)\n        \n    # Aggregate all result strings into the final required output format.\n    final_output = f\"[{','.join(results_as_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2384153"}, {"introduction": "我们已经探讨了包含单个离散商品的决策问题，现在让我们将其推广到所有商品都不可分的一般情况。这个练习将向你展示，在预算约束下从一系列不可分商品中进行选择的消费者问题，如何被精确地构建为一个经典的组合优化问题——0/1背包问题。这个实践通过将经济学理论与计算机科学相联系，提供了一个深刻的视角。你将学习如何将一个经济问题形式化为整数规划，并使用动态规划等算法来求解，从而揭示离散选择问题的内在计算结构，并掌握解决更广泛资源分配问题的强大工具。[@problem_id:2384164]", "problem": "给定一个包含不可分商品的离散时间消费者选择问题。消费者面临一组有限的商品，索引为 $i \\in \\{1,\\dots,n\\}$。每种商品可以不购买，也可以购买一个单位。消费者有一个由向量 $u \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示的非负、加性可分效用指数，其中 $u_i$ 是获得一个单位商品 $i$ 的效用；以及一个由向量 $p \\in \\mathbb{R}_{\\ge 0}^{n}$ 表示的非负价格，其中 $p_i$ 是一个单位商品 $i$ 的价格。消费者拥有预算 $M \\in \\mathbb{R}_{\\ge 0}$。决策变量为 $x_i \\in \\{0,1\\}$（对每个 $i$），表示是否购买商品 $i$。消费者寻求在预算约束下最大化总效用。\n\n根据基本微观经济学原理，消费者问题是在资源约束下最大化一个效用函数。在商品间效用可加且商品不可分的条件下，这成为一个组合优化问题。您的任务是：\n\n- 从效用最大化和预算集的定义出发，推导该离散消费者选择问题的精确数学公式，引入二元决策变量和线性预算约束。使用有效的整数规划来表达该问题。\n- 解释为何此公式是 0-1 背包问题的一个实例，其中效用扮演价值的角色，价格扮演重量的角色，预算则是容量。\n- 设计并实现一个精确算法，将该问题作为整数规划来求解。您必须得出一个总效用的精确最大化器。您可以使用一种有原则的算法，例如带有分数背包上界的分支定界方案，或伪多项式动态规划，确保对所有提供的测试用例的正确性。从基本原理清晰地解释算法逻辑。\n\n您的程序必须实现该求解器，并将其应用于以下测试用例集，每个测试用例由一个效用向量 $u$、一个价格向量 $p$ 和一个预算 $M$ 指定：\n\n- 测试 $1$ (一般情况): $u = [9,6,7,3]$, $p = [4,3,5,2]$, $M = 7$.\n- 测试 $2$ (零预算边界): $u = [5,4]$, $p = [1,2]$, $M = 0$.\n- 测试 $3$ (零价格物品): $u = [4,10,2]$, $p = [0,5,3], $M = 5$.\n- 测试 $4$ (单位美元效用存在平局，但最优总效用唯一): $u = [6,6,5]$, $p = [4,4,5]$, $M = 8$.\n- 测试 $5$ (存在被支配选项): $u = [8,7,6,9]$, $p = [5,6,4,7]$, $M = 9$.\n- 测试 $6$ (预算超过总成本，全选): $u = [3,5,2]$, $p = [1,2,1]$, $M = 10$.\n\n为覆盖性而设计：\n- 测试 $1$ 是一个标准的非平凡实例。\n- 测试 $2$ 检查 $M = 0$ 的边界情况。\n- 测试 $3$ 检查对零价格物品的处理。\n- 测试 $4$ 检查在效用-价格比存在平局但最优总效用唯一的情况下的行为。\n- 测试 $5$ 包含一个被支配选项以验证正确的剪枝。\n- 测试 $6$ 检查容量占优的情况，即最优选择是购买所有商品。\n\n假设：\n- 所有效用项满足 $u_i \\ge 0$。\n- 所有价格满足 $p_i \\ge 0$，除非另有说明，否则至少有一个 $p_i  0$。\n- 如果任何 $p_i = 0$ 且 $u_i  0$，那么对于这类物品，将 $x_i = 1$ 总是理性的。\n\n您的程序应为每个测试用例计算可实现的最大总效用，并将其作为一个整数。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[a_1,a_2,\\dots,a_6]$，其中 $a_j$ 是测试 $j$ 的最大总效用，按上述顺序排列。不涉及物理单位或角度单位。将每个数字表示为整数。此问题中不使用百分比。", "solution": "在加性可分效用函数和预算约束下的离散消费者选择问题，是微观经济学理论中的一个经典模型，也是组合优化中的一个基本问题。我们将首先验证问题陈述，然后推导其数学公式，将其与一个已知的问题结构联系起来，最后设计并实现一个正确且精确的算法。\n\n**问题公式化**\n\n消费者的目标是在预算约束下，最大化从商品集合中获得的总效用。设商品集合由 $i \\in \\{1, \\dots, n\\}$ 索引。对于每种商品 $i$，消费者做出一个由变量 $x_i$ 表示的二元决策，其中如果购买该商品，则 $x_i = 1$，如果不购买，则 $x_i = 0$。\n效用是加性可分的，这意味着总效用是所购买单个商品效用的总和。给定一个效用向量 $u = (u_1, u_2, \\dots, u_n)$，总效用表示为线性函数：\n$$\nU(x) = \\sum_{i=1}^{n} u_i x_i\n$$\n消费者面临预算约束。给定一个价格向量 $p = (p_1, p_2, \\dots, p_n)$ 和总预算 $M$，总支出不得超过预算。这表示为线性不等式：\n$$\n\\sum_{i=1}^{n} p_i x_i \\le M\n$$\n结合目标函数、预算约束和决策变量的二元性质，我们得到以下整数线性规划 (ILP) 公式：\n$$\n\\begin{aligned}\n\\text{maximize} \\quad  \\sum_{i=1}^{n} u_i x_i \\\\\n\\text{subject to} \\quad  \\sum_{i=1}^{n} p_i x_i \\le M \\\\\n x_i \\in \\{0, 1\\}, \\quad \\forall i \\in \\{1, \\dots, n\\}\n\\end{aligned}\n$$\n此公式精确地描述了消费者的优化问题。所有参数 ($u_i$, $p_i$, $M$) 均为给定的非负实数。\n\n**与 0-1 背包问题的关系**\n\n推导出的 ILP 在结构上与标准的 0-1 背包问题相同。0-1 背包问题是一个组合优化问题，定义如下：给定一组物品，每个物品都有一个价值和一个重量，确定要包含在集合（“背包”）中的物品子集，以使总价值最大化，同时受总重量不超过给定容量的约束。\n\n其形式上的映射是直接且明确的：\n-   消费者的商品对应于背包问题中的 *物品*。\n-   商品 $i$ 的效用 $u_i$ 对应于物品 $i$ 的 *价值*。\n-   商品 $i$ 的价格 $p_i$ 对应于物品 $i$ 的 *重量*。\n-   消费者的预算 $M$ 对应于背包的 *容量*。\n-   决策变量 $x_i$ (购买与否) 等同于决定是否将一个物品放入背包。\n\n因此，解决消费者的效用最大化问题等同于解决一个 0-1 背包问题的实例。此问题是 NP-难的，这意味着没有已知的算法可以在关于物品数量和表示输入所需的比特数的多项式时间内解决它。然而，它允许通过动态规划得到一个伪多项式时间解。\n\n**算法设计：动态规划**\n\n我们将构建一个动态规划算法来找到精确的最优效用。该算法依赖于最优性原理：问题的最优解可以由其子问题的最优解构造而成。\n\n首先，我们处理零价格物品的特殊情况。根据问题的假设，如果一个商品 $i$ 的价格 $p_i=0$ 且效用 $u_i > 0$，那么获取它总是最优的，因为它在不消耗预算的情况下提供了正效用。因此，我们可以预处理物品列表。我们将所有此类零价格物品的效用相加，建立一个 `base_utility` (基础效用)，然后使用原始预算 $M$ 来解决剩余的正价格商品问题。\n\n设剩余的物品（价格 $p_i>0$）从 $1$ 到 $n'$ 索引。子问题定义为使用前 $i$ 个物品（$1 \\le i \\le n'$）的子集，在预算为 $w$（$0 \\le w \\le M$）的情况下可获得的最大效用。令 $dp[i][w]$ 表示该解的值。\n\n递推关系通过考虑第 $i$ 个物品（效用 $u_i$，价格 $p_i$）来推导：\n1.  **不包含物品 $i$**：最大效用与用前 $i-1$ 个物品和预算 $w$ 可达到的效用相同。此值为 $dp[i-1][w]$。\n2.  **包含物品 $i$**：仅当其价格 $p_i$ 不超过当前预算 $w$ 时才可能。如果包含，它对效用贡献 $u_i$，剩余的预算 $w - p_i$ 可用于前 $i-1$ 个物品的最优选择。此情况下的总效用是 $u_i + dp[i-1][w-p_i]$。\n\n最优选择是这两个选项中的最大值。因此，递推关系为：\n$$\ndp[i][w] = \\begin{cases}\ndp[i-1][w]  \\text{if } p_i > w \\\\\n\\max(dp[i-1][w], u_i + dp[i-1][w-p_i])  \\text{if } p_i \\le w\n\\end{cases}\n$$\n基本情况是 $dp[0][w] = 0$ 对所有 $w$ 成立，因为零个物品不能获得任何效用。\n\n这个二维动态规划公式的时间复杂度为 $O(n'M)$，空间复杂度为 $O(n'M)$。通过观察到第 $i$ 行的计算仅依赖于第 $i-1$ 行，空间复杂度可以优化到 $O(M)$。通过使用一个一维数组 `dp[w]` 并将预算 `w` 从 $M$ 向下迭代到 $p_i$，我们可以防止在同一个物品处理步骤中多次使用物品 $i$ 的信息。对于大小为 $M+1$ 的单个数组 `dp` 的优化递推关系如下：\n\n对于每个物品 $i$ 从 $1$到 $n'$:\n对于每个预算 $w$ 从 $M$ 到 $p_i$:\n$$\ndp[w] = \\max(dp[w], u_i + dp[w-p_i])\n$$\n子问题的最终解是 $dp[M]$。最大总效用是此值加上来自零价格物品的 `base_utility` (基础效用)。由于问题的测试用例涉及整数价格和预算，这种动态规划方法是适用且高效的。实现将遵循这种空间优化的方法。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the discrete consumer choice problem for a suite of test cases.\n    This problem is equivalent to the 0-1 knapsack problem.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1 (general case)\n        {'u': [9, 6, 7, 3], 'p': [4, 3, 5, 2], 'M': 7},\n        # Test 2 (zero budget boundary)\n        {'u': [5, 4], 'p': [1, 2], 'M': 0},\n        # Test 3 (zero-price item)\n        {'u': [4, 10, 2], 'p': [0, 5, 3], 'M': 5},\n        # Test 4 (tie in per-dollar utilities, unique optimal utility)\n        {'u': [6, 6, 5], 'p': [4, 4, 5], 'M': 8},\n        # Test 5 (dominated item present)\n        {'u': [8, 7, 6, 9], 'p': [5, 6, 4, 7], 'M': 9},\n        # Test 6 (budget exceeds total cost, take all)\n        {'u': [3, 5, 2], 'p': [1, 2, 1], 'M': 10},\n    ]\n\n    results = []\n    for case in test_cases:\n        utilities = case['u']\n        prices = case['p']\n        budget = case['M']\n        \n        n = len(utilities)\n        base_utility = 0\n        \n        # Preprocessing step for zero-price items\n        positive_price_items = []\n        for i in range(n):\n            if prices[i] == 0:\n                if utilities[i] > 0:\n                    base_utility += utilities[i]\n            else:\n                # We only consider items that could potentially fit in the budget\n                if prices[i] = budget:\n                    positive_price_items.append({'u': utilities[i], 'p': prices[i]})\n\n        # If budget is 0, no items with positive price can be bought.\n        if budget == 0:\n            results.append(base_utility)\n            continue\n\n        # Dynamic Programming solution for the 0-1 Knapsack problem\n        # dp[w] stores the maximum utility for a budget of w.\n        # The budget is treated as an integer quantity.\n        dp = np.zeros(budget + 1, dtype=int)\n        \n        for item in positive_price_items:\n            utility = item['u']\n            price = item['p']\n            # Iterate backwards to use each item at most once\n            for w in range(budget, price - 1, -1):\n                dp[w] = max(dp[w], utility + dp[w - price])\n                \n        max_utility = dp[budget] + base_utility\n        results.append(int(max_utility))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2384164"}]}