{"hands_on_practices": [{"introduction": "本练习将引导我们解决一个核心的优化问题。设想一位自由职业者，他必须在设定更高时薪（这会降低找到工作的概率）与承诺的工作时长（这会产生机会成本）之间做出权衡。这个问题旨在锻炼构建预期利润函数并通过微积分求解最大值的基本技能。[@problem_id:2422477]", "problem": "考虑一位风险中性的自由职业者，他在单个时期内决定小时费率 $w \\ge 0$ 并预留 $h \\ge 0$ 小时的可用时间。该工作者以 $p(w) = \\exp(-\\alpha w)$ 的概率与客户匹配，其中 $\\alpha > 0$。如果匹配成功，该工作者在所有 $h$ 小时内每小时赚取 $w$，总收入为 $w h$；如果未匹配，收入为 $0$。预留 $h$ 小时会产生机会成本 $c(h) = \\frac{\\gamma}{2} h^{2}$（其中 $\\gamma > 0$），无论是否匹配成功，该成本都会产生。\n\n假设存在内部解，并且该工作者选择 $(w,h)$ 以最大化期望利润（期望收入减去机会成本），请确定利润最大化的选择 $(w^{\\star}, h^{\\star})$，并以 $\\alpha$ 和 $\\gamma$ 的闭式表达式表示。\n\n你的最终答案必须是单个解析表达式。不要提供不等式或方程。无需四舍五入。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n步骤1：提取已知条件\n- 决策变量：小时费率 $w \\ge 0$，可用小时数 $h \\ge 0$。\n- 与客户匹配的概率：$p(w) = \\exp(-\\alpha w)$。\n- 概率函数的参数约束：$\\alpha > 0$。\n- 匹配成功时的收入：$w h$。\n- 未匹配时的收入：$0$。\n- 机会成本函数：$c(h) = \\frac{\\gamma}{2} h^{2}$。\n- 成本函数的参数约束：$\\gamma > 0$。\n- 工作者的目标：最大化期望利润。\n- 期望利润定义：期望收入减去机会成本。\n- 假设：存在内部解，意味着最优选择 $(w^{\\star}, h^{\\star})$ 满足 $w^{\\star} > 0$ 和 $h^{\\star} > 0$。\n- 目标：确定利润最大化的选择 $(w^{\\star}, h^{\\star})$，并以 $\\alpha$ 和 $\\gamma$ 的闭式表达式表示。\n\n步骤2：使用提取的已知条件进行验证\n- **科学依据**：该问题在经济学原理中有充分的依据。在经济建模中，使用指数函数表示成功概率和使用二次函数表示成本是常见的做法，以确保诸如收益递减和边际成本递增等理想性质。风险中性的假设将效用函数简化为货币的线性函数。该问题在科学上和数学上都是合理的。\n- **适定性**：该问题是适定的。它指定了一个目标函数（期望利润），该函数需要关于两个选择变量（$w$ 和 $h$）进行最大化，并受限于给定的函数形式和参数约束（$\\alpha > 0$，$\\gamma > 0$）。存在内部解的假设将方法论引向标准微分学，确保可以找到唯一解。\n- **客观性**：该问题使用精确、客观的数学语言陈述，没有歧义或主观论断。\n\n步骤3：结论与行动\n该问题有效。它是一个定义明确、有科学依据的优化问题。将推导求解。\n\n工作者的期望利润（表示为 $\\Pi(w, h)$）是期望收入减去机会成本。期望收入是匹配成功时的收入 $w h$ 乘以匹配成功的概率 $p(w)$，加上未匹配时的收入 $0$ 乘以未匹配的概率 $1-p(w)$。机会成本 $c(h)$ 无论结果如何都会产生。\n\n因此，期望利润函数为：\n$$\n\\Pi(w, h) = p(w) \\cdot (wh) + (1 - p(w)) \\cdot 0 - c(h)\n$$\n代入给定的函数形式 $p(w)$ 和 $c(h)$：\n$$\n\\Pi(w, h) = \\exp(-\\alpha w) w h - \\frac{\\gamma}{2} h^{2}\n$$\n为了对该函数关于 $w$ 和 $h$ 进行最大化，我们求其一阶偏导数并令它们为零。这是临界点的一阶条件。问题中关于内部解的假设保证了该点对应于最大利润。\n\n首先，我们对工资 $w$ 求导：\n$$\n\\frac{\\partial \\Pi}{\\partial w} = \\frac{\\partial}{\\partial w} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\n对第一项使用乘法法则求导：\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\cdot \\frac{d}{dw}(w \\exp(-\\alpha w)) = h \\left( 1 \\cdot \\exp(-\\alpha w) + w \\cdot (-\\alpha \\exp(-\\alpha w)) \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial w} = h \\exp(-\\alpha w) (1 - \\alpha w)\n$$\n将此偏导数设为零，得到第一个条件：\n$$\nh \\exp(-\\alpha w) (1 - \\alpha w) = 0\n$$\n\n接下来，我们对小时数 $h$ 求导：\n$$\n\\frac{\\partial \\Pi}{\\partial h} = \\frac{\\partial}{\\partial h} \\left( w h \\exp(-\\alpha w) - \\frac{\\gamma}{2} h^{2} \\right)\n$$\n$$\n\\frac{\\partial \\Pi}{\\partial h} = w \\exp(-\\alpha w) - \\gamma h\n$$\n将此偏导数设为零，得到第二个条件：\n$$\nw \\exp(-\\alpha w) - \\gamma h = 0\n$$\n\n现在我们有一个包含两个未知数 $w$ 和 $h$ 的方程组：\n1. $h \\exp(-\\alpha w) (1 - \\alpha w) = 0$\n2. $w \\exp(-\\alpha w) - \\gamma h = 0$\n\n从方程(1)可知，因为我们在寻找 $h^{\\star} > 0$ 的内部解，并且由于对于任何有限的 $w$，项 $\\exp(-\\alpha w)$ 都是严格为正的，所以只有当项 $(1 - \\alpha w)$ 等于零时，该方程才能成立。\n$$\n1 - \\alpha w = 0\n$$\n解出 $w$ 得到最优工资率 $w^{\\star}$：\n$$\nw^{\\star} = \\frac{1}{\\alpha}\n$$\n由于给定 $\\alpha > 0$，因此 $w^{\\star}$ 为正，这与内部解的假设一致。\n\n现在，我们将这个最优工资 $w^{\\star}$ 代入方程(2)来求最优小时数 $h^{\\star}$：\n$$\n\\left(\\frac{1}{\\alpha}\\right) \\exp\\left(-\\alpha \\left(\\frac{1}{\\alpha}\\right)\\right) - \\gamma h = 0\n$$\n$$\n\\frac{1}{\\alpha} \\exp(-1) - \\gamma h = 0\n$$\n重新整理以解出 $h$：\n$$\n\\gamma h = \\frac{1}{\\alpha} \\exp(-1) = \\frac{1}{\\alpha e}\n$$\n这就得到了最优小时数 $h^{\\star}$：\n$$\nh^{\\star} = \\frac{1}{\\alpha \\gamma e}\n$$\n由于给定 $\\alpha > 0$ 和 $\\gamma > 0$，因此 $h^{\\star}$ 也为正，这与内部解的假设一致。\n\n因此，利润最大化的选择是 $(w^{\\star}, h^{\\star}) = \\left(\\frac{1}{\\alpha}, \\frac{1}{\\alpha \\gamma e}\\right)$。\n\n为严谨起见，我们可以使用二阶条件来验证这是一个最大值。二阶偏导数的海森矩阵为：\n$$ H(w,h) = \\begin{pmatrix} \\frac{\\partial^2 \\Pi}{\\partial w^2} & \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} \\\\ \\frac{\\partial^2 \\Pi}{\\partial h \\partial w} & \\frac{\\partial^2 \\Pi}{\\partial h^2} \\end{pmatrix} $$\n各分量为：\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2} = -h\\alpha\\exp(-\\alpha w)(2 - \\alpha w) $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2} = -\\gamma $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h} = \\exp(-\\alpha w)(1 - \\alpha w) $$\n在临界点 $w^{\\star} = 1/\\alpha$ 和 $h^{\\star} = 1/(\\alpha \\gamma e)$ 处：\n$$ \\frac{\\partial^2 \\Pi}{\\partial w^2}\\bigg|_{(w^{\\star},h^{\\star})} = -h^{\\star}\\alpha\\exp(-1)(2 - 1) = -\\frac{1}{\\alpha\\gamma e}\\alpha e^{-1} = -\\frac{1}{\\gamma e^2}  0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial h^2}\\bigg|_{(w^{\\star},h^{\\star})} = -\\gamma  0 $$\n$$ \\frac{\\partial^2 \\Pi}{\\partial w \\partial h}\\bigg|_{(w^{\\star},h^{\\star})} = \\exp(-1)(1 - 1) = 0 $$\n在此点处海森矩阵的行列式为：\n$$ D = \\left(-\\frac{1}{\\gamma e^2}\\right)(-\\gamma) - (0)^2 = \\frac{1}{e^2}  0 $$\n由于行列式 $D$ 为正，且 $\\frac{\\partial^2 \\Pi}{\\partial w^2}$ 为负，因此该临界点是一个局部最大值，符合要求。\n\n利润最大化的选择由推导出的 $w^{\\star}$ 和 $h^{\\star}$ 的表达式给出。", "answer": "$$\n\\boxed{\\begin{pmatrix} \\frac{1}{\\alpha}  \\frac{1}{\\alpha \\gamma e} \\end{pmatrix}}\n$$", "id": "2422477"}, {"introduction": "接下来，我们将从静态分析转向动态环境。这个问题模拟了一个奢侈品品牌面临的真实战略挑战：今天的销量如何影响品牌声望和未来的市场需求。我们将运用逆向归纳法来解决这个跨期优化问题，这凸显了当前决策如何影响未来收益，是动态规划中的一个核心思想。[@problem_id:2422445]", "problem": "考虑一个在两个离散时期（由 $t \\in \\{1,2\\}$ 索引）内生产单一奢侈品的垄断者。在每个时期 $t$，该商品的反需求曲线是线性的，由 $p_t(q_t) = A_t - B_t q_t$ 给出，其中 $A_t  0$ 和 $B_t  0$ 是参数，$q_t \\ge 0$ 是时期 $t$ 的销售数量。该公司在两个时期内都有一个不变的边际成本 $c \\ge 0$。收入和成本以任意货币单位计价。时间没有物理单位，是无量纲的。跨期权衡由一个以小数（而非百分比）表示的贴现因子 $\\beta \\in (0,1)$ 进行贴现。\n\n品牌稀释：大量销售奢侈品可能会损害品牌并降低未来的支付意愿。我们将此建模为时期2需求截距的向下移动，该移动取决于时期1的数量超出声望阈值数量 $q_{\\text{bar}} \\ge 0$ 的程度。具体来说，时期2的截距为\n$$\nA_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0,\\, q_1 - q_{\\text{bar}}\\},\n$$\n其中 $d \\ge 0$ 是稀释敏感度。如果 $q_1 \\le q_{\\text{bar}}$，则没有稀释，且 $A_2^{\\text{eff}}(q_1) = A_2$；如果 $q_1  q_{\\text{bar}}$，截距以斜率 $-d$ 线性缩小。\n\n垄断者在时期1选择 $q_1$，在时期2选择 $q_2$，以最大化利润的贴现总和。时期 $t$ 的利润为\n$$\n\\pi_t(q_t) = \\big(p_t(q_t) - c\\big)\\, q_t = \\big(A_t - B_t q_t - c\\big)\\, q_t,\n$$\n需要注意的是，在时期2，相关的截距是 $A_2^{\\text{eff}}(q_1)$，即 $p_2(q_2) = A_2^{\\text{eff}}(q_1) - B_2 q_2$。总目标为\n$$\n\\Pi(q_1,q_2) = \\pi_1(q_1) + \\beta \\, \\pi_2(q_2),\n$$\n受限于 $q_1 \\ge 0$ 和 $q_2 \\ge 0$，并且需求上的隐含非负价格条件确保了在时期 $t$ 有 $q_t \\le A_t/B_t$，其中时期2使用 $A_2^{\\text{eff}}(q_1)$ 代替 $A_2$。\n\n推导和计算的基本依据：\n- 在线性需求下，垄断者在时期 $t$ 的静态利润最大化，对于给定的截距 $A$、斜率 $B$ 和成本 $c$，其一阶条件会导出经过充分检验的结果 $q^\\star = \\max\\{0,\\, (A - c)/(2B)\\}$ 和 $p^\\star = (A + c)/2$，前提是 $A  c$。\n- 未来收益的贴现通过将时期2的利润乘以 $\\beta$ 来建模。\n\n计算任务：\n- 以纯数学术语进行。你必须通过逆向归纳法计算子博弈完美结果：对于任何固定的 $q_1$，时期2的垄断者在给定 $A_2^{\\text{eff}}(q_1)$ 的情况下最优地选择 $q_2$；预见到这一点，公司选择 $q_1$ 以最大化总贴现利润。\n- 假设公司不能以负价格销售，因此 $q_1 \\in [0,\\, A_1/B_1]$，而在时期2，当 $A_2^{\\text{eff}}(q_1)  0$ 时，$q_2 \\in [0,\\, A_2^{\\text{eff}}(q_1)/B_2]$；否则 $q_2 = 0$。\n- 对于下面的每个测试用例，计算唯一的利润最大化对 $(q_1^\\star, q_2^\\star)$，以及相应的均衡价格 $p_1^\\star$ 和 $p_2^\\star$，和总贴现利润 $\\Pi^\\star = \\pi_1(q_1^\\star) + \\beta \\pi_2(q_2^\\star)$。所有标量输出必须是实数。\n\n测试套件（每个元组为 $(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta)$）：\n- 用例1：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 20,\\, 0.8,\\, 0.95)$。\n- 用例2：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (100,\\, 1,\\, 120,\\, 1.5,\\, 10,\\, 80,\\, 0.8,\\, 0.95)$。\n- 用例3：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (50,\\, 1,\\, 8,\\, 1.2,\\, 10,\\, 20,\\, 1.0,\\, 0.9)$。\n- 用例4：$(A_1, B_1, A_2, B_2, c, q_{\\text{bar}}, d, \\beta) = (80,\\, 1,\\, 100,\\, 0.5,\\, 20,\\, 15,\\, 3.5,\\, 0.9)$。\n\n输出规格：\n- 对于每个测试用例，输出列表 $[q_1^\\star, q_2^\\star, p_1^\\star, p_2^\\star, \\Pi^\\star]$，其中每个数字四舍五入到6位小数。\n- 你的程序应生成单行输出，其中包含所有用例的结果，形式为这些列表的单一列表，按上述测试套件的顺序排列，格式化为用方括号括起来的逗号分隔列表。\n- 不应从标准输入读取任何输入。所有计算必须在程序内针对给定用例执行，并且只应打印所需的单行输出。", "solution": "该问题要求计算一个垄断者在两个时期内的利润最大化生产数量、价格和总利润，同时考虑品牌稀释效应。该问题定义明确，并在微观经济学理论中有坚实的科学基础。我们将使用逆向归纳法来求解子博弈完美均衡。\n\n垄断者的总利润 $\\Pi$ 是时期1和时期2利润的贴现总和：\n$$ \\Pi(q_1, q_2) = \\pi_1(q_1) + \\beta \\pi_2(q_2) $$\n其中 $\\pi_t(q_t) = (p_t(q_t) - c)q_t$，$p_t(q_t) = A_t - B_t q_t$ 是反需求曲线，$c$ 是不变的边际成本，$\\beta$ 是贴现因子。品牌稀释通过一个有效的时期2需求截距 $A_2^{\\text{eff}}(q_1)$ 来建模，该截距取决于时期1的数量 $q_1$：\n$$ A_2^{\\text{eff}}(q_1) = A_2 - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\} $$\n此处，$d$ 是稀释敏感度，$q_{\\text{bar}}$ 是声望销售阈值。\n\n**步骤1：时期2的优化（逆向归纳）**\n\n在时期2，数量 $q_1$ 已经确定。垄断者面临一个具有给定需求截距 $A_2^{\\text{eff}}(q_1)$ 的静态优化问题。时期2的利润为 $\\pi_2(q_2) = (A_2^{\\text{eff}}(q_1) - B_2 q_2 - c)q_2$。关于 $q_2$ 最大化 $\\pi_2$ 的一阶条件得出了标准的垄断数量：\n$$ q_2^\\star(q_1) = \\max\\left\\{0, \\frac{A_2^{\\text{eff}}(q_1) - c}{2B_2}\\right\\} $$\n由此产生的时期2最大化利润，作为 $q_1$ 的函数，是：\n$$ \\pi_2^\\star(q_1) = \\frac{\\left(\\max\\{0, A_2^{\\text{eff}}(q_1) - c\\}\\right)^2}{4B_2} $$\n\n**步骤2：时期1的优化**\n\n预见到时期2的最优反应，公司在时期1选择 $q_1 \\ge 0$ 以最大化总贴现利润函数，该函数现在仅依赖于 $q_1$：\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\beta \\pi_2^\\star(q_1) $$\n代入 $\\pi_2^\\star(q_1)$ 和 $A_2^{\\text{eff}}(q_1)$ 的表达式：\n$$ \\Pi(q_1) = (A_1 - B_1 q_1 - c)q_1 + \\frac{\\beta}{4B_2} \\left(\\max\\{0, A_2 - c - d \\cdot \\max\\{0, q_1 - q_{\\text{bar}}\\}\\}\\right)^2 $$\n这个目标函数是连续但分段可微的。不可微点（扭结）出现在 $q_1 = q_{\\text{bar}}$，以及可能出现在 $A_2 - c - d(q_1 - q_{\\text{bar}}) = 0$ 的地方，即 $q_1 = q_{\\text{crit}} \\equiv q_{\\text{bar}} + (A_2-c)/d$（对于 $d  0$ 和 $A_2  c$）。函数 $\\Pi(q_1)$ 由最多三个二次分段组成。\n\n**步骤3：寻找全局最大值**\n\n为了找到这个连续分段函数的全局最大值，我们必须在所有候选点上对其进行求值。这些点包括每个平滑段内导数为零的点（驻点）以及扭结本身。最优数量 $q_1^\\star$ 的候选集合构建如下：\n1.  **边界点和扭结点**：点 $q_1=0$（非负约束）、声望阈值 $q_1 = q_{\\text{bar}}$，以及稀释至零利润点 $q_1 = q_{\\text{crit}}$ 都是最优值的潜在候选点。\n2.  **驻点**：我们通过在每个平滑区域内将导数 $\\frac{d\\Pi}{dq_1}$ 设为零来找到驻点。\n    -   对于 $0 \\le q_1  q_{\\text{bar}}$，目标函数简化，驻点是标准的静态垄断数量 $q_{S1} = (A_1-c)/(2B_1)$。\n    -   对于 $q_{\\text{bar}}  q_1  q_{\\text{crit}}$，导数会得到一个不同的驻点，我们称之为 $q_{S2}$：\n        $$ q_{S2} = \\frac{2B_2(A_1 - c) - \\beta d(A_2 - c + dq_{\\text{bar}})}{4B_1B_2 - \\beta d^2} $$\n        这个点仅当它落在其有效区域内，并且分母 $4B_1B_2 - \\beta d^2$ 不为零时，才是一个候选点。如果分母为负，目标函数是局部凸的，该段上的最大值必须位于其边界（$q_{\\text{bar}}$ 或 $q_{\\text{crit}}$）。\n    -   对于 $q_1 > q_{\\text{crit}}$，时期2的利润为零。目标再次是时期1的利润函数，驻点为 $q_{S1}$。\n\n算法方法是汇集所有这些候选点的集合，确保我们包括所有扭结点和所有相关的可行驻点（$q_1 \\ge 0$）。然后我们在每个候选点上评估总利润函数 $\\Pi(q_1)$。产生最高利润的 $q_1$ 值即为最优数量 $q_1^\\star$。\n\n**步骤4：计算最终结果**\n\n一旦确定了最优的 $q_1^\\star$，剩余的均衡值计算如下：\n-   时期1价格：$p_1^\\star = A_1 - B_1 q_1^\\star$。\n-   有效的时期2截距：$A_{2, \\text{eff}}^\\star = A_2 - d \\cdot \\max\\{0, q_1^\\star - q_{\\text{bar}}\\}$。\n-   时期2数量：$q_2^\\star = \\max\\{0, (A_{2, \\text{eff}}^\\star - c) / (2B_2)\\}$。\n-   时期2价格：如果 $q_2^\\star > 0$，则 $p_2^\\star = (A_{2, \\text{eff}}^\\star + c) / 2$。如果 $q_2^\\star = 0$，市场出清价格是窒息价格 $p_2^\\star = A_{2, \\text{eff}}^\\star$。\n-   总贴现利润：$\\Pi^\\star = (p_1^\\star - c)q_1^\\star + \\beta (p_2^\\star - c)q_2^\\star$。\n\n对于给定的问题结构，这个系统性的程序保证能找到唯一的利润最大化结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the two-period monopoly problem with brand dilution for a suite of test cases.\n    \"\"\"\n    test_cases = [\n        # (A1, B1, A2, B2, c, q_bar, d, beta)\n        (100.0, 1.0, 120.0, 1.5, 10.0, 20.0, 0.8, 0.95),\n        (100.0, 1.0, 120.0, 1.5, 10.0, 80.0, 0.8, 0.95),\n        (50.0, 1.0, 8.0, 1.2, 10.0, 20.0, 1.0, 0.9),\n        (80.0, 1.0, 100.0, 0.5, 20.0, 15.0, 3.5, 0.9),\n    ]\n\n    all_results = []\n\n    for params in test_cases:\n        result = _solve_single_case(params)\n        all_results.append([f\"{x:.6f}\" for x in result])\n\n    # Format the final output string as a list of lists.\n    output_str = \"[\" + \",\".join([f\"[{','.join(res)}]\" for res in all_results]) + \"]\"\n    print(output_str)\n\ndef _calculate_total_profit(q1, params):\n    \"\"\"\n    Helper function to calculate total discounted profit for a given q1.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    if q1  0:\n        return -np.inf\n\n    # Period 1 profit\n    pi1 = (A1 - B1 * q1 - c) * q1\n    \n    # Period 2 effective demand intercept\n    A2_eff = A2 - d * max(0, q1 - q_bar)\n\n    # Optimal period 2 profit\n    pi2_opt = 0.0\n    if A2_eff > c:\n        # Standard monopoly profit formula: (A-c)^2 / (4B)\n        pi2_opt = (A2_eff - c)**2 / (4 * B2)\n\n    return pi1 + beta * pi2_opt\n\n\ndef _solve_single_case(params):\n    \"\"\"\n    Solves a single instance of the monopolist problem.\n    \"\"\"\n    A1, B1, A2, B2, c, q_bar, d, beta = params\n\n    # The optimal q1 must be one of the critical points of the piecewise objective function.\n    # We collect all such candidates and evaluate the profit at each.\n    candidates = {0.0, q_bar}\n    \n    # Candidate from static profit maximization in period 1\n    if A1 > c:\n        q_s1 = (A1 - c) / (2 * B1)\n        candidates.add(q_s1)\n\n    # Candidates related to the dilution mechanism\n    if d > 0 and A2 > c:\n        # Kink point where period 2 profit becomes zero due to dilution\n        q_crit = q_bar + (A2 - c) / d\n        candidates.add(q_crit)\n        \n        # Stationary point in the dilution region (q_bar  q1  q_crit)\n        denom = 4 * B1 * B2 - beta * d**2\n        if abs(denom) > 1e-12: # Avoid division by zero\n            num = 2 * B2 * (A1 - c) - beta * d * (A2 - c + d * q_bar)\n            q_s2 = num / denom\n            candidates.add(q_s2)\n\n    max_profit = -np.inf\n    q1_star = 0.0\n\n    # Feasibility limit for q1 (where price becomes zero)\n    q1_max_feasible = A1 / B1 if B1 > 0 else np.inf\n\n    for q1_cand in candidates:\n        # Only consider physically and economically meaningful candidates\n        if q1_cand  0 or q1_cand > q1_max_feasible + 1e-9:\n            continue\n        \n        current_profit = _calculate_total_profit(q1_cand, params)\n        \n        if current_profit > max_profit:\n            max_profit = current_profit\n            q1_star = q1_cand\n\n    # Calculate final equilibrium values based on the optimal q1_star\n    p1_star = A1 - B1 * q1_star\n    A2_eff_star = A2 - d * max(0, q1_star - q_bar)\n    \n    if A2_eff_star > c:\n        q2_star = (A2_eff_star - c) / (2 * B2)\n        p2_star = (A2_eff_star + c) / 2\n    else:\n        q2_star = 0.0\n        # If no production, the market clearing price is the choke price\n        p2_star = A2_eff_star\n\n    # Recalculate final total profit for precision\n    pi1_star = (p1_star - c) * q1_star\n    pi2_star = (p2_star - c) * q2_star\n    Pi_star = pi1_star + beta * pi2_star\n\n    return [q1_star, q2_star, p1_star, p2_star, Pi_star]\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2422445"}, {"introduction": "最后，我们将从解析解法转向模拟方法。在现实世界中，企业往往不完全了解竞争对手的行为模式，而是通过反复试验来调整策略。本练习将模拟在古诺双头垄断市场中，企业如何利用强化学习算法，根据历史盈利情况来调整产量，这为我们研究有限理性下的市场动态提供了强大的计算工具。[@problem_id:2422430]", "problem": "考虑一个具有反需求和恒定边际成本的同质商品 Cournot 双寡头垄断模型。时间是离散的。在每个时期，两家公司同时选择非负产量，并从实现的市场价格中获得利润。两家公司都不知道对手的行为。相反，每家公司都通过仅根据实现的利润更新与每个可行产量水平相关的内部价值，来随时间调整自己的产量。\n\n模型基本要素和时序如下。\n\n1. 市场环境。\n- 每个时期 $t$ 的反需求由 $p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$ 给出，其中 $a \\gt 0$，$b \\gt 0$，$q_{i,t} \\ge 0$ 是公司 $i$ 在时期 $t$ 的产量。\n- 公司 $i$ 的边际成本为恒定的 $c_i \\ge 0$，因此其在时期 $t$ 的利润为 $\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$。\n\n2. 行动空间离散化。\n- 固定一个容量 $Q_{\\max} \\gt 0$ 和一个整数网格大小 $M \\ge 2$。每个公司的可行行动集是大小为 $M$ 的网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$，其中 $\\Delta = Q_{\\max}/(M-1)$。\n\n3. 学习动态。\n- 每个公司 $i \\in \\{1,2\\}$ 维护一个行动价值向量 $Q_i \\in \\mathbb{R}^M$，其所有索引 $m \\in \\{0,1,\\dots,M-1\\}$ 的值都初始化为 $Q_i[m] = 0$。\n- 对于每个时期 $t \\in \\{1,2,\\dots,T\\}$：\n    - 每个公司使用带有温度参数 $\\tau \\gt 0$ 的 softmax 选择规则独立地抽取其行动：\n    $$\\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp\\!\\left(Q_i[m]/\\tau\\right)}{\\sum_{j=0}^{M-1} \\exp\\!\\left(Q_i[j]/\\tau\\right)}, \\quad m \\in \\{0,1,\\dots,M-1\\}.$$\n    - 如果 $a_{i,t} = m$，则对应的产量为 $q_{i,t} = m\\Delta$。\n    - 市场价格 $p_t$ 和利润 $\\pi_{i,t}$ 从需求和成本基本要素中实现。\n    - 每个公司仅使用带有学习率 $\\alpha \\in (0,1]$ 的近因加权规则更新其所执行行动的价值：\n    $$Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t}.$$\n    - $Q_i$ 的所有其他分量在该时期内保持不变。\n- 所有随机抽取都将由一个带有指定整数种子的伪随机数生成器生成，以确保可复现性。\n\n4. 性能度量。\n- 在 $T$ 个时期后，为每个公司计算最后 $W$ 个时期的平均产量：\n$$\\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t}, \\quad i \\in \\{1,2\\},$$\n其中 $W \\in \\{1,2,\\dots,T\\}$ 是给定的。对于每个参数集，要求的输出是两个平均值 $(\\overline{q_1}, \\overline{q_2})$。\n\n实现要求。\n\n- 使用上述的精确动态。使用所述的精确 softmax 选择概率和精确价值更新规则。对所有 $t$ 使用 $p_t = \\max\\{0, a - b(q_{1,t}+q_{2,t})\\}$。\n- 对每个测试用例使用指定的伪随机数生成器种子进行所有行动抽取，并在每个测试用例开始时将生成器重新初始化为该种子。\n- 对于每个测试用例，报告对值 $(\\overline{q_1}, \\overline{q_2})$，四舍五入到4位小数。\n\n测试套件。\n\n对于下面的每一行，元组为 $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$。\n\n- A例（对称，内部基准）：$(100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023)$。\n- B例（非对称成本）：$(100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024)$。\n- C例（近边界高成本）：$(50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025)$。\n- D例（紧容量）：$(60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026)$。\n\n最终输出格式。\n\n- 您的程序应生成单行输出，其中包含 A-D 例的结果，格式为一个长度为 4 的逗号分隔列表，其中每个元素本身是一个双元素列表 $[\\overline{q_1}, \\overline{q_2}]$。该行必须是一个单一的 Python 风格列表字面量，每个平均值四舍五入到 4 位小数，例如：\n$[[x_{A,1}, x_{A,2}],[x_{B,1}, x_{B,2}],[x_{C,1}, x_{C,2}],[x_{D,1}, x_{D,2}]]$.", "solution": "问题陈述接受验证。\n\n### 第 1 步：提取已知条件\n\n- **市场模型**：同质商品 Cournot 双寡头垄断。\n- **反需求函数**：$p_t = \\max\\{0, a - b(q_{1,t} + q_{2,t})\\}$，参数为 $a  0$，$b  0$。\n- **公司产量**：$q_{i,t} \\ge 0$ 为公司 $i \\in \\{1,2\\}$ 在时期 $t$ 的产量。\n- **成本结构**：公司 $i$ 的边际成本为恒定的 $c_i \\ge 0$。\n- **利润函数**：$\\pi_{i,t} = (p_t - c_i)\\,q_{i,t}$。\n- **行动空间**：一个大小为 $M \\ge 2$ 的离散网格 $\\mathcal{A} = \\{0, \\Delta, 2\\Delta, \\dots, Q_{\\max}\\}$，其中 $Q_{\\max}  0$ 是容量限制，$\\Delta = Q_{\\max}/(M-1)$。\n- **学习模型**：每个公司 $i$ 维护一个行动价值向量 $Q_i \\in \\mathbb{R}^M$。\n- **初始化**：在 $t=0$ 时，对所有 $m \\in \\{0, \\dots, M-1\\}$，$Q_i[m] = 0$。\n- **模拟时域**：$t \\in \\{1, 2, \\dots, T\\}$。\n- **行动选择**：使用温度参数 $\\tau  0$ 的 Softmax 选择规则：\n$$ \\mathbb{P}\\{a_{i,t} = m\\} = \\frac{\\exp(Q_i[m]/\\tau)}{\\sum_{j=0}^{M-1} \\exp(Q_i[j]/\\tau)} $$\n- **行动产生的产量**：如果行动 $a_{i,t} = m$，则产量 $q_{i,t} = m\\Delta$。\n- **价值更新规则**：使用学习率 $\\alpha \\in (0,1]$ 的近因加权平均：\n$$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha)\\,Q_i[a_{i,t}] + \\alpha\\,\\pi_{i,t} $$\n仅更新所选行动的价值。\n- **可复现性**：所有随机抽取必须来自一个为每个测试用例指定整数种子的伪随机数生成器。\n- **性能度量**：最后 $W$ 个时期的平均产量，其中 $W \\in \\{1, \\dots, T\\}$：\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{t=T-W+1}^{T} q_{i,t} $$\n- **测试用例**：提供了四组参数 $(a, b, c_1, c_2, Q_{\\max}, M, \\alpha, \\tau, T, W, \\text{seed})$。\n- **输出格式**：最终结果是每个用例的一对 $(\\overline{q_1}, \\overline{q_2})$ 的列表，四舍五入到 4 位小数，格式化为 Python 风格的列表的列表。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n- **科学依据**：该问题描述了一个 Cournot 双寡头垄断模型，其中公司使用标准的强化学习算法（与 Q-learning 和指数权重相关）来调整其策略。这是计算经济学和博弈论中一个公认且科学有效的主题。该模型没有违反任何基本原则。\n- **适定性**：该问题指定了一个完整的计算过程。所有参数、初始条件和动态规则都已明确定义。对每个用例使用带有固定种子的伪随机数生成器可确保模拟是确定性的并产生唯一结果。因此，该问题是适定的。\n- **客观性**：该问题使用精确的数学和算法语言陈述，没有任何主观或模糊的术语。\n\n问题陈述通过了所有验证标准。它在科学上是合理的、适定的、客观的、完整的且计算上可行的。没有矛盾或谬误。\n\n### 第 3 步：结论与行动\n\n问题是 **有效的**。将提供一个解决方案。\n\n### 算法解决方案\n\n该问题要求实现一个双公司（双寡头）Cournot 市场竞争的模拟。两家公司都作为随时间学习的自主代理行动。解决方案涉及构建一个进行 $T$ 个时期的离散时间模拟。对于每个测试用例，必须使用指定的参数重新初始化模拟。\n\n解决方案的核心是一个从 $t=1$ 到 $T$ 的迭代循环。对于每次模拟，必须初始化以下对象：\n\n1.  一个使用指定 `seed` 的伪随机数生成器（RNG）。这对可复现性至关重要。\n2.  离散行动空间 $\\mathcal{A}$，这是一个从 $0$ 到 $Q_{\\max}$ 的 $M$ 个等间距产量水平的网格。让它由一个长度为 $M$ 的向量 `actions` 表示，其中 `actions`$[m] = m \\cdot \\Delta$。\n3.  两个行动价值向量 $Q_1$ 和 $Q_2$，大小均为 $M$，初始化为全零。\n4.  两个历史向量 `q1_history` 和 `q2_history`，长度为 $T$，用于存储每个时期选择的产量。\n\n在每个时期 $t$ 的主循环内部：\n\n1.  **行动选择**：对于每个公司 $i \\in \\{1,2\\}$，必须选择一个行动。这是一个两步过程：\n    a.  计算每个行动 $m \\in \\{0, \\dots, M-1\\}$ 的 softmax 概率，使用当前的行动价值向量 $Q_i$ 和温度参数 $\\tau$。为确保数值稳定性，标准做法是在应用指数函数之前，从向量 $Q_i/\\tau$ 的所有元素中减去其最大值。然后概率 $P_i$ 由以下公式给出：\n    $$ v_m = Q_i[m]/\\tau $$\n    $$ P_i[m] = \\frac{\\exp(v_m - \\max(v))}{\\sum_{j=0}^{M-1} \\exp(v_j - \\max(v))} $$\n    b.  使用 RNG 根据概率分布 $P_i$ 抽取一个行动索引 $a_{i,t} \\in \\{0, \\dots, M-1\\}$。\n\n2.  **市场交互**：一旦两家公司都选择了它们的行动 $a_{1,t}$ 和 $a_{2,t}$，它们各自的产量就确定了：\n    $$ q_{i,t} = \\text{actions}[a_{i,t}] $$\n    这些产量被存储在历史向量中。市场总产量为 $Q_{\\text{total}, t} = q_{1,t} + q_{2,t}$。市场价格随后根据反需求函数实现：\n    $$ p_t = \\max\\{0, a - b \\cdot Q_{\\text{total}, t}\\} $$\n\n3.  **利润计算**：计算每个公司在该时期的利润：\n    $$ \\pi_{i,t} = (p_t - c_i) \\cdot q_{i,t} $$\n\n4.  **价值更新**：每个公司更新与其刚刚执行的行动相关的价值。对于每个公司 $i$，更新规则应用于单个元素 $Q_i[a_{i,t}]$：\n    $$ Q_i[a_{i,t}] \\leftarrow (1 - \\alpha) \\cdot Q_i[a_{i,t}] + \\alpha \\cdot \\pi_{i,t} $$\n\n在 $T$ 个时期的模拟循环完成后，计算性能度量。对于每个公司 $i$，使用存储的 `q_history` 向量计算模拟最后 $W$ 个时期的平均产量 $\\overline{q_i}$。\n\n$$ \\overline{q_i} = \\frac{1}{W} \\sum_{k=T-W}^{T-1} \\text{q\\_history}_i[k] $$\n这两个平均值 $(\\overline{q_1}, \\overline{q_2})$ 四舍五入到 4 位小数。对提供的四个测试用例中的每一个重复此整个过程。最终输出是所有用例结果的聚合，格式为指定的列表的列表格式。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Cournot duopoly learning simulation for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Case A (symmetric, interior benchmark)\n        (100.0, 1.0, 10.0, 10.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2023),\n        # Case B (asymmetric costs)\n        (100.0, 1.0, 10.0, 40.0, 100.0, 51, 0.10, 1.00, 20000, 5000, 2024),\n        # Case C (near-boundary high costs)\n        (50.0, 1.5, 45.0, 45.0, 60.0, 61, 0.15, 0.80, 20000, 5000, 2025),\n        # Case D (tight capacity)\n        (60.0, 2.0, 5.0, 5.0, 10.0, 21, 0.10, 0.70, 20000, 5000, 2026),\n    ]\n\n    all_results = []\n\n    for case in test_cases:\n        a, b, c1, c2, Q_max, M, alpha, tau, T, W, seed = case\n\n        # Initialize pseudo-random number generator for reproducibility\n        rng = np.random.default_rng(seed)\n\n        # 1. Setup\n        # Action space\n        delta = Q_max / (M - 1)\n        actions = np.arange(M) * delta\n        action_indices = np.arange(M)\n\n        # Action-value vectors\n        Q1 = np.zeros(M)\n        Q2 = np.zeros(M)\n\n        # History of quantities\n        q1_history = np.zeros(T)\n        q2_history = np.zeros(T)\n\n        # 2. Simulation Loop\n        for t in range(T):\n            # Firm 1 action selection\n            v1 = Q1 / tau\n            # Numerically stable softmax\n            exp_v1 = np.exp(v1 - np.max(v1))\n            probs1 = exp_v1 / np.sum(exp_v1)\n            action_idx1 = rng.choice(action_indices, p=probs1)\n            q1_t = actions[action_idx1]\n\n            # Firm 2 action selection\n            v2 = Q2 / tau\n            exp_v2 = np.exp(v2 - np.max(v2))\n            probs2 = exp_v2 / np.sum(exp_v2)\n            action_idx2 = rng.choice(action_indices, p=probs2)\n            q2_t = actions[action_idx2]\n            \n            # Store quantities\n            q1_history[t] = q1_t\n            q2_history[t] = q2_t\n\n            # Market price\n            p_t = max(0.0, a - b * (q1_t + q2_t))\n\n            # Profits\n            pi1_t = (p_t - c1) * q1_t\n            pi2_t = (p_t - c2) * q2_t\n\n            # Value update\n            Q1[action_idx1] = (1.0 - alpha) * Q1[action_idx1] + alpha * pi1_t\n            Q2[action_idx2] = (1.0 - alpha) * Q2[action_idx2] + alpha * pi2_t\n\n        # 3. Performance Measure\n        avg_q1 = np.mean(q1_history[-W:])\n        avg_q2 = np.mean(q2_history[-W:])\n\n        # Append rounded results\n        result_pair = [round(avg_q1, 4), round(avg_q2, 4)]\n        all_results.append(result_pair)\n\n    # 4. Final Output Formatting\n    # The format is a string representation of a Python list of lists.\n    # str(list) automatically adds spaces after commas, which is fine for a Python literal.\n    # The scaffold f\"[{','.join(map(str, results))}]\" replicates this behavior.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2422430"}]}