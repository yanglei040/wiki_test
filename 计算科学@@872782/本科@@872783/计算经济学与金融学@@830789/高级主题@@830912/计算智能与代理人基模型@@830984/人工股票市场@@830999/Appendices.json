{"hands_on_practices": [{"introduction": "要理解人工市场，核心在于掌握反馈循环的概念。这个入门练习将通过一个虽简化但功能强大的模型来探索这一核心思想，其中市场仅由一群“逆向投资者”构成。你将亲手推导并验证一个市场的稳定性条件，直观地看到一个简单的交易规则——总是与市场近期趋势反向押注——如何根据反馈的强度，既可能带来市场稳定，也可能引发剧烈震荡 [@problem_id:2372768]。", "problem": "考虑一个完全由逆向投资者组成的人工股票市场，这些投资者总是与最近的市场趋势反向交易。市场在离散时间内演化。设 $p_t$ 表示时间 $t$ 的（对数）价格，$r_t$ 表示单步收益率，定义为 $r_t = p_t - p_{t-1}$。假设遵循以下基本原则，这些原则在市场微观结构和基于主体的建模中是标准做法：\n\n- 线性价格影响：价格更新与总超额需求成正比。存在一个常数 $\\kappa > 0$，使得 $p_t = p_{t-1} + \\kappa \\cdot ED_t$，其中 $ED_t$ 是时间 $t$ 的总超额需求。\n- 逆向需求：总超额需求与最近的已实现收益率的负值成正比。存在一个常数 $\\beta > 0$，使得 $ED_t = -\\beta \\cdot r_{t-1}$。\n\n初始条件由 $p_0$ 和 $r_0$ 指定。将 $r_0$ 解释为从 $t=-1$ 到 $t=0$ 的已实现收益率，因此在 $t=1$ 时的首次逆向反应取决于 $r_0$。\n\n对于这个只有逆向投资者的市场，我们将渐进价格稳定性定义为收益率趋于零且价格收敛到一个有限极限，具体来说，即 $\\lim_{t \\to \\infty} r_t = 0$ 并且 $\\lim_{t \\to \\infty} p_t$ 存在且有限。\n\n您的任务如下：\n- 仅使用上述两个基本原则和收益率的定义，从第一性原理推导出该纯逆向市场中参数满足渐进价格稳定性的充要条件。\n- 设计一个算法，在给定 $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$ 的情况下，模拟由基本原则所蕴含的市场动态，并在收益率的绝对值于时间 $T$ 或之前降至容差 $\\varepsilon$ 以下时，宣布市场为渐进价格稳定。这个有限时间范围内的数值标准是为了测试目的而将渐进定义可操作化，并且必须与您推导出的解析条件相一致。\n\n实现一个完整的、可运行的程序，用于评估以下测试套件。每个测试用例是一个元组 $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$：\n\n- 情况 A（一般稳定情况）：$(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.2,\\, 2.5,\\, 0.0,\\, 0.1,\\, 200,\\, 10^{-6}\\,)$。\n- 情况 B（边界条件）：$(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.5,\\, 2.0,\\, 0.0,\\, 0.1,\\, 200,\\, 10^{-6}\\,)$。\n- 情况 C（不稳定情况）：$(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.8,\\, 2.0,\\, 0.0,\\, 0.1,\\, 50,\\, 10^{-6}\\,)$。\n- 情况 D（近边界慢收敛）：$(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.95,\\, 1.0,\\, 0.0,\\, -0.2,\\, 500,\\, 10^{-3}\\,)$。\n- 情况 E（从大初始波动快速收敛）：$(\\kappa, \\beta, p_0, r_0, T, \\varepsilon) = (\\,0.05,\\, 1.0,\\, 0.0,\\, 1.0,\\, 50,\\, 10^{-6}\\,)$。\n\n您的程序必须：\n- 完全按照两个基本原则和收益率的定义来实现模拟，从提供的初始条件开始，迭代直到时间 $T$。\n- 对于每种情况，输出一个布尔值，指示在时间 $T$ 之前（含时间 $T$），绝对收益率 $\\lvert r_t \\rvert$ 是否在某个步骤 $t \\in \\{1, 2, \\dots, T\\}$ 降到了 $\\varepsilon$ 以下，这是对渐进价格稳定性的操作性测试。\n- 生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\,\\text{True},\\text{False},\\dots\\,]$）。不应打印任何额外文本。\n\n注意：所有量都是无单位的。角度不适用。所有容差都应表示为小数（例如，$10^{-6}$），而不是百分比。最终输出是布尔值。该测试套件旨在包括一个一般稳定情况、一个边界情况、一个不稳定情况、一个近边界慢收敛情况以及一个从大初始波动快速收敛的情况。", "solution": "该问题要求在一个纯逆向投资者的人工股票市场中，推导渐进价格稳定性的充要条件，然后设计并实现一个算法来模拟市场并对这种稳定性进行数值检验。\n\n首先，我们从第一性原理推导稳定性条件。该模型由三个方程定义：\n1.  单步收益率 $r_t$ 的定义：$r_t = p_t - p_{t-1}$，其中 $p_t$ 是时间 $t$ 的对数价格。\n2.  线性价格影响法则：$p_t = p_{t-1} + \\kappa \\cdot ED_t$，其中 $\\kappa > 0$ 且 $ED_t$ 是总超额需求。\n3.  逆向需求函数：$ED_t = -\\beta \\cdot r_{t-1}$，其中 $\\beta > 0$。\n\n通过结合这些原则，我们可以为收益率序列 $r_t$ 建立一个递推关系。从前两个方程可以清楚地看出，收益率 $r_t$ 与超额需求成正比：\n$$r_t = p_t - p_{t-1} = \\kappa \\cdot ED_t$$\n现在，我们将逆向需求 $ED_t$ 的表达式代入这个关系中：\n$$r_t = \\kappa \\cdot (-\\beta \\cdot r_{t-1})$$\n这可以简化为关于收益率的一阶线性齐次差分方程：\n$$r_t = -(\\kappa\\beta) \\cdot r_{t-1}$$\n这是一个等比数列。给定初始收益率 $r_0$（即从 $t=-1$ 到 $t=0$ 的收益率），我们可以写出 $r_t$ 的通解为：\n$$r_t = (-\\kappa\\beta)^t \\cdot r_0$$\n问题将渐进价格稳定性定义为两个条件：\n1.  收益率必须趋于零：$\\lim_{t \\to \\infty} r_t = 0$。\n2.  价格必须收敛到一个有限极限：$\\lim_{t \\to \\infty} p_t$ 存在且有限。\n\n我们分析这两个条件。对于第一个条件，$\\lim_{t \\to \\infty} r_t = \\lim_{t \\to \\infty} (-\\kappa\\beta)^t \\cdot r_0 = 0$。对于任何非零初始收益率 $r_0 \\neq 0$，该极限成立的充要条件是公比的绝对值小于 1：\n$$|-\\kappa\\beta|  1$$\n由于参数 $\\kappa$ 和 $\\beta$ 被给定为正常数（$\\kappa > 0$, $\\beta > 0$），它们的乘积 $\\kappa\\beta$ 也是正的。因此，条件简化为：\n$$\\kappa\\beta  1$$\n\n对于第二个条件，我们分析价格 $p_t$ 的收敛性。时间 $t$ 的价格可以表示为初始价格 $p_0$ 加上所有后续收益率的总和：\n$$p_t = p_0 + \\sum_{i=1}^{t} r_i = p_0 + \\sum_{i=1}^{t} (-\\kappa\\beta)^i \\cdot r_0$$\n当 $t \\to \\infty$ 时价格的极限是：\n$$\\lim_{t \\to \\infty} p_t = p_0 + r_0 \\sum_{i=1}^{\\infty} (-\\kappa\\beta)^i$$\n这是一个公比为 $c = -\\kappa\\beta$ 的几何级数。该级数收敛到一个有限和的充要条件是 $|c|  1$，这与为收益率推导出的条件完全相同：\n$$|-\\kappa\\beta|  1 \\implies \\kappa\\beta  1$$\n当此条件成立时，价格收敛到有限值 $p_{\\infty} = p_0 + r_0 \\left( \\frac{-\\kappa\\beta}{1 - (-\\kappa\\beta)} \\right) = p_0 - r_0 \\frac{\\kappa\\beta}{1 + \\kappa\\beta}$。\n\n渐进价格稳定性的两个条件都导出了相同的要求。因此，该市场中渐进价格稳定性的充要条件是 $\\kappa\\beta  1$。\n\n接下来，我们设计一个算法，在一个有限的时间范围内数值评估这个稳定性条件。任务是确定收益率的绝对值 $|r_t|$ 是否在 $\\{1, 2, \\dots, T\\}$ 范围内的任何时间步长 $t$ 降至容差 $\\varepsilon$ 以下。这可以通过模拟上面推导出的收益率动态来实现。\n对于每个测试用例 $(\\kappa, \\beta, p_0, r_0, T, \\varepsilon)$，算法流程如下：\n1.  初始化一个布尔标志 `is_stable` 为 `False`。\n2.  用 $r_0$ 的值初始化当前收益率 `current_r`。\n3.  计算递推关系的常数乘法因子 $c = -\\kappa\\beta$。\n4.  对 $t$ 从 $1$ 到 $T$ 进行迭代。在每一步中：\n    a. 更新收益率：`current_r` 变为 $c \\cdot \\text{current\\_r}$。这对应于计算 $r_t$。\n    b. 检查稳定性标准：如果 $| \\text{current\\_r} |  \\varepsilon$，则将 `is_stable` 设置为 `True` 并终止此测试用例的循环，因为条件已满足。\n5.  循环结束后（无论是正常完成还是提前终止），`is_stable` 的值就是给定测试用例的结果。该算法通过检查收益率的衰减是否足够快以在指定的时间范围内满足容差，从而正确地将稳定性定义可操作化。价格 $p_t$ 无需模拟，因为它不属于数值测试标准的一部分。\n这为所需的程序提供了一个完整的计划。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating a contrarian agent-based market model\n    for several test cases and checking for numerical stability.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (kappa, beta, p_0, r_0, T, epsilon)\n    test_cases = [\n        (0.2, 2.5, 0.0, 0.1, 200, 1e-6),   # Case A: Stable (kappa*beta = 0.5  1)\n        (0.5, 2.0, 0.0, 0.1, 200, 1e-6),   # Case B: Boundary (kappa*beta = 1.0)\n        (0.8, 2.0, 0.0, 0.1, 50, 1e-6),    # Case C: Unstable (kappa*beta = 1.6 > 1)\n        (0.95, 1.0, 0.0, -0.2, 500, 1e-3), # Case D: Near-boundary, slow convergence\n        (0.05, 1.0, 0.0, 1.0, 50, 1e-6),    # Case E: Fast convergence\n    ]\n\n    results = []\n    for case in test_cases:\n        kappa, beta, p0, r0, T, epsilon = case\n        \n        # This boolean will store the outcome for the current test case.\n        # It is initialized to False, assuming instability unless proven otherwise.\n        is_stable_numerically = False\n        \n        # The initial return r_0 is for the time step from t=-1 to t=0.\n        # The simulation starts by calculating r_1.\n        current_r = r0\n        \n        # The constant factor in the recurrence relation r_t = factor * r_{t-1}\n        # is derived from the model's foundational principles.\n        factor = -kappa * beta\n\n        # The problem asks to check for stability at any step t in {1, 2, ..., T}.\n        # The loop simulates the returns from t=1 to t=T.\n        for t in range(1, T + 1):\n            # Calculate the next return in the sequence: r_t = factor * r_{t-1}\n            current_r = factor * current_r\n            \n            # Check the operational stability criterion.\n            # If the absolute value of the return falls below the tolerance,\n            # the market is considered stable for this test.\n            if np.abs(current_r)  epsilon:\n                is_stable_numerically = True\n                # Stability is detected, no need for further simulation for this case.\n                break\n        \n        results.append(is_stable_numerically)\n\n    # Final print statement in the exact required format.\n    # The output is a comma-separated list of booleans enclosed in square brackets.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372768"}, {"introduction": "在反馈循环的基础上，下一个实践将构建一个更经典、更贴近现实的人工股票市场。在这个市场中，我们将不再局限于单一类型的交易者，而是引入两种相互竞争的策略：“基本面投资者”，他们相信资产存在一个“公允价值”；以及“技术分析者”，他们追随价格趋势。我们将允许交易者根据近期盈利表现动态切换策略，从而让你见证复杂的、类似真实世界的市场动态（如泡沫和崩溃）是如何从简单的个体互动中涌现出来的 [@problem_id:2372798]。", "problem": "构建一个人工股票市场 (ASM)，其中包含两种代表性策略：“基本面派”和“技术分析派”，时间是离散的，由 $t \\in \\{0,1,\\dots,T\\}$ 索引。设资产价格为 $p_t \\in \\mathbb{R}$，恒定的基本价值为 $v \\in \\mathbb{R}$。在时间 $t$ 使用基本面派和技术分析派策略的交易者比例分别为 $w^F_t \\in [0,1]$ 和 $w^C_t \\in [0,1]$，对于所有 $t$ 满足 $w^F_t + w^C_t = 1$。令 $p_{-1} = p_0$。\n\n在时间 $t$ 的个体（标准化）需求由以下公式给出：\n- 基本面派需求：$d^F_t = \\beta_F \\left( v - p_t \\right)$。\n- 技术分析派（趋势追随）需求：$d^C_t = \\beta_C \\left( p_t - p_{t-1} \\right)$。\n\n总超额需求为 $ED_t = w^F_t d^F_t + w^C_t d^C_t$。做市商根据以下公式调整价格：\n$$\np_{t+1} = p_t + \\alpha \\, ED_t,\n$$\n其中 $\\alpha \\in \\mathbb{R}_{\\ge 0}$ 是价格影响参数。\n\n将策略 $s \\in \\{F,C\\}$ 在时间 $t$ 实现的单期利润定义为：\n$$\n\\pi^s_t = d^s_t \\left(p_{t+1} - p_t\\right) - \\frac{c}{2} \\left(d^s_t\\right)^2,\n$$\n其中 $c \\in \\mathbb{R}_{\\ge 0}$ 是一个交易成本参数。设 $U^s_t$ 为策略 $s$ 在时间 $t$ 的表现得分，初始化为 $U^F_0 = 0$ 和 $U^C_0 = 0$，并通过指数平滑法更新得分：\n$$\nU^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\, \\pi^s_t,\n$$\n其中平滑参数为 $\\delta \\in (0,1]$。\n\n交易者根据多项 logit（离散选择）规则转换策略，选择强度为 $\\gamma \\in \\mathbb{R}_{\\ge 0}$：\n$$\nw^F_{t+1} = \\frac{\\exp\\left(\\gamma U^F_{t+1}\\right)}{\\exp\\left(\\gamma U^F_{t+1}\\right) + \\exp\\left(\\gamma U^C_{t+1}\\right)}, \\quad\nw^C_{t+1} = 1 - w^F_{t+1}.\n$$\n\n对于每次模拟，定义收益序列 $r_t = p_t - p_{t-1}$（对于 $t \\in \\{1,\\dots,T\\}$）及其波动率（标准差）为：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} \\left( r_t - \\bar{r} \\right)^2},\n$$\n其中 $\\bar{r} = \\frac{1}{T} \\sum_{t=1}^{T} r_t$。\n\n你的任务是精确地实现上述模型，并为下面测试套件中的每一组参数计算由以下各项组成的元组：\n- 最终价格 $p_T$，\n- 最终技术分析派比例 $w^C_T$，\n- 波动率 $\\sigma$。\n\n所有初始条件为 $p_{-1} = p_0$, $U^F_0 = 0$, $U^C_0 = 0$，初始权重 $w^F_0$ 在每个测试用例中给出（其中 $w^C_0 = 1 - w^F_0$）。所有输出都必须是实数。\n\n测试套件（按所列顺序，精确使用这四组参数）：\n- 案例 1：$T = 50$, $v = 1.0$, $p_0 = 0.8$, $\\alpha = 0.4$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 0.5$。\n- 案例 2：$T = 50$, $v = 1.0$, $p_0 = 0.2$, $\\alpha = 0.5$, $\\beta_F = 1.0$, $\\beta_C = 0.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 2.0$, $w^F_0 = 1.0$。\n- 案例 3：$T = 30$, $v = 1.0$, $p_0 = 0.5$, $\\alpha = 0.0$, $\\beta_F = 1.0$, $\\beta_C = 1.0$, $c = 0.1$, $\\delta = 0.5$, $\\gamma = 3.0$, $w^F_0 = 0.5$。\n- 案例 4：$T = 80$, $v = 1.0$, $p_0 = 1.2$, $\\alpha = 0.3$, $\\beta_F = 0.8$, $\\beta_C = 1.2$, $c = 0.05$, $\\delta = 0.3$, $\\gamma = 5.0$, $w^F_0 = 0.5$。\n\n最终输出格式：你的程序应产生单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。对于每个案例 $i \\in \\{1,2,3,4\\}$，按顺序附加三个数字 $(p_T, w^C_T, \\sigma)$。因此，最终输出必须是 $[p_T^{(1)}, w^{C,(1)}_T, \\sigma^{(1)}, p_T^{(2)}, w^{C,(2)}_T, \\sigma^{(2)}, p_T^{(3)}, w^{C,(3)}_T, \\sigma^{(3)}, p_T^{(4)}, w^{C,(4)}_T, \\sigma^{(4)}]$ 的形式。\n\n所有数值答案都是无单位的实数，必须以原始小数值报告。不涉及角度或物理单位。不得包含百分号；将 $[0,1]$ 范围内的分数表示为小数。", "solution": "问题陈述已经过严格评估，并被确定为有效。它构成了计算经济学领域中的一个适定问题，特别是关于人工股票市场（ASM）的模拟。该模型是基于已建立的 Brock-Hommes 框架的离散时间动力系统。获得唯一数值解所需的所有模型方程、参数和初始条件都已明确给出。该问题具有科学依据、内部一致且客观。我现在将开始构建解决方案。\n\n该模型是一个耦合的非线性差分方程组。在任意给定时间 $t$ 系统的状态可以由变量向量 $(p_t, p_{t-1}, U^F_t, U^C_t, w^F_t)$ 指定。给定时间 $t$ 的状态，时间 $t+1$ 的状态是唯一确定的。因此，求解方法是直接进行数值模拟，从时间 $t=0$ 向前步进到 $T$。\n\n我们来定义状态变量及其初始化：\n- 价格历史：一个数组，用于存储 $p_t$（对于 $t \\in \\{0, 1, \\dots, T\\}$）。给定 $p_0$ 和条件 $p_{-1} = p_0$。\n- 基本面派比例历史：一个用于存储 $w^F_t$ 的数组。给定 $w^F_0$。\n- 表现得分历史：用于存储 $U^F_t$ 和 $U^C_t$ 的数组。给定初始条件 $U^F_0 = 0$ 和 $U^C_0 = 0$。\n\n模拟通过从 $t=0$ 到 $T-1$ 的循环进行。在每次迭代 $t$ 中，我们基于时间 $t$（以及价格的时间 $t-1$）的状态计算时间 $t+1$ 的状态。操作顺序如下：\n\n1.  **计算个体需求**：在时间 $t$，确定两类交易者的需求。\n    - 基本面派需求取决于当前价格 $p_t$ 与基本价值 $v$ 的偏差：\n    $$\n    d^F_t = \\beta_F (v - p_t)\n    $$\n    - 技术分析派需求基于最近的价格趋势 $(p_t - p_{t-1})$：\n    $$\n    d^C_t = \\beta_C (p_t - p_{t-1})\n    $$\n    对于初始步骤 $t=0$，我们使用条件 $p_{-1} = p_0$，这导致 $d^C_0 = 0$。\n\n2.  **计算总超额需求**：总超额需求 $ED_t$ 是个体需求的加权平均，权重为时间 $t$ 的人口比例 $w^F_t$ 和 $w^C_t = 1 - w^F_t$：\n    $$\n    ED_t = w^F_t d^F_t + w^C_t d^C_t\n    $$\n\n3.  **更新价格**：做市商按与超额需求成比例的方式调整价格，该比例由价格影响参数 $\\alpha$ 控制：\n    $$\n    p_{t+1} = p_t + \\alpha ED_t\n    $$\n\n4.  **计算已实现利润**：一旦下一期的价格 $p_{t+1}$ 被确定，每种策略 $s \\in \\{F,C\\}$ 的单期利润 $\\pi^s_t$ 就可以被计算。利润由所持头寸的资本利得减去二次交易成本组成：\n    $$\n    \\pi^s_t = d^s_t (p_{t+1} - p_t) - \\frac{c}{2} (d^s_t)^2\n    $$\n    注意，价格变化项可以代换为 $(p_{t+1} - p_t) = \\alpha ED_t$。\n\n5.  **更新表现得分**：表现得分 $U^s_t$ 代表了每种策略的感知适应度，它使用过去利润的指数平滑平均值进行更新。参数 $\\delta$ 控制交易者的“记忆”：\n    $$\n    U^s_{t+1} = (1 - \\delta) U^s_t + \\delta \\pi^s_t\n    $$\n\n6.  **更新策略比例**：交易者根据更新后的表现得分为下一期重新评估其策略选择。在时间 $t+1$ 选择基本面派策略的交易者比例由离散选择（多项 logit）概率给出，其中 $\\gamma$ 是选择强度参数：\n    $$\n    w^F_{t+1} = \\frac{\\exp(\\gamma U^F_{t+1})}{\\exp(\\gamma U^F_{t+1}) + \\exp(\\gamma U^C_{t+1})} = \\frac{1}{1 + \\exp\\left(\\gamma (U^C_{t+1} - U^F_{t+1})\\right)}\n    $$\n    第二种形式在数值稳定性上更可取，因为当指数为大的正数时，它能减轻浮点溢出的风险。技术分析派的比例则简单地是 $w^C_{t+1} = 1 - w^F_{t+1}$。\n\n这个循环运行 $T$ 次迭代，生成所有状态变量直到时间 $T$ 的时间序列。\n\n模拟完成后，计算最终的输出量：\n- 最终价格是 $p_T$。\n- 最终技术分析派比例是 $w^C_T = 1 - w^F_T$。\n- 波动率 $\\sigma$ 是根据收益率的时间序列 $r_t = p_t - p_{t-1}$（对于 $t \\in \\{1, \\dots, T\\}$）计算的。这涉及到计算平均收益率 $\\bar{r}$ 然后计算收益率的总体标准差：\n$$\n\\sigma = \\sqrt{\\frac{1}{T} \\sum_{t=1}^{T} (r_t - \\bar{r})^2}\n$$\n将对四个指定的参数组中的每一个实施此程序，以产生最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(T, v, p0, alpha, beta_F, beta_C, c, delta, gamma, wF0):\n    \"\"\"\n    Simulates the Artificial Stock Market model for a given set of parameters.\n    \"\"\"\n    # Initialize arrays to store time series data\n    p = np.zeros(T + 1)\n    wF = np.zeros(T + 1)\n    UF = np.zeros(T + 1)\n    UC = np.zeros(T + 1)\n\n    # Set initial conditions at t=0\n    p[0] = p0\n    wF[0] = wF0\n    # UF[0] and UC[0] are initialized to 0 by np.zeros\n\n    # Main simulation loop from t=0 to T-1\n    for t in range(T):\n        # Retrieve current state variables for time t\n        p_t = p[t]\n        p_tm1 = p[t-1] if t > 0 else p[0]  # Condition: p_{-1} = p_0\n\n        wF_t = wF[t]\n        wC_t = 1.0 - wF_t\n        \n        UF_t = UF[t]\n        UC_t = UC[t]\n        \n        # Step 1: Calculate individual demands\n        dF_t = beta_F * (v - p_t)\n        dC_t = beta_C * (p_t - p_tm1)\n        \n        # Step 2: Calculate aggregate excess demand\n        ED_t = wF_t * dF_t + wC_t * dC_t\n        \n        # Step 3: Update price\n        p_tp1 = p_t + alpha * ED_t\n        p[t+1] = p_tp1\n        \n        # Step 4: Calculate realized profits\n        price_change = p_tp1 - p_t\n        profitF_t = dF_t * price_change - (c / 2.0) * dF_t**2\n        profitC_t = dC_t * price_change - (c / 2.0) * dC_t**2\n        \n        # Step 5: Update performance scores\n        UF_tp1 = (1.0 - delta) * UF_t + delta * profitF_t\n        UC_tp1 = (1.0 - delta) * UC_t + delta * profitC_t\n        UF[t+1] = UF_tp1\n        UC[t+1] = UC_tp1\n        \n        # Step 6: Update strategy fractions (with numerical stability)\n        diff_U = gamma * (UC_tp1 - UF_tp1)\n        \n        # Handle potential overflow in np.exp()\n        if diff_U > 700:\n            wF_tp1 = 0.0\n        else:\n            wF_tp1 = 1.0 / (1.0 + np.exp(diff_U))\n        \n        wF[t+1] = wF_tp1\n\n    # After the loop, calculate final results\n    p_T = p[T]\n    wF_T = wF[T]\n    wC_T = 1.0 - wF_T\n    \n    # Calculate volatility of returns\n    if T > 0:\n        returns = p[1:] - p[:-1]\n        sigma = np.std(returns)\n    else:  # Edge case where T=0, though not in test suite\n        sigma = 0.0\n\n    return p_T, wC_T, sigma\n\ndef solve():\n    \"\"\"\n    Runs the simulations for all test cases and prints the formatted output.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'T': 50, 'v': 1.0, 'p0': 0.8, 'alpha': 0.4, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 0.5},\n        # Case 2\n        {'T': 50, 'v': 1.0, 'p0': 0.2, 'alpha': 0.5, 'beta_F': 1.0, 'beta_C': 0.0, 'c': 0.1, 'delta': 0.5, 'gamma': 2.0, 'wF0': 1.0},\n        # Case 3\n        {'T': 30, 'v': 1.0, 'p0': 0.5, 'alpha': 0.0, 'beta_F': 1.0, 'beta_C': 1.0, 'c': 0.1, 'delta': 0.5, 'gamma': 3.0, 'wF0': 0.5},\n        # Case 4\n        {'T': 80, 'v': 1.0, 'p0': 1.2, 'alpha': 0.3, 'beta_F': 0.8, 'beta_C': 1.2, 'c': 0.05, 'delta': 0.3, 'gamma': 5.0, 'wF0': 0.5},\n    ]\n\n    results = []\n    for params in test_cases:\n        p_T, wC_T, sigma = run_simulation(**params)\n        results.extend([p_T, wC_T, sigma])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2372798"}, {"introduction": "人工股票市场不仅用于研究宏观市场动态，也是检验具体人类行为假说的有力工具。最后的这个练习将聚焦于建模“处置效应”，这是一个在行为金融学中有据可查的认知偏差，即投资者倾向于过早卖出盈利的股票，而过久地持有亏损的股票。通过蒙特卡洛模拟，你将学习如何量化这种行为，并通过改变模型参数来亲眼观察其对交易决策的影响 [@problem_id:2372828]。", "problem": "您将构建一个最小化的人工股票市场（ASM），该市场通过使卖出概率取决于当前持有的头寸是处于盈利还是亏损状态，来体现处置效应。该ASM由一个价格过程为风险资产和一名最多可持有一股的风险中性代理人组成。目标是通过蒙特卡洛模拟，在指定的参数集下，从第一性原理计算处置效应度量，并以精确的格式报告结果。\n\n基本基础和定义：\n- 资产价格过程是一个乘法二项式随机游走：在每个离散时间步 $t \\in \\{0,1,\\dots,T-1\\}$，价格 $P_t$ 移动到 $P_{t+1} = P_t \\cdot U_t$，其中 $U_t \\in \\{1+\\mu, 1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$ 且 $\\Pr[U_t = 1-\\mu] = 1-q$。参数满足 $0  \\mu  1$ 和 $0  q  1$，以确保价格严格为正且概率有明确定义。\n- 代理人遵循一个简单的状态依赖交易规则：\n  - 如果代理人在时间 $t$ 未持有股票，她以概率 $p_{\\text{buy}} \\in (0,1)$ 按当前价格 $P_t$ 购买一股。如果她购买，则买入价格记录为 $P_{\\text{entry}} = P_t$。\n  - 如果代理人在时间 $t$ 持有一股，定义未实现收益 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。卖出概率为 $p_{\\text{sell}}(r_t) = p_g$（如果 $r_t > 0$）和 $p_{\\text{sell}}(r_t) = p_\\ell$（如果 $r_t  0$），其中 $p_g, p_\\ell \\in [0,1]$。如果 $r_t = 0$，则在该步骤中不发生卖出。当 $p_g > p_\\ell$ 时，这体现了处置效应（即相比于亏损股，更倾向于卖出盈利股）。\n- 为了凭经验量化处置效应，使用成熟的已实现与账面（realized-vs-paper）方法论。在整个模拟过程中，追踪代理人持有头寸期间的四个计数：\n  - $G_{\\text{real}}$：处于未实现收益状态的头寸被卖出的次数（已实现收益）。\n  - $G_{\\text{paper}}$：处于未实现收益状态的头寸未被卖出的次数（账面收益）。\n  - $L_{\\text{real}}$：处于未实现亏损状态的头寸被卖出的次数（已实现亏损）。\n  - $L_{\\text{paper}}$：处于未实现亏损状态的头寸未被卖出的次数（账面亏损）。\n  然后计算收益实现比例（PGR）和亏损实现比例（PLR）为：$$\\text{PGR} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}, \\quad \\text{PLR} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}},$$ 约定如果分母为 $0$，则相应的比例设置为 $0$。处置效应度量为 $\\text{DE} = \\text{PGR} - \\text{PLR}$。\n\n任务：\n- 从上述定义以及价格变动和交易决策的伯努利试验的独立性出发，推导出一个正确的模拟程序，该程序能根据大数定律产生对 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$ 的一致估计。证明用于从观测频率估计条件概率的计数逻辑的合理性。\n- 实现一个完整的、确定性的（有种子的）程序，该程序：\n  - 初始化 $P_0 = 100$（任意货币单位）。\n  - 根据上述规则，演化价格和单个代理人的头寸共 $T$ 步。\n  - 精确地按照定义计算 $G_{\\text{real}}, G_{\\text{paper}}, L_{\\text{real}}, L_{\\text{paper}}$，然后为每个参数集计算 $\\text{PGR}$、$\\text{PLR}$ 和 $\\text{DE}$。\n  - 每个测试案例使用固定的随机种子以确保可复现性。\n\n重要实现细节：\n- 在一个时间步 $t$ 内，决策顺序为：如果持有，根据 $r_t$ 决定是否卖出；然后，如果在卖出决策后未持有，则允许以概率 $p_{\\text{buy}}$ 进行买入决策；最后，将价格更新为 $P_{t+1}$。如果 $r_t = 0$，则不卖出，并且该步骤不计为收益或亏损。\n- 代理人在任何时候最多只能持有一股。\n\n测试套件：\n为以下四个参数集运行程序，每个参数集由 $(T, q, \\mu, p_{\\text{buy}}, p_g, p_\\ell, s)$ 定义，其中 $s$ 是伪随机数生成器的整数种子。\n- 案例 1：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.2,\\; p_\\ell=\\;0.2,\\; s=\\;7)$。对称的卖出倾向应产生接近 $0$ 的 $\\text{DE}$。\n- 案例 2：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.6,\\; p_\\ell=\\;0.05,\\; s=\\;11)$。当 $p_g > p_\\ell$ 时，强的处置效应应产生 $\\text{DE} > 0$。\n- 案例 3：$(T=\\;30000,\\; q=\\;0.5,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.02,\\; p_\\ell=\\;0.6,\\; s=\\;13)$。反向处置效应应产生 $\\text{DE}  0$。\n- 案例 4：$(T=\\;30000,\\; q=\\;0.6,\\; \\mu=\\;0.01,\\; p_{\\text{buy}}=\\;0.5,\\; p_g=\\;0.4,\\; p_\\ell=\\;0.2,\\; s=\\;17)$。伴有中度处置效应的向上漂移。\n\n答案规格和输出格式：\n- 对于每个案例，计算 $\\text{DE}$ 为一个四舍五入到 $6$ 位小数的浮点数。\n- 您的程序应产生单行输出，包含四个结果，格式为逗号分隔的列表并用方括号括起来（例如，$[\\text{DE}_1,\\text{DE}_2,\\text{DE}_3,\\text{DE}_4]$）。\n- 本问题不涉及物理单位或角度；所有报告的量均为无单位的实数。", "solution": "我们从乘法二项式模型的基本设定和通过收益实现比例（PGR）及亏损实现比例（PLR）对处置效应的定义开始。价格过程是一个序列 $\\{P_t\\}_{t=0}^{T}$，其中 $P_{t+1} = P_t \\cdot U_t$，$U_t \\in \\{1+\\mu,1-\\mu\\}$，$\\Pr[U_t = 1+\\mu] = q$，且 $\\Pr[U_t = 1-\\mu] = 1-q$。这是一个在伯努利方案下的独立同分布的乘性冲击序列，当 $0  \\mu  1$ 时，$1-\\mu > 0$ 保证了价格的正值性。\n\n代理人在时间 $t$ 的行为取决于当前的持仓状态以及持有头寸时的未实现收益 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$ 的符号。卖出概率是一个分段定义的函数 $p_{\\text{sell}}(r_t)$：如果 $r_t > 0$，则 $p_{\\text{sell}}(r_t) = p_g$；如果 $r_t  0$，则 $p_{\\text{sell}}(r_t) = p_\\ell$。如果 $r_t = 0$，规则将该步的卖出概率设为 $0$，因此不发生卖出。如果在时间 $t$ 未持仓，代理人以概率 $p_{\\text{buy}}$ 买入。所有这些行为都被建模为独立的伯努利试验，这与行为规则引发随机转换的标准基于代理人的模型一致。\n\n为了从模拟中估计PGR和PLR，我们依赖于基于频率的条件概率估计，其合理性由大数定律保证。具体来说，对于收益状态，在出现收益且代理人持有头寸时定义指示事件。令 $X_t^{G}$ 为时间 $t$ 头寸处于收益状态并被实现（卖出）的指示符，令 $Y_t^{G}$ 为时间 $t$ 头寸处于收益状态但未被实现（持有）的指示符。然后我们计数\n$$G_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{G}, \\quad G_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{G}。$$\n在伯努利决策在收益状态下条件独立和平稳的假设下，经验比例\n$$\\widehat{\\text{PGR}} = \\frac{G_{\\text{real}}}{G_{\\text{real}} + G_{\\text{paper}}}$$\n随着 $T \\to \\infty$ 收敛于收益状态下的真实条件卖出概率。类似地，对于亏损状态，定义 $X_t^{L}$ 为在 $t$ 时刻亏损状态被实现（卖出）的指示符，$Y_t^{L}$ 为亏损状态未被卖出的指示符，得到\n$$L_{\\text{real}} = \\sum_{t=0}^{T-1} X_t^{L}, \\quad L_{\\text{paper}} = \\sum_{t=0}^{T-1} Y_t^{L}, \\quad \\widehat{\\text{PLR}} = \\frac{L_{\\text{real}}}{L_{\\text{real}} + L_{\\text{paper}}}.$$\n处置效应度量则为\n$$\\widehat{\\text{DE}} = \\widehat{\\text{PGR}} - \\widehat{\\text{PLR}}.$$\n\n算法设计：\n- 初始化 $P_0 = 100$ 和代理人为未持仓状态。如果发生买入，设置 $P_{\\text{entry}} = P_t$。\n- 对于每个时间步 $t \\in \\{0,1,\\dots,T-1\\}$：\n  - 如果持仓，计算 $r_t = (P_t - P_{\\text{entry}})/P_{\\text{entry}}$。\n    - 如果 $r_t > 0$，进行一次伯努利($p_g$)试验决定是否卖出。如果卖出，则增加 $G_{\\text{real}}$ 并将持仓状态设为假；如果未卖出，则增加 $G_{\\text{paper}}$ 并继续持仓。\n    - 如果 $r_t  0$，进行一次伯努利($p_\\ell$)试验决定是否卖出。如果卖出，则增加 $L_{\\text{real}}$ 并将持仓状态设为假；如果未卖出，则增加 $L_{\\text{paper}}$。\n    - 如果 $r_t = 0$，则此步既不计数也不卖出。\n  - 如果在卖出决策后未持仓，进行一次伯努利($p_{\\text{buy}}$)试验决定是否以价格 $P_t$ 买入；如果发生买入，设置 $P_{\\text{entry}} = P_t$。\n  - 通过从 $\\{1+\\mu, 1-\\mu\\}$ 中分别以概率 $q$ 和 $1-q$ 抽样 $U_t$ 来更新价格，并设置 $P_{t+1} = P_t U_t$。\n- 在 $T$ 步之后，使用上述计数公式计算 $\\widehat{\\text{PGR}}$、$\\widehat{\\text{PLR}}$ 和 $\\widehat{\\text{DE}}$。如果 $G_{\\text{real}} + G_{\\text{paper}} = 0$，则设置 $\\widehat{\\text{PGR}} = 0$。如果 $L_{\\text{real}} + L_{\\text{paper}} = 0$，则设置 $\\widehat{\\text{PLR}} = 0$。\n\n原理证明：\n- 二项式模型是一个经过充分检验的价格动态离散化方法，它在粗略层面上捕捉了漂移和波动率，同时对于 $0  \\mu  1$ 保证了价格的正值性。\n- 代理人决策被建模为以 $r_t$ 符号为条件的伯努利试验，为处置效应提供了一个可解释且易于处理的机制，其中 $p_g > p_\\ell$ 编码了更高的卖出盈利股的倾向。\n- 频率估计量 $\\widehat{\\text{PGR}}$ 和 $\\widehat{\\text{PLR}}$ 是经验条件概率。在独立性假设和基础过程的遍历性下，大数定律保证了当 $T$ 增长时，它们会收敛到其理论值。\n- 计数方案与定义完全匹配：代理人持有且处于收益（或亏损）状态的每一步都对分母有贡献；其中发生卖出的那些步骤则对分子有贡献。\n\n边界情况和约定：\n- 如果 $r_t = 0$，则不发生卖出，也不添加计数，以防止分类中的歧义。\n- 如果PGR或PLR中的分母为零，相应的比例设置为零，以避免除以零，并反映在该类别中未观察到机会。\n- 由于模拟是随机的，固定种子可确保可复现的输出。\n\n计算考量：\n- 每个测试案例的算法运行时间为 $\\mathcal{O}(T)$，除了计数器外，内存消耗为常数。对于 $T = 30000$ 和四个案例，运行时间是适中的。\n\n最终输出：\n- 对于四个指定案例中的每一个，输出处置效应 $\\widehat{\\text{DE}}$，四舍五入到 $6$ 位小数。\n- 程序必须以精确的格式 $[\\widehat{\\text{DE}}_1,\\widehat{\\text{DE}}_2,\\widehat{\\text{DE}}_3,\\widehat{\\text{DE}}_4]$ 打印单行结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(T, q, mu, p_buy, p_gain, p_loss, seed, P0=100.0):\n    rng = np.random.default_rng(seed)\n    P = float(P0)\n    holding = False\n    entry_price = None\n\n    g_realized = 0\n    g_paper = 0\n    l_realized = 0\n    l_paper = 0\n\n    for _ in range(T):\n        # If holding, decide whether to sell based on unrealized gain/loss\n        if holding:\n            r = (P - entry_price) / entry_price\n            if r > 0.0:\n                # Gain state\n                if rng.random()  p_gain:\n                    g_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    g_paper += 1\n            elif r  0.0:\n                # Loss state\n                if rng.random()  p_loss:\n                    l_realized += 1\n                    holding = False\n                    entry_price = None\n                else:\n                    l_paper += 1\n            else:\n                # Exactly break-even: do nothing, do not count\n                pass\n\n        # If not holding after potential sale, possibly buy\n        if not holding:\n            if rng.random()  p_buy:\n                holding = True\n                entry_price = P\n\n        # Update price via binomial move\n        if rng.random()  q:\n            P *= (1.0 + mu)\n        else:\n            P *= (1.0 - mu)\n\n    # Compute PGR and PLR with zero-denominator safeguards\n    denom_g = g_realized + g_paper\n    denom_l = l_realized + l_paper\n    pgr = (g_realized / denom_g) if denom_g > 0 else 0.0\n    plr = (l_realized / denom_l) if denom_l > 0 else 0.0\n    de = pgr - plr\n    return de\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each tuple: (T, q, mu, p_buy, p_g, p_l, seed)\n    test_cases = [\n        (30000, 0.5, 0.01, 0.5, 0.2, 0.2, 7),    # Case 1\n        (30000, 0.5, 0.01, 0.5, 0.6, 0.05, 11),  # Case 2\n        (30000, 0.5, 0.01, 0.5, 0.02, 0.6, 13),  # Case 3\n        (30000, 0.6, 0.01, 0.5, 0.4, 0.2, 17),   # Case 4\n    ]\n\n    results = []\n    for case in test_cases:\n        T, q, mu, p_buy, p_g, p_l, seed = case\n        de = simulate_case(T, q, mu, p_buy, p_g, p_l, seed)\n        results.append(f\"{de:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2372828"}]}