{"hands_on_practices": [{"introduction": "理解订单簿的构成是市场微观结构分析的第一步。此练习将指导你使用最大似然估计法，将订单规模的分布拟合到一个截断幂律模型，这是一种在金融数据中普遍存在的分布 [@problem_id:2408310]。通过估计幂律指数 $\\alpha$，你将能够量化市场上大小订单的相对频率，从而深入理解流动性的颗粒度。", "problem": "给定从加密货币限价订单簿中观测到的独立限价订单大小样本，以基础资产单位（例如，币的数量）表示。假设在每种情况下，所有观测值都是独立同分布的，并且在指定区间内，订单大小遵循闭合区间上的连续截断幂律分布。具体来说，对于参数 $x_{\\min} > 0$、$x_{\\max} > x_{\\min}$ 和指数 $\\alpha > 0$，其概率密度函数为\n$$\nf(x \\mid \\alpha, x_{\\min}, x_{\\max}) = C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha}, \\quad x \\in [x_{\\min}, x_{\\max}],\n$$\n并且在该区间之外 $f(x \\mid \\alpha, x_{\\min}, x_{\\max}) = 0$，其中归一化常数 $C(\\alpha; x_{\\min}, x_{\\max})$ 满足\n$$\n\\int_{x_{\\min}}^{x_{\\max}} C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha} \\, dx = 1.\n$$\n对于 $\\alpha \\neq 1$，此常数为\n$$\nC(\\alpha; x_{\\min}, x_{\\max}) = \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}},\n$$\n对于 $\\alpha = 1$，它是相应的连续极限。\n\n任务：对于下方的每个测试用例，仅使用落在指定区间 $[x_{\\min}, x_{\\max}]$ 内的观测值，通过最大化截断幂律模型下的对数似然来估计指数 $\\alpha$。将每个用例估计出的 $\\alpha$ 作为纯数字（无单位）报告。然后，从经济学角度解释该指数，说明大额订单与小额订单的相对频率；但是，您的程序输出应仅包含数值估计。\n\n所有订单大小均以基础资产单位（例如，币）计量。指数 $\\alpha$ 是无量纲的。您的程序的最终输出必须是单行，包含一个由逗号分隔的三个估计指数的列表，每个指数四舍五入到小数点后四位，并用方括号括起来（例如，$[\\alpha_1,\\alpha_2,\\alpha_3]$）。不应打印其他任何文本。\n\n测试套件（请严格使用这些样本和区间）：\n\n用例 1（理想路径，中度截断）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.02, 5.0]$。\n- 观测到的订单大小：\n$[0.02, 0.02, 0.025, 0.03, 0.03, 0.035, 0.04, 0.045, 0.05, 0.05, 0.06, 0.07, 0.08, 0.09, 0.10, 0.12, 0.15, 0.18, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60, 0.70, 0.80, 0.90, 1.00, 1.10, 1.30, 1.50, 1.70, 2.00, 2.50, 3.00, 3.50, 4.00]$。\n\n用例 2（更宽的截断，质量集中在下界附近，伴有少量大额订单）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.01, 10.0]$。\n- 观测到的订单大小：\n$[0.01, 0.01, 0.012, 0.015, 0.02, 0.02, 0.025, 0.03, 0.035, 0.04, 0.05, 0.06, 0.08, 0.10, 0.13, 0.17, 0.22, 0.30, 0.40, 0.55, 0.75, 1.00, 1.40, 2.00, 3.00, 4.50, 6.00, 8.00, 9.50]$。\n\n用例 3（边缘用例，拟合前需要在区间内进行筛选）：\n- 区间：$[x_{\\min}, x_{\\max}] = [0.05, 2.0]$。\n- 观测到的订单大小（请注意，某些值位于区间之外，在估计前必须丢弃）：\n$[0.03, 0.04, 0.05, 0.06, 0.07, 0.09, 0.12, 0.16, 0.21, 0.28, 0.37, 0.50, 0.68, 0.91, 1.20, 1.60, 2.00, 2.20, 3.00, 0.02, 1.90]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表（例如，$[1.7321,2.0000,1.2345]$），其中每个条目是对应案例的估计指数 $\\alpha$，四舍五入到小数点后四位。不应产生其他任何输出。", "solution": "该问题要求根据一组观测到的订单大小，估计截断幂律分布的指数 $\\alpha$。估计将使用最大似然估计（MLE）方法进行。分析过程如下。\n\n首先，必须验证问题陈述的有效性。该问题具有科学依据，因为幂律分布是经济物理学和金融学中用于描述订单大小等量的标准模型。该问题是适定的，提供了清晰的统计模型和数据，通过标准的估计程序可以得出唯一的解。所有术语都有定义，提供的数据也与上下文一致。因此，该问题被认为是有效的，可以构建一个严谨的解决方案。\n\n对于 $x \\in [x_{\\min}, x_{\\max}]$ 的订单大小 $x$ 的概率密度函数（PDF）如下所示：\n$$\nf(x \\mid \\alpha, x_{\\min}, x_{\\max}) = C(\\alpha; x_{\\min}, x_{\\max}) \\, x^{-\\alpha}\n$$\n其中 $\\alpha > 0$ 是待估计的指数，$x_{\\min}$ 和 $x_{\\max}$ 是给定的截断边界。归一化常数 $C(\\alpha; x_{\\min}, x_{\\max})$（下文记作 $C(\\alpha)$）确保 PDF 在其支撑集上的积分为 1。\n\n对于 $\\alpha \\neq 1$，该常数为：\n$$\nC(\\alpha) = \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}}\n$$\n对于 $\\alpha = 1$ 的特殊情况，我们必须计算当 $\\alpha \\to 1$ 时 $C(\\alpha)$ 的极限。通过对关于 $\\delta = 1 - \\alpha$ 的表达式应用 L'Hôpital 法则，我们得到：\n$$\nC(1) = \\lim_{\\alpha \\to 1} \\frac{1 - \\alpha}{x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}} = \\frac{1}{\\ln(x_{\\max}) - \\ln(x_{\\min})} = \\frac{1}{\\ln(x_{\\max}/x_{\\min})}\n$$\n\n给定一组落在区间 $[x_{\\min}, x_{\\max}]$ 内的 $N$ 个独立同分布的观测值 $\\{x_i\\}_{i=1}^N$，似然函数 $L(\\alpha)$ 是各个概率的乘积：\n$$\nL(\\alpha \\mid \\{x_i\\}) = \\prod_{i=1}^{N} f(x_i \\mid \\alpha) = \\prod_{i=1}^{N} C(\\alpha) x_i^{-\\alpha} = [C(\\alpha)]^N \\left( \\prod_{i=1}^{N} x_i \\right)^{-\\alpha}\n$$\n在计算上，处理对数似然函数 $\\mathcal{L}(\\alpha) = \\ln L(\\alpha)$ 更为方便：\n$$\n\\mathcal{L}(\\alpha) = \\ln\\left( [C(\\alpha)]^N \\right) + \\ln\\left( \\left( \\prod_{i=1}^{N} x_i \\right)^{-\\alpha} \\right) = N \\ln C(\\alpha) - \\alpha \\sum_{i=1}^{N} \\ln x_i\n$$\n为了找到最大似然估计值 $\\hat{\\alpha}$，我们必须找到使 $\\mathcal{L}(\\alpha)$ 最大化的 $\\alpha$ 值。这可以通过求解 $\\frac{d\\mathcal{L}(\\alpha)}{d\\alpha} = 0$ 来实现。其导数为：\n$$\n\\frac{d\\mathcal{L}(\\alpha)}{d\\alpha} = N \\frac{d}{d\\alpha}(\\ln C(\\alpha)) - \\sum_{i=1}^{N} \\ln x_i = 0\n$$\n$\\ln C(\\alpha)$ 的导数并非平凡，所得方程是超越方程，这意味着无法解析地求解 $\\alpha$。因此，需要采用数值方法。标准方法是使用数值优化算法来找到负对数似然函数 $-\\mathcal{L}(\\alpha)$ 的最小值。\n\n需要最小化的函数是：\n$$\n-\\mathcal{L}(\\alpha) = -N \\ln C(\\alpha) + \\alpha \\sum_{i=1}^{N} \\ln x_i\n$$\n对于所有 $\\alpha \\neq 1$ 都有效的 $\\ln C(\\alpha)$ 的一个数值稳定表达式是 $\\ln|1 - \\alpha| - \\ln|x_{\\max}^{1 - \\alpha} - x_{\\min}^{1 - \\alpha}|$。必须分段实现完整的目标函数，以处理 $\\alpha = 1$ 的特殊情况。算法将搜索使该函数最小化的 $\\alpha > 0$ 的值。\n\n对于每个测试用例，步骤如下：\n1. 筛选所提供的观测订单大小列表，仅保留位于指定区间 $[x_{\\min}, x_{\\max}]$ 内的值 $x_i$。设此类有效观测值的数量为 $N$。\n2. 计算这些有效观测值的对数之和 $\\sum_{i=1}^{N} \\ln x_i$。\n3. 在一个合适的范围（例如 $\\alpha > 0$）内，使用 $N$、$\\sum \\ln x_i$、$x_{\\min}$ 和 $x_{\\max}$ 的值，对负对数似然函数 $-\\mathcal{L}(\\alpha)$ 关于 $\\alpha$ 进行数值最小化。\n4. 使该函数最小化的 $\\alpha$ 值即为最大似然估计值 $\\hat{\\alpha}$。\n\n在经济学上，指数 $\\alpha$ 量化了订单大小的分布。一个较大的 $\\alpha$ 值表示概率密度 $f(x) \\propto x^{-\\alpha}$ 随着 $x$ 的增加而迅速衰减。这意味着小额订单的频率远高于大额订单。一个较小的 $\\alpha$ 值对应于分布中的“重尾”，表明大额订单虽然频率仍低于小额订单，但其出现的相对概率更高。因此，$\\alpha$ 是市场碎片化以及散户规模与机构规模流动性供给之间平衡的一个指标。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize_scalar\n\ndef solve():\n    \"\"\"\n    Solves for the MLE of the power-law exponent alpha for three test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"interval\": (0.02, 5.0),\n            \"observations\": [\n                0.02, 0.02, 0.025, 0.03, 0.03, 0.035, 0.04, 0.045, 0.05, 0.05, 0.06, 0.07, 0.08, 0.09,\n                0.10, 0.12, 0.15, 0.18, 0.20, 0.25, 0.30, 0.35, 0.40, 0.45, 0.50, 0.60, 0.70, 0.80,\n                0.90, 1.00, 1.10, 1.30, 1.50, 1.70, 2.00, 2.50, 3.00, 3.50, 4.00\n            ]\n        },\n        {\n            \"interval\": (0.01, 10.0),\n            \"observations\": [\n                0.01, 0.01, 0.012, 0.015, 0.02, 0.02, 0.025, 0.03, 0.035, 0.04, 0.05, 0.06, 0.08,\n                0.10, 0.13, 0.17, 0.22, 0.30, 0.40, 0.55, 0.75, 1.00, 1.40, 2.00, 3.00, 4.50,\n                6.00, 8.00, 9.50\n            ]\n        },\n        {\n            \"interval\": (0.05, 2.0),\n            \"observations\": [\n                0.03, 0.04, 0.05, 0.06, 0.07, 0.09, 0.12, 0.16, 0.21, 0.28, 0.37, 0.50, 0.68,\n                0.91, 1.20, 1.60, 2.00, 2.20, 3.00, 0.02, 1.90\n            ]\n        }\n    ]\n\n    results = []\n\n    def neg_log_likelihood(alpha, N, sum_log_x, x_min, x_max):\n        \"\"\"\n        Computes the negative log-likelihood for the truncated power-law distribution.\n        \"\"\"\n        if N == 0:\n            return np.inf\n\n        # Case for alpha = 1\n        if np.isclose(alpha, 1.0):\n            log_C = -np.log(np.log(x_max) - np.log(x_min))\n        # Case for alpha != 1\n        else:\n            one_minus_alpha = 1.0 - alpha\n            try:\n                # This formulation is numerically stable for alpha  1 and alpha > 1\n                log_C = np.log(np.abs(one_minus_alpha)) - np.log(np.abs(x_max**one_minus_alpha - x_min**one_minus_alpha))\n            except (ValueError, ZeroDivisionError):\n                return np.inf\n\n        log_L = N * log_C - alpha * sum_log_x\n        return -log_L\n\n    for case in test_cases:\n        x_min, x_max = case[\"interval\"]\n        obs = np.array(case[\"observations\"])\n\n        # 1. Filter data to be within the specified interval [x_min, x_max]\n        filtered_obs = obs[(obs >= x_min)  (obs = x_max)]\n        \n        N = len(filtered_obs)\n        if N == 0:\n            # Handle cases with no valid data, though not expected here.\n            results.append(np.nan)\n            continue\n            \n        # 2. Pre-compute sum of logarithms\n        sum_log_x = np.sum(np.log(filtered_obs))\n\n        # 3. Minimize the negative log-likelihood function\n        # The search for alpha > 0. Bounds avoid alpha=0 and very large values.\n        res = minimize_scalar(\n            neg_log_likelihood,\n            bounds=(1e-6, 10.0),\n            args=(N, sum_log_x, x_min, x_max),\n            method='bounded'\n        )\n\n        estimated_alpha = res.x\n        results.append(estimated_alpha)\n\n    # Format output to four decimal places\n    formatted_results = [f\"{r:.4f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2408310"}, {"introduction": "在了解了订单簿的静态结构之后，我们转向其动态响应。此练习的核心是量化市场冲击——即交易行为对价格的瞬时影响，这是交易执行策略中的一个关键考量因素 [@problem_id:2408364]。你将通过对一个非线性幂律模型 $I(Q) = aQ^{b}$ 进行对数线性化，并使用普通最小二乘法来估计冲击指数 $b$，从而掌握一种从经验数据中提取重要市场参数的强大技术。", "problem": "您正在研究限价订单簿 (LOB) 中市价订单的即时价格影响。我们将即时市场影响定义为执行一个大小为 $Q$ 的市价订单所引起的中价变化，记为 $I(Q)$。在一个静态的 LOB 中，若单位价格位移 $u$（相对于当前中价）的边际供给密度为连续函数 $s(u)$，则执行的数量满足一致性条件\n$$\nQ \\;=\\; \\int_{0}^{I(Q)} s(u)\\,du,\n$$\n而影响 $I(Q)$ 是消耗 $Q$ 单位流动性所需的价格位移。假设边际供给密度是 $u$ 的单调函数，并且 LOB 在感兴趣的时间范围内是局部平稳的。\n\n您将提出一个参数化的影响模型，并使用合成数据对其进行实证评估。该参数模型为非线性幂律\n$$\nI(Q) \\;=\\; a\\,Q^{b},\n$$\n其中参数 $a0$ 且 $b0$。观测值受乘性噪声影响：观测到的影响 $I_{\\text{obs}}(Q)$ 满足\n$$\nI_{\\text{obs}}(Q) \\;=\\; I(Q)\\,\\exp(\\varepsilon),\n$$\n其中 $\\varepsilon$ 是独立同分布的高斯噪声，其均值为 $0$，方差为 $\\tau^{2}$。\n\n任务：\n- 对于下面测试套件中描述的每个数据集，按如下方式生成合成数据：从 $[Q_{\\min},Q_{\\max}]$ 上的对数均匀分布中抽取 $N$ 个独立的交易大小 $Q_{i}$（即 $\\log Q_{i}$ 在 $[\\log Q_{\\min},\\log Q_{\\max}]$ 上均匀分布），计算噪声 $\\varepsilon_{i}\\sim \\mathcal{N}(0,\\tau^{2})$，并设置 $I_{i,\\text{obs}}=a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})$。\n- 基于联合样本 $\\{(Q_{i},I_{i,\\text{obs}})\\}_{i=1}^{N}$ 和上述噪声模型所依据的、有充分理由的统计学原理，设计并实现一个 $b$ 的估计器。您的估计器必须在 $Q_{i}$ 和 $I_{i,\\text{obs}}$ 严格为正时有良好定义，并且不应依赖外部数据。\n- 对于每个测试用例，仅输出该数据集的估计值 $\\hat{b}$。\n\n提供一个执行所有测试用例并打印 $\\hat{b}$ 估计值列表的单一程序。\n\n您可以使用的基础知识包括：\n- 即时市场影响 $I(Q)$ 的定义，即在 LOB 中执行数量 $Q$ 所需的价格位移。\n- 积分关系 $Q=\\int_{0}^{I(Q)} s(u)\\,du$，它将消耗的深度与订单大小等同起来。\n- 高斯分布的性质以及在正确指定的模型下的最大似然估计 (MLE) 原理。\n- 应用于变换后的线性模型时的普通最小二乘 (OLS) 回归的性质。\n\n测试套件规范：\n对于每种情况，您必须使用指定的随机种子以确保可复现性。在每个元组中，参数为 $(\\text{seed}, a, b, \\tau, N, Q_{\\min}, Q_{\\max})$。\n\n- 情况 A（凹性影响，低噪声，宽范围交易量）：$(314159,\\, 0.5,\\, 0.6,\\, 0.05,\\, 2000,\\, 100,\\, 50000)$。\n- 情况 B（近线性影响，中等范围）：$(271828,\\, 1.2,\\, 1.0,\\, 0.05,\\, 1500,\\, 50,\\, 20000)$。\n- 情况 C（强凹性，较高噪声，非常宽的范围）：$(424242,\\, 0.8,\\, 0.3,\\, 0.10,\\, 3000,\\, 10,\\, 100000)$。\n- 情况 D（中度凹性，较重噪声，较少样本）：$(8675309,\\, 0.3,\\, 0.9,\\, 0.20,\\, 800,\\, 5,\\, 5000)$。\n\n以上所有符号和数字都是精确的，必须严格遵守。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按 A、B、C、D 顺序排列的四个估计值，以逗号分隔，并用方括号括起来。例如，输出必须类似于\n$[\\hat{b}_{A},\\hat{b}_{B},\\hat{b}_{C},\\hat{b}_{D}]$，\n每个 $\\hat{b}$ 表示为浮点数。在打印输出中，将每个 $\\hat{b}$ 精确四舍五入到 $6$ 位小数。\n\n不涉及物理单位或角度单位。不使用百分比。最终答案必须是浮点数。程序不得读取任何输入，必须完全自包含，并可使用指定的种子进行复现。", "solution": "问题陈述已经过严格验证，被认为是有效的。它在科学上基于既定的市场微观结构理论，在数学上是适定的，并为任务提供了完整而明确的规范。因此，我们可以着手推导和实施解决方案。\n\n该问题要求在给定的非线性幂律市场影响模型中估计参数 $b$，该模型为\n$$\nI(Q) \\;=\\; a\\,Q^{b}\n$$\n观测值受到乘性的、对数正态分布的噪声影响。对于一组大小为 $\\{Q_i\\}_{i=1}^{N}$ 的 $N$ 笔交易，观测到的影响 $\\{I_{i,\\text{obs}}\\}_{i=1}^{N}$ 由以下模型给出\n$$\nI_{i,\\text{obs}} \\;=\\; a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})\n$$\n其中噪声项 $\\varepsilon_{i}$ 是从均值为 $0$、方差为 $\\tau^2$ 的高斯分布中独立同分布地抽取的，即 $\\varepsilon_{i} \\sim \\mathcal{N}(0, \\tau^2)$。\n\n为了估计这个非线性模型的参数，一种标准且有效的技术是通过对数变换将关系线性化。对观测方程两边取自然对数，得到：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log\\left(a\\,Q_{i}^{b}\\,\\exp(\\varepsilon_{i})\\right)\n$$\n利用对数的基本性质，特别是 $\\log(xyz) = \\log(x) + \\log(y) + \\log(z)$ 和 $\\log(x^k) = k\\log(x)$，我们可以展开右边部分：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log(a) + \\log(Q_{i}^{b}) + \\log(\\exp(\\varepsilon_{i}))\n$$\n这简化为一个线性方程：\n$$\n\\log(I_{i,\\text{obs}}) \\;=\\; \\log(a) + b\\,\\log(Q_{i}) + \\varepsilon_{i}\n$$\n为了将其形式化为标准的线性回归问题，我们引入以下变量变换：\n- 令 $y_i = \\log(I_{i,\\text{obs}})$ 为响应变量。\n- 令 $x_i = \\log(Q_i)$ 为预测变量。\n- 令 $\\beta_0 = \\log(a)$ 为截距项。\n- 令 $\\beta_1 = b$ 为斜率系数，这是我们感兴趣的参数。\n\n现在，该模型可以写成简单线性回归的规范形式：\n$$\ny_i \\;=\\; \\beta_0 + \\beta_1 x_i + \\varepsilon_i\n$$\n问题陈述指出，交易大小 $Q_i$ 和噪声项 $\\varepsilon_i$ 是独立生成的。因此，预测变量 $x_i = \\log(Q_i)$ 与误差项 $\\varepsilon_i$ 相互独立。误差 $\\varepsilon_i$ 是从均值为零、方差恒定（$\\tau^2$）的正态分布中独立同分布地抽取的。这些条件满足经典线性回归模型的所有假设。\n\n在这些条件下，普通最小二乘 (OLS) 估计器是参数 $\\beta_0$ 和 $\\beta_1$ 的最佳线性无偏估计器 (BLUE)。此外，由于误差项服从正态分布，OLS 估计器与最大似然估计器 (MLE) 相同，后者具有一致性和渐近有效性等强大的统计特性。\n\nOLS 方法通过最小化残差平方和 (SSR) 来找到参数估计值 $\\hat{\\beta}_0$ 和 $\\hat{\\beta}_1$：\n$$\n\\text{SSR} \\;=\\; \\sum_{i=1}^{N} (y_i - \\hat{\\beta}_0 - \\hat{\\beta}_1 x_i)^2\n$$\n斜率系数 $\\hat{\\beta}_1$ 的著名闭式解为：\n$$\n\\hat{\\beta}_1 \\;=\\; \\frac{\\sum_{i=1}^{N}(x_i - \\bar{x})(y_i - \\bar{y})}{\\sum_{i=1}^{N}(x_i - \\bar{x})^2}\n$$\n其中 $\\bar{x} = \\frac{1}{N}\\sum_{i=1}^{N} x_i$ 和 $\\bar{y} = \\frac{1}{N}\\sum_{i=1}^{N} y_i$ 分别是预测变量和响应变量的样本均值。因此，我们对市场影响指数 $\\hat{b}$ 的估计就是这个估计出的斜率系数，即 $\\hat{b} = \\hat{\\beta}_1$。\n\n每个测试用例的算法流程如下：\n$1$. **数据生成**：\n    - 对于由 $(\\text{seed}, a, b, \\tau, N, Q_{\\min}, Q_{\\max})$ 指定的给定测试用例，使用指定的种子初始化伪随机数生成器以确保可复现性。\n    - 从区间 $[Q_{\\min}, Q_{\\max}]$ 上的对数均匀分布中生成 $N$ 个交易大小 $Q_i$。这等同于从均匀分布 $\\mathcal{U}(\\log(Q_{\\min}), \\log(Q_{\\max}))$ 中抽取 $\\log(Q_i)$。\n    - 从正态分布 $\\mathcal{N}(0, \\tau^2)$ 中生成 $N$ 个噪声项 $\\varepsilon_i$。\n    - 计算合成的观测影响 $I_{i,\\text{obs}} = a\\,Q_i^b \\exp(\\varepsilon_i)$。\n$2$. **模型估计**：\n    - 通过取自然对数来转换生成的数据：$y_i = \\log(I_{i,\\text{obs}})$ 和 $x_i = \\log(Q_i)$。\n    - 构建线性系统 $\\mathbf{y} = X\\boldsymbol{\\beta} + \\boldsymbol{\\varepsilon}$，其中 $\\mathbf{y}$ 是 $y_i$ 值的向量，$\\boldsymbol{\\beta} = [\\beta_0, \\beta_1]^T$，$X$ 是一个 $N \\times 2$ 的设计矩阵，其第一列全为 1，第二列是 $x_i$ 值的向量。\n    - 使用数值最小二乘法求解器求解系数向量 $\\hat{\\boldsymbol{\\beta}}$。该向量的第二个元素 $\\hat{\\beta}_1$ 即为估计值 $\\hat{b}$。\n该方法在统计学上基础扎实，在计算上稳健可靠。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Generates synthetic market impact data and estimates the power-law exponent 'b'\n    for a series of test cases using Ordinary Least Squares on a log-transformed model.\n    \"\"\"\n\n    # Test cases: (seed, a, b, tau, N, Q_min, Q_max)\n    # The parameters correspond to: random seed, scale parameter 'a', exponent 'b',\n    # noise standard deviation 'tau', number of samples 'N', minimum trade size 'Q_min',\n    # and maximum trade size 'Q_max'.\n    test_cases = [\n        # Case A (concave impact, low noise, wide size range)\n        (314159, 0.5, 0.6, 0.05, 2000, 100, 50000),\n        # Case B (near-linear impact, moderate range)\n        (271828, 1.2, 1.0, 0.05, 1500, 50, 20000),\n        # Case C (strongly concave, higher noise, very wide range)\n        (424242, 0.8, 0.3, 0.10, 3000, 10, 100000),\n        # Case D (moderately concave, heavier noise, fewer samples)\n        (8675309, 0.3, 0.9, 0.20, 800, 5, 5000),\n    ]\n\n    results = []\n\n    for seed, a, b, tau, N, Q_min, Q_max in test_cases:\n        # Step 1: Generate synthetic data.\n        # Initialize a random number generator with the specified seed for reproducibility.\n        rng = np.random.default_rng(seed)\n\n        # Generate N trade sizes Q from a log-uniform distribution on [Q_min, Q_max].\n        # This is done by drawing from a uniform distribution in log-space.\n        log_Q = rng.uniform(np.log(Q_min), np.log(Q_max), N)\n        Q = np.exp(log_Q)\n\n        # Generate N i.i.d. Gaussian noise terms.\n        epsilon = rng.normal(loc=0.0, scale=tau, size=N)\n\n        # Compute the observed impact I_obs = a * Q^b * exp(epsilon).\n        I_obs = a * (Q ** b) * np.exp(epsilon)\n\n        # Step 2: Transform the data to linearize the model.\n        # log(I_obs) = log(a) + b*log(Q) + epsilon\n        log_I_obs = np.log(I_obs)\n\n        # Step 3: Perform Ordinary Least Squares (OLS) regression.\n        # We model log_I_obs = beta_0 + beta_1 * log_Q, where beta_1 is our estimate for b.\n        y = log_I_obs\n        x = log_Q\n\n        # Construct the design matrix X for the linear system y = X * beta.\n        # The first column is for the intercept (beta_0), the second for the slope (beta_1).\n        X = np.vstack([np.ones(N), x]).T\n\n        # Solve for the coefficient vector beta = [beta_0, beta_1] using a\n        # standard and numerically stable least-squares solver.\n        # beta[0] will be the estimate for log(a), and beta[1] for b.\n        beta, _, _, _ = np.linalg.lstsq(X, y, rcond=None)\n        \n        b_estimate = beta[1]\n        results.append(b_estimate)\n        \n    # Final print statement in the exact required format.\n    # The output must be a single line: a list of comma-separated values\n    # enclosed in square brackets, with each value rounded to 6 decimal places.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\n# Execute the main function.\nsolve()\n```", "id": "2408364"}, {"introduction": "本练习综合了前述概念，要求你构建一个指定做市商（DMM）的动态仿真模型，以探索其在真实约束下的策略行为。你将模拟一个做市商如何在赚取买卖价差的收益与管理库存风险的成本之间进行权衡，其中库存风险由一个随机过程驱动 [@problem_id:2408375]。这项实践为你提供了一个微观的视角，来理解流动性提供者在现代电子市场中所面临的核心挑战。", "problem": "您的任务是构建一个自包含的离散时间模拟，模拟一个指定做市商（DMM）在限价订单簿中，在明确的微观结构约束和随机库存风险因素下进行操作。该DMM必须在订单簿的两侧持续报价，满足最大价差和最小报价规模的要求，并通过执行交易累积收入，同时承担由Vasicek过程驱动的库存风险惩罚。\n\n模型规格：\n\n- 时间被离散化为大小为 $\\Delta t  0$ 的步长，由 $t \\in \\{0,1,\\ldots,T-1\\}$ 索引。\n\n- 存在一个恒定的参考中间价 $m_0 \\in \\mathbb{R}$。\n\n- DMM必须始终在两侧发布具有对称半价差 $h_t \\in \\mathbb{R}_{\\ge 0}$ 的报价，使得总价差 $2 h_t \\le S_{\\max}$，其中 $S_{\\max}  0$ 是规定的最大价差。DMM的最小报价规模为 $q_{\\min} \\in \\mathbb{N}$，必须在每个时间步的买价和卖价上都发布。\n\n- DMM维持一个库存 $I_t \\in \\mathbb{Z}$，初始库存为 $I_0 \\in \\mathbb{Z}$。在每个时间步，库存因已发布报价的执行而发生变化。\n\n- DMM计算一个保留价格 $r_t \\in \\mathbb{R}$，该价格根据库存和Vasicek（Ornstein–Uhlenbeck）风险因子 $X_t$ 来倾斜报价：\n  $$ r_t = m_0 - \\varphi \\, I_t \\, X_t, $$\n  其中 $\\varphi \\in \\mathbb{R}_{\\ge 0}$ 是一个给定的敏感度参数。\n\n- 在时间 $t$ 发布的买价和卖价为：\n  $$ p^{\\text{bid}}_t = r_t - h_t, \\qquad p^{\\text{ask}}_t = r_t + h_t, $$\n  约束条件为 $2 h_t \\le S_{\\max}$。其意图是DMM通过使用以下公式来遵守该约束\n  $$ h_t = \\min\\left(H, \\frac{S_{\\max}}{2}\\right), $$\n  其中 $H \\in \\mathbb{R}_{0}$ 是一个给定的基础半价差。\n\n- 风险因子 $X_t$ 在连续时间内遵循Vasicek过程，\n  $$ dX_t = \\kappa \\, (\\theta - X_t) \\, dt + \\sigma \\, dW_t, $$\n  其中 $\\kappa \\in \\mathbb{R}_{0}$，$\\theta \\in \\mathbb{R}$，$\\sigma \\in \\mathbb{R}_{\\ge 0}$，以及标准布朗运动 $W_t$。在步长为 $\\Delta t$ 的离散时间内，通过以下方式模拟 $X_t$\n  $$ X_{t+\\Delta t} = X_t + \\kappa \\, (\\theta - X_t) \\, \\Delta t + \\sigma \\, \\sqrt{\\Delta t} \\, Z_t, $$\n  其中 $\\{Z_t\\}$ 是独立的标准正态随机变量，且 $X_0$ 是给定的。\n\n- 可以与DMM发布的报价成交的市价单到达是独立的泊松过程，其强度对于买入市价单（触及卖价）为 $\\lambda_a \\in \\mathbb{R}_{\\ge 0}$，对于卖出市价单（触及买价）为 $\\lambda_b \\in \\mathbb{R}_{\\ge 0}$。在一个时间步长 $\\Delta t$ 内，一侧至少有一次到达的概率是\n  $$ p_a = 1 - e^{-\\lambda_a \\Delta t}, \\qquad p_b = 1 - e^{-\\lambda_b \\Delta t}. $$\n  假设在每个时间步中，每一侧最多只能发生一次规模为 $q_{\\min}$ 的成交。设 $F^{\\text{ask}}_t \\in \\{0,1\\}$ 为卖方成交的指标， $F^{\\text{bid}}_t \\in \\{0,1\\}$ 为买方成交的指标，满足\n  $$ \\mathbb{P}(F^{\\text{ask}}_t = 1) = p_a, \\quad \\mathbb{P}(F^{\\text{bid}}_t = 1) = p_b, $$\n  并且所有随机变量在时间和买卖双方之间都是独立的。\n\n- 库存更新如下\n  $$ I_{t+1} = I_t + q_{\\min} \\, F^{\\text{bid}}_t - q_{\\min} \\, F^{\\text{ask}}_t. $$\n\n- 在时间 $t$，DMM实现的价差收入增量为\n  $$ \\Pi^{\\text{rev}}_t = q_{\\min} \\left( F^{\\text{ask}}_t \\, p^{\\text{ask}}_t - F^{\\text{bid}}_t \\, p^{\\text{bid}}_t \\right). $$\n\n- DMM会产生一个非负的瞬时库存风险惩罚，该惩罚通过以下方式取决于当前库存和当前风险因子\n  $$ \\rho_t = \\max(X_t, 0), \\qquad \\Pi^{\\text{risk}}_t = - \\frac{1}{2} \\, \\rho_t \\, I_t^2 \\, \\Delta t. $$\n\n- 在整个时间范围内累积的总目标是\n  $$ U = \\sum_{t=0}^{T-1} \\left( \\Pi^{\\text{rev}}_t + \\Pi^{\\text{risk}}_t \\right). $$\n\n每个时间步 $t \\in \\{0,1,\\ldots,T-1\\}$ 的模拟协议：\n\n1. 使用 $I_t$ 和 $X_t$ 计算 $r_t$；设置 $h_t = \\min(H, S_{\\max}/2)$；然后设置 $p^{\\text{bid}}_t$ 和 $p^{\\text{ask}}_t$。\n2. 分别以概率 $p_a$ 和 $p_b$ 抽取独立的 $F^{\\text{ask}}_t$ 和 $F^{\\text{bid}}_t$。\n3. 计算收入增量 $\\Pi^{\\text{rev}}_t$。\n4. 使用 $\\rho_t = \\max(X_t, 0)$ 和当前 $I_t$ 计算风险惩罚增量 $\\Pi^{\\text{risk}}_t$。\n5. 将库存更新为 $I_{t+1}$。\n6. 使用离散Vasicek更新和一个新的 $Z_t \\sim \\mathcal{N}(0,1)$ 来更新 $X_{t+\\Delta t}$。\n\n随机性与可复现性：\n\n- 使用一个以整数 $2025$ 为种子的伪随机数生成器实例，并在整个模拟过程中，按照测试用例的评估顺序以及在每个用例中按照上述指定的操作顺序重用它。\n\n测试套件：\n\n对于下面的每个参数集，模拟该过程并报告标量 $U$，四舍五入到六位小数。\n\n- 测试用例A（均衡流量，无约束基础价差）：\n  - $T = 500$, $\\Delta t = 0.1$, $m_0 = 100.0$, $S_{\\max} = 0.20$, $H = 0.08$, $q_{\\min} = 1$,\n  - $\\lambda_a = 3.0$, $\\lambda_b = 3.0$,\n  - $\\kappa = 2.0$, $\\theta = 0.5$, $\\sigma = 0.5$, $X_0 = 0.5$,\n  - $\\varphi = 0.01$, $I_0 = 0$.\n\n- 测试用例B（无到达边缘情况）：\n  - $T = 500$, $\\Delta t = 0.1$, $m_0 = 100.0$, $S_{\\max} = 0.20$, $H = 0.08$, $q_{\\min} = 1$,\n  - $\\lambda_a = 0.0$, $\\lambda_b = 0.0$,\n  - $\\kappa = 2.0$, $\\theta = 0.5$, $\\sigma = 0.5$, $X_0 = 0.5$,\n  - $\\varphi = 0.01$, $I_0 = 0$.\n\n- 测试用例C（紧价差上限，不均衡流量，较大报价规模，非零初始库存）：\n  - $T = 300$, $\\Delta t = 0.1$, $m_0 = 50.0$, $S_{\\max} = 0.20$, $H = 0.20$, $q_{\\min} = 2$,\n  - $\\lambda_a = 8.0$, $\\lambda_b = 1.0$,\n  - $\\kappa = 1.0$, $\\theta = 0.5$, $\\sigma = 0.3$, $X_0 = 0.2$,\n  - $\\varphi = 0.02$, $I_0 = 5$.\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含三个结果 $[U_A, U_B, U_C]$，以逗号分隔的列表形式包含在方括号中，每个值都四舍五入到六位小数（例如，$[12.345678,0.000000,-3.210987]$）。不应打印任何其他文本。", "solution": "该问题要求通过构建一个离散时间的蒙特卡洛模拟，来评估一个指定做市商（DMM）的累积效用。DMM的策略是在赚取买卖价差收益和管理库存风险成本之间进行权衡。解决方案的核心是精确地实现问题中定义的模拟协议。\n\n在每个时间步长 $t$ 中，系统的状态由两个变量定义：DMM的库存 $I_t$ 和随机风险因子 $X_t$。模拟从给定的初始状态 $(I_0, X_0)$ 开始，并迭代 $T$ 个时间步。\n\n**DMM的报价策略**\n在每个时间步 $t$，DMM首先根据其当前库存和风险敞口计算一个*保留价格* $r_t$。这是代理人对资产的内部估值，公式为 $r_t = m_0 - \\varphi \\, I_t \\, X_t$。这个机制是DMM管理库存的核心：例如，当库存 $I_t$ 为正且风险因子 $X_t$ 也为正时，DMM会降低其保留价格，从而使其报价向下倾斜，以激励卖单（减少库存）并抑制买单。\n然后，DMM围绕此保留价格对称地设定其买卖报价：$p^{\\text{bid}}_t = r_t - h_t$ 和 $p^{\\text{ask}}_t = r_t + h_t$。其中，半价差 $h_t$ 是一个由DMM的基础价差 $H$ 和市场规定的最大价差 $S_{\\max}$ 共同决定的常数。\n\n**随机动态的模拟**\n模拟环境包含两个随机性来源：\n1.  **市价单成交**：市价单的到达被建模为独立的泊松过程。在离散时间步 $\\Delta t$ 内，这简化为独立的伯努利试验。DMM的卖单被执行的概率为 $p_a = 1 - e^{-\\lambda_a \\Delta t}$，买单被执行的概率为 $p_b = 1 - e^{-\\lambda_b \\Delta t}$。在每个时间步，我们根据这些概率生成成交指标 $F^{\\text{ask}}_t$ 和 $F^{\\text{bid}}_t$。\n2.  **风险因子演化**：风险因子 $X_t$ 遵循一个均值回归的Vasicek（Ornstein-Uhlenbeck）过程。我们使用欧拉-丸山方法对其进行离散化模拟：$X_{t+\\Delta t} = X_t + \\kappa (\\theta - X_t) \\Delta t + \\sigma \\sqrt{\\Delta t} Z_t$，其中 $Z_t$ 是一个标准正态随机变量。\n\n**效用计算与状态更新**\n在每个时间步 $t$，我们计算DMM总效用 $U$ 的增量：\n-   **价差收入** $\\Pi^{\\text{rev}}_t = q_{\\min} ( F^{\\text{ask}}_t p^{\\text{ask}}_t - F^{\\text{bid}}_t p^{\\text{bid}}_t )$，这是通过低买高卖赚取的利润。\n-   **库存风险惩罚** $\\Pi^{\\text{risk}}_t = - \\frac{1}{2} \\rho_t I_t^2 \\Delta t$（其中 $\\rho_t = \\max(X_t, 0)$），这代表了持有非零库存的成本。该成本与库存量的平方成正比，反映了风险厌恶，并由随时间变化的非负风险参数 $\\rho_t$ 调节。\n\n在计算完增量效用后，系统状态将为下一步进行更新。库存根据成交情况更新：$I_{t+1} = I_t + q_{\\min} F^{\\text{bid}}_t - q_{\\min} F^{\\text{ask}}_t$。风险因子 $X_t$ 则根据其随机过程更新。\n\n**实现与可复现性**\n该解决方案在Python中实现，严格遵循模拟协议。为确保结果的可复现性，我们使用一个以种子 $2025$ 初始化的单一伪随机数生成器。该生成器用于所有测试用例中的所有随机抽样，并严格按照协议中规定的顺序（先是成交，后是风险因子）进行，从而为每个测试用例生成一个确定的累积效用值 $U$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(params, rng):\n    \"\"\"\n    Runs a single simulation for a given parameter set and RNG.\n\n    Args:\n        params (dict): A dictionary containing all model parameters.\n        rng (numpy.random.Generator): The random number generator instance.\n\n    Returns:\n        float: The total accumulated utility U.\n    \"\"\"\n    T = params['T']\n    dt = params['dt']\n    m0 = params['m0']\n    S_max = params['S_max']\n    H = params['H']\n    q_min = params['q_min']\n    lambda_a = params['lambda_a']\n    lambda_b = params['lambda_b']\n    kappa = params['kappa']\n    theta = params['theta']\n    sigma = params['sigma']\n    X0 = params['X0']\n    phi = params['phi']\n    I0 = params['I0']\n\n    # Initialize state variables\n    I_t = float(I0)\n    X_t = float(X0)\n    total_utility = 0.0\n\n    # Pre-calculate constant values\n    h_t = min(H, S_max / 2.0)\n    p_a = 1.0 - np.exp(-lambda_a * dt)\n    p_b = 1.0 - np.exp(-lambda_b * dt)\n    sqrt_dt = np.sqrt(dt)\n\n    for _ in range(T):\n        # Step 1: Compute reservation price and quotes\n        r_t = m0 - phi * I_t * X_t\n        p_ask_t = r_t + h_t\n        p_bid_t = r_t - h_t\n\n        # Step 2: Draw fill indicators\n        F_ask_t = 1 if rng.random()  p_a else 0\n        F_bid_t = 1 if rng.random()  p_b else 0\n\n        # Step 3: Compute revenue increment\n        pi_rev_t = q_min * (F_ask_t * p_ask_t - F_bid_t * p_bid_t)\n\n        # Step 4: Compute risk penalty increment\n        rho_t = max(X_t, 0.0)\n        pi_risk_t = -0.5 * rho_t * (I_t**2) * dt\n\n        # Accumulate utility\n        total_utility += pi_rev_t + pi_risk_t\n\n        # Step 5: Update inventory for the next step\n        I_t = I_t + q_min * F_bid_t - q_min * F_ask_t\n\n        # Step 6: Update risk factor for the next step\n        Z_t = rng.normal(0, 1)\n        X_t = X_t + kappa * (theta - X_t) * dt + sigma * sqrt_dt * Z_t\n        \n    return total_utility\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test case A\n        {\n            'T': 500, 'dt': 0.1, 'm0': 100.0, 'S_max': 0.20, 'H': 0.08, 'q_min': 1,\n            'lambda_a': 3.0, 'lambda_b': 3.0,\n            'kappa': 2.0, 'theta': 0.5, 'sigma': 0.5, 'X0': 0.5,\n            'phi': 0.01, 'I0': 0\n        },\n        # Test case B\n        {\n            'T': 500, 'dt': 0.1, 'm0': 100.0, 'S_max': 0.20, 'H': 0.08, 'q_min': 1,\n            'lambda_a': 0.0, 'lambda_b': 0.0,\n            'kappa': 2.0, 'theta': 0.5, 'sigma': 0.5, 'X0': 0.5,\n            'phi': 0.01, 'I0': 0\n        },\n        # Test case C\n        {\n            'T': 300, 'dt': 0.1, 'm0': 50.0, 'S_max': 0.20, 'H': 0.20, 'q_min': 2,\n            'lambda_a': 8.0, 'lambda_b': 1.0,\n            'kappa': 1.0, 'theta': 0.5, 'sigma': 0.3, 'X0': 0.2,\n            'phi': 0.02, 'I0': 5\n        }\n    ]\n\n    # Initialize a single PRNG instance as required for reproducibility\n    rng = np.random.default_rng(2025)\n    \n    results = []\n    for case_params in test_cases:\n        result = run_simulation(case_params, rng)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2408375"}]}