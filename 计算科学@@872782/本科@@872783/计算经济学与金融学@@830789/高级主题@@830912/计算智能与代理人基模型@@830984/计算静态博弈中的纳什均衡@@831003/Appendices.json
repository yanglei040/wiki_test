{"hands_on_practices": [{"introduction": "在许多策略互动中，参与者可能没有一个显而易见的最佳选择，导致不存在纯策略纳什均衡。在这种情况下，理性的参与者会随机化他们的行动，形成混合策略。本练习提供了一个具体的商业竞争场景，让你亲手实践如何计算混合策略纳什均衡，你将运用关键的“无差异原理”(indifference principle)，即在均衡中，一个参与者的混合策略必须使对手在自己的多个纯策略选项之间获得完全相同的期望收益。[@problem_id:2381458]", "problem": "两个相互竞争的时尚品牌，品牌A和品牌B，各自同时决定其季末促销的时间。每个品牌有两种可能的行动：$E$ (提早开始促销) 或 $L$ (推迟开始促销)。这是一个一次性的、静态的、具有完全信息的同时行动博弈。利润在行动被选择后立即实现，并按以下方式给出，其中每对数字中的第一个是品牌A的利润，第二个是品牌B的利润：\n\n- 如果双方都选择 $E$，利润为 $(40, 10)$。\n- 如果品牌A选择 $E$ 且品牌B选择 $L$，利润为 $(15, 45)$。\n- 如果品牌A选择 $L$ 且品牌B选择 $E$，利润为 $(10, 50)$。\n- 如果双方都选择 $L$，利润为 $(35, 12)$。\n\n假设该博弈存在唯一的混合策略纳什均衡（Nash equilibrium (NE)）。设 $p$ 表示在此均衡中品牌A选择 $E$ 的概率。$p$ 的值是多少？请将您的答案表示为最简分数或小数。无需四舍五入。", "solution": "问题陈述经过验证。\n\n从陈述中提取的已知条件：\n1.  两个参与者：品牌A和品牌B。\n2.  每个参与者的行动集：{$E, L$}。\n3.  该博弈是一个静态、同时行动的完全信息博弈。\n4.  支付矩阵，其中支付为（品牌A的利润，品牌B的利润）：\n    -   如果（品牌A，品牌B）选择 $(E, E)$，支付为 $(40, 10)$。\n    -   如果（品牌A，品牌B）选择 $(E, L)$，支付为 $(15, 45)$。\n    -   如果（品牌A，品牌B）选择 $(L, E)$，支付为 $(10, 50)$。\n    -   如果（品牌A，品牌B）选择 $(L, L)$，支付为 $(35, 12)$。\n5.  假设存在一个唯一的混合策略纳什均衡（NE）。\n6.  变量 $p$ 表示在此均衡中品牌A选择行动 $E$ 的概率。\n7.  任务是求出 $p$ 的值。\n\n验证结论：\n该问题在科学上基于博弈论的既定原则。这是一个关于计算 $2 \\times 2$ 静态博弈的混合策略纳什均衡的适定问题。所提供的信息是完整的、一致的、客观的。没有违反科学或逻辑原则。该问题不包含验证清单中列出的任何缺陷。因此，该问题被认为是有效的，并将提供解决方案。\n\n该博弈可以由以下支付矩阵表示，其中品牌A是行参与者，品牌B是列参与者。矩阵中的条目是支付 $(u_A, u_B)$：\n\n$$\n\\begin{array}{c|cc}\n\\multicolumn{1}{c}{} & \\multicolumn{2}{c}{\\text{品牌B}} \\\\\n\\multicolumn{1}{c}{} & E & L \\\\\n\\cline{2-3}\n\\text{品牌A} \\;\\; E & (40, 10) & (15, 45) \\\\\nL & (10, 50) & (35, 12) \\\\\n\\end{array}\n$$\n\n首先，我们检查纯策略纳什均衡。如果没有任何参与者可以通过单方面偏离来提高其支付，那么一个纯策略组合就是一个纳什均衡。\n-   $(E, E)$：品牌B会倾向于偏离到 $L$（支付为 $45 > 10$）。不是纳什均衡。\n-   $(E, L)$：品牌A会倾向于偏离到 $L$（支付为 $35 > 15$）。不是纳什均衡。\n-   $(L, E)$：品牌A会倾向于偏离到 $E$（支付为 $40 > 10$）。不是纳什均衡。\n-   $(L, L)$：品牌B会倾向于偏离到 $E$（支付为 $50 > 12$）。不是纳什均衡。\n不存在纯策略纳什均衡。正如问题所述，我们必须找到混合策略纳什均衡。\n\n设 $p$ 是品牌A选择行动 $E$ 的概率。因此，品牌A以 $1-p$ 的概率选择 $L$。\n设 $q$ 是品牌B选择行动 $E$ 的概率。因此，品牌B以 $1-q$ 的概率选择 $L$。\n\n要使混合策略纳什均衡存在，每个参与者必须对其混合的纯策略无差异。$p$ 的值应使品牌B在选择 $E$ 和选择 $L$ 之间无差异。\n\n品牌B选择 $E$ 的期望支付，记为 $E[U_B(E)]$，是根据品牌A的策略计算的：\n$$ E[U_B(E)] = p \\cdot 10 + (1-p) \\cdot 50 $$\n品牌B选择 $L$ 的期望支付，记为 $E[U_B(L)]$，是：\n$$ E[U_B(L)] = p \\cdot 45 + (1-p) \\cdot 12 $$\n\n在均衡中，品牌B必须是无差异的，因此我们令 $E[U_B(E)] = E[U_B(L)]$：\n$$ p \\cdot 10 + (1-p) \\cdot 50 = p \\cdot 45 + (1-p) \\cdot 12 $$\n我们现在解这个关于 $p$ 的方程：\n$$ 10p + 50 - 50p = 45p + 12 - 12p $$\n$$ 50 - 40p = 33p + 12 $$\n现在，我们将含 $p$ 的项收集到一边，常数项收集到另一边：\n$$ 50 - 12 = 33p + 40p $$\n$$ 38 = 73p $$\n$$ p = \\frac{38}{73} $$\n\n这就是品牌A必须选择 $E$ 的概率，以使品牌B对其纯策略无差异。由于 $0  \\frac{38}{73}  1$，这是一个有效的混合策略。\n\n为完整起见，我们也可以计算品牌B的均衡策略 $q$。品牌A必须对其策略 $E$ 和 $L$ 无差异。\n品牌A选择 $E$ 的期望支付：\n$$ E[U_A(E)] = q \\cdot 40 + (1-q) \\cdot 15 = 40q + 15 - 15q = 25q + 15 $$\n品牌A选择 $L$ 的期望支付：\n$$ E[U_A(L)] = q \\cdot 10 + (1-q) \\cdot 35 = 10q + 35 - 35q = 35 - 25q $$\n令 $E[U_A(E)] = E[U_A(L)]$：\n$$ 25q + 15 = 35 - 25q $$\n$$ 50q = 20 $$\n$$ q = \\frac{20}{50} = \\frac{2}{5} $$\n由于 $0  \\frac{2}{5}  1$，这也是一个有效的混合策略。唯一的混合策略纳什均衡是 $\\left(\\sigma_A, \\sigma_B\\right) = \\left(p=\\frac{38}{73}, q=\\frac{2}{5}\\right)$。\n\n问题要求的是 $p$ 的值。分数 $\\frac{38}{73}$ 是最简形式，因为 $73$ 是一个质数，而 $38 = 2 \\times 19$。", "answer": "$$\\boxed{\\frac{38}{73}}$$", "id": "2381458"}, {"introduction": "纳什均衡的概念不仅限于离散选择，它更是分析寡头市场等经济模型的基石。这个问题将带你进入经典的古诺双寡头模型 (Cournot duopoly)，这是一个策略空间为连续变量（产量）的博弈。这个练习不仅要求你求解均衡解，更挑战你分析当关键参数（边际成本 $c_i$）变化时，均衡会如何移动——这是经济学中称为“比较静态分析”(comparative statics) 的强大思想。[@problem_id:2381463]", "problem": "考虑一个单次古诺双寡头垄断模型，其中两个公司同时选择非负产量 $q_{1} \\ge 0$ 和 $q_{2} \\ge 0$。市场反需求函数为 $P(Q) = \\alpha - \\beta Q$，其中 $Q = q_{1} + q_{2}$，且 $\\alpha  0$ 和 $\\beta  0$。公司 $i \\in \\{1,2\\}$ 的边际成本为常数 $c_{i}$，且没有固定成本，因此其总成本为 $C_{i}(q_{i}) = c_{i} q_{i}$。假设 $0 \\le c_{1}  \\alpha$ 且 $c_{2} \\ge 0$。纳什均衡（NE）是一个产量对 $(q_{1}^{\\ast}, q_{2}^{\\ast})$，使得在给定另一家公司选择的情况下，每个公司的产量 $q_{i}^{\\ast}$ 都能最大化其自身利润。\n\n当 $c_{2} \\to \\infty$ 时，求纳什均衡产量向量 $(q_{1}^{\\ast}, q_{2}^{\\ast})$ 的极限，并用 $\\alpha$、$\\beta$ 和 $c_{1}$ 表示为一个显式闭式解析表达式。最终答案必须以单个行向量的形式给出。不需要进行数值近似或四舍五入。", "solution": "古诺双寡头模型是一个同步行动博弈，其中每个公司选择一个产量以在给定另一家公司产量的情况下最大化其利润。给定 $q_{1}$ 和 $q_{2}$，市场价格为 $P = \\alpha - \\beta(q_{1} + q_{2})$。公司 $i$ 的利润为\n$$\n\\pi_{i}(q_{i},q_{-i}) = \\big(\\alpha - \\beta(q_{i} + q_{-i}) - c_{i}\\big) q_{i},\n$$\n其中 $q_{-i}$ 表示竞争对手的产量。对于每个公司，关于 $q_{i}$ 的利润函数在 $q_{i} \\ge 0$ 上是一个严格凹的二次函数，因为 $q_{i}^{2}$ 的系数是 $- \\beta  0$。因此，每个公司都存在唯一的最优反应，且非负约束 $q_{i} \\ge 0$ 可能具有约束力。\n\n考虑公司1。对于给定的 $q_{2}$，最大化 $\\pi_{1}$ 的无约束一阶条件（FOC）是\n$$\n\\frac{\\partial \\pi_{1}}{\\partial q_{1}} = \\alpha - \\beta(q_{1} + q_{2}) - c_{1} - \\beta q_{1} = \\alpha - c_{1} - \\beta q_{2} - 2 \\beta q_{1} = 0,\n$$\n这给出了无约束的最优反应\n$$\nq_{1} = \\frac{\\alpha - c_{1} - \\beta q_{2}}{2 \\beta}.\n$$\n施加 $q_{1} \\ge 0$ 的约束，得到最优反应对应\n$$\nBR_{1}(q_{2}) = \\max\\!\\left\\{0,\\; \\frac{\\alpha - c_{1} - \\beta q_{2}}{2 \\beta}\\right\\}.\n$$\n通过对称性，公司2的最优反应是\n$$\nBR_{2}(q_{1}) = \\max\\!\\left\\{0,\\; \\frac{\\alpha - c_{2} - \\beta q_{1}}{2 \\beta}\\right\\}.\n$$\n\n纳什均衡 $(q_{1}^{\\ast}, q_{2}^{\\ast})$ 求解不动点条件 $q_{1}^{\\ast} \\in BR_{1}(q_{2}^{\\ast})$ 和 $q_{2}^{\\ast} \\in BR_{2}(q_{1}^{\\ast})$，其中 $q_{1}^{\\ast}, q_{2}^{\\ast} \\ge 0$。当两个产量都严格为正时（内部均衡），最优反应是等式：\n$$\nq_{1}^{\\ast} = \\frac{\\alpha - c_{1} - \\beta q_{2}^{\\ast}}{2 \\beta}, \n\\quad\nq_{2}^{\\ast} = \\frac{\\alpha - c_{2} - \\beta q_{1}^{\\ast}}{2 \\beta}.\n$$\n解这个线性方程组得到\n$$\nq_{1}^{\\ast} = \\frac{\\alpha - 2 c_{1} + c_{2}}{3 \\beta}, \n\\quad\nq_{2}^{\\ast} = \\frac{\\alpha - 2 c_{2} + c_{1}}{3 \\beta}.\n$$\n内部均衡的可行性要求 $q_{1}^{\\ast} \\ge 0$ 和 $q_{2}^{\\ast} \\ge 0$，即\n$$\n\\alpha - 2 c_{1} + c_{2} \\ge 0\n\\quad \\text{和} \\quad\n\\alpha - 2 c_{2} + c_{1} \\ge 0.\n$$\n当 $c_{2} \\to \\infty$ 时，对于足够大的 $c_{2}$，第二个条件 $\\alpha - 2 c_{2} + c_{1} \\ge 0$ 将被违反，因此内部均衡解不再可行。在这种情况下，公司2的非负约束是紧的，均衡必须是 $q_{2}^{\\ast} = 0$ 的角点解。\n\n为了找到当 $q_{2}^{\\ast} = 0$ 时的角点均衡，将 $q_{2} = 0$ 代入公司1的利润函数，并在 $q_{1} \\ge 0$ 上进行最大化：\n$$\n\\max_{q_{1} \\ge 0} \\; \\pi_{1}(q_{1},0) = \\max_{q_{1} \\ge 0} \\; \\big(\\alpha - \\beta q_{1} - c_{1}\\big) q_{1}.\n$$\n无约束的一阶条件是\n$$\n\\frac{\\partial \\pi_{1}}{\\partial q_{1}} = \\alpha - c_{1} - 2 \\beta q_{1} = 0\n\\;\\;\\Rightarrow\\;\\;\nq_{1} = \\frac{\\alpha - c_{1}}{2 \\beta}.\n$$\n根据假设 $0 \\le c_{1}  \\alpha$，该产量严格为正，因此是可行的。因此，对于足够大的 $c_{2}$，唯一的纳什均衡是\n$$\n\\left(q_{1}^{\\ast}, q_{2}^{\\ast}\\right) = \\left(\\frac{\\alpha - c_{1}}{2 \\beta},\\; 0\\right).\n$$\n\n取极限 $c_{2} \\to \\infty$ 会得到相同的角点均衡产量。因此，\n$$\n\\lim_{c_{2} \\to \\infty} \\left(q_{1}^{\\ast}, q_{2}^{\\ast}\\right) = \\left(\\frac{\\alpha - c_{1}}{2 \\beta},\\; 0\\right).\n$$\n这表明了当公司的边际成本趋于不同时，均衡策略如何调整：在极限情况下，高成本公司退出市场，而低成本公司则提供对应于其边际成本 $c_{1}$ 的垄断产量。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{\\alpha - c_{1}}{2 \\beta}  0\\end{pmatrix}}$$", "id": "2381463"}, {"introduction": "从手动计算到自动化求解是计算经济学的重要一步，它能让我们系统性地分析更复杂的策略环境。本练习的核心任务是编写代码，实现一个能够找出任意有限双矩阵博弈中所有纳什均衡的“支撑集枚举法”(support enumeration) 算法。这个练习将理论知识转化为实际可操作的工具，让你通过编程和测试，深刻理解纳什均衡的计算本质，这是成为计算经济学家的必备技能之一。[@problem_id:2381485]", "problem": "考虑一个有限双人静态完全信息博弈，其以双矩阵形式表示，包含两个支付矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和 $B \\in \\mathbb{R}^{m \\times n}$。参与人1（行参与人）从 $m$ 个纯策略中选择一个混合策略 $x \\in \\Delta^{m-1}$，参与人2（列参与人）从 $n$ 个纯策略中选择一个混合策略 $y \\in \\Delta^{n-1}$，其中 $\\Delta^{k}$ 表示 $k$ 维概率单纯形。如果 $x$ 是对 $y$ 的最佳应对，并且 $y$ 是对 $x$ 的最佳应对，那么策略对 $(x,y)$ 就是一个纳什均衡。所有支付都是无单位的。您必须实现一个完整的程序，对于给定的一组双矩阵博弈，计算每个博弈的不同纳什均衡（包括纯策略和混合策略）的数量。所有不等式和等式检查均需使用精确实数算术，并在 $\\varepsilon = 10^{-9}$ 的绝对容差下进行数值验证。如果两个均衡的混合策略在绝对容差 $\\varepsilon$ 内逐元素相等，则认为它们是相同的。\n\n请使用以下博弈测试套件。每个博弈由一对支付矩阵 $(A^{(k)}, B^{(k)})$ 指定：\n\n测试用例1（一个具有唯一纯策略纳什均衡的博弈）：\n$$\nA^{(1)} = \\begin{pmatrix}\n2  0 \\\\\n3  1\n\\end{pmatrix}, \\quad\nB^{(1)} = \\begin{pmatrix}\n2  3 \\\\\n0  1\n\\end{pmatrix}.\n$$\n\n测试用例2（一个具有多个均衡的博弈，其中至少包含一个混合策略均衡）：\n$$\nA^{(2)} = \\begin{pmatrix}\n3  0 \\\\\n0  2\n\\end{pmatrix}, \\quad\nB^{(2)} = \\begin{pmatrix}\n2  0 \\\\\n0  3\n\\end{pmatrix}.\n$$\n\n测试用例3（一个具有唯一混合策略均衡的严格竞争博弈）：\n$$\nA^{(3)} = \\begin{pmatrix}\n1  -1 \\\\\n-1  1\n\\end{pmatrix}, \\quad\nB^{(3)} = \\begin{pmatrix}\n-1  1 \\\\\n1  -1\n\\end{pmatrix}.\n$$\n\n测试用例4（一个通过严格占优导致唯一纯策略纳什均衡的 $3 \\times 3$ 博弈）：\n$$\nA^{(4)} = \\begin{pmatrix}\n1  0  0 \\\\\n0  1  0 \\\\\n2  3  2\n\\end{pmatrix}, \\quad\nB^{(4)} = \\begin{pmatrix}\n0  5  0 \\\\\n1  6  1 \\\\\n2  7  2\n\\end{pmatrix}.\n$$\n\n您的程序必须为每个测试用例 $k \\in \\{1,2,3,4\\}$ 计算 $(A^{(k)}, B^{(k)})$ 的不同纳什均衡的数量。在检查最佳应对最优性和支撑集内纯策略支付的相等性时，所有计算都必须遵守 $\\varepsilon = 10^{-9}$ 的绝对容差。最终输出必须将所有测试用例的结果聚合到一行中，形式为用方括号括起来的逗号分隔列表，并按测试用例的顺序排列。例如，输出格式必须严格遵循以下形式\n$$\n[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4],\n$$\n其中每个 $\\text{result}_k$ 是为测试用例 $k$ 找到的不同纳什均衡数量的整数。", "solution": "该问题要求计算给定一组双人有限静态博弈中所有不同纳什均衡的数量。这些博弈以双矩阵形式呈现，由行参与人（参与人1）的支付矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 和列参与人（参与人2）的支付矩阵 $B \\in \\mathbb{R}^{m \\times n}$ 定义。\n\n纳什均衡是一个混合策略组合 $(x, y)$，其中 $x \\in \\Delta^{m-1}$ 且 $y \\in \\Delta^{n-1}$，使得没有任何一个参与人有单方面偏离的动机。这意味着 $x$ 是对 $y$ 的最佳应对，而 $y$ 是对 $x$ 的最佳应对。参与人1的期望支付为 $x^T A y$，参与人2的期望支付为 $x^T B y$。\n\n为了找到所有纳什均衡，包括纯策略均衡和混合策略均衡，我们采用**支撑集枚举**（support enumeration）的方法。一个混合策略的支撑集是指以非零概率使用的纯策略集合。设 $S_1$ 是 $x$ 的支撑集，$S_2$ 是 $y$ 的支撑集。\n\n博弈论中的一个基本结论，即**无差异原理**（Indifference Principle），指出：要使一个混合策略成为最佳应对，该参与人必须对其支撑集内的所有纯策略保持无差异。使用这些纯策略中任意一个所获得的期望支付都必须相等。此外，支撑集内任何纯策略的期望支付必须不小于支撑集外任何纯策略的期望支付。\n\n我们假设存在一个候选纳什均衡，其参与人1的支撑集为 $S_1$，参与人2的支撑集为 $S_2$。对于非退化博弈，所有纳什均衡的支撑集大小相同，即 $|S_1| = |S_2|$。因此，我们将遍历所有大小相等的可能支撑集对 $(S_1, S_2)$，其中大小 $k$ 的范围从 $1$ 到 $\\min(m, n)$。\n\n对于给定的支撑集对 $(S_1, S_2)$，其中 $|S_1| = |S_2| = k$，我们构建两个线性方程组来求解候选策略 $x$ 和 $y$。\n\n**1. 求解参与人2的策略 $y$：**\n参与人1必须对其支撑集 $S_1$ 中的所有纯策略 $i$ 保持无差异。这意味着，对于任意策略 $i \\in S_1$，在对手采用策略 $y$ 的情况下，其期望支付必须等于同一个值，记为 $v_1$。\n$$ (A y)_i = \\sum_{j=1}^{n} A_{ij} y_j = v_1 \\quad \\forall i \\in S_1 $$\n由于当 $j \\notin S_2$ 时 $y_j = 0$，这可以简化为：\n$$ \\sum_{j \\in S_2} A_{ij} y_j = v_1 \\quad \\forall i \\in S_1 $$\n这提供了 $k$ 个方程。然而，为了求解 $k$ 个未知概率 $\\{y_j\\}_{j \\in S_2}$，我们只需要 $k-1$ 个独立的无差异方程。设 $i_0$ 是 $S_1$ 中的一个任意参考策略。这 $k-1$ 个无差异条件是：\n$$ \\sum_{j \\in S_2} A_{ij} y_j = \\sum_{j \\in S_2} A_{i_0,j} y_j \\implies \\sum_{j \\in S_2} (A_{ij} - A_{i_0,j}) y_j = 0 \\quad \\forall i \\in S_1, i \\neq i_0 $$\n所需的最后一个方程是概率归一化约束：\n$$ \\sum_{j \\in S_2} y_j = 1 $$\n这就构成了一个包含 $k$ 个变量 $\\{y_j\\}_{j \\in S_2}$ 的 $k$ 元线性方程组，可以使用标准的线性代数方法求解。\n\n**2. 求解参与人1的策略 $x$：**\n类似地，参与人2必须对其支撑集 $S_2$ 中的所有纯策略 $j$ 保持无差异。对于任意策略 $j \\in S_2$，在对手采用策略 $x$ 的情况下，其期望支付必须等于同一个值 $v_2$。\n$$ (x^T B)_j = \\sum_{i=1}^{m} x_i B_{ij} = v_2 \\quad \\forall j \\in S_2 $$\n由于当 $i \\notin S_1$ 时 $x_i = 0$，这可以简化为：\n$$ \\sum_{i \\in S_1} x_i B_{ij} = v_2 \\quad \\forall j \\in S_2 $$\n这可以使用 $B$ 的转置 $B^T$ 表示为 $(B^T x)_j = v_2$。该过程与参与人1的过程类似。我们通过 $k-1$ 个无差异条件和归一化约束 $\\sum_{i \\in S_1} x_i = 1$ 构建一个包含 $k$ 个变量 $\\{x_i\\}_{i \\in S_1}$ 的 $k$ 元线性方程组。\n\n**3. 候选均衡的验证：**\n这些方程组的解 $(x, y)$ 只是一个候选均衡。必须使用数值容差 $\\varepsilon = 10^{-9}$ 对其进行三个条件的验证：\na. **概率分布有效性：** 计算出的策略的所有分量必须为非负数。也就是说，对于所有 $i \\in S_1$，$x_i \\ge -\\varepsilon$；对于所有 $j \\in S_2$，$y_j \\ge -\\varepsilon$。\nb. **参与人1的最佳应对：** 参与人1通过偏离到支撑集外的纯策略 $i' \\notin S_1$ 不会获益。任何此类策略的支付不得严格大于均衡支付 $v_1$。\n$$ (A y)_{i'} \\le v_1 + \\varepsilon \\quad \\forall i' \\notin S_1, \\text{ where } v_1 = (A y)_{i_0} \\text{ for any } i_0 \\in S_1 $$\nc. **参与人2的最佳应对：** 参与人2通过偏离到支撑集外的纯策略 $j' \\notin S_2$ 不会获益。\n$$ (x^T B)_{j'} \\le v_2 + \\varepsilon \\quad \\forall j' \\notin S_2, \\text{ where } v_2 = (x^T B)_{j_0} \\text{ for any } j_0 \\in S_2 $$\n\n如果候选解 $(x, y)$ 通过了所有验证步骤，它就是一个有效的纳什均衡。该算法通过遍历所有有效的支撑集对，求解相应的线性系统，验证解，并收集所有唯一的有效均衡来执行。当支撑集大小 $k$ 为 1 时，纯策略均衡自然地被包含在此过程中。最后，报告为每个博弈找到的不同均衡的总数。", "answer": "```python\nimport numpy as np\nfrom itertools import combinations\n\ndef find_equilibria(A, B, tol=1e-9):\n    \"\"\"\n    Finds all Nash equilibria in a bimatrix game using support enumeration.\n    \n    This function iterates through all possible support pairs of equal size,\n    solves for candidate mixed strategies, and verifies if they constitute\n    a Nash equilibrium.\n    \"\"\"\n    m, n = A.shape\n    found_equilibria = []\n\n    # Iterate over all possible support sizes k. For non-degenerate games,\n    # equilibria have supports of equal size.\n    for k in range(1, min(m, n) + 1):\n        # Iterate over all possible supports for Player 1 (rows)\n        for s1_indices in combinations(range(m), k):\n            s1 = list(s1_indices)\n            \n            # Iterate over all possible supports for Player 2 (columns)\n            for s2_indices in combinations(range(n), k):\n                s2 = list(s2_indices)\n\n                # 1. Solve for Player 2's mixed strategy y\n                try:\n                    # Construct the linear system for y\n                    # We need to solve M_y * y_s2 = b_y\n                    # k-1 indifference equations and 1 probability sum equation\n                    M_y = np.ones((k, k))\n                    b_y = np.zeros(k)\n                    b_y[-1] = 1.0\n                    \n                    # Indifference equations for player 1\n                    A_sub = A[s1, :][:, s2]\n                    M_y[:-1, :] = A_sub[:-1, :] - A_sub[-1, :]\n\n                    y_s2 = np.linalg.solve(M_y, b_y)\n\n                except np.linalg.LinAlgError:\n                    continue  # Singular matrix, no unique solution for this support pair\n\n                # 2. Solve for Player 1's mixed strategy x\n                try:\n                    # Construct the linear system for x, using the transpose of B\n                    # We need to solve M_x * x_s1 = b_x\n                    B_T_sub = B.T[s2, :][:, s1]\n                    M_x = np.ones((k, k))\n                    b_x = np.zeros(k)\n                    b_x[-1] = 1.0\n\n                    # Indifference equations for player 2\n                    M_x[:-1, :] = B_T_sub[:-1, :] - B_T_sub[-1, :]\n                    \n                    x_s1 = np.linalg.solve(M_x, b_x)\n\n                except np.linalg.LinAlgError:\n                    continue # Singular matrix\n\n                # 3. Verify the candidate solution (x, y)\n                \n                # a. Check if strategies are valid probability distributions\n                if np.min(x_s1)  -tol or np.min(y_s2)  -tol:\n                    continue\n\n                # Reconstruct full strategy vectors\n                x = np.zeros(m)\n                x[s1] = x_s1\n                y = np.zeros(n)\n                y[s2] = y_s2\n\n                # b. Verify best-response conditions for players\n                p1_payoffs = A @ y\n                p2_payoffs = x @ B\n\n                v1 = p1_payoffs[s1[0]]\n                v2 = p2_payoffs[s2[0]]\n\n                # Check if any strategy outside the support yields a strictly higher payoff\n                p1_max_other_payoff = -np.inf\n                for i in range(m):\n                    if i not in s1:\n                        p1_max_other_payoff = max(p1_max_other_payoff, p1_payoffs[i])\n                \n                if p1_max_other_payoff > v1 + tol:\n                    continue\n\n                p2_max_other_payoff = -np.inf\n                for j in range(n):\n                    if j not in s2:\n                        p2_max_other_payoff = max(p2_max_other_payoff, p2_payoffs[j])\n\n                if p2_max_other_payoff > v2 + tol:\n                    continue\n\n                # The candidate is a valid Nash Equilibrium.\n                # Add it to the list if it's not a duplicate.\n                is_duplicate = False\n                for ex, ey in found_equilibria:\n                    if np.allclose(x, ex, atol=tol) and np.allclose(y, ey, atol=tol):\n                        is_duplicate = True\n                        break\n                \n                if not is_duplicate:\n                    found_equilibria.append((x, y))\n\n    return len(found_equilibria)\n\n\ndef solve():\n    \"\"\"\n    Solves the given set of bimatrix games and prints the number of equilibria.\n    \"\"\"\n    test_cases = [\n        (np.array([[2, 0], [3, 1]]), np.array([[2, 3], [0, 1]])),\n        (np.array([[3, 0], [0, 2]]), np.array([[2, 0], [0, 3]])),\n        (np.array([[1, -1], [-1, 1]]), np.array([[-1, 1], [1, -1]])),\n        (np.array([[1, 0, 0], [0, 1, 0], [2, 3, 2]]), np.array([[0, 5, 0], [1, 6, 1], [2, 7, 2]]))\n    ]\n    \n    results = []\n    for A, B in test_cases:\n        num_equilibria = find_equilibria(A, B)\n        results.append(num_equilibria)\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2381485"}]}