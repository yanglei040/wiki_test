{"hands_on_practices": [{"introduction": "理解一个概率分布的最佳方式之一就是亲手实现其模拟。本练习将指导你使用逆变换采样法（inverse transform sampling）来生成广义帕累托分布（GPD）的随机样本。该方法是计算统计学中的基石技术，通过它你不仅能深入理解GPD的累积分布函数（CDF）及其反函数（分位数函数），还将学会如何通过一系列统计指标来验证模拟结果的准确性，这是任何严谨建模工作中不可或缺的一步。[@problem_id:2397442]", "problem": "一家金融机构使用广义帕累托分布 (GPD) 对超过高阈值的超额损失进行建模。设 $X$ 服从广义帕累托分布，其形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。其累积分布函数定义如下\n- 对于 $\\xi \\neq 0$,\n$$\nF(x;\\xi,\\beta,\\mu) \\;=\\; 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}\n\\quad \\text{for} \\quad\n\\begin{cases}\nx \\ge \\mu  \\text{ if } \\xi \\ge 0, \\\\\n\\mu \\le x \\le \\mu - \\beta/\\xi  \\text{ if } \\xi  0,\n\\end{cases}\n$$\n- 对于 $\\xi = 0$,\n$$\nF(x;0,\\beta,\\mu) \\;=\\; 1 - \\exp\\!\\left(-\\frac{x-\\mu}{\\beta}\\right)\n\\quad \\text{for} \\quad x \\ge \\mu.\n$$\n\n您必须编写一个完整的程序，该程序能针对多组参数集从上述 GPD 生成独立同分布的随机变量，然后通过在固定的概率网格上比较经验分位数与理论分位数来评估生成的样本。所有计算都应使用指定的种子以保证可复现性。不允许使用外部数据或用户输入。\n\n定义和要求：\n- 设 $U$ 是一个服从 $(0,1)$ 上标准连续均匀分布的随机变量。分位数函数 $F^{-1}(p;\\xi,\\beta,\\mu)$ 对于 $p \\in (0,1)$ 定义为其支撑集上 $F(\\cdot;\\xi,\\beta,\\mu)$ 的反函数。\n- 对于给定的概率 $p \\in (0,1)$，有限样本 $x_{1},\\dots,x_{n}$ 的经验 $p$-分位数定义如下：将样本按非递减顺序排序得到 $x_{(1)} \\le \\dots \\le x_{(n)}$，设置 $s = (n-1)p$，令 $i = \\lfloor s \\rfloor + 1$ 和 $j = \\lceil s \\rceil + 1$ 为 $\\{1,\\dots,n\\}$ 中的整数索引，并令 $\\lambda = s - \\lfloor s \\rfloor$。经验分位数为\n$$\nQ_{\\text{emp}}(p) \\;=\\; (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}.\n$$\n- 构建分位数网格 $\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和中心网格 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- 对于给定的参数集和大小为 $n$ 的样本，计算向量 $\\mathbf{Q}_{\\text{th}} = \\big(F^{-1}(p;\\xi,\\beta,\\mu)\\big)_{p \\in \\mathcal{P}}$ 和 $\\mathbf{Q}_{\\text{emp}} = \\big(Q_{\\text{emp}}(p)\\big)_{p \\in \\mathcal{P}}$。使用这些向量计算：\n    1. $\\mathbf{Q}_{\\text{th}}$ 和 $\\mathbf{Q}_{\\text{emp}}$ 之间的决定系数 $R^{2}$，定义为两个向量的皮尔逊相关系数的平方。\n    2. 通过普通最小二乘法拟合线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 得到的最小二乘斜率 $b$ 和截距 $a$。\n    3. 在中心网格上的最大绝对偏差，按尺度参数归一化，$\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p;\\xi,\\beta,\\mu)\\big|/\\beta$。\n    4. 对于 $\\xi  0$，支撑集的上端点为 $x_{\\max} = \\mu - \\beta/\\xi$。定义支撑集检查为 $\\mathbf{1}\\{\\max_{k} x_{k} \\le x_{\\max}\\}$，其中 $x_{k}$ 是采样值，$\\mathbf{1}\\{\\cdot\\}$ 是指示函数。对于 $\\xi \\ge 0$，此检查自动满足。\n\n每个参数集的接受标准：\n- $R^{2} \\ge 0.9995$,\n- $|b - 1| \\le 0.02$,\n- $|a| \\le 0.05\\,\\beta$,\n- $\\Delta_{\\max} \\le 0.12$,\n- 支撑集检查通过。\n\n对于每个参数集，输出一个布尔值，指示是否同时满足所有接受标准。\n\n测试套件：\n- 案例 1：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25,\\,1.40,\\,0.00,\\,120000,\\,1729)$。\n- 案例 2：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00,\\,2.20,\\,0.50,\\,150000,\\,41041)$。\n- 案例 3：$(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35,\\,1.10,\\,{-0.30},\\,120000,\\,271828)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，结果顺序与上述案例一致，例如 $[\\text{True},\\text{False},\\text{True}]$，其中每个条目都是一个布尔值。", "solution": "所陈述的问题经过了严格的验证。\n\n**第 1 步：提取给定信息**\n- **分布**：广义帕累托分布 (GPD)，形状参数为 $\\xi \\in \\mathbb{R}$，尺度参数为 $\\beta \\in (0,\\infty)$，位置参数为 $\\mu \\in \\mathbb{R}$。\n- **累积分布函数 (CDF)**：\n  - 对于 $\\xi \\neq 0$：$F(x;\\xi,\\beta,\\mu) = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi}$，支撑集为 $x \\ge \\mu$（当 $\\xi \\ge 0$ 时）和 $\\mu \\le x \\le \\mu - \\beta/\\xi$（当 $\\xi  0$ 时）。\n  - 对于 $\\xi = 0$：$F(x;0,\\beta,\\mu) = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right)$，支撑集为 $x \\ge \\mu$。\n- **分位数函数**：$F^{-1}(p;\\xi,\\beta,\\mu)$ 定义为 CDF 在 $p \\in (0,1)$ 上的反函数。\n- **经验分位数**：对于排序后的样本 $x_{(1)} \\le \\dots \\le x_{(n)}$，经验 $p$-分位数为 $Q_{\\text{emp}}(p) = (1-\\lambda)\\,x_{(i)} + \\lambda\\,x_{(j)}$，其中 $s = (n-1)p$, $i = \\lfloor s \\rfloor + 1$, $j = \\lceil s \\rceil + 1$ 且 $\\lambda = s - \\lfloor s \\rfloor$。\n- **概率网格**：$\\mathcal{P} = \\{0.01, 0.02, \\dots, 0.99\\}$ 和 $\\mathcal{P}_{\\text{central}} = \\{0.05, 0.10, \\dots, 0.95\\}$。\n- **评估所需指标**：\n    1. 在网格 $\\mathcal{P}$ 上，理论分位数 $\\mathbf{Q}_{\\text{th}}$ 与经验分位数 $\\mathbf{Q}_{\\text{emp}}$ 之间的决定系数 $R^{2}$。\n    2. 来自线性模型 $Q_{\\text{emp}} \\approx a + b\\,Q_{\\text{th}}$ 的最小二乘斜率 $b$ 和截距 $a$。\n    3. 最大归一化绝对偏差 $\\Delta_{\\max} = \\max_{p \\in \\mathcal{P}_{\\text{central}}} \\big|Q_{\\text{emp}}(p) - F^{-1}(p)\\big|/\\beta$。\n    4. 支撑集检查：对于 $\\xi  0$，指示函数 $\\mathbf{1}\\{\\max_{k} x_{k} \\le \\mu - \\beta/\\xi\\}$；根据定义，当 $\\xi \\ge 0$ 时此条件满足。\n- **接受标准**：\n    1. $R^{2} \\ge 0.9995$\n    2. $|b - 1| \\le 0.02$\n    3. $|a| \\le 0.05\\,\\beta$\n    4. $\\Delta_{\\max} \\le 0.12$\n    5. 支撑集检查必须通过。\n- **测试用例**：\n    1. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.25, 1.40, 0.00, 120000, 1729)$\n    2. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (0.00, 2.20, 0.50, 150000, 41041)$\n    3. $(\\xi,\\beta,\\mu,n,\\text{seed}) = (-0.35, 1.10, -0.30, 120000, 271828)$\n\n**第 2 步：问题陈述的验证**\n根据所需标准对问题进行评估。\n- **科学依据**：该问题建立在极值理论和计算统计学的原理之上。GPD 是这些领域的标准模型。所有定义，包括 CDF 和统计指标，都是标准且正确的。\n- **适定性**：该问题是适定的。它要求实现一个基于指定种子的伪随机数生成的确定性算法。这确保了存在唯一且可验证的解。所有必要信息均已提供。\n- **客观性**：问题以精确的数学和算法术语陈述，没有主观性或模糊性。定义、测试用例和接受标准都得到了完整而清晰的说明。\n\n**第 3 步：结论与行动**\n该问题是有效的。这是一个定义明确的计算统计学练习，要求实现随机变量生成、分位数分析和统计验证。将提供完整的解决方案。\n\n**方法论**\n解决方案将基于逆变换采样原理构建。对于一个具有 CDF $F(x)$ 的连续随机变量，其分位数函数为 $F^{-1}(p)$。如果 $U$ 是一个服从 $(0,1)$ 上标准均匀分布的随机变量，那么随机变量 $X = F^{-1}(U)$ 的 CDF 就是 $F(x)$。\n\n首先，我们推导 GPD 的分位数函数 $F^{-1}(p)$。\n令 $p = F(x)$。我们求解 $x$。\n\n情况 1：$\\xi \\neq 0$\n$$ p = 1 - \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ 1-p = \\left(1 + \\xi \\frac{x-\\mu}{\\beta}\\right)^{-1/\\xi} $$\n$$ (1-p)^{-\\xi} = 1 + \\xi \\frac{x-\\mu}{\\beta} $$\n$$ (1-p)^{-\\xi} - 1 = \\xi \\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n因此，分位数函数为：\n$$ F^{-1}(p;\\xi,\\beta,\\mu) = \\mu + \\frac{\\beta}{\\xi} \\left( (1-p)^{-\\xi} - 1 \\right) $$\n\n情况 2：$\\xi = 0$\n这对应于尺度为 $\\beta$、位置为 $\\mu$ 的指数分布。\n$$ p = 1 - \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ 1-p = \\exp\\left(-\\frac{x-\\mu}{\\beta}\\right) $$\n$$ \\ln(1-p) = -\\frac{x-\\mu}{\\beta} $$\n$$ x - \\mu = -\\beta \\ln(1-p) $$\n因此，分位数函数为：\n$$ F^{-1}(p;0,\\beta,\\mu) = \\mu - \\beta \\ln(1-p) $$\n\n对于每个测试用例，程序将按以下步骤进行：\n1.  设置随机数生成器种子以保证可复现性。\n2.  从标准均匀分布 $U(0,1)$ 生成大小为 $n$ 的样本。\n3.  根据 $\\xi$ 的值，使用上面推导出的适当的分位数函数将此样本转换为 GPD 样本。\n4.  构建概率网格 $\\mathcal{P}$ 和 $\\mathcal{P}_{\\text{central}}$。\n5.  将分位数函数应用于网格 $\\mathcal{P}$ 中的概率，计算理论分位数向量 $\\mathbf{Q}_{\\text{th}}$。\n6.  从生成的样本中，为同一网格 $\\mathcal{P}$ 计算经验分位数向量 $\\mathbf{Q}_{\\text{emp}}$。所提供的 $Q_{\\text{emp}}(p)$ 公式对应于标准的线性插值法，该方法在数值库中可用。\n7.  计算四个指定的指标：\n    a. $R^2$：计算为 $\\mathbf{Q}_{\\text{th}}$ 和 $\\mathbf{Q}_{\\text{emp}}$ 之间皮尔逊相关系数的平方。\n    b. $a, b$：通过对 $\\mathbf{Q}_{\\text{emp}}$ 关于 $\\mathbf{Q}_{\\text{th}}$ 进行普通最小二乘线性回归获得。\n    c. $\\Delta_{\\max}$：通过找出中心网格 $\\mathcal{P}_{\\text{central}}$ 上经验分位数和理论分位数之间的最大绝对差，并用 $\\beta$ 进行归一化来计算。\n    d. 支撑集检查：对于 $\\xi  0$，确认所有生成的随机变量都小于或等于支撑集的理论上界 $x_{\\max} = \\mu - \\beta/\\xi$。\n8.  最后，验证是否所有五个接受标准都已满足。每个测试用例的结果是一个单一的布尔值。\n最终输出是将这些布尔结果汇总成指定的列表格式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Validates GPD random variate generation against theoretical properties\n    for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (xi, beta, mu, n, seed)\n        (0.25, 1.40, 0.00, 120000, 1729),\n        (0.00, 2.20, 0.50, 150000, 41041),\n        (-0.35, 1.10, -0.30, 120000, 271828),\n    ]\n\n    results = []\n    \n    # Define probability grids\n    # P = {0.01, ..., 0.99}\n    p_grid = np.linspace(0.01, 0.99, 99)\n    # P_central = {0.05, ..., 0.95}\n    p_central = np.linspace(0.05, 0.95, 19)\n\n    def gpd_quantile(p, xi, beta, mu):\n        \"\"\"Computes the theoretical quantile for the GPD.\"\"\"\n        if xi == 0:\n            # Handle the case for xi = 0 (Exponential distribution)\n            return mu - beta * np.log(1 - p)\n        else:\n            # Handle the case for xi != 0\n            # Expression ( (1-p)**(-xi) - 1 ) / xi can be written using expm1 for numerical stability\n            # for small xi, as expm1(y)/y - 1 as y-0.\n            # Here y = -xi * log(1-p).\n            return mu + beta * (np.power(1 - p, -xi) - 1) / xi\n\n    for case in test_cases:\n        xi, beta, mu, n, seed = case\n        \n        # 1. Generate random variates using inverse transform sampling\n        np.random.seed(seed)\n        uniform_samples = np.random.uniform(size=n)\n        gpd_samples = gpd_quantile(uniform_samples, xi, beta, mu)\n\n        # 2. Compute theoretical and empirical quantiles\n        q_th = gpd_quantile(p_grid, xi, beta, mu)\n        q_emp = np.quantile(gpd_samples, p_grid, method='linear')\n\n        # 3. Calculate metrics and perform checks\n        \n        # Metric 1: R^2\n        pearson_r, _ = stats.pearsonr(q_th, q_emp)\n        r_squared = pearson_r**2\n        check1 = r_squared >= 0.9995\n\n        # Metric 2: OLS slope and intercept\n        lin_reg = stats.linregress(x=q_th, y=q_emp)\n        b, a = lin_reg.slope, lin_reg.intercept\n        check2 = abs(b - 1) = 0.02\n        check3 = abs(a) = 0.05 * beta\n\n        # Metric 3: Maximum absolute deviation on the central grid\n        q_th_central = gpd_quantile(p_central, xi, beta, mu)\n        q_emp_central = np.quantile(gpd_samples, p_central, method='linear')\n        delta_max = np.max(np.abs(q_emp_central - q_th_central)) / beta\n        check4 = delta_max = 0.12\n\n        # Metric 4: Support upper endpoint check\n        if xi  0:\n            support_upper_bound = mu - beta / xi\n            check5 = np.max(gpd_samples) = support_upper_bound\n        else:\n            # For xi >= 0, the support is unbounded above, so the check is satisfied\n            check5 = True\n\n        # Combine all checks\n        all_criteria_met = all([check1, check2, check3, check4, check5])\n        results.append(all_criteria_met)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2397442"}, {"introduction": "广义帕累托分布不仅是一个理论模型，更是在金融风险管理中量化极端事件的关键工具。上一个练习让你掌握了如何生成GPD数据，现在我们将探讨其在实际应用中的重要性，特别是其形状参数 $\\xi$ 如何影响风险度量。这个练习将通过一个具体的案例，计算由于错误地假设一个轻尾分布（Gumbel类型，对应 $\\xi=0$）而导致的预期短缺（Expected Shortfall, ES）的度量误差，从而揭示模型风险的严重后果。[@problem_id:2391806]", "problem": "一位风险经理使用超阈值峰值 (Peaks-Over-Threshold) 框架对投资组合损失的超额部分进行建模。设投资组合损失为随机变量 $L$，并设 $u$ 为一个固定阈值。定义在 $Lu$ 的条件下，超额量为 $Y=L-u$。假设在 $Lu$ 的条件下，超额量 $Y$ 服从广义帕累托分布 (Generalized Pareto Distribution, GPD)，其形状参数为 $\\xi$，尺度参数为 $\\beta0$。$Y$ 的累积分布函数为\n$$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}\\quad\\text{对于 }\\xi\\neq 0,\\ y\\ge 0,\\ 1+\\frac{\\xi y}{\\beta}0,$$\n以及\n$$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)\\quad\\text{对于 }\\xi=0,\\ y\\ge 0.$$\n令 $p_u=\\mathbb{P}(Lu)$ 表示超额概率。对于一个无条件概率水平 $\\alpha\\in(0,1)$ 且 $\\alpha1-p_u$，将在险价值 (Value at Risk, VaR) 定义为 $\\mathrm{VaR}_\\alpha$，即 $L$ 的 $\\alpha$-分位数。将在水平 $\\alpha$ 的期望亏损 (Expected Shortfall, ES) 定义为 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L\\mathrm{VaR}_\\alpha]$，当其为有限值时。\n\n假设真实的尾部分布为 Fréchet 类型，$\\xi=\\xi_{\\text{true}}0$ 且 $\\xi_{\\text{true}}  1$（因此 $\\mathrm{ES}_\\alpha$ 是有限的），但一位分析师错误地将尾部分布指定为 Gumbel 类型，即设定 $\\xi=0$，同时使用相同的 $u$、$p_u$ 和 $\\beta$。\n\n对于下方的每个测试用例，计算错误设定比率\n$$R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}},$$\n其中 $\\mathrm{ES}_\\alpha^{\\text{true}}$ 是在真实的 $\\xi_{\\text{true}}0$ 下计算的，而 $\\mathrm{ES}_\\alpha^{\\text{mis}}$ 是在错误设定的 $\\xi=0$ 下计算的，两者都使用相同的 $u$、$p_u$ 和 $\\beta$。所有计算都应遵循上述定义以及广义帕累托分布和条件超额的标准性质。将每个 $R$ 表示为四舍五入到 $6$ 位小数的小数。\n\n测试套件（每个元组为 $(u,p_u,\\beta,\\xi_{\\text{true}},\\alpha)$）：\n- 案例 1：$(1.0,0.05,1.5,0.3,0.99)$\n- 案例 2：$(1.0,0.10,0.7,0.05,0.98)$\n- 案例 3：$(0.5,0.02,1.0,0.9,0.999)$\n- 案例 4：$(2.0,0.01,0.8,0.4,0.995)$\n\n您的程序必须生成单行输出，其中包含所有案例的结果，格式为一个用方括号括起来的逗号分隔列表，顺序与测试套件相同（例如 $[r_1,r_2,r_3,r_4]$），每个 $r_i$ 四舍五入到 $6$ 位小数。", "solution": "该问题要求计算期望亏损 (ES) 风险度量的错误设定比率。这是一个量化风险管理中的标准问题，需要严格应用极值理论 (EVT) 的定义。我们将首先验证问题陈述，然后着手推导必要的公式。\n\n验证步骤确认了该问题在科学上是合理的、适定的和客观的。\n按要求逐字提取已知条件：\n- 投资组合损失是一个随机变量 $L$。\n- 阈值为 $u$。\n- 在 $Lu$ 的条件下，超额量为 $Y=L-u$。\n- $Y$ 的分布为广义帕累托分布 (GPD)，形状参数为 $\\xi$，尺度参数为 $\\beta0$。\n- 当 $\\xi\\neq 0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\left(1+\\frac{\\xi y}{\\beta}\\right)^{-1/\\xi}$。\n- 当 $\\xi=0$ 时，$Y$ 的累积分布函数为：$F_Y(y)=1-\\exp\\left(-\\frac{y}{\\beta}\\right)$。\n- 超额概率为 $p_u=\\mathbb{P}(Lu)$。\n- 在险价值是 $\\mathrm{VaR}_\\alpha$，即 $L$ 在 $\\alpha \\in (0,1)$ 且 $\\alpha  1-p_u$ 时的 $\\alpha$-分位数。\n- 期望亏损是 $\\mathrm{ES}_\\alpha=\\mathbb{E}[L\\mid L\\mathrm{VaR}_\\alpha]$。\n- 真实模型具有 Fréchet 类型的尾部，$\\xi=\\xi_{\\text{true}} \\in (0,1)$。\n- 错误设定的模型具有 Gumbel 类型的尾部，$\\xi=0$。\n- 参数 $u$、$p_u$ 和 $\\beta$ 保持不变。\n- 任务是计算比率 $R=\\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}}$。\n- 测试用例以元组 $(u, p_u, \\beta, \\xi_{\\text{true}}, \\alpha)$ 的形式提供。\n\n该问题是有效的。它是超阈值峰值 (POT) 方法论的标准应用，建立在公认的数学和统计原理之上。所有定义和条件都是标准的、完整的且一致的。条件 $\\alpha  1-p_u$ 确保了 $\\mathrm{VaR}_\\alpha  u$，将分位数置于由 GPD 建模的尾部区域。条件 $\\xi_{\\text{true}}  1$ 确保了 GPD 的一阶矩，从而期望亏损是有限的。我们继续进行求解。\n\n推导分三个阶段进行：首先，我们推导 $\\mathrm{VaR}_\\alpha$ 的一般表达式；其次，我们推导 $\\mathrm{ES}_\\alpha$ 的一般表达式；第三，我们将这些表达式针对真实模型和错误设定模型进行特化，并构造比率。\n\n**1. 在险价值 ($\\mathrm{VaR}_\\alpha$) 的推导**\n\nPOT 模型将 $L$ 的无条件尾部与超额量 $Y$ 的条件分布联系起来。对于任何损失水平 $l  u$，$L$ 的尾部概率由下式给出：\n$$ \\mathbb{P}(L  l) = \\mathbb{P}(L  l \\mid L  u) \\cdot \\mathbb{P}(L  u) $$\n这可以用超额量 $Y = L - u$ 及其生存函数 $S_Y(y) = 1 - F_Y(y)$ 来表示：\n$$ \\mathbb{P}(L  l) = \\mathbb{P}(Y  l - u) \\cdot p_u = S_Y(l-u) \\cdot p_u $$\n根据定义，$\\mathrm{VaR}_\\alpha$ 是使得 $\\mathbb{P}(L  \\mathrm{VaR}_\\alpha) = 1-\\alpha$ 成立的值。我们有：\n$$ 1-\\alpha = S_Y(\\mathrm{VaR}_\\alpha - u) \\cdot p_u $$\n$$ S_Y(\\mathrm{VaR}_\\alpha - u) = \\frac{1-\\alpha}{p_u} $$\n令 $y_\\alpha = \\mathrm{VaR}_\\alpha - u$。值 $y_\\alpha$ 是 GPD 对应于概率 $q = 1 - \\frac{1-\\alpha}{p_u}$ 的分位数。GPD 的逆累积分布函数（分位数函数）$F_Y^{-1}(q) = y$ 为：\n$$ y = \\begin{cases} \\frac{\\beta}{\\xi}\\left((1-q)^{-\\xi} - 1\\right)  \\text{如果 } \\xi \\neq 0 \\\\ -\\beta \\ln(1-q)  \\text{如果 } \\xi = 0 \\end{cases} $$\n代入 $1-q = \\frac{1-\\alpha}{p_u}$ 可得 $y_\\alpha$ 的表达式：\n$$ y_\\alpha = \\begin{cases} \\frac{\\beta}{\\xi}\\left(\\left(\\frac{1-\\alpha}{p_u}\\right)^{-\\xi} - 1\\right) = \\frac{\\beta}{\\xi}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi} - 1\\right)  \\text{如果 } \\xi \\neq 0 \\\\ -\\beta \\ln\\left(\\frac{1-\\alpha}{p_u}\\right) = \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right)  \\text{如果 } \\xi = 0 \\end{cases} $$\n最后，由于 $\\mathrm{VaR}_\\alpha = u + y_\\alpha$，我们得到 $\\mathrm{VaR}_\\alpha$ 的公式。\n\n**2. 期望亏损 ($\\mathrm{ES}_\\alpha$) 的推导**\n\n$\\mathrm{ES}_\\alpha$ 被定义为条件期望 $\\mathbb{E}[L \\mid L  \\mathrm{VaR}_\\alpha]$。由于 $\\mathrm{VaR}_\\alpha  u$，条件 $L  \\mathrm{VaR}_\\alpha$ 意味着 $L  u$。因此，我们可以将 $L$ 表示为 $u+Y$：\n$$ \\mathrm{ES}_\\alpha = \\mathbb{E}[u+Y \\mid u+Y  \\mathrm{VaR}_\\alpha] = u + \\mathbb{E}[Y \\mid Y  \\mathrm{VaR}_\\alpha - u] = u + \\mathbb{E}[Y \\mid Y  y_\\alpha]$$\n条件期望 $\\mathbb{E}[Y \\mid Y  y_\\alpha]$ 可以用 GPD 的平均超额函数 $e(z) = \\mathbb{E}[Y-z \\mid Y  z]$ 来表示。\n$$ \\mathbb{E}[Y \\mid Y  y_\\alpha] = y_\\alpha + \\mathbb{E}[Y-y_\\alpha \\mid Y  y_\\alpha] = y_\\alpha + e(y_\\alpha) $$\n因此，$\\mathrm{ES}_\\alpha = u + y_\\alpha + e(y_\\alpha) = \\mathrm{VaR}_\\alpha + e(\\mathrm{VaR}_\\alpha - u)$。对于 $\\xi  1$ 的 GPD，其平均超额函数为：\n$$ e(z) = \\frac{\\beta + \\xi z}{1-\\xi} $$\n对于 $\\xi=0$ 的特殊情况（指数分布），该式简化为 $e(z) = \\beta$，这与无记忆性是一致的。\n将此代入 $\\mathrm{ES}_\\alpha$ 的表达式中：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi(\\mathrm{VaR}_\\alpha - u)}{1-\\xi} $$\n通过代入已推导出的 $\\mathrm{VaR}_\\alpha - u = y_\\alpha$ 的形式，可以获得一个简化的表达式：\n$$ \\mathrm{ES}_\\alpha = \\mathrm{VaR}_\\alpha + \\frac{\\beta + \\xi y_\\alpha}{1-\\xi} $$\n\n**3. 真实模型和错误设定模型的设定**\n\n我们现在将这些通用公式应用于两种场景。令 $Z = \\frac{p_u}{1-\\alpha}$。\n\n_真实模型：_ $\\xi = \\xi_{\\text{true}} \\in (0, 1)$\n$$ \\mathrm{VaR}_\\alpha^{\\text{true}} = u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}(\\mathrm{VaR}_\\alpha^{\\text{true}} - u)}{1-\\xi_{\\text{true}}} $$\n代入 $\\mathrm{VaR}_\\alpha^{\\text{true}} - u$：\n$$ \\mathrm{ES}_\\alpha^{\\text{true}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\xi_{\\text{true}}\\left(\\frac{\\beta}{\\xi_{\\text{true}}}\\left(Z^{\\xi_{\\text{true}}} - 1\\right)\\right)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta + \\beta(Z^{\\xi_{\\text{true}}} - 1)}{1-\\xi_{\\text{true}}} = \\mathrm{VaR}_\\alpha^{\\text{true}} + \\frac{\\beta Z^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}} $$\n\n_错误设定模型：_ $\\xi = 0$\n$$ \\mathrm{VaR}_\\alpha^{\\text{mis}} = u + \\beta \\ln(Z) $$\n$$ \\mathrm{ES}_\\alpha^{\\text{mis}} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\frac{\\beta + 0 \\cdot (\\mathrm{VaR}_\\alpha^{\\text{mis}} - u)}{1-0} = \\mathrm{VaR}_\\alpha^{\\text{mis}} + \\beta $$\n\n因此，错误设定比率 $R$ 为：\n$$ R = \\frac{\\mathrm{ES}_\\alpha^{\\text{mis}}}{\\mathrm{ES}_\\alpha^{\\text{true}}} = \\frac{u + \\beta \\ln\\left(\\frac{p_u}{1-\\alpha}\\right) + \\beta}{u + \\frac{\\beta}{\\xi_{\\text{true}}}\\left(\\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}} - 1\\right) + \\frac{\\beta \\left(\\frac{p_u}{1-\\alpha}\\right)^{\\xi_{\\text{true}}}}{1-\\xi_{\\text{true}}}} $$\n我们应用这些公式来计算每个测试用例所需的比率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the misspecification ratio R = ES_mis / ES_true for several test cases.\n    \"\"\"\n    # Test cases: (u, p_u, beta, xi_true, alpha)\n    test_cases = [\n        (1.0, 0.05, 1.5, 0.3, 0.99),\n        (1.0, 0.10, 0.7, 0.05, 0.98),\n        (0.5, 0.02, 1.0, 0.9, 0.999),\n        (2.0, 0.01, 0.8, 0.4, 0.995)\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        u, p_u, beta, xi_true, alpha = case\n        \n        # Helper term Z\n        z_factor = p_u / (1 - alpha)\n\n        # --- True Model Calculation (xi = xi_true  0) ---\n        \n        # Power term for true model\n        z_pow_xi = np.power(z_factor, xi_true)\n        \n        # VaR_true\n        var_true = u + (beta / xi_true) * (z_pow_xi - 1)\n        \n        # ES_true\n        # The formula derived is ES_true = VaR_true + (beta * Z^xi_true) / (1 - xi_true)\n        es_true = var_true + (beta * z_pow_xi) / (1 - xi_true)\n\n        # --- Misspecified Model Calculation (xi = 0) ---\n        \n        # VaR_mis\n        # The formula is VaR_mis = u + beta * log(Z)\n        var_mis = u + beta * np.log(z_factor)\n\n        # ES_mis\n        # The formula is ES_mis = VaR_mis + beta\n        es_mis = var_mis + beta\n        \n        # --- Ratio Calculation ---\n        ratio = es_mis / es_true\n        results.append(f\"{ratio:.6f}\") # Format to 6 decimal places\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2391806"}, {"introduction": "在掌握了GPD的模拟方法并理解了其形状参数 $\\xi$ 对风险评估的巨大影响后，一个自然而然的问题是：我们如何从真实数据中推断 $\\xi$ 的值？本练习将为你介绍一种强大的统计推断工具——似然比检验（Likelihood-Ratio Test, LRT）。你将运用LRT来检验一个重要的零假设 $H_0: \\xi = 0$，即判断数据尾部是否可以用更简单的指数分布来描述，从而为模型选择提供坚实的统计依据。[@problem_id:2397475]", "problem": "您需要设计并实现一个程序，该程序针对代表比特币区块发现的到达间隔时间的合成样本，通过拟合广义帕累托分布（GPD）并检验GPD形状参数是否为零，来评估高阈值超额分布是否与指数模型一致。该场景依赖于以下基本建模基础：在强度恒定的齐次泊松过程中，到达间隔时间呈指数分布；对于足够高的阈值，超出阈值的分布可通过广义帕累托分布（GPD）建模。指数分布对应于形状参数为零的GPD。您必须使用此基础来推导适当的基于似然的推断。\n\n需为每个测试用例实现的任务：\n- 根据指定的数据生成过程，生成一个大小为 $n$ 的独立同分布的非负到达间隔时间样本。两种可能的数据生成过程是：\n  - 均值为 $m$ 的指数分布。\n  - 形状参数为 $\\xi$、尺度参数为 $\\beta$ 的广义帕累托分布 (GPD)。\n- 计算经验阈值 $u$ 作为样本的 $q$-分位数，其中给定了 $q \\in (0,1)$。\n- 构建超额量 $Y = \\{X_i - u : X_i  u\\}$。\n- 通过最大似然估计（MLE）将GPD拟合到 $Y$，并将位置参数固定为零，记录估计出的形状参数 $\\hat{\\xi}$。\n- 使用似然比检验（LRT），在显著性水平 $\\alpha$ 下，检验原假设 $H_0\\!:\\, \\xi = 0$ 与双边备择假设 $H_1\\!:\\, \\xi \\neq 0$。根据自由度为1的渐近卡方分布计算p值。\n- 为每个测试用例生成三元组 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$，其中 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 是浮点数，$\\text{reject}$ 是一个布尔值，如果在水平 $\\alpha$ 下拒绝原假设，则为true，否则为false。\n\n重要的实现和输出细节：\n- 您的代码必须是完全确定性的。使用给定的种子初始化随机数生成器，并可复现地抽取所有随机样本。\n- 单位：在合成数据中，到达间隔时间可解释为以秒为单位，但您无需报告任何带单位的量。所有要求的输出都是无量纲的。\n- 最终输出必须是单行文本，包含一个列表的列表，每个内部列表对应一个测试用例，形式为 $[\\hat{\\xi}, \\text{p\\_value}, \\text{reject}]$。整个输出必须严格以单个Python风格的列表字面量形式打印，例如，`[[x_1, p_1, True], [x_2, p_2, False], ...]`。在打印输出中，将浮点数 $\\hat{\\xi}$ 和 $\\text{p\\_value}$ 四舍五入到 $6$ 位小数。\n\n需实现和评估的测试套件：\n- 案例 1：种子 $= 12345$，分布 $=$ 均值为 $m = 600$ 的指数分布，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 案例 2：种子 $= 54321$，分布 $=$ GPD，其中 $\\xi = 0.25$ 且 $\\beta = 600$，样本大小 $n = 5000$，阈值分位数 $q = 0.80$，显著性水平 $\\alpha = 0.05$。\n- 案例 3：种子 $= 20231105$，分布 $=$ GPD，其中 $\\xi = 0.05$ 且 $\\beta = 600$，样本大小 $n = 6000$，阈值分位数 $q = 0.85$，显著性水平 $\\alpha = 0.05$。\n- 案例 4：种子 $= 314159$，分布 $=$ 均值为 $m = 600$ 的指数分布，样本大小 $n = 3000$，阈值分位数 $q = 0.98$，显著性水平 $\\alpha = 0.05$。\n\n您的程序应生成单行输出，其中包含按上述四个案例顺序排列的结果，以Python风格的列表的列表形式呈现，例如：\n$[[\\hat{\\xi}_1,\\text{p\\_value}_1,\\text{reject}_1],[\\hat{\\xi}_2,\\text{p\\_value}_2,\\text{reject}_2],[\\hat{\\xi}_3,\\text{p\\_value}_3,\\text{reject}_3],[\\hat{\\xi}_4,\\text{p\\_value}_4,\\text{reject}_4]]$。", "solution": "该问题要求实现一个统计程序，以验证到达间隔时间数据集是否与指数分布一致。该方法论植根于极值理论（EVT），特别是超阈值峰值（POT）方法。其核心原理是，对于广义的随机变量，超过一个足够高阈值的值的分布可以由广义帕累托分布（GPD）近似。GPD的一个特例，即形状参数 $\\xi$ 等于零时，对应于指数分布。我们将利用这一事实来构建假设检验。\n\n每个测试用例的程序如下：\n$1$. 根据指定的参数生成一个到达间隔时间的合成样本。\n$2$. 以样本的分位数作为经验方法，确定一个高阈值 $u$。\n$3$. 收集超过此阈值的超额量 $Y = X_i - u$。\n$4$. 使用最大似然估计（MLE）将GPD拟合到这些超额量。\n$5$. 进行似然比检验（LRT），以检验原假设 $H_0: \\xi = 0$ 与备择假设 $H_1: \\xi \\neq 0$。\n\n让我们首先建立理论基础。\n\n**1. 广义帕累托分布 (GPD)**\nGPD是一个双参数分布族，用于对其他分布的尾部进行建模。当位置参数固定为零时，其对于观测值 $y$ 的概率密度函数（PDF）$f(y; \\xi, \\beta)$ 由下式给出：\n$$\nf(y; \\xi, \\beta) =\n\\begin{cases}\n\\frac{1}{\\beta} \\left(1 + \\frac{\\xi y}{\\beta}\\right)^{-\\frac{1}{\\xi}-1}  \\text{if } \\xi \\neq 0 \\\\\n\\frac{1}{\\beta} \\exp\\left(-\\frac{y}{\\beta}\\right)  \\text{if } \\xi = 0\n\\end{cases}\n$$\n其中 $\\xi$ 是形状参数，$\\beta  0$ 是尺度参数。当 $\\xi \\ge 0$ 时，支撑集为 $y \\ge 0$；当 $\\xi  0$ 时，支撑集为 $0 \\le y \\le -\\beta/\\xi$。$\\xi=0$ 的情况恰好是均值为 $\\beta$ 的指数分布。这种关系是我们检验的基石。\n\n**2. 最大似然估计 (MLE)**\n给定一个包含 $N_u$ 个超额量的样本 $Y = \\{y_1, y_2, \\dots, y_{N_u}\\}$，对数似然函数 $\\ell(\\xi, \\beta | Y)$ 是每个观测值的对数PDF之和：\n$$ \\ell(\\xi, \\beta | Y) = \\sum_{i=1}^{N_u} \\ln f(y_i; \\xi, \\beta) $$\n对于 $\\xi \\neq 0$，该函数为：\n$$ \\ell(\\xi, \\beta) = -N_u \\ln \\beta - \\left(\\frac{1}{\\xi} + 1\\right) \\sum_{i=1}^{N_u} \\ln\\left(1 + \\frac{\\xi y_i}{\\beta}\\right) $$\n最大似然估计 $(\\hat{\\xi}, \\hat{\\beta})$ 是使该函数最大化的参数值。这是一个我们将使用计算库解决的数值优化问题。\n\n**3. 似然比检验 (LRT)**\n我们希望检验原假设 $H_0: \\xi = 0$ 与双边备择假设 $H_1: \\xi \\neq 0$。LRT统计量 $\\Lambda$ 定义为无约束模型的最大对数似然与受原假设约束的模型的最大对数似然之差的两倍：\n$$ \\Lambda = 2 \\left( \\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) - \\sup_{\\beta} \\ell(0, \\beta | Y) \\right) $$\n第一项 $\\sup_{\\xi, \\beta} \\ell(\\xi, \\beta | Y) = \\ell(\\hat{\\xi}, \\hat{\\beta} | Y)$ 是在无约束MLEs $(\\hat{\\xi}, \\hat{\\beta})$ 处计算的对数似然。\n\n第二项 $\\sup_{\\beta} \\ell(0, \\beta | Y)$ 是在 $H_0$ 下模型的对数似然，其中 $\\xi=0$。这是一个指数模型。其对数似然为：\n$$ \\ell(0, \\beta | Y) = -N_u \\ln \\beta - \\frac{1}{\\beta} \\sum_{i=1}^{N_u} y_i $$\n在 $H_0$ 下，$\\beta$ 的MLE，记为 $\\hat{\\beta}_0$，通过将关于 $\\beta$ 的导数设为零得到，结果是超额量的样本均值：\n$$ \\hat{\\beta}_0 = \\frac{1}{N_u} \\sum_{i=1}^{N_u} y_i = \\bar{y} $$\n因此，受约束的最大对数似然为 $\\ell(0, \\hat{\\beta}_0 | Y)$。\n\n根据威尔克斯定理，在原假设下，LRT统计量 $\\Lambda$ 渐近服从卡方分布，其自由度等于在 $H_0$ 下固定的参数数量。在我们的案例中，固定了一个参数（$\\xi$），所以 $\\Lambda \\sim \\chi^2_1$。\n\n检验的p值是在假设 $H_0$ 为真的情况下，观测到至少与计算出的检验统计量一样极端的检验统计量的概率：\n$$ \\text{p-value} = P(\\chi^2_1 \\ge \\Lambda) $$\n如果p值小于指定的显著性水平 $\\alpha$，我们拒绝原假设 $H_0$，并得出数据与指数尾部模型不一致的结论。\n\n**算法与实现**\n\n每个测试用例的计算程序如下：\n$1$. **可复现性**：为确保结果的确定性，为每个案例使用指定的种子初始化一个随机数生成器。我们使用 `numpy.random.default_rng`。\n$2$. **数据生成**：\n   - 对于均值为 $m$ 的指数分布，我们使用 `rng.exponential(scale=m, size=n)` 生成 $n$ 个样本。\n   - 对于形状为 $\\xi$、尺度为 $\\beta$ 的GPD，我们使用 `scipy.stats.genpareto.rvs(c=xi, scale=beta, size=n, random_state=rng)` 生成 $n$ 个样本。\n$3$. **阈值处理**：使用 `numpy.quantile` 将生成样本 $X$ 的第 $q$ 个分位数计算为经验阈值 $u$。然后通过取所有 $X_i  u$ 并减去阈值来形成超额样本 $Y=\\{X_i - u | X_i  u\\}$。\n$4$. **无约束MLE**：通过数值最大化对数似然，从样本 $Y$ 中估计GPD参数 $(\\hat{\\xi}, \\hat{\\beta})$。我们使用 `scipy.stats.genpareto.fit(Y, floc=0)` 来执行此操作，将位置参数固定为 $0$。这会产生无约束估计值 $\\hat{\\xi}$ 和 $\\hat{\\beta}$。\n$5$. **受约束MLE**：在 $H_0: \\xi=0$ 下，分布是指数分布。尺度参数的MLE $\\hat{\\beta}_0$ 是 $Y$ 的样本均值，通过 `numpy.mean(Y)` 计算。\n$6$. **LRT计算**：\n   - 无约束对数似然 $\\ell(\\hat{\\xi}, \\hat{\\beta})$ 使用估计的参数计算：$\\sum \\ln f(y_i; \\hat{\\xi}, \\hat{\\beta})$。\n   - 受约束对数似然 $\\ell(0, \\hat{\\beta}_0)$ 类似地计算：$\\sum \\ln f(y_i; 0, \\hat{\\beta}_0)$。\n   - 检验统计量是 $\\Lambda = 2(\\ell(\\hat{\\xi}, \\hat{\\beta}) - \\ell(0, \\hat{\\beta}_0))$。为处理可能导致小的负值的数值不准确性，我们取 $\\max(0, \\Lambda)$。\n$7$. **P值和决策**：p值从 $\\chi^2_1$ 分布的生存函数计算得出，即 `scipy.stats.chi2.sf(\\Lambda, df=1)`。如果 $\\text{p-value}  \\alpha$，则拒绝原假设。\n$8$. **输出格式化**：收集每个案例产生的三元组 $[\\hat{\\xi}, \\text{p-value}, \\text{reject}]$。浮点值格式化为 $6$ 位小数，并组装成所需的最终字符串表示形式。\n\n这种严谨的、理论驱动的方法确保了对所述问题的正确和可复现的解决方案。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and produce the final output.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {'case_id': 1, 'seed': 12345, 'dist': 'exponential', 'params': {'m': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 2, 'seed': 54321, 'dist': 'gpd', 'params': {'xi': 0.25, 'beta': 600}, 'n': 5000, 'q': 0.80, 'alpha': 0.05},\n        {'case_id': 3, 'seed': 20231105, 'dist': 'gpd', 'params': {'xi': 0.05, 'beta': 600}, 'n': 6000, 'q': 0.85, 'alpha': 0.05},\n        {'case_id': 4, 'seed': 314159, 'dist': 'exponential', 'params': {'m': 600}, 'n': 3000, 'q': 0.98, 'alpha': 0.05},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Step 1: Initialize RNG for reproducibility\n        rng = np.random.default_rng(case['seed'])\n\n        # Step 2: Generate sample data\n        if case['dist'] == 'exponential':\n            m = case['params']['m']\n            sample_X = rng.exponential(scale=m, size=case['n'])\n        elif case['dist'] == 'gpd':\n            xi, beta = case['params']['xi'], case['params']['beta']\n            # Use scipy's GPD generator, passing the numpy RNG\n            sample_X = stats.genpareto.rvs(c=xi, scale=beta, size=case['n'], random_state=rng)\n\n        # Step 3: Compute threshold and form exceedances\n        u = np.quantile(sample_X, case['q'])\n        exceedances = sample_X[sample_X > u]\n        sample_Y = exceedances - u\n        \n        # Guard against cases with no exceedances\n        if len(sample_Y) == 0:\n            results.append([float('nan'), float('nan'), False])\n            continue\n            \n        # Step 4: Fit GPD to Y (unrestricted model)\n        # floc=0 fixes the location parameter to 0\n        xi_hat, _, beta_hat = stats.genpareto.fit(sample_Y, floc=0)\n\n        # Step 5: Calculate unrestricted log-likelihood\n        log_lik_unrestricted = np.sum(stats.genpareto.logpdf(sample_Y, c=xi_hat, scale=beta_hat, loc=0))\n\n        # Step 6: Fit GPD under H0: xi=0 (restricted model - exponential)\n        # For exponential dist, the MLE of scale is the mean\n        beta_hat_h0 = np.mean(sample_Y)\n        \n        # Step 7: Calculate restricted log-likelihood\n        # GPD with c=0 is exponential\n        log_lik_restricted = np.sum(stats.genpareto.logpdf(sample_Y, c=0, scale=beta_hat_h0, loc=0))\n\n        # Step 8: Compute the Likelihood-Ratio Test statistic\n        lrt_statistic = 2 * (log_lik_unrestricted - log_lik_restricted)\n        # LRT statistic must be non-negative. Small negative values can arise from numerical precision issues.\n        lrt_statistic = max(0, lrt_statistic)\n\n        # Step 9: Compute p-value from chi-square distribution with 1 dof\n        p_value = stats.chi2.sf(lrt_statistic, df=1)\n\n        # Step 10: Decide whether to reject H0\n        reject_h0 = p_value  case['alpha']\n\n        results.append([xi_hat, p_value, reject_h0])\n\n    # Final print statement in the exact required format.\n    # Format each inner list into a string, then join them.\n    formatted_results = []\n    for res in results:\n        xi_str = f\"{res[0]:.6f}\"\n        pval_str = f\"{res[1]:.6f}\"\n        reject_str = str(res[2]) # Converts True to 'True', False to 'False'\n        formatted_results.append(f\"[{xi_str},{pval_str},{reject_str}]\")\n        \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2397475"}]}