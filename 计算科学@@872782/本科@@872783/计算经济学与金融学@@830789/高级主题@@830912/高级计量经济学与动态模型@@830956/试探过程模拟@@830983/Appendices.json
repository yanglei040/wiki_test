{"hands_on_practices": [{"introduction": "这个首个练习旨在构建一个纯交换经济中“试探”过程的基础模拟。通过采用恒定替代弹性（CES）效用函数，我们可以研究消费者在商品间进行替代的意愿——一个关键的经济参数——如何影响价格向均衡调整的速度。这项实践[@problem_id:2436189]不仅巩固了价格调整机制的核心原理，还为理解市场特征如何影响其动态过程提供了直观的认识。", "problem": "在一个纯交换经济体中，实现并分析一个离散时间的试探过程 (tâtonnement process)。该经济体包含两种商品和两位消费者，消费者的偏好遵循不变替代弹性 (Constant Elasticity of Substitution, CES) 效用函数。您的目标是比较当替代弹性参数较低和较高时，该过程的收敛速度。请使用纯数学术语进行分析，所有量均为无量纲。您编写的程序必须是一个完全可运行的脚本，并且在执行环境允许的范围内，仅使用 Python 标准库以及 NumPy 和 SciPy。\n\n考虑由 $i \\in \\{1,2\\}$ 索引的两位消费者和由 $j \\in \\{1,2\\}$ 索引的两种商品。每位消费者 $i$ 都有一个替代弹性为 $\\sigma  0$, $\\sigma \\neq 1$ 的 CES 效用函数，其形式为\n$$\nU_i(x_{i1},x_{i2};\\sigma) \\;=\\; \\left(\\alpha_i \\, x_{i1}^{\\rho} \\;+\\; (1-\\alpha_i)\\, x_{i2}^{\\rho}\\right)^{\\frac{1}{\\rho}},\n\\quad \\text{其中} \\quad \\rho \\;=\\; \\frac{\\sigma - 1}{\\sigma},\n$$\n其中权重 $\\alpha_i \\in (0,1)$。如果 $\\sigma = 1$，则将 $U_i$ 解释为柯布-道格拉斯 (Cobb–Douglas) 极限形式。\n\n每位消费者 $i$ 拥有一个禀赋向量 $e_i \\in \\mathbb{R}^2_{+}$，并面临价格 $p \\in \\mathbb{R}^2_{++}$。预算集由 $p \\cdot x_i \\leq p \\cdot e_i$ 定义，其中 $m_i = p \\cdot e_i$ 是收入。设总超额需求为\n$$\nz(p;\\sigma) \\;=\\; \\sum_{i=1}^{2} x_i(p;\\sigma, m_i) \\;-\\; \\sum_{i=1}^{2} e_i,\n\\quad \\text{其中} \\quad m_i \\;=\\; p \\cdot e_i.\n$$\n您必须通过求解效用最大化问题来计算马歇尔（未补偿）需求 $x_i(p;\\sigma,m_i)$\n$$\n\\max_{x_i \\ge 0}\\; U_i(x_{i1},x_{i2};\\sigma) \\quad \\text{受制于} \\quad p \\cdot x_i \\le m_i,\n$$\n在您的求解推导中需使用第一性原理。\n\n模拟一个离散时间的试探过程，该过程沿着超额需求的方向调整价格，同时确保价格为正和规模不变性。使用带有单纯形归一化的指数更新规则：\n$$\n\\tilde{p}_{t+1} \\;=\\; p_t \\odot \\exp\\!\\left(\\eta \\, z(p_t;\\sigma)\\right),\n\\qquad\np_{t+1} \\;=\\; \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}},\n$$\n其中 $\\odot$ 表示逐分量乘法，$\\exp(\\cdot)$ 逐分量应用，$\\eta  0$ 是一个步长，$\\mathbf{1}$ 是全一向量。从一个严格为正的价格向量 $p_0$ 开始初始化，并将其重新归一化以满足 $\\mathbf{1}^\\top p_0 = 1$。在每次迭代 $t$ 中，计算 $z(p_t;\\sigma)$。当满足以下条件的最小 $t$ 出现时停止：\n$$\n\\max_{j \\in \\{1,2\\}} \\left| z_j(p_t;\\sigma) \\right| \\;\\le\\; \\varepsilon,\n$$\n或者当达到最大迭代次数时停止。返回收敛前所用的迭代次数，如果未收敛则返回最大迭代次数。\n\n使用以下固定的经济体参数：\n- 消费者权重：$\\alpha_1 = 0.7$, $\\alpha_2 = 0.3$。\n- 禀赋：$e_1 = (1.2,\\, 0.3)$, $e_2 = (0.2,\\, 1.1)$。\n- 收敛容差：$\\varepsilon = 10^{-8}$。\n- 最大迭代次数：$100000$。\n- 每一步的价格归一化：$\\mathbf{1}^\\top p_t = 1$。\n\n测试套件：\n为以下参数集 $(\\sigma,\\eta,p_0)$ 实现并运行模拟：\n- 案例1：$(\\sigma,\\eta,p_0) = (0.5,\\, 0.10,\\, (0.5,\\, 0.5))$。\n- 案例2：$(\\sigma,\\eta,p_0) = (5.0,\\, 0.10,\\, (0.5,\\, 0.5))$。\n- 案例3：$(\\sigma,\\eta,p_0) = (0.5,\\, 0.05,\\, (0.9,\\, 0.1))$。\n- 案例4：$(\\sigma,\\eta,p_0) = (5.0,\\, 0.05,\\, (0.9,\\, 0.1))$。\n\n对于每个案例，计算满足停止标准所需的整数迭代次数。您的程序应生成单行输出，其中包含一个逗号分隔的列表，用方括号括起来（例如：$\"[123,456,789,1011]\"$），结果按案例1到4的顺序排列。\n\n您的代码必须是一个完整的、可运行的程序，它在内部执行所有计算，并且只打印指定的最终输出行。", "solution": "该问题要求为一个包含两位消费者和两种商品的纯交换经济体，实现并分析一个瓦尔拉斯试探过程 (Walrasian tâtonnement process)。消费者的偏好由不变替代弹性（CES）效用函数描述。我们的主要任务是根据第一性原理推导出必要的经济学函数，然后构建一个离散时间模拟，以找出在不同参数化条件下价格向量收敛到均衡所需的迭代次数。\n\n首先，我们必须为具有 CES 效用函数的消费者 $i$ 推导出马歇尔需求函数。效用最大化问题（UMP）表述为：\n$$\n\\max_{x_{i1}, x_{i2} \\ge 0} \\; U_i(x_{i1}, x_{i2};\\sigma) = \\left(\\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho}\\right)^{1/\\rho}\n$$\n受制于预算约束：\n$$\np_1 x_{i1} + p_2 x_{i2} \\le m_i\n$$\n其中 $p = (p_1, p_2)$ 是严格为正的价格向量，$m_i$ 是消费者的收入，$\\rho = (\\sigma - 1)/\\sigma$。由于指定的效用函数对其参数是严格递增的，因此在最优点，预算约束将以等式形式成立：$p_1 x_{i1} + p_2 x_{i2} = m_i$。\n\n为了解决效用最大化问题，从计算角度看，最大化单调变换 $U_i^\\rho$ 更为方便，因为这可以简化求导过程。这个修改后问题的相应拉格朗日函数是：\n$$\n\\mathcal{L}(x_{i1}, x_{i2}, \\lambda) = \\alpha_i x_{i1}^{\\rho} + (1-\\alpha_i) x_{i2}^{\\rho} - \\lambda (p_1 x_{i1} + p_2 x_{i2} - m_i)\n$$\n假设存在内部解（$x_{i1}0, x_{i2}0$），关于 $x_{i1}$ 和 $x_{i2}$ 的一阶条件是：\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i1}} = \\rho \\alpha_i x_{i1}^{\\rho - 1} - \\lambda p_1 = 0\n$$\n$$\n\\frac{\\partial \\mathcal{L}}{\\partial x_{i2}} = \\rho (1-\\alpha_i) x_{i2}^{\\rho - 1} - \\lambda p_2 = 0\n$$\n我们可以通过将第一个方程除以第二个方程来消去拉格朗日乘子 $\\lambda$：\n$$\n\\frac{\\alpha_i}{(1-\\alpha_i)} \\left(\\frac{x_{i1}}{x_{i2}}\\right)^{\\rho-1} = \\frac{p_1}{p_2}\n$$\n求解商品消费的比率：\n$$\n\\frac{x_{i1}}{x_{i2}} = \\left( \\frac{p_1}{p_2} \\frac{1-\\alpha_i}{\\alpha_i} \\right)^{\\frac{1}{\\rho-1}}\n$$\n使用定义 $\\rho = (\\sigma - 1)/\\sigma$，我们得到 $\\rho - 1 = -1/\\sigma$。因此，上述表达式中的指数变为 $1/(\\rho-1) = -\\sigma$。这样，关系式为：\n$$\nx_{i1} = x_{i2} \\left( \\frac{p_1}{p_2} \\right)^{-\\sigma} \\left( \\frac{\\alpha_i}{1-\\alpha_i} \\right)^{\\sigma}\n$$\n将这个 $x_{i1}$ 的表达式代入预算约束 $p_1 x_{i1} + p_2 x_{i2} = m_i$ 中，我们就可以解出 $x_{i2}$，进而解出 $x_{i1}$。这个过程得到了 CES 效用设定下的标准马歇尔需求函数。对于商品 $j \\in \\{1,2\\}$，消费者 $i$ 的需求是：\n$$\nx_{i1}(p, m_i; \\sigma) = m_i \\frac{\\alpha_i^{\\sigma} p_1^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\n$$\nx_{i2}(p, m_i; \\sigma) = m_i \\frac{(1-\\alpha_i)^{\\sigma} p_2^{-\\sigma}}{\\alpha_i^{\\sigma} p_1^{1-\\sigma} + (1-\\alpha_i)^{\\sigma} p_2^{1-\\sigma}}\n$$\n对于所有的 $p \\in \\mathbb{R}_{++}^2$ 和 $\\sigma  0$，这些表达式都是良定义的。\n\n试探过程的模拟是一个迭代算法。给定总禀赋 $E = \\sum_{i=1}^2 e_i$。该过程按迭代 $t=0, 1, 2, \\dots$ 进行如下：\n1.  用一个严格为正的价格向量 $p_0$ 进行初始化，并将其归一化，使其分量之和为1。\n2.  在每次迭代 $t$ 中，给定当前价格向量 $p_t=(p_{t,1}, p_{t,2})$：\n    a. 为每位消费者 $i$ 计算收入 $m_{i,t}$：$m_{i,t} = p_t \\cdot e_i = p_{t,1} e_{i1} + p_{t,2} e_{i2}$。\n    b. 使用推导出的公式为每位消费者计算需求向量 $x_{i}(p_t, m_{i,t}; \\sigma)$。\n    c. 计算总需求向量 $X_t = \\sum_{i=1}^2 x_{i}(p_t, m_{i,t}; \\sigma)$。\n    d. 计算总超额需求向量 $z(p_t; \\sigma) = X_t - E$。根据瓦尔拉斯法则 (Walras's law)，必然有 $p_t \\cdot z(p_t; \\sigma) = 0$。\n3.  检查收敛性。如果超额需求向量的无穷范数低于容差 $\\varepsilon$：$\\max_j |z_j(p_t; \\sigma)| \\le \\varepsilon$，则过程终止。如果满足此条件，则将收敛所需的迭代次数记录为 $t$。\n4.  如果系统尚未收敛，则更新价格向量。使用指数更新规则逐分量计算一个中间的、未归一化的价格向量 $\\tilde{p}_{t+1}$：\n    $$\n    \\tilde{p}_{t+1, j} = p_{t,j} \\exp(\\eta \\, z_j(p_t; \\sigma)) \\quad \\text{对于 } j \\in \\{1,2\\}\n    $$\n    其中 $\\eta  0$ 是一个固定的步长参数。此更新规则确保新的价格向量保持严格为正。\n5.  下一次迭代的新价格向量 $p_{t+1}$ 是通过将 $\\tilde{p}_{t+1}$ 归一化到标准单纯形上得到的：\n    $$\n    p_{t+1} = \\frac{\\tilde{p}_{t+1}}{\\mathbf{1}^\\top \\tilde{p}_{t+1}} = \\frac{\\tilde{p}_{t+1}}{\\tilde{p}_{t+1,1} + \\tilde{p}_{t+1,2}}\n    $$\n6.  然后，过程从第2步开始重复，索引 $t$ 递增。如果迭代次数达到指定的最大值 $100000$，模拟将停止并报告此最大值，表示在分配的步数内未实现收敛。\n\n所提供的数值实现将精确地编码此算法。利用 NumPy 库的向量和矩阵运算来高效计算收入、需求和超额需求。经济体的固定参数（$\\alpha_i, e_i$）和模拟参数（$\\sigma, \\eta, p_0, \\varepsilon, \\text{max\\_iter}$）均按照问题陈述中的规定进行定义。对四个测试案例中的每一个都执行模拟，并收集收敛所需的迭代次数以用于最终输出。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to orchestrate the simulation for all test cases.\n    \"\"\"\n\n    # --- Fixed Economy and Simulation Parameters ---\n    # Consumer preference weights (alpha_1, alpha_2)\n    ALPHA = np.array([0.7, 0.3])\n    # Consumer endowments e_i = (e_i1, e_i2)\n    ENDOWMENTS = np.array([[1.2, 0.3], [0.2, 1.1]])\n    # Convergence tolerance\n    EPSILON = 1e-8\n    # Maximum number of iterations\n    MAX_ITER = 100000\n    # Aggregate endowments E = (E_1, E_2)\n    E_AGG = np.sum(ENDOWMENTS, axis=0)\n\n    # --- Test Cases ---\n    # Each case is a tuple: (sigma, eta, p0)\n    test_cases = [\n        (0.5, 0.10, (0.5, 0.5)),\n        (5.0, 0.10, (0.5, 0.5)),\n        (0.5, 0.05, (0.9, 0.1)),\n        (5.0, 0.05, (0.9, 0.1)),\n    ]\n\n    def calculate_excess_demand(p, sigma):\n        \"\"\"\n        Calculates the aggregate excess demand vector for a given price vector and elasticity.\n\n        Args:\n            p (np.ndarray): Price vector of shape (2,).\n            sigma (float): Elasticity of substitution.\n\n        Returns:\n            np.ndarray: Aggregate excess demand vector of shape (2,).\n        \"\"\"\n        # Calculate incomes for each consumer: m_i = p . e_i\n        # ENDOWMENTS is (2, 2), p is (2,). Result is a (2,) vector of incomes.\n        incomes = ENDOWMENTS @ p\n\n        # Prepare matrices for vectorized demand calculation.\n        # alpha_matrix[i, j] is the weight consumer i gives to good j.\n        alpha_matrix = np.array([ALPHA, 1 - ALPHA]).T\n\n        # Numerator term: alpha_ij^sigma * p_j^(-sigma)\n        p_pow_neg_sigma = p**(-sigma)       # element-wise power\n        alpha_pow_sigma = alpha_matrix**sigma # element-wise power\n        numerators = alpha_pow_sigma * p_pow_neg_sigma # broadcasting (2,2) * (2,)\n\n        # Denominator term: D_i = sum_j alpha_ij^sigma * p_j^(1-sigma)\n        p_pow_1_minus_sigma = p**(1 - sigma)\n        # Using dot product with ones vector for summation over j\n        denominators = (alpha_pow_sigma * p_pow_1_minus_sigma) @ np.ones(2)\n\n        # Calculate Marshallian demands: x_ij = m_i * Numerator_ij / Denominator_i\n        # Use np.newaxis to align dimensions for broadcasting correctly.\n        demands = (incomes[:, np.newaxis] * numerators) / denominators[:, np.newaxis]\n\n        # Aggregate demand and excess demand\n        X_agg = np.sum(demands, axis=0)\n        z = X_agg - E_AGG\n        \n        return z\n\n    def run_simulation(sigma, eta, p0):\n        \"\"\"\n        Runs the tâtonnement process simulation for a given parameter set.\n\n        Args:\n            sigma (float): Elasticity of substitution.\n            eta (float): Step size for price updates.\n            p0 (tuple): Initial price vector.\n\n        Returns:\n            int: Number of iterations to converge, or MAX_ITER if not converged.\n        \"\"\"\n        # Initialize and normalize the price vector.\n        p = np.array(p0, dtype=np.float64)\n        p /= np.sum(p)\n\n        for t in range(MAX_ITER):\n            # Calculate excess demand at current price p_t\n            z = calculate_excess_demand(p, sigma)\n\n            # Check for convergence\n            if np.max(np.abs(z)) = EPSILON:\n                return t\n\n            # Update prices using the exponential rule\n            p_tilde = p * np.exp(eta * z)\n            \n            # Normalize to get the price vector for the next iteration\n            p = p_tilde / np.sum(p_tilde)\n        \n        # After MAX_ITER iterations, check for convergence one last time.\n        z = calculate_excess_demand(p, sigma)\n        if np.max(np.abs(z)) = EPSILON:\n            return MAX_ITER\n\n        # If the loop finishes without converging, return MAX_ITER.\n        return MAX_ITER\n\n    # Execute simulation for all test cases and collect results.\n    results = []\n    for sigma_val, eta_val, p0_val in test_cases:\n        iterations = run_simulation(sigma_val, eta_val, p0_val)\n        results.append(iterations)\n\n    # Print results in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2436189"}, {"introduction": "真实世界中的价格通常不会对供需的每一次微小失衡都立即做出调整。本练习将“粘性价格”这一概念引入我们的“试探”模型中，即只有当超额需求足够大以至于超过某个阈值时，价格才会发生变化。通过模拟这一情景[@problem_id:2436152]，我们可以探索市场摩擦如何减缓或改变通往均衡的路径，从而为价格动态提供一个更加细致入微的视角。", "problem": "考虑一个纯交换经济体，其中有 $I = 2$ 个代理人和 $G = 3$ 种商品。每个代理人 $i \\in \\{1,2\\}$ 对这些商品拥有一个柯布-道格拉斯效用函数，其指数 $\\alpha_{ig}$ 满足 $\\sum_{g=1}^{3} \\alpha_{ig} = 1$ 且对于所有 $g$ 都有 $\\alpha_{ig} \\in (0,1)$。代理人 $i$ 被赋予一个严格为正的商品向量 $\\mathbf{e}_i \\in \\mathbb{R}_{++}^{3}$。令总禀赋为 $\\mathbf{E} = \\sum_{i=1}^{2} \\mathbf{e}_i$。价格由一个严格为正的向量 $\\mathbf{p} \\in \\mathbb{R}_{++}^{3}$ 表示，其中第一种商品被用作计价物，因此始终有 $p_1 \\equiv 1$。\n\n给定一个价格向量 $\\mathbf{p}$，代理人 $i$ 的收入为 $m_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i$。对于柯布-道格拉斯偏好，代理人 $i$ 对商品 $g$ 的个人需求为 $x_{ig}(\\mathbf{p}) = \\alpha_{ig} \\, m_i(\\mathbf{p}) / p_g$。商品 $g$ 的总需求为 $X_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})$，超额需求为 $Z_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g$。市场出清要求在均衡价格 $\\mathbf{p}^*$ 下，对所有商品 $g$ 都有 $Z_g(\\mathbf{p}^*) = 0$，并以 $p_1^* = 1$ 作为规范化。\n\n您将模拟一个带有粘性价格的离散时间拍卖调整（价格调整）过程。令 $t \\in \\{0,1,2,\\dots\\}$ 为迭代的索引。对于给定的步长 $\\gamma  0$ 和粘性阈值 $\\delta \\ge 0$，价格按如下方式更新：\n- 计价物价格是固定的：对于所有 $t$，$p_1^{t+1} = 1$。\n- 对于每种非计价物商品 $g \\in \\{2,3\\}$，\n  - 如果 $\\lvert Z_g(\\mathbf{p}^t) \\rvert  \\delta$，则 \n    $$\n    p_g^{t+1} = \\max\\{\\varepsilon, \\, p_g^t \\, (1 + \\gamma \\, Z_g(\\mathbf{p}^t))\\},\n    $$\n    其中 $\\varepsilon  0$ 是一个用于强制保持正值的小常数。\n  - 否则，$p_g^{t+1} = p_g^t$（由于粘性而不变）。\n当 $\\max_{g \\in \\{1,2,3\\}} \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$ 时，宣布收敛，其中 $\\tau  0$ 是一个容差。如果在 $T_{\\max}$ 次迭代内未达到收敛，则过程停止并宣布未收敛。\n\n使用以下校准的经济体：\n- 柯布-道格拉斯指数：\n  - 代理人1：$(\\alpha_{11}, \\alpha_{12}, \\alpha_{13}) = (0.5, 0.3, 0.2)$。\n  - 代理人2：$(\\alpha_{21}, \\alpha_{22}, \\alpha_{23}) = (0.2, 0.4, 0.4)$。\n- 禀赋：\n  - 代理人1：$\\mathbf{e}_1 = (1.0, 0.5, 0.5)$。\n  - 代理人2：$\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = (1.5, 1.5, 1.0)$。\n- 所有模拟的固定参数：正值下限 $\\varepsilon = 10^{-8}$，收敛容差 $\\tau = 10^{-6}$。\n- 初始价格向量 $\\mathbf{p}^0$ 总是指定 $p_1^0 = 1$。\n\n为以下测试用例集实现模拟。每个测试用例是一个具有明确值的元组 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$：\n- 情况 $\\mathrm{A}$（基准，无粘性）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.0, 5000, [1.0, 1.0, 1.0])$。\n- 情况 $\\mathrm{B}$（中度粘性，非均衡起点）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.15, 0.1, 5000, [1.0, 0.7, 1.3])$。\n- 情况 $\\mathrm{C}$（高度粘性，实际冻结）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 1.0, 10, [1.0, 1.0, 1.0])$。\n- 情况 $\\mathrm{D}$（等式处的边界粘性）：$(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0) = (0.2, 0.2, 10, [1.0, 1.0, 1.0])$。\n\n对您的程序的要求：\n- 在每次迭代中，根据基本原理精确计算上面定义的 $Z_g(\\mathbf{p})$。\n- 严格按照指定的方式应用粘性拍卖调整规则，以严格不等式 $\\lvert Z_g \\rvert  \\delta$ 触发更新。\n- 始终保持 $p_1 \\equiv 1$。\n- 如果满足收敛条件 $\\max_g \\lvert Z_g(\\mathbf{p}^t) \\rvert \\le \\tau$，则提前停止。\n- 对于每个测试用例，生成一个形式为 $[N, B, [p_1, p_2, p_3]]$ 的结果，其中：\n  - $N$ 是实际执行的迭代次数（介于 $0$ 和 $T_{\\max}$ 之间）的整数。\n  - $B$ 是一个布尔值，如果宣布收敛则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n  - $[p_1, p_2, p_3]$ 是四舍五入到六位小数的最终价格向量。\n- 最终输出格式：您的程序应生成单行输出，其中包含按情况 $\\mathrm{A}$、$\\mathrm{B}$、$\\mathrm{C}$、$\\mathrm{D}$ 顺序排列的结果，形式为用方括号括起来的逗号分隔列表。例如，它应该看起来像 $[[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]],[\\cdot, \\cdot, [\\cdot,\\cdot,\\cdot]]]$，并用实际的数值和布尔结果替换。", "solution": "该问题是有效的。这是一个定义明确的计算经济学练习，其基础是一般均衡理论和动态系统数值模拟的既定原则。所有参数、方程和条件都已足够精确地指定，以构建一个唯一且可验证的解。\n\n该问题要求在纯交换经济体中模拟一个离散时间的拍卖调整价格调整过程。该经济体由 $I=2$ 个代理人和 $G=3$ 种商品组成。解决方案的核心是实现一个迭代算法，该算法根据市场超额需求更新价格，直到达到均衡或超过最大迭代次数。\n\n首先，我们建立经济模型的基本方程。每个代理人 $i \\in \\{1, 2\\}$ 都有柯布-道格拉斯偏好，由效用函数 $U_i(\\mathbf{x}_i) = \\prod_{g=1}^3 x_{ig}^{\\alpha_{ig}}$ 描述，其中 $\\mathbf{x}_i = (x_{i1}, x_{i2}, x_{i3})$ 是消费束，$\\boldsymbol{\\alpha}_i = (\\alpha_{i1}, \\alpha_{i2}, \\alpha_{i3})$ 是效用份额参数。代理人被赋予一个商品向量 $\\mathbf{e}_i = (e_{i1}, e_{i2}, e_{i3})$。\n\n给定一个价格向量 $\\mathbf{p} = (p_1, p_2, p_3)$，代理人 $i$ 的收入（或财富）来自其禀赋：\n$$\nm_i(\\mathbf{p}) = \\mathbf{p} \\cdot \\mathbf{e}_i = \\sum_{g=1}^{3} p_g e_{ig}\n$$\n柯布-道格拉斯效用函数的一个关键特性是，代理人 $i$ 将其收入的固定比例 $\\alpha_{ig}$ 分配给每种商品 $g$。这得出了个人需求函数：\n$$\nx_{ig}(\\mathbf{p}) = \\frac{\\alpha_{ig} m_i(\\mathbf{p})}{p_g}\n$$\n每种商品 $g$ 的总需求是所有代理人个人需求的总和：\n$$\nX_g(\\mathbf{p}) = \\sum_{i=1}^{2} x_{ig}(\\mathbf{p})\n$$\n经济体中每种商品的总量由总禀赋 $\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2$ 固定。商品 $g$ 的超额需求，记为 $Z_g(\\mathbf{p})$，是需求量与可用量之间的差额：\n$$\nZ_g(\\mathbf{p}) = X_g(\\mathbf{p}) - E_g\n$$\n问题指定了以下经济参数：\n- 效用指数：代理人1为 $\\boldsymbol{\\alpha}_1 = (0.5, 0.3, 0.2)$，代理人2为 $\\boldsymbol{\\alpha}_2 = (0.2, 0.4, 0.4)$。\n- 禀赋：代理人1为 $\\mathbf{e}_1 = (1.0, 0.5, 0.5)$，代理人2为 $\\mathbf{e}_2 = (0.5, 1.0, 0.5)$。\n- 总禀赋：$\\mathbf{E} = \\mathbf{e}_1 + \\mathbf{e}_2 = (1.5, 1.5, 1.0)$。\n\n模拟遵循一个由 $t \\in \\{0, 1, 2, \\dots\\}$ 索引的离散时间拍卖调整过程。商品1的价格被规范化为计价物，即对于所有 $t$ 都有 $p_1^t \\equiv 1$。非计价物商品 $p_2$ 和 $p_3$ 的价格根据它们各自的超额需求进行调整，但带有一个“粘性”条件。\n\n算法流程如下：\n1.  **初始化**：在迭代 $t=0$ 时，从给定的初始价格向量 $\\mathbf{p}^0$ 开始。\n2.  **迭代循环**：对于 $t = 0, 1, \\dots, T_{\\max}-1$：\n    a. **计算状态**：为所有商品 $g \\in \\{1, 2, 3\\}$ 计算代理人收入 $m_i(\\mathbf{p}^t)$、总需求 $X_g(\\mathbf{p}^t)$ 和超额需求 $Z_g(\\mathbf{p}^t)$。\n    b. **检查收敛**：如果 $\\max_{g} |Z_g(\\mathbf{p}^t)| \\le \\tau$，其中 $\\tau = 10^{-6}$ 是容差，则过程已收敛。模拟终止，报告当前迭代次数 $t$、收敛状态 `True` 和最终价格向量 $\\mathbf{p}^t$。\n    c. **检查迭代限制**：如果 $t$ 达到 $T_{\\max}$，模拟停止。报告最终状态，迭代次数为 $T_{\\max}$，收敛状态由步骤(b)中的最终检查确定。\n    d. **价格更新**：如果过程尚未终止，计算下一个价格向量 $\\mathbf{p}^{t+1}$。计价物价格是固定的：$p_1^{t+1} = 1$。对于每个非计价物商品 $g \\in \\{2, 3\\}$，价格根据粘性规则更新：\n       $$\n       p_g^{t+1} =\n       \\begin{cases}\n       \\max\\{\\varepsilon, p_g^t (1 + \\gamma Z_g(\\mathbf{p}^t))\\}  \\text{if } |Z_g(\\mathbf{p}^t)|  \\delta \\\\\n       p_g^t  \\text{if } |Z_g(\\mathbf{p}^t)| \\le \\delta\n       \\end{cases}\n       $$\n       此处，$\\gamma$ 是调整速度，$\\delta$ 是粘性阈值，$\\varepsilon = 10^{-8}$ 是确保价格保持严格为正的下限。\n    e. **推进**：设置 $\\mathbf{p}^t \\leftarrow \\mathbf{p}^{t+1}$，增加迭代计数器，并从步骤(a)重复。\n\n该算法将使用 Python 的 `numpy` 库实现，以进行高效的向量和矩阵运算。程序将对四个指定的测试用例执行模拟，每个用例都有一组不同的参数 $(\\gamma, \\delta, T_{\\max}, \\mathbf{p}^0)$，并按要求格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the tâtonnement process simulations for all test cases.\n    \"\"\"\n    \n    # Calibrated economy parameters\n    alphas = np.array([\n        [0.5, 0.3, 0.2],  # Agent 1\n        [0.2, 0.4, 0.4]   # Agent 2\n    ])\n    \n    endowments = np.array([\n        [1.0, 0.5, 0.5],  # Agent 1\n        [0.5, 1.0, 0.5]   # Agent 2\n    ])\n    \n    agg_endowment = np.sum(endowments, axis=0)\n    \n    # Fixed simulation parameters\n    epsilon = 1e-8\n    tau = 1e-6\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: baseline, no stickiness\n        (0.2, 0.0, 5000, np.array([1.0, 1.0, 1.0])),\n        # Case B: moderate stickiness, off-equilibrium start\n        (0.15, 0.1, 5000, np.array([1.0, 0.7, 1.3])),\n        # Case C: high stickiness, effectively frozen\n        (0.2, 1.0, 10, np.array([1.0, 1.0, 1.0])),\n        # Case D: boundary stickiness at equality\n        (0.2, 0.2, 10, np.array([1.0, 1.0, 1.0])),\n    ]\n\n    results = []\n    for case in test_cases:\n        gamma, delta, T_max, p0 = case\n        \n        # Run the simulation for the current case\n        N, B, p_final = simulate_tatonnement(\n            gamma, delta, T_max, p0, \n            alphas, endowments, agg_endowment, \n            epsilon, tau\n        )\n        \n        # Round final prices to 6 decimal places\n        p_final_rounded = np.round(p_final, 6).tolist()\n        \n        results.append([N, B, p_final_rounded])\n\n    # Final print statement in the exact required format.\n    # The replace(\" \", \"\") call ensures the output matches the dense format.\n    print(str(results).replace(\" \", \"\"))\n\ndef simulate_tatonnement(gamma, delta, T_max, p0, alphas, endowments, agg_endowment, epsilon, tau):\n    \"\"\"\n    Simulates the sticky tâtonnement process for a single case.\n    \n    Returns:\n        N (int): Number of iterations performed.\n        converged (bool): True if convergence was achieved, False otherwise.\n        p (np.ndarray): The final price vector.\n    \"\"\"\n    p = p0.copy()\n    N = 0\n    converged = False\n\n    while N  T_max:\n        # Step 1: Calculate incomes m_i(p) = p . e_i\n        incomes = np.dot(endowments, p)\n        \n        # Step 2: Calculate individual demands x_ig(p) = alpha_ig * m_i(p) / p_g\n        # We need to handle division by p_g carefully.\n        # income_matrix: (I x G)\n        income_matrix = np.tile(incomes, (alphas.shape[1], 1)).T\n        demands = alphas * income_matrix / p\n        \n        # Step 3: Calculate aggregate and excess demands\n        agg_demand = np.sum(demands, axis=0)\n        excess_demand = agg_demand - agg_endowment\n        \n        # Step 4: Check for convergence\n        if np.max(np.abs(excess_demand)) = tau:\n            converged = True\n            break\n        \n        # Step 5: Update prices for the next iteration\n        p_next = p.copy()\n        \n        # Update for non-numeraire goods (g=2, 3), indices 1, 2\n        for g_idx in [1, 2]:\n            if abs(excess_demand[g_idx]) > delta:\n                p_next[g_idx] = max(epsilon, p[g_idx] * (1 + gamma * excess_demand[g_idx]))\n        \n        p = p_next\n        N += 1\n    \n    # Final check after the loop (in case it terminated due to N == T_max)\n    if not converged and np.max(np.abs(excess_demand)) = tau:\n        converged = True\n        \n    return N, converged, p\n\nsolve()\n\n```", "id": "2436152"}, {"introduction": "当并非所有市场参与者都对最新信息做出反应时，会发生什么？本练习通过模拟一个基于过时价格更新其需求的“固执”代理人，来探讨信息滞后和决策频率的关键作用。这个简单而强大的修改[@problem_id:2436106]能够极大地影响整个市场的稳定性，揭示了系统中的延迟如何可能导致价格振荡甚至偏离均衡。", "problem": "考虑一个单一商品市场的离散时间瓦尔拉斯试探过程。设在回合 $t \\in \\{0,1,2,\\dots\\}$ 的市场价格为 $p_t \\in \\mathbb{R}_{+}$。价格更新规则由瓦尔拉斯试探动态的基本定义给出：\n$$\np_{t+1} \\;=\\; p_t \\;+\\; \\gamma \\, z_t,\n$$\n其中 $\\gamma \\in \\mathbb{R}_{+}$ 是一个固定的步长（学习率），$z_t$ 是当前回合的超额需求。超额需求是总需求与总供给之差：\n$$\nz_t \\;=\\; D_A^{\\mathrm{sub}}(t) \\;+\\; D_B(p_t) \\;-\\; S(p_t).\n$$\n市场中有两个代理人，代理人 $A$ 和代理人 $B$，以及一条竞争性供给曲线。代理人 $B$ 每回合都更新其需求，而代理人 $A$ 是一个“固执”的代理人，他每 $k \\in \\mathbb{Z}_{\\ge 1}$ 个回合才向市场提交一次更新后的需求。形式上：\n- 代理人 $A$ 提交的需求 $D_A^{\\mathrm{sub}}(t)$ 定义如下。设 $t_A(t)$ 是小于或等于 $t$ 的最近的非负 $k$ 的倍数。那么\n$$\nD_A^{\\mathrm{sub}}(t) \\;=\\; \\max\\!\\big(0,\\; D_A(p_{t_A(t)})\\big).\n$$\n- 代理人 $B$ 的同期需求是\n$$\nD_B(p_t) \\;=\\; \\max\\!\\big(0,\\; a_B \\;-\\; b_B \\, p_t\\big).\n$$\n- 竞争性供给是\n$$\nS(p_t) \\;=\\; s_0 \\;+\\; s_1 \\, p_t.\n$$\n假设代理人 $A$ 和代理人 $B$ 的个人（总）需求为线性形式\n$$\nD_A(p) \\;=\\; a_A \\;-\\; b_A \\, p, \\qquad D_B(p) \\;=\\; a_B \\;-\\; b_B \\, p,\n$$\n且供给为如上指定的线性形式。所有参数均为非负，且其选择使得完全同期更新下的竞争均衡存在于一个严格为正的价格和严格为正的个人需求水平上，因此非负性约束 $\\max(0,\\cdot)$ 在竞争均衡点上不起作用。\n\n设参数固定为\n$$\na_A = 10, \\quad b_A = 1, \\quad a_B = 8, \\quad b_B = \\tfrac{1}{2}, \\quad s_0 = 1, \\quad s_1 = 1.\n$$\n初始价格为\n$$\np_0 = 6.\n$$\n该过程在一个固定的 $T$ 回合视界内运行，其中 $T = 2000$。为保证数值真实性，模拟必须在每一步强制执行 $p_t \\ge p_{\\min}$（其中 $p_{\\min} = 10^{-8}$）（通过约束更新值），并且如果任何时候出现 $p_t  p_{\\max}$（其中 $p_{\\max} = 10^{6}$），则必须检测到数值发散，并将此类轨迹视为不稳定。\n\n将竞争均衡价格 $p^{\\ast}$ 定义为在完全同期需求下使市场出清的唯一价格（也就是说，在计算 $p^{\\ast}$ 时，将 $D_A^{\\mathrm{sub}}(t)$ 视为 $D_A(p_t)$ 并忽略 $\\max(0,\\cdot)$，根据参数选择，此处的这种做法是有效的）。明确地，$p^{\\ast}$ 是以下方程的唯一解\n$$\n\\big(a_A - b_A p\\big) + \\big(a_B - b_B p\\big) - \\big(s_0 + s_1 p\\big) = 0.\n$$\n\n您必须实现一个程序，对于给定的配对 $(k,\\gamma)$，该程序根据上述代理人 $A$ 的“固执”提交规则模拟价格路径 $\\{p_t\\}_{t=0}^{T}$，并判断价格路径对于竞争均衡是否稳定。一个模拟的价格路径被分类为稳定，当且仅当以下所有条件同时满足：\n1. 未检测到数值发散，即对于所有 $t \\in \\{0,\\dots,T\\}$，都有 $p_t \\le p_{\\max}$。\n2. 在最后 $W$ 回合的窗口内，与竞争均衡的平均绝对偏差很小：\n$$\n\\frac{1}{W} \\sum_{t=T-W}^{T-1} \\big| p_t - p^{\\ast} \\big| \\le \\varepsilon_{\\mathrm{eq}},\n$$\n且该窗口内的步间变化很小：\n$$\n\\max_{t \\in \\{T-W+1,\\dots,T\\}} \\big| p_t - p_{t-1} \\big| \\le \\varepsilon_{\\mathrm{step}}.\n$$\n使用 $W = 200$，$\\varepsilon_{\\mathrm{eq}} = 10^{-5}$，以及 $\\varepsilon_{\\mathrm{step}} = 10^{-5}$。\n\n您的程序应根据所述参数计算 $p^{\\ast}$，然后为以下测试套件中的每个案例评估稳定性。对于每个测试用例，返回一个布尔值以指示稳定性（稳定为 True，不稳定为 False）。\n\n测试套件（每项为 $(k,\\gamma)$）：\n- $(1,\\; 0.5)$\n- $(1,\\; 0.9)$\n- $(5,\\; 0.9)$\n- $(5,\\; 1.3)$\n- $(10000,\\; 0.5)$\n- $(2,\\; 0.2)$\n\n附加要求：\n- 使用上面给出的确切价格更新和提交规则。\n- 使用上面给出的固定参数、初始条件和阈值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表顺序与上述测试套件相对应，例如 $[\\text{result}_1,\\text{result}_2,\\dots]$。\n- 所有输出都必须是布尔值。\n\n目标是根据需求、供给和瓦尔拉斯试探的定义进行推理，用指定的“固执”代理人实现动态过程，并诊断更新频率 $k$ 如何在不同步长 $\\gamma$ 下影响价格路径的稳定性。此问题不涉及物理单位、角度或百分比。描述纯粹是数学和算法性的，程序必须是自包含的，并且不需要外部输入。", "solution": "用户提出了一个关于计算经济学中瓦尔拉斯试探过程稳定性的问题。我将首先验证问题陈述。\n\n### 步骤 1：提取给定信息\n\n-   **价格更新规则**：$p_{t+1} = p_t + \\gamma \\, z_t$，对于 $t \\in \\{0,1,2,\\dots\\}$ 和 $p_t \\in \\mathbb{R}_{+}$。\n-   **步长**：$\\gamma \\in \\mathbb{R}_{+}$。\n-   **超额需求**：$z_t = D_A^{\\mathrm{sub}}(t) + D_B(p_t) - S(p_t)$。\n-   **代理人 A 的提交需求**：$D_A^{\\mathrm{sub}}(t) = \\max(0, D_A(p_{t_A(t)}))$，其中 $t_A(t)$ 是小于或等于 $t$ 的最近的非负 $k$ 的倍数。\n-   **固执参数**：$k \\in \\mathbb{Z}_{\\ge 1}$。\n-   **代理人 B 的需求**：$D_B(p_t) = \\max(0, a_B - b_B \\, p_t)$。\n-   **竞争性供给**：$S(p_t) = s_0 + s_1 \\, p_t$。\n-   **个人线性需求**：$D_A(p) = a_A - b_A \\, p$, $D_B(p) = a_B - b_B \\, p$。\n-   **参数值**：$a_A = 10$, $b_A = 1$, $a_B = 8$, $b_B = \\tfrac{1}{2}$, $s_0 = 1$, $s_1 = 1$。所有参数均为非负。\n-   **初始条件**：$p_0 = 6$。\n-   **模拟时域**：$T = 2000$ 回合。\n-   **价格下限**：$p_t \\ge p_{\\min}$，其中 $p_{\\min} = 10^{-8}$。\n-   **发散阈值**：$p_t  p_{\\max}$，其中 $p_{\\max} = 10^{6}$。\n-   **竞争均衡价格 $p^{\\ast}$ 的定义**：方程 $(a_A - b_A p) + (a_B - b_B p) - (s_0 + s_1 p) = 0$ 的解。\n-   **稳定性条件 1**：无数值发散，$p_t \\le p_{\\max}$ 对所有 $t \\in \\{0, \\dots, T\\}$ 成立。\n-   **稳定性条件 2（平均偏差）**：$\\frac{1}{W} \\sum_{t=T-W}^{T-1} |p_t - p^{\\ast}| \\le \\varepsilon_{\\mathrm{eq}}$，其中 $W = 200, \\varepsilon_{\\mathrm{eq}} = 10^{-5}$。\n-   **稳定性条件 3（步间变化）**：$\\max_{t \\in \\{T-W+1,\\dots,T\\}} |p_t - p_{t-1}| \\le \\varepsilon_{\\mathrm{step}}$，其中 $\\varepsilon_{\\mathrm{step}} = 10^{-5}$。\n-   **$(k,\\gamma)$ 的测试用例**：$(1, 0.5)$, $(1, 0.9)$, $(5, 0.9)$, $(5, 1.3)$, $(10000, 0.5)$, $(2, 0.2)$。\n-   **输出格式**：单行，包含一个用方括号括起来的逗号分隔的布尔值列表。\n\n### 步骤 2：使用提取的给定信息进行验证\n\n-   **科学依据**：问题描述了一个瓦尔拉斯试探过程，这是一般均衡理论中的一个典型模型。引入一个具有延迟更新的“固执”代理人是研究异质性预期或信息滞后下市场动态的一个有效扩展。该模型在数学上是形式化的，并以经济理论为基础。它不是伪科学。\n-   **良态的**：问题是良态的。所有必需的参数、初始条件、更新方程和终止标准都已明确提供。任务定义清晰：模拟系统并根据精确的量化标准对其稳定性进行分类。\n-   **客观的**：问题以客观的数学语言陈述。它没有主观断言、观点或歧义。\n-   **缺陷清单**：\n    1.  *科学/事实不健全*：无。该模型是经济学中使用的有效抽象。\n    2.  *非形式化/不相关*：问题是形式化的，并且与指定的计算经济学主题直接相关。\n    3.  *不完整/矛盾的设置*：所有数据都已提供。规则清晰且不矛盾。\n    4.  *不切实际/不可行*：该模型是一种抽象。参数在数值上是一致的。问题通过提供约束（$p_{\\min}$、$p_{\\max}$）来处理数值可行性。\n    5.  *病态/结构不良*：问题结构清晰，可得出唯一的计算结果，并对期望结果有明确的定义。\n    6.  *超出科学可验证性*：模拟是确定性的，其结果可以通过直接计算来验证。\n\n### 步骤 3：结论与行动\n\n问题是有效的。我将继续进行解答。\n\n任务是模拟单一商品市场中的离散时间价格调整过程并评估其稳定性。分析涉及三个主要阶段：计算理论均衡，根据指定规则模拟价格动态，以及应用稳定性标准。\n\n首先，我们确定竞争均衡价格，记为 $p^{\\ast}$。这是在所有代理人都同期更新其需求时能够使市场出清的价格。它作为我们稳定性分析的基准。均衡条件是总需求等于总供给：\n$$\nD_A(p^{\\ast}) + D_B(p^{\\ast}) = S(p^{\\ast})\n$$\n代入需求和供给的线性形式：\n$$\n(a_A - b_A p^{\\ast}) + (a_B - b_B p^{\\ast}) = s_0 + s_1 p^{\\ast}\n$$\n我们解出 $p^{\\ast}$：\n$$\na_A + a_B - s_0 = (b_A + b_B + s_1) p^{\\ast}\n$$\n$$\np^{\\ast} = \\frac{a_A + a_B - s_0}{b_A + b_B + s_1}\n$$\n使用给定的参数值：$a_A = 10$，$b_A = 1$，$a_B = 8$，$b_B = \\tfrac{1}{2} = 0.5$，$s_0 = 1$，$s_1 = 1$：\n$$\np^{\\ast} = \\frac{10 + 8 - 1}{1 + 0.5 + 1} = \\frac{17}{2.5} = 6.8\n$$\n问题陈述断言，在此均衡价格下，所有需求均为正，我们可以验证这一点：$D_A(6.8) = 10 - 1 \\cdot 6.8 = 3.2  0$ 且 $D_B(6.8) = 8 - 0.5 \\cdot 6.8 = 8 - 3.4 = 4.6  0$。该断言成立。\n\n接下来，我们设计模拟算法。对于每对给定的参数 $(k, \\gamma)$，我们必须追踪价格路径 $\\{p_t\\}_{t=0}^{T}$。模拟过程如下：\n初始化一个长度为 $T+1$ 的价格向量，例如 `prices`。我们将其第一个元素 `prices[0]` 设置为初始价格 $p_0 = 6$。然后，模拟对每个时间步 $t$ 从 $0$ 到 $T-1$ 进行迭代，以计算 $p_{t+1}$。\n\n在每个步骤 $t$ 中：\n1.  确定代理人 A 的相关过去价格。规则指定代理人 A 提交的需求基于时间 $t_A(t)$ 的价格，即小于或等于 $t$ 的最近的 $k$ 的倍数。这可以计算为 $t_A(t) = k \\cdot \\lfloor t/k \\rfloor$。因此，代理人 A 使用的价格是 $p_{t_A(t)}$，该价格从我们存储的 `prices` 向量中检索。\n2.  计算超额需求 $z_t$ 的组成部分：\n    -   代理人 A 的提交需求：$D_A^{\\mathrm{sub}}(t) = \\max(0, a_A - b_A \\cdot p_{t_A(t)})$。\n    -   代理人 B 的需求：$D_B(p_t) = \\max(0, a_B - b_B \\cdot p_t)$。请注意，这使用的是当前价格 $p_t$。\n    -   供给：$S(p_t) = s_0 + s_1 \\cdot p_t$。\n    -   超额需求：$z_t = D_A^{\\mathrm{sub}}(t) + D_B(p_t) - S(p_t)$。\n3.  根据试探规则更新价格：\n    $$\n    p_{t+1}^{\\text{raw}} = p_t + \\gamma \\cdot z_t\n    $$\n4.  应用数值约束：\n    -   强制执行价格下限：$p_{t+1} = \\max(p_{\\min}, p_{t+1}^{\\text{raw}})$，其中 $p_{\\min} = 10^{-8}$。\n    -   将此值存储在 `prices[t+1]` 中。\n    -   检查是否发散：如果 $p_{t+1}  p_{\\max}$（其中 $p_{\\max} = 10^6$），则认为轨迹不稳定。该 $(k, \\gamma)$ 对的模拟终止，结果为 `False`。\n\n如果模拟在所有 $T$ 个回合中完成而没有发散，我们继续进行最终的稳定性评估。一条路径是稳定的，当且仅当关于最后 $W=200$ 个回合的两个条件都得到满足：\n1.  与均衡的平均绝对偏差必须很小。我们在从 $t=T-W$ 到 $t=T-1$ 的价格历史记录上计算这个值：\n    $$\n    \\text{dev} = \\frac{1}{W} \\sum_{t=T-W}^{T-1} |p_t - p^{\\ast}|\n    $$\n    这必须满足 $\\text{dev} \\le \\varepsilon_{\\mathrm{eq}}$，其中 $\\varepsilon_{\\mathrm{eq}} = 10^{-5}$。\n2.  最终窗口中的最大价格波动必须很小。我们检查从 $t=T-W+1$ 到 $t=T$ 的步间变化：\n    $$\n    \\text{step\\_chg} = \\max_{t \\in \\{T-W+1, \\dots, T\\}} |p_t - p_{t-1}|\n    $$\n    这必须满足 $\\text{step\\_chg} \\le \\varepsilon_{\\mathrm{step}}$，其中 $\\varepsilon_{\\mathrm{step}} = 10^{-5}$。\n\n如果两个条件都满足，则该路径被归类为稳定 (`True`)。否则，它是不稳定的 (`False`)。对提供的测试套件中的每一对 $(k, \\gamma)$ 重复此整个过程。最终输出是这些布尔结果的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Walrasian tâtonnement simulation problem.\n    \"\"\"\n    \n    # ----------------------------------------------------------------------\n    # Define parameters from the problem statement\n    # ----------------------------------------------------------------------\n    \n    # Demand and Supply parameters\n    a_A = 10.0\n    b_A = 1.0\n    a_B = 8.0\n    b_B = 0.5\n    s_0 = 1.0\n    s_1 = 1.0\n\n    # Simulation parameters\n    p_0 = 6.0\n    T = 2000\n    p_min = 1e-8\n    p_max = 1e6\n\n    # Stability criteria parameters\n    W = 200\n    epsilon_eq = 1e-5\n    epsilon_step = 1e-5\n\n    # Test suite of (k, gamma) pairs\n    test_cases = [\n        (1, 0.5),\n        (1, 0.9),\n        (5, 0.9),\n        (5, 1.3),\n        (10000, 0.5),\n        (2, 0.2),\n    ]\n\n    # ----------------------------------------------------------------------\n    # Calculate the competitive equilibrium price p*\n    # ----------------------------------------------------------------------\n    \n    # p* is the solution to (a_A - b_A*p) + (a_B - b_B*p) = s_0 + s_1*p\n    # (a_A + a_B - s_0) = (b_A + b_B + s_1) * p\n    p_star = (a_A + a_B - s_0) / (b_A + b_B + s_1)\n\n    # ----------------------------------------------------------------------\n    # Main simulation and stability check logic\n    # ----------------------------------------------------------------------\n    \n    def run_simulation(k, gamma):\n        \"\"\"\n        Simulates the price path for a given (k, gamma) and returns stability.\n        \"\"\"\n        prices = np.zeros(T + 1)\n        prices[0] = p_0\n        \n        for t in range(T):\n            p_t = prices[t]\n            \n            # Determine the time index for Agent A's demand update\n            t_A = (t // k) * k\n            p_at_t_A = prices[t_A]\n            \n            # Calculate demand and supply\n            D_A_sub = max(0.0, a_A - b_A * p_at_t_A)\n            D_B = max(0.0, a_B - b_B * p_t)\n            S = s_0 + s_1 * p_t\n            \n            # Calculate excess demand\n            z_t = D_A_sub + D_B - S\n            \n            # Update price\n            p_next = p_t + gamma * z_t\n            \n            # Apply floor clamp\n            p_next = max(p_min, p_next)\n            \n            # Check for divergence\n            if p_next > p_max:\n                return False # Path is unstable due to divergence\n                \n            prices[t+1] = p_next\n\n        # If simulation completes without divergence, check stability criteria\n        \n        # Condition 2: Average absolute deviation from equilibrium\n        # Sum over t = T-W to T-1, which is prices[T-W : T]\n        final_window_dev = prices[T - W : T]\n        avg_dev = np.mean(np.abs(final_window_dev - p_star))\n        \n        if avg_dev > epsilon_eq:\n            return False\n\n        # Condition 3: Maximum step-to-step changes\n        # Differences for t = T-W+1 to T, from prices p_{T-W} to p_T\n        # This corresponds to prices[T-W : T+1]\n        final_window_step = prices[T - W : T + 1]\n        max_step = np.max(np.abs(np.diff(final_window_step)))\n\n        if max_step > epsilon_step:\n            return False\n            \n        return True # Stable if all conditions are met\n\n    # ----------------------------------------------------------------------\n    # Run simulations for all test cases and format output\n    # ----------------------------------------------------------------------\n    \n    results = []\n    for k, gamma in test_cases:\n        is_stable = run_simulation(k, gamma)\n        results.append(is_stable)\n    \n    # Format the final output as specified\n    output_str = f\"[{','.join(map(str, [r.lower() if isinstance(r, bool) else r for r in results]))}]\"\n    # The problem asks for boolean values, which in python are True/False.\n    # The example output uses lowercase, so let's adjust.\n    print(str(results).replace(\"True\", \"true\").replace(\"False\", \"false\"))\n\nsolve()\n```", "id": "2436106"}]}