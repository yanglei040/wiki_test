{"hands_on_practices": [{"introduction": "要真正掌握两阶段最小二乘法（2SLS），我们必须超越现成的软件包命令，深入理解其底层的数学原理。这项练习旨在通过直接的矩阵运算，让您从第一性原理出发实现 2SLS 估计量。通过处理恰好识别、过度识别以及弱工具变量等不同情景 [@problem_id:2445014]，您将对 2SLS 如何从计算层面解决内生性问题建立起深刻的认识。", "problem": "考虑一个关于患者治疗结果的计量经济学模型，其中一个内生的医院质量指标使用偏向最近医院的救护车调度协议作为工具变量。设结构方程为\n$$\ny_i \\;=\\; \\alpha \\;+\\; \\beta\\,x_i \\;+\\; \\gamma\\,w_i \\;+\\; u_i,\n$$\n其中 $y_i$ 是患者 $i$ 的标量结果（死亡率指标），$x_i$ 是一个衡量医院质量的标量内生回归量，$w_i$ 是一个标量外生控制变量（患者协变量），而 $u_i$ 是一个未观测到的误差项。模型通过截距参数 $\\alpha$ 包含了一个常数项。正交性条件由满足下式的工具变量 $z_i$ 定义\n$$\n\\mathbb{E}\\!\\left[z_i\\,u_i\\right] \\;=\\; 0,\n$$\n其中 $z_i$ 包括所有外生回归量以及源自救护车调度规则的排除性工具变量。\n\n定义回归量矩阵 $X \\in \\mathbb{R}^{n \\times k}$，其列为 $[\\,\\mathbf{1},\\,w,\\,x\\,]$，以及工具变量矩阵 $Z \\in \\mathbb{R}^{n \\times L}$，它堆叠了 $[\\,\\mathbf{1},\\,w,\\,\\text{排除性工具变量}\\,]$。对于下方的每个测试用例，计算由正交性条件所隐含的系数 $\\beta$（$x$ 的系数）的两阶段最小二乘（TSLS）估计值，即通过将 $X$ 和 $y$ 投影到 $Z$ 的列空间而定义的线性工具变量估计量所获得的值。您必须将截距和外生控制变量 $w$ 视为同时包含在 $X$ 和 $Z$ 中。\n\n您的程序必须实现计算每个测试用例中 $x$ 的TSLS系数，并仅报告每个用例的该系数。\n\n测试套件：\n\n- 用例A（恰好识别，相关工具变量）：$n = 8$。使用\n  - $w = [\\,0.20,\\,-0.10,\\,0.00,\\,0.50,\\,-0.30,\\,0.10,\\,-0.40,\\,0.30\\,]$,\n  - $x = [\\,2.00,\\,3.70,\\,2.20,\\,3.90,\\,1.80,\\,3.40,\\,2.10,\\,3.60\\,]$,\n  - 排除性工具变量 $z^{(1)} = [\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1\\,]$,\n  - $y = [\\,0.156,\\,0.020,\\,0.098,\\,0.076,\\,0.108,\\,0.054,\\,0.102,\\,0.038\\,]$。\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n- 用例B（弱但有效的工具变量）：$n = 8$。使用\n  - $w = [\\,0.20,\\,-0.10,\\,0.00,\\,0.50,\\,-0.30,\\,0.10,\\,-0.40,\\,0.30\\,]$,\n  - $x = [\\,2.90,\\,3.10,\\,3.00,\\,3.20,\\,2.90,\\,3.10,\\,2.95,\\,3.05\\,]$,\n  - 排除性工具变量 $z^{(1)} = [\\,0,\\,1,\\,0,\\,1,\\,1,\\,0,\\,0,\\,1\\,]$,\n  - $y = [\\,0.097,\\,0.051,\\,0.070,\\,0.113,\\,0.042,\\,0.072,\\,0.046,\\,0.081\\,]$。\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n- 用例C（过度识别，两个排除性工具变量）：$n = 10$。使用\n  - $w = [\\,0.00,\\,0.20,\\,-0.20,\\,0.50,\\,-0.10,\\,0.30,\\,-0.40,\\,0.10,\\,-0.30,\\,0.40\\,]$,\n  - $x = [\\,3.80,\\,3.50,\\,2.20,\\,4.00,\\,2.40,\\,3.70,\\,1.90,\\,3.40,\\,2.10,\\,3.90\\,]$,\n  - 排除性工具变量：\n    - $z^{(1)} = [\\,1,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1,\\,0,\\,1\\,]$,\n    - $z^{(2)} = [\\,0.80,\\,0.60,\\,-0.70,\\,0.90,\\,-0.50,\\,0.70,\\,-0.90,\\,0.50,\\,-0.60,\\,0.80\\,]$,\n  - $y = [\\,0.022,\\,0.066,\\,0.082,\\,0.070,\\,0.098,\\,0.062,\\,0.094,\\,0.054,\\,0.100,\\,0.028\\,]$。\n  此处，$Z = [\\,\\mathbf{1},\\,w,\\,z^{(1)},\\,z^{(2)}\\,]$ 且 $X = [\\,\\mathbf{1},\\,w,\\,x\\,]$。\n\n每个用例的计算目标：\n\n- 使用基于将 $X$ 和 $y$ 投影到 $Z$ 的列空间的定义来计算 $\\beta$ 的TSLS估计值。\n- 仅返回 $\\beta$ 的标量估计值。\n\n最终输出规格：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个浮点数，按用例A、用例B、用例C的顺序排列。\n- 每个数字必须四舍五入到六位小数。\n- 例如，包含三个结果的输出必须类似于 $[b_A,b_B,b_C]$，其中每个 $b_{\\cdot}$ 都是一个四舍五入到六位小数的浮点数。", "solution": "所提供的问题陈述已经过验证，并被确定为有效。它在科学上基于成熟的计量经济学理论，问题阐述清晰且为计算提供了足够的数据，并进行了客观的表述。未发现任何会妨碍严谨求解的缺陷。\n\n该问题要求计算线性结构模型中系数 $\\beta$ 的两阶段最小二乘（$TSLS$）估计值：\n$$\ny_i \\;=\\; \\alpha \\;+\\; \\gamma\\,w_i \\;+\\; \\beta\\,x_i \\;+\\; u_i\n$$\n此处，$y_i$ 是结果，$x_i$ 是内生回归量，$w_i$ 是外生控制变量，$u_i$ 是观测 $i$ 的误差项。以矩阵形式，该模型写作 $y = X\\mathbf{b} + u$，其中 $y \\in \\mathbb{R}^{n}$ 是结果向量，$X \\in \\mathbb{R}^{n \\times k}$ 是回归量矩阵，$\\mathbf{b} \\in \\mathbb{R}^{k}$ 是系数向量，$u \\in \\mathbb{R}^{n}$ 是未观测误差向量。\n\n根据问题规范，回归量矩阵是 $X = [\\begin{matrix} \\mathbf{1} & w & x \\end{matrix}]$，其中 $\\mathbf{1}$ 是对应截距 $\\alpha$ 的全1向量，$w$ 是对应系数 $\\gamma$ 的外生协变量向量，$x$ 是对应系数 $\\beta$ 的内生回归量向量。因此，回归量的数量为 $k=3$，待估计的系数向量为 $\\mathbf{b} = [\\alpha, \\gamma, \\beta]^T$。\n\n$x$ 的内生性意味着其值与误差项 $u$ 相关，具体来说 $\\mathbb{E}[x_i u_i] \\neq 0$。这种相关性违反了普通最小二乘法（$OLS$）的一个关键假设，使得 $\\mathbf{b}$ 的 $OLS$ 估计量有偏且不一致。$TSLS$ 方法通过使用一组收集在矩阵 $Z \\in \\mathbb{R}^{n \\times L}$ 中的工具变量来克服这个问题，这些工具变量与内生回归量 $x$ 相关，但与误差项 $u$ 不相关。这由正交性条件 $\\mathbb{E}[Z^T u] = 0$ 所捕捉。矩阵 $Z$ 由模型中已有的所有外生变量（截距和 $w$，称为内含工具变量）以及一个或多个额外的变量（称为排除性工具变量）组成。\n\n顾名思义，$TSLS$ 过程可以概念化为两个阶段。\n\n第一阶段：从内生回归量中清除误差项的影响。这是通过将回归量矩阵 $X$ 投影到由工具变量矩阵 $Z$ 的列所张成的线性空间上来实现的。$Z$ 的列空间上的正交投影矩阵由下式给出：\n$$\nP_Z = Z(Z^T Z)^{-1}Z^T\n$$\n从此投影得到的 $X$ 的预测值，记为 $\\hat{X}$，计算如下：\n$$\n\\hat{X} = P_Z X\n$$\n这些拟合值 $\\hat{X}$ 是 $Z$ 中工具变量的线性组合，因此与误差项 $u$ 渐近不相关。\n\n第二阶段：使用结果变量 $y$ 和投影后的回归量 $\\hat{X}$ 进行 $OLS$ 回归。此回归得到的系数向量即为 $TSLS$ 估计量 $\\hat{\\mathbf{b}}_{\\text{TSLS}}$：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = (\\hat{X}^T \\hat{X})^{-1} \\hat{X}^T y\n$$\n为了得到一个直接的计算公式，我们代入 $\\hat{X} = P_Z X$。利用投影矩阵的对称性（$P_Z^T = P_Z$）和幂等性（$P_Z P_Z = P_Z$）的性质，我们简化估计量的组成部分：\n$$\n\\hat{X}^T \\hat{X} = (P_Z X)^T (P_Z X) = X^T P_Z^T P_Z X = X^T P_Z X\n$$\n和\n$$\n\\hat{X}^T y = (P_Z X)^T y = X^T P_Z^T y = X^T P_Z y\n$$\n这导出了 $TSLS$ 估计量的一般表达式：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = (X^T P_Z X)^{-1} (X^T P_Z y)\n$$\n通过代入 $P_Z$ 的定义，我们得到用于计算的完整公式：\n$$\n\\hat{\\mathbf{b}}_{\\text{TSLS}} = \\left( X^T Z(Z^T Z)^{-1}Z^T X \\right)^{-1} \\left( X^T Z(Z^T Z)^{-1}Z^T y \\right)\n$$\n这个公式对于恰好识别（工具变量数量 $L$ 等于回归量数量 $k$）和过度识别（$L > k$）的情况都有效。\n\n对于所提供的每个测试用例，我们根据数据构建向量 $y$ 以及矩阵 $X$ 和 $Z$。然后，我们应用推导出的公式来计算系数向量 $\\hat{\\mathbf{b}}_{\\text{TSLS}} = [\\hat{\\alpha}, \\hat{\\gamma}, \\hat{\\beta}]^T$。所要求的结果是标量估计值 $\\hat{\\beta}$，它是该向量的第三个元素。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the TSLS estimate of the coefficient beta for each test case.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"name\": \"Case A\",\n            \"n\": 8,\n            \"w\": np.array([0.20, -0.10, 0.00, 0.50, -0.30, 0.10, -0.40, 0.30]),\n            \"x\": np.array([2.00, 3.70, 2.20, 3.90, 1.80, 3.40, 2.10, 3.60]),\n            \"excluded_instruments\": [\n                np.array([0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0])\n            ],\n            \"y\": np.array([0.156, 0.020, 0.098, 0.076, 0.108, 0.054, 0.102, 0.038]),\n        },\n        {\n            \"name\": \"Case B\",\n            \"n\": 8,\n            \"w\": np.array([0.20, -0.10, 0.00, 0.50, -0.30, 0.10, -0.40, 0.30]),\n            \"x\": np.array([2.90, 3.10, 3.00, 3.20, 2.90, 3.10, 2.95, 3.05]),\n            \"excluded_instruments\": [\n                np.array([0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0])\n            ],\n            \"y\": np.array([0.097, 0.051, 0.070, 0.113, 0.042, 0.072, 0.046, 0.081]),\n        },\n        {\n            \"name\": \"Case C\",\n            \"n\": 10,\n            \"w\": np.array([0.00, 0.20, -0.20, 0.50, -0.10, 0.30, -0.40, 0.10, -0.30, 0.40]),\n            \"x\": np.array([3.80, 3.50, 2.20, 4.00, 2.40, 3.70, 1.90, 3.40, 2.10, 3.90]),\n            \"excluded_instruments\": [\n                np.array([1.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0]),\n                np.array([0.80, 0.60, -0.70, 0.90, -0.50, 0.70, -0.90, 0.50, -0.60, 0.80]),\n            ],\n            \"y\": np.array([0.022, 0.066, 0.082, 0.070, 0.098, 0.062, 0.094, 0.054, 0.100, 0.028]),\n        },\n    ]\n\n    def compute_tsls_beta(y, w, x, excluded_instruments, n):\n        \"\"\"\n        Computes the TSLS estimate for the coefficient on x.\n\n        The formula is beta_hat_tsls = (X'Z(Z'Z)^-1 Z'X)^-1 X'Z(Z'Z)^-1 Z'y\n        \"\"\"\n        # Reshape vectors to be column vectors for matrix operations\n        y_col = y.reshape(-1, 1)\n        w_col = w.reshape(-1, 1)\n        x_col = x.reshape(-1, 1)\n        \n        # Construct the regressor matrix X = [1, w, x]\n        ones = np.ones((n, 1))\n        X = np.hstack((ones, w_col, x_col))\n\n        # Construct the instrument matrix Z = [1, w, excluded_instruments...]\n        z_parts = [ones, w_col]\n        for z_ex in excluded_instruments:\n            z_parts.append(z_ex.reshape(-1, 1))\n        Z = np.hstack(z_parts)\n\n        # Apply the TSLS formula\n        # Let's compute parts of the formula for clarity\n        # We use np.linalg.solve(A, B) for X = A^-1 B for better numerical stability\n        \n        # Compute projection matrix part: Pz = Z @ inv(Z'Z) @ Z'\n        # A more stable way than forming Pz explicitly is to use its components.\n        try:\n            ZTZ_inv = np.linalg.inv(Z.T @ Z)\n        except np.linalg.LinAlgError:\n            # Handle cases where Z'Z is singular.\n            return np.nan\n\n        # First part of the formula: X' * P_Z\n        # X_T_PZ = X.T @ Z @ ZTZ_inv @ Z.T\n        # This can be computed more efficiently.\n        \n        # Term inside the inverse: A = X'Z(Z'Z)^-1 Z'X\n        XZ_term = X.T @ Z\n        A = XZ_term @ ZTZ_inv @ XZ_term.T\n\n        # Term for the y part: B = X'Z(Z'Z)^-1 Z'y\n        Zy_term = Z.T @ y_col\n        B = XZ_term @ ZTZ_inv @ Zy_term\n        \n        # b_hat = inv(A) @ B\n        try:\n            b_hat = np.linalg.solve(A, B)\n        except np.linalg.LinAlgError:\n            # Handle cases where the matrix for the second stage is singular.\n            return np.nan\n\n        # The coefficient beta is the third element (index 2)\n        beta_hat = b_hat[2, 0]\n        return beta_hat\n\n    results = []\n    for case in test_cases:\n        beta_estimate = compute_tsls_beta(\n            case[\"y\"],\n            case[\"w\"],\n            case[\"x\"],\n            case[\"excluded_instruments\"],\n            case[\"n\"]\n        )\n        results.append(f\"{beta_estimate:.6f}\")\n    \n    # Format and print the final output as specified.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2445014"}, {"introduction": "2SLS 是一个通用框架，在特定的研究设计中能展现出强大的应用价值。本练习将探讨其在断点回归设计（Regression Discontinuity Design）中的应用，其中，以微弱优势决定的选举结果可作为一个准随机的工具变量。您将看到，在二元工具变量的特定情况下，通用的 2SLS 公式如何简化为直观的 Wald 估计量 [@problem_id:2445017]，即比较断点两侧样本的平均结果差异，从而清晰地揭示该方法的因果推断逻辑。", "problem": "给定三个独立的数据集，每个数据集代表经历过票数非常接近的选举的管辖区的横截面数据。对于管辖区 $i$，令 $y_i$ 表示一个目标结果的变化量，$D_i$ 表示一个财政政策变量的变化量，$m_i$ 表示在任者的得票率之差（定义为在任者的得票份额减去挑战者的得票份额）。定义二元指标 $Z_i$ 为：如果 $m_i < 0$，则 $Z_i = 1$；否则 $Z_i = 0$。假设在零点周围一个极窄的带宽内，$m_i$ 的符号是准随机的，因此 $Z_i$ 可以作为 $D_i$ 的有效工具变量。考虑以下线性结构关系\n$$\ny_i = \\beta D_i + \\gamma \\cdot 1 + u_i,\n$$\n其中 $1$ 是截距项回归量，$\\beta$ 和 $\\gamma$ 是未知系数，$u_i$ 是一个不可观测的扰动项。假设满足以下正交性条件\n$$\n\\mathbb{E}[u_i] = 0 \\quad \\text{and} \\quad \\mathbb{E}[Z_i u_i] = 0,\n$$\n因此工具变量集是 $\\{1, Z_i\\}$ 的生成空间，且 $D_i$ 可能是内生的。对于每个数据集，只包括满足 $\\lvert m_i \\rvert \\le \\tau$ 的观测值，其中 $\\tau$ 是一个给定的非负阈值。\n\n对于下面的每个数据集，计算满足由上述模型和工具变量 $\\{1, Z_i\\}$ 所隐含的样本正交性条件的唯一 $\\beta$ 值。您的程序必须仅使用所提供的数组为每个数据集计算此值。不允许使用外部输入。最终输出要求为实数。\n\n测试套件（每个数据集提供 $(\\tau, (m_i)_i, (D_i)_i, (y_i)_i)$）：\n\n- 数据集 $1$：\n  - $\\tau = 0.020$,\n  - $m = (-0.010,\\,-0.015,\\,-0.008,\\,0.012,\\,0.005,\\,0.017)$,\n  - $D = (5.0,\\,5.0,\\,5.0,\\,1.0,\\,2.0,\\,3.0)$,\n  - $y = (10.0,\\,10.0,\\,10.0,\\,2.0,\\,4.0,\\,6.0)$.\n\n- 数据集 $2$：\n  - $\\tau = 0.010$,\n  - $m = (-0.004,\\,-0.003,\\,-0.001,\\,0.006,\\,0.009,\\,0.002)$,\n  - $D = (2.6,\\,2.6,\\,2.6,\\,2.5,\\,2.5,\\,2.5)$,\n  - $y = (5.0,\\,5.0,\\,5.0,\\,4.8,\\,4.8,\\,4.8)$.\n\n- 数据集 $3$：\n  - $\\tau = 0.015$,\n  - $m = (-0.010,\\,0.005,\\,0.007,\\,0.008,\\,0.012)$,\n  - $D = (4.0,\\,3.0,\\,3.0,\\,3.0,\\,3.0)$,\n  - $y = (8.5,\\,6.0,\\,6.0,\\,6.0,\\,6.0)$.\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的结果列表，每个数字四舍五入到六位小数。例如，如果计算出的三个值是 $a$、$b$ 和 $c$，则应精确打印以下行\n$[a,b,c]$\n其中 $a$、$b$ 和 $c$ 都四舍五入到六位小数。不得打印任何其他文本。", "solution": "该问题要求在一个含有潜在内生回归量的线性模型中，计算一个结构参数 $\\beta$。估计将使用工具变量（IV）法进行，对于一个恰好识别系统，这是一种两阶段最小二乘法（2SLS）的特定应用。\n\n首先，让我们将问题形式化。给定结果变量 $y_i$ 作为政策变量 $D_i$ 的函数的结构方程：\n$$\ny_i = \\beta D_i + \\gamma \\cdot 1 + u_i\n$$\n此处，$\\beta$ 和 $\\gamma$ 是我们感兴趣的参数，$1$ 代表截距项的回归量，$u_i$ 是一个不可观测的扰动项。变量 $D_i$ 可能是内生的，意味着它可能与 $u_i$ 相关。\n\n为解决此内生性问题，我们获得了一个工具变量 $Z_i$。该工具变量是一个从在任者得票率之差 $m_i$ 导出的二元指标，定义为：如果 $m_i < 0$，则 $Z_i = 1$；否则 $Z_i = 0$。问题提供了允许一致性估计的基本正交性条件：\n$$\n\\mathbb{E}[u_i] = 0 \\quad \\text{and} \\quad \\mathbb{E}[Z_i u_i] = 0\n$$\n这些总体矩条件表明，扰动项 $u_i$ 与常数项以及工具变量 $Z_i$ 不相关。因此，工具变量集是 $\\{1, Z_i\\}$ 的生成空间。\n\n任务是找到满足这些正交性条件的样本类似形式的 $\\beta$ 值。这些样本矩条件是：\n$$\n\\frac{1}{N} \\sum_{i=1}^{N} (y_i - \\hat{\\beta} D_i - \\hat{\\gamma}) = 0 \\\\\n\\frac{1}{N} \\sum_{i=1}^{N} Z_i (y_i - \\hat{\\beta} D_i - \\hat{\\gamma}) = 0\n$$\n其中 $N$ 是观测值的数量，$\\hat{\\beta}$ 和 $\\hat{\\gamma}$ 是 $\\beta$ 和 $\\gamma$ 的估计量。\n\n这是一个包含两个未知数（$\\hat{\\beta}$ 和 $\\hat{\\gamma}$）的二元线性方程组。我们可以解这个方程组来推导出 $\\hat{\\beta}$ 的显式公式。\n从第一个方程，我们可以用 $\\hat{\\beta}$ 来表示 $\\hat{\\gamma}$：\n$$\n\\hat{\\gamma} = \\bar{y} - \\hat{\\beta} \\bar{D}\n$$\n其中 $\\bar{y} = \\frac{1}{N}\\sum y_i$ 和 $\\bar{D} = \\frac{1}{N}\\sum D_i$ 是样本均值。\n将这个 $\\hat{\\gamma}$ 的表达式代入第二个方程得到：\n$$\n\\sum_{i=1}^{N} Z_i (y_i - \\hat{\\beta} D_i - (\\bar{y} - \\hat{\\beta} \\bar{D})) = 0 \\\\\n\\sum_{i=1}^{N} Z_i (y_i - \\bar{y}) - \\hat{\\beta} \\sum_{i=1}^{N} Z_i (D_i - \\bar{D}) = 0\n$$\n解出 $\\hat{\\beta}$ 得到通用的 IV 估计量公式：\n$$\n\\hat{\\beta}_{IV} = \\frac{\\sum_{i=1}^{N} Z_i (y_i - \\bar{y})}{\\sum_{i=1}^{N} Z_i (D_i - \\bar{D})} = \\frac{\\widehat{\\text{Cov}}(Z, y)}{\\widehat{\\text{Cov}}(Z, D)}\n$$\n其中 $\\widehat{\\text{Cov}}(X, V)$ 表示变量 $X$ 和 $V$ 之间的样本协方差。当且仅当分母非零，即 $\\widehat{\\text{Cov}}(Z, D) \\neq 0$ 时，存在唯一解，这就是工具变量相关性条件。\n\n鉴于工具变量 $Z_i$ 是二元的，该估计量简化为沃尔德（Wald）估计量。令 $N_1$ 为 $Z_i=1$ 的观测值数量，$N_0$ 为 $Z_i=0$ 的观测值数量。沃尔德估计量是在由工具变量定义的两组之间，结果变量均值之差与处理变量均值之差的比值：\n$$\n\\hat{\\beta}_{Wald} = \\frac{\\mathbb{E}[y | Z=1] - \\mathbb{E}[y | Z=0]}{\\mathbb{E}[D | Z=1] - \\mathbb{E}[D | Z=0]}\n$$\n其样本类似形式为：\n$$\n\\hat{\\beta} = \\frac{\\bar{y}_{Z=1} - \\bar{y}_{Z=0}}{\\bar{D}_{Z=1} - \\bar{D}_{Z=0}}\n$$\n其中 $\\bar{y}_{Z=j}$ 和 $\\bar{D}_{Z=j}$ 分别是 $Z_i=j$ 的观测值子组中 $y_i$ 和 $D_i$ 的样本均值。此公式在计算上更直接，我们将用它进行计算。\n\n问题规定，对于每个数据集，仅使用 $|m_i| \\le \\tau$ 的观测值。对于所提供的所有三个数据集，每个数据点都满足此条件，因此没有观测值被舍弃。\n\n**数据集 1:**\n- $\\tau = 0.020$\n- $m = (-0.010, -0.015, -0.008, 0.012, 0.005, 0.017)$\n- $D = (5.0, 5.0, 5.0, 1.0, 2.0, 3.0)$\n- $y = (10.0, 10.0, 10.0, 2.0, 4.0, 6.0)$\n\n工具变量向量为 $Z = (1, 1, 1, 0, 0, 0)$。\n对于 $Z_i=1$ 的组（前3个观测值）：\n- $\\bar{y}_{Z=1} = \\frac{10.0 + 10.0 + 10.0}{3} = 10.0$\n- $\\bar{D}_{Z=1} = \\frac{5.0 + 5.0 + 5.0}{3} = 5.0$\n对于 $Z_i=0$ 的组（后3个观测值）：\n- $\\bar{y}_{Z=0} = \\frac{2.0 + 4.0 + 6.0}{3} = 4.0$\n- $\\bar{D}_{Z=0} = \\frac{1.0 + 2.0 + 3.0}{3} = 2.0$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_1 = \\frac{10.0 - 4.0}{5.0 - 2.0} = \\frac{6.0}{3.0} = 2.0\n$$\n\n**数据集 2:**\n- $\\tau = 0.010$\n- $m = (-0.004, -0.003, -0.001, 0.006, 0.009, 0.002)$\n- $D = (2.6, 2.6, 2.6, 2.5, 2.5, 2.5)$\n- $y = (5.0, 5.0, 5.0, 4.8, 4.8, 4.8)$\n\n工具变量向量为 $Z = (1, 1, 1, 0, 0, 0)$。\n对于 $Z_i=1$ 的组：\n- $\\bar{y}_{Z=1} = \\frac{5.0 + 5.0 + 5.0}{3} = 5.0$\n- $\\bar{D}_{Z=1} = \\frac{2.6 + 2.6 + 2.6}{3} = 2.6$\n对于 $Z_i=0$ 的组：\n- $\\bar{y}_{Z=0} = \\frac{4.8 + 4.8 + 4.8}{3} = 4.8$\n- $\\bar{D}_{Z=0} = \\frac{2.5 + 2.5 + 2.5}{3} = 2.5$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_2 = \\frac{5.0 - 4.8}{2.6 - 2.5} = \\frac{0.2}{0.1} = 2.0\n$$\n\n**数据集 3:**\n- $\\tau = 0.015$\n- $m = (-0.010, 0.005, 0.007, 0.008, 0.012)$\n- $D = (4.0, 3.0, 3.0, 3.0, 3.0)$\n- $y = (8.5, 6.0, 6.0, 6.0, 6.0)$\n\n工具变量向量为 $Z = (1, 0, 0, 0, 0)$。\n对于 $Z_i=1$ 的组（第一个观测值）：\n- $\\bar{y}_{Z=1} = 8.5$\n- $\\bar{D}_{Z=1} = 4.0$\n对于 $Z_i=0$ 的组（后4个观测值）：\n- $\\bar{y}_{Z=0} = \\frac{6.0 + 6.0 + 6.0 + 6.0}{4} = 6.0$\n- $\\bar{D}_{Z=0} = \\frac{3.0 + 3.0 + 3.0 + 3.0}{4} = 3.0$\n$\\beta$ 的估计值为：\n$$\n\\hat{\\beta}_3 = \\frac{8.5 - 6.0}{4.0 - 3.0} = \\frac{2.5}{1.0} = 2.5\n$$\n三个数据集计算出的 $\\beta$ 值分别为 $2.0$、$2.0$ 和 $2.5$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the instrumental variables (IV) estimate of beta for three datasets.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"tau\": 0.020,\n            \"m\": np.array([-0.010, -0.015, -0.008, 0.012, 0.005, 0.017]),\n            \"D\": np.array([5.0, 5.0, 5.0, 1.0, 2.0, 3.0]),\n            \"y\": np.array([10.0, 10.0, 10.0, 2.0, 4.0, 6.0]),\n        },\n        {\n            \"tau\": 0.010,\n            \"m\": np.array([-0.004, -0.003, -0.001, 0.006, 0.009, 0.002]),\n            \"D\": np.array([2.6, 2.6, 2.6, 2.5, 2.5, 2.5]),\n            \"y\": np.array([5.0, 5.0, 5.0, 4.8, 4.8, 4.8]),\n        },\n        {\n            \"tau\": 0.015,\n            \"m\": np.array([-0.010, 0.005, 0.007, 0.008, 0.012]),\n            \"D\": np.array([4.0, 3.0, 3.0, 3.0, 3.0]),\n            \"y\": np.array([8.5, 6.0, 6.0, 6.0, 6.0]),\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, m, D, y = case[\"tau\"], case[\"m\"], case[\"D\"], case[\"y\"]\n\n        # Filter the data based on the threshold tau.\n        # For the given problem, all data points satisfy the condition,\n        # but this step ensures correctness for a general case.\n        inclusion_mask = np.abs(m) = tau\n        m_filtered = m[inclusion_mask]\n        D_filtered = D[inclusion_mask]\n        y_filtered = y[inclusion_mask]\n\n        # Construct the binary instrument Z, where Z=1 if m  0.\n        Z = (m_filtered  0).astype(int)\n\n        # Identify the two groups based on the instrument value.\n        Z_is_1_mask = (Z == 1)\n        Z_is_0_mask = (Z == 0)\n\n        # Separate the y and D vectors into two groups.\n        y_group_1 = y_filtered[Z_is_1_mask]\n        y_group_0 = y_filtered[Z_is_0_mask]\n        D_group_1 = D_filtered[Z_is_1_mask]\n        D_group_0 = D_filtered[Z_is_0_mask]\n\n        # The problem statement guarantees a unique solution exists,\n        # which implies both groups are non-empty and the denominator of the\n        # Wald estimator is non-zero.\n        \n        # Calculate the mean of y and D for each group.\n        y_mean_1 = np.mean(y_group_1)\n        y_mean_0 = np.mean(y_group_0)\n        D_mean_1 = np.mean(D_group_1)\n        D_mean_0 = np.mean(D_group_0)\n\n        # Calculate beta using the Wald estimator formula.\n        beta = (y_mean_1 - y_mean_0) / (D_mean_1 - D_mean_0)\n\n        results.append(beta)\n\n    # Format the final output as a comma-separated list of values\n    # rounded to six decimal places, enclosed in square brackets.\n    output_str = \",\".join([f\"{res:.6f}\" for res in results])\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "2445017"}, {"introduction": "对于计算经济学家而言，通过模拟来检验和理解估计方法是一项至关重要的技能。这项综合性练习将引导您走过一个完整的研究流程：首先，根据一个包含已知内生性来源的结构模型生成模拟数据；其次，应用 2SLS 方法进行估计；最后，计算关键的诊断统计量。通过计算第一阶段的 $F$ 统计量 [@problem_id:2445083]，您将学会如何评估工具变量的强度——这是任何可信的工具变量分析中都不可或缺的一步，并观察样本量、工具变量相关性等因素如何影响您的估计结果。", "problem": "给定一个受公司金融背景启发的结构模型，我们关注的焦点是首席执行官（CEO）拥有工商管理硕士（MBA）学位与拥有博士（PhD）学位对公司战略指数的因果效应。结果变量表示为 $Y \\in \\mathbb{R}$（一个标量策略指数）。内生回归量是一个二元处理 $D \\in \\{0,1\\}$，表示CEO是否拥有MBA学位（而非PhD学位）。工具变量是 $Z \\in \\mathbb{R}$，代表CEO大学期间顶尖学校学费的外生指数。有一个观测到的控制变量 $X \\in \\mathbb{R}$（标准化的公司规模代理变量），以及一个不可观测的扰动项 $u \\in \\mathbb{R}$。数据生成过程（DGP）为 $i = 1, \\dots, n$ 定义如下：\n1. 结构结果方程：\n$$\nY_i = \\beta_0 + \\beta_1 D_i + \\gamma X_i + u_i .\n$$\n2. 教育的潜选择和实现的处置：\n$$\nD_i^{\\ast} = \\alpha_0 + \\pi Z_i + \\alpha_X X_i + v_i, \\quad D_i = \\mathbf{1}\\{D_i^{\\ast}  0\\} .\n$$\n3. 内生性通过 $u_i$ 和 $v_i$ 之间的相关性产生：\n$$\nu_i = \\rho v_i + \\sqrt{1 - \\rho^2} \\, \\varepsilon_i ,\n$$\n其中 $v_i \\sim \\mathcal{N}(0,\\sigma_v^2)$，$\\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_u^2)$，并且 $(Z_i, X_i, v_i, \\varepsilon_i)$ 对于不同的 $i$ 相互独立，且彼此联合独立。工具变量外生性成立，因为\n$$\n\\mathbb{E}[Z_i u_i] = 0, \\quad \\text{和} \\quad \\mathbb{E}[Z_i \\,|\\, X_i] = 0 .\n$$\n工具变量相关性由参数 $\\pi$ 控制，较大的 $|\\pi|$ 意味着在给定 $X_i$ 的条件下，$Z_i$ 和 $D_i$ 之间的相关性更强。\n\n结构参数在所有测试案例中都是固定的且相同：\n- $\\beta_0 = 0$, $\\beta_1 = 0.8$, $\\gamma = 0.3$,\n- $\\alpha_0 = 0$, $\\alpha_X = 0.5$.\n\n您的任务是仅使用线性投影逻辑和普通最小二乘法操作，从第一性原理出发实现 $\\beta_1$ 的两阶段最小二乘法（2SLS）估计量。具体来说，将工具变量集视为常数项、工具变量 $Z$ 和控制变量 $X$，将回归量集视为常数项、内生回归量 $D$ 和控制变量 $X$。此外，计算同方差的第一阶段 $F$ 统计量，用于检验在 $D$ 对工具变量集的第一阶段回归中，被排除的工具变量系数为零的原假设。\n\n算法要求：\n- 仅使用最小二乘投影所蕴含的线性代数来构建2SLS估计。您可以使用的推导基础是：普通最小二乘法通过最小化残差平方和来计算线性投影，以及一个有效的工具变量与结构误差不相关且与内生回归量相关。\n- 在工具变量集和回归量集中都包含一个常数项。\n- 通过比较受约束模型（将 $D$ 对常数项和 $X$ 进行回归）和不受约束模型（将 $D$ 对常数项、$Z$ 和 $X$ 进行回归），并使用标准的同方差方差分析恒等式，来计算第一阶段的 $F$ 统计量。\n\n每个测试案例的数据生成协议：\n- 对于每个案例，给定 $(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed})$，为 $i = 1, \\dots, n$ 生成：\n$$\nZ_i \\sim \\mathcal{N}(0,1), \\quad X_i \\sim \\mathcal{N}(0,1), \\quad v_i \\sim \\mathcal{N}(0,\\sigma_v^2), \\quad \\varepsilon_i \\sim \\mathcal{N}(0,\\sigma_u^2),\n$$\n这些变量相互独立。\n- 使用上述方程构建 $D_i^{\\ast}$，然后 $D_i = \\mathbf{1}\\{D_i^{\\ast}  0\\}$，最后构建 $Y_i$。\n\n测试套件：\n为以下四个测试案例提供结果，每个案例由 $(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed})$ 指定：\n- 案例 A（强工具变量，大样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (2000, 1.5, 0.7, 1.0, 1.0, 123)$。\n- 案例 B（弱工具变量，大样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (2000, 0.1, 0.7, 1.0, 1.0, 456)$。\n- 案例 C（强工具变量，小样本）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (100, 1.5, 0.7, 1.0, 1.0, 789)$。\n- 案例 D（无内生性，强工具变量）：$(n, \\pi, \\rho, \\sigma_v, \\sigma_u, \\text{seed}) = (1000, 1.5, 0.0, 1.0, 1.0, 321)$。\n\n每个测试案例需要计算的内容：\n- 使用工具变量集 $\\{1, Z, X\\}$ 对回归量集 $\\{1, D, X\\}$ 计算 $\\beta_1$ 的2SLS估计值 $\\hat{\\beta}_1$。\n- 在 $D$ 对 $\\{1, Z, X\\}$ 的第一阶段线性回归中，检验关于 $Z$ 的系数为零的原假设的第一阶段同方差 $F$ 统计量。\n\n输出规格：\n- 您的程序应生成单行输出，其中包含一个长度为 $4$ 的列表，每个条目按 A、B、C、D 的顺序对应一个测试案例。\n- 每个条目必须是一个双元素列表 $[\\hat{\\beta}_1, F]$。\n- 每个数字必须四舍五入到 $6$ 位小数。\n- 因此，最终输出必须是完全符合以下格式的单行：\n$$\n\\text{[}[\\hat{\\beta}_1^{(A)}, F^{(A)}],[\\hat{\\beta}_1^{(B)}, F^{(B)}],[\\hat{\\beta}_1^{(C)}, F^{(C)}],[\\hat{\\beta}_1^{(D)}, F^{(D)}]\\text{]}.\n$$\n不应打印任何额外的文本。", "solution": "所提出的问题是计算计量经济学中一个定义明确且有科学依据的练习，要求为模拟数据集实现两阶段最小二乘法（2SLS）估计量并计算第一阶段的F统计量。数据生成过程定义清晰，并提供了所有必要的参数。该问题是有效的。\n\n问题的核心在于回归量 $D_i$ 的内生性。结构方程为：\n$$\nY_i = \\beta_0 + \\beta_1 D_i + \\gamma X_i + u_i\n$$\n内生性之所以产生，是因为回归量 $D_i$ 与误差项 $u_i$ 相关，即 $\\mathbb{E}[D_i u_i] \\neq 0$。这种相关性源于 $D_i$ 和 $u_i$ 都是同一不可观测随机冲击 $v_i$ 的函数。因此，对该结构方程应用普通最小二乘法（OLS）将对我们感兴趣的参数 $\\beta_1$ 产生有偏且不一致的估计量。\n\n工具变量法（IV），特别是2SLS估计量，旨在解决此问题。它使用一个工具变量 $Z_i$，该变量与内生回归量 $D_i$ 相关（相关性），但与结构误差项 $u_i$ 不相关（外生性）。\n\n让我们用矩阵表示法来表述这个问题。设 $n$ 为样本量。该模型可以写成：\n$$\n\\mathbf{y} = \\mathbf{W}\\boldsymbol{\\theta} + \\mathbf{u}\n$$\n其中：\n- $\\mathbf{y}$ 是结果 $Y_i$ 的 $n \\times 1$ 向量。\n- $\\mathbf{W}$ 是 $n \\times 3$ 的回归量矩阵：$\\mathbf{W} = [\\mathbf{1}_n, \\mathbf{d}, \\mathbf{x}]$，其中 $\\mathbf{1}_n$ 是元素全为1的向量，$\\mathbf{d}$ 是处置 $D_i$ 的向量，$\\mathbf{x}$ 是控制变量 $X_i$ 的向量。\n- $\\boldsymbol{\\theta}$ 是 $3 \\times 1$ 的参数向量：$\\boldsymbol{\\theta} = [\\beta_0, \\beta_1, \\gamma]^T$。\n- $\\mathbf{u}$ 是结构误差 $u_i$ 的 $n \\times 1$ 向量。\n\n内生性问题意味着 $\\mathbb{E}[\\mathbf{W}^T\\mathbf{u}] \\neq \\mathbf{0}$，因为 $\\mathbf{W}$ 的列 $\\mathbf{d}$ 与 $\\mathbf{u}$ 相关。\n\n2SLS程序通过使用一组工具变量来解决这个问题。设 $\\mathbf{Z}$ 为 $n \\times 3$ 的工具变量矩阵，由被排除的工具变量 $\\mathbf{z}$（$Z_i$ 的向量）和来自 $\\mathbf{W}$ 的外生回归量（即常数项和控制变量 $\\mathbf{x}$）组成。因此，$\\mathbf{Z} = [\\mathbf{1}_n, \\mathbf{z}, \\mathbf{x}]$。这些工具变量的有效性取决于条件 $\\mathbb{E}[\\mathbf{Z}^T\\mathbf{u}] = \\mathbf{0}$。\n\n2SLS估计量源于线性投影原理，分两个阶段执行：\n\n**Stage 1: Purging the Endogenous Regressor**\n第一阶段从回归量 $\\mathbf{d}$ 中清除内生部分。这是通过将 $\\mathbf{d}$ 线性投影到工具变量矩阵 $\\mathbf{Z}$ 的列空间来实现的。该投影等价于将 $\\mathbf{d}$ 对 $\\mathbf{Z}$ 进行OLS回归。该回归的预测值，记为 $\\hat{\\mathbf{d}}$，代表了 $\\mathbf{d}$ 中可由工具变量线性解释的部分。\n此回归的OLS系数向量为 $\\hat{\\boldsymbol{\\pi}} = (\\mathbf{Z}^T\\mathbf{Z})^{-1}\\mathbf{Z}^T\\mathbf{d}$。\n预测值为 $\\hat{\\mathbf{d}} = \\mathbf{Z}\\hat{\\boldsymbol{\\pi}}$。注意，由于外生回归量 $\\mathbf{1}_n$ 和 $\\mathbf{x}$ 已包含在工具变量集 $\\mathbf{Z}$ 中，它们在由 $\\mathbf{Z}$ 张成的空间上的投影就是它们自身。因此，我们构建一个“净化后”的回归量矩阵 $\\hat{\\mathbf{W}} = [\\mathbf{1}_n, \\hat{\\mathbf{d}}, \\mathbf{x}]$。根据构造，$\\hat{\\mathbf{W}}$ 仅是 $\\mathbf{Z}$ 的函数，因此在大样本中与 $\\mathbf{u}$ 不相关。\n\n**Stage 2: Estimating the Structural Parameters**\n第二阶段包括将结果变量 $\\mathbf{y}$ 对净化后的回归量矩阵 $\\hat{\\mathbf{W}}$ 进行OLS回归。得到的系数向量即为2SLS估计量 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$。\n$$\n\\hat{\\boldsymbol{\\theta}}_{2SLS} = (\\hat{\\mathbf{W}}^T \\hat{\\mathbf{W}})^{-1} \\hat{\\mathbf{W}}^T \\mathbf{y}\n$$\n我们感兴趣的参数 $\\hat{\\beta}_1$ 是此向量 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$ 的第二个元素。\n\n**First-Stage F-Statistic for Instrument Relevance**\n有效的IV估计的一个关键条件是工具变量相关性，即在给定其他外生变量的情况下，被排除的工具变量必须与内生回归量显著相关。弱工具变量的一个常用诊断是第一阶段F统计量。该统计量检验在第一阶段回归中，被排除工具变量的系数全部为零的原假设。\n\n在这个问题中，我们有一个内生回归量 $D_i$ 和一个被排除的工具变量 $Z_i$。第一阶段是 $D_i$ 对 $1$，$Z_i$ 和 $X_i$ 的线性回归：\n$$\nD_i = \\pi_0 + \\pi_Z Z_i + \\pi_X X_i + \\text{residual}_i\n$$\n我们检验原假设 $H_0: \\pi_Z = 0$。这是通过比较此无约束模型的残差平方和（SSR）与将 $\\pi_Z$ 强制为零的受约束模型的SSR来完成的。\n\n- **无约束模型：** 将 $\\mathbf{d}$ 对 $\\mathbf{Z} = [\\mathbf{1}_n, \\mathbf{z}, \\mathbf{x}]$ 进行回归。设残差平方和为 $SSR_{unres}$。\n- **有约束模型：** 将 $\\mathbf{d}$ 对 $\\mathbf{Z}_{res} = [\\mathbf{1}_n, \\mathbf{x}]$ 进行回归。设残差平方和为 $SSR_{res}$。\n\n然后，同方差F统计量的计算公式为：\n$$\nF = \\frac{(SSR_{res} - SSR_{unres}) / q}{SSR_{unres} / (n - k_{unres})}\n$$\n其中 $q$ 是被排除工具变量的数量（这里，$q=1$），$k_{unres}$ 是无约束第一阶段模型中的参数数量（这里，$k_{unres}=3$，分别对应截距项、$Z_i$ 和 $X_i$）。\n\n每个测试案例的实现将按以下步骤进行：\n1. 根据指定的DGP生成数据 $(Y_i, D_i, Z_i, X_i)$，其中 $i=1, \\dots, n$。\n2. 构建矩阵 $\\mathbf{y}$、$\\mathbf{d}$、$\\mathbf{W}$ 和 $\\mathbf{Z}$。\n3. 对 $\\mathbf{d}$ 和 $\\mathbf{Z}$ 进行第一阶段回归以获得 $\\hat{\\mathbf{d}}$。这也将得出 $SSR_{unres}$。\n4. 对 $\\mathbf{y}$ 和 $\\hat{\\mathbf{W}} = [\\mathbf{1}_n, \\hat{\\mathbf{d}}, \\mathbf{x}]$ 进行第二阶段回归以获得 $\\hat{\\boldsymbol{\\theta}}_{2SLS}$，并提取 $\\hat{\\beta}_1$。\n5. 对 $\\mathbf{d}$ 和 $[\\mathbf{1}_n, \\mathbf{x}]$ 进行有约束回归以获得 $SSR_{res}$。\n6. 使用上述公式计算F统计量。\n7. 存储并格式化得到的 $(\\hat{\\beta}_1, F)$ 对。", "answer": "```python\nimport numpy as np\n\ndef run_case(n, pi, rho, sigma_v, sigma_u, seed):\n    \"\"\"\n    Generates data and computes the 2SLS estimate and first-stage F-statistic\n    for a single test case.\n    \"\"\"\n    # Set seed for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # Fixed parameters\n    beta_0 = 0.0\n    beta_1 = 0.8\n    gamma = 0.3\n    alpha_0 = 0.0\n    alpha_X = 0.5\n\n    # 1. Data Generation\n    Z = rng.normal(loc=0, scale=1, size=n)\n    X = rng.normal(loc=0, scale=1, size=n)\n    v = rng.normal(loc=0, scale=sigma_v, size=n)\n    epsilon = rng.normal(loc=0, scale=sigma_u, size=n)\n\n    # Latent variable for D\n    D_star = alpha_0 + pi * Z + alpha_X * X + v\n    # Realized treatment\n    D = (D_star  0).astype(float)\n\n    # Structural error\n    u = rho * v + np.sqrt(1 - rho**2) * epsilon\n\n    # Outcome variable\n    Y = beta_0 + beta_1 * D + gamma * X + u\n\n    # Reshape for matrix operations\n    y_vec = Y.reshape(-1, 1)\n    d_vec = D.reshape(-1, 1)\n\n    # Define matrices for 2SLS\n    # Regressor matrix W = [1, D, X]\n    W = np.c_[np.ones(n), D, X]\n    # Instrument matrix Z_mat = [1, Z, X]\n    Z_mat = np.c_[np.ones(n), Z, X]\n\n    # 2. 2SLS Estimation using explicit two stages\n    # Stage 1: Regress D on Z_mat to get D_hat\n    try:\n        # OLS formula: (Z'Z)^{-1}Z'd\n        ZTZ_inv = np.linalg.inv(Z_mat.T @ Z_mat)\n        pi_hat_vec = ZTZ_inv @ Z_mat.T @ d_vec\n        D_hat = Z_mat @ pi_hat_vec\n    except np.linalg.LinAlgError:\n        # In case of perfect multicollinearity (highly unlikely with random data)\n        return [np.nan, np.nan]\n\n    # Stage 2: Regress Y on [1, D_hat, X]\n    W_hat = np.c_[np.ones(n), D_hat, X]\n    try:\n        # OLS formula: (W_hat'W_hat)^{-1}W_hat'y\n        WHatTWHat_inv = np.linalg.inv(W_hat.T @ W_hat)\n        theta_hat_2sls = WHatTWHat_inv @ W_hat.T @ y_vec\n        beta1_hat = theta_hat_2sls[1, 0]\n    except np.linalg.LinAlgError:\n        beta1_hat = np.nan\n\n    # 3. First-Stage F-statistic Calculation\n    # Unrestricted model (D on 1, Z, X) residuals\n    # Predicted values are simply D_hat\n    residuals_unres = d_vec - D_hat\n    SSR_unres = residuals_unres.T @ residuals_unres\n\n    # Restricted model (D on 1, X)\n    Z_res = np.c_[np.ones(n), X]\n    try:\n        # OLS on restricted model\n        ZresTZres_inv = np.linalg.inv(Z_res.T @ Z_res)\n        delta_hat = ZresTZres_inv @ Z_res.T @ d_vec\n        D_hat_res = Z_res @ delta_hat\n        \n        residuals_res = d_vec - D_hat_res\n        SSR_res = residuals_res.T @ residuals_res\n    except np.linalg.LinAlgError:\n        SSR_res = np.nan\n\n    # Compute F-statistic\n    q = 1  # Number of excluded instruments\n    k_unres = Z_mat.shape[1]  # Number of regressors in unrestricted first stage\n    \n    if SSR_unres  0 and not np.isnan(SSR_res):\n        numerator = (SSR_res - SSR_unres) / q\n        denominator = SSR_unres / (n - k_unres)\n        F_stat = (numerator / denominator)[0, 0]\n    else:\n        F_stat = np.nan\n\n    return [beta1_hat, F_stat]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the final results.\n    \"\"\"\n    test_cases = [\n        # Case A: Strong instrument, large sample\n        (2000, 1.5, 0.7, 1.0, 1.0, 123),\n        # Case B: Weak instrument, large sample\n        (2000, 0.1, 0.7, 1.0, 1.0, 456),\n        # Case C: Strong instrument, small sample\n        (100, 1.5, 0.7, 1.0, 1.0, 789),\n        # Case D: No endogeneity, strong instrument\n        (1000, 1.5, 0.0, 1.0, 1.0, 321),\n    ]\n\n    results_as_strings = []\n    for case_params in test_cases:\n        n, pi, rho, sigma_v, sigma_u, seed = case_params\n        beta1_hat, f_stat = run_case(n, pi, rho, sigma_v, sigma_u, seed)\n        \n        # Format results to 6 decimal places\n        formatted_beta1 = f\"{beta1_hat:.6f}\"\n        formatted_f_stat = f\"{f_stat:.6f}\"\n        \n        results_as_strings.append(f\"[{formatted_beta1},{formatted_f_stat}]\")\n\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2445083"}]}