{"hands_on_practices": [{"introduction": "在应用一阶扰动法时，一个常见的选择是究竟在变量的水平（例如 $k_t$）上还是在它们的对数（例如 $\\log k_t$）上进行线性化。本练习将探讨这两种方法之间的关系。通过编程实现这两种方法并比较结果，你将发现一阶近似的一个基本性质：它们在一阶上是等价的。[@problem_id:2418943] 这个练习将巩固你对一阶近似真正含义的理解，并增强你对该技术鲁棒性的信心，无论选择何种变量变换方式。", "problem": "考虑具有Cobb-Douglas技术和外生生产率的随机Solow增长模型：\n- 资本根据 $k_{t+1} = s \\, a_t \\, k_t^{\\alpha} + (1-\\delta) k_t$ 演化，其中 $k_t > 0$ 是资本，$s \\in (0,1)$ 是储蓄率，$\\alpha \\in (0,1)$ 是资本的产出弹性，$\\delta \\in (0,1)$ 是折旧率。\n- 生产率满足 $a_t = \\exp(z_t)$，其中对数生产率遵循自回归过程 $z_t = (1-\\rho)\\,\\bar z + \\rho\\, z_{t-1} + \\sigma \\varepsilon_t$，这里 $|\\rho| < 1$，$\\sigma \\ge 0$，$\\varepsilon_t$ 是均值为 $0$、单位方差的独立同分布（i.i.d.）新息。\n- 设确定性稳态为 $(\\bar k, \\bar z)$，其中 $\\bar a = \\exp(\\bar z)$ 且 $\\bar k$ 求解 $\\bar k = s \\bar a \\bar k^{\\alpha} + (1-\\delta)\\bar k$。\n\n你需要比较在确定性稳态附近，两种一阶扰动方法下资本的脉冲响应函数：\n- 水平线性化：在变量 $(k_t, z_t)$ 中进行线性化。\n- 对数线性化：在 $(\\log k_t, z_t)$ 中进行线性化，并使用一阶映射 $k_t \\approx \\bar k (1 + \\hat k_t)$ 报告资本的水平响应，其中 $\\hat k_t = \\log(k_t) - \\log(\\bar k)$。\n\n通过设置 $\\varepsilon_0 = 1$ 和对于所有 $t \\ge 1$ 设置 $\\varepsilon_t = 0$ 来定义在日期 $t=0$ 时对一个标准差生产率冲击的脉冲响应，初始条件为 $k_0 = \\bar k$ 和 $z_{-1} = \\bar z$。在两种方法下，构建 $k_t$ 在有限期界 $t=0,1,\\dots,H$ 内的脉冲响应，保持近似阶数为一阶。对于下面的每一组参数，计算在 $t=0,1,\\dots,H$ 范围内，两种水平资本响应之间的最大绝对差。\n\n测试套件（每行为一个独立案例，按所列顺序进行评估）：\n- 案例 A (正常路径): $\\alpha = 0.35$, $\\delta = 0.08$, $s = 0.25$, $\\rho = 0.90$, $\\sigma = 0.01$, $\\bar z = 0$, $H = 20$。\n- 案例 B (低折旧): $\\alpha = 0.33$, $\\delta = 0.01$, $s = 0.15$, $\\rho = 0.80$, $\\sigma = 0.02$, $\\bar z = 0$, $H = 30$。\n- 案例 C (无持续性): $\\alpha = 0.40$, $\\delta = 0.12$, $s = 0.30$, $\\rho = 0$, $\\sigma = 0.05$, $\\bar z = 0$, $H = 15$。\n- 案例 D (高持续性): $\\alpha = 0.30$, $\\delta = 0.05$, $s = 0.20$, $\\rho = 0.99$, $\\sigma = 0.005$, $\\bar z = 0$, $H = 40$。\n- 案例 E (零冲击规模): $\\alpha = 0.33$, $\\delta = 0.10$, $s = 0.20$, $\\rho = 0.95$, $\\sigma = 0$, $\\bar z = 0$, $H = 20$。\n\n你的程序必须：\n- 根据模型定义和参数，从第一性原理计算 $\\bar k$。\n- 构建水平和对数的一阶扰动动态。\n- 对于每个案例，在指定期界内模拟两种方法下 $k_t$ 的脉冲响应，并计算在 $t=0,1,\\dots,H$ 上的最大绝对差。\n- 输出单行，其中包含一个用逗号分隔的这些最大值列表，按 A 到 E 的顺序排列，并用方括号括起来。每个值必须是四舍五入到 $12$ 位小数的浮点数。例如，一个包含三个案例的输出应类似于 $[x_1,x_2,x_3]$，没有空格。\n\n不涉及物理单位。不出现角度。任何地方都不得使用百分比；所有值都是实数。", "solution": "用户提供的问题陈述已经过严格验证，被认为是有效的。它具有科学依据，问题设定良好，客观，并包含推导出唯一解所需的所有必要信息。我们现在进行一个完整的、有理有据的解答。\n\n该问题要求比较两种用于求解随机 Solow 增长模型的一阶扰动方法。分析的核心在于推导两种方法的线性化动态，模拟资本对生产率冲击的脉冲响应，并计算两条最终资本路径之间的最大绝对差。\n\n首先，我们定义模型方程：\n1.  资本积累：$k_{t+1} = s \\, a_t \\, k_t^{\\alpha} + (1-\\delta) k_t$，其中 $a_t = \\exp(z_t)$。\n2.  对数生产率过程：$z_t = (1-\\rho)\\,\\bar z + \\rho\\, z_{t-1} + \\sigma \\varepsilon_t$。\n\n我们来确定确定性稳态 $(\\bar k, \\bar z)$。在此状态下，没有冲击（$\\varepsilon_t = 0$），因此对于所有 $t$ 都有 $z_t = \\bar z$。资本存量是恒定的，$k_t = k_{t+1} = \\bar k$。稳态由以下方程定义：\n$$\n\\bar k = s \\, \\exp(\\bar z) \\, \\bar k^{\\alpha} + (1-\\delta) \\bar k\n$$\n令 $\\bar a = \\exp(\\bar z)$，我们简化为：\n$$\n\\delta \\bar k = s \\bar a \\bar k^{\\alpha}\n$$\n由于 $k_t > 0$，我们知道 $\\bar k > 0$。我们可以除以 $\\bar k^{\\alpha}$：\n$$\n\\delta \\bar k^{1-\\alpha} = s \\bar a\n$$\n求解 $\\bar k$ 得到稳态资本存量：\n$$\n\\bar k = \\left(\\frac{s \\bar a}{\\delta}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n\n接下来，我们分析扰动方法。让偏离稳态的量用波浪号表示，例如 $\\tilde k_t = k_t - \\bar k$ 和 $\\tilde z_t = z_t - \\bar z$。$\\tilde z_t$ 的外生过程可以通过从 $z_t$ 的方程中减去 $\\bar z$ 来找到：\n$$\nz_t - \\bar z = (1-\\rho)\\bar z + \\rho z_{t-1} + \\sigma \\varepsilon_t - \\bar z = \\rho(z_{t-1} - \\bar z) + \\sigma \\varepsilon_t\n$$\n$$\n\\tilde z_t = \\rho \\tilde z_{t-1} + \\sigma \\varepsilon_t\n$$\n给定初始条件 $z_{-1} = \\bar z$（$\\tilde z_{-1}=0$）和一次性冲击 $\\varepsilon_0 = 1$（对于 $t \\ge 1$ 有 $\\varepsilon_t=0$），$\\tilde z_t$ 的路径是：\n$$\n\\tilde z_0 = \\rho \\tilde z_{-1} + \\sigma \\varepsilon_0 = \\sigma\n$$\n$$\n\\tilde z_1 = \\rho \\tilde z_0 + \\sigma \\varepsilon_1 = \\rho \\sigma\n$$\n$$\n\\tilde z_t = \\rho^t \\sigma \\quad \\text{for } t \\ge 0\n$$\n\n**1. 水平线性化**\n\n我们在稳态 $(\\bar k, \\bar z)$ 附近对资本积累方程 $k_{t+1} = f(k_t, z_t)$ 进行线性化。一阶泰勒展开给出：\n$$\nk_{t+1} - \\bar k \\approx \\frac{\\partial f}{\\partial k_t}\\bigg|_{(\\bar k, \\bar z)} (k_t - \\bar k) + \\frac{\\partial f}{\\partial z_t}\\bigg|_{(\\bar k, \\bar z)} (z_t - \\bar z)\n$$\n$$\n\\tilde k_{t+1} \\approx J_k \\tilde k_t + J_z \\tilde z_t\n$$\n所需的偏导数为：\n$$\nJ_k = \\frac{\\partial f}{\\partial k_t}\\bigg|_{(\\bar k, \\bar z)} = s \\bar a \\alpha \\bar k^{\\alpha-1} + (1-\\delta)\n$$\n使用稳态条件 $s \\bar a = \\delta \\bar k^{1-\\alpha}$，我们有：\n$$\nJ_k = (\\delta \\bar k^{1-\\alpha}) \\alpha \\bar k^{\\alpha-1} + (1-\\delta) = \\alpha \\delta + 1 - \\delta = 1 - \\delta(1-\\alpha)\n$$\n$$\nJ_z = \\frac{\\partial f}{\\partial z_t}\\bigg|_{(\\bar k, \\bar z)} = s \\exp(z_t) k_t^\\alpha \\bigg|_{(\\bar k, \\bar z)} = s \\bar a \\bar k^\\alpha\n$$\n再次使用稳态条件 $\\delta \\bar k = s \\bar a \\bar k^\\alpha$：\n$$\nJ_z = \\delta \\bar k\n$$\n因此，水平线性化系统为：\n$$\n\\tilde k_{t+1}^{\\text{level}} = (1 - \\delta(1-\\alpha)) \\tilde k_t^{\\text{level}} + (\\delta \\bar k) \\tilde z_t\n$$\n资本的水平脉冲响应，记为 $k_t^{\\text{level}}$，是 $k_t^{\\text{level}} = \\bar k + \\tilde k_t^{\\text{level}}$。\n\n**2. 对数线性化**\n\n我们根据对数偏离稳态的方式对模型进行线性化。令 $\\hat k_t = \\log(k_t) - \\log(\\bar k)$。用于线性化的状态变量是 $(\\log k_t, z_t)$。资本积累方程不能轻易地取对数。相反，我们直接对函数 $k_{t+1}(\\log k_t, z_t)$ 进行线性化。一个更稳健的方法是在稳态附近对以下隐函数进行线性化：\n$$\n\\log(k_{t+1}) = \\log\\left(s \\exp(z_t) k_t^\\alpha + (1-\\delta)k_t\\right)\n$$\n令 $x_t = \\log k_t$。$\\hat k_{t+1} = \\log(k_{t+1}) - \\log(\\bar k)$ 的线性化方程是：\n$$\n\\hat k_{t+1} \\approx \\frac{\\partial \\log(k_{t+1})}{\\partial x_t}\\bigg|_{SS} \\hat k_t + \\frac{\\partial \\log(k_{t+1})}{\\partial z_t}\\bigg|_{SS} \\tilde z_t\n$$\n导数是：\n$$\n\\frac{\\partial \\log(k_{t+1})}{\\partial x_t} = \\frac{1}{k_{t+1}} \\frac{\\partial k_{t+1}}{\\partial x_t} = \\frac{1}{k_{t+1}} \\frac{\\partial}{\\partial x_t}\\left(s e^{z_t} e^{\\alpha x_t} + (1-\\delta)e^{x_t}\\right) = \\frac{s e^{z_t} \\alpha e^{\\alpha x_t} + (1-\\delta)e^{x_t}}{s e^{z_t} e^{\\alpha x_t} + (1-\\delta)e^{x_t}}\n$$\n在稳态（$x_t=\\log \\bar k, z_t=\\bar z, k_{t+1}=\\bar k$）下求值，这变成：\n$$\n\\frac{s \\bar a \\alpha \\bar k^\\alpha + (1-\\delta)\\bar k}{s \\bar a \\bar k^\\alpha + (1-\\delta)\\bar k} = \\frac{\\alpha(\\delta \\bar k) + (1-\\delta)\\bar k}{\\bar k} = \\alpha\\delta + 1 - \\delta = 1 - \\delta(1-\\alpha)\n$$\n对于 $z_t$：\n$$\n\\frac{\\partial \\log(k_{t+1})}{\\partial z_t} = \\frac{1}{k_{t+1}} \\frac{\\partial k_{t+1}}{\\partial z_t} = \\frac{s e^{z_t} k_t^\\alpha}{k_{t+1}}\n$$\n在稳态下求值，这为：\n$$\n\\frac{s \\bar a \\bar k^\\alpha}{\\bar k} = \\frac{\\delta \\bar k}{\\bar k} = \\delta\n$$\n对数线性化的动态是：\n$$\n\\hat k_{t+1}^{\\text{log}} = (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t\n$$\n问题指定使用一阶近似 $k_t \\approx \\bar k(1 + \\hat k_t)$ 将其转换回水平值。所以，$k_t^{\\text{log}} = \\bar k(1 + \\hat k_t^{\\text{log}})$。\n\n**3. 脉冲响应的比较**\n\n我们必须比较两条路径 $k_t^{\\text{level}}$ 和 $k_t^{\\text{log}}$ 在 $t=0, 1, \\dots, H$ 上的情况。\n初始条件是 $k_0 = \\bar k$ 和 $z_{-1} = \\bar z$。这意味着：\n- $k_0^{\\text{level}} = \\bar k$，所以 $\\tilde k_0^{\\text{level}} = 0$。\n- 对于对数线性化情况，$\\log(k_0) = \\log(\\bar k)$，所以 $\\hat k_0^{\\text{log}} = 0$。因此 $k_0^{\\text{log}} = \\bar k(1+0) = \\bar k$。\n在 $t=0$ 时，差值 $|k_0^{\\text{level}} - k_0^{\\text{log}}|$ 为 $0$。\n\n我们来考察 $t \\ge 1$ 时的关系。\n水平偏差的路径由 $\\tilde k_{t+1}^{\\text{level}} = (1 - \\delta(1-\\alpha)) \\tilde k_t^{\\text{level}} + (\\delta \\bar k) \\tilde z_t$ 给出。\n对数偏差的路径是 $\\hat k_{t+1}^{\\text{log}} = (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t$。\n\n让我们定义一个缩放后的对数偏差 $Y_t = \\bar k \\hat k_t^{\\text{log}}$。$Y_t$ 的演化过程是：\n$$\nY_{t+1} = \\bar k \\hat k_{t+1}^{\\text{log}} = \\bar k \\left( (1 - \\delta(1-\\alpha)) \\hat k_t^{\\text{log}} + \\delta \\tilde z_t \\right)\n$$\n$$\nY_{t+1} = (1 - \\delta(1-\\alpha)) (\\bar k \\hat k_t^{\\text{log}}) + (\\bar k \\delta) \\tilde z_t\n$$\n$$\nY_{t+1} = (1 - \\delta(1-\\alpha)) Y_t + (\\delta \\bar k) \\tilde z_t\n$$\n$Y_t$ 的这个递推关系与 $\\tilde k_t^{\\text{level}}$ 的递推关系相同。初始条件也相同：\n- $\\tilde k_0^{\\text{level}} = 0$。\n- $Y_0 = \\bar k \\hat k_0^{\\text{log}} = \\bar k \\cdot 0 = 0$。\n\n由于序列 $\\left\\{\\tilde k_t^{\\text{level}}\\right\\}$ 和 $\\left\\{Y_t\\right\\}$ 都是由相同的线性递推关系生成，并从相同的初始条件开始，所以它们对于所有 $t$ 都必须是相同的。\n$$\n\\tilde k_t^{\\text{level}} = Y_t = \\bar k \\hat k_t^{\\text{log}} \\quad \\forall t \\ge 0\n$$\n现在我们计算两条资本路径之间的差异：\n$$\nk_t^{\\text{level}} - k_t^{\\text{log}} = (\\bar k + \\tilde k_t^{\\text{level}}) - \\bar k(1 + \\hat k_t^{\\text{log}}) = \\bar k + \\tilde k_t^{\\text{level}} - \\bar k - \\bar k \\hat k_t^{\\text{log}} = \\tilde k_t^{\\text{level}} - \\bar k \\hat k_t^{\\text{log}}\n$$\n根据我们上面的证明，对于所有 $t \\ge 0$，这个差值恒为零。\n$$\nk_t^{\\text{level}} - k_t^{\\text{log}} = 0 \\quad \\forall t \\ge 0\n$$\n因此，在期界 $t=0, 1, \\dots, H$ 内的最大绝对差也为 $0$。这个结果表明，当对数线性化通过其自身的一阶近似转换回水平值时，它与水平线性化是一阶等价的。这对任何给定的有效参数集都成立。数值实现将计算路径及其差异，该差异应在机器精度范围内为零。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute difference between capital impulse responses\n    from levels-linearization and log-linearization for the stochastic Solow model.\n    \"\"\"\n    # Test suite: (alpha, delta, s, rho, sigma, z_bar, H)\n    test_cases = [\n        (0.35, 0.08, 0.25, 0.90, 0.01, 0.0, 20),   # Case A\n        (0.33, 0.01, 0.15, 0.80, 0.02, 0.0, 30),   # Case B\n        (0.40, 0.12, 0.30, 0.0, 0.05, 0.0, 15),    # Case C\n        (0.30, 0.05, 0.20, 0.99, 0.005, 0.0, 40),  # Case D\n        (0.33, 0.10, 0.20, 0.95, 0.0, 0.0, 20),    # Case E\n    ]\n\n    max_diffs = []\n\n    for case in test_cases:\n        alpha, delta, s, rho, sigma, z_bar, H = case\n        \n        # 1. Compute steady state\n        a_bar = np.exp(z_bar)\n        # Handle alpha=1 edge case to avoid division by zero, though not in test cases\n        if abs(1.0 - alpha)  1e-12:\n            # This case is not economically standard and not in test suite.\n            # A placeholder, though it won't be reached.\n            k_bar = 1.0 \n        else:\n            k_bar = (s * a_bar / delta) ** (1.0 / (1.0 - alpha))\n\n        # 2. Simulate the exogenous shock process z_t\n        # Path of z_tilde_t = z_t - z_bar\n        z_tilde_path = np.zeros(H + 1)\n        if sigma != 0:\n            for t in range(H + 1):\n                z_tilde_path[t] = (rho ** t) * sigma\n        \n        # 3. Simulate impulse responses for both methods\n        \n        # Levels linearization\n        k_level_path = np.zeros(H + 1)\n        k_tilde_level_path = np.zeros(H + 1)\n        \n        # Log-linearization\n        k_log_path = np.zeros(H + 1)\n        k_hat_log_path = np.zeros(H + 1)\n\n        # Initial conditions at t=0\n        # k_0 = k_bar implies k_tilde_0 = 0 and k_hat_0 = 0\n        k_level_path[0] = k_bar\n        k_log_path[0] = k_bar\n\n        # Coefficients for the recurrence relations\n        coeff_k = 1.0 - delta * (1.0 - alpha)\n        coeff_z_level = delta * k_bar\n        coeff_z_log = delta\n\n        # Iterate from t=0 to H-1 to find states at t=1..H\n        for t in range(H):\n            # Levels-linearization update\n            k_tilde_level_path[t+1] = coeff_k * k_tilde_level_path[t] + coeff_z_level * z_tilde_path[t]\n            k_level_path[t+1] = k_bar + k_tilde_level_path[t+1]\n\n            # Log-linearization update\n            k_hat_log_path[t+1] = coeff_k * k_hat_log_path[t] + coeff_z_log * z_tilde_path[t]\n            k_log_path[t+1] = k_bar * (1.0 + k_hat_log_path[t+1])\n\n        # 4. Compute the maximum absolute difference\n        abs_diff = np.abs(k_level_path - k_log_path)\n        max_abs_diff = np.max(abs_diff)\n        \n        max_diffs.append(f\"{max_abs_diff:.12f}\")\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(max_diffs)}]\")\n\nsolve()\n```", "id": "2418943"}, {"introduction": "在应用扰动法之前，一个至关重要且不可妥协的步骤是正确识别模型的确定性稳态，该稳态将作为展开点。本练习将有意引导你围绕错误的点进行模型线性化。通过观察由此产生的不稳定或无意义的脉冲响应函数，你将直观而深刻地理解为何展开点必须是真实的均衡点。[@problem_id:2418938] 这是一个警示性的实践，突出了在扰动法实际应用中最常见也最致命的错误之一。", "problem": "考虑一个标准的、具有非弹性劳动和对数效用的单部门真实商业周期（RBC）模型。时间是离散的。代表性家庭在资源约束下最大化其预期贴现效用，而企业使用柯布-道格拉斯技术进行生产。结构性环境如下：\n- 偏好：$\\sum_{t=0}^{\\infty} \\beta^{t} \\log(c_{t})$，其中贴现因子 $\\beta \\in (0,1)$。\n- 技术：$y_{t} = \\exp(z_{t}) k_{t}^{\\alpha}$，其中资本份额 $\\alpha \\in (0,1)$。\n- 资本积累与资源可行性：$c_{t} + k_{t+1} = (1-\\delta) k_{t} + y_{t}$，其中折旧率 $\\delta \\in (0,1)$。\n- 生产率冲击：$z_{t+1} = \\rho z_{t} + \\sigma \\varepsilon_{t+1}$，其中 $|\\rho|  1$，$\\sigma0$，且 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0,1)$。\n\n基本均衡一阶条件为：\n- 欧拉方程：$\\dfrac{1}{c_{t}} = \\beta \\, \\mathbb{E}_{t} \\left[ \\dfrac{1}{c_{t+1}} \\left( \\alpha \\exp(z_{t+1}) k_{t+1}^{\\alpha-1} + 1 - \\delta \\right) \\right]$。\n- 资源可行性：$c_{t} + k_{t+1} - (1-\\delta)k_{t} - \\exp(z_{t}) k_{t}^{\\alpha} = 0$。\n\n令预定内生变量向量为 $x_{t} = k_{t}$，非预定内生（跳跃）变量向量为 $y_{t} = c_{t}$，外生状态向量为 $z_{t}$（标量）。通过堆叠在变量 $(x_{t+1},y_{t+1},x_{t},y_{t},z_{t+1},z_{t})$ 上评估的欧拉方程残差和资源可行性残差，定义在时间 $t$ 的均衡残差向量 $f(\\cdot)$。\n\n围绕稳态的一阶扰动要求在满足稳态条件的点附近对均衡条件进行线性化。在本练习中，您需要实现一个朴素的一阶扰动，该方法忽略常数残差，并在可能不满足稳态条件的错误“伪稳态”点周围进行线性化。目标是通过计算由此产生的脉冲响应函数（IRF）和稳定性属性，来说明当展开点不正确时可能出现的病态问题。\n\n需要实现的任务：\n1. 对于给定的展开点 $(\\bar{x},\\bar{y},\\bar{z}) = (\\bar{k},\\bar{c},0)$ 及其“下一期”对应点 $(\\bar{x}^{+},\\bar{y}^{+},\\bar{z}^{+}) = (\\bar{k},\\bar{c},0)$，使用中心有限差分法数值计算 $f$ 的雅可比矩阵块：\n   - $f_{x^{+}} = \\frac{\\partial f}{\\partial x_{t+1}}(\\bar{\\cdot})$，$f_{y^{+}} = \\frac{\\partial f}{\\partial y_{t+1}}(\\bar{\\cdot})$，$f_{x} = \\frac{\\partial f}{\\partial x_{t}}(\\bar{\\cdot})$，$f_{y} = \\frac{\\partial f}{\\partial y_{t}}(\\bar{\\cdot})$，$f_{z} = \\frac{\\partial f}{\\partial z_{t}}(\\bar{\\cdot})$，$f_{z^{+}} = \\frac{\\partial f}{\\partial z_{t+1}}(\\bar{\\cdot})$。\n   使用与被扰动变量的大小成比例的步长，以避免数值下溢，并确保 $y$ 在扰动中保持严格为正。\n2. 通过其条件期望合并 $z_{t+1}$ 项，形成（与展开点偏差的）线性化预期系统：\n   - 令 $F_{x^{+}} = f_{x^{+}}$，$F_{y^{+}} = f_{y^{+}}$，$F_{x} = f_{x}$，$F_{y} = f_{y}$，以及 $F_{z} = f_{z} + f_{z^{+}} \\rho$。\n   - 线性化均衡为 $F_{x^{+}} x_{t+1} + F_{y^{+}} y_{t+1} + F_{x} x_{t} + F_{y} y_{t} + F_{z} z_{t} = 0$，其中期望通过策略函数应用于 $y_{t+1}$。\n3. 为朴素一阶解假设线性策略函数（忽略在非解点线性化所引起的任何常数项）：\n   - $x_{t+1} = p \\, x_{t} + q \\, z_{t}$，\n   - $y_{t} = r \\, x_{t} + s \\, z_{t}$，\n   - 因此 $\\mathbb{E}_{t} y_{t+1} = r \\, x_{t+1} + s \\, \\rho \\, z_{t}$。\n   要求线性化系统中 $x_{t}$ 和 $z_{t}$ 的系数在每个方程中恒为零，以获得两个向量条件。根据 $x_{t}$ 系数条件求解 $(p,r)$，然后根据 $z_{t}$ 系数条件求解 $(q,s)$。对 $(p,r)$ 使用稳健的数值求根器，对 $(q,s)$ 使用线性求解器。如果求解器未能收敛到有限解，则将该情况视为“无有效解”。\n4. 使用获得的 $(p,q,r,s)$，计算 $(x_{t},y_{t})$ 对在 $t=0$ 时刻大小为 $\\Delta z_{0} = \\sigma$ 的一次性初始外生状态偏差的脉冲响应函数（IRF），其中 $x_{0}=0$，且对于 $t \\ge 0$， $z_{t+1} = \\rho z_{t}$，之后无进一步冲击。也就是说，设置 $z_{0} = \\sigma$，然后迭代：\n   - $y_{t} = r \\, x_{t} + s \\, z_{t}$，\n   - $x_{t+1} = p \\, x_{t} + q \\, z_{t}$，\n   - $z_{t+1} = \\rho \\, z_{t}$，\n   对于有限期界 $T$ 内的 $t = 0,1,\\dots,T-1$。\n5. 使用以下量化指标诊断“病态”：\n   - 稳定性标志：如果 $|p|  1$，则设为 $1$，否则设为 $0$。\n   - 消费冲击响应的符号一致性标志：当 $\\Delta z_{0}  0$ 时，如果 $y_{0} \\ge 0$，则设为 $1$，否则设为 $0$。\n   - 发散标志：在期界内计算欧几里得范数 $\\| (x_{t},y_{t}) \\|$；如果求解器失败，或 $|p| \\ge 1$，或比率 $\\max_{t \\in \\{T-5,\\dots,T-1\\}} \\| (x_{t},y_{t}) \\| \\big/ \\max_{t \\in \\{0,\\dots,4\\}} \\| (x_{t},y_{t}) \\|$ 超过 $100$，则设为 $1$，否则设为 $0$。\n\n参数值：\n- $\\beta = 0.96$，$\\alpha = 0.36$，$\\delta = 0.08$，$\\rho = 0.90$，$\\sigma = 0.01$，$T = 40$。\n- 正确的稳态（展开点）满足 $1 = \\beta \\left( \\alpha \\bar{k}^{\\alpha-1} + 1 - \\delta \\right)$，因此 $\\bar{k} = \\left( \\dfrac{\\alpha}{\\beta^{-1} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}$，$\\bar{y} = \\bar{k}^{\\alpha}$，$\\bar{c} = \\bar{y} - \\delta \\bar{k}$，且 $\\bar{z} = 0$。\n\n展开点测试套件（围绕每个点进行“朴素”线性化，将其视为稳态）：\n- 情况 A（正确的展开点）：根据上述公式计算的 $(\\bar{k}, \\bar{c}, 0)$。\n- 情况 B（不正确但资源一致的点）：$(\\tilde{k}, \\tilde{c}, 0)$，其中 $\\tilde{k} = 0.5 \\, \\bar{k}$ 且 $\\tilde{c} = \\tilde{k}^{\\alpha} - \\delta \\tilde{k}$。\n- 情况 C（不正确且资源不一致的点）：$(\\hat{k}, \\hat{c}, 0)$，其中 $\\hat{k} = 5.0 \\, \\bar{k}$ 且 $\\hat{c} = 0.2 \\, \\bar{c}$。\n\n您的程序必须：\n- 数值计算雅可比矩阵，使用所述方法求解 $(p,q,r,s)$，在一次性初始偏差 $\\Delta z_{0} = \\sigma$ 下为每种情况模拟 IRF，并按顺序为每种情况计算三个标志：稳定性标志、符号一致性标志、发散标志。\n- 生成一行输出，其中包含所有结果，形式为方括号内的逗号分隔列表，顺序为：情况 A 的标志，后跟情况 B 的标志，再后跟情况 C 的标志。例如，输出格式必须与 $[a_{1},a_{2},a_{3},b_{1},b_{2},b_{3},c_{1},c_{2},c_{3}]$ 完全一样，其中每个 $a_{i}$、$b_{i}$、$c_{i}$ 是整数 0 或 1。\n\n不涉及物理单位或角度单位。将所有数值输出精确表示为整数 0 或 1，而不是小数。", "solution": "该问题要求为一个标准的真实商业周期（RBC）模型实现并评估一个一阶扰动方法。该问题的独特之处在于，它要求围绕不一定是模型真实确定性稳态的点进行线性化（扰动）。这是一个教学练习，旨在展示因展开点不正确而产生的病态问题，这也是实际应用中的一个常见错误。我的回答将遵循指定的数值方法，呈现解决此问题的系统性步骤。\n\n首先，必须明确定义经济环境的结构方程。在给定的偏好、技术和约束条件下，代表性家庭的问题产生了两个基本的一阶条件，这些条件必须在所有时间 $t$ 的均衡状态下都成立：\n1.  欧拉方程，它决定了跨期消费-储蓄的权衡：\n    $$ \\dfrac{1}{c_{t}} = \\beta \\, \\mathbb{E}_{t} \\left[ \\dfrac{1}{c_{t+1}} \\left( \\alpha \\exp(z_{t+1}) k_{t+1}^{\\alpha-1} + 1 - \\delta \\right) \\right] $$\n2.  资源约束，确保市场出清：\n    $$ c_{t} + k_{t+1} = (1-\\delta) k_{t} + \\exp(z_{t}) k_{t}^{\\alpha} $$\n\n这两个方程构成了一个非线性随机差分方程组。为了使用扰动法求解该系统，我们首先将其表示为一个残差函数向量 $f$，该向量在均衡时必须等于零。令状态向量被划分为预定变量 $x_t = k_t$、非预定（跳跃）变量 $y_t = c_t$ 和外生冲击 $z_t$。该系统可以抽象地写为：\n$$ \\mathbb{E}_t [f(x_{t+1}, y_{t+1}, x_t, y_t, z_{t+1}, z_t)] = 0 $$\n具体来说，$f$ 的两个分量是：\n$$ f_1 = \\dfrac{1}{y_{t}} - \\beta \\dfrac{1}{y_{t+1}} \\left( \\alpha \\exp(z_{t+1}) x_{t+1}^{\\alpha-1} + 1 - \\delta \\right) $$\n$$ f_2 = y_{t} + x_{t+1} - (1-\\delta)x_{t} - \\exp(z_{t}) x_{t}^{\\alpha} $$\n请注意，期望算子在后续阶段处理。\n\n一阶扰动通过在指定展开点（表示为 $(\\bar{x}, \\bar{y}, \\bar{z})$）附近对该系统进行一阶泰勒级数展开来近似求解。一个关键细节是，扰动理论的正确应用要求该展开点是一个稳态，即当 $\\bar{z}=0$ 时，满足 $f(\\bar{x}, \\bar{y}, \\bar{x}, \\bar{y}, \\bar{z}, \\bar{z}) = 0$ 的点。该问题指示我们“朴素地”进行处理，即忽略当此条件不满足时产生的常数项。因此，线性化系统近似为：\n$$ F_{x^{+}} \\hat{x}_{t+1} + F_{y^{+}} \\mathbb{E}_{t} \\hat{y}_{t+1} + F_{x} \\hat{x}_{t} + F_{y} \\hat{y}_{t} + F_{z^{+}} \\mathbb{E}_{t} \\hat{z}_{t+1} + F_{z} \\hat{z}_{t} = 0 $$\n其中 $\\hat{v} = v - \\bar{v}$ 表示与展开点的偏差，而矩阵 $F_{v}$ 是 $f$ 关于变量 $v$ 在展开点处求值的雅可比矩阵。根据问题要求，这些雅可比矩阵使用中心有限差分格式进行数值计算。\n\n冲击过程的自回归性质 $z_{t+1} = \\rho z_t + \\sigma \\varepsilon_{t+1}$ 意味着 $\\mathbb{E}_t[\\hat{z}_{t+1}] = \\rho \\hat{z}_t$。代入此式可将冲击项合并为一个：\n$$ F_{x^{+}} \\hat{x}_{t+1} + F_{y^{+}} \\mathbb{E}_{t} \\hat{y}_{t+1} + F_{x} \\hat{x}_{t} + F_{y} \\hat{y}_{t} + (F_{z} + F_{z^{+}}\\rho) \\hat{z}_{t} = 0 $$\n\n$\\mathbb{E}_{t} \\hat{y}_{t+1}$ 项是内生的且未知。为了求解该系统，我们为偏差假设一个线性策略函数：\n$$ \\hat{x}_{t+1} = p \\hat{x}_{t} + q \\hat{z}_{t} $$\n$$ \\hat{y}_{t} = r \\hat{x}_{t} + s \\hat{z}_{t} $$\n这意味着未来跳跃变量的期望遵循一个规则：\n$$ \\mathbb{E}_{t} \\hat{y}_{t+1} = \\mathbb{E}_{t} [r \\hat{x}_{t+1} + s \\hat{z}_{t+1}] = r \\hat{x}_{t+1} + s (\\rho \\hat{z}_t) = r(p \\hat{x}_{t} + q \\hat{z}_{t}) + s \\rho \\hat{z}_t $$\n\n将这些策略规则代入线性化系统，并按独立状态变量 $\\hat{x}_t$ 和 $\\hat{z}_t$ 对各项进行分组，得到两个条件，因为该方程必须对任何状态实现都成立：\n1.  $\\hat{x}_t$ 上的系数：$F_{x^{+}}p + F_{y^{+}}rp + F_x + F_y r = 0$\n2.  $\\hat{z}_t$ 上的系数：$F_{x^{+}}q + F_{y^{+}}(rq + s\\rho) + F_y s + (F_z + F_{z^{+}}\\rho) = 0$\n\n第一个是关于两个未知数 $(p,r)$ 的方程组，由于乘积 $rp$ 的存在，它是非线性的。它必须通过数值方法求解，例如，使用稳健的求根算法。第二个是关于 $(q,s)$ 的线性系统，一旦 $(p,r)$ 已知，就可以直接求解。\n\n一旦策略函数系数 $(p,q,r,s)$ 被确定，我们就可以评估所得“解”的性质。数值求解器未能找到有限实数解是病态的第一个指标。如果找到了解，我们根据三个标准对其进行评估：\n1.  **稳定性**：一个稳定的动态系统要求内生状态变量不会因暂时性冲击而爆炸。对于此模型，这对应于条件 $|p|  1$。\n2.  **符号一致性**：标准经济学理论规定，正的生产率冲击（$\\Delta z_0  0$）应导致消费增加，即 $y_0 \\ge 0$。初始响应为 $\\hat{y}_0 = r \\hat{x}_0 + s \\hat{z}_0 = s \\sigma$。鉴于 $\\sigma0$，这简化为检查是否 $s \\ge 0$。\n3.  **发散**：这是一个复合标志。如果求解器失败、满足稳定性条件 $|\\,p\\,| \\ge 1$，或者模拟的脉冲响应函数（IRF）表现出爆炸性行为，则会触发此标志。爆炸性行为通过比较模拟期末状态向量的范数与期初范数来量化衡量。\n\n该实现将把这整个过程应用于三个不同的展开点：正确的稳态（情况 A）、一个不正确但资源一致的点（情况 B）以及一个违反所有稳态条件的不正确的点（情况 C）。这将定量地证明，只有围绕真实稳态的线性化才能产生一个一致的动态系统。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import root\n\ndef process_case(expansion_point, params):\n    \"\"\"\n    Computes Jacobians, solves for policy functions, and evaluates pathologies for a given expansion point.\n    \"\"\"\n    # Unpack parameters\n    beta, alpha, delta, rho, sigma, T = params\n    k_bar, c_bar, z_bar = expansion_point\n\n    # Ensure expansion point itself is valid for calculation (c>0)\n    if c_bar = 0:\n        # Cannot proceed, mark as total failure\n        return 0, 0, 1\n\n    # 1. Define the residual functions for the two equilibrium conditions\n    def f_residuals(xp, yp, x, y, zp, z):\n        # xp=k_{t+1}, yp=c_{t+1}, x=k_t, y=c_t, zp=z_{t+1}, z=z_t\n        if yp = 0:\n            return np.array([1e12, 1e12]) # Return large penalty if consumption is non-positive\n        \n        # Euler equation residual\n        f1 = 1.0 / y - beta / yp * (alpha * np.exp(zp) * xp**(alpha - 1) + 1.0 - delta)\n        # Resource constraint residual\n        f2 = y + xp - (1.0 - delta) * x - np.exp(z) * x**alpha\n        return np.array([f1, f2])\n\n    # 2. Compute Jacobians numerically via central finite differences\n    def compute_jacobians(eval_point):\n        k_eval, c_eval, z_eval = eval_point\n        vars_base = [k_eval, c_eval, k_eval, c_eval, z_eval, z_eval]\n        jacobians = {}\n        var_names = ['xp', 'yp', 'x', 'y', 'zp', 'z']\n        \n        for i, name in enumerate(var_names):\n            # Scaled step size to handle variables of different magnitudes\n            h = 1e-6 * np.abs(vars_base[i]) + 1e-8\n            \n            vars_plus = list(vars_base)\n            vars_plus[i] += h\n            f_plus = f_residuals(*vars_plus)\n\n            vars_minus = list(vars_base)\n            vars_minus[i] -= h\n            f_minus = f_residuals(*vars_minus)\n            \n            jacobians[name] = (f_plus - f_minus) / (2.0 * h)\n            \n        return (jacobians['xp'], jacobians['yp'], jacobians['x'],\n                jacobians['y'], jacobians['zp'], jacobians['z'])\n\n    f_xp, f_yp, f_x, f_y, f_zp, f_z = compute_jacobians(expansion_point)\n\n    # 3. Solve for policy function coefficients (p, r, q, s)\n    p, q, r, s = None, None, None, None\n    solver_success = False\n    \n    # Define the nonlinear system for (p, r)\n    def pol_sys_pr(pr_vec):\n        p_val, r_val = pr_vec\n        # Eq1: Coefficient on x_t from Euler residual must be zero\n        eq1 = f_xp[0] * p_val + f_yp[0] * r_val * p_val + f_x[0] + f_y[0] * r_val\n        # Eq2: Coefficient on x_t from Resource residual must be zero\n        eq2 = f_xp[1] * p_val + f_yp[1] * r_val * p_val + f_x[1] + f_y[1] * r_val\n        return [eq1, eq2]\n    \n    # Solve for (p,r) using a numerical root finder\n    initial_guess_pr = [0.95, 0.5]\n    sol_pr = root(pol_sys_pr, initial_guess_pr, method='hybr', options={'xtol': 1e-9})\n    \n    if sol_pr.success and np.all(np.isfinite(sol_pr.x)):\n        p, r = sol_pr.x\n        \n        # Once (p,r) are found, solve the linear system for (q,s)\n        Fz_eff = f_z + f_zp * rho\n        \n        A = np.zeros((2, 2))\n        A[:, 0] = f_xp + f_yp * r      # Coefficient on q\n        A[:, 1] = f_y + f_yp * rho    # Coefficient on s\n        \n        b = -Fz_eff\n        \n        try:\n            # Check if matrix A is singular\n            if np.linalg.det(A) == 0:\n                solver_success = False\n            else:\n                q, s = np.linalg.solve(A, b)\n                if np.all(np.isfinite([q, s])):\n                    solver_success = True\n        except np.linalg.LinAlgError:\n            solver_success = False\n\n    # 4. Diagnose pathologies and compute flags\n    divergence_flag = 0\n    if not solver_success:\n        divergence_flag = 1\n        stability_flag = 0\n        sign_consistency_flag = 0\n        return stability_flag, sign_consistency_flag, divergence_flag\n\n    stability_flag = 1 if np.abs(p)  1.0 else 0\n    sign_consistency_flag = 1 if s >= 0.0 else 0\n    \n    if np.abs(p) >= 1.0:\n        divergence_flag = 1\n\n    # Simulate IRF to check for long-term divergence only if not already flagged\n    if divergence_flag == 0:\n        x_irf = np.zeros(T)\n        y_irf = np.zeros(T)\n        z_irf = np.zeros(T)\n        \n        z_irf[0] = sigma\n        # x_irf[0] is 0 by problem specification\n\n        for t in range(T - 1):\n            y_irf[t] = r * x_irf[t] + s * z_irf[t]\n            x_irf[t+1] = p * x_irf[t] + q * z_irf[t]\n            z_irf[t+1] = rho * z_irf[t]\n        y_irf[T-1] = r * x_irf[T-1] + s * z_irf[T-1]\n\n        norms = np.sqrt(x_irf**2 + y_irf**2)\n        \n        max_early = np.max(norms[0:5])\n        max_late = np.max(norms[T-5:T])\n        \n        # If initial impact is virtually zero, system is stable, so avoid division by zero\n        if max_early > 1e-12:\n            if max_late / max_early > 100.0:\n                divergence_flag = 1\n    \n    return stability_flag, sign_consistency_flag, divergence_flag\n\n\ndef solve():\n    # Structural parameters of the RBC model\n    beta = 0.96\n    alpha = 0.36\n    delta = 0.08\n    rho = 0.90\n    sigma = 0.01\n    T = 40\n    params = (beta, alpha, delta, rho, sigma, T)\n\n    # Calculate the correct steady state (for Case A and as a reference)\n    k_bar = (alpha / (1.0/beta - 1.0 + delta))**(1.0 / (1.0 - alpha))\n    c_bar = k_bar**alpha - delta * k_bar\n    z_bar = 0.0\n    \n    # Define the three test cases as expansion points (k, c, z)\n    test_cases = [\n        # Case A: Correct expansion point\n        (k_bar, c_bar, z_bar),\n        # Case B: Incorrect but resource-consistent point\n        (0.5 * k_bar, (0.5 * k_bar)**alpha - delta * (0.5 * k_bar), z_bar),\n        # Case C: Incorrect and resource-inconsistent point\n        (5.0 * k_bar, 0.2 * c_bar, z_bar)\n    ]\n\n    all_results = []\n    for expansion_point in test_cases:\n        flags = process_case(expansion_point, params)\n        all_results.extend(flags)\n        \n    # Format and print the final output as a single-line list\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2418938"}, {"introduction": "一阶解是线性的，而二阶近似通过引入二次项提供了更高的精度。然而，模拟这些非线性模型需要特别小心，以避免引入虚假的、可能导致发散的动态。本练习对比了一种“朴素”的直接模拟方法和一种理论上更稳健的“剪枝”（或称阶数一致性）方法。[@problem_id:2418999] 你将亲眼看到朴素方法如何导致数值不稳定，而剪枝方法如何正确地保持近似的完整性，从而确保模拟的稳定性。对于任何希望正确实施高阶扰动解的人来说，这个实践都是必不可少的。", "problem": "考虑一个关于资本偏离其非随机稳态（用 $k_t$ 表示）的单变量二阶扰动策略函数。围绕稳态的二阶近似形式如下：\n$$\nk_{t+1} \\;=\\; h\\,k_t \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1} \\;+\\; \\tfrac{1}{2}H\\,k_t^2 \\;+\\; \\tfrac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; N\\,k_t\\,(\\sigma\\,\\varepsilon_{t+1}),\n$$\n其中 $h$、$r$、$H$、$M$ 和 $N$ 是实值系数，$\\sigma \\ge 0$ 是冲击规模，$\\varepsilon_{t}$ 是独立同分布的标准正态冲击，满足 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n\n需要在长度为 $T$ 的有限期界内，以初始条件 $k_0 = 0$ 实现两种模拟约定：\n\n1. 近似式的直接迭代：\n$$\n\\text{对于 } t = 0,1,\\dots,T-1:\\quad k_{t+1}^{\\text{dir}} \\;=\\; h\\,k_t^{\\text{dir}} \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1} \\;+\\; \\tfrac{1}{2}H\\,(k_t^{\\text{dir}})^2 \\;+\\; \\tfrac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; N\\,k_t^{\\text{dir}}\\,(\\sigma\\,\\varepsilon_{t+1})。\n$$\n\n2. 阶数一致性模拟，通过分离一阶和二阶分量来强制截断至二阶：\n$$\nz_{t+1} \\;=\\; h\\,z_t \\;+\\; r\\,\\sigma\\,\\varepsilon_{t+1},\n$$\n$$\nw_{t+1} \\;=\\; H\\,z_t^2 \\;+\\; M\\,(\\sigma\\,\\varepsilon_{t+1})^2 \\;+\\; 2\\,N\\,z_t\\,(\\sigma\\,\\varepsilon_{t+1}),\n$$\n$$\nk_{t+1}^{\\text{oc}} \\;=\\; z_{t+1} \\;+\\; \\tfrac{1}{2}w_{t+1},\n$$\n其中 $z_0 = 0$ 且 $w_0 = 0$。\n\n为了数值可复现性，使用固定的随机种子 $s = 2025$ 来生成序列 $\\{\\varepsilon_t\\}_{t=1}^T$，并将 $\\varepsilon_t$ 视为标准正态分布的独立同分布抽样。定义一个数值界限 $B = 10^6$。如果一个模拟路径 $\\{k_t\\}_{t=0}^T$ 在任何时候达到非有限值（非数字或无穷大）或者 $\\max_{0 \\le t \\le T} |k_t|  B$，则称其为“发散的”；否则称为“有界的”。\n\n你的任务是编写一个程序，对于下面测试套件中的每一组参数，为两种模拟生成相同的冲击序列，并判断直接迭代是否产生发散路径，而阶数一致性模拟是否保持有界。对于每组参数 $i$，当且仅当直接迭代发散且阶数一致性模拟保持有界时，输出整数 $1$；否则输出整数 $0$。\n\n测试套件（每行列出 $(h,r,H,M,N,\\sigma,T)$）：\n- 情况 A（旨在揭示直接迭代下发散的一般情况）：$(0.95,\\,0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.6,\\,20000)$\n- 情况 B（无随机性的边界情况）：$(0.95,\\,0.8,\\,1.2,\\,0.8,\\,0.6,\\,0.0,\\,1000)$\n- 情况 C（具有弱非线性的近线性情况）：$(0.90,\\,0.3,\\,0.05,\\,0.02,\\,0.01,\\,0.2,\\,5000)$\n\n你的程序应产生单行输出，其中包含一个由方括号括起来的、逗号分隔的整数列表形式的结果。例如，一个包含三个情况的输出必须看起来像“[x1,x2,x3]”，其中 $x_i \\in \\{0,1\\}$。", "solution": "该问题陈述已经过验证，并被认定为有效。它在计算经济学领域内具有科学依据，特别是关于动态随机模型扰动方法的数值实现。该问题定义明确，提供了所有必要的方程、参数、初始条件和清晰、客观的评估标准。它没有歧义、矛盾和事实错误。因此，我们可以着手解决。\n\n这个问题的核心在于区分两种用于模拟从二阶泰勒近似推导出的动态系统的方​​法。这些方法之间的差异并非无足轻重；它关系到模拟的数值稳定性和理论一致性。严谨的分析揭示了为什么一种方法可能失败而另一种方法能够成功。\n\n状态变量 $k_t$（表示资本与其稳态的偏离）的模型由以下二阶近似给出：\n$$\nk_{t+1} = h\\,k_t + r\\,\\sigma\\,\\varepsilon_{t+1} + \\frac{1}{2}H\\,k_t^2 + \\frac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + N\\,k_t\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n其中 $k_0 = 0$ 且 $\\varepsilon_t \\sim \\mathcal{N}(0,1)$。\n\n第一种模拟方法，称为“直接迭代”，递归地实现这个方程：\n$$\nk_{t+1}^{\\text{dir}} = h\\,k_t^{\\text{dir}} + r\\,\\sigma\\,\\varepsilon_{t+1} + \\frac{1}{2}H\\,(k_t^{\\text{dir}})^2 + \\frac{1}{2}M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + N\\,k_t^{\\text{dir}}\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n这种方法看似直接，但包含一个根本性缺陷。原始近似是在二阶截断的泰勒级数。这意味着任何三阶或更高阶的项都已被舍弃。在直接迭代中，状态变量 $k_t^{\\text{dir}}$ 本身包含从前期累积的一阶和二阶项。当这个变量在 $\\frac{1}{2}H\\,(k_t^{\\text{dir}})^2$ 项中被平方时，会产生虚假的三阶和四阶项并反馈回系统中。例如，如果概念上将 $k_t^{\\text{dir}}$ 分为其一阶分量 $k_t^{(1)}$ 和二阶分量 $k_t^{(2)}$，那么 $(k_t^{\\text{dir}})^2 = (k_t^{(1)} + k_t^{(2)})^2 = (k_t^{(1)})^2 + 2k_t^{(1)}k_t^{(2)} + (k_t^{(2)})^2$。项 $2k_t^{(1)}k_t^{(2)}$ 是三阶的，而 $(k_t^{(2)})^2$ 是四阶的。这些项与原始近似不一致，并且会累积，导致爆发性的非平稳行为，这是模拟方法的产物，而非模型的属性。当持续性参数 $h$ 接近 $1$ 且二次反馈系数 $H$ 较大时，这种不稳定性最为显著。\n\n第二种方法，“阶数一致性模拟”或“剪枝模拟”，被明确设计用以防止这种高阶项的污染。它在每一步都保持了二阶近似的完整性。这是通过分离解的一阶和二阶分量的演化来实现的。\n一阶分量 $z_t$ 遵循模型的线性部分：\n$$\nz_{t+1} = h\\,z_t + r\\,\\sigma\\,\\varepsilon_{t+1}\n$$\n二阶校正项 $w_{t+1}$ 仅使用一阶状态 $z_t$ 来计算非线性项：\n$$\nw_{t+1} = H\\,z_t^2 + M\\,(\\sigma\\,\\varepsilon_{t+1})^2 + 2\\,N\\,z_t\\,(\\sigma\\,\\varepsilon_{t+1})\n$$\n然后组装成完整的二阶状态：\n$$\nk_{t+1}^{\\text{oc}} = z_{t+1} + \\frac{1}{2}w_{t+1}\n$$\n通过构造，此过程确保了高于二阶的项永远不会被引入 $k_t^{\\text{oc}}$ 的动态中。只要原始动态系统是局部稳定的，模拟路径就与底层的泰勒近似保持一致，从而提供一条稳定且理论上正确的轨迹。\n\n任务是为给定的一组参数 $(h, r, H, M, N, \\sigma, T)$ 实现这两种模拟方案，使用固定的随机种子 $s = 2025$ 为两种模拟生成相同的冲击序列 $\\{\\varepsilon_t\\}_{t=1}^T$。如果一个路径变为非有限值或其绝对值超过界限 $B = 10^6$，则该路径是“发散的”。我们必须识别出直接迭代发散而阶数一致性模拟保持有界的情况。\n\n算法流程如下：\n1.  使用指定的种子 $s = 2025$ 初始化随机数生成器。\n2.  对于测试套件中提供的每组参数：\n    a. 提取参数 $h, r, H, M, N, \\sigma,$ 和期界 $T$。\n    b. 生成一个长度为 $T$ 的标准正态随机冲击序列。该序列将用于两种模拟，以确保公平比较。\n    c. 执行直接迭代模拟。初始化 $k_0^{\\text{dir}} = 0.0$。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，计算 $k_{t+1}^{\\text{dir}}$。每次计算后，检查 `not isfinite`$(k_{t+1}^{\\text{dir}})$ 或 $|k_{t+1}^{\\text{dir}}|  B$ 是否成立。如果条件满足，将此路径标记为发散，并终止此方法的模拟。\n    d. 执行阶数一致性模拟。初始化 $z_0 = 0.0$。对于从 $0$ 到 $T-1$ 的每个时间步 $t$，计算 $z_{t+1}$、$w_{t+1}$，然后计算 $k_{t+1}^{\\text{oc}}$。使用与上述相同的标准检查发散。如果发生发散，将此路径标记为发散并终止。\n    e. 两种模拟都完成后，评估条件：直接迭代路径是否被标记为发散，并且阶数一致性路径未被标记为发散？如果为真，则此测试用例的结果为 $1$。否则，为 $0$。\n3.  收集所有测试用例的结果，并将其格式化为指定的输出字符串。\n这个过程将正确诊断出朴素直接迭代方法中固有的数值不稳定性，以及阶数一致性方法的稳健性。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by simulating two different perturbation methods and comparing their stability.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (h, r, H, M, N, sigma, T)\n    test_cases = [\n        (0.95, 0.8, 1.2, 0.8, 0.6, 0.6, 20000),  # Case A\n        (0.95, 0.8, 1.2, 0.8, 0.6, 0.0, 1000),   # Case B\n        (0.90, 0.3, 0.05, 0.02, 0.01, 0.2, 5000),  # Case C\n    ]\n\n    # Parameters for simulation.\n    seed = 2025\n    bound = 1e6\n\n    # Initialize the random number generator for reproducibility.\n    rng = np.random.default_rng(seed)\n\n    results = []\n\n    for h, r, H, M, N, sigma, T in test_cases:\n        # Generate the same shock sequence for both simulations for a fair comparison.\n        shocks = rng.standard_normal(T)\n        \n        # --- Simulation 1: Direct Iteration ---\n        direct_diverged = False\n        k_dir = 0.0\n        for t in range(T):\n            eps = shocks[t]\n            sigma_eps = sigma * eps\n            \n            # Direct iteration formula\n            k_dir_next = (h * k_dir + r * sigma_eps +\n                          0.5 * H * k_dir**2 +\n                          0.5 * M * sigma_eps**2 +\n                          N * k_dir * sigma_eps)\n\n            # Check for divergence\n            if not np.isfinite(k_dir_next) or abs(k_dir_next) > bound:\n                direct_diverged = True\n                break\n            \n            k_dir = k_dir_next\n\n        # --- Simulation 2: Order-Consistent Iteration ---\n        oc_diverged = False\n        z = 0.0\n        for t in range(T):\n            eps = shocks[t]\n            sigma_eps = sigma * eps\n            \n            # First-order component\n            z_next = h * z + r * sigma_eps\n            \n            # Second-order correction\n            w_next = H * z**2 + M * sigma_eps**2 + 2 * N * z * sigma_eps\n            \n            # Assembled state\n            k_oc_next = z_next + 0.5 * w_next\n            \n            # Check for divergence\n            if not np.isfinite(k_oc_next) or abs(k_oc_next) > bound:\n                oc_diverged = True\n                break\n            \n            z = z_next\n            \n        # --- Evaluate the condition ---\n        # Output 1 if direct diverges and order-consistent remains bounded; otherwise 0.\n        if direct_diverged and not oc_diverged:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == '__main__':\n    solve()\n```", "id": "2418999"}]}