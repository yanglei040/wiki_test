{"hands_on_practices": [{"introduction": "本次练习将通过一个具体应用——情感分析，引导你初步接触贝叶斯工作流程。我们将使用基础的贝塔-二项共轭模型来为中央银行通讯中的“鸽派”术语比例进行建模 [@problem_id:2375504]。通过完成这个练习，你将获得计算关键后验量（如后验均值和可信区间）的实践经验，这些是解读任何贝叶斯分析结果的核心。", "problem": "给定一个简化的、基于模型的设定，用于通过被归类为“鸽派”和“鹰派”的术语的相对频率来量化中央银行沟通的情绪。对于单个文档，让 $D$ 表示通过预先指定的词典提取的“鸽派”术语的数量，让 $H$ 表示“鹰派”术语的数量。让 $N$ 表示被分类术语的总数，因此 $N = D + H$。假设每个被分类的术语都是独立生成的，并且一个被分类术语是“鸽派”的未知概率为 $p \\in (0,1)$。在给定 $N$ 的条件下，将计数 $D$ 建模为参数为 $p$ 的二项随机变量。为 $p$ 设置一个贝塔先验，即 $p \\sim \\text{Beta}(a,b)$，其形状参数为 $a > 0$ 和 $b > 0$。\n\n将文档的“鸽派指数”定义为上述模型下 $p$ 的后验均值。将水平为 $c \\in (0,1)$ 的 $p$ 的等尾可信区间 (Credible Interval, CI) 定义为一个区间，其下端点和上端点分别是 $p$ 的 $\\alpha/2$ 和 $1-\\alpha/2$ 后验分位数，其中 $\\alpha = 1-c$。为支持分类，将文档在阈值 $\\tau \\in (0,1)$ 下“鸽派倾向大于鹰派倾向”的后验概率定义为 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。所有概率值必须表示为 $[0,1]$ 范围内的小数。\n\n对于下方的每个测试用例，计算并返回指定参数 $(D,H,a,b,c,\\tau)$ 的以下四个量：\n- $p$ 的后验均值，\n- 水平为 $c$ 的等尾 CI 的下端点，\n- 水平为 $c$ 的等尾 CI 的上端点，\n- 后验概率 $\\mathbb{P}(p > \\tau \\mid D,H,a,b)$。\n\n测试套件（每行为一个测试用例 $(D,H,a,b,c,\\tau)$）：\n- $(D,H,a,b,c,\\tau) = (\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n- $(D,H,a,b,c,\\tau) = (\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n你的程序应生成单行输出，包含一个无空格的、逗号分隔的列表的列表形式的结果，其中每个内部列表对应一个测试用例，并按 $[\\,\\text{posterior\\_mean},\\,\\text{CI\\_lower},\\,\\text{CI\\_upper},\\,\\mathbb{P}(p>\\tau)\\,]$ 的顺序排列。每个小数必须四舍五入到小数点后 $6$ 位。例如，最终输出格式必须类似于 $[[m_1,l_1,u_1,q_1],[m_2,l_2,u_2,q_2],\\dots]$，且不含任何空格。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取给定条件\n\n- 文档术语计数：$D$（鸽派），$H$（鹰派）。\n- 被分类术语总数：$N = D + H$。\n- 未知参数：$p \\in (0,1)$，一个术语是“鸽派”的概率。\n- 似然模型：计数 $D$ 被建模为二项随机变量，$D \\mid p, N \\sim \\text{Binomial}(N, p)$。\n- 先验模型：为参数 $p$ 指定一个贝塔先验，$p \\sim \\text{Beta}(a,b)$，其超参数为 $a > 0$ 和 $b > 0$。\n- “鸽派指数”：定义为 $p$ 的后验均值，$E[p \\mid D, H, a, b]$。\n- 可信区间 (CI)：一个水平为 $c \\in (0,1)$ 的 $p$ 的等尾区间。其下端点和上端点分别是后验分布的 $\\alpha/2$ 和 $1-\\alpha/2$ 分位数，其中 $\\alpha = 1-c$。\n- 后验概率：$\\mathbb{P}(p > \\tau \\mid D,H,a,b)$，用于分类阈值 $\\tau \\in (0,1)$。\n- 为每个测试用例 $(D,H,a,b,c,\\tau)$ 计算的量：\n    1.  $p$ 的后验均值。\n    2.  CI 的下端点。\n    3.  CI 的上端点。\n    4.  后验概率 $\\mathbb{P}(p > \\tau)$。\n- 参数 $(D,H,a,b,c,\\tau)$ 的测试套件：\n    - $(\\,30,\\,20,\\,2,\\,2,\\,0.95,\\,0.5\\,)$\n    - $(\\,0,\\,0,\\,1,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,50,\\,10,\\,0.5,\\,0.5,\\,0.95,\\,0.5\\,)$\n    - $(\\,1,\\,9,\\,5,\\,1,\\,0.9,\\,0.5\\,)$\n    - $(\\,100,\\,100,\\,10,\\,10,\\,0.99,\\,0.5\\,)$\n\n### 步骤 2：使用提取的给定条件进行验证\n\n- **科学依据**：该问题基于贝塔-二项模型，这是贝叶斯统计中一个标准的、基本的共轭先验构造。该框架在科学上是合理的，并广泛应用于文本分析和计量经济学等领域。该问题牢固地植根于已建立的概率论。\n- **适定性**：该问题是适定的。贝塔先验和二项似然的组合产生的后验分布也是一个贝塔分布。对于贝塔分布，其均值、分位数和尾部概率都是定义明确且唯一的。给定指定的输入，所有必需的计算都存在唯一解。\n- **客观性**：该问题使用精确、客观的数学语言表述。所有术语都有明确定义（例如，“鸽派指数”定义为后验均值）。问题不含主观或模棱两可的陈述。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它在科学上是合理的、适定的和客观的。它包含了唯一解所需的所有必要信息。将提供一个完整的、有理有据的解决方案。\n\n### 解决方案\n\n该问题要求将贝叶斯推断应用于一个标准共轭模型。其核心原理是，贝塔分布是二项似然参数的共轭先验。此属性使得后验分布有一个闭式解析表达式，从而极大地简化了计算。\n\n设概率 $p$ 的先验分布是形状参数为 $a$ 和 $b$ 的贝塔分布：\n$$ p \\sim \\text{Beta}(a,b) $$\n其概率密度函数 (PDF) 由下式给出：\n$$ f(p; a, b) = \\frac{p^{a-1}(1-p)^{b-1}}{B(a,b)} $$\n其中 $B(a,b)$ 是贝塔函数。\n\n观测数据包括 $D$ 个“鸽派”术语和 $H$ 个“鹰派”术语，总共 $N = D+H$ 个术语。在给定概率 $p$ 的情况下，从大小为 $N$ 的样本中观测到 $D$ 个鸽派术语的似然由二项分布描述：\n$$ D \\mid p, N \\sim \\text{Binomial}(N, p) $$\n似然函数为：\n$$ L(p \\mid D, N) = \\binom{N}{D} p^D (1-p)^{N-D} $$\n\n根据贝叶斯定理，$p$ 的后验分布与似然和先验的乘积成正比：\n$$ f(p \\mid D, N, a, b) \\propto L(p \\mid D, N) \\times f(p; a, b) $$\n$$ f(p \\mid D, N, a, b) \\propto \\left( p^D (1-p)^{N-D} \\right) \\times \\left( p^{a-1} (1-p)^{b-1} \\right) $$\n合并含有 $p$ 和 $(1-p)$ 的项：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{N-D+b-1} $$\n代入 $N = D+H$：\n$$ f(p \\mid D, N, a, b) \\propto p^{D+a-1} (1-p)^{H+b-1} $$\n此表达式是具有更新后参数 $a' = a+D$ 和 $b' = b+H$ 的贝塔分布的核。因此，后验分布为：\n$$ p \\mid D, H, a, b \\sim \\text{Beta}(a', b') = \\text{Beta}(a+D, b+H) $$\n\n在确定后验分布后，我们可以计算所需的四个量。\n\n1.  **后验均值（鸽派指数）**：$\\text{Beta}(a', b')$ 分布的均值由下式给出：\n    $$ E[p \\mid D, H, a, b] = \\frac{a'}{a'+b'} = \\frac{a+D}{a+D+b+H} $$\n\n2.  **等尾可信区间 (CI)**：对于一个可信水平 $c$，我们设定 $\\alpha = 1-c$。等尾 CI 由后验分布的 $\\frac{\\alpha}{2}$ 和 $1-\\frac{\\alpha}{2}$ 分位数定义。设 $F_{a',b'}^{-1}(q)$ 为 $\\text{Beta}(a', b')$ 分布对应于概率 $q$ 的分位数函数（逆累积分布函数）。\n    - 下端点：$CI_{\\text{lower}} = F_{a',b'}^{-1}\\left(\\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(\\frac{1-c}{2}\\right)$\n    - 上端点：$CI_{\\text{upper}} = F_{a',b'}^{-1}\\left(1 - \\frac{\\alpha}{2}\\right) = F_{a+D, b+H}^{-1}\\left(1 - \\frac{1-c}{2}\\right)$\n\n3.  **后验概率 $\\mathbb{P}(p > \\tau)$**：这是根据后验分布计算出的 $p$ 超过某个阈值 $\\tau$ 的概率。这等价于在 $\\tau$ 处求值的生存函数 (SF)，即 $S(x) = 1 - F(x)$。\n    $$ \\mathbb{P}(p > \\tau \\mid D,H,a,b) = \\int_{\\tau}^{1} f(p \\mid D,H,a,b) \\,dp = 1 - F_{a',b'}(\\tau) = S_{a+D, b+H}(\\tau) $$\n    其中 $F_{a',b'}$ 和 $S_{a',b'}$ 分别是 $\\text{Beta}(a', b')$ 分布的累积分布函数 (CDF) 和生存函数 (SF)。当 $\\tau$ 接近 1 时，出于数值稳定性的考虑，使用生存函数在计算上更可取。\n\n这些公式将使用提供的参数应用于每个测试用例。分位数和生存函数的计算将使用标准数值库执行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import beta\n\ndef solve():\n    \"\"\"\n    Computes Bayesian sentiment metrics for a series of test cases.\n\n    For each case, it calculates the posterior mean, credible interval,\n    and a posterior probability based on a Beta-Binomial model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is in the format (D, H, a, b, c, tau)\n    test_cases = [\n        (30, 20, 2, 2, 0.95, 0.5),\n        (0, 0, 1, 1, 0.9, 0.5),\n        (50, 10, 0.5, 0.5, 0.95, 0.5),\n        (1, 9, 5, 1, 0.9, 0.5),\n        (100, 100, 10, 10, 0.99, 0.5),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        D, H, a, b, c, tau = case\n\n        # Calculate posterior parameters for the Beta distribution\n        # a_prime = a + D and b_prime = b + H\n        a_prime = a + D\n        b_prime = b + H\n\n        # 1. Calculate the posterior mean\n        posterior_mean = a_prime / (a_prime + b_prime)\n\n        # 2. Calculate the equal-tailed credible interval\n        alpha = 1.0 - c\n        ci_lower = beta.ppf(alpha / 2.0, a_prime, b_prime)\n        ci_upper = beta.ppf(1.0 - alpha / 2.0, a_prime, b_prime)\n\n        # 3. Calculate the posterior probability P(p  tau)\n        # This is the survival function (1 - CDF) of the posterior Beta distribution\n        prob_p_gt_tau = beta.sf(tau, a_prime, b_prime)\n        \n        case_results = [\n            posterior_mean,\n            ci_lower,\n            ci_upper,\n            prob_p_gt_tau\n        ]\n        all_results.append(case_results)\n\n    # Format the final output string according to the specification:\n    # A comma-separated list of lists with no spaces, with values rounded to 6 decimal places.\n    # Example: [[m1,l1,u1,q1],[m2,l2,u2,q2],...]\n    inner_parts = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places\n        formatted_vals = [f\"{val:.6f}\" for val in res_list]\n        # Join numbers with a comma and enclose in brackets\n        inner_parts.append(f\"[{','.join(formatted_vals)}]\")\n    \n    # Join the inner lists with a comma and enclose in brackets for the final string\n    final_output_str = f\"[{','.join(inner_parts)}]\"\n\n    print(final_output_str)\n\nsolve()\n```", "id": "2375504"}, {"introduction": "在参数估计的基础上，本练习将深入探讨贝叶斯模型比较，这是科学探究的基石。你将通过计算贝叶斯因子这一强大的证据权重工具，来比较两个简化的GDP增长经济模型 [@problem_id:2375563]。此练习不仅让你能实践应用于线性回归的正态-逆伽马模型，还将有力地展示先验分布对模型选择的关键影响，这是应用贝叶斯分析时必须掌握的重要一课。", "problem": "给定两个相互竞争的线性时间序列模型，作为对国内生产总值（GDP）增长波动的两种经济理论的程式化表述。第一个模型 $M_{K}$ 代表一个简化的凯恩斯主义机制，其截距项用于捕捉需求变化。第二个模型 $M_{R}$ 代表一个简化的真实商业周期 (RBC) 机制，其通过两个滞后项体现更深的持续性，且没有截距项。对于一个去均值的真实GDP增长率的单变量序列 $\\{y_t\\}_{t=1}^{T}$，在共同样本 $t=3,\\dots,T$ 上定义模型如下：\n- 模型 $M_{K}$ (凯恩斯主义): $$y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t, \\quad \\text{其中} \\; \\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$$\n- 模型 $M_{R}$ (真实商业周期 (RBC)): $$y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t, \\quad \\text{其中} \\; \\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$$\n\n对于每个模型，参数和先验分布为：\n- 对于 $M_{K}$，$\\theta_K = (\\alpha,\\phi,\\sigma^2)$，其先验分布为\n  $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 和 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n- 对于 $M_{R}$，$\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$，其先验分布为\n  $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 和 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n\n逆伽马先验由以下密度函数参数化\n$$\np(\\sigma^2) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp\\!\\left(-\\frac{b_0}{\\sigma^2}\\right),\n$$\n其中 $\\Gamma(\\cdot)$ 是伽马函数。\n\n您必须为每个数据集和每个指定的先验配置，计算支持 $M_{K}$ 相对于 $M_{R}$ 的贝叶斯因子的自然对数，即\n$$\n\\log \\text{BF}_{K,R} = \\log p(y \\mid M_{K}) - \\log p(y \\mid M_{R}),\n$$\n其中 $p(y \\mid M)$ 表示在共同样本 $t=3,\\dots,T$ 上评估的模型 $M$ 下的边际似然。\n\n数据集（每个序列为 $y_1,\\dots,y_T$），其中 $T$ 由序列长度隐式指定：\n- 数据集 1: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$。\n- 数据集 2: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$。\n- 数据集 3: $[0.05, 0.02, 0.03, 0.01]$。\n\n将使用两种不同的先验设定：\n\n- 先验设定 $\\mathcal{A}$ (扩散的，模型间对称)：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$。\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$。\n\n- 先验设定 $\\mathcal{B}$ (信息性的，模型特定的)：\n  - 对于 $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$。\n  - 对于 $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$。\n\n测试套件与答案规范：\n- 对于两个模型和所有数据集，用于似然评估的共同样本均为 $t=3,\\dots,T$。\n- 对于每个数据集 $i \\in \\{1,2,3\\}$ 和每个先验设定 $P \\in \\{\\mathcal{A},\\mathcal{B}\\}$，计算标量 $\\log \\text{BF}_{K,R}^{(i,P)}$。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，并严格按照以下顺序排列：\n$$\n[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]\n$$\n所有六个输出都必须是浮点数。除此单行外，不允许任何额外的文本或格式。", "solution": "问题陈述经过了严格的验证。\n\n### 步骤1：提取已知信息\n- **模型**：\n    - $M_{K}$ (凯恩斯主义): $y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t$，对于 $t=3,\\dots,T$。\n    - $M_{R}$ (真实商业周期 (RBC)): $y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t$，对于 $t=3,\\dots,T$。\n    - 对于两个模型，误差项为 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$。\n- **先验**：\n    - 对于 $M_{K}$，参数 $\\theta_K = (\\alpha,\\phi,\\sigma^2)$ 的先验为 $\\alpha,\\phi \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,K}, \\sigma^2 V_{0,K})$ 和 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,K}, b_{0,K})$。\n    - 对于 $M_{R}$，参数 $\\theta_R = (\\beta_1,\\beta_2,\\sigma^2)$ 的先验为 $\\beta_1,\\beta_2 \\mid \\sigma^2 \\sim \\mathcal{N}(m_{0,R}, \\sigma^2 V_{0,R})$ 和 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_{0,R}, b_{0,R})$。\n- **逆伽马概率密度函数(PDF)**：$p(\\sigma^2) = \\frac{b_0^{a_0}}{\\Gamma(a_0)} \\, (\\sigma^2)^{-(a_0+1)} \\exp(-\\frac{b_0}{\\sigma^2})$。\n- **目标**：计算贝叶斯因子的自然对数，$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_{K}) - \\log p(y \\mid M_{R})$。\n- **数据集**：\n    - 数据集 1: $[0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]$。\n    - 数据集 2: $[0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]$。\n    - 数据集 3: $[0.05, 0.02, 0.03, 0.01]$。\n- **先验设定**：\n    - 设定 $\\mathcal{A}$:\n        - $M_{K}$: $m_{0,K}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,K}^{\\mathcal{A}} = 0.01$, $b_{0,K}^{\\mathcal{A}} = 0.01$。\n        - $M_{R}$: $m_{0,R}^{\\mathcal{A}} = \\begin{bmatrix} 0.00 \\\\ 0.00 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{A}} = \\operatorname{diag}(10000.00, 10000.00)$, $a_{0,R}^{\\mathcal{A}} = 0.01$, $b_{0,R}^{\\mathcal{A}} = 0.01$。\n    - 设定 $\\mathcal{B}$:\n        - $M_{K}$: $m_{0,K}^{\\mathcal{B}} = \\begin{bmatrix} 0.02 \\\\ 0.80 \\end{bmatrix}$, $V_{0,K}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,K}^{\\mathcal{B}} = 2.00$, $b_{0,K}^{\\mathcal{B}} = 0.01$。\n        - $M_{R}$: $m_{0,R}^{\\mathcal{B}} = \\begin{bmatrix} 0.60 \\\\ 0.20 \\end{bmatrix}$, $V_{0,R}^{\\mathcal{B}} = \\operatorname{diag}(0.01, 0.01)$, $a_{0,R}^{\\mathcal{B}} = 2.00$, $b_{0,R}^{\\mathcal{B}} = 0.01$。\n- **评估样本**：用于似然评估的共同样本为 $t=3,\\dots,T$。\n- **输出顺序**：$[\\log \\text{BF}_{K,R}^{(1,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(1,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(2,\\mathcal{B})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{A})}, \\log \\text{BF}_{K,R}^{(3,\\mathcal{B})}]$。\n\n### 步骤2：使用提取的已知信息进行验证\n评估问题的有效性。\n- **科学依据**：该问题是贝叶斯计量经济学中的一个标准练习。它涉及使用通过边际似然计算的贝叶斯因子来比较两个线性回归模型。所选的先验结构，即正态-逆伽马分布，是方差未知的线性模型的自然共轭先验，这是贝叶斯统计学中的一个基本概念。模型本身，即带常数项的 $AR(1)$ 模型和不带常数项的 $AR(2)$ 模型，是教科书式的例子。该问题牢固地建立在公认的统计学和计量经济学原理之上。\n- **适定性**：所有必要组成部分——数据、模型设定、先验分布和超参数——均已提供。目标定义明确。对于指定的共轭先验设置，边际似然存在已知的解析解。因此，每种情况都存在唯一、稳定且有意义的解。\n- **客观性**：问题以精确的数学语言陈述。“凯恩斯主义”和“RBC”这些名称仅作为数学结构的标签，不会为所需的计算引入任何主观性。\n- **缺陷清单**：该问题不违反任何指定的缺陷条件。它在科学上是合理的、可形式化的、完整的、可行的、适定的和可验证的。\n\n### 步骤3：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 解法\n\n目标是计算对数贝叶斯因子 $\\log \\text{BF}_{K,R}$，这需要为每个模型 $M \\in \\{M_K, M_R\\}$ 计算对数边际似然 $\\log p(y \\mid M)$。\n\n两个模型都符合一般线性模型的框架：\n$$\ny = X\\beta + \\varepsilon, \\quad \\varepsilon \\sim \\mathcal{N}(0, \\sigma^2 I_N)\n$$\n其中 $y$ 是一个包含 $N$ 个观测值的向量，$X$ 是一个 $N \\times k$ 的设计矩阵，$\\beta$ 是一个 $k \\times 1$ 的回归系数向量。似然函数是 $p(y \\mid \\beta, \\sigma^2) = (2\\pi\\sigma^2)^{-N/2} \\exp(-\\frac{1}{2\\sigma^2}(y-X\\beta)^T(y-X\\beta))$。\n\n指定的先验是正态-逆伽马分布：\n$$\np(\\beta, \\sigma^2) = p(\\beta \\mid \\sigma^2) p(\\sigma^2)\n$$\n其中 $\\beta \\mid \\sigma^2 \\sim \\mathcal{N}(m_0, \\sigma^2 V_0)$ 且 $\\sigma^2 \\sim \\text{Inverse-Gamma}(a_0, b_0)$。这是正态线性模型的共轭先验。\n\n边际似然 $p(y \\mid M)$ 是通过将似然函数与先验分布的乘积对所有参数进行积分得到的：\n$$\np(y \\mid M) = \\int_0^\\infty \\int_{\\mathbb{R}^k} p(y \\mid \\beta, \\sigma^2) p(\\beta \\mid \\sigma^2) p(\\sigma^2) \\, d\\beta \\, d\\sigma^2\n$$\n对于指定的共轭设置，该积分有闭式解。参数的后验分布也是正态-逆伽马分布，$p(\\beta, \\sigma^2 \\mid y) \\propto p(\\beta, \\sigma^2)p(y \\mid \\beta, \\sigma^2)$，其更新后的参数为：\n- $\\beta$ 的后验精度矩阵： $V_n^{-1} = V_0^{-1} + X^T X$\n- $\\beta$ 的后验均值： $m_n = V_n (V_0^{-1}m_0 + X^T y)$\n- $\\sigma^2$ 的后验形状参数： $a_n = a_0 + N/2$\n- $\\sigma^2$ 的后验速率参数： $b_n = b_0 + \\frac{1}{2}(y^T y + m_0^T V_0^{-1} m_0 - m_n^T V_n^{-1} m_n)$\n\n边际似然是后验分布的归一化常数，由下式给出：\n$$\np(y \\mid M) = \\frac{\\Gamma(a_n)}{\\Gamma(a_0)} \\frac{b_0^{a_0}}{b_n^{a_n}} (2\\pi)^{-N/2} \\frac{|V_n|^{1/2}}{|V_0|^{1/2}}\n$$\n为防止数值下溢并简化计算，我们使用边际似然的自然对数：\n$$\n\\log p(y \\mid M) = \\log\\Gamma(a_n) - \\log\\Gamma(a_0) + a_0\\log(b_0) - a_n\\log(b_n) - \\frac{N}{2}\\log(2\\pi) + \\frac{1}{2}(\\log|V_n| - \\log|V_0|)\n$$\n对数伽马函数 $\\log\\Gamma(\\cdot)$ 由标准科学库提供。对数行列式 $\\log|V|$ 进行稳健计算。\n\n对于每个数据集和模型，我们首先使用共同样本 $t=3, \\dots, T$ 来构建响应向量 $y$ 和设计矩阵 $X$。观测数量为 $N = T - 2$。\n响应向量为 $y = [y_3, y_4, \\dots, y_T]^T$。\n\n对于模型 $M_K (y_t = \\alpha + \\phi y_{t-1} + \\varepsilon_t)$，参数向量为 $\\beta_K = [\\alpha, \\phi]^T$，设计矩阵为：\n$$\nX_K = \\begin{bmatrix} 1  y_2 \\\\ 1  y_3 \\\\ \\vdots  \\vdots \\\\ 1  y_{T-1} \\end{bmatrix}\n$$\n这是一个 $N \\times 2$ 的矩阵。\n\n对于模型 $M_R (y_t = \\beta_1 y_{t-1} + \\beta_2 y_{t-2} + \\varepsilon_t)$，参数向量为 $\\beta_R = [\\beta_1, \\beta_2]^T$，设计矩阵为：\n$$\nX_R = \\begin{bmatrix} y_2  y_1 \\\\ y_3  y_2 \\\\ \\vdots  \\vdots \\\\ y_{T-1}  y_{T-2} \\end{bmatrix}\n$$\n这也是一个 $N \\times 2$ 的矩阵。\n\n六个所需计算中每一个的步骤如下：\n1. 选择一个数据集和一个先验设定。\n2. 构建响应向量 $y$ 以及设计矩阵 $X_K$ 和 $X_R$。\n3. 对于模型 $M_K$，使用其对应的先验超参数（$m_{0,K}, V_{0,K}, a_{0,K}, b_{0,K}$）来计算后验参数（$V_{n,K}, m_{n,K}, a_{n,K}, b_{n,K}$），然后使用上述公式计算对数边际似然 $\\log p(y \\mid M_K)$。\n4. 对于模型 $M_R$，使用其对应的先验超参数重复步骤3，以找到 $\\log p(y \\mid M_R)$。\n5. 计算对数贝叶斯因子：$\\log \\text{BF}_{K,R} = \\log p(y \\mid M_K) - \\log p(y \\mid M_R)$。\n对问题陈述中指定的每个数据集-先验配对重复此过程。该算法将使用 Python 实现，其中 `numpy` 库用于线性代数，`scipy` 库用于对数伽马函数。", "answer": "```python\nimport numpy as np\nfrom scipy.special import gammaln\nfrom numpy.linalg import inv, slogdet\n\ndef calculate_log_marginal_likelihood(y_data, X, m0, V0, a0, b0):\n    \"\"\"\n    Calculates the log marginal likelihood for a linear model with a Normal-Inverse-Gamma prior.\n    \n    Args:\n        y_data (np.ndarray): The dependent variable vector (N,).\n        X (np.ndarray): The design matrix (N, k).\n        m0 (np.ndarray): The prior mean vector for beta (k,).\n        V0 (np.ndarray): The prior covariance matrix for beta (k, k).\n        a0 (float): The prior shape parameter for sigma^2.\n        b0 (float): The prior rate parameter for sigma^2.\n\n    Returns:\n        float: The log marginal likelihood.\n    \"\"\"\n    N, k = X.shape\n\n    # Calculation of posterior parameters for beta (Vn, mn)\n    V0_inv = inv(V0)\n    Vn_inv = V0_inv + X.T @ X\n    Vn = inv(Vn_inv)\n    mn = Vn @ (V0_inv @ m0 + X.T @ y_data)\n    \n    # Calculation of posterior parameters for sigma^2 (an, bn)\n    an = a0 + N / 2\n    \n    # Quadratic forms for bn\n    # bn = b0 + 0.5 * (y'y + m0'V0_inv*m0 - mn'Vn_inv*mn)\n    ss_data = y_data.T @ y_data\n    ss_prior = m0.T @ V0_inv @ m0\n    ss_posterior_mean = mn.T @ Vn_inv @ mn\n    bn = b0 + 0.5 * (ss_data + ss_prior - ss_posterior_mean)\n\n    # Log determinant term\n    _, logdet_Vn = slogdet(Vn)\n    _, logdet_V0 = slogdet(V0)\n    log_det_term = 0.5 * (logdet_Vn - logdet_V0)\n\n    # Assemble the log marginal likelihood\n    log_ml = (gammaln(an) - gammaln(a0) +\n              a0 * np.log(b0) - an * np.log(bn) -\n              (N / 2) * np.log(2 * np.pi) +\n              log_det_term)\n\n    return log_ml\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the log Bayes Factor for each dataset and prior specification.\n    \"\"\"\n    # Define datasets\n    datasets = {\n        1: np.array([0.00, 0.10, 0.18, 0.24, 0.29, 0.31, 0.33, 0.35]),\n        2: np.array([0.00, 0.30, 0.20, 0.27, 0.18, 0.25, 0.17, 0.24]),\n        3: np.array([0.05, 0.02, 0.03, 0.01])\n    }\n\n    # Define prior specifications\n    priors = {\n        'A': {  # Prior Specification A\n            'K': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01},\n            'R': {'m0': np.array([0.0, 0.0]), 'V0': np.diag([10000.0, 10000.0]), 'a0': 0.01, 'b0': 0.01}\n        },\n        'B': {  # Prior Specification B\n            'K': {'m0': np.array([0.02, 0.80]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01},\n            'R': {'m0': np.array([0.60, 0.20]), 'V0': np.diag([0.01, 0.01]), 'a0': 2.0, 'b0': 0.01}\n        }\n    }\n    \n    test_cases = [\n        (1, 'A'), (1, 'B'),\n        (2, 'A'), (2, 'B'),\n        (3, 'A'), (3, 'B')\n    ]\n\n    results = []\n    for d_idx, p_key in test_cases:\n        y_full = datasets[d_idx]\n        T = len(y_full)\n        N = T - 2\n\n        # Common dependent variable for the sample t=3,...,T\n        y_vec = y_full[2:]\n\n        # Construct Design Matrix for Model K (Keynesian)\n        # y_t = alpha + phi*y_{t-1}\n        X_K = np.vstack([np.ones(N), y_full[1:T-1]]).T\n        \n        # Construct Design Matrix for Model R (RBC)\n        # y_t = beta1*y_{t-1} + beta2*y_{t-2}\n        X_R = np.vstack([y_full[1:T-1], y_full[0:T-2]]).T\n        \n        # Get prior hyperparameters for the current case\n        prior_K = priors[p_key]['K']\n        prior_R = priors[p_key]['R']\n\n        # Calculate log marginal likelihood for Model K\n        log_ml_K = calculate_log_marginal_likelihood(y_vec, X_K, \n            prior_K['m0'], prior_K['V0'], prior_K['a0'], prior_K['b0'])\n        \n        # Calculate log marginal likelihood for Model R\n        log_ml_R = calculate_log_marginal_likelihood(y_vec, X_R, \n            prior_R['m0'], prior_R['V0'], prior_R['a0'], prior_R['b0'])\n\n        # Compute the log Bayes Factor in favor of K over R\n        log_bf_KR = log_ml_K - log_ml_R\n        results.append(log_bf_KR)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2375563"}, {"introduction": "这项最终练习将挑战你解决一个位于计量经济学和贝叶斯计算交叉前沿的复杂问题：估计一个协整向量自回归（CVAR）模型。你将使用高级的矩阵正态-逆威沙特共轭先验，从第一性原理出发实现对一个多变量系统的估计 [@problem_id:2375565]。这项综合性练习将数据模拟、矩阵代数和贝叶斯理论融于一体，让你通过解决一个在现代金融与经济学实证研究中具有代表性的问题，来巩固和深化你的理解。", "problem": "要求您设计并实现一个完整的、可运行的程序，该程序在共轭先验下对两个对数汇率的协整向量自回归 (CVAR) 模型进行贝叶斯估计。此任务必须从第一性原理出发解决，从多元高斯似然和共轭先验的核心定义开始，并且不使用黑盒时间序列例程。每一步都必须使用基础线性代数明确编码。\n\n考虑一个二元对数汇率向量 $y_t \\in \\mathbb{R}^2$，它遵循一个向量误差修正模型 (VECM)，其协整秩为 $1$ 且不含滞后差分项：\n$$\n\\Delta y_t = \\alpha \\, \\beta^{\\top} y_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma),\n$$\n其中 $\\alpha \\in \\mathbb{R}^{2 \\times 1}$ 是调整（也称为载荷）向量，$\\beta \\in \\mathbb{R}^{2 \\times 1}$ 是协整向量，$\\Sigma \\in \\mathbb{R}^{2 \\times 2}$ 是正定新息协方差矩阵。协整向量是固定的，已知为 $\\beta = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix}$。通过定义回归量 $x_t = \\beta^{\\top} y_{t-1} \\in \\mathbb{R}$，将 $T$ 个观测值堆叠成一个元素为 $x_t$ 的 $T \\times 1$ 矩阵 $X$，并将 $\\Delta y_t$ 堆叠成 $T \\times 2$ 的矩阵 $Y$，该模型可以被组织成一个多元线性回归。然后：\n$$\nY = X B + E,\\quad E \\sim \\mathcal{MN}_{T,2}(0, I_T, \\Sigma),\n$$\n其中 $B \\in \\mathbb{R}^{1 \\times 2}$ 是系数矩阵，$\\mathcal{MN}$ 表示矩阵正态分布。注意 $\\alpha$ 是 $B$ 的转置，即 $\\alpha = B^{\\top}$。\n\n假设一个共轭的矩阵正态逆威沙特 (MNIW) 先验：\n$$\nB \\mid \\Sigma \\sim \\mathcal{MN}_{1,2}(B_0, V_0, \\Sigma), \\quad \\Sigma \\sim \\mathcal{IW}(S_0, \\nu_0),\n$$\n其中超参数 $B_0 \\in \\mathbb{R}^{1 \\times 2}$, $V_0 \\in \\mathbb{R}^{1 \\times 1}$, $S_0 \\in \\mathbb{R}^{2 \\times 2}$, 和 $\\nu_0 \\in \\mathbb{R}$ 已知。您必须在此先验和高斯似然下推导 $(B, \\Sigma)$ 的后验分布，并计算 $\\alpha = B^{\\top}$ 的后验均值。\n\n在所有案例中，使用以下超参数：$B_0 = \\mathbf{0}_{1 \\times 2}$, $V_0 = c I_1$ 其中 $c = 10^6$, $S_0 = s_0 I_2$ 其中 $s_0 = 10^{-4}$，以及 $\\nu_0 = 4$。\n\n每个测试案例的数据生成都必须通过从 VECM 模型本身进行模拟来完成，使用精确的数据生成过程：\n$$\n\\begin{aligned}\ny_0 = \\begin{bmatrix} 0 \\\\ 0 \\end{bmatrix}, \\\\\n\\text{for } t = 1, \\ldots, T: \\\\\n\\quad x_t = \\beta^{\\top} y_{t-1}, \\\\\n\\quad \\Delta y_t = \\alpha^{\\text{true}} x_t + \\varepsilon_t,\\quad \\varepsilon_t \\overset{\\text{i.i.d.}}{\\sim} \\mathcal{N}(\\mathbf{0}, \\Sigma^{\\text{true}}), \\\\\n\\quad y_t = y_{t-1} + \\Delta y_t.\n\\end{aligned}\n$$\n\n您必须实现贝叶斯后验推导，并在 MNIW 先验下，根据模拟出的 $(X, Y)$ 计算 $\\alpha$ 的后验均值。不要依赖任何用于时间序列估计或贝叶斯回归的内置例程。所有量都必须以一致的数学术语和维度来表示和计算。不涉及任何物理单位。\n\n测试套件：\n实现以下三个测试案例。对于每个案例，完全按照规定（包括种子）模拟数据，然后计算 $\\alpha$ 的后验均值。\n\n- 案例 $1$（理想情况；清晰的误差修正）：\n  - $T = 200$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} -0.2 \\\\ 0.15 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0004  0.0 \\\\ 0.0  0.0009 \\end{bmatrix}$,\n  - 随机种子 $= 123$。\n\n- 案例 $2$（相关扰动；较弱的误差修正）：\n  - $T = 80$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} -0.05 \\\\ 0.05 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0009  0.0002 \\\\ 0.0002  0.0009 \\end{bmatrix}$,\n  - 随机种子 $= 456$。\n\n- 案例 $3$（边缘情况；在秩为 $1$ 的模型下几乎没有协整调整）：\n  - $T = 50$,\n  - $\\alpha^{\\text{true}} = \\begin{bmatrix} 0.0 \\\\ 0.0 \\end{bmatrix}$,\n  - $\\Sigma^{\\text{true}} = \\begin{bmatrix} 0.0016  0.0 \\\\ 0.0  0.0016 \\end{bmatrix}$,\n  - 随机种子 $= 789$。\n\n您的程序应在单行中输出一个扁平列表，其中包含恰好六个浮点数，对应于每个案例中 $\\alpha$ 的两个条目的后验均值，顺序如下：\n$[\\widehat{\\alpha}_{1}^{(1)}, \\widehat{\\alpha}_{2}^{(1)}, \\widehat{\\alpha}_{1}^{(2)}, \\widehat{\\alpha}_{2}^{(2)}, \\widehat{\\alpha}_{1}^{(3)}, \\widehat{\\alpha}_{2}^{(3)}]$,\n其中上标 $(i)$ 表示测试案例的索引。每个浮点数必须格式化为恰好 $6$ 位小数。最终输出必须是单行，格式完全如下：\n\"[a1_case1,a2_case1,a1_case2,a2_case2,a1_case3,a2_case3]\".\n\n此问题不涉及角度或物理单位。所有计算都是无量纲的实数。因此，对角度单位的要求不适用。\n\n约束和要求重述：\n- 您必须从多元高斯似然和矩阵正态逆威沙特 (MNIW) 先验的核心定义开始。\n- 您必须在共轭性下推导后验分布，并实现得到的 $\\alpha$ 的后验均值。\n- 您必须为每个测试案例完全按照规定模拟数据。\n- 您不得使用任何外部数据或非标准库。\n- 您的程序必须生成一个单行，其中包含一个用方括号括起来的逗号分隔列表，列表包含按指定顺序排列的恰好 $6$ 个浮点数，每个浮点数保留 $6$ 位小数。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。它具有科学依据，问题设定良好，并包含得出唯一解所需的所有必要信息。任务是使用共轭先验对协整向量自回归 (CVAR) 模型中的调整系数向量进行贝叶斯估计。我们将进行完整的推导和实现。\n\n**1. 模型设定**\n二元对数汇率向量 $y_t \\in \\mathbb{R}^2$ 的模型是一个协整秩为 $1$ 的向量误差修正模型 (VECM)：\n$$\n\\Delta y_t = \\alpha \\beta^\\top y_{t-1} + \\varepsilon_t, \\quad \\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma)\n$$\n此处，$\\alpha \\in \\mathbb{R}^{2 \\times 1}$ 是调整系数向量，$\\beta = \\begin{bmatrix} 1 \\\\ -1 \\end{bmatrix} \\in \\mathbb{R}^{2 \\times 1}$ 是已知的协整向量，而 $\\Sigma \\in \\mathbb{R}^{2 \\times 2}$ 是新息的正定协方差矩阵。\n为了估计，该模型被设定为一个多元线性回归。设标量误差修正项为 $x_t = \\beta^\\top y_{t-1}$。对于一个包含 $T$ 个观测值的样本，我们定义以下矩阵：\n- 因变量矩阵：$Y = \\begin{bmatrix} (\\Delta y_1)^\\top \\\\ \\vdots \\\\ (\\Delta y_T)^\\top \\end{bmatrix} \\in \\mathbb{R}^{T \\times 2}$\n- 回归量矩阵：$X = \\begin{bmatrix} x_1 \\\\ \\vdots \\\\ x_T \\end{bmatrix} \\in \\mathbb{R}^{T \\times 1}$\n该模型随后可以表示为：\n$$\nY = X B + E\n$$\n其中 $B = \\alpha^\\top \\in \\mathbb{R}^{1 \\times 2}$ 是回归系数矩阵。误差矩阵 $E$ 的行是从 $\\mathcal{N}(\\mathbf{0}, \\Sigma)$ 中独立抽取的，这对应于矩阵正态分布 $E \\sim \\mathcal{MN}_{T,2}(\\mathbf{0}, I_T, \\Sigma)$。\n\n**2. 贝叶斯框架：似然与先验**\n在给定参数 $(B, \\Sigma)$ 的条件下，数据 $(Y, X)$ 的似然函数从误差项 $E$ 的分布中导出：\n$$\np(Y \\mid X, B, \\Sigma) \\propto |\\Sigma|^{-T/2} \\exp\\left(-\\frac{1}{2} \\mathrm{tr}\\left( (Y - X B)^\\top (Y - X B) \\Sigma^{-1} \\right)\\right)\n$$\n为参数 $(B, \\Sigma)$ 指定一个共轭的矩阵正态逆威沙特 (MNIW) 先验：\n$$\np(B, \\Sigma) = p(B \\mid \\Sigma) p(\\Sigma)\n$$\nB 的条件先验是矩阵正态分布，而 $\\Sigma$ 的边际先验是逆威沙特分布：\n$$\nB \\mid \\Sigma \\sim \\mathcal{MN}_{1,2}(B_0, V_0, \\Sigma)\n$$\n$$\n\\Sigma \\sim \\mathcal{IW}(S_0, \\nu_0)\n$$\n该先验由超参数定义：$B_0 \\in \\mathbb{R}^{1 \\times 2}$，$V_0 \\in \\mathbb{R}^{1 \\times 1}$ (一个正定矩阵，此处为标量)，$S_0 \\in \\mathbb{R}^{2 \\times 2}$ (一个正定矩阵)，以及 $\\nu_0 \\in \\mathbb{R}$ (自由度，$\\nu_0 > 2-1=1$）。\n\n**3. 后验分布推导**\n根据贝叶斯定理，后验分布正比于似然乘以先验：\n$$\np(B, \\Sigma \\mid Y, X) \\propto p(Y \\mid X, B, \\Sigma) \\, p(B \\mid \\Sigma) \\, p(\\Sigma)\n$$\n鉴于先验的共轭性，后验分布保留了 MNIW 形式：\n$$\n(B, \\Sigma) \\mid Y, X \\sim \\text{MNIW}(B_N, V_N, S_N, \\nu_N)\n$$\n后验超参数 $(B_N, V_N, S_N, \\nu_N)$ 是基于数据对先验超参数的更新。我们通过分析后验密度的核来推导这些参数。对数后验的指数部分中涉及 $B$ 的项（忽略常数）为：\n$$\n-\\frac{1}{2} \\mathrm{tr}\\left( \\left[ (Y - X B)^\\top (Y - X B) + (B - B_0)^\\top V_0^{-1} (B - B_0) \\right] \\Sigma^{-1} \\right)\n$$\n通过展开二次型并对 $B$ 进行配方，我们可以确定条件后验 $p(B \\mid \\Sigma, Y, X)$ 的参数。相关项为：\n$$\nB^\\top (X^\\top X) B - B^\\top(X^\\top Y) - (Y^\\top X)B + B^\\top V_0^{-1} B - B^\\top V_0^{-1} B_0 - B_0^\\top V_0^{-1} B\n$$\n$$\n= B^\\top(V_0^{-1} + X^\\top X)B - B^\\top(V_0^{-1}B_0 + X^\\top Y) - (B_0^\\top V_0^{-1} + Y^\\top X)B\n$$\n这个结构揭示了 $B$ 的后验精度和均值。$B$ 的（行的）后验精度矩阵为 $V_N^{-1} = V_0^{-1} + X^\\top X$。后验均值 $B_N$ 满足 $V_N^{-1}B_N = V_0^{-1}B_0 + X^\\top Y$。\n决定 $B$ 的后验分布的参数的最终更新规则是：\n$$\nV_N = (V_0^{-1} + X^\\top X)^{-1}\n$$\n$$\nB_N = V_N (V_0^{-1} B_0 + X^\\top Y)\n$$\n$\\Sigma$ 的逆威沙特分布的后验自由度简单更新为：\n$$\n\\nu_N = \\nu_0 + T\n$$\n后验尺度矩阵 $S_N$ 对于此问题不是必需的，因为我们只需要 $\\alpha$ 的后验均值。$B$ 的后验均值为 $E[B \\mid Y, X] = B_N$。由于 $\\alpha = B^\\top$，根据期望的线性性质，$\\alpha$ 的后验均值为：\n$$\n\\widehat{\\alpha} = E[\\alpha \\mid Y, X] = (E[B \\mid Y, X])^\\top = B_N^\\top\n$$\n\n**4. 计算算法**\n对于每个测试案例，实现过程包括两个主要部分。\n\n首先，**数据模拟**：\n$1$. 使用指定的种子初始化一个随机数生成器。\n$2$. 设置初始向量 $\\mathbf{y}_0 = \\mathbf{0} \\in \\mathbb{R}^{2 \\times 1}$。\n$3$. 从 $t = 1$ 循环到 $T$：\n    a. 计算误差修正项 $x_t = \\beta^\\top y_{t-1}$。\n    b. 生成一个新息向量 $\\varepsilon_t \\sim \\mathcal{N}(\\mathbf{0}, \\Sigma^{\\text{true}})$。\n    c. 计算变化向量 $\\Delta y_t = \\alpha^{\\text{true}} x_t + \\varepsilon_t$。\n    d. 更新状态向量：$y_t = y_{t-1} + \\Delta y_t$。\n    e. 存储 $x_t$ 和 $(\\Delta y_t)^\\top$。\n$4$. 将存储的值组合成矩阵 $X \\in \\mathbb{R}^{T \\times 1}$ 和 $Y \\in \\mathbb{R}^{T \\times 2}$。\n\n其次，**贝叶斯估计**：\n$1$. 指定先验超参数：$B_0 = \\mathbf{0}_{1 \\times 2}$, $V_0 = c I_1$ 其中 $c = 10^6$, $\\nu_0 = 4$，以及 $S_0 = s_0 I_2$ 其中 $s_0 = 10^{-4}$。\n$2$. 使用模拟数据 $(X, Y)$ 计算汇总统计量 $X^\\top X$ 和 $X^\\top Y$。\n$3$. 计算先验精度矩阵的逆 $V_0^{-1}$。\n$4$. 计算后验精度参数 $V_N = (V_0^{-1} + X^\\top X)^{-1}$。\n$5$. 计算后验均值参数 $B_N = V_N (V_0^{-1} B_0 + X^\\top Y)$。\n$6$. 最终估计是 $\\alpha$ 的后验均值，由 $\\widehat{\\alpha} = B_N^\\top$ 给出。该向量的两个元素是给定案例所需的输出。\n\n对三个测试案例中的每一个都执行此过程，并将结果连接起来。", "answer": "```python\nimport numpy as np\n\ndef generate_data(T, alpha_true, Sigma_true, seed):\n    \"\"\"\n    Simulates data from the specified VECM.\n\n    Args:\n        T (int): Number of time periods to simulate.\n        alpha_true (np.ndarray): True alpha vector (2x1).\n        Sigma_true (np.ndarray): True innovation covariance matrix (2x2).\n        seed (int): Random seed for reproducibility.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing the regressor matrix X (Tx1)\n                                       and the dependent variable matrix Y (Tx2).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    beta = np.array([[1.0], [-1.0]])\n    y_prev = np.zeros((2, 1))\n\n    X_list = []\n    Y_list = []\n\n    for _ in range(T):\n        # Calculate the error correction term\n        x_t = (beta.T @ y_prev).item()  # The result is a scalar\n        \n        # Draw innovation from a multivariate normal distribution\n        epsilon_t = rng.multivariate_normal(np.zeros(2), Sigma_true).reshape(2, 1)\n\n        # Compute delta_y_t using the VECM equation\n        delta_y_t = alpha_true * x_t + epsilon_t\n        \n        # Update the y process\n        y_t = y_prev + delta_y_t\n        \n        # Store data for the regression Y = XB + E\n        X_list.append(x_t)\n        Y_list.append(delta_y_t.flatten())  # Store delta_y_t as a row vector\n        \n        y_prev = y_t\n\n    X = np.array(X_list).reshape(-1, 1)\n    Y = np.array(Y_list)\n    return X, Y\n\ndef estimate_posterior_alpha_mean(X, Y, B0, V0):\n    \"\"\"\n    Computes the posterior mean of alpha under a conjugate MNIW prior.\n\n    Args:\n        X (np.ndarray): Regressor matrix (Tx1).\n        Y (np.ndarray): Dependent variable matrix (Tx2).\n        B0 (np.ndarray): Prior mean for B (1x2).\n        V0 (np.ndarray): Prior covariance for B (rows) (1x1).\n\n    Returns:\n        np.ndarray: The posterior mean of alpha, a flattened array of 2 elements.\n    \"\"\"\n    # Calculate sufficient statistics from data\n    XTX = X.T @ X  # Shape: (1x1)\n    XTY = X.T @ Y  # Shape: (1x2)\n\n    # Calculate inverse of prior variance\n    V0_inv = np.linalg.inv(V0)\n    \n    # Calculate posterior parameters for B using standard update rules\n    VN_inv = V0_inv + XTX\n    VN = np.linalg.inv(VN_inv)\n    \n    # The term V0_inv @ B0 is zero since B0 is zero, but included for completeness\n    BN = VN @ (V0_inv @ B0 + XTY)  # Shape: (1x2)\n    \n    # The posterior mean of alpha is the transpose of BN\n    alpha_hat = BN.T  # Shape: (2x1)\n    \n    return alpha_hat.flatten()\n\ndef solve():\n    \"\"\"\n    Main solver function to run all test cases and print the final result.\n    \"\"\"\n    # Definition of test cases as provided in the problem statement\n    test_cases = [\n        {\n            \"T\": 200,\n            \"alpha_true\": np.array([[-0.2], [0.15]]),\n            \"Sigma_true\": np.array([[0.0004, 0.0], [0.0, 0.0009]]),\n            \"seed\": 123\n        },\n        {\n            \"T\": 80,\n            \"alpha_true\": np.array([[-0.05], [0.05]]),\n            \"Sigma_true\": np.array([[0.0009, 0.0002], [0.0002, 0.0009]]),\n            \"seed\": 456\n        },\n        {\n            \"T\": 50,\n            \"alpha_true\": np.array([[0.0], [0.0]]),\n            \"Sigma_true\": np.array([[0.0016, 0.0], [0.0, 0.0016]]),\n            \"seed\": 789\n        }\n    ]\n\n    # Prior hyperparameters, S0 and nu0 are not needed for the mean of alpha\n    c = 1e6\n    B0 = np.zeros((1, 2))\n    V0 = c * np.identity(1)\n\n    all_results = []\n    for case in test_cases:\n        # 1. Simulate data according to the VECM process\n        X, Y = generate_data(case[\"T\"], case[\"alpha_true\"], case[\"Sigma_true\"], case[\"seed\"])\n        \n        # 2. Compute the posterior mean of alpha\n        alpha_hat = estimate_posterior_alpha_mean(X, Y, B0, V0)\n        \n        # 3. Collect results\n        all_results.extend(alpha_hat)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{r:.6f}\" for r in all_results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2375565"}]}