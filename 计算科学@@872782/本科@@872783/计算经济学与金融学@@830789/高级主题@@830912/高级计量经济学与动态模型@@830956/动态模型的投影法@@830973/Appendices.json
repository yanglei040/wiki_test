{"hands_on_practices": [{"introduction": "投影法的核心目标是找到一个近似的策略函数，使得模型最优性条件（即欧拉方程）的误差尽可能小。在我们着手构建一个完整的求解器之前，首要任务是学会如何精确地衡量这个误差。本练习将指导你如何量化一个给定近似解的准确性。([@problem_id:2422834])\n\n此练习的核心科学原理是欧拉方程残差（Euler equation residual）的概念。它衡量了在任何给定的状态下，我们的近似策略与最优策略之间的偏差。一个高质量的近似解应该在整个状态空间上都具有极小的残差。通过在一个密集的网格上计算并找到最大的残差，我们可以评估该解的整体质量。这项实践不仅能帮助你理解配点法（collocation method）的最终目标，还能培养验证模型解这一关键的计算技能。", "problem": "考虑具有常数相对风险厌恶（CRRA）偏好和柯布-道格拉斯（Cobb–Douglas）生产函数的确定性新古典增长模型。设代表性代理人对消费的偏好由周期效用函数 $u(c)$ 给出，其形式为\n$$\nu(c) =\n\\begin{cases}\n\\dfrac{c^{1-\\sigma}}{1-\\sigma},  \\text{若 } \\sigma \\neq 1, \\\\\n\\ln(c),  \\text{若 } \\sigma = 1,\n\\end{cases}\n$$\n其中 $\\sigma > 0$ 是相对风险厌恶系数。资本 $k$ 的演化遵循以下规律\n$$\nk' = A k^{\\alpha} + (1-\\delta) k - c,\n$$\n其中 $A > 0$ 是全要素生产率，$\\alpha \\in (0,1)$ 是生产中的资本份额，$\\delta \\in (0,1)$ 是折旧率。在这种确定性设置下，刻画最优策略的欧拉方程为\n$$\nu'(c(k)) = \\beta \\, u'(c(k')) \\left( A \\alpha (k')^{\\alpha - 1} + 1 - \\delta \\right),\n$$\n其中边际效用由下式给出\n$$\nu'(c) =\n\\begin{cases}\nc^{-\\sigma},  \\text{若 } \\sigma \\neq 1, \\\\\n\\dfrac{1}{c},  \\text{若 } \\sigma = 1.\n\\end{cases}\n$$\n\n假设给定一个近似的消费策略函数 $\\hat{c}(k)$，该函数是先前通过在资本域 $[k_{\\min}, k_{\\max}]$ 上对最高3次的切比雪夫多项式使用投影法获得的。定义从资本 $k \\in [k_{\\min}, k_{\\max}]$ 到切比雪夫域 $x \\in [-1,1]$ 的仿射变换为\n$$\nx(k) = \\frac{2 k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n$$\n设前四个第一类切比雪夫多项式为\n$$\nT_0(x) = 1,\\quad T_1(x) = x,\\quad T_2(x) = 2x^2 - 1,\\quad T_3(x) = 4x^3 - 3x.\n$$\n近似的消费策略为\n$$\n\\hat{c}(k) = \\theta_0 T_0(x(k)) + \\theta_1 T_1(x(k)) + \\theta_2 T_2(x(k)) + \\theta_3 T_3(x(k)),\n$$\n其中系数向量 $\\boldsymbol{\\theta} = (\\theta_0,\\theta_1,\\theta_2,\\theta_3)$ 对每组参数都是特定的。对于任何给定的 $k$，定义隐含的下一期资本为\n$$\nk'(k) = A k^{\\alpha} + (1-\\delta) k - \\hat{c}(k),\n$$\n并定义在 $k$ 处的绝对欧拉方程残差为\n$$\n\\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|.\n$$\n您的任务是，对于下面的每一组参数，在一个包含 $[k_{\\min}, k_{\\max}]$ 区间上 $N_{\\text{fine}}$ 个点的精细均匀网格上，计算最大绝对欧拉方程残差。请使用包含两个端点的网格。答案没有物理单位。\n\n测试套件（每种情况指定了 $(A,\\alpha,\\beta,\\delta,\\sigma)$、域 $[k_{\\min},k_{\\max}]$、系数向量 $\\boldsymbol{\\theta}$ 和 $N_{\\text{fine}}$）：\n\n- 情况1（基线，内部解）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 2.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.75, 0.35, 0.02, -0.01)$，$N_{\\text{fine}} = 2001$。\n\n- 情况2（更高风险厌恶）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 5.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.70, 0.32, 0.00, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n- 情况3（更高折旧和更低耐心）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.92, 0.15, 2.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.65, 0.28, 0.03, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n- 情况4（接近对数效用）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.01)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.74, 0.34, 0.01, 0.02)$，$N_{\\text{fine}} = 2001$。\n\n- 情况5（对数效用边界情况）：$(A,\\alpha,\\beta,\\delta,\\sigma) = (1.0, 0.33, 0.96, 0.08, 1.0)$，$[k_{\\min}, k_{\\max}] = [0.5, 3.0]$，$\\boldsymbol{\\theta} = (0.72, 0.33, 0.01, 0.00)$，$N_{\\text{fine}} = 2001$。\n\n对于每种情况，计算精细网格上的最大绝对欧拉方程残差。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3,result4,result5]”）。将每个结果报告为浮点数，不带任何百分号，且无特定舍入要求。", "solution": "提交的问题陈述是计算经济学中一个定义明确的练习。它具有科学依据，内部一致，并包含进行求解所需的所有必要信息。任务是通过在指定域上计算最大欧拉方程残差，来评估一个预先计算的确定性新古典增长模型近似策略函数的准确性。我将开始进行求解。\n\n目标是计算最大绝对欧拉方程残差，定义为\n$$\n\\text{Res}(k) = \\left| u'(\\hat{c}(k)) - \\beta \\, u'(\\hat{c}(k'(k))) \\left( A \\alpha (k'(k))^{\\alpha - 1} + 1 - \\delta \\right) \\right|,\n$$\n对于一组资本网格点 $k \\in [k_{\\min}, k_{\\max}]$。消费的策略函数 $\\hat{c}(k)$ 是通过使用前四个第一类切比雪夫多项式 $T_n(x)$ 的线性组合来近似的。\n\n每个测试用例的计算过程如下：\n\n1.  **建立资本网格**：在区间 $[k_{\\min}, k_{\\max}]$ 上构建一个包含 $N_{\\text{fine}}$ 个资本水平的均匀网格，记为 $\\{k_i\\}_{i=1}^{N_{\\text{fine}}}$。该网格包含端点。\n\n2.  **评估当前消费 $\\hat{c}(k)$**：对于网格上的每个资本水平 $k_i$，我们首先使用仿射变换将其映射到切比雪夫域 $x_i = x(k_i) \\in [-1,1]$：\n    $$\n    x(k_i) = \\frac{2 k_i - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.\n    $$\n    然后，通过使用给定的系数向量 $\\boldsymbol{\\theta} = (\\theta_0, \\theta_1, \\theta_2, \\theta_3)$ 评估切比雪夫多项式展开式来计算近似消费 $\\hat{c}(k_i)$：\n    $$\n    \\hat{c}(k_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k_i)).\n    $$\n    基多项式为 $T_0(x) = 1$、$T_1(x) = x$、$T_2(x) = 2x^2 - 1$ 和 $T_3(x) = 4x^3 - 3x$。\n\n3.  **确定下一期资本 $k'$**：使用资本运动定律，为每个 $k_i$ 计算隐含的下一期资本存量 $k'_i = k'(k_i)$：\n    $$\n    k'_i = A k_i^{\\alpha} + (1-\\delta) k_i - \\hat{c}(k_i).\n    $$\n\n4.  **评估下一期消费 $\\hat{c}(k')$**：下一期的消费 $\\hat{c}(k'_i)$ 是通过将相同的近似策略函数应用于所得到的资本存量 $k'_i$ 来确定的。这包括将每个 $k'_i$ 映射到其对应的切比雪夫域值 $x'_i = x(k'_i)$ 并评估多项式展开：\n    $$\n    \\hat{c}(k'_i) = \\sum_{j=0}^{3} \\theta_j T_j(x(k'_i)).\n    $$\n    请注意，$k'_i$ 不保证在原始近似域 $[k_{\\min}, k_{\\max}]$ 内。在这种情况下，多项式提供了外插值。\n\n5.  **计算边际效用**：对当前和下一期的消费评估消费的边际效用 $u'(c)$。该函数取决于相对风险厌恶系数 $\\sigma$：\n    $$\n    u'(c) =\n    \\begin{cases}\n    c^{-\\sigma},  \\text{若 } \\sigma \\neq 1, \\\\\n    c^{-1},  \\text{若 } \\sigma = 1.\n    \\end{cases}\n    $$\n    我们为网格上的所有点计算 $u'(\\hat{c}(k_i))$ 和 $u'(\\hat{c}(k'_i))$。\n\n6.  **计算欧拉方程残差**：对于每个网格点 $k_i$，计算并比较欧拉方程的两边。左手边（LHS）是 $u'(\\hat{c}(k_i))$。右手边（RHS）是\n    $$\n    \\text{RHS}_i = \\beta \\, u'(\\hat{c}(k'_i)) \\left( A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta \\right).\n    $$\n    项 $A \\alpha (k'_i)^{\\alpha - 1} + 1 - \\delta$ 代表下一期资本的总回报率。在 $k_i$ 处的绝对残差为 $\\text{Res}(k_i) = |\\text{LHS}_i - \\text{RHS}_i|$。\n\n7.  **找到最大残差**：在为所有 $i=1, \\dots, N_{\\text{fine}}$ 计算残差 $\\text{Res}(k_i)$ 后，确定最大值：\n    $$\n    \\max_{i} \\text{Res}(k_i).\n    $$\n这个最大值量化了近似策略函数在指定网格上满足模型最优性条件的最大误差。整个过程使用向量化的数值运算来实现以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the maximum absolute Euler equation residual for several parameterizations\n    of the neoclassical growth model, given an approximate consumption policy function\n    represented by Chebyshev polynomials.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: (A, alpha, beta, delta, sigma), [k_min, k_max], theta, N_fine\n        ( (1.0, 0.33, 0.96, 0.08, 2.0), [0.5, 3.0], [0.75, 0.35, 0.02, -0.01], 2001 ),\n        # Case 2\n        ( (1.0, 0.33, 0.96, 0.08, 5.0), [0.5, 3.0], [0.70, 0.32, 0.00, 0.00], 2001 ),\n        # Case 3\n        ( (1.0, 0.33, 0.92, 0.15, 2.0), [0.5, 3.0], [0.65, 0.28, 0.03, 0.00], 2001 ),\n        # Case 4\n        ( (1.0, 0.33, 0.96, 0.08, 1.01), [0.5, 3.0], [0.74, 0.34, 0.01, 0.02], 2001 ),\n        # Case 5\n        ( (1.0, 0.33, 0.96, 0.08, 1.0), [0.5, 3.0], [0.72, 0.33, 0.01, 0.00], 2001 )\n    ]\n\n    results = []\n\n    def evaluate_chebyshev_policy(k, k_min, k_max, theta_coeffs):\n        \"\"\"\n        Evaluates the consumption policy approximated by Chebyshev polynomials.\n        It is vectorized to operate on an array of capital levels k.\n        \"\"\"\n        # Map capital k from [k_min, k_max] to x in [-1, 1]\n        x = (2 * k - (k_min + k_max)) / (k_max - k_min)\n        \n        # Chebyshev polynomials T0, T1, T2, T3\n        T0 = np.ones_like(x)\n        T1 = x\n        T2 = 2 * x**2 - 1\n        T3 = 4 * x**3 - 3 * x\n        \n        # Form the basis matrix (N x 4)\n        chebyshev_basis = np.vstack([T0, T1, T2, T3]).T\n        \n        # Calculate consumption c_hat using matrix-vector product\n        c_hat = chebyshev_basis @ theta_coeffs\n        return c_hat\n\n    for case in test_cases:\n        params, k_domain, theta_list, N_fine = case\n        A, alpha, beta, delta, sigma = params\n        k_min, k_max = k_domain\n        theta = np.array(theta_list)\n\n        # 1. Create the capital grid\n        k_grid = np.linspace(k_min, k_max, N_fine)\n        \n        # 2. Evaluate current consumption on the grid\n        c_k = evaluate_chebyshev_policy(k_grid, k_min, k_max, theta)\n        \n        # 3. Determine next-period capital\n        k_prime = A * k_grid**alpha + (1 - delta) * k_grid - c_k\n        \n        # 4. Evaluate next-period consumption\n        c_k_prime = evaluate_chebyshev_policy(k_prime, k_min, k_max, theta)\n        \n        # 5. Calculate marginal utilities\n        if sigma == 1.0:\n            mu_k = 1.0 / c_k\n            mu_k_prime = 1.0 / c_k_prime\n        else:\n            mu_k = c_k**(-sigma)\n            mu_k_prime = c_k_prime**(-sigma)\n\n        # 6. Calculate the RHS of the Euler equation\n        # Marginal product of capital in the next period\n        mpk_prime = A * alpha * k_prime**(alpha - 1) + 1 - delta\n        \n        # Full RHS\n        euler_rhs = beta * mu_k_prime * mpk_prime\n        \n        # 7. Calculate the absolute residuals\n        residuals = np.abs(mu_k - euler_rhs)\n        \n        # 8. Find the maximum residual and store it\n        max_residual = np.max(residuals)\n        results.append(max_residual)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2422834"}, {"introduction": "既然我们已经掌握了如何衡量一个解的误差，下一步自然是构建一个能够找到最优策略函数系数的求解器，其目标正是将此误差驱动至零。我们将从一个确定性的新古典增长模型开始，这是动态宏观经济学的一个基石模型。([@problem_id:2422824])\n\n本练习将引导你运用配点法，将一个复杂的函数方程问题转化为一个非线性代数方程组。我们将使用牛顿法（Newton's method）来高效求解该方程组，并特别地，利用自动微分（automatic differentiation）技术来自动计算求解过程中必需的雅可比矩阵（Jacobian matrix），从而避免繁琐且易错的手动求导。这项练习将为你提供实现现代、稳健的动态模型求解器的实战经验，这是计算经济学领域的一项核心技能。", "problem": "要求您使用多项式策略近似，通过投影和配点法结合自动微分，实现并求解一个确定性单状态新古典增长模型。数值目标是近似满足跨期最优性条件的最优策略，并报告在多个参数集下，评估网格上的最大欧拉方程残差。您的程序必须是一个完整、可运行的程序，并产生指定的单行输出。\n\n模型与基本原理：\n- 代表性代理人选择消费 $c_t$ 和下一期资本 $k_{t+1}$ 以最大化时期效用的贴现总和\n$$\\sum_{t=0}^{\\infty} \\beta^t u(c_t),$$\n受制于资源运动定律\n$$c_t + k_{t+1} = f(k_t) + (1-\\delta)\\,k_t,$$\n其中生产函数为 $f(k) = A\\,k^{\\alpha}$，贴现因子 $\\beta \\in (0,1)$，资本份额 $\\alpha \\in (0,1)$，折旧率 $\\delta \\in (0,1)$，生产率 $A > 0$。偏好为恒定相对风险规避（CRRA）形式，参数为 $\\gamma > 0$，由以下公式给出：\n$$u(c) = \n\\begin{cases}\n\\frac{c^{1-\\gamma}}{1-\\gamma},  \\gamma \\neq 1,\\\\\n\\ln(c),  \\gamma = 1,\n\\end{cases}\n\\quad\\text{so that}\\quad\nu'(c) = \n\\begin{cases}\nc^{-\\gamma},  \\gamma \\neq 1,\\\\\n\\frac{1}{c},  \\gamma = 1.\n\\end{cases}$$\n- 内部解的跨期最优性（欧拉）条件为\n$$u'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right),$$\n其中 $f'(k) = \\alpha A k^{\\alpha - 1}$。\n\n策略表示与投影设置：\n- 定义可用资源 $R(k) = f(k)+(1-\\delta)k$。\n- 将策略参数化为一个平滑的储蓄份额 $s(k) \\in (0,1)$，并设定\n$$k' = s(k)\\,R(k), \\quad c = (1-s(k))\\,R(k).$$\n- 令 $x(k)$ 为将 $k \\in [k_{\\min},k_{\\max}]$ 映射到 $[-1,1]$ 的仿射映射：\n$$x(k) = \\frac{2k - (k_{\\min} + k_{\\max})}{k_{\\max} - k_{\\min}}.$$\n- 用一个 $n-1$ 阶的截断切比雪夫级数来近似储蓄份额的 logit：\n$$\\phi(k) \\equiv \\log\\left(\\frac{s(k)}{1 - s(k)}\\right) \\approx \\sum_{j=0}^{n-1} a_j\\,T_j(x(k)),$$\n然后 $s(k) = \\sigma(\\phi(k))$，其中 logistic 映射为 $\\sigma(z) = \\frac{1}{1+e^{-z}}$。\n- 配点法：选择 $n$ 个切比雪夫节点 $x_i = \\cos\\left(\\frac{2i-1}{2n}\\pi\\right)$（$i=1,\\dots,n$），并通过 $x \\mapsto k$ 将它们映射到资本网格点 $k_i$。要求这 $n$ 个节点上的 $n$ 个欧拉方程残差为零，由此定义残差向量 $R(a)\\in\\mathbb{R}^n$：\n$$R_i(a) = u'\\big(c(k_i;a)\\big) - \\beta\\,u'\\big(c(k'_i;a)\\big)\\left(f'(k'_i)+1-\\delta\\right), \\quad k'_i = s(k_i;a)\\,R(k_i), \\quad c(k_i;a) = R(k_i) - k'_i,$$\n$$c(k'_i;a) = R(k'_i) - s(k'_i;a)\\,R(k'_i).$$\n这里 $a = (a_0,\\dots,a_{n-1})$ 是未知系数。\n\n自动微分要求：\n- 为了实现一个稳定且精确的牛顿求解器来求解非线性系统 $R(a) = 0$，请使用自动微分计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$。您可以实现前向模式对偶数来达到此目的，这样代码就能保持自包含，并且不依赖于允许库之外的外部包。\n\n确保真实性和可复现性的数值规范：\n- 对于每个参数集，计算由稳态欧拉方程所蕴含的稳态资本水平 $k^{\\ast}$\n$$f'(k^{\\ast}) + 1 - \\delta = \\frac{1}{\\beta}, \\quad\\text{that is}\\quad \\alpha A (k^{\\ast})^{\\alpha - 1} = \\frac{1}{\\beta} - 1 + \\delta,$$\n并设置近似区间 $[k_{\\min},k_{\\max}] = [\\zeta_1 k^{\\ast},\\, \\zeta_2 k^{\\ast}]$，其中 $\\zeta_1 = 0.7$，$\\zeta_2 = 1.3$。\n- 使用 $n = 7$ 个切比雪夫基函数和 $n = 7$ 个配点节点。\n- 用与稳态储蓄份额 $s^{\\ast} = \\frac{k^{\\ast}}{R(k^{\\ast})}$ 对应的常数 logit 来初始化系数，即设 $a_0 = \\log\\left(\\frac{s^{\\ast}}{1-s^{\\ast}}\\right)$ 且当 $j \\ge 1$ 时 $a_j = 0$。\n\n测试套件：\n实现您的求解器，并通过计算下面每个参数集在 $[k_{\\min},k_{\\max}]$ 上 $M=80$ 个等距点的评估网格上的最大绝对欧拉残差，来评估投影解的质量：\n$$\\max_{k \\in \\mathcal{G}} \\left| u'\\big(c(k;a)\\big) - \\beta\\,u'\\big(c(k';a)\\big)\\left(f'(k')+1-\\delta\\right) \\right|,$$\n其中 $\\mathcal{G}$ 是均匀网格，并且 $k' = s(k;a)R(k)$，$c(k;a)=R(k)-k'$，$c(k';a)=R(k')-s(k';a)R(k')$ 如上所述。将每个测试用例的此最大值报告为浮点数。\n\n参数集如下：\n- 案例 A（基准）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.96,\\,0.08,\\,2.0,\\,1.0)$。\n- 案例 B（有耐心）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.36,\\,0.99,\\,0.025,\\,2.0,\\,1.0)$。\n- 案例 C（高折旧和高风险规避）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.40,\\,0.95,\\,0.15,\\,3.0,\\,1.0)$。\n- 案例 D（对数效用）：$(\\alpha,\\beta,\\delta,\\gamma,A) = (0.33,\\,0.97,\\,0.08,\\,1.0,\\,1.0)$。\n\n算法要求：\n- 使用带有回溯线搜索的牛顿法求解系数向量 $a$ 的方程 $R(a) = 0$。当残差向量的无穷范数低于 $\\varepsilon = 10^{-8}$ 或达到最大迭代次数 $I_{\\max} = 50$ 时终止。\n- 通过前向模式对偶数计算雅可比矩阵 $\\frac{\\partial R}{\\partial a}(a)$，对切比雪夫递推关系 $T_0(x)=1$，$T_1(x)=x$，$T_{j+1}(x) = 2xT_j(x) - T_{j-1}(x)$ 及所有下游计算（包括 $k'$, $c$, $c'$）进行微分。\n- 在求解牛顿步时，如果雅可比矩阵是奇异或病态的，您可以使用最小二乘步。\n\n最终输出格式：\n- 对于给定的 A–D 四个案例，您的程序应按顺序生成单行输出，其中包含四个最大残差值，以逗号分隔并用方括号括起，例如“[vA,vB,vC,vD]”。每个条目都必须是浮点数。\n\n不涉及物理单位或角度单位。所有最终数值均以不带百分号的普通浮点数表示。程序必须是自包含的，不得要求任何用户输入或外部文件。唯一允许的库是执行环境中声明的 Python 标准库、NumPy 和 SciPy。", "solution": "所提出的问题是计算经济学中一个标准的、定义明确的练习：使用投影法对确定性新古典增长模型进行数值求解。问题的所有组成部分——经济模型、近似架构和数值算法——都基于已建立且科学合理的原则。该问题是自包含的、内部一致的，并且满足事实健全性、适定性和客观性，因此该问题适合进行完整求解。\n\n我们从模型的基本最优性条件——欧拉方程开始，它将跨时间的边际效用联系起来：\n$$\nu'(c_t) = \\beta\\,u'(c_{t+1})\\left(f'(k_{t+1}) + 1 - \\delta\\right)\n$$\n在这里，$c_t$ 是时间 $t$ 的消费，$k_t$ 是资本存量，$\\beta$ 是贴现因子，$\\delta$ 是资本折旧率。效用函数为恒定相对风险规避（CRRA）形式，$u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$（如果 $\\gamma=1$，则为 $\\ln(c)$），其边际效用始终为 $u'(c) = c^{-\\gamma}$。生产函数为柯布-道格拉斯形式，$f(k) = Ak^{\\alpha}$，其边际产出为 $f'(k) = \\alpha A k^{\\alpha-1}$。\n\n目标是找到最优策略函数，该函数为任意给定的当前资本存量 $k_t$ 决定下一期的资本 $k_{t+1}$。我们将此函数表示为 $k_{t+1} = g(k_t)$。投影法用一个已知的、参数化的函数形式来近似这个未知函数 $g(k)$。问题通过储蓄份额 $s(k) \\in (0,1)$ 指定了一种数值稳定的参数化方法，使得：\n$$\nk_{t+1} = s(k_t) R(k_t) \\quad \\text{and} \\quad c_t = (1-s(k_t))R(k_t)\n$$\n其中 $R(k) = f(k) + (1-\\delta)k$ 代表可从生产和未折旧资本中获得的总资源。这种表述方式通过构造确保了资源约束得到满足。\n\n为了便于在无界范围上进行近似，使用 logit 函数对储蓄份额 $s(k)$ 进行变换，即 $\\phi(k) = \\log\\left(\\frac{s(k)}{1-s(k)}\\right)$。这个变换后的策略函数 $\\phi(k)$ 由一个包含 $n$ 个第一类切比雪夫多项式 $T_j(x)$ 的截断级数来近似：\n$$\n\\phi(k; a) \\approx \\sum_{j=0}^{n-1} a_j T_j(x(k))\n$$\n其中 $a = (a_0, \\dots, a_{n-1})$ 是待确定的未知系数向量。变量 $x(k)$ 是一个仿射变换，它将资本近似域 $[k_{\\min}, k_{\\max}]$ 映射到切比雪夫多项式的定义域 $[-1, 1]$。给定系数 $a$，储蓄份额可以通过逆 logit（logistic）函数恢复，即 $s(k;a) = \\frac{1}{1+e^{-\\phi(k;a)}}$。\n\n投影法的核心是通过要求欧拉方程在一组 $n$ 个特定点（称为配点节点）上精确成立来确定系数 $a$。问题指定这些节点为切比雪夫多项式 $T_n(x)$ 的 $n$ 个根，并映射回资本域 $[k_{\\min}, k_{\\max}]$。这就为 $n$ 个未知系数创建了一个包含 $n$ 个非线性方程的方程组。对于每个配点节点 $k_i$，我们定义一个残差函数 $E_i(a)$：\n$$\nE_i(a) = u'(c_i) - \\beta u'(c'_i)(f'(k'_i) + 1 - \\delta) = 0\n$$\n其中 $c_i = c(k_i; a)$，$k'_i = k(k_i; a)$，以及 $c'_i = c(k'_i; a)$。目标是找到能求解方程组 $E(a) = 0$ 的向量 $a$。\n\n该方程组使用牛顿法求解，这是一种迭代算法，需要计算雅可比矩阵 $J(a) = \\frac{\\partial E}{\\partial a}(a)$。矩阵元素 $J_{ij}$ 是第 $i$ 个残差相对于第 $j$ 个系数的偏导数。系数的更新规则是：\n$$\na_{new} = a_{old} - J(a_{old})^{-1} E(a_{old})\n$$\n问题要求通过前向模式自动微分（AD）来计算雅可比矩阵。这是通过实现一个对偶数系统来完成的。一个对偶数 $z = v + \\dot{v}\\epsilon$ 有一个值部分 $v$ 和一个导数部分 $\\dot{v}$，其性质为 $\\epsilon^2 = 0$。所有的数学运算和函数都被重载，以便根据微积分法则传播导数。例如，对于一个函数 $h(z)$，我们有 $h(v + \\dot{v}\\epsilon) = h(v) + h'(v)\\dot{v}\\epsilon$。为了计算雅可比矩阵的第 $j$ 列，我们将系数向量初始化为 $a_k = a_k^{\\text{val}} + \\delta_{kj}\\epsilon$（其中 $\\delta_{kj}$ 是克罗内克 δ），然后计算整个残差向量 $E$。第 $i$ 个结果对偶数的导数部分 $\\dot{E_i}$ 正是雅可比矩阵的元素 $J_{ij}$。\n\n牛顿法辅以回溯线搜索以确保稳健收敛。如果一个完整的牛顿步没有减小残差向量的范数，步长将被逐步减小。求解器会一直迭代，直到残差向量的无穷范数低于指定的容差 $\\varepsilon = 10^{-8}$。\n\n一旦找到最优系数向量 $a^*$，就会在一个横跨近似区间 $[k_{\\min}, k_{\\max}]$ 的 $M=80$ 个点的细网格上，通过计算最大绝对欧拉方程残差来评估近似的质量。该值作为每个参数集的最终可报告指标。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\n# ---- Automatic Differentiation: Dual Number Implementation ----\nclass Dual:\n    \"\"\"\n    A class for forward-mode automatic differentiation.\n    A Dual number z = val + der * epsilon, where epsilon^2 = 0.\n    \"\"\"\n    def __init__(self, val, der=0.0):\n        self.val = val\n        self.der = der\n\n    def __add__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val + other.val, self.der + other.der)\n        return Dual(self.val + other, self.der)\n\n    def __radd__(self, other):\n        return self.__add__(other)\n\n    def __sub__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val - other.val, self.der - other.der)\n        return Dual(self.val - other, self.der)\n\n    def __rsub__(self, other):\n        return Dual(other - self.val, -self.der)\n\n    def __mul__(self, other):\n        if isinstance(other, Dual):\n            return Dual(self.val * other.val, self.der * other.val + self.val * other.der)\n        return Dual(self.val * other, self.der * other)\n\n    def __rmul__(self, other):\n        return self.__mul__(other)\n\n    def __truediv__(self, other):\n        if isinstance(other, Dual):\n            val = self.val / other.val\n            der = (self.der * other.val - self.val * other.der) / (other.val**2)\n            return Dual(val, der)\n        return Dual(self.val / other, self.der / other)\n\n    def __rtruediv__(self, other):\n        val = other / self.val\n        der = (-other * self.der) / (self.val**2)\n        return Dual(val, der)\n\n    def __pow__(self, power):\n        val = self.val ** power\n        der = power * (self.val ** (power - 1)) * self.der\n        return Dual(val, der)\n\n    def __neg__(self):\n        return Dual(-self.val, -self.der)\n\n    def __repr__(self):\n        return f\"Dual(val={self.val}, der={self.der})\"\n\ndef dual_exp(d):\n    if isinstance(d, Dual):\n        val = np.exp(d.val)\n        return Dual(val, val * d.der)\n    return np.exp(d)\n\ndef dual_pow(base, exp):\n    if isinstance(base, Dual):\n        return base ** exp\n    return base ** exp\n\n\n# ---- Model and Numerical Method Implementation ----\n\ndef chebyshev_poly_vals(x, n):\n    \"\"\"Evaluates the first n Chebyshev polynomials T_0, ..., T_{n-1} at x.\"\"\"\n    if n == 0:\n        return []\n    \n    T = [1.0, x] if not isinstance(x, Dual) else [Dual(1.0), x]\n    \n    for _ in range(n - 2):\n        T.append(2.0 * x * T[-1] - T[-2])\n    return T[:n]\n\ndef evaluate_policy(k, coeffs, params):\n    \"\"\"\n    Given capital k and coefficients a, computes c and k'.\n    This function handles both float and Dual types.\n    \"\"\"\n    alpha, _, delta, _, A, k_min, k_max, n = params\n    \n    is_dual = isinstance(coeffs[0], Dual) or isinstance(k, Dual)\n\n    # 1. Map k to x in [-1, 1]\n    x = (2.0 * k - (k_min + k_max)) / (k_max - k_min)\n\n    # 2. Evaluate Chebyshev basis\n    T_vals = chebyshev_poly_vals(x, n)\n    \n    # 3. Compute logit of savings share phi = sum(a_j * T_j(x))\n    phi = Dual(0.0) if is_dual else 0.0\n    for i in range(n):\n        phi += coeffs[i] * T_vals[i]\n\n    # 4. Compute savings share s = 1 / (1 + exp(-phi))\n    s = 1.0 / (1.0 + dual_exp(-phi))\n\n    # 5. Compute resources R(k), next-period capital k', and consumption c\n    R_k = A * dual_pow(k, alpha) + (1.0 - delta) * k\n    k_prime = s * R_k\n    c = (1.0 - s) * R_k\n\n    return c, k_prime\n\ndef calculate_residuals(coeffs, k_nodes, params):\n    \"\"\"\n    Calculates the Euler equation residuals at the given capital nodes.\n    Handles both float and Dual coefficients.\n    \"\"\"\n    alpha, beta, delta, gamma, A, _, _, _ = params\n    is_dual_input = isinstance(coeffs[0], Dual)\n    residuals = []\n\n    for k_node in k_nodes:\n        # Get c and k' at the current node k\n        c, k_prime = evaluate_policy(k_node, coeffs, params)\n        \n        # Get c' at the future capital level k'\n        c_prime, _ = evaluate_policy(k_prime, coeffs, params)\n\n        # Marginal utility and marginal product\n        u_prime_c = dual_pow(c, -gamma)\n        u_prime_c_prime = dual_pow(c_prime, -gamma)\n        f_prime_k_prime = alpha * A * dual_pow(k_prime, alpha - 1)\n        \n        # Euler residual\n        res = u_prime_c - beta * u_prime_c_prime * (f_prime_k_prime + 1.0 - delta)\n        residuals.append(res)\n    \n    if not is_dual_input:\n        return np.array([r for r in residuals])\n    return residuals\n\ndef solve_for_case(case_params):\n    \"\"\"\n    Solves the model for a single set of parameters.\n    \"\"\"\n    alpha, beta, delta, gamma, A = case_params\n    n, M, tol, max_iter = 7, 80, 1e-8, 50\n\n    # 1. Steady state capital\n    k_ss_numerator = alpha * A\n    k_ss_denominator = 1.0 / beta - 1.0 + delta\n    k_ss = (k_ss_numerator / k_ss_denominator) ** (1.0 / (1.0 - alpha))\n\n    # 2. Grid and state space\n    k_min, k_max = 0.7 * k_ss, 1.3 * k_ss\n    params = (alpha, beta, delta, gamma, A, k_min, k_max, n)\n    \n    # Collocation nodes (zeros of T_n)\n    chebyshev_zeros = np.cos((2 * np.arange(1, n + 1) - 1) * np.pi / (2 * n))\n    k_nodes = (k_min + k_max) / 2.0 + (k_max - k_min) / 2.0 * chebyshev_zeros\n    \n    # 3. Initial guess for coefficients 'a'\n    R_k_ss = A * k_ss**alpha + (1.0 - delta) * k_ss\n    s_ss = k_ss / R_k_ss\n    a = np.zeros(n)\n    a[0] = np.log(s_ss / (1.0 - s_ss))\n\n    # 4. Newton's method solver\n    for i in range(max_iter):\n        # Calculate residuals R(a)\n        R_val = calculate_residuals(a, k_nodes, params)\n        \n        res_norm = np.linalg.norm(R_val, np.inf)\n        if res_norm  tol:\n            break\n\n        # Calculate Jacobian J(a) using Automatic Differentiation\n        J = np.zeros((n, n))\n        for j in range(n):\n            a_dual = [Dual(val, 1.0 if idx == j else 0.0) for idx, val in enumerate(a)]\n            R_dual = calculate_residuals(a_dual, k_nodes, params)\n            J[:, j] = [res.der for res in R_dual]\n        \n        # Solve Newton step using least squares for robustness\n        delta_a = np.linalg.lstsq(J, -R_val, rcond=None)[0]\n        \n        # Backtracking line search\n        lambda_ = 1.0\n        for _ in range(10): # At most 10 backtracking steps\n            a_new = a + lambda_ * delta_a\n            R_new = calculate_residuals(a_new, k_nodes, params)\n            if np.linalg.norm(R_new, np.inf)  res_norm:\n                a = a_new\n                break\n            lambda_ *= 0.5\n        else: # If line search fails, take the small step and hope for the best\n            a = a + lambda_ * delta_a\n\n    # 5. Evaluate solution quality on a fine grid\n    eval_grid = np.linspace(k_min, k_max, M)\n    final_residuals = calculate_residuals(a, eval_grid, params)\n    max_abs_residual = np.max(np.abs(final_residuals))\n    \n    return max_abs_residual\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.33, 0.96, 0.08, 2.0, 1.0),   # Case A (baseline)\n        (0.36, 0.99, 0.025, 2.0, 1.0),  # Case B (patient)\n        (0.40, 0.95, 0.15, 3.0, 1.0),   # Case C (high depreciation and risk aversion)\n        (0.33, 0.97, 0.08, 1.0, 1.0),   # Case D (log utility)\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_for_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2422824"}, {"introduction": "现实世界中的经济模型几乎总是包含不确定性。在这个最后的练习中，我们将把之前构建求解器的技能扩展到一个随机环境中，模型中的经济主体需要面对未来的不确定性。([@problem_id:2422848])\n\n求解随机模型需要计算期望值，这通常没有解析解，因此我们必须使用数值积分（numerical quadrature）进行近似。本练习的挑战在于，模型中的生产率冲击遵循一个非标准的双峰分布（bimodal distribution），这将迫使我们思考如何选择和实施恰当的积分方案来准确计算期望。通过对比一个简化的“天真”方法和一个更精确的“混合校正”方法，本练习突显了数值积分方法对解的准确性的关键影响。这项实践将加深你对如何在动态模型中处理不确定性的理解，并展示模型假设（如冲击的分布）如何直接影响数值实现。", "problem": "考虑一个真实商业周期（RBC）经济，其劳动供给无弹性，除了生产率之外资本是唯一的状态变量，采用幂效用和柯布-道格拉斯生产函数。生产率是乘性的和随机的。贝尔曼公式导出的一阶最优性条件可以概括为欧拉方程和资源约束。令 $k_t$ 表示资本，$s_t$ 表示生产率的对数，$z_t = \\exp(s_t)$ 表示生产率。偏好由 $u(c) = \\frac{c^{1-\\gamma}}{1-\\gamma}$ 给出，其中风险厌恶参数 $\\gamma \\gt 0$，生产遵循 $y_t = z_t k_t^{\\alpha}$，资本折旧率为 $\\delta \\in (0,1)$，资本份额为 $\\alpha \\in (0,1)$。欧拉方程和资源约束为：\n$$\nu'(c_t) = \\beta \\mathbb{E}\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right],\n\\quad\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t,\n$$\n其中 $\\beta \\in (0,1)$ 是折扣因子，期望是关于生产率的运动定律来计算的。\n\n与标准形式不同，假设 $s_t$ 是独立同分布（i.i.d.）的，服从双峰正态混合分布：\n$$\ns_t \\sim p \\cdot \\mathcal{N}(\\mu_1,\\sigma_1^2) + (1-p)\\cdot \\mathcal{N}(\\mu_2,\\sigma_2^2),\n$$\n其中混合权重 $p \\in (0,1)$，分量参数为 $\\mu_1,\\mu_2 \\in \\mathbb{R}$ 和 $\\sigma_1,\\sigma_2 \\gt 0$。该过程随时间是独立同分布的。\n\n您的任务是为最优储蓄率策略 $\\phi(k,s) \\in (0,1)$ 构建一个投影法解，该策略由以下公式定义：\n$$\nk' = \\phi(k,s)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n\\quad\nc = \\left(1-\\phi(k,s)\\right)\\left(z k^{\\alpha} + (1-\\delta)k\\right),\n$$\n使用 $(k,s)$ 上的张量积切比雪夫多项式基，并通过配点法最小化欧拉方程残差。在 $(k,s)$ 处的欧拉残差为\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv u'(c(k,s;\\theta)) - \\beta\\, \\mathbb{E}\\left[u'(c'(k,s;\\theta,s'))\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right],\n$$\n其中 $\\theta$ 是基系数，$k' = \\phi(k,s;\\theta)\\left(\\exp(s)k^{\\alpha} + (1-\\delta)k\\right)$，以及 $c' = \\left(1-\\phi(k',s';\\theta)\\right)\\left(\\exp(s')k'^{\\alpha} + (1-\\delta)k'\\right)$。\n\n为了计算期望，请使用高斯-埃尔米特求积法（阶数如下文指定）。考虑两种关于 $s'$ 分布的求积方案：\n- 一种朴素的单正态方案，该方案通过一个均值和方差与混合分布相匹配的单一正态分布 $\\mathcal{N}(\\mu_{\\text{mix}},\\sigma_{\\text{mix}}^2)$ 来近似混合分布。在此近似下，使用高斯-埃尔米特求积法，通过变量替换 $s' = \\mu_{\\text{mix}} + \\sqrt{2}\\,\\sigma_{\\text{mix}} x$ 并相应调整权重来计算 $\\mathbb{E}[g(s')]$。\n- 一种混合校正方案，该方案将 $\\mathbb{E}[g(s')]$ 计算为在 $\\mathcal{N}(\\mu_1,\\sigma_1^2)$ 下的高斯-埃尔米特求积结果乘以 $p$，加上在 $\\mathcal{N}(\\mu_2,\\sigma_2^2)$ 下的高斯-埃尔米特求积结果乘以 $(1-p)$。\n\n您必须：\n- 将投影基指定为 $k$ 中最高次数为 $d_k$ 和 $s$ 中最高次数为 $d_s$ 的切比雪夫多项式的张量积。在计算切比雪夫多项式之前，将 $k$ 和 $s$ 的定义域仿射映射到 $[-1,1]$。使用 $d_k = 3$ 和 $d_s = 2$。\n- 将策略参数化为 $\\phi(k,s;\\theta) = \\sigma\\!\\left(B(k,s)^{\\top}\\theta\\right)$，其中 $B(k,s)$ 是基向量，$\\sigma(\\cdot)$ 是映射到 $(0,1)$ 的 logistic sigmoid 函数。这对所有 $(k,s)$ 强制了可行性 $c \\in (0, z k^{\\alpha} + (1-\\delta)k)$。\n- 选择一个矩形配点网格，作为 $k$ 和 $s$ 中大小分别为 $N_k=7$ 和 $N_s=5$ 的切比雪夫节点的张量积。\n- 在混合分布所蕴含的生产率无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 下，计算确定性稳态资本 $k^{\\star}$，并将 $k$ 的定义域设置为 $[0.75\\,k^{\\star}, 1.25\\,k^{\\star}]$。将 $s$ 的定义域设置为 $[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n- 通过对配点节点上的欧拉残差进行非线性最小二乘求解基系数 $\\theta$。执行此操作两次：一次在残差定义中使用朴素单正态求积法，另一次使用混合校正求积法。\n- 在一个大小为 $N_k^{\\text{val}}=13$ 乘以 $N_s^{\\text{val}}=9$ 的更精细的矩形网格（映射到相同定义域的切比雪夫节点）上验证每个解，计算使用真实的混合校正求积法评估的欧拉残差的上确界范数。\n\n使用以下固定的结构参数：$\\alpha = 0.33$，$\\beta = 0.96$，$\\delta = 0.08$，$\\gamma = 2.0$。对期望使用阶数为 $N_q = 7$ 的高斯-埃尔米特求积法。\n\n测试套件。针对以下三种独立情况求解问题（所有其他参数如上所述）：\n- 情况A（平衡双峰性）：$p = 0.5$, $\\mu_1 = -0.1$, $\\sigma_1 = 0.05$, $\\mu_2 = 0.1$, $\\sigma_2 = 0.05$。\n- 情况B（非对称且更分离）：$p = 0.7$, $\\mu_1 = -0.2$, $\\sigma_1 = 0.08$, $\\mu_2 = 0.2$, $\\sigma_2 = 0.08$。\n- 情况C（退化为单峰）：$p = 0.4$, $\\mu_1 = 0.0$, $\\sigma_1 = 0.07$, $\\mu_2 = 0.0$, $\\sigma_2 = 0.07$。\n\n对于每种情况，在两种求积方案下求解策略后，在验证网格上计算：\n- $r_{\\text{mix}}$：使用混合校正策略，并用混合校正求积法计算其欧拉残差的上确界范数。\n- $r_{\\text{naive}\\to \\text{true}}$：使用朴素求积策略，并用混合校正求积法计算其欧拉残差的上确界范数。\n- $\\Delta r \\equiv r_{\\text{naive}\\to \\text{true}} - r_{\\text{mix}}$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，结果顺序如下：\n$$\n\\left[r_{\\text{mix}}^{(A)},\\; r_{\\text{naive}\\to \\text{true}}^{(A)},\\; \\Delta r^{(A)},\\; r_{\\text{mix}}^{(B)},\\; r_{\\text{naive}\\to \\text{true}}^{(B)},\\; \\Delta r^{(B)},\\; r_{\\text{mix}}^{(C)},\\; r_{\\text{naive}\\to \\text{true}}^{(C)},\\; \\Delta r^{(C)}\\right].\n$$\n所有数字都是无单位的实数值。不涉及角度或百分比。\n\n最终答案必须是一个完整的、可运行的程序，该程序实现了上述规范并按要求格式精确打印一行。不需要任何用户输入。", "solution": "所提出的问题是计算经济学中一个适定性（well-posed）的练习，要求应用投影法来求解一个动态随机一般均衡模型。其参数定义清晰，其科学基础在真实商业周期理论框架内是健全的，并且指定的数值方法是标准的并且适合该任务。因此，该问题是有效的，并将构建一个解。\n\n目标是为一个随机增长模型中的最优消费-储蓄策略找到一个近似解。经济的动态由跨期欧拉方程决定，该方程将牺牲一单位当前消费的边际效用成本与由此产生的未来消费的期望折现边际效用收益相等同。经济的状态由资本存量 $k$ 和生产率的对数 $s$ 描述。\n\n控制性的函数方程是欧拉方程：\n$$\nu'(c_t) = \\beta \\mathbb{E}_t\\left[u'(c_{t+1})\\left(\\alpha z_{t+1} k_{t+1}^{\\alpha-1} + 1 - \\delta\\right)\\right]\n$$\n其中 $u'(c) = c^{-\\gamma}$ 是消费的边际效用，$\\beta$ 是折扣因子，$\\alpha$ 是生产中的资本份额，$\\delta$ 是资本折旧率，以及 $z_{t+1} = \\exp(s_{t+1})$ 是未来的生产率水平。期望 $\\mathbb{E}_t[\\cdot]$ 是对未来生产率冲击 $s_{t+1}$ 的分布计算的。资本的运动定律由资源约束决定，$c_t + k_{t+1} = z_t k_t^{\\alpha} + (1-\\delta)k_t$。\n\n问题的核心是策略函数——消费 $c(k,s)$ 和下一期资本 $k'(k,s)$——没有解析解。因此，我们采用数值逼近的方法。\n\n**1. 策略函数逼近**\n\n我们逼近最优储蓄率策略 $\\phi(k,s)$，它决定了可用资源中用于储蓄的比例。下一期资本和当前消费的策略函数则为：\n$$\nk'(k,s) = \\phi(k,s) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n$$\nc(k,s) = (1-\\phi(k,s)) \\left( \\exp(s) k^{\\alpha} + (1-\\delta)k \\right)\n$$\n储蓄率必须位于区间 $(0,1)$ 内，以确保消费和投资均为正。我们通过使用 logistic sigmoid 函数 $\\sigma(x) = (1+e^{-x})^{-1}$ 来参数化策略，从而强制执行此约束：\n$$\n\\phi(k,s; \\theta) = \\sigma\\left(\\sum_{i=0}^{d_k} \\sum_{j=0}^{d_s} \\theta_{ij} T_i(\\hat{k}) T_j(\\hat{s})\\right)\n$$\n这里，$\\{T_i\\}$ 和 $\\{T_j\\}$ 是第一类切比雪夫多项式。状态变量 $(k,s)$ 被线性映射到定义多项式的规范域 $[-1,1]$ 上的 $(\\hat{k}, \\hat{s})$。系数集 $\\{\\theta_{ij}\\}$ 是待确定的参数。次数被指定为 $d_k=3$ 和 $d_s=2$，这导致了 $(3+1)(2+1)=12$ 个基函数和相应的系数 $\\theta$。\n\n**2. 状态空间与配点网格**\n\n逼近是在状态变量的一个有界域上进行的。\n- 资本 $k$ 的域以确定性稳态资本存量 $k^{\\star}$ 为中心。这个稳态是通过假设生产率固定在其无条件均值 $\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)]$ 并且所有状态变量都恒定来找到的。求解稳态欧拉方程 $1 = \\beta (\\alpha \\mathbb{E}[z] (k^{\\star})^{\\alpha-1} + 1 - \\delta)$ 可得：\n$$\nk^{\\star} = \\left( \\frac{\\alpha \\mathbb{E}[z]}{\\frac{1}{\\beta} - 1 + \\delta} \\right)^{\\frac{1}{1-\\alpha}}\n$$\n期望 $\\mathbb{E}[z]$ 是根据为 $s$ 指定的正态混合分布计算的：\n$$\n\\mathbb{E}[z] = \\mathbb{E}[\\exp(s)] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[\\exp(s)] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[\\exp(s)] = p e^{\\mu_1 + \\sigma_1^2/2} + (1-p) e^{\\mu_2 + \\sigma_2^2/2}\n$$\n然后将 $k$ 的域设置为 $[0.75 k^{\\star}, 1.25 k^{\\star}]$。\n- 生产率冲击 $s$ 的域设置为覆盖其大部分概率质量：$[\\min(\\mu_1 - 3\\sigma_1, \\mu_2 - 3\\sigma_2), \\max(\\mu_1 + 3\\sigma_1, \\mu_2 + 3\\sigma_2)]$。\n\n为了求解系数 $\\theta$，我们使用配点法。我们在域内的一组离散点（配点节点）上强制执行欧拉方程。这些节点被选为切比雪夫多项式根的张量积，具体为一个 $N_k=7$ 个资本点和 $N_s=5$ 个对数生产率点的网格。\n\n**3. 欧拉方程残差与求解**\n\n逼近的策略函数 $\\phi(k,s;\\theta)$ 不会精确满足欧拉方程。我们将欧拉方程残差 $\\mathcal{R}(k,s;\\theta)$ 定义为方程左侧和右侧之间的差：\n$$\n\\mathcal{R}(k,s;\\theta) \\equiv c(k,s;\\theta)^{-\\gamma} - \\beta \\mathbb{E}\\left[c'(k,s;\\theta,s')^{-\\gamma}\\left(\\alpha \\exp(s') k'(k,s;\\theta)^{\\alpha-1} + 1-\\delta\\right)\\right]\n$$\n选择系数 $\\theta$ 以最小化配点节点集上的残差平方和。这是一个非线性最小二乘问题：$\\min_{\\theta} \\sum_{i,j} [\\mathcal{R}(k_i, s_j; \\theta)]^2$。\n\n**4. 期望的数值求积**\n\n一项核心任务是期望项的数值评估。问题要求比较两种方案，两者都基于 $N_q=7$ 点高斯-埃尔米特求积法。对于一个通用函数 $g(s')$，在正态分布 $s' \\sim \\mathcal{N}(\\mu, \\sigma^2)$ 下的期望近似为：\n$$\n\\mathbb{E}[g(s')] = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} g(\\mu + \\sqrt{2}\\sigma x) e^{-x^2} dx \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{j=1}^{N_q} w_j g(\\mu + \\sqrt{2}\\sigma x_j)\n$$\n其中 $(x_j, w_j)$ 是标准的高斯-埃尔米特求积节点和权重。\n\n- **朴素单正态方案：** $s'$ 的双峰混合分布由一个具有匹配均值和方差的单正态分布 $\\mathcal{N}(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}}^2)$ 来近似。\n    - $\\mu_{\\text{mix}} = p\\mu_1 + (1-p)\\mu_2$\n    - $\\sigma_{\\text{mix}}^2 = [p\\sigma_1^2 + (1-p)\\sigma_2^2] + p(1-p)(\\mu_1-\\mu_2)^2$\n    然后使用上述公式和参数 $(\\mu_{\\text{mix}}, \\sigma_{\\text{mix}})$ 计算期望。\n\n- **混合校正方案：** 使用混合分布的定义直接计算期望：\n    $$\n    \\mathbb{E}[g(s')] = p \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_1,\\sigma_1^2)}[g(s')] + (1-p) \\cdot \\mathbb{E}_{\\mathcal{N}(\\mu_2,\\sigma_2^2)}[g(s')]\n    $$\n    右侧的两个期望项中，每一项都使用其自身的高斯-埃尔米特求积法进行评估，一个以 $\\mu_1$ 为中心，尺度为 $\\sigma_1$，另一个以 $\\mu_2$ 为中心，尺度为 $\\sigma_2$。\n\n**5. 验证**\n\n我们得到两组系数：$\\theta_{\\text{naive}}$，通过使用朴素求积法求解得到；以及 $\\theta_{\\text{mix}}$，通过使用混合校正求积法求解得到。这些解的质量通过在更精细的验证网格（$N_k^{\\text{val}}=13 \\times N_s^{\\text{val}}=9$）上评估欧拉残差的上确界范数来评估。至关重要的是，对于两种策略，此验证残差都是使用精确的**混合校正求积法**计算的。此过程隔离了在求解阶段由朴素近似引入的误差。需要报告的量是：\n- $r_{\\text{mix}}$：策略 $\\phi(k,s;\\theta_{\\text{mix}})$ 的残差的上确界范数，作为我们的基准。\n- $r_{\\text{naive}\\to\\text{true}}$：策略 $\\phi(k,s;\\theta_{\\text{naive}})$ 的残差的上确界范数，显示了当被正确评估时朴素策略的误差。\n- $\\Delta r = r_{\\text{naive}\\to\\text{true}} - r_{\\text{mix}}$：可归因于朴素近似方法的超额误差。\n\n这个严谨的过程允许对这两种求积方案在此类模型中处理混合分布的性能进行量化比较。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import least_squares\nfrom scipy.special import expit, logit\nfrom numpy.polynomial import chebyshev, hermite\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the results.\n    \"\"\"\n    # Fixed structural parameters\n    alpha = 0.33\n    beta = 0.96\n    delta = 0.08\n    gamma = 2.0\n\n    # Numerical approximation parameters\n    d_k = 3\n    d_s = 2\n    N_k = 7\n    N_s = 5\n    N_q = 7\n    N_k_val = 13\n    N_s_val = 9\n\n    test_cases = [\n        # Case A: balanced bimodality\n        {'p': 0.5, 'mu1': -0.1, 'sigma1': 0.05, 'mu2': 0.1, 'sigma2': 0.05},\n        # Case B: asymmetric and more separated\n        {'p': 0.7, 'mu1': -0.2, 'sigma1': 0.08, 'mu2': 0.2, 'sigma2': 0.08},\n        # Case C: degenerate to unimodal\n        {'p': 0.4, 'mu1': 0.0, 'sigma1': 0.07, 'mu2': 0.0, 'sigma2': 0.07},\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        params = {\n            'alpha': alpha, 'beta': beta, 'delta': delta, 'gamma': gamma,\n            **case_params\n        }\n        \n        # Unpack degrees and grid sizes\n        degrees = (d_k, d_s)\n        collocation_grid_sizes = (N_k, N_s)\n        validation_grid_sizes = (N_k_val, N_s_val)\n\n        r_mix, r_naive_to_true, delta_r = solve_case(\n            params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q\n        )\n        all_results.extend([r_mix, r_naive_to_true, delta_r])\n\n    print(f\"[{','.join(map(str, all_results))}]\")\n\ndef solve_case(params, degrees, collocation_grid_sizes, validation_grid_sizes, N_q):\n    \"\"\"\n    Solves for and validates policies for a single parameter case.\n    \"\"\"\n    # 1. State-space domain\n    k_domain, s_domain = calculate_domains(params)\n\n    # 2. Quadrature nodes and weights for expectation\n    # hermgauss returns nodes/weights for integral with weight e^(-x^2)\n    q_nodes, q_weights = hermite.hermgauss(N_q)\n    q_weights /= np.sqrt(np.pi)  # Adjust for standard normal probability measure\n    \n    # 3. Collocation grid\n    collocation_grid = create_chebyshev_grid(collocation_grid_sizes, k_domain, s_domain)\n\n    # 4. Initial guess for theta (based on deterministic steady state)\n    theta0 = get_initial_theta(params, degrees, k_domain)\n\n    # Arguments for the solver\n    solver_args = (params, degrees, k_domain, s_domain, collocation_grid, q_nodes, q_weights)\n\n    # 5. Solve for theta_mix\n    res_mix = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'mixture_correct'),\n        method='lm', jac='2-point'\n    )\n    theta_mix = res_mix.x\n\n    # 6. Solve for theta_naive\n    res_naive = least_squares(\n        euler_residuals, theta0, args=(*solver_args, 'naive'),\n        method='lm', jac='2-point'\n    )\n    theta_naive = res_naive.x\n\n    # 7. Validation\n    validation_grid = create_chebyshev_grid(validation_grid_sizes, k_domain, s_domain)\n    val_args = (params, degrees, k_domain, s_domain, validation_grid, q_nodes, q_weights)\n\n    # Evaluate mixture-correct policy with mixture-correct quadrature\n    residuals_mix = euler_residuals(theta_mix, *val_args, 'mixture_correct')\n    r_mix = np.max(np.abs(residuals_mix))\n\n    # Evaluate naive policy with mixture-correct quadrature\n    residuals_naive_true = euler_residuals(theta_naive, *val_args, 'mixture_correct')\n    r_naive_to_true = np.max(np.abs(residuals_naive_true))\n\n    delta_r = r_naive_to_true - r_mix\n\n    return r_mix, r_naive_to_true, delta_r\n\ndef calculate_domains(params):\n    \"\"\"Calculates the state-space domains for k and s.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    # Unconditional mean of productivity z = exp(s)\n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    \n    # Deterministic steady-state capital k_star\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    k_domain = [0.75 * k_star, 1.25 * k_star]\n    \n    # Domain for s\n    s_min = min(mu1 - 3 * s1, mu2 - 3 * s2)\n    s_max = max(mu1 + 3 * s1, mu2 + 3 * s2)\n    s_domain = [s_min, s_max]\n    \n    return k_domain, s_domain\n\ndef get_initial_theta(params, degrees, k_domain):\n    \"\"\"Computes an informed initial guess for theta.\"\"\"\n    p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n    alpha, beta, delta = params['alpha'], params['beta'], params['delta']\n    \n    expected_z = p * np.exp(mu1 + s1**2 / 2) + (1 - p) * np.exp(mu2 + s2**2 / 2)\n    k_star = ((alpha * expected_z) / (1 / beta - 1 + delta))**(1 / (1 - alpha))\n    y_star = expected_z * k_star**alpha\n    phi_star = k_star / (y_star + (1 - delta) * k_star)\n    \n    d_k, d_s = degrees\n    num_coeffs = (d_k + 1) * (d_s + 1)\n    theta0 = np.zeros(num_coeffs)\n    theta0[0] = logit(phi_star)\n    return theta0\n\ndef cheb_transform(x, domain):\n    \"\"\"Maps points from a domain to [-1, 1].\"\"\"\n    return 2 * (x - domain[0]) / (domain[1] - domain[0]) - 1\n\ndef cheb_basis_tensor(k_hat, s_hat, degrees):\n    \"\"\"Computes a tensor product Chebyshev basis matrix.\"\"\"\n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat, d_k)\n    basis_s = chebyshev.chebvander(s_hat, d_s)\n    # Reshape for broadcasting and then combine\n    # B[i, j, :] is the basis vector for grid point (i, j)\n    B = basis_k[:, np.newaxis, :] * basis_s[np.newaxis, :, :]\n    # Reshape B to be (Nk * Ns, N_coeffs)\n    return B.reshape(-1, (d_k + 1) * (d_s + 1))\n\n\ndef create_chebyshev_grid(grid_sizes, k_domain, s_domain):\n    \"\"\"Creates a tensor product grid of Chebyshev nodes.\"\"\"\n    N_k, N_s = grid_sizes\n    # Use chebpts1 for nodes including endpoints - common in collocation\n    k_nodes_hat = chebyshev.chebpts1(N_k) # in [-1, 1]\n    s_nodes_hat = chebyshev.chebpts1(N_s) # in [-1, 1]\n    \n    k_grid = (k_nodes_hat + 1) / 2 * (k_domain[1] - k_domain[0]) + k_domain[0]\n    s_grid = (s_nodes_hat + 1) / 2 * (s_domain[1] - s_domain[0]) + s_domain[0]\n    \n    return k_grid, s_grid\n\ndef get_policy(k, s, theta, params, degrees, k_domain, s_domain):\n    \"\"\"Computes policy (phi), consumption (c), and next-period capital (k_prime).\"\"\"\n    k_hat = cheb_transform(k, k_domain)\n    s_hat = cheb_transform(s, s_domain)\n    \n    d_k, d_s = degrees\n    basis_k = chebyshev.chebvander(k_hat.flatten(), d_k)\n    basis_s = chebyshev.chebvander(s_hat.flatten(), d_s)\n    \n    # Manual tensor product broadcasting\n    flat_basis_tensor = (basis_k[:, :, np.newaxis] * basis_s[:, np.newaxis, :]).reshape(len(k.flatten()), -1)\n    \n    # Savings rate\n    phi = expit(flat_basis_tensor @ theta).reshape(k.shape)\n\n    z = np.exp(s)\n    resources = z * k**params['alpha'] + (1 - params['delta']) * k\n    \n    c = (1 - phi) * resources\n    k_prime = phi * resources\n    \n    return c, k_prime\n\ndef euler_residuals(theta, params, degrees, k_domain, s_domain, grid, q_nodes, q_weights, quadrature_scheme):\n    \"\"\"\n    Computes the Euler equation residuals over a grid.\n    Vectorized for efficiency.\n    \"\"\"\n    k_grid, s_grid = grid\n    K, S = np.meshgrid(k_grid, s_grid, indexing='ij')\n\n    alpha, beta, delta, gamma = params['alpha'], params['beta'], params['delta'], params['gamma']\n\n    # Current period values\n    c_t, k_prime = get_policy(K, S, theta, params, degrees, k_domain, s_domain)\n    marginal_utility_t = c_t**(-gamma)\n\n    # Expected future values\n    def get_integrand(s_prime_nodes):\n        # s_prime_nodes is a vector of quadrature points for s'\n        # k_prime is an Nk x Ns matrix\n        # Need to evaluate policy at all (k_prime, s_prime) pairs\n        num_q_nodes = len(s_prime_nodes)\n        \n        # Reshape for broadcasting\n        k_prime_flat = k_prime.flatten() # (Nk*Ns)\n        k_prime_rep = np.tile(k_prime_flat, (num_q_nodes, 1)).T # (Nk*Ns, Nq)\n        s_prime_rep = np.tile(s_prime_nodes, (len(k_prime_flat), 1)) # (Nk*Ns, Nq)\n        \n        c_prime, _ = get_policy(k_prime_rep, s_prime_rep, theta, params, degrees, k_domain, s_domain)\n        \n        marginal_utility_prime = c_prime**(-gamma)\n        \n        mpk_prime = alpha * np.exp(s_prime_rep) * k_prime_rep**(alpha - 1) + (1 - delta)\n        \n        return (marginal_utility_prime * mpk_prime).reshape(K.shape[0], K.shape[1], -1)\n\n    if quadrature_scheme == 'mixture_correct':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        \n        s_prime_nodes1 = mu1 + np.sqrt(2) * s1 * q_nodes\n        integrand1 = get_integrand(s_prime_nodes1)\n        E1 = np.sum(integrand1 * q_weights, axis=2)\n        \n        s_prime_nodes2 = mu2 + np.sqrt(2) * s2 * q_nodes\n        integrand2 = get_integrand(s_prime_nodes2)\n        E2 = np.sum(integrand2 * q_weights, axis=2)\n        \n        E_term = p * E1 + (1 - p) * E2\n        \n    elif quadrature_scheme == 'naive':\n        p, mu1, s1, mu2, s2 = params['p'], params['mu1'], params['sigma1'], params['mu2'], params['sigma2']\n        mu_mix = p * mu1 + (1 - p) * mu2\n        var_mix = p * s1**2 + (1 - p) * s2**2 + p * (1 - p) * (mu1 - mu2)**2\n        s_mix = np.sqrt(var_mix)\n        \n        s_prime_nodes_mix = mu_mix + np.sqrt(2) * s_mix * q_nodes\n        integrand_mix = get_integrand(s_prime_nodes_mix)\n        E_term = np.sum(integrand_mix * q_weights, axis=2)\n\n    else:\n        raise ValueError(\"Invalid quadrature scheme.\")\n\n    residuals = marginal_utility_t - beta * E_term\n    return residuals.flatten()\n\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2422848"}]}