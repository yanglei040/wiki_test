{"hands_on_practices": [{"introduction": "宏观经济模型的结果往往依赖于贴现因子（$\\beta$）和折旧率（$\\delta$）等关键参数。理解经济的长期均衡（或稳态）如何随这些参数变化，对于政策分析至关重要。本练习将通过参数扫描——即为许多不同的参数组合计算结果——来展示这如何构成一个天然的“易并行”任务，因为每个参数组合的计算都是完全独立的 [@problem_id:2390013]。", "problem": "考虑一个确定性的、无限期界的代表性代理人经济体，其中单一商品可用于消费和投资。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。代表性家庭对消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 的偏好由期望贴现总和 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$ 给出，其中 $\\beta \\in (0,1)$ 是主观贴现因子，$u(\\cdot)$ 是一个严格递增、严格凹且二次连续可微的效用函数。假设效用函数为恒定相对风险厌恶 (CRRA) 效用函数，其系数为 $\\sigma > 0$，即当 $\\sigma \\neq 1$ 时为 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$，当 $\\sigma = 1$ 时为 $u(c) = \\log c$。生产是竞争性的，由单一企业运营，采用柯布-道格拉斯生产技术 $y_t = A k_t^{\\alpha} n_t^{1-\\alpha}$，其中 $A = 1$，$\\alpha \\in (0,1)$，劳动供给为无弹性的 $n_t \\equiv 1$，物质资本为 $k_t$。资本以折旧率 $\\delta \\in [0,1]$ 进行折旧。竞争性要素价格等于边际产品：资本的租金率为 $r_t = \\alpha k_t^{\\alpha - 1}$，工资为 $w_t = (1 - \\alpha) k_t^{\\alpha}$。以人均计算，家庭的时期预算约束为 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$，其中 $k_{t+1} \\ge 0$ 且 $c_t \\ge 0$。假设没有人口增长或技术增长。\n\n仅从这些初始条件和定义出发，并仅使用第一性原理（例如家庭的跨期最优性条件和竞争均衡条件），在无外生增长的假设下，推导出作为参数 $\\alpha$、$\\beta$ 和 $\\delta$ 的函数的唯一正稳态资本存量 $K$ 的稳态条件。然后，实现一个程序，使用此稳态条件，在保持 $\\alpha$ 固定的情况下，为一组参数对 $(\\beta,\\delta)$ 计算 $K$。\n\n您的实现应利用每个 $(\\beta,\\delta)$ 对都可以独立于其他对进行评估这一事实，这使得该计算成为模拟中易于并行的问题的一个例子。然而，您的程序必须按顺序和确定性地执行，不需要任何用户输入。\n\n在所有计算中使用以下参数化设置：\n- 资本份额：$\\alpha = 0.36$。\n- 生产率：$A = 1$。\n- 劳动：$n_t \\equiv 1$。\n- 风险厌恶参数 $\\sigma$ 是任意的，但固定且严格为正；在上述假设下，您最终的稳态表达式不得依赖于 $\\sigma$。\n\n测试套件（为每对参数计算稳态资本存量 $K$）：\n- 情况 $1$：$(\\beta,\\delta) = (0.96,0.08)$。\n- 情况 $2$：$(\\beta,\\delta) = (0.96,0.00)$。\n- 情况 $3$：$(\\beta,\\delta) = (0.96,1.00)$。\n- 情况 $4$：$(\\beta,\\delta) = (0.99,0.08)$。\n- 情况 $5$：$(\\beta,\\delta) = (0.90,0.08)$。\n- 情况 $6$：$(\\beta,\\delta) = (0.99,0.01)$。\n- 情况 $7$：$(\\beta,\\delta) = (0.95,0.20)$。\n- 情况 $8$：$(\\beta,\\delta) = (0.999,0.50)$。\n\n科学真实性和可行性条件：\n- 对于有效的参数对，假设存在严格为正的稳态资本 $K > 0$ 的内部解。\n- 如果推导出的稳态条件对某个参数对意味着 $K$ 为非正值或未定义（例如，由于您推导的表达式中分母为非正值），您的程序应为该情况返回一个非数值 (Not-a-Number)。\n\n数值和输出要求：\n- 所有数值答案均表示为无单位的实数。\n- 将报告的每个稳态资本 $K$ 四舍五入到 6 位小数。\n- 您的程序应生成单行输出，其中包含测试套件的结果，按顺序排列，形式为方括号内以逗号分隔的列表，且无空格。例如：\"[k1,k2,k3,k4,k5,k6,k7,k8]\"。", "solution": "问题陈述经评估有效。这是现代宏观经济理论中一个标准的、适定的问题，具体来说是对新古典增长模型的分析。所有必需的参数、函数形式和均衡条件都已提供，不存在内部矛盾或科学不准确之处。我们开始进行推导。\n\n目标是为代表性代理人经济体推导出稳态资本存量，记为 $K$。此推导过程分三步：首先，建立家庭的跨期最优性条件（欧拉方程）；其次，施加所有的人均变量都恒定的稳态条件；第三，求解由此产生的代数方程以得到 $K$。\n\n首先，我们构建家庭的动态优化问题。家庭选择消费序列 $\\{c_t\\}_{t=0}^{\\infty}$ 和资本序列 $\\{k_{t+1}\\}_{t=0}^{\\infty}$ 来最大化其生命周期效用 $\\sum_{t=0}^{\\infty} \\beta^t u(c_t)$，并受制于一系列预算约束。时期 $t$ 的预算约束是 $c_t + k_{t+1} = (1 - \\delta) k_t + r_t k_t + w_t$。\n\n在竞争均衡中，要素价格等于其边际产品。给定柯布-道格拉斯生产函数 $y_t = k_t^{\\alpha}$（因为 $A=1$ 且 $n_t=1$），资本的租金率是 $r_t = \\frac{\\partial y_t}{\\partial k_t} = \\alpha k_t^{\\alpha-1}$，工资率是 $w_t = y_t - r_t k_t = k_t^\\alpha - (\\alpha k_t^{\\alpha-1})k_t = (1-\\alpha)k_t^\\alpha$。将这些代入家庭的预算约束，得到 $c_t + k_{t+1} = (1 - \\delta)k_t + (\\alpha k_t^{\\alpha-1})k_t + (1-\\alpha)k_t^\\alpha = (1 - \\delta)k_t + \\alpha k_t^\\alpha + (1 - \\alpha)k_t^\\alpha = k_t^\\alpha + (1 - \\delta)k_t$。这是经济体的总资源约束。\n\n家庭的问题可以用动态规划来解决。贝尔曼方程是：\n$$V(k_t) = \\max_{k_{t+1}} \\left\\{ u(k_t^\\alpha + (1-\\delta)k_t - k_{t+1}) + \\beta V(k_{t+1}) \\right\\}$$\n关于选择变量 $k_{t+1}$ 的一阶条件是：\n$$-u'(c_t) \\cdot 1 + \\beta V'(k_{t+1}) = 0 \\implies u'(c_t) = \\beta V'(k_{t+1})$$\n通过对贝尔曼方程关于状态变量 $k_t$ 求导得到的包络定理是：\n$$V'(k_t) = u'(c_t) \\left( \\frac{\\partial y_t}{\\partial k_t} + 1 - \\delta \\right) = u'(c_t) (\\alpha k_t^{\\alpha-1} + 1 - \\delta)$$\n将包络定理向前推一期得到：\n$$V'(k_{t+1}) = u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n将 $V'(k_{t+1})$ 的这个表达式代回一阶条件，得到欧拉方程：\n$$u'(c_t) = \\beta u'(c_{t+1}) (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n对于指定的恒定相对风险厌恶 (CRRA) 效用函数 $u(c) = \\frac{c^{1-\\sigma}}{1-\\sigma}$（或当 $\\sigma=1$ 时为 $u(c)=\\log c$），边际效用是 $u'(c) = c^{-\\sigma}$。欧拉方程变为：\n$$c_t^{-\\sigma} = \\beta c_{t+1}^{-\\sigma} (\\alpha k_{t+1}^{\\alpha-1} + 1 - \\delta)$$\n\n第二，我们施加稳态条件。在没有外生增长的稳态下，所有的人均变量随时间保持不变。因此，对于所有 $t$，$k_t = k_{t+1} = K$ 且 $c_t = c_{t+1} = C$。将这些条件应用于欧拉方程，我们得到：\n$$C^{-\\sigma} = \\beta C^{-\\sigma} (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n由于我们假设存在严格为正的消费 $C > 0$ 的内部解，我们可以将两边同除以 $C^{-\\sigma}$：\n$$1 = \\beta (\\alpha K^{\\alpha-1} + 1 - \\delta)$$\n这就是刻画稳态资本存量 $K$ 的基本条件。注意，风险厌恶参数 $\\sigma$ 已经消去，正如问题陈述所要求的那样。\n\n第三，我们求解这个代数方程以得到 $K$。\n$$\\frac{1}{\\beta} = \\alpha K^{\\alpha-1} + 1 - \\delta$$\n整理各项以分离出 $K$：\n$$\\alpha K^{\\alpha-1} = \\frac{1}{\\beta} - (1 - \\delta) = \\frac{1 - \\beta(1-\\delta)}{\\beta} = \\frac{1 - \\beta + \\beta\\delta}{\\beta}$$\n$$K^{\\alpha-1} = \\frac{1 - \\beta + \\beta\\delta}{\\alpha\\beta}$$\n为了求解 $K$，我们将两边同时取 $\\frac{1}{\\alpha-1}$ 次幂。这等价于取底数的倒数，然后取其 $\\frac{1}{1-\\alpha}$ 次幂：\n$$K = \\left( \\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta} \\right)^{\\frac{1}{1-\\alpha}}$$\n这就是唯一正稳态资本存量的最终表达式。\n\n在计算中，我们使用给定的固定参数 $\\alpha = 0.36$。因此，指数为 $\\frac{1}{1 - 0.36} = \\frac{1}{0.64} = 1.5625$。幂运算的底数是 $\\frac{\\alpha\\beta}{1 - \\beta + \\beta\\delta}$。为了使 $K$ 是一个正实数，底数必须为正。给定 $\\alpha \\in (0,1)$ 和 $\\beta \\in (0,1)$，分子 $\\alpha\\beta$ 总是正的。分母是 $(1-\\beta) + \\beta\\delta$。由于 $1-\\beta > 0$ 且 $\\beta\\delta \\ge 0$（对于 $\\delta \\in [0,1]$），分母总是严格为正。因此，对于测试套件中提供的所有有效参数对，稳态资本存量 $K$ 都是正且良定义的，预计不会出现非数值结果。\n\n实现将对每个指定的 $(\\beta, \\delta)$ 对应用此公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital stock for a neoclassical growth model\n    for a given set of parameters.\n    \"\"\"\n    \n    # Fixed parameters from the problem statement.\n    # Capital share in production.\n    alpha = 0.36\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple (beta, delta).\n    test_cases = [\n        (0.96, 0.08),   # Case 1\n        (0.96, 0.00),   # Case 2\n        (0.96, 1.00),   # Case 3\n        (0.99, 0.08),   # Case 4\n        (0.90, 0.08),   # Case 5\n        (0.99, 0.01),   # Case 6\n        (0.95, 0.20),   # Case 7\n        (0.999, 0.50),  # Case 8\n    ]\n\n    results = []\n    \n    # The exponent in the final expression for the steady-state capital stock K.\n    exponent = 1.0 / (1.0 - alpha)\n\n    # Iterate through each parameter set (beta, delta)\n    for beta, delta in test_cases:\n        # The steady-state capital stock K is given by the formula:\n        # K = ( (alpha * beta) / (1 - beta + beta * delta) ) ^ (1 / (1 - alpha))\n        \n        # Calculate the denominator of the base.\n        denominator = 1.0 - beta + beta * delta\n        \n        # As reasoned in the solution, the denominator for the given parameter ranges\n        # is always positive. Thus, we do not need to explicitly handle division by zero\n        # or non-positive bases.\n        \n        # Calculate the base of the exponentiation.\n        base = (alpha * beta) / denominator\n        \n        # Calculate the steady-state capital stock K.\n        k_steady_state = np.power(base, exponent)\n        \n        # Round the result to 6 decimal places as required.\n        result_rounded = round(k_steady_state, 6)\n        \n        results.append(result_rounded)\n\n    # Format the final output string as a comma-separated list in brackets.\n    # The map(str, ...) ensures each number is converted to a string before joining.\n    # No spaces are included between the elements, as per the output format requirement.\n    output_string = f\"[{','.join(map(str, results))}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_string)\n\n# Execute the main function.\nsolve()\n```", "id": "2390013"}, {"introduction": "银行挤兑等现象源于个体决策和战略互动，因此常使用基于主体的模型（Agent-Based Models）进行研究。由于结果依赖于随机的初始条件（如此处的储户恐慌阈值），我们需要进行大量独立的模拟（即“试验”）来理解诸如全面挤兑等事件发生的概率。这种蒙特卡洛模拟方法是“易并行”问题的典型范例 [@problem_id:2389979]。", "problem": "考虑以下简化的银行挤兑阈值模型。有 $N$ 位存款人，索引为 $i \\in \\{1,\\dots,N\\}$。每位存款人 $i$ 都有一个私有的恐慌阈值 $\\theta_i \\in [0,1]$，该阈值是从一个均值为 $m \\in (0,1)$、集中度参数为 $\\kappa > 0$ 的贝塔分布（Beta distribution）中独立同分布地抽取的。回顾一下，对于由形状参数 $\\alpha > 0$ 和 $\\beta > 0$ 参数化的贝塔分布，其均值等于 $\\alpha/(\\alpha+\\beta)$。因此，设定 $\\alpha = m \\kappa$ 和 $\\beta = (1-m)\\kappa$ 可以得到具有期望均值和集中度的贝塔分布。\n\n在任何时间点，如果当前关于将要提款的存款人比例的信念是 $f \\in [0,1]$，那么每位存款人 $i$ 都遵循一个阈值策略：当且仅当 $\\theta_i \\le f$ 时提款。这导出了一个总体的最优反应映射\n$$\nF_N(f) \\equiv \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\theta_i \\le f\\},\n$$\n这是在 $f$ 处评估的 $\\{\\theta_i\\}_{i=1}^N$ 的经验累积分布函数。从初始信念 $f_0 \\in [0,1]$ 开始，总体信念根据以下迭代方案进行更新\n$$\nf_{t+1} = F_N(f_t), \\quad t = 0,1,2,\\dots\n$$\n该过程会在有限步内收敛到一个满足 $f^\\star = F_N(f^\\star)$ 的不动点 $f^\\star$，因为 $F_N$ 将 $[0,1]$ 映射到离散网格 $\\{0,\\frac{1}{N},\\dots,\\frac{N}{N}\\}$ 上，并且是单调不减的。\n\n您的任务是编写一个完整的、可运行的程序，通过运行许多独立的试验来对该模型进行易并行（embarrassingly parallel）模拟。在每次试验中，从指定的贝塔分布中抽取一组新的 $\\{\\theta_i\\}_{i=1}^N$，从指定的 $f_0$ 开始迭代信念动态过程直到收敛到 $f^\\star$，记录最终比例 $f^\\star$，然后确定是否发生了“全面挤兑”事件，该事件定义为 $f^\\star \\ge 0.95$。所有试验都是独立的，可以在没有试验间通信的情况下进行处理。\n\n实现要求：\n- 使用带有固定种子的伪随机数生成器（PRNG），以确保可复现性，具体如以下测试套件中所指定。对贝塔分布使用参数化 $\\alpha = m \\kappa$ 和 $\\beta = (1-m)\\kappa$。\n- 收敛准则：因为 $F_N$ 映射到 $\\{0,\\frac{1}{N},\\dots,\\frac{N}{N}\\}$，所以更新直到 $f_{t+1} = f_t$ 精确成立。\n- 为了利用易并行结构，组织计算时应使各试验相互独立；跨试验的向量化计算是可接受的。\n\n测试套件。对于以下每个独立案例，计算发生全面挤兑的试验所占的比例，并以小数形式输出：\n- 案例 1：$N = 500$，试验次数 $T = 3000$，均值 $m = 0.60$，集中度 $\\kappa = 40$，初始信念 $f_0 = 0.20$，PRNG种子 $12345$。\n- 案例 2：$N = 500$，试验次数 $T = 3000$，均值 $m = 0.40$，集中度 $\\kappa = 40$，初始信念 $f_0 = 0.80$，PRNG种子 $67890$。\n- 案例 3：$N = 500$，试验次数 $T = 3000$，均值 $m = 0.50$，集中度 $\\kappa = 10$，初始信念 $f_0 = 0.50$，PRNG种子 $13579$。\n\n最终输出格式。您的程序应生成单行输出，其中包含与案例 1–3 对应的三个结果，格式为方括号括起来的逗号分隔列表，每个概率值四舍五入到恰好六位小数（例如，$[0.123456,0.654321,0.000000]$）。不应产生任何其他输出。\n\n注意：此问题不涉及物理单位或角度单位。所有答案必须以小数形式表示。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确、客观且完整的。所有参数和定义均已提供，所描述的模型是计算经济学中一个标准的程式化表示。该问题是有效的，将提供解决方案。\n\n该问题描述了一个简化的基于主体的银行挤兑模型，这是一个具有战略互补性的协调博弈的经典例子。有 $N$ 位存款人，每位存款人由一个私有的恐慌阈值 $\\theta_i$ 来表征。这些阈值从一个由均值 $m$ 和集中度参数 $\\kappa$ 指定的贝塔分布中独立同分布地抽取。贝塔分布的形状参数 $\\alpha$ 和 $\\beta$ 由关系式 $\\alpha = m \\kappa$ 和 $\\beta = (1-m)\\kappa$ 确定。较高的集中度 $\\kappa$ 意味着存款人的阈值更紧密地聚集在均值 $m$ 附近。\n\n该模型的核心是集体信念（用 $f$ 表示）的动态演化，它代表了预期将要提取资金的存款人比例。每位存款人 $i$ 都遵循一个简单的阈值规则：如果他们的个人恐慌阈值 $\\theta_i$ 小于或等于普遍的信念 $f$，他们就会提款。这种个体行为汇聚到宏观层面。新的提款存款人比例（它将成为下一时期的信念）由总体最优反应函数给出：\n$$\nF_N(f) = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\theta_i \\le f\\}\n$$\n其中 $\\mathbf{1}\\{\\cdot\\}$ 是指示函数。这个函数是抽取的阈值 $\\{\\theta_i\\}_{i=1}^N$ 的经验累积分布函数（ECDF）。系统的动态由以下迭代映射控制：\n$$\nf_{t+1} = F_N(f_t)\n$$\n从初始信念 $f_0$ 开始。由于 $F_N$ 是一个将区间 $[0,1]$ 映射到有限值集合 $\\{0, \\frac{1}{N}, \\frac{2}{N}, \\ldots, 1\\}$ 的单调不减函数，这个迭代过程保证在有限步内收敛到一个不动点 $f^\\star$，满足 $f^\\star = F_N(f^\\star)$。如果这个均衡状态下的提款比例 $f^\\star$ 达到或超过指定的临界水平 $0.95$，则称发生了“全面挤兑”。\n\n任务是针对大量的独立试验（$T$次）模拟此过程，并为不同的参数设置计算全面挤兑的经验概率。每个试验的独立性——每次试验都重新抽取一组 $\\{\\theta_i\\}_{i=1}^N$——将此问题定性为易并行问题。这种结构非常适合向量化计算，其中所有 $T$ 次试验可以同时处理，而不是顺序处理。\n\n给定测试案例的模拟算法如下：\n\n1. **初始化**：设置问题参数：存款人数量 $N$、试验次数 $T$、贝塔分布均值 $m$ 和集中度 $\\kappa$、初始信念 $f_0$，以及伪随机数生成器（PRNG）的种子以确保可复现性。计算贝塔形状参数 $\\alpha = m\\kappa$ 和 $\\beta = (1-m)\\kappa$。\n\n2. **向量化阈值生成**：生成一个 $T \\times N$ 的阈值矩阵，我们将其表示为 $\\Theta$。该矩阵的每一行对应一次试验，并包含 $N$ 个从贝塔$(\\alpha, \\beta)$分布中抽取的独立样本。\n\n3. **向量化迭代动力学**：\n    a. 初始化一个长度为 $T$ 的向量 $\\mathbf{f}$，其中每个元素都设置为初始信念 $f_0$。该向量同时代表所有 $T$ 次试验的当前信念 $f_t$。\n    b. 进入一个迭代循环，直到所有 $T$ 次试验中的信念都收敛为止。应包含一个最大迭代次数作为安全措施，尽管数学上保证了快速收敛。\n    c. 在循环的每一步中，计算下一个信念向量 $\\mathbf{f}_{\\text{next}}$，以用于所有试验。这是通过以向量化的方式应用总体最优反应函数来完成的。对于每个试验 $j \\in \\{1, \\dots, T\\}$，下一个信念是 $f_{t+1}^{(j)} = \\frac{1}{N} \\sum_{i=1}^N \\mathbf{1}\\{\\Theta_{ji} \\le f_t^{(j)}\\}$。此操作通过将阈值矩阵 $\\Theta$ 与信念向量 $\\mathbf{f}$（进行适当的广播）进行比较，然后沿存款人轴（轴 1）计算均值来一次性对所有 $j$ 执行。\n    d. 检查收敛性。如果 $\\mathbf{f}_{\\text{next}}$ 与 $\\mathbf{f}$ 逐元素相同，则意味着对于所有试验 $j$ 都有 $f_{t+1}^{(j)} = f_t^{(j)}$，并且每个试验中的系统都已达到不动点。循环终止。\n    e. 如果未收敛，则更新信念向量：$\\mathbf{f} \\leftarrow \\mathbf{f}_{\\text{next}}$。\n\n4. **结果分析**：循环终止后，向量 $\\mathbf{f}$ 包含所有 $T$ 次试验的均衡不动点 $f^\\star$。全面挤兑的概率通过计算布尔向量（由比较 $\\mathbf{f} \\ge 0.95$ 产生）的均值来估算，即发生 $f^\\star \\ge 0.95$ 的试验所占的比例。\n\n对每个指定的测试案例重复此过程。使用 NumPy 的向量化操作可以实现高效的计算，直接反映了问题的并行结构，而无需显式使用并行编程库。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the bank run simulation problem for the specified test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: N=500, T=3000, m=0.60, k=40, f0=0.20, seed=12345\n        (500, 3000, 0.60, 40, 0.20, 12345),\n        # Case 2: N=500, T=3000, m=0.40, k=40, f0=0.80, seed=67890\n        (500, 3000, 0.40, 40, 0.80, 67890),\n        # Case 3: N=500, T=3000, m=0.50, k=10, f0=0.50, seed=13579\n        (500, 3000, 0.50, 10, 0.50, 13579),\n    ]\n\n    results = []\n    for case in test_cases:\n        N, T, m, kappa, f0, seed = case\n        \n        # Initialize the pseudo-random number generator with the given seed.\n        rng = np.random.default_rng(seed)\n        \n        # Calculate the shape parameters for the Beta distribution.\n        alpha = m * kappa\n        beta = (1.0 - m) * kappa\n        \n        # In this embarrassingly parallel setup, we can simulate all trials at once.\n        # Generate a TxN matrix of panic thresholds. Each row is a separate trial.\n        thetas = rng.beta(alpha, beta, size=(T, N))\n        \n        # Initialize the belief vector for all T trials.\n        f_current = np.full(T, f0, dtype=float)\n        \n        # Set a practical limit on iterations to prevent any infinite loops,\n        # although convergence is guaranteed. N+2 is more than sufficient.\n        max_iter = N + 2\n        for _ in range(max_iter):\n            # To compute the next belief f_next, we need to compare the current belief f_current\n            # for each trial with the N thresholds for that trial.\n            # f_current[:, np.newaxis] broadcasts the (T,) vector to (T, 1) for comparison\n            # against the (T, N) thetas matrix.\n            # The result of the comparison is a boolean matrix. Taking the mean along axis=1\n            # gives the fraction of depositors who withdraw in each trial.\n            f_next = np.mean(thetas = f_current[:, np.newaxis], axis=1)\n            \n            # Check for convergence. If all trials have converged to a fixed point, break the loop.\n            if np.all(f_next == f_current):\n                break\n            \n            # Update the belief vector for the next iteration.\n            f_current = f_next\n        \n        # The converged beliefs are the fixed points f_star.\n        f_star = f_current\n        \n        # A \"full run\" is defined as f_star >= 0.95.\n        # We calculate the fraction of trials where this occurred.\n        # np.mean on a boolean array counts the True values and divides by the total count.\n        full_run_probability = np.mean(f_star >= 0.95)\n        \n        results.append(full_run_probability)\n\n    # Format the final results as a comma-separated list of strings,\n    # with each number rounded to exactly six decimal places.\n    output_str = f\"[{','.join([f'{r:.6f}' for r in results])}]\"\n    \n    # Final print statement in the exact required format.\n    print(output_str)\n\nsolve()\n```", "id": "2389979"}, {"introduction": "“牛鞭效应”是供应链管理中的一个核心问题，指的是需求变异性沿供应链向上传递时被逐级放大的现象。企业的策略，例如其需求预测方法，会显著影响这一效应。本练习通过模拟不同预测规则下的供应链来比较其性能，展示了比较替代策略或情景如何成为另一类常见的“易并行”计算任务 [@problem_id:2389983]。", "problem": "编写一个完整、可运行的程序，在几种不同的零售商预测规则下，模拟一个串行、多级供应链中的牛鞭效应。该供应链有 $4$ 个层级，索引为 $e \\in \\{0,1,2,3\\}$，其中 $e=0$ 是零售商，$e=1$ 是批发商，$e=2$ 是分销商，$e=3$ 是工厂。时间以周期 $t=1,2,\\dots,T$ 离散。每个层级都采用定期检查的基本库存策略。提前期是确定性的，并且所有层级都相同，即对所有 $e$ 都有 $L_e=L$，其中 $L=2$ 个周期。\n\n每个周期，外生顾客需求 $D_t$ 到达零售商（$e=0$）。外生需求过程是独立同分布的，服从均值为 $\\lambda$ 的泊松分布，即 $D_t \\sim \\text{Poisson}(\\lambda)$，其中 $\\lambda=20$。使用以种子 $20240501$ 初始化的伪随机数生成器生成一个单一的需求实现 $\\{D_t\\}_{t=1}^T$，该实现将在所有测试用例中重复使用。所有其他层级 $e \\ge 1$ 在周期 $t$ 面临的需求是其紧邻下游层级在同一周期下的订单，即 $X_{e,t} = Q_{e-1,t}$，零售商观察到的需求定义为 $X_{0,t} = D_t$。\n\n在每个周期 $t$ 内，事件按以下顺序发生，从下游到上游处理（从 $e=0$ 到 $e=3$）：\n- 由同一层级在 $L$ 个周期前订购的货物在周期开始时到达层级 $e$，并被添加到现有库存中。具体来说，在周期 $t$ 到达层级 $e$ 的数量等于其自己的订单 $Q_{e,t-L}$（如果 $t-L \\ge 1$），否则为 $0$。没有产能限制或供应短缺；到达量等于计划量。\n- 层级 $e$ 观察其周期 $t$ 的需求 $X_{e,t}$，对于 $e=0$ 等于 $D_t$，对于 $e \\ge 1$ 等于 $Q_{e-1,t}$。需求从现有库存中满足；任何未满足的需求都将被完全延期交货并结转。\n- 每个层级根据刚刚观察到的 $X_{e,t}$ 更新其对平均需求的预测。\n- 每个层级计算其基本库存目标 $S_{e,t}$ 并下达订单 $Q_{e,t}$，使其库存头寸等于目标，且订单为非负数。库存头寸为 $IP_{e,t} = \\text{on\\_hand}_{e,t} + \\text{on\\_order}_{e,t} - \\text{backorders}_{e,t}$。目标是 $S_{e,t} = L \\cdot F_{e,t}$，其中 $F_{e,t}$ 是对未来一个周期的平均需求的当前预测。下达的订单是 $Q_{e,t}=\\max\\{0,\\, S_{e,t} - IP_{e,t}\\}$。订单 $Q_{e,t}$ 将在 $L$ 个周期后，即在周期 $t+L$ 开始时到达层级 $e$。\n\n所有层级开始时现有库存和延期交货订单均为零，并且管道为空（没有待收的未完成订单）。所有层级 $e$ 的预测值初始化为 $F_{e,0}=\\lambda$。对于指数平滑法，在观察到 $X_{e,t}$ 之后、计算 $Q_{e,t}$ 之前，更新遵循 $F_{e,t} \\leftarrow \\alpha \\cdot X_{e,t} + (1-\\alpha)\\cdot F_{e,t-1}$。对于窗口长度为 $k$ 的移动平均法，观察到 $X_{e,t}$ 后的预测是该层级最近 $\\min\\{k,t\\}$ 个观测需求的算术平均值，即 $F_{e,t}=\\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j}$，其中 $m=\\min\\{k,t\\}$。\n\n只有零售商的预测方法在不同测试用例中有所不同；所有上游层级 $e \\ge 1$ 都使用平滑参数为 $\\alpha_{\\text{up}}=0.5$ 的指数平滑法。零售商的预测备选方案定义了测试套件。在计算统计数据时，使用总时长 $T=3000$ 个周期，并舍弃最初的 $B=500$ 个周期的磨合期数据。对于每个测试用例，计算每个层级 $e \\in \\{0,1,2,3\\}$ 的牛鞭比率\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)},\n$$\n其中方差是分母为 $n-1$ 的无偏样本方差。\n\n测试套件（每个项目指定零售商的预测规则及其参数）：\n- 用例 1：移动平均法，窗口 $k=5$。\n- 用例 2：移动平均法，窗口 $k=1$。\n- 用例 3：指数平滑法，$\\alpha=0.2$。\n- 用例 4：指数平滑法，$\\alpha=0.9$。\n\n你的程序必须：\n- 使用种子 $20240501$ 生成单一的外生需求路径 $\\{D_t\\}_{t=1}^T$，并在所有用例中重复使用。\n- 对于每个测试用例，按规定运行模拟，并计算向量 $\\left[B_0,B_1,B_2,B_3\\right]$。\n- 将每个牛鞭比率四舍五入到 $4$ 位小数。\n\n最终输出格式：你的程序应生成单行输出，包含一个逗号分隔的列表的列表，不含空格。其中每个内部列表对应上述顺序的一个测试用例，并包含四个四舍五入后的牛鞭比率，对应 $e=0,1,2,3$。例如，打印的行必须如下所示：\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]\n其中 $b_{ij}$ 是四舍五入到 $4$ 位小数的十进制数。", "solution": "牛鞭效应量化了在供应链中向上游移动时订单变异性的放大程度。在具有确定性提前期的定期检查、订货点策略下，每个层级的基本状态包括现有库存、延期交货订单以及由其过去订单创建的计划到货管道。外生随机性是零售商的顾客需求 $D_t$，此处指定为 $D_t \\sim \\text{Poisson}(\\lambda)$，其中 $\\lambda=20$。\n\n我们设置了 $4$ 个层级，索引为 $e \\in \\{0,1,2,3\\}$，具有相同的提前期 $L_e=L=2$。在周期 $t$ 内，处理从下游向上游进行，以确保上游层级观察到的需求是紧邻下游层级在同一周期内下的订单。具体来说，$X_{0,t}=D_t$，对于 $e \\ge 1$，$X_{e,t}=Q_{e-1,t}$。这个顺序在每个周期产生了一个明确定义的事件序列：\n1. 到货：如果 $t-L \\ge 1$，数量为 $Q_{e,t-L}$ 的货物到达层级 $e$，这反映了确定性的提前期 $L$。这些到货被添加到现有库存中。由于供应不受限制且等于计划到货量，上游的产能或拥堵不会干扰动态过程，因此预测的信息效应被分离开来。\n2. 需求实现与满足：层级 $e$ 观察到 $X_{e,t}$。它尽可能地从现有库存中满足需求，任何短缺都将延期交货。设 $\\text{on\\_hand}_{e,t}$ 和 $\\text{backorders}_{e,t}$ 表示在周期 $t$ 订货前的即时状态，并设 $x=X_{e,t}$ 为实现的需求，则满足的数量为 $\\min\\{\\text{on\\_hand}_{e,t},x\\}$，延期交货增量为 $x-\\min\\{\\text{on\\_hand}_{e,t},x\\}$。\n3. 预测更新：每个层级维护一个平均需求预测 $F_{e,t}$。对于参数为 $\\alpha \\in (0,1]$ 的指数平滑法，\n$$\nF_{e,t}\\leftarrow \\alpha X_{e,t} + (1-\\alpha)F_{e,t-1}.\n$$\n对于窗口为 $k \\in \\mathbb{N}$ 的移动平均法，在观察到 $X_{e,t}$ 之后，预测为\n$$\nF_{e,t} \\;=\\; \\frac{1}{m}\\sum_{j=0}^{m-1} X_{e,t-j},\\quad m=\\min\\{k,t\\}.\n$$\n初始预测为 $F_{e,0}=\\lambda$。只有零售商的预测方法在不同测试用例中有所不同；所有上游层级都使用平滑参数为 $\\alpha_{\\text{up}}=0.5$ 的指数平滑法。\n4. 订货点决策：库存头寸为\n$$\nIP_{e,t} \\;=\\; \\text{on\\_hand}_{e,t} + \\text{on\\_order}_{e,t} - \\text{backorders}_{e,t},\n$$\n其中 $\\text{on\\_order}_{e,t}$ 是层级 $e$ 在未来 $L$ 个周期内计划到货的总和。基本库存目标是\n$$\nS_{e,t} \\;=\\; L \\cdot F_{e,t},\n$$\n这是在没有安全库存情况下的预期提前期需求。下达的订单是\n$$\nQ_{e,t} \\;=\\; \\max\\{0,\\; S_{e,t} - IP_{e,t}\\}.\n$$\n这个订单被添加到层级 $e$ 的管道末端，并将在 $L$ 个周期后到达。\n\n所有层级开始时管道为空，现有库存和延期交货订单均为零。由于空的初始条件导致的初始瞬态效应，通过在从总时长 $T=3000$ 个周期计算统计数据时丢弃前 $B=500$ 个周期的数据来减轻。所有测试用例都使用相同的外生需求路径 $\\{D_t\\}_{t=1}^T$，以分离零售商预测规则的影响。\n\n为衡量牛鞭效应，对于每个层级 $e$，我们计算订单序列 $\\{Q_{e,t}\\}_{t=B+1}^T$ 的无偏样本方差，并将其除以外生顾客需求 $\\{D_t\\}_{t=B+1}^T$ 的无偏样本方差：\n$$\nB_e \\;=\\;\\frac{\\operatorname{Var}\\left(Q_{e,t}\\,:\\,t=B+1,\\dots,T\\right)}{\\operatorname{Var}\\left(D_t\\,:\\,t=B+1,\\dots,T\\right)}.\n$$\n分子和分母使用分母为 $n-1$ 的标准无偏估计量。值 $B_e1$ 表示层级 $e$ 的变异性相对于外生顾客需求被放大，这是牛鞭效应的标志。更平滑的预测（例如，较小 $\\alpha$ 值的指数平滑法或较大 $k$ 值的移动平均法）通常会减少订单变异性，而更具反应性的预测（例如，$k=1$ 的移动平均法或 $\\alpha$ 接近 $1$ 的指数平滑法）则倾向于增加订单变异性，从而增加牛鞭比率，尤其是在上游。\n\n该程序精确地实现了上述动态系统，使用种子 $20240501$ 生成指定的需求路径，使用相同的外生路径独立模拟每个测试用例，计算每个用例中对应 $e=0,1,2,3$ 的四个牛鞭比率，将每个比率四舍五入到 $4$ 位小数，并以所需格式打印包含结果列表的单行内容：\n[[b00,b01,b02,b03],[b10,b11,b12,b13],[b20,b21,b22,b23],[b30,b31,b32,b33]]。\n每个测试用例都与其他用例独立，因此可以分开评估，无需考虑用例间的交互，这反映了该任务的易并行特性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up):\n    \"\"\"\n    Simulate the 4-echelon supply chain for one retailer forecasting case.\n    demand_path: numpy array of length T with exogenous customer demand for the retailer.\n    method: 'MA' or 'ES' for retailer's forecasting method.\n    param: window k for MA (int) or alpha for ES (float).\n    Returns list of 4 bullwhip ratios [B0, B1, B2, B3].\n    \"\"\"\n    E = 4  # number of echelons: 0=retailer,1=wholesaler,2=distributor,3=factory\n    orders = np.zeros((E, T), dtype=float)\n    on_hand = np.zeros(E, dtype=float)\n    backorders = np.zeros(E, dtype=float)\n    # Pipelines: each is a list of length L storing scheduled arrivals for future periods\n    pipelines = [([0.0] * L) for _ in range(E)]\n    # Forecasts initialized to lambda\n    forecasts = np.full(E, float(lam), dtype=float)\n    # Moving average buffers per echelon (retailer may use MA; upstream use ES)\n    ma_buffers = [[] for _ in range(E)]\n\n    for t in range(T):\n        downstream_order = None  # will hold Q_{e-1,t} as demand for echelon e\n        for e in range(E):\n            # 1) Arrivals\n            if L > 0:\n                arrival = pipelines[e].pop(0)\n                on_hand[e] += arrival\n            else:\n                arrival = 0.0\n\n            # 2) Demand observed for echelon e\n            if e == 0:\n                x = float(demand_path[t])\n            else:\n                x = float(downstream_order) if downstream_order is not None else 0.0\n\n            # Fulfill demand from on-hand; backorder any unmet\n            fulfilled = min(on_hand[e], x)\n            on_hand[e] -= fulfilled\n            unmet = x - fulfilled\n            backorders[e] += unmet\n\n            # 3) Forecast update\n            if e == 0:\n                if method == 'MA':\n                    k = int(param)\n                    # Update buffer with latest observation\n                    ma_buffers[e].append(x)\n                    # Keep only last k\n                    if len(ma_buffers[e]) > k:\n                        ma_buffers[e] = ma_buffers[e][-k:]\n                    # Forecast is mean of available buffer\n                    if len(ma_buffers[e]) > 0:\n                        forecasts[e] = float(sum(ma_buffers[e]) / len(ma_buffers[e]))\n                    else:\n                        forecasts[e] = float(lam)\n                elif method == 'ES':\n                    alpha = float(param)\n                    forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n                else:\n                    raise ValueError(\"Unknown method\")\n            else:\n                # Upstream echelons use exponential smoothing with fixed alpha_up\n                alpha = float(alpha_up)\n                forecasts[e] = alpha * x + (1.0 - alpha) * forecasts[e]\n\n            # 4) Order-up-to decision\n            on_order = sum(pipelines[e]) if L > 0 else 0.0\n            inventory_position = on_hand[e] + on_order - backorders[e]\n            S_target = L * forecasts[e]\n            q = S_target - inventory_position\n            if q  0.0:\n                q = 0.0\n            orders[e, t] = q\n\n            # Schedule arrival after L periods\n            if L > 0:\n                pipelines[e].append(q)\n\n            # Set demand for next upstream echelon within same period\n            downstream_order = q\n\n    # Compute bullwhip ratios using unbiased sample variance after burn-in\n    mask = np.arange(T) >= burn_in\n    var_D = np.var(demand_path[mask], ddof=1)\n    # Guard against zero variance (should not happen with Poisson)\n    if var_D == 0.0:\n        var_D = np.nan\n\n    bullwhip = []\n    for e in range(E):\n        var_Q = np.var(orders[e, mask], ddof=1)\n        ratio = var_Q / var_D if np.isfinite(var_D) and var_D > 0 else float('nan')\n        bullwhip.append(ratio)\n\n    return bullwhip\n\n\ndef solve():\n    # Parameters as specified in the problem statement\n    T = 3000\n    burn_in = 500\n    L = 2\n    lam = 20\n    seed = 20240501\n    alpha_up = 0.5  # upstream echelons' exponential smoothing parameter\n\n    # Generate a single exogenous demand path reused across all test cases\n    rng = np.random.default_rng(seed)\n    demand_path = rng.poisson(lam=lam, size=T).astype(float)\n\n    # Define test cases: (method, parameter)\n    test_cases = [\n        ('MA', 5),     # Case 1: Moving average k=5\n        ('MA', 1),     # Case 2: Moving average k=1\n        ('ES', 0.2),   # Case 3: Exponential smoothing alpha=0.2\n        ('ES', 0.9),   # Case 4: Exponential smoothing alpha=0.9\n    ]\n\n    results = []\n    for method, param in test_cases:\n        ratios = simulate_case(demand_path, method, param, T, burn_in, L, lam, alpha_up)\n        # Round to 4 decimals\n        rounded = [float(f\"{r:.4f}\") for r in ratios]\n        results.append(rounded)\n\n    # Print single-line output in required format without spaces\n    # Construct string like [[b00,b01,b02,b03],[b10,...],...]\n    inner_lists = []\n    for row in results:\n        inner = \",\".join(f\"{x:.4f}\" for x in row)\n        inner_lists.append(f\"[{inner}]\")\n    output = \"[\" + \",\".join(inner_lists) + \"]\"\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2389983"}]}