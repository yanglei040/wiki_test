{"hands_on_practices": [{"introduction": "在计算经济学中，选择正确的数据结构对模型效率至关重要。不同的稀疏矩阵表示法，如键字典（DOK）和压缩稀疏行（CSR），具有不同的内存开销和访问特性。本练习将通过一个投资组合优化的实际场景，帮助您量化这些差异，从而培养您在面对具体问题时做出明智数据结构选择的直觉和能力。[@problem_id:2432973]", "problem": "在计算经济学和金融学中，您正在为一个带有行业限制的只做多投资组合选择问题建立线性约束模型。现有 $N$ 种资产和 $S$ 个行业。每种资产恰好属于一个行业。令 $x \\in \\mathbb{R}^{N}$ 表示资产决策变量，$y \\in \\mathbb{R}^{S}$ 表示二元行业使用指标。投资组合持有的资产不超过 $k$ 个行业的约束，由一个具有以下结构的稀疏线性系统表示：\n1. 对每个行业 $s \\in \\{1,\\dots,S\\}$，约束为\n$$\\sum_{i \\in \\text{sector}(s)} 1 \\cdot x_i - M \\cdot y_s \\le 0,$$\n其中 $M$ 是任意正常数，且每种资产 $i$ 恰好出现在一个此类总和中，系数为 $1$。\n2. 对活跃行业数量的上限，\n$$\\sum_{s=1}^{S} 1 \\cdot y_s \\le k.$$\n将这些约束组合成一个单一的稀疏约束矩阵 $A \\in \\mathbb{R}^{(S+1)\\times (N+S)}$，作用于拼接向量 $(x,y) \\in \\mathbb{R}^{N+S}$，其右端向量为 $b \\in \\mathbb{R}^{S+1}$，且 $k$ 仅出现在其最后一个分量中。在这些条件下，$A$ 中的非零元数量为\n$$\\mathrm{nnz} = N + 2S,$$\n因为 $S$ 个行业行中对应 $x$ 有 $N$ 个单位系数，在相同的行中对应 $y$ 变量有 $S$ 个系数，以及在最后一行中对应 $y$ 变量有 $S$ 个单位系数。\n\n您将比较矩阵 $A$ 及其右端向量 $b$ 的两种稀疏表示的内存使用量（以字节为单位）：\n- 键字典 (DOK)：使用64位有符号整数表示索引，64位浮点数表示值，将每个非零元存储为三元组 $(\\text{row}, \\text{col}, \\text{value})$。同时，将右端向量 $b$ 存储为64位浮点数条目。假设除了这些基本字段外没有额外的开销。\n- 压缩稀疏行 (CSR)：为 $A$ 存储三个数组：数据（长度为 $\\mathrm{nnz}$，64位浮点数）、列索引（长度为 $\\mathrm{nnz}$，64位有符号整数）和行指针（长度为 $(S+1)+1$，64位有符号整数）。同时，将右端向量 $b$ 存储为64位浮点数条目。\n\n所有索引字段每个条目使用8字节，所有浮点字段每个条目使用8字节。$M$ 的大小不影响内存使用。$k$ 的值仅影响 $b$ 中一个条目的数值，因此不改变存储条目的数量。\n\n任务：对于每个测试用例 $(N,S,k)$，计算上述模型下键字典 (DOK) 和压缩稀疏行 (CSR) 表示所需的总内存（以字节为单位），包括 $b$ 的存储。然后，为每个测试用例计算比率\n$$r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}},$$\n该比率是无量纲的。报告每个 $r$ 值，四舍五入到三位小数。\n\n测试集（每个元组为 $(N,S,k)$，其中 $N \\in \\mathbb{Z}_{\\ge 0}$，$S \\in \\mathbb{Z}_{\\ge 1}$，$k \\in \\{0,1,\\dots,S\\}$）：\n- $(500, 10, 3)$\n- $(10000, 100, 5)$\n- $(0, 8, 0)$\n- $(1000, 1, 1)$\n- $(50, 200, 5)$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 `\"[r_1,r_2,r_3,r_4,r_5]\"`，其中每个 $r_j$ 均按要求四舍五入到三位小数。", "solution": "所提出的问题定义明确，具有科学依据，并包含了获得唯一解所需的所有信息。我们将系统地推导指定稀疏矩阵表示的内存需求。\n\n问题要求比较线性约束系统 $Ax \\le b$ 的键字典 (DOK) 和压缩稀疏行 (CSR) 格式之间的内存使用情况。该系统由 $N$ 种资产和 $S$ 个行业定义。约束矩阵 $A$ 的维度为 $(S+1) \\times (N+S)$，右端向量 $b$ 的维度为 $S+1$。$A$ 中的非零元数量给定为 $\\mathrm{nnz} = N + 2S$。所有索引字段存储为64位（8字节）整数，所有值字段存储为64位（8字节）浮点数。\n\n首先，我们将计算键字典 (DOK) 表示所需的总内存，记为 $\\text{bytes}_{\\mathrm{DOK}}$。在 DOK 格式中，矩阵 $A$ 的每个 $\\mathrm{nnz}$ 非零元都存储为一个三元组 $(\\text{row}, \\text{col}, \\text{value})$。三元组的每个分量的内存分别为：行索引8字节，列索引8字节，值8字节。因此，存储一个非零元所需的内存为 $8 + 8 + 8 = 24$ 字节。矩阵 $A$ 的总内存是非零元数量与每个条目内存的乘积：\n$$ \\text{Mem}_{\\mathrm{DOK}}(A) = \\mathrm{nnz} \\times 24 = (N + 2S) \\times 24 = 24N + 48S $$\n右端向量 $b$ 有 $S+1$ 个条目，每个条目是8字节的浮点数。其内存占用为：\n$$ \\text{Mem}(b) = (S+1) \\times 8 = 8S + 8 $$\nDOK 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{DOK}} = \\text{Mem}_{\\mathrm{DOK}}(A) + \\text{Mem}(b) = (24N + 48S) + (8S + 8) = 24N + 56S + 8 $$\n\n接下来，我们计算压缩稀疏行 (CSR) 表示所需的总内存，记为 $\\text{bytes}_{\\mathrm{CSR}}$。矩阵 $A$ 的 CSR 格式由三个数组组成：用于存储值的 `data` 数组、`column indices`（列索引）数组和 `row pointer`（行指针）数组。`data` 数组存储 $\\mathrm{nnz}$ 个非零值，`column indices` 数组存储这些值各自的列索引。两个数组的长度均为 $\\mathrm{nnz}$，并使用8字节元素（分别为64位浮点数和64位整数）。`row pointer` 数组指定了其他两个数组中每一行的起始位置；其长度为行数加一，即 $(S+1)+1 = S+2$，其元素为8字节整数。矩阵 $A$ 在 CSR 格式下的内存为：\n$$ \\text{Mem}_{\\mathrm{CSR}}(A) = \\underbrace{(N+2S) \\times 8}_{\\text{data}} + \\underbrace{(N+2S) \\times 8}_{\\text{indices}} + \\underbrace{(S+2) \\times 8}_{\\text{row pointer}} $$\n$$ \\text{Mem}_{\\mathrm{CSR}}(A) = 16(N+2S) + 8(S+2) = 16N + 32S + 8S + 16 = 16N + 40S + 16 $$\n向量 $b$ 的存储方式与前一种情况相同，需要 $\\text{Mem}(b) = 8S + 8$ 字节。CSR 表示的总内存是矩阵 $A$ 和向量 $b$ 的内存之和：\n$$ \\text{bytes}_{\\mathrm{CSR}} = \\text{Mem}_{\\mathrm{CSR}}(A) + \\text{Mem}(b) = (16N + 40S + 16) + (8S + 8) = 16N + 48S + 24 $$\n\n最后，我们计算比率 $r = \\frac{\\text{bytes}_{\\mathrm{DOK}}}{\\text{bytes}_{\\mathrm{CSR}}}$。代入推导出的表达式：\n$$ r = \\frac{24N + 56S + 8}{16N + 48S + 24} $$\n这个表达式可以通过将分子和分母同除以它们的最大公约数 $8$ 来简化：\n$$ r = \\frac{3N + 7S + 1}{2N + 6S + 3} $$\n这个最终公式用于计算每个测试用例所需的比率。正如问题中所述，参数 $k$ 和 $M$ 正确地对内存计算没有影响。比率 $r$ 仅取决于资产数量 $N$ 和行业数量 $S$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Calculates the ratio of memory usage between DOK and CSR sparse representations\n    for a series of test cases based on a portfolio optimization problem.\n    \"\"\"\n    test_cases = [\n        # Each tuple is (N, S, k)\n        (500, 10, 3),\n        (10000, 100, 5),\n        (0, 8, 0),\n        (1000, 1, 1),\n        (50, 200, 5)\n    ]\n\n    results = []\n    for case in test_cases:\n        N, S, k = case  # The parameter k is not used in the memory calculation.\n\n        # Derived formula for the ratio r = bytes_DOK / bytes_CSR\n        # r = (24*N + 56*S + 8) / (16*N + 48*S + 24)\n        # Simplified formula by dividing numerator and denominator by 8:\n        # r = (3*N + 7*S + 1) / (2*N + 6*S + 3)\n        numerator = 3 * N + 7 * S + 1\n        denominator = 2 * N + 6 * S + 3\n        \n        # Based on problem constraints (N=0, S=1), the denominator is always positive.\n        # min denominator: 2*0 + 6*1 + 3 = 9. So no division by zero check is needed.\n        ratio = numerator / denominator\n        \n        # Format the result to three decimal places.\n        results.append(f\"{ratio:.3f}\")\n\n    # Print the final output in the specified format: \"[r1,r2,r3,r4,r5]\"\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2432973"}, {"introduction": "理解了存储方式后，我们转向计算。金融模型常常需要整合来自不同来源的数据，例如将市场相关性矩阵与新闻情绪矩阵相结合。本练习探讨了哈达玛积（Hadamard product），即元素级乘积，这是一种常见的操作，其关键在于结果的稀疏性是输入矩阵稀疏模式的交集。通过这个练习，您将学会如何通过避免对零元素进行不必要的计算来高效地实现此类操作，这是计算金融领域的一项核心技能。[@problem_id:2433011]", "problem": "给定多对实值稀疏方阵，分别代表资产相关性矩阵和新闻情绪共动矩阵。对于每一对矩阵，计算其哈达玛积（逐元素积），定义为 $A = C \\circ S$，其中对所有索引 $i,j$ 都有 $A_{ij} = C_{ij} \\cdot S_{ij}$。每个稀疏矩阵由其维度 $n$ 和一个有限的非零元列表指定。索引从零开始。任何未列出的元素都精确为零。\n\n对于每个测试用例，计算并返回三个量：\n- $A$ 的非零元数量，记为 $\\mathrm{nnz}(A)$。\n- $A$ 的所有元素之和，记为 $\\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} A_{ij}$。\n- $A$ 的弗罗贝尼乌斯范数的平方，记为 $\\lVert A \\rVert_F^2 = \\sum_{i=0}^{n-1} \\sum_{j=0}^{n-1} A_{ij}^2$。\n\n您的程序必须生成单行输出，其中包含所有测试用例的结果，格式为一个方括号括起来的逗号分隔列表。每个测试用例的结果本身必须是 $[\\mathrm{nnz}(A), \\text{sum}, \\text{frob\\_sq}]$ 形式的列表，其中 $\\mathrm{nnz}(A)$ 是一个整数，两个浮点值打印时四舍五入到一位小数。例如：$[[x_1,y_1,z_1],[x_2,y_2,z_2],[x_3,y_3,z_3]]$。\n\n测试套件：\n- 测试用例 1：\n  - 维度：$n = 5$。\n  - 相关性矩阵 $C$ 的非零元：\n    - 对角线：$(0,0,1)$, $(1,1,1)$, $(2,2,1)$, $(3,3,1)$, $(4,4,1)$。\n    - 非对角线对称对：$(0,1,0.3)$, $(1,0,0.3)$, $(0,3,-0.2)$, $(3,0,-0.2)$, $(2,4,0.5)$, $(4,2,0.5)$, $(1,2,0.1)$, $(2,1,0.1)$。\n  - 情绪矩阵 $S$ 的非零元：\n    - 对角线：$(0,0,0.5)$, $(2,2,1.5)$, $(4,4,-1.0)$。\n    - 非对角线对称对：$(0,1,10)$, $(1,0,10)$, $(0,3,3)$, $(3,0,3)$, $(1,3,7)$, $(2,4,-2)$, $(4,2,-2)$, $(1,2,8)$, $(2,1,8)$。\n- 测试用例 2：\n  - 维度：$n = 4$。\n  - 相关性矩阵 $C$ 的非零元：\n    - 对角线：$(0,0,1)$, $(1,1,1)$, $(2,2,1)$, $(3,3,1)$。\n    - 非对角线对称对：$(0,1,0.4)$, $(1,0,0.4)$, $(2,3,-0.7)$, $(3,2,-0.7)$。\n  - 情绪矩阵 $S$ 的非零元：\n    - 仅非对角线对称对：$(1,2,5)$, $(2,1,5)$, $(0,3,9)$, $(3,0,9)$, $(1,3,2)$, $(3,1,2)$。\n- 测试用例 3：\n  - 维度：$n = 6$。\n  - 相关性矩阵 $C$ 的非零元：\n    - 对角线：$(0,0,1)$, $(1,1,1)$, $(2,2,1)$, $(3,3,1)$, $(4,4,1)$, $(5,5,1)$。\n    - 非对角线对称对：$(0,2,0.2)$, $(2,0,0.2)$, $(1,2,-0.4)$, $(2,1,-0.4)$, $(3,4,0.9)$, $(4,3,0.9)$, $(4,5,0.6)$, $(5,4,0.6)$。\n  - 情绪矩阵 $S$ 的非零元：\n    - 对角线：$(1,1,2.0)$, $(3,3,-1.0)$, $(5,5,4.0)$。\n    - 非对角线对称对：$(0,2,-5.0)$, $(2,0,-5.0)$, $(1,2,1.0)$, $(2,1,1.0)$, $(3,4,10.0)$, $(4,3,10.0)$, $(4,5,-3.0)$, $(5,4,-3.0)$, $(0,1,7.0)$, $(2,3,8.0)$。\n\n所有矩阵元素均为实数。索引 $(i,j)$ 满足 $0 \\le i,j  n$。对于每个测试用例，所列出的条目是全部的非零元；任何未列出的条目都必须视为精确为零。任何列表中都没有重复的索引对。\n\n最终输出格式：\n- 单行输出，包含 $[r_1,r_2,r_3]$，其中每个 $r_k$ 是测试用例 $k$ 的结果列表 $[\\mathrm{nnz}(A), \\text{sum}, \\text{frob\\_sq}]$，并且两个浮点值按照上述规定四舍五入到一位小数。", "solution": "该问题已经过分析，被认为是有效的。这是一个适定（well-posed）的计算问题，基于线性代数和计算科学的标准原理，并提供了所有必要的数据。我们将着手解决。\n\n任务是计算由两个稀疏矩阵 $C$ 和 $S$ 的哈达玛积产生的矩阵 $A$ 的三个属性。哈达玛积定义为 $A = C \\circ S$，其中每个元素 $A_{ij}$ 是源矩阵相应元素的简单乘积：$A_{ij} = C_{ij} \\cdot S_{ij}$。这些矩阵是稀疏的，意味着它们的大部分元素为零。每个测试用例需要计算的属性是：非零元数量 $\\mathrm{nnz}(A)$；所有元素之和 $\\sum_{i,j} A_{ij}$；以及弗罗贝尼乌斯范数的平方 $\\lVert A \\rVert_F^2 = \\sum_{i,j} A_{ij}^2$。\n\n解决此问题的基本原理植根于稀疏矩阵哈达玛积的定义。一个元素 $A_{ij}$ 非零的当且仅当 $C_{ij}$ 和 $S_{ij}$ 均非零。如果 $C_{ij}$ 或 $S_{ij}$ 中任何一个为零（对于大多数索引都是如此），那么 $A_{ij}$ 必然为零。这引出一个关键的观察：$A_{ij}$ 可能非零的索引 $(i,j)$ 集合是 $C$ 和 $S$ 的非零索引集合的交集。令 $\\mathcal{N}(M)$ 为矩阵 $M$ 具有非零元的索引 $(i,j)$ 的集合。那么，$A$ 的非零结构由以下公式确定：\n$$\n\\mathcal{N}(A) = \\mathcal{N}(C) \\cap \\mathcal{N}(S)\n$$\n试图通过在内存中构建完整的 $n \\times n$ 稠密矩阵来解决这个问题是一种幼稚且计算成本高昂的方法。对于大的维度 $n$，这将导致与 $n^2$ 成正比的过量内存消耗，以及涉及大量零值元素的不必要计算。唯一正确且高效的方法是直接对所提供的非零元列表进行操作，充分利用数据的稀疏性。\n\n我们的算法正是围绕着求稀疏索引集交集这一原理设计的。用于测试成员资格和检索与索引关联的值的最有效数据结构是哈希映射，在Python中称为字典。\n\n算法流程如下：\n$1$. 对于给定的一对矩阵 $C$ 和 $S$，我们首先处理其中一个（比如 $C$）来构建一个哈希映射。我们称之为 `c_map`。该映射的键是索引元组 $(i, j)$，值是对应的非零矩阵元素 $C_{ij}$。此步骤需要对 $C$ 的非零元列表进行单次遍历，时间复杂度为 $O(\\mathrm{nnz}(C))$。\n\n$2$. 接下来，我们遍历第二个矩阵 $S$ 的非零元列表。对于每个元素 $(i, j, S_{ij})$，我们使用索引元组 $(i, j)$ 作为键在 `c_map` 中进行查找。这种哈希映射查找的平均时间复杂度为 $O(1)$。\n\n$3$. 如果在 `c_map` 中找到了键 $(i, j)$，这表示我们找到了一个 $C$ 和 $S$ 都有非零元的索引。我们从映射中检索值 $C_{ij}$ 并计算乘积 $A_{ij} = C_{ij} \\cdot S_{ij}$。\n\n$4$. 对于每个计算出的非零元 $A_{ij}$，我们更新我们的三个聚合量：\n- 我们增加非零元计数 $\\mathrm{nnz}(A)$。\n- 我们将 $A_{ij}$ 加到总和的运行总数中。\n- 我们将 $A_{ij}^2$ 加到弗罗贝尼乌斯范数平方的运行总数中。\n\n对 $S$ 中的所有非零元重复此过程。迭代完成后，我们就计算出了矩阵 $A$ 所需的所有量。此第二阶段的总时间复杂度为 $O(\\mathrm{nnz}(S))$。\n\n因此，该算法的总时间复杂度为 $O(\\mathrm{nnz}(C) + \\mathrm{nnz}(S))$，这相对于作为输入的非零元素数量是线性的。空间复杂度为 $O(\\min(\\mathrm{nnz}(C), \\mathrm{nnz}(S)))$，因为我们只需要将其中一个矩阵存储在哈希映射中；为了优化，我们会选择较小的一个。这种方法是最高效的，因为它避免了对零值元素的任何操作，并利用了常数时间查找。", "answer": "```python\nimport numpy as np\n# No other libraries are needed for this solution.\n\ndef solve():\n    \"\"\"\n    Solves the sparse matrix Hadamard product problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        {\n            \"n\": 5,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0), (4, 4, 1.0),\n                (0, 1, 0.3), (1, 0, 0.3), (0, 3, -0.2), (3, 0, -0.2), (2, 4, 0.5),\n                (4, 2, 0.5), (1, 2, 0.1), (2, 1, 0.1)\n            ],\n            \"S_nonzeros\": [\n                (0, 0, 0.5), (2, 2, 1.5), (4, 4, -1.0), (0, 1, 10.0), (1, 0, 10.0),\n                (0, 3, 3.0), (3, 0, 3.0), (1, 3, 7.0), (2, 4, -2.0), (4, 2, -2.0),\n                (1, 2, 8.0), (2, 1, 8.0)\n            ]\n        },\n        {\n            \"n\": 4,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0),\n                (0, 1, 0.4), (1, 0, 0.4), (2, 3, -0.7), (3, 2, -0.7)\n            ],\n            \"S_nonzeros\": [\n                (1, 2, 5.0), (2, 1, 5.0), (0, 3, 9.0), (3, 0, 9.0),\n                (1, 3, 2.0), (3, 1, 2.0)\n            ]\n        },\n        {\n            \"n\": 6,\n            \"C_nonzeros\": [\n                (0, 0, 1.0), (1, 1, 1.0), (2, 2, 1.0), (3, 3, 1.0), (4, 4, 1.0), (5, 5, 1.0),\n                (0, 2, 0.2), (2, 0, 0.2), (1, 2, -0.4), (2, 1, -0.4), (3, 4, 0.9),\n                (4, 3, 0.9), (4, 5, 0.6), (5, 4, 0.6)\n            ],\n            \"S_nonzeros\": [\n                (1, 1, 2.0), (3, 3, -1.0), (5, 5, 4.0), (0, 2, -5.0), (2, 0, -5.0),\n                (1, 2, 1.0), (2, 1, 1.0), (3, 4, 10.0), (4, 3, 10.0), (4, 5, -3.0),\n                (5, 4, -3.0), (0, 1, 7.0), (2, 3, 8.0)\n            ]\n        }\n    ]\n\n    all_results = []\n    for case in test_cases:\n        c_nonzeros = case[\"C_nonzeros\"]\n        s_nonzeros = case[\"S_nonzeros\"]\n\n        # To optimize, build the map from the smaller set of nonzeros.\n        if len(c_nonzeros) = len(s_nonzeros):\n            map_nonzeros = c_nonzeros\n            iterate_nonzeros = s_nonzeros\n        else:\n            map_nonzeros = s_nonzeros\n            iterate_nonzeros = c_nonzeros\n\n        map_data = {(i, j): val for i, j, val in map_nonzeros}\n\n        nnz_A = 0\n        sum_A = 0.0\n        frob_sq_A = 0.0\n\n        for i, j, val_iter in iterate_nonzeros:\n            if (i, j) in map_data:\n                val_map = map_data[(i, j)]\n                a_ij = val_iter * val_map\n                \n                # An entry is counted if the product is non-zero.\n                # Given inputs are non-zero, this check is robust for potential floating point issues.\n                if a_ij != 0.0:\n                    nnz_A += 1\n                    sum_A += a_ij\n                    frob_sq_A += a_ij**2\n\n        all_results.append(f\"[{nnz_A},{sum_A:.1f},{frob_sq_A:.1f}]\")\n\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2433011"}, {"introduction": "现在，让我们将所学知识应用于一个更综合的经济学问题。在分析供应链或金融网络时，评估网络中每个节点（例如公司）的重要性至关重要。本练习将引导您计算卡茨中心性（Katz centrality），这是一个衡量网络影响力的指标，其核心是求解一个大型稀疏线性方程组。这个实践综合了从原始数据构建稀疏矩阵、建立线性系统并使用稀疏求解器找到解决方案等多项技能，展示了稀疏矩阵技术在解决复杂现实世界模型中的强大威力。[@problem_id:2432966]", "problem": "给定有向加权供应链网络，由邻接矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 表示，其中 $A_{ij}$ 是从公司 $i$ 到公司 $j$ 的权重。公司的 Katz 中心性 $x \\in \\mathbb{R}^{n}$ 被定义为以下线性系统的唯一解\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1},\n$$\n其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\alpha \\in \\mathbb{R}$ 满足 $\\alpha \\ge 0$，$A^{\\top}$ 是 $A$ 的转置，$\\mathbf{1}$ 是 n 维全1向量。如果 $\\alpha  1/\\rho(A)$，则保证解的存在性和唯一性，其中 $\\rho(A)$ 是 $A$ 的谱半径。\n\n您的任务是编写一个完整的、可运行的程序，为几个指定的稀疏网络计算 Katz 中心性向量 $x$。节点由从 $0$ 到 $n-1$ 的整数标记。每个网络由元组 $(n,\\ \\text{edge list},\\ \\alpha)$ 指定，其中边列表是一组三元组 $(i,j,w)$，其中 $i,j \\in \\{0,\\dots,n-1\\}$ 且 $w \\in \\mathbb{R}$，表示一条从 $i$ 到 $j$ 的权重为 $w$ 的有向边。邻接矩阵 $A$ 由这些边定义，任何未列出的条目均为零。\n\n计算下面每种情况的 $x$，并报告每个向量，其中每个分量四舍五入到 $6$ 位小数。\n\n测试套件：\n- 情况1（一般无环供应链，理想路径）：\n  - $n = 4$\n  - 边：$(0,1,0.2)$, $(0,2,0.1)$, $(1,2,0.3)$, $(1,3,0.4)$, $(2,3,0.5)$\n  - $\\alpha = 0.85$\n- 情况2（$\\alpha = 0$ 的边界情况）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0$\n- 情况3（接近可逆性边界但可行）：\n  - $n = 3$\n  - 边：$(0,1,1)$, $(1,2,1)$, $(2,0,1)$\n  - $\\alpha = 0.99$\n- 情况4（边界情况：零矩阵）：\n  - $n = 5$\n  - 边：无\n  - $\\alpha = 0.7$\n\n数值精度要求：每个解向量的每个分量相对于精确解的绝对误差必须小于 $10^{-6}$。\n\n最终输出格式：您的程序应生成单行输出，其中包含解向量列表（每个测试用例一个），该列表是用方括号括起来的单个逗号分隔列表，其中每个向量本身也是用方括号括起来的逗号分隔列表，每个数字是小数点后恰好有 $6$ 位的小数。外部列表中的向量顺序必须与上面列出的测试用例顺序相匹配。", "solution": "所提出的问题是线性代数在网络分析中的一个直接应用。我们的任务是为一系列网络计算 Katz 中心性向量 $x$。中心性向量 $x$ 被定义为以下线性系统的解：\n$$\n\\left(I - \\alpha A^{\\top}\\right) x = \\mathbf{1}\n$$\n在这里，$I$ 是 $n \\times n$ 的单位矩阵，$A$ 是网络的邻接矩阵，$\\alpha$ 是一个非负标量衰减因子，$\\mathbf{1}$ 是 n 维全1向量。矩阵 $A^{\\top}$ 是 $A$ 的转置。在条件 $\\alpha  1/\\rho(A)$ 下，保证了唯一非负解 $x$ 的存在性，其中 $\\rho(A)$ 是 $A$ 的谱半径。问题陈述向我们保证，此条件对所有测试用例均成立。\n\n任务的核心是求解这个线性方程组，可以表示为 $M x = b$，其中系数矩阵是 $M = I - \\alpha A^{\\top}$，右端向量是 $b = \\mathbf{1}$。\n\n这些网络被描述为稀疏网络，意味着邻接矩阵 $A$ 包含绝大多数的零元素。为提高计算效率，必须使用为稀疏矩阵设计的数据结构，而不是密集的 $n \\times n$ 数组。Python 中的 `scipy.sparse` 库提供了必要的工具。\n\n对于每个测试用例 $(n, \\text{edge list}, \\alpha)$，算法按以下步骤进行：\n\n1.  **构造矩阵 $M = I - \\alpha A^{\\top}$**：\n    *   首先，我们以稀疏格式构造邻接矩阵的转置 $A^{\\top}$。输入的边列表以三元组 $(i, j, w)$ 的形式提供 $A$ 的条目，这对应于矩阵元素 $A_{ij} = w$。因此，对于转置矩阵 $A^{\\top}$，这对应于元素 $(A^{\\top})_{ji} = w$。我们可以通过向稀疏矩阵构造函数（例如 `scipy.sparse.coo_matrix`）提供行索引、列索引和数据值的列表来高效地组装 $A^{\\top}$。\n    *   大小为 $n \\times n$ 的单位矩阵 $I$ 使用类似 `scipy.sparse.identity(n)` 的函数构造。\n    *   然后矩阵 $M$ 通过稀疏矩阵运算 $I - \\alpha \\cdot A^{\\top}$ 计算得出。`SciPy` 能正确处理其稀疏矩阵格式的标量乘法和减法。\n\n2.  **构造向量 $b$**：\n    *   向量 $b = \\mathbf{1}$ 是一个 n 维向量，其中每个分量都是 $1$。这可以使用 `numpy.ones(n)` 创建。\n\n3.  **求解线性系统 $M x = b$**：\n    *   在准备好稀疏矩阵 $M$ 和密集向量 $b$ 后，我们使用专门的稀疏线性求解器来求解 $x$。函数 `scipy.sparse.linalg.spsolve(M, b)` 就是为此目的设计的。它采用高效的数值方法（例如基于稀疏矩阵LU分解的直接方法），避免了反转密集矩阵所带来的高昂内存和计算成本。\n\n4.  **处理特殊情况**：\n    *   考虑边界条件是有益的。\n    *   对于情况2，其中 $\\alpha=0$，方程简化为 $(I - 0 \\cdot A^{\\top}) x = \\mathbf{1}$，即 $I x = \\mathbf{1}$。解显然是 $x = \\mathbf{1}$。\n    *   对于情况4，其中边列表为空，邻接矩阵 $A$ 是零矩阵。因此，$A^{\\top}$ 也是零矩阵。方程变为 $(I - \\alpha \\cdot 0) x = \\mathbf{1}$，同样是 $I x = \\mathbf{1}$，得出 $x = \\mathbf{1}$，无论 $\\alpha$ 的值是多少。\n    *   在这两种情况下，稀疏求解器的计算机制都是不必要的，可以直接给出结果。我们的实现将识别这些简单情况。\n\n对于一般情况，如情况1和情况3，需要完整的数值计算过程。对于情况1，矩阵 $A$ 是无环的，导致 $A^{\\top}$ 是幂零矩阵。矩阵 $M = I - \\alpha A^{\\top}$ 是下三角矩阵，该系统可以通过前向代入法解析求解，为数值结果提供了一个很好的检验。对于情况3，对于该特定矩阵，给定 $\\rho(A)=1$ 时，$\\alpha=0.99$ 接近稳定性边界。矩阵 $M$ 变得近奇异，但问题仍然是适定的，数值求解器将产生一个有效的解，我们通过解析推导得出对所有 $i$ 都有 $x_i = 1/(1-\\alpha) = 100$。\n\n实现将遵循此逻辑，处理每个测试用例，计算向量 $x$，并按指定的 $6$ 位小数精度格式化输出。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import coo_matrix, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef solve():\n    \"\"\"\n    Solves the Katz centrality problem for a batch of test cases.\n    \"\"\"\n    test_cases = [\n        # Case 1: General acyclic supply chain\n        {'n': 4, 'edges': [(0, 1, 0.2), (0, 2, 0.1), (1, 2, 0.3), (1, 3, 0.4), (2, 3, 0.5)], 'alpha': 0.85},\n        # Case 2: Boundary at alpha = 0\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0},\n        # Case 3: Near the invertibility boundary\n        {'n': 3, 'edges': [(0, 1, 1), (1, 2, 1), (2, 0, 1)], 'alpha': 0.99},\n        # Case 4: Zero matrix\n        {'n': 5, 'edges': [], 'alpha': 0.7},\n    ]\n\n    all_results_str = []\n\n    for case in test_cases:\n        n = case['n']\n        edges = case['edges']\n        alpha = case['alpha']\n\n        # The Katz centrality vector is the solution x to the linear system\n        # (I - alpha * A_transpose) * x = 1\n        # where 1 is a vector of ones.\n\n        # Handle trivial cases for efficiency and correctness.\n        # If alpha is 0 or there are no edges (A is zero matrix),\n        # the equation becomes I*x = 1, so x is a vector of ones.\n        if alpha == 0 or not edges:\n            x = np.ones(n)\n        else:\n            # Construct the transpose of the adjacency matrix A in sparse format.\n            # For an edge (i, j, w) in A, A[i,j] = w.\n            # In A_transpose, this becomes A_transpose[j,i] = w.\n            row_indices = [j for i, j, w in edges]\n            col_indices = [i for i, j, w in edges]\n            data = [w for i, j, w in edges]\n\n            # Use Coordinate (COO) format for easy construction, then convert to\n            # Compressed Sparse Row (CSR) for efficient arithmetic and solving.\n            A_transpose = coo_matrix((data, (row_indices, col_indices)), shape=(n, n)).asformat('csr')\n\n            # Create the identity matrix in sparse CSR format.\n            I = identity(n, format='csr')\n\n            # Form the coefficient matrix M = I - alpha * A_transpose.\n            M = I - alpha * A_transpose\n\n            # The right-hand side vector `b` is a vector of ones.\n            b = np.ones(n)\n\n            # Solve the sparse linear system Mx = b.\n            x = spsolve(M, b)\n\n        # Format the resulting vector according to the problem specification.\n        # Each component is rounded to 6 decimal places.\n        formatted_x = [f\"{val:.6f}\" for val in x]\n        all_results_str.append(f\"[{','.join(formatted_x)}]\")\n\n    # Print the final result in the exact single-line format.\n    print(f\"[{','.join(all_results_str)}]\")\n\nsolve()\n```", "id": "2432966"}]}