{"hands_on_practices": [{"introduction": "在经济学中，许多宏观量是通过汇总大量异质性个体（如公司或家庭）的行为得出的，这个过程通常表现为一个多维积分。在直接采用计算成本高昂的数值方法之前，我们应该始终先检验问题的结构是否允许我们找到更简洁的解析解。这个练习将向你展示，一个看似复杂的二维积分问题 [@problem_id:2415557]，其本质上是二元正态分布的矩生成函数（MGF），识别出这一点就能将数值估算任务转变为对已知公式的简单求值，这不仅更快、更精确，也提供了更深刻的洞见。", "problem": "一个由大量异质性企业组成的连续统根据企业层面的生产函数 $y(z,k)=z^{\\alpha}k^{\\beta}$ 来生产产出，其中 $z>0$ 是企业生产率，$k>0$ 是企业资本。在模型的稳态均衡中，$(\\ln Z,\\ln K)$ 的联合分布是二元正态分布，其均值向量为 $\\mu=\\begin{bmatrix}\\mu_z\\\\ \\mu_k\\end{bmatrix}$，协方差矩阵为 $\\Sigma=\\begin{bmatrix}\\sigma_z^2  \\rho\\,\\sigma_z\\sigma_k\\\\ \\rho\\,\\sigma_z\\sigma_k  \\sigma_k^2\\end{bmatrix}$，其中 $\\sigma_z > 0$，$\\sigma_k > 0$ 且 $-1  \\rho  1$。定义 $Z=\\exp(X_z)$ 和 $K=\\exp(X_k)$，其中 $(X_z,X_k)\\sim \\mathcal{N}(\\mu,\\Sigma)$。总产出是期望\n$$\nY=\\mathbb{E}\\!\\left[Z^{\\alpha}K^{\\beta}\\right]\n=\\iint_{\\mathbb{R}^2}\\exp(\\alpha x+\\beta y)\\,\\phi(x,y;\\mu,\\Sigma)\\,dx\\,dy,\n$$\n其中二元正态密度函数为\n$$\n\\phi(x,y;\\mu,\\Sigma)=\\frac{1}{2\\pi\\sqrt{\\det\\Sigma}}\\exp\\!\\left(-\\tfrac{1}{2}\\begin{bmatrix}x-\\mu_z  y-\\mu_k\\end{bmatrix}\\Sigma^{-1}\\begin{bmatrix}x-\\mu_z\\\\ y-\\mu_k\\end{bmatrix}\\right).\n$$\n\n你的任务是为下面测试套件中的每一组参数计算 $Y$。所有量都是无量纲的。你的程序必须独立处理每个测试用例，并以浮点数形式返回总产出，四舍五入到六位小数。\n\n测试套件（每个测试用例为 $(\\alpha,\\beta,\\mu_z,\\mu_k,\\sigma_z,\\sigma_k,\\rho)$）：\n- 用例 1: $(0.3,0.6,0.1,0.2,0.3,0.4,0.3)$\n- 用例 2: $(0.5,0.4,0.0,0.0,10^{-6},10^{-6},0.0)$\n- 用例 3: $(0.4,0.5,0.1,-0.1,0.5,0.6,0.0)$\n- 用例 4: $(0.2,0.79,0.0,0.0,0.8,0.9,0.95)$\n- 用例 5: $(0.45,0.5,-0.2,0.3,1.0,1.0,-0.8)$\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[r_1,r_2,r_3,r_4,r_5]$），其中每个 $r_i$ 是相应测试用例计算出的 $Y$ 值，四舍五入到六位小数。不应打印任何其他文本。", "solution": "问题陈述已经过验证，并被认为是有效的。它具有科学依据、提法明确且客观。它提出了经济理论中一个关于在企业异质性的分布假设下对企业层面产出进行加总的标准问题。我将继续提供解决方案。\n\n该问题要求计算总产出 $Y$，其定义为企业层面生产函数 $y(Z,K) = Z^{\\alpha}K^{\\beta}$ 在企业生产率 $Z$ 和资本 $K$ 的联合分布上的期望。\n\n已知条件如下：\n- 生产函数: $y(Z,K) = Z^{\\alpha}K^{\\beta}$\n- 对数正态分布：题目指定 $(\\ln Z, \\ln K)$ 服从二元正态分布。令 $X_z = \\ln Z$ 且 $X_k = \\ln K$。则随机向量 $\\begin{bmatrix} X_z \\\\ X_k \\end{bmatrix}$ 服从二元正态分布 $\\mathcal{N}(\\mu, \\Sigma)$。\n- 均值向量为 $\\mu = \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix}$。\n- 协方差矩阵为 $\\Sigma = \\begin{bmatrix} \\sigma_z^2  \\rho\\,\\sigma_z\\sigma_k\\\\ \\rho\\,\\sigma_z\\sigma_k  \\sigma_k^2 \\end{bmatrix}$。\n\n总产出 $Y$ 是期望：\n$$\nY = \\mathbb{E}\\left[Z^{\\alpha}K^{\\beta}\\right]\n$$\n通过代入 $Z = \\exp(X_z)$ 和 $K = \\exp(X_k)$，表达式变为：\n$$\nY = \\mathbb{E}\\left[\\left(\\exp(X_z)\\right)^{\\alpha}\\left(\\exp(X_k)\\right)^{\\beta}\\right] = \\mathbb{E}\\left[\\exp(\\alpha X_z + \\beta X_k)\\right]\n$$\n这个期望正是二元正态随机向量 $X = \\begin{bmatrix} X_z \\\\ X_k \\end{bmatrix}$ 的矩生成函数 (MGF)，在点 $t = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$ 处的值。\n\n问题中给出的定义积分，\n$$\nY=\\iint_{\\mathbb{R}^2}\\exp(\\alpha x+\\beta y)\\,\\phi(x,y;\\mu,\\Sigma)\\,dx\\,dy\n$$\n是正确的，但代表了一种朴素的计算路径。当存在闭式解析解时，数值积分是不必要的，且在计算上效率较低。严谨的方法是利用多元正态分布的性质。\n\n一个通用的 $d$ 维正态随机向量 $X \\sim \\mathcal{N}(\\mu, \\Sigma)$ 的 MGF 由以下公式给出：\n$$\nM_X(t) = \\mathbb{E}\\left[\\exp(t^T X)\\right] = \\exp\\left(t^T \\mu + \\frac{1}{2} t^T \\Sigma t\\right)\n$$\n在我们的二维情况下，我们有 $t = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}$，$\\mu = \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix}$，以及 $\\Sigma = \\begin{bmatrix} \\sigma_z^2  \\rho\\sigma_z\\sigma_k \\\\ \\rho\\sigma_z\\sigma_k  \\sigma_k^2 \\end{bmatrix}$。\n\n我们现在计算 MGF 指数部分的两项。\n第一项是线性项：\n$$\nt^T \\mu = \\begin{bmatrix} \\alpha  \\beta \\end{bmatrix} \\begin{bmatrix} \\mu_z \\\\ \\mu_k \\end{bmatrix} = \\alpha\\mu_z + \\beta\\mu_k\n$$\n第二项是二次项：\n$$\nt^T \\Sigma t = \\begin{bmatrix} \\alpha  \\beta \\end{bmatrix} \\begin{bmatrix} \\sigma_z^2  \\rho\\sigma_z\\sigma_k \\\\ \\rho\\sigma_z\\sigma_k  \\sigma_k^2 \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\n$$\n执行矩阵乘法得到：\n$$\nt^T \\Sigma t = \\begin{bmatrix} \\alpha  \\beta \\end{bmatrix} \\begin{bmatrix} \\alpha\\sigma_z^2 + \\beta\\rho\\sigma_z\\sigma_k \\\\ \\alpha\\rho\\sigma_z\\sigma_k + \\beta\\sigma_k^2 \\end{bmatrix}\n$$\n$$\nt^T \\Sigma t = \\alpha(\\alpha\\sigma_z^2 + \\beta\\rho\\sigma_z\\sigma_k) + \\beta(\\alpha\\rho\\sigma_z\\sigma_k + \\beta\\sigma_k^2)\n$$\n$$\nt^T \\Sigma t = \\alpha^2\\sigma_z^2 + \\alpha\\beta\\rho\\sigma_z\\sigma_k + \\alpha\\beta\\rho\\sigma_z\\sigma_k + \\beta^2\\sigma_k^2\n$$\n$$\nt^T \\Sigma t = \\alpha^2\\sigma_z^2 + \\beta^2\\sigma_k^2 + 2\\alpha\\beta\\rho\\sigma_z\\sigma_k\n$$\n将这些项代回 MGF 公式，我们得到总产出 $Y$ 的解析表达式：\n$$\nY = \\exp\\left( (\\alpha\\mu_z + \\beta\\mu_k) + \\frac{1}{2}(\\alpha^2\\sigma_z^2 + \\beta^2\\sigma_k^2 + 2\\alpha\\beta\\rho\\sigma_z\\sigma_k) \\right)\n$$\n这个公式是精确的，避免了数值积分的复杂性和潜在的不准确性。实现部分将为每个给定的参数集计算这个闭式表达式的值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the aggregate output Y for several parameter sets based on an\n    analytical formula for the expectation of a function of two correlated\n    log-normal random variables.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (alpha, beta, mu_z, mu_k, sigma_z, sigma_k, rho)\n    test_cases = [\n        (0.3, 0.6, 0.1, 0.2, 0.3, 0.4, 0.3),\n        (0.5, 0.4, 0.0, 0.0, 1e-6, 1e-6, 0.0),\n        (0.4, 0.5, 0.1, -0.1, 0.5, 0.6, 0.0),\n        (0.2, 0.79, 0.0, 0.0, 0.8, 0.9, 0.95),\n        (0.45, 0.5, -0.2, 0.3, 1.0, 1.0, -0.8),\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, beta, mu_z, mu_k, sigma_z, sigma_k, rho = case\n\n        # The aggregate output Y is the moment-generating function of the\n        # bivariate normal vector (ln Z, ln K) evaluated at t = (alpha, beta).\n        # Y = exp(t' * mu + 0.5 * t' * Sigma * t)\n        \n        # Linear term: t' * mu\n        linear_term = alpha * mu_z + beta * mu_k\n        \n        # Quadratic term: t' * Sigma * t\n        quadratic_term = (alpha**2 * sigma_z**2 \n                          + beta**2 * sigma_k**2 \n                          + 2 * alpha * beta * rho * sigma_z * sigma_k)\n        \n        # Combine terms in the exponent and calculate Y\n        exponent = linear_term + 0.5 * quadratic_term\n        y_aggregate = np.exp(exponent)\n        \n        # Append the result rounded to six decimal places\n        results.append(round(y_aggregate, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2415557"}, {"introduction": "当无法进行解析简化时，尤其是在处理高维问题时，蒙特卡洛方法是不可或缺的工具。本练习 [@problem_id:2415504] 将探讨标准伪随机蒙特卡洛（MC）方法与准随机、低差异序列（QMC）方法（如索博尔序列）之间的关键差异。你将构建一个特定的、具有经济学合理性的情景，其中索博尔序列的确定性结构会导致系统性的错误答案，从而具体地展示出，虽然QMC方法通常收敛更快，但理解其潜在失效模式至关重要。", "problem": "考虑一个期望收益的积分，该收益取决于 $d$ 个独立的风险因子，这些风险因子被建模为一个由独立的 Uniform$([0,1])$ 随机变量组成的向量 $U=(U_{1},\\dots,U_{d})$。对于整数 $m \\ge 1$，定义样本大小为 $N=2^{m}$。令 $p=2^{-(m+1)}$ 且 $\\tau=1-p=1-2^{-(m+1)}$。在 $[0,1]^{d}$ 上定义以下两个收益函数：\n\n1. 病态但经济上合理的极端触发数字收益（可解释为一种仅在至少一个周期表现出极端正向冲击时才支付的票息）：\n$$\ng_{d,m}(u) \\;=\\; \\mathbf{1}\\Big\\{\\max_{1 \\le i \\le d} u_{i} \\ge \\tau\\Big\\}.\n$$\n\n2. 平滑基准收益：\n$$\nh_{d}(u) \\;=\\; \\exp\\Big(-\\sum_{i=1}^{d} u_{i}\\Big).\n$$\n\n对于每个收益函数，目标是风险中性期望值（在 Uniform$([0,1])$ 因子下），即\n$$\nG(d,m) \\;=\\; \\mathbb{E}\\big[g_{d,m}(U)\\big] \\;=\\; 1 - \\big(1 - p\\big)^{d} \\quad\\text{其中}\\quad p=2^{-(m+1)},\n$$\n和\n$$\nH(d) \\;=\\; \\mathbb{E}\\big[h_{d}(U)\\big] \\;=\\; \\prod_{i=1}^{d} \\int_{0}^{1} e^{-u_{i}} \\, du_{i} \\;=\\; \\big(1 - e^{-1}\\big)^{d}.\n$$\n\n您将使用相同的样本大小 $N=2^{m}$ 来实现这两个期望的两种估计量：\n\n- 一个基于应用于 $d$ 维空间的、以 2 为底的 Sobol 数字网格的前 $2^{m}$ 个点的低差异估计量。\n- 一个基于 $d$ 维空间中 $N$ 个独立同分布的 Uniform$([0,1])$ 点的标准蒙特卡洛估计量。\n\n对于下面的每个测试用例，计算两种估计量相对于相应精确值（$G(d,m)$ 或 $H(d)$）的绝对误差，并返回一个布尔值，该值指示基于 Sobol 的绝对误差是否严格大于标准蒙特卡洛的绝对误差。\n\n测试套件（每个项目是一个元组，指定要积分的收益函数、维度 $d$ 和定义 $N=2^{m}$ 的指数 $m$）：\n\n- 用例 1：$\\big(\\text{数字收益},\\, d=100,\\, m=10\\big)$，用于评估 $G(100,10)$。\n- 用例 2：$\\big(\\text{平滑收益},\\, d=20,\\, m=10\\big)$，用于评估 $H(20)$。\n- 用例 3：$\\big(\\text{数字收益},\\, d=1,\\, m=10\\big)$，用于评估 $G(1,10)$。\n\n您的程序必须生成单行输出，其中包含按测试套件顺序排列、用方括号括起来的、以逗号分隔的结果列表，例如 $[True, False, True]$，但需使用编程语言的规范布尔文字。\n\n不涉及物理单位。所有角度（如果出现）必须以弧度为单位，但此处不需要。每个测试用例的最终输出是如上所述的布尔值。不要读取任何输入；请直接使用上面给出的测试套件。", "solution": "我们将待估量及其精确值进行形式化，然后从第一性原理出发设计两种基于抽样的估计量。令 $U=(U_{1},\\dots,U_{d})$，其分量独立同分布，且每个分量都服从 Uniform$([0,1])$ 分布。\n\n对于极端触发数字收益 $g_{d,m}$，\n$$\ng_{d,m}(u) = \\mathbf{1}\\Big\\{\\max_{1 \\le i \\le d} u_{i} \\ge \\tau\\Big\\}, \\quad \\tau = 1 - p, \\quad p=2^{-(m+1)}.\n$$\n其精确期望是至少有一个坐标超过阈值 $\\tau$ 的概率：\n$$\nG(d,m) = \\mathbb{E}[g_{d,m}(U)] = \\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i} \\ge \\tau\\Big) = 1 - \\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i}  \\tau\\Big).\n$$\n由于 $U_{i}$ 独立同分布，\n$$\n\\mathbb{P}\\Big(\\max_{1 \\le i \\le d} U_{i}  \\tau\\Big) = \\prod_{i=1}^{d} \\mathbb{P}(U_{i}  \\tau) = \\tau^{d} = \\big(1 - p\\big)^{d},\n$$\n因此\n$$\nG(d,m) = 1 - \\big(1 - p\\big)^{d}, \\quad p=2^{-(m+1)}.\n$$\n\n对于平滑收益 $h_{d}$，\n$$\nh_{d}(u) = \\exp\\Big(-\\sum_{i=1}^{d} u_{i}\\Big) = \\prod_{i=1}^{d} e^{-u_{i}}.\n$$\n利用独立性和 Fubini 定理，\n$$\nH(d) = \\mathbb{E}[h_{d}(U)] = \\prod_{i=1}^{d} \\int_{0}^{1} e^{-u_{i}} \\, du_{i} = \\big(1 - e^{-1}\\big)^{d}.\n$$\n\n我们考虑两种使用相同样本大小 $N=2^{m}$ 的积分规则：\n\n1. 基于 Sobol 的估计量。一个 $d$ 维空间中以 2 为底的 Sobol 数字网格是 $[0,1)^{d}$ 中一个包含 $N$ 个点、具有低差异属性的确定性点集。将这些点表示为 $\\{x^{(n)}\\}_{n=1}^{N}$。其估计量为\n$$\n\\widehat{I}_{\\text{Sob}} = \\frac{1}{N} \\sum_{n=1}^{N} f\\big(x^{(n)}\\big),\n$$\n其中 $f$ 是 $g_{d,m}$ 或 $h_{d}$。当精确使用由 2 的幂次规则生成的 $N=2^{m}$ 个点时，$x^{(n)}$ 的每个坐标都是一个最多有 $m$ 位的二进制分数，这意味着 $\\max_{1 \\le n \\le N,\\, 1 \\le i \\le d} x^{(n)}_{i} \\le 1 - 2^{-m}$。对于数字收益的阈值 $\\tau = 1 - 2^{-(m+1)}$，我们有 $1 - 2^{-m}  \\tau$，因此对于所有的 $n$ 都有 $g_{d,m}(x^{(n)})=0$。所以，对于 $g_{d,m}$，\n$$\n\\widehat{G}_{\\text{Sob}} = 0, \\quad \\big|\\widehat{G}_{\\text{Sob}} - G(d,m)\\big| = G(d,m) = 1 - \\big(1 - 2^{-(m+1)}\\big)^{d}.\n$$\n对于这种选择，这表现出一种确定性的低估，显示出病态的性能不佳。\n\n对于平滑收益 $h_{d}$，不会发生这种退化现象，并且低差异抽样通常会相对于独立抽样减少积分误差，尽管这并非对每个问题都得到保证；其估计量是相同的平均值，只是没有退化现象。\n\n2. 标准蒙特卡洛估计量。从 Uniform$([0,1])^{d}$ 中抽取 $N$ 个独立同分布的样本 $\\{U^{(n)}\\}_{n=1}^{N}$ 并计算\n$$\n\\widehat{I}_{\\text{MC}} = \\frac{1}{N} \\sum_{n=1}^{N} f\\big(U^{(n)}\\big).\n$$\n对于 $g_{d,m}$，每个加数都是一个成功概率为 $q = G(d,m)$ 的伯努利随机变量。该估计量是无偏的，其方差为\n$$\n\\mathbb{V}\\big[\\widehat{G}_{\\text{MC}}\\big] = \\frac{q(1-q)}{N}.\n$$\n当具体选择 $p=2^{-(m+1)}$ 且 $d$ 适中大时，对于小的 $p$ 有 $q = 1 - (1-p)^{d} \\approx d\\,p$，因此预期一个典型的绝对误差量级为 $\\sqrt{q(1-q)/N}$。相比之下，在 $N=2^{m}$ 时，用于 $g_{d,m}$ 的 Sobol 估计量产生一个等于 $q$ 本身的确定性绝对误差，对于相同的 $N$，这个误差可能远大于蒙特卡洛抽样误差。\n\n算法设计。对于每个测试用例，我们计算精确值（对于数字收益是 $G(d,m)$，对于平滑收益是 $H(d)$）。然后我们计算两个估计值：(i) 基于 $d$ 维 Sobol 数字网格的前 $2^{m}$ 个点的 Sobol 平均值，以及 (ii) 基于 $N=2^{m}$ 个独立样本的标准蒙特卡洛平均值。然后我们报告基于 Sobol 的绝对误差是否严格大于标准蒙特卡洛的绝对误差。测试套件包括：一个旨在触发 Sobol 规则确定性低估的中等高维病态数字用例；一个用于评估在良态被积函数上典型行为的平滑用例；以及一个用以说明在最基本维度下相同退化现象的一维边界数字用例。最终程序按测试套件的顺序打印一个布尔值列表。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import qmc\n\ndef digital_payoff_any_tail(samples: np.ndarray, tau: float) - np.ndarray:\n    \"\"\"\n    Pathological but economically plausible digital payoff:\n    pays 1 if any coordinate exceeds tau, else 0.\n    samples: array of shape (N, d)\n    tau: threshold in (0,1)\n    Returns: array of shape (N,) with 0/1 values.\n    \"\"\"\n    return (samples.max(axis=1) = tau).astype(float)\n\ndef smooth_payoff(samples: np.ndarray) - np.ndarray:\n    \"\"\"\n    Smooth benchmark payoff: exp(-sum_i u_i).\n    samples: array of shape (N, d)\n    Returns: array of shape (N,) with positive real values.\n    \"\"\"\n    return np.exp(-samples.sum(axis=1))\n\ndef exact_digital_expectation(d: int, m: int) - float:\n    p = 2.0 ** (-(m + 1))\n    return 1.0 - (1.0 - p) ** d\n\ndef exact_smooth_expectation(d: int) - float:\n    return (1.0 - np.exp(-1.0)) ** d\n\ndef sobol_estimate(d: int, m: int, which: str) - float:\n    \"\"\"\n    Compute Sobol-based estimate using N=2^m points.\n    which: 'digital' or 'smooth'\n    \"\"\"\n    N = 2 ** m\n    engine = qmc.Sobol(d, scramble=False)\n    # Generate exactly 2^m points using the power-of-two method\n    samples = engine.random_base2(m)\n    if which == 'digital':\n        tau = 1.0 - 2.0 ** (-(m + 1))\n        vals = digital_payoff_any_tail(samples, tau)\n    elif which == 'smooth':\n        vals = smooth_payoff(samples)\n    else:\n        raise ValueError(\"Unknown payoff type.\")\n    return float(vals.mean())\n\ndef mc_estimate(d: int, m: int, which: str, seed: int) - float:\n    \"\"\"\n    Compute standard Monte Carlo estimate with N=2^m IID uniforms.\n    which: 'digital' or 'smooth'\n    \"\"\"\n    N = 2 ** m\n    rng = np.random.default_rng(seed)\n    samples = rng.random((N, d))\n    if which == 'digital':\n        tau = 1.0 - 2.0 ** (-(m + 1))\n        vals = digital_payoff_any_tail(samples, tau)\n    elif which == 'smooth':\n        vals = smooth_payoff(samples)\n    else:\n        raise ValueError(\"Unknown payoff type.\")\n    return float(vals.mean())\n\ndef solve():\n    # Test suite: (which, d, m)\n    test_cases = [\n        (\"digital\", 100, 10),  # Pathological case\n        (\"smooth\", 20, 10),    # Smooth benchmark\n        (\"digital\", 1, 10),    # Boundary digital case\n    ]\n\n    results = []\n    # Use distinct seeds for MC to ensure deterministic but independent sampling per case\n    base_seed = 1234567\n    for idx, (which, d, m) in enumerate(test_cases):\n        # Exact value\n        if which == \"digital\":\n            exact = exact_digital_expectation(d, m)\n        else:\n            exact = exact_smooth_expectation(d)\n\n        # Sobol estimate\n        est_sobol = sobol_estimate(d, m, which)\n        err_sobol = abs(est_sobol - exact)\n\n        # MC estimate\n        est_mc = mc_estimate(d, m, which, seed=base_seed + 1000 * (idx + 1))\n        err_mc = abs(est_mc - exact)\n\n        # Compare absolute errors: True if Sobol performs worse\n        results.append(err_sobol  err_mc)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(lambda x: str(x).lower(), results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415504"}, {"introduction": "在许多金融应用中，尤其是在维度较低的情况下（例如，为少量资产构成的篮子期权定价），我们需要极高的精度，这时确定性求积法则通常优于蒙特卡洛方法。这个练习 [@problem_id:2415537] 将指导你为一种基于积分波动的衍生品定价。其核心挑战在于，如何将为标准正态分布积分设计的高斯-埃尔米特求积法应用于一个包含*相关*风险因子的问题，你将学习使用乔列斯基分解（Cholesky decomposition）将问题转化，使其适用于张量积求积法则。", "problem": "考虑一种衍生证券，其在到期时间 $T$ 支付的金额为 $g(I)$，其中 $I$ 是在 $[0,T]$ 的一个包含 $d$ 个子区间的均匀划分上，平方随机波动率的时间积分，即\n$$\nI \\equiv \\sum_{i=1}^{d} \\exp\\left(2 X_i\\right)\\,\\Delta t,\\quad \\Delta t \\equiv \\frac{T}{d}.\n$$\n对数波动率向量 $\\mathbf{X} = (X_1,\\dots,X_d)^\\top$ 在风险中性测度下被建模为一个相关的多元高斯向量，其均值向量为 $\\boldsymbol{\\mu} = (m,\\dots,m)^\\top$，协方差矩阵为 $\\mathbf{C}$，由下式给出\n$$\n\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C}),\\quad \\mathbf{C}_{ij} = s^2\\,\\rho^{|i-j|}\\ \\text{for}\\ i,j \\in \\{1,\\dots,d\\},\n$$\n其中波动率的波动率参数为 $s  0$，时间自相关参数为 $\\rho \\in (-1,1)$。该衍生品的收益是关于积分方差的看涨期权，\n$$\ng(I) = \\max(I - K, 0),\n$$\n执行价格为 $K  0$。在时间 0，风险中性测度下，以连续复利无风险利率 $r$ 计算的无套利价格为\n$$\nV_0 = e^{-rT}\\,\\mathbb{E}\\big[g(I)\\big],\n$$\n其中期望是基于 $\\mathbf{X}$ 的联合分布计算的。\n\n您的任务是编写一个完整的程序，使用确定性乘积高斯-埃尔米特求积法，通过数值计算 $d$ 维期望 $\\mathbb{E}[g(I)]$ 来计算 $V_0$。请从以下基本原理出发：\n- 风险中性定价原理 $V_0 = e^{-rT}\\,\\mathbb{E}[\\text{payoff}]$。\n- 多元正态分布的定义以及独立标准正态变量的仿射变换。\n- 一维经典高斯-埃尔米特求积法则及其到多维的张量积扩展。\n您必须推导出适当的变量替换，将关于多元正态分布的期望转换为适合乘积高斯-埃尔米特求积的形式，首先针对独立标准正态情况，然后通过仿射变换处理相关情况。请勿使用蒙特卡洛或准蒙特卡洛方法；仅使用 $d$ 维确定性高斯-埃尔米特求积法。\n\n精度和数值稳定性要求：\n- 完全按照规定构造协方差矩阵 $\\mathbf{C}$。\n- 使用 Cholesky 分解将独立标准正态变量映射到与 $\\mathbf{C}$ 一致的相关正态变量。\n- 实现每维具有 $q$ 个节点的 $d$ 维乘积高斯-埃尔米特求积法，并确保权重和节点已针对标准正态分布下的期望进行正确缩放。\n- 为指定的测试套件计算出数值稳定的 $V_0$ 值。\n\n输入和输出格式：\n- 没有外部输入；您的程序必须硬编码以下测试套件，计算相应的价格，并打印一行包含以逗号分隔的价格列表（Python 风格的列表），价格按测试用例的顺序列出，每个数字都以定点小数表示法输出。\n\n测试套件：\n- 案例 A (一维基准):\n  - $d = 1$, $T = 1.0$, $r = 0.02$, $m = -1.0$, $s = 0.5$, $\\rho = 0.0$, $K = 0.5$, $q = 50$。\n- 案例 B (二维，弱相关):\n  - $d = 2$, $T = 1.0$, $r = 0.01$, $m = -1.0$, $s = 0.6$, $\\rho = 0.3$, $K = 0.8$, $q = 12$。\n- 案例 C (三维，较强相关性和较长持有期):\n  - $d = 3$, $T = 2.0$, $r = 0.03$, $m = -1.2$, $s = 0.7$, $\\rho = 0.5$, $K = 1.0$, $q = 8$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含方括号括起来的逗号分隔结果列表（例如，[xA,xB,xC]），其中 $xA$、$xB$ 和 $xC$ 分别是案例 A、B 和 C 的价格，每个价格都精确打印到小数点后 $10$ 位。", "solution": "该问题要求计算一种欧式衍生证券的无套利价格 $V_0$。该价格由基本的风险中性估值公式确定：\n$$\nV_0 = e^{-rT}\\,\\mathbb{E}\\big[g(I)\\big]\n$$\n其中，$r$ 是连续复利无风险利率，$T$ 是到期时间，$g(I) = \\max(I - K, 0)$ 是收益函数，它依赖于积分平方波动率的代理变量 $I$。执行价格为 $K$。\n\n积分方差代理变量 $I$ 定义为离散时间网格上的总和：\n$$\nI = \\sum_{i=1}^{d} \\exp\\left(2 X_i\\right)\\,\\Delta t, \\quad \\text{with } \\Delta t = \\frac{T}{d}\n$$\n对数波动率向量 $\\mathbf{X} = (X_1, \\dots, X_d)^\\top$ 被建模为多元正态随机变量，$\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$。均值向量为 $\\boldsymbol{\\mu} = (m, \\dots, m)^\\top$，协方差矩阵是一个 Toeplitz 矩阵，其元素由 $\\mathbf{C}_{ij} = s^2 \\rho^{|i-j|}$ 给出，其中参数 $s  0$ 和 $\\rho \\in (-1, 1)$ 是指定的。\n\n任务的核心是数值计算 $d$ 维期望 $\\mathbb{E}[g(I)]$。该期望是关于多元正态概率密度函数 $p(\\mathbf{x}; \\boldsymbol{\\mu}, \\mathbf{C})$ 在 $\\mathbb{R}^d$ 上的积分：\n$$\n\\mathbb{E}[g(I)] = \\int_{\\mathbb{R}^d} g(I(\\mathbf{x})) \\, p(\\mathbf{x}; \\boldsymbol{\\mu}, \\mathbf{C}) \\, d\\mathbf{x}\n$$\n我们被要求使用确定性乘积高斯-埃尔米特求积法，这需要将积分转换为适合此方法的形式。\n\n经典的一维高斯-埃尔米特求积法则旨在近似计算以 $e^{-y^2}$ 为权重函数的积分：\n$$\n\\int_{-\\infty}^{\\infty} f(y) e^{-y^2} dy \\approx \\sum_{k=1}^{q} w_k f(y_k)\n$$\n其中 $y_k$ 是 $q$ 个节点（埃尔米特多项式 $H_q(y)$ 的根），$w_k$ 是对应的权重。为了计算关于标准正态变量 $Z \\sim \\mathcal{N}(0, 1)$ 的期望，其概率密度函数为 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$，我们进行变量替换 $z = \\sqrt{2}y$。期望积分变为：\n$$\n\\mathbb{E}[h(Z)] = \\int_{-\\infty}^{\\infty} h(z) \\frac{e^{-z^2/2}}{\\sqrt{2\\pi}} dz = \\int_{-\\infty}^{\\infty} h(\\sqrt{2}y) \\frac{e^{-y^2}}{\\sqrt{2\\pi}} \\sqrt{2}dy = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} h(\\sqrt{2}y) e^{-y^2} dy\n$$\n应用求积法则得到以下近似值：\n$$\n\\mathbb{E}[h(Z)] \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{k=1}^{q} w_k h(\\sqrt{2}y_k)\n$$\n通过定义缩放后的节点 $\\tilde{z}_k = \\sqrt{2}y_k$ 和缩放后的权重 $\\tilde{w}_k = w_k / \\sqrt{\\pi}$，可以更紧凑地表示为：\n$$\n\\mathbb{E}[h(Z)] \\approx \\sum_{k=1}^{q} \\tilde{w}_k h(\\tilde{z}_k)\n$$\n对于一个由独立标准正态变量组成的 $d$ 维向量 $\\mathbf{Z} = (Z_1, \\dots, Z_d)^\\top$，其期望通过一维规则在所有 $q^d$ 个网格点上的张量积来近似：\n$$\n\\mathbb{E}[H(\\mathbf{Z})] \\approx \\sum_{k_1=1}^q \\cdots \\sum_{k_d=1}^q H(\\tilde{z}_{k_1}, \\dots, \\tilde{z}_{k_d}) \\prod_{i=1}^d \\tilde{w}_{k_i}\n$$\n对数波动率向量 $\\mathbf{X}$ 是相关的，而不是标准正态的。因此，我们必须将积分域从 $\\mathbf{X} \\sim \\mathcal{N}(\\boldsymbol{\\mu}, \\mathbf{C})$ 转换到 $\\mathbf{Z} \\sim \\mathcal{N}(\\mathbf{0}, \\mathbf{I})$。这通过仿射变换实现：\n$$\n\\mathbf{X} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}\n$$\n其中 $\\mathbf{L}$ 是一个满足 $\\mathbf{L}\\mathbf{L}^\\top = \\mathbf{C}$ 的矩阵。这样的矩阵 $\\mathbf{L}$ 可以通过对对称正定协方差矩阵 $\\mathbf{C}$ 进行 Cholesky 分解得到。然后，关于 $\\mathbf{X}$ 的期望被重写为关于 $\\mathbf{Z}$ 的等价期望：\n$$\n\\mathbb{E}_{\\mathbf{X}}[g(I(\\mathbf{X}))] = \\mathbb{E}_{\\mathbf{Z}}[g(I(\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}))]\n$$\n这个转换后的期望现在处于适合乘积高斯-埃尔米特求积法的形式。令新的被积函数为 $H(\\mathbf{Z}) = g(I(\\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{Z}))$。该期望通过以下求和来近似：\n$$\n\\mathbb{E}[g(I)] \\approx \\sum_{k_1, \\dots, k_d \\in \\{1,\\dots,q\\}} \\left( H(\\tilde{z}_{k_1}, \\dots, \\tilde{z}_{k_d}) \\prod_{i=1}^d \\tilde{w}_{k_i} \\right)\n$$\n整个算法的执行步骤如下：\n1.  对于每个测试用例，组合参数：$d, T, r, m, s, \\rho, K, q$。\n2.  构造 $d \\times d$ 协方差矩阵 $\\mathbf{C}$，其元素为 $\\mathbf{C}_{ij} = s^2 \\rho^{|i-j|}$，以及均值向量 $\\boldsymbol{\\mu}$。\n3.  计算 $\\mathbf{C}$ 的 Cholesky 分解以找到矩阵 $\\mathbf{L}$。\n4.  生成 $q$ 个一维高斯-埃尔米特节点 $y_k$ 和权重 $w_k$。\n5.  对它们进行缩放，以获得适合标准正态分布的节点 $\\tilde{z}_k = \\sqrt{2} y_k$ 和权重 $\\tilde{w}_k = w_k/\\sqrt{\\pi}$。\n6.  通过取缩放后的一维节点的笛卡尔积，构造一个包含 $q^d$ 个节点的 $d$ 维网格。类似地，计算网格上每个点的权重乘积。\n7.  对于 $q^d$ 个网格点中的每一个 $\\mathbf{z}_{\\mathbf{k}}$：\n    a. 将标准正态节点转换为相关的对数波动率空间：$\\mathbf{x}_{\\mathbf{k}} = \\boldsymbol{\\mu} + \\mathbf{L}\\mathbf{z}_{\\mathbf{k}}$。\n    b. 计算积分方差：$I_{\\mathbf{k}} = (T/d)\\sum_{i=1}^d \\exp(2 (\\mathbf{x}_{\\mathbf{k}})_i)$。\n    c. 评估收益：$g(I_{\\mathbf{k}}) = \\max(I_{\\mathbf{k}} - K, 0)$。\n    d. 将收益乘以相应的权重乘积 $W_{\\mathbf{k}} = \\prod_{i=1}^d \\tilde{w}_{k_i}$ 并累加到一个总和中。\n8.  最终的总和近似于 $\\mathbb{E}[g(I)]$。衍生品价格则为 $V_0 = e^{-rT}$ 乘以该总和。为提高效率，此过程以向量化方式实现。", "answer": "```python\nimport numpy as np\n\ndef compute_price(d, T, r, m, s, rho, K, q):\n    \"\"\"\n    Computes the derivative price V0 using d-dimensional Gauss-Hermite quadrature.\n\n    Args:\n        d (int): Dimension of the log-volatility vector.\n        T (float): Time to maturity.\n        r (float): Risk-free interest rate.\n        m (float): Mean of the log-volatility components.\n        s (float): Volatility-of-volatility parameter.\n        rho (float): Autocorrelation parameter.\n        K (float): Strike price.\n        q (int): Number of quadrature nodes per dimension.\n\n    Returns:\n        float: The computed arbitrage-free price V0.\n    \"\"\"\n    # Step 1: Construct mean vector and covariance matrix\n    mu = np.full(d, m)\n    indices = np.arange(d)\n    # Using broadcasting to create the Toeplitz covariance matrix efficiently\n    C = s**2 * rho**(np.abs(indices[:, np.newaxis] - indices))\n    \n    # Step 2: Perform Cholesky decomposition of the covariance matrix\n    # L is a lower-triangular matrix such that C = L @ L.T\n    try:\n        L = np.linalg.cholesky(C)\n    except np.linalg.LinAlgError:\n        # This should not happen for valid parameters rho in (-1, 1)\n        # but is good practice for numerical stability.\n        raise ValueError(\"Covariance matrix is not positive-definite.\")\n\n    # Step 3: Generate and scale 1D Gauss-Hermite nodes and weights\n    nodes_hermite, weights_hermite = np.polynomial.hermite.hermgauss(q)\n    # Scale nodes and weights for integration against the standard normal PDF\n    nodes_std_normal = nodes_hermite * np.sqrt(2.0)\n    weights_std_normal = weights_hermite / np.sqrt(np.pi)\n\n    # Step 4: Create d-dimensional grid of nodes and product weights\n    # The meshgrid approach creates all combinations of nodes for a vectorized calculation.\n    # It returns a list of d-dimensional arrays.\n    node_grids = np.meshgrid(*[nodes_std_normal for _ in range(d)])\n    # We stack the raveled grids to get an array of shape (q**d, d) where each row is a point.\n    z_vectors = np.stack([grid.ravel() for grid in node_grids], axis=1)\n    \n    # Similarly, create product weights for each point\n    weight_grids = np.meshgrid(*[weights_std_normal for _ in range(d)])\n    w_products = np.prod(np.stack([grid.ravel() for grid in weight_grids], axis=1), axis=1)\n    \n    # Step 5: Vectorized computation of the expectation\n    # Transform standard normal nodes z to correlated log-volatility nodes x\n    # z_vectors.T has shape (d, q**d). L @ z_vectors.T has shape (d, q**d).\n    # After transposing back, we have (q**d, d). Add mean vector mu.\n    x_vectors = mu + (L @ z_vectors.T).T\n    \n    # Calculate integrated variance I for all points\n    delta_t = T / d\n    I_values = delta_t * np.sum(np.exp(2.0 * x_vectors), axis=1)\n    \n    # Calculate payoffs for all points\n    payoffs = np.maximum(I_values - K, 0.0)\n    \n    # Step 6: Compute the expectation as the dot product of payoffs and weights\n    expectation = np.dot(payoffs, w_products)\n    \n    # Step 7: Discount the expectation to get the final price\n    price = np.exp(-r * T) * expectation\n    \n    return price\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test suite defined in the problem statement\n    test_cases = [\n        # Case A: 1D baseline\n        {'d': 1, 'T': 1.0, 'r': 0.02, 'm': -1.0, 's': 0.5, 'rho': 0.0, 'K': 0.5, 'q': 50},\n        # Case B: 2D, weak correlation\n        {'d': 2, 'T': 1.0, 'r': 0.01, 'm': -1.0, 's': 0.6, 'rho': 0.3, 'K': 0.8, 'q': 12},\n        # Case C: 3D, stronger correlation\n        {'d': 3, 'T': 2.0, 'r': 0.03, 'm': -1.2, 's': 0.7, 'rho': 0.5, 'K': 1.0, 'q': 8},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = compute_price(**case)\n        # Format the result to 10 decimal places in fixed-point notation\n        results.append(f\"{price:.10f}\")\n\n    # Print the final output in the required format\n    print(f\"[{','.join(results)}]\")\n\n# Execute the solver\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2415537"}]}