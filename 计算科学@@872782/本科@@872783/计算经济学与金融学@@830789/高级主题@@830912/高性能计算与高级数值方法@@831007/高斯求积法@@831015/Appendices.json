{"hands_on_practices": [{"introduction": "金融领域的许多问题，例如为遵循对数正态分布的资产定价，都需要计算期望值。本练习将向您展示如何通过变量变换，将定义在简单区间 $[-1, 1]$ 上的标准高斯-勒让德求积法，转化为一个能处理金融学中常见积分的强大工具。通过这个练习 [@problem_id:2396760]，您将掌握一项核心技能：如何调整通用数值方法以解决特定领域的实际问题。", "problem": "考虑一个严格为正的随机变量 $X$，其定义为 $X=\\exp(\\mu+\\sigma Z)$，其中 $Z$ 是一个标准正态随机变量，$\\mu\\in\\mathbb{R}$ 且 $\\sigma>0$。对于一个可测函数 $g:\\mathbb{R}_{+}\\to\\mathbb{R}$，其期望 $\\mathbb{E}[g(X)]$ 由 $\\int_{0}^{\\infty} g(x) f_{X}(x)\\,\\mathrm{d}x$ 给出，其中 $f_{X}$ 是由 $(\\mu,\\sigma)$ 导出的对数正态分布的概率密度函数。您的任务是通过将区间 $[-1,1]$ 上的标准高斯-勒让德求积法则转换为一个关于 $X$ 的分布进行积分的法则，来为 $\\mathbb{E}[g(X)]$ 构建一个数值求积法则，转换方式需将测度变换融入到变换后的节点和权重中。\n\n您编写的程序必须使用区间 $[-1,1]$ 上标准高斯-勒让德求积法则的恰好 $n=96$ 个节点，计算下列每个测试用例中 $\\mathbb{E}[g(X)]$ 的数值近似值：\n\n- 测试用例 1：$\\mu=0$，$\\sigma=0.25$，$g(x)=x$。\n- 测试用例 2：$\\mu=0.1$，$\\sigma=0.5$，$g(x)=x^{2}$。\n- 测试用例 3：$\\mu=-0.2$，$\\sigma=0.3$，$g(x)=\\ln(x)$。\n- 测试用例 4：$\\mu=0.05$，$\\sigma=0.6$，$g(x)=\\max(x-K,0)$，其中 $K=\\exp(\\mu)$。\n- 测试用例 5：$\\mu=0$，$\\sigma=10^{-6}$，$g(x)=x$。\n\n所有角度（如有）必须以弧度为单位。此问题不涉及任何物理单位。对于数值报告，每个近似值必须四舍五入到 $12$ 位小数。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。顺序必须遵循上述测试用例，因此所需格式为 $[\\text{result}_{1},\\text{result}_{2},\\text{result}_{3},\\text{result}_{4},\\text{result}_{5}]$，其中每个 $\\text{result}_{i}$ 是一个四舍五入到 $12$ 位小数的浮点数。不应打印其他任何文本或格式。", "solution": "所述问题是有效的。它在科学上基于数理金融和数值分析的理论，具体涉及对数正态分布随机变量函数的期望及其通过高斯求积的计算。该问题是适定的、客观的，并包含推导出唯一解所需的所有必要信息。我们将继续进行解答。\n\n目标是计算期望 $\\mathbb{E}[g(X)]$，其中随机变量 $X$ 服从对数正态分布，定义为 $X = \\exp(\\mu + \\sigma Z)$，$Z$ 是一个标准正态随机变量，$Z \\sim N(0,1)$。该期望由以下积分给出：\n$$ \\mathbb{E}[g(X)] = \\int_{0}^{\\infty} g(x) f_X(x) \\,dx $$\n其中 $f_X(x)$ 是对数正态分布的概率密度函数 (PDF)。一个更直接的数值计算路径是将期望用其底层的标准正态变量 $Z$ 来表示。随机变量函数的期望定义为：\n$$ \\mathbb{E}[h(Z)] = \\int_{-\\infty}^{\\infty} h(z) f_Z(z) \\,dz $$\n其中 $f_Z(z) = \\frac{1}{\\sqrt{2\\pi}} \\exp(-z^2/2)$ 是标准正态 PDF。\n将 $X = \\exp(\\mu + \\sigma Z)$ 代入 $\\mathbb{E}[g(X)]$，我们得到：\n$$ \\mathbb{E}[g(X)] = \\mathbb{E}[g(\\exp(\\mu + \\sigma Z))] = \\int_{-\\infty}^{\\infty} g(\\exp(\\mu + \\sigma z)) \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} \\,dz $$\n这个积分是在无限域 $(-\\infty, \\infty)$ 上的。问题要求使用定义在有限区间 $[-1, 1]$ 上的标准高斯-勒让德求积法则来近似它。要使用此法则，我们必须将积分变量变换到这个区间上。\n\n一个标准且稳健的技术是逆变换采样法，也称为分位数函数法。令 $\\Phi(z)$ 为标准正态分布的累积分布函数 (CDF)。我们进行变量替换 $u = \\Phi(z)$。此变换将域 $z \\in (-\\infty, \\infty)$ 映射到 $u \\in (0, 1)$。逆变换为 $z = \\Phi^{-1}(u)$，其中 $\\Phi^{-1}$ 是标准正态分布的分位数函数（或 Probit 函数）。微分由 $du = \\Phi'(z) dz = \\phi(z) dz = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz$ 给出。\n\n将这些代入期望积分中，得到：\n$$ \\mathbb{E}[g(X)] = \\int_{0}^{1} g(\\exp(\\mu + \\sigma \\Phi^{-1}(u))) \\,du $$\n现在积分是在有限区间 $(0, 1)$ 上的。为了应用 $[-1, 1]$ 上的高斯-勒让德求积法则，我们对积分变量进行最后一次线性变换。令 $u = \\frac{t+1}{2}$，这将 $t \\in [-1, 1]$ 映射到 $u \\in [0, 1]$。微分为 $du = \\frac{1}{2} dt$。积分变为：\n$$ \\mathbb{E}[g(X)] = \\int_{-1}^{1} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t+1}{2}\\right)\\right)\\right) \\frac{1}{2} \\,dt $$\n此积分现在是适合高斯-勒让德求积的标准形式 $\\int_{-1}^{1} F(t) dt$，其中被积函数为\n$$ F(t) = \\frac{1}{2} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t+1}{2}\\right)\\right)\\right) $$\n积分 $\\int_{-1}^{1} F(t) dt$ 的 $n$ 点高斯-勒让德求积近似由 $\\sum_{i=1}^{n} w_i F(t_i)$ 给出，其中 $\\{t_i\\}_{i=1}^n$ 是节点（$n$ 阶勒让德多项式的根），而 $\\{w_i\\}_{i=1}^n$ 是相应的权重。\n因此，$\\mathbb{E}[g(X)]$ 的数值近似为：\n$$ \\mathbb{E}[g(X)] \\approx \\sum_{i=1}^{n} w_i \\left[ \\frac{1}{2} g\\left(\\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t_i+1}{2}\\right)\\right)\\right) \\right] $$\n其中按规定 $n=96$。节点 $t_i$ 和权重 $w_i$ 从标准数值库中获得。分位数函数 $\\Phi^{-1}$ 也是一个标准的特殊函数。\n\n该方法按要求构建了一个求积法则。我们可以定义变换后的节点 $\\tilde{x}_i$ 和变换后的权重 $\\tilde{w}_i$ 来直接近似 $\\int_0^\\infty g(x) f_X(x) dx$。令变换后的节点为 $\\tilde{x}_i = \\exp\\left(\\mu + \\sigma \\Phi^{-1}\\left(\\frac{t_i+1}{2}\\right)\\right)$，相应的权重为 $\\tilde{w}_i = w_i/2$。那么近似值就是 $\\sum_{i=1}^{n} \\tilde{w}_i g(\\tilde{x}_i)$。这展示了测度变换是如何被融入到构建过程中的。\n\n计算步骤如下：\n1.  获取区间 $[-1, 1]$ 上 $n=96$ 个标准高斯-勒让德节点 $t_i$ 和权重 $w_i$。\n2.  对于每个由参数 $\\mu$、$\\sigma$ 和函数 $g(x)$ 指定的测试用例：\n3.  对于每个节点 $t_i$：\n    a. 将节点变换到均匀域 $[0, 1]$：$u_i = (t_i+1)/2$。\n    b. 计算标准正态分位数：$z_i = \\Phi^{-1}(u_i)$。\n    c. 计算对数正态变量的值：$x_i = \\exp(\\mu + \\sigma z_i)$。\n    d. 计算函数值：$g(x_i)$。\n4.  计算最终的和：$\\text{Result} = \\frac{1}{2} \\sum_{i=1}^{n} w_i g(x_i)$。\n5.  将结果四舍五入到 $12$ 位小数。\n\n此算法将为所有指定的测试用例实现。\n\n- **测试用例 1**：$\\mu=0$，$\\sigma=0.25$，$g(x)=x$。解析解：$\\mathbb{E}[X] = \\exp(\\mu+\\sigma^2/2) = \\exp(0.03125) \\approx 1.031735515784$。\n- **测试用例 2**：$\\mu=0.1$，$\\sigma=0.5$，$g(x)=x^2$。解析解：$\\mathbb{E}[X^2] = \\exp(2\\mu+2\\sigma^2) = \\exp(0.7) \\approx 2.013752707470$。\n- **测试用例 3**：$\\mu=-0.2$，$\\sigma=0.3$，$g(x)=\\ln(x)$。解析解：$\\mathbb{E}[\\ln(X)] = \\mathbb{E}[\\mu+\\sigma Z] = \\mu = -0.2$。\n- **测试用例 4**：$\\mu=0.05$，$\\sigma=0.6$，$g(x)=\\max(x-K,0)$，其中 $K=\\exp(\\mu)$。这类似于欧式看涨期权的支付。解析值为 $e^{\\mu+\\sigma^2/2}\\Phi(\\sigma) - K\\Phi(0) \\approx 0.387819650393$。\n- **测试用例 5**：$\\mu=0$，$\\sigma=10^{-6}$，$g(x)=x$。这用于测试小 $\\sigma$ 值下的数值稳定性。解析解为 $\\mathbb{E}[X] = \\exp(0.5 \\times 10^{-12}) \\approx 1.0 + 0.5 \\times 10^{-12}$。四舍五入到 12 位小数，结果为 $1.000000000001$。\n\n实现将使用 `numpy` 进行向量化计算，并使用 `scipy.special` 中的 `roots_legendre` 和逆正态累积分布函数 `ndtri`。", "answer": "```python\nimport numpy as np\nfrom scipy.special import roots_legendre, ndtri\n\ndef solve():\n    \"\"\"\n    Computes numerical approximations of E[g(X)] for a lognormal variable X\n    using a transformed Gauss-Legendre quadrature rule.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple contains: (mu, sigma, g_function, K)\n    # K is None if not applicable.\n    test_cases = [\n        (0.0, 0.25, lambda x, k: x, None),\n        (0.1, 0.5, lambda x, k: x**2, None),\n        (-0.2, 0.3, lambda x, k: np.log(x), None),\n        (0.05, 0.6, lambda x, k: np.maximum(x - k, 0), 'exp_mu'),\n        (0.0, 1e-6, lambda x, k: x, None)\n    ]\n    \n    n = 96  # Number of quadrature nodes as specified\n\n    # Get standard Gauss-Legendre nodes and weights for the interval [-1, 1]\n    t_nodes, l_weights = roots_legendre(n)\n\n    results = []\n    \n    for case in test_cases:\n        mu, sigma, g_func, k_spec = case\n        \n        # Determine the value of K if specified\n        K = None\n        if k_spec == 'exp_mu':\n            K = np.exp(mu)\n\n        # Vectorized calculation of the quadrature sum\n        # 1. Transform nodes from [-1, 1] to [0, 1] for CDF argument\n        u_nodes = (t_nodes + 1) / 2.0\n        \n        # 2. Compute standard normal quantiles (probit function)\n        # Add small epsilon to avoid u=0 or u=1 which result in inf\n        epsilon = 1e-16\n        u_nodes = np.clip(u_nodes, epsilon, 1 - epsilon)\n        z_nodes = ndtri(u_nodes)\n        \n        # 3. Compute the values of the lognormal variable at the transformed nodes\n        x_values = np.exp(mu + sigma * z_nodes)\n        \n        # 4. Evaluate the function g(x) for all x values\n        g_values = g_func(x_values, K)\n        \n        # 5. Compute the integral approximation using the quadrature rule\n        # The integral is transformed to 1/2 * integral on [-1, 1] dt\n        integral_approx = 0.5 * np.sum(l_weights * g_values)\n        \n        results.append(integral_approx)\n\n    # Format the final output as specified\n    formatted_results = [f\"{r:.12f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2396760"}, {"introduction": "高斯求积法极为高效，但其性能在很大程度上取决于被积函数的光滑性。本练习 [@problem_id:2396797] 通过比较两种期权的估值——具有连续支付的普通看涨期权和具有不连续支付的数字期权——来深入探讨这一特性。通过观察两者在数值逼近上收敛速度的显著差异，您将对该方法的局限性以及在应用任何数值技术前分析被积函数性质的重要性有更深刻的理解。", "problem": "考虑一个在风险中性测度下具有恒定无风险利率的无摩擦市场。设 $S_0 \\in \\mathbb{R}_{+}$，$K \\in \\mathbb{R}_{+}$，$r \\in \\mathbb{R}$，$\\sigma \\in \\mathbb{R}_{+}$ 及 $T \\in \\mathbb{R}_{+}$ 为固定参数。终端资产价格 $S_T$ 被建模为对数正态分布，其形式为\n$$\nS_T \\;=\\; S_0 \\exp\\!\\big( (r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, Z \\big),\n$$\n其中 $Z \\sim \\mathcal{N}(0,1)$ 是一个标准正态随机变量。定义两种欧式收益：一种是普通看涨期权，其收益为 $\\max\\{S_T - K, 0\\}$；另一种是数字看涨期权，其收益为 $\\mathbf{1}\\{S_T > K\\}$。在时间 $0$ 的无套利价格由风险中性期望给出\n$$\nC \\;=\\; e^{-rT}\\,\\mathbb{E}\\!\\left[\\max\\{S_T - K,0\\}\\right],\\qquad D \\;=\\; e^{-rT}\\,\\mathbb{E}\\!\\left[\\mathbf{1}\\{S_T > K\\}\\right].\n$$\n对于数值近似，您必须通过在 $n \\in \\{4,8,16,32,64\\}$ 的一组有限确定性节点上评估 $Z$ 的函数，将每个期望近似为关于标准正态分布的积分，并计算相对于精确解析值的绝对估值误差。$C$ 和 $D$ 的精确解析值是使用相同的参数 $S_0$、$K$、$r$、$\\sigma$ 和 $T$ 通过 Black-Scholes 封闭式公式获得的值。\n\n给定以下参数集测试套件：\n- 测试用例 1：$(S_0, K, r, \\sigma, T) = (100, 100, 0.03, 0.2, 1)$。\n- 测试用例 2：$(S_0, K, r, \\sigma, T) = (100, 140, 0.03, 0.2, 1)$。\n- 测试用例 3：$(S_0, K, r, \\sigma, T) = (100, 100, 0.03, 0.2, 0.01)$。\n\n对于每个测试用例、每个 $n \\in \\{4,8,16,32,64\\}$ 以及每种收益（普通看涨期权和数字看涨期权），计算数值近似价格与精确解析价格之间的绝对误差。您的程序必须按如下方式将所有结果汇总到单行输出中。对于每个测试用例，按 $1,2,3$ 的顺序，首先按 $n$ 的升序列出 $n=4, 8, 16, 32, 64$ 时普通看涨期权的 5 个绝对误差，然后列出相同 $n$ 值下数字看涨期权的 5 个绝对误差。将这三个测试用例的序列连接成一个单一列表。\n\n最终输出格式：您的程序应生成单行内容，其中包含一个浮点数列表，顺序完全按照规定，用方括号括起来，各项之间用逗号分隔，例如 $[a_1,a_2,\\dots,a_{30}]$。", "solution": "所提出的问题是有效的。这是一个适定且有科学依据的计算金融问题，需要将标准数值方法应用于一个典型模型。我将提供一个完整的解决方案。\n\n任务是使用数值求积法计算欧式普通看涨期权和欧式数字看涨期权的价格，并根据精确的 Black-Scholes 解析公式评估该方法的准确性。\n\n在风险中性框架下，衍生证券在时间 $t=0$ 的价格是其未来收益的贴现期望值。对于在时间 $T$ 发生且是终端资产价格 $S_T$ 的函数的收益，其价格 $V_0$ 由以下公式给出：\n$$\nV_0 = e^{-rT} \\mathbb{E}^{\\mathbb{Q}} [ \\text{Payoff}(S_T) ]\n$$\n其中 $r$ 是恒定的无风险利率，$T$ 是到期时间，期望 $\\mathbb{E}^{\\mathbb{Q}}$ 是在风险中性测度 $\\mathbb{Q}$ 下计算的。终端资产价格 $S_T$ 被建模为对数正态随机变量：\n$$\nS_T = S_0 \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T} Z \\right)\n$$\n其中 $Z$ 是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0,1)$。\n\n该期望可以表示为关于标准正态概率密度函数 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$ 的积分。\n对于一个通用的收益函数 $P(S_T)$，其期望为：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[P(S_T)] = \\int_{-\\infty}^{\\infty} P(S_T(z)) \\phi(z) dz\n$$\n其中 $S_T(z)$ 是作为随机变量 $Z$ 的实现值 $z$ 的函数的终端价格。\n\n对于普通看涨期权，其收益为 $\\max\\{S_T - K, 0\\}$，其价格 $C$ 为：\n$$\nC = e^{-rT} \\int_{-\\infty}^{\\infty} \\max\\{S_T(z) - K, 0\\} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz\n$$\n对于数字看涨期权，其收益为 $\\mathbf{1}\\{S_T > K\\}$，其价格 $D$ 为：\n$$\nD = e^{-rT} \\int_{-\\infty}^{\\infty} \\mathbf{1}\\{S_T(z) > K\\} \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz\n$$\n\n为了对这些积分进行数值近似，我们采用 Gauss-Hermite 求积法。该方法专为形如 $\\int_{-\\infty}^{\\infty} e^{-x^2} g(x) dx$ 的积分而设计。$n$ 点求积法则由下式给出：\n$$\n\\int_{-\\infty}^{\\infty} e^{-x^2} g(x) dx \\approx \\sum_{i=1}^n w_i g(x_i)\n$$\n其中 $x_i$ 是 $n$ 阶物理学家 Hermite 多项式 $H_n(x)$ 的根（节点），$w_i$ 是相关的权重。\n\n我们的积分涉及权重函数 $\\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2}$，而不是 $e^{-x^2}$。因此需要进行变量替换。设 $z = \\sqrt{2}x$，这意味着 $dz = \\sqrt{2}dx$。项 $\\phi(z)dz$ 的变换如下：\n$$\n\\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz = \\frac{1}{\\sqrt{2\\pi}} e^{-(\\sqrt{2}x)^2/2} (\\sqrt{2}dx) = \\frac{\\sqrt{2}}{\\sqrt{2\\pi}} e^{-x^2} dx = \\frac{1}{\\sqrt{\\pi}} e^{-x^2} dx\n$$\n因此，对于函数 $f(z)$，积分变为：\n$$\n\\int_{-\\infty}^{\\infty} f(z) \\frac{1}{\\sqrt{2\\pi}} e^{-z^2/2} dz = \\int_{-\\infty}^{\\infty} f(\\sqrt{2}x) \\frac{1}{\\sqrt{\\pi}} e^{-x^2} dx = \\frac{1}{\\sqrt{\\pi}} \\int_{-\\infty}^{\\infty} f(\\sqrt{2}x) e^{-x^2} dx\n$$\n应用 Gauss-Hermite 求积法则，我们得到近似值：\n$$\n\\mathbb{E}[f(Z)] \\approx \\frac{1}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i f(\\sqrt{2}x_i)\n$$\n其中 $(x_i, w_i)$ 是标准的 $n$ 点 Gauss-Hermite 节点和权重。\n\n对于给定的节点数 $n$，期权价格的数值近似值 $C_n$ 和 $D_n$ 分别为：\n$$\nC_n = \\frac{e^{-rT}}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i \\max\\{S_T(\\sqrt{2}x_i) - K, 0\\}\n$$\n$$\nD_n = \\frac{e^{-rT}}{\\sqrt{\\pi}} \\sum_{i=1}^n w_i \\mathbf{1}\\{S_T(\\sqrt{2}x_i) > K\\}\n$$\n\n为进行基准测试，我们使用 Black-Scholes 公式提供的精确解析解。我们定义项 $d_1$ 和 $d_2$：\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T} = \\frac{\\ln(S_0/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n普通看涨期权的精确价格 $C_{BS}$ 为：\n$$\nC_{BS} = S_0 \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数（CDF）。\n\n数字看涨期权的精确价格 $D_{BS}$ 对应于期权以价内状态结束的贴现概率，即 $\\mathbb{P}(S_T > K)$。这个概率是 $\\Phi(d_2)$。因此：\n$$\nD_{BS} = e^{-rT} \\Phi(d_2)\n$$\n\n对于给定的 $n$，绝对估值误差计算为数值近似值与解析值之间的绝对差：\n$$\n\\epsilon_C(n) = |C_n - C_{BS}|\n$$\n$$\n\\epsilon_D(n) = |D_n - D_{BS}|\n$$\n\n对于每个测试用例，算法按以下步骤进行：\n1. 使用所提供的参数计算解析价格 $C_{BS}$ 和 $D_{BS}$。\n2. 对于每个指定的节点数 $n \\in \\{4, 8, 16, 32, 64\\}$：\n    a. 获取 $n$ 点 Gauss-Hermite 节点 $\\{x_i\\}$ 和权重 $\\{w_i\\}$。\n    b. 计算标准正态积分对应的节点 $\\{z_i = \\sqrt{2}x_i\\}$。\n    c. 在这些节点上评估终端价格 $\\{S_T(z_i)\\}$。\n    d. 在每个节点上计算两种期权类型的收益。\n    e. 通过执行加权求和并乘以 $e^{-rT}/\\sqrt{\\pi}$ 来计算数值近似价格 $C_n$ 和 $D_n$。\n    f. 计算绝对误差 $\\epsilon_C(n)$ 和 $\\epsilon_D(n)$。\n3. 按照问题陈述中的规定收集并排序误差。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes absolute errors in option pricing using Gauss-Hermite quadrature\n    against analytical Black-Scholes formulas for a set of test cases.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S0, K, r, sigma, T)\n        (100.0, 100.0, 0.03, 0.2, 1.0),\n        (100.0, 140.0, 0.03, 0.2, 1.0),\n        (100.0, 100.0, 0.03, 0.2, 0.01),\n    ]\n\n    # Number of quadrature points to test\n    n_values = [4, 8, 16, 32, 64]\n\n    # List to store all computed errors in the required order\n    all_results = []\n\n    def black_scholes_call(S0, K, r, sigma, T):\n        \"\"\"Analytical Black-Scholes price for a European vanilla call.\"\"\"\n        if T == 0:\n            return np.maximum(S0 - K, 0)\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def black_scholes_digital_call(S0, K, r, sigma, T, d2):\n        \"\"\"Analytical Black-Scholes price for a European digital call.\"\"\"\n        if T == 0:\n            return 1.0 if S0 > K else 0.0\n        price = np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    for S0, K, r, sigma, T in test_cases:\n        # Calculate d2 once, as it's used in both analytical formulas\n        if T > 0:\n            d2 = (np.log(S0 / K) + (r - 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        else:\n            d2 = np.inf if S0 > K else -np.inf # Edge case an T=0\n\n        # 1. Calculate analytical benchmark prices\n        C_bs = black_scholes_call(S0, K, r, sigma, T)\n        D_bs = black_scholes_digital_call(S0, K, r, sigma, T, d2)\n        \n        call_errors_case = []\n        digital_errors_case = []\n\n        # 2. Loop through number of quadrature nodes\n        for n in n_values:\n            # a. Get Gauss-Hermite nodes and weights\n            x_i_herm, w_i_herm = np.polynomial.hermite.hermgauss(n)\n            \n            # b. Change of variables for standard normal integral N(0,1)\n            # z ~ N(0,1), integral is against (1/sqrt(2pi)) * exp(-z^2/2)\n            # We use x for Hermite integral, against exp(-x^2)\n            # Change of variables: z = sqrt(2)*x => dz = sqrt(2)*dx\n            # (1/sqrt(2pi))exp(-z^2/2)dz = (1/sqrt(pi))exp(-x^2)dx\n            # So, our integral approx is (1/sqrt(pi)) * sum(w_i * f(sqrt(2)*x_i))\n            z_nodes = np.sqrt(2.0) * x_i_herm\n            \n            # c. Evaluate terminal price at each node\n            drift = (r - 0.5 * sigma**2) * T\n            diffusion = sigma * np.sqrt(T) * z_nodes\n            S_T_nodes = S0 * np.exp(drift + diffusion)\n            \n            # d. Compute payoffs at each node\n            call_payoff = np.maximum(S_T_nodes - K, 0)\n            digital_payoff = (S_T_nodes > K).astype(float)\n            \n            # e. Calculate numerical prices\n            # The scaling factor is exp(-rT)/sqrt(pi)\n            scale_factor = np.exp(-r * T) / np.sqrt(np.pi)\n            C_n = scale_factor * np.sum(w_i_herm * call_payoff)\n            D_n = scale_factor * np.sum(w_i_herm * digital_payoff)\n            \n            # f. Compute and store absolute errors\n            call_errors_case.append(abs(C_n - C_bs))\n            digital_errors_case.append(abs(D_n - D_bs))\n            \n        # 3. Collect and order results for this test case\n        all_results.extend(call_errors_case)\n        all_results.extend(digital_errors_case)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2396797"}, {"introduction": "在我们理解了非光滑函数对高斯求积法构成的挑战后，本练习将介绍一种强大的解决方案：分段求积。您将处理一个在特定点不可导的支付函数，这类函数在奇异期权定价中很常见。通过本练习 [@problem_id:2396765]，您将学习如何策略性地在奇点处分割积分区间，从而让高精度的求积法则在每个光滑的子区间上都能有效发挥作用，最终获得精确的估值结果。", "problem": "要求您在风险中性、对数正态资产定价环境下，使用分段高斯求积法对一个或有债权进行稳健的数值估值，以处理其不可微的支付函数。考虑一个标的资产，其初始水平为 $S_0$，连续复利无风险利率为 $r$，波动率为 $\\sigma$，到期日为 $T$。在 Black–Scholes 模型的标准无套利假设下，时间 $T$ 的资产价格 $S_T$ 服从对数正态分布，其中\n- $S_T = S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, Z\\right)$,\n- $Z \\sim \\mathcal{N}(0,1)$ 且独立于 $S_0$。\n\n设支付函数为 $f(S_T) = \\lvert S_T - K \\rvert^{1/2}$，其中 $K$ 是一个固定的行权价。在时间 $t=0$ 的无套利价值是其折现的风险中性期望：\n$$\nV(S_0,K,r,\\sigma,T) = e^{-rT}\\,\\mathbb{E}\\left[\\lvert S_T - K \\rvert^{1/2}\\right].\n$$\n\n您的任务是：\n- 从风险中性估值原理和 Black–Scholes 假设下 $S_T$ 的对数正态性出发。将期望表述为对标准正态变量 $Z$（其密度为 $\\varphi(z)$）的积分，确保该积分对于 $S_T = K$ 处的不可微点是适定的。\n- 通过条件 $S_T(z^\\star) = K$，找出被积函数中出现不可微性的唯一奇点 $z^\\star$（如果存在）。解释该点如何划分 $z$ 的积分域。\n- 基于高斯-勒让德法则，在标准正态变量 $Z$ 的截断对称区间 $[-L,L]$ 上，开发一种在 $z^\\star$ 处分割区间的分段高斯求积方法。使用从标准高斯-勒让德节点 $[-1,1]$ 到每个子区间的映射。您的设计必须讨论截断水平 $L$ 的选择，以控制 $[-L,L]$ 之外 $\\lvert S_T - K \\rvert^{1/2}$ 所贡献的尾部误差。\n- 实现数值近似\n$$\nV \\approx e^{-rT}\\int_{-L}^{L} \\lvert S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T}\\, z\\right) - K \\rvert^{1/2} \\, \\varphi(z)\\, dz,\n$$\n使用分段高斯-勒让德求积法，当 $z^\\star \\in (-L,L)$ 时在 $z^\\star$ 处分割积分，否则在 $[-L,L]$ 上应用单个高斯-勒让德求积。此处，$\\varphi(z)$ 表示标准正态密度函数。您必须实现从其在 $[-1,1]$ 上的节点和权重出发，在任意有限区间 $[a,b]$ 上应用高斯-勒让德求积的一般映射公式，并且您的程序必须根据第一性原理正确处理 $\\sigma = 0$ 和 $T = 0$ 的边界情况。\n- 程序必须完全自包含。不要读取任何输入。仅使用下面指定的参数并打印所需的输出。\n\n参数约定和单位：\n- 所有利率和波动率都应视为无量纲小数（例如，$r = 0.05$ 表示每年 $0.05$，而不是 $5$ %）。\n- 不存在角度；任何地方都不要使用度或弧度。\n- 在此问题中，货币量是无单位的；将值报告为纯数字。\n\n您的实现必须使用以下测试套件。对于每种情况，使用截断水平 $L = 8$ 的分段高斯-勒让德方法计算近似值 $V$，其中左子区间使用 $n_{\\text{left}} = 64$ 个节点，右子区间使用 $n_{\\text{right}} = 64$ 个节点（如果由于分割点位于 $[-L,L]$ 之外导致某个子区间为空，则在 $[-L,L]$ 上使用 $n_{\\text{left}} + n_{\\text{right}}$ 个节点的单个高斯-勒让德法则）：\n\n- 情况 1：$(S_0, K, r, \\sigma, T) = (100, 100, 0.02, 0.2, 1)$。\n- 情况 2：$(S_0, K, r, \\sigma, T) = (100, 20, 0.01, 0.3, 1.5)$。\n- 情况 3：$(S_0, K, r, \\sigma, T) = (100, 100, 0.0, 0.25, 10^{-6})$。\n- 情况 4：$(S_0, K, r, \\sigma, T) = (80, 120, 0.03, 1.0, 2.0)$。\n- 情况 5：$(S_0, K, r, \\sigma, T) = (100, 100, 0.05, 0.05, 1.0)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔结果列表。该列表必须根据上述五种情况排序，并且每个值必须四舍五入到恰好 $10$ 位小数。例如，一个有效的输出行应如下所示：\n$[v_1,v_2,v_3,v_4,v_5]$\n其中每个 $v_i$ 是一个小数点后恰好有 $10$ 位数字的浮点数。", "solution": "所述问题是有效的。这是一个计算金融学中的适定问题，基于标准的 Black-Scholes 资产定价模型。该问题是客观、自包含的，并为唯一的数值解提供了所有必要的数据和定义。核心任务涉及对一个具有非标准支付函数 $f(S_T) = \\lvert S_T - K \\rvert^{1/2}$ 的欧式或有债权进行估值，该函数引入了不可微性。所规定的数值方法——分段高斯求积法，是处理此类被积函数以确保数值精度的恰当且标准的技术。不存在科学或逻辑上的矛盾。\n\n我们基于第一性原理给出一个完整的解法。\n\n**1. 估值问题的积分表述**\n\n或有债权的无套利价值 $V$ 是其支付函数的折现风险中性期望：\n$$\nV = e^{-rT} \\mathbb{E}\\left[ f(S_T) \\right] = e^{-rT} \\mathbb{E}\\left[ \\lvert S_T - K \\rvert^{1/2} \\right]\n$$\n在 Black-Scholes 模型假设下，期末资产价格 $S_T$ 由下式给出：\n$$\nS_T = S_0 \\exp\\left( (r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} Z \\right)\n$$\n其中 $Z$ 是一个标准正态随机变量，$Z \\sim \\mathcal{N}(0,1)$。该期望可以写成关于 $Z$ 的概率密度函数 $\\varphi(z)$ 的积分，其中 $\\varphi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$。设 $h(z)$ 为关于变量 $z$ 的被积函数：\n$$\nh(z) = \\left| S_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z\\right) - K \\right|^{1/2} \\varphi(z)\n$$\n则该债权的价值为\n$$\nV = e^{-rT} \\int_{-\\infty}^{\\infty} h(z) dz\n$$\n\n**2. 被积函数与不可微性分析**\n\n函数 $h(z)$ 在绝对值函数的参数为零处不可微。该点对应于 $S_T = K$。函数 $g(x) = |x|^{1/2}$ 的导数为 $g'(x) = \\frac{1}{2\\sqrt{|x|}}\\text{sgn}(x)$，在 $x=0$ 处无定义。如果天真地在整个定义域上应用标准数值积分方法（如高斯求积），这个导数中的奇点会显著降低其收敛速度。\n\n为了根据积分变量 $z$ 定位该点，我们令 $S_T(z) = K$：\n$$\nS_0 \\exp\\left((r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z\\right) = K\n$$\n在 $\\sigma > 0$ 和 $T > 0$ 的条件下，解出 $z$：\n$$\n(r - \\tfrac{1}{2}\\sigma^2)T + \\sigma \\sqrt{T} z = \\ln(K/S_0)\n$$\n$$\n\\sigma \\sqrt{T} z = \\ln(K/S_0) - (r - \\tfrac{1}{2}\\sigma^2)T\n$$\n这给出了一个唯一的不可微点，我们将其表示为 $z^\\star$：\n$$\nz^\\star = \\frac{\\ln(K/S_0) - (r - \\tfrac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}\n$$\n该表达式在标准 Black-Scholes 期权定价公式中等价于 $-d_2$。为使问题非平凡，我们假设 $S_0 > 0$ 和 $K > 0$。\n\n**3. 分段高斯求积法**\n\n为了获得积分的精确数值近似，我们采用一个两步策略：积分域截断和分段求积。\n\n首先，我们将无限积分域 $(-\\infty, \\infty)$ 截断为一个有限的对称区间 $[-L, L]$。标准正态密度 $\\varphi(z)$ 随着 $|z| \\to \\infty$ 而迅速衰减。问题中指定的 $L=8$ 的选择确保了尾部被忽略的概率质量约为 $2\\Phi(-8) \\approx 1.24 \\times 10^{-15}$，这对于大多数金融应用来说是微不足道的。因此，债权的价值可近似为：\n$$\nV \\approx e^{-rT} \\int_{-L}^{L} h(z) dz\n$$\n\n其次，为了处理在 $z^\\star$ 处的不可微性，我们在此点处划分积分区间 $[-L, L]$。如果 $z^\\star \\in (-L, L)$，积分被分成两部分：\n$$\n\\int_{-L}^{L} h(z) dz = \\int_{-L}^{z^\\star} h(z) dz + \\int_{z^\\star}^{L} h(z) dz\n$$\n在每个子区间 $[-L, z^\\star]$ 和 $[z^\\star, L]$ 上，被积函数是无穷可微的。这种光滑性使得高斯-勒让德求积能够达到其特有的指数收敛速度。\n\n如果 $z^\\star \\notin (-L, L)$，则被积函数在整个区间 $[-L, L]$ 上是光滑的，可以在整个区间上应用单个高斯-勒让德求积法则。\n\n高斯-勒让德求积将标准区间 $[-1,1]$ 上的积分近似为加权和：\n$$\n\\int_{-1}^{1} f(x) dx \\approx \\sum_{i=1}^{n} w_i f(x_i)\n$$\n其中 $x_i$ 是节点（第 $n$ 阶勒让德多项式的根），$w_i$ 是对应的权重。要将其应用于一般区间 $[a,b]$，我们使用线性变换 $z(x) = \\frac{b-a}{2} x + \\frac{a+b}{2}$，其雅可比行列式为 $dz/dx = \\frac{b-a}{2}$。积分变为：\n$$\n\\int_{a}^{b} h(z) dz = \\int_{-1}^{1} h\\left(\\frac{b-a}{2}x + \\frac{a+b}{2}\\right) \\frac{b-a}{2} dx \\approx \\frac{b-a}{2} \\sum_{i=1}^{n} w_i h\\left(\\frac{b-a}{2}x_i + \\frac{a+b}{2}\\right)\n$$\n该公式应用于每个子区间，使用指定数量的节点（$n_{\\text{left}}=64$ 和 $n_{\\text{right}}=64$）。\n\n**4. 退化情况的处理**\n\n问题要求处理 $\\sigma=0$ 或 $T=0$ 的情况。在任一情况下，随机项 $\\sigma\\sqrt{T}Z$ 都消失。期末资产价格 $S_T$ 变为确定性的：\n$$\nS_T = S_0 \\exp(rT)\n$$\n估值积分坍缩，因为期望变得平凡：\n$$\n\\mathbb{E}\\left[ \\lvert S_T - K \\rvert^{1/2} \\right] = \\lvert S_0 e^{rT} - K \\rvert^{1/2}\n$$\n此时，债权的价值由一个简单的封闭形式表达式给出：\n$$\nV = e^{-rT} \\lvert S_0 e^{rT} - K \\rvert^{1/2}\n$$\n我们的实现必须能正确识别这些情况并应用此公式，从而绕过数值积分。\n\n**5. 算法总结**\n\n对于给定的参数集 $(S_0, K, r, \\sigma, T)$：\n1. 检查退化情况：如果 $T \\approx 0$ 或 $\\sigma \\approx 0$，使用确定性公式计算 $V$。\n2. 否则，定义完整的被积函数 $h(z) = \\left| S_T(z) - K \\right|^{1/2} \\varphi(z)$。\n3. 计算分割点 $z^\\star$。\n4. 设置截断水平 $L=8$。\n5. 如果 $z^\\star \\in (-L, L)$：\n    a. 在 $[-L, z^\\star]$ 上使用 $n_{\\text{left}}=64$ 个节点进行高斯-勒让德求积。\n    b. 在 $[z^\\star, L]$ 上使用 $n_{\\text{right}}=64$ 个节点进行高斯-勒让德求积。\n    c. 总积分是(a)和(b)的结果之和。\n6. 如果 $z^\\star \\notin (-L, L)$：\n    a. 在单个区间 $[-L, L]$ 上使用 $n=n_{\\text{left}} + n_{\\text{right}} = 128$ 个节点进行高斯-勒让德求积。\n7. 最终价值为 $V = e^{-rT} \\times (\\text{总积分})$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import roots_legendre\n\ndef solve():\n    \"\"\"\n    Computes the value of a contingent claim with a non-differentiable payoff\n    using piecewise Gaussian quadrature, as specified in the problem statement.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100, 100, 0.02, 0.2, 1.0),\n        (100, 20, 0.01, 0.3, 1.5),\n        (100, 100, 0.0, 0.25, 1e-6),\n        (80, 120, 0.03, 1.0, 2.0),\n        (100, 100, 0.05, 0.05, 1.0),\n    ]\n\n    L = 8.0\n    n_left = 64\n    n_right = 64\n    \n    results = []\n\n    def gauss_legendre_quad(func, a, b, n):\n        \"\"\"\n        Performs Gauss-Legendre quadrature of a function 'func' over [a, b] using 'n' nodes.\n        Handles the case where a = b, returning 0.\n        \"\"\"\n        if np.isclose(a, b):\n            return 0.0\n        \n        nodes, weights = roots_legendre(n)\n        \n        # Map nodes from [-1, 1] to [a, b]\n        mapped_nodes = 0.5 * (b - a) * nodes + 0.5 * (a + b)\n        \n        # Evaluate the function at the mapped nodes\n        func_values = func(mapped_nodes)\n        \n        # Calculate the integral using the quadrature formula\n        integral = 0.5 * (b - a) * np.sum(weights * func_values)\n        \n        return integral\n\n    for case in test_cases:\n        S0, K, r, sigma, T = case\n\n        # Handle degenerate cases: deterministic asset price\n        if np.isclose(T, 0.0) or np.isclose(sigma, 0.0):\n            S_T = S0 * np.exp(r * T)\n            payoff = np.sqrt(np.abs(S_T - K))\n            value = np.exp(-r * T) * payoff\n            results.append(value)\n            continue\n            \n        # Define the integrand h(z) = |S_T(z) - K|^(1/2) * phi(z)\n        # where phi(z) is the standard normal PDF.\n        sqrt_T = np.sqrt(T)\n        drift = (r - 0.5 * sigma**2) * T\n        def integrand(z):\n            S_T = S0 * np.exp(drift + sigma * sqrt_T * z)\n            payoff_sqrt = np.sqrt(np.abs(S_T - K))\n            phi_z = (1.0 / np.sqrt(2.0 * np.pi)) * np.exp(-0.5 * z**2)\n            return payoff_sqrt * phi_z\n\n        # Find the non-differentiable point z_star\n        # where S_T(z_star) = K\n        #\n        # Note: We must ensure K/S0 > 0, which is true for all test cases.\n        # Catches potential warnings for log(0) if K is 0, though not in test data.\n        if K == 0 or S0 == 0:\n            # Fallback for ill-posed inputs not in test data\n            z_star = np.nan \n        else:\n            numerator = np.log(K / S0) - drift\n            denominator = sigma * sqrt_T\n            z_star = numerator / denominator\n\n        # Perform numerical integration\n        total_integral = 0.0\n        if -L  z_star  L:\n            # Piecewise quadrature: split at the singularity point\n            integral_left = gauss_legendre_quad(integrand, -L, z_star, n_left)\n            integral_right = gauss_legendre_quad(integrand, z_star, L, n_right)\n            total_integral = integral_left + integral_right\n        else:\n            # Singularity is outside the integration domain; use a single rule\n            total_integral = gauss_legendre_quad(integrand, -L, L, n_left + n_right)\n\n        # Discount the expected payoff to get the final value\n        value = np.exp(-r * T) * total_integral\n        results.append(value)\n\n    # Format the final output string as required\n    output_str = f\"[{','.join([f'{v:.10f}' for v in results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2396765"}]}