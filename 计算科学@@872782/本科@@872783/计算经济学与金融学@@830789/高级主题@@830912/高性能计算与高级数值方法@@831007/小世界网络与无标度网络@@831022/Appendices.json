{"hands_on_practices": [{"introduction": "本练习将带你亲手实践定义小世界网络的核心指标：高聚类系数和短平均路径长度。你需要通过向一个高度结构化的初始网络中逐步添加“捷径”边，来确定性地构建一个小世界网络，并在此过程中追踪关键量化指标 $\\gamma$ 和 $\\lambda$ 的变化。这个练习将帮助你具体理解，为何仅仅几条长程连接就能极大地改变一个网络的全局特性 [@problem_id:2431664]。", "problem": "您需要形式化并解决以下决策问题：一个模块化的贸易网络（一个风格化的区域化世界经济体）在添加国际捷径贸易协定后，何时会成为一个小世界网络。该网络包含 $M$ 个不相交的区域。每个区域包含 $n$ 个经济体（节点），这些节点排列在一个环状晶格上，其中每个节点都连接到其在同一区域内两侧最近的 $k$ 个邻居（因此每个节点在其区域内的度为 $2k$）。从这个区域内没有跨区域连接的基线开始，您可以添加无向的国际捷径，每个捷径连接一个区域中的一个节点到另一个不同区域中的一个节点。您必须确定，为满足下文定义的小世界准则，使用指定的构造性策略（该策略消除了随机性并确保了唯一答案），必须添加的此类捷径的最小数量。\n\n基本依据与定义：\n- 设 $G$ 是一个包含 $N = M \\cdot n$ 个节点的简单无向图，其邻接关系由 $A$ 编码。节点 $i$ 的度为 $d_i$。\n- 平均局部聚类系数 $C$ 是对所有节点的邻居之间已实现连接比例的算术平均值：对于节点 $i$，如果 $d_i \\lt 2$，则令 $C_i = 0$；否则，$C_i = \\dfrac{2 t_i}{d_i(d_i - 1)}$，其中 $t_i$ 是节点 $i$ 的邻居之间的边数。则 $C = \\dfrac{1}{N} \\sum_{i=1}^N C_i$。\n- 平均最短路径长度 $L$ 是在同一连通分量中所有无序的不同节点对的图距离 $d(i,j)$ 的平均值，即 $L = \\dfrac{2}{N(N-1)} \\sum_{1 \\le i \\lt j \\le N} d(i,j)$，仅当 $G$ 是连通图时有定义。\n- 参考随机网络是具有相同节点数 $N$ 和相同期望边数 $E$ 的 Erdős–Rényi 模型。其连接概率为 $p = \\dfrac{2E}{N(N-1)}$，其期望聚类为 $C_{\\text{rand}} = p$。对于足够大的 $N$ 和平均度 $z = \\dfrac{2E}{N}$ 且 $z \\gt 1$ 的情况，期望平均最短路径长度可以很好地近似为 $L_{\\text{rand}} \\approx \\dfrac{\\ln N}{\\ln z}$。这些是广泛使用、经过充分检验的用于基准测试小世界结构的近似值。\n- 定义 $\\gamma = \\dfrac{C}{C_{\\text{rand}}}$ 和 $\\lambda = \\dfrac{L}{L_{\\text{rand}}}$。\n\n待实现的小世界准则：\n- 如果网络同时满足 $\\gamma \\ge g_{\\min}$ 和 $\\lambda \\le \\ell_{\\max}$，则该网络被声明为小世界网络，其中给定阈值 $g_{\\min} \\gt 1$ 且 $\\ell_{\\max}$ 接近于 $1$。\n\n捷径放置策略（确定性与构造性）：\n- 从 $M$ 个区域性环状晶格的不相交并集开始（无国际边）。\n- 迭代地一次添加一个国际捷径，并记录已添加的数量。在每次迭代中：\n  1. 如果图不连通，添加一个捷径，连接字典序最小的连通分量中索引最小的节点，到下一个字典序最小的连通分量中索引最小的节点。此步骤在迭代中重复，直到图变为连通。这保证了在添加了 $C-1$ 条捷径后图是连通的，其中 $C$ 是该次迭代时的连通分量数。\n  2. 如果图是连通的，计算所有节点对之间的最短路径距离。在所有属于不同区域且尚未邻接的无序节点对 $(i,j)$ 中，选择图距离最大的那一对。通过字典序最小的对来打破平局。添加这个国际捷径并继续。\n- 每次添加捷径后，重新计算 $C$、$L$、$C_{\\text{rand}}$、$L_{\\text{rand}}$、$\\gamma$ 和 $\\lambda$。当小世界准则首次被满足时，立即停止。\n\n目标：\n- 对于每个测试用例，计算（在上述策略下）为使网络首次满足 $\\gamma \\ge g_{\\min}$ 和 $\\lambda \\le \\ell_{\\max}$ 所需添加的最小捷径数量。\n- 如果即使在添加了所有可能的国际捷径（即来自不同区域的每对节点都由一条边连接）之后，准则仍然无法满足，则对该测试用例返回 $-1$。\n\n输入模型与单位：\n- 没有外部输入；您的程序必须按规定实现构造和评估。没有物理单位。所有角度（如果有）都应以弧度处理，尽管本题没有直接出现。\n\n测试套件与参数：\n- 案例 1：$M = 4$，$n = 12$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.3$。\n- 案例 2：$M = 3$，$n = 16$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.25$。\n- 案例 3：$M = 5$，$n = 8$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.3$。\n- 案例 4：$M = 2$，$n = 24$，$k = 3$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.25$。\n\n输出规范：\n- 您的程序应产生单行输出，其中包含测试用例的结果，格式为方括号内的逗号分隔列表，例如 $[r_1,r_2,r_3,r_4]$，其中每个 $r_i$ 是表示测试用例 $i$ 的最小国际捷径数量的整数（如果无法实现则为 $-1$）。", "solution": "对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n- **网络结构**:\n    - $M$：不相交区域的数量。\n    - $n$：每个区域的经济体（节点）数量。\n    - 总节点数 $N = M \\cdot n$。\n    - 每个区域是一个环状晶格，其中每个节点都连接到其两侧最近的 $k$ 个邻居。初始区域内度为 $2k$。\n    - 最初，区域之间没有连接。\n- **网络度量**:\n    - $A$：简单无向图 $G$ 的邻接矩阵。\n    - $d_i$：节点 $i$ 的度。\n    - 局部聚类系数：对于 $d_i \\ge 2$，为 $C_i = \\dfrac{2 t_i}{d_i(d_i - 1)}$，其中 $t_i$ 是节点 $i$ 的邻居之间的边数。如果 $d_i  2$，则 $C_i=0$。\n    - 平均局部聚类系数：$C = \\dfrac{1}{N} \\sum_{i=1}^N C_i$。\n    - 平均最短路径长度：$L = \\dfrac{2}{N(N-1)} \\sum_{1 \\le i \\lt j \\le N} d(i,j)$，为连通图定义。\n- **参考网络 (Erdős–Rényi)**:\n    - 具有相同节点数 $N$ 和边数 $E$。\n    - 期望聚类系数：$C_{\\text{rand}} = p = \\dfrac{2E}{N(N-1)}$。\n    - 近似期望平均最短路径长度：对于平均度 $z = \\dfrac{2E}{N} > 1$，$L_{\\text{rand}} \\approx \\dfrac{\\ln N}{\\ln z}$。\n- **小世界准则**:\n    - $\\gamma = \\dfrac{C}{C_{\\text{rand}}} \\ge g_{\\min}$ 且 $\\lambda = \\dfrac{L}{L_{\\text{rand}}} \\le \\ell_{\\max}$。\n- **捷径放置策略（确定性）**:\n    - 从 $M$ 个不相交的环状晶格开始。\n    - 迭代添加一个无向国际捷径。\n    - **如果图不连通**：连接字典序最小的连通分量中索引最小的节点，到下一个字典序最小的连通分量中索引最小的节点。\n    - **如果图是连通的**：计算所有节点对之间的最短路径。在来自不同区域且尚未邻接的节点对 $(i, j)$ 中，添加一个捷径，该捷径连接具有最大图距离的节点对。通过选择字典序最小的对来打破平局。\n- **目标**:\n    - 找出首次满足小世界准则所需的最少捷径数。\n    - 如果在添加了所有可能的国际捷径后仍无法满足准则，则返回 $-1$。\n- **测试用例**:\n    - 案例 1：$M = 4$，$n = 12$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.3$。\n    - 案例 2：$M = 3$，$n = 16$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.25$。\n    - 案例 3：$M = 5$，$n = 8$，$k = 2$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.3$。\n    - 案例 4：$M = 2$，$n = 24$，$k = 3$，$g_{\\min} = 1.5$，$\\ell_{\\max} = 1.25$。\n\n### 步骤2：使用提取的信息进行验证\n根据既定标准对问题的有效性进行评估。\n\n1.  **科学依据**：该问题牢固地植根于网络科学领域，这是计算社会科学和STEM中一个成熟的学科。所有概念——环状晶格、聚类系数、最短路径长度、Erdős–Rényi随机图和Watts-Strogatz小世界模型——都是标准的、严格定义的。$L_{\\text{rand}}$ 和 $C_{\\text{rand}}$ 的近似值在文献中是标准的。该问题不包含任何伪科学或事实错误。\n\n2.  **良构性**：该问题是良构的。目标是在一个构造性过程中找到最少的步骤数。该过程本身是完全确定性的，由一个清晰、明确的捷径放置策略和显式的打破平局规则定义。这保证了对于给定的参数集，添加的捷径序列和最终结果是唯一的。终止条件也是精确的。\n\n3.  **客观性**：该问题以精确、定量和无偏见的语言陈述。所有定义都是形式化的。成功标准是客观的数学不等式。\n\n4.  **完整性**：该问题是自包含的。所有必要的参数（$M, n, k, g_{\\min}, \\ell_{\\max}$）和定义都已提供。不需要外部信息。\n\n5.  **一致性与可行性**：设置在逻辑上是一致的。初始状态是一组不相交的图。迭代规则描述了如何修改图。正确地指出了计算 $L$ 的条件（图的连通性）。测试用例中的参数是合理的，没有出现任何直接的矛盾或不可行性。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**。这是一个基于既定科学原理、定义明确的计算问题。将提供一个解决方案。\n\n### 解决方案\n该问题要求我们模拟一个网络演化的确定性过程，并确定网络首次满足指定的小世界准则的时刻。解决方案是过程性的，需要细致地遵循指定的规则。\n\n**1. 图的初始化**\n首先，我们构建初始图。总节点数为 $N = M \\cdot n$。我们可以使用一个 $N \\times N$ 的邻接矩阵 $A$ 来表示图。节点索引从 $0$ 到 $N-1$，其中索引为 $i$ 的节点属于区域 $\\lfloor i/n \\rfloor$，其局部索引为 $i \\pmod n$。\n初始图由 $M$ 个不相交的环状晶格组成。对于每个区域 $r \\in \\{0, \\dots, M-1\\}$ 和该区域内的每个节点 $i$，我们建立与其两侧最近的 $k$ 个邻居的边。具体来说，全局索引为 $u = r \\cdot n + i$ 的节点与节点 $v = r \\cdot n + ((i \\pm s) \\pmod n)$ 相连，其中 $s \\in \\{1, \\dots, k\\}$。\n\n**2. 迭代添加捷径**\n我们通过一个循环进行，每次迭代添加一个捷径，并检查小世界准则。设 `num_shortcuts` 为已添加边的计数，初始化为 $0$。\n\n在每一步中，我们必须首先评估图的连通性。这可以通过广度优先搜索（BFS）或深度优先搜索（DFS）来识别连通分量。\n\n- **如果图不连通**（多于一个分量）：策略规定添加一条边来连接两个分量。分量按其最小节点索引进行字典序排序。在第一个分量的最小索引节点和第二个分量的最小索引节点之间添加一个捷径。\n\n- **如果图是连通的**：策略规定添加一个“长程”捷径。这需要计算所有节点对之间的最短路径（APSP）。对于此问题中的图规模，复杂度为 $O(N^3)$ 的Floyd-Warshall算法是合适的。计算出距离矩阵 $D$ 后，我们识别出所有候选对 $(i, j)$ 的集合，其中 $i$ 和 $j$ 在不同区域且尚未通过边连接。在这些候选对中，我们选择具有最大最短路径距离 $d(i, j)$ 的那一对。距离上的任何平局都通过选择字典序最小的对 $(i, j)$（其中 $i  j$）来解决。在此选定的对之间添加一个捷径。如果不存在这样的候选对，则意味着所有区域间的连接都已建立。\n\n在确定要连接的对 $(u, v)$ 后，我们更新邻接矩阵（$A_{uv} = A_{vu} = 1$）并递增 `num_shortcuts`。\n\n**3. 准则评估**\n每次添加捷径后，我们评估小世界准则。这仅在图是连通的时才有意义，因为 $L$ 的定义要求如此。\n\n- **连通性检查**：我们必须首先验证图是连通的。如果不是，准则无法满足，我们继续下一次迭代。\n\n- **度量计算**：如果图是连通的，我们计算当前图状态所需的度量。\n    - **总边数 $E$**：这是邻接矩阵中所有元素总和的一半。\n    - **平均聚类系数 $C$**：我们遍历每个节点 $i$。我们找到其邻居集合，并计算它们之间存在的边数 $t_i$。对于度为 $d_i \\ge 2$ 的节点，局部聚类为 $C_i = 2t_i / (d_i(d_i-1))$。平均值 $C$ 是所有 $C_i$ 的均值。\n    - **平均最短路径长度 $L$**：使用为当前图计算的APSP矩阵，我们对所有 $\\binom{N}{2}$ 个不同节点对的距离求和，然后除以这个总对数。\n    - **参考度量 $C_{\\text{rand}}$ 和 $L_{\\text{rand}}$**：这些是使用规定的公式计算的：$z = 2E/N$，$C_{\\text{rand}} = z/(N-1)$，以及 $L_{\\text{rand}} = \\ln(N)/\\ln(z)$。在计算 $\\ln(z)$ 之前，必须确保 $z > 1$。\n\n- **条件检查**：最后，我们计算比率 $\\gamma = C/C_{\\text{rand}}$ 和 $\\lambda = L/L_{\\text{rand}}$。如果 $\\gamma \\ge g_{\\min}$ 且 $\\lambda \\le \\ell_{\\max}$，则过程终止。`num_shortcuts` 的当前值就是解。\n\n**4. 终止**\n迭代过程通过以下两种方式之一终止：\n1. 满足小世界准则，返回捷径的数量。\n2. 循环完成了所有可能的区域间捷径添加，但仍未满足准则。在连通阶段，当不同区域之间不再有非邻接的对时，就会检测到这种情况。在这种情况下，返回 $-1$。\n\n为每个测试用例实现这个完整的、确定性的算法，以找到所需的结果。", "answer": "```python\nimport numpy as np\nfrom collections import deque\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # M, n, k, g_min, l_max\n        (4, 12, 2, 1.5, 1.3),\n        (3, 16, 2, 1.5, 1.25),\n        (5, 8, 2, 1.5, 1.3),\n        (2, 24, 3, 1.5, 1.25),\n    ]\n\n    results = []\n    for case in test_cases:\n        M, n, k, g_min, l_max = case\n        result = _solve_one_case(M, n, k, g_min, l_max)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef _solve_one_case(M, n, k, g_min, l_max):\n    \"\"\"\n    Solves a single instance of the problem.\n    \"\"\"\n    N = M * n\n\n    # 1. Build initial adjacency matrix for M disjoint ring lattices\n    adj = np.zeros((N, N), dtype=int)\n    for r in range(M):\n        base_idx = r * n\n        for i in range(n):\n            u = base_idx + i\n            for s in range(1, k + 1):\n                v1 = base_idx + ((i + s) % n)\n                v2 = base_idx + ((i - s + n) % n)\n                adj[u, v1] = 1\n                adj[u, v2] = 1\n\n    num_shortcuts = 0\n    max_possible_shortcuts = (M * (M - 1) // 2) * (n * n)\n\n    while num_shortcuts = max_possible_shortcuts:\n        # A. Determine which shortcut to add based on the policy\n        components = _find_components(adj, N)\n        u, v = -1, -1\n\n        if len(components) > 1:\n            # Policy for disconnected graphs\n            sorted_components = sorted([sorted(list(c)) for c in components])\n            u, v = sorted_components[0][0], sorted_components[1][0]\n        else:\n            # Policy for connected graphs\n            dist = _floyd_warshall(adj, N)\n            \n            candidate_pairs = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if (i // n) != (j // n) and adj[i, j] == 0:\n                        candidate_pairs.append((i, j))\n            \n            if not candidate_pairs:\n                return -1 # No more shortcuts can be added\n\n            max_d = -np.inf\n            best_pairs = []\n            for i_p, j_p in candidate_pairs:\n                d = dist[i_p, j_p]\n                if d > max_d:\n                    max_d = d\n                    best_pairs = [(i_p, j_p)]\n                elif d == max_d:\n                    best_pairs.append((i_p, j_p))\n            \n            # Tie-break by lexicographically smallest pair\n            u, v = min(best_pairs)\n\n        # B. Add the shortcut\n        adj[u, v] = 1\n        adj[v, u] = 1\n        num_shortcuts += 1\n\n        # C. Evaluate the small-world criterion\n        # Only check if graph is connected, which is a prerequisite for L\n        post_add_components = _find_components(adj, N)\n        if len(post_add_components) > 1:\n            continue\n\n        # --- Graph is connected, proceed with metric calculations ---\n        C = _calculate_C(adj, N)\n        \n        current_dist = _floyd_warshall(adj, N)\n        \n        # Check for disconnected sub-pockets (should not happen with find_components check)\n        if np.isinf(current_dist).any():\n            continue\n            \n        L = current_dist[np.triu_indices(N, k=1)].mean()\n\n        num_edges = np.sum(adj) // 2\n        avg_degree = 2 * num_edges / N\n\n        if avg_degree = 1.0:\n            continue\n\n        C_rand = avg_degree / (N - 1)\n        L_rand = np.log(N) / np.log(avg_degree)\n        \n        if C_rand == 0 or L_rand == 0:\n            continue\n\n        gamma = C / C_rand\n        lambda_val = L / L_rand\n\n        if gamma >= g_min and lambda_val = l_max:\n            return num_shortcuts\n            \n    return -1\n\n\ndef _find_components(adj, N):\n    \"\"\"Finds connected components using BFS.\"\"\"\n    visited = set()\n    components = []\n    for i in range(N):\n        if i not in visited:\n            component = set()\n            q = deque([i])\n            visited.add(i)\n            while q:\n                u = q.popleft()\n                component.add(u)\n                neighbors = np.where(adj[u] == 1)[0]\n                for v in neighbors:\n                    if v not in visited:\n                        visited.add(v)\n                        q.append(v)\n            components.append(component)\n    return components\n\ndef _floyd_warshall(adj, N):\n    \"\"\"Computes all-pairs shortest paths using Floyd-Warshall.\"\"\"\n    dist = np.full((N, N), np.inf)\n    np.fill_diagonal(dist, 0)\n    for i in range(N):\n        for j in range(N):\n            if adj[i, j] == 1:\n                dist[i, j] = 1\n    \n    for k_fw in range(N):\n        for i in range(N):\n            for j in range(N):\n                if dist[i, k_fw] + dist[k_fw, j]  dist[i, j]:\n                    dist[i, j] = dist[i, k_fw] + dist[k_fw, j]\n    return dist\n\ndef _calculate_C(adj, N):\n    \"\"\"Calculates the average local clustering coefficient.\"\"\"\n    local_C = []\n    degrees = np.sum(adj, axis=1)\n    for i in range(N):\n        d_i = degrees[i]\n        if d_i  2:\n            local_C.append(0.0)\n            continue\n        \n        neighbors = np.where(adj[i] == 1)[0]\n        t_i = 0\n        subgraph = adj[np.ix_(neighbors, neighbors)]\n        t_i = np.sum(subgraph) // 2\n        \n        C_i = (2 * t_i) / (d_i * (d_i - 1))\n        local_C.append(C_i)\n        \n    return np.mean(local_C)\n\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "2431664"}, {"introduction": "在理解了网络的静态属性之后，我们转向其动态影响。本练习将探讨交易者网络的结构如何影响市场中的信息传播和价格发现过程，该网络结构由经典的 Watts-Strogatz 模型生成。通过模拟交易者观点的更新过程，并改变网络的随机化程度，你将能直接观察到小世界网络在信息传递方面为何如此高效 [@problem_id:2431703]。", "problem": "考虑一个由 $N$ 个交易者组成的市场，其信息网络通过 Watts–Strogatz 小世界模型构建。该网络初始化为一个度为偶数 $k$ 的规则环形格网（每个节点连接到其两侧各 $k/2$ 个最近的邻居），然后每条右侧边以概率 $p$ 独立地重连到一个均匀选择的非邻居节点，排除自环和重复边，最终生成一个无向简单图。设 $A \\in \\{0,1\\}^{N \\times N}$ 表示所得图的邻接矩阵，设 $D \\in \\mathbb{R}^{N \\times N}$ 为节点度的对角矩阵。定义行随机的社会影响矩阵 $W = D^{-1} A$。\n\n在离散时间 $t \\in \\{0,1,2,\\dots\\}$，每个交易者 $i \\in \\{1,\\dots,N\\}$ 都持有一个关于资产基本价值 $F \\in \\mathbb{R}$ 的信念 $x_i(t)$。时间 $t$ 的市场价格是简单平均值 $P(t) = \\frac{1}{N} \\sum_{i=1}^N x_i(t)$。信念通过 DeGroot 锚定动态模型进行更新：\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1},\n$$\n其中 $\\alpha \\in [0,1]$ 是公共信号锚定权重，$\\mathbf{1}$ 是 $N$ 维全一向量。初始信念是异质的，并按如下方式抽取：\n$$\nx_i(0) = F + \\Delta + \\xi_i,\\quad \\xi_i \\sim \\mathcal{N}(0,\\sigma^2) \\text{ 对各 } i \\text{ 独立},\n$$\n其中给定 $\\Delta \\in \\mathbb{R}$ 和 $\\sigma  0$。\n\n您的任务是编写一个完整、可运行的程序，该程序能够：\n- 根据给定的 $N$、$k$ 和 $p$，按上述描述构建 Watts–Strogatz 网络。\n- 根据更新方程，将信念向量 $\\mathbf{x}(t)$ 演化最多 $T_{\\max}$ 步。\n- 计算市场价格到基本价值的首次达到 $\\varepsilon$-收敛的命中时间，\n$$\n\\tau = \\min\\{t \\in \\{1,2,\\dots,T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\},\n$$\n约定如果在 $T_{\\max}$ 时刻前不存在这样的 $t$，则 $\\tau = T_{\\max}$。\n- 每个测试用例使用一个固定的伪随机数生成器种子以确保可复现性。该种子必须同时影响重连的随机性和初始的 $\\xi_i$。\n\n在所有测试用例中，对非网络参数使用以下固定配置：基本价值 $F = 100.0$，初始偏移 $\\Delta = 5.0$，噪声标准差 $\\sigma = 1.0$。收敛容差为每个用例指定的 $\\varepsilon$。本问题不使用角度。所有量均为无量纲，因此不需要物理单位。所有时间索引均为整数。\n\n实现并评估以下参数值 $(N,k,p,\\alpha,\\varepsilon,T_{\\max},\\text{seed})$ 的测试套件：\n- 用例 1：$(150,\\,4,\\,0.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 2：$(150,\\,4,\\,0.05,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 3：$(150,\\,4,\\,0.2,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 4：$(150,\\,4,\\,1.0,\\,0.05,\\,10^{-3},\\,5000,\\,1)$\n- 用例 5（边界情况，无锚定）：$(150,\\,4,\\,0.2,\\,0.0,\\,10^{-3},\\,5000,\\,1)$\n- 用例 6（更稀疏的基础格网）：$(150,\\,2,\\,0.5,\\,0.05,\\,10^{-3},\\,5000,\\,2)$\n\n您的程序应输出一行，包含由六个得到的命中时间 $\\tau$ 组成的列表，格式为逗号分隔并用方括号括起（例如，$\\,[\\tau_1,\\tau_2,\\dots,\\tau_6]\\,$）。最终输出必须是整数。不应打印任何其他文本。", "solution": "问题陈述已经过严格验证，被认为是有效的。其科学基础在于网络科学和计算经济学中的既有模型，问题设定良好，目标明确，信息充分，并且其表述语言清晰明确。任务是在一个 Watts-Strogatz 网络上模拟信念传播动态，并计算价格收敛的命中时间。我们着手解决此问题。\n\n解决方案分为三个主要部分：1) 构建 Watts-Strogatz 网络，2) 阐述和分析 DeGroot 信念动态，3) 实现数值模拟以计算命中时间 $\\tau$。\n\n**1. Watts–Strogatz 网络构建**\n\n$N$ 个交易者的网络根据所描述的特定 Watts-Strogatz 过程构建。\n\n首先，创建一个初始的规则环形格网。节点集为 $V = \\{0, 1, \\dots, N-1\\}$。每个节点 $i \\in V$ 连接到其 $k$ 个最近邻居，其中 $k$ 是一个偶数。具体来说，每个节点 $i$ 连接到节点 $(i \\pm j) \\pmod N$，其中 $j \\in \\{1, \\dots, k/2\\}$。这会创建一个每个节点度均为 $k$ 的无向图。这个初始格网的邻接矩阵 $A^{(0)}$ 的元素为：如果节点 $j$ 是 $i$ 的 $k$ 个最近邻居之一，则 $A^{(0)}_{ij} = 1$，否则 $A^{(0)}_{ij} = 0$。\n\n其次，应用重连过程。问题规定“每条右侧边独立地重连”。我们将“右侧”边定义为形如 $(i, (i+j) \\pmod N)$ 的边，其中 $i \\in \\{0, \\dots, N-1\\}$ 且 $j \\in \\{1, \\dots, k/2\\}$。这样的有向对有 $N \\times (k/2)$ 个，对应于格网中的 $N \\times (k/2)$ 条无向边。对于每一条这样的边，比如 $(u, v)$，进行一次随机决策。以概率 $p$ 重连边 $(u, v)$。重连操作包括移除边 $(u, v)$ 并添加一条新边 $(u, w)$，其中新的目标节点 $w$ 从所有非 $u$ 且未与 $u$ 连接的节点中均匀随机选择。这个过程确保不会产生自环（$u=w$）或 $u$ 和 $w$ 之间的多重边。所得图保持无向，因此如果我们添加边 $(u,w)$，也必须考虑边 $(w,u)$。\n\n最终的邻接矩阵 $A \\in \\{0,1\\}^{N \\times N}$ 表示所得简单无向图的连通性。使用指定种子的伪随机数生成器确保了网络结构的可复现性。\n\n**2. DeGroot 信念动态**\n\n交易者信念的演化由一个带有锚定项的 DeGroot 模型控制。设 $\\mathbf{x}(t) = [x_1(t), \\dots, x_N(t)]^T$ 为离散时间 $t$ 的信念向量。\n\n社会影响矩阵 $W$ 定义为 $W = D^{-1} A$，其中 $A$ 是通过网络构建得到的邻接矩阵，$D$ 是节点度的对角矩阵，$D_{ii} = \\text{deg}(i) = \\sum_{j=0}^{N-1} A_{ij}$。元素 $W_{ij} = A_{ij} / \\text{deg}(i)$ 表示交易者 $j$ 对交易者 $i$ 的影响。如果 $\\text{deg}(i) = 0$，则 $W$ 的第 $i$ 行为全零。$W$ 是一个行随机矩阵，意味着其行和为 $1$（除非某个度为 $0$）。\n\n信念更新方程为：\n$$\n\\mathbf{x}(t+1) = (1-\\alpha) W \\mathbf{x}(t) + \\alpha F \\mathbf{1}\n$$\n其中 $\\alpha \\in [0,1]$ 是对公共信号 $F \\in \\mathbb{R}$ 的锚定权重，$\\mathbf{1}$ 是 $N$ 维全一向量。该方程描述了作用于交易者信念的两种竞争力量：来自邻居的社会影响，乘以 $(1-\\alpha)$，以及朝向基本价值 $F$ 的锚定拉力，乘以 $\\alpha$。\n\n当 $\\alpha > 0$ 时，该系统存在唯一的平衡点 $\\mathbf{x}^*$。在平衡状态下，$\\mathbf{x}^* = (1-\\alpha) W \\mathbf{x}^* + \\alpha F \\mathbf{1}$。对于一个连通图，$W$ 对应于特征值 $1$ 的唯一特征向量是 $\\mathbf{1}$。系统会收敛到一个共识值，因此 $\\mathbf{x}^* = c \\mathbf{1}$，其中 $c$ 为某个常数。将此代入平衡方程得到 $c \\mathbf{1} = (1-\\alpha) c W \\mathbf{1} + \\alpha F \\mathbf{1} = (1-\\alpha) c \\mathbf{1} + \\alpha F \\mathbf{1}$。这可以简化为 $\\alpha c = \\alpha F$，在 $\\alpha > 0$ 的情况下，意味着 $c=F$。因此，所有信念以及它们的平均值（市场价格 $P(t)$）都将收敛到基本价值 $F$。\n\n在 $\\alpha=0$ 的特殊情况下，方程变为 $\\mathbf{x}(t+1) = W \\mathbf{x}(t)$。系统仍会收敛到一个共识值 $c$，但 $c$ 的值由初始条件和网络结构决定。具体来说，$c = \\sum_i \\pi_i x_i(0)$，其中 $\\pi$ 是图上随机游走的平稳分布，由 $\\pi_i = \\text{deg}(i) / \\sum_j \\text{deg}(j)$ 给出。给定初始信念 $x_i(0) = F + \\Delta + \\xi_i$，共识值将大约为 $F+\\Delta$，当 $\\Delta \\neq 0$ 时不等于 $F$。因此，收敛条件 $|P(t) - F| \\le \\varepsilon$ 预计不会被满足。\n\n**3. 数值模拟与命中时间**\n\n任务是计算首次命中时间 $\\tau$，定义为：\n$$\n\\tau = \\min\\{t \\in \\{1, 2, \\dots, T_{\\max}\\} : |P(t) - F| \\le \\varepsilon \\}\n$$\n如果到 $t=T_{\\max}$ 时仍未满足条件，则 $\\tau = T_{\\max}$。\n\n每个测试用例的模拟算法如下：\n1. 为保证可复现性，设置伪随机数生成器种子。\n2. 根据给定的参数 $N$、$k$ 和 $p$，构建 Watts-Strogatz 网络的邻接矩阵 $A$。\n3. 计算度矩阵 $D$ 和影响矩阵 $W = D^{-1} A$。注意处理任何孤立节点（度为0）的除零问题。\n4. 初始化信念向量 $\\mathbf{x}(0)$。对每个 $i$，$x_i(0) = F + \\Delta + \\xi_i$，其中 $\\xi_i$ 是从正态分布 $\\mathcal{N}(0, \\sigma^2)$ 中独立抽取的值。固定的模型参数为 $F=100.0$，$\\Delta=5.0$ 和 $\\sigma=1.0$。\n5. 从时间步 $t=1$ 到 $T_{\\max}$ 进行迭代模拟：\n    a. 更新信念向量：$\\mathbf{x}(t) = (1-\\alpha) W \\mathbf{x}(t-1) + \\alpha F \\mathbf{1}$。\n    b. 计算市场价格：$P(t) = \\frac{1}{N} \\sum_{i=0}^{N-1} x_i(t)$。\n    c. 检查收敛性：如果 $|P(t) - F| \\le \\varepsilon$，则将当前时间步 $t$ 记录为 $\\tau$ 并终止该案例的模拟。\n6. 如果循环完成而未满足收敛准则，则设 $\\tau = T_{\\max}$。\n\n对每个指定的测试用例执行此过程，以生成所需的命中时间列表。", "answer": "```python\nimport numpy as np\n\ndef construct_watts_strogatz(N, k, p, rng):\n    \"\"\"\n    Constructs a Watts-Strogatz small-world network.\n\n    Args:\n        N (int): Number of nodes.\n        k (int): Even integer for the degree of each node in the initial lattice.\n        p (float): Rewiring probability.\n        rng (np.random.Generator): Random number generator for reproducibility.\n\n    Returns:\n        np.ndarray: The N x N adjacency matrix of the graph.\n    \"\"\"\n    if k % 2 != 0 or k >= N:\n        raise ValueError(\"k must be an even integer and less than N.\")\n\n    A = np.zeros((N, N), dtype=np.int8)\n    \n    # 1. Create the initial regular ring lattice\n    edges_to_rewire = []\n    for i in range(N):\n        for j in range(1, k // 2 + 1):\n            neighbor = (i + j) % N\n            A[i, neighbor] = 1\n            A[neighbor, i] = 1\n            # \"right-side\" edges are defined as (i, i+j)\n            edges_to_rewire.append((i, neighbor))\n\n    # 2. Rewire edges\n    for u, v in edges_to_rewire:\n        if rng.random()  p:\n            # Find a a suitable node 'w' to rewire to\n            # 'w' cannot be 'u' or an existing neighbor of 'u'\n            current_neighbors = np.where(A[u, :] == 1)[0]\n            possible_targets = np.setdiff1d(np.arange(N), np.append(current_neighbors, u))\n\n            if len(possible_targets) > 0:\n                w = rng.choice(possible_targets)\n                \n                # Remove old edge (u, v)\n                A[u, v] = 0\n                A[v, u] = 0\n                \n                # Add new edge (u, w)\n                A[u, w] = 1\n                A[w, u] = 1\n    \n    return A\n\ndef simulate_convergence(N, k, p, alpha, epsilon, T_max, seed):\n    \"\"\"\n    Simulates belief dynamics on a Watts-Strogatz network and finds the convergence time.\n\n    Args:\n        N (int): Number of traders.\n        k (int): Lattice degree.\n        p (float): Rewiring probability.\n        alpha (float): Anchoring weight.\n        epsilon (float): Convergence tolerance.\n        T_max (int): Maximum simulation steps.\n        seed (int): Seed for the random number generator.\n\n    Returns:\n        int: The hitting time tau.\n    \"\"\"\n    # Fixed parameters from the problem description\n    F = 100.0\n    DELTA = 5.0\n    SIGMA = 1.0\n    \n    # Initialize random number generator for reproducibility\n    rng = np.random.default_rng(seed)\n\n    # 1. Construct the network\n    A = construct_watts_strogatz(N, k, p, rng)\n\n    # 2. Set up the belief dynamics matrices\n    degrees = A.sum(axis=1)\n    # Handle isolated nodes (degree=0) by keeping their row as all zeros\n    W = np.divide(A, degrees[:, np.newaxis], out=np.zeros_like(A, dtype=float), where=degrees[:, np.newaxis] != 0)\n    \n    one_vector = np.ones(N)\n    \n    # 3. Initialize beliefs\n    xi = rng.normal(0, SIGMA, N)\n    x = F + DELTA + xi\n\n    # 4. Run simulation\n    for t in range(1, T_max + 1):\n        # Update beliefs\n        x = (1 - alpha) * (W @ x) + alpha * F * one_vector\n        \n        # Calculate market price\n        P_t = np.mean(x)\n        \n        # Check for convergence\n        if abs(P_t - F) = epsilon:\n            return t\n            \n    # If convergence is not reached by T_max\n    return T_max\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Test cases: (N, k, p, alpha, epsilon, T_max, seed)\n    test_cases = [\n        (150, 4, 0.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.05, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.05, 1e-3, 5000, 1),\n        (150, 4, 1.0, 0.05, 1e-3, 5000, 1),\n        (150, 4, 0.2, 0.0, 1e-3, 5000, 1),\n        (150, 2, 0.5, 0.05, 1e-3, 5000, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        tau = simulate_convergence(*case)\n        results.append(tau)\n\n    # Print output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2431703"}, {"introduction": "最后，我们将分析推向更深层次，探究这些网络结构本身是如何形成的。这个高级练习引入了一个网络形成的博弈模型，其中理性经纪人根据网络中心性带来的收益和维护连接的成本之间的权衡来决定是否建立连接。你需要找出该博弈的纳什均衡网络，并分析其结构特性，从而深入理解网络的内生形成机制 [@problem_id:2431635]。", "problem": "给定一类具有有限标记智能体集合的无向简单网络。每个智能体是一个节点，一个链接是一条无向边。对于一个给定的网络，其邻接矩阵为 $A \\in \\{0,1\\}^{n \\times n}$（对称，对角线元素为零），令 $d_i(A)$ 表示节点 $i$ 的度，令 $v(A) \\in \\mathbb{R}^n_{\\ge 0}$ 表示特征向量中心性向量，定义为 $A$ 的主特征向量，并归一化为单位欧几里得范数，即 $v(A)$ 满足 $A v(A) = \\lambda_{\\max}(A) v(A)$，且 $\\|v(A)\\|_2 = 1$ 和 $v(A) \\ge 0$ (元素级)；如果 $A$ 是零矩阵，则定义 $v(A) = 0$。\n\n对于参数 $\\alpha  0$ 和 $c  0$，每个智能体 $i$ 的收益为\n$$\nu_i(A;\\alpha,c) \\;=\\; \\alpha \\, v_i(A) \\;-\\; c \\, d_i(A).\n$$\n\n链接的形成遵循双方同意和单方切断的原则。考虑以下均衡概念。一个网络 $A$ 是一个成对纳什均衡，当且仅当以下两个条件都成立：\n1. 对于每个现有的链接 $\\{i,j\\}$ (其中 $A_{ij} = 1$)，令 $A^{-ij}$ 表示移除了该单个链接后的邻接矩阵，我们有 $u_i(A^{-ij};\\alpha,c) \\le u_i(A;\\alpha,c)$ 且 $u_j(A^{-ij};\\alpha,c) \\le u_j(A;\\alpha,c)$。\n2. 对于每个缺失的链接 $\\{i,j\\}$ (其中 $A_{ij} = 0$)，令 $A^{+ij}$ 表示添加了该单个链接后的邻接矩阵，不会同时出现 $u_i(A^{+ij};\\alpha,c)  u_i(A;\\alpha,c)$ 和 $u_j(A^{+ij};\\alpha,c)  u_j(A;\\alpha,c)$ 的情况。\n\n将一个网络的总福利定义为 $W(A;\\alpha,c) = \\sum_{i=1}^n u_i(A;\\alpha,c)$。\n\n小世界和无标度诊断。对于任何网络 $A$，定义：\n- 节点 $i$ 的局部聚类系数为\n$$\nC_i(A) \\;=\\; \n\\begin{cases}\n\\frac{\\text{i 的邻居之间的边数}}{\\binom{d_i(A)}{2}},  \\text{如果 } d_i(A) \\ge 2,\\\\\n0,  \\text{如果 } d_i(A)  2,\n\\end{cases}\n$$\n全局聚类系数为 $C(A) = \\frac{1}{n}\\sum_{i=1}^n C_i(A)$。\n- 平均最短路径长度 $L(A)$ 在最大连通分量上计算：如果最大连通分量的大小 $s \\ge 2$，则令 $L(A)$ 为该分量内所有无序节点对的最短路径距离的平均值；如果 $s  2$，则设 $L(A) = 0$。\n- 对于给定的 $n$ 和边数 $m$，将 Erdős–Rényi 基线平均值 $C_{\\mathrm{rand}}(n,m)$ 和 $L_{\\mathrm{rand}}(n,m)$ 定义为在所有具有 $n$ 个节点和恰好 $m$ 条边的无向简单图上计算的 $C(\\cdot)$ 和 $L(\\cdot)$ 的算术平均值。\n- 小世界系数为\n$$\n\\sigma(A) \\;=\\; \\frac{C(A)/C_{\\mathrm{rand}}(n,m)}{L(A)/L_{\\mathrm{rand}}(n,m)},\n$$\n其中 $m$ 是 $A$ 中的边数。当且仅当 $C_{\\mathrm{rand}}(n,m)  0$、$L_{\\mathrm{rand}}(n,m)  0$、$L(A)  0$ 且 $\\sigma(A)  1$ 时，宣称一个网络是类小世界网络；否则，它不是类小世界网络。\n- 为了测试类无标度行为，令 $k_i = d_i(A)$ 为度，并将度序列的基尼系数定义为\n$$\nG(A) \\;=\\; \\frac{\\sum_{i=1}^n \\sum_{j=1}^n |k_i - k_j|}{2 n \\sum_{i=1}^n k_i},\n$$\n约定当 $\\sum_i k_i = 0$ 时 $G(A)=0$。使用由度至少为 $k_{\\min} = 2$ 定义的尾部，令 $S = \\{i : k_i \\ge k_{\\min}\\}$ 且 $N_{\\mathrm{tail}} = |S|$。如果 $N_{\\mathrm{tail}} \\ge 2$ 且 $\\sum_{i \\in S} \\ln\\left(\\frac{k_i}{k_{\\min}}\\right)  0$，定义 Hill 型估计量\n$$\n\\hat{\\alpha}(A) \\;=\\; 1 + \\frac{N_{\\mathrm{tail}}}{\\sum_{i \\in S} \\ln\\left(\\frac{k_i}{k_{\\min}}\\right)}.\n$$\n当且仅当 $N_{\\mathrm{tail}} \\ge 2$、$2.0 \\le \\hat{\\alpha}(A) \\le 3.5$ 且 $G(A) \\ge 0.4$ 时，宣称一个网络是类无标度网络；否则，它不是类无标度网络。\n\n任务。对于下面测试套件中的每个参数集，执行以下步骤：\n- 枚举 $n$ 个标记节点上的所有无向简单网络。\n- 根据上述收益规范，计算成对纳什均衡网络的集合。\n- 在所有均衡中，选择使总福利 $W(A;\\alpha,c)$ 最大化的网络作为规范均衡；如果出现平局，则通过使用边序 $(1,2),(1,3),\\dots,(n-1,n)$ 选择具有字典序最小的边关联比特串的网络来打破平局。\n- 对于规范均衡网络，使用上述规则计算它是否是类小世界网络以及是否是类无标度网络。\n- 对于每个参数集，输出一个列表，其中包含：\n    1. 成对纳什均衡的数量（一个整数）。\n    2. 规范均衡的总福利，四舍五入到三位小数（一个浮点数）。\n    3. 规范均衡的类小世界指标（一个布尔值）。\n    4. 规范均衡的类无标度指标（一个布尔值）。\n\n测试套件。使用以下参数集：\n- 情况 1：$(n,\\alpha,c) = (3, 1.0, 1.0)$。\n- 情况 2：$(n,\\alpha,c) = (3, 1.0, 0.05)$。\n- 情况 3：$(n,\\alpha,c) = (3, 1.0, 0.2)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个情况的结果本身都是一个按上述顺序排列的列表。例如，格式必须完全像\n\"[ [x1,y1,z1,w1],[x2,y2,z2,w2],[x3,y3,z3,w3] ]\"\n除了此处显示的外，没有多余的空格，其中 $x_i$ 是一个整数，$y_i$ 是一个四舍五入到三位小数的浮点数，$z_i,w_i$ 是布尔值。", "solution": "问题陈述是计算经济学和网络理论中一个有效、适定且有科学依据的练习。它要求在一个网络形成的博弈论模型中，识别和分析均衡网络。给定的条件是完整的，定义是精确且算法上可处理的，对于一个小的网络规模 $n=3$ 来说，该任务是一项标准的计算分析，对此可以使用穷举搜索方法。\n\n该解决方案按以下算法步骤进行：\n\n1.  **网络枚举**：对于给定的智能体数量 $n$，有 $\\binom{n}{2}$ 个可能的无向链接。简单无向网络的总数是 $2^{\\binom{n}{2}}$。对于给定的测试用例 $n=3$，有 $\\binom{3}{2}=3$ 个可能的链接，导致总共有 $2^3=8$ 个不同的网络需要分析，这是一个可管理的数量。每个网络都可以由其邻接矩阵 $A$ 唯一表示。\n\n2.  **收益计算**：对于任何给定的网络 $A$，每个智能体 $i$ 的收益 $u_i(A)$ 取决于两个量：智能体的度 $d_i(A)$ 和特征向量中心性 $v_i(A)$。\n    - 度 $d_i(A)$ 是邻接矩阵 $A$ 的第 $i$ 行（或列）的总和。\n    - 特征向量中心性向量 $v(A)$ 被定义为与矩阵 $A$ 的最大特征值 $\\lambda_{\\max}(A)$ 相对应的非负、单位范数特征向量。根据非负矩阵的 Perron-Frobenius 定理，可以保证其存在性。在数值上，通过计算对称矩阵 $A$ 的完整特征系统并选择与最大特征值相关联的特征向量来找到它。为了遵守非负性约束 $v(A) \\ge 0$，我们取计算出的特征向量分量的绝对值，这是一个标准程序，相当于解决特征向量的任意符号问题。对于零矩阵，$v(A)$ 被定义为零向量。\n\n3.  **均衡识别**：如果一个网络 $A$ 对于单个链接的移除和添加都保持稳定，那么它就是一个成对纳什均衡 (PNE)。对于这 8 个网络中的每一个，我们检查以下两个条件：\n    - **条件 1 (对切断的稳定性)**：对于每个现有的链接 $\\{i,j\\}$（即 $A_{ij}=1$），我们通过移除这个链接来形成一个新网络 $A^{-ij}$。如果没有任何一个智能体能从移除链接中单方面受益，则原始网络 $A$ 相对于此链接是稳定的。也就是说，必须满足 $u_i(A^{-ij}) \\le u_i(A)$ 和 $u_j(A^{-ij}) \\le u_j(A)$。如果对于任何现有的链接，此条件被违反，则该网络不是 PNE。\n    - **条件 2 (对添加的稳定性)**：对于未被链接连接的每一对智能体 $\\{i,j\\}$（即 $A_{ij}=0$），我们通过添加这个链接来形成一个新网络 $A^{+ij}$。如果两个智能体没有共同的动机来形成这个链接，则原始网络 $A$ 相对于这个非链接是稳定的。也就是说，必须不能同时满足 $u_i(A^{+ij}) > u_i(A)$ 和 $u_j(A^{+ij}) > u_j(A)$。如果对于任何不存在的链接，此条件被违反，则该网络不是 PNE。\n    一个网络当且仅当对所有可能的链接都满足这两个条件时，才是一个 PNE。\n\n4.  **规范均衡选择**：在识别出所有 PNE 网络集合后，我们选择一个单一的规范均衡。\n    - 首先，我们计算每个 PNE 的总福利 $W(A) = \\sum_{i=1}^n u_i(A)$。\n    - 规范均衡是使此总福利最大化的 PNE。\n    - 如果福利出现平局，则通过选择具有字典序最小的边关联比特串的网络来打破平局，遵循指定的边序 $(1,2), (1,3), \\dots, (n-1,n)$。对于 $n=3$，这对应于边的顺序为 $((1,2), (1,3), (2,3))$。\n\n5.  **规范均衡的诊断分析**：对所选的规范均衡网络 $A_c$ 进行小世界和无标度属性分析。\n    - **类小世界属性**：这需要将网络的全局聚类系数 $C(A_c)$ 和平均最短路径长度 $L(A_c)$ 与随机图的相应值 $C_{\\mathrm{rand}}(n,m)$ 和 $L_{\\mathrm{rand}}(n,m)$ 进行比较，其中 $m$ 是 $A_c$ 中的边数。\n        - 全局聚类系数 $C(A)$ 是局部聚类系数 $C_i(A)$ 的平均值。\n        - 平均路径长度 $L(A)$ 是在最大连通分量上计算的。\n        - 对于 $n=3$，随机基线是通过枚举所有具有 $m$ 条边的图并对其各自的 $C$ 和 $L$ 值求平均来计算的。\n        - 如果 $C_{\\mathrm{rand}}>0$、$L_{\\mathrm{rand}}>0$、$L(A_c)>0$ 且小世界系数 $\\sigma(A_c) = \\frac{C(A_c)/C_{\\mathrm{rand}}}{L(A_c)/L_{\\mathrm{rand}}} > 1$，则该网络是类小世界网络。\n    - **类无标度属性**：此属性根据网络的度分布进行诊断。它要求基尼系数 $G(A_c)$ 较高，并且来自 Hill 型估计量的尾部指数 $\\hat{\\alpha}(A_c)$ 在特定范围内。\n        - Hill 估计量的定义要求度尾部至少有两个节点（$N_{\\mathrm{tail}} \\ge 2$，其中尾部由度 $k_i \\ge k_{\\min}=2$ 定义）。它还要求和 $\\sum_{i \\in S} \\ln(k_i/k_{\\min})$ 严格为正。\n        - 对于 $n=3$，最大可能度为 $n-1=2$。因此，尾部中的任何节点（度 $\\ge 2$）的度必须恰好为 $2$。如果存在 $N_{\\mathrm{tail}} \\ge 2$ 个这样的节点，它们的度都是 $k_i=2$。这导致对于所有 $i \\in S$，$k_i/k_{\\min} = 2/2 = 1$，因此 $\\ln(k_i/k_{\\min}) = \\ln(1) = 0$。因此，只要 $N_{\\mathrm{tail}} > 0$，和 $\\sum_{i \\in S} \\ln(k_i/k_{\\min})$ 就始终为零。\n        - 由于定义 $\\hat{\\alpha}(A)$ 的条件要求这个和严格为正，因此对于任何 $n=3$ 的网络，Hill 估计量都永远无法定义。因此，根据给定的规则，任何 $n=3$ 的网络都不能被归类为类无标度网络。这将检查简化为始终产生 `False`。\n\n将此完整过程实现并应用于每个指定的测试用例，以生成最终结果。", "answer": "```python\nimport numpy as np\nfrom scipy.special import comb\nimport math\n\ndef get_payoffs(A, alpha, c):\n    \"\"\"Calculates payoffs for all agents in a network A.\"\"\"\n    n = A.shape[0]\n    # Handle the zero matrix case\n    if not np.any(A):\n        v = np.zeros(n)\n        lambda_max = 0\n    else:\n        # Use eigh for symmetric matrices; it's faster and more stable.\n        # It returns eigenvalues in ascending order.\n        eigenvalues, eigenvectors = np.linalg.eigh(A)\n        lambda_max = eigenvalues[-1]\n        v = eigenvectors[:, -1]\n        # The dominant eigenvector of a non-negative matrix can be chosen to be non-negative.\n        # np.linalg.eigh might return a vector with an overall negative sign.\n        # Taking the absolute value enforces non-negativity.\n        v = np.abs(v)\n\n    degrees = np.sum(A, axis=1)\n    payoffs = alpha * v - c * degrees\n    return payoffs, v, lambda_max, degrees\n\ndef get_all_networks(n):\n    \"\"\"Generates all simple undirected graphs on n nodes.\"\"\"\n    num_edges = n * (n - 1) // 2\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            edges.append((i, j))\n    \n    for i in range(2**num_edges):\n        A = np.zeros((n, n), dtype=int)\n        bitstring = bin(i)[2:].zfill(num_edges)\n        for k in range(num_edges):\n            if bitstring[k] == '1':\n                u, v = edges[k]\n                A[u, v] = A[v, u] = 1\n        yield A, ''.join(reversed(bitstring)) # Reverse for lexicographical order (1,2), (1,3)...\n\ndef solve():\n    \"\"\"\n    Main solver function for the network formation problem.\n    \"\"\"\n    test_cases = [\n        (3, 1.0, 1.0),\n        (3, 1.0, 0.05),\n        (3, 1.0, 0.2),\n    ]\n\n    # Pre-calculate ER baselines for n=3\n    er_baselines = {\n        # m: (C_rand, L_rand)\n        0: (0.0, 0.0),\n        1: (0.0, 1.0),\n        2: (0.0, 4.0 / 3.0),\n        3: (1.0, 1.0),\n    }\n\n    final_results = []\n    for n, alpha, c in test_cases:\n        pne_list = []\n        \n        edge_indices = []\n        for i_node in range(n):\n            for j_node in range(i_node + 1, n):\n                edge_indices.append((i_node, j_node))\n\n        for A, bitstring in get_all_networks(n):\n            is_pne = True\n            payoffs_A, _, _, _ = get_payoffs(A, alpha, c)\n\n            # Condition 1: Stability against severance\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 1:\n                        A_minus = A.copy()\n                        A_minus[i, j] = A_minus[j, i] = 0\n                        payoffs_minus, _, _, _ = get_payoffs(A_minus, alpha, c)\n                        if not (payoffs_minus[i] = payoffs_A[i] and payoffs_minus[j] = payoffs_A[j]):\n                            is_pne = False\n                            break\n                if not is_pne:\n                    break\n            if not is_pne:\n                continue\n\n            # Condition 2: Stability against addition\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A[i, j] == 0:\n                        A_plus = A.copy()\n                        A_plus[i, j] = A_plus[j, i] = 1\n                        payoffs_plus, _, _, _ = get_payoffs(A_plus, alpha, c)\n                        if payoffs_plus[i] > payoffs_A[i] and payoffs_plus[j] > payoffs_A[j]:\n                            is_pne = False\n                            break\n                if not is_pne:\n                    break\n            \n            if is_pne:\n                welfare = np.sum(payoffs_A)\n                pne_list.append({'A': A, 'welfare': welfare, 'bitstring': bitstring})\n\n        num_pne = len(pne_list)\n        \n        if num_pne == 0:\n             # This case should not occur based on problem structure but is a safeguard.\n            final_results.append([0, 0.0, False, False])\n            continue\n            \n        # Sort to find canonical equilibrium: primary key welfare (desc), secondary key bitstring (asc)\n        pne_list.sort(key=lambda x: (-x['welfare'], x['bitstring']))\n        canonical_equilibrium = pne_list[0]\n        \n        A_c = canonical_equilibrium['A']\n        canonical_welfare = canonical_equilibrium['welfare']\n\n        # Small-world analysis\n        m = int(np.sum(A_c) / 2)\n        degrees = np.sum(A_c, axis=1)\n\n        # Global Clustering Coefficient C(A)\n        local_cs = []\n        for i in range(n):\n            d_i = degrees[i]\n            if d_i  2:\n                local_cs.append(0.0)\n            else:\n                neighbors = np.where(A_c[i] == 1)[0]\n                num_neighbor_edges = 0\n                for u_idx in range(len(neighbors)):\n                    for v_idx in range(u_idx + 1, len(neighbors)):\n                        u, v = neighbors[u_idx], neighbors[v_idx]\n                        if A_c[u, v] == 1:\n                            num_neighbor_edges += 1\n                local_cs.append(num_neighbor_edges / comb(d_i, 2))\n        C_A = np.mean(local_cs)\n\n        # Average Shortest-Path Length L(A)\n        # Find connected components and largest one\n        visited = [False] * n\n        components = []\n        for i in range(n):\n            if not visited[i]:\n                component = []\n                q = [i]\n                visited[i] = True\n                head = 0\n                while head  len(q):\n                    u = q[head]\n                    head += 1\n                    component.append(u)\n                    for v in range(n):\n                        if A_c[u, v] == 1 and not visited[v]:\n                            visited[v] = True\n                            q.append(v)\n                components.append(component)\n        \n        largest_comp = max(components, key=len) if components else []\n        s = len(largest_comp)\n        \n        L_A = 0.0\n        if s >= 2:\n            dist_matrix = np.full((n, n), np.inf)\n            for i in range(n):\n                dist_matrix[i, i] = 0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if A_c[i, j] == 1:\n                        dist_matrix[i, j] = dist_matrix[j, i] = 1\n\n            for k in range(n):\n                for i in range(n):\n                    for j in range(n):\n                        dist_matrix[i, j] = min(dist_matrix[i, j], dist_matrix[i, k] + dist_matrix[k, j])\n\n            path_sum = 0\n            num_pairs = 0\n            for i_idx in range(s):\n                for j_idx in range(i_idx + 1, s):\n                    u, v = largest_comp[i_idx], largest_comp[j_idx]\n                    path_sum += dist_matrix[u, v]\n                    num_pairs += 1\n            if num_pairs > 0:\n                L_A = path_sum / num_pairs\n\n        C_rand, L_rand = er_baselines[m]\n        is_small_world = False\n        if C_rand > 0 and L_rand > 0 and L_A > 0:\n            sigma = (C_A / C_rand) / (L_A / L_rand)\n            if sigma > 1:\n                is_small_world = True\n\n        # Scale-free analysis\n        # For n=3, max degree is 2. The tail starts at k_min=2.\n        # If any nodes have degree >= 2, they must have degree exactly 2.\n        # This makes sum(ln(k_i/k_min)) = sum(ln(2/2)) = sum(ln(1)) = 0.\n        # The Hill estimator is undefined. Thus, it can never be scale-free for n=3.\n        is_scale_free = False\n        \n        rounded_welfare = round(canonical_welfare, 3)\n        final_results.append(f\"[{num_pne},{rounded_welfare:.3f},{str(is_small_world).lower()},{str(is_scale_free).lower()}]\")\n\n    print(f\"[{','.join(final_results)}]\")\n\nsolve()\n```", "id": "2431635"}]}