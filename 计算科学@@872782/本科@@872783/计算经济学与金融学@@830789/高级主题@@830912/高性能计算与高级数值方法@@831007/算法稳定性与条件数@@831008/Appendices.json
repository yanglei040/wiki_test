{"hands_on_practices": [{"introduction": "问题的“条件”优劣，或称“病态/良态”，衡量了其解对输入数据微小变化的敏感程度。这个练习将此抽象概念置于一个具体的金融决策场景中 [@problem_id:2370897]。我们将通过一个资本资产定价模型（CAPM）的例子，精确计算一个微小的 $\\beta$ 估计误差如何导致一个投资项目的决策从接受逆转为拒绝，从而揭示当折现率 $r$ 与增长率 $g$ 相近时，估值问题会变得何等敏感或“病态”。", "problem": "一家公司正在考虑一个全股权项目，该项目需要在时间 $t=0$ 时投入初始资金 $I = 199$ 美元。该项目预计将从时间 $t=1$ 开始产生一连串自由现金流，初始值为 $C_{1} = 1$，然后每期以 $g = 0.06$ 的恒定增长率永久增长。公司使用资本资产定价模型 (CAPM) 对现金流进行折现，其中权益成本为 $r(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)$。无风险利率为 $r_{f} = 0.02$，市场风险溢价为 $E[R_{m}] - r_{f} = 0.05$。公司的真实贝塔值为 $\\beta^{\\ast} = 0.9$。\n\n投资决策规则是，如果使用测量的贝塔值 $\\widehat{\\beta}$ 计算出的净现值为非负，则接受该项目，否则拒绝。如果基于 $\\widehat{\\beta}$ 的决策与使用真实贝塔值 $\\beta^{\\ast}$ 做出的决策不同，则发生错误决策。\n\n计算会导致决策从在真实贝塔值 $\\beta^{\\ast}$ 下的接受，转变为在使用 $\\widehat{\\beta}$ 时的拒绝的最小贝塔估计绝对误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。请以精确分数形式给出答案。", "solution": "首先必须验证问题陈述的科学合理性、适定性和客观性。\n\n**步骤1：提取已知条件**\n- 初始投资：$I = 199$\n- t=1时的初始现金流：$C_{1} = 1$\n- 现金流的恒定增长率：$g = 0.06$\n- 权益成本模型 (CAPM)：$r(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)$\n- 无风险利率：$r_{f} = 0.02$\n- 市场风险溢价：$E[R_{m}] - r_{f} = 0.05$\n- 项目真实贝塔值：$\\beta^{\\ast} = 0.9$\n- 测量的项目贝塔值：$\\widehat{\\beta}$\n- 投资规则：如果净现值 $NPV(\\widehat{\\beta}) \\ge 0$，则接受，否则拒绝。\n- 如果使用 $\\widehat{\\beta}$ 的结果与使用 $\\beta^{\\ast}$ 的结果不同，则发生错误决策。\n- 目标是找到导致决策从接受翻转为拒绝的最小绝对估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题基于公司金融的标准、公认原则：用于估值的增长永续模型（戈登增长模型）和用于确定折现率的资本资产定价模型 (CAPM)。所提供的数据是自洽且内部一致的。永续年金公式要求折现率 $r$ 大于增长率 $g$。使用真实贝塔值 $\\beta^{\\ast} = 0.9$，折现率为 $r(\\beta^{\\ast}) = 0.02 + 0.9(0.05) = 0.02 + 0.045 = 0.065$。该值大于增长率 $g=0.06$，因此估值是适定的。因此，该问题具有科学依据且适定。语言客观且量化。未发现任何缺陷。\n\n**步骤3：结论与行动**\n该问题有效。现在将提供完整的解决方案。\n\n**解题过程**\n\n一个初始投资为 $I$、从 $C_1$ 开始并以增长率 $g$ 永续增长的现金流流的项目，其净现值 (NPV) 由增长永续年金公式给出：\n$$\nNPV = \\frac{C_1}{r - g} - I\n$$\n其中 $r$ 是适当的折现率。该公式仅在 $r  g$ 时有效。\n\n折现率 $r$ 是权益成本，由资本资产定价模型 (CAPM) 确定，是项目贝塔值 $\\beta$ 的函数：\n$$\nr(\\beta) = r_{f} + \\beta\\big(E[R_{m}] - r_{f}\\big)\n$$\n代入给定值，我们得到：\n$$\nr(\\beta) = 0.02 + \\beta(0.05)\n$$\n因此，NPV 作为 $\\beta$ 的函数为：\n$$\nNPV(\\beta) = \\frac{C_1}{r_f + \\beta(E[R_m] - r_f) - g} - I = \\frac{1}{0.02 + 0.05\\beta - 0.06} - 199 = \\frac{1}{0.05\\beta - 0.04} - 199\n$$\n\n首先，我们使用真实贝塔值 $\\beta^{\\ast} = 0.9$ 来确定正确的投资决策。\n真实的折现率是：\n$$\nr(\\beta^{\\ast}) = r(0.9) = 0.02 + 0.9(0.05) = 0.02 + 0.045 = 0.065\n$$\n由于 $r(\\beta^{\\ast}) = 0.065  g = 0.06$，估值有效。在真实贝塔值下的净现值为：\n$$\nNPV(\\beta^{\\ast}) = \\frac{1}{0.065 - 0.06} - 199 = \\frac{1}{0.005} - 199 = 200 - 199 = 1\n$$\n由于 $NPV(\\beta^{\\ast}) = 1  0$，正确的决策是 **接受** 该项目。\n\n问题要求找到将此决策翻转为 **拒绝** 的最小估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$。当计算出的 NPV 为负值时，即 $NPV(\\widehat{\\beta})  0$ 时，发生拒绝。决策在边界 $NPV(\\widehat{\\beta}) = 0$ 处翻转。让我们找出使此条件成立的临界贝塔值 $\\widehat{\\beta}_{crit}$。\n$$\nNPV(\\widehat{\\beta}_{crit}) = \\frac{1}{r(\\widehat{\\beta}_{crit}) - g} - I = 0\n$$\n$$\n\\frac{1}{r(\\widehat{\\beta}_{crit}) - 0.06} = 199\n$$\n$$\nr(\\widehat{\\beta}_{crit}) - 0.06 = \\frac{1}{199}\n$$\n$$\nr(\\widehat{\\beta}_{crit}) = 0.06 + \\frac{1}{199}\n$$\n现在，我们将 CAPM 公式代入 $r(\\widehat{\\beta}_{crit})$：\n$$\n0.02 + 0.05\\widehat{\\beta}_{crit} = 0.06 + \\frac{1}{199}\n$$\n求解 $\\widehat{\\beta}_{crit}$：\n$$\n0.05\\widehat{\\beta}_{crit} = 0.06 - 0.02 + \\frac{1}{199} = 0.04 + \\frac{1}{199}\n$$\n$$\n\\widehat{\\beta}_{crit} = \\frac{0.04 + \\frac{1}{199}}{0.05} = \\frac{0.04}{0.05} + \\frac{1}{199 \\times 0.05} = \\frac{4}{5} + \\frac{1}{9.95} = \\frac{4}{5} + \\frac{1}{199/20} = \\frac{4}{5} + \\frac{20}{199}\n$$\n为了合并这些分数，我们找到一个公分母：\n$$\n\\widehat{\\beta}_{crit} = \\frac{4 \\times 199 + 20 \\times 5}{5 \\times 199} = \\frac{796 + 100}{995} = \\frac{896}{995}\n$$\n$NPV(\\beta)$ 函数，$NPV(\\beta) = \\frac{1}{0.05\\beta - 0.04} - 199$，在 $\\beta > 0.04/0.05 = 0.8$ 的区间内是 $\\beta$ 的递减函数。由于 $\\beta^{\\ast} = 0.9 > 0.8$，我们处于一个较高的贝塔值导致较低 NPV 的区域。\n正确的决策是接受 ($NPV > 0$)。翻转为拒绝 ($NPV  0$) 要求估计的贝塔值 $\\widehat{\\beta}$ 大于临界贝塔值 $\\widehat{\\beta}_{crit}$。\n由于 $NPV(\\beta^{\\ast}) > 0$ 且 $NPV(\\widehat{\\beta}_{crit}) = 0$，并且 NPV 是 $\\beta$ 的递减函数，所以必然有 $\\widehat{\\beta}_{crit} > \\beta^{\\ast}$。\n让我们验证一下：$\\widehat{\\beta}_{crit} = \\frac{896}{995} \\approx 0.9005025$ 且 $\\beta^{\\ast} = 0.9$。确实，$\\widehat{\\beta}_{crit} > \\beta^{\\ast}$。\n\n会导致决策翻转的最小绝对估计误差 $|\\widehat{\\beta} - \\beta^{\\ast}|$ 是临界贝塔值与真实贝塔值之间的差。对于任何大于此值的误差，如果误差为正 ($\\widehat{\\beta} > \\beta^{\\ast}$)，则会发生拒绝。\n$$\n|\\widehat{\\beta}_{crit} - \\beta^{\\ast}| = \\widehat{\\beta}_{crit} - \\beta^{\\ast} = \\frac{896}{995} - 0.9 = \\frac{896}{995} - \\frac{9}{10}\n$$\n我们使用公分母 $9950$ 计算差值：\n$$\n\\frac{896 \\times 10}{9950} - \\frac{9 \\times 995}{9950} = \\frac{8960 - 8955}{9950} = \\frac{5}{9950}\n$$\n通过将分子和分母同时除以 $5$ 来简化此分数：\n$$\n\\frac{5 \\div 5}{9950 \\div 5} = \\frac{1}{1990}\n$$\n因此，导致决策从接受翻转为拒绝的最小贝塔绝对估计误差是 $\\frac{1}{1990}$。", "answer": "$$\n\\boxed{\\frac{1}{1990}}\n$$", "id": "2370897"}, {"introduction": "在分析了问题的内在敏感性之后，我们转向算法本身的属性：稳定性。一个“不稳定”的算法即使在处理一个“良态”问题时，也可能因为放大了计算过程中的舍入误差而得出完全错误的答案。这个练习 [@problem_id:2370924] 展示了数值线性代数中一个经典的例子：对于一个精心构造但良态的 $2 \\times 2$ 线性系统，不带主元选择的高斯消元法会得出灾难性的结果，而带有主元选择的稳定算法则能轻松获得精确解，这突显了算法设计的重要性。", "problem": "考虑一个线性方程组，它编码了一个带有微小比例扭曲的有摩擦市场中，两个合成投资组合之间的两两无套利平衡。设未知向量为 $x \\in \\mathbb{R}^{2}$，对于给定的参数 $\\varepsilon \\in (0,1)$，定义系数矩阵和右端项为\n$$\nA(\\varepsilon) \\equiv \\begin{bmatrix}\n\\varepsilon  1 \\\\\n1  1\n\\end{bmatrix}, \\qquad \nb \\equiv \\begin{bmatrix}\n1 \\\\\n2\n\\end{bmatrix}.\n$$\n该系统可以被解释为一组线性化的无套利一致性方程，它连接了两个复制策略，其中微小的摩擦参数 $\\varepsilon$ 仅出现在第一个方程中。这些方程是无量纲的，不需要物理单位。\n\n定义关于欧几里得范数的谱条件数为\n$$\n\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\equiv \\|A(\\varepsilon)\\|_{2}\\,\\|A(\\varepsilon)^{-1}\\|_{2}.\n$$\n\n定义解 $x$ 的两个计算近似值如下：\n1. $x_{\\mathrm{np}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 的结果，该分解在每一步都保持行序固定（无行交换）。\n2. $x_{\\mathrm{pp}}(\\varepsilon)$ 是通过三角分解求解 $A(\\varepsilon)\\,x=b$ 的结果，该分解在每个消元步骤中，对活动子矩阵内的行进行重排，以使当前列的主元具有最大绝对值（允许在列内进行行交换）。\n\n设精确解记为 $x^{\\star}(\\varepsilon)$，并定义任意近似值 $y \\in \\mathbb{R}^{2}$ 的相对误差为\n$$\n\\mathcal{E}(y;\\varepsilon) \\equiv \\frac{\\|y - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}}.\n$$\n\n你的程序必须为每个指定的测试用例值 $\\varepsilon$ 计算三元组\n$$\n\\left(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right), \\ \\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right)\\right),\n$$\n然后计算布尔值\n$$\nS(\\varepsilon) \\equiv \\Big(\\kappa_{2}\\!\\left(A(\\varepsilon)\\right) \\leq 10\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon\\right) \\geq 10^{-3}\\Big) \\ \\wedge \\ \\Big(\\mathcal{E}\\!\\left(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon\\right) \\leq 10^{-12}\\Big).\n$$\n其预期解释是，$S(\\varepsilon)$ 为真的条件是：系统是良态的，同时固定行序的消元法产生较大的向前误差，而行交换的消元法保持高度精确。\n\n测试集：\n- $\\varepsilon = 10^{-16}$\n- $\\varepsilon = 10^{-12}$\n- $\\varepsilon = 10^{-8}$\n- $\\varepsilon = 10^{-4}$\n- $\\varepsilon = 10^{-1}$\n\n答案规格：\n- 对于以上述顺序列出的每个测试用例，计算定义的 $S(\\varepsilon)$。\n- 你的程序应产生单行输出，包含一个用方括号括起来的逗号分隔列表的结果，例如 $[r_{1},r_{2},r_{3},r_{4},r_{5}]$，其中每个 $r_{i}$ 是字面标记 True 或 False，对应于第 $i$ 个测试用例的 $S(\\varepsilon)$。\n\n所有计算必须使用标准双精度浮点运算进行。此任务不涉及角度和物理单位，也不需要百分比；任何比率都应以纯小数形式报告。", "solution": "提交分析的问题陈述被认为是有效的。这是一个在数值线性代数领域中提出来的、有科学依据的适定问题，其表述客观而精确。所有必要的数据、定义和约束都已提供，不存在内部矛盾或逻辑缺陷。该问题要求分析算法稳定性，这是计算科学中的一个基本概念。我们将着手进行解答。\n\n目标是研究对于参数 $\\varepsilon$ 的各种小值，求解线性系统 $A(\\varepsilon)x = b$ 的数值稳定性。具体来说，我们必须比较两种基于三角分解的方法的精度：一种保持固定的行序（不带主元选择的 Gaussian 消元法），另一种则重排行以使用最大绝对值的主元（带部分主元选择的 Gaussian 消元法）。\n\n首先，让我们确定精确解 $x^{\\star}(\\varepsilon)$，数值近似解将与之进行比较。矩阵 $A(\\varepsilon)$ 由下式给出\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon  1 \\\\ 1  1 \\end{bmatrix}.\n$$\n行列式为 $\\det(A(\\varepsilon)) = \\varepsilon \\cdot 1 - 1 \\cdot 1 = \\varepsilon - 1$。由于问题指定 $\\varepsilon \\in (0,1)$，行列式非零，因此该矩阵始终可逆。其逆矩阵为\n$$\nA(\\varepsilon)^{-1} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1  -1 \\\\ -1  \\varepsilon \\end{bmatrix}.\n$$\n因此，精确解 $x^{\\star}(\\varepsilon) = A(\\varepsilon)^{-1}b$ 为\n$$\nx^{\\star}(\\varepsilon) = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1  -1 \\\\ -1  \\varepsilon \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} 1 - 2 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\frac{1}{\\varepsilon - 1} \\begin{bmatrix} -1 \\\\ -1 + 2\\varepsilon \\end{bmatrix} = \\begin{bmatrix} \\frac{1}{1-\\varepsilon} \\\\ \\frac{1-2\\varepsilon}{1-\\varepsilon} \\end{bmatrix}.\n$$\n当 $\\varepsilon \\to 0$ 时，精确解趋近于 $x^{\\star}(0) = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$。对于小的 $\\varepsilon$ 值，解本身是表现良好的。\n\n接下来，我们分析问题的条件。谱条件数 $\\kappa_{2}(A(\\varepsilon))$ 衡量解 $x$ 对 $A$ 或 $b$ 中扰动的敏感性。当 $\\varepsilon \\to 0$ 时，矩阵 $A(\\varepsilon)$ 趋近于 $A(0) = \\begin{bmatrix} 0  1 \\\\ 1  1 \\end{bmatrix}$。$A(0)$ 的奇异值是 $A(0)^T A(0) = \\begin{bmatrix} 1  1 \\\\ 1  2 \\end{bmatrix}$ 特征值的平方根。该矩阵的特征值为 $\\lambda = (3 \\pm \\sqrt{5})/2$。奇异值为 $\\sigma_{\\max} = \\sqrt{(3 + \\sqrt{5})/2}$ 和 $\\sigma_{\\min} = \\sqrt{(3 - \\sqrt{5})/2}$。条件数为\n$$\n\\kappa_{2}(A(0)) = \\frac{\\sigma_{\\max}}{\\sigma_{\\min}} = \\frac{\\sqrt{3+\\sqrt{5}}}{\\sqrt{3-\\sqrt{5}}} = \\frac{3+\\sqrt{5}}{2} \\approx 2.618.\n$$\n这是一个小数，表明对于小的 $\\varepsilon$，矩阵 $A(\\varepsilon)$ 是良态的。该问题本身对小扰动不敏感。因此，$S(\\varepsilon)$ 中的第一个条件 $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 对于所有测试值 $\\varepsilon$ 都将满足。计算解中的任何大误差因此必然源于所用算法的不稳定性，而非问题本身的病态性。\n\n现在我们来分析第一种数值方法 $x_{\\mathrm{np}}(\\varepsilon)$，它对应于不带主元选择的 Gaussian 消元法。我们对 $A(\\varepsilon)$ 进行 LU 分解，即 $A(\\varepsilon) = LU$。\n$$\nA(\\varepsilon) = \\begin{bmatrix} \\varepsilon  1 \\\\ 1  1 \\end{bmatrix}.\n$$\n为了消去元素 $a_{21}=1$，我们使用乘数 $m_{21} = a_{21}/a_{11} = 1/\\varepsilon$。得到的上三角矩阵 $U$ 是\n$$\nU = \\begin{bmatrix} \\varepsilon  1 \\\\ 0  1 - 1/\\varepsilon \\end{bmatrix}.\n$$\n而下三角矩阵 $L$ 是\n$$\nL = \\begin{bmatrix} 1  0 \\\\ 1/\\varepsilon  1 \\end{bmatrix}.\n$$\n对于一个很小的 $\\varepsilon$ (例如 $\\varepsilon \\approx 10^{-16}$)，乘数 $1/\\varepsilon$ 会变得极大。在标准双精度浮点运算中（其机器精度约为 $2.2 \\times 10^{-16}$），项 $\\mathrm{fl}(1 - 1/\\varepsilon)$ 的计算会遭受灾难性抵消。与 $1/\\varepsilon$ 相比，数字 $1$ 微不足道，因此结果就只是 $\\mathrm{fl}(-1/\\varepsilon)$。\n该系统通过向前代入 $Ly=b$ 和向后代入 $Ux=y$ 来求解。\n求解 $Ly=b$：\n$y_1 = b_1 = 1$。\n$(1/\\varepsilon)y_1 + y_2 = b_2 \\implies y_2 = 2 - 1/\\varepsilon$。\n在浮点运算中，$\\mathrm{fl}(y_2) = \\mathrm{fl}(2 - 1/\\varepsilon) \\approx -1/\\varepsilon$。\n求解 $Ux=y$：\n计算出的 $U$ 矩阵的 $(2,2)$ 元素是 $\\tilde{u}_{22} = \\mathrm{fl}(1-1/\\varepsilon) \\approx -1/\\varepsilon$。\n$\\tilde{u}_{22} x_2 = \\tilde{y}_2 \\implies (-1/\\varepsilon) x_2 \\approx -1/\\varepsilon \\implies x_2 \\approx 1$。\n$\\varepsilon x_1 + x_2 = y_1 \\implies \\varepsilon x_1 + 1 \\approx 1 \\implies \\varepsilon x_1 \\approx 0 \\implies x_1 \\approx 0$。\n计算得到的解为 $x_{\\mathrm{np}}(\\varepsilon) \\approx \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}$。\n将其与小的 $\\varepsilon$ 的精确解 $x^{\\star}(\\varepsilon) \\approx \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}$ 相比较，误差是显著的。相对误差为\n$$\n\\mathcal{E}(x_{\\mathrm{np}};\\varepsilon) = \\frac{\\|x_{\\mathrm{np}} - x^{\\star}(\\varepsilon)\\|_{2}}{\\|x^{\\star}(\\varepsilon)\\|_{2}} \\approx \\frac{\\|\\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} - \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\|_{2}}{\\|\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\|_{2}} = \\frac{\\|\\begin{bmatrix} -1 \\\\ 0 \\end{bmatrix}\\|_{2}}{\\sqrt{1^2+1^2}} = \\frac{1}{\\sqrt{2}} \\approx 0.707.\n$$\n这是一个非常大的误差，远超过 $10^{-3}$。这说明了当遇到小主元时，不带主元选择的 Gaussian 消元法的数值不稳定性。对于任何小到足以导致这种浮点行为的 $\\varepsilon$，这种情况都会成立。只有当 $\\varepsilon$ 足够大以至于 $1/\\varepsilon$ 不大时，这种不稳定性才会消失。对于 $\\varepsilon = 10^{-1}$，乘数为 $10$，计算 $1-10=-9$ 在浮点数中是精确的。在这种情况下，无主元消元法是准确的。因此，条件 $\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 对于小的 $\\varepsilon$ 为真，但对于 $\\varepsilon = 10^{-1}$ 为假。\n\n现在，我们分析第二种方法 $x_{\\mathrm{pp}}(\\varepsilon)$，它对应于带部分主元选择的 Gaussian 消元法。在每一步中，交换行以确保主元元素（对角线元素）在活动子矩阵的当前列中是最大的。\n对于 $A(\\varepsilon) = \\begin{bmatrix} \\varepsilon  1 \\\\ 1  1 \\end{bmatrix}$ 和 $\\varepsilon \\in (0,1)$，我们有 $|a_{21}| = 1 > |\\varepsilon| = |a_{11}|$。因此，我们必须交换第1行和第2行。这等价于乘以一个置换矩阵 $P = \\begin{bmatrix} 0  1 \\\\ 1  0 \\end{bmatrix}$。系统变为 $PAx=Pb$。\n$$\nPA = \\begin{bmatrix} 1  1 \\\\ \\varepsilon  1 \\end{bmatrix}, \\quad Pb = \\begin{bmatrix} 2 \\\\ 1 \\end{bmatrix}.\n$$\n现在我们对这个新系统进行消元。乘数为 $m_{21} = \\varepsilon/1 = \\varepsilon$。由于 $|\\varepsilon|1$，乘数很小，这是一个稳定消元步骤的标志。\n上三角矩阵 $U$ 变为\n$$\nU = \\begin{bmatrix} 1  1 \\\\ 0  1-\\varepsilon \\end{bmatrix}.\n$$\n运算过程为 $y_1=2$，$y_2=1-2\\varepsilon$，然后 $(1-\\varepsilon)x_2 = 1-2\\varepsilon \\implies x_2 = (1-2\\varepsilon)/(1-\\varepsilon)$，以及 $x_1+x_2=2 \\implies x_1=2-x_2 = 1/(1-\\varepsilon)$。计算出的解与精确解的解析形式相同。由于所有运算都涉及良态算术（没有相近大数相减），浮点计算将是高度精确的。相对误差 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon)$ 将在机器精度（约 $10^{-16}$）的量级上，因此对于所有测试用例，都满足条件 $\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$。\n\n总之，对于 $\\varepsilon \\in \\{10^{-16}, 10^{-12}, 10^{-8}, 10^{-4}\\}$：\n1.  $\\kappa_{2}(A(\\varepsilon)) \\leq 10$ 是 `True`。\n2.  由于不稳定性，$\\mathcal{E}(x_{\\mathrm{np}}(\\varepsilon);\\varepsilon) \\geq 10^{-3}$ 是 `True`。\n3.  由于稳定性，$\\mathcal{E}(x_{\\mathrm{pp}}(\\varepsilon);\\varepsilon) \\leq 10^{-12}$ 是 `True`。\n因此，$S(\\varepsilon)$ 的计算结果为 `True`。\n\n对于 $\\varepsilon=10^{-1}$：\n1.  $\\kappa_{2}(A(0.1)) \\leq 10$ 是 `True`。\n2.  $\\mathcal{E}(x_{\\mathrm{np}}(0.1);\\varepsilon) \\geq 10^{-3}$ 是 `False`，因为乘数 $1/0.1=10$ 不够大，不会引起显著的浮点误差，计算是准确的。\n3.  $\\mathcal{E}(x_{\\mathrm{pp}}(0.1);\\varepsilon) \\leq 10^{-12}$ 是 `True`。\n由于第二个条件为假，$S(0.1)$ 的计算结果为 `False`。\n\n程序将实现这些计算并证实这一推理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n# The problem can be solved with numpy; scipy is not strictly necessary but is permitted.\n\ndef solve():\n    \"\"\"\n    Solves the specified problem by analyzing the numerical stability of solving\n    a linear system with and without pivoting.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        1e-16,\n        1e-12,\n        1e-8,\n        1e-4,\n        1e-1,\n    ]\n\n    results = []\n    \n    for eps in test_cases:\n        # Define the matrix A and vector b for the current epsilon\n        A = np.array([[eps, 1.0], [1.0, 1.0]], dtype=np.float64)\n        b = np.array([1.0, 2.0], dtype=np.float64)\n\n        # --- 1. Calculate the 'exact' solution x_star ---\n        # Using the analytical formula derived from the problem.\n        # This gives a high-precision reference for error calculation.\n        x_star = np.array([1.0 / (1.0 - eps), (1.0 - 2.0 * eps) / (1.0 - eps)], dtype=np.float64)\n\n        # --- 2. Calculate the condition number kappa_2 ---\n        kappa_2 = np.linalg.cond(A, 2)\n\n        # --- 3. Calculate the solution with no pivoting (x_np) ---\n        # This requires manually implementing Gaussian elimination without row swaps.\n        def solve_no_pivot(mat_A, vec_b):\n            n = len(vec_b)\n            A_np = mat_A.copy()\n            b_np = vec_b.copy()\n\n            # Forward elimination to create an upper triangular matrix\n            # This is a 2x2 specific implementation for simplicity and clarity.\n            if A_np[0, 0] == 0:\n                # This case isn't hit for eps  0 but is a necessary check\n                # for a general algorithm. A zero pivot without pivoting fails.\n                return np.array([np.nan, np.nan])\n            \n            m = A_np[1, 0] / A_np[0, 0]\n            A_np[1, :] -= m * A_np[0, :]\n            b_np[1] -= m * b_np[0]\n            \n            # Backward substitution\n            x = np.zeros(n, dtype=np.float64)\n            if A_np[1, 1] == 0:\n                # Another fail condition, singular matrix after elimination.\n                return np.array([np.nan, np.nan])\n                \n            x[1] = b_np[1] / A_np[1, 1]\n            x[0] = (b_np[0] - A_np[0, 1] * x[1]) / A_np[0, 0]\n            \n            return x\n\n        x_np = solve_no_pivot(A, b)\n        \n        # --- 4. Calculate the solution with partial pivoting (x_pp) ---\n        # np.linalg.solve uses LAPACK routines which employ partial pivoting by default.\n        x_pp = np.linalg.solve(A, b)\n\n        # --- 5. Calculate relative errors ---\n        norm_x_star = np.linalg.norm(x_star, 2)\n        if norm_x_star == 0:\n             # Avoid division by zero, though not relevant for this problem.\n            rel_error_np = np.linalg.norm(x_np - x_star, 2)\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2)\n        else:\n            rel_error_np = np.linalg.norm(x_np - x_star, 2) / norm_x_star\n            rel_error_pp = np.linalg.norm(x_pp - x_star, 2) / norm_x_star\n            \n        # --- 6. Evaluate the boolean condition S(epsilon) ---\n        S = (kappa_2 = 10.0) and (rel_error_np >= 1e-3) and (rel_error_pp = 1e-12)\n        results.append(S)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2370924"}, {"introduction": "最后，我们将问题的条件和算法的稳定性这两个概念结合起来，探讨当一个稳定的算法遇到一个病态问题时会发生什么。一个稳定的算法能保证计算误差不会被自身过程不必要地放大，但它无法消除问题固有的敏感性。这个练习 [@problem_id:2421700] 使用了著名的病态矩阵——希尔伯特矩阵（Hilbert matrix）——来证明这一点，你将观察到，即便使用最可靠的线性求解器，随着矩阵维度的增加，其条件数会爆炸式增长，最终导致计算出的解完全失去精度。", "problem": "要求您编写一个完整、可运行的程序，来演示在使用希尔伯特矩阵求解线性系统时出现的数值稳定性和不稳定性。一个大小为 $n$ 的希尔伯特矩阵，记作 $H_n$，是一个 $n \\times n$ 的矩阵，其元素为 $H_{ij} = \\dfrac{1}{i + j - 1}$，$1 \\le i, j \\le n$。该矩阵是对称正定的，但它也是著名的病态矩阵 (ill-conditioned)，这意味着小的扰动（例如，浮点运算中的舍入误差）会导致计算出的线性系统解产生巨大的变化。\n\n基本原理和定义：考虑线性系统 $A x = b$，其中 $A$ 为非奇异矩阵。对于解 $x$，以下概念是基础。\n- 前向相对误差 (forward relative error) 为 $\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2}$。\n- 后向误差 (backward error)（一种常见的归一化选择）为 $\\dfrac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n- 2-范数条件数 (2-norm condition number) 为 $\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2$。\n\n用作起点的成熟结论：\n- 在符合电气和电子工程师协会 (Institute of Electrical and Electronics Engineers, IEEE) $754$ 标准的浮点运算中，稳定的直接求解器（例如，标准库中实现的部分主元高斯消元法）通常是后向稳定的 (backward stable)：计算出的解 $\\hat{x}$ 是一个邻近系统 $(A + \\Delta A)\\hat{x} = b$ 的精确解，其中 $\\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$ 的量级与单位舍入误差 $u$（对于双精度，约为 $2^{-53} \\approx 1.11 \\times 10^{-16}$）相当。\n- 对于小的扰动，前向误差的界与条件数成正比：$\\dfrac{\\lVert \\hat{x} - x \\rVert_2}{\\lVert x \\rVert_2} \\lesssim \\kappa_2(A) \\cdot \\dfrac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2}$。\n\n任务：实现一个程序，对于指定测试集中的每个 $n$，构造希尔伯特矩阵 $H_n$，选择一个已知的精确解 $x_\\text{true}$，构造 $b = H_n x_\\text{true}$，在双精度下数值求解该系统以获得 $\\hat{x}$，并报告：\n- 前向相对误差 $\\dfrac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$，\n- 归一化后向误差 $\\dfrac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$，\n- 2-范数条件数 $\\kappa_2(H_n)$。\n\n精确解的选择：使用 $x_\\text{true}$，其元素为 $x_i = (-1)^{i-1}$，$i = 1, \\dots, n$，因此 $x_\\text{true}$ 的元素为 $\\{+1, -1, +1, -1, \\dots\\}$。\n\n数值环境：使用双精度浮点运算。不允许使用随机数。不涉及角度。没有物理单位。\n\n测试集：按顺序对 $n \\in \\{2, 5, 8, 12, 14\\}$ 运行您的程序。这些案例涵盖了一个基准小尺寸 ($n = 2$)、一个表现良好的典型中小规模案例 ($n = 5$)、一个明显病态的中等规模案例 ($n = 8$)，以及两个日益极端的病态案例 ($n = 12$ 和 $n = 14$)。\n\n要求的最终输出格式：您的程序应生成单行输出，包含所有测试用例的结果，形式为一个逗号分隔的列表，并用方括号括起来。每个测试用例的结果应报告为一个内部列表，形式为 $[n,\\ \\text{forward\\_error},\\ \\text{backward\\_error},\\ \\kappa_2]$。输出中不得有任何空格。例如，整体结构必须是\n$[[n_1,\\text{forward\\_error}_1,\\text{backward\\_error}_1,\\kappa_{2,1}],[n_2,\\text{forward\\_error}_2,\\text{backward\\_error}_2,\\kappa_{2,2}],\\dots]$。\n所有数值应以十进制浮点数形式打印（可接受科学记数法）。程序不得读取任何输入。", "solution": "所述问题是数值线性代数中一个标准且基础的练习，是计算科学的基石。其目的在于通过经验证明算法的稳定性与问题的条件性之间的关键区别。在继续之前，需要进行严格的验证。\n\n该问题要求分析线性系统 $H_n x = b$，其中 $H_n$ 是大小为 $n$ 的希尔伯特矩阵。所有给定条件都已明确陈述：$H_n$ 的定义为 $H_{ij} = (i+j-1)^{-1}$，精确解向量 $x_\\text{true}$ 的选择，构造向量 $b$ 的过程，要使用的数值方法（双精度算术，标准线性求解器），以及需要精确报告的量：前向相对误差、归一化的后向误差和 2-范数条件数。矩阵大小的测试集 $n \\in \\{2, 5, 8, 12, 14\\}$ 也已指定。\n\n问题陈述在科学上是合理的，它借鉴了矩阵分析和数值稳定性理论的既定原则。它是一个适定 (well-posed) 问题，提供了一套完整且一致的指令，可以得出一个唯一的、可验证的计算结果。其语言客观且明确。因此，该问题被认为是有效的，并将给出一个解决方案。\n\n核心概念是数学问题的条件性 (conditioning)。如果输入数据的微小相对变化可能导致输出解的巨大相对变化，则称该问题是病态的 (ill-conditioned)。对于线性系统 $Ax=b$，解 $x$ 对 $A$ 和 $b$ 中扰动的敏感性由矩阵 $A$ 的条件数来衡量，对于 2-范数，其定义为：\n$$\n\\kappa_2(A) = \\lVert A \\rVert_2 \\lVert A^{-1} \\rVert_2\n$$\n一个大的条件数意味着一个病态问题。希尔伯特矩阵是臭名昭著的病态矩阵，其 $\\kappa_2(H_n)$ 随 $n$ 呈指数级增长。\n\n一个用于解决问题的算法如果不会引入超出问题本身条件性所固有的显著额外误差，则该算法是数值稳定的。一个后向稳定 (backward stable) 的算法，如部分主元高斯消元法（标准库求解器如 `numpy.linalg.solve` 的基础），计算出的解 $\\hat{x}$ 是一个轻微扰动问题的精确解：\n$$\n(A + \\Delta A)\\hat{x} = b, \\quad \\text{其中} \\quad \\frac{\\lVert \\Delta A \\rVert_2}{\\lVert A \\rVert_2} \\approx u\n$$\n这里，$u$ 是单位舍入误差或机器精度（对于 IEEE $754$ 双精度，$u = 2^{-53} \\approx 1.11 \\times 10^{-16}$）。一个小的后向误差是这一特性的体现。问题定义了一个特定的归一化后向误差：\n$$\nE_b = \\frac{\\lVert A \\hat{x} - b \\rVert_2}{\\lVert A \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}\n$$\n该量度量了残差 $A\\hat{x}-b$ 相对于问题规模的大小。对于后向稳定的算法，我们期望 $E_b$ 很小，在 $u$ 的量级。\n\n相比之下，前向相对误差度量了解本身的差异：\n$$\nE_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}\n$$\n连接这些量的基本关系近似由下式给出：\n$$\nE_f \\lesssim \\kappa_2(A) \\cdot (\\text{后向误差})\n$$\n这个不等式表明，即使使用后向稳定的算法（后向误差小），如果问题是病态的（$\\kappa_2(A)$ 大），计算解中的前向误差也可能大到无法接受。希尔伯特矩阵为这种现象提供了一个经典的案例研究。\n\n对于测试集 $\\{2, 5, 8, 12, 14\\}$ 中的每个 $n$，需要实现的计算步骤如下：\n$1$. 构造 $n \\times n$ 的希尔伯特矩阵 $H_n$，其元素为 $H_{ij} = (i+j-1)^{-1}$，$i,j \\in \\{1, \\dots, n\\}$。\n$2$. 构造大小为 $n$ 的真解向量 $x_\\text{true}$，其元素为 $(x_\\text{true})_i = (-1)^{i-1}$，$i \\in \\{1, \\dots, n\\}$。\n$3$. 计算右端向量 $b = H_n x_\\text{true}$。此计算在双精度算术中执行，其结果是数值测试的参考右端项。\n$4$. 数值求解线性系统 $H_n x = b$ 以获得计算解 $\\hat{x}$。这将使用标准的、稳定的直接求解器来完成。\n$5$. 计算所需的三个诊断量：\n    a. 2-范数条件数 $\\kappa_2(H_n)$。\n    b. 前向相对误差 $E_f = \\frac{\\lVert \\hat{x} - x_\\text{true} \\rVert_2}{\\lVert x_\\text{true} \\rVert_2}$。\n    c. 归一化后向误差 $E_b = \\frac{\\lVert H_n \\hat{x} - b \\rVert_2}{\\lVert H_n \\rVert_2 \\lVert \\hat{x} \\rVert_2 + \\lVert b \\rVert_2}$。\n$6$. 收集并报告结果 $[n, E_f, E_b, \\kappa_2(H_n)]$。\n\n预期行为：随着 $n$ 的增加，$\\kappa_2(H_n)$ 将极快地增长。归一化的后向误差 $E_b$ 将保持很小，接近机器精度，这证实了求解器的稳定性。因此，前向误差 $E_f$ 将急剧增长，大致与乘积 $\\kappa_2(H_n) \\cdot u$ 的趋势一致。对于 $n=12$ 和 $n=14$，条件数将非常大，以至于 $\\kappa_2(H_n) \\cdot u \\gg 1$，这表明矩阵在数值上是奇异的，预计计算出的解 $\\hat{x}$ 将没有正确的有效数字。该程序将精确地展示这一行为。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Demonstrates numerical stability and instability when solving a linear system\n    with a Hilbert matrix for various sizes.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 5, 8, 12, 14]\n\n    results = []\n    for n in test_cases:\n        # Construct the Hilbert matrix H_n.\n        # scipy.linalg.hilbert uses 1-based indexing in its definition,\n        # which matches the problem statement.\n        H = linalg.hilbert(n)\n\n        # Construct the known exact solution x_true with entries (-1)^(i-1).\n        # For 0-based array indexing, this is (-1)^i.\n        x_true = np.array([(-1)**i for i in range(n)])\n\n        # Construct the right-hand side vector b = H_n * x_true.\n        # This is performed in standard double-precision floating-point arithmetic.\n        b = H @ x_true\n\n        # Solve the system H_n * x = b numerically to obtain the computed solution x_hat.\n        # numpy.linalg.solve is a backward stable direct solver.\n        x_hat = np.linalg.solve(H, b)\n\n        # Calculate the 2-norm condition number of H_n.\n        # This is kappa_2(H_n) = ||H_n||_2 * ||H_n^-1||_2.\n        cond_num = np.linalg.cond(H, p=2)\n\n        # Calculate the forward relative error: ||x_hat - x_true||_2 / ||x_true||_2.\n        norm_x_true = np.linalg.norm(x_true, ord=2)\n        norm_error_x = np.linalg.norm(x_hat - x_true, ord=2)\n        forward_error = norm_error_x / norm_x_true\n\n        # Calculate the normalized backward error:\n        # ||H_n * x_hat - b||_2 / (||H_n||_2 * ||x_hat||_2 + ||b||_2).\n        residual_vec = H @ x_hat - b\n        norm_residual = np.linalg.norm(residual_vec, ord=2)\n        norm_H = np.linalg.norm(H, ord=2)\n        norm_x_hat = np.linalg.norm(x_hat, ord=2)\n        norm_b = np.linalg.norm(b, ord=2)\n        backward_error = norm_residual / (norm_H * norm_x_hat + norm_b)\n        \n        # Store the results for the current n.\n        results.append([n, forward_error, backward_error, cond_num])\n\n    # Format the final output string exactly as required.\n    # Each sublist is formatted as \"[n,ferr,berr,cond]\" with no spaces.\n    str_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    \n    # All sublist strings are joined by commas and enclosed in brackets.\n    final_output_str = f\"[{','.join(str_results)}]\"\n\n    # Final print statement in the exact required format.\n    print(final_output_str)\n\nsolve()\n\n```", "id": "2421700"}]}