{"hands_on_practices": [{"introduction": "在金融工程中，Crank-Nicolson (CN) 方法因其无条件稳定性和二阶准确性，是求解金融偏微分方程（PDEs）的常用选择。然而，当处理诸如期权到期时的“曲棍球棒”式非光滑支付函数时，标准的CN方法可能会在支付函数不光滑点（如执行价格）附近产生非物理的伪振荡。本练习将引导你亲手实现CN格式，观察这一现象，并将其与一种旨在抑制这些振荡的改进方法（Rannacher平滑法）进行比较，这对于建立稳健的数值求解器至关重要。[@problem_id:2391467]", "problem": "本任务要求您为欧式看跌期权的 Black–Scholes 偏微分方程 (PDE) 实现两种无条件稳定的有限差分时间步进格式，并量化在从到期日后退一步时，在行权价附近可能出现的伪振荡。Black–Scholes PDE 为\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n适用于资产价格 $S \\in [0,S_{\\max}]$ 和时间 $t \\in [0,T]$，对于欧式看跌期权，其终端条件（在到期日 $t=T$ 时）为\n$$\nV(S,T) = \\max(K - S, 0).\n$$\n使用狄利克雷边界条件\n$$\nV(0,t) = K e^{-r (T-t)}, \\quad V(S_{\\max}, t) = 0.\n$$\n未知量为期权价值 $V(S,t)$；$S$ 是标的资产价格；$t$ 是日历时间；$T$ 是到期日；$\\sigma$ 是波动率（假定为常数）；$r$ 是恒定的无风险利率。\n\n您的程序必须：\n- 在均匀网格 $S_i = i\\,\\Delta S$（其中 $i \\in \\{0,1,\\dots,N\\}$，$ \\Delta S = S_{\\max}/N$ 且 $N \\in \\mathbb{N}$）上离散化空间域。\n- 以 $M \\in \\mathbb{N}$ 个大小为 $\\Delta t = T/M$ 的步长对时间进行均匀离散化，从 $t=T$ 向后推进至 $t = T - \\Delta t$ 单步，以分离到期日后的瞬时行为。\n\n实现并比较以下两种格式在第一个后退步（从 $t=T$ 到 $t=T-\\Delta t$）中的表现：\n\n1) Crank–Nicolson 格式（时间中心，二阶）：\n从算子形式 $\\partial_t V = -\\mathcal{A} V$ 出发，其中 $\\mathcal{A} V = \\frac{1}{2}\\sigma^2 S^2 V_{SS} + r S V_S - r V$。Crank–Nicolson 更新公式为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^n,\n$$\n其中 $V^n(\\cdot) = V(\\cdot, t_n)$ 且 $t_{n+1} = t_n - \\Delta t$，此处 $t_n = T$。空间导数 $\\partial_S V$ 和 $\\partial_{SS} V$ 必须在内部节点 $i \\in \\{1,\\dots,N-1\\}$ 使用中心差分进行近似：\n$$\nV_S(S_i) \\approx \\frac{V_{i+1}-V_{i-1}}{2\\Delta S}, \\quad V_{SS}(S_i) \\approx \\frac{V_{i+1} - 2V_i + V_{i-1}}{\\Delta S^2}.\n$$\n\n2) Rannacher 阻尼的 Crank–Nicolson：\n执行两个初始的完全隐式（后向欧拉）半步，每步大小为 $\\Delta t/2$，然后不执行任何其他操作（因为此任务仅需要一个完整的 $\\Delta t$ 后退步）。后向欧拉格式的半步为\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+\\frac{1}{2}} = V^n, \\quad\n\\left(I + \\frac{\\Delta t}{2}\\mathcal{A}\\right) V^{n+1} = V^{n+\\frac{1}{2}}.\n$$\n\n在两种格式中，通过适当调整第一个和最后一个内部网格点上的右侧项来强制执行狄利克雷边界条件。所产生的三对角线性系统必须精确求解（例如，通过 Thomas 算法）。所有参数都是确定性的，并且设定为风险中性和无套利环境。\n\n伪振荡的检测与量化：\n- 对于欧式看跌期权，其精确价格是关于 $S$ 的单调不增函数。将在给定时间层级上的离散前向差分定义为 $\\Delta V_i = V_{i+1} - V_i$。任何 $\\Delta V_i  0$ 的情况都是一次单调性破坏，与伪振荡一致。\n- 令 $i_K = \\left\\lfloor K/\\Delta S \\right\\rfloor$ 并定义一个半宽为 $w \\in \\mathbb{N}$ 的对称行权价中心窗口，其索引为 $i \\in \\{\\max(0,i_K-w), \\dots, \\min(N-1,i_K+w)\\}$。在此窗口内，计算最大正斜率 $\\max\\{0, \\max_{i \\text{ in window}} \\Delta V_i\\}$，作为行权价附近过冲幅度的度量。\n\n所需的数值基础：\n- 使用 PDE 中的线性微分算子 $\\mathcal{A}$ 和中心有限差分作为唯一的空间离散化工具。\n- 在您的实现或检查中，请勿使用任何 Black–Scholes 解析定价公式。\n- 显式地构建三对角矩阵，并使用数值稳定的直接三对角求解器进行求解。\n\n测试套件：\n使用以下参数集。对于每种情况，使用两种格式计算从 $t=T$ 到 $t=T-\\Delta t$ 一个完整后退时间步后的结果。所有情况的通用参数为 $K = 100$, $T = 1.0$, $S_{\\max} = 500$, $r = 0.05$, $\\sigma = 0.2$，以及 $w = 5$。\n- 情况 A（粗时间步长）：$N = 200$, $M = 10$ (因此 $\\Delta t = 0.1$)。\n- 情况 B（中等时间步长）：$N = 400$, $M = 50$ (因此 $\\Delta t = 0.02$)。\n- 情况 C（细时间步长）：$N = 400$, $M = 200$ (因此 $\\Delta t = 0.005$)。\n\n对于每种情况，按以下顺序报告以下六个量：\n1) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在整个网格上的单调性破坏的整数计数。\n2) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的单调性破坏的整数计数。\n3) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在整个网格上的单调性破坏的整数计数。\n4) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的单调性破坏的整数计数。\n5) 在 $t=T-\\Delta t$ 时，Crank–Nicolson 格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n6) 在 $t=T-\\Delta t$ 时，Rannacher 阻尼格式在行权价中心窗口内的最大正离散斜率（一个非负实数）。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个含三个列表的列表（每个情况一个），每个内部列表按上述定义的顺序包含该情况的六个结果。输出格式必须严格如下\n$$\n\\text{[}[a_{1},a_{2},a_{3},a_{4},a_{5},a_{6}],[b_{1},b_{2},b_{3},b_{4},b_{5},b_{6}],[c_{1},c_{2},c_{3},c_{4},c_{5},c_{6}]\\text{]}\n$$\n所有数字由逗号分隔，无多余空格，其中每个 $a_i$、$b_i$ 和 $c_i$ 均为数字。不涉及角度，也无需报告物理单位。所有数值量都应打印为纯数字；过冲幅度应打印为标准小数形式。", "solution": "问题陈述经评估有效。它描述了一个适定的数值分析任务，该任务基于作为量化金融基石的基础性 Black-Scholes 偏微分方程 (PDE)。所有参数和方法都已足够精确地定义，可得到唯一且可验证的解。此任务是实现并比较两种有限差分格式——Crank-Nicolson 格式和一种 Rannacher 阻尼变体——以求解欧式看跌期权价格，并量化由非光滑终端条件引起的行权价附近的伪振荡。\n\n我们首先将 Black-Scholes PDE 的离散化过程形式化。该方程可以写成算子形式 $\\frac{\\partial V}{\\partial t} = -\\mathcal{A}V$，其中线性算子 $\\mathcal{A}$ 定义为\n$$\n\\mathcal{A}V := \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - rV\n$$\n我们将空间域 $S \\in [0, S_{\\max}]$ 离散为 $N$ 个宽度为 $\\Delta S = S_{\\max}/N$ 的均匀区间，创建网格点 $S_i = i\\Delta S$，其中 $i \\in \\{0, 1, \\dots, N\\}$。在这些点上的解 $V(S_i, t)$ 记为 $V_i(t)$。在内部网格点 $S_i$（其中 $i \\in \\{1, \\dots, N-1\\}$）上，使用中心有限差分来近似空间导数，作用于值向量 $\\mathbf{V}$ 上的算子 $\\mathcal{A}$ 可近似为矩阵-向量乘法 $\\mathbf{A_h V}$。该离散算子 $\\mathbf{A_h}$ 在第 $i$ 行作用于向量 $\\mathbf{V}$ 的结果为：\n$$\n(\\mathbf{A_h V})_i = \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S}\\right)V_{i-1} + \\left(-\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r\\right)V_i + \\left(\\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\\right)V_{i+1}\n$$\n为方便起见，我们定义系数：\n$$\n\\begin{aligned}\n\\alpha_i = \\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S} \\\\\n\\beta_i = -\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r \\\\\n\\gamma_i = \\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\n\\end{aligned}\n$$\n使得 $(\\mathbf{A_h V})_i = \\alpha_i V_{i-1} + \\beta_i V_i + \\gamma_i V_{i+1}$。此公式对内部网格点 $i \\in \\{1, \\dots, N-1\\}$ 有效。\n\n时间步进从到期日 $T$ 开始，以大小为 $\\Delta t=T/M$ 的步长向后进行。设 $V^n$ 表示在时间 $t_n = T$ 的期权价值，我们求解在时间 $t_{n+1} = T - \\Delta t$ 的 $V^{n+1}$。\n\n首先，实现 Crank-Nicolson 格式。更新规则为：\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{V}^{n+1} = \\left(I - \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{V}^n\n$$\n这为 $N-1$ 个未知的内部值 $\\{V_1^{n+1}, \\dots, V_{N-1}^{n+1}\\}$ 构成了一个包含 $N-1$ 个线性方程的三对角系统。左侧矩阵为 $L = I + \\frac{\\Delta t}{2}\\mathbf{A_h}$，右侧向量为 $\\mathbf{d} = (I - \\frac{\\Delta t}{2}\\mathbf{A_h}) \\mathbf{V}^n$。必须将已知的边界值 $V_0$ 和 $V_N$ 纳入计算。狄利克雷边界条件为 $V(0, t) = K e^{-r(T-t)}$ 和 $V(S_{\\max}, t) = 0$。因此，$V_0^n = K$，$V_N^n = 0$，$V_0^{n+1} = Ke^{-r\\Delta t}$，以及 $V_N^{n+1} = 0$。对于第一个内部方程（$i=1$），涉及 $V_0^{n+1}$ 的项是已知的，并被移到右侧。对于最后一个内部方程（$i=N-1$），涉及 $V_N^{n+1}$ 和 $V_N^n$ 的项为零，无需调整。\n\n其次，Rannacher 阻尼格式包含两个初始的完全隐式（后向欧拉）步骤，每步大小为半步长 $\\Delta t/2$。更新规则为：\n$$\n\\begin{aligned}\n\\text{步骤 1: } \\left(I + \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{V}^{n+\\frac{1}{2}} = \\mathbf{V}^n \\\\\n\\text{步骤 2: } \\left(I + \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{V}^{n+1} = \\mathbf{V}^{n+\\frac{1}{2}}\n\\end{aligned}\n$$\n其中 $V^{n+\\frac{1}{2}}$ 是在中间时间 $t = T - \\Delta t/2$ 的解。左侧的算子矩阵与 Crank-Nicolson 方法中使用的相同。对于步骤 1，右侧是内部点上的向量 $V^n$。在 $S=0$ 处的边界条件是 $V_0^{n+\\frac{1}{2}} = Ke^{-r\\Delta t/2}$。对于步骤 2，右侧是步骤 1 中计算出的向量 $V^{n+\\frac{1}{2}}$。在 $S=0$ 处的边界条件是 $V_0^{n+1} = Ke^{-r\\Delta t}$。\n在两种格式中，得到的三对角系统都使用 Thomas 算法求解，这是一种针对此类系统的直接且数值稳定的方法。\n\n最后，为了量化伪振荡，我们分析计算出的解 $V^{n+1}$。看跌期权的价值必须是资产价格 $S$ 的一个单调不增函数。因此，任何正的离散斜率 $\\Delta V_i = V_{i+1} - V_i  0$ 都表示对该性质的违反，是数值伪振荡的一个特征。我们计算两个指标：整个网格上此类违规的总数，以及在以行权价 $K$ 为中心、半宽为 $w$ 的指定窗口内的计数。差分索引 $i$ 的窗口定义为 $i \\in \\{\\max(0, i_K-w), \\dots, \\min(N-1, i_K+w)\\}$，其中 $i_K = \\lfloor K/\\Delta S \\rfloor$。我们还计算最大正斜率 $\\max(0, \\max_{i \\text{ in window}} \\Delta V_i)$，作为行权价附近振荡幅度的度量。为每个测试用例计算这六个量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_tridiagonal(a, b, c, d):\n    \"\"\"\n    Solves a tridiagonal linear system Ax=d using the Thomas algorithm.\n    a: sub-diagonal (length n-1)\n    b: main diagonal (length n)\n    c: super-diagonal (length n-1)\n    d: right-hand side vector (length n)\n    \"\"\"\n    n = len(d)\n    c_prime = np.zeros(n - 1)\n    d_prime = np.zeros(n)\n    x = np.zeros(n)\n\n    if n == 0:\n        return x\n    \n    # Forward elimination\n    c_prime[0] = c[0] / b[0]\n    d_prime[0] = d[0] / b[0]\n    for i in range(1, n - 1):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        c_prime[i] = c[i] / denum\n    for i in range(1, n):\n        denum = b[i] - a[i - 1] * c_prime[i - 1]\n        d_prime[i] = (d[i] - a[i - 1] * d_prime[i - 1]) / denum\n\n    # Backward substitution\n    x[n - 1] = d_prime[n - 1]\n    for i in range(n - 2, -1, -1):\n        x[i] = d_prime[i] - c_prime[i] * x[i + 1]\n\n    return x\n\ndef analyze_oscillations(values, N, dS, K, w):\n    \"\"\"\n    Analyzes the solution vector for monotonicity violations.\n    \"\"\"\n    diffs = np.diff(values)\n    \n    # Full grid analysis\n    full_grid_violations = np.sum(diffs > 1e-9) # Use a small tolerance for float comparison\n\n    # Window analysis\n    i_K = int(np.floor(K / dS))\n    # The diffs array has length N. diffs[i] is V[i+1] - V[i].\n    # We are interested in indices i from i_K-w to i_K+w-1\n    window_start = max(0, i_K - w)\n    window_end = min(N-1, i_K + w) \n    \n    window_diffs = diffs[window_start : window_end]\n    \n    window_violations = np.sum(window_diffs > 1e-9)\n    max_overshoot = 0.0\n    if window_diffs.size > 0:\n        max_overshoot = np.max(window_diffs, initial=0.0)\n    \n    if max_overshoot  1e-9:\n        max_overshoot = 0.0\n\n    return int(full_grid_violations), int(window_violations), float(max_overshoot)\n\n\ndef run_case(case_params):\n    \"\"\"\n    Runs a single test case for the Black-Scholes PDE problem.\n    \"\"\"\n    N, M, K, T, S_max, r, sigma, w = case_params\n\n    # Grid setup\n    dt = T / M\n    dS = S_max / N\n    S = np.linspace(0, S_max, N + 1)\n\n    # Terminal condition V(S, T)\n    V_current = np.maximum(K - S, 0.0)\n\n    # Discretized operator coefficients\n    i = np.arange(1, N)\n    s_i = i * dS\n    alpha = 0.5 * sigma**2 * s_i**2 / dS**2 - 0.5 * r * s_i / dS\n    beta = -sigma**2 * s_i**2 / dS**2 - r\n    gamma = 0.5 * sigma**2 * s_i**2 / dS**2 + 0.5 * r * s_i / dS\n\n    # --- 1. Crank-Nicolson Scheme ---\n    # System (I + dt/2 * A)V_new = (I - dt/2 * A)V_old\n    \n    # LHS matrix (I + dt/2 * A) diagonals\n    a_LHS = 0.5 * dt * alpha[1:]\n    b_LHS = 1.0 + 0.5 * dt * beta\n    c_LHS = 0.5 * dt * gamma[:-1]\n\n    # RHS vector from (I - dt/2 * A)V_old\n    V_int_current = V_current[1:N]\n    rhs_cn = (1.0 - 0.5 * dt * beta) * V_int_current\n    rhs_cn[1:] += (-0.5 * dt * alpha[1:]) * V_current[0:N-2]\n    rhs_cn[:-1] += (-0.5 * dt * gamma[:-1]) * V_current[2:N]\n    \n    # Boundary conditions for CN\n    v0_n_plus_1 = K * np.exp(-r * dt)\n    vN_n_plus_1 = 0.0\n    \n    # Adjust RHS for BCs: move known V_0_new and V_N_new terms from LHS\n    rhs_cn[0] -= (0.5 * dt * alpha[0]) * v0_n_plus_1\n    rhs_cn[-1] -= (0.5 * dt * gamma[-1]) * vN_n_plus_1\n    \n    # Solve tridiagonal system for interior points\n    V_int_new_cn = solve_tridiagonal(a_LHS, b_LHS, c_LHS, rhs_cn)\n\n    # Assemble full solution vector\n    V_cn = np.zeros(N + 1)\n    V_cn[0] = v0_n_plus_1\n    V_cn[1:N] = V_int_new_cn\n    V_cn[N] = vN_n_plus_1\n\n    # Analyze oscillations\n    cn_full, cn_window, cn_max_slope = analyze_oscillations(V_cn, N, dS, K, w)\n\n    # --- 2. Rannacher Damping Scheme ---\n    # Two backward Euler steps with dt/2\n    # System (I + dt/2 * A)V_new = V_old\n    # LHS matrix is the same as for CN.\n    \n    # Step 1: V_n -> V_{n+1/2}\n    V_int_step1_rhs = V_int_current.copy()\n    v0_n_plus_half = K * np.exp(-r * dt * 0.5)\n    vN_n_plus_half = 0.0\n    \n    V_int_step1_rhs[0] -= (0.5 * dt * alpha[0]) * v0_n_plus_half\n    V_int_step1_rhs[-1] -= (0.5 * dt * gamma[-1]) * vN_n_plus_half\n    \n    V_int_half = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step1_rhs)\n\n    # Step 2: V_{n+1/2} -> V_{n+1}\n    V_int_step2_rhs = V_int_half.copy()\n    \n    V_int_step2_rhs[0] -= (0.5 * dt * alpha[0]) * v0_n_plus_1\n    V_int_step2_rhs[-1] -= (0.5 * dt * gamma[-1]) * vN_n_plus_1\n    \n    V_int_new_rannacher = solve_tridiagonal(a_LHS, b_LHS, c_LHS, V_int_step2_rhs)\n\n    # Assemble full solution vector\n    V_rannacher = np.zeros(N + 1)\n    V_rannacher[0] = v0_n_plus_1\n    V_rannacher[1:N] = V_int_new_rannacher\n    V_rannacher[N] = vN_n_plus_1\n\n    # Analyze oscillations\n    r_full, r_window, r_max_slope = analyze_oscillations(V_rannacher, N, dS, K, w)\n\n    return [cn_full, cn_window, r_full, r_window, cn_max_slope, r_max_slope]\n\ndef solve():\n    # Define parameters common to all cases\n    K = 100.0\n    T = 1.0\n    S_max = 500.0\n    r = 0.05\n    sigma = 0.2\n    w = 5\n    \n    test_cases_params = [\n        (200, 10),  # Case A: N, M\n        (400, 50),  # Case B\n        (400, 200), # Case C\n    ]\n\n    results = []\n    for N, M in test_cases_params:\n        case_params = (N, M, K, T, S_max, r, sigma, w)\n        case_results = run_case(case_params)\n        results.append(case_results)\n\n    formatted_results = [\n        \"[\" + \",\".join(map(str, [int(x) if i  4 else float(x) for i, x in enumerate(res)])) + \"]\" for res in results\n    ]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2391467"}, {"introduction": "在我们掌握了如何构建一个稳定的隐式求解器之后，一个自然而然的问题是如何在不显著增加计算成本的情况下进一步提高其精度。Richardson外推法为此提供了一种强大而通用的技术，可以提高任何具有已知收敛阶数的数值方法的准确性。本练习将要求你使用两种不同的时间步长（例如 $\\Delta t$ 和 $\\Delta t/2$）运行Crank-Nicolson求解器，然后将两个结果线性组合，以消除主要的误差项，从而获得更高阶的精度估计。掌握这项技术是实现高效、精确金融建模的关键一步。[@problem_id:2391443]", "problem": "考虑在风险中性定价原则下，一个不支付股息资产的欧式看涨期权的价值。该期权的现货价格为 $S$，行权价为 $K$，波动率为 $\\sigma$，连续复利无风险利率为 $r$，到期时间为 $T$。价值函数 $V(S,t)$ 在 $0  S  S_{\\max}$ 和 $0 \\le t  T$ 的范围内，满足以下后向抛物型偏微分方程 (PDE)\n$$\n\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V = 0,\n$$\n其终端条件为 $V(S,T) = \\max(S - K, 0)$，对于欧式看涨期权，边界条件如下：$V(0,t) = 0$，以及当资产价格很大时，$V(S_{\\max},t) = S_{\\max} - K e^{-r (T - t)}$。假设 $S_{\\max}$ 足够大，以确保边界条件的准确性。\n\n您的任务是在空间均匀网格上实现一个 Crank–Nicolson 有限差分求解器，将该偏微分方程从 $t = T$到 $t = 0$ 进行时间逆向步进求解。对一阶和二阶导数使用空间中心差分。然后，通过在同一空间网格上计算两次 $t=0$ 时的解，应用理查森外推法 (Richardson Extrapolation) 提高时间精度：一次使用时间步长 $\\Delta t = T/N$，另一次使用 $\\Delta t/2 = T/(2N)$，并将它们组合成一个更高阶的估计值。具体来说，如果 $p$ 表示该格式的时间精度阶数，则在任何固定空间点上的外推估计值为\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{2^p - 1}.\n$$\n对于 Crank–Nicolson 方法，取 $p = 2$。对于每种情况，报告在给定现货价格 $S_0$ 下的外推期权价值。\n\n作为对一个经过充分检验的公式的验证，您还需要使用相同的 $S_0$、$K$、$r$、$\\sigma$ 和 $T$ 参数，通过布莱克-斯科尔斯闭式解计算相应的欧式看涨期权价格。对于退化情况 $\\sigma = 0$，使用风险中性极限 $V_{\\mathrm{BS}} = \\max(S_0 - K e^{-r T}, 0)$。对于 $\\sigma  0$，在布莱克-斯科尔斯公式中使用常规的高斯累积分布函数。对于每种情况，报告理查森外推有限差分估计值与布莱克-斯科尔斯解析价格之间的绝对误差。\n\n实现要求：\n- 空间网格：在 $[0, S_{\\max}]$ 区间上对 $S$ 使用均匀网格，包含 $M$ 个子区间（即 $M+1$ 个网格点）。使用 $M \\ge 2$。\n- 时间步进：采用 Crank–Nicolson 隐式方法，从 $t = T$ 到 $t = 0$ 进行均匀的逆向步进。\n- 线性系统求解器：利用三对角结构，通过托马斯算法 (Thomas algorithm) 或等效的带状求解器求解。\n- 插值：通过在 $S$ 网格上进行线性插值，返回 $t=0$ 和 $S_0$ 时的价格。\n- 理查森外推法：将时间步长为 $\\Delta t$ 和 $\\Delta t/2$ 的解与 $p=2$ 结合，公式为 $V_{\\mathrm{Rich}} = V_{\\Delta t/2} + \\frac{V_{\\Delta t/2} - V_{\\Delta t}}{3}$。\n- 单位：为便于计算，所有货币量均为名义值且无单位；将数值报告为浮点数。\n- 角度单位不适用。\n\n测试套件：\n实现您的程序以运行以下四组参数集，每组均以元组 $(S_0, K, r, \\sigma, T, S_{\\max}, M, N)$ 的形式指定：\n1) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.2, 1.0, 400, 200, 50)$。\n2) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (80, 100, 0.03, 0.25, 2.0, 400, 200, 80)$。\n3) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (120, 100, 0.0, 0.2, 0.25, 400, 200, 40)$。\n4) $(S_0, K, r, \\sigma, T, S_{\\max}, M, N) = (100, 100, 0.05, 0.0, 1.0, 400, 200, 40)$。\n\n对于每种情况 $i \\in \\{1,2,3,4\\}$，计算：\n- 在 $t=0$ 和 $S_0$ 处的理查森外推 Crank–Nicolson 估计值 $V_{\\mathrm{Rich},i}$。\n- 绝对误差 $E_i = |V_{\\mathrm{Rich},i} - V_{\\mathrm{BS},i}|$，其中 $V_{\\mathrm{BS},i}$ 是相同参数下的布莱克-斯科尔斯解析价格。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[V_{\\mathrm{Rich},1}, E_1, V_{\\mathrm{Rich},2}, E_2, V_{\\mathrm{Rich},3}, E_3, V_{\\mathrm{Rich},4}, E_4].\n$$\n所有条目必须是浮点数。不应打印任何其他文本。", "solution": "所提出的问题是计算金融学中的一个标准练习，要求对欧式看涨期权的布莱克-斯科尔斯偏微分方程 (PDE) 进行数值求解。该问题定义明确、科学上合理且内部一致。它明确了偏微分方程、终端和边界条件，以及所需的数值方法——结合理查森外推法的 Crank–Nicolson 方法。提供了测试用例的所有参数，并且通过与解析解的对比进行验证是一种标准且恰当的验证程序。因此，该问题被认定为 **有效**。\n\n我们着手构建解决方案。布莱克-斯科尔斯偏微分方程可写为 $\\frac{\\partial V}{\\partial t} + \\mathcal{L}V = 0$，其中 $\\mathcal{L}$ 是空间微分算子。为方便数值计算，我们进行变量替换，将时间转换为正向时间 $\\tau = T - t$。偏微分方程变换为：\n$$\n\\frac{\\partial V}{\\partial \\tau} = \\mathcal{L}V = \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + r S \\frac{\\partial V}{\\partial S} - r V\n$$\n我们求解此方程，$\\tau$ 从 $0$ 到 $T$。$t=T$ 时的终端条件变为 $\\tau=0$ 时的初始条件：\n$$\nV(S, \\tau=0) = \\max(S - K, 0)\n$$\n边界条件为：\n$$\nV(0, \\tau) = 0 \\quad \\text{and} \\quad V(S_{\\max}, \\tau) = S_{\\max} - K e^{-r\\tau}\n$$\n\n我们在均匀网格上对域进行离散化：\n- 空间网格：$S_i = i \\Delta S$，其中 $i = 0, 1, \\dots, M$，$\\Delta S = S_{\\max} / M$。\n- 时间网格：$\\tau_j = j \\Delta \\tau$，其中 $j = 0, 1, \\dots, N$，$\\Delta \\tau = T / N$。\n令 $V_i^j$ 表示 $V(S_i, \\tau_j)$ 的数值近似值。\n\n应用 Crank–Nicolson 方法，这是一种隐式有限差分格式，它对时间步 $j$ 和 $j+1$ 上的空间算子进行平均：\n$$\n\\frac{V_i^{j+1} - V_i^j}{\\Delta \\tau} = \\frac{1}{2} \\left( \\mathcal{L}_h V_i^{j+1} + \\mathcal{L}_h V_i^j \\right)\n$$\n其中 $\\mathcal{L}_h$ 是使用中心差分的离散化空间算子。重排 Crank–Nicolson 格式，将未知值 $V^{j+1}$ 置于左侧 (LHS)，已知值 $V^j$ 置于右侧 (RHS)：\n$$\n\\left(I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^{j+1} = \\left(I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h\\right) V^j\n$$\n这代表了内部网格点 $i=1, \\dots, M-1$ 的一个线性方程组。该系统是三对角的。\n离散算子 $\\mathcal{L}_h$ 的系数为：\n$$\n\\begin{aligned}\n\\alpha_i = \\frac{\\sigma^2 S_i^2}{2\\Delta S^2} - \\frac{rS_i}{2\\Delta S} \\\\\n\\beta_i = -\\frac{\\sigma^2 S_i^2}{\\Delta S^2} - r \\\\\n\\gamma_i = \\frac{\\sigma^2 S_i^2}{2\\Delta S^2} + \\frac{rS_i}{2\\Delta S}\n\\end{aligned}\n$$\n左侧矩阵 $A = I - \\frac{\\Delta \\tau}{2}\\mathcal{L}_h$ 的三对角元素为：\n$$\na_i = -\\frac{\\Delta \\tau}{2}\\alpha_i, \\quad b_i = 1 - \\frac{\\Delta \\tau}{2}\\beta_i, \\quad c_i = -\\frac{\\Delta \\tau}{2}\\gamma_i\n$$\n右侧向量由 $B V^j$ 构成，其中 $B = I + \\frac{\\Delta \\tau}{2}\\mathcal{L}_h$。\n边界条件 $V_0^{j+1}=0$ 和 $V_M^{j+1}=S_{\\max}-Ke^{-r\\tau_{j+1}}$ 被整合到线性系统的第一个 ($i=1$) 和最后一个 ($i=M-1$) 方程中。在每个时间步，所得到的三对角系统可使用专门的算法（如托马斯算法）高效求解。\n\n此过程从 $\\tau=0$ 迭代到 $\\tau=T$。最终的解向量 $V^N$ 给出了 $t=0$ 时的期权价值。为找到特定现货价格 $S_0$ 处的价值，我们对最终的网格值使用线性插值。\n\n该过程运行两次：一次使用 $N$ 个时间步（步长 $\\Delta \\tau = T/N$），得到解 $V_{\\Delta \\tau}$；另一次使用 $2N$ 个时间步（步长 $\\Delta \\tau/2 = T/(2N)$），得到解 $V_{\\Delta \\tau/2}$。由于 Crank–Nicolson 方法的时间精度阶数为 $p=2$，我们应用理查森外推法以获得更精确的估计：\n$$\nV_{\\mathrm{Rich}} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{2^p - 1} = V_{\\Delta \\tau/2} + \\frac{V_{\\Delta \\tau/2} - V_{\\Delta \\tau}}{3}\n$$\n\n为了验证，将此数值结果与欧式看涨期权的布莱克-斯科尔斯解析公式进行比较：\n$$\nV_{\\mathrm{BS}}(S, t) = S_0 N(d_1) - K e^{-r(T-t)} N(d_2)\n$$\n其中 $N(\\cdot)$ 是标准正态累积分布函数 (CDF)，且\n$$\nd_1 = \\frac{\\ln(S_0/K) + (r + \\frac{1}{2}\\sigma^2)(T-t)}{\\sigma\\sqrt{T-t}}, \\quad d_2 = d_1 - \\sigma\\sqrt{T-t}\n$$\n在零波动率 ($\\sigma=0$) 的情况下，该公式退化为风险中性贴现收益：\n$$\nV_{\\mathrm{BS}}(S_0, t) = \\max(S_0 - K e^{-r(T-t)}, 0)\n$$\n在 $t=0$ 时的绝对误差 $E = |V_{\\mathrm{Rich}} - V_{\\mathrm{BS}}|$ 量化了我们数值实现的准确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\nfrom scipy.special import erf\n\ndef black_scholes_analytical(S0, K, r, sigma, T):\n    \"\"\"\n    Computes the analytical Black-Scholes price for a European call option.\n    \"\"\"\n    if sigma == 0:\n        return np.maximum(S0 - K * np.exp(-r * T), 0)\n\n    def norm_cdf(x):\n        return 0.5 * (1 + erf(x / np.sqrt(2)))\n\n    if T = 1e-10:\n        return np.maximum(S0 - K, 0)\n        \n    d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    call_price = S0 * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return call_price\n\ndef run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N_steps):\n    \"\"\"\n    Solves the Black-Scholes PDE using the Crank-Nicolson method.\n    This function solves the forward-in-time version: dV/d(tau) = LV\n    \"\"\"\n    # Grid parameters\n    dtau = T / N_steps\n    dS = Smax / M\n    S_vec = np.linspace(0, Smax, M + 1)\n    \n    # Grid of interior asset prices\n    i_vec = np.arange(1, M)\n    S_int = S_vec[1:-1]\n\n    # Initial condition at tau=0 (t=T)\n    V = np.maximum(S_vec - K, 0)\n    \n    # Coefficients for the discretized spatial operator L_h\n    alpha = 0.5 * sigma**2 * S_int**2 / dS**2 - 0.5 * r * S_int / dS\n    beta = -sigma**2 * S_int**2 / dS**2 - r\n    gamma = 0.5 * sigma**2 * S_int**2 / dS**2 + 0.5 * r * S_int / dS\n    \n    # LHS matrix A = I - dtau/2 * L_h (banded format)\n    A_banded = np.zeros((3, M - 1))\n    A_banded[0, 1:] = -0.5 * dtau * gamma[:-1]   # super-diagonal\n    A_banded[1, :] = 1 - 0.5 * dtau * beta        # main-diagonal\n    A_banded[2, :-1] = -0.5 * dtau * alpha[1:]   # sub-diagonal\n    \n    # Time-stepping loop (forward in tau)\n    for j in range(1, N_steps + 1):\n        tau = j * dtau\n        \n        # RHS vector: B * V^j = (I + dtau/2 * L_h) * V^j\n        rhs = (1 + 0.5 * dtau * beta) * V[1:-1] + \\\n              (0.5 * dtau * alpha) * V[:-2] + \\\n              (0.5 * dtau * gamma) * V[2:]\n        \n        # Boundary conditions at time tau\n        # V(0, tau) = 0 is handled as V[0] = 0.\n        V_M_tau = Smax - K * np.exp(-r * tau)\n        \n        # Adjust RHS for the known boundary value at S_max\n        # The term from LHS matrix is moved to RHS: -c_M-1 * V_M_tau\n        rhs[-1] -= (-0.5 * dtau * gamma[-1]) * V_M_tau\n        \n        # Solve the tridiagonal system A*V_new = rhs\n        V_interior = solve_banded((1, 1), A_banded, rhs, check_finite=False)\n        \n        # Update V for the next time step\n        V[1:-1] = V_interior\n        V[0] = 0.0 # Dirichlet boundary condition at S=0\n        V[-1] = V_M_tau # Dirichlet boundary condition at S_max\n\n    # Interpolate to find the price at S0\n    return np.interp(S0, S_vec, V)\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and generate final output.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, sigma, T, Smax, M, N)\n        (100, 100, 0.05, 0.2, 1.0, 400, 200, 50),\n        (80, 100, 0.03, 0.25, 2.0, 400, 200, 80),\n        (120, 100, 0.0, 0.2, 0.25, 400, 200, 40),\n        (100, 100, 0.05, 0.0, 1.0, 400, 200, 40),\n    ]\n\n    results = []\n    for case in test_cases:\n        S0, K, r, sigma, T, Smax, M, N = case\n        \n        # Calculate numerical solution with N and 2*N time steps\n        V_N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, N)\n        V_2N = run_crank_nicolson(S0, K, r, sigma, T, Smax, M, 2 * N)\n        \n        # Richardson Extrapolation (p=2 for Crank-Nicolson)\n        V_rich = V_2N + (V_2N - V_N) / 3.0\n        \n        # Calculate analytical solution for comparison\n        V_bs = black_scholes_analytical(S0, K, r, sigma, T)\n        \n        # Calculate absolute error\n        error = np.abs(V_rich - V_bs)\n        \n        results.extend([V_rich, error])\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391443"}, {"introduction": "掌握了构建稳健且高精度的PDE求解器的技能后，我们便能将其应用于更复杂的金融产品定价。复合期权（例如，看涨期权的看涨期权）就是一种典型的奇异衍生品，其价值取决于另一个期权的价格，这为数值方法提供了展示其灵活性的绝佳舞台。本练习将通过一个两阶段过程来展示PDE方法的威力：首先，求解标的期权的PDE以确定其在某个中间时刻的价值；然后，将此结果作为复合期权PDE的终端支付函数，进而求解复合期权在当前时刻的价格。[@problem_id:2391429]", "problem": "考虑一个在风险中性测度下的无摩擦市场，其中一种不付股息或连续支付股息的股票，其价格由具有恒定漂移率和波动率的几何布朗运动建模。设$S$表示股票价格，$t$表示以年为单位、从当前$t=0$开始计算的时间，$r$表示连续复利无风险利率（以年化小数形式表示），$q$表示连续股息收益率（以年化小数形式表示），$\\sigma$表示恒定波动率(以年化小数形式表示，单位为 年$^{-1/2}$)。设$K_2$是到期时间为$T_2$的欧式看涨期权的行权价，设$K_1$是该看涨期权之上的欧式看涨期权（即看涨期权上的看涨期权）的行权价，其到期时间为$T_1$，且$0 \\le t \\le T_1 \\le T_2$。目标是计算该复合期权在当前时间$t=0$、标的股票即期价格为$S_0$时的价格。\n\n定义$U(S,t)$为行权价为$K_2$、到期日为$T_2$的欧式看涨期权的无套利价格。在标准假设下，$U(S,t)$满足Black–Scholes偏微分方程（PDE）\n$$\n\\frac{\\partial U}{\\partial t}(S,t) + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 U}{\\partial S^2}(S,t) + (r - q) S \\frac{\\partial U}{\\partial S}(S,t) - r U(S,t) = 0,\n$$\n对于$S \\in (0,\\infty)$和$t \\in [0,T_2)$，其终端条件为\n$$\nU(S,T_2) = \\max(S - K_2, 0).\n$$\n在一个有界计算域$S \\in [0,S_{\\max}]$上，对所有$t \\in [0,T_2]$施加边界条件：\n- $U(0,t) = 0$，\n- $U(S_{\\max},t) = S_{\\max}\\,\\mathrm{e}^{-q (T_2 - t)} - K_2\\,\\mathrm{e}^{-r (T_2 - t)}$。\n\n定义$V(S,t)$为到期日为$T_1$、行权价为$K_1$的看涨期权上的看涨期权（复合期权）的无套利价格。对于$t \\in [0,T_1)$，它满足相同的Black–Scholes偏微分方程，\n$$\n\\frac{\\partial V}{\\partial t}(S,t) + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2}(S,t) + (r - q) S \\frac{\\partial V}{\\partial S}(S,t) - r V(S,t) = 0,\n$$\n其在$t = T_1$时的终端收益为\n$$\nV(S,T_1) = \\max\\big(U(S,T_1) - K_1, 0\\big).\n$$\n在相同的有界域$S \\in [0,S_{\\max}]$上，对所有$t \\in [0,T_1]$施加边界条件：\n- $V(0,t) = 0$，\n- $V(S_{\\max},t) = U(S_{\\max},t) - K_1\\,\\mathrm{e}^{-r (T_1 - t)}$，其中$U(S_{\\max},t)$近似为$S_{\\max}\\,\\mathrm{e}^{-q (T_2 - t)} - K_2\\,\\mathrm{e}^{-r (T_2 - t)}$。\n\n您的程序必须：\n- 在$S \\in [0,S_{\\max}]$的均匀网格和时间的均匀网格上，将$U(S,t)$的偏微分方程从$t=T_2$向后求解至$t=T_1$，\n- 使用计算出的$U(S,T_1)$作为$V(S,t)$在$t=T_1$时的终端收益，\n- 在相同的均匀空间网格上，将$V(S,t)$的偏微分方程从$t=T_1$向后求解至$t=0$，\n- 通过在计算出的网格上对$S$进行线性插值，返回复合期权价格$V(S_0,0)$。\n\n所有利率和收益率必须解释为小数（而非百分比）。时间以年为单位计量。不涉及角度。数值域、网格和参数在下方的每个测试用例中指定。最终答案必须是实数。要求的最终输出格式是单行文本，包含一个Python列表，其中包含所有测试用例的结果，结果之间用逗号分隔，并用方括号括起来。每个结果必须使用标准四舍五入到$6$位小数。\n\n测试套件。对于每个测试用例，请精确使用所提供的参数、空间和时间网格：\n- 测试用例 1：\n  - $r = 0.05$, $q = 0.00$, $\\sigma = 0.20$, $S_0 = 100$, $K_1 = 10$, $K_2 = 100$, $T_1 = 0.50$, $T_2 = 1.00$，\n  - $S_{\\max} = 400$，\n  - 空间网格规模 $N_S = 200$（因此 $\\Delta S = S_{\\max}/N_S$），\n  - $U$的时间步数：$N^{(U)}_t = 1000$（因此 $\\Delta t_U = T_2/N^{(U)}_t$ 且 $T_1/\\Delta t_U$ 是整数），\n  - $V$的时间步数：$N^{(V)}_t = 500$（因此 $\\Delta t_V = T_1/N^{(V)}_t$）。\n- 测试用例 2：\n  - $r = 0.03$, $q = 0.01$, $\\sigma = 0.25$, $S_0 = 120$, $K_1 = 15$, $K_2 = 100$, $T_1 = 0.25$, $T_2 = 0.75$，\n  - $S_{\\max} = 500$，\n  - 空间网格规模 $N_S = 220$，\n  - $U$的时间步数：$N^{(U)}_t = 600$（因此 $\\Delta t_U = T_2/N^{(U)}_t$ 且 $T_1/\\Delta t_U$ 是整数），\n  - $V$的时间步数：$N^{(V)}_t = 200$。\n- 测试用例 3：\n  - $r = 0.01$, $q = 0.00$, $\\sigma = 0.15$, $S_0 = 80$, $K_1 = 5$, $K_2 = 90$, $T_1 = 0.02$, $T_2 = 0.50$，\n  - $S_{\\max} = 360$，\n  - 空间网格规模 $N_S = 180$，\n  - $U$的时间步数：$N^{(U)}_t = 500$（因此 $\\Delta t_U = T_2/N^{(U)}_t$ 且 $T_1/\\Delta t_U$ 是整数），\n  - $V$的时间步数：$N^{(V)}_t = 20$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表，每个条目四舍五入到$6$位小数，并按测试用例的顺序排列。例如：\"[x1,x2,x3]\"，其中$x1$、$x2$和$x3$分别是测试用例1、2和3的四舍五入价格。", "solution": "问题陈述经过严格审查，被认为是有效的。它在科学上基于成熟的Black-Scholes期权定价框架，在数学上是适定的，并且其细节规定得足够充分、无歧义，可以得到唯一的数值解。该问题要求对一个欧式看涨期权上的另一个欧式看涨期权进行估值，通常称为复合期权。这是一个序贯定价问题，必须首先确定标的期权在复合期权到期时的价格。解决方案将通过使用有限差分法数值求解Black-Scholes偏微分方程（PDE）来获得。\n\n为此任务选择了Crank-Nicolson方法。它在时间和空间上都是二阶精度的，并且无条件稳定，使其成为处理像Black-Scholes方程这样的抛物型偏微分方程的稳健选择。求解过程分为两个主要阶段。\n\n首先，我们确定行权价为$K_2$、到期日为$T_2$的标的看涨期权的价格$U(S,t)$。其控制PDE为 $\\frac{\\partial U}{\\partial t} + \\mathcal{A}U = 0$，其中 $\\mathcal{A}$ 是空间微分算子。该方程从时间$t=T_2$向后求解至$t=T_1$。\n\n其次，我们确定行权价为$K_1$、到期日为$T_1$的复合期权的价格$V(S,t)$。它由相同的PDE控制，从$t=T_1$向后求解至$t=0$，使用第一阶段计算的价格函数$U(S,T_1)$来定义$V$的终端条件。\n\n令$W(S,t)$代表任一期权$U$或$V$的价格。我们在均匀网格上离散化求解域。空间域$S \\in [0, S_{\\max}]$被划分为$N_S$个大小为$\\Delta S = S_{\\max}/N_S$的区间，得到网格点$S_i = i \\Delta S$。时间域以大小为$\\Delta t$的均匀步长进行离散化。我们将$W(S_i, t_j)$的近似值表示为$W_i^j$。\n\n空间导数使用中心差分进行近似。将这些代入Black-Scholes偏微分方程，并对内部节点$i \\in \\{1, \\dots, N_S-1\\}$进行离散化，我们得到一个常微分方程组。对于时间导数，稳定的Crank-Nicolson格式在从时间步$j$向后求解到$j-1$时，其离散形式为：\n$$\n\\left(I + \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{W}^{j-1} = \\left(I - \\frac{\\Delta t}{2}\\mathbf{A_h}\\right) \\mathbf{W}^j\n$$\n其中 $\\mathbf{A_h}$ 是离散化的空间算子。这形成了一个三对角线性方程组 $L \\mathbf{W}^{j-1} = \\mathbf{R}$，必须在每个时间步求解。左侧矩阵 $L=I + \\frac{\\Delta t}{2}\\mathbf{A_h}$ 仅依赖于常数参数，可以一次性构建。右侧向量 $\\mathbf{R}$ 依赖于前一个时间步的已知解 $\\mathbf{W}^j$。通过修改系统的第一个和最后一个方程来并入边界条件。\n\n**阶段1：为标的期权$U(S,t)$定价**\n1.  **网格设置**：定义空间网格$S_i$和时间步长$\\Delta t_U = T_2/N_t^{(U)}$。\n2.  **终端条件**：在$t=T_2$时，初始化期权价格：$U(S_i, T_2) = \\max(S_i - K_2, 0)$。\n3.  **边界条件**：对于每个时间步$t_j \\in [T_1, T_2]$，强制执行边界值：$U(0, t_j) = 0$ 和 $U(S_{\\max}, t_j) = S_{\\max}e^{-q(T_2-t_j)} - K_2e^{-r(T_2-t_j)}$。\n4.  **向后演化**：从$t=T_2$开始，为每个时间步向后迭代求解三对角系统，直到$t=T_1$。这得到期权价格向量$U(S_i, T_1)$。\n\n**阶段2：为复合期权$V(S,t)$定价**\n1.  **网格设置**：使用相同的空间网格和时间步长$\\Delta t_V = T_1/N_t^{(V)}$。\n2.  **终端条件**：在$t=T_1$时，使用阶段1的结果初始化复合期权的收益：$V(S_i, T_1) = \\max(U(S_i, T_1) - K_1, 0)$。\n3.  **边界条件**：对于每个时间步$t_j \\in [0, T_1]$，边界值为：$V(0, t_j) = 0$ 和 $V(S_{\\max}, t_j) = (S_{\\max}e^{-q(T_2-t_j)} - K_2e^{-r(T_2-t_j)}) - K_1e^{-r(T_1-t_j)}$。\n4.  **向后演化**：从$t=T_1$开始，在每个时间步迭代求解相应的$V$的三对角系统，直到$t=0$。这得到价格向量$V(S_i, 0)$。\n\n**最终结果**\n通过对空间网格上计算出的值$V(S_i, 0)$进行线性插值，获得初始股票价格$S_0$处的复合期权价格$V(S_0, 0)$。", "answer": "```python\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve_one_case(r, q, sigma, S0, K1, K2, T1, T2, S_max, N_S, N_t_U_total, N_t_V_total):\n    \"\"\"\n    Solves for the compound option price for a single set of parameters using\n    the Crank-Nicolson finite difference method. This is the backward-in-time version.\n    \"\"\"\n    # --- Spatial Grid Setup ---\n    dS = S_max / N_S\n    S_grid = np.linspace(0, S_max, N_S + 1)\n    S_int = S_grid[1:-1]\n    \n    # --- Part 1: Solve for U(S, t) from T2 down to T1 ---\n    dt_U = T2 / N_t_U_total\n    num_steps_U = int(round((T2 - T1) / dt_U))\n    \n    U = np.maximum(S_grid - K2, 0)\n    \n    # Coefficients for the discretized spatial operator A_h\n    alpha = 0.5 * sigma**2 * S_int**2 / dS**2 - 0.5 * (r - q) * S_int / dS\n    beta = -sigma**2 * S_int**2 / dS**2 - r\n    gamma = 0.5 * sigma**2 * S_int**2 / dS**2 + 0.5 * (r - q) * S_int / dS\n    \n    # LHS matrix for Crank-Nicolson: L = (I + dt/2 * A_h)\n    L_U = np.zeros((3, N_S - 1))\n    L_U[0, 1:] = 0.5 * dt_U * gamma[:-1]\n    L_U[1, :] = 1 + 0.5 * dt_U * beta\n    L_U[2, :-1] = 0.5 * dt_U * alpha[1:]\n\n    for j in range(num_steps_U):\n        t_old = T2 - j * dt_U\n        t_new = T2 - (j + 1) * dt_U\n        \n        # RHS vector from (I - dt/2 * A_h) * U_old\n        rhs_vec = (1 - 0.5 * dt_U * beta) * U[1:-1] - \\\n                  (0.5 * dt_U * alpha) * U[0:-2] - \\\n                  (0.5 * dt_U * gamma) * U[2:]\n        \n        U_Smax_new = S_max * np.exp(-q * (T2 - t_new)) - K2 * np.exp(-r * (T2 - t_new))\n        \n        # Adjust RHS for boundary condition at S_max (term moved from LHS)\n        rhs_vec[-1] -= (0.5 * dt_U * gamma[-1]) * U_Smax_new\n        \n        U_internal_new = solve_banded((1, 1), L_U, rhs_vec)\n        \n        U[1:-1] = U_internal_new\n        U[0] = 0.0\n        U[-1] = U_Smax_new\n        \n    U_at_T1 = U.copy()\n\n    # --- Part 2: Solve for V(S, t) from T1 down to 0 ---\n    dt_V = T1 / N_t_V_total\n    num_steps_V = N_t_V_total\n    \n    V = np.maximum(U_at_T1 - K1, 0)\n    \n    # LHS matrix for V: L = (I + dt/2 * A_h)\n    L_V = np.zeros((3, N_S - 1))\n    L_V[0, 1:] = 0.5 * dt_V * gamma[:-1]\n    L_V[1, :] = 1 + 0.5 * dt_V * beta\n    L_V[2, :-1] = 0.5 * dt_V * alpha[1:]\n    \n    for j in range(num_steps_V):\n        t_old = T1 - j * dt_V\n        t_new = T1 - (j + 1) * dt_V\n        \n        # RHS vector from (I - dt/2 * A_h) * V_old\n        rhs_vec = (1 - 0.5 * dt_V * beta) * V[1:-1] - \\\n                  (0.5 * dt_V * alpha) * V[0:-2] - \\\n                  (0.5 * dt_V * gamma) * V[2:]\n        \n        U_BC_Smax_new = S_max * np.exp(-q * (T2 - t_new)) - K2 * np.exp(-r * (T2 - t_new))\n        V_Smax_new = U_BC_Smax_new - K1 * np.exp(-r * (T1 - t_new))\n        \n        # Adjust RHS for boundary condition\n        rhs_vec[-1] -= (0.5 * dt_V * gamma[-1]) * V_Smax_new\n        \n        V_internal_new = solve_banded((1, 1), L_V, rhs_vec)\n        \n        V[1:-1] = V_internal_new\n        V[0] = 0.0\n        V[-1] = V_Smax_new\n        \n    V_at_0 = V\n    \n    price = np.interp(S0, S_grid, V_at_0)\n    \n    return round(price, 6)\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print results in the specified format.\n    \"\"\"\n    test_cases = [\n        # (r, q, sigma, S0, K1, K2, T1, T2, S_max, N_S, N_t_U_total, N_t_V_total)\n        (0.05, 0.00, 0.20, 100, 10, 100, 0.50, 1.00, 400, 200, 1000, 500),\n        (0.03, 0.01, 0.25, 120, 15, 100, 0.25, 0.75, 500, 220, 600, 200),\n        (0.01, 0.00, 0.15, 80, 5, 90, 0.02, 0.50, 360, 180, 500, 20),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = solve_one_case(*case)\n        results.append(result)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2391429"}]}