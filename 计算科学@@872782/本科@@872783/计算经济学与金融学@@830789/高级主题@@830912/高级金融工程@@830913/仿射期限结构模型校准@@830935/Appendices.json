{"hands_on_practices": [{"introduction": "本练习将经济学理论与计量实践联系起来。我们将构建一个仿射期限结构模型，其中短期利率由代表央行政策规则的潜在因子驱动，然后利用观测到的收益率曲线数据来估计这些不可观测的政策权重。这个练习展示了如何利用期限结构模型从金融市场价格中提取具有经济意义的信息[@problem_id:2370016]。", "problem": "要求您为一个高斯仿射期限结构模型 (ATSM) 实现并测试一个校准程序。在该模型中，短期利率由一个泰勒式政策规则生成，其系数是潜在的状态变量。该模型必须在风险中性测度下进行指定和求解。所有利率和收益率必须以小数形式处理（例如，2%的年收益率写作0.02），输出中不允许出现百分号。目标是从单一日期的合成收益率曲线观测值中，恢复进入短期利率的通货膨胀和失业率的潜在泰勒规则权重。\n\n基本基础和模型设置：\n- 在风险中性测度下工作，无套利原则意味着零息债券在时间 $t$ 的价格是贴现后收益的条件期望。形式上，对于一个 $n$ 年后到期的零息债券，其价格为 $P_t(n) \\equiv \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-\\sum_{j=0}^{n-1} r_{t+j}\\right)\\right]$，其中 $\\mathbb{Q}$ 表示风险中性测度。\n- 短期利率由一个泰勒式规则生成，其时变系数被视为状态，即 $r_t = \\delta_0 + \\delta_1^\\top x_t$，其中 $x_t \\in \\mathbb{R}^2$ 分别汇集了通货膨胀和失业率的泰勒规则权重。\n- 在风险中性测度下，状态是高斯的，并遵循一阶线性过程，$x_{t+1} = \\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1}$，其中 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)$，$\\mu \\in \\mathbb{R}^2$，$\\Phi \\in \\mathbb{R}^{2\\times 2}$ 是稳定的，$\\Sigma \\in \\mathbb{R}^{2\\times 2}$ 是下三角矩阵。风险的市场价格为零，因此物理动态与风险中性动态一致。\n\n需要实现的任务：\n1) 从风险中性定价恒等式和高斯线性状态动态出发，推导并实现零息债券价格的指数仿射解。特别地，证明存在序列 $\\{A_n\\}_{n\\ge 0}$ 和 $\\{B_n\\}_{n\\ge 0}$ 使得 $\\log P_t(n) = -A_n - B_n^\\top x_t$，并通过向前条件化一步来获得它们的递推关系。然后将模型隐含的 $n$ 年期零息收益率定义为 $y_t(n) \\equiv -\\frac{1}{n}\\log P_t(n)$。\n2) 给定在单个日期 $t$ 的 $N$ 个期限的横截面，展示如何通过利用线性关系 $y_t(n)\\,n - A_n = B_n^\\top x_t$ 来通过最小二乘法估计潜在状态 $x_t$。实现一个数值稳定的算法，从超定系统中计算最小二乘估计 $\\hat{x}_t$。\n3) 对于下方测试套件中的每个参数集，通过在真实状态 $x_t^{\\star}$ 处评估仿射收益率公式并添加一个确定性的测量扰动 $\\epsilon_n$ 来生成合成的观测收益率 $y^{\\text{obs}}(n)$。然后通过最小二乘法估计 $\\hat{x}_t$，并计算模型隐含收益率与观测收益率之间跨期限的样本内均方根误差 (RMSE)。\n\n校准目标和报告：\n- 对于每个测试用例，在期限 $\\mathcal{N} = \\{1,2,5,10\\}$ 年的情况下，构建 $y^{\\text{obs}}(n) = \\frac{A_n + B_n^\\top x_t^{\\star}}{n} + \\epsilon_n$，估计 $\\hat{x}_t$，并计算 $\\text{RMSE} \\equiv \\sqrt{\\frac{1}{|\\mathcal{N}|}\\sum_{n\\in \\mathcal{N}} \\left(y^{\\text{obs}}(n) - \\frac{A_n + B_n^\\top \\hat{x}_t}{n}\\right)^2}$。\n- 对于每个测试用例，您的程序必须输出一个三元组，包含 $\\hat{x}_t$ 的两个分量和 RMSE，所有值均四舍五入到小数点后六位。将所有测试用例的结果按照下面列出的顺序汇总到一个扁平列表中。\n- 最终输出格式要求：您的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。例如，如果有三个测试用例，输出必须看起来像“[x1_case1,x2_case1,rmse_case1,x1_case2,x2_case2,rmse_case2,x1_case3,x2_case3,rmse_case3]”。\n\n测试套件（所有数字均为小数，必须完全按照规定使用）：\n- 通用期限：$\\mathcal{N} = \\{\\,1,\\,2,\\,5,\\,10\\,\\}$ (年)。\n\n- 测试用例 1:\n  - 短期利率载荷：$\\delta_0 = 0.005$，$\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.02$, $u = 0.06$。\n  - 风险中性状态动态：$\\mu = [0.3, -0.1]^\\top$，$\\Phi = \\begin{bmatrix} 0.8  0 \\\\ 0  0.5 \\end{bmatrix}$，$\\Sigma = \\operatorname{diag}(0.1, 0.1)$。\n  - $t$ 时刻的真实状态：$x_t^{\\star} = [1.0, 0.5]^\\top$。\n  - 跨期限的测量扰动：$\\epsilon = [0.0000, 0.0000, 0.0000, 0.0000]^\\top$。\n\n- 测试用例 2 (近边界持久性):\n  - 短期利率载荷：$\\delta_0 = 0.004$，$\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.03$, $u = 0.05$。\n  - 风险中性状态动态：$\\mu = [-0.05, 0.02]^\\top$，$\\Phi = \\begin{bmatrix} 0.99  0 \\\\ 0  0.95 \\end{bmatrix}$，$\\Sigma = \\operatorname{diag}(0.05, 0.02)$。\n  - $t$ 时刻的真实状态：$x_t^{\\star} = [0.7, -0.3]^\\top$。\n  - 测量扰动：$\\epsilon = [0.0001, -0.0001, 0.0001, -0.0001]^\\top$。\n\n- 测试用例 3 (异构持久性和较大波动性):\n  - 短期利率载荷：$\\delta_0 = 0.002$，$\\delta_1 = [\\pi, u]^\\top$ 其中 $\\pi = 0.01$, $u = 0.08$。\n  - 风险中性状态动态：$\\mu = [-0.2, 0.4]^\\top$，$\\Phi = \\begin{bmatrix} 0.3  0 \\\\ 0  0.7 \\end{bmatrix}$，$\\Sigma = \\operatorname{diag}(0.2, 0.1)$。\n  - $t$ 时刻的真实状态：$x_t^{\\star} = [1.2, 0.2]^\\top$。\n  - 测量扰动：$\\epsilon = [0.0002, 0.0000, -0.0002, 0.0000]^\\top$。\n\n程序要求：\n- 根据上述描述，从第一性原理实现债券价格的仿射递推。\n- 使用数值稳定的线性代数方法解决 $\\hat{x}_t$ 的最小二乘问题。\n- 对于每个测试用例，返回三个数字 $(\\hat{x}_{t,1}, \\hat{x}_{t,2}, \\text{RMSE})$，所有值均四舍五入到小数点后六位。\n- 最终输出：一个包含 9 个浮点数（每个测试用例三个）的扁平列表的单行，顺序与测试套件完全一致，格式也与上述描述完全一致。不允许有其他输出。", "solution": "问题陈述是计算金融学中的一个有效练习。它描述了如何使用合成收益率曲线数据校准一个离散时间高斯仿射期限结构模型 (ATSM)。模型已完全指定，目标明确，问题在科学上是合理且适定的。我们继续进行解答。\n\n解答分为三个部分：第一，仿射系数递推公式的推导；第二，通过普通最小二乘法构建状态向量估计问题；第三，待实现算法的说明。\n\n**1. 仿射递推的推导**\n\n该模型在风险中性测度 $\\mathbb{Q}$ 下定义。一个在时间 $t$ 还有 $n$ 个周期到期的零息债券价格 $P_t(n)$ 由贴现后收益的风险中性期望给出：\n$$\nP_t(n) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-\\sum_{j=0}^{n-1} r_{t+j}\\right)\\right]\n$$\n其中 $r_t$ 是短期利率。根据迭代期望定律，这可以递归地写为：\n$$\nP_t(n) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(-r_t) \\cdot \\exp\\left(-\\sum_{j=1}^{n-1} r_{t+j}\\right)\\right] = \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(-r_t) \\cdot P_{t+1}(n-1)\\right]\n$$\n模型假设债券价格具有指数仿射形式，我们将其写为：\n$$\nP_t(n) = \\exp(-A_n - B_n^\\top x_t)\n$$\n其中 $A_n$ 是一个标量，$B_n \\in \\mathbb{R}^2$。短期利率 $r_t$ 和状态向量 $x_t$ 被指定为：\n$$\nr_t = \\delta_0 + \\delta_1^\\top x_t\n$$\n$$\nx_{t+1} = \\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1}, \\quad \\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)\n$$\n将这些代入递归定价方程中：\n$$\n\\exp(-A_n - B_n^\\top x_t) = \\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-(\\delta_0 + \\delta_1^\\top x_t)\\right) \\exp\\left(-A_{n-1} - B_{n-1}^\\top x_{t+1}\\right) \\right]\n$$\n由于涉及 $t$ 时刻变量的项在时间 $t$ 是已知的，因此可以将其从期望中提出：\n$$\n\\exp(-A_n - B_n^\\top x_t) = \\exp(-\\delta_0 - \\delta_1^\\top x_t - A_{n-1}) \\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-B_{n-1}^\\top x_{t+1}\\right) \\right]\n$$\n我们现在通过代入 $x_{t+1}$ 的动态来计算该期望：\n$$\n\\mathbb{E}_t^{\\mathbb{Q}}\\left[ \\exp\\left(-B_{n-1}^\\top (\\mu + \\Phi x_t + \\Sigma \\varepsilon_{t+1})\\right) \\right] = \\exp\\left(-B_{n-1}^\\top \\mu - B_{n-1}^\\top \\Phi x_t\\right) \\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp\\left(-B_{n-1}^\\top \\Sigma \\varepsilon_{t+1}\\right)\\right]\n$$\n剩余的期望涉及随机变量 $Z = -B_{n-1}^\\top \\Sigma \\varepsilon_{t+1}$。由于 $\\varepsilon_{t+1} \\sim \\mathcal{N}(0, I)$，$Z$ 是一个标量正态变量，其均值为 $\\mathbb{E}[Z]=0$，方差为 $\\text{Var}(Z) = (-B_{n-1}^\\top \\Sigma) \\mathbb{E}[\\varepsilon_{t+1}\\varepsilon_{t+1}^\\top] (-B_{n-1}^\\top \\Sigma)^\\top = B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}$。一个正态变量 $Y \\sim \\mathcal{N}(m, \\sigma^2)$ 在点 $s$ 处的矩生成函数是 $\\mathbb{E}[\\exp(sY)] = \\exp(sm + \\frac{1}{2}s^2\\sigma^2)$。对于 $Z$，在 $s=1$ 处求值，我们有：\n$$\n\\mathbb{E}_t^{\\mathbb{Q}}\\left[\\exp(Z)\\right] = \\exp\\left(\\frac{1}{2}\\text{Var}(Z)\\right) = \\exp\\left(\\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}\\right)\n$$\n将其代回并对两边取对数，得到：\n$$\n-A_n - B_n^\\top x_t = (-\\delta_0 - A_{n-1} - B_{n-1}^\\top \\mu + \\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}) - (\\delta_1^\\top + B_{n-1}^\\top \\Phi) x_t\n$$\n这个恒等式必须对任何状态 $x_t$ 都成立。通过匹配截距项和 $x_t$ 的系数，我们得到以下关于 $A_n$ 和 $B_n$ 的递推关系：\n$$\nB_n = \\Phi^\\top B_{n-1} + \\delta_1\n$$\n$$\nA_n = A_{n-1} + \\delta_0 + B_{n-1}^\\top \\mu - \\frac{1}{2} B_{n-1}^\\top \\Sigma \\Sigma^\\top B_{n-1}\n$$\n该递推关系对于零期限债券进行初始化，$P_t(0)=1$，此时 $\\log P_t(0)=0$。这意味着对所有 $x_t$ 都有 $-A_0 - B_0^\\top x_t=0$，这要求初始条件为：\n$$\nA_0 = 0, \\quad B_0 = \\mathbf{0} \\in \\mathbb{R}^2\n$$\n\n**2. 通过最小二乘法进行状态估计**\n\n$n$ 周期债券的模型隐含收益率定义为 $y_t(n) = -\\frac{1}{n} \\log P_t(n)$。使用仿射结构：\n$$\ny_t(n) = \\frac{A_n + B_n^\\top x_t}{n}\n$$\n给定一组针对期限 $\\mathcal{N}=\\{n_1, \\dots, n_N\\}$ 的观测收益率 $\\{y^{\\text{obs}}(n_i)\\}_{i=1}^N$，我们的目标是估计未观测到的状态向量 $x_t$。重新整理收益率方程可得到一个线性关系：\n$$\nn \\cdot y_t(n) - A_n = B_n^\\top x_t\n$$\n假设观测收益率是由模型在真实状态 $x_t^\\star$ 处加上测量扰动 $\\epsilon_n$ 生成的：\n$$\ny^{\\text{obs}}(n) = \\frac{A_n + B_n^\\top x_t^\\star}{n} + \\epsilon_n\n$$\n将其代入线性关系中得到：\n$$\nn \\cdot y^{\\text{obs}}(n) - A_n = B_n^\\top x_t^\\star + n \\cdot \\epsilon_n\n$$\n对于一组 $N$ 个期限，我们可以将这些方程堆叠起来，形成一个超定线性系统。令 $Z$ 为一个 $N \\times 1$ 向量，其元素为 $Z_i = n_i \\cdot y^{\\text{obs}}(n_i) - A_{n_i}$，令 $\\mathbf{B}$ 为一个 $N \\times 2$ 矩阵，其行为 $B_{n_i}^\\top$。该系统为：\n$$\nZ = \\mathbf{B} x_t + \\nu\n$$\n其中 $\\nu$ 是定价误差向量。最小二乘估计 $\\hat{x}_t$ 最小化了误差平方和 $\\|Z - \\mathbf{B} x_t\\|^2$，并由法方程的解给出：\n$$\n\\hat{x}_t = (\\mathbf{B}^\\top \\mathbf{B})^{-1} \\mathbf{B}^\\top Z\n$$\n这个系统应该使用数值稳定的方法来求解，例如 QR 分解或奇异值分解 (SVD)，这些方法在标准的科学计算库中都有实现。\n\n**3. 算法实现与评估**\n\n对于每个测试用例，校准过程如下：\n1.  初始化 $A_0 = 0$ 和 $B_0 = [0, 0]^\\top$。\n2.  使用推导出的递推关系，迭代计算并存储系数 $\\{A_n, B_n\\}$，其中 $n=1, \\dots, 10$。\n3.  对于指定的期限 $\\mathcal{N} = \\{1, 2, 5, 10\\}$，使用提供的真实状态 $x_t^{\\star}$ 和测量扰动 $\\epsilon_n$ 生成合成的“观测”收益率 $y^{\\text{obs}}(n)$。\n4.  构建 $4 \\times 1$ 的目标向量 $Z$，其中第 $i$ 个元素为 $n_i \\cdot y^{\\text{obs}}(n_i) - A_{n_i}$。\n5.  构建 $4 \\times 2$ 的回归矩阵 $\\mathbf{B}$，其中第 $i$ 行为 $B_{n_i}^\\top$。\n6.  求解线性最小二乘问题 $Z = \\mathbf{B} \\hat{x}_t$ 以找到估计的状态向量 $\\hat{x}_t$。\n7.  使用估计的 $\\hat{x}_t$ 计算每个 $n \\in \\mathcal{N}$ 的模型隐含收益率 $y^{\\text{model}}(n) = (A_n + B_n^\\top \\hat{x}_t)/n$。\n8.  计算观测收益率和模型隐含收益率之间的样本内均方根误差 (RMSE)：\n    $$\n    \\text{RMSE} = \\sqrt{\\frac{1}{|\\mathcal{N}|}\\sum_{n\\in \\mathcal{N}} (y^{\\text{obs}}(n) - y^{\\text{model}}(n))^2}\n    $$\n9.  该测试用例的最终结果是一个元组 $(\\hat{x}_{t,1}, \\hat{x}_{t,2}, \\text{RMSE})$，每个值都四舍五入到小数点后六位。\n\n这个过程是确定性的，并直接在所提供的数据上实现了理论框架。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the ATSM calibration problem for all test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test Case 1\n        {\n            \"delta0\": 0.005,\n            \"delta1\": np.array([0.02, 0.06]),\n            \"mu\": np.array([0.3, -0.1]),\n            \"Phi\": np.array([[0.8, 0.0], [0.0, 0.5]]),\n            \"Sigma\": np.diag([0.1, 0.1]),\n            \"x_true\": np.array([1.0, 0.5]),\n            \"epsilon\": np.array([0.0000, 0.0000, 0.0000, 0.0000]),\n        },\n        # Test Case 2\n        {\n            \"delta0\": 0.004,\n            \"delta1\": np.array([0.03, 0.05]),\n            \"mu\": np.array([-0.05, 0.02]),\n            \"Phi\": np.array([[0.99, 0.0], [0.0, 0.95]]),\n            \"Sigma\": np.diag([0.05, 0.02]),\n            \"x_true\": np.array([0.7, -0.3]),\n            \"epsilon\": np.array([0.0001, -0.0001, 0.0001, -0.0001]),\n        },\n        # Test Case 3\n        {\n            \"delta0\": 0.002,\n            \"delta1\": np.array([0.01, 0.08]),\n            \"mu\": np.array([-0.2, 0.4]),\n            \"Phi\": np.array([[0.3, 0.0], [0.0, 0.7]]),\n            \"Sigma\": np.diag([0.2, 0.1]),\n            \"x_true\": np.array([1.2, 0.2]),\n            \"epsilon\": np.array([0.0002, 0.0000, -0.0002, 0.0000]),\n        },\n    ]\n\n    maturities = np.array([1, 2, 5, 10])\n    max_maturity = np.max(maturities)\n\n    all_results = []\n\n    for case in test_cases:\n        delta0 = case[\"delta0\"]\n        delta1 = case[\"delta1\"]\n        mu = case[\"mu\"]\n        Phi = case[\"Phi\"]\n        Sigma = case[\"Sigma\"]\n        x_true = case[\"x_true\"]\n        epsilon = case[\"epsilon\"]\n\n        # 1. Compute affine coefficients A_n and B_n\n        A = np.zeros(max_maturity + 1)\n        B = np.zeros((max_maturity + 1, 2))\n        \n        A[0] = 0.0\n        B[0, :] = 0.0\n\n        Sigma_SigmaT = Sigma @ Sigma.T\n\n        for n in range(1, max_maturity + 1):\n            B[n, :] = Phi.T @ B[n-1, :] + delta1\n            A[n] = A[n-1] + delta0 + B[n-1, :].T @ mu - 0.5 * B[n-1, :].T @ Sigma_SigmaT @ B[n-1, :]\n\n        # 2. Generate synthetic observed yields\n        y_obs = np.zeros(len(maturities))\n        for i, n in enumerate(maturities):\n            y_obs[i] = (A[n] + B[n, :].T @ x_true) / n + epsilon[i]\n            \n        # 3. Set up and solve the least squares problem\n        num_maturities = len(maturities)\n        Z_vector = np.zeros(num_maturities)\n        B_matrix = np.zeros((num_maturities, 2))\n\n        for i, n in enumerate(maturities):\n            Z_vector[i] = n * y_obs[i] - A[n]\n            B_matrix[i, :] = B[n, :]\n            \n        # Solve for x_hat using numerically stable lstsq\n        x_hat, _, _, _ = np.linalg.lstsq(B_matrix, Z_vector, rcond=None)\n        \n        # 4. Compute model-implied yields and RMSE\n        y_model = np.zeros(num_maturities)\n        for i, n in enumerate(maturities):\n            y_model[i] = (A[n] + B[n, :].T @ x_hat) / n\n\n        rmse = np.sqrt(np.mean((y_obs - y_model)**2))\n\n        # 5. Append results rounded to 6 decimal places\n        all_results.append(round(x_hat[0], 6))\n        all_results.append(round(x_hat[1], 6))\n        all_results.append(round(rmse, 6))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2370016"}, {"introduction": "本练习超越了简单的最小二乘法，介绍了一种基于信息论的更高级的校准技术。您将通过最小化Kullback-Leibler (KL) 散度来校准Vasicek模型的参数，KL散度衡量了模型隐含的债券价格分布与经验分布之间的“距离”。这个练习强调了选择合适的目标函数的重要性，并提供了使用全局优化方法的经验[@problem_id:2370055]。", "problem": "考虑一个单因子 Vasicek 类型的仿射期限结构模型 (ATSM)，其中短利率 $r_t$ 在风险中性测度下遵循 $dr_t = \\kappa(\\theta - r_t)\\,dt + \\sigma\\,dW_t$。参数包括均值回归速度 $\\kappa$、长期均值 $\\theta$、波动率 $\\sigma$ 以及初始短利率 $r_0$。对于到期时间 $T \\ge 0$，模型在时间 $0$ 隐含的零息债券价格由下式给出\n$$\nP(0,T) = \\exp\\!\\big(A(T) - B(T)\\,r_0\\big),\n$$\n其中\n$$\nB(T) = \\frac{1 - e^{-\\kappa T}}{\\kappa},\n\\qquad\nA(T) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2,\n$$\n并约定当 $T=0$ 时，有 $B(0)=0$ 和 $A(0)=0$。对于一组有限的到期时间 $\\{T_i\\}_{i=1}^n$（其中 $T_i \\ge 0$），通过对债券价格进行归一化，定义在这些到期时间上的模型隐含横截面分布：\n$$\nq_i(\\kappa,\\theta,\\sigma,r_0) = \\frac{P(0,T_i)}{\\sum_{j=1}^n P(0,T_j)} \\quad \\text{其中 } i=1,\\dots,n.\n$$\n令 $\\{p_i\\}_{i=1}^n$ 为在相同到期时间上的一个经验横截面分布，满足 $p_i > 0$ 且 $\\sum_{i=1}^n p_i = 1$。定义从经验分布到模型隐含分布的 Kullback–Leibler (KL) 散度（使用自然对数）为\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\kappa,\\theta,\\sigma,r_0)\\big) \\;=\\; \\sum_{i=1}^n p_i \\,\\log\\!\\left(\\frac{p_i}{q_i(\\kappa,\\theta,\\sigma,r_0)}\\right).\n$$\n将校准问题表述为在参数向量 $(\\kappa,\\theta,\\sigma,r_0)$ 上对 $D_{\\mathrm{KL}}$ 的最小化，约束条件为 $\\kappa0$ 和 $\\sigma0$。假设无套利和风险中性定价成立。本问题不涉及物理单位，也不涉及角度。\n\n测试套件。对于以下三种情况中的每一种，都指定了到期时间 $\\{T_i\\}$ 和经验分布 $\\{p_i\\}$。在每种情况下，请精确使用给定的到期时间（以年为单位）和提供的经验概率（它们加起来已为 $1$）：\n\n- 情况 1：\n  - 到期时间：$\\{0.25,\\,0.5,\\,1.0,\\,2.0,\\,5.0,\\,10.0\\}$。\n  - 经验分布：$\\{0.27,\\,0.25,\\,0.20,\\,0.15,\\,0.08,\\,0.05\\}$。\n\n- 情况 2（包括零时刻的边界到期时间）：\n  - 到期时间：$\\{0.0,\\,0.25,\\,0.5,\\,1.0,\\,4.0,\\,7.0\\}$。\n  - 经验分布：$\\{0.35,\\,0.25,\\,0.18,\\,0.12,\\,0.06,\\,0.04\\}$。\n\n- 情况 3（包括非常长的到期时间）：\n  - 到期时间：$\\{0.5,\\,1.0,\\,1.5,\\,2.0,\\,5.0,\\,15.0,\\,30.0\\}$。\n  - 经验分布：$\\{0.26,\\,0.21,\\,0.17,\\,0.14,\\,0.10,\\,0.07,\\,0.05\\}$。\n\n参数域。将搜索限制在经济上合理的集合内\n$$\n\\kappa \\in [10^{-4},\\,5.0],\\quad \\theta \\in [-0.05,\\,0.15],\\quad \\sigma \\in [10^{-5},\\,0.2],\\quad r_0 \\in [-0.02,\\,0.2].\n$$\n\n要求输出。对于上述每种情况，按给定顺序，计算在给定域约束下 $D_{\\mathrm{KL}}$ 关于 $(\\kappa,\\theta,\\sigma,r_0)$ 的最小值。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，每个最小值四舍五入到 $10$ 位小数，例如 $\\big[\\text{result}_1,\\text{result}_2,\\text{result}_3\\big]$。", "solution": "所给出的问题是计算金融学中一个明确定义的任务。它要求将一个单因子 Vasicek 期限结构模型校准到经验观测数据。该校准被表述为一个数值优化问题，具体来说，是最小化模型隐含概率分布与给定经验分布之间的 Kullback-Leibler (KL) 散度。这是一个严谨且标准的方法。我们将采用一种规范的解法。\n\n问题的核心是找到参数向量 $\\mathbf{x} = (\\kappa, \\theta, \\sigma, r_0)$，使得目标函数 $D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))$ 最小化。向量 $\\mathbf{x}$ 由 Vasicek 模型参数组成：$\\kappa$（均值回归速度）、$\\theta$（长期均值）、$\\sigma$（波动率）和初始短利率 $r_0$。优化是在这些参数的指定有界域上进行的。\n\n目标函数 KL 散度由下式给出：\n$$\nD_{\\mathrm{KL}}\\big(p \\,\\|\\, q(\\mathbf{x})\\big) = \\sum_{i=1}^n p_i \\log\\left(\\frac{p_i}{q_i(\\mathbf{x})}\\right)\n$$\n其中 $\\{p_i\\}_{i=1}^n$ 是固定的经验分布，$\\{q_i(\\mathbf{x})\\}_{i=1}^n$ 是模型隐含的分布，其依赖于参数 $\\mathbf{x}$。模型隐含的概率是从一组到期时间 $\\{T_i\\}_{i=1}^n$ 的零息债券价格 $P(0, T_i)$ 导出的：\n$$\nq_i(\\mathbf{x}) = \\frac{P(0,T_i; \\mathbf{x})}{\\sum_{j=1}^n P(0,T_j; \\mathbf{x})}\n$$\n在 Vasicek 模型中，根据风险中性测度，债券价格是短利率的指数仿射函数：\n$$\nP(0,T) = \\exp\\big(A(T) - B(T)r_0\\big)\n$$\n函数 $A(T)$ 和 $B(T)$ 本身也是模型参数的函数。具体来说，对于到期时间 $T > 0$：\n$$\nB(T; \\kappa) = \\frac{1 - e^{-\\kappa T}}{\\kappa}\n$$\n$$\nA(T; \\kappa, \\theta, \\sigma) = \\left(\\theta - \\frac{\\sigma^2}{2\\kappa^2}\\right)\\big(B(T) - T\\big) - \\frac{\\sigma^2}{4\\kappa}\\,B(T)^2\n$$\n对于边界情况 $T=0$，使用约定 $A(0)=0$ 和 $B(0)=0$，这正确地导出了 $P(0,0)=1$。\n\n问题在于求解以下约束非线性优化问题：\n$$\n\\min_{\\mathbf{x} \\in \\mathcal{D}} D_{\\mathrm{KL}}(p \\,\\|\\, q(\\mathbf{x}))\n$$\n搜索域 $\\mathcal{D}$ 是由以下定义的超矩形：\n$\\kappa \\in [10^{-4}, 5.0]$，$\\theta \\in [-0.05, 0.15]$，$\\sigma \\in [10^{-5}, 0.2]$，以及 $r_0 \\in [-0.02, 0.2]$。\n\n目标函数是非线性的，其对参数的依赖关系复杂，可能导致一个具有多个局部最小值的优化景观。一个简单的基于梯度的局部优化器可能无法找到全局最小值。因此，全局优化算法是合适的选择。我们将使用 `scipy.optimize` 库提供的 `differential_evolution` 算法。这是一种基于种群的随机优化方法，对于在箱型约束域上寻找函数的全局最小值具有鲁棒性。\n\n为了数值稳定性，特别是在处理指数时，使用对数是明智的。目标函数可以重写为：\n$$\nD_{\\mathrm{KL}} = \\sum_{i=1}^n p_i (\\log p_i - \\log q_i)\n$$\n$\\log q_i$ 项计算为 $\\log q_i = \\log P(0,T_i) - \\log(\\sum_j P(0,T_j))$。分母中指数项的和如果直接计算，在数值上是不稳定的。我们可以使用 log-sum-exp 稳定技巧：\n$$\n\\log\\left(\\sum_{j=1}^n P(0,T_j)\\right) = \\log\\left(\\sum_{j=1}^n \\exp\\big(\\log P(0,T_j)\\big)\\right)\n$$\n其中 $\\log P(0,T_j) = A(T_j) - B(T_j)r_0$。`scipy.special.logsumexp` 函数能够稳健地实现这一计算。\n\n该实现将包含一个主函数，它将目标 $D_{\\mathrm{KL}}$ 定义为参数向量 $\\mathbf{x}$ 的函数。该函数将与指定的参数边界一起传递给 `differential_evolution` 求解器。这个过程将对三个测试用例中的每一个重复进行，并记录最小化的 KL 散度值。使用固定的随机数生成器种子以确保优化结果的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import differential_evolution\nfrom scipy.special import logsumexp\n\ndef vasicek_bond_price_components(params, T_values):\n    \"\"\"\n    Calculates the A(T) and B(T) components for the Vasicek model bond price.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n            r0 is not used in this function but is part of the standard parameter vector.\n        T_values (np.ndarray): An array of maturities T.\n    \n    Returns:\n        (np.ndarray, np.ndarray): A tuple containing the A(T) and B(T) arrays.\n    \"\"\"\n    kappa, theta, sigma, _ = params\n    T_values = np.asarray(T_values, dtype=float)\n    \n    A_T = np.zeros_like(T_values)\n    B_T = np.zeros_like(T_values)\n    \n    # Isolate non-zero maturities to avoid division by zero in formulas.\n    # The convention for T=0 is A(0)=0, B(0)=0, which is handled by the initialization.\n    non_zero_T_mask = T_values > 1e-9\n\n    if np.any(non_zero_T_mask):\n        T = T_values[non_zero_T_mask]\n        \n        # The parameter domain for kappa is [1e-4, 5.0], so kappa is never zero.\n        # Direct computation of B(T) is safe.\n        exp_minus_kappa_T = np.exp(-kappa * T)\n        B_T_vals = (1.0 - exp_minus_kappa_T) / kappa\n        \n        # Calculate A(T) using the formula from the problem statement.\n        term_B_minus_T = B_T_vals - T\n        kappa_sq = kappa * kappa\n        sigma_sq = sigma * sigma\n        \n        A_T_vals = (theta - sigma_sq / (2.0 * kappa_sq)) * term_B_minus_T - \\\n                   (sigma_sq / (4.0 * kappa)) * (B_T_vals**2)\n        \n        # Assign calculated values to the corresponding positions in the arrays.\n        B_T[non_zero_T_mask] = B_T_vals\n        A_T[non_zero_T_mask] = A_T_vals\n        \n    return A_T, B_T\n\ndef kl_divergence_objective(params, T_values, p_dist):\n    \"\"\"\n    Objective function calculating the KL divergence for Vasicek model calibration.\n    \n    Args:\n        params (list or np.ndarray): A list of parameters [kappa, theta, sigma, r0].\n        T_values (np.ndarray): An array of maturities T.\n        p_dist (np.ndarray): The empirical probability distribution.\n        \n    Returns:\n        float: The KL divergence D_KL(p || q).\n    \"\"\"\n    kappa, theta, sigma, r0 = params\n    \n    # Calculate A(T) and B(T)\n    A_T, B_T = vasicek_bond_price_components(params, T_values)\n    \n    # Calculate the logarithm of bond prices\n    log_P_0_T = A_T - B_T * r0\n\n    # Handle potential numerical overflows from intermediate calculations\n    if np.any(np.isnan(log_P_0_T)) or np.any(np.isinf(log_P_0_T)):\n        return np.inf\n\n    # Calculate log of model-implied probabilities q_i using log-sum-exp for stability\n    log_S = logsumexp(log_P_0_T)\n    log_q_dist = log_P_0_T - log_S\n    \n    # Calculate KL divergence: D_KL(p || q) = sum(p_i * (log(p_i) - log(q_i)))\n    # The problem specifies p_i > 0, so log(p_dist) is safe.\n    kl_div = np.sum(p_dist * (np.log(p_dist) - log_q_dist))\n    \n    return kl_div\n\ndef solve():\n    \"\"\"\n    Main function to solve the calibration problem for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([0.25, 0.5, 1.0, 2.0, 5.0, 10.0]),\n            np.array([0.27, 0.25, 0.20, 0.15, 0.08, 0.05])\n        ),\n        (\n            np.array([0.0, 0.25, 0.5, 1.0, 4.0, 7.0]),\n            np.array([0.35, 0.25, 0.18, 0.12, 0.06, 0.04])\n        ),\n        (\n            np.array([0.5, 1.0, 1.5, 2.0, 5.0, 15.0, 30.0]),\n            np.array([0.26, 0.21, 0.17, 0.14, 0.10, 0.07, 0.05])\n        )\n    ]\n\n    # Define the parameter search domain (bounds for the optimizer)\n    bounds = [\n        (1e-4, 5.0),    # kappa\n        (-0.05, 0.15),  # theta\n        (1e-5, 0.2),    # sigma\n        (-0.02, 0.2)    # r0\n    ]\n\n    results = []\n    for maturities, emp_dist in test_cases:\n        # Define the objective function for the current case\n        objective_func = lambda p: kl_divergence_objective(p, maturities, emp_dist)\n        \n        # Perform global optimization using differential evolution to find the minimum KL divergence\n        # A seed is used for reproducibility of the stochastic optimization process.\n        result = differential_evolution(objective_func, bounds, seed=42)\n        \n        # The minimized value of the objective function\n        min_kl_divergence = result.fun\n        results.append(min_kl_divergence)\n\n    # Format the results to 10 decimal places as required.\n    results_str = [f\"{r:.10f}\" for r in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2370055"}, {"introduction": "我们最后的练习是一个富有洞察力的“逆向工程”挑战，旨在加深您对校准过程本身的理解。给定一组“已校准”的参数，您的任务是推断出在底层的加权最小二乘目标函数中使用的隐含权重。这个练习阐明了优化的的一阶条件，并揭示了校准结果如何隐含地优先拟合某些数据点而非其他数据点[@problem_id:2370072]。", "problem": "考虑一个用于零息债券定价的指数仿射期限结构模型。对于期限 $T \\ge 0$，瞬时远期利率定义为\n$$\nf(0,T) \\equiv \\phi_0 + \\phi_1 e^{-\\lambda_1 T} + \\phi_2 e^{-\\lambda_2 T},\n$$\n其中 $\\phi_0$、$\\phi_1$ 和 $\\phi_2$ 是参数，$\\lambda_1$ 和 $\\lambda_2$ 是严格为正的常数。相应的模型隐含的期限为 $T$ 的零息债券价格为\n$$\nP_{\\text{model}}(T;\\boldsymbol{\\phi}) \\equiv \\exp\\!\\Bigg(-\\int_0^T f(0,u)\\,du\\Bigg) \n= \\exp\\!\\Bigg(-\\phi_0 T - \\frac{\\phi_1}{\\lambda_1}\\big(1-e^{-\\lambda_1 T}\\big) - \\frac{\\phi_2}{\\lambda_2}\\big(1-e^{-\\lambda_2 T}\\big)\\Bigg),\n$$\n参数向量为 $\\boldsymbol{\\phi} \\equiv (\\phi_0,\\phi_1,\\phi_2)^\\top$。\n\n假设在针对期限为 $\\{T_i\\}_{i=1}^n$ 的观测零息债券价格 $\\{P_{\\text{obs}}(T_i)\\}_{i=1}^n$ 进行校准时，使用加权最小二乘目标：\n$$\nS(\\boldsymbol{\\phi}) \\equiv \\sum_{i=1}^n w_i \\Big(P_{\\text{model}}(T_i;\\boldsymbol{\\phi}) - P_{\\text{obs}}(T_i)\\Big)^2,\n$$\n其中权重满足 $w_i \\ge 0$ 且 $\\sum_{i=1}^n w_i = 1$。假设在优化中对 $\\boldsymbol{\\phi}$ 没有约束。\n\n给定一个参数向量 $\\boldsymbol{\\phi}^\\star$，已知对于某些总和为1的未知非负权重 $\\{w_i\\}_{i=1}^n$，该向量是 $S(\\boldsymbol{\\phi})$ 的一个（无约束）一阶驻定点。同时，还给定期限和观测价格。您的任务是反向工程出一个权重向量 $\\boldsymbol{w}$，使得 $\\boldsymbol{\\phi}^\\star$ 满足一阶平稳性条件。\n\n使用上述模型定义和基础微积分推导出一阶平稳性的必要条件，然后计算一个满足这些条件和归一化条件 $\\sum_{i=1}^n w_i = 1$ 的权重向量 $\\boldsymbol{w}$。如果存在多个解，选择精确满足一阶条件和归一化条件的解，即求解相应的线性方程组；当该方阵系统是奇异的，则返回在最小二乘意义上满足条件的最小欧几里得范数解，然后重新归一化使其总和为 1。所有输出必须表示为小数（不含百分号）。\n\n测试套件。对于下面的每个测试用例，计算一个对应的权重向量 $\\boldsymbol{w} \\in \\mathbb{R}^n$：\n- 用例 1 (一般情况):\n  - $\\lambda_1 = 0.7$, $\\lambda_2 = 0.15$。\n  - 期限 (年): $T = [0.5, 1.0, 2.5, 5.0]$。\n  - 给定的驻定点参数: $\\boldsymbol{\\phi}^\\star = (0.018, -0.012, 0.020)$。\n  - 由相同模型从 $\\boldsymbol{\\phi}^{\\text{true}} = (0.019, -0.011, 0.0185)$ 生成的观测价格: $P_{\\text{obs}}(T_i) = P_{\\text{model}}(T_i; \\boldsymbol{\\phi}^{\\text{true}})$ 对于每个 $T_i$。\n\n- 用例 2 (包含 $T=0$ 处的边界价格):\n  - $\\lambda_1 = 1.0$, $\\lambda_2 = 0.3$。\n  - 期限 (年): $T = [0.0, 0.25, 1.0, 3.0]$。\n  - 给定的驻定点参数: $\\boldsymbol{\\phi}^\\star = (0.015, 0.002, 0.010)$。\n  - 如上从 $\\boldsymbol{\\phi}^{\\text{true}} = (0.0155, 0.0015, 0.0105)$ 生成的观测价格。\n\n- 用例 3 (因子载荷中存在近似共线性):\n  - $\\lambda_1 = 5.0$, $\\lambda_2 = 4.0$。\n  - 期限 (年): $T = [0.5, 0.9, 1.1, 1.5]$。\n  - 给定的驻定点参数: $\\boldsymbol{\\phi}^\\star = (0.020, 0.005, -0.004)$。\n  - 如上从 $\\boldsymbol{\\phi}^{\\text{true}} = (0.0195, 0.0040, -0.0035)$ 生成的观测价格。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个包含三个权重向量的列表，每个测试用例一个，每个权重向量表示为一个包含 n 个小数的列表，所有内容都包含在一个外部列表中。例如：`[[w_1_1, w_1_2, ...], [w_2_1, w_2_2, ...], ...]`。", "solution": "该问题要求我们，在给定特定参数向量 $\\boldsymbol{\\phi}^\\star$ 是目标函数的一阶驻定点的情况下，反向工程出一组用于加权最小二乘校准的权重 $\\boldsymbol{w} = (w_1, \\dots, w_n)^\\top$。\n\n需要最小化的目标函数由下式给出：\n$$\nS(\\boldsymbol{\\phi}) \\equiv \\sum_{i=1}^n w_i \\Big(P_{\\text{model}}(T_i;\\boldsymbol{\\phi}) - P_{\\text{obs}}(T_i)\\Big)^2\n$$\n其中 $\\boldsymbol{\\phi} = (\\phi_0, \\phi_1, \\phi_2)^\\top$ 是参数向量。权重满足 $w_i \\ge 0$ 且 $\\sum_{i=1}^n w_i = 1$。问题陈述优化是无约束的。\n\n如果 $S(\\boldsymbol{\\phi})$ 相对于 $\\boldsymbol{\\phi}$ 的梯度在该点为零，则点 $\\boldsymbol{\\phi}^\\star$ 是一个一阶驻定点：\n$$\n\\nabla_{\\boldsymbol{\\phi}} S(\\boldsymbol{\\phi}) \\Big|_{\\boldsymbol{\\phi}=\\boldsymbol{\\phi}^\\star} = \\boldsymbol{0}\n$$\n该向量方程对应于三个标量方程，每个 $\\boldsymbol{\\phi}$ 的分量一个：\n$$\n\\frac{\\partial S}{\\partial \\phi_j} \\Bigg|_{\\boldsymbol{\\phi}=\\boldsymbol{\\phi}^\\star} = 0 \\quad \\text{for } j=0, 1, 2.\n$$\n使用链式法则，我们计算 $S(\\boldsymbol{\\phi})$ 的偏导数：\n$$\n\\frac{\\partial S}{\\partial \\phi_j} = \\sum_{i=1}^n w_i \\cdot 2 \\Big(P_{\\text{model}}(T_i;\\boldsymbol{\\phi}) - P_{\\text{obs}}(T_i)\\Big) \\cdot \\frac{\\partial P_{\\text{model}}(T_i;\\boldsymbol{\\phi})}{\\partial \\phi_j}\n$$\n为了继续，我们必须计算模型债券价格 $P_{\\text{model}}(T;\\boldsymbol{\\phi})$ 相对于每个参数 $\\phi_j$ 的导数。债券价格由下式给出：\n$$\nP_{\\text{model}}(T;\\boldsymbol{\\phi}) = \\exp\\!\\Bigg(-\\phi_0 T - \\frac{\\phi_1}{\\lambda_1}\\big(1-e^{-\\lambda_1 T}\\big) - \\frac{\\phi_2}{\\lambda_2}\\big(1-e^{-\\lambda_2 T}\\big)\\Bigg) = \\exp(A(T;\\boldsymbol{\\phi}))\n$$\n其导数为：\n$$\n\\frac{\\partial P_{\\text{model}}(T;\\boldsymbol{\\phi})}{\\partial \\phi_j} = P_{\\text{model}}(T;\\boldsymbol{\\phi}) \\cdot \\frac{\\partial A(T;\\boldsymbol{\\phi})}{\\partial \\phi_j}\n$$\n指数项 $A(T;\\boldsymbol{\\phi})$ 的偏导数是因子载荷：\n$$\nL_{i,0} = \\frac{\\partial A(T_i;\\boldsymbol{\\phi})}{\\partial \\phi_0} = -T_i\n$$\n$$\nL_{i,1} = \\frac{\\partial A(T_i;\\boldsymbol{\\phi})}{\\partial \\phi_1} = -\\frac{1}{\\lambda_1}\\big(1-e^{-\\lambda_1 T_i}\\big)\n$$\n$$\nL_{i,2} = \\frac{\\partial A(T_i;\\boldsymbol{\\phi})}{\\partial \\phi_2} = -\\frac{1}{\\lambda_2}\\big(1-e^{-\\lambda_2 T_i}\\big)\n$$\n我们将驻定点 $\\boldsymbol{\\phi}^\\star$ 处期限为 $T_i$ 的定价误差定义为 $e_i = P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star) - P_{\\text{obs}}(T_i)$。\n在 $\\boldsymbol{\\phi} = \\boldsymbol{\\phi}^\\star$ 处评估的一阶条件，成为一个关于未知权重 $w_i$ 的线性方程组：\n$$\n\\sum_{i=1}^n w_i \\cdot 2 \\cdot e_i \\cdot P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star) \\cdot L_{i,j} = 0 \\quad \\text{for } j=0, 1, 2.\n$$\n常数因子 $2$ 可以去掉。我们将 $i=1, \\dots, n$ 和 $j=0, 1, 2$ 的系数 $c_{ij}$ 定义为：\n$$\nc_{ij} = e_i \\cdot P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star) \\cdot L_{i,j}\n$$\n一阶条件构成了关于 $n$ 个未知权重 $w_i$ 的一个包含 3 个线性方程的齐次方程组：\n$$\n\\begin{cases}\n\\sum_{i=1}^n c_{i0} w_i = 0 \\\\\n\\sum_{i=1}^n c_{i1} w_i = 0 \\\\\n\\sum_{i=1}^n c_{i2} w_i = 0\n\\end{cases}\n$$\n除了这三个方程，权重还必须满足归一化约束：\n$$\n\\sum_{i=1}^n w_i = 1\n$$\n我们现在有一个包含 4 个线性方程和 n 个未知数的方程组。对于提供的测试用例，n=4，因此我们有一个包含 4 个方程和 4 个未知数的方阵系统。我们可以将此系统写成矩阵形式 $\\boldsymbol{A}\\boldsymbol{w} = \\boldsymbol{b}$：\n$$\n\\begin{pmatrix}\nc_{10}  c_{20}  \\dots  c_{n0} \\\\\nc_{11}  c_{21}  \\dots  c_{n1} \\\\\nc_{12}  c_{22}  \\dots  c_{n2} \\\\\n1  1  \\dots  1\n\\end{pmatrix}\n\\begin{pmatrix}\nw_1 \\\\ w_2 \\\\ \\vdots \\\\ w_n\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n0 \\\\ 0 \\\\ 0 \\\\ 1\n\\end{pmatrix}\n$$\n解向量 $\\boldsymbol{w}$ 可以通过求解这个线性系统找到。算法流程如下：\n1.  对于给定的测试用例，使用提供的真实参数 $\\boldsymbol{\\phi}^{\\text{true}}$ 计算观测价格 $P_{\\text{obs}}(T_i)$。\n2.  使用给定的驻定参数 $\\boldsymbol{\\phi}^\\star$ 计算模型价格 $P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star)$。\n3.  对每个期限 $T_i$ 计算定价误差 $e_i = P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star) - P_{\\text{obs}}(T_i)$。\n4.  对每个期限 $T_i$ 和每个参数索引 $j$ 计算因子载荷 $L_{ij}$。\n5.  构造大小为 $n \\times 3$ 的系数矩阵 $\\boldsymbol{C}$，其元素为 $C_{ij} = c_{ij} = e_i \\cdot P_{\\text{model}}(T_i;\\boldsymbol{\\phi}^\\star) \\cdot L_{ij}$。\n6.  组装 $4 \\times 4$ 矩阵 $\\boldsymbol{A}$ 和 $4 \\times 1$ 向量 $\\boldsymbol{b}$。$\\boldsymbol{A}$ 的前三行是 $\\boldsymbol{C}$ 的转置，第四行是全为1的向量。$\\boldsymbol{b}=(0,0,0,1)^\\top$。\n7.  求解系统 $\\boldsymbol{A}\\boldsymbol{w} = \\boldsymbol{b}$。\n    - 如果 $\\boldsymbol{A}$ 是非奇异的，则存在唯一解，可以使用标准线性求解器找到。\n    - 如果 $\\boldsymbol{A}$ 是奇异的，如问题陈述所示，我们必须找到最小二乘问题 $\\min \\|\\boldsymbol{A}\\boldsymbol{w}-\\boldsymbol{b}\\|_2$ 的最小欧几里得范数解。设此解为 $\\boldsymbol{w}_{\\text{ls}}$。然后我们对其进行重新归一化，以确保满足总和为一的约束：$\\boldsymbol{w} = \\boldsymbol{w}_{\\text{ls}} / \\sum_i (\\boldsymbol{w}_{\\text{ls}})_i$。这处理了由于一阶条件和归一化约束之间的共线性导致系统不一致的情况。\n\n此程序将为每个测试用例实现。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the weight vector w in a weighted least squares calibration\n    of an affine term structure model, given a stationary point.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"l1\": 0.7, \"l2\": 0.15,\n            \"T\": np.array([0.5, 1.0, 2.5, 5.0]),\n            \"phi_star\": np.array([0.018, -0.012, 0.020]),\n            \"phi_true\": np.array([0.019, -0.011, 0.0185]),\n        },\n        {\n            \"l1\": 1.0, \"l2\": 0.3,\n            \"T\": np.array([0.0, 0.25, 1.0, 3.0]),\n            \"phi_star\": np.array([0.015, 0.002, 0.010]),\n            \"phi_true\": np.array([0.0155, 0.0015, 0.0105]),\n        },\n        {\n            \"l1\": 5.0, \"l2\": 4.0,\n            \"T\": np.array([0.5, 0.9, 1.1, 1.5]),\n            \"phi_star\": np.array([0.020, 0.005, -0.004]),\n            \"phi_true\": np.array([0.0195, 0.0040, -0.0035]),\n        }\n    ]\n\n    results = []\n\n    def p_model(T, phi, l1, l2):\n        \"\"\"Calculates the model zero-coupon bond price.\"\"\"\n        phi0, phi1, phi2 = phi\n        \n        # Use np.divide to handle T=0 or l=0 cases gracefully, though problem states l > 0\n        term1 = phi0 * T\n        term2 = np.divide(phi1, l1, out=np.zeros_like(T, dtype=float), where=l1!=0) * (1 - np.exp(-l1 * T))\n        term3 = np.divide(phi2, l2, out=np.zeros_like(T, dtype=float), where=l2!=0) * (1 - np.exp(-l2 * T))\n\n        return np.exp(-term1 - term2 - term3)\n\n    for case in test_cases:\n        l1, l2 = case[\"l1\"], case[\"l2\"]\n        T_arr = case[\"T\"]\n        phi_star = case[\"phi_star\"]\n        phi_true = case[\"phi_true\"]\n        n = len(T_arr)\n        k = len(phi_star)\n\n        # 1. Calculate observed and model prices\n        p_obs = p_model(T_arr, phi_true, l1, l2)\n        p_model_at_star = p_model(T_arr, phi_star, l1, l2)\n\n        # 2. Calculate pricing errors\n        errors = p_model_at_star - p_obs\n\n        # 3. Calculate factor loadings L (n x k matrix)\n        L = np.zeros((n, k))\n        L[:, 0] = -T_arr\n        L[:, 1] = -1/l1 * (1 - np.exp(-l1 * T_arr))\n        L[:, 2] = -1/l2 * (1 - np.exp(-l2 * T_arr))\n\n        # 4. Calculate coefficients c_ij (n x k matrix)\n        C = np.zeros((n, k))\n        for j in range(k):\n            C[:, j] = errors * p_model_at_star * L[:, j]\n\n        # 5. Assemble the matrix A and vector b for the system Aw = b\n        A = np.zeros((k+1, n))\n        A[:k, :] = C.T\n        A[k, :] = 1.0\n        \n        b = np.zeros(k+1)\n        b[k] = 1.0\n\n        # 6. Solve the linear system\n        # As per problem, if square system is singular, use lstsq and renormalize.\n        # We handle this by attempting a direct solve, and falling back to lstsq.\n        try:\n            # np.linalg.cond(A) could be used to check for ill-conditioning,\n            # but catching the error is more direct for singularity.\n            if np.linalg.det(A) == 0:\n                 raise np.linalg.LinAlgError(\"Singular matrix\")\n            w = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            # Handle singular case as per instruction\n            w_ls = np.linalg.lstsq(A, b, rcond=None)[0]\n            # Renormalize to ensure sum-to-one constraint is met\n            w = w_ls / np.sum(w_ls)\n\n        results.append(list(w))\n\n    # Format the final output string\n    # e.g., [[w11,w12,...],[w21,w22,...]]\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2370072"}]}