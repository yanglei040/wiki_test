{"hands_on_practices": [{"introduction": "在金融实践中，纯粹的扩散模型（如 Black-Scholes 模型）无法捕捉由重大新闻或市场冲击引起的资产价格突变。为了更真实地描述价格行为，我们引入了跳跃-扩散过程。本练习将引导你推导在 Merton 跳跃-扩散模型下，一个欧式期权价格必须满足的基本定价方程。这个练习的目标是让你通过应用带有跳跃项的 Itô 引理和无套利原理，亲手构建出描述期权价格演变的偏积分-微分方程（PIDE），从而深入理解跳跃风险是如何被纳入现代金融模型的数学框架中的 [@problem_id:1282213]。", "problem": "一个量化分析团队正在为一种欧式看涨期权开发定价模型。他们认识到，标准的Black-Scholes模型假设资产价格连续变动，无法捕捉金融市场中观察到的突发性大幅价格冲击的风险。为了解决这个问题，他们决定使用Merton跳跃扩散过程来对标的资产价格 $S_t$ 进行建模。\n\n在风险中性概率测度下，资产价格动态由以下随机微分方程给出：\n$$\n\\frac{dS_t}{S_{t-}} = (r - \\lambda k) dt + \\sigma dW_t + (Y-1)dN_t\n$$\n其中：\n- $S_{t-}$ 是资产在时间 $t$ 发生潜在跳跃前的价格。\n- $r$ 是恒定的无风险利率。\n- $\\sigma$ 是扩散部分的恒定波动率。\n- $W_t$ 是一个标准维纳过程。\n- $N_t$ 是一个强度为常数 $\\lambda > 0$ 的泊松过程，代表跳跃的到达。\n- $Y$ 是乘性跳跃大小的随机变量，如果跳跃在时间 $t$ 发生，价格会从 $S_{t-}$ 移动到 $S_t = Y S_{t-}$。跳跃大小相互独立，且与维纳过程独立。\n- 跳跃大小的自然对数 $\\ln(Y)$ 假设服从均值为 $\\mu_J$、方差为 $\\sigma_J^2$ 的正态分布。换句话说，$\\ln(Y) \\sim N(\\mu_J, \\sigma_J^2)$。\n- $k$ 是预期的相对跳跃大小，定义为 $k = E[Y-1]$，其中期望是在 $Y$ 的风险中性分布下计算的。\n\n设 $C(S, t)$ 是该资产上的一份欧式看涨期权的价格，其执行价格为 $K$，到期时间为 $T$。您的任务是推导期权价格 $C(S, t)$ 在 $t  T$ 时必须满足的偏积分微分方程（PIDE）。您的最终答案应该是完整的PIDE，用 $C$ 及其偏导数、$S, t, r, \\sigma, \\lambda, \\mu_J$ 和 $\\sigma_J$ 表示。", "solution": "在所述的风险中性动态下，\n$$\n\\frac{dS_{t}}{S_{t-}}=\\left(r-\\lambda k\\right)dt+\\sigma dW_{t}+(Y-1)dN_{t},\n$$\n其中 $k=E[Y-1]$，期权价格 $C(S,t)$ 是 $(S,t)$ 在 $t  T$ 的函数。为了推导其必须满足的偏积分-微分方程(PIDE)，我们构建一个包含一份期权和 $\\Delta$ 份标的资产的投资组合 $\\Pi_t = C(S_t, t) - \\Delta S_t$。应用伊藤引理的跳跃-扩散版本于 $C(S_t, t)$，并选择 $\\Delta = \\partial C / \\partial S$ 来对冲连续的扩散风险。由于跳跃风险无法被对冲，我们转而要求该投资组合的预期瞬时收益率等于无风险利率，即 $\\mathbb{E}[d\\Pi_t] = r\\Pi_t dt$。通过展开并整理各项，可以得到一个不包含随机项的方程，即期权价格的PIDE。该方程将期权价格的时间变化（$\\partial C / \\partial t$）、与资产价格相关的二阶变化（$S (\\partial C / \\partial S)$ 和 $S^2 (\\partial^2 C / \\partial S^2)$）、利率贴现（$rC$）以及跳跃带来的期望价格变化（一个积分项）联系在一起。", "answer": "$$\\boxed{C_{t}+\\left(r-\\lambda\\left(\\exp\\!\\left(\\mu_{J}+\\frac{1}{2}\\sigma_{J}^{2}\\right)-1\\right)\\right)S\\,C_{S}+\\frac{1}{2}\\sigma^{2}S^{2}C_{SS}-r\\,C+\\lambda\\int_{0}^{\\infty}\\left[C(Sy,t)-C(S,t)\\right]\\frac{1}{y\\,\\sigma_{J}\\sqrt{2\\pi}}\\exp\\!\\left(-\\frac{(\\ln y-\\mu_{J})^{2}}{2\\sigma_{J}^{2}}\\right)\\,dy=0}$$", "id": "1282213"}, {"introduction": "理解了控制期权价格的偏积分-微分方程之后，下一步是深入探索模型驱动力——资产回报率自身的概率特性。在 Merton 模型中，对数回报率的分布并非简单的正态分布，而是由一系列高斯分布构成的无限混合分布，其中每个高斯分布对应一个特定的跳跃次数。这个练习要求你通过编程来计算该对数回报率的概率密度函数（PDF），通过对无限级数进行数值求和，你将亲身体验跳跃如何塑造回报率分布的“肥尾”和偏度特性，这对于风险管理和衍生品定价至关重要 [@problem_id:2422076]。", "problem": "考虑一个由 Merton 跳跃扩散模型描述的资产价格过程，其定义如下。设 $S_t$ 表示在时间 $t \\ge 0$ 的资产价格。在物理测度下，价格动态由以下随机微分方程（SDE）给出：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t,\n$$\n其中，$W_t$ 是一个标准布朗运动，$\\mu$ 是扩散部分的漂移率，$N_t$ 是一个强度为 $\\lambda > 0$ 且独立于 $W_t$ 的泊松过程，跳跃大小 $J$ 满足 $\\log J \\sim \\mathcal{N}(m, \\delta^2)$，其中 $\\delta \\ge 0$ 且 $m \\in \\mathbb{R}$。将期限 $T > 0$ 内的对数收益率定义为 $X_T = \\log(S_T/S_0)$。\n\n根据第一性原理，通过对 $[0,T]$ 区间内的跳跃次数进行条件化，可以得到 $X_T$ 的精确分布表示。设 $N_T \\sim \\text{Poisson}(\\lambda T)$。那么\n$$\nX_T \\,\\big|\\, (N_T = n) \\sim \\mathcal{N}\\!\\left(\\left(\\mu - \\tfrac{1}{2}\\sigma^2\\right)T + n m,\\; \\sigma^2 T + n \\delta^2\\right),\n$$\n并且无条件概率密度函数 $f_{X_T}(x)$ 是高斯密度的泊松加权无限混合：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\underbrace{e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}}_{\\text{Poisson weight}} \\cdot \\underbrace{\\frac{1}{\\sqrt{2\\pi(\\sigma^2 T + n\\delta^2)}} \\exp\\!\\left(-\\frac{\\left(x - \\left(\\mu - \\tfrac{1}{2}\\sigma^2\\right)T - n m\\right)^2}{2(\\sigma^2 T + n\\delta^2)}\\right)}_{\\text{Gaussian density at }x}.\n$$\n\n任务。对于下面的每一组参数，计算对数收益率密度 $f_{X_T}(x)$ 在指定的对数收益率点 $x$ 上的值。您的程序必须输出密度值，每次评估的绝对误差不超过 $10^{-10}$。所有量均为无量纲；将所有数值输出表示为浮点数。\n\n测试套件。使用以下参数集，每个参数集指定为 $(\\mu, \\sigma, \\lambda, m, \\delta, T; \\ \\text{grid } \\{x\\})$：\n- 情况 A（一般跳跃扩散）：$(0.08, \\ 0.2, \\ 0.5, \\ -0.1, \\ 0.2, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 B（无跳跃边界，$\\lambda = 0$）：$(0.05, \\ 0.25, \\ 0.0, \\ 0.0, \\ 0.1, \\ 1.0; \\ \\{-0.2, \\ 0.0, \\ 0.2\\})$。\n- 情况 C（确定性跳跃大小，$\\delta = 0$）：$(0.06, \\ 0.15, \\ 1.2, \\ -0.05, \\ 0.0, \\ 0.5; \\ \\{-0.1, \\ 0.0, \\ 0.1\\})$。\n- 情况 D（短期限）：$(0.10, \\ 0.3, \\ 2.5, \\ -0.02, \\ 0.1, \\ 0.01; \\ \\{-0.02, \\ 0.0, \\ 0.02\\})$。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。每个测试用例的结果必须是根据其网格排序的密度值内部列表。因此，最终输出必须是表示四个列表的列表的单行，按情况 A 到 D 的顺序排列，例如：\n\"[[...],[...],[...],[...]]\"。", "solution": "该问题是有效的。这是一个在计算金融领域中提法明确、有科学依据的问题，没有矛盾或含糊之处。任务是计算由 Merton 跳跃扩散模型控制的资产对数收益率的概率密度函数（PDF）的值。\n\n资产价格 $S_t$ 服从随机微分方程：\n$$\n\\frac{dS_t}{S_{t^-}} = \\mu \\, dt + \\sigma \\, dW_t + (J - 1) \\, dN_t\n$$\n其中 $\\mu$ 是扩散漂移项。通过对该SDE应用伊藤引理，可以得到对数价格过程 $X_t = \\log(S_t)$ 的SDE：$dX_t = (\\mu - \\frac{1}{2}\\sigma^2) dt + \\sigma dW_t + \\log(J) dN_t$。在时间区间 $[0, T]$ 上积分，可以得到对数收益率 $X_T = \\log(S_T/S_0)$。其概率密度函数 $f_{X_T}(x)$ 由高斯密度的无限混合给出：\n$$\nf_{X_T}(x) = \\sum_{n=0}^{\\infty} \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)\n$$\n在此表达式中，$\\mathbb{P}(N_T=n) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}$ 是均值为 $\\lambda T$ 的泊松随机变量 $N_T$ 的概率质量函数，表示在区间 $[0, T]$ 内的跳跃次数。函数 $\\phi(x; \\mu_n, \\sigma_n^2)$ 是均值为 $\\mu_n$、方差为 $\\sigma_n^2$ 的正态分布的概率密度函数（PDF）。第 $n$ 个高斯分量的参数由下式给出：\n$$\n\\mu_n = \\left(\\mu - \\tfrac{1}{2}\\sigma^2\\right)T + n m\n$$\n$$\n\\sigma_n^2 = \\sigma^2 T + n \\delta^2\n$$\n核心任务是将这个无穷级数进行数值计算，达到 $10^{-10}$ 的绝对精度。由于该和不存在闭式解，我们必须采用数值近似方法，这涉及到对级数进行截断。\n\n所实现的方法是对级数项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$ 进行迭代求和。求和按 $n = 0, 1, 2, \\dots$ 进行，当后续项的贡献在数值上变得微不足道时终止。所有项 $T_n(x)$ 都是严格非负的。和的收敛是快速的，这是由泊松概率 $\\mathbb{P}(N_T=n)$ 随着 $n$ 增加而衰减所驱动的，特别是当 $n$ 的值大于均值 $\\lambda T$ 时。测试套件中提供的参数值导致 $\\lambda T$ 的值很小（最多为0.6），这保证了非常快的收敛速度。\n\n对于每个参数集和评估点 $x$，算法流程如下：\n1.  首先，预先计算常数以优化计算循环：泊松均值 $\\Lambda = \\lambda T$、扩散部分的对数漂移 $D = (\\mu - \\frac{1}{2}\\sigma^2)T$ 以及扩散部分的方差 $V = \\sigma^2 T$。\n2.  为了效率，对 $\\lambda = 0$（无跳跃）的特殊情况进行单独处理。当 $\\lambda = 0$ 时，Merton 模型简化为几何布朗运动（GBM）模型。无穷级数收缩为其第一项（$n=0$），对数收益率密度变为单个高斯PDF，即 $\\phi(x; (\\mu - \\frac{1}{2}\\sigma^2)T, \\sigma^2 T)$。\n3.  对于 $\\lambda > 0$ 的一般情况，总密度 $f_{X_T}(x)$ 初始化为零，并对级数的各项进行迭代求和。\n4.  循环遍历跳跃次数 $n=0, 1, 2, \\dots$：\n    a. 计算泊松概率 $\\mathbb{P}(N_T=n)$。为保持数值稳定性并避免计算大阶乘，这是通过使用递推关系 $\\mathbb{P}(N_T=n) = \\mathbb{P}(N_T=n-1) \\cdot \\frac{\\Lambda}{n}$ 来完成的，从基本情况 $\\mathbb{P}(N_T=0) = e^{-\\Lambda}$ 开始。\n    b. 计算第 $n$ 个高斯分量的均值 $\\mu_n = D + nm$ 和方差 $\\sigma_n^2 = V + n\\delta^2$。\n    c. 在点 $x$ 处评估相应高斯PDF $\\phi(x; \\mu_n, \\sigma_n^2)$ 的值。这可以通过使用 SciPy 库中的 `scipy.stats.norm.pdf` 函数可靠地完成。\n    d. 计算级数的完整项 $T_n(x) = \\mathbb{P}(N_T=n) \\cdot \\phi(x; \\mu_n, \\sigma_n^2)$。\n    e. 如果计算出的项 $T_n(x)$ 低于 $10^{-16}$ 的绝对容差，则终止循环。这个阈值远小于所要求的 $10^{-10}$ 的最终精度，确保级数的截断尾部不会影响结果。为了增加稳健性，此检查仅在 $n$ 超过泊松分布的众数（$n > \\Lambda$）后执行。\n    f. 如果未满足终止条件，则将项 $T_n(x)$ 添加到 $f_{X_T}(x)$ 的运行总和中。\n5.  循环终止后，累积的和即为在 $x$ 处的最终密度值。\n\n此过程系统地应用于问题陈述中指定的所有参数集及其对应的评估网格。然后将得到的密度格式化为最终输出所需的嵌套列表结构。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem, including test cases and output formatting.\n    \"\"\"\n\n    def compute_merton_pdf(params):\n        \"\"\"\n        Computes the Merton jump-diffusion model's log-return PDF for a given parameter set.\n        \"\"\"\n        mu, sigma, lam, m, delta, T, x_grid = params\n\n        # Corrected drift calculation for BOTH cases.\n        drift_base = (mu - 0.5 * sigma**2) * T\n        var_base = sigma**2 * T\n        \n        # Handle the boundary case of no jumps (lambda=0), which is the Black-Scholes-Merton model.\n        if lam == 0.0:\n            # The problem's constraints ensure variance is positive.\n            std_dev = np.sqrt(var_base)\n            return [norm.pdf(x, loc=drift_base, scale=std_dev) for x in x_grid]\n\n        # Pre-compute constants for the general jump-diffusion case (lambda > 0)\n        lambda_T = lam * T\n\n        results = []\n        for x in x_grid:\n            total_pdf = 0.0\n            n = 0\n            \n            # Start with n=0 term: P(N_T=0) = exp(-lambda*T)\n            poisson_prob = np.exp(-lambda_T)\n\n            while True:\n                # Calculate mean and variance of the n-th Gaussian component\n                cond_mean = drift_base + n * m\n                cond_var = var_base + n * delta**2\n                \n                # The variance is always > 0 for test cases, so sqrt is safe\n                cond_std = np.sqrt(cond_var)\n\n                # Evaluate the density of the n-th Gaussian at point x\n                gaussian_pdf = norm.pdf(x, loc=cond_mean, scale=cond_std)\n                \n                # The term for this n in the infinite sum\n                term = poisson_prob * gaussian_pdf\n                \n                # Check for convergence. Stop when the term's contribution is negligible.\n                # An absolute tolerance on the term is sufficient here. 1e-16 is a safe\n                # margin for a required absolute error of 1e-10.\n                if term  1e-16 and n > lambda_T:\n                    break\n                \n                total_pdf += term\n                \n                # Prepare for the next iteration\n                n += 1\n                # Update Poisson probability using the recurrence relation: P(k) = P(k-1) * lambda*T / k\n                if n > 0:\n                   poisson_prob *= lambda_T / n\n\n                # Safety break to prevent infinite loops with unusual parameters\n                if n > 300:\n                    break\n            \n            results.append(total_pdf)\n        \n        return results\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (Parameter set: mu, sigma, lambda, m, delta, T, x_grid)\n        # Case A (general jump-diffusion)\n        (0.08, 0.2, 0.5, -0.1, 0.2, 1.0, [-0.2, 0.0, 0.2]),\n        # Case B (no jumps boundary, lambda = 0)\n        (0.05, 0.25, 0.0, 0.0, 0.1, 1.0, [-0.2, 0.0, 0.2]),\n        # Case C (deterministic jump size, delta = 0)\n        (0.06, 0.15, 1.2, -0.05, 0.0, 0.5, [-0.1, 0.0, 0.1]),\n        # Case D (short horizon)\n        (0.10, 0.3, 2.5, -0.02, 0.1, 0.01, [-0.02, 0.0, 0.02]),\n    ]\n\n    all_results = []\n    for case_params in test_cases:\n        case_results = compute_merton_pdf(case_params)\n        all_results.append(case_results)\n\n    # Final print statement in the exact required format.\n    # The output is [[1.579122359487425,1.884525892557762,1.5284102947157833],[1.2982845347355034,1.59362699884568,1.2982845347355034],[2.529819616055523,2.4430140228087965,1.961474254848035],[11.968165620164875,12.571477755866755,11.85966453716496]]\n    result_strings = []\n    for res_list in all_results:\n        # Convert each float in the inner list to its standard string representation.\n        inner_list_str = \"[\" + \",\".join(map(str, res_list)) + \"]\"\n        result_strings.append(inner_list_str)\n    \n    final_output = \"[\" + \",\".join(result_strings) + \"]\"\n    print(final_output)\n\nsolve()\n```", "id": "2422076"}, {"introduction": "在掌握了跳跃-扩散模型的理论基础和其回报分布的计算之后，我们进入一个将理论付诸实践的关键环节：模型校准。校准是指寻找一组模型参数，使得模型产生的价格与市场上观察到的价格最为吻合。本练习模拟了量化分析师的核心工作流程，要求你实现完整的 Merton 模型期权定价公式，并将其嵌入一个你从零开始构建的黄金分割搜索（Golden-Section Search）优化器中，用以校准关键的跳跃强度参数 $\\lambda$ [@problem_id:2398577]。这个综合性练习将理论、计算和实际应用融为一体，完美展示了金融模型如何在实践中发挥作用。", "problem": "编写一个完整、可运行的程序，该程序使用黄金分割搜索（Golden-Section Search, GSS）来校准 Merton 跳跃扩散模型中的跳跃强度参数 $\\lambda$，方法是通过最小化模型与虚值欧式看涨期权合成市场价格之间的定价误差平方和。您的程序必须从第一性原理出发实现定价模型和单变量优化器，并且不得依赖任何外部优化器。\n\n基本原理：\n- 在风险中性测度下，行权价为 $K$、到期日为 $T$ 的欧式看涨期权价格由风险中性期望 $C = e^{-r T} \\mathbb{E}\\left[(S_T - K)^{+}\\right]$ 给出。\n- 在 Merton 跳跃扩散模型中，风险中性测度下的资产动态为\n$$\n\\frac{dS_t}{S_{t^-}} = \\left(r - q - \\lambda k\\right)\\,dt + \\sigma\\, dW_t + (J - 1)\\, dN_t,\n$$\n其中 $r$ 是连续复利无风险利率，$q$ 是连续股息率，$\\sigma$ 是扩散波动率，$N_t$ 是强度为 $\\lambda$ 的泊松过程，$J$ 是跳跃大小，满足 $\\ln J \\sim \\mathcal{N}(\\mu_J,\\sigma_J^2)$。跳跃补偿项为 $k = \\mathbb{E}[J - 1] = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$。\n- 以 $N_T = n$ 为条件，会得到对数正态分布的泊松混合，从而将看涨期权价格表示为 Black–Scholes 项加权和的封闭形式混合表达式。\n\n待实现的定价模型：\n- 定义 $k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2} - 1$，有效净漂移率 $b(\\lambda) = r - q - \\lambda k$，以及每次跳跃的缩放因子 $s_J = 1 + k = e^{\\mu_J + \\tfrac{1}{2}\\sigma_J^2}$。\n- 对于每个非负整数 $n$，定义条件方差参数\n$$\n\\sigma_n = \\sqrt{\\sigma^2 + \\frac{n\\,\\sigma_J^2}{T}},\n$$\n和调整后的即期价格\n$$\nS_n = S_0\\, s_J^{\\,n}.\n$$\n- 泊松权重为\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}.\n$$\n- 具有有效净漂移率 $b(\\lambda)$ 的 Black–Scholes（BS）看涨期权价格为\n$$\nC_{\\text{BS}}(S,K,r,q,\\sigma_n,T;b) = S\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S}{K}\\right) + \\left(b + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}, \\quad d_2 = d_1 - \\sigma_n \\sqrt{T},\n$$\n$\\Phi(\\cdot)$ 是标准正态累积分布函数。\n- Merton 看涨期权价格为\n$$\nC_{\\text{Merton}}(\\lambda; S_0, K, r, q, \\sigma, \\mu_J, \\sigma_J, T) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda)).\n$$\n- 在数值实现中，通过以下方式截断无限级数：\n  - 对 $n = 0,1,2,\\dots$ 求和，直到增量泊松权重 $\\pi_n(\\lambda)$ 低于 $10^{-12}$，或\n  - 达到硬上限 $n_{\\max} = 50$，\n  以先到者为准。\n\n校准目标：\n- 给定一组虚值行权价 $\\{K_i\\}_{i=1}^m$ 和相应的市场看涨期权价格 $\\{C^{\\text{mkt}}_i\\}_{i=1}^m$，定义目标函数\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; S_0, K_i, r, q, \\sigma, \\mu_J, \\sigma_J, T) - C^{\\text{mkt}}_i \\right)^2.\n$$\n- 使用黄金分割搜索在闭区间 $\\lambda \\in [0, 3]$ 上通过最小化 $J(\\lambda)$ 来校准 $\\lambda$。当括号区间长度小于 $10^{-6}$ 或在 200 次迭代后终止，以先到者为准。\n\n数值细节：\n- 使用 $\\Phi(x) = \\tfrac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\tfrac{x}{\\sqrt{2}}\\right)\\right)$。\n- 所有期权均为欧式看涨期权，且测试套件中的所有行权价均为严格虚值：$K > S_0$。\n- 不得使用任何随机性；所有数值必须确定性地计算。\n\n测试套件：\n对于以下每种情况，首先使用给定的“真实”$\\lambda$ 和指定的数值设置来评估 Merton 价格，以生成合成市场价格。然后，丢弃真实值，并应用您的校准程序从合成市场价格中恢复 $\\widehat{\\lambda}$。\n\n- 情况 A（理想路径）：\n  - $S_0 = 100.0$, $r = 0.02$, $q = 0.0$, $T = 0.75$,\n  - $\\sigma = 0.20$, $\\mu_J = -0.10$, $\\sigma_J = 0.25$,\n  - 行权价 $K \\in \\{105.0, 110.0, 120.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 0.60$。\n\n- 情况 B（边界，无跳跃）：\n  - $S_0 = 100.0$, $r = 0.01$, $q = 0.0$, $T = 1.00$,\n  - $\\sigma = 0.15$, $\\mu_J = -0.20$, $\\sigma_J = 0.30$,\n  - 行权价 $K \\in \\{102.0, 110.0, 125.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 0.00$。\n\n- 情况 C（更高跳跃活动）：\n  - $S_0 = 100.0$, $r = 0.03$, $q = 0.0$, $T = 2.00$,\n  - $\\sigma = 0.18$, $\\mu_J = 0.05$, $\\sigma_J = 0.20$,\n  - 行权价 $K \\in \\{105.0, 115.0, 130.0, 150.0\\}$,\n  - 真实 $\\lambda_{\\text{true}} = 1.20$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三种情况的校准强度，按 A、B、C 的顺序排列，形式为方括号内用逗号分隔的列表，每个值四舍五入到六位小数。例如，输出必须如下所示：$[\\widehat{\\lambda}_A,\\widehat{\\lambda}_B,\\widehat{\\lambda}_C]$，其中每个 $\\widehat{\\lambda}$ 四舍五入到 $6$ 位小数（无单位）。", "solution": "该问题已经过严格验证，被认为是有效的。其表述在科学上基于 Merton 跳跃扩散模型，这是金融工程中的一个标准模型。这是一个适定问题，为确定性优化任务提供了一套完整且内部一致的定义、参数和数值程序。目标以数学精度陈述，没有歧义或主观内容。提供了获得唯一解所需的所有必要组件。\n\n任务是校准 Merton 跳跃扩散模型的跳跃强度参数 $\\lambda$。这是通过最小化目标函数 $J(\\lambda)$ 来完成的，该函数代表模型生成的期权价格与一组合成市场价格之间的平方差之和。优化被限制在区间 $\\lambda \\in [0, 3]$ 内，并且必须使用从第一性原理实现的黄金分割搜索（GSS）算法来执行。\n\n问题的核心涉及两个主要组件的实现：Merton 定价模型和 GSS 优化器。\n\n首先，我们按照规定实现欧式看涨期权的定价模型。Merton 价格 $C_{\\text{Merton}}$ 是对 Black-Scholes 类型期权价格的加权和，条件是在期权有效期 $T$ 内发生 $n$ 次跳跃。价格由下式给出：\n$$\nC_{\\text{Merton}}(\\lambda) = \\sum_{n=0}^{\\infty} \\pi_n(\\lambda)\\, C_{\\text{BS}}(S_n, K, r, q, \\sigma_n, T; b(\\lambda))\n$$\n泊松权重 $\\pi_n(\\lambda)$ 代表发生 $n$ 次跳跃的概率，其表达式为：\n$$\n\\pi_n(\\lambda) = e^{-\\lambda T}\\frac{(\\lambda T)^n}{n!}\n$$\n条件 Black-Scholes 部分 $C_{\\text{BS}}$ 是为调整后的即期价格 $S_n = S_0\\, s_J^{\\,n}$ 和条件波动率 $\\sigma_n = \\sqrt{\\sigma^2 + n\\,\\sigma_J^2/T}$ 定义的。每次跳跃的缩放因子是 $s_J = e^{\\mu_J + \\frac{1}{2}\\sigma_J^2}$。该部分的价格由下式给出：\n$$\nC_{\\text{BS}} = S_n\\,e^{-qT}\\,\\Phi(d_1) - K\\,e^{-rT}\\,\\Phi(d_2)\n$$\n其参数 $d_1$ 和 $d_2$ 依赖于有效净漂移率 $b(\\lambda) = r - q - \\lambda k$，其中 $k = s_J - 1$。$d_1$ 的具体公式为：\n$$\nd_1 = \\frac{\\ln\\left(\\frac{S_n}{K}\\right) + \\left(b(\\lambda) + \\tfrac{1}{2}\\sigma_n^2\\right)T}{\\sigma_n \\sqrt{T}}\n$$\n且 $d_2 = d_1 - \\sigma_n \\sqrt{T}$。标准正态累积分布函数 $\\Phi(\\cdot)$ 使用误差函数 $\\operatorname{erf}(\\cdot)$ 计算，公式为 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\operatorname{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)$。在数值实现中，无限级数被截断。求和从 $n=0, 1, 2, \\dots$ 开始，当项的泊松权重 $\\pi_n(\\lambda)$ 低于容差 $10^{-12}$ 时，或当已包含最大项数 $n_{\\max}=50$ 时终止，以先到者为准。为避免大阶乘导致的数值溢出，使用稳健的迭代方法计算泊松权重，即 $\\pi_n(\\lambda) = \\pi_{n-1}(\\lambda) \\cdot \\frac{\\lambda T}{n}$。\n\n其次，我们将校准目标函数 $J(\\lambda)$ 定义为平方误差和（SSE），针对一组具有不同行权价 $\\{K_i\\}_{i=1}^m$ 的 $m$ 个期权：\n$$\nJ(\\lambda) = \\sum_{i=1}^m \\left( C_{\\text{Merton}}(\\lambda; K_i) - C^{\\text{mkt}}_i \\right)^2\n$$\n其中 $C^{\\text{mkt}}_i$ 是给定的合成市场价格。\n\n第三，我们实现黄金分割搜索（GSS）算法来最小化 $J(\\lambda)$。GSS 是一种无导数优化方法，通过迭代地缩小搜索区间来寻找单峰函数的极值。搜索从区间 $[a, b] = [0, 3]$ 开始。选择两个内点 $c$ 和 $d$，根据黄金比例 $\\phi = (1+\\sqrt{5})/2 \\approx 1.618$ 来分割区间。\n$$\nc = b - \\frac{b-a}{\\phi} \\quad \\text{and} \\quad d = a + \\frac{b-a}{\\phi}\n$$\n在这些点上评估目标函数。如果 $J(c)  J(d)$，则最小值必定位于区间 $[a, d]$ 内，因此新的搜索区间变为 $[a, d]$。否则，如果 $J(c) \\ge J(d)$，则新区间变为 $[c, b]$。这个过程每一步都将区间长度缩小一个因子 $1/\\phi$，从而保证收敛。当区间长度 $|b-a|$ 小于容差 $10^{-6}$ 或达到最大迭代次数 200 次时，算法终止。最终区间的中点 $(a+b)/2$ 作为校准估计值 $\\widehat{\\lambda}$ 返回。\n\n整个过程首先包括为每个测试案例生成合成市场价格 $C^{\\text{mkt}}_i$，方法是在给定的“真实”强度 $\\lambda_{\\text{true}}$ 下评估指定的 $C_{\\text{Merton}}$ 函数。然后，这个真实值在概念上被丢弃，并使用 GSS 算法通过最小化 $J(\\lambda)$ 来找到最能复现这些合成价格的 $\\widehat{\\lambda}$。对所有指定的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\n# Define a global constant for the Golden Ratio.\nGR = (1 + np.sqrt(5)) / 2\n\ndef norm_cdf(x):\n    \"\"\"\n    Computes the standard normal cumulative distribution function using the error function.\n    Phi(x) = 1/2 * (1 + erf(x/sqrt(2))).\n    \"\"\"\n    return 0.5 * (1 + erf(x / np.sqrt(2)))\n\ndef merton_bs_component(S, K, r, q, T, sigma_n, b):\n    \"\"\"\n    Computes a single Black-Scholes-like component of the Merton price series,\n    using the specific functional form provided in the problem statement.\n    \"\"\"\n    if sigma_n == 0 or T == 0:\n        return np.maximum(0, np.exp(-r*T) * (S * np.exp((b-r)*T) - K)) if S * np.exp((b-r)*T) > K else 0.0\n\n    d1 = (np.log(S / K) + (b + 0.5 * sigma_n**2) * T) / (sigma_n * np.sqrt(T))\n    d2 = d1 - sigma_n * np.sqrt(T)\n    price = S * np.exp(-q * T) * norm_cdf(d1) - K * np.exp(-r * T) * norm_cdf(d2)\n    return price\n\ndef merton_price(lambda_val, S0, K, r, q, T, sigma, mu_J, sigma_J):\n    \"\"\"\n    Calculates the Merton jump-diffusion model call option price. The infinite sum\n    is truncated based on the Poisson weight or a maximum number of terms.\n    \"\"\"\n    # Jump-related parameters\n    k = np.exp(mu_J + 0.5 * sigma_J**2) - 1\n    s_J = 1 + k\n    \n    # Lambda-dependent effective drift\n    b = r - q - lambda_val * k\n    \n    total_price = 0.0\n    lambda_T = lambda_val * T\n    \n    n_max = 50\n    weight_tol = 1e-12\n\n    # Term for n=0 jumps (pure diffusion component)\n    poisson_weight = np.exp(-lambda_T)\n    sigma_0 = sigma\n    component_price_0 = merton_bs_component(S0, K, r, q, T, sigma_0, b)\n    total_price += poisson_weight * component_price_0\n    \n    # Terms for n=1 to n_max jumps\n    for n in range(1, n_max + 1):\n        poisson_weight *= lambda_T / n\n        if poisson_weight  weight_tol:\n            break\n        \n        sigma_n = np.sqrt(sigma**2 + n * sigma_J**2 / T)\n        S_n = S0 * (s_J**n)\n        \n        component_price = merton_bs_component(S_n, K, r, q, T, sigma_n, b)\n        total_price += poisson_weight * component_price\n        \n    return total_price\n\ndef objective_function(lambda_val, S0, r, q, T, sigma, mu_J, sigma_J, strikes, market_prices):\n    \"\"\"\n    Calculates the sum of squared errors (SSE) between model prices and market prices.\n    This is the function to be minimized.\n    \"\"\"\n    sse = 0.0\n    for i in range(len(strikes)):\n        model_price = merton_price(lambda_val, S0, strikes[i], r, q, T, sigma, mu_J, sigma_J)\n        sse += (model_price - market_prices[i])**2\n    return sse\n\ndef golden_section_search(f, a, b, tol=1e-6, max_iter=200):\n    \"\"\"\n    Performs Golden-Section Search to find the minimum of a univariate function 'f'\n    on the interval [a, b].\n    \"\"\"\n    inv_phi = 1 / GR\n    \n    # Initialize interior points\n    c = b - inv_phi * (b - a)\n    d = a + inv_phi * (b - a)\n    \n    fc = f(c)\n    fd = f(d)\n    \n    for _ in range(max_iter):\n        if abs(b - a)  tol:\n            break\n            \n        if fc  fd:\n            b = d\n            d = c\n            fd = fc\n            c = b - inv_phi * (b - a)\n            fc = f(c)\n        else:\n            a = c\n            c = d\n            fc = fd\n            d = a + inv_phi * (b - a)\n            fd = f(d)\n            \n    return (a + b) / 2\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite, calibrate lambda for each case, and print results.\n    \"\"\"\n    test_cases = [\n        # Case A: Happy path\n        {'S0': 100.0, 'r': 0.02, 'q': 0.0, 'T': 0.75, 'sigma': 0.20,\n         'mu_J': -0.10, 'sigma_J': 0.25, 'strikes': [105.0, 110.0, 120.0],\n         'lambda_true': 0.60},\n        # Case B: Boundary case, no jumps\n        {'S0': 100.0, 'r': 0.01, 'q': 0.0, 'T': 1.00, 'sigma': 0.15,\n         'mu_J': -0.20, 'sigma_J': 0.30, 'strikes': [102.0, 110.0, 125.0],\n         'lambda_true': 0.00},\n        # Case C: Higher jump activity\n        {'S0': 100.0, 'r': 0.03, 'q': 0.0, 'T': 2.00, 'sigma': 0.18,\n         'mu_J': 0.05, 'sigma_J': 0.20, 'strikes': [105.0, 115.0, 130.0, 150.0],\n         'lambda_true': 1.20}\n    ]\n    \n    calibrated_lambdas = []\n    \n    for case in test_cases:\n        # 1. Generate synthetic market prices using the true lambda\n        market_prices = [\n            merton_price(case['lambda_true'], case['S0'], K, case['r'], case['q'], case['T'],\n                         case['sigma'], case['mu_J'], case['sigma_J'])\n            for K in case['strikes']\n        ]\n\n        # 2. Define objective function for this case, capturing all parameters except lambda\n        obj_func = lambda l: objective_function(\n            l, case['S0'], case['r'], case['q'], case['T'], case['sigma'],\n            case['mu_J'], case['sigma_J'], case['strikes'], market_prices\n        )\n\n        # 3. Run Golden-Section Search to find the calibrated lambda\n        lambda_hat = golden_section_search(obj_func, a=0.0, b=3.0, tol=1e-6, max_iter=200)\n        calibrated_lambdas.append(lambda_hat)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{l:.6f}' for l in calibrated_lambdas])}]\")\n\nsolve()\n```", "id": "2398577"}]}