{"hands_on_practices": [{"introduction": "理论上，高阶数值方法能提供更精确的路径近似，但这并不意味着它在所有方面都更优越。本练习将揭示一个与直觉相悖的现象：对于某些随机微分方程，Milstein 方法对时间步长的稳定性要求可能比阶数更低的 Euler–Maruyama 方法更为苛刻。通过这个实践，您将亲手分析并验证这种“稳定性悖论”，从而理解在选择数值方案时，收敛阶与稳定性之间需要权衡。[@problem_id:2443132]", "problem": "您的任务是构建并分析一个标量随机微分方程，在该方程中，对于时间步长的选择，米尔斯坦格式的数值稳定性比欧拉-丸山格式更敏感，也即要求更严格。考虑由下式给出的具有乘性噪声的标量随机微分方程：\n$$\n\\mathrm{d}X_t = a\\,X_t\\,\\mathrm{d}t + b\\,X_t\\,\\mathrm{d}W_t,\n$$\n其中 $a \\in \\mathbb{R}$ 和 $b \\in \\mathbb{R}$ 是常数，$X_0 \\in \\mathbb{R}$ 是给定的具有有限二阶矩的初始值，$W_t$ 是标准维纳过程。对于此任务，您必须使用具体的参数值 $a=-2$ 和 $b=1$。该连续时间系统的零解是一个平衡点，离散时间近似的均方稳定性指的是二阶矩 $\\,\\mathbb{E}[X_n^2]\\,$ 是否随着步长指数 $n$ 的增加而呈几何级数递减。\n\n您的程序必须对每个给定的时间步长 $\\,\\Delta t\\,$，确定以下两种离散化格式应用于上述方程时，是否在单步均方放大因子严格小于 $\\,1\\,$ 的意义下是均方稳定的：\n- 欧拉-丸山格式。\n- 米尔斯坦格式。\n\n时间步长的测试集为\n$$\n\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\} = \\{\\,0.1,\\,0.7,\\,1.0\\,\\}.\n$$\n对于此集合中的每个 $\\,\\Delta t\\,$，评估两个布尔值：欧拉-丸山格式在该 $\\,\\Delta t\\,$ 下的均方稳定性，以及米尔斯坦格式在该 $\\,\\Delta t\\,$ 下的均方稳定性。当且仅当一个格式的单步均方放大因子严格小于 $\\,1\\,$ 时，声明该格式为“稳定”，否则为“不稳定”。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\text{EM}(\\Delta t_1),\\ \\text{Mil}(\\Delta t_1),\\ \\text{EM}(\\Delta t_2),\\ \\text{Mil}(\\Delta t_2),\\ \\text{EM}(\\Delta t_3),\\ \\text{Mil}(\\Delta t_3)],\n$$\n其中 $\\,\\text{EM}(\\Delta t)\\,$ 和 $\\,\\text{Mil}(\\Delta t)\\,$ 分别是表示欧拉-丸山格式和米尔斯坦格式在时间步长 $\\,\\Delta t\\,$ 下均方稳定性的布尔值。要求的输出是一个包含六个布尔值的列表，格式化为单行，不含任何额外文本或字符。", "solution": "所述问题是有效的。它具有科学依据，是适定的、客观的。它使用既定定义和具体示例，对随机微分方程常用离散化格式的数值稳定性进行了标准探究。所有必要的数据和条件都已提供，没有矛盾或歧义。我们将继续进行推导和求解。\n\n该问题要求分析两种数值格式对于标量随机微分方程（SDE）的均方稳定性\n$$\n\\mathrm{d}X_t = a X_t \\mathrm{d}t + b X_t \\mathrm{d}W_t,\n$$\n参数为 $a = -2$ 和 $b = 1$。$W_t$ 是标准维纳过程。在离散时间 $t_n = n \\Delta t$ 上对 $X(t_n)$ 的数值近似 $X_n$ 被认为是均方稳定的，如果其单步均方放大因子 $R$ 严格小于1。放大因子定义为 $R = \\mathbb{E}[X_{n+1}^2 | \\mathcal{F}_{t_n}] / X_n^2$，其中 $\\mathbb{E}[ \\cdot | \\mathcal{F}_{t_n}]$ 表示在时间 $t_n$ 可用信息下的条件期望。由于 $X_n$ 在第 $n$ 步是已知的，这可以简化为 $R = \\mathbb{E}[(X_{n+1}/X_n)^2]$。稳定性的条件是 $R  1$。\n\n我们将分别分析欧拉-丸山格式和米尔斯坦格式。在这些推导中，我们使用维纳增量 $\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 的矩，它是一个均值为零、方差为 $\\Delta t$ 的正态分布随机变量。具体来说，$\\mathbb{E}[\\Delta W_n] = 0$ 且 $\\mathbb{E}[(\\Delta W_n)^2] = \\Delta t$。对于米尔斯坦格式，我们还需要更高阶的矩：$\\mathbb{E}[(\\Delta W_n)^3] = 0$ 和 $\\mathbb{E}[(\\Delta W_n)^4] = 3(\\Delta t)^2$。\n\n**1. 欧拉-丸山 (EM) 格式**\n\n给定SDE的欧拉-丸山格式为\n$$\nX_{n+1} = X_n + a X_n \\Delta t + b X_n \\Delta W_n = X_n (1 + a \\Delta t + b \\Delta W_n).\n$$\n单步均方放大因子 $R_{EM}$ 为\n$$\nR_{EM} = \\mathbb{E}\\left[ \\left(\\frac{X_{n+1}}{X_n}\\right)^2 \\right] = \\mathbb{E}[ (1 + a \\Delta t + b \\Delta W_n)^2 ].\n$$\n展开平方项并取期望，得到：\n$$\nR_{EM} = \\mathbb{E}[ 1 + (a \\Delta t)^2 + b^2 (\\Delta W_n)^2 + 2a \\Delta t + 2b \\Delta W_n + 2ab \\Delta t \\Delta W_n ]\n$$\n$$\nR_{EM} = 1 + (a \\Delta t)^2 + b^2 \\mathbb{E}[(\\Delta W_n)^2] + 2a \\Delta t + 2b \\mathbb{E}[\\Delta W_n] + 2ab \\Delta t \\mathbb{E}[\\Delta W_n].\n$$\n代入 $\\Delta W_n$ 的矩：\n$$\nR_{EM} = 1 + a^2 (\\Delta t)^2 + b^2 \\Delta t + 2a \\Delta t = (1 + a \\Delta t)^2 + b^2 \\Delta t.\n$$\n为保证均方稳定性，我们需要 $R_{EM}  1$。当 $a = -2$ 和 $b = 1$ 时：\n$$\n(1 - 2 \\Delta t)^2 + (1)^2 \\Delta t  1\n$$\n$$\n1 - 4 \\Delta t + 4(\\Delta t)^2 + \\Delta t  1\n$$\n$$\n4(\\Delta t)^2 - 3 \\Delta t  0.\n$$\n由于 $\\Delta t > 0$，我们可以两边同除以 $\\Delta t$ 得到稳定性条件：\n$$\n4 \\Delta t - 3  0 \\implies \\Delta t  \\frac{3}{4} = 0.75.\n$$\n\n**2. 米尔斯坦 (Milstein) 格式**\n\n通用的米尔斯坦格式是 $X_{n+1} = X_n + f(X_n)\\Delta t + g(X_n)\\Delta W_n + \\frac{1}{2}g(X_n)g'(X_n)((\\Delta W_n)^2 - \\Delta t)$。对于我们的SDE，$f(x) = ax$ 且 $g(x) = bx$，所以 $g'(x) = b$。该格式变为：\n$$\nX_{n+1} = X_n + a X_n \\Delta t + b X_n \\Delta W_n + \\frac{1}{2}(b X_n)(b)((\\Delta W_n)^2 - \\Delta t)\n$$\n$$\nX_{n+1} = X_n \\left( 1 + a \\Delta t - \\frac{1}{2}b^2 \\Delta t + b \\Delta W_n + \\frac{1}{2}b^2 (\\Delta W_n)^2 \\right).\n$$\n放大因子 $R_{Mil}$ 是括号内项平方的期望。令 $C = 1 + a \\Delta t - \\frac{1}{2}b^2 \\Delta t$。\n$$\nR_{Mil} = \\mathbb{E}\\left[ \\left( C + b \\Delta W_n + \\frac{1}{2}b^2 (\\Delta W_n)^2 \\right)^2 \\right]\n$$\n$$\nR_{Mil} = \\mathbb{E}\\left[ C^2 + b^2(\\Delta W_n)^2 + \\frac{1}{4}b^4(\\Delta W_n)^4 + 2C b \\Delta W_n + C b^2 (\\Delta W_n)^2 + b^3 (\\Delta W_n)^3 \\right].\n$$\n使用 $\\Delta W_n$ 的矩逐项取期望：\n$$\nR_{Mil} = C^2 + b^2\\Delta t + \\frac{1}{4}b^4(3(\\Delta t)^2) + 2C b(0) + C b^2 \\Delta t + b^3(0)\n$$\n$$\nR_{Mil} = C^2 + C b^2 \\Delta t + b^2 \\Delta t + \\frac{3}{4} b^4 (\\Delta t)^2.\n$$\n将 $C = 1 + a \\Delta t - \\frac{1}{2}b^2 \\Delta t$ 代回表达式：\n$$\nR_{Mil} = \\left(1 + a \\Delta t - \\frac{1}{2}b^2 \\Delta t\\right)^2 + \\left(1 + a \\Delta t - \\frac{1}{2}b^2 \\Delta t\\right)b^2 \\Delta t + b^2 \\Delta t + \\frac{3}{4}b^4 (\\Delta t)^2\n$$\n$$\nR_{Mil} = \\left((1+a\\Delta t) - \\frac{1}{2}b^2\\Delta t\\right) \\left((1+a\\Delta t) + \\frac{1}{2}b^2\\Delta t\\right) + b^2\\Delta t + \\frac{3}{4}b^4 (\\Delta t)^2\n$$\n$$\nR_{Mil} = (1+a\\Delta t)^2 - \\frac{1}{4}b^4(\\Delta t)^2 + b^2\\Delta t + \\frac{3}{4}b^4(\\Delta t)^2 = (1+a\\Delta t)^2 + b^2\\Delta t + \\frac{1}{2}b^4(\\Delta t)^2.\n$$\n为保证均方稳定性，我们需要 $R_{Mil}  1$。当 $a = -2$ 和 $b = 1$ 时：\n$$\n(1 - 2 \\Delta t)^2 + \\Delta t + \\frac{1}{2}(1)^4 (\\Delta t)^2  1\n$$\n$$\n1 - 4 \\Delta t + 4(\\Delta t)^2 + \\Delta t + \\frac{1}{2}(\\Delta t)^2  1\n$$\n$$\n\\frac{9}{2}(\\Delta t)^2 - 3 \\Delta t  0.\n$$\n两边同除以 $\\Delta t > 0$：\n$$\n\\frac{9}{2} \\Delta t - 3  0 \\implies \\Delta t  \\frac{3}{9/2} = \\frac{6}{9} = \\frac{2}{3}.\n$$\n\n**3. 测试用例评估**\n\n我们得到了稳定性区域：\n- 欧拉-丸山格式：$\\Delta t  0.75$\n- 米尔斯坦格式：$\\Delta t  2/3 \\approx 0.667$\n\n现在我们测试给定的时间步长 $\\{\\Delta t_1, \\Delta t_2, \\Delta t_3\\} = \\{0.1, 0.7, 1.0\\}$。如果一个格式的 $\\Delta t$ 在其稳定性区域内，则该格式是稳定的。\n\n- 对于 $\\Delta t_1 = 0.1$：\n  - EM: $0.1  0.75 \\implies \\text{稳定 (True)}$\n  - Milstein: $0.1  2/3 \\implies \\text{稳定 (True)}$\n\n- 对于 $\\Delta t_2 = 0.7$：\n  - EM: $0.7  0.75 \\implies \\text{稳定 (True)}$\n  - Milstein: $0.7 > 2/3 \\implies \\text{不稳定 (False)}$\n\n- 对于 $\\Delta t_3 = 1.0$：\n  - EM: $1.0 > 0.75 \\implies \\text{不稳定 (False)}$\n  - Milstein: $1.0 > 2/3 \\implies \\text{不稳定 (False)}$\n\n最终的布尔值序列为 [True, True, True, False, False, False]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Determines the mean-square stability of the Euler-Maruyama and Milstein schemes\n    for a specific SDE at given timesteps.\n    \"\"\"\n    # Parameters for the SDE: dX = a*X*dt + b*X*dW\n    a = -2.0\n    b = 1.0\n\n    # Test suite of timesteps\n    test_cases = [0.1, 0.7, 1.0]\n\n    results = []\n    \n    # The mean-square stability condition for a scheme is that its one-step\n    # amplification factor R must be strictly less than 1.\n\n    for dt in test_cases:\n        # Euler-Maruyama stability analysis:\n        # The amplification factor is R_EM = (1 + a*dt)^2 + b^2*dt.\n        # The stability condition R_EM  1 simplifies to:\n        # (1 - 2*dt)^2 + dt  1\n        # 1 - 4*dt + 4*dt^2 + dt  1\n        # 4*dt^2 - 3*dt  0\n        # dt * (4*dt - 3)  0\n        # Since dt > 0, the condition is 4*dt - 3  0.\n        em_stable = (4.0 * dt - 3.0)  0\n        results.append(em_stable)\n\n        # Milstein stability analysis:\n        # The amplification factor is R_Mil = (1 + a*dt)^2 + b^2*dt + 0.5*b^4*dt^2.\n        # The stability condition R_Mil  1 simplifies to:\n        # (1 - 2*dt)^2 + dt + 0.5*dt^2  1\n        # 1 - 4*dt + 4*dt^2 + dt + 0.5*dt^2  1\n        # 4.5*dt^2 - 3*dt  0\n        # dt * (4.5*dt - 3)  0\n        # Since dt > 0, the condition is 4.5*dt - 3  0.\n        mil_stable = (4.5 * dt - 3.0)  0\n        results.append(mil_stable)\n\n    # Final print statement in the exact required format.\n    # The str() of a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443132"}, {"introduction": "Milstein 方法的核心优势在于其 $1.0$ 阶的强收敛性，这对于需要精确模拟样本路径的应用至关重要。然而，许多金融和科学应用的目标是计算期望值，这是一个衡量弱收敛性的问题。本练习旨在通过一个精确的、非蒙特卡洛的计算实验，让您探究并证实：对于计算期望值这类任务，Milstein 方法相较于 Euler–Maruyama 方法通常没有表现出优势，两者的弱收敛阶均为 $1.0$ 阶。[@problem_id:2443108]", "problem": "您的任务是，在计算经济学和金融学的背景下，从第一性原理出发构建一个数值实验，以评估伊藤(Itô)随机微分方程（SDEs）的离散时间近似的弱收敛性质。考虑一个形式为 $dX_{t} = a(X_{t})\\,dt + b(X_{t})\\,dW_{t}$ 的标量伊藤(Itô)SDE，其定义在固定时间区间 $[0,T]$ 上，初始条件为 $X_{0}=x_{0}$，其中 $W_{t}$ 是一个标准维纳过程。如果对于足够光滑的泛函 $\\varphi$，偏差 $\\left| \\mathbb{E}[\\varphi(X_{T})] - \\mathbb{E}[\\varphi(\\widehat{X}_{T}^{h})] \\right|$ 随着 $h \\to 0$ 的缩放行为如同 $\\mathcal{O}(h^{p})$，那么一个时间步进方法具有弱阶 $p$。这里 $h$ 是时间步长，$\\widehat{X}_{T}^{h}$ 是在时间 $T$ 的数值近似。从伊藤(Itô)微积分基础和伊藤-泰勒(Itô–Taylor)展开出发，为标量SDE推导欧拉-丸山(Euler–Maruyama)法和米尔斯坦(Milstein)法的可实现更新规则，然后使用这些更新规则计算下述特定模型和泛函的离散时间近似的精确期望，过程中不使用蒙特卡洛采样。您的推导必须仅依赖于维纳增量的独立性和高斯矩性质，以及条件期望的塔性质。\n\n您必须编写一个完整、可运行的程序，该程序：\n- 为下面的测试问题实现欧拉-丸山(Euler–Maruyama)和米尔斯坦(Milstein)格式，使用条件期望和高斯随机变量的已知矩，在固定的终端时间 $T$ 推导出 $\\mathbb{E}[\\varphi(\\widehat{X}_{T}^{h})]$ 的闭式表达式，无需进行采样。\n- 对每种格式，为一组递减的步长 $h$ 计算绝对弱误差 $\\left| \\mathbb{E}[\\varphi(X_{T})] - \\mathbb{E}[\\varphi(\\widehat{X}_{T}^{h})] \\right|$。\n- 通过对所提供步长范围内的 $\\log(\\text{error})$ 与 $\\log(h)$ 进行最小二乘拟合，来估计观测到的弱阶 $p$。\n- 通过直接比较它们对于恒等泛函的绝对弱误差，量化米尔斯坦(Milstein)格式在简单期望计算方面是否比欧拉-丸山(Euler–Maruyama)格式更有优势。\n\n仅使用以下模型、参数和泛函作为测试套件。在所有项目中，时间区间为 $T = 1.0$。\n\n测试套件：\n- 测试 $1$ (几何布朗运动)：$dX_{t} = \\mu X_{t}\\,dt + \\sigma X_{t}\\,dW_{t}$，其中 $x_{0} = 1.0$，$\\mu = 0.05$，$\\sigma = 0.2$，$\\varphi(x)=x$。\n- 测试 $2$ (几何布朗运动)：与测试 $1$ 相同的模型和参数，但 $\\varphi(x)=x^{2}$。\n- 测试 $3$ (奥恩斯坦-乌伦贝克)：$dX_{t} = \\kappa(\\theta - X_{t})\\,dt + \\sigma\\,dW_{t}$，其中 $x_{0} = 1.0$，$\\kappa = 1.2$，$\\theta = 0.8$，$\\sigma = 0.3$，$\\varphi(x)=x$。\n\n对于每个测试，使用从SDE的闭式解中获得的精确模型期望 $\\mathbb{E}[\\varphi(X_{T})]$ 来定义偏差。对于几何布朗运动，您必须使用一阶矩和二阶矩的精确闭式表达式。对于奥恩斯坦-乌伦贝克模型，您必须使用均值的精确闭式表达式。程序中任何地方都不要使用任何蒙特卡洛近似。\n\n步长：\n- 使用 $N \\in \\{4, 8, 16, 32\\}$ 个均匀步长，使得 $h = T/N$。\n\n输出：\n- 对于三个测试中的每一个，使用四个 $h$ 值下 $\\log(\\text{error})$ 对 $\\log(h)$ 的最小二乘斜率，计算欧拉-丸山法和米尔斯坦法的观测弱阶 $p$。\n- 同时计算两个布尔值，分别表示在绝对容差 $10^{-12}$ 内，测试1中欧拉-丸山法和米尔斯坦法的绝对弱误差在所有 $h$ 上是否一致，以及测试3中它们是否一致。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[$observed\\_order\\_Euler\\_Test1, observed\\_order\\_Milstein\\_Test1, observed\\_order\\_Euler\\_Test2, observed\\_order\\_Milstein\\_Test2, observed\\_order\\_Euler\\_Test3, observed\\_order\\_Milstein\\_Test3, equal\\_errors\\_Test1, equal\\_errors\\_Test3$]$。\n- 前六个条目必须是浮点数，后两个条目必须是布尔值。", "solution": "所提出的问题陈述是计算金融学中一个适定且科学上合理的练习。它要求对评估伊藤(Itô)随机微分方程(SDE)数值格式弱收敛性的方法进行严谨的、从第一性原理出发的推导和实现。所有必需的参数、模型和解析基准均已提供，问题没有歧义、矛盾或事实错误。因此，该问题被认为是有效的，并将提供一个完整的解决方案。\n\n所考虑的标量伊藤(Itô)SDE的一般形式为：\n$$\ndX_t = a(X_t) dt + b(X_t) dW_t\n$$\n初始条件为 $X_0 = x_0$，时间区间为 $[0, T]$。我们的任务是分析弱误差，定义为 $\\left| \\mathbb{E}[\\varphi(X_T)] - \\mathbb{E}[\\varphi(\\widehat{X}_T^h)] \\right|$，其中 $\\widehat{X}_T^h$ 是使用步长 $h$ 在时间 $T$ 的数值近似。本分析将通过推导数值解的期望值的精确表达式来进行，不使用蒙特卡洛模拟。\n\n首先，我们建立数值格式。时间区间 $[0, T]$ 被离散化为 $N$ 个步长为 $h = T/N$ 的步骤，网格点为 $t_i = ih$。维纳过程在 $[t_i, t_{i+1}]$ 上的增量为 $\\Delta W_i = W_{t_{i+1}} - W_{t_i} \\sim \\mathcal{N}(0, h)$。我们可以写成 $\\Delta W_i = \\sqrt{h} Z_i$，其中 $Z_i \\sim \\mathcal{N}(0, 1)$ 是独立同分布的标准正态随机变量。\n\n欧拉-丸山(Euler-Maruyama, EM)格式源自伊藤-泰勒(Itô-Taylor)展开的一阶截断：\n$$\n\\widehat{X}_{i+1}^{\\text{EM}} = \\widehat{X}_i + a(\\widehat{X}_i)h + b(\\widehat{X}_i)\\sqrt{h}Z_i\n$$\n\n米尔斯坦(Milstein)格式包含一个额外的伊藤-泰勒(Itô-Taylor)项，该项涉及一个二重维纳积分。其更新规则是：\n$$\n\\widehat{X}_{i+1}^{\\text{Mil}} = \\widehat{X}_i + a(\\widehat{X}_i)h + b(\\widehat{X}_i)\\sqrt{h}Z_i + \\frac{1}{2}b(\\widehat{X}_i)b'(\\widehat{X}_i)h(Z_i^2 - 1)\n$$\n其中 $b'(x) = \\frac{db}{dx}$。\n\n为了递归地计算期望 $\\mathbb{E}[\\varphi(\\widehat{X}_N^h)]$，我们采用条件期望的塔性质。令 $m_i[\\psi] = \\mathbb{E}[\\psi(\\widehat{X}_i)]$，其中 $\\psi$ 是某个泛函。那么，\n$$\nm_{i+1}[\\psi] = \\mathbb{E}[\\psi(\\widehat{X}_{i+1})] = \\mathbb{E}\\left[\\mathbb{E}[\\psi(\\widehat{X}_{i+1}) | \\mathcal{F}_{t_i}]\\right]\n$$\n其中 $\\mathcal{F}_{t_i}$ 是在时间 $t_i$ 的信息流(filtration)。由于 $\\widehat{X}_i$ 是 $\\mathcal{F}_{t_i}$-可测的，内层期望是关于随机变量 $Z_i$ 取的。这个过程允许我们为 $\\widehat{X}_i$ 的矩推导出递推关系。我们使用标准正态变量的矩：$\\mathbb{E}[Z_i] = 0$，$\\mathbb{E}[Z_i^2] = 1$, $\\mathbb{E}[Z_i^3] = 0$, 以及 $\\mathbb{E}[Z_i^4] = 3$。\n\n测试1：几何布朗运动 (GBM)，$\\varphi(x) = x$。\nSDE为 $dX_t = \\mu X_t dt + \\sigma X_t dW_t$，其中 $a(x) = \\mu x$ 且 $b(x) = \\sigma x$。因此，$b'(x) = \\sigma$。\n均值的精确解为 $\\mathbb{E}[X_T] = x_0 e^{\\mu T}$。\n\n对于EM格式，更新规则是 $\\widehat{X}_{i+1} = \\widehat{X}_i(1 + \\mu h + \\sigma \\sqrt{h}Z_i)$。令 $m_i = \\mathbb{E}[\\widehat{X}_i]$。\n$$\nm_{i+1} = \\mathbb{E}\\left[\\mathbb{E}\\left[\\widehat{X}_i(1 + \\mu h + \\sigma \\sqrt{h}Z_i) | \\mathcal{F}_{t_i}\\right]\\right] = \\mathbb{E}\\left[\\widehat{X}_i(1 + \\mu h)\\right] = (1 + \\mu h)m_i\n$$\n对于Milstein格式，更新规则是 $\\widehat{X}_{i+1} = \\widehat{X}_i + \\mu \\widehat{X}_i h + \\sigma \\widehat{X}_i \\sqrt{h}Z_i + \\frac{1}{2}(\\sigma \\widehat{X}_i)\\sigma h(Z_i^2 - 1)$。\n$$\nm_{i+1} = \\mathbb{E}\\left[\\mathbb{E}\\left[\\widehat{X}_i \\left(1 + \\mu h + \\sigma \\sqrt{h}Z_i + \\frac{1}{2}\\sigma^2 h(Z_i^2 - 1)\\right) | \\mathcal{F}_{t_i}\\right]\\right]\n$$\n由于 $\\mathbb{E}[Z_i]=0$ 且 $\\mathbb{E}[Z_i^2-1]=0$，括号内项的条件期望简化为 $1 + \\mu h$。因此，$m_{i+1} = (1 + \\mu h)m_i$，这与EM的递推关系相同。\n对于两种格式，当 $m_0 = x_0$ 时，解为 $\\mathbb{E}[\\widehat{X}_N^h] = x_0(1 + \\mu h)^N$。因此，在这个测试案例中，它们的弱误差是相同的。\n\n测试2：GBM，$\\varphi(x) = x^2$。\n精确二阶矩为 $\\mathbb{E}[X_T^2] = x_0^2 e^{(2\\mu + \\sigma^2)T}$。令 $m_i^{(2)} = \\mathbb{E}[\\widehat{X}_i^2]$。\n\n对于EM格式，我们计算 $\\mathbb{E}[\\widehat{X}_{i+1}^2 | \\mathcal{F}_{t_i}]$：\n$$\n\\mathbb{E}[(\\widehat{X}_i(1 + \\mu h + \\sigma\\sqrt{h}Z_i))^2 | \\mathcal{F}_{t_i}] = \\widehat{X}_i^2 \\mathbb{E}[(1 + \\mu h)^2 + 2(1 + \\mu h)\\sigma\\sqrt{h}Z_i + \\sigma^2 h Z_i^2] = \\widehat{X}_i^2 ( (1+\\mu h)^2 + \\sigma^2 h )\n$$\n递推关系为 $m_{i+1}^{(2)} = (1 + 2\\mu h + \\mu^2 h^2 + \\sigma^2 h)m_i^{(2)}$。最终值为 $\\mathbb{E}[(\\widehat{X}_N^h)^2] = x_0^2(1 + (2\\mu + \\sigma^2)h + \\mu^2 h^2)^N$。\n\n对于Milstein格式，$\\widehat{X}_{i+1} = \\widehat{X}_i( (1+\\mu h - \\frac{1}{2}\\sigma^2h) + \\sigma\\sqrt{h}Z_i + \\frac{1}{2}\\sigma^2 h Z_i^2)$。令 $\\widehat{X}_{i+1} = \\widehat{X}_i(K_0 + K_1 Z_i + K_2 Z_i^2)$。\n$$\n\\mathbb{E}[\\widehat{X}_{i+1}^2 | \\mathcal{F}_{t_i}] = \\widehat{X}_i^2 \\mathbb{E}[(K_0 + K_1 Z_i + K_2 Z_i^2)^2] = \\widehat{X}_i^2 (K_0^2 + K_1^2 \\mathbb{E}[Z_i^2] + K_2^2 \\mathbb{E}[Z_i^4] + 2K_0K_2\\mathbb{E}[Z_i^2])\n$$\n使用 $\\mathbb{E}[Z_i^2]=1$ 和 $\\mathbb{E}[Z_i^4]=3$，并代入 $K_0=1+\\mu h - \\frac{1}{2}\\sigma^2h$，$K_1=\\sigma\\sqrt{h}$，$K_2=\\frac{1}{2}\\sigma^2h$：\n$$\nm_{i+1}^{(2)} = m_i^{(2)} \\left( (1+\\mu h - \\tfrac{1}{2}\\sigma^2h)^2 + \\sigma^2h + 3(\\tfrac{1}{2}\\sigma^2h)^2 + 2(1+\\mu h - \\tfrac{1}{2}\\sigma^2h)(\\tfrac{1}{2}\\sigma^2h) \\right)\n$$\n展开并合并项得到系数：\n$1 + (2\\mu + \\sigma^2)h + (\\mu^2 + \\frac{1}{2}\\sigma^4)h^2$。\n所以，$\\mathbb{E}[(\\widehat{X}_N^h)^2] = x_0^2(1 + (2\\mu + \\sigma^2)h + (\\mu^2 + \\frac{1}{2}\\sigma^4)h^2)^N$。由于 $\\mathcal{O}(h^2)$ 项的存在，EM和Milstein的误差将会有所不同。\n\n测试3：奥恩斯坦-乌伦贝克 (OU)，$\\varphi(x) = x$。\nSDE为 $dX_t = \\kappa(\\theta - X_t) dt + \\sigma dW_t$，其中 $a(x) = \\kappa(\\theta - x)$ 且 $b(x) = \\sigma$。\n由于 $b(x)$ 是一个常数，$b'(x) = 0$。Milstein修正项 $\\frac{1}{2}b(x)b'(x)h(Z_i^2-1)$ 为零。因此，对于任何具有加性噪声的SDE，Milstein格式与Euler-Maruyama格式是相同的。\n精确均值为 $\\mathbb{E}[X_T] = x_0 e^{-\\kappa T} + \\theta(1-e^{-\\kappa T})$。\n\n共同的更新规则是 $\\widehat{X}_{i+1} = \\widehat{X}_i + \\kappa(\\theta - \\widehat{X}_i)h + \\sigma\\sqrt{h}Z_i$。令 $m_i = \\mathbb{E}[\\widehat{X}_i]$。\n$$\nm_{i+1} = \\mathbb{E}[\\widehat{X}_i(1-\\kappa h) + \\kappa\\theta h + \\sigma\\sqrt{h}Z_i] = (1-\\kappa h)m_i + \\kappa\\theta h\n$$\n这是一个线性递推关系 $m_{i+1} = A m_i + B$，其中 $A=1-\\kappa h$ 且 $B=\\kappa\\theta h$。从 $m_0=x_0$ 开始，其解为 $m_N = A^N m_0 + B \\frac{1-A^N}{1-A}$。代入 $A$ 和 $B$ 得到：\n$$\n\\mathbb{E}[\\widehat{X}_N^h] = x_0(1-\\kappa h)^N + \\theta(1-(1-\\kappa h)^N)\n$$\n由于EM和Milstein是相同的格式，它们的弱误差是相同的。\n\n弱阶估计。\n弱阶 $p$ 是从关系式 $\\log(\\text{error}) \\approx \\log(C) + p \\log(h)$ 中估计出来的。我们对步长集合 $h \\in \\{T/4, T/8, T/16, T/32\\}$，对 $\\log(\\text{error})$ 关于 $\\log(h)$ 进行线性最小二乘回归。所得直线的斜率即为估计的阶数 $p$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes weak convergence orders for Euler-Maruyama and Milstein schemes.\n    \"\"\"\n    # Global parameters\n    T = 1.0\n    Ns = np.array([4, 8, 16, 32])\n    hs = T / Ns\n    log_hs = np.log(hs)\n    abs_tol = 1e-12\n\n    # --- Test Case 1: Geometric Brownian Motion, phi(x)=x ---\n    x0_gbm = 1.0\n    mu = 0.05\n    sigma_gbm = 0.2\n\n    # Exact solution\n    exact_t1 = x0_gbm * np.exp(mu * T)\n\n    errors_em_t1 = []\n    errors_mil_t1 = []\n    \n    for h, N in zip(hs, Ns):\n        # For E[X_N], EM and Milstein recurrences are identical for GBM\n        num_val = x0_gbm * (1 + mu * h)**N\n        error = abs(exact_t1 - num_val)\n        errors_em_t1.append(error)\n        errors_mil_t1.append(error)\n\n    # Convert to numpy arrays for vectorized operations\n    errors_em_t1 = np.array(errors_em_t1)\n    errors_mil_t1 = np.array(errors_mil_t1)\n\n    # Estimate weak order p using polyfit on log-log data\n    # p is the slope (first coefficient)\n    p_em_t1 = np.polyfit(log_hs, np.log(errors_em_t1), 1)[0]\n    p_mil_t1 = np.polyfit(log_hs, np.log(errors_mil_t1), 1)[0]\n    \n    # Check if errors are identical within tolerance\n    equal_errors_t1 = np.allclose(errors_em_t1, errors_mil_t1, rtol=0, atol=abs_tol)\n\n    # --- Test Case 2: Geometric Brownian Motion, phi(x)=x^2 ---\n    # Exact solution for the second moment\n    exact_t2 = x0_gbm**2 * np.exp((2 * mu + sigma_gbm**2) * T)\n\n    errors_em_t2 = []\n    errors_mil_t2 = []\n\n    for h, N in zip(hs, Ns):\n        # Euler-Maruyama E[X_N^2]\n        term_em = 1 + (2 * mu + sigma_gbm**2) * h + mu**2 * h**2\n        num_val_em = x0_gbm**2 * term_em**N\n        errors_em_t2.append(abs(exact_t2 - num_val_em))\n        \n        # Milstein E[X_N^2]\n        term_mil = 1 + (2 * mu + sigma_gbm**2) * h + (mu**2 + 0.5 * sigma_gbm**4) * h**2\n        num_val_mil = x0_gbm**2 * term_mil**N\n        errors_mil_t2.append(abs(exact_t2 - num_val_mil))\n\n    p_em_t2 = np.polyfit(log_hs, np.log(errors_em_t2), 1)[0]\n    p_mil_t2 = np.polyfit(log_hs, np.log(errors_mil_t2), 1)[0]\n\n    # --- Test Case 3: Ornstein-Uhlenbeck, phi(x)=x ---\n    x0_ou = 1.0\n    kappa = 1.2\n    theta = 0.8\n    sigma_ou = 0.3\n\n    # Exact solution\n    exact_t3 = x0_ou * np.exp(-kappa * T) + theta * (1 - np.exp(-kappa * T))\n\n    errors_em_t3 = []\n    errors_mil_t3 = []\n\n    for h, N in zip(hs, Ns):\n        # For OU (additive noise), EM and Milstein schemes are identical\n        term = (1 - kappa * h)**N\n        num_val = term * x0_ou + theta * (1 - term)\n        error = abs(exact_t3 - num_val)\n        errors_em_t3.append(error)\n        errors_mil_t3.append(error)\n\n    errors_em_t3 = np.array(errors_em_t3)\n    errors_mil_t3 = np.array(errors_mil_t3)\n\n    p_em_t3 = np.polyfit(log_hs, np.log(errors_em_t3), 1)[0]\n    p_mil_t3 = np.polyfit(log_hs, np.log(errors_mil_t3), 1)[0]\n    \n    equal_errors_t3 = np.allclose(errors_em_t3, errors_mil_t3, rtol=0, atol=abs_tol)\n\n    # --- Final Output ---\n    results = [\n        p_em_t1, p_mil_t1,\n        p_em_t2, p_mil_t2,\n        p_em_t3, p_mil_t3,\n        equal_errors_t1, equal_errors_t3,\n    ]\n\n    # Format into the required string output\n    # bools will be converted to 'True'/'False'\n    # floats will be converted to their string representation\n    output_str = f\"[{','.join(map(str, results))}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2443108"}, {"introduction": "在应用随机模型时，一个常见且关键的细节是随机积分的解释：是 Itô 积分还是 Stratonovich 积分？像 Milstein 这样的标准数值方法是为 Itô 方程设计的。本练习将引导您完成一个重要的实践任务：通过一个具体的例子，展示如何将一个 Stratonovich SDE 正确转换为等价的 Itô SDE 再进行数值求解，并与错误地直接应用 Itô 求解器所产生的系统性偏差进行对比。[@problem_id:3002512]", "problem": "考虑一个实值过程 $X_t$ 的标量随机微分方程，其初值为 $X_0 = x_0$，并包含一个布朗运动 $W_t$。随机积分通常有两种诠释：Itô 诠释和 Stratonovich 诠释。两种诠释都定义了有效的随机模型，但它们遵循不同的链式法则，并且在转换后会导致不同的漂移项。您将研究在使用适用于 Itô 方程的一阶强收敛数值方法（Milstein 方法）时，将同一个随机模型分别按 Stratonovich 和 Itô 诠释，会如何产生系统性差异的数值轨迹。\n\n您的任务如下，请从基本定义和经过充分检验的事实出发，按顺序完成：\n\n1) 利用 Itô 积分和 Stratonovich 积分的基本定义，以及它们遵循不同变量替换（链式）法则这一事实，推导出将 Stratonovich 随机微分方程转换为具有相同样本路径定律的 Itô 随机微分方程所需的漂移修正项。您的推导应基于 Itô 公式和 Stratonovich 积分的经典链式法则，并得出以 Stratonovich 漂移和扩散系数表示 Itô 漂移的精确表达式。\n\n2) 从一阶强收敛的 Itô-Taylor 展开式出发，推导出用于求解带有漂移项 $a(x)$ 和扩散项 $b(x)$ 的标量 Itô 随机微分方程的 Milstein 方法的显式单步更新规则。您的结果应包含对导数 $b'(x)$ 和布朗增量 $\\Delta W$ 的依赖关系。\n\n3) 利用第 1 部分的结果，确定如何通过 Itô 积分器模拟 Stratonovich 模型：即，指明在 Milstein 步骤中必须使用哪个漂移项，才能与 Stratonovich 诠释保持一致。\n\n4) 实现一个程序，该程序为下述每个测试用例，在相同的时间网格上并由相同的布朗增量驱动，构建两条数值轨迹：\n   - 轨迹 S：将模型诠释为 Stratonovich 随机微分方程。将其转换为等价的 Itô 形式，并使用第 2 部分的 Milstein 方法进行积分。\n   - 轨迹 I_mis：将相同的符号系数视为定义了一个 Itô 随机微分方程，不执行任何转换，并直接使用第 2 部分的 Milstein 方法进行积分。\n\n对于每个测试用例，返回终值的标量差 $X_S(T) - X_{I\\_mis}(T)$，其中 $X_S(T)$ 是轨迹 S 的终值，$X_{I\\_mis}(T)$ 是轨迹 I_mis 的终值。为确保公平比较，在给定测试用例中，两条轨迹必须使用完全相同的布朗增量。不涉及任何物理单位。\n\n您必须使用以下测试套件。每个测试用例都指定了漂移和扩散的函数形式、时间范围、步数以及用于生成布朗增量的随机种子。所有角度（如有）都必须视为无量纲实数。\n\n- 测试用例 A（乘性噪声；预期终值差异不为零，且不会随着步长的减小而消失）：Stratonovich 漂移 $\\alpha(x) = \\lambda x$，扩散 $b(x) = \\sigma x$，参数为 $x_0 = 1.0$，$\\lambda = 0.25$，$\\sigma = 1.0$，最终时间 $T = 1.0$，步数 $N = 2000$，随机种子 $7$。\n- 测试用例 B（加性噪声；两种诠释一致的边界情况）：Stratonovich 漂移 $\\alpha(x) = \\lambda x$，扩散 $b(x) = \\sigma$（常数），参数为 $x_0 = 1.0$，$\\lambda = 0.25$，$\\sigma = 1.0$，最终时间 $T = 1.0$，步数 $N = 2000$，随机种子 $7$。\n- 测试用例 C（使用更精细网格的乘性噪声；证明差异在网格细化后依然存在）：Stratonovich 漂移 $\\alpha(x) = \\lambda x$，扩散 $b(x) = \\sigma x$，参数为 $x_0 = 1.0$，$\\lambda = 0.25$，$\\sigma = 1.0$，最终时间 $T = 1.0$，步数 $N = 20000$，随机种子 $12345$。\n\n实现细节和约束：\n- 对于每个测试用例，使用指定的种子生成独立同分布的高斯布朗增量 $\\Delta W_n \\sim \\mathcal{N}(0,h)$，其中 $h = T/N$。在为该测试用例积分轨迹 S 和轨迹 I_mis 时，请使用相同的增量。\n- 对于轨迹 S，您必须首先将 Stratonovich 模型转换为等价的 Itô 模型，然后应用第 2 部分的 Milstein 方法。\n- 对于轨迹 I_mis，您必须直接应用 Milstein 方法，将给定的符号系数当作它们定义了一个 Itô 模型来使用，无需转换。\n- 使用双精度浮点运算。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个测试用例的终值差异，表示为一个用方括号括起来的逗号分隔列表，并以标准十进制表示法打印为实数，例如，“[0.12345,0.0,0.23456]”。\n\n唯一可接受的返回类型是指定格式的包含三个实数的单个列表。不应打印任何其他文本。", "solution": "该问题要求进行与随机微分方程（SDE）的 Itô 和 Stratonovich 诠释及其通过 Milstein 方法的数值解法相关的多步推导和实现。\n\n### 第 1 部分：Itô-Stratonovich 转换规则的推导\n\n一个标量 Stratonovich SDE 由下式给出：\n$$dX_t = \\alpha(X_t) dt + b(X_t) \\circ dW_t$$\n其中 $\\alpha(x)$ 是 Stratonovich 漂移，$b(x)$ 是扩散系数，$W_t$ 是标准维纳过程，`$\\circ$` 表示 Stratonovich 积分。我们寻求一个形式如下的等价 Itô SDE：\n$$dX_t = a(X_t) dt + b(X_t) dW_t$$\n其中 $a(x)$ 是 Itô 漂移，关于 $dW_t$ 的积分是 Itô 意义下的。\n\nItô 微分 $b(X_t) dW_t$ 和 Stratonovich 微分 $b(X_t) \\circ dW_t$ 之间的基本关系由下式给出：\n$$b(X_t) \\circ dW_t = b(X_t) dW_t + \\frac{1}{2} d[b(X), W]_t$$\n其中 $[b(X), W]_t$ 是 $b(X_t)$ 和 $W_t$ 的二次协变过程。\n\n为了计算二次协变，我们首先使用 Itô 引理来表示 $db(X_t)$。过程 $X_t$ 本身遵循 Itô SDE $dX_t = a(X_t) dt + b(X_t) dW_t$。将 Itô 引理应用于函数 $b(x)$ 可得：\n$$db(X_t) = b'(X_t) dX_t + \\frac{1}{2} b''(X_t) (dX_t)^2$$\n使用规则 $(dW_t)^2=dt$、$dt \\cdot dW_t = 0$ 和 $(dt)^2=0$ 将其展开：\n$$db(X_t) = b'(X_t) [a(X_t) dt + b(X_t) dW_t] + \\frac{1}{2} b''(X_t) [b(X_t) dW_t]^2$$\n$$db(X_t) = [a(X_t)b'(X_t) + \\frac{1}{2}b(X_t)^2 b''(X_t)] dt + [b(X_t)b'(X_t)] dW_t$$\n二次协变 $d[b(X), W]_t$ 是 $b(X_t)$ 和 $W_t$ 的随机微分中 $dW_t$ 项的系数之积，再乘以 $dt$。$W_t$ 的微分是 $dW_t = 1 \\cdot dW_t$。因此：\n$$d[b(X), W]_t = (b(X_t)b'(X_t)) \\cdot (1) \\cdot dt = b(X_t)b'(X_t) dt$$\n将此代回积分的转换公式：\n$$b(X_t) \\circ dW_t = b(X_t) dW_t + \\frac{1}{2} b(X_t)b'(X_t) dt$$\n现在，我们将此表达式代入原始的 Stratonovich SDE：\n$$dX_t = \\alpha(X_t) dt + \\left(b(X_t) dW_t + \\frac{1}{2} b(X_t)b'(X_t) dt\\right)$$\n对 $dt$ 项进行分组，我们得到：\n$$dX_t = \\left(\\alpha(X_t) + \\frac{1}{2} b(X_t)b'(X_t)\\right) dt + b(X_t) dW_t$$\n通过将其与目标 Itô SDE 形式进行比较，我们确定 Itô 漂移 $a(x)$ 为：\n$$a(x) = \\alpha(x) + \\frac{1}{2} b(x)b'(x)$$\n这就是所需的漂移修正。附加项 $\\frac{1}{2} b(x)b'(x)$ 通常被称为 Itô-Stratonovich 修正项或噪声诱导漂移。\n\n### 第 2 部分：Milstein 方法的推导\n\nMilstein 方法是求解 Itô SDE 的一种数值格式，它源于 Itô-Taylor 展开。考虑以下 Itô SDE：\n$$dX_t = a(X_t) dt + b(X_t) dW_t$$\n其在小时间步长 $h = t_{n+1} - t_n$ 上的积分形式为：\n$$X_{t_{n+1}} = X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_s) ds + \\int_{t_n}^{t_{n+1}} b(X_s) dW_s$$\n为了推导 Milstein 方法，我们在 $X_{t_n}$ 附近展开被积函数 $a(X_s)$ 和 $b(X_s)$。\n我们近似 $a(X_s) \\approx a(X_{t_n})$。\n对于 $b(X_s)$，我们使用一阶 Itô-Taylor 展开：$b(X_s) \\approx b(X_{t_n}) + \\mathcal{L}b(X_{t_n})(s-t_n)$，其中 $\\mathcal{L}$ 是 SDE 的生成元。更直接地，我们可以写成：\n$$b(X_s) \\approx b(X_{t_n}) + b'(X_{t_n})(X_s - X_{t_n})$$\n我们用其最低阶项来近似增量 $X_s - X_{t_n}$：\n$$X_s - X_{t_n} \\approx \\int_{t_n}^s b(X_{t_n}) dW_u = b(X_{t_n})(W_s - W_{t_n})$$\n将这些近似值代回积分方程：\n$$X_{t_{n+1}} \\approx X_{t_n} + \\int_{t_n}^{t_{n+1}} a(X_{t_n}) ds + \\int_{t_n}^{t_{n+1}} \\left[ b(X_{t_n}) + b'(X_{t_n})b(X_{t_n})(W_s - W_{t_n}) \\right] dW_s$$\n逐项计算积分：\n$$ \\int_{t_n}^{t_{n+1}} a(X_{t_n}) ds = a(X_{t_n}) h $$\n$$ \\int_{t_n}^{t_{n+1}} b(X_{t_n}) dW_s = b(X_{t_n}) \\Delta W_n $$\n其中 $\\Delta W_n = W_{t_{n+1}} - W_{t_n}$ 是维纳增量，一个服从 $\\mathcal{N}(0, h)$ 分布的随机变量。\n最后的积分是一个二重 Itô 积分：\n$$ \\int_{t_n}^{t_{n+1}} b(X_{t_n})b'(X_{t_n})(W_s - W_{t_n}) dW_s = b(X_{t_n})b'(X_{t_n}) \\int_{t_n}^{t_{n+1}} (W_s - W_{t_n}) dW_s $$\n这个迭代积分有一个已知的值：\n$$ \\int_{t_n}^{t_{n+1}} (W_s - W_{t_n}) dW_s = \\frac{1}{2} \\left[ (\\Delta W_n)^2 - h \\right] $$\n合并所有项，我们得到 Milstein 方法的单步更新规则，其中 $X_n \\approx X_{t_n}$：\n$$X_{n+1} = X_n + a(X_n)h + b(X_n)\\Delta W_n + \\frac{1}{2} b(X_n)b'(X_n) \\left[ (\\Delta W_n)^2 - h \\right]$$\n该格式的强收敛阶为 1.0。\n\n### 第 3 部分：通过 Itô 积分器模拟 Stratonovich 模型\n\n要使用像 Milstein 方法这样的 Itô 积分器来模拟 Stratonovich SDE，必须首先将 Stratonovich SDE 转换为其数学上等价的 Itô 形式。\n给定 Stratonovich 模型：\n$$dX_t = \\alpha(X_t) dt + b(X_t) \\circ dW_t$$\n从第 1 部分可知，其等价的 Itô 形式为：\n$$dX_t = \\left(\\alpha(X_t) + \\frac{1}{2} b(X_t)b'(X_t)\\right) dt + b(X_t) dW_t$$\n为了模拟这个过程，我们将 Milstein 方法（来自第 2 部分）应用于此 Itô SDE。我们确定 Itô 漂移为 $a(x) = \\alpha(x) + \\frac{1}{2} b(x)b'(x)$，扩散项为 $b(x)$。将这些代入 Milstein 公式，即可得到模拟 Stratonovich SDE 的正确更新规则：\n$$X_{n+1} = X_n + \\left[\\alpha(X_n) + \\frac{1}{2}b(X_n)b'(X_n)\\right]h + b(X_n)\\Delta W_n + \\frac{1}{2} b(X_n)b'(X_n) \\left[ (\\Delta W_n)^2 - h \\right]$$\n\n### 第 4 部分：数值轨迹的说明\n\n问题要求构建两条轨迹：\n1.  **轨迹 S**：此轨迹正确地模拟了 Stratonovich SDE。该数值格式使用推导出的等价 Itô 漂移 $a_S(x) = \\alpha(x) + \\frac{1}{2}b(x)b'(x)$。更新规则是：\n    $$X_{n+1}^S = X_n^S + a_S(X_n^S)h + b(X_n^S)\\Delta W_n + \\frac{1}{2} b(X_n^S)b'(X_n^S) ((\\Delta W_n)^2 - h)$$\n2.  **轨迹 I_mis**：此轨迹错误地将 Stratonovich SDE 的符号系数 $(\\alpha, b)$ 从一开始就当作定义了一个 Itô SDE。因此，该数值格式使用了 Itô 漂移 $a_{I\\_mis}(x) = \\alpha(x)$，而没有使用关键的修正项。更新规则是：\n    $$X_{n+1}^{I\\_mis} = X_n^{I\\_mis} + a_{I\\_mis}(X_n^{I\\_mis})h + b(X_n^{I\\_mis})\\Delta W_n + \\frac{1}{2} b(X_n^{I\\_mis})b'(X_n^{I\\_mis}) ((\\Delta W_n)^2 - h)$$\n\n两条轨迹之间的差异完全源于积分步骤中使用的漂移项不同。在每一步中，忽略状态 $X_n^S$ 和 $X_n^{I\\_mis}$ 之间的高阶差异，$X^S$ 的更新包含一个额外的漂移分量 $\\frac{1}{2}b(X_n)b'(X_n)h$。这种系统性差异在整个模拟过程中会不断累积，导致路径出现分歧。如果 $b'(x) = 0$（加性噪声），则修正项消失，Itô 和 Stratonovich 诠释一致，从而产生完全相同的轨迹。", "answer": "```python\nimport numpy as np\n\n# It is specified that scipy version 1.11.4 is available,\n# but it is not required for this problem.\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # We use 'lam' for the parameter lambda to avoid Python keyword conflict.\n    test_cases = [\n        # Test Case A (multiplicative noise)\n        {\n            'x0': 1.0, 'lam': 0.25, 'sig': 1.0, 'T': 1.0, 'N': 2000, 'seed': 7,\n            'alpha_f': lambda x, lam: lam * x,\n            'b_f': lambda x, sig: sig * x,\n            'b_prime_f': lambda x, sig: sig\n        },\n        # Test Case B (additive noise)\n        {\n            'x0': 1.0, 'lam': 0.25, 'sig': 1.0, 'T': 1.0, 'N': 2000, 'seed': 7,\n            'alpha_f': lambda x, lam: lam * x,\n            'b_f': lambda x, sig: sig, # b(x) is constant\n            'b_prime_f': lambda x, sig: 0.0 # b'(x) is zero\n        },\n        # Test Case C (multiplicative noise, finer grid)\n        {\n            'x0': 1.0, 'lam': 0.25, 'sig': 1.0, 'T': 1.0, 'N': 20000, 'seed': 12345,\n            'alpha_f': lambda x, lam: lam * x,\n            'b_f': lambda x, sig: sig * x,\n            'b_prime_f': lambda x, sig: sig\n        }\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        # Unpack parameters\n        x0, lam, sig, T, N, seed = case['x0'], case['lam'], case['sig'], case['T'], case['N'], case['seed']\n        alpha_f, b_f, b_prime_f = case['alpha_f'], case['b_f'], case['b_prime_f']\n        \n        # Simulation setup\n        h = T / N\n        rng = np.random.default_rng(seed)\n        dw_increments = rng.normal(0.0, np.sqrt(h), N)\n        \n        # --- Trajectory S (Correct Stratonovich simulation via Itô conversion) ---\n        # The Stratonovich SDE: dX = alpha(X)dt + b(X) o dW\n        # has an equivalent Itô SDE: dX = a_S(X)dt + b(X)dW,\n        # where the correct Itô drift is a_S(X) = alpha(X) + 0.5 * b(X) * b'(X).\n        # The Milstein method is applied to this Itô SDE.\n        x_s = x0\n        for n in range(N):\n            alpha_val = alpha_f(x_s, lam)\n            b_val = b_f(x_s, sig)\n            b_prime_val = b_prime_f(x_s, sig)\n            \n            # Correct Itô drift for the equivalent SDE\n            a_s_val = alpha_val + 0.5 * b_val * b_prime_val\n            \n            dw = dw_increments[n]\n            \n            milstein_term = 0.5 * b_val * b_prime_val * (dw**2 - h)\n            x_s += a_s_val * h + b_val * dw + milstein_term\n\n        # --- Trajectory I_mis (Misinformed Itô simulation) ---\n        # The Stratonovich coefficients (alpha, b) are wrongly interpreted\n        # as defining an Itô SDE, dX = alpha(X)dt + b(X)dW.\n        # The Milstein method is applied directly with the incorrect drift `alpha`.\n        x_imis = x0\n        for n in range(N):\n            alpha_val = alpha_f(x_imis, lam)\n            b_val = b_f(x_imis, sig)\n            b_prime_val = b_prime_f(x_imis, sig)\n            \n            # Incorrect Itô drift is taken as alpha\n            a_imis_val = alpha_val\n            \n            dw = dw_increments[n]\n            \n            milstein_term = 0.5 * b_val * b_prime_val * (dw**2 - h)\n            x_imis += a_imis_val * h + b_val * dw + milstein_term\n            \n        # Calculate terminal difference\n        terminal_difference = x_s - x_imis\n        results.append(terminal_difference)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3002512"}]}