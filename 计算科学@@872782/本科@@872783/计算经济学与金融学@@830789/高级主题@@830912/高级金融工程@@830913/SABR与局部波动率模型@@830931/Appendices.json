{"hands_on_practices": [{"introduction": "要真正掌握SABR模型，关键在于理解它与局部波动率模型之间的深刻联系。这个练习将通过一个重要的特例来揭示这种关系：当波动率的波动率$\\nu$为零时，SABR模型会发生什么？通过推导此情景下的等价局部波动率函数[@problem_id:2428074]，你将亲手证明SABR模型如何简化为更基础的恒定方差弹性(CEV)模型，从而直观地理解参数$\\nu$在产生随机波动性中的核心作用。", "problem": "考虑在零利率的风险中性测度下的随机 Alpha Beta Rho (SABR) 模型。资产价格过程 $S_{t}$ 及其随机波动率因子 $\\alpha_{t}$ 满足以下耦合的随机微分方程\n$$\n\\mathrm{d}S_{t} \\;=\\; \\alpha_{t}\\, S_{t}^{\\beta}\\, \\mathrm{d}W^{(1)}_{t}, \n\\qquad \n\\mathrm{d}\\alpha_{t} \\;=\\; \\nu\\, \\alpha_{t}\\, \\mathrm{d}W^{(2)}_{t},\n\\qquad \n\\mathrm{d}\\langle W^{(1)}, W^{(2)} \\rangle_{t} \\;=\\; \\rho\\, \\mathrm{d}t,\n$$\n其中给定常数 $\\alpha_{0} = \\alpha > 0$，$\\beta \\in (0,1]$，$\\rho \\in [-1,1]$，$\\nu \\ge 0$ 以及初始价格 $S_{0} > 0$。令 $W^{(1)}$ 和 $W^{(2)}$ 为具有所述瞬时相关性的标准布朗运动。\n\n局部波动率模型是 $S_{t}$ 的一种单因子扩散模型，其形式为\n$$\n\\mathrm{d}S_{t} \\;=\\; \\sigma_{LV}(S_{t}, t)\\, \\mathrm{d}W_{t},\n$$\n其中 $W_{t}$ 是一个标准布朗运动。假设对于每个 $t \\ge 0$，$S_{t}$ 在 SABR 模型下的一维边际分布与在局部波动率模型下的分布一致。\n\n在保持其他 SABR 参数 $\\alpha$、$\\beta$ 和 $\\rho$ 给定的情况下，将问题特化到 $\\nu = 0$ 的情形。推导对于所有 $S>0$ 和 $t \\ge 0$ 的等效局部波动率函数 $\\sigma_{LV}(S,t)$ 的显式表达式。请以单个闭式解析表达式的形式给出您的答案。", "solution": "问题要求在波动率的波动率参数 $\\nu$ 为零的特殊情况下，推导随机 Alpha Beta Rho (SABR) 模型的等效局部波动率函数 $\\sigma_{LV}(S,t)$ 的显式表达式。\n\n资产价格 $S_t$ 及其随机波动率 $\\alpha_t$ 的 SABR 模型由以下随机微分方程组给出：\n$$\n\\mathrm{d}S_{t} = \\alpha_{t} S_{t}^{\\beta} \\mathrm{d}W^{(1)}_{t}\n$$\n$$\n\\mathrm{d}\\alpha_{t} = \\nu \\alpha_{t} \\mathrm{d}W^{(2)}_{t}\n$$\n其中 $W^{(1)}_t$ 和 $W^{(2)}_t$ 是瞬时相关性为 $\\rho$ 的标准布朗运动，满足 $\\mathrm{d}\\langle W^{(1)}, W^{(2)} \\rangle_{t} = \\rho \\mathrm{d}t$。模型参数包括初始波动率 $\\alpha_0 = \\alpha > 0$、弹性系数 $\\beta \\in (0,1]$、相关系数 $\\rho \\in [-1,1]$ 和波动率的波动率 $\\nu \\ge 0$。初始资产价格为 $S_0 > 0$。我们在零利率的风险中性测度下进行操作，因此资产价格动态中没有漂移项。\n\n局部波动率模型由以下形式的单个随机微分方程定义：\n$$\n\\mathrm{d}S_{t} = \\sigma_{LV}(S_{t}, t) \\mathrm{d}W_{t}\n$$\n其中 $\\sigma_{LV}(S,t)$ 是某个函数，$W_t$ 是一个标准布朗运动。\n\n问题陈述，对于每个时间 $t \\ge 0$，$S_t$ 在 SABR 模型下的一维边际概率分布必须与在局部波动率模型下的分布一致。这种等价性使我们能够确定 $\\sigma_{LV}(S,t)$。一个通常归功于 Gyöngy 引理的普适性结论指出，局部波动率的平方 $\\sigma_{LV}^2(S,t)$ 等于原始过程的瞬时方差在时刻 $t$ 过程处于状态 $S$ 条件下的条件期望。\n\n对于 SABR 模型，$S_t$ 过程的瞬时方差为 $(\\alpha_t S_t^{\\beta})^2$。应用 Gyöngy 引理，我们有：\n$$\n\\sigma_{LV}^2(S,t) = E\\left[ (\\alpha_t S_t^{\\beta})^2 \\mid S_t=S \\right]\n$$\n由于在条件中 $S_t$ 的值固定为 $S$，我们可以将包含 $S_t$ 的项从期望中提出：\n$$\n\\sigma_{LV}^2(S,t) = S^{2\\beta} E\\left[ \\alpha_t^2 \\mid S_t=S \\right]\n$$\n该表达式对一般的 SABR 模型都有效。\n\n现在，问题要求我们特化到 $\\nu = 0$ 的情况。我们分析在此条件下 $\\alpha_t$ 的随机微分方程：\n$$\n\\mathrm{d}\\alpha_{t} = (0) \\cdot \\alpha_{t} \\mathrm{d}W^{(2)}_{t} = 0\n$$\n一个扩散系数为零的随机微分方程意味着过程 $\\alpha_t$ 的二次变差为零，因此它随时间保持不变。对于所有 $t \\ge 0$，它都保持其初始值：\n$$\n\\alpha_t = \\alpha_0 = \\alpha\n$$\n在这个特例中，“随机”波动率因子实际上是一个确定性常数。\n\n我们将这个确定性的 $\\alpha_t$ 值代回到局部波动率平方的公式中：\n$$\n\\sigma_{LV}^2(S,t) = S^{2\\beta} E\\left[ \\alpha^2 \\mid S_t=S \\right]\n$$\n由于 $\\alpha$ 是一个常数，其期望就是 $\\alpha^2$，无论任何条件如何。对 $S_t=S$ 取条件对一个常数的期望没有影响。\n$$\nE\\left[ \\alpha^2 \\mid S_t=S \\right] = \\alpha^2\n$$\n因此，局部波动率平方的表达式简化为：\n$$\n\\sigma_{LV}^2(S,t) = S^{2\\beta} \\alpha^2 = (\\alpha S^{\\beta})^2\n$$\n为了求得 $\\sigma_{LV}(S,t)$，我们取正平方根，因为波动率必须是一个非负量：\n$$\n\\sigma_{LV}(S,t) = \\sqrt{(\\alpha S^{\\beta})^2} = |\\alpha S^{\\beta}|\n$$\n考虑到问题约束条件 $\\alpha > 0$，并且资产价格 $S$ 是金融工具的价格，因此 $S > 0$，乘积 $\\alpha S^{\\beta}$ 总是正的。因此，绝对值是多余的。\n$$\n\\sigma_{LV}(S,t) = \\alpha S^{\\beta}\n$$\n这个结果表明，当 $\\nu=0$ 时，SABR 模型退化为一个时间齐次的局部波动率模型，具体来说是固定弹性方差 (CEV) 模型。所得到的局部波动率函数 $\\sigma_{LV}(S,t)$ 与时间 $t$ 和相关性参数 $\\rho$ 均无关。参数 $\\rho$ 变得无关紧要，因为波动率过程 $\\alpha_t$ 是恒定的，这意味着布朗运动 $W^{(2)}_t$ 不再影响系统的动态。", "answer": "$$\n\\boxed{\\alpha S^{\\beta}}\n$$", "id": "2428074"}, {"introduction": "SABR模型在金融实践中广受欢迎，其主要原因之一是它能准确地捕捉市场中观察到的波动率微笑和偏斜。此练习将带你深入SABR模型的核心应用，通过解析方法推导并计算平价(at-the-money)期权的波动率偏斜。完成这项练习[@problem_id:2428115]，你将清晰地看到模型参数（尤其是相关性$\\rho$）如何直接影响和控制波动率微笑的形态，从而将抽象的数学模型与具体的市场现象联系起来。", "problem": "给定风险中性测度下的随机 Alpha Beta Rho (SABR) 模型，用于描述远期价格过程。对于到期时间 $T > 0$，远期价格过程 $F_t$ 及其波动率过程 $\\alpha_t$ 满足：\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta} \\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t \\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)},W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\n其中，常数满足 $0 \\le \\beta \\le 1$，$\\nu \\ge 0$，相关性 $-1 < \\rho < 1$，初始条件为 $F_0$ 和 $\\alpha_0 = \\alpha$。考虑与时间-0 远期价格 $F_0$ 相关联的布莱克隐含波动率函数 $\\sigma_{\\mathrm{imp}}(K,T)$。根据定义，它是唯一的非负 $\\sigma$，使得使用波动率 $\\sigma$ 和行权价 $K$ 的布莱克公式计算出的价格与 SABR 模型下看涨期权在时间-0 的价值相匹配。在本问题中，您将使用标准的到期时间一阶渐近近似来对 $\\sigma_{\\mathrm{imp}}(K,T)$ 进行建模，定义如下。对于给定的参数 $(F_0,K,T,\\alpha,\\beta,\\rho,\\nu)$，定义\n$$\nz = \\frac{\\nu}{\\alpha}\\,(F_0 K)^{\\frac{1-\\beta}{2}} \\ln\\!\\left(\\frac{F_0}{K}\\right), \\qquad \n\\chi(z) = \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right),\n$$\n和\n$$\n\\sigma_{\\mathrm{imp}}(K,T) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}}\\,\\frac{z}{\\chi(z)}\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right],\n$$\n并约定当 $z = 0$ 时，根据连续性，比率 $z/\\chi(z)$ 取值为 $1$。平价偏斜定义为隐含波动率相对于对数货币性 $k = \\ln(K/F_0)$ 在平价点 $k=0$ 处的导数：\n$$\nS(T;\\rho) = \\left.\\frac{\\partial \\sigma_{\\mathrm{imp}}(K,T)}{\\partial k}\\right|_{k=0}, \\quad \\text{其中 } k=\\ln\\!\\left(\\frac{K}{F_0}\\right).\n$$\n您的任务是使用上述 $\\sigma_{\\mathrm{imp}}(K,T)$ 的定义来计算 $S(T;\\rho)$，并分析其在不同期限下对相关性参数 $\\rho$ 的依赖性。\n\n使用以下基本参数值：远期价格 $F_0 = 100$，初始波动率水平 $\\alpha = 0.2$，弹性 $\\beta = 0.5$，以及波动率的波动率 $\\nu = 0.6$。将波动率及其导数视为无量纲量；所有数值输出必须以小数形式表示（而非百分比）。本问题不涉及角度。到期时间 $T$ 以年为单位。\n\n测试集：\n- 考虑由 $\\rho \\in \\{-0.9, 0.0, 0.9\\}$ 和 $T \\in \\{0.25, 1.0, 5.0\\}$ 的笛卡尔积形成的九个测试用例，按以下顺序进行评估：\n$$\n(\\rho,T) \\in \\{(-0.9,0.25),\\,(-0.9,1.0),\\,(-0.9,5.0),\\,(0.0,0.25),\\,(0.0,1.0),\\,(0.0,5.0),\\,(0.9,0.25),\\,(0.9,1.0),\\,(0.9,5.0)\\}.\n$$\n\n要求输出：\n- 对于每个测试用例，计算平价偏斜 $S(T;\\rho)$，结果为一个实数。您的程序应生成单行输出，其中包含九个结果，以逗号分隔并用方括号括起，顺序与上述完全一致。每个数字必须四舍五入到六位小数。例如，输出必须如下所示：\n$$\n[\\text{value}_1,\\text{value}_2,\\ldots,\\text{value}_9],\n$$\n该行中任何地方都不能有空格。\n\n不提供外部输入；所有参数均如上所述。您的实现必须是通用的，并且仅基于此处给出的数学定义和模型近似。测试集的最终数值答案必须是四舍五入到六位小数的浮点数。", "solution": "问题陈述经过验证，确认有效。这是一个计算金融学中定义明确的问题，基于成熟的数学模型，并为获得唯一解提供了所有必要信息。我们将继续进行推导和计算。\n\n任务是计算隐含波动率的平价（ATM）偏斜，其定义为隐含波动率 $\\sigma_{\\mathrm{imp}}(K,T)$ 相对于对数货币性 $k = \\ln(K/F_0)$ 在平价点 $k=0$（对应于 $K=F_0$）处的导数。隐含波动率由一阶渐近近似给出：\n$$\n\\sigma_{\\mathrm{imp}}(K,T) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}}\\,\\frac{z}{\\chi(z)}\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right]\n$$\n其中 $z = \\frac{\\nu}{\\alpha}(F_0 K)^{\\frac{1-\\beta}{2}} \\ln(F_0/K)$ 且 $\\chi(z) = \\ln\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right)$。\n\n我们必须计算 $S(T;\\rho) = \\left.\\frac{\\partial \\sigma_{\\mathrm{imp}}(K,T)}{\\partial k}\\right|_{k=0}$。首先，我们将所有量表示为对数货币性 $k = \\ln(K/F_0)$ 的函数。这意味着 $K = F_0 e^k$。\n\n变量 $z$ 可以用 $k$ 来表示：\n$$\n\\ln\\left(\\frac{F_0}{K}\\right) = \\ln\\left(\\frac{F_0}{F_0 e^k}\\right) = -k\n$$\n$$\n(F_0 K)^{\\frac{1-\\beta}{2}} = (F_0^2 e^k)^{\\frac{1-\\beta}{2}} = F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}\n$$\n因此，\n$$\nz(k) = \\frac{\\nu}{\\alpha} F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}} (-k) = -k \\frac{\\nu}{\\alpha} F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}\n$$\n当 $k \\to 0$ 时，$z \\to 0$。\n\n隐含波动率公式 $\\sigma_{\\mathrm{imp}}$ 可以看作是三个关于 $k$ 的函数的乘积：$\\sigma_{\\mathrm{imp}}(k) = A(k)B(k)C(k)$，其中：\n$$\nA(k) = \\frac{\\alpha}{(F_0 K)^{\\frac{1-\\beta}{2}}} = \\frac{\\alpha}{F_0^{1-\\beta} e^{k\\frac{1-\\beta}{2}}} = \\alpha F_0^{-(1-\\beta)} e^{-k\\frac{1-\\beta}{2}}\n$$\n$$\nB(k) = \\frac{z(k)}{\\chi(z(k))}\n$$\n$$\nC(k) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,(F_0 K)^{1-\\beta}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,(F_0 K)^{\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n$$\n代入 $K = F_0 e^k$：\n$$\nC(k) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}e^{k(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}e^{k\\frac{1-\\beta}{2}}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n$$\n平价偏斜是该乘积在 $k=0$ 处的导数：\n$$\nS(T;\\rho) = \\left.\\frac{d\\sigma_{\\mathrm{imp}}}{dk}\\right|_{k=0} = A'(0)B(0)C(0) + A(0)B'(0)C(0) + A(0)B(0)C'(0)\n$$\n我们计算每一项及其在 $k=0$ 处的导数。\n\n1.  **项 $A(k)$ 及其导数：**\n    $$\n    A(0) = \\alpha F_0^{-(1-\\beta)} = \\frac{\\alpha}{F_0^{1-\\beta}}\n    $$\n    $$\n    A'(k) = \\alpha F_0^{-(1-\\beta)} \\left(-\\frac{1-\\beta}{2}\\right) e^{-k\\frac{1-\\beta}{2}} \\implies A'(0) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}}\n    $$\n\n2.  **项 $B(k)$ 及其导数：**\n    对于极限 $z \\to 0$，我们展开 $\\chi(z)$：\n    $$\n    \\sqrt{1-2\\rho z+z^2} = 1 - \\rho z + \\frac{1-\\rho^2}{2} z^2 + O(z^3)\n    $$\n    $$\n    \\chi(z) = \\ln\\left(\\frac{1 - \\rho z + z - \\rho + O(z^2)}{1-\\rho}\\right) = \\ln\\left(\\frac{(1-\\rho) + (1-\\rho)z + O(z^2)}{1-\\rho}\\right) = \\ln(1 + z + O(z^2))\n    $$\n    使用 $\\ln(1+x)=x - x^2/2 + \\dots$，我们得到一个更精确的 $\\chi(z)$ 展开式：\n    $$\n    \\chi(z) = z + \\frac{\\rho}{2} z^2 + O(z^3)\n    $$\n    因此，当 $z \\to 0$ 时：\n    $$\n    \\frac{z}{\\chi(z)} = \\frac{z}{z + \\frac{\\rho}{2} z^2 + O(z^3)} = \\frac{1}{1 + \\frac{\\rho}{2} z + O(z^2)} = 1 - \\frac{\\rho}{2} z + O(z^2)\n    $$\n    由此，我们发现 $B(0) = \\lim_{z\\to 0} \\frac{z}{\\chi(z)} = 1$，这与问题陈述一致。\n    导数 $B'(0)$ 使用链式法则计算：$B'(k) = \\frac{d B}{dz} \\frac{dz}{dk}$。\n    $$\n    \\left.\\frac{dB}{dz}\\right|_{z=0} = \\left.\\frac{d}{dz}\\left(1 - \\frac{\\rho}{2} z + O(z^2)\\right)\\right|_{z=0} = -\\frac{\\rho}{2}\n    $$\n    $$\n    \\frac{dz}{dk} = -\\frac{\\nu}{\\alpha}F_0^{1-\\beta} \\frac{d}{dk}\\left(k e^{k\\frac{1-\\beta}{2}}\\right) = -\\frac{\\nu}{\\alpha}F_0^{1-\\beta} \\left(e^{k\\frac{1-\\beta}{2}} + k \\frac{1-\\beta}{2} e^{k\\frac{1-\\beta}{2}}\\right)\n    $$\n    $$\n    \\left.\\frac{dz}{dk}\\right|_{k=0} = -\\frac{\\nu}{\\alpha} F_0^{1-\\beta}\n    $$\n    将这些结合起来得到：\n    $$\n    B'(0) = \\left.\\frac{dB}{dz}\\right|_{z=0} \\left.\\frac{dz}{dk}\\right|_{k=0} = \\left(-\\frac{\\rho}{2}\\right) \\left(-\\frac{\\nu}{\\alpha} F_0^{1-\\beta}\\right) = \\frac{\\rho \\nu F_0^{1-\\beta}}{2\\alpha}\n    $$\n\n3.  **项 $C(k)$ 及其导数：**\n    $$\n    C(0) = 1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\n    $$\n    导数 $C'(k)$ 为：\n    $$\n    C'(k) = T \\left( \\frac{(1-\\beta)^2 \\alpha^2}{24 F_0^{2(1-\\beta)}} (-(1-\\beta))e^{-k(1-\\beta)} + \\frac{\\rho \\beta \\nu \\alpha}{4 F_0^{1-\\beta}} \\left(-\\frac{1-\\beta}{2}\\right)e^{-k\\frac{1-\\beta}{2}} \\right)\n    $$\n    在 $k=0$ 处：\n    $$\n    C'(0) = T \\left( -\\frac{(1-\\beta)^3 \\alpha^2}{24 F_0^{2(1-\\beta)}} - \\frac{\\rho \\beta \\nu \\alpha(1-\\beta)}{8 F_0^{1-\\beta}} \\right)\n    $$\n\n最后，我们组合导数 $S(T;\\rho) = A'(0)B(0)C(0) + A(0)B'(0)C(0) + A(0)B(0)C'(0)$：\n$$\nS(T;\\rho) = [A'(0) + A(0)B'(0)]C(0) + A(0)C'(0)\n$$\n第一项是平价主干偏斜：\n$$\nS_0 = A'(0) + A(0)B'(0) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\left(\\frac{\\alpha}{F_0^{1-\\beta}}\\right)\\left(\\frac{\\rho \\nu F_0^{1-\\beta}}{2\\alpha}\\right) = -\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\frac{\\rho \\nu}{2}\n$$\n那么，偏斜的完整表达式是：\n$S(T;\\rho) = S_0 C(0) + A(0) C'(0)$。代入 $S_0, C(0), A(0), C'(0)$ 的表达式：\n$$\nS(T;\\rho) = \\left(-\\frac{\\alpha(1-\\beta)}{2F_0^{1-\\beta}} + \\frac{\\rho \\nu}{2}\\right)\\left[1 + T\\left(\\frac{(1-\\beta)^2 \\alpha^2}{24\\,F_0^{2(1-\\beta)}} + \\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{4\\,F_0^{1-\\beta}} + \\frac{(2-3\\rho^2)\\nu^2}{24}\\right)\\right] + \\frac{\\alpha}{F_0^{1-\\beta}} T \\left(-\\frac{(1-\\beta)^3 \\alpha^2}{24 F_0^{2(1-\\beta)}} - \\frac{\\rho \\beta \\nu \\alpha (1-\\beta)}{8 F_0^{1-\\beta}}\\right)\n$$\n这就是平价偏斜的解析公式。我们将实现此公式来计算指定测试集所需的值。\n基本参数为 $F_0 = 100$，$\\alpha = 0.2$，$\\beta = 0.5$，$\\nu = 0.6$。测试用例是 $\\rho \\in \\{-0.9, 0.0, 0.9\\}$ 和 $T \\in \\{0.25, 1.0, 5.0\\}$ 的笛卡尔积。\n计算过程通过将这些参数直接代入 $S(T;\\rho)$ 的最终公式来进行。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the at-the-money (ATM) skew for the SABR model based on a\n    first-order asymptotic approximation for the implied volatility.\n    \"\"\"\n\n    # Base parameter values\n    F0 = 100.0\n    alpha = 0.2\n    beta = 0.5\n    nu = 0.6\n\n    # Test suite from the problem statement\n    test_cases = [\n        (-0.9, 0.25), (-0.9, 1.0), (-0.9, 5.0),\n        (0.0, 0.25), (0.0, 1.0), (0.0, 5.0),\n        (0.9, 0.25), (0.9, 1.0), (0.9, 5.0)\n    ]\n\n    results = []\n    \n    # Pre-compute constants based on base parameters\n    one_minus_beta = 1.0 - beta\n    F0_pow_1_minus_beta = F0**one_minus_beta\n    F0_pow_2_1_minus_beta = F0**(2.0 * one_minus_beta)\n    \n    # Term A(0) from derivation\n    A_0 = alpha / F0_pow_1_minus_beta\n    \n    for case in test_cases:\n        rho, T = case\n\n        # --- Calculation based on the derived formula for S(T; rho) ---\n        \n        # S_0 = -alpha(1-beta)/(2*F0^(1-beta)) + rho*nu/2\n        # This is the ATM skew of the backbone volatility.\n        S_0 = -alpha * one_minus_beta / (2.0 * F0_pow_1_minus_beta) + rho * nu / 2.0\n\n        # Term C(0) from derivation\n        # C(0) = 1 + T * (term1 + term2 + term3)\n        c0_term1 = (one_minus_beta**2 * alpha**2) / (24.0 * F0_pow_2_1_minus_beta)\n        c0_term2 = (rho * beta * nu * alpha) / (4.0 * F0_pow_1_minus_beta)\n        c0_term3 = (2.0 - 3.0 * rho**2) * nu**2 / 24.0\n        C_0 = 1.0 + T * (c0_term1 + c0_term2 + c0_term3)\n        \n        # Term C'(0) from derivation\n        # C'(0) = T * (term1 + term2)\n        c_prime_0_term1 = -(one_minus_beta**3 * alpha**2) / (24.0 * F0_pow_2_1_minus_beta)\n        c_prime_0_term2 = -(rho * beta * nu * alpha * one_minus_beta) / (8.0 * F0_pow_1_minus_beta)\n        C_prime_0 = T * (c_prime_0_term1 + c_prime_0_term2)\n\n        # Final ATM skew S(T; rho) = S_0 * C(0) + A(0) * C'(0)\n        skew = S_0 * C_0 + A_0 * C_prime_0\n        \n        results.append(skew)\n\n    # Format the output as specified: comma-separated list in brackets,\n    # with each value rounded to six decimal places. No spaces.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2428115"}, {"introduction": "在理论分析之外，数值计算是量化金融从业者的基本功。这个练习将理论付诸实践，要求你使用金融工程中常用的有限差分法来数值计算波动率微笑的斜率[@problem_id:2428125]。通过探索相关性参数$\\rho$在其极限值（即$+1$和$-1$）附近时模型的行为，你不仅能巩固关于$\\rho$如何决定微笑形状的直觉，还能获得宝贵的编程实现经验，为解决更复杂的实际问题打下基础。", "problem": "给定在风险中性测度下，用于严格正的远期价格过程 $F_t$ 的 Stochastic Alpha, Beta, Rho (SABR) 模型：\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta} \\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t \\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho \\,\\mathrm{d}t,\n$$\n其参数为 $\\alpha_0 = \\alpha \\gt 0$，$\\beta \\in [0,1]$，$\\nu \\ge 0$，以及相关系数 $\\rho \\in (-1,1)$。考虑在 SABR 模型下，一个到期日为 $T \\gt 0$、远期价格为 $F \\gt 0$、执行价格为 $K \\gt 0$ 的欧式看涨期权的 Black-Scholes (BS) 隐含波动率，该波动率由 Hagan 等人的渐近公式一阶近似给出：\n- 对于一般的 $K \\ne F$，定义\n$$\n\\log_{FK} = \\ln\\!\\left(\\frac{F}{K}\\right), \\quad \\phi = (F K)^{\\frac{1-\\beta}{2}}, \\quad z = \\frac{\\nu}{\\alpha} \\,\\phi\\, \\log_{FK}, \\quad x(z) = \\ln\\!\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right),\n$$\n隐含波动率的近似值为\n$$\n\\sigma_{\\text{BS}}(F,K,T;\\alpha,\\beta,\\rho,\\nu) \\approx \\frac{\\alpha}{\\phi} \\cdot \\frac{z}{x(z)} \\cdot \\left[ 1 + \\frac{(1-\\beta)^2}{24}\\,\\log_{FK}^2 + \\frac{(1-\\beta)^4}{1920}\\,\\log_{FK}^4 \\right] \\cdot \\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{(F K)^{1-\\beta}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{(F K)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}.\n$$\n- 平价（At-the-money，$K=F$）时，使用连续极限\n$$\n\\sigma_{\\text{BS}}(F,F,T;\\alpha,\\beta,\\rho,\\nu) \\approx \\frac{\\alpha}{F^{1-\\beta}} \\cdot \\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{F^{2(1-\\beta)}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}.\n$$\n所有波动率必须以小数形式表示（例如，$0.2$ 代表 $20\\%$），并且所有输出都必须是小数形式，不带百分号。\n\n您的任务是，通过计算分析当相关性参数 $\\rho$ 接近其极限 $+1$ 和 $-1$ 时，SABR 波动率微笑的行为。对于下面测试套件中的每组参数，使用围绕 $K=F$ 的对称有限差分（执行价格扰动为 $\\Delta K = 0.01\\,F$），计算平价时隐含波动率微笑相对于执行价格的斜率。具体来说，对于每个固定的 $\\rho$，定义斜率\n$$\nS(F,\\alpha,\\beta,\\rho,\\nu,T) = \\frac{\\sigma_{\\text{BS}}(F,F+\\Delta K,T;\\alpha,\\beta,\\rho,\\nu) - \\sigma_{\\text{BS}}(F,F-\\Delta K,T;\\alpha,\\beta,\\rho,\\nu)}{2\\,\\Delta K}.\n$$\n您必须计算当 $\\rho \\in \\{-0.999,\\,0.0,\\,0.999\\}$ 时的 $S$。\n\n测试套件（三组参数），以 $(F,\\alpha,\\beta,\\nu,T)$ 的形式给出：\n1. $(100.0,\\,0.3,\\,0.5,\\,0.5,\\,1.0)$,\n2. $(100.0,\\,0.2,\\,0.7,\\,0.05,\\,1.0)$,\n3. $(100.0,\\,0.2,\\,0.0,\\,0.8,\\,2.0)$.\n\n您的程序必须对于按上述顺序列出的每组参数，生成分别对应 $\\rho=-0.999$、$\\rho=0.0$ 和 $\\rho=0.999$ 的三个斜率 $S$。将所有九个结果按此顺序汇总到一个扁平列表中。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按所述顺序包含 $9$ 个浮点数，例如：\n\"[s1_neg,s1_zero,s1_pos,s2_neg,s2_zero,s2_pos,s3_neg,s3_zero,s3_pos]\".", "solution": "问题陈述经过严格审查，被认为是有效的。它具有科学依据，提法明确，且客观。该问题是量化金融领域的一个标准计算练习，涉及著名的 Stochastic Alpha, Beta, Rho (SABR) 模型以及 Hagan 等人提出的隐含波动率渐近近似公式。所提供的方程是正确的，参数在典型范围内，且计算任务定义清晰可行。不存在矛盾、歧义或不成立的前提。\n\n任务是计算 SABR 隐含波动率微笑相对于执行价格 $K$ 的平价斜率。这个量通常被称为“偏斜”（skew），是波动率曲面的一个关键特征。为此，规定使用对称有限差分格式：\n$$\nS(F,\\alpha,\\beta,\\rho,\\nu,T) = \\frac{\\sigma_{\\text{BS}}(F,F+\\Delta K,T;\\alpha,\\beta,\\rho,\\nu) - \\sigma_{\\text{BS}}(F,F-\\Delta K,T;\\alpha,\\beta,\\rho,\\nu)}{2\\,\\Delta K}\n$$\n其中 $\\sigma_{\\text{BS}}(F,K,\\dots)$ 是 Hagan 等人用于 Black-Scholes 隐含波动率的一阶近似。执行价格扰动给定为 $\\Delta K = 0.01\\,F$。\n\n解决方案的核心是针对 $K \\ne F$ 的情况，实现所提供的 $\\sigma_{\\text{BS}}(F, K, \\dots)$ 公式。该公式由几个必须仔细评估的项组成：\n1. 主要的前置因子是 $\\frac{\\alpha}{\\phi}$，其中 $\\phi = (F K)^{\\frac{1-\\beta}{2}}$ 项通过由参数 $\\beta$ 决定的恒定方差弹性（CEV）主干，捕捉了对远期价格 $F$ 和执行价格 $K$ 的主要依赖关系。\n\n2. “对数正态主干”调整项是 $\\frac{z}{x(z)}$，其中 $z = \\frac{\\nu}{\\alpha} \\,\\phi\\, \\ln\\left(\\frac{F}{K}\\right)$ 且 $x(z) = \\ln\\left(\\frac{\\sqrt{1 - 2\\rho z + z^2} + z - \\rho}{1 - \\rho}\\right)$。此项捕捉了由波动率的波动率参数 $\\nu$ 驱动的随机波动率过程的影响。对于接近远期价格的执行价格（$K \\to F$），$z \\to 0$，此项趋近其极限值 $1$。\n\n3. 一个密度校正项 $\\left[ 1 + \\frac{(1-\\beta)^2}{24}\\,\\ln^2(F/K) + \\frac{(1-\\beta)^4}{1920}\\,\\ln^4(F/K) \\right]$，它对主干参数 $\\beta$ 不同于 $1$（对数正态情况）的情况进行调整。\n\n4. 一个与时间相关的校正项 $\\left\\{ 1 + \\left[ \\frac{(1-\\beta)^2}{24}\\frac{\\alpha^2}{(F K)^{1-\\beta}} + \\frac{1}{4}\\frac{\\rho\\,\\beta\\,\\nu\\,\\alpha}{(F K)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2 \\right] T \\right\\}$，它提供了对时间 $T$ 的一阶校正。\n\n解决方案需要计算对于执行价格 $K_{+} = F + \\Delta K$ 和 $K_{-} = F - \\Delta K$ 的波动率 $\\sigma_{\\text{BS}}$，然后计算对于相关性参数的 $3$ 个值 $\\rho \\in \\{-0.999, 0.0, 0.999\\}$ 的斜率 $S$。对测试套件中提供的 $3$ 组参数中的每一组重复此过程。\n\n相关性参数 $\\rho$ 是控制波动率微笑斜率的主要因素。负的 $\\rho$（这在股票市场中很典型）意味着一个向下倾斜的微笑，即在较低的执行价格下波动率更高。正的 $\\rho$ 意味着一个向上倾斜的微笑。当 $\\rho=0$ 时，微笑曲线在平价点周围更对称，其平价斜率主要由 CEV 主干的凸性驱动，这导致一个更小的、通常为非零的斜率。计算将展示这种特征行为。\n\n实现是用 Python 完成的，利用了 NumPy 库以进行稳健的浮点运算。所提供的公式被直接转录到一个 Python 函数中。程序的主体部分遍历测试用例和指定的 $\\rho$ 值，以生成所需的 $9$ 个斜率值，然后按要求将这些值汇总并格式化为最终的输出列表。对于 $z/x(z)$ 项，不需要特殊的数值处理，因为规定的执行价格扰动 $\\Delta K = 0.01\\,F$ 足够大，可以避免在标准双精度算术中出现不稳定性。", "answer": "```python\nimport numpy as np\n\ndef sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n    \"\"\"\n    Computes the SABR implied volatility using the Hagan et al. 2002 first-order approximation.\n    This implementation handles the K != F case.\n    \"\"\"\n    \n    # Ensure K is positive to avoid mathematical domain errors.\n    if K == 0:\n        return np.nan\n\n    log_FK = np.log(F / K)\n    \n    # For nu=0, the model collapses to CEV. The z/x(z) term becomes 1.\n    if np.isclose(nu, 0):\n        z = 0\n        z_over_x = 1.0\n    else:\n        phi = (F * K)**((1 - beta) / 2.0)\n        z = (nu / alpha) * phi * log_FK\n        \n        # Argument of the logarithm in x(z) can cause numerical issues if not handled carefully.\n        # Direct computation with numpy's float64 is generally sufficient for non-extreme parameters.\n        x_z_arg_num = np.sqrt(1 - 2*rho*z + z**2) + z - rho\n        x_z_arg_den = 1 - rho\n        \n        # To avoid log(0) for rho=1, or other issues, check argument positivity.\n        # For rho approaching 1, both num and den approach 0.\n        # For rho approaching -1, den approaches 2.\n        if x_z_arg_num = 0 or x_z_arg_den == 0:\n            # Handle pathological cases, though not expected with given test data.\n            # Using series expansion for z/x(z) is the robust way, but not required here.\n            # Fallback to limit for small z as a simple guard.\n             if np.isclose(z, 0.0):\n                z_over_x = 1.0\n             else:\n                return np.nan\n        else:\n            x_z = np.log(x_z_arg_num / x_z_arg_den)\n            # Handle the limit z/x(z) -> 1 as z -> 0\n            if np.isclose(z, 0.0):\n                z_over_x = 1.0\n            else:\n                z_over_x = z / x_z\n\n    # Main term without corrections\n    # phi is defined inside the 'else' block, so redefine for generality\n    phi = (F * K)**((1 - beta) / 2.0)\n    term_main = (alpha / phi) * z_over_x\n\n    # First correction term (log-space adjustment)\n    term_1_beta_sq = (1 - beta)**2\n    term_log_adj = 1.0 + (term_1_beta_sq / 24.0) * log_FK**2 + (term_1_beta_sq**2 / 1920.0) * log_FK**4\n    \n    # Second correction term (time-dependent adjustment)\n    fk_pow_1_beta = (F * K)**(1 - beta)\n    \n    term_T_adj_1 = (term_1_beta_sq / 24.0) * (alpha**2 / fk_pow_1_beta)\n    term_T_adj_2 = (rho * beta * nu * alpha) / (4.0 * phi)\n    term_T_adj_3 = ((2.0 - 3.0*rho**2) / 24.0) * nu**2\n    \n    term_T_adj = 1.0 + (term_T_adj_1 + term_T_adj_2 + term_T_adj_3) * T\n                       \n    vol = term_main * term_log_adj * term_T_adj\n    \n    return vol\n\ndef solve():\n    \"\"\"\n    Main solver function to compute the SABR smile slope for the given test cases.\n    \"\"\"\n    # Test cases: (F, alpha, beta, nu, T)\n    test_cases = [\n        (100.0, 0.3, 0.5, 0.5, 1.0),\n        (100.0, 0.2, 0.7, 0.05, 1.0),\n        (100.0, 0.2, 0.0, 0.8, 2.0),\n    ]\n    \n    rhos = [-0.999, 0.0, 0.999]\n    results = []\n    \n    for case in test_cases:\n        F, alpha, beta, nu, T = case\n        delta_K = 0.01 * F\n        K_plus = F + delta_K\n        K_minus = F - delta_K\n\n        for rho in rhos:\n            vol_plus = sabr_implied_vol(F, K_plus, T, alpha, beta, rho, nu)\n            vol_minus = sabr_implied_vol(F, K_minus, T, alpha, beta, rho, nu)\n            \n            # Symmetric finite difference for the slope\n            slope = (vol_plus - vol_minus) / (2.0 * delta_K)\n            results.append(slope)\n\n    # Format output as a comma-separated list in brackets.\n    output_str = \",\".join(map(lambda x: f\"{x:.10f}\", results))\n    print(f\"[{output_str}]\")\n\nsolve()\n\n```", "id": "2428125"}]}