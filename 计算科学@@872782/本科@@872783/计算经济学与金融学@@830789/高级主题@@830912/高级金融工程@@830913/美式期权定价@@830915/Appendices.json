{"hands_on_practices": [{"introduction": "二叉树模型是期权定价中最基本且直观的工具之一，它将资产价格在连续时间内的随机游走过程离散化为一系列简单的“上涨”或“下跌”步骤。本练习将经典的 Cox-Ross-Rubinstein (CRR) 模型应用于一个更贴近现实的场景：为商品期权定价。此处的关键挑战在于处理一个随时间变化的有效收益率 $q(t)$，该收益率包含了季节性因素和存储成本，这使得风险中性概率在树的每一步上都会发生变化。通过这个练习，你将掌握后向归纳法 (backward induction) 的核心技能，并学会如何调整基础模型以适应更复杂的资产动态。[@problem_id:2420641]", "problem": "要求您编程式计算一份美式期权的价值，该期权以一种商品为标的，其现货价格过程受季节性和存储成本的影响。在风险中性测度下进行计算。商品现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 具有如下的瞬时动态：\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t,\n$$\n其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，$q(t)$ 是随时间变化的有效收益率。该有效收益率结合了一个确定性的季节性分量和被视为负连续股息收益率的存储成本：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s.\n$$\n此处，$q_0$ 是基准便利收益率水平，$A$ 是季节性振幅，$\\phi$ 是相位（以弧度为单位），$s$ 是存储成本率。所有利率均以年为单位的小数表示，时间 $t$ 和 $T$ 均以年为单位。\n\n对于数值估值，使用一个在 $N$ 个长度为 $\\Delta t = T/N$ 的等长时间步上的 Cox-Ross-Rubinstein 可重组二叉树模型进行离散时间近似。上涨和下跌乘数分别为\n$$\nu = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = \\frac{1}{u},\n$$\n在对应于时间 $t_i = i \\Delta t$ 的时间步 $i \\in \\{0,1,\\dots,N-1\\}$，单步风险中性概率为\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}.\n$$\n单步贴现因子为 $D = e^{-r \\Delta t}$。在上述模型下，时间 0 的美式期权价值是在网格 $\\{0, \\Delta t, 2 \\Delta t, \\dots, T\\}$ 上取值的所有停止时间 $\\tau$ 的贴现期望收益的上确界。对于看涨期权，收益函数为 $\\Pi(S) = \\max(S - K, 0)$；对于看跌期权，收益函数为 $\\Pi(S) = \\max(K - S, 0)$。\n\n实现一个程序，为以下每个测试用例计算时间 0 的美式期权价值。所有输入均使用上述单位，其中 $\\phi$ 以弧度为单位给出。每个用例的输出必须是单个实数（浮点数）。每个结果必须四舍五入到六位小数。\n\n测试套件：\n- 案例 1（由于存储成本，季节性有效收益率在负值附近振荡，基准一年期）：\n  - $S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$.\n- 案例 2（极短期限边界，单步树）：\n  - $S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, 期权类型：看跌期权。\n  - $q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$.\n- 案例 3（由于存储成本和零无风险利率，导致有效收益率为负的美式看涨期权）：\n  - $S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, 期权类型：看涨期权。\n  - $q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$.\n- 案例 4（由于强便利收益率导致正有效收益率，一年期）：\n  - $S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, 期权类型：看跌期权。\n  - $q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$.\n\n最终输出格式：\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个价格都四舍五入到六位小数并以十进制数打印（例如，$[12.345678,9.876543,0.123456,4.000000]$）。不应打印任何其他文本。", "solution": "在尝试提供解决方案之前，该问题已经过验证。\n\n### 第 1 步：提取已知条件\n\n现货价格过程 $\\{S_t\\}_{t \\in [0,T]}$ 遵循以下随机微分方程：\n$$\n\\frac{dS_t}{S_t} = \\left(r - q(t)\\right) \\, dt + \\sigma \\, dW_t\n$$\n其中 $r$ 是无风险利率，$\\sigma$ 是波动率，$q(t)$ 是随时间变化的有效收益率。\n\n有效收益率定义为：\n$$\nq(t) = q_0 + A \\cos\\left(2\\pi t + \\phi\\right) - s\n$$\n其中 $q_0$ 是基准便利收益率，$A$ 是季节性振幅，$\\phi$ 是相位，$s$ 是存储成本率。\n\n数值方法是在周期 $T$ 内包含 $N$ 个时间步的 Cox-Ross-Rubinstein (CRR) 二叉树模型。\n- 时间步：$\\Delta t = T/N$。\n- 上涨/下跌乘数：$u = e^{\\sigma \\sqrt{\\Delta t}}$，$d = 1/u$。\n- 在时间 $t_i = i \\Delta t$ 的单步风险中性概率：\n$$\np_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n$$\n- 单步贴现因子：$D = e^{-r \\Delta t}$。\n- 收益函数：看涨期权为 $\\Pi(S) = \\max(S - K, 0)$，看跌期权为 $\\Pi(S) = \\max(K - S, 0)$。\n\n测试用例：\n1.  **案例 1**：$S_0 = 100.0$, $K = 100.0$, $r = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 400$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.03$, $\\phi = 0.0$, $s = 0.02$。\n2.  **案例 2**：$S_0 = 80.0$, $K = 100.0$, $r = 0.01$, $\\sigma = 0.25$, $T = 1/365$, $N = 1$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.02$, $\\phi = \\pi/2$, $s = 0.01$。\n3.  **案例 3**：$S_0 = 50.0$, $K = 40.0$, $r = 0.0$, $\\sigma = 0.3$, $T = 0.5$, $N = 300$, `期权类型：看涨期权`。$q(t)$ 的参数：$q_0 = 0.0$, $A = 0.0$, $\\phi = 0.0$, $s = 0.05$。\n4.  **案例 4**：$S_0 = 100.0$, $K = 90.0$, $r = 0.02$, $\\sigma = 0.25$, $T = 1.0$, $N = 400$, `期权类型：看跌期权`。$q(t)$ 的参数：$q_0 = 0.07$, $A = 0.02$, $\\phi = \\pi$, $s = 0.02$。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n根据验证标准对问题进行评估。\n- **科学依据**：所提供的模型是带有随时间变化漂移项的几何布朗运动的变体，这是量化金融中为商品价格建模的标准框架。包含季节性和存储成本的有效收益率 $q(t)$ 的形式也是一种常规方法。数值估值方法，即二叉树，是计算金融中期权定价的基石。所有方程和概念都基于成熟的金融工程原理。\n- **适定性**：该问题是适定的。每个测试用例的输入都是完整且充分的，足以使用指定算法计算出唯一的数值结果。带有随时间变化股息收益率的 CRR 模型已知可以为连续时间解提供一个收敛的近似。参数处于合理范围内，确保风险中性概率 $p_i$ 满足无套利条件 $0  p_i  1$。\n- **客观性**：问题以精确、客观的数学和金融语言陈述。它提供了具体的测试用例，并要求数值输出，没有主观解释的余地。\n\n该问题不存在任何科学上不健全、不完整、矛盾或歧义等缺陷。这是计算经济学和金融学中一个标准且定义明确的问题。\n\n### 第 3 步：结论与行动\n\n问题陈述是**有效的**。将提供解决方案。\n\n对具有指定动态的商品美式期权进行估值，是使用二叉格来完成的。基本原理是风险中性估值结合动态规划，以考虑提前行权的特性。在任何时间点，美式期权的价格是其内在价值（立即行权所得）和其持续价值（持有期权所得）中的最大值。\n\n该算法通过在可重组二叉树上进行反向归纳来执行。\n\n1.  **模型离散化**：将到期时间 $T$ 分为 $N$ 个长度为 $\\Delta t = T/N$ 的等长区间。商品价格 $S$ 的状态空间被离散化为一个二叉格。在时间 $t_i = i\\Delta t$ 的节点 $(i, j)$（经历了 $j$ 次上涨和 $i-j$ 次下跌）的价格由 $S_{i,j} = S_0 u^j d^{i-j}$ 给出。根据 CRR 模型，上涨和下跌乘数 $u$ 和 $d$ 由波动率 $\\sigma$ 和时间步 $\\Delta t$ 确定：\n    $$\n    u = e^{\\sigma \\sqrt{\\Delta t}}, \\quad d = e^{-\\sigma \\sqrt{\\Delta t}} = \\frac{1}{u}\n    $$\n    单步贴现因子是恒定的：$D = e^{-r \\Delta t}$。\n\n2.  **随时间变化的风险中性概率**：由于有效收益率 $q(t_i)$ 随时间变化，上涨的风险中性概率不是恒定的，而是取决于时间步 $i$。对于每个时间步 $t_i = i \\Delta t$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$），有效收益率为：\n    $$\n    q(t_i) = q_0 + A \\cos(2\\pi t_i + \\phi) - s\n    $$\n    这为从 $t_i$ 到 $t_{i+1}$ 的转移产生了一个与步长相关的风险中性概率 $p_i$：\n    $$\n    p_i = \\frac{e^{(r - q(t_i)) \\Delta t} - d}{u - d}\n    $$\n\n3.  **反向归纳算法**：\n    - **到期时初始化（时间 $T$）**：在最后一个时间步 $N$，在 $N+1$ 个节点中每个节点的期权价值就是其由收益函数给出的内在价值。设看涨期权 $\\omega = 1$，看跌期权 $\\omega = -1$。节点 $(N,j)$ 的价值 $V_{N,j}$ 为：\n      $$\n      V_{N,j} = \\max(\\omega \\cdot (S_{N,j} - K), 0) \\quad \\text{for } j = 0, 1, \\dots, N\n      $$\n      这些值存储在一个大小为 $N+1$ 的一维数组中。\n\n    - **迭代**：算法从时间步 $i = N-1$ 反向迭代到 0。在每一步 $i$，它计算所有节点 $j \\in \\{0, 1, \\dots, i\\}$ 的期权价值 $V_{i,j}$。\n      - 对于每个节点 $(i,j)$，持续价值 $C_{i,j}$ 是下一时间步期权的贴现期望价值，使用风险中性概率 $p_i$ 计算得出：\n        $$\n        C_{i,j} = D \\cdot [p_i V_{i+1, j+1} + (1-p_i) V_{i+1, j}]\n        $$\n      - 内在价值 $I_{i,j}$ 是在节点 $(i,j)$ 行权时的价值：\n        $$\n        I_{i,j} = \\max(\\omega \\cdot (S_{i,j} - K), 0)\n        $$\n      - 在此节点的美式期权价值是这两个价值的最大值，反映了最优决策：\n        $$\n        V_{i,j} = \\max(I_{i,j}, C_{i,j})\n        $$\n      在实现中，一个代表步骤 $i+1$ 处期权价值的一维数组可以被原地更新，以存储步骤 $i$ 的价值。\n\n    - **最终价值**：该过程在步骤 $i=0$ 处终止。单个值 $V_{0,0}$ 就是时间 $t=0$ 时美式期权的价格。\n\n对每个测试用例实施此过程，以计算所需的期权价格。", "answer": "```python\nimport numpy as np\n\ndef calculate_american_option(S0, K, r, sigma, T, N, option_type, q_params):\n    \"\"\"\n    Computes the value of an American option on a commodity with seasonality.\n\n    Args:\n        S0 (float): Initial spot price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility.\n        T (float): Time to maturity in years.\n        N (int): Number of steps in the binomial tree.\n        option_type (str): 'call' or 'put'.\n        q_params (dict): Parameters for the effective yield q(t).\n                         Keys: 'q0', 'A', 'phi', 's'.\n\n    Returns:\n        float: The price of the American option at time 0.\n    \"\"\"\n    # Unpack parameters for q(t)\n    q0 = q_params['q0']\n    A = q_params['A']\n    phi = q_params['phi']\n    s = q_params['s']\n\n    # Step 1: Discretization and constant parameters\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n    discount_factor = np.exp(-r * dt)\n\n    # Step 2: Initialize option values at maturity (time T)\n    # Omega = 1 for call, -1 for put\n    omega = 1.0 if option_type == 'call' else -1.0\n    \n    # Create a vector for option values. This will be updated at each step.\n    # It stores values at step i+1, and is used to compute values at step i.\n    V = np.zeros(N + 1)\n    \n    # Asset prices at maturity\n    S_T = np.array([(S0 * u**j * d**(N - j)) for j in range(N + 1)])\n    \n    # Option payoff at maturity\n    V[:] = np.maximum(omega * (S_T - K), 0)\n\n    # Step 3: Backward induction\n    for i in range(N - 1, -1, -1):\n        # Calculate time-dependent risk-neutral probability for this step\n        ti = i * dt\n        q_ti = q0 + A * np.cos(2 * np.pi * ti + phi) - s\n        \n        # Risk-neutral probability for transition from t_i to t_{i+1}\n        p_i = (np.exp((r - q_ti) * dt) - d) / (u - d)\n        \n        # Stability check, should hold for reasonable parameters\n        if not (0  p_i  1):\n             # This indicates an arbitrage opportunity or unstable parameters.\n             # The problem parameters are well-behaved, so this is a safeguard.\n             # For some extreme parameters, one might need to adjust u,d,p.\n             # but here it is not necessary.\n             pass\n\n        # Calculate option values at time step i\n        for j in range(i + 1):\n            # Continuation value (if not exercised)\n            continuation_value = discount_factor * (p_i * V[j+1] + (1 - p_i) * V[j])\n            \n            # Stock price at this node (i, j)\n            S_ij = S0 * u**j * d**(i - j)\n            \n            # Intrinsic value (if exercised now)\n            intrinsic_value = np.maximum(omega * (S_ij - K), 0)\n            \n            # American option value is the max of exercising or holding\n            V[j] = np.maximum(intrinsic_value, continuation_value)\n            \n    # The final result is the option value at the root of the tree (t=0)\n    return round(V[0], 6)\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Case 1\n        {'S0': 100.0, 'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.03, 'phi': 0.0, 's': 0.02}},\n        # Case 2\n        {'S0': 80.0, 'K': 100.0, 'r': 0.01, 'sigma': 0.25, 'T': 1/365, 'N': 1, 'option_type': 'put',\n         'q_params': {'q0': 0.0, 'A': 0.02, 'phi': np.pi/2, 's': 0.01}},\n        # Case 3\n        {'S0': 50.0, 'K': 40.0, 'r': 0.0, 'sigma': 0.3, 'T': 0.5, 'N': 300, 'option_type': 'call',\n         'q_params': {'q0': 0.0, 'A': 0.0, 'phi': 0.0, 's': 0.05}},\n        # Case 4\n        {'S0': 100.0, 'K': 90.0, 'r': 0.02, 'sigma': 0.25, 'T': 1.0, 'N': 400, 'option_type': 'put',\n         'q_params': {'q0': 0.07, 'A': 0.02, 'phi': np.pi, 's': 0.02}},\n    ]\n\n    results = []\n    for case in test_cases:\n        price = calculate_american_option(\n            S0=case['S0'],\n            K=case['K'],\n            r=case['r'],\n            sigma=case['sigma'],\n            T=case['T'],\n            N=case['N'],\n            option_type=case['option_type'],\n            q_params=case['q_params']\n        )\n        results.append(price)\n    \n    # Format the final output according to specification\n    print(f\"[{','.join(map(lambda x: f'{x:.6f}', results))}]\")\n\nsolve()\n```", "id": "2420641"}, {"introduction": "在掌握了标准的可重组 (recombining) 二叉树模型后，我们来解决其主要局限之一：恒定波动率的假设。本练习引入了*局部波动率* (local volatility) 的概念，即波动率本身是标的资产价格 $S$ 的函数，表示为 $\\sigma(S)$。这个设定将导致一个*不可重组* (non-recombining) 的二叉树，其中每个节点的后继节点都是独一无二的。这个练习迫使你更深入地理解树的构建和估值算法，因为它无法再依赖可重组格点的简洁结构，是迈向更复杂波动率模型（如随机波动率模型）的重要一步。[@problem_id:2420693]", "problem": "要求您设计并实现一个离散时间二项式模型，用于在瞬时（局部）波动率是股票价格的函数时，为美式看跌期权定价。该模型必须是自洽的，并基于风险中性测度下的无套利定价第一性原理。具体来说，考虑一个风险资产，其当前价格为 $S_0$，行权价为 $K$，连续复利无风险利率为 $r$（以小数形式表示），到期时间为 $T$（以年为单位），以及整数个时间步长 $N$。时间步长为 $\\Delta t = T / N$。不考虑股息。该期权是美式看跌期权，意味着它可以在到期日（含）之前的任何时间步被行权。\n\n基本原理和定义：二项式模型假设，在长度为 $\\Delta t$ 的单个时间步内，从任意一个股票价格为 $S$ 的节点出发，下一个股票价格将取两个值之一：一个“上涨”价格 $S \\cdot u(S)$ 或一个“下跌”价格 $S \\cdot d(S)$，其中 $u(S)  1$ 且 $d(S) = 1/u(S) \\in (0,1)$。无套利风险中性定价原则要求，在风险中性测度下，股票在单个时间步内的预期收益等于 $e^{r \\Delta t}$。因此，在价格为 $S$ 的节点上，上涨的风险中性概率为\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)},\n$$\n下跌的概率为 $1 - p(S)$。在价格为 $S$ 的节点上进行美式提前行权，将产生即时回报 $\\max\\{K - S, 0\\}$；否则，其持续价值是下一步期权价值的折现期望值。\n\n局部波动率设定：在股票价格为 $S$ 的节点上，上涨和下跌因子由局部波动率函数 $\\sigma(S)$ 通过以下公式确定\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)}.\n$$\n为确保正值以及与 $S$ 之间存在一个简单且明确定义的关系，使用以下公式\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right),\n$$\n其中 $\\sigma_{\\min}  0$ 是波动率下限，$\\sigma_0  0$ 是基准波动率水平，$\\beta$ 是一个无量纲的斜率参数。由于 $u(S)$ 和 $d(S)$ 依赖于 $S$，生成的二项树通常不重组。因此，您必须显式地构建完整的非重组二叉树。\n\n算法要求：\n1. 使用局部波动率规则构建具有 $N$ 层的非重组股票价格树，从 $S_0$ 开始，并将每个节点扩展为其特定节点因子 $u(S)$ 和 $d(S)$ 对应的两个子节点。记录每个节点对应的风险中性概率 $p(S)$。\n2. 在到期日（第 $N$ 层），将每个叶节点的期权价值初始化为其内在价值 $\\max\\{K - S, 0\\}$。\n3. 从第 $N-1$ 层到第 $0$ 层执行向后归纳法：在股票价格为 $S$ 的节点上，通过在 $p(S)$ 和 $1 - p(S)$ 的概率下对下一步的期望期权价值进行折现来计算持续价值，并将其与立即行权回报 $\\max\\{K - S, 0\\}$ 的最大值作为该节点的价值。也就是说，在价格为 $S$ 的一般节点上，\n$$\nV(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\cdot \\left(p(S) \\cdot V\\left(S \\cdot u(S)\\right) + (1 - p(S)) \\cdot V\\left(S \\cdot d(S)\\right)\\right)\\right).\n$$\n4. 报告根节点价值 $V(S_0)$，作为该参数集的美式看跌期权价格。\n\n数值现实性和约束：您必须假设 $N$ 足够小，以使显式非重组树在计算上是可行的。所有利率和波动率均以小数形式表示。时间以年为单位。不涉及角度。除了已指定的金融惯例，没有其他物理单位。下面的测试套件选择了科学上合理的参数，这些参数能保证 $0  p(S)  1$ 并确保数值稳定性。如果数值舍入导致概率略微超出 $[0,1]$ 区间，应将其局部地裁剪到 $[0,1]$ 区间内，以避免伪负概率。\n\n测试套件：您的程序必须为以下每个参数集的美式看跌期权定价。在每个元组中，参数按 $(S_0, K, r, T, N, \\sigma_0, \\beta, \\sigma_{\\min})$ 的顺序排列。\n- 案例 1：$(\\$100.0, \\$100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05)$。\n- 案例 2：$(\\$50.0, \\$100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05)$。\n- 案例 3：$(\\$120.0, \\$100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05)$。\n- 案例 4：$(\\$100.0, \\$100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05)$。\n\n要求的最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[x_1,x_2,x_3,x_4]$，其中每个 $x_i$ 是案例 $i$ 计算出的美式看跌期权价格。将每个 $x_i$ 四舍五入到恰好 $6$ 位小数。输出行中不得有多余的空格或其他文本。", "solution": "问题陈述已经过严格验证，并被确定为**有效**。它构成了计算金融领域中一个适定问题，其基础是成熟的无套利衍生品定价第一性原理。所有定义、参数和算法要求都具有足够的清晰度和精确性，足以构建一个唯一且有意义的解决方案。\n\n该问题要求在局部波动率框架下为美式看跌期权定价。这是通过使用离散时间的非重组二项树模型来完成的。解决方案的核心是构建此树，然后应用向后归纳法原理来找到期权的价值。\n\n该模型定义在 $N$ 个离散时间步上，每步的持续时间为 $\\Delta t = T/N$。在树中任何给定的股票价格为 $S$ 的节点上，资产价格在下一个时间步可以上涨到 $S \\cdot u(S)$ 或下跌到 $S \\cdot d(S)$。价格移动因子 $u(S)$ 和 $d(S)$ 是通过局部波动率函数 $\\sigma(S)$ 与股票价格 $S$ 相关的函数：\n$$\nu(S) = e^{\\sigma(S)\\sqrt{\\Delta t}}, \\quad d(S) = \\frac{1}{u(S)} = e^{-\\sigma(S)\\sqrt{\\Delta t}}\n$$\n局部波动率 $\\sigma(S)$ 被指定为股票相对于行权价 $K$ 的价内价外程度的函数：\n$$\n\\sigma(S) = \\max\\left(\\sigma_{\\min}, \\ \\sigma_0 \\cdot \\left(1 + \\beta \\cdot \\left(\\frac{S}{K} - 1\\right)\\right)\\right)\n$$\n这种状态依赖的波动率意味着二项树不重组，因此有必要在每个时间层级 $i$ 显式构建并存储所有 $2^i$ 个节点。\n\n定价是在风险中性测度下进行的。价格上涨的风险中性概率 $p(S)$ 源于无套利条件，该条件规定资产的预期收益必须等于无风险回报率 $e^{r\\Delta t}$。这得出：\n$$\np(S) = \\frac{e^{r \\Delta t} - d(S)}{u(S) - d(S)}\n$$\n相应地，价格下跌的概率是 $1 - p(S)$。问题规范保证了所选参数能使得 $0  p(S)  1$，但同时也建议将计算出的概率裁剪到区间 $[0, 1]$ 以确保数值稳定性。\n\n估值算法通过向后归纳法进行：\n1.  **前向建树**：首先，构建一个完整的股票价格二叉树。从第 $i=0$ 层的初始价格 $S_0$ 开始，我们根据第 $i$ 层的 $2^i$ 个价格，迭代计算第 $i+1$ 层的 $2^{i+1}$ 个后继价格。此过程一直持续到第 $N$ 层，最终得到 $2^N$ 个终端股票价格。\n\n2.  **到期日估值**：在最后的时间步，即第 $N$ 层，每个节点的期权价值由其行权时的内在价值决定：\n    $$\n    V_N(S) = \\max\\{K - S, 0\\}\n    $$\n\n3.  **向后归纳步骤**：然后，算法从第 $i=N-1$ 层向后迭代至第 $i=0$ 层。在每个价格为 $S$ 的节点上，期权价值 $V_i(S)$ 是立即行权价值与持续价值中的较大者。\n    - 立即行权价值为 $\\max\\{K - S, 0\\}$。\n    - 持续价值是在风险中性测度下，下一时间步期权价值的折现期望值：\n      $$\n      \\text{持续价值} = e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1}(S \\cdot u(S)) + (1 - p(S)) \\cdot V_{i+1}(S \\cdot d(S)) \\right]\n      $$\n      此处，$V_{i+1}(\\cdot)$ 是已计算出的下一层的已知期权价值。\n    - 因此，期权价值为：\n      $$\n      V_i(S) = \\max\\left(\\max\\{K - S, 0\\}, \\ e^{-r\\Delta t} \\left[ p(S) \\cdot V_{i+1,u} + (1 - p(S)) \\cdot V_{i+1,d} \\right] \\right)\n      $$\n\n4.  **期权价格**：此向后迭代在第 $i=0$ 层结束，该层只包含价格为 $S_0$ 的根节点。为此节点计算出的价值 $V_0(S_0)$ 即为美式看跌期权的价格。实现将逐层执行此过程，以计算给定测试用例的价格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Parameters are ordered as: (S0, K, r, T, N, sigma0, beta, sigma_min)\n    test_cases = [\n        (100.0, 100.0, 0.05, 1.0, 10, 0.20, 0.40, 0.05),\n        (50.0, 100.0, 0.02, 1.0, 12, 0.25, -0.60, 0.05),\n        (120.0, 100.0, 0.00, 0.25, 8, 0.15, 0.00, 0.05),\n        (100.0, 100.0, 0.10, 0.5, 1, 0.30, 1.00, 0.05),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = price_american_put_non_recombining(*case)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\ndef price_american_put_non_recombining(S0, K, r, T, N, sigma0, beta, sigma_min):\n    \"\"\"\n    Prices an American put option using a non-recombining binomial tree\n    with local volatility.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (decimal).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps.\n        sigma0 (float): Baseline volatility.\n        beta (float): Volatility slope parameter.\n        sigma_min (float): Volatility floor.\n\n    Returns:\n        float: The calculated price of the American put option.\n    \"\"\"\n    dt = T / N\n    discount_factor = np.exp(-r * dt)\n    exp_rdt = np.exp(r * dt)\n    sqrt_dt = np.sqrt(dt)\n\n    def get_sigma(S):\n        \"\"\"Calculates local volatility for a given stock price S.\"\"\"\n        return np.maximum(sigma_min, sigma0 * (1.0 + beta * (S / K - 1.0)))\n\n    # Step 1: Forward Pass - Build the stock price tree\n    # stock_tree[i] stores the list of stock prices at level i.\n    stock_tree = [[S0]]\n    for i in range(N):\n        prices_at_next_level = []\n        for S in stock_tree[i]:\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            prices_at_next_level.append(S * u)\n            prices_at_next_level.append(S / u) # d = 1/u\n        stock_tree.append(prices_at_next_level)\n\n    # Step 2: Backward Pass - Calculate option values\n    # Initialize option values at maturity (level N).\n    option_values = [np.maximum(K - s, 0.0) for s in stock_tree[N]]\n    \n    # Iterate backwards from level N-1 down to 0.\n    for i in range(N - 1, -1, -1):\n        option_values_at_this_level = []\n        for j in range(len(stock_tree[i])):\n            S = stock_tree[i][j]\n            \n            # Option values from the successor nodes.\n            V_u = option_values[2 * j]\n            V_d = option_values[2 * j + 1]\n            \n            # Calculate node-specific parameters.\n            sigma_S = get_sigma(S)\n            u = np.exp(sigma_S * sqrt_dt)\n            d = 1.0 / u\n            \n            # Risk-neutral probability. Since sigma_S is guaranteed to be positive,\n            # u > d, so no division by zero will occur.\n            p = (exp_rdt - d) / (u - d)\n\n            # Clip probability to [0, 1] for numerical stability as per instructions.\n            p = np.maximum(0.0, np.minimum(1.0, p))\n\n            # Continuation value (value of holding the option).\n            continuation_value = discount_factor * (p * V_u + (1.0 - p) * V_d)\n            \n            # Exercise value (value of exercising the option now).\n            exercise_value = np.maximum(K - S, 0.0)\n            \n            # Option value is the maximum of holding vs. exercising.\n            node_value = np.maximum(continuation_value, exercise_value)\n            option_values_at_this_level.append(node_value)\n        \n        option_values = option_values_at_this_level\n            \n    # The final price is the single value at the root of the tree (level 0).\n    return option_values[0]\n\nsolve()\n```", "id": "2420693"}, {"introduction": "现在，让我们从离散时间的格点模型转向连续时间的偏微分方程 (Partial Differential Equations, PDE) 世界。本练习从 Black-Scholes-Merton 框架及其对美式期权的扩展出发，该扩展问题最终表现为一个偏微分*不等式* (partial differential inequality)，也称为自由边界问题。我们将使用有限差分法 (Finite Difference Method, FDM) 来离散化这个连续问题，并进行数值求解。这项实践不仅连接了金融理论 (PDE) 与数值实现，还引入了*数值稳定性*这一至关重要的概念，这是任何显式 FDM 方案都必须考虑的核心问题。[@problem_id:2420683]", "problem": "考虑一个不支付股息的标的资产，其现货价格 $S(t)$ 在风险中性测度下遵循几何布朗运动。另有一个行权价为 $K$、到期日为 $T$ 的美式看跌期权。从基本的无套利原理和一个自融资复制投资组合的存在性出发，推导出描述美式期权无套利价值函数 $V(S,t)$ 的变分不等式。您的推导必须明确说明扩散项和漂移项的微分算子、时间演化以及提前行权（障碍）约束，以及连接它们的互补松弛结构。然后，将空间变量转换为对数价格 $x = \\ln S$，并用函数 $u(x,t) = V(e^{x},t)$ 来表示该不等式，详细说明转换后算子中新的漂移和扩散系数。\n\n接下来，在对数价格变量 $x$ 中设计一个显式有限差分方法，通过从到期日向后演化来数值计算美式看跌期权价格。在空间上使用中心差分，在时间上使用前向欧拉法（在日历时间上向后，从 $t=T$ 开始，步进到 $t=0$），并在每个时间步通过投影到障碍上来施加提前行权特性。指定并实现在金融上对于不支付股息标的资产上的美式看跌期权有意义的、在 $x$ 上的无通量相容的狄利克雷边界条件。\n\n对于稳定性分析，考虑在均匀对数价格网格上的显式格式，其空间步长为 $\\Delta x$，时间步长为 $\\Delta t$。陈述一个关于 $\\Delta t$ 的、以 $\\Delta x$ 和波动率 $\\sigma$ 表示的扩散主导的充分稳定性条件，该条件确保使用中心空间差分的显式格式的数值稳定性，并解释为什么违反此条件会导致伪震荡或数值爆炸。\n\n您的程序必须实现上述方法并运行以下测试套件。对于所有测试，除非另有说明，否则使用相同的空间域和网格：\n- 所有测试的通用设置：\n    - 期权类型：美式看跌期权。\n    - 股息率：$q = 0$。\n    - 价格空间域：$S_{\\min} = 10^{-4}$ 和 $S_{\\max} = 5K$。\n    - 对数价格域：$x_{\\min} = \\ln S_{\\min}$ 和 $x_{\\max} = \\ln S_{\\max}$。\n    - 空间区间数：$M = 400$ (因此 $\\Delta x = (x_{\\max} - x_{\\min})/M$)。\n    - 对所有 $t \\in [0,T]$ 的边界条件：$V(S_{\\min},t) = K$ 和 $V(S_{\\max},t) = 0$。\n    - 在 $t = T$ 时的终端回报：$V(S,T) = \\max(K - S, 0)$。\n    - 每个时间步的美式约束：$V(S,t) \\leftarrow \\max(V(S,t), \\max(K - S, 0))$。\n    - 采用空间中心差分的对数空间显式格式。\n\n- 用于稳定性分析的时间步长选择规则定义：\n    - 设基于扩散的充分条件为 $\\Delta t \\le \\Delta x^{2}/\\sigma^{2}$。定义界限 $B = \\Delta x^{2}/\\sigma^{2}$。\n    - 对于给定的界限 $B$ 和到期日 $T$，定义：\n        - 一个稳定的时间步数 $N_{\\text{stable}} = \\left\\lceil \\dfrac{T}{0.9 B} \\right\\rceil$，使得 $\\Delta t_{\\text{stable}} = T/N_{\\text{stable}} \\le 0.9 B$。\n        - 一个不稳定的时间步数 $N_{\\text{unstable}} = \\max\\left(1, \\left\\lfloor \\dfrac{T}{1.1 B} \\right\\rfloor \\right)$，使得 $\\Delta t_{\\text{unstable}} = T/N_{\\text{unstable}} \\ge 1.1 B$。\n\n- 测试案例：\n    1. 正常路径稳定性案例：\n        - 参数：$K = 100$，$r = 0.05$，$\\sigma = 0.2$，$T = 1.0$，$S_{0} = 100$。\n        - 使用 $N_{\\text{stable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n\n    2. 违反稳定性案例：\n        - 参数与测试1相同。\n        - 使用 $N_{\\text{unstable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n        - 同时报告是否违反了稳定性界限，即 $\\Delta t_{\\text{unstable}} > B$ 是否成立。\n\n    3. 接近边界的资产价格案例：\n        - 参数：$K = 100$，$r = 0.05$，$\\sigma = 0.2$，$T = 1.0$，$S_{0} = 1$。\n        - 使用 $N_{\\text{stable}}$ 并计算在 $S_{0}$ 处的美式看跌期权价格。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按以下顺序排列：\n- 第一个条目：测试1计算出的价格（浮点数）。\n- 第二个条目：测试2计算出的价格（浮点数）。\n- 第三个条目：测试2的违规指示符，如果 $\\Delta t_{\\text{unstable}} > B$ 则为 $1$，否则为 $0$（整数）。\n- 第四个条目：测试3计算出的价格（浮点数）。\n\n无需外部输入，也不涉及任何角度或物理单位。所有数值输出均表示为普通十进制数。代码必须是一个完整的、可运行的程序，遵循指定的算法并以要求的格式准确输出一行。", "solution": "该问题要求推导美式期权的控制变分不等式，将其变换到对数价格坐标系，设计一个用于其数值解的显式有限差分格式，并对所提出的格式进行稳定性分析。这些工作应在实现该方法以在几种情景下为美式看跌期权定价之前完成。\n\n首先，我们推导美式期权价值 $V(S,t)$ 所遵循的变分不等式。该期权基于一种不付股息的股票，其价格 $S(t)$ 在风险中性测度下遵循几何布朗运动 $dS = rS dt + \\sigma S dW_t$，其中 $r$ 是无风险利率，$\\sigma$ 是波动率。我们构建一个投资组合，卖空一份期权并持有 $\\Delta$ 单位的标的资产。该投资组合的价值为 $\\Pi = -V + \\Delta S$。其价值变化为 $d\\Pi = -dV + \\Delta dS$。根据伊藤引理(Itô's lemma)，期权价值的变化为 $dV = \\frac{\\partial V}{\\partial t}dt + \\frac{\\partial V}{\\partial S}dS + \\frac{1}{2}\\frac{\\partial^2 V}{\\partial S^2}(dS)^2$。代入 $dS$ 和 $(dS)^2 = \\sigma^2 S^2 dt$，我们得到 $dV = (\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt + \\sigma S \\frac{\\partial V}{\\partial S}dW_t$。为了消除投资组合的风险，我们选择 $\\Delta = \\frac{\\partial V}{\\partial S}$（Delta对冲）。投资组合价值的变化变为纯粹的确定性：$d\\Pi = -(\\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2})dt$。这个无风险投资组合的回报不能提供套利机会。在期权未被行权的区域（持有区域），投资组合必须恰好赚取无风险利率，即 $d\\Pi = r\\Pi dt = r(-V + S\\frac{\\partial V}{\\partial S})dt$。令两种 $d\\Pi$ 的表达式相等，得到布莱克-斯科尔斯(Black-Scholes)偏微分方程(PDE)：$\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV = 0$。\n\n对于美式期权，持有者有权在任何时间 $t \\in [0,T]$ 行权。这带来了两个关键条件。首先，期权的价值永远不能低于其立即行权的内在价值 $P(S,t)$，对于看跌期权，该价值为 $\\max(K-S, 0)$。这是障碍约束：$V(S,t) \\ge P(S)$。其次，在持有区域 $V(S,t)  P(S)$，期权被持有，其价值根据布莱克-斯科尔斯偏微分方程演化。然而，由于有提前行权的权利，一个卖空美式期权的投资组合的回报必须不高于无风险利率，这防止了买方进行套利。这意味着对冲组合的价值变化 $d\\Pi$ 小于或等于无风险回报 $r\\Pi dt$。这导致不等式：$\\frac{\\partial V}{\\partial t} + rS\\frac{\\partial V}{\\partial S} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} - rV \\le 0$。该不等式在定义域 $(S,t) \\in (0, \\infty) \\times [0, T)$ 内处处成立。\n\n这些条件构成一个互补松弛问题，它是一种变分不等式。该问题总结如下：\n$1.$ 障碍约束: $V(S,t) \\ge \\max(K-S, 0)$。\n$2.$ PDE不等式: $\\mathcal{L}V \\equiv \\frac{\\partial V}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2 V}{\\partial S^2} + rS\\frac{\\partial V}{\\partial S} - rV \\le 0$。\n$3.$ 互补松弛性: $(V(S,t) - \\max(K-S, 0)) \\times (\\mathcal{L}V) = 0$。\n这意味着在持有区域 $V  P(S)$，必须有 $\\mathcal{L}V=0$。在行权区域 $V=P(S)$，必须有 $\\mathcal{L}V \\le 0$。漂移和扩散的微分算子是 $\\frac{1}{2}\\sigma^2 S^2 \\frac{\\partial^2}{\\partial S^2} + rS\\frac{\\partial}{\\partial S}$。\n\n接下来，我们将问题转换到对数价格坐标系，令 $x = \\ln S$，因此 $S = e^x$。设 $u(x,t) = V(e^x, t)$。导数变换如下：\n$\\frac{\\partial V}{\\partial t} = \\frac{\\partial u}{\\partial t}$\n$\\frac{\\partial V}{\\partial S} = \\frac{\\partial u}{\\partial x} \\frac{\\partial x}{\\partial S} = \\frac{1}{S}\\frac{\\partial u}{\\partial x}$\n$\\frac{\\partial^2 V}{\\partial S^2} = \\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})$\n将这些代入不等式 $\\mathcal{L}V \\le 0$ 得到：\n$\\frac{\\partial u}{\\partial t} + \\frac{1}{2}\\sigma^2 S^2 \\left(\\frac{1}{S^2}(\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial u}{\\partial x})\\right) + rS \\left(\\frac{1}{S}\\frac{\\partial u}{\\partial x}\\right) - ru \\le 0$\n化简并组合各项，得到具有常系数的变换不等式：\n$\\frac{\\partial u}{\\partial t} + (r - \\frac{1}{2}\\sigma^2) \\frac{\\partial u}{\\partial x} + \\frac{1}{2}\\sigma^2 \\frac{\\partial^2 u}{\\partial x^2} - ru \\le 0$\n新的漂移系数是 $(r - \\frac{1}{2}\\sigma^2)$，新的扩散系数是 $\\frac{1}{2}\\sigma^2$。障碍约束变为 $u(x,t) \\ge \\max(K-e^x, 0)$。\n\n为了数值求解，我们设计一个显式有限差分法。我们用均匀网格对 $(x,t)$ 域进行离散化：$x_j = x_{\\min} + j\\Delta x$ for $j=0, \\dots, M$ 和 $t_n = T - n\\Delta t$ for $n=0, \\dots, N$。令 $u_j^n \\approx u(x_j, t_n)$。我们从已知的终端条件 $u(x,T) = \\max(K-e^x, 0)$ 开始在时间上向后求解。\n时间导数用后向时间的向前差分近似：$\\frac{\\partial u}{\\partial t} \\approx \\frac{u(t_n) - u(t_{n+1})}{\\Delta t} = \\frac{u_j^n - u_j^{n+1}}{\\Delta t}$。\n空间导数用时间层 $n$ 上的中心差分近似：\n$\\frac{\\partial u}{\\partial x} \\approx \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x}$\n$\\frac{\\partial^2 u}{\\partial x^2} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}$\n将这些代入PDE（暂时忽略不等式）得到一个关于 $u_j^{n+1}$（前一个时间步 $t_{n+1} = t_n - \\Delta t$ 的值）的显式更新规则：\n$u_j^{n+1} = u_j^n - \\Delta t \\left[ (r - \\frac{1}{2}\\sigma^2) \\frac{u_{j+1}^n - u_{j-1}^n}{2\\Delta x} + \\frac{1}{2}\\sigma^2 \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2} - ru_j^n \\right]$\n这可以写成 $u_j^{n+1} = a u_{j-1}^n + b u_j^n + c u_{j+1}^n$，其中：\n$a = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} - \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right)$\n$c = \\Delta t \\left( \\frac{\\sigma^2}{2(\\Delta x)^2} + \\frac{r - \\sigma^2/2}{2\\Delta x} \\right)$\n在计算出这个基于PDE的值之后，我们必须施加美式提前行权约束：\n$u_j^{n+1} \\leftarrow \\max(u_j^{n+1}, \\max(K-e^{x_j}, 0))$\n\n问题指定了狄利克雷(Dirichlet)边界条件：$V(S_{\\min},t) = K$ 和 $V(S_{\\max},t) = 0$。这些在金融上是有意义的。当 $S \\to S_{\\max}$ 时，看跌期权的价值趋近于 $0$。当 $S \\to S_{\\min}$（非常小）时，看跌期权是深度价内期权。对于不付股息的股票，提前行使美式看跌期权通常是最佳选择。其价值为 $K-S$。对于一个非常小的 $S_{\\min}$，$K-S_{\\min} \\approx K$。因此，所提供的边界条件是合理的近似。在对数空间中，这些条件是 $u(x_{\\min},t) = K$ 和 $u(x_{\\max},t)=0$。这些条件在每个时间步应用。\n\n对于显式格式的稳定性，更新规则中的所有系数 $a,b,c$ 必须非负。最严格的条件通常来自系数 $b$：\n$b = 1 - \\Delta t \\left( \\frac{\\sigma^2}{(\\Delta x)^2} + r \\right) \\ge 0 \\implies \\Delta t \\le \\frac{1}{\\frac{\\sigma^2}{(\\Delta x)^2} + r}$\n一个更简单、充分且此处要求的条件只考虑扩散项，因为它是最高阶导数，对不稳定性最敏感。这导致扩散主导的稳定性条件：\n$\\Delta t \\le \\frac{(\\Delta x)^2}{\\sigma^2}$\n违反这个条件会使系数 $b$ 变为负值。当 $b  0$ 时，一个正值 $u_j^n$ 会对更新后的值 $u_j^{n+1}$ 产生负贡献。这会在解中引起虚假的、非物理的振荡，随着计算在时间上向后进行，其幅度可能会增长。如果严重违反该条件，系数的绝对值之和可能超过 $1$，导致数值爆炸，解会无界增长。", "answer": "```python\nimport numpy as np\nimport math\n\ndef price_american_put_fdm(K, r, sigma, T, S0, M, S_min_val, S_max_factor, N):\n    \"\"\"\n    Computes the American put option price using an explicit finite difference method.\n\n    Args:\n        K (float): Strike price.\n        r (float): Risk-free interest rate.\n        sigma (float): Volatility of the underlying asset.\n        T (float): Time to maturity.\n        S0 (float): Initial stock price.\n        M (int): Number of spatial intervals.\n        S_min_val (float): Minimum value for the price domain S.\n        S_max_factor (float): Factor to determine S_max = S_max_factor * K.\n        N (int): Number of time steps.\n\n    Returns:\n        float: The price of the American put option at S0 and t=0.\n    \"\"\"\n    # 1. Setup grid\n    S_max = S_max_factor * K\n    x_min, x_max = np.log(S_min_val), np.log(S_max)\n    dx = (x_max - x_min) / M\n    dt = T / N\n\n    x_grid = np.linspace(x_min, x_max, M + 1)\n    S_grid = np.exp(x_grid)\n\n    # 2. Initial condition at maturity T (n=0)\n    V = np.maximum(K - S_grid, 0)\n\n    # 3. FDM coefficients\n    nu = r - 0.5 * sigma**2\n    \n    # Coefficients for the explicit scheme u_j^{n+1} = a*u_{j-1}^n + b*u_j^n + c*u_{j+1}^n\n    # Note: we are calculating V at previous time step (n+1 in backward time) from current (n)\n    a = dt * (0.5 * sigma**2 / dx**2 - nu / (2 * dx))\n    b = 1 - dt * (sigma**2 / dx**2 + r)\n    c = dt * (0.5 * sigma**2 / dx**2 + nu / (2 * dx))\n\n    # 4. Time-stepping loop (from T back to 0)\n    for _ in range(N):\n        V_old = V.copy()\n        \n        # Update interior points using the PDE\n        V[1:-1] = a * V_old[:-2] + b * V_old[1:-1] + c * V_old[2:]\n\n        # Apply boundary conditions\n        V[0] = K  # V(S_min, t) = K\n        V[-1] = 0 # V(S_max, t) = 0\n        \n        # Apply American option early exercise constraint\n        payoff = np.maximum(K - S_grid, 0)\n        V = np.maximum(V, payoff)\n\n    # 5. Interpolate to find price at S0\n    price_at_t0 = np.interp(S0, S_grid, V)\n    \n    return price_at_t0\n\ndef solve():\n    \"\"\"\n    Main solver function that runs the test suite.\n    \"\"\"\n    # Common settings from the problem statement\n    M = 400\n    S_min_val = 1e-4\n    S_max_factor = 5.0\n    \n    test_cases = [\n        # Test 1: Happy-path stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'stable'},\n        # Test 2: Violated stability case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 100.0, 'case_type': 'unstable'},\n        # Test 3: Near-boundary asset price case\n        {'K': 100.0, 'r': 0.05, 'sigma': 0.2, 'T': 1.0, 'S0': 1.0, 'case_type': 'stable'}\n    ]\n\n    results = []\n\n    # Calculate stability parameters (only depends on K, sigma, M) for the first two tests\n    params1 = test_cases[0]\n    K1, sigma1, T1 = params1['K'], params1['sigma'], params1['T']\n    \n    S_max1 = S_max_factor * K1\n    x_min1 = np.log(S_min_val)\n    x_max1 = np.log(S_max1)\n    dx1 = (x_max1 - x_min1) / M\n    \n    # Diffusion-based stability bound B\n    B = dx1**2 / sigma1**2\n    \n    # Time step counts\n    N_stable = int(math.ceil(T1 / (0.9 * B)))\n    N_unstable = int(max(1, math.floor(T1 / (1.1 * B))))\n\n    # --- Test Case 1 ---\n    price1 = price_american_put_fdm(\n        K=params1['K'], r=params1['r'], sigma=params1['sigma'], T=params1['T'], S0=params1['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price1)\n    \n    # --- Test Case 2 ---\n    params2 = test_cases[1]\n    price2 = price_american_put_fdm(\n        K=params2['K'], r=params2['r'], sigma=params2['sigma'], T=params2['T'], S0=params2['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_unstable\n    )\n    results.append(price2)\n    \n    dt_unstable = params2['T'] / N_unstable\n    violation_indicator = 1 if dt_unstable > B else 0\n    results.append(violation_indicator)\n\n    # --- Test Case 3 ---\n    params3 = test_cases[2]\n    # Reuse N_stable as per problem description\n    price3 = price_american_put_fdm(\n        K=params3['K'], r=params3['r'], sigma=params3['sigma'], T=params3['T'], S0=params3['S0'],\n        M=M, S_min_val=S_min_val, S_max_factor=S_max_factor, N=N_stable\n    )\n    results.append(price3)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2420683"}]}