{"hands_on_practices": [{"introduction": "时间序列建模的第一步是识别一个合适的模型结构。自相关函数 (ACF) 和偏自相关函数 (PACF) 是完成此任务的主要工具。本练习旨在训练你如何解读这些函数的典型“特征”，从而选择恰当的 ARMA 模型阶数 ([@problem_id:1897449])。这是 Box-Jenkins 方法论中的一项基础技能。", "problem": "一位分析师正在研究一个平稳时间序列，该序列代表了某种商品的每周价格变化。为了选择一个合适的预测模型，他们根据数据计算了样本自相关函数 (ACF) 和样本偏自相关函数 (PACF)。\n\n分析揭示了以下两个关键特征：\n1.  样本ACF图显示，在许多滞后阶数上，其值都具有统计显著性，并以一种缓慢的几何（类指数）模式向零衰减。\n2.  样本PACF图显示，在滞后1阶处有一个单一的、突出的、统计上显著的尖峰。所有滞后大于1阶的后续偏自相关系数在统计上都不显著，并且都落在零附近的置信区间内。\n\n基于对ACF和PACF的这些经验观察，请为该时间序列确定最合适的自回归移动平均模型，记为ARMA(p,q)。其中整数 `p` 代表自回归部分的阶数，整数 `q` 代表移动平均部分的阶数。\n\n下列哪个模型是最合适的选择？\n\nA. ARMA(0, 1)\n\nB. ARMA(2, 0)\n\nC. ARMA(0, 2)\n\nD. ARMA(1, 1)\n\nE. ARMA(1, 0)", "solution": "从样本ACF和PACF图中识别合适的ARMA(p,q)模型的过程，依赖于这些函数对于不同类型模型的理论性质。我们需要将观察到的模式与AR、MA和ARMA过程的理论特征进行匹配。\n\n我们来总结一下基本模型的理论行为：\n- **p阶自回归模型，AR(p) 或 ARMA(p,0)：**\n    - ACF呈拖尾性，以指数方式或阻尼正弦波模式衰减。\n    - PACF在滞后 p 阶后截尾。这意味着对于滞后 $k \\leq p$，偏自相关系数非零；对于滞后 $k  p$，偏自相关系数为零。\n- **q阶移动平均模型，MA(q) 或 ARMA(0,q)：**\n    - ACF在滞后 q 阶后截尾。这意味着对于滞后 $k \\leq q$，自相关系数非零；对于滞后 $k  q$，自相关系数为零。\n    - PACF呈拖尾性，以指数方式或阻尼正弦波模式衰减。\n- **混合自回归移动平均模型，ARMA(p,q)（其中 $p0$ 且 $q0$）：**\n    - ACF和PACF均呈拖尾性。\n\n现在，我们来分析问题陈述中描述的特征。\n\n1.  **PACF分析：** 问题陈述指出，样本PACF在滞后1阶处有一个单一的、统计上显著的尖峰，并在此后立即截尾。这种“截尾”行为是自回归过程的决定性特征。截尾发生在滞后1阶之后，表明自回归部分的阶数是 $p=1$。这强烈暗示了一个AR(1)模型。\n\n2.  **ACF分析：** 问题陈述指出，样本ACF呈指数衰减。这种“拖尾”行为与AR(1)过程一致。一个具有正系数的AR(1)过程，其ACF会呈指数衰减。这一观察结果与纯MA模型不一致，因为纯MA模型的ACF会突然截尾。\n\n3.  **综合分析：**\n    - PACF在滞后1阶截尾，是 $p=1$ 的明确指标。\n    - ACF呈拖尾性，与 $p=1$ 一致。\n    - 纯MA模型（如MA(1)或MA(2)）被排除，因为观察到的ACF是拖尾而非截尾。\n    - 混合ARMA(1,1)模型通常ACF和PACF都呈拖尾性，这与观察到的PACF急剧截尾相矛盾。\n    - AR(2)模型的PACF应在滞后2阶后截尾，而不是1阶。\n\n综合以上各点，证据压倒性地支持一个包含一个自回归项和零个移动平均项的模型。因此，最合适的模型是AR(1)过程，它等同于ARMA(1,0)模型。\n\n回顾这些选项：\nA. ARMA(0, 1) 是一个MA(1)模型。排除，因为ACF是拖尾的。\nB. ARMA(2, 0) 是一个AR(2)模型。排除，因为PACF在滞后1阶截尾，而不是2阶。\nC. ARMA(0, 2) 是一个MA(2)模型。排除，因为ACF是拖尾的。\nD. ARMA(1, 1) 是一个混合模型。排除，因为PACF是截尾的，而不是拖尾的。\nE. ARMA(1, 0) 是一个AR(1)模型。这完美地匹配了ACF呈指数衰减且PACF在滞后1阶后截尾的描述。\n\n因此，正确的选择是ARMA(1,0)。", "answer": "$$\\boxed{E}$$", "id": "1897449"}, {"introduction": "在识别并估计模型之后，下一个关键步骤是诊断性检验。本练习探讨了一个实践中常见的问题：模型过度参数化。通过分析一个特定的估计结果，你将学会识别模型冗余的迹象，并理解为何简约性原则对于构建稳健的模型至关重要 ([@problem_id:2378231])。", "problem": "您正在使用 Box–Jenkins 方法对金融时间序列中的季度超额收益进行建模。假设您对一个去均值化的序列 $\\{y_t\\}$ 拟合了一个阶数为 $\\left(1,1\\right)$ 的自回归移动平均（ARMA）模型，其形式如下\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1},\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为零、方差为 $\\sigma^2$ 的白噪声序列，$\\phi$ 是自回归系数，$\\theta$ 是移动平均系数。您的估计值满足 $\\hat{\\phi} \\approx \\hat{\\theta}$，并且两者在常规水平上都具有统计显著性。\n\n在 Box–Jenkins 框架内，以下哪项是最恰当的解释？\n\nA. $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 的近似相等表明自回归和移动平均动态几乎相互抵消，因此该过程的行为接近白噪声；模型可能过度参数化，并且如果之前应用了差分，则序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。\n\nB. 这些估计值为 $y_t$ 中存在单位根提供了强有力的证据，因此您应该对序列再进行一次差分，并以 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。\n\nC. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 相近且具有统计显著性，所以该模型必然违反平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。\n\nD. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后阶数上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。", "solution": "此问题要求在 Box–Jenkins 方法的背景下，对自回归移动平均（ARMA）模型的一个特定估计结果进行解释。该问题陈述是有效的，因为它在科学上基于时间序列计量经济学的既定原则，问题本身是适定的，并使用了客观、精确的语言。\n\n我们必须分析所提供的阶数为 $(1,1)$ 的 ARMA 模型，该模型是为一个去均值化的时间序列 $\\{y_t\\}$ 指定的：\n$$\ny_t \\;=\\; \\phi\\, y_{t-1} \\;+\\; \\varepsilon_t \\;-\\; \\theta\\, \\varepsilon_{t-1}\n$$\n此处，$\\{\\varepsilon_t\\}$ 表示一个均值为 $0$、方差为 $\\sigma^2$ 的白噪声过程。估计的关键发现是自回归系数的估计值 $\\hat{\\phi}$ 近似等于移动平均系数的估计值 $\\hat{\\theta}$，即 $\\hat{\\phi} \\approx \\hat{\\theta}$。\n\n为了理解这一结果的含义，我们使用滞后算子 $B$，其定义为 $B^k z_t = z_{t-k}$。ARMA($1,1$) 模型方程可以重写为：\n$$\ny_t - \\phi B y_t = \\varepsilon_t - \\theta B \\varepsilon_t\n$$\n将 $y_t$ 和 $\\varepsilon_t$ 因子提出，我们得到多项式表示：\n$$\n(1 - \\phi B) y_t = (1 - \\theta B) \\varepsilon_t\n$$\n条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 意味着自回归多项式 $\\Phi(B) = 1 - \\phi B$ 和移动平均多项式 $\\Theta(B) = 1 - \\theta B$ 几乎相同。如果 $\\phi$ 完全等于 $\\theta$，方程将变为：\n$$\n(1 - \\phi B) y_t = (1 - \\phi B) \\varepsilon_t\n$$\n对于一个平稳且可逆的过程，我们必须有 $|\\phi|  1$ 和 $|\\theta|  1$。在平稳性条件 $|\\phi|  1$ 下，算子 $(1 - \\phi B)$ 是可逆的。因此，原则上我们可以从方程两侧消去这个公因子，从而得到：\n$$\ny_t = \\varepsilon_t\n$$\n这个结果方程描述了一个白噪声过程。因此，条件 $\\hat{\\phi} \\approx \\hat{\\theta}$ 强烈暗示自回归和移动平均部分相互抵消，且过程 $\\{y_t\\}$ 是白噪声或非常接近白噪声。\n\n用 ARMA($1,1$) 模型来建模一个白噪声过程是**过度参数化**的一个例子。Box–Jenkins 方法强调**简约原则**，该原则要求应选择能够对数据提供充分描述的最简单的模型。一个 ARMA($0,0$) 模型（即白噪声）比一个 ARMA($1,1$) 模型更简约。$\\hat{\\phi} \\approx \\hat{\\theta}$ 的发现是一个经典的诊断信号，表明模型可能过度参数化，应当被简化。\n\n此外，这种类型的参数冗余是**过度差分**的一个已知症状。如果对一个平稳序列进行差分，会将其单位根引入其移动平均部分。例如，如果原始序列已经是平稳的，比如 $z_t = \\eta_t$，其中 $\\eta_t$ 是白噪声，而我们错误地进行一阶差分得到 $y_t = z_t - z_{t-1} = \\eta_t - \\eta_{t-1}$，那么所得到的过程 $y_t$ 是一个 $\\theta=1$ 的不可逆 MA($1$) 过程。当对这样的序列拟合 ARMA($1,1$) 模型时，估计量通常会产生彼此接近且接近单位根的系数 $\\hat{\\phi}$ 和 $\\hat{\\theta}$（即 $\\hat{\\phi} \\approx \\hat{\\theta} \\approx 1$），因为 AR 部分试图抵消由差分引入的 MA 单位根。因此，如果 $y_t$ 是通过对另一个序列进行差分得到的，那么参数冗余就是一个强有力的指标，表明差分操作是不必要的。\n\n现在我们基于此分析评估给出的选项。\n\n**A. $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 的近似相等表明自回归和移动平均动态几乎相互抵消，因此该过程的行为接近白噪声；模型可能过度参数化，并且如果之前应用了差分，则序列可能被过度差分。应考虑简化为 AR$\\left(1\\right)$ 或 MA$\\left(1\\right)$ 模型，或使用更低阶的差分。**\n这个陈述是对情况的精确而完整的描述。它正确地指出了动态的抵消、过程接近白噪声的含义、过度参数化的问题，以及与过度差分的潜在联系。建议的措施——将模型简化为 AR($1$)、MA($1$)，甚至 ARMA($0,0$)，或降低差分阶数——是根据 Box–Jenkins 方法论的标准且正确的补救措施。\n结论：**正确**。\n\n**B. 这些估计值为 $y_t$ 中存在单位根提供了强有力的证据，因此您应该对序列再进行一次差分，并以 $d \\leftarrow d + 1$ 重新拟合一个 ARIMA 模型。**\n这种解释是不正确的。$y_t$ 过程中的单位根将由自回归多项式 $(1-\\phi B)$ 中的 $\\phi=1$ 来表征。$\\hat{\\phi} \\approx \\hat{\\theta}$ 这个条件本身并不意味着 $\\hat{\\phi} \\approx 1$。相反，它表明了冗余。对序列再进行一次差分是错误的做法，因为证据指向的是可能存在的过度差分，而不是差分不足。进一步差分会加剧问题。\n结论：**不正确**。\n\n**C. 因为 $\\hat{\\phi}$ 和 $\\hat{\\theta}$ 相近且具有统计显著性，所以该模型必然违反平稳性或可逆性，意味着 $|\\phi| \\ge 1$ 或 $|\\theta| \\ge 1$。**\n这个陈述做出了一个错误的必然性主张。完全有可能在 $\\hat{\\phi} \\approx \\hat{\\theta}$ 的同时，两个系数都远在单位圆内（例如，$\\hat{\\phi}=0.4$ 和 $\\hat{\\theta}=0.41$）。在这种情况下，估计出的模型既是平稳的也是可逆的。问题在于参数冗余，而不一定是平稳性或可逆性的问题，尽管如果发生了过度差分，冗余也可能出现在边界附近。“必然”这个词使得这个陈述绝对是错误的。\n结论：**不正确**。\n\n**D. $\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式主要表明存在未建模的季节性；您应该在季节性滞后阶数上添加阶数为 $\\left(1,1\\right)$ 的季节性自回归和移动平均项。**\n这是一个错误的归因。在 Box-Jenkins 框架中，未建模季节性的主要信号是在非季节性模型的残差中，在季节性滞后阶数（例如，对于季度数据，滞后阶数为 $4, 8, 12, \\dots$）上存在显著的自相关。$\\hat{\\phi} \\approx \\hat{\\theta}$ 的模式是 AR 和 MA 多项式之间存在公因子的典型标志，表明存在过度参数化或过度差分。它不是季节性的信号。\n结论：**不正确**。\n\n基于严谨的分析，选项 A 在 Box-Jenkins 框架内为给定的估计结果提供了唯一正确且全面的解释。", "answer": "$$\\boxed{A}$$", "id": "2378231"}, {"introduction": "建立 ARMA 模型的一个核心目标是理解其所代表系统的动态行为。脉冲响应函数 (IRF) 是一个强大的分析工具，它揭示了系统对一个冲击随时间的反应路径。这项计算练习要求你将理论上的 ARMA 方程转化为计算 IRF 的算法，从而架起理论与实际应用之间的桥梁 ([@problem_id:2372460])。", "problem": "给定一个离散时间自回归移动平均（ARMA）过程，该过程在计算经济学和金融学中用于对收益、消费增长或其他宏观金融时间序列进行建模。对于整数 $p \\ge 0$ 和 $q \\ge 0$，ARMA$(p,q)$ 模型定义为\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j},\n$$\n其中 $(\\varepsilon_t)$ 是一个零均值、有限方差的白噪声新息，参数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 是实数，使得自回归多项式的所有零点都在单位圆外（平稳性），移动平均多项式的所有零点都在单位圆外（可逆性）。理论脉冲响应函数（IRF）由 Wold 表示中的系数 $(\\psi_k)_{k \\ge 0}$ 定义\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k},\n$$\n它描述了 $y_t$ 对时刻 $t$ 的单位新息的响应的时间路径。\n\n编写一个完整、可运行的程序，实现一个函数，该函数在给定 ARMA$(p,q)$ 系数 $(\\phi_1,\\ldots,\\phi_p)$ 和 $(\\theta_1,\\ldots,\\theta_q)$ 以及一个正整数 $N$ 的情况下，返回该模型所隐含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。您的程序必须将此函数应用于以下参数集测试套件，其中每个参数集都满足所述的平稳性和可逆性条件：\n\n- 测试用例 $1$：$p=1$，$(\\phi_1) = (0.5)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 $2$：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=1$，$(\\theta_1)=(0.8)$，$N=6$。\n- 测试用例 $3$：$p=1$，$(\\phi_1)=(0.7)$，$q=1$，$(\\theta_1)=(-0.4)$，$N=6$。\n- 测试用例 $4$：$p=0$，$(\\phi_1,\\ldots,\\phi_p)=()$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n- 测试用例 $5$：$p=2$，$(\\phi_1,\\phi_2)=(1.2,-0.32)$，$q=2$，$(\\theta_1,\\theta_2)=(0.3,-0.2)$，$N=8$。\n- 测试用例 $6$：$p=1$，$(\\phi_1)=(0.99)$，$q=0$，$(\\theta_1,\\ldots,\\theta_q)=()$，$N=6$。\n\n对于每个测试用例，您的程序必须计算给定模型所隐含的前 $N$ 个理论脉冲响应系数 $(\\psi_0,\\ldots,\\psi_{N-1})$。将每个系数表示为四舍五入到 $6$ 位小数的实数。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素本身是针对一个测试用例的 $N$ 个四舍五入系数的、用方括号括起来的逗号分隔列表，并且没有任何空格。例如，输出应如下所示\n$$\n[ [a_{1,0},a_{1,1},\\ldots], [a_{2,0},a_{2,1},\\ldots], \\ldots ]\n$$\n但完全没有空格，并且每个 $a_{i,j}$ 都被替换为相应的四舍五入浮点数。具体来说，所要求的格式就是\n$$\n[[\\psi^{(1)}_0,\\ldots,\\psi^{(1)}_{N_1-1}],[\\psi^{(2)}_0,\\ldots,\\psi^{(2)}_{N_2-1}],\\ldots],\n$$\n其中上标表示测试用例索引。仅作为一个明确的格式示例，一个有效的单行输出可能是\n$$\n[[1.000000,0.500000],[1.000000,0.800000,0.000000]],\n$$\n但是，您的程序必须生成与上述六个指定测试用例相对应的输出，而不是此示例。", "solution": "对问题陈述进行验证。\n\n**步骤 1：提取已知信息**\n\nARMA$(p,q)$ 模型定义如下：\n$$\ny_t - \\sum_{i=1}^{p} \\phi_i y_{t-i} \\;=\\; \\varepsilon_t + \\sum_{j=1}^{q} \\theta_j \\varepsilon_{t-j}\n$$\n其中 $(\\varepsilon_t)$ 是一个白噪声过程，$p \\ge 0$，$q \\ge 0$。AR 多项式的零点在单位圆外（平稳性），MA 多项式的零点在单位圆外（可逆性）。\n\nWold 表示（或移动平均表示）为：\n$$\ny_t \\;=\\; \\sum_{k=0}^{\\infty} \\psi_k \\,\\varepsilon_{t-k}\n$$\n系数 $(\\psi_k)_{k \\ge 0}$ 构成了脉冲响应函数（IRF）。\n\n任务是为六个测试用例计算前 $N$ 个 IRF 系数 $(\\psi_0, \\ldots, \\psi_{N-1})$。\n\n测试用例：\n1. $p=1$, $(\\phi_1) = (0.5)$, $q=0$, $(\\theta_j)=()$, $N=6$。\n2. $p=0$, $(\\phi_j)=()$, $q=1$, $(\\theta_1)=(0.8)$, $N=6$。\n3. $p=1$, $(\\phi_1)=(0.7)$, $q=1$, $(\\theta_1)=(-0.4)$, $N=6$。\n4. $p=0$, $(\\phi_j)=()$, $q=0$, $(\\theta_j)=()$, $N=6$。\n5. $p=2$, $(\\phi_1,\\phi_2)=(1.2,-0.32)$, $q=2$, $(\\theta_1,\\theta_2)=(0.3,-0.2)$, $N=8$。\n6. $p=1$, $(\\phi_1)=(0.99)$, $q=0$, $(\\theta_j)=()$, $N=6$。\n\n所有测试用例均声明满足平稳性和可逆性条件。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n根据指定标准对问题进行审查。\n- **科学依据**：该问题基于线性时间序列模型的标准理论，特别是 ARMA 过程，这是计量经济学、统计学和计算金融学中的一个基础课题。其定义和关系在文献中是正确且标准的。\n- **适定性**：该问题是适定的。对于一个平稳且可逆的 ARMA 过程，其 Wold 表示的系数 $(\\psi_k)$ 由参数 $(\\phi_i)$ 和 $(\\theta_j)$ 唯一确定。平稳性和可逆性成立的规定至关重要，并确保了唯一、稳定解的存在。\n- **客观性**：该问题以精确的数学语言表述。任务是客观的，需要计算明确定义的量。\n- **完整性与一致性**：该问题提供了所有必要信息——模型方程、所有测试用例的参数值以及所需的 IRF 系数数量 $N$。信息内部一致。\n- **现实性与可行性**：参数值对于经济学和金融学的应用是现实的。计算任务是基础的，完全可行。\n\n**步骤 3：结论与行动**\n\n该问题有效。它具有科学依据，是适定的，并且是完整的。将提供一个解决方案。\n\n**求解推导**\n\nARMA$(p,q)$ 模型可以使用滞后算子 $B$ 紧凑地表示，其中 $B^k z_t = z_{t-k}$。模型方程变为：\n$$\n\\left(1 - \\sum_{i=1}^{p} \\phi_i B^i\\right) y_t \\;=\\; \\left(1 + \\sum_{j=1}^{q} \\theta_j B^j\\right) \\varepsilon_t\n$$\n我们定义自回归多项式 $\\phi(B) = 1 - \\sum_{i=1}^{p} \\phi_i B^i$ 和移动平均多项式 $\\theta(B) = 1 + \\sum_{j=1}^{q} \\theta_j B^j$。于是方程为 $\\phi(B)y_t = \\theta(B)\\varepsilon_t$。\n\nWold 表示为 $y_t = \\psi(B)\\varepsilon_t$，其中 $\\psi(B) = \\sum_{k=0}^{\\infty} \\psi_k B^k$。\n\n通过将 Wold 形式代入 ARMA 模型的滞后算子表示，我们得到：\n$$\n\\phi(B) \\left(\\psi(B) \\varepsilon_t\\right) \\;=\\; \\theta(B) \\varepsilon_t\n$$\n这隐含了多项式之间的一个基本关系：\n$$\n\\phi(B) \\psi(B) \\;=\\; \\theta(B)\n$$\n这个形式幂级数的等式允许通过相等 $B$ 的同次幂的系数来确定系数 $\\psi_k$。\n$$\n\\left(1 - \\phi_1 B - \\phi_2 B^2 - \\dots - \\phi_p B^p\\right) \\left(\\psi_0 + \\psi_1 B + \\psi_2 B^2 + \\dots\\right) \\;=\\; 1 + \\theta_1 B + \\theta_2 B^2 + \\dots + \\theta_q B^q\n$$\n为了找到系数 $\\psi_k$，我们展开左边并令 $k = 0, 1, 2, \\dots$ 时 $B^k$ 的系数相等。\n\n对于 $k=0$（常数项，$B^0$ 的系数）：\n左边常数项的唯一贡献是 $1 \\cdot \\psi_0$。右边是 $1$。\n$$\n\\psi_0 \\;=\\; 1\n$$\n对于 $k  0$，左边 $B^k$ 的系数是 $\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i}$。右边 $B^k$ 的系数是 $\\theta_k$，我们定义当 $kq$ 时 $\\theta_k=0$。\n$$\n\\psi_k - \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} \\;=\\; \\theta_k\n$$\n重新整理得到 $\\psi_k$ 的递归公式：\n$$\n\\psi_k \\;=\\; \\sum_{i=1}^{p} \\phi_i \\psi_{k-i} + \\theta_k\n$$\n该递推关系对 $k \\ge 1$ 成立。为了实现，精确定义求和的界限和 $\\theta_k$ 的定义是很有用的。设 $(\\phi_1, \\dots, \\phi_p)$ 和 $(\\theta_1, \\dots, \\theta_q)$ 是给定的系数向量。\n\n计算 $(\\psi_0, \\ldots, \\psi_{N-1})$ 的算法如下：\n1.  初始化一个长度为 $N$ 的数组 `psi`。\n2.  设置初始值：$\\psi_0 = 1$。\n3.  对 $k$ 从 $1$ 到 $N-1$ 进行迭代：\n    a. 计算自回归部分：$\\text{AR\\_part} = \\sum_{i=1}^{\\min(k, p)} \\phi_i \\psi_{k-i}$。这个和是对已计算出的 $\\psi$ 值进行的。\n    b. 确定移动平均部分：如果 $1 \\le k \\le q$，则 $\\text{MA\\_part} = \\theta_k$，否则为 $0$。\n    c. 计算 $\\psi_k = \\text{AR\\_part} + \\text{MA\\_part}$。\n\n对每个测试用例实施此递归过程，以导出所需的 IRF 序列。最终数值按规定四舍五入到 $6$ 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_irf(phi, theta, N):\n    \"\"\"\n    Computes the first N coefficients of the Impulse Response Function (IRF)\n    for a given ARMA(p,q) model.\n\n    The IRF psi_k is computed using the recurrence relation:\n    psi_k = sum_{i=1 to p} phi_i * psi_{k-i} + theta_k\n    with psi_0 = 1 and theta_k = 0 for k  q.\n\n    Args:\n        phi (tuple): A tuple of p autoregressive coefficients (phi_1, ..., phi_p).\n        theta (tuple): A tuple of q moving average coefficients (theta_1, ..., theta_q).\n        N (int): The number of IRF coefficients to compute (psi_0, ..., psi_{N-1}).\n\n    Returns:\n        numpy.ndarray: An array of the first N IRF coefficients.\n    \"\"\"\n    p = len(phi)\n    q = len(theta)\n    \n    # Initialize psi array of length N\n    psi = np.zeros(N)\n    \n    # Base case: psi_0 = 1\n    if N  0:\n        psi[0] = 1.0\n\n    # Recursively compute psi_k for k = 1, ..., N-1\n    for k in range(1, N):\n        # Autoregressive part\n        ar_part = 0.0\n        # Sum_{i=1 to p} phi_i * psi_{k-i}\n        for i in range(1, p + 1):\n            if k - i = 0:\n                ar_part += phi[i - 1] * psi[k - i]\n        \n        # Moving average part\n        ma_part = 0.0\n        # For k=1..q, theta_k corresponds to theta[k-1]\n        if k - 1  q:\n            ma_part = theta[k - 1]\n            \n        psi[k] = ar_part + ma_part\n        \n    return psi\n\ndef solve():\n    \"\"\"\n    Solves the problem by computing the IRF for each test case\n    and printing the results in the specified format.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (phi_coeffs, theta_coeffs, N)\n        ((0.5,), (), 6),\n        ((), (0.8,), 6),\n        ((0.7,), (-0.4,), 6),\n        ((), (), 6),\n        ((1.2, -0.32), (0.3, -0.2), 8),\n        ((0.99,), (), 6),\n    ]\n\n    all_results_str = []\n    for phi_case, theta_case, n_case in test_cases:\n        # Compute the IRF coefficients for the current case.\n        psi_coeffs = compute_irf(phi_case, theta_case, n_case)\n        \n        # Round each coefficient to 6 decimal places.\n        rounded_psi = np.round(psi_coeffs, 6)\n        \n        # Format the rounded coefficients into strings with 6 decimal places.\n        formatted_psi = [f\"{x:.6f}\" for x in rounded_psi]\n        \n        # Create the string for the current case, e.g., \"[1.000000,0.500000]\"\n        case_str = f\"[{','.join(formatted_psi)}]\"\n        all_results_str.append(case_str)\n\n    # Combine all case strings into the final output format, e.g., \"[[...],[...]]\"\n    final_output = f\"[{','.join(all_results_str)}]\"\n    \n    # Final print statement in the exact required format.\n    print(final_output)\n\nsolve()\n```", "id": "2372460"}]}