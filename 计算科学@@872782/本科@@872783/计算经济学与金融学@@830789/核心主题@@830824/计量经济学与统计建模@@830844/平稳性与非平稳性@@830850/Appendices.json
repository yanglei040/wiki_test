{"hands_on_practices": [{"introduction": "“平稳性”这一概念听起来可能很抽象，但它在现实世界中有着直观的对应。这个练习将平稳性与一个具体物理系统的长期稳定性联系起来：一个客户服务队列。通过分析到达率和服务率之间的关系，你将推导出使队列长度过程保持平稳（即，队列不会无限增长）的关键条件，从而将理论与实际相结合 [@problem_id:2433729]。", "problem": "一家金融服务公司运营一个单一的客户支持台，处理来自在线经纪平台客户的传入请求。该公司将系统中的请求数量（包括任何正在服务中的请求）建模为非负整数上的连续时间马尔可夫链。具体来说，令 $Q(t)$ 表示在时间 $t \\ge 0$ 时的队列长度。请求根据一个速率为 $\\lambda  0$ 的恒定泊松过程到达，服务时间是独立的，且服从速率为 $\\mu  0$ 的恒定指数分布。该系统有一个单一的服务器。当 $Q(t)=n \\ge 1$ 时，转移 $n \\to n-1$ 以速率 $\\mu$ 发生；当 $Q(t)=n \\ge 0$ 时，转移 $n \\to n+1$ 以速率 $\\lambda$ 发生。当 $Q(t)=0$ 时，没有离去发生。\n\n仅使用连续时间马尔可夫链的第一性原理、平稳分布的定义以及泊松到达和指数服务的性质，确定到达率 $\\lambda$ 的上确界（表示为 $\\mu$ 的函数），使得队列长度过程 $Q(t)$ 是严格平稳的，即其分布不随时间变化且等于一个正常的平稳分布。\n\n以 $\\mu$ 的单一闭式解析表达式作答。答案中不要包含单位。", "solution": "该问题要求确定到达率 $\\lambda$ 的上确界，使得所描述的排队系统拥有一个正常的平稳分布。该系统被描述为在非负整数状态空间 $S = \\{0, 1, 2, \\dots\\}$ 上的连续时间马尔可夫链（CTMC），其中状态 $n$ 代表系统中的请求数量。这是一个经典的生灭过程。\n\n让我们为每个状态 $n \\in S$ 定义生灭率。\n“生”对应于一次到达，导致从状态 $n$ 转移到 $n+1$。根据问题陈述，到达遵循一个速率为 $\\lambda$ 的恒定泊松过程。因此，在任何状态 $n \\ge 0$ 下的出生率都是恒定的：\n$$ \\lambda_n = \\lambda \\quad \\text{for } n = 0, 1, 2, \\dots $$\n“灭”对应于一次服务完成，导致从状态 $n$ 转移到 $n-1$。该系统有一个单一的服务器，其指数服务速率为 $\\mu$。因此，只有当系统不为空（即 $n \\ge 1$）时，才会发生离去。死亡率为：\n$$ \\mu_n = \\begin{cases} \\mu  \\text{if } n \\ge 1 \\\\ 0  \\text{if } n = 0 \\end{cases} $$\n\n为了使过程 $Q(t)$ 是严格平稳的且具有正常的平稳分布，必须存在一个概率分布 $\\pi = (\\pi_0, \\pi_1, \\pi_2, \\dots)$，使得对于所有 $n$，$\\pi_n \\ge 0$，$\\sum_{n=0}^{\\infty} \\pi_n = 1$，并且该分布不随时间变化。对于生灭过程，如果平稳分布 $\\pi$ 满足细致平衡方程，则可以保证时间不变性：\n$$ \\pi_n \\lambda_n = \\pi_{n+1} \\mu_{n+1} \\quad \\text{for } n = 0, 1, 2, \\dots $$\n\n我们可以用递归的方式求解这些方程，以 $\\pi_0$ 表示 $\\pi_n$。\n对于 $n=0$：\n$$ \\pi_0 \\lambda_0 = \\pi_1 \\mu_1 \\implies \\pi_0 \\lambda = \\pi_1 \\mu \\implies \\pi_1 = \\pi_0 \\left(\\frac{\\lambda}{\\mu}\\right) $$\n对于 $n=1$：\n$$ \\pi_1 \\lambda_1 = \\pi_2 \\mu_2 \\implies \\pi_1 \\lambda = \\pi_2 \\mu \\implies \\pi_2 = \\pi_1 \\left(\\frac{\\lambda}{\\mu}\\right) = \\pi_0 \\left(\\frac{\\lambda}{\\mu}\\right)^2 $$\n通过归纳法，我们可以为任何 $n \\ge 0$ 建立以下通用关系：\n$$ \\pi_n = \\pi_0 \\left(\\frac{\\lambda}{\\mu}\\right)^n $$\n\n为了使 $\\pi$ 成为一个正常的概率分布，所有概率的总和必须等于 $1$。这是归一化条件：\n$$ \\sum_{n=0}^{\\infty} \\pi_n = 1 $$\n将 $\\pi_n$ 的表达式代入此方程可得：\n$$ \\sum_{n=0}^{\\infty} \\pi_0 \\left(\\frac{\\lambda}{\\mu}\\right)^n = 1 $$\n$$ \\pi_0 \\sum_{n=0}^{\\infty} \\left(\\frac{\\lambda}{\\mu}\\right)^n = 1 $$\n该求和是一个公比为 $r = \\frac{\\lambda}{\\mu}$ 的几何级数。为使该级数收敛到一个有限值，公比的绝对值必须小于 $1$。由于 $\\lambda  0$ 且 $\\mu  0$，公比为正，因此收敛的条件是：\n$$ \\frac{\\lambda}{\\mu}  1 \\implies \\lambda  \\mu $$\n如果不满足此条件（即，如果 $\\lambda \\ge \\mu$），则级数发散，概率之和无法归一化为 $1$。在这种情况下，不存在正常的平稳分布；队列是不稳定的，请求数量会无限增长。\n\n当满足条件 $\\lambda  \\mu$ 时，几何级数的和为：\n$$ \\sum_{n=0}^{\\infty} \\left(\\frac{\\lambda}{\\mu}\\right)^n = \\frac{1}{1 - \\frac{\\lambda}{\\mu}} $$\n将此结果代回归一化方程，我们可以解出 $\\pi_0$：\n$$ \\pi_0 \\left(\\frac{1}{1 - \\frac{\\lambda}{\\mu}}\\right) = 1 \\implies \\pi_0 = 1 - \\frac{\\lambda}{\\mu} $$\n由于概率必须是非负的，$\\pi_0  0$（因为 $\\pi_0 = 0$ 将意味着所有 $\\pi_n = 0$），这再次要求 $1 - \\frac{\\lambda}{\\mu}  0$，即 $\\lambda  \\mu$。\n\n因此，存在一个正常的平稳分布的充要条件是 $\\lambda  \\mu$。问题要求的是满足此条件的到达率 $\\lambda$ 的上确界。给定一个固定的服务率 $\\mu  0$，所有允许存在平稳分布的可能到达率 $\\lambda  0$ 的集合由区间 $(0, \\mu)$ 给出。\n一个集合的上确界是它的最小上界。对于到达率集合 $\\lambda \\in (0, \\mu)$，其上确界是：\n$$ \\sup\\{\\lambda \\mid 0  \\lambda  \\mu\\} = \\mu $$\n这是阈值到达率；对于任何严格低于此值的速率，系统是稳定的，而当速率等于或高于此值时，系统变得不稳定。", "answer": "$$\\boxed{\\mu}$$", "id": "2433729"}, {"introduction": "在理解了平稳性的基本直觉后，我们转向经济数据分析中的一个核心挑战：识别并处理非平稳性。本练习构建了一个截距会随时间“漂移”的随机过程，你需要通过分析来确定如何将其转换为一个平稳序列。这项实践将使你掌握单位根和差分这两个处理非平稳时间序列的关键工具 [@problem_id:2433747]。", "problem": "考虑一个由下式定义的离散时间随机过程 $\\{y_t\\}_{t \\in \\mathbb{Z}}$：\n$$\ny_t \\;=\\; \\alpha_t \\;+\\; 0.5\\, y_{t-1} \\;+\\; \\epsilon_t,\n$$\n其中，时变截距 $\\{\\alpha_t\\}$ 服从一个随机游走：\n$$\n\\alpha_t \\;=\\; \\alpha_{t-1} \\;+\\; u_t.\n$$\n假设 $\\{\\epsilon_t\\}$ 和 $\\{u_t\\}$ 是相互独立的独立同分布 (i.i.d.) 随机变量序列，且 $\\mathbb{E}[\\epsilon_t]=0$, $\\mathbb{E}[u_t]=0$, $\\operatorname{Var}(\\epsilon_t)=\\sigma_{\\epsilon}^{2}\\in (0,\\infty)$ 以及 $\\operatorname{Var}(u_t)=\\sigma_{u}^{2}\\in (0,\\infty)$。假设 $\\alpha_0$ 和 $y_{-1}$ 是有限方差的常数，且独立于 $\\{\\epsilon_t\\}$ 和 $\\{u_t\\}$。令一阶差分算子定义为 $\\Delta y_t \\equiv y_t - y_{t-1}$，对于整数 $d \\ge 0$，递归地定义 $\\Delta^{d}$ 为 $\\Delta^{0} y_t \\equiv y_t$ 且当 $d \\ge 1$ 时 $\\Delta^{d} y_t \\equiv \\Delta(\\Delta^{d-1} y_t)$。\n\n确定最小的整数 $d \\ge 0$，使得 $\\{\\Delta^{d} y_t\\}$ 是弱平稳的 (协方差平稳的)。给出 $d$ 的值作为你的答案。不需要单位。你的答案必须是一个无舍入的单一整数。", "solution": "问题是确定最小的非负整数 $d$，使得过程 $\\{\\Delta^d y_t\\}$ 是弱平稳的。如果一个过程 $\\{z_t\\}$ 的均值 $\\mathbb{E}[z_t]$ 和方差 $\\operatorname{Var}(z_t)$ 不随时间变化，且自协方差 $\\operatorname{Cov}(z_t, z_{t-h})$ 只取决于滞后阶数 $h$，那么该过程是弱平稳的。\n\n过程 $\\{y_t\\}$ 由以下方程组定义：\n$$\n(1) \\quad y_t = \\alpha_t + 0.5 y_{t-1} + \\epsilon_t\n$$\n$$\n(2) \\quad \\alpha_t = \\alpha_{t-1} + u_t\n$$\n其中 $\\{\\epsilon_t\\}$ 和 $\\{u_t\\}$ 是相互独立的 i.i.d. 序列，其均值为零，有限正方差分别为 $\\sigma_{\\epsilon}^{2}$ 和 $\\sigma_{u}^{2}$。\n\n让我们首先分析 $\\{y_t\\}$ 本身的平稳性，这对应于 $d=0$ 的情况。\n我们可以仅用 $\\{y_t\\}$ 来表示该系统。根据方程 (1)，我们有：\n$$\n\\alpha_t = y_t - 0.5 y_{t-1} - \\epsilon_t\n$$\n将此方程滞后一期得到：\n$$\n\\alpha_{t-1} = y_{t-1} - 0.5 y_{t-2} - \\epsilon_{t-1}\n$$\n将 $\\alpha_t$ 和 $\\alpha_{t-1}$ 的这些表达式代入方程 (2) 得到：\n$$\n(y_t - 0.5 y_{t-1} - \\epsilon_t) = (y_{t-1} - 0.5 y_{t-2} - \\epsilon_{t-1}) + u_t\n$$\n整理各项，我们得到一个关于 $\\{y_t\\}$ 的单一方程：\n$$\ny_t - 1.5 y_{t-1} + 0.5 y_{t-2} = u_t + \\epsilon_t - \\epsilon_{t-1}\n$$\n这是一个关于 $\\{y_t\\}$ 的自回归移动平均 (ARMA) 模型。我们可以使用滞后算子 $L$ 来写它，其中 $L x_t = x_{t-1}$：\n$$\n(1 - 1.5 L + 0.5 L^2) y_t = u_t + (1 - L) \\epsilon_t\n$$\n对于一个自回归过程，要使其平稳，其特征多项式的根必须全部位于单位圆之外。自回归特征多项式为 $\\phi(z) = 1 - 1.5 z + 0.5 z^2$。我们通过求解 $\\phi(z)=0$ 来找到它的根：\n$$\n0.5 z^2 - 1.5 z + 1 = 0\n$$\n$$\nz^2 - 3 z + 2 = 0\n$$\n$$\n(z-1)(z-2) = 0\n$$\n根是 $z_1=1$ 和 $z_2=2$。其中一个根 $z_1=1$ 位于单位圆上。这是一个“单位根”，它是非平稳性的一个确定性指标。单位根的存在意味着对系统的冲击具有永久性影响，且该过程的方差不随时间恒定。具体来说，随机游走部分 $\\{\\alpha_t\\}$ 的方差是 $\\operatorname{Var}(\\alpha_t) = t \\sigma_u^2$（假设 $\\alpha_0$ 是一个常数），它随时间增长。这种非平稳性被 $\\{y_t\\}$ 所继承。因此，对于 $d=0$，过程 $\\{\\Delta^0 y_t\\} = \\{y_t\\}$ 是非平稳的。\n\n接下来，我们研究 $d=1$ 的情况。我们分析一阶差分过程 $w_t = \\Delta y_t = y_t - y_{t-1} = (1-L)y_t$。\n$y_t$ 的 AR 多项式可以分解为 $\\phi(L) = (1-L)(1-0.5L)$。将其代入 $y_t$ 的方程中：\n$$\n(1-L)(1-0.5L) y_t = u_t + \\epsilon_t - \\epsilon_{t-1}\n$$\n代入 $w_t = (1-L)y_t$，我们得到一个关于 $\\{w_t\\}$ 的方程：\n$$\n(1-0.5L) w_t = u_t + \\epsilon_t - \\epsilon_{t-1}\n$$\n这可以写成：\n$$\nw_t = 0.5 w_{t-1} + v_t\n$$\n其中 $v_t = u_t + \\epsilon_t - \\epsilon_{t-1}$。这表明 $\\{w_t\\}$ 是一个由误差项 $\\{v_t\\}$ 驱动的 AR(1) 过程。要使 $\\{w_t\\}$ 弱平稳，必须满足两个条件：\n1. 自回归系数的绝对值必须小于 1。这里，系数是 $0.5$，且 $|0.5|  1$，所以这个条件得到满足。\n2. 驱动噪声过程 $\\{v_t\\}$ 必须是弱平稳的。\n\n让我们检查 $\\{v_t\\}$ 的性质：\n- 均值：$\\mathbb{E}[v_t] = \\mathbb{E}[u_t] + \\mathbb{E}[\\epsilon_t] - \\mathbb{E}[\\epsilon_{t-1}] = 0 + 0 - 0 = 0$。均值是常数。\n- 方差：由于 $\\{u_t\\}$ 和 $\\{\\epsilon_t\\}$ 是相互独立的 i.i.d. 序列，$u_t$, $\\epsilon_t$ 和 $\\epsilon_{t-1}$ 互不相关。\n$$\n\\operatorname{Var}(v_t) = \\operatorname{Var}(u_t + \\epsilon_t - \\epsilon_{t-1}) = \\operatorname{Var}(u_t) + \\operatorname{Var}(\\epsilon_t) + \\operatorname{Var}(-\\epsilon_{t-1}) = \\sigma_u^2 + \\sigma_\\epsilon^2 + (-1)^2 \\sigma_\\epsilon^2 = \\sigma_u^2 + 2\\sigma_\\epsilon^2\n$$\n由于 $\\sigma_u^2, \\sigma_\\epsilon^2 \\in (0, \\infty)$，方差是恒定且有限的。\n- 自协方差：对于滞后阶数 $h=1$：\n$$\n\\operatorname{Cov}(v_t, v_{t-1}) = \\mathbb{E}[v_t v_{t-1}] = \\mathbb{E}[(u_t + \\epsilon_t - \\epsilon_{t-1})(u_{t-1} + \\epsilon_{t-1} - \\epsilon_{t-2})]\n$$\n展开此式并利用独立性和 i.i.d. 性质，唯一不为零的期望是 $\\mathbb{E}[(-\\epsilon_{t-1})(\\epsilon_{t-1})] = -\\mathbb{E}[\\epsilon_{t-1}^2] = -\\sigma_\\epsilon^2$。所以，$\\operatorname{Cov}(v_t, v_{t-1}) = -\\sigma_\\epsilon^2$。\n对于滞后阶数 $h \\ge 2$：\n$$\n\\operatorname{Cov}(v_t, v_{t-h}) = \\mathbb{E}[(u_t + \\epsilon_t - \\epsilon_{t-1})(u_{t-h} + \\epsilon_{t-h} - \\epsilon_{t-h-1})] = 0\n$$\n因为所有交叉项都涉及不同时间周期的变量。\n由于 $\\{v_t\\}$ 的均值、方差和自协方差不依赖于时间 $t$，所以 $\\{v_t\\}$ 是一个弱平稳过程（具体来说，是一个 MA(1) 过程）。\n\n因为 $\\{w_t\\} = \\{\\Delta y_t\\}$ 是一个由平稳噪声过程 $\\{v_t\\}$ 驱动的稳定 AR(1) 过程，所以 $\\{w_t\\}$ 本身是弱平稳的。它的无条件均值为 $\\mathbb{E}[w_t] = 0$，其方差是恒定且有限的。自协方差函数 $\\operatorname{Cov}(w_t, w_{t-h})$ 可以被证明只取决于滞后阶数 $h$。\n因此，对于 $d=1$，过程 $\\{\\Delta^1 y_t\\}$ 是弱平稳的。\n\n由于 $\\{y_t\\}$（对于 $d=0$）是非平稳的，而 $\\{\\Delta y_t\\}$（对于 $d=1$）是平稳的，所以使得 $\\{\\Delta^d y_t\\}$ 弱平稳的最小非负整数 $d$ 是 $1$。任何进一步的差分（例如 $d=2$）也会得到一个平稳过程，因为对一个平稳过程进行差分会产生另一个平稳过程，但 $d=1$ 是所需的最小差分阶数。", "answer": "$$\\boxed{1}$$", "id": "2433747"}, {"introduction": "真实的金融和经济系统很少是纯粹平稳或纯粹非平稳的，它们的行为模式会随环境而改变。本练习将带你进入非线性时间序列建模的领域，模拟一个在不同“机制”之间切换的金融序列。通过构建一个门限自回归 (TAR) 模型，你将看到一个序列如何在低波动时期表现出平稳性，而在高波动时期转变为非平稳的随机游走，从而更好地捕捉真实市场的动态特性 [@problem_id:2433671]。", "problem": "考虑一个由双机制阈值自回归 (TAR) 模型定义的时间离散金融序列，其机制取决于一个波动率阈值。令 $\\{y_t\\}_{t=1}^T$ 表示该序列，其样本前值为 $y_{-w+1}=\\cdots=y_{-1}=y_0=0$。对于 $t \\geq 1$，基于最后 $w$ 个值定义滚动波动率估计量为\n$$\n\\bar{y}_{t-1,w}=\\frac{1}{w}\\sum_{i=1}^{w} y_{t-i},\\qquad\nv_{t-1}=\\sqrt{\\frac{1}{w}\\sum_{i=1}^{w}\\left(y_{t-i}-\\bar{y}_{t-1,w}\\right)^2}.\n$$\n设阈值为 $\\tau \\ge 0$。该过程按如下方式切换机制：\n- 若 $v_{t-1} \\le \\tau$，则 $y_t = c_s + \\phi_s y_{t-1} + \\varepsilon_t$（平稳机制）。\n- 若 $v_{t-1}  \\tau$，则 $y_t = c_u + 1 \\cdot y_{t-1} + \\varepsilon_t$（单位根机制）。\n\n假定新息 $\\{\\varepsilon_t\\}$ 是独立同分布 (i.i.d.) 的正态分布，均值为 $0$，方差为 $\\sigma^2$。为保证可复现性，对于每组参数，新息序列均在固定种子 $s$ 下生成。\n\n你的任务是严格按照上述说明实现该模型，并对下面测试套件中的每组参数，计算以下三个量：\n- 单位根机制被激活的次数比例：\n$$\n\\hat{p}=\\frac{1}{T}\\sum_{t=1}^{T}\\mathbf{1}\\{v_{t-1}\\tau\\},\n$$\n表示为小数点后保留六位的小数。\n- $\\{y_t\\}_{t=1}^T$ 的有限样本方差：\n$$\n\\hat{V}=\\frac{1}{T}\\sum_{t=1}^{T}\\left(y_t - \\bar{y}\\right)^2,\\quad \\text{其中}\\quad \\bar{y}=\\frac{1}{T}\\sum_{t=1}^{T}y_t,\n$$\n小数点后保留六位。\n- 最终值 $y_T$，小数点后保留六位。\n\n所有量都是无量纲的。不涉及角度。所有比例必须以小数形式表示。\n\n测试套件（每个元组列出了 $(T,w,\\tau,\\phi_s,c_s,c_u,\\sigma,s)$）：\n- 案例 $1$：$(200,\\,10,\\,0.8,\\,0.6,\\,0.0,\\,0.0,\\,1.0,\\,20240229)$。\n- 案例 $2$（$\\tau=0$ 强调初始边界情况）：$(200,\\,10,\\,0.0,\\,0.6,\\,0.0,\\,0.0,\\,1.0,\\,7)$。\n- 案例 $3$（由于阈值较高，实际效果为始终平稳）：$(200,\\,10,\\,5.0,\\,0.6,\\,0.0,\\,0.0,\\,1.0,\\,12345)$。\n\n你的程序应生成单行输出，其中包含按上述顺序排列的三个案例的结果，形式为一个包含三个子列表的逗号分隔列表。每个子列表必须包含相应案例的三个四舍五入后的值 $[\\hat{p},\\hat{V},y_T]$。确切格式为：\n[[p1,V1,yT1],[p2,V2,yT2],[p3,V3,yT3]]", "solution": "该模型是一个双机制阈值自回归 (TAR) 过程。其机制由应用于波动率估计量的阈值 $\\tau$ 触发。我们通过指定递归关系、波动率度量以及待计算的汇总统计量来将问题形式化。\n\n首先，我们使用过去的 $w$ 个值来定义滚动波动率估计量。对于每个 $t \\ge 1$，我们计算\n$$\n\\bar{y}_{t-1,w}=\\frac{1}{w}\\sum_{i=1}^{w} y_{t-i},\\qquad\nv_{t-1}=\\sqrt{\\frac{1}{w}\\sum_{i=1}^{w}\\left(y_{t-i}-\\bar{y}_{t-1,w}\\right)^2}.\n$$\n由于我们将样本前值设为 $y_{-w+1}=\\cdots=y_0=0$，波动率估计量从 $v_0=0$ 开始，并随着模拟路径偏离零而演变。\n\n其次，我们定义依赖于机制的递归关系：\n- 平稳机制（低波动率）：如果 $v_{t-1}\\le \\tau$，则\n$$\ny_t = c_s + \\phi_s y_{t-1} + \\varepsilon_t,\n$$\n其中 $|\\phi_s|1$ 确保了此机制下 $AR(1)$ 部分的协方差平稳性。在我们的测试套件中，$\\phi_s=0.6$ 满足 $|\\phi_s|1$。\n- 单位根机制（高波动率）：如果 $v_{t-1}  \\tau$，则\n$$\ny_t = c_u + 1\\cdot y_{t-1} + \\varepsilon_t,\n$$\n这是一个带有漂移项 $c_u$ 的随机游走；由于存在单位根，此机制是非平稳的。\n\n新息满足 $\\varepsilon_t \\sim \\mathcal{N}(0,\\sigma^2)$，且在时间 $t$ 上独立。为了使输出具有确定性且可测试，对于每组参数，我们使用一个固定的种子 $s$ 来初始化伪随机数生成器，从而固定实现 $\\{\\varepsilon_t\\}_{t=1}^T$。\n\n给定 $(T,w,\\tau,\\phi_s,c_s,c_u,\\sigma,s)$，我们对 $t=1,\\dots,T$ 进行如下操作：\n- 从最后 $w$ 个值 $y_{t-1},y_{t-2},\\dots,y_{t-w}$ 计算 $v_{t-1}$。\n- 根据 $v_{t-1}\\le \\tau$ 或 $v_{t-1}\\tau$ 来选择机制，并相应地更新 $y_t$。\n\n模拟出 $\\{y_t\\}_{t=1}^T$ 后，我们计算所需的汇总统计量：\n- 单位根机制被激活的次数比例：\n$$\n\\hat{p}=\\frac{1}{T}\\sum_{t=1}^{T}\\mathbf{1}\\{v_{t-1}\\tau\\}.\n$$\n- 有限样本方差（使用除数 $T$）：\n$$\n\\bar{y}=\\frac{1}{T}\\sum_{t=1}^{T}y_t,\\qquad\n\\hat{V}=\\frac{1}{T}\\sum_{t=1}^{T}\\left(y_t - \\bar{y}\\right)^2.\n$$\n- 终值 $y_T$。\n\n最后，我们将 $\\hat{p}$、$\\hat{V}$ 和 $y_T$ 都四舍五入到小数点后六位。我们对三个测试案例中的每一个都重复此计算，并将三个三元组 $[\\hat{p},\\hat{V},yT]$ 聚合到单行输出中，格式如下：\n$$\n[[p_1,V_1,yT_1],[p_2,V_2,yT_2],[p_3,V_3,yT_3]].\n$$\n\n从平稳性的角度来看，在低波动率机制下，由于 $|\\phi_s|1$，过程表现得像一个稳定的 $AR(1)$，这意味着如果该机制是永久性的，其无条件方差是良定义的，约为 $\\sigma^2/(1-\\phi_s^2)$。在高波动率机制下，单位根意味着冲击会累积而没有均值回归，使得路径在这些时期内是非平稳的。TAR 机制是非线性的且路径依赖的：实现的波动率决定机制选择，而机制的动态决定未来的波动率。所要求的汇总统计量通过 $\\hat{p}$ 捕获了非平稳行为的经验频率，通过 $\\hat{V}$ 捕获了实现路径的离散程度，以及通过反映累积动态的终值 $y_T$。$\\tau=0$ 的边界情况确保了在 $t=1$ 时，过程从平稳机制开始，因为 $v_0=0\\le 0$，但任何随后的正波动率都将立即允许在 $v_{t-1}0$ 时切换到单位根机制。", "answer": "```python\nimport numpy as np\n\ndef simulate_tar(T, w, tau, phi_s, c_s, c_u, sigma, seed):\n    \"\"\"\n    Simulate the TAR process:\n      y_t = c_s + phi_s * y_{t-1} + eps_t, if v_{t-1} = tau\n      y_t = c_u + 1.0   * y_{t-1} + eps_t, if v_{t-1} >  tau\n    where v_{t-1} is the population standard deviation (dividing by w) of the last w values.\n    Pre-sample values y_{-w+1} = ... = y_0 = 0.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    eps = rng.normal(loc=0.0, scale=sigma, size=T)\n\n    # Maintain a window of last w observations; initialize with zeros\n    window = [0.0] * w\n    y_values = []  # store y_1 ... y_T\n    unit_root_count = 0\n\n    for t in range(T):\n        # Compute rolling volatility v_{t-1}: std with divisor w\n        mean_window = sum(window) / w\n        var_window = sum((val - mean_window) ** 2 for val in window) / w\n        v_prev = var_window ** 0.5\n\n        y_prev = window[-1]\n        if v_prev = tau:\n            y_t = c_s + phi_s * y_prev + eps[t]\n        else:\n            y_t = c_u + 1.0 * y_prev + eps[t]\n            unit_root_count += 1\n\n        # Update structures\n        y_values.append(y_t)\n        window.pop(0)\n        window.append(y_t)\n\n    # Compute summary statistics\n    y_arr = np.array(y_values, dtype=float)\n    mean_y = float(np.sum(y_arr) / T)\n    var_y = float(np.sum((y_arr - mean_y) ** 2) / T)\n    frac_unit_root = unit_root_count / T\n    y_T = float(y_arr[-1])\n\n    return frac_unit_root, var_y, y_T\n\ndef fmt_float(x):\n    y = round(float(x), 6)\n    # Normalize negative zero to zero for cleaner output\n    if y == 0.0:\n        y = 0.0\n    return f\"{y:.6f}\"\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each tuple: (T, w, tau, phi_s, c_s, c_u, sigma, seed)\n    test_cases = [\n        (200, 10, 0.8, 0.6, 0.0, 0.0, 1.0, 20240229),\n        (200, 10, 0.0, 0.6, 0.0, 0.0, 1.0, 7),\n        (200, 10, 5.0, 0.6, 0.0, 0.0, 1.0, 12345),\n    ]\n\n    results = []\n    for case in test_cases:\n        T, w, tau, phi_s, c_s, c_u, sigma, seed = case\n        frac_unit_root, var_y, y_T = simulate_tar(T, w, tau, phi_s, c_s, c_u, sigma, seed)\n        results.append([frac_unit_root, var_y, y_T])\n\n    # Format output as a single line: [[p1,V1,yT1],[p2,V2,yT2],[p3,V3,yT3]]\n    formatted_groups = []\n    for triplet in results:\n        formatted = \"[\" + \",\".join(fmt_float(x) for x in triplet) + \"]\"\n        formatted_groups.append(formatted)\n    output_line = \"[\" + \",\".join(formatted_groups) + \"]\"\n    print(output_line)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2433671"}]}