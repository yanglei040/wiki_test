{"hands_on_practices": [{"introduction": "为了在实践中应用自相关函数（ACF）和偏自相关函数（PACF），首先必须理解它们之间的数学关系。本练习将引导你通过一个基础计算，来掌握这两者之间的核心联系。通过使用杜宾-列文森（Durbin-Levinson）递推公式，你可以根据给定的ACF值直接计算出PACF值，从而加深对这些时间序列分析基本工具背后计算机制的理解[@problem_id:1943287]。", "problem": "在平稳时间序列的分析中，自相关函数 (ACF) 和偏自相关函数 (PACF) 是识别数据潜在结构的基本工具。对于一个给定的平稳过程，令 $\\rho(k)$ 表示滞后 $k$ 阶的理论ACF，它衡量了相隔 $k$ 个时间步长的观测值之间的相关性。令 $\\phi_{kk}$ 表示滞后 $k$ 阶的理论PACF，它衡量了在剔除中间观测值的线性效应后，相隔 $k$ 个时间步长的观测值之间的相关性。\n\n假设一个平稳时间序列的理论ACF值为 $\\rho(1) = 0.8$ 和 $\\rho(2) = 0.5$。计算其滞后为2的理论PACF值，记为 $\\phi_{22}$。将最终答案四舍五入到四位有效数字。", "solution": "我们使用联系理论ACF $\\rho(k)$ 和 PACF $\\phi_{kk}$ 的 Durbin–Levinson 递推公式。对于 $k=1$，\n$$\n\\phi_{11}=\\rho(1).\n$$\n对于 $k=2$，递推公式给出\n$$\n\\phi_{22}=\\frac{\\rho(2)-\\phi_{11}\\rho(1)}{1-\\phi_{11}\\rho(1)}.\n$$\n将 $\\phi_{11}=\\rho(1)$ 代入可得\n$$\n\\phi_{22}=\\frac{\\rho(2)-\\rho(1)^{2}}{1-\\rho(1)^{2}}.\n$$\n使用给定值 $\\rho(1)=0.8$ 和 $\\rho(2)=0.5$，\n$$\n\\phi_{22}=\\frac{0.5-0.8^{2}}{1-0.8^{2}}=\\frac{0.5-0.64}{1-0.64}=\\frac{-0.14}{0.36}=-\\frac{7}{18}\\approx -0.388888\\ldots\n$$\n四舍五入到四位有效数字得到 $-0.3889$。", "answer": "$$\\boxed{-0.3889}$$", "id": "1943287"}, {"introduction": "理论知识的真正价值在于其应用。这个动手实践旨在将ACF和PACF的抽象概念与实际的模型识别联系起来。你将从零开始构建一个自回归（AR）过程，并通过模拟生成数据，亲眼观察其标志性的相关性模式：一个逐渐衰减的ACF和一个在特定阶数后突然“截尾”的PACF [@problem_id:2373131]。这项练习对于培养从数据中识别潜在时间序列模型的直觉至关重要。", "problem": "考虑一个计算经济学和金融学中的单变量、协方差平稳的时间序列，其底层数据生成过程可以被建模为线性自回归模型。你的任务是构建并验证一个过程，该过程的样本自相关函数（ACF）呈现出清晰的正弦模式，而样本偏自相关函数（PACF）则不呈现。重点是从第一性原理出发，推导并实现其逻辑：协方差平稳性、自协方差、自相关以及通过由 Levinson–Durbin 递归求解的 Yule–Walker 系统得到的偏自相关。不要使用任何预构建的时间序列工具；直接根据其定义实现所需的估计量。\n\n使用的基本定义：\n\n- 一个零均值、弱平稳过程具有自协方差序列 $\\{\\gamma_{k}\\}_{k \\in \\mathbb{Z}}$，其中 $\\gamma_{k} = \\mathbb{E}[(X_{t} - \\mu)(X_{t-k} - \\mu)]$ 仅依赖于滞后 $k$，其中 $\\mu = \\mathbb{E}[X_{t}]$ 是常数，且 $\\operatorname{Var}(X_{t}) = \\gamma_{0} \\lt \\infty$ 不依赖于 $t$。\n\n- 滞后 $k$ 的自相关为 $\\rho_{k} = \\gamma_{k}/\\gamma_{0}$。\n\n- 滞后 $k$ 的偏自相关，记作 $\\alpha_{k}$，是在移除了对中间滞后 $1,\\dots,k-1$ 的线性依赖后，$X_{t}$ 和 $X_{t-k}$ 之间的相关性。它是 $k$ 阶自回归的 Yule–Walker 线性系统解中的最后一个系数，可以通过将 Levinson–Durbin 算法应用于样本自协方差序列来递归计算。\n\n你将模拟一个由下式定义的二阶自回归过程 $\\text{AR}(2)$：\n$$\nX_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t},\n$$\n其中 $\\{\\varepsilon_{t}\\}$ 是一个独立同分布的白噪声序列，满足 $\\varepsilon_{t} \\sim \\mathcal{N}(0,\\sigma^{2})$，且 $\\sigma^{2} = 1$。选择 $(\\phi_{1},\\phi_{2})$ 使得特征多项式 $1 - \\phi_{1} z - \\phi_{2} z^{2}$ 的根为复数且位于单位圆外，以确保协方差平稳性和振荡动态。\n\n从第一性原理实现：\n\n- 一个带有预烧期（burn-in period）以近似平稳性的 $\\text{AR}(2)$ 模拟器。\n\n- 使用以下公式计算样本均值 $\\hat{\\mu}$ 和样本自协方差序列 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$：\n$$\n\\hat{\\mu} = \\frac{1}{n} \\sum_{t=1}^{n} X_{t}, \\qquad\n\\hat{\\gamma}_{k} = \\frac{1}{n} \\sum_{t=k+1}^{n} (X_{t} - \\hat{\\mu})(X_{t-k} - \\hat{\\mu}).\n$$\n\n- 样本自相关序列 $\\hat{\\rho}_{k} = \\hat{\\gamma}_{k}/\\hat{\\gamma}_{0}$，其中 $k=0,1,\\dots,K$。\n\n- 通过将 Levinson–Durbin 递归应用于 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$ 来计算样本 PACF $\\{\\hat{\\alpha}_{k}\\}_{k=1}^{K}$。\n\n每个模拟序列的验证标准必须按如下方式计算：\n\n- 定义 $K$ 为诊断检验的最大滞后阶数。\n\n- 如果以下两个条件都成立，则声明 ACF 具有“清晰的正弦模式”：\n  1. 在丢弃掉绝对值小于容差 $\\varepsilon$ 的项之后，序列 $\\{\\hat{\\rho}_{k}\\}_{k=1}^{K}$ 中符号变化的次数至少为 $S_{\\min}$。\n  2. 幅值呈衰减趋势，即 $|\\hat{\\rho}_{K}|  |\\hat{\\rho}_{1}|$。\n\n- 通过验证 PACF 对于 $\\text{AR}(2)$ 模型在滞后 2 阶后有效截断，来声明其“不具有正弦模式”，操作化为\n$$\n\\max_{k \\in \\{3,4,\\dots,K\\}} |\\hat{\\alpha}_{k}| \\le \\tau,\n$$\n其中 $\\tau$ 为选定的容差。\n\n测试套件：\n\n你必须精确运行以下三个案例，其中每个元组指定了 $(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in})$：\n\n- 案例 1：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.5,\\, -0.75,\\, 600,\\, 20,\\, 123,\\, 500 \\,)$。\n\n- 案例 2：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.2,\\, -0.64,\\, 400,\\, 20,\\, 456,\\, 500 \\,)$。\n\n- 案例 3：$(\\phi_{1}, \\phi_{2}, n, K, \\text{seed}, \\text{burn\\_in}) = (\\, 1.6,\\, -0.85,\\, 300,\\, 20,\\, 789,\\, 500 \\,)$。\n\n在上述标准中使用 $\\varepsilon = 0.05$，$S_{\\min} = 3$ 和 $\\tau = 0.30$。\n\n对于每个案例，输出一个布尔值，当且仅当两个诊断条件都满足时为真：即 ACF 根据上述规则是正弦的，并且 PACF 在滞后 2 阶之后在容差 $\\tau$ 内有效截断，因此不呈现正弦模式。\n\n最终输出格式：\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，例如 $[\\text{result1},\\text{result2},\\text{result3}]$，其中每个条目是按顺序对应于上述三个案例的布尔值。\n\n在此任务中，不应报告任何物理单位或角度作为输出。如果理论上出现任何内部角度，请以弧度解释，但不要输出任何角度。", "solution": "问题陈述已经过验证。所有给定的条件、定义和约束都已被提取和分析。该问题被认为是具有科学依据、提法恰当且客观的。这是一个计算时间序列分析中的标准练习，特别关注自回归模型的性质。测试案例的参数被选择以满足指定的平稳性和振荡行为条件。对于一个 $\\text{AR}(2)$ 过程 $X_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t}$，平稳性要求特征多项式 $1 - \\phi_{1} z - \\phi_{2} z^{2} = 0$ 的根位于单位圆之外。这等价于条件 $\\phi_{1} + \\phi_{2}  1$、$\\phi_{2} - \\phi_{1}  1$ 和 $|\\phi_{2}|  1$。导致正弦自相关函数的振荡行为，要求根为复数，这在 $\\phi_{1}^{2} + 4\\phi_{2}  0$ 时发生。所有三个提供的参数集 $(\\phi_{1}, \\phi_{2})$ 都满足这些条件。因此，该问题被认为是有效的，并将构建一个解决方案。\n\n任务是模拟一个二阶自回归（$\\text{AR}(2)$）过程，并验证其样本统计量符合理论预期。具体来说，对于一个具有复数特征根的 $\\text{AR}(2)$ 过程，理论自相关函数（ACF）表现出类似于阻尼正弦波的行为，而偏自相关函数（PACF）在滞后 2 阶后截断。我们将从第一性原理实现必要的算法，以验证给定样本数据的这种行为。\n\n首先，我们模拟由 $X_{t} = \\phi_{1} X_{t-1} + \\phi_{2} X_{t-2} + \\varepsilon_{t}$ 定义的 $\\text{AR}(2)$ 过程，其中 $\\varepsilon_{t}$ 是一个均值为 $0$、方差为 $\\sigma^2=1$ 的白噪声过程。使用一个预烧期（burn-in period）以确保模拟序列近似于一个弱平稳过程。初始值 $X_0$ 和 $X_{-1}$ 设置为 $0$。在生成总共 $n + \\text{burn\\_in}$ 个点后，丢弃前 $\\text{burn\\_in}$ 个样本，留下一个长度为 $n$ 的序列。\n\n接下来，我们计算样本统计量。样本均值估计为 $\\hat{\\mu} = \\frac{1}{n} \\sum_{t=1}^{n} X_{t}$。使用它，我们根据指定公式计算样本自协方差序列 $\\{\\hat{\\gamma}_{k}\\}_{k=0}^{K}$：\n$$\n\\hat{\\gamma}_{k} = \\frac{1}{n} \\sum_{t=k+1}^{n} (X_{t} - \\hat{\\mu})(X_{t-k} - \\hat{\\mu})\n$$\n这是一个有偏估计量，因为求和项包含 $n-k$ 个项，而除数是 $n$。然后，样本自相关函数（ACF）计算为 $\\hat{\\rho}_{k} = \\hat{\\gamma}_{k}/\\hat{\\gamma}_{0}$，滞后阶数为 $k=0, 1, \\dots, K$。\n\n分析的核心是计算样本偏自相关函数（PACF），记作 $\\{\\hat{\\alpha}_{k}\\}_{k=1}^{K}$。滞后 $k$ 的 PACF，$\\alpha_k$，被定义为拟合到数据的 $k$ 阶自回归模型中的最后一个系数 $\\phi_{k,k}$。这些系数由 Yule–Walker 方程确定，该方程将模型系数与自相关联系起来：\n$$\n\\begin{pmatrix} 1  \\rho_1  \\dots  \\rho_{k-1} \\\\ \\rho_1  1  \\dots  \\rho_{k-2} \\\\ \\vdots  \\vdots  \\ddots  \\vdots \\\\ \\rho_{k-1}  \\rho_{k-2}  \\dots  1 \\end{pmatrix} \\begin{pmatrix} \\phi_{k,1} \\\\ \\phi_{k,2} \\\\ \\vdots \\\\ \\phi_{k,k} \\end{pmatrix} = \\begin{pmatrix} \\rho_1 \\\\ \\rho_2 \\\\ \\vdots \\\\ \\rho_k \\end{pmatrix}\n$$\n我们使用计算上高效的 Levinson–Durbin 递归，对每个滞后 $k=1, \\dots, K$ 求解该系统的 $\\phi_{k,k}$。给定样本自相关 $\\{\\hat{\\rho}_k\\}$，样本 PACF 系数 $\\{\\hat{\\alpha}_k = \\hat{\\phi}_{k,k}\\}$ 被递归计算。\n当 $k=1$ 时：\n$$ \\hat{\\alpha}_1 = \\hat{\\phi}_{1,1} = \\hat{\\rho}_1 $$\n当 $k  1$ 时：\n$$ \\hat{\\alpha}_k = \\hat{\\phi}_{k,k} = \\frac{\\hat{\\rho}_k - \\sum_{j=1}^{k-1} \\hat{\\phi}_{k-1,j} \\hat{\\rho}_{k-j}}{1 - \\sum_{j=1}^{k-1} \\hat{\\phi}_{k-1,j} \\hat{\\rho}_{j}} $$\n中间 $\\text{AR}(k)$ 模型的其他系数更新如下：\n$$ \\hat{\\phi}_{k,j} = \\hat{\\phi}_{k-1,j} - \\hat{\\alpha}_k \\hat{\\phi}_{k-1,k-j} \\quad \\text{for } j=1, \\dots, k-1 $$\n该算法对 $k=1, \\dots, K$ 迭代应用，以获得完整的样本 PACF 序列。\n\n最后，我们应用指定的验证标准。如果满足两个条件，则认为 ACF 具有“清晰的正弦模式”：\n1. 序列 $\\{\\hat{\\rho}_{k}\\}_{k=1}^{K}$ 中符号变化的次数，仅考虑 $|\\hat{\\rho}_{k}| \\ge \\varepsilon = 0.05$ 的项，必须至少为 $S_{\\min} = 3$。\n2. 幅值必须表现出整体衰减，具体为 $|\\hat{\\rho}_{K}|  |\\hat{\\rho}_{1}|$。\n\n如果 PACF 在真实模型阶数 2 之后有效截断，则声明其“不具有正弦模式”。这通过条件来检验：\n$$ \\max_{k \\in \\{3,4,\\dots,K\\}} |\\hat{\\alpha}_{k}| \\le \\tau $$\n其中容差为 $\\tau = 0.30$。\n\n一个测试案例当且仅当 ACF 和 PACF 标准都满足时才通过验证。对提供的三个测试案例中的每一个都执行该程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef generate_ar2_series(phi1, phi2, n, burn_in, seed):\n    \"\"\"\n    Simulates a zero-mean AR(2) process.\n\n    Args:\n        phi1 (float): The first AR coefficient.\n        phi2 (float): The second AR coefficient.\n        n (int): The length of the output series.\n        burn_in (int): The number of initial points to discard.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        numpy.ndarray: The simulated AR(2) time series of length n.\n    \"\"\"\n    total_len = n + burn_in\n    rng = np.random.default_rng(seed)\n    epsilon = rng.normal(loc=0.0, scale=1.0, size=total_len)\n    \n    x = np.zeros(total_len)\n    # Initial values are X_0=0, X_{-1}=0, so first two terms are just noise\n    if total_len > 0:\n        x[0] = epsilon[0]\n    if total_len > 1:\n        x[1] = phi1 * x[0] + epsilon[1]\n\n    for t in range(2, total_len):\n        x[t] = phi1 * x[t-1] + phi2 * x[t-2] + epsilon[t]\n        \n    return x[burn_in:]\n\ndef compute_acf_pacf(series, K):\n    \"\"\"\n    Computes sample ACF and PACF from first principles using Levinson-Durbin.\n\n    Args:\n        series (numpy.ndarray): The time series data.\n        K (int): The maximum lag to compute.\n\n    Returns:\n        tuple: A tuple containing:\n            - numpy.ndarray: The sample ACF up to lag K.\n            - numpy.ndarray: The sample PACF up to lag K.\n    \"\"\"\n    n = len(series)\n    mu_hat = np.mean(series)\n    demeaned_series = series - mu_hat\n\n    # Sample Autocovariance\n    gamma_hat = np.zeros(K + 1)\n    for k in range(K + 1):\n        # As per problem: (1/n) * sum_{t=k+1 to n} ...\n        # which involves n-k terms\n        gamma_hat[k] = (1/n) * np.sum(demeaned_series[k:] * demeaned_series[:n-k])\n\n    # Sample Autocorrelation\n    rho_hat = gamma_hat / gamma_hat[0]\n\n    # Sample Partial Autocorrelation (Levinson-Durbin recursion)\n    pacf = np.zeros(K + 1)\n    phi = np.zeros(K + 1)\n    \n    for k in range(1, K + 1):\n        # Calculate phi_k,k which is the PACF at lag k\n        num_sum = np.dot(phi[1:k], rho_hat[k-1:0:-1])\n        den_sum = np.dot(phi[1:k], rho_hat[1:k])\n        \n        phi_kk = (rho_hat[k] - num_sum) / (1 - den_sum)\n        pacf[k] = phi_kk\n        \n        # Update phi coefficients for the next iteration\n        phi_old = phi[1:k].copy()\n        phi[k] = phi_kk\n        phi[1:k] = phi_old - phi_kk * phi_old[::-1]\n\n    return rho_hat, pacf\n\ndef verify_criteria(rho_hat, pacf, K, epsilon, S_min, tau):\n    \"\"\"\n    Verifies the conditions for ACF and PACF patterns.\n\n    Args:\n        rho_hat (numpy.ndarray): The sample ACF.\n        pacf (numpy.ndarray): The sample PACF.\n        K (int): The maximum lag.\n        epsilon (float): Threshold for ACF magnitude.\n        S_min (int): Minimum number of sign changes for ACF.\n        tau (float): Threshold for PACF cutoff.\n\n    Returns:\n        bool: True if all criteria are met, False otherwise.\n    \"\"\"\n    # 1. ACF sinusoidal pattern verification\n    acf_is_sinusoidal = False\n    \n    # Condition 1.1: Sign changes\n    rho_filtered = [r for r in rho_hat[1:K+1] if np.abs(r) >= epsilon]\n    num_sign_changes = 0\n    if len(rho_filtered) > 1:\n        for i in range(len(rho_filtered) - 1):\n            if np.sign(rho_filtered[i]) != np.sign(rho_filtered[i+1]):\n                num_sign_changes += 1\n    \n    # Condition 1.2: Magnitude decay\n    magnitude_decay = np.abs(rho_hat[K])  np.abs(rho_hat[1])\n    \n    if num_sign_changes >= S_min and magnitude_decay:\n        acf_is_sinusoidal = True\n\n    # 2. PACF cutoff verification\n    pacf_cuts_off = False\n    if K >= 3:\n        max_abs_pacf_tail = np.max(np.abs(pacf[3:K+1]))\n        if max_abs_pacf_tail = tau:\n            pacf_cuts_off = True\n    else: # If K  3, criteria cannot be checked, so it is considered not met.\n        pacf_cuts_off = False\n\n    return acf_is_sinusoidal and pacf_cuts_off\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    test_cases = [\n        # (phi1, phi2, n, K, seed, burn_in)\n        (1.5, -0.75, 600, 20, 123, 500),\n        (1.2, -0.64, 400, 20, 456, 500),\n        (1.6, -0.85, 300, 20, 789, 500),\n    ]\n\n    epsilon = 0.05\n    S_min = 3\n    tau = 0.30\n\n    results = []\n    for case in test_cases:\n        phi1, phi2, n, K, seed, burn_in = case\n        \n        # 1. Simulate the AR(2) process\n        series = generate_ar2_series(phi1, phi2, n, burn_in, seed)\n        \n        # 2. Compute sample ACF and PACF from first principles\n        rho_hat, pacf_hat = compute_acf_pacf(series, K)\n        \n        # 3. Verify conditions\n        result = verify_criteria(rho_hat, pacf_hat, K, epsilon, S_min, tau)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2373131"}, {"introduction": "在理解了模型参数如何决定其相关性结构之后，我们可以反向思考：能否从相关性结构反推出模型参数？这个练习将带你完成这一概念闭环。通过求解尤尔-沃克（Yule-Walker）方程组，你将利用已知的理论ACF值来精确求解一个自回归（AR）模型的系数[@problem_id:2373109]。这不仅巩固了ACF与模型参数之间的深刻联系，也揭示了参数估计方法的核心原理。", "problem": "考虑一个零均值、协方差平稳的 $p$ 阶自回归 (AR) 过程 (Autoregressive (AR)($p$))，定义为 $X_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t$，其中 $\\{\\varepsilon_t\\}$ 是一个方差为 $\\sigma^2_\\varepsilon$ 的白噪声序列。令理论自协方差函数为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$，理论自相关函数 (Autocorrelation Function (ACF)) 为 $\\rho_k = \\gamma_k / \\gamma_0$，且 $\\rho_0 = 1$。将 $\\{\\phi_i\\}_{i=1}^p$ 与 $\\{\\rho_k\\}_{k=1}^p$ 联系起来的总体矩条件是，对于每个 $k \\in \\{1,\\dots,p\\}$，\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i},\n$$\n并满足对称条件 $\\rho_{-k} = \\rho_k$。等价地，这个方程组可以写成一个托普利茨 (Toeplitz) 线性系统\n$$\nR \\,\\boldsymbol{\\phi} = \\boldsymbol{r},\n$$\n其中 $R \\in \\mathbb{R}^{p \\times p}$ 的元素为 $R_{ij} = \\rho_{|i-j|}$，$i,j \\in \\{1,\\dots,p\\}$，$\\boldsymbol{\\phi} = [\\phi_1,\\dots,\\phi_p]^\\top$ 且 $\\boldsymbol{r} = [\\rho_1,\\dots,\\rho_p]^\\top$。\n\n您的任务是通过求解上述线性系统，为以下每个测试用例精确计算 $\\boldsymbol{\\phi}$。在报告数值时，每个分量必须四舍五入到 $6$ 位小数。最终输出必须将所有结果汇总到一行，形式为列表的列表，其中每个内部列表包含该测试用例的 $p$ 个系数，顺序为 $[\\phi_1,\\dots,\\phi_p]$。\n\n测试套件：\n- 情况 $1$：$p = 1$，$(\\rho_1) = (0.6)$。\n- 情况 $2$：$p = 1$，$(\\rho_1) = (0.99)$。\n- 情况 $3$：$p = 1$，$(\\rho_1) = (-0.75)$。\n- 情况 $4$：$p = 2$，$(\\rho_1,\\rho_2) = (0.625,\\,0.5125)$。\n- 情况 $5$：$p = 2$，$(\\rho_1,\\rho_2) = (0.8,\\,0.46)$。\n- 情况 $6$：$p = 3$，$(\\rho_1,\\rho_2,\\rho_3) = (0.42105263157894735,\\,0.3684210526315789,\\,0.29473684210526313)$。\n\n要求的最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的列表的列表，每个数字都四舍五入到 $6$ 位小数。例如，一个有效的输出看起来像 $[[a_{11},\\dots,a_{1p_1}],[a_{21},\\dots,a_{2p_2}],\\dots]$，其中每个 $a_{ij}$ 是一个恰好有 $6$ 位小数的浮点数。", "solution": "该问题要求针对几组给定的理论自相关函数 (ACF) 值 $\\{\\rho_k\\}$，计算一个零均值、协方差平稳的 $p$ 阶自回归过程（记为 AR($p$)）的系数 $\\boldsymbol{\\phi} = [\\phi_1, \\dots, \\phi_p]^\\top$。\n\nAR($p$) 过程由以下随机差分方程定义：\n$$\nX_t = \\sum_{i=1}^p \\phi_i X_{t-i} + \\varepsilon_t\n$$\n其中 $\\{\\varepsilon_t\\}$ 是一个均值为 $0$、方差为 $\\sigma^2_\\varepsilon$ 的白噪声过程。项 $\\varepsilon_t$ 与该过程的过去值 $X_{t-k}$（对于 $k0$）不相关。\n\n滞后 $k$ 阶的自协方差 $\\gamma_k$ 定义为 $\\gamma_k = \\mathbb{E}[X_t X_{t-k}]$。为了找出系数 $\\phi_i$ 和自协方差之间的关系，我们将 AR($p$) 方程两边同乘以 $X_{t-k}$（对于 $k \\in \\{1, \\dots, p\\}$）并取期望：\n$$\n\\mathbb{E}[X_t X_{t-k}] = \\mathbb{E}\\left[\\left(\\sum_{i=1}^p \\phi_i X_{t-i}\\right) X_{t-k}\\right] + \\mathbb{E}[\\varepsilon_t X_{t-k}]\n$$\n根据白噪声的性质，当 $k  0$ 时，最后一项 $\\mathbb{E}[\\varepsilon_t X_{t-k}]$ 为 $0$。这得到：\n$$\n\\gamma_k = \\sum_{i=1}^p \\phi_i \\mathbb{E}[X_{t-i} X_{t-k}] = \\sum_{i=1}^p \\phi_i \\gamma_{k-i}\n$$\n自相关函数 (ACF) $\\rho_k$ 定义为 $\\rho_k = \\gamma_k / \\gamma_0$。将上述方程两边同除以方差 $\\gamma_0$，得到尤尔-沃克 (Yule-Walker) 方程：\n$$\n\\rho_k = \\sum_{i=1}^p \\phi_i \\rho_{k-i}\n$$\n这些方程对 $k \\in \\{1, \\dots, p\\}$ 成立。我们使用 ACF 的性质：对于任意整数 $k$，$\\rho_0 = 1$ 且 $\\rho_{-k} = \\rho_k$。\n\n问题指出，这个包含 $p$ 个未知数 $\\{\\phi_i\\}_{i=1}^p$ 的 $p$ 元线性方程组可以写成矩阵形式 $R \\boldsymbol{\\phi} = \\boldsymbol{r}$。让我们为一般的 $p$ 展开这个方程组：\n当 $k=1$ 时: $\\rho_1 = \\phi_1\\rho_0 + \\phi_2\\rho_{-1} + \\dots + \\phi_p\\rho_{1-p} = \\phi_1\\rho_0 + \\phi_2\\rho_1 + \\dots + \\phi_p\\rho_{p-1}$\n当 $k=2$ 时: $\\rho_2 = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{2-p} = \\phi_1\\rho_1 + \\phi_2\\rho_0 + \\dots + \\phi_p\\rho_{p-2}$\n...\n当 $k=p$ 时: $\\rho_p = \\phi_1\\rho_{p-1} + \\phi_2\\rho_{p-2} + \\dots + \\phi_p\\rho_0$\n\n其矩阵形式为：\n$$\n\\begin{pmatrix}\n\\rho_0  \\rho_1  \\rho_2  \\dots  \\rho_{p-1} \\\\\n\\rho_1  \\rho_0  \\rho_1  \\dots  \\rho_{p-2} \\\\\n\\rho_2  \\rho_1  \\rho_0  \\dots  \\rho_{p-3} \\\\\n\\vdots  \\vdots  \\vdots  \\ddots  \\vdots \\\\\n\\rho_{p-1}  \\rho_{p-2}  \\rho_{p-3}  \\dots  \\rho_0\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3 \\\\\n\\vdots \\\\\n\\phi_p\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3 \\\\\n\\vdots \\\\\n\\rho_p\n\\end{pmatrix}\n$$\n矩阵 $R$ 是一个对称的托普利茨 (Toeplitz) 矩阵，其元素为 $R_{ij} = \\rho_{|i-j|}$（对 $i,j \\in \\{1,\\dots,p\\}$ 使用 1-based 索引），且 $\\rho_0=1$。向量 $\\boldsymbol{r}$ 是 $[\\rho_1, \\dots, \\rho_p]^\\top$。任务是为每个测试用例求解这个线性系统 $\\boldsymbol{\\phi} = R^{-1}\\boldsymbol{r}$。\n\n**情况 1：** $p=1$，$(\\rho_1) = (0.6)$。\n该系统为 $[\\rho_0][\\phi_1] = [\\rho_1]$，简化为 $1 \\cdot \\phi_1 = 0.6$。因此，$\\phi_1 = 0.6$。\n\n**情况 2：** $p=1$，$(\\rho_1) = (0.99)$。\n该系统为 $1 \\cdot \\phi_1 = 0.99$。因此，$\\phi_1 = 0.99$。\n\n**情况 3：** $p=1$，$(\\rho_1) = (-0.75)$。\n该系统为 $1 \\cdot \\phi_1 = -0.75$。因此，$\\phi_1 = -0.75$。\n\n**情况 4：** $p=2$，$(\\rho_1, \\rho_2) = (0.625, 0.5125)$。\n该系统为 $\\begin{pmatrix} 1  0.625 \\\\ 0.625  1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.625 \\\\ 0.5125 \\end{pmatrix}$。\n求解该系统得到 $\\phi_1 = 0.5$ 和 $\\phi_2 = 0.2$。\n\n**情况 5：** $p=2$，$(\\rho_1, \\rho_2) = (0.8, 0.46)$。\n该系统为 $\\begin{pmatrix} 1  0.8 \\\\ 0.8  1 \\end{pmatrix} \\begin{pmatrix} \\phi_1 \\\\ \\phi_2 \\end{pmatrix} = \\begin{pmatrix} 0.8 \\\\ 0.46 \\end{pmatrix}$。\n求解该系统得到 $\\phi_1 = 1.2$ 和 $\\phi_2 = -0.5$。\n\n**情况 6：** $p=3$, $(\\rho_1, \\rho_2, \\rho_3) = (0.42105263157894735, 0.3684210526315789, 0.29473684210526313)$。\n令 $\\rho_1 \\approx 0.421$，$\\rho_2 \\approx 0.368$，$\\rho_3 \\approx 0.295$。该系统为：\n$$\n\\begin{pmatrix}\n1  \\rho_1  \\rho_2 \\\\\n\\rho_1  1  \\rho_1 \\\\\n\\rho_2  \\rho_1  1\n\\end{pmatrix}\n\\begin{pmatrix}\n\\phi_1 \\\\\n\\phi_2 \\\\\n\\phi_3\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n\\rho_1 \\\\\n\\rho_2 \\\\\n\\rho_3\n\\end{pmatrix}\n$$\n使用提供的 $\\rho_k$ 高精度值求解这个 $3 \\times 3$ 线性系统，得到 $\\phi_1 = 0.2$，$\\phi_2 = 0.3$ 和 $\\phi_3 = 0.1$。\n\n所需的 Python 代码将为每组参数实现一个该系统的通用求解器。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the AR(p) coefficients phi given the theoretical autocorrelations rho_k\n    by solving the Yule-Walker equations in their matrix form R*phi = r.\n    \"\"\"\n    test_cases = [\n        {'p': 1, 'rho': [0.6]},\n        {'p': 1, 'rho': [0.99]},\n        {'p': 1, 'rho': [-0.75]},\n        {'p': 2, 'rho': [0.625, 0.5125]},\n        {'p': 2, 'rho': [0.8, 0.46]},\n        {'p': 3, 'rho': [0.42105263157894735, 0.3684210526315789, 0.29473684210526313]}\n    ]\n\n    all_phis = []\n\n    for case in test_cases:\n        p = case['p']\n        rho_k = case['rho']\n\n        # The vector r is [rho_1, ..., rho_p]^T\n        r = np.array(rho_k)\n\n        # The matrix R is a symmetric Toeplitz matrix R_ij = rho_{|i-j|}\n        # We need autocorrelations from rho_0 to rho_{p-1}.\n        # rho_0 is always 1.\n        rho_full = np.concatenate(([1.0], np.array(rho_k)))\n\n        # Construct the Toeplitz matrix R using scipy.linalg.toeplitz or manually.\n        # Manual construction:\n        R = np.zeros((p, p))\n        for i in range(p):\n            for j in range(p):\n                # Using 0-based indexing for numpy arrays\n                R[i, j] = rho_full[abs(i - j)]\n\n        # Solve the linear system R * phi = r for phi\n        phi = np.linalg.solve(R, r)\n        all_phis.append(phi)\n\n    # Format the final output string as a list of lists, with each number\n    # rounded to 6 decimal places.\n    formatted_results = []\n    for phi_vector in all_phis:\n        # Format each coefficient in the vector\n        formatted_phi = [f\"{x:.6f}\" for x in phi_vector]\n        # Create the string for the inner list\n        formatted_results.append(f\"[{','.join(formatted_phi)}]\")\n    \n    # Create the final output string for the outer list\n    final_output = f\"[{','.join(formatted_results)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "2373109"}]}