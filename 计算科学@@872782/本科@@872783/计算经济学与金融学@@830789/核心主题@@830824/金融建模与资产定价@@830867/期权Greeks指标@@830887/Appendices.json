{"hands_on_practices": [{"introduction": "尽管期权希腊字母的解析公式提供了理论上的精确值，但在实践中，我们常常依赖数值方法。这项练习要求你实现并比较解析法计算的希腊字母与通过有限差分法得到的近似值 [@problem_id:2416913]。通过分析近似误差如何随步长 $h$ 变化，你将亲身体验到截断误差与舍入误差之间的权衡，这是计算金融学中的一个基本概念。", "problem": "您需要编写一个完整且可运行的程序，在布莱克-斯科尔斯-默顿模型下（假设无风险利率为连续复利且无股息），评估一个欧式看涨期权的解析敏感度指标（希腊字母），并将其与当扰动大小 $h$ 趋近于零时的对称有限差分近似值进行比较。请遵循以下定义和约定。\n\n考虑一个欧式看涨期权，其标的资产价格为 $S0$，行权价为 $K0$，无风险利率 $r\\in\\mathbb{R}$（以年化小数表示），波动率 $\\sigma0$（以年化小数表示），以及到期时间 $T0$（以年为单位）。在布莱克-斯科尔斯-默顿模型下，期权价格 $C(S,K,r,\\sigma,T)$ 是良定义的，我们关注的希腊字母（相对于其自然变量）如下：\n- Delta $\\Delta := \\frac{\\partial C}{\\partial S}$，\n- Gamma $\\Gamma := \\frac{\\partial^2 C}{\\partial S^2}$，\n- Vega $\\mathcal{V} := \\frac{\\partial C}{\\partial \\sigma}$，\n- Theta $\\Theta := \\frac{\\partial C}{\\partial T}$，其中 $T$ 表示到期时间（注意这是关于 $T$ 的导数，而不是关于日历时间的导数），\n- Rho $\\mathrm{P} := \\frac{\\partial C}{\\partial r}$。\n\n您的程序必须：\n- 对于每个参数元组 $(S,K,r,\\sigma,T)$，使用无股息的布莱克-斯科尔斯-默顿框架计算 $\\Delta$、$\\Gamma$、$\\mathcal{V}$、$\\Theta$ 和 $\\mathrm{P}$ 的解析值。\n- 对于每个希腊字母，以及对于集合 $\\mathcal{H} = \\{10^{-1},10^{-2},10^{-3},10^{-4},10^{-5},10^{-6}\\}$ 中的每个扰动大小 $h$，当其良定义时，使用中心差分格式，根据其定义变量计算对称有限差分近似值。需使用的中心差分如下：\n  - 对于 $\\Delta$ 和 $\\Gamma$，对 $S$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\mathcal{V}$，对 $\\sigma$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\Theta$，对 $T$ 进行 $\\pm h$ 扰动，\n  - 对于 $\\mathrm{P}$，对 $r$ 进行 $\\pm h$ 扰动。\n- 强制执行定义域约束，以使受扰动的参数保持在其定义域内。具体来说，仅当相应的正负扰动能使参数保持在其有效定义域内时，才对某个希腊字母使用给定的 $h\\in\\mathcal{H}$。这些有效定义域为 $S\\pm h0$、$\\sigma\\pm h0$、$T\\pm h0$，而对 $r\\pm h$ 无限制。\n- 对于每个允许的 $h$，计算有限差分近似值与其解析希腊字母之间的绝对相对误差。如果解析值恰好等于 $0$，则将误差定义为绝对差。对于每个希腊字母，找出（在定义域约束允许的 $h$ 中）使该误差最小化的 $h\\in\\mathcal{H}$。如果在某个测试案例中，没有 $h$ 值对某个特定的希腊字母是允许的，则为该希腊字母报告一个非数值（non-number）。\n\n测试套件。您的程序必须对以下参数元组 $(S,K,r,\\sigma,T)$ 进行上述评估：\n- 案例 A（一般情况）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,1)$。\n- 案例 B（短期限）：$(S,K,r,\\sigma,T)=(100,100,0.05,0.2,0.01)$。\n- 案例 C（深度实值）：$(S,K,r,\\sigma,T)=(150,100,0.05,0.3,1.5)$。\n- 案例 D（深度虚值，低波动率）：$(S,K,r,\\sigma,T)=(50,100,0.01,0.05,2)$。\n\n所有利率和波动率必须作为小数处理（例如，使用 $0.05$ 而不是 $5$），时间 $T$ 必须以年为单位。\n\n要求的最终输出格式。您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试案例的结果必须是一个包含五个浮点数的列表，顺序为 $[\\Delta,\\Gamma,\\mathcal{V},\\Theta,\\mathrm{P}]$，分别代表每个希腊字母在上述标准下使误差最小化的扰动大小 $h\\in\\mathcal{H}$（如果不存在允许的 $h$，则为非数值）。因此，整体输出必须是一个包含四个此类列表的列表，顺序与案例 A 到 D 相同。例如，打印的结构必须类似于 $[[h\\_{\\Delta}^{(A)},h\\_{\\Gamma}^{(A)},h\\_{\\mathcal{V}}^{(A)},h\\_{\\Theta}^{(A)},h\\_{\\mathrm{P}}^{(A)}],[h\\_{\\Delta}^{(B)},\\dots],[h\\_{\\Delta}^{(C)},\\dots],[h\\_{\\Delta}^{(D)},\\dots]]$，并用数值替换。", "solution": "该问题要求在布莱克-斯科尔斯-默顿 (BSM) 框架内，实现并比较用于计算欧式看涨期权敏感度指标（即“希腊字母”）的解析方法和数值方法。该问题的有效性得到了肯定，因为它基于金融数学和数值分析的基本原理。问题设定良好、客观，并包含了获得唯一解所需的所有信息。\n\n解决方案分三个阶段进行。首先，我们介绍期权价格及其相关希腊字母的解析公式。其次，我们定义用于其数值近似的有限差分格式。最后，我们详细说明比较这些方法并为每种情况确定最佳数值步长 $h$ 的算法。\n\n**1. 布莱克-斯科尔斯-默顿模型**\n\n一个基于无股息支付的标的资产的欧式看涨期权价格 $C$ 由 BSM 公式给出：\n$$\nC(S, K, r, \\sigma, T) = S N(d_1) - K e^{-rT} N(d_2)\n$$\n其中参数为：\n- $S$：标的资产的当前价格 $(S0)$\n- $K$：期权的行权价 $(K0)$\n- $r$：连续复利的无风险利率\n- $\\sigma$：标的资产回报率的波动率 $(\\sigma0)$\n- $T$：到期时间，以年为单位 $(T0)$\n\n函数 $N(\\cdot)$、$d_1$ 和 $d_2$ 定义如下：\n- $N(x)$：标准正态分布的累积分布函数 (CDF)，$N(x) = \\int_{-\\infty}^{x} \\phi(z) dz$，其中 $\\phi(z) = \\frac{1}{\\sqrt{2\\pi}}e^{-z^2/2}$ 是其概率密度函数 (PDF)。\n- $d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n- $d_2 = d_1 - \\sigma \\sqrt{T} = \\frac{\\ln(S/K) + (r - \\frac{1}{2}\\sigma^2)T}{\\sigma \\sqrt{T}}$\n\n**2. 希腊字母的解析公式**\n\n希腊字母是期权价格 $C$ 对其参数的偏导数。问题中指定的希腊字母的解析公式如下：\n\n- **Delta ($\\Delta$)：** 期权价格相对于标的资产价格 $S$ 的变化率。\n$$\n\\Delta = \\frac{\\partial C}{\\partial S} = N(d_1)\n$$\n\n- **Gamma ($\\Gamma$)：** Delta 相对于 $S$ 的变化率。它是 $C$ 相对于 $S$ 的二阶偏导数。\n$$\n\\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{\\phi(d_1)}{S\\sigma\\sqrt{T}}\n$$\n\n- **Vega ($\\mathcal{V}$):** 期权价格相对于波动率 $\\sigma$ 的变化率。\n$$\n\\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S\\phi(d_1)\\sqrt{T}\n$$\n\n- **Theta ($\\Theta$):** 期权价格相对于到期时间 $T$ 的变化率。根据问题规定，这是 $\\frac{\\partial C}{\\partial T}$，其符号与衡量日历时间流逝敏感度的传统 Theta 定义相反。\n$$\n\\Theta = \\frac{\\partial C}{\\partial T} = \\frac{S\\phi(d_1)\\sigma}{2\\sqrt{T}} + r K e^{-rT} N(d_2)\n$$\n\n- **Rho ($\\mathrm{P}$):** 期权价格相对于无风险利率 $r$ 的变化率。\n$$\n\\mathrm{P} = \\frac{\\partial C}{\\partial r} = K T e^{-rT} N(d_2)\n$$\n\n**3. 有限差分近似**\n\n我们采用对称有限差分格式来近似求导。对于一个函数 $f(x)$ 和一个小的扰动量 $h$：\n\n- 一阶导数由中心差分公式近似：\n$$\nf'(x) \\approx \\frac{f(x+h) - f(x-h)}{2h} \\quad (\\text{误差 } O(h^2))\n$$\n\n- 二阶导数由以下公式近似：\n$$\nf''(x) \\approx \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2} \\quad (\\text{误差 } O(h^2))\n$$\n\n将这些公式应用于期权价格函数 $C(\\cdot)$，得到以下希腊字母的近似值：\n\n- **Delta:** $\\Delta_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - C(S-h, \\dots)}{2h}$\n- **Gamma:** $\\Gamma_{\\text{FD}}(h) = \\frac{C(S+h, \\dots) - 2C(S, \\dots) + C(S-h, \\dots)}{h^2}$\n- **Vega:** $\\mathcal{V}_{\\text{FD}}(h) = \\frac{C(\\dots, \\sigma+h, \\dots) - C(\\dots, \\sigma-h, \\dots)}{2h}$\n- **Theta:** $\\Theta_{\\text{FD}}(h) = \\frac{C(\\dots, T+h) - C(\\dots, T-h)}{2h}$\n- **Rho:** $\\mathrm{P}_{\\text{FD}}(h) = \\frac{C(\\dots, r+h, \\dots) - C(\\dots, r-h, \\dots)}{2h}$\n\n**4. 算法流程**\n\n目标是从集合 $\\mathcal{H} = \\{10^{-1}, 10^{-2}, 10^{-3}, 10^{-4}, 10^{-5}, 10^{-6}\\}$ 中找到一个扰动大小 $h$，以使每个希腊字母的近似误差最小化。\n\n对于每个测试案例 $(S,K,r,\\sigma,T)$ 和每个希腊字母 $G \\in \\{\\Delta, \\Gamma, \\mathcal{V}, \\Theta, \\mathrm{P}\\}$，算法如下：\n\n1.  **计算解析值：** 使用第 2 节中的公式计算真实值 $G_{\\text{analytical}}$。\n2.  **迭代与评估：** 对于 $\\mathcal{H}$ 中的每个 $h$：\n    a. **验证定义域：** 检查扰动是否有效。对于变量 $x \\in \\{S, \\sigma, T\\}$ 且其定义域为 $x0$，条件是 $x-h  0$。如果不满足此条件，则当前的 $h$ 不可取，应跳过。对 $r$ 没有定义域约束。\n    b. **计算数值近似值：** 如果 $h$ 可取，则使用第 3 节中的公式计算有限差分近似值 $G_{\\text{FD}}(h)$。\n    c. **计算误差：** 计算误差。如果 $|G_{\\text{analytical}}|  \\epsilon$（其中 $\\epsilon$ 是一个很小的容差，如 $10^{-15}$），则使用绝对相对误差：\n    $$\n    \\text{Error}(h) = \\left| \\frac{G_{\\text{FD}}(h) - G_{\\text{analytical}}}{G_{\\text{analytical}}} \\right|\n    $$\n    否则，如果 $G_{\\text{analytical}} \\approx 0$，则使用绝对误差以避免除以零：\n    $$\n    \\text{Error}(h) = |G_{\\text{FD}}(h) - G_{\\text{analytical}}|\n    $$\n    d. **追踪最小值：** 将 $\\text{Error}(h)$ 与迄今为止找到的最小误差进行比较。如果更小，则将 $h$ 存储为当前最优的扰动大小。\n3.  **报告结果：** 遍历完 $\\mathcal{H}$ 中所有的 $h$ 后，存储的最优 $h$ 即为希腊字母 $G$ 的结果。如果没有可取的 $h$，则结果为非数值 (NaN)。\n\n对所有五个希腊字母和问题陈述中提供的所有四个测试案例重复此过程。最终的实现将此逻辑封装在一个 Python 脚本中。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Evaluates optimal finite-difference bump sizes for Black-Scholes-Merton Greeks.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (S, K, r, sigma, T)\n        (100.0, 100.0, 0.05, 0.20, 1.0),\n        # Case B\n        (100.0, 100.0, 0.05, 0.20, 0.01),\n        # Case C\n        (150.0, 100.0, 0.05, 0.30, 1.5),\n        # Case D\n        (50.0, 100.0, 0.01, 0.05, 2.0)\n    ]\n\n    H_SET = [1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6]\n    \n    def bsm_call_price(S, K, r, sigma, T):\n        \"\"\"Calculates the BSM price of a European call option.\"\"\"\n        # For T=0, the option price is its intrinsic value.\n        # Use a small tolerance for floating point comparisons.\n        if T = 1e-9:\n            return max(0.0, S - K)\n        \n        # If other parameters are non-positive, price is 0. This is enforced\n        # by the domain constraint checks on h, but is good practice.\n        if S = 0 or K = 0 or sigma = 0:\n            return 0.0\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def analytical_greeks(S, K, r, sigma, T):\n        \"\"\"Calculates the analytical values of BSM Greeks.\"\"\"\n        # As per problem, T > 0, so no need to handle T=0 case separately here.\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        phi_d1 = norm.pdf(d1)\n        cdf_d1 = norm.cdf(d1)\n        cdf_d2 = norm.cdf(d2)\n\n        delta = cdf_d1\n        gamma = phi_d1 / (S * sigma * np.sqrt(T))\n        vega = S * phi_d1 * np.sqrt(T)\n        # As per problem, Theta is dC/dT (time-to-maturity), not dC/dt (calendar time).\n        theta = (S * phi_d1 * sigma) / (2 * np.sqrt(T)) + r * K * np.exp(-r * T) * cdf_d2\n        rho = K * T * np.exp(-r * T) * cdf_d2\n\n        return {\n            'delta': delta, \n            'gamma': gamma, \n            'vega': vega, \n            'theta': theta, \n            'rho': rho\n        }\n\n    all_results = []\n    for S, K, r, sigma, T in test_cases:\n        case_results = []\n        greeks_ana = analytical_greeks(S, K, r, sigma, T)\n\n        # --- Delta and Gamma ---\n        min_error_delta, optimal_h_delta = float('inf'), np.nan\n        min_error_gamma, optimal_h_gamma = float('inf'), np.nan\n        ana_delta = greeks_ana['delta']\n        ana_gamma = greeks_ana['gamma']\n        price_0 = bsm_call_price(S, K, r, sigma, T)\n        for h in H_SET:\n            if S - h > 0:\n                price_p = bsm_call_price(S + h, K, r, sigma, T)\n                price_m = bsm_call_price(S - h, K, r, sigma, T)\n                \n                # Delta\n                approx_delta = (price_p - price_m) / (2 * h)\n                error_delta = abs((approx_delta - ana_delta) / ana_delta) if abs(ana_delta) > 1e-15 else abs(approx_delta - ana_delta)\n                if error_delta  min_error_delta:\n                    min_error_delta = error_delta\n                    optimal_h_delta = h\n                \n                # Gamma\n                approx_gamma = (price_p - 2 * price_0 + price_m) / (h**2)\n                error_gamma = abs((approx_gamma - ana_gamma) / ana_gamma) if abs(ana_gamma) > 1e-15 else abs(approx_gamma - ana_gamma)\n                if error_gamma  min_error_gamma:\n                    min_error_gamma = error_gamma\n                    optimal_h_gamma = h\n        case_results.extend([optimal_h_delta, optimal_h_gamma])\n        \n        # --- Vega ---\n        min_error_vega, optimal_h_vega = float('inf'), np.nan\n        ana_vega = greeks_ana['vega']\n        for h in H_SET:\n            if sigma - h > 0:\n                approx_vega = (bsm_call_price(S, K, r, sigma + h, T) - bsm_call_price(S, K, r, sigma - h, T)) / (2 * h)\n                error_vega = abs((approx_vega - ana_vega) / ana_vega) if abs(ana_vega) > 1e-15 else abs(approx_vega - ana_vega)\n                if error_vega  min_error_vega:\n                    min_error_vega = error_vega\n                    optimal_h_vega = h\n        case_results.append(optimal_h_vega)\n        \n        # --- Theta ---\n        min_error_theta, optimal_h_theta = float('inf'), np.nan\n        ana_theta = greeks_ana['theta']\n        for h in H_SET:\n            if T - h > 0:\n                approx_theta = (bsm_call_price(S, K, r, sigma, T + h) - bsm_call_price(S, K, r, sigma, T - h)) / (2 * h)\n                error_theta = abs((approx_theta - ana_theta) / ana_theta) if abs(ana_theta) > 1e-15 else abs(approx_theta - ana_theta)\n                if error_theta  min_error_theta:\n                    min_error_theta = error_theta\n                    optimal_h_theta = h\n        case_results.append(optimal_h_theta)\n        \n        # --- Rho ---\n        min_error_rho, optimal_h_rho = float('inf'), np.nan\n        ana_rho = greeks_ana['rho']\n        for h in H_SET:\n            # No domain constraint for r\n            approx_rho = (bsm_call_price(S, K, r + h, sigma, T) - bsm_call_price(S, K, r - h, T)) / (2 * h)\n            error_rho = abs((approx_rho - ana_rho) / ana_rho) if abs(ana_rho) > 1e-15 else abs(approx_rho - ana_rho)\n            if error_rho  min_error_rho:\n                min_error_rho = error_rho\n                optimal_h_rho = h\n        case_results.append(optimal_h_rho)\n        \n        all_results.append(case_results)\n\n    # Format the final output as a string representing a list of lists.\n    output_str = f\"[{','.join([f'[{\",\".join(map(str, res))}]' for res in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2416913"}, {"introduction": "期权希腊字母不仅是理论上的度量指标，更是构建复杂交易策略和管理风险的主要工具。这项练习将指导你构建一个经典的期权组合——日历价差，其目的是实现维加（Vega）中性，但伽马（Gamma）为正 [@problem_id:2416880]。你将学习如何组合不同的期权来分离并利用特定的市场观点，例如预期波动率将会上升。", "problem": "给定一个无摩擦市场，其中只有一种标的资产，其价格表示为 $S$。欧式期权在 Black–Scholes 框架下进行定价，该框架包含连续复利无风险利率 $r$、连续股息率 $q$ 以及恒定波动率 $\\sigma$。所有到期时间 $T$ 均以年为单位。所有利率和波动率必须以小数形式表示，而非百分比。\n\n考虑一个由两份欧式看涨期权构成的投资组合，这两份期权基于相同的标的资产，具有相同的行权价 $K$，但到期日不同，分别为 $T_1$ 和 $T_2$（其中 $T_1  T_2$）。投资组合的权重定义如下：短期看涨期权（到期日为 $T_1$）的头寸固定为 $w_1 = 1$（一个多头单位），长期看涨期权（到期日为 $T_2$）的头寸为 $w_2$（一个实数，可以为负）。投资组合相对于波动率期限结构微小平移的 Vega 定义为，当两个期权的波动率都发生相同微小变化时，投资组合价值相对于 $\\sigma$ 的导数。投资组合的 Gamma 定义为投资组合价值相对于 $S$ 的二阶导数。\n\n您的任务是，对于下方的每个测试用例，确定唯一的权重 $w_2$，使得在给定的 $S$ 下，投资组合的 Vega 恰好为零（即，在当前即期价格下，对于波动率期限结构的微小平移是 Vega 中性的），然后计算在该 $S$ 下由此产生的净 Gamma 和净 Vega。如果一个投资组合在 $S$ 处的净 Gamma 为正，则称其为“做多波动率”。\n\n请实现一个完整的程序，该程序能够：\n- 根据 Black–Scholes 模型，从第一性原理出发计算每个成分期权的 Vega 和 Gamma。\n- 在 $w_1 = 1$ 的情况下，确定使投资组合在给定 $S$ 下净 Vega 等于零的唯一 $w_2$。\n- 在给定 $S$ 下，评估由此产生的投资组合的净 Gamma 和净 Vega。\n\n使用以下参数集测试套件，每个参数集以元组 $(S,K,r,q,\\sigma,T_1,T_2)$ 的形式给出：\n- 测试 $1$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$100\\,,\\,\\$100\\,,\\,0.02\\,,\\,0.00\\,,\\,0.20\\,,\\,0.25\\,,\\,1.00\\,)$。\n- 测试 $2$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$50\\,,\\,\\$50\\,,\\,0.01\\,,\\,0.03\\,,\\,0.35\\,,\\,0.10\\,,\\,0.60\\,)$。\n- 测试 $3$：$(S,K,r,q,\\sigma,T_1,T_2) = (\\,\\$200\\,,\\,\\$200\\,,\\,0.00\\,,\\,0.05\\,,\\,0.15\\,,\\,0.05\\,,\\,0.50\\,)$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个 Python 风格的浮点数列表，按顺序为每个测试用例提供三个值：$w_2$、净 Gamma 和净 Vega。所有数字必须四舍五入到 $10$ 位小数。例如，整体结构必须是 $[w_{2,1},\\Gamma_1,\\text{Vega}_1,w_{2,2},\\Gamma_2,\\text{Vega}_2,w_{2,3},\\Gamma_3,\\text{Vega}_3]$ 的形式，其中条目之间用逗号分隔，没有多余的空格或文本。", "solution": "所呈现的问题陈述是有效的。它在 Black–Scholes 模型的既定框架内具有科学依据，数学上是适定的，并且以客观、明确的语言表述。所有必要的参数都已提供，且内部没有矛盾。因此，我们可以进行严谨的求解。\n\n该问题要求构建一个由两个欧式看涨期权组成的 Vega 中性投资组合，然后确定其净 Gamma。这些期权的定价和风险衡量由 Black–Scholes 模型决定。一个欧式看涨期权的价值 $C$ 取决于标的资产价格 $S$、行权价 $K$、到期时间 $T$、无风险利率 $r$、连续股息率 $q$ 和波动率 $\\sigma$。\n\n该模型的核心围绕项 $d_1$ 和 $d_2$ 展开，定义如下：\n$$ d_1 = \\frac{\\ln(S/K) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n期权的 Gamma ($\\Gamma$) 衡量期权 Delta 相对于标的价格 $S$ 的变化率，由下式给出：\n$$ \\Gamma = \\frac{\\partial^2 C}{\\partial S^2} = \\frac{e^{-qT}\\phi(d_1)}{S\\sigma\\sqrt{T}} $$\n期权的 Vega ($\\mathcal{V}$) 衡量期权价值对波动率 $\\sigma$ 变化的敏感度，由下式给出：\n$$ \\mathcal{V} = \\frac{\\partial C}{\\partial \\sigma} = S e^{-qT} \\sqrt{T} \\phi(d_1) $$\n在这些公式中，$\\phi(x)$ 表示标准正态分布的概率密度函数 (PDF)，$\\phi(x) = \\frac{1}{\\sqrt{2\\pi}}e^{-x^2/2}$。\n\n该投资组合由两个基于相同标的资产、具有相同行权价 $K$ 但不同到期日 $T_1$ 和 $T_2$（其中 $T_1  T_2$）的欧式看涨期权组成。短期期权（到期日为 $T_1$）的权重固定为 $w_1 = 1$。长期期权（到期日为 $T_2$）的权重为 $w_2$。\n\n投资组合的净 Gamma ($\\Gamma_P$) 和净 Vega ($\\mathcal{V}_P$) 是各期权风险指标的线性组合：\n$$ \\Gamma_P = w_1\\Gamma_1 + w_2\\Gamma_2 $$\n$$ \\mathcal{V}_P = w_1\\mathcal{V}_1 + w_2\\mathcal{V}_2 $$\n此处，$(\\Gamma_1, \\mathcal{V}_1)$ 是到期日为 $T_1$ 的期权的风险指标，而 $(\\Gamma_2, \\mathcal{V}_2)$ 是到期日为 $T_2$ 的期权的风险指标。\n\n主要目标是使投资组合达到 Vega 中性，即将其净 Vega 设为零。给定 $w_1 = 1$，我们施加条件：\n$$ \\mathcal{V}_P = 1 \\cdot \\mathcal{V}_1 + w_2\\mathcal{V}_2 = 0 $$\n对于任何 $T  0$ 的欧式期权，其 Vega ($\\mathcal{V}$) 严格为正。由于 $T_1$ 和 $T_2$ 均为正，因此 $\\mathcal{V}_2  0$，我们可以唯一地解出权重 $w_2$：\n$$ w_2 = -\\frac{\\mathcal{V}_1}{\\mathcal{V}_2} $$\n该权重 $w_2$ 代表为抵消一个多头单位的短期看涨期权的 Vega，而必须卖空的长期看涨期权的单位数。\n\n一旦确定了 $w_2$，我们就可以计算这个 Vega 中性投资组合的净 Gamma：\n$$ \\Gamma_P = \\Gamma_1 + w_2\\Gamma_2 = \\Gamma_1 - \\left(\\frac{\\mathcal{V}_1}{\\mathcal{V}_2}\\right)\\Gamma_2 $$\n根据构造，该投资组合的净 Vega 精确为零。由于浮点精度限制，数值计算可能会得出一个接近零的值，这是一个预期的结果。\n\n算法流程如下：\n$1$. 对于测试套件中的每一组参数 $(S, K, r, q, \\sigma, T_1, T_2)$，我们将首先为这两个期权分别计算 Gamma 和 Vega。这涉及计算各自的 $d_1$ 项，然后应用 $\\Gamma$ 和 $\\mathcal{V}$ 公式。\n$2$. 使用计算出的 Vegas, $\\mathcal{V}_1$ 和 $\\mathcal{V}_2$，我们确定权重 $w_2 = -\\mathcal{V}_1 / \\mathcal{V}_2$。\n$3$. 然后我们计算投资组合的净 Gamma, $\\Gamma_P = \\Gamma_1 + w_2\\Gamma_2$。\n$4$. 计算得到的净 Vega 将为 $\\mathcal{V}_P = \\mathcal{V}_1 + w_2\\mathcal{V}_2$，以确认其为零。\n$5$. 然后为每个测试用例存储三元组 $(w_2, \\Gamma_P, \\mathcal{V}_P)$。\n$6$. 最后，收集所有结果，格式化到要求的精度，并以指定的单行格式打印。\n该过程将用一个自包含的 Python 程序实现，利用 `numpy` 进行数值计算，并使用 `scipy.stats.norm` 获取标准正态分布的概率密度函数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes the weight w2 for a Vega-neutral portfolio of two European call options,\n    and the resulting portfolio's net Gamma and net Vega.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (S, K, r, q, sigma, T1, T2)\n        (100.0, 100.0, 0.02, 0.00, 0.20, 0.25, 1.00),\n        (50.0, 50.0, 0.01, 0.03, 0.35, 0.10, 0.60),\n        (200.0, 200.0, 0.00, 0.05, 0.15, 0.05, 0.50),\n    ]\n\n    results = []\n\n    def calculate_greeks(S, K, T, r, q, sigma):\n        \"\"\"\n        Calculates the Gamma and Vega of a European call option using Black-Scholes formulas.\n\n        Args:\n            S (float): Spot price of the underlying asset.\n            K (float): Strike price of the option.\n            T (float): Time to maturity in years.\n            r (float): Risk-free interest rate (decimal).\n            q (float): Continuous dividend yield (decimal).\n            sigma (float): Volatility of the underlying asset (decimal).\n\n        Returns:\n            tuple: A tuple containing the option's Gamma and Vega.\n        \"\"\"\n        # Ensure T > 0 to avoid division by zero\n        if T = 1e-9:\n            return 0.0, 0.0\n\n        sigma_sqrt_T = sigma * np.sqrt(T)\n        \n        # d1 calculation\n        d1 = (np.log(S / K) + (r - q + 0.5 * sigma**2) * T) / sigma_sqrt_T\n        \n        # Standard normal probability density function (PDF)\n        phi_d1 = norm.pdf(d1)\n        \n        # Gamma formula\n        gamma = np.exp(-q * T) * phi_d1 / (S * sigma_sqrt_T)\n        \n        # Vega formula\n        vega = S * np.exp(-q * T) * np.sqrt(T) * phi_d1\n        \n        return gamma, vega\n\n    # Process each test case\n    for S, K, r, q, sigma, T1, T2 in test_cases:\n        # Calculate greeks for the short-dated option (T1)\n        gamma1, vega1 = calculate_greeks(S, K, T1, r, q, sigma)\n        \n        # Calculate greeks for the long-dated option (T2)\n        gamma2, vega2 = calculate_greeks(S, K, T2, r, q, sigma)\n        \n        # Determine weight w2 for Vega neutrality (w1 is fixed at 1)\n        # The equation is V_p = 1*vega1 + w2*vega2 = 0\n        w2 = -vega1 / vega2\n        \n        # Calculate the net Gamma of the portfolio\n        net_gamma = gamma1 + w2 * gamma2\n        \n        # Calculate the net Vega of the portfolio (should be zero by construction)\n        net_vega = vega1 + w2 * vega2\n        \n        # Append the results for the current test case\n        results.extend([w2, net_gamma, net_vega])\n\n    # Format the results to 10 decimal places and join into a single string\n    formatted_results = [f\"{x:.10f}\" for x in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2416880"}, {"introduction": "标准的布莱克-斯科尔斯模型关于常数波动率的假设是一种简化，与现实市场存在偏差，在真实市场中“波动率微笑”是一个持续存在的特征。这项高级练习通过比较使用单一平价波动率的模型与包含完整波动率微笑的模型的定价和对冲表现，量化了这种简化的实际后果 [@problem_id:2416891]。这将加深你对模型风险以及使用更真实市场输入重要性的理解。", "problem": "给定一个包含单一标的资产和欧式看涨期权的市场。假设欧式期权的唯一定价（无套利价值）等于其在风险中性测度下的期望值。在此测度下，标的资产遵循几何布朗运动，其波动率参数为恒定值，等于期权的输入隐含波动率；无风险利率为连续复利；连续股息率为零。对于每个期权，将其敏感度指标（“希腊字母”）定义为其价值相对于各输入参数的相应偏导数：delta 是对标的资产现货价格的偏导数，gamma 是对标的资产现货价格的二阶偏导数，vega 是对输入波动率的偏导数，theta 是对到期时间的负偏导数，rho 是对无风险利率的偏导数。考虑以下常见的近似做法：对所有行权价，使用单一的平价（at-the-money）隐含波动率来计算所有期权价格和希腊字母，而不是使用依赖于行权价的隐含波动率微笑。\n\n标的资产的当前价格为 $S_0 = 100$，连续复利无风险利率为每年 $r = 0.02$，连续股息率为零，每个期权的到期时间为 $T = 0.5$ 年。行权价集合为 $K \\in \\{70,85,100,115,130\\}$。一个参数化的隐含波动率微笑通过以下公式将每个行权价 $K$ 映射到一个隐含波动率 $\\sigma(K)$：\n$$\n\\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2.\n$$\n对于每个测试用例，平价（ATM）隐含波动率为 $\\sigma_{\\text{ATM}} = \\sigma(S_0)$，并考虑两种估值和希腊字母计算方法：\n- 完整微笑方法：对每个行权价 $K$，使用该行权价特定的 $\\sigma(K)$。\n- 仅ATM方法：对每个行权价 $K$，都使用 $\\sigma_{\\text{ATM}}$。\n\n将在给定状态下，根据波动率微笑曲线，使用该状态下行权价特定的隐含波动率，并基于上述几何布朗运动模型计算出的唯一无套利价值，定义为任何期权的“真实”估值。在对冲方面，考虑单步 delta 对冲：在时间 $t=0$ 时，对于给定的行权价 $K$，卖空一份看涨期权，并买入 $\\Delta$ 单位的标的资产，其中 $\\Delta$ 是在 $t=0$ 时根据两种方法之一计算得出的。在发生以下情景冲击后，平仓并计算对冲的盈亏。\n\n所有测试用例的情景冲击都相同：\n- 标的资产价格变为 $S_1 = S_0 \\times (1 + u)$，其中 $u = 0.01$。\n- 隐含波动率微笑曲线发生 $d v = 0.01$ 的平行移动，因此行权价 $K$ 的新隐含波动率为 $\\sigma'(K) = \\sigma(K) + d v$。\n- 时间流逝 $\\Delta t = 1/252$ 年，因此到期期限变为 $T' = T - \\Delta t$。\n\n对于下文的每个测试用例，针对固定的行权价集合 $K \\in \\{70,85,100,115,130\\}$ 执行以下操作：\n1. 计算在时间 $t=0$ 时，使用仅ATM方法相对于完整微笑方法的均方根定价误差（RMSE），即\n$$\n\\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) - V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) \\big)^2 }.\n$$\n2. 对每种对冲方法，计算在情景冲击下的平均绝对 delta 对冲盈亏。对于给定的行权价 $K$，定义\n$$\n\\text{PnL}_{\\text{method}}(K) \\;=\\; V_{\\text{true}}(S_1,K,T',r,\\sigma'(K)) \\;-\\; V_{\\text{true}}(S_0,K,T,r,\\sigma(K)) \\;-\\; \\Delta_{\\text{method}}(S_0,K,T,r,\\cdot)\\,\\big(S_1 - S_0\\big),\n$$\n其中 $V_{\\text{true}}(\\cdot)$ 是在相应时间点使用该行权价在微笑曲线上的隐含波动率计算出的“真实”估值，$\\Delta_{\\text{method}}$ 是在 $t=0$ 时，根据仅ATM方法（所有 $K$ 均使用 $\\sigma_{\\text{ATM}}$）或完整微笑方法（每个 $K$ 使用各自的 $\\sigma(K)$）计算出的 delta，点 $\\cdot$ 表示该方法所适用的隐含波动率输入。令\n$$\n\\overline{A}_{\\text{ATM}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{ATM}}(K)\\big|,\\qquad\n\\overline{A}_{\\text{smile}} \\;=\\; \\frac{1}{5} \\sum_{K} \\big|\\text{PnL}_{\\text{smile}}(K)\\big|.\n$$\n报告比率\n$$\nR \\;=\\; \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}}.\n$$\n\n微笑参数 $(a,b,c)$ 的测试套件：\n- 用例 1：$(a,b,c) = (0.2,\\,0.0,\\,0.0)$。\n- 用例 2：$(a,b,c) = (0.2,\\,-0.05,\\,0.0)$。\n- 用例 3：$(a,b,c) = (0.2,\\,-0.05,\\,0.15)$。\n\n您的程序必须按给定顺序为每个用例计算实数对 $[\\text{RMSE}, R]$。您的程序应生成单行输出，其中包含一个以逗号分隔的列表，该列表被方括号括起，并按上述用例排序。每个用例的结果本身也是一个包含两个元素的、以逗号分隔的列表，并被方括号括起。例如，要求的输出格式为 $[[x_1,y_1],[x_2,y_2],[x_3,y_3]]$，其中 $x_i$ 和 $y_i$ 是用例 $i$ 所需的浮点数。不应打印任何额外文本。", "solution": "该问题是有效的。这是一个定义明确的量化金融问题，基于标准的 Black-Scholes-Merton 框架进行期权定价和对冲。所有参数、模型和计算过程都得到了明确的规定。\n\n该解决方案要求评估在用简化的波动率模型（恒定的平价波动率）替代更现实的、依赖于行权价的波动率微笑时，定价和对冲性能的下降情况。此评估将针对三种不同的微笑参数化进行。\n\n分析的核心是针对欧式看涨期权的 Black-Scholes-Merton (BSM) 模型。在问题陈述的假设（几何布朗运动、恒定无风险利率、无股息）下，欧式看涨期权的价格 $V_c$ 由以下公式给出：\n$$ V_c(S, K, T, r, \\sigma) = S N(d_1) - K e^{-rT} N(d_2) $$\n其中 $S$ 是标的资产的现货价格，$K$ 是行权价，$T$ 是以年为单位的到期时间，$r$ 是连续复利无风险利率，$\\sigma$ 是波动率。函数 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。项 $d_1$ 和 $d_2$ 定义如下：\n$$ d_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n看涨期权的 delta ($\\Delta$) 表示期权价格对标的资产价格变化的敏感度，是 $V_c$ 相对于 $S$ 的一阶偏导数：\n$$ \\Delta = \\frac{\\partial V_c}{\\partial S} = N(d_1) $$\n这个量是构建 delta 中性对冲的核心。\n\n问题将参数化波动率微笑定义为行权价 $K$ 的函数：\n$$ \\sigma(K) \\;=\\; a \\;+\\; b \\,\\ln\\!\\big(K/S_0\\big) \\;+\\; c \\,\\big(\\ln\\!\\big(K/S_0\\big)\\big)^2. $$\n\n解决方案通过对三个测试用例 $(a,b,c)$ 中的每一个执行所需的计算来进行。\n\n**步骤 1：计算均方根定价误差 (RMSE)**\n\n在初始时间 $t=0$ 时，我们有 $S_0 = 100$，$r = 0.02$，$T = 0.5$。对于每个行权价 $K \\in \\{70, 85, 100, 115, 130\\}$：\n1.  “完整微笑”波动率 $\\sigma(K)$ 使用给定的参数 $(a,b,c)$ 计算。相应的“真实”价格为 $V_{\\text{smile}}(S_0,K,T,r,\\sigma(K)) = V_c(S_0,K,T,r,\\sigma(K))$。\n2.  “仅ATM”波动率对所有行权价都是恒定的：$\\sigma_{\\text{ATM}} = \\sigma(S_0) = a$。近似价格为 $V_{\\text{ATM}}(S_0,K,T,r,\\sigma_{\\text{ATM}}) = V_c(S_0,K,T,r,a)$。\n3.  然后根据提供的公式，对这五个行权价的集合计算 RMSE：\n    $$ \\text{RMSE} \\;=\\; \\sqrt{\\frac{1}{5} \\sum_{K} \\big( V_{\\text{ATM}}(K) - V_{\\text{smile}}(K) \\big)^2 } $$\n\n**步骤 2：计算对冲性能比率 (R)**\n\n此步骤分析在特定市场冲击下单步 delta 对冲的盈亏 (PnL)。\n在 $t=0$ 时的初始投资组合包括一份看涨期权的空头头寸和 $\\Delta$ 股标的资产的多头头寸，其中 $\\Delta$ 是在 $t=0$ 时计算的。该投资组合的价值为 $P_0 = \\Delta S_0 - V_0$。\n\n冲击过后，在时间 $t_1$，新的市场状态为：\n-   标的资产价格：$S_1 = S_0 (1+u) = 100 \\times (1+0.01) = 101$。\n-   到期时间：$T' = T - \\Delta t = 0.5 - 1/252$。\n-   新的波动率微笑：$\\sigma'(K) = \\sigma(K) + dv = \\sigma(K) + 0.01$。\n\n在 $t_1$ 时期权的“真实”价值是 $V_{\\text{true},1}(K) = V_c(S_1, K, T', r, \\sigma'(K))$。在 $t_1$ 时对冲投资组合的价值是 $P_1 = \\Delta S_1 - V_{\\text{true},1}(K)$。\n该期间的盈亏为 $P_1 - P_0 = (\\Delta S_1 - V_{\\text{true},1}(K)) - (\\Delta S_0 - V_0) = V_0 - V_{\\text{true},1}(K) + \\Delta(S_1 - S_0)$，这与问题中提供的公式符号相反。符号约定不影响平均绝对盈亏。我们将使用给定的公式：\n$$ \\text{PnL}(K) = V_{\\text{true},1}(K) - V_{0}(K) - \\Delta(K)(S_1 - S_0) $$\n其中 $V_0(K)$ 是在 $t=0$ 时的“真实”价格，即 $V_{\\text{smile}}(K)$。\n\n比较两种不同的对冲策略：\n1.  **仅ATM对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{ATM}}(K) = N(d_1)$，使用 $\\sigma_{\\text{ATM}} = a$ 计算。相应的盈亏为 $\\text{PnL}_{\\text{ATM}}(K)$。\n2.  **完整微笑对冲**：$\\Delta_{\\text{method}} = \\Delta_{\\text{smile}}(K) = N(d_1)$，使用 $\\sigma(K)$ 计算。相应的盈亏为 $\\text{PnL}_{\\text{smile}}(K)$。\n\n对每种策略，计算平均绝对盈亏：\n$$ \\overline{A}_{\\text{ATM}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{ATM}}(K)| \\quad \\text{and} \\quad \\overline{A}_{\\text{smile}} = \\frac{1}{5} \\sum_{K} |\\text{PnL}_{\\text{smile}}(K)| $$\n最后，确定比率 $R$：\n$$ R = \\frac{\\overline{A}_{\\text{ATM}}}{\\overline{A}_{\\text{smile}}} $$\n该比率量化了因使用简化的仅ATM波动率模型而导致的平均对冲误差的增加。$R=1$ 的值意味着性能上没有差异，而 $R1$ 则表明仅ATM模型在对冲方面较差。对于用例 1，其中微笑曲线是平的（$b=c=0$），我们预计 $\\sigma(K) = \\sigma_{\\text{ATM}}$，这将导致 $\\text{RMSE}=0$ 和 $R=1$。\n\n该算法将使用 Python 实现，利用 `numpy` 进行高效的数组运算，并使用 `scipy.stats.norm` 计算标准正态累积分布函数。.", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option price using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming to avoid division by zero or log of non-positive\n    # This is important for very small T or sigma\n    d1 = np.full_like(S, np.inf, dtype=float)\n    d2 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9)  (T > 1e-9)\n    \n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    d2[valid_mask] = d1[valid_mask] - sigma_sqrt_T\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes European call option delta using the Black-Scholes-Merton model.\n    Vectorized to handle numpy arrays.\n    \"\"\"\n    # Defensive programming similar to price function\n    d1 = np.full_like(S, np.inf, dtype=float)\n    \n    valid_mask = (sigma > 1e-9)  (T > 1e-9)\n\n    sigma_sqrt_T = sigma[valid_mask] * np.sqrt(T)\n    d1[valid_mask] = (np.log(S[valid_mask] / K[valid_mask]) + (r + 0.5 * sigma[valid_mask]**2) * T) / sigma_sqrt_T\n    \n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main solver function to compute RMSE and hedging performance ratio R\n    for the given test cases.\n    \"\"\"\n    # Market and scenario parameters\n    S0 = 100.0\n    r = 0.02\n    T0 = 0.5\n    strikes = np.array([70.0, 85.0, 100.0, 115.0, 130.0])\n    num_strikes = len(strikes)\n\n    u_shock = 0.01\n    dv_shock = 0.01\n    dt_shock = 1.0 / 252.0\n\n    # Post-shock state\n    S1 = S0 * (1.0 + u_shock)\n    T1 = T0 - dt_shock\n    delta_S = S1 - S0\n\n    # Test suite of smile parameters\n    test_cases = [\n        (0.2, 0.0, 0.0),    # Case 1: Flat smile\n        (0.2, -0.05, 0.0),  # Case 2: Linear smile (skew)\n        (0.2, -0.05, 0.15), # Case 3: Quadratic smile (skew and convexity)\n    ]\n\n    results = []\n    \n    # Broadcast S0 and T0 to match the shape of strikes for vectorized calculations\n    S0_vec = np.full_like(strikes, S0)\n    S1_vec = np.full_like(strikes, S1)\n\n    for a, b, c in test_cases:\n        # --- Time t=0 calculations ---\n        \n        # Volatility calculations\n        log_moneyness = np.log(strikes / S0)\n        sigma_smile_t0 = a + b * log_moneyness + c * log_moneyness**2\n        sigma_atm_t0 = a  # This is a scalar\n        sigma_atm_t0_vec = np.full_like(strikes, sigma_atm_t0)\n\n        # 1. Compute RMSE\n        v_smile_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_smile_t0)\n        v_atm_t0 = bsm_call_price(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n        \n        rmse = np.sqrt(np.mean((v_atm_t0 - v_smile_t0)**2))\n        \n        # --- Hedging PnL calculations ---\n\n        # Deltas at t=0\n        delta_smile_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_smile_t0)\n        delta_atm_t0 = bsm_call_delta(S0_vec, strikes, T0, r, sigma_atm_t0_vec)\n\n        # \"True\" option value at t=1 (post-shock)\n        sigma_smile_t1 = sigma_smile_t0 + dv_shock\n        v_true_t1 = bsm_call_price(S1_vec, strikes, T1, r, sigma_smile_t1)\n        \n        # PnL for both hedging methods\n        # The true initial value is always the smile value\n        v_true_t0 = v_smile_t0 \n        \n        pnl_smile = v_true_t1 - v_true_t0 - delta_smile_t0 * delta_S\n        pnl_atm = v_true_t1 - v_true_t0 - delta_atm_t0 * delta_S\n        \n        # Average absolute PnLs\n        avg_abs_pnl_smile = np.mean(np.abs(pnl_smile))\n        avg_abs_pnl_atm = np.mean(np.abs(pnl_atm))\n\n        # 2. Compute Ratio R\n        # Handle the theoretical case of zero denominator, though unlikely here\n        if avg_abs_pnl_smile  1e-12:\n            ratio_R = 1.0 if avg_abs_pnl_atm  1e-12 else np.inf\n        else:\n            ratio_R = avg_abs_pnl_atm / avg_abs_pnl_smile\n            \n        results.append([rmse, ratio_R])\n    \n    # Format the output as specified: [[x1,y1],[x2,y2],[x3,y3]]\n    output_str = \"[\" + \",\".join([f\"[{x:.8f},{y:.8f}]\" for x, y in results]) + \"]\"\n    print(output_str)\n\n\nsolve()\n```", "id": "2416891"}]}