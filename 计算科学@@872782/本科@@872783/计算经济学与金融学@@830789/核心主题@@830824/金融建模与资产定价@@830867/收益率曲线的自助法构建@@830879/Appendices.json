{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本节的练习将引导你从基础的插值和外推方法开始，探讨其在构建收益率曲线时的应用和潜在的缺陷。这个练习将演示如何使用简单的线性插值和外推来填补收益率曲线中的空白，同时它也作为一个重要的警示案例，说明看似直接的方法可能会产生不符合经济直觉的结果，例如负的远期利率，从而突显了模型选择和验证的重要性。[@problem_id:2419260]", "problem": "一位固定收益分析师观察到以下无违约风险债券在不同期限 $T$（以年为单位）下的连续复利零息收益率：$(T, z(T)) = (5, 0.0340)$、$(10, 0.0320)$、$(15, 0.0307)$ 和 $(20, 0.0113)$。期限 $T = 20$ 之后没有市场报价。该分析师使用分段线性插值法对报价节点之间的零收益率曲线 $z(T)$ 进行建模，对于最后一个节点之后的期限 $T$，则使用线性外推法，延伸最后一个观测区间的斜率。假设到期时间为 $T$ 的无违约风险零息债券的价格为 $P(T) = \\exp(-T\\,z(T))$。\n\n使用此插值和外推约定：\n- 外推计算 $z(25)$。\n- 然后根据这些零利率，计算从 $T = 20$ 到 $T = 25$ 的连续复利年化5年期远期利率。\n\n将最终的远期利率以连续复利下的年化小数形式表示，并四舍五入至四位有效数字。", "solution": "在尝试求解之前，将首先对问题进行严格的验证。\n\n问题验证\n\n第1步：提取已知条件\n明确给出的已知条件如下：\n- 期限 $T$（以年为单位）下的连续复利零息收益率 $z(T)$ 的数据点：$(T, z(T)) = (5, 0.0340)$、$(10, 0.0320)$、$(15, 0.0307)$ 和 $(20, 0.0113)$。\n- 收益率曲线 $z(T)$ 通过在给定节点之间对 $T$ 进行分段线性插值来建模。\n- 对于期限 $T > 20$，模型使用线性外推法，延伸最后一个观测区间的斜率。\n- 到期时间为 $T$ 的无违约风险零息债券的价格由公式 $P(T) = \\exp(-T\\,z(T))$ 给出。\n- 任务是：\n    1. 外推计算25年期收益率 $z(25)$。\n    2. 计算从 $T = 20$ 到 $T = 25$ 的连续复利年化5年期远期利率 $f(20, 25)$。\n- 最终的远期利率必须表示为小数并四舍五入至四位有效数字。\n\n第2步：使用提取的已知条件进行验证\n根据有效性标准对问题进行评估。\n- **科学依据**：该问题基于量化金融和固定收益分析中的标准基本概念。连续复利收益率、债券定价、远期利率以及分段线性插值/外推的定义都是成熟且数学上合理的。\n- **良定性**：问题陈述清晰。所有必要的数据和建模约定（插值和外推规则）均已提供。问题在数学上是精确的，并能导出一个唯一、可确定的解。\n- **客观性**：语言正式且无歧义。它提出了一个明确的计算任务，不含主观或推测性元素。\n- **完整性和一致性**：问题是自洽的。所给数据和方法足以执行所需的计算。没有内部矛盾。指定的外推方法（线性延续最后一段的斜率）在实践中是一种常用但简化的技术。\n\n第3步：结论和行动\n该问题被判定为**有效**。这是一个将插值和外推技术应用于收益率曲线并从中推导金融工具的标准练习。我将继续进行求解。\n\n解题步骤\n\n该问题需要两步计算。首先，必须使用指定的外推方法确定25年期零息收益率 $z(25)$。其次，使用此外推收益率计算从第20年到第25年的5年期远期利率。\n\n对于 $T > 20$ 的外推是线性的，并使用最后一个观测区间的斜率，即 $T_3 = 15$ 年和 $T_4 = 20$ 年之间的区间。对应的收益率是 $z(T_3) = 0.0307$ 和 $z(T_4) = 0.0113$。\n\n收益率曲线在这个最后区间的斜率 $m$ 计算如下：\n$$\nm = \\frac{z(T_4) - z(T_3)}{T_4 - T_3} = \\frac{0.0113 - 0.0307}{20 - 15} = \\frac{-0.0194}{5} = -0.00388\n$$\n对于 $T \\ge 20$，外推是 $T$ 的线性函数，其起点为点 $(T_4, z(T_4))$，斜率为 $m$。外推收益率 $z(T)$ 的公式是：\n$$\nz(T) = z(20) + m \\cdot (T - 20)\n$$\n我们应用此公式来计算 $z(25)$：\n$$\nz(25) = z(20) + m \\cdot (25 - 20) = 0.0113 + (-0.00388) \\cdot 5 = 0.0113 - 0.0194 = -0.0081\n$$\n外推得到的收益率 $z(25)$ 是 $-0.0081$。负收益率虽然不常见，但是将指定的线性外推模型应用于给定数据所得到的直接且有效的结果。已知当收益率曲线具有显著曲率时，该模型会产生此类非物理性的结果。\n\n接下来，我们计算跨越 $T_1$ 到 $T_2$ 期间的连续复利年化远期利率 $f(T_1, T_2)$。关联零息债券价格和远期利率的无套利条件是：\n$$\nP(T_2) = P(T_1) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\n代入给定的债券价格公式 $P(T) = \\exp(-T\\,z(T))$：\n$$\n\\exp(-T_2 z(T_2)) = \\exp(-T_1 z(T_1)) \\cdot \\exp(-(T_2 - T_1) f(T_1, T_2))\n$$\n对两边取自然对数，得到一个线性关系：\n$$\n-T_2 z(T_2) = -T_1 z(T_1) - (T_2 - T_1) f(T_1, T_2)\n$$\n求解远期利率 $f(T_1, T_2)$：\n$$\nf(T_1, T_2) = \\frac{T_2 z(T_2) - T_1 z(T_1)}{T_2 - T_1}\n$$\n我们需要计算从 $T_1 = 20$ 到 $T_2 = 25$ 的5年期远期利率。我们有所需的值：$z(20) = 0.0113$ 和我们计算出的 $z(25) = -0.0081$。\n将这些值代入远期利率公式：\n$$\nf(20, 25) = \\frac{25 \\cdot z(25) - 20 \\cdot z(20)}{25 - 20} = \\frac{25 \\cdot (-0.0081) - 20 \\cdot (0.0113)}{5}\n$$\n我们计算分子：\n$$\n25 \\cdot (-0.0081) = -0.2025\n$$\n$$\n20 \\cdot (0.0113) = 0.2260\n$$\n$$\n\\text{分子} = -0.2025 - 0.2260 = -0.4285\n$$\n现在，我们计算远期利率：\n$$\nf(20, 25) = \\frac{-0.4285}{5} = -0.0857\n$$\n问题要求答案四舍五入到四位有效数字。计算出的值 $-0.0857$ 恰好有三位有效数字（$8$、$5$、$7$）。为了用四位有效数字表示，必须在末尾添加一个零。因此，最终答案是 $-0.08570$。这个负的远期利率同样是由于简化外推模型产生了负收益率的逻辑结果。", "answer": "$$\n\\boxed{-0.08570}\n$$", "id": "2419260"}, {"introduction": "在掌握了基本概念之后，这个练习将带你处理一个更贴近现实的场景：从一组带有噪声的市场价格中构建贴现曲线。你将需要实现一种最小二乘法来拟合曲线，并执行一项关键的诊断测试——检查是否存在由负远期利率所预示的套利机会，这是任何有效金融模型的基本要求。通过这个实践，你将学会如何构建一条稳健的收益率曲线并对其进行有效性验证。[@problem_id:2377895]", "problem": "考虑一个具有确定性期限结构的无摩擦市场。令 $P(0,t)$ 表示时间 $t \\ge 0$ 的折现因子，它是在时间 $0$ 收到在时间 $t$ 支付的一单位货币的现值。对于任何一组固定的现金流 $\\{(t_k,a_k)\\}_{k=1}^K$，其支付时间为 $t_k$（以年为单位），金额为 $a_k$（以货币单位计），无套利定价关系要求该工具的时间 $0$ 价格 $V$ 满足\n$$\nV = \\sum_{k=1}^K a_k \\, P(0,t_k).\n$$\n对于一个期限网格 $0  t_1  t_2  \\dots  t_n$，将相邻区间上的分段常数远期利率定义为\n$$\nf_i = -\\frac{\\ln\\!\\left(\\frac{P(0,t_{i+1})}{P(0,t_i)}\\right)}{t_{i+1}-t_i}, \\quad i=1,\\dots,n-1.\n$$\n在此设定下，假设短期利率经济为非负，违反 $f_i \\ge 0$ 的情况表明推导出的曲线中存在套利信号。如果远期利率 $f_i  -10^{-10}$，则将其视为负利率。\n\n您的任务是，对于下方的每个数据集，在数据集中所有不同现金流时间的并集上构建折现因子 $P(0,t_i)$，使得在方程超定的情况下，相应的工具定价关系在最小二乘意义上尽可能地成立，并满足所有 $i$ 的 $P(0,t_i) > 0$ 约束。然后，使用拟合的折现因子，计算排序后时间网格上的分段常数远期利率，并根据上述阈值统计其中严格为负的数量。\n\n所有货币金额均以每 $100$ 单位面值为基准。所有时间均以年为单位。所有利率（收益率和远期利率）必须以小数形式处理（例如，百分之五记为 $0.05$）。要求的输出是整数（计数）。不需要其他单位。\n\n测试套件（三个数据集）：\n\n- 数据集 A（纯净零息工具）：每个工具在其到期时支付单笔现金流 $100$；观测到的价格如下：\n  - 现金流时间和价格：\n    - $(t,a)=(0.5,100)$，价格 $98.5112$\n    - $(t,a)=(1.0,100)$，价格 $96.8500$\n    - $(t,a)=(1.5,100)$，价格 $94.8841$\n    - $(t,a)=(2.0,100)$，价格 $92.8642$\n    - $(t,a)=(3.0,100)$，价格 $88.6920$\n    - $(t,a)=(5.0,100)$，价格 $79.8516$\n\n- 数据集 B（类似真实世界报价的含噪零息工具）：每个工具在其到期时支付单笔现金流 $100$；观测到的价格如下：\n  - 现金流时间（半年度网格）和价格：\n    - $(0.5, 98.050)$，$(1.0, 96.000)$，$(1.5, 94.250)$，$(2.0, 92.200)$，$(2.5, 90.600)$，\n      $(3.0, 88.800)$，$(3.5, 86.900)$，$(4.0, 85.100)$，$(4.5, 83.650)$，$(5.0, 81.900)$，\n      $(5.5, 80.300)$，$(6.0, 78.600)$，$(6.5, 77.200)$，$(7.0, 75.500)$，$(7.5, 74.100)$，\n      $(8.0, 72.500)$，$(8.5, 71.300)$，$(9.0, 69.700)$，$(9.5, 67.800)$，$(10.0, 68.200)$。\n\n- 数据集 C（包含一个短期零息工具和一年期附息债券的边界案例）：\n  - 工具 1：$(t,a)=(0.5,100)$，价格 $98.000$。\n  - 工具 2：附息债券，在 $t=0.5$ 和 $t=1.0$ 时支付金额为 $2.0$ 的半年度利息，并在 $t=1.0$ 时支付本金 $100.0$，观测价格为 $102.500$。\n\n对于每个数据集：\n1. 形成所有不同现金流时间 $\\{t_i\\}$ 的并集。\n2. 确定折现因子 $\\{P(0,t_i)\\}$，使得在所有工具上的定价误差平方和最小，并满足所有 $i$ 的 $P(0,t_i) > 0$ 约束。\n3. 使用上述公式计算相邻网格区间上的远期利率 $\\{f_i\\}$。\n4. 统计满足 $f_i  -10^{-10}$ 的索引 $i$ 的数量。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按数据集 A、B、C 顺序排列的三个整数结果，形式为用方括号括起来的逗号分隔列表（例如，“[0,1,2]”）。", "solution": "该问题要求根据一组观测到的金融工具价格构建折现曲线。这个过程被称为引导法（bootstrapping），是量化金融的基础。构建的曲线的有效性需要通过检查套利机会来验证，在非负短期利率经济的假设下，负的远期利率是套利机会的信号。我将首先验证问题陈述，然后提供一个完整的解决方案。\n\n该问题经过了严格的验证。\n\n**步骤 1：提取已知条件**\n-   具有现金流 $\\{(t_k, a_k)\\}_{k=1}^K$ 的工具的无套利价格 $V$ 是 $V = \\sum_{k=1}^K a_k P(0,t_k)$，其中 $P(0,t)$ 是到期日为 $t$ 的时间 $0$ 折现因子。\n-   期限网格为 $0  t_1  t_2  \\dots  t_n$。\n-   在 $[t_i, t_{i+1}]$ 上的分段常数远期利率为 $f_i = -\\frac{\\ln(P(0,t_{i+1})/P(0,t_i))}{t_{i+1}-t_i}$。\n-   如果 $f_i  -10^{-10}$，则存在套利信号。\n-   任务：对于三个数据集，在现金流时间的并集上，通过最小化定价误差平方和来找到折现因子 $P(0,t_i)$，并满足 $P(0,t_i) > 0$ 的约束。然后，计算负远期利率的数量。\n-   数据集 A、B 和 C 提供了各种工具的价格和现金流。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学上基于无套利资产定价原理。将价格表述为折现因子的线性组合是标准理论。使用最小二乘优化是从可能包含噪声或超定的市场数据中通过引导法构建收益率曲线的标准技术。远期利率的定义和套利条件也是标准的。该问题是适定的（well-posed）；它要求解一个约束最小二乘问题，对此存在稳健的算法。数据和目标以明确的量化术语表达。未发现清单中的任何缺陷。因此，该问题被视为 **有效**。\n\n**方法论**\n\n对于每个数据集，我们必须执行以下步骤：\n\n1.  **建立时间网格**：设一个数据集中所有工具的所有唯一现金流时间的集合为 $\\{t_1, t_2, \\dots, t_n\\}$，按升序排序，其中 $t_1 > 0$。这些时间构成了我们的网格。未知变量是相应的折现因子，我们用向量 $\\mathbf{p} = [p_1, p_2, \\dots, p_n]^T$ 表示，其中 $p_i = P(0, t_i)$。\n\n2.  **构建线性系统**：每个工具 $j$（对于 $j=1, \\dots, m$）有一个观测价格 $V_j$ 和一组在时间 $\\{t_{jk}\\}$ 的现金流 $\\{a_{jk}\\}$。工具 $j$ 的定价方程可以写成关于未知折现因子 $\\mathbf{p}$ 的线性方程：\n    $$ \\sum_{i=1}^n C_{ji} p_i = V_j $$\n    其中 $C_{ji}$ 是工具 $j$ 在时间 $t_i$ 的现金流金额。这构成了一个包含 $m$ 个线性方程和 $n$ 个未知数的方程组，可以写成矩阵形式：\n    $$ C\\mathbf{p} = \\mathbf{v} $$\n    这里，$C$ 是 $m \\times n$ 的现金流矩阵，$\\mathbf{p}$ 是 $n \\times 1$ 的折现因子向量，$\\mathbf{v}$ 是 $m \\times 1$ 的观测价格向量。\n\n3.  **求解优化问题**：问题是找到向量 $\\mathbf{p}$，使得模型价格 $C\\mathbf{p}$ 和观测价格 $\\mathbf{v}$ 之间的平方差之和最小，同时满足所有折现因子都为正的约束。这是一个约束优化问题：\n    $$ \\min_{\\mathbf{p}} \\| C\\mathbf{p} - \\mathbf{v} \\|_2^2 \\quad \\text{约束条件} \\quad \\mathbf{p} > 0 $$\n    这是一个非负约束最小二乘（NNLS）问题。我们使用稍微弱化但在计算上标准的约束 $\\mathbf{p} \\ge 0$，因为所提供的数据会产生严格为正的解。\n\n4.  **计算和分析远期利率**：在解出 $\\mathbf{p} = [p_1, \\dots, p_n]^T$ 后，我们为每个相邻区间 $[t_i, t_{i+1}]$（对于 $i=1, \\dots, n-1$）计算分段常数远期利率 $f_i$：\n    $$ f_i = -\\frac{\\ln(p_{i+1}/p_i)}{t_{i+1}-t_i} $$\n    如果 $p_{i+1} > p_i$，则会出现负远期利率，这意味着在未来较晚时间 $t_{i+1}$ 的钱比在较早时间 $t_i$ 的钱在今天更有价值。这构成了一个套利机会。我们统计 $f_i  -10^{-10}$ 的实例数量。\n\n**应用于数据集**\n\n**数据集 A：纯净零息工具**\n-   时间网格为 $\\{0.5, 1.0, 1.5, 2.0, 3.0, 5.0\\}$。有 $n=6$ 个时间点和 $m=6$ 个工具。\n-   每个工具都是一个在到期时支付 $100$ 的零息债券。方程组为：\n    $$ 100 \\cdot P(0, t_i) = V_i \\quad \\text{对于 } i=1, \\dots, 6 $$\n-   该系统是对角的，可直接求解：$P(0, t_i) = V_i / 100$。计算出的折现因子为：$0.985112$, $0.968500$, $0.948841$, $0.928642$, $0.886920$, $0.798516$。\n-   折现因子序列是严格递减的，因此对所有 $i$ 都有 $P(0, t_{i+1})  P(0, t_i)$。因此，$p_{i+1}/p_i  1$，$\\ln(p_{i+1}/p_i)  0$，每个远期利率 $f_i$ 都将为正。\n-   负远期利率的数量为 $0$。\n\n**数据集 B：含噪零息工具**\n-   时间网格是从 $0.5$ 年到 $10.0$ 年的半年度网格，包含 $n=20$ 个点。有 $m=20$ 个工具。\n-   与数据集 A 一样，问题简化为对 $20$ 个到期日中的每一个求解 $P(0, t_i) = V_i / 100$。\n-   我们检查价格序列 $V_i$ 以确定相应的折现因子是否单调递减。价格为：$98.050, 96.000, \\dots, 69.700, 67.800, 68.200$。\n-   在期限结构的末端出现异常。我们有 $V_{19} = 67.800$ 对应 $t_{19} = 9.5$，以及 $V_{20} = 68.200$ 对应 $t_{20} = 10.0$。\n-   这给出的折现因子为 $p_{19} = P(0, 9.5) = 0.67800$ 和 $p_{20} = P(0, 10.0) = 0.68200$。\n-   由于 $p_{20} > p_{19}$，区间 $[9.5, 10.0]$ 的远期利率 $f_{19}$ 将为负：\n    $$ f_{19} = -\\frac{\\ln(0.68200 / 0.67800)}{10.0 - 9.5} \\approx -0.01176 $$\n    该值小于 $-10^{-10}$。所有其他相邻价格都在下降，因此没有其他负远期利率。\n-   负远期利率的数量为 $1$。\n\n**数据集 C：包含附息债券的边界案例**\n-   不同的现金流时间是 $t_1=0.5$ 和 $t_2=1.0$，所以 $n=2$。有 $m=2$ 个工具。\n-   线性方程组为：\n    $$\n    \\begin{pmatrix}\n    100  0 \\\\\n    2.0  102.0\n    \\end{pmatrix}\n    \\begin{pmatrix}\n    P(0, 0.5) \\\\\n    P(0, 1.0)\n    \\end{pmatrix}\n    =\n    \\begin{pmatrix}\n    98.000 \\\\\n    102.500\n    \\end{pmatrix}\n    $$\n-   这个系统是恰定的。求解第一个方程得到 $p_1 = P(0, 0.5) = 98.000 / 100 = 0.98000$。\n-   代入第二个方程：$2.0(0.98000) + 102.0 \\cdot p_2 = 102.500$，得到 $1.96 + 102.0 \\cdot p_2 = 102.500$。\n-   解出 $p_2$ 得到 $p_2 = P(0, 1.0) = (102.500 - 1.96) / 102.0 = 100.54 / 102.0 \\approx 0.985686$。\n-   这里，$p_2 \\approx 0.985686 > p_1 = 0.98000$。这意味着在区间 $[0.5, 1.0]$ 上的远期利率为负：\n    $$ f_1 = -\\frac{\\ln(0.985686 / 0.98000)}{1.0 - 0.5} \\approx -0.01157 $$\n    该值小于 $-10^{-10}$。\n-   负远期利率的数量为 $1$。\n\n最终计数为 $0$、$1$ 和 $1$。代码将系统地实现这一逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.optimize import nnls\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all datasets and print the result.\n    \"\"\"\n    \n    # Dataset A (clean zero-coupon instruments)\n    dataset_a = [\n        (98.5112, [(0.5, 100.0)]),\n        (96.8500, [(1.0, 100.0)]),\n        (94.8841, [(1.5, 100.0)]),\n        (92.8642, [(2.0, 100.0)]),\n        (88.6920, [(3.0, 100.0)]),\n        (79.8516, [(5.0, 100.0)]),\n    ]\n\n    # Dataset B (noisy zero-coupon instruments)\n    prices_b = [\n        98.050, 96.000, 94.250, 92.200, 90.600, 88.800, 86.900, 85.100, \n        83.650, 81.900, 80.300, 78.600, 77.200, 75.500, 74.100, 72.500, \n        71.300, 69.700, 67.800, 68.200\n    ]\n    times_b = np.arange(0.5, 10.1, 0.5)\n    dataset_b = [(price, [(time, 100.0)]) for price, time in zip(prices_b, times_b)]\n\n    # Dataset C (edge case with a short-dated zero and a one-year coupon bond)\n    dataset_c = [\n        (98.000, [(0.5, 100.0)]),\n        (102.500, [(0.5, 2.0), (1.0, 102.0)]),\n    ]\n    \n    test_cases = [dataset_a, dataset_b, dataset_c]\n    \n    results = []\n    for case in test_cases:\n        count = solve_dataset(case)\n        results.append(count)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef solve_dataset(instruments):\n    \"\"\"\n    Constructs discount curve for a given dataset and counts negative forward rates.\n\n    Args:\n        instruments: A list of tuples, where each tuple contains an instrument's\n                     price and a list of its cash flows (time, amount).\n\n    Returns:\n        An integer count of negative forward rates.\n    \"\"\"\n    \n    # 1. Establish the Time Grid\n    all_times = set()\n    for _, cash_flows in instruments:\n        for t, _ in cash_flows:\n            all_times.add(t)\n    \n    sorted_times = sorted(list(all_times))\n    time_to_idx = {t: i for i, t in enumerate(sorted_times)}\n    n_times = len(sorted_times)\n    n_instruments = len(instruments)\n\n    # 2. Formulate the Linear System\n    C = np.zeros((n_instruments, n_times))\n    v = np.zeros(n_instruments)\n\n    for j, (price, cash_flows) in enumerate(instruments):\n        v[j] = price\n        for t, amount in cash_flows:\n            if t in time_to_idx:\n                i = time_to_idx[t]\n                C[j, i] += amount\n\n    # 3. Solve the Optimization Problem (NNLS)\n    p, _ = nnls(C, v)\n\n    # 4. Compute and Analyze Forward Rates\n    negative_forward_count = 0\n    neg_threshold = -1.0e-10\n\n    for i in range(n_times - 1):\n        t_i = sorted_times[i]\n        t_i_plus_1 = sorted_times[i+1]\n        \n        p_i = p[i]\n        p_i_plus_1 = p[i+1]\n\n        # Avoid log(0) or division by zero. If p_i is zero, the forward rate\n        # would be infinite, not negative. With the given data, p_i > 0.\n        if p_i > 1e-12:  # Practical threshold for being non-zero\n            ratio = p_i_plus_1 / p_i\n            # If ratio is non-positive, log is undefined. Assume positive discount factors.\n            if ratio > 1e-12:\n                log_ratio = np.log(ratio)\n                delta_t = t_i_plus_1 - t_i\n                \n                # Ensure delta_t is not zero\n                if delta_t > 1e-12:\n                    forward_rate = -log_ratio / delta_t\n                    if forward_rate  neg_threshold:\n                        negative_forward_count += 1\n\n    return negative_forward_count\n\nsolve()\n```", "id": "2377895"}, {"introduction": "掌握了曲线构建之后，任何量化分析师的关键任务之一是理解其对市场输入的敏感性。这项高级实践将指导你推导并计算雅可比矩阵（Jacobian matrix），它衡量了每个自举出的零利率对输入债券价格变化的响应程度。这是利率风险管理（例如计算DV01等风险指标）的基石，将曲线构建过程与其在风险对冲和分析中的应用直接联系起来。[@problem_id:2377880]", "problem": "给定一组固定收益工具，用于在有限的到期日集合上引导（bootstrap）连续复利的零息收益率曲线。假设有 $n$ 个工具，其支付时间递增，为 $\\{t_1,\\dots,t_n\\}$（以年为单位）。工具 $j$ ($1 \\leq j \\leq n$) 在 $\\{t_1,\\dots,t_j\\}$ 时刻支付现金流。将工具 $j$ 的年化票面利率记为 $c_j$（以小数表示，而非百分比），净价记为 $P_j$。假设所有工具的名义本金为 $1$，且一个计息区间内的票息金额等于票面利率乘以该区间的年份分数。具体来说，定义计息分数为 $\\Delta t_1 = t_1 - 0$ 和 $\\Delta t_k = t_k - t_{k-1}$（对于所有 $k \\geq 2$）。那么，对于 $k \\leq j$，工具 $j$ 在时间 $t_k$ 的现金流为 $c_j \\,\\Delta t_k$，并在 $t_j$ 时额外偿还本金 $1$。将 $t_k$ 时刻的连续复利零息利率记为 $z_k$。在无套利假设下，工具 $j$ 的净价由以下贴现关系给出\n$$\nP_j \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right),\n$$\n其中 $\\mathbf{1}_{\\{k=j\\}}$ 是指示函数，当 $k=j$ 时等于 $1$，否则等于 $0$。\n\n定义未知零息利率向量 $\\mathbf{z} = (z_1,\\dots,z_n)^\\top$ 和观测到的价格向量 $\\mathbf{P}=(P_1,\\dots,P_n)^\\top$。定义包含 $n$ 个未知数的 $n$ 个非线性方程组如下\n$$\nF_j(\\mathbf{z},\\mathbf{P}) \\;=\\; \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp\\!\\left(-z_k\\,t_k\\right) \\;-\\; P_j \\;=\\; 0,\\quad j=1,\\dots,n.\n$$\n根据工具的构造，该方程组是下三角的，即方程 $j$ 只涉及 $\\{z_1,\\dots,z_j\\}$。\n\n任务：严格地从上述无套利定价关系和方程组 $F_j(\\mathbf{z},\\mathbf{P})=0$ 的定义出发，推导一个算法来计算引导出的零息利率相对于输入价格的敏感度雅可比矩阵，\n$$\nJ \\;=\\; \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n.\n$$\n您的推导必须从第一性原理出发，通过对定义方程进行微分并利用其下三角结构，不得调用任何预先封装的敏感度公式。然后，将推导出的算法实现为一个完整的、可运行的程序，对提供的测试套件中的每个测试用例执行以下操作：\n\n1. 使用上述计息惯例，根据 $\\{t_k\\}$ 和 $\\{c_j\\}$ 构建隐含的现金流矩阵。\n2. 使用给定的“真实”零息利率向量 $\\{z_k^{\\text{true}}\\}$，通过定价关系计算合成的净价 $\\{P_j\\}$。\n3. 利用三角结构，从 $\\{P_j\\}$ 中引导出 $\\{z_k\\}$。\n4. 组合通过对 $F_j(\\mathbf{z},\\mathbf{P})=0$ 进行隐式微分得到的相应方程组，以求解完整的雅可比矩阵 $J$。\n5. 对于每个测试用例，返回按行主序展开的整个雅可比矩阵，形式为保留 $8$ 位小数的实数列表。\n\n单位与惯例：\n- 所有时间 $\\{t_k\\}$ 均以年为单位。\n- 所有利率 $\\{c_j\\}$ 和 $\\{z_k\\}$ 均为小数（例如，$0.02$ 表示百分之二）。\n- 贴现使用连续复利，即 $\\exp(-z_k\\,t_k)$。\n\n测试套件：\n- 案例 A（一般半年付息结构，“理想路径”）：$n=4$, $t=[0.5,1.0,1.5,2.0]$, $c=[0.0,0.02,0.025,0.03]$, $z^{\\text{true}}=[0.018,0.020,0.0215,0.022]$。\n- 案例 B（全部为零息债券，对角结构边界）：$n=3$, $t=[0.25,0.5,1.0]$, $c=[0.0,0.0,0.0]$, $z^{\\text{true}}=[0.015,0.016,0.0175]$。\n- 案例 C（票息极小，数值上需要小心处理但适定）：$n=3$, $t=[1.0,2.0,3.0]$, $c=[0.0001,0.0001,0.0001]$, $z^{\\text{true}}=[0.03,0.031,0.032]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个含三个元素的列表，每个元素按 A、B、C 的顺序对应一个测试用例。\n- 每个元素本身必须是一个列表，包含按行主序展开的雅可比矩阵项 $\\left[\\frac{\\partial z_i}{\\partial P_j}\\right]$，并四舍五入到 $8$ 位小数。\n- 具体而言，如果一个测试用例的维度为 $n$，则输出一个长度为 $n\\times n$ 的列表，按顺序包含 $J_{1,1},J_{1,2},\\dots,J_{1,n},J_{2,1},\\dots,J_{n,n}$。\n- 打印的单行内容必须是标准的 Python 风格嵌套列表字面量，例如 $\\texttt{[[0.12345678,0.0,\\dots],[\\dots],[\\dots]]}$，其值四舍五入到 $8$ 位小数。", "solution": "所述问题在科学上是合理的、适定的和客观的。它基于无套利定价和利率期限结构的基本原理，这是计算金融学的核心课题。所有必要的数据和定义都已提供，问题结构导向一个唯一且有意义的解。其中没有逻辑矛盾、不切实际的假设或含糊不清之处。因此，我将提供一个完整的解决方案。\n\n目标是推导一个算法，用于计算引导出的零息利率相对于输入工具价格的雅可比矩阵，定义为 $J = \\left[\\frac{\\partial z_i}{\\partial P_j}\\right]_{i,j=1}^n$。该推导将基于应用于非线性定价方程组的隐函数定理。\n\n将价格 $\\mathbf{P}=(P_1, \\dots, P_n)^\\top$ 与零息利率 $\\mathbf{z}=(z_1, \\dots, z_n)^\\top$ 联系起来的 $n$ 个方程组由下式给出：\n$$\nF_j(\\mathbf{z}, \\mathbf{P}) = \\sum_{k=1}^{j} \\left(c_j\\,\\Delta t_k + \\mathbf{1}_{\\{k=j\\}}\\right)\\exp(-z_k\\,t_k) - P_j = 0, \\quad \\text{for } j=1, \\dots, n.\n$$\n在这里，零息利率 $\\mathbf{z}$ 被隐式地定义为市场价格 $\\mathbf{P}$ 的函数。为了找到 $\\mathbf{z}$ 相对于 $\\mathbf{P}$ 的敏感度，我们考虑方程组 $\\mathbf{F}(\\mathbf{z}(\\mathbf{P}), \\mathbf{P}) = \\mathbf{0}$ 的全微分。对于每个分量 $F_j$，我们有：\n$$\ndF_j = \\sum_{i=1}^{n} \\frac{\\partial F_j}{\\partial z_i} dz_i + \\sum_{m=1}^{n} \\frac{\\partial F_j}{\\partial P_m} dP_m = 0.\n$$\n这可以用雅可比矩阵以矩阵形式表示：\n$$\n\\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}} d\\mathbf{z} + \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}} d\\mathbf{P} = \\mathbf{0}.\n$$\n我们用 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ 表示系统关于利率的雅可比矩阵，用 $J_P = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{P}}$ 表示关于价格的雅可比矩阵。方程变为：\n$$\nJ_z d\\mathbf{z} + J_P d\\mathbf{P} = \\mathbf{0}.\n$$\n所求的雅可比矩阵 $J = \\frac{\\partial \\mathbf{z}}{\\partial \\mathbf{P}}$ 通过 $d\\mathbf{z} = J d\\mathbf{P}$ 关联微分 $d\\mathbf{z}$ 和 $d\\mathbf{P}$。将此代入前一个方程可得：\n$$\nJ_z (J d\\mathbf{P}) + J_P d\\mathbf{P} = \\mathbf{0} \\implies (J_z J + J_P) d\\mathbf{P} = \\mathbf{0}.\n$$\n由于此关系必须对价格的任何无穷小变化 $d\\mathbf{P}$ 都成立，因此括号中的矩阵必须是零矩阵。\n$$\nJ_z J + J_P = \\mathbf{0} \\implies J = -(J_z)^{-1} J_P.\n$$\n接下来，我们确定矩阵 $J_z$ 和 $J_P$。\n$F_j$ 对价格 $P_m$ 的偏导数仅在 $m=j$ 时非零：\n$$\n(J_P)_{jm} = \\frac{\\partial F_j}{\\partial P_m} = \\frac{\\partial}{\\partial P_m} \\left( \\dots - P_j \\right) = -\\delta_{jm},\n$$\n其中 $\\delta_{jm}$ 是克罗内克（Kronecker）δ函数。因此，$J_P$ 是负单位矩阵，$J_P = -I$。\n\n将 $J_P=-I$ 代入 $J$ 的表达式中，得到一个简化的结果：\n$$\nJ = -(J_z)^{-1}(-I) = (J_z)^{-1}.\n$$\n问题现在简化为计算矩阵 $J_z = \\frac{\\partial \\mathbf{F}}{\\partial \\mathbf{z}}$ 并求其逆矩阵。$J_z$ 的元素为 $(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i}$。\n根据 $F_j$ 的定义，利率 $z_i$ 仅在 $i \\le j$ 时才出现在公式中。因此，当 $i > j$ 时，$\\frac{\\partial F_j}{\\partial z_i} = 0$，这证实了 $J_z$ 是一个下三角矩阵。\n\n对于 $i \\le j$，导数为：\n$$\n(J_z)_{ji} = \\frac{\\partial F_j}{\\partial z_i} = \\frac{\\partial}{\\partial z_i} \\left[ \\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right)\\exp(-z_i\\,t_i) \\right] = -\\left(c_j\\,\\Delta t_i + \\mathbf{1}_{\\{i=j\\}}\\right) t_i \\exp(-z_i\\,t_i).\n$$\n具体来说，$J_z$ 的元素是：\n- 对角线元素 ($i=j$)：$(J_z)_{jj} = -(c_j \\Delta t_j + 1) t_j \\exp(-z_j t_j)$。\n- 非对角线元素 ($i  j$)：$(J_z)_{ji} = -c_j \\Delta t_i t_i \\exp(-z_i t_i)$。\n- 上三角元素 ($i > j$)：$(J_z)_{ji} = 0$。\n\n我们所求的雅可比矩阵 $J$ 就是这个下三角矩阵 $J_z$ 的逆。由于 $J_z$ 是下三角矩阵，它的逆 $J$ 也将是下三角矩阵。我们可以通过解线性方程组 $J_z J = I$ 来有效地计算 $J$。由于 $J$ 也是下三角矩阵，这可以按列求解，每列的求解过程都是一个利用先前已求解列的前向替换过程。\n\n该算法包括以下步骤：\n1.  给定 $\\{t_k, c_j, z_k^{\\text{true}}\\}$，计算每个工具的合成价格 $\\{P_j\\}$。\n2.  从 $\\{P_j\\}$ 中引导回 $\\{z_k\\}$，以验证引导过程并获得进行微分的点（应恢复 $z_k^{\\text{true}}$）。\n3.  使用引导出的（或真实的）零息利率 $\\{z_k\\}$ 和工具参数 $\\{c_j, \\Delta t_k\\}$，构建下三角矩阵 $J_z$。\n4.  计算 $J_z$ 的逆矩阵，得到 $J$。这可以通过求解线性系统 $J_z J = I$ 来完成，其中 $I$ 是单位矩阵。对于下三角矩阵 $J_z$，这可以通过前向替换高效地完成。\n5.  将 $J$ 矩阵按行主序展开并返回。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_triangular\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and print results.\n    \"\"\"\n\n    def compute_jacobian(t, c, z_true):\n        \"\"\"\n        Derives and computes the Jacobian of zero rates w.r.t. instrument prices.\n\n        Args:\n            t (list): Payment times in years.\n            c (list): Annualized coupon rates (decimal).\n            z_true (list): True zero rates for generating synthetic prices.\n\n        Returns:\n            list: Flattened Jacobian matrix in row-major order, rounded to 8 decimal places.\n        \"\"\"\n        n = len(t)\n        t_arr = np.array(t, dtype=float)\n        c_arr = np.array(c, dtype=float)\n        z_true_arr = np.array(z_true, dtype=float)\n\n        # Step 0: Pre-computation of accrual fractions (delta_t)\n        delta_t = np.zeros(n)\n        delta_t[0] = t_arr[0]\n        if n > 1:\n            delta_t[1:] = t_arr[1:] - t_arr[:-1]\n\n        # Step 2: Compute synthetic clean prices P_j from z_true\n        prices = np.zeros(n)\n        for j in range(n):\n            price = 0.0\n            # Sum of present values of coupons before maturity\n            for k in range(j):\n                price += c_arr[j] * delta_t[k] * np.exp(-z_true_arr[k] * t_arr[k])\n            # Add PV of final payment (last coupon + principal)\n            price += (c_arr[j] * delta_t[j] + 1.0) * np.exp(-z_true_arr[j] * t_arr[j])\n            prices[j] = price\n\n        # Step 3: Bootstrap zero rates z_k from prices P_j\n        # This step recovers z_true and provides the point for derivative evaluation.\n        z_boot = np.zeros(n)\n        for j in range(n):\n            known_pv_of_coupons = 0.0\n            for k in range(j):\n                known_pv_of_coupons += c_arr[j] * delta_t[k] * np.exp(-z_boot[k] * t_arr[k])\n            \n            final_cash_flow = c_arr[j] * delta_t[j] + 1.0\n            \n            # From P_j - known_pv = final_cash_flow * exp(-z_j * t_j)\n            arg_of_log = (prices[j] - known_pv_of_coupons) / final_cash_flow\n            \n            # Handle potential numerical issues for log\n            if arg_of_log = 0:\n                raise ValueError(f\"Invalid argument for log at step j={j}: {arg_of_log}\")\n\n            z_boot[j] = -np.log(arg_of_log) / t_arr[j]\n\n        # Step 4a: Assemble the matrix J_z = dF/dz\n        J_z = np.zeros((n, n))\n        for j in range(n):\n            for i in range(j + 1):\n                discount_factor = np.exp(-z_boot[i] * t_arr[i])\n                if i  j:\n                    # Off-diagonal element (J_z)_ji\n                    # Derivative of F_j w.r.t z_i where i  j\n                    J_z[j, i] = -c_arr[j] * delta_t[i] * t_arr[i] * discount_factor\n                else:  # i == j\n                    # Diagonal element (J_z)_jj\n                    # Derivative of F_j w.r.t z_j\n                    final_payment = c_arr[j] * delta_t[j] + 1.0\n                    J_z[j, j] = -final_payment * t_arr[j] * discount_factor\n\n        # Step 4b: Solve for the Jacobian J = (J_z)^-1\n        # We are solving J_z @ J = I, where I is the identity matrix.\n        # solve_triangular is efficient for this as J_z is lower-triangular.\n        identity_matrix = np.identity(n)\n        J = solve_triangular(J_z, identity_matrix, lower=True)\n\n        # Step 5: Return flattened Jacobian, rounded to 8 decimal places.\n        return np.round(J.flatten(order='C'), 8).tolist()\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: General semiannual coupon structure\n        {'t': [0.5, 1.0, 1.5, 2.0], 'c': [0.0, 0.02, 0.025, 0.03], 'z_true': [0.018, 0.020, 0.0215, 0.022]},\n        # Case B: All zero-coupon bonds\n        {'t': [0.25, 0.5, 1.0], 'c': [0.0, 0.0, 0.0], 'z_true': [0.015, 0.016, 0.0175]},\n        # Case C: Very small coupons\n        {'t': [1.0, 2.0, 3.0], 'c': [0.0001, 0.0001, 0.0001], 'z_true': [0.03, 0.031, 0.032]}\n    ]\n\n    results = []\n    for case in test_cases:\n        result = compute_jacobian(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The string representation is formatted to remove spaces for a compact output.\n    print(str(results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "2377880"}]}