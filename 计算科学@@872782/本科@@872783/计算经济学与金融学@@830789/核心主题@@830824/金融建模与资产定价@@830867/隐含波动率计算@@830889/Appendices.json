{"hands_on_practices": [{"introduction": "隐含波动率是金融市场中的一个核心指标，它通过“反转”经典的Black-Scholes期权定价模型得到。这项实践将指导你实现一个牛顿-拉弗森（Newton-Raphson）数值求解器，用以寻找那个能使理论价格与市场价格相匹配的波动率值。掌握这一基本技能是每位量化分析师的必经之路。[@problem_id:2400522]", "problem": "您需要实现一个程序，该程序针对一组在 Black–Scholes 模型下、基于无股息支付资产的欧式期权，计算其隐含波动率。隐含波动率被定义为唯一的非负年化标准差值，当将此值代入 Black–Scholes 定价公式时，其结果与给定的观测期权价格相匹配。令 $S$ 表示即期价格，$K$ 表示行权价格，$r$ 表示连续复利无风险利率，$T$ 表示到期时间（以年为单位），$\\sigma$ 表示年化波动率（以小数形式表示），$\\Phi(\\cdot)$ 表示标准正态分布的累积分布函数（CDF），$\\phi(\\cdot)$ 表示其概率密度函数（PDF）。对于欧式看涨期权，\n$$\nC(S,K,r,T,\\sigma) \\;=\\; S\\,\\Phi(d_1) \\;-\\; K\\,e^{-rT}\\,\\Phi(d_2),\n$$\n对于欧式看跌期权，\n$$\nP(S,K,r,T,\\sigma) \\;=\\; K\\,e^{-rT}\\,\\Phi(-d_2) \\;-\\; S\\,\\Phi(-d_1),\n$$\n其中\n$$\nd_1 \\;=\\; \\frac{\\ln(S/K) + \\left(r + \\tfrac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}}, \n\\qquad\nd_2 \\;=\\; d_1 - \\sigma\\sqrt{T}.\n$$\n对于一个给定的观测期权价格 $p_{\\text{obs}}$，其隐含波动率是使得相应的 Black–Scholes 价格等于 $p_{\\text{obs}}$ 的值 $\\sigma^\\star \\ge 0$。如果 $p_{\\text{obs}}$ 处于无套利下限（即，对于看涨期权，$p_{\\text{obs}} = \\max\\{0, S - K e^{-rT}\\}$；对于看跌期权，$p_{\\text{obs}} = \\max\\{0, K e^{-rT} - S\\}$），则隐含波动率必须为 $0$。所有输出必须以年化波动率单位表示（小数形式，而非百分比）。\n\n您的程序必须为以下每个测试用例计算隐含波动率，期权类型可为看涨期权（$\\text{C}$）或看跌期权（$\\text{P}$），所有时间 $T$ 均以年为单位衡量：\n\n- 测试用例 1：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $68.268949213709$。\n- 测试用例 2：类型 $\\text{C}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $14.461007592486$。\n- 测试用例 3：类型 $\\text{P}$，$S=60.653065971263$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $53.807941621223$。\n- 测试用例 4：类型 $\\text{C}$，$S=120.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 5：类型 $\\text{P}$，$S=80.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $20.0$。\n- 测试用例 6：类型 $\\text{C}$，$S=100.0$，$K=100.0$，$r=0.0$，$T=1.0$，观测价格 $7.965567455406$。\n\n您的程序必须生成单行输出，其中包含按顺序排列的各测试用例的隐含波动率，四舍五入到小数点后恰好六位。输出格式必须是单行上的一个列表，形式为方括号内以逗号分隔的列表，不含多余空格。例如，输出格式必须类似于“[v1,v2,v3,v4,v5,v6]”，其中每个 $v_i$ 是一个四舍五入到六位小数的浮点数。\n\n程序必须是自包含的，并且不得读取任何输入。最终答案必须是小数形式的浮点数（而非百分比）。请确保数值稳定性，并正确处理位于无套利下限上的情况。以上数据具有科学依据，每个案例都存在一个与 Black–Scholes 模型和无套利边界相符的唯一非负隐含波动率。这组案例覆盖了一般行为、深度价内（ITM）和深度价外（OTM）状态以及边界条件。最终输出必须按规定将六个结果汇总到单行上。", "solution": "该问题要求根据一组欧式期权的观测市场价格 $p_{\\text{obs}}$，计算其隐含波动率 $\\sigma^\\star$。这是量化金融中的一个经典反向问题。隐含波动率被定义为波动率参数 $\\sigma$ 的一个值，该值使得期权的理论 Black-Scholes 价格等于其观测价格。\n\n任务的核心是求解方程 $f(\\sigma) = 0$（其中 $\\sigma \\ge 0$），$f(\\sigma)$ 是 Black-Scholes 价格与观测价格之差：\n$$\nf(\\sigma) = \\text{BS}(S, K, r, T, \\sigma) - p_{\\text{obs}} = 0\n$$\n此处，$\\text{BS}(S, K, r, T, \\sigma)$ 是期权（看涨期权 $C$ 或看跌期权 $P$）的价格，由问题描述中提供的 Black-Scholes 公式给出。\n\n对于任何到期时间 $T > 0$，Black-Scholes 定价函数 $\\text{BS}(\\sigma)$ 是关于波动率 $\\sigma$ 的严格递增连续函数。这种单调性保证了如果 $\\sigma^\\star$ 的解存在，则该解是唯一的。这一特性使该问题非常适合使用数值求根算法。我们将采用 Newton-Raphson 方法，该方法在函数导数可用且性质良好时以其快速收敛而著称。\n\nNewton-Raphson 方法是一种迭代方案，用于寻找实值函数根的逐次更优近似值。其迭代公式为：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{f(\\sigma_k)}{f'(\\sigma_k)}\n$$\n在我们的情境中，$f(\\sigma) = \\text{BS}(\\sigma) - p_{\\text{obs}}$，其关于 $\\sigma$ 的导数为：\n$$\nf'(\\sigma) = \\frac{\\partial}{\\partial \\sigma} \\left[ \\text{BS}(\\sigma) - p_{\\text{obs}} \\right] = \\frac{\\partial \\text{BS}(\\sigma)}{\\partial \\sigma}\n$$\n这个导数在期权定价中是一个非常重要的量，称为 Vega，用 $\\mathcal{V}$ 表示。对于看涨和看跌期权，Vega 均由以下公式给出：\n$$\n\\mathcal{V} = S \\phi(d_1) \\sqrt{T}\n$$\n其中 $\\phi(\\cdot)$ 是标准正态分布的概率密度函数（PDF），$d_1$ 的定义与问题描述中相同。由于对于所有实数 $x$，$\\phi(x) > 0$，且 $S, T > 0$，因此 Vega 严格为正。这证实了定价函数的单调性。\n\n因此，隐含波动率的迭代公式变为：\n$$\n\\sigma_{k+1} = \\sigma_k - \\frac{\\text{BS}(\\sigma_k) - p_{\\text{obs}}}{\\mathcal{V}(\\sigma_k)}\n$$\n\n整个算法设计如下：\n首先，我们处理一个关键的边界条件。问题指出，如果观测价格 $p_{\\text{obs}}$ 等于期权的无套利下限（其内在价值），则隐含波动率为 $0$。看涨期权的内在价值为 $\\max\\{0, S - K e^{-rT}\\}$，看跌期权的内在价值为 $\\max\\{0, K e^{-rT} - S\\}$。我们的实现将首先检查 $p_{\\text{obs}}$ 是否在一个小的数值容差内与此值匹配。如果匹配，我们立即返回 $\\sigma^\\star = 0$，不进行迭代。\n\n如果价格高于内在价值，我们继续使用 Newton-Raphson 求解器。\n1.  选择一个初始猜测值 $\\sigma_0$。对于广泛的期权参数，$\\sigma_0 = 0.5$ 是一个合理且稳健的起点。\n2.  算法进行迭代，使用上述公式从 $\\sigma_k$ 计算 $\\sigma_{k+1}$。\n3.  迭代持续进行，直到在 $\\sigma_k$ 处计算出的 Black-Scholes 价格与观测价格 $p_{\\text{obs}}$ 之间的绝对差值小于一个预定义的容差（例如，$10^{-12}$）。\n4.  为确保算法终止，会强制设定最大迭代次数（例如 $100$ 次）。对于所提供的性质良好的测试用例，预计收敛会非常迅速。\n\n该实现由三个主要的 Python 函数组成：\n-   一个用于计算看涨或看跌期权的 Black-Scholes 价格的函数，使用 `scipy.stats.norm.cdf` 来表示标准正态累积分布函数 $\\Phi(\\cdot)$。\n-   一个用于计算 Vega ($\\mathcal{V}$) 的函数，使用 `scipy.stats.norm.pdf` 来表示标准正态概率密度函数 $\\phi(\\cdot)$。\n-   一个主函数，用于协调整个过程：它检查边界条件，并在必要时执行 Newton-Raphson 迭代以找到隐含波动率。\n\n最后，将此过程应用于问题中定义的六个测试用例。收集得出的隐含波动率，格式化为六位小数，并以指定的列表格式打印到标准输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Computes implied volatility for a set of European options using the Black-Scholes model\n    and the Newton-Raphson method.\n    \"\"\"\n\n    def black_scholes_price(S, K, r, T, sigma, option_type):\n        \"\"\"\n        Calculates the Black-Scholes price for a European option.\n        \"\"\"\n        # For non-positive sigma, price is intrinsic value.\n        if sigma = 0.0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K * np.exp(-r * T))\n            else:  # 'P'\n                return np.maximum(0.0, K * np.exp(-r * T) - S)\n\n        # To prevent division by zero for T=0\n        if T == 0:\n            if option_type == 'C':\n                return np.maximum(0.0, S - K)\n            else: # 'P'\n                return np.maximum(0.0, K - S)\n\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n\n        if option_type == 'C':\n            price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        elif option_type == 'P':\n            price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)\n        else:\n            raise ValueError(\"Invalid option type. Must be 'C' or 'P'.\")\n        return price\n\n    def vega(S, K, r, T, sigma):\n        \"\"\"\n        Calculates the Vega of a European option.\n        \"\"\"\n        if sigma == 0.0 or T == 0.0:\n            return 0.0\n        \n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return S * norm.pdf(d1) * np.sqrt(T)\n\n    def implied_volatility(S, K, r, T, p_obs, option_type):\n        \"\"\"\n        Calculates the implied volatility using the Newton-Raphson method.\n        \"\"\"\n        # Check if price is at the no-arbitrage lower bound (intrinsic value)\n        if option_type == 'C':\n            intrinsic_value = np.maximum(0.0, S - K * np.exp(-r * T))\n        else:  # 'P'\n            intrinsic_value = np.maximum(0.0, K * np.exp(-r * T) - S)\n        \n        # Using a small tolerance for floating point comparison\n        if np.isclose(p_obs, intrinsic_value):\n            return 0.0\n\n        # Newton-Raphson settings\n        sigma = 0.5  # Initial guess\n        max_iter = 100\n        tolerance = 1e-12\n\n        for _ in range(max_iter):\n            price = black_scholes_price(S, K, r, T, sigma, option_type)\n            v = vega(S, K, r, T, sigma)\n            \n            diff = price - p_obs\n\n            if abs(diff)  tolerance:\n                return sigma\n            \n            if v  1e-13:\n                # Vega is too small, Newton-Raphson is unstable.\n                # This should not happen for the given test cases.\n                # A more robust solver would switch to bisection here.\n                break\n\n            sigma = sigma - diff / v\n        \n        # Return the last calculated sigma if max iterations are reached\n        return sigma\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (option_type, S, K, r, T, p_obs)\n        ('C', 100.0, 100.0, 0.0, 1.0, 68.268949213709),\n        ('C', 60.653065971263, 100.0, 0.0, 1.0, 14.461007592486),\n        ('P', 60.653065971263, 100.0, 0.0, 1.0, 53.807941621223),\n        ('C', 120.0, 100.0, 0.0, 1.0, 20.0),\n        ('P', 80.0, 100.0, 0.0, 1.0, 20.0),\n        ('C', 100.0, 100.0, 0.0, 1.0, 7.965567455406),\n    ]\n\n    results = []\n    for case in test_cases:\n        # Main logic to calculate the result for one case goes here.\n        option_type, S, K, r, T, p_obs = case\n        result = implied_volatility(S, K, r, T, p_obs, option_type)\n        results.append(f\"{result:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2400522"}, {"introduction": "Black-Scholes公式的适用范围仅限于欧式期权，而现实世界中存在大量可提前行权的美式期权。本次练习将挑战更复杂的美式期权，你将首先构建一个二叉树定价模型来处理其提前行权的特性，然后用它来求解隐含波动率。通过这项实践，你将深刻理解隐含波动率这一关键参数对模型的依赖性。[@problem_id:2400466]", "problem": "要求您编写一个完整、可运行的程序，该程序使用可重组二叉树模型和考虑提前行权的风险中性定价方法，为支付股息的股票上的美式期权计算隐含波动率。该程序必须构建一个考虑了连续股息收益率的美式期权定价函数，然后求解出能使模型价格与给定观测价格相匹配的唯一波动率。在测试时，每个观测价格都将通过以下方式合成生成：首先使用一个已知的波动率，在相同的二叉树规格下对同一期权进行定价。\n\n所有参数在适用情况下均为年化和连续的。在风险中性测度下，标的资产在固定数量的时间步长内遵循乘法二叉过程。该股票支付连续的股息收益率。在每个节点，美式期权价值等于其立即行权价值与在风险中性概率下的折现预期持有价值中的较大者。隐含波动率被定义为这样一个非负实数：当它作为波动率代入同一二叉树模型时，计算出的美式期权价格等于观测价格。\n\n单位与惯例：\n- 无风险利率 $r$ 和股息收益率 $q$ 是以小数形式给出的连续复利年利率。\n- 到期时间 $T$ 以年为单位。\n- 标的资产价格 $S_0$ 和行权价 $K$ 使用任意货币单位；波动率以小数形式报告。\n- 不涉及角度。\n- 所有利率和波动率必须按小数处理，而非百分比。\n\n测试套件：\n对于每个测试用例，首先通过使用提供的波动率 $\\,\\sigma^\\star\\,$ 和指定的二叉树步数 $\\,N\\,$ 对美式期权进行定价，从而计算出观测期权价格 $V^{obs}$。然后，仅使用 $V^{obs}$（而非 $\\,\\sigma^\\star\\,$），求解出能在同一模型中重现 $V^{obs}$ 的隐含波动率 $\\,\\hat{\\sigma}\\,$。您的程序应为每个案例返回 $\\,\\hat{\\sigma}\\,$，四舍五入至六位小数。\n\n- 案例 A（通用，平价美式看跌期权）：$S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, 期权类型 put, 正向定价波动率 $\\,\\sigma^\\star = 0.20$。\n- 案例 B（含股息收益率的美式看涨期权，可能提前行权）：$S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, 期权类型 call, 正向定价波动率 $\\,\\sigma^\\star = 0.25$。\n- 案例 C（短期限）：$S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\tfrac{7}{365}$, $N = 120$, 期权类型 call, 正向定价波动率 $\\,\\sigma^\\star = 0.15$。\n- 案例 D（深度价外美式看跌期权，较长期限）：$S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, 期权类型 put, 正向定价波动率 $\\,\\sigma^\\star = 0.35$。\n\n最终输出格式：\n您的程序应生成单行输出，其中按顺序包含案例 A-D 的四个隐含波动率，四舍五入至六位小数，以逗号分隔的列表形式并用方括号括起来。例如，格式必须为\n\"[vA,vB,vC,vD]\"\n不带多余的空格或字符，其中 $vA$、$vB$、$vC$ 和 $vD$ 均为四舍五入至六位小数的小数形式浮点数。", "solution": "在尝试任何解决方案之前，所呈现的问题陈述都经过了严格的验证。\n\n步骤 1：提取已知信息\n- **模型类型**：用于美式期权的可重组二叉树模型。\n- **标的资产**：支付连续股息收益率的股票。\n- **估值方法**：考虑提前行权的风险中性定价。\n- **股价过程**：乘法二叉过程，$S_{t+\\Delta t} = S_t \\cdot u$ 或 $S_{t+\\Delta t} = S_t \\cdot d$。\n- **期权价值规则**：在任何节点，价值为其立即行权价值和其在风险中性概率下的折现预期持有价值中的最大值。\n- **隐含波动率 ($\\hat{\\sigma}$)**：使得模型价格等于观测市场价格 $V^{obs}$ 的唯一非负实数波动率 $\\sigma$。\n- **观测价格生成**：每个 $V^{obs}$ 都是通过使用一个已知的波动率 $\\sigma^\\star$ 对期权进行定价来合成生成的。\n- **模型参数**：\n    - $S_0$: 初始股价。\n    - $K$: 行权价。\n    - $r$: 无风险利率（连续，年化）。\n    - $q$: 股息收益率（连续，年化）。\n    - $T$: 到期时间（年）。\n    - $N$: 二叉树的时间步数。\n    - `option_type`: 'call' 或 'put'。\n- **测试用例**：\n    - **A**: $S_0 = 100$, $K = 100$, $r = 0.05$, $q = 0.02$, $T = 1.0$, $N = 300$, 类型 = put, $\\sigma^\\star = 0.20$。\n    - **B**: $S_0 = 120$, $K = 100$, $r = 0.01$, $q = 0.06$, $T = 0.5$, $N = 300$, 类型 = call, $\\sigma^\\star = 0.25$。\n    - **C**: $S_0 = 100$, $K = 95$, $r = 0.03$, $q = 0.00$, $T = \\frac{7}{365}$, $N = 120$, 类型 = call, $\\sigma^\\star = 0.15$。\n    - **D**: $S_0 = 150$, $K = 100$, $r = 0.03$, $q = 0.02$, $T = 2.0$, $N = 400$, 类型 = put, $\\sigma^\\star = 0.35$。\n- **输出要求**：一个包含四个隐含波动率 $\\hat{\\sigma}$ 的列表，对应于各测试用例，四舍五入到六位小数。\n\n步骤 2：验证\n- **科学基础**：该问题基于 Cox-Ross-Rubinstein (CRR) 二叉树期权定价模型，这是计算金融学的基石。风险中性定价、处理带提前行权的美式期权以及隐含波动率的概念都是标准的、完善的原则。该模型在科学上是合理的。\n- **适定性**：该问题要求为方程 $V_{model}(\\sigma) - V^{obs} = 0$ 求解一个根。对于标准期权，期权价格 $V_{model}(\\sigma)$ 是波动率 $\\sigma$ 的单调递增函数（即 Vega 为正）。这确保了对于任何有效的观测价格 $V^{obs}$，都存在唯一的解 $\\sigma$。问题的结构是 $V^{obs}$ 是使用同一模型由已知 $\\sigma^\\star$ 生成的，这保证了存在一个解 $\\hat{\\sigma} = \\sigma^\\star$，使得问题是适定的。\n- **客观性**：所有参数和定义都是定量的和精确的。问题中没有主观语言或推测性陈述。\n- **完整性**：为每个测试用例提供了所有必需的参数（$S_0, K, r, q, T, N, \\text{type}$），使问题是自洽的。\n- **一致性**：问题陈述不包含内部矛盾。\n\n步骤 3：结论\n该问题被判定为**有效**。它具有科学依据、适定、客观、完整且一致。它代表了量化金融中的一个标准计算任务。我现在将继续进行解决方案的推导和实现。\n\n解决方案是一个两阶段的过程。首先，基于指定的二叉树模型构建一个美式期权定价器。其次，使用数值求根算法来求解隐含波动率。\n\n**第 1 部分：美式期权定价的二叉树模型**\n\n二叉树模型将时间离散化为 $N$ 个持续时间为 $\\Delta t = T/N$ 的步长。在每个节点，股价向上移动一个因子 $u$ 或向下移动一个因子 $d$。我们使用标准的 Cox-Ross-Rubinstein (CRR) 公式来表示这些因子，这取决于波动率 $\\sigma$。\n\n1.  **模型参数**：\n    单个时间步长的长度是 $\\Delta t = T/N$。\n    上涨因子是 $u = e^{\\sigma \\sqrt{\\Delta t}}$。\n    下跌因子是 $d = e^{-\\sigma \\sqrt{\\Delta t}} = 1/u$。\n\n2.  **风险中性概率**：\n    为了使折现后的股价过程在风险中性测度下成为一个鞅，考虑到连续股息收益率 $q$，在 $t+\\Delta t$ 时刻的预期股价，以无风险利率 $r$ 折现后，必须等于 $t$ 时刻的股价在扣除 $\\Delta t$ 区间内因股息支付而损失的价值之后的值。这给出了以下关系：\n    $$S_t e^{-q \\Delta t} = e^{-r \\Delta t} [p (S_t u) + (1-p) (S_t d)]$$\n    解出上涨的风险中性概率 $p$ 得：\n    $$p = \\frac{e^{(r-q)\\Delta t} - d}{u - d}$$\n    下跌的概率则是 $1-p$。必须满足条件 $0  p  1$，这要求 $d  e^{(r-q)\\Delta t}  u$。对于典型的参数值和非零波动率，此条件是满足的。\n\n3.  **向后归纳算法**：\n    美式期权的价值是通过从到期日向后推算来确定的。\n    - **在到期日（时间 $T$，第 $N$ 步）**：期权价值是其内在价值。构建一个到期时的股价树。对于 $j$ 次上涨和 $N-j$ 次下跌（其中 $j \\in \\{0, 1, \\dots, N\\}$），股价为 $S_{N,j} = S_0 u^j d^{N-j}$。期权价值是：\n    $$V_{N,j} = \\max(S_{N,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$V_{N,j} = \\max(K - S_{N,j}, 0) \\quad \\text{对于看跌期权}$$\n\n    - **在中间步骤（时间 $i \\Delta t$，第 $i$ 步，$i  N$）**：在任何节点 $(i, j)$ 的期权价值是提前行权价值和折现预期持有价值中的最大值。\n    持有价值是在第 $i+1$ 步的期权预期值，折现一个周期回来：\n    $$C_{i,j} = e^{-r \\Delta t} [p V_{i+1, j+1} + (1-p) V_{i+1, j}]$$\n    在节点 $(i,j)$ 处的提前行权价值，此时股价为 $S_{i,j} = S_0 u^j d^{i-j}$，是：\n    $$E_{i,j} = \\max(S_{i,j} - K, 0) \\quad \\text{对于看涨期权}$$\n    $$E_{i,j} = \\max(K - S_{i,j}, 0) \\quad \\text{对于看跌期权}$$\n    因此，美式期权的价值是：\n    $$V_{i,j} = \\max(E_{i,j}, C_{i,j})$$\n    这个向后迭代过程一直进行到第 $i=0$ 步。在时间 $t=0$ 的期权价格是单个节点的值 $V_{0,0}$。这整个过程构成了定价函数，我们将其表示为 $V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type})$。\n\n**第 2 部分：隐含波动率计算**\n\n隐含波动率 $\\hat{\\sigma}$ 是使模型价格等于观测市场价格 $V^{obs}$ 的 $\\sigma$ 值。我们必须为 $\\sigma$ 求解以下方程：\n$$f(\\sigma) = V_{\\text{model}}(S_0, K, r, q, T, N, \\sigma, \\text{type}) - V^{obs} = 0$$\n\n由于 $V_{\\text{model}}$ 没有简单的封闭形式表达式，我们必须使用数值求根方法。Brent 方法是一个稳健且高效的选择。它需要一个区间 $[a, b]$，其中 $f(a)$ 和 $f(b)$ 符号相反。\n\n1.  **目标函数**：需要最小化的函数是 `objective_func(sigma) = american_option_pricer(...) - V_obs`。\n2.  **生成观测价格**：对于每个测试用例，我们首先用给定的正向定价波动率 $\\sigma^\\star$ 调用我们的定价函数来计算 $V^{obs}$。\n3.  **求根**：然后我们使用 Brent 方法（在 `scipy.optimize.brentq` 中可用）来找到 `objective_func` 的根。\n    - 需要一个合适的波动率搜索区间。下界可以是一个小的正数，例如 $10^{-6}$，因为波动率不能为负。上界 $5.0$（代表 $500\\%$ 的波动率）是极其保守的，对于任何现实的期权价格，都足以将解包含在内。\n    - 由于期权价格是波动率的单调递增函数，并且我们知道在 $\\sigma = \\sigma^\\star$ 处存在一个解，因此找到一个包含根的区间是直接的。\n\n最终的程序将封装这两个部分。对于每个测试用例，它将首先计算 $V^{obs}$，然后求解 $\\hat{\\sigma}$。问题设定保证了结果 $\\hat{\\sigma}$ 在求解器的容差范围内将等于 $\\sigma^\\star$。最终结果按规定进行四舍五入。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import brentq\n\ndef american_option_pricer(S0, K, r, q, T, N, sigma, option_type):\n    \"\"\"\n    Prices an American option using a recombining binomial tree model.\n\n    Args:\n        S0 (float): Initial stock price.\n        K (float): Strike price.\n        r (float): Risk-free interest rate (annual, continuous).\n        q (float): Dividend yield (annual, continuous).\n        T (float): Time to maturity (years).\n        N (int): Number of time steps in the binomial tree.\n        sigma (float): Volatility of the underlying stock.\n        option_type (str): Type of option, 'call' or 'put'.\n\n    Returns:\n        float: The price of the American option.\n    \"\"\"\n    # 1. Parameter setup for the binomial model\n    # Ensure sigma is not too close to zero to avoid division issues.\n    if sigma  1e-9:\n        sigma = 1e-9\n\n    dt = T / N\n    u = np.exp(sigma * np.sqrt(dt))\n    d = 1.0 / u\n\n    # Check for arbitrage condition and calculate risk-neutral probability\n    a = np.exp((r - q) * dt)\n    if not (d  a  u):\n        # Fallback or handle arbitrage condition violation\n        # For this problem's context, this is unlikely.\n        # This can be triggered if r-q is very large or sigma very small.\n        # If it happens, we can approximate p to be very close to 1 or 0.\n        if a >= u:\n            p = 1.0 \n        else: # a = d\n            p = 0.0\n    else:\n        p = (a - d) / (u - d)\n\n    # 2. Initialize option values at maturity (time T)\n    # The prices are stored in a 1D array representing nodes at a given time step.\n    V = np.zeros(N + 1)\n    \n    # Stock prices at maturity\n    S_T = S0 * (d ** np.arange(N, -1, -1)) * (u ** np.arange(0, N + 1, 1))\n\n    if option_type == 'call':\n        V[:] = np.maximum(S_T - K, 0)\n        payoff_sign = 1\n    else:  # put\n        V[:] = np.maximum(K - S_T, 0)\n        payoff_sign = -1\n\n    # 3. Backward induction through the tree\n    for i in range(N - 1, -1, -1):\n        # Calculate continuation value at step i (vector of size i+1)\n        # V is of size i+2 from the previous step i+1.\n        # We use V's relevant subarray [0:i+2]\n        continuation_value = np.exp(-r * dt) * (p * V[1:i + 2] + (1 - p) * V[0:i + 1])\n\n        # Calculate stock prices at step i\n        S_i = S0 * (d ** np.arange(i, -1, -1)) * (u ** np.arange(0, i + 1, 1))\n\n        # Calculate early exercise value\n        exercise_value = np.maximum((S_i - K) * payoff_sign, 0)\n\n        # Update option values at step i\n        V[0:i + 1] = np.maximum(continuation_value, exercise_value)\n\n    return V[0]\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute implied volatilities.\n    \"\"\"\n    test_cases = [\n        # (S0, K, r, q, T, N, option_type, sigma_star)\n        (100.0, 100.0, 0.05, 0.02, 1.0, 300, 'put', 0.20),  # Case A\n        (120.0, 100.0, 0.01, 0.06, 0.5, 300, 'call', 0.25), # Case B\n        (100.0, 95.0, 0.03, 0.00, 7.0/365.0, 120, 'call', 0.15), # Case C\n        (150.0, 100.0, 0.03, 0.02, 2.0, 400, 'put', 0.35), # Case D\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        S0, K, r, q, T, N, option_type, sigma_star = case\n\n        # 1. Generate the \"observed\" option price using the known volatility\n        observed_price = american_option_pricer(S0, K, r, q, T, N, sigma_star, option_type)\n\n        # 2. Define the objective function for the root-finder\n        # The function calculates the difference between model price and observed price.\n        def objective_func(sigma):\n            return american_option_pricer(S0, K, r, q, T, N, sigma, option_type) - observed_price\n\n        # 3. Find the implied volatility using Brent's method\n        # A search bracket from 0.0001 (0.01%) to 5.0 (500%) is very safe.\n        try:\n            implied_vol = brentq(objective_func, a=1e-6, b=5.0, xtol=1e-12, rtol=1e-12)\n        except ValueError:\n            # This would happen if f(a) and f(b) don't have opposite signs.\n            # Given the problem's synthetic nature, this is not expected.\n            implied_vol = np.nan\n\n        results.append(round(implied_vol, 6))\n\n    # Final output format: \"[vA,vB,vC,vD]\"\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2400466"}, {"introduction": "恒定波动率是Black-Scholes模型的一个著名局限，它无法解释市场上观察到的“波动率微笑”现象。这项高级实践将引入SABR模型，一个波动率本身也随机变化的随机波动率模型。通过实现著名的Hagan近似公式，你将能够计算出可以形成真实市场中波动率微笑的隐含波动率，从而将理论模型与经验现象联系起来。[@problem_id:2400489]", "problem": "实现一个完整的程序，用于计算由随机Alpha Beta Rho (SABR) 模型生成的欧式期权的对数正态布莱克隐含波动率。SABR动态在风险中性测度下由以下耦合随机微分方程定义\n$$\n\\mathrm{d}F_t = \\alpha_t F_t^{\\beta}\\,\\mathrm{d}W_t^{(1)}, \\qquad \\mathrm{d}\\alpha_t = \\nu \\alpha_t\\,\\mathrm{d}W_t^{(2)}, \\qquad \\mathrm{d}\\langle W^{(1)}, W^{(2)}\\rangle_t = \\rho\\,\\mathrm{d}t,\n$$\n其中 $F_t$ 是时间 $t$ 的远期标的，$\\alpha_t$ 是瞬时波动率，$\\beta \\in [0,1]$，$\\rho \\in (-1,1)$ 是瞬时相关性，$\\nu \\ge 0$ 是波动率的波动率。对于一个到期日 $T0$，一个远期价格 $F0$，一个行权价 $K0$，以及SABR参数 $(\\alpha,\\beta,\\rho,\\nu)$（其中$\\alpha0$），对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}(F,K,T;\\alpha,\\beta,\\rho,\\nu)$ 被定义为唯一的 $\\sigma$，使得使用波动率 $\\sigma$ 的Black-Scholes（对数正态）公式与到期日为 $T$ 的SABR期权价格相匹配。在短到期日渐近机制中，这个隐含波动率由标准的作为 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$ 的确定性函数的一阶短时间表达式明确定义。\n\n您的程序必须为下方测试套件中的每一组参数，根据这个短到期日SABR隐含波动率映射，计算出相应的对数正态布莱克隐含波动率 $\\sigma_{\\mathrm{imp}}$。所有返回的波动率必须表示为小数（例如，$0.2$ 表示百分之二十），并且每个结果必须四舍五入到$8$位小数。\n\n测试套件（每个案例都是一个元组 $(F,K,T,\\alpha,\\beta,\\rho,\\nu)$，所有量均为无量纲，且 $T$ 以年为单位）：\n- 案例 $1$：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.1,\\,1.0,\\,0.3,\\,0.7,\\,-0.3,\\,0.5)$\n- 案例 $2$（平价）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,1.0,\\,2.0,\\,0.25,\\,1.0,\\,0.0,\\,0.4)$\n- 案例 $3$（极短到期日）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (1.0,\\,0.9,\\,0.0001,\\,0.2,\\,0.5,\\,0.5,\\,1.2)$\n- 案例 $4$（高正相关性）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (2.0,\\,1.0,\\,3.0,\\,0.15,\\,0.9,\\,0.99,\\,0.8)$\n- 案例 $5$（高负相关性，低 $\\beta$）：$(F,K,T,\\alpha,\\beta,\\rho,\\nu) = (0.5,\\,0.8,\\,0.5,\\,0.4,\\,0.3,\\,-0.99,\\,1.0)$\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔的结果列表。请按顺序报告案例 $1$ 到案例 $5$ 对应的 $5$ 个隐含波动率，每个都四舍五入到 $8$ 位小数。例如，\n\"[v1,v2,v3,v4,v5]\"\n其中每个 $v_i$ 是一个格式化为恰好 $8$ 位小数的浮点数。", "solution": "所提出的问题要求计算在随机Alpha Beta Rho (SABR) 模型下定价的欧式期权的对数正态布莱克隐含波动率。计算必须使用由 Hagan、Kumar、Lesniewski 和 Woodward 开发的标准一阶短时间渐近公式来执行。\n\n首先，确定问题的有效性。该问题在科学上基于量化金融中已建立的随机波动率模型理论。它是一个适定的、客观的问题，并为得到唯一解提供了所有必要的参数和条件。提及“标准的一阶短时间表达式”明确指向了广泛使用的 Hagan 等人的公式。所有提供的测试案例都遵守SABR模型定义的参数约束，即 $F0$、$K0$、$T0$、$\\alpha0$、$\\beta \\in [0,1]$、$\\rho \\in (-1,1)$ 和 $\\nu \\ge 0$。因此，该问题被认为是有效的，并且可以构建一个严谨的解决方案。\n\n解决方案的核心是实现用于Black-Scholes隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的 Hagan 渐近公式。该公式为SABR价格到波动率的映射提供了一个精确的近似，尤其适用于短到期日的情况。\n\n对于给定的远期价格 $F$、行权价 $K$、到期时间 $T$、初始波动率 $\\alpha$ 以及SABR参数 $\\beta, \\rho, \\nu$，隐含波动率 $\\sigma_{\\mathrm{imp}}$ 的通用公式为：\n$$ \\sigma_{\\mathrm{imp}}(F,K) \\approx \\frac{\\alpha}{\\left(FK\\right)^{\\frac{1-\\beta}{2}} \\left[1 + \\frac{(1-\\beta)^2}{24}\\log^2\\left(\\frac{F}{K}\\right) + \\frac{(1-\\beta)^4}{1920}\\log^4\\left(\\frac{F}{K}\\right)\\right]} \\times \\left(\\frac{z}{\\chi(z)}\\right) \\times \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24(FK)^{1-\\beta}} + \\frac{\\rho\\beta\\nu\\alpha}{4(FK)^{\\frac{1-\\beta}{2}}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n该表达式由三个主要部分组成：\n$1$. 一个主干项，它依赖于价内程度 $\\log(F/K)$ 和参数 $\\beta$。为求完整，我们包含了在 $\\log(F/K)$ 中直到四阶的展开式，这是提高远离平价时期权准确性的标准做法。\n$2$. 一个项 $\\frac{z}{\\chi(z)}$，它修正了由 $\\nu$ 及其与远期过程的相关性 $\\rho$ 驱动的波动率过程的随机性。辅助变量 $z$ 和 $\\chi(z)$ 定义如下：\n$$ z = \\frac{\\nu}{\\alpha}(FK)^{\\frac{1-\\beta}{2}} \\log\\left(\\frac{F}{K}\\right) $$\n$$ \\chi(z) = \\log\\left(\\frac{\\sqrt{1-2\\rho z+z^2}+z-\\rho}{1-\\rho}\\right) $$\n$3$. 一个时间依赖因子 $[1 + (\\dots)T]$，它表示到期时间 $T$ 的一阶修正。\n\n稳健实现的一个关键方面是处理此公式中的奇异点和数值不稳定性。具体来说，当期权为平价（$F=K$）时，价内程度 $\\log(F/K)=0$，这意味着 $z=0$。这导致项 $z/\\chi(z)$ 出现 $0/0$ 的不定式。为解决此问题，我们必须计算 $K \\to F$ 时的极限。在此极限下，$\\log(F/K) \\to 0$，所有在 $\\log(F/K)$ 中的展开项都消失，且 $\\lim_{z \\to 0} \\frac{z}{\\chi(z)} = 1$。公式简化为平价（ATM）隐含波动率：\n$$ \\sigma_{\\mathrm{imp}}(F,F) = \\frac{\\alpha}{F^{1-\\beta}} \\left[1 + \\left(\\frac{(1-\\beta)^2\\alpha^2}{24F^{2(1-\\beta)}} + \\frac{\\rho\\beta\\nu\\alpha}{4F^{1-\\beta}} + \\frac{2-3\\rho^2}{24}\\nu^2\\right)T\\right] $$\n对于测试套件中的案例2以及任何 $F$ 在数值上与 $K$ 无法区分的情况，必须使用这个专门的平价公式。\n\n算法设计如下：\n$1$. 对于每组输入参数 $(F, K, T, \\alpha, \\beta, \\rho, \\nu)$，首先评估对数价内程度 $x = \\log(F/K)$。\n$2$. 如果 $|x|$ 小于一个小的数值容差（例如，$10^{-7}$），则认为该期权是平价期权。应用简化的平价公式来计算隐含波动率。这个分支正确处理了 $F=K$ 的案例2，并防止了近乎平价期权的数值错误。\n$3$. 如果期权不是平价的，则使用完整的渐近公式。\n    a. 计算 $f = (FK)^{(1-\\beta)/2}$ 和 $z = (\\nu/\\alpha)f x$。\n    b. 计算主干项的分母，包括直到 $\\log^4(F/K)$ 的项。\n    c. 计算 $\\chi(z)$ 并随后计算比率 $z/\\chi(z)$。对于测试案例中提供的参数范围，包括接近 $\\pm 1$ 的 $\\rho$ 值，$\\chi(z)$ 的公式在数值上是稳定的。\n    d. 计算时间依赖的调整因子。\n    e. 组合所有项以计算最终的隐含波动率。\n\n这种结构化方法确保了在指定模型下的数学正确性，以及在各种输入参数范围内的数值稳健性。最终结果按要求四舍五入到 $8$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the lognormal Black implied volatility for European options\n    under the SABR model using the first-order small-time asymptotic formula\n    by Hagan et al. (2002).\n    \"\"\"\n\n    def sabr_implied_vol(F, K, T, alpha, beta, rho, nu):\n        \"\"\"\n        Calculates SABR implied volatility.\n\n        Args:\n            F (float): Forward price.\n            K (float): Strike price.\n            T (float): Time to maturity in years.\n            alpha (float): Initial volatility.\n            beta (float): Exponent parameter.\n            rho (float): Correlation parameter.\n            nu (float): Volatility of volatility.\n\n        Returns:\n            float: The SABR implied volatility.\n        \"\"\"\n        # For numerical stability, treat cases where F and K are very close as at-the-money.\n        # This avoids issues with log(F/K) and z being close to zero.\n        if abs(F - K)  1e-7:\n            f_atm = F**(1 - beta)\n            term1 = (1 - beta)**2 * alpha**2 / (24 * f_atm**2)\n            term2 = rho * beta * nu * alpha / (4 * f_atm)\n            term3 = (2 - 3 * rho**2) * nu**2 / 24\n            time_adj = 1 + (term1 + term2 + term3) * T\n            return (alpha / f_atm) * time_adj\n\n        log_FK = np.log(F / K)\n        f = (F * K)**((1 - beta) / 2)\n        \n        # Check for nu=0, which corresponds to the CEV model. In this case, z=0 and z/chi(z)=1.\n        if nu == 0:\n            z = 0.\n            z_over_chi = 1.\n        else:\n            z = nu / alpha * f * log_FK\n            # Use full expression for chi(z) as it's stable for given test cases.\n            sqrt_term = np.sqrt(1 - 2 * rho * z + z**2)\n            chi_z = np.log((sqrt_term + z - rho) / (1 - rho))\n            z_over_chi = z / chi_z\n\n        # Backbone term including expansion up to 4th order in log-moneyness for accuracy.\n        denom_beta_expansion = (1 +\n                                (1 - beta)**2 / 24 * log_FK**2 +\n                                (1 - beta)**4 / 1920 * log_FK**4)\n\n        # Time-dependent adjustment term (first-order in T).\n        term1 = (1 - beta)**2 * alpha**2 / (24 * f**2)\n        term2 = rho * beta * nu * alpha / (4 * f)\n        term3 = (2 - 3 * rho**2) * nu**2 / 24\n        time_adj = 1 + (term1 + term2 + term3) * T\n\n        vol = (alpha / (f * denom_beta_expansion)) * z_over_chi * time_adj\n        return vol\n\n    # Test Suite from the problem statement.\n    # Each case is a tuple (F, K, T, alpha, beta, rho, nu).\n    test_cases = [\n        (1.0, 1.1, 1.0, 0.3, 0.7, -0.3, 0.5), # Case 1\n        (1.0, 1.0, 2.0, 0.25, 1.0, 0.0, 0.4), # Case 2 (at-the-money)\n        (1.0, 0.9, 0.0001, 0.2, 0.5, 0.5, 1.2), # Case 3 (very short maturity)\n        (2.0, 1.0, 3.0, 0.15, 0.9, 0.99, 0.8), # Case 4 (high positive correlation)\n        (0.5, 0.8, 0.5, 0.4, 0.3, -0.99, 1.0), # Case 5 (high negative correlation, low beta)\n    ]\n\n    results = []\n    for case in test_cases:\n        F, K, T, alpha, beta, rho, nu = case\n        implied_vol = sabr_implied_vol(F, K, T, alpha, beta, rho, nu)\n        # Round the result to 8 decimal places.\n        results.append(f\"{implied_vol:.8f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2400489"}]}