{"hands_on_practices": [{"introduction": "期权定价理论不仅在于计算价格，更在于理解和管理风险。“Greeks”正是衡量这些风险的敏感性指标，其中“rho”($\\rho$)用以衡量期权价格对无风险利率变化的敏感度。这个练习通过一个超长期限的假设性期权 [@problem_id:2438207]，旨在放大并清晰地揭示利率对期权价值的长期影响，从而帮助你掌握风险度量的核心计算方法。", "problem": "考虑在 Black–Scholes–Merton (BSM) 模型假设下，一份针对不支付股息股票的欧式看涨期权。当前股价为 $S_{0}=100$，行权价为 $K=100$，到期时间为 $T=100$ 年，年化连续复利无风险利率为 $r=0.02$，年化波动率为 $\\sigma=0.20$。计算该期权的 rho 值 $\\rho$，其定义为期权价格对连续复利无风险利率 $r$ 的偏导数，并使用给定参数进行计算。将您的答案以单个实数的形式给出，并四舍五入到四位有效数字。将 $\\rho$ 解释为年化连续复利无风险利率每单位变化所引起的货币单位变化量。", "solution": "所述问题提法恰当，有科学依据，并包含了在 Black-Scholes-Merton 框架下获得唯一解所需的所有信息。我们将继续进行推导与计算。\n\n不支付股息股票的欧式看涨期权价格 $C$ 由 Black-Scholes-Merton (BSM) 公式给出。在时间 $t=0$ 时，其价格为：\n$$ C = S_{0} N(d_1) - K \\exp(-rT) N(d_2) $$\n其中 $N(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)。$d_1$ 和 $d_2$ 的定义如下：\n$$ d_1 = \\frac{\\ln\\left(\\frac{S_{0}}{K}\\right) + \\left(r + \\frac{1}{2}\\sigma^{2}\\right)T}{\\sigma\\sqrt{T}} $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} $$\n期权的 rho 值 $\\rho$ 是期权价格 $C$ 关于无风险利率 $r$ 的偏导数：\n$$ \\rho = \\frac{\\partial C}{\\partial r} $$\n我们对 $C$ 的 BSM 公式应用链式法则和乘积法则：\n$$ \\rho = \\frac{\\partial}{\\partial r} \\left[ S_{0} N(d_1) - K \\exp(-rT) N(d_2) \\right] $$\n$$ \\rho = S_{0} \\frac{\\partial N(d_1)}{\\partial r} - \\left[ \\frac{\\partial (K \\exp(-rT))}{\\partial r} N(d_2) + K \\exp(-rT) \\frac{\\partial N(d_2)}{\\partial r} \\right] $$\n令 $N'(x)$ 表示标准正态分布的概率密度函数 (PDF)。使用链式法则，$\\frac{\\partial N(x)}{\\partial r} = N'(x) \\frac{\\partial x}{\\partial r}$。\n$$ \\rho = S_{0} N'(d_1) \\frac{\\partial d_1}{\\partial r} - \\left[ -TK \\exp(-rT) N(d_2) + K \\exp(-rT) N'(d_2) \\frac{\\partial d_2}{\\partial r} \\right] $$\n接下来，我们求 $d_1$ 和 $d_2$ 关于 $r$ 的偏导数：\n$$ \\frac{\\partial d_1}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ \\frac{\\ln(S_{0}/K) + rT + \\frac{1}{2}\\sigma^{2}T}{\\sigma\\sqrt{T}} \\right] = \\frac{T}{\\sigma\\sqrt{T}} = \\frac{\\sqrt{T}}{\\sigma} $$\n$$ \\frac{\\partial d_2}{\\partial r} = \\frac{\\partial}{\\partial r} \\left[ d_1 - \\sigma\\sqrt{T} \\right] = \\frac{\\partial d_1}{\\partial r} = \\frac{\\sqrt{T}}{\\sigma} $$\n将这些代入 $\\rho$ 的表达式中：\n$$ \\rho = S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} + TK \\exp(-rT) N(d_2) - K \\exp(-rT) N'(d_2) \\frac{\\sqrt{T}}{\\sigma} $$\nBSM 模型中的一个基本恒等式是 $S_{0} N'(d_1) = K \\exp(-rT) N'(d_2)$。将此恒等式代入 $\\rho$ 表达式的第三项：\n$$ \\rho = S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} + TK \\exp(-rT) N(d_2) - S_{0} N'(d_1) \\frac{\\sqrt{T}}{\\sigma} $$\n第一项和第三项相互抵消，得到 rho 的简化公式：\n$$ \\rho = K T \\exp(-rT) N(d_2) $$\n现在，我们将给定参数代入我们的公式中：\n$S_{0} = 100$\n$K = 100$\n$T = 100$ 年\n$r = 0.02$ 每年\n$\\sigma = 0.20$ 每年\n\n首先，我们计算 $d_1$ 和 $d_2$：\n由于 $S_{0}=K$，项 $\\ln(S_{0}/K) = \\ln(1) = 0$。\n$$ d_1 = \\frac{0 + \\left(0.02 + \\frac{1}{2}(0.20)^{2}\\right) \\times 100}{0.20\\sqrt{100}} = \\frac{\\left(0.02 + \\frac{1}{2}(0.04)\\right) \\times 100}{0.20 \\times 10} = \\frac{(0.02 + 0.02) \\times 100}{2} = \\frac{0.04 \\times 100}{2} = \\frac{4}{2} = 2 $$\n$$ d_2 = d_1 - \\sigma\\sqrt{T} = 2 - 0.20\\sqrt{100} = 2 - 2 = 0 $$\n接下来，我们计算 $N(d_2)$ 的值：\n$$ N(d_2) = N(0) $$\n由于标准正态分布围绕其均值 0 对称，其累积分布函数在 0 处的值恰好是 0.5。\n$$ N(0) = 0.5 $$\n最后，我们将这些值代入 $\\rho$ 的公式中：\n$$ \\rho = K T \\exp(-rT) N(d_2) = 100 \\times 100 \\times \\exp(-0.02 \\times 100) \\times 0.5 $$\n$$ \\rho = 10000 \\times \\exp(-2) \\times 0.5 = 5000 \\exp(-2) $$\n为了求出数值，我们计算：\n$$ \\rho \\approx 5000 \\times 0.13533528... \\approx 676.6764... $$\n按要求四舍五入到四位有效数字，得到 $676.7$。\n\nrho 的解释是期权价格相对于无风险利率的变化率。$\\rho = 676.7$ 的值意味着，当年化连续复利无风险利率增加 1 个单位（例如，从 $r=0.02$ 增加到 $r=1.02$）时，在其他条件不变的情况下，期权价格预计将增加约 $676.7$ 个货币单位。更实际地讲，如果利率增加 1%（即 $\\Delta r = 0.01$），期权价格将增加约 $676.7 \\times 0.01 = 6.767$ 个货币单位。", "answer": "$$\\boxed{676.7}$$", "id": "2438207"}, {"introduction": "Black-Scholes-Merton 框架的强大之处在于其通用性，它不仅适用于标准的看涨和看跌期权。本练习将挑战你为一种名为“价差期权”(gap option) 的奇异期权定价 [@problem_id:2438273]。通过将复杂的支付结构分解为更简单的、可定价的组成部分（如现金或无价值、资产或无价值期权），你将深化对风险中性定价基本原理的理解，并学会如何将其应用于更广泛的金融产品。", "problem": "考虑一个满足Black-Scholes-Merton (BSM) 假设的无摩擦市场。设连续复利无风险利率为常数 $r \\ge 0$，且某单一股票以常数比率 $q \\ge 0$ 支付连续股息收益。在风险中性概率测度下，股价过程 $\\{S_t\\}_{t \\in [0,T]}$ 服从随机微分方程\n$$\n\\mathrm{d}S_t = (r - q)\\,S_t\\,\\mathrm{d}t + \\sigma\\,S_t\\,\\mathrm{d}W_t,\n$$\n其中 $S_0 > 0$，波动率 $\\sigma > 0$，$W_t$ 为标准布朗运动。固定到期日 $T > 0$。设 $K_1 > 0$，$K_2 > 0$ 和 $A > 0$ 为给定的常数。\n\n定义两个在时间 $T$ 到期的欧式或有债权：\n- 债权 $\\mathcal{C}_{\\text{cash}}$ 的收益为：如果 $S_T > K_1$，则为 $A$；否则为 $0$。\n- 债权 $\\mathcal{C}_{\\text{gap}}$ 的收益为 $(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。\n\n假设满足Black-Scholes-Merton框架中通常的无套利和市场完备性条件。求 $\\mathcal{C}_{\\text{cash}}$ 和 $\\mathcal{C}_{\\text{gap}}$ 在时间 $0$ 的无套利价格的闭式解，用模型参数 $S_0$、$r$、$q$、$\\sigma$、$T$、$K_1$、$K_2$ 和 $A$ 表示。\n\n答案格式：以一个 $1 \\times 2$ 行矩阵的形式提供你的最终答案，第一个条目是 $\\mathcal{C}_{\\text{cash}}$ 的价格，第二个条目是 $\\mathcal{C}_{\\text{gap}}$ 的价格。不要四舍五入。答案中不要包含任何单位。", "solution": "对问题陈述进行验证。\n\n**第1步：提取已知条件**\n- 市场假设：无摩擦，满足Black-Scholes-Merton (BSM) 框架。\n- 连续复利无风险利率：常数 $r \\ge 0$。\n- 连续股息收益：常数比率 $q \\ge 0$。\n- 风险中性股价过程 $\\{S_t\\}_{t \\in [0,T]}$: $\\mathrm{d}S_t = (r - q)\\,S_t\\,\\mathrm{d}t + \\sigma\\,S_t\\,\\mathrm{d}W_t$。\n- 初始股价：$S_0 > 0$。\n- 波动率：$\\sigma > 0$。\n- $W_t$：标准布朗运动。\n- 到期日：$T > 0$。\n- 常数：$K_1 > 0$，$K_2 > 0$，$A > 0$。\n- 债权 $\\mathcal{C}_{\\text{cash}}$ 在时间 $T$ 的收益：如果 $S_T > K_1$，则为 $A$；否则为 $0$。即 $A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}$。\n- 债权 $\\mathcal{C}_{\\text{gap}}$ 在时间 $T$ 的收益：$(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。\n- 经济假设：无套利和市场完备性。\n- 目标：确定 $\\mathcal{C}_{\\text{cash}}$ 和 $\\mathcal{C}_{\\text{gap}}$ 在时间 $0$ 的无套利价格。\n\n**第2步：使用提取的已知条件进行验证**\n该问题具有科学依据，是Black-Scholes-Merton模型的标准应用，该模型是量化金融中的一个基本理论。该问题是适定的，因为BSM框架为计算具有给定收益结构的欧式衍生品提供了唯一价格的计算方法。所有必要的参数都以符号形式给出，问题是自洽的，没有内部矛盾。语言客观、精确。该问题不违反任何指定的无效标准。\n\n**第3步：结论与行动**\n问题有效，可以求解。\n\n资产定价基本定理指出，在一个完备、无套利市场中，到期日为 $T$、收益为 $\\Pi(S_T)$ 的欧式或有债权在时间 $0$ 的价格 $V_0$ 是在风险中性概率测度 $\\mathbb{Q}$ 下收益的贴现期望值。\n$$\nV_0 = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\Pi(S_T)]\n$$\n在 $\\mathbb{Q}$ 下，所给出的股价 $S_t$ 的随机微分方程是一个几何布朗运动。此SDE的解为：\n$$\nS_T = S_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma W_T \\right)\n$$\n其中在 $\\mathbb{Q}$ 下，$W_T \\sim N(0, T)$。我们可以写成 $W_T = \\sqrt{T}Z$，其中 $Z$ 是一个标准正态随机变量，$Z \\sim N(0, 1)$。因此，$\\ln(S_T)$ 服从正态分布：\n$$\n\\ln(S_T) \\sim N\\left(\\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T, \\sigma^2 T\\right)\n$$\n为方便起见，我们定义关于执行价格 $K_1$ 的标准BSM辅助变量 $d_1$ 和 $d_2$：\n$$\nd_1 = \\frac{\\ln(S_0/K_1) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = \\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}} = d_1 - \\sigma\\sqrt{T}\n$$\n令 $N(\\cdot)$ 表示标准正态分布的累积分布函数 (CDF)。\n\n**债权 $\\mathcal{C}_{\\text{cash}}$ 的价格**\n$\\mathcal{C}_{\\text{cash}}$ 的收益为 $\\Pi_{\\text{cash}} = A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}$。这是一个现金或无价值看涨期权。其在时间 $0$ 的价格，记为 $V_{\\text{cash}}(0)$，是：\n$$\nV_{\\text{cash}}(0) = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[A \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = A \\exp(-rT)\\,\\mathbb{Q}(S_T > K_1)\n$$\n我们必须计算概率 $\\mathbb{Q}(S_T > K_1)$。\n$$\n\\mathbb{Q}(S_T > K_1) = \\mathbb{Q}\\left( \\ln(S_T) > \\ln(K_1) \\right)\n$$\n$$\n= \\mathbb{Q}\\left( \\ln(S_0) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}Z > \\ln(K_1) \\right)\n$$\n$$\n= \\mathbb{Q}\\left( \\sigma\\sqrt{T}Z > \\ln(K_1/S_0) - \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T \\right)\n$$\n$$\n= \\mathbb{Q}\\left( Z > -\\frac{\\ln(S_0/K_1) + \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} \\right)\n$$\n概率的参数恰好是 $-d_2$。\n$$\n\\mathbb{Q}(S_T > K_1) = \\mathbb{Q}(Z > -d_2) = \\mathbb{Q}(Z \\le d_2) = N(d_2)\n$$\n因此，$\\mathcal{C}_{\\text{cash}}$ 的价格是：\n$$\nV_{\\text{cash}}(0) = A \\exp(-rT) N(d_2)\n$$\n\n**债权 $\\mathcal{C}_{\\text{gap}}$ 的价格**\n$\\mathcal{C}_{\\text{gap}}$ 的收益为 $\\Pi_{\\text{gap}} = (S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}$。这是一个价差期权。其在时间 $0$ 的价格，记为 $V_{\\text{gap}}(0)$，可以通过期望的线性性质分解：\n$$\nV_{\\text{gap}}(0) = \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[(S_T - K_2)\\,\\mathbf{1}_{\\{S_T > K_1\\}}]\n$$\n$$\n= \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] - K_2 \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}_{\\{S_T > K_1\\}}]\n$$\n第二项与之前计算的现金或无价值看涨期权的价格直接相关：\n$$\nK_2 \\exp(-rT)\\,\\mathbb{E}^{\\mathbb{Q}}[\\mathbf{1}_{\\{S_T > K_1\\}}] = K_2 \\exp(-rT)\\,\\mathbb{Q}(S_T > K_1) = K_2 \\exp(-rT) N(d_2)\n$$\n第一项是在 $S_T > K_1$ 时收到资产的贴现风险中性期望。这是资产或无价值看涨期权的价格。这是一个标准结果，即此价格为 $S_0 \\exp(-qT) N(d_1)$。形式上，这可以通过更换为计价物 $S_t \\exp(-qt)$ 或通过直接积分推导得出：\n$$\n\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = \\int_{-\\infty}^{\\infty} S_0 \\exp\\left( \\left(r - q - \\frac{1}{2}\\sigma^2\\right)T + \\sigma\\sqrt{T}z \\right) \\cdot \\mathbf{1}_{\\{S_T > K_1\\}} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{z^2}{2}\\right) dz\n$$\n条件 $S_T > K_1$ 对应于 $z > -d_2$。积分变为：\n$$\nS_0 \\exp\\left( (r-q)T \\right) \\int_{-d_2}^{\\infty} \\frac{1}{\\sqrt{2\\pi}} \\exp\\left(-\\frac{1}{2}(z - \\sigma\\sqrt{T})^2\\right) dz\n$$\n使用换元 $y = z - \\sigma\\sqrt{T}$，积分下限变为 $-d_2 - \\sigma\\sqrt{T} = -(d_2 + \\sigma\\sqrt{T}) = -d_1$。积分结果为 $N(d_1)$。\n$$\n\\mathbb{E}^{\\mathbb{Q}}[S_T \\cdot \\mathbf{1}_{\\{S_T > K_1\\}}] = S_0 \\exp((r-q)T) N(d_1)\n$$\n将其贴现回时间 $0$ 得到第一项的值：\n$$\n\\exp(-rT) \\left( S_0 \\exp((r-q)T) N(d_1) \\right) = S_0 \\exp(-qT) N(d_1)\n$$\n合并两项，$\\mathcal{C}_{\\text{gap}}$ 的价格是：\n$$\nV_{\\text{gap}}(0) = S_0 \\exp(-qT) N(d_1) - K_2 \\exp(-rT) N(d_2)\n$$\n\n最终价格用给定的模型参数表示，其中 $d_1$、$d_2$ 和 $N(\\cdot)$ 的定义如上。", "answer": "$$\n\\boxed{\\begin{pmatrix} A \\exp(-rT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right)  S_0 \\exp(-qT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right) - K_2 \\exp(-rT) N\\left(\\frac{\\ln(S_0/K_1) + (r - q - \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\\right) \\end{pmatrix}}\n$$", "id": "2438273"}, {"introduction": "理论模型与现实世界之间存在差距，完美的对冲只存在于理想化的假设之中。本练习将带你从理论走向实践，通过编程模拟来检验 Black-Scholes-Merton 模型的对冲效果 [@problem_id:2438266]。你将实施一个离散时间的 Delta 对冲策略，并比较在模型假设成立（几何布朗运动）与不成立（均值回归过程）两种情境下的对冲误差，从而对至关重要的“模型风险”概念获得直观而深刻的认识。", "problem": "构建一个独立的程序，用于计算和比较在两种不同的标的资产价格数据生成过程中，一个欧式看涨期权的delta中性、自融资复制策略所产生的期末对冲误差。第一个过程是几何布朗运动，第二个是通过对Ornstein-Uhlenbeck过程取指数得到的均值回归过程。所有利率和波动率必须以小数形式表示。\n\n设标的资产价格为 $S_t$，执行价格为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$。考虑一个收益为 $\\max(S_T - K, 0)$ 的欧式看涨期权。\n\n模型 A（几何布朗运动）：价格过程 $S_t$ 遵循\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n其中连续股息收益率 $q = 0$。模型 B（指数Ornstein-Uhlenbeck）：定义 $X_t$ 遵循\n$$\n\\mathrm{d}X_t = \\kappa\\,(\\theta - X_t)\\,\\mathrm{d}t + \\eta\\, \\mathrm{d}W_t,\n$$\n并设 $S_t = \\exp(X_t)$ 以确保其为正值。使用 $X_0 = \\ln(S_0)$ 并设定 $\\theta = \\ln(S_0)$。\n\n对冲策略定义如下。在均匀网格 $t_0 = 0$, $t_i = i\\,\\Delta t$, $i \\in \\{0,1,\\dots,N\\}$, $\\Delta t = T/N$ 上的每个再平衡时间 $t_i$，构建一个delta中性、自融资的投资组合，该组合使用在几何布朗运动假设下（波动率参数为 $\\sigma$，股息收益率为 $q=0$）计算出的Black-Scholes-Merton delta。具体而言，令 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示剩余到期时间为 $\\tau$ 时的Black-Scholes-Merton价格，令 $\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 表示相应的delta值。在 $t_0$ 时刻初始化投资组合，现金头寸为 $B_0$，股票头寸为 $\\Delta_0$，其中 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 且 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在两次再平衡之间，现金账户以利率 $r$ 计息。在每个再平衡时间 $t_i$（其中 $i \\in \\{1,\\dots,N-1\\}$），通过买入或卖出股票将股票头寸从 $\\Delta_{i-1}$ 调整为 $\\Delta_i = \\Delta_{\\text{BSM}}(S_{t_i}, K, r, \\sigma, T - t_i)$；现金账户相应地记入借方或贷方，以使该策略是自融资的。在到期日 $t_N = T$ 不进行再平衡。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1}\\, S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n您的程序必须为每个指定的测试用例估计模型A和模型B下的均方根对冲误差。这需要以时间步长 $\\Delta t = T/N$ 模拟标的过程的 $M$ 条独立路径，沿每条路径如上所述执行离散时间对冲策略，然后计算\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n为使结果具有确定性和可测试性，请使用一个伪随机数生成器，并为索引从0开始的测试用例 $i$ 使用种子 $s_i = 123456 + i$ 进行初始化。在每个测试用例中，对模型A和模型B使用相同的标准正态冲击序列。所有利率和波动率必须以小数形式表示。\n\n测试套件（三个案例，共同覆盖典型情况、粗略再平衡边界和压力配置）。在每个案例中，指定 $(S_0, K, r, T, \\sigma, \\kappa, \\eta, N, M)$：\n- 案例 0（典型）：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$。\n- 案例 1（粗略再平衡）：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$。\n- 案例 2（压力）：$S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个方括号内的逗号分隔列表形式的结果。对于每个测试用例 $i \\in \\{0,1,2\\}$，报告一个双元素列表 $[\\text{RMSE}^{(A)}_i, \\text{RMSE}^{(B)}_i]$，其中 $\\text{RMSE}^{(A)}_i$ 是模型A下的均方根对冲误差，$\\text{RMSE}^{(B)}_i$ 是模型B下的均方根对冲误差。将每个报告值四舍五入到6位小数。因此，最终输出必须是如下所示的单行\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B)}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr].\n$$", "solution": "我们比较在两种不同的标的数据生成过程中，欧式看涨期权的离散时间delta对冲复制误差。该构建基于两个原则：Black-Scholes-Merton框架下的无套利定价和自融资delta对冲。\n\n首先，在Black-Scholes-Merton框架（Black-Scholes-Merton）下，当标的 $S_t$ 遵循连续股息收益率 $q = 0$ 的几何布朗运动时，\n$$\n\\mathrm{d}S_t = (r - q)\\, S_t\\, \\mathrm{d}t + \\sigma\\, S_t\\, \\mathrm{d}W_t,\n$$\n欧式看涨期权在剩余到期时间为 $\\tau$ 时的无套利价格 $C_{\\text{BSM}}(S, K, r, \\sigma, \\tau)$ 是通过求解风险中性估值问题，或等价地，求解相关的偏微分方程得到的。相应的delta是价格对标的资产的导数。具体来说，\n$$\nd_1 = \\frac{\\ln(S/K) + (r - q + \\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma \\sqrt{\\tau}},\\quad d_2 = d_1 - \\sigma \\sqrt{\\tau},\n$$\n$$\nC_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau} S\\, \\Phi(d_1) - \\mathrm{e}^{-r \\tau} K\\, \\Phi(d_2),\n$$\n$$\n\\Delta_{\\text{BSM}}(S, K, r, \\sigma, \\tau) = \\mathrm{e}^{-q \\tau}\\, \\Phi(d_1),\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态累积分布函数，且此处 $q=0$。\n\n其次，考虑一个自融资、delta中性的投资组合，该组合最初做空一份看涨期权，并持有 $\\Delta_0 = \\Delta_{\\text{BSM}}(S_0, K, r, \\sigma, T)$ 份股票，现金为 $B_0 = C_{\\text{BSM}}(S_0, K, r, \\sigma, T) - \\Delta_0 S_0$。在网格 $t_i = i \\Delta t$（其中 $i \\in \\{0,1,\\dots,N\\}$ 且 $\\Delta t = T/N$）上，现金账户在两次再平衡之间以利率 $r$ 计息，而在时间 $t_i$ 将头寸从 $\\Delta_{i-1}$ 再平衡到 $\\Delta_i$ 会使现金改变 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$。由于 $q=0$，没有股息流。作为连续时间自融资条件的离散时间近似，对于 $i \\in \\{1,2,\\dots,N-1\\}$，\n$$\nB_i = B_{i-1}\\, \\mathrm{e}^{r \\Delta t} - \\left(\\Delta_i - \\Delta_{i-1}\\right) S_{t_i}.\n$$\n在到期日 $t_N = T$ 不进行再平衡。期末投资组合价值为\n$$\nV_T = \\Delta_{N-1} S_T + B_{N-1}\\, \\mathrm{e}^{r \\Delta t},\n$$\n期末对冲误差为\n$$\nE = V_T - \\max(S_T - K, 0).\n$$\n\n我们在 $M$ 条样本路径上评估和比较两种数据生成过程的均方根误差：\n\n- 模型 A（几何布朗运动）：模拟\n$$\nS_{t_{i+1}} = S_{t_i} \\exp\\left((r - q - \\tfrac{1}{2}\\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z_i\\right),\n$$\n其中 $q=0$ 且 $Z_i$ 为独立标准正态冲击。\n\n- 模型 B（指数Ornstein-Uhlenbeck）：将 $X_t$ 模拟为\n$$\nX_{t_{i+1}} = \\theta + (X_{t_i} - \\theta)\\, \\mathrm{e}^{-\\kappa \\Delta t} + \\eta\\, \\sqrt{\\frac{1 - \\mathrm{e}^{-2 \\kappa \\Delta t}}{2 \\kappa}}\\, Z_i,\n$$\n并设 $S_{t_i} = \\exp(X_{t_i})$。我们使用 $X_0 = \\ln(S_0)$ 和 $\\theta = \\ln(S_0)$，使得 $X_t$ 向初始对数价格均值回归。\n\n在给定的测试用例中，对两个模型使用相同的冲击序列 $Z_i$ 可以提高可比性。为了保证确定性，我们为测试用例索引 $i \\in \\{0,1,2\\}$ 使用种子 $s_i = 123456 + i$ 初始化伪随机数生成器。对于每条路径，我们执行离散对冲程序：在 $t_0$ 时刻，根据Black-Scholes-Merton价格和delta设置 $\\Delta_0$ 和 $B_0$；在每个时间间隔内，现金以利率 $r$ 计息，使用所选模型推进标的价格；在下一个网格时间 $t_i$（其中 $i \\in \\{1,\\dots,N-1\\}$），使用当前 $S_{t_i}$ 和剩余时间 $T - t_i$ 计算的Black-Scholes-Merton delta来更新 $\\Delta_i$，并通过 $-(\\Delta_i - \\Delta_{i-1}) S_{t_i}$ 调整现金。在到期时，计算 $V_T$ 和误差 $E$，然后计算均方根误差\n$$\n\\text{RMSE} = \\sqrt{\\frac{1}{M} \\sum_{m=1}^{M} E_m^2}.\n$$\n\n测试套件指定了三组参数：\n- 案例 0：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 252$, $M = 20000$，种子 $123456$。\n- 案例 1：$S_0 = 100$, $K = 100$, $r = 0.02$, $T = 1$, $\\sigma = 0.2$, $\\kappa = 1.0$, $\\eta = 0.2$, $N = 1$, $M = 20000$，种子 $123457$。\n- 案例 2：$S_0 = 100$, $K = 50$, $r = 0.02$, $T = 0.25$, $\\sigma = 0.4$, $\\kappa = 3.0$, $\\eta = 0.3$, $N = 13$, $M = 20000$，种子 $123458$。\n\n最终程序必须输出单行，将三个案例的结果汇总为一个列表的列表\n$$\n\\bigl[[\\text{RMSE}^{(A)}_0,\\ \\text{RMSE}^{(B)}_0],\\ [\\text{RMSE}^{(A)}_1,\\ \\text{RMSE}^{(B}_1],\\ [\\text{RMSE}^{(A)}_2,\\ \\text{RMSE}^{(B)}_2]\\bigr],\n$$\n每个浮点数四舍五入到6位小数。这种格式便于自动评估。其科学原理是，在几何布朗运动和连续再平衡下，Black-Scholes-Merton的delta对冲可以消除风险，而离散再平衡会留下残余误差；在错误设定的动态过程（如指数Ornstein-Uhlenbeck）下，Black-Scholes-Merton的delta与模型不一致，复制误差通常更大，而本计算正是要量化这一事实。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom math import log, exp, sqrt, isfinite\nfrom scipy.stats import norm\n\ndef bs_price_delta(S, K, r, sigma, tau):\n    \"\"\"\n    Black-Scholes-Merton call price and delta with zero dividend yield.\n    Vectorized over S and tau (tau can be scalar).\n    \"\"\"\n    S = np.asarray(S, dtype=float)\n    tau = float(tau)\n    # Handle tau == 0 separately to avoid division by zero.\n    if tau == 0.0:\n        # At maturity: price = max(S - K, 0), delta = 1_{S > K} with 0.5 at S==K\n        price = np.maximum(S - K, 0.0)\n        delta = np.where(S > K, 1.0, np.where(S  K, 0.0, 0.5))\n        return price, delta\n\n    # For tau > 0:\n    vol_sqrt_tau = sigma * sqrt(tau)\n    # Avoid log(0)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        d1 = (np.log(S / K) + (r + 0.5 * sigma * sigma) * tau) / vol_sqrt_tau\n    d2 = d1 - vol_sqrt_tau\n\n    Nd1 = norm.cdf(d1)\n    Nd2 = norm.cdf(d2)\n    price = S * Nd1 - K * exp(-r * tau) * Nd2\n    delta = Nd1\n    # Handle any NaNs due to S = 0 (shouldn't occur in our simulations)\n    price = np.where(np.isfinite(price), price, 0.0)\n    delta = np.where(np.isfinite(delta), delta, 0.0)\n    return price, delta\n\ndef simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z):\n    \"\"\"\n    Simulate GBM paths and compute RMSE of terminal hedging error\n    for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    S = np.full(M, S0, dtype=float)\n    # Initial BSM price and delta\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    mu_dt = (r - 0.0 - 0.5 * sigma * sigma) * dt\n    vol_sqrt_dt = sigma * sqrt(dt)\n    erdt = exp(r * dt)\n\n    # Rebalance at times t=dt, 2dt, ..., (N-1)dt\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance S over dt\n        S = S * np.exp(mu_dt + vol_sqrt_dt * Z[:, i])\n        # Rebalance at next grid time if not maturity\n        if i  N - 1:\n            tau_next = T - (i + 1) * dt\n            # Compute new delta at time t_{i+1}\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            # Self-financing cash adjustment\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n        # else: no rebalancing at maturity\n\n    # Terminal portfolio value and hedging error\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta):\n    \"\"\"\n    Simulate exponential OU paths (X OU, S=exp(X)) and compute RMSE of\n    terminal hedging error for BSM delta-hedging with discrete rebalancing.\n    Z: array of shape (M, N) standard normals for increments.\n    \"\"\"\n    M, Ncols = Z.shape\n    assert Ncols == N, \"Z shape mismatch with N\"\n    dt = T / N\n    # Initialize\n    X = np.full(M, log(S0), dtype=float)\n    theta = log(S0)  # mean-reversion level for log-price\n    S = np.exp(X)\n\n    # Initial BSM price and delta based on initial S\n    price0, delta = bs_price_delta(S, K, r, sigma, T)\n    cash = price0 - delta * S  # initial cash position\n\n    erdt = exp(r * dt)\n    ekdt = exp(-kappa * dt)\n    # Exact OU increment variance term\n    var_term = (1.0 - exp(-2.0 * kappa * dt)) / (2.0 * kappa) if kappa > 0 else dt\n    std_ou = eta * sqrt(var_term)\n\n    for i in range(N):\n        # Accrue cash over dt\n        cash *= erdt\n        # Advance X with exact OU step, then S = exp(X)\n        X = theta + (X - theta) * ekdt + std_ou * Z[:, i]\n        S = np.exp(X)\n        if i  N - 1:\n            tau_next = T - (i + 1) * dt\n            _, delta_next = bs_price_delta(S, K, r, sigma, tau_next)\n            cash -= (delta_next - delta) * S\n            delta = delta_next\n\n    V_T = delta * S + cash\n    payoff = np.maximum(S - K, 0.0)\n    error = V_T - payoff\n    rmse = float(np.sqrt(np.mean(error * error)))\n    return rmse\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each case: (S0, K, r, T, sigma, kappa, eta, N, M)\n    test_cases = [\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 252, 20000),   # Case 0\n        (100.0, 100.0, 0.02, 1.0, 0.2, 1.0, 0.2, 1,   20000),   # Case 1\n        (100.0, 50.0,  0.02, 0.25, 0.4, 3.0, 0.3, 13,  20000),  # Case 2\n    ]\n\n    results = []\n    for idx, case in enumerate(test_cases):\n        S0, K, r, T, sigma, kappa, eta, N, M = case\n        # Set deterministic seed per case\n        seed = 123456 + idx\n        rng = np.random.default_rng(seed)\n        Z = rng.standard_normal(size=(M, N))\n        # Model A: GBM\n        rmse_gbm = simulate_and_hedge_gbm(S0, K, r, sigma, T, N, Z)\n        # Model B: Exponential OU\n        rmse_expou = simulate_and_hedge_expou(S0, K, r, sigma, T, N, Z, kappa, eta)\n        # Round to 6 decimals as required\n        results.append([round(rmse_gbm, 6), round(rmse_expou, 6)])\n\n    # Format as a single-line nested list with comma-separated values.\n    # Ensure fixed 6 decimal places.\n    def format_results(res):\n        parts = []\n        for pair in res:\n            parts.append(f\"[{pair[0]:.6f},{pair[1]:.6f}]\")\n        return \"[\" + \",\".join(parts) + \"]\"\n\n    print(format_results(results))\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2438266"}]}