{"hands_on_practices": [{"introduction": "理论上的均值-方差优化通常不考虑卖空限制，从而得到一条平滑的有效前沿。然而在实际投资中，禁止卖空（即投资组合权重 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$）是常见约束，这使得有效前沿变为由一系列分段曲线构成。本练习 [@problem_id:2383613] 将指导你通过识别和计算关键的“角点投资组合”来构建这种分段式的有效前沿，并验证其基本性质，从而深入理解约束条件如何重塑最优投资决策。", "problem": "考虑一个带无卖空约束的均值-方差投资组合选择问题。设有 $n$ 种风险资产，其期望收益向量为 $\\boldsymbol{\\mu} \\in \\mathbb{R}^n$，协方差矩阵为正定矩阵 $\\boldsymbol{\\Sigma} \\in \\mathbb{R}^{n \\times n}$。一个投资组合由权重向量 $\\boldsymbol{w} \\in \\mathbb{R}^n$ 表示，满足 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$。对于一个目标期望收益 $r \\in \\mathbb{R}$，均值-方差有效投资组合通过求解以下凸优化问题得到：在满足约束条件 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$、$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 的情况下，最小化方差 $ \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$。\n\n角点投资组合（也称为临界投资组合）被定义为这样一个有效投资组合：当目标收益 $r$ 变化时，在该组合对应的 $r$ 值上，活跃不等式约束的集合发生改变，即 $\\boldsymbol{w}$ 的至少一个分量变为 $0$ 或从 $0$ 变为正数。在两个相邻的角点投资组合之间，具有严格正权重的资产集合保持不变。\n\n您的任务是：\n- 从上述基本定义出发，实现一个算法，该算法能够：\n  1. 在约束条件 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 下，计算最小方差投资组合，并记录其期望收益 $r_{\\mathrm{mv}} = \\boldsymbol{\\mu}^\\top \\boldsymbol{w}_{\\mathrm{mv}}$。\n  2. 通过在一系列网格化的 $r$ 值上求解在约束 $\\boldsymbol{1}^\\top \\boldsymbol{w} = 1$、$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$ 和 $\\boldsymbol{w} \\succeq \\boldsymbol{0}$ 下的方差最小化问题，构建目标收益在 $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 区间内的有效前沿。\n  3. 通过检测活跃资产集（严格正权重的指数集合）发生变化的收益水平来识别角点投资组合。对每个检测到的变化点，通过对 $r$ 进行二分法搜索来精确其位置，使变化点在 $r$ 上的定位容差在 $10^{-6}$ 以内。\n  4. 通过计算验证以下性质：对于任意一个目标收益为 $r$ 的有效投资组合，如果 $r$ 位于两个相邻角点投资组合的目标收益 $r_{\\ell}$ 和 $r_u$ 之间（即 $r_{\\ell} \\le r \\le r_u$），则其最优权重 $\\boldsymbol{w}(r)$ 在数值容差范围内等于某个凸组合 $\\tau \\boldsymbol{w}(r_u) + (1-\\tau)\\boldsymbol{w}(r_\\ell)$。其中 $\\tau \\in [0,1]$ 的选择应使组合后的投资组合期望收益为 $r$。\n- 在您的算法中，请使用以下容差约定：\n  - 在确定活跃集时，将任何小于或等于 $10^{-8}$ 的权重视为零。\n  - 在检查两个权重向量是否相等时，接受的最大绝对偏差至多为 $5 \\times 10^{-4}$。\n\n您必须实现您的算法，并将其应用于以下测试套件，其中每个测试用例指定了 $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma})$：\n\n- 测试用例 1（两种资产）：\n  - $\\boldsymbol{\\mu} = [\\,0.08,\\, 0.12\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix} 0.04  0.006 \\\\ 0.006  0.09 \\end{bmatrix}$。\n\n- 测试用例 2（三种资产，其中一种被构造为劣势资产）：\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.10,\\, 0.03\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.0422  0.0134  0.0418 \\\\\n  0.0134  0.0343  0.0276 \\\\\n  0.0418  0.0276  0.1062\n  \\end{bmatrix}$。\n\n- 测试用例 3（三种资产，均相关）：\n  - $\\boldsymbol{\\mu} = [\\,0.06,\\, 0.11,\\, 0.08\\,]$。\n  - $\\boldsymbol{\\Sigma} = \\begin{bmatrix}\n  0.02  0.015  0.005 \\\\\n  0.015  0.05  0.01 \\\\\n  0.005  0.01  0.03\n  \\end{bmatrix}$。\n\n对于每个测试用例，您必须：\n- 报告在 $r \\in [r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 区间的有效前沿上检测到的角点投资组合总数。\n- 通过在 $[r_{\\mathrm{mv}}, \\max_i \\mu_i]$ 区间内均匀采样至少 $5$ 个目标收益，并检查每个有效投资组合是否在其相邻角点投资组合的凸组合的指定容差范围内，来验证凸组合性质。将每个测试用例的这些检查结果汇总为一个布尔值，当且仅当所有采样目标收益都通过检查时，该值为真。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$[\\,\\text{corner\\_count\\_1},\\, \\text{convex\\_ok\\_1},\\, \\text{corner\\_count\\_2},\\, \\text{convex\\_ok\\_2},\\, \\text{corner\\_count\\_3},\\, \\text{convex\\_ok\\_3}\\,]$,\n其中每个角点计数是整数，每个凸性检查是布尔值。本问题不涉及物理单位，所有收益均为小数形式（例如，写作 $0.12$ 而不是 $12$ 百分比）。", "solution": "所给问题是计算金融领域中与 Markowitz 均值-方差优化相关的标准练习。它要求在无卖空约束（$\\boldsymbol{w} \\succeq \\boldsymbol{0}$）下，为一组风险资产构建有效前沿。这个任务本质上是一个凸二次规划（QP）问题。该问题陈述在科学上是合理的、自洽的且适定的，因为目标函数 $\\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w}$ 是严格凸的（因为 $\\boldsymbol{\\Sigma}$ 是正定的），并且对于任何可行的目标收益 $r$，约束条件定义了一个非空紧凸集。因此，存在唯一解。我们直接实现所要求的算法。\n\n核心优化问题表述如下：\n$$\n\\begin{aligned}\n \\underset{\\boldsymbol{w} \\in \\mathbb{R}^n}{\\text{最小化}}\n  \\frac{1}{2} \\boldsymbol{w}^\\top \\boldsymbol{\\Sigma} \\boldsymbol{w} \\\\\n \\text{约束于}\n  \\boldsymbol{1}^\\top \\boldsymbol{w} = 1, \\\\\n   \\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r, \\\\\n   w_i \\ge 0 \\quad \\text{对于 } i = 1, \\dots, n.\n\\end{aligned}\n$$\n这里，$\\boldsymbol{w}$ 是投资组合权重向量，$\\boldsymbol{\\mu}$ 是期望收益向量，$\\boldsymbol{\\Sigma}$ 是协方差矩阵，而 $r$ 是目标期望收益。我们使用 `scipy.optimize.minimize` 提供的序列最小二乘规划（`SLSQP`）方法来求解给定参数 $(\\boldsymbol{\\mu}, \\boldsymbol{\\Sigma}, r)$ 下的这个二次规划问题。\n\n根据问题说明，该算法分三个主要阶段进行。\n\n首先，确定有效前沿的相关范围。下界是在无卖空约束下的全局最小方差投资组合（GMVP）的期望收益 $r_{\\mathrm{mv}}$。该投资组合 $\\boldsymbol{w}_{\\mathrm{mv}}$ 是通过求解不含目标收益约束（$\\boldsymbol{\\mu}^\\top \\boldsymbol{w} = r$）的二次规划问题得到的。上界是可能的最大期望收益 $r_{\\max} = \\max_i \\mu_i$，通过将 $100\\%$ 的投资分配给具有最高期望收益的单个资产来实现。有效前沿是目标收益 $r \\in [r_{\\mathrm{mv}}, r_{\\max}]$ 范围内的最优投资组合集合。\n\n其次，识别角点投资组合。角点投资组合对应有效前沿上的一个点，在该点，具有严格正权重的资产集合（即活跃集）发生变化。我们寻找这些组合的步骤如下：\n$1$. 在区间 $[r_{\\mathrm{mv}}, r_{\\max}]$ 上生成一个包含 $1001$ 个目标收益的精细网格。\n$2$. 对于网格中的每个收益 $r_j$，我们求解二次规划问题以找到最优权重 $\\boldsymbol{w}(r_j)$。我们将活跃集定义为满足 $w_i(r_j) > 10^{-8}$ 的指数 $i$ 的集合。\n$3$. 我们扫描网格，识别出计算出的活跃集在相邻点 $(r_j, r_{j+1})$ 处不同的情况。这样的区间必定包含一个角点投资组合。\n$4$. 对每个识别出的区间，执行二分搜索以找到活跃集发生变化的临界收益 $r_c$。搜索过程不断精确 $r_c$ 的位置，直到搜索区间的宽度小于 $10^{-6}$。\n$5$. 最终的角点投资组合列表包括全局最小方差投资组合（GMVP）、最高收益投资组合以及通过二分搜索找到的所有唯一投资组合。该列表按收益排序并去重，以处理从多个网格区间找到相同角点的情况。然后报告这些唯一角点投资组合的总数。\n\n第三，我们通过计算验证双基金分离定理，该定理指出，任何位于两个相邻角点投资组合之间的有效投资组合都是这两个角点投资组合的凸组合。验证过程如下：\n$1$. 在整个区间 $[r_{\\mathrm{mv}}, r_{\\max}]$ 上生成一个至少包含 $5$ 个均匀间隔的目标收益 $\\{r_k\\}$ 的样本。\n$2$. 对于每个 $r_k$，我们直接使用二次规划求解器计算最优投资组合 $\\boldsymbol{w}_{actual}(r_k)$。\n$3$. 我们找出包含 $r_k$ 的两个相邻角点投资组合 $(r_\\ell, \\boldsymbol{w}_\\ell)$ 和 $(r_u, \\boldsymbol{w}_u)$，即 $r_\\ell \\le r_k \\le r_u$。\n$4$. 我们使用凸组合 $\\boldsymbol{w}_{theory}(r_k) = (1-\\tau) \\boldsymbol{w}_\\ell + \\tau \\boldsymbol{w}_u$ 计算理论投资组合 $\\boldsymbol{w}_{theory}(r_k)$，其中插值因子 $\\tau = (r_k - r_\\ell) / (r_u - r_\\ell)$ 确保了组合的期望收益为 $r_k$。\n$5$. 然后我们检查 $\\boldsymbol{w}_{actual}(r_k)$ 和 $\\boldsymbol{w}_{theory}(r_k)$ 是否在指定的数值容差内相等。如果它们对应权重之间的最大绝对差 $\\max_i |w_{actual,i}(r_k) - w_{theory,i}(r_k)|$ 不超过 $5 \\times 10^{-4}$，则检查通过。\n$6$. 当且仅当此条件对所有采样收益都成立时，该测试用例的总体验证才被视为成功（True）。\n\n将此综合程序系统地应用于所有测试用例，以生成所需结果。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve_qp(target_r, mu, Sigma, n):\n    \"\"\"Solves the quadratic programming problem for a given target return.\"\"\"\n    objective = lambda w: w.T @ Sigma @ w\n    w0 = np.ones(n) / n\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: w.T @ mu - target_r}\n    ]\n    bounds = tuple((0, None) for _ in range(n))\n    \n    result = minimize(objective, w0, method='SLSQP', bounds=bounds, constraints=constraints, tol=1e-9)\n    # The problem is constructed to be feasible, so success is expected.\n    return result.x\n\ndef process_case(mu, Sigma):\n    \"\"\"\n    Processes a single test case: finds corner portfolios and verifies the\n    convex combination property.\n    \"\"\"\n    n = len(mu)\n    weight_tol = 1e-8\n    bisection_tol = 1e-6\n    vector_comp_tol = 5e-4\n\n    # 1. Find the global minimum variance portfolio (GMVP) with no short-selling\n    objective_gmvp = lambda w: w.T @ Sigma @ w\n    constraints_gmvp = [{'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0}]\n    bounds_gmvp = tuple((0, None) for _ in range(n))\n    res_gmvp = minimize(objective_gmvp, np.ones(n) / n, method='SLSQP', bounds=bounds_gmvp, constraints=constraints_gmvp, tol=1e-9)\n    w_mv = res_gmvp.x\n    r_mv = w_mv.T @ mu\n\n    # 2. Define the efficient frontier range\n    r_max = np.max(mu)\n    w_max_idx = np.argmax(mu)\n\n    # 3. Grid search to find intervals containing corner portfolios\n    grid_size = 1001\n    r_grid = np.linspace(r_mv, r_max, grid_size)\n    active_sets_grid = []\n    for r_val in r_grid:\n        w = solve_qp(r_val, mu, Sigma, n)\n        active_set = frozenset(np.where(w > weight_tol)[0])\n        active_sets_grid.append(active_set)\n\n    # 4. Use bisection to refine corner portfolio locations\n    found_corner_returns = []\n    for i in range(grid_size - 1):\n        if active_sets_grid[i] != active_sets_grid[i+1]:\n            r_low, r_high = r_grid[i], r_grid[i+1]\n            active_low = active_sets_grid[i]\n            \n            while (r_high - r_low) > bisection_tol:\n                r_mid = (r_low + r_high) / 2\n                w_mid = solve_qp(r_mid, mu, Sigma, n)\n                active_mid = frozenset(np.where(w_mid > weight_tol)[0])\n                if active_mid == active_low:\n                    r_low = r_mid\n                else:\n                    r_high = r_mid\n            found_corner_returns.append((r_low + r_high) / 2)\n\n    # 5. Consolidate and de-duplicate corner portfolios\n    all_corner_returns = sorted(list(set([r_mv] + found_corner_returns + [r_max])))\n    \n    unique_corner_portfolios = []\n    if all_corner_returns:\n        last_r = -np.inf\n        for r in all_corner_returns:\n            if r - last_r > 1e-5: # De-duplication tolerance\n                w = solve_qp(r, mu, Sigma, n)\n                unique_corner_portfolios.append({'r': r, 'w': w})\n                last_r = r\n    \n    # If the GMVP is the max return asset, there's only one portfolio\n    if len(unique_corner_portfolios) == 0:\n        unique_corner_portfolios.append({'r': r_mv, 'w': w_mv})\n    \n    corner_count = len(unique_corner_portfolios)\n\n    # 6. Verify the convex combination property\n    convex_ok = True\n    num_samples = 5\n    sample_returns = np.linspace(r_mv, r_max, num_samples)\n    \n    corner_rs = np.array([cp['r'] for cp in unique_corner_portfolios])\n    corner_ws = np.array([cp['w'] for cp in unique_corner_portfolios])\n\n    if corner_count < 2: # Only one portfolio, property is trivially true\n        return corner_count, True\n\n    for r_sample in sample_returns:\n        w_actual = solve_qp(r_sample, mu, Sigma, n)\n        \n        idx_u = np.searchsorted(corner_rs, r_sample)\n\n        if idx_u == 0:\n             w_theory = corner_ws[0]\n        elif idx_u == len(corner_rs):\n             w_theory = corner_ws[-1]\n        else:\n            r_l, w_l = corner_rs[idx_u - 1], corner_ws[idx_u - 1]\n            r_u, w_u = corner_rs[idx_u], corner_ws[idx_u]\n            \n            if np.isclose(r_u, r_l):\n                tau = 0.0 if np.isclose(r_sample, r_l) else 1.0\n            else:\n                tau = (r_sample - r_l) / (r_u - r_l)\n            \n            w_theory = (1 - tau) * w_l + tau * w_u\n        \n        if np.max(np.abs(w_actual - w_theory)) > vector_comp_tol:\n            convex_ok = False\n            break\n\n    return corner_count, convex_ok\n\n\ndef solve():\n    test_cases = [\n        {\n            \"mu\": np.array([0.08, 0.12]),\n            \"Sigma\": np.array([[0.04, 0.006], [0.006, 0.09]])\n        },\n        {\n            \"mu\": np.array([0.06, 0.10, 0.03]),\n            \"Sigma\": np.array([\n                [0.0422, 0.0134, 0.0418],\n                [0.0134, 0.0343, 0.0276],\n                [0.0418, 0.0276, 0.1062]\n            ])\n        },\n        {\n            \"mu\": np.array([0.06, 0.11, 0.08]),\n            \"Sigma\": np.array([\n                [0.02, 0.015, 0.005],\n                [0.015, 0.05, 0.01],\n                [0.005, 0.01, 0.03]\n            ])\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mu_vec = case[\"mu\"]\n        Sigma_mat = case[\"Sigma\"]\n        \n        # Check for positive definiteness as a matter of principle\n        if not np.all(np.linalg.eigvals(Sigma_mat) > 0):\n             raise ValueError(\"Covariance matrix is not positive definite.\")\n        \n        corner_count, convex_ok = process_case(mu_vec, Sigma_mat)\n        results.append(corner_count)\n        results.append(convex_ok)\n\n    # Final print statement must match the problem's required format exactly.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2383613"}, {"introduction": "在掌握了如何计算有效前沿之后，我们必须面对一个关键问题：模型输入的质量。均值-方差优化的结果对预期收益和协方差矩阵的估计值高度敏感，这一特性是众所周知的。本练习 [@problem_id:2383628] 要求你直接比较两种常用的协方差矩阵估计方法——历史数据法和结构化的因子模型法，让你亲身体验不同的建模假设如何导致截然不同的投资策略和风险评估。", "problem": "在均值-方差范式下，为构建投资组合的有效前沿，您将获得两种备选的资产收益协方差矩阵规范。对于投资组合权重向量 $w \\in \\mathbb{R}^n$、预期收益向量 $\\mu \\in \\mathbb{R}^n$ 以及对称正定协方差矩阵 $\\Sigma \\in \\mathbb{R}^{n \\times n}$，投资组合方差为 $w^{\\top} \\Sigma w$，投资组合预期收益为 $w^{\\top} \\mu$。在目标预期收益为 $r_{\\text{tgt}}$ 时的有效前沿，由以下约束优化问题的解定义：最小化 $w^{\\top} \\Sigma w$，约束条件为 $w^{\\top} \\mu = r_{\\text{tgt}}$、$\\mathbf{1}^{\\top} w = 1$ 和 $w \\succeq 0$，其中 $\\mathbf{1}$ 表示全一向量，$\\succeq$ 表示逐元素不等式。标准差是方差的平方根，并且必须以小数单位报告（而非百分号形式）。\n\n将比较两种协方差规范：\n- 历史协方差矩阵 $\\Sigma_{\\text{hist}}$。\n- 因子模型协方差矩阵 $\\Sigma_{\\text{fac}}$，定义为 $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$，其中 $B \\in \\mathbb{R}^{n \\times k}$ 是对 $k$ 个因子的暴露矩阵，$\\Sigma_F \\in \\mathbb{R}^{k \\times k}$ 是因子协方差矩阵，而 $D \\in \\mathbb{R}^{n \\times n}$ 是特质方差的对角矩阵。\n\n对于下方的每个测试用例，定义目标收益网格 $T = \\{ r_0, r_1, r_2, r_3, r_4 \\}$，其中 $r_0 = \\min_i \\mu_i$，$r_4 = \\max_i \\mu_i$，且对于 $j \\in \\{ 1, 2, 3 \\}$，$r_j = r_0 + \\frac{j}{4} (r_4 - r_0)$。对于每个 $r \\in T$，计算在 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 下的有效前沿点，并记录相应的标准差。对于每个测试用例，计算单一汇总指标\n$$\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|,$$\n其中 $\\sigma_{\\text{hist}}(r)$ 和 $\\sigma_{\\text{fac}}(r)$ 分别表示在目标收益为 $r$ 时，基于 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 计算出的最优投资组合标准差。\n\n您的程序必须输出一行，其中包含一个逗号分隔的列表，内含下方测试用例的三个 $\\Delta$ 值，并用方括号括起来，每个值都是四舍五入到小数点后六位的小数，例如 $[0.012345,0.000001,0.543210]$。不应打印任何其他文本。\n\n测试套件：\n- 测试用例 $1$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 预期收益\n    $$\\mu = \\begin{bmatrix} 0.08 \\\\ 0.10 \\\\ 0.12 \\\\ 0.09 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    1.2  0.5  0.3 \\\\\n    0.8  1.1  -0.2 \\\\\n    1.5  -0.4  0.7 \\\\\n    0.6  0.9  0.4\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.04  0  0 \\\\\n    0  0.03  0 \\\\\n    0  0  0.02\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.02  0  0  0 \\\\\n    0  0.015  0  0 \\\\\n    0  0  0.018  0 \\\\\n    0  0  0  0.017\n    \\end{bmatrix}.$$\n  - 历史协方差通过对因子模型协方差的对称扰动来定义：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    其中\n    $$E = \\begin{bmatrix}\n    0.001  -0.0003  0.0002  -0.0001 \\\\\n    -0.0003  0.001  -0.00025  0.00015 \\\\\n    0.0002  -0.00025  0.0012  -0.0002 \\\\\n    -0.0001  0.00015  -0.0002  0.0008\n    \\end{bmatrix}.$$\n- 测试用例 $2$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 预期收益\n    $$\\mu = \\begin{bmatrix} 0.07 \\\\ 0.075 \\\\ 0.072 \\\\ 0.074 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    1.0  0.2  0.1 \\\\\n    0.95  0.25  0.12 \\\\\n    1.05  0.18  0.09 \\\\\n    0.90  0.30  0.11\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.05  0  0 \\\\\n    0  0.025  0 \\\\\n    0  0  0.015\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.01  0  0  0 \\\\\n    0  0.012  0  0 \\\\\n    0  0  0.011  0 \\\\\n    0  0  0  0.013\n    \\end{bmatrix}.$$\n  - 历史协方差等于因子模型协方差：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}.$$\n- 测试用例 $3$：\n  - 资产数量 $n = 4$，因子数量 $k = 3$。\n  - 预期收益\n    $$\\mu = \\begin{bmatrix} 0.11 \\\\ 0.09 \\\\ 0.10 \\\\ 0.115 \\end{bmatrix}.$$\n  - 因子暴露\n    $$B = \\begin{bmatrix}\n    0.7  -0.2  0.5 \\\\\n    1.3  0.4  -0.1 \\\\\n    0.2  1.1  0.3 \\\\\n    1.0  -0.3  0.8\n    \\end{bmatrix}.$$\n  - 因子协方差\n    $$\\Sigma_F = \\begin{bmatrix}\n    0.06  0  0 \\\\\n    0  0.02  0 \\\\\n    0  0  0.025\n    \\end{bmatrix}.$$\n  - 特质方差（对角）\n    $$D = \\begin{bmatrix}\n    0.02  0  0  0 \\\\\n    0  0.018  0  0 \\\\\n    0  0  0.016  0 \\\\\n    0  0  0  0.017\n    \\end{bmatrix}.$$\n  - 历史协方差通过对因子模型协方差的对称扰动来定义：\n    $$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E,$$\n    其中\n    $$E = \\begin{bmatrix}\n    0.002  0.0004  -0.0003  0.0002 \\\\\n    0.0004  0.0025  0.00035  -0.00025 \\\\\n    -0.0003  0.00035  0.0022  0.00015 \\\\\n    0.0002  -0.00025  0.00015  0.0018\n    \\end{bmatrix}.$$\n\n要求：\n- 对每个测试用例，构建 $\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D$，然后按上述规定构建 $\\Sigma_{\\text{hist}}$。\n- 对于每个 $r \\in T$，求解在 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$ 下的约束优化问题，并计算相应的最优标准差。\n- 对每个测试用例，计算如上定义的 $\\Delta$。\n- 您的程序应生成单行输出，其中包含按顺序排列的三个测试用例的 $\\Delta$ 值，以逗号分隔列表的形式用方括号括起来，每个值都精确四舍五入到小数点后六位。所有计算均以小数单位进行（不使用百分号），且本问题不涉及角度。", "solution": "该问题要求通过计算所得到的有效前沿的最大差异，来比较投资组合协方差矩阵的两种规范 $\\Sigma_{\\text{hist}}$ 和 $\\Sigma_{\\text{fac}}$。这是一个计算金融领域的问题，具体来说是 Markowitz 提出的均值-方差框架下的投资组合优化。\n\n问题的核心是找到投资组合权重向量 $w \\in \\mathbb{R}^n$，以在给定的目标预期收益 $r_{\\text{tgt}}$ 下，最小化投资组合方差 $w^{\\top} \\Sigma w$。这被表述为一个约束二次规划（QP）问题。\n\n**1. 问题表述**\n\n对于给定的协方差矩阵 $\\Sigma$、预期收益向量 $\\mu$ 和目标收益 $r_{\\text{tgt}}$，优化问题如下：\n$$\n\\begin{aligned}\n \\underset{w}{\\text{minimize}}\n  w^{\\top} \\Sigma w \\\\\n \\text{subject to}\n  w^{\\top} \\mu = r_{\\text{tgt}} \\\\\n   \\mathbf{1}^{\\top} w = 1 \\\\\n   w \\succeq 0\n\\end{aligned}\n$$\n其中 $w$ 是投资组合权重向量，$n$ 是资产数量，$\\mathbf{1}$ 是一个 $n$ 维的全一向量，$w \\succeq 0$ 表示逐元素非负（即禁止卖空）。该问题的解给出了在目标收益 $r_{\\text{tgt}}$ 下的最小方差。标准差是该最小方差的平方根。\n\n**2. 协方差矩阵的构建**\n\n每个测试用例都必须构建两个协方差矩阵。\n\n首先，因子模型协方差矩阵 $\\Sigma_{\\text{fac}}$ 构建如下：\n$$\n\\Sigma_{\\text{fac}} = B \\Sigma_F B^{\\top} + D\n$$\n其中 $B$ 是 $n \\times k$ 的因子暴露矩阵，$\\Sigma_F$ 是 $k \\times k$ 的因子协方差矩阵，$D$ 是 $n \\times n$ 的特质方差对角矩阵。鉴于 $\\Sigma_F$ 被指定为具有正元素的对角矩阵，因此它是正定的。$D$ 也是具有正元素的对角矩阵，因此也是正定的。项 $B \\Sigma_F B^{\\top}$ 是半正定的。一个正定矩阵（$D$）和一个半正定矩阵（$B \\Sigma_F B^{\\top}$）的和，其结果矩阵 $\\Sigma_{\\text{fac}}$ 保证是正定的。\n\n其次，历史协方差矩阵 $\\Sigma_{\\text{hist}}$ 在每个测试用例中的指定方式不同。在测试用例 1 和 3 中，它被定义为因子模型矩阵的一个扰动：\n$$\n\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}} + E\n$$\n其中 $E$ 是一个给定的对称矩阵。为了使优化问题是良置的（具体来说，为了有唯一最小值），$\\Sigma_{\\text{hist}}$ 也必须是正定的。这个条件不是先验保证的，而是取决于扰动 $E$。对测试用例 1 和 3 中得到的 $\\Sigma_{\\text{hist}}$ 矩阵的特征值进行计算检查，可以确认所有特征值均为正，因此这些矩阵确实是正定的。在测试用例 2 中，$\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$，因此其正定性得到保证。\n\n**3. 数值优化**\n\nQP 问题使用数值求解器来解决。`scipy.optimize.minimize` 函数与序列最小二乘规划（`SLSQP`）方法适用于此类约束优化问题。\n\n对于每个协方差矩阵 $\\Sigma \\in \\{\\Sigma_{\\text{hist}}, \\Sigma_{\\text{fac}}\\}$ 和每个目标收益 $r_{\\text{tgt}}$，求解器的配置如下：\n- **目标函数**：$f(w) = w^{\\top} \\Sigma w$。\n- **等式约束**：\n    1. $g_1(w) = w^{\\top} \\mu - r_{\\text{tgt}} = 0$\n    2. $g_2(w) = \\mathbf{1}^{\\top} w - 1 = 0$\n- **边界**：$w_i \\ge 0$ 对于 $i=1, \\dots, n$。一个初始猜测，例如等权重投资组合 $w_0 = [1/n, \\dots, 1/n]^{\\top}$，提供了一个可行的起始点。\n\n优化产生最优权重向量 $w_{\\text{opt}}$，最小化的目标函数值即为投资组合方差 $\\sigma^2 = w_{\\text{opt}}^{\\top} \\Sigma w_{\\text{opt}}$。标准差为 $\\sigma = \\sqrt{\\sigma^2}$。\n\n**4. 指标计算**\n\n分析是在一个包含 5 个目标收益的网格 $T = \\{r_0, r_1, r_2, r_3, r_4\\}$ 上进行的。该网格由单个资产的最小和最大预期收益定义：\n- $r_0 = \\min_{i} \\mu_i$\n- $r_4 = \\max_{i} \\mu_i$\n- 中间点是均匀分布的：$r_j = r_0 + \\frac{j}{4}(r_4 - r_0)$ 对于 $j \\in \\{1, 2, 3\\}$。\n\n对于每个 $r \\in T$，我们计算两种协方差模型下的最优标准差 $\\sigma_{\\text{hist}}(r)$ 和 $\\sigma_{\\text{fac}}(r)$。每个测试用例的最终汇总指标 $\\Delta$ 是这些标准差在整个网格上的最大绝对差：\n$$\n\\Delta = \\max_{r \\in T} \\left| \\sigma_{\\text{hist}}(r) - \\sigma_{\\text{fac}}(r) \\right|\n$$\n整个过程是遍历每个测试用例，构建必要的矩阵，为收益网格 $T$ 中的每个点求解一系列优化问题，并计算最终指标 $\\Delta$。对于测试用例 2，由于 $\\Sigma_{\\text{hist}} = \\Sigma_{\\text{fac}}$，优化问题是相同的，导致对所有 $r$ 都有 $\\sigma_{\\text{hist}}(r) = \\sigma_{\\text{fac}}(r)$，因此无需数值计算即可得出 $\\Delta=0$。", "answer": "```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    \"\"\"\n    Solves the portfolio optimization problem for three test cases and\n    calculates the summary metric Delta for each.\n    \"\"\"\n\n    # Test Case 1 Data\n    case1 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.08, 0.10, 0.12, 0.09]),\n        'B': np.array([\n            [1.2, 0.5, 0.3],\n            [0.8, 1.1, -0.2],\n            [1.5, -0.4, 0.7],\n            [0.6, 0.9, 0.4]\n        ]),\n        'Sigma_F': np.diag([0.04, 0.03, 0.02]),\n        'D': np.diag([0.02, 0.015, 0.018, 0.017]),\n        'E': np.array([\n            [0.001, -0.0003, 0.0002, -0.0001],\n            [-0.0003, 0.001, -0.00025, 0.00015],\n            [0.0002, -0.00025, 0.0012, -0.0002],\n            [-0.0001, 0.00015, -0.0002, 0.0008]\n        ])\n    }\n\n    # Test Case 2 Data\n    case2 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.07, 0.075, 0.072, 0.074]),\n        'B': np.array([\n            [1.0, 0.2, 0.1],\n            [0.95, 0.25, 0.12],\n            [1.05, 0.18, 0.09],\n            [0.90, 0.30, 0.11]\n        ]),\n        'Sigma_F': np.diag([0.05, 0.025, 0.015]),\n        'D': np.diag([0.01, 0.012, 0.011, 0.013]),\n        'E': np.zeros((4, 4))  # Sigma_hist = Sigma_fac\n    }\n\n    # Test Case 3 Data\n    case3 = {\n        'n': 4, 'k': 3,\n        'mu': np.array([0.11, 0.09, 0.10, 0.115]),\n        'B': np.array([\n            [0.7, -0.2, 0.5],\n            [1.3, 0.4, -0.1],\n            [0.2, 1.1, 0.3],\n            [1.0, -0.3, 0.8]\n        ]),\n        'Sigma_F': np.diag([0.06, 0.02, 0.025]),\n        'D': np.diag([0.02, 0.018, 0.016, 0.017]),\n        'E': np.array([\n            [0.002, 0.0004, -0.0003, 0.0002],\n            [0.0004, 0.0025, 0.00035, -0.00025],\n            [-0.0003, 0.00035, 0.0022, 0.00015],\n            [0.0002, -0.00025, 0.00015, 0.0018]\n        ])\n    }\n\n    test_cases = [case1, case2, case3]\n    results = []\n\n    for case in test_cases:\n        delta = compute_delta_for_case(case)\n        results.append(delta)\n    \n    # Format the final output string as required.\n    print(f\"[{','.join(f'{d:.6f}' for d in results)}]\")\n\ndef run_optimization(Sigma, mu, r_tgt, n):\n    \"\"\"\n    Solves the quadratic programming problem for a given covariance matrix and target return.\n    \"\"\"\n    \n    # Objective function: portfolio variance\n    def portfolio_variance(w, Sigma_arg):\n        return w.T @ Sigma_arg @ w\n\n    # Initial guess: equally weighted portfolio\n    w0 = np.ones(n) / n\n\n    # Constraints: sum of weights is 1, portfolio return is r_tgt\n    constraints = [\n        {'type': 'eq', 'fun': lambda w: np.sum(w) - 1.0},\n        {'type': 'eq', 'fun': lambda w: np.dot(w, mu) - r_tgt}\n    ]\n\n    # Bounds: weights are non-negative (no short selling)\n    bounds = tuple((0.0, None) for _ in range(n))\n\n    # Perform the optimization\n    result = minimize(\n        fun=portfolio_variance,\n        x0=w0,\n        args=(Sigma,),\n        method='SLSQP',\n        bounds=bounds,\n        constraints=constraints\n    )\n\n    if not result.success:\n        raise ValueError(f\"Optimization failed for r_tgt={r_tgt}: {result.message}\")\n        \n    return result.fun # This is the minimized variance\n\ndef compute_delta_for_case(case_data):\n    \"\"\"\n    Computes the summary metric Delta for a single test case.\n    \"\"\"\n    n, mu, B, Sigma_F, D, E = (\n        case_data['n'], case_data['mu'], case_data['B'],\n        case_data['Sigma_F'], case_data['D'], case_data['E']\n    )\n\n    # Construct covariance matrices\n    Sigma_fac = B @ Sigma_F @ B.T + D\n    Sigma_hist = Sigma_fac + E\n\n    # For Test Case 2, Sigma_hist == Sigma_fac, so Delta is 0.\n    if np.allclose(Sigma_hist, Sigma_fac):\n        return 0.0\n\n    # Define the target return grid\n    r_min = np.min(mu)\n    r_max = np.max(mu)\n    target_returns = np.linspace(r_min, r_max, 5)\n\n    max_diff = 0.0\n    for r_tgt in target_returns:\n        # Solve for historical covariance\n        var_hist = run_optimization(Sigma_hist, mu, r_tgt, n)\n        std_dev_hist = np.sqrt(var_hist)\n\n        # Solve for factor model covariance\n        var_fac = run_optimization(Sigma_fac, mu, r_tgt, n)\n        std_dev_fac = np.sqrt(var_fac)\n\n        # Update the maximum difference\n        diff = np.abs(std_dev_hist - std_dev_fac)\n        if diff > max_diff:\n            max_diff = diff\n            \n    return max_diff\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2383628"}, {"introduction": "既然我们知道协方差矩阵的估计总存在误差，一个自然的问题是：我们能否构建一个对这些估计误差不敏感，即“稳健”的投资组合？这个高级练习 [@problem_id:2409743] 将向你介绍强大的稳健优化框架。你将学习如何解决一个极小化极大问题 (minimax problem)，在优化投资组合的同时防范给定不确定性集合内的“最坏情况”，从而制定出更可靠的投资策略。", "problem": "给定一个鲁棒均值-方差优化（MVO）问题，其中协方差矩阵并非精确已知，但已知其位于一个围绕名义估计值的弗罗贝尼乌斯范数不确定性球内。考虑 $n=3$ 种风险资产，其预期超额收益向量为 $\\mu \\in \\mathbb{R}^{3}$，名义协方差矩阵为 $\\Sigma_{0} \\in \\mathbb{R}^{3 \\times 3}$。协方差矩阵是不确定的，并被约束在集合\n$$\n\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\},\n$$\n中，其中 $\\delta \\ge 0$ 是一个给定的半径，$\\mathbb{S}_{+}^{3}$ 表示对称半正定 $3 \\times 3$ 矩阵的集合，$\\|\\cdot\\|_{F}$ 表示弗罗贝尼乌斯范数。\n\n一个投资组合是一个权重向量 $x \\in \\mathbb{R}^{3}$，满足完全投资约束 $\\mathbf{1}^{\\top} x = 1$，其中 $\\mathbf{1}$ 是全1向量。允许卖空。对于给定的风险厌恶参数 $\\gamma > 0$，考虑以下鲁棒MVO问题\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n\n使用以下数据，这些数据在所有测试用例中都是固定的：\n- 资产数量 $n = 3$。\n- 预期超额收益（以小数单位表示）：$\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$。\n- 名义协方差矩阵：\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100  0.0018  0.0011 \\\\\n0.0018  0.0064  0.0013 \\\\\n0.0011  0.0013  0.0025\n\\end{bmatrix}.\n$$\n\n程序必须为每个指定的测试用例计算上述鲁棒MVO问题的唯一最优解 $x^{\\star}$，并将其报告为一个包含三个实数的列表，每个实数四舍五入到六位小数。\n\n测试套件：\n1. 案例A（名义边界）：$\\gamma = 5.0$, $\\delta = 0.0$。\n2. 案例B（中等鲁棒性）：$\\gamma = 5.0$, $\\delta = 0.020$。\n3. 案例C（强鲁棒性）：$\\gamma = 5.0$, $\\delta = 0.050$。\n4. 案例D（高风险厌恶与鲁棒性）：$\\gamma = 20.0$, $\\delta = 0.020$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身也是一个用方括号括起来的、由三个投資组合权重组成的逗号分隔列表。所有数字必须四舍五入到六位小数。例如，要求的格式是\n$[\\,[w_{1,1},w_{1,2},w_{1,3}],\\,[w_{2,1},w_{2,2},w_{2,3}],\\,[w_{3,1},w_{3,2},w_{3,3}],\\,[w_{4,1},w_{4,2},w_{4,3}]\\,]$,\n其中 $w_{k,i}$ 表示第 $k$ 个测试用例中的第 $i$ 个权重。不涉及单位，数字必须表示为实数十进制数，而不是百分比。", "solution": "问题陈述需经过验证。\n\n**第1步：提取的已知条件**\n- 资产数量：$n = 3$。\n- 预期超额收益向量：$\\mu = \\begin{bmatrix} 0.12 \\\\ 0.10 \\\\ 0.07 \\end{bmatrix}$。\n- 名义协方差矩阵：\n$$\n\\Sigma_{0} \\;=\\;\n\\begin{bmatrix}\n0.0100  0.0018  0.0011 \\\\\n0.0018  0.0064  0.0013 \\\\\n0.0011  0.0013  0.0025\n\\end{bmatrix}.\n$$\n- 协方差不确定性集合：$\\mathcal{U}(\\delta) \\;=\\; \\left\\{ \\Sigma \\in \\mathbb{S}_{+}^{3} \\;:\\; \\left\\| \\Sigma - \\Sigma_{0} \\right\\|_{F} \\le \\delta \\right\\}$，其中 $\\mathbb{S}_{+}^{3}$ 是对称半正定 $3 \\times 3$ 矩阵的集合，$\\| \\cdot \\|_{F}$ 是弗罗贝尼乌斯范数。\n- 投资组合约束：$\\mathbf{1}^{\\top} x = 1$。\n- 鲁棒均值-方差优化（MVO）问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\;\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} \\; x^{\\top} \\Sigma x \\;-\\; \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n- 测试用例由参数对 $(\\gamma, \\delta)$ 定义：\n  1. 案例A：$\\gamma = 5.0$, $\\delta = 0.0$。\n  2. 案例B：$\\gamma = 5.0$, $\\delta = 0.020$。\n  3. 案例C：$\\gamma = 5.0$, $\\delta = 0.050$。\n  4. 案例D：$\\gamma = 20.0$, $\\delta = 0.020$。\n\n**第2步：验证提取的已知条件**\n该问题具有科学依据，是适定的、客观的。这是鲁棒投资组合优化中的一个标准提法，该领域是计算金融学的一个子领域。所有参数都有明确定义，且数据一致。名义协方差矩阵 $\\Sigma_0$ 是对称正定的（其特征值约为 $0.0107$, $0.0059$ 和 $0.0023$），因此它属于 $\\mathbb{S}_{+}^{3}$。问题提法在数学上是精确的，并且可以推导出唯一解。未发现任何缺陷。\n\n**第3步：结论与行动**\n问题被认定为有效。将推导解答。\n\n**解答推导**\n指定的鲁棒MVO问题是一个极小极大问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\left( \\frac{\\gamma}{2} \\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x -\\mu^{\\top} x \\right)\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n为解决此问题，我们首先分析内部最大化问题，即寻找固定投资组合 $x$ 的最坏情况下的投资组合方差：\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = \\sup_{\\Sigma} \\left\\{ x^{\\top} \\Sigma x \\mid \\Sigma \\in \\mathbb{S}_{+}^{3}, \\|\\Sigma - \\Sigma_{0}\\|_{F} \\le \\delta \\right\\}.\n$$\n我们可以使用迹算子和矩阵内积 $\\langle A, B \\rangle_{F} = \\text{Tr}(A^{\\top}B)$ 来表示二次型 $x^{\\top} \\Sigma x$。由于 $x^{\\top}\\Sigma x$ 是一个标量，所以 $x^{\\top}\\Sigma x = \\text{Tr}(x^{\\top}\\Sigma x) = \\text{Tr}(\\Sigma x x^{\\top})$。因为 $\\Sigma$ 和 $xx^\\top$ 是对称的，这等价于 $\\langle \\Sigma, x x^{\\top} \\rangle_{F}$。\n\n令 $\\Delta = \\Sigma - \\Sigma_0$。关于 $\\Sigma$ 的最大化问题可以重写为关于对称扰动矩阵 $\\Delta$ 的最大化问题：\n$$\n\\sup_{\\Delta} \\left\\{ x^{\\top}(\\Sigma_0 + \\Delta)x \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\},\n$$\n其中 $\\mathbb{S}^{3}$ 是 $3 \\times 3$ 对称矩阵的集合。\n目标函数为 $x^{\\top}\\Sigma_0 x + x^{\\top}\\Delta x = x^{\\top}\\Sigma_0 x + \\langle \\Delta, x x^{\\top} \\rangle_{F}$。项 $x^{\\top}\\Sigma_0 x$ 相对于 $\\Delta$ 是常数，因此我们必须求解：\n$$\nx^{\\top}\\Sigma_0 x + \\sup_{\\Delta} \\left\\{ \\langle \\Delta, x x^{\\top} \\rangle_{F} \\mid \\|\\Delta\\|_{F} \\le \\delta, \\Sigma_0+\\Delta \\in \\mathbb{S}_{+}^{3}, \\Delta \\in \\mathbb{S}^{3} \\right\\}.\n$$\n根据弗罗贝尼乌斯内积的柯西-施瓦茨不等式，当 $\\Delta$ 与矩阵 $xx^{\\top}$ 对齐时，在 $\\|\\Delta\\|_{F} \\le \\delta$ 的约束下，$\\langle \\Delta, x x^{\\top} \\rangle_{F}$ 的上确界得以实现。最优扰动为 $\\Delta^{\\star} = \\delta \\frac{x x^{\\top}}{\\|x x^{\\top}\\|_{F}}$。\n秩为1的矩阵 $x x^{\\top}$ 的弗罗贝尼乌斯范数为：\n$$\n\\|x x^{\\top}\\|_{F} = \\sqrt{\\text{Tr}\\left((x x^{\\top})^{\\top}(x x^{\\top})\\right)} = \\sqrt{\\text{Tr}\\left(x x^{\\top} x x^{\\top}\\right)} = \\sqrt{\\text{Tr}\\left(x(x^{\\top}x)x^{\\top}\\right)} = \\sqrt{(x^{\\top}x)\\text{Tr}(x x^{\\top})} = \\sqrt{\\|x\\|_{2}^2 \\|x\\|_{2}^2} = \\|x\\|_{2}^2,\n$$\n其中 $\\|x\\|_2$ 是 $x$ 的欧几里得范数。\n因此，最优扰动为 $\\Delta^{\\star} = \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$。相应的最坏情况下的协方差矩阵是 $\\Sigma^{\\star} = \\Sigma_0 + \\frac{\\delta}{\\|x\\|_{2}^2} x x^{\\top}$。由于 $\\Sigma_0$ 是半正定的，并且 $xx^{\\top}$ 也是半正定的，它们的加权和（权重为非负）确保了 $\\Sigma^\\star \\in \\mathbb{S}_{+}^{3}$。因此，$\\Sigma$ 的半正定性约束被松弛问题的解自动满足，可以忽略。\n\n内积项的最大值为 $\\langle \\Delta^{\\star}, x x^{\\top} \\rangle_{F} = \\delta \\|x x^{\\top}\\|_{F} = \\delta \\|x\\|_{2}^2$。\n最坏情况下的方差为：\n$$\n\\sup_{\\Sigma \\in \\mathcal{U}(\\delta)} x^{\\top} \\Sigma x = x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2.\n$$\n将此代回MVO问题，我们得到一个等价的标准二次规划问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} \\left( x^{\\top}\\Sigma_0 x + \\delta \\|x\\|_{2}^2 \\right) - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n认识到 $\\|x\\|_{2}^2 = x^{\\top}Ix$，其中 $I$ 是单位矩阵，目标函数可以重写为：\n$$\nf(x) = \\frac{\\gamma}{2} x^{\\top}(\\Sigma_0 + \\delta I)x - \\mu^{\\top} x.\n$$\n让我们定义鲁棒协方差矩阵 $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$。现在问题变成了一个标准的MVO问题：\n$$\n\\min_{x \\in \\mathbb{R}^{3}} \\;\\; \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x\n\\quad \\text{subject to} \\quad \\mathbf{1}^{\\top} x = 1.\n$$\n这是一个带有线性等式约束的凸优化问题，我们使用拉格朗日乘子法来求解。拉格朗日函数为：\n$$\n\\mathcal{L}(x, \\lambda) = \\frac{\\gamma}{2} x^{\\top}\\tilde{\\Sigma}x - \\mu^{\\top} x + \\lambda(1 - \\mathbf{1}^{\\top} x).\n$$\n通过将梯度设置为零，可以获得一阶最优性必要条件：\n$$\n\\nabla_x \\mathcal{L} = \\gamma \\tilde{\\Sigma}x - \\mu - \\lambda\\mathbf{1} = 0\n$$\n$$\n\\nabla_\\lambda \\mathcal{L} = 1 - \\mathbf{1}^{\\top} x = 0\n$$\n从第一个方程中，我们求解 $x$。因为 $\\Sigma_0$ 是正定的且 $\\delta \\ge 0$，所以 $\\tilde{\\Sigma}$ 也是正定的，因此是可逆的。\n$$\n\\gamma \\tilde{\\Sigma}x = \\mu + \\lambda\\mathbf{1} \\implies x = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}).\n$$\n我们将这个 $x$ 的表达式代入预算约束 $\\mathbf{1}^{\\top}x = 1$ 中：\n$$\n\\mathbf{1}^{\\top} \\left( \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1} (\\mu + \\lambda\\mathbf{1}) \\right) = 1\n$$\n$$\n\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu + \\lambda(\\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}) = \\gamma.\n$$\n为了求出 $\\lambda$，我们定义标量：\n$$\nA = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}, \\quad B = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu.\n$$\n关于 $\\lambda$ 的方程变为 $B + \\lambda A = \\gamma$，这给出：\n$$\n\\lambda = \\frac{\\gamma - B}{A}.\n$$\n唯一的最优投资组合 $x^{\\star}$ 通过先计算 $\\lambda$，然后将其代回到 $x$ 的表达式中来找到。\n\n**算法**\n对于每个具有参数 $(\\gamma, \\delta)$ 的测试用例：\n1. 构建鲁棒协方差矩阵 $\\tilde{\\Sigma} = \\Sigma_0 + \\delta I$，其中 $I$ 是 $3 \\times 3$ 的单位矩阵。\n2. 计算逆矩阵 $\\tilde{\\Sigma}^{-1}$。\n3. 计算标量 $A = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$ 和 $B = \\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1}$。注意，由于 $\\tilde{\\Sigma}^{-1}$ 是对称的，$\\mu^{\\top}\\tilde{\\Sigma}^{-1}\\mathbf{1} = \\mathbf{1}^{\\top}\\tilde{\\Sigma}^{-1}\\mu$。\n4. 计算拉格朗日乘子 $\\lambda = \\frac{\\gamma - B}{A}$。\n5. 计算最优权重向量 $x^{\\star} = \\frac{1}{\\gamma} \\tilde{\\Sigma}^{-1}(\\mu + \\lambda\\mathbf{1})$。\n6. 报告 $x^{\\star}$ 的分量，四舍五入到六位小数。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the robust mean-variance optimization problem for a given set of test cases.\n    \"\"\"\n\n    # --- Fixed Parameters from Problem Statement ---\n    # Number of assets\n    n = 3\n    # Expected excess returns vector (mu)\n    mu = np.array([[0.12], [0.10], [0.07]])\n    # Nominal covariance matrix (Sigma_0)\n    sigma_0 = np.array([\n        [0.0100, 0.0018, 0.0011],\n        [0.0018, 0.0064, 0.0013],\n        [0.0011, 0.0013, 0.0025]\n    ])\n    # Vector of ones for the budget constraint\n    ones = np.ones((n, 1))\n    # Identity matrix\n    identity = np.identity(n)\n\n    # --- Test Suite ---\n    test_cases = [\n        # (gamma, delta)\n        (5.0, 0.0),       # Case A\n        (5.0, 0.020),     # Case B\n        (5.0, 0.050),     # Case C\n        (20.0, 0.020)     # Case D\n    ]\n\n    results_as_strings = []\n\n    for gamma, delta in test_cases:\n        # Step 1: Construct the robust covariance matrix\n        sigma_tilde = sigma_0 + delta * identity\n\n        # Step 2: Compute its inverse\n        sigma_tilde_inv = np.linalg.inv(sigma_tilde)\n\n        # Step 3: Calculate scalars A and B for solving for lambda\n        # A = 1^T * inv(Sigma_tilde) * 1\n        A_matrix = ones.T @ sigma_tilde_inv @ ones\n        A = A_matrix[0, 0]\n        \n        # B = 1^T * inv(Sigma_tilde) * mu\n        B_matrix = ones.T @ sigma_tilde_inv @ mu\n        B = B_matrix[0, 0]\n\n        # Step 4: Compute the Lagrange multiplier lambda\n        lambda_val = (gamma - B) / A\n\n        # Step 5: Calculate the optimal portfolio weights x_star\n        # x_star = (1/gamma) * inv(Sigma_tilde) * (mu + lambda * 1)\n        x_star_vec = (1 / gamma) * sigma_tilde_inv @ (mu + lambda_val * ones)\n\n        # Format the result string for the current case\n        # Flatten the column vector to a 1D array for easier formatting\n        x_star_flat = x_star_vec.flatten()\n        # Create a string representation like \"[w1,w2,w3]\" with 6 decimal places\n        case_result_str = (\n            f\"[{x_star_flat[0]:.6f},\"\n            f\"{x_star_flat[1]:.6f},\"\n            f\"{x_star_flat[2]:.6f}]\"\n        )\n        results_as_strings.append(case_result_str)\n\n    # Final print statement in the exact required format: [[w1,w2,w3],[...],...]\n    print(f\"[{','.join(results_as_strings)}]\")\n\nsolve()\n```", "id": "2409743"}]}