{"hands_on_practices": [{"introduction": "任何对冲策略的基石都是对冲比率（即“希腊字母”）的精确计算。这个练习将探讨使用金融领域常见的有限差分法来计算$\\Delta$时遇到的实际挑战，特别是在期权参数达到极端值（如临近到期日）的情况下。通过这个实践，你将理解不同数值方法之间的权衡，并掌握评估其稳定性的方法。[@problem_id:2387641]", "problem": "要求您编写一个完整、可运行的程序，用于比较三种有限差分方法（前向、后向和中心差分）在到期时间趋近于零时，近似计算欧式看涨期权即期敏感度（delta）的数值稳定性。请在无套利的 Black–Scholes–Merton 框架内进行操作。\n\n假设以下基本前提：\n- 在风险中性测度下，标的资产价格过程 $\\{S_t\\}_{t \\ge 0}$ 服从随机微分方程 $dS_t = r S_t \\, dt + \\sigma S_t \\, dW_t$，其中 $r$ 是连续复利无风险利率，$\\sigma$ 是波动率，而 $W_t$ 是标准维纳过程。\n- 执行价格为 $K$、到期日为 $T$ 的欧式看涨期权在时间 $0$ 的无套利价格是一个函数 $C(S;K,r,\\sigma,T)$，由经过充分检验的 Black–Scholes–Merton 公式给出。\n- 该看涨期权在时间 $0$ 的 delta 定义为偏导数 $\\Delta(S) = \\frac{\\partial C}{\\partial S}(S;K,r,\\sigma,T)$。\n\n您的任务是：\n- 在下述所有有限差分公式中，使用 Black–Scholes–Merton 价格 $C(S;K,r,\\sigma,T)$ 作为定价函数。除该公式外，不要对 $C$ 使用任何其他近似。\n- 使用 Black–Scholes–Merton 价格关于 $S$ 的精确导数作为误差评估的参考 delta $\\Delta_{\\text{ref}}(S)$。该导数的显式形式必须由您实现，但在此不提供。\n\n对于给定的步长 $h > 0$，定义即期价格为 $S$ 时 delta 的三种有限差分估计量：\n- 前向差分：$\\Delta_{\\text{fwd}}(h) = \\dfrac{C(S+h;K,r,\\sigma,T) - C(S;K,r,\\sigma,T)}{h}$。\n- 后向差分：$\\Delta_{\\text{bwd}}(h) = \\dfrac{C(S;K,r,\\sigma,T) - C(S-h;K,r,\\sigma,T)}{h}$。\n- 中心差分：$\\Delta_{\\text{ctr}}(h) = \\dfrac{C(S+h;K,r,\\sigma,T) - C(S-h;K,r,\\sigma,T)}{2h}$。\n\n将方法 $m \\in \\{\\text{fwd}, \\text{bwd}, \\text{ctr}\\}$ 在步长网格 $\\mathcal{H}$ 上的数值稳定性度量定义为网格上的最坏情况绝对误差，\n$$\nE_m = \\max_{h \\in \\mathcal{H}} \\left| \\Delta_m(h) - \\Delta_{\\text{ref}}(S) \\right|.\n$$\n\n请实现您的程序，对以下每个旨在探究当 $T \\to 0$ 时行为的测试用例，评估 $E_{\\text{fwd}}$、$E_{\\text{bwd}}$ 和 $E_{\\text{ctr}}$：\n- 测试用例 A（临近到期的平价期权）：$(S, K, r, \\sigma, T) = (100, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n- 测试用例 B（临近到期的轻度实值期权）：$(S, K, r, \\sigma, T) = (101, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n- 测试用例 C（临近到期的轻度虚值期权）：$(S, K, r, \\sigma, T) = (99, 100, 0.01, 0.2, 1 \\times 10^{-6})$。\n\n对每个测试用例，使用以下步长网格（表示为 $S$ 的分数）：\n$$\n\\mathcal{H} = \\{ h = S \\times 10^{-k} : k \\in \\{2,3,4,5,6,7,8\\} \\}.\n$$\n对于任何满足 $S-h \\le 0$ 的 $h$，在评估后向和中心差分时排除该 $h$，以避免无效的即期价格水平。\n\n您的程序必须：\n- 为每个测试用例和每种方法计算如上定义的稳定性度量 $E_m$。\n- 生成单行输出，其中包含一个长度为 3 的列表（按 A、B、C 的顺序，每个测试用例对应一个条目）。每个条目必须是包含三个浮点数的列表，顺序为该测试用例的 $[E_{\\text{fwd}}, E_{\\text{bwd}}, E_{\\text{ctr}}]$。\n- 输出必须是严格的一行，格式为方括号内包含的逗号分隔列表，不得有多余文本。例如： “[[x11,x12,x13],[x21,x22,x23],[x31,x32,x33]]”。\n\n所有量均为无量纲，因此不涉及物理单位。不涉及角度。不要使用百分号表示任何量；如果需要分数，请用小数表示。\n\n程序必须是自包含的，不需要用户输入，并且必须能直接运行。每个测试用例的最终答案是上文描述的浮点数列表。程序必须根据此处所述的基本假设一致地实现 Black–Scholes–Merton 价格及其精确 delta。数值方法必须按照此处指定的方式实现，不得引入任何额外的平滑或正则化处理。测试套件是上述指定的三个用例，您必须将结果汇总成上文描述的单行输出格式。", "solution": "所提出的问题是有效的。这是一个适定且具有科学依据的计算金融练习，旨在研究有限差分方法在特定挑战性条件下的数值稳定性。该问题是自包含的，其参数和目标的定义足够严谨，可以计算出唯一解。\n\n任务是评估三种有限差分方案（前向、后向和中心差分）在近似欧式看涨期权 delta 时的数值稳定性。稳定性测试在到期时间 $T$ 非常小的区间内进行，这种情况在数值计算上是众所周知的挑战。\n\n理论框架是 Black–Scholes–Merton (BSM) 模型。一个无股息支付的标的资产上，即期价格为 $S$、执行价格为 $K$、到期时间为 $T$、无风险利率为 $r$、波动率为 $\\sigma$ 的欧式看涨期权价格 $C$ 由以下公式给出：\n$$\nC(S, K, T, r, \\sigma) = S \\Phi(d_1) - K e^{-rT} \\Phi(d_2)\n$$\n其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，而项 $d_1$ 和 $d_2$ 定义为：\n$$\nd_1 = \\frac{\\ln(S/K) + (r + \\frac{1}{2}\\sigma^2)T}{\\sigma\\sqrt{T}}\n$$\n$$\nd_2 = d_1 - \\sigma\\sqrt{T}\n$$\n期权的 delta, $\\Delta$, 是期权价格对标的资产即期价格的一阶偏导数，$\\Delta = \\frac{\\partial C}{\\partial S}$。对于 BSM 模型，它有一个简单的解析形式，我们将用作参考值 $\\Delta_{\\text{ref}}$：\n$$\n\\Delta_{\\text{ref}}(S) = \\Phi(d_1)\n$$\n我们的任务是将此解析 delta 与使用步长 $h > 0$ 构建的三种有限差分近似进行比较：\n1.  **前向差分**：$\\Delta_{\\text{fwd}}(h) = \\dfrac{C(S+h; \\dots) - C(S; \\dots)}{h}$\n2.  **后向差分**：$\\Delta_{\\text{bwd}}(h) = \\dfrac{C(S; \\dots) - C(S-h; \\dots)}{h}$\n3.  **中心差分**：$\\Delta_{\\text{ctr}}(h) = \\dfrac{C(S+h; \\dots) - C(S-h; \\dots)}{2h}$\n\n这些方法的数值误差主要有两个来源。首先是**截断误差**，它源于为证明近似合理性而截断泰勒级数展开。对于前向和后向方案，此误差的阶数为 $O(h)$，而对于中心方案，其阶数为 $O(h^2)$。此误差随着 $h$ 的减小而减小。其次是**舍入误差**，它源于浮点运算的有限精度。当 $h$ 很小时，有限差分公式的分子涉及两个几乎相等的值相减，导致有效数字的损失。此误差与 $\\epsilon_{\\text{mach}}/h$ 成正比，其中 $\\epsilon_{\\text{mach}}$ 是机器 epsilon，它随着 $h$ 的减小而增大。总误差是这两个分量的总和，通常表现为关于 $h$ 的 U 形曲线。问题定义了一个稳定性度量 $E_m = \\max_{h \\in \\mathcal{H}} |\\Delta_m(h) - \\Delta_{\\text{ref}}|$，以捕捉在指定的步长网格 $\\mathcal{H}$ 上的最坏情况误差。\n\n该问题关注到期时间 $T$ 趋近于零 ($T \\to 0$) 的情况。在此极限下，$\\Delta_{\\text{ref}} = \\Phi(d_1)$ 的行为变得极端。项 $d_1$ 会发散：\n$$\n\\lim_{T \\to 0^+} d_1 = \\begin{cases} +\\infty  \\text{若 } S > K \\\\ -\\infty  \\text{若 } S  K \\\\ 0  \\text{若 } S = K \\end{cases}\n$$\n因此，delta 趋近于一个阶跃函数：\n$$\n\\lim_{T \\to 0^+} \\Delta_{\\text{ref}} = \\begin{cases} 1  \\text{若 } S > K \\text{ (实值)} \\\\ 0  \\text{若 } S  K \\text{ (虚值)} \\\\ 0.5  \\text{若 } S = K \\text{ (平价)} \\end{cases}\n$$\n这种急剧的转变使得数值微分尤为困难。决定曲率的期权 gamma, $\\Gamma = \\frac{\\partial^2 C}{\\partial S^2}$, 在 $S=K$ 附近变得高度集中，当 $T \\to 0$ 时表现得像一个狄拉克 delta 函数。高曲率使得有限差分方法所依赖的低阶多项式假设失效，导致巨大的截断误差。这正是问题要求我们研究的现象。\n\n解决该问题的算法如下：\n1.  实现两个函数：一个用于 BSM 看涨期权价格 $C(\\cdot)$，另一个用于解析 BSM 看涨期权 delta $\\Delta_{\\text{ref}}(\\cdot)$。这两个函数将依赖于科学计算库中提供的标准正态 CDF。\n2.  对于由参数 $(S, K, r, \\sigma, T)$ 指定的每个测试用例：\n    a.  确定步长网格 $\\mathcal{H} = \\{ S \\times 10^{-k} : k \\in \\{2, 3, 4, 5, 6, 7, 8\\} \\}$。\n    b.  为该组给定的参数计算唯一的、恒定的参考 delta $\\Delta_{\\text{ref}}$。\n    c.  初始化三个列表，用于存储每种方法的绝对误差。\n    d.  遍历网格 $\\mathcal{H}$ 中的每个步长 $h$。\n        i.  根据各自的公式计算 $\\Delta_{\\text{fwd}}(h)$、$\\Delta_{\\text{bwd}}(h)$ 和 $\\Delta_{\\text{ctr}}(h)$，根据需要调用 BSM 价格函数。必须为后向和中心方法检查条件 $S-h > 0$，尽管对于给定的问题参数，该条件将始终满足。\n        ii.  计算绝对误差 $|\\Delta_{\\text{fwd}}(h) - \\Delta_{\\text{ref}}|$、$|\\Delta_{\\text{bwd}}(h) - \\Delta_{\\text{ref}}|$ 和 $|\\Delta_{\\text{ctr}}(h) - \\Delta_{\\text{ref}}|$，并将它们附加到各自的列表中。\n    e.  遍历所有 $h$ 后，找出每个误差列表中的最大值。这些就是稳定性度量 $E_{\\text{fwd}}$、$E_{\\text{bwd}}$ 和 $E_{\\text{ctr}}$。\n    f.  存储当前测试用例的三元组 $[E_{\\text{fwd}}, E_{\\text{bwd}}, E_{\\text{ctr}}]$。\n3.  处理完所有测试用例后，将结果汇总成一个列表的列表。\n4.  将此最终数据结构格式化为问题陈述中指定的单行字符串并打印。任务至此完成。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n#\n# MIT License\n#\n# Copyright (c) 2024 The CodiumAI Team\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n#\n\ndef bsm_call_price(S, K, T, r, sigma):\n    \"\"\"\n    Computes the Black-Scholes-Merton price for a European call option.\n    \"\"\"\n    if T = 1e-12 or sigma = 1e-12: # Avoid division by zero for small T or sigma\n        if T = 1e-12:\n            return np.maximum(0.0, S - K)\n        # Case for zero volatility\n        return np.maximum(0.0, S - K * np.exp(-r * T))\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    d2 = d1 - sigma * np.sqrt(T)\n    \n    price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n    return price\n\ndef bsm_call_delta(S, K, T, r, sigma):\n    \"\"\"\n    Computes the analytical Black-Scholes-Merton delta for a European call option.\n    \"\"\"\n    if T = 1e-12: # For T -> 0 limit\n        if S > K:\n            return 1.0\n        elif S  K:\n            return 0.0\n        else: # S == K\n            return 0.5\n            \n    if sigma = 1e-12: # For sigma -> 0 limit\n        if S > K * np.exp(-r * T):\n            return 1.0\n        else:\n            return 0.0\n\n    d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n    delta = norm.cdf(d1)\n    return delta\n\ndef solve():\n    \"\"\"\n    Main function to execute the stability analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # Test case A (at-the-money near expiry)\n        (100.0, 100.0, 0.01, 0.2, 1e-6),\n        # Test case B (slightly in-the-money near expiry)\n        (101.0, 100.0, 0.01, 0.2, 1e-6),\n        # Test case C (slightly out-of-the-money near expiry)\n        (99.0, 100.0, 0.01, 0.2, 1e-6),\n    ]\n\n    all_results = []\n    \n    for S, K, r, sigma, T in test_cases:\n        \n        # Define the step-size grid as fractions of S\n        h_grid = [S * 10**(-k) for k in range(2, 9)]\n        \n        # Calculate the single reference delta for this case\n        delta_ref = bsm_call_delta(S, K, T, r, sigma)\n        \n        errors_fwd = []\n        errors_bwd = []\n        errors_ctr = []\n        \n        price_S = bsm_call_price(S, K, T, r, sigma)\n        \n        for h in h_grid:\n            # Forward difference\n            price_plus_h = bsm_call_price(S + h, K, T, r, sigma)\n            delta_fwd = (price_plus_h - price_S) / h\n            errors_fwd.append(np.abs(delta_fwd - delta_ref))\n            \n            # Check if S - h is valid before calculating backward/central differences\n            if S - h > 0:\n                price_minus_h = bsm_call_price(S - h, K, T, r, sigma)\n                \n                # Backward difference\n                delta_bwd = (price_S - price_minus_h) / h\n                errors_bwd.append(np.abs(delta_bwd - delta_ref))\n                \n                # Central difference\n                delta_ctr = (price_plus_h - price_minus_h) / (2.0 * h)\n                errors_ctr.append(np.abs(delta_ctr - delta_ref))\n        \n        # Determine the stability metric E_m = max(abs(error)) for each method\n        E_fwd = np.max(errors_fwd) if errors_fwd else 0.0\n        E_bwd = np.max(errors_bwd) if errors_bwd else 0.0\n        E_ctr = np.max(errors_ctr) if errors_ctr else 0.0\n        \n        all_results.append([E_fwd, E_bwd, E_ctr])\n    \n    # Format the output string exactly as specified: [[r1,r2,r3],[...],...]\n    # Using str().replace() is a robust way to remove spaces from the default list representation.\n    output_str = str(all_results).replace(' ', '')\n    print(output_str)\n\nsolve()\n```", "id": "2387641"}, {"introduction": "在掌握了$\\Delta$的计算之后，下一步便是将其应用于实际的对冲操作中。本练习要求你从第一性原理出发，构建一个完整的离散时间$\\Delta$对冲模拟。通过比较标准二叉树模型与一个能更好地捕捉股价无变动状态的三叉树模型，你将深入体会模型风险以及不同模型假设对最终对冲效果的影响。[@problem_id:2387642]", "problem": "要求您编写一个完整的、可运行的程序，用于比较通过二叉树模型计算的 delta 对冲与通过一个明确包含零回报状态以捕捉股价无变动情况的三叉树模型计算的 delta 对冲的样本外对冲表现。您的实现必须基于离散时间、无套利定价和自融资复制的基本原理，并且不得依赖任何封闭解。您将使用蒙特卡洛（MC）模拟，在包含无变动状态的数据生成过程下评估对冲表现，并使用固定种子以保证可复现性。\n\n您必须使用的基本基础如下：\n- 无套利与风险中性定价：在风险中性测度下，贴现后的资产价格是一个鞅。在一个长度为 $\\Delta t$ 的时间步内，无风险总收益因子为 $e^{r \\Delta t}$，其中 $r$ 是连续复利无风险利率（以每单位时间的小数表示）。\n- 带重组的离散时间格模型：\n  - 二叉树模型：在每一步，股票的总回报要么是 $u$，要么是 $d$，其中 $u = e^{\\sigma \\sqrt{\\Delta t}}$ 且 $d = 1/u$，$σ$ 是波动率（以每平方根时间的小数表示）。设向上移动的风险中性概率为 $q$，其确定方式应确保贴现后的股票在一步内是鞅。\n  - 带无变动状态的三叉树模型：在每一步，股票的总回报为 $u$、$1$ 或 $d$，其中 $u = e^{\\sigma \\sqrt{\\Delta t}}$ 且 $d = 1/u$。设无变动概率为 $p_m \\in [0,1)$，并确定风险中性的向上和向下概率 $p_u$ 和 $p_d$，使得 $p_u + p_m + p_d = 1$ 且贴现后的股票在一步内是鞅。\n- 自融资 delta 对冲与复制：对于一个执行价格为 $K$、到期日为 $T$ 的欧式看涨期权，在每个再平衡时刻，投资组合持有 $\\Delta_t$ 份股票，其余资金投资于无风险资产，以使投资组合价值等于模型价格。在再平衡时刻之间，持有的股票数量保持不变，现金头寸以无风险利率增长。终端对冲误差是终端投资组合价值与期权收益之间的差额。\n\n您的程序必须基于这些原理实现以下内容，不使用任何封闭形式的期权定价公式：\n1. 格的构建与定价：\n   - 时间被离散化为 $N$ 步，$\\Delta t = T/N$。\n   - 对于二叉树模型，使用股票总回报 $S_{t+\\Delta t}/S_t \\in \\{u,d\\}$ 的单步风险中性鞅条件确定 $q$，并通过在重组树上进行反向归纳来计算欧式看涨期权价格。\n   - 对于三叉树模型，使用指定的无变动概率 $p_m$，并使用 $S_{t+\\Delta t}/S_t \\in \\{u,1,d\\}$ 的单步风险中性鞅条件和 $p_u + p_m + p_d = 1$ 来确定 $p_u$ 和 $p_d$。通过在重组树上进行反向归纳来计算欧式看涨期权价格。\n2. 在格上计算 Delta：\n   - 在每个时间步和可达状态 $j$，将股价定义为 $S_t = S_0 \\, u^j$，其中 $j \\in \\{-t,-t+1,\\dots,t-1,t\\}$，并认识到由于 $d = 1/u$ 和无变动状态的总回报为 $1$ 而产生的重组。\n   - 使用模型的下一步期权价值和相邻的股价，将局部 delta $\\Delta_t$ 计算为关于股票的中心有限差分斜率，即使用向上和向下移动的下一步节点来构建对称的有限差分商。不使用任何封闭形式或连续时间公式。\n3. 自融资 Delta 对冲：\n   - 对于给定的模拟路径，在每个股价为 $S_t$、模型期权价值为 $V_t$ 的时间步 $t$，将现金持有量设为 $B_t = V_t - \\Delta_t S_t$。在持有 $\\Delta_t$ 份股票的同时，演化到 $t+\\Delta t$，此时股价为 $S_{t+\\Delta t}$，现金头寸变为 $B_{t+\\Delta t}^- = B_t e^{r \\Delta t}$。然后，再平衡至 $\\Delta_{t+\\Delta t}$，并设置 $B_{t+\\Delta t} = \\Delta_t S_{t+\\Delta t} + B_{t+\\Delta t}^- - \\Delta_{t+\\Delta t} S_{t+\\Delta t}$。重复此过程直至到期。\n   - 终端对冲误差为 $\\Pi_T - \\max(S_T - K, 0)$，其中 $\\Pi_T = \\Delta_T S_T + B_T$ 是最后一次再平衡后的终端投资组合价值。\n4. 用于模拟的数据生成过程（物理测度）：\n   - 使用一个无变动概率为 $p_m^{\\text{true}}$ 且 $u$ 和 $d$ 与上述相同的三叉树过程。通过强制实施 $p_u^{\\text{true}} + p_m^{\\text{true}} + p_d^{\\text{true}} = 1$ 和单步平均增长条件 $\\mathbb{E}[S_{t+\\Delta t}/S_t] = e^{\\mu \\Delta t}$ 来确定物理概率 $p_u^{\\text{true}}$ 和 $p_d^{\\text{true}}$，其中 $\\mu$ 是连续复利的真实世界漂移率（以每单位时间的小数表示）。使用这些概率模拟独立的路径。\n5. 表现指标：\n   - 对于每个模型（二叉树对冲和三叉树对冲），估算所有模拟路径的平均绝对对冲误差。报告“二叉树模型的平均绝对误差减去三叉树模型的平均绝对误差”这一差值，以量化明确为无变动状态建模的优势。\n\n测试套件和输入规范（固定在您的程序内部，无外部输入）：\n- 使用以下通用惯例（所有利率以年化小数表示，时间以年为单位，股票和执行价格使用相同的货币单位）：\n  - 蒙特卡洛路径数量：$M = 20000$。\n  - 蒙特卡洛随机种子：$12345$。\n  - 欧式看涨期权收益 $\\max(S_T - K, 0)$。\n  - 在每个时间步进行对冲再平衡。\n  - 在所有模型和模拟中均使用 $u = e^{\\sigma \\sqrt{\\Delta t}}$ 和 $d = 1/u$。\n- 实现以下测试案例。对于每个案例，在构建三叉树对冲时，将三叉树模型的无变动概率设置为等于数据生成的无变动概率 $p_m^{\\text{true}}$。所有指定的数字均为小数。\n  - 案例 A（典型情况）：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 50$, $p_m^{\\text{true}} = 0.2$。\n  - 案例 B（高无变动率，低波动率）：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.03$, $\\sigma = 0.1$, $T = 1.0$, $N = 100$, $p_m^{\\text{true}} = 0.6$。\n  - 案例 C（无无变动基准）：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.05$, $\\sigma = 0.2$, $T = 1.0$, $N = 50$, $p_m^{\\text{true}} = 0.0$。\n  - 案例 D（短期限，高波动率，中等无变动率）：$S_0 = 100$, $K = 100$, $r = 0.01$, $\\mu = 0.00$, $\\sigma = 0.3$, $T = 0.25$, $N = 50$, $p_m^{\\text{true}} = 0.3$。\n\n输出规范：\n- 对于每个测试案例，计算二叉树对冲和三叉树对冲下的平均绝对对冲误差。输出一个等于“二叉树模型的平均绝对误差减去三叉树模型的平均绝对误差”的浮点数。正值表示三叉树对冲产生了更小的平均绝对误差。\n- 单位：以与 $S_0$ 和 $K$ 相同的货币单位报告对冲误差，格式为小数浮点数（无货币符号）。\n- 四舍五入：将每个报告的浮点数四舍五入到 $6$ 位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个逗号分隔的四个浮点数列表，用方括号括起，按案例 A, B, C, D 的顺序排列。例如：“[x_A,x_B,x_C,x_D]”，其中每个 $x_\\cdot$ 都四舍五入到 $6$ 位小数。\n\n科学真实性与约束：\n- 对每个模型，在风险中性测度下强制执行单步鞅条件；对模拟，在物理测度下强制执行单步平均增长条件。\n- 仅使用上述定义的格、反向归纳法、中心有限差分 delta 和自融资对冲更新。不使用任何封闭解。\n- 确保对于给定的参数，概率保持在 $[0,1]$ 区间内。在适当的地方使用向量化计算，以确保数值稳定性和性能。\n\n您的程序必须是完全自包含的，并严格按照指定格式生成单行输出。不允许用户输入或外部文件。", "solution": "所述问题是有效的。这是一个定义明确、具有科学依据的计算金融练习，遵循了无套利定价和离散时间对冲的基本原理。它提供了所有必要的参数和一个清晰、客观的任务。因此，我们将着手提供一个完整的解决方案。\n\n目标是当股价的真实数据生成过程（DGP）包含一个无变动状态时，比较二叉树模型和三叉树模型的对冲表现。表现通过平均绝对对冲误差来衡量，并通过蒙特卡洛模拟进行评估。\n\n首先，我们定义所有模型共有的参数。到期时间 $T$ 被划分为 $N$ 步，每步长度为 $\\Delta t = T/N$。在时间 $t$ 的股价 $S_t$ 可以向上移动，总回报为 $u = e^{\\sigma \\sqrt{\\Delta t}}$；向下移动，总回报为 $d = 1/u$；或者保持不变（总回报为 $1$）。连续复利无风险利率为 $r$。\n\n1.  **数据生成过程（物理测度）**\n    股价路径在物理测度下进行模拟，该测度决定了真实世界的概率。该过程是一个三叉树过程，具有指定的无变动概率 $p_m^{\\text{true}}$。向上移动的概率 $p_u^{\\text{true}}$ 和向下移动的概率 $p_d^{\\text{true}}$ 由两个条件确定：\n    1.  概率之和必须为一：$p_u^{\\text{true}} + p_d^{\\text{true}} + p_m^{\\text{true}} = 1$。\n    2.  期望总回报必须匹配真实世界的漂移率 $\\mu$：$\\mathbb{E}[S_{t+\\Delta t}/S_t] = p_u^{\\text{true}} u + p_m^{\\text{true}}(1) + p_d^{\\text{true}} d = e^{\\mu \\Delta t}$。\n\n    这个由两个线性方程组成的系统为 $p_u^{\\text{true}}$ 和 $p_d^{\\text{true}}$ 提供了唯一解：\n    $$p_u^{\\text{true}} = \\frac{e^{\\mu \\Delta t} - p_m^{\\text{true}} - d(1 - p_m^{\\text{true}})}{u - d}$$\n    $$p_d^{\\text{true}} = 1 - p_m^{\\text{true}} - p_u^{\\text{true}}$$\n    对于给定的参数，可以保证这些概率在 $[0,1]$ 区间内。我们使用这些概率和一个固定的随机种子生成 $M$ 条独立的股价路径，每条路径长度为 $N$ 步，以保证可复现性。\n\n2.  **用于对冲的格模型（风险中性测度）**\n    对冲和定价在风险中性测度 Q 下进行。基本原理是贴现后的股价是一个鞅。这意味着 $\\mathbb{E}_Q[e^{-r\\Delta t} S_{t+\\Delta t} | S_t] = e^{-r t} S_t$，可简化为 $\\mathbb{E}_Q[S_{t+\\Delta t}/S_t] = e^{r \\Delta t}$。令 $R = e^{r \\Delta t}$。\n\n    a. **二叉树模型：** 此模型只允许向上和向下移动。风险中性概率 $q_u$ 和 $q_d$ 通过以下方式找到：\n    $q_u u + q_d d = R$ 且 $q_u + q_d = 1$。\n    这给出了标准解：\n    $$q_u = \\frac{R - d}{u - d}$$\n    $$q_d = 1 - q_u$$\n\n    b. **三叉树模型：** 此模型明确包含了无变动状态。在对冲模拟中，我们将其无变动概率 $p_m$ 设置为等于真实的物理概率 $p_m^{\\text{true}}$。风险中性概率 $p_u, p_d, p_m$ 满足：\n    $p_u u + p_m (1) + p_d d = R$ 且 $p_u + p_m + p_d = 1$。\n    解此系统可得：\n    $$p_u = \\frac{R - p_m - d(1 - p_m)}{u - d}$$\n    $$p_d = 1 - p_m - p_u$$\n\n3.  **格定价与 Delta 计算**\n    对于每个模型，我们构建一个股价的重组格，其中时间步 $i$ 和状态 $j$ 的节点对应价格 $S_{i,j} = S_0 u^j$。状态索引 $j$ 的范围是从 $-i$ 到 $i$。我们在每个节点预先计算期权价值 $V$ 和对冲比率 $\\Delta$。\n\n    任何节点 $(i,j)$ 的期权价值通过反向归纳法找到。在到期日 $T$（第 $N$ 步），价值是欧式看涨期权的收益：\n    $$V_{N,j} = \\max(S_0 u^j - K, 0)$$\n    对于任何更早的时间步 $i  N$，价值是相应风险中性测度下贴现后的期望未来价值：\n    -   **二叉树模型：** $V_{i,j} = R^{-1} (q_u V_{i+1, j+1} + q_d V_{i+1, j-1})$\n    -   **三叉树模型：** $V_{i,j} = R^{-1} (p_u V_{i+1, j+1} + p_m V_{i+1, j} + p_d V_{i+1, j-1})$\n\n    在节点 $(i,j)$ 的对冲比率，或 delta ($\\Delta$)，使用下一时间步的期权价值的中心有限差分计算，具体如下：\n    $$\\Delta_{i,j} = \\frac{V_{i+1, j+1} - V_{i+1, j-1}}{S_{i+1, j+1} - S_{i+1, j-1}} = \\frac{V_{i+1, j+1} - V_{i+1, j-1}}{S_0 u^j (u - d)}$$\n    这个 $\\Delta$ 的公式适用于二叉树和三叉树模型，使用为每个模型计算的相应期权价值 $V$。\n\n4.  **自融资对冲模拟**\n    模拟的核心是为 $M$ 条生成的股价路径中的每一条追踪一个自融资投资组合 $\\Pi$ 的价值。单个路径的过程如下：\n    -   **初始化 (t=0):** 创建投资组合，其价值等于模型在时间 0 的期权价格，$\\Pi_0 = V_{0,0}$。\n    -   **递归更新：** 对于从 $0$ 到 $N-1$ 的每个时间步 $t$，我们更新投资组合价值。时间 $t$ 的投资组合价值为 $\\Pi_t$。我们从预先计算的格中找到对应股价 $S_t$ 的对冲比率 $\\Delta_t$。投资组合名义上由 $\\Delta_t$ 份股票和现金头寸 $B_t = \\Pi_t - \\Delta_t S_t$ 组成。该投资组合演化到时间 $t+1$：股价变为 $S_{t+1}$，现金产生利息，变为 $B_t R$。新的投资组合价值为：\n    $$\\Pi_{t+1} = \\Delta_t S_{t+1} + B_t R = \\Delta_t S_{t+1} + (\\Pi_t - \\Delta_t S_t) R$$\n    此递归应用于 $t=0, \\dots, N-1$，以找到终端投资组合价值 $\\Pi_T$。\n\n5.  **表现评估**\n    单个路径的终端对冲误差是对冲投资组合的最终价值 $\\Pi_T$ 与实际期权收益 $\\max(S_T - K, 0)$ 之间的差额。\n    $$\\text{误差} = \\Pi_T - \\max(S_T - K, 0)$$\n    对所有 $M$ 条路径重复此过程，并计算平均绝对误差（MAE）。我们使用二叉树模型进行定价/对冲计算 $\\text{MAE}_{\\text{binomial}}$，使用三叉树模型计算 $\\text{MAE}_{\\text{trinomial}}$。每个测试案例最终报告的指标是差值：\n    $$\\text{结果} = \\text{MAE}_{\\text{binomial}} - \\text{MAE}_{\\text{trinomial}}$$\n    正值结果表明，对于给定的 DGP，三叉树对冲策略更有效。\n\n该实现将包含一个主类，用于管理模拟参数和执行流程。它将生成股票路径，然后为每个对冲模型调用一个子程序来计算 MAE，并最终计算差值。为了提高效率，特别是在路径生成和格计算中，使用了向量化的 `numpy` 操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the hedging simulation for all test cases and print the results.\n    \"\"\"\n    M = 20000\n    seed = 12345\n\n    test_cases = [\n        {'case_id': 'A', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 50, 'pm_true': 0.2},\n        {'case_id': 'B', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.03, 'sigma': 0.1, 'T': 1.0, 'N': 100, 'pm_true': 0.6},\n        {'case_id': 'C', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.05, 'sigma': 0.2, 'T': 1.0, 'N': 50, 'pm_true': 0.0},\n        {'case_id': 'D', 'S0': 100.0, 'K': 100.0, 'r': 0.01, 'mu': 0.00, 'sigma': 0.3, 'T': 0.25, 'N': 50, 'pm_true': 0.3},\n    ]\n\n    results = []\n    for params in test_cases:\n        # We pop case_id as it's not a parameter for the simulator class\n        case_id = params.pop('case_id')\n        simulator = HedgingSimulator(**params, M=M, seed=seed)\n        result = simulator.run_full_comparison()\n        results.append(f\"{result:.6f}\")\n\n    print(f\"[{','.join(results)}]\")\n\nclass HedgingSimulator:\n    \"\"\"\n    A class to encapsulate the logic for comparing delta hedging performance.\n    \"\"\"\n    def __init__(self, S0, K, r, mu, sigma, T, N, pm_true, M, seed):\n        self.S0 = S0\n        self.K = K\n        self.r = r\n        self.mu = mu\n        self.sigma = sigma\n        self.T = T\n        self.N = int(N)\n        self.pm_true = pm_true\n        self.M = int(M)\n        self.seed = seed\n\n        # Derived parameters\n        self.dt = self.T / self.N\n        self.u = np.exp(self.sigma * np.sqrt(self.dt))\n        self.d = 1.0 / self.u\n        self.R_dt = np.exp(self.r * self.dt)\n        \n        # Pre-generate paths to be used by both hedging models\n        self.stock_paths, self.exponent_paths = self._generate_paths()\n\n    def _generate_paths(self):\n        \"\"\"Generates stock price paths based on the trinomial DGP.\"\"\"\n        R_mu_dt = np.exp(self.mu * self.dt)\n\n        # Solve for physical probabilities\n        pu_true = (R_mu_dt - self.pm_true - self.d * (1 - self.pm_true)) / (self.u - self.d)\n        pd_true = 1 - self.pm_true - pu_true\n        \n        # Check for valid probabilities\n        if not (0 = pu_true = 1 and 0 = pd_true = 1 and 0 = self.pm_true = 1):\n            raise ValueError(\"Invalid physical probabilities.\")\n\n        rng = np.random.default_rng(self.seed)\n        random_draws = rng.uniform(0, 1, size=(self.M, self.N))\n\n        moves = np.full((self.M, self.N), 0)  # Default is middle move (0)\n        moves[random_draws = pu_true] = 1  # Up move\n        moves[random_draws > (pu_true + self.pm_true)] = -1  # Down move\n\n        # Cumulative exponent path\n        exponent_paths_with_zero = np.hstack([np.zeros((self.M, 1), dtype=int), np.cumsum(moves, axis=1)])\n        \n        # Stock price paths\n        stock_paths = self.S0 * (self.u ** exponent_paths_with_zero)\n        \n        return stock_paths, exponent_paths_with_zero.astype(int)\n\n    def _get_model_prices_and_deltas(self, model_type):\n        \"\"\"Computes option values and deltas on a lattice for a given model.\"\"\"\n        if model_type == 'binomial':\n            pu_q = (self.R_dt - self.d) / (self.u - self.d)\n            pd_q = 1.0 - pu_q\n            pm_q = 0.0\n        elif model_type == 'trinomial':\n            pm_q = self.pm_true\n            pu_q = (self.R_dt - pm_q - self.d * (1 - pm_q)) / (self.u - self.d)\n            pd_q = 1.0 - pm_q - pu_q\n        else:\n            raise ValueError(\"Unknown model type\")\n            \n        # Lattice size to accommodate all possible states from trinomial moves\n        num_states = 2 * self.N + 1\n        V = np.zeros((self.N + 1, num_states))\n        Deltas = np.zeros((self.N, num_states))\n        \n        # Terminal condition\n        j_values_T = np.arange(-self.N, self.N + 1)\n        j_indices_T = j_values_T + self.N\n        stock_prices_T = self.S0 * (self.u ** j_values_T)\n        V[self.N, j_indices_T] = np.maximum(stock_prices_T - self.K, 0)\n\n        # Backward induction\n        for i in range(self.N - 1, -1, -1):\n            j_values = np.arange(-i, i + 1)\n            j_indices = j_values + self.N\n            \n            # Get next-step option values needed for current step\n            V_up = V[i + 1, j_indices + 1]\n            V_mid = V[i + 1, j_indices]\n            V_down = V[i + 1, j_indices - 1]\n            \n            # Calculate option value\n            expected_V = pu_q * V_up + pm_q * V_mid + pd_q * V_down\n            V[i, j_indices] = expected_V / self.R_dt\n            \n            # Calculate delta\n            stock_up = self.S0 * (self.u ** (j_values + 1))\n            stock_down = self.S0 * (self.u ** (j_values - 1))\n            \n            # Avoid division by zero if u=d, although u > d by construction\n            delta_S = stock_up - stock_down\n            Deltas[i, j_indices] = np.divide(V_up - V_down, delta_S, out=np.zeros_like(delta_S), where=delta_S!=0)\n    \n        return V, Deltas\n\n    def _calculate_hedge_error(self, model_type):\n        \"\"\"Simulates hedging and computes mean absolute error.\"\"\"\n        V, Deltas = self._get_model_prices_and_deltas(model_type)\n        V0 = V[0, self.N]\n        \n        errors = np.zeros(self.M)\n        \n        # Vectorized portfolio update\n        Pi = np.full(self.M, V0)\n        for t in range(self.N):\n            S_t = self.stock_paths[:, t]\n            S_t_plus_1 = self.stock_paths[:, t+1]\n            \n            # Get deltas for all paths at time t\n            j_values_t = self.exponent_paths[:, t]\n            j_indices_t = j_values_t + self.N\n            delta_t = Deltas[t, j_indices_t]\n            \n            # Update portfolio value for all paths\n            Pi = delta_t * S_t_plus_1 + (Pi - delta_t * S_t) * self.R_dt\n            \n        S_T = self.stock_paths[:, -1]\n        payoff = np.maximum(S_T - self.K, 0)\n        errors = Pi - payoff\n        \n        return np.mean(np.abs(errors))\n\n    def run_full_comparison(self):\n        \"\"\"Runs the simulation for both models and returns the difference in MAE.\"\"\"\n        mae_binomial = self._calculate_hedge_error('binomial')\n        mae_trinomial = self._calculate_hedge_error('trinomial')\n        return mae_binomial - mae_trinomial\n\nif __name__ == '__main__':\n    solve()\n\n```", "id": "2387642"}, {"introduction": "为了更贴近真实世界的复杂性，我们将对冲模拟提升到一个新的层次。这个练习引入了随机的股票借贷成本，这是做空操作中一项重要的现实摩擦。你将学习如何调整自融资投资组合的递推关系以计入这些额外成本，并模拟相关的随机过程，从而深化对实际对冲挑战的理解。[@problem_id:2387615]", "problem": "当股票空头头寸的借券费是随机且显著时，为欧式看涨期权实现一个离散时间的 Delta 对冲模拟器。对于一个看涨期权多头头寸，采用一种自融资策略，该策略通过做空期权 Delta 数量的标的资产进行对冲，并在现金账户中为剩余部分融资。在风险中性测度下，股票价格过程遵循几何布朗运动，而借券费遵循一个正的、均值回归的平方根（Cox-Ingersoll-Ross）过程，该过程可能与股票相关。从自融资交易策略和几何布朗运动模型的基本定义出发，推导出离散时间对冲现金流的递归关系，并实现模拟以生成对冲组合的期末价值。\n\n用作基本依据的假设和定义：\n- 在风险中性测度下，标的股票价格过程由以下随机微分方程（SDE）给出：\n$$\ndS_t = S_t\\, r\\, dt + S_t\\, \\sigma\\, dW_t^{(S)},\n$$\n其中 $S_t$ 是股票价格，$r$ 是连续复利无风险利率，$\\sigma$ 是恒定波动率，$W_t^{(S)}$ 是一个标准维纳过程。\n- 股票空头头寸的借券费（年化，以小数形式表示）遵循一个 Cox-Ingersoll-Ross 过程：\n$$\ndb_t = \\kappa(\\theta - b_t)\\, dt + \\nu \\sqrt{b_t}\\, dW_t^{(b)},\n$$\n其中均值回归速度 $\\kappa \\ge 0$，长期均值 $\\theta \\ge 0$，波动率参数 $\\nu \\ge 0$，$W_t^{(b)}$ 是一个标准维纳过程。这两个维纳过程瞬时相关，相关系数为 $\\rho \\in [-1,1]$，即 $dW_t^{(S)} dW_t^{(b)} = \\rho\\, dt$。\n- 欧式看涨期权的行权价为 $K$，到期日为 $T$。其 Black-Scholes 价值 $V(S,t)$ 和 Delta 值 $\\Delta(S,t)$ 由具有恒定 $r$ 和 $\\sigma$ 的标准无股息 Black-Scholes 框架定义。时间以年为单位，所有利率均为年化小数。\n- 在时间 $t$，一个自融资的 Delta 对冲看涨期权多头组合持有一份期权 $V_t$，做空 $\\Delta_t$ 股股票，并持有一个现金头寸 $B_t$。其市值为：\n$$\nP_t = V_t - \\Delta_t S_t + B_t.\n$$\n为确保 $P_0 = 0$，初始化 $B_0 = \\Delta_0 S_0 - V_0$。\n\n离散时间模拟和对冲协议：\n- 使用 $N$ 个等间隔的再平衡时间点，步长为 $\\Delta t = T/N$。在每个区间 $[t_i, t_{i+1}]$（其中 $t_i = i \\Delta t$），按顺序执行以下操作：\n  1. 根据区间开始时的水平支付股票空头头寸的借券费：现金账户 $B$ 减少 $b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t$。\n  2. 现金账户按无风险利率计息：$B \\leftarrow B \\cdot (1 + r \\Delta t)$。\n  3. 使用欧拉式离散化来演化状态变量：\n     - 对于股票，\n     $$\n     S_{t_{i+1}} = S_{t_i} \\exp\\Big( (r - \\tfrac{1}{2} \\sigma^2)\\Delta t + \\sigma \\sqrt{\\Delta t}\\, Z_S \\Big),\n     $$\n     其中 $Z_S \\sim \\mathcal{N}(0,1)$。\n     - 对于借券费 $b_t$，使用带完全截断的欧拉法以保持非负性：\n     $$\n     b_{t_{i+1}} = \\max\\!\\Big\\{ b_{t_i} + \\kappa(\\theta - b_{t_i}) \\Delta t + \\nu \\sqrt{\\max(b_{t_i}, 0)} \\sqrt{\\Delta t}\\, Z_b,\\ 0 \\Big\\},\n     $$\n     其中 $Z_b$ 是标准正态分布，并通过 $\\text{Corr}(Z_S, Z_b) = \\rho$ 与 $Z_S$ 相关。\n  4. 使用参数为 $r$ 和 $\\sigma$ 的 Black-Scholes 模型，在新的剩余到期时间 $\\tau_{i+1} = T - t_{i+1}$ 处更新期权价值和 Delta。\n  5. 将股票空头头寸再平衡至新的 Delta：通过改变空头头寸产生的收益/成本来调整现金，\n     $$\n     B \\leftarrow B + (\\Delta_{t_{i+1}} - \\Delta_{t_i}) S_{t_{i+1}}.\n     $$\n- 到期时，设置 $V_T = \\max(S_T - K, 0)$ 且 $\\Delta_T \\in \\{0,1\\}$ 的选择与 Black-Scholes delta 的极限一致。期末组合价值为：\n$$\nP_T = V_T - \\Delta_T S_T + B_T.\n$$\n将 $P_T$（与 $S_0$ 的货币单位相同）解释为从零初始财富开始的自融资 Delta 对冲看涨期权多头的期末损益。在连续时间和连续再平衡的理想条件下，$P_T$ 等于由空头头寸和股票价值加权的借券费的负积分；在离散时间中，由于有限频率的对冲，会产生额外的离散化误差。\n\n实现要求：\n- 严格遵循上述协议。对 $b_t$ 使用带完全截断的欧拉式离散化，对 $S_t$ 使用对数欧拉格式。在每一步使用相关系数为 $\\rho$ 的相关标准正态变量 $(Z_S, Z_b)$。在每个再平衡时间点使用 Black-Scholes 公式计算期权价值和 Delta。通过使用 $V_T = \\max(S_T - K, 0)$ 和 $\\Delta_T = \\mathbf{1}\\{S_T > K\\}$ 来处理 $\\tau = 0$ 的情况。\n- 所有输入均为年化单位：$r$、$\\sigma$ 和 $b_t$ 为年化小数；$T$ 以年为单位。货币量应以与 $S_0$ 相同的单位报告。\n- 对于随机数生成，请使用测试套件中为每个测试用例提供的固定种子，以确保结果可复现。\n- 程序必须输出单行，其中包含每个测试用例的期末组合价值 $P_T$ 的列表，四舍五入到 6 位小数，格式为用方括号括起来的逗号分隔列表，无空格，例如 $[x_1,x_2,x_3]$。\n\n测试套件（独立并按给定顺序处理每个案例）：\n- 案例 1 (正常路径)：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.05$, $\\kappa = 1.5$, $\\theta = 0.05$, $\\nu = 0.3$, $\\rho = 0.0$, $N = 252$, $\\text{seed} = 12345$。\n- 案例 2 (高且波动的借券费，正相关)：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.5$, $\\kappa = 1.0$, $\\theta = 0.5$, $\\nu = 1.0$, $\\rho = 0.5$, $N = 252$, $\\text{seed} = 2023$。\n- 案例 3 (确定性借券费，每周对冲)：$S_0 = 100$, $K = 110$, $T = 1$, $\\sigma = 0.25$, $r = 0.0$, $b_0 = 0.1$, $\\kappa = 0.0$, $\\theta = 0.1$, $\\nu = 0.0$, $\\rho = 0.0$, $N = 52$, $\\text{seed} = 7$。\n- 案例 4 (接近零的借券费，每日对冲)：$S_0 = 100$, $K = 100$, $T = 1$, $\\sigma = 0.2$, $r = 0.01$, $b_0 = 0.0$, $\\kappa = 2.0$, $\\theta = 0.0$, $\\nu = 0.0$, $\\rho = 0.0$, $N = 252$, $\\text{seed} = 999$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，无空格。列表中的条目必须分别是案例 1 到 4 的期末价值 $P_T$，每个值四舍五入到 6 位小数，例如 $[x_1,x_2,x_3,x_4]$。", "solution": "问题陈述已经过分析并被确定为有效。它在科学上基于金融工程的原理，对于给定的参数和随机种子是适定的且有唯一解，并且使用客观、无歧义的语言表述。所有实现所需模拟的必要数据、模型和程序均已提供。我们可以开始求解。\n\n目标是为一个欧式看涨期权多头实现一个 Delta 对冲策略的离散时间模拟。该策略是自融资的，并在一个对冲所需的股票空头头寸存在随机借券费的环境中执行。该策略以零资本启动，其损益（$P_T$）是需要计算的量。\n\n首先，我们必须定义 Delta 对冲组合的组成部分。在任意时刻 $t$，组合的价值 $P_t$ 由一份价值为 $V_t$ 的看涨期权多头、一个数量为 $\\Delta_t$ 股、价格为 $S_t$ 的标的股票空头头寸，以及一笔现金余额 $B_t$ 组成。其价值由下式给出：\n$$\nP_t = V_t - \\Delta_t S_t + B_t\n$$\n该策略是自融资的，这意味着组合价值的变化仅源于市场变动和指定的现金流（利息和费用），而非资本的注入或撤出。初始组合价值设为零，$P_0 = 0$，这定义了初始现金余额为 $B_0 = \\Delta_0 S_0 - V_0$。\n\n模拟以大小为 $\\Delta t = T/N$ 的离散时间步进行。我们用 $(S_{t_i}, b_{t_i}, B_{t_i}, \\Delta_{t_i}, V_{t_i})$ 表示在时间 $t_i = i \\Delta t$ 的状态。我们将遵循指定协议，推导在区间 $[t_i, t_{i+1}]$ 上现金余额 $B_t$ 的递归关系。\n\n1.  **支付借券费：** 在区间开始时，为持有股票空头头寸支付费用。空头头寸的大小为 $\\Delta_{t_i}$ 股，总价值为 $\\Delta_{t_i} S_{t_i}$。年化借券费率为 $b_{t_i}$。在 $\\Delta t$ 期间，费用为 $b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t$。这笔金额从现金账户中扣除。\n    $$\n    B \\rightarrow B_{t_i} - b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t\n    $$\n\n2.  **利息累积：** 现金账户按无风险利率 $r$ 累积利息。问题指定在离散步骤中采用单利计算。\n    $$\n    B \\rightarrow \\left( B_{t_i} - b_{t_i} \\Delta_{t_i} S_{t_i} \\Delta t \\right) (1 + r \\Delta t)\n    $$\n    我们将此中间现金余额表示为 $B'_{t_{i+1}}$。\n\n3.  **状态变量的演化：** 标的股票价格 $S_t$ 和借券费率 $b_t$ 在区间 $\\Delta t$ 内演化。问题指定了以下离散化格式。\n    对于遵循风险中性测度下几何布朗运动的股票价格：\n    $$\n    S_{t_{i+1}} = S_{t_i} \\exp\\left( \\left(r - \\frac{1}{2}\\sigma^2\\right)\\Delta t + \\sigma \\sqrt{\\Delta t} Z_S \\right)\n    $$\n    对于遵循 Cox-Ingersoll-Ross 过程的借券费率，使用截断的 Euler-Maruyama 格式以确保非负性：\n    $$\n    b_{t_{i+1}} = \\max\\left\\{ 0, b_{t_i} + \\kappa(\\theta - b_{t_i})\\Delta t + \\nu \\sqrt{\\max(b_{t_i}, 0)} \\sqrt{\\Delta t} Z_b \\right\\}\n    $$\n    随机变量 $Z_S$ 和 $Z_b$ 是标准正态的，即 $Z_S, Z_b \\sim \\mathcal{N}(0,1)$，并且以系数 $\\rho$ 相关。为了生成它们，我们首先抽取两个独立的标准正态变量 $X_1$ 和 $X_2$，然后设置 $Z_S = X_1$ 和 $Z_b = \\rho X_1 + \\sqrt{1 - \\rho^2} X_2$。\n\n4.  **期权指标更新：** 根据新的股票价格 $S_{t_{i+1}}$ 和新的剩余到期时间 $\\tau_{i+1} = T - t_{i+1}$，重新计算期权的公允价值 $V_{t_{i+1}}$ 和对冲比率 $\\Delta_{t_{i+1}}$。问题要求使用标准的 Black-Scholes 公式，该公式假设无风险利率 $r$ 和波动率 $\\sigma$ 为常数，且不考虑借券费。\n    Black-Scholes 看涨期权价格为：\n    $$\n    V(S, \\tau; K, r, \\sigma) = S N(d_1) - K e^{-r\\tau} N(d_2)\n    $$\n    Delta 值为：\n    $$\n    \\Delta(S, \\tau; K, r, \\sigma) = N(d_1)\n    $$\n    其中 $\\tau = T-t$ 是剩余到期时间，$N(\\cdot)$ 是标准正态累积分布函数，且\n    $$\n    d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)\\tau}{\\sigma \\sqrt{\\tau}}, \\quad d_2 = d_1 - \\sigma \\sqrt{\\tau}\n    $$\n    在到期时（$t=T, \\tau=0$），这些公式是未定义的。我们必须使用指定的期末条件：$V_T = \\max(S_T - K, 0)$ 和 $\\Delta_T = \\mathbf{1}_{S_T > K}$，其中 $\\mathbf{1}_{\\{\\cdot\\}}$ 是指示函数。\n\n5.  **对冲再平衡：** 股票的空头头寸从 $\\Delta_{t_i}$ 股调整到新的目标 $\\Delta_{t_{i+1}}$ 股。此交易必须是自融资的。做空的股票数量变化会产生现金流。现金的变化等于卖空（正）或回购（负）的股票数量乘以当前股价 $S_{t_{i+1}}$。现金调整额为 $(\\Delta_{i} - \\Delta_{i+1}) S_{t_{i+1}}$。\n    因此，时间 $t_{i+1}$ 的最终现金余额为：\n    $$\n    B_{t_{i+1}} = B'_{t_{i+1}} + (\\Delta_i - \\Delta_{i+1}) S_{t_{i+1}}\n    $$\n    根据自融资原则，等价地，现金余额的更新遵循问题中给出的公式：\n    $$\n    B_{t_{i+1}} = B'_{t_{i+1}} + (\\Delta_{t_{i+1}} - \\Delta_{t_i}) S_{t_{i+1}}\n    $$\n\n这就完成了组合状态从 $t_i$到 $t_{i+1}$ 的演化。模拟从 $t_0=0$ 的初始状态开始，迭代 $N$ 次，直到达到到期时间 $T$。\n\n最终的损益 $P_T$ 是组合在到期时的价值：\n$$\nP_T = V_T - \\Delta_T S_T + B_T\n$$\n此处，$S_T$、$V_T$、$\\Delta_T$ 和 $B_T$ 是模拟循环最后一步之后相应变量的值。$P_T$ 值代表了对冲活动的净结果，它既包含了借券费的成本，也包含了对具有非零 Gamma 的期权使用离散对冲安排所带来的误差。\n\n要实现的算法如下：\n对于每个测试用例：\n1.  初始化参数：$S_0, K, T, \\sigma, r, b_0, \\kappa, \\theta, \\nu, \\rho, N$，以及随机种子。\n2.  计算 $\\Delta t = T/N$。用指定的种子设置一个随机数生成器。\n3.  设置初始状态变量：$S = S_0, b = b_0$。\n4.  在时间 $t=0$ 处，使用 Black-Scholes 公式（$\\tau=T$）计算初始期权价值 $V$ 和 Delta 值 $\\Delta$。\n5.  初始化现金余额：$B = \\Delta S - V$。\n6.  从 $i=0$ 到 $N-1$ 循环：\n    a. 存储当前 Delta：$\\Delta_{old} = \\Delta$。\n    b. 支付借券费：$B \\leftarrow B - b \\cdot \\Delta \\cdot S \\cdot \\Delta t$。\n    c. 计算利息：$B \\leftarrow B \\cdot (1 + r \\Delta t)$。\n    d. 生成相关的标准正态随机数 $Z_S, Z_b$。\n    e. 将股票价格 $S$ 演化到 $t_{i+1}$ 时刻的新值。\n    f. 将借券费 $b$ 演化到 $t_{i+1}$ 时刻的新值。\n    g. 计算新的剩余到期时间 $\\tau = T - (i+1)\\Delta t$。\n    h. 如果 $\\tau > 0$，使用 Black-Scholes 公式更新 $V$ 和 $\\Delta$。如果 $\\tau \\le 0$，使用期末收益和 Delta 条件更新。\n    i. 再平衡对冲：$B \\leftarrow B + (\\Delta - \\Delta_{old}) \\cdot S$。\n7.  循环结束后，计算期末组合价值：$P_T = V - \\Delta \\cdot S + B$。\n8.  存储结果，四舍五入到 6 位小数。\n\n在处理完所有测试用例后，将收集到的结果格式化为所需的字符串输出。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import norm\n\ndef solve():\n    \"\"\"\n    Main function to run the delta hedging simulation for all test cases.\n    \"\"\"\n\n    def black_scholes_call(S, K, T, r, sigma):\n        \"\"\"\n        Calculates the price of a European call option using the Black-Scholes model.\n        \"\"\"\n        if T = 1e-9:  # Treat times very close to zero as zero\n            return np.maximum(S - K, 0.0)\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    def black_scholes_delta(S, K, T, r, sigma):\n        \"\"\"\n        Calculates the delta of a European call option using the Black-Scholes model.\n        \"\"\"\n        if T = 1e-9:  # Treat times very close to zero as zero\n            return np.where(S > K, 1.0, 0.0)\n        d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        return norm.cdf(d1)\n\n    def simulate_hedge(S0, K, T, sigma, r, b0, kappa, theta, nu, rho, N, seed):\n        \"\"\"\n        Performs the discrete-time delta hedging simulation.\n        \n        S0, K, T, sigma, r: Option and GBM parameters.\n        b0, kappa, theta, nu, rho: CIR process and correlation parameters.\n        N: Number of hedging intervals.\n        seed: Random seed for reproducibility.\n        \n        Returns the terminal profit-and-loss (P) of the strategy.\n        \"\"\"\n        dt = T / N\n        rng = np.random.default_rng(seed)\n        \n        # Pre-generate all random numbers for efficiency\n        Z_independent = rng.standard_normal(size=(N, 2))\n        \n        # Initial state\n        S = float(S0)\n        b = float(b0)\n\n        # Initialize portfolio at t=0\n        tau = T\n        V = black_scholes_call(S, K, tau, r, sigma)\n        delta = black_scholes_delta(S, K, tau, r, sigma)\n        \n        # Set initial cash B0 such that initial portfolio value P0 is zero\n        # P0 = V0 - delta0 * S0 + B0 = 0  => B0 = delta0 * S0 - V0\n        B = delta * S - V\n\n        # Simulation loop over N time steps\n        for i in range(N):\n            # Store values at the beginning of the interval [t_i, t_{i+1}]\n            delta_old = delta\n            \n            # --- Hedging Protocol at each step ---\n            \n            # 1. Pay borrowing fee on the short stock position\n            # Fee is based on beginning-of-interval values S_i, b_i, delta_i\n            borrow_fee_cost = b * delta * S * dt\n            B -= borrow_fee_cost\n\n            # 2. Accrue interest on the cash account\n            B *= (1.0 + r * dt)\n            \n            # 3. Evolve state variables S and b to t_{i+1}\n            \n            # Generate correlated normal random variables for this step\n            Z_S = Z_independent[i, 0]\n            Z_b = rho * Z_independent[i, 0] + np.sqrt(1.0 - rho**2) * Z_independent[i, 1]\n            \n            # Evolve stock price using log-Euler scheme\n            S *= np.exp((r - 0.5 * sigma**2) * dt + sigma * np.sqrt(dt) * Z_S)\n            \n            # Evolve borrow fee using truncated Euler scheme\n            # Use max(b, 0) inside sqrt for numerical stability as per problem\n            db = kappa * (theta - b) * dt + nu * np.sqrt(max(b, 0.0)) * np.sqrt(dt) * Z_b\n            b = max(b + db, 0.0)\n\n            # 4. Update option value and delta for the new state at t_{i+1}\n            current_time = (i + 1) * dt\n            tau = T - current_time\n            \n            V = black_scholes_call(S, K, tau, r, sigma)\n            delta = black_scholes_delta(S, K, tau, r, sigma)\n            \n            # 5. Rebalance the short stock position to the new delta\n            # Cash is adjusted by the proceeds/costs of changing the short position\n            # Change in cash = (new_delta - old_delta) * S_{i+1}\n            B += (delta - delta_old) * S\n            \n        # At maturity T, after the final rebalancing step\n        # The variables S, V, delta, B hold their terminal values S_T, V_T, delta_T, B_T\n        # Calculate final portfolio value P_T = V_T - delta_T * S_T + B_T\n        P_T = V - delta * S + B\n        \n        return P_T\n\n    test_cases = [\n        # Case 1 (happy path)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.05, 'kappa': 1.5, 'theta': 0.05, 'nu': 0.3, 'rho': 0.0, 'N': 252, 'seed': 12345},\n        # Case 2 (high and volatile borrow, positive correlation)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.5, 'kappa': 1.0, 'theta': 0.5, 'nu': 1.0, 'rho': 0.5, 'N': 252, 'seed': 2023},\n        # Case 3 (deterministic borrow, weekly hedging)\n        {'S0': 100, 'K': 110, 'T': 1, 'sigma': 0.25, 'r': 0.0, 'b0': 0.1, 'kappa': 0.0, 'theta': 0.1, 'nu': 0.0, 'rho': 0.0, 'N': 52, 'seed': 7},\n        # Case 4 (nearly zero borrow, daily hedging)\n        {'S0': 100, 'K': 100, 'T': 1, 'sigma': 0.2, 'r': 0.01, 'b0': 0.0, 'kappa': 2.0, 'theta': 0.0, 'nu': 0.0, 'rho': 0.0, 'N': 252, 'seed': 999},\n    ]\n\n    results = []\n    for case in test_cases:\n        pnl = simulate_hedge(**case)\n        results.append(f\"{pnl:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2387615"}]}