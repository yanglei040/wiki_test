{"hands_on_practices": [{"introduction": "在资本预算中，我们经常会遇到净现值（NPV）是利率的非线性函数的情况。当分析师只能在离散的利率点上计算NPV时，分段线性插值提供了一种简单而直观的方法来估算内部收益率（IRR），即NPV函数为零时的利率。这个练习将帮助你应用插值法来近似求解这个重要的金融方程，从而锻炼你的实践技能 [@problem_id:2419227]。", "problem": "在计算经济学和金融学的资本预算中，一个具有现金流序列 $\\{C_{0}, C_{1}, \\dots, C_{T}\\}$ 的确定性项目，以贴现率 $r$ 进行贴现的净现值 (NPV) 由以下基本现值关系定义：\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}.\n$$\n内部收益率 (IRR) 被定义为唯一的实数 $r^{\\ast}$（如果存在），使得 $\\mathrm{NPV}(r^{\\ast})=0$。\n\n考虑一个单期项目，其在时间 $t=0$ 的现金流为 $C_{0}=-100$，在时间 $t=1$ 的现金流为 $C_{1}=103.5$。假设一位分析师仅在一组离散的利率集合 $r \\in \\{0.01,0.02,\\dots,0.10\\}$ 上计算该项目的 $\\mathrm{NPV}(r)$，然后使用相邻网格点之间的 $\\mathrm{NPV}(r)$ 分段线性插值来估计 IRR。\n\n仅使用位于 $\\mathrm{NPV}(r)$ 符号变化两侧的两个连续网格利率，构建该区间上 $\\mathrm{NPV}(r)$ 的线性插值函数，并求解插值得到的 IRR。接下来，从第一性原理精确计算真实的 IRR。最后，将插值得到的 IRR 与真实 IRR 之间的绝对差值以单一数字报告。请将最终答案表示为一个精确分数（不进行四舍五入）。百分比必须表示为小数或分数，不得使用百分号。", "solution": "在尝试任何解答之前，对问题陈述进行严格的验证。\n\n第1步：提取已知条件\n-   净现值 (NPV) 定义：$\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{T} \\frac{C_{t}}{(1+r)^{t}}$\n-   内部收益率 (IRR) 定义：唯一的实数 $r^{\\ast}$，使得 $\\mathrm{NPV}(r^{\\ast}) = 0$。\n-   项目现金流：$t=0$ 时为 $C_{0}=-100$，$t=1$ 时为 $C_{1}=103.5$。\n-   项目期限：$T=1$。\n-   用于插值的离散利率集合：$r \\in \\{0.01, 0.02, \\dots, 0.10\\}$。\n-   任务1：使用位于 $\\mathrm{NPV}(r)$ 符号变化两侧的两个连续网格利率之间的分段线性插值来估计 IRR ($r_{\\text{interp}}$)。\n-   任务2：精确计算真实的 IRR ($r_{\\text{true}}$)。\n-   任务3：将绝对差值 $|r_{\\text{interp}} - r_{\\text{true}}|$ 报告为精确分数。\n\n第2步：使用提取的已知条件进行验证\n根据所需标准对问题进行评估。\n-   **科学依据**：NPV、IRR 和线性插值的概念在金融学和数值分析中是标准且成熟的。其前提在事实上和数学上都是合理的。\n-   **适定性**：该问题提供了所有必要的数据和一个清晰、明确的目标。存在唯一的解，并且可以从所提供的信息中推导出来。\n-   **客观性**：问题以精确、正式的语言陈述，没有主观性或模糊性。\n\n第3步：结论与行动\n问题有效。它是自洽的、有科学依据的并且是适定的。将推导解答。\n\n给定单期项目的 NPV 为：\n$$\n\\mathrm{NPV}(r) = C_{0} + \\frac{C_{1}}{1+r} = -100 + \\frac{103.5}{1+r}\n$$\n\n第一步是确定进行线性插值的区间。我们必须在指定的网格点上评估 $\\mathrm{NPV}(r)$，以找到两个连续的利率 $r_{1}$ 和 $r_{2}$，使得 $\\mathrm{NPV}(r_{1})$ 和 $\\mathrm{NPV}(r_{2})$ 的符号相反。对于 $r  -1$，函数 $\\mathrm{NPV}(r)$ 是 $r$ 的单调递减函数。\n\n让我们在网格点上进行评估：\n$\\mathrm{NPV}(0.01) = -100 + \\frac{103.5}{1.01} \\approx 2.475  0$\n$\\mathrm{NPV}(0.02) = -100 + \\frac{103.5}{1.02} \\approx 1.471  0$\n$\\mathrm{NPV}(0.03) = -100 + \\frac{103.5}{1.03} = -100 + \\frac{10350}{103} = \\frac{-10300 + 10350}{103} = \\frac{50}{103}  0$\n$\\mathrm{NPV}(0.04) = -100 + \\frac{103.5}{1.04} = -100 + \\frac{10350}{104} = \\frac{-10400 + 10350}{104} = -\\frac{50}{104}  0$\n\n符号变化发生在区间 $[0.03, 0.04]$ 内。因此，我们使用点 $(r_{1}, \\mathrm{NPV}(r_{1}))$ 和 $(r_{2}, \\mathrm{NPV}(r_{2}))$，其中 $r_{1} = 0.03$ 和 $r_{2} = 0.04$。相应的 NPV 值为 $\\mathrm{NPV}(r_{1}) = \\frac{50}{103}$ 和 $\\mathrm{NPV}(r_{2}) = -\\frac{50}{104}$。\n\n我们构建一个通过这两点的线性插值函数 $L(r)$。插值得到的 IRR（我们记作 $r_{\\text{interp}}$）是该线性函数的根，即 $L(r_{\\text{interp}}) = 0$。使用线性插值公式（或割线法）：\n$$\nr_{\\text{interp}} = r_{1} - \\mathrm{NPV}(r_{1}) \\frac{r_{2} - r_{1}}{\\mathrm{NPV}(r_{2}) - \\mathrm{NPV}(r_{1})}\n$$\n代入已知值：\n$$\nr_{\\text{interp}} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.04 - 0.03}{\\left(-\\frac{50}{104}\\right) - \\left(\\frac{50}{103}\\right)} = 0.03 - \\left(\\frac{50}{103}\\right) \\frac{0.01}{-50 \\left(\\frac{1}{104} + \\frac{1}{103}\\right)}\n$$\n$$\nr_{\\text{interp}} = 0.03 + \\frac{1}{103} \\frac{0.01}{\\frac{103+104}{104 \\cdot 103}} = 0.03 + \\frac{0.01}{103} \\frac{104 \\cdot 103}{207} = 0.03 + 0.01 \\cdot \\frac{104}{207}\n$$\n表示为分数：\n$$\nr_{\\text{interp}} = \\frac{3}{100} + \\frac{1}{100} \\cdot \\frac{104}{207} = \\frac{1}{100} \\left( 3 + \\frac{104}{207} \\right) = \\frac{1}{100} \\left( \\frac{3 \\cdot 207 + 104}{207} \\right)\n$$\n$$\nr_{\\text{interp}} = \\frac{1}{100} \\left( \\frac{621 + 104}{207} \\right) = \\frac{725}{20700}\n$$\n这个分数可以化简。分子和分母都可以被 $25$ 整除：\n$$\nr_{\\text{interp}} = \\frac{725 \\div 25}{20700 \\div 25} = \\frac{29}{828}\n$$\n接下来，我们通过设置 $\\mathrm{NPV}(r_{\\text{true}})=0$ 来计算真实的 IRR，$r_{\\text{true}}$：\n$$\n-100 + \\frac{103.5}{1+r_{\\text{true}}} = 0\n$$\n$$\n\\frac{103.5}{1+r_{\\text{true}}} = 100\n$$\n$$\n1+r_{\\text{true}} = \\frac{103.5}{100} = 1.035\n$$\n$$\nr_{\\text{true}} = 1.035 - 1 = 0.035\n$$\n作为精确分数：\n$$\nr_{\\text{true}} = \\frac{35}{1000} = \\frac{7}{200}\n$$\n最后，我们计算插值得到的 IRR 和真实 IRR 之间的绝对差值：\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29}{828} - \\frac{7}{200} \\right|\n$$\n为了进行分数减法，我们找到一个公分母。素数分解为 $828 = 2^{2} \\cdot 3^{2} \\cdot 23$ 和 $200 = 2^{3} \\cdot 5^{2}$。最小公倍数是 $2^{3} \\cdot 3^{2} \\cdot 5^{2} \\cdot 23 = 8 \\cdot 9 \\cdot 25 \\cdot 23 = 41400$。\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{29 \\cdot 50}{828 \\cdot 50} - \\frac{7 \\cdot 207}{200 \\cdot 207} \\right| = \\left| \\frac{1450}{41400} - \\frac{1449}{41400} \\right|\n$$\n$$\n|r_{\\text{interp}} - r_{\\text{true}}| = \\left| \\frac{1450 - 1449}{41400} \\right| = \\frac{1}{41400}\n$$\n这就是所要求的作为精确分数的绝对差值。", "answer": "$$\n\\boxed{\\frac{1}{41400}}\n$$", "id": "2419227"}, {"introduction": "在金融市场中，诸如“买卖权平价关系”（put-call parity）之类的无套利关系是基本法则。当我们使用插值法来构建模型或填补缺失数据时，一个关键问题是这些基本法则是否得到了保留。这项练习 [@problem_id:2419232] 将通过分别对看涨和看跌期权价格进行线性插值，来检验买卖权平价关系的完整性是否得以维持，从而揭示线性算子的一个重要特性。", "problem": "一个量化研究团队需要为一个风险引擎中使用的欧式期权曲面计算不同执行价上的期权价值。他们决定对看涨期权和看跌期权分别按执行价进行分段线性插值。考虑一个具有以下市场输入的单一到期日：\n\n- 标的现货价格 $S_0 = 100$（货币单位）。\n- 到期时间 $T = 0.5$（年）。\n- 连续复利无风险利率 $r = 0$（年化）。\n- 连续股息率 $q = 0$（年化）。\n- 在执行价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价：\n  - 看涨期权价格：$C(95) = 9$, $C(105) = 4$。\n  - 看跌期权价格：$P(95) = 4$, $P(105) = 9$。\n\n使用按执行价 $K$ 的分段线性插值，独立地对看涨期权和看跌期权进行插值，以得到目标执行价 $K^{\\ast} = 100$ 处的 $C_{\\text{lin}}(K^{\\ast})$ 和 $P_{\\text{lin}}(K^{\\ast})$。然后计算看涨-看跌期权平价残差\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr).\n$$\n以货币单位将 $R$ 的值报告为一个实数。无需四舍五入。", "solution": "该问题要求在对看涨期权和看跌期权价格进行分段线性插值后，计算看涨-看跌期权平价残差。首先，必须严格验证问题陈述的有效性。\n\n**问题验证**\n逐字列出给定的条件：\n- 标的现货价格 $S_0 = 100$。\n- 到期时间 $T = 0.5$。\n- 连续复利无风险利率 $r = 0$。\n- 连续股息率 $q = 0$。\n- 在执行价 $K_1 = 95$ 和 $K_2 = 105$ 处观测到的中间价。\n- 看涨期权价格：$C(95) = 9$, $C(105) = 4$。\n- 看跌期权价格：$P(95) = 4$, $P(105) = 9$。\n- 目标执行价 $K^{\\ast} = 100$。\n\n欧式期权的看涨-看跌期权平价关系是金融学中的一个基本原则，由下式给出：\n$$C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$$\n给定参数 $r = 0$ 和 $q = 0$，此关系简化为：\n$$C(K) - P(K) = S_0 - K$$\n一个关键步骤是检查所提供的市场数据是否与此原则一致。\n在执行价 $K_1 = 95$ 处：\n左边是 $C(95) - P(95) = 9 - 4 = 5$。\n右边是 $S_0 - K_1 = 100 - 95 = 5$。\n两值一致。\n\n在执行价 $K_2 = 105$ 处：\n左边是 $C(105) - P(105) = 4 - 9 = -5$。\n右边是 $S_0 - K_2 = 100 - 105 = -5$。\n两值一致。\n\n该问题具有科学依据，因为它基于标准的金融工程原理和内部一致的数据。它是适定的、客观且完整的。因此，该问题是有效的，我们将继续进行求解。\n\n**求解推导**\n指定的方法是对看涨期权和看跌期权价格按执行价 $K$ 独立进行分段线性插值。对于一个在点 $x_1$ 和 $x_2$ 处具有已知值的函数 $f(x)$，其在中间点 $x$ 的线性插值由以下公式给出：\n$$f(x) = f(x_1) + (x - x_1) \\frac{f(x_2) - f(x_1)}{x_2 - x_1}$$\n\n首先，我们应用此公式对目标执行价 $K^{\\ast} = 100$ 处的看涨期权价格 $C(K)$ 进行插值。已知的数据点为 $(K_1, C(K_1)) = (95, 9)$ 和 $(K_2, C(K_2)) = (105, 4)$。\n$$\nC_{\\text{lin}}(K^{\\ast}) = C(K_1) + (K^{\\ast} - K_1) \\frac{C(K_2) - C(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nC_{\\text{lin}}(100) = 9 + (100 - 95) \\frac{4 - 9}{105 - 95} = 9 + (5) \\frac{-5}{10} = 9 - 2.5 = 6.5\n$$\n\n接下来，我们对看跌期权价格 $P(K)$ 进行相同的插值。已知的数据点为 $(K_1, P(K_1)) = (95, 4)$ 和 $(K_2, P(K_2)) = (105, 9)$。\n$$\nP_{\\text{lin}}(K^{\\ast}) = P(K_1) + (K^{\\ast} - K_1) \\frac{P(K_2) - P(K_1)}{K_2 - K_1}\n$$\n代入数值：\n$$\nP_{\\text{lin}}(100) = 4 + (100 - 95) \\frac{9 - 4}{105 - 95} = 4 + (5) \\frac{5}{10} = 4 + 2.5 = 6.5\n$$\n\n最后一步是计算问题陈述中定义的看涨-看跌期权平价残差 $R$：\n$$\nR \\equiv \\bigl(C_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast})\\bigr) - \\bigl(S_0 \\exp(-q T) - K^{\\ast} \\exp(-r T)\\bigr)\n$$\n我们已得到插值 $C_{\\text{lin}}(100) = 6.5$ 和 $P_{\\text{lin}}(100) = 6.5$。残差的第一项是：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = 6.5 - 6.5 = 0\n$$\n第二项，即在 $K^{\\ast}$ 处由看涨-看跌期权平价关系得出的理论价格差，是：\n$$\nS_0 \\exp(-q T) - K^{\\ast} \\exp(-r T) = 100 \\exp(-0 \\cdot 0.5) - 100 \\exp(-0 \\cdot 0.5) = 100 \\cdot 1 - 100 \\cdot 1 = 0\n$$\n将这些结果代入 $R$ 的定义中：\n$$\nR = 0 - 0 = 0\n$$\n\n这个结果并非是由于选择了特定的数值而偶然产生的。它阐明了线性算子的一个普遍性质。由于插值是一种线性操作，而看涨-看跌期权平价检验是价格的一个线性泛函，因此如果该性质在端点处成立，那么它对插值也同样成立。\n设插值权重为 $w = \\frac{K^{\\ast} - K_1}{K_2 - K_1}$。插值后的价格为：\n$$\nC_{\\text{lin}}(K^{\\ast}) = (1-w) C(K_1) + w C(K_2)\n$$\n$$\nP_{\\text{lin}}(K^{\\ast}) = (1-w) P(K_1) + w P(K_2)\n$$\n插值价格之差是端点差值的线性组合：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w) [C(K_1) - P(K_1)] + w [C(K_2) - P(K_2)]\n$$\n鉴于端点满足平价关系 $C(K) - P(K) = S_0 \\exp(-qT) - K \\exp(-rT)$，我们代入此关系：\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = (1-w)[S_0 e^{-qT} - K_1 e^{-rT}] + w[S_0 e^{-qT} - K_2 e^{-rT}]\n$$\n$$\n= S_0 e^{-qT} - [(1-w)K_1 + wK_2]e^{-rT}\n$$\n根据线性插值的定义，$K^{\\ast} = (1-w)K_1 + wK_2$。因此，\n$$\nC_{\\text{lin}}(K^{\\ast}) - P_{\\text{lin}}(K^{\\ast}) = S_0 e^{-qT} - K^{\\ast}e^{-rT}\n$$\n这表明，如果用于插值的输入数据是无套利的（即满足看涨-看跌期权平价关系），那么插值后的价格集合在同样意义上也是无套利的。因此，残差 $R$ 必须恒等于零。数值计算证实了这一普遍的理论结果。", "answer": "$$\\boxed{0}$$", "id": "2419232"}, {"introduction": "在现代期权定价中，隐含波动率并非一个常数，而是随执行价格变化，形成所谓的“波动率微笑”曲线。一种常见的做法是使用分段线性插值，根据少数几个市场观测点构建一条连续的波动率曲线。然而，这种看似简单的方法可能会带来意想不到的后果。这项高级练习 [@problem_id:2419249] 将指导你通过编程来检验，用这种方法构建的波动率微笑是否可能违反蝶式价差价格为正的无套利原则，从而揭示了量化建模中的一个关键陷阱。", "problem": "考虑一个单一到期日的欧式看涨期权市场，其参数包括现货价格 $S_0$、到期时间 $T$（以年为单位）、连续复利无风险利率 $r$ 以及连续股息率 $\\delta$。波动率微笑由一组有限的行权价-波动率节点 $\\{(K_i,\\sigma_i)\\}_{i=1}^m$ 定义，这些节点具有严格递增的行权价 $K_1  K_2  \\cdots  K_m$ 和对应的 Black–Scholes–Merton (BSM) 隐含波动率 $\\sigma_i  0$。对于任何满足 $K_1 \\le K \\le K_m$ 的行权价 $K$，通过节点上的分段线性插值定义隐含波动率函数 $\\sigma(K)$：\n- 对于 $K \\in [K_i, K_{i+1}]$，令 $\\sigma(K)$ 为在 $[K_i,K_{i+1}]$ 上满足 $\\sigma(K_i)=\\sigma_i$ 和 $\\sigma(K_{i+1})=\\sigma_{i+1}$ 的唯一仿射函数。\n不需要进行外插，因为所有用于评估的行权价都将位于 $[K_1,K_m]$ 区间内。\n\n对于任意行权价 $K$ 和波动率 $\\sigma(K)$，在零利率和零股息率的条件下，BSM 欧式看涨期权价格定义为\n$$\nC(K) \\equiv S_0 \\, \\Phi(d_1) - K \\, \\Phi(d_2),\n$$\n其中\n$$\nd_1 \\equiv \\frac{\\ln(S_0/K) + \\tfrac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}}, \n\\quad\nd_2 \\equiv d_1 - \\sigma(K)\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。在无套利设定下，看涨期权价格作为行权价的函数是凸函数，这意味着对于任何等间距的三个行权价 $K-h$、$K$、$K+h$ (其中 $h0$)，蝶式价差的价格\n$$\nB(K;h) \\equiv C(K-h) - 2\\,C(K) + C(K+h)\n$$\n必须是非负的。负值表示违反了蝶式价差价格必须为正的无套利条件（等价于在某个行权价上存在负的风险中性密度）。\n\n编写一个程序，对于以下每个测试用例，通过在所提供的节点上进行分段线性插值来构建 $\\sigma(K)$，在等间距的行权价格网格上计算 $C(K)$，评估内部网格点上的离散蝶式价差价格，并返回找到的最小蝶式价差价格。\n\n对所有测试用例使用以下固定的市场输入：\n- $S_0 = 100$\n- $T = 1$ (年)\n- $r = 0$\n- $\\delta = 0$\n\n对于每个测试用例：\n1. 令 $K_{\\min} \\equiv K_1$ 且 $K_{\\max} \\equiv K_m$。\n2. 构建一个包含 $N=81$ 个点的等间距行权价格网格 $\\{K_j\\}_{j=0}^{N-1}$，该网格覆盖区间 $[K_{\\min},K_{\\max}]$（含两端），使得 $K_0 = K_{\\min}$，$K_{N-1}=K_{\\max}$，并且对于所有的 $j$，$K_{j+1}-K_j$ 为常数。\n3. 使用 BSM 公式计算所有 $j=0,\\dots,N-1$ 的 $C(K_j)$，其中 $\\sigma(K_j)$ 通过分段线性插值定义。\n4. 对于每个内部索引 $j=1,\\dots,N-2$，计算离散蝶式价差价格\n$$\nB_j \\equiv C(K_{j-1}) - 2\\,C(K_j) + C(K_{j+1}).\n$$\n5. 报告最小蝶式价差价格\n$$\nb_{\\min} \\equiv \\min_{1 \\le j \\le N-2} B_j.\n$$\n返回保留六位小数的 $b_{\\min}$。\n\n测试套件（每个用例提供节点对 $\\{(K_i,\\sigma_i)\\}$）：\n- 用例 A（平坦微笑，一般正常路径）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.20),(85,0.20),(100,0.20),(115,0.20),(130,0.20)\\}.\n  $$\n- 用例 B（旨在违反无套利条件的尖峰微笑）：$(K,\\sigma)$ 节点\n  $$\n  \\{(70,0.15),(85,0.15),(100,0.90),(115,0.15),(130,0.15)\\}.\n  $$\n- 用例 C（具有最少节点和非均匀微笑的边界覆盖）：$(K,\\sigma)$ 节点\n  $$\n  \\{(80,0.18),(100,0.20),(120,0.22)\\}.\n  $$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含三个结果 $[b_{\\min}^{(A)}, b_{\\min}^{(B)}, b_{\\min}^{(C)}]$，形式为用方括号括起来的逗号分隔列表，每个值都四舍五入到六位小数（例如，“[0.012345,-0.001234,0.000000]”）。", "solution": "所提出的问题是计算金融领域中一个定义明确且有科学依据的练习，具体涉及期权市场中无套利条件的验证。所有必要的参数和定义都已提供，任务是实现一个明确指定的数值算法。因此，该问题被认为是有效的，并将提供完整的解决方案。\n\n需要测试的核心原理是欧式看涨期权价格相对于行权价的凸性。在无套利市场中，看涨期权价格函数 $C(K)$ 必须是关于行权价 $K$ 的凸函数。这意味着其二阶导数 $\\frac{\\partial^2 C}{\\partial K^2}$ 必须为非负。根据 Breeden-Litzenberger 公式，该二阶导数与标的资产在到期日 $T$ 的价格的风险中性概率密度函数直接相关：$\\frac{\\partial^2 C}{\\partial K^2} = e^{rT} p(S_T = K)$。该导数的负值将意味着负概率，这是存在套利机会的明确信号。\n\n二阶导数的一个离散近似是蝶式价差，对于一组三个行权价 $K-h$、$K$ 和 $K+h$（其中 $h0$）定义如下：\n$$ B(K;h) \\equiv C(K-h) - 2C(K) + C(K+h) $$\n无套利条件要求 $B(K;h) \\ge 0$。问题要求我们在一个离散的行权价格网格上，针对指定的波动率微笑检查此条件。\n\n过程如下：\n\n1.  **模型和参数设置**：我们得到了固定的市场参数：现货价格 $S_0 = 100$，到期时间 $T = 1$ 年，无风险利率 $r = 0$，股息率 $\\delta = 0$。在这些条件下，欧式看涨期权的 Black-Scholes-Merton (BSM) 价格为：\n    $$ C(K) = S_0 \\Phi(d_1) - K \\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数，项 $d_1$ 和 $d_2$ 为：\n    $$ d_1 = \\frac{\\ln(S_0/K) + \\frac{1}{2}\\sigma(K)^2 T}{\\sigma(K)\\sqrt{T}} $$\n    $$ d_2 = d_1 - \\sigma(K)\\sqrt{T} $$\n    隐含波动率 $\\sigma(K)$ 不是一个常数，而是行权价 $K$ 的函数。\n\n2.  **隐含波动率插值**：对于每个测试用例，波动率微笑由一组节点 $\\{(K_i, \\sigma_i)\\}_{i=1}^m$ 定义。对于 $[K_1, K_m]$ 范围内的任何行权价 $K$，$\\sigma(K)$ 的值由分段线性插值确定。如果 $K$ 位于区间 $[K_i, K_{i+1}]$ 内，其波动率由以下仿射函数给出：\n    $$ \\sigma(K) = \\sigma_i + \\frac{\\sigma_{i+1} - \\sigma_i}{K_{i+1} - K_i} (K - K_i) $$\n\n3.  **数值评估网格**：对于每个用例，我们定义一个评估范围 $[K_{\\min}, K_{\\max}]$，其中 $K_{\\min} = K_1$，$K_{\\max} = K_m$。在此范围上构建一个由 $N=81$ 个行权价组成的等间距网格 $\\{K_j\\}_{j=0}^{N-1}$，其中 $K_0=K_{\\min}$，$K_{N-1}=K_{\\max}$。\n\n4.  **看涨期权价格和蝶式价差的计算**：我们对每个测试用例按顺序进行一系列计算：\n    a. 对于网格上的每个行权价 $K_j$，我们首先使用分段线性插值函数计算相应的隐含波动率 $\\sigma(K_j)$。\n    b. 使用此 $\\sigma(K_j)$，我们计算 BSM 看涨期权价格 $C(K_j)$。这将得到一个看涨期权价格向量 $\\{C(K_j)\\}_{j=0}^{N-1}$。\n    c. 对于网格的每个内部点，索引 $j$ 从 $1$ 到 $N-2$，我们计算离散蝶式价差价格：\n       $$ B_j = C(K_{j-1}) - 2C(K_j) + C(K_{j+1}) $$\n    \n5.  **套利检测**：最后一步是找到所有计算出的蝶式价差中的最小值：\n    $$ b_{\\min} = \\min_{1 \\le j \\le N-2} B_j $$\n    $b_{\\min}$ 的负值表示违反了无套利条件，表明给定的波动率微笑与有效的风险中性密度不一致。对于用例 A（平坦微笑），我们预期 $b_{\\min} \\ge 0$，因为标准 BSM 模型是无套利的。对于用例 B（尖峰微笑），已知波动率函数中的极端凸性可能导致看涨期权价格函数的非凸性，因此我们可能会发现 $b_{\\min}  0$。用例 C 呈现了一个更现实的、有斜率的微笑，其无套利性必须通过数值方法进行验证。\n\n该实现将利用 `scipy.interpolate.interp1d` 来实现波动率函数，利用 `scipy.stats.norm.cdf` 来实现函数 $\\Phi$。所有的向量和矩阵运算将由 `numpy` 处理以提高效率。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\nfrom scipy.interpolate import interp1d\n\ndef solve():\n    \"\"\"\n    Computes the minimum butterfly spread price for different volatility smiles\n    to check for arbitrage.\n    \"\"\"\n    # Fixed market inputs for all test cases\n    S0 = 100.0\n    T = 1.0\n    # r = 0, delta = 0 are implicitly used in the simplified BSM formula.\n\n    # Grid parameters\n    N = 81\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: flat smile\n        [\n            (70.0, 0.20), (85.0, 0.20), (100.0, 0.20), (115.0, 0.20), (130.0, 0.20)\n        ],\n        # Case B: spiky smile\n        [\n            (70.0, 0.15), (85.0, 0.15), (100.0, 0.90), (115.0, 0.15), (130.0, 0.15)\n        ],\n        # Case C: sloped smile\n        [\n            (80.0, 0.18), (100.0, 0.20), (120.0, 0.22)\n        ],\n    ]\n\n    def bsm_call_price(K, sigma_K):\n        \"\"\"\n        Calculates the BSM European call price for r=0, delta=0.\n        K and sigma_K can be numpy arrays.\n        \"\"\"\n        # Handle cases where sigma_K might be zero or K is zero to avoid division by zero or log(0)\n        # However, problem constraints (sigma_i > 0, K_i > 0) make this unlikely\n        # for interpolated values. Add a small epsilon for robustness.\n        epsilon = 1e-12\n        sigma_K = np.maximum(sigma_K, epsilon)\n        K = np.maximum(K, epsilon)\n\n        d1 = (np.log(S0 / K) + 0.5 * sigma_K**2 * T) / (sigma_K * np.sqrt(T))\n        d2 = d1 - sigma_K * np.sqrt(T)\n        \n        price = S0 * norm.cdf(d1) - K * norm.cdf(d2)\n        return price\n\n    results = []\n    for nodes in test_cases:\n        # 1. Unpack nodes and create interpolator for sigma(K)\n        strikes_nodes, vols_nodes = zip(*nodes)\n        \n        # Use scipy's linear interpolation. fill_value is not needed as we\n        # stay within the bounds defined by the nodes.\n        sigma_func = interp1d(\n            strikes_nodes, vols_nodes, kind='linear', bounds_error=True\n        )\n\n        # 2. Construct the equally spaced strike grid\n        K_min = strikes_nodes[0]\n        K_max = strikes_nodes[-1]\n        K_grid = np.linspace(K_min, K_max, N)\n\n        # 3. Compute C(K_j) for all j\n        # First, compute interpolated volatilities on the grid\n        sigma_grid = sigma_func(K_grid)\n        # Then, compute call prices on the grid\n        C_grid = bsm_call_price(K_grid, sigma_grid)\n        \n        # 4. Compute discrete butterfly spread prices\n        # B_j = C(K_{j-1}) - 2*C(K_j) + C(K_{j+1})\n        # This can be vectorized using numpy slicing\n        butterfly_spreads = C_grid[:-2] - 2 * C_grid[1:-1] + C_grid[2:]\n\n        # 5. Report the minimum butterfly spread price\n        b_min = np.min(butterfly_spreads)\n        \n        # Round to six decimal places as required\n        results.append(round(b_min, 6))\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2419249"}]}