{"hands_on_practices": [{"introduction": "掌握索洛增长模型的数值求解，第一步是计算其长期均衡，即稳态。此练习 [@problem_id:2393421] 将指导你如何将稳态条件转化为一个不动点问题 $k^* = T(k^*)$，并应用基础的不动点迭代法来找到数值解。这不仅能加深你对模型核心机制的理解，也是掌握计算经济学基本工具的绝佳起点。", "problem": "给定一个连续时间索洛增长模型，其中包含外生的人口增长、技术增长和折旧。人均有效资本的稳态由净投资为零的均衡条件所刻画 ($\\dot{k}=0$)。您的任务是从这个稳态条件出发，构建一个不动点问题，其解为人均有效资本的稳态存量，并通过不动点迭代 (FPI) 进行数值求解。\n\n使用以下核心定义作为基础：\n- 稳态定义为净投资为零的条件，即人均有效资本的时间导数为零。\n- 总产出由一个二阶连续可微、严格递增且凹的人均有效生产函数产生。为确保测试套件的具体性，此处将使用带有参数化弹性的柯布-道格拉斯生产函数。\n- 储蓄是产出的一个固定比例，有效折旧率是人口增长、技术增长和物质折旧之和。\n\n你的任务：\n1. 仅使用上述基本定义，从稳态条件中推导出不动点映射。解释你将计算其不动点的数学对象，并说明在给定假设下为何在紧凸集上存在不动点。\n2. 实现一个不动点迭代算法，对于给定的参数，从一个严格为正的初始猜测开始迭代，直到满足收敛准则。\n3. 使用基于不动点残差的停止法则。具体而言，设迭代值为 $k_{t}$，映射为 $T(k)$。当 $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$ 时停止，容差 $\\varepsilon$ 见下文规定。\n4. 使用最大迭代次数保护，以保证在未达到容差时程序能够终止。\n\n数值要求：\n- 使用容差 $\\varepsilon = 10^{-12}$。\n- 对所有测试用例使用统一的初始猜测 $k_{0} = 1.0$。\n- 如果储蓄为零，直接返回映射所隐含的稳态值，无需迭代。\n- 如果任何参数集导致非正的有效折旧项，请勿尝试迭代；而是返回一个非数值标志值。为具体起见，在这种情况下返回浮点非数值 (`NaN`)。\n\n测试套件的模型设定：\n- 生产函数为柯布-道格拉斯形式 $f(k) = A k^{\\alpha}$。\n- 储蓄率为 $s \\in [0,1]$。\n- 有效折旧项为 $\\nu = n + g + \\delta$，其中人口增长率 $n \\ge 0$，技术增长率 $g \\ge 0$，折旧率 $\\delta \\ge 0$。\n\n对于每个参数元组 $(A,\\alpha,s,n,g,\\delta)$，使用不动点迭代（FPI）和你推导的映射，根据上述要求计算稳态 $k^{\\star}$。将结果报告为浮点数，四舍五入到小数点后六位。\n\n测试套件：\n- 情况 1：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.3, 0.25, 0.01, 0.02, 0.08)$。\n- 情况 2：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.5, 0.10, 0.02, 0.02, 0.06)$。\n- 情况 3：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.3, 0.00, 0.02, 0.01, 0.07)$。\n- 情况 4：$(A,\\alpha,s,n,g,\\delta) = (0.8, 0.8, 0.30, 0.03, 0.01, 0.04)$。\n- 情况 5：$(A,\\alpha,s,n,g,\\delta) = (1.0, 0.9, 0.20, 0.01, 0.02, 0.07)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果的顺序与测试用例相同，例如 $[\\text{结果}_{1},\\text{结果}_{2},\\dots]$。\n- 每个 $\\text{结果}_{i}$ 必须是四舍五入到小数点后六位的浮点数。", "solution": "在尝试求解之前，对问题陈述进行验证。\n\n**步骤 1：提取给定信息**\n- **模型**：单部门索洛增长模型，包含外生人口增长 $n \\ge 0$、技术增长 $g \\ge 0$ 和折旧 $\\delta \\ge 0$。\n- **生产函数**：一个二阶连续可微、严格递增且凹的人均有效生产函数 $f(k)$。对于测试套件，这是柯布-道格拉斯函数 $f(k) = A k^{\\alpha}$。\n- **储蓄**：产出的一个固定比例 $s \\in [0,1]$。\n- **有效折旧**：有效折旧率为 $\\nu = n + g + \\delta$。\n- **稳态定义**：下一期人均有效资本等于当期人均有效资本的状态，这意味着人均有效资本的基本微分方程 $\\dot{k}$ 为零。\n- **任务**：为人均有效资本的稳态 $k^{\\star}$ 构建一个不动点问题，并使用不动点迭代 (FPI) 进行求解。\n- **不动点映射**：必须从稳态条件 $s f(k) = \\nu k$ 推导得出。\n- **算法**：从初始猜测 $k_{0} = 1.0$ 开始的不动点迭代。\n- **停止法则**：对 $k_t$ 使用映射 $T(k)$ 的迭代在 $\\lvert T(k_{t}) - k_{t} \\rvert \\le \\varepsilon \\cdot \\max\\{1,\\lvert k_{t} \\rvert\\}$ 时终止。\n- **数值参数**：容差 $\\varepsilon = 10^{-12}$；初始猜测 $k_{0} = 1.0$。必须使用最大迭代保护。\n- **特殊情况**：\n    - 如果 $s = 0$，返回稳态值，无需迭代。\n    - 如果 $\\nu \\le 0$，返回一个非数值 (`NaN`) 值。\n- **测试套件**：提供了五个参数元组 $(A,\\alpha,s,n,g,\\delta)$。\n    - 情况 1：$(1.0, 0.3, 0.25, 0.01, 0.02, 0.08)$。\n    - 情况 2：$(1.0, 0.5, 0.10, 0.02, 0.02, 0.06)$。\n    - 情况 3：$(1.0, 0.3, 0.00, 0.02, 0.01, 0.07)$。\n    - 情况 4：$(0.8, 0.8, 0.30, 0.03, 0.01, 0.04)$。\n    - 情况 5：$(1.0, 0.9, 0.20, 0.01, 0.02, 0.07)$。\n\n**步骤 2：使用提取的信息进行验证**\n- **科学基础**：该问题基于索洛-斯旺模型，这是宏观经济学中一个基础且完善的框架。使用柯布-道格拉斯生产函数以及通过不动点问题推导稳态是标准的教科书程序。该问题在科学上是合理的。\n- **适定性**：该问题是适定的。对于给定的参数约束（$0  \\alpha  1$、$s > 0$、$\\nu > 0$），模型保证存在唯一、非平凡且稳定的稳态资本存量。问题提供了所有必要信息和明确的目标。\n- **客观性**：该问题使用精确、客观、形式化的数学和经济学语言陈述。没有主观或含糊的表述。\n\n**步骤 3：结论与行动**\n该问题是有效的。这是一个计算经济学中的标准、定义明确的问题，具有科学依据且内部一致。将提供完整解答。\n\n**不动点映射的推导与解的存在性**\n\n设 $k$ 为人均有效资本。在连续时间索洛模型中，$k$ 的基本运动方程由以下微分方程给出：\n$$ \\dot{k} = s f(k) - (n + g + \\delta)k $$\n其中 $s f(k)$ 代表人均有效总投资，$(n + g + \\delta)k$ 代表人均有效折旧。项 $\\nu = n + g + \\delta$ 是有效折旧率，它包括了物质折旧 ($\\delta$)、因人口增长 ($n$) 导致的资本稀释，以及因技术进步 ($g$) 导致的资本稀释。\n\n稳态，记为 $k^{\\star}$，是一个均衡点，在该点人均有效资本存量恒定，即 $\\dot{k} = 0$。这得出了稳态条件：\n$$ s f(k^{\\star}) = \\nu k^{\\star} $$\n在 $\\nu > 0$ 的前提下，我们可以重排此方程以定义一个不动点问题。函数 $T(k)$ 的不动点是一个值 $k^{\\star}$，使得 $T(k^{\\star}) = k^{\\star}$。我们可以从我们的稳态条件定义这样一个函数 $T(k)$：\n$$ k^{\\star} = \\frac{s}{\\nu} f(k^{\\star}) $$\n因此，我们必须计算其不动点的数学对象是由以下公式定义的映射 $T: \\mathbb{R}_+ \\to \\mathbb{R}_+$：\n$$ T(k) = \\frac{s}{\\nu} f(k) $$\n对于特定的柯布-道格拉斯生产函数 $f(k) = A k^{\\alpha}$，该映射变为：\n$$ T(k) = \\left( \\frac{sA}{\\nu} \\right) k^{\\alpha} $$\n在特定条件下，布劳威尔不动点定理保证了在紧凸集上存在不动点。该定理指出，任何将一个紧、凸、非空集合映射到其自身的连续函数，都至少有一个不动点。\n\n我们来分析在 $s>0$、$\\nu>0$、$A>0$ 和 $0  \\alpha  1$ 的假设下，对于 $k \\ge 0$ 的映射 $T(k)$。\n1. 我们感兴趣的定义域是 $k \\in [0, \\infty)$。函数 $T(k)$ 在此定义域上是连续的。\n2. 我们需要找到一个紧凸集 $D \\subset [0, \\infty)$ 使得 $T(D) \\subseteq D$。设 $D = [k_{min}, k_{max}]$，其中 $0  k_{min}  k_{max}$。\n3. 生产函数的标准稻田条件，对于 $0  \\alpha  1$ 的柯布-道格拉斯形式是满足的，即 $\\lim_{k \\to 0} f'(k) = \\infty$ 和 $\\lim_{k \\to \\infty} f'(k) = 0$。\n4. 关于 $f'(k)$ 的这些条件意味着 $T(k)$ 的斜率，即 $T'(k) = \\frac{s}{\\nu} f'(k)$，在 $k \\to 0$ 时也趋于无穷大，在 $k \\to \\infty$ 时趋于零。\n5. 条件 $\\lim_{k \\to 0} T'(k) = \\infty$ 确保对于足够小的 $k_{min} > 0$，$T(k)$ 的图像比直线 $y=k$ 更陡峭，这意味着 $T(k_{min}) > k_{min}$。\n6. 条件 $\\lim_{k \\to \\infty} T'(k) = 0$ 确保对于足够大的 $k_{max}$，$T(k)$ 的图像比直线 $y=k$ 更平坦，这意味着 $T(k_{max})  k_{max}$。\n7. 由于 $T(k)$ 是一个连续函数，我们可以将介值定理应用于区间 $[k_{min}, k_{max}]$ 上的函数 $g(k) = T(k) - k$。由于 $g(k_{min}) > 0$ 且 $g(k_{max})  0$，必定存在至少一个点 $k^{\\star} \\in (k_{min}, k_{max})$ 使得 $g(k^{\\star}) = 0$，这意味着 $T(k^{\\star}) = k^{\\star}$。这就证明了不动点的存在性。对于 $0  \\alpha  1$，$T(k)$ 是严格凹函数，这保证了正不动点 $k^{\\star}$ 是唯一的。\n\n**算法实现**\n\n不动点迭代 (FPI) 算法使用递推关系 $k_{t+1} = T(k_t)$ 生成一个序列 $\\{k_t\\}_{t=0}^\\infty$。根据 $T(k)$ 的性质，对于任何初始猜测 $k_0 > 0$，该序列保证收敛到唯一的正不动点 $k^{\\star}$。\n\n算法如下：\n1. 对于给定的参数集 $(A, \\alpha, s, n, g, \\delta)$，首先计算有效折旧 $\\nu = n+g+\\delta$。\n2. 处理特殊情况：如果 $\\nu \\le 0$，模型定义不当；返回 `NaN`。如果 $s = 0$，投资为零，因此稳态为 $k^{\\star} = 0$；返回 $0.0$。\n3. 使用 $k_t = k_0 = 1.0$ 初始化迭代。\n4. 在一个循环中，计算下一个迭代值 $k_{t+1} = T(k_t) = (s A k_{t}^{\\alpha}) / \\nu$。\n5. 使用指定的停止法则检查收敛性：$\\lvert k_{t+1} - k_t \\rvert \\le \\varepsilon \\cdot \\max\\{1, \\lvert k_t \\rvert\\}$，其中 $\\varepsilon = 10^{-12}$。\n6. 如果满足条件，则迭代已收敛。返回 $k_{t+1}$。\n7. 如果不满足条件，更新 $k_t \\leftarrow k_{t+1}$ 并继续下一次迭代。\n8. 必须设定最大迭代次数，以保证在不收敛的情况下程序能够终止，尽管对于给定的测试用例，预计会收敛。", "answer": "```python\nimport numpy as np\n\ndef solve_fpi(params):\n    \"\"\"\n    Computes the steady-state capital per effective worker ($k^*$) for the Solow model\n    using Fixed Point Iteration.\n\n    Args:\n        params (tuple): A tuple containing the model parameters (A, alpha, s, n, g, delta).\n\n    Returns:\n        float: The steady-state capital k*, or np.nan if the model is ill-defined.\n    \"\"\"\n    A, alpha, s, n, g, delta = params\n    \n    # Calculate the effective depreciation rate\n    nu = n + g + delta\n    \n    # Handle special case: non-positive effective depreciation\n    if nu = 0:\n        return np.nan\n        \n    # Handle special case: zero savings rate\n    # If s = 0, T(k) = 0 for all k, so the fixed point is k* = 0.\n    if s == 0.0:\n        return 0.0\n\n    # FPI parameters\n    k_curr = 1.0  # Initial guess k_0\n    eps = 1e-12   # Tolerance\n    max_iter = 5000 # Maximum iteration safeguard\n\n    for _ in range(max_iter):\n        # Apply the fixed-point map T(k) = (s * A * k^alpha) / nu\n        try:\n            k_next = (s * A * (k_curr ** alpha)) / nu\n        except (ValueError, OverflowError):\n            # Handle potential numerical errors for very large k\n            return np.nan\n\n        # Check for convergence using the specified mixed absolute/relative tolerance\n        if abs(k_next - k_curr) = eps * max(1.0, abs(k_curr)):\n            return k_next\n        \n        # Update for the next iteration\n        k_curr = k_next\n\n    # If max_iter is reached without convergence, return the last computed value\n    # as a best-effort result, though this case is not expected for the given tests.\n    return k_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        # (A, alpha, s, n, g, delta)\n        (1.0, 0.3, 0.25, 0.01, 0.02, 0.08),  # Case 1\n        (1.0, 0.5, 0.10, 0.02, 0.02, 0.06),  # Case 2\n        (1.0, 0.3, 0.00, 0.02, 0.01, 0.07),  # Case 3\n        (0.8, 0.8, 0.30, 0.03, 0.01, 0.04),  # Case 4\n        (1.0, 0.9, 0.20, 0.01, 0.02, 0.07),  # Case 5\n    ]\n    \n    results = []\n    for case in test_cases:\n        k_star = solve_fpi(case)\n        results.append(k_star)\n\n    # Format results to six decimal places for printing\n    formatted_results = []\n    for res in results:\n        if np.isnan(res):\n            formatted_results.append('nan')\n        else:\n            formatted_results.append(f\"{res:.6f}\")\n\n    # Print the final output in the specified format\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393421"}, {"introduction": "经济模型常常需要超越标准假设，例如使用比柯布-道格拉斯函数更具一般性的恒定替代弹性（CES）生产函数。在这种情况下，简单的`不动点迭代`可能不再适用，我们需要更强大的求根算法。此练习 [@problem_id:2443698] 将向你介绍如何将稳态求解问题构建为一个求根问题 $F(k)=0$，并利用高效的割线法来解决它，从而提升你处理复杂非线性经济模型的能力。", "problem": "考虑一个连续时间索洛增长模型，该模型包含哈罗德中性技术进步，其中每个效率单位的总产出由一个恒定替代弹性 (CES) 生产函数给出。令 $k$ 表示每个效率单位劳动力的资本存量，$y$ 表示每个效率单位的产出，$s \\in (0,1)$ 表示恒定的储蓄率，$n \\ge 0$ 表示人口增长率，$g \\ge 0$ 表示劳动力增强型技术进步率，$\\delta \\in (0,1)$ 表示折旧率。在稳态下，每个效率单位的资本存量 $k^{\\ast}$ 满足以下条件\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}.\n$$\n假设单位效率生产函数 $f(k)$ 是 CES 形式，其分配参数为 $\\theta \\in (0,1)$，替代弹性为 $\\sigma  0$，定义如下：\n$$\nf(k) = \\begin{cases} \\left[\\theta k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}  \\text{if } \\rho \\neq 0 \\\\ k^{\\theta}  \\text{if } \\rho = 0 \\end{cases}, \\quad \\text{where} \\quad \\rho \\equiv \\frac{\\sigma - 1}{\\sigma}.\n$$\n定义稳态残差函数\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k.\n$$\n稳态 $k^{\\ast}$ 是任何满足 $F(k^{\\ast}) = 0$ 的正值 $k^{\\ast}  0$。\n\n您的任务是编写一个完整、可运行的程序，针对下方的每个测试用例，仅使用所提供的信息，计算 $k^{\\ast}$ 的一个数值近似解 $\\widehat{k}$，该解满足方程 $F(\\widehat{k}) = 0$，绝对误差容忍度在 $10^{-10}$ 以内。对于每个测试用例，请将所列的一对正值作为 $k$ 的两个起始值来初始化您的计算。如果某个测试用例在给定参数下没有正解，或者您的计算未能在有限步数内达到容忍度要求，您仍必须输出一个数值；然而，在本作业中，所有提供的用例都构造为具有唯一的正解。\n\n测试集（每行是一个测试用例，参数为 $(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1})$）：\n- 用例 A：$(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000)$\n- 用例 B：$(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000)$\n- 用例 C：$(s, n, g, \\delta, \\theta, \\sigma, k_{0}, k_{1}) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)$\n\n程序要求：\n- 对于每个测试用例，计算唯一正稳态 $k^{\\ast}$ 的数值近似解 $\\widehat{k}$，使得 $|F(\\widehat{k})| \\le 10^{-10}$。\n- 使用如上定义的 CES 函数，其中 $\\rho = (\\sigma - 1)/\\sigma$，并在 $\\rho = 0$ 时使用科布-道格拉斯极限形式 $f(k) = k^{\\theta}$。\n- 输出格式：您的程序应生成单行输出，其中包含三个结果，形式为方括号内的逗号分隔列表，每个 $\\widehat{k}$ 四舍五入到小数点后 $10$ 位（例如，$[x_{A},x_{B},x_{C}]$，其中每个 $x_{\\cdot}$ 是一个小数点后恰好有 $10$ 位数字的浮点数）。", "solution": "该问题要求计算索洛增长模型中每个效率单位的稳态资本存量 $k^{\\ast}$，该模型使用恒定替代弹性 (CES) 生产函数。稳态被定义为满足均衡条件的正值 $k^{\\ast}  0$：\n$$\ns\\, f(k^{\\ast}) = (n+g+\\delta)\\, k^{\\ast}\n$$\n通过定义残差函数 $F(k)$，该方程可以被重构为一个求根问题：\n$$\nF(k) \\equiv s\\, f(k) - (n+g+\\delta)\\, k\n$$\n目标是找到一个数值近似解 $\\widehat{k}$ 使得 $F(\\widehat{k}) = 0$。更确切地说，我们寻求一个值 $\\widehat{k}$，其残差的绝对值小于或等于指定的容忍度，即 $|F(\\widehat{k})| \\le 10^{-10}$。\n\n每个效率单位的生产函数 $f(k)$ 是 CES 类型，定义如下：\n$$\nf(k) = \\begin{cases} \\left[\\theta k^{\\rho} + (1-\\theta)\\right]^{1/\\rho}  \\text{if } \\rho \\neq 0 \\\\ k^{\\theta}  \\text{if } \\rho = 0 \\end{cases}\n$$\n其中参数 $\\rho$ 与替代弹性 $\\sigma$ 通过公式 $\\rho = (\\sigma - 1)/\\sigma$ 相关联。每个测试用例的参数 $s$、$n$、$g$、$\\delta$、$\\theta$ 和 $\\sigma$ 均已给出，并且都在其理论有效范围内。\n\n对于每个用例，问题提供了两个关于 $k$ 的初始近似值，我们记为 $k_0$ 和 $k_1$。这种结构表明适合使用两点迭代法。我们将采用割线法，这是一种解决此类非线性方程的成熟且通常高效的求根算法。\n\n割线法生成一个近似序列 $\\{k_i\\}_{i=0}^{\\infty}$，在适当条件下，该序列收敛于根 $k^{\\ast}$。给定两个初始点 $k_{i-1}$ 和 $k_i$，序列中的下一个点 $k_{i+1}$ 是连接点 $(k_{i-1}, F(k_{i-1}))$ 和 $(k_i, F(k_i))$ 的割线与横轴交点的横坐标。迭代公式如下：\n$$\nk_{i+1} = k_i - F(k_i) \\frac{k_i - k_{i-1}}{F(k_i) - F(k_{i-1})}\n$$\n计算算法的步骤如下：\n1. 使用相应测试用例中提供的值初始化前两个迭代点 $k_0$ 和 $k_1$。\n2. 计算这些点上的函数值，$F_0 = F(k_0)$ 和 $F_1 = F(k_1)$。\n3. 对于每次迭代 $i=1, 2, 3, \\dots$：\n   a. 检查分母 $F(k_i) - F(k_{i-1})$ 是否足够远离零以避免数值不稳定。如果它接近于零，则该方法的进展会停滞，应返回当前的最佳估计值。\n   b. 使用割线法公式计算下一个近似值 $k_{i+1}$。\n   c. 计算新的残差 $F(k_{i+1})$。\n   d. 检查收敛性：如果 $|F(k_{i+1})| \\le 10^{-10}$，算法终止，并将解取为 $\\widehat{k} = k_{i+1}$。\n   e. 否则，通过设置 $k_{i-1} \\leftarrow k_i$ 和 $k_i \\leftarrow k_{i+1}$ 来更新迭代值以进行下一步。\n4. 为保证终止，设置了最大迭代次数。由于问题陈述保证了收敛，这可以作为通用实现的一种保障措施。\n\n对于每个测试用例，使用特定的参数 $(s, n, g, \\delta, \\theta, \\sigma)$ 来定义函数 $F(k)$ 的具体形式。然后，应用割线法和相应的初始值 $(k_0, k_1)$ 来找到满足容忍度要求的根 $\\widehat{k}$。对于所有提供的测试用例，$\\sigma$ 的值不等于 $1$，因此 $\\rho \\ne 0$，并且适用 CES 函数的一般形式。\n\n函数 $F(k)$ 的具体参数化如下：\n- 用例 A：$(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 0.800)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 用例 B：$(s, n, g, \\delta, \\theta, \\sigma) = (0.200, 0.010, 0.020, 0.050, 0.400, 1.500)$。项 $(n+g+\\delta)$ 等于 $0.080$。\n- 用例 C：$(s, n, g, \\delta, \\theta, \\sigma) = (0.250, 0.015, 0.020, 0.050, 0.300, 0.990)$。项 $(n+g+\\delta)$ 等于 $0.085$。\n\n以下程序实现了此数值过程，以求解每个用例的 $\\widehat{k}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves for the steady-state capital per efficiency unit for a set of test cases\n    using the secant method.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each tuple contains: (s, n, g, delta, theta, sigma, k0, k1)\n    test_cases = [\n        (0.200, 0.010, 0.020, 0.050, 0.400, 0.800, 0.100, 50.000),\n        (0.200, 0.010, 0.020, 0.050, 0.400, 1.500, 0.100, 20.000),\n        (0.250, 0.015, 0.020, 0.050, 0.300, 0.990, 1.000, 10.000)\n    ]\n\n    TOLERANCE = 1e-10\n    MAX_ITER = 100\n\n    def F_residual(k, s, n, g, delta, theta, sigma):\n        \"\"\"\n        Computes the steady-state residual function F(k).\n        F(k) = s*f(k) - (n+g+delta)*k\n        \n        The function assumes k > 0.\n        \"\"\"\n        # CES production function f(k)\n        if np.isclose(sigma, 1.0):\n            # Cobb-Douglas case: f(k) = k^theta\n            # This case is included for completeness but not used by the test data.\n            f_k = np.power(k, theta)\n        else:\n            # General CES case\n            rho = (sigma - 1.0) / sigma\n            # Use numpy.power for robust floating-point exponentiation.\n            f_k = np.power(theta * np.power(k, rho) + (1.0 - theta), 1.0 / rho)\n        \n        # Effective depreciation rate, which is the slope of the break-even investment line.\n        effective_depreciation = n + g + delta\n        \n        return s * f_k - effective_depreciation * k\n\n    def secant_solver(params, k0, k1):\n        \"\"\"\n        Finds the root of F_residual using the secant method.\n        The function takes a tuple of parameters and two initial guesses.\n        \"\"\"\n        s, n, g, delta, theta, sigma = params\n        \n        k_prev, k_curr = float(k0), float(k1)\n\n        f_prev = F_residual(k_prev, s, n, g, delta, theta, sigma)\n        f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n        \n        for _ in range(MAX_ITER):\n            if abs(f_curr) = TOLERANCE:\n                return k_curr\n\n            # Calculate the denominator for the secant update.\n            delta_f = f_curr - f_prev\n            \n            # If the change in function value is negligible, the method cannot proceed.\n            # Return the current best guess. This is unlikely given the problem's guarantees.\n            if np.isclose(delta_f, 0.0):\n                return k_curr\n            \n            # Secant method update formula.\n            k_next = k_curr - f_curr * (k_curr - k_prev) / delta_f\n            \n            # Update iterates for the next step.\n            k_prev, f_prev = k_curr, f_curr\n            k_curr = k_next\n            f_curr = F_residual(k_curr, s, n, g, delta, theta, sigma)\n            \n        # As per problem instructions, return the last computed value if max iterations are reached.\n        return k_curr\n\n    results = []\n    for case in test_cases:\n        # Unpack parameters and initial guesses for the solver.\n        params_tuple = case[:6]  # s, n, g, delta, theta, sigma\n        k_init_0, k_init_1 = case[6], case[7]\n        \n        # Compute the steady-state capital.\n        k_star_approx = secant_solver(params_tuple, k_init_0, k_init_1)\n        \n        # Format the result to 10 decimal places.\n        results.append(f\"{k_star_approx:.10f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2443698"}, {"introduction": "经济体的长期稳态固然重要，但其向稳态过渡的动态路径对于理解经济冲击和政策效果更为关键。本练习 [@problem_id:2416228] 将挑战你解决一个更高级的问题：给定一个未来的资本存量目标，如何找到实现该目标所需的初始资本水平？你将学习并实践打靶算法，这是一种巧妙结合了常微分方程（ODE）求解器和求根算法的强大技术，用于解决经济学中常见的两点边值问题。", "problem": "您需要编写一个完整、可运行的程序，使用打靶算法数值求解连续时间 Solow 增长模型中的人均有效资本问题，以满足在固定时间范围内的终端条件，而不是从给定的初始条件向前步进。该程序必须实现以下数学设定和要求。\n\n考虑人均有效资本 $k(t)$ 的连续时间 Solow 模型，该模型源自具有 Cobb–Douglas 生产函数以及外生人口和技术增长的标准 Solow 模型。设储蓄率 $s \\in (0,1)$ 为常数，资本折旧率 $\\delta \\ge 0$，人口增长率 $n \\ge 0$，技术增长率 $g \\ge 0$，人均有效产出生产函数为 $f(k) = k^{\\alpha}$（其中 $\\alpha \\in (0,1)$），则人均有效资本的运动方程为以下一阶自治常微分方程 (ODE)：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t).\n$$\n根据模型设定，$k(t) \\ge 0$ 对所有 $t \\ge 0$ 成立。稳态 $k^{\\ast}$ 满足：\n$$\n0 = s \\, (k^{\\ast})^{\\alpha} - (n+g+\\delta)\\,k^{\\ast}.\n$$\n\n您的任务是实现一个打靶算法，以找到初始条件 $k(0) = k_0$，使得该 ODE 的解 $k(t)$ 在一个固定的有限时间 $T  0$ 满足终端条件：\n$$\nk(T; k_0) = \\bar{k},\n$$\n其中 $\\bar{k}  0$ 是给定的目标终端人均有效资本。该打靶算法必须：\n- 定义打靶函数 $\\phi(k_0) = k(T; k_0) - \\bar{k}$。\n- 对于任意给定的 $k_0$，通过从 $t=0$ 到 $t=T$ 对 ODE 进行时间上的前向数值积分，以计算 $k(T; k_0)$。\n- 对 $\\phi(k_0)$ 使用一种稳健的、带区间限定的一维求根方法，以在适用于双精度计算的数值容差内确定 $k_0$，使得 $\\phi(k_0) = 0$。\n\n推导和算法设计允许使用的基本依据：\n- 上述给出的、带有 Cobb–Douglas 生产函数 $f(k)=k^{\\alpha}$ 的 $k(t)$ 运动方程。\n- 稳态的定义、右端项为 Lipschitz 连续的 ODE 解的存在性和唯一性，以及右端项连续的标量自治 ODE 解的单调性（保序性）。\n\n实现细节和数值要求：\n- 使用高精度 ODE 积分器。在相关情况下，应选择合适的容差以确保终端条件在很小的误差范围内得到满足。\n- 实现一种区间扩展策略，以确保在调用区间求根求解器之前，$\\phi(k_0)$ 的根已被置于一个区间内。您的方法必须能够防止失败，通过几何级数方式扩展区间，直到观察到函数值的符号发生变化或达到一个合理的上限。\n- 确保 $k(t)$ 保持非负；您必须将 $k_0$ 初始化为正数，并相应地选择区间值。\n- 在为参数集计算稳态 $k^{\\ast}$ 时，使用代数条件 $s \\, (k^{\\ast})^{\\alpha} = (n+g+\\delta)\\,k^{\\ast}$，注意当 $s  0$ 且 $n+g+\\delta  0$ 时，$k^{\\ast}  0$。在您的程序中，应将其表示为参数的函数，而不是在问题陈述中以闭式形式给出。\n\n测试套件：\n您的程序必须为以下四个参数集中的每一个计算 $k_0$。对于每种情况，目标终端资本 $\\bar{k}$ 都是根据相同参数下的稳态 $k^{\\ast}$ 来指定的。所有标量都必须视为无量纲。\n\n- 情况 A (基准稳态目标):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 5.0$, $\\bar{k} = k^{\\ast}$。\n- 情况 B (低于稳态的目标，较短时间范围):\n  - $\\alpha = 0.33$, $s = 0.25$, $n = 0.01$, $g = 0.02$, $\\delta = 0.05$, $T = 2.0$, $\\bar{k} = 0.5 \\times k^{\\ast}$。\n- 情况 C (无人口或技术增长，高于稳态的目标，较长时间范围):\n  - $\\alpha = 0.40$, $s = 0.15$, $n = 0.0$, $g = 0.0$, $\\delta = 0.07$, $T = 10.0$, $\\bar{k} = 1.2 \\times k^{\\ast}$。\n- 情况 D (较高储蓄率，短时间范围，略低于稳态):\n  - $\\alpha = 0.33$, $s = 0.35$, $n = 0.02$, $g = 0.01$, $\\delta = 0.04$, $T = 1.0$, $\\bar{k} = 0.9 \\times k^{\\ast}$。\n\n输出规格：\n- 对于每种情况，计算在时间 $T$ 达到终端条件所需的初始人均有效资本 $k_0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 [情况 A, 情况 B, 情况 C, 情况 D]。\n- 每个数字必须四舍五入到六位小数。\n- 格式示例（仅供参考）：$[1.234567,0.500000,3.210000,0.987654]$。\n\n约束和期望：\n- 您的解决方案必须是完全数值化的：不要使用 ODE 的闭式解或任何绕过数值积分和求根的变换。\n- 算法应对所提供的参数集具有稳健性，并且在解存在时应能可靠地找到 $k_0$。\n- 所有数值输出必须是浮点数。不打印百分比。不涉及角度单位。", "solution": "所提出的问题是描述 Solow-Swan 增长模型的一阶自治常微分方程 (ODE) 的一个适定两点边值问题。它在既定的经济理论中有科学依据，并且在数学上是合理的。所有参数和条件都已指定，从而允许存在一个唯一且有意义的解。因此，该问题被认为是有效的。我们继续推导数值解。\n\n问题的核心是找到一个初始状态，即人均有效资本 $k(0) = k_0$，使得系统轨迹在一个有限时间 $T  0$ 到达指定的终端状态 $\\bar{k}$。其动态由以下 ODE 控制：\n$$\n\\frac{dk(t)}{dt} = s \\, k(t)^{\\alpha} - (n+g+\\delta)\\,k(t)\n$$\n其中 $k(t) \\ge 0$，储蓄率 $s \\in (0,1)$，资本的产出弹性 $\\alpha \\in (0,1)$，有效折旧率是人口增长率 $n \\ge 0$、技术进步率 $g \\ge 0$ 和资本折旧率 $\\delta \\ge 0$ 的总和。令 $\\lambda = n+g+\\delta$。则 ODE 为：\n$$\n\\frac{dk}{dt} = s k^{\\alpha} - \\lambda k\n$$\n问题在于求解方程 $k(T; k_0) = \\bar{k}$ 中的 $k_0$，其中 $k(t; k_0)$ 表示满足初始条件 $k(0)=k_0$ 的 ODE 的唯一解。\n\n这是一个边值问题，我们将按规定使用打靶算法来解决。该算法将边值问题转化为一个求根问题。我们定义一个打靶函数 $\\phi(k_0)$，其根对应于所需的初始条件 $k_0$：\n$$\n\\phi(k_0) = k(T; k_0) - \\bar{k}\n$$\n为了对给定的试验值 $k_0$ 计算 $\\phi(k_0)$，我们必须求解从 $t=0$ 到 $t=T$ 的 ODE 初值问题 (IVP)。为此，需要一个高精度的数值 ODE 积分器。使用 `scipy.integrate.solve_ivp` 函数，配合如 `RK45` 或 `DOP853` 等方法，并设置足够小的相对和绝对容差（例如，分别为 $10^{-9}$ 和 $10^{-12}$）是合适的。\n\n打靶函数 $\\phi(k_0)$ 的一个关键性质是其单调性。对于一个标量自治 ODE $\\dot{x} = f(x)$，其中 $f$ 是 Lipschitz 连续的，其解的轨迹是有序的。如果 $x_1(0)  x_2(0)$，那么对于所有 $t  0$，都有 $x_1(t)  x_2(t)$。在我们的问题中，右侧项 $s k^{\\alpha} - \\lambda k$ 对于 $k  0$ 是连续可微的，因此在 $(0, \\infty)$ 的任何紧子区间上都是 Lipschitz 连续的。因此，如果我们选择两个初始条件 $k_{0,1}  k_{0,2}  0$，对应的解将满足 $k(t; k_{0,1})  k(t; k_{0,2})$ 对所有 $t  0$ 成立。这意味着 $k(T; k_0)$ 是 $k_0$ 的严格增函数。因此，$\\phi(k_0)$ 也是严格递增的。一个严格单调的连续函数至多有一个根，这保证了如果解 $k_0$ 存在，它就是唯一的。\n\n为了找到这个根，我们采用一种区间求根方法，如 Brent-Dekker 方法，它在 `scipy.optimize.brentq` 中可用。该方法需要一个初始区间 $[a, b]$，使得 $\\phi(a)$ 和 $\\phi(b)$ 的符号相反。因此，一个稳健的区间划定策略至关重要。\n\n首先，我们确定非平凡稳态 $k^{\\ast}  0$，在该点 $\\frac{dk}{dt} = 0$：\n$$\ns(k^{\\ast})^{\\alpha} - \\lambda k^{\\ast} = 0 \\implies s(k^{\\ast})^{\\alpha-1} = \\lambda \\implies k^{\\ast} = \\left(\\frac{s}{\\lambda}\\right)^{\\frac{1}{1-\\alpha}}\n$$\n这个稳态是所有 $k_0  0$ 的全局吸引子。这一性质为我们的区间划定策略提供了依据。\n存在一个平凡的特殊情况：如果目标是稳态，即 $\\bar{k} = k^{\\ast}$，那么解显然是 $k_0 = k^{\\ast}$。如果 $k(0)=k^{\\ast}$，则 $\\frac{dk}{dt}=0$，因此对所有 $t$ 都有 $k(t)=k^{\\ast}$，从而 $k(T)=k^{\\ast}=\\bar{k}$。\n\n对于一般情况 $\\bar{k} \\neq k^{\\ast}$，我们分析其动态：\n1.  如果目标 $\\bar{k}  k^{\\ast}$：要在一个时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0  k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 增加。为了在时间 $T$ 结束于 $\\bar{k}$，我们必须从某个 $k_0  \\bar{k}$ 开始。因此，根 $k_0$ 必须位于区间 $(0, \\bar{k})$ 内。这建议了一个区间，例如 $[\\epsilon, \\bar{k}]$，其中 $\\epsilon$ 是一个小的正数。我们来测试一下：\n    - $\\phi(\\epsilon) = k(T; \\epsilon) - \\bar{k}$。由于 $k(t)$ 从接近零开始并增加， $k(T; \\epsilon)$ 会很小，所以 $\\phi(\\epsilon)  0$。\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k}  k^{\\ast}$，有 $\\frac{dk}{dt}|_{k=\\bar{k}} > 0$。因此，从 $\\bar{k}$ 开始的轨迹会增加，意味着 $k(T; \\bar{k}) > \\bar{k}$，且 $\\phi(\\bar{k}) > 0$。\n    区间 $[\\epsilon, \\bar{k}]$ 确实包含了根。\n\n2.  如果目标 $\\bar{k} > k^{\\ast}$：要在一个时间 $T$ 到达 $\\bar{k}$，轨迹必须是向 $k^{\\ast}$ 演化的。如果我们从 $k_0 > k^{\\ast}$ 开始， $k(t)$ 会向 $k^{\\ast}$ 减少。为了在时间 $T$ 结束于 $\\bar{k}$，我们必须从某个 $k_0 > \\bar{k}$ 开始。根 $k_0$ 必须位于区间 $(\\bar{k}, \\infty)$ 内。这建议了一个初始试验区间，如 $[\\bar{k}, M]$，其中 $M > \\bar{k}$。我们来测试一下：\n    - $\\phi(\\bar{k}) = k(T; \\bar{k}) - \\bar{k}$。由于 $\\bar{k} > k^{\\ast}$，有 $\\frac{dk}{dt}|_{k=\\bar{k}}  0$。从 $\\bar{k}$ 开始的轨迹会减少，所以 $k(T; \\bar{k})  \\bar{k}$，且 $\\phi(\\bar{k})  0$。\n    - 对于一个足够大的上界 $M$，$k(T; M)$ 也会很大，具体来说 $k(T; M) > \\bar{k}$，因此 $\\phi(M) > 0$。\n    因此，像 $[\\bar{k}, 2\\bar{k}]$ 这样的区间是一个合理的起点。\n\n为满足问题对稳健区间扩展策略的严格要求，我们实现以下通用流程：从一个初始区间 $[a, b]$ 开始，例如，根据上述逻辑指导。如果 $\\phi(a) \\cdot \\phi(b) \\ge 0$，则按几何级数扩展该区间。由于 $\\phi$ 是递增的：\n- 如果 $\\phi(a) > 0$ 且 $\\phi(b) > 0$，则根小于 $a$。将区间更新为 $[a/F, a]$，其中因子 $F>1$。\n- 如果 $\\phi(a)  0$ 且 $\\phi(b)  0$，则根大于 $b$。将区间更新为 $[b, b \\cdot F]$。\n重复此扩展过程，直到检测到符号变化或达到最大迭代次数，以防止失败。这种系统化的方法确保了区间求根器的先决条件得到满足。\n\n每个测试用例的最终算法如下：\n1.  计算 $\\lambda = n+g+\\delta$ 和 $k^{\\ast} = (s/\\lambda)^{1/(1-\\alpha)}$。\n2.  根据 $k^{\\ast}$ 计算目标值 $\\bar{k}$。\n3.  如果 $\\bar{k} = k^{\\ast}$，结果为 $k_0 = k^{\\ast}$。\n4.  否则，定义打靶函数 $\\phi(k_0)$，该函数内部求解 ODE 初值问题。\n5.  根据 $\\bar{k}$ 和 $k^{\\ast}$ 之间的关系建立一个初始区间 $[a, b]$。\n6.  如果这不是一个有效的区间，则迭代地扩展它，直到 $\\phi(a) \\cdot \\phi(b)  0$。\n7.  对 $\\phi$ 使用 `scipy.optimize.brentq`，并以找到的区间 $[a, b]$ 为界，求出根 $k_0$。\n8.  存储得到的 $k_0$，并四舍五入到指定的精度。\n此过程将为所有提供的测试用例实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.optimize import brentq\n\ndef solve():\n    \"\"\"\n    Numerically solves the continuous-time Solow growth model for the initial condition k_0\n    that results in a specific terminal condition k(T) = k_bar, using a shooting algorithm.\n    \"\"\"\n\n    # Test cases from the problem statement:\n    # (alpha, s, n, g, delta, T, k_bar_factor)\n    test_cases = [\n        (0.33, 0.25, 0.01, 0.02, 0.05, 5.0, 1.0),    # Case A\n        (0.33, 0.25, 0.01, 0.02, 0.05, 2.0, 0.5),    # Case B\n        (0.40, 0.15, 0.0,  0.0,  0.07, 10.0, 1.2),   # Case C\n        (0.33, 0.35, 0.02, 0.01, 0.04, 1.0, 0.9),    # Case D\n    ]\n\n    results = []\n    \n    # Constants for numerical methods\n    BRACKET_EXPAND_FACTOR = 2.0\n    BRACKET_MAX_ITER = 100\n    ODE_RTOL = 1e-9\n    ODE_ATOL = 1e-12\n    # A small positive number to avoid k=0 issues\n    EPSILON = 1e-9\n\n    for case in test_cases:\n        alpha, s, n, g, delta, T, k_bar_factor = case\n        \n        # Effective depreciation rate\n        lambd = n + g + delta\n        \n        # Calculate the steady state k* if it exists and is positive\n        if lambd = 0 or s = 0:\n            # For the given problem constraints, this branch is not taken\n            raise ValueError(\"Invalid parameters: steady state is not well-defined and positive.\")\n        \n        k_star = (s / lambd)**(1 / (1 - alpha))\n        \n        # Calculate the target terminal capital k_bar\n        k_bar = k_bar_factor * k_star\n        \n        # Special case: If target is the steady state, the solution is trivial.\n        if np.isclose(k_bar, k_star):\n            results.append(k_star)\n            continue\n            \n        # Define the right-hand side of the ODE dk/dt = s*k^alpha - lambda*k\n        def solow_ode(t, k, alpha_p, s_p, lambd_p):\n            # Ensure k is not negative, which can happen due to numerical error\n            k_val = max(k[0], 0.0)\n            return [s_p * (k_val**alpha_p) - lambd_p * k_val]\n\n        # Define the shooting function phi(k0) = k(T, k0) - k_bar\n        def shooting_function(k0):\n            if k0 = 0:\n                # k0 must be positive. For k0->0+, k(t)->0, so phi  0 for k_bar > 0.\n                return -k_bar\n            \n            # Solve the IVP from t=0 to T with initial condition k0\n            sol = solve_ivp(\n                fun=lambda t, y: solow_ode(t, y, alpha, s, lambd),\n                t_span=[0, T],\n                y0=[k0],\n                method='DOP853',\n                rtol=ODE_RTOL,\n                atol=ODE_ATOL\n            )\n            \n            k_T = sol.y[0, -1]\n            return k_T - k_bar\n\n        # --- Bracket finding logic ---\n        # Use model dynamics to propose an intelligent initial bracket\n        if k_bar  k_star:\n            # We expect k0  k_bar. Root is in (0, k_bar].\n            bracket_low = EPSILON\n            bracket_high = k_bar\n        else: # k_bar > k_star\n            # We expect k0 > k_bar. Root is in (k_bar, infinity).\n            bracket_low = k_bar\n            bracket_high = k_bar * BRACKET_EXPAND_FACTOR\n            \n        val_low = shooting_function(bracket_low)\n        val_high = shooting_function(bracket_high)\n\n        # Expand bracket if root is not bracketed by the initial guess\n        for _ in range(BRACKET_MAX_ITER):\n            if val_low * val_high  0:\n                break # Bracket found\n\n            # Since the shooting function is monotonically increasing:\n            if val_low  0 and val_high  0:\n                # Both points are below the root, expand to the right\n                bracket_low = bracket_high\n                bracket_high *= BRACKET_EXPAND_FACTOR\n                val_low = val_high\n                val_high = shooting_function(bracket_high)\n            elif val_low > 0 and val_high > 0:\n                # Both points are above the root, expand to the left\n                bracket_high = bracket_low\n                bracket_low /= BRACKET_EXPAND_FACTOR\n                # Ensure lower bound remains positive\n                bracket_low = max(bracket_low, EPSILON)\n                val_high = val_low\n                val_low = shooting_function(bracket_low)\n            else: # One of the ends is already the root\n                break \n        else:\n            raise RuntimeError(f\"Failed to find a bracket for case: {case}\")\n            \n        # Use a robust root-finding algorithm (Brent's method)\n        k0_solution = brentq(shooting_function, bracket_low, bracket_high)\n        results.append(k0_solution)\n\n    # Format the final output as specified\n    print(f\"[{','.join(f'{r:.6f}' for r in results)}]\")\n\nsolve()\n```", "id": "2416228"}]}