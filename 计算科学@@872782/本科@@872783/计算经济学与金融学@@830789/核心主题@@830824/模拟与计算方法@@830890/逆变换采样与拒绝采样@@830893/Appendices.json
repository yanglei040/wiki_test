{"hands_on_practices": [{"introduction": "这个练习将指导你为标准逻辑分布实现逆变换采样法。这不仅仅是一个编程练习，它通过证明逻辑分布的逆累积分布函数（CDF）正是对数几率（logit）函数，揭示了采样与统计建模之间的深刻联系。通过这个练习，你将在解析推导、数值稳定实现和蒙特卡洛验证方面增强你的技能。[@problem_id:2403666]", "problem": "要求您实现标准逻辑斯谛分布的逆变换采样法，并证明其等价于取几率比的对数（也称为对数几率或 logit）。您的实现必须是一个完整、可运行的程序。\n\n从以下基础知识开始：\n\n- 如果 $U$ 是一个在单位区间上服从连续均匀分布的随机变量，记作 $U \\sim \\mathrm{Uniform}(0,1)$，并且 $F$ 是一个连续且严格递增的累积分布函数，那么随机变量 $X = F^{-1}(U)$ 的累积分布函数为 $F$。这是逆变换采样法的基本原理，源于累积分布函数的定义和 $F$ 的单调性。\n- 标准逻辑斯谛分布的累积分布函数为 $F(x) = \\dfrac{1}{1 + e^{-x}}$，适用于所有实数 $x \\in \\mathbb{R}$。其均值为 $0$，方差为 $\\dfrac{\\pi^2}{3}$。\n\n您的任务：\n\n1. 仅使用上述基本事实，为标准逻辑斯谛累积分布函数推导一个显式的逆变换 $F^{-1}$，并解释为什么该逆变换等于相应累积概率的对数几率。对于概率 $p \\in (0,1)$，对数几率变换定义为 $\\log\\!\\left(\\dfrac{p}{1-p}\\right)$，其中 $\\log$ 表示自然对数。\n2. 为以下各项实现数值稳定的函数：\n   - 逻辑斯谛累积分布函数 $F(x)$。\n   - 定义在 $(0,1)$ 上的逻辑斯谛逆变换 $F^{-1}(u)$。\n3. 通过一个包含典型值和边界情况值的小型测试套件，验证逆变换和对数几率关系。\n\n测试套件及所需检查：\n\n- 使用以下概率 $u$ 测试逆变换：$u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$。对于此集合中的每个 $u$，计算 $x = F^{-1}(u)$ 并数值验证 $|F(x) - u| \\leq \\varepsilon$ 是否成立，容差 $\\varepsilon = 10^{-10}$。为每个 $u$ 记录一个布尔值，表示该条件是否成立。\n- 使用以下实数 $x$ 测试对数几率关系：$x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$。对于此集合中的每个 $x$，计算 $u = F(x)$ 并验证 $\\left|\\log\\!\\left(\\dfrac{u}{1-u}\\right) - x\\right| \\leq \\varepsilon$ 是否成立，使用相同的容差 $\\varepsilon = 10^{-10}$。为每个 $x$ 记录一个布尔值，表示该条件是否成立。\n- 使用逆变换采样法，通过将 $U_i \\sim \\mathrm{Uniform}(0,1)$ 的 $U_1, \\dots, U_N$ 转换为 $X_i = F^{-1}(U_i)$，从标准逻辑斯谛分布中生成 $N = 100000$ 个独立同分布 (IID) 的样本。设 $\\bar{X}_N$ 为样本均值，$S_N^2$ 为样本方差。在容差 $\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$ 下验证以下条件：\n  - $|\\bar{X}_N - 0| \\leq \\delta_{\\mathrm{mean}}$，\n  - $\\left|S_N^2 - \\dfrac{\\pi^2}{3}\\right| \\leq \\delta_{\\mathrm{var}}$。\n  为均值检查和方差检查各记录一个布尔值。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[true1,true2,...]”）。顺序必须是：\n  - 对 $u \\in \\{0.1, 0.5, 0.9, 10^{-12}, 1 - 10^{-12}\\}$ 进行的逆变换检查的五个布尔值（按此顺序），\n  - 接着是对 $x \\in \\{-6.0, -1.0, 0.0, 2.5, 10.0\\}$ 进行的对数几率检查的五个布尔值（按此顺序），\n  - 接着是对样本均值和方差进行蒙特卡洛检查的两个布尔值（按此顺序）。", "solution": "问题陈述已经过评估，并被确定为 **有效**。它以概率论和统计学的既定原则为科学基础，问题提法得当，具有明确的目标和约束，并以客观、明确的语言表述。所要求的任务是计算统计学中的标准练习。我们将继续提供解决方案。\n\n该解决方案分为三个部分：逆变换的解析推导、其数值稳定实现的讨论，以及其数值验证的方案。\n\n### 1. 解析推导\n\n逆变换采样方法的核心在于对累积分布函数（CDF）求逆。\n\n#### 1.1. 标准逻辑斯谛CDF的逆\n\n标准逻辑斯谛分布由其CDF $F(x)$ 定义：\n$$F(x) = \\frac{1}{1 + e^{-x}}$$\n要应用逆变换采样法，我们必须通过解方程 $u = F(x)$ 来找到反函数 $x = F^{-1}(u)$，其中 $u$ 是一个给定的概率，$u \\in (0, 1)$。\n\n我们从CDF的方程开始：\n$$u = \\frac{1}{1 + e^{-x}}$$\n我们进行代数变换以分离出 $x$：\n$$1 + e^{-x} = \\frac{1}{u}$$\n$$e^{-x} = \\frac{1}{u} - 1$$\n$$e^{-x} = \\frac{1 - u}{u}$$\n对两边取自然对数，得到：\n$$\\ln(e^{-x}) = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n$$-x = \\ln\\left(\\frac{1 - u}{u}\\right)$$\n最后，解出 $x$：\n$$x = -\\ln\\left(\\frac{1 - u}{u}\\right) = \\ln\\left(\\left(\\frac{1 - u}{u}\\right)^{-1}\\right) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n因此，反函数，即分位数函数，是：\n$$F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$$\n\n#### 1.2. 与对数几率（Logit）函数的等价性\n\n概率 $p$ 的对数几率，或 logit 变换，定义为 $\\log\\left(\\frac{p}{1-p}\\right)$。通过将概率 $p$ 设为累积概率 $u = F(x)$，$u$ 的对数几率变为：\n$$\\text{logit}(u) = \\log\\left(\\frac{u}{1 - u}\\right)$$\n将此与我们推导出的反函数 $F^{-1}(u)$ 进行比较，我们发现它们是恒等的：\n$$x = F^{-1}(u) = \\log\\left(\\frac{u}{1 - u}\\right) = \\text{logit}(u)$$\n这证明了逻辑斯谛分布的一个基本性质：来自标准逻辑斯谛分布的随机变量 $X$ 等于其自身累积概率 $U=F(X)$ 的对数几率。这种关系是其在逻辑斯谛回归等模型中应用的核心。\n\n### 2. 数值实现策略\n\n数值计算的正确性需要关注潜在的不稳定性，例如上溢和精度损失。\n\n#### 2.1. CDF 函数 $F(x)$\n\n如果 $x$ 是一个很大的负数，$e^{-x}$ 将会变得过大，直接实现 $F(x) = \\frac{1}{1 + e^{-x}}$ 容易发生数值上溢。一个更稳定的实现利用了代数上等价的另一种形式 $F(x) = \\frac{e^x}{1 + e^x}$，当 $x$ 为负数时，$e^x$ 趋近于 $0$，因此该形式是稳定的。因此，一个鲁棒的函数应该根据 $x$ 的符号进行分支：\n- 对于 $x \\ge 0$，使用 $F(x) = \\frac{1}{1 + e^{-x}}$。此时，$e^{-x}$ 的值在 $0$ 和 $1$ 之间，没有上溢风险。\n- 对于 $x  0$，使用 $F(x) = \\frac{e^x}{1 + e^x}$。此时，$e^{x}$ 的值在 $0$ 和 $1$ 之间，同样没有上溢风险。\n这确保了在整个实数轴 $\\mathbb{R}$ 上的稳定性。\n\n#### 2.2. 逆CDF函数 $F^{-1}(u)$\n\n逆CDF函数 $F^{-1}(u) = \\ln\\left(\\frac{u}{1 - u}\\right)$ 可以实现为 $\\ln(u) - \\ln(1 - u)$。当 $u$ 的值极度接近 $1$ 时，如果机器精度不足，$1-u$ 这一项可能会遭受灾难性抵消。然而，对于标准的双精度浮点运算和所提供的测试值（例如，$u = 1 - 10^{-12}$），$1-u$ 的计算是精确的。因此，直接实现对于此问题是足够且准确的。\n\n### 3. 验证方案\n\n问题指定了三组测试来验证我们推导和实现的正确性。\n\n1.  **逆变换检查**：我们将为一组概率 $u$ 计算 $x = F^{-1}(u)$，并验证 $F(x)$ 在指定的容差 $\\varepsilon = 10^{-10}$ 内恢复出原始的 $u$。这证实了我们实现的函数确实互为反函数。\n\n2.  **对数几率关系检查**：对于一组值 $x$，我们将计算 $u=F(x)$ 并验证 $u$ 的对数几率 $\\log\\left(\\frac{u}{1-u}\\right)$ 在容差 $\\varepsilon = 10^{-10}$ 内恢复出原始的 $x$。这在数值上验证了恒等式 $x = \\text{logit}(F(x))$。\n\n3.  **蒙特卡洛模拟**：我们将使用逆变换采样法，对一个均匀随机数流进行变换，从标准逻辑斯谛分布中生成 $N=100000$ 个随机变量。然后，我们将计算样本均值 $\\bar{X}_N$ 和样本方差 $S_N^2$。这些统计量将与标准逻辑斯谛分布的已知理论均值（$\\mu=0$）和方差（$\\sigma^2 = \\pi^2/3$）进行比较。结果是否在指定的容差（$\\delta_{\\mathrm{mean}} = 0.02$ 和 $\\delta_{\\mathrm{var}} = 0.05$）范围内，为采样方法正确生成目标分布的变量提供了经验证据。将使用固定的随机种子以确保结果的可复现性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies the inverse transform sampling for the standard logistic distribution.\n    \"\"\"\n\n    # --- Task 2: Implement numerically stable functions ---\n\n    def logistic_cdf(x: np.ndarray) - np.ndarray:\n        \"\"\"\n        Numerically stable computation of the standard logistic CDF.\n        F(x) = 1 / (1 + exp(-x))\n        \"\"\"\n        x = np.asanyarray(x, dtype=float)\n        res = np.empty_like(x)\n        \n        # For non-negative x, the standard formula is stable.\n        pos_mask = (x = 0)\n        res[pos_mask] = 1.0 / (1.0 + np.exp(-x[pos_mask]))\n        \n        # For negative x, use the equivalent form F(x) = exp(x) / (1 + exp(x)) to avoid overflow.\n        neg_mask = ~pos_mask\n        exp_x_neg = np.exp(x[neg_mask])\n        res[neg_mask] = exp_x_neg / (1.0 + exp_x_neg)\n        \n        return res\n\n    def logistic_inv_cdf(u: np.ndarray) - np.ndarray:\n        \"\"\"\n        Computes the inverse of the standard logistic CDF (quantile function or logit).\n        F_inv(u) = log(u / (1 - u))\n        \"\"\"\n        u = np.asanyarray(u, dtype=float)\n        # The form log(u) - log(1-u) is equivalent and standard.\n        return np.log(u) - np.log(1 - u)\n\n    # --- Task 3: Verify the implementation ---\n\n    results = []\n    \n    # Test Suite 1: Inverse transform check\n    # For each u, compute x = F_inv(u) and check |F(x) - u| = epsilon\n    epsilon = 1e-10\n    u_vals = np.array([0.1, 0.5, 0.9, 1e-12, 1.0 - 1e-12])\n    \n    x_from_u = logistic_inv_cdf(u_vals)\n    u_recalc = logistic_cdf(x_from_u)\n    inv_transform_checks = np.abs(u_recalc - u_vals) = epsilon\n    results.extend(inv_transform_checks)\n\n    # Test Suite 2: Log-odds relationship check\n    # For each x, compute u = F(x) and check |log(u/(1-u)) - x| = epsilon\n    x_vals = np.array([-6.0, -1.0, 0.0, 2.5, 10.0])\n    \n    u_from_x = logistic_cdf(x_vals)\n    # The log-odds is identical to the inverse CDF function.\n    x_recalc = logistic_inv_cdf(u_from_x)\n    log_odds_checks = np.abs(x_recalc - x_vals) = epsilon\n    results.extend(log_odds_checks)\n\n    # Test Suite 3: Monte Carlo simulation check\n    N = 100000\n    delta_mean = 0.02\n    delta_var = 0.05\n    \n    # Use a fixed seed for reproducibility.\n    np.random.seed(42)\n    \n    # Generate N uniform samples from (0, 1)\n    uniform_samples = np.random.uniform(0.0, 1.0, N)\n    \n    # Apply inverse transform sampling\n    logistic_samples = logistic_inv_cdf(uniform_samples)\n    \n    # Calculate sample mean and variance (with ddof=1 for unbiased estimator)\n    sample_mean = np.mean(logistic_samples)\n    sample_var = np.var(logistic_samples, ddof=1)\n    \n    # Theoretical properties of the standard logistic distribution\n    true_mean = 0.0\n    true_var = np.pi**2 / 3.0\n    \n    # Perform checks\n    mean_check = np.abs(sample_mean - true_mean) = delta_mean\n    var_check = np.abs(sample_var - true_var) = delta_var\n    results.extend([mean_check, var_check])\n\n    # Final output formatting\n    # Convert boolean values to lowercase strings \"true\" or \"false\"\n    results_str = [str(b).lower() for b in results]\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "2403666"}, {"introduction": "接下来，我们来解决拒绝采样问题，这是一种在无法得到逆累积分布函数时，从复杂分布中抽样的强大技术。这项动手练习要求你为一个周期性目标密度从零开始构建一个完整的拒绝采样器，甚至包括实现底层的伪随机数生成器以确保可复现性。你将获得选择合适的提议分布、计算接受条件以及分析采样器性能的实践经验。[@problem_id:2403643]", "problem": "构建一个程序，从区间 $[0,4\\pi]$ 上的一个概率分布中生成独立抽样，该分布的密度与 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 成正比，并为一组参数配置计算指定的汇总统计量。所有角度均以弧度为单位。你的程序必须仅依赖于目标分布的定义和一个明确指定的独立均匀分布于 $[0,1)$ 的随机数源，不得读取任何外部输入。\n\n目标密度定义为\n$$\nf(x) \\;=\\; c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}, \\quad x \\in [0,4\\pi],\n$$\n在该区间之外 $f(x)=0$，其中归一化常数 $c$ 由要求 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 唯一确定。\n\n为了生成候选点和报告接受率，考虑一个在 $[0,4\\pi]$ 上均匀分布的提议密度 $g$，即\n$$\ng(x) \\;=\\; \\frac{1}{4\\pi} \\quad \\text{对于 } x\\in[0,4\\pi], \\quad \\text{并且在其他情况下 } g(x)=0,\n$$\n以及一个正常数 $M$，使得对于所有 $x\\in[0,4\\pi]$ 都有 $f(x)\\le M\\,g(x)$。\n\n随机数生成必须使用以下线性同余生成器（LCG）来产生一个可复现的均匀分布于 $[0,1)$ 的变量序列。设整数状态为 $(s_n)_{n\\ge 0}$，其满足\n$$\ns_{n+1} \\;=\\; (a\\, s_n + c_0) \\bmod m,\n$$\n其中 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。每个均匀分布于 $[0,1)$ 的变量由 $u_n = s_n/m$ 给出。对于下面的每个测试用例，将 $s_0$ 初始化为指定的种子值，并按顺序使用生成的序列。\n\n测试套件：\n- 测试用例 1（边界大小样本）：使用种子 $s_0=314159265$，常数 $M=\\frac{\\pi}{2}$，并产生 $N=1$ 个接受的抽样。输出单个接受值 $x_1$，四舍五入到 6 位小数。\n- 测试用例 2（中等样本，精确 $M$）：使用种子 $s_0=271828182$，常数 $M=\\frac{\\pi}{2}$，并产生 $N=1000$ 个接受的抽样。输出两个量，四舍五入到 6 位小数：首先，是总接受率（接受的抽样数除以提议点的总数），其次，是所有接受抽样上 $x\\mapsto \\sin(x)$ 的样本均值。\n- 测试用例 3（大样本，次优 $M$）：使用种子 $s_0=141421356$，常数 $M=\\frac{\\pi}{2}+\\frac{1}{2}$，并产生 $N=50000$ 个接受的抽样。输出两个量，四舍五入到 6 位小数：首先，是总接受率，其次，是一个接受的抽样位于区间 $[\\pi,2\\pi]$ 内的经验概率。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为\n$$\n[x_1,\\ \\text{acc\\_2},\\ \\overline{\\sin}_2,\\ \\text{acc\\_3},\\ p_{[\\pi,2\\pi],3}],\n$$\n其中 $x_1$ 来自测试用例 1，$\\text{acc\\_2}$ 和 $\\overline{\\sin}_2$ 来自测试用例 2，$\\text{acc\\_3}$ 和 $p_{[\\pi,2\\pi],3}$ 来自测试用例 3。每个数值项必须四舍五入到 6 位小数，并且方括号内不允许有空格。", "solution": "问题陈述经过验证。\n\n**步骤 1：提取给定信息**\n- 目标概率密度函数 (PDF)：$f(x) = c \\cdot \\frac{1}{1+\\lvert \\sin(x)\\rvert}$，对于 $x \\in [0,4\\pi]$，其他情况下 $f(x)=0$。常数 $c$ 由 $\\int_0^{4\\pi} f(x)\\,dx = 1$ 定义。\n- 提议概率密度函数：$g(x) = \\frac{1}{4\\pi}$，对于 $x \\in [0,4\\pi]$，其他情况下 $g(x)=0$。\n- 拒绝抽样常数：$M$，一个正常数，使得对于所有 $x \\in [0,4\\pi]$ 都有 $f(x) \\le M\\,g(x)$。\n- 随机数源：一个线性同余生成器（LCG），定义为 $s_{n+1} = (a\\, s_n + c_0) \\bmod m$，参数为 $a=1664525$，$c_0=1013904223$，$m=2^{32}$。均匀分布的随机数是 $u_n = s_n/m$。\n- 测试用例 1：$s_0=314159265$，$M=\\frac{\\pi}{2}$，$N=1$。输出是单个接受值 $x_1$。\n- 测试用例 2：$s_0=271828182$，$M=\\frac{\\pi}{2}$，$N=1000$。输出是接受率和 $\\sin(x)$ 的样本均值。\n- 测试用例 3：$s_0=141421356$，$M=\\frac{\\pi}{2}+\\frac{1}{2}$，$N=50000$。输出是接受率和一个接受的抽样在 $[\\pi,2\\pi]$ 内的经验概率。\n- 格式化：所有数值输出必须四舍五入到 6 位小数。\n\n**步骤 2：使用提取的给定信息进行验证**\n- **科学依据：** 该问题描述了拒绝抽样的应用，这是计算统计学中的一个标准和基础算法。目标函数 $x \\mapsto \\frac{1}{1+\\lvert \\sin(x)\\rvert}$ 在 $[0, 4\\pi]$ 上是非负且连续的。其在该定义域上的积分是有限的，确保可以构建一个有效的 PDF。归一化常数 $c$ 通过计算该积分来确定。函数 $|\\sin(x)|$ 的周期为 $\\pi$，因此积分为 $4 \\int_0^\\pi \\frac{dx}{1+\\sin(x)}$。使用 Weierstrass 换元法 $t = \\tan(x/2)$，该积分计算结果为 2。因此，$\\int_0^{4\\pi} \\frac{dx}{1+|\\sin(x)|} = 4 \\times 2 = 8$。归一化常数为 $c=1/8$，目标 PDF 在定义域 $[0, 4\\pi]$ 上为 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。该问题在科学上是合理的。\n\n- **适定性：** 拒绝抽样方法需要一个常数 $M$ 使得 $f(x) \\le M g(x)$。这个不等式是 $\\frac{1}{8(1+|\\sin x|)} \\le M \\frac{1}{4\\pi}$，可以简化为 $M \\ge \\frac{\\pi}{2} \\frac{1}{1+|\\sin x|}$。当 $|\\sin x|$ 最小时，即 $|\\sin x|=0$ 时，右侧的表达式最大。因此，我们必须有 $M \\ge \\frac{\\pi}{2}$。问题提供了 $M=\\frac{\\pi}{2}$（最优值）和 $M=\\frac{\\pi}{2}+\\frac{1}{2}$（一个有效的次优值），两者都满足条件。LCG 参数是标准的，并产生一个确定性的伪随机序列，使得结果可复现。每个测试用例所需的所有参数（$s_0$, $M$, $N$）都已明确提供。该问题是适定的且自洽的。\n\n- **客观性：** 该问题使用精确的数学定义和客观的计算任务来陈述。没有主观或模糊的元素。\n\n**步骤 3：结论与行动**\n该问题是有效的。将提供一个合理的解决方案。\n\n**解决方案推导**\n这个问题的核心是实现拒绝抽样算法。该方法通过使用一个更简单的提议分布（密度为 $g(x)$）来从目标分布（密度为 $f(x)$）生成样本。该方法需要一个常数 $M$，使得缩放后的提议密度 $M g(x)$ 作为 $f(x)$ 的一个包络，即对于所有 $x$ 都有 $f(x) \\le M g(x)$。\n\n生成一个样本的算法如下：\n1.  从提议分布 $g(x)$ 中抽取一个候选样本 $Y$。\n2.  从 $[0,1]$ 上的均匀分布中抽取一个随机数 $U$。\n3.  如果 $U \\le \\frac{f(Y)}{M g(Y)}$，则接受候选样本 $Y$ 作为来自 $f(x)$ 的一个样本。否则，拒绝 $Y$ 并返回步骤 1。\n\n对于这个具体问题：\n- 提议分布 $g(x)$ 在 $[0, 4\\pi]$ 上是均匀的。可以通过抽取一个均匀分布的随机数 $U_1 \\sim U(0,1)$ 并设置 $Y = 4\\pi \\cdot U_1$ 来生成候选样本 $Y$。\n- 目标密度为 $f(x) = \\frac{1}{8(1+|\\sin x|)}$。\n- 提议密度为 $g(x) = \\frac{1}{4\\pi}$。\n- 接受条件的检查涉及以下比率：\n$$\n\\frac{f(Y)}{M g(Y)} = \\frac{\\frac{1}{8(1+|\\sin Y|)}}{M \\frac{1}{4\\pi}} = \\frac{4\\pi}{8M} \\cdot \\frac{1}{1+|\\sin Y|} = \\frac{\\pi}{2M} \\cdot \\frac{1}{1+|\\sin Y|}\n$$\n生成候选样本和进行接受检查所需的均匀分布随机数序列必须由指定的 LCG 生成：$s_{n+1} = (1664525 \\cdot s_n + 1013904223) \\pmod{2^{32}}$，其中 $u_n = s_n / 2^{32}$。\n\n对于每个测试用例，流程如下：\n1.  用给定的种子 $s_0$ 初始化 LCG。\n2.  为接受的样本初始化一个空列表，并将提议计数器设置为 0。\n3.  循环直到收集到 $N$ 个样本：\n    a. 增加提议计数器。\n    b. 从 LCG 生成 $U_1$ 以创建一个候选样本 $Y = 4\\pi \\cdot U_1$。\n    c. 从 LCG 生成 $U_2$ 用于接受测试。\n    d. 计算阈值 $T = \\frac{\\pi}{2M(1+|\\sin Y|)}$。\n    e. 如果 $U_2 \\le T$，则将 $Y$ 添加到接受样本列表中。\n4.  收集到 $N$ 个样本后，计算所需的统计量。\n\n每个用例的统计量如下：\n- 用例 1：单个样本的值，$x_1$。\n- 用例 2：接受率，定义为 $\\frac{N}{\\text{总提议数}}$，以及样本均值 $\\frac{1}{N} \\sum_{i=1}^{N} \\sin(x_i)$。\n- 用例 3：接受率和经验概率 $P(\\pi \\le X \\le 2\\pi)$，计算方式为 $\\frac{1}{N} \\times (\\text{满足 } \\pi \\le x_i \\le 2\\pi \\text{ 的样本 } x_i \\text{ 的数量})$。\n\n所有最终数值结果必须格式化为六位小数。实现将精确遵循此逻辑以产生所需的输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing rejection sampling for the given\n    distribution and computing the required statistics for three test cases.\n    \"\"\"\n    \n    # LCG parameters are defined as specified in the problem.\n    A_LCG = 1664525\n    C0_LCG = 1013904223\n    M_LCG = 2**32\n\n    def lcg_generator(seed):\n        \"\"\"\n        Creates a generator that yields a sequence of U(0,1) random numbers\n        using the specified Linear Congruential Generator (LCG).\n        \"\"\"\n        state = seed\n        while True:\n            state = (A_LCG * state + C0_LCG) % M_LCG\n            yield state / M_LCG\n\n    def rejection_sampler(lcg, M, N):\n        \"\"\"\n        Generates N samples from the target distribution using rejection sampling.\n\n        Args:\n            lcg (generator): The random number generator.\n            M (float): The constant for the rejection sampling envelope.\n            N (int): The number of samples to generate.\n\n        Returns:\n            tuple: A tuple containing a list of accepted samples and the total\n                   number of proposals made.\n        \"\"\"\n        accepted_samples = []\n        total_proposals = 0\n        \n        # Pre-compute the constant factor for the acceptance threshold calculation\n        acceptance_factor = np.pi / (2.0 * M)\n\n        while len(accepted_samples)  N:\n            total_proposals += 1\n            \n            # Step 1: Generate candidate Y from proposal g(x) = U[0, 4*pi]\n            u1 = next(lcg)\n            y_candidate = u1 * 4.0 * np.pi\n            \n            # Step 2: Generate U for acceptance check from U[0, 1]\n            u2 = next(lcg)\n            \n            # Step 3: Calculate acceptance threshold and check condition\n            # T(y) = f(y) / (M*g(y)) = (pi/(2*M)) * 1/(1+|sin(y)|)\n            threshold = acceptance_factor / (1.0 + np.abs(np.sin(y_candidate)))\n            \n            if u2 = threshold:\n                accepted_samples.append(y_candidate)\n                \n        return accepted_samples, total_proposals\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (seed, M, N)\n        (314159265, np.pi / 2.0, 1),\n        (271828182, np.pi / 2.0, 1000),\n        (141421356, np.pi / 2.0 + 0.5, 50000),\n    ]\n\n    all_results = []\n\n    # --- Test Case 1 ---\n    seed1, M1, N1 = test_cases[0]\n    lcg1 = lcg_generator(seed1)\n    samples1, _ = rejection_sampler(lcg1, M1, N1)\n    x1 = samples1[0]\n    all_results.append(x1)\n\n    # --- Test Case 2 ---\n    seed2, M2, N2 = test_cases[1]\n    lcg2 = lcg_generator(seed2)\n    samples2, total_proposals2 = rejection_sampler(lcg2, M2, N2)\n    \n    # Calculate acceptance rate\n    acc_2 = N2 / total_proposals2\n    all_results.append(acc_2)\n    \n    # Calculate sample mean of sin(x)\n    mean_sin_2 = np.mean([np.sin(x) for x in samples2])\n    all_results.append(mean_sin_2)\n\n    # --- Test Case 3 ---\n    seed3, M3, N3 = test_cases[2]\n    lcg3 = lcg_generator(seed3)\n    samples3, total_proposals3 = rejection_sampler(lcg3, M3, N3)\n    \n    # Calculate acceptance rate\n    acc_3 = N3 / total_proposals3\n    all_results.append(acc_3)\n    \n    # Calculate empirical probability of x in [pi, 2*pi]\n    count_in_interval = sum(1 for x in samples3 if np.pi = x and x = 2.0 * np.pi)\n    prob_3 = count_in_interval / N3\n    all_results.append(prob_3)\n    \n    # Format all results to 6 decimal places and join them into the final string\n    formatted_results = [f'{r:.6f}' for r in all_results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2403643"}, {"introduction": "一个模拟的可靠性取决于其随机性来源的质量。这个引人深思的练习挑战你分析使用低精度随机数生成器的后果，这种情况暴露了像逆变换法这样看似稳健的算法的潜在弱点。通过评估其对估计期望值和风险价值（VaR）等风险度量的影响，你将对计算方法背后的假设有更深入、更具批判性的理解。[@problem_id:2403661]", "problem": "一位计算风险管理领域的研究员希望使用逆变换法来模拟一个非负损失随机变量 $X$。该变量的累积分布函数 $F(x)$ 是连续且严格递增的。模拟方法为：抽取 $U \\sim \\text{Uniform}(0,1)$ 并设置 $X = F^{-1}(U)$。然而，唯一可用的用于 $U$ 的伪随机数生成器返回的值恰好有两位小数，即以 $1/100$ 的等概率从集合 $U \\in \\{0.00, 0.01, \\dots, 0.99\\}$ 中取值。该研究员计划使用这些模拟来估计期望损失 $\\mathbb{E}[X]$ 和高分位数风险度量，如风险价值 (VaR)，其中 $\\alpha$ 水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。同时考虑一个特殊情况，即 $X$ 服从参数为 $\\lambda  0$ 的指数分布，因此对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n选择所有正确的陈述。\n\nA. 在低精度生成器下，模拟出的 $X$ 值被限制在网格 $x_k = F^{-1}(k/100)$ 上，其中 $k \\in \\{0,1,\\dots,99\\}$。因此，随着模拟次数的增加，任何基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 的估计量都会收敛到 $x_{99} = F^{-1}(0.99)$，从而在 $F^{-1}$ 是严格递增的情况下，低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\nB. 即使使用低精度生成器，当模拟次数 $n \\to \\infty$ 时，逆变换模拟的样本均值仍然是 $\\mathbb{E}[X]$ 的一致估计量。\n\nC. 在参数为 $\\lambda$ 的指数分布情况下，从低精度逆变换模拟器计算出的期望值等于 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$，并且严格小于 $1/\\lambda$。\n\nD. 将逆变换采样切换为使用有界提议密度的接受-拒绝（拒绝）采样，可以解决由两位小数的均匀分布生成器引起的离散化偏差，而无需任何其他更改。\n\nE. 通过组合多个独立抽样，可以从两位小数的生成器中恢复任意精细的分辨率：如果 $U_j \\in \\{0.00,0.01,\\dots,0.99\\}$ 是独立的，且 $D_j = 100\\,U_j \\in \\{0,1,\\dots,99\\}$，那么对于任何正整数 $m$，变量 $V_m = \\sum_{j=1}^{m} D_j\\,100^{-j}$ 在网格 $\\{0, 1/100^{m}, 2/100^{m}, \\dots, (100^{m}-1)/100^{m}\\}$ 上均匀分布，这使得随着 $m$ 的增加，能够以 $10^{-2m}$ 的分辨率进行逆变换采样。\n\n选择所有适用的选项。", "solution": "对问题陈述进行验证。\n\n### 第一步：提取已知信息\n- 一个非负损失随机变量 $X$。\n- $X$ 的累积分布函数 (CDF) 是 $F(x)$，它是连续且严格递增的。\n- 模拟方法：逆变换法，$X = F^{-1}(U)$，其中 $U \\sim \\text{Uniform}(0,1)$。\n- 可用于 $U$ 的伪随机数生成器是离散的，以 $1/100$ 的等概率从集合 $\\{0.00, 0.01, \\dots, 0.99\\}$ 中生成值。我们将此离散随机变量表示为 $U_d$。因此，对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。\n- 目标是估计期望损失 $\\mathbb{E}[X]$ 和风险价值 (VaR)。\n- $\\alpha$ 水平的风险价值定义为 $\\text{VaR}_{\\alpha}(X) = \\inf\\{x \\in \\mathbb{R}: F(x) \\ge \\alpha\\}$。\n- 考虑一个特殊情况：$X$ 服从参数为 $\\lambda  0$ 的指数分布，其中对于 $x \\ge 0$，$F(x) = 1 - e^{-\\lambda x}$。\n\n### 第二步：使用提取的已知信息进行验证\n根据指定的标准对问题进行评估。\n- **科学性**：该问题深植于计算统计学和量化金融的原理之中。逆变换采样、伪随机数生成器的性质、期望值和风险价值都是标准概念。有限精度生成器的情景是对现实世界计算约束的一种实用且具有教育意义的简化。\n- **定义明确**：该问题表述清晰。它描述了一个特定的模拟设置，并要求评估关于该设置的属性和后果的五个不同陈述。每个陈述都是一个可检验的数学命题。\n- **客观性**：语言精确、技术性强，没有任何主观性或歧义。\n问题陈述没有违反任何无效标准。它是一个自洽、一致且科学上合理的问题。\n\n### 第三步：结论与行动\n问题陈述有效。将推导出解决方案。\n\n研究员使用的是一个离散均匀随机变量 $U_d$，其中对于 $k \\in \\{0, 1, \\dots, 99\\}$，$P(U_d = k/100) = 1/100$。模拟的损失变量是 $X_d = F^{-1}(U_d)$。$X_d$ 的可能取值为 $x_k = F^{-1}(k/100)$，其中 $k \\in \\{0, 1, \\dots, 99\\}$。\n\n### 选项A的分析\n该陈述声称，基于这些模拟的 $\\text{VaR}_{0.995}(X)$ 的估计量将收敛到 $x_{99} = F^{-1}(0.99)$，从而低估了真实的 $\\text{VaR}_{0.995}(X)$。\n\n水平为 $\\alpha=0.995$ 的真实风险价值是 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。这是因为 $F$ 是连续且严格递增的，所以 $\\inf\\{x: F(x) \\ge \\alpha\\} = F^{-1}(\\alpha)$。\n\n正在模拟的随机变量是 $X_d = F^{-1}(U_d)$。$U_d$ 能取到的最大可能值是 $0.99$。由于 $F^{-1}$ 是严格递增的（因为 $F$ 是），所以模拟出的损失的最大可能值为 $X_{\\text{max}} = F^{-1}(0.99) = x_{99}$。\n\n任何基于从 $X_d$ 分布中抽取的样本的分位数统计估计量，都不能产生一个大于该分布支撑集最大可能值的值。随着模拟次数的增加，任何一致的经验分位数估计量都将收敛到变量 $X_d$ 的理论分位数。\n\n模拟变量 $X_d$ 的 $\\text{VaR}_{0.995}$ 是 $\\inf\\{x : P(X_d \\le x) \\ge 0.995\\}$。\n$P(X_d \\le x) = P(F^{-1}(U_d) \\le x) = P(U_d \\le F(x))$。\n我们需要找到满足 $P(U_d \\le F(x)) \\ge 0.995$ 的最小 $x$。\n$U_d$ 的累积分布函数是一个阶梯函数。对于 $y \\ge 0.99$，$P(U_d \\le y) = 1$。为了使 $P(U_d \\le F(x)) \\ge 0.995$，我们必须有 $P(U_d \\le F(x))=1$。这要求 $F(x) \\ge 0.99$。\n由于 $F$ 是严格递增的，满足 $F(x) \\ge 0.99$ 的最小 $x$ 是 $x = F^{-1}(0.99)$。\n因此，基于 $X_d$ 模拟的 $0.995$-分位数的估计量将收敛到 $F^{-1}(0.99)$。\n\n真实值为 $\\text{VaR}_{0.995}(X) = F^{-1}(0.995)$。\n由于 $F^{-1}$ 是严格递增的，$F^{-1}(0.99)  F^{-1}(0.995)$。\n基于模拟的估计收敛到 $F^{-1}(0.99)$，这是对真实值 $F^{-1}(0.995)$ 的严重低估。这是风险管理中的一个严重失误，因为尾部风险被低估了。\n\n该陈述是**正确的**。\n\n### 选项B的分析\n该陈述声称模拟的样本均值是 $\\mathbb{E}[X]$ 的一致估计量。\n样本均值是 $\\bar{X}_{d,n} = \\frac{1}{n} \\sum_{i=1}^n X_{d,i}$，其中 $X_{d,i}$ 是 $X_d = F^{-1}(U_d)$ 的独立抽样。\n根据大数定律，当模拟次数 $n \\to \\infty$ 时，样本均值收敛于模拟变量的期望值：$\\bar{X}_{d,n} \\to \\mathbb{E}[X_d]$。\n如果一个估计量依概率收敛于某个参数（这里是 $\\mathbb{E}[X]$），那么它就是该参数的一致估计量。因此，我们必须检查是否有 $\\mathbb{E}[X_d] = \\mathbb{E}[X]$。\n\n模拟变量的期望值为：\n$$ \\mathbb{E}[X_d] = \\mathbb{E}[F^{-1}(U_d)] = \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) P\\left(U_d = \\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) $$\n真实的期望值为：\n$$ \\mathbb{E}[X] = \\mathbb{E}[F^{-1}(U)] = \\int_0^1 F^{-1}(u) \\,du $$\n$\\mathbb{E}[X_d]$ 的和是 $\\mathbb{E}[X]$ 积分的一个左黎曼和近似，分区宽度为 $\\Delta u = 1/100$。对于一个一般的严格递增函数 $F^{-1}$，这个和不等于积分值。例如，如果 $F^{-1}(u)$ 是严格凸函数，左黎曼和将严格小于积分值。如果它是严格凹函数，它将严格大于积分值。通常情况下，$\\mathbb{E}[X_d] \\neq \\mathbb{E}[X]$。\n由于样本均值收敛于 $\\mathbb{E}[X_d]$，而不是 $\\mathbb{E}[X]$，所以该估计量存在系统性偏差，不是 $\\mathbb{E}[X]$ 的一致估计量。\n\n该陈述是**不正确的**。\n\n### 选项C的分析\n该陈述专门针对指数分布情况，$F(x) = 1 - e^{-\\lambda x}$。\n通过令 $u = F(x) = 1 - e^{-\\lambda x}$ 来求逆累积分布函数，得到 $x = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$。\n真实的期望值是 $\\mathbb{E}[X] = 1/\\lambda$。\n\n陈述的第一部分说，来自模拟器的期望值是 $(1/100)\\sum_{k=0}^{99} F^{-1}(k/100)$。正如在选项B的分析中确立的，这是 $\\mathbb{E}[X_d]$ 的正确表达式。\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right) = \\frac{1}{100} \\sum_{k=0}^{99} \\left(-\\frac{1}{\\lambda} \\ln\\left(1-\\frac{k}{100}\\right)\\right) $$\n第二部分声称这个值严格小于 $1/\\lambda$。这意味着我们必须证明 $\\mathbb{E}[X_d]  \\mathbb{E}[X]$。\n如前所述，$\\mathbb{E}[X_d]$ 是积分 $\\mathbb{E}[X] = \\int_0^1 F^{-1}(u) \\,du$ 的一个左黎曼和。我们来分析 $g(u) = F^{-1}(u) = -\\frac{1}{\\lambda} \\ln(1-u)$ 的凸性。\n一阶导数是 $g'(u) = -\\frac{1}{\\lambda} \\frac{-1}{1-u} = \\frac{1}{\\lambda(1-u)}$。\n二阶导数是 $g''(u) = \\frac{1}{\\lambda} (-1)(1-u)^{-2}(-1) = \\frac{1}{\\lambda(1-u)^2}$。\n由于 $\\lambda  0$，对于所有 $u \\in [0,1)$，我们有 $g''(u)  0$。这意味着 $F^{-1}(u)$ 在其定义域上是一个严格凸函数。\n对于一个严格凸函数，任何左黎曼和都严格小于在相同区间上的定积分值。\n因此，\n$$ \\mathbb{E}[X_d] = \\frac{1}{100} \\sum_{k=0}^{99} F^{-1}\\left(\\frac{k}{100}\\right)  \\int_0^1 F^{-1}(u) \\,du = \\mathbb{E}[X] = \\frac{1}{\\lambda} $$\n陈述的两部分都为真。\n\n该陈述是**正确的**。\n\n### 选项D的分析\n该陈述建议切换到接受-拒绝 (A-R) 采样将解决离散化偏差。\n标准的A-R算法需要从一个提议分布 $g$ 中抽取一个候选样本 $Y$，并抽取一个均匀随机数 $W \\sim \\text{Uniform}(0,1)$，然后在 $W \\le \\frac{f(Y)}{Mg(Y)}$ 时接受 $Y$，其中 $f$ 是目标密度，$M$ 是一个常数使得 $f(x) \\le Mg(x)$。\n问题指出*唯一*可用的生成器是离散的 $U_d$。如果我们在接受检查中被迫使用 $U_d$ 代替 $W$，条件就变成了 $U_d \\le \\frac{f(Y)}{Mg(Y)}$。\n对于一个连续均匀分布的 $W$，给定 $Y$ 的接受概率是 $P(W \\le c) = c$，其中 $c = \\frac{f(Y)}{Mg(Y)}$。这个性质对于确保接受的样本遵循密度 $f$ 至关重要。\n对于离散生成器 $U_d$，接受概率是 $P(U_d \\le c) = (\\lfloor 100c \\rfloor + 1)/100$（对于 $c  1$）。这是一个阶梯函数，不等于 $c$。均匀变量的离散化破坏了接受概率。因此，接受样本的分布将不会是目标分布 $f(x)$。离散化偏差没有被解决；它只是转移到了模拟算法的另一个部分。\n声称“无需任何其他更改”就能解决偏差是错误的。\n\n该陈述是**不正确的**。\n\n### 选项E的分析\n该陈述提出了一种从低精度均匀随机变量构造更高分辨率均匀随机变量的方法。\n设 $D_j = 100 U_j$，其中 $U_j$ 是来自离散生成器的独立抽样。每个 $D_j$ 都是一个在整数集合 $\\{0, 1, \\dots, 99\\}$ 上均匀分布的独立随机变量。\n提议的变量是 $V_m = \\sum_{j=1}^{m} D_j 100^{-j}$。\n我们来分析 $V_m$：\n$$ V_m = \\frac{D_1}{100} + \\frac{D_2}{100^2} + \\dots + \\frac{D_m}{100^m} = \\frac{D_1 100^{m-1} + D_2 100^{m-2} + \\dots + D_m}{100^m} $$\n分子是一个由 $m$ 个独立的100进制“数字” $D_j$ 构成的随机整数。每个数字序列 $(D_1, \\dots, D_m)$ 对应一个从 $0$ (所有 $D_j=0$) 到 $99 \\cdot 100^{m-1} + \\dots + 99 = 100^m - 1$ 的唯一整数值。\n由于每个 $D_j$ 都在 $\\{0, \\dots, 99\\}$ 上均匀分布且它们是独立的，每个可能的序列 $(D_1, \\dots, D_m)$ 都是等可能的，概率为 $(1/100)^m = 1/100^m$。\n这意味着从 $0$ 到 $100^m-1$ 的每个整数都是分子可能的结果，每个的概率都是 $1/100^m$。\n因此，$V_m$ 是一个在网格 $\\{0/100^m, 1/100^m, \\dots, (100^m-1)/100^m\\}$ 上均匀分布的随机变量。\n$V_m$ 的可能值网格有 $100^m$ 个点，分辨率为 $100^{-m} = 10^{-2m}$。随着 $m$ 的增加，这个离散均匀分布为连续的 $\\text{Uniform}(0,1)$ 分布提供了越来越精细的近似。在逆变换方法中使用 $V_m$，$X=F^{-1}(V_m)$，允许通过选择足够大的 $m$ 来使离散化误差变得任意小。\n这个技术是有效的，并且描述正确。\n\n该陈述是**正确的**。", "answer": "$$\\boxed{ACE}$$", "id": "2403661"}]}