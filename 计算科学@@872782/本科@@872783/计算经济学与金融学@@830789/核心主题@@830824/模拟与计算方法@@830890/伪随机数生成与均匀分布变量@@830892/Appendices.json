{"hands_on_practices": [{"introduction": "在金融建模和蒙特卡洛模拟中，一个常见的任务是从一个标准的均匀分布（通常在 $[0,1)$ 上）生成一个特定范围 $[a,b]$ 内的随机整数。一个看似简单直观的方法是使用模运算，但这种方法会引入一种微妙但后果严重的偏差。本练习将通过精确计算，揭示这种“模偏差”的来源和大小，并与正确的无偏方法（拒绝采样）进行对比，从而加深你对生成离散均匀变量严谨性的理解。[@problem_id:2423278]", "problem": "您可以使用一个基础伪随机数生成器（PRNG），它在整数集合 $\\{0,1,\\dots,m-1\\}$ 上进行独立均匀抽样，其中 $m = 2^{32}$。您的任务是分析如何使用此源在目标范围 $[a,b]$ 内生成一个随机整数，并量化朴素实现所引入的偏差。这个问题源于计算经济学和金融学中广泛使用的 Monte Carlo 算法，其中有偏的离散均匀采样会扭曲估计值（例如，状态转移、序贯 Monte Carlo 中的重采样步骤或离散选择模拟）。您必须从第一性原理推导出相关表达式，并实现一个程序来计算精确的偏差度量和资源使用情况，而无需进行模拟。\n\n基本定义和假设：\n- 基础 PRNG 的输出 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上严格均匀分布，其中 $m=2^{32}$。\n- 令 $n = b-a+1$ 为目标整数范围 $[a,b]$ 的大小。\n- 朴素的“取模”映射生成 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。\n- 拒绝采样映射定义 $q = \\lfloor m/n \\rfloor$，如果 $X  qn$ 则接受一次抽样，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽样，直到接受为止。\n\n您的任务：\n1) 从第一性原理推导出 $Y_{\\mathrm{mod}}$ 的精确概率质量函数（用 $m$、$n$、$q = \\lfloor m/n \\rfloor$ 和 $r = m - qn$ 表示），然后推导出 $Y_{\\mathrm{mod}}$ 的分布与 $[a,b]$ 上的理想离散均匀分布之间的全变差距离的闭式表达式。两种概率分布 $\\{p_i\\}$ 和 $\\{u_i\\}$ 在 $n$ 个结果上的全变差距离定义为\n$$\n\\mathrm{TVD} = \\frac{1}{2}\\sum_{i=1}^{n} \\left| p_i - u_i \\right|.\n$$\n\n2) 证明拒绝采样映射在 $[a,b]$ 上产生严格均匀分布（即全变差距离为 $0$），并推导其接受概率 $\\alpha$ 以及每个接受的输出所需的期望基础 PRNG 抽样次数。用 $m$、$n$、$q$ 和 $r$ 表示您的答案。\n\n3) 实现一个程序，对于下面的每个测试用例，使用您推导出的公式（而不是通过模拟）计算三个量：\n- 取模方法的全变差距离 $\\mathrm{TVD}_{\\mathrm{mod}}$。\n- 拒绝采样方法的全变差距离 $\\mathrm{TVD}_{\\mathrm{rej}}$。\n- 拒绝采样下每个接受的输出所需的期望基础 PRNG 抽样次数 $\\mathbb{E}[D]$。\n\n测试套件（使用以下 $(a,b)$ 对；这些设计旨在包含一般情况、边界情况和边缘情况）：\n- 情况 1（一般情况）：$(a,b) = (0, 9)$，因此 $n=10$。\n- 情况 2（退化范围）：$(a,b) = (5, 5)$，因此 $n=1$。\n- 情况 3（包含负数）：$(a,b) = (-2, 2)$，因此 $n=5$。\n- 情况 4（能整除 $m$）：$(a,b) = (0, 65535)$，因此 $n=65536$。\n- 情况 5（大的非整除数）：$(a,b) = (-10, 10^{6})$，因此 $n = 1{,}000{,}011$。\n\n精确的输出要求：\n- 对于每个测试用例，按此顺序输出一个列表 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。\n- 您的程序应生成单行输出，其中包含所有测试用例的结果，形式为由方括号括起来的、每个用例列表组成的逗号分隔列表。例如：“[[x_{1},y_{1},z_{1}],[x_{2},y_{2},z_{2}],...]”，但不含空格。您的程序必须精确输出这样的一行。\n- 所有结果必须是数值型（浮点数是可以接受的）。您的解决方案中不允许进行随机采样；仅使用闭式表达式计算值。", "solution": "我们从第一性原理开始。基础伪随机数生成器（PRNG）从有限集 $\\{0,1,\\dots,m-1\\}$ 中均匀地抽取 $X$，其中 $m = 2^{32}$。对于目标整数区间 $[a,b]$，定义 $n = b-a+1 \\in \\mathbb{N}$。\n\n朴素取模映射分析：\n定义朴素映射 $Y_{\\mathrm{mod}} = a + (X \\bmod n)$。由于 $X$ 在 $\\{0,1,\\dots,m-1\\}$ 上是均匀的，且 $(X \\bmod n)$ 的取值在 $\\{0,1,\\dots,n-1\\}$ 内，因此 $(X \\bmod n) = i$ 的概率与 $\\{0,1,\\dots,m-1\\}$ 中有多少整数模 $n$ 的余数为 $i$ 成正比。\n\n令 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 且 $r = m - qn = m \\bmod n$，其中 $r \\in \\{0,1,\\dots,n-1\\}$。当我们将 $\\{0,1,\\dots,m-1\\}$ 划分为模 $n$ 的同余类时，恰好有 $r$ 个余数出现 $q+1$ 次，有 $n-r$ 个余数出现 $q$ 次。因此，对于余数 $i$，\n- 对于 $r$ 个不同的 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q+1}{m}$。\n- 对于 $n-r$ 个不同的 $i$ 值，$\\mathbb{P}[(X \\bmod n)=i] = \\frac{q}{m}$。\n\n在 $\\{0,1,\\dots,n-1\\}$ 上的理想离散均匀分布为每个余数赋予 $\\frac{1}{n}$ 的概率。绝对偏差为\n$$\n\\left|\\frac{q+1}{m} - \\frac{1}{n}\\right| = \\frac{n-r}{mn}, \\quad\n\\left|\\frac{q}{m} - \\frac{1}{n}\\right| = \\frac{r}{mn}.\n$$\n因此，全变差距离为\n$$\n\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{1}{2}\\left( r \\cdot \\frac{n-r}{mn} + (n-r) \\cdot \\frac{r}{mn} \\right) = \\frac{r(n-r)}{mn}.\n$$\n这个闭式表达式量化了只要 $r \\neq 0$（即只要 $n$ 不能整除 $m$）时取模方法引入的偏差。如果 $r=0$，那么 $\\mathrm{TVD}_{\\mathrm{mod}} = 0$，并且该映射是严格均匀的。\n\n拒绝采样分析：\n如前所述，定义 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$，如果 $X  qn$，则接受一次抽样，并在接受时返回 $Y_{\\mathrm{rej}} = a + (X \\bmod n)$；否则，从基础 PRNG 重新抽样。因为接受集的规模为 $qn$，并且被划分为 $n$ 个同余类，每个类的大小恰好为 $q$，所以在接受的条件下，余数 $(X \\bmod n)$ 在 $\\{0,1,\\dots,n-1\\}$ 上是严格均匀的。因此，\n$$\n\\mathrm{TVD}_{\\mathrm{rej}} = 0.\n$$\n接受概率为 $\\alpha = \\frac{qn}{m} = 1 - \\frac{r}{m}$，所需的基础抽样次数 $D$ 是一个成功概率为 $\\alpha$ 的几何随机变量，因此每个接受的输出所需的期望基础抽样次数是\n$$\n\\mathbb{E}[D] = \\frac{1}{\\alpha} = \\frac{1}{1 - \\frac{r}{m}}.\n$$\n在 $r=0$ 的特殊情况下（即当 $n$ 能整除 $m$ 时），我们有 $\\alpha = 1$ 和 $\\mathbb{E}[D] = 1$。\n\n算法设计：\n给定 $(a,b)$，计算 $n = b-a+1$，然后计算 $q = \\left\\lfloor \\frac{m}{n} \\right\\rfloor$ 和 $r = m - qn$。使用这些值，评估：\n- $\\mathrm{TVD}_{\\mathrm{mod}} = \\frac{r(n-r)}{mn}$。\n- $\\mathrm{TVD}_{\\mathrm{rej}} = 0$。\n- $\\mathbb{E}[D] = \\frac{1}{1 - \\frac{r}{m}}$（按照约定，当 $r=0$ 时 $\\mathbb{E}[D]=1$）。\n不需要进行随机采样；这些都是闭式计算。\n\n测试套件覆盖范围：\n- 情况 $n=10$ 测试了一般非整除情况（$r \\neq 0$）。\n- 情况 $n=1$ 测试了退化区间（始终均匀，零偏差）。\n- 情况 $n=5$ 测试了包含负数边界和小的非整除情况。\n- 情况 $n=65536$ 测试了精确整除情况（$n$ 能整除 $m$）。\n- 情况 $n=1{,}000{,}011$ 测试了大的非整除情况。\n\n输出格式：\n对于每个用例，输出 $[\\mathrm{TVD}_{\\mathrm{mod}}, \\mathrm{TVD}_{\\mathrm{rej}}, \\mathbb{E}[D]]$。将所有五个用例的结果汇总成一个单一的、用逗号分隔的列表，并用方括号括起来，不含空格，例如：\"[[x1,y1,z1],[x2,y2,z2],...]\"，打印在单行上。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef compute_metrics(a: int, b: int, m: int) - tuple[float, float, float]:\n    \"\"\"\n    Compute (TVD_mod, TVD_rej, E[D]) for target range [a,b],\n    given base PRNG modulus m (here m=2^32).\n    \"\"\"\n    n = b - a + 1\n    if n = 0:\n        raise ValueError(\"Invalid range: b must be >= a.\")\n    # Compute q and r\n    q = m // n\n    r = m - q * n  # same as m % n, but avoids negatives\n    # Total variation distance for modulo method: r*(n-r)/(m*n)\n    tvd_mod = (r * (n - r)) / (m * n)\n    # Rejection sampling is exactly uniform\n    tvd_rej = 0.0\n    # Expected number of base draws per accepted output: 1 / (1 - r/m)\n    if r == 0:\n        expected_draws = 1.0\n    else:\n        expected_draws = 1.0 / (1.0 - (r / m))\n    return float(tvd_mod), float(tvd_rej), float(expected_draws)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0, 9),          # n=10\n        (5, 5),          # n=1\n        (-2, 2),         # n=5\n        (0, 65535),      # n=65536 (divides 2^32)\n        (-10, 10**6),    # n=1_000_011\n    ]\n    # Base PRNG modulus m = 2^32\n    m = 2 ** 32\n\n    results_str = []\n    for a, b in test_cases:\n        tvd_mod, tvd_rej, expected_draws = compute_metrics(a, b, m)\n        # Format numbers using a consistent, compact representation\n        # Use .17g for good precision without excessive digits\n        sub = \"[\" + \",\".join([\n            format(tvd_mod, \".17g\"),\n            format(tvd_rej, \".17g\"),\n            format(expected_draws, \".17g\"),\n        ]) + \"]\"\n        results_str.append(sub)\n\n    # Final print statement in the exact required format (no spaces).\n    print(f\"[{','.join(results_str)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2423278"}, {"introduction": "生成随机整数是许多更复杂算法的基础，例如生成随机排列（洗牌）。随机排列在自举法（bootstrapping）和置换检验（permutation tests）等统计技术中至关重要。本练习将生动地展示，当一个有缺陷的洗牌算法与一个质量低劣的伪随机数生成器（PRNG）结合时，会如何导致灾难性的后果，产生一个高度非随机的排列。通过这个实践，你将认识到选择正确的算法（如Fisher-Yates洗牌）和高质量的PRNG同等重要。[@problem_id:2423267]", "problem": "给定两个用于索引数组 $0,1,2,\\dots,n-1$ 的洗牌程序和两种类型的伪随机数生成器 (PRNG)。您的任务是实现这两种洗牌程序，将它们与指定的 PRNG 结合使用，并量化一个朴素洗牌与一个低范围 PRNG 结合如何产生一个高度非随机的排列。这是一个关于伪随机数生成和均匀分布变量的计算经济学和金融学练习，重点关注实现选择如何影响模拟结果的统计特性。\n\n基本基础：\n- 伪随机数生成器 (PRNG) 是一个确定性函数，其生成的序列旨在模拟 $[0,1)$ 上均匀分布变量的独立实现。一个常见的类别是线性同余生成器 (LCG)，其递推关系为 $x_{t+1} \\equiv (a x_t + c) \\bmod m$。\n- 有限集合 $\\{0,1,\\dots,k\\}$ 上的均匀分布变量为每个结果分配相等的概率 $1/(k+1)$。\n- Fisher–Yates（也称为 Knuth）洗牌算法生成一个均匀分布的排列，前提是在每一步 $i$，整数 $j$ 都是从 $\\{0,1,\\dots,i\\}$ 中均匀且独立地抽取的。\n- 一个包含 $n$ 个项目的排列是均匀的，如果 $n!$ 种排列中的每一种都有 $1/n!$ 的概率。\n\n您将实现：\n- Fisher–Yates 洗牌：对于 $i = n-1, n-2, \\dots, 1$，使用高质量的 PRNG 从 $\\{0,1,\\dots,i\\}$ 中均匀抽取一个整数 $j$，并交换位置 $i$ 和 $j$。\n- 朴素洗牌：对于 $i = 0,1,\\dots,n-1$，从 $\\{0,1,\\dots,n-1\\}$ 中抽取一个整数 $j$，并交换位置 $i$ 和 $j$。已知即使使用好的 PRNG，此过程也是非均匀的，当与低范围 PRNG 配对时，情况会变得更糟。\n\n您还将实现两种 PRNG：\n- 好的 PRNG：使用 Python NumPy Generator 与置换同余生成器 (Permuted Congruential Generator, PCG) 族，在指定范围内生成独立的均匀整数。\n- 差的 PRNG：模拟一个低范围、类似遗留系统的生成器，每次抽取仅产生 $15$ 位随机性。它通过 LCG $x_{t+1} \\equiv (a x_t + c) \\bmod 2^{31}$（其中 $a$ 和 $c$ 为固定整数）实现，并仅将高 $15$ 位作为输出整数暴露在 $\\{0,1,\\dots,32767\\}$ 中。这模拟了一个常见的陷阱，即 $j$ 由一个 PRNG 生成，其最大值 $R$（通常称为 $RAND\\_MAX$）远小于 $n-1$，因此 $j$ 永远不能超过 $R$。\n\n每个测试用例需报告的统计量：\n- 将索引划分为下部块 $L = \\{0,1,\\dots,b\\}$ 和上部块 $U = \\{b+1, b+2, \\dots, n-1\\}$，其中 $b$ 是一个给定的边界，满足 $0 \\le b  n-1$。\n- 洗牌后，令 $\\pi$ 为得到的排列。定义分数\n$$\nS = \\frac{\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}}{|U|},\n$$\n即上部块中的最终位置被同样源自上部块的元素占据的比例。对于一个真正均匀的随机排列，根据对称性和无放回抽样，S的期望值等于 $|U|/n$。\n\n重要的科学现实主义说明：\n- 当朴素洗牌与一个低范围 PRNG 配对时，如果其输出 $j$ 位于 $\\{0,1,\\dots,b\\}$ 且 $b \\ll n-1$，那么对于 $i \\le b$，交换只在 $L$ 内部发生；对于 $i  b$，每次交换都是将一个高索引 $i \\in U$ 与一个低索引 $j \\in L$ 进行交换。由于未来的步骤不会选择任何 $j \\in U$，一旦一个值被放置在特定的 $i \\in U$ 位置，它就再也不会被移动。因此，$U$ 中的所有最终位置都必须被来自 $L$ 的值占据，从而 $S = 0$。这与均匀分布的基准值 $|U|/n$ 存在显著偏差。\n\n您的程序必须：\n- 实现两种洗牌程序和两种 PRNG。\n- 对于每个测试用例，构建排列并按上述定义计算 $S$。\n- 使用固定的种子以保证可复现性。\n- 输出单行，其中包含所有测试用例的 $S$ 值列表，格式如下所述。\n\n角度单位和物理单位在此不适用。\n\n测试套件和要求的最终输出格式：\n- 使用以下包含四个案例的测试套件，每个案例由 $(\\text{alg}, n, b, \\text{seed})$ 指定，其中 $\\text{alg} \\in \\{\\text{\"good\"}, \\text{\"bad\"}\\}$ 分别选择使用好的 PRNG 的 Fisher–Yates 算法或使用低范围差的 PRNG 的朴素洗牌算法。\n    1. $\\text{alg} = \\text{\"good\"}$，$n = 100000$，$b = 32767$，$\\text{seed} = 20240517$。\n    2. $\\text{alg} = \\text{\"bad\"}$，$n = 100000$，$b = 32767$，$\\text{seed} = 123456789$。\n    3. $\\text{alg} = \\text{\"bad\"}$，$n = 33000$，$b = 32767$，$\\text{seed} = 987654321$。\n    4. $\\text{alg} = \\text{\"good\"}$，$n = 65536$，$b = 1023$，$\\text{seed} = 31415926$。\n- 对于每个案例，将 $S$ 计算为浮点数。您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表，列表中的结果顺序与上述案例顺序相同。例如：\"[0.6723,0.0,0.0,0.9844]\"。您的程序不得打印任何其他文本。\n\n四个案例的最终答案必须是浮点数。程序必须是完整且可直接运行的，并且不得要求任何输入。", "solution": "问题陈述经过严格审查，被认为是有效的。它具有科学依据，问题定义明确，客观，并提出了一个基于计算机科学和统计学既定原则的非平凡计算任务。这是一个精心设计的练习，旨在理解伪随机数生成和算法设计中的微妙之处。\n\n目标是量化一个有缺陷的洗牌算法与一个范围受限的伪随机数生成器 (PRNG) 相结合所导致的与均匀分布的统计偏差。这是通过比较两种情况来完成的：一种是科学上可靠的洗牌算法 (Fisher-Yates) 与高质量 PRNG 的组合，另一种是“朴素”洗牌算法与一个明显很差的 PRNG 的组合。要计算的统计量是 $S$，即源自上部索引块 $U = \\{b+1, \\dots, n-1\\}$ 的元素在洗牌后仍留在 $U$ 内位置的比例。\n\n对于一个包含 $n$ 个元素的真正均匀随机排列 $\\pi$，每个元素都有相等的机会落在任何位置。一个特定元素最终落入块 $U$ 的概率是 $|U|/n$。根据期望的线性性质，来自 $U$ 的元素最终落入 $U$ 中位置的期望数量是 $|U| \\times (|U|/n)$。因此，统计量 $S$ 的期望值为：\n$$\nE[S] = E\\left[\\frac{\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}}{|U|}\\right] = \\frac{E[\\#\\{i \\in U \\,:\\, \\pi(i) \\in U\\}]}{|U|} = \\frac{|U|^2/n}{|U|} = \\frac{|U|}{n}\n$$\n这个理论值是我们“好的”算法的基准。\n\n**1. “好的”情景：Fisher-Yates 洗牌与高质量 PRNG**\n\nFisher-Yates（或 Knuth）洗牌是生成均匀随机排列的经典算法。其过程如下：对于从 $n-1$ 向下到 $1$ 的每个索引 $i$，从范围 $\\{0, 1, \\dots, i\\}$ 中均匀随机选择一个索引 $j$。然后交换位置 $i$ 和 $j$ 的元素。通过确保在每一步 $i$，要放置在此位置的元素是从所有尚未放置的可用元素中均匀选择的，该算法保证了 $n!$ 种可能的排列中的每一种都是等可能的。\n\n然而，这个保证取决于 PRNG 是否能够从所需的范围 $\\{0, 1, \\dots, i\\}$ 中提供真正均匀且独立的整数。对于“好的”情况，实现利用了 Python 的 `numpy.random.Generator` 及其 `PCG64` 引擎，这是一个现代且统计上稳健的 PRNG，非常适合此任务。预计这些情况下计算出的 $S$ 值将接近理论平均值 $|U|/n$。\n\n- 对于测试用例 1 ($n=100000, b=32767$)，期望值为 $E[S] = (100000 - 32768) / 100000 = 0.67232$。\n- 对于测试用例 4 ($n=65536, b=1023$)，期望值为 $E[S] = (65536 - 1024) / 65536 = 63/64 = 0.984375$。\n\n**2. “差的”情景：朴素洗牌与低范围 PRNG**\n\n这个情景展示了一个常见而严重的实现缺陷。\n\n首先，“朴素”洗牌算法从 $i=0$ 迭代到 $n-1$，在每一步，将位置 $i$ 的元素与从完整范围 $\\{0, 1, \\dots, n-1\\}$ 中选择的位置 $j$ 的元素进行交换。即使使用完美的 PRNG，该算法也无法生成均匀的排列。\n\n其次，“差的” PRNG 是对一个具有严重缺陷的遗留生成器的模拟：输出范围有限。它被建模为线性同余生成器 (LCG)，形式为 $x_{t+1} \\equiv (a x_t + c) \\bmod m$，参数为 $a=1103515245$，$c=12345$，模数为 $m=2^{31}$。关键的是，只使用 $31$ 位状态的高 $15$ 位，产生一个在范围 $\\{0, 1, \\dots, 2^{15}-1\\}$（即 $\\{0, 1, \\dots, 32767\\}$）内的整数输出。这模仿了历史上最大整数 `RAND_MAX` 很小的 PRNG。\n\n这两个缺陷的组合是灾难性的。在使用此情景的测试用例中，$n$ 大于或等于 $33000$，边界为 $b=32767$。PRNG 只能生成索引 $j \\in L = \\{0, 1, \\dots, 32767\\}$。洗牌循环从 $i=0, \\dots, n-1$ 进行。\n- 对于 $i \\in L$，交换 `(i, j)` 发生在下部块 $L$ 中的两个索引之间。这部分地洗牌了 $L$ 内部的元素。\n- 对于 $i \\in U$，交换 `(i, j)` 发生在上部块 $U$ 中的索引 $i$ 和总是在下部块 $L$ 中的索引 $j$ 之间。此操作将一个源自 $L$ 的元素移动到位置 $i$。由于循环索引 $i$ 只会增加，而交换索引 $j$ 永远不可能在 $U$ 中，因此一旦一个来自 $L$ 的元素被放置在 $i \\in U$ 的位置，它就再也不会被换成来自 $U$ 的元素。\n\n因此，在程序结束时，$U$ 中的每个位置 $i$ 都将被一个源自 $L$ 的元素占据。最终位置在 $U$ 中且同样源自 $U$ 的元素数量（即 $S$ 的分子）必须恰好为 $0$。因此，对于“差的”情况，我们必须发现 $S=0$。\n\n以下实现根据这些原则为每个指定的测试用例计算统计量 $S$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates two shuffle algorithms with two different PRNGs\n    to demonstrate the impact of implementation choices on statistical properties.\n    \"\"\"\n\n    class BadLCG:\n        \"\"\"\n        A 'bad' Linear Congruential Generator that mimics a legacy PRNG\n        with a limited output range of 15 bits.\n        \"\"\"\n        def __init__(self, seed):\n            self.a = 1103515245\n            self.c = 12345\n            self.m = 2**31\n            self.state = seed  (self.m - 1)\n\n        def next_int(self):\n            \"\"\"\n            Advances the LCG state and returns the upper 15 bits, an integer\n            in the range [0, 32767].\n            \"\"\"\n            self.state = (self.a * self.state + self.c)  (self.m - 1)\n            # The problem specifies to expose the upper 15 bits of a 31-bit state.\n            # Shifting right by (31 - 15) = 16 bits accomplishes this.\n            return self.state >> 16\n\n    def fisher_yates_shuffle(arr, prng_callable):\n        \"\"\"\n        Performs a Fisher-Yates (Knuth) shuffle on an array.\n        \n        Args:\n            arr (np.array): The array to shuffle.\n            prng_callable (function): A function that takes (low, high) and returns a\n                                      random integer in that inclusive range.\n        \"\"\"\n        n = len(arr)\n        for i in range(n - 1, 0, -1):\n            j = prng_callable(0, i)\n            arr[i], arr[j] = arr[j], arr[i]\n\n    def naive_shuffle(arr, prng_callable):\n        \"\"\"\n        Performs a naive shuffle known to be statistically biased.\n        \n        Args:\n            arr (np.array): The array to shuffle.\n            prng_callable (function): A function that returns a random integer.\n                                      For the 'bad' case, it ignores any bounds.\n        \"\"\"\n        n = len(arr)\n        for i in range(n):\n            # The 'bad' PRNG's range is limited, so j will be capped regardless\n            # of n.\n            j = prng_callable()\n            arr[i], arr[j] = arr[j], arr[i]\n\n    # Test suite from the problem statement\n    test_cases = [\n        # (alg, n, b, seed)\n        (\"good\", 100000, 32767, 20240517),\n        (\"bad\", 100000, 32767, 123456789),\n        (\"bad\", 33000, 32767, 987654321),\n        (\"good\", 65536, 1023, 31415926),\n    ]\n\n    results = []\n    for alg, n, b, seed in test_cases:\n        pi = np.arange(n, dtype=np.int64) # Use 64-bit int to avoid overflow if n > 2^32\n        \n        if alg == \"good\":\n            rng = np.random.default_rng(seed)\n            # Create a callable that matches the expected signature for Fisher-Yates\n            def good_prng_callable(low, high):\n                return rng.integers(low, high + 1)\n            \n            fisher_yates_shuffle(pi, good_prng_callable)\n        \n        elif alg == \"bad\":\n            rng = BadLCG(seed)\n            # The callable for the naive shuffle with the bad PRNG just calls next_int()\n            # and ignores any potential arguments.\n            def bad_prng_callable(*args, **kwargs):\n                return rng.next_int()\n\n            naive_shuffle(pi, bad_prng_callable)\n        \n        # Calculate the statistic S\n        upper_block_start = b + 1\n        \n        # The upper block U consists of indices {b+1, ..., n-1}\n        # Its size is n - (b+1).\n        size_U = n - upper_block_start\n\n        if size_U = 0:\n            # According to problem constraints (0 = b  n-1), size_U is always > 0.\n            # Handle this case for robustness, though it won't be triggered.\n            s_value = 0.0 if size_U == 0 else float('nan')\n        else:\n            # We are interested in pi(i) for i in U. These are the elements\n            # in the final permutation at positions from upper_block_start onwards.\n            final_upper_block_values = pi[upper_block_start:]\n            \n            # Count how many of these values came from the original upper block.\n            # An element originated from the upper block if its value is >= upper_block_start.\n            count_from_U = np.sum(final_upper_block_values >= upper_block_start)\n            \n            s_value = count_from_U / size_U\n            \n        results.append(s_value)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2423267"}, {"introduction": "到目前为止，我们关注的是伪随机数序列的统计特性，如均匀性和独立性。然而，一个更深层次的属性是其不可预测性。本练习将带领你扮演“密码破解者”的角色，通过观察一个序列的前几个输出来尝试预测后续的数值。你将发现，即使是像线性同余生成器（LCG）这样在统计上表现良好的PRNG，其输出也是完全可以预测的，这暴露了其底层的确定性结构。这个实践揭示了用于模拟的PRNG和用于加密安全应用的CSPRNG之间的根本区别。[@problem_id:2423284]", "problem": "给定两类用于在计算经济学和金融学中生成离散均匀变量的生成器：一个线性同余生成器和一个由计数器模式下的密码学哈希函数构建的密码学安全生成器。你的任务是实现一个预测器，在被动观察一个生成器的三个连续输出后，尝试预测下一个输出。该预测器应对线性同余生成器成功，而对密码学安全生成器失败。\n\n基本原理和定义：\n- 线性同余生成器 (LCG) 由以下递推关系定义：\n$$X_{t+1} \\equiv a X_t + c \\pmod{m},$$\n其状态为 $X_t \\in \\{0,1,\\dots,m-1\\}$，模数为 $m \\in \\mathbb{N}$，乘数为 $a \\in \\{0,1,\\dots,m-1\\}$，增量为 $c \\in \\{0,1,\\dots,m-1\\}$，并有一个初始种子 $X_0$。它通过映射 $U_t = X_t/m \\in [0,1)$ 来生成离散均匀变量。\n- 此处使用的密码学安全生成器规定如下：设 $H$ 为安全哈希算法256位哈希函数 (SHA-256)。对于给定的字节串种子 $s$ 和一个素数模数 $m$，定义\n$$X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m,$$\n其中 $\\mathrm{encode}_{8}(t)$ 是非负整数 $t$ 的8字节大端编码，$\\|$ 表示拼接，$\\mathrm{int}(\\cdot)$ 将32字节的哈希输出解释为以256为基数的非负整数。这种结构是使用密码学原语的标准计数器模式伪随机数生成器，其输出旨在实现计算上的不可预测性。\n\n你的程序必须实现以下内容：\n1. 一个函数，给定模数 $m$ 和来自单个生成器的三个连续观测状态 $(x_0,x_1,x_2)$，尝试推断与 LCG 定义一致的参数 $(a,c)$，并预测下一个状态 $\\hat{x}_3 \\equiv a x_2 + c \\pmod{m}$。如果多个 $(a,c)$ 满足给定观测值的同余方程，或者在你的方法中模逆运算不可能，你可以选择任何一致的规则，但你必须返回一个单一的整数预测值 $\\hat{x}_3 \\in \\{0,1,\\dots,m-1\\}$。\n2. 对于每个测试用例，使用指定的基准生成器计算真实的下一个状态 $x_3$。以布尔值的形式报告你的预测值 $\\hat{x}_3$ 是否等于真实的 $x_3$。\n\n测试套件：\n- 案例 A (LCG, 理想路径)：$m = 2147483647$，$a = 48271$，$c = 0$，$X_0 = 12345$。\n- 案例 B (LCG, 非零增量)：$m = 1000003$，$a = 35011$，$c = 7919$，$X_0 = 424242$。\n- 案例 C (LCG, a = 1 的边界情况)：$m = 101$，$a = 1$，$c = 1$，$X_0 = 17$。\n- 案例 D (密码学安全生成器)：素数模数 $m = 4294967291$，种子 $s$ 等于文本“econ-secure”的 ASCII 字节串。生成器为 $X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m$，其中 $H$ 为 SHA-256。\n\n对于每个案例，按以下步骤操作：\n- 使用指定的基准生成器和参数生成前四个连续状态 $X_0, X_1, X_2, X_3$。\n- 仅向预测器提供 $(m, X_0, X_1, X_2)$，让它根据上述第 1 项通过拟合 LCG 来计算 $\\hat{X}_3$。\n- 计算一个布尔值 $b$，如果 $\\hat{X}_3 = X_3$，则为 $\\mathrm{True}$，否则为 $\\mathrm{False}$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个逗号分隔的布尔值列表，并用方括号括起来（例如，“[True,False,True,False]”），顺序为案例 A、案例 B、案例 C、案例 D。\n\n注意事项和要求：\n- 所有量均为无量纲计数；不涉及物理单位。\n- 不涉及角度。\n- 不要使用百分号；不需要百分比。\n- 严格根据所提供的定义设计你的预测器。不要对答案进行硬编码。\n- 确保你的程序是自包含的，并且不读取任何输入。", "solution": "所陈述的问题是有效的。它在数论和密码学领域有科学依据，问题设定良好，目标明确且可实现，没有歧义或矛盾。它正确地构建了统计随机序列（可能可以预测）和密码学安全序列（设计为不可预测）之间的基本二分法。因此，我们将着手提供一个完整的解决方案。\n\n任务是通过在观察到三个连续项后尝试预测序列中的下一项，来区分线性同余生成器 (LCG) 和密码学安全伪随机数生成器 (CSPRNG)。预测的成功与否用于对生成器进行分类。\n\nLCG 由以下线性递推关系定义：\n$$X_{t+1} \\equiv a X_t + c \\pmod{m}$$\n其中 $a$ 是乘数，$c$ 是增量，$m$ 是模数。这种线性结构是其关键弱点。给定三个观察到的连续状态 $x_0$、$x_1$ 和 $x_2$，我们可以构建一个包含两个未知数 a 和 c 的两个线性同余方程组：\n$$\n\\begin{cases}\nx_1 \\equiv a x_0 + c \\pmod{m} \\\\\nx_2 \\equiv a x_1 + c \\pmod{m}\n\\end{cases}\n$$\n为了解出未知参数，我们首先通过从第二个同余方程中减去第一个来消去 $c$：\n$$x_2 - x_1 \\equiv (a x_1 + c) - (a x_0 + c) \\pmod{m}$$\n$$x_2 - x_1 \\equiv a (x_1 - x_0) \\pmod{m}$$\n令 $\\Delta_0 = x_1 - x_0$ 和 $\\Delta_1 = x_2 - x_1$。该同余方程简化为 $\\Delta_1 \\equiv a \\Delta_0 \\pmod{m}$。我们可以通过乘以 $\\Delta_0$ 对模 $m$ 的模乘法逆元来解出 $a$。这个逆元 $\\Delta_0^{-1}$ 存在的充分必要条件是 $\\text{gcd}(\\Delta_0, m) = 1$。测试用例使用了素数模数 $m$，对于这些模数，除非 $\\Delta_0$ 是 $m$ 的倍数，即 $x_1 \\equiv x_0 \\pmod{m}$，否则此条件成立。假设 $x_1 \\not\\equiv x_0 \\pmod{m}$，我们可以为乘数 $\\hat{a}$ 找到一个唯一解：\n$$\\hat{a} \\equiv \\Delta_1 \\cdot (\\Delta_0 \\pmod m)^{-1} \\pmod{m}$$\n一旦确定了 $\\hat{a}$，我们将其代入第一个同余方程以求解增量 $\\hat{c}$：\n$$\\hat{c} \\equiv x_1 - \\hat{a} x_0 \\pmod{m}$$\n恢复参数 $(\\hat{a}, \\hat{c})$ 后，我们可以使用 LCG 递推关系预测下一个状态 $\\hat{x}_3$：\n$$\\hat{x}_3 \\equiv \\hat{a} x_2 + \\hat{c} \\pmod{m}$$\n如果观察到的序列确实是由 LCG 生成的，我们恢复的参数 $(\\hat{a}, \\hat{c})$ 将与生成器的真实参数相同，我们的预测 $\\hat{x}_3$ 将等于真实状态 $X_3$。\n\n相比之下，密码学安全生成器被设计为使此类预测在计算上不可行。其定义为：\n$$X_t \\equiv \\mathrm{int}\\big(H(s \\,\\|\\, \\mathrm{encode}_{8}(t))\\big) \\bmod m$$\n这里，$H$ 是 SHA-256 密码学哈希函数。输出 $X_t$ 是一个简单计数器 $t$ 的复杂非线性变换。连续项 $X_t$ 和 $X_{t+1}$ 之间没有简单的代数关系。虽然我们的预测器仍然可以应用于来自此生成器的序列——它总是会找到一些 LCG 参数 $(\\hat{a}, \\hat{c})$ 来拟合任意三个点 $(x_0, x_1, x_2)$（只要 $x_1 \\not\\equiv x_0 \\pmod m$）——但这些参数只是偶然产物。它们描述了一条穿过三个有效随机点的线，与底层的生成过程无关。真实的下一个状态 $X_3$ 由在 $t=3$ 处对哈希函数的独立求值确定。我们的预测 $\\hat{x}_3$ 与 $X_3$ 相匹配的概率极小，约为 $1/m$。\n\n因此，我们的算法将为每个测试用例生成真实序列 $(X_0, X_1, X_2, X_3)$，将 LCG 预测器应用于 $(X_0, X_1, X_2)$ 以计算 $\\hat{X}_3$，并报告 $\\hat{X}_3 = X_3$ 是否成立。我们预期所有 LCG 案例都会得到肯定结果，而 CSPRNG 案例则会得到否定结果，从而证明不可预测性原理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport hashlib\n\ndef solve():\n    \"\"\"\n    Main function to run the prediction tests and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"name\": \"Case A (LCG, happy path)\",\n            \"type\": \"lcg\",\n            \"m\": 2147483647,\n            \"a\": 48271,\n            \"c\": 0,\n            \"x0\": 12345,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case B (LCG, nonzero increment)\",\n            \"type\": \"lcg\",\n            \"m\": 1000003,\n            \"a\": 35011,\n            \"c\": 7919,\n            \"x0\": 424242,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case C (LCG, boundary where a = 1)\",\n            \"type\": \"lcg\",\n            \"m\": 101,\n            \"a\": 1,\n            \"c\": 1,\n            \"x0\": 17,\n            \"seed\": None,\n        },\n        {\n            \"name\": \"Case D (cryptographically secure generator)\",\n            \"type\": \"csg\",\n            \"m\": 4294967291,\n            \"a\": None,\n            \"c\": None,\n            \"x0\": None,\n            \"seed\": b\"econ-secure\",\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        # Generate the ground-truth sequence of 4 states (X0, X1, X2, X3)\n        if case[\"type\"] == \"lcg\":\n            true_sequence = generate_lcg_sequence(\n                case[\"m\"], case[\"a\"], case[\"c\"], case[\"x0\"], 4\n            )\n        elif case[\"type\"] == \"csg\":\n            true_sequence = generate_csg_sequence(case[\"m\"], case[\"seed\"], 4)\n        else:\n            raise ValueError(f\"Unknown generator type: {case['type']}\")\n\n        x0, x1, x2, x3_true = true_sequence\n\n        # Predict the next state assuming an LCG model\n        x3_pred = predict_next_lcg(case[\"m\"], x0, x1, x2)\n\n        # Compare the prediction with the true state\n        results.append(x3_pred == x3_true)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef generate_lcg_sequence(m, a, c, x0, count):\n    \"\"\"\n    Generates a sequence of numbers from a Linear Congruential Generator.\n    X_{t+1} = (a * X_t + c) % m\n    \"\"\"\n    sequence = []\n    x_current = x0\n    for _ in range(count):\n        sequence.append(x_current)\n        x_current = (a * x_current + c) % m\n    return sequence\n\ndef generate_csg_sequence(m, seed, count):\n    \"\"\"\n    Generates a sequence from a SHA-256 counter-based generator.\n    X_t = int(SHA256(seed || encode_8(t))) % m\n    \"\"\"\n    sequence = []\n    for t in range(count):\n        t_bytes = t.to_bytes(8, 'big')\n        data_to_hash = seed + t_bytes\n        h = hashlib.sha256(data_to_hash).digest()\n        int_hash = int.from_bytes(h, 'big')\n        x_t = int_hash % m\n        sequence.append(x_t)\n    return sequence\n\ndef predict_next_lcg(m, x0, x1, x2):\n    \"\"\"\n    Predicts the next state (x3) from three previous states (x0, x1, x2)\n    by inferring the parameters of an LCG.\n    \"\"\"\n    # System to solve for a_hat, c_hat:\n    # x1 = a*x0 + c (mod m)\n    # x2 = a*x1 + c (mod m)\n    # Subtracting gives: x2 - x1 = a * (x1 - x0) (mod m)\n    \n    delta0 = (x1 - x0) % m\n    delta1 = (x2 - x1) % m\n\n    try:\n        # To solve a_hat * delta0 = delta1 (mod m), we need the modular inverse of delta0.\n        # pow(base, -1, mod) computes this efficiently.\n        inv_delta0 = pow(delta0, -1, m)\n        a_hat = (delta1 * inv_delta0) % m\n    except ValueError:\n        # This occurs if gcd(delta0, m) != 1. Since all test case moduli are prime,\n        # this only happens if delta0 = 0 (mod m), i.e., x1 == x0.\n        # If x1 = x0, the congruence is 0 = delta1 (mod m), so we must have x2 = x1.\n        if delta1 == 0:  # Case x0 = x1 = x2, a constant sequence\n            # The recurrence is x0 = a*x0 + c. Prediction for x3 is a*x2 + c = a*x0 + c = x0.\n            # So, the next term is also x0 (or x2, which is the same).\n            return x2\n        else: # Case x0 = x1 but x2 != x1.\n            # This sequence cannot be from an LCG. As per problem, we must return a prediction.\n            # We choose a default of 0.\n            return 0\n\n    # Solve for c_hat using c_hat = x1 - a_hat * x0 (mod m)\n    c_hat = (x1 - a_hat * x0) % m\n\n    # Predict x3_hat = a_hat * x2 + c_hat (mod m)\n    x3_hat = (a_hat * x2 + c_hat) % m\n\n    return x3_hat\n\nsolve()\n```", "id": "2423284"}]}