{"hands_on_practices": [{"introduction": "在深入研究价值函数迭代的编程实现之前，我们首先通过一个基础计算来理解其面临的根本性挑战：“维度灾难”。这个练习 [@problem_id:2439741] 将让您亲身体会到，随着状态变量的增加，问题的计算规模会如何爆炸式增长。这突显了为何在计算经济学中，开发和使用高效算法是如此关键。", "problem": "在一个计算经济学应用中，考虑通过对一个离散化的连续状态向量进行价值函数迭代，来求解一个有限状态马尔可夫决策过程 (MDP) 的动态问题。该状态向量是$d$维的，并且状态向量的每个分量都被离散化为$10$个等间距的区间。假设在状态空间上形成了一个正则笛卡尔网格。\n\n计算当$d=2$和$d=10$时，不同网格单元的总数。以对应于$\\left(d=2,\\ d=10\\right)$的有序对形式提供您的答案。报告精确值，无需四舍五入。不需要单位。", "solution": "首先将对问题陈述进行严格的验证过程。\n\n步骤1：提取已知条件。\n问题陈述中提供的明确数据如下：\n- 背景是计算经济学中的一个有限状态马尔可夫决策过程 (MDP)。\n- 求解方法是对一个离散化的连续状态向量进行价值函数迭代。\n- 状态向量是$d$维的。\n- 状态向量的每个分量被离散化为$10$个等间距的区间。\n- 网格结构是状态空间上的一个正则笛卡尔网格。\n- 任务是计算在维度$d=2$和维度$d=10$两种情况下，不同网格单元的总数。\n- 答案必须以对应于$(d=2, d=10)$的有序对形式提供。\n- 数值必须是精确的。\n\n步骤2：使用提取的已知条件进行验证。\n根据所需标准对问题进行评估。\n- **科学依据**：该问题基于动态规划和计算经济学这一成熟领域。将连续状态空间离散化为笛卡尔网格是求解连续状态MDPs近似解的标准技术。本问题所阐释的“维度灾难”是该领域的一个基本概念。因此，该问题在科学上是合理的。\n- **适定性**：该问题是适定的。它提供了计算唯一、确定性答案所需的所有信息。每个维度的区间数量和维度本身都已指定，网格的结构也明确定义为笛卡尔式。\n- **客观性**：该问题以精确、技术性和客观的语言陈述，没有任何主观或模糊的术语。\n\n基于此分析，该问题被认为是有效的，可以推导出解决方案。\n\n该问题要求计算离散化状态空间中的状态总数。在此背景下，一个状态是多维网格中的单个网格单元。\n\n设状态向量的维度表示为$d$。\n设每个维度的离散化区间数（或称“箱”）表示为$N$。\n根据问题陈述，我们已知$N = 10$。\n\n状态空间由一个正则笛卡尔网格构成。这意味着对于$d$个维度中的每一个，我们都从$N$个可用区间中选择一个。一个特定的状态由所有维度上区间选择的唯一组合来定义。\n\n对于一个通用维度$d$，不同网格单元的总数（我们将其表示为$S_d$）是所有可能组合的总数。由于第一个维度有$N$个选择，第二个维度有$N$个选择，依此类推，直到第$d$个维度，因此组合总数是每个维度选择数量的乘积。\n\n$$S_d = \\underbrace{N \\times N \\times \\dots \\times N}_{d \\text{ times}}$$\n\n这可以表示为指数形式：\n\n$$S_d = N^{d}$$\n\n状态数量与维度之间的这种指数关系是“维度灾难”的数学基础。随着$d$的增加，状态空间的大小$S_d$呈指数级增长，使得像价值函数迭代这样的穷举计算方法变得不可行。\n\n问题要求我们计算在$d$的两个特定值（$d=2$和$d=10$）下$S_d$的值。\n\n情况1：$d=2$\n对于一个$2$维状态空间，我们将$d=2$和$N=10$代入公式：\n$$S_2 = N^{2} = 10^{2} = 100$$\n因此，对于一个$2$维问题，状态空间被离散化为$100$个单元。\n\n情况2：$d=10$\n对于一个$10$维状态空间，我们将$d=10$和$N=10$代入公式：\n$$S_{10} = N^{10} = 10^{10} = 10,000,000,000$$\n对于一个$10$维问题，状态空间被离散化为一百亿个单元。这种急剧的增加鲜明地说明了更高维度带来的计算负担。\n\n最终答案应表示为有序对$(S_2, S_{10})$。\n因此，该有序对为$(100, 10^{10})$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n100  10^{10}\n\\end{pmatrix}\n}\n$$", "id": "2439741"}, {"introduction": "现在，让我们亲自动手，从零开始实现价值函数迭代算法。在这个核心练习 [@problem_id:2446471] 中，您将解决一个包含资本和随机生产率双重状态变量的标准消费—储蓄模型，这是现代宏观经济学的基石。通过这个练习，您将巩固对贝尔曼算子的理解，并学会如何将经济理论转化为可执行的计算模型。", "problem": "考虑一个无限期界的消费—储蓄问题，其中单一代表性行为人面临由物质资本和外生生产率水平组成的二维状态。时间是离散的，由 $t \\in \\{0,1,2,\\dots\\}$ 索引。时期效用函数为恒定相对风险规避 (CRRA) 形式，对于消费 $c_t$ 定义为\n$$\nu(c_t) = \n\\begin{cases}\n\\dfrac{c_t^{1-\\sigma}}{1-\\sigma},  \\text{如果 } \\sigma \\neq 1, \\\\\n\\log(c_t),  \\text{如果 } \\sigma = 1,\n\\end{cases}\n$$\n其中 $\\sigma  0$ 是相对风险规避系数。生产技术为 Cobb–Douglas 形式，资本份额参数为 $\\alpha \\in (0,1)$，折旧率为 $\\delta \\in (0,1)$，因此产出为 $y_t = z_t k_t^{\\alpha}$，资本运动规律满足\n$$\nc_t + k_{t+1} = z_t k_t^{\\alpha} + (1 - \\delta) k_t,\n$$\n同时满足非负约束 $c_t \\ge 0$ 和借贷约束 $k_{t+1} \\ge 0$。贴现因子为 $\\beta \\in (0,1)$。\n\n外生生产率状态 $z_t$ 在一个有限网格 $\\{z_1,\\dots,z_{N_z}\\}$ 上取值，并遵循一个时齐马尔可夫链，其转移矩阵为 $P \\in \\mathbb{R}^{N_z \\times N_z}$，其中 $P_{ij} = \\mathbb{P}(z_{t+1}=z_j \\mid z_t=z_i)$，且 $P$ 的每一行之和为 1。\n\n将价值函数 $V(k,z)$ 定义为从状态 $(k,z)$ 出发，所有可行计划下效用期望贴现和的上确界。该价值函数满足贝尔曼方程\n$$\nV(k,z) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(z k^{\\alpha} + (1-\\delta)k - k' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\mathbb{P}(z' \\mid z) V(k', z') \\right\\},\n$$\n其中 $\\mathcal{Z} = \\{z_1,\\dots,z_{N_z}\\}$，$\\mathcal{K}$ 是资本选择的离散网格。可行集的特征是 $k' \\in \\mathcal{K}$ 且满足 $z k^{\\alpha} + (1-\\delta)k - k' \\ge 0$。\n\n你的程序必须：\n- 将资本空间离散化为一个包含 $N_k$ 个点（包括端点）的等距网格 $\\mathcal{K} = \\{k_{\\min}, k_{\\min} + \\Delta k, \\dots, k_{\\max}\\}$。\n- 计算贝尔曼方程在笛卡尔积 $\\mathcal{K} \\times \\mathcal{Z}$ 上的唯一不动点，以及相关的、限制在 $\\mathcal{K}$ 上的下一期资本策略函数 $k'(k,z)$。\n- 对于下述每个测试用例，报告以下五个量：\n  1. 满足停止准则所用的迭代次数。\n  2. 在资本网格中位数索引和冲击中位数索引处求值的价值函数，即 $V\\!\\left(k_{\\lfloor (N_k-1)/2 \\rfloor+1}, z_{\\lfloor (N_z-1)/2 \\rfloor+1}\\right)$。\n  3. 在最低资本和最低冲击下的最优下一期资本，即 $k'(k_{\\min}, z_{\\min})$。\n  4. 一个布尔值，表示对于每个固定的冲击 $z$，策略 $k'(k,z)$ 在整个资本网格上是否关于 $k$ 弱增。\n  5. 在内部状态（不包括策略在 $(k,z)$ 处选择最低或最高资本网格点，或任何隐含消费为非正的状态）上的最大绝对欧拉方程残差，其中状态 $(k,z)$ 的残差定义为\n     $$\n     \\left| 1 - \\dfrac{\\beta \\, \\mathbb{E}\\!\\left[ u'(c') \\left( \\alpha z' k'^{\\alpha - 1} + 1 - \\delta \\right) \\,\\big|\\, z \\right]}{u'(c)} \\right|,\n     $$\n     其中 $c = z k^{\\alpha} + (1-\\delta)k - k'$, $k' = k'(k,z)$, $c' = z' k'^{\\alpha} + (1-\\delta)k' - k''$, 且 $k'' = k'(k', z')$。此处 $u'(c)$ 表示消费的边际效用。\n\n使用以下测试套件。对于每个测试用例，使用指定的参数、冲击网格、转移矩阵和资本网格：\n\n- 测试用例 A (基准)：\n  - $\\beta = 0.96$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.08$。\n  - 冲击网格: $N_z = 3$ 且 $z = [0.9, 1.0, 1.1]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.90  0.09  0.01 \\\\\n    0.09  0.82  0.09 \\\\\n    0.01  0.09  0.90\n    \\end{bmatrix}.\n    $$\n  - 资本网格: $N_k = 80$, $k_{\\min} = 0.01$, $k_{\\max} = 3.0$。\n\n- 测试用例 B (较低耐心和更易变的冲击)：\n  - $\\beta = 0.90$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.08$。\n  - 冲击网格: $N_z = 3$ 且 $z = [0.8, 1.0, 1.2]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.85  0.10  0.05 \\\\\n    0.10  0.80  0.10 \\\\\n    0.05  0.10  0.85\n    \\end{bmatrix}.\n    $$\n  - 资本网格: $N_k = 60$, $k_{\\min} = 0.01$, $k_{\\max} = 3.0$。\n\n- 测试用例 C (较高耐心和较低折旧)：\n  - $\\beta = 0.985$, $\\sigma = 2.0$, $\\alpha = 0.36$, $\\delta = 0.02$。\n  - 冲击网格: $N_z = 3$ 且 $z = [0.95, 1.0, 1.05]$。\n  - 转移矩阵\n    $$\n    P = \\begin{bmatrix}\n    0.92  0.07  0.01 \\\\\n    0.07  0.86  0.07 \\\\\n    0.01  0.07  0.92\n    \\end{bmatrix}.\n    $$\n  - 资本网格: $N_k = 100$, $k_{\\min} = 0.01$, $k_{\\max} = 4.0$。\n\n停止准则和数值约定：\n- 在 $\\mathcal{K} \\times \\mathcal{Z}$ 上任意初始化价值函数。\n- 对贝尔曼方程进行迭代，直到连续的价值函数迭代值之间的上确界范数距离小于 $\\varepsilon = 10^{-6}$，或达到最大迭代次数 $N_{\\text{iter},\\max} = 1000$。\n- 计算效用时，将任何 $c \\le 0$ 的消费视为不可行。你必须强制 $c \\ge 0$；在最大化过程中不得选择任何不可行的选项。\n\n最终输出格式：\n- 你的程序应产生单行输出，包含一个含三个子列表的列表，按 A、B、C 的顺序每个测试用例一个。每个子列表必须按上述顺序包含五个量：$[\\text{iterations}, V_{\\text{mid}}, k'_{\\text{min,low}~z}, \\text{is\\_monotone}, \\text{max\\_Euler\\_residual}]$。\n- 所有浮点数必须四舍五入到六位小数；布尔值必须是 True 或 False。\n- 具体来说，输出必须如下所示\n  $$\n  \\big[ [n_A, v_A, k_A, b_A, e_A], [n_B, v_B, k_B, b_B, e_B], [n_C, v_C, k_C, b_C, e_C] \\big],\n  $$\n  打印为单行，括号和逗号完全如上所示，其中 $n_\\cdot$ 是整数，$v_\\cdot, k_\\cdot, e_\\cdot$ 是四舍五入到六位小数的浮点数，$b_\\cdot$ 是布尔值。", "solution": "该问题是一个平稳的、无限期界的动态规划问题，具有紧凑的离散化状态空间和可行集上的有界回报函数。将有界函数映射到有界函数的贝尔曼算子 $T$ 对于 $(k,z) \\in \\mathcal{K} \\times \\mathcal{Z}$ 逐点定义为\n$$\n(TV)(k,z) = \\max_{k' \\in \\mathcal{K}} \\left\\{ u\\!\\left(z k^{\\alpha} + (1 - \\delta)k - k' \\right) + \\beta \\sum_{z' \\in \\mathcal{Z}} \\mathbb{P}(z' \\mid z) V(k', z') \\right\\}.\n$$\n根据 Blackwell 充分条件，$T$ 是有界函数空间上关于上确界范数的压缩映射：它是单调的，因为如果 $V \\le W$，则 $TV \\le TW$；它满足贴现性质，因为对于任何常数 $a$，都有 $(TV + a)(k,z) \\le (TV)(k,z) + \\beta a$，其模为 $\\beta \\in (0,1)$。因此，$T$ 有一个唯一的不动点 $V^\\star$，并且对于任何初始的 $V_0$，序列 $V_{n+1} = TV_n$ 在上确界范数下收敛到 $V^\\star$。\n\n为了数值计算不动点，我们在相同的有限网格 $\\mathcal{K} = \\{k_1,\\dots,k_{N_k}\\}$ 上离散化资本状态和决策 $k'$，并在 $\\mathcal{Z} = \\{z_1,\\dots,z_{N_z}\\}$ 上离散化外生冲击空间。对于每个冲击 $z_j$ 和每个当前资本 $k_i$，我们枚举所有候选的下一期资本 $k' \\in \\mathcal{K}$，计算隐含的消费 $c = z_j k_i^{\\alpha} + (1 - \\delta) k_i - k'$，丢弃 $c \\le 0$ 的不可行候选者，评估时期效用 $u(c)$，并加上贴现的期望持续价值 $\\beta \\sum_{m=1}^{N_z} P_{j m} V(k', z_m)$。对 $k'$ 的最大化者产生更新后的价值和相应的策略索引。这种构造以向量化的方式实现了应用于价值函数迭代值的贝尔曼算子。重复此更新，直到连续迭代值之间的上确界范数距离小于 $\\varepsilon = 10^{-6}$（或达到迭代上限），即可得到 $V^\\star$ 及其相关策略函数 $k'(k,z)$ 的一个 $\\varepsilon$-精确近似。\n\n一旦获得策略，我们评估额外的诊断指标：\n\n- 中位数索引处的价值：令 $i^\\star = \\left\\lfloor \\dfrac{N_k - 1}{2} \\right\\rfloor + 1$ 且 $j^\\star = \\left\\lfloor \\dfrac{N_z - 1}{2} \\right\\rfloor + 1$。报告 $V(k_{i^\\star}, z_{j^\\star})$。\n\n- 边界状态 $(k_{\\min}, z_{\\min})$ 处的最优下一期资本：报告 $k'(k_1, z_1)$。\n\n- 策略在资本上的单调性：对于每个固定的冲击 $z_j$，验证映射 $i \\mapsto k'(k_i, z_j)$ 对于 $i = 1,\\dots,N_k$ 是否是弱增的。在标准的凹增长模型中，此属性受到贝尔曼算子的单调性和凹性的理论支持，尽管数值离散化可能会引入微小的违例。我们通过检查所有相邻对来计算该布尔值。\n\n- 欧拉方程残差：内部解的一阶条件断言\n$$\nu'(c_t) = \\beta \\, \\mathbb{E} \\left[ u'(c_{t+1}) \\left( \\alpha z_{t+1} k_{t+1}^{\\alpha - 1} + 1 - \\delta \\right) \\bigg| z_t \\right].\n$$\n使用离散策略 $k' = k'(k,z)$ 和关于 $z$ 的马尔可夫链，我们将每个内部状态 $(k_i, z_j)$ 的残差近似为\n$$\nR(k_i,z_j) = \\left| 1 - \\dfrac{\\beta \\sum_{m=1}^{N_z} P_{j m} \\, u'(c'(k_i,z_j; z_m)) \\, \\left( \\alpha z_m \\, k'(k_i,z_j)^{\\alpha - 1} + 1 - \\delta \\right)}{u'(c(k_i,z_j))} \\right|,\n$$\n其中 $c(k_i,z_j) = z_j k_i^{\\alpha} + (1 - \\delta) k_i - k'(k_i,z_j)$ 且 $c'(k_i,z_j; z_m) = z_m k'(k_i,z_j)^{\\alpha} + (1 - \\delta) k'(k_i,z_j) - k''$，其中 $k'' = k'(k'(k_i,z_j), z_m)$。我们排除了策略选择最低或最高 $k'$ 的状态（以避免角点解），以及任何 $c$ 或 $c'$ 为非正的状态。在其余状态中，最大残差衡量了离散策略相对于欧拉条件的全局质量。\n\n数值细节：\n- 对于 $\\sigma \\neq 1$ 的 CRRA， $u'(c) = c^{-\\sigma}$。对于 $\\sigma = 1$，可以使用 $u(c) = \\log(c)$ 和 $u'(c) = 1/c$；实现中兼容这两种情况。\n- 可行性 $c \\ge 0$ 是通过在最大化步骤中为不可行选择分配负无穷大的值来强制执行的，从而确保它们永远不会被选中。\n- 对于一个固定的当前冲击 $z_j$ 和候选的 $k'$，期望持续价值是通过 $P$ 与在 $k'$ 处求值的、关于 $z'$ 的堆叠价值函数进行行式乘积来计算的。\n\n将此程序应用于三个指定的测试用例及其给定的参数、冲击网格、转移矩阵和资本网格，可以为每个用例得出五个所要求的输出：迭代次数、中位数索引处的价值、在 $(k_{\\min}, z_{\\min})$ 处的策略、单调性布尔值以及最大欧拉残差。所有浮点输出都四舍五入到六位小数，最终打印为一个按要求结构的单行列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef crra_utility(c, sigma):\n    \"\"\"CRRA utility u(c); returns -inf for nonpositive c to enforce feasibility.\"\"\"\n    c = np.asarray(c)\n    u = np.full_like(c, -np.inf, dtype=np.float64)\n    positive = c  0\n    if sigma == 1.0:\n        u[positive] = np.log(c[positive])\n    else:\n        u[positive] = (np.power(c[positive], 1.0 - sigma)) / (1.0 - sigma)\n    return u\n\ndef crra_marginal_utility(c, sigma):\n    \"\"\"Marginal utility u'(c) for CRRA; returns nan for nonpositive c.\"\"\"\n    c = np.asarray(c)\n    mu = np.full_like(c, np.nan, dtype=np.float64)\n    positive = c  0\n    if sigma == 1.0:\n        mu[positive] = 1.0 / c[positive]\n    else:\n        mu[positive] = np.power(c[positive], -sigma)\n    return mu\n\ndef vfi(k_grid, z_grid, P, beta, sigma, alpha, delta, tol=1e-6, max_iter=1000):\n    \"\"\"\n    Perform value function iteration on discretized grids.\n    Returns:\n        V: value function array shape (Nz, Nk)\n        policy_idx: optimal k' indices shape (Nz, Nk)\n        iters: iterations performed\n    \"\"\"\n    Nz = len(z_grid)\n    Nk = len(k_grid)\n    V = np.zeros((Nz, Nk), dtype=np.float64)\n    V_new = np.empty_like(V)\n    policy_idx = np.zeros((Nz, Nk), dtype=np.int64)\n\n    # Precompute resources y[j, i] = z_j * k_i^alpha + (1 - delta) * k_i\n    k_alpha = np.power(k_grid, alpha)\n    y = (z_grid[:, None] * k_alpha[None, :]) + (1.0 - delta) * k_grid[None, :]\n\n    # For each shock z_j, continuation value over k' is beta * P[j] @ V_old\n    iters = 0\n    diff = np.inf\n    neg_inf = -1.0e12  # numerical -inf surrogate for infeasible choices\n    while iters  max_iter and diff > tol:\n        # Expected continuation values for choosing each k' at current shock j\n        # EV has shape (Nz, Nk): for each j, EV[j, k_idx] = beta * sum_m P[j, m] * V[m, k_idx]\n        EV = beta * (P @ V)\n        # Loop over shocks to form return matrices and maximize w.r.t k'\n        for j in range(Nz):\n            # consumption matrix for current shock j: C[i, kprime] = y[j,i] - k_grid[kprime]\n            C = y[j, :, None] - k_grid[None, :]\n            U = crra_utility(C, sigma)\n            # mask infeasible as neg_inf to avoid NaNs in max\n            U[~np.isfinite(U)] = neg_inf\n            # add continuation value for each k' (broadcast across current k_i)\n            # total return W[i, kprime]\n            W = U + EV[j][None, :]\n            # maximize over k' axis=1\n            pol_idx = np.argmax(W, axis=1)\n            V_new[j, :] = W[np.arange(Nk), pol_idx]\n            policy_idx[j, :] = pol_idx\n\n        diff = np.max(np.abs(V_new - V))\n        V[:, :] = V_new\n        iters += 1\n\n    return V, policy_idx, iters\n\ndef policy_monotone(policy_idx):\n    \"\"\"\n    Check monotonicity of policy in k for each z: nondecreasing indices across k.\n    Returns True if monotone for all z, else False.\n    \"\"\"\n    Nz, Nk = policy_idx.shape\n    for j in range(Nz):\n        if np.any(np.diff(policy_idx[j, :])  0):\n            return False\n    return True\n\ndef euler_residual_max(k_grid, z_grid, P, beta, sigma, alpha, delta, policy_idx):\n    \"\"\"\n    Compute the maximum absolute Euler residual over interior states.\n    Excludes states where policy picks boundary k' or any implied c or c' is nonpositive.\n    Residual at (k_i, z_j): |1 - RHS / LHS| with LHS = u'(c), RHS = beta * E[u'(c') * (alpha z' k'^{alpha-1} + 1 - delta)].\n    \"\"\"\n    Nz = len(z_grid)\n    Nk = len(k_grid)\n    # Precompute\n    k_alpha = np.power(k_grid, alpha)\n    y = (z_grid[:, None] * k_alpha[None, :]) + (1.0 - delta) * k_grid[None, :]\n\n    max_resid = 0.0\n    # Iterate over states\n    for j in range(Nz):\n        for i in range(Nk):\n            kp_idx = policy_idx[j, i]\n            # exclude boundary policies\n            if kp_idx == 0 or kp_idx == Nk - 1:\n                continue\n            k = k_grid[i]\n            z = z_grid[j]\n            kp = k_grid[kp_idx]\n            # Current consumption\n            c = z * (k ** alpha) + (1.0 - delta) * k - kp\n            if c = 0:\n                continue\n            mu_c = (1.0 / c) if sigma == 1.0 else c ** (-sigma)\n            # Next period marginal utility and returns term\n            # For each z' compute c' and k'' = policy(k', z')\n            kp_alpha = kp ** alpha\n            # Precompute gross return at next period given z'\n            R_terms = alpha * z_grid * (kp ** (alpha - 1.0)) + (1.0 - delta)\n            # Compute c' for each z'\n            y_next = z_grid * kp_alpha + (1.0 - delta) * kp  # shape (Nz,)\n            # For each z' state m, need k'' index policy_idx[m, kp_idx]\n            kpp_idx_vec = policy_idx[:, kp_idx]  # shape (Nz,)\n            kpp_vec = k_grid[kpp_idx_vec]        # shape (Nz,)\n            c_next = y_next - kpp_vec            # shape (Nz,)\n            # Exclude if any c' is nonpositive by setting their marginal utility to nan and ignoring via weights\n            mu_c_next = crra_marginal_utility(c_next, sigma)  # nan where nonpositive\n            # Expected RHS conditional on current z_j using P[j, :]\n            valid = np.isfinite(mu_c_next)\n            if not np.any(valid):\n                continue\n            RHS = beta * np.sum(P[j, valid] * mu_c_next[valid] * R_terms[valid])\n            resid = abs(1.0 - RHS / mu_c)\n            if np.isfinite(resid):\n                if resid > max_resid:\n                    max_resid = resid\n    return float(max_resid)\n\ndef run_test_case(params):\n    beta = params[\"beta\"]\n    sigma = params[\"sigma\"]\n    alpha = params[\"alpha\"]\n    delta = params[\"delta\"]\n    z = np.array(params[\"z\"], dtype=np.float64)\n    P = np.array(params[\"P\"], dtype=np.float64)\n    Nk = params[\"Nk\"]\n    k_min = params[\"k_min\"]\n    k_max = params[\"k_max\"]\n    k_grid = np.linspace(k_min, k_max, Nk, dtype=np.float64)\n\n    V, pol_idx, iters = vfi(k_grid, z, P, beta, sigma, alpha, delta, tol=1e-6, max_iter=1000)\n\n    # Median indices\n    mid_k_idx = (Nk - 1) // 2\n    mid_z_idx = (len(z) - 1) // 2\n    V_mid = V[mid_z_idx, mid_k_idx]\n    # Policy at (k_min, z_min)\n    kp_min_lowz = k_grid[pol_idx[0, 0]]\n    # Monotonicity\n    is_mono = policy_monotone(pol_idx)\n    # Euler residual\n    max_euler_resid = euler_residual_max(k_grid, z, P, beta, sigma, alpha, delta, pol_idx)\n\n    # Round floats to six decimals\n    result = [\n        int(iters),\n        round(float(V_mid), 6),\n        round(float(kp_min_lowz), 6),\n        bool(is_mono),\n        round(float(max_euler_resid), 6),\n    ]\n    return result\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"name\": \"A\",\n            \"beta\": 0.96,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.08,\n            \"z\": [0.9, 1.0, 1.1],\n            \"P\": [\n                [0.90, 0.09, 0.01],\n                [0.09, 0.82, 0.09],\n                [0.01, 0.09, 0.90],\n            ],\n            \"Nk\": 80,\n            \"k_min\": 0.01,\n            \"k_max\": 3.0,\n        },\n        {\n            \"name\": \"B\",\n            \"beta\": 0.90,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.08,\n            \"z\": [0.8, 1.0, 1.2],\n            \"P\": [\n                [0.85, 0.10, 0.05],\n                [0.10, 0.80, 0.10],\n                [0.05, 0.10, 0.85],\n            ],\n            \"Nk\": 60,\n            \"k_min\": 0.01,\n            \"k_max\": 3.0,\n        },\n        {\n            \"name\": \"C\",\n            \"beta\": 0.985,\n            \"sigma\": 2.0,\n            \"alpha\": 0.36,\n            \"delta\": 0.02,\n            \"z\": [0.95, 1.0, 1.05],\n            \"P\": [\n                [0.92, 0.07, 0.01],\n                [0.07, 0.86, 0.07],\n                [0.01, 0.07, 0.92],\n            ],\n            \"Nk\": 100,\n            \"k_min\": 0.01,\n            \"k_max\": 4.0,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_test_case(case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # Ensure booleans and numbers are printed without extra spaces.\n    def format_item(x):\n        if isinstance(x, bool):\n            return \"True\" if x else \"False\"\n        elif isinstance(x, (int, np.integer)):\n            return str(int(x))\n        elif isinstance(x, float) or isinstance(x, np.floating):\n            # Ensure fixed rounding to 6 decimals; preserve trailing zeros\n            return f\"{x:.6f}\"\n        else:\n            return str(x)\n\n    formatted = []\n    for res in results:\n        formatted.append(\"[\" + \",\".join(format_item(x) for x in res) + \"]\")\n    print(\"[\" + \",\".join(formatted) + \"]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2446471"}, {"introduction": "真实的经济模型常常包含随状态而变的约束条件。这个练习 [@problem_id:2446389] 通过引入依赖于状态的借贷限制，扩展了我们的价值函数迭代工具箱。您将学习如何修改算法，以处理随当前状态 $s$ 而变化的可行动作集 $\\mathcal{A}(s)$，这是构建更贴近现实模型的一项关键技能。", "problem": "考虑一个具有离散资产和两种收入状态的无限期消费-储蓄问题。状态是一个对 $s = (a, z)$，其中 $a$ 是从一个有限网格中选择的当前资产，$z \\in \\{z_{L}, z_{H}\\}$ 是当前的收入实现。每期效用为 $u(c) = \\log(c)$，其中 $c$ 是消费。资源约束为\n$$\nc + a' = (1 + r)a + z,\n$$\n借贷约束取决于当前的收入状态，\n$$\na' \\ge \\underline{b}(z),\n$$\n以及可行性要求 $c  0$。外生收入过程的转移是马尔可夫过程，转移矩阵为 $P$，其中 $P_{ij} = \\Pr(z' = j \\mid z = i)$。目标是在折现因子 $\\beta \\in (0,1)$ 的情况下最大化期望折现效用，最优值函数 $V(a,z)$ 满足贝尔曼方程\n$$\nV(a,z) = \\max_{a' \\in \\mathcal{A}(z)} \\left\\{ \\log\\left((1+r)a + z - a'\\right) + \\beta \\sum_{z' \\in \\{z_L, z_H\\}} P(z,z') V(a', z') \\right\\},\n$$\n其中可行行动集通过以下方式取决于状态\n$$\n\\mathcal{A}(z) = \\left\\{ a' \\in \\mathcal{G}_A \\,:\\, a' \\ge \\underline{b}(z) \\text{ and } (1+r)a + z - a'  0 \\right\\},\n$$\n且 $\\mathcal{G}_A$ 是给定的资产网格。所有选择都限制在网格 $\\mathcal{G}_A$ 上。\n\n您的任务是，对于下面的每个参数集，在上述定义的模型下，计算指定查询状态 $(a^{\\star}, z^{\\star})$ 处的最优值 $V(a^{\\star}, z^{\\star})$ 以及相应的最优下一期资产选择 $a'^{\\star}$。如果存在多个最大化者，请选择其中最小的 $a'^{\\star}$。所有数值输出必须四舍五入到 $6$ 位小数。\n\n测试套件：\n- 情况 1：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.5,\\,-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\}$。\n  - 收入值 $(z_L, z_H) = (1.0,\\,2.0)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.9  0.1\\\\ 0.2  0.8\\end{bmatrix}$，其中第一行对应于 $z_L$。\n  - 借贷限制 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.5)$。\n  - 折现因子 $\\beta = 0.95$。\n  - 利率 $r = 0.04$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (0.25,\\, z_H)$。\n- 情况 2：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.5,\\,-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75,\\,1.0\\}$。\n  - 收入值 $(z_L, z_H) = (1.0,\\,2.0)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.9  0.1\\\\ 0.2  0.8\\end{bmatrix}$。\n  - 借贷限制 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.5)$。\n  - 折现因子 $\\beta = 0.95$。\n  - 利率 $r = 0.04$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (-0.25,\\, z_L)$。\n- 情况 3：\n  - 资产网格 $\\mathcal{G}_A = \\{-0.25,\\,0.0,\\,0.25,\\,0.5,\\,0.75\\}$。\n  - 收入值 $(z_L, z_H) = (0.5,\\,1.5)$。\n  - 转移矩阵 $P = \\begin{bmatrix}0.95  0.05\\\\ 0.1  0.9\\end{bmatrix}$。\n  - 借贷限制 $(\\underline{b}(z_L), \\underline{b}(z_H)) = (0.0,\\,-0.25)$。\n  - 折现因子 $\\beta = 0.96$。\n  - 利率 $r = 0.02$。\n  - 查询状态 $(a^{\\star}, z^{\\star}) = (0.0,\\, z_L)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。对于每种情况，按顺序报告两个值：最优值 $V(a^{\\star}, z^{\\star})$ 和相应的最优下一期资产 $a'^{\\star}$，每个值都四舍五入到 $6$ 位小数。将所有三种情况的结果顺序汇总到一个扁平列表中。例如，输出格式必须为\n$$\n[\\text{V1},\\text{a1\\_next},\\text{V2},\\text{a2\\_next},\\text{V3},\\text{a3\\_next}],\n$$\n其中每一项都是四舍五入到 $6$ 位小数的十进制数。", "solution": "所呈现的问题是一个标准的有限状态、无限期、离散时间的动态规划问题，是现代量化经济学的基石。我们的任务是通过计算值函数和相关的策略函数来找到代理人消费-储蓄问题的解。解决此类问题的指定方法是值函数迭代（Value Function Iteration, VFI）。\n\n系统的状态由对偶 $s = (a, z)$ 定义，其中 $a$ 是来自离散网格 $\\mathcal{G}_A$ 的资产水平，$z$ 是来自离散集合 $\\{z_L, z_H\\}$ 的随机收入实现。代理人的目标是选择一系列的下一期资产持有量 $a'$，以最大化由对数效用函数 $u(c) = \\log(c)$ 给出的折现单期效用之和的期望值。\n\n问题的核心在于求解贝尔曼方程，这是一个最优值函数 $V(a,z)$ 必须满足的函数方程：\n$$V(a,z) = \\max_{a' \\in \\mathcal{A}(a,z)} \\left\\{ \\log\\left((1+r)a + z - a'\\right) + \\beta \\sum_{z' \\in \\{z_L, z_H\\}} P(z,z') V(a', z') \\right\\}$$\n此处，下一期资产的可行选择集 $\\mathcal{A}(a,z)$ 受代理人的借贷限制 $\\underline{b}(z)$ 和正消费的必要性 $c  0$ 的约束。可用的手头现金为 $(1+r)a + z$，这决定了消费的上限，从而也决定了 $a'$ 的选择范围。\n\n贝尔曼方程定义了一个映射，我们称之为贝尔曼算子 $T$，它接受一个候选值函数 $V_k$ 并返回一个更新后的函数 $V_{k+1} = T(V_k)$。对于折现因子 $\\beta \\in (0,1)$，该算子是关于上确界范数的收缩映射。因此，巴拿赫不动点定理保证了存在唯一的不动点 $V^\\star$，使得 $V^\\star = T(V^\\star)$。此外，从任意初始有界函数 $V_0$ 开始迭代该算子，将会收敛到这个唯一解：$\\lim_{k \\to \\infty} T^k(V_0) = V^\\star$。\n\n值函数迭代算法的步骤如下：\n\n1.  **初始化**：状态空间由给定的资产网格 $\\mathcal{G}_A$ 和收入状态 $\\{z_L, z_H\\}$ 进行离散化。这产生了有限数量的状态 $(a_i, z_j)$。我们将值函数表示为一个大小为 $N_a \\times N_z$ 的矩阵 $\\mathbf{V}$，其中 $N_a$ 是 $\\mathcal{G}_A$ 中的点数，$N_z=2$。我们初始化这个矩阵，例如，全部用零初始化：对于所有 $(a,z)$，$V_0(a,z) = 0$。我们还定义一个用于收敛的小容差阈值 $\\epsilon  0$。\n\n2.  **迭代**：我们对每次迭代 $k=0, 1, 2, \\dots$ 重复以下更新步骤，直到收敛。对于我们状态空间中的每个状态 $(a_i, z_j)$：\n    a. 我们使用当前的值函数近似 $V_k$ 计算贝尔曼方程的右侧。这涉及一个最大化问题。对于下一期资产的每个可能选择 $a'_l \\in \\mathcal{G}_A$：\n        i. 我们首先检查选择 $a'_l$ 是否可行。它必须满足依赖于状态的借贷限制 $a'_l \\ge \\underline{b}(z_j)$，并确保正消费 $c_l = (1+r)a_i + z_j - a'_l  0$。\n        ii. 如果可行，我们计算此选择的值，即当前效用与折现期望持续值之和：\n            $$W(a_i, z_j, a'_l) = \\log(c_l) + \\beta \\left( P(z_j, z_L) V_k(a'_l, z_L) + P(z_j, z_H) V_k(a'_l, z_H) \\right)$$\n    b. 状态 $(a_i, z_j)$ 的更新值是所有此类可行选择中的最大值：\n        $$V_{k+1}(a_i, z_j) = \\max_{a'_l \\in \\mathcal{A}(a_i,z_j)} W(a_i, z_j, a'_l)$$\n    c. 我们还存储实现此最大值的选择 $a'_l$。这构成了下一次迭代的策略函数 $g_{k+1}(a_i, z_j)$。问题规定，如果多个最大化者之间出现平局，应选择最小的 $a'$ 值。\n\n3.  **收敛检查**：在更新所有状态的值之后，我们得到一个新的值函数矩阵 $V_{k+1}$。我们通过使用上确界范数测量连续迭代之间的距离来检查收敛性：\n    $$\\text{dist} = \\max_{i,j} | V_{k+1}(a_i, z_j) - V_k(a_i, z_j) |$$\n    如果 $\\text{dist}  \\epsilon$，则过程终止。最终矩阵 $V_{k+1}$ 是我们对真实值函数 $V^\\star$ 的数值近似，而相关的策略函数 $g_{k+1}$ 是最优策略 $g^\\star$。\n\n4.  **报告结果**：一旦算法收敛，我们为每个测试案例确定与查询状态 $(a^\\star, z^\\star)$ 对应的索引。然后我们从最终计算出的矩阵中提取收敛值 $V^\\star(a^\\star, z^\\star)$ 和最优策略选择 $a'^\\star = g^\\star(a^\\star, z^\\star)$。\n\n此数值程序将为所提供的三个参数集中的每一个实施。核心逻辑是相同的，只是各案例之间的参数不同。为了提高效率，计算使用矩阵运算执行，特别是在计算所有可能的下一期资产选择的期望持续值时。最终的数值结果然后按要求四舍入到 $6$ 位小数。", "answer": "```python\nimport numpy as np\n\ndef run_vfi(params):\n    \"\"\"\n    Solves the consumption-savings problem using Value Function Iteration.\n    \"\"\"\n    asset_grid, z_values, P, b_limits, beta, r, query_state = params\n    a_star, z_star_val = query_state\n\n    n_a = len(asset_grid)\n    n_z = len(z_values)\n\n    # Map query state to indices\n    try:\n        a_star_idx = np.where(asset_grid == a_star)[0][0]\n        z_star_idx = np.where(z_values == z_star_val)[0][0]\n    except IndexError:\n        raise ValueError(\"Query state not found in grids.\")\n\n    # VFI setup\n    V = np.zeros((n_a, n_z))\n    policy = np.zeros((n_a, n_z), dtype=int)\n    \n    max_iter = 5000\n    tol = 1e-9\n\n    for i in range(max_iter):\n        V_old = V.copy()\n        \n        # E[V(a',z') | z] for all a' and z\n        # (V_old @ P.T)[i, j] = sum_k V_old[i, k] * P.T[k, j] = sum_k V_old(a_i, z_k) * P(z_k | z_j)\n        expected_cont_value_matrix = V_old @ P.T\n\n        for z_idx, z_val in enumerate(z_values):\n            # E[V(a',z') | z_j] for all a' for this specific z_j\n            expected_cont_value_vector = expected_cont_value_matrix[:, z_idx]\n            borrowing_limit = b_limits[z_idx]\n\n            for a_idx, a_val in enumerate(asset_grid):\n                cash_on_hand = (1 + r) * a_val + z_val\n                consumption = cash_on_hand - asset_grid\n                \n                feasible_mask = (consumption > 0)  (asset_grid >= borrowing_limit)\n                \n                value_options = -np.inf * np.ones(n_a)\n                \n                if np.any(feasible_mask):\n                    utility = np.log(consumption[feasible_mask])\n                    cont_vals = beta * expected_cont_value_vector[feasible_mask]\n                    value_options[feasible_mask] = utility + cont_vals\n\n                V[a_idx, z_idx] = np.max(value_options)\n                # np.argmax returns the index of the first max value. Since asset_grid\n                # is sorted, this correctly implements the tie-breaking rule.\n                policy[a_idx, z_idx] = np.argmax(value_options)\n    \n        dist = np.max(np.abs(V - V_old))\n        if dist  tol:\n            break\n\n    # After convergence, extract and round results\n    optimal_value = V[a_star_idx, z_star_idx]\n    optimal_policy_idx = policy[a_star_idx, z_star_idx]\n    optimal_asset_choice = asset_grid[optimal_policy_idx]\n    \n    return optimal_value, optimal_asset_choice\n\ndef solve():\n    test_cases = [\n        # Case 1\n        (\n            np.array([-0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0]),\n            np.array([1.0, 2.0]),\n            np.array([[0.9, 0.1], [0.2, 0.8]]),\n            np.array([0.0, -0.5]),\n            0.95,\n            0.04,\n            (0.25, 2.0)\n        ),\n        # Case 2\n        (\n            np.array([-0.5, -0.25, 0.0, 0.25, 0.5, 0.75, 1.0]),\n            np.array([1.0, 2.0]),\n            np.array([[0.9, 0.1], [0.2, 0.8]]),\n            np.array([0.0, -0.5]),\n            0.95,\n            0.04,\n            (-0.25, 1.0)\n        ),\n        # Case 3\n        (\n            np.array([-0.25, 0.0, 0.25, 0.5, 0.75]),\n            np.array([0.5, 1.5]),\n            np.array([[0.95, 0.05], [0.1, 0.9]]),\n            np.array([0.0, -0.25]),\n            0.96,\n            0.02,\n            (0.0, 0.5)\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        v, a_next = run_vfi(case)\n        results.append(round(v, 6))\n        results.append(round(a_next, 6))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "2446389"}]}