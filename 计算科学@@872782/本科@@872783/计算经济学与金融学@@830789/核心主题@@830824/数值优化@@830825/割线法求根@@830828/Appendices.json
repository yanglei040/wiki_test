{"hands_on_practices": [{"introduction": "要真正理解割线法，最好的方式莫过于亲手计算几步迭代过程，并将其与我们已经熟悉的二分法进行比较。这个练习旨在通过一个简单的多项式求根问题，让你直观地感受割线法相较于二分法的收敛速度优势。通过手动计算，你将更深刻地理解割线法是如何利用函数的局部线性信息来加速寻找根的过程[@problem_id:2199000]。", "problem": "求函数根的两种常用数值方法是二分法和割线法。考虑多项式函数 $p(x) = x^3 - 4x + 1$。我们想要找到该多项式的最大实根，已知该根位于区间 $[1, 2]$ 内。\n\n你的任务是比较两种方法前几次迭代的结果。\n\n首先，使用二分法，从区间 $[a_0, b_0] = [1, 2]$ 开始，进行两次迭代以找到根的近似值。记此近似值为 $x_B$。\n\n其次，使用割线法，从初始猜测值 $x_0 = 1$ 和 $x_1 = 2$ 开始，进行两次迭代以找到根的近似值。记此近似值为 $x_S$。\n\n计算这两个近似值之间的绝对差 $|x_B - x_S|$。报告你的最终答案，并四舍五入到四位有效数字。", "solution": "给定多项式 $p(x)=x^{3}-4x+1$，且其最大实根位于区间 $[1,2]$ 内。首先，我们从 $[a_{0},b_{0}]=[1,2]$ 开始，应用两次二分法迭代；然后从 $x_{0}=1$，$x_{1}=2$ 开始，应用两次割线法迭代。最后，我们计算两个近似值之间的绝对差。\n\n二分法：\n- 计算端点值：$p(1)=1-4+1=-2  0$ 和 $p(2)=8-8+1=1 > 0$，因此在 $[1,2]$ 内有一个根。\n- 迭代 1：中点 $m_{1}=\\frac{1+2}{2}=\\frac{3}{2}$。然后\n$$\np\\!\\left(\\frac{3}{2}\\right)=\\left(\\frac{3}{2}\\right)^{3}-4\\cdot\\frac{3}{2}+1=\\frac{27}{8}-6+1=\\frac{27}{8}-\\frac{40}{8}=-\\frac{13}{8}  0.\n$$\n由于 $p(m_{1})  0$ 且 $p(2) > 0$，新区间为 $[a_{1},b_{1}]=\\left[\\frac{3}{2},2\\right]$。\n- 迭代 2：中点 $m_{2}=\\frac{\\frac{3}{2}+2}{2}=\\frac{7}{4}$。然后\n$$\np\\!\\left(\\frac{7}{4}\\right)=\\left(\\frac{7}{4}\\right)^{3}-4\\cdot\\frac{7}{4}+1=\\frac{343}{64}-7+1=\\frac{343}{64}-6=\\frac{343-384}{64}=-\\frac{41}{64}  0.\n$$\n同样地，$p(m_{2})  0$ 且 $p(2) > 0$，所以经过两次迭代后，二分法的近似值为\n$$\nx_{B}=m_{2}=\\frac{7}{4}.\n$$\n\n割线法：\n使用迭代公式 $x_{k+1}=x_{k}-p(x_{k})\\frac{x_{k}-x_{k-1}}{p(x_{k})-p(x_{k-1})}$。\n- 当 $x_{0}=1$，$x_{1}=2$ 时，我们有 $p(1)=-2$，$p(2)=1$。第一次迭代更新给出\n$$\nx_{2}=2-1\\cdot\\frac{2-1}{1-(-2)}=2-\\frac{1}{3}=\\frac{5}{3}.\n$$\n计算\n$$\np\\!\\left(\\frac{5}{3}\\right)=\\left(\\frac{5}{3}\\right)^{3}-4\\cdot\\frac{5}{3}+1=\\frac{125}{27}-\\frac{20}{3}+1=\\frac{125-180+27}{27}=-\\frac{28}{27}.\n$$\n- 第二次迭代更新使用 $x_{1}=2$，$x_{2}=\\frac{5}{3}$：\n$$\nx_{3}=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{\\frac{5}{3}-2}{-\\frac{28}{27}-1}\n=\\frac{5}{3}-\\left(-\\frac{28}{27}\\right)\\frac{-\\frac{1}{3}}{-\\frac{55}{27}}\n=\\frac{5}{3}-\\frac{28}{81}\\cdot\\frac{27}{-55}\n=\\frac{5}{3}-\\left(-\\frac{28}{165}\\right)\n=\\frac{5}{3}+\\frac{28}{165}\n=\\frac{275}{165}+\\frac{28}{165}\n=\\frac{303}{165}\n=\\frac{101}{55}.\n$$\n因此，经过两次迭代后，割线法的近似值为\n$$\nx_{S}=\\frac{101}{55}.\n$$\n\n绝对差与四舍五入：\n计算\n$$\n|x_{B}-x_{S}|=\\left|\\frac{7}{4}-\\frac{101}{55}\\right|=\\left|\\frac{385-404}{220}\\right|=\\frac{19}{220}.\n$$\n作为小数，$\\frac{19}{220}=0.0863636\\ldots$，四舍五入到四位有效数字是 $0.08636$。", "answer": "$$\\boxed{0.08636}$$", "id": "2199000"}, {"introduction": "数值方法的魅力不仅在于其普遍适用性，还在于某些特殊条件下展现出的优雅特性。本题将引导你探索一个有趣的“思想实验”：当割线法应用于一个奇函数且初始点关于原点对称时，会发生什么[@problem_id:2163434]？通过分析这个特殊情况，你将洞察到割线法迭代公式背后深刻的几何直觉，并理解初始点选择对算法性能的巨大影响。", "problem": "割线法是一种求解函数 $f(x)$ 根的数值算法。给定两个初始猜测值 $x_{n-1}$ 和 $x_n$，下一个猜测值 $x_{n+1}$ 使用以下迭代公式计算：\n$$x_{n+1} = x_n - f(x_n) \\frac{x_n - x_{n-1}}{f(x_n) - f(x_{n-1})}$$\n考虑一个连续函数 $f(x)$，它是一个奇函数，满足在其定义域内对所有 $x$ 都有 $f(-x) = -f(x)$ 的性质。为了求该函数的根，割线法采用两个关于原点对称、非零且不相等的初始猜测值启动：$x_1 = -x_0$。我们已知 $x_0 \\neq 0$ 且 $f(x_0) \\neq 0$。\n\n确定在这些特定初始条件下，割线法找到函数 $f(x)$ 的一个根所需的确切迭代次数。一次“迭代”指的是应用一次公式来计算下一个猜测值。", "solution": "我们已知 $f$ 是奇函数，所以对所有 $x$ 都有 $f(-x)=-f(x)$。特别地，令 $x=0$ 可得 $f(0)=-f(0)$，因此 $f(0)=0$。所以 $x=0$ 是 $f$ 的一个根。\n\n割线法的迭代公式为\n$$\nx_{n+1}=x_{n}-f(x_{n})\\,\\frac{x_{n}-x_{n-1}}{f(x_{n})-f(x_{n-1})}.\n$$\n我们从对称的、非零的初始猜测值 $x_{0}$ 和 $x_{1}=-x_{0}$ 开始，其中 $x_{0}\\neq 0$ 且 $f(x_{0})\\neq 0$。从 $x_{0}$ 和 $x_{1}$ 计算 $x_{2}$。利用奇函数的性质，我们有\n$$\nf(x_{1})=f(-x_{0})=-f(x_{0}).\n$$\n那么\n$$\nx_{1}-x_{0}=-x_{0}-x_{0}=-2x_{0},\\quad f(x_{1})-f(x_{0})=-f(x_{0})-f(x_{0})=-2f(x_{0}).\n$$\n因为 $f(x_{0})\\neq 0$，所以分母 $-2f(x_{0})\\neq 0$，因此割线法的更新是良定义的。分数部分化简为\n$$\n\\frac{f(x_{1})(x_{1}-x_{0})}{f(x_{1})-f(x_{0})}\n=\\frac{(-f(x_{0}))(-2x_{0})}{-2f(x_{0})}\n=\\frac{2x_{0}f(x_{0})}{-2f(x_{0})}\n=-x_{0}.\n$$\n因此，\n$$\nx_{2}=x_{1}-\\left(-x_{0}\\right)=x_{1}+x_{0}=-x_{0}+x_{0}=0.\n$$\n如上所示，$x=0$ 是 $f$ 的一个根，所以从给定的对称初始猜测值开始，割线法在单次应用迭代公式后就精确地找到了根。因此，所需的确切迭代次数是 $1$。", "answer": "$$\\boxed{1}$$", "id": "2163434"}, {"introduction": "纯粹的割线法虽然收敛快，但在实际应用中可能因迭代点跳出有效区间而失败。为了构建既快速又可靠的求根器，我们常常将其与稳健的二分法相结合，形成所谓的“混合算法”。这个综合性练习将指导你设计并实现一个有界的割线法（如Dekker-Brent方法），并将其应用于解决金融计算中的经典问题，如市场出清价格、债券到期收益率和期权隐含波动率的计算[@problem_id:2443706]。", "problem": "给定一些在计算经济学和金融学中出现的连续实值函数，每个函数都在一个闭区间上定义，并且在区间端点处的函数值异号。对于每个函数，请仅使用函数求值（不使用导数）的方法，在给定区间内计算一个实根 $x^\\star$。在终止前的每一次迭代中，该算法必须满足以下所有性质：(i) 所有的函数求值都必须在当前的含根区间 $\\left[a,b\\right]$ 内进行，(ii) 该区间必须始终包含一个根，即始终满足 $f(a)\\cdot f(b)\\le 0$，以及 (iii) 试验点的序列必须通过一种规则来选择，该规则可以在保持含根性质的前提下，利用最多三个先前已求值点的信息。当当前区间的宽度满足 $\\lvert b-a\\rvert \\le \\varepsilon_x$ 或当前近似值的函数值满足 $\\lvert f(x)\\rvert \\le \\varepsilon_f$ 时，程序必须终止，其中 $\\varepsilon_x=\\varepsilon_f=10^{-10}$。每个测试实例最多使用 $100$ 次迭代。如果提前满足终止条件，则立即返回。返回的近似值必须位于最终的含根区间内。\n\n定义以下求根实例的测试套件。每个实例指定一个函数 $f(x)$、一个满足 $f(a)\\cdot f(b)\\le 0$ 的区间 $\\left[a,b\\right]$ 以及任何所需的参数。\n\n测试用例 A（恒定弹性需求和线性供给下的市场出清价格）：\n- 变量：价格 $p$。\n- 需求：$D(p)=A\\,p^{-\\eta}$，其中 $A=120$ 且 $\\eta=1.5$。\n- 供给：$S(p)=c_0+c_1 p$，其中 $c_0=10$ 且 $c_1=2$。\n- 超额需求：$f(p)=D(p)-S(p)=A\\,p^{-\\eta}-(c_0+c_1 p)$。\n- 区间：$[a,b]=[1,20]$。\n\n测试用例 B（根据等额息票债券价格计算到期收益率）：\n- 变量：收益率 $y$。\n- 每期票息：$C=5$，面值：$F=100$，到期期数：$T=10$，观测价格：$P=95$。\n- 现值函数：$\\mathrm{PV}(y)=\\sum_{t=1}^{T}\\dfrac{C}{(1+y)^t}+\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0,0.2]$。\n\n测试用例 C（根据 Black–Scholes–Merton 看涨期权价格计算隐含波动率）：\n- 变量：波动率 $\\sigma$。\n- 标的资产价格：$S=100$，执行价格：$K=100$，连续复利无风险利率：$r=0.02$，到期时间（年）：$\\tau=1$，观测到的看涨期权价格：$C_{\\text{mkt}}=10$。\n- Black–Scholes–Merton 看涨期权价格：$C(\\sigma)=S\\,N(d_1)-K e^{-r\\tau} N(d_2)$，其中 $d_1=\\dfrac{\\ln(S/K)+(r+\\tfrac{1}{2}\\sigma^2)\\tau}{\\sigma\\sqrt{\\tau}}$，$d_2=d_1-\\sigma\\sqrt{\\tau}$，且 $N(\\cdot)$ 是标准正态累积分布函数 (CDF)。\n- 求根函数：$f(\\sigma)=C(\\sigma)-C_{\\text{mkt}}$。\n- 区间：$[a,b]=[0.01,1.0]$。\n\n测试用例 D（零息债券收益率方程中的边界根）：\n- 变量：收益率 $y$。\n- 面值：$F=100$，到期期数：$T=5$，参考收益率：$y_0=0.04$，观测价格：$P=F/(1+y_0)^T$。\n- 现值函数：$\\mathrm{PV}(y)=\\dfrac{F}{(1+y)^T}$。\n- 求根函数：$f(y)=\\mathrm{PV}(y)-P$。\n- 区间：$[a,b]=[0.04,0.20]$。\n\n您的程序必须使用相同的通用求解器按 A、B、C、D 的顺序评估所有四个测试用例，并生成单行输出，其中包含四个根的数值近似值，形式为用方括号括起来的逗号分隔列表，例如 $[x_A,x_B,x_C,x_D]$。每个 $x$ 都应打印为浮点数。不涉及角度。答案中没有物理单位。输出必须严格按照所述格式显示在单行上。", "solution": "该问题已经过验证并被确定为 **有效**。它具有科学依据，问题定义良好、客观，并为一项数值任务提供了完整、无矛盾的规范。该问题要求实现一类特定的求根算法，以解决计算经济学和金融学中的几个明确定义的问题。\n\n对算法的要求是：\n1.  它必须是一种区间法（bracketing method），确保根始终位于两点 $a$ 和 $b$ 之间，使得 $f(a) \\cdot f(b) \\le 0$。\n2.  所有的函数求值都必须在当前的含根区间内进行。\n3.  它必须使用基于最多三个先前点的插值法来加速收敛，但如果插值点不理想，则回退到一种安全的方法。\n4.  它必须仅使用函数求值，不使用导数。\n5.  当区间宽度的容差 $\\varepsilon_x = 10^{-10}$ 或函数值的容差 $\\varepsilon_f = 10^{-10}$ 之一满足时，必须终止。\n\n这些约束描述了一种稳健的混合求根算法。标准的割线法（secant method）不能保证迭代点保留在区间内。因此，需要一种更复杂的方法。所指定的性质是 Dekker 和 Brent 开发的典型方法的特征，这些方法将快速的开放法（如割线法或逆二次插值法）与安全的封闭法（二分法）相结合。\n\n这里实现的算法是 Dekker 方法的一个变体，该方法是 Brent 方法的直接前身。它满足所有问题约束。\n\n**算法设计：Dekker-Brent 方法**\n\n该方法的核心是维护一个区间 $[a, b]$，并约定 $b$ 代表对根 $x^{\\star}$ 的当前最佳近似。因此，在每一步中，我们都确保 $|f(b)| \\le |f(a)|$。\n\n1.  **初始化**：给定一个区间 $[a, b]$ 使得 $f(a)f(b) \\le 0$，我们计算 $f(a)$ 和 $f(b)$。如果任一端点在容差 $\\varepsilon_f$ 内是根，则终止。否则，我们通过在必要时交换 $a$ 和 $b$ 来建立不变量 $|f(b)| \\le |f(a)|$。点 $c=a$ 作为*上一个*最佳猜测点被存储起来。\n\n2.  **迭代**：主循环包括生成和评估一个新的试验点 $x_{\\text{next}}$，以缩小区间 $[a, b]$。\n\n3.  **试验点生成**：\n    *   **插值步骤（割线法）**：使用割线法计算一个试验点 $s$，该方法通过两个最近的最佳猜测点——当前最佳猜测点 $(b, f(b))$ 和上一个最佳猜测点 $(c, f(c))$ ——构建一条直线。公式为：\n        $$ s = b - f(b) \\frac{b - c}{f(b) - f(c)} $$\n        此步骤使用两个先前的点（$b$ 和 $c$）来实现超线性收敛。\n    *   **二分步骤**：一个有保证但较慢的备用方法是二分中点 $m = (a+b)/2$。\n\n4.  **混合策略**：每一步都需要做出一个关键决策。为确保收敛并满足求值点需在区间内的约束，只有当快速的割线法步骤 $s$ 是“合理的”时才会被接受。Dekker 方法的一个核心、简单而有效的条件是：仅当 $s$ 位于当前最佳猜测点 $b$ 和二分中点 $m$ 之间时，才接受 $s$。如果此条件不满足，我们就不信任插值结果，并默认使用安全的二分点 $m$。这确保了 $x_{\\text{next}}$ 始终在当前区间 $[a, b]$ 内。\n\n5.  **区间更新**：在计算 $f(x_{\\text{NEXT}})$ 之后，更新区间。如果 $f(a)$ 和 $f(x_{\\text{next}})$ 异号，则新区间变为 $[a, x_{\\text{next}}]$；否则，它变为 $[x_{\\text{next}}, b]$。然后重新标记这些点以维持 $b$ 是最佳猜测点的不变量，并重复此过程。\n\n6.  **终止**：如果区间宽度 $|b-a|$ 小于或等于 $\\varepsilon_x$ 或者最佳猜测点的函数值 $|f(b)|$ 小于或等于 $\\varepsilon_f$，则循环终止。\n\n**测试用例实现**\n\n四个测试用例被实现为 Python 函数。\n- 对于测试用例 B（到期收益率），现值通过直接求和计算，以在收益率值接近零时保持数值稳定性和正确性。\n- 对于测试用例 C（隐含波动率），需要标准正态累积分布函数 $N(x)$。它是使用 Python 标准 `math` 库中可用的误差函数 $\\mathrm{erf}(x)$，通过关系式 $N(x) = \\frac{1}{2}(1 + \\mathrm{erf}(x/\\sqrt{2}))$ 来实现的。\n- 对于测试用例 D，根恰好位于初始区间的边界上。求解器在第一次检查时就正确识别了这一点，并立即以正确答案终止。\n\n这种基于原则的稳健设计确保了对所有指定测试用例的根进行正确而高效的计算。", "answer": "```python\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the solver.\n    The output is a single line with comma-separated roots in a list format.\n    \"\"\"\n    # Define global constants for the solver.\n    EPS_X = 1e-10\n    EPS_F = 1e-10\n    MAX_ITER = 100\n\n    def dekker_brent_solver(f, a, b, eps_x, eps_f, max_iter):\n        \"\"\"\n        A robust root-finding algorithm based on Dekker's and Brent's methods.\n        It combines a fast interpolation step (secant method) with a safe\n        fallback (bisection method) to guarantee convergence while ensuring the\n        root remains bracketed.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            raise ValueError(\"Root not bracketed in initial interval [a, b].\")\n\n        # Check if endpoints are already the root within tolerance.\n        if abs(fa) = eps_f:\n            return a\n        if abs(fb) = eps_f:\n            return b\n\n        # Convention: 'b' is always the current best guess for the root.\n        # 'a' is the contrapoint, ensuring f(a) and f(b) have opposite signs.\n        if abs(fa)  abs(fb):\n            a, b = b, a\n            fa, fb = fb, fa\n        \n        # 'c' is the previous best guess, used for the secant step.\n        c = a\n        fc = fa\n        \n        for _ in range(max_iter):\n            # Check for termination on either interval width or function value.\n            if abs(b - a) = eps_x or abs(fb) = eps_f:\n                return b\n\n            s = None\n            # Propose a new point 's' using the secant method (linear interpolation).\n            # This step uses the current best guess (b) and previous best guess (c).\n            if abs(fb - fc) > 1e-15:  # Avoid division by zero or large floating-point errors.\n                s = b - fb * (b - c) / (fb - fc)\n\n            # The bisection midpoint serves as a safe fallback.\n            m = (a + b) / 2\n            \n            # Hybrid strategy: Accept the secant step 's' only if it's reasonable.\n            # \"Reasonable\" means it falls strictly between 'b' and the bisection point 'm'.\n            # This ensures the new point is inside the bracket and promotes convergence.\n            is_secant_step_acceptable = False\n            if s is not None:\n                # The order of b and m is not known, so check both cases.\n                if (b  m and s > b and s  m) or (b > m and s  b and s > m):\n                    is_secant_step_acceptable = True\n\n            if is_secant_step_acceptable:\n                x_next = s\n            else:\n                # If interpolation is untrustworthy, fall back to bisection.\n                x_next = m\n            \n            f_next = f(x_next)\n\n            # Update state for the next iteration: the old 'b' becomes the new 'c'.\n            c, fc = b, fb\n\n            # Update the bracketing interval based on the sign of f_next.\n            if fa * f_next  0:\n                b, fb = x_next, f_next\n            else:\n                a, fa = x_next, f_next\n\n            # Maintain the invariant that 'b' is the best guess so far (|f(b)| is minimal).\n            if abs(fa)  abs(fb):\n                a, b = b, a\n                fa, fb = fb, fa\n        \n        # If max iterations are reached, return the best approximation found.\n        return b\n\n    # --- Test Case Definitions ---\n\n    # Test Case A: Market-clearing price\n    def f_A(p):\n        A, eta, c0, c1 = 120.0, 1.5, 10.0, 2.0\n        if p = 0: return float('inf')\n        return A * p**(-eta) - (c0 + c1 * p)\n    \n    # Test Case B: Yield to maturity\n    def f_B(y):\n        C, F, T, P = 5.0, 100.0, 10, 95.0\n        if y = -1: return float('inf')\n        one_plus_y = 1.0 + y\n        # Direct summation is robust against numerical issues near y=0.\n        terms = [C / (one_plus_y**t) for t in range(1, T + 1)]\n        pv = np.sum(terms) + F / (one_plus_y**T)\n        return pv - P\n    \n    # Test Case C: Implied volatility\n    def f_C(sigma):\n        S, K, r, tau, C_mkt = 100.0, 100.0, 0.02, 1.0, 10.0\n        if sigma = 0: return -C_mkt # C(0) = 0, so f(0) = -C_mkt\n\n        # Standard Normal CDF N(x) using math.erf from the standard library\n        def N(x):\n            return 0.5 * (1.0 + math.erf(x / math.sqrt(2.0)))\n        \n        d1 = (math.log(S / K) + (r + 0.5 * sigma**2) * tau) / (sigma * math.sqrt(tau))\n        d2 = d1 - sigma * math.sqrt(tau)\n        call_price = S * N(d1) - K * math.exp(-r * tau) * N(d2)\n        return call_price - C_mkt\n\n    # Test Case D: Boundary root\n    F_D, T_D, y0_D = 100.0, 5, 0.04\n    P_D = F_D / (1.0 + y0_D)**T_D\n    def f_D(y):\n        if y = -1: return float('inf')\n        return F_D / (1.0 + y)**T_D - P_D\n\n    test_cases = [\n        {'func': f_A, 'a': 1.0, 'b': 20.0},\n        {'func': f_B, 'a': 0.0, 'b': 0.2},\n        {'func': f_C, 'a': 0.01, 'b': 1.0},\n        {'func': f_D, 'a': 0.04, 'b': 0.20},\n    ]\n\n    results = []\n    for case in test_cases:\n        root = dekker_brent_solver(case['func'], case['a'], case['b'], EPS_X, EPS_F, MAX_ITER)\n        results.append(root)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2443706"}]}