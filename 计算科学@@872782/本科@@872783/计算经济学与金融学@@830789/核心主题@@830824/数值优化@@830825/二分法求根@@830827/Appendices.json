{"hands_on_practices": [{"introduction": "在投入编写代码之前，理解一个算法的性能保证是至关重要的。二分法的一个显著优点是其可预测的收敛速度。这个练习 [@problem_id:2438012] 将让你亲手计算，在给定的初始区间和精度要求下，确保找到内部收益率（IRR）所需的最少迭代次数，从而让你对算法的效率和收敛保证有一个具体的、量化的认识。", "problem": "一项资本预算分析考虑一个期限为$50$年的常规投资项目：在时间$t=0$时有一笔初始支出$c_{0}  0$，随后在$t=1,2,\\dots,50$期间产生非负净现金流$c_{t} \\ge 0$，且并非所有现金流都为零。内部收益率 (IRR) $r^{\\ast}$被定义为净现值函数的根：\n$$\n\\mathrm{NPV}(r) \\equiv \\sum_{t=0}^{50} \\frac{c_{t}}{(1+r)^{t}} = 0,\n$$\n其中$r \\ge 0$是以小数形式表示的折现率。在这些现金流条件下，对于$r \\ge 0$，$\\mathrm{NPV}(r)$是关于$r$的连续且严格递减函数，因此任何变号区间都包含一个唯一的IRR。\n\n假设已知$r^{\\ast} \\in [0,\\,0.30]$，并且$\\mathrm{NPV}(0) \\ge 0$而$\\mathrm{NPV}(0.30) \\le 0$，因此可以在初始区间$[a_{0}, b_{0}] = [0,\\,0.30]$上应用二分法。您使用二分法，并在第$N$次迭代时，将当前包围区间的中点作为$r^{\\ast}$的估计值。您希望保证绝对估计误差至多为一个基点，其中一个基点按小数单位的利率表示为$0.0001$。\n\n假设在每次迭代中$r^{\\ast}$都位于区间内的最坏情况下，为保证$|r_{N} - r^{\\ast}| \\le 0.0001$（其中$r_{N}$是$N$次迭代后的中点），所需的最小二分法迭代次数$N$是多少？请以单个整数形式提供答案。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是有效的。它具有科学依据、是适定的、客观的且内部一致。它展示了在计算金融背景下使用二分法求根的一个标准应用，这是一个定义明确且可解的问题。\n\n该问题要求为保证内部收益率$r^{\\ast}$的估计值达到特定精度，所需的二分法最小迭代次数$N$。解决方案的核心在于二分法的误差分析。\n\n设初始区间为$[a_0, b_0]$，已知根$r^{\\ast}$位于此区间内。该区间的长度为$L_0 = b_0 - a_0$。二分法通过迭代将包围区间的长度减半。经过$N$次迭代后，包含根的新区间$[a_N, b_N]$的长度将为：\n$$\nL_N = b_N - a_N = \\frac{b_0 - a_0}{2^N}\n$$\n问题指明，经过$N$次迭代后根的估计值$r_N$是结果区间$[a_N, b_N]$的中点。\n$$\nr_N = \\frac{a_N + b_N}{2}\n$$\n由于保证真实根$r^{\\ast}$位于区间$[a_N, b_N]$内，即$a_N \\le r^{\\ast} \\le b_N$，因此估计值$r_N$的绝对误差为$|r_N - r^{\\ast}|$。问题要求假设$r^{\\ast}$处于最坏情况的位置。当$r^{\\ast}$位于区间的某个端点时，会发生最大可能误差。\n$$\n|r_N - r^{\\ast}| \\le \\max(r_N - a_N, b_N - r_N)\n$$\n由于$r_N$是中点，这个最大误差是区间$[a_N, b_N]$长度的一半：\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_N - a_N}{2} = \\frac{L_N}{2}\n$$\n代入$L_N$的表达式，我们得到$N$次迭代后的误差界：\n$$\n|r_N - r^{\\ast}| \\le \\frac{b_0 - a_0}{2^{N+1}}\n$$\n问题给出的初始区间为$[a_0, b_0] = [0, 0.30]$。因此，$a_0 = 0$且$b_0 = 0.30$。要求的绝对误差容限为一个基点，即$0.0001$。我们必须找到满足以下条件的最小整数$N$：\n$$\n|r_N - r^{\\ast}| \\le 0.0001\n$$\n使用误差界，我们建立不等式：\n$$\n\\frac{b_0 - a_0}{2^{N+1}} \\le 0.0001\n$$\n代入$a_0$和$b_0$的值：\n$$\n\\frac{0.30 - 0}{2^{N+1}} \\le 0.0001\n$$\n$$\n\\frac{0.30}{2^{N+1}} \\le 0.0001\n$$\n为了解出$N$，我们整理该不等式：\n$$\n0.30 \\le 0.0001 \\times 2^{N+1}\n$$\n$$\n\\frac{0.30}{0.0001} \\le 2^{N+1}\n$$\n$$\n3000 \\le 2^{N+1}\n$$\n为了分离出指数，我们对不等式两边取以2为底的对数：\n$$\n\\log_{2}(3000) \\le N+1\n$$\n我们可以使用换底公式$\\log_{b}(x) = \\frac{\\ln(x)}{\\ln(b)}$来计算$\\log_{2}(3000)$的值：\n$$\n\\frac{\\ln(3000)}{\\ln(2)} \\le N+1\n$$\n使用自然对数的数值，$\\ln(3000) \\approx 8.006367$ 且 $\\ln(2) \\approx 0.693147$：\n$$\n\\frac{8.006367}{0.693147} \\approx 11.5507 \\le N+1\n$$\n两边同时减1，得到关于$N$的条件：\n$$\n11.5507 - 1 \\le N\n$$\n$$\n10.5507 \\le N\n$$\n由于迭代次数$N$必须是整数，我们必须选择满足此条件的最小整数。大于或等于$10.5507$的最小整数$N$是$11$。\n因此，至少需要$11$次迭代才能保证绝对估计误差至多为$0.0001$。", "answer": "$$\\boxed{11}$$", "id": "2438012"}, {"introduction": "经济模型的核心任务之一是求解均衡状态，而这通常归结为求解一个非线性方程。这个实践 [@problem_id:2437951] 将指导你应用二分法来寻找索洛增长模型中的稳态资本水平，这是一个经典的宏观经济学问题。通过这个练习，你将把理论算法转化为解决具体经济问题的实用工具，并体会数值方法在经济学研究中的力量。", "problem": "考虑一个确定性的人均索洛增长模型，其人均生产函数 $f(k)$ 是严格递增的凹函数，并满足 $f(0)=0$。人均资本 $k^\\ast$ 的非负稳态满足不动点方程\n$$\ns\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0,\n$$\n其中 $s \\in (0,1)$ 是恒定的储蓄率，$\\delta \\in (0,1)$ 是折旧率，$n \\ge 0$ 是外生的人口增长率。在本问题的所有测试案例中，生产函数均为柯布-道格拉斯形式\n$$\nf(k) = A\\, k^{\\alpha},\n$$\n其参数为 $A>0$ 和 $\\alpha \\in (0,1)$。\n\n定义函数\n$$\ng(k) = s\\, f(k) - (\\delta + n)\\, k.\n$$\n对于下方的每组参数，在指定的闭区间 $[k_{\\min}, k_{\\max}]$ 内，$g(k)$ 至少存在一个根 $k^\\ast \\ge 0$。您的任务是计算位于给定区间内且满足以下终止条件的 $g(k)$ 的根 $k^\\ast$：(i) 绝对区间宽度最多为 $\\varepsilon_x = 10^{-12}$，或 (ii) 绝对函数值满足 $|g(k^\\ast)| \\le \\varepsilon_f = 10^{-12}$。以下所有输入均无单位。储蓄率、折旧率和人口增长率均以小数（而非百分比）形式给出。\n\n测试套件（每个案例为一个元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$）：\n- 案例 1：$(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$。\n- 案例 2：$(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$。\n- 案例 3：$(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$。\n- 案例 4：$(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$。\n\n最终输出格式：\n- 您的程序必须生成单行输出，其中包含按测试套件顺序排列的四个计算出的稳态资本水平，格式为用方括号括起来的逗号分隔列表，无空格。\n- 每个值必须打印为浮点数，小数点后精确到 $8$ 位。\n- 例如，要求的格式形如 [$x_1,x_2,x_3,x_4$]，其中每个 $x_i$ 都四舍五入到小数点后 $8$ 位。", "solution": "该问题要求在确定性索洛增长模型中计算非负的稳态人均资本，记为 $k^\\ast$。该模型由柯布-道格拉斯形式的人均生产函数 $f(k) = A k^\\alpha$ 定义。\n\n首先，有必要对问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n-   人均资本的稳态 $k^\\ast$ 是满足方程 $s\\, f(k^\\ast) - (\\delta + n)\\, k^\\ast = 0$ 的不动点。\n-   参数包括储蓄率 $s \\in (0,1)$、折旧率 $\\delta \\in (0,1)$ 和人口增长率 $n \\ge 0$。\n-   生产函数具体为 $f(k) = A\\, k^{\\alpha}$，其中生产率参数 $A>0$，资本产出弹性 $\\alpha \\in (0,1)$。函数 $f(k)$ 是严格递增的凹函数，并满足 $f(0)=0$。\n-   任务是在指定区间 $[k_{\\min}, k_{\\max}]$ 内找到函数 $g(k) = s\\, f(k) - (\\delta + n)\\, k$ 的一个根。\n-   数值方法的终止标准为区间宽度最多为 $\\varepsilon_x = 10^{-12}$，或函数值的绝对大小最多为 $\\varepsilon_f = 10^{-12}$。\n-   测试案例以元组 $(A,\\alpha,s,\\delta,n,k_{\\min},k_{\\max})$ 的形式给出：\n    1.  $(1.0,\\, 0.33,\\, 0.25,\\, 0.08,\\, 0.02,\\, 10^{-6},\\, 10.0)$\n    2.  $(0.5,\\, 0.5,\\, 0.3,\\, 0.04,\\, 0.01,\\, 10^{-6},\\, 9.0)$\n    3.  $(1.0,\\, 0.4,\\, 0.0,\\, 0.05,\\, 0.01,\\, 0.0,\\, 5.0)$\n    4.  $(1.0,\\, 0.5,\\, 0.005,\\, 0.05,\\, 0.01,\\, 10^{-8},\\, 1.0)$\n\n**步骤 2：验证**\n该问题具有科学依据，因为它涉及标准的 Solow-Swan 新古典增长模型，这是宏观经济学中的一个基本概念。数学公式是正确的。问题是客观且适定的。\n\n存在一个微小的不一致之处：一般性描述指出 $s \\in (0,1)$，而测试案例 3 中指定 $s=0.0$。这不是一个严重缺陷。对于 $s=0$ 的极限情况，该模型仍然完全有效且具有物理意义。它代表一个没有储蓄的经济体，其资本存量必然会折旧至零。测试案例的具体参数必须优先于一般性描述。问题仍然是可解的。\n\n函数 $g(k) = s A k^\\alpha - (\\delta+n)k$ 有两个潜在的非负根。\n1.  平凡稳态，即 $k=0$。这总是一个根，因为根据约定，当 $\\alpha > 0$ 时 $0^\\alpha = 0$，所以 $g(0) = s A (0)^\\alpha - (\\delta+n)(0) = 0$。\n2.  非平凡正稳态。对于 $k>0$，我们可以求解 $s A k^{\\alpha-1} - (\\delta+n) = 0$。这得出 $k^{\\alpha-1} = \\frac{\\delta+n}{sA}$。因为 $\\alpha \\in (0,1)$，指数 $1-\\alpha$ 是正的。因此，唯一的正根是：\n    $$\n    k^\\ast = \\left( \\frac{sA}{\\delta+n} \\right)^{\\frac{1}{1-\\alpha}}\n    $$\n    这个正稳态存在的充要条件是 $s > 0$。如果 $s=0$，唯一的非负根是 $k=0$。\n\n$g(k)$ 的二阶导数是 $g''(k) = s A \\alpha (\\alpha-1) k^{\\alpha-2}$。给定 $s \\ge 0$，$A>0$，$\\alpha \\in (0,1)$，对于所有 $k>0$，我们有 $g''(k) \\le 0$，这意味着 $g(k)$ 是一个凹函数。一个凹函数最多与横轴相交两次。这证实了最多只存在一个正根。\n\n问题要求在给定区间内找到根。这表明需要使用数值求根算法。二分法是一个合适且稳健的选择，因为问题陈述保证了对于每个案例，在给定区间 $[k_{\\min}, k_{\\max}]$ 内都存在一个根，并且函数 $g(k)$ 是连续的。为保证该方法收敛，区间端点处的函数值必须异号，即 $g(k_{\\min}) \\cdot g(k_{\\max})  0$。让我们对那些根不在边界上的案例进行验证。\n-   案例 1：$k^\\ast \\approx 4.41 \\in [10^{-6}, 10.0]$。$g(10^{-6}) > 0$ 且 $g(10.0)  0$。条件成立。\n-   案例 4：$k^\\ast \\approx 0.00694 \\in [10^{-8}, 1.0]$。$g(10^{-8}) > 0$ 且 $g(1.0)  0$。条件成立。\n-   案例 2 和 3 的根位于区间边界之一。二分法的稳健实现必须在开始迭代过程之前，首先检查端点本身是否为根。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将提供一个解决方案。\n\n**求解方法**\n我们将实现二分法，在区间 $[a, b] = [k_{\\min}, k_{\\max}]$ 上找到 $g(k) = sAk^\\alpha - (\\delta+n)k$ 的根。给定的容差为 $\\varepsilon_x = 10^{-12}$ 和 $\\varepsilon_f = 10^{-12}$。\n\n算法流程如下：\n1.  对于给定的一组参数 $(A, \\alpha, s, \\delta, n)$，定义函数 $g(k)$。\n2.  设置初始区间端点 $a = k_{\\min}$ 和 $b = k_{\\max}$。\n3.  计算 $g(a)$ 和 $g(b)$。如果 $|g(a)| \\le \\varepsilon_f$，则根为 $a$。如果 $|g(b)| \\le \\varepsilon_f$，则根为 $b$。在这些情况下，算法终止。\n4.  开始二分法循环。将使用最大迭代次数（例如 $100$ 次）作为安全保障。\n5.  在每次迭代中，计算中点 $c = a + (b-a)/2$。\n6.  计算 $g_c = g(c)$。\n7.  检查终止条件：如果 $(b-a) \\le \\varepsilon_x$ 或 $|g_c| \\le \\varepsilon_f$，算法终止并返回 $c$ 作为根。\n8.  更新区间：令 $g_a = g(a)$。如果 $g_a \\cdot g_c  0$，根位于 $[a, c]$ 内，因此我们设置 $b=c$。否则，根必定位于 $[c, b]$ 内，因此我们设置 $a=c$。\n9.  从步骤 5 开始重复，直到满足终止条件。\n\n此过程将应用于所提供的四个测试案例中的每一个。对于案例 3，其中 $s=0$ 且 $k_{\\min}=0$，我们有 $g(k_{\\min})=g(0)=0$。算法将在初始检查中正确识别出 $k_{\\min}=0$ 是根。对于案例 2，其根位于 $k_{\\max}=9.0$，算法也将在初始检查中识别出这一点。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the steady-state capital per worker for the Solow growth model\n    using the bisection method for different parameter sets.\n    \"\"\"\n\n    test_cases = [\n        # (A, alpha, s, delta, n, k_min, k_max)\n        (1.0, 0.33, 0.25, 0.08, 0.02, 1e-6, 10.0),\n        (0.5, 0.5, 0.3, 0.04, 0.01, 1e-6, 9.0),\n        (1.0, 0.4, 0.0, 0.05, 0.01, 0.0, 5.0),\n        (1.0, 0.5, 0.005, 0.05, 0.01, 1e-8, 1.0),\n    ]\n\n    results = []\n    for case in test_cases:\n        root = bisection_solver(*case)\n        results.append(root)\n\n    # Format the final output string as required.\n    output_str = f\"[{','.join([f'{r:.8f}' for r in results])}]\"\n    print(output_str)\n\ndef bisection_solver(A, alpha, s, delta, n, k_min, k_max):\n    \"\"\"\n    Finds a root of the Solow steady-state equation using the bisection method.\n\n    The function to find a root for is g(k) = s * A * k**alpha - (delta + n) * k.\n    \"\"\"\n    \n    eps_x = 1e-12\n    eps_f = 1e-12\n    max_iter = 100\n\n    # Define the function g(k) whose root we are seeking.\n    break_even_rate = delta + n\n    g = lambda k: s * A * k**alpha - break_even_rate * k if k > 0 else 0.0\n\n    a = k_min\n    b = k_max\n\n    g_a = g(a)\n    if abs(g_a) = eps_f:\n        return a\n    \n    g_b = g(b)\n    if abs(g_b) = eps_f:\n        return b\n    \n    # Standard bisection method requires g(a) and g(b) to have opposite signs.\n    # The problem setup ensures this or that one endpoint is the root.\n    if g_a * g_b > 0:\n        # This state should not be reached with the given valid problem cases.\n        # It indicates an issue with the interval.\n        # Note: A lambda for g(k) with a ternary operator is safer for k=0.\n        # Original code had a bug where g(0) with alpha  1 would be nan\n        # if k was 0.0. Added a check in the lambda itself.\n        g = lambda k: s * A * k**alpha - break_even_rate * k if k > 0 else 0.0\n        g_a, g_b = g(a), g(b) # Recalculate with robust g(k)\n        if abs(g_a) = eps_f: return a\n        if abs(g_b) = eps_f: return b\n        if g_a * g_b > 0:\n             raise ValueError(\"Bisection method precondition failed: g(a) * g(b) > 0.\")\n        \n    c = a # Initialize c\n    for _ in range(max_iter):\n        c = a + (b - a) / 2\n        g_c = g(c)\n\n        # Check termination criteria\n        if (b - a) = eps_x or abs(g_c) = eps_f:\n            return c\n\n        if g_a * g_c  0:\n            b = c\n        else:\n            a = c\n            g_a = g(a) # Update g_a for the new interval [a, b]\n            \n    return c\n\nsolve()\n```", "id": "2437951"}, {"introduction": "二分法的应用在金融领域同样广泛，尤其是在债券定价和收益率计算中。此练习 [@problem_id:2437995] 要求你为一只可赎回债券计算其到期赎回收益率（YTC），这需要你构建一个定价函数并找出其根。这个过程不仅能巩固你对二分法的编程实现，还能加深你对金融工具估值背后数学原理的认识。", "problem": "您的任务是使用二分法通过数值求解债券定价不动点方程来计算可赎回固定息票债券的年度名义到期调用收益率 (YTC)。请以纯数学术语进行分析，并考虑以下基本原则：未来确定性现金流以正确的收益率贴现后的现值等于观测到的市场价格。对于一个确定将在指定的未来付息期数后被赎回的可赎回债券，其现金流包括直至赎回日的定期息票，以及在赎回日支付的最后一笔等于末期息票与赎回价格之和的合并付款。假设无违约风险、确定性贴现，并且除了指定的离散复利外，不考虑其他计日惯例。\n\n各量定义：\n- 令 $P$ 表示观测到的债券价格。\n- 令 $M$ 表示债券的面值。\n- 令 $\\kappa$ 表示年票面利率（以小数形式）。\n- 令 $m$ 表示每年的付息次数（整数）。\n- 令 $n$ 表示到赎回日为止的付息期数（整数）。\n- 令 $K$ 表示在赎回日收到的赎回价格。\n- 令 $y$ 表示年名义到期调用收益率，复利频率为 $m$（以小数形式）。\n- 令 $C$ 表示每期息票，由 $C = \\frac{\\kappa}{m} M$ 给出。\n- 令 $r$ 表示每期收益率，由 $r = \\frac{y}{m}$ 给出。\n- 令 $D_t(y)$ 表示第 $t$ 期的贴现因子，由 $D_t(y) = \\left(1 + \\frac{y}{m}\\right)^{-t}$ 给出。\n\n基本定价关系：\nYTC $y$ 通过将现金流的现值与价格 $P$ 相等来隐式定义：\n$$\nP = \\sum_{t=1}^{n-1} C \\cdot D_t(y) \\;+\\; \\big(C + K\\big)\\cdot D_n(y).\n$$\n等价地，定义函数\n$$\nf(y) = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n} - P,\n$$\n并找到使 $f(y) = 0$ 的 $y$。\n\n算法要求：\n- 实现二分法，在区间 $[y_{\\min}, y_{\\max}]$ 上求解 $f(y) = 0$，其中 $y_{\\min} > -m$ 以确保 $1 + \\frac{y}{m} > 0$。在迭代前，请确保 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。\n- 使用一个停止规则，当区间宽度在 $y$ 上最多为 $\\varepsilon$ 或 $|f(y)| \\le \\varepsilon$ 时终止，其中 $\\varepsilon$ 是给定的容差。\n- 使用最大迭代次数以防止无限循环。\n\n角度单位不适用。不涉及物理单位。所有利率必须以小数表示，而非百分号。\n\n测试套件：\n为以下三种情况计算 YTC。每种情况都由 $(M, \\kappa, m, n, K, P)$ 独立参数化：\n\n- Case A (单周期边界检查):\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 1$, $K = 1010$, $P = 1000$。\n- Case B (平价下的理想路径):\n  - $M = 1000$, $\\kappa = 0.06$, $m = 2$, $n = 10$, $K = 1000$, $P = 1000$。\n- Case C (零息票边缘情况):\n  - $M = 1000$, $\\kappa = 0.00$, $m = 2$, $n = 4$, $K = 1000$, $P = 822.7024747919322$。\n\n数值设置：\n- 使用 $y_{\\min} = -0.90$，$y_{\\max} = 1.00$，容差 $\\varepsilon = 10^{-12}$，以及最大迭代次数 $100000$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含三个计算出的 YTC 值，四舍五入到 $8$ 位小数，格式为用方括号括起来的逗号分隔列表，例如 $[0.01234567,0.07654321,0.00000000]$。", "solution": "所提出的问题是计算金融学中一个定义明确的练习，具体涉及债券到期调用收益率的数值确定。任务是求解一个源于现金流贴现原理的非线性方程的根。这是数值方法的标准应用。该问题是有效的，因为它在科学上基于已确立的金融理论，在数学上是一致的，其规格是完整的，并且是客观的。\n\n问题的核心是求解方程 $f(y) = 0$，以得到年度名义到期调用收益率 $y$。函数 $f(y)$ 表示债券未来现金流的现值 ($PV$) 与其观测到的市场价格 $P$ 之间的差额。现金流包括 $n$ 笔息票支付和一笔赎回价格 $K$ 的最终付款。\n\n定价方程如下：\n$$\nP = \\sum_{t=1}^{n-1} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{C + K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\n其中 $C$ 是每期支付的息票， $C = \\frac{\\kappa}{m} M$，$m$ 是每年的付息次数，$n$ 是到赎回日为止的付息期数。因此，要求解的函数是 $f(y) = PV(y) - P$，其中 $PV(y)$ 是方程的右侧部分。\n\n为提高计算效率，我们可以认识到贴现后息票的总和是一个几何级数。一个更标准且等价的现值表示方法是：\n$$\nPV(y) = \\sum_{t=1}^{n} \\frac{C}{\\left(1 + \\frac{y}{m}\\right)^t} + \\frac{K}{\\left(1 + \\frac{y}{m}\\right)^n}\n$$\n求和项是普通年金的现值，它有一个封闭形式的表达式。令 $r = y/m$ 为每期贴现率，则该和为 $\\frac{C}{r}\\left(1 - (1+r)^{-n}\\right)$。因此，函数 $f(y)$ 可以写成：\n$$\nf(y) = \\frac{C}{y/m}\\left(1 - \\left(1+\\frac{y}{m}\\right)^{-n}\\right) + K\\left(1+\\frac{y}{m}\\right)^{-n} - P\n$$\n此公式在 $y \\neq 0$ 时有效。在 $y = 0$ 的特殊情况下，我们必须评估第一项的极限。对项 $\\frac{1-(1+r)^{-n}}{r}$ 在 $r \\to 0$ 时使用 L'Hôpital 法则，我们发现极限为 $n$。因此，对于 $y = 0$，函数为：\n$$\nf(0) = C \\cdot n + K - P\n$$\n现值关于 $y$ 的导数是：\n$$\n\\frac{d(PV)}{dy} = \\sum_{t=1}^{n-1} C \\cdot \\frac{-t}{m}\\left(1+\\frac{y}{m}\\right)^{-t-1} + (C+K) \\cdot \\frac{-n}{m}\\left(1+\\frac{y}{m}\\right)^{-n-1}\n$$\n由于所有现金流（$C, K$）都是非负的，且参数 $t, n, m$ 是正的，因此对于有效域（$y > -m$）中的任何 $y$，该导数都严格为负。这证明了 $f(y)$ 是一个关于 $y$ 的严格单调递减函数。这一性质至关重要，因为它保证了如果在一个给定的区间内存在根，那么这个根是唯一的。因此，二分法是寻找这个根的合适且稳健的选择。\n\n二分法是一种迭代求根算法，它作用于一个区间 $[a, b]$，在此区间上函数 $f$ 在端点处具有相反的符号，即 $f(a) \\cdot f(b) \\le 0$。根据介值定理，这保证了在 $[a, b]$ 中至少存在一个根。该算法的步骤如下：\n\n$1$. 用 $[y_{\\min}, y_{\\max}]$ 初始化搜索区间。验证 $f(y_{\\min}) \\cdot f(y_{\\max}) \\le 0$。对于本问题，给定的区间是 $[-0.90, 1.00]$。\n\n$2$. 开始迭代，最多进行 $100000$ 次。\n\n$3$. 在每次迭代中，计算区间的中点，$y_{mid} = \\frac{y_{\\min} + y_{\\max}}{2}$。\n\n$4$. 在中点处计算函数值，$f(y_{mid})$。\n\n$5$. 检查停止条件：\n    - 如果区间宽度 $(y_{\\max} - y_{\\min})$ 小于或等于容差 $\\varepsilon = 10^{-12}$。\n    - 或者，如果中点处的函数绝对值 $|f(y_{mid})|$ 小于或等于 $\\varepsilon = 10^{-12}$。\n    - 如果满足任一条件，算法终止，$y_{mid}$ 即为近似根。\n\n$6$. 如果未满足停止条件，则更新区间。由于 $f(y)$ 是单调递减的：\n    - 如果 $f(y_{mid}) > 0$，根必定位于区间的上半部分。我们设置 $y_{\\min} = y_{mid}$。\n    - 如果 $f(y_{mid})  0$，根必定位于区间的下半部分。我们设置 $y_{\\max} = y_{mid}$。\n    - 如果 $f(y_{mid}) = 0$，则找到了精确根，可以终止。\n\n$7$. 从步骤 3 重复。\n\n该算法将被实现并应用于提供的三个测试用例。对于每个用例，参数 $(M, \\kappa, m, n, K, P)$ 定义了函数 $f(y)$ 的一个特定实例。实现将使用数值稳定且高效的现值封闭形式表达式，并对 $y=0$ 的情况进行特殊处理。\n\n三个用例的参数如下：\n- Case A: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 1, 1010, 1000)$。\n- Case B: $(M, \\kappa, m, n, K, P) = (1000, 0.06, 2, 10, 1000, 1000)$。\n- Case C: $(M, \\kappa, m, n, K, P) = (1000, 0.00, 2, 4, 1000, 822.7024747919322)$。\n\n数值设置为 $y_{\\min} = -0.90$，$y_{\\max} = 1.00$，$\\varepsilon = 10^{-12}$，以及最大迭代次数 = $100000$。每个用例最终计算出的收益率将按要求四舍五入到 8 位小数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the Yield-to-Call (YTC) for callable bonds using the bisection method.\n    \"\"\"\n\n    def bisection(f, a, b, tol=1e-12, max_iter=100000):\n        \"\"\"\n        Finds the root of a function f within the interval [a, b] using the bisection method.\n\n        Args:\n            f (callable): The function for which to find a root.\n            a (float): The lower bound of the interval.\n            b (float): The upper bound of the interval.\n            tol (float): The tolerance for stopping criteria.\n            max_iter (int): The maximum number of iterations.\n\n        Returns:\n            float: The approximate root, or None if the method fails.\n        \"\"\"\n        fa = f(a)\n        fb = f(b)\n\n        if fa * fb > 0:\n            # This check is important, but for the given monotonic function and\n            # wide interval, it is expected to hold for all test cases.\n            return None\n\n        for _ in range(max_iter):\n            c = a + (b - a) / 2\n            fc = f(c)\n\n            # Stopping criteria\n            if (b - a) = tol or abs(fc) = tol:\n                return c\n\n            # Update interval\n            # Since the function is monotonically decreasing, if f(c) has the same sign as f(a)\n            # then the root is in [c, b]. f(a) is positive. So if f(c) is positive, a becomes c.\n            if fa * fc  0:\n                b = c\n                # fb = fc is not necessary\n            else:\n                a = c\n                fa = fc # fa must be updated as it's used in the sign check\n\n        return (a + b) / 2 # Return the best estimate after max_iter\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case A: (M, kappa, m, n, K, P)\n        (1000, 0.06, 2, 1, 1010, 1000),\n        # Case B:\n        (1000, 0.06, 2, 10, 1000, 1000),\n        # Case C:\n        (1000, 0.00, 2, 4, 1000, 822.7024747919322),\n    ]\n\n    # Numerical settings\n    y_min = -0.90\n    y_max = 1.00\n    tolerance = 1e-12\n    max_iterations = 100000\n\n    results = []\n    for case in test_cases:\n        M, kappa, m, n, K, P = case\n        C = (kappa / m) * M\n\n        def f_ytc(y):\n            \"\"\"\n            The function f(y) = PV(y) - P whose root we are seeking.\n            \"\"\"\n            if m + y = 0:  # Avoid division by zero or negative base in power for 1+y/m\n                return np.inf # Return a large number to guide the search away\n\n            if abs(y)  1e-14: # Handle the case y -> 0\n                # Using L'Hopital's rule, the PV limit is C*n + K\n                pv = C * n + K\n            else:\n                r = y / m\n                # Use the closed-form expression for annuity present value\n                pv_coupons = (C / r) * (1 - (1 + r)**-n)\n                pv_principal = K * (1 + r)**-n\n                pv = pv_coupons + pv_principal\n            \n            return pv - P\n\n        # Solve for YTC using the bisection method\n        ytc = bisection(f_ytc, y_min, y_max, tol=tolerance, max_iter=max_iterations)\n        results.append(ytc)\n\n    # Format the results as specified\n    formatted_results = [f\"{res:.8f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2437995"}]}