{"hands_on_practices": [{"introduction": "本练习将我们带回信息论形式化之前的时代，探索其核心直觉：信息是“意外程度”的度量。通过计算从一个简单的纸牌游戏中获得的信息量，我们可以具体理解概率与信息内容之间的关系。这项实践为量化“信息”这个看似抽象的概念奠定了基础 [@problem_id:1629826]。", "problem": "想象一下，您身处 19 世纪末，那是在信息论被正式提出之前的几十年。您正在观察一个纸牌游戏，其中从一副洗匀的标准 52 张扑克牌中抽出一张牌。这副牌包含四种花色（梅花、方块、红桃、黑桃），每种花色有 13 个点数（2、3、4、5、6、7、8、9、10、J、Q、K、A）。J、Q 和 K 这几张牌被称为“花牌”。\n\n一位看不到牌的观察者按顺序收到了两条信息。首先，他们被告知：“这张牌是花牌。”在消化了这一事实之后，他们又被告知：“这张牌是黑桃。”\n\n计算观察者从这两条公告中共同获得的新信息总量。请用一个单一、精确的解析表达式来表示您的答案，单位为比特。", "solution": "让我们将所有可能结果的初始样本空间表示为 $\\Omega$，其中 $|\\Omega| = 52$。问题要求计算从两个连续的公告中获得的总信息量。我们可以通过将每一步获得的信息相加来计算这个总量。\n\n一个事件 $E$ 的信息量（或自信息）由公式 $I(E) = -\\log_2(P(E))$ 给出，其中 $P(E)$ 是该事件的概率。以 2 为底的对数确保了结果的单位是比特。\n\n**步骤 1：来自第一个公告的信息**\n\n设 $A$ 为抽到的牌是花牌的事件。\n在一副标准的 52 张牌中，每种花色有 3 张花牌（J、Q、K）。\n花牌的总数是 $N_A = 3 \\times 4 = 12$。\n抽到花牌的概率是：\n$$P(A) = \\frac{\\text{花牌数量}}{\\text{总牌数}} = \\frac{12}{52} = \\frac{3}{13}$$\n得知事件 $A$ 发生所获得的信息量是：\n$$I(A) = -\\log_2(P(A)) = -\\log_2\\left(\\frac{3}{13}\\right) = \\log_2\\left(\\frac{13}{3}\\right)$$\n\n**步骤 2：来自第二个公告的信息**\n\n设 $B$ 为抽到的牌是黑桃的事件。\n第二个公告是在已经知道这张牌是花牌之后发布的。因此，我们需要计算在事件 $A$ 已经发生的条件下，事件 $B$ 的条件信息。这由 $I(B|A) = -\\log_2(P(B|A))$ 给出。\n\n条件概率 $P(B|A)$ 是在已知牌是花牌的情况下，这张牌是黑桃的概率。我们的样本空间现在缩小到 12 张花牌。\n在这 12 张花牌中，有 3 张是黑桃：黑桃 J、黑桃 Q 和黑桃 K。\n所以，对应于“黑桃花牌”的结果数量是 3。\n\n条件概率是：\n$$P(B|A) = \\frac{\\text{黑桃花牌的数量}}{\\text{花牌总数}} = \\frac{3}{12} = \\frac{1}{4}$$\n在已知第一个公告的情况下，从第二个公告获得的信息量是：\n$$I(B|A) = -\\log_2(P(B|A)) = -\\log_2\\left(\\frac{1}{4}\\right) = \\log_2(4) = 2 \\text{ 比特}$$\n\n**步骤 3：总信息量**\n\n获得的总信息量是每个连续公告所提供信息量的总和：\n$$I_{\\text{total}} = I(A) + I(B|A)$$\n$$I_{\\text{total}} = \\log_2\\left(\\frac{13}{3}\\right) + \\log_2(4)$$\n使用对数属性 $\\log(x) + \\log(y) = \\log(xy)$：\n$$I_{\\text{total}} = \\log_2\\left(\\frac{13}{3} \\times 4\\right) = \\log_2\\left(\\frac{52}{3}\\right)$$\n\n**替代方法（验证）**\n\n获得的总信息量等同于最终事件的信息量，即这张牌既是花牌又是黑桃。设这个交集事件为 $C = A \\cap B$。\n事件 $C$ 的结果是 {黑桃 J, 黑桃 Q, 黑桃 K}。在最初的 52 张牌中，有 3 张这样的牌。\n这个事件的概率是：\n$$P(C) = P(A \\cap B) = \\frac{3}{52}$$\n总信息量是：\n$$I(C) = -\\log_2(P(C)) = -\\log_2\\left(\\frac{3}{52}\\right) = \\log_2\\left(\\frac{52}{3}\\right)$$\n两种方法得出了相同的结果，从而验证了该解法。", "answer": "$$\\boxed{\\log_{2}\\left(\\frac{52}{3}\\right)}$$", "id": "1629826"}, {"introduction": "在量化信息的基础上，本问题探讨了一个实际的工程挑战：如何高效地表示消息。我们将分析一个简化的铁路信号系统，比较一种实用的定长编码与由信源熵决定的理论最小平均长度。这个练习引入了“冗余”这一关键概念，它是设计高效通信系统的核心衡量标准 [@problem_id:1629773]。", "problem": "在数字通信的早期，一位工程师正在为一条偏远的铁路线设计一个信号系统。该系统被简化为仅传输三个不同的消息：`NORMAL`、`CAUTION` 和 `HALT`。根据运营分析，工程师确定了这些消息的长期频率：`NORMAL` 信号占所有传输的 50%，而 `CAUTION` 和 `HALT` 信号各占 25% 的传输。\n\n为了简化设计和硬件，工程师采用了一种定长二进制编码方案。在这个方案中，三个消息中的每一个都由一个唯一的、长度恰好为 2 的二进制数字序列表示。\n\n编码的冗余度定义为，与信息源理想编码所需的理论最小平均比特数相比，每个消息平均多传输的比特数。计算工程师编码方案的冗余度。用一个数值表示你的答案，单位为比特/符号。", "solution": "问题要求计算特定编码方案的冗余度。根据问题中的定义，冗余度是每个符号的实际平均码长与每个符号的理论最小平均码长之间的差值。理论最小值由信源的熵给出。\n\n设消息集合为 $S = \\{\\text{NORMAL}, \\text{CAUTION}, \\text{HALT}\\}$。我们已知它们的概率和对应码字的长度。\n\n步骤 1：确定概率和码长。\n这些符号的概率是：\n$p(\\text{NORMAL}) = 0.5$\n$p(\\text{CAUTION}) = 0.25$\n$p(\\text{HALT}) = 0.25$\n\n问题陈述，对所有三个消息都使用长度为 2 的定长二进制编码。因此，码长为：\n$l(\\text{NORMAL}) = 2$\n$l(\\text{CAUTION}) = 2$\n$l(\\text{HALT}) = 2$\n\n步骤 2：计算信源的熵。\n熵 $H(S)$ 给出每个符号的理论最小平均比特数。熵的公式是：\n$$H(S) = -\\sum_{i \\in S} p(i) \\log_{2}(p(i))$$\n\n代入给定的概率：\n$$H(S) = - [p(\\text{NORMAL})\\log_{2}(p(\\text{NORMAL})) + p(\\text{CAUTION})\\log_{2}(p(\\text{CAUTION})) + p(\\text{HALT})\\log_{2}(p(\\text{HALT}))]$$\n$$H(S) = - [0.5 \\log_{2}(0.5) + 0.25 \\log_{2}(0.25) + 0.25 \\log_{2}(0.25)]$$\n\n我们计算对数项：\n$\\log_{2}(0.5) = \\log_{2}(2^{-1}) = -1$\n$\\log_{2}(0.25) = \\log_{2}(2^{-2}) = -2$\n\n现在将这些值代回熵方程：\n$$H(S) = - [0.5(-1) + 0.25(-2) + 0.25(-2)]$$\n$$H(S) = - [-0.5 - 0.5 - 0.5]$$\n$$H(S) = - [-1.5] = 1.5 \\text{ 比特/符号}$$\n\n这是表示该信源的任何编码的理论最小平均长度。\n\n步骤 3：计算工程师编码的平均码长。\n平均码长 $L$ 是码字长度的加权平均值，其中权重是符号的概率。\n$$L = \\sum_{i \\in S} p(i) l(i)$$\n\n代入给定的概率和码长：\n$$L = p(\\text{NORMAL})l(\\text{NORMAL}) + p(\\text{CAUTION})l(\\text{CAUTION}) + p(\\text{HALT})l(\\text{HALT})$$\n$$L = (0.5)(2) + (0.25)(2) + (0.25)(2)$$\n$$L = 1.0 + 0.5 + 0.5 = 2.0 \\text{ 比特/符号}$$\n\n这是工程师的定长编码所使用的每个符号的实际平均比特数。\n\n步骤 4：计算冗余度。\n冗余度 $R$ 是平均码长与熵之间的差值。\n$$R = L - H(S)$$\n\n代入前面步骤中计算出的值：\n$$R = 2.0 \\text{ 比特/符号} - 1.5 \\text{ 比特/符号}$$\n$$R = 0.5 \\text{ 比特/符号}$$", "answer": "$$\\boxed{0.5}$$", "id": "1629773"}, {"introduction": "除了效率，可靠性是通信的另一个基石。这个问题深入探讨了一种早期的错误检测方法，这是现代信道编码技术的前身。通过分析二维奇偶校验方案在何种情况下会失效，我们可以深入了解在不完美信道上准确传输数据的根本挑战，以及发展更强大编码的必要性 [@problem_id:1629782]。", "problem": "在数字通信的早期，在像汉明码这样更先进的技术发展起来之前，人们采用了一些简单的错误检测方案。其中一种方法包括将数据位排列成一个二维网格，并为每行和每列添加奇偶校验位。\n\n考虑一个方案，其中9个数据位（记为 $d_{ij}$，其中 $i, j \\in \\{1, 2, 3\\}$）被排列在一个 $3 \\times 3$ 的网格中。为三行中的每一行追加一个额外的奇偶校验位 $p_{i,c}$。为三列中的每一列追加一个额外的奇偶校验位 $p_{r,j}$。这就形成了一个由数据和行校验位组成的 $4 \\times 3$ 块，以及一个由列校验位组成的 $1 \\times 4$ 块（包括一个对行校验位列的校验位）。最终传输的完整数据块是一个 $4 \\times 4$ 的比特网格。\n\n所有奇偶校验位都使用偶校验方案计算，这意味着任何完整行（3个数据位 + 1个校验位）或任何完整列（3个数据位 + 1个校验位）中的比特之和必须是偶数。当原始的9位数据块中的一个或多个位在传输过程中被翻转（0变为1，或1变为0）时，就会发生错误。如果在比特翻转后，接收到的 $4 \\times 4$ 数据块的所有行和列的奇偶校验仍然通过，那么这种错误模式就被认为是“未被检测到的”。\n\n假设错误只发生在9个数据位中，能够导致一个未被检测到的错误的最小比特翻转数是多少？", "solution": "令 $d_{ij}$（其中 $i,j \\in \\{1,2,3\\}$）表示原始数据位，令 $e_{ij} \\in \\{0,1\\}$ 表示 $d_{ij}$ 在传输过程中是否被翻转（$e_{ij}=1$ 表示在位置 $(i,j)$ 发生了翻转）。错误只发生在数据位上，因此所有奇偶校验位保持不变。为了让接收到的 $4 \\times 4$ 数据块的偶校验检查通过，每个数据行和每个数据列的奇偶性必须保持不变。由于奇偶校验位是固定的，这等价于要求每个数据行和每个数据列中的翻转次数为偶数。\n\n形式上，未被检测到的错误的条件是\n$$\n\\sum_{j=1}^{3} e_{ij} \\equiv 0 \\pmod{2} \\quad \\text{for } i=1,2,3,\n\\qquad\n\\sum_{i=1}^{3} e_{ij} \\equiv 0 \\pmod{2} \\quad \\text{for } j=1,2,3.\n$$\n设总翻转数为 $w=\\sum_{i=1}^{3}\\sum_{j=1}^{3} e_{ij}$。首先，$w$ 必须是偶数，因为\n$$\nw=\\sum_{i=1}^{3}\\sum_{j=1}^{3} e_{ij} \\equiv \\sum_{i=1}^{3} \\left( \\sum_{j=1}^{3} e_{ij} \\right) \\equiv 0 \\pmod{2},\n$$\n鉴于每行的和都是偶数。因此 $w$ 不可能是1或3。\n\n考虑 $w=2$ 的情况。两个翻转的位置有三种可能性：\n(i) 同一行，不同列：受影响行的翻转和为 $2 \\equiv 0 \\pmod{2}$，但两个受影响列的翻转和各为 $1 \\equiv 1 \\pmod{2}$，这违反了列校验；\n(ii) 同一列，不同行：受影响列的翻转和为 $2 \\equiv 0 \\pmod{2}$，但两个受影响行的翻转和各为 $1 \\equiv 1 \\pmod{2}$，这违反了行校验；\n(iii) 不同行且不同列：两行的翻转和为1，两列的翻转和也为1，同时违反了行校验和列校验。因此，$w=2$ 是不可能的。\n\n现在考虑 $w=4$ 的情况。选择两个不同的行 $i_{1}\\neq i_{2}$ 和两个不同的列 $j_{1}\\neq j_{2}$，并设置 $e_{i_{1}j_{1}}=e_{i_{1}j_{2}}=e_{i_{2}j_{1}}=e_{i_{2}j_{2}}=1$，所有其他的 $e_{ij}=0$。这样，行 $i_{1},i_{2}$ 各恰好有两次翻转（偶数），剩下的一行有零次翻转（偶数），类似地，列 $j_{1},j_{2}$ 各恰好有两次翻转（偶数），剩下的一列有零次翻转（偶数）。因此，所有的行和列奇偶校验都通过。涉及仅含校验位的行和列的奇偶校验也会自动通过，因为那些位没有被翻转。\n\n因此，能导致未被检测到的错误的最小非零数据位翻转数是 $w=4$。", "answer": "$$\\boxed{4}$$", "id": "1629782"}]}