{"hands_on_practices": [{"introduction": "霍夫曼编码是无损数据压缩领域的基石。虽然我们最常接触的是二进制（$D=2$）霍夫曼编码，但其核心思想可以推广到任何大小的码字母表（$D \\gt 2$）。本练习将指导你构建一个三元（$D=3$）霍夫曼码，这不仅能加深你对算法基本步骤的理解，还能让你掌握处理非二进制编码时为满足分组条件而引入“伪符号”的关键技巧。[@problem_id:1659054]", "problem": "一个研究团队正在为一个简化的化学信号系统开发一种通信协议。该系统使用六种不同的分子信号，表示为 $S = \\{s_1, s_2, s_3, s_4, s_5, s_6\\}$。根据经验确定，观察到每种信号的概率为 $P(s_1) = 0.35$, $P(s_2) = 0.25$, $P(s_3) = 0.15$, $P(s_4) = 0.12$, $P(s_5) = 0.08$ 和 $P(s_6) = 0.05$。\n\n为了高效地传输这些信息，团队决定使用三元哈夫曼编码，其码字母表为 $\\{0, 1, 2\\}$。\n\n计算生成的三元哈夫曼码的平均长度。答案以每个源符号的三元数字为单位表示，并四舍五入到三位有效数字。", "solution": "目标是为一个包含六个符号的信源构建一个三元哈夫曼码，然后计算其平均长度。三元码使用 $D=3$ 个码符号。\n\nD元码的哈夫曼算法要求，在每一步中要合并的符号数量满足条件 $(N_k - 1) \\pmod{D-1} = 0$，其中 $N_k$ 是第 $k$ 步的符号数。这对于初始符号集 $N_0$ 必须成立。在这里，我们有 $N=6$ 个源符号，并且我们正在创建一个三元码，因此 $D=3$。条件是 $(N_0 - 1) \\pmod{2} = 0$。由于我们的初始符号数是 $N=6$，我们有 $(6-1) \\pmod{2} = 5 \\pmod{2} = 1 \\neq 0$。\n\n为了满足该条件，我们必须添加概率为零的虚拟符号，直到符号总数 $N_0$ 使得 $(N_0 - 1)$ 是一个偶数。这意味着 $N_0$ 必须是奇数。大于或等于6的最小奇数是7。因此，我们需要添加 $7-6=1$ 个虚拟符号 $d_1$，其概率为 $P(d_1) = 0$。\n\n我们的初始符号集和概率是：\n$s_1: 0.35$\n$s_2: 0.25$\n$s_3: 0.15$\n$s_4: 0.12$\n$s_5: 0.08$\n$s_6: 0.05$\n$d_1: 0.00$\n\n现在我们继续执行哈夫曼算法，在每一步中将 $D=3$ 个概率最小的符号合并成一个新的复合符号。\n\n**步骤 1：**\n概率最小的三个符号是 $d_1(0.00)$、$s_6(0.05)$ 和 $s_5(0.08)$。我们将它们合并成一个新节点（我们称之为 $n_1$），其概率为 $0.00 + 0.05 + 0.08 = 0.13$。\n符号及其概率列表变为：\n$s_1: 0.35$\n$s_2: 0.25$\n$s_3: 0.15$\n$n_1: 0.13$\n$s_4: 0.12$\n\n**步骤 2：**\n我们对新列表进行排序，并再次合并三个概率最小的符号。当前按概率排序的列表是：$\\{s_4(0.12), n_1(0.13), s_3(0.15), s_2(0.25), s_1(0.35)\\}$。\n概率最小的三个是 $s_4(0.12)$、$n_1(0.13)$ 和 $s_3(0.15)$。我们将它们合并成一个新节点 ($n_2$)，其概率为 $0.12 + 0.13 + 0.15 = 0.40$。\n符号和概率列表变为：\n$n_2: 0.40$\n$s_1: 0.35$\n$s_2: 0.25$\n\n**步骤 3：**\n我们剩下三个符号：$n_2(0.40)$、$s_1(0.35)$ 和 $s_2(0.25)$。我们将它们合并成树的根节点，概率为 $0.40 + 0.35 + 0.25 = 1.00$。构建完成。\n\n现在，我们通过从根节点遍历树来分配码字。我们将按照所连接节点的概率递减顺序，将码符号 $\\{0, 1, 2\\}$ 分配给分支。\n\n- 在根节点（和=1.00），分支指向 $n_2(0.40)$、$s_1(0.35)$ 和 $s_2(0.25)$。\n  - $n_2(0.40) \\rightarrow 0$\n  - $s_1(0.35) \\rightarrow 1$。所以，$s_1$ 的码字是 `1`。\n  - $s_2(0.25) \\rightarrow 2$。所以，$s_2$ 的码字是 `2`。\n\n- 从节点 $n_2(0.40)$ 出发，分支指向 $s_3(0.15)$、$n_1(0.13)$ 和 $s_4(0.12)$。\n  - $s_3(0.15) \\rightarrow 0$。从根节点开始的路径是 `0`，所以 $s_3$ 的码字是 `00`。\n  - $n_1(0.13) \\rightarrow 1$。从根节点开始的路径是 `0`，所以前缀是 `01`。\n  - $s_4(0.12) \\rightarrow 2$。从根节点开始的路径是 `0`，所以 $s_4$ 的码字是 `02`。\n\n- 从节点 $n_1(0.13)$ 出发，分支指向 $s_5(0.08)$、$s_6(0.05)$ 和 $d_1(0.00)$。\n  - $s_5(0.08) \\rightarrow 0$。从根节点开始的路径是 `01`，所以 $s_5$ 的码字是 `010`。\n  - $s_6(0.05) \\rightarrow 1$。从根节点开始的路径是 `01`，所以 $s_6$ 的码字是 `011`。\n  - $d_1(0.00) \\rightarrow 2$。从根节点开始的路径是 `01`，所以 $d_1$ 的码字是 `012`，这个码字未使用。\n\n最终的码本是：\n- $s_1: 1$ (长度 $l_1=1$)\n- $s_2: 2$ (长度 $l_2=1$)\n- $s_3: 00$ (长度 $l_3=2$)\n- $s_4: 02$ (长度 $l_4=2$)\n- $s_5: 010$ (长度 $l_5=3$)\n- $s_6: 011$ (长度 $l_6=3$)\n\n平均长度 $L_{avg}$ 是每个符号的概率与其码字长度的乘积之和：\n$L_{avg} = \\sum_{i=1}^{6} P(s_i) l_i$\n$L_{avg} = (0.35 \\times 1) + (0.25 \\times 1) + (0.15 \\times 2) + (0.12 \\times 2) + (0.08 \\times 3) + (0.05 \\times 3)$\n$L_{avg} = 0.35 + 0.25 + 0.30 + 0.24 + 0.24 + 0.15$\n$L_{avg} = 1.53$\n\n平均长度是每个源符号 $1.53$ 个三元数字。这个值已经是三位有效数字了。", "answer": "$$\\boxed{1.53}$$", "id": "1659054"}, {"introduction": "学习了如何构建最优码后，一个自然的问题是：“最优”到底有多优？信息论告诉我们，信源熵 $H(S)$ 是数据压缩的理论极限，而任何实际编码的平均码长 $\\bar{L}$ 与熵之间的差值——即冗余度 $\\bar{L} - H(S)$——衡量了编码的低效程度。这个练习将通过一个精心设计的思想实验揭示，即使是“最优”的霍夫曼编码，在处理某些概率分布极不均衡的信源时，其冗余度也可能非常高，这暴露了该算法的一个内在局限性。[@problem_id:1659082]", "problem": "正在为一个专门的监控系统设计一种无损数据压缩方案，该系统追踪四种不同的事件类型，由符号集 $S = \\{s_1, s_2, s_3, s_4\\}$ 表示。为了最小化数据存储，使用二进制霍夫曼编码来对观测到的事件序列进行编码。这种编码的性能在很大程度上取决于源符号的概率分布。信源编码的冗余度，定义为 $R = \\bar{L} - H(S)$，衡量的是平均码长 $\\bar{L}$ 与信源香农熵 $H(S)$ 之间的差异。熵，以比特/符号为单位，由公式 $H(S) = \\sum_{i=1}^{4} -p_i \\log_{2}(p_i)$ 给出，其中 $p_i$ 是符号 $s_i$ 的概率。理想的编码其冗余度应为零。\n\n你的任务是从以下选项中找出一个“最坏情况”的概率分布，具体来说，是那种使得二进制霍夫曼编码效率极低的分布。下列哪个概率分布 $P(S) = \\{p_1, p_2, p_3, p_4\\}$ 导致的冗余度 $R$ 大于 $0.99$ 比特/符号？\n\nA. $P(S) = \\{0.99997, 0.00001, 0.00001, 0.00001\\}$\nB. $P(S) = \\{0.26, 0.25, 0.25, 0.24\\}$\nC. $P(S) = \\{1/2, 1/4, 1/8, 1/8\\}$\nD. $P(S) = \\{0.5, 0.2, 0.2, 0.1\\}$\nE. $P(S) = \\{0.4, 0.3, 0.2, 0.1\\}$", "solution": "冗余度定义为 $R=\\bar{L}-H(S)$，其中 $H(S)=\\sum_{i=1}^{4}-p_{i}\\log_{2}(p_{i})$。对于一个有四个符号的二进制霍夫曼编码，最优码长多重集是 $\\{2,2,2,2\\}$ 或 $\\{1,2,3,3\\}$，这取决于每一步霍夫曼合并中两个概率最小的符号。\n\n选项 A: $P=\\{0.99997,10^{-5},10^{-5},10^{-5}\\}$。霍夫曼编码将 $10^{-5}$ 和 $10^{-5}$ 合并为 $2\\times 10^{-5}$，然后将 $10^{-5}$ 和 $2\\times 10^{-5}$ 合并为 $3\\times 10^{-5}$，最后将 $0.99997$ 和 $3\\times 10^{-5}$ 合并。这得到的码长为 $\\{1,2,3,3\\}$，其中概率最高的符号码长为 $1$，一个稀有符号码长为 $2$，剩下的两个稀有符号码长为 $3$。因此\n$$\n\\bar{L}=0.99997\\cdot 1+10^{-5}\\cdot 2+10^{-5}\\cdot 3+10^{-5}\\cdot 3=1.00005.\n$$\n熵为\n$$\nH(S)=-0.99997\\log_{2}(0.99997)-3\\cdot 10^{-5}\\log_{2}(10^{-5}).\n$$\n利用 $\\log_{2}(10^{-5})=-5\\log_{2}(10)\\approx -16.609640$ 以及对 $p=0.99997$ 时 $-p\\log_{2}p$ 贡献很小（$\\approx 4.33\\times 10^{-5}$）的近似，我们得到\n$$\nH(S)\\approx 4.33\\times 10^{-5}+3\\cdot 10^{-5}\\cdot 16.609640\\approx 0.0005416.\n$$\n因此\n$$\nR=\\bar{L}-H(S)\\approx 1.00005-0.0005416\\approx 0.9995080.99.\n$$\n\n选项 B: $P=\\{0.26,0.25,0.25,0.24\\}$。霍夫曼编码得到的码长为 $\\{2,2,2,2\\}$，所以 $\\bar{L}=2$。熵为\n$$\nH(S)=-0.26\\log_{2}(0.26)-2\\cdot 0.25\\log_{2}(0.25)-0.24\\log_{2}(0.24)\\approx 1.9994,\n$$\n所以 $R\\approx 2-1.9994\\approx 0.0006  0.99$。\n\n选项 C: $P=\\{1/2,1/4,1/8,1/8\\}$。这些是二进概率，所以霍夫曼编码分配的码长恰好为 $l_{i}=-\\log_{2}p_{i}$，得到 $\\bar{L}=H(S)=1.75$ 且 $R=0  0.99$。\n\n选项 D: $P=\\{0.5,0.2,0.2,0.1\\}$。霍夫曼编码将 $0.1$与一个 $0.2$ 合并，然后与另一个 $0.2$ 合并，最后与 $0.5$ 合并，得到的码长为 $\\{1,2,3,3\\}$ 且\n$$\n\\bar{L}=0.5\\cdot 1+0.2\\cdot 2+0.2\\cdot 3+0.1\\cdot 3=1.8.\n$$\n熵为\n$$\nH(S)=-0.5\\log_{2}(0.5)-2\\cdot 0.2\\log_{2}(0.2)-0.1\\log_{2}(0.1)\\approx 1.760964,\n$$\n所以 $R\\approx 1.8-1.760964\\approx 0.039  0.99$。\n\n选项 E: $P=\\{0.4,0.3,0.2,0.1\\}$。霍夫曼编码将 $0.1$ 和 $0.2$ 合并，然后将两个概率为 $0.3$ 的节点合并，再与 $0.4$ 合并，得到码长 $\\{1,2,3,3\\}$ 且\n$$\n\\bar{L}=0.4\\cdot 1+0.3\\cdot 2+0.2\\cdot 3+0.1\\cdot 3=1.9.\n$$\n熵为\n$$\nH(S)=-0.4\\log_{2}(0.4)-0.3\\log_{2}(0.3)-0.2\\log_{2}(0.2)-0.1\\log_{2}(0.1)\\approx 1.84644,\n$$\n所以 $R\\approx 1.9-1.84644\\approx 0.0536  0.99$。\n\n只有选项 A 产生的冗余度大于 $0.99$ 比特/符号。", "answer": "$$\\boxed{A}$$", "id": "1659082"}, {"introduction": "前面的练习表明，霍夫曼编码的性能受限于其必须为每个信源符号分配整数长度码字的结构，导致在某些情况下产生显著的冗余。算术编码提供了一种更强大、更灵活的替代方案，它将整个消息序列映射到 $[0, 1)$ 区间内的一个浮点数，从而能够以更高的精度逼近信源熵。通过这个动手实践，你将逐步执行算术编码的核心过程——递归地划分和选择子区间——来亲身体验这一高效编码方法的工作原理。[@problem_id:1659115]", "problem": "一个简单的随机源从字母表 {A, B, C} 中生成符号。这些符号的概率如下所示：\n$P(\\text{A}) = 0.25$\n$P(\\text{B}) = 0.60$\n$P(\\text{C}) = 0.15$\n\n一种特定的数据压缩方案将这些符号的任意序列映射到初始区间 $[0, 1)$ 内一个唯一的浮点子区间。该映射过程被递归地定义如下：\n1. 初始区间为 $[0, 1)$。该区间被划分为与符号 A、B、C 相对应的子区间，并按此顺序排列。每个子区间的长度等于相应符号的概率。\n2. 为了编码一个序列，初始区间被缩小到序列中第一个符号的子区间。\n3. 这个新的、更小的区间然后以与原始区间 $[0, 1)$ 相同的比例进行划分。然后该过程再缩小到对应于序列中第二个符号的子区间。\n4. 对序列中的所有符号重复此递归过程。\n\n确定表示序列“BCA”的最终区间 $[L, U)$。将您的答案表示为一个行矩阵，其中包含下界 $L$ 和上界 $U$（按此顺序），并将两个值四舍五入到五位有效数字。", "solution": "我们应用算术编码中的递归区间细化方法。设当前区间为 $[L, U)$，宽度为 $R=U-L$。根据符号顺序 A、B、C 及其概率 $p_{A}=0.25$、$p_{B}=0.60$、$p_{C}=0.15$，在任何区间 $[L,U)$ 内的划分如下：\n- A: $[L,\\, L + 0.25R)$\n- B: $[L + 0.25R,\\, L + 0.85R)$\n- C: $[L + 0.85R,\\, U)$\n\n从 $[L_{0}, U_{0}) = [0, 1)$ 开始，所以 $R_{0}=1$。\n\n第一个符号 B：选择 $[L_{1}, U_{1}) = [L_{0} + 0.25R_{0},\\, L_{0} + 0.85R_{0}) = [0.25,\\, 0.85)$。则 $R_{1} = U_{1} - L_{1} = 0.60$。\n\n第二个符号 C：在 $[0.25, 0.85)$ 内选择 $[L_{2}, U_{2}) = [L_{1} + 0.85R_{1},\\, U_{1}) = [0.25 + 0.85 \\cdot 0.60,\\, 0.85) = [0.76,\\, 0.85)$。则 $R_{2} = U_{2} - L_{2} = 0.09$。\n\n第三个符号 A：在 $[0.76, 0.85)$ 内选择 $[L_{3}, U_{3}) = [L_{2},\\, L_{2} + 0.25R_{2}) = [0.76,\\, 0.76 + 0.25 \\cdot 0.09] = [0.76,\\, 0.7825)$。\n\n因此，最终区间为 $[L, U) = [0.76, 0.7825)$。将每个边界四舍五入到五位有效数字，得到 $L = 0.76000$ 和 $U = 0.78250$。", "answer": "$$\\boxed{\\begin{pmatrix}0.76000  0.78250\\end{pmatrix}}$$", "id": "1659115"}]}