{"hands_on_practices": [{"introduction": "要掌握 LZ77 算法，核心在于理解其滑动窗口机制。本练习 [@problem_id:1617527] 将带你逐步追踪编码过程，通过观察搜索缓冲区和前向缓冲区的内容变化，你将亲身体验 LZ77 是如何发现并编码重复数据序列的。", "problem": "一个数据压缩系统使用 Lempel-Ziv 1977 (LZ77) 算法的简化版本。该算法通过在输入数据流上维护一个滑动窗口来工作。这个窗口分为两部分：一个搜索缓冲区，包含最近处理过的文本；以及一个前瞻缓冲区，包含下一段要编码的文本。\n\n压缩器会找出前瞻缓冲区中最长的、同时也在搜索缓冲区中出现过的前缀。然后它会输出一个短语，这是一个三元组 `(offset, length, next_char)`，其中：\n- `offset` 是从当前位置回到搜索缓冲区中匹配项起始位置的距离。offset 为 0 表示未找到匹配项。\n- `length` 是最长匹配的长度。length 为 0 表示未找到匹配项。\n- `next_char` 是前瞻缓冲区中紧跟在匹配前缀之后的第一个字符。如果未找到匹配项（即 length 为 0），则它就是前瞻缓冲区的第一个字符。\n\n编码一个短语后，滑动窗口向前移动 `length + 1` 个字符。\n\n考虑输入字符串 `A_CAT_SAW_A_RAT_EAT_A_CAT`（其中 `_` 代表空格字符）。压缩器配置的搜索缓冲区大小为 8，前瞻缓冲区大小为 7。处理过程从一个空的搜索缓冲区开始，前瞻缓冲区从字符串的开头填充。\n\n在编码了前五个短语之后，搜索缓冲区和前瞻缓冲区的内容分别是什么？\n\nA. 搜索缓冲区: `A_CAT_S`, 前瞻缓冲区: `AW_A_RA`\n\nB. 搜索缓冲区: `A_CAT`, 前瞻缓冲区: `_SAW_A_`\n\nC. 搜索缓冲区: `A_CAT_S`, 前瞻缓冲区: `AW_A_RAT`\n\nD. 搜索缓冲区: `CAT_SAW`, 前瞻缓冲区: `_A_RAT_`\n\nE. 搜索缓冲区: `_CAT_SA`, 前瞻缓冲区: `W_A_RAT`", "solution": "问题要求在 LZ77 算法的五个编码步骤之后，搜索缓冲区和前瞻缓冲区的状态。\n\n参数如下：\n- 输入字符串: `A_CAT_SAW_A_RAT_EAT_A_CAT`\n- 搜索缓冲区大小 (S): 8\n- 前瞻缓冲区大小 (L): 7\n\n让我们逐步跟踪缓冲区的状态。符号 `|` 将表示搜索缓冲区和前瞻缓冲区之间的边界（即当前光标位置）。\n\n**初始状态：**\n光标位于字符串的开头。搜索缓冲区为空。前瞻缓冲区填充了前 7 个字符。\n- 字符串视图: `|A_CAT_SAW_A_RAT_EAT_A_CAT`\n- 搜索缓冲区 (SB): ` ` (空)\n- 前瞻缓冲区 (LAB): `A_CAT_S`\n\n**步骤 1：**\n- 前瞻缓冲区以 `A` 开始。我们在空的搜索缓冲区中搜索 `A`。未找到匹配。\n- 编码后的短语是 `(offset=0, length=0, next_char='A')`。\n- 窗口向前移动 `length + 1 = 1` 个字符。\n- 步骤 1 后的状态：\n    - 字符串视图: `A|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A`\n    - LAB: `_CAT_SA`\n\n**步骤 2：**\n- 前瞻缓冲区以 `_` 开始。我们在搜索缓冲区 (`A`) 中搜索 `_`。未找到匹配。\n- 编码后的短语是 `(0, 0, '_')`。\n- 窗口向前移动 `length + 1 = 1` 个字符。\n- 步骤 2 后的状态：\n    - 字符串视图: `A_|_CAT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_`\n    - LAB: `CAT_SAW`\n\n**步骤 3：**\n- 前瞻缓冲区以 `C` 开始。我们在搜索缓冲区 (`A_`) 中搜索 `C`。未找到匹配。\n- 编码后的短语是 `(0, 0, 'C')`。\n- 窗口向前移动 `length + 1 = 1` 个字符。\n- 步骤 3 后的状态：\n    - 字符串视图: `A_C|AT_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_C`\n    - LAB: `AT_SAW_`\n\n**步骤 4：**\n- 前瞻缓冲区以 `A` 开始。我们在搜索缓冲区 (`A_C`) 中搜索 `A`。找到一个匹配。\n- 匹配项 `A` 位于 `A_C` 缓冲区的开头。从光标回到这个 `A` 的距离是 2 个位置。所以，`offset = 2`。\n- 我们检查是否存在更长的匹配。前瞻缓冲区中 `A` 后面的字符是 `T`。原始字符串 (`A_C...`) 中匹配的 `A` 后面的字符是 `_`。由于 `T` 不等于 `_`，匹配无法扩展。\n- 最长匹配的长度为 `length = 1`。\n- `next_char` 是前瞻缓冲区中匹配项之后的字符，即 `T`。\n- 编码后的短语是 `(2, 1, 'T')`。\n- 窗口向前移动 `length + 1 = 1 + 1 = 2` 个字符。\n- 步骤 4 后的状态：\n    - 字符串视图: `A_CAT|_SAW_A_RAT_EAT_A_CAT`\n    - SB: `A_CAT`\n    - LAB: `_SAW_A_`\n\n**步骤 5：**\n- 前瞻缓冲区以 `_` 开始。我们在搜索缓冲区 (`A_CAT`) 中搜索 `_`。找到一个匹配。\n- 匹配项 `_` 位于 `A_CAT` 缓冲区的第二个位置。从光标回到这个 `_` 的距离是 3 个位置。所以，`offset = 3`。\n- 我们检查是否存在更长的匹配。前瞻缓冲区中 `_` 后面的字符是 `S`。原始字符串 (`A_CAT...`) 中匹配的 `_` 后面的字符是 `C`。由于 `S` 不等于 `C`，匹配无法扩展。\n- 最长匹配的长度为 `length = 1`。\n- `next_char` 是前瞻缓冲区中匹配项之后的字符，即 `S`。\n- 编码后的短语是 `(3, 1, 'S')`。\n- 窗口向前移动 `length + 1 = 1 + 1 = 2` 个字符。\n- 步骤 5 后的状态：\n    - 字符串视图: `A_CAT_S|AW_A_RAT_EAT_A_CAT`\n    - 搜索缓冲区包含光标左侧的 8 个字符（如果在字符串开头，则更少）。当前光标左侧的字符串是 `A_CAT_S`，其长度为 7。这在缓冲区大小之内。所以，SB: `A_CAT_S`。\n    - 前瞻缓冲区包含光标右侧的 7 个字符。所以，LAB: `AW_A_RA`。\n\n在编码了五个短语之后，最终状态是：\n- 搜索缓冲区: `A_CAT_S`\n- 前瞻缓冲区: `AW_A_RA`\n\n这对应于选项 A。", "answer": "$$\\boxed{A}$$", "id": "1617527"}, {"introduction": "与 LZ77 不同，LZ78 算法通过显式构建一个短语词典来进行压缩。通过这个练习 [@problem_id:1617519]，你将模拟 LZ78 编码器的工作，学习如何将输入字符串解析为一系列（索引，字符）对，并观察词典是如何随着处理过程而动态增长的。", "problem": "Lempel-Ziv 1978 (LZ78) 算法是一种基于字典的无损数据压缩方法。它通过解析字符串并建立一个所遇到短语的字典来压缩字符串。\n\n该算法的流程如下：\n1.  字典初始为空。新短语从1开始被分配整数索引。\n2.  算法迭代地在输入字符串的剩余未读部分中，查找已存在于字典中的最长前缀。设该前缀对应的字典索引为 `i`。\n3.  一个非空前缀必须与字典条目完全匹配。如果找不到非空前缀，则匹配被视为空字符串，我们使用索引 `i=0`。\n4.  然后，算法从输入流中读取紧跟在匹配前缀后的下一个单字符 `C`。\n5.  生成一个输出对 `(i, C)`，它代表短语 `prefix + C` 的压缩形式。\n6.  这个新短语 `prefix + C` 被添加到字典中，并分配下一个可用的整数索引。\n7.  已处理的短语 (`prefix + C`) 从输入字符串的开头被移除，然后重复此过程，直到整个字符串被处理完毕。\n\n考虑输入字符串 `S = BOOKKEEPER`。该字符串将被解析为一系列短语，并且对于每个短语，都会生成一个输出对 `(i, C)`。请确定在字符串 `S` 的 LZ78 压缩过程中生成的前缀索引 `i` 的序列。将您的答案表示为一个整数序列。", "solution": "将字典初始化为空，并设置下一个可用索引从1开始。根据 LZ78 规则，迭代处理输入字符串 $S=\\text{BOOKKEEPER}$。\n\n第1次迭代：剩余输入为 BOOKKEEPER。字典中没有非空前缀，所以 $i=0$。下一个字符是 $C='B'$。输出 $(0, 'B')$，将短语 $\\text{B}$ 以索引 $1$ 添加到字典中，并移除 $\\text{B}$。剩余输入：OOKKEEPER。\n\n第2次迭代：剩余输入为 OOKKEEPER。字典中没有与开头匹配的非空前缀，所以 $i=0$。下一个字符是 $C='O'$。输出 $(0, 'O')$，将短语 $\\text{O}$ 以索引 $2$ 添加到字典中，并移除 $\\text{O}$。剩余输入：OKKEEPER。\n\n第3次迭代：剩余输入为 OKKEEPER。最长的匹配前缀是 $\\text{O}$，索引为 $2$。下一个字符是 $C='K'$。输出 $(2, 'K')$，将短语 $\\text{OK}$ 以索引 $3$ 添加到字典中，并移除 $\\text{OK}$。剩余输入：KEEPER。\n\n第4次迭代：剩余输入为 KEEPER。字典中没有与开头匹配的非空前缀，所以 $i=0$。下一个字符是 $C='K'$。输出 $(0, 'K')$，将短语 $\\text{K}$ 以索引 $4$ 添加到字典中，并移除 $\\text{K}$。剩余输入：EEPER。\n\n第5次迭代：剩余输入为 EEPER。字典中没有与开头匹配的非空前缀，所以 $i=0$。下一个字符是 $C='E'$。输出 $(0, 'E')$，将短语 $\\text{E}$ 以索引 $5$ 添加到字典中，并移除 $\\text{E}$。剩余输入：EPER。\n\n第6次迭代：剩余输入为 EPER。最长的匹配前缀是 $\\text{E}$，索引为 $5$。下一个字符是 $C='P'$。输出 $(5, 'P')$，将短语 $\\text{EP}$ 以索引 $6$ 添加到字典中，并移除 $\\text{EP}$。剩余输入：ER。\n\n第7次迭代：剩余输入为 ER。最长的匹配前缀是 $\\text{E}$，索引为 $5$。下一个字符是 $C='R'$。输出 $(5, 'R')$，将短语 $\\text{ER}$ 以索引 $7$ 添加到字典中，并移除 $\\text{ER}$。剩余输入：空，过程停止。\n\n按顺序收集每个输出对中的前缀索引 $i$，得到序列 $0, 0, 2, 0, 0, 5, 5$。", "answer": "$$\\boxed{0, 0, 2, 0, 0, 5, 5}$$", "id": "1617519"}, {"introduction": "LZW 算法是 LZ78 的一个重要变种，它在 GIF、TIFF 等多种格式中得到了广泛应用。这个练习 [@problem_id:1617490] 提供了一个更具挑战性的任务：你需要逆向思考，构建一个特定的输入字符串，以使编码器在词典中生成一个目标短语。这能加深你对 LZW 词典构建规则的理解。", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。它的运作依赖于在编码过程中构建一个遇到的字符串字典。\n\n考虑一个标准的 LZW 编码器实现，它在一个仅由两个字符 'A' 和 'B' 组成的字母表上运行。其过程如下：\n1. 字典被初始化为包含字母表中所有单个字符。在这种情况下，初始字典为 `{'A', 'B'}`。\n2. 当前匹配字符串 `w` 通过读取输入流的第一个字符来初始化。\n3. 然后，算法遍历输入流中剩余的字符。对于每个后续字符 `k`：\n    a. 如果将当前匹配与新字符连接形成的新字符串 `w + k` 已存在于字典中，则扩展当前匹配，即 `w` 更新为 `w + k`。\n    b. 如果 `w + k` 不在字典中，算法首先将这个新字符串 `w + k` 添加到字典中，然后将当前匹配 `w` 重置为单字符字符串 `k`。\n4. 这个过程持续进行，直到整个输入流都被处理完毕。\n\n你的任务是确定最短的可能输入字符串，当这个字符串输入到该 LZW 编码器时，会使得特定字符串 'BABA' 被添加到字典中。", "solution": "我们想找到在字母表 $\\{A,B\\}$ 上的最短输入，该输入能使 LZW 编码器（仅用 $A$ 和 $B$ 初始化）将字符串 $BABA$ 添加到字典中。在 LZW 中，新字符串的添加时机是：当对于当前匹配 $w$ 和下一个输入字符 $k$，拼接结果 $w+k$ 尚不在字典中时；此时编码器会插入 $w+k$ 并将 $w$ 重置为单个字符 $k$。因此，要添加 $BABA$，我们必须达到一个步骤，其中 $w=BAB$ 且 $k=A$，并且 $BABA$ 尚未在字典中。根据 LZW 的不变量，$w$ 在那一刻必须是字典中已有的条目，所以 $BAB$ 必须在此之前已经被添加。\n\n首先确定 $BAB$ 最早可能被添加的时间点。初始时 $D_{0}=\\{A,B\\}$。添加 $BA$ 的最早方式是以 $B$ 开始，然后是 $A$：\n- 读取第一个符号 $B$，因此 $w=B$。\n- 下一个 $k=A$：$BA\\notin D_{0}$，因此插入 $BA$ 得到 $D_{1}=D_{0}\\cup\\{BA\\}$，然后设置 $w=A$。\n要添加 $BAB$，我们需要一个步骤，其中 $w=BA$ 且下一个 $k=B$，此时 $BAB$ 尚未在字典中。添加 $BA$ 后，下一个符号 $B$ 与 $w=A$ 配对，得出 $AB\\notin D_{1}$，因此添加 $AB$ 并设置 $w=B$。随后的 $A$ 使得 $w=BA$，而再下一个 $B$ 则导致 $BAB$ 被添加。因此，$BAB$ 最早可以在处理第五个输入符号时被添加。\n\n一旦 $BAB$ 被添加，为了添加 $BABA$，我们必须有 $w=BAB$ 然后读取 $k=A$。插入 $BAB$ 后，编码器立即将 $w$ 重置为 $B$。在此之后，要得到 $w=BAB$ 的最短方式是读取 $A$（使得 $w=BA$），然后读取 $B$（因为 $BAB$ 此时已在字典中，这会扩展为 $w=BAB$），接着再读取 $A$ 来触发 $BABA$ 的插入。因此，$BABA$ 最早可以在第八个输入符号处被添加。\n\n实现这一目标的一个明确的最短输入是 $BABABABA$。逐步验证如下：\n- 初始化 $D_{0}=\\{A,B\\}$ 并读取第一个符号 $B$，因此 $w=B$。\n- 符号 2，$k=A$：$BA\\notin D_{0}$，插入 $BA$，设置 $w=A$。\n- 符号 3，$k=B$：$AB\\notin D_{1}$，插入 $AB$，设置 $w=B$。\n- 符号 4，$k=A$：$BA\\in D$，扩展 $w=BA$。\n- 符号 5，$k=B$：$BAB\\notin D$，插入 $BAB$，设置 $w=B$。\n- 符号 6，$k=A$：$BA\\in D$，扩展 $w=BA$。\n- 符号 7，$k=B$：$BAB\\in D$，扩展 $w=BAB$。\n- 符号 8，$k=A$：$BABA\\notin D$，插入 $BABA$。\n\n如上所述，没有更短的输入可以在第八个符号之前实现 $BABA$ 的插入。因此，最短的可能输入字符串是 $BABABABA$。", "answer": "$$\\boxed{BABABABA}$$", "id": "1617490"}]}