{"hands_on_practices": [{"introduction": "让我们从一个模拟真实世界数据压缩场景的完整示例开始。本练习将引导你完成整个过程，从一组符号概率开始，首先使用霍夫曼算法确定最优码长，然后构建最终的规范霍夫曼码。这项实践对于理解如何从源统计数据中推导出规范码至关重要。[@problem_id:1607377]", "problem": "一个自动化的天文台根据观测到的特性将瞬变天体事件分为四类。经过长时间的观测，这些事件的频率已经确定如下：\n- A类：50%\n- B类：25%\n- C类：12.5%\n- D类：12.5%\n\n为了有效存储，需要压缩这些分类的数据流，为此将构建一个规范霍夫曼码。为符号分配码字的排序过程要求，对于任何具有相同概率（因此具有相同码长）的符号，分配应遵循字母顺序（例如，'C' 在 'D' 之前分配码字）。\n\n下列哪组码字代表了这些事件类型的正确规范霍夫曼码？\n\nA. A类: 0, B类: 10, C类: 110, D类: 111\nB. A类: 1, B类: 01, C类: 001, D类: 000\nC. A类: 0, B类: 11, C类: 100, D类: 101\nD. A类: 0, B类: 10, C类: 111, D类: 110\nE. A类: 0, B类: 100, C类: 101, D类: 111", "solution": "设事件概率为 $p(A)=\\frac{1}{2}$，$p(B)=\\frac{1}{4}$，$p(C)=\\frac{1}{8}$ 和 $p(D)=\\frac{1}{8}$。霍夫曼过程在每一步中合并两个概率最小的符号：\n\n1. 合并 $C$ 和 $D$：$\\frac{1}{8}+\\frac{1}{8}=\\frac{1}{4}$，产生一个概率为 $\\frac{1}{4}$ 的节点。\n2. 现在多重集为 $\\left\\{\\frac{1}{2},\\frac{1}{4},\\frac{1}{4}\\right\\}$。合并两个概率为 $\\frac{1}{4}$ 的节点，得到 $\\frac{1}{2}$。\n3. 合并两个概率为 $\\frac{1}{2}$ 的节点以完成树的构建。\n\n由此，码长由树中的深度确定：$l(A)=1$，$l(B)=2$，$l(C)=3$ 和 $l(D)=3$。\n\n为构成规范霍夫曼码，按码长递增排序符号，对于相同长度的符号，按字母顺序排序：$(A,1)$，$(B,2)$，$(C,3)$，$(D,3)$。分配规范码时，从最短长度开始，赋予码值 $0$，然后以二进制递增；当移动到更长的码长时，进行左移操作：\n\n- 为 $A$ 分配长度为 $1$ 的码 $0$。\n- 将码值增至 $1$，然后左移 $1$ 位以移动到长度 $2$：$1 \\mapsto 10_{2}$，为 $B$ 分配 $10$。\n- 将码值 $10_2$ (即2) 增至 $3$，然后左移 $1$ 位以移动到长度 $3$：$3 \\mapsto 110_{2}$，为 $C$ 分配 $110$。\n- 在相同长度下增至 $111_{2}$，为 $D$ 分配 $111$。\n\n因此，规范码为 $A:0$，$B:10$，$C:110$，$D:111$，与选项 A 匹配。选项 C、D 和 E 的码长不正确或违反了相同长度内的字母顺序平局规则；选项 B 将最短码分配为 $1$ 而不是 $0$，这不是规范的。", "answer": "$$\\boxed{A}$$", "id": "1607377"}, {"introduction": "在实践中，我们可能从一个有效但非规范的前缀码开始。本练习演示了将任意给定的前缀码转换为其规范等价形式的关键过程，这是实现标准化和高效解码器的必要步骤。你将练习提取码长，然后应用规范的排序和分配规则，以生成一个结构更简单、更易于存储的码本。[@problem_id:1607358]", "problem": "在为物联网 (IoT) 设备中使用的轻量级遥测协议 (LTP) 设计数据压缩方案时，一组由符号 {A, B, C, D, E} 表示的五个常见状态消息使用前缀码进行编码。工程团队当前的原型使用了以下码本：\n- A: 000\n- B: 001\n- C: 010\n- D: 10\n- E: 11\n\n虽然此编码是有效的前缀码，但它不符合协议对*规范霍夫曼码*的要求，而规范霍夫曼码可以简化解码器的实现。要创建规范码，必须遵循以下标准流程：\n1.  首先，按码长的升序对符号进行排序。\n2.  然后，将任何码长相同的符号按字母顺序排序。\n3.  排序列表中的第一个符号被分配一个相应长度的全零码字。\n4.  每个后续符号的码字通过以下方式生成：取前一个符号的码字，将其（视为一个二进制整数）加 1，然后在右侧追加零位（左移），直到码字达到所需长度。\n\n你的任务是根据原型中的码长和指定的流程，将给定的非规范码本转换为其等效的规范霍夫曼码本。下列哪项代表了正确的规范码本？\n\nA) `A: 100, B: 101, C: 110, D: 00, E: 01`\nB) `A: 000, B: 001, C: 010, D: 10, E: 11`\nC) `A: 110, B: 101, C: 100, D: 01, E: 00`\nD) `A: 010, B: 011, C: 100, D: 00, E: 01`\nE) `A: 100, B: 110, C: 111, D: 00, E: 01`", "solution": "我们首先从给定的原型中提取码长，因为构建规范霍夫曼码只需要长度信息：\n- $A$：长度 $3$\n- $B$：长度 $3$\n- $C$：长度 $3$\n- $D$：长度 $2$\n- $E$：长度 $2$\n\n遵循规范码的构建流程：\n1. 按码长升序对符号排序；若码长相同，则按字母顺序排序。这得到的顺序是：$D$ (2)、$E$ (2)、$A$ (3)、$B$ (3)、$C$ (3)。\n\n2. 根据规则分配码字：第一个符号获得其对应长度的全零码字；每个后续码字通过将前一个码字（视为一个二进制整数）加 $1$，然后在右侧追加零直到达到所需长度来获得。\n\n- 对于 $D$（长度为 $2$）：分配长度为 $2$ 的全零码字，即 $00$。\n- 对于 $E$（长度为 $2$）：取前一个码字 $00$，加 $1$ 得到 $01$；长度已经是 $2$，因此分配 $01$。\n- 对于 $A$（长度为 $3$）：取前一个码字 $01$，加 $1$ 得到 $10$，然后追加零直到长度达到 $3$，得到 $100$。\n- 对于 $B$（长度为 $3$）：取前一个码字 $100$，加 $1$ 得到 $101$；长度已经是 $3$，因此分配 $101$。\n- 对于 $C$（长度为 $3$）：取前一个码字 $101$，加 $1$ 得到 $110$；长度已经是 $3$，因此分配 $110$。\n\n因此，规范码本是：\n- $A: 100$\n- $B: 101$\n- $C: 110$\n- $D: 00$\n- $E: 01$\n\n与选项比较，这与选项 A 相匹配。", "answer": "$$\\boxed{A}$$", "id": "1607358"}, {"introduction": "为了巩固你对构建算法的理解，本问题纯粹关注规范化过程本身。给定字母表的一组特定码长，你的任务是系统地应用排序和增量码字生成的规则。这项练习有助于你掌握创建规范码本的精确、分步的机制，确保你能够仅从码长信息中准确地重建整个码本。[@problem_id:1607359]", "problem": "一位工程师正在为资源受限的嵌入式系统设计一种压缩方案。该系统使用一个由六个状态符号组成的小型自定义字母表进行通信：`S = {A, B, C, D, E, F}`。为了最小化传输带宽，使用了可变长度前缀码。设计规范规定了每个符号的二进制码字的确切长度如下：\n- `length(A) = 1`\n- `length(B) = 3`\n- `length(C) = 3`\n- `length(D) = 4`\n- `length(E) = 4`\n- `length(F) = 3`\n\n为了确保接收端的解码器能够以最小的内存高效实现，码本必须根据一种特定的规范方法构建。这种方法从给定的长度集合中保证了一个唯一且可预测的码本，其定义过程如下：\n\n1.  字母表中的符号首先被排列成一个有序序列。主排序键是符号分配的码字长度（升序），而对于任何长度相同的符号，次排序键是它们的字母顺序（A 在 B 之前，B 在 C 之前，依此类推）。\n\n2.  这个有序序列中第一个符号的码字是一个由零组成的字符串，其长度为该符号指定的长度。\n\n3.  对于序列中的每个后续符号，其码字是通过获取前一个符号的二进制码字，将其解释为一个整数，将该整数加一，然后将结果表示为二进制字符串来生成的。然后，根据需要，用后缀零（即左移）填充这个新的二进制字符串，直到其长度与当前符号所需的码字长度相匹配。\n\n遵循这个确切的步骤，符号 `D` 的二进制码字是什么？\n\nA. `1101`\nB. `0111`\nC. `1110`\nD. `1111`\nE. `110`", "solution": "问题要求我们根据一组特定的规则构建一个规范前缀码，并找出符号 `D` 的码字。我们将按照问题描述中的步骤逐一进行。\n\n**第 1 步：对符号进行排序**\n第一步是根据指定的码字长度（升序）对符号进行排序，然后对于长度相同的符号按字母顺序排序。\n\n符号及其长度如下：\n- A: 1\n- B: 3\n- C: 3\n- D: 4\n- E: 4\n- F: 3\n\n我们创建一个 `(符号, 长度)` 对的列表：`(A, 1), (B, 3), (C, 3), (D, 4), (E, 4), (F, 3)`。\n\n现在，我们对这个列表进行排序。\n- 长度最短的符号是 `A`（长度为 1）。它排在第一位。\n- 接下来是长度为 3 的符号。按字母顺序对 `B`、`C` 和 `F` 进行排序，得到 `B`、`C`、`F`。\n- 最后是长度为 4 的符号。按字母顺序对 `D` 和 `E` 进行排序，得到 `D`、`E`。\n\n将这些组合起来，得到最终的有序符号序列：`A, B, C, F, D, E`。\n\n**第 2 步：迭代生成码字**\n\n我们现在为排序后序列中的每个符号生成码字。\n\n- **符号 `A` (长度 1):**\n这是第一个符号。其码字是长度为其指定长度的全零字符串。\n`code(A) = 0`\n\n- **符号 `B` (长度 3):**\n这是下一个符号。前一个码字是 `code(A) = 0`。\n1.  前一个码字 `0` 的整数值是 `0`。\n2.  加一：`0 + 1 = 1`。\n3.  前一个码字的长度是 1，当前要求的长度是 3。长度增加了。\n4.  规则 3 指出，我们必须用后缀零填充新的二进制数，以匹配所需的长度。`1` 的二进制表示是 `1`。要从长度 1 变为长度 3，我们需要添加 `3 - 1 = 2` 个后缀零（相当于左移 2 位）。\n`code(B) = 100`\n\n- **符号 `C` (长度 3):**\n前一个码字是 `code(B) = 100`。\n1.  前一个码字 `100` 的整数值是 `4`。\n2.  加一：`4 + 1 = 5`。\n3.  前一个码字的长度是 3，当前要求的长度是 3。长度没有改变。\n4.  `5` 的二进制表示是 `101`，其长度为 3。不需要填充。\n`code(C) = 101`\n\n- **符号 `F` (长度 3):**\n前一个码字是 `code(C) = 101`。\n1.  前一个码字 `101` 的整数值是 `5`。\n2.  加一：`5 + 1 = 6`。\n3.  前一个码字的长度是 3，当前要求的长度是 3。长度没有改变。\n4.  `6` 的二进制表示是 `110`，其长度为 3。不需要填充。\n`code(F) = 110`\n\n- **符号 `D` (长度 4):**\n前一个码字是 `code(F) = 110`。\n1.  前一个码字 `110` 的整数值是 `6`。\n2.  加一：`6 + 1 = 7`。\n3.  前一个码字的长度是 3，当前要求的长度是 4。长度增加了。\n4.  我们必须用后缀零填充新的二进制数。`7` 的二进制表示是 `111`。要从长度 3 变为长度 4，我们需要添加 `4 - 3 = 1` 个后缀零（相当于左移 1 位）。\n`code(D) = 1110`\n\n这就是我们要找的答案。为了完整起见，我们可以计算最后一个码字。\n\n- **符号 `E` (长度 4):**\n前一个码字是 `code(D) = 1110`。\n1.  前一个码字 `1110` 的整数值是 `14`。\n2.  加一：`14 + 1 = 15`。\n3.  前一个码字的长度是 4，当前要求的长度是 4。长度没有改变。\n4.  `15` 的二进制表示是 `1111`，其长度为 4。不需要填充。\n`code(E) = 1111`\n\n完整的规范码本是：\n- A: `0`\n- B: `100`\n- C: `101`\n- F: `110`\n- D: `1110`\n- E: `1111`\n\n符号 `D` 的码字是 `1110`。这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1607359"}]}