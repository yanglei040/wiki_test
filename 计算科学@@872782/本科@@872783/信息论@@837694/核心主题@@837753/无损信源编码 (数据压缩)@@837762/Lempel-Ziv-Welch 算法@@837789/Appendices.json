{"hands_on_practices": [{"introduction": "理解 LZW 算法的第一步是亲手执行其核心的编码过程。这个练习将引导你逐个字符地处理一个输入字符串，通过手动追踪字典的动态构建和码字的生成，来巩固对 LZW 压缩机制的理解。通过这个基础实践 [@problem_id:1636836]，你将掌握 LZW 算法是如何从零开始学习和压缩重复模式的。", "problem": "Lempel-Ziv-Welch (LZW) 算法是一种通用的无损数据压缩算法。其操作依赖于在压缩过程中构建遇到的字符串字典。压缩过程如下：\n\n1.  使用一组预定义的字符串及其对应的编码初始化字典。\n2.  从一个空的“当前字符串”`S`开始。\n3.  从输入流中读取下一个字符`C`。\n4.  考虑新字符串`S + C`（当前字符串附加新字符）。\n5.  如果`S + C`已在字典中，则更新当前字符串：`S = S + C`。\n6.  如果`S + C`不在字典中：\n    a) 将`S + C`添加到字典中，并使用下一个可用的整数编码。\n    b) 输出当前字符串`S`的编码。\n    c) 将当前字符串重置为仅字符`C`，即`S = C`。\n7.  从步骤3开始重复，直到到达输入流的末尾。\n8.  循环终止后，输出最终“当前字符串”`S`的编码。\n\n考虑一个LZW压缩器，其初始字典仅包含两个条目：`A`的编码为`0`，`B`的编码为`1`。新字典条目的编码从`2`开始并按顺序分配。\n\n确定此LZW压缩器为输入字符串`BBAABABB`生成的输出编码序列。请以整数序列的形式给出您的答案。", "solution": "初始化字典，$D(\\text{A})=0$ 和 $D(\\text{B})=1$。设下一个可用编码为 $n=2$。从空的当前字符串 $S$ 开始。\n\n读取第一个字符 $C=\\text{B}$。由于 $S$ 为空，连接后的字符串 $S+C=\\text{B}$ 在字典中，因此更新 $S=\\text{B}$。\n\n读取第二个字符 $C=\\text{B}$。现在 $S+C=\\text{BB}$ 不在字典中。将其加入：$D(\\text{BB})=2$ 并更新 $n \\rightarrow 3$。输出当前字符串 $S$ 的编码，即 $D(\\text{B})=1$。重置 $S=C=\\text{B}$。\n\n读取第三个字符 $C=\\text{A}$。现在 $S+C=\\text{BA}$ 不在字典中。将其加入：$D(\\text{BA})=3$ 并更新 $n \\rightarrow 4$。输出 $D(\\text{B})=1$。重置 $S=C=\\text{A}$。\n\n读取第四个字符 $C=\\text{A}$。现在 $S+C=\\text{AA}$ 不在字典中。将其加入：$D(\\text{AA})=4$ 并更新 $n \\rightarrow 5$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{A}$。\n\n读取第五个字符 $C=\\text{B}$。现在 $S+C=\\text{AB}$ 不在字典中。将其加入：$D(\\text{AB})=5$ 并更新 $n \\rightarrow 6$。输出 $D(\\text{A})=0$。重置 $S=C=\\text{B}$。\n\n读取第六个字符 $C=\\text{A}$。现在 $S+C=\\text{BA}$ 在字典中（编码为 $3$），因此更新 $S=\\text{BA}$。\n\n读取第七个字符 $C=\\text{B}$。现在 $S+C=\\text{BAB}$ 不在字典中。将其加入：$D(\\text{BAB})=6$ 并更新 $n \\rightarrow 7$。输出 $D(\\text{BA})=3$。重置 $S=C=\\text{B}$。\n\n读取第八个字符 $C=\\text{B}$。现在 $S+C=\\text{BB}$ 在字典中（编码为 $2$），因此更新 $S=\\text{BB}$。\n\n输入结束：输出最终当前字符串 $S$ 的编码，即 $D(\\text{BB})=2$。\n\n按顺序收集输出，得到序列 $1, 1, 0, 0, 3, 2$。", "answer": "$$\\boxed{\\begin{pmatrix}1  1  0  0  3  2\\end{pmatrix}}$$", "id": "1636836"}, {"introduction": "能够压缩数据固然重要，但能够准确无误地将其解压回原始形式也同样关键。这个练习将带你从编码转向解码，让你扮演解压器的角色。通过处理一串 LZW 码字序列 [@problem_id:1636869]，你将学习解压器如何与压缩器同步地重建字典，并最终还原出原始信息。", "problem": "一个简化的数据压缩系统使用 Lempel-Ziv-Welch (LZW) 算法来编码文本消息。该算法通过构建一个在压缩过程中遇到的字符串字典来工作。为了本题的目的，假设 LZW 实现具有以下具体细节：\n\n1.  初始字典预先填充了所有8位ASCII字符的条目。这意味着整数代码从 0 到 255 映射到它们对应的单字符字符串。\n2.  用于新生成的字典条目的第一个可用代码是 256。\n3.  LZW 编码器从输入中读取当前在字典中的最长字符串 `S`。它输出 `S` 的代码。然后，它取 `S` 加上输入中的下一个字符 `C`，即 `S+C`，并将这个新字符串用下一个可用的数字代码添加到字典中。\n\n接收到一个压缩的消息片段，它是一个整数代码序列：`[65, 66, 67, 256, 258]`。请根据此序列重建原始的文本消息片段。", "solution": "我们需要解码一个 LZW 压缩的代码序列：`[65, 66, 67, 256, 258]`。我们将使用标准的 LZW 解码算法，该算法与编码过程相对应。\n\n**初始状态：**\n*   字典包含从 0 到 255 的所有 ASCII 字符的条目。例如，代码 `65` 映射到字符串 'A'，`66` 映射到 'B'，`67` 映射到 'C'。\n*   将要添加到字典的下一个可用代码是 `256`。\n*   输出字符串初始为空。\n\n解码算法按如下方式进行：从输入中读取一个代码，在字典中查找其对应的字符串，并输出该字符串。然后，通过将前一个输出的字符串与当前输出字符串的第一个字符连接起来，创建一个新的字典条目。\n\n让我们来追踪序列 `[65, 66, 67, 256, 258]` 的解码过程。\n\n**步骤 1：解码代码 `65`**\n*   输入代码：`65`。\n*   根据初始字典，代码 `65` 对应字符串 'A'。\n*   输出字符串：'A'。\n*   第一个代码已处理完毕。我们设置 `previous_string = 'A'`。\n*   当前已解码消息：\"A\"。\n\n**步骤 2：解码代码 `66`**\n*   输入代码：`66`。\n*   根据初始字典，代码 `66` 对应字符串 'B'。我们称之为 `current_string`。\n*   输出字符串：'B'。\n*   必须创建一个新的字典条目。新条目是 `previous_string + first_character(current_string)`。\n*   `previous_string` 是 'A'。`current_string` 是 'B'。`first_character(current_string)` 是 'B'。\n*   要添加的新字符串：'A' + 'B' = \"AB\"。\n*   这个新字符串 \"AB\" 以下一个可用的代码 `256` 添加到字典中。所以，字典现在包含 `(256, \"AB\")`。\n*   更新 `previous_string = current_string = 'B'`。\n*   当前已解码消息：\"AB\"。\n\n**步骤 3：解码代码 `67`**\n*   输入代码：`67`。\n*   根据初始字典，代码 `67` 对应字符串 'C'。我们称之为 `current_string`。\n*   输出字符串：'C'。\n*   创建新字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 'B'。`current_string` 是 'C'。`first_character(current_string)` 是 'C'。\n*   要添加的新字符串：'B' + 'C' = \"BC\"。\n*   这个新字符串 \"BC\" 以下一个可用的代码 `257` 添加到字典中。所以，字典现在包含 `(257, \"BC\")`。\n*   更新 `previous_string = current_string = 'C'`。\n*   当前已解码消息：\"ABC\"。\n\n**步骤 4：解码代码 `256`**\n*   输入代码：`256`。\n*   我们在字典中查找代码 `256`。从步骤 2 可知，它对应字符串 \"AB\"。我们称之为 `current_string`。\n*   输出字符串：\"AB\"。\n*   创建新字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 'C'。`current_string` 是 \"AB\"。`first_character(current_string)` 是 'A'。\n*   要添加的新字符串：'C' + 'A' = \"CA\"。\n*   这个新字符串 \"CA\" 以下一个可用的代码 `258` 添加到字典中。所以，字典现在包含 `(258, \"CA\")`。\n*   更新 `previous_string = current_string = \"AB\"`。\n*   当前已解码消息：\"ABCAB\"。\n\n**步骤 5：解码代码 `258`**\n*   输入代码：`258`。\n*   我们在字典中查找代码 `258`。从步骤 4 可知，它对应字符串 \"CA\"。我们称之为 `current_string`。\n*   输出字符串：\"CA\"。\n*   创建新字典条目：`previous_string + first_character(current_string)`。\n*   `previous_string` 是 \"AB\"。`current_string` 是 \"CA\"。`first_character(current_string)` 是 'C'。\n*   要添加的新字符串：\"AB\" + 'C' = \"ABC\"。\n*   这个新字符串 \"ABC\" 以下一个可用的代码 `259` 添加到字典中。所以，字典现在包含 `(259, \"ABC\")`。\n*   更新 `previous_string = current_string = \"CA\"`。\n*   当前已解码消息：\"ABCABCA\"。\n\n输入序列现已完全处理。连接起来的输出即为原始消息。\n\n最终解码字符串：'A' + 'B' + 'C' + \"AB\" + \"CA\" = \"ABCABCA\"。", "answer": "$$\\boxed{ABCABCA}$$", "id": "1636869"}, {"introduction": "一个优秀的算法必须能够稳健地处理各种边界情况。这个练习聚焦于 LZW 解码中的一个经典特殊场景，在这种情况下 [@problem_id:1636872]，解压器会遇到一个在字典中“尚不存在”的码字。这要求我们运用一个特殊的推导规则来正确解码，从而检验你对算法同步机制的深层理解。", "problem": "Lempel-Ziv-Welch (LZW) 解压缩器旨在从一系列整数代码中重构原始文本字符串。该算法的字典初始化时包含 256 个条目（代码 0-255），对应于 8 位 ASCII 字符集中的所有单字符字符串。可用于新多字符字符串的第一个代码是 256。\n\n解压缩算法通过从压缩输入流中一次读取一个代码来执行。对于读取的每个代码，它按顺序执行以下两个操作：\n1.  从字典中检索与该代码对应的字符串，并将其写入输出流。\n2.  向字典中添加一个新条目。这个新条目的字符串值是来自*前一个*代码的字符串与来自*当前*代码的字符串的*第一个字符*的串联。流中的第一个代码没有前一个代码，因此在处理它之后不会更新字典。\n\n你的任务是手动解压缩以下代码序列：`[66, 79, 256, 258]`。\n代码 66 和 79 分别对应于 ASCII 字符 'B' 和 'O'。\n\n确定确切的原始未压缩字符串。", "solution": "用代码 $0$ 到 $255$ 的单字符字符串初始化 LZW 字典 $D$。下一个可用的代码是 $c=256$。令 $\\operatorname{first}(X)$ 表示字符串 $X$ 的第一个字符。解压缩过程读取每个代码，输出其对应的字符串，然后添加一个新条目 $D[c]=P \\Vert \\operatorname{first}(S)$，其中 $P$ 是前一个代码对应的字符串，$S$ 是当前代码对应的字符串。对于一个代码尚不在字典 $D$ 中的特殊情况，LZW 规则是 $S=P \\Vert \\operatorname{first}(P)$。\n\n按如下方式处理代码 $[66,79,256,258]$。\n\n1) 读取 $66$：\n- 当前字符串 $S=D[66]=\"B\"$。输出 \"B\"。\n- 不存在前一个代码，因此不添加到字典中。\n- 设置 $P=\"B\"$。$c$ 保持为 $256$。\n\n2) 读取 $79$：\n- $S=D[79]=\"O\"$。输出 \"O\"。\n- 添加 $D[256]=P \\Vert \\operatorname{first}(S) = \\text{\"B\"} \\Vert \\text{\"O\"} = \\text{\"BO\"}$。将 $c$ 递增到 $257$。\n- 设置 $P=\"O\"$。\n\n3) 读取 $256$：\n- $S=D[256]=\"BO\"$。输出 \"BO\"。\n- 添加 $D[257]=P \\Vert \\operatorname{first}(S) = \\text{\"O\"} \\Vert \\text{\"B\"} = \\text{\"OB\"}$。将 $c$ 递增到 $258$。\n- 设置 $P=\"BO\"$。\n\n4) 读取 $258$：\n- 代码 $258$ 尚不在 $D$ 中（因为 $c=258$），因此使用 LZW 特殊情况：$S=P \\Vert \\operatorname{first}(P) = \\text{\"BO\"} \\Vert \\text{\"B\"} = \\text{\"BOB\"}$。输出 \"BOB\"。\n- 添加 $D[258]=P \\Vert \\operatorname{first}(S) = \\text{\"BO\"} \\Vert \\text{\"B\"} = \\text{\"BOB\"}$。将 $c$ 递增到 $259$。\n- 设置 $P=\"BOB\"$。\n\n按顺序串联所有输出，得到原始字符串：\"B\" 后跟 \"O\" 后跟 \"BO\" 后跟 \"BOB\"，即 \"BOBOBOB\"。", "answer": "$$\\boxed{BOBOBOB}$$", "id": "1636872"}]}