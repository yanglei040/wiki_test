{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。让我们从一个基础练习开始，亲手构建一个Tunstall编码字典。这个练习 [@problem_id:1665390] 将帮助你熟悉Tunstall算法的核心步骤：从一个初始符号集出发，通过迭代地扩展概率最高的序列，直到达到预定的字典大小。", "problem": "一个数据压缩系统正在为二进制无记忆信源（BMS）设计。BMS 是一种从固定字母表中发出符号的信源，其中每次发出都与前一次独立。该信源的字母表为 $\\mathcal{X} = \\{0, 1\\}$，其符号的概率分布已知：发出 '0' 的概率为 $P(0) = 0.8$，发出 '1' 的概率为 $P(1) = 0.2$。\n\n该设计采用 Tunstall 编码，这是一种将信源数据流解析成一系列可变长度短语的方法。这些短语中的每一个都属于一个预定义的字典，然后被映射到一个固定长度的二进制码字。\n\n你的任务是确定构成此信源的 Tunstall 字典的信源短语集，已知字典的目标大小为 $M=4$。以下哪个选项正确表示了这个字典？\n\nA. $\\{0, 1, 00, 01\\}$\n\nB. $\\{00, 01, 10, 11\\}$\n\nC. $\\{000, 001, 01, 1\\}$\n\nD. $\\{1, 10, 11, 00\\}$\n\nE. $\\{0, 10, 110, 111\\}$", "solution": "对于字母表为 $\\mathcal{X}=\\{0,1\\}$ 且概率为 $P(0)=0.8$ 和 $P(1)=0.2$ 的二进制无记忆信源，Tunstall 编码通过重复扩展当前概率最大的叶节点来构建解析树，直到叶节点的数量等于目标字典大小 $M$。每次扩展都会将一个概率为 $P(w)$ 的叶短语 $w$ 替换为其两个子节点 $w0$ 和 $w1$，它们的概率分别为 $P(w0)=P(w)P(0)$ 和 $P(w1)=P(w)P(1)$。当树达到 $M$ 个叶节点时，字典就是这些叶节点的集合。\n\n从概率为 $1$ 的根节点（空短语）开始。将根节点扩展为其子节点：\n$$\\{0,1\\},\\quad P(0)=0.8,\\; P(1)=0.2.$$\n此时有 $2$ 个叶节点。概率最大的叶节点是 $0$，其概率为 $0.8$。扩展 $0$：\n$$0 \\to \\{00,01\\},\\quad P(00)=0.8\\cdot 0.8=0.64,\\; P(01)=0.8\\cdot 0.2=0.16.$$\n现在的叶节点为 $\\{00,01,1\\}$，其概率分别为 $0.64,0.16,0.2$。概率最大的叶节点是 $00$，其概率为 $0.64$。扩展 $00$：\n$$00 \\to \\{000,001\\},\\quad P(000)=0.64\\cdot 0.8=0.512,\\; P(001)=0.64\\cdot 0.2=0.128.$$\n现在的叶节点为 $\\{000,001,01,1\\}$，共有 $M=4$ 个叶节点，因此我们停止。因此，Tunstall 字典是 $\\{000,001,01,1\\}$，这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1665390"}, {"introduction": "构建完字典后，下一步是评估其性能。这个练习 [@problem_id:1665354] 将带你计算Tunstall编码器解析出的可变长度源序列的期望长度。这个指标是理解Tunstall编码压缩效率的关键，因为它直接关系到最终的压缩率。", "problem": "考虑一个二进制无记忆信源，其生成的符号来自符号集 $\\mathcal{S} = \\{0, 1\\}$。生成符号“0”的概率为 $p=0.75$，因此生成符号“1”的概率为 $1-p=0.25$。为了压缩该信源的输出，使用Tunstall算法构造一个变长到定长码。该算法从一个包含初始信源符号的字典开始。然后，它迭代地扩展字典中概率最大的序列，方法是将每个信源符号追加到该序列末尾，并将新生成的更长序列添加到字典中，同时移除被扩展的那个序列。重复此过程，直到字典中包含恰好 $M=5$ 个唯一的信源序列（码字）。\n\n在包含 $M=5$ 个码字的最终字典中，一个信源序列的期望长度是多少？请用一个数值表示你的答案。", "solution": "设信源概率为 $p=\\Pr\\{0\\}=0.75$ 和 $1-p=\\Pr\\{1\\}=0.25$。Tunstall算法从字典 $\\{0,1\\}$ 开始，在每一步中，通过追加每个信源符号来扩展概率最大的序列。\n\n开始：字典为 $\\{0,1\\}$，其概率分别为 $p$ 和 $1-p$。\n\n第1次迭代（扩展概率最大的序列 $0$）：\n- 用概率为 $p^{2}$ 和 $p(1-p)$ 的 $00$ 和 $01$ 替换 $0$。\n- 字典：$\\{1,01,00\\}$，其概率为 $\\{1-p,\\;p(1-p),\\;p^{2}\\}$。\n\n第2次迭代（扩展概率最大的序列 $00$）：\n- 用概率为 $p^{3}$ 和 $p^{2}(1-p)$ 的 $000$ 和 $001$ 替换 $00$。\n- 字典：$\\{1,01,000,001\\}$，其概率为 $\\{1-p,\\;p(1-p),\\;p^{3},\\;p^{2}(1-p)\\}$。\n\n第3次迭代（扩展概率最大的序列 $000$）：\n- 用概率为 $p^{4}$ 和 $p^{3}(1-p)$ 的 $0000$ 和 $0001$ 替换 $000$。\n- 包含 $M=5$ 个序列的最终字典为：$\\{1,01,001,0000,0001\\}$，其概率为\n$\\{1-p,\\;p(1-p),\\;p^{2}(1-p),\\;p^{4},\\;p^{3}(1-p)\\}$，长度为 $\\{1,2,3,4,4\\}$。\n\n信源序列的期望长度为\n$$\n\\mathbb{E}[L]\n=1\\cdot(1-p)+2\\cdot p(1-p)+3\\cdot p^{2}(1-p)+4\\cdot p^{4}+4\\cdot p^{3}(1-p).\n$$\n代入 $p=\\frac{3}{4}$：\n$$\n\\mathbb{E}[L]\n=1\\cdot\\frac{1}{4}+2\\cdot\\frac{3}{16}+3\\cdot\\frac{9}{64}+4\\cdot\\frac{81}{256}+4\\cdot\\frac{27}{256}\n=\\frac{64+96+108+324+108}{256}\n=\\frac{700}{256}\n=\\frac{175}{64}.\n$$\n因此，期望长度为 $\\frac{175}{64}$。", "answer": "$$\\boxed{\\frac{175}{64}}$$", "id": "1665354"}, {"introduction": "在实际工程应用中，理论算法常会遇到现实约束。这个高级练习 [@problem_id:1665395] 模拟了一个设计场景：当目标字典大小$M$无法被Tunstall算法精确达到时，我们该如何决策？通过比较两种不同的实现策略，你将学会如何超越算法的机械应用，做出能带来更优压缩性能的设计选择。", "problem": "一位工程师正在为离散无记忆信源设计一种可变长度到固定长度的压缩系统。该信源具有三个符号的字母表 $\\mathcal{X} = \\{S_0, S_1, S_2\\}$，其出现概率分别为 $P(S_0) = 0.90$，$P(S_1) = 0.05$ 和 $P(S_2) = 0.05$。\n\n该设计需要一个信源词典，其中的信源词随后被映射到固定长度的二进制码。工程师考虑了两种不同的方法来生成这个词典，这两种方法都基于Tunstall编码算法，目标词典大小为 $M=4$。\n\n第一种方法，方案A，是一种朴素的实现。它通过执行 $k$ 次分裂来生成一个Tunstall词典，其中 $k$ 的选择是为了产生满足 $N_A \\le M$ 的最大可能词典大小 $N_A$。所得到的 $N_A$ 个信源词被映射到一组长度为 $\\lceil \\log_2 M \\rceil$ 比特的 $N_A$ 个二进制码。\n\n第二种方法，方案B，则更为灵活。它认识到对 $M$ 的约束可能并非最优。它为*下一个*可达到的词典大小 $N_B > M$ 构建一个Tunstall词典，这个大小是通过比方案A多执行一次分裂得到的。所得到的 $N_B$ 个信源词被映射到长度为 $\\lceil \\log_2 N_B \\rceil$ 比特的二进制码。\n\n您的任务是确定哪种方案提供更好的压缩效果（即，每个信源符号的比特率更低）。计算更高效方案的压缩率。压缩率 $R$ 定义为 $R = \\frac{L_{out}}{E[L_{in}]}$，其中 $L_{out}$ 是固定长度输出二进制码的长度，$E[L_{in}]$ 是每个词典词的期望信源符号数。\n\n将较优方案的速率表示为最终答案，并四舍五入到四位有效数字。", "solution": "设信源字母表为 $\\mathcal{X}=\\{S_{0},S_{1},S_{2}\\}$，其概率为 $P(S_{0})=0.90$，$P(S_{1})=0.05$ 和 $P(S_{2})=0.05$。通过分裂生长的Tunstall词典每次分裂会使叶子节点的数量增加 $|\\mathcal{X}|-1=2$。因此，可达到的词典大小为 $N=3+2k$，其中整数 $k\\geq 0$。\n\n方案A：当 $M=4$ 时，可达到的最大 $N\\leq M$ 为 $N_{A}=3$（零次分裂，$k=0$）。词典为 $\\{S_{0},S_{1},S_{2}\\}$，其词组概率为 $\\{0.90,0.05,0.05\\}$，且所有词组的长度均为 $1$。因此，\n$$\nE[L_{\\text{in},A}]=\\sum_{i=0}^{2}P(S_{i})\\cdot 1=1,\n$$\n固定输出长度为\n$$\nL_{\\text{out},A}=\\lceil \\log_{2} M\\rceil=\\lceil \\log_{2} 4\\rceil=2.\n$$\n因此速率为\n$$\nR_{A}=\\frac{L_{\\text{out},A}}{E[L_{\\text{in},A}]}=\\frac{2}{1}=2.\n$$\n\n方案B：下一个可达到的词典大小为 $N_{B}=N_{A}+2=5$（一次分裂，$k=1$）。从 $\\{S_{0},S_{1},S_{2}\\}$ 开始，分裂概率最大的叶子节点 $S_{0}$，得到叶子节点\n$$\n\\{S_{1},\\,S_{2},\\,S_{0}S_{0},\\,S_{0}S_{1},\\,S_{0}S_{2}\\}\n$$\n其概率为\n$$\n\\{0.05,\\,0.05,\\,0.9\\cdot 0.9,\\,0.9\\cdot 0.05,\\,0.9\\cdot 0.05\\}=\\{0.05,\\,0.05,\\,0.81,\\,0.045,\\,0.045\\},\n$$\n长度为 $\\{1,1,2,2,2\\}$。期望输入词组长度为\n$$\nE[L_{\\text{in},B}]=1\\cdot(0.05+0.05)+2\\cdot(0.81+0.045+0.045)=0.10+2\\cdot 0.90=1.9.\n$$\n固定输出长度为\n$$\nL_{\\text{out},B}=\\lceil \\log_{2} N_{B}\\rceil=\\lceil \\log_{2} 5\\rceil=3,\n$$\n所以速率为\n$$\nR_{B}=\\frac{L_{\\text{out},B}}{E[L_{\\text{in},B}]}=\\frac{3}{1.9}=\\frac{30}{19}\\approx 1.578947\\ldots.\n$$\n\n比较：\n$$\nR_{A}=2,\\quad R_{B}=\\frac{30}{19}\\approx 1.578947\\ldots.\n$$\n因此，方案B提供了更好的压缩效果。四舍五入到四位有效数字得到 $1.579$。", "answer": "$$\\boxed{1.579}$$", "id": "1665395"}]}