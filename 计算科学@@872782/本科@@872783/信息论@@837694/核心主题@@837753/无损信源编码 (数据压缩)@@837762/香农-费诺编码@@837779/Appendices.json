{"hands_on_practices": [{"introduction": "掌握香农-范诺编码的第一步是学习其核心的构建过程。这个练习提供了一个具体的场景——深空探测器信号——并引导你完成从排序概率、递归划分集合到分配比特以构建编码的基本步骤。这是将概率分布转化为可用编码的基础技能。[@problem_id:1658125]", "problem": "一个深空探测器监视一种特定的恒星现象，并将观测结果传回地球。该探测器可以发送三种不同的信号类型之一，记为 `{A, B, C}`。由于该现象的性质，这些信号的发送频率不相等。长期观测确定了每种信号的概率如下：信号 `A` 的概率为 `0.55`，信号 `B` 的概率为 `0.30`，信号 `C` 的概率为 `0.15`。\n\n为了节省传输功率，探测器使用一种特定的算法为这些信号生成可变长度的二进制编码。该算法遵循以下步骤：\n1.  按概率降序排列信号。\n2.  将此排序列表划分为两个连续的子组。选择划分点，使得第一个子组中的概率之和与第二个子组中的概率之和尽可能接近。\n3.  为第一个子组中的所有信号分配比特 `0` 作为前缀，为第二个子组中的所有信号分配比特 `1` 作为前缀。\n4.  对每个包含多于一个信号的子组重复步骤2和3，将新的比特附加到编码上，直到每个信号都自成一个子组。\n\n使用这种特定的编码算法，确定为消息序列 `ABA` 传输的最终二进制字符串。", "solution": "我们将所述的可变长度编码算法（香农-范诺编码风格）应用于概率为 $p_{A} = 0.55$、$p_{B} = 0.30$ 和 $p_{C} = 0.15$ 的信号。首先，按降序排序：$(A, 0.55)$, $(B, 0.30)$, $(C, 0.15)$。接下来，选择划分点，使两个连续子组的概率和尽可能接近。如果我们在 $A$ 之后划分，那么\n$$\nS_{1} = 0.55,\\quad S_{2} = 0.30 + 0.15 = 0.45,\\quad |S_{1} - S_{2}| = 0.10.\n$$\n如果我们在 $B$ 之后划分，那么\n$$\nS_{1} = 0.55 + 0.30 = 0.85,\\quad S_{2} = 0.15,\\quad |S_{1} - S_{2}| = 0.70.\n$$\n在 $A$ 之后划分可以使差值最小化，因此为第一个子组 $\\{A\\}$ 分配前缀 $0$，为第二个子组 $\\{B, C\\}$ 分配前缀 $1$。现在对 $\\{B, C\\}$ 进行递归，即 $(B, 0.30)$、$(C, 0.15)$。唯一的连续划分是在 $B$ 和 $C$ 之间，得到\n$$\nS_{1} = 0.30,\\quad S_{2} = 0.15,\\quad |S_{1} - S_{2}| = 0.15.\n$$\n在此子组内为 $B$ 分配 $0$，为 $C$ 分配 $1$，并将其附加到它们已有的前缀 $1$ 后面。因此，最终的码字是\n$$\nA \\to 0,\\quad B \\to 10,\\quad C \\to 11.\n$$\n要编码消息序列 $A B A$，连接相应的码字：\n$$\nA \\to 0,\\quad B \\to 10,\\quad A \\to 0 \\;\\;\\Rightarrow\\;\\; 0\\,10\\,0 = 0100.\n$$\n因此，为 $A B A$ 传输的二进制字符串是 $0100$。", "answer": "$$\\boxed{0100}$$", "id": "1658125"}, {"introduction": "在学会了如何构建编码之后，下一步是深化理解，探索编码结构与其背后概率之间的关系。这个练习挑战你通过观察最终的码本，反向推导出原始符号的概率排序。这会加深你对排序和划分步骤如何决定最终码字结构（例如，高概率符号对应更短码字）的理解。[@problem_id:1658114]", "problem": "一个信息源被建模为一个具有三符号字母表 $S = \\{A, B, C\\}$ 的离散无记忆信源。这些符号的概率分别用 $p_A$、$p_B$ 和 $p_C$ 表示。已知这三个概率都不为零且互不相同。\n\n使用香农-范诺算法为该信源构建了一个可变长度二进制码。得到的码字分配如下：\n- 符号 A 编码为 '0'。\n- 符号 B 编码为 '10'。\n- 符号 C 编码为 '11'。\n\n根据这些信息，以下哪个陈述正确描述了符号概率之间的关系？\n\nA. $p_A > p_B > p_C$\n\nB. $p_C > p_B > p_A$\n\nC. $p_B > p_A > p_C$\n\nD. $p_A > p_C > p_B$\n\nE. $p_C > p_A > p_B$\n\nF. 对于任何概率分布，给定的编码都不可能通过香农-范诺算法生成。", "solution": "问题要求我们通过逆向分析香农-范诺算法的步骤来推断出概率 $p_A$、$p_B$ 和 $p_C$ 的排序，该算法得出了给定的码本。\n\n香农-范诺算法按以下步骤进行：\n1.  将信源符号按其概率降序排列。\n2.  将排序后的列表划分为两个连续的子列表，使得每个子列表中的概率总和尽可能接近相等。\n3.  第一个子列表中的所有符号，其码字的第一位被分配为 '0'，而第二个子列表中的所有符号则被分配为 '1'。\n4.  对每个子列表递归地重复此过程，直到每个子列表只包含一个符号为止。\n\n让我们逆向分析给定的码本。\n\n**步骤1：分析第一次划分。**\n码字为 $C(A) = '0'$，$C(B) = '10'$ 和 $C(C) = '11'$。\n注意，符号 A 的码字以 '0' 开头，而符号 B 和 C 的码字都以 '1' 开头。这意味着在算法的第一步中，符号集 $\\{A, B, C\\}$ 被划分为两组：$\\{A\\}$ 和 $\\{B, C\\}$。第一组 $\\{A\\}$ 被分配了比特 '0'，第二组 $\\{B, C\\}$ 被分配了比特 '1'。\n\n**步骤2：将第一次划分与符号概率关联起来。**\n香农-范诺算法是对按概率排序的符号列表进行操作的。设排序后的符号为 $s_1, s_2, s_3$，其概率满足 $p(s_1)  p(s_2)  p(s_3)$。（我们使用严格不等号，因为问题说明了概率是互不相同的）。\n\n该算法将此排序列表划分为两个*连续*的子列表。可能的初始划分有：\n-   划分 1：$\\{s_1\\}$ 和 $\\{s_2, s_3\\}$\n-   划分 2：$\\{s_1, s_2\\}$ 和 $\\{s_3\\}$\n\n从步骤1可知，划分是 $\\{A\\}$ 和 $\\{B, C\\}$。要使之成为连续排序列表的有效划分，符号 A 必须是排序列表的第一个元素 ($s_1$) 或最后一个元素 ($s_3$)。\n\n让我们考虑 A 是概率最小的符号的情况，即 $A = s_3$。排序列表将是 $(s_1, s_2, A)$。为了分离出 A，划分必须是 $\\{s_1, s_2\\}$ 和 $\\{A\\}$。在这种情况下，第一组 $\\{s_1, s_2\\}$ 将被分配一个比特（例如 '0'），第二组 $\\{A\\}$ 将被分配另一个比特（例如 '1'）。A 的码字将是单个比特 '1'。给定的 A 的码字是 '0'。虽然为第一/第二组选择 '0' 还是 '1' 是任意的，但关键是 A 被分离开了。如果 $\\{A\\}$ 得到 '0'，那么 $C(A)='0'$，而 $C(s_1), C(s_2)$ 将以 '1' 开头。这与结构相符。然而，算法会选择能最好地平衡概率的划分。在这种情况下，两组的概率和将是 $p(s_1)+p(s_2)$ 和 $p(s_3)=p_A$。由于 $p(s_1)  p(s_2)  p_A$，很可能 $p(s_1)  p(s_2)+p_A$，这将使得替代划分 $\\{s_1\\}$ 与 $\\{s_2, A\\}$ 更加平衡。关键是，如果 $A=s_3$，它的码字将从只包含它自己的集合中生成，因此其码字将是单个比特。如果码字 '0' 被分配给这一组，所有其他符号的码字必须以 '1' 开头。这与给定的 B 和 C 的码字以 '1' 开头不一致。让我们重新审视一下。如果划分为 $\\{s_1, s_2\\}$ 与 $\\{A\\}$，并且 $\\{A\\}$ 被分配为 '0'，那么 $C(A)='0'$，$C(s_1)$ 以 '1' 开头，$C(s_2)$ 以 '1' 开头。这是符合的。\n让我们重新考虑 $A = s_1$ 的情况。排序列表是 $(A, s_2, s_3)$。为了分离 A，划分必须是 $\\{A\\}$ 和 $\\{s_2, s_3\\}$。这是两种可能划分中的一种。如果进行此划分，A 得到一个单位比特的码字（'0' 或 '1'），而其他符号的码字以另一个比特开头。这与给定码字的结构完全匹配，其中 $C(A)='0'$，而 $C(B)$ 和 $C(C)$ 以 '1' 开头。\n\n所以，A 必须是 $s_1$ 或 $s_3$。然而，如果 A 是 $s_3$（概率最小），只有当 $|(p(s_1)+p(s_2)) - p_A|$ 小于 $|p(s_1) - (p(s_2)+p_A)|$ 时，才会选择划分 $\\{s_1, s_2\\}$ 与 $\\{A\\}$。鉴于 $p(s_1)  p(s_2)  p_A$，第一个概率和 $p(s_1)+p(s_2)$ 远大于 $p_A$，使得划分不平衡。算法的标准应用会将概率最高和最低的符号放在码树的“末端”，使其获得更长的码字（除非其概率非常高/低）。像 '0' 这样长度为 1 的码字通常是为概率最高的符号保留的。这表明 $A=s_1$。因此，$p_A$ 必须是最大的概率。\n\n**步骤3：分析第二次划分。**\n接下来处理子列表 $\\{B, C\\}$，其前缀 '1' 已被分配。算法被应用于这个子列表。\n1.  符号 B 和 C 按概率排序。\n2.  对排序后的列表进行划分。由于只有两个符号，划分就是简单的 $\\{s'_1\\}$ 和 $\\{s'_2\\}$，其中 $s'_1$ 是两者中概率较大的，而 $s'_2$ 是概率较小的。\n3.  为第一个符号 ($s'_1$) 追加一个 '0'，为第二个符号 ($s'_2$) 追加一个 '1'。\n\n得到的码字是 $C(B) = '10'$ 和 $C(C) = '11'$。在公共前缀 '1' 之后追加的比特，对于符号 B 是 '0'，对于符号 C 是 '1'。\n根据算法，'0' 被分配给子组中概率较高的符号。因此，B 的概率必须大于 C。\n这给了我们关系：$p_B > p_C$。\n\n**步骤4：综合结果。**\n从步骤2，我们推断出 $p_A$ 是最大的概率：\n$p_A > p_B$ 且 $p_A > p_C$。\n\n从步骤3，我们推断出另外两个概率的相对顺序：\n$p_B > p_C$。\n\n结合这两个结果，我们得到完整的概率排序：\n$p_A > p_B > p_C$。\n\n这对应于选项 A。让我们确认这个逻辑成立。如果 $p_A > p_B > p_C$，则排序列表为 (A, B, C)。如果 $|p_A - (p_B+p_C)|  |(p_A+p_B) - p_C|$，则第一次划分在 {A} 和 {B, C} 之间。正如许多关于香农-范诺算法的分析所示，如果 $p_A$ 足够大（例如，$p_A \\ge p_B+p_C$），这个不等式成立。因此，第一次划分是 {A} | {B, C}。将 '0' 分配给第一组，'1' 分配给第二组，得到 $C(A)='0'$ 以及 B 和 C 的前缀 '1'。子组 {B, C} 已经排序（$p_B > p_C$），所以划分为 {B} | {C}。将 '0' 分配给第一个，'1' 分配给第二个，得到最终码字 $C(B)='10'$ 和 $C(C)='11'$。逻辑是一致的。", "answer": "$$\\boxed{A}$$", "id": "1658114"}, {"introduction": "对算法的真正掌握不仅在于遵循其规则，更在于理解每一步规则背后的原因。这个思想实验探讨了如果省略了关键的第一步——按概率排序——会发生什么。通过计算并比较正确生成的编码与有缺陷的编码的平均码长，你可以定量地理解为什么排序是实现压缩效率的必要步骤，而不是一个可有可无的惯例。[@problem_id:1658132]", "problem": "一个离散无记忆信源从字母表 $S = \\{S_1, S_2, S_3, S_4\\}$ 中发出符号，其对应的出现概率为 $P = \\{0.1, 0.5, 0.2, 0.2\\}$。\n\n用于生成无前缀二进制码的标准香农-范诺编码算法由以下递归过程定义：\n1.  将信源符号按其概率降序排列。\n2.  将排序后的符号列表划分为两个子列表，使每个子列表中的概率总和尽可能接近相等。\n3.  为第一个子列表中的所有符号分配比特 '0' 作为前缀，为第二个子列表中的所有符号分配比特 '1' 作为前缀。\n4.  对每个包含多个符号的子列表重复此过程，直到每个符号都有一个唯一的码字。\n\n现在，考虑一个有缺陷的过程，其中一位工程师忘记了第一步。他们直接对给定未排序顺序的符号进行香农-范诺划分：$S_1$（概率为 0.1），然后是 $S_2$（0.5），接着是 $S_3$（0.2），最后是 $S_4$（0.2）。在这个有缺陷的过程中，符号的相对顺序永远不变。\n\n计算通过标准（正确）的香农-范诺算法获得的平均码长与通过这个特定的有缺陷过程获得的平均码长之间的绝对差值。以 比特/符号 为单位表示您的最终答案。", "solution": "给定一个离散无记忆信源，其符号为 $S=\\{S_{1},S_{2},S_{3},S_{4}\\}$，概率为 $P=\\{0.1,0.5,0.2,0.2\\}$。对于一个码长为 $\\{l_{i}\\}$ 的码，其平均码长定义为\n$$\nL=\\sum_{i=1}^{4} p_{i} l_{i}.\n$$\n\n首先，应用标准（正确）的香农-范诺算法。\n\n第1步（排序）：按概率降序排列符号：$S_{2}$（0.5），$S_{3}$（0.2），$S_{4}$（0.2），$S_{1}$（0.1）。\n\n第2步（第一次划分）：划分为两个概率和尽可能相等的子列表。取 $\\{S_{2}\\}$ 的概率和为 $0.5$，余下的 $\\{S_{3},S_{4},S_{1}\\}$ 的概率和也为 $0.5$。为 $\\{S_{2}\\}$ 分配前缀 $0$，为 $\\{S_{3},S_{4},S_{1}\\}$ 分配前缀 $1$。\n\n第3步（对 $\\{S_{3},S_{4},S_{1}\\}$ 进行第二次划分）：该有序列表的概率为 $0.2,0.2,0.1$，总和为 $0.5$。可能的划分有：\n- $\\{S_{3}\\}$ 与 $\\{S_{4},S_{1}\\}$ 概率和为 $0.2$ 与 $0.3$（差值为 $0.1$），\n- $\\{S_{3},S_{4}\\}$ 与 $\\{S_{1}\\}$ 概率和为 $0.4$ 与 $0.1$（差值为 $0.3$）。\n选择 $\\{S_{3}\\}$ 与 $\\{S_{4},S_{1}\\}$ 的划分。为 $\\{S_{3}\\}$ 分配一个额外的 $0$，为 $\\{S_{4},S_{1}\\}$ 分配一个额外的 $1$，得到 $S_{3}$ 的前缀为 $10$，$S_{4},S_{1}$ 的前缀为 $11$。\n\n第4步（对 $\\{S_{4},S_{1}\\}$ 进行第三次划分）：划分 $\\{S_{4}\\}$（概率和 $0.2$）与 $\\{S_{1}\\}$（概率和 $0.1$）。为 $S_{4}$ 分配 $0$，为 $S_{1}$ 分配 $1$，得到 $S_{4}$ 的码字为 $110$，$S_{1}$ 的码字为 $111$。\n\n因此，标准的香农-范诺码和码长为：\n- $S_{2}: 0$，码长 $l_{2}=1$，\n- $S_{3}: 10$，码长 $l_{3}=2$，\n- $S_{4}: 110$，码长 $l_{4}=3$，\n- $S_{1}: 111$，码长 $l_{1}=3$。\n\n计算平均码长：\n$$\nL_{\\text{SF}}=0.5\\cdot 1+0.2\\cdot 2+0.2\\cdot 3+0.1\\cdot 3=0.5+0.4+0.6+0.3=1.8.\n$$\n\n接下来，应用有缺陷的过程（不排序；保持初始顺序 $S_{1},S_{2},S_{3},S_{4}$）。\n\n第1步（对 $[S_{1},S_{2},S_{3},S_{4}]$ 进行第一次划分）：累积概率和为 $0.1$, $0.6$, $0.8$。候选的划分有：\n- $\\{S_{1}\\}$ 与 $\\{S_{2},S_{3},S_{4}\\}$ 概率和为 $0.1$ 与 $0.9$（差值为 $0.8$），\n- $\\{S_{1},S_{2}\\}$ 与 $\\{S_{3},S_{4}\\}$ 概率和为 $0.6$ 与 $0.4$（差值为 $0.2$），\n- $\\{S_{1},S_{2},S_{3}\\}$ 与 $\\{S_{4}\\}$ 概率和为 $0.8$ 与 $0.2$（差值为 $0.6$）。\n选择 $\\{S_{1},S_{2}\\}$ 与 $\\{S_{3},S_{4}\\}$ 的划分。为 $\\{S_{1},S_{2}\\}$ 分配 $0$，为 $\\{S_{3},S_{4}\\}$ 分配 $1$。\n\n第2步（对概率为 $0.1,0.5$ 的 $\\{S_{1},S_{2}\\}$ 进行第二次划分）：划分 $\\{S_{1}\\}$ 与 $\\{S_{2}\\}$，为 $S_{1}$ 分配 $0$，为 $S_{2}$ 分配 $1$。码字变为 $S_{1}$ 的 $00$ 和 $S_{2}$ 的 $01$。\n\n第3步（对概率为 $0.2,0.2$ 的 $\\{S_{3},S_{4}\\}$ 进行第二次划分）：划分 $\\{S_{3}\\}$ 与 $\\{S_{4}\\}$，为 $S_{3}$ 分配 $0$，为 $S_{4}$ 分配 $1$。码字变为 $S_{3}$ 的 $10$ 和 $S_{4}$ 的 $11$。\n\n因此，有缺陷的码的码长为 $l_{1}=2, l_{2}=2, l_{3}=2, l_{4}=2$。平均码长为\n$$\nL_{\\text{flawed}}=\\sum_{i=1}^{4} p_{i}\\cdot 2=2.\n$$\n\n所要求的平均码长之间的绝对差值为\n$$\n|L_{\\text{SF}}-L_{\\text{flawed}}|=|1.8-2|=0.2.\n$$\n该值的单位是比特/符号。", "answer": "$$\\boxed{0.2}$$", "id": "1658132"}]}