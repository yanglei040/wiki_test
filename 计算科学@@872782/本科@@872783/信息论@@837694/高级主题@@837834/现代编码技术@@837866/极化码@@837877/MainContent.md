## 引言
极化码（Polar Codes）是信息论领域的一项革命性突破，由 Erdal Arıkan 于2009年首次提出。作为第一种被严格证明能够达到任意二进制输入对称无记忆信道香农容量，且具备低复杂度编译码算法的编码方案，它的出现解决了长期以来寻找一种既理论最优又切实可行的[信道编码](@entry_id:268406)方法的挑战。几十年来，[通信工程](@entry_id:272129)师和理论家们一直在追求能够逼近香农极限的编码技术，但大多方案要么结构复杂，要么缺乏严格的理论保证。极化码以其优雅的递归结构和深刻的信道极化理论，填补了这一空白。

本文旨在为读者提供一个关于极化码的全面视角。我们将在“原理与机制”一节中，深入剖析其核心的极化变换和信道极化现象，并介绍SC和SCL等关键译码算法。接着，在“应用与[交叉](@entry_id:147634)学科联系”一节中，我们将探索极化码如何从理论走向实践，成为5G等现代[通信系统](@entry_id:265921)的关键技术，并触及数据压缩、信息安全等多个交叉领域。最后，通过“动手实践”部分的练习，读者将有机会通过具体的计算和模拟，亲手体验极化码的编码与译码过程，巩固所学知识。这几部分内容层层递进，将带领你从基础理论的深刻理解，到实际应用的广阔视野，再到动手操作的具体实践，全方位掌握极化码的精髓。

## 原理与机制

本章深入探讨极化码的核心工作原理与实现机制。我们将从其独特的编码变换——极化变换——开始，揭示这一变换如何引发信道极化现象，这是极化码性能的理论基石。随后，我们将阐述如何利用这一现象来构造实用的编码方案。最后，我们将详细分析其经典的译码算法——连续消除（SC）译码及其性能更优的改进版本——连续消除列表（SCL）译码。

### 极化变换：编码的基础

极化码的编码过程本质上是一个[线性变换](@entry_id:149133)，它将一组待发送的原始比特 $u = (u_1, u_2, \dots, u_N)$ 映射为码字 $x = (x_1, x_2, \dots, x_N)$。此变换的设计旨在将多个独立的物理信道副本合成为一组具有两极分化特性的虚拟比特信道。码块长度 $N$ 通常被限定为2的幂，即 $N=2^n$。

#### 递归构造

极化变换 $x = T_N(u)$ 最直观的理解方式是其[递归定义](@entry_id:266613)。

- **基本模块 ($N=2$)**: [变换的核](@entry_id:149509)心是一个 $2 \times 2$ 的基础模块。输入为 $(u_1, u_2)$，输出为 $(x_1, x_2)$，其变换规则为：
  $$
  x_1 = u_1 \oplus u_2 \\
  x_2 = u_2
  $$
  其中 $\oplus$ 表示模2加法（异或运算）。这个简单的操作是整个极化过程的起点。

- **递归扩展 ($N=2^n, n>1$)**: 对于更长的码块，变换过程可分解为三个步骤：合并、[置换](@entry_id:136432)和递归。
  1.  **合并 (Combine)**: 将长度为 $N$ 的输入向量 $u$ 两两配对，应用基础变换的[异或](@entry_id:172120)部分。生成一个中间向量 $v$：
      $$
      v_{2j-1} = u_{2j-1} \oplus u_{2j} \\
      v_{2j} = u_{2j} \quad (\text{for } j = 1, \dots, N/2)
      $$
  2.  **[置换](@entry_id:136432) (Shuffle)**: 将向量 $v$ 的奇数位元素和偶数位元素分开，重新[排列](@entry_id:136432)成一个新的向量 $w$。$w$ 的前半部分由 $v$ 的所有奇数位元素构成，$w$ 的后半部分由 $v$ 的所有偶数位元素构成。
  3.  **递归 (Recurse)**: 将向量 $w$ 分成两个长度为 $N/2$ 的子块，并对每个子块分别递归地应用极化变换 $T_{N/2}$。最终得到的两个输出子块拼接起来，便构成了最终的码字 $x$。

为了具体理解这一过程，我们可以追踪一个长度为 $N=8$ 的输入向量 $u = (1, 0, 1, 1, 0, 1, 0, 0)$ 的变换过程。通过逐层应用上述的合并、[置换](@entry_id:136432)和递归步骤，最终可以计算出其对应的码字 $x = (0, 1, 0, 0, 0, 1, 1, 0)$ [@problem_id:1646913]。这种分而治之的递归结构不仅是理论分析的关键，也为高效的硬件实现提供了可能。

#### 矩阵表示

尽管[递归定义](@entry_id:266613)很直观，但使用[矩阵代数](@entry_id:153824)能提供一个更紧凑和全局的视角。整个极化变换是一个线性过程，因此可以表示为 $x = u G_N$，其中 $G_N$ 是一个 $N \times N$ 的[生成矩阵](@entry_id:275809)。

该[生成矩阵](@entry_id:275809)可以通过**克罗内克积 (Kronecker product)** 来系统地构造。首先定义基础矩阵 $F_2$：
$$
F_2 = \begin{pmatrix} 1  0 \\ 1  1 \end{pmatrix}
$$
一个长度为 $N=2^n$ 的极化码的[生成矩阵](@entry_id:275809)与 $F_2$ 的 $n$ 次克罗内克幂 $F^{\otimes n}$ 密切相关。克罗内克积的[递归定义](@entry_id:266613)为 $F^{\otimes n} = F_2 \otimes F^{\otimes (n-1)}$。例如，对于 $N=4$，我们有：
$$
F^{\otimes 2} = F_2 \otimes F_2 = \begin{pmatrix} 1  0 \\ 1  1 \end{pmatrix} \otimes \begin{pmatrix} 1  0 \\ 1  1 \end{pmatrix} = \begin{pmatrix} 1 \cdot F_2  0 \cdot F_2 \\ 1 \cdot F_2  1 \cdot F_2 \end{pmatrix} = \begin{pmatrix} 1  0  0  0 \\ 1  1  0  0 \\ 1  0  1  0 \\ 1  1  1  1 \end{pmatrix}
$$
对于 $N=8=2^3$ 的情况，其[生成矩阵](@entry_id:275809) $F^{\otimes 3}$ 具有清晰的自相似分块结构，可以表示为 [@problem_id:1646932]：
$$
F^{\otimes 3} = F_2 \otimes F^{\otimes 2} = \begin{pmatrix} F^{\otimes 2}  0_4 \\ F^{\otimes 2}  F^{\otimes 2} \end{pmatrix}
$$
其中 $0_4$ 是一个 $4 \times 4$ 的零矩阵。

然而，需要特别注意的是，标准的极化码[生成矩阵](@entry_id:275809) $G_N$ 并非直接等于 $F^{\otimes n}$。它还包含一个**比特反[转置](@entry_id:142115)换 (bit-reversal permutation)** 矩阵 $B_N$，即 $G_N = B_N F^{\otimes n}$。这个[置换矩阵](@entry_id:136841)的作用是重排 $F^{\otimes n}$ 的行，其目的是将合成的比特信道按照可靠性进行自然的排序。如果省略了 $B_N$ 而直接使用 $F^{\otimes n}$ 作为[生成矩阵](@entry_id:275809)，虽然得到的码仍然是线性的，但其合成信道的可靠性顺序会与标准构造不同。因此，如果此时仍使用为标准构造 $G_N$ 计算出的“好”信道索引（即信息集 $\mathcal{A}$）来承载信息比特，这些比特实际上会被映射到一组非最优的信道上，从而导致码的错误纠正性能显著下降 [@problem_id:1646941]。

### 信道极化现象

极化码之所以有效，其根本原因在于**信道极化 (channel polarization)** 现象。如前所述，极化变换的真正威力在于它能将 $N$ 个独立的、质量相同的物理信道 $W$ 变换成一组新的、具有两极分化特性的合成比特信道 $\{W_N^{(i)}\}_{i=1}^N$。随着码块长度 $N$ 的增加，这组信道中的一部分会趋向于完美的无噪声信道，而其余部分则趋向于完全无用的纯噪声信道。

#### 可靠性度量：巴氏参数

为了量化信道的“好”与“坏”，我们需要一个可靠性的度量标准。在信息论中，**巴氏参数 (Bhattacharyya parameter)** $Z(W)$ 是一个广泛使用的指标。对于一个二[进制](@entry_id:634389)输入的信道 $W$，其输入字母表为 $\mathcal{X} = \{0, 1\}$，输出字母表为 $\mathcal{Y}$，巴氏参数定义为：
$$
Z(W) = \sum_{y \in \mathcal{Y}} \sqrt{P(y|X=0)P(y|X=1)}
$$
$Z(W)$ 的取值范围是 $[0, 1]$。$Z(W)=0$ 意味着对于任何输出 $y$，$P(y|0)$ 和 $P(y|1)$ 中至少有一个为零，这表示信道是无噪声的，可以完美区分输入。相反，$Z(W)=1$ 表示信道完全无法区分输入0和1，是纯噪声信道。$Z(W)$ 值越小，信道越可靠。

对于常见的[二进制对称信道](@entry_id:266630)（BSC），其[交叉概率](@entry_id:276540)为 $p$，巴氏参数为 $Z(W) = 2\sqrt{p(1-p)}$。对于[二进制删除信道](@entry_id:267278)（BEC），其删除概率为 $\epsilon$，巴氏参数恰好等于删除概率 $Z(W) = \epsilon$ [@problem_id:1646952]。

#### 单步极化

信道极化现象源于极化变换的基础模块。考虑将两个独立的信道 $W$ 组合。输入比特 $u_1, u_2$ 经过变换 $x_1=u_1 \oplus u_2, x_2=u_2$ 后，通过两个独立的信道 $W$ 发送，得到输出 $y_1, y_2$。接收端试图依次译码 $u_1$ 和 $u_2$。

1.  **译码 $u_1$**: 译码器利用 $(y_1, y_2)$ 来估计 $u_1$。这个过程定义了第一个合成信道 $W^-$。
2.  **译码 $u_2$**: 译码器利用 $(y_1, y_2)$ 以及对 $u_1$ 的估计值 $\hat{u}_1$ 来估计 $u_2$。这个过程定义了第二个合成信道 $W^+$。

可以证明，这两个新合成信道的巴氏参数 $Z(W^-)$ 和 $Z(W^+)$ 与原始信道参数 $Z(W)$ 之间存在确定性关系。对于任何二进制输入的离散无记忆[对称信道](@entry_id:274947)，这个关系是 [@problem_id:1646956]：
$$
Z(W^-) = 2Z(W) - Z(W)^2 \\
Z(W^+) = Z(W)^2
$$
当 $0  Z(W)  1$ 时，我们总有 $Z(W^+)  Z(W)  Z(W^-)$。这意味着，通过一次简单的组合，我们从两个相同的信道中合成了一个更好的信道（$W^+$）和一个更差的信道（$W^-$）。这正是“极化”一词的由来。

以[二进制删除信道](@entry_id:267278)（BEC）为例，这个过程尤为清晰。若原始BEC的删除概率为 $\epsilon$，那么合成信道 $W^-$ 和 $W^+$ 同样是BEC，其等效删除概率分别为 [@problem_id:1646952]：
$$
\epsilon^- = 2\epsilon - \epsilon^2 \\
\epsilon^+ = \epsilon^2
$$
由于 $Z(BEC) = \epsilon$，这与巴氏参数的通用变换规律完全吻合。

#### 递归极化与极限行为

当极化变换被递归地应用 $n$ 次（对应码块长度 $N=2^n$），上述的单步极化过程也随之被递归地应用。在每一层递归中，一部分信道变得更好，另一部分变得更差。随着 $n$（即 $N$）的增大，这种效应被不断放大。

最终，当 $N \to \infty$ 时，除了极少数之外，所有 $N$ 个合成信道的巴氏参数 $Z(W_N^{(i)})$ 都会趋近于 $0$ 或 $1$。也就是说，信道质量的[分布](@entry_id:182848)从一个集中在初始值 $Z(W)$ 附近的单峰[分布](@entry_id:182848)，演变成一个集中在 $0$ 和 $1$ 两端的[双峰分布](@entry_id:166376)。中间质量的信道几乎消失。这正是选项A在问题[@problem_id:1646956]中所描述的现象。更深刻的是，巴氏参数趋近于0的“好”信道的比例，会收敛到原始物理信道 $W$ 的对称容量 $I(W)$。这为极化码能够达到[信道容量](@entry_id:143699)提供了理论保证。

### 极化码的构造与[码率](@entry_id:176461)

信道极化现象为设计高效的编码方案指明了方向：我们应该只在那些已经变得几乎无噪声的“好”信道上传输信息，而在那些几乎纯噪声的“坏”信道上发送固定的、收发双方都知道的比特。

1.  **信息集与冻结集**: 对于一个给定的码块长度 $N$ 和物理信道 $W$，我们可以计算出所有 $N$ 个合成比特信道 $W_N^{(i)}$ 的巴氏参数。然后，我们根据可靠性对这些信道进行排序。最可靠的 $K$ 个信道（即巴氏参数最小的 $K$ 个）的索引集合被称为**信息集**，记为 $\mathcal{A}$。其余 $N-K$ 个最不可靠的信道的索引集合被称为**冻结集**，记为 $\mathcal{F}$ [@problem_id:1661161]。

2.  **编码过程**: 在编码时，输入向量 $u$ 中对应于冻结集 $\mathcal{F}$ 的比特位（称为**冻结比特**）被设置为预先约定的固定值（通常全为0）。而对应于信息集 $\mathcal{A}$ 的比特位则用于承载 $K$ 个**信息比特**。然后，将这个完整的向量 $u$ 输入极化变换器 $x = uG_N$ 生成最终的码字。

3.  **码率**: 这个码的**码率 (code rate)** 定义为 $R = K/N$，即每个信道符号平均承载的信息比特数。理论上，为了可靠传输，我们应该选择 $K$ 略小于 $N \times I(W)$。

例如，对于一个长度 $N=8$ 的极化码，用于删除概率 $\epsilon=0.4$ 的BEC信道，我们可以通过[递归公式](@entry_id:160630)计算出8个合成信道的巴氏参数。假设我们设定一个可靠性门限，比如选择所有巴氏参数小于$0.1$的信道作为[信息信道](@entry_id:266393)。通过计算，我们发现有3个信道的巴氏参数满足此条件。因此，信息比特数 $K=3$，码率为 $R = 3/8 = 0.375$ [@problem_id:1610807]。

### 译码机制

极化码的译码过程利用了其递归的结构。最基础的译码算法是**连续消除（Successive Cancellation, SC）译码**。

#### 连续消除（SC）译码

SC译码器按顺序 $i=1, 2, \dots, N$ 估计原始比特 $\hat{u}_i$。对于每一个 $u_i$，译码器利用信道的接收值（通常以[对数似然比](@entry_id:274622) LLR 的形式表示）以及所有先前已译出的比特估计值 $\hat{u}_1, \dots, \hat{u}_{i-1}$ 来做出判决。

-   如果索引 $i$ 属于冻结集 $\mathcal{F}$，译码器直接将 $\hat{u}_i$ 置为已知的冻结值（如0）。
-   如果索引 $i$ 属于信息集 $\mathcal{A}$，译码器会计算在已知 $\hat{u}_1^{i-1}$ 条件下 $u_i$ 的LLR，然后根据LLR的符号做出硬判决（例如，LLR $\ge 0$ 判为0，LLR $ 0$ 判为1）。

SC译码器的实现同样是递归的，其信息流动路径与编码器的递归结构正好相反。在译码过程中，LLR向量在不同递归层级间传递和更新。例如，一个长度为 $M$ 的译码问题可以分解为两个长度为 $M/2$ 的子问题。第一个子问题译码完成后，其结果会作为“[旁路信息](@entry_id:271857)”帮助计算第二个子问题的输入LLR [@problem_id:1661171]。

SC译码的主要优点是其复杂度低，仅为 $O(N \log N)$。然而，它有一个致命弱点：**错误传播 (error propagation)**。由于译码是串行的，一旦某个比特 $\hat{u}_i$ 发生错误，这个错误将影响后续所有依赖于它的比特（即在[生成矩阵](@entry_id:275809)中与 $u_i$ 相关的比特）的译码过程。一个早期的错误很可能像多米诺骨牌一样引发一连串的后续错误，即使后续信道观测值非常清晰也无济于事 [@problem_id:1661179]。

例如，考虑一个 $N=4$ 的极化码，其译码关系为 $\hat{u}_2 = \hat{x}_2 \oplus \hat{u}_1, \hat{u}_3 = \hat{x}_3 \oplus \hat{u}_1, \dots$。如果 $\hat{u}_1$ 被错误译出，那么即使 $\hat{x}_2$ 和 $\hat{x}_3$ 是完全正确的，计算出的 $\hat{u}_2$ 和 $\hat{u}_3$ 也几乎必然是错误的。

#### 连续消除列表（SCL）译码

为了克服SC译码的错误传播问题，**连续消除列表（Successive Cancellation List, SCL）译码**被提出。[SCL译码](@entry_id:265416)器在SC的基础上引入了[列表译码](@entry_id:272728)的思想。

其核心机制是：在译码过程中的每一个信息比特判决阶段，[SCL译码](@entry_id:265416)器不再只选择一个最可能的比特值，而是同时探索两种可能性（0和1）。它维护一个大小为 $L$ 的列表，保存着当前最可能的 $L$ 条候选译码路径（即部分译出的比特序列）。

-   在每个信息比特 $u_i$ 的译码步骤，对于列表中的每条路径，SCL都会分裂成两条新路径，分别对应 $\hat{u}_i=0$ 和 $\hat{u}_i=1$。这样最多会产生 $2L$ 条路径。
-   译码器为每条新路径计算一个**[路径度量](@entry_id:262152) (path metric)**，该度量反映了路径的[似然](@entry_id:167119)度（或非[似然](@entry_id:167119)度）。
-   然后，它对这 $2L$ 条路径进行排序，并只保留度量最优的 $L$ 条路径进入下一阶段。

通过这种方式，即使在某个阶段，正确的路径看起来不是最可能的（即其LLR指向了错误的方向），但只要它的[路径度量](@entry_id:262152)没有差到被挤出列表，它就仍然有机会在后续阶段“翻盘”。

考虑一个场景 [@problem_id:1637400]，在译码 $u_3$ 时，LLR微弱地指向0（$L=+0.2$），而真实值为1。一个SC译码器会在此处做出错误判决 $\hat{u}_3=0$，并沿着这条错误的路径继续下去，导致最终译码失败。而一个[SCL译码](@entry_id:265416)器（例如 $L=2$）会同时保留 $\hat{u}_3=0$ 和 $\hat{u}_3=1$ 两条路径。虽然 $\hat{u}_3=1$ 的路径初始度量稍差，但在译码下一比特 $u_4$ 时，这条正确路径上的LLR可能非常强（例如 $L=+4.0$），足以弥补之前的劣势，使其最终成为度量最优的路径。

[SCL译码](@entry_id:265416)通过保留多个候选路径，极大地缓解了SC译码的错误传播问题，从而显著提升了极化码在有限码长下的错误纠正性能。当列表大小 $L$ 增加时，其性能逼近[最大似然译码](@entry_id:269127)，但相应的计算复杂度也会增加。在SCL的基础上增加一个循环冗余校验（CRC）辅助选择最终路径，即为目前在5G标准中采纳的CRC辅助SCL（CA-SCL）译码方案。