{"hands_on_practices": [{"introduction": "编码的最终目的是为了明确无误地解码。本练习将带你体验编码表示在实际应用中的最后一步：从一个连续的比特流中恢复原始信息。通过手动解码一个前缀码，你将亲身体会到为何无前缀性质是实现即时、准确解码的关键所在 [@problem_id:1619443]。", "problem": "一个深空探测器使用一种可变长度的二进制编码方案来压缩来自四个不同科学仪器的数据，然后再将其传输回地球。这些仪器及其对应的二进制码字如下：\n\n- 仪器A（测量阿尔法粒子通量）：`0`\n- 仪器B（测量硼同位素比率）：`10`\n- 仪器C（测量碳基分子存在）：`110`\n- 仪器D（测量尘埃粒子密度）：`111`\n\n探测器传输一个连续的比特流，代表一系列的测量结果。一个地面站接收到以下比特流：`101100111`。假设没有传输错误，地面站将重建出的仪器读数序列是什么？\n\nA. `BCAD`\n\nB. `BACD`\n\nC. `ADBC`\n\nD. 比特流包含一个无效的码字。\n\nE. `B C A A A`", "solution": "我们有一个可变长度的无前缀码，其映射关系为：A: 0, B: 10, C: 110, D: 111。因为该编码是无前缀的，所以可以通过从左到右扫描比特流来即时解码，在每一步中取与码字匹配的最短前缀。\n\n从接收到的比特流 101100111 开始。\n\n第一步：读取第一个比特 1；由于没有码字是单独的 1，继续读取下一个比特形成 10，这与 B 匹配。记录 B 并移除前缀 10。剩余比特流：1100111。\n\n第二步：读取 1 然后 11；1 和 11 都不是完整的码字。继续读取下一个比特形成 110，这与 C 匹配。记录 C 并移除 110。剩余比特流：0111。\n\n第三步：第一个比特 0 与 A 匹配。记录 A 并移除 0。剩余比特流：111。\n\n第四步：接下来的三个比特 111 与 D 匹配。记录 D 并移除 111。剩余比特流为空。\n\n重建的序列是 BCAD，对应选项 A。", "answer": "$$\\boxed{A}$$", "id": "1619443"}, {"introduction": "设计一个高效的编码器远不止是简单地为符号分配比特串。在现实世界的系统中，不同的编码符号可能带来不同的“成本”，例如传输时间或能量消耗。此问题挑战你设计一个在非均匀成本约束下的最优前缀码，这需要你将霍夫曼编码的核心思想推广到更一般化的情况，即最小化平均成本而非平均长度 [@problem_id:1619389]。", "problem": "一个深空探测器被设计用于监测四种不同类型的天文现象，我们将其标记为符号$S_1, S_2, S_3,$和$S_4$。长期观测表明，这些现象以相等的概率发生。为了将其发现传回地球，该探测器使用一种基于两种脉冲的通信系统：一种是短脉冲，其传输成本为1个能量单位；另一种是长脉冲，其传输成本为3个能量单位。\n\n探测器必须将这四个符号编码成这些脉冲的序列。这组序列必须构成一个前缀码，即没有任何码字是另一个码字的前缀。传输一个符号的成本是其对应码字中脉冲成本的总和。你的任务是设计一种最优前缀码，以最小化每个符号的平均传输成本。\n\n每个符号可能的最低平均传输成本是多少？请以精确小数值报告你的最终答案。", "solution": "设两种脉冲类型为二元码字母表中的字母，其成本分别为 $c_{S}=1$ (短) 和 $c_{L}=3$ (长)。前缀码对应于一棵有根二叉树，其中每条指向子节点的边都会将相应的脉冲成本加到路径上，每个叶子节点对应一个码字，其成本等于其路径上各边成本的总和。对于四个等概率的符号，平均传输成本等于四个叶子成本之和除以$4$。因此，我们必须最小化四个叶子成本的总和。\n\n要做到这一点，我们采用一个贪心策略，迭代地构建编码树。我们从一个成本为0的根节点开始，在每一步中，选择当前所有叶子中成本最低的一个并将其扩展（分裂）成两个新的子叶子。重复此过程，直到我们有四个叶子。\n\n执行贪心构造，直到有$4$个叶子为止：\n\n1) 从一个叶子开始：$\\{0\\}$。\n扩展 $0 \\to \\{1,3\\}$。叶子：成本 $\\{1,3\\}$；总和 $=4$。\n\n2) 扩展最便宜的叶子 $1 \\to \\{2,4\\}$。叶子：$\\{2,3,4\\}$；总和 $=9$。\n\n3) 扩展最便宜的叶子 $2 \\to \\{3,5\\}$。叶子：$\\{3,3,4,5\\}$；总和 $=15$。\n\n现在我们有$4$个叶子，其可能的最小总成本为$15$，所以最小平均成本是\n$$\n\\frac{15}{4} \\;=\\; 3.75.\n$$\n我们也可以通过可行性约束来确认其最优性：要优于$15$，我们需要总和$\\leq 14$，例如$\\{3,3,4,4\\}$。仅有的成本为$3$的叶子是$L$和$SSS$，根据前缀约束，同时选择这两者会迫使我们排除$LS$和$SSSS$，最多只留下一个成本为$4$的叶子($SL$)，而第四个叶子的成本至少为$5$（例如，$SSL$），得到的总和为$15$。因此，无法实现低于$15$的总和，并且所构造的码是最优的。所以，每个符号可能的最低平均传输成本是$3.75$。", "answer": "$$\\boxed{3.75}$$", "id": "1619389"}, {"introduction": "理解一个算法为何有效，最好的方法之一是分析一个看似合理但实际上有缺陷的替代算法。这个问题提供了一个“反向”的霍夫曼算法，它在每一步合并概率最高的节点。通过计算这个次优编码的平均码长，你将更深刻地理解为什么标准霍夫曼算法坚持合并概率最低的节点是实现最优压缩的关键 [@problem_id:1619430]。", "problem": "考虑一个离散无记忆信源，其符号集包含四个符号 $\\{S_1, S_2, S_3, S_4\\}$，出现的概率分别为 $P(S_1)=0.5$、$P(S_2)=0.4$、$P(S_3)=0.05$ 和 $P(S_4)=0.05$。一位工程师实现了一种算法，为该信源构建二进制前缀码。该算法通过迭代合并节点来构建码树。在每一步中，算法会识别当前集合中概率最高的两个节点，并将它们合并成一个新的父节点。这个新节点的概率是其子节点概率之和。重复此过程，直到所有符号都成为单个树的一部分，且根节点的总概率为1。\n\n计算所得编码的平均码长。答案以比特/符号为单位表示。", "solution": "给定一个二进制前缀码构建算法，该算法重复地将当前概率最高的两个节点合并，形成一个父节点，其概率为两者之和。这会生成一个满二叉树；每个符号的码长等于其在最终树中的深度（离根节点的距离），平均码长计算公式为 $L=\\sum_{i}P(S_{i})\\,\\ell(S_{i})$。\n\n从节点概率的多重集开始：\n$$\\{0.5,\\,0.4,\\,0.05,\\,0.05\\}.$$\n\n步骤1（合并概率最高的两个）：合并 $0.5$ 和 $0.4$，形成一个概率为 $0.9$ 的节点。\n当前集合：\n$$\\{0.9,\\,0.05,\\,0.05\\}.$$\n这使得 $S_{1}$ 和 $S_{2}$ 在一个子树中成为兄弟节点，在该子树中，它们当前的深度均为 $1$。\n\n步骤2（合并概率最高的两个）：合并 $0.9$ 和其中一个 $0.05$ 的节点，形成一个概率为 $0.95$ 的节点。\n当前集合：\n$$\\{0.95,\\,0.05\\}.$$\n这将合并后的 $0.05$ 叶节点置于这个新子树中深度为 $1$ 的位置，并使 $\\{S_{1},S_{2}\\}$ 子树成为其兄弟节点；相对于最终的根，它们在下一步中深度将再增加一级。\n\n步骤3（合并概率最高的两个）：合并 $0.95$ 和 $0.05$，形成概率为 $1$ 的根节点。\n\n根据此构造过程，最终的码长由每个符号到根节点的路径上影响它的合并次数决定：\n- $S_{4}$（直到最后一步才被合并的那个 $0.05$）仅在最后一次合并时被连接，所以 $\\ell(S_{4})=1$。\n- 另一个 $0.05$（比如 $S_{3}$）在步骤2中被合并，然后在步骤3中再次被合并，所以 $\\ell(S_{3})=2$。\n- $S_{1}$ 和 $S_{2}$ 在步骤1中被合并，然后它们的父节点在步骤2中被合并，并在步骤3中再次被合并，所以 $\\ell(S_{1})=\\ell(S_{2})=3$。\n\n因此，平均码长为\n$$\nL \\;=\\; 0.5\\cdot 3 \\;+\\; 0.4\\cdot 3 \\;+\\; 0.05\\cdot 2 \\;+\\; 0.05\\cdot 1\n\\;=\\; 1.5 \\;+\\; 1.2 \\;+\\; 0.1 \\;+\\; 0.05\n\\;=\\; 2.85.\n$$\n两个 $0.05$ 符号之间的任何平局处理方式只会交换它们的码长 $1$ 和 $2$，而平均码长保持不变。", "answer": "$$\\boxed{2.85}$$", "id": "1619430"}]}