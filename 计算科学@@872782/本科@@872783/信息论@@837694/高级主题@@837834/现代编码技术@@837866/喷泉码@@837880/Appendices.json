{"hands_on_practices": [{"introduction": "要真正掌握剥离解码器（peeling decoder）的巧妙之处，最好的方法莫过于亲手实践。本练习提供了一组具体的已接收编码包，让您能够逐步模拟解码算法。通过手动解决依赖关系，您将直观地理解信息是如何被逐层“剥离”以揭示原始数据的。", "problem": "在现代数据传输系统（如卫星通信或点对点文件共享）中，无速率码（喷泉码的一类）因其高效性和鲁棒性而被采用。一个文件首先被分割成 $K$ 个源数据包，记为 $s_1, s_2, \\dots, s_K$。然后，发送端会生成一个可能无限的编码包流 $c_1, c_2, \\dots$。每个编码包 $c_j$ 是由源数据包的一个随机选择的子集进行按位异或（XOR，用 $\\oplus$ 表示）运算生成的。\n\n接收端收集这些编码包。为了重构原始文件，使用一种称为“剥离解码器”的简单而有效的迭代算法。解码过程按以下步骤进行：\n1.  解码器搜索任何仅由单个源数据包组成的已接收编码包 $c_j$，例如 $c_j = s_i$。这就立即恢复了源数据包 $s_i$。\n2.  一旦一个源数据包 $s_i$ 被恢复，它的值就被用来简化所有其他依赖于它的编码包。对于任何其他在其异或和中包含 $s_i$ 的已接收数据包 $c_k$（例如，$c_k = s_i \\oplus s_p \\oplus s_q$），接收端计算一个新的、简化的编码包 $c'_k = c_k \\oplus s_i = s_p \\oplus s_q$。这个新包 $c'_k$ 在待解方程组中替换 $c_k$。\n3.  从步骤1开始重复此过程，迭代地寻找新的可解依赖关系并简化系统，直到所有 $K$ 个源数据包都被恢复。\n\n如果有多个包同时变得可解，它们将按照其原始编码包索引的升序进行处理（例如，源于 $c_2$ 的简化将在源于 $c_3$ 的简化之前处理）。\n\n考虑一个场景，其中一个文件被分割成 $K=4$ 个源数据包：$s_1, s_2, s_3$ 和 $s_4$。一个接收端收集了以下四个编码包：\n- $c_1 = s_1$\n- $c_2 = s_1 \\oplus s_2$\n- $c_3 = s_1 \\oplus s_3$\n- $c_4 = s_2 \\oplus s_3 \\oplus s_4$\n\n遵循所述的剥离解码器算法，源数据包将按特定顺序被恢复。在这个序列中第三个被恢复的源数据包 $s_i$ 的索引 $i$ 是什么？请以单个整数的形式提供您的答案。", "solution": "我们严格按照规定遵循剥离解码器算法，应用异或简化以及给定的按原始编码包索引升序的平局打破规则。\n\n最初，接收到的编码包是：\n$$\nc_{1}=s_{1},\\quad c_{2}=s_{1}\\oplus s_{2},\\quad c_{3}=s_{1}\\oplus s_{3},\\quad c_{4}=s_{2}\\oplus s_{3}\\oplus s_{4}.\n$$\n\n1) 识别度为1的包：$c_{1}=s_{1}$ 的度为1，所以 $s_{1}$ 首先被恢复。\n\n2) 使用 $s_{1}$ 来简化所有其他包含 $s_{1}$ 的包：\n$$\nc_{2}'=c_{2}\\oplus s_{1}=(s_{1}\\oplus s_{2})\\oplus s_{1}=s_{2},\\quad\nc_{3}'=c_{3}\\oplus s_{1}=(s_{1}\\oplus s_{3})\\oplus s_{1}=s_{3},\n$$\n而 $c_{4}$ 保持为 $s_{2}\\oplus s_{3}\\oplus s_{4}$，因为它不包含 $s_{1}$。\n\n现在 $c_{2}'=s_{2}$ 和 $c_{3}'=s_{3}$ 同时变为度为1。根据按原始编码包索引升序打破平局的规则，我们在处理 $c_{3}'$（源于 $c_{3}$）之前处理 $c_{2}'$（源于 $c_{2}$）。因此 $s_{2}$ 是第二个被恢复的。\n\n3) 使用 $s_{2}$ 来简化包含 $s_{2}$ 的包：\n$$\nc_{4}'=c_{4}\\oplus s_{2}=(s_{2}\\oplus s_{3}\\oplus s_{4})\\oplus s_{2}=s_{3}\\oplus s_{4},\n$$\n而 $c_{3}'=s_{3}$ 保持不变。\n\n现在度为1的包是 $c_{3}'=s_{3}$，所以 $s_{3}$ 是第三个被恢复的。\n\n因此，第三个被恢复的源数据包的索引是 $i=3$。", "answer": "$$\\boxed{3}$$", "id": "1625543"}, {"introduction": "虽然剥离解码器功能强大，但并非万无一失。本练习探讨了一种解码失败的关键情景，即使接收到的数据包数量等于源数据包数量，解码仍然无法完成。这个思想实验 [@problem_id:1625537] 揭示了接收到的数据量与其所含信息量之间的关键区别，并引入了线性相关性作为解码停滞的原因。", "problem": "一种简单的数字喷泉码被用来传输一个消息，该消息被分成三个源数据包，记为 $S_1$、$S_2$ 和 $S_3$。编码过程通过对源数据包的一个子集进行按位异或（XOR，记为 $\\oplus$）操作来生成新的数据包。接收方收集编码后的数据包，直到它拥有足够的信息来重构原始的三个源数据包。\n\n假设一个接收方收集到了以下三个编码数据包 $E_1$、$E_2$ 和 $E_3$：\n- $E_1 = S_1 \\oplus S_2$\n- $E_2 = S_1 \\oplus S_3$\n- $E_3 = S_2 \\oplus S_3$\n\n这种编码的标准解码算法，被称为“涟漪”过程，首先需要找到一个仅由单个源数据包编码而成的接收包（一个“度为一”的数据包）。这个源数据包随后被视为“已解决”，并与任何其他包含它的编码数据包进行异或操作，从而降低它们的复杂度，并期望能创建出新的度为一的数据包。这个过程持续进行，直到所有源数据包都被解决。\n\n根据接收到的数据包集合 $\\{E_1, E_2, E_3\\}$ 以及异或操作的性质，以下哪个陈述是正确的？\n\nA: 源数据包 $S_1$ 可以从接收到的数据包中唯一确定。\n\nB: 异或和 $S_1 \\oplus S_2 \\oplus S_3$ 可以从接收到的数据包中唯一确定。\n\nC: “涟漪”解码过程可以成功启动，并最终恢复所有源数据包。\n\nD: 接收到的数据包集合是线性相关的，但仍然可以通过其他方法（例如，高斯消元法）唯一确定所有源数据包。\n\nE: 异或和 $S_1 \\oplus S_2$ 可以被唯一确定，但没有任何单个源数据包可以被唯一确定。", "solution": "设未知数据包为域 $\\mathbb{F}_{2}$ 上向量空间的元素，其中异或操作记为 $\\oplus$。接收到的方程为\n$$\nE_{1} = S_{1} \\oplus S_{2}, \\quad E_{2} = S_{1} \\oplus S_{3}, \\quad E_{3} = S_{2} \\oplus S_{3}.\n$$\n我们使用异或的性质：交换律和结合律，$x \\oplus x = 0$，以及 $x \\oplus 0 = x$。\n\n首先，观察接收到的数据包之间的线性相关性。将所有三个方程进行异或运算得到\n$$\nE_{1} \\oplus E_{2} \\oplus E_{3} = (S_{1} \\oplus S_{2}) \\oplus (S_{1} \\oplus S_{3}) \\oplus (S_{2} \\oplus S_{3}) = (S_{1} \\oplus S_{1}) \\oplus (S_{2} \\oplus S_{2}) \\oplus (S_{3} \\oplus S_{3}) = 0,\n$$\n因此 $E_{1} \\oplus E_{2} \\oplus E_{3} = 0$，这三个方程是线性相关的。等价地，系数矩阵\n$$\n\\begin{pmatrix}\n1  1  0 \\\\\n1  0  1 \\\\\n0  1  1\n\\end{pmatrix}\n$$\n的行向量之和为零向量，因此其秩为 $2$。对于 $3$ 个未知数和只有 $2$ 个独立方程的情况，无法通过高斯消元法唯一确定所有的 $S_{i}$。因此选项D是错误的。\n\n考虑“涟漪”解码过程。它需要一个度为一的数据包（即一个等于单个 $S_{i}$ 的方程）。每个 $E_{k}$ 都是两个源数据包的异或（度为 $2$），因此没有可用于启动的度为一的数据包，“涟漪”过程无法启动；所以它也无法恢复所有源数据包。因此选项C是错误的。\n\n检查单个源数据包的唯一性。如果 $(S_{1}, S_{2}, S_{3})$ 是任意一个解，那么对于任意数据包 $V$，三元组 $(S_{1} \\oplus V, S_{2} \\oplus V, S_{3} \\oplus V)$ 会产生相同的 $E_{1}, E_{2}, E_{3}$，因为\n$$\n(S_{1} \\oplus V) \\oplus (S_{2} \\oplus V) = S_{1} \\oplus S_{2}, \\quad (S_{1} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{1} \\oplus S_{3}, \\quad (S_{2} \\oplus V) \\oplus (S_{3} \\oplus V) = S_{2} \\oplus S_{3}.\n$$\n因此，没有任何单个 $S_{i}$ 是唯一确定的；选项A是错误的。\n\n检查 $S_{1} \\oplus S_{2} \\oplus S_{3}$ 是否是唯一确定的。用 $S_{1}$ 和已知的 $E_{1}, E_{2}$ 来表示，\n$$\nS_{2} = S_{1} \\oplus E_{1}, \\quad S_{3} = S_{1} \\oplus E_{2},\n$$\n所以\n$$\nS_{1} \\oplus S_{2} \\oplus S_{3} = S_{1} \\oplus (S_{1} \\oplus E_{1}) \\oplus (S_{1} \\oplus E_{2}) = (S_{1} \\oplus S_{1} \\oplus S_{1}) \\oplus E_{1} \\oplus E_{2} = S_{1} \\oplus E_{1} \\oplus E_{2}.\n$$\n因为 $S_{1}$ 不是唯一确定的，所以 $S_{1} \\oplus S_{2} \\oplus S_{3}$ 也不是唯一确定的；选项B是错误的。\n\n然而，某些成对的异或和是唯一已知的。特别地，$S_{1} \\oplus S_{2} = E_{1}$ 是直接给出的，因此是唯一确定的。对于 $S_{1} \\oplus S_{3} = E_{2}$ 和 $S_{2} \\oplus S_{3} = E_{3}$ 也是如此。这就证明了，虽然没有单个源数据包是唯一确定的，但异或和 $S_{1} \\oplus S_{2}$ 是唯一确定的。因此选项E是正确的。", "answer": "$$\\boxed{E}$$", "id": "1625537"}, {"introduction": "除了理解解码机制，评估喷泉码系统的效率也至关重要。本练习引入了“接收开销”（reception overhead）这一关键性能指标，它量化了成功解码需要多少额外的数据包。通过解决一个实际应用场景 [@problem_id:1625538]，您将学会如何计算这一开销，并理解其在现实世界部署中的重要性。", "problem": "一家科技公司正在向其庞大的远程传感器集群部署一项关键的固件更新。更新文件的总大小为 $20.0$ 兆字节 (MB)。为确保在有损无线网络上的可靠传输，该公司使用了一种 Luby 变换 (LT) 码，这是一种喷泉码。更新文件首先被分割成 $K$ 个原始源数据包，每个数据包的大小为 $128$ 千字节 (KB)。假设 $1 \\text{ MB} = 1024 \\text{ KB}$。\n\n服务器随后生成并广播一个由源数据包派生而来的、可视为无穷无尽的编码数据包流。当传感器收集到的唯一编码数据包总数 $N_{rx}$ 比原始源数据包数量 $K$ 多 $5.00\\%$ 时，它就能成功重构原始固件更新文件。\n\n这种编码方案的“接收开销”定义为解码所需的数据包数量与原始源数据包数量的比率，即 $\\frac{N_{rx}}{K}$。\n\n计算该系统的接收开销。请将您的答案以数字形式给出，并四舍五入到三位有效数字。", "solution": "更新文件总大小为 $S=20.0\\ \\text{MB}$，且 $1\\ \\text{MB}=1024\\ \\text{KB}$，所以以千字节 (KB) 为单位，$S=20.0\\times 1024\\ \\text{KB}=20480\\ \\text{KB}$。每个源数据包的大小为 $P=128\\ \\text{KB}$，因此原始源数据包的数量为\n$$\nK=\\frac{S}{P}=\\frac{20480}{128}=160.\n$$\n传感器必须收集的唯一编码数据包数量比 $K$ 多 $0.0500$（相对值），所以\n$$\nN_{rx}=K\\left(1+0.0500\\right)=1.05\\,K.\n$$\n接收开销定义为\n$$\n\\frac{N_{rx}}{K}=\\frac{1.05\\,K}{K}=1.05.\n$$\n四舍五入到三位有效数字，结果是 $1.05$。", "answer": "$$\\boxed{1.05}$$", "id": "1625538"}]}