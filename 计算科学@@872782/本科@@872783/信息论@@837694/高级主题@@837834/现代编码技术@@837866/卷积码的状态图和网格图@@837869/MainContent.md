## 引言
在[数字通信](@entry_id:271926)领域，[卷积码](@entry_id:267423)因其强大的纠错能力和相对简单的实现而扮演着至关重要的角色。然而，要真正驾驭其威力，仅仅理解其基本定义是远远不够的。我们必须深入其内部工作机制——一个由[状态和](@entry_id:193625)转移构成的动态系统。本文旨在填补从抽象概念到具体实现的认知鸿沟，通过引入两种强大的可视化工具——[状态图](@entry_id:176069)和[网格图](@entry_id:261673)，来揭示[卷积码](@entry_id:267423)的核心奥秘。

本文将引导读者踏上一段系统性的学习之旅。在“原理与机制”一章中，我们将学习如何将卷积编码器建模为[有限状态机](@entry_id:174162)，并掌握从其代数定义构建[状态图](@entry_id:176069)和[网格图](@entry_id:261673)的方法。接着，在“应用与跨学科联系”一章，我们将探讨这些图形工具在实际通信系统中的多样化应用，从经典的维特比译码到前沿的[网格编码调制](@entry_id:266755)和量子纠错。最后，“动手实践”部分将提供一系列精心设计的问题，帮助你巩固理论知识，将抽象的图论概念转化为解决实际编码问题的能力。通过这三个层次的深入学习，你将不仅能看懂，更能灵活运用[状态图](@entry_id:176069)和[网格图](@entry_id:261673)来分析、设计和优化[卷积码](@entry_id:267423)方案。

## 原理与机制

在上一章介绍[卷积码](@entry_id:267423)的基本概念之后，本章将深入探讨其核心工作原理和数学表示。卷积编码器本质上是一个具有记忆功能的[有限状态机](@entry_id:174162)（Finite-State Machine, FSM）。为了精确描述和分析其动态行为，我们将引入两种强大的图形表示工具：**[状态图](@entry_id:176069)**（State Diagram）和**[网格图](@entry_id:261673)**（Trellis Diagram）。本章将详细阐述这些图的构建方法、内在结构及其在编码过程中的应用。

### 卷积编码器作为[有限状态机](@entry_id:174162)

理解卷积编码器的第一步是将其视为一个[有限状态机](@entry_id:174162)。一个[有限状态机](@entry_id:174162)的行为由其当前**状态**、接收到的**输入**以及根据这两者确定的**输出**和**下一个状态**完全定义。

#### 状态与存储器

卷积编码器的“记忆”功能是通过其内部的存储单元（通常是[移位寄存器](@entry_id:754780)）实现的。编码器在任意时刻 $t$ 的**状态（state）**被定义为能够唯一确定其未来输出（给定未来输入）的最小信息集合。对于一个标准的非[递归卷积](@entry_id:754162)编码器，这个信息就是其存储寄存器中包含的比特序列。

编码器的**存储器阶数（memory order）**，记为 $m$，是指定义其状态所需的过去输入比特的数量。对于一个[码率](@entry_id:176461)为 $R=1/n$ 的编码器（即每次处理1个输入比特），其状态通常由最近的 $m$ 个输入比特确定。由于每个比特可以是0或1，因此总共有 $2^m$ 个可能的状态。例如，一个具有 $m=3$ 的编码器将有 $2^3 = 8$ 个唯一状态 [@problem_id:1660253]。这个关系是双向的：如果我们知道一个编码器有8个不同的状态，我们可以推断出其存储器阶数为 $m=\log_2(8)=3$。

对于更一般的码率 $R=k/n$ 编码器，它在每个时间单位处理 $k$ 个输入比特。其状态由所有 $k$ 个输入流的历史数据共同决定。如果第 $i$ 个输入流需要 $m_i$ 个存储单元，那么编码器的**总存储器阶数（total memory order）** $\nu$ 是所有单个存储器阶数之和：
$$ \nu = \sum_{i=1}^{k} m_i $$
因此，该编码器的总状态数将是 $2^\nu$。

例如，考虑一个[码率](@entry_id:176461) $R=2/3$ 的编码器，其[生成矩阵](@entry_id:275809) $G(D)$ 为 [@problem_id:1660261]：
$$ G(D) = \begin{pmatrix} 1+D^2  1+D  1 \\ 1+D  D  1+D+D^2 \end{pmatrix} $$
这里，$D$ 是延迟算子。第一个输入流 $U_1(D)$ 所需的存储器 $m_1$ 等于 $G(D)$ 第一行多项式的最高次数，即 $\max\{\deg(1+D^2), \deg(1+D), \deg(1)\} = \max\{2, 1, 0\} = 2$。同样，第二个输入流 $U_2(D)$ 所需的存储器 $m_2$ 是第二行多项式的最高次数，即 $\max\{\deg(1+D), \deg(D), \deg(1+D+D^2)\} = \max\{1, 1, 2\} = 2$。因此，总存储器阶数 $\nu = m_1 + m_2 = 2 + 2 = 4$。该编码器总共有 $2^4 = 16$ 个状态。

### [状态图](@entry_id:176069)表示

为了可视化和分析卷积编码器的动态行为，我们使用一种称为**[状态图](@entry_id:176069)**（state diagram）的图形工具。作为一个[有限状态机](@entry_id:174162)，编码器的所有动态特性——其状态、状态之间的转换以及与这些转换相关的输出——都可以被紧凑地总结在一个有向图中。

在[状态图](@entry_id:176069)中，每个**节点**（node）代表编码器的一个唯一状态。对于一个具有 $m$ 个二[进制](@entry_id:634389)存储单元的编码器，将有 $2^m$ 个状态，可以方便地用存储器中的比特序列来标记，例如 $(u_{t-1}, u_{t-2}, ..., u_{t-m})$。

**有向边**（directed edge）表示从一个当前状态到下一个状态的转换。由于编码器的下一个[状态和](@entry_id:193625)输出取决于当前[状态和](@entry_id:193625)当前输入比特，因此对于每个状态，必须有对应于每个可能输入值的出边。对于二进制编码器，每个状态节点将恰好有两条出边：一条对应于输入 '0'，另一条对应于输入 '1'。

每条边都用 `输入/输出` 的格式进行标记。例如，一条从状态 $S_i$ 指向 $S_j$ 的边，标记为 `1/11`，意味着当编码器处于状态 $S_i$ 时，若输入比特为 `1`，它将转换到状态 $S_j$，并产生输出 `11`。

#### 从代数定义构建[状态图](@entry_id:176069)

[状态图](@entry_id:176069)是编码器代数定义的直接图形化翻译。让我们通过一个具体的例子来演示构建过程。考虑一个[码率](@entry_id:176461)为 $R=1/2$，存储器阶数为 $m=2$ 的卷积编码器 [@problem_id:1660279]。

**1. 确定状态、输出方程和状态转移规则**

编码器的状态由其存储器内容定义。对于 $m=2$，状态可以表示为 $s_k = (u_{k-1}, u_{k-2})$，其中 $u_{k-1}$ 和 $u_{k-2}$ 是前两个输入比特。这给了我们 $2^2=4$ 个状态，我们可以将它们命名为：
- $S_0 = (0, 0)$
- $S_1 = (0, 1)$
- $S_2 = (1, 0)$
- $S_3 = (1, 1)$

假设输出比特 $v_k^{(0)}$ 和 $v_k^{(1)}$ 由以下模2加法（XOR运算）得出：
$$ v_k^{(0)} = u_k \oplus u_{k-1} \oplus u_{k-2} $$
$$ v_k^{(1)} = u_k \oplus u_{k-2} $$

对于标准的[移位寄存器](@entry_id:754780)实现，下一个状态 $s_{k+1}$ 是通过将当前输入 $u_k$ 移入寄存器来确定的：$s_{k+1} = (u_k, u_{k-1})$。

**2. 系统地推导状态转移**

现在，我们可以系统地计算每个状态的所有可能转移。让我们以状态 $S_2 = (1, 0)$ 为例 [@problem_id:1660279]：
- **当前状态**: $s_k = (u_{k-1}, u_{k-2}) = (1, 0)$。
- **当输入 $u_k=0$ 时**:
    - 输出: $v_k^{(0)} = 0 \oplus 1 \oplus 0 = 1$, $v_k^{(1)} = 0 \oplus 0 = 0$。输出对为 $(1, 0)$。
    - 下一个状态: $s_{k+1} = (u_k, u_{k-1}) = (0, 1)$，即状态 $S_1$。
    - 因此，我们得到一条从 $S_2$ 到 $S_1$ 的边，标记为 `0/10`。
- **当输入 $u_k=1$ 时**:
    - 输出: $v_k^{(0)} = 1 \oplus 1 \oplus 0 = 0$, $v_k^{(1)} = 1 \oplus 0 = 1$。输出对为 $(0, 1)$。
    - 下一个状态: $s_{k+1} = (u_k, u_{k-1}) = (1, 1)$，即状态 $S_3$。
    - 因此，我们得到一条从 $S_2$ 到 $S_3$ 的边，标记为 `1/01`。

对所有四个状态重复此过程，我们将得到完整的[状态图](@entry_id:176069)。这个图完整地描述了编码器的行为，独立于时间。

#### [状态图](@entry_id:176069)的基本结构约束

标准卷积编码器的[移位寄存器](@entry_id:754780)结构对其[状态图](@entry_id:176069)施加了严格的拓扑约束。下一个状态 $s_{k+1} = (u_k, u_{k-1}, \dots, u_{k-m+1})$ 仅取决于当前输入 $u_k$ 和状态中除最旧比特外的所有比特 $(u_{k-1}, \dots, u_{k-m+1})$。

这意味着，对于任意两个当前状态，如果它们的前 $m-1$ 个比特相同（即它们仅在最旧的比特 $u_{k-m}$ 上不同），那么在给定相同输入的情况下，它们将转移到完全相同的下一个状态。例如，状态 $(0, u_{k-2}, \dots)$ 和 $(1, u_{k-2}, \dots)$ 在接收到输入 $u_k$ 时，都会转移到状态 $(u_k, 0, u_{k-2}, \dots)$。

任何不遵循此规则的转移描述都不能代表一个标准的卷积编码器。例如，考虑一个声称有四个状态 A, B, C, D 的编码器，其转移规则如下 [@problem_id:1660244]：
- 从状态 C (假设其比特表示为 $(1,1)$) 出发:
    - 输入 0，转移到 A (假设为 $(0,1)$)。这符合移位规则 $(1,1) \xrightarrow{0} (0,1)$。
    - 输入 1，转移到 D。根据[移位](@entry_id:145848)规则，下一个状态应为 $(1,1)$，即它应该转移回自身。如果 D 不是 C，则该规则违反了标准结构。
- 进一步分析发现，该问题的[状态转移表](@entry_id:163350)无法与任何一致的二[进制](@entry_id:634389)[状态表示](@entry_id:141201)相匹配，因此它描述的不是一个标准的卷积编码器。这种结构性检查是验证编码器设计的关键步骤。

### 使用[状态图](@entry_id:176069)进行编码

一旦[状态图](@entry_id:176069)建立，编码过程就变得非常直观。它简化为在图上追踪一条由输入序列决定的路径。

假设一个[码率](@entry_id:176461)为 $R=1/2$、存储器为 $m=2$ 的编码器，其生成序列为 $g_1=(1,1,1)$ 和 $g_2=(1,0,1)$。编码器从全零状态 $s_0=(0,0)$ 开始。我们要对输入序列 $u=(1,0,1,1)$ 进行编码 [@problem_id:1660238]。

1.  **t=1**: 初始状态 $s_1=(0,0)$，输入 $u_1=1$。
    - 输出: $(y_{1,1}, y_{2,1}) = (1\oplus0\oplus0, 1\oplus0) = (1,1)$。
    - 下一状态: $s_2 = (u_1, u_0) = (1,0)$。
    - 路径: 从状态 (0,0) 沿标记 `1/11` 的边移动到状态 (1,0)。

2.  **t=2**: 当前状态 $s_2=(1,0)$，输入 $u_2=0$。
    - 输出: $(y_{1,2}, y_{2,2}) = (0\oplus1\oplus0, 0\oplus0) = (1,0)$。
    - 下一状态: $s_3 = (u_2, u_1) = (0,1)$。
    - 路径: 从状态 (1,0) 沿标记 `0/10` 的边移动到状态 (0,1)。

3.  **t=3**: 当前状态 $s_3=(0,1)$，输入 $u_3=1$。
    - 输出: $(y_{1,3}, y_{2,3}) = (1\oplus0\oplus1, 1\oplus1) = (0,0)$。
    - 下一状态: $s_4 = (u_3, u_2) = (1,0)$。
    - 路径: 从状态 (0,1) 沿标记 `1/00` 的边移动到状态 (1,0)。

4.  **t=4**: 当前状态 $s_4=(1,0)$，输入 $u_4=1$。
    - 输出: $(y_{1,4}, y_{2,4}) = (1\oplus1\oplus0, 1\oplus0) = (0,1)$。
    - 下一状态: $s_5 = (u_4, u_3) = (1,1)$。
    - 路径: 从状态 (1,0) 沿标记 `1/01` 的边移动到状态 (1,1)。

通过连接每个时间步的输出，我们得到最终的码字序列：$(1,1), (1,0), (0,0), (0,1)$，或连接成比特流 `11100001` [@problem_id:1660238] [@problem_id:1660259] [@problem_id:1660260]。这个过程清晰地展示了[状态图](@entry_id:176069)作为编码工具的实用性。

### 从[状态图](@entry_id:176069)到[网格图](@entry_id:261673)

[状态图](@entry_id:176069)提供了一个编码器行为的紧凑、时不变的描述。然而，对于分析和解码一个特定的、随时间演进的序列，我们需要一个能明确表示时间维度的工具。这就是**[网格图](@entry_id:261673)（trellis diagram）**的作用。

[网格图](@entry_id:261673)可以被看作是[状态图](@entry_id:176069)在时间轴上的“展开”。它由一系列[排列](@entry_id:136432)在列中的节点组成，每一列代表一个离散的时间步。
- 在任意时间步 $t$，$N_{states}$ 个节点代表了编码器在该时刻可能处于的所有状态。
- 边仅连接相邻时间步的节点（从时间 $t$到 $t+1$）。
- 连接两个节点的边代表一个有效的状态转移，其标签 `输入/输出` 与[状态图](@entry_id:176069)中对应转移的标签完全相同。

关键的见解是，**[网格图](@entry_id:261673)的单个时间切片（即时间 $t$ 和 $t+1$ 之间的所有节点和转移）在结构上与[状态图](@entry_id:176069)是完全相同的** [@problem_id:1660275]。[网格图](@entry_id:261673)本质上是沿着时间轴重复地绘制[状态图](@entry_id:176069)的副本，并将它们连接起来。

[状态图](@entry_id:176069)的优势在于其紧凑性，它用一个简单的图描绘了所有可能性。而[网格图](@entry_id:261673)的优势在于其明确的时间演进表示。对于一个长度为 $L$ 的输入序列，其编码过程对应于[网格图](@entry_id:261673)上的一条从时间 0 到时间 $L$ 的特定路径。这种路径的可视化对于理解诸如[维特比算法](@entry_id:269328)（Viterbi algorithm）等[最大似然](@entry_id:146147)解码算法至关重要，这些算法正是在[网格图](@entry_id:261673)上寻找最可能的路径。

### 特殊性质与实际应用

[状态图](@entry_id:176069)和[网格图](@entry_id:261673)不仅是理论工具，它们还能帮助我们理解[卷积码](@entry_id:267423)的一些重要实际特性。

#### 系统码

如果一个[卷积码](@entry_id:267423)的某个输出流与输入信息流完全相同，则称该码为**系统码（systematic code）**。例如，对于一个[码率](@entry_id:176461) $R=1/2$ 的编码器，如果其两个输出流之一始终等于输入比特，那么它就是系统码。系统码的优势在于原始信息比特无需任何计算即可在接收端提取，这在某些应用中非常方便。

我们可以直接通过检查[状态图](@entry_id:176069)来判断一个码是否是系统码。我们需要检查是否存在一个固定的输出位置（例如，第一个输出比特），使得对于图中所有的转移边，该位置的输出比特都等于导致该转移的输入比特。

考虑一个编码器A，其部分转移如下 [@problem_id:1660272]：
- 从 (0,0) 出发：输入0 $\rightarrow$ 输出00；输入1 $\rightarrow$ 输出11。
- 从 (0,1) 出发：输入0 $\rightarrow$ 输出01；输入1 $\rightarrow$ 输出10。
在所有情况下，第一个输出比特 $c_1$ 都等于输入比特 $u$。如果这个规律对所有状态都成立，那么编码器A就是系统码。

相比之下，另一个编码器B，其从状态 (1,1) 出发的转移为：输入0 $\rightarrow$ 输出11。这里，两个输出比特都不等于输入比特。因此，编码器B不可能是系统码。

#### [网格终止](@entry_id:262014)

在实际的块传输系统中，信息数据通常是有限长度的块。当一个信息块的所有比特都输入编码器后，编码器会停留在某个最终状态，这个状态取决于整个输入序列。然而，许多解码算法（如[维特比算法](@entry_id:269328)）要求编码器在块的开始和结束时都处于一个已知的状态，通常是**全零状态**（all-zero state）。

为了实现这一点，需要在信息块的末尾附加一串特定的**尾比特（tail bits）**。这些尾比特的作用是将编码器从其最终状态强制驱动回全零状态。这个过程称为**[网格终止](@entry_id:262014)（trellis termination）**。

对于一个存储器阶数为 $m$ 的非递归（前馈）编码器，一个简单而通用的终止方法是附加 $m$ 个 '0' 作为尾比特。无论编码器在处理完信息块后处于哪个状态 $(u_{L}, u_{L-1}, \dots, u_{L-m+1})$，连续输入 $m$ 个零将逐步将寄存器中的所有非零比特“冲洗”出去，最终使状态变为 $(0, 0, \dots, 0)$。

例如，对于一个 $m=2$ 的编码器，在处理完信息块后，其状态为 $(u_L, u_{L-1})$。
- 第一个尾比特 '0' 输入后，状态变为 $(0, u_L)$。
- 第二个尾比特 '0' 输入后，状态变为 $(0, 0)$，即全零状态。

重要的是，这个过程只依赖于编码器的[移位寄存器](@entry_id:754780)结构和存储器阶数 $m$，而与具体的[生成多项式](@entry_id:265173)无关 [@problem_id:1660249]。这种可靠的终止方法确保了每个[数据块](@entry_id:748187)都可以被独立解码，是[卷积码](@entry_id:267423)在实际通信系统中（如Wi-Fi和蜂窝网络标准）得以广泛应用的关键技术之一。