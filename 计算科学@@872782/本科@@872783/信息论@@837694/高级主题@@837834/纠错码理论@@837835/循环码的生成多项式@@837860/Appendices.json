{"hands_on_practices": [{"introduction": "在设计循环码时，首要任务是选择一个有效的生成多项式。一个多项式 $g(x)$ 要成为长度为 $n$ 的循环码的生成多项式，它必须满足一个基本条件：它必须是 $x^n+1$ 在 $\\mathbb{F}_2[x]$ 上的一个因式。这个练习将带你通过一个具体的例子 [@problem_id:1626619] 来检验这个关键的先决条件，这是构建任何循环码系统的第一步。", "problem": "在数字通信系统的纠错码设计中，二元循环码因其高效的实现而受到青睐。如果一个系数在二元域 $\\mathbb{F}_2$ 中的多项式 $g(x)$，其所有码字组成的集合是由次数小于 $n$ 且为 $g(x)$ 倍式的多项式构成，并且这个码字集合在循环移位下是闭合的，则称该多项式 $g(x)$ 生成一个码长为 $n$ 的二元循环码。要使这样的码存在，一个基本要求是生成多项式 $g(x)$ 必须在多项式环 $\\mathbb{F}_2[x]$ 中整除多项式 $x^n+1$，其中所有系数运算都是模2进行的。\n\n考虑一个设计使用码长为 $n=7$ 的二元循环码的系统。一位工程师提出了四种不同的多项式作为生成多项式。然而，其中一个提议是无效的，因为它不满足给定码长的基本要求。\n\n从下面的列表中找出无效的多项式。\n\nA. $g_A(x) = x+1$\n\nB. $g_B(x) = x^3+x+1$\n\nC. $g_C(x) = x^2+1$\n\nD. $g_D(x) = (x+1)(x^3+x+1)$", "solution": "一个在 $\\mathbb{F}_2$ 上码长为 $n$、生成多项式为 $g(x)$ 的二元循环码存在的充要条件是 $g(x)$ 在 $\\mathbb{F}_2[x]$ 中整除 $x^n+1$。我们必须确定，对于 $n=7$，哪个提议的 $g(x)$ 不能整除 $x^7+1$。\n\n首先，在 $\\mathbb{F}_2$ 中使用余数定理来检验 $g_A(x) = x+1$。任何多项式 $f(x)$ 除以 $x+1$ 的余数是 $f(1)$。对于 $f(x)=x^7+1$ 计算 $f(1)$：\n$$\n1^{7}+1=1+1=0 \\quad \\text{在 } \\mathbb{F}_{2} \\text{ 中}。\n$$\n因此 $x+1$ 整除 $x^7+1$，所以 A 是有效的。\n\n接下来，考虑 $g_B(x) = x^3+x+1$。令 $\\alpha$ 是 $x^3+x+1$ 在一个扩域中的根。由于 $x^3+x+1$ 在 $\\mathbb{F}_2$ 上是不可约的，域 $\\mathbb{F}_2(\\alpha)$ 有 $2^3=8$ 个元素，其乘法群的阶为7。一个非零元素的可能阶只能是7的因子，即1和7。在 $x=1$ 处计算 $x^3+x+1$ 的值：\n$$\n1^{3}+1+1=1 \\neq 0 \\quad \\text{在 } \\mathbb{F}_{2} \\text{ 中}，\n$$\n所以 $\\alpha \\neq 1$。因此 $\\alpha$ 的阶为7，所以 $\\alpha^7=1$，这意味着 $\\alpha$ 是 $x^7+1$ 的一个根。因此 $\\alpha$ 的极小多项式，即 $x^3+x+1$，整除 $x^7+1$，B 是有效的。\n\n对于 $g_D(x)=(x+1)(x^3+x+1)$，由于每个因子都整除 $x^7+1$ 并且\n$$\n\\gcd(x+1,\\,x^{3}+x+1)=1 \\quad \\text{(因为在 } \\mathbb{F}_{2} \\text{ 中 } (x^{3}+x+1)(1)=1 \\neq 0)，\n$$\n根据性质“若 $g_1 \\mid P$ 且 $g_2 \\mid P$ 且 $\\gcd(g_1, g_2) = 1$，则 $g_1g_2 \\mid P$”，可得 $(x+1)(x^3+x+1)$ 整除 $x^7+1$。因此 D 是有效的。\n\n最后，检验 $g_C(x) = x^2+1$。在 $\\mathbb{F}_2$ 上，\n$$\nx^{2}+1=(x+1)^{2},\n$$\n因为在 $\\mathbb{F}_2$ 中 $(x+1)^2=x^2+2x+1=x^2+1$。如果 $(x+1)^2$ 要整除 $x^7+1$，那么 $x=1$ 必须是 $x^7+1$ 的一个二重根。根的重数可以通过形式导数来检验。在 $\\mathbb{F}_2$ 中计算导数：\n$$\n\\frac{d}{dx}\\left(x^{7}+1\\right)=7x^{6}=x^{6} \\quad \\text{在 } \\mathbb{F}_{2} \\text{ 中}。\n$$\n在 $x=1$ 处求值：\n$$\n(x^{6})(1)=1 \\neq 0 \\quad \\text{在 } \\mathbb{F}_{2} \\text{ 中}。\n$$\n因此 $x=1$ 是 $x^7+1$ 的一个单根，所以 $(x+1)^2$ 不整除 $x^7+1$。因此 $x^2+1$ 不整除 $x^7+1$，C 是无效的。\n\n因此，无效的生成多项式是 $g_C(x) = x^2+1$。", "answer": "$$\\boxed{C}$$", "id": "1626619"}, {"introduction": "一旦我们选定了有效的生成多项式，它的主要作用就是将信息进行编码。最直接的编码方法是多项式乘法，即码字多项式 $c(x)$ 等于信息多项式 $m(x)$ 与生成多项式 $g(x)$ 的乘积。下面的练习 [@problem_id:1361299] 将让你亲手完成这个核心的编码计算过程，将一条给定的信息转换为相应的码字。", "problem": "在一个简化的数字通信系统中，使用循环码实现了一种基本的错误检测方案。该方案对数据块进行操作，这些数据块表示为系数在有限域 $\\mathbb{F}_2 = \\{0, 1\\}$ 中的多项式。在此域中，对系数的所有算术运算均在模2下进行。\n\n该系统使用一个 $[7,4]$ 循环码，这意味着长度为4的消息块（表示为次数小于4的多项式）被编码为长度为7的码字块（表示为次数小于7的多项式）。这个特定的码由生成多项式 $g(x) = 1 + x + x^3$ 指定。\n\n编码过程定义如下：码字多项式 $c(x)$ 是通过将消息多项式 $m(x)$ 与生成多项式 $g(x)$ 直接相乘而生成的。\n\n给定由多项式 $m(x) = 1 + x^2$ 表示的消息，确定相应的码字多项式 $c(x)$。", "solution": "我们在多项式环 $\\mathbb{F}_{2}[x]$ 上进行运算，其中系数的加法和乘法是模2的。编码规则是 $c(x) = m(x)g(x)$。\n\n给定 $m(x) = 1 + x^{2}$ 和 $g(x) = 1 + x + x^{3}$，计算：\n$$\nc(x) = (1 + x^{2})(1 + x + x^{3}).\n$$\n使用分配律，\n$$\nc(x) = 1\\cdot(1 + x + x^{3}) + x^{2}\\cdot(1 + x + x^{3}) = (1 + x + x^{3}) + (x^{2} + x^{3} + x^{5}).\n$$\n合并同类项，加法在模2下进行（因此一个项与自身相加会抵消为 $0$）：\n$$\nc(x) = 1 + x + x^{3} + x^{2} + x^{3} + x^{5} = 1 + x + x^{2} + (x^{3} + x^{3}) + x^{5} = 1 + x + x^{2} + x^{5}.\n$$\n此多项式的次数小于7，符合在给定编码规则下对 $[7,4]$ 码的要求。", "answer": "$$\\boxed{1 + x + x^{2} + x^{5}}$$", "id": "1361299"}, {"introduction": "循环码的真正威力在于其错误控制能力。这种能力的核心是“伴随式” (syndrome) 的概念，它通过计算接收到的多项式除以生成多项式 $g(x)$ 的余数来诊断错误，一个非零的伴随式标志着数据传输中出现了错误。这个练习 [@problem_id:1626637] 将演示如何计算伴随式，让你理解它是如何作为通信系统中发现数据错误的关键诊断工具。", "problem": "硬盘驱动器上的一个数据存储系统使用二元循环码来检测和纠正错误。所有多项式运算都在有限域 $\\mathbb{F}_2$ 中进行，其中加法等价于逻辑异或运算。该码使用生成多项式 $g(x) = x^3 + x + 1$ 构建。根据定义，任何表示为多项式 $c(x)$ 的有效码字都是 $g(x)$ 的倍数。\n\n在一次读取操作中，一个7比特数据块（码块长度 $n=7$，比特位置从0到6索引）的最高位比特位置发生了一次翻转。这个单比特错误可以用错误多项式 $e(x) = x^6$ 来描述。代表读取数据的多项式是 $r(x) = c(x) + e(x)$。\n\n错误检测机制通过计算伴随式多项式 $s(x)$ 来工作，它被定义为读取数据多项式 $r(x)$ 除以生成多项式 $g(x)$ 后的余数。\n\n计算由这个特定错误产生的伴随式多项式 $s(x)$。", "solution": "伴随式多项式 $s(x)$ 定义为接收到的多项式 $r(x)$ 除以生成多项式 $g(x)$ 的余数。这可以用模运算表示为：\n$$s(x) = r(x) \\pmod{g(x)}$$\n给定接收到的多项式为 $r(x) = c(x) + e(x)$，其中 $c(x)$ 是发送的码字多项式，$e(x)$ 是错误多项式。将此代入伴随式方程得到：\n$$s(x) = [c(x) + e(x)] \\pmod{g(x)}$$\n利用模运算的性质，我们可以将各项分开：\n$$s(x) = [c(x) \\pmod{g(x)}] + [e(x) \\pmod{g(x)}]$$\n根据循环码的定义，任何有效的码字多项式 $c(x)$ 都是生成多项式 $g(x)$ 的倍数。这意味着 $c(x)$ 除以 $g(x)$ 的余数为零。\n$$c(x) \\pmod{g(x)} = 0$$\n因此，伴随式的计算简化为求错误多项式除以生成多项式的余数：\n$$s(x) = e(x) \\pmod{g(x)}$$\n给定错误多项式 $e(x) = x^6$ 和生成多项式 $g(x) = x^3 + x + 1$。为了求余数，我们可以使用多项式长除法，或者更高效地，利用模 $g(x)$ 的多项式环的代数性质。在此背景下，任何 $g(x)$ 的倍数都等价于 0。\n$$g(x) = x^3 + x + 1 \\equiv 0$$\n这给了我们一个规约规则。因为所有运算都在 $\\mathbb{F}_2$ 中进行，加法与减法相同。因此，我们可以写成：\n$$x^3 \\equiv -x - 1 \\equiv x + 1$$\n现在我们可以用这个规则来规约错误多项式 $e(x) = x^6$，直到其次数小于 $g(x)$ 的次数（即3）。\n$$e(x) = x^6 = (x^3)^{2}$$\n代入规约规则 $x^3 \\equiv x + 1$：\n$$s(x) \\equiv (x + 1)^2$$\n现在，我们展开平方项：\n$$(x + 1)^2 = x^2 + 2x + 1$$\n因为运算是在 $\\mathbb{F}_2$ 中进行的，系数2等价于0（$2 \\pmod{2} = 0$）。\n$$x^2 + 2x + 1 \\equiv x^2 + (0)x + 1 = x^2 + 1$$\n得到的多项式 $x^2 + 1$ 的次数为2，小于 $g(x)$ 的次数。因此，这就是最终的余数。伴随式多项式是：\n$$s(x) = x^2 + 1$$", "answer": "$$\\boxed{x^{2} + 1}$$", "id": "1626637"}]}