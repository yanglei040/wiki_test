{"hands_on_practices": [{"introduction": "线性码本质上是一个向量子空间，它可以由不同的基向量组来描述。在编码理论中，这些基对应于生成矩阵。本练习 [@problem_id:1633509] 将引导你完成一个实际场景，你必须判断两个表面上不同的生成矩阵是否实际上定义了完全相同的纠错码，这是验证和比较编码设计的关键技能。", "problem": "在一个新的人造卫星通信项目中，两个分别被命名为Alpha和Bravo的工程团队被独立地分配了设计一个二元线性纠错码的任务。两个团队本应实现相同的 $[6, 3]$ 码，即一种将3比特信息字映射为6比特码字的编码。然而，由于初始项目规范中的混淆，他们最终记录的生成矩阵有所不同。所有算术运算都在有限域 $GF(2)$ 中进行，其中 $1+1=0$。\n\nAlpha团队的生成矩阵为：\n$$ G_A = \\begin{pmatrix} 1  0  0  1  1  0 \\\\ 0  1  0  1  0  1 \\\\ 0  0  1  0  1  1 \\end{pmatrix} $$\n\nBravo团队的生成矩阵为：\n$$ G_B = \\begin{pmatrix} 1  1  0  0  1  1 \\\\ 0  1  1  1  1  0 \\\\ 1  1  1  1  1  1 \\end{pmatrix} $$\n\n你的任务是确定这两个矩阵是否生成相同的码。如果由一个矩阵生成的所有可能码字的集合与由另一个矩阵生成的所有可能码字的集合相同，则称这两个生成矩阵生成相同的码。以下哪个陈述是正确的？\n\nA. 由 $G_A$ 和 $G_B$ 生成的码是相同的。\n\nB. 由 $G_A$ 和 $G_B$ 生成的码是不同的。\n\nC. 没有足够的信息来确定这些码是否相同。\n\nD. 其中一个或两个矩阵不是 $[6, 3]$ 码的有效生成矩阵。", "solution": "在 $GF(2)$ 上的两个生成矩阵生成相同的线性码，当且仅当它们的行空间相等。等价地，存在一个 $GF(2)$ 上的可逆 $3 \\times 3$ 矩阵 $U$ 使得 $G_{B} = U G_{A}$，或者两个矩阵在 $GF(2)$ 上具有相同的简化行阶梯形（RREF）。\n\nAlpha团队的矩阵是\n$$\nG_{A}=\\begin{pmatrix}\n1  0  0  1  1  0\\\\\n0  1  0  1  0  1\\\\\n0  0  1  0  1  1\n\\end{pmatrix},\n$$\n它已经是系统形式 $[I_{3} \\mid P_{A}]$，其中\n$$\nP_{A}=\\begin{pmatrix}\n1  1  0\\\\\n1  0  1\\\\\n0  1  1\n\\end{pmatrix}.\n$$\n\n在 $GF(2)$ 上对 $G_{B}$ 进行行化简：\n$$\nG_{B}=\\begin{pmatrix}\n1  1  0  0  1  1\\\\\n0  1  1  1  1  0\\\\\n1  1  1  1  1  1\n\\end{pmatrix}.\n$$\n使用 $R_{3} \\leftarrow R_{3}+R_{1}$ 来消去 $R_{3}$ 中第 $1$ 列的元素：\n$$\n\\begin{pmatrix}\n1  1  0  0  1  1\\\\\n0  1  1  1  1  0\\\\\n0  0  1  1  0  0\n\\end{pmatrix}.\n$$\n使用 $R_{1} \\leftarrow R_{1}+R_{2}$ 来消去 $R_{1}$ 中第 $2$ 列的元素：\n$$\n\\begin{pmatrix}\n1  0  1  1  0  1\\\\\n0  1  1  1  1  0\\\\\n0  0  1  1  0  0\n\\end{pmatrix}.\n$$\n使用 $R_{1} \\leftarrow R_{1}+R_{3}$ 和 $R_{2} \\leftarrow R_{2}+R_{3}$ 来消去 $R_{1}$ 和 $R_{2}$ 中第 $3$ 列的元素：\n$$\n\\begin{pmatrix}\n1  0  0  0  0  1\\\\\n0  1  0  0  1  0\\\\\n0  0  1  1  0  0\n\\end{pmatrix}.\n$$\n这是 $G_{B}$ 的简化行阶梯形（RREF），其形式为系统形式 $[I_{3} \\mid P_{B}]$，其中\n$$\nP_{B}=\\begin{pmatrix}\n0  0  1\\\\\n0  1  0\\\\\n1  0  0\n\\end{pmatrix}.\n$$\n\n由于对于给定的行空间，其简化行阶梯形是唯一的，并且 $P_{A} \\neq P_{B}$，所以 $G_{A}$ 和 $G_{B}$ 的行空间不相等。因此，这两个码是不同的。\n\n作为一个直接的一致性检查，由这种形式的 $G_{B}$ 生成的码具有形式为 $[u_{1}, u_{2}, u_{3}, u_{3}, u_{2}, u_{1}]$ 的码字，因为对于任何信息行向量 $u = [u_{1}, u_{2}, u_{3}]$，都有 $u P_{B} = [u_{3}, u_{2}, u_{1}]$。由 $G_{A}$ 生成的码具有码字 $[u_{1}, u_{2}, u_{3}, u_{1}+u_{2}, u_{1}+u_{3}, u_{2}+u_{3}]$。取 $u=[1,0,0]$ 得到 $G_{A}$ 的码字 $[1,0,0,1,1,0]$，这个码字不满足 $G_{B}$ 码字所要求的等式 $c_{6}=c_{1}$。因此，$G_{A}$ 的码包含一个不在 $G_{B}$ 码中的向量，这证实了这两个码是不同的。\n\n两个矩阵都是 $[6,3]$ 码的有效生成矩阵，因为它们都是 $3 \\times 6$ 且秩为 $3$（对于 $G_{A}$，这从其头部的 $I_{3}$ 分块矩阵可以立即看出；对于 $G_{B}$，其 RREF 明确显示了三个主元）。因此，正确的陈述是，由 $G_{A}$ 和 $G_{B}$ 生成的码是不同的。", "answer": "$$\\boxed{B}$$", "id": "1633509"}, {"introduction": "定义了码之后，我们必须能够衡量其性能。本练习 [@problem_id:1633520] 通过使用其校验矩阵，深入探讨了码的检错能力极限。你将计算能够不被检测到的最小比特翻转数，从而对码的最小距离（其最关键的性能指标）有一个具体的理解。", "problem": "在数字通信系统中，信息使用二进制线性分组码进行编码，以防止传输过程中的错误。一个码被定义为一组有效的码字，码字是二进制数字（比特）的向量。这个特定的码是一个 $[n, k]$ 线性码，由其校验矩阵 $H$ 定义。任何传输的码字 $c$ 都必须满足条件 $Hc^T = \\boldsymbol{0}$，其中矩阵乘法在二元域 $\\mathbb{F}_2$ 上进行（即，加法是异或，乘法是与）。\n\n当一个码字 $c$ 通过噪声信道传输时，它可能被接收为一个不同的向量 $y = c + e$，其中 $e$ 是一个非零的错误向量。向量 $e$ 在每个发生比特翻转的位置为 '1'，在其他位置为 '0'。接收器通过计算伴随式向量 $s = Hy^T$ 来检查接收向量 $y$ 的有效性。如果 $s = \\boldsymbol{0}$，接收器假定没有发生错误。因此，如果一个错误模式 $e$ 满足 $He^T = \\boldsymbol{0}$，那么这个错误将不会被检测到。\n\n考虑一个由以下 $3 \\times 6$ 校验矩阵 $H$ 定义的二进制线性码：\n$$\nH = \\begin{pmatrix} \n1  0  0  1  1  0 \\\\\n0  1  0  1  0  1 \\\\\n0  0  1  0  1  1 \n\\end{pmatrix}\n$$\n在一次传输中，可能导致接收器无法检测到的错误模式的最小比特翻转数是多少？", "solution": "当接收到的码字 $y=c+e$ 的伴随式 $s=Hy^{T}=\\boldsymbol{0}$ 时，会发生未被检测到的错误。由于码字满足 $Hc^{T}=\\boldsymbol{0}$，我们有\n$$\ns=H(c+e)^{T}=Hc^{T}+He^{T}=\\boldsymbol{0}+He^{T}=He^{T}.\n$$\n因此，一个错误 $e$ 是不可检测的，当且仅当 $He^{T}=\\boldsymbol{0}$ 且 $e\\neq \\boldsymbol{0}$。能够不被检测到的最小比特翻转数是 $H$ 的零空间中所有非零 $e$ 的最小汉明重量，这等于该码的最小距离。\n\n设 $H$ 的列向量为 $h_{1},\\dots,h_{6}$。在 $\\mathbb{F}_{2}$ 上，条件 $He^{T}=\\boldsymbol{0}$ 意味着由 $e$ 的支撑集索引的列向量之和（异或）为零向量。计算这些列向量：\n$$\nh_{1}=\\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\quad\nh_{2}=\\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\quad\nh_{3}=\\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix},\\quad\nh_{4}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\quad\nh_{5}=\\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\quad\nh_{6}=\\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\n- 重量为1：一个未被检测到的单位比特错误需要某个 $h_{i}=\\boldsymbol{0}$，这种情况没有发生。因此重量为1是不可能的。\n- 重量为2：一个未被检测到的双比特错误需要 $h_{i}+h_{j}=\\boldsymbol{0}$，即 $h_{i}=h_{j}$。所有列向量都是不同的，所以重量为2是不可能的。\n- 重量为3：检查是否有三个向量的和为零。我们有\n$$\nh_{1}+h_{2}=\\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix}=h_{4}\\;\\Rightarrow\\;h_{1}+h_{2}+h_{4}=\\boldsymbol{0}.\n$$\n因此，在位置 $\\{1,2,4\\}$ 上的一个重量为3的错误是不可检测的，所以最小不可检测重量至多为3。结合重量为1和2的不可能性，最小值恰好为3。\n\n因此，能够不被检测到的最小比特翻转数是3。", "answer": "$$\\boxed{3}$$", "id": "1633520"}, {"introduction": "最后的这项挑战 [@problem_id:1633532] 将所有核心概念整合到一个具有独特错误模型的现实解码问题中。你将扮演一名工程师，使用伴随式译码来纠正非简单的比特翻转错误，并直面译码模糊性的实际问题。这个练习展示了理论工具如何被调整以解决特定的现实世界工程约束。", "problem": "在一种新型的高密度磁存储中，数据在写入前使用系统线性分组码进行编码。一个消息，由3比特二进制向量 $m = (m_1, m_2, m_3)$ 表示，使用有限域 $\\mathbb{F}_2$ 上的生成矩阵 $G$ 编码成一个6比特的码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6)$：\n$$ G = \\begin{pmatrix} 1  0  0  1  1  0 \\\\ 0  1  0  0  1  1 \\\\ 0  0  1  1  0  1 \\end{pmatrix} $$\n编码规则为 $c = mG$。所有算术运算都在模2下进行。\n\n这种存储介质的主要失效模式是局部磁场衰减，这会导致一种单一、特定类型的错误事件。这种错误，我们称之为循环相邻对比特翻转（Cyclic Adjacent Pair Flip, CAPF）错误，会同时翻转码字中恰好两个相邻比特的值。邻接关系是循环的，意味着比特 $c_6$ 被认为与比特 $c_1$ 相邻。例如，一个CAPF错误可以翻转比特 $(c_2, c_3)$ 或 $(c_6, c_1)$，但不能翻转 $(c_1, c_3)$。\n\n从存储介质中读取到一个6比特向量 $r = (1, 1, 0, 0, 1, 1)$。假设最多发生一个错误事件（即没有错误或单个CAPF错误），确定所有可能已发送的原始3比特消息 $m$ 的集合。\n\n下列哪个陈述是正确的？\n\nA. 唯一可能的消息是 $(1, 0, 1)$。\n\nB. 唯一可能的消息是 $(1, 1, 0)$。\n\nC. 唯一可能的消息是 $(0, 1, 1)$。\n\nD. 恰好有两个可能的消息：$(1, 0, 1)$ 和 $(1, 1, 0)$。\n\nE. 接收到的向量必定是由于多于一个CAPF错误造成的，因为它与任何单一错误情景都不一致。", "solution": "该问题要求我们对一个具有特定错误模型的信道上的线性码进行译码。对此的标准流程是伴随式译码。\n\n首先，我们需要确定给定线性码的校验矩阵 $H$。生成矩阵 $G$ 以系统形式 $G = [I_k | P]$ 给出，其中 $k=3$ 是消息比特的数量，$I_k$ 是 $k \\times k$ 的单位矩阵。矩阵 $P$ 是构成 $G$ 剩余部分的 $k \\times (n-k)$ 矩阵。这里，$n=6$，所以 $n-k=3$。\n$$ P = \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 1  0  1 \\end{pmatrix} $$\n校验矩阵 $H$ 接着由 $H = [P^T | I_{n-k}]$ 给出，其中 $P^T$ 是 $P$ 的转置。\n$$ P^T = \\begin{pmatrix} 1  0  1 \\\\ 1  1  0 \\\\ 0  1  1 \\end{pmatrix} $$\n因此，校验矩阵 $H$ 是：\n$$ H = \\begin{pmatrix} 1  0  1  1  0  0 \\\\ 1  1  0  0  1  0 \\\\ 0  1  1  0  0  1 \\end{pmatrix} $$\n一个向量 $c$ 是一个有效码字当且仅当 $cH^T = 0$。对于一个接收到的向量 $r = c + e$，其中 $c$ 是发送的码字，$e$ 是错误向量，伴随式 $s$ 计算为 $s = rH^T$。由于 $cH^T=0$，我们有 $s = (c+e)H^T = cH^T + eH^T = eH^T$。伴随式仅取决于错误。\n\n接收到的向量是 $r = (1, 1, 0, 0, 1, 1)$。让我们计算它的伴随式。所有运算都在 $\\mathbb{F}_2$ 中进行。\n$$ s = rH^T = (1, 1, 0, 0, 1, 1) \\begin{pmatrix} 1  1  0 \\\\ 0  1  1 \\\\ 1  0  1 \\\\ 1  0  0 \\\\ 0  1  0 \\\\ 0  0  1 \\end{pmatrix} $$\n让我们计算3比特伴随式向量 $s=(s_1, s_2, s_3)$ 的每个分量：\n$s_1 = 1 \\cdot 1 + 1 \\cdot 0 + 0 \\cdot 1 + 0 \\cdot 1 + 1 \\cdot 0 + 1 \\cdot 0 = 1$\n$s_2 = 1 \\cdot 1 + 1 \\cdot 1 + 0 \\cdot 0 + 0 \\cdot 0 + 1 \\cdot 1 + 1 \\cdot 0 = 1+1+1 = 1$\n$s_3 = 1 \\cdot 0 + 1 \\cdot 1 + 0 \\cdot 1 + 0 \\cdot 0 + 1 \\cdot 0 + 1 \\cdot 1 = 1+1 = 0$\n所以，接收向量的伴随式是 $s = (1, 1, 0)$。由于 $s \\neq (0,0,0)$，接收到的向量不是一个有效的码字，肯定发生了错误。\n\n接下来，我们必须找出我们的错误模型中的哪个（些）错误对应于这个伴随式。可能的单个CAPF错误由权重为2的错误向量表示，其中1位于相邻位置（循环地）。让我们为每个可能的单个错误向量 $e$ 计算伴随式：设 $h_i$ 是 $H$ 的第 $i$ 列。那么翻转比特 $i$ 和 $j$ 的错误的伴随式是 $h_i^T + h_j^T$。\n\n- 无错误: $e_0 = (0,0,0,0,0,0)$, 伴随式 $s_0 = (0,0,0)$。\n- 翻转比特1, 2的错误: $e_1 = (1,1,0,0,0,0)$, 伴随式 $s_1 = h_1^T + h_2^T = (1,1,0) + (0,1,1) = (1,0,1)$。\n- 翻转比特2, 3的错误: $e_2 = (0,1,1,0,0,0)$, 伴随式 $s_2 = h_2^T + h_3^T = (0,1,1) + (1,0,1) = (1,1,0)$。\n- 翻转比特3, 4的错误: $e_3 = (0,0,1,1,0,0)$, 伴随式 $s_3 = h_3^T + h_4^T = (1,0,1) + (1,0,0) = (0,0,1)$。\n- 翻转比特4, 5的错误: $e_4 = (0,0,0,1,1,0)$, 伴随式 $s_4 = h_4^T + h_5^T = (1,0,0) + (0,1,0) = (1,1,0)$。\n- 翻转比特5, 6的错误: $e_5 = (0,0,0,0,1,1)$, 伴随式 $s_5 = h_5^T + h_6^T = (0,1,0) + (0,0,1) = (0,1,1)$。\n- 翻转比特6, 1的错误: $e_6 = (1,0,0,0,0,1)$, 伴随式 $s_6 = h_6^T + h_1^T = (0,0,1) + (1,1,0) = (1,1,1)$。\n\n我们接收向量的伴随式是 $s=(1,1,0)$。从我们的伴随式表中，这匹配了两个可能的错误向量：$e_2 = (0,1,1,0,0,0)$ 和 $e_4 = (0,0,0,1,1,0)$。这意味着译码存在歧义。我们必须找到两个可能的发送码字。纠正后的码字 $\\hat{c}$ 通过 $\\hat{c} = r + e$ 找到。\n\n可能性1：错误是 $e_2 = (0,1,1,0,0,0)$。\n发送的码字将是 $\\hat{c}_1 = r + e_2 = (1,1,0,0,1,1) + (0,1,1,0,0,0) = (1,0,1,0,1,1)$。\n\n可能性2：错误是 $e_4 = (0,0,0,1,1,0)$。\n发送的码字将是 $\\hat{c}_2 = r + e_4 = (1,1,0,0,1,1) + (0,0,0,1,1,0) = (1,1,0,1,0,1)$。\n\n我们现在必须对这两个可能的码字进行译码，以找到原始消息。由于该码是系统码，其生成矩阵为 $G=[I_3 | P]$，原始消息 $m = (m_1, m_2, m_3)$ 对应于码字 $c$ 的前三位。\n\n对于 $\\hat{c}_1 = (1,0,1,0,1,1)$，原始消息是 $m_1 = (1,0,1)$。\n对于 $\\hat{c}_2 = (1,1,0,1,0,1)$，原始消息是 $m_2 = (1,1,0)$。\n\n在单个CAPF错误的假设下，这两种解释都是有效的。因此，存在两个可能的原始消息：$(1,0,1)$ 和 $(1,1,0)$。\n\n将我们的发现与给定的选项进行比较：\nA. 唯一可能的消息是 $(1, 0, 1)$。(不正确，不完整)\nB. 唯一可能的消息是 $(1, 1, 0)$。(不正确，不完整)\nC. 唯一可能的消息是 $(0, 1, 1)$。(不正确)\nD. 恰好有两个可能的消息：$(1, 0, 1)$ 和 $(1, 1, 0)$。(正确)\nE. 接收到的向量必定是由于多于一个CAPF错误造成的... (不正确，我们找到了单一错误的解释)\n\n正确的陈述是 D。", "answer": "$$\\boxed{D}$$", "id": "1633532"}]}