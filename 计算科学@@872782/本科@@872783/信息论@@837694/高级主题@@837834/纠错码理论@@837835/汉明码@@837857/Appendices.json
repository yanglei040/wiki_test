{"hands_on_practices": [{"introduction": "掌握汉明码的第一步是学习如何将原始数据编码为受保护的码字。这个练习将指导你完成一个系统(7,4)汉明码的编码过程，你需要根据给定的信息位计算出正确的奇偶校验位。通过这个实践，你将熟悉汉明码的基本构造原理和模2算术的应用。", "problem": "一个远程环境监测站设计用于从其主传感器传输4位数据包。为了防止在通过噪声信道传输过程中出现单位比特错误，使用了一种系统的(7,4)汉明码来对数据进行编码。\n\n一个待发送的4位消息由向量 $u = [u_1, u_2, u_3, u_4]$ 表示。该消息被编码为一个7位码字 $x = [x_1, x_2, x_3, x_4, x_5, x_6, x_7]$。该编码是系统性的，意味着原始消息位直接嵌入到码字中。具体来说，消息位被放置在第3、5、6和7位，使得 $x_3 = u_1$，$x_5 = u_2$，$x_6 = u_3$ 以及 $x_7 = u_4$。其余的位，$x_1$，$x_2$ 和 $x_4$，是校验位，其计算需要满足一组奇偶校验方程。\n\n所有算术运算都在模2下进行（即在有限域 $GF(2)$ 中，其中 $1+1=0$）。码字 $x$ 必须满足以下三个方程：\n1. $x_1 + x_3 + x_5 + x_7 = 0$\n2. $x_2 + x_3 + x_6 + x_7 = 0$\n3. $x_4 + x_5 + x_6 + x_7 = 0$\n\n该监测站需要传输与消息向量 $u = [1, 1, 0, 1]$ 对应的传感器读数。确定被传输的完整的7位码字 $x$。请将您的答案表示为一个7元素的行向量。", "solution": "我们使用给定的消息位到码字的系统性放置规则：$x_{3}=u_{1}$，$x_{5}=u_{2}$，$x_{6}=u_{3}$，$x_{7}=u_{4}$。对于 $u=[1,1,0,1]$，这给出 $x_{3}=1$，$x_{5}=1$，$x_{6}=0$，$x_{7}=1$。\n\n所有运算都在 $GF(2)$ 中进行，因此加法是模2加法。奇偶校验方程为：\n$$x_{1}+x_{3}+x_{5}+x_{7}=0,$$\n$$x_{2}+x_{3}+x_{6}+x_{7}=0,$$\n$$x_{4}+x_{5}+x_{6}+x_{7}=0.$$\n\n对每个方程求解校验位（利用在 $GF(2)$ 中减法等于加法），我们有：\n$$x_{1}=x_{3}+x_{5}+x_{7}=1+1+1=1,$$\n$$x_{2}=x_{3}+x_{6}+x_{7}=1+0+1=0,$$\n$$x_{4}=x_{5}+x_{6}+x_{7}=1+0+1=0.$$\n\n因此，完整的码字，按 $[x_{1},x_{2},x_{3},x_{4},x_{5},x_{6},x_{7}]$ 顺序排列，是 $[1,0,1,0,1,0,1]$。", "answer": "$$\\boxed{\\begin{pmatrix}1  0  1  0  1  0  1\\end{pmatrix}}$$", "id": "1627892"}, {"introduction": "编码的目的是为了在数据传输后能够检测和纠正错误。在这个练习中，你将扮演接收者的角色，对一个可能在传输过程中发生单个比特错误的汉明码字进行解码。你将学习如何计算“综合症” (syndrome) 并利用它来精确定位和纠正错误，从而恢复原始的正确码字。", "problem": "一艘深空探测器使用一种系统化的二元(7,4)汉明码来保护其遥测数据免受宇宙射线的破坏。在这种编码方案中，一个4比特的消息被编码成一个7比特的码字，形式为 $(d_1, d_2, d_3, d_4, p_1, p_2, p_3)$，其中 $d_i$是原始数据比特，$p_j$是奇偶校验比特。\n\n数据比特和校验比特之间的关系由该码的奇偶校验矩阵 $H$ 定义，使得对于任何有效的码字 $c$，乘积 $Hc^T$ 为零向量（所有计算都在模2下进行）。该特定码的奇偶校验矩阵如下：\n$$\nH = \\begin{pmatrix}\n1  1  0  1  1  0  0 \\\\\n1  0  1  1  0  1  0 \\\\\n0  1  1  1  0  0  1\n\\end{pmatrix}\n$$\n在一次传输过程中，一个地面站接收到二元向量 $r = (0, 1, 1, 0, 1, 0, 1)$。已知在传输过程中，由于高能粒子撞击，最多只有一个比特被翻转。确定探测器传输的原始7比特码字。\n\n将您的答案表示为一个7元素的行矩阵。", "solution": "我们在域 $GF(2)$ 上进行计算。对于任何接收到的向量 $r$，其综合症为 $s = Hr^T$，并且在最多只有一个比特错误的情况下，非零的综合症等于 $H$ 中对应于错误位置的列。\n\n接收到的向量是 $r = (0,1,1,0,1,0,1)$。设 $H$ 的列为\n$$\nh_{1} = \\begin{pmatrix}1\\\\1\\\\0\\end{pmatrix},\\;\nh_{2} = \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix},\\;\nh_{3} = \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix},\\;\nh_{4} = \\begin{pmatrix}1\\\\1\\\\1\\end{pmatrix},\\;\nh_{5} = \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix},\\;\nh_{6} = \\begin{pmatrix}0\\\\1\\\\0\\end{pmatrix},\\;\nh_{7} = \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix}.\n$$\n那么综合症计算如下：\n$$\ns = H r^{T} = \\sum_{i=1}^{7} r_{i} h_{i} = r_{2} h_{2} + r_{3} h_{3} + r_{5} h_{5} + r_{7} h_{7}\n= \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix} + \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\1\\\\1\\end{pmatrix}.\n$$\n这等于 $h_{3}$，因此单个比特错误发生在位置3。所以，通过翻转 $r$ 的第三个比特，可以得到发送的码字 $c$：\n$$\nc = (0,1,0,0,1,0,1).\n$$\n验证：\n$$\nH c^{T} = r_{2} h_{2} + r_{5} h_{5} + r_{7} h_{7} = \\begin{pmatrix}1\\\\0\\\\1\\end{pmatrix} + \\begin{pmatrix}1\\\\0\\\\0\\end{pmatrix} + \\begin{pmatrix}0\\\\0\\\\1\\end{pmatrix} = \\begin{pmatrix}0\\\\0\\\\0\\end{pmatrix},\n$$\n因此 $c$ 是一个有效的码字。", "answer": "$$\\boxed{\\begin{pmatrix}0  1  0  0  1  0  1\\end{pmatrix}}$$", "id": "1649638"}, {"introduction": "虽然汉明码能完美地纠正单个比特的错误，但当错误数量超出其设计能力时会发生什么呢？这个练习将模拟一个发生了两个比特错误的场景。通过计算综合症并观察解码器如何错误地“纠正”一个不相关的比特，你将深刻理解汉明码的纠错极限及其被称为“完美码”的内在含义。", "problem": "一个通信系统使用一种系统(7,4)汉明码来传输4比特的数据字。一个7比特码字 $c = (c_1, c_2, c_3, c_4, c_5, c_6, c_7)$ 由一个4比特数据字构成，其比特被放置在码字的位置3、5、6和7。计算出三个校验比特并放置在位置1、2和4。因此，码字比特排列为 $c = (p_1, p_2, d_1, p_3, d_2, d_3, d_4)$，其中 $p_1, p_2, p_3$ 是校验比特。校验比特使用以下偶校验方程计算，其中 $\\oplus$ 表示异或运算：\n$p_1 \\oplus d_1 \\oplus d_2 \\oplus d_4 = 0$\n$p_2 \\oplus d_1 \\oplus d_3 \\oplus d_4 = 0$\n$p_3 \\oplus d_2 \\oplus d_3 \\oplus d_4 = 0$\n\n在接收到一个7比特字 $y = (y_1, y_2, y_3, y_4, y_5, y_6, y_7)$ 后，接收器按如下方式计算一个3比特的综合症 $s = (s_1, s_2, s_3)$：\n$s_1 = y_4 \\oplus y_5 \\oplus y_6 \\oplus y_7$\n$s_2 = y_2 \\oplus y_3 \\oplus y_6 \\oplus y_7$\n$s_3 = y_1 \\oplus y_3 \\oplus y_5 \\oplus y_7$\n\n该解码系统设计用于纠正最多一个比特的错误。如果综合症 $s$ 为 $(0,0,0)$，则该字被认为是正确的。如果 $s$ 非零，它将被解释为单个错误比特位置的二进制表示，其中 $s_1$ 为最高有效位。例如，综合症 $(1,0,1)$ 表示比特位置5存在错误。解码器随后会翻转所指示位置的比特以尝试纠正。\n\n假设位置为 $(3, 5, 6, 7)$ 且比特值为 $(1, 0, 1, 1)$ 的4比特数据字被编码成其对应的码字 $c$。在传输过程中，码字被损坏，导致位置3和6的比特被翻转。接收器的单错误纠正解码器将识别出的错误比特位置是哪一个？", "solution": "该码是一种系统汉明码，数据比特 $(d_1, d_2, d_3, d_4)$ 放置在位置 $3,5,6,7$，校验比特 $(p_1, p_2, p_3)$ 放置在位置 $1,2,4$。偶校验方程如下：\n$$p_{1} \\oplus d_{1} \\oplus d_{2} \\oplus d_{4} = 0,$$\n$$p_{2} \\oplus d_{1} \\oplus d_{3} \\oplus d_{4} = 0,$$\n$$p_{3} \\oplus d_{2} \\oplus d_{3} \\oplus d_{4} = 0.$$\n对于数据比特 $(d_1, d_2, d_3, d_4)=(1,0,1,1)$，求解校验比特如下：\n$$p_{1} = d_{1} \\oplus d_{2} \\oplus d_{4} = 1 \\oplus 0 \\oplus 1 = 0,$$\n$$p_{2} = d_{1} \\oplus d_{3} \\oplus d_{4} = 1 \\oplus 1 \\oplus 1 = 1,$$\n$$p_{3} = d_{2} \\oplus d_{3} \\oplus d_{4} = 0 \\oplus 1 \\oplus 1 = 0.$$\n因此，传输的码字为 $c = (p_1, p_2, d_1, p_3, d_2, d_3, d_4) = (0,1,1,0,0,1,1)$。\n在传输过程中，位置3和6的比特被翻转，得到的接收字为\n$$y=(0,1,0,0,0,0,1).$$\n综合症计算如下：\n$$s_{1}=y_{4} \\oplus y_{5} \\oplus y_{6} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1,$$\n$$s_{2}=y_{2} \\oplus y_{3} \\oplus y_{6} \\oplus y_{7}=1 \\oplus 0 \\oplus 0 \\oplus 1=0,$$\n$$s_{3}=y_{1} \\oplus y_{3} \\oplus y_{5} \\oplus y_{7}=0 \\oplus 0 \\oplus 0 \\oplus 1=1.$$\n因此综合症 $s=(s_{1},s_{2},s_{3})=(1,0,1)$，其中 $s_{1}$ 为最高有效位，该值是位置5的二进制表示。因此，单错误纠正解码器将比特位置5识别为错误位置。", "answer": "$$\\boxed{5}$$", "id": "1373639"}]}