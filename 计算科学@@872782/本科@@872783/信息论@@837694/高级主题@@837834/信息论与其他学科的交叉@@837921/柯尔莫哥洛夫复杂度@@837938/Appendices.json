{"hands_on_practices": [{"introduction": "第一个练习旨在探索柯氏复杂性的一个基本性质。通过分析一个重复字符串 $xx$ 的复杂性，我们将理解算法信息内容如何处理冗余数据。这个实践 [@problem_id:1429018] 为我们奠定了一个基础：柯氏复杂性衡量的是核心信息，而不仅仅是数据的长度。", "problem": "在算法信息论（理论计算机科学的一个子领域）中，我们用一个对象的最短可能描述的长度来量化其复杂度。对于一个有限二进制字符串 $x$，其柯尔莫哥洛夫复杂度，记作 $K(x)$，是相对于一个固定的通用图灵机 $U$ 来定义的。它是最短程序 $p$ 的长度（以比特为单位），该程序在作为输入提供给 $U$ 时，会使 $U$ 输出字符串 $x$ 然后停机。形式上，$K(x) = \\min\\{|p| : U(p)=x\\}$。虽然 $K(x)$ 的确切值取决于所选择的通用图灵机 $U$，但复杂度理论中的关键关系，例如上界和下界，在一个加法常数的范围内是成立的。\n\n考虑一个数据处理任务，其中一个二进制字符串 $x$ 与其自身连接，形成一个新的字符串 $xx$。这是数据冗余的一个简单模型。我们关心这个新的、更长的字符串的复杂度。\n\n对于任意二进制字符串 $x$，下列哪个不等式表示了字符串 $xx$ 的柯尔莫哥洛夫复杂度的最紧一般上界？在这些表达式中，$c$ 代表一个正常数，其值仅取决于通用图灵机 $U$ 的选择，而不取决于字符串 $x$ 或其属性。\n\nA. $K(xx) \\le K(x) + c$\n\nB. $K(xx) \\le 2K(x) + c$\n\nC. $K(xx) \\le K(x)^2 + c$\n\nD. $K(xx) \\le K(x) + c \\log_2(|x|)$\n\nE. $K(xx) \\le |x| + c$", "solution": "设 $U$ 为一固定的通用图灵机，$K(\\cdot)$ 为相关的柯尔莫哥洛夫复杂度（非前缀码版本）。对于任何一个可由算法计算的函数 $f$，存在一个仅取决于 $f$ 和 $U$ 的常数 $c_f$，使得对于所有输入 $x$ 都有：\n$$\nK(f(x)) \\leq K(x) + c_{f}\n$$\n这个标准上界的直观解释是：我们可以构建一个新程序，它首先使用生成 $x$ 的最短程序（长度为 $K(x)$）来得到 $x$，然后再执行计算函数 $f$ 的固定指令（长度为 $c_f$）来得到 $f(x)$。整个过程的描述长度即为 $K(x) + c_f$。\n\n将此结论应用于字符串复制函数 $f(y)=yy$。由于这个函数是可计算的，因此存在一个常数 $c$ 使得：\n$$\nK(xx) \\leq K(x) + c\n$$\n\n这个界限在相差一个加法常数的意义下是紧的。我们可以定义一个函数 $g(z)$，它返回字符串 $z$ 的前半部分。显然，$g$ 也是可计算的，且 $g(xx)=x$。根据同样的推理，存在另一个常数 $c'$ 使得：\n$$\nK(x) \\leq K(xx) + c'\n$$\n因此 $K(xx) \\geq K(x) - c'$。结合上界和下界，我们得出在一般情况下 $K(xx) = K(x) \\pm O(1)$。\n\n在给定的选项中，A 选项是可能的最紧一般上界；选项 B、C、D 和 E 都更宽松，因为它们分别引入了额外的 $K(x)$ 项、一个二次项、一个随 $|x|$ 增长的对数项，或者用通常远大于 $K(x)$ 的 $|x|$ 来代替它。", "answer": "$$\\boxed{A}$$", "id": "1429018"}, {"introduction": "从简单的字符串转向结构化数据，这个问题要求我们思考一个图的复杂性。我们将分析一个简单路径图的邻接矩阵，它可能是一个非常庞大的对象。这个练习 [@problem_id:1635719] 展示了柯氏复杂性的一个关键应用：揭示那些看似庞大但高度有序的对象的内在简单性和可压缩性。", "problem": "在算法信息论中，一个对象（如一段文本或一幅图像）的 Kolmogorov 复杂度是指定它所需的计算资源的度量。形式上，一个有限二进制字符串 $s$ 的 Kolmogorov 复杂度，记作 $K(s)$，是在一个固定的通用编程语言中，能输出字符串 $s$ 然后停机的最短计算机程序的长度。我们感兴趣的是估计一个来自图论的高度结构化对象的这种复杂度。\n\n考虑一个简单路径图 $P_n$，它定义在一组 $n$ 个标记为 $v_1, v_2, \\dots, v_n$ 的顶点上。该图的边恰好是集合 $\\{(v_i, v_{i+1}) \\mid i = 1, 2, \\dots, n-1\\}$。该图的结构可以由其 $n \\times n$ 邻接矩阵 $A$ 完全描述，其中如果顶点 $v_i$ 和 $v_j$ 之间存在一条边，则元素 $A_{ij}$ 为 1，否则为 0。\n\n为分析该矩阵的复杂度，我们将其表示为一个长度为 $n^2$ 的单一二进制字符串 $s_A$。该字符串通过按顺序拼接矩阵的行（从第 1 行到第 $n$ 行）而形成。\n\n你的任务是提供一个简单的、封闭形式的解析表达式，作为当 $n$ 很大时 Kolmogorov 复杂度 $K(s_A)$ 的一个紧上界。你的答案应捕捉到该复杂度的主要渐近行为。用 $n$ 和一个代表生成程序固定长度的通用常数 $C$ 来表示你的答案。就本题而言，你可以假设指定整数 $n$ 所需的比特数是 $\\log_2(n)$。", "solution": "我们构造一个显式的短程序，该程序输出编码了路径图 $P_{n}$ 的 $n \\times n$ 邻接矩阵的二进制字符串 $s_{A}$，然后界定其长度。\n\n1) 构造性上界。考虑一个固定算法，该算法在给定二进制的 $n$ 后，通过遍历所有满足 $1 \\leq i,j \\leq n$ 的有序对 $(i,j)$ 来输出 $s_{A}$，当且仅当 $j=i+1$ 或 $i=j+1$ 时写入 1，否则写入 0；行按从 $i=1$ 到 $i=n$ 的顺序输出，每行内的列按从 $j=1$ 到 $j=n$ 的顺序输出。这个算法对于所有 $n$ 都是相同的，所以其描述长度是一个与 $n$ 无关的常数；将此常数记为 $C$。为了将此程序特化到特定的 $n$，我们将 $n$ 的二进制表示直接硬编码到源代码中。根据指定整数 $n$ 需要 $\\log_{2}(n)$ 比特的假设，该程序的总长度为\n$$\nC+\\log_{2}(n),\n$$\n这给出了 Kolmogorov 复杂度的上界\n$$\nK(s_{A}) \\leq C+\\log_{2}(n).\n$$\n\n2) 在加法常数意义下的渐近紧性。令 $\\ell(s_{A})$ 表示字符串 $s_{A}$ 的长度。对于 $P_{n}$，有 $\\ell(s_{A})=n^{2}$。存在一个固定的解码器（其描述长度为常数，与 $n$ 无关），该解码器在给定 $s_{A}$ 的情况下，通过 $n=\\sqrt{\\ell(s_{A})}$ 计算出 $n$ 并输出该整数。因此，\n$$\nK(n) \\leq K(s_{A}) + O(1).\n$$\n根据题目的假设，指定 $n$ 需要 $\\log_{2}(n)$ 比特，所以 $K(n) \\geq \\log_{2}(n) - O(1)$。结合这些可得\n$$\nK(s_{A}) \\geq \\log_{2}(n) - O(1).\n$$\n结合构造性上界，这表明主要渐近行为是 $\\Theta(\\log_{2}(n))$，并且简单的封闭形式紧上界（将所有常数开销吸收到 $C$ 中）是\n$$\nK(s_{A}) \\leq C+\\log_{2}(n).\n$$", "answer": "$$\\boxed{C+\\log_{2}(n)}$$", "id": "1635719"}, {"introduction": "在了解了结构如何被压缩之后，我们现在提出一个更广泛的问题：可压缩性到底有多普遍？这个实践运用简单的计数论证，得出了一个关于数据本质的深刻结论。通过计算无法被显著压缩的字符串所占的比例 [@problem_id:1635770]，你将发现一个基本原理：大多数字符串在算法上是随机的，也是不可压缩的。", "problem": "在数据压缩的理论研究中，我们分析二进制串的性质。考虑所有可能的长度为 $n=128$ 的二进制串的集合。一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记作 $K(s)$，被定义为能够生成 $s$ 作为输出然后停机的最短计算机程序的长度（以比特为单位）。这个值代表了该字符串无损压缩的最终极限。\n\n如果一个字符串 $s$ 的柯尔莫哥洛夫复杂度小于其长度，我们可以将其定义为“可压缩的”。对于本问题，如果一个长度为 $n=128$ 的字符串 $s$ 的复杂度 $K(s)$ 满足不等式 $K(s) \\leq 118$，我们将其定义为“高度可压缩的”。\n\n基于一个基本原则，即对于任意给定的整数长度 $k$，最多存在 $2^k$ 个该长度的不同程序，请计算长度为 128 的二进制串中*不*是高度可压缩的串所占的最小可能比例。将你的答案表示为保留五位有效数字的小数。", "solution": "目标是求长度为 $n=128$ 的二进制串中不属于“高度可压缩”的串所占的最小比例。一个字符串 $s$ 被定义为高度可压缩的，如果其柯尔莫哥洛夫复杂度 $K(s) \\leq 118$。因此，如果 $K(s)  118$，则该字符串不是高度可压缩的。\n\n首先，让我们确定长度为 $n=128$ 的不同二进制串的总数。由于字符串中的 128 个位置每个都可以是 0 或 1，因此可能的字符串总数为 $2^{128}$。\n\n接下来，我们需要找到高度可压缩字符串数量的上限。一个字符串 $s$ 是高度可压缩的，如果 $K(s) \\leq 118$。这意味着存在一个长度为 $k \\leq 118$ 比特的程序可以生成 $s$。我们可以计算这类程序的总数。\n\n程序本身就是一个二进制串。特定长度 $k$ 的可能程序数量为 $2^k$。为了找到长度小于或等于 118 的程序总数，我们将从 $k=0$ 到 $k=118$ 的每个可能长度的程序数量相加。\n设 $N_{programs}$ 是长度 $k \\leq 118$ 的程序的总数。\n$$ N_{programs} = \\sum_{k=0}^{118} 2^k $$\n这是一个几何级数。几何级数 $\\sum_{i=0}^{m} r^i$ 的和由公式 $\\frac{r^{m+1}-1}{r-1}$ 给出。在我们的例子中，$r=2$ 且 $m=118$。\n$$ N_{programs} = \\frac{2^{118+1}-1}{2-1} = 2^{119} - 1 $$\n所以，长度为 118 比特或更短的不同程序最多有 $2^{119} - 1$ 个。\n\n这些短程序中的每一个最多只能生成一个唯一的输出字符串。因此，可以由这些程序生成的字符串数量也最多为 $2^{119} - 1$。这给了我们高度可压缩字符串数量的一个上限。设 $N_{comp}$ 为高度可压缩字符串的数量。\n$$ N_{comp} \\leq 2^{119} - 1 $$\n高度可压缩字符串的最大可能数量是 $2^{119} - 1$。\n\n问题要求的是*不*是高度可压缩的字符串所占的最小比例。设 $N_{not\\_comp}$ 为不是高度可压缩的字符串的数量。\n$$ N_{not\\_comp} = (\\text{字符串总数}) - N_{comp} $$\n为了找到 $N_{not\\_comp}$ 的最小值，我们必须减去 $N_{comp}$ 的最大可能值。\n$$ N_{not\\_comp, min} = 2^{128} - (2^{119} - 1) $$\n最小比例 $f_{min}$ 是这个最小数量除以字符串总数。\n$$ f_{min} = \\frac{N_{not\\_comp, min}}{2^{128}} = \\frac{2^{128} - (2^{119} - 1)}{2^{128}} $$\n我们可以拆分这个分数：\n$$ f_{min} = \\frac{2^{128}}{2^{128}} - \\frac{2^{119}}{2^{128}} + \\frac{1}{2^{128}} $$\n$$ f_{min} = 1 - 2^{119-128} + 2^{-128} $$\n$$ f_{min} = 1 - 2^{-9} + 2^{-128} $$\n现在我们来计算这个表达式的数值。\n$$ 2^9 = 512 $$\n$$ 2^{-9} = \\frac{1}{512} = 0.001953125 $$\n项 $2^{-128}$ 非常小（大约是 $2.9 \\times 10^{-39}$），不会影响我们结果的前几位有效数字。所以我们有：\n$$ f_{min} \\approx 1 - 0.001953125 = 0.998046875 $$\n最后，我们需要将此结果四舍五入到五位有效数字。前五位有效数字是 9、9、8、0 和 4。第六位数字是 6，大于或等于 5，所以我们将第五位有效数字（4）向上取整为 5。\n$$ f_{min} \\approx 0.99805 $$\n这个结果表明，绝大多数字符串不能被显著压缩，因为它们的最短描述几乎与字符串本身一样长。", "answer": "$$\\boxed{0.99805}$$", "id": "1635770"}]}