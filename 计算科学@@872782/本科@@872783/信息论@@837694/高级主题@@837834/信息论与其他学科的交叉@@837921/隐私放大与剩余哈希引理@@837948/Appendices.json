{"hands_on_practices": [{"introduction": "在我们进行隐私放大之前，首要任务是量化我们原始数据中固有的不可预测性。最小熵（Min-entropy）正是为此目的而设计的关键度量，它衡量了攻击者猜中原始密钥的最优策略的成功概率。这个练习将通过一个有缺陷的密钥生成过程的具体例子，帮助你掌握最小熵的计算，并直观地理解数据中的结构性缺陷是如何降低其随机性的。[@problem_id:1647791]", "problem": "一个密码协议依赖于一个能生成 $n$ 比特密钥的源，其中 $n$ 是一个正偶数。实现中的一个缺陷导致密钥生成过程按如下方式进行：一个长度为 $n/2$ 比特的字符串被均匀随机地选择，并且该字符串构成了密钥的前半部分。密钥的后半部分接着被设置为前半部分的一个精确副本。由此产生的 $n$ 比特密钥由随机变量 $X$ 表示。\n\n离散随机变量 $Y$ 的最小熵定义为 $H_{\\infty}(Y) = -\\log_{2}(\\max_{y} P(Y=y))$，其中最大化是在变量 $Y$ 的所有可能结果 $y$ 上进行的。该度量是衡量攻击者单次猜测成功概率的一个关键指标。\n\n计算随机变量 $X$ 的最小熵。请用比特表示你的答案，并将其表示为 $n$ 的函数。", "solution": "设 $n$ 是一个正偶数。该过程从 $\\{0,1\\}^{n/2}$ 中均匀随机地选择一个长度为 $n/2$ 的字符串 $w$，并输出 $n$ 比特的字符串 $X = ww$。因此，$X$ 的支撑集是集合\n$$\nS = \\{ ww : w \\in \\{0,1\\}^{n/2} \\},\n$$\n其基数为\n$$\n|S| = 2^{n/2}.\n$$\n因为 $w$ 是均匀选择的，并且确定性地映射到 $ww$，所以 $X$ 在 $S$ 上是均匀分布的。因此，对于任何 $x \\in S$，\n$$\nP(X = x) = \\frac{1}{2^{n/2}},\n$$\n而对于任何 $x \\notin S$，$P(X = x) = 0$。因此，任何结果的最大概率是\n$$\n\\max_{x} P(X = x) = \\frac{1}{2^{n/2}}.\n$$\n根据最小熵的定义，\n$$\nH_{\\infty}(X) = -\\log_{2}\\!\\left( \\max_{x} P(X = x) \\right) = -\\log_{2}\\!\\left( 2^{-n/2} \\right) = \\frac{n}{2}.\n$$\n因此，$X$ 的最小熵为 $\\frac{n}{2}$ 比特。", "answer": "$$\\boxed{\\frac{n}{2}}$$", "id": "1647791"}, {"introduction": "有了一个带有最小熵的随机源后，我们需要一个强大的工具来从中提取出一个更短、更安全的密钥，这个工具就是2-万有哈希函数族。剩余哈希引理的威力正依赖于这类哈希函数的良好“混合”特性，即它们能显著降低冲突概率。这个练习将引导你分析一种常见且构造简单的线性哈希函数族，并证明其关键的通用性属性，从而让你深入理解隐私放大工具箱的核心部件。[@problem_id:1647784]", "problem": "在密码学和信息论领域，2-万有哈希函数族是隐私放大等任务的关键工具。这样的哈希族能够将长数据字符串映射为较短的、固定长度的字符串，并以最小化任何两个不同输入的碰撞的方式进行。\n\n考虑一个简单的线性哈希函数族 $\\mathcal{H}$，它被设计用来将 $n$ 位二进制字符串映射到 $m$ 位二进制字符串，其中 $n > m$。所有算术运算都在含两个元素的伽罗瓦域（记作 $\\mathrm{GF}(2)$）上进行，其中加法对应于按位异或（XOR）运算，乘法对应于按位与（AND）运算。\n\n一个特定的哈希函数 $h_A \\in \\mathcal{H}$ 由一个 $m \\times n$ 的矩阵 $A$ 决定，其元素独立且均匀地从 $\\{0, 1\\}$ 中随机选取。一个输入，表示为 $n$ 位字符串，被视为一个 $n \\times 1$ 的列向量 $x$。该函数通过矩阵-向量乘积计算哈希值：\n$$h_A(x) = Ax$$\n结果 $h_A(x)$ 是一个 $m \\times 1$ 的列向量，表示 $m$ 位的输出字符串。\n\n假设通过均匀随机地选择矩阵 $A$ 来从该族中选取一个哈希函数 $h_A$。对于任意两个不同的 $n$ 位输入向量 $x_1$ 和 $x_2$，确定它们的哈希值相同的概率。请用一个关于 $m$ 的数学表达式来表示你的答案。", "solution": "令 $x_{1},x_{2} \\in \\{0,1\\}^{n}$ 且 $x_{1} \\neq x_{2}$，并令 $A$ 为一个在 $\\mathrm{GF}(2)$ 上的 $m \\times n$ 随机矩阵，其元素独立且均匀地分布在 $\\{0,1\\}$ 中。在 $\\mathrm{GF}(2)$ 中定义非零差分向量 $d = x_{1} + x_{2}$，因此 $d \\neq 0$。\n\n碰撞事件 $h_{A}(x_{1}) = h_{A}(x_{2})$ 满足\n$$\nh_{A}(x_{1}) = h_{A}(x_{2})\n\\;\\;\\Longleftrightarrow\\;\\;\nA x_{1} = A x_{2}\n\\;\\;\\Longleftrightarrow\\;\\;\nA(x_{1}+x_{2}) = 0\n\\;\\;\\Longleftrightarrow\\;\\;\nA d = 0.\n$$\n\n将 $A$ 的行记作 $r_{1}^{\\top},\\dots,r_{m}^{\\top} \\in \\{0,1\\}^{n}$。那么 $A d = 0$ 当且仅当对于所有的 $i=1,\\dots,m$，$r_{i}^{\\top} d = 0$ 在 $\\mathrm{GF}(2)$ 中成立。对于一个固定的非零 $d$，考虑单个随机行 $r$。点积 $r^{\\top} d = \\sum_{j=1}^{n} r_{j} d_{j}$ 是在 $\\mathrm{GF}(2)$ 中计算的。由于 $d \\neq 0$，存在一个索引 $j^{*}$ 使得 $d_{j^{*}}=1$。在给定所有坐标 $\\{r_{j}\\}_{j \\neq j^{*}}$ 的条件下，$r^{\\top} d$ 的值在 $\\mathrm{GF}(2)$ 中等于 $b + r_{j^{*}}$，其中 $b \\in \\{0,1\\}$ 是某个固定的值。因为 $r_{j^{*}}$ 在 $\\{0,1\\}$ 中是均匀分布的，并且独立于其他坐标，所以可以得出\n$$\n\\Pr(r^{\\top} d = 0) = \\frac{1}{2}.\n$$\n\n由于行 $r_{1},\\dots,r_{m}$ 是相互独立的，所以事件 $\\{r_{i}^{\\top} d = 0\\}$ 也是相互独立的，因此\n$$\n\\Pr(A d = 0) = \\prod_{i=1}^{m} \\Pr(r_{i}^{\\top} d = 0) = \\left(\\frac{1}{2}\\right)^{m} = 2^{-m}.\n$$\n\n因此，对于任意两个不同的输入 $x_{1}$ 和 $x_{2}$，在随机选择矩阵 $A$ 的情况下，$h_{A}(x_{1}) = h_{A}(x_{2})$ 的概率是 $2^{-m}$。", "answer": "$$\\boxed{2^{-m}}$$", "id": "1647784"}, {"introduction": "现在，我们将最小熵和2-万有哈希这两个概念结合起来，解决一个现实世界中的密码学工程问题。假设我们有一个已知最小熵的原始密钥源，并计划使用2-万有哈希函数进行隐私放大，那么我们需要多高的原始熵才能生成一个满足特定安全标准的最终密钥呢？这个练习将让你直接应用剩余哈希引理的保证，将理论与实际系统设计参数（如密钥长度和安全级别）联系起来，从而巩固你对整个隐私放大过程的理解。[@problem_id:1647754]", "problem": "一位密码学工程师的任务是为一个安全通信系统设计隐私放大模块。该模块处理一个已被部分泄露的原始密钥，以生成一个更短、高度安全的最终密钥。\n\n原始密钥表示为一个随机变量 $X$，其初始不确定性由其最小熵 $k$ 来量化，单位为比特。该系统使用一个随机选择的2-万有哈希函数将原始密钥转换为长度为 $m$ 的最终密钥。这个最终密钥的安全性由一个参数 $\\epsilon$ 保证，该参数表示其与一个真正随机字符串的统计可区分性。$\\epsilon$ 的值越低，表示密钥越安全。所选隐私放大协议的理论安全保证由以下不等式给出：\n$$ \\epsilon \\le \\frac{1}{2} 2^{(m-k)/2} $$\n该系统必须生成一个长度为 $m=64$ 比特的最终密钥。为了使密钥在其预期应用中被认为是密码学安全的，安全参数必须满足条件 $\\epsilon \\le 2^{-20}$。\n\n为确保系统设计正确，请确定原始密钥必须拥有的最小熵 $k$ 的最小整数值，以满足这些安全性和输出长度的要求。", "solution": "我们已知，一个使用2-万有哈希函数的隐私放大协议保证\n$$ \\epsilon \\le \\frac{1}{2} 2^{(m - k)/2}. $$\n为确保最终密钥在输出长度为 $m = 64$ 时满足设计要求 $\\epsilon \\le 2^{-20}$，我们只需要求其上界至多为 $2^{-20}$：\n$$ \\frac{1}{2} 2^{(64 - k)/2} \\le 2^{-20}. $$\n不等式两边均为正数，且 $\\log_{2}$ 是严格递增函数，因此我们对两边取 $\\log_{2}$：\n$$ \\log_{2}\\!\\left(\\frac{1}{2} 2^{(64 - k)/2}\\right) \\le \\log_{2}\\!\\left(2^{-20}\\right). $$\n计算两边可得\n$$ -1 + \\frac{64 - k}{2} \\le -20. $$\n逐步整理不等式：\n$$ \\frac{64 - k}{2} \\le -19, $$\n$$ 64 - k \\le -38, $$\n$$ -k \\le -102, $$\n$$ k \\ge 102. $$\n由于 $k$ 必须是整数，满足该要求的最小整数值为 $k = 102$。", "answer": "$$\\boxed{102}$$", "id": "1647754"}]}