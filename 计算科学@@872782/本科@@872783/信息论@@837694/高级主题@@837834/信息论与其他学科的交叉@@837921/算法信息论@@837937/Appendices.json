{"hands_on_practices": [{"introduction": "算法信息论的核心思想是，一个字符串的复杂性并非由其长度决定，而是由描述它的最短程序的长度来衡量。一个看似很长但高度重复的字符串，例如由 $n$ 个“1”组成的字符串，实际上可能非常简单。这个练习 [@problem_id:1602461] 将引导你探索这种结构化字符串的柯尔莫哥洛夫复杂性，并揭示其复杂性是如何依赖于其底层模式（即重复次数 $n$）的复杂性，而不是其自身的物理长度。", "problem": "在算法信息论中，一个字符串 $x$ 的柯尔莫哥洛夫复杂度，记作 $K(x)$，被定义为能够生成 $x$ 作为其输出然后停机的最短计算机程序的长度。这个长度以比特为单位进行度量。这个概念提供了一个字符串所含信息量或“不可压缩性”的基本度量。我们假设使用一个固定的、最优的、通用的描述语言（类似于通用图灵机），这确保了复杂度值在相差一个加性常数的范围内是良定义的。\n\n考虑一个字符串 $s_n$，它由字符 '1' 重复 $n$ 次组成，其中 $n$ 是一个正整数。例如，$s_4$ 是字符串 '1111'。令 $K(s_n)$ 表示字符串 $s_n$ 的柯尔莫哥洛夫复杂度。令 $K(n)$ 表示整数 $n$ 本身的柯尔莫哥洛夫复杂度（形式上，是输出 $n$ 的标准二进制表示的最短程序的长度）。\n\n对于所有正整数 $n$，以下哪个方程最准确地描述了 $K(s_n)$ 和 $K(n)$ 之间的关系？在这些选项中，$c$，$c_1$ 和 $c_2$ 表示与 $n$ 无关的正数常量。\n\nA. $K(s_n) = n \\cdot c_1 + c_2$\n\nB. $K(s_n) = K(n) + c$\n\nC. $K(s_n) = n + c$\n\nD. $K(s_n) = \\log_2(n) + c$\n\nE. $K(s_n) = c \\cdot K(n)", "solution": "我们使用一个固定的最优通用描述语言。根据定义，$K(x)$ 是输出 $x$ 并停机的最短程序的长度。\n\n上界：\n令 $p_{n}$ 是一个输出 $n$ 的标准二进制表示的最短程序，因此 $|p_{n}|=K(n)$。构建一个固定的包装程序 $W$（与 $n$ 无关），当执行时，它在硬编码的 $p_{n}$ 上模拟通用机以获得 $n$，然后精确地打印字符 '1' 共 $n$ 次并停机。连接起来的描述 $Wp_{n}$ 输出 $s_{n}$，因此\n$$\nK(s_{n}) \\leq |W| + |p_{n}| = K(n) + c_{+},\n$$\n其中 $c_{+}=|W|$ 是一个与 $n$ 无关的正数常量。\n\n下界：\n令 $q$ 是 $s_{n}$ 的一个最短程序，因此 $|q|=K(s_{n})$。存在一个固定的提取程序 $E$（与 $n$ 无关），当执行时，它运行硬编码的 $q$ 以生成 $s_{n}$，计算其长度 $n$，将其转换为标准二进制格式，输出它，然后停机。因此，连接起来的描述 $Eq$ 是一个用于 $n$ 的程序，这意味着\n$$\nK(n) \\leq |E| + |q| = K(s_{n}) + c_{-},\n$$\n其中 $c_{-}=|E|$ 是一个与 $n$ 无关的正数常量。整理可得 $K(s_{n}) \\geq K(n) - c_{-}$。\n\n结合这两个界限，\n$$\nK(n) - c_{-} \\leq K(s_{n}) \\leq K(n) + c_{+},\n$$\n所以 $K(s_{n}) = K(n) + O(1)$，即它们最多相差一个与 $n$ 无关的加性常数。\n\n在给定的选项中，只有 $K(s_{n})=K(n)+c$ 的形式捕捉了对于所有正整数 $n$ 的这种加性常数关系。断言与 $n$ 呈线性依赖关系的选项（A, C）是错误的，因为 $s_{n}$ 是高度可压缩的；$K(s_{n})$ 的增长类似于 $n$ 的描述长度，而不是 $n$。选项 D，$K(s_{n})=\\log_{2}(n)+c$，对于所有 $n$ 来说，使用单一常数是不成立的，因为 $K(n)$ 在 $\\log_{2}(n)$ 附近波动，其波动幅度超过了一个固定的常数。选项 E 假设了一种乘法关系，但这并非正确的关系类型；该关系是加性的。", "answer": "$$\\boxed{B}$$", "id": "1602461"}, {"introduction": "在理解了单个字符串的复杂性之后，一个自然的问题是：如果我们已经知道某个字符串 $x$，那么生成一个与之密切相关的字符串需要多少额外信息？这个问题将我们引向了“条件柯尔莫哥洛夫复杂性”的概念。通过这个练习 [@problem_id:1602453]，你将计算给定二进制字符串 $x$ 的条件下，其按位取反字符串 $\\text{NOT}(x)$ 的复杂性，即 $K(\\text{NOT}(x)|x)$。这有助于你具体理解“给定信息”如何极大地简化相关信息的描述。", "problem": "在算法信息论中，一个字符串 $s$ 的柯尔莫哥洛夫复杂度，记为 $K(s)$，是能产生 $s$ 作为输出的最短计算机程序的长度。我们考虑的是一个固定的通用图灵机的程序。这个概念量化了字符串中所包含的信息量。一个随机字符串具有高复杂度，因为产生它的最短程序本质上就是包含该字符串本身的程序。一个高度模式化的字符串具有低复杂度。\n\n类似地，给定字符串 $t$ 的情况下，字符串 $s$ 的条件柯尔莫哥洛夫复杂度，记为 $K(s|t)$，是在给定 $t$ 作为程序的辅助输入时，能产生 $s$ 作为输出的最短程序的长度。这衡量了在已知 $t$ 的情况下，产生 $s$ 所需的信息量。\n\n设 $x$ 是一个长度为 $n$ 的二进制字符串。我们定义 $\\text{NOT}(x)$ 为 $x$ 的按位取反，即通过翻转 $x$ 的每一位（即将每个0变为1，每个1变为0）得到的长度为 $n$ 的字符串。\n\n对于任意长的二进制字符串 $x$，以下哪个表达式最能描述条件柯尔莫哥洛夫复杂度 $K(\\text{NOT}(x)|x)$？在以下选项中，$c$ 代表一个小的正常数，它仅取决于通用图灵机的选择，而不取决于字符串 $x$ 或其长度 $n$。\n\nA. $n + c$\n\nB. $\\log_{2}(n) + c$\n\nC. $c$\n\nD. $K(x) + c$\n\nE. $n - K(x) + c$", "solution": "设 $U$ 为一个固定的通用图灵机，并回顾条件柯尔莫哥洛夫复杂度的定义：\n$$\nK(s|t) \\equiv \\min\\{\\,|p| : U(p,t)=s\\,\\}.\n$$\n考虑由 $f(t)=\\text{NOT}(t)$ 定义的全可计算函数 $f$，其中 $\\text{NOT}(t)$ 翻转 $t$ 的每一位。由于 $f$ 是可计算的，并且除了将特定输入 $t$ 用作数据外不依赖于它，因此存在一个固定的程序 $p_{f}$（描述算法“扫描输入带并翻转每一位，然后停机”），使得对于所有二进制字符串 $x$，\n$$\nU(p_{f},x)=\\text{NOT}(x).\n$$\n长度 $|p_{f}|$ 是一个常数，仅取决于 $U$ 的选择和翻转过程的实现，而不取决于 $x$ 或其长度 $n$。因此，\n$$\nK(\\text{NOT}(x)\\,|\\,x)\\leq |p_{f}| \\equiv c.\n$$\n这表明 $K(\\text{NOT}(x)|x)$ 的上界是一个与 $n$ 和 $K(x)$ 无关的常数。一个平凡的下界是 $K(\\text{NOT}(x)|x)\\geq 0$，并且根据不变性定理，改变 $U$ 只会使复杂度产生一个加性常数的改变。因此，选项中最好的描述是 $K(\\text{NOT}(x)|x)$ 是一个常数（最多相差一个仅依赖于 $U$ 的加性常数），即选项C。\n\n其他选项不合适：它不随 $n$ 增长（所以A和B太大了），它不依赖于 $K(x)$（所以D和E不正确）。", "answer": "$$\\boxed{C}$$", "id": "1602453"}, {"introduction": "柯尔莫哥洛夫复杂性 $K(x)$ 是一个定义明确的数学对象，但它有一个惊人且深刻的特性：它是不可计算的。这意味着不存在一个通用算法，可以在有限时间内计算出任意给定字符串 $x$ 的 $K(x)$ 值。这个思想实验 [@problem_id:1602444] 通过一个假想的场景让你直面这一概念：如果你拥有一个能解决“停机问题”的神谕（oracle），你将如何设计一个算法来精确计算 $K(x)$？通过构建这个假想的计算过程，你将更深入地理解柯尔莫哥洛夫复杂性的不可计算性与停机问题之间的内在联系。", "problem": "在算法信息论的研究中，一个字符串 $x$ 的柯尔莫哥洛夫复杂度，记为 $K(x)$，被定义为在一个固定的参考通用图灵机（UTM）上运行时，能输出 $x$ 的最短程序的长度。虽然对于任何字符串 $x$，$K(x)$ 都是一个明确定义的整数，但它是一个著名的不可计算函数。\n\n然而，想象一下，你被给予了一个名为“停机预言机”的假设性设备。这个预言机，我们可以表示为函数 $H(p)$，它接受任何程序（一个二进制字符串）$p$ 作为输入，如果程序 $p$ 在空输入上停机，则立即返回 1，如果它永远运行，则返回 0。\n\n你的任务是使用这个预言机，通过穷举搜索算法来确定给定目标字符串 $x$ 的确切柯尔莫哥洛夫复杂度。算法过程如下：\n1.  初始化搜索长度 $l=0$。\n2.  系统地生成并测试所有 $2^l$ 个可能的长度为 $l$ 的程序。对于每个程序 $p$：\n    a. 查询停机预言机 $H(p)$。\n    b. 如果 $H(p)=1$，则运行程序 $p$ 以获得其输出。\n    c. 将输出与目标字符串 $x$ 进行比较。\n3.  如果找到了一个输出 $x$ 的程序，算法终止。其长度 $l$ 就是柯尔莫哥洛夫复杂度 $K(x)$。\n4.  如果在检查完所有长度为 $l$ 的程序后，没有一个产生 $x$，则将 $l$ 增加 1 并从步骤 2 重复。\n\n假设你使用这个算法，并发现某个特定字符串 $x_0$ 的柯尔莫哥洛夫复杂度恰好是 $L$，其中 $L$ 是一个正整数。为了明确地确定这个结果，可能需要查询停机预言机的最大次数是多少？请用一个关于 $L$ 的解析表达式来表示你的答案。", "solution": "该算法通过按程序长度 $l=0, 1, 2, \\ldots$ 的顺序进行穷举搜索。对于每个长度，它会测试所有该长度的程序。\n\n1.  **检查长度小于 L 的程序**：由于已知 $K(x_0) = L$，因此所有长度 $l  L$ 的程序都不能生成 $x_0$。算法必须检查所有这些程序以确认这一点。对于每个长度 $l$（从 $0$到 $L-1$），有 $2^l$ 个程序。查询停机预言机的总次数为 $\\sum_{l=0}^{L-1} 2^l = 2^L - 1$ 次。\n\n2.  **检查长度为 L 的程序**：在排除了所有更短的程序后，算法开始测试长度为 $L$ 的程序。为了找到最大查询次数，我们考虑最坏情况：生成 $x_0$ 的程序是所有长度为 $L$ 的程序中最后一个被测试的。长度为 $L$ 的程序有 $2^L$ 个，因此在最坏情况下，需要进行 $2^L$ 次查询。\n\n3.  **总查询次数**：将这两部分相加，得到可能需要的最大查询次数：\n    $$ (\\text{长度 }  L \\text{ 的查询}) + (\\text{长度 } L \\text{ 的查询}) = (2^L - 1) + 2^L = 2 \\cdot 2^L - 1 = 2^{L+1} - 1 $$\n    因此，确定 $K(x_0)=L$ 的最大查询次数是 $2^{L+1}-1$。", "answer": "$$\\boxed{2^{L+1}-1}$$", "id": "1602444"}]}