{"hands_on_practices": [{"introduction": "要真正掌握管道，一个极好的方法是从零开始亲手实现一个。这项练习将挑战您用代码模拟管道的核心特性——即“破坏性读取”和“不可寻址”，从而将抽象的操作系统原理转化为具体的程序逻辑。通过这个过程，您将深刻理解为何管道被设计为一种瞬时且单向的字节流。", "problem": "要求您编写一个完整的程序，该程序模拟匿名管道作为字节流通道的行为，并体现操作系统教科书中确立的两个基本特性：(i) 读操作是破坏性的，会消耗流中的数据；(ii) 由于缺乏可寻址的位置，流是不可寻址的。您的论证应基于以下基础：匿名管道是一种不支持随机访问的先进先出 (FIFO) 字节流，对于没有稳定后备存储的流，任何试图重新定位读偏移量（例如，通过寻址操作）的行为根据定义都是无效的。\n\n您的程序必须仅使用内存数据结构和标准输入/输出 (I/O) 文件函数来模拟匿名管道。该模拟必须体现上述两个特性，并支持一个审计机制，该机制通过将流经模拟读操作的字节复制到一个文件中，来模仿“tee”操作的行为。除了标准的C库文件I/O之外，不允许使用其他操作系统调用。设计约束如下：\n\n1. 模拟管道是一个容量为 $C$ 的字节流，其中 $C$ 是您选择的任意固定有限整数（为了在您的程序中具体化，您可以取 $C = 64$）。您必须存储当前未读的内容和一个读指针。读取 $k$ 字节的操作返回 $\\min(k, r)$ 字节，其中 $r$ 是未读字节数，并根据实际返回的字节数推进读指针。这模拟了数据的破坏性、临时性消耗。\n2. 任何对管道进行“寻址”的尝试，即通过任意偏移量 $o \\in \\mathbb{Z}$ 来改变读指针，都必须通过返回错误码 $-1$ 来拒绝。这体现了不可寻址的特性。\n3. 带审计的读操作必须使用标准文件I/O将与读操作返回的字节完全相同的字节写入审计文件。这模拟了用于审计的“tee”操作，确保字节在从流中消耗的同时被复制到持久存储中。\n\n您的程序必须构建并执行以下测试套件，并生成一行输出，其中包含所有结果，这些结果聚合为一个用方括号括起来的逗号分隔列表。所有输出必须是整数。\n\n测试套件：\n- 测试A（不可寻址语义）：用字节序列“hello”初始化模拟管道。尝试以偏移量 $0$ 进行寻址，如果结果等于 $-1$，则返回 $1$，否则返回 $0$。这验证了寻址操作被拒绝。\n- 测试B（临时性消耗）：用字节序列“ABCDE”初始化模拟管道。分别执行三次大小为 $2$、 $3$ 和 $1$ 字节的读取，记录每次读取实际返回的字节数。正确的临时性行为产生三元组 $\\langle 2, 3, 0 \\rangle$，因为前两次读取后流已被耗尽。\n- 测试C（通过tee进行审计）：用长度为 $22$ 的字节序列“os-pipes-are-ephemeral”初始化模拟管道。执行一次带审计的读取，请求 $1000$ 字节（大于可用字节数），以便该操作返回所有可用字节并将相同的字节写入审计文件。读取完成后，从审计文件内容中计算两个整数：文件的字节长度 $L$ 和字节和 $S = \\sum_{i=1}^{L} b_i$，其中 $b_i$ 是第 $i$ 个字节的无符号值。对于所提供的确切字符串， $L = 22$ 且 $S = 2165$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按以下顺序排列、用方括号括起来的逗号分隔列表形式的结果：\n1. 测试A的结果（整数 $0$ 或 $1$），\n2. 测试B第一次读取的大小（整数），\n3. 测试B第二次读取的大小（整数），\n4. 测试B第三次读取的大小（整数），\n5. 测试C的文件长度 $L$ （整数），\n6. 测试C的字节和 $S$ （整数）。\n\n具体来说，输出必须具有 [resA,resB1,resB2,resB3,L,S] 的确切形式，行内没有空格也没有其他文本。", "solution": "问题陈述已经过严格评估，并被确定为**有效的**。它在科学上基于操作系统关于匿名管道的既定原则，问题提法得当，目标明确且可实现，并且没有歧义或矛盾。该问题为模拟字节流通道提供了形式化规范，并提供了一个具体的测试套件来验证模拟的正确性。\n\n任务是为一个匿名管道建模，这是一种基本的进程间通信机制。该模型必须遵循两个定义性属性：(i) 读操作是破坏性的，意味着数据在被读取后即从流中消耗掉；(ii) 流是不可寻址的，意味着没有机制可以任意重新定位读指针。该模拟将使用C语言，通过内存数据结构和标准文件I/O函数来实现。\n\n一个合适的表示模拟管道的数据结构是C语言的 `struct`。该结构将封装管道的状态：一个用于存放字节流的固定大小的缓冲区，一个用于跟踪最初写入管道的总字节数的变量，以及一个用于跟踪消耗情况的读指针。\n\n设该结构定义为 `SimulatedPipe`：\n- `char data[C]`：一个固定容量为 $C$ 的字符数组。根据建议，我们将使用 $C=64$ 字节。此数组存储字节流。\n- `int content_length`：一个整数，表示管道内部缓冲区当前持有的字节数。\n- `int read_offset`：一个整数，表示读头的当前位置。此偏移量跟踪从流的开始处已经消耗了多少字节。\n\n管道的行为由对该结构的一组操作定义。\n\n1.  **初始化 (`pipe_init`)**：此函数准备管道以供使用。它接受一个指向 `SimulatedPipe` 结构的指针和一串初始数据。它将数据复制到管道的缓冲区中，将 `content_length` 设置为输入数据的长度（不超过容量 $C$），并将 `read_offset` 初始化为 $0$，表示尚未消耗任何数据。\n\n2.  **寻址 (`pipe_seek`)**：此函数模拟管道的不可寻址特性。问题规定，任何尝试通过偏移量 $o \\in \\mathbb{Z}$ 进行寻址的操作都必须被拒绝。因此，此函数将忽略其输入参数，并无条件返回错误码 $-1$，从而正确模拟真实的 `lseek` 系统调用在管道文件描述符上会返回的 `ESPIPE` 错误（`Illegal seek`，非法寻址）。\n\n3.  **读取 (`pipe_read`)**：此函数模拟破坏性的读操作。它接受一个请求读取的字节数 $k$。\n    - 首先，它计算流中剩余的未读字节数 $r$。该值由 $r = \\text{content\\_length} - \\text{read\\_offset}$ 给出。\n    - 实际可以返回的字节数是请求量和可用量中的较小者：$\\min(k, r)$。设此值为 `bytes_to_return`。\n    - 从内部缓冲区的当前 `read_offset` 位置开始，将 `bytes_to_return` 个字节复制到调用者提供的输出缓冲区中。\n    - 然后，`read_offset` 增加 `bytes_to_return`。这是模拟读取的“破坏性”或“临时性”的关键步骤：数据现在被视为已消耗，不再可用于后续读取。\n    - 函数返回 `bytes_to_return`。如果没有可用字节（$r \\le 0$），则返回 $0$。\n\n4.  **带审计的读取 (`pipe_read_with_audit`)**：此操作模拟一个“tee”工具，其中流经管道的数据被复制到一个次要目标，在本例中是一个审计文件。\n    - 它在内部调用 `pipe_read` 来执行读操作。实际读取的字节数（我们称之为 `bytes_read`）被捕获。\n    - 然后，使用标准文件I/O函数（`fopen`、`fwrite`、`fclose`）将这些被复制到调用者输出缓冲区中的 `bytes_read` 个字节写入指定的审计文件。这确保了审计日志包含该操作期间从管道消耗的数据的精确副本。\n\n现在可以使用这些函数执行指定的测试套件。\n\n- **测试A（不可寻址语义）**：用字节序列“hello”初始化管道。调用 `pipe_seek` 并设置偏移量为 $0$。按照设计，该函数返回 $-1$。测试结果为 $1$，证实了不可寻址特性的正确实现。\n\n- **测试B（临时性消耗）**：用“ABCDE”初始化管道，因此 `content_length` 为 $5$。\n    1.  请求读取 $k=2$ 字节。可用字节数为 $r = 5 - 0 = 5$。操作返回 $\\min(2, 5) = 2$ 字节（“AB”）。`read_offset` 变为 $2$。第一个结果是 $2$。\n    2.  请求读取 $k=3$ 字节。现在可用字节数为 $r = 5 - 2 = 3$。操作返回 $\\min(3, 3) = 3$ 字节（“CDE”）。`read_offset` 变为 $2 + 3 = 5$。第二个结果是 $3$。\n    3.  请求读取 $k=1$ 字节。可用字节数为 $r = 5 - 5 = 0$。操作返回 $\\min(1, 0) = 0$ 字节。`read_offset` 保持为 $5$。第三个结果是 $0$。\n    最终读取大小的序列是 $\\langle 2, 3, 0 \\rangle$，展示了正确的临时性消耗。\n\n- **测试C（通过tee进行审计）**：用长度为 $22$ 的字符串“os-pipes-are-ephemeral”初始化管道。\n    - 执行一次 `pipe_read_with_audit` 操作，请求 $k=1000$ 字节。\n    - 可用字节数为 $r = 22 - 0 = 22$。读操作返回 $\\min(1000, 22) = 22$ 字节。整个字符串被消耗。\n    - 这 $22$ 个字节被写入一个审计文件。\n    - 为验证审计结果，以读取模式打开文件。确定其长度 $L$（例如，使用 `fseek` 到文件末尾和 `ftell`），该长度将为 $22$。\n    - 然后逐字节读取文件，并将每个字节 $b_i$ 的无符号值累加到总和 $S$ 中。对于给定的字符串，此总和为 $S = \\sum_{i=1}^{22} b_i = 2165$。\n    - 此测试的结果是 $L=22$ 和 $S=2165$。\n\n最终的程序会将这些结果组合成指定的逗号分隔格式。", "answer": "```c\n// The complete and compilable C program.\n#include", "id": "3669825"}, {"introduction": "在理论学习之后，我们将面对现实编程中的挑战。当管道的读取端意外关闭时，管道会“破裂”，这在实际应用中很常见。本练习探讨了操作系统为处理此类错误提供的关键机制，即 $SIGPIPE$ 信号和 $EPIPE$ 错误码，掌握这些是编写能够优雅处理异常、避免程序崩溃的健壮软件的关键。", "problem": "一个单线程的写入进程 $P_w$ 和一个读取进程 $P_r$ 通过由 `pipe(pipefd)` 创建的匿名管道进行通信，其中 `pipefd[0]` 是读取端，`pipefd[1]` 是写入端。根据设计，$P_r$ 在 fork 后立即关闭 `pipefd[1]`，并且只从 `pipefd[0]` 读取。然而，在这种情况下，$P_r$ 在执行任何读取操作之前提前退出，这导致其文件描述符被操作系统关闭，使得 $P_w$ 只有 `pipefd[1]` 保持打开，而管道上没有任何读取者。\n\n假设存在以下系统特性和广为接受的事实：\n- 在可移植操作系统接口 (POSIX) 标准下，对一个没有打开的读取端的管道调用 `write()` 会导致向调用进程传递 $SIGPIPE$ 信号；如果该信号被忽略或处理程序返回，则 `write()` 调用失败，返回值为 $-1$ 并将 $errno$ 设置为 $EPIPE$。\n- $SIGPIPE$ 的默认操作是终止进程。\n- 对于至少有一个读取者的管道，$PIPE\\_BUF$ 是一个系统定义的大小，任何大小 $\\leq PIPE\\_BUF$ 的单次 `write()` 操作相对于其他写入者都是原子的。POSIX 要求 $PIPE\\_BUF \\geq 512$。在本系统中，设 $PIPE\\_BUF = 4096$ 且管道容量 $C = 65536$ 字节。\n- `write()` 系统调用遵循应用程序编程接口 (API) 约定：它返回成功写入的字节数 ($\\geq 0$)，或者在出错时返回 $-1$，此时 $errno$ 会指示错误。\n\n进程 $P_w$ 尝试向 $P_r$ 发送大小为 $N = 100000$ 字节的消息，方法是按大小为 $s = 8192$ 字节的数据块进行迭代，重复调用 `write(pipefd[1], buf + offset, s)` 直到所有字节被写入或发生错误。考虑 $P_w$ 的三种配置变体：\n1. $SIGPIPE$ 使用其默认处置方式。\n2. 通过设置为忽略来抑制 $SIGPIPE$。\n3. 通过安装一个立即返回的处理程序来抑制 $SIGPIPE$（处理程序内部没有 longjmp 或重试）。\n\n在这种情况下，关于控制流和错误恢复的以下哪些陈述是正确的？选择所有适用的选项。\n\nA. 在 $SIGPIPE$ 使用默认处置方式的情况下，当 $P_w$ 首次向没有读取者的管道进行 `write()` 操作时，内核传递 $SIGPIPE$ 信号，默认操作终止 $P_w$，$0$ 字节被写入，并且 `write()` 调用不会返回到用户空间。\n\nB. 如果在 $P_w$ 中忽略 $SIGPIPE$，首次向没有读取者的管道进行 `write()` 操作将返回 $-1$ 并设置 $errno = EPIPE$，$0$ 字节被写入，控制流在 `write()` 调用后继续，允许应用程序执行清理并决定恢复策略。\n\nC. 如果 $P_w$ 安装一个返回的 $SIGPIPE$ 处理程序，首次向没有读取者的管道进行 `write()` 操作将返回 $-1$ 并设置 $errno = EPIPE$，$0$ 字节被写入，执行在 `write()` 调用后继续，从而可以在不终止进程的情况下进行恢复。\n\nD. 对于任何写入大小 $n \\leq PIPE\\_BUF$，即使没有读取者存在，操作系统也保证传递整个记录，因此抑制 $SIGPIPE$ 将允许数据被缓冲直到有读取者出现，并且不会发生 $EPIPE$。\n\nE. 当 $N > C$ 且至少存在一个读取者时，`write()` 可能会传输部分字节并返回一个小于 $N$ 的正值；然而，当没有读取者时，无论 $N$ 或 $s$ 的大小，`write()` 都会传输 $0$ 字节并报告 $EPIPE$。", "solution": "问题陈述描述了一个常见的进程间通信 (IPC) 场景，涉及一个写入进程 $P_w$ 和一个读取进程 $P_r$ 在兼容 POSIX 的系统上使用匿名管道。问题的核心在于读取进程 $P_r$ 的提前退出，它关闭了管道的读取端 `pipefd[0]`。这一行为导致写入进程 $P_w$ 拥有一个指向已无活动读取者的管道的打开的写入端 `pipefd[1]`。\n\n### **问题验证**\n\n**步骤 1：提取已知条件**\n- **进程和管道：** 一个写入进程 $P_w$ 和一个读取进程 $P_r$ 通过 `pipe(pipefd)` 创建的管道进行通信。`pipefd[0]` 是读取端，`pipefd[1]` 是写入端。\n- **场景：** $P_r$ 从 $P_w$ fork 出来，关闭 `pipefd[1]`，并计划从 `pipefd[0]` 读取。然而，$P_r$ 在读取前退出，导致其所有文件描述符（包括 `pipefd[0]`）被关闭。因此，该管道没有打开的读取端。\n- **系统行为 (POSIX)：**\n    - 对一个没有打开的读取端的管道进行 `write()` 操作会传递 $SIGPIPE$ 信号。\n    - 如果 $SIGPIPE$ 被忽略或由一个返回的处理程序处理，`write()` 会失败，返回 $-1$ 并将 $errno$ 设置为 $EPIPE$。\n    - $SIGPIPE$ 的默认操作是终止进程。\n- **系统参数：**\n    - 原子写入的管道缓冲区大小：$PIPE\\_BUF = 4096$ 字节。\n    - 总管道容量：$C = 65536$ 字节。\n- **写入者行为：** $P_w$ 尝试以大小为 $s = 8192$ 字节的数据块写入 $N = 100000$ 字节，使用 `write(pipefd[1], buf + offset, s)`。\n- **$P_w$ 的配置：**\n    1.  $SIGPIPE$ 采用其默认处置方式。\n    2.  $SIGPIPE$ 被忽略。\n    3.  为 $SIGPIPE$ 安装了一个立即返回的处理程序。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，提法明确且客观。它基于 POSIX 标准所定义的管道、系统调用和信号的标准、可验证的行为。该场景是一个健壮程序必须处理的经典 IPC 错误条件。其前提事实可靠，术语精确，设置内部一致且完整。不存在科学或逻辑上的缺陷。\n\n**步骤 3：结论与行动**\n问题陈述是**有效**的。开始进行解答。\n\n### **推导与选项分析**\n\n支配此场景的基本原则是，管道是至少一个写入者和至少一个读取者之间的单向通信通道。当管道的打开的读取描述符（`pipefd[0]`）数量降至零时，该管道被视为“已损坏”(broken)。任何后续向此管道写入的尝试都是错误的。内核通过发送 $SIGPIPE$ 信号来通知写入进程此错误。进程对此信号的响应决定了最终结果。\n\n让我们分析 $P_w$ 的三种指定配置：\n\n1.  **默认 $SIGPIPE$ 处置方式：** $SIGPIPE$ 的默认操作是终止进程。当 $P_w$ 执行其第一次 `write()` 调用时，内核检测到管道没有读取者，并向 $P_w$ 发送 $SIGPIPE$。默认信号处理程序被调用，立即终止该进程。因此，`write()` 系统调用被中止，不会将控制权返回给用户空间代码。程序的执行被停止。\n\n2.  **$SIGPIPE$ 被忽略：** 如果进程已将 $SIGPIPE$ 的处置方式设置为忽略（例如，通过 `signal(SIGPIPE, SIG_IGN)`），当 `write()` 被调用时，内核仍然会检测到损坏的管道。它尝试传递 $SIGPIPE$，发现该信号应被忽略，于是丢弃该信号。根据问题陈述和 POSIX 标准，`write()` 调用会优雅地失败，返回 $-1$ 并将全局变量 `errno` 设置为 $EPIPE$。控制权返回到 `write()` 调用之后的指令，允许应用程序检查返回值，探查 `errno`，并执行错误处理或清理逻辑。\n\n3.  **$SIGPIPE$ 被处理：** 如果进程为 $SIGPIPE$ 安装了一个仅作返回的自定义处理程序，关于 `write()` 调用失败的事件序列与忽略情况类似。当在损坏的管道上调用 `write()` 时，内核发送 $SIGPIPE$。进程的执行被中断，控制权转移到信号处理程序。处理程序执行并返回。在处理程序返回后，被中断的系统调用（`write()`）不会自动重启，因为底层的错误条件（损坏的管道）是持续存在的。该调用失败，返回 $-1$ 并将 $errno$ 设置为 $EPIPE$。控制权在 `write()` 调用后返回到用户空间代码，从而可以进行恢复。\n\n现在我们基于此分析来评估每个选项。\n\n**A. 在 $SIGPIPE$ 使用默认处置方式的情况下，当 $P_w$ 首次向没有读取者的管道进行 `write()` 操作时，内核传递 $SIGPIPE$ 信号，默认操作终止 $P_w$，$0$ 字节被写入，并且 `write()` 调用不会返回到用户空间。**\n此陈述准确描述了默认 $SIGPIPE$ 处置方式（情况 1）的结果。内核发送 $SIGPIPE$，默认操作是终止，而这种终止会抢占系统调用的完成，意味着它永远不会返回到用户程序。写入操作本身失败，因此传输了 $0$ 字节。\n**结论：正确。**\n\n**B. 如果在 $P_w$ 中忽略 $SIGPIPE$，首次向没有读取者的管道进行 `write()` 操作将返回 $-1$ 并设置 $errno = EPIPE$，$0$ 字节被写入，控制流在 `write()` 调用后继续，允许应用程序执行清理并决定恢复策略。**\n此陈述准确描述了当 $SIGPIPE$ 被忽略时（情况 2）的结果。通过忽略该信号，进程选择通过系统调用的返回值和 `errno` 来接收错误通知。这使得程序能够保持控制并处理错误，而不会被终止。\n**结论：正确。**\n\n**C. 如果 $P_w$ 安装一个返回的 $SIGPIPE$ 处理程序，首次向没有读取者的管道进行 `write()` 操作将返回 $-1$ 并设置 $errno = EPIPE$，$0$ 字节被写入，执行在 `write()` 调用后继续，从而可以在不终止进程的情况下进行恢复。**\n此陈述准确描述了为 $SIGPIPE$ 安装返回处理程序时（情况 3）的结果。问题陈述和 POSIX 行为都证实，在处理程序返回后，永久失败的系统调用将通过返回 $-1$ 并将 $errno$ 设置为 $EPIPE$ 来指示错误。此机制也防止了进程终止，并允许进行程序化的错误处理。\n**结论：正确。**\n\n**D. 对于任何写入大小 $n \\leq PIPE\\_BUF$，即使没有读取者存在，操作系统也保证传递整个记录，因此抑制 $SIGPIPE$ 将允许数据被缓冲直到有读取者出现，并且不会发生 $EPIPE$。**\n此陈述存在根本性缺陷。$PIPE\\_BUF$ 提供的保证涉及对一个*有效的、正常工作*的管道（即有读取者的管道）进行写入操作的原子性。它确保大小小于或等于 $PIPE\\_BUF$ 的写入不会与其他写入者的数据交错。它不适用于损坏的管道。内核不会在没有读取者的管道中缓冲数据；“没有读取者存在”这个条件正是 $SIGPIPE$ 和 $EPIPE$ 设计用来报告的错误。抑制信号并不能改变写入操作不可能完成这一根本事实。\n**结论：错误。**\n\n**E. 当 $N > C$ 且至少存在一个读取者时，`write()` 可能会传输部分字节并返回一个小于 $N$ 的正值；然而，当没有读取者时，无论 $N$ 或 $s$ 的大小，`write()` 都会传输 $0$ 字节并报告 $EPIPE$。**\n此陈述正确地对比了管道的两种不同行为。\n- **第一部分：** 当存在读取者时，对管道的 `write()` 操作确实可以返回一个“部分计数”（返回值大于 $0$ 但小于请求的字节数）。如果管道缓冲区在写入过程中变满，这种情况就可能发生，特别是对于非原子写入（写入大小大于 $PIPE\\_BUF$，如此处 $s = 8192 > PIPE\\_BUF = 4096$）。该陈述提到返回一个小于 $N$ ($100000$) 的值，这对于任何一次大小为 $s=8192$ 的成功写入都是成立的。因此，这部分是正确的。\n- **第二部分：** 这部分正确地重申了管道损坏时的行为：在没有读取者的情况下，任何写入尝试都会立即失败，传输 $0$ 字节，并导致 $EPIPE$ 错误（假设信号被处理或忽略），而不管预期的写入大小（$N$ 或 $s$）是多少。\n整个陈述对管道在有效状态和损坏状态下的行为进行了准确的比较。\n**结论：正确。**", "answer": "$$\\boxed{ABCE}$$", "id": "3669766"}, {"introduction": "这项练习将您置于系统诊断专家的角色，解决一个真实的“悬挂”管道难题。在复杂的多进程系统中，一个看似正常运行的流水线可能会意外卡住，而问题往往源于一个被遗忘的文件描述符。通过追踪进程间的继承关系和文件描述符的生命周期，您将学会如何定位并解决这类棘手的并发问题 ([@problem_id:3669787])。", "problem": "在可移植操作系统接口（POSIX）中，匿名管道是一个由内核管理的缓冲区，它恰好有两个端点：一个读端和一个写端。根据定义，当管道缓冲区中没有字节且至少有一个写端保持打开时，对管道的 `read()` 操作会阻塞；而当所有写端都已关闭时，读操作会返回文件结束符（EOF）。文件描述符通过 `fork()` 系统调用在进程创建时被继承，并且在执行 `exec()` 系列系统调用后保持打开状态，除非设置了 Close-On-Execute (CLOEXEC) 标志。像 `A | B | C` 这样的 shell 管道是通过两个匿名管道实现的：一个在 $A$ 和 $B$ 之间，另一个在 $B$ 和 $C$ 之间。进程状态命令 (`ps`) 概念上会显示父子进程关系，而列出打开文件命令 (`lsof`) 概念上会揭示每个进程打开的文件描述符以及每个管道的内核对象标识。\n\n考虑一个由 shell 创建的管道，其中命令 $A$、$B$ 和 $C$ 的进程标识符 (PID) 分别为 $2301$、$2302$ 和 $2303$。该 shell 创建了两个匿名管道，其内核对象标识分别为 $p_{\\alpha}$ 和 $p_{\\beta}$，其中 $p_{\\alpha}$ 的标识符为 $41001$，$p_{\\beta}$ 的标识符为 $41002$。在时刻 $t_{0}$，管道设置完成后立即出现以下情况：\n\n- 进程 $A$ (PID $2301$，父进程标识符 (PPID) $2299$) 的文件描述符 $1$ 打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的写端。其文件描述符 $0$ 是一个普通文件。\n- 进程 $B$ (PID $2302$，PPID $2299$) 的文件描述符 $0$ 打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的读端，文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端。\n- 进程 $C$ (PID $2303$，PPID $2299$) 的文件描述符 $0$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的读端。\n\n之后，进程 $B$ 在未对其文件描述符设置 CLOEXEC 的情况下执行了一个辅助程序。具体来说，进程 $B$ fork 之后执行了一个辅助进程 $H$ (PID $2310$，PPID $2302$)，该进程继承了指向管道 $p_{\\beta}$ (标识符 $41002$) 写端的描述符 $1$。此后不久，在时刻 $t_{1}$，进程 $B$ 终止并成为一个僵尸进程 (defunct)，释放了其文件描述符。在时刻 $t_{2} > t_{1}$，与管道相关的系统状态如下：\n\n- 进程 $A$ (PID $2301$) 的文件描述符 $1$ 仍然打开并指向管道 $p_{\\alpha}$ (标识符 $41001$) 的写端。它没有任何指向管道 $p_{\\beta}$ (标识符 $41002$) 的描述符。\n- 进程 $B$ (PID $2302$) 是一个僵尸进程，没有打开的文件描述符。\n- 进程 $C$ (PID $2303$) 在其文件描述符 $0$ (即管道 $p_{\\beta}$ (标识符 $41002$) 的读端) 上的一个 `read()` 操作中被阻塞。\n- 辅助进程 $H$ (PID $2310$，PPID $2302$) 的文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端。它没有写入任何数据并且正在休眠。\n- 系统中没有其他进程持有指向管道 $p_{\\beta}$ (标识符 $41002$) 的打开描述符。\n\n测量表明，在时刻 $t_{2}$，管道 $p_{\\beta}$ 的缓冲区包含 $0$ 字节。管道表现为“挂起”状态，因为进程 $C$ 正在等待管道 $p_{\\beta}$ 上的 EOF 信号以继续执行，但该 EOF 信号一直未出现。\n\n哪个选项指出了在时刻 $t_{2}$ 时，其打开的写端足以阻止在管道 $p_{\\beta}$ 上产生 EOF 的唯一进程，因此该进程必须关闭那个描述符（或被终止），以允许进程 $C$ 观察到 EOF 并解除阻塞，从而“拯救”整个管道？\n\nA. 进程 $A$ (PID $2301$)\n\nB. 进程 $B$ (PID $2302$)\n\nC. 进程 $C$ (PID $2303$)\n\nD. 辅助进程 $H$ (PID $2310$)", "solution": "首先提取给定信息，然后评估其科学依据、一致性和完整性，从而验证问题陈述。\n\n**步骤 1：提取已知条件**\n- 在 POSIX 中，匿名管道是具有读端和写端的内核缓冲区。\n- 如果管道缓冲区为空且至少有一个写端是打开的，对管道的 `read()` 操作会阻塞。\n- 如果管道缓冲区为空且所有写端都已关闭，对管道的 `read()` 操作会返回文件结束符 (EOF)。\n- 文件描述符在 `fork()` 时被继承，并且在 `exec()` 后保持打开，除非设置了 `CLOEXEC` 标志。\n- shell 管道 `A | B | C` 是通过两个匿名管道实现的。\n- 管道 $p_{\\alpha}$ 的内核对象标识符为 $41001$。\n- 管道 $p_{\\beta}$ 的内核对象标识符为 $41002$。\n- 在时刻 $t_0$，管道设置完成后立即：\n    - 进程 $A$ (PID $2301$, PPID $2299$) 的文件描述符 (FD) $1$ 打开并指向 $p_{\\alpha}$ 的写端。\n    - 进程 $B$ (PID $2302$, PPID $2299$) 的 FD $0$ 打开并指向 $p_{\\alpha}$ 的读端，FD $1$ 打开并指向 $p_{\\beta}$ 的写端。\n    - 进程 $C$ (PID $2303$, PPID $2299$) 的 FD $0$ 打开并指向 $p_{\\beta}$ 的读端。\n- 在 $t_0$ 之后：\n    - 进程 $B$ fork 一个子进程，该子进程随后执行一个辅助程序，成为进程 $H$。\n    - `exec()` 调用没有在 $B$ 的文件描述符上设置 `CLOEXEC`。\n    - 进程 $H$ (PID $2310$, PPID $2302$) 继承了文件描述符，包括指向 $p_{\\beta}$ 写端的 FD $1$。\n    - 在时刻 $t_1$，进程 $B$ 终止，成为一个僵尸进程，其文件描述符被释放。\n- 在时刻 $t_2 > t_1$，系统状态为：\n    - 进程 $A$ (PID $2301$) 的 FD $1$ 打开并指向 $p_{\\alpha}$ 的写端。它不持有 $p_{\\beta}$ 的描述符。\n    - 进程 $B$ (PID $2302$) 是一个没有打开文件描述符的僵尸进程。\n    - 进程 $C$ (PID $2303$) 在 FD $0$（即 $p_{\\beta}$ 的读端）上的 `read()` 操作中阻塞。\n    - 进程 $H$ (PID $2310$) 的 FD $1$ 打开并指向 $p_{\\beta}$ 的写端。\n    - 没有其他进程持有管道 $p_{\\beta}$ 的打开描述符。\n    - 管道 $p_{\\beta}$ 的缓冲区包含 $0$ 字节。\n- 问题要求找出是哪个唯一的进程，其在管道 $p_{\\beta}$ 上打开的写端阻止了进程 $C$ 接收 EOF，从而导致管道“挂起”。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述是对 Unix/POSIX 系统中涉及使用管道进行进程间通信的一个常见场景的形式良好且准确的描述。\n- **有科学依据：** 对管道语义（阻塞读、EOF 条件）、通过 `fork()` 和 `exec()` 的文件描述符继承以及进程状态（僵尸进程）的描述，完全符合操作系统的既定原则，特别是 POSIX 标准。该场景是“管道卡住”错误的一个典型例子。\n- **问题定义良好：** 问题提供了在特定时间 ($t_2$) 系统的一个完整且一致的状态，并就特定行为（进程 $C$ 阻塞）的原因提出了一个精确、可回答的问题。可以从所提供的信息中推导出唯一且明确的答案。\n- **客观性：** 问题使用精确的技术术语（PID、PPID、文件描述符、`CLOEXEC`、僵尸进程）和定量标识符进行陈述。它没有任何歧义或主观断言。\n\n**步骤 3：结论与行动**\n问题陈述有效。可以继续进行分析。\n\n**求解过程**\n问题的核心在于对管道的 `read()` 操作何时返回文件结束符 (EOF) 的规则。正如问题描述中所述，这发生在“所有[通向该管道的]写端都已关闭”时。进程 $C$ 当前在从管道 $p_{\\beta}$ 读取时被阻塞，且该管道的缓冲区是空的。只要至少有一个进程持有与 $p_{\\beta}$ 写端对应的打开文件描述符，这就是预期的行为。为了“拯救”进程 $C$ 并使其能观察到 EOF，所有这样的写端文件描述符都必须被关闭。\n\n任务是确定在时刻 $t_2$ 哪个或哪些进程持有管道 $p_{\\beta}$ 写端的打开文件描述符。我们必须系统地检查在 $t_2$ 的状态描述中提到的每个进程。\n\n1.  **关注的管道**：问题集中在管道 $p_{\\beta}$ (标识符 $41002$) 上，因为进程 $C$ 正因从中读取而被阻塞。\n\n2.  **EOF 的条件**：为了让进程 $C$ 接收到 EOF，内核对管道 $p_{\\beta}$ 的打开写端的内部引用计数必须降至 $0$。\n\n3.  **$t_2$ 时刻的进程状态分析**：\n    - **进程 $A$ (PID $2301$)：** 问题陈述“它没有任何指向管道 $p_{\\beta}$ 的描述符”。因此，进程 $A$ 没有保持 $p_{\\beta}$ 的写端打开。\n    - **进程 $B$ (PID $2302$)：** 问题陈述“进程 $B$ (PID $2302$) 是一个僵尸进程，没有打开的文件描述符。”当一个进程终止时，操作系统内核会关闭其所有打开的文件描述符。因此，进程 $B$ 曾经持有的用于 $p_{\\beta}$ 写端的文件描述符已在时刻 $t_1$ 被关闭。在时刻 $t_2$，进程 $B$ 对打开的写入者计数没有贡献。\n    - **进程 $C$ (PID $2303$)：** 这个进程是管道 $p_{\\beta}$ 的读取者。它持有的是读端的描述符，而不是写端。它是等待 EOF 的一方，而不是阻止 EOF产生的一方。\n    - **辅助进程 $H$ (PID $2310$)：** 问题明确指出，“辅助进程 $H$ (PID $2310$，PPID $2302$) 的文件描述符 $1$ 打开并指向管道 $p_{\\beta}$ (标识符 $41002$) 的写端...它没有写入任何数据并且正在休眠。” 这是进程 $B$ 在未设置 `CLOEXEC` 标志的情况下 fork 并执行 $H$ 的直接后果；进程 $H$ 继承了打开的文件描述符。\n    - **其他进程：** 问题陈述，“系统中没有其他进程持有指向管道 $p_{\\beta}$ 的打开描述符”。\n\n4.  **结论**：根据分析，在时刻 $t_2$，整个系统中只有一个指向管道 $p_{\\beta}$ 写端的打开文件描述符。该描述符由辅助进程 $H$ 持有。这单个打开的写句柄的存在，足以阻止内核向进程 $C$ 发送 EOF。因此，进程 $H$ 是导致管道挂起的唯一原因。要解决此问题，进程 $H$ 必须关闭其文件描述符 $1$ 或被终止，这将导致内核代表它关闭该描述符。\n\n**逐项分析选项**\n\n- **A. 进程 $A$ (PID $2301$)：** 如前所述，进程 $A$ 没有与管道 $p_{\\beta}$ 相关联的打开文件描述符。因此，它在阻止 $p_{\\beta}$ 上的 EOF 方面不起作用。**错误**。\n\n- **B. 进程 $B$ (PID $2302$)：** 进程 $B$ 已终止。尽管它在执行进程 $H$ 之前因不当管理文件描述符而造成了这种情况，但在时刻 $t_2$，它是一个僵尸进程，不持有任何打开的文件描述符。内核在其于 $t_1$ 终止时关闭了它的描述符。因此，它不是当前阻止 EOF 的进程。**错误**。\n\n- **C. 进程 $C$ (PID $2303$)：** 进程 $C$ 是管道 $p_{\\beta}$ 的消费者，持有读端的描述符。它是管道挂起的受害者，而不是原因。**错误**。\n\n- **D. 辅助进程 $H$ (PID $2310$)：** 进程 $H$ 继承并持有一个指向管道 $p_{\\beta}$ 写端的打开文件描述符。只要此描述符是打开的，为进程 $C$ 生成 EOF 的条件（即所有写端都已关闭）就未满足。进程 $H$ 是唯一一个其打开的写端足以阻止 EOF 的进程。**正确**。", "answer": "$$\\boxed{D}$$", "id": "3669787"}]}