{"hands_on_practices": [{"introduction": "线程是实现并发的强大工具，但它们并非“免费的午餐”。要真正驾驭线程，我们首先必须理解其资源成本。这项练习将引导你扮演系统程序员的角色，在一个给定的虚拟地址空间限制下，计算一个进程理论上可以创建的最大线程数。通过这个实践 [@problem_id:3688668]，你将从“线程是轻量级的”这一模糊概念，转向对资源进行精确量化的思维模式，从而深刻理解线程决策对系统资源的实际影响。", "problem": "在现代操作系统 (OS) 中，单个进程为其所有线程维护一个共享的虚拟地址空间。操作系统以页面粒度强制执行分配和保护，并且典型的线程堆栈被预留为连续区域，并附有额外的未映射保护页以捕获溢出。考虑一个进程，其用户空间虚拟地址空间的上限为 $V$ 字节。与线程数量无关，该进程还有其他非堆栈虚拟内存映射，总大小为 $B$ 字节。每个线程（包括主线程）都会预留一个大小为 $S$ 字节的堆栈，外加 $g$ 个大小各为 $p$ 字节的未映射保护页，并且所有堆栈区域都是页对齐且互不相交的。假设没有其他每个线程的虚拟内存预留，并忽略微小的元数据开销。\n\n给定：\n- $V = 2.5 \\times 2^{30}$ 字节，\n- $B = 900 \\times 2^{20}$ 字节，\n- $S = 8 \\times 2^{20}$ 字节，\n- $g = 3$，\n- $p = 4096$ 字节。\n\n确定最大安全线程数 $T_{\\max}$（包括主线程），使得预留的虚拟地址空间总量不超过 $V$。请以无单位的精确整数形式报告您的答案。", "solution": "用户提供的问题陈述已经过严格验证，被认为是科学合理的、定义明确的且客观的。它不包含任何可辨别的缺陷、矛盾或歧义。所有必要的数据均已提供，并且该问题可以使用操作系统环境下的资源分配基本原则进行形式化求解。\n\n问题要求计算一个进程可以创建的最大线程数 $T_{\\max}$，而不使其预留的虚拟地址空间总量超过给定限制 $V$。\n\n设 $T$ 为进程中的线程数。预留的虚拟地址空间总量 $V_{total}$ 由两部分组成：用于非堆栈映射的固定大小部分 $B$，以及一个取决于线程数量的可变部分。\n\n为每个线程预留的空间包括其大小为 $S$ 的堆栈，以及 $g$ 个大小各为 $p$ 的保护页。因此，每个线程预留的总空间（我们可表示为 $S_{\\text{thread}}$）为：\n$$ S_{\\text{thread}} = S + g \\cdot p $$\n对于 $T$ 个线程，为所有线程特定结构预留的总空间为：\n$$ T \\cdot S_{\\text{thread}} = T (S + g \\cdot p) $$\n该进程预留的虚拟地址空间总量是非堆栈映射和所有与线程相关的映射的总和：\n$$ V_{\\text{total}} = B + T (S + g \\cdot p) $$\n问题规定，这个总预留量不得超过上限 $V$。此约束由以下不等式表示：\n$$ B + T (S + g \\cdot p) \\leq V $$\n为了找到最大线程数，我们必须求解满足此不等式的最大整数 $T$。我们可以重新排列不等式以分离出 $T$：\n$$ T (S + g \\cdot p) \\leq V - B $$\n$$ T \\leq \\frac{V - B}{S + g \\cdot p} $$\n由于线程数 $T$ 必须是整数，最大安全线程数 $T_{\\max}$ 是不等式右侧值的向下取整：\n$$ T_{\\max} = \\left\\lfloor \\frac{V - B}{S + g \\cdot p} \\right\\rfloor $$\n给定以下数值：\n- $V = 2.5 \\times 2^{30}$ 字节\n- $B = 900 \\times 2^{20}$ 字节\n- $S = 8 \\times 2^{20}$ 字节\n- $g = 3$\n- $p = 4096 = 2^{12}$ 字节\n\n首先，我们计算分子，它代表可用于线程预留的虚拟地址空间总量。将所有量表示为共同的基本单位（如字节）会很有帮助。\n为了计算 $V - B$，我们首先将 $V$ 表示为 $2^{20}$ 字节（兆字节）的倍数。\n$$ V = 2.5 \\times 2^{30} \\text{ 字节} = 2.5 \\times 2^{10} \\times 2^{20} \\text{ 字节} = 2.5 \\times 1024 \\times 2^{20} \\text{ 字节} = 2560 \\times 2^{20} \\text{ 字节} $$\n现在我们可以计算差值：\n$$ V - B = (2560 \\times 2^{20}) - (900 \\times 2^{20}) = (2560 - 900) \\times 2^{20} = 1660 \\times 2^{20} \\text{ 字节} $$\n其绝对字节值为：\n$$ V - B = 1660 \\times 1,048,576 = 1,740,636,160 \\text{ 字节} $$\n接下来，我们计算分母，即每个线程的总预留空间 $S + g \\cdot p$。\n$$ S = 8 \\times 2^{20} = 8 \\times 1,048,576 = 8,388,608 \\text{ 字节} $$\n$$ g \\cdot p = 3 \\times 4096 = 12,288 \\text{ 字节} $$\n每个线程的总预留空间为：\n$$ S + g \\cdot p = 8,388,608 + 12,288 = 8,400,896 \\text{ 字节} $$\n现在我们可以将这些值代回到关于 $T$ 的不等式中：\n$$ T \\leq \\frac{1,740,636,160}{8,400,896} $$\n进行除法运算：\n$$ T \\leq 207.19904... $$\n由于 $T$ 必须是整数，它能取的最大值 $T_{\\max}$ 是此结果的整数部分。\n$$ T_{\\max} = \\lfloor 207.19904... \\rfloor = 207 $$\n因此，最大安全线程数（包括主线程）为 $207$。", "answer": "$$\n\\boxed{207}\n$$", "id": "3688668"}, {"introduction": "在确定了进程可以容纳多少线程之后，我们自然会关注如何高效地配置每一个线程。线程栈的大小是一个关键的平衡艺术：它必须足够大以支持复杂的计算（尤其是递归），同时又要足够小以便在有限的内存预算下最大化并发度。这项练习 [@problem_id:3688677] 将通过把栈空间分解为函数调用帧、系统开销和安全裕量等组成部分，来揭开栈管理的神秘面纱，让你亲手计算出最小且安全的栈大小。", "problem": "一个并行的分治算法在一个操作系统（OS）下的多核机器上运行。每个工作线程执行一个递归程序，该程序将问题规模减半，直到达到大小为 $1$ 的基本情况。随机存取存储器（RAM）分配器为每个线程保留一个大小为 $S$ 字节的固定栈空间，该大小必须是页面大小 $p$ 的整数倍。操作系统为每个线程栈附加总共 $g$ 字节的不可访问的保护页，因此只有 $S - g$ 字节可用于线程执行。非递归的基线使用（线程运行时、调度器记账和每线程库状态）在可访问栈上占用 $h$ 字节。每次递归调用消耗一个大小为 $f$ 字节的固定栈帧。为了容忍异步事件（例如，信号处理器和中断），必须在可访问栈上保留 $r$ 字节的保守余量。\n\n该算法处理 $n = 2^{20}$ 个元素，通过不断减半直到规模为 $1$。页面大小 $p = 4096$ 字节，保护页总大小 $g = 8192$ 字节，基线栈使用量 $h = 32768$ 字节，每次递归调用的栈帧大小 $f = 384$ 字节，异步事件余量 $r = 24576$ 字节。应用程序二进制接口（ABI）确保递归深度等于将 $n$ 减小到 $1$ 所需的减半步骤数。\n\n假设所有线程的栈内存总预算是固定的；最大化并发性意味着选择安全的最小栈大小，因为在预算固定的情况下，线程数与 $S$ 成反比。使用第一性原理从减半过程中推导出递归深度，然后推导出防止栈溢出的关于 $S$ 的安全条件。根据该条件，确定满足页面大小对齐的最小安全 $S$。以字节为单位表示最终的栈大小。除了整数页对齐外，不需要进行其他舍入。", "solution": "对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n- 算法：并行的分治算法，递归地将问题规模减半。\n- 基本情况大小：$1$。\n- 总问题规模：$n = 2^{20}$ 个元素。\n- 每线程栈大小：$S$ 字节。\n- 页面大小：$p = 4096$ 字节。\n- $S$ 的约束：必须是 $p$ 的整数倍。\n- 保护页总大小：$g = 8192$ 字节。\n- 非递归基线栈使用量：$h = 32768$ 字节。\n- 每次递归调用的栈帧大小：$f = 384$ 字节。\n- 异步事件余量：$r = 24576$ 字节。\n- 递归深度：等于将 $n$ 减小到 $1$ 所需的减半步骤数。\n\n### 步骤2：使用提取的给定信息进行验证\n根据验证标准对问题进行评估。\n- **科学性**：该问题基于计算机科学和操作系统中公认的概念，包括线程内存管理（栈）、保护页、递归、栈帧和内存页对齐。该场景真实地描绘了在高性能和系统编程中的考量。\n- **问题明确**：该问题提供了所有必要的数值和约束，以确定一个唯一的最小栈大小 $S$。目标陈述清晰。\n- **客观性**：该问题使用精确、无歧义的技术术语进行描述。没有主观或基于观点的陈述。\n- 该问题没有表现出任何列出的缺陷。它是自包含的、逻辑一致的且计算上可行的。所提供的值对于现代计算环境是合理的。\n\n### 步骤3：结论与行动\n问题有效。将提供完整的解决方案。\n\n目标是找到最小的安全每线程栈大小 $S$，该大小是页面大小 $p$ 的整数倍。\n\n首先，我们必须确定递归深度，记为 $d$。该算法从一个大小为 $n$ 的问题开始，递归地将其减半，直到大小变为 $1$。经过 $k$ 次递归调用后，问题大小为 $\\frac{n}{2^k}$。当大小为 $1$ 时，递归在基本情况下停止。因此，深度 $d$ 必须满足以下方程：\n$$\n\\frac{n}{2^d} = 1\n$$\n求解 $d$，我们得到 $2^d = n$，这意味着 $d = \\log_2(n)$。给定 $n = 2^{20}$，递归深度为：\n$$\nd = \\log_2(2^{20}) = 20\n$$\n\n接下来，我们建立栈大小的安全条件。为线程栈分配的总内存是 $S$。但是，其中一部分 $g$ 用于不可访问的保护页。因此，线程可访问或可用的栈空间是 $S_{usable} = S - g$。\n\n线程执行所需的总栈空间 $U_{req}$ 必须小于或等于可用栈空间。这个所需的空间是三个部分的总和：\n1. 非递归基线使用量 $h$。\n2. 所有递归调用的栈帧总大小，即深度 $d$ 乘以栈帧大小 $f$。这是 $d \\times f$。\n3. 用于异步事件的保守余量 $r$。\n\n所以，所需的总栈空间为：\n$$\nU_{req} = h + d \\times f + r\n$$\n因此，安全条件是：\n$$\nU_{req} \\le S_{usable}\n$$\n$$\nh + d \\times f + r \\le S - g\n$$\n为了找到可能的最小栈大小 $S$，我们可以解出 $S$：\n$$\nS \\ge h + d \\times f + r + g\n$$\n我们将考虑页面对齐之前的最小所需大小称为 $S_{min\\_raw}$。这对应于等式：\n$$\nS_{min\\_raw} = h + d \\times f + r + g\n$$\n代入给定值：\n- $h = 32768$ 字节\n- $d = 20$\n- $f = 384$ 字节\n- $r = 24576$ 字节\n- $g = 8192$ 字节\n\n我们可以计算 $S_{min\\_raw}$：\n$$\nS_{min\\_raw} = 32768 + (20 \\times 384) + 24576 + 8192\n$$\n$$\nS_{min\\_raw} = 32768 + 7680 + 24576 + 8192\n$$\n$$\nS_{min\\_raw} = 73216 \\text{ 字节}\n$$\n\n最后，我们应用栈大小 $S$ 必须是页面大小 $p = 4096$ 字节的整数倍这一约束。这意味着对于某个整数 $k$，$S = k \\times p$。我们需要找到满足 $S \\ge S_{min\\_raw}$ 的最小整数 $k$。\n$$\nk \\times p \\ge S_{min\\_raw}\n$$\n$$\nk \\times 4096 \\ge 73216\n$$\n求解 $k$：\n$$\nk \\ge \\frac{73216}{4096}\n$$\n$$\nk \\ge 17.875\n$$\n由于 $k$ 必须是整数，所以 $k$ 的最小整数值是 $18$。因此，最小的安全栈大小 $S$ 是：\n$$\nS = 18 \\times p = 18 \\times 4096\n$$\n$$\nS = 73728 \\text{ 字节}\n$$\n这个栈大小满足安全条件（$73728 \\ge 73216$）和对齐约束（$73728$ 是 $4096$ 的倍数）。", "answer": "$$\n\\boxed{73728}\n$$", "id": "3688677"}, {"introduction": "当我们正确地分配了线程资源后，最后一个也是最微妙的挑战，便是确保共享数据时的程序正确性。为了追求性能，现代处理器和编译器会重排指令，这可能打破我们对于程序顺序执行的直观假设。这项练习 [@problem_id:3688611] 通过一个经典的并发“捉虫”场景，让你深入探索内存一致性模型的概念。它将揭示非原子操作如何导致意外结果，并引入内存栅栏（memory fences）作为强制执行顺序、确保线程间写入可见性的关键工具。", "problem": "您将为一个双线程程序建模，并使用一个简化的内存系统来推断一个结果，该系统旨在捕捉线程级优势和并发陷阱背后的核心直觉。目标是检测在不同的线程内排序约束下，某一特定的并发异常是否可能发生，然后量化插入栅栏如何改变该异常的可达性。最终程序必须为给定的测试套件计算这些结果，并以要求的格式打印它们。\n\n考虑两个线程 $T_1$ 和 $T_2$ 操作共享变量 $x$ 和 $y$，初始值为 $x = 0$ 和 $y = 0$。线程 $T_1$ 执行一次对 $x$ 的存储，然后从 $y$ 加载值到寄存器 $r_1$。线程 $T_2$ 执行一次对 $y$ 的存储，然后从 $x$ 加载值到寄存器 $r_2$。我们关心的是否可能出现 $r_1 = 0$ 且 $r_2 = 0$ 的结果。\n\n从以下经过充分测试的基础定义出发：\n- 顺序一致性 (Lamport)：每次执行都等效于所有线程操作的某种交错，且这种交错尊重每个线程的程序顺序。\n- 来自广泛讲授的计算机体系结构的存储缓冲区直觉：线程本地的缓冲区可以延迟其存储操作对其他线程的可见性，直到缓冲区刷新；读取操作会观察相同位置上最新的本地缓冲值（如果存在），否则观察全局可见值。\n\n我们使用以下简化的存储缓冲内存模型，它在保持科学真实性的同时，在计算上仍然是可行的：\n- 每个线程维护一个本地写缓冲区。对变量 $v \\in \\{x,y\\}$ 的一次存储操作 $W(v,1)$ 会将值 $1$ 放入该线程对应于 $v$ 的缓冲区中；$v$ 的共享内存直到缓冲区刷新时才会改变。\n- 一次读取操作 $R(v)$ 会返回该线程对应于 $v$ 的缓冲值（如果存在）；否则返回 $v$ 的当前共享内存值。\n- 线程内的程序顺序得到遵守：操作按其编写的顺序发生。\n- 栅栏在其出现的位置将线程的本地缓冲区刷新到共享内存。\n- 线程间交错是任意的：$T_1$ 和 $T_2$ 的操作可以以任何保持各自线程程序顺序的方式交错。\n\n在此模型下，结果 $r_1 = 0$ 且 $r_2 = 0$ 是可能的，当且仅当每个线程都在另一个线程的缓冲写入刷新到共享内存之前执行其读取操作。放置在线程的存储操作和其后续读取操作之间的栅栏，能确保该线程的缓冲写入在该读取之前被刷新，从而消除部分或所有本可能导致 $r_1 = 0$ 且 $r_2 = 0$ 结果的执行。\n\n参数化：\n- 对于线程 $T_i$ ($i \\in \\{1,2\\}$)，令 $p_i \\in \\{0,1,2,3\\}$ 表示栅栏位置：\n  - $p_i = 0$：无栅栏，\n  - $p_i = 1$：栅栏在存储之前（$\\text{fence};\\ W;\\ R$），\n  - $p_i = 2$：栅栏在存储和读取之间（$W;\\ \\text{fence};\\ R$），\n  - $p_i = 3$：栅栏在读取之后（$W;\\ R;\\ \\text{fence}$）。\n- 栅栏仅在程序顺序中的相应位置刷新发起线程的缓冲区。\n- 我们定义一个布尔函数，如果在简化模型和给定的 $p_1$ 和 $p_2$ 下，结果 $r_1 = 0$ 且 $r_2 = 0$ 是可达的，则返回 $1$，否则返回 $0$。\n\n测试套件：\n- 情况 1：$p_1 = 0$, $p_2 = 0$。基准：无栅栏。\n- 情况 2：$p_1 = 2$, $p_2 = 2$。在每次存储和读取之间放置栅栏。\n- 情况 3：$p_1 = 2$, $p_2 = 0$。仅在 $T_1$ 的存储和读取之间放置栅栏。\n- 情况 4：$p_1 = 3$, $p_2 = 3$。仅在读取之后放置栅栏。\n\n您的程序应生成单行输出，其中包含一个逗号分隔的列表，并用方括号括起来（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_k \\in \\{0,1\\}$ 是上述布尔值。输出中不允许有空格。\n\n不涉及物理单位和角度。所有输出均为 $\\{0,1\\}$ 中的整数。", "solution": "该问题陈述清晰且科学上合理。它提出了一个简化但逻辑上一致的内存模型，用于探讨线程级并发、程序顺序和内存栅栏等基本概念。该模型是在操作系统和计算机体系结构课程中引入内存一致性问题的标准教学工具。所有术语都有定义，初始状态已指定，目标明确。因此，可以进行严谨的分析。\n\n问题的核心是确定寄存器 $r_1=0$ 和寄存器 $r_2=0$ 这一结果的可达性。让我们将模型形式化，并分析达成此结果所需的条件。\n\n**1. 形式化模型**\n\n- **状态**：系统的状态是一个元组 $(M, B_1, B_2)$，其中 $M$ 是将变量映射到值的共享内存，而 $B_i$ 是线程 $T_i$ 的私有存储缓冲区。初始时，$M(x)=0$，$M(y)=0$，且缓冲区 $B_1, B_2$ 为空。\n- **操作**：\n    - 存储 $W_i(v, k)$：线程 $T_i$ 将值 $k$ 写入变量 $v$。这会更新本地缓冲区，$B_i(v) \\leftarrow k$。\n    - 加载 $R_i(v) \\rightarrow r_i$：线程 $T_i$ 将变量 $v$ 的值读入其寄存器 $r_i$。读取的值是 $B_i(v)$（如果存在）；否则为 $M(v)$。\n    - 栅栏 $F_i$：线程 $T_i$ 将其缓冲区 $B_i$ 刷新到共享内存。对于 $B_i$ 中的每个变量 $v$，$M(v) \\leftarrow B_i(v)$，并从 $B_i$ 中清除 $v$ 的条目。\n- **线程程序**：\n    - $T_1$：操作 $x$ 和 $y$。基本序列为 $W_1(x,1); R_1(y) \\rightarrow r_1$。\n    - $T_2$：操作 $y$ 和 $x$。基本序列为 $W_2(y,1); R_2(x) \\rightarrow r_2$。\n- **执行**：一次执行是所有线程中所有操作的一个全序排列，该排列尊重每个线程内部的程序顺序。令 $\\xrightarrow{PO}$ 表示程序顺序，$\\xrightarrow{EXE}$ 表示全局执行顺序。\n\n**2. 结果 $r_1=0 \\land r_2=0$ 的条件**\n\n为使结果 $r_1=0$ 发生，加载操作 $R_1(y)$ 必须返回 $0$。由于线程 $T_1$ 从不写入 $y$，其缓冲区 $B_1$ 中关于 $y$ 的条目始终为空。因此，$R_1(y)$ 总是从共享内存 $M(y)$ 读取。线程 $T_2$ 的操作 $W_2(y,1)$ 只有在 $T_2$ 执行栅栏 $F_2$ 时，才会将 $M(y)$ 从 $0$ 改为 $1$。因此，为了得到 $r_1=0$，操作 $R_1(y)$ 必须在全局执行顺序中发生在 $F_2$ 之前（如果 $F_2$ 存在）。\n$r_1=0$ 的条件：$R_1(y) \\xrightarrow{EXE} F_2$。\n\n类似地，为使结果 $r_2=0$ 发生，加载操作 $R_2(x)$ 必须返回 $0$。由于 $T_2$ 从不写入 $x$，$R_2(x)$ 从 $M(x)$ 读取。$T_1$ 的操作 $W_1(x,1)$ 只有在执行 $F_1$ 时才会将 $M(x)$ 改为 $1$。因此，为了得到 $r_2=0$，$R_2(x)$ 必须发生在 $F_1$ 之前（如果 $F_1$ 存在）。\n$r_2=0$ 的条件：$R_2(x) \\xrightarrow{EXE} F_1$。\n\n结果 $r_1=0 \\land r_2=0$ 是可达的，当且仅当存在一个有效的执行轨迹同时满足这些条件。\n\n**3. 栅栏位置的通用分析**\n\n参数 $p_i \\in \\{0, 1, 2, 3\\}$ 决定了线程 $T_i$ 的程序顺序。我们分析关键情况 $p_i=2$，即将栅栏置于存储和加载之间。\n\n- 如果 $p_1=2$，则 $T_1$ 的程序顺序为 $W_1(x,1) \\xrightarrow{PO} F_1 \\xrightarrow{PO} R_1(y)$。\n- 如果 $p_2=2$，则 $T_2$ 的程序顺序为 $W_2(y,1) \\xrightarrow{PO} F_2 \\xrightarrow{PO} R_2(x)$。\n\n让我们分析 $p_1=2$ 和 $p_2=2$ 的情况。为使目标结果可达，我们需要满足以下排序约束：\n1. $R_2(x) \\xrightarrow{EXE} F_1$ (为了 $r_2=0$)\n2. $F_1 \\xrightarrow{EXE} R_1(y)$ (根据 $T_1$ 的程序顺序，因为 $p_1=2$)\n3. $R_1(y) \\xrightarrow{EXE} F_2$ (为了 $r_1=0$)\n4. $F_2 \\xrightarrow{EXE} R_2(x)$ (根据 $T_2$ 的程序顺序，因为 $p_2=2$)\n\n结合这些约束，我们发现一个循环：\n- 从 (1) 和 (2)：$R_2(x) \\xrightarrow{EXE} F_1 \\xrightarrow{EXE} R_1(y) \\implies R_2(x) \\xrightarrow{EXE} R_1(y)$。\n- 从 (3) 和 (4)：$R_1(y) \\xrightarrow{EXE} F_2 \\xrightarrow{EXE} R_2(x) \\implies R_1(y) \\xrightarrow{EXE} R_2(x)$。\n\n这两个推导出的约束，$R_2(x) \\xrightarrow{EXE} R_1(y)$ 和 $R_1(y) \\xrightarrow{EXE} R_2(x)$，构成逻辑矛盾。一个操作的全序排列不能存在循环。因此，当 $p_1=2$ 且 $p_2=2$ 时，结果 $r_1=0 \\land r_2=0$ 是不可达的。\n\n现在，考虑任何其他情况，即 $p_1 \\neq 2$ 或 $p_2 \\neq 2$。这意味着至少有一个程序顺序约束（$F_1 \\xrightarrow{PO} R_1(y)$ 或 $F_2 \\xrightarrow{PO} R_2(x)$）不存在。这就打破了循环。对于所有这类情况，我们都可以构建一个有效的执行轨迹。例如，只要循环被打破，以下轨迹就成立：\n$W_1(x,1) \\xrightarrow{EXE} W_2(y,1) \\xrightarrow{EXE} R_1(y) \\xrightarrow{EXE} R_2(x) \\xrightarrow{EXE} ...$ (任何剩余的栅栏)。\n- 在 $R_1(y)$ 执行时，$F_2$ 尚未执行（无论 $p_2$ 为何值），所以 $r_1=0$。\n- 在 $R_2(x)$ 执行时，$F_1$ 尚未执行（无论 $p_1$ 为何值），所以 $r_2=0$。\n只要此序列不违反程序顺序，它就是有效的。有问题的程序顺序是 $F_1 \\xrightarrow{PO} R_1$ 和 $F_2 \\xrightarrow{PO} R_2$。只要这两个中至少有一个不被强制执行，我们就可以将读取操作交错到有问题的栅栏之前，从而使该结果成为可能。\n\n因此，通用规则是：结果 $r_1=0 \\land r_2=0$ 是可达的，当且仅当不满足 $(p_1=2 \\text{ and } p_2=2)$ 的情况。\n\n**4. 应用于测试套件**\n\n我们将此推导出的规则应用于具体的测试用例。\n\n- **情况 1：$p_1 = 0, p_2 = 0$。**\n这不属于 $(p_1=2, p_2=2)$ 的情况。结果是可达的。结果：$1$。\n\n- **情况 2：$p_1 = 2, p_2 = 2$。**\n这正是产生无法打破的依赖循环的情况。结果是不可达的。结果：$0$。\n\n- **情况 3：$p_1 = 2, p_2 = 0$。**\n这不属于 $(p_1=2, p_2=2)$ 的情况，因为 $p_2 \\neq 2$。结果是可达的。结果：$1$。\n\n- **情况 4：$p_1 = 3, p_2 = 3$。**\n这不属于 $(p_1=2, p_2=2)$ 的情况，因为 $p_1 \\neq 2$ 且 $p_2 \\neq 2$。结果是可达的。结果：$1$。\n\n最终的结果序列是 $[1, 0, 1, 1]$。", "answer": "[1,0,1,1]", "id": "3688611"}]}