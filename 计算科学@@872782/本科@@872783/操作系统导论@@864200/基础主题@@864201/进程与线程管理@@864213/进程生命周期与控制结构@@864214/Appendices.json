{"hands_on_practices": [{"introduction": "要真正掌握进程控制，我们必须首先建立一个关于进程状态机的坚实心智模型。本练习模拟了一个子进程在不同条件下的生命周期，例如接收信号以及其父进程的不同行为。通过亲手追踪其状态转换——从运行到停止，最终到僵尸或被回收——你将对操作系统如何管理进程获得具体的理解。这项练习 [@problem_id:3672144] 是调试和预测复杂应用程序行为的一项基本技能。", "problem": "您需要设计并实现一个独立的模拟程序，模拟父子进程交互。该模拟需与可移植操作系统接口 (POSIX) 信号模型和进程生命周期规则的通用语义保持一致。模拟必须从基本原理开始：进程状态的定义、信号（包括名为 `SIGSTOP` 的信号）的行为，以及由进程控制块 (PCB) 体现的父子资源核算关系。进程控制块 (PCB) 是一个逻辑记录，用于保存进程的状态、标识符和核算信息。一个进程拥有一个进程标识符 (PID) 和一个用户标识符 (UID)。父进程是通过一个类似 fork 的操作创建子进程的创建者，并负责在子进程终止时通过一个类似 wait 的操作来回收它，否则子进程可能会短暂进入一个通常被描述为僵尸进程的终止后状态。当一个进程向自身发送 `SIGSTOP` 信号时，它会转换到停止状态，此状态下它无法被调度，直到收到来自授权进程的恢复信号（如 `SIGCONT`）。在此模型中，发送恢复信号的授权被赋予存活的父进程或任何与目标进程具有相同 `UID` 的进程；具有不同 `UID` 的进程无法恢复目标进程。如果父进程在子进程仍然存活时退出，子进程将成为孤儿进程，并被一个特殊的系统进程收养，该系统进程总是会回收已终止的孤儿进程，从而消除了持续的僵尸进程风险。\n\n基本基础：\n- 进程存在于以下状态之一：$RUNNING$、$STOPPED$、$ZOMBIE$ 或 $REAPED$。为了在此模拟中进行观察，孤儿进程的运行或停止状态分别表示为 $ORPHAN\\_RUNNING$ 和 $ORPHAN\\_STOPPED$。\n- 进程生命周期语义如下：\n  1. 通过类似 fork 的事件创建子进程会产生父子关系，两个进程都处于 $RUNNING$ 状态。\n  2. 一个向自身发送 `SIGSTOP` 信号的子进程会从 $RUNNING$ 转换到 $STOPPED$ 状态。\n  3. 一个处于 $STOPPED$ 状态的子进程只有在收到来自授权进程的 `SIGCONT` 信号后才能转换回 $RUNNING$ 状态。授权被授予存活的父进程或任何具有相同 `UID` 的进程。\n  4. 如果父进程在子进程仍然存活时退出，子进程将成为孤儿进程，并被一个会回收已终止子进程的系统进程收养。\n  5. 如果子进程在其父进程存活时终止，而父进程没有执行类似 wait 的操作来回收它，子进程将成为 $ZOMBIE$。如果父进程执行了类似 wait 的操作，子进程将立即成为 $REAPED$。如果父进程已经退出，孤儿进程将被系统进程回收，因此消除了持续的僵尸进程风险。\n\n您的程序必须实现以下逻辑模型：\n- 从一个父进程 $P$ 和一个子进程 $C$ 开始。两者都以 $RUNNING$ 状态开始。\n- 创建后，子进程 $C$ 立即向自身发送 `SIGSTOP` 信号，使 $C$ 从 $RUNNING$ 转换到 $STOPPED$ 状态。\n- 以下事件根据每个测试用例进行参数化，每个事件都是 $\\{0, 1\\}$ 中的一个布尔值：\n  - `c_p`: 父进程 $P$ 是否在 $P$ 存活时尝试向 $C$ 发送 `SIGCONT`。\n  - `e_p`: 父进程 $P$ 是否在 $P$ 成功恢复 $C$ 之前退出。\n  - `c_s`: 是否有相同 `UID` 的第三方进程尝试向 $C$ 发送 `SIGCONT`。\n  - `c_d`: 是否有不同 `UID` 的第三方进程尝试向 $C$ 发送 `SIGCONT`。\n  - `w_p`: 在 $C$ 终止后，如果 $P$ 此时仍然存活，父进程 $P$ 是否执行类似 wait 的操作。\n- 只有当恢复尝试由一个在尝试时存活的授权进程发起时，该尝试才会成功。如果 `e_p` = 1，那么父进程 $P$ 之后不能执行 `SIGCONT` 或类似 wait 的操作。\n\n终止和僵尸-孤儿语义：\n- 如果 $C$ 处于 $RUNNING$ 状态，它最终可以终止。当 $C$ 终止时：\n  - 如果 $P$ 存活且 `w_p` = 1，则 $C$ 转换到 $REAPED$ 状态。\n  - 如果 $P$ 存活且 `w_p` = 0，则 $C$ 转换到 $ZOMBIE$ 状态。\n  - 如果 $P$ 已经退出 (`e_p` = 1)，$C$ 是一个孤儿进程，并将被系统进程回收，转换到 $REAPED$ 状态，没有持续的僵尸进程风险。\n- 如果由于没有授权的恢复成功，$C$ 保持在 $STOPPED$ 状态，并且 $P$ 退出，则 $C$ 转换到 $ORPHAN\\_STOPPED$ 状态，并且在此模型中，没有参数所代表的外部操作，它无法终止。\n\n定义输出编码：\n- 状态码：$0 \\rightarrow RUNNING$、$1 \\rightarrow STOPPED$、$2 \\rightarrow ORPHAN\\_STOPPED$、$3 \\rightarrow ORPHAN\\_RUNNING$、$4 \\rightarrow ZOMBIE$、$5 \\rightarrow REAPED$。\n- 对于每个测试用例，您的程序必须按顺序输出三个值：最终的子进程状态码、恢复成功指示符和僵尸风险指示符。如果任何授权的恢复成功，则恢复成功指示符为 $1$，否则为 $0$。如果 $C$ 因为 $P$ 在存活时未执行类似 wait 的操作而进入 $ZOMBIE$ 状态，则僵尸风险指示符为 $1$；否则为 $0$。\n\n测试套件：\n- 测试用例 1：(`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (1, 0, 0, 0, 1)。\n- 测试用例 2：(`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (0, 1, 1, 0, 0)。\n- 测试用例 3：(`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (0, 1, 0, 1, 0)。\n- 测试用例 4：(`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (1, 0, 0, 0, 0)。\n\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须是上述测试用例按顺序的三元组的串联，即 $[state\\_1,resumed\\_1,zombie\\_1,state\\_2,resumed\\_2,zombie\\_2,state\\_3,resumed\\_3,zombie\\_3,state\\_4,resumed\\_4,zombie\\_4]$，其中每个 $state\\_i$ 是最终的子进程状态码，每个 $resumed\\_i$ 和 $zombie\\_i$ 是 $\\{0, 1\\}$ 中的布尔值。", "solution": "问题陈述已经过验证并被认为是可靠的。其科学基础在于操作系统进程管理的原理，问题定义良好，具有清晰完整的规则集，并使用客观、可形式化的语言表述。不存在矛盾、歧义或事实错误。通过逻辑应用所提供的规则可以确定唯一的解。\n\n该问题要求基于一组控制其与父进程及其他进程交互的参数，模拟一个子进程的生命周期。必须为四个不同的测试用例确定子进程 $C$ 的最终状态，以及恢复成功和僵尸风险的指示符。状态编码如下：$RUNNING \\rightarrow 0$、$STOPPED \\rightarrow 1$、$ORPHAN\\_STOPPED \\rightarrow 2$、$ORPHAN\\_RUNNING \\rightarrow 3$、$ZOMBIE \\rightarrow 4$、$REAPED \\rightarrow 5$。\n\n子进程 $C$ 的初始状态是 $STOPPED$（代码 $1$），因为它在创建后立即向自身发送一个 `SIGSTOP` 信号。从此状态开始的演变取决于是否收到成功的恢复信号 (`SIGCONT`)。\n\n逻辑的核心在于一个两阶段分析：首先，确定子进程是否被恢复；其次，根据恢复尝试的结果以及父进程 $P$ 的后续行为确定其最终状态。\n\n**阶段 1：恢复成功分析**\n\n如果恢复尝试源于一个授权进程，则该尝试是成功的。根据问题规范，授权被授予：\n1. 父进程 $P$，前提是它在发送信号时是存活的。参数 `e_p`=1 表示父进程提前退出，使其无法发送信号。因此，父进程的恢复尝试 (`c_p`=1) 仅在 `e_p`=0 时成功。\n2. 任何与子进程具有相同用户标识符 ($UID$) 的第三方进程。这由参数 `c_s`=1 表示。\n3. 来自不同 $UID$ 进程的尝试 (`c_d`=1) 永远不会被授权。\n\n设 $R_s$ 为恢复成功的布尔指示符（$1$ 表示成功，$0$ 表示失败）。成功条件由授权尝试的逻辑或得出：\n$$R_s = (c_p \\land \\neg e_p) \\lor c_s$$\n其中参数被解释为布尔值（$1$ 为真，$0$ 为假）。\n\n**阶段 2：最终状态确定**\n\n子进程 $C$ 的最终状态取决于 $R_s$ 以及控制父进程存活性 (`e_p`) 和回收行为 (`w_p`) 的参数。\n\n*   **如果恢复失败 ($R_s = 0$)：**\n    子进程 $C$ 永远不会被恢复并保持在停止状态。其最终状态取决于父进程的存活性：\n    *   如果父进程保持存活 (`e_p`=0)，子进程的状态是 $STOPPED$（代码 $1$）。\n    *   如果父进程退出 (`e_p`=1)，子进程在停止时成为孤儿进程，其状态是 $ORPHAN\\_STOPPED$（代码 $2$）。在此模型中，这是一个终结状态。\n\n*   **如果恢复成功 ($R_s = 1$)：**\n    子进程 $C$ 转换到 $RUNNING$ 状态并最终会终止。其终止后的最终状态取决于它是否被回收以及由谁回收。\n    *   如果父进程保持存活 (`e_p`=0)：子进程终止时父进程可用于回收它。\n        *   如果父进程执行类似 wait 的操作 (`w_p`=1)，子进程被正确回收，其最终状态是 $REAPED$（代码 $5$）。僵尸风险为 $0$。\n        *   如果父进程不等待 (`w_p`=0)，子进程进入 $ZOMBIE$ 状态（代码 $4$）。这是存在僵尸风险的唯一条件，因此僵尸风险指示符为 $1$。\n    *   如果父进程退出 (`e_p`=1)：运行中的子进程成为孤儿进程。其状态暂时为 $ORPHAN\\_RUNNING$（代码 $3$）。终止后，它会被指定的系统进程自动回收。其最终状态是 $REAPED$（代码 $5$），并且没有持续的僵尸风险。\n\n我们现在将此形式逻辑应用于每个测试用例。\n\n**测试用例 1: (`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (1, 0, 0, 0, 1)**\n1.  **恢复成功 ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$。恢复成功。\n2.  **最终状态:** 由于 $R_s=1$ 且父进程存活 (`e_p`=0)，子进程进入 $RUNNING$ 状态并终止。父进程执行 wait 操作 (`w_p`=1)。子进程被回收。\n    *   最终状态码: $5$ ($REAPED$)\n    *   恢复成功指示符: $1$\n    *   僵尸风险指示符: $0$\n    *   结果: $(5, 1, 0)$\n\n**测试用例 2: (`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (0, 1, 1, 0, 0)**\n1.  **恢复成功 ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 1 = 0 \\lor 1 = 1$。恢复成功（来自相同 $UID$ 的进程）。\n2.  **最终状态:** 由于 $R_s=1$ 且父进程退出 (`e_p`=1)，子进程在运行时成为孤儿进程 ($ORPHAN\\_RUNNING$)。终止后，它被系统回收。\n    *   最终状态码: $5$ ($REAPED$)\n    *   恢复成功指示符: $1$\n    *   僵尸风险指示符: $0$\n    *   结果: $(5, 1, 0)$\n\n**测试用例 3: (`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (0, 1, 0, 1, 0)**\n1.  **恢复成功 ($R_s$):** $R_s = (0 \\land \\neg 1) \\lor 0 = 0 \\lor 0 = 0$。恢复失败。请注意，来自不同 $UID$ 进程的尝试 (`c_d`=1) 未被授权，没有效果。\n2.  **最终状态:** 由于 $R_s=0$ 且父进程退出 (`e_p`=1)，停止的子进程成为孤儿进程。\n    *   最终状态码: $2$ ($ORPHAN\\_STOPPED$)\n    *   恢复成功指示符: $0$\n    *   僵尸风险指示符: $0$\n    *   结果: $(2, 0, 0)$\n\n**测试用例 4: (`c_p`, `e_p`, `c_s`, `c_d`, `w_p`) = (1, 0, 0, 0, 0)**\n1.  **恢复成功 ($R_s$):** $R_s = (1 \\land \\neg 0) \\lor 0 = 1 \\lor 0 = 1$。恢复成功。\n2.  **最终状态:** 由于 $R_s=1$ 且父进程存活 (`e_p`=0)，子进程进入 $RUNNING$ 状态并终止。父进程不执行 wait 操作 (`w_p`=0)。子进程成为僵尸进程。\n    *   最终状态码: $4$ ($ZOMBIE$)\n    *   恢复成功指示符: $1$\n    *   僵尸风险指示符: $1$\n    *   结果: $(4, 1, 1)$\n\n四个测试用例的结果串联列表为 $[5,1,0,5,1,0,2,0,0,4,1,1]$。", "answer": "[5,1,0,5,1,0,2,0,0,4,1,1]", "id": "3672144"}, {"introduction": "每一次进程状态转换，特别是抢占，都会带来性能开销。在实时系统中，这种开销不仅仅是性能上的拖累，它甚至决定了系统能否满足关键的截止时间要求。本练习 [@problem_id:3672223] 要求你通过推导一个实时任务的可调度性条件来量化这一成本。你将学会如何计算一个进程所能承受的最大抢占次数，从而将进程控制块 ($PCB$) 和上下文切换等抽象概念与严格的实时约束联系起来。", "problem": "一个单个硬实时进程 $P$ 在时间 $t = 0$ 被释放，其相对截止时间为 $D$，从其释放时间开始计算。该进程 $P$ 一旦被调度，需要 $C$ 个单位的中央处理器（CPU）执行时间来完成其任务。操作系统使用一个完全抢占式调度器，$P$ 的每次抢占都会导致其状态从运行态转换到就绪态，之后再转换回运行态。$P$ 的每一次这样的抢占都会产生一个确定性的、恒定的开销 $c$，该开销包括保存和恢复进程控制块（PCB）、调度器的簿记工作，以及与抢占相关的任何中断服务例程的有界执行。假设 $c > 0$，$D \\ge C$，$P$ 不会发生输入/输出阻塞，并且所有状态转换和控制结构都如指定的那样确定性地运行。\n\n在 $P$ 的执行窗口期间，假设它由于更高优先级的活动或外部事件而遭受了恰好 $k$ 次抢占，每次抢占都如前所述贡献了开销 $c$。从“一个任务是可调度的当且仅当其最坏情况响应时间小于或等于其相对截止时间”这个基本定义出发，并根据进程状态和上下文切换的语义进行推理，请推导出用 $C$、$c$、$k$ 和 $D$ 表示的可调度性要求。然后，将 $k$ 视为一个由系统设计（例如，通过优先级分配或中断屏蔽策略）控制的整数决策变量，确定仍然能保证 $P$ 满足其截止时间的最大允许整数抢占次数 $k_{\\max}$。\n\n请将您的最终答案表示为一个用 $D$、$C$ 和 $c$ 来表示 $k_{\\max}$ 的闭式解析表达式。", "solution": "问题要求我们确定单个硬实时进程 $P$ 的可调度性条件，并由此推导出它在满足其截止时间的同时所能承受的最大抢占次数。分析将基于实时调度和进程管理的基本原理。\n\n首先，让我们形式化进程执行时间线的各个组成部分。进程 $P$ 在时间 $t = 0$ 被释放，并且必须在其相对截止时间 $D$ 之前完成执行。该进程需要总共 $C$ 个单位的CPU时间用于其自身的计算。系统是抢占式的，在其执行期间，进程 $P$ 被抢占了恰好 $k$ 次。\n\n每次抢占都会产生一个确定性的开销 $c$。这个开销计算的是CPU用于处理系统任务而非应用程序代码的时间，例如将 $P$ 的上下文保存到其进程控制块（PCB）中，执行调度器以选择另一个进程，并在 $P$ 再次被调度运行时最终恢复其上下文。问题描述还将“与抢占相关的任何中断服务例程的有界执行”包含在此开销 $c$ 中。\n\n为确保进程 $P$ 的完成，CPU必须服务的总工作负载是其自身计算需求与因抢占而产生的总开销之和。\n进程的内在计算工作负载是 $C$。\n有 $k$ 次抢占，每次产生开销 $c$，因此总开销工作负载是乘积 $k \\cdot c$。\n\n因此，完成进程 $P$ 的任务所需的总有效CPU时间，记为 $C_{eff}$，是：\n$$C_{eff} = C + k \\cdot c$$\n\n一个进程的最坏情况响应时间 $R_{wc}$，是从其释放到其完成可能的最长时间间隔。在此模型中，给定恰好有 $k$ 次抢占事件。所提供的开销 $c$ 的定义包含了与这些抢占相关的所有时间成本。问题没有为其他更高优先级进程的执行时间提供模型；分析被限制在术语 $C$、$c$、$k$ 和 $D$ 上。这意味着来自更高优先级活动的干扰完全由这 $k$ 次离散的抢占事件及其总成本 $k \\cdot c$ 来表示。在此解释下，最坏情况是CPU必须执行总工作负载 $C_{eff}$ 而没有任何空闲时间。因此，最坏情况响应时间等于这个总有效工作负载。\n\n$$R_{wc} = C_{eff} = C + k \\cdot c$$\n\n问题指出，一个任务是可调度的当且仅当其最坏情况响应时间小于或等于其相对截止时间。对于进程 $P$，这个基本的可调度性条件是：\n$$R_{wc} \\le D$$\n\n代入我们推导出的 $R_{wc}$ 表达式，得到进程 $P$ 的具体可调度性要求：\n$$C + k \\cdot c \\le D$$\n\n这个不等式就是用给定参数 $C$、$c$、$k$ 和 $D$ 表示的可调度性要求。\n\n问题的第二部分要求找出保证可调度性的最大允许整数抢占次数，记为 $k_{\\max}$。为了找到这个值，我们必须对可调度性不等式求解 $k$。\n\n从不等式开始：\n$$C + k \\cdot c \\le D$$\n\n我们可以通过从两边减去 $C$ 来分离出包含 $k$ 的项：\n$$k \\cdot c \\le D - C$$\n\n问题指定开销 $c$ 是正的，即 $c > 0$。因此，我们可以将不等式两边都除以 $c$ 而不改变不等号的方向：\n$$k \\le \\frac{D - C}{c}$$\n\n这个不等式定义了抢占次数的上限。由于 $k$ 必须是一个整数（因为它代表离散事件的计数），$k$ 的最大允许值，即 $k_{\\max}$，是满足此条件的最大整数。根据定义，这是右侧表达式的向下取整（floor）函数值。\n\n$$k_{\\max} = \\left\\lfloor \\frac{D - C}{c} \\right\\rfloor$$\n\n给定条件 $D \\ge C$ 和 $c > 0$ 确保了向下取整函数的参数 $\\frac{D - C}{c}$ 是非负的，这与 $k$ 作为非负的抢占次数计数是一致的。这个闭式表达式表示进程 $P$ 在保证满足其截止时间 $D$ 的情况下可以承受的最大抢占次数。", "answer": "$$\n\\boxed{\\left\\lfloor \\frac{D - C}{c} \\right\\rfloor}\n$$", "id": "3672223"}, {"introduction": "现在，让我们综合所学知识，解决一个经典的系统编程挑战：如何可靠地启动一个新程序，同时保证不留下任何僵尸进程。本练习 [@problem_id:3672175] 将指导你使用管道设计一个父子进程间的通信握手协议。你将探索文件描述符、`FD_CLOEXEC` 标志以及 `fork`、`exec` 和 `wait` 系统调用的精确顺序所扮演的关键角色，以确保正确的资源清理，并处理诸如 `exec` 失败等边缘情况。", "problem": "在一个可移植操作系统接口（POSIX）系统上，您正在设计一个健壮的父子进程握手协议，用于派生一个子进程，该子进程将通过 $execve$ 调用将其进程映像替换为目标程序。您希望保证绝不会产生僵尸进程。僵尸进程是指已终止但其条目仍存在于进程控制块（PCB）中的进程，因为其父进程尚未通过 $wait$ 或 $waitpid$ 来收集其终止状态。您将仅使用管道以及 $close$、$exec$ 和 $wait$ 调用的顺序，并且必须考虑诸如 $exec$ 失败、子进程提前退出以及父进程在派生后不久执行 $exec$ 等边界情况。请将以下经过充分检验的事实和定义作为您的基本依据：\n\n- 一次成功的 $fork$ 调用后，子进程会继承父进程打开的文件描述符（FD），包括父进程创建的任何管道的两端，并且内核会为每一端维护引用计数。\n- 只有当所有进程中指向管道的所有写入端都关闭时，对管道的读操作才会返回 $0$（表示文件结束）。当至少有一个写入端保持打开且没有可用数据时，读操作会阻塞。\n- $execve$ 会替换调用进程的映像，文件描述符会被保留，除非它们设置了“执行时关闭”（FD_CLOEXEC）标志，在这种情况下，它们会在 $execve$ 执行期间被原子地关闭。\n- 如果一个子进程终止，而其父进程没有调用 $wait$ 或 $waitpid$ 来回收它，那么该子进程就会成为僵尸进程；如果父进程自身终止，子进程会被系统回收进程（例如，在某些系统上是 1 号进程）收养，从而防止该进程谱系中出现僵尸进程。\n- 在任何阻塞的读操作完成后都可以调用 $waitpid$；正确的顺序至关重要，以避免可能导致子进程未被回收的竞争条件。\n\n您将从以下设计中选择一种，该设计使用管道来确保父进程永远不会留下僵尸子进程，即使父进程打算在派生子进程后不久调用 $exec$。请考虑以下候选的握手协议，它们在 $close$、$exec$ 和 $wait$ 的调用顺序上有所不同。在每个方案中，$P_{c2p}$ 表示一个子进程到父进程的状态管道，$P_{p2c}$ 表示一个父进程到子进程的就绪管道。为清晰起见，$r$ 和 $w$ 分别表示读取端和写入端。\n\nA. 父进程创建两个管道 $P_{c2p}$ 和 $P_{p2c}$。父进程在 $P_{c2p}(w)$上设置 FD_CLOEXEC 标志，而 $P_{c2p}(r)$ 则不设置。在 $fork$ 之后：\n- 子进程关闭 $P_{c2p}(r)$ 和 $P_{p2c}(w)$，然后从 $P_{p2c}(r)$ 阻塞读取 1 个字节，以确保父进程已准备好进行回收。收到该字节后，子进程尝试执行 $execve$。如果 $execve$ 成功，FD_CLOEXEC 标志会原子地关闭 $P_{c2p}(w)$，子进程在新映像中继续执行。如果 $execve$ 失败，子进程向 $P_{c2p}(w)$ 写入一个小的错误码并调用 $_exit$。\n- 父进程立即关闭 $P_{c2p}(w)$ 和 $P_{p2c}(r)$，向 $P_{p2c}(w)$ 写入 1 个字节以释放子进程，然后从 $P_{c2p}(r)$ 读取。如果读取返回 0，父进程推断 $execve$ 成功，并调用 $waitpid$ 以便在子进程最终终止时进行回收。如果读取返回一个错误码，父进程立即调用 $waitpid$ 进行回收并处理失败。只有在执行 $waitpid$ 之后，父进程才会继续执行自己的 $exec$ 或其他操作。这个顺序确保了在成功路径中 $P_{c2p}$ 的所有写入端都被关闭（从而产生 0 返回值），并且父进程在成功和失败两种路径下都会回收子进程，从而防止僵尸进程。边界情况：如果子进程在读取 $P_{p2c}(r)$ 之前提前退出，父进程对 $P_{c2p}(r)$ 的读取将收到错误码或 0，而 $waitpid$ 仍然会完成回收。如果在 $P_{c2p}(w)$ 上没有设置 FD_CLOEXEC，由于新映像会保持写入端打开，父进程的读取可能会永远阻塞；设置 FD_CLOEXEC 可以避免这种情况。\n\nB. 父进程创建一个管道 $P_{c2p}$，但不在任何一端设置 FD_CLOEXEC。在 $fork$ 之后：\n- 子进程关闭 $P_{c2p}(r)$ 并尝试执行 $execve$。如果失败，它会写入一个错误码并退出；如果成功，新映像会继承 $P_{c2p}(w)$ 并无限期地保持其打开状态。\n- 父进程不关闭任何描述符，并从 $P_{c2p}(r)$ 读取。它将返回 0 解释为成功，将非零字节解释为失败，然后立即调用 $exec$ 而不调用 $waitpid$。\n这个设计可能导致死锁或错误信号：父进程的读取操作可能永远不会返回 0，因为在子进程的新映像中 $P_{c2p}(w)$ 仍然是打开的；并且父进程从不调用 $waitpid$，如果子进程在父进程执行 $exec$ 后退出，则有产生僵尸进程的风险。\n\nC. 父进程将信号（SIGCHLD）的处置方式设置为忽略，并且不使用管道。在 $fork$ 之后：\n- 子进程尝试执行 $execve$ 并在完成后退出。\n- 父进程立即调用 $exec$ 而不调用 $waitpid$，并假设忽略 SIGCHLD 信号能在所有 POSIX 系统上保证自动回收。\n这种方法依赖于非可移植的行为；在所有 POSIX 实现中，忽略 SIGCHLD 并不普遍保证自动回收，而且该方法没有使用指定的基于管道的握手协议。因此，在不执行自动回收的系统上，它有产生僵尸进程的风险。\n\nD. 父进程在子进程中实现一次双重 $fork$，以使孙进程成为孤儿进程，不使用管道，也从不调用 $waitpid$。中间的子进程退出，导致孙进程被系统回收进程（例如，1 号进程）重新收养，该进程最终会回收它。\n虽然双重 $fork$ 可以避免僵尸进程，但它忽略了使用管道进行握手协议的要求，并且没有涵盖向父进程发信号通知 $exec$ 失败的情况；此外，它还使资源管理和进程谱系跟踪变得复杂。\n\n在给定的假设下，哪个选项正确地使用了管道以及 $close$、$exec$ 和 $wait$ 调用的顺序，以确保不产生僵尸进程并处理了所述的边界情况？\n\nA. 采用双管道握手协议，在 $P_{c2p}(w)$ 上设置 FD_CLOEXEC，父进程关闭其写入端，通过 $P_{p2c}$ 释放子进程，读取状态，并在父进程执行任何 $exec$ 之前调用 $waitpid$。\n\nB. 采用单管道方法，不使用 FD_CLOEXEC，父进程不关闭其写入端，并在不调用 $waitpid$ 的情况下调用 $exec$。\n\nC. 忽略 SIGCHLD 且不使用管道，依赖自动回收。\n\nD. 采用双重 $fork$，不使用管道，且从不调用 $waitpid$。", "solution": "对用户提供的问题分析如下。\n\n### 第一步：提取已知条件\n- **目标**：在 POSIX 系统上设计一个健壮的父子进程握手协议，用于派生一个子进程，让它调用 `$execve$`，并保证不产生僵尸进程。\n- **僵尸进程定义**：一个已终止但其进程控制块（PCB）条目仍然存在的进程，因为其父进程尚未通过 `$wait$` 或 `$waitpid$` 收集其状态。\n- **约束**：仅使用管道以及 `$close$`、`$exec$` 和 `$wait$` 调用的顺序。\n- **边界情况**：必须处理 `$exec$` 失败、子进程提前退出以及父进程在派生后不久执行 `$exec$` 的情况。\n- **基本事实**：\n    1. `$fork$` 成功后，子进程继承父进程打开的文件描述符（FD），内核对每个管道末端进行引用计数。\n    2. 只有当所有写入端都关闭时，对管道的读操作才会返回 `$0$`（文件结束）。如果至少有一个写入端打开且无数据，读操作会阻塞。\n    3. `$execve$` 保留 FD，除非设置了 `FD_CLOEXEC`（执行时关闭）标志，该标志会原子地关闭它们。\n    4. 如果活着的父进程不调用 `$wait$`，子进程会变成僵尸进程。如果父进程终止，被收养的子进程将被系统回收进程（如 1 号进程）回收。\n    5. 可以在阻塞读操作完成后调用 `$waitpid$`；顺序至关重要，以避免竞争条件。\n- **符号**：`$P_{c2p}$`（子-父管道），`$P_{p2c}$`（父-子管道），`$r$`（读取端），`$w$`（写入端）。\n\n### 第二步：使用提取的已知条件进行验证\n对问题陈述进行严格评估以验证其有效性。\n\n- **科学依据**：该问题牢固地植根于 POSIX 兼容操作系统中进程管理的既定原则。关于 `$fork$`、`$execve$`、`$waitpid$`、管道、文件描述符、`FD_CLOEXEC` 和僵尸进程的描述是准确的，反映了标准的系统编程概念。\n- **问题定义良好**：该问题定义良好。它提出了一个明确的目标（在 `$exec$` 握手期间防止僵尸进程），定义了约束和可用工具，并要求评估具体的提议解决方案。根据所提供的公理，选项中存在一个唯一的正确设计。\n- **客观性**：语言技术性强、精确，没有主观或含糊的术语。成功解决方案的标准被明确定义且可验证。\n- **完整性与一致性**：该问题提供了所有必要的定义和假设，以推导出正确的解决方案。内部没有矛盾。提供的“基本事实”为分析构成了一个自洽的逻辑基础。\n- **相关性**：该问题直接且根本性地关系到操作系统导论中关于进程生命周期和控制结构的主题。\n\n### 第三步：结论与行动\n问题陈述是 **有效的**。这是一个系统编程中的标准问题，尽管有些复杂，但它测试了对进程控制和进程间通信原语的理解。现在可以进行求解过程。\n\n### 基于原则的推导\n\n核心挑战是在指定的约束下设计一个机制，同时完成两个任务：\n1.  **状态报告**：父进程必须能够可靠地确定子进程对 `$execve$` 的调用是成功还是失败。\n2.  **防止僵尸进程**：子进程在终止时必须被其父进程通过 `$wait$` 或 `$waitpid$` 成功回收，以防止其成为僵尸进程。即使父进程本身在握手后调用 `$execve$`，这一点也必须成立。\n\n**状态报告机制**：\n从子进程到父进程的管道（`$P_{c2p}$`）是指定的工具。子进程可以在退出前向管道写入一个错误码来表示失败。成功则更微妙，因为由 `$execve$` 加载的新进程映像对握手协议一无所知，不会写入“成功”码。表示成功的正确方法是通过一个隐式操作：关闭管道的写入端。\n\n让父进程持有读取端 `$P_{c2p}(r)$`，子进程持有写入端 `$P_{c2p}(w)$`。在 `$fork$` 之后，两个进程最初都拥有这两个 FD。为了使通信正常工作，父进程必须关闭其 `$P_{c2p}(w)$` 的副本，而子进程必须关闭其 `$P_{c2p}(r)$` 的副本。现在，父进程可以在 `$P_{c2p}(r)$` 上执行阻塞的 `read()`。\n- 如果 `$execve$` 失败，子进程向 `$P_{c2p}(w)` `write()` 一个错误码。父进程的 `read()` 会接收到这些数据。\n- 如果 `$execve$` 成功，程序必须确保 `$P_{c2p}(w)` 被关闭。如果它在新加载的进程中保持打开状态，父进程的 `read()` 将无限期阻塞。`FD_CLOEXEC` 标志在这里至关重要。通过在 `$fork$` 之前在 `$P_{c2p}(w)` 上设置 `FD_CLOEXEC`，子进程中成功的 `$execve$` 将原子地关闭这个文件描述符。由于父进程已经关闭了其 `$P_{c2p}(w)` 的副本，这个操作关闭了最后一个剩余的写入句柄，导致父进程的 `read()` 解除阻塞并返回 `$0$`（EOF），从而可靠地表示成功。\n\n**防止僵尸进程机制**：\n如果父进程存活但未能调用 `$waitpid$`，子进程就会变成僵尸进程。问题指出父进程自己也可能调用 `$execve$`。一个常见的误解是这会终止父进程。并非如此；它替换了父进程的进程映像。父进程，以其原始的进程 ID，继续存在并仍然是子进程的父进程。然而，由 `$execve$` 加载的新程序将不知道子进程的存在，也不会有调用 `$waitpid$` 的逻辑。因此，当子进程最终终止时，它的父进程（运行着新程序）不会回收它，它将成为一个僵尸进程。\n\n为了绝对*保证*不产生僵尸进程，原始的父进程代码必须在它通过调用 `$execve$` 放弃控制权*之前*回收子进程。这意味着，在父进程确定了子进程的 `$execve$` 状态后，它必须调用 `$waitpid(child\\_pid, ...)` 并等待其完成。如果子进程的 `$execve$` 成功，这意味着父进程将阻塞，直到子进程的整个生命周期结束。这创建了一个同步的派生过程，在所有情况下可能都不是理想的，但这是在指定约束下满足严格的“保证不产生僵尸进程”要求的唯一方法。\n\n### 逐项分析选项\n\n**A. 采用双管道握手协议，在 `$P_{c2p}(w)$` 上设置 FD_CLOEXEC，父进程关闭其写入端，通过 `$P_{p2c}$` 释放子进程，读取状态，并在父进程执行任何 `$exec$` 之前调用 `$waitpid$`。**\n\n该选项基于上述推导出的原则，描述了一个细致且正确的实现方案。\n- **管道**：它使用了两个管道。子-父管道（`$P_{c2p}$`）用于状态报告，如前所述。父-子管道（`$P_{p2c}$`）作为一个同步屏障，确保子进程在父进程完全准备好监听状态信号之前不会调用 `$execve$`，从而防止了竞争条件。\n- **`FD_CLOEXEC`**：它正确地指明了 `$P_{c2p}(w)$` 必须设置 `FD_CLOEXEC` 标志。这是通过管道上的 EOF 信号来表示 `$execve$` 成功的基石。\n- **`close()` 顺序**：它正确地概述了每个进程关闭其不使用的管道端。\n- **回收**：至关重要的是，它指出在解决了握手问题（从 `$P_{c2p}(r)$` 读取到 `$0$` 或错误码）*之后*，父进程会调用 `$waitpid$`。在 `$execve$` 失败的情况下，子进程已经退出，所以 `$waitpid$` 会立即返回。在 `$execve$` 成功的情况下，父进程会阻塞直到子进程终止。只有在回收了子进程之后，父进程才会继续执行自己的任务，例如调用 `$exec$`。这个顺序正确且完全地防止了僵尸进程的产生，满足了所有问题约束。\n\n结论：**正确**。\n\n**B. 采用单管道方法，不使用 FD_CLOEXEC，父进程不关闭其写入端，并在不调用 `$waitpid$` 的情况下调用 `$exec$`。**\n\n这个选项存在根本性缺陷。\n- **没有 `FD_CLOEXEC`**：如果没有 `FD_CLOEXEC`，子进程中成功的 `$execve$` 会导致新进程映像继承管道的写入端（`$P_{c2p}(w)`）。父进程对 `$P_{c2p}(r)` 的 `read()` 操作将永远阻塞，因为管道的一个写入句柄仍然打开，但没有数据被写入。这会导致死锁。\n- **父进程没有 `close()`**：父进程未能关闭其自己的 `$P_{c2p}(w)` 副本。这是导致父进程 `read()` 死锁的另一个独立原因。\n- **没有 `waitpid`**：父进程在没有调用 `$waitpid$` 的情况下调用 `$exec$`。如推导中所解释的，如果子进程在父进程运行其新映像时终止，这保证会产生一个僵尸进程。\n\n结论：**不正确**。\n\n**C. 忽略 SIGCHLD 且不使用管道，依赖自动回收。**\n\n该选项违反了问题的明确约束，并且不是一个普遍健 robuste的解决方案。\n- **违反约束**：问题要求“仅使用管道以及 `$close$`、`$exec$` 和 `$wait$` 调用的顺序”。此解决方案使用信号（`$SIGCHLD$`）并明确避免使用管道。\n- **非可移植性**：将 `$SIGCHLD$` 的处置设置为 `$SIG_IGN$` 会导致子进程自动被回收的行为是一个常见的扩展（例如，在 Linux 和 BSD 上），但 POSIX 标准并未规定此行为。为 POSIX 系统设计的健壮方案不能依赖此行为。\n- **无状态报告**：此机制没有提供任何方法让父进程知道子进程的 `$execve$` 调用是否失败。\n\n结论：**不正确**。\n\n**D. 采用双重 `$fork$`，不使用管道，且从不调用 `$waitpid$`。**\n\n该选项描述了一种有效的通用守护进程化模式，但未能满足本问题的具体要求。\n- **违反约束**：问题要求使用基于管道的握手协议。此解决方案在原始父进程和最终将调用 `$execve$` 的进程之间不使用管道进行通信。\n- **无状态报告**：原始父进程回收了几乎立即退出的中间子进程。父进程与孙进程（实际的工作进程）之间没有通信渠道，因此无法在孙进程的 `$execve$` 调用失败时得到通知。\n\n结论：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3672175"}]}