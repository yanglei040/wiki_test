{"hands_on_practices": [{"introduction": "内核与用户空间之间最关键的边界之一在于参数验证。一个常见的安全漏洞源于整数溢出，恶意用户可能通过精心构造的地址和长度参数，欺骗内核访问未授权的内存区域。这个练习 [@problem_id:3686254] 旨在探讨如何设计和识别可靠的验证策略，以在内核复制数据之前，稳健地检测并阻止这类攻击，这是构建安全操作系统的第一道防线。", "problem": "一个操作系统内核实现了一个系统调用，该调用接受一个用户空间指针和一个长度，表示为序对 $\\big(addr, len\\big)$。内核在调用诸如 copyin 之类的用户到内核复制例程之前，必须验证这些参数，以确保整个半开区间 $\\big[addr, addr + len\\big)$ 位于允许的用户空间区域内。假设有以下基本前提：\n\n- 地址和长度表示为无符号 $n$ 位整数，算术运算在模 $2^n$ 下进行。\n- 允许的用户空间区域是半开区间 $\\big[0, L\\big)$，其中 $L$ 是一个实现定义的限制，满足 $0  L \\le 2^n$。\n- 对于任何使得 $\\big[addr, addr + len\\big)$ 不为 $\\big[0, L\\big)$ 子集的输入，内核都必须拒绝，包括 $addr + len$ 发生模 $2^n$ 回绕的情况。\n\n考虑一个在 $n = 64$ 架构上的场景，其中 $L$ 是 $[0, 2^{64})$ 的一个真子集，一个恶意用户传递一个接近 $2^{64} - 1$ 的 $addr$ 和一个非零的 $len$，使得计算出的 $addr + len$ 经过模 $2^{64}$ 回绕后成为一个很小的值。内核寻求一种可证明是健全的验证策略：它必须在调用 copyin 之前检测到计算 $addr + len$ 时的任何整数溢出，并拒绝任何超出用户空间边界的区间。\n\n在所述模型下，以下哪种验证策略是健全的？选择所有适用的选项。\n\nA. 如果 $addr  L$ 且 $len \\le L - addr$，则接受。\n\nB. 如果 $addr  L$ 且 $(addr + len) \\le L$，则接受，其中和是在无符号 $n$ 位算术下按模 $2^n$ 计算的。\n\nC. 如果 $addr  L$，则在无符号 $n$ 位算术下按模 $2^n$ 计算 $end = addr + len$，如果 $end  addr$ 则拒绝，否则仅在 $end \\le L$ 时接受。\n\nD. 将 $addr$ 和 $len$ 转换为有符号 $n$ 位整数，并使用有符号算术，在 $(addr + len) \\ge addr$ 且 $(addr + len) \\le L$ 的情况下接受。\n\nE. 将 $addr$ 和 $len$ 提升到一个宽度为 $n' \\ge n + 1$ 位的更宽的无符号整数类型，在该更宽类型中计算 $end = addr + len$ 而不发生回绕，并仅在 $addr  L$ 且 $end \\le L$ 时接受。", "solution": "用户提供的问题陈述已经过验证，被认为是健全的。这是一个在操作系统安全和计算机体系结构领域中定义良好、有科学依据的问题。它没有任何科学、逻辑或事实上的缺陷。\n\n问题的核心是设计一种验证策略，以确保用户提供的内存区间（由起始地址 `addr` 和长度 `len` 表示）完全包含在允许的用户空间内存区域内。该区域是半开区间 $\\big[0, L\\big)$，其中 $L$ 是一个预定义的限制。`addr` 和 `len` 都是无符号 $n$ 位整数，它们的算术运算在模 $2^n$ 下进行。验证必须能抵御整数溢出，当恶意用户提供一个大的 `addr` 和一个 `len`，导致和 `addr + len` 在 $n$ 位地址空间中“回绕”时，就会发生整数溢出。\n\n一个健全的验证策略必须确保区间 $\\big[addr, addr + len\\big)$ 是 $\\big[0, L\\big)$ 的子集。考虑到 `addr` 和 `len` 是非负的，这可以分解为三个必要且充分的条件：\n1.  区间的起始点必须在有效区域内：$addr \\ge 0$ 且 $addr  L$。由于 `addr` 是一个无符号整数，第一部分 ($addr \\ge 0$) 总是成立的。因此，条件是 $addr  L$。\n2.  区间端点 $addr + len$ 的计算不得导致整数溢出（回绕）。在 $n$ 位无符号算术中，这意味着数学上的和必须小于 $2^n$。一个等效的检查是，$n$ 位加法的结果不小于起始地址，即 $addr + len \\ge addr$（对于非零的 $len$）。如果 $len=0$，该条件也成立。\n3.  区间的终点不能超过边界 $L$。该区间是 $\\big[addr, addr + len\\big)$，因此访问的最高内存地址是 $addr + len - 1$。为了使这个值小于 $L$，我们必须有 $addr + len \\le L$。\n\n综合这些，一个健全的策略必须正确验证：\n- $addr  L$\n- 和 $addr + len$ 没有溢出\n- $addr + len \\le L$\n\n我们现在将根据这些原则评估每个选项。让 `+_n` 表示无符号 $n$ 位加法。\n\nA. **如果 $addr  L$ 且 $len \\le L - addr$，则接受。**\n这个策略包含两个检查。\n- 第一个检查 $addr  L$ 正确地验证了起始地址在允许的用户区域内。\n- 第二个检查是 $len \\le L - addr$。这个数学不等式是使用 $n$ 位无符号算术执行的。第一个检查 $addr  L$ 确保了减法 $L - addr$ 不会下溢（或“借位”）。因此，$L - addr$ 的机器计算会产生正确的数学结果。\n不等式 $len \\le L - addr$ 在数学上等价于 $addr + len \\le L$。这一个检查巧妙地结合了溢出检查和边界检查。\n让我们分析为什么它能正确检测溢出。如果数学和 $addr + len \\ge 2^n$，就会发生溢出。问题陈述说对于 $n=64$ 的情况，`L` 是真子集的一部分，所以 $L  2^n$。在一般情况下，$L \\le 2^n$。如果发生溢出，那么 $addr+len \\ge 2^n$。由于 $L \\le 2^n$，这意味着对于任何小的 epsilon，$addr + len > L - \\epsilon$，除非 $L=2^n$ 且 $addr+len=2^n$。\n更正式地说：如果发生溢出，真实的和 $addr+len \\ge 2^n$。这意味着 $len \\ge 2^n - addr$。被检查的条件是 $len \\le L - addr$。我们知道 $L \\le 2^n$，因此 $L - addr \\le 2^n - addr$。如果 $L  2^n$，那么 $L - addr  2^n - addr$。在这种情况下，溢出意味着 $len \\ge 2^n - addr > L-addr$，所以检查 $len \\le L-addr$ 会失败。如果 $L=2^n$，溢出意味着 $len \\ge 2^n-addr$。检查是 $len \\le 2^n-addr$。所以如果 $len > 2^n-addr$，它会失败。如果 $len = 2^n-addr$，检查通过，`end` 地址是 $2^n$，并且区间 $\\big[addr, 2^n\\big)$ 在 $\\big[0, 2^n\\big)$ 内是有效的。这种方法是健全的。它通过重新排列表达式来避免计算可能溢出的和 $addr + len$。\n结论：**正确**。\n\nB. **如果 $addr  L$ 且 $(addr + len) \\le L$，则接受，其中和是在无符号 $n$ 位算术下按模 $2^n$ 计算的。**\n这是不健全检查的典型例子。\n- 检查 $addr  L$ 是正确的。\n- 检查 $(addr +_n len) \\le L$ 是有缺陷的。\n让我们使用问题描述中的恶意用户场景。对于 $n=64$，设 $L = 2^{64}-5$，这是一个有效的限制。假设用户提供 $addr = 2^{64} - 10$ 和 $len = 20$。\n1.  检查 $addr  L$：$2^{64} - 10  2^{64} - 5$。这是真的。\n2.  计算和：$(2^{64} - 10) +_n 20$。数学上的和是 $2^{64} + 10$。模 $2^{64}$ 后，这会回绕到值 $10$。\n3.  检查 $(addr +_n len) \\le L$：$10 \\le 2^{64} - 5$。这也是真的。\n该策略接受了输入。然而，实际请求的内存范围从 $addr$ 延伸到地址空间的末尾，并回绕到开头：$\\big[2^{64}-10, 2^{64}\\big) \\cup \\big[0, 10\\big)$。这个范围不是 $\\big[0, L\\big)=\\big[0, 2^{64}-5\\big)$ 的子集，因为它包含了像 $2^{64}-1$ 这样的地址。该策略未能检测到溢出。\n结论：**不正确**。\n\nC. **如果 $addr  L$，则在无符号 $n$ 位算术下按模 $2^n$ 计算 $end = addr + len$，如果 $end  addr$ 则拒绝，否则仅在 $end \\le L$ 时接受。**\n该策略使用一个多步骤过程。\n1.  检查 $addr  L$：这正确地验证了区间的起始点。\n2.  计算 $end = addr +_n len$。\n3.  检查溢出：`如果 end  addr 则拒绝`。这是检测无符号加法溢出的标准且正确的方法。如果 $len$ 是正数，和 $addr+len$ 必须大于 `addr`，除非发生了溢出，这会使结果变小。如果 $len=0$，$end=addr$，所以 $end  addr$ 为假，检查正确通过。\n4.  如果没有溢出（即 $end \\ge addr$），`end` 的值就是真实的数学和 `addr + len`。该策略接着继续检查 $end \\le L$。\n这一系列检查在逻辑上是健全的。它验证了起始点 ($addr  L$)，然后明确验证了没有溢出，最后验证未溢出的端点在允许的边界内 ($addr + len \\le L$)。这些条件共同正确地确保了 $\\big[addr, addr + len\\big) \\subseteq \\big[0, L\\big)$。\n让我们重新评估恶意情况：$addr = 2^{64} - 10$，$len = 20$，$L = 2^{64}-5$。\n1.  $addr  L$：真。\n2.  $end = (2^{64} - 10) +_n 20 = 10$。\n3.  如果 $end  addr$ 则拒绝：$10  2^{64} - 10$。这是真的。该条件触发了拒绝操作。\n该策略正确地拒绝了恶意输入。\n结论：**正确**。\n\nD. **将 `addr` 和 `len` 转换为有符号 $n$ 位整数，并使用有符号算术，在 $(addr + len) \\ge addr$ 且 $(addr + len) \\le L$ 的情况下接受。**\n这种方法存在根本性缺陷。内存地址和长度本质上是无符号实体。将它们转换为有符号类型会引入歧义和实现定义的行为。\n- 一个在 $\\big[2^{n-1}, 2^n - 1\\big]$ 范围内的无符号 $n$ 位整数 `addr` 在转换为有符号 $n$ 位整数时会变成一个负数。这会使所有后续的比较复杂化。\n- 有符号整数溢出的行为并未被像 C/C++ 这样的语言标准所保证（它是未定义行为），尽管大多数处理器实现了二进制补码回绕。一个“可证明是健全的”策略不能依赖于未定义行为。\n- 检查 $(addr + len) \\ge addr$ 对于有符号数来说不是一个可靠的溢出检测器。例如，如果 `addr` 是一个大的正数，`len` 是一个小的正数，它们的和可能会溢出并成为一个大的负数，此时 `sum  addr` 为真，可以正确检测到溢出。但是，如果 `addr` 是一个负数，`len` 也是一个负数，它们的和可能会下溢并变为正数，此时 `sum > addr` 为真，未能检测到溢出。\n- 该策略缺少了关键的初始检查 $addr  L$。\n该策略不可移植、复杂且不正确。\n结论：**不正确**。\n\nE. **将 `addr` 和 `len` 提升到一个宽度为 $n' \\ge n + 1$ 位的更宽的无符号整数类型，在该更宽类型中计算 $end = addr + len$ 而不发生回绕，并仅在 $addr  L$ 且 $end \\le L$ 时接受。**\n这是一种健壮且广泛使用的策略。\n- 一个 $n$ 位无符号整数的最大值为 $2^n - 1$。两个这样的整数的最大可能和是 $(2^n - 1) + (2^n - 1) = 2^{n+1} - 2$。\n- 这个和可以在一个宽度为 $n+1$ 位或更宽的无符号整数类型中表示而不会丢失或溢出（该类型可以表示高达 $2^{n+1}-1$ 的值）。问题指定了宽度 $n' \\ge n+1$，这是足够的。\n- 通过将 `addr` 和 `len` 提升到这个更宽的类型，计算 $end = addr + len$ 会产生真实的数学和，完全避免了回绕问题。\n- 然后，该策略执行两个简单的比较：\n    1.  $addr  L$：正确检查起始边界。\n    2.  $end \\le L$：将真实的数学端点与限制进行比较。这一个比较就正确地检查了溢出（如果真实和 `end` 超过 $2^n-1$，它肯定会大于 $L$，因为 $L \\le 2^n$）和边界条件。\n让我们检查一下恶意情况：$addr = 2^{64} - 10$，$len = 20$，$L = 2^{64}-5$。\n1.  将 `addr` 和 `len` 提升到一个 $128$ 位的无符号类型。\n2.  计算 $end = (2^{64} - 10) + 20 = 2^{64} + 10$。这是精确的和。\n3.  检查 $addr  L$：$2^{64} - 10  2^{64} - 5$。真。\n4.  检查 $end \\le L$：$2^{64} + 10 \\le 2^{64} - 5$。这是假的。\n输入被正确拒绝。这个策略是可证明是健全的。\n结论：**正确**。", "answer": "$$\\boxed{ACE}$$", "id": "3686254"}, {"introduction": "在多线程环境中，即使参数已通过验证，内核操作共享资源时仍面临并发挑战。一个经典的竞态条件是“检查时-使用时”（Time-of-Check-to-Time-of-Use, TOCTOU），即内核检查资源状态和实际使用该资源之间存在一个时间窗口，状态可能被另一线程改变。本练习 [@problem_id:3686201] 以文件描述符为例，要求你评估不同的内核同步协议，以原子方式获取资源引用，从而解决这一根本性的并发问题。", "problem": "一个多线程进程使用一个每进程文件描述符表，该表将一个整数描述符 $fd$ 映射到一个内核文件对象 $F$。操作系统为每个文件对象维护一个引用计数 $ref(F)$。一个记为 $\\mathrm{do\\_op}(fd,\\ldots)$ 的系统调用，首先检查 $fd$ 是否在范围内且存在于调用者的描述符表中，然后使用相应的文件对象 $F$ 来执行操作。同一进程中的另一个线程可能会并发调用 $\\mathrm{close}(fd)$，此操作会移除 $fd \\rightarrow F$ 的映射并递减 $ref(F)$；当 $ref(F)$ 达到 $0$ 时，$F$ 变为可回收状态。\n\n考虑经典的检查时-使用时（time-of-check-to-time-of-use）时间窗口：线程 $T_1$ 进入 $\\mathrm{do\\_op}(fd,\\ldots)$ 并验证 $fd$，而线程 $T_2$ 并发执行 $\\mathrm{close}(fd)$。在对 $F$ 的验证和首次使用之间，$T_2$ 可能会移除该映射，并可能允许 $fd$ 被重用于另一个不同的文件对象 $F'$，从而造成释放后使用（use-after-free）或错误对象（wrong-object）的风险。\n\n从以下候选设计中，选择所有实现了在系统调用入口处相对于 $\\mathrm{close}(fd)$ 是原子的文件描述符引用获取协议，满足“如果 $fd$ 在入口处无效则出错失败，否则返回一个对入口处所映射的文件对象 $F$ 的稳定引用，并阻止其在释放前被回收”的正确性属性，并通过保持临界区最小且不串行化不相关的系统调用来保持可扩展性的设计。\n\nA. 在系统调用入口处，获取进程的文件描述符表锁，验证 $0 \\le fd  N$ 并且该条目指向一个非空文件对象 $F$，在仍持有锁的情况下增加 $ref(F)$，然后释放锁。使用 $F$ 继续执行系统调用，并在完成后递减 $ref(F)$。如果条目为空，则返回一个错误（例如，$-EBADF$）。\n\nB. 在验证 $fd$ 和获取 $F$ 时，禁用调用方中央处理器（CPU）上的抢占和中断，然后在用 $F$ 之前重新启用它们。假设阻止上下文切换使得该时间窗口小到可以忽略。\n\nC. 在系统调用入口处，将整数 $fd$ 从用户空间复制到内核内存，并验证其范围。之后访问描述符表时使用此内核副本，无需任何进一步的同步，因为内核副本不能被用户空间更改。\n\nD. 对描述符表使用读-复制-更新（Read-Copy-Update, RCU）：进入一个RCU读端临界区，读取表条目以获得指针 $F$ 和一个每个条目的代数计数器 $g$，然后尝试原子地增加 $ref(F)$（例如，通过对 $ref(F)$ 进行比较并交换）来“钉住” $F$。在增加成功后，重新读取代数计数器为 $g'$ 并检查 $g' = g$。如果相等，则退出RCU读端临界区并继续使用 $F$；如果不等，则放弃对 $F$ 的引用，并在获取表锁的慢速路径上重试。如果条目为空，则返回一个错误。当系统调用完成时，递减 $ref(F)$。\n\nE. 通过在每个使用 $fd$ 的系统调用（从入口到完成）的整个持续时间内，以及对每个 $\\mathrm{close}(fd)$，获取一个单一的全局互斥锁来串行化描述符操作。在该互斥锁内部，验证并获取 $F$，然后执行操作；最后释放互斥锁。\n\n选择所有正确选项。", "solution": "问题描述了一个在多线程进程中文件描述符管理上下文下的经典检查时-使用时（TOCTOU）竞争条件。目标是识别出能够原子地查找文件描述符 $fd$、获取对底层文件对象 $F$ 的稳定引用、并防止其被过早回收，同时保持系统可扩展性的同步协议。一个有效的解决方案必须满足两个主要属性：\n1.  **正确性：** 操作必须相对于并发的 $\\mathrm{close}(fd)$ 是原子的。它必须要么在调用时 $fd$ 无效的情况下干净地失败，要么必须确保获得对当时映射的正确文件对象 $F$ 的引用，保证 $F$ 在系统调用期间不被回收。\n2.  **可扩展性：** 临界区必须是最小的，并且解决方案不能不必要地串行化不相关的系统调用，因为这会造成性能瓶颈。\n\n我们现在根据这些标准来评估每个候选设计。\n\n### 选项 A 评估\n该选项建议使用锁来保护文件描述符表。操作顺序是：\n1.  获取进程文件描述符表的锁。\n2.  验证 $fd$ 并查找相应的文件对象 $F$。\n3.  如果有效，增加引用计数 $ref(F)$。\n4.  释放锁。\n5.  使用 $F$ 继续执行操作。\n6.  完成后递减 $ref(F)$。\n\n**正确性：** 此设计正确地解决了竞争条件。该锁确保了验证 $fd$、检索指向 $F$ 的指针以及增加 $ref(F)$ 的序列相对于任何其他修改文件描述符表的操作（例如 $\\mathrm{close}(fd)$）是原子的。如果线程 $T_1$（执行 $\\mathrm{do\\_op}$）首先获取锁，它将在释放锁之前增加 $ref(F)$。随后由线程 $T_2$ 执行的 $\\mathrm{close}(fd)$ 将移除 $fd \\rightarrow F$ 映射并递减 $ref(F)$，但由于 $T_1$ 持有一个引用，$ref(F)$ 不会降至 $0$，对象 $F$ 也不会被回收。如果 $T_2$ 首先获取锁，它将移除该映射。当 $T_1$ 随后获取锁时，它会发现 $fd$ 无效并正确返回一个错误（例如，$-EBADF$）。这满足了正确性属性。\n\n**可扩展性：** 锁的持有时间非常短——仅够执行范围检查、表查找和引用计数增加。这是一个最小的临界区。该锁特定于一个进程的文件描述符表，因此它不会串行化来自不同进程的系统调用。虽然它确实会串行化同一进程内的并发文件描述符操作，但这通常是一个可接受的权衡，并且远优于全局锁。因此，该设计在合理程度上保持了可扩展性。\n\n**结论：** **正确**。这是一个标准的、健壮的且被广泛使用的解决方案。\n\n### 选项 B 评估\n该选项建议禁用调用方CPU上的抢占和中断，以创建一个类似原子的区域。\n\n**正确性：** 在多处理器环境中，这种方法存在根本性缺陷。在单个CPU核心（例如CPU$_0$）上禁用抢占和中断，仅能防止其他线程在该CPU$_0$上被调度。它完全无法阻止另一个线程 $T_2$ 在不同的核心（例如CPU$_1$）上并发运行、获取 $\\mathrm{close}$ 操作所需的任何锁、修改共享的文件描述符表，并导致我们试图防止的竞争条件。假设这样做能使时间窗口“小到可以忽略”，是依赖于时序的危险做法，而不是正确性的保证，并且在任何现代多核系统上都是错误的。\n\n**可扩展性：** 由于方法不正确，可扩展性无关紧要。\n\n**结论：** **不正确**。这无法在当今标准的多处理器系统上提供所需的原子性。\n\n### 选项 C 评估\n该选项建议将整数 $fd$ 从用户空间复制到内核空间，然后使用这个内核副本。\n\n**正确性：** 这个提议误解了TOCTOU漏洞的本质。问题不在于用户空间程序可能会在内核读取文件描述符编号后恶意更改持有该编号的变量的值。问题在于，*共享的内核数据结构*（文件描述符表）的状态可能会被另一个内核级执行线程（例如运行 $\\mathrm{close}(fd)$ 的 $T_2$）在 $T_1$ 检查表和它使用该检查结果之间被更改。将整数 $fd$ 复制到内核内存中，对于同步对文件描述符表本身的访问毫无作用。线程 $T_1$ 可以读取 $fd$ 的内核副本并验证它，但在它可以使用相关的文件对象 $F$ 之前，线程 $T_2$ 可以关闭该 $fd$，导致释放后使用或错误对象使用的错误。\n\n**可扩展性：** 由于方法不正确，可扩展性无关紧要。\n\n**结论：** **不正确**。它未能解决实际的并发问题。\n\n### 选项 D 评估\n该选项描述了一种使用读-复制-更新（RCU）和代数计数器的无锁乐观方法。\n\n**正确性：** 这是一个复杂且正确的设计。\n1.  进入RCU读端临界区可以防止文件描述符表结构本身在读取器遍历它时被释放。\n2.  读取器获取指向 $F$ 的指针和一个代数计数器 $g$。任何修改此特定表条目的写入器（一个 $\\mathrm{close}$ 或 `dup2` 操作）都会增加该代数计数器。\n3.  读取器尝试通过原子地增加其引用计数 $ref(F)$ 来“钉住”文件对象。\n4.  关键步骤是重新读取代数计数器为 $g'$ 并验证 $g' = g$。如果它们相等，这意味着在初始读取和成功钉住 $F$ 之间，没有写入器修改过这个特定的 $fd$ 条目。读取器已经获得了对正确对象的稳定引用，可以继续进行。\n5.  如果 $g' \\neq g$，则发生了与写入器的竞争。读取器的引用可能指向一个陈旧的对象，因此它必须撤销其操作（递减 $ref(F)$）并重试，通常通过使用传统锁的“慢速路径”（如选项A所示）。\n此协议正确地确保了读取器要么获得对调用入口时存在的对象的稳定引用，要么安全地检测到竞争并重试。\n\n**可扩展性：** 此设计具有高度可扩展性。读取器的快速路径不涉及任何锁定，只涉及RCU原语和原子操作，这些都非常高效。这允许多个并发的系统调用（`do_op`）在不相互阻塞的情况下并行进行。写入器（$\\mathrm{close}$）需要获取锁来更新表和代数计数器，但在许多工作负载中，读取远比写入频繁，这使其成为一个出色的优化。此设计明确地最小化了临界区，并避免了串行化不相关的调用。\n\n**结论：** **正确**。这是一个在高级操作系统中使用的有效、高性能的解决方案。\n\n### 选项 E 评估\n该选项建议使用一个在整个调用期间持有的单一全局互斥锁来串行化所有与文件描述符相关的系统调用。\n\n**正确性：** 这确实可以防止竞争条件。通过串行化所有接触文件描述符的操作，它消除了所有并发性，因此TOCTOU风险不会发生。对 $fd$ 的验证和对 $F$ 的使用都将在全局互斥锁的独占保护下进行。\n\n**可扩展性：** 这个解决方案在可扩展性方面是灾难性的。它不仅串行化了一个进程内的相关操作，而且串行化了*整个系统*中*所有*的文件描述符操作。一个进程中的线程在管道上执行一个长时间阻塞的 $\\mathrm{read()}$ 将会阻止一个完全不相关的进程中的线程打开一个新文件。这直接违反了“通过保持临界区最小且不串行化不相关的系统调用来保持可扩展性”的要求。在可能阻塞的I/O操作的整个持续时间内持有锁，是内核开发中的一个主要设计缺陷。\n\n**结论：** **不正确**。它以最极端的方式未能满足可扩展性要求。", "answer": "$$\\boxed{AD}$$", "id": "3686201"}, {"introduction": "系统调用的交互是一个双向的契约，不仅内核需要健壮，用户空间的应用程序也必须能正确处理内核的各种返回状态。一个常见的例子是，诸如 `write` 这样的系统调用可能只完成了部分请求的工作。这个练习 [@problem_id:3686250] 模拟了一个“部分成功”的场景，要求你计算出后续调用所需的正确参数，以确保数据的完整传输，这对于编写可靠的 I/O 程序至关重要。", "problem": "一个遵循可移植操作系统接口 (POSIX) 的系统上的用户空间程序发出 `write` 系统调用，以将内存缓冲区中的连续消息传输到文件描述符。在一个广泛使用的64位架构上，流行的应用程序二进制接口 (ABI) 上的系统调用接口传递参数时，将缓冲区指针和字节数分别作为第二个和第三个参数提供。操作系统内核可以合法地完成比请求少的字节数，并返回实际写入的字节数作为一个非负值。\n\n从以下核心定义出发：(i) `write` 系统调用返回实际写入的字节数，以及 (ii) 在一个元素类型为字符的按字节寻址的缓冲区上进行指针算术运算时，每增加一个单位，指针前进一个字节，推导在部分成功的情况下，如何调整下一次 `write` 系统调用的参数，以避免重新发送已经写入的字节。\n\n具体来说，假设程序最初传递缓冲区指针 $p = 0x7\\mathrm{fff}00001000$ 和长度 $n = 4096$ 字节给 `write`，而内核返回 $k = 1723$，其中 $0  k  n$。对于旨在仅传输剩余字节的后续 `write` 系统调用，计算应分别放入缓冲区指针寄存器和长度寄存器的两个参数值，表示为精确整数。将你的最终答案以单行矩阵的形式提供，其中包含更新后的缓冲区指针和更新后的长度，两个条目都需精确写入。最终答案无需四舍五入，也无需单位。", "solution": "用户空间程序的目标是从起始地址为 $p$ 的内存缓冲区写入总共 $n$ 个字节。使用这些参数调用 `write` 系统调用。系统调用返回一个值 $k$，表示只有缓冲区的前 $k$ 个字节被成功写入。这种情况，即 $0 \\le k  n$，被称为部分写入或短写入，是该系统调用的一种标准的、有文档记载的行为，尤其是在写入管道、套接字或空间有限的磁盘等实体时。\n\n为了完成数据传输，程序必须发出一个或多个后续的 `write` 调用来传输剩余的数据。问题要求为紧接着的下一次调用提供正确的参数，这次调用应尝试发送第一次尝试中未发送的那部分数据。\n\n设初始缓冲区指针为 $p$，要写入的初始字节数为 $n$。给定的值为：\n- $p = 0x7\\mathrm{fff}00001000$ (一个以十六进制表示的64位内存地址)\n- $n = 4096$ 字节\n系统调用返回 $k = 1723$，表示写入了 $1723$ 个字节。由于 $0  1723  4096$，这是一次部分写入。\n\n缓冲区的前 $k$ 个字节，位于从 $p$ 到 $p + k - 1$ 的内存地址，已成功传输。剩余数据由从偏移量 $k$ 到原始缓冲区末尾的字节组成。\n\n任务是为后续的 `write` 调用确定新的缓冲区指针 $p'$ 和新的长度 $n'$。\n\n1.  **计算新缓冲区指针 ($p'$)**:\n    剩余数据段紧跟在已写入的前 $k$ 个字节之后开始。因此，该段的起始地址距离原始起始地址 $p$ 有 $k$ 个字节的偏移量。\n    问题指出，“在一个按字节寻址的缓冲区上进行指针算术运算时…每增加一个单位，指针前进一个字节。” 这将类C语言中针对字符类型指针（例如 `char*`）或空指针（`void*`）的指针算术标准行为形式化，这些指针通常用于原始内存缓冲区。将一个整数 $k$ 加到这样的指针上，会产生一个新的指针，该指针在内存中偏移了 $k$ 个字节。\n    因此，新的缓冲区指针 $p'$ 计算如下：\n    $$p' = p + k$$\n    我们已知 $p = 0x7\\mathrm{fff}00001000$ 且 $k = 1723$。必须执行加法运算。在系统编程中，通常用十六进制表示内存地址并在此基数下进行算术运算。为此，我们首先将十进制整数 $k$ 转换为其十六进制等价值。\n    - $1723 \\div 16 = 107$，余数为 $11$ (即 $\\mathrm{B}_{16}$)。\n    - $107 \\div 16 = 6$，余数为 $11$ (即 $\\mathrm{B}_{16}$)。\n    - $6 \\div 16 = 0$，余数为 $6$。\n    按计算的逆序读取余数，得到 $1723_{10} = 6\\mathrm{BB}_{16}$。\n    现在，我们执行十六进制加法：\n    $$p' = 0x7\\mathrm{fff}00001000_{16} + 6\\mathrm{BB}_{16} = 0x7\\mathrm{fff}000016\\mathrm{BB}_{16}$$\n    所以，更新后的缓冲区指针参数是 $0x7\\mathrm{fff}000016\\mathrm{BB}$。\n\n2.  **计算新长度 ($n'$)**:\n    最初的请求是写入 $n$ 个字节。由于已经写入了 $k$ 个字节，剩余待写入的字节数是原始总量减去已完成的量。\n    因此，新的长度 $n'$ 是：\n    $$n' = n - k$$\n    代入给定值：\n    $$n' = 4096 - 1723 = 2373$$\n    更新后的长度参数是 $2373$ 字节。\n\n总而言之，为了在后续调用 `write` 以传输消息的剩余部分时，程序应使用缓冲区指针 $p' = 0x7\\mathrm{fff}000016\\mathrm{BB}$ 和长度 $n' = 2373$。根据系统的 ABI，这两个值将被放入相应的寄存器中。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n0x7\\mathrm{fff}000016\\mathrm{BB}  2373\n\\end{pmatrix}\n}\n$$", "id": "3686250"}]}