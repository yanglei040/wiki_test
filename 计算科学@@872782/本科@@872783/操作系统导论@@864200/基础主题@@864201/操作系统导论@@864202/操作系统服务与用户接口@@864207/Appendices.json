{"hands_on_practices": [{"introduction": "一个响应迅速的用户界面必须能够处理大量的事件流（例如鼠标移动），同时又不能延迟关键的输入（例如按钮点击）。本练习探讨“事件合并”（event coalescing），这是操作系统用来管理高频输入流的一项基本技术 [@problem_id:3665207]。通过分析不同的合并策略，你将深入理解在输入保真度和系统响应性之间进行权衡的艺术。", "problem": "桌面操作系统（OS）上的一个用户空间图形用户界面（GUI）应用程序由一个单线程事件循环驱动，该循环处理来自内核维护的队列中的输入和计时器事件。操作系统可以在将事件传递给应用程序之前，选择性地执行输入事件合并。\n\n考虑两类事件：鼠标移动事件（用 $M$ 表示此类）和“其他”事件，如按钮按下、按键按下和计时器（用 $O$ 表示此类）。该事件循环是一个单一服务器，其总服务容量为每秒 $\\mu$ 个事件，由所有类别共享，并按到达顺序处理事件，除非操作系统通过合并来改变队列内容。\n\n假设以下基本事实和定义：\n- 如果当时间 $t \\to \\infty$ 时，存在类别 $X$ 的事件其等待时间无限增长，或者等价地，当类别 $X$ 具有非零到达率时，它获得的服务份额渐近为零，则称类别 $X$ 存在饿死现象。\n- 显示器以每秒 $f$ 帧的频率刷新，因此帧间隔为 $\\Delta = 1/f$ 秒。GUI 应用程序在渲染一帧时，仅使用渲染时刻最新的指针位置；同一帧间隔内的中间指针位置对用户而言不是单独可见的。\n- 设 $\\lambda_M$ 和 $\\lambda_O$ 分别表示 $M$ 和 $O$ 事件的到达率（可能随时间变化）。假设到达率和队列长度是可测量的，并且可以由操作系统在短时间窗口内进行估算。操作系统可以通过丢弃除最新事件外的所有事件来合并一个最长的连续 $M$ 事件序列，并保留最新的时间戳和位置。\n\n操作系统必须决定何时丢弃或合并 $M$ 事件，以防止 $O$ 饿死，同时保持 GUI 可显示内容的正确性。以下哪些策略是决定何时合并 $M$ 以使 $O$ 不饿死并保留鼠标语义的有效方法？选择所有适用的选项。\n\nA. 在任何长度为 $\\Delta = 1/f$ 的窗口内，如果测得的 $M$ 到达率超过 $f$（等价地，在一个帧间隔内到达的 $M$ 事件超过1个），则将该窗口内每个连续的 $M$ 事件序列合并为单个 $M$ 事件，仅包含最新的位置和时间戳，从而确保有效传递的 $M$ 事件率最多为 $f$，并在为当前帧保留单个 $M$ 事件后调度 $O$ 事件。\n\nB. 从不合并 $M$，并始终严格按照先进先出（FIFO）顺序传递事件，因为任何丢弃行为都违反了输入保真度。依赖应用程序最终能跟上处理速度，并依赖调度器来确保公平性。\n\nC. 仅当事件循环线程的中央处理器（CPU）利用率低于 $50\\%$ 时才合并 $M$，因为此时丢弃的工作不会影响延迟，并在利用率高时避免合并以保持保真度。\n\nD. 如果队列头部的最旧 $O$ 事件的估计等待时间超过配置的界限 $D_O$，则丢弃该 $O$ 事件前面除最新事件外的所有 $M$ 事件（保留最新的位置和时间戳），然后立即调度该 $O$ 事件，确保 $W_O \\le D_O$。\n\nE. 总是合并所有 $M$ 事件，使得每秒最多传递 1 个 $M$ 事件，不论显示刷新率 $f$ 如何，以保证 $O$ 获得大部分服务容量。", "solution": "该问题要求评估几种用于合并鼠标移动事件（$M$）以防止单线程 GUI 应用程序事件循环中其他事件（$O$）饿死的策略。评估必须考虑两个标准：防止类别 $O$ 饿死和保留鼠标语义。\n\n让我们根据给定条件建立理论框架。事件循环是一个单服务器排队系统，服务率为每秒 $\\mu$ 个事件。事件类别 $M$ 和 $O$ 的到达率分别为 $\\lambda_M$ 和 $\\lambda_O$。总到达率为 $\\lambda = \\lambda_M + \\lambda_O$。如果有效到达率 $\\lambda'$ 小于服务率 $\\mu$，则系统是稳定的。如果 $\\lambda' > \\mu$，事件队列的长度将无限增长，导致后到达事件的等待时间无限延长。\n\n如果类别 $O$ 的事件经历无限增长的等待时间，就会发生饿死。如果队列因为另一个类别的高到达率而饱和，特别是如果 $\\lambda_M$ 非常大，导致 $\\lambda_M + \\lambda_O > \\mu$，就会发生这种情况。在这种情况下，任何到达的 $O$ 事件都会被放置在一个由 $M$ 事件组成的漫长且持续增长的队列的末尾。\n\n保留鼠标语义的定义是：GUI 应用程序在每 $\\Delta = 1/f$ 秒渲染一帧时，只使用最新的指针位置。这意味着，在单个帧间隔内发生的任何 $M$ 事件序列都可以被替换为包含该序列中最后一个事件的位置和时间戳的单个 $M$ 事件，而不会丢失任何与视觉输出相关的信息。\n\n目标是找到既能确保 $O$ 事件队列稳定，又遵守此语义约束的策略。\n\n### 逐项分析\n\n**A. 在任何长度为 $\\Delta = 1/f$ 的窗口内，如果测得的 $M$ 到达率超过 $f$（等价地，在一个帧间隔内到达的 $M$ 事件超过1个），则将该窗口内每个连续的 $M$ 事件序列合并为单个 $M$ 事件，仅包含最新的位置和时间戳，从而确保有效传递的 $M$ 事件率最多为 $f$，并在为当前帧保留单个 $M$ 事件后调度 $O$ 事件。**\n\n-   **防止饿死**：该策略将鼠标事件的有效到达率 $\\lambda'_M$ 限制为最大不超过显示刷新率 $f$。进入事件队列的总有效到达率变为 $\\lambda' = \\lambda'_M + \\lambda_O \\le f + \\lambda_O$。高频鼠标可以产生 $\\lambda_M \\gg \\mu$ 的事件率，但此策略将该速率限制到一个可预测的有界值 $f$。在一个设计良好的系统中，服务容量 $\\mu$ 会被配置为处理典型显示刷新率加上其他输入的负载，即 $\\mu > f + \\lambda_O$。通过限制 $\\lambda_M$ 的贡献，该策略防止队列因鼠标事件泛滥而无限增长，从而防止类别 $O$ 饿死。\n-   **保留鼠标语义**：合并是基于帧间隔 $\\Delta$ 执行的。通过仅保留一个帧间隔内最新的 $M$ 事件，该策略为应用程序提供了渲染下一帧所需的确切信息，正如问题所述。间隔内的中间鼠标位置对用户不可见，因此在此上下文中丢弃它们在语义上是正确的。\n-   **结论**：该策略是一种主动的、有原则的方法，它正确地利用显示刷新率的物理约束来管理事件流。它满足了两个要求。因此，该选项是**正确的**。\n\n**B. 从不合并 $M$，并始终严格按照先进先出（FIFO）顺序传递事件，因为任何丢弃行为都违反了输入保真度。依赖应用程序最终能跟上处理速度，并依赖调度器来确保公平性。**\n\n-   **防止饿死**：该策略维持的有效到达率为 $\\lambda' = \\lambda_M + \\lambda_O$。正如问题动机所暗示的，高轮询率的鼠标可能产生使 $\\lambda_M \\gg \\mu$ 的事件，导致 $\\lambda' > \\mu$。在这种过载情况下，事件队列长度会无限增长。在一连串 $M$ 事件之后到达的 $O$ 事件将不得不等待所有前面的 $M$ 事件被处理，并且随着更多 $M$ 事件的到来，其等待时间将无限增长。这就是饿死的定义。对于到达率持续超过服务率的系统，断言应用程序将“最终跟上”是不正确的。提到“调度器”确保公平性是不适用的，因为瓶颈是单线程事件循环，而不是 CPU 时间分配。\n-   **保留鼠标语义**：虽然它保留了完整的输入流，但这是以牺牲系统稳定性和响应性为代价的。问题定义了一个更实际的、与可显示内容相关的语义正确性概念，而该策略的理由忽略了这一点。\n-   **结论**：该策略未能防止饿死，而这是一个主要目标。因此，该选项是**不正确的**。\n\n**C. 仅当事件循环线程的中央处理器（CPU）利用率低于 $50\\%$ 时才合并 $M$，因为此时丢弃的工作不会影响延迟，并在利用率高时避免合并以保持保真度。**\n\n-   **防止饿死**：该策略的逻辑是颠倒的。事件循环线程的高 CPU 利用率是高工作负载和持续非空事件队列的症状，表明系统处于或接近饱和状态（$\\lambda' \\approx \\mu$ 或 $\\lambda' > \\mu$）。这恰恰是事件合并最需要的时刻，以减轻负载并防止队列失控增长。通过在利用率高时避免合并，该策略允许系统保持在过载状态，直接导致 $O$ 事件的饿死。仅在 CPU 利用率低时进行合并意味着在系统没有压力且没有饿死风险时才采取行动，这使得该行动对其既定目的无效。\n-   **保留鼠标语义**：合并的标准（CPU 利用率）与语义正确性的标准（显示刷新）无关。\n-   **结论**：该策略适得其反，会加剧而不是防止饿死。因此，该选项是**不正确的**。\n\n**D. 如果队列头部的最旧 $O$ 事件的估计等待时间超过配置的界限 $D_O$，则丢弃该 $O$ 事件前面除最新事件外的所有 $M$ 事件（保留最新的位置和时间戳），然后立即调度该 $O$ 事件，确保 $W_O \\le D_O$。**\n\n-   **防止饿死**：这是一个直接针对饿死定义的反应式策略。饿死意味着无限的等待时间。该策略通过配置的最大值 $D_O$ 明确地限制了 $O$ 事件的等待时间 $W_O$。当一个 $O$ 事件的延迟接近这个界限时，操作系统会通过从队列中移除阻塞的 $M$ 事件来干预，从而允许该 $O$ 事件被处理。这保证了 $O$ 事件不会饿死，因为它们的等待时间被保持在一个有限的限制以下。\n-   **保留鼠标语义**：该策略通过只保留最新的一个来合并一连串的 $M$ 事件。这保留了被丢弃事件集中最新的指针位置，这是一种合理且常见的合并方法。虽然不像策略 A 那样明确地与显示刷新率挂钩，但它正确地认识到在一系列移动中最关键的信息是最终位置。这是保留基本鼠标语义的一种有效方法。\n-   **结论**：该策略通过限制 $O$ 事件的延迟提供了一种有效的机制来防止饿死，并且其合并 $M$ 事件的方法在语义上是合理的。因此，该选项是**正确的**。\n\n**E. 总是合并所有 $M$ 事件，使得每秒最多传递 1 个 $M$ 事件，不论显示刷新率 $f$ 如何，以保证 $O$ 获得大部分服务容量。**\n\n-   **防止饿死**：该策略将鼠标事件率限制在 $\\lambda'_M \\le 1$ Hz。总速率变为 $\\lambda' \\le 1 + \\lambda_O$。鉴于任何合理的服务容量 $\\mu$（例如，每秒数百或数千个事件），这个速率将远低于 $\\mu$，从而有效地防止队列过载和 $O$ 的饿死。\n-   **保留鼠标语义**：这是该策略失败的地方。目标是保留“GUI 可显示内容的正确性”。$1$ Hz 的鼠标更新率极低，并且与显示器的刷新率 $f$（通常为 $60$ Hz 或更高）不同步。这将导致光标每秒只更新一次位置，使其看起来像是在屏幕上跳跃而不是平滑移动。任何用户都会认为这是一个损坏或极度滞后的界面。它未能提供用户连续输入的可用或正确的表示。$1$ Hz 的选择是任意的，与系统的感知或技术约束无关。虽然它在技术上可以防止饿死，但它通过不可接受地降低鼠标输入的用户体验来实现这一点。\n-   **结论**：该策略在任何实际意义上都未能满足“保留鼠标语义”的标准。因此，该选项是**不正确的**。", "answer": "$$\\boxed{AD}$$", "id": "3665207"}, {"introduction": "现代应用程序，如网络浏览器或聊天客户端，常常需要同时管理数百甚至数千个网络连接或文件。本练习将经典的 I/O 多路复用机制（`select`/`poll`）与现代的高性能机制（`epoll`）进行对比 [@problem_id:3665180]。理解它们在可扩展性上的根本差异，是构建即使在重负载下也能保持高响应性的复杂应用程序的关键。", "problem": "图形用户界面（GUI）应用程序运行一个事件循环以保持交互响应性。假设显示器以 $60\\ \\mathrm{Hz}$ 的频率刷新，因此每帧的预算时间为 $T_f \\approx 16.7\\ \\mathrm{ms}$。事件循环在 $n$ 个文件描述符上等待输入/输出（I/O）就绪，而在一个典型的帧中，只有 $k$ 个描述符变为就绪状态，其中 $k \\ll n$。程序可以使用 select 或 poll 风格的接口（每次等待都对所有描述符进行线性扫描），也可以使用事件轮询机制，例如 Linux 上的 epoll，它在内核内部维护就绪状态，只返回那些已就绪的描述符。\n\n使用以下核心定义和事实作为您推理的基础：\n- 如果每帧的总工作量超过 $T_f$，就会发生掉帧，用户会感觉到延迟。\n- 一次 select 或 poll 调用要求用户空间准备一组 $n$ 个描述符，并由内核扫描它们以确定就绪状态；每次调用的工作量与描述符的数量 $n$（无论是否就绪）成比例扩展。\n- 基于 epoll 的等待返回内核先前已确定为就绪的描述符，因此假设注册集稳定，每次等待的返回成本与就绪描述符的数量 $k$ 成比例扩展。然而，通过注册或注销来修改 epoll 关注集需要系统调用，这会产生其自身的开销。\n- 在任何机制中，如果许多描述符同时就绪，应用程序必须迭代处理它们，处理成本与就绪事件的数量成比例扩展。\n- 大$O$表示法 $O(\\cdot)$ 描述了随指定变量的渐近扩展关系。\n\n假设每次等待调用都有一个固定的进出内核的开销 $t_0$，以及取决于机制的额外开销：\n- 对于 select 或 poll，内核在每次调用时都必须考虑 $n$ 个描述符中的每一个，每个描述符的成本为 $t_s$，用于扫描和用户-内核间描述符集的复制。\n- 对于 epoll，在关注集没有变化的稳态等待中，只返回就绪的描述符，每个返回的描述符开销为 $t_r$；但每次对关注集的更改（例如，添加或删除描述符）每个 epoll 控制操作的成本为 $t_c$。\n\n假设应用程序还必须处理它接收到的事件，其成本在任何模型中都与返回事件的数量成比例扩展。\n\n以下哪些陈述正确地解释了为什么 GUI 中的 $n$ 个活动文件描述符会导致延迟，正确地比较了 epoll 与 select 或 poll 的可扩展性，并正确地指出了病态情况？选择所有适用的选项。\n\n- A. 对于 select 或 poll，每次等待的成本约为 $t_0 + n \\cdot t_s$，无论实际有多少描述符就绪。因此，当 $n$ 增长到使 $t_0 + n \\cdot t_s > T_f$ 时，就会发生掉帧。当关注集稳定时，Epoll 将稳态等待成本降低到约 $t_0 + k \\cdot t_r$，使其与 $k$ 而不是 $n$ 成比例扩展。\n- B. epoll_wait 的时间复杂度相对于就绪描述符的数量 $k$ 是 $O(1)$；当更多描述符就绪时，它不会增加。\n- C. Select 或 poll 要求在每次等待时在用户空间和内核空间之间重建和复制描述符集，时间复杂度为 $O(n)$，而 epoll 在内核中维护关注集，减少了重复的用户-内核传输开销和每次等待的扫描，这对于有许多空闲描述符的 GUI 非常有利。\n- D. 当所有 $n$ 个描述符在一次突发中都就绪时，epoll 通过每次调用返回一个固定大小的子集来将工作量减少到 $O(\\log n)$，因此应用程序避免了迭代所有就绪的描述符。\n- E. epoll 的一个病态情况是当许多描述符持续处于就绪状态（例如，一个繁忙的管道或大量带有未读数据的套接字），因此在大多数帧中 $k \\approx n$；此时，返回和处理就绪状态的每次迭代工作量与 $n$ 成比例扩展，削弱了 epoll 的优势并可能导致延迟。\n- F. epoll 的一个病态情况是当应用程序每帧频繁地添加和删除许多描述符时（例如，重复创建一次性定时器或短生命周期的套接字），每帧执行 $m$ 次 epoll 控制操作；即使 $k$ 很小，增加的成本 $m \\cdot t_c$ 也可能占主导地位并导致帧超时。\n- G. 使用边缘触发的 epoll 并且未能完全耗尽一个就绪的非阻塞套接字或管道直到它返回 EAGAIN，这会阻止该描述符的进一步唤醒，从而产生明显的停顿，表现为 UI 延迟，即使事件仍然存在。\n\n- H. Epoll 消除了由 I/O 等待引起的上下文切换，因此无论 $n$ 或 $k$ 的大小，它都不会导致延迟。\n\n选择所有正确的选项。", "solution": "问题陈述提供了一个模型，用于分析 GUI 应用程序中不同 I/O 多路复用策略的性能，特别是比较 `select`/`poll` 风格的接口与 Linux 的 `epoll` 接口。关键的性能指标是每帧的总工作量，为了避免用户可感知的延迟，该工作量不得超过 $T_f \\approx 16.7\\ \\mathrm{ms}$ 的帧预算。被监视的文件描述符数量为 $n$，在一个典型帧中就绪的描述符数量为 $k$，其中 $k \\ll n$。\n\n`select` 或 `poll` 的每帧成本模型可以表示为：\n$$\nW_{\\text{select/poll}} = t_0 + n \\cdot t_s + C_{\\text{process}}(k)\n$$\n其中 $t_0$ 是固定的内核进入/退出开销，$t_s$ 是每个描述符的扫描和数据传输成本，$C_{\\text{process}}(k)$ 是处理 $k$ 个就绪事件的成本。系统调用的成本 $t_0 + n \\cdot t_s$ 与 $n$ 呈线性扩展。\n\n`epoll` 的每帧成本模型取决于被监视的描述符集合是否稳定。\n在稳态情况下（关注集稳定），成本为：\n$$\nW_{\\text{epoll, steady}} = t_0 + k \\cdot t_r + C_{\\text{process}}(k)\n$$\n其中 $t_r$ 是等待调用中每个就绪描述符的开销。此成本与 $k$ 成比例扩展。\n\n如果关注集是动态的，每帧有 $m$ 个描述符被添加或删除，则成本变为：\n$$\nW_{\\text{epoll, dynamic}} = t_0 + k \\cdot t_r + m \\cdot t_c + C_{\\text{process}}(k)\n$$\n其中 $t_c$ 是每个控制操作的描述符成本。\n\n我们现在将基于这个框架和操作系统的通用原理来评估每个陈述。\n\n- **A. 对于 select 或 poll，每次等待的成本约为 $t_0 + n \\cdot t_s$，无论实际有多少描述符就绪。因此，当 $n$ 增长到使 $t_0 + n \\cdot t_s > T_f$ 时，就会发生掉帧。当关注集稳定时，Epoll 将稳态等待成本降低到约 $t_0 + k \\cdot t_r$，使其与 $k$ 而不是 $n$ 成比例扩展。**\n该陈述准确地反映了所提供的成本模型。对于 `select` 或 `poll`，问题陈述指出内核“在每次调用时都必须考虑 $n$ 个描述符中的每一个，每个描述符的成本为 $t_s$”。这产生了一个 $t_0 + n \\cdot t_s$ 的等待成本，这是一个 $O(n)$ 操作。如果仅此成本就超过了帧预算 $T_f$，那么无论应用程序的工作如何，都会发生掉帧。该陈述正确地将这种扩展性确定为大 $n$ 值下延迟的来源。对于稳态下的 `epoll`，问题陈述指出每次等待的成本有“每个返回的描述符开销 $t_r$”，对于 $k$ 个就绪描述符。这给出了大约 $t_0 + k \\cdot t_r$ 的等待成本，该成本与 $k$ 而不是 $n$ 成比例。该陈述正确地对比了这两种机制。\n**结论：正确。**\n\n- **B. epoll_wait 的时间复杂度相对于就绪描述符的数量 $k$ 是 $O(1)$；当更多描述符就绪时，它不会增加。**\n该陈述不正确。问题明确指出，对于 `epoll`，“每次等待的返回成本与就绪描述符的数量 $k$ 成比例扩展”。所呈现的成本模型是 $t_0 + k \\cdot t_r$。根据定义，这相对于就绪描述符数量的时间复杂度是 $O(k)$。当更多描述符就绪时，成本线性增加。有时与 `epoll_wait` 关联的 $O(1)$ 复杂度指的是其相对于被监视的总描述符数量 $n$ 的扩展性，这是它相对于 `select` 的 $O(n)$ 复杂度的主要优势。然而，该陈述是专门关于与 $k$ 的扩展性，因此是错误的。\n**结论：不正确。**\n\n- **C. Select 或 poll 要求在每次等待时在用户空间和内核空间之间重建和复制描述符集，时间复杂度为 $O(n)$，而 epoll 在内核中维护关注集，减少了重复的用户-内核传输开销和每次等待的扫描，这对于有许多空闲描述符的 GUI 非常有利。**\n该陈述正确描述了基本的架构差异。从内核的角度来看，`select` 和 `poll` 是无状态的；用户进程必须在每次调用时传递完整的 $n$ 个描述符集，这涉及到数据传输和内核端对所有 $n$ 个描述符的扫描。这是一个 $O(n)$ 操作。`epoll` 是有状态的；关注集通过 `epoll_ctl` 注册一次并由内核内部维护。后续的 `epoll_wait` 调用不需要重新传输这 $n$ 个描述符集，从而节省了传输开销，并使内核能够避免 $O(n)$ 的扫描。这在典型的 GUI 场景中尤其有利，因为在这些场景中 $n$ 很大，但大多数描述符是空闲的（$k \\ll n$）。\n**结论：正确。**\n\n- **D. 当所有 $n$ 个描述符在一次突发中都就绪时，epoll 通过每次调用返回一个固定大小的子集来将工作量减少到 $O(\\log n)$，因此应用程序避免了迭代所有就绪的描述符。**\n该陈述是错误的。`epoll_wait` 系统调用返回所有就绪的文件描述符，最多可达用户在调用中指定的最大数量。当许多描述符就绪时，它不会人为地返回一个“固定大小的子集”或将复杂度降低到 $O(\\log n)$。如果所有 $n$ 个描述符都就绪（$k=n$），`epoll_wait` 将报告所有 $n$ 个事件，检索和处理它们的成本将与 $n$ 成比例扩展，即 $O(n)$。然后应用程序必须迭代所有 $n$ 个就绪的描述符。\n**结论：不正确。**\n\n- **E. epoll 的一个病态情况是当许多描述符持续处于就绪状态（例如，一个繁忙的管道或大量带有未读数据的套接字），因此在大多数帧中 $k \\approx n$；此时，返回和处理就绪状态的每次迭代工作量与 $n$ 成比例扩展，削弱了 epoll 的优势并可能导致延迟。**\n该陈述正确地指出了一个性能病态。`epoll` 相对于 `select` 的主要优势是其等待时间与 $k$ 而非 $n$ 成比例扩展。如果 $k$ 接近 $n$，`epoll` 的等待成本将变为约 $t_0 + n \\cdot t_r$，并且总的帧工作量与 $n$ 成比例扩展。这在渐近意义上与 `select`/`poll` 相同，后者的工作量也与 $n$ 成比例扩展。在这种“惊群”场景中，`epoll` 的扩展优势被抵消，总工作量为 $O(n)$，很容易超过帧预算 $T_f$ 并导致延迟。\n**结论：正确。**\n\n- **F. epoll 的一个病态情况是当应用程序每帧频繁地添加和删除许多描述符时（例如，重复创建一次性定时器或短生命周期的套接字），每帧执行 $m$ 次 epoll 控制操作；即使 $k$ 很小，增加的成本 $m \\cdot t_c$ 也可能占主导地位并导致帧超时。**\n该陈述根据提供的成本模型正确地指出了另一个病态情况。该模型包含了每次 `epoll` 控制操作（`epoll_ctl`）的成本 $t_c$。如果一个应用程序的文件描述符集高度动态，每帧执行 $m$ 次添加或删除操作，那么这些控制操作的累积成本 $m \\cdot t_c$ 会增加到总工作负载中。如果 $m$ 很大，这个部分可能成为每帧成本的主导因素，即使就绪描述符的数量 $k$ 很小，也可能导致总工作量 $W_{\\text{epoll, dynamic}}$ 超过 $T_f$。\n**结论：正确。**\n\n- **G. 使用边缘触发的 epoll 并且未能完全耗尽一个就绪的非阻塞套接字或管道直到它返回 EAGAIN，这会阻止该描述符的进一步唤醒，从而产生明显的停顿，表现为 UI 延迟，即使事件仍然存在。**\n该陈述描述了一个与正确使用 `epoll` 的边缘触发（ET）模式相关的著名且关键的问题。虽然没有明确包含在成本模型中，但边缘触发是 `epoll` 的一个基本特性。在 ET 模式下，只有在状态发生变化时（例如，新数据到达）才会传递唤醒信号。如果应用程序只读取了部分可用数据，它将不会再次收到该描述符的通知，直到有更多新数据到达。未读的数据仍然存在，但应用程序对此一无所知，导致事件丢失和应用程序级停顿。这表现为 UI 延迟。这是对一个导致用户可感知问题的病态使用模式的正确描述。\n**结论：正确。**\n\n- **H. Epoll 消除了由 I/O 等待引起的上下文切换，因此无论 $n$ 或 $k$ 的大小，它都不会导致延迟。**\n该陈述在两点上是不正确的。首先，`epoll_wait` 是一个阻塞式系统调用。当没有事件就绪时，内核会将调用线程置于睡眠状态，并进行上下文切换到另一个任务。它并没有消除与等待 I/O 相关的上下文切换。其次，正如在对选项 A、E 和 F 的分析中所确立的，由 `epoll` 调用执行和产生的工作确实可能导致延迟。成本与 $k$（就绪事件数）和 $m$（控制操作数）成比例扩展，如果这项工作超过了帧预算 $T_f$，就会发生延迟。声称它“不会导致延迟”是错误的。\n**结论：不正确。**", "answer": "$$\\boxed{ACEFG}$$", "id": "3665180"}, {"introduction": "在确保性能之后，我们必须关注安全性，这是操作系统为用户界面提供的另一项关键服务。本练习以我们熟悉的文件打开对话框为例，揭示一种微妙但危险的“检查时-使用时”（Time-of-Check-to-Time-of-Use, TOCTOU）竞态条件漏洞 [@problem_id:3665172]。通过评估不同的解决方案，你将学习如何利用现代操作系统提供的原语，以一种有原则的方式构建安全的用户交互。", "problem": "操作系统（OS）中的桌面文件打开对话框通过在用户确认选择前读取候选文件的一小部分来生成预览。该对话框是用户界面（UI）服务的一部分，可通过应用程序编程接口（API）访问。请考虑以下基本事实和定义：\n\n- 文件描述符，表示为 $fd$，引用一个在打开时绑定到特定文件对象（例如 inode）的打开文件描述。使用 $fd$ 的操作不执行名称解析，因此不受后续路径重命名或替换的影响。\n- 基于路径的操作通过目录解析名称，并可能跟随符号链接。在默认语义下，解析过程可能通过符号链接被重定向，或被并发的重命名操作所替换，从而产生“检查时到使用时”（Time Of Check To Time Of Use, TOCTOU）的竞争条件。\n- 一些操作系统提供目录相对路径解析，例如通过 `openat` 或 `openat2`，以及解析约束，如 `RESOLVE_NO_SYMLINKS` 和 `RESOLVE_BENEATH`，用以禁止符号链接和防止从指定的目录根目录逃逸；诸如 `O_NOFOLLOW` 的标志可防止路径的末端组件是一个符号链接。使用 `O_RDONLY` 打开会得到一个只读的 $fd$。设置 `O_CLOEXEC` 可避免描述符在 `exec` 边界泄漏，但不会影响 $fd$ 与文件对象的绑定。\n\n攻击者在对话框正在浏览的目录中放置一个名为 `photo.jpg` 的符号链接。在生成预览期间，对话框解析该路径名并读取数据以渲染缩略图。攻击者可以在预览和确认之间进行竞争，以重新指定 `photo.jpg` 的目标。设计目标是以一种有原则且与操作系统服务一致的方式，消除预览和用户确认之间的 TOCTOU 窗口，以便最终操作使用的文件对象与预览的完全相同，并且预览本身不能通过基于名称的解析技巧被欺骗去读取非预期的目标。\n\n下面哪个选项通过定义一个安全的“预览句柄”来最稳健地实现这一目标？该句柄具有防止 TOCTOU 漏洞利用的属性，同时与核心的操作系统路径解析和文件描述符语义保持一致。\n\n- A. 在预览时，获取当前浏览目录的目录文件描述符 $dfd$。使用一个禁止符号链接和目录逃逸的调用（例如，使用带 `RESOLVE_NO_SYMLINKS` 和 `RESOLVE_BENEATH` 标志的 `openat2`，外加 `O_NOFOLLOW`）来相对于 $dfd$ 解析候选文件名，并使用 `O_RDONLY | O_CLOEXEC` 打开文件以获得 $fd$。直接使用 $fd$ 读取以进行预览。将预览句柄构造为一个封装了 $fd$ 的不透明能力（capability）（可选地记录设备和 inode 等标识符用于审计），当用户确认时，将这同一个 $fd$ 返回给应用程序，而不是通过路径重新打开。如果路径在预览后被重命名或替换，该能力仍然绑定到原始文件对象；通过符号链接欺骗解析的企图在创建时就被阻止了。\n- B. 为了预览，按名称打开路径，不加特殊解析约束，并读取初始字节以渲染缩略图。记录路径字符串以及修改时间和文件大小等元数据。在确认时，通过路径重新打开并检查元数据是否匹配；仅在相等时继续，否则中止。\n- C. 为了预览，通过路径读取以渲染缩略图，然后在内存中缓存第一个内容块。在确认时，按名称重新打开原始路径；如果路径能解析，则允许访问，因为缓存的内容可用于验证用户的意图。\n- D. 为候选路径获取一个 `O_PATH` 描述符，以避免在预览期间读取数据。之后，为了预览，通过打开 `/proc/self/fd/n` 来读取以获得一个可读的描述符。在确认时，按名称重新打开原始路径，为应用程序提供一个正常的 $fd$，因为 `O_PATH` 不能直接用于 I/O。\n\n选择唯一的最佳选项。", "solution": "在尝试解决方案之前，用户提供的问题会经过一个验证过程。\n\n### 第 1 步：提取已知信息\n- **上下文：** 操作系统（OS）中的桌面文件打开对话框会生成文件预览。该对话框是用户界面（UI）服务的一部分，可通过应用程序编程接口（API）访问。\n- **文件描述符定义：** 文件描述符 `$fd$` 引用一个在打开时绑定到特定文件对象（例如 inode）的打开文件描述。使用 `$fd$` 的操作不执行名称解析，并且不受后续路径重命名或替换的影响。\n- **基于路径的操作定义：** 这些操作通过目录解析名称，并可能跟随符号链接。它们容易受到由于符号链接或并发重命名而导致的“检查时到使用时”（TOCTOU）竞争条件的影响。\n- **提供的操作系统原语：**\n    - 目录相对路径解析：`openat`、`openat2`。\n    - 解析约束：`RESOLVE_NO_SYMLINKS`（禁止符号链接）、`RESOLVE_BENEATH`（禁止从目录根目录逃逸）。\n    - 打开标志：`O_NOFOLLOW`（防止路径的末端组件是符号链接）、`O_RDONLY`（产生只读的 `$fd$`）、`O_CLOEXEC`（避免 `$fd$` 跨 `exec` 边界泄漏）。\n- **攻击者模型：** 攻击者在被浏览的目录中放置一个符号链接（例如 `` `photo.jpg` ``）。攻击者可以在预览操作和用户确认之间的时间窗口内进行竞争，以重定向该符号链接的目标。\n- **设计目标：** 消除 TOCTOU 窗口，确保最终操作使用的文件对象与预览的完全相同。预览过程本身也必须能抵御基于名称的解析攻击。\n- **问题：** 确定哪个选项最稳健地定义了一个安全的“预览句柄”来实现此目标，并与操作系统语义保持一致。\n\n### 第 2 步：使用提取的已知信息进行验证\n1.  **科学上成立：** 该问题牢固地植根于既定的计算机科学原理，特别是操作系统设计和安全。文件描述符、路径解析、符号链接和 TOCTOU 竞争条件等概念是该领域的基本主题。提到的系统调用（`openat`、`openat2`）和标志（`O_NOFOLLOW`、`RESOLVE_BENEATH` 等）是现代类Unix操作系统（如Linux）中的真实功能。所描述的场景是一个经典且实际的安全问题。\n2.  **问题定义良好：** 问题定义良好。它提出了一个清晰、具体的安全目标，并提供了一套明确的工具（操作系统原语）来实现它。问题要求在给定选项中选出“最稳健”的解决方案，这需要对每个选项提供的安全保证进行逻辑比较。通过严谨的分析可以确定唯一的最佳答案。\n3.  **客观性：** 问题陈述是客观的，使用了精确的技术语言。它定义了术语并描述了一个场景，没有主观或基于意见的断言。\n\n### 第 3 步：结论与行动\n问题陈述是**有效的**。它在科学上合理、定义良好且客观。它描述了系统编程和安全领域中一个真实且不简单的问题。可以进行求解过程。\n\n### 基于原则的推导\n问题的核心是“检查时到使用时”（Time Of Check To Time Of Use, TOCTOU）漏洞。\n- **检查时间 (TOC):** 系统预览文件。这包括将路径名（例如 `` `photo.jpg` ``）解析为文件对象并读取其部分内容。\n- **使用时间 (TOU):** 系统根据用户的确认采取行动。在简单的实现中，这包括重新解析相同的路径名以获取文件对象来执行最终操作（例如，为应用程序打开它）。\n\n漏洞存在于 TOC 和 TOU 之间的时间窗口内。由于路径名是一个可变引用，攻击者可以在此窗口期间更改其指向的目标。具体来说，`photo.jpg` 在预览期间可能指向一个良性图片，然后在用户点击“打开”之前，被原子地替换为一个指向敏感文件（例如 `~/.ssh/id_rsa`）或恶意可执行文件的符号链接。\n\n击败这种竞争条件的基本原则是在“使用时间”消除第二次名称解析。一个稳健的解决方案必须在“检查时间”建立一个对文件对象的安全、不可变的引用，并在“使用时间”使用同一个引用。\n\n正如问题中所定义的，文件描述符（`$fd$`）正是这样一个不可变的引用。一旦 `open` 系统调用成功，返回的 `$fd$` 直接绑定到文件对象（inode 及其数据），而不是用于找到它的路径名。所有后续对该 `$fd$` 的操作都将针对该特定文件对象，无论原始路径名发生什么变化。\n\n因此，一个安全的程序必须：\n1.  在开始时执行单次 `open` 操作。这次 `open` 本身必须能抵御路径解析攻击（如符号链接遍历）。问题为此提供了原语：使用目录文件描述符 `$dfd$` 的 `openat2`，以及诸如 `RESOLVE_NO_SYMLINKS`、`RESOLVE_BENEATH` 和 `O_NOFOLLOW` 的标志。\n2.  使用这次单一、安全的 `open` 操作产生的 `$fd$` 来执行所有后续操作：首先用于读取预览数据，其次用于最终的确认操作。\n\n这创建了一个“句柄”或“能力”（即 `$fd$`），它代表了用户审查过的意图，并且直接使用此能力，从而杜绝了任何基于路径名可变性的竞争条件可能性。\n\n### 逐项分析选项\n\n**A. 在预览时，获取当前浏览目录的目录文件描述符 `$dfd$`。使用一个禁止符号链接和目录逃逸的调用（例如，使用带 `RESOLVE_NO_SYMLINKS` 和 `RESOLVE_BENEATH` 标志的 `openat2`，外加 `O_NOFOLLOW`）来相对于 $dfd$ 解析候选文件名，并使用 `O_RDONLY | O_CLOEXEC` 打开文件以获得 `$fd$`。直接使用 `$fd$` 读取以进行预览。将预览句柄构造为一个封装了 `$fd$` 的不透明能力（capability）（可选地记录设备和 inode 等标识符用于审计），当用户确认时，将这同一个 `$fd$` 返回给应用程序，而不是通过路径重新打开。如果路径在预览后被重命名或替换，该能力仍然绑定到原始文件对象；通过符号链接欺骗解析的企图在创建时就被阻止了。**\n\n此选项描述了上面推导出的、完全符合原则的解决方案。\n- 它执行单次 `open` 操作。\n- 这次 `open` 操作通过使用目录文件描述符（`$dfd$`）和严格的解析标志（`RESOLVE_NO_SYMLINKS`、`RESOLVE_BENEATH`、`O_NOFOLLOW`）来防范路径解析攻击。这保护了“检查时间”。\n- 它使用产生的文件描述符（`$fd$`）进行预览和最终操作。这将“使用时间”绑定到“检查时间”，从而消除了竞争窗口。\n- 使用 `O_CLOEXEC` 是一个额外的安全最佳实践。\n这种方法是稳健、正确，并与现代操作系统的安全语义一致的。\n\n**结论：正确**\n\n**B. 为了预览，按名称打开路径，不加特殊解析约束，并读取初始字节以渲染缩略图。记录路径字符串以及修改时间和文件大小等元数据。在确认时，通过路径重新打开并检查元数据是否匹配；仅在相等时继续，否则中止。**\n\n此选项未能稳健地解决问题。\n- 它通过路径执行了两次独立的 `open` 操作，这正是 TOCTOU 漏洞的基本结构。\n- 检查（比较修改时间和大小等元数据）是不充分的。攻击者可以在新的 `open` 调用和元数据检查的 `stat` 调用 *之间* 发起竞争。此外，攻击者有可能创建一个与良性文件元数据相同的恶意文件。\n- 最重要的是，它不能保证底层的文件对象是同一个，而这正是明确的设计目标。\n\n**结论：不正确**\n\n**C. 为了预览，通过路径读取以渲染缩略图，然后在内存中缓存第一个内容块。在确认时，按名称重新打开原始路径；如果路径能解析，则允许访问，因为缓存的内容可用于验证用户的意图。**\n\n这个选项也存在严重缺陷。\n- 与选项 B 一样，它在确认时按路径重新打开文件，保留了 TOCTOU 竞争。\n- 验证第一个内容块是一个弱检查。攻击者可以精心构造一个恶意文件，其起始字节与原始文件相同，但后面包含恶意负载。\n- “如果路径能解析，则允许访问”这一说法是危险地宽松，完全忽略了路径可能解析到另一个不同的、恶意文件的风险。\n\n**结论：不正确**\n\n**D. 为候选路径获取一个 `O_PATH` 描述符，以避免在预览期间读取数据。之后，为了预览，通过打开 `` `/proc/self/fd/n` `` 来读取以获得一个可读的描述符。在确认时，按名称重新打开原始路径，为应用程序提供一个正常的 fd，因为 `O_PATH` 不能直接用于 I/O。**\n\n这个选项以一种复杂的技术开始，但以一个致命的缺陷结束。\n- 获取一个 `O_PATH` 描述符，然后通过打开 ``/proc/self/fd/n` ` 来“升级”它，是一种为特定文件对象获取可读 `$fd$` 而无需重新解析路径的有效且安全的方法。这部分逻辑对于获取预览是合理的。\n- 然而，确认的步骤是“按名称重新打开原始路径”。这一个步骤就丢弃了之前获得的所有安全优势。它在“使用时间”重新引入了路径解析步骤，从而再次打开了问题试图消除的那个 TOCTOU 漏洞。一个正确的程序也应该使用 `O_PATH` 描述符（或预览步骤中升级得到的可读描述符）来进行最终的确认操作。\n\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3665172"}]}