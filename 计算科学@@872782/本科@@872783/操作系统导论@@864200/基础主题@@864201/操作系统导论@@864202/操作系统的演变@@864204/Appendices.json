{"hands_on_practices": [{"introduction": "操作系统的演进在很大程度上是为了应对硬件的局限性。在早期计算时代，频繁的硬件故障（如断电）对长时间运行的计算任务构成了严重威胁。本练习通过一个设定在1978年的假想场景，探讨了一种经典的容错技术——检查点/恢复机制，让您亲手推导出在给定故障率的情况下，如何通过优化检查点间隔 $\\tau$ 来最小化系统停机时间，从而深入理解可靠性工程中的核心权衡。[@problem_id:3639697]", "problem": "1978 年，一个大学研究实验室部署了一台小型多用户小型计算机，其唯一可用于批量顺序传输的大容量存储外设是磁带（MT）。由于频繁的电源故障，操作系统团队希望设计一种最小化的、符合那个时代背景的检查点/恢复机制，该机制仅使用磁带，以限制计算损失并减少停机时间。\n\n要求您完成以下任务：\n\n- 提出一个合理的检查点/恢复设计方案，该方案适用于 20 世纪 70 年代后期没有虚拟内存的单体内核：\n  1) 检查点操作必须静默用户进程，清空设备队列，并将可恢复的进程状态（寄存器、内存映像、进程控制块、以标识符或路径名形式存在的打开文件表元数据，以及待处理信号）以带有版本化头部和冗余（例如，块校验和）的自描述格式，序列化到专用的检查点磁带上。系统必须在检查点窗口期间停止所有应用级的磁盘写入操作，并在磁带开头记录一个重启意图标记，以支持幂等的恢复操作。\n  2) 恢复操作必须启动一个最小化的恢复监视器，加载并倒带检查点磁带，验证头部，重建进程地址空间和寄存器，通过以一致模式重新打开路径来重新绑定打开的文件，并将设备驱动程序重新初始化到静默状态。在检查点创建时任何正在进行的设备 I/O，在恢复后都必须被视为未执行。\n\n假设您的分析采用以下量化模型：\n\n- 一个单一作业无限期运行，每 $\\tau$ 秒进行一次周期性的协调检查点。磁带写入吞吐量为 $b_{w}$（字节/秒），读取吞吐量为 $b_{r}$（字节/秒），每次磁带操作的加载/倒带延迟为 $m$（秒），序列化的检查点镜像大小为 $s$（字节）。\n- 写入一个完整检查点的时间为 $C_{w}$，从最近的检查点读取并恢复的时间为 $R_{r}$。您可以假设磁带行为是顺序的，因此 $C_{w} = m + s/b_{w}$ 且 $R_{r} = m + s/b_{r}$。\n- 故障遵循泊松过程，其速率为 $\\lambda$（次/秒），且与检查点计划无关。假设 $\\lambda \\tau \\ll 1$，这样在两个检查点之间发生一次以上故障的概率可以忽略不计，并且对于一阶分析，可以将检查点间隔内的故障点视为在 $[0,\\tau]$ 上均匀分布。\n- 将长期非生产性时钟时间比例 $D(\\tau)$ 定义为由于检查点操作、故障后重启和重新执行丢失的计算而没有取得净进展的时间所占的期望比例。\n- 将数据丢失风险 $L(\\tau)$ 定义为仅因故障后重新执行回滚计算而损失的长期期望时钟时间比例。\n\n任务：\n\n1) 从上述磁带和故障模型出发，用 $m$、$s$、$b_{w}$ 和 $b_{r}$ 推导 $C_{w}$ 和 $R_{r}$ 的表达式。\n\n2) 使用更新回报推理和 $\\lambda \\tau \\ll 1$ 近似，用 $\\lambda$、$\\tau$、$C_{w}$ 和 $R_{r}$ 推导 $D(\\tau)$ 和 $L(\\tau)$。\n\n3) 确定使 $D(\\tau)$ 最小化的检查点间隔 $\\tau^{\\ast}$，然后以闭合形式计算 $D(\\tau^{\\ast})$ 和 $L(\\tau^{\\ast})$。\n\n将您的最终答案表示为一个二元行矩阵 $\\bigl[D(\\tau^{\\ast}),\\,L(\\tau^{\\ast})\\bigr]$，用 $\\lambda$、$m$、$s$、$b_{w}$ 和 $b_{r}$ 的符号表示。不需要进行数值计算，最终方框答案中不应包含任何单位。", "solution": "该问题在科学上是成立的，问题明确且客观。它提供了一个基于可靠性工程和排队论标准原理的量化模型，适合进行数学分析。所有必需的参数都已定义，目标也明确。因此，我们可以着手求解。\n\n解答根据问题陈述中指定的三个任务进行组织。\n\n### 任务1：$C_{w}$ 和 $R_{r}$ 的表达式\n\n问题陈述提供了一个模型，用于描述使用磁带进行检查点和恢复操作的持续时间。磁带操作被建模为包含两个不同的阶段：机械延迟和数据传输期。\n\n写入一个完整检查点的时间，表示为 $C_{w}$，包括加载和倒带延迟 $m$，加上以写入吞吐量 $b_{w}$ 传输大小为 $s$ 的检查点镜像所需的时间。假设顺序写入访问，传输时间是镜像大小除以吞吐量，即 $\\frac{s}{b_{w}}$。因此，检查点写入操作的总时间是：\n$$C_{w} = m + \\frac{s}{b_{w}}$$\n\n类似地，读取检查点数据并执行系统恢复的时间，表示为 $R_{r}$，包括相同的机械延迟 $m$，加上以读取吞吐量 $b_{r}$ 读取大小为 $s$ 的镜像所需的时间。读取传输时间是 $\\frac{s}{b_{r}}$。因此，恢复操作的总时间是：\n$$R_{r} = m + \\frac{s}{b_{r}}$$\n\n### 任务2：$D(\\tau)$ 和 $L(\\tau)$ 的推导\n\n我们使用基于检查点间隔内故障稀少（即 $\\lambda \\tau \\ll 1$）假设的一阶分析，来推导长期非生产性时间比例 $D(\\tau)$ 和数据丢失风险 $L(\\tau)$。这使我们能够考虑每个非生产性活动贡献的开销比例。我们在一个任意长的时钟时间段 $T_{total}$ 内分析系统。\n\n1.  **用于检查点操作的时间：** 在没有故障的情况下，系统执行 $\\tau$ 时长的有用计算，然后花费 $C_{w}$ 时长进行一次检查点操作。这样一个周期的时长是 $\\tau + C_{w}$。在 $T_{total}$ 期间进行的检查点数量约为 $\\frac{T_{total}}{\\tau + C_{w}}$。由于假定开销占总时间的一小部分，我们可以用 $\\tau$ 来近似周期长度，因此检查点数量约为 $\\frac{T_{total}}{\\tau}$。用于检查点操作的总时间是这个数量乘以一次检查点操作的时长 $C_{w}$。\n    $$T_{checkpoint} \\approx \\frac{T_{total}}{\\tau} C_{w}$$\n    用于检查点操作的时间比例为 $\\frac{T_{checkpoint}}{T_{total}} = \\frac{C_{w}}{\\tau}$。\n\n2.  **用于恢复的时间：** 故障以速率 $\\lambda$ 的泊松过程发生。在 $T_{total}$ 期间，预期的故障次数为 $\\lambda T_{total}$。每次故障都需要一次恢复操作，耗时 $R_{r}$ 秒。用于恢复操作的总时间是故障次数乘以单次恢复的时长。\n    $$T_{restore} = (\\lambda T_{total}) R_{r}$$\n    用于恢复的时间比例为 $\\frac{T_{restore}}{T_{total}} = \\lambda R_{r}$。\n\n3.  **用于重新执行丢失工作的时间：** 当发生故障时，自上一个成功检查点以来执行的计算会丢失，必须重新执行。假设故障发生在时间 $t_{f}$，该时间在区间 $[0, \\tau]$ 内均匀分布。因此，丢失的计算时间的期望值为 $E[t_{f}] = \\frac{\\tau}{2}$。用于重新执行丢失工作的总时间是预期的故障次数乘以每次故障预期的损失时间。\n    $$T_{re-execute} = (\\lambda T_{total}) \\left(\\frac{\\tau}{2}\\right)$$\n    用于重新执行的时间比例为 $\\frac{T_{re-execute}}{T_{total}} = \\frac{\\lambda \\tau}{2}$。\n\n数据丢失风险 $L(\\tau)$ 被定义为仅因重新执行而损失的时间比例。根据以上推导，我们有：\n$$L(\\tau) = \\frac{\\lambda \\tau}{2}$$\n\n总的非生产性时间比例 $D(\\tau)$ 是所有非生产性活动（检查点操作、恢复和重新执行）所用时间比例的总和。\n$$D(\\tau) = \\frac{C_{w}}{\\tau} + \\lambda R_{r} + \\frac{\\lambda \\tau}{2}$$\n此表达式与各个开销比例的总和一致，并代表了检查点开销的标准一阶模型。\n\n### 任务3：最优检查点间隔及相关开销\n\n为了找到使总非生产性时间比例 $D(\\tau)$ 最小化的检查点间隔 $\\tau^{\\ast}$，我们必须找到使任务2中推导出的表达式最小化的 $\\tau$ 值。\n$$D(\\tau) = \\frac{C_{w}}{\\tau} + \\frac{\\lambda \\tau}{2} + \\lambda R_{r}$$\n项 $\\lambda R_{r}$ 相对于 $\\tau$ 是常数，所以我们只需要最小化函数中与 $\\tau$ 相关的部分。我们通过对 $D(\\tau)$ 求关于 $\\tau$ 的导数并将其设为零来找到最小值。\n$$\\frac{dD}{d\\tau} = \\frac{d}{d\\tau} \\left( C_{w}\\tau^{-1} + \\frac{\\lambda}{2}\\tau + \\lambda R_{r} \\right) = -C_{w}\\tau^{-2} + \\frac{\\lambda}{2}$$\n将导数设为零以找到临界点：\n$$-\\frac{C_{w}}{(\\tau^{\\ast})^2} + \\frac{\\lambda}{2} = 0$$\n$$\\frac{\\lambda}{2} = \\frac{C_{w}}{(\\tau^{\\ast})^2}$$\n$$(\\tau^{\\ast})^2 = \\frac{2 C_{w}}{\\lambda}$$\n$$\\tau^{\\ast} = \\sqrt{\\frac{2 C_{w}}{\\lambda}}$$\n为确认这是一个最小值，我们检查二阶导数：\n$$\\frac{d^2D}{d\\tau^2} = \\frac{d}{d\\tau} \\left(-C_{w}\\tau^{-2}\\right) = 2C_{w}\\tau^{-3} = \\frac{2 C_{w}}{\\tau^3}$$\n由于 $C_{w} > 0$ 且 $\\tau > 0$，二阶导数为正，这证实了 $\\tau^{\\ast}$ 对应一个局部最小值。\n\n现在我们在此最优间隔下计算 $D(\\tau^{\\ast})$ 和 $L(\\tau^{\\ast})$。\n首先，对于 $L(\\tau^{\\ast})$：\n$$L(\\tau^{\\ast}) = \\frac{\\lambda \\tau^{\\ast}}{2} = \\frac{\\lambda}{2} \\sqrt{\\frac{2 C_{w}}{\\lambda}} = \\frac{1}{2}\\sqrt{\\lambda^2 \\frac{2 C_{w}}{\\lambda}} = \\sqrt{\\frac{2 \\lambda^2 C_{w}}{4\\lambda}} = \\sqrt{\\frac{\\lambda C_{w}}{2}}$$\n\n接下来，对于 $D(\\tau^{\\ast})$：\n$$D(\\tau^{\\ast}) = \\frac{C_{w}}{\\tau^{\\ast}} + \\frac{\\lambda \\tau^{\\ast}}{2} + \\lambda R_{r}$$\n我们将 $\\tau^{\\ast}$ 的表达式代入第一项：\n$$\\frac{C_{w}}{\\tau^{\\ast}} = \\frac{C_{w}}{\\sqrt{\\frac{2 C_{w}}{\\lambda}}} = C_{w}\\sqrt{\\frac{\\lambda}{2 C_{w}}} = \\sqrt{\\frac{C_{w}^2\\lambda}{2 C_{w}}} = \\sqrt{\\frac{\\lambda C_{w}}{2}}$$\n在最优点，$D(\\tau^{\\ast})$ 的前两项相等：$\\frac{C_{w}}{\\tau^{\\ast}} = L(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda C_{w}}{2}}$。这表明在最优间隔下，因检查点操作损失的时间等于因重新执行损失的时间。\n$$D(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda C_{w}}{2}} + \\sqrt{\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = 2\\sqrt{\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = \\sqrt{4\\frac{\\lambda C_{w}}{2}} + \\lambda R_{r} = \\sqrt{2\\lambda C_{w}} + \\lambda R_{r}$$\n\n最后，我们通过代入任务1中 $C_{w}$ 和 $R_{r}$ 的表达式，用基本参数 $\\lambda$、$m$、$s$、$b_{w}$ 和 $b_{r}$ 来表示这些结果。\n$$C_{w} = m + \\frac{s}{b_{w}}$$\n$$R_{r} = m + \\frac{s}{b_{r}}$$\n\n将 $C_{w}$ 代入 $L(\\tau^{\\ast})$ 的表达式中：\n$$L(\\tau^{\\ast}) = \\sqrt{\\frac{\\lambda}{2} \\left(m + \\frac{s}{b_{w}}\\right)}$$\n\n将 $C_{w}$ 和 $R_{r}$ 都代入 $D(\\tau^{\\ast})$ 的表达式中：\n$$D(\\tau^{\\ast}) = \\sqrt{2\\lambda \\left(m + \\frac{s}{b_{w}}\\right)} + \\lambda \\left(m + \\frac{s}{b_{r}}\\right)$$\n\n最终答案是二元行矩阵 $[D(\\tau^{\\ast}), L(\\tau^{\\ast})]$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n\\sqrt{2 \\lambda \\left(m + \\frac{s}{b_{w}}\\right)} + \\lambda \\left(m + \\frac{s}{b_{r}}\\right) & \\sqrt{\\frac{\\lambda}{2} \\left(m + \\frac{s}{b_{w}}\\right)}\n\\end{pmatrix}\n}\n$$", "id": "3639697"}, {"introduction": "随着操作系统越来越多地被用于管理关键的持久化数据，如何确保数据在存储介质上不被“静默损坏” (silent corruption) 成为一个核心挑战。本练习将带您对比两种文件系统设计：一种是没有端到端校验的传统设计，另一种是采用校验和与数据复制的现代设计。通过运用基本的概率论，您将定量地计算出两种设计在读取大文件时遭遇数据丢失的概率，从而清晰地看到现代文件系统在数据完整性方面实现的巨大飞跃。[@problem_id:3639725]", "problem": "考虑从没有端到端完整性的传统文件系统到现代带校验和的文件系统的历史演变。在传统设计中，操作系统（OS）不维护文件数据的端到端校验和；存储设备带来的任何静默损坏都无法被检测到，损坏的字节会返回给应用程序。在现代设计中，文件系统为每个数据块存储一个强校验和（假设检测完美），并为每个数据块维护两个独立的副本，例如在独立磁盘冗余阵列（RAID）级别 $1$ 镜像中。如果从一个副本读取数据块时校验和验证失败，文件系统会读取另一个副本，并在至少有一个副本持有未损坏的拷贝时返回正确的数据。\n\n静默损坏的模型如下：每次读取数据块时，会以概率 $p$ 独立地发生静默损坏，且损坏事件在不同数据块之间以及不同副本之间是独立的。设文件大小为 $1$ 吉字节（GiB），数据块大小为 $4$ 千字节（KiB）。取每次数据块读取的 $p = 1 \\times 10^{-9}$。将单次完整文件读取的端到端数据丢失定义为以下事件：应用程序由于至少一个数据块未能获取正确数据，原因或为损坏数据未被检测到而返回（传统设计），或为损坏被检测到但在两个副本中均无法恢复（带校验和的设计）。\n\n仅从事件独立性、补集法则和基本概率乘法法则的核心定义出发，推导两种设计下，单次完整文件读取的端到端数据丢失概率的表达式：\n- 不带校验和且无副本的传统文件系统。\n- 带完美检测和两个独立副本的校验和文件系统。\n\n然后根据给定参数计算数值。将两个概率以标准科学记数法的小数形式表示。答案四舍五入至 $4$ 位有效数字。不允许使用百分号；给出纯小数形式的数值，不带单位。", "solution": "问题陈述已被评估并被认为是有效的。它具有科学依据，问题提出得当且客观。所有必要的参数均已提供，且该模型虽然简化，但遵循了与计算机系统可靠性相关的逻辑和概率原则。\n\n目标是推导和计算在两种不同的文件系统设计下，单次完整文件读取的端到端数据丢失概率。我们首先确定文件中的总数据块数。\n\n设 $1$ 吉字节（GiB）为 $2^{30}$ 字节，$1$ 千字节（KiB）为 $2^{10}$ 字节。文件大小为 $1$ GiB，数据块大小为 $4$ KiB。数据块的数量 $N$ 是文件大小与数据块大小的比值：\n$$N = \\frac{\\text{File Size}}{\\text{Block Size}} = \\frac{1 \\text{ GiB}}{4 \\text{ KiB}} = \\frac{2^{30} \\text{ bytes}}{4 \\times 2^{10} \\text{ bytes}} = \\frac{2^{30}}{2^2 \\times 2^{10}} = \\frac{2^{30}}{2^{12}} = 2^{18}$$\n计算该值得出：\n$$N = 2^{18} = 262144$$\n\n我们已知单次数据块读取发生静默损坏的概率为 $p = 1 \\times 10^{-9}$。这些事件对于每次数据块读取都是独立的。\n\n**传统文件系统（无校验和，无副本）**\n\n在传统设计中，如果至少有一个数据块在读取时发生静默损坏，就会发生数据丢失。由于没有校验和来检测错误，应用程序会接收到损坏的数据。\n\n设 $P_L$ 为传统系统的端到端数据丢失概率。更直接的方法是先计算成功读取文件的概率，这是一个互补事件。当且仅当所有 $N$ 个数据块都无损坏地被读取时，一次完整的文件读取才是成功的。\n\n单个数据块被正确读取（即没有损坏）的概率是 $1-p$。\n由于所有数据块的读取事件都是独立的，所有 $N$ 个数据块都被正确读取的概率是它们各自成功概率的乘积：\n$$P(\\text{success}) = (1-p) \\times (1-p) \\times \\dots \\times (1-p) \\quad (N \\text{ times})$$\n$$P(\\text{success}) = (1-p)^N$$\n\n数据丢失事件 $P_L$ 是成功读取的补集。使用补集法则 $P(A) = 1 - P(A^c)$：\n$$P_L = 1 - P(\\text{success}) = 1 - (1-p)^N$$\n\n代入给定值 $N = 262144$ 和 $p = 1 \\times 10^{-9}$：\n$$P_L = 1 - (1 - 1 \\times 10^{-9})^{262144}$$\n\n对于一个小的 $x$ 值，可以使用二项式近似 $(1-x)^n \\approx 1-nx$。这里，$p$ 非常小，所以 $Np = (262144)(1 \\times 10^{-9}) = 2.62144 \\times 10^{-4}$ 也很小。这证明了使用该近似是合理的：\n$$P_L \\approx 1 - (1 - Np) = Np$$\n$$P_L \\approx 262144 \\times (1 \\times 10^{-9}) = 2.62144 \\times 10^{-4}$$\n四舍五入到 $4$ 位有效数字，我们得到：\n$$P_L \\approx 2.621 \\times 10^{-4}$$\n\n**带校验和的文件系统（两个副本）**\n\n在现代设计中，每个数据块有两个独立的副本。只要至少有一个副本是未损坏的，该数据块的数据就能被正确返回。仅当一个数据块的*两个*副本在读取时都损坏，才会发生该数据块的数据丢失。\n\n设 $p$ 为从单个副本读取时发生损坏的概率。从两个副本读取是独立的。单个数据块的两个副本都损坏的概率是：\n$$p_{\\text{block loss}} = p \\times p = p^2$$\n一个给定的数据块可恢复（即不发生数据块丢失事件）的概率是其补集：\n$$P(\\text{block recoverable}) = 1 - p^2$$\n\n要使一次完整的文件读取成功，所有 $N$ 个数据块都必须是可恢复的。由于损坏事件在不同数据块之间是独立的，一次成功的完整文件读取的概率是 $N$ 个数据块各自可恢复概率的乘积：\n$$P(\\text{success}) = (1 - p^2) \\times (1 - p^2) \\times \\dots \\times (1 - p^2) \\quad (N \\text{ times})$$\n$$P(\\text{success}) = (1 - p^2)^N$$\n\n设 $P_M$ 为现代系统的端到端数据丢失概率。这是成功读取的补集：\n$$P_M = 1 - P(\\text{success}) = 1 - (1 - p^2)^N$$\n\n代入值 $N = 262144$ 和 $p = 1 \\times 10^{-9}$：\n$$p^2 = (1 \\times 10^{-9})^2 = 1 \\times 10^{-18}$$\n$$P_M = 1 - (1 - 1 \\times 10^{-18})^{262144}$$\n\n$p^2$ 的值极小。我们可以放心地使用二项式近似 $1 - (1-x)^N \\approx Nx$，其中 $x=p^2$：\n$$P_M \\approx N p^2$$\n$$P_M \\approx 262144 \\times (1 \\times 10^{-18}) = 2.62144 \\times 10^5 \\times 10^{-18} = 2.62144 \\times 10^{-13}$$\n四舍五入到 $4$ 位有效数字得出：\n$$P_M \\approx 2.621 \\times 10^{-13}$$\n\n结果表明，校验和与副本的结合极大地提升了数据完整性。数据丢失的概率降低了约九个数量级。", "answer": "$$\\boxed{\\begin{pmatrix} 2.621 \\times 10^{-4} & 2.621 \\times 10^{-13} \\end{pmatrix}}$$", "id": "3639725"}, {"introduction": "现代操作系统极其复杂，理解其内部的实时行为对于性能诊断和安全监控至关重要，但这本身会带来性能开销。本练习通过一个简化的数学模型，让您探索“可观测性”的价值与“探测”成本之间的权衡，其中价值函数 $V(s)$ 体现了边际效益递减，而成本函数 $\\kappa(s)$ 则反映了开销的增加。通过求解最优采样率 $s^{\\star}$，您将理解像 DTrace 和 eBPF 这样的高级内核追踪工具背后的设计哲学，即在提供深刻洞察的同时，如何将系统开销降至最低。[@problem_id:3639734]", "problem": "现代操作系统从粗粒度的事件记录演变为普适的内核跟踪设施，以在系统行为的洞察力与运行时开销之间取得平衡。考虑对这种权衡进行建模，以解释诸如 DTrace 和扩展伯克利包过滤器 (eBPF) 等内核跟踪工具的兴起。设可观测性价值是采样率 $s$ (单位：样本/秒) 的凹函数 $V(s)$，它捕捉了随着探针增多而带来的收益递减效应；设探针成本是凸函数 $\\kappa(s)$，它反映了由于竞争和缓存效应而增加的开销。具体来说，假设\n$$V(s) = \\alpha \\ln\\!\\big(1 + \\beta s\\big), \\quad \\kappa(s) = \\gamma s + \\delta s^{2},$$\n参数为 $\\alpha = 100$, $\\beta = 5 \\times 10^{-3}$ $\\mathrm{s}$, $\\gamma = 0.1$ 和 $\\delta = 1 \\times 10^{-4}$。净收益为 $F(s) = V(s) - \\kappa(s)$。\n\n使用基于微积分的优化基本原理（边际效益等于边际成本），并假设 $s \\ge 0$，确定使 $F(s)$ 最大化的采样率 $s^{\\star}$。将您的答案四舍五入到 $3$ 位有效数字，并以样本/秒为单位表示采样率。", "solution": "向普适内核跟踪的演变可以通过可观测性与开销之间的形式化权衡来解释：随着探针密度的增加，插桩提供的增量洞察力会递减，而由于共享资源竞争，开销的增长超过线性。捕捉收益递减的典型方法是对数效用，而捕捉开销增长的典型方法是二次成本。我们将净收益形式化为\n$$F(s) = V(s) - \\kappa(s) = \\alpha \\ln\\!\\big(1 + \\beta s\\big) - \\gamma s - \\delta s^{2}.$$\n我们寻求 $s^{\\star} \\ge 0$ 来最大化 $F(s)$。根据可微凹目标的标准一阶最优性条件，最大化点满足\n$$\\frac{d}{ds}F(s) = 0,$$\n并且二阶条件验证了该驻点是一个最大值点。\n\n计算导数：\n$$\\frac{d}{ds}F(s) = \\frac{d}{ds}\\left[\\alpha \\ln\\!\\big(1 + \\beta s\\big)\\right] - \\frac{d}{ds}(\\gamma s) - \\frac{d}{ds}(\\delta s^{2}) = \\frac{\\alpha \\beta}{1 + \\beta s} - \\gamma - 2 \\delta s.$$\n将导数设为零：\n$$\\frac{\\alpha \\beta}{1 + \\beta s} - \\gamma - 2 \\delta s = 0.$$\n重新整理以求解 $s$。两边同乘以 $\\big(1 + \\beta s\\big)$ 以消去分母：\n$$\\alpha \\beta = \\big(\\gamma + 2 \\delta s\\big)\\big(1 + \\beta s\\big).$$\n展开右侧：\n$$\\alpha \\beta = \\gamma + \\gamma \\beta s + 2 \\delta s + 2 \\delta \\beta s^{2}.$$\n合并项得到关于 $s$ 的二次方程：\n$$2 \\delta \\beta s^{2} + \\big(\\gamma \\beta + 2 \\delta\\big) s + \\gamma - \\alpha \\beta = 0.$$\n使用给定的参数 $\\alpha = 100$, $\\beta = 5 \\times 10^{-3}$, $\\gamma = 0.1$ 和 $\\delta = 1 \\times 10^{-4}$，计算系数：\n- $2 \\delta \\beta = 2 \\times \\big(1 \\times 10^{-4}\\big) \\times \\big(5 \\times 10^{-3}\\big) = 1 \\times 10^{-6}$,\n- $\\gamma \\beta + 2 \\delta = 0.1 \\times \\big(5 \\times 10^{-3}\\big) + 2 \\times \\big(1 \\times 10^{-4}\\big) = 5 \\times 10^{-4} + 2 \\times 10^{-4} = 7 \\times 10^{-4}$,\n- $\\gamma - \\alpha \\beta = 0.1 - 100 \\times \\big(5 \\times 10^{-3}\\big) = 0.1 - 0.5 = -0.4$。\n\n因此二次方程为\n$$\\big(1 \\times 10^{-6}\\big) s^{2} + \\big(7 \\times 10^{-4}\\big) s - 0.4 = 0.$$\n使用二次公式求解。令 $a = 1 \\times 10^{-6}$, $b = 7 \\times 10^{-4}$，以及 $c = -0.4$。判别式为\n$$\\Delta = b^{2} - 4 a c = \\big(7 \\times 10^{-4}\\big)^{2} - 4 \\times \\big(1 \\times 10^{-6}\\big) \\times \\big(-0.4\\big) = 4.9 \\times 10^{-7} + 1.6 \\times 10^{-6} = 2.09 \\times 10^{-6}.$$\n其平方根为\n$$\\sqrt{\\Delta} = \\sqrt{2.09 \\times 10^{-6}} \\approx 1.446664 \\times 10^{-3}.$$\n方程的根为\n$$s = \\frac{-b \\pm \\sqrt{\\Delta}}{2 a} = \\frac{-7 \\times 10^{-4} \\pm 1.446664 \\times 10^{-3}}{2 \\times 10^{-6}}.$$\n负根不可行 ($s  0$)，因此取正根：\n$$s^{\\star} = \\frac{-7 \\times 10^{-4} + 1.446664 \\times 10^{-3}}{2 \\times 10^{-6}} = \\frac{7.46664 \\times 10^{-4}}{2 \\times 10^{-6}} \\approx 3.73332 \\times 10^{2}.$$\n验证二阶条件：\n$$\\frac{d^{2}}{ds^{2}}F(s) = -\\frac{\\alpha \\beta^{2}}{\\big(1 + \\beta s\\big)^{2}} - 2 \\delta  0,$$\n对于所有 $s \\ge 0$，因为 $\\alpha > 0$, $\\beta > 0$ 和 $\\delta > 0$。因此，该驻点确实是 $s \\ge 0$ 上的全局最大值点。\n\n将 $s^{\\star}$ 四舍五入到 $3$ 位有效数字：\n$$s^{\\star} \\approx 373.$$\n在操作系统演变背景下的解释：凹函数 $V(s)$ 模拟了这样一个事实，即探针密度的早期增加（如 DTrace 和后来的扩展伯克利包过滤器所实现的）能产生显著的洞察力，但每个额外的探针贡献越来越少。凸函数 $\\kappa(s)$ 模拟了开销随着探针密度的增加而急剧增长，尤其是在使用朴素的插桩技术时；诸如扩展伯克利包过滤器之类的进步降低了 $\\gamma$ 和 $\\delta$，从而将最优点移向更高的 $s^{\\star}$，同时保持了效率。对于给定的参数，最佳采样率为 373 样本/秒。", "answer": "$$\\boxed{373}$$", "id": "3639734"}]}