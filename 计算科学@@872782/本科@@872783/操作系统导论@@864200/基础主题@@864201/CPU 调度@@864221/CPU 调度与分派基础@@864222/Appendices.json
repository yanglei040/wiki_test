{"hands_on_practices": [{"introduction": "理解CPU调度的第一步是比较最基础的算法。本练习提供一个具体场景，让您并排模拟“先来先服务”（FCFS）和“最短作业优先”（SJF）调度器，并使用“减速比”这一指标来量化它们的性能差异。这项练习旨在培养您手动追踪调度器行为的基础技能，并理解为何需要发展更复杂的算法 [@problem_id:3630106]。", "problem": "一个单处理器中央处理单元 (CPU) 执行一个由六个具有任意到达时间的独立作业组成的混合工作负载。调度和上下文切换的开销可以忽略不计（假设为零）。就绪队列由先来先服务 (FCFS) 或非抢占式最短作业优先 (SJF) 算法管理。对于 FCFS，同时到达的作业之间的平局由作业索引的递增顺序打破。对于 SJF，当 CPU 空闲时，调度程序选择可用作业中服务时间最短的作业；平局首先按最早到达时间打破，然后按作业索引的递增顺序打破。如果就绪队列为空，CPU 将保持空闲直到下一个作业到达。所有时间均以毫秒为单位。对于每个作业 $J_i$，设到达时间为 $a_i$，服务时间（CPU 突发时间）为 $s_i$，开始时间为 $b_i$，完成时间为 $f_i$，周转时间为 $c_i = f_i - a_i$，减速比为 $S_i = \\frac{c_i}{s_i}$。\n\n工作负载如下：\n- 作业 $J_1$：$a_1 = 0$, $s_1 = 8$。\n- 作业 $J_2$：$a_2 = 0$, $s_2 = 3$。\n- 作业 $J_3$：$a_3 = 0$, $s_3 = 1$。\n- 作业 $J_4$：$a_4 = 2$, $s_4 = 9$。\n- 作业 $J_5$：$a_5 = 3$, $s_5 = 2$。\n- 作业 $J_6$：$a_6 = 6$, $s_6 = 5$。\n\n仅使用上述定义和调度规则，确定 FCFS 下的算术平均减速比（记为 $\\overline{S}_{\\mathrm{FCFS}}$）和 SJF 下的算术平均减速比（记为 $\\overline{S}_{\\mathrm{SJF}}$）。然后计算比率\n$$R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}.$$\n仅报告 $R$ 的纯数值，四舍五入到四位有效数字。", "solution": "问题陈述经过仔细审查，被认为是有效的。这是一个来自操作系统领域（特别是 CPU 调度）的适定问题。它为六个作业提供了一套完整的数据，定义了两种调度算法（先来先服务和非抢占式最短作业优先）并附有明确的平局打破规则，同时指定了所有必要的性能指标。其中没有科学上的不一致、矛盾或模糊之处。因此，我们可以着手求解。\n\n问题要求计算两种不同调度策略下的算术平均减速比及其比率。给出的定义如下：\n- 到达时间: $a_i$\n- 服务时间: $s_i$\n- 完成时间: $f_i$\n- 周转时间: $c_i = f_i - a_i$\n- 减速比: $S_i = \\frac{c_i}{s_i}$\n- 平均减速比: $\\overline{S} = \\frac{1}{N} \\sum_{i=1}^{N} S_i$，其中 $N=6$。\n\n工作负载包含从 $J_1$ 到 $J_6$ 的 $6$ 个作业：\n- $J_1: a_1=0, s_1=8$\n- $J_2: a_2=0, s_2=3$\n- $J_3: a_3=0, s_3=1$\n- $J_4: a_4=2, s_4=9$\n- $J_5: a_5=3, s_5=2$\n- $J_6: a_6=6, s_6=5$\n\n**第一部分：先来先服务 (FCFS) 调度分析**\n\n在 FCFS 下，作业按其到达顺序进行处理。对于同时到达的作业，通过递增的作业索引来打破平局。\n- 在时间 $t=0$ 时，作业 $J_1$、$J_2$ 和 $J_3$ 到达。按作业索引排序的就绪队列为 ($J_1, J_2, J_3$)。\n- CPU 在 $t=0$ 时开始处理 $J_1$。它运行 $s_1 = 8$ 个时间单位。\n- $J_1$ 的完成时间为 $f_1 = 0 + 8 = 8$。\n- 在 $t=8$ 时，CPU 变为空闲。此时就绪队列包含所有其他作业，因为它们都已到达。FCFS 顺序（基于原始到达时间和作业索引）为 ($J_2, J_3, J_4, J_5, J_6$)。\n- CPU 在 $t=8$ 时开始处理 $J_2$。它运行 $s_2 = 3$ 个时间单位。\n- $J_2$ 的完成时间为 $f_2 = 8 + 3 = 11$。\n- CPU 在 $t=11$ 时开始处理 $J_3$。它运行 $s_3 = 1$ 个时间单位。\n- $J_3$ 的完成时间为 $f_3 = 11 + 1 = 12$。\n- CPU 在 $t=12$ 时开始处理 $J_4$。它运行 $s_4 = 9$ 个时间单位。\n- $J_4$ 的完成时间为 $f_4 = 12 + 9 = 21$。\n- CPU 在 $t=21$ 时开始处理 $J_5$。它运行 $s_5 = 2$ 个时间单位。\n- $J_5$ 的完成时间为 $f_5 = 21 + 2 = 23$。\n- CPU 在 $t=23$ 时开始处理 $J_6$。它运行 $s_6 = 5$ 个时间单位。\n- $J_6$ 的完成时间为 $f_6 = 23 + 5 = 28$。\n\n现在，我们为每个作业计算周转时间 $c_i$ 和减速比 $S_i$。\n- $J_1$：$c_1 = f_1 - a_1 = 8 - 0 = 8$。$S_1 = c_1/s_1 = 8/8 = 1$。\n- $J_2$：$c_2 = f_2 - a_2 = 11 - 0 = 11$。$S_2 = c_2/s_2 = 11/3$。\n- $J_3$：$c_3 = f_3 - a_3 = 12 - 0 = 12$。$S_3 = c_3/s_3 = 12/1 = 12$。\n- $J_4$：$c_4 = f_4 - a_4 = 21 - 2 = 19$。$S_4 = c_4/s_4 = 19/9$。\n- $J_5$：$c_5 = f_5 - a_5 = 23 - 3 = 20$。$S_5 = c_5/s_5 = 20/2 = 10$。\n- $J_6$：$c_6 = f_6 - a_6 = 28 - 6 = 22$。$S_6 = c_6/s_6 = 22/5$。\n\nFCFS 的算术平均减速比为：\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(1 + \\frac{11}{3} + 12 + \\frac{19}{9} + 10 + \\frac{22}{5}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(23 + \\frac{11}{3} + \\frac{19}{9} + \\frac{22}{5}\\right) $$\n为了对分数求和，我们找到公分母 $45$：\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{23 \\cdot 45}{45} + \\frac{11 \\cdot 15}{45} + \\frac{19 \\cdot 5}{45} + \\frac{22 \\cdot 9}{45}\\right) $$\n$$ \\overline{S}_{\\mathrm{FCFS}} = \\frac{1}{6} \\left(\\frac{1035 + 165 + 95 + 198}{45}\\right) = \\frac{1}{6} \\left(\\frac{1493}{45}\\right) = \\frac{1493}{270} $$\n\n**第二部分：非抢占式最短作业优先 (SJF) 调度分析**\n\n在非抢占式 SJF 下，当 CPU 变为空闲时，它会选择可用作业中服务时间最短的作业。平局首先按最早到达时间打破，然后按递增的作业索引打破。\n\n- 在 $t=0$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_2(s_2=3, a_2=0)$ 和 $J_3(s_3=1, a_3=0)$。根据最短服务时间，选择 $J_3$。\n- $J_3$ 在 $t=0$ 时开始，运行 $s_3=1$。完成时间 $f_3 = 1$。\n- 在 $t=1$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$ 和 $J_2(s_2=3, a_2=0)$。最短的是 $J_2$。\n- $J_2$ 在 $t=1$ 时开始，运行 $s_2=3$。完成时间 $f_2 = 1+3=4$。在其执行期间，$J_4(a_4=2, s_4=9)$ 和 $J_5(a_5=3, s_5=2)$ 到达。\n- 在 $t=4$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_4(s_4=9, a_4=2)$ 和 $J_5(s_5=2, a_5=3)$。最短的是 $J_5$。\n- $J_5$ 在 $t=4$ 时开始，运行 $s_5=2$。完成时间 $f_5 = 4+2=6$。在其执行期间，$J_6(a_6=6, s_6=5)$ 在其完成的时刻到达。\n- 在 $t=6$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$、$J_4(s_4=9, a_4=2)$ 和 $J_6(s_6=5, a_6=6)$。最短的是 $J_6$。\n- $J_6$ 在 $t=6$ 时开始，运行 $s_6=5$。完成时间 $f_6 = 6+5=11$。\n- 在 $t=11$ 时，CPU 空闲。就绪队列包含 $J_1(s_1=8, a_1=0)$ 和 $J_4(s_4=9, a_4=2)$。最短的是 $J_1$。\n- $J_1$ 在 $t=11$ 时开始，运行 $s_1=8$。完成时间 $f_1 = 11+8=19$。\n- 在 $t=19$ 时，CPU 空闲。只剩下作业 $J_4$。\n- $J_4$ 在 $t=19$ 时开始，运行 $s_4=9$。完成时间 $f_4 = 19+9=28$。\n\n现在，我们计算 SJF 下每个作业的周转时间 $c_i$ 和减速比 $S_i$。\n- $J_1$：$c_1 = f_1 - a_1 = 19 - 0 = 19$。$S_1 = c_1/s_1 = 19/8$。\n- $J_2$：$c_2 = f_2 - a_2 = 4 - 0 = 4$。$S_2 = c_2/s_2 = 4/3$。\n- $J_3$：$c_3 = f_3 - a_3 = 1 - 0 = 1$。$S_3 = c_3/s_3 = 1/1 = 1$。\n- $J_4$：$c_4 = f_4 - a_4 = 28 - 2 = 26$。$S_4 = c_4/s_4 = 26/9$。\n- $J_5$：$c_5 = f_5 - a_5 = 6 - 3 = 3$。$S_5 = c_5/s_5 = 3/2$。\n- $J_6$：$c_6 = f_6 - a_6 = 11 - 6 = 5$。$S_6 = c_6/s_6 = 5/5 = 1$。\n\nSJF 的算术平均减速比为：\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\sum_{i=1}^{6} S_i = \\frac{1}{6} \\left(\\frac{19}{8} + \\frac{4}{3} + 1 + \\frac{26}{9} + \\frac{3}{2} + 1\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(2 + \\frac{19}{8} + \\frac{4}{3} + \\frac{26}{9} + \\frac{3}{2}\\right) $$\n为了对分数求和，我们找到公分母 $72$：\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{2 \\cdot 72}{72} + \\frac{19 \\cdot 9}{72} + \\frac{4 \\cdot 24}{72} + \\frac{26 \\cdot 8}{72} + \\frac{3 \\cdot 36}{72}\\right) $$\n$$ \\overline{S}_{\\mathrm{SJF}} = \\frac{1}{6} \\left(\\frac{144 + 171 + 96 + 208 + 108}{72}\\right) = \\frac{1}{6} \\left(\\frac{727}{72}\\right) = \\frac{727}{432} $$\n\n**第三部分：计算比率 R**\n\n最后一步是计算比率 $R \\equiv \\frac{\\overline{S}_{\\mathrm{FCFS}}}{\\overline{S}_{\\mathrm{SJF}}}$。\n$$ R = \\frac{1493/270}{727/432} = \\frac{1493}{270} \\times \\frac{432}{727} $$\n我们可以化简分数 $\\frac{432}{270}$：\n$$ \\frac{432}{270} = \\frac{432 \\div 54}{270 \\div 54} = \\frac{8}{5} $$\n因此比率变为：\n$$ R = \\frac{1493}{727} \\times \\frac{8}{5} = \\frac{11944}{3635} $$\n现在，我们计算其数值并四舍五入到四位有效数字：\n$$ R \\approx 3.285832187... $$\n四舍五入到四位有效数字得到 $3.286$。", "answer": "$$\\boxed{3.286}$$", "id": "3630106"}, {"introduction": "在基础调度的基础上，我们现在引入一个关键的现实世界因素：开销。本练习将探讨“轮转”（RR）算法——分时系统的基石，并要求您对上下文切换时间对整体系统吞吐量的影响进行建模。通过推导吞吐量下降因子 $D(q,d)$，您将对选择时间片大小时所涉及的权衡有一个定量的理解 [@problem_id:3630101]。", "problem": "考虑一个单核中央处理器（CPU）在轮转（Round Robin, RR）调度下执行大量相同的、纯粹受CPU限制的作业流。每个作业需要总共 $C$ 个单位的CPU服务才能完成，其中 $C \\gg q$，$q$ 是 RR 的时间片（quantum）。在每次抢占和调度时，调度程序会产生平均为 $d$ 个单位CPU时间的上下文切换开销，在此期间不执行任何有用的作业计算。假设总是至少有 $2$ 个就绪作业，以致于每个时间片用尽时都会发生上下文切换，CPU从不空闲，并且在长期平均中，作业开始和完成时的边界效应可以忽略不计。\n\n令 $X(q,d)$ 表示长期吞吐率，定义为单位时间内完成的作业数量的极限；令 $X_{\\text{ideal}}$ 表示在没有上下文切换开销和抢占开销的情况下，同一CPU上的理想吞吐率，并定义吞吐率退化因子为 $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。\n\n仅从吞吐率的定义以及在 RR 调度和分派下有用功与开销的时间核算出发，推导 $D(q,d)$，然后在 $q=d$ 时对其求值。请给出当 $q=d$ 时 $D(q,d)$ 的单个精确值作为最终答案。不需要四舍五入，最终答案中不应包含单位。将最终值表示为一个简化的精确分数。", "solution": "首先验证问题陈述的科学合理性、自洽性和清晰度。\n\n**步骤1：提取已知条件**\n- 调度算法：轮转（Round Robin, RR）。\n- CPU：单核。\n- 作业特性：相同的、纯粹受CPU限制的。\n- 每个作业所需的总CPU服务时间：$C$。\n- 时间片（quantum）：$q$。\n- 服务时间与时间片的关系：$C \\gg q$。\n- 每次抢占的上下文切换开销：$d$。\n- 系统状态：总是至少有2个就绪作业，确保CPU从不空闲，且每个时间片结束时都发生上下文切换。\n- 简化假设：在长期平均中，作业开始和完成时的边界效应可以忽略不计。\n- 长期吞吐率的定义：$X(q,d)$ 是单位时间内完成作业数的极限。\n- 理想吞吐率的定义：$X_{\\text{ideal}}$ 是在 $d=0$（无上下文切换开销）时，同一CPU上的吞吐率。\n- 吞吐率退化因子的定义：$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。\n- 任务：推导 $D(q,d)$ 并在 $q=d$ 的情况下对其求值。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题具有科学依据，植根于操作系统CPU调度的基本原理。它提出了一个用于分析轮转算法性能的标准简化模型。所使用的术语（$C$, $q$, $d$, 吞吐率）在计算机科学中都有明确的定义。所提供的假设（例如，$C \\gg q$，总有就绪作业）对于创建一个易于处理的稳态行为分析模型是必要的，它消除了瞬态和空闲时间的复杂性。该问题提法恰当、客观、自成一体，没有内部矛盾或信息缺失。这是一个有效的可供分析的问题。\n\n**步骤3：结论与行动**\n该问题有效。将提供完整的解答。\n\n**解答的推导**\n\n目标是求出吞吐率退化因子 $D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$。我们首先推导理想吞吐率 $X_{\\text{ideal}}$ 和实际吞吐率 $X(q,d)$ 的表达式。吞吐率定义为单位时间内完成的作业数量。\n\n**1. 理想吞吐率 ($X_{\\text{ideal}}$)**\n\n在理想情况下，没有上下文切换的开销，因此 $d=0$。CPU将其 $100\\%$ 的时间用于为作业执行有用的计算。每个作业需要总共 $C$ 个单位的CPU服务时间。因此，完成一个作业所需的时间就是 $C$。\n\n理想吞吐率 $X_{\\text{ideal}}$ 是完成一个作业所需时间的倒数：\n$$X_{\\text{ideal}} = \\frac{1 \\text{ job}}{C \\text{ time units}} = \\frac{1}{C}$$\n\n**2. 实际吞吐率 ($X(q,d)$)**\n\n在带有上下文切换开销的轮转调度下，CPU的时间被分配给有用功和开销。问题陈述中说明了每个时间片后都会发生一次上下文切换。\n\n一个操作周期包括：\n- 一个持续时间为 $q$ 的有用计算时间片。\n- 一次持续时间为 $d$ 的上下文切换。\n\n这样一个周期的总持续时间是 $T_{\\text{cycle}} = q + d$。\n\n在这个总时间为 $q+d$ 的周期中，只有 $q$ 的时间用于执行有用功。CPU用于有用计算的时间占总时间的比例即为其效率 $\\eta$：\n$$\\eta = \\frac{\\text{Useful time}}{\\text{Total time}} = \\frac{q}{q+d}$$\n\n要完成一个作业，必须提供总共 $C$ 个单位的有用CPU服务。由于CPU在有效工作时间上只占总时间的比例 $\\eta$，提供 $C$ 个单位服务所需的总（挂钟）时间为：\n$$T_{\\text{job}} = \\frac{C}{\\eta} = \\frac{C}{\\frac{q}{q+d}} = C \\frac{q+d}{q}$$\n\n实际的长期吞吐率 $X(q,d)$ 是每个作业总时间的倒数：\n$$X(q,d) = \\frac{1}{T_{\\text{job}}} = \\frac{1}{C \\frac{q+d}{q}} = \\frac{q}{C(q+d)}$$\n\n**3. 吞吐率退化因子 ($D(q,d)$)**\n\n现在我们可以用其定义来计算退化因子：\n$$D(q,d) = \\frac{X(q,d)}{X_{\\text{ideal}}}$$\n代入 $X(q,d)$ 和 $X_{\\text{ideal}}$ 的表达式：\n$$D(q,d) = \\frac{\\frac{q}{C(q+d)}}{\\frac{1}{C}}$$\n$$D(q,d) = \\frac{q}{C(q+d)} \\cdot \\frac{C}{1} = \\frac{q}{q+d}$$\n这个结果是直观的：吞吐率的退化因子等于CPU用于做有用功的时间所占的比例。\n\n**4. 对 $q=d$ 的情况求值**\n\n问题要求计算当时间片 $q$ 等于上下文切换开销 $d$ 时 $D(q,d)$ 的值。我们将 $d=q$ 代入 $D(q,d)$ 的表达式中：\n$$D(q,q) = \\frac{q}{q+q} = \\frac{q}{2q}$$\n由于 $q$ 是一个时间片，它必须是一个正的持续时间（$q > 0$）。因此，我们可以消去分子和分母中的 $q$：\n$$D(q,q) = \\frac{1}{2}$$\n\n因此，当上下文切换开销等于时间片持续时间时，CPU一半时间用于有用功，一半时间用于开销，导致吞吐率恰好是理想吞吐率的一半。", "answer": "$$\\boxed{\\frac{1}{2}}$$", "id": "3630101"}, {"introduction": "现实世界的调度器通常使用动态优先级来平衡响应性和公平性。这项练习让您扮演系统设计师的角色，负责配置一个使用“老化”机制来防止饥饿的基于优先级的调度器。您将通过将高级设计目标——防止饥饿和保持有意义的优先级差异——转化为精确的数学约束，来推导老化速率 $\\alpha$ 的可接受范围 [@problem_id:3630147]。", "problem": "一个单处理器操作系统对中央处理器（CPU）采用基于优先级的抢占式调度。每个就绪（非运行）任务都有一个动态优先级，该优先级从其基础优先级开始，并通过老化过程在每个调度器时钟周期内增加一个固定的增量。具体来说，在每个调度器时钟周期，就绪队列中的每个任务的动态优先级都会增加 $\\alpha$（单位：优先级点数/时钟周期），其上限为最大优先级 $P_{\\max}$。调度器总是分派具有最高动态优先级的就绪任务；优先级相同时，按先进先出（FIFO）原则处理。假设抢占和分派决策只能在时钟周期的边界发生。老化仅适用于等待中的任务；正在执行的运行中任务不会老化。\n\n为了在最坏负载情况下防止饥饿，系统设计者规定，任何基础优先级为 $p_{L}$ 的任务必须在最多 $W_{\\max}$ 个时钟周期内获得 CPU 时间，即使基础优先级为 $p_{H}$ 的任务流持续不断地到达。在此要求下，只需确保低优先级任务的动态优先级能在等待 $W_{\\max}$ 个时钟周期内达到至少 $p_{H}$ 即可。\n\n为了保持调度器的稳定性，设计者还规定，优先级不能过快地趋同。具体而言，他们要求一个从低基础优先级 $p_{\\min}$ 开始的任务，其等待时间不得少于 $T_{\\text{flat}}$ 个时钟周期就达到最大优先级 $P_{\\max}$。这个约束避免了优先级同质化过快，从而导致调度器失去对任务有意义的区分。\n\n给定以下参数：\n- 最大优先级 $P_{\\max} = 100$，\n- 高基础优先级 $p_{H} = 80$，\n- 用于饥饿约束的低基础优先级 $p_{L} = 25$，\n- 饥饿界限 $W_{\\max} = 550$ 个时钟周期，\n- 用于趋同约束的低基础优先级 $p_{\\min} = 10$，\n- 最小扁平化时间 $T_{\\text{flat}} = 450$ 个时钟周期，\n\n请根据优先级老化和调度的基本原理，推导老化速率 $\\alpha$ 的允许范围，该范围需同时满足防止饥饿和避免优先级过快趋同的条件。将你的最终答案表示为代表 $\\alpha$ 下限和上限的两个数字（单位：优先级点数/时钟周期）。无需四舍五入；请提供精确值。最终答案必须是计算结果。", "solution": "本问题要求基于两个不同的约束条件推导优先级老化速率 $\\alpha$ 的允许范围：一个是为了防止任务饥饿，另一个是为了防止优先级体系的快速趋同。我们将分别分析每个约束条件，以确定 $\\alpha$ 的下限和上限。\n\n其基本原理是，一个基础优先级为 $p_{base}$ 的就绪任务，其动态优先级 $p_{dyn}(t)$ 会随着它在就绪队列中等待的时间 $t$ 线性增加。老化速率 $\\alpha$ 是比例常数。这个关系可以表示为：\n$$p_{dyn}(t) = p_{base} + \\alpha t$$\n这个增长的上限是最大优先级 $P_{\\max}$。在我们的分析中，我们将首先考虑无上限的线性增长，以找出达到特定优先级阈值所需的时间，然后确保逻辑与上限一致。\n\n第一个约束条件旨在防止饥饿。它规定任何基础优先级为 $p_L$ 的任务必须在最大等待时间 $W_{\\max}$ 个时钟周期内获得 CPU 时间。问题指出，满足此要求的一个充分条件是，确保该任务的动态优先级在 $W_{\\max}$ 的时间窗口内至少达到高基础优先级水平 $p_H$。这确保了低优先级任务最终将具有比任何新到达的高优先级任务更高的优先级，从而被调度。\n\n让我们将这个条件形式化。低优先级任务等待时间 $t$ 后的动态优先级为 $p_L + \\alpha t$。为保证它能在 $W_{\\max}$ 个时钟周期内被调度，其在时间 $t = W_{\\max}$ 时的优先级必须至少为 $p_H$。这给了我们以下不等式：\n$$p_L + \\alpha W_{\\max} \\ge p_H$$\n对于防止饥饿所需的最小可接受 $\\alpha$ 值，此不等式必须成立。我们可以解这个关于 $\\alpha$ 的不等式：\n$$\\alpha W_{\\max} \\ge p_H - p_L$$\n$$\\alpha \\ge \\frac{p_H - p_L}{W_{\\max}}$$\n这个不等式确立了老化速率的下限 $\\alpha_{min}$。代入给定的参数值：\n- 用于比较的高基础优先级，$p_H = 80$。\n- 用于饥饿约束的低基础优先级，$p_L = 25$。\n- 最大允许等待时间，$W_{\\max} = 550$ 个时钟周期。\n\n我们计算 $\\alpha$ 的最小值：\n$$\\alpha_{min} = \\frac{80 - 25}{550} = \\frac{55}{550} = \\frac{1}{10}$$\n因此，为防止饥饿，老化速率 $\\alpha$ 必须至少为 $\\frac{1}{10}$ 优先级点数/时钟周期。\n\n第二个约束条件旨在通过防止优先级过快趋同来保持优先级系统中有意义的区分度。它要求一个从极低基础优先级 $p_{min}$ 开始的任务，其达到系统最大优先级 $P_{max}$ 所需的时间不得少于 $T_{flat}$ 个时钟周期。\n\n设 $T_{climb}$ 为基础优先级为 $p_{min}$ 的任务达到 $P_{max}$ 所需的时间。我们可以通过将其动态优先级设为等于 $P_{max}$ 来求得这个时间：\n$$p_{min} + \\alpha T_{climb} = P_{max}$$\n求解 $T_{climb}$：\n$$T_{climb} = \\frac{P_{max} - p_{min}}{\\alpha}$$\n约束条件规定，这个时间必须大于或等于 $T_{flat}$：\n$$T_{climb} \\ge T_{flat}$$\n代入我们关于 $T_{climb}$ 的表达式：\n$$\\frac{P_{max} - p_{min}}{\\alpha} \\ge T_{flat}$$\n这个不等式将确立 $\\alpha$ 的上限。由于 $\\alpha$ 是一个增长率，它本身是正数（$\\alpha > 0$）。我们可以安全地重排不等式来求解 $\\alpha$：\n$$P_{max} - p_{min} \\ge \\alpha T_{flat}$$\n$$\\alpha \\le \\frac{P_{max} - p_{min}}{T_{flat}}$$\n这个不等式确立了老化速率的上限 $\\alpha_{max}$。代入给定的参数值：\n- 最大优先级，$P_{max} = 100$。\n- 用于趋同约束的低基础优先级，$p_{min} = 10$。\n- 最小扁平化时间，$T_{flat} = 450$ 个时钟周期。\n\n我们计算 $\\alpha$ 的最大值：\n$$\\alpha_{max} = \\frac{100 - 10}{450} = \\frac{90}{450} = \\frac{9}{45} = \\frac{1}{5}$$\n因此，为避免优先级快速趋同，老化速率 $\\alpha$ 不得超过 $\\frac{1}{5}$ 优先级点数/时钟周期。\n\n结合两个约束条件，我们得到 $\\alpha$ 的允许范围：\n$$\\alpha_{min} \\le \\alpha \\le \\alpha_{max}$$\n$$\\frac{1}{10} \\le \\alpha \\le \\frac{1}{5}$$\n$\\alpha$ 的下限是 $\\frac{1}{10}$，上限是 $\\frac{1}{5}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{1}{10}  \\frac{1}{5} \\end{pmatrix}}$$", "id": "3630147"}]}