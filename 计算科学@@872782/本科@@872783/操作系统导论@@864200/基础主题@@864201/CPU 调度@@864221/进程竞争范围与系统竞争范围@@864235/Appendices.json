{"hands_on_practices": [{"introduction": "理解进程竞争范围（PCS）和系统竞争范围（SCS）之间的权衡，首先要从早期“多对一”线程模型的一个最关键挑战入手。在这种模型下，一个用户线程的阻塞性系统调用可能会暂停整个用户线程组的执行。这个练习 [@problem_id:3672449] 让你运用基本的概率论原理，来计算这种阻塞行为导致的预期性能开销，从而为一个经典的 PCS 弱点提供具体的量化衡量。", "problem": "考虑一个多线程进程，其用户级运行时使用进程竞争范围 (PCS) 将多个用户线程多路复用到一个单一的轻量级进程 (LWP，一个内核可调度实体) 上。在 PCS 中，如果一个用户线程发出一个阻塞的系统调用，LWP 会被内核置于休眠状态，并且同一进程中的其他用户线程都无法取得进展，直到内核解除 LWP 的阻塞。相比之下，在具有多个内核线程的系统竞争范围 (SCS) 下，一个线程的阻塞不一定会导致其他线程停滞；然而，在本场景中，该进程被限制为使用 PCS 和一个确切的 LWP。\n\n假设运行时就绪状态预测失误，调度了一个用户线程，该线程立即尝试进行一个阻塞结果不可预测的系统调用。设系统调用阻塞的概率为 $p_b$，并假设试验是独立的，且不存在其他延迟来源。如果发生阻塞，LWP 将休眠 $t_b$ 毫秒，在此期间所有其他可运行的用户线程都将等待。如果不发生阻塞，系统调用会足够快地完成，在下一个可运行的用户线程被调度之前的唯一延迟是 $t_c$ 毫秒的协作式切换和调度器开销。\n\n给定 $p_b = 0.32$，$t_b = 50$ 毫秒，以及 $t_c = 3$ 毫秒，请使用概率论的第一性原理和期望值的定义，推导因这次 PCS 错误预测而导致其他可运行用户线程所经历的期望等待时间 $E[W]$（单位为毫秒）。请用毫秒表示最终答案，并四舍五入至四位有效数字。", "solution": "用户要求推导在一个受限于进程竞争范围 (PCS) 和单一轻量级进程 (LWP) 的多线程进程中，可运行用户线程的期望等待时间。必须首先验证该问题的科学合理性、完整性和客观性。\n\n### 步骤 1：提取已知条件\n逐字提取所提供的数据和条件：\n- 系统使用进程竞争范围 (PCS) 和单一 LWP。\n- 一个用户线程尝试进行一个具有不可预测阻塞结果的系统调用。\n- 系统调用阻塞的概率为 $p_b$。\n- 如果调用阻塞，LWP 将休眠 $t_b$ 的时长。\n- 如果调用不阻塞，延迟是调度器开销 $t_c$。\n- 试验是独立的，并且没有其他延迟来源。\n- $p_b = 0.32$\n- $t_b = 50$ 毫秒\n- $t_c = 3$ 毫秒\n- 目标是求出期望等待时间 $E[W]$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估：\n- **科学依据**：问题陈述准确地描述了多对一线程模型（多个用户线程映射到一个内核线程/LWP）的行为，这是进程竞争范围的本质。一个用户线程的阻塞性系统调用导致复用在该 LWP 上的整个用户线程集停滞的场景，是该模型的一个决定性特征。使用期望值来分析系统性能是计算机科学和工程中的一种标准且有效的方法。该问题在根本上是合理的。\n- **适定性**：该问题是适定的。它定义了一个离散随机变量，即等待时间 $W$，该变量可以取两个特定值之一。每个值的概率已经提供，或者可以从已知条件（$p_b$ 和 $1-p_b$）中直接推断出来。计算期望值所需的所有参数（$t_b$，$t_c$，$p_b$）都已明确说明。目标清晰，且存在唯一解。\n- **客观性**：问题以精确、客观的语言陈述。它描述了一个技术场景，没有任何主观、模糊或基于观点的主张。\n\n该问题不违反任何无效性标准。它具有科学合理性、适定性、完整说明性和客观性。因此，该问题被认定为**有效**。\n\n### 步骤 3：进行求解\n其他可运行用户线程所经历的等待时间，用随机变量 $W$ 表示，取决于系统调用的结果。存在两种互斥的结果：调用阻塞，或不阻塞。\n\n设 $p_b$ 为系统调用阻塞的概率。\n系统调用不阻塞的概率是其互补事件的概率，即 $1 - p_b$。\n\n等待时间 $W$ 的值由发生哪种结果决定：\n1.  如果系统调用阻塞，等待时间为 $t_b$。此情况发生的概率为 $p_b$。\n2.  如果系统调用不阻塞，等待时间为 $t_c$。此情况发生的概率为 $1 - p_b$。\n\n离散随机变量的期望值定义为该变量每个可能值与其对应概率的乘积之和。对于随机变量 $W$，其期望值 $E[W]$ 由下式给出：\n$$E[W] = (W \\text{ 在阻塞情况下的值}) \\times P(\\text{阻塞}) + (W \\text{ 在非阻塞情况下的值}) \\times P(\\text{非阻塞})$$\n\n代入问题陈述中的符号变量：\n$$E[W] = t_b \\cdot p_b + t_c \\cdot (1 - p_b)$$\n\n现在，我们代入问题陈述中提供的数值：\n- $p_b = 0.32$\n- $t_b = 50$ ms\n- $t_c = 3$ ms\n\n不阻塞的概率为 $1 - p_b = 1 - 0.32 = 0.68$。\n\n将这些值代入期望等待时间的公式中：\n$$E[W] = (50) \\cdot (0.32) + (3) \\cdot (0.68)$$\n\n我们计算和的两个部分：\n$$50 \\cdot 0.32 = 16.0$$\n$$3 \\cdot 0.68 = 2.04$$\n\n将这两个部分相加得到最终的期望值：\n$$E[W] = 16.0 + 2.04 = 18.04$$\n\n问题要求最终答案以毫秒表示，并四舍五入到四位有效数字。计算出的值为 $18.04$ 毫秒，该值已经有四位有效数字（$1$、$8$、$0$、$4$）。因此，无需进一步四舍五入。", "answer": "$$\\boxed{18.04}$$", "id": "3672449"}, {"introduction": "除了阻塞调用的问题，线程调度的效率在很大程度上也受到上下文切换开销的影响。PCS 中的用户级调度器和 SCS 中的内核级调度器在切换线程时都会产生开销，但这些开销通常是不同的。这项练习 [@problem_id:3672426] 将指导你从第一性原理出发，构建一个量化模型来分析超载系统中的性能下降，直接比较 PCS 和 SCS 如何受到调度开销的影响。", "problem": "给定一个模型，用于推断在超额订阅（oversubscription）情况下，进程竞争范围（Process-Contention Scope, PCS）和系统竞争范围（System-Contention Scope, SCS）调度如何影响执行时间。请从第一性原理出发，使用以下基本定义和事实，推导出一个定量的减速（slowdown）模型，并在一个程序中实现它。\n\n基本定义和事实：\n- 进程竞争范围（PCS）：由用户级库在单个进程内对用户级线程进行调度。在这种模式下，内核只调度一小部分内核可见的执行实体（例如，每个中央处理器（CPU）一个）。用户级库在其用户线程之间执行上下文切换。\n- 系统竞争范围（SCS）：由操作系统内核在系统上所有进程的内核可见线程之间执行调度，并通过内核感知的负载均衡将可运行的线程分配到各个CPU。\n- 轮询时间共享（Round-robin time sharing）：每个可运行线程在被抢占前，会在一个CPU上获得一个长度为 $q$ 的时间量。每次上下文切换会产生固定的开销 $s$，在此期间不执行任何有效工作。对于PCS，开销记为 $s_{\\mathrm{PCS}}$；对于SCS，开销记为 $s_{\\mathrm{SCS}}$。\n- 相同的工作负载：$N$ 个相同的线程，每个都需要 $W$ 单位的纯计算时间。假设CPU的归一化速度为每个CPU每秒1个工作单位，因此 $W$ 以理想计算时间的秒为单位来衡量。\n- CPU时间的公平共享和守恒：在轮询调度、线程相同且负载均衡完美的条件下，每个CPU会将其可用的有效时间平均分配给分配给它的可运行线程。每个CPU的总有效率会因上下文切换开销所占时间的比例而降低。当有可运行线程时，空闲时间为零。\n\n设置：\n- 设CPU数量为 $C$，线程数量为 $N = 2C$ 以制造超额订阅情况。假设在SCS下，内核感知的负载均衡使每个CPU上的可运行线程数保持相等。\n- 对于PCS，假设 $C$ 个内核可见的执行实体被固定到 $C$ 个CPU上，用户级库使用时间量为 $q$、每次用户级上下文切换开销为 $s_{\\mathrm{PCS}}$ 的轮询方式，将 $N$ 个用户线程复用到这 $C$ 个实体上。\n- 对于SCS，假设内核使用时间量为 $q$、每次内核级上下文切换开销为 $s_{\\mathrm{SCS}}$ 的轮询方式，将 $N$ 个内核可见线程复用到 $C$ 个CPU上，并通过内核感知的负载均衡消除了额外的迁移惩罚。\n\n任务：\n1. 仅从上述基本定义和事实出发，逻辑推导在 $N=2C$ 的情况下，单个线程在PCS下的完成时间 $T_{\\mathrm{PCS}}$ 和在SCS下的完成时间 $T_{\\mathrm{SCS}}$，用 $W$, $q$, $s_{\\mathrm{PCS}}$, $s_{\\mathrm{SCS}}$, $N$ 和 $C$ 表示。将减速定义为 $\\delta = T/T_{\\mathrm{ideal}}$，其中 $T_{\\mathrm{ideal}}$ 是在 $N=C$ 且没有时间分片开销时单个线程的完成时间。请将 $\\delta_{\\mathrm{PCS}}$ 和 $\\delta_{\\mathrm{SCS}}$ 表示为无量纲比率。\n2. 实现一个完整的、可运行的程序，为以下测试套件计算 $\\delta_{\\mathrm{PCS}}$ 和 $\\delta_{\\mathrm{SCS}}$。将所有时间 $q$、$s_{\\mathrm{PCS}}$ 和 $s_{\\mathrm{SCS}}$ 视为以秒为单位，将 $W$ 视为以理想计算时间的秒为单位。你的程序不能使用任何随机性或操作系统并发性；它必须是纯计算的。\n3. 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，数值按 $[\\delta_{\\mathrm{PCS}}^{(1)},\\delta_{\\mathrm{SCS}}^{(1)},\\delta_{\\mathrm{PCS}}^{(2)},\\delta_{\\mathrm{SCS}}^{(2)},\\dots]$ 的顺序排列，并四舍五入到六位小数。\n\n测试套件（每种情况下均为 $N=2C$）：\n- 案例1（理想情况）：$C=4$, $N=8$, $W=1.0$, $q=0.010$, $s_{\\mathrm{PCS}}=0.0005$, $s_{\\mathrm{SCS}}=0.0010$。\n- 案例2（零开销边界）：$C=4$, $N=8$, $W=2.5$, $q=0.010$, $s_{\\mathrm{PCS}}=0.0000$, $s_{\\mathrm{SCS}}=0.0000$。\n- 案例3（小时间量，显著开销）：$C=2$, $N=4$, $W=1.0$, $q=0.0010$, $s_{\\mathrm{PCS}}=0.0005$, $s_{\\mathrm{SCS}}=0.0005$。\n- 案例4（单CPU边界）：$C=1$, $N=2$, $W=3.0$, $q=0.0200$, $s_{\\mathrm{PCS}}=0.0008$, $s_{\\mathrm{SCS}}=0.0010$。\n- 案例5（较大型系统，轻度开销不平衡）：$C=8$, $N=16$, $W=0.5$, $q=0.0050$, $s_{\\mathrm{PCS}}=0.0002$, $s_{\\mathrm{SCS}}=0.0006$。\n\n答案格式：\n- 精确输出一行，格式为 $[\\text{float},\\text{float},\\dots]$，不含空格，每个浮点数按要求四舍五入到六位小数。", "solution": "任务是针对一个特定的超额订阅场景，推导出一个定量模型，用以描述由进程竞争范围（PCS）和系统竞争范围（SCS）调度所引入的性能减速。推导过程必须从所提供的第一性原理出发。\n\n首先，我们建立用于比较的基线，即理想完成时间 $T_{\\mathrm{ideal}}$。它被定义为当线程数 $N$ 等于CPU数 $C$ 且没有时间分片开销时，单个线程完成其工作所需的时间。在这种情况下，$C$ 个线程中的每一个都被分配到 $C$ 个CPU中的一个，并运行至完成而不会被中断。鉴于每个线程需要 $W$ 秒的纯计算时间，且CPU的归一化速度为每秒1个工作单位，理想完成时间就是：\n$$ T_{\\mathrm{ideal}} = W $$\n\n接下来，我们分析在带有开销的轮询调度下CPU的性能。考虑单个CPU调度 $k$ 个线程。一个完整的调度周期包括为 $k$ 个线程中的每一个分配一个时间量 $q$，每次CPU的分配之后都伴随着一个持续时间为 $s$ 的上下文切换。一个完整周期的总时间是所有时间量和所有上下文切换时间的总和：\n$$ T_{\\mathrm{cycle}} = k \\cdot q + k \\cdot s = k(q+s) $$\n在此周期内完成的有效工作是执行线程代码所花费的时间总和：\n$$ W_{\\mathrm{cycle}} = k \\cdot q $$\nCPU的有效服务率 $\\eta$ 是其用于有效工作的时间所占的比例。这是有效时间与总周期时间之比：\n$$ \\eta = \\frac{W_{\\mathrm{cycle}}}{T_{\\mathrm{cycle}}} = \\frac{k \\cdot q}{k(q+s)} = \\frac{q}{q+s} $$\n这个有效比例 $\\eta$ 代表了CPU总时间中转化为有效计算的部分。请注意，只要 $k \\ge 1$，这个比率与被调度的线程数 $k$ 无关。\n\n现在，我们将此模型应用于给定的 $C$ 个CPU上运行 $N=2C$ 个线程的设置，分析两种调度范围。\n\n对于系统竞争范围（SCS），操作系统内核在 $C$ 个CPU上调度全部 $N=2C$ 个线程。问题描述指出，内核感知的负载均衡会均匀分配这些线程。因此， $C$ 个CPU中的每一个都需要管理 $k = N/C = 2C/C = 2$ 个线程。这些是内核可见线程，因此每次上下文切换都会产生内核级开销 $s_{\\mathrm{SCS}}$。因此，每个CPU的有效服务率为：\n$$ \\eta_{\\mathrm{SCS}} = \\frac{q}{q + s_{\\mathrm{SCS}}} $$\n根据公平共享策略，这个有效率在CPU上的2个线程之间平均共享。单个线程能够完成其工作的速率是CPU有效率的一半：\n$$ \\text{Rate}_{\\text{per thread, SCS}} = \\frac{1}{2} \\eta_{\\mathrm{SCS}} = \\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{SCS}}} \\right) $$\n单个线程完成其工作负载 $W$ 所需的总时间 $T_{\\mathrm{SCS}}$ 是工作量除以其被服务的速率：\n$$ T_{\\mathrm{SCS}} = \\frac{W}{\\text{Rate}_{\\text{per thread, SCS}}} = \\frac{W}{\\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{SCS}}} \\right)} = \\frac{2W(q + s_{\\mathrm{SCS}})}{q} $$\n\n对于进程竞争范围（PCS），其设置涉及 $C$ 个内核可见实体被固定到 $C$ 个CPU上。操作系统每个CPU只看到一个实体，因此在内核层面不执行时间分片。用户级库负责在这 $C$ 个内核实体上调度 $N=2C$ 个用户线程。假设库将它们均匀分配，则每个内核实体（并延伸至每个CPU）负责调度 $k = N/C = 2$ 个用户线程。这种用户级调度使用时间量 $q$，上下文切换开销为 $s_{\\mathrm{PCS}}$。其逻辑结构与SCS情况相同，但开销参数不同。\n由用户级调度器调节的CPU有效服务率为：\n$$ \\eta_{\\mathrm{PCS}} = \\frac{q}{q + s_{\\mathrm{PCS}}} $$\n这个速率在分配给该内核实体的2个用户线程之间共享。每个线程的速率是：\n$$ \\text{Rate}_{\\text{per thread, PCS}} = \\frac{1}{2} \\eta_{\\mathrm{PCS}} = \\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{PCS}}} \\right) $$\n一个线程完成其工作负载 $W$ 所需的总时间 $T_{\\mathrm{PCS}}$ 是：\n$$ T_{\\mathrm{PCS}} = \\frac{W}{\\text{Rate}_{\\text{per thread, PCS}}} = \\frac{W}{\\frac{1}{2} \\left( \\frac{q}{q + s_{\\mathrm{PCS}}} \\right)} = \\frac{2W(q + s_{\\mathrm{PCS}})}{q} $$\n\n最后，我们计算减速 $\\delta$，它被定义为实际完成时间 $T$ 与理想时间 $T_{\\mathrm{ideal}}$ 的比率。\n对于PCS，减速 $\\delta_{\\mathrm{PCS}}$ 是：\n$$ \\delta_{\\mathrm{PCS}} = \\frac{T_{\\mathrm{PCS}}}{T_{\\mathrm{ideal}}} = \\frac{ \\frac{2W(q + s_{\\mathrm{PCS}})}{q} }{W} = \\frac{2(q + s_{\\mathrm{PCS}})}{q} = 2 \\left(1 + \\frac{s_{\\mathrm{PCS}}}{q}\\right) $$\n对于SCS，减速 $\\delta_{\\mathrm{SCS}}$ 是：\n$$ \\delta_{\\mathrm{SCS}} = \\frac{T_{\\mathrm{SCS}}}{T_{\\mathrm{ideal}}} = \\frac{ \\frac{2W(q + s_{\\mathrm{SCS}})}{q} }{W} = \\frac{2(q + s_{\\mathrm{SCS}})}{q} = 2 \\left(1 + \\frac{s_{\\mathrm{SCS}}}{q}\\right) $$\n这些表达式是所要求的无量纲比率。因子2源于竞争（超额订阅因子 $N/C=2$），而项 $(1 + s/q)$ 代表了相对于时间量而言，由上下文切换开销带来的惩罚。", "answer": "[2.100000,2.200000,2.000000,2.000000,3.000000,3.000000,2.080000,2.100000,2.080000,2.240000]", "id": "3672426"}, {"introduction": "理论模型为我们提供了深刻的见解，但诊断真实世界系统中的性能问题需要实际的测量技术。在复杂的应用程序中，性能瓶颈可能源于应用程序自身运行时（PCS）内部的竞争，也可能源于对全系统资源（SCS）的争夺。这个问题 [@problem_id:3672486] 模拟了一个现代性能分析场景，你将利用假设的追踪数据对不同来源的延迟进行分类和量化，最终确定归因于各个竞争范围的竞争比例。", "problem": "考虑一个用户空间运行时，它将许多用户级线程多路复用到较少数量的内核级线程上，这在进程竞争范围 (Process-Contention Scope, PCS) 和系统竞争范围 (System-Contention Scope, SCS) 之间造成了潜在的分离。进程竞争范围指的是完全在单个进程的用户空间运行时内部管理和体现的竞争（例如，用户级锁、自旋和协作式让步），而系统竞争范围指的是对操作系统内核调度器可见并由其管理的竞争（例如，一个可运行的线程在内核运行队列中等待，或在内核管理的等待中阻塞）。\n\n要求您使用扩展伯克利包过滤器 (Extended Berkeley Packet Filter, eBPF) 设计一种跟踪方法，以区分 PCS 和 SCS 的竞争，并提出量化每个范围的计数器。eBPF 用户空间探针 (uprobes) 可以附加到用户空间函数上以捕获用户级事件，而 eBPF 内核探针 (kprobes) 或内核跟踪点 (tracepoints) 可以附加到内核函数上以捕获内核级事件。\n\n将计数器 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 定义为在持续时间为 $T$ 的测量窗口内，目标进程所有线程的聚合竞争时间度量，其中 $C_{\\text{user}}$ 捕获用户空间竞争时间，而 $C_{\\text{kernel}}$ 捕获内核可见的竞争时间。假设在该窗口期间，收集并分类了以下被检测的事件类别：\n\n- 用户空间在用户级同步上自旋：所有线程的总聚合时间 $D_{\\text{spin}} = 6.4$ 秒。\n- 在用户级互斥锁上发生用户空间阻塞（完全在用户空间管理，不调用内核等待）：总聚合时间 $D_{\\text{umutex}} = 3.6$ 秒。\n- 内核管理的等待（例如，futex 等待或内核可见的其他阻塞调用）：总聚合时间 $D_{\\text{futex}} = 2.2$ 秒。\n- 因内核运行队列竞争而处于可运行但未运行状态（例如，通过调度器跟踪点测量，显示线程已准备好运行但未被调度）：总聚合时间 $D_{\\text{rq}} = 1.1$ 秒。\n\n所有持续时间都是跨线程聚合的，因此可能超过测量的墙钟时长 $T$。您可以假设这些分类是相互排斥的，并共同覆盖了该进程所关注的竞争状态。\n\n从 PCS 和 SCS 的基本定义以及一个连贯的竞争时间核算模型出发，推导出以 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 表示的 PCS 贡献率 $\\rho$ 的估计量，然后根据给定测量值计算 $\\rho$。将最终比率表示为一个无量纲小数，并将您的答案四舍五入到四位有效数字。", "solution": "该问题要求我们为进程竞争范围 (PCS) 对多线程应用程序所经历的总竞争的贡献，制定一个量化度量。我们获得了 PCS 和系统竞争范围 (SCS) 的定义，以及一组通过 eBPF 收集的、针对不同类型竞争的聚合时间测量值。\n\n首先，我们必须根据所提供的概念描述和测量数据，来形式化定义聚合竞争时间计数器 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$。\n\n进程竞争范围 (PCS) 被定义为完全在进程的用户空间内管理的竞争。计数器 $C_{\\text{user}}$ 是在这些状态下花费的总时间。根据所提供的数据，有两个类别属于此定义：\n1. 用户空间在用户级同步上自旋 ($D_{\\text{spin}}$)。在这种状态下，一个线程在用户级循环中主动消耗 CPU 周期以等待资源。这对内核调度器是不可见的，内核调度器将该线程视为正在运行。这是 PCS 的一种形式。\n2. 在用户级互斥锁上发生用户空间阻塞 ($D_{\\text{umutex}}$)。问题指明这是“完全在用户空间管理，不调用内核等待”。这意味着用户空间运行时调度器会取消该用户级线程的调度，并可能在同一个内核线程上运行另一个用户级线程。内核不知道这次上下文切换。这也是 PCS 的一种形式。\n\n因此，总的用户空间聚合竞争时间 $C_{\\text{user}}$ 是这些事件持续时间的总和。\n$$C_{\\text{user}} = D_{\\text{spin}} + D_{\\text{umutex}}$$\n\n系统竞争范围 (SCS) 被定义为对操作系统内核调度器可见并由其管理的竞争。计数器 $C_{\\text{kernel}}$ 是在这些状态下花费的总时间。数据中的两个类别符合此描述：\n1. 内核管理的等待 ($D_{\\text{futex}}$)。这包括在阻塞系统调用中花费的时间，其中内核明确将线程置于睡眠状态（例如，等待 futex、I/O 或其他内核同步原语）。对资源的竞争由内核管理。这是 SCS 的一种形式。\n2. 可运行但未运行 ($D_{\\text{rq}}$)。这表示一个内核线程已准备好执行，但在内核的运行队列中等待可用的 CPU 核心。这是对 CPU 核心的竞争，CPU 核心是由内核调度器直接管理的资源。这是 SCS 的一种形式。\n\n因此，总的内核可见聚合竞争时间 $C_{\\text{kernel}}$ 是这些事件持续时间的总和。\n$$C_{\\text{kernel}} = D_{\\text{futex}} + D_{\\text{rq}}$$\n\n总竞争时间 $C_{\\text{total}}$ 是来自两个范围的竞争之和。鉴于事件类别相互排斥并共同覆盖了所关注的竞争状态的假设，我们可以写出：\n$$C_{\\text{total}} = C_{\\text{user}} + C_{\\text{kernel}}$$\n\n问题要求计算 PCS 贡献率，我们用 $\\rho$ 表示。此比率的逻辑定义是可归因于 PCS 的竞争时间占总竞争时间的比例。\n$$\\rho = \\frac{C_{\\text{user}}}{C_{\\text{total}}} = \\frac{C_{\\text{user}}}{C_{\\text{user}} + C_{\\text{kernel}}}$$\n代入 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$ 的表达式：\n$$\\rho = \\frac{D_{\\text{spin}} + D_{\\text{umutex}}}{ (D_{\\text{spin}} + D_{\\text{umutex}}) + (D_{\\text{futex}} + D_{\\text{rq}}) }$$\n\n现在，我们将给定的数值代入这些表达式：\n$D_{\\text{spin}} = 6.4$ s\n$D_{\\text{umutex}} = 3.6$ s\n$D_{\\text{futex}} = 2.2$ s\n$D_{\\text{rq}} = 1.1$ s\n\n首先，我们计算 $C_{\\text{user}}$ 和 $C_{\\text{kernel}}$：\n$$C_{\\text{user}} = 6.4 + 3.6 = 10.0 \\text{ s}$$\n$$C_{\\text{kernel}} = 2.2 + 1.1 = 3.3 \\text{ s}$$\n\n接下来，我们计算总竞争时间 $C_{\\text{total}}$：\n$$C_{\\text{total}} = C_{\\text{user}} + C_{\\text{kernel}} = 10.0 + 3.3 = 13.3 \\text{ s}$$\n\n最后，我们计算比率 $\\rho$：\n$$\\rho = \\frac{C_{\\text{user}}}{C_{\\text{total}}} = \\frac{10.0}{13.3}$$\n$$\\rho \\approx 0.751879699...$$\n\n问题要求答案四舍五入到四位有效数字。\n$$\\rho \\approx 0.7519$$\n这个无量纲比率表明，大约 $75.19\\%$ 的测量竞争发生在用户空间运行时 (PCS) 内，而其余部分是由于对内核管理的资源 (SCS) 的竞争造成的。", "answer": "$$\\boxed{0.7519}$$", "id": "3672486"}]}