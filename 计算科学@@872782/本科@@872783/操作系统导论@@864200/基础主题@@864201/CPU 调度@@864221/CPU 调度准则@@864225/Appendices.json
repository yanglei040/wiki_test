{"hands_on_practices": [{"introduction": "掌握CPU调度算法的第一步是能够精确计算其性能指标。这个练习将引导你为一个简单的先来先服务（FCFS）场景计算周转时间、响应时间等核心指标，并让你思考为什么即使是具有相同处理时间的作业，其用户体验也可能大相径庭。通过这个基础练习，你将为评估更复杂的调度策略打下坚实的基础。[@problem_id:3630364]", "problem": "考虑一个单核中央处理器（CPU），其调度方式为非抢占式先到先服务（FCFS）。上下文切换的开销可以忽略不计。有四个作业 $J_1, J_2, J_3, J_4$，每个作业都需要一个相同的 CPU 执行周期，时长为 $4$ 毫秒。它们的到达时间（单位：毫秒）分别为 $A_1 = 0$, $A_2 = 1$, $A_3 = 2$, $A_4 = 10$。仅使用响应时间、等待时间、周转时间、吞吐量和 CPU 利用率的基本定义（在从时间 $0$ 到最后一个作业完成的时间区间内），完成以下任务：\n\n- 构建 FCFS 执行时间线。\n- 对每个作业 $J_i$，确定其响应时间、等待时间和周转时间，然后计算这四个作业的这些指标的平均值。所有时间量均以毫秒表示。\n- 计算从时间 $0$ 到最后一个作业完成期间的吞吐量，以 作业/毫秒 表示。\n- 计算同一时间区间内的 CPU 利用率，以分数或小数表示（不要使用百分号）。\n- 根据计算出的时间，简要讨论在 FCFS 调度下，由于到达顺序不同，相同的 CPU 执行周期如何仍然会导致不同的响应时间。\n\n最后，通过计算四个作业响应时间的变异系数（定义为标准差除以所有作业的平均值）来量化响应时间的公平性。将此变异系数作为您的最终答案，以精确的符号形式报告（不要四舍五入）。最终报告的值不需要单位。", "solution": "该问题是有效的。这是一个在操作系统领域，特别是 CPU 调度范畴内，提法恰当、有科学依据的问题。所有必要的数据和定义都已提供，没有内部矛盾或含糊之处。\n\n我们首先根据每个作业 $J_i$ 的到达时间 $A_i$、执行周期 $B_i$、开始时间 $S_i$ 和完成时间 $C_i$ 来定义主要的性能指标。\n- **周转时间 ($TT_i$)**：作业从到达系统到完成所花费的总时间。计算公式为 $TT_i = C_i - A_i$。\n- **等待时间 ($WT_i$)**：作业在就绪队列中花费的总时间。对于非抢占式算法，这是从到达直到其开始执行的时间，计算公式为 $WT_i = S_i - A_i$。\n- **响应时间 ($RT_i$)**：从作业到达直到它收到第一次响应（即开始执行）的时间。对于非抢占式调度，这与等待时间相同：$RT_i = S_i - A_i$。\n\n已知条件如下：\n- 调度算法：非抢占式先到先服务（FCFS）。\n- 作业数量：$4$。\n- 到达时间：$A_1 = 0$ 毫秒, $A_2 = 1$ 毫秒, $A_3 = 2$ 毫秒, $A_4 = 10$ 毫秒。\n- CPU 执行周期：$B_1 = B_2 = B_3 = B_4 = 4$ 毫秒。\n\n首先，我们根据 FCFS 调度策略构建执行时间线（甘特图）。\n\\begin{enumerate}\n    \\item 在时间 $t=0$ 时，作业 $J_1$ 到达。就绪队列为 $[J_1]$。CPU 处于空闲状态，因此 $J_1$ 立即开始执行。其开始时间为 $S_1 = 0$。\n    \\item $J_1$ 需要 $4$ 毫秒的 CPU 执行周期。它将从 $t=0$ 运行到 $t=4$。其完成时间为 $C_1 = S_1 + B_1 = 0 + 4 = 4$。\n    \\item 在 $J_1$ 执行期间，作业 $J_2$（在 $t=1$ 时）和 $J_3$（在 $t=2$ 时）到达。当 $J_1$ 在 $t=4$ 时完成，按到达时间排序的就绪队列为 $[J_2, J_3]$。\n    \\item 根据 FCFS 规则，$J_2$ 接下来被服务。它在 $t=4$ 时开始，所以 $S_2 = 4$。它运行 $4$ 毫秒，在 $C_2 = S_2 + B_2 = 4 + 4 = 8$ 时完成。\n    \\item 在 $t=8$ 时，$J_2$ 完成。就绪队列现在只包含 $J_3$。$J_3$ 立即开始，所以 $S_3 = 8$。它运行 $4$ 毫秒，在 $C_3 = S_3 + B_3 = 8 + 4 = 12$ 时完成。\n    \\item 在 $J_3$ 执行期间，作业 $J_4$ 在 $t=10$ 时到达。当 $J_3$ 在 $t=12$ 时完成，就绪队列包含 $[J_4]$。\n    \\item $J_4$ 在 $t=12$ 时开始，所以 $S_4 = 12$。它运行 $4$ 毫秒，在 $C_4 = S_4 + B_4 = 12 + 4 = 16$ 时完成。\n\\end{enumerate}\n执行时间线如下：\n- $J_1$: $t \\in [0, 4)$\n- $J_2$: $t \\in [4, 8)$\n- $J_3$: $t \\in [8, 12)$\n- $J_4$: $t \\in [12, 16)$\n\n现在我们为每个作业计算性能指标。\n- **作业 $J_1$**:\n  - $TT_1 = C_1 - A_1 = 4 - 0 = 4$ 毫秒。\n  - $WT_1 = S_1 - A_1 = 0 - 0 = 0$ 毫秒。\n  - $RT_1 = WT_1 = 0$ 毫秒。\n- **作业 $J_2$**:\n  - $TT_2 = C_2 - A_2 = 8 - 1 = 7$ 毫秒。\n  - $WT_2 = S_2 - A_2 = 4 - 1 = 3$ 毫秒。\n  - $RT_2 = WT_2 = 3$ 毫秒。\n- **作业 $J_3$**:\n  - $TT_3 = C_3 - A_3 = 12 - 2 = 10$ 毫秒。\n  - $WT_3 = S_3 - A_3 = 8 - 2 = 6$ 毫秒。\n  - $RT_3 = WT_3 = 6$ 毫秒。\n- **作业 $J_4$**:\n  - $TT_4 = C_4 - A_4 = 16 - 10 = 6$ 毫秒。\n  - $WT_4 = S_4 - A_4 = 12 - 10 = 2$ 毫秒。\n  - $RT_4 = WT_4 = 2$ 毫秒。\n\n接下来，我们计算平均指标：\n- 平均周转时间 ($TT_{avg}$):\n$$ TT_{avg} = \\frac{TT_1 + TT_2 + TT_3 + TT_4}{4} = \\frac{4 + 7 + 10 + 6}{4} = \\frac{27}{4} = 6.75 \\text{ 毫秒} $$\n- 平均等待时间 ($WT_{avg}$):\n$$ WT_{avg} = \\frac{WT_1 + WT_2 + WT_3 + WT_4}{4} = \\frac{0 + 3 + 6 + 2}{4} = \\frac{11}{4} = 2.75 \\text{ 毫秒} $$\n- 平均响应时间 ($RT_{avg}$): 由于调度是非抢占式的，所以 $RT_{avg} = WT_{avg} = 2.75$ 毫秒。\n\n现在我们计算从 $t=0$ 到最后一个作业完成（$t=16$）期间的吞吐量和 CPU 利用率。\n- **吞吐量**：单位时间内完成的作业数量。\n$$ \\text{吞吐量} = \\frac{\\text{作业数量}}{\\text{总时间}} = \\frac{4}{16} = \\frac{1}{4} = 0.25 \\text{ 作业/毫秒} $$\n- **CPU 利用率**：CPU 处于忙碌状态的时间比例。\n该时间区间的总时长为 $16 - 0 = 16$ 毫秒。CPU 总忙碌时间是所有执行周期的总和：$4 \\times 4 = 16$ 毫秒。\n$$ \\text{CPU 利用率} = \\frac{\\text{总忙碌时间}}{\\text{总时间}} = \\frac{16}{16} = 1 $$\n\n问题要求讨论为什么相同的 CPU 执行周期会导致不同的响应时间。计算出的响应时间为 $RT_1 = 0$ 毫秒, $RT_2 = 3$ 毫秒, $RT_3 = 6$ 毫秒, 以及 $RT_4 = 2$ 毫秒。尽管所有作业都有相同的 $4$ 毫秒执行周期，但这些时间显然是不同的。响应时间 $RT_i = S_i - A_i$ 取决于开始时间和到达时间。在 FCFS 调度下，开始时间 $S_i$ 由所有先前到达的作业的完成时间决定。\n- $J_1$ 到达时系统空闲，因此它立即开始执行（$S_1=A_1$），其响应时间为 $0$。\n- $J_2$ 在 $t=1$ 到达，此时 $J_1$ 正在运行。它必须在队列中等待，直到 $J_1$ 在 $t=4$ 时完成。其响应时间是它到达后等待的时间，$RT_2 = 4-1=3$。\n- $J_3$ 在 $t=2$ 到达，必须等待 $J_1$ 和 $J_2$。它们在 $t=8$ 时完成。其响应时间是 $RT_3 = 8-2=6$。\n- $J_4$ 在 $t=10$ 时较晚到达，此时 $J_3$ 正在运行。它只需要等待 $J_3$ 在 $t=12$ 时完成。其响应时间是 $RT_4 = 12-10=2$。\n因此，响应时间是作业到达时系统负载的函数。在繁忙时期相继到达的作业将经历更长的等待时间，这种现象在 FCFS 中被称为护航效应（convoy effect）。\n\n最后，我们使用变异系数（CV）来量化响应时间的公平性，其定义为标准差除以平均值。响应时间的集合是 $\\{0, 3, 6, 2\\}$。\n平均响应时间 $\\mu_{RT}$ 为：\n$$ \\mu_{RT} = \\frac{0 + 3 + 6 + 2}{4} = \\frac{11}{4} $$\n为了求标准差 $\\sigma_{RT}$，我们首先计算方差 $\\sigma_{RT}^2$。使用公式 $\\sigma^2 = \\frac{1}{N}\\sum_{i=1}^{N} x_i^2 - \\mu^2$：\n$$ \\sum_{i=1}^{4} RT_i^2 = 0^2 + 3^2 + 6^2 + 2^2 = 0 + 9 + 36 + 4 = 49 $$\n$$ \\sigma_{RT}^2 = \\frac{1}{4} \\sum_{i=1}^{4} RT_i^2 - \\mu_{RT}^2 = \\frac{49}{4} - \\left(\\frac{11}{4}\\right)^2 = \\frac{49}{4} - \\frac{121}{16} = \\frac{4 \\times 49}{16} - \\frac{121}{16} = \\frac{196 - 121}{16} = \\frac{75}{16} $$\n标准差是方差的平方根：\n$$ \\sigma_{RT} = \\sqrt{\\frac{75}{16}} = \\frac{\\sqrt{25 \\times 3}}{\\sqrt{16}} = \\frac{5\\sqrt{3}}{4} $$\n变异系数为：\n$$ CV_{RT} = \\frac{\\sigma_{RT}}{\\mu_{RT}} = \\frac{5\\sqrt{3}/4}{11/4} = \\frac{5\\sqrt{3}}{11} $$", "answer": "$$\\boxed{\\frac{5\\sqrt{3}}{11}}$$", "id": "3630364"}, {"introduction": "理论分析告诉我们，最短作业优先（SJF）算法在特定条件下可以最小化平均周转时间，而FCFS则可能因“护航效应”表现不佳。这个练习将挑战你从分析者转变为设计者：你需要构造一个工作负载，以最大限度地突显这两种算法之间的性能差异。这个过程将让你深刻理解调度顺序如何对系统整体效率产生巨大影响。[@problem_id:3630422]", "problem": "考虑一个采用非抢占式调度的单核处理器。四个进程 $P_{1}, P_{2}, P_{3}, P_{4}$ 必须被调度。它们的 CPU 执行时间总和固定为 $20$ 个时间单位，并且每个单独的执行时间必须是正整数。您可以选择到达时间 $a_{i} \\geq 0$ 和执行时间 $b_{i} \\in \\mathbb{Z}^{+}$（其中 $i \\in \\{1,2,3,4\\}$），但必须满足约束条件 $\\sum_{i=1}^{4} b_{i} = 20$。调度器为先来先服务 (FCFS) 或最短作业优先 (SJF)，两者均为非抢占式。当主要规则无法区分进程优先级时，按进程标识符的升序来处理。具体来说，FCFS 按到达时间的升序排序，若到达时间相同则按进程标识符的升序排序；SJF 按执行时间的升序排序，若执行时间相同则按进程标识符的升序排序。进程 $i$ 的周转时间定义为 $T_{i} = C_{i} - a_{i}$，其中 $C_{i}$ 是其完成时间。\n\n请设计到达时间和执行时间，以在所述约束条件下，最大化由 FCFS 产生的平均周转时间与由 SJF 产生的平均周转时间之间的差值。然后，计算该最大平均周转时间差值的数值。将最终差值表示为一个不带单位的实数。除了整数的精确算术外，不需要进行舍入。", "solution": "用户希望我解决以下问题：\n“考虑一个采用非抢占式调度的单核处理器。四个进程 $P_{1}, P_{2}, P_{3}, P_{4}$ 必须被调度。它们的 CPU 执行时间总和固定为 $20$ 个时间单位，并且每个单独的执行时间必须是正整数。您可以选择到达时间 $a_{i} \\geq 0$ 和执行时间 $b_{i} \\in \\mathbb{Z}^{+}$（其中 $i \\in \\{1,2,3,4\\}$），但必须满足约束条件 $\\sum_{i=1}^{4} b_{i} = 20$。调度器为先来先服务 (FCFS) 或最短作业优先 (SJF)，两者均为非抢占式。当主要规则无法区分进程优先级时，按进程标识符的升序来处理。具体来说，FCFS 按到达时间的升序排序，若到达时间相同则按进程标识符的升序排序；SJF 按执行时间的升序排序，若执行时间相同则按进程标识符的升序排序。进程 $i$ 的周转时间定义为 $T_{i} = C_{i} - a_{i}$，其中 $C_{i}$ 是其完成时间。\n\n请设计到达时间和执行时间，以在所述约束条件下，最大化由 FCFS 产生的平均周转时间与由 SJF 产生的平均周转时间之间的差值。然后，计算该最大平均周转时间差值的数值。将最终差值表示为一个不带单位的实数。除了整数的精确算术外，不需要进行舍入。”\n\n### 步骤 1：提取已知条件\n- **进程**：$P_{1}, P_{2}, P_{3}, P_{4}$。进程数量 $N=4$。\n- **调度**：单核，非抢占式。\n- **算法**：先来先服务 (FCFS) 和最短作业优先 (SJF)。\n- **平局打破规则**：对于 FCFS（到达时间相同）和 SJF（执行时间相同），通过增加进程标识符（例如，$P_1$ 在 $P_2$ 之前）来打破僵局。\n- **到达时间**：$a_i \\ge 0$，对于 $i \\in \\{1,2,3,4\\}$，是待选择的变量。\n- **执行时间**：$b_i \\in \\mathbb{Z}^{+}$ (正整数)，对于 $i \\in \\{1,2,3,4\\}$，是待选择的变量，且需满足 $\\sum_{i=1}^{4} b_i = 20$。\n- **目标**：最大化平均周转时间的差值，$\\overline{T}_{FCFS} - \\overline{T}_{SJF}$。周转时间为 $T_i = C_i - a_i$，其中 $C_i$ 是完成时间。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题是一个在操作系统调度标准理论框架内定义明确的优化任务。所有已知条件是自洽且一致的。所用术语（FCFS、SJF、非抢占式、周转时间等）均为标准术语且定义明确。约束条件清晰指定。平局打破规则是明确的，避免了调度决策中的歧义。该问题具有科学依据，是客观且适定的。未发现任何缺陷。\n\n### 步骤 3：结论与行动\n该问题有效。将提供完整解答。\n\n### 解题过程\n设 $\\overline{T}_{FCFS}$ 和 $\\overline{T}_{SJF}$ 分别为 FCFS 和 SJF 调度器的平均周转时间。我们的目标是最大化差值 $\\Delta \\overline{T} = \\overline{T}_{FCFS} - \\overline{T}_{SJF}$。\n\n平均周转时间由 $\\overline{T} = \\frac{1}{N} \\sum_{i=1}^{N} T_i$ 给出，其中 $N=4$。进程 $i$ 的周转时间为 $T_i = C_i - a_i$。\n差值可以写为：\n$$ \\Delta \\overline{T} = \\frac{1}{4} \\sum_{i=1}^{4} T_{i,FCFS} - \\frac{1}{4} \\sum_{i=1}^{4} T_{i,SJF} = \\frac{1}{4} \\left( \\sum_{i=1}^{4} (C_{i,FCFS} - a_i) - \\sum_{i=1}^{4} (C_{i,SJF} - a_i) \\right) $$\n由于两种情况下的到达时间 $a_i$ 相同，它们会相互抵消：\n$$ \\Delta \\overline{T} = \\frac{1}{4} \\left( \\sum_{i=1}^{4} C_{i,FCFS} - \\sum_{i=1}^{4} C_{i,SJF} \\right) $$\n因此，我们的目标是选择到达时间 $a_i$ 和执行时间 $b_i$，以最大化完成时间总和的差值。\n\n让我们分析完成时间的总和。对于从空闲 CPU 开始的进程序列 $P_{\\pi(1)}, P_{\\pi(2)}, \\dots, P_{\\pi(N)}$ 的非抢占式调度，序列中第 $k$ 个进程的完成时间为 $C_{\\pi(k)} = \\max(C_{\\pi(k-1)}, a_{\\pi(k)}) + b_{\\pi(k)}$，其中 $C_{\\pi(0)}=0$。\n\n为了最大化差值，我们应该力求使 FCFS 调度尽可能低效（最大化 $\\sum C_{FCFS}$），并使 SJF 调度尽可能高效（最小化 $\\sum C_{SJF}$）。\n\n已知 SJF 算法在所有进程同时可用的情况下，在最小化平均周转时间（以及完成时间总和）方面是最优的。任何到达时间的错开，特别是如果一个长作业先到达，都可能导致次优的 SJF 调度（“护航效应”）。为确保 SJF 表现最优，我们应该让所有进程在开始时都可用。实现这一目标的最简单方法是将所有到达时间都设置为零：$a_1=a_2=a_3=a_4=0$。\n\n我们采用此策略：对所有 $i$，令 $a_i=0$。\n现在我们分析这对两种调度器的影响。\n\n**$a_i=0$ 条件下的 FCFS 调度：**\n由于所有进程都在 $t=0$ 到达，FCFS 调度完全由平局打破规则决定：按进程标识符的升序。因此，执行顺序固定为 $P_1, P_2, P_3, P_4$。\n完成时间为：\n$C_1 = b_1$\n$C_2 = b_1 + b_2$\n$C_3 = b_1 + b_2 + b_3$\n$C_4 = b_1 + b_2 + b_3 + b_4 = 20$\nFCFS 的完成时间总和为：\n$$ \\sum_{i=1}^{4} C_{i,FCFS} = (b_1) + (b_1+b_2) + (b_1+b_2+b_3) + (b_1+b_2+b_3+b_4) = 4b_1 + 3b_2 + 2b_3 + b_4 $$\n\n**$a_i=0$ 条件下的 SJF 调度：**\n由于所有进程都在 $t=0$ 可用，SJF 将按其执行时间的升序执行它们。让我们将排序后的执行时间表示为 $b_{(1)} \\le b_{(2)} \\le b_{(3)} \\le b_{(4)}$。SJF 调度器将首先执行执行时间为 $b_{(1)}$ 的进程，然后是 $b_{(2)}$ 的进程，以此类推。（平局由进程 ID 打破，但这不改变调度中执行时间值的序列）。\n这种最优 SJF 调度的完成时间总和为：\n$$ \\sum_{i=1}^{4} C_{i,SJF} = 4b_{(1)} + 3b_{(2)} + 2b_{(3)} + b_{(4)} $$\n\n**最大化差值：**\n我们需要最大化 $\\Delta \\Sigma C = (\\sum C_{i,FCFS}) - (\\sum C_{i,SJF})$。\n$$ \\Delta \\Sigma C = (4b_1 + 3b_2 + 2b_3 + b_4) - (4b_{(1)} + 3b_{(2)} + 2b_{(3)} + b_{(4)}) $$\n值 $\\{b_1, b_2, b_3, b_4\\}$ 是排序后的值 $\\{b_{(1)}, b_{(2)}, b_{(3)}, b_{(4)}\\}$ 的一个排列。我们必须选择执行时间及其到进程 $P_1, \\dots, P_4$ 的分配。\n\n首先，让我们选择一组四个正整数执行时间 $\\{B_1, B_2, B_3, B_4\\}$，使得 $B_1 \\le B_2 \\le B_3 \\le B_4$ 且它们的总和为 $20$。对于这个固定的集合，排序后的值是固定的：$(b_{(1)}, b_{(2)}, b_{(3)}, b_{(4)}) = (B_1, B_2, B_3, B_4)$。对于这个集合，$\\sum C_{SJF}$ 项是常数。\n为了最大化 $\\Delta \\Sigma C$，我们必须通过将集合 $\\{B_1, B_2, B_3, B_4\\}$ 中的值分配给变量 $(b_1, b_2, b_3, b_4)$ 来最大化 $\\sum C_{FCFS} = 4b_1 + 3b_2 + 2b_3 + b_4$。通过将最大的执行时间分配给系数最大的变量，第二大的执行时间分配给系数第二大的变量，以此类推，可以使总和最大化。\n这种最优分配是：$b_1 = B_4$, $b_2 = B_3$, $b_3 = B_2$ 和 $b_4 = B_1$。\n\n将此分配代入 $\\Delta \\Sigma C$ 的表达式中：\n$$ \\Delta \\Sigma C = (4B_4 + 3B_3 + 2B_2 + B_1) - (4B_1 + 3B_2 + 2B_3 + B_4) $$\n$$ \\Delta \\Sigma C = (4-1)B_4 + (3-2)B_3 + (2-3)B_2 + (1-4)B_1 $$\n$$ \\Delta \\Sigma C = 3B_4 + B_3 - B_2 - 3B_1 = 3(B_4 - B_1) + (B_3 - B_2) $$\n\n现在，我们需要选择正整数 $B_1, B_2, B_3, B_4$，使其满足约束条件 $1 \\le B_1 \\le B_2 \\le B_3 \\le B_4$ 和 $B_1+B_2+B_3+B_4=20$，并使得 $3(B_4 - B_1) + (B_3 - B_2)$ 最大化。\n\n为了最大化该表达式，我们需要最大化“跨度” $(B_4 - B_1)$ 和 $(B_3 - B_2)$。$(B_4-B_1)$ 项的系数更大，因此它更重要。\n为了最大化 $B_4 - B_1$，我们必须使 $B_4$ 尽可能大，并使 $B_1$ 尽可能小。执行时间的最小可能值为 $B_1=1$。\n为了最大化 $B_4$，我们必须使 $B_1, B_2, B_3$ 尽可能小。\n让我们选择最小可能的值：$B_1 = 1$, $B_2 = 1$, $B_3 = 1$。\n这个选择满足 $B_1 \\le B_2 \\le B_3$。\n第四个执行时间由总和约束确定：$B_4 = 20 - B_1 - B_2 - B_3 = 20 - 1 - 1 - 1 = 17$。\n得到的集合是 $\\{1, 1, 1, 17\\}$。我们必须检查该集合是否满足排序约束：$1 \\le 1 \\le 1 \\le 17$。它满足。\n任何增加 $B_1$、$B_2$ 或 $B_3$ 的行为都会减少 $B_4$，从而减少主导项 $3(B_4-B_1)$，或者无法最大化 $3(B_4-B_1)+(B_3-B_2)$。例如，使用 $\\{1, 1, 2, 16\\}$ 会得到 $3(16-1)+(2-1) = 45+1 = 46$，这小于 $3(17-1)+(1-1)=48$。\n因此，最大化差值的执行时间集合是 $\\{1, 1, 1, 17\\}$。\n\n$\\Delta \\Sigma C$ 的最大值为：\n$$ \\Delta \\Sigma C_{max} = 3(17 - 1) + (1 - 1) = 3(16) + 0 = 48 $$\n\n设计的到达时间和执行时间为：\n-   到达时间：$a_1=0, a_2=0, a_3=0, a_4=0$。\n-   执行时间：基于分配 $b_1=B_4, b_2=B_3, b_3=B_2, b_4=B_1$，我们有：\n    $b_1 = 17$, $b_2 = 1$, $b_3 = 1$, $b_4 = 1$。\n\n最后，我们计算平均周转时间的最大差值。\n$$ \\Delta \\overline{T}_{max} = \\frac{1}{4} (\\Delta \\Sigma C_{max}) = \\frac{48}{4} = 12 $$\n\n为了验证，我们明确计算此配置下的平均周转时间。\n$a_i=0$, $b_1=17, b_2=1, b_3=1, b_4=1$。\nFCFS 调度：$P_1, P_2, P_3, P_4$。\n$C_1=17, C_2=18, C_3=19, C_4=20$。\n$T_1=17, T_2=18, T_3=19, T_4=20$。\n$\\overline{T}_{FCFS} = \\frac{17+18+19+20}{4} = \\frac{74}{4} = 18.5$。\n\nSJF 调度：$P_2, P_3, P_4, P_1$（因为 $b_2=b_3=b_4=1$，平局按 ID 打破）。\n$C_2=1, C_3=2, C_4=3$。$C_1=20$。\n$T_2=1, T_3=2, T_4=3, T_1=20$。\n$\\overline{T}_{SJF} = \\frac{20+1+2+3}{4} = \\frac{26}{4} = 6.5$。\n\n差值：$\\overline{T}_{FCFS} - \\overline{T}_{SJF} = 18.5 - 6.5 = 12$。\n结果得到证实。", "answer": "$$\\boxed{12}$$", "id": "3630422"}, {"introduction": "在理想化的模型之外，现实世界的调度决策必须考虑上下文切换的开销（$c$）。本练习将探讨这一开销如何影响CPU利用率，特别是在比较看似公平的轮转（RR）调度与简单的FCFS时。通过推导，你将发现算法的选择与系统参数（如时间片大小 $q$）之间存在的微妙权衡，这是性能调优中的一个核心问题。[@problem_id:3630455]", "problem": "考虑一个单处理器操作系统，其每次调度器分派会产生 $c>0$ 个时间单位的上下文切换开销。一个工作负载在时间 $0$ 到达，由 $N$ 个相同的、严格受 CPU 限制的进程组成。每个进程执行一个持续时间为 $B>0$ 个时间单位的、不间断的 CPU 突发，然后终止；没有输入/输出，也没有新的进程到达。假设调度器使用先到先服务（FCFS）或时间片轮转（RR）策略，时间片大小为 $q>0$。对于这两种策略，将上下文切换开销建模为在每个调度时间片发生一次（即，在每个突发或时间片开始之前，包括每个进程的首次分派）。\n\n仅使用中央处理器（CPU）利用率的核心定义，即 CPU 执行有用进程而非调度器开销的时间占总运行时间的比例，在上述假设下完成以下任务：\n\n- 明确说明此工作负载，并根据 $c$ 和 $q$ 解释为什么当 $q$ 很小时，即使两种策略最终完成的有用功相同，FCFS 仍能实现比 RR 更高的利用率。\n- 从第一性原理出发，推导 FCFS 和 RR 在整个工作负载完成期间实现的利用率的符号表达式，这些表达式是关于 $N$、$B$、$c$ 和 $q$ 的函数。\n- 计算阈值时间片 $q^{\\ast}$，使得当 $0", "solution": "该问题被评估为有效。这是一个来自操作系统领域的、表述清晰、有科学依据的问题，没有矛盾或歧义。解决问题所需的所有参数均已提供。我们可以开始推导。\n\n题目给出的核心定义是，中央处理器（CPU）利用率（表示为 $U$）是 CPU 执行有用进程的时间占总运行时间的比例。这可以表示为：\n$$\nU = \\frac{\\text{总有用功时间}}{\\text{总运行时间}}\n$$\n总有用功时间是所有进程的 CPU 突发持续时间之和。该工作负载由 $N$ 个相同的进程组成，每个进程有一个持续时间为 $B$ 的 CPU 突发。因此，总有用功时间 $T_{\\text{work}}$ 为：\n$$\nT_{\\text{work}} = N \\times B\n$$\n总运行时间，也称为完工时间（makespan），是总有用功时间和上下文切换产生的总开销时间之和。调度策略决定了总开销。\n\n首先，将工作负载指定为 $N$ 个进程的集合 $\\{P_1, P_2, \\dots, P_N\\}$。对于每个进程 $P_i$，其到达时间为 $A_i = 0$，CPU 突发持续时间为 $B_i = B$。所有进程都是严格受 CPU 限制的。\n\n让我们推导每种策略的利用率。\n\n**先到先服务（FCFS）调度**\n\n在 FCFS 策略下，进程按顺序执行直至完成。不失一般性，设执行顺序为 $P_1, P_2, \\dots, P_N$。\n对于每个进程 $P_i$，系统为其分派产生 $c$ 的上下文切换开销，然后进程运行其完整的突发时间 $B$。因此，服务单个进程的时间为 $c+B$。由于有 $N$ 个进程一个接一个地执行，总运行时间 $T_{\\text{FCFS}}$ 为：\n$$\nT_{\\text{FCFS}} = \\sum_{i=1}^{N} (c + B) = N(c+B)\n$$\nFCFS 的总开销是所有上下文切换时间之和，即 $N \\times c$。总运行时间确实是总有用功（$NB$）和总开销（$Nc$）之和。\nFCFS 的利用率 $U_{\\text{FCFS}}$ 为：\n$$\nU_{\\text{FCFS}} = \\frac{T_{\\text{work}}}{T_{\\text{FCFS}}} = \\frac{NB}{N(c+B)} = \\frac{B}{B+c}\n$$\n\n**时间片轮转（RR）调度**\n\n在 RR 策略下，调度器循环遍历就绪队列，为每个进程分派最多为 $q$ 的时间片。每次分派前都会发生一次成本为 $c$ 的上下文切换。\n如果 $B > q$，一个总突发需求为 $B$ 的进程将需要多个时间片。单个进程必须被分派的次数是大于或等于 $B/q$ 的最小整数，由向上取整函数 $\\lceil B/q \\rceil$ 给出。\n由于有 $N$ 个相同的进程，整个工作负载的总分派次数为：\n$$\n\\text{Total Dispatches}_{\\text{RR}} = N \\times \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\n每次分派产生 $c$ 的开销。因此，RR 的总开销时间为：\n$$\nT_{\\text{overhead, RR}} = N c \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\nCPU 从不空闲，因为在整个工作负载完成之前，就绪队列中始终至少有一个进程。总运行时间 $T_{\\text{RR}}$ 是总有用功和总开销之和。\n$$\nT_{\\text{RR}} = T_{\\text{work}} + T_{\\text{overhead, RR}} = NB + Nc \\left\\lceil \\frac{B}{q} \\right\\rceil\n$$\nRR 的利用率 $U_{\\text{RR}}$ 为：\n$$\nU_{\\text{RR}} = \\frac{T_{\\text{work}}}{T_{\\text{RR}}} = \\frac{NB}{NB + Nc \\left\\lceil \\frac{B}{q} \\right\\rceil} = \\frac{B}{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil}\n$$\n\n**定性比较**\n\n两种策略都完成了相同的有用功 $NB$。通过最小化开销可以最大化利用率。\nFCFS 的开销是一个常数 $Nc$，对应于每个进程一次上下文切换。\nRR 的开销是 $Nc\\lceil B/q \\rceil$。当时间片 $q$ 相对于突发时间 $B$ 很小（即 $q \\ll B$）时，项 $\\lceil B/q \\rceil$ 会变得很大。例如，如果 $B/q = 100$，则 RR 的开销大约是 FCFS 的 100 倍。这种不成比例的高开销导致了 RR 的利用率降低。虽然 RR 可能提供了更好的响应时间，但这是以降低整体效率为代价的。\n\n**阈值时间片 $q^{\\ast}$ 的计算**\n\n我们想找到一个 $q^{\\ast}$，使得当 $0  q  q^{\\ast}$ 时，不等式 $U_{\\text{RR}}  U_{\\text{FCFS}}$ 成立。\n代入我们推导的表达式：\n$$\n\\frac{B}{B + c \\left\\lceil \\frac{B}{q} \\right\\rceil}  \\frac{B}{B+c}\n$$\n由于所有项都是正数，我们可以取倒数并反转不等号：\n$$\nB + c \\left\\lceil \\frac{B}{q} \\right\\rceil > B+c\n$$\n$$\nc \\left\\lceil \\frac{B}{q} \\right\\rceil > c\n$$\n由于 $c > 0$，我们可以将两边都除以 $c$：\n$$\n\\left\\lceil \\frac{B}{q} \\right\\rceil > 1\n$$\n向上取整函数 $\\lceil x \\rceil$ 的值大于 $1$ 的条件是 $x>1$。\n因此，该不等式成立的条件是：\n$$\n\\frac{B}{q} > 1 \\implies B > q \\implies q  B\n$$\n因此，只要时间片 $q$ 小于突发时间 $B$，RR 的利用率就会严格低于 FCFS。行为发生改变的临界点是当 $q=B$ 时。此时，$\\lceil B/q \\rceil = \\lceil 1 \\rceil = 1$，这使得 $U_{\\text{RR}} = U_{\\text{FCFS}}$。对于任何 $q>B$，$\\lceil B/q \\rceil$ 仍然是 $1$，因此利用率保持相等。\n不等式 $U_{\\text{RR}}  U_{\\text{FCFS}}$ 成立的区间是 $0  q  B$。\n因此，阈值 $q^{\\ast}$ 是 $B$。\n\n最终答案是 $B$。", "answer": "$$\\boxed{B}$$", "id": "3630455"}]}