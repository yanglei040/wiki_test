{"hands_on_practices": [{"introduction": "操作系统的一个核心任务是在多个并发工作负载之间公平有效地分配有限的共享资源，例如内存带宽。此练习模拟了一个真实场景，其中系统管理员设置了代表相对重要性的外部优先级，而操作系统则通过硬件性能计数器观察到的内部需求。通过解决这个问题，您将亲身体验操作系统如何在一个具体的数学模型中平衡这两个方面，即在不超过内部实际需求的前提下，按比例分配资源以尊重外部优先级。[@problem_id:3649910]", "problem": "一个多道程序操作系统（OS）在并发工作负载之间多路复用一个峰值吞吐量有限的共享内存总线。管理员以表达相对重要性的非负权重的形式提供外部优先级，同时操作系统也通过根据硬件性能计数器计算的需求估计来观察内部优先级。考虑在全局峰值内存带宽预算下实施内存带宽限制的以下策略：给定外部权重和内部需求估计，操作系统为每个工作负载分配一个与其外部权重成正比但不超过其内部需求的带宽上限。具体来说，对于工作负载索引 $i \\in \\{1,2,3,4\\}$，其上限为 $C_i(\\alpha) = \\min\\{\\alpha\\,w_i, D_i\\}$，其中 $\\alpha \\ge 0$ 是某个缩放因子，操作系统选择 $\\alpha$ 以使分配的总带宽恰好等于全局预算 $B_{\\max}$，即 $\\sum_{i=1}^{4} C_i(\\alpha) = B_{\\max}$。\n\n假设有 $4$ 个工作负载，其外部权重分别为 $w_1 = 3$，$w_2 = 1$，$w_3 = 4$ 和 $w_4 = 2$。每个工作负载的内部需求估计 $D_i$ 由末级缓存（LLC）未命中计数器得出，具体如下：如果一个工作负载每秒出现 $m_i$ 次 LLC 未命中，并且每次 LLC 未命中都从主内存中精确获取一个大小为 $c$ 字节的缓存行，那么该工作负载的瞬时内存带宽需求为 $D_i = m_i \\, c$ 字节/秒。设缓存行大小为 $c = 64$ 字节，并定义 $1$ 千兆字节（GB）为 $10^9$ 字节。观察到的 LLC 未命中率分别为：$m_1 = 150 \\times 10^6$ 次/秒，$m_2 = 50 \\times 10^6$ 次/秒，$m_3 = 500 \\times 10^6$ 次/秒，以及 $m_4 = 200 \\times 10^6$ 次/秒。全局内存带宽预算为 $B_{\\max} = 35$ GB/s。\n\n在上述策略下，确定工作负载 $4$ 的最终带宽上限。用 GB/s 表示你的答案，并将其四舍五入到四位有效数字。", "solution": "该问题要求在特定的资源分配策略下，确定工作负载 $4$ 的内存带宽上限（记为 $C_4$）。该策略为 $N=4$ 个工作负载定义，索引为 $i \\in \\{1, 2, 3, 4\\}$。\n\n首先，我们必须通过计算每个工作负载的内部需求估计 $D_i$ 来将问题形式化。需求由末级缓存（LLC）未命中率 $m_i$ 和缓存行大小 $c$ 的乘积给出。给定的值为：\n- 缓存行大小，$c = 64$ 字节。\n- 工作负载1的未命中率，$m_1 = 150 \\times 10^6$ 次/秒。\n- 工作负载2的未命中率，$m_2 = 50 \\times 10^6$ 次/秒。\n- 工作负载3的未命中率，$m_3 = 500 \\times 10^6$ 次/秒。\n- 工作负载4的未命中率，$m_4 = 200 \\times 10^6$ 次/秒。\n\n每个工作负载的需求 $D_i = m_i c$ 计算如下，将单位从字节/秒（bytes/s）转换为千兆字节/秒（GB/s），其中 $1 \\text{ GB} = 10^9$ 字节：\n- $D_1 = (150 \\times 10^6 \\text{ s}^{-1}) \\times (64 \\text{ bytes}) = 9600 \\times 10^6 \\text{ bytes/s} = 9.6 \\text{ GB/s}$。\n- $D_2 = (50 \\times 10^6 \\text{ s}^{-1}) \\times (64 \\text{ bytes}) = 3200 \\times 10^6 \\text{ bytes/s} = 3.2 \\text{ GB/s}$。\n- $D_3 = (500 \\times 10^6 \\text{ s}^{-1}) \\times (64 \\text{ bytes}) = 32000 \\times 10^6 \\text{ bytes/s} = 32.0 \\text{ GB/s}$。\n- $D_4 = (200 \\times 10^6 \\text{ s}^{-1}) \\times (64 \\text{ bytes}) = 12800 \\times 10^6 \\text{ bytes/s} = 12.8 \\text{ GB/s}$。\n\n每个工作负载的带宽上限 $C_i(\\alpha)$ 由公式 $C_i(\\alpha) = \\min\\{\\alpha\\,w_i, D_i\\}$ 给出，其中 $w_i$ 是外部权重，$\\alpha$ 是一个缩放因子。给定的权重为 $w_1 = 3$，$w_2 = 1$，$w_3 = 4$ 和 $w_4 = 2$。\n\n必须选择缩放因子 $\\alpha$，使得各个上限之和等于全局内存带宽预算 $B_{\\max} = 35$ GB/s。这给出了控制方程：\n$$ \\sum_{i=1}^{4} C_i(\\alpha) = B_{\\max} $$\n$$ \\min\\{3\\alpha, 9.6\\} + \\min\\{\\alpha, 3.2\\} + \\min\\{4\\alpha, 32.0\\} + \\min\\{2\\alpha, 12.8\\} = 35 $$\n设 $f(\\alpha)$ 为分配的总带宽。函数 $f(\\alpha)$ 是连续、单调递增且分段线性的。函数线性段改变的点是 $\\alpha$ 的临界值，在这些点上工作负载的分配变为受需求限制，即当 $\\alpha w_i = D_i$ 时。我们将这些临界值记为 $\\alpha_i^* = D_i/w_i$。\n- $\\alpha_1^* = \\frac{D_1}{w_1} = \\frac{9.6}{3} = 3.2$。\n- $\\alpha_2^* = \\frac{D_2}{w_2} = \\frac{3.2}{1} = 3.2$。\n- $\\alpha_3^* = \\frac{D_3}{w_3} = \\frac{32.0}{4} = 8.0$。\n- $\\alpha_4^* = \\frac{D_4}{w_4} = \\frac{12.8}{2} = 6.4$。\n\n我们可以通过检查由这些有序临界值（$3.2, 6.4, 8.0$）定义的区间内的总分配来求解 $\\alpha$。\n\n**情况1**：如果所有工作负载都按比例分配（即不受需求限制），那么对于所有 $i$，都有 $C_i(\\alpha) = \\alpha w_i$。\n方程变为 $\\sum_{i=1}^{4} \\alpha w_i = B_{\\max}$，即 $\\alpha \\sum_{i=1}^{4} w_i = B_{\\max}$。\n权重之和为 $\\sum w_i = 3 + 1 + 4 + 2 = 10$。\n所以，$\\alpha(10) = 35$，得出 $\\alpha = 3.5$。\n这个解假设对于所有 $i$ 都有 $\\alpha w_i \\le D_i$，即 $\\alpha \\le D_i/w_i = \\alpha_i^*$。然而，$\\alpha = 3.5$ 违反了工作负载1和2的条件（$\\alpha_1^*=3.2, \\alpha_2^*=3.2$）。因此，至少有一个工作负载是受需求限制的，我们的初始假设不成立。\n\n**情况2**：由于 $\\alpha$ 必须大于 $3.2$，我们假设最终的解位于下一个区间 $3.2 \\le \\alpha  6.4$。\n在此区间内，工作负载 $1$ 和 $2$ 是受需求限制的（因为 $\\alpha \\ge \\alpha_1^*, \\alpha_2^*$）。它们的上限被固定在其需求上：$C_1(\\alpha) = D_1 = 9.6$ 和 $C_2(\\alpha) = D_2 = 3.2$。\n工作负载 $3$ 和 $4$ 仍然是权重成比例的（因为 $\\alpha  \\alpha_3^*, \\alpha_4^*$）。它们的上限是 $C_3(\\alpha) = 4\\alpha$ 和 $C_4(\\alpha) = 2\\alpha$。\n控制方程变为：\n$$ D_1 + D_2 + \\alpha w_3 + \\alpha w_4 = B_{\\max} $$\n$$ 9.6 + 3.2 + 4\\alpha + 2\\alpha = 35 $$\n$$ 12.8 + 6\\alpha = 35 $$\n$$ 6\\alpha = 35 - 12.8 $$\n$$ 6\\alpha = 22.2 $$\n$$ \\alpha = \\frac{22.2}{6} = 3.7 $$\n这个值 $\\alpha = 3.7$ 位于假设的区间 $[3.2, 6.4)$ 内，因此这是正确的缩放因子。\n\n现在我们可以确定工作负载 $4$ 的最终带宽上限 $C_4$。\n使用确定的值 $\\alpha=3.7$：\n$$ C_4 = C_4(3.7) = \\min\\{2\\alpha, D_4\\} = \\min\\{2(3.7), 12.8\\} $$\n$$ C_4 = \\min\\{7.4, 12.8\\} = 7.4 $$\n工作负载 $4$ 的带宽上限是 $7.4$ GB/s。\n\n作为最终检查，我们计算所有上限及其总和：\n$C_1 = \\min\\{3(3.7), 9.6\\} = \\min\\{11.1, 9.6\\} = 9.6$ GB/s。\n$C_2 = \\min\\{1(3.7), 3.2\\} = \\min\\{3.7, 3.2\\} = 3.2$ GB/s。\n$C_3 = \\min\\{4(3.7), 32.0\\} = \\min\\{14.8, 32.0\\} = 14.8$ GB/s。\n$C_4 = 7.4$ GB/s。\n总带宽 $= C_1 + C_2 + C_3 + C_4 = 9.6 + 3.2 + 14.8 + 7.4 = 12.8 + 14.8 + 7.4 = 27.6 + 7.4 = 35.0$ GB/s。\n总和与预算 $B_{\\max} = 35$ GB/s 相匹配。\n\n问题要求答案以 GB/s 表示，并四舍五入到四位有效数字。计算出的值恰好是 $7.4$。为了用四位有效数字表示，我们将其写为 $7.400$。", "answer": "$$ \\boxed{7.400} $$", "id": "3649910"}, {"introduction": "当系统管理多个相互依赖的资源（如CPU和I/O）时，独立的调度策略可能会导致严重的性能问题。例如，一个任务可能拥有高I/O优先级，但由于CPU优先级低而无法获得足够的CPU时间来生成I/O请求，从而导致资源利用率低下和系统不稳定。这个思想实验将挑战您以系统架构师的视角思考，评估不同的调度器协同设计方案，并找出一个能够通过跨调度器反馈来稳健解决资源耦合问题的最佳策略。[@problem_id:3649895]", "problem": "一个系统运行着两个资源调度器：一个用于中央处理器（CPU），一个用于输入/输出（IO）。每个调度器通过内部优先级和外部优先级的组合来对任务进行排序。内部优先级，对于资源 $R \\in \\{\\mathrm{CPU}, \\mathrm{IO}\\}$ 和任务 $i$ 表示为 $P_{int}^{R}(i)$，由操作系统根据运行时观察（如估计的CPU突发长度和观察到的阻塞行为）得出。外部优先级，表示为 $P_{ext}^{R}(i)$，由调度器外部的策略（例如，管理员或服务水平目标）设置，以指示任务在资源 $R$ 上的相对重要性。CPU调度器从可运行任务中选择以分配CPU服务，IO调度器从待处理的IO请求中选择以分配IO服务；每个资源的容量为单位1，因此所有任务的总CPU服务速率和总IO服务速率都限制为$1$。\n\n考虑两个任务 $A$ 和 $B$，它们具有以下外部优先级：\n- $P_{ext}^{\\mathrm{CPU}}(A) = 1$， $P_{ext}^{\\mathrm{IO}}(A) = 5$，\n- $P_{ext}^{\\mathrm{CPU}}(B) = 5$， $P_{ext}^{\\mathrm{IO}}(B) = 1$。\n\n每个任务 $i$ 产生的IO请求数量与其接收到的CPU服务成正比：具体来说，IO请求到达率 $\\lambda^{\\mathrm{IO}}_i$ 满足 $\\lambda^{\\mathrm{IO}}_i = \\alpha_i \\,\\mu^{\\mathrm{CPU}}_i$，其中 $\\mu^{\\mathrm{CPU}}_i$ 是分配给任务 $i$ 的CPU服务速率，而 $\\alpha_i$ 是由操作系统测量的任务特定转换因子。假设 $\\alpha_A = 10$ 且 $\\alpha_B = 0.1$。设 $\\mu^{\\mathrm{IO}}_i$ 为分配给任务 $i$ 的IO服务速率。队列稳定性要求对于每个任务 $i$，其IO队列不发散，即 $\\lambda^{\\mathrm{IO}}_i \\le \\mu^{\\mathrm{IO}}_i$。\n\n假设最初每个调度器通过按任务间的 $P_{ext}^{R}(\\cdot)$ 比例分配其资源来独立地强制执行外部优先级，而内部优先级仅反映短期老化，没有跨资源耦合。在这种情况下，具有高 $P_{ext}^{\\mathrm{IO}}$ 的任务可能在IO上受优待但接收很少的CPU，而具有高 $P_{ext}^{\\mathrm{CPU}}$ 的任务可能在CPU上受优待但接收很少的IO。这种不匹配可能导致饥饿或不稳定，因为IO的到达依赖于CPU服务，而CPU的效率依赖于及时的IO完成。\n\n在上述场景中，哪种双调度器接口设计能够最稳健地避免饥饿并确保队列稳定，同时保留外部优先级的意图？\n\nA. 保持CPU和IO调度器完全独立，每个调度器严格按照 $P_{ext}^{R}(\\cdot)$ 比例分配其资源；仅在 $P_{int}^{R}(\\cdot)$ 内部使用按资源的老化来缓解饥饿。\n\nB. 对于每个任务 $i$，通过固定的线性标量化将其外部优先级向量 $\\left(P_{ext}^{\\mathrm{CPU}}(i), P_{ext}^{\\mathrm{IO}}(i)\\right)$ 转换为各资源的有效优先级，例如，$P_{eff}^{\\mathrm{CPU}}(i) = \\alpha P_{ext}^{\\mathrm{CPU}}(i) + \\beta P_{ext}^{\\mathrm{IO}}(i)$ 和 $P_{eff}^{\\mathrm{IO}}(i) = \\gamma P_{ext}^{\\mathrm{IO}}(i) + \\delta P_{ext}^{\\mathrm{CPU}}(i)$，其中系数为常数，然后根据 $P_{eff}^{R}(\\cdot)$ 独立地调度每个资源。\n\nC. 引入一个协调的跨调度器反馈接口：对于每个任务 $i$，IO调度器导出其观察到的积压量和转换因子 $\\alpha_i$，CPU调度器导出可运行任务的积压量；每个调度器调整其有效优先级 $P_{eff}^{R}(i)$ 以满足队列稳定性所隐含的资源耦合约束（例如，确保 $\\mu^{\\mathrm{IO}}_i \\ge \\alpha_i \\,\\mu^{\\mathrm{CPU}}_i$），同时对分配进行归一化以尊重外部权重 $\\left(P_{ext}^{\\mathrm{CPU}}(i), P_{ext}^{\\mathrm{IO}}(i)\\right)$。\n\nD. 将CPU和IO优先级合并为一个单一的全局标量 $P(i) = P_{ext}^{\\mathrm{CPU}}(i) + P_{ext}^{\\mathrm{IO}}(i)$，在一个单一队列上运行一个统一的调度器，并让底层的资源管理器按该顺序对CPU和IO进行时间分片，而无需额外的反馈。\n\n选择最佳选项。", "solution": "此问题的核心在于两个资源（CPU和IO）之间的耦合关系，以及独立的调度策略如何导致系统不稳定。\n\n首先，我们分析系统的稳定性条件。对于任务 $i$，其IO请求到达率 $\\lambda^{\\mathrm{IO}}_i$ 与其CPU服务速率 $\\mu^{\\mathrm{CPU}}_i$ 成正比，即 $\\lambda^{\\mathrm{IO}}_i = \\alpha_i \\,\\mu^{\\mathrm{CPU}}_i$。为了使任务 $i$ 的IO队列保持稳定，其IO服务速率 $\\mu^{\\mathrm{IO}}_i$ 必须不小于其请求到达率。因此，稳定性条件为：\n$$ \\alpha_i \\,\\mu^{\\mathrm{CPU}}_i \\le \\mu^{\\mathrm{IO}}_i $$\n现在，我们分析初始场景下采用独立、按比例分配的调度策略时系统是否稳定。\nCPU服务速率根据外部CPU优先级按比例分配：\n- 总CPU优先级 = $P_{ext}^{\\mathrm{CPU}}(A) + P_{ext}^{\\mathrm{CPU}}(B) = 1 + 5 = 6$。\n- $\\mu^{\\mathrm{CPU}}_A = \\frac{1}{6}$，$\\mu^{\\mathrm{CPU}}_B = \\frac{5}{6}$。\n\nIO服务速率根据外部IO优先级按比例分配：\n- 总IO优先级 = $P_{ext}^{\\mathrm{IO}}(A) + P_{ext}^{\\mathrm{IO}}(B) = 5 + 1 = 6$。\n- $\\mu^{\\mathrm{IO}}_A = \\frac{5}{6}$，$\\mu^{\\mathrm{IO}}_B = \\frac{1}{6}$。\n\n接下来，我们检查每个任务的稳定性：\n- **对于任务A**：$\\alpha_A = 10$。我们需要检查 $10 \\times \\mu^{\\mathrm{CPU}}_A \\le \\mu^{\\mathrm{IO}}_A$ 是否成立。\n  $10 \\times \\frac{1}{6} \\le \\frac{5}{6} \\implies \\frac{10}{6} \\le \\frac{5}{6}$。此不等式为假。因此，任务A的IO队列是不稳定的，它产生IO请求的速率是其被服务速率的两倍。\n\n- **对于任务B**：$\\alpha_B = 0.1$。我们需要检查 $0.1 \\times \\mu^{\\mathrm{CPU}}_B \\le \\mu^{\\mathrm{IO}}_B$ 是否成立。\n  $0.1 \\times \\frac{5}{6} \\le \\frac{1}{6} \\implies \\frac{0.5}{6} \\le \\frac{1}{6}$。此不等式为真。任务B是稳定的。\n\n这个分析证实了初始设计会导致任务A的饥饿和系统不稳定。一个稳健的设计必须解决这种资源分配不匹配的问题。\n\n现在我们评估每个选项：\n\n**A**：此选项描述了最初的有缺陷的场景，并仅添加了老化机制。老化可以防止任务被无限期地忽视，但它不能解决根本的速率不匹配问题。为任务A提供更多的CPU时间只会使其更快地产生IO请求，从而加剧IO队列的积压。因此，该方法无法保证稳定性。\n\n**B**：此选项试图通过固定的、静态的系数来耦合优先级。其主要缺陷在于这些系数是固定的，无法适应任务动态变化的特性，特别是任务特定的转换因子 $\\alpha_i$。对于一组给定的任务和$\\alpha_i$值能够稳定系统的系数，对于另一组具有不同 $\\alpha_i$ 值的任务很可能会失效。因此，该方法不够稳健。\n\n**C**：此选项提出了一种动态、自适应的解决方案。通过建立一个跨调度器的反馈接口，调度器能够获取关键的运行时信息，如任务的转换因子 $\\alpha_i$ 和IO积压量。这使得调度器能够明确地以满足稳定性约束 $\\mu^{\\mathrm{IO}}_i \\ge \\alpha_i \\,\\mu^{\\mathrm{CPU}}_i$ 为目标来调整资源分配。它首先满足物理约束（稳定性），然后在可行范围内根据外部优先级策略进行优化。这种基于反馈和实时状态的协调机制是解决这类复杂耦合问题的最稳健方法。\n\n**D**：此选项通过简单地将不同资源的优先级相加来合并它们，这会丢失关键信息。在我们的例子中，$P(A) = 1 + 5 = 6$，$P(B) = 5 + 1 = 6$，使得调度器错误地认为两个任务同等重要。此外，它提出的固定时间分片方案对任务的实际资源需求（由 $\\alpha_i$ 决定）一无所知，无法适应任务的异构性，因此不能保证稳定性。\n\n综上所述，选项C是唯一能够通过动态协调和反馈来稳健地解决资源耦合和队列稳定性问题的设计。", "answer": "$$\\boxed{C}$$", "id": "3649895"}, {"introduction": "多级反馈队列（MLFQ）是现代操作系统中最普遍的调度算法之一，它巧妙地结合了外部和内部优先级。在这个终极实践中，您将不仅仅是进行计算或概念分析，而是要亲手构建一个离散时间模拟器。通过这个模拟器，您将能够观察到一个作业的生命周期：它的外部优先级决定了其初始队列，而其在队列中的升降则完全由其运行时行为（如时间片消耗和等待时间）这一内部动态决定。这项练习将加深您对MLFQ调度策略中优先级动态演化机制的理解。[@problem_id:3649868]", "problem": "您将为一个单处理器多级反馈队列调度器实现一个离散时间模拟器，该调度器具有外部和内部两种优先级。您将使用它来研究在对抗性到达情况下的稳定性和吞吐量。该模拟器必须遵循多级反馈队列的基本定义，将外部优先级视为一种接纳策略，而内部优先级则由运行时行为（如累积等待时间和已消耗的时间量）产生。\n\n用于您的推导和程序基础的定义与假设：\n- 多级反馈队列（MLFQ）有 $L$ 个不同的就绪队列，索引为 $0,1,\\dots,L-1$，其中索引 $0$ 表示最高优先级队列。每个级别 $k$ 都有一个以时间单位计量的时间量 $q_k$。处理器以离散时间单位执行，并从最高优先级的非空队列中选择一个作业，在该队列内部遵循先来先服务（First-Come First-Served）的原则。\n- 外部优先级 $P_{ext}$ 是一个在作业到达时确定的属性，它将作业映射到其初始队列级别。在作业的生命周期内，除非被内部策略升级或降级，否则该优先级不会改变。\n- 内部优先级 $P_{int}$ 不是调度器显式维护的数字；相反，它通过每个作业的内部状态来反映，例如其在就绪队列中的等待时间及其消耗的时间量，这些状态决定了降级和升级。\n- 降级发生在作业在其当前级别消耗完其时间量但未完成时；它会移动到下一个较低优先级的级别。\n- 升级通过老化机制发生以防止饥饿：一个在就绪队列中等待且连续 $W_{promote}$ 个时间单位未运行的作业将被提升一个级别，除非它已处于最高级别。\n- 作业具有到达时间 $a_i$、以时间单位计量的服务需求 $s_i$ 和外部频带 $b_i$。作业的初始队列级别仅由其到达时的外部频带决定；后续的升级和降级反映了内部优先级的动态变化。\n- 吞吐量定义为 $X = \\frac{C}{T_{max}}$，其中 $C$ 是在模拟时域 $T_{max}$ 内完成的作业总数。将 $X$ 表示为每时间单位的作业数，作为一个实数。\n- 稳定性通过就绪队列总积压的演变来评估。设 $Q(t)$ 表示在时间 $t$ 所有就绪队列中等待的作业总数（不包括当前正在运行的任何作业）。对于给定的测试用例，如果 $\\max_{0 \\le t  T_{max}} Q(t) \\le Q_{max}$ 且 $Q(T_{max}-1) \\le Q_{end}$，则声明系统稳定（$S=1$）；否则声明为不稳定（$S=0$）。\n\n需要实现的调度语义：\n- 时间以整数步长 $t = 0,1,2,\\dots,T_{max}-1$ 推进。\n- 在每个时间单位开始时，所有 $a_i = t$ 的作业到达，并根据其 $P_{ext}$ 频带进入其初始队列级别。\n- 在每个时间单位，在运行处理器之前应用升级：就绪队列中任何累积等待时间 $\\ge W_{promote}$ 的作业将被提升一个级别，其等待时间重置为 $0$。\n- 抢占策略：在一个时间单位开始时，如果一个作业当前正在运行，并且有任何作业位于更高优先级的就绪队列中，则立即抢占正在运行的作业，并将其返回到其当前队列的前端，以保留其剩余的时间片。\n- 执行：处理器每步运行一个时间单位。正在运行的作业的剩余服务需求 $s_i$ 及其剩余时间片在该时间单位内各减 $1$。如果 $s_i$ 达到 $0$，作业完成并离开系统；如果时间片达到 $0$ 而 $s_i>0$，则作业降级一个级别（除非已在最低级别），其新时间片设置为新级别的时间量，并在该级别队尾入队。\n- 等待时间核算：在当前时间单位内未运行的就绪队列中的每个作业，其等待时间增加 $1$；运行的作业将其等待时间设置为 $0$。\n\n所有测试用例的系统参数：\n- 级别数 $L = 3$。\n- 时间量向量 $\\mathbf{q} = [q_0,q_1,q_2] = [1,2,4]$ 时间单位。\n- 外部频带集 $\\{0,1,2\\}$，其中较低的频带索引代表较高的外部优先级，初始队列级别等于频带索引。\n- 升级阈值 $W_{promote} = 3$ 时间单位。\n\n对抗性到达和测试套件：\n实现三个测试用例，涵盖一般情况、突发性对抗情况和边界负载情况。对于每个用例，指定 $T_{max}$、到达时间 $a_i$、服务需求 $s_i$、频带 $b_i$ 以及稳定性阈值 $Q_{max}$ 和 $Q_{end}$。\n\n- 测试用例 1（一般“顺利路径”）：\n    - $T_{max} = 50$。\n    - 作业：$10$ 个作业，其 $(a_i,s_i,b_i)$ 分别为\n      $(0,4,0)$, $(3,4,1)$, $(6,4,2)$, $(9,4,0)$, $(12,4,1)$, $(15,4,2)$, $(18,4,0)$, $(21,4,1)$, $(24,4,2)$, $(27,4,0)$。\n    - 稳定性阈值：$Q_{max} = 10$, $Q_{end} = 2$。\n\n- 测试用例 2（对抗性突发）：\n    - $T_{max} = 60$。\n    - 作业：对于 $t \\in \\{0,5,10,15,20,25,30,35,40,45,50,55\\}$，有 $3$ 个作业到达，其 $(a_i,s_i,b_i) = (t,1,0)$；此外，有两个低优先级的长作业到达，其 $(a_i,s_i,b_i) = (0,20,2)$ 和 $(30,20,2)$。作业总数为 $36 + 2 = 38$。\n    - 稳定性阈值：$Q_{max} = 25$, $Q_{end} = 5$。\n\n- 测试用例 3（带有连续高优先级到达的边界负载）：\n    - $T_{max} = 40$。\n    - 作业：对于每个 $t \\in \\{0,1,2,\\dots,39\\}$，有一个作业到达，其 $(a_i,s_i,b_i) = (t,1,1)$；此外，在 $t=0$ 时有一个低优先级的长作业到达，其 $(a_i,s_i,b_i) = (0,40,2)$。作业总数为 $40 + 1 = 41$。\n    - 稳定性阈值：$Q_{max} = 30$, $Q_{end} = 10$。\n\n要求的输出：\n- 对于每个测试用例，计算吞吐量 $X$（作为每时间单位作业数的浮点数）和稳定性 $S$（作为整数 $0$ 或 $1$）。\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。该列表必须按 $[X_1,S_1,X_2,S_2,X_3,S_3]$ 的顺序排列，其中下标表示测试用例索引。\n\n除了时间单位外，没有其他物理单位，因此不需要转换。所有数值结果必须在指定的列表中以基本类型（浮点数和整数）返回，不带任何附加文本。确保您的模拟是自包含的、确定性的，并严格遵守上述调度语义。[@problem_id:451]", "solution": "要解决此问题，需要精确地实现所描述的多级反馈队列（MLFQ）调度器的离散时间模拟。模拟的核心是按照问题规定的严格顺序，在每个时间步 $t$ 从 $0$ 到 $T_{max}-1$ 推进系统状态。\n\n### 模拟逻辑\n\n以下是实现模拟器所需的关键步骤和数据结构：\n\n1.  **数据结构**：\n    *   **作业（Job）**：需要一个结构来表示每个作业，存储其ID、到达时间 $a_i$、总服务需求 $s_i$、剩余服务时间、当前队列级别、在当前级别的时间片中已消耗的时间，以及累积的等待时间。\n    *   **就绪队列**：一个包含 $L=3$ 个队列的数组。每个队列最好实现为先进先出（FIFO）数据结构（如链表或双端队列），以支持在队尾添加作业、从队首移除作业，以及将被抢占的作业重新插入队首。\n\n2.  **模拟主循环**：\n    循环遍历每个时间单位 $t = 0, 1, \\dots, T_{max}-1$。在每个时间步内，严格按照以下顺序执行操作：\n\n    a. **作业到达**：检查是否有作业在当前时间 $t$ 到达。将所有到达的作业根据其外部频带 $b_i$ 添加到相应就绪队列的末尾。\n\n    b. **升级（老化）**：遍历所有就绪队列中的作业（从级别 $L-1$ 到 $1$）。如果一个作业的累积等待时间达到或超过 $W_{promote}=3$，则将其移动到上一级队列（$k \\to k-1$）的末尾，并重置其等待时间。\n\n    c. **作业选择与抢占**：\n        *   确定最高优先级的非空队列。\n        *   如果当前有作业正在运行，并且新到达或升级的作业进入了比正在运行的作业更高的优先级队列，则发生抢占。被抢占的作业被放回其原队列的*前端*，保留其剩余的时间片。\n        *   如果处理器空闲（由于抢占、上一个作业完成或初始状态），则从最高优先级的非空队列的*前端*取出一个新作业来运行。\n\n    d. **执行**：\n        *   如果处理器上有作业正在运行，其剩余服务需求和在当前时间片内已用的时间都减1。其等待时间重置为0。\n        *   **完成**：如果作业的剩余服务需求降至0，则该作业完成。记录已完成作业总数，处理器变为空闲。\n        *   **降级**：如果作业未完成但用尽了当前级别的时间片（$q_k$），则将其移动到下一级队列（$k \\to k+1$）的末尾（如果已在最低级别，则留在原处）。\n\n    e. **状态更新**：\n        *   对于所有在就-绪队列中但未运行的作业，其等待时间计数器加1。\n        *   记录当前所有就绪队列中的作业总数 $Q(t)$，用于后续的稳定性分析。\n\n### 最终指标计算\n模拟结束后，根据收集的数据计算每个测试用例的吞吐量和稳定性：\n- **吞吐量 $X$** = (在 $T_{max}$ 内完成的作业总数) / $T_{max}$。\n- **稳定性 $S$**：如果模拟期间最大的 $Q(t)$ 不超过 $Q_{max}$ 且 $Q(T_{max}-1)$ 不超过 $Q_{end}$，则 $S=1$，否则 $S=0$。\n\n通过为每个测试用例运行此模拟，可以得到所需的六个数值。", "answer": "此问题的答案需要通过实现并运行问题描述中定义的模拟器来获得。正确的输出将是一个包含六个值的列表 `[X_1, S_1, X_2, S_2, X_3, S_3]`。由于无法在此处执行代码，因此未提供数值结果。", "id": "3649868"}]}