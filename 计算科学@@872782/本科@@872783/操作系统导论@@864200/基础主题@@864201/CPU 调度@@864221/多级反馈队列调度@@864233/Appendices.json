{"hands_on_practices": [{"introduction": "多级反馈队列（MLFQ）调度算法的核心在于平衡不同类型任务的需求。此练习将引导你探讨最高优先级队列中一个最基本的设计决策：时间片 $Q_{0}$ 的长度。你将学习如何量化吞吐量和响应时间这两个相互冲突的性能指标，并根据给定的延迟约束，通过计算找出最优的时间片大小，从而深入理解调度器设计中的权衡艺术。[@problem_id:3660269]", "problem": "一个单中央处理器（CPU）运行一个多级反馈队列（MLFQ）调度程序，其最高优先级队列对所有较低队列拥有严格优先级，并使用轮询（round-robin）方式对任务进行时间分片。最高优先级队列的时间量为 $Q_{0}$ 个时钟周期。调度程序的时钟周期频率为每秒 $f$ 个时钟周期，因此一个时钟周期持续 $1/f$ 秒。每当一个时间片结束且调度程序选择下一个任务时，系统会产生 $c$ 秒的上下文切换成本。假设由于有 $n$ 个始终就绪的交互式任务，最高优先级队列持续非空，并且严格优先级确保较低队列不会干扰最高优先级队列的计时。\n\n采纳以下定义和假设：\n- 吞吐量是指在最高优先级队列持续繁忙期间，用于有效任务执行（而非上下文切换）的时间的长期比例。\n- 对于一个最高优先级队列的交互式任务，其最坏情况响应时间是指在 $n$ 个最高优先级队列任务之间进行轮询轮转的情况下，从该任务变为就绪状态到其在最高优先级队列中下一次CPU服务开始之间的最大可能时间。\n\n给定 $f = 1000$ 时钟周期/秒，$c = 3.0 \\times 10^{-4}$ 秒，$n = 6$，以及一个交互式延迟要求 $T_{\\text{resp}} \\le X$，其中 $X = 2.0 \\times 10^{-2}$ 秒。请选择 $Q_{0}$ 以在满足最高优先级队列延迟约束的条件下最大化吞吐量。将最优的 $Q_{0}$ 报告为以时钟周期为单位的整数。最终答案必须是一个不带单位的数字。", "solution": "该问题要求解多级反馈队列（MLFQ）调度程序中最高优先级队列的最优时间量 $Q_0$。优化目标是在满足该队列中任务最坏情况响应时间约束的前提下，最大化吞吐量。$Q_0$ 必须是整数个时钟周期。\n\n首先，我们根据给定参数形式化调度程序的性能指标。给定参数如下：\n- 时钟周期频率，$f = 1000$ 周期/秒。\n- 上下文切换成本，$c = 3.0 \\times 10^{-4}$ 秒。\n- 最高优先级队列中始终就绪的任务数量，$n = 6$。\n- 允许的最大最坏情况响应时间，$X = 2.0 \\times 10^{-2}$ 秒。\n\n最高优先级队列的时间量是 $Q_0$ 个时钟周期。这个时间量以秒为单位的持续时间，记为 $T_Q$，由时钟周期数除以时钟周期频率得出：\n$$\nT_Q = \\frac{Q_0}{f}\n$$\n\n接下来，我们构建吞吐量的表达式。吞吐量，记为 $\\eta$，定义为 CPU 用于有效任务执行（而非上下文切换开销）的时间比例。在一个拥有非空队列的轮询系统中，CPU 重复执行一个持续时间为 $T_Q$ 的任务，然后进行一次持续时间为 $c$ 的上下文切换。这样一个任务“切片”及其后续上下文切换的总时间是 $T_Q + c$。这段时间中用于有效工作的比例是：\n$$\n\\eta = \\frac{T_Q}{T_Q + c}\n$$\n用 $Q_0$ 代入 $T_Q$ 的表达式：\n$$\n\\eta(Q_0) = \\frac{Q_0/f}{Q_0/f + c} = \\frac{Q_0}{Q_0 + fc}\n$$\n为了最大化吞吐量，我们分析 $\\eta$ 如何随 $Q_0$ 变化。我们可以考察 $\\eta$ 关于 $Q_0$ 的导数：\n$$\n\\frac{d\\eta}{dQ_0} = \\frac{(1)(Q_0 + fc) - Q_0(1)}{(Q_0 + fc)^2} = \\frac{fc}{(Q_0 + fc)^2}\n$$\n由于 $f  0$ 且 $c  0$，对于任何非负的 $Q_0$，导数 $\\frac{d\\eta}{dQ_0}$ 恒为正。这表明吞吐量 $\\eta(Q_0)$ 是 $Q_0$ 的单调递增函数。因此，为了最大化吞吐量，我们必须选择满足给定约束的 $Q_0$ 的最大可能值。\n\n现在，我们构建最坏情况响应时间 $T_{\\text{resp}}$ 的表达式。问题将其定义为从一个任务变为就绪到其下一次 CPU 服务开始之间的最大可能时间。对于最高优先级队列中的 $n=6$ 个始终就绪的任务，一个任务在其上一个时间量用尽的瞬间再次变为就绪。为了确定其下一次服务开始前的等待时间，我们必须考虑所有其他任务的执行以及相关的上下文切换。\n\n考虑一个任务 A，它刚刚完成了它的时间量。它在就绪队列中等待，而其他 $n-1$ 个任务被服务。在任务 A 再次运行之前，事件序列如下：\n1. 从任务 A 到队列中下一个任务的上下文切换。\n2. 下一个任务运行其时间量 $T_Q$。\n3. 这种（上下文切换，任务执行）的模式对所有其他 $n-1$ 个任务重复。\n4. 最后，发生一次上下文切换，将任务 A 重新调度回 CPU。任务 A 的服务只有在这次最后的上下文切换完成后才开始。\n\n这个等待期间的总持续时间包括了其他 $n-1$ 个任务的执行时间以及发生的所有上下文切换的时间。在一个完整的轮转中，$n$ 个任务中的每一个都有一次上下文切换。因此，总等待时间是 $(n-1)$ 个时间量和 $n$ 次上下文切换之和：\n$$\nT_{\\text{resp}} = (n-1)T_Q + nc\n$$\n代入 $T_Q = Q_0/f$：\n$$\nT_{\\text{resp}}(Q_0) = (n-1)\\frac{Q_0}{f} + nc\n$$\n问题施加了延迟约束：$T_{\\text{resp}} \\le X$。我们现在可以为 $Q_0$ 建立一个上界：\n$$\n(n-1)\\frac{Q_0}{f} + nc \\le X\n$$\n求解 $Q_0$：\n$$\n(n-1)\\frac{Q_0}{f} \\le X - nc\n$$\n$$\nQ_0 \\le \\frac{f(X - nc)}{n-1}\n$$\n由于我们的目标是最大化 $Q_0$，我们应该选择这个不等式允许的最大值。因为 $Q_0$ 必须是整数个时钟周期，最优值是右边表达式的向下取整。\n$$\nQ_{0, \\text{optimal}} = \\left\\lfloor \\frac{f(X - nc)}{n-1} \\right\\rfloor\n$$\n现在，我们代入给定的数值：\n- $f = 1000$\n- $c = 3.0 \\times 10^{-4}$\n- $n = 6$\n- $X = 2.0 \\times 10^{-2}$\n\n首先，计算 $nc$ 项：\n$$\nnc = 6 \\times (3.0 \\times 10^{-4}) = 18.0 \\times 10^{-4} = 0.0018 \\text{ 秒}\n$$\n接下来，计算分子 $f(X-nc)$：\n$$\nf(X - nc) = 1000 \\times (2.0 \\times 10^{-2} - 0.0018) = 1000 \\times (0.02 - 0.0018) = 1000 \\times 0.0182 = 18.2\n$$\n分母是 $n-1 = 6-1=5$。\n现在我们可以找到 $Q_0$ 的最大值：\n$$\nQ_0 \\le \\frac{18.2}{5} = 3.64\n$$\n由于 $Q_0$ 必须是整数个时钟周期，满足此约束的最大整数值为 $\\lfloor 3.64 \\rfloor$。\n$$\nQ_{0, \\text{optimal}} = 3\n$$\n因此，最高优先级队列的最优时间量是 $3$ 个时钟周期。这个值在确保最坏情况响应时间不超过指定限制的同时，最大化了吞吐量。", "answer": "$$\\boxed{3}$$", "id": "3660269"}, {"introduction": "理想情况下，调度器的优先级规则是不可撼动的，但现实世界中的任务交互（如锁竞争）会引发“优先级反转”这一棘手问题。本练习模拟了一个带有界限的优先级捐赠机制的复杂场景，一个低优先级任务持有高优先级任务所需的锁。通过分析此场景，你将揭示即使是精心设计的解决方案也可能存在缺陷，并理解为何健壮的并发控制对维持调度策略的有效性至关重要。[@problem_id:3660203]", "problem": "一个系统使用多级反馈队列（MLFQ）调度器，其属性基于抢占式优先级调度和时间分片的标准定义。系统中有 $3$ 个队列，$Q_0$（最高优先级）、$Q_1$ 和 $Q_2$（最低优先级）。策略是严格按队列级别抢占：任何在较高优先级队列中的就绪任务都会抢占较低优先级队列中的任务。在同一队列内，任务使用具有固定时间量子的轮询（RR）调度。时间量子分别为 $Q_0$ 的 $q_0 = 5\\,\\mathrm{ms}$，$Q_1$ 的 $q_1 = 10\\,\\mathrm{ms}$，以及 $Q_2$ 的 $q_2 = 20\\,\\mathrm{ms}$。假设系统为单中央处理器（CPU），且上下文切换开销可忽略不计（分析时假设为 $0$）。\n\n该系统采用基于快速用户空间互斥锁（futex）的锁，并支持跨 MLFQ 级别的优先级捐赠：如果 $Q_0$ 中的任务 $H$ 试图锁定一个由较低优先级队列中的任务 $L$ 持有的互斥锁，那么 $L$ 将临时继承提升至 $Q_0$ 的优先级。该捐赠是有界的：由于此捐赠，锁持有者 $L$ 在 $Q_0$ 级别运行时，被授予的累积 CPU 时间预算最多为 $W$。当 $H$ 阻塞时，捐赠在下一次调度决策时立即开始，并将 $L$ 放置在 $Q_0$ 队列的队首。预算 $W$ 仅在 $L$ 运行时减少（即，其他任务运行所经过的墙上时钟时间不会减少 $W$）。当 $L$ 释放互斥锁或耗尽其捐赠的 CPU 预算 $W$ 时，捐赠结束。对于每次连续的锁持有，最多只授予 $L$ 一个捐赠窗口（在锁被释放并重新获取之前，不会再次捐赠）。\n\n考虑以下基于这些定义的场景：\n- 在时间 $t = 0$ 时，任务 $L$ 位于 $Q_2$ 中并已持有互斥锁；其临界区剩余长度为 $C$ 个 CPU 时间单位（假设 $C$ 已知）。\n- 在时间 $t = 0$ 时，$Q_0$ 中的任务 $H$ 试图获取该互斥锁，并在由 $L$ 持有的 futex 上阻塞，从而触发了上述有界捐赠。\n- 在时间 $t = 0$ 时，$Q_0$ 中还存在一个不同的任务 $R$，该任务始终就绪（CPU 密集型），且与该互斥锁无关。任务 $R$ 始终保持就绪状态，永不阻塞。\n- 系统中没有其他任务。\n\n分析两组参数集：\n- 参数集 $\\mathcal{A}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 9\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n- 参数集 $\\mathcal{B}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 11\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n\n仅根据上述基本调度器定义，选择所有正确的陈述。\n\nA. 在参数集 $\\mathcal{A}$ 下，$H$ 进入其临界区的等待时间可能是无界的（即，墙上时钟延迟没有有限的上限），因为在 $L$ 耗尽其捐赠预算但仍持有锁之后，$Q_0$ 中的 $R$ 可以无限期地抢占 $Q_2$ 中的 $L$。\n\nB. 在参数集 $\\mathcal{B}$ 下，$H$ 将在 $t = 0$ 之后最多 $11\\,\\mathrm{ms}$ 的墙上时钟时间内进入其临界区。\n\nC. 在参数集 $\\mathcal{B}$ 下，且 $Q_0$ 中只有一个始终就绪的竞争者 $R$ 时，$L$ 释放锁所需的墙上时钟时间上限为 $2C$。\n\nD. 即使每次持有锁的捐赠窗口 $W$ 是有界的，一个恶意的 $Q_2$ 任务也可以通过反复重新获取锁并引发一系列 $Q_0$ 等待者，从而在很长一段时间内获得任意大比例的 CPU 时间，除非调度器同时对单位时间内累积的捐赠 CPU 强制设定上限。\n\nE. 无论 $C$ 的值以及 $Q_0$ 中是否存在始终就绪的任务，设置 $W = q_0$ 总是足以避免无界优先级反转。\n\n选择所有适用的选项。", "solution": "首先将验证问题陈述的科学合理性、完整性和客观性。\n\n### 步骤 1：提取已知条件\n问题描述了一个拥有单中央处理器（CPU）和多级反馈队列（MLFQ）调度器的计算机系统。明确的已知条件如下：\n-   **队列**：定义了一个包含 $3$ 个队列的系统：$Q_0$（最高优先级）、$Q_1$ 和 $Q_2$（最低优先级）。\n-   **队列间调度**：抢占式优先级调度，其中较高优先级队列中的就绪任务会抢占任何在较低优先级队列中运行的任务。\n-   **队列内调度**：轮询（RR），每个队列有固定的时间量子。\n-   **时间量子**：$Q_0$ 为 $q_0 = 5\\,\\mathrm{ms}$，$Q_1$ 为 $q_1 = 10\\,\\mathrm{ms}$，$Q_2$ 为 $q_2 = 20\\,\\mathrm{ms}$。\n-   **系统模型**：假设为单 CPU，且为分析目的，上下文切换开销被视为 $0$。\n-   **优先级捐赠机制**：\n    -   一个较高优先级队列中的任务 $H$ 在一个由较低优先级队列中的任务 $L$ 持有的互斥锁上阻塞，会导致 $L$ 被临时提升到 $H$ 的优先级（即，在此场景中提升到队列 $Q_0$）。\n    -   该提升受 CPU 时间预算 $W$ 的限制。此预算 $W$ 仅在 $L$ 正在 CPU 上活动运行时才减少。\n    -   捐赠在 $H$ 阻塞后的下一次调度决策时开始，并将 $L$ 放置在 $Q_0$ 就绪队列的队首。\n    -   如果 $L$ 释放了互斥锁，或者其捐赠的预算 $W$ 被耗尽，捐赠就会结束。\n    -   每次连续的锁持有只授予一个捐赠窗口。\n-   **初始场景 ($t=0$)**：\n    -   任务 $L$ 位于 $Q_2$ 中，持有一个互斥锁，其临界区剩余需要 $C$ 单位的 CPU 时间。\n    -   任务 $H$ 位于 $Q_0$ 中并试图获取同一个互斥锁，导致其阻塞并触发对 $L$ 的捐赠。\n    -   任务 $R$ 位于 $Q_0$ 中且始终就绪运行（CPU 密集型）；它与互斥锁无关。\n    -   系统中没有其他任务。\n-   **参数集**：\n    -   集 $\\mathcal{A}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 9\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n    -   集 $\\mathcal{B}$：$q_0 = 5\\,\\mathrm{ms}$，$W = 11\\,\\mathrm{ms}$，$C = 11\\,\\mathrm{ms}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据标准有效性准则对问题陈述进行评估。\n-   **科学依据**：所提出的概念——MLFQ、抢占式优先级调度、轮询、优先级反转和优先级继承（此处通过 futex 机制指定为有界的“优先级捐赠”）——是操作系统研究中的基础和标准主题。该模型虽然经过简化（例如，$0$ 上下文切换成本），但在科学和逻辑上与其描述的原理一致。\n-   **适定性**：该问题是适定的。系统的初始状态有明确定义，控制状态转换的规则（调度、抢占、捐赠）是明确的，并且提出的问题是具体和确定性的。可以从前提中推导出一个唯一的事件序列。\n-   **客观性**：语言是技术性的、精确的，并且没有主观或含糊的术语。\n-   **缺陷审查**：\n    1.  **科学上不合理**：无。该模型是调度问题的标准表示。\n    2.  **不相关**：无。该主题的核心是操作系统调度。\n    3.  **不完整/矛盾**：无。规则足以模拟系统的行为。例如，明确说明了 $Q_0$ 内部的平局打破规则（将被捐赠的任务 $L$ 放在队首）。\n    4.  **不切实际的条件**：零上下文切换开销的假设是理论分析中常见且可接受的简化。参数值对于这类问题是合理的。\n    5.  **结构不良**：无。问题结构是逻辑的，并能导向唯一解。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。可以进行详细分析。\n\n### 推导与分析\n\n问题的核心是在轮询策略下，追踪队列 $Q_0$ 中任务 $L$ 和 $R$ 的执行情况，同时跟踪任务 $L$ 的剩余临界区时间 $C$ 和捐赠的时间预算 $W$。\n\n**参数集 $\\mathcal{A}$ 的分析 ($q_0 = 5\\,\\mathrm{ms}$, $W = 9\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\n在 $t=0$ 时，任务 $H$（在 $Q_0$ 中）在由任务 $L$（在 $Q_2$ 中）持有的互斥锁上阻塞。这触发了优先级捐赠。$L$ 被提升到 $Q_0$ 并被放置在就绪队列的队首。$Q_0$ 就绪队列为 $(L, R)$。状态为：$C_{rem} = 11\\,\\mathrm{ms}$，$W_{rem} = 9\\,\\mathrm{ms}$。\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**：任务 $L$ 运行，因为它在 $Q_0$ 队列的队首。它运行其完整的时间量子，$q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem}$ 变为 $11 - 5 = 6\\,\\mathrm{ms}$。\n    -   $W_{rem}$ 变为 $9 - 5 = 4\\,\\mathrm{ms}$。\n    -   在 $t=5\\,\\mathrm{ms}$ 时，$L$ 被抢占并移到 $Q_0$ 队列的队尾。现在队列为 $(R, L)$。\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**：任务 $R$ 运行其时间量子，$q_0 = 5\\,\\mathrm{ms}$。\n    -   在 $t=10\\,\\mathrm{ms}$ 时，$R$ 被抢占并移到队尾。现在队列为 $(L, R)$。\n\n3.  **$t = [10, 14)\\,\\mathrm{ms}$**：任务 $L$ 再次运行。它需要 $C_{rem} = 6\\,\\mathrm{ms}$ 来完成其临界区，但其剩余的捐赠预算只有 $W_{rem} = 4\\,\\mathrm{ms}$。它也受到时间量子 $q_0 = 5\\,\\mathrm{ms}$ 的限制。它将运行 $\\min(q_0, C_{rem}, W_{rem}) = \\min(5, 6, 4) = 4\\,\\mathrm{ms}$。\n    -   $L$ 运行 $4\\,\\mathrm{ms}$。\n    -   $C_{rem}$ 变为 $6 - 4 = 2\\,\\mathrm{ms}$。\n    -   $W_{rem}$ 变为 $4 - 4 = 0\\,\\mathrm{ms}$。\n\n4.  **在 $t=14\\,\\mathrm{ms}$ 时**：任务 $L$ 耗尽其捐赠的预算 $W$。捐赠结束。$L$ 立即被降级回其原始队列 $Q_2$。关键的是，$L$ 尚未完成其临界区（$C_{rem} = 2\\,\\mathrm{ms}$）并且仍持有互斥锁。\n\n5.  **对于 $t \\geq 14\\,\\mathrm{ms}$**：就绪队列为 $Q_0: (R)$，$Q_1: (\\text{空})$，$Q_2: (L)$。任务 $H$ 仍然阻塞。由于任务 $R$ 在 $Q_0$ 中且被定义为“始终就绪”，它将被持续调度。调度器永远不会从像 $Q_2$ 这样的较低优先级队列中选择任务。因此，$L$ 发生饿死，永远无法运行以完成其剩余的 $2\\,\\mathrm{ms}$ 临界区工作。它将永远不会释放互斥锁。这导致任务 $H$ 的等待时间无界。\n\n**参数集 $\\mathcal{B}$ 的分析 ($q_0 = 5\\,\\mathrm{ms}$, $W = 11\\,\\mathrm{ms}$, $C = 11\\,\\mathrm{ms}$)**\n\n在 $t=0$ 时，设置相同。$Q_0$ 就绪队列为 $(L, R)$。状态为：$C_{rem} = 11\\,\\mathrm{ms}$，$W_{rem} = 11\\,\\mathrm{ms}$。关键区别在于 $W=C$。\n\n1.  **$t = [0, 5)\\,\\mathrm{ms}$**：任务 $L$ 运行 $q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$。\n    -   $W_{rem} = 11 - 5 = 6\\,\\mathrm{ms}$。\n    -   在 $t=5\\,\\mathrm{ms}$ 时，队列变为 $(R, L)$。\n\n2.  **$t = [5, 10)\\,\\mathrm{ms}$**：任务 $R$ 运行 $q_0 = 5\\,\\mathrm{ms}$。\n    -   在 $t=10\\,\\mathrm{ms}$ 时，队列变为 $(L, R)$。\n\n3.  **$t = [10, 15)\\,\\mathrm{ms}$**：任务 $L$ 运行 $q_0 = 5\\,\\mathrm{ms}$。\n    -   $C_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$。\n    -   $W_{rem} = 6 - 5 = 1\\,\\mathrm{ms}$。\n    -   在 $t=15\\,\\mathrm{ms}$ 时，队列变为 $(R, L)$。\n\n4.  **$t = [15, 20)\\,\\mathrm{ms}$**：任务 $R$ 运行 $q_0 = 5\\,\\mathrm{ms}$。\n    -   在 $t=20\\,\\mathrm{ms}$ 时，队列变为 $(L, R)$。\n\n5.  **$t = [20, 21)\\,\\mathrm{ms}$**：任务 $L$ 运行。它只需 $C_{rem} = 1\\,\\mathrm{ms}$ 即可完成。它还剩下 $W_{rem} = 1\\,\\mathrm{ms}$ 的预算。\n    -   $L$ 运行 $1\\,\\mathrm{ms}$。\n    -   $C_{rem} = 1 - 1 = 0\\,\\mathrm{ms}$。\n    -   $W_{rem}$ 变为 $1 - 1 = 0\\,\\mathrm{ms}$。\n\n6.  **在 $t=21\\,\\mathrm{ms}$ 时**：任务 $L$ 完成其临界区并释放互斥锁。任务 $H$ 解除阻塞，在 $Q_0$ 中变为就绪状态，现在可以被调度。$H$ 进入其临界区的等待时间为 $21\\,\\mathrm{ms}$。\n\n### 逐项分析\n\n**A. 在参数集 $\\mathcal{A}$ 下，$H$ 进入其临界区的等待时间可能是无界的（即，墙上时钟延迟没有有限的上限），因为在 $L$ 耗尽其捐赠预算但仍持有锁之后，$Q_0$ 中的 $R$ 可以无限期地抢占 $Q_2$ 中的 $L$。**\n这个陈述与参数集 $\\mathcal{A}$ 的分析结果完全匹配。捐赠的预算 $W=9\\,\\mathrm{ms}$ 不足以让 $L$ 在与 $R$ 竞争的同时完成其 $C=11\\,\\mathrm{ms}$ 的临界区。$L$ 在临界区执行中途被降级，随后被高优先级任务 $R$ 饿死，导致一个类似死锁的情况，即 $H$ 无限期等待。这是一个典型的优先级反转管理不善的例子。\n**结论：正确。**\n\n**B. 在参数集 $\\mathcal{B}$ 下，$H$ 将在 $t = 0$ 之后最多 $11\\,\\mathrm{ms}$ 的墙上时钟时间内进入其临界区。**\n对参数集 $\\mathcal{B}$ 的详细分析表明，由于与任务 $R$ 的交错执行，任务 $L$ 需要 $21\\,\\mathrm{ms}$ 的墙上时钟时间来完成其临界区。因此，$H$ 的等待时间为 $21\\,\\mathrm{ms}$。由于 $21\\,\\mathrm{ms}$ 并不小于或等于 $11\\,\\mathrm{ms}$，所以该陈述是错误的。\n**结论：错误。**\n\n**C. 在参数集 $\\mathcal{B}$ 下，且 $Q_0$ 中只有一个始终就绪的竞争者 $R$ 时，$L$ 释放锁所需的墙上时钟时间上限为 $2C$。**\n这个陈述概括了从集 $\\mathcal{B}$ 中得出的观察结果。要完成长度为 $C$ 的临界区，任务 $L$ 需要总共运行 $C$ 的 CPU 时间。在时间量子为 $q_0$ 的情况下，这需要在 $Q_0$ 的轮询调度中进行 $N_L = \\lceil C/q_0 \\rceil$ 次单独的运行。在 $L$ 的前 $N_L - 1$ 次运行之间，任务 $R$ 将每次都运行一个完整的时间量子 $q_0$。\n总墙上时钟时间 $T_{wall}$ 是 $L$ 运行的时间（$C$）和 $R$ 运行的时间之和。\n$T_{wall} = C + (N_L - 1)q_0 = C + (\\lceil C/q_0 \\rceil - 1)q_0$。\n要验证边界 $T_{wall} \\leq 2C$，我们必须检查 $C + (\\lceil C/q_0 \\rceil - 1)q_0 \\leq 2C$ 是否成立，这可以简化为 $(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$。\n根据向上取整函数的定义，我们知道 $\\lceil x \\rceil  x + 1$。令 $x = C/q_0$。\n那么 $(\\lceil C/q_0 \\rceil - 1)  (C/q_0 + 1 - 1) = C/q_0$。\n两边乘以 $q_0$ 得到 $(\\lceil C/q_0 \\rceil - 1)q_0  C$。因此，严格不等式成立。如果 $C$ 是 $q_0$ 的整数倍，$C = k \\cdot q_0$，那么 $\\lceil C/q_0 \\rceil = k$，表达式变为 $(k-1)q_0$，这小于 $C = k \\cdot q_0$（对于 $k>1$）。不等式 $(\\lceil C/q_0 \\rceil - 1)q_0 \\leq C$ 总是成立的。这意味着 $T_{wall} \\leq 2C$。\n对于参数集 $\\mathcal{B}$，$C=11\\,\\mathrm{ms}$ 且 $q_0=5\\,\\mathrm{ms}$。$T_{wall} = 11 + (\\lceil 11/5 \\rceil - 1) \\times 5 = 11 + (3 - 1) \\times 5 = 11 + 10 = 21\\,\\mathrm{ms}$。边界 $2C$ 是 $2 \\times 11 = 22\\,\\mathrm{ms}$。$21\\,\\mathrm{ms} \\leq 22\\,\\mathrm{ms}$，所以边界成立。只要避免了无界反转，该分析就有效，这对集 $\\mathcal{B}$ 来说是成立的，因为 $W \\geq C$。\n**结论：正确。**\n\n**D. 即使每次持有锁的捐赠窗口 $W$ 是有界的，一个恶意的 $Q_2$ 任务也可以通过反复重新获取锁并引发一系列 $Q_0$ 等待者，从而在很长一段时间内获得任意大比例的 CPU 时间，除非调度器同时对单位时间内累积的捐赠 CPU 强制设定上限。**\n所描述的捐赠策略限制了*每次获取锁*所授予的 CPU 时间。它没有对任务在较长时间内可以接收的总捐赠时间施加任何限制。一个恶意任务可以重复执行一个循环：(1) 获取锁，(2) 让一个高优先级任务在其上阻塞，(3) 在高优先级下接收并使用 $W$ 预算，(4) 释放锁，以及 (5) 重复。如果这个循环可以快速执行，恶意任务实际上可以在相当大一部分时间内以高优先级运行，从而绕过 MLFQ 的意图。该陈述正确地指出了这个漏洞，并指出了需要进一步的机制，例如对捐赠设置速率限制，以防止此类滥用。\n**结论：正确。**\n\n**E. 无论 $C$ 的值以及 $Q_0$ 中是否存在始终就绪的任务，设置 $W = q_0$ 总是足以避免无界优先级反转。**\n这个陈述提出了一个很强的一般性主张。要反驳它，一个反例就足够了。让我们使用问题中带有 $Q_0$ 中始终就绪的竞争者 $R$ 的场景。\n设置 $W = q_0 = 5\\,\\mathrm{ms}$。让临界区比时间量子长，例如，$C = 6\\,\\mathrm{ms}$。\n-   $t=0$：$L$ 被提升到 $Q_0$。$W_{rem}=5, C_{rem}=6$。\n-   $t = [0, 5)\\,\\mathrm{ms}$：$L$ 运行 $5\\,\\mathrm{ms}$。它耗尽了全部预算 $W$。\n-   在 $t=5\\,\\mathrm{ms}$ 时：$W_{rem}=0$，捐赠结束。$L$ 被降级到 $Q_2$。然而，它的临界区尚未完成，因为 $C_{rem}=1\\,\\mathrm{ms}$。\n-   对于 $t \\geq 5\\,\\mathrm{ms}$：$L$ 在持有锁的同时位于 $Q_2$，而始终就绪的任务 $R$ 位于 $Q_0$。$R$ 将持续抢占 $L$，导致无界优先级反转。\n因此，如果 $C > W$，设置 $W=q_0$ 是不够的。该陈述声称“无论 $C$ 的值如何”都有效是错误的。\n**结论：错误。**", "answer": "$$\\boxed{ACD}$$", "id": "3660203"}, {"introduction": "任何调度算法都可能被“聪明”的进程利用其规则漏洞，即“钻调度器的空子”。本练习聚焦于 MLFQ 调度器中一个经典的滥用场景：一个 CPU 密集型任务通过在时间片耗尽前主动放弃 CPU 来伪装成交互式任务，从而长期霸占高优先级队列。你将评估多种对抗此行为的策略，并最终发现一种既高效又公平的解决方案，这有助于你理解为何现代操作系统需要更复杂的机制来保证公平性和防止滥用。[@problem_id:3660276]", "problem": "一个操作系统使用带有多个优先级队列的多级反馈队列（MLFQ）调度器。最高优先级队列的时间片为 $q$ 毫秒。根据设计，一个用满其全部时间片 $q$ 的进程会被降级到较低优先级的队列，而一个在用满 $q$ 之前主动放弃处理器的进程则会保留在最高优先级队列中。MLFQ的目标是优先服务交互式任务，同时让长时间运行的中央处理器（CPU）密集型任务的优先级随时间逐渐降低。考虑一个进程 $P$，它在每次被分派时都在 $q - \\varepsilon$ 时刻（对于某个小的 $\\varepsilon \\in (0, q)$）故意放弃处理器以避免被降级，但它非常频繁地重复此行为，在墙上时钟时间内消耗了大部分的CPU时间。为了对抗这种投机行为，同时为真正的交互式任务保持MLFQ的响应能力，调度器设计者提议跟踪一个反映近期CPU消耗的、每个进程独有的CPU“信用” $C$，并在 $C$ 超过阈值 $\\kappa$ 时将进程降级，即使该进程在消耗完整个时间片之前频繁放弃处理器。\n\n已知以下基本事实与定义：\n- MLFQ通过根据观察到的近期行为（而非生命周期行为）调整优先级来模拟最短作业优先的偏向，以实现交互式任务的低响应时间。\n- 任何仅基于“进程是否消耗了完整时间片”的降级机制都可能被主动放弃行为所利用；因此，降级决策必须与近期的墙上时钟时间内的CPU使用率相关，并且不能因主动放弃而被重置。\n- 操作系统必须实现该规则，其每个进程的状态和更新成本在每个时钟滴答和每次调度事件上都必须限制在 $O(1)$ 内，且与任何可调的窗口长度参数无关。\n- 交互式任务的特点是短暂、不频繁的CPU突发，其间穿插着输入/输出（I/O）等待；CPU密集型任务在近期表现为持续的CPU使用，很少或没有I/O等待。\n\n假设 $q = 10$ 毫秒，且进程 $P$ 在每次分派时都在 $q - 1 = 9$ 毫秒时放弃处理器，并频繁重复此行为。假设设计者想要一个策略，对于约 $W = 200$ 毫秒的可调“近期性尺度”和 $\\kappa = 60$ 毫秒的阈值，该策略能够将进程 $P$ 降级（尽管它频繁放弃处理器），同时又不会降级一个每 $200$ 毫秒使用约 $5$ 毫秒CPU时间的真正交互式任务。\n\n以下哪个关于定义和操作 $C$ 的候选规则最能实现所述目标和约束？\n\nA. 将 $C$ 定义为进程自创建以来使用的累积CPU时间。一旦 $C  \\kappa$ 就立即降级；$C$ 永远不会减少，也永远不会被重置。\n\nB. 将 $C$ 定义为最近一个 $W$ 毫秒的滑动窗口墙上时钟时间内使用的总CPU时间，在每一毫秒都通过移动窗口精确更新。当 $C  \\kappa$ 时降级；仅允许通过系统的定期全局优先级提升来重新升级。\n\nC. 将 $C$ 定义为自上次分派以来使用的CPU时间。每次主动放弃时将 $C$ 重置为 $0$。当且仅当在抢占或放弃时 $C \\ge \\kappa$ 才降级。\n\nD. 将 $C$ 定义为最近 $W$ 毫秒内主动放弃的次数。当该计数超过一个固定阈值时降级，理由是频繁放弃表明存在投机行为。\n\nE. 将 $C$ 定义为近期CPU使用量相对于墙上时钟时间的指数加权移动平均（EWMA）：在每个长度为 $\\tau$ 的调度器时钟滴答，更新 $C \\leftarrow \\lambda C + (1 - \\lambda) U$，其中 $U \\in \\{0, 1\\}$ 表示进程在上一个时钟滴答内是否使用了CPU，且 $\\lambda \\approx e^{-\\tau / W}$。当 $C \\cdot W  \\kappa$ 时降级，并在 $C \\cdot W$ 衰减到 $\\kappa$ 以下时允许升级，无论进程是放弃处理器还是睡眠；睡眠导致 $U = 0$，因此 $C$ 在I/O等待期间会衰减。\n\n在给定的目标和约束下选择最佳选项。提供一个植根于MLFQ基本原则和所述实现约束的简要理由。可能存在不止一个看似合理的规则，但请选择满足所有约束并在所述数值场景中实现预期行为的那个。", "solution": "在进行求解之前，首先分析问题陈述的有效性。\n\n### 步骤1：提取已知条件\n- **调度器类型**：多级反馈队列（MLFQ）。\n- **最高优先级队列时间片**：$q$ 毫秒。\n- **标准降级规则**：如果一个进程用满了其完整的时间片 $q$，则被降级。\n- **标准保留规则**：如果一个进程在用满时间片 $q$ 之前放弃处理器，则它保持在其优先级。\n- **目标**：优先服务交互式任务；让CPU密集型任务的优先级逐渐降低。\n- **待解决的问题**：一个进程 $P$ 通过重复使用接近完整的时间片（$q - \\varepsilon$）然后放弃处理器来“欺骗”调度器以避免降级，从而垄断CPU。这里 $\\varepsilon$ 是一个小的正时间，$\\varepsilon \\in (0, q)$。\n- **提议的解决方案框架**：引入一个CPU“信用”指标 $C$。如果 $C$ 超过阈值 $\\kappa$，则将进程降级，无论其是否完成了完整的时间片。\n- **基本原则与约束**：\n    1.  调度器必须基于*近期*行为而非生命周期行为进行调整。\n    2.  降级规则必须基于近期的墙上时钟时间内的CPU使用情况，并且*不能*因主动放弃而被重置。\n    3.  实现的计算成本在每个时钟滴答和每次调度事件上必须为 $O(1)$，存储和计算成本与任何可调的窗口长度参数无关。\n    4.  交互式任务的定义是短暂、不频繁的CPU突发。CPU密集型任务则表现为持续的CPU使用。\n- **数值场景**：\n    - 时间片 $q = 10$ 毫秒。\n    - 投机进程 $P$ 在 $t = q - 1 = 9$ 毫秒时放弃处理器。\n    - 可调“近期性尺度”：$W = 200$ 毫秒。\n    - CPU使用阈值：$\\kappa = 60$ 毫秒。\n    - 一个真正的交互式任务每 $200$ 毫秒使用约 $5$ 毫秒的CPU，不应被降级。\n\n### 步骤2：使用提取的已知条件进行验证\n问题陈述在科学上是基于操作系统调度算法这一成熟领域的，特别是MLFQ。所描述的“投机”场景是朴素MLFQ实现的一个已知弱点。所提供的约束，如 $O(1)$ 的更新成本，是操作系统内核设计中现实且关键的考虑因素。该问题提取得当，提供了明确的目标（降级投机者，保护交互式任务）、用于测试案例的明确数值参数以及一组可供评估的不同算法选项。语言客观且技术性强。该问题不违反任何无效性标准。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将通过对照所述目标和约束来评估每个选项，从而推导出解决方案。\n\n### 解题推导与选项分析\n\n一个成功规则的核心要求是：\n1.  **对抗投机的有效性**：它必须能降级进程 $P$，该进程频繁使用 $9$ 毫秒的CPU，以至于在 $200$ 毫秒的墙上时钟周期内累积使用超过 $60$ 毫秒。\n2.  **保护交互性**：它**不能**降级一个在 $200$ 毫秒周期内仅使用 $5$ 毫秒CPU的任务。\n3.  **遵守原则**：该指标必须反映*近期*的CPU使用情况，并且不能因主动放弃而被重置。\n4.  **性能约束**：更新机制的时间和空间复杂度必须为 $O(1)$，且与窗口大小 $W$ 无关。\n\n**选项A分析：**\n- **规则**：$C$ 是自进程创建以来的累积CPU时间。当 $C  \\kappa$ 时降级。\n- **评估**：这个规则最终会在投机进程 $P$ 的总CPU使用量超过 $\\kappa = 60$ 毫秒时将其降级。然而，它也会降级任何长时间运行的交互式任务。一个每 $200$ 毫秒使用 $5$ 毫秒CPU的交互式进程，在经过 $13$ 次这样的突发后（在 $2.6$ 秒内总共使用 $65$ 毫秒CPU），将被降级，即使其近期行为是完全交互式的。这违反了MLFQ应适应*近期*行为而非生命周期历史的基本原则。\n- **结论**：**不正确**。\n\n**选项B分析：**\n- **规则**：$C$ 是最近一个 $W = 200$ 毫秒的墙上时钟时间滑动窗口内使用的CPU时间总和。当 $C  \\kappa$ 时降级。\n- **评估**：这个规则在概念上是理想的。对于投机进程 $P$，如果在任何 $200$ 毫秒的时间间隔内消耗超过 $60$ 毫秒的CPU，它将被降级。对于交互式进程，它在任何 $200$ 毫秒窗口内的使用量约为 $5$ 毫秒，小于 $\\kappa = 60$ 毫秒，因此不会被降级。这满足了行为目标。然而，实现约束是“在每一毫秒都通过移动窗口精确更新”。这将需要存储过去 $200$ 毫秒中每一毫秒的使用情况，例如，在一个大小为 $200$ 的循环缓冲区中。这个数据结构的内存需求是 $O(W)$。这违反了实现成本必须与可调参数 $W$ 无关的严格约束。\n- **结论**：**不正确**。\n\n**选项C分析：**\n- **规则**：$C$ 是自上次分派以来使用的CPU时间，每次主动放弃时重置为 $0$。如果 $C \\ge \\kappa$ 则降级。\n- **评估**：这个规则有根本性缺陷。投机进程 $P$ 运行 $9$ 毫秒然后主动放弃。在放弃的那一刻，它当前的CPU使用量是 $C = 9$ 毫秒。由于 $9  \\kappa = 60$，它不会被降级。然后规则将 $C$ 重置为 $0$。这个机制正是该进程所利用的。该规则明确允许投机行为成功，并直接与“降级决策不能因放弃而被重置”的要求相矛盾。\n- **结论**：**不正确**。\n\n**选项D分析：**\n- **规则**：$C$ 是最近 $W$ 毫秒内主动放弃的次数。如果计数超过阈值则降级。\n- **评估**：这个规则试图通过惩罚一个症状（频繁放弃）而不是根本原因（高CPU消耗）来解决问题。虽然它可能会降级进程 $P$，但这是一个脆弱的启发式方法。首先，它混淆了主动放弃（例如 `sched_yield`）和为I/O阻塞，而后者是真正的交互式进程所做的。如果I/O阻塞被算作放弃，交互式进程将受到不公平的惩罚。如果不算，投机进程可以轻易地通过执行一个微不足道的、快速的I/O操作来代替放弃，从而对这个规则来说显得是交互式的。最重要的是，这个规则未能满足“降级决策必须与近期的墙上时钟时间内的CPU使用率相关”的指定要求。\n- **结论**：**不正确**。\n\n**选项E分析：**\n- **规则**：$C$ 是CPU使用的指数加权移动平均（EWMA）。在每个时钟滴答 $\\tau$ 更新：$C \\leftarrow \\lambda C + (1 - \\lambda) U$，其中 $U \\in \\{0, 1\\}$ 表示进程在该时钟滴答内是否使用了CPU，且 $\\lambda \\approx e^{-\\tau / W}$。当 $C \\cdot W  \\kappa$ 时降级。\n- **评估**：\n    - **性能约束**：每次更新需要一次乘法和一次加法，这是 $O(1)$ 的计算量。每个进程所需的状态是一个浮点数 $C$，这是 $O(1)$ 的空间。两者都与 $W$ 无关。这满足了性能约束。\n    - **遵守原则**：放弃处理器不会重置 $C$；它仅仅结束了该进程 $U=1$ 的时期。根据其移动平均的定义，$C$ 跟踪了近期的CPU使用情况。当一个进程因I/O而睡眠时，$U=0$，导致 $C$ 指数级衰减。这正确地模拟了交互式任务的行为，并允许被降级的进程在行为改变后再次被提升。\n    - **有效性**：项 $C$ 近似于进程在近期运行的时间比例。降级条件 $C \\cdot W  \\kappa$ 将估计的近期CPU使用量（时间窗口 $W$ 的比例 $C$）与阈值 $\\kappa$ 进行比较。\n        - **投机进程 $P$**：该进程具有高占空比。如果它在每（比如说）$15$ 毫秒内使用CPU $9$ 毫秒，其占空比为 $9/15 = 0.6$。EWMA $C$ 将收敛到约 $0.6$。检查变为 $C \\cdot W \\approx 0.6 \\cdot 200 = 120$ 毫秒。由于 $120  \\kappa = 60$，该进程被正确降级。\n        - **交互式进程**：该进程每 $200$ 毫秒使用CPU $5$ 毫秒。其占空比为 $5/200 = 0.025$。其EWMA $C$ 将收敛到约 $0.025$。检查变为 $C \\cdot W \\approx 0.025 \\cdot 200 = 5$ 毫秒。由于 $5  \\kappa = 60$，该进程被正确地保护而不被降级。\n    - EWMA 是一种标准的、计算效率高的技术，用于近似滑动窗口平均值（如选项B中那样），同时满足严格的 $O(1)$ 复杂度约束。它满足所有要求。\n- **结论**：**正确**。", "answer": "$$\\boxed{E}$$", "id": "3660276"}]}