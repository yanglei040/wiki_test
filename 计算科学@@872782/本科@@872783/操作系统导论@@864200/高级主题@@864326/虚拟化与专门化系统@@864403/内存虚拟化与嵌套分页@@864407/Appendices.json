{"hands_on_practices": [{"introduction": "要真正掌握嵌套分页，没有什么比亲手完成一次完整的地址转换更能加深理解了。本练习将引导您完成从客户机虚拟地址到客户机物理地址，最终到宿主机物理地址的两阶段翻译过程。通过手动追踪分页表遍历并验证每一步的权限，您将为CPU在虚拟化环境中处理内存访问的方式建立一个具体的心理模型 [@problem_id:3657979]。", "problem": "一个 $32$ 位客户机在启用物理地址扩展 (PAE) 和 No-Execute (NX) 支持的情况下，以监管模式运行。该客户机尝试向客户机线性地址 $0x\\mathrm{E5412345}$ 写入一个字节。虚拟机监控程序 (hypervisor) 使用 Intel 扩展页表 (EPT) 进行嵌套分页。假设索引提取和权限遵循标准的 PAE 语义，索引提取和权限也遵循标准的 EPT 语义，包括支持混合页面大小。\n\n客户机分页结构 (PAE):\n- 索引为 $3$ 的页目录指针表项 (PDPTE) 存在，并指向一个页目录，该页目录的页目录项 (PDE) 均有效。您可以假设 PDPTE 的权限不会在下面描述的 PDE 所隐含的权限之外，进一步限制监管模式的写入操作。\n- 在所引用的页目录中，索引为 $0x\\mathrm{12A}$ 的页目录项被标记为存在，读/写已启用，用户/监管位指示仅限监管模式访问，并且页大小位已设置（它映射一个 $2\\,\\text{MiB}$ 的页面）。此 PDE 中的 No-Execute 位被清除。此 PDE 映射一个客户机物理 $2\\,\\text{MiB}$ 帧，其基客户机物理地址为 $0x\\mathrm{01A00000}$。\n\nEPT 结构:\n- 索引为 $0$ 的 EPT 页映射级别 $4$ (PML4) 表项是可读/可写/可执行的，并指向一个有效的 EPT 页目录指针表 (PDPT)。\n- 索引为 $0$ 的 EPT PDPT 表项是可读/可写/可执行的，并指向一个有效的 EPT 页目录 (PD)。\n- 索引为 $13$ 的 EPT PD 表项是可读/可写/可执行的，不是大页面表项，并指向一个有效的 EPT 页表 (PT)。\n- 索引为 $18$ 的 EPT 页表项 (PTE) 是可读和可写的（可执行位被清除），并映射一个 $4\\,\\text{KiB}$ 的主机物理帧，其基主机物理地址为 $0x\\mathrm{00000000008F3000}$。\n\n假设在客户机和 EPT 遍历过程中的所有未指定条目都存在且正确对齐，并且没有其他处理器状态（如缓存控制）影响此次访问的权限检查。\n\n任务：\n- 使用 PAE 地址转换和 EPT 地址转换的定义，推导出与客户机写入访问相对应的最终主机物理地址。在每一步中，明确验证权限是否允许监管模式的写入。如果任何权限会拒绝该访问，您必须在该点终止推导；否则，计算最终地址。\n- 将最终地址表示为一个带 $0x$ 前缀的十六进制无符号整数。不要四舍五入。", "solution": "该问题要求对由客户机操作系统发起的写入访问执行一个两阶段内存地址转换。第一阶段使用客户机的分页结构 (PAE) 将客户机线性地址转换为客户机物理地址。第二阶段使用虚拟机监控程序的扩展页表 (EPT) 将得到的客户机物理地址转换为主机物理地址。在两次转换的每一步中，我们都必须验证访问权限是否允许监管模式的写入。\n\n**第一阶段：客户机线性地址到客户机物理地址 (GPA) 的转换**\n\n客户机是一个启用了物理地址扩展 (PAE) 的 $32$ 位系统。一个 $32$ 位的线性地址使用三级页表结构进行转换。需要转换的客户机线性地址是 $LA_g = 0x\\mathrm{E5412345}$。\n\n在 PAE 模式下，这个 $32$ 位的线性地址被划分如下：\n- 位 $31-30$：页目录指针表 (PDPTE) 的索引，$2$ 位。\n- 位 $29-21$：页目录 (PD) 的索引，$9$ 位。\n- 位 $20-0$：页内偏移量，$21$ 位（对于一个 $2\\,\\text{MiB}$ 的页面）。\n\n我们解析客户机线性地址 $LA_g = 0x\\mathrm{E5412345}$：\n1.  **PDPTE 索引**：索引由地址的最高 $2$ 位给出。\n    $$ \\text{Index}_{\\text{PDPTE}} = 0x\\mathrm{E5412345} \\gg 30 = 3 $$\n    题目说明索引为 $3$ 的 PDPTE 存在，且其权限不限制监管模式的写入。因此，在这一级别，访问是允许的。\n\n2.  **页目录 (PD) 索引**：索引由地址的位 $29-21$ 给出。\n    $$ \\text{Index}_{\\text{PD}} = (0x\\mathrm{E5412345} \\gg 21) \\ 0x\\mathrm{1FF} = 0x\\mathrm{12A} $$\n    题目说明索引为 $0x\\mathrm{12A}$ 的页目录项 (PDE) 存在。\n\n3.  **权限检查和页面大小确定**：\n    题目指定了索引为 $0x\\mathrm{12A}$ 的 PDE 的属性：\n    - **存在 (Present)**：表项有效。\n    - **读/写 (R/W)**：已启用，允许写入访问。\n    - **用户/监管 (U/S)**：设置为仅限监管模式访问。客户机访问是在监管模式下，因此这是允许的。\n    - **No-Execute (NX)**：清除。这对于写入访问是无关紧要的，但也不构成限制。\n    - **页大小 (PS)**：已设置。这表明该 PDE 映射一个大小为 $2\\,\\text{MiB}$ 的大页面。\n\n    该访问是一次监管模式写入，此 PDE 完全允许。由于 PS 位已设置，这是客户机地址转换的最后一步。\n\n4.  **客户机物理地址 (GPA) 计算**：\n    对于一个 $2\\,\\text{MiB}$ 的大页面，客户机物理地址是 PDE 中的基物理地址与线性地址中的偏移量之和。\n    - 来自 PDE 的基客户机物理地址为 $0x\\mathrm{01A00000}$。\n    - 偏移量是线性地址的低 $21$ 位：\n      $$ \\text{Offset}_g = LA_g \\ 0x\\mathrm{1FFFFF} = 0x\\mathrm{E5412345} \\ 0x\\mathrm{1FFFFF} = 0x\\mathrm{12345} $$\n    - 最终的客户机物理地址是：\n      $$ \\text{GPA} = 0x\\mathrm{01A00000} + 0x\\mathrm{12345} = 0x\\mathrm{01A12345} $$\n\n**第二阶段：客户机物理地址 (GPA) 到主机物理地址 (HPA) 的转换**\n\n虚拟机监控程序使用 Intel 扩展页表 (EPT) 将 GPA 转换为主机物理地址 (HPA)。这涉及使用 GPA $0x\\mathrm{01A12345}$ 进行四级页表遍历。EPT 结构将一个物理地址划分为四个 $9$ 位索引和一个 $12$ 位偏移量。\n\nGPA $0x\\mathrm{01A12345}$ 在 EPT 遍历中解析如下：\n- 位 $47-39$：EPT 页映射级别 $4$ 表 (PML4T) 的索引。\n- 位 $38-30$：EPT 页目录指针表 (PDPT) 的索引。\n- 位 $29-21$：EPT 页目录 (PD) 的索引。\n- 位 $20-12$：EPT 页表 (PT) 的索引。\n- 位 $11-0$：$4\\,\\text{KiB}$ 页面内的偏移量。\n\n1.  **EPT PML4 索引**：由于 GPA $0x\\mathrm{01A12345}$ 是一个 $32$ 位地址，其从 $32$ 到 $47$ 的位都为 $0$。\n    $$ \\text{Index}_{\\text{PML4}} = (0x\\mathrm{01A12345} \\gg 39) \\ 0x\\mathrm{1FF} = 0 $$\n    索引为 $0$ 的 EPT PML4 表项被指定为可读、可写和可执行。写入是允许的。\n\n2.  **EPT PDPT 索引**：GPA 的位 $38-30$ 也都为 $0$。\n    $$ \\text{Index}_{\\text{PDPT}} = (0x\\mathrm{01A12345} \\gg 30) \\ 0x\\mathrm{1FF} = 0 $$\n    索引为 $0$ 的 EPT PDPT 表项被指定为可读、可写和可执行。写入是允许的。\n\n3.  **EPT PD 索引**：\n    $$ \\text{Index}_{\\text{PD}} = (0x\\mathrm{01A12345} \\gg 21) \\ 0x\\mathrm{1FF} = 0xD = 13 $$\n    索引为 $13$ 的 EPT PD 表项被指定为可读、可写和可执行，并且不是大页面表项。写入是允许的，遍历继续到下一级。\n\n4.  **EPT PT 索引**：\n    $$ \\text{Index}_{\\text{PT}} = (0x\\mathrm{01A12345} \\gg 12) \\ 0x\\mathrm{1FF} = 0x\\mathrm{12} = 18 $$\n    索引为 $18$ 的 EPT 页表项 (PTE) 是 EPT 遍历中的最终条目。它被指定为可读和可写，这允许客户机的写入访问。可执行位被清除对于数据写入不构成限制。此 PTE 映射一个 $4\\,\\text{KiB}$ 的主机物理帧。\n\n5.  **主机物理地址 (HPA) 计算**：\n    HPA 是 EPT PTE 中的基主机物理地址与 GPA 中的偏移量之和。\n    - 来自 PTE 的基主机物理地址为 $0x\\mathrm{00000000008F3000}$。\n    - 偏移量是 GPA 的低 $12$ 位：\n      $$ \\text{Offset}_h = \\text{GPA} \\ 0x\\mathrm{FFF} = 0x\\mathrm{01A12345} \\ 0x\\mathrm{FFF} = 0x\\mathrm{345} $$\n    - 最终的主机物理地址是：\n      $$ \\text{HPA} = 0x\\mathrm{8F3000} + 0x\\mathrm{345} = 0x\\mathrm{8F3345} $$\n\n在客户机级别和 EPT 级别的转换过程中，所有针对监管模式写入的权限检查都已通过。最终的主机物理地址已成功推导出来。", "answer": "$$\\boxed{0x\\mathrm{8F3345}}$$", "id": "3657979"}, {"introduction": "客户机操作系统以页为单位管理其内存，但这如何转化为虚拟机监控器（hypervisor）所需的工作呢？此问题将一个常见的操作系统操作——扩展线程栈——与嵌套分页的底层机制联系起来。通过计算所需的新扩展页表（EPT）条目数量，这个练习有助于阐明客户机内存需求与 hypervisor 资源管理之间的直接关系 [@problem_id:3657916]。", "problem": "一个 $64$ 位虚拟化系统使用 Intel 扩展页表 (EPT) 进行嵌套分页，其叶级别的页面大小为 $4\\,\\text{KiB}$。考虑一个客户机操作系统，其线程栈在客户机虚拟内存中向下增长。客户机操作系统以页面大小为增量管理客户机栈：当扩展栈时，客户机提交恰好能覆盖额外字节所需的整数个页面。虚拟机监控程序 (hypervisor) 使用 $4\\,\\text{KiB}$ 的叶映射实现 EPT，并已为一个连续的客户机物理帧区域预先分配了所有非叶 EPT 结构，该区域足够大以满足即将到来的分配，因此为新提交的页面创建映射仅需插入叶 EPT 条目。当前已提交的栈大小 $S_{0}$ 是页面大小的整数倍，因此下一次扩展从页面边界开始。\n\n客户机执行一次大小为 $\\Delta S = 5.75\\,\\text{MiB}$ 的栈扩展。假设客户机从一个客户机物理帧范围分配新的栈页面，该范围完全位于虚拟机监控程序已为其准备好非叶 EPT 结构的区域内。\n\n在这些假设下，并从分页虚拟内存和嵌套分页的基本原理出发，计算虚拟机监控程序为映射额外提交的栈而必须创建的新叶 EPT 条目的确切数量 $n$。将 $n$ 表示为单个实数值。最终答案中不要包含任何单位。", "solution": "分页系统中虚拟内存的基本机制是内存被划分为称为页面的固定大小块。对于大小为 $P$ 字节的页面，任何大小为 $\\Delta S$ 字节的连续分配，如果其起始点位于页面边界，则需要的页面数等于大于或等于 $\\Delta S / P$ 的最小整数。这是因为每个页面恰好覆盖 $P$ 字节，并且从页面分配器和页表的角度来看，一个部分的最后一页与一个完整的页面分配是无法区分的。\n\n在具有嵌套分页的虚拟化系统中，客户机操作系统使用其自己的页表将客户机虚拟页面映射到客户机物理帧。然后，虚拟机监控程序使用扩展页表 (EPT) 将客户机物理帧映射到主机物理帧。在叶级别，一个叶 EPT 条目将一个 $4\\,\\text{KiB}$ 的客户机物理页帧精确地映射到一个主机物理页帧。因此，所需的新叶 EPT 条目数量等于支持额外栈的新提交的客户机物理页面的数量。因为问题陈述所有非叶 EPT 结构都已为相关区域预先分配，所以为新页面创建映射仅需插入叶 EPT 条目，而无需分配额外的中间 EPT 表。\n\n令 $P$ 表示页面大小。我们已知 $P = 4\\,\\text{KiB} = 4 \\times 2^{10} = 2^{12}$ 字节。扩展大小为 $\\Delta S = 5.75\\,\\text{MiB} = 5.75 \\times 2^{20}$ 字节。当前已提交的栈大小 $S_{0}$ 是 $P$ 的整数倍，因此扩展从页面边界开始。因此，新提交的页面数，也就是新叶 EPT 条目的数量 $n$ 是\n$$\nn = \\left\\lceil \\frac{\\Delta S}{P} \\right\\rceil.\n$$\n代入给定值，\n$$\n\\frac{\\Delta S}{P} = \\frac{5.75 \\times 2^{20}}{2^{12}} = 5.75 \\times 2^{8} = 5.75 \\times 256.\n$$\n计算 $5.75 \\times 256$：\n$$\n5.75 \\times 256 = (5 + 0.75) \\times 256 = 5 \\times 256 + 0.75 \\times 256 = 1280 + 192 = 1472.\n$$\n由于该值已经是整数，向上取整不会改变它：\n$$\nn = \\left\\lceil 1472 \\right\\rceil = 1472.\n$$\n因此，虚拟机监控程序必须创建恰好 $1472$ 个新的叶 EPT 条目来映射额外提交的栈。", "answer": "$$\\boxed{1472}$$", "id": "3657916"}, {"introduction": "内存虚拟化不仅是为了隔离，它也是一个强大的优化工具。本练习探讨了优雅的写时复制（Copy-on-Write, COW）技术，该技术被用于实现近乎瞬时的虚拟机克隆。通过分析所需的 EPT 修改，您将了解 hypervisor 如何利用硬件级别的权限控制来实现复杂而高效的系统级功能 [@problem_id:3657999]。", "problem": "一个在支持英特尔扩展页表 (EPT) 的 x86 平台上的虚拟机管理器 (hypervisor) 使用写时复制 (copy-on-write) 技术来实现快速的虚拟机克隆。在这种设置下，中央处理器 (CPU) 执行两阶段地址转换：首先使用客户机页表将客户机虚拟地址转换为客户机物理地址，然后使用 EPT 将客户机物理地址转换为主机物理地址。对写入操作的硬件权限检查是通过此转换管道中各级权限的交集来强制执行的：只有当所有相关权限都允许写入时，写入操作才被允许；否则，将向相应的处理程序引发一个故障 (fault)。\n\n考虑一个单一的虚拟机派生 (fork) 操作，该操作克隆一个父虚拟机以生成一个子虚拟机。Hypervisor 在 EPT 叶表项级别实现写时复制，以便在两个虚拟机之间初始共享 $S$ 个不同的主机页帧。这 $S$ 个页面中的每一个当前都在父虚拟机中通过一个授予读写权限的 EPT 叶表项进行映射。为了在派生时建立写时复制共享，hypervisor 必须确保父虚拟机或子虚拟机后续对这些共享页面的任何写入操作都将被截获，以便可以创建一个私有副本。\n\n假设该派生操作遵循以下操作模型：\n- 对于 $S$ 个共享页面中的每一个，hypervisor 修改父虚拟机现有的 EPT 叶表项，以拒绝写入但继续允许读取。\n- 对于 $S$ 个共享页面中的每一个，hypervisor 在子虚拟机的 EPT 中安装一个相应的 EPT 叶表项，该表项映射到与父虚拟机相同的主机物理页，并且同样拒绝写入但允许读取。\n- 对于覆盖这 $S$ 个页面的地址范围，父虚拟机和子虚拟机的上层 EPT 结构（非叶级别）都已分配或被重用，无需修改。此处不计算转译后备缓冲器 (TLB) 刷新 (shootdown)、访问位或脏位的副作用，以及实际发生写故障时的任何后续更新。\n\n在这些条件下，计算在此次单一派生操作期间 hypervisor 必须执行的 EPT 叶表项更新的总数，并表示为共享页面数 $S$ 的函数。请以关于 $S$ 的闭式解析表达式形式给出你的答案。无需四舍五入，也无需单位。", "solution": "目标是计算单次虚拟机派生操作所需的扩展页表 (EPT) 叶表项更新的总数，并将其表示为共享页面数 $S$ 的函数。\n\n问题明确指出，在派生过程中，为建立 $S$ 个页面的 COW 共享，hypervisor 执行以下操作：\n\n1.  **对父虚拟机的更新：**\n    问题陈述道：“对于 $S$ 个共享页面中的每一个，hypervisor 修改父虚拟机现有的 EPT 叶表项，以拒绝写入但继续允许读取。”\n    一个 EPT 叶表项是内存中的一个数据结构，它定义了一个页面的映射和权限。修改一个现有的表项，例如，通过清除写权限位，构成对该内存位置的一次更新。由于此操作对 $S$ 个共享页面中的每一个都执行一次，因此对父虚拟机的 EPT 叶表项更新次数恰好为 $S$。我们将此计数表示为 $N_{parent}$。\n    $$N_{parent} = S$$\n\n2.  **对子虚拟机的更新：**\n    问题陈述道：“对于 $S$ 个共享页面中的每一个，hypervisor 在子虚拟机的 EPT 中安装一个相应的 EPT 叶表项，该表项映射到与父虚拟机相同的主机物理页，并且同样拒绝写入但允许读取。”\n    子虚拟机从其自己独立的 EPT 结构开始。“安装”一个新的 EPT 叶表项意味着 hypervisor 必须为子虚拟机创建此表项并将其写入相应的叶级 EPT 页面中。这种写入新表项数据的行为是对 EPT 结构的一次更新。此操作也对 $S$ 个共享页面中的每一个执行一次。因此，对子虚拟机的 EPT 叶表项更新次数也为 $S$。我们将此计数表示为 $N_{child}$。\n    $$N_{child} = S$$\n\n问题明确要求计算 EPT 叶表项更新的*总*数。这个总数，我们称之为 $N_{total}$，是为父虚拟机的 EPT 执行的更新数与为子虚拟机的 EPT 执行的更新数之和。\n\n$$N_{total} = N_{parent} + N_{child}$$\n\n代入从问题描述中导出的值：\n\n$$N_{total} = S + S$$\n$$N_{total} = 2S$$\n\n问题明确规定，对上层 EPT 结构的修改、TLB 刷新以及发生写故障后的后续更新不应计入此总数。上述计算严格遵守这些约束，仅计算在派生操作发生的时刻执行的 EPT 叶表项更新。\n\n因此，EPT 叶表项更新的总数是共享页面数的两倍。", "answer": "$$\\boxed{2S}$$", "id": "3657999"}]}