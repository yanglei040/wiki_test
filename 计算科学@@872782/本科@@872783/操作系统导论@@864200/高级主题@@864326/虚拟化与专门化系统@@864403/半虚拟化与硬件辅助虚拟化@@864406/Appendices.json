{"hands_on_practices": [{"introduction": "在深入探讨优化技术之前，首先必须学会如何精确地量化虚拟化带来的开销。硬件辅助虚拟化虽然提供了强大的隔离性，但每次陷入（trap）到虚拟机监控器（hypervisor）都会产生显著的性能成本。本练习将指导你设计一个微基准测试（microbenchmark），以量化硬件指令捕获（如 `RDTSC`）与半虚拟化时钟（paravirtual clock）之间的性能差异，从而突显在系统性能分析中严谨的实验方法论的重要性。[@problem_id:3668635]", "problem": "您正在研究x86虚拟机（Virtual Machine (VM)）中，在两种客户机可见的时间源下读取时间的性能成本：一种是由虚拟机监控器（hypervisor）完全进行陷阱并模拟（trap-and-emulate）的读取时间戳计数器（Read Time-Stamp Counter, RDTSC），另一种是通过虚拟动态共享对象（Virtual Dynamic Shared Object, vDSO）暴露的半虚拟化时钟（paravirtual clock, PV clock）。您希望估算用PV时钟读取替换模拟的RDTSC读取时，每次调用节省的周期数，记为 $\\Delta C$。\n\n根据第一性原理，将每次调用的成本定义为在控制了测量工具开销后，待测操作所带来的中央处理器（CPU）增量周期数。假设客户机中的一个测量工具通过将一个紧凑循环的循环体置于一个串行化的起始序列和一个串行化的结束序列之间来进行计时，然后计算周期数的差值。起始序列是串行化指令对 $\\text{CPUID}$ 后跟 $\\text{RDTSC}$，用于读取起始时间戳。结束序列是 $\\text{RDTSCP}$ 后跟 $\\text{CPUID}$，用于读取结束时间戳并串行化指令的提交。循环重复 $M$ 次迭代，循环体在每次迭代中恰好调用待测的两种操作之一。程序经过优化编译，并使用标记为 volatile 的内联汇编和数据依赖来防止死代码消除和代码跨越计时区间的移动。\n\n您在同一台虚拟机的同一个核心上运行此测量工具三次，除了循环体之外，所有系统设置都保持不变。您获得了以下周期计数（由客户机的时间戳计数器在起始和结束序列之间的差值读取）：\n\n- 空测量工具（循环体内无操作）：$M = 5\\times 10^{6}$ 次迭代，总周期数 $C_{\\text{empty}} = 25{,}000{,}000$。\n- 循环体调用模拟的 RDTSC（虚拟机监控器在每次客户机 RDTSC 时进行拦截和模拟）：$M = 5\\times 10^{6}$ 次迭代，总周期数 $C_{\\text{rdtsc}} = 10{,}025{,}000{,}000$。\n- 循环体通过 vDSO 调用 PV 时钟读取（此操作读取一个由虚拟机监控器填充的共享结构，无需陷阱）：$M = 5\\times 10^{6}$ 次迭代，总周期数 $C_{\\text{pv}} = 775{,}000{,}000$。\n\n假设虚拟机监控器的配置使得客户机 RDTSC 总是导致 VM 退出并被模拟（没有硬件 TSC 偏移），并且 PV 时钟路径确实是快速的 vDSO 路径（没有系统调用回退）。您还假设存在现代的乱序执行，并且串行化序列可以防止指令跨越计时区间的重排。\n\n哪个选项给出了一个科学上合理的测量方案，以仅隔离由两种时间源引起的每次调用成本差异，并根据上述数据正确计算出每次调用节省的周期数 $\\Delta C$？\n\nA. 不将线程固定到某个CPU，允许动态电压和频率缩放，并使用墙上时钟 gettimeofday 对两种循环变体进行计时；计算 $\\Delta C$ 为 $\\left(C_{\\text{rdtsc}}/M\\right)-\\left(C_{\\text{pv}}/M\\right)\\approx 200$ 个周期，因为墙上时钟的抖动在 $M$ 次迭代中会被平均掉。\n\nB. 将线程固定到一个CPU，禁用频率缩放和睿频（turbo），尽可能将该核心与其他任务和中断隔离，对所有运行使用具有相同代码结构的串行化 $\\text{CPUID}$-$\\text{RDTSC}$/$\\text{RDTSCP}$-$\\text{CPUID}$ 测量工具，验证PV时钟正在使用vDSO，使用 volatile 和数据依赖防止编译器重排，运行多次试验并取中位数；通过减去空测量工具的平均成本来计算每次调用的成本：$c_{\\text{rdtsc}}=\\left(C_{\\text{rdtsc}}-C_{\\text{empty}}\\right)/M$, $c_{\\text{pv}}=\\left(C_{\\text{pv}}-C_{\\text{empty}}\\right)/M$, 以及 $\\Delta C=c_{\\text{rdtsc}}-c_{\\text{pv}}=1850$ 个周期。\n\nC. 通过 RDPMC 使用性能监控单元（PMU），但不请求客户机用户模式访问权限，在循环中读取周期数而不进行串行化，假设 PV 时钟成本为 0 周期因为它属于半虚拟化，并报告 $\\Delta C\\approx 2000$ 个周期。\n\nD. 固定线程并使用相同的串行化测量工具，但不进行基线空测量；估计 $\\Delta C$ 为 $\\left(C_{\\text{rdtsc}}/M\\right)-\\left(C_{\\text{pv}}/M\\right)$，并且为减少噪声，通过除以 $M-1$ 来校正端点开销，得到 $\\Delta C\\approx 1975$ 个周期。", "solution": "### 问题验证\n\n#### 步骤1：提取已知条件\n\n问题提供了以下数据、定义和条件：\n\n*   **目标**：估算用半虚拟化时钟（`PV clock`）读取替换模拟的`RDTSC`读取时，每次调用节省的周期数，记为 $\\Delta C$。\n*   **每次调用成本定义**：在控制了测量工具开销后，待测操作所带来的中央处理器（CPU）增量周期数。\n*   **测量工具**：\n    *   重复 $M$ 次迭代的循环。\n    *   计时起始序列：`CPUID` 后跟 `RDTSC`。\n    *   计时结束序列：`RDTSCP` 后跟 `CPUID`。\n    *   循环体在每次迭代中恰好包含一个待测操作。\n*   **实验运行**：执行了三次运行。\n    *   空测量工具（循环体内无操作）：$M = 5 \\times 10^{6}$ 次迭代，总周期数 $C_{\\text{empty}} = 25{,}000{,}000$。\n    *   循环体中为模拟的 `RDTSC`：$M = 5 \\times 10^{6}$ 次迭代，总周期数 $C_{\\text{rdtsc}} = 10{,}025{,}000{,}000$。\n    *   循环体中为 `PV clock` 读取：$M = 5 \\times 10^{6}$ 次迭代，总周期数 $C_{\\text{pv}} = 775{,}000{,}000$。\n*   **假设**：\n    *   客户机 `RDTSC` 总是导致 VM 退出并由虚拟机监控器模拟。\n    *   `PV clock` 路径使用虚拟动态共享对象（vDSO），不涉及系统调用（即无陷阱）。\n    *   CPU 使用现代的乱序执行。\n    *   串行化指令序列能有效防止指令跨越计时区间的重排。\n    *   所有实验设置（虚拟机、核心等）在各次运行中保持不变。\n\n#### 步骤2：使用提取的已知条件进行验证\n\n根据验证标准评估问题陈述：\n\n*   **科学依据**：该问题牢固地植根于计算机体系结构和操作系统的原理，特别是在虚拟化环境中的性能测量（微基准测试）。`RDTSC`、`CPUID`、串行化、VM退出（陷阱）、半虚拟化（PV-clock, vDSO）和测量开销等概念都是标准且成熟的。所描述的场景是量化虚拟化开销的一种经典方法。\n*   **适定性**：该问题是适定的。它定义了要测量的量（$\\Delta C$），明确了方法和假设，并为得出唯一解提供了所有必要的数值数据。\n*   **客观性**：语言技术性强、精确且不含主观性。所描述的实验是客观且可重复的。\n*   **缺陷分析**：\n    1.  **科学上不合理**：无。所描述的机制和性能特征与现实世界的x86虚拟化一致。VM退出（陷阱并模拟）的成本通常是数千个周期，而vDSO读取的成本在几十到几百个周期之间，具体取决于缓存状态。所提供的数据反映了这一现实。\n    2.  **不可形式化或不相关**：无。该问题是一个可形式化且高度相关的性能分析练习。\n    3.  **不完整或矛盾的设置**：无。所有必要的变量（$C_{\\text{empty}}$, $C_{\\text{rdtsc}}$, $C_{\\text{pv}}$, $M$）和上下文假设都已提供。\n    4.  **不切实际或不可行**：周期计数很大，但考虑到大量的迭代次数（$M = 5 \\times 10^6$），这是完全合理的。从这些数据中得出的每次迭代成本对于所描述的操作是现实的。\n    5.  **不适定或结构不良**：无。可以根据所提供的信息推导出唯一解。\n    6.  **故作高深、琐碎或同义反复**：无。该问题要求对性能测量的实验设计有正确的理解，特别是理解基线测量在解释开销方面的关键作用。这是一个实质性的概念要点。\n\n#### 步骤3：结论与行动\n\n问题陈述是**有效的**。它呈现了一个科学上合理、适定且客观的场景。现在可以进行求解过程。\n\n### 解题推导\n\n目标是确定使用 `PV clock` 替代模拟 `RDTSC` 每次调用节省的周期数 $\\Delta C$。这需要计算每个操作的每次调用成本，该成本被定义为在控制了测量工具开销后的*增量*成本。\n\n1.  **建模总成本**：对于给定的运行，测得的总周期数 $C_{\\text{total}}$ 可以建模为循环体 $M$ 次迭代的成本总和。每次迭代包括测量工具的开销（例如，循环计数器递增和跳转）和被测特定操作的成本。设 $\\bar{c}_{\\text{harness}}$ 为每次迭代的平均测量工具开销，而 $c_{\\text{op}}$ 为每次调用的待测操作成本。测试操作 'op' 的一次运行所测得的总周期为：\n    $$C_{\\text{op\\_run}} = M \\times (\\bar{c}_{\\text{harness}} + c_{\\text{op}})$$\n    此模型假设，当分摊到 $M$ 次大量迭代中时，起始和结束计时序列的一次性成本可以忽略不计，这是此类微基准测试中的一个标准假设。\n\n2.  **计算测量工具开销**：空测量工具运行专门用于测量 $\\bar{c}_{\\text{harness}}$。在此运行中，$c_{\\text{op}} = 0$。\n    $$C_{\\text{empty}} = M \\times \\bar{c}_{\\text{harness}}$$\n    因此，每次迭代的平均测量工具开销为：\n    $$\\bar{c}_{\\text{harness}} = \\frac{C_{\\text{empty}}}{M} = \\frac{25{,}000{,}000}{5 \\times 10^{6}} = 5 \\text{ 个周期}$$\n\n3.  **计算模拟RDTSC的每次调用成本**：我们使用 `RDTSC` 运行的数据，并减去已知的测量工具开销，以分离出模拟 `RDTSC` 调用的增量成本 $c_{\\text{rdtsc}}$。\n    $$C_{\\text{rdtsc}} = M \\times (\\bar{c}_{\\text{harness}} + c_{\\text{rdtsc}})$$\n    $$c_{\\text{rdtsc}} = \\frac{C_{\\text{rdtsc}}}{M} - \\bar{c}_{\\text{harness}} = \\frac{C_{\\text{rdtsc}}}{M} - \\frac{C_{\\text{empty}}}{M} = \\frac{C_{\\text{rdtsc}} - C_{\\text{empty}}}{M}$$\n    $$c_{\\text{rdtsc}} = \\frac{10{,}025{,}000{,}000 - 25{,}000{,}000}{5 \\times 10^{6}} = \\frac{10{,}000{,}000{,}000}{5 \\times 10^{6}} = 2000 \\text{ 个周期}$$\n\n4.  **计算PV时钟的每次调用成本**：类似地，我们计算 `PV clock` 读取的增量成本 $c_{\\text{pv}}$。\n    $$C_{\\text{pv}} = M \\times (\\bar{c}_{\\text{harness}} + c_{\\text{pv}})$$\n    $$c_{\\text{pv}} = \\frac{C_{\\text{pv}}}{M} - \\bar{c}_{\\text{harness}} = \\frac{C_{\\text{pv}}}{M} - \\frac{C_{\\text{empty}}}{M} = \\frac{C_{\\text{pv}} - C_{\\text{empty}}}{M}$$\n    $$c_{\\text{pv}} = \\frac{775{,}000{,}000 - 25{,}000{,}000}{5 \\times 10^{6}} = \\frac{750{,}000{,}000}{5 \\times 10^{6}} = 150 \\text{ 个周期}$$\n\n5.  **计算节省的周期数 ($\\Delta C$)**：每次调用节省的周期数是两次调用成本之差。\n    $$\\Delta C = c_{\\text{rdtsc}} - c_{\\text{pv}}$$\n    $$\\Delta C = 2000 - 150 = 1850 \\text{ 个周期}$$\n    或者，可以直接计算如下：\n    $$\\Delta C = \\left(\\frac{C_{\\text{rdtsc}} - C_{\\text{empty}}}{M}\\right) - \\left(\\frac{C_{\\text{pv}} - C_{\\text{empty}}}{M}\\right) = \\frac{C_{\\text{rdtsc}} - C_{\\text{pv}}}{M}$$\n    $$\\Delta C = \\frac{10{,}025{,}000{,}000 - 775{,}000{,}000}{5 \\times 10^{6}} = \\frac{9{,}250{,}000{,}000}{5 \\times 10^{6}} = 1850 \\text{ 个周期}$$\n\n科学上合理的方法包括测量基线并用它来计算真实的增量成本，然后得出差值。问题要求提供合理的方案和正确的计算。\n\n### 逐项分析选项\n\n**A. 不将线程固定到某个CPU，允许动态电压和频率缩放，并使用墙上时钟 gettimeofday 对两种循环变体进行计时；计算 $\\Delta C$ 为 $\\left(C_{\\text{rdtsc}}/M\\right)-\\left(C_{\\text{pv}}/M\\right)\\approx 200$ 个周期，因为墙上时钟的抖动在 $M$ 次迭代中会被平均掉。**\n*   **测量方案**：该方案对于微基准测试来说是根本不合理的。不固定线程会导致核心迁移，这会使周期计数失效，因为时间戳计数器在不同核心间可能不同步。允许动态频率缩放（DVFS）意味着“周期”的持续时间不是恒定的，会给任何基于周期的测量带来巨大的、不确定的误差。使用 `gettimeofday` 测量的是墙上时钟时间，而非CPU周期，并且它本身也受误差源（例如NTP调整）和较低分辨率的影响，不适合此任务。\n*   **计算**：计算 $\\left(C_{\\text{rdtsc}}/M\\right)-\\left(C_{\\text{pv}}/M\\right)$ 会得到 $(10025 \\times 10^6 / 5 \\times 10^6) - (775 \\times 10^6 / 5 \\times 10^6) = 2005 - 155 = 1850$ 个周期。声称这大约是 $200$ 个周期在算术上是不正确的。\n*   **结论**：**不正确**。测量方法存在缺陷，且选项中陈述的数值结果是错误的。\n\n**B. 将线程固定到一个CPU，禁用频率缩放和睿频（turbo），尽可能将该核心与其他任务和中断隔离，对所有运行使用具有相同代码结构的串行化 $\\text{CPUID}$-$\\text{RDTSC}$/$\\text{RDTSCP}$-$\\text{CPUID}$ 测量工具，验证PV时钟正在使用vDSO，使用 volatile 和数据依赖防止编译器重排，运行多次试验并取中位数；通过减去空测量工具的平均成本来计算每次调用的成本：$c_{\\text{rdtsc}}=\\left(C_{\\text{rdtsc}}-C_{\\text{empty}}\\right)/M$, $c_{\\text{pv}}=\\left(C_{\\text{pv}}-C_{\\text{empty}}\\right)/M$, 以及 $\\Delta C=c_{\\text{rdtsc}}-c_{\\text{pv}}=1850$ 个周期。**\n*   **测量方案**：这描述了一个严谨的、科学上合理的微基准测试的检查清单。每一步（固定线程、禁用DVFS、核心隔离、串行化、编译器提示、多次试验）都是标准的最佳实践，旨在最小化噪声并确保测量隔离了感兴趣的现象。这是一个优秀的方案。\n*   **计算**：提供的公式 $c_{\\text{rdtsc}}=\\left(C_{\\text{rdtsc}}-C_{\\text{empty}}\\right)/M$ 和 $c_{\\text{pv}}=\\left(C_{\\text{pv}}-C_{\\text{empty}}\\right)/M$ 正确地实现了通过减去基线开销来找到增量成本的原则。随后计算差值 $\\Delta C = c_{\\text{rdtsc}} - c_{\\text{pv}}$ 是正确的。最终的数值结果 $1850$ 个周期与我们的推导完全匹配。\n*   **结论**：**正确**。此选项根据问题的定义和数据，既提出了一个合理的测量方案，也给出了正确的计算。\n\n**C. 通过 RDPMC 使用性能监控单元（PMU），但不请求客户机用户模式访问权限，在循环中读取周期数而不进行串行化，假设 PV 时钟成本为 0 周期因为它属于半虚拟化，并报告 $\\Delta C\\approx 2000$ 个周期。**\n*   **测量方案**：该方案存在缺陷。`RDPMC` 是一条特权指令。在没有虚拟机监控器明确授权的情况下，从客户机用户模式尝试执行它将导致故障，使测试无法进行。此外，在现代乱序CPU上*不进行串行化*的情况下读取周期计数是一个严重错误，因为测量指令可能会相对于被测代码进行重排，从而产生无意义的结果。\n*   **计算**：假设 `PV clock` 读取成本为 0 周期的假设是不正确的。任何操作，即使是从L1缓存中读取内存，也会消耗CPU周期。我们的计算表明，在此设置中其成本为 $150$ 个周期。报告 $\\Delta C \\approx 2000$ 个周期相当于只报告 $c_{\\text{rdtsc}}$ 而忽略 $c_{\\text{pv}}$，这并不是成本的*差异*。\n*   **结论**：**不正确**。所提议的测量方案无法实施且方法上有缺陷，其计算基于一个错误的假设。\n\n**D. 固定线程并使用相同的串行化测量工具，但不进行基线空测量；估计 $\\Delta C$ 为 $\\left(C_{\\text{rdtsc}}/M\\right)-\\left(C_{\\text{pv}}/M\\right)$，并且为减少噪声，通过除以 $M-1$ 来校正端点开销，得到 $\\Delta C\\approx 1975$ 个周期。**\n*   **测量方案**：虽然固定线程和使用串行化是好的做法，但不进行基线空测量是一个重大的方法论遗漏。它使得无法确定问题所定义的真实增量成本（$c_{\\text{rdtsc}}$ 和 $c_{\\text{pv}}$），即使可以计算出差值，分析也是不完整的。\n*   **计算**：公式 $\\Delta C = (C_{\\text{rdtsc}}/M) - (C_{\\text{pv}}/M)$ 确实可以得出 $1850$ 这个正确的数值答案。然而，随后关于除以 $M-1$ “来校正端点开销”的说法是无稽之谈。这个校正因子用于计算样本方差，而不是用于计时开销。这样的校正在这里没有任何物理或统计依据。此外，声称这会得到 $\\approx 1975$ 个周期在算术上是错误的；将 $9{,}250{,}000{,}000$ 除以 $(5\\times 10^6-1)$ 得到的结果非常接近 $1850$，而不是 $1975$。\n*   **结论**：**不正确**。测量方案不完整，所提议的“校正”在概念上是错误的，在数值上也不准确。", "answer": "$$\\boxed{B}$$", "id": "3668635"}, {"introduction": "既然我们已经了解了虚拟机退出（VM-exit）的高昂代价，下一步自然是设法减少其发生频率。本实践探讨了一种常见的半虚拟化优化技术——超调用批处理（hypercall batching），它允许客户机操作系统将多个请求合并，通过一次陷入操作完成，从而大幅降低开销。通过对该系统进行建模和计算，你将把批处理这一抽象概念与具体的性能增益联系起来。[@problem_id:3668597]", "problem": "在具有硬件辅助虚拟化（例如，Intel Virtualization Technology for x86 或 AMD Virtualization）的主机上，运行在虚拟机（VM）内的客户机操作系统通过发出超调用（hypercall）来执行特权服务，这些超调用通常会导致一次从客户机到主机的转换，称为虚拟机退出（VM-exit）。\n\n在半虚拟化设计中，客户机被修改为将超调用描述符写入共享内存环形缓冲区，并通过向虚拟机监控程序（hypervisor）配置的内存映射输入/输出（I/O）“门铃”寄存器写入，来通知一批处理的完成。hypervisor 会将此寄存器配置为每次门铃写入仅导致一次 VM-exit。\n\n假设以下基本事实和定义：\n- 超调用是一次从客户机到 hypervisor 的控制权转移；在没有批处理的情况下，每次超调用都恰好导致一次 VM-exit。\n- 使用门铃机制时，客户机将超调用描述符入队到共享内存环中，并在每批恰好 $k$ 个入队的可合并超调用后执行一次门铃写入；每次门铃写入恰好导致一次 VM-exit。\n- 所有超调用中有 $p$ 的比例是不可合并的（例如，它们需要立即处理），必须直接发出，每次都导致一次 VM-exit；剩余的 $1-p$ 比例是可合并的，并使用带有门铃批处理的共享环。\n- 系统在稳态下运行，持续的超调用生成速率为每秒 $E$ 次超调用，环形缓冲区从不溢出，且没有超时或部分批处理；假设在稳态下，每次门铃操作都对恰好 $k$ 个可合并的超调用进行整数批处理。\n\n要求您分析上述批处理方法，并仅使用速率的定义以及两种路径（不可合并和可合并）下 VM-exit 的行为，来确定由超调用处理产生的稳态 VM-exit 速率。\n\n给定 $E = 2.56 \\times 10^{6}$ 次超调用 $\\mathrm{s}^{-1}$，$k = 16$，以及 $p = \\frac{1}{8}$，计算由超调用处理产生的稳态 VM-exit 速率。将您的答案四舍五入至四位有效数字，并以 $\\mathrm{s}^{-1}$ 为单位表示该速率。", "solution": "所述问题具有科学依据、提法明确且客观。它描述了系统虚拟化中一种常见的性能优化技术，即超调用批处理，并使用了一个简化但一致的模型。所有必要的参数和条件都已提供，足以推导出唯一且有意义的解。因此，该问题被认为是有效的。\n\n核心任务是确定由超调用活动产生的虚拟机退出（VM-exit）的总稳态速率。总超调用生成速率给定为 $E$。这些超调用通过两条不同的路径进行处理：一条是用于不可合并超调用的直接路径，另一条是用于可合并超调用的批处理路径。总 VM-exit 速率将是这两条路径速率之和。\n\n设 $V_{total}$ 为总稳态 VM-exit 速率。我们可以将其表示为不可合并超调用引起的 VM-exit 速率 $V_{nc}$ 与可合并超调用引起的 VM-exit 速率 $V_{c}$ 之和。\n$$V_{total} = V_{nc} + V_{c}$$\n我们现在将推导 $V_{nc}$ 和 $V_{c}$ 的表达式。\n\n首先，考虑不可合并的超调用。总超调用中有一部分比例为 $p$ 的是不可合并的。因此，这些超调用的生成速率 $R_{nc}$ 为：\n$$R_{nc} = p \\cdot E$$\n根据题目描述，每个不可合并的超调用都恰好导致一次 VM-exit。因此，来自此路径的 VM-exit 速率等于这些超调用本身的速率。\n$$V_{nc} = R_{nc} = p \\cdot E$$\n\n接下来，考虑可合并的超调用。可合并的超调用比例为 $1-p$。这些超调用的生成速率 $R_c$ 为：\n$$R_c = (1-p) \\cdot E$$\n这些超调用以大小为 $k$ 的批次进行处理。每批 $k$ 个可合并的超调用触发一次门铃写入，这又恰好导致一次 VM-exit。在没有部分批处理的稳态条件下，VM-exit 的速率由完整批次形成的速率决定。该速率是可合并超调用的总速率除以批处理大小 $k$。\n$$V_c = \\frac{R_c}{k} = \\frac{(1-p) \\cdot E}{k}$$\n\n现在，我们可以将 $V_{nc}$ 和 $V_{c}$ 的表达式代入总 VM-exit 速率的方程中：\n$$V_{total} = p \\cdot E + \\frac{(1-p) \\cdot E}{k}$$\n提取总超调用速率 $E$ 作为公因子，得到总 VM-exit 速率的最终解析表达式：\n$$V_{total} = E \\left( p + \\frac{1-p}{k} \\right)$$\n我们给定了以下值：\n- 总超调用速率, $E = 2.56 \\times 10^{6} \\, \\mathrm{s}^{-1}$\n- 批处理大小, $k = 16$\n- 不可合并超调用的比例, $p = \\frac{1}{8}$\n\n我们将这些值代入推导出的公式。首先，我们计算括号内的项：\n$$p + \\frac{1-p}{k} = \\frac{1}{8} + \\frac{1 - \\frac{1}{8}}{16} = \\frac{1}{8} + \\frac{\\frac{7}{8}}{16} = \\frac{1}{8} + \\frac{7}{8 \\times 16} = \\frac{1}{8} + \\frac{7}{128}$$\n为了进行加法运算，我们使用公分母 $128$：\n$$\\frac{1}{8} = \\frac{1 \\times 16}{8 \\times 16} = \\frac{16}{128}$$\n和为：\n$$\\frac{16}{128} + \\frac{7}{128} = \\frac{16+7}{128} = \\frac{23}{128}$$\n现在，我们将此结果乘以 $E$：\n$$V_{total} = (2.56 \\times 10^{6}) \\cdot \\frac{23}{128}$$\n为了简化计算，我们可以观察 $2.56$ 和 $128$ 之间的关系：\n$$V_{total} = \\left(\\frac{2.56}{128}\\right) \\cdot 23 \\cdot 10^{6}$$\n因为 $128 \\times 2 = 256$，所以 $128 \\times 0.02 = 2.56$。因此，$\\frac{2.56}{128} = 0.02$。\n$$V_{total} = 0.02 \\cdot 23 \\cdot 10^{6} = 0.46 \\cdot 10^{6} = 460000 \\, \\mathrm{s}^{-1}$$\n结果用标准科学记数法表示为 $4.6 \\times 10^5 \\, \\mathrm{s}^{-1}$。题目要求答案四舍五入到四位有效数字。为了用四位有效数字表示 $4.6 \\times 10^5$，我们在尾数后添加尾随零。\n$$V_{total} = 4.600 \\times 10^5 \\, \\mathrm{s}^{-1}$$\n这是最终计算出的由超调用处理引起的稳态 VM-exit 速率。", "answer": "$$\\boxed{4.600 \\times 10^{5}}$$", "id": "3668597"}, {"introduction": "简单的优化技术很有效，但现代高性能I/O需要更复杂的异步设计。本练习将挑战你像系统设计师一样思考，利用共享内存环形缓冲区（shared memory rings）来构建一个类似于 `virtio` 的异步半虚拟化接口。这次的重点不再是简单的性能计算，而是分析在真实并发系统中至关重要的正确性问题，例如数据一致性（内存排序）和系统稳定性（死锁）。[@problem_id:3668578]", "problem": "在虚拟机监控程序上运行的半虚拟化客户机操作系统实现对虚拟设备的异步 hypercall。该设计使用两个共享内存环：一个用于提交的请求环和一个用于响应的完成环。每个 hypercall 创建一个由句柄 $h$ 标识的描述符，并将该描述符放入请求环并调用一个轻量级的虚拟机监控程序入口点 $H\\_{\\mathrm{submit}}(h)$ 后立即返回。虚拟机监控程序并发处理描述符，并在操作完成时，将一个完成记录 $\\langle h, s, \\mathrm{status} \\rangle$ 写入完成环，其中 $s$ 是虚拟机监控程序在完成时分配的单调递增的序列号。完成环的容量为 $m$，客户机最多有 $n$ 个未完成的 hypercall（配额）。虚拟机监控程序可以不按提交顺序完成 hypercall。虚拟机监控程序保证对于任何句柄 $h$，写入其完成记录的操作具有释放语义，而客户机读取完成记录的操作具有获取语义。客户机可以：(i) 主动排空完成环（消费条目并调用相应的回调函数），或者 (ii) 阻塞一个线程等待某个特定句柄 $h^\\*$ 完成，并且不排空其他完成条目。\n\n假设共享环和生产者-消费者系统具有标准属性，并考虑经典的死锁条件（互斥、持有并等待、不可抢占、循环等待）。进一步假设每个完成记录与一个未完成的 hypercall 一一对应，因此虚拟机监控程序对于正在使用的 $n$ 个配额最多会产生 $n$ 个完成记录。考虑当有 $n$ 个请求未完成且完成可能乱序到达时，顺序保证与死锁风险之间的相互作用。\n\n以下哪个陈述是正确的？\n\nA. 如果客户机在同一虚拟设备上先发出 hypercall A，再发出 hypercall B，并且 B 逻辑上依赖于 A 的副作用，那么即使虚拟机监控程序乱序完成，仅靠完成队列的顺序也足以强制正确的依赖关系。\n\nB. 如果客户机阻塞等待一个特定句柄 $h^\\*$ 并且不排空其他完成条目，那么当 $m  n$ 时，可能会出现由容量引发的死锁：完成环可能被其他完成记录填满，导致虚拟机监控程序无法发布 $h^\\*$ 的完成记录，从而造成循环等待。\n\nC. 借助虚拟机监控程序完成写入的释放语义和客户机完成读取的获取语义，读取句柄 $h$ 的完成记录会与该 hypercall $h$ 的副作用建立一个 happens-before 关系。只要客户机明确编码依赖关系（例如，通过使用屏障操作或在观察到 A 的完成之前不发出 B），乱序完成就是安全的。\n\nD. 如果 $n \\le m$，那么无论客户机的锁定或调度行为如何，该系统中都不会发生死锁。\n\nE. 保证所有操作的完成顺序遵循每个虚拟中央处理器（vCPU）的先进先出（First-In-First-Out）原则，意味着需要串行化设备端的执行，这会降低并发性。允许乱序完成并由客户机进行显式依赖跟踪，可以在提高吞吐量的同时保持内存安全。", "solution": "本分析基于操作系统和并发领域的基本原理：生产者-消费者环形缓冲区、通过释放/获取语义建立 happens-before 关系的内存排序，以及经典的 Coffman 死锁条件，即互斥、持有并等待、不可抢占和循环等待。我们还利用了向完成环中生产操作的有界性：最多 $n$ 个完成对应 $n$ 个未完成的配额。\n\n顺序保证和内存安全。虚拟机监控程序承诺，对于任何句柄 $h$，其完成记录都以释放语义发布；客户机以获取语义读取。在这些语义下，如果客户机读取了句柄 $h$ 的完成记录，那么在虚拟机监控程序对 $h$ 的副作用与客户机基于该完成记录的后续操作之间就建立了一个 happens-before 关系。这确保了对于该特定句柄，其 hypercall 副作用的内存可见性是安全的，但这并不提供不同句柄之间的顺序保证，除非客户机施加额外的约束（例如，在发出 B 之前等待 A，或引入一个显式的屏障）。\n\n有界队列的死锁风险。完成环的容量为 $m$。客户机最多可以发出 $n$ 个未完成的请求。虚拟机监控程序为这些请求最多产生 $n$ 个完成记录。如果客户机阻塞等待一个完成，并拒绝排空其他完成，完成环可能会在目标完成 $h^\\*$ 准备好之前被填满。如果环已满，虚拟机监控程序可能无法将 $h^\\*$ 的完成记录入队（取决于具体实现），从而使设备端的进展停滞，足以满足通过循环等待形成死锁的条件：客户机等待 $h^\\*$；虚拟机监控程序等待完成环中的空闲空间；客户机持有的资源（消费者角色）不可抢占；并且客户机持有配额或锁（互斥、持有并等待）。当 $m  n$ 时，在客户机阻塞期间，虚拟机监控程序可以产生比环容量更多的完成记录，使得这种由容量引发的死锁成为可能。相反，当 $m \\ge n$ 时，仅凭容量本身并不会因为这 $n$ 个完成而导致环被填满，尽管其他死锁仍可能因锁或调度而发生。\n\n逐项分析：\n\nA. 该主张依赖于仅靠完成队列的顺序来强制 B 观察 A 的副作用这一依赖关系。然而，虚拟机监控程序被允许乱序完成。乱序完成意味着 B 的完成记录可能在 A 之前到达。如果没有客户机的额外约束（例如，在发出 B 之前等待 A 的完成，或编码显式依赖），完成队列的顺序不足以强制该依赖关系。因此，A 是不正确的。\n\nB. 假设客户机阻塞等待句柄 $h^\\*$，并拒绝排空其他完成条目。如果虚拟机监控程序首先完成了其他 $n-1$ 个请求，它会尝试将 $n-1$ 个完成记录入队。当 $m  n$ 时，这 $n-1$ 个完成记录可能会填满完成环，因此 $m \\le n-1$ 意味着在 $h^\\*$ 完成之前环已满。如果虚拟机监控程序发布完成记录需要一个可用槽位，它就无法将 $h^\\*$ 的完成记录入队，从而导致循环等待：客户机等待 $h^\\*$；虚拟机监控程序等待环空间；并且没有进展。这满足了 Coffman 条件：互斥（有界的环槽位）、持有并等待（客户机持有配额或锁并等待）、不可抢占（任何一方都不能强迫另一方释放），以及循环等待（客户机等待虚拟机监控程序的完成；虚拟机监控程序等待客户机的排空）。因此 B 是正确的。\n\nC. 释放/获取语义确保当客户机读取句柄 $h$ 的完成记录时，所有在因果上先于释放操作的副作用（包括为 $h$ 所做的设备端工作）都 happen-before 于客户机消费此完成记录的后续计算。这对于保证每个句柄的内存安全是足够的。然而，不同句柄之间的乱序完成问题依然存在，因此依赖关系必须由客户机明确编码：例如，仅在观察到 A 的完成后才发出 B，或插入一个能被虚拟机监控程序识别的屏障操作，以防止 B 的副作用在 A 的副作用之前被发布。因此，只要客户机管理好依赖关系，乱序完成就与安全性兼容。C 是正确的。\n\nD. 该陈述声称只要 $n \\le m$，死锁就不可能发生。虽然 $m \\ge n$ 可以防止纯粹由容量问题引起的完成环已满的死锁（因为虚拟机监控程序最多可以入队 $n$ 个完成记录而不会被阻塞），但死锁仍可能由于其他资源依赖而产生：例如，等待 $h^\\*$ 的客户机线程可能持有一个完成排空线程或回调函数所需的互斥锁，从而导致与 $m$ 无关的循环等待。因此，死锁不可能发生这个一概而论的断言过于绝对。D 是不正确的。\n\nE. 为所有操作强制执行每个虚拟中央处理器（vCPU）的先进先出（First-In-First-Out）完成顺序，意味着虚拟机监控程序必须串行化这些操作在设备端的执行，或者至少串行化完成记录的发布，这在操作服务时间不同时会降低并发性并可能限制吞吐量。允许乱序完成使虚拟机监控程序能够利用并行性并提早完成较短的操作，从而提高吞吐量。通过释放/获取语义和客户机中的显式依赖跟踪，尽管存在乱序完成，内存安全仍然得到保障。E 是正确的。\n\n综上所述，正确的陈述是 B、C 和 E。", "answer": "$$\\boxed{BCE}$$", "id": "3668578"}]}