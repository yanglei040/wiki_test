{"hands_on_practices": [{"introduction": "在设计分布式系统时，必须在成本和可靠性之间做出权衡。本练习将解决系统设计者必须面对的首要问题：“需要多少台机器才能容忍 $f$ 个故障？” 我们将运用多数派法定人数（quorum）的核心原则，推导出著名的 $N=2f+1$ 公式，并进一步量化由此构建的系统的可用性 [@problem_id:3627669]。", "problem": "一个实验室集群使用一种带有多数派法定人数（例如 Paxos 或 Raft）的耐崩溃共识算法来协调操作系统服务。故障模型为仅崩溃模型：故障节点会停止运行或无响应，但不会产生不正确的消息，并且节点在修复后可以恢复。假设节点间的故障是独立的。\n\n您必须确定在发生故障时维持安全性和活性所需的最小集群规模和法定人数，然后估算共识服务的稳态可用性。\n\n仅使用以下基本依据：\n- 法定人数的定义：任何规模足以取得进展的节点子集，并且要求任意两个法定人数必须相交以保证安全性。\n- 活性的要求：在最多发生指定数量的崩溃后，剩余的运行节点子集仍能形成一个法定人数。\n- 针对具有无记忆（指数）时间的独立故障和修复组件的标准可靠性建模，其中长期可用性是组件可运行的时间比例。\n\n执行以下操作：\n1. 对于崩溃容错参数 $f = 2$，确定最小节点数 $N$ 和最小多数派法定人数规模 $q$，使得系统在最多 $f$ 个节点并发崩溃的情况下仍能继续取得进展。\n2. 每个节点的平均无故障时间（MTBF）为 $200$ 小时，平均修复时间（MTTR）为 $10$ 小时。将每个节点建模为在“运行”和“宕机”状态之间独立交替，其故障和修复时间服从指数分布。估算共识服务的稳态可用性（以小数形式，而非百分比），定义为在任意时刻至少有 $q$ 个（共 $N$ 个）节点处于运行状态的概率。\n\n将您的最终答案表示为一行三个值 $\\left(N, q, \\text{availability}\\right)$，其中可用性四舍五入到四位有效数字。最终答案框中不应包含任何单位。", "solution": "该问题提法明确，具有科学依据，并提供了确定集群规模、法定人数规模和系统可用性所需的所有信息。所引用的原则——用于安全性的法定人数相交、用于活性的可生存性以及标准可靠性建模——是分布式系统和可靠性工程的基础。因此，该问题被认为是有效的。\n\n根据问题陈述的要求，解决方案分为两部分。\n\n第 1 部分：确定最小集群规模 $N$ 和法定人数规模 $q$。\n\n该系统采用多数派法定人数共识算法，并且必须能容忍 $f$ 个崩溃故障。必须满足两个基本属性：安全性和活性。\n\n安全性属性要求任意两个法定人数必须有非空交集。对于一个有 $N$ 个节点和统一法定人数规模为 $q$ 的系统，这个条件数学上表示为：\n$$q + q > N \\implies 2q > N$$\n由于 $q$ 必须是整数，这等价于 $q \\ge \\lfloor \\frac{N}{2} \\rfloor + 1$。这就定义了多数派法定人数。\n\n活性属性要求系统在最多 $f$ 个节点并发崩溃的情况下仍能继续取得进展（即形成一个法定人数）。这意味着剩余的运行节点数量必须至少等于一个法定人数的规模：\n$$N - f \\ge q$$\n\n为了找到容忍 $f$ 个故障所需的最小节点数 $N$，我们组合这两个不等式：\n$$N - f \\ge q > \\frac{N}{2}$$\n关注不等式的两端，我们得到：\n$$N - f > \\frac{N}{2}$$\n$$N - \\frac{N}{2} > f$$\n$$\\frac{N}{2} > f$$\n$$N > 2f$$\n由于 $N$ 必须是整数，最小节点数是 $N_{min} = 2f + 1$。\n\n问题陈述系统必须容忍最多 $f = 2$ 个并发崩溃。将该值代入 $N_{min}$ 的表达式中：\n$$N = 2(2) + 1 = 5$$\n所以，所需的最小节点数为 $N = 5$。\n\n在 $N=5$ 的情况下，我们现在可以使用安全性条件来确定最小多数派法定人数规模 $q$：\n$$q = \\lfloor \\frac{N}{2} \\rfloor + 1 = \\lfloor \\frac{5}{2} \\rfloor + 1 = 2 + 1 = 3$$\n因此，最小法定人数规模为 $q = 3$。\n\n我们必须验证此配置 $(N=5, q=3)$ 对于 $f=2$ 也满足活性条件：\n$$N - f \\ge q \\implies 5 - 2 \\ge 3 \\implies 3 \\ge 3$$\n该条件成立。因此，最小集群规模为 $N=5$，最小法定人数规模为 $q=3$。\n\n第 2 部分：估算稳态可用性。\n\n首先，我们计算单个节点的稳态可用性，记为 $A_{node}$。对于一个故障和修复时间服从指数分布的组件，其故障率为 $\\lambda = \\frac{1}{\\text{MTBF}}$，修复率为 $\\mu = \\frac{1}{\\text{MTTR}}$。稳态可用性是节点可运行时间的长期比例，由下式给出：\n$$A_{node} = \\frac{\\mu}{\\lambda + \\mu} = \\frac{\\frac{1}{\\text{MTTR}}}{\\frac{1}{\\text{MTBF}} + \\frac{1}{\\text{MTTR}}}$$\n将分子和分母同乘以 $(\\text{MTBF} \\times \\text{MTTR})$，可简化为：\n$$A_{node} = \\frac{\\text{MTBF}}{\\text{MTBF} + \\text{MTTR}}$$\n给定 MTBF = $200$ 小时，MTTR = $10$ 小时：\n$$A_{node} = \\frac{200}{200 + 10} = \\frac{200}{210} = \\frac{20}{21}$$\n一个节点宕机的概率为 $U_{node} = 1 - A_{node} = 1 - \\frac{20}{21} = \\frac{1}{21}$。\n\n如果至少有一个法定人数的节点在运行，则共识服务可用。当 $N=5$ 且 $q=3$ 时，如果有 $3$、$4$ 或 $5$ 个节点在运行，则服务可用。由于节点故障是独立的，大小为 $N$ 的集群中运行的节点数 $k$ 服从二项分布。恰好有 $k$ 个节点运行的概率由下式给出：\n$$P(k) = \\binom{N}{k} (A_{node})^k (1 - A_{node})^{N-k}$$\n共识服务的可用性 $A_{service}$ 是运行节点数大于或等于 $q$ 的概率：\n$$A_{service} = P(k \\ge q) = \\sum_{k=q}^{N} \\binom{N}{k} (A_{node})^k (1 - A_{node})^{N-k}$$\n代入 $N=5$，$q=3$ 和 $A_{node} = \\frac{20}{21}$：\n$$A_{service} = P(k=3) + P(k=4) + P(k=5)$$\n$$A_{service} = \\binom{5}{3} \\left(\\frac{20}{21}\\right)^3 \\left(\\frac{1}{21}\\right)^{2} + \\binom{5}{4} \\left(\\frac{20}{21}\\right)^4 \\left(\\frac{1}{21}\\right)^{1} + \\binom{5}{5} \\left(\\frac{20}{21}\\right)^5 \\left(\\frac{1}{21}\\right)^{0}$$\n二项式系数为 $\\binom{5}{3} = \\frac{5!}{3!2!} = 10$，$\\binom{5}{4} = 5$ 和 $\\binom{5}{5} = 1$。\n$$A_{service} = 10 \\cdot \\frac{20^3}{21^3} \\cdot \\frac{1^2}{21^2} + 5 \\cdot \\frac{20^4}{21^4} \\cdot \\frac{1^1}{21^1} + 1 \\cdot \\frac{20^5}{21^5} \\cdot \\frac{1^0}{21^0}$$\n$$A_{service} = \\frac{1}{21^5} [10 \\cdot 20^3 + 5 \\cdot 20^4 + 1 \\cdot 20^5]$$\n让我们提出公因式以简化计算：\n$$A_{service} = \\frac{20^3}{21^5} \\left[ 10 + 5 \\cdot 20 + 20^2 \\right]$$\n$$A_{service} = \\frac{8000}{4084101} \\left[ 10 + 100 + 400 \\right]$$\n$$A_{service} = \\frac{8000}{4084101} \\left[ 510 \\right]$$\n$$A_{service} = \\frac{4080000}{4084101}$$\n现在，我们计算其小数值并四舍五入到四位有效数字：\n$$A_{service} \\approx 0.99900076$$\n四舍五入到四位有效数字得到 $0.9990$。\n\n最终结果是 $N=5$，$q=3$，可用性 $\\approx 0.9990$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n5 & 3 & 0.9990\n\\end{pmatrix}\n}\n$$", "id": "3627669"}, {"introduction": "虽然法定人数机制可以保证安全，但许多系统为提高效率采用了基于领导者的方法，如 Raft 或 Paxos。领导者依赖“租约”来确保其权威，但计算机时钟并非完美同步，这使得问题变得复杂。本练习将通过对有界时钟漂移进行建模，探讨这个关键的现实世界问题，并推导出一个安全的操作边界 [@problem_id:3627665]。", "problem": "一个基于集群的服务使用一种基于租约的共识机制，以确保在任何真实时间点，最多只有一个进程将自己视为领导者。每个租约都通过一个受有界时钟漂移影响的本地单调租约计时器进行跟踪。以下假设定义了推理的基本基础。\n\n- 有界时钟漂移：对于任何进程，如果真实时间增加了 $dr$，其本地租约时钟将增加 $d\\ell \\in [(1-\\rho)dr,(1+\\rho)dr]$，其中 $\\rho \\in (0,1)$ 是一个已知的漂移界限。\n- 租约语义：领导者持有领导权，直到其本地租约计时器前进了 $L_{\\ell}$。在一个跟随者收到最近的有效领导者续约消息后，其自身的本地租约计时器必须前进 $L_{f}$，然后才能向另一个领导者授予新租约。\n- 挂起/恢复行为：操作系统 (OS) 可能会将领导者进程挂起一段真实时间 $S$，在此期间领导者的本地租约计时器完全停止（即，在挂起时前进为 $0$），之后进程恢复。本地租约计时器仅在进程未被挂起时，其行为才受限于以 $\\rho$ 为界的漂移。\n- 安全性要求：为保证安全性，旧领导者仍认为其租约有效的区间，与任何跟随者可以认为新领导者租约有效的最早真实时间点之间，不得存在真实时间上的重叠。\n\n假设旧领导者最近的一次续约在真实时间参考点 $r_{0}$ 生效，随后立即被挂起，持续真实时间为 $S$。请从第一性原理和上述假设出发，推导出一个最大安全挂起持续时间 $S_{\\max}$ 的表达式，以确保即使领导者恢复后，在没有额外检查的情况下立即根据其本地租约计时器采取行动，安全性也不会被违反。然后，使用 $\\rho=1\\times 10^{-4}$，$L_{\\ell}=9$ 秒和 $L_{f}=10$ 秒对该表达式进行数值计算。将您的最终数值答案四舍五入到四位有效数字，并以秒为单位表示。", "solution": "本题的求解涉及对一个基于租约的共识协议进行安全分析。首先，我们确认问题的设定是标准的：它基于一个定义明确的有界时钟漂移和进程挂起模型，所有术语都有正式定义，且前提在计算机科学领域是科学合理的。问题描述完整，没有不一致之处。\n\n现在开始求解过程。\n\n安全性要求规定，在真实时间中，不能存在两个不同进程同时认为自己是领导者的情况。这意味着旧领导者认为其租约有效的真实时间区间必须在新领导者可以被建立的真实时间区间开始之前或恰好在该时刻结束。\n\n设 $r$ 表示真实时间。参考点是 $r_0$，即旧领导者租约续约生效的真实时间。所有其他时间都相对于 $r_0$ 进行度量。\n\n**1. 旧领导者租约到期分析**\n\n设旧领导者为 $P_{old}$。其租约在其本地租约计时器前进了 $L_{\\ell}$ 之前一直有效。根据题目，在真实时间 $r_0$ 时，$P_{old}$ 被挂起，持续真实时间为 $S$。在此挂起期间，其本地时钟不前进。进程在真实时间 $r_0 + S$ 恢复。\n\n为了找到最大安全挂起时间 $S_{\\max}$，我们必须考虑最坏情况。$P_{old}$ 仍认为其租约有效的最晚可能真实时间，发生在它的本地时钟相对于真实时间以前进最慢的速率运行时。\n\n当进程运行时，本地时间增量 $d\\ell$ 与真实时间增量 $dr$ 之间的关系由 $d\\ell \\in [(1-\\rho)dr, (1+\\rho)dr]$ 给出。本地时钟前进的最慢速率是 $d\\ell = (1-\\rho)dr$。\n\n为了累积 $L_{\\ell}$ 的本地时间，进程必须运行一段真实时间 $\\Delta r_{run}$，由下式给出：\n$$L_{\\ell} = (1-\\rho) \\Delta r_{run}$$\n$$\\Delta r_{run} = \\frac{L_{\\ell}}{1-\\rho}$$\n从租约在 $r_0$ 开始到其到期所经过的总真实时间是挂起持续时间 $S$ 和运行时间 $\\Delta r_{run}$ 的总和。因此，旧领导者租约到期的最晚真实时间，我们记为 $r_{end,old}$，是：\n$$r_{end,old} = r_0 + S + \\Delta r_{run} = r_0 + S + \\frac{L_{\\ell}}{1-\\rho}$$\n\n**2. 新领导者租约开始分析**\n\n只有在一个跟随者进程授予新领导者 $P_{new}$ 一个新租约之后，它才能被选举出来。一个跟随者在从 $P_{old}$ 收到最后一条续约消息后，直到其自身的本地计时器前进了 $L_{f}$，才会授予新租约。\n\n为了找到可以授予新租约的最早时刻，我们必须考虑本地时钟前进速率最快的那个跟随者。这代表了对安全性最危险的场景。我们假设跟随者的计时器在真实时间参考点 $r_0$ 开始计时。接收续约消息的任何网络延迟只会推迟这个时间，从而使系统更安全。因此，将跟随者的开始时间视为 $r_0$ 是正确的、符合最坏情况的假设。\n\n一个跟随者本地时钟前进的最快速率是 $d\\ell = (1+\\rho)dr$。为了累积 $L_{f}$ 的本地时间，必须经过一段真实时间 $\\Delta r_{wait}$：\n$$L_{f} = (1+\\rho) \\Delta r_{wait}$$\n$$\\Delta r_{wait} = \\frac{L_{f}}{1+\\rho}$$\n任何跟随者可以授予新租约的最早真实时间，记为 $r_{start,new}$，是：\n$$r_{start,new} = r_0 + \\Delta r_{wait} = r_0 + \\frac{L_{f}}{1+\\rho}$$\n这是新领导者的租约可能生效的最早时间。\n\n**3. 最大安全挂起时间 ($S_{\\max}$) 的推导**\n\n安全性要求是两个领导权周期之间没有真实时间上的重叠。这意味着旧领导者的租约必须不迟于新领导者租约可以开始的时刻到期：\n$$r_{end,old} \\le r_{start,new}$$\n代入上面推导出的表达式：\n$$r_0 + S + \\frac{L_{\\ell}}{1-\\rho} \\le r_0 + \\frac{L_{f}}{1+\\rho}$$\n$r_0$ 项从两边消去。我们现在可以解出挂起持续时间 $S$：\n$$S \\le \\frac{L_{f}}{1+\\rho} - \\frac{L_{\\ell}}{1-\\rho}$$\n最大安全挂起持续时间 $S_{\\max}$ 是这个不等式的上界：\n$$S_{\\max} = \\frac{L_{f}}{1+\\rho} - \\frac{L_{\\ell}}{1-\\rho}$$\n这个表达式可以合并成一个单独的分数：\n$$S_{\\max} = \\frac{L_{f}(1-\\rho) - L_{\\ell}(1+\\rho)}{(1+\\rho)(1-\\rho)} = \\frac{(L_{f} - L_{\\ell}) - (L_{f} + L_{\\ell})\\rho}{1 - \\rho^2}$$\n\n**4. 数值计算**\n\n题目提供了以下数值：$\\rho = 1 \\times 10^{-4}$，$L_{\\ell} = 9$ 秒，以及 $L_{f} = 10$ 秒。\n我们将这些值代入 $S_{\\max}$ 的表达式中：\n$$S_{\\max} = \\frac{10}{1 + 1 \\times 10^{-4}} - \\frac{9}{1 - 1 \\times 10^{-4}}$$\n$$S_{\\max} = \\frac{10}{1.0001} - \\frac{9}{0.9999}$$\n我们可以计算这个表达式：\n$$S_{\\max} = \\frac{10 \\times 0.9999 - 9 \\times 1.0001}{1.0001 \\times 0.9999}$$\n$$S_{\\max} = \\frac{9.999 - 9.0009}{0.99999999}$$\n$$S_{\\max} = \\frac{0.9981}{0.99999999}$$\n$$S_{\\max} \\approx 0.998100009981... \\text{ 秒}$$\n题目要求答案四舍五入到四位有效数字。前四位有效数字是 $9, 9, 8, 1$。其后的数字是 $0$，所以我们向下取整。\n$$S_{\\max} \\approx 0.9981 \\text{ 秒}$$", "answer": "$$\\boxed{0.9981}$$", "id": "3627665"}, {"introduction": "共识协议需要对故障（尤其是领导者崩溃）作出反应，但系统如何“知道”领导者已经崩溃？本练习超越了简单的超时机制，探讨了一种更复杂的“累积型”故障检测器的设计。你将运用概率论和优化方法，确定一个理想的怀疑阈值，以在快速检测和错误警报风险之间取得平衡 [@problem_id:3627694]。", "problem": "您正在设计一个操作系统（OS）级别的监控组件，该组件使用扩展伯克利数据包过滤器（eBPF）程序来为领导者心跳的到达间隔时间添加时间戳并导出这些数据。这些测量值将输入一个累积故障检测器，其怀疑级别为 $\\phi(t)$。当 $\\phi(t)$ 超过阈值 $\\Phi$ 时，该检测器会在一个共识模块中触发领导者选举。您将假设来自健康领导者的心跳到达遵循速率为 $\\lambda$（单位：$\\mathrm{s}^{-1}$）的泊松过程，这意味着到达间隔时间是独立同分布的指数随机变量，参数为 $\\lambda$。\n\n基本核心定义：\n- 对于速率为 $\\lambda$ 的泊松过程，其到达间隔时间随机变量 $X$ 的生存函数为 $\\Pr\\{X > x\\} = e^{-\\lambda x}$（当 $x \\ge 0$ 时）。\n- 累积故障检测器定义为 $\\phi(t) = -\\log_{10} \\Pr\\{X > t - t_{\\text{last}}\\}$，其中 $t_{\\text{last}}$ 是最后一次观测到的心跳的时间戳。在指数模型下，对于经过的时间 $x = t - t_{\\text{last}}$，该式变为 $\\phi(x) = -\\log_{10}(e^{-\\lambda x}) = \\dfrac{\\lambda x}{\\ln 10}$。\n- 当 $\\phi(t)$ 首次超过一个恒定阈值 $\\Phi$ 时，共识模块会发起一次领导者选举。\n\n设计目标：\n- 您必须选择怀疑阈值 $\\Phi$，以最小化错误的领导者选举，同时保证在真实领导者崩溃情况下的检测时间要求。\n\n用于评估的可量化定义：\n- 检测时间要求：如果领导者确实发生故障（停止发送心跳），则怀疑时间是第一个使得 $\\phi(x^{\\ast}) = \\Phi$ 的穿越时间 $x^{\\ast}$。在指数模型下，这意味着 $x^{\\ast} = \\dfrac{\\Phi \\ln 10}{\\lambda}$。为保证在 $D$ 秒内产生怀疑，其充分必要条件是 $x^{\\ast} \\le D$，即 $\\Phi \\le \\dfrac{\\lambda D}{\\ln 10}$。\n- 监控周期内的错误选举模型：当领导者健康时，如果 $\\phi(t)$ 在下一次心跳到达前超过了 $\\Phi$，则会发生一次错误的领导者选举。对于指数分布的 $X$，每个间隔的错误怀疑概率为 $\\Pr\\{X > x^{\\ast}\\} = 10^{-\\Phi}$。在一个长度为 $H$ 秒的监控周期内，预期的间隔机会数为 $\\lambda H$，周期内至少发生一次错误选举的概率为 $p(H,\\Phi) = 1 - \\exp\\!\\left(-\\lambda H \\cdot 10^{-\\Phi}\\right)$。\n\n优化问题：\n- 在满足检测时间约束 $x^{\\ast} \\le D$ 的条件下，选择 $\\Phi$ 以最小化 $p(H,\\Phi)$。从第一性原理出发，论证为什么最优选择位于约束的边界上，并计算由此产生的最优 $\\Phi^{\\ast}$，作为 $\\lambda$ 和 $D$ 的函数。\n\n实现任务：\n- 编写一个完整的程序，为每个提供的测试用例计算最优阈值 $\\Phi^{\\ast}$，并将所有结果输出到单行中。\n\n输入由问题固定；您的程序不得读取任何输入。使用以下测试套件，其中 $\\lambda$ 的单位是 $\\mathrm{s}^{-1}$，$D$ 和 $H$ 的单位是 $\\mathrm{s}$，输出 $\\Phi^{\\ast}$ 无单位：\n- 测试用例 1（通用“理想路径”）：$\\lambda = 1.0$, $D = 2.0$, $H = 60.0$。\n- 测试用例 2（边界：非常紧凑的检测时间）：$\\lambda = 2.0$, $D = 0.1$, $H = 60.0$。\n- 测试用例 3（低心跳率）：$\\lambda = 0.5$, $D = 5.0$, $H = 120.0$。\n- 测试用例 4（高心跳率和宽松的检测时间）：$\\lambda = 5.0$, $D = 8.0$, $H = 30.0$。\n\n您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，每个 $\\Phi^{\\ast}$ 值都四舍五入到小数点后恰好六位数字（例如，$[\\;0.123456,1.000000,2.500000\\;]$）。方括号内不得有空格。\n\n交付成果：\n- 一个可编译的单一程序，为每个测试用例计算 $\\Phi^{\\ast}$ 并以所要求的确切格式打印结果。不允许用户输入。所有常量必须嵌入到程序中。", "solution": "所述问题构成一个定义明确的约束优化问题。我们的任务是为累积故障检测器选择一个怀疑阈值 $\\Phi$，以最小化错误领导者选举的概率，同时满足对真实故障检测时间的约束。\n\n各量定义如下：\n- 来自健康领导者的心跳速率为 $\\lambda$，遵循泊松过程。\n- 心跳之间的时间间隔 $X$ 是一个指数随机变量，其概率密度函数为 $f(x) = \\lambda e^{-\\lambda x}$，生存函数为 $\\Pr\\{X > x\\} = e^{-\\lambda x}$（当 $x \\ge 0$ 时）。\n- 自上次心跳以来经过时间 $x$ 后的怀疑级别为 $\\phi(x) = \\dfrac{\\lambda x}{\\ln 10}$。\n- 当 $\\phi(x)$ 超过阈值 $\\Phi$ 时，将触发领导者选举。发生这种情况的时间 $x^{\\ast}$ 可通过求解 $\\Phi = \\phi(x^{\\ast})$ 得到，即 $x^{\\ast} = \\dfrac{\\Phi \\ln 10}{\\lambda}$。\n- 检测时间约束要求必须在 $D$ 秒内检测到真实故障。这要求怀疑时间 $x^{\\ast}$ 不超过 $D$，即 $x^{\\ast} \\le D$。代入 $x^{\\ast}$ 的表达式，我们得到对 $\\Phi$ 的约束：\n$$ \\dfrac{\\Phi \\ln 10}{\\lambda} \\le D \\implies \\Phi \\le \\dfrac{\\lambda D}{\\ln 10} $$\n由于对于任何非零的经过时间，怀疑级别必须为正，因此阈值的定义域为 $\\Phi > 0$。\n\n- 在时间范围 $H$ 内至少发生一次错误选举（即领导者健康时触发了怀疑）的概率由我们希望最小化的目标函数给出：\n$$ p(H,\\Phi) = 1 - \\exp\\!\\left(-\\lambda H \\cdot 10^{-\\Phi}\\right) $$\n\n因此，优化问题是：\n关于 $\\Phi$ 最小化 $p(H,\\Phi)$，约束条件为 $0  \\Phi \\le \\dfrac{\\lambda D}{\\ln 10}$。\n\n为解决此问题，我们分析目标函数 $p(H,\\Phi)$ 的行为。\n让我们考虑函数 $p(\\Phi) = 1 - \\exp(-C \\cdot 10^{-\\Phi})$，其中 $C = \\lambda H$ 是一个正常数。\n要最小化 $p(\\Phi)$，我们必须最大化从 1 中减去的项，即 $\\exp(-C \\cdot 10^{-\\Phi})$。\n指数函数 $e^z$ 是其参数 $z$ 的严格递增函数。因此，最大化 $e^z$ 等价于最大化其参数 $z$。在我们的例子中，参数是 $z = -C \\cdot 10^{-\\Phi}$。\n因为 $C$ 是一个正常数，所以最大化 $-C \\cdot 10^{-\\Phi}$ 等价于最小化 $C \\cdot 10^{-\\Phi}$。\n由于 $C = \\lambda H  0$，最小化 $C \\cdot 10^{-\\Phi}$ 等价于最小化项 $10^{-\\Phi}$。\n\n函数 $h(\\Phi) = 10^{-\\Phi} = \\left(\\frac{1}{10}\\right)^{\\Phi}$ 是一个底数在 0 和 1 之间的标准指数函数。这类函数对于所有实数 $\\Phi$ 都是严格递减的。\n或者，我们可以分析它关于 $\\Phi$ 的导数：\n$$ \\dfrac{d}{d\\Phi} (10^{-\\Phi}) = 10^{-\\Phi} \\ln(10) \\cdot (-1) = -\\ln(10) \\cdot 10^{-\\Phi} $$\n由于对于所有实数 $\\Phi$，$\\ln(10)  0$ 且 $10^{-\\Phi}  0$，所以导数始终为负。导数严格为负的函数是严格递减的。\n\n这就证明了我们的原始目标函数 $p(H,\\Phi)$ 是 $\\Phi$ 的严格递减函数。要在一个给定区间上最小化一个严格递减的函数，必须选择该区间内其参数的最大可能值。\n\n$\\Phi$ 的允许区间由检测时间约束定义：\n$$ 0  \\Phi \\le \\dfrac{\\lambda D}{\\ln 10} $$\n在这个区间内，$\\Phi$ 的最大值出现在边界上。因此，在满足检测时间要求的同时最小化错误选举概率的最优阈值 $\\Phi^{\\ast}$ 是：\n$$ \\Phi^{\\ast} = \\dfrac{\\lambda D}{\\ln 10} $$\n这个结果直观上是正确的。一个更高的阈值 $\\Phi$ 会使系统不那么“容易触发”，从而降低错误怀疑的发生率。最优策略是将阈值设置得尽可能高，直到达到在时间 $D$ 内检测到真实故障的要求所施加的限制。监控周期 $H$ 会影响错误选举概率 $p(H, \\Phi)$ 的值，但它不影响最优阈值 $\\Phi^{\\ast}$ 的选择，后者完全由每个时间间隔内检测时间与假阳性之间的权衡决定。", "answer": "[0.868589,0.086859,1.085736,17.371779]", "id": "3627694"}]}