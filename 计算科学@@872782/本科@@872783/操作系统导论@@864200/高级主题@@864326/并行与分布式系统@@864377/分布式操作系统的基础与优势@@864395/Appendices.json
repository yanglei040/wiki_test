{"hands_on_practices": [{"introduction": "分布式计算中的一个基本权衡是：在本地节点上执行任务，还是将其迁移到可能更快的远程节点上。这个决策并非总是显而易见的，因为它涉及到计算速度增益与网络通信成本之间的平衡。这个练习 [@problem_id:3644955] 将指导你推导出一个精确的决策规则，帮助你确定何时迁移一个进程才能真正缩短其完成时间，这是设计高效负载均衡和任务调度系统的核心技能。", "problem": "一个分布式操作系统 (DOS) 可以将一个计算密集型进程从本地节点迁移到远程节点，以减少其完成时间。假设该进程的作业大小为 $x$，以本地中央处理器 (CPU) 的秒数计量，这意味着如果它完全在本地节点上执行，将需要本地处理器 $x$ 秒的 CPU 时间。远程节点提供一个相对于本地节点的速率比 $\\rho$，这意味着远程处理器的执行速率是本地处理器的 $\\rho$ 倍，且 $\\rho  1$。将进程迁移到远程节点的行为会产生一次性的网络和设置成本 $C_{n}$（以秒为单位），其中包括状态转移和远程调度的开销。假设计算和通信之间没有重叠，计算量在迁移过程中保持不变，并且两个节点都没有排队延迟。\n\n仅使用“执行时间等于工作量除以速度”以及“独立开销会累加到完成时间上”这两个基本事实，推导出一个决策规则，该规则能保证通过迁移可以净减少完成时间。将你的答案表示为阈值作业大小 $x^{*}$（以秒为单位），形式为包含 $\\rho$ 和 $C_{n}$ 的符号表达式的封闭形式，使得当且仅当 $x  x^{*}$ 时，迁移会严格减少完成时间。请精确给出最终答案，不要进行近似。将该阈值以秒为单位表示。", "solution": "该问题要求推导一个用于分布式系统中进程迁移的决策规则。该规则应确定一个阈值作业大小，记为 $x^*$，当作业大小超过该阈值时，将进程迁移到远程节点会严格减少其完成时间。推导将基于所提供的基本原则和变量。\n\n首先，我们为两种可能的执行场景（本地执行和远程执行）形式化其完成时间。\n\n设 $T_{local}$ 为进程完全在本地节点上执行的总完成时间。问题将作业大小 $x$ 定义为进程在本地节点上所需的 CPU 时间（秒）。因此，本地执行的完成时间为：\n$$T_{local} = x$$\n\n接下来，设 $T_{remote}$ 为进程被迁移到远程节点时的总完成时间。这个时间段包括两个独立且不重叠的部分：迁移开销和远程计算时间。\n\n迁移成本是一个固定的、一次性的开销，给定为 $C_{n}$ 秒。\n\n远程节点上的计算时间取决于作业的工作内容和远程处理器的速度。设 $W$ 代表进程的总计算工作量。由于该进程在本地处理器上需要 $x$ 秒，我们可以将工作量表示为 $W = S_{local} \\cdot x$，其中 $S_{local}$ 是本地处理器的执行速度（例如，每秒指令数）。远程处理器的速度是本地的 $\\rho$ 倍，因此其速度为 $S_{remote} = \\rho \\cdot S_{local}$。远程节点上的执行时间是工作量除以远程速度：\n$$T_{compute\\_remote} = \\frac{W}{S_{remote}} = \\frac{S_{local} \\cdot x}{\\rho \\cdot S_{local}} = \\frac{x}{\\rho}$$\n问题陈述计算和通信之间没有重叠。因此，远程执行场景的总完成时间是迁移开销和远程计算时间之和：\n$$T_{remote} = C_{n} + T_{compute\\_remote} = C_{n} + \\frac{x}{\\rho}$$\n\n当且仅当完成时间被严格减少时，迁移才是有利的。这可以用以下不等式表示：\n$$T_{remote}  T_{local}$$\n代入 $T_{remote}$ 和 $T_{local}$ 的推导表达式：\n$$C_{n} + \\frac{x}{\\rho}  x$$\n为了找到阈值作业大小 $x^*$，我们必须解这个关于 $x$ 的不等式。我们首先分离包含 $x$ 的项：\n$$C_{n}  x - \\frac{x}{\\rho}$$\n从右侧提取公因式 $x$ 可得：\n$$C_{n}  x \\left(1 - \\frac{1}{\\rho}\\right)$$\n为了化简括号中的项，我们进行通分：\n$$C_{n}  x \\left(\\frac{\\rho - 1}{\\rho}\\right)$$\n问题陈述中提到远程节点速度更快，即 $\\rho  1$。这意味着 $\\rho - 1$ 项是正数。由于 $\\rho$ 也是正数，分数 $\\frac{\\rho-1}{\\rho}$ 是一个正量。因此，我们可以在不等式两边同乘以其倒数 $\\frac{\\rho}{\\rho-1}$，而无需改变不等号的方向：\n$$C_{n} \\cdot \\frac{\\rho}{\\rho - 1}  x$$\n这个不等式可以重写为：\n$$x  C_{n} \\frac{\\rho}{\\rho - 1}$$\n这个表达式定义了迁移有利的条件。问题要求的是阈值作业大小 $x^*$，使得当且仅当 $x  x^*$ 时，迁移才是严格有利的。通过将我们的结果与这个条件进行比较，我们可以确定 $x^*$ 的表达式：\n$$x^* = C_{n} \\frac{\\rho}{\\rho - 1}$$\n这就是阈值作业大小的封闭形式符号表达式。如果作业大小 $x$ 大于此值，那么由更快的远程处理器节省的时间将超过固定的迁移成本。", "answer": "$$\\boxed{C_{n} \\frac{\\rho}{\\rho - 1}}$$", "id": "3644955"}, {"introduction": "构建分布式系统的主要动机之一是通过冗余来实现容错。通过在多个节点上部署服务的副本，即使部分节点发生故障，整个系统也能继续提供服务。这个练习 [@problem_id:3645021] 将让你定量地分析副本数量与服务可用性之间的关系，并在此过程中发现“收益递减”这一重要原则，这对于在成本和可靠性之间做出明智决策至关重要。", "problem": "一个分布式操作系统 (DOS) 将一个无状态、以读为主的服务以 $k$ 个相同副本的形式部署在多个独立节点上。在一个固定的任务窗口期内，每个节点不可用的概率为 $p \\in (0,1)$，且与其他所有节点相互独立。如果在该窗口期内至少有 $1$ 个副本可用，则该服务被认为是可用的。假设不存在相关故障，并忽略网络分区和请求路由延迟。\n\n仅从概率公理和独立性定义出发，完成以下任务：\n\n1. 推导服务的精确可用性 $A(k)$，将其表示为 $k$ 和 $p$ 的函数。\n2. 使用您得到的 $A(k)$ 表达式，推导增加第 $k$ 个副本所获得的边际可用性增益 $\\Delta(k)$，其定义为 $\\Delta(k) = A(k) - A(k-1)$（对于 $k \\ge 1$，并约定 $A(0)=0$）。然后，确定比率 $\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)}$（对于 $k \\ge 1$），并解释随着 $k$ 的增加，这对收益递减意味着什么。\n3. 对于一个 $p = 0.02$ 的具体系统，确定最小的整数 $k$，使得增加第 $k$ 个副本带来的增量增益低于目标阈值 $\\varepsilon = 1.0 \\times 10^{-6}$，即 $\\Delta(k)  \\varepsilon$。\n\n报告您最终的答案，即在参数 $p = 0.02$ 和 $\\varepsilon = 1.0 \\times 10^{-6}$ 下 $k$ 的整数值。除精确整数外，无需进行舍入。", "solution": "问题陈述已经过分析，被认为是有效的。它在基础概率论方面有科学依据，问题提出得当，目标明确，数据充分，并以客观、正式的语言表述。因此，我们可以开始求解。\n\n根据问题陈述的要求，解答分为三个部分。\n\n### 第 1 部分：服务可用性 $A(k)$ 的推导\n\n设 $U_i$ 为第 $i$ 个副本在任务窗口期内不可用的事件，其中 $i \\in \\{1, 2, \\dots, k\\}$。问题陈述指出，此事件的概率为 $p$。\n$$P(U_i) = p$$\n因此，第 $i$ 个副本可用的概率，我们用其对立事件 $U_i^c$ 表示，为：\n$$P(U_i^c) = 1 - p$$\n服务的可用性定义为至少有一个副本可用。计算其对立事件（即服务不可用）的概率更为直接。当且仅当所有 $k$ 个副本都不可用时，服务才不可用。这对应于事件 $U_1, U_2, \\dots, U_k$ 的交集。\n$$P(\\text{服务不可用}) = P(U_1 \\cap U_2 \\cap \\dots \\cap U_k)$$\n问题明确指出节点是独立的。因此，事件 $U_i$ 是相互独立的。它们交集的概率是它们各自概率的乘积：\n$$P(\\text{服务不可用}) = \\prod_{i=1}^{k} P(U_i) = \\prod_{i=1}^{k} p = p^k$$\n服务的可用性 $A(k)$ 是指服务可用的概率。这个概率等于 $1$ 减去服务不可用的概率。\n$$A(k) = 1 - P(\\text{服务不可用})$$\n代入推导出的表达式，可得到精确可用性作为 $k$ 和 $p$ 的函数：\n$$A(k) = 1 - p^k$$\n\n### 第 2 部分：边际增益 $\\Delta(k)$ 与比率 $\\rho(k)$ 的推导\n\n边际可用性增益 $\\Delta(k)$ 定义为 $\\Delta(k) = A(k) - A(k-1)$（对于 $k \\ge 1$），并约定 $A(0) = 0$。\n使用 $A(k)$ 的表达式：\n$$A(k) = 1 - p^k$$\n$$A(k-1) = 1 - p^{k-1}$$\n将这些代入 $\\Delta(k)$ 的定义中：\n$$\\Delta(k) = (1 - p^k) - (1 - p^{k-1}) = 1 - p^k - 1 + p^{k-1} = p^{k-1} - p^k$$\n提出公因式 $p^{k-1}$：\n$$\\Delta(k) = p^{k-1}(1-p)$$\n这个表达式代表了通过增加第 $k$ 个副本所获得的服务可用性的增量概率。它恰好是前 $k-1$ 个副本全部失败（概率为 $p^{k-1}$）且第 $k$ 个副本可用（概率为 $1-p$）的概率。\n\n接下来，我们确定比率 $\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)}$（对于 $k \\ge 1$）。\n首先，我们将 $\\Delta(k)$ 公式中的 $k$ 替换为 $k+1$，求出 $\\Delta(k+1)$ 的表达式：\n$$\\Delta(k+1) = p^{(k+1)-1}(1-p) = p^k(1-p)$$\n现在，我们构建这个比率：\n$$\\rho(k) = \\frac{\\Delta(k+1)}{\\Delta(k)} = \\frac{p^k(1-p)}{p^{k-1}(1-p)}$$\n由于 $p \\in (0,1)$，项 $1-p$ 非零，可以消去。我们得到：\n$$\\rho(k) = \\frac{p^k}{p^{k-1}} = p^{k-(k-1)} = p^1 = p$$\n比率 $\\rho(k)$ 是一个常数，等于 $p$。由于 $p \\in (0,1)$，这意味着增加一个副本所带来的边际增益总是前一个副本边际增益的一个固定比例 $p$。这表示边际增益呈几何级数递减，是收益递减原则的一个典型例子。每增加一个后续副本，对系统整体可用性的贡献都逐步减少。\n\n### 第 3 部分：最小副本数 $k$ 的确定\n\n我们需要找到最小的整数 $k$，使得增量增益 $\\Delta(k)$ 低于阈值 $\\varepsilon$。条件是：\n$$\\Delta(k)  \\varepsilon$$\n代入 $\\Delta(k)$ 的表达式以及给定值 $p = 0.02$ 和 $\\varepsilon = 1.0 \\times 10^{-6}$：\n$$p^{k-1}(1-p)  \\varepsilon$$\n$$(0.02)^{k-1}(1 - 0.02)  1.0 \\times 10^{-6}$$\n$$(0.02)^{k-1}(0.98)  10^{-6}$$\n为了解出 $k$，我们首先分离出包含指数的项：\n$$(0.02)^{k-1}  \\frac{10^{-6}}{0.98}$$\n现在我们对两边取自然对数 ($\\ln$)。由于自然对数是严格递增函数，不等号的方向保持不变。\n$$\\ln\\left((0.02)^{k-1}\\right)  \\ln\\left(\\frac{10^{-6}}{0.98}\\right)$$\n使用对数性质 $\\ln(a^b) = b\\ln(a)$：\n$$(k-1)\\ln(0.02)  \\ln(10^{-6}) - \\ln(0.98)$$\n为了分离出 $(k-1)$，我们必须除以 $\\ln(0.02)$。关键要注意的是，由于 $0.02  1$，$\\ln(0.02)$ 的值为负。不等式两边同除以一个负数会改变不等号的方向。\n$$k-1  \\frac{\\ln(10^{-6}) - \\ln(0.98)}{\\ln(0.02)}$$\n现在，我们可以解出 $k$：\n$$k  1 + \\frac{\\ln(10^{-6}) - \\ln(0.98)}{\\ln(0.02)}$$\n我们来计算右边的表达式：\n$$k  1 + \\frac{-6\\ln(10) - \\ln(0.98)}{\\ln(0.02)}$$\n使用计算值，$\\ln(10) \\approx 2.302585$，$\\ln(0.98) \\approx -0.0202027$，以及 $\\ln(0.02) \\approx -3.912023$。\n$$k  1 + \\frac{-6(2.302585) - (-0.0202027)}{-3.912023}$$\n$$k  1 + \\frac{-13.815510 + 0.0202027}{-3.912023}$$\n$$k  1 + \\frac{-13.7953073}{-3.912023} \\approx 1 + 3.52638$$\n$$k  4.52638$$\n由于 $k$ 必须是整数，满足此不等式的最小整数 $k$ 是 $5$。\n为了验证，当 $k=5$ 时，增益为 $\\Delta(5) = (0.02)^{4}(0.98) = (1.6 \\times 10^{-7})(0.98) = 1.568 \\times 10^{-7}$，小于 $\\varepsilon = 1.0 \\times 10^{-6}$。\n当 $k=4$ 时，增益为 $\\Delta(4) = (0.02)^{3}(0.98) = (8.0 \\times 10^{-6})(0.98) = 7.84 \\times 10^{-6}$，不小于 $\\varepsilon$。\n因此，最小的整数确实是 $k=5$。", "answer": "$$\\boxed{5}$$", "id": "3645021"}, {"introduction": "分布式系统虽然强大，但也引入了一些微妙的性能陷阱。其中一个典型问题是“伪共享”（false sharing），它常见于分布式共享内存（DSM）系统中，指的是由于内存对齐不当，导致多个节点在无实质数据竞争的情况下，仍因缓存一致性协议而产生不必要的通信开销。通过这个练习 [@problem_id:3644993]，你将学会如何计算这种开销，并思考如何通过调整数据布局来有效避免它，从而提升程序性能。", "problem": "一个并行程序运行在一个分布式共享内存（DSM）系统上，该系统以页面为粒度实现基于失效的一致性协议。系统的页面大小为 $P = 4096$ 字节。系统中有 $N = 8$ 个节点，每个节点运行一个线程。每个线程每秒对一个大型共享数组的元素执行 $r = 5.0 \\times 10^{5}$ 次写操作。该数组是页面对齐的。由于线程在页面内独立放置元素，任何给定的写操作有 $\\phi = 0.12$ 的伪共享概率，即其目标页面在没有真实数据依赖的情况下被其他节点并发缓存。当发生此类伪共享事件时，失效协议会向该页面的每个远程共享者发送一条失效消息和一条确认消息。一个伪共享页面的平均远程共享者数量为 $\\bar{s} = 3$。\n\n从基于失效的一致性协议中的期望和消息计数的首要原则出发，推导并计算在这些条件下由伪共享引起的预期一致性消息速率（以每秒消息数计）。用每秒消息数表示您的最终数值答案。\n\n然后，基于DSM一致性的页面级特性和给定的页面大小 $P$，提出一种具体的可以防止伪共享从而降低 $\\phi$ 的数据布局转换方法，并定性解释为什么它在DSM系统中是有效的。您可以假设只有一个线程需要写入数组元素的给定子集，并且可以在页面边界上对齐和分区数据以隔离写入者。\n\n请仅提供任何布局更改前的预期一致性消息速率，以每秒消息数为单位，作为您的最终答案。无需四舍五入，最终方框内不应包含单位。", "solution": "在尝试求解之前，对问题陈述的有效性进行评估。\n\n给定的参数如下：\n- 页面大小：$P = 4096$ 字节\n- 节点/线程数：$N = 8$\n- 每个线程的写速率：$r = 5.0 \\times 10^{5}$ 次写入/秒\n- 伪共享概率：$\\phi = 0.12$\n- 伪共享页面的平均远程共享者数量：$\\bar{s} = 3$\n- 一致性协议：基于失效\n- 每个伪共享事件中每个远程共享者的消息数：1条失效消息和1条确认消息。\n\n该问题在科学上植根于并行计算机体系结构和分布式操作系统的原理，特别是关于分布式共享内存（DSM）系统中的缓存一致性。页面粒度上的伪共享概念是一个众所周知的性能问题。该问题提法明确，为得到唯一的定量解提供了所有必要的参数（$N$、$r$、$\\phi$、$\\bar{s}$和协议消息计数）。语言客观、精确。所提供的数据在数值上是一致的，并且对于高性能分布式系统来说是合理的。不存在科学缺陷、矛盾或含糊不清之处。因此，该问题被认为是有效的。\n\n按照问题陈述的要求，解决方案分两部分进行。\n\n第1部分：计算预期的一致性消息速率。\n由伪共享引起的总一致性消息速率可以从首要原则出发，通过考虑系统中所有线程的贡献来推导。\n\n首先，我们确定整个系统每秒发生的写操作总数。有 $N$ 个线程，每个线程每秒执行 $r$ 次写操作，则整个系统的总写速率 $R_{write}$ 为：\n$$R_{write} = N \\times r$$\n\n接下来，我们确定这些写操作导致伪共享事件的速率。一次写操作以概率 $\\phi$ 触发一个伪共享事件。因此，伪共享事件的预期速率 $R_{event}$ 是总写速率乘以该概率：\n$$R_{event} = R_{write} \\times \\phi = (N \\times r) \\times \\phi$$\n\n对于每个伪共享事件，基于失效的一致性协议都会生成消息。对一个伪共享页面的写入需要向所有拥有该页面缓存副本的其他节点（远程共享者）发送失效消息。问题陈述指出，对于一个给定的伪共享事件，平均有 $\\bar{s}$ 个远程共享者。协议要求向每个远程共享者发送一条失效消息，并从每个共享者那里接收一条确认消息。因此，每个远程共享者生成的消息数为 $1 + 1 = 2$。\n每个伪共享事件的总消息数 $M_{event}$ 是每个共享者的消息数乘以平均共享者数量：\n$$M_{event} = 2 \\times \\bar{s}$$\n\n最后，每秒的预期一致性消息总速率 $R_{msg}$ 是伪共享事件的速率与每个事件生成的消息数的乘积。\n$$R_{msg} = R_{event} \\times M_{event} = (N \\times r \\times \\phi) \\times (2 \\times \\bar{s})$$\n\n代入给定的数值：\n- $N = 8$\n- $r = 5.0 \\times 10^{5} \\text{ s}^{-1}$\n- $\\phi = 0.12$\n- $\\bar{s} = 3$\n\n我们计算该速率：\n$$R_{msg} = 8 \\times (5.0 \\times 10^{5}) \\times 0.12 \\times (2 \\times 3)$$\n$$R_{msg} = 8 \\times (5.0 \\times 10^{5}) \\times 0.12 \\times 6$$\n$$R_{msg} = 40.0 \\times 10^{5} \\times 0.12 \\times 6$$\n$$R_{msg} = (4.0 \\times 10^{6}) \\times 0.72$$\n$$R_{msg} = 2.88 \\times 10^{6} \\text{ 消息/秒}$$\n\n第2部分：减少伪共享的数据布局转换。\n在基于页面的DSM系统中，伪共享的根本原因是多个被不同线程访问的独立数据项恰好位于同一个内存页面上。一致性协议以 $P=4096$ 字节的页面粒度运行，这意味着它无法区分对同一页面内不同字节的写入。一个线程对页面任何部分的写入都会导致系统将整个页面视为已修改，从而触发对拥有缓存副本的其他线程的失效操作，即使这些线程访问的是该页面内完全不同的数据元素。\n\n防止这种情况的一种具体的数据布局转换方法是**数据填充和对齐**。其策略是确保由不同线程独占写入的共享数组的不相交子集被分配在物理上不同的内存页面上。\n\n转换的实现方式如下：\n假设 $N$ 个线程中的每一个都有一个工作负载，涉及对共享数组的特定、不重叠的分区进行写入，我们必须修改数组的内存分配方式。不应连续分配分区，而是应将每个分区显式地对齐到页面边界。这意味着每个线程可写分区的起始地址必须是页面大小 $P = 4096$ 的倍数。\n\n例如，如果线程0写入 `data_partition_0`，线程1写入 `data_partition_1`，我们应确保 `data_partition_1` 的起始内存地址在 `data_partition_0` 起始地址之后至少 $P$ 字节，并且其本身在 $P$ 字节边界上对齐。如果 `data_partition_0` 的大小不是 $P$ 的整数倍，则必须在其后插入未使用的内存，即“填充”，以强制 `data_partition_1` 在下一个页面边界上开始。\n\n这种转换是有效的，因为它将不同线程的写入目标物理隔离到不同的页面上。当线程 $i$ 写入其数据分区时，它修改的是一个只包含其自身数据的页面。没有其他线程 $j$（其中 $j \\neq i$）会因为自己的写入而有理由缓存这个页面。因此，线程 $i$ 的写入不会触发对线程 $j$ 所需页面的失效操作。这通过确保单个一致性块（一个页面）不包含被多个写入者独立修改的数据，直接解决了伪共享的前提。这种布局更改将伪共享概率 $\\phi$ 降低到接近0，但代价是由于填充而增加了内存消耗。", "answer": "$$\\boxed{2.88 \\times 10^{6}}$$", "id": "3644993"}]}