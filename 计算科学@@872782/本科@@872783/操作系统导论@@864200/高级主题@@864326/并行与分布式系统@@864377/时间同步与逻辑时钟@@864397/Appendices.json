{"hands_on_practices": [{"introduction": "要构建可靠的分布式系统，我们必须首先理解物理时间同步的局限性。本练习探讨了经典的物理时钟同步协议——Cristian算法，但加入了一个现实的转折：网络延迟并非总是对称的。通过从第一性原理出发推导同步误差，您将对真实世界的网络条件如何影响协议的准确性建立起批判性的理解，并学会量化这种不确定性的边界 [@problem_id:3688987]。", "problem": "一个客户端进程 $C$ 试图在现实的网络不对称性条件下，使用 Cristian 算法将其本地物理时钟与参考服务器 $S$ 同步。设 $d_{\\text{forward}}$ 是从 $C$ 到 $S$ 的单向网络延迟，$d_{\\text{backward}}$ 是从 $S$ 到 $C$ 的单向网络延迟，并设 $p$ 是服务器从接收请求到发送回复之间的处理时间。客户端测量此次交换的往返时间 (RTT) 为 $r$，并遵循 Cristian 算法，将其时钟设置为服务器的发送时间加上所测量的往返时间的一半。假设两个时钟以相同的速率运行，并且服务器在发送回复的瞬间为回复加上时间戳。\n\n从第一性原理出发——具体来说，即单向传播延迟、服务器处理时间和 Cristian 算法操作规则的定义——推导在 $d_{\\text{forward}} \\neq d_{\\text{backward}}$ 时产生的同步误差的表达式，然后使用它来计算在某次特定运行中观察到的以下约束条件下的绝对误差的最坏情况界限：\n- 测量的往返时间 $r = 96.0$ 毫秒，\n- 服务器处理时间 $p = 1.2$ 毫秒，\n- 前向延迟 $d_{\\text{forward}} \\in [21.0, 29.0]$ 毫秒，\n- 后向延迟 $d_{\\text{backward}} \\in [60.0, 72.0]$ 毫秒。\n\n假设在此次交换中，实际延迟满足 $d_{\\text{forward}} + d_{\\text{backward}} = r - p$。将您的最终答案表示为以毫秒为单位的最大可能绝对同步误差，并将您的答案四舍五入到三位有效数字。", "solution": "该问题要求在非对称网络延迟下推导 Cristian 算法中的同步误差，并在给定的约束条件下计算其最坏情况界限。\n\n首先，我们基于一个参考物理时间 $t$ 建立一个事件时间线。设服务器时钟 $S$ 为参考，因此其时间为 $S(t) = t$。客户端进程为 $C$。\n事件序列如下：\n1.  在时间 $t_0$，客户端 $C$ 向服务器 $S$ 发送一个同步请求。\n2.  请求在时间 $t_1 = t_0 + d_{\\text{forward}}$ 到达 $S$，其中 $d_{\\text{forward}}$ 是从 $C$ 到 $S$ 的单向延迟。\n3.  服务器处理该请求，耗时 $p$。然后在发送回复的瞬间为回复加上时间戳。这发生在时间 $t_2 = t_1 + p = t_0 + d_{\\text{forward}} + p$。发送回客户端的时间戳是 $T_S = S(t_2) = t_2$。\n4.  回复在时间 $t_3 = t_2 + d_{\\text{backward}} = t_0 + d_{\\text{forward}} + p + d_{\\text{backward}}$ 回到客户端，其中 $d_{\\text{backward}}$ 是从 $S$ 到 $C$ 的单向延迟。\n\n客户端测量的总往返时间 ($r$) 是从发送请求 ($t_0$) 到接收回复 ($t_3$) 之间的时间间隔。\n$$r = t_3 - t_0 = (t_0 + d_{\\text{forward}} + p + d_{\\text{backward}}) - t_0 = d_{\\text{forward}} + p + d_{\\text{backward}}$$\n这个关系与问题中给出的约束条件 $d_{\\text{forward}} + d_{\\text{backward}} = r - p$ 一致。\n\n根据所描述的 Cristian 算法的具体实现，在时间 $t_3$ 收到回复时，客户端将其时钟设置为一个新值 $T_{\\text{new}}$：\n$$T_{\\text{new}} = T_S + \\frac{r}{2}$$\n同步误差（我们用 $\\epsilon$ 表示）是这个新设置的客户端时间与真实物理时间 $t_3$ 之间的差值。\n$$\\epsilon = T_{\\text{new}} - t_3$$\n我们可以用 $T_S$ (即 $t_2$) 和 $d_{\\text{backward}}$ 来表示 $t_3$，即 $t_3 = t_2 + d_{\\text{backward}} = T_S + d_{\\text{backward}}$。将此代入误差方程：\n$$\\epsilon = \\left(T_S + \\frac{r}{2}\\right) - (T_S + d_{\\text{backward}}) = \\frac{r}{2} - d_{\\text{backward}}$$\n为了得到一个用基本延迟和处理时间表示的表达式，我们代入 $r = d_{\\text{forward}} + p + d_{\\text{backward}}$：\n$$\\epsilon = \\frac{1}{2}(d_{\\text{forward}} + p + d_{\\text{backward}}) - d_{\\text{backward}}$$\n化简此表达式得到同步误差：\n$$\\epsilon = \\frac{1}{2}(d_{\\text{forward}} + p - d_{\\text{backward}})$$\n这是同步误差的通用表达式。\n\n接下来，我们必须使用给定的约束条件计算绝对误差 $|\\epsilon|$ 的最坏情况界限：\n- 测量的 RTT: $r = 96.0$ 毫秒\n- 服务器处理时间: $p = 1.2$ 毫秒\n- 前向延迟: $d_{\\text{forward}} \\in [21.0, 29.0]$ 毫秒\n- 后向延迟: $d_{\\text{backward}} \\in [60.0, 72.0]$ 毫秒\n\n这些参数由以下条件关联：\n$$d_{\\text{forward}} + d_{\\text{backward}} = r - p = 96.0 - 1.2 = 94.8 \\text{ ms}$$\n为了找到 $|\\epsilon|$ 的最大值，我们首先找到 $\\epsilon$ 的可能范围。我们可以将 $\\epsilon$ 表示为单个变量（例如 $d_{\\text{forward}}$）的函数。根据和的约束条件，我们有 $d_{\\text{backward}} = 94.8 - d_{\\text{forward}}$。将此代入误差公式：\n$$\\epsilon(d_{\\text{forward}}) = \\frac{1}{2}(d_{\\text{forward}} + p - (94.8 - d_{\\text{forward}})) = \\frac{1}{2}(2d_{\\text{forward}} + p - 94.8)$$\n代入 $p = 1.2$：\n$$\\epsilon(d_{\\text{forward}}) = \\frac{1}{2}(2d_{\\text{forward}} + 1.2 - 94.8) = \\frac{1}{2}(2d_{\\text{forward}} - 93.6) = d_{\\text{forward}} - 46.8$$\n$d_{\\text{forward}}$ 的允许值范围由其给定区间和 $d_{\\text{backward}}$ 约束所隐含的区间的交集确定。\n显式约束是 $d_{\\text{forward}} \\in [21.0, 29.0]$。\n约束条件 $d_{\\text{backward}} \\in [60.0, 72.0]$ 意味着：\n$$60.0 \\le 94.8 - d_{\\text{forward}} \\le 72.0$$\n各部分减去 $94.8$：\n$$60.0 - 94.8 \\le -d_{\\text{forward}} \\le 72.0 - 94.8$$\n$$-34.8 \\le -d_{\\text{forward}} \\le -22.8$$\n乘以 $-1$ 并反转不等号：\n$$22.8 \\le d_{\\text{forward}} \\le 34.8$$\n$d_{\\text{forward}}$ 的有效范围是两个区间的交集：$[21.0, 29.0] \\cap [22.8, 34.8]$，即 $[22.8, 29.0]$。\n所以，$d_{\\text{forward}}$ 必须在 $[22.8, 29.0]$ 范围内。\n\n误差函数 $\\epsilon(d_{\\text{forward}}) = d_{\\text{forward}} - 46.8$ 是 $d_{\\text{forward}}$ 的线性函数。其极值将出现在 $d_{\\text{forward}}$ 有效区间的端点处。\n在下界，$d_{\\text{forward}} = 22.8$：\n$$\\epsilon_{\\text{min}} = 22.8 - 46.8 = -24.0 \\text{ ms}$$\n在上界，$d_{\\text{forward}} = 29.0$：\n$$\\epsilon_{\\text{max}} = 29.0 - 46.8 = -17.8 \\text{ ms}$$\n可能的误差范围是 $\\epsilon \\in [-24.0, -17.8]$。\n最坏情况下的绝对误差是此范围内 $|\\epsilon|$ 的最大值。\n$$|\\epsilon_{\\text{min}}| = |-24.0| = 24.0 \\text{ ms}$$\n$$|\\epsilon_{\\text{max}}| = |-17.8| = 17.8 \\text{ ms}$$\n这两个值的最大值是 $24.0$ ms。\n$$\\max(|\\epsilon|) = 24.0 \\text{ ms}$$\n结果必须四舍五入到三位有效数字。值 $24.0$ 已经是以三位有效数字呈现。", "answer": "$$\\boxed{24.0}$$", "id": "3688987"}, {"introduction": "当物理时间不可靠时，逻辑时钟为事件排序提供了一个稳健的替代方案。本练习将介绍Lamport时钟，它基于“先于发生”（happened-before）关系建立因果顺序。通过一个精心设计的、涉及故意时钟“漂移”的思想实验，您将亲眼观察到因果信息如何在分布式系统中传播并影响未来事件的时间戳，从而巩固Lamport模型的核心原则 [@problem_id:3688949]。", "problem": "考虑一个由 $n$ 个进程组成的分布式系统，这些进程实现 Lamport 逻辑时钟来追踪“发生于前”（happened-before）关系。每个进程 $P_i$ 维护一个逻辑时钟 $L_i$，初始值为 $0$。该系统是异步的，具有可靠的消息传递。假设遵循标准的 Lamport 规则：每发生一个事件，本地时钟就增加；消息携带发送方的时间戳；接收方将其时钟设置为超过其当前值和接收到的时间戳的值。您将设计一个简单的实验，然后引入一个故意的时钟漂移。\n\n实验设置为 $n=3$ 个进程。设进程为 $P_1$、$P_2$ 和 $P_3$。以下事件按顺序在每个进程上发生，消息传递如下所示：\n- 在 $P_1$ 上：事件 $e_1$ (本地)，然后是事件 $e_2$ (发送消息 $m_1$ 给 $P_2$)，之后是事件 $e_3$ (从 $P_3$ 接收消息 $m_3$)。\n- 在 $P_2$ 上：事件 $f_1$ (本地)，然后是事件 $f_2$ (从 $P_1$ 接收消息 $m_1$)，然后是事件 $f_3$ (发送消息 $m_2$ 给 $P_3$)。\n- 在 $P_3$ 上：事件 $g_1$ (本地)，然后是事件 $g_2$ (从 $P_2$ 接收消息 $m_2$)，然后是事件 $g_3$ (发送消息 $m_3$ 给 $P_1$)。\n\n假设消息的传递顺序与上述时间表一致（例如，$m_1$ 在 $e_2$ 发送后于 $f_2$ 被接收，$m_2$ 在 $f_3$ 发送后于 $g_2$ 被接收，而 $m_3$ 在 $g_3$ 发送后于 $e_3$ 被接收）。运行 $1$ 使用标准的 Lamport 时钟，每个事件增加一个单位。然后，在运行 $2$ 中，在 $P_2$ 处引入一个故意的时钟漂移，如下所示：在 $P_2$ 的每个事件之前，该进程执行 $\\delta \\in \\mathbb{N}$ 次虚拟逻辑滴答，使 $L_2$ 增加 $\\delta$ (不产生对其他进程可见的事件)，然后按照标准的 Lamport 规则执行该事件。所有其他进程照常使用单位增量。\n\n问题。比较运行 $1$ 和运行 $2$，在运行 $2$ 中（相对于运行 $1$），哪一组事件的 Lamport 时间戳 $L(\\cdot)$ 会不同，为什么？\n\n选择唯一的最佳答案：\n\nA. 只有发生漂移的进程 $P_2$ 上的事件的时间戳会改变，因为 Lamport 时钟除了在接收时，纯粹是本地的。\n\nB. $P_2$ 上的事件会改变，此外，位于 $P_2$ 上某个事件的传递因果未来中的每个事件（即，对于任何事件 $x$，存在 $P_2$ 上的事件 $y$ 使得 $y \\rightarrow x$）都会改变，而与 $P_2$ 上所有事件并发的事件保持不变。\n\nC. 所有进程上的所有事件都会改变，因为 Lamport 时钟实现了一种形式的全局同步，会将任何漂移传播到整个系统。\n\nD. 只有直接从 $P_2$ 接收消息的接收事件会改变，但超过 $1$ 跳远的事件不会改变，因为接收时的最大值操作不会传播超过一跳。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n- **系统**：一个由 $n=3$ 个进程 $P_1$、$P_2$ 和 $P_3$ 组成的分布式系统。\n- **时钟**：Lamport 逻辑时钟，每个进程 $P_i$ 对应一个 $L_i$。\n- **初始条件**：对于 $i \\in \\{1, 2, 3\\}$，$L_i = 0$。\n- **系统模型**：异步，消息传递可靠。\n- **Lamport 时钟规则**：\n    1. 每发生一个事件，本地时钟就增加。\n    2. 消息携带发送方的时间戳。\n    3. 接收到时间戳为 $T$ 的消息后，接收进程 $P_i$ 将其时钟 $L_i$ 设置为超过其当前值和 $T$ 的值。（具体来说，对于一个事件，时钟会递增。对于接收事件，$L_i \\leftarrow \\max(\\text{当前 } L_i, T) + 1$）。\n- **事件序列**：\n    - $P_1$：$e_1$ (本地)，$e_2$ (发送 $m_1$ 给 $P_2$)，$e_3$ (从 $P_3$ 接收 $m_3$)。\n    - $P_2$：$f_1$ (本地)，$f_2$ (从 $P_1$ 接收 $m_1$)，$f_3$ (发送 $m_2$ 给 $P_3$)。\n    - $P_3$：$g_1$ (本地)，$g_2$ (从 $P_2$ 接收 $m_2$)，$g_3$ (发送 $m_3$ 给 $P_1$)。\n- **来自消息的因果依赖关系**：\n    - 通过消息 $m_1$，$e_2 \\rightarrow f_2$。\n    - 通过消息 $m_2$，$f_3 \\rightarrow g_2$。\n    - 通过消息 $m_3$，$g_3 \\rightarrow e_3$。\n- **运行 1**：标准 Lamport 时钟，每个事件单位增量 ($+1$)。\n- **运行 2**：进程 $P_2$ 的行为被修改。在 $P_2$ 的每个事件之前，其时钟 $L_2$ 增加 $\\delta$ ($\\delta \\in \\mathbb{N}$)，然后该事件遵循标准的 Lamport 规则。进程 $P_1$ 和 $P_3$ 使用单位增量。\n- **问题**：比较运行 1 和运行 2，并确定哪组事件将具有不同的 Lamport 时间戳 $L(\\cdot)$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n- **科学依据**：该问题基于 Lamport 逻辑时钟，这是分布式系统中的一个基本且成熟的概念。它在科学上是合理的。\n- **定义良好**：问题定义清晰。两次实验运行的初始条件、事件序列、通信模式和时钟更新规则都已明确说明。问题要求对两次运行进行具体比较，可以推导出一个唯一的答案。\n- **客观性**：问题陈述使用精确的技术语言，不含主观性或模糊性。\n- **缺陷检查**：\n    1.  **科学或事实上的不健全**：无。该模型是 Lamport 时钟的标准表示。\n    2.  **非形式化或不相关**：该问题是形式化的，并且与操作系统中逻辑时间的主题直接相关。\n    3.  **不完整或矛盾的设置**：设置是完整且一致的。“标准 Lamport 规则，单位增量”在此上下文中是明确的，意指本地/发送事件为 $L \\leftarrow L+1$，接收事件为 $L \\leftarrow \\max(L, T) + 1$。对 $P_2$ 的修改也已明确规定。\n    4.  **不切实际或不可行**：该场景在计算模型中是一个有效的思想实验。\n    5.  **不适定或结构不良**：可以通过追踪事件计算出一个唯一且稳定的结果。\n    6.  **伪深刻、琐碎或同义反复**：问题并非琐碎；它需要仔细的追踪和对信息如何在因果有序系统中传播的概念性理解。\n    7.  **超出科学可验证性范围**：逻辑完全可以通过计算来验证。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导解决方案。\n\n## 解决方案推导\n\n为了确定哪些事件的时间戳发生变化，我们必须追踪两次运行的时钟值。Lamport 时钟规则如下：\n1.  对于 $P_i$ 上的本地事件或发送事件，时钟更新为：$L_i \\leftarrow L_i + 1$。\n2.  对于 $P_i$ 上接收到一个时间戳为 $T$ 的消息的事件，时钟更新为：$L_i \\leftarrow \\max(L_i, T) + 1$。\n\n### 运行 1：标准 Lamport 时钟\n\n初始状态：$L_1 = 0, L_2 = 0, L_3 = 0$。\n\n1.  $P_1$：事件 $e_1$ (本地)。$L_1 \\leftarrow 0 + 1 = 1$。**$L(e_1) = 1$**。\n2.  $P_2$：事件 $f_1$ (本地)。$L_2 \\leftarrow 0 + 1 = 1$。**$L(f_1) = 1$**。\n3.  $P_3$：事件 $g_1$ (本地)。$L_3 \\leftarrow 0 + 1 = 1$。**$L(g_1) = 1$**。\n4.  $P_1$：事件 $e_2$ (发送 $m_1$ 给 $P_2$) 。$L_1 \\leftarrow 1 + 1 = 2$。**$L(e_2) = 2$**。消息 $m_1$ 的时间戳为 $T_{m_1} = 2$。\n5.  $P_2$：事件 $f_2$ (接收 $m_1$) 。$L_2 \\leftarrow \\max(1, T_{m_1}) + 1 = \\max(1, 2) + 1 = 3$。**$L(f_2) = 3$**。\n6.  $P_2$：事件 $f_3$ (发送 $m_2$ 给 $P_3$) 。$L_2 \\leftarrow 3 + 1 = 4$。**$L(f_3) = 4$**。消息 $m_2$ 的时间戳为 $T_{m_2} = 4$。\n7.  $P_3$：事件 $g_2$ (接收 $m_2$) 。$L_3 \\leftarrow \\max(1, T_{m_2}) + 1 = \\max(1, 4) + 1 = 5$。**$L(g_2) = 5$**。\n8.  $P_3$：事件 $g_3$ (发送 $m_3$ 给 $P_1$) 。$L_3 \\leftarrow 5 + 1 = 6$。**$L(g_3) = 6$**。消息 $m_3$ 的时间戳为 $T_{m_3} = 6$。\n9.  $P_1$：事件 $e_3$ (接收 $m_3$) 。$L_1 \\leftarrow \\max(2, T_{m_3}) + 1 = \\max(2, 6) + 1 = 7$。**$L(e_3) = 7$**。\n\n**运行 1 总结：**\n- $L(e_1)=1, L(e_2)=2, L(e_3)=7$\n- $L(f_1)=1, L(f_2)=3, L(f_3)=4$\n- $L(g_1)=1, L(g_2)=5, L(g_3)=6$\n\n### 运行 2：$P_2$ 上的修改时钟\n\n在 $P_2$ 上，每次事件执行前都有 $L_2 \\leftarrow L_2 + \\delta$。由于 $\\delta \\in \\mathbb{N}$，所以 $\\delta \\ge 1$。\n初始状态：$L_1 = 0, L_2 = 0, L_3 = 0$。\n\n1.  $P_1$：事件 $e_1$ (本地)。$L_1 \\leftarrow 0 + 1 = 1$。**$L(e_1) = 1$** (未改变)。\n2.  $P_2$：事件 $f_1$ (本地)。预先滴答：$L_2 \\leftarrow 0 + \\delta = \\delta$。标准规则：$L_2 \\leftarrow \\delta + 1$。**$L(f_1) = \\delta + 1$** (已改变，因为 $\\delta+1 \\ge 2$)。\n3.  $P_3$：事件 $g_1$ (本地)。$L_3 \\leftarrow 0 + 1 = 1$。**$L(g_1) = 1$** (未改变)。\n4.  $P_1$：事件 $e_2$ (发送 $m_1$ 给 $P_2$) 。$L_1 \\leftarrow 1 + 1 = 2$。**$L(e_2) = 2$** (未改变)。消息 $m_1$ 的时间戳为 $T'_{m_1} = 2$。\n5.  $P_2$：事件 $f_2$ (接收 $m_1$) 。预先滴答：$L_2 \\leftarrow (\\delta+1) + \\delta = 2\\delta+1$。标准规则：$L_2 \\leftarrow \\max(2\\delta+1, T'_{m_1}) + 1 = \\max(2\\delta+1, 2) + 1$。由于 $\\delta \\ge 1$, $2\\delta+1 \\ge 3$, 所以 $L_2 \\leftarrow (2\\delta+1)+1 = 2\\delta+2$。**$L(f_2) = 2\\delta + 2$** (已改变，因为 $2\\delta+2 \\ge 4$)。\n6.  $P_2$：事件 $f_3$ (发送 $m_2$ 给 $P_3$) 。预先滴答：$L_2 \\leftarrow (2\\delta+2) + \\delta = 3\\delta+2$。标准规则：$L_2 \\leftarrow (3\\delta+2) + 1 = 3\\delta+3$。**$L(f_3) = 3\\delta + 3$** (已改变，因为 $3\\delta+3 \\ge 6$)。消息 $m_2$ 的时间戳为 $T'_{m_2} = 3\\delta+3$。\n7.  $P_3$：事件 $g_2$ (接收 $m_2$) 。$L_3 \\leftarrow \\max(1, T'_{m_2}) + 1 = \\max(1, 3\\delta+3) + 1$。由于 $\\delta \\ge 1$, $3\\delta+3 \\ge 6$, 所以 $L_3 \\leftarrow (3\\delta+3)+1 = 3\\delta+4$。**$L(g_2) = 3\\delta + 4$** (已改变，因为 $3\\delta+4 \\ge 7$)。\n8.  $P_3$：事件 $g_3$ (发送 $m_3$ 给 $P_1$) 。$L_3 \\leftarrow (3\\delta+4)+1 = 3\\delta+5$。**$L(g_3) = 3\\delta+5$** (已改变，因为 $3\\delta+5 \\ge 8$)。消息 $m_3$ 的时间戳为 $T'_{m_3} = 3\\delta+5$。\n9.  $P_1$：事件 $e_3$ (接收 $m_3$) 。$L_1 \\leftarrow \\max(2, T'_{m_3}) + 1 = \\max(2, 3\\delta+5) + 1$。由于 $\\delta \\ge 1$, $3\\delta+5 \\ge 8$, 所以 $L_1 \\leftarrow (3\\delta+5)+1 = 3\\delta+6$。**$L(e_3) = 3\\delta+6$** (已改变，因为 $3\\delta+6 \\ge 9$)。\n\n### 变化分析\n-   **时间戳已改变的事件**：$f_1, f_2, f_3$ (在 $P_2$)，$g_2, g_3$ (在 $P_3$)，$e_3$ (在 $P_1$)。\n-   **时间戳未改变的事件**：$e_1, e_2$ (在 $P_1$)，$g_1$ (在 $P_3$)。\n\n在 $P_2$ 上的故意漂移首先影响 $P_2$ 上的所有本地事件 ($f_1, f_2, f_3$)。然后，进程 $P_2$ 从事件 $f_3$ 发送带有膨胀时间戳的消息 $m_2$。当 $P_3$ 在事件 $g_2$ 接收此消息时，其时钟被迫调高到一个更大的值。这个更高的值接着影响 $P_3$ 上的所有后续事件，包括 $g_3$。然后，$P_3$ 从 $g_3$ 发送带有这个新膨胀时间戳的消息 $m_3$。当 $P_1$ 在事件 $e_3$ 接收此消息时，其时钟也相应地被迫调高。\n\n这种传播遵循“发生于前”（happened-before）关系 ($\\rightarrow$)。\n- 漂移始于 $P_2$。事件 $\\{f_1, f_2, f_3\\}$ 受到影响。\n- 存在一个因果路径 $f_3 \\rightarrow g_2$ (通过 $m_2$)。漂移传播到 $g_2$。\n- 存在一个因果路径 $g_2 \\rightarrow g_3$ (本地顺序)。漂移传播到 $g_3$。\n- 存在一个因果路径 $g_3 \\rightarrow e_3$ (通过 $m_3$)。漂移传播到 $e_3$。\n通过传递性，我们有一个因果链 $f_3 \\rightarrow g_2 \\rightarrow g_3 \\rightarrow e_3$。\n\n受影响的事件集合由漂移源头（$P_2$）的事件以及所有位于其因果未来中的事件组成。\n- 设 $E_{P_2} = \\{f_1, f_2, f_3\\}$。\n- 已改变的事件集合是 $E_{P_2} \\cup \\{x \\mid \\exists y \\in E_{P_2} \\text{ 使得 } y \\rightarrow x\\}$。\n- 这恰好是集合 $\\{f_1, f_2, f_3, g_2, g_3, e_3\\}$。\n\n时间戳未改变的事件 ($e_1, e_2, g_1$) 不在 $P_2$ 上任何事件的因果未来中。例如，$e_2 \\rightarrow f_2$，所以 $e_2$ 在 $P_2$ 上一个事件的因果过去中，而非其未来。$g_1$ 与 $P_2$ 上的所有事件并发（对于任何 $i$，$g_1 \\not\\rightarrow f_i$ 且 $f_i \\not\\rightarrow g_1$）。一个不在 $P_2$ 的因果未来中的事件，不会受到来自 $P_2$ 的时钟漂移的影响。\n\n## 逐项分析选项\n\n**A. 只有发生漂移的进程 $P_2$ 上的事件的时间戳会改变，因为 Lamport 时钟除了在接收时，纯粹是本地的。**\n追踪过程明确显示，$P_3$ 上的事件 $g_2, g_3$ 和 $P_1$ 上的事件 $e_3$ 的时间戳也发生了改变。给出的理由是有缺陷的；正是 `receive` 事件将膨胀的时钟值传播到其他进程。\n**结论：不正确。**\n\n**B. $P_2$ 上的事件会改变，此外，位于 $P_2$ 上某个事件的传递因果未来中的每个事件（即，对于任何事件 $x$，存在 $P_2$ 上的事件 $y$ 使得 $y \\rightarrow x$）都会改变，而与 $P_2$ 上所有事件并发的事件保持不变。**\n我们的分析完美地证实了这一说法。$P_2$ 上的事件 ($f_1, f_2, f_3$) 发生改变。它们因果未来中的事件 ($g_2, g_3, e_3$) 也发生改变。不在它们因果未来中的事件 ($e_1, e_2, g_1$) 没有改变。关于并发事件（如 $g_1$）保持不变的说法也是正确的，因为并发意味着不存在从 $P_2$ 到该事件的因果路径。\n**结论：正确。**\n\n**C. 所有进程上的所有事件都会改变，因为 Lamport 时钟实现了一种形式的全局同步，会将任何漂移传播到整个系统。**\n追踪过程显示事件 $e_1, e_2,$ 和 $g_1$ 的时间戳没有改变。其理由也是错误的；Lamport 时钟建立的是偏序关系，而非全局同步。“漂移”是因果传播的，而不是无处不在、瞬时传播的。\n**结论：不正确。**\n\n**D. 只有直接从 $P_2$ 接收消息的接收事件会改变，但超过 $1$ 跳远的事件不会改变，因为接收时的最大值操作不会传播超过一跳。**\n事件 $g_2$ 是一个离 $P_2$ 一跳的接收事件，其时间戳改变了。然而，事件 $g_3$（距离 $g_2$ 0跳，但其值受影响）和事件 $e_3$（2跳远，通过 $P_3$）的时间戳也改变了。`max` 操作的效果是为本地时钟设置一个新的、更高的基线，这个基线会带到后续的本地事件，并通过后续发送的消息传播出去。这种影响明确地传播超过了一跳。\n**结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3688949"}, {"introduction": "虽然Lamport时钟可以确定一个事件是否先于另一个事件发生，但它无法区分真正并发的事件。向量时钟通过追踪系统中每个进程的因果关系解决了这个问题。这个详细的练习要求您在一个存在消息重排序的场景中，精确地应用向量时钟的更新规则，然后使用生成的时间戳来完整地描绘“先于发生”关系，从而为您提供一个强大的工具来推理因果关系和并发性 [@problem_id:3688990]。", "problem": "给定一个包含三个进程 $P_1$、$P_2$ 和 $P_3$ 的分布式执行。系统不保证消息传递的先入先出（FIFO）顺序，因此网络可能会对消息进行重排序。每个进程维护一个维度为 $3$ 的向量时钟（VC），其初始值为 $(0,0,0)$。向量时钟（VC）算法定义如下：\n\n- 对于进程 $i \\in \\{1,2,3\\}$ 上的任何事件，在为该事件加盖时间戳之前，将本地向量时钟的第 $i$ 个分量加 $1$。\n- 对于发送事件，将发送方的当前向量时钟捎带在消息上。\n- 对于进程 $i$ 上的接收事件，设 $V_{\\text{local}}$ 为本地向量，$V_{\\text{msg}}$ 为捎带的向量。首先将本地向量更新为 $\\max(V_{\\text{local}}, V_{\\text{msg}})$（按分量取最大值），然后将其第 $i$ 个分量加 $1$，并用结果向量为该接收事件加盖时间戳。\n\n先行发生（Happens-Before, HB）关系由以下规则生成：\n- 每个进程的程序顺序（如果事件 $e$ 在同一进程上先于事件 $f$ 发生，则 $e \\rightarrow_{\\mathrm{HB}} f$），\n- 消息因果关系（对于任何消息 $m$，有 $\\mathrm{send}(m) \\rightarrow_{\\mathrm{HB}} \\mathrm{recv}(m)$），\n- 以上两点的传递闭包。\n\n现提供以下具有显式程序顺序和消息边的执行轨迹。事件在 $P_1$ 上标记为 $a_k$，在 $P_2$ 上标记为 $b_k$，在 $P_3$ 上标记为 $c_k$：\n\n- 在进程 $P_1$ 上：$a_1$：本地计算；$a_2$：发送 $m_1$ 到 $P_2$；$a_3$：发送 $m_2$ 到 $P_2$。\n- 在进程 $P_2$ 上：$b_1$：本地计算；$b_2$：接收 $m_2$；$b_3$：发送 $m_3$ 到 $P_3$；$b_4$：接收 $m_1$。\n- 在进程 $P_3$ 上：$c_1$：本地计算；$c_2$：接收 $m_3$。\n\n每个进程的程序顺序如上所列。消息匹配如下：$a_2$ 发送 $m_1$ 且 $b_4$ 接收 $m_1$；$a_3$ 发送 $m_2$ 且 $b_2$ 接收 $m_2$；$b_3$ 发送 $m_3$ 且 $c_2$ 接收 $m_3$。注意网络重排序现象：在 $P_1$ 上，$m_1$ 在 $m_2$ 之前发送（因为 $a_2 \\rightarrow a_3$），但 $P_2$ 却在 $m_1$ 之前接收了 $m_2$（$b_2 \\rightarrow b_4$）。\n\n任务：\n1. 使用上述向量时钟（VC）规则，为每个事件 $a_1, a_2, a_3, b_1, b_2, b_3, b_4, c_1, c_2$ 分配一个向量时间戳。\n2. 仅使用按分量向量比较，验证此轨迹中由程序顺序和消息因果关系产生的每一条先行发生（HB）关系边。然后，利用属性“对于事件 $e$ 和 $f$，$e \\rightarrow_{\\mathrm{HB}} f$ 当且仅当 $\\mathrm{VC}(e) \\le \\mathrm{VC}(f)$（按分量比较）且 $\\mathrm{VC}(e) \\neq \\mathrm{VC}(f)$”，将关系扩展到所有事件对。\n3. 计算在此执行中，所有满足 $e \\rightarrow_{\\mathrm{HB}} f$ 的有序对 $(e,f)$（其中 $e \\neq f$）的总数。请以单个整数形式提供答案（无单位）。", "solution": "问题要求计算给定分布式执行的向量时钟时间戳，验证先行发生（Happens-Before, HB）关系，并统计所有满足 $e$ 先行发生于 $f$ 的事件有序对 $(e,f)$ 的数量。\n\n该系统由三个进程 $P_1$、$P_2$ 和 $P_3$ 组成。每个进程维护一个 3 维向量时钟，初始值为 $(0,0,0)$。事件在 $P_1$ 上为 $a_1, a_2, a_3$；在 $P_2$ 上为 $b_1, b_2, b_3, b_4$；在 $P_3$ 上为 $c_1, c_2$。\n\n设 $\\mathrm{VC}(e)$ 表示事件 $e$ 的向量时钟，设 $V_i$ 表示进程 $P_i$ 的本地向量时钟。初始时，$V_1 = V_2 = V_3 = (0,0,0)$。我们将按照执行的因果顺序为每个事件计算时间戳。\n\n**任务 1：为每个事件分配向量时间戳。**\n\n1.  **事件 $a_1$（在 $P_1$ 上，本地计算）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加 1。\n    $V_1 \\leftarrow (0,0,0) + (1,0,0) = (1,0,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(a_1) = (1,0,0)$。\n\n2.  **事件 $a_2$（在 $P_1$ 上，发送 $m_1$ 到 $P_2$）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加 1。\n    $V_1 \\leftarrow (1,0,0) + (1,0,0) = (2,0,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(a_2) = (2,0,0)$。消息 $m_1$ 携带此时间戳，$V_{m_1} = (2,0,0)$。\n\n3.  **事件 $a_3$（在 $P_1$ 上，发送 $m_2$ 到 $P_2$）：**\n    进程 $P_1$ 将其本地时钟的第一个分量加 1。\n    $V_1 \\leftarrow (2,0,0) + (1,0,0) = (3,0,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(a_3) = (3,0,0)$。消息 $m_2$ 携带此时间戳，$V_{m_2} = (3,0,0)$。\n\n4.  **事件 $b_1$（在 $P_2$ 上，本地计算）：**\n    进程 $P_2$ 将其本地时钟的第二个分量加 1。\n    $V_2 \\leftarrow (0,0,0) + (0,1,0) = (0,1,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(b_1) = (0,1,0)$。\n\n5.  **事件 $b_2$（在 $P_2$ 上，从 $P_1$ 接收 $m_2$）：**\n    进程 $P_2$ 首先将其本地时钟 $V_2=(0,1,0)$ 与消息时钟 $V_{m_2}=(3,0,0)$ 按分量取最大值来更新其时钟。\n    $V_2 \\leftarrow \\max((0,1,0), (3,0,0)) = (3,1,0)$。\n    然后，它将其本地时钟的第二个分量加 1。\n    $V_2 \\leftarrow (3,1,0) + (0,1,0) = (3,2,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(b_2) = (3,2,0)$。\n\n6.  **事件 $b_3$（在 $P_2$ 上，发送 $m_3$ 到 $P_3$）：**\n    进程 $P_2$ 将其本地时钟的第二个分量加 1。\n    $V_2 \\leftarrow (3,2,0) + (0,1,0) = (3,3,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(b_3) = (3,3,0)$。消息 $m_3$ 携带此时间戳，$V_{m_3} = (3,3,0)$。\n\n7.  **事件 $c_1$（在 $P_3$ 上，本地计算）：**\n    进程 $P_3$ 将其本地时钟的第三个分量加 1。\n    $V_3 \\leftarrow (0,0,0) + (0,0,1) = (0,0,1)$。\n    该事件的时间戳为：$\\mathrm{VC}(c_1) = (0,0,1)$。\n\n8.  **事件 $b_4$（在 $P_2$ 上，从 $P_1$ 接收 $m_1$）：**\n    进程 $P_2$ 使用消息时钟 $V_{m_1}=(2,0,0)$ 更新其时钟。其当前本地时钟为 $V_2=(3,3,0)$。\n    $V_2 \\leftarrow \\max((3,3,0), (2,0,0)) = (3,3,0)$。\n    然后，它将其本地时钟的第二个分量加 1。\n    $V_2 \\leftarrow (3,3,0) + (0,1,0) = (3,4,0)$。\n    该事件的时间戳为：$\\mathrm{VC}(b_4) = (3,4,0)$。注意，$m_1$ 的到达并未给 $P_2$ 带来来自 $P_1$ 的新因果知识，因为 $P_2$ 已经通过消息 $m_2$ 了解到了一个来自 $P_1$ 的更晚的事件。\n\n9.  **事件 $c_2$（在 $P_3$ 上，从 $P_2$ 接收 $m_3$）：**\n    进程 $P_3$ 使用消息时钟 $V_{m_3}=(3,3,0)$ 更新其时钟。其当前本地时钟为 $V_3=(0,0,1)$。\n    $V_3 \\leftarrow \\max((0,0,1), (3,3,0)) = (3,3,1)$。\n    然后，它将其本地时钟的第三个分量加 1。\n    $V_3 \\leftarrow (3,3,1) + (0,0,1) = (3,3,2)$。\n    该事件的时间戳为：$\\mathrm{VC}(c_2) = (3,3,2)$。\n\n最终的向量时间戳列表为：\n- $\\mathrm{VC}(a_1) = (1,0,0)$\n- $\\mathrm{VC}(a_2) = (2,0,0)$\n- $\\mathrm{VC}(a_3) = (3,0,0)$\n- $\\mathrm{VC}(b_1) = (0,1,0)$\n- $\\mathrm{VC}(b_2) = (3,2,0)$\n- $\\mathrm{VC}(b_3) = (3,3,0)$\n- $\\mathrm{VC}(b_4) = (3,4,0)$\n- $\\mathrm{VC}(c_1) = (0,0,1)$\n- $\\mathrm{VC}(c_2) = (3,3,2)$\n\n**任务 2：验证并扩展先行发生关系。**\n\n对于任意两个事件 $e$ 和 $f$，关系 $e \\rightarrow_{\\mathrm{HB}} f$ 成立当且仅当 $\\mathrm{VC}(e)  \\mathrm{VC}(f)$。对于向量 $V$ 和 $W$，关系 $V  W$ 表示对于所有索引 $i$ 都有 $V[i] \\le W[i]$，且 $V \\neq W$。我们可以利用这个属性来找到所有有序对。\n\n**任务 3：计算有序 HB 对的总数。**\n\n我们必须计算满足 $\\mathrm{VC}(e)  \\mathrm{VC}(f)$ 的不同事件对 $(e, f)$ 的数量。我们遍历每个事件 $e$，并计算它先行发生于（happens-before）的事件 $f$ 的数量。\n\n- 从 $e = a_1, \\mathrm{VC}(a_1)=(1,0,0)$:\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(a_2) = (2,0,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(a_3) = (3,0,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_1)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$6$。\n\n- 从 $e = a_2, \\mathrm{VC}(a_2)=(2,0,0)$:\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(a_3) = (3,0,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_2)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$5$。\n\n- 从 $e = a_3, \\mathrm{VC}(a_3)=(3,0,0)$:\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(a_3)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$4$。\n\n- 从 $e = b_1, \\mathrm{VC}(b_1)=(0,1,0)$:\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_2) = (3,2,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_1)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$4$。\n\n- 从 $e = b_2, \\mathrm{VC}(b_2)=(3,2,0)$:\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(b_3) = (3,3,0)$\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_2)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$3$。\n\n- 从 $e = b_3, \\mathrm{VC}(b_3)=(3,3,0)$:\n  - $\\mathrm{VC}(b_3)  \\mathrm{VC}(b_4) = (3,4,0)$\n  - $\\mathrm{VC}(b_3)  \\mathrm{VC}(c_2) = (3,3,2)$\n  总对数：$2$。\n\n- 从 $e = b_4, \\mathrm{VC}(b_4)=(3,4,0)$: 不存在事件 $f$ 使得 $\\mathrm{VC}(b_4)  \\mathrm{VC}(f)$。\n  总对数：$0$。\n\n- 从 $e = c_1, \\mathrm{VC}(c_1)=(0,0,1)$:\n  - $\\mathrm{VC(c_1)}  \\mathrm{VC(c_2)} = (3,3,2)$\n  总对数：$1$。\n\n- 从 $e = c_2, \\mathrm{VC}(c_2)=(3,3,2)$: 不存在事件 $f$ 使得 $\\mathrm{VC}(c_2)  \\mathrm{VC}(f)$。\n  总对数：$0$。\n\n满足 $e \\rightarrow_{\\mathrm{HB}} f$ 的有序对 $(e,f)$ 的总数是这些单独计数的总和：\n总数 = $6 + 5 + 4 + 4 + 3 + 2 + 0 + 1 + 0 = 25$。", "answer": "$$\\boxed{25}$$", "id": "3688990"}]}