{"hands_on_practices": [{"introduction": "理论概念的理解最好从观察其在现实世界中的影响开始。伪共享（False Sharing）是多核处理器中一个常见的性能陷阱，当多个线程访问位于同一缓存行（cache line）上的不同数据时就会发生。本练习将指导你通过编写一个简单的计算模型，来量化不同内存布局（结构数组 vs. 数组结构）对伪共享的影响，并亲身体验数据结构设计如何直接影响缓存性能。[@problem_id:3625510]", "problem": "考虑一个用于物理模拟的简化多核缓存模型。内存是字节寻址的，每个中央处理器核心都有一个私有缓存，该缓存使用大小为 $L$ 字节的固定大小缓存行。系统采用写-失效缓存一致性协议：当一个线程写入某个缓存行内的任意字节时，所有其他核心上该缓存行的副本都将失效。当多个线程写入位于同一缓存行内的不同数据字时，就会发生伪共享；尽管不存在真正的数据依赖，但一致性协议仍会强制进行失效操作。\n\n您将分析当多个线程更新大量物体集合中的单个热点字段时，内存布局如何影响伪共享。使用两种布局：结构数组 (AoS) 和数组结构 (SoA)。在 AoS 中，每个物体由一个大小为 $s$ 字节的结构体表示，其中热点字段位于结构体内部字节偏移量为 $o$ 的位置。在 SoA 中，所有物体的热点字段存储在一个连续数组中，其中每个元素占用 $f$ 字节。还考虑了一种对齐变体：“AoS-aligned”，其中每个物体的热点字段被放置在使其地址开始一个新的缓存行的位置（实际上是每个缓存行一个热点字段）。所有地址都可以用纯算术术语进行建模，而无需模拟真实硬件。\n\n假设使用以下编程模型：\n- 有 $N$ 个物体，索引为 $i = 0, 1, \\dots, N-1$。\n- 有 $T$ 个线程，这些线程对物体进行连续且不相交的划分。线程 $k$（其中 $k \\in \\{0, 1, \\dots, T-1\\}$）处理从 $i = \\left\\lfloor \\frac{kN}{T} \\right\\rfloor$ 到 $i = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor - 1$（含边界）的子范围。当 $T > N$ 时，子范围可能为空。\n- 在单次迭代中，每个线程对其子范围内的每个物体写入一次热点字段。\n\n定义在三种布局下，索引为 $i$ 的物体的热点字段的有效地址：\n- AoS: $a_{\\text{AoS}}(i) = i \\cdot s + o$。\n- SoA: $a_{\\text{SoA}}(i) = i \\cdot f$。\n- AoS-aligned: $a_{\\text{ALGN}}(i) = i \\cdot L$。\n\n定义任意字节地址 $a$ 的缓存行索引函数为 $\\ell(a) = \\left\\lfloor \\frac{a}{L} \\right\\rfloor$。在写-失效协议和连续分区下，本次单次迭代中任何潜在的伪共享都必然出现在分区边界上。具体来说，对于相邻的线程 $k$ 和 $k+1$，需要检查线程 $k$ 的最后一个物体索引 $i_{\\text{end}} = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor - 1$ 和线程 $k+1$ 的第一个物体索引 $i_{\\text{start}} = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor$ 的热点字段地址是否映射到同一个缓存行。当它们映射到同一个缓存行时，两个线程都会写入该缓存行，从而在该边界上于本次迭代中产生恰好一个共享缓存行。如果任一线程的子范围为空，则该边界上不会发生边界共享。\n\n您的任务是实现一个完整的程序，根据上述模型，为下面的每个测试用例分别计算 AoS、SoA 和 AoS-aligned 布局的共享缓存行数量（一个整数）。对于相邻线程之间的每个边界，最多计一个共享缓存行，并将所有边界的计数求和。程序不应派生线程；它应只执行指定的纯算术计算。\n\n使用以下参数集 $(N, T, L, s, o, f)$ 的测试套件，其中除作为计数的 $N$ 和 $T$ 外，所有量均以字节为单位：\n1. $(N, T, L, s, o, f) = (1000, 4, 64, 48, 0, 8)$ 是一个一般情况，具有典型的缓存行大小和双精度热点字段。\n2. $(N, T, L, s, o, f) = (1000, 1, 64, 48, 0, 8)$ 是一个单线程的边界条件。\n3. $(N, T, L, s, o, f) = (1024, 8, 64, 64, 0, 64)$ 是一个边缘情况，其中每个热点字段元素占据一个完整的缓存行。\n4. $(N, T, L, s, o, f) = (7, 3, 64, 24, 8, 8)$ 是一个具有非平凡结构体偏移的小规模边缘情况。\n\n您的程序必须生成单行输出，其中包含结果，格式为逗号分隔的列表的列表，每个测试用例一个列表，其中每个内部列表为 $[\\text{AoS}, \\text{SoA}, \\text{ALGN}]$，每个元素是该布局下共享缓存行的整数数量。例如，包含两个测试用例的输出应如下所示：$[[x_1,y_1,z_1],[x_2,y_2,z_2]]$。\n\n最终输出必须严格遵循所述格式，只有一行，且不含任何额外文本。", "solution": "该问题要求分析伪共享，这是共享内存多处理器系统中的一种性能下降现象。当多个线程访问恰好位于同一缓存行上的不同数据变量时，就会发生伪共享。在一个采用写-失效缓存一致性协议的系统中，一个线程对其变量的写入将导致其他线程缓存中整个缓存行的失效，即使这些线程只访问该行上其他不相关的变量。这迫使其他线程的后续访问必须从主内存中获取该缓存行，从而产生显著的性能损失。\n\n该问题提供了一个确定性的算术模型，用于量化三种不同数据布局（结构数组 (AoS)、数组结构 (SoA) 和特殊对齐的结构数组 (AoS-aligned)）下线程分区边界上的共享缓存行数量。解决方案是该指定模型的直接实现。\n\n算法方法如下：\n\n对于每个由参数 $(N, T, L, s, o, f)$ 指定的测试用例，我们计算三种内存布局中每一种的共享缓存行数量。这些参数是：\n- $N$: 模拟中的物体数量。\n- $T$: 处理物体的线程数量。\n- $L$: 缓存行的大小（字节）。\n- $s$: 在 AoS 布局中，单个物体的完整结构体的大小（字节）。\n- $o$: 在 AoS 布局中，结构体内部“热点字段”的字节偏移量。\n- $f$: 在 SoA 布局中，“热点字段”元素的大小（字节）。\n\n分析的核心是检查相邻线程分区之间的 $T-1$ 个边界。对于线程 $k$ 和线程 $k+1$ 之间的每个边界（其中 $k$ 的范围从 $0$ 到 $T-2$），我们执行以下步骤：\n\n1.  **识别分区边界**：问题陈述 $N$ 个物体被连续地划分给 $T$ 个线程。线程 $k$ 负责的物体索引范围从 $i_{k, \\text{start}} = \\left\\lfloor \\frac{kN}{T} \\right\\rfloor$ 到 $i_{k, \\text{end}} = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor - 1$。如果边界两侧的两个线程都有工作要做，则该边界是共享的。如果一个线程 $m$ 的起始索引大于其结束索引，则其分区为空，这种情况发生在 $\\lfloor mN/T \\rfloor > \\lfloor(m+1)N/T\\rfloor - 1$ 时，等价于 $\\lfloor mN/T \\rfloor \\ge \\lfloor(m+1)N/T\\rfloor$。这在 $T > N$ 时可能发生。如果线程 $k$ 或线程 $k+1$ 的分区为空，则此边界上不发生共享。\n\n2.  **定位关键访问**：在此模型中，伪共享只可能发生在线程 $k$ 处理的最后一个物体和线程 $k+1$ 处理的第一个物体之间。这两个物体的索引是：\n    - 线程 $k$ 的最后一个物体：$i_1 = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor - 1$。\n    - 线程 $k+1$ 的第一个物体：$i_2 = \\left\\lfloor \\frac{(k+1)N}{T} \\right\\rfloor$。\n    注意 $i_2 = i_1 + 1$。\n\n3.  **计算内存地址**：对于三种布局中的每一种，我们使用提供的函数计算物体 $i_1$ 和 $i_2$ 的热点字段的有效内存地址：\n    - **AoS**：$a_{\\text{AoS}}(i) = i \\cdot s + o$。地址为 $a_1 = i_1 \\cdot s + o$ 和 $a_2 = i_2 \\cdot s + o$。\n    - **SoA**：$a_{\\text{SoA}}(i) = i \\cdot f$。地址为 $a_1 = i_1 \\cdot f$ 和 $a_2 = i_2 \\cdot f$。\n    - **AoS-aligned (ALGN)**：$a_{\\text{ALGN}}(i) = i \\cdot L$。地址为 $a_1 = i_1 \\cdot L$ 和 $a_2 = i_2 \\cdot L$。\n\n4.  **确定缓存行索引**：任何内存地址 $a$ 的缓存行索引由 $\\ell(a) = \\left\\lfloor \\frac{a}{L} \\right\\rfloor$ 给出。我们为每种布局计算物体 $i_1$ 和 $i_2$ 的热点字段地址的此值。\n\n5.  **统计共享行**：对于给定的布局，如果在线程 $k$ 和 $k+1$ 之间的边界上，物体 $i_1$ 和 $i_2$ 的热点字段映射到相同的缓存行索引，则计为一个共享缓存行。即，如果 $\\ell(a_1) = \\ell(a_2)$。我们为该布局增加相应的计数器。\n\n每种布局的共享行总数是所有 $T-1$ 个边界上计数的总和。\n\n对于 AoS-aligned 情况有一个关键的观察：物体 $i$ 的热点字段地址是 $a_{\\text{ALGN}}(i) = i \\cdot L$。相应的缓存行是 $\\ell(a_{\\text{ALGN}}(i)) = \\lfloor(i \\cdot L) / L\\rfloor = i$。在一个边界上，我们比较物体 $i_1$ 和 $i_2$ 的缓存行。它们的缓存行索引分别是 $i_1$ 和 $i_2$。由于 $i_2 = i_1 + 1$，所以 $i_1 = i_2$ 是不可能的。因此，在此模型下，AoS-aligned 布局的共享缓存行数量确定性地为 $0$。这可以作为计算结果的分析性验证。\n\n最终的程序以算术方式实现此逻辑，遍历所有测试用例，并对每个测试用例遍历线程边界以计算总数。", "answer": "[[0,3,0],[0,0,0],[0,0,0],[2,2,0]]", "id": "3625510"}, {"introduction": "在探讨了因数据布局不当引起的“伪共享”之后，我们现在转向“真共享”（True Sharing）——即多个线程确实需要并发访问同一份数据的情况。本练习要求你运用概率模型（泊松过程）来推导一个高争用共享计数器所导致的缓存失效消息的期望速率。这个练习将让你掌握一种量化分析高争用同步开销的方法，加深对缓存一致性协议底层成本的理解。[@problem_id:3625552]", "problem": "一个共享内存程序运行在一台多处理器上，该多处理器有 $T$ 个硬件线程，每个线程固定在一个中央处理器（CPU）核心上。所有核心共享一个单一的物理索引、物理标记的缓存一致性层次结构，该结构实现了一种基于失效的“修改-独占-共享-无效”（MESI）协议。该程序维护一个单一的 $64$ 位计数器，此计数器完全位于一个缓存行内，并由每个线程使用原子读-改-写操作（例如，原子取加）进行递增。\n\n假设以下简化但现实的一致性和时序模型：\n- 每个原子递增操作都是通过一次“请求所有权”（Read For Ownership, RFO）事务实现的，该事务将缓存行以“修改”（Modified）状态带入请求者缓存中，并使任何其他有效副本失效。完成递增后，请求者将该行保持在“修改”状态。\n- 除了作为递增操作的RFO一部分外，没有对该行的推测性读取，也没有其他共享者；在任何时刻，至多有一个核心持有有效副本，即处于“修改”状态的当前所有者。\n- 当一个不同的核心在另一个核心以“修改”状态拥有该行时发出RFO，目录会向当前所有者发送恰好一个失效消息以撤销其副本，然后才将所有权转移给请求者。这计为恰好一次失效。如果已经拥有该行的同一核心发出另一次递增请求，则不会产生失效。\n- 每个线程以每秒 $r$ 次递增的速率发出递增请求，这构成一个独立的泊松过程。所有过程都是独立的、平稳的，因此这些过程的叠加具有泊松过程的通常属性。\n\n从基于失效的一致性的核心定义以及独立泊松过程的标准属性（叠加性、无记忆性和源选择与速率成正比）出发，推导此工作负载所导致的每秒失效消息的稳态期望计数，作为 $T$ 和 $r$ 的函数。将您的最终答案表示为关于 $T$ 和 $r$ 的单个闭式解析表达式。不要四舍五入。以“每秒”为单位陈述您的最终结果。", "solution": "问题要求计算一个由 $T$ 个线程原子递增的共享计数器所产生的每秒失效消息的稳态期望计数。这些线程在 $T$ 个独立的核心上运行，每个线程的递增请求遵循速率为 $r$ 的独立泊松过程。\n\n首先，我们确定所有核心上原子递增操作的总速率。问题指出，$T$ 个线程中的每一个都以每秒 $r$ 次递增的速率发出请求，这构成一个独立的泊松过程。独立泊松过程的一个基本性质是，它们的叠加也是一个泊松过程，其速率是各个速率之和。设 $R_{total}$ 为叠加过程的速率，它代表了系统中原子递增的总速率。\n\n$$R_{total} = \\sum_{i=1}^{T} r = Tr$$\n\n这是整个系统每秒原子递增（也就是“请求所有权”，即 RFO 请求）的总期望次数。\n\n接下来，我们必须确定在何种条件下，这些 RFO 请求之一会产生一个失效消息。根据问题描述：\n1. 来自一个不拥有缓存行的核心的 RFO 会导致向当前所有者发送一个失效消息。\n2. 执行递增的核心将该行保留在“修改”（M）状态，成为新的所有者。\n3. 来自已经拥有该行的核心的 RFO 不会产生失效。\n\n因此，当且仅当发出 RFO 请求的核心与发出紧接其前一个 RFO 请求的核心不同时，才会发生失效事件。\n\n我们需要找到从所有递增操作的叠加流中随机选择一个递增操作，该操作由一个不同于发出前一个递增操作的核心发出的概率。让我们将发出第 $k$ 次递增的核心记为 $C_k$。在第 $k$ 次递增时发生失效的条件是当且仅当 $C_k \\neq C_{k-1}$。我们关心的是概率 $P(C_k \\neq C_{k-1})$。\n\n问题指出，我们应该使用独立泊松过程的标准属性。其中一个属性，通常称为“源选择”或“竞争过程”属性，指出对于一个叠加过程，任何给定事件起源于特定组成过程 $i$ 的概率与其速率 $r_i$ 成正比。在我们的情况下，所有组成过程（每个核心一个）都具有相同的速率 $r$。一个给定的递增事件来自核心 $i$ 的概率 $p_i$ 是：\n\n$$p_i = \\frac{r}{\\sum_{j=1}^{T} r} = \\frac{r}{Tr} = \\frac{1}{T}$$\n\n这意味着任何单个递增事件都等可能地来自 $T$ 个核心中的任何一个。\n\n泊松过程的另一个关键属性是无记忆性。这意味着产生第 $k$ 个事件的核心的身份与产生第 $(k-1)$ 个事件的核心的身份在统计上是独立的。\n\n让我们假设第 $(k-1)$ 次递增是由某个核心，比如说核心A，执行的。核心A现在是该缓存行的所有者。下一次递增，即第 $k$ 次递增，即将发生。根据我们之前的结果，这次第 $k$ 次递增也由核心A发出的概率是 $P(C_k = \\text{Core A}) = \\frac{1}{T}$。\n\n如果这次第 $k$ 次递增是由除核心A之外的任何核心发出的，就会触发一次失效。由于事件是独立的，这个概率是：\n\n$$P_{inval} = P(C_k \\neq \\text{Core A}) = 1 - P(C_k = \\text{Core A}) = 1 - \\frac{1}{T} = \\frac{T-1}{T}$$\n\n这就是任何单个原子递增操作导致一次失效的概率。\n\n为了找到每秒的期望失效次数，我们将其表示为 $I_{total}$，我们将总递增操作速率乘以任何给定递增操作导致失效的概率。\n\n$$I_{total} = R_{total} \\times P_{inval}$$\n\n代入 $R_{total}$ 和 $P_{inval}$ 的表达式：\n\n$$I_{total} = (Tr) \\times \\left( \\frac{T-1}{T} \\right)$$\n\n$T$ 因子被消掉，得出期望失效速率的最终表达式：\n\n$$I_{total} = r(T-1)$$\n\n$r$ 的单位是每个线程每秒的递增次数，$T$ 是线程数（无单位），因此最终表达式的单位确实是每秒失效次数，符合要求。\n\n例如，如果 $T=1$，只有一个核心，它永远不会使其余核心的副本失效。公式给出 $I_{total} = r(1-1) = 0$，这是正确的。如果 $T$ 非常大，几乎每次递增都来自一个新的核心，因此失效速率应接近总递增速率 $Tr$。该公式给出 $r(T-1) = Tr - r$，对于大的 $T$ 来说，这确实接近于 $Tr$。", "answer": "$$\\boxed{r(T-1)}$$", "id": "3625552"}, {"introduction": "优秀的性能工程通常是在权衡各种利弊之间做出决策。本练习将我们对共享问题的理解提升到一个新的层次，即分析解决方案本身的成本。通过填充（padding）数据结构来避免伪共享是一种常用技巧，但这会增加内存占用，可能导致更多的缓存容量未命中（capacity miss）。本练习将引导你建立一个成本模型，计算填充策略的“盈亏平衡点”，让你体验在真实系统设计中如何权衡利弊。[@problem_id:3625495]", "problem": "一个由两个中央处理器 (CPU) 核心共享的软件队列在内存中有两个计数器：一个头索引，仅由消费者核心写入；一个尾索引，仅由生产者核心写入。设缓存行大小为 $B$ 字节。如果头索引和尾索引变量位于同一缓存行中，则任一核心的每次写入都会导致另一核心可见的一致性失效。设生产者更新率为每秒 $r_{t}$ 次写入，消费者更新率为每秒 $r_{h}$ 次写入。在典型的“修改-独占-共享-无效”(MESI) 协议下，由于缓存行所有权转移，每次跨核心的一致性失效都会在写入核心上引起 $t_{i}$ 个周期的停顿。\n\n为了减少失效，可以选择对数据结构进行填充，使得尾索引位于同一内存对象中头索引之后 $L$ 字节处。假设在多次执行中，头索引在缓存行内的起始偏移量在 $\\{0,1,\\dots,B-1\\}$ 上是均匀随机的；在此假设下，当 $0 \\le L \\le B$ 时，头索引和尾索引位于不同缓存行上的概率为 $L/B$，并且当 $L \\ge B$ 时，该概率饱和为 $1$。\n\n$L$ 字节的填充会使一级数据缓存 (L1D) 观察到的稳态工作集增加 $L$ 字节。假设在一个统一访问模型中，来自两个核心的 L1D 缓存行总引用率为每秒 $R$ 个缓存行。设 L1D 的容量为 $C_{1}$ 字节，因额外的 L1D 未命中而回退到下一级的停顿惩罚为 $t_{m}$ 个周期。在此模型中，接近稳态时，由额外的 $L$ 字节引起的未命中概率的增加分数近似为 $L/C_{1}$，因此由填充引起的预期额外停顿为每秒 $(t_{m} R L)/C_{1}$ 个周期。\n\n将每秒预期总停顿定义为一致性失效停顿与填充引起的未命中停顿之和。仅使用上述定义和假设，推导出一个封闭形式的表达式，用于计算每次写入的盈亏平衡一致性失效惩罚 $t_{i}^{\\star}$（以周期为单位）。在此惩罚值下，填充到恰好一个缓存行间距（$L=B$）所产生的每秒预期总停顿与不进行填充（$L=0$）时相同。请用符号 $B$、$r_{h}$、$r_{t}$、$R$、$t_{m}$ 和 $C_{1}$ 来表示您的最终答案。将最终结果表述为单一的解析表达式。以周期为单位表示最终答案。无需四舍五入。", "solution": "该问题要求在特定的性能模型下，推导出一个盈亏平衡的一致性失效惩罚，记为 $t_{i}^{\\star}$。盈亏平衡点定义为这样一个惩罚值，在该值下，两种配置的每秒总预期性能停顿是相同的：一种是没有数据结构填充（$L=0$ 字节），另一种是填充等于一个缓存行大小（$L=B$ 字节）。\n\n每秒总预期停顿，我们可以将其表示为函数 $S(L)$，定义为两个组成部分之和：一致性失效引起的停顿 $S_{coh}(L)$，以及由填充引起的额外缓存未命中停顿 $S_{pad}(L)$。\n$$ S(L) = S_{coh}(L) + S_{pad}(L) $$\n\n首先，我们来构建一致性停顿 $S_{coh}(L)$ 的表达式。一致性失效及相关的停顿仅在头索引和尾索引计数器位于同一缓存行时发生，这种情况被称为伪共享 (false sharing)。如果消费者核心和生产者核心都拥有缓存行的副本，那么消费者核心对头索引的写入或生产者核心对尾索引的写入将使另一核心的缓存行失效。可能导致此类失效的总写入速率是单个写入速率之和，即 $r_{h} + r_{t}$。每个此类事件都会产生 $t_{i}$ 个周期的停顿。\n\n问题陈述，头索引和尾索引位于*不同*缓存行上的概率为 $P(\\text{different}) = L/B$（对于 $0 \\le L \\le B$）。因此，它们位于*相同*缓存行上的概率为 $P(\\text{same}) = 1 - P(\\text{different})$。\n$$ P(\\text{same}) = 1 - \\frac{L}{B} \\quad \\text{for } 0 \\le L \\le B $$\n由一致性失效引起的每秒预期停顿是总写入速率乘以伪共享的概率，再乘以每次失效的停顿。\n$$ S_{coh}(L) = (r_{h} + r_{t}) t_{i} \\left(1 - \\frac{L}{B}\\right) $$\n\n接下来，我们考虑由填充引起的未命中停顿 $S_{pad}(L)$。问题陈述为该部分提供了一个直接的模型：“由填充引起的预期额外停顿为每秒 $(t_{m} R L)/C_{1}$ 个周期。”\n$$ S_{pad}(L) = \\frac{t_{m} R L}{C_{1}} $$\n\n结合这两个部分，每秒总预期停顿为：\n$$ S(L) = (r_{h} + r_{t}) t_{i} \\left(1 - \\frac{L}{B}\\right) + \\frac{t_{m} R L}{C_{1}} $$\n此表达式在填充范围 $0 \\le L \\le B$ 内有效。\n\n我们需要找到盈亏平衡值 $t_{i}^{\\star}$，使得无填充（$L=0$）时的总停顿等于填充一个缓存行大小（$L=B$）时的总停顿。让我们计算 $S(L)$ 在这两点的值。\n\n对于无填充的情况，$L=0$：\n$$ S(L=0) = (r_{h} + r_{t}) t_{i} \\left(1 - \\frac{0}{B}\\right) + \\frac{t_{m} R \\cdot 0}{C_{1}} $$\n$$ S(L=0) = (r_{h} + r_{t}) t_{i} (1 - 0) + 0 $$\n$$ S(L=0) = (r_{h} + r_{t}) t_{i} $$\n在这种情况下，总是发生伪共享，且没有由填充引起的停顿。\n\n对于填充一个缓存行大小的情况，$L=B$：\n$$ S(L=B) = (r_{h} + r_{t}) t_{i} \\left(1 - \\frac{B}{B}\\right) + \\frac{t_{m} R B}{C_{1}} $$\n$$ S(L=B) = (r_{h} + r_{t}) t_{i} (1 - 1) + \\frac{t_{m} R B}{C_{1}} $$\n$$ S(L=B) = 0 + \\frac{t_{m} R B}{C_{1}} $$\n$$ S(L=B) = \\frac{t_{m} R B}{C_{1}} $$\n在这种情况下，伪共享被完全消除，但系统会承受此模型中考虑的最大由填充引起的停顿惩罚。\n\n当 $S(L=0) = S(L=B)$ 时满足盈亏平衡条件，此时一致性惩罚为 $t_{i}^{\\star}$：\n$$ (r_{h} + r_{t}) t_{i}^{\\star} = \\frac{t_{m} R B}{C_{1}} $$\n\n为了求出 $t_{i}^{\\star}$ 的表达式，我们将其解出，方法是将等式两边同时除以总写入速率 $(r_{h} + r_{t})$。\n$$ t_{i}^{\\star} = \\frac{t_{m} R B}{C_{1} (r_{h} + r_{t})} $$\n这就是每次写入的盈亏平衡一致性失效惩罚的封闭形式表达式，用给定的参数以符号形式表示。", "answer": "$$\\boxed{\\frac{t_{m} R B}{C_{1} (r_{h} + r_{t})}}$$", "id": "3625495"}]}