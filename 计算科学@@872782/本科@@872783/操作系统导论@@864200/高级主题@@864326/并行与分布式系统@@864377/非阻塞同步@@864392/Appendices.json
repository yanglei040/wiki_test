{"hands_on_practices": [{"introduction": "原子操作本身并不足以保证线程间的正确协作；我们还必须精确控制内存操作的可见性。本练习 [@problem_id:3664124] 探讨了至关重要的 `release-acquire` 语义，它是无锁通信安全性的基石。通过分析一个由于使用了较弱内存顺序而导致的常见错误，你将理解为何正确的内存屏障对于构建可靠的并发代码至关重要。", "problem": "一个通过 International Organization for Standardization C 2011 (C11) 原子操作实现的单生产者单消费者（SPSC）队列，旨在所有主流硬件上都是非阻塞且正确的。生产者线程分配一个节点，在普通（非原子）内存中完全初始化其字段，然后通过将其指针存储到一个共享原子变量中来发布该节点。消费者线程自旋，直到该共享原子变量变为非空，然后读取节点的字段。相关步骤如下：\n\n- 生产者线程：\n  1. 使用普通的非原子存储，将节点 $n$ 中的数据字段 $d$ 写入值 $1$。\n  2. 通过对共享原子指针 $H$ 执行带有 $memory\\_order\\_release$ 的原子存储来发布指向 $n$ 的指针。\n\n- 消费者线程：\n  1. 使用带有 $memory\\_order\\_relaxed$ 的原子加载来轮询 $H$，直到它变为非空，并将结果存储到局部指针 $p$ 中。\n  2. 在普通非原子内存中通过 $p$ 读取数据字段 $d$ 并使用它。\n\n假设初始状态为 $H = \\text{null}$ 且 $d = 0$。预期的不变式是：一旦消费者观察到 $H \\neq \\text{null}$，它随后必须从已发布的节点中读取到 $d = 1$。然而，在允许弱排序的架构上以及在 C11 内存模型中，上述消费者代码有时可能会观察到 $H \\neq \\text{null}$，但随后仍然读取到 $d = 0$。在此设定下，决定正确性的核心定义是：\n\n- 对同一原子对象的带有 $memory\\_order\\_release$ 的存储，如果其后跟着一个读取该存储值的、带有 $memory\\_order\\_acquire$ 的加载，则会建立一个“同步于”（synchronizes-with）关系，这反过来会产生一个“先行发生”（happens-before）边，该边将在另一线程中，把之前的普通写入（例如对 $d$ 的写入）排序到之后的普通读取之前。\n- 在没有“同步于”关系的情况下，不要求消费者的对 $d$ 的普通非原子读取能看到生产者在对 $H$ 进行释放存储之前执行的对 $d$ 的普通非原子写入。\n- 编译器屏障会阻止编译器的某些重排序，但其本身并不提供线程间的可见性保证，除非在 C11 模型中与适当的原子操作或栅栏（fences）结合使用。\n\n考虑所述的错误：消费者对 $H$ 的加载使用 $memory\\_order\\_relaxed$，然后立即读取 $d$。以下哪些修改（按规定应用于消费者或生产者代码）能够建立所需的排序和可见性保证，从而使得一旦消费者观察到 $H \\neq \\text{null}$，它就必须读取到 $d = 1$？选择所有适用的选项。\n\nA. 将消费者的对 $H$ 的加载从 $memory\\_order\\_relaxed$ 更改为 $memory\\_order\\_acquire$，同时保持生产者对 $H$ 的存储为 $memory\\_order\\_release$。\n\nB. 保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$，但在观察到 $H \\neq \\text{null}$ 后，在读取 $d$ 之前立即插入 $atomic\\_thread\\_fence(memory\\_order\\_acquire)$。\n\nC. 保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$，而是在读取 $d$ 之前插入 $atomic\\_signal\\_fence(memory\\_order\\_acquire)$。\n\nD. 将 $H$ 声明为 $volatile$ 并保持所有内存顺序不变。\n\nE. 将生产者对 $H$ 的存储从 $memory\\_order\\_release$ 更改为 $memory\\_order\\_seq\\_cst$，同时保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$。", "solution": "经过严格审查，该问题陈述是有效的。它在科学上以 C11 内存模型为基础，问题定义明确且客观，不包含矛盾或模糊之处。\n\n核心问题是关于非原子数据字段 $d$ 的数据竞争。为使程序正确，生产者的对 $d$ 的写入必须“先行发生于”（happen-before）消费者的对 $d$ 的读取。C11 内存模型主要通过原子操作之间的“同步于”（synchronizes-with）关系来建立这种“先行发生”关系。\n\n在原始的有缺陷的实现中：\n- 生产者执行一次非原子写入：$d=1$。\n- 生产者执行一次原子存储：$H \\leftarrow n$，使用 $memory\\_order\\_release$。\n- 消费者执行一次原子加载：$p \\leftarrow H$，使用 $memory\\_order\\_relaxed$。\n- 消费者通过 $p$ 执行一次对 $d$ 的非原子读取。\n\n一个 $memory\\_order\\_release$ 操作确保同一线程中所有之前的内存写入，对于在同一原子变量上执行 $memory\\_order\\_acquire$ 操作的其他线程是可见的。消费者的 $memory\\_order\\_relaxed$ 加载不会创建此链接。它仅保证加载本身的原子性，而不保证相对于其他内存操作的任何排序。因此，不存在“同步于”关系，没有为对 $d$ 的访问形成“先行发生”边，消费者即使在观察到非空的 $H$ 后，也可能读取到旧值 $d=0$。这是因为在弱排序架构上，内存操作可能被 CPU 重排序，或者缓存一致性协议在消费者读取 $d$ 时可能尚未将对 $d$ 的写入传播到其核心。\n\n为了修复这个问题，我们必须在生产者的存储和消费者的后续操作之间建立一个“同步于”关系。让我们分析每个提议的修改。\n\nA. 将消费者的对 $H$ 的加载从 $memory\\_order\\_relaxed$ 更改为 $memory\\_order\\_acquire$，同时保持生产者对 $H$ 的存储为 $memory\\_order\\_release$。\n这个修改创建了典型的 `release-acquire` 配对。根据 C11 标准，对一个原子对象的带有 $memory\\_order\\_release$ 的存储，“同步于”从同一原子对象读取该写入值的、带有 $memory\\_order\\_acquire$ 的加载。这就建立了一个“先行发生”关系。具体来说：\n1. 生产者的对 $d$ 的写入“先行发生于”其对 $H$ 的 `release` 存储。\n2. 生产者的对 $H$ 的 `release` 存储“同步于”（因此也“先行发生于”）消费者的对 $H$ 的 `acquire` 加载。\n3. 消费者的对 $H$ 的 `acquire` 加载“先行发生于”其对数据字段 $d$ 的读取。\n根据“先行发生”关系的传递性，生产者的对 $d$ 的写入“先行发生于”消费者的对 $d$ 的读取。这正确地排序了内存访问，并保证消费者将读取到 $d=1$。\n**结论：正确。**\n\nB. 保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$，但在观察到 $H \\neq \\text{null}$ 后，在读取 $d$ 之前立即插入 $atomic\\_thread\\_fence(memory\\_order\\_acquire)$。\n这使用了一个内存栅栏来建立排序。C11 标准规定，一个释放操作（如 $memory\\_order\\_release$ 存储）可以与一个获取栅栏同步。一个带有 $memory\\_order\\_release$ 的原子存储操作 $A$，“同步于”一个带有 $memory\\_order\\_acquire$ 的 $atomic\\_thread\\_fence$ $B$，如果存在一个读取了 $A$ 所存储的值的原子加载 $L$，并且 $L$ 在定序上先于 $B$。\n在我们的案例中：\n1. $A$ 是生产者对 $H$ 的 `release` 存储。\n2. $L$ 是消费者对 $H$ 的 $memory\\_order\\_relaxed$ 加载。\n3. $B$ 是 $atomic\\_thread\\_fence(memory\\_order\\_acquire)$。\n加载 $L$ 在定序上先于栅栏 $B$。因此，`release` 存储 $A$ “同步于” `acquire` 栅栏 $B$。这确保了所有“先行发生于” `release` 存储的内存写入（对 $d$ 的写入），对于所有“发生于” `acquire` 栅栏之后的内存读取（对 $d$ 的读取）都是可见的。这种模式正确地防止了数据竞争。\n**结论：正确。**\n\nC. 保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$，而是在读取 $d$ 之前插入 $atomic\\_signal\\_fence(memory\\_order\\_acquire)$。\n一个 $atomic\\_signal\\_fence$ 与一个 $atomic\\_thread\\_fence$ 有着根本的不同。它只在单个线程内部创建内存排序保证，特别是在信号处理器和它所中断的线程之间。它不发出核心间的同步指令（内存屏障），因此不能在两个不同线程之间建立“同步于”关系。线程间的可见性问题仍未解决。\n**结论：不正确。**\n\nD. 将 $H$ 声明为 $volatile$ 并保持所有内存顺序不变。\n在 C11 中，`volatile` 关键字的用途与原子内存顺序不同。它防止编译器优化掉内存访问，这对于内存映射 I/O 或由异步外部代理（如信号处理器）修改的变量至关重要。然而，`volatile` 不提供关于不同线程之间内存排序的任何保证。它不生成多核系统上缓存一致性和排序所需的内存栅栏。C11 标准明确指出 `volatile` 对象不适用于线程间同步。由 $memory\\_order\\_relaxed$ 引起的原始数据竞争将依然存在。\n**结论：不正确。**\n\nE. 将生产者对 $H$ 的存储从 $memory\\_order\\_release$ 更改为 $memory\\_order\\_seq\\_cst$，同时保持消费者对 $H$ 的加载为 $memory\\_order\\_relaxed$。\n一个带有 $memory\\_order\\_seq\\_cst$ 的存储，其作用相当于一个 `release` 操作，并且还参与所有 `seq_cst` 操作的单一全局总排序。虽然它是一个比 $memory\\_order\\_release$ 更强的操作，但它仍然需要在消费者线程中有相应的同步操作。根据 C11 标准，一个 `release` 操作（$memory\\_order\\_seq\\_cst$ 存储就是一种）并不与一个 $memory\\_order\\_relaxed$ 加载“同步”。消费者的 `relaxed` 加载仍然无法建立必要的“先行发生”关系，以保证生产者对 $d$ 的写入的可见性。\n**结论：不正确。**", "answer": "$$\\boxed{AB}$$", "id": "3664124"}, {"introduction": "`ABA` 问题是无锁算法中一个臭名昭著的陷阱，即使使用了原子`CAS`指令，它也可能悄无声息地破坏数据结构的完整性。这个思想实验 [@problem_id:3664130] 演示了如何通过“标记指针”技术来有效规避此问题。你将面临的挑战是计算出在给定的操作负载下，需要多大的标记位宽才能确保系统的安全性，从而将理论与实际的工程权衡联系起来。", "problem": "一个无锁工作窃取双端队列 (deque) 被实现为一个容量为 $C = 2^{20}$ 个槽位的循环缓冲区。共享的 top 指针表示为一个单个机器字，其中打包了一个索引 $i \\in \\{0, 1, \\dots, C - 1\\}$ 和一个标签 $t \\in \\{0, 1, \\dots, 2^b - 1\\}$，记作序对 $(i, t)$。窃取者线程使用比较并交换 (Compare-And-Swap, CAS) 来从顶部窃取：它们读取当前的 $(i, t)$，计算一个提议的新顶部值，然后尝试进行一次 CAS 操作，只有当当前的打包字等于它们预期的 $(i, t)$ 时，该操作才会成功。为了缓解所谓的 A-B-A 问题（通常缩写为 ABA），每次任何线程成功更改顶部时，标签 $t$ 都会在模 $2^b$ 的意义下加 $1$，而每次成功窃取时，索引 $i$ 都会在模 $C$ 的意义下加 $1$。\n\n假设一个窃取者线程读取了初始序对 $(i_0, t_0)$，在其尝试 CAS 操作之前，其他线程可能已经成功进行了多达 $M_{\\max} = 10^{12}$ 次的顶部更改。如果在这些更改中，打包字返回到与初始完全相同的序对 $(i_0, t_0)$，那么就会出现 ABA 漏洞，这使得窃取者线程的 CAS 操作会因一个过时的视图而成功，尽管逻辑状态已经改变。在此实现中，A-B-A 问题要求索引和标签都返回到它们的初始值，即经过某个数量为 $m$ 的更改后，同时满足 $i_0 + m \\equiv i_0 \\pmod{C}$ 和 $t_0 + m \\equiv t_0 \\pmod{2^b}$。\n\n哪个选项给出的标签宽度 $b$（以位为单位）是最小的，且能保证在任何严格少于 $M_{\\max}$ 次成功的 top 指针更改窗口内，不会发生 A-B-A 问题？\n\nA. $b = 20$\n\nB. $b = 30$\n\nC. $b = 40$\n\nD. $b = 50$", "solution": "用户希望我解决一个关于无锁工作窃取双端队列中 ABA 问题的问题。\n\n**1. 问题验证**\n\n首先，我必须验证问题陈述。\n\n**步骤1：提取已知条件**\n- 数据结构：无锁工作窃取双端队列 (deque)。\n- 实现：循环缓冲区。\n- 容量：$C = 2^{20}$ 个槽位。\n- 共享的 top 指针：一个单个机器字，打包了一个索引 $i \\in \\{0, 1, \\dots, C - 1\\}$ 和一个标签 $t \\in \\{0, 1, \\dots, 2^b - 1\\}$，记作序对 $(i, t)$。\n- 窃取时索引的更新：每次成功窃取， $i$ 在模 $C$ 的意义下加 $1$。\n- top 指针更改时标签的更新：每次成功更改 top 指针， $t$ 在模 $2^b$ 的意义下加 $1$。\n- 场景：一个窃取者线程读取了 $(i_0, t_0)$。在其 CAS 操作之前，其他线程可能已经成功进行了多达 $M_{\\max} = 10^{12}$ 次的 top 指针更改。问题规定分析应覆盖任何“严格少于 $M_{\\max}$”次更改的窗口，即 $m \\in \\{1, 2, \\dots, M_{\\max}-1\\}$。\n- ABA 条件：经过 $m$ 次更改后，打包字返回到 $(i_0, t_0)$。这要求同时满足 $i_0 + m \\equiv i_0 \\pmod{C}$ 和 $t_0 + m \\equiv t_0 \\pmod{2^b}$。问题文本暗示，对于正在考虑的特定类型的更改（从 top 窃取），索引和标签的增量次数是相同的。这对于带标签指针上的简单 pop 操作是标准的。因此，经过 $m$ 次此类操作后，新状态为 $(i_0+m, t_0+m)$。\n\n**步骤2：使用提取的已知条件进行验证**\n- **科学上是否成立：** 该问题牢固地定位于并发算法和操作系统原理领域。ABA 问题、CAS、带标签指针和工作窃取双端队列都是公认的概念。该模型是此问题的标准表示。\n- **是否定义良好：** 问题提供了所有必要的数据（$C$，$M_{\\max}$）和一个明确的目标（找到最小的整数 $b$），从而允许一个唯一的数学解。\n- **客观性：** 语言技术性强、精确，且没有主观性。\n- **缺陷清单：**\n  1.  **科学/事实不健全：** 无。该模型是真实世界计算机科学问题的有效抽象。\n  2.  **不可形式化/不相关：** 无。该问题可直接形式化为一个数论不等式。\n  3.  **设置不完整/矛盾：** “top 指针的更改”与“成功的窃取”的措辞可能被视为略有歧义。然而，在工作窃取双端队列的 `top` 指针的上下文中，它们实际上是同义词。窃取者的成功窃取是典型的“top 指针的成功更改”。假设它们是同一事件，则问题是自洽的。如果它们不同，问题将是未充分说明的，但最简洁和上下文中最合理的解释是它们是相同的。\n  4.  **不切实际/不可行：** 数字很大（$C=2^{20}$，$M_{\\max}=10^{12}$），但它们用于定义高性能系统在长时间运行期间的操作约束，并且在数学上是合理的。\n  5.  **不适定/结构不良：** 无。期望得到一个唯一的、最小的整数解 $b$。\n  6.  **伪深刻/琐碎/同义反复：** 无。解决方案需要非平凡的计算以及对模运算和对数的理解。\n  7.  **超出科学可验证范围：** 无。解决方案是可以通过数学推导和验证的。\n\n**步骤3：结论和行动**\n问题是有效的。我将继续推导解决方案。\n\n**2. 解决方案的推导**\n\n问题陈述，如果打包字 $(i, t)$ 在经过 $m$ 次成功 top 指针更改后返回其初始值 $(i_0, t_0)$，其中 $0  m  M_{\\max}$，则会发生 A-B-A 漏洞。每次成功的更改都会使索引 $i$ 在模 $C$ 的意义下加 $1$，标签 $t$ 在模 $2^b$ 的意义下加 $1$。\n\n为了使状态在 $m$ 次更改后返回到 $(i_0, t_0)$，必须同时满足以下两个同余方程：\n1. $i_0 + m \\equiv i_0 \\pmod{C}$\n2. $t_0 + m \\equiv t_0 \\pmod{2^b}$\n\n这两个方程可以简化为：\n1. $m \\equiv 0 \\pmod{C}$\n2. $m \\equiv 0 \\pmod{2^b}$\n\n这意味着 $m$ 必须是 $C$ 和 $2^b$ 的公倍数。可能发生 A-B-A 再次出现的最小正值 $m$ 是 $C$ 和 $2^b$ 的最小公倍数 (LCM)。\n$$m_{\\text{min_ABA}} = \\text{lcm}(C, 2^b)$$\n\n我们已知 $C = 2^{20}$。为了求两个同底幂的最小公倍数，我们取该底数，指数为两者中的最大值。\n$$ \\text{lcm}(2^{20}, 2^b) = 2^{\\max(20, b)} $$\n\n为了保证在任何严格少于 $M_{\\max}$ 次的更改中都不会发生 A-B-A 事件，可能导致 A-B-A 的最小更改次数必须至少为 $M_{\\max}$。\n$$ m_{\\text{min_ABA}} \\ge M_{\\max} $$\n代入 $m_{\\text{min_ABA}}$ 和 $M_{\\max}$ 的表达式：\n$$ 2^{\\max(20, b)} \\ge 10^{12} $$\n\n为了解出 $b$，我们对不等式两边取以 $2$ 为底的对数：\n$$ \\max(20, b) \\ge \\log_2(10^{12}) $$\n$$ \\max(20, b) \\ge 12 \\log_2(10) $$\n\n我们使用近似值 $\\log_2(10) \\approx 3.321928$。\n$$ \\max(20, b) \\ge 12 \\times 3.321928 $$\n$$ \\max(20, b) \\ge 39.863136 $$\n\n因为 $b$ 必须是表示位数的整数，所以 $\\max(20, b)$ 的值也必须是整数。满足此不等式的最小整数值为 $40$。\n$$ \\max(20, b) \\ge 40 $$\n\n我们现在必须找到满足 $\\max(20, b) \\ge 40$ 的最小整数 $b$。\n- 如果 $b \\le 20$，那么 $\\max(20, b) = 20$。条件变为 $20 \\ge 40$，这是错误的。因此，$b$ 不能小于或等于 $20$。\n- 如果 $b > 20$，那么 $\\max(20, b) = b$。条件变为 $b \\ge 40$。\n\n综合这些发现，我们需要 $b > 20$ 且 $b \\ge 40$。更严格的条件是 $b \\ge 40$。满足此条件的最小整数值 $b$ 是 $b=40$。\n\n**3. 逐项分析**\n\n现在我将根据推导出的最小要求 $b = 40$ 来评估每个选项。\n\n**A. $b = 20$**\n如果 $b=20$，直到第一次可能发生 A-B-A 的操作次数是 $\\text{lcm}(2^{20}, 2^{20}) = 2^{20}$。\n我们检查这是否能保证安全：\n$2^{20} = (2^{10})^2 = (1024)^2 = 1,048,576$。\n这个值远小于 $M_{\\max} = 10^{12}$。A-B-A 可能在远未达到指定限制时发生。\n因此，此选项是 **不正确的**。\n\n**B. $b = 30$**\n如果 $b=30$，直到第一次可能发生 A-B-A 的操作次数是 $\\text{lcm}(2^{20}, 2^{30}) = 2^{\\max(20, 30)} = 2^{30}$。\n我们检查这是否能保证安全：\n$2^{30} = (2^{10})^3 = (1024)^3 \\approx (10^3)^3 = 10^9$。\n具体来说，$2^{30} = 1,073,741,824$。这个值小于 $M_{\\max} = 10^{12}$。A-B-A 在不安全的窗口内是可能发生的。\n因此，此选项是 **不正确的**。\n\n**C. $b = 40$**\n如果 $b=40$，直到第一次可能发生 A-B-A 的操作次数是 $\\text{lcm}(2^{20}, 2^{40}) = 2^{\\max(20, 40)} = 2^{40}$。\n为了验证安全性，我们检查 $2^{40} \\ge 10^{12}$。\n$2^{40} = (2^{10})^4 = (1024)^4$。\n因为 $1024 > 1000 = 10^3$，所以 $(1024)^4 > (10^3)^4$，即 $2^{40} > 10^{12}$。\n更精确地说，$2^{40} \\approx 1.1 \\times 10^{12}$，大于 $M_{\\max} = 10^{12}$。\n第一次 A-B-A 只能在至少 $2^{40}$ 次操作后发生，这比我们必须保证安全的 $M_{\\max}-1$ 次操作要多。如推导中所证， $b=39$ 是不够的。因此，$b=40$ 是提供所需保证的最小整数标签宽度。\n因此，此选项是 **正确的**。\n\n**D. $b = 50$**\n如果 $b=50$，直到第一次可能发生 A-B-A 的操作次数是 $\\text{lcm}(2^{20}, 2^{50}) = 2^{\\max(20, 50)} = 2^{50}$。\n$2^{50} = (2^{10})^5 \\approx (10^3)^5 = 10^{15}$。\n这显然大于 $M_{\\max} = 10^{12}$，所以这个标签宽度也能在给定范围内防止 A-B-A 问题。\n然而，问题要求的是*最小的*标签宽度 $b$。既然我们发现 $b=40$ 就足够了，而 $50 > 40$，所以这个选项不是最小的正确值。\n因此，此选项是 **不正确的**。", "answer": "$$\\boxed{C}$$", "id": "3664130"}, {"introduction": "现在，让我们将前面学到的概念应用于一个真实世界的高性能并发模式：读-复制-更新（Read-Copy-Update, RCU）。这个编程练习 [@problem_id:3664167] 要求你实现一个支持无锁读取的字典。它综合了原子操作、用于发布更新的内存顺序以及安全内存回收这一核心挑战的知识，而后者正是 RCU 用于解决“释放后使用”(use-after-free) 问题的精妙方案。", "problem": "你需要实现一个读-复制-更新（Read-Copy-Update, RCU）字典，该字典支持非阻塞的读者，以及发布新快照并将旧快照的回收延迟到宽限期结束后的写者。此任务的教育背景是操作系统入门，重点面向高等本科水平的非阻塞同步。\n\n需要使用的基本原理和定义：\n- 原子操作相对于并发执行是不可分割的。设 $x$ 为一个原子变量；原子存储表示为 $\\text{store}(x, v)$，原子加载表示为 $\\text{load}(x)$。\n- 内存排序语义：acquire 操作确保程序顺序中后续的加载和存储能够观察到由其他线程使用 release 语义执行的先前存储。release 操作确保其之前的加载和存储对于执行 acquire 操作并读取到该发布变量的线程可见。形式上，如果一个写者执行 $\\text{store\\_release}(x, v)$ 且一个读者执行 $\\text{load\\_acquire}(x)$ 并观察到 $v$，则该读者将观察到在写者 release 操作之前发生的所有写操作。\n- 在读-复制-更新中，读者在永不阻塞的读端临界区内执行，而写者发布一个指向完全成形的副本（快照）的新根指针，并淘汰旧的根。被淘汰快照的内存回收被延迟到一个宽限期过去之后，宽限期定义为所有可能持有对被淘汰快照引用的读者都已退出其读端临界区的时间间隔。\n\n你的实现必须满足：\n- 字典将字符串键映射到整数值。每个快照一旦发布就是不可变的。\n- 读者：\n  - 读者通过对全局根指针执行 acquire 加载并增加一个全局原子读者计数器来开始一个读端临界区。将读者计数器表示为 $R$。\n  - 读者无需锁也无需等待地遍历快照，并通过以 release 语义递减 $R$ 来结束读端临界区。\n- 写者：\n  - 写者通过复制当前根并应用修改（插入、更新或删除）来创建一个新快照。\n  - 写者使用 release 存储或在原子根指针上进行 acquire-release 交换来发布新的根。\n  - 旧的根被放置到一个淘汰列表中。只有当 $\\text{load\\_acquire}(R) = 0$（一个宽限期）时，才可能对所有被淘汰的根进行回收，此时写者可以安全地释放所有被淘汰的快照。\n\n假设一个单进程模拟，其中的顺序步骤遵循 acquire-release 语义；你不需要衍生实际的线程。但是，你必须使用带有 acquire/release 内存排序的原子操作来模拟正确的先行发生（happens-before）关系。\n\n实现程序以处理以下测试场景套件。初始字典快照包含三个键值对：$\\text{\"mode\"} \\mapsto 1$，$\\text{\"threads\"} \\mapsto 4$，$\\text{\"debug\"} \\mapsto 1$。\n\n测试套件：\n1. 常规更新路径：\n   - 写者通过发布新快照将 $\\text{\"mode\"}$ 更新为 $2$，并淘汰旧根。\n   - 读者进入读端临界区，从其快照中读取 $\\text{\"mode\"}$，然后退出。\n   - 此测试的输出是读者观察到的 $\\text{\"mode\"}$ 的整数值。\n2. 并发更新下的快照一致性：\n   - 读者进入，读取 $\\text{\"threads\"}$（初始为 $4$）。\n   - 写者通过发布新快照将 $\\text{\"threads\"}$ 更新为 $8$，并淘汰旧根。\n   - 同一个读者，仍在读端临界区内，再次从其快照中读取 $\\text{\"threads\"}$，然后退出。\n   - 此测试的输出是同一读者在同一临界区内观察到的整数差值 $d = v_{\\text{after}} - v_{\\text{before}}$。一致的快照意味着 $d = 0$。\n3. 带有延迟回收的删除：\n   - 读者进入，读取键 $\\text{\"debug\"}$ 是否存在（如果找到则存在编码为 $1$，否则为 $0$）。\n   - 写者通过发布新快照删除 $\\text{\"debug\"}$，并淘汰旧根。\n   - 同一个读者，仍在读端临界区内，再次读取 $\\text{\"debug\"}$ 是否存在，然后退出。\n   - 一个新读者进入并读取 $\\text{\"debug\"}$ 是否存在，然后退出。\n   - 此测试的输出是一个整数 $b$。如果第一个读者在其临界区之前和期间都观察到存在值为 $1$，而新读者在删除后观察到存在值为 $0$，则 $b$ 定义为 $1$；否则为 $0$。\n4. 多次写入间的延迟释放：\n   - 读者进入并停留在其读端临界区内。\n   - 写者执行三次连续的发布：将 $\\text{\"mode\"}$ 更新为 $3$，插入 $\\text{\"opt\"} \\mapsto 7$，并将 $\\text{\"threads\"}$ 更新为 $16$，每次发布都淘汰旧根。\n   - 当读者仍然活跃时，尝试回收（由于 $R > 0$，必须不回收任何东西）。\n   - 读者退出，然后进行回收，并释放所有被淘汰的根。\n   - 此测试的输出是在该回收步骤中释放的被淘汰根的整数数量。有三次发布和一个读者延迟回收，正确的值是 $3$。\n\n要求的最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试顺序排列：$[\\text{result1},\\text{result2},\\text{result3},\\text{result4}]$。\n\n所有输出都是整数。不涉及物理单位或角度单位。不得使用百分比；存在性必须按规定编码为整数。\n\n你的程序必须是一个完整的、可运行的程序，没有用户输入。使用带有 acquire 和 release 语义的原子操作来模拟非阻塞的读者行为和写者的延迟释放。", "solution": "该问题要求使用读-复制-更新（RCU）非阻塞同步机制来实现一个字典。解决方案必须在一个单线程模拟中，根据指定的 acquire-release 内存语义，正确地模拟并发读者和写者的行为。\n\n### 基于原则的设计\n\n该解决方案基于读-复制-更新（RCU）的核心原则，RCU 是一种针对读多写少场景优化的同步技术。\n\n1.  **读端临界区**：读者操作无需锁。他们获取一个指向数据一致性快照的指针，并保证该快照在他们的读端临界区持续期间不会被修改或释放。\n2.  **写时复制更新**：写者不就地修改数据。相反，他们创建数据结构的私有副本，对该副本应用修改，然后通过更新单个全局指针来原子地“发布”新版本。\n3.  **延迟回收**：由于读者可能正在遍历数据的旧版本，写者不能立即释放与之关联的内存。旧数据版本的回收被延迟到一个“宽限期”过去之后，宽限期定义为所有可能正在使用旧数据的读者完成其临界区所需的时间。\n\n### 数据结构\n\n为实现 RCU 字典，采用了以下数据结构：\n\n-   **字典节点 (`RCU_Node`)**：使用标准的单向链表节点来表示一个键值对。每个节点包含一个键（字符串）、一个值（整数）和一个指向下一个节点的指针。\n    $$\n    \\text{struct } \\text{RCU\\_Node} \\{ \\text{char*} \\text{ key}; \\text{int value}; \\text{struct } \\text{RCU\\_Node*} \\text{ next}; \\}\n    $$\n-   **快照 (`RCU_Snapshot`)**：字典的快照仅仅是指向 `RCU_Node` 链表头部的指针。由于快照一旦发布就是不可变的，此指针提供了对字典一个完整、一致版本的访问。\n-   **全局根指针 (`g_rcu_root`)**：一个全局原子指针 `_Atomic(RCU_Snapshot) g_rcu_root`，指向当前活动的快照。这是读者和写者之间协调的中心点。\n-   **读者计数器 (`g_reader_count`)**：一个全局原子整数 `_Atomic int g_reader_count`，跟踪当前在读端临界区内执行的读者数量。\n-   **淘汰列表 (`Retired_Node`)**：一个简单的、非原子的链表，供写者用来跟踪等待回收的旧快照。由于问题模拟的是串行化的写者，此列表不需要原子访问。\n\n### 同步与内存排序\n\nRCU 的正确性取决于严格的内存排序规则，这些规则通过 C11/C23 `stdatomic.h` 的原语实现。\n\n-   **读者进入临界区**：读者通过调用一个类似于 `rcu_read_lock()` 的函数开始。\n    1.  它使用 `memory_order_acquire` 语义对全局根指针 `g_rcu_root` 执行原子加载：`local_root = atomic_load_explicit(, memory_order_acquire)`。此 acquire 操作确保读者能看到写者在发布该根指针之前所做的所有写入。读者现在拥有一个指向不可变快照的稳定指针。\n    2.  它增加全局读者计数器 `g_reader_count`：`atomic_fetch_add_explicit(, 1, memory_order_relaxed)`。此操作表示一个新读者处于活动状态。它可以使用 relaxed 排序，因为必要的内存排序已由根指针的 acquire 加载建立。\n\n-   **读者退出临界区**：完成后，读者调用一个类似于 `rcu_read_unlock()` 的函数。\n    1.  它使用 `memory_order_release` 语义递减读者计数器：`atomic_fetch_sub_explicit(, 1, memory_order_release)`。此 release 操作至关重要。它确保读者在其临界区内执行的所有内存访问对写者的宽限期检测逻辑可见。\n\n-   **写者发布新快照**：写者遵循“复制-更新-发布”序列。\n    1.  它创建当前快照的深拷贝。\n    2.  它将所有修改（插入、更新、删除）应用于此私有副本。\n    3.  它使用 `atomic_exchange_explicit(, new_snapshot, memory_order_acq_rel)` 原子地交换全局根指针，以发布新版本并检索旧版本。`release` 语义使新快照的内容对后续读者的 `acquire` 加载可见。`acquire` 语义确保写者的内存视图在淘汰旧快照之前是同步的。\n    4.  旧快照指针被添加到淘汰列表。\n\n-   **写者回收内存**：写者可以通过检查宽限期是否结束来启动内存回收。\n    1.  宽限期结束的条件是没有活动的读者，即 `g_reader_count == 0`。\n    2.  该检查通过 `atomic_load_explicit(, memory_order_acquire)` 执行。此 `acquire` 与读者退出其临界区时执行的 `release` 递减操作同步。如果加载返回 $0$，则可以保证任何可能持有对被淘汰快照引用的读者都已完成其工作，并且其所有内存操作现在都可见。\n    3.  如果条件满足，写者可以安全地遍历淘汰列表并释放与旧快照相关的所有内存。\n\n### 测试场景执行\n\n实现顺序执行四个测试场景。状态被管理，使得活动字典快照 (`g_rcu_root`) 在测试之间保持不变，但淘汰列表在每个测试后被清除（如测试 $4$ 的预期结果所示），以模拟独立的回收场景。\n\n-   **测试 1**：写者更新一个值，随后的读者正确地观察到新值 $2$。\n-   **测试 2**：读者获取一个快照。然后写者发布一个新快照。该读者仍在其原始的、不可变的快照上操作，两次读取到相同的值，展示了快照隔离性。差值为 $0$。\n-   **测试 3**：读者（读者 1）获取一个其中键 `\"debug\"` 存在的快照。然后写者删除该键并发布一个新快照。读者 1 仍在其临界区内，重新读取并发现该键在其本地快照中仍然存在。然后一个新读者（读者 2）开始并获取新快照，正确地发现该键不存在。这产生结果 $1$。\n-   **测试 4**：一个读者保持活动状态，而一个写者执行三次连续的更新，淘汰了三个旧快照。在读者活跃时尝试回收内存失败（因为 `g_reader_count > 0`）。只有在读者退出且 `g_reader_count` 变为 $0$ 之后，后续的回收尝试才能成功，释放 $3$ 个被淘汰的快照。\n\n此设计正确地模拟了 RCU 的基本属性：非阻塞读取、快照一致性，以及基于 acquire-release 语义的显式宽限期检测的安全、延迟内存回收。", "answer": "$$\\boxed{[2,0,1,3]}$$", "id": "3664167"}]}