{"hands_on_practices": [{"introduction": "在构建并发应用程序时，一个核心的性能调优问题是如何确定线程池的最佳大小。本练习将引导你通过一个理论模型，探索处理器核心数、线程阻塞概率以及线程池大小之间的关系[@problem_id:3661557]。通过这项实践，你将学会如何在最大化CPU利用率（以提高吞吐量）与避免过多上下文切换开销之间做出权衡。", "problem": "一台服务器在一台拥有 $N$ 个硬件核心的多核机器上运行。它使用一个大小为 $P$ 的固定大小线程池来处理稳定的同构任务流。每个线程在中央处理器（CPU）上执行和等待输入/输出（I/O）之间重复交替。在任何调度时刻，一个线程有 $p_b$ 的概率被阻塞（等待 I/O），且与其他线程独立，有 $1 - p_b$ 的概率可运行。操作系统采用轮询调度器：当多个可运行线程为一个给定的核心竞争时，调度器会为该核心上的每个可运行线程分配一个长度为 $q$ 的时间片，并在每个时间片结束时执行一次成本为 $c$ 的上下文切换（当一个正在运行的线程在其时间片完成前阻塞时也是如此）。\n\n您希望设计一个调优测试，通过改变 $P$ 来最大化吞吐量，同时控制上下文切换的开销。在持续的工作负载下，您将为每个 $P$ 值测量两个指标：(i) 总吞吐量（单位时间内完成的 CPU 段数）和 (ii) 每秒上下文切换次数。您的目标是选择 $P$，使得可运行线程的期望数量接近核心数量，以避免核心空闲，但又不能太大，以至于轮询抢占和频繁阻塞导致过度的上下文切换开销。\n\n哪个选项最能描述您在选择 $P$ 时应应用的规则及其背后的基本原理？\n\nA. 设置 $P = N$，因为任何更大的 $P$ 只会增加上下文切换而不会提高吞吐量；当 $q$ 固定时，阻塞概率 $p_b$ 对理想的 $P$ 没有影响。\n\nB. 设置 $P \\approx \\left\\lceil \\dfrac{N}{1 - p_b} \\right\\rceil$，因为可运行线程的期望数量 $\\mathbb{E}[R] = P (1 - p_b)$ 应接近 $N$：如果 $\\mathbb{E}[R]  N$，一些核心会空闲，吞吐量会下降；如果 $\\mathbb{E}[R] \\gg N$，轮询抢占会确保每个核心的上下文切换开销约为 $c / q$，从而降低每个核心的有效 CPU 时间。\n\nC. 设置 $P \\approx N (1 - p_b)$，因为阻塞减少了有效的 CPU 需求；线程池大小应与 $1 - p_b$ 成比例减少，以最小化上下文切换开销。\n\nD. 设置 $P \\gg N$（例如 $P = 10 N$），因为激进的超额配置可以隐藏 I/O 停顿；在 $q$ 固定的情况下，保持核心繁忙所带来的吞吐量增益总是超过上下文切换开销 $c$。\n\nE. 设置 $P \\approx \\left\\lfloor \\dfrac{N}{1 + p_b} \\right\\rfloor$，因为在分母中将 $p_b$ 加到 $1$ 上可以解释阻塞问题，并减少由抢占引起的上下文切换，同时保持核心的完全利用。", "solution": "### 第一部分：问题分析\n\n本问题旨在为I/O密集型工作负载确定最佳线程池大小，以在拥有 $N$ 个核心的处理器上最大化吞吐量。关键在于平衡CPU利用率和上下文切换开销。\n\n系统的核心参数如下：\n-   硬件核心数：$N$\n-   线程池大小：$P$\n-   单个线程的阻塞概率：$p_b$\n-   单个线程的可运行概率：$1 - p_b$\n\n目标是最大化吞吐量，这要求我们尽可能让所有 $N$ 个核心都保持忙碌状态。一个核心只有在有可运行线程时才能工作。\n\n### 第二部分：解答推导\n\n1.  **可运行线程的期望数量**\n    设 $R$ 为在任意时刻可运行线程的数量。由于线程池中有 $P$ 个线程，且每个线程独立地以 $1 - p_b$ 的概率可运行，$R$ 服从二项分布 $R \\sim \\text{Binomial}(P, 1 - p_b)$。\n    可运行线程的期望数量为：\n    $$\\mathbb{E}[R] = P \\cdot (1 - p_b)$$\n\n2.  **优化目标**\n    为了使所有 $N$ 个核心都保持忙碌，我们期望系统中至少有 $N$ 个可运行的线程。\n    -   如果 $\\mathbb{E}[R]  N$，则平均而言，将有 $N - \\mathbb{E}[R]$ 个核心处于空闲状态，导致CPU资源浪费和吞吐量下降。\n    -   如果 $\\mathbb{E}[R] \\gg N$，则可运行的线程远多于核心数，导致在每个核心上都有一个等待运行的线程队列。这会增加上下文切换的频率（由于抢占和线程阻塞），从而增加开销，降低用于实际工作的有效CPU时间。\n\n    因此，理想的平衡点是使可运行线程的期望数量恰好等于核心数量，即：\n    $$\\mathbb{E}[R] = N$$\n\n3.  **推导最优池大小 $P$**\n    将 $\\mathbb{E}[R]$ 的表达式代入优化目标：\n    $$P \\cdot (1 - p_b) = N$$\n    解出 $P$：\n    $$P = \\frac{N}{1 - p_b}$$\n    由于线程数必须是整数，且为了应对统计波动并倾向于避免核心空闲，通常向上取整。因此，经验法则是：\n    $$P \\approx \\left\\lceil \\frac{N}{1 - p_b} \\right\\rceil$$\n\n4.  **评估选项**\n    -   **A. 设置 $P = N$**：此选项忽略了线程阻塞。当 $p_b > 0$ 时，这将导致 $\\mathbb{E}[R]  N$，造成核心利用不足。不正确。\n    -   **B. 设置 $P \\approx \\left\\lceil \\dfrac{N}{1 - p_b} \\right\\rceil$**：此选项与我们的推导完全一致，并正确地阐述了核心空闲（配置不足）和过度开销（过度配置）之间的权衡。正确。\n    -   **C. 设置 $P \\approx N (1 - p_b)$**：此公式将导致 $\\mathbb{E}[R] = N(1-p_b)^2$，这会造成严重的核心利用不足。逻辑是反的；阻塞需要更多的线程来补偿，而不是更少。不正确。\n    -   **D. 设置 $P \\gg N$**：此选项忽略了过度配置带来的性能惩罚。虽然一定程度的超额配置有益，但“总是”有利的说法是错误的，因为过多的线程会因内存消耗、缓存污染和调度器开销而降低整体性能。不正确。\n    -   **E. 设置 $P \\approx \\left\\lfloor \\dfrac{N}{1 + p_b} \\right\\rfloor$**：此公式在数学上不正确，同样会导致 $\\mathbb{E}[R]  N$，造成核心利用不足。不正确。\n\n### 结论\n选项B提供了正确的公式和对其背后权衡的准确解释，是确定I/O密集型任务线程池大小的经典法则。", "answer": "$$\\boxed{B}$$", "id": "3661557"}, {"introduction": "在多处理器系统中，性能瓶颈有时并非源于代码逻辑，而是来自硬件层面微妙的交互，伪共享（false sharing）就是典型的例子。本练习要求你设计一个微基准测试来揭示这一现象，即当多个线程访问逻辑上独立但物理上位于同一缓存行的数据时，性能会如何急剧下降[@problem_id:3661589]。这项实践将加深你对缓存一致性协议及其对并行程序性能影响的理解。", "problem": "一个包含 $M$ 个元素的数组，每个元素大小为 $b$ 字节，由运行在多核处理器上的 $N$ 个线程共享。每个核心拥有私有的 1 级和 2 级缓存以及一个共享的末级缓存，缓存一致性通过修改、独占、共享、无效（MESI）协议来维护。缓存行大小为 $L$ 字节。操作系统调度器可能会在核心之间迁移线程，除非通过处理器亲和性（绑定）来阻止。现提出一个吞吐量实验，其中每个线程 $t \\in \\{0, 1, \\dots, N-1\\}$ 对一个指定的数组元素重复执行非原子性增量操作，该元素的索引是步长参数 $s$ 的函数；步长 $s$ 将在一组整数值上变化，以观察吞吐量悬崖。吞吐量以单位时间内的总增量次数来衡量。\n\n仅使用以下基本事实：\n- 一个核心对某个缓存行内地址的写入，会强制其他核心上该缓存行的副本根据一致性协议转换为无效状态，即使这些核心正在写入同一缓存行内的不同字。\n- 当多个核心频繁写入同一缓存行内的不同字时，一致性流量（“乒乓效应”）会占主导地位，尽管没有真正的数据依赖（伪共享），但仍会降低吞吐量。\n- 绑定线程可以防止调度器迁移，否则迁移会引入额外的噪声和混淆性的缓存行为。\n- 通过填充或对齐数据，使并发写入的字占据不同的缓存行，可以减少一致性冲突。\n\n请选择一个选项，该选项最严谨地指定了一个通过改变 $s$ 来暴露伪共享的实验，并提出了一种操作系统调度器策略和一种数据布局策略，以缓解完全由伪共享引起的吞吐量悬崖，同时控制其他混淆因素（如非均匀内存访问（NUMA）效应和线程迁移）。假设 $N$ 至少为 $4$，$L$ 是一个典型的缓存行大小（例如 $L = 64$ 字节），$b$ 对应于一个 $64$ 位整数（例如 $b = 8$ 字节）。如果需要，可以对齐数组的基地址。\n\nA. 将每个线程绑定到同一插槽（socket）上一个独立的物理核心。将数组的基地址与缓存行边界对齐。为线程 $t$ 分配索引 $i_t = t \\cdot s$ 让其在固定时间内持续更新，并对 $s$ 进行扫描，取值如 $s \\in \\{1, 2, 4, 8, 16, 32\\}$。记录每秒的总增量次数。为了缓解吞吐量悬崖，引入每个线程 $p$ 个元素的填充，使每个线程的槽位索引变为 $i_t = t \\cdot (s + p)$，其中 $p$ 取满足 $p \\cdot b \\geq L$ 的最小值，并保持线程绑定以防止迁移。\n\nB. 允许操作系统自由调度和迁移线程。对于每个 $s$，为每个线程 $t$ 分配在 $\\{0, 1, \\dots, M-1\\}$ 中均匀分布的随机索引进行更新，并以一定概率跳过步长 $s$。测量吞吐量。为了缓解吞吐量悬崖，增加线程数量并启用同时多线程（SMT）以隐藏内存延迟。\n\nC. 在一个具有非均匀内存访问（NUMA）的双插槽系统中，将一半线程绑定到插槽 0 的核心上，另一半绑定到插槽 1 的核心上。为线程 $t$ 分配索引 $i_t = t \\cdot s$ 进行更新，并对 $s$ 取较大值进行扫描，例如 $s \\geq M/N$，以确保线程更新的元素间隔很远。为了缓解吞吐量悬崖，跨 NUMA 节点交错分配内存，并依赖硬件预取器。\n\nD. 将所有线程绑定到单个核心以最大化缓存复用。为线程 $t$ 分配索引 $i_t = t \\cdot s$ 进行更新并改变 $s$。为了缓解吞吐量悬崖，使用页表属性禁用缓存，并完全依赖主存访问以避免一致性交互。\n\nE. 将每个线程绑定到同一插槽上一个独立的物理核心。不要刻意对齐数组基地址。为线程 $t$ 分配索引 $i_t = t \\cdot s$ 进行更新，并对 $s$ 在 $\\{1, 2, 3, 5, 7, 9\\}$ 上进行扫描。为了缓解吞吐量悬崖，在不改变数据布局的情况下，启用积极的编译器向量化和硬件预取。\n\n哪个选项最能满足上述实验设计目标，并提供了合理的调度器绑定和填充策略，以专门缓解因 $s$ 变化而引起的伪共享导致的吞吐量悬崖？", "solution": "### 第一部分：问题分析\n\n本题要求设计一个严谨的微基准测试来暴露和缓解伪共享（false sharing）现象。一个好的实验设计必须满足以下条件：\n1.  **可控性**：必须隔离研究的现象（伪共享），同时控制或消除其他可能影响性能的混淆因素，如线程迁移、NUMA效应等。\n2.  **可观察性**：实验变量（步长 $s$）的变化必须能清晰地揭示伪共享导致的性能“悬崖”。\n3.  **有效的缓解策略**：提出的解决方案必须能从根本上解决伪共享问题。\n\n伪共享的根源是多个核心并发写入位于**同一缓存行**但**逻辑独立**的数据。在给定参数下（缓存行大小 $L=64$ 字节，元素大小 $b=8$ 字节），一个缓存行可以容纳 $L/b = 8$ 个元素。线程 $t$ 和 $t+1$ 分别访问索引为 $t \\cdot s$ 和 $(t+1) \\cdot s$ 的元素，它们之间的内存距离为 $s \\cdot b$ 字节。\n-   当 $s \\cdot b  L$（即 $s  8$）时，多个线程访问的元素很可能位于同一缓存行，从而引发严重的伪共享。\n-   当 $s \\cdot b \\geq L$（即 $s \\geq 8$）时，相邻线程访问的元素保证位于不同的缓存行（假设内存对齐），伪共享现象消失。\n\n因此，实验应围绕步长 $s=8$ 这个临界点进行扫描。\n\n### 第二部分：解答推导\n\n我们逐一评估每个选项的设计是否严谨。\n\n-   **A. 将每个线程绑定到同一插槽（socket）上一个独立的物理核心。将数组的基地址与缓存行边界对齐。为线程 $t$ 分配索引 $i_t = t \\cdot s$ 让其在固定时间内持续更新，并对 $s$ 进行扫描，取值如 $s \\in \\{1, 2, 4, 8, 16, 32\\}$...**\n    -   **实验设计**：非常严谨。\n        -   `将每个线程绑定到同一插槽上一个独立的物理核心`：此举有效地消除了线程迁移和NUMA效应这两个主要的混淆因素。\n        -   `将数组的基地址与缓存行边界对齐`：确保了元素到缓存行的映射是可预测的，使实验结果更清晰。\n        -   `对 s 进行扫描，取值如 s ∈ {1, 2, 4, 8, 16, 32}`：这个扫描范围完美地跨越了伪共享的临界点（$s=8$），能够清晰地展示出当 $s8$ 时性能低下，而在 $s \\geq 8$ 时性能急剧提升的“悬崖”现象。\n    -   **缓解策略**：策略是有效的。它通过增加数据间距（填充）来确保每个线程操作的数据独占一个缓存行，从而从根本上解决问题。尽管 $i_t = t \\cdot (s + p)$ 的表达方式略显复杂，但其效果是保证了并发访问元素之间的距离大于一个缓存行，功能上是正确的。\n    -   **结论**：**正确**。这是最符合科学实验设计原则的选项。\n\n-   **B. 允许操作系统自由调度和迁移线程。更新随机索引...**\n    -   **实验设计**：存在严重缺陷。允许线程迁移和使用随机索引会引入大量噪声，完全掩盖了由步长 $s$ 控制的伪共享效应。\n    -   **结论**：**不正确**。\n\n-   **C. 在一个具有非均匀内存访问（NUMA）的双插槽系统中，将线程绑定到不同插槽...**\n    -   **实验设计**：存在严重缺陷。故意跨NUMA节点绑定线程，会引入远程内存访问延迟，使伪共享和NUMA效应混杂在一起，无法分离。扫描较大的 $s$ 值会直接错过伪共享发生的区域。\n    -   **结论**：**不正确**。\n\n-   **D. 将所有线程绑定到单个核心...**\n    -   **实验设计**：无效。将所有线程放在一个核心上，它们会分时复用该核心，而不是并行执行。这从根本上消除了多核并发，也就无从谈起伪共享。\n    -   **结论**：**不正确**。\n\n-   **E. ...不要刻意对齐数组基地址...启用积极的编译器向量化和硬件预取。**\n    -   **实验设计**：不够严谨。不对齐基地址会使结果依赖于偶然的内存布局，降低实验的可复现性。\n    -   **缓解策略**：无效。向量化和预取是针对其他性能问题的优化，它们无法解决写-写冲突导致的缓存行“乒乓”问题。\n    -   **结论**：**不正确**。\n\n### 结论\n选项A提出了一个控制变量严谨、实验设计合理、缓解策略有效的方案，是揭示和解决伪共享问题的最佳选择。", "answer": "$$\\boxed{A}$$", "id": "3661589"}, {"introduction": "正确的同步机制不仅要保证互斥，还必须确保公平性，尤其是在具有不同优先级的线程环境中。本练习模拟了一个场景，其中一个设计不当的自旋锁导致了高优先级线程的饥饿问题[@problem_id:3661484]。你将分析并选择一种高级锁定策略，以在多核抢占式调度器下确保高优先级任务的响应性并提供可预测的等待时间界限。", "problem": "考虑一个拥有 $N$ 个相同核心的多核操作系统，它运行着一个全局固定优先级抢占式调度器。抢占在全局范围内是启用的，但在某些临界区内除外。在临界区内，线程在获取用于保护内核数据结构的共享锁时会禁用抢占。该锁是一个简单的测试并设置（test-and-set）自旋锁，没有公平性保证。以下定义构成了推理的基础：\n\n- 互斥（Mutual exclusion）确保在任何时候最多只有一个线程持有锁。\n- 进展（Progress）要求如果有一个或多个线程希望进入临界区，那么必须有某个线程能够取得进展。\n- 有限等待（Bounded waiting）保证每个请求锁的线程最终都会在一个有限的时间界限内获得锁，该界限不依赖于其他线程的无界行为。\n- 饥饿（Starvation）发生在因竞争或调度决策导致线程的等待时间无界时。\n- 优先级反转（Priority inversion）发生在高优先级线程等待一个持有资源的低优先级线程时。\n\n该系统有 $N = 4$ 个核心和两类线程：\n- $H = 2$ 个高优先级线程 $\\{H_1, H_2\\}$，它们周期性地进入一个持续时间为 $C_H = 10\\,\\mu s$ 的临界区，周期为 $P_H = 5\\,ms$。\n- $L = 6$ 个低优先级线程 $\\{L_1,\\dots,L_6\\}$，它们重复进入同一个持续时间为 $C_L = 200\\,\\mu s$ 的临界区，并在两次释放和重新获取锁之间执行持续时间为 $W_L = 50\\,\\mu s$ 的非临界区工作脉冲。\n\n假设该自旋锁是高度缓存本地化的：释放锁的线程所在的核心会短暂地保留锁的缓存行，这使其在释放锁后立即重新获取锁时具有概率优势。在临界区内抢占被禁用，因此锁的持有者在退出临界区并重新启用抢占之前，不能被非自愿地调度出。在持续负载下，三个核心运行低优先级线程，这些线程在临界区和非临界区工作之间循环。第四个核心在就绪时调度高优先级线程。\n\n根据经验观察，一个到达并竞争锁的高优先级线程 $H_i$ 可能会被无限期饥饿，因为其他核心上的低优先级线程由于缓存局部性偏向而重复地重新获取锁。由于在临界区内禁用了抢占，调度器无法抢占一个持有锁的低优先级线程，因此无论是互斥还是进展都不能保证 $H_i$ 的有限等待。\n\n你的任务是选择一种设计变更，既能防止高优先级线程的饥饿，又能为其进入临界区的最坏情况等待时间得出一个可证明的、紧凑的上限，同时保持互斥性。考虑以下候选设计和参数：\n\n- 候选方案 A：在临界区内部以至多 $\\tau = 50\\,\\mu s$ 的间隔插入协作式抢占点。在抢占点，锁持有者检查一个内核标志，该标志指示是否存在任何更高优先级的等待者。如果存在这样的等待者，持有者将执行一次安全交接：它完成当前保持不变量的微观步骤，释放锁，并直接将所有权转移给最高优先级的等待者。该锁被替换为一个优先级感知队列锁，它按优先级降序排列等待者，并实现优先级继承（PI），即低优先级持有者在持有锁期间会继承等待队列中最高的优先级。交接开销为 $\\delta = 5\\,\\mu s$。\n- 候选方案 B：在临界区内保持禁用抢占，但将锁替换为一个仅对低优先级线程使用指数退避的测试并设置自旋锁；高优先级线程不使用退避。\n- 候选方案 C：在全局范围内启用抢占，包括临界区内部。保留非公平的测试并设置自旋锁，并依赖调度器在需要时中断长的临界区。\n- 候选方案 D：在临界区内保持禁用抢占，但将锁替换为一个先进先出（FIFO）票号锁。不实现优先级感知的排序或优先级继承。\n\n哪一个候选方案能同时确保 (i) 在所述负载和缓存局部性偏向下，高优先级线程无饥饿，以及 (ii) 任何高优先级线程进入临界区的最坏情况等待时间上限独立于 $L$ 和 $C_L$？对于所选的候选方案，请用给定参数陈述该上限，并从第一性原理（互斥、进展、有限等待和优先级反转控制）出发，简要论证该上限为何成立。选择最佳答案。\n\nA. 候选方案 A。\n\nB. 候选方案 B。\n\nC. 候选方案 C。\n\nD. 候选方案 D。", "solution": "### 第一部分：问题分析\n\n问题的核心在于一个具有固定优先级的多核系统中，一个设计不佳的同步机制（不公平的自旋锁 + 临界区内禁用抢占）导致了高优先级线程的饥饿。我们需要选择一个解决方案来同时满足两个条件：\n1.  **无饥饿**：保证高优先级线程最终能获得锁，即等待时间有界。\n2.  **紧凑且独立的等待时间上限**：高优先级线程的最坏情况等待时间必须有一个可计算的上限，并且这个上限必须独立于低优先级线程的数量（$L$）和它们临界区的长度（$C_L$）。\n\n初始问题源于两个关键缺陷的组合：\n-   **不公平的锁**：简单的测试并设置自旋锁不保证请求顺序，加上缓存局部性偏向，使得低优先级线程可以“战胜”等待中的高优先级线程。\n-   **无界优先级反转**：一个低优先级线程持有锁时，高优先级线程必须等待其完成整个长达 $C_L = 200\\,\\mu s$ 的临界区。\n\n### 第二部分：解答推导\n\n我们来评估每个候选方案是否满足这两个条件。\n\n-   **A. 协作式抢占、优先级感知队列锁和优先级继承（PI）**\n    -   **无饥饿性分析**：该方案引入了优先级感知的队列锁，从根本上解决了公平性问题。一旦高优先级线程进入等待队列，它将被排在所有低优先级线程之前。这保证了它不会被低优先级线程无限次地超越，从而防止了饥饿。\n    -   **等待时间上限分析**：当一个高优先级线程 $H_i$ 到达时，最坏的情况是：\n        1.  一个低优先级线程 $L_j$ 恰好持有锁。由于存在间隔为 $\\tau=50\\,\\mu s$ 的协作式抢占点，该低优先级线程在持有锁最多 $\\tau$ 时间后，就会检查并发现等待中的 $H_i$，然后执行耗时为 $\\delta=5\\,\\mu s$ 的交接。因此，来自一个低优先级持有者的最大阻塞时间为 $\\tau + \\delta$。\n        2.  另一个高优先级线程 $H_k$ ($k \\neq i$) 已经持有锁或在队列中等待。$H_i$ 需要等待它完成其临界区。系统中只有一个其他高优先级线程，其临界区时间为 $C_H=10\\,\\mu s$。\n    -   因此，最坏情况等待时间上限为：\n        $$W_{H, \\text{max}} \\le (\\text{来自一个 } L_j \\text{ 的阻塞}) + (\\text{来自其他 } H \\text{ 线程的阻塞})$$\n        $$W_{H, \\text{max}} \\le (\\tau + \\delta) + (H-1) \\cdot C_H = (50\\,\\mu s + 5\\,\\mu s) + (2-1) \\cdot 10\\,\\mu s = 65\\,\\mu s$$\n        这个上限是有限的，并且完全独立于低优先级线程的数量 $L$ 和它们临界区的长度 $C_L$。\n    -   **结论**：**正确**。该方案同时满足两个条件。\n\n-   **B. 为低优先级线程增加指数退避**\n    -   **无饥饿性分析**：退避是一种概率性机制，它降低了低优先级线程的竞争强度，但不能从根本上保证高优先级线程一定能获取锁。在极端情况下，饥饿仍有可能发生。它不能提供确定性的有限等待保证。\n    -   **等待时间上限分析**：如果一个低优先级线程获取了锁，高优先级线程仍需等待其完成整个 $C_L = 200\\,\\mu s$ 的临界区。因此，等待时间上限依赖于 $C_L$。\n    -   **结论**：**不正确**。\n\n-   **C. 在临界区内启用抢占**\n    -   **分析**：这是一个严重的设计错误。抢占一个持有自旋锁的线程可能导致其他核心上的线程进入无休止的自旋，浪费CPU资源。更糟糕的是，如果被抢占的线程所在的物理核心被调度去运行一个也需要该锁的线程，系统将发生死锁。这引入了比饥饿更严重的正确性问题。\n    -   **结论**：**不正确**。\n\n-   **D. 使用FIFO票号锁**\n    -   **无饥饿性分析**：FIFO顺序保证了每个请求锁的线程最终都会获得它，因此饥饿被阻止。条件(i)满足。\n    -   **等待时间上限分析**：由于锁是纯粹的FIFO，不感知优先级，一个高优先级线程可能会排在一系列低优先级线程之后。在最坏情况下，它可能需要等待最多 $N-1=3$ 个已经排队的低优先级线程。其等待时间将是这些线程临界区时间之和，即一个依赖于 $L$ 和 $C_L$ 的值（例如，最坏可达 $3 \\times C_L = 600\\,\\mu s$）。这违反了条件(ii)。\n    -   **结论**：**不正确**。\n\n### 结论\n只有候选方案A通过引入一套组合机制（协作式抢占、优先级队列、优先级继承），系统性地解决了公平性和无界优先级反转问题，从而提供了无饥饿保证以及一个独立于低优先级任务参数的紧凑等待时间上限。", "answer": "$$\\boxed{A}$$", "id": "3661484"}]}