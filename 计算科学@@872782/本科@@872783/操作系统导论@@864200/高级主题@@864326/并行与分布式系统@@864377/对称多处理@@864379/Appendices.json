{"hands_on_practices": [{"introduction": "在对称多处理（SMP）系统中，性能并非仅仅取决于计算本身，还深受内存系统行为的影响。一个典型的问题是“伪共享”（false sharing），即当多个处理器独立地修改位于同一缓存行（cache line）上的不同变量时，会引发不必要的缓存一致性流量，从而导致性能下降。\n\n这个练习旨在通过一个性能模型来量化伪共享的影响。通过对比连续存储的计数器和经过填充（padding）以对齐缓存行的计数器，你将亲手计算出性能差异，从而深刻理解数据布局对多核性能的关键作用。[@problem_id:3685550]", "problem": "您正在研究对称多处理（SMP）系统，其中多个处理器核心共享一个单一的相干内存空间。在此类系统中，缓存一致性协议（例如，修改、独占、共享、无效（MESI））通过在发生写入时使跨核心的缓存行失效或更新，来维护内存的一致视图。当多个线程频繁写入占用同一缓存行的独立变量时，会发生一种称为伪共享（false sharing）的现象，产生不必要的一致性流量并增加写入延迟。\n\n考虑一个包含 $N$ 个每线程计数器的数组，其中线程 $i$ 重复递增其自己的计数器。在未填充（unpadded）布局中，计数器在内存中连续放置，每个计数器占用 $s$ 字节。内存系统使用大小为 $L$ 字节的缓存行，因此最多有 $\\left\\lfloor \\frac{L}{s} \\right\\rfloor$ 个不同的计数器可以占用同一个缓存行。在填充（padded）布局中，每个计数器都放置在其自己专用的 $64$ 字节区域中，以确保没有两个计数器共享一个缓存行。\n\n假设在对称多处理系统上，增量操作的时间成本遵循以下性能模型：\n- 对于执行核心独占拥有的缓存行上的计数器，每次增量操作需要一个基础时间 $p_{\\text{base}}$（单位为纳秒）。\n- 由于伪共享，如果 $k$ 个线程并发地递增位于同一缓存行上的计数器，那么每次增量操作平均会为该行上每个其他参与线程带来一个额外的相干性惩罚 $p_{\\text{remote}}$（单位为纳秒），以重新获取独占所有权。也就是说，平均每次增量的惩罚与 $(k-1)$ 成正比。\n\n让每个线程在其自己的计数器上执行 $M$ 次增量操作。设 $F = \\left\\lfloor \\frac{L}{s} \\right\\rfloor$ 为未填充布局中每个缓存行可容纳的最大计数器数量。线程被连续分配到计数器，因此在未填充布局中，最大的共享组大小为 $k_{\\max} = \\min(N, F)$。在具有 $64$ 字节间距的填充布局中，我们假设每个计数器映射到一个独立的缓存行，因此 $k=1$。\n\n在这些假设下：\n- 将 $T_{\\text{unpadded}}$ 定义为在未填充布局中，一个线程完成 $M$ 次增量操作所需的时间，该时间由最慢的共享组决定。\n- 将 $T_{\\text{padded}}$ 定义为在填充的 $64$ 字节布局中，一个线程完成 $M$ 次增量操作所需的时间。\n- 加速比为 $R = \\frac{T_{\\text{unpadded}}}{T_{\\text{padded}}}$。\n\n您的任务是根据上述定义，使用缓存一致性行为的第一性原理推导出 $R$，并实现一个程序来为给定的测试套件计算 $R$。所有时间都以纳秒为单位处理。不涉及角度。不應使用百分比；请将任何比例表示为小数。\n\n测试套件：\n对于每个测试用例，参数为 $(N, s, L, M, p_{\\text{base}}, p_{\\text{remote}})$，其中 $N$、$s$、$L$ 和 $M$ 为整数，$p_{\\text{base}}$ 和 $p_{\\text{remote}}$ 为浮点数纳秒。请使用以下测试用例：\n1. $(N=8, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n2. $(N=1, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n3. $(N=4, s=16, L=64, M=500000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n4. $(N=9, s=8, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n5. $(N=8, s=64, L=64, M=1000000, p_{\\text{base}}=5.0, p_{\\text{remote}}=30.0)$\n6. $(N=8, s=8, L=64, M=2000000, p_{\\text{base}}=10.0, p_{\\text{remote}}=10.0)$\n7. $(N=10, s=12, L=64, M=750000, p_{\\text{base}}=8.0, p_{\\text{remote}}=24.0)$\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。每个 $R$ 都应以十进制形式的浮点值打印。\n\n程序必须完全自包含，不需要任何输入，并为列出的每个测试用例计算 $R$。不应打印任何无关的文本。", "solution": "该问题要求推导加速比 $R$，该比率量化了在对称多处理（SMP）系统中使用填充内存布局相对于连续（未填充）布局在缓解伪共享方面的性能提升。解决方案是根据提供的性能模型推导出来的。\n\n首先，我们形式化单个计数器增量操作的时间成本。模型指出，如果其他线程正在访问同一个缓存行，一次增量操作需要一个基础时间 $p_{\\text{base}}$ 再加上一个因缓存一致性流量产生的惩罚。对于一组在同一缓存行上并发递增计数器的 $k$ 个线程，每次增量操作会为其他 $(k-1)$ 个竞争线程中的每一个带来 $p_{\\text{remote}}$ 的惩罚。因此，作为共享线程数 $k$ 的函数，单次增量的平均时间 $T_{\\text{inc}}(k)$ 为：\n$$T_{\\text{inc}}(k) = p_{\\text{base}} + (k-1) p_{\\text{remote}}$$\n此方程假设 $k \\ge 1$。如果 $k=1$，则没有其他竞争线程，时间正确地简化为 $T_{\\text{inc}}(1) = p_{\\text{base}}$。\n\n接下来，我们确定一个线程在填充和未填充两种情况下完成其工作所需的总时间。每个线程执行 $M$ 次增量。\n\n在填充布局中，每个计数器被分配在自己专属的 $64$ 字节内存区域中。假设缓存行大小 $L$ 小于或等于 $64$ 字节（这是一个标准的假设，并且对于所有 $L=64$ 的测试用例都成立），这种填充确保了没有两个计数器会驻留在同一个缓存行上。因此，当一个线程递增其计数器时，它是该缓存行的唯一使用者。竞争线程的数量始终为 $k=1$。因此，单次增量的时间为 $T_{\\text{inc}}(1) = p_{\\text{base}}$。一个线程执行 $M$ 次增量操作的总时间 $T_{\\text{padded}}$ 为：\n$$T_{\\text{padded}} = M \\cdot T_{\\text{inc}}(1) = M \\cdot p_{\\text{base}}$$\n\n在未填充布局中，计数器在内存中连续放置。每个计数器的大小为 $s$ 字节。给定缓存行大小为 $L$ 字节，单个缓存行可容纳的最大计数器数量为 $F = \\left\\lfloor \\frac{L}{s} \\right\\rfloor$。\n问题陈述中提到，线程被连续分配到计数器，并且性能由“最慢的共享组”决定。这对应于为人口最稠密的缓存行而竞争的线程组。这个最大共享组的大小 $k_{\\text{max}}$ 是总线程数 $N$ 和每个缓存行最大计数器数 $F$ 的最小值。\n$$k_{\\text{max}} = \\min(N, F) = \\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right)$$\n对于这个最慢组中的任何线程，单次增量的时间是 $T_{\\text{inc}}(k_{\\text{max}})$。这样一个线程完成 $M$ 次增量操作的总时间 $T_{\\text{unpadded}}$ 为：\n$$T_{\\text{unpadded}} = M \\cdot T_{\\text{inc}}(k_{\\text{max}}) = M \\cdot (p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}})$$\n请注意，如果 $k_{\\text{max}} = 1$（当 $N=1$ 或 $F=1$ 时发生），则不存在伪共享，$T_{\\text{unpadded}}$ 正确地简化为 $M \\cdot p_{\\text{base}}$。\n\n最后，我们推导加速比 $R$，定义为 $R = \\frac{T_{\\text{unpadded}}}{T_{\\text{padded}}}$。代入 $T_{\\text{unpadded}}$ 和 $T_{\\text{padded}}$ 的表达式：\n$$R = \\frac{M \\cdot (p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}})}{M \\cdot p_{\\text{base}}}$$\n代表增量次数的因子 $M$ 被消去，这表明加速比与总工作负载无关，仅取决于系统参数和竞争水平：\n$$R = \\frac{p_{\\text{base}} + (k_{\\text{max}} - 1) p_{\\text{remote}}}{p_{\\text{base}}}$$\n代入 $k_{\\text{max}}$ 的表达式，得到用于计算的最终公式：\n$$R = \\frac{p_{\\text{base}} + \\left(\\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right) - 1\\right) p_{\\text{remote}}}{p_{\\text{base}}}$$\n这也可以表示为：\n$$R = 1 + \\frac{\\left(\\min\\left(N, \\left\\lfloor \\frac{L}{s} \\right\\rfloor\\right) - 1\\right) p_{\\text{remote}}}{p_{\\text{base}}}$$\n将使用这个最终表达式来计算所提供的每个测试用例的比率。对于所有测试用例，$N \\ge 1$ 且 $L \\ge s$，这确保了 $k_{\\text{max}} \\ge 1$，因此项 $(k_{\\text{max}}-1)$ 是非负的。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3685550"}, {"introduction": "了解了底层缓存行为（如伪共享）后，我们可以进阶到软件设计层面，探讨如何通过数据作用域的选择来优化性能。在多线程程序中，开发者常常面临一个抉择：是使用线程局部存储（Thread-Local Storage, TLS）还是共享全局变量？\n\n此练习提供了一个基于概率的成本模型，用于分析和比较这两种策略。你将计算并权衡 TLS 的一次性初始化开销与共享变量可能带来的持续性缓存一致性开销，学会做出有数据支持的架构决策。[@problem_id:3685589]", "problem": "给定一个对称多处理（SMP）场景，其中多个线程在多个处理器上运行，并访问线程本地存储（TLS）或共享全局变量。目标是使用一个基于内存层次结构和概率论的原则性模型，来分析和量化在缓存一致性下，TLS与共享全局变量之间的性能权衡。\n\n使用的基础理论：\n- 在对称多处理（SMP）中，所有处理器对内存具有平等的访问权限，并通过缓存一致性协议来维护一致性。对共享缓存行的写入会使其他缓存中的副本失效，从而产生额外的延迟。这种增加的延迟将被建模为每次失效事件的惩罚成本。\n- 线程本地存储（TLS）将每个线程的变量映射到不同的内存位置，从而消除了该变量的线程间一致性问题。TLS 可能会有为每个线程设置存储的一次性初始化成本。\n- 概率论中的期望值：对于成功概率为 $p$ 的伯努利（Bernoulli）随机变量，每次试验的预期惩罚贡献是 $p$ 乘以惩罚的成本。在 $N$ 次相同操作中进行摊销，得到的每次操作开销等于总开销除以 $N$。\n\n定义和假设：\n- 令 $P$ 表示处理器数量。所有处理器都是相同的，并并发运行线程。\n- 每个线程对一个变量执行 $N$ 次访问，该变量可以是 TLS 或共享全局变量。\n- TLS 每个线程有一次性初始化成本 $c_{\\text{init}}$（单位：时钟周期），以及稳定的每次访问成本 $c_{\\text{tls}}$（单位：时钟周期）。\n- 共享全局变量访问有稳定的每次访问基础成本 $c_{\\text{shrd}}$（单位：时钟周期）。如果一次访问是写入操作，并且缓存行的最新有效副本由另一个处理器（远程）持有，则该写入会触发失效和一致性流量，并带来额外的每次访问惩罚 $c_{\\text{coh}}$（单位：时钟周期）。\n- 令 $f_{\\text{write}} \\in [0,1]$ 为写入访问所占的比例。令 $p_{\\text{remote}} \\in [0,1]$ 为写入命中由远程处理器拥有的缓存行的概率。对于共享全局变量：\n  - 每次访问的失效概率为 $p_{\\text{inv}} = f_{\\text{write}} \\cdot p_{\\text{remote}}$。\n  - 预期的每次访问共享成本为 $E_{\\text{shared}} = c_{\\text{shrd}} + p_{\\text{inv}} \\cdot c_{\\text{coh}}$。\n- 根据设计，TLS 避免了变量的一致性失效。通过摊销初始化成本：\n  - 预期的每次访问 TLS 成本为 $E_{\\text{tls}} = c_{\\text{tls}} + \\dfrac{c_{\\text{init}}}{N}$。\n\n您的程序必须为每个测试用例计算：\n- TLS 预期的每次访问成本 $E_{\\text{tls}}$（单位：时钟周期）。\n- 共享变量预期的每次访问成本 $E_{\\text{shared}}$（单位：时钟周期）。\n- 每次访问的加速比 $S = \\dfrac{E_{\\text{shared}}}{E_{\\text{tls}}}$（无单位）。\n- 因使用 TLS 而避免的每次访问的一致性流量，量化为 $p_{\\text{inv}}$（无单位的分数）。\n\n所有表示时钟周期数的输出都必须以时钟周期为单位。最终的加速比和一致性概率必须表示为十进制小数。\n\n测试套件：\n- 用例 $1$：$P = 8$，$N = 1000000$，$f_{\\text{write}} = 0.1$，$p_{\\text{remote}} = 0.7$，$c_{\\text{init}} = 2000$，$c_{\\text{tls}} = 4$，$c_{\\text{shrd}} = 6$，$c_{\\text{coh}} = 60$。\n- 用例 $2$：$P = 1$，$N = 100000$，$f_{\\text{write}} = 0.5$，$p_{\\text{remote}} = 0$，$c_{\\text{init}} = 1000$，$c_{\\text{tls}} = 4$，$c_{\\text{shrd}} = 6$，$c_{\\text{coh}} = 60$。\n- 用例 $3$：$P = 32$，$N = 10000$，$f_{\\text{write}} = 1$，$p_{\\text{remote}} = 1$，$c_{\\text{init}} = 2000$，$c_{\\text{tls}} = 4$，$c_{\\text{shrd}} = 6$，$c_{\\text{coh}} = 200$。\n- 用例 $4$：$P = 4$，$N = 1$，$f_{\\text{write}} = 0.2$，$p_{\\text{remote}} = 0.5$，$c_{\\text{init}} = 5000$，$c_{\\text{tls}} = 4$，$c_{\\text{shrd}} = 6$，$c_{\\text{coh}} = 60$。\n- 用例 $5$：$P = 16$，$N = 1000000$，$f_{\\text{write}} = 0.01$，$p_{\\text{remote}} = 0.9$，$c_{\\text{init}} = 2000$，$c_{\\text{tls}} = 4$，$c_{\\text{shrd}} = 6$，$c_{\\text{coh}} = 60$。\n\n您的程序应生成单行输出，其中包含一个以逗号分隔的各用例结果列表。每个结果列表的形式为 $[E_{\\text{tls}},E_{\\text{shared}},S,p_{\\text{inv}}]$，每个数值都格式化为小数点后恰好六位数字，并且整个输出用方括号括起来。例如：$[[\\dots],[\\dots],\\dots]$。", "solution": "分析的关键在于计算两种不同内存访问策略的预期每次访问成本：使用共享全局变量与使用线程本地存储。\n\n首先，我们分析访问共享全局变量的成本。任何访问（读或写）的基础成本都给定为 $c_{\\text{shrd}}$。仅在特定情况下才会产生额外成本 $c_{\\text{coh}}$：该访问必须是写入操作，并且该写入必须使远程处理器持有的相应缓存行的副本失效。问题提供了写入访问的比例 $f_{\\text{write}}$，以及写入操作导致远程缓存行失效的概率 $p_{\\text{remote}}$。由于对于任何给定的访问，这两个条件是独立事件，因此产生一致性惩罚的概率是它们各自概率的乘积。这就得出了每次访问的失效概率 $p_{\\text{inv}}$：\n$$p_{\\text{inv}} = f_{\\text{write}} \\cdot p_{\\text{remote}}$$\n这是一个伯努利（Bernoulli）试验，其中“成功”是一个一致性事件，其概率为 $p_{\\text{inv}}$，成本为 $c_{\\text{coh}}$。每次访问的预期惩罚值是事件的概率乘以其成本。因此，共享变量的总预期每次访问成本 $E_{\\text{shared}}$ 是基础成本与预期惩罚成本之和：\n$$E_{\\text{shared}} = c_{\\text{shrd}} + p_{\\text{inv}} \\cdot c_{\\text{coh}}$$\n\n接下来，我们分析使用线程本地存储的成本。根据设计，TLS 为每个线程的变量分配一个唯一的内存位置，从而避免了线程间数据共享和相关的缓存一致性流量。因此，没有一致性惩罚 $c_{\\text{coh}}$。访问 TLS 变量具有稳定的每次访问成本 $c_{\\text{tls}}$。但是，每个线程初始化其本地存储时存在一次性设置成本 $c_{\\text{init}}$。为了与每次访问的共享成本进行公平比较，我们将这个一次性成本摊销到线程执行的总访问次数 $N$ 上。每次访问的摊销初始化成本为 $\\frac{c_{\\text{init}}}{N}$。因此，TLS 的总预期每次访问成本 $E_{\\text{tls}}$ 为：\n$$E_{\\text{tls}} = c_{\\text{tls}} + \\frac{c_{\\text{init}}}{N}$$\n\n最后，为了比较这两种策略，我们计算加速比 $S$，即共享变量成本与 TLS 成本的比率。加速比 $S > 1$ 表明 TLS 性能更高。\n$$S = \\frac{E_{\\text{shared}}}{E_{\\text{tls}}}$$\n\n数量 $p_{\\text{inv}}$ 本身是一个有用的度量，表示如果使用共享变量，会导致一致性流量的内存访问比例。它量化了 TLS 通过其设计所避免的一致性活动量。\n\n我们现在将这些公式应用于给定的测试用例。\n\n**用例 1：** $N = 1000000$, $f_{\\text{write}} = 0.1$, $p_{\\text{remote}} = 0.7$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.1 \\cdot 0.7 = 0.07$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{1000000} = 4 + 0.002 = 4.002$ 时钟周期\n-   $E_{\\text{shared}} = 6 + (0.07 \\cdot 60) = 6 + 4.2 = 10.2$ 时钟周期\n-   $S = \\frac{10.2}{4.002} \\approx 2.548726$\n\n**用例 2：** $N = 100000$, $f_{\\text{write}} = 0.5$, $p_{\\text{remote}} = 0.0$, $c_{\\text{init}} = 1000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.5 \\cdot 0.0 = 0.0$\n-   $E_{\\text{tls}} = 4 + \\frac{1000}{100000} = 4 + 0.01 = 4.01$ 时钟周期\n-   $E_{\\text{shared}} = 6 + (0.0 \\cdot 60) = 6.0$ 时钟周期\n-   $S = \\frac{6.0}{4.01} \\approx 1.496259$\n\n**用例 3：** $N = 10000$, $f_{\\text{write}} = 1.0$, $p_{\\text{remote}} = 1.0$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 200$。\n-   $p_{\\text{inv}} = 1.0 \\cdot 1.0 = 1.0$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{10000} = 4 + 0.2 = 4.2$ 时钟周期\n-   $E_{\\text{shared}} = 6 + (1.0 \\cdot 200) = 206.0$ 时钟周期\n-   $S = \\frac{206.0}{4.2} \\approx 49.047619$\n\n**用例 4：** $N = 1$, $f_{\\text{write}} = 0.2$, $p_{\\text{remote}} = 0.5$, $c_{\\text{init}} = 5000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.2 \\cdot 0.5 = 0.1$\n-   $E_{\\text{tls}} = 4 + \\frac{5000}{1} = 5004.0$ 时钟周期\n-   $E_{\\text{shared}} = 6 + (0.1 \\cdot 60) = 6 + 6 = 12.0$ 时钟周期\n-   $S = \\frac{12.0}{5004.0} \\approx 0.002398$\n\n**用例 5：** $N = 1000000$, $f_{\\text{write}} = 0.01$, $p_{\\text{remote}} = 0.9$, $c_{\\text{init}} = 2000$, $c_{\\text{tls}} = 4$, $c_{\\text{shrd}} = 6$, $c_{\\text{coh}} = 60$。\n-   $p_{\\text{inv}} = 0.01 \\cdot 0.9 = 0.009$\n-   $E_{\\text{tls}} = 4 + \\frac{2000}{1000000} = 4 + 0.002 = 4.002$ 时钟周期\n-   $E_{\\text{shared}} = 6 + (0.009 \\cdot 60) = 6 + 0.54 = 6.54$ 时钟周期\n-   $S = \\frac{6.54}{4.002} \\approx 1.634183$", "answer": "```c\n// This program models and compares the performance of thread-local storage (TLS)\n// versus shared global variables in a symmetric multiprocessing (SMP) environment.\n#include", "id": "3685589"}]}