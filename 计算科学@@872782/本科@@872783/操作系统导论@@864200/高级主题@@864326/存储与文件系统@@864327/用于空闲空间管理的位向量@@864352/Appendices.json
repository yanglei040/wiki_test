{"hands_on_practices": [{"introduction": "位图是管理磁盘空间的一种基本而有效的方法，但它自身也需要占用内存。这个练习将帮助你理解位图大小与它能管理的磁盘容量之间的直接关系，这是文件系统设计中的一个核心权衡。通过一个具体的计算，你将能够量化这种关系，并体会到内存资源对存储系统规模的制约。[@problem_id:3624191]", "problem": "一个操作系统使用位向量（位图）来管理块设备上的空闲空间，其中每个磁盘块都由一个位精确表示，位的值表示已分配或空闲。该位向量保存在主存中，并且被限制为最多占用 $P$ 个页帧，每个页帧的大小为 $P_{s}$ 字节。磁盘使用固定的块大小，为 $B$ 字节。假设除了每块一位的表示方法外，没有其他位图开销，并且分配的内存区域中的每一位都可用于位图。\n\n给定以下参数：$P = 64$，$P_{s} = 4\\,\\text{KiB}$，以及 $B = 4\\,\\text{KiB}$，其中 $1\\,\\text{KiB} = 1024\\,\\text{bytes}$ 且 $1\\,\\text{GiB} = 2^{30}\\,\\text{bytes}$，请确定这样一个位图可以完全覆盖的最大磁盘容量 $S$。将您的最终容量以吉比字节（GiB）表示，并四舍五入到 $4$ 位有效数字。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n**步骤 1：提取已知条件**\n问题陈述中明确提供了以下数据和约束：\n- 空闲空间管理方案是位向量（位图）。\n- 位图中的每一位精确表示一个磁盘块。\n- 位图存储在主存中。\n- 位图可以占用的最大页帧数是 $P = 64$。\n- 每个页帧的大小是 $P_s = 4\\,\\text{KiB}$。\n- 每个磁盘块的大小是 $B = 4\\,\\text{KiB}$。\n- 给出了转换因子：$1\\,\\text{KiB} = 1024\\,\\text{bytes}$。\n- 给出了转换因子：$1\\,\\text{GiB} = 2^{30}\\,\\text{bytes}$。\n- 最大磁盘容量 $S$ 的最终答案必须以吉比字节（GiB）表示，并四舍五入到 $4$ 位有效数字。\n- 假设没有开销，并且所有分配的内存都可用于位图。\n\n**步骤 2：使用提取的已知条件进行验证**\n根据验证标准对问题进行评估：\n- **科学上合理**：该问题是操作系统中的一个标准练习，涉及内存和磁盘管理的基本概念（位图、页、块）。其原理是可靠且公认的。\n- **定义明确**：所有必要的参数（$P$、$P_s$、$B$）和转换因子都已指定，从而可以计算出唯一的解。问题清晰明确。\n- **客观**：问题以精确的量化术语陈述，没有任何主观或推测性语言。\n\n该问题没有科学上不合理、不完整、矛盾或模棱两可等缺陷。\n\n**步骤 3：结论和行动**\n该问题被判定为**有效**。将推导出完整的解。\n\n求解过程首先计算位图可用的总内存，然后确定该内存提供的总位数，这又定义了可以管理的磁盘块数量，最后计算总磁盘容量。\n\n首先，我们确定为位图分配的总内存 $M_{\\text{bitmap}}$。这是页帧数 $P$ 与每个页帧大小 $P_s$ 的乘积。\n$$M_{\\text{bitmap}} = P \\times P_s$$\n给定值为 $P = 64$ 和 $P_s = 4\\,\\text{KiB}$。我们使用给定的转换关系 $1\\,\\text{KiB} = 1024\\,\\text{bytes}$ 将 $P_s$ 转换为字节。使用 2 的幂来计算会很方便。\n$$P = 64 = 2^6$$\n$$P_s = 4\\,\\text{KiB} = 4 \\times 1024\\,\\text{bytes} = 2^2 \\times 2^{10}\\,\\text{bytes} = 2^{12}\\,\\text{bytes}$$\n将这些值代入 $M_{\\text{bitmap}}$ 的方程中：\n$$M_{\\text{bitmap}} = 2^6 \\times 2^{12}\\,\\text{bytes} = 2^{18}\\,\\text{bytes}$$\n\n接下来，我们计算此内存空间中可用的总位数 $N_{\\text{bits}}$。因为 $1\\,\\text{byte} = 8\\,\\text{bits}$，即 $2^3\\,\\text{bits}$：\n$$N_{\\text{bits}} = M_{\\text{bitmap}} \\times 8\\,\\frac{\\text{bits}}{\\text{byte}}$$\n$$N_{\\text{bits}} = 2^{18}\\,\\text{bytes} \\times 2^3\\,\\frac{\\text{bits}}{\\text{byte}} = 2^{21}\\,\\text{bits}$$\n\n根据问题陈述，每个磁盘块由一个位精确表示。因此，该位图可以管理的总磁盘块数 $N_{\\text{blocks}}$ 等于总位数。\n$$N_{\\text{blocks}} = N_{\\text{bits}} = 2^{21}$$\n\n最大磁盘容量 $S$ 是总块数乘以每个块的大小 $B$。给定的块大小为 $B = 4\\,\\text{KiB}$。\n$$B = 4\\,\\text{KiB} = 4 \\times 1024\\,\\text{bytes} = 2^2 \\times 2^{10}\\,\\text{bytes} = 2^{12}\\,\\text{bytes}$$\n现在，我们可以计算以字节为单位的总容量 $S$：\n$$S = N_{\\text{blocks}} \\times B$$\n$$S = 2^{21} \\times 2^{12}\\,\\text{bytes} = 2^{33}\\,\\text{bytes}$$\n\n最后，问题要求将容量以吉比字节（GiB）表示，并四舍五入到 $4$ 位有效数字。转换因子为 $1\\,\\text{GiB} = 2^{30}\\,\\text{bytes}$。\n$$S_{\\text{GiB}} = \\frac{S}{2^{30}\\,\\text{bytes/GiB}} = \\frac{2^{33}\\,\\text{bytes}}{2^{30}\\,\\text{bytes/GiB}}$$\n$$S_{\\text{GiB}} = 2^{33-30}\\,\\text{GiB} = 2^3\\,\\text{GiB} = 8\\,\\text{GiB}$$\n\n结果恰好是 $8\\,\\text{GiB}$。为了用 $4$ 位有效数字表示，我们将其写为 $8.000$。", "answer": "$$\\boxed{8.000}$$", "id": "3624191"}, {"introduction": "位图的准确性对文件系统的完整性至关重要；一个被文件使用的数据块绝不能在位图中被标记为空闲。这个实践练习将挑战你设计一个高效的一致性检查算法，类似于 `fsck` 工具的功能，以在给定的时间和空间资源限制下检测出关键的错误。这能让你深入理解在实际操作系统中，如何利用数据结构来确保数据的安全性和可靠性。[@problem_id:3624195]", "problem": "一个存储卷使用空闲空间位向量（位图）来管理数据块的分配。假设有 $M$ 个数据块，索引从 $0$ 到 $M-1$。空闲空间位图 $B$ 是一个长度为 $M$ 的位数组，其中当且仅当块 $b$ 当前已被分配时，$B[b] = 1$。inode 表为每个文件列出了一个有限的数据块索引序列。设 $N$ 表示所有 inode 中块指针的总数（如果因错误存在重复，也计算在内）。根据设计，一个正确的文件系统必须满足以下两个不变式：\n- 对于出现在任何 inode 块列表中的每个块索引 $b$，必须有 $B[b] = 1$。\n- 没有数据块被一个以上的文件引用（无重复分配），即在所有 inode 中，每个块索引 $b$ 最多出现一次。\n\n要求您选择一种检查策略，该策略在给定 inode 表和空闲空间位图 $B$ 的只读快照的情况下，能在标准单位成本字 RAM 模型（机器字大小为 $W$ 位）下，在 $O(N)$ 时间内检测出对上述不变式的违反，并且只使用少量额外内存。在本问题中，“少量额外内存”定义为最多 $c \\cdot M$ 位（其中 $c$ 是一个与 $M$ 和 $N$ 无关的小常数），外加 $O(1)$ 个机器字。检查程序不得修改任何磁盘上的元数据。它可以在 $O\\!\\left(\\frac{M}{W}\\right)$ 时间内初始化其自身的辅助结构，并且如果需要，最多可以对 $B$ 进行一次线性扫描。\n\n下面哪个选项满足这些要求，并能在指定的资源限制内正确检测“inode 引用了 $B[b] = 0$ 的块”和“重复分配”这两种情况？\n\nA. 对所有 inode 块指针进行一遍扫描。维护一个长度为 $M$ 位的辅助“已见”位向量 $S$，初始全为零。对于每个遇到的块索引 $b$：读取 $B[b]$；如果 $B[b] = 0$，报告错误；否则如果 $S[b] = 1$，报告重复分配；否则设置 $S[b] \\leftarrow 1$。可选地，在扫描结束后，线性扫描 $B$ 以报告已分配但未被引用的块。总时间为 $O\\!\\left(N + \\frac{M}{W}\\right)$，额外内存为 $M$ 位。\n\nB. 对所有 inode 块指针进行一遍扫描，将每个看到的块索引 $b$ 插入到一个以 $b$ 为键的动态哈希集合中；如果插入时发现 $b$ 已存在，报告重复分配。对于每个 $b$，读取 $B[b]$，如果 $B[b] = 0$，报告错误。总期望时间为 $O(N)$，额外内存与被引用的不同块的数量成正比。\n\nC. 将所有 inode 引用的块索引提取到一个长度为 $N$ 的数组中，然后按块索引对该数组执行外部归并排序。在随后对已排序数组的扫描中，报告任何重复项为重复分配。独立地，对数组中的每个索引，验证 $B[b] = 1$。总时间为 $O\\!\\left(N \\log N\\right)$ 外加线性的额外磁盘流量，使用 $O(1)$ 的随机存取存储器 (RAM)。\n\nD. 对所有 inode 块指针进行一遍扫描。对于每个块索引 $b$，在磁盘上的空闲空间位图中翻转位 $B[b] \\leftarrow 1 - B[b]$。如果一个翻转后的位变为 $0$，将其解释为第二次引用并报告重复分配；如果它最初为 $0$，翻转为 $1$ 会在下一次遇到时揭示一个“inode 引用空闲块”的错误。最后，将所有接触过的位翻转回来以恢复 $B$。\n\nE. 对所有 inode 块指针进行一遍扫描，同时将每个 $b$ 插入到一个配置为恒定假阳性率的布隆过滤器中。如果插入操作表明该元素已存在，则报告重复分配。对于每个 $b$，检查布隆过滤器中 $b$ 在集合 $\\{ i \\mid B[i] = 1 \\}$ 中的近似隶属关系，而不直接查询 $B$，如果未找到则报告错误。总时间为 $O(N)$，使用亚线性内存，且初始化后无需读取 $B$。\n\n选择满足所述正确性和资源约束的单个最佳选项。", "solution": "用户需要选择一个满足所述正确性和资源约束的最佳选项。\n\n### 问题验证\n\n**步骤 1：提取给定条件**\n- 一个存储卷使用空闲空间位向量（位图）。\n- 有 $M$ 个数据块，索引从 $0$ 到 $M-1$。\n- 空闲空间位图 $B$ 是一个长度为 $M$ 的位数组。\n- 当且仅当块 $b$ 当前已被分配时，$B[b] = 1$。\n- inode 表为每个文件列出了一个有限的数据块索引序列。\n- $N$ 是所有 inode 中块指针的总数。\n- 不变式 1：对于出现在任何 inode 块列表中的每个块索引 $b$，必须有 $B[b] = 1$。\n- 不变式 2：没有数据块被一个以上的文件引用（无重复分配）。\n- 任务是选择一个能检测出两种不变式违规的检查策略。\n- 检查程序被给予 inode 表和位图 $B$ 的一个只读快照。\n- 时间复杂度必须是 $O(N)$。\n- 计算模型是标准单位成本字 RAM 模型，机器字大小为 $W$ 位。\n- 额外内存最多为 $c \\cdot M$ 位（$c$ 是一个小常数），外加 $O(1)$ 个机器字。\n- 检查程序不得修改任何磁盘上的元数据。\n- 辅助结构可以在 $O\\!\\left(\\frac{M}{W}\\right)$ 时间内初始化。\n- 如果需要，最多允许对 $B$ 进行一次线性扫描。\n\n**步骤 2：使用提取的条件进行验证**\n问题陈述是有效的。\n- **科学依据：** 该问题描述了文件系统一致性检查中的一个基本任务（类似于类 Unix 系统中的 `fsck`）。inode、块指针和空闲空间位图的概念是许多文件系统设计的标准组件。所描述的不变式对文件系统的完整性至关重要。\n- **定义明确：** 目标清晰定义（检测两种特定类型的错误），并且对时间和空间复杂度的约束（$O(N)$ 时间，$c \\cdot M$ 位空间）是精确且无歧义的。计算模型已指定。可以根据这些约束唯一地确定一个解决方案。\n- **客观性：** 语言是技术性的和精确的，没有主观或含糊的术语。\n- **完整且一致的设置：** 提供了所有必要的信息。$M$、$N$、$B$、不变式和资源约束的定义是自洽和一致的。允许 $O\\!\\left(\\frac{M}{W}\\right)$ 的初始化阶段是与对大小为 $M$ 的位向量操作相一致的关键细节。\n\n**步骤 3：结论与行动**\n问题是有效的。现在进行解决方案推导和选项分析。\n\n### 解决方案推导\n\n目标是设计一个算法，为一组 $N$ 个块指针验证两个不变式，其中块的索引范围是从 $0$ 到 $M-1$。\n1.  **inode 引用空闲块**：对于来自 inode 的每个块指针 $b$，我们必须验证 $B[b] = 1$。\n2.  **重复分配**：我们必须验证每个块指针 $b$ 在所有 inode 列表中最多出现一次。\n\n该算法必须在 $O(N)$ 的时间复杂度和最多 $c \\cdot M$ 位外加常数个字的额外内存下运行。\n\n让我们分析一下这些要求。我们必须处理 $N$ 个块指针。对所有指针进行一次线性扫描是实现 $O(N)$ 运行时间的自然方法。在此过程中，对于每个指针 $b$，我们需要执行两个检查。\n\n**检查不变式 1 ($B[b]=1$):**\n对于每个指针 $b$，我们需要从空闲空间位图访问位 $B[b]$。由于 $B$ 是一个位数组，这是一个在字 RAM 模型上耗时 $O(1)$ 的随机访问操作。对所有 $N$ 个指针重复此操作总共需要 $O(N)$ 时间。这符合时间预算。\n\n**检查不变式 2 (无重复分配):**\n要检测重复分配，我们需要记住在扫描 inode 指针的过程中已经看到了哪些块索引。让我们将先前见过的块索引集合称为 $S_{seen}$。对于每个新指针 $b$，我们必须检查 $b \\in S_{seen}$ 是否成立。如果成立，我们发现了一个重复分配。如果不成立，我们必须将其添加到集合中，即 $S_{seen} \\leftarrow S_{seen} \\cup \\{b\\}$，然后继续。\n\n为 $S_{seen}$ 选择的数据结构对于满足复杂度约束至关重要。\n-   该结构必须支持插入和成员资格测试。\n-   为了达到 $O(N)$ 的总时间，这 $N$ 个操作中的每一个都必须耗时 $O(1)$（摊销或最坏情况）。\n-   该结构使用的空间不得超过 $c \\cdot M$ 位。\n\n一个**位向量**（或位图）是完成此任务的理想数据结构。我们可以使用一个辅助位向量，称之为 $S$，长度为 $M$，初始化为全零。该向量的索引对应于数据块索引 $0, \\dots, M-1$。\n-   **初始化：** 将 $S$ 的所有 $M$ 位置为 $0$。这需要 $O\\!\\left(\\frac{M}{W}\\right)$ 时间，这是问题陈述明确允许的。\n-   **成员资格测试：** 要检查一个块 $b$ 是否已被看到，我们读取位 $S[b]$。这是一个 $O(1)$ 操作。\n-   **插入：** 要标记块 $b$ 为已见，我们设置位 $S[b] \\leftarrow 1$。这也是一个 $O(1)$ 操作。\n-   **空间：** 向量 $S$ 需要恰好 $M$ 位的存储空间。这满足了“最多 $c \\cdot M$ 位，其中 $c$ 是一个小常数”的内存约束（取 $c=1$）。\n\n综合起来，完整的算法是：\n1.  初始化一个大小为 $M$ 的辅助位向量 $S$ 为全零。时间：$O\\!\\left(\\frac{M}{W}\\right)$。空间：$M$ 位。\n2.  遍历 inode 表提供的 $N$ 个块指针。对于每个块索引 $b$：\n    a. 读取 $B[b]$。如果 $B[b] = 0$，报告违反不变式 1。\n    b. 读取 $S[b]$。如果 $S[b] = 1$，报告违反不变式 2（重复分配）。\n    c. 设置 $S[b] \\leftarrow 1$。\n3.  主循环（步骤 2）包含 $N$ 次迭代，每次耗时 $O(1)$。因此，此步骤的时间为 $O(N)$。\n4.  总时间复杂度为 $O\\!\\left(N + \\frac{M}{W}\\right)$。由于问题规定检查时间应为 $O(N)$ 并允许 $O\\!\\left(\\frac{M}{W}\\right)$ 的初始化，这是一个有效的解决方案。总额外内存是用于 $S$ 的 $M$ 位加上用于计数器和指针的 $O(1)$ 个字，这满足了内存约束。\n\n这个推导出的过程是健全的，并满足所有要求。我们现在根据这一理解来评估给定的选项。\n\n### 逐项分析选项\n\n**A. 对所有 inode 块指针进行一遍扫描。维护一个长度为 $M$ 位的辅助“已见”位向量 $S$，初始全为零。对于每个遇到的块索引 $b$：读取 $B[b]$；如果 $B[b] = 0$，报告错误；否则如果 $S[b] = 1$，报告重复分配；否则设置 $S[b] \\leftarrow 1$。可选地，在扫描结束后，线性扫描 $B$ 以报告已分配但未被引用的块。总时间为 $O\\!\\left(N + \\frac{M}{W}\\right)$，额外内存为 $M$ 位。**\n- **分析：** 这个选项完美地描述了上面推导出的算法。\n    - **正确性：** 逻辑是健全的。它通过查询 $B[b]$ 来检查指向空闲块的 inode 指针。它通过使用辅助的“已见”位图 $S$ 来检查重复分配。\n    - **时间复杂度：** 初始化 $M$ 位向量 $S$ 需要 $O\\!\\left(\\frac{M}{W}\\right)$ 时间。对 $N$ 个指针的单次扫描需要 $O(N)$ 时间，因为循环内的每个操作都是 $O(1)$。总时间为 $O\\!\\left(N + \\frac{M}{W}\\right)$，满足问题的要求。\n    - **空间复杂度：** 辅助向量 $S$ 使用 $M$ 位。这满足了“最多 $c \\cdot M$ 位”的约束（取 $c=1$）。\n    - **其他约束：** 检查程序对于磁盘上的元数据是只读的（只读取 $B$）。\n- **结论：** 正确。\n\n**B. 对所有 inode 块指针进行一遍扫描，将每个看到的块索引 $b$ 插入到一个以 $b$ 为键的动态哈希集合中；如果插入时发现 $b$ 已存在，报告重复分配。对于每个 $b$，读取 $B[b]$，如果 $B[b] = 0$，报告错误。总期望时间为 $O(N)$，额外内存与被引用的不同块的数量成正比。**\n- **分析：**\n    - **正确性：** 查找两种错误的逻辑是正确的。\n    - **时间复杂度：** 哈希集合为每次操作提供*期望* $O(1)$ 的时间。因此总时间是*期望* $O(N)$。然而，最坏情况下的时间可能要高得多，这对于系统验证工具来说可能是不可接受的。更重要的是，它不像位向量方法那样提供严格的最坏情况 $O(N)$ 保证。\n    - **空间复杂度：** 哈希集合存储块索引本身。设 $U$ 是被引用的唯一块索引的数量，其中 $U \\le \\min(N, M)$。所需的空间是 $O(U)$ 个字。一个字是 $W$ 位。所以空间是 $O(U \\cdot W)$ 位。问题要求空间最多为 $c \\cdot M$ 位。$U \\cdot W$ 很可能远大于 $M$。例如，考虑一个有大磁盘的系统，$M = 2^{40}$，并且有 $U = 2^{30}$ 个唯一的文件块。对于 $W=64$ 位的字大小，哈希集合将需要大约 $O(2^{30} \\cdot 64) = O(2^{36})$ 位的内存。约束是 $c \\cdot M = c \\cdot 2^{40}$ 位。在这种情况下，它可能满足。但考虑 $M=2^{32}$，$U=2^{30}$，$W=64$。哈希集合需要 $O(2^{36})$ 位，而限制是 $c \\cdot 2^{32}$ 位，对于小的 $c$ 来说这是一个违规。由于 $N$、$M$ 和 $W$ 之间的关系不固定，我们无法保证空间约束得到满足。\n- **结论：** 不正确。在一般情况下，空间复杂度不满足指定的界限。\n\n**C. 将所有 inode 引用的块索引提取到一个长度为 $N$ 的数组中，然后按块索引对该数组执行外部归并排序。在随后对已排序数组的扫描中，报告任何重复项为重复分配。独立地，对数组中的每个索引，验证 $B[b] = 1$。总时间为 $O\\left(N \\log N\\right)$ 外加线性的额外磁盘流量，使用 $O(1)$ 的随机存取存储器 (RAM)。**\n- **分析：**\n    - **正确性：** 对块索引进行排序可以方便地在随后的线性扫描中检测重复项（它们将是相邻的）。检查每个 $B[b]=1$ 也可以做到。逻辑是正确的。\n    - **时间复杂度：** 主要步骤是对 $N$ 个块索引进行排序。一个高效的基于比较的排序需要 $O(N \\log N)$ 时间。问题明确要求 $O(N)$ 时间。此选项未能满足时间复杂度约束。\n- **结论：** 不正确。\n\n**D. 对所有 inode 块指针进行一遍扫描。对于每个块索引 $b$，在磁盘上的空闲空间位图中翻转位 $B[b] \\leftarrow 1 - B[b]$。如果一个翻转后的位变为 $0$，将其解释为第二次引用并报告重复分配；如果它最初为 $0$，翻转为 $1$ 会在下一次遇到时揭示一个“inode 引用空闲块”的错误。最后，将所有接触过的位翻转回来以恢复 $B$。**\n- **分析：**\n    - **正确性：** 逻辑有缺陷。如果一个 inode 引用了一个空闲块（初始状态 $B[b]=0$），算法会将其翻转为 $1$。描述称这个错误在“下一次遇到时”才会被揭示，但如果该块只被引用一次，这种情况可能永远不会发生。在发现 $B[b]=0$ 时应立即报告错误。此外，对状态变化的解释是反的：将一个位从 $1$ 翻转到 $0$ 发生在*第一次*遇到有效块时，而不是第二次。\n    - **违反约束：** 问题规定，“检查程序不得修改任何磁盘上的元数据。”此选项建议直接修改磁盘上的位图 $B$。尽管它建议稍后恢复这些位，但这是对磁盘上状态的修改，这是明确禁止的。这是一个严重的违规。\n- **结论：** 不正确。\n\n**E. 对所有 inode 块指针进行一遍扫描，同时将每个 $b$ 插入到一个配置为恒定假阳性率的布隆过滤器中。如果插入操作表明该元素已存在，则报告重复分配。对于每个 $b$，检查布隆过滤器中 $b$ 在集合 $\\{ i \\mid B[i] = 1 \\}$ 中的近似隶属关系，而不直接查询 $B$，如果未找到则报告错误。总时间为 $O(N)$，使用亚线性内存，且初始化后无需读取 $B$。**\n- **分析：**\n    - **正确性：** 布隆过滤器是一种概率性数据结构。它可能产生假阳性。\n        - 对于重复分配：如果插入 $b$ 表明它“已存在”，这可能是一个真阳性（重复分配）或一个假阳性（哈希冲突）。在此基础上报告重复分配将导致错误地将有效的文件系统标记为损坏。\n        - 对于检查空闲块：该选项建议检查表示已分配块的布隆过滤器中的成员资格。查询返回“不存在”是确定的（没有假阴性），可以正确识别指向空闲块的指针。然而，查询返回“存在”可能是假阳性，这会导致检查错过一个错误，即 inode 指向一个空闲块，而该块的索引恰好在布隆过滤器中错误地测试为存在。\n    - 文件系统验证要求确定性的正确性。可能产生假阳性（对于重复分配）或导致假阴性（错过错误，当假阳性掩盖了它时发生）的概率性数据结构不适合此任务。\n- **结论：** 不正确。\n\n### 总结\n选项 A 提供了一个正确且确定性的算法，满足了问题的所有时间、空间和操作约束。其他选项则存在缺陷，原因包括违反复杂度限制（B, C）、操作约束（D），或正确性的基本要求（D, E）。", "answer": "$$\\boxed{A}$$", "id": "3624195"}, {"introduction": "在一个大型磁盘上，从头开始线性扫描位图来查找一个空闲块（值为 $0$ 的位）可能会非常耗时，这会严重影响文件创建和写入的性能。为了实现高性能的分配，我们需要一种更快的查找方法。这个练习将介绍一种源自简洁数据结构的强大技术：通过为位图配备一个辅助的 $\\mathrm{rank}$ 结构，我们可以在对数时间内定位到第 $k$ 个空闲块，这相对于线性扫描是巨大的性能飞跃。[@problem_id:3624178]", "problem": "一个文件系统使用长度为 $N$ 的位向量来管理空闲空间，其中位 $1$ 表示已分配的块，位 $0$ 表示空闲块。令 $N = 2^{32}$。定义函数 $\\mathrm{rank}_{1}(i)$ 为前缀 $[1..i]$ 中 $1$ 的数量，函数 $\\mathrm{select}_{0}(k)$ 为位向量中第 $k$ 个 $0$ 的位置。你需要仅使用一个预计算的 $\\mathrm{rank}_{1}(\\cdot)$ 结构和 $O(1)$ 时间复杂度的 $\\mathrm{rank}_{1}$ 查询来支持对任意有效 $k$ 的 $\\mathrm{select}_{0}(k)$ 操作，并且不能修改原始位向量。\n\n假设以下用于 $\\mathrm{rank}_{1}$ 的预计算结构是可用的：\n\n- 位向量被划分为大小为 $s$ 位的超块和大小为 $b$ 位的块，其中 $s = (\\log_{2} N)^{2}$ 且 $b = \\frac{1}{2}\\log_{2} N$。对于 $N = 2^{32}$，这得到 $s = 1024$ 和 $b = 16$。\n- 对于每个超块边界，使用恰好 $\\log_{2} N$ 位来存储截至该超块起始位置的累计 $1$ 的数量（每个超块条目）。\n- 对于超块内的每个块边界，使用恰好 $\\log_{2} s$ 位来存储从该超块起始位置到该块起始位置的 $1$ 的数量（每个块条目）。\n- 在 $\\mathrm{rank}_{1}$ 查询期间，为了计算最后一个部分块（长度最多为 $b$ 位）中 $1$ 的数量，使用一个查找表来存储每个 $b$ 位模式的置位位数（popcount）；每个置位位数使用恰好 $\\lceil \\log_{2}(b+1)\\rceil$ 位存储。该表是全局的，并为所有查询共享。\n\n任务：\n\n1. 从 $\\mathrm{rank}_{1}$ 和 $\\mathrm{select}_{0}$ 的核心定义出发，仅利用前缀计数的单调性，推导出一个正确的算法来计算 $\\mathrm{select}_{0}(k)$。该算法每次调用 $\\mathrm{rank}_{1}(\\cdot)$ 时将其视为一个 $O(1)$ 时间的黑箱。当在位置 $1$到 $N$ 上执行标准二分搜索时，得出单次 $\\mathrm{select}_{0}(k)$ 查询在最坏情况下调用黑箱 $\\mathrm{rank}_{1}$ 的次数。\n\n2. 计算上述预计算结构在 $N=2^{32}$、$s=1024$ 和 $b=16$ 的情况下所需辅助位的确切数量：\n   - 超块目录，\n   - 块目录，\n   - 所有 $b$ 位模式的置位位数查找表。\n\n用位（bit）表示总辅助空间。\n\n答案规格：\n\n- 辅助空间用位（bit）表示，为一个精确整数。\n- 查询时间表示为每次 $\\mathrm{select}_{0}(k)$ 查询在最坏情况下调用 $\\mathrm{rank}_{1}$ 的确切次数，为一个精确整数。\n- 以一个包含两个条目 $\\bigl[\\text{辅助位数} \\ \\ \\text{rank调用次数}\\bigr]$ 的单行矩阵形式提供你的最终答案。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上植根于计算机科学中的简洁数据结构领域，数学上一致、适定，并包含推导出唯一解所需的所有必要信息。\n\n该问题分为两部分：第一，推导 $\\mathrm{select}_{0}(k)$ 的算法并确定其在调用黑箱 $\\mathrm{rank}_{1}$ 函数方面的复杂度；第二，计算所描述的辅助数据结构的总大小。\n\n### 第1部分：$\\mathrm{select}_{0}(k)$ 算法和查询复杂度\n\n函数 $\\mathrm{rank}_{1}(i)$ 给出长度为 $i$ 的位向量前缀（即从位置 $1$ 到 $i$）中 $1$ 的数量。该前缀的总位数为 $i$。由于每一位不是 $0$ 就是 $1$，因此该前缀中 $0$ 的数量（我们可以表示为 $\\mathrm{rank}_{0}(i)$）由下式给出：\n$$ \\mathrm{rank}_{0}(i) = i - \\mathrm{rank}_{1}(i) $$\n函数 $\\mathrm{select}_{0}(k)$ 定义为第 $k$ 个 $0$ 的位置。这意味着我们正在寻找最小的整数位置 $p \\in [1, N]$，使得截至该位置的 $0$ 的数量恰好为 $k$。形式上，我们寻求满足以下条件的最小 $p$：\n$$ \\mathrm{rank}_{0}(p) = p - \\mathrm{rank}_{1}(p) = k $$\n我们定义函数 $f(p) = p - \\mathrm{rank}_{1}(p)$。为了确定该函数是否适合二分搜索，我们必须检查其单调性。考虑差值 $f(p+1) - f(p)$：\n$$ f(p+1) - f(p) = \\left( (p+1) - \\mathrm{rank}_{1}(p+1) \\right) - \\left( p - \\mathrm{rank}_{1}(p) \\right) $$\n$$ f(p+1) - f(p) = 1 - \\left( \\mathrm{rank}_{1}(p+1) - \\mathrm{rank}_{1}(p) \\right) $$\n项 $\\mathrm{rank}_{1}(p+1) - \\mathrm{rank}_{1}(p)$ 表示位置 $p+1$ 处的位的值。\n- 如果位置 $p+1$ 处的位是 $0$，则 $\\mathrm{rank}_{1}(p+1) = \\mathrm{rank}_{1}(p)$，且 $f(p+1) - f(p) = 1 - 0 = 1$。\n- 如果位置 $p+1$ 处的位是 $1$，则 $\\mathrm{rank}_{1}(p+1) = \\mathrm{rank}_{1}(p) + 1$，且 $f(p+1) - f(p) = 1 - 1 = 0$。\n在这两种情况下，都有 $f(p+1) - f(p) \\ge 0$，这证明了 $f(p)$ 是一个单调不减函数。此性质允许我们使用二分搜索来找到所需的位置 $p$。\n\n搜索在所有可能位置的整个范围（从 $1$ 到 $N$）上进行。目标是找到最小的 $p$ 使得 $f(p) \\ge k$。由于 $f(p)$ 每一步最多增加 $1$，因此使得 $f(p) \\ge k$ 的最小 $p$ 将是 $f(p)=k$ 的确切位置，从而确定第 $k$ 个 $0$。\n\n在大小为 $N$ 的搜索空间上进行标准二分搜索，需要进行 $\\lceil \\log_{2} N \\rceil$ 次迭代。在二分搜索的每次迭代中，我们探查一个中间位置 `mid` 并计算 $f(\\text{mid}) = \\text{mid} - \\mathrm{rank}_{1}(\\text{mid})$，这需要恰好一次对 $\\mathrm{rank}_{1}$ 函数的调用。由于问题陈述 $\\mathrm{rank}_{1}$ 是一个黑箱操作，所以 $\\mathrm{rank}_{1}$ 的总调用次数等于二分搜索的迭代次数。\n\n给定 $N = 2^{32}$，最坏情况下的 $\\mathrm{rank}_{1}$ 调用次数为：\n$$ \\text{调用次数} = \\lceil \\log_{2} N \\rceil = \\lceil \\log_{2} (2^{32}) \\rceil = \\lceil 32 \\rceil = 32 $$\n\n### 第2部分：辅助空间计算\n\n我们计算在 $N=2^{32}$，$s=1024$ 和 $b=16$ 的条件下，预计算结构的三个组成部分各自所需的空间。\n\n**1. 超块目录**\n该目录为每个超块边界存储一个条目。\n- 向量中的总位数：$N = 2^{32}$。\n- 超块大小：$s = 1024 = 2^{10}$ 位。\n- 超块数量：$\\frac{N}{s} = \\frac{2^{32}}{2^{10}} = 2^{22}$。\n- 每个条目的大小（用于存储截至 $N$ 的累计计数）：$\\log_{2} N = \\log_{2}(2^{32}) = 32$ 位。\n- 超块目录的总空间：\n$$ S_{sb} = (\\text{超块数量}) \\times (\\text{每个条目的大小}) = 2^{22} \\times 32 = 2^{22} \\times 2^5 = 2^{27} \\text{ 位} $$\n\n**2. 块目录**\n该目录存储其父超块内每个块的相对计数。\n- 向量中的总块数：$\\frac{N}{b} = \\frac{2^{32}}{16} = \\frac{2^{32}}{2^{4}} = 2^{28}$。\n- 每个条目的大小（用于存储大小为 $s$ 的超块内 $1$ 的数量）：$\\log_{2} s = \\log_{2}(1024) = 10$ 位。最大计数值为 $s$，但该结构是计数到块的起始位置，因此最大的计数值是针对最后一个块的，需要存储一个大约为 $s-b$ 的数字。问题指定存储大小为 $\\log_2 s$。\n- 块目录的总空间：\n$$ S_{b} = (\\text{总块数}) \\times (\\text{每个条目的大小}) = 2^{28} \\times 10 \\text{ 位} $$\n\n**3. 置位位数（Popcount）查找表**\n该表为每个可能的 $b$ 位模式存储 $1$ 的数量（置位位数）。\n- 块大小：$b = 16$ 位。\n- 不同 $b$ 位模式的数量：$2^b = 2^{16}$。\n- 一个 $b$ 位模式的置位位数范围可以从 $0$ 到 $b$。我们需要存储此范围内的整数值。每个条目所需的位数是 $\\lceil \\log_{2}(b+1) \\rceil$。\n- 对于 $b=16$，每个条目的大小为 $\\lceil \\log_{2}(16+1) \\rceil = \\lceil \\log_{2}(17) \\rceil$。因为 $2^4 = 16$ 且 $2^5 = 32$，我们有 $4  \\log_{2}(17)  5$，所以 $\\lceil \\log_{2}(17) \\rceil = 5$ 位。\n- 置位位数查找表的总空间：\n$$ S_{lut} = (\\text{模式数量}) \\times (\\text{每个条目的大小}) = 2^{16} \\times 5 \\text{ 位} $$\n\n**总辅助空间**\n总辅助空间是所有三个组成部分的空间之和。\n$$ S_{\\text{总计}} = S_{sb} + S_{b} + S_{lut} = 2^{27} + (10 \\times 2^{28}) + (5 \\times 2^{16}) \\text{ 位} $$\n现在，我们计算确切的整数值：\n- $S_{sb} = 2^{27} = 134,217,728$ 位。\n- $S_{b} = 10 \\times 2^{28} = 10 \\times 268,435,456 = 2,684,354,560$ 位。\n- $S_{lut} = 5 \\times 2^{16} = 5 \\times 65,536 = 327,680$ 位。\n总空间：\n$$ S_{\\text{总计}} = 134,217,728 + 2,684,354,560 + 327,680 = 2,818,899,968 \\text{ 位} $$\n\n所需的两个值是总辅助空间（以位为单位）和每次 $\\mathrm{select}_{0}(k)$ 查询在最坏情况下调用 $\\mathrm{rank}_{1}$ 的次数。\n- 辅助位数：$2,818,899,968$。\n- Rank 调用次数：$32$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2818899968  32\n\\end{pmatrix}\n}\n$$", "id": "3624178"}]}