{"hands_on_practices": [{"introduction": "除了性能，存储空间的有效利用也是文件系统设计的另一个关键维度。操作系统以固定大小的块来管理磁盘空间，这不可避免地会在存储目录等可变大小的数据时产生“内部碎片”，造成空间浪费。本练习将让你亲手计算和比较根目录与用户目录中内部碎片的大小，从而更深刻地理解影响空间效率的因素。通过这个实践，你将学会如何精确量化存储开销，这是优化资源利用率的重要一步 [@problem_id:3689414]。", "problem": "考虑一个操作系统（OS）中的 $2$ 级目录系统，其中根目录正好包含 $U$ 个用户条目，每个用户目录正好包含 $F$ 个文件条目。目录内容以大小为 $B$ 字节的固定大小块存储在磁盘上，目录条目由一个可变长度的名称加上固定的元数据组成。可变长度名称的平均长度为 $L$ 字节，每个条目的固定元数据占用 $s$ 字节，因此为了估算，平均条目大小可以建模为 $L+s$ 字节。所有目录条目都连续存放，除了每个目录最后一个分配块中未使用的尾随字节外，没有其他间隙。每个目录占用整数个完整的块。\n\n使用基本定义，即基于块的存储对象中的内部碎片等于总分配容量与实际占用内容大小之间的差值，并且存储大小为 $S$ 的内容所需的分配块数为 $\\lceil S/B \\rceil$，请从第一性原理推导出一个闭式解析表达式，用于表示根目录的内部碎片与单个用户目录的内部碎片之间的差值，该表达式仅用 $B$、$L$、$s$、$U$ 和 $F$ 表示。请以最简闭式形式提供最终表达式。不需要进行数值代入，也不需要进行四舍五入。", "solution": "首先将根据所需标准验证问题陈述。\n\n### 第1步：提取已知条件\n- 系统类型：一个 $2$ 级目录系统。\n- 根目录内容：正好 $U$ 个用户条目。\n- 用户目录内容：每个用户目录正好 $F$ 个文件条目。\n- 存储块大小：$B$ 字节。\n- 平均目录条目名称长度：$L$ 字节。\n- 每个条目的固定元数据大小：$s$ 字节。\n- 目录条目的平均总大小（模型）：$L+s$ 字节。\n- 分配规则：每个目录占用整数个完整的块。\n- 内部碎片的定义：总分配容量减去实际占用的内容大小。\n- 存储大小为 $S$ 的内容所需的块数公式：$\\lceil S/B \\rceil$。\n- 目标：推导根目录内部碎片与单个用户目录内部碎片之间差值的闭式解析表达式。\n- 表达式变量：$B$、$L$、$s$、$U$ 和 $F$。\n\n### 第2步：使用提取的已知条件进行验证\n对问题的有效性进行评估。\n- **科学依据**：该问题充分基于操作系统设计的基本原理，特别是文件系统实现。多级目录、基于块的存储和内部碎片等概念是计算机科学中的标准课题。该模型虽然使用平均条目大小进行了简化，但对于此类分析而言，是一种常见且有效的方法。\n- **适定性**：该问题是适定的。它提供了所有必要的变量（$U$、$F$、$B$、$L$、$s$）以及用于计算空间需求（连续存放）和碎片的明确定义。目标陈述清晰，并且可以从给定信息中推导出唯一的解析解。\n- **客观性**：问题以客观的技术语言陈述，没有歧义或主观论断。\n\n该问题没有表现出验证清单中列出的任何缺陷。它是科学合理的、可形式化的、完整的且结构良好。\n\n### 第3步：结论与行动\n问题是有效的。将从第一性原理推导解决方案。\n\n### 解决方案的推导\n\n令 $\\text{Frag}(S, B)$ 表示大小为 $S$、存储在大小为 $B$ 的块中的数据对象的内部碎片。问题定义分配的块数为 $N = \\lceil S/B \\rceil$。因此，总分配容量为 $N \\times B$。内部碎片是分配容量与实际内容大小之间的差值。\n\n$$ \\text{Frag}(S, B) = \\left( \\lceil \\frac{S}{B} \\rceil \\times B \\right) - S $$\n\n我们将把这个基本公式应用于根目录和单个用户目录。\n\n**1. 根目录的内部碎片**\n\n根目录包含 $U$ 个用户条目。每个条目的平均大小给定为 $L+s$ 字节。由于条目是连续存放的，根目录中内容的总大小 $S_{\\text{root}}$ 是条目数与每个条目平均大小的乘积。\n\n$$ S_{\\text{root}} = U(L+s) $$\n\n使用碎片的通用公式，根目录的内部碎片 $\\text{Frag}_{\\text{root}}$ 为：\n\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{S_{\\text{root}}}{B} \\rceil \\times B \\right) - S_{\\text{root}} $$\n$$ \\text{Frag}_{\\text{root}} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil \\times B \\right) - U(L+s) $$\n\n**2. 单个用户目录的内部碎片**\n\n类似地，每个用户目录包含 $F$ 个文件条目。每个条目的平均大小相同，为 $L+s$ 字节。单个用户目录中内容的总大小 $S_{\\text{user}}$ 是：\n\n$$ S_{\\text{user}} = F(L+s) $$\n\n单个用户目录的内部碎片 $\\text{Frag}_{\\text{user}}$ 是：\n\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{S_{\\text{user}}}{B} \\rceil \\times B \\right) - S_{\\text{user}} $$\n$$ \\text{Frag}_{\\text{user}} = \\left( \\lceil \\frac{F(L+s)}{B} \\rceil \\times B \\right) - F(L+s) $$\n\n**3. 内部碎片的差值**\n\n问题要求推导根目录内部碎片与单个用户目录内部碎片之间的差值，我们将其表示为 $\\Delta \\text{Frag}$。\n\n$$ \\Delta \\text{Frag} = \\text{Frag}_{\\text{root}} - \\text{Frag}_{\\text{user}} $$\n\n代入上面推导出的表达式：\n\n$$ \\Delta \\text{Frag} = \\left[ \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B \\right) - U(L+s) \\right] - \\left[ \\left( \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - F(L+s) \\right] $$\n\n为了简化，我们将具有公因子 $B$ 的项和具有公因子 $(L+s)$ 的项组合在一起：\n\n$$ \\Delta \\text{Frag} = \\left( \\lceil \\frac{U(L+s)}{B} \\rceil B - \\lceil \\frac{F(L+s)}{B} \\rceil B \\right) - \\left( U(L+s) - F(L+s) \\right) $$\n\n提取公因子 $B$ 和 $(L+s)$:\n\n$$ \\Delta \\text{Frag} = B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U - F)(L+s) $$\n\n该表达式是内部碎片差值的闭式解析解，完全用给定的变量 $B$、$L$、$s$、$U$ 和 $F$ 表示。在不对变量施加额外约束的情况下，无法进一步简化。这是最简闭式形式。", "answer": "$$\n\\boxed{B \\left( \\lceil \\frac{U(L+s)}{B} \\rceil - \\lceil \\frac{F(L+s)}{B} \\rceil \\right) - (U-F)(L+s)}\n$$", "id": "3689414"}, {"introduction": "一个高性能、高空间利用率的系统如果存在安全漏洞，其价值将大打折扣。并发执行是现代操作系统的常态，但也带来了诸如“检查时-使用时”（Time Of Check to Time Of Use, TOCTOU）的竞态条件漏洞。本练习将剖析一个在文件创建过程中典型的TOCTOU漏洞，并要求你设计一套安全的原子操作来根除此隐患。这个实践将让你认识到原子性在系统调用设计中的至关重要性，并掌握防止并发编程中常见安全问题的核心原则 [@problem_id:3689375]。", "problem": "考虑一个两级目录系统，其根目录为每个用户包含一个目录。对于标识符为 $U$ 的用户，将其目录表示为 $D_U$，并将要创建的文件命名为 $N$。一个以有效用户标识符 $U$ 运行的程序 $P$ 打算在 $D_U$ 内创建 $N$。在当前的实现中，$P$ 执行两个独立的系统调用：首先在时刻 $t_1$ 检查 $N$ 是否存在于 $D_U$ 中（使用存在性谓词 $E(D_U,N,t_1)$），然后，如果检查结果为不存在，它在时刻 $t_2$ 发出创建调用。另一个由攻击者控制的进程 $Q$ 可以在时间间隔 $(t_1,t_2)$ 内并发地修改 $D_U$ 中的目录条目，可能会引入符号链接并更改 $N$ 的目标。这引发了一个“检查时-使用时”（Time Of Check to Time Of Use, TOCTOU）漏洞：$P$ 基于 $E(D_U,N,t_1)$ 做出的决定，到时刻 $t_2$ 使用时可能已经失效。\n\n假设以下来自操作系统的基本定义和事实：\n- 如果一个操作在内核中作为单个不可分割的动作执行，那么它是原子的，因此没有其他进程可以在该操作期间观察到中间状态或交错执行冲突的更新。\n- 目录操作由内核的路径解析和访问控制来协调。设 $\\text{owner}(D)$ 为目录 $D$ 的所有者标识符。设 $\\text{perm}(U, D, \\text{op})$ 为一个谓词，表示用户 $U$ 对目录 $D$ 拥有操作 $\\text{op}$ 的权限。\n- 存在性谓词 $E(D,N,t)$ 为真，如果在时刻 $t$，目录 $D$ 中存在名为 $N$ 的目录条目；它本身不区分文件类型（常规文件与符号链接）。\n- 符号链接遍历可以将路径解析重定向到 $D_U$ 之外的目标，除非被那些对最终路径组件不遵循符号链接的语义明确阻止。\n- 两级目录不变量要求每个用户文件路径的形式为 $/users/U/N$，并且 $\\text{owner}(D_U)=U$。\n\n你的任务是通过用原子创建语义替换“先检查后创建”的两次调用来消除 TOCTOU 漏洞，并指定必要的内核端检查以强制执行两级目录不变量、避免符号链接重定向，并确保存在性测试和创建操作作为一个不可分割的操作发生。\n\n哪个选项最完整、最正确地指定了原子创建语义，并概述了足以防止此两级目录系统中 TOCTOU 漏洞的内核端检查？\n\nA. 通过使用仅限目录的标志打开 $D_U$，获取一个指向 $D_U$ 的目录文件描述符 $d$，然后使用相关标志调用一个相对于 $d$ 的、针对名称 $N$ 的单一原子创建操作。这些标志的作用是：仅当文件不存在时才创建它，并禁止跟随作为最终组件的符号链接。在内核中，相对于 $d$ 解析 $N$，验证 $\\text{owner}(D_U)=U$ 和 $\\text{perm}(U,D_U,\\text{create})$，如果在操作发生的瞬间 $t$，$E(D_U,N,t)$ 为真则拒绝操作，阻止跟随作为最终组件的符号链接，并在一个覆盖存在性检查和插入操作的锁下将 $N$ 插入 $D_U$，若名称已存在则返回错误。\n\nB. 在用户空间中循环：在时刻 $t$ 通过状态调用检查 $E(D_U,N,t)$，如果未找到条目则发出创建请求；如果因并发更改而失败，则重试。在内核中，仅依赖标准的访问控制列表（ACL）检查，并照常允许符号链接遍历。这确保了最终的成功，而无需特殊的原子语义。\n\nC. 在时刻 $t_1$ 在 $D_U$ 中创建一个临时文件 $T$，然后在时刻 $t_2$ 将 $T$ 原子地重命名为 $N$。在内核中，允许重命名操作在 $N$ 并发出现时覆盖它，因为重命名是原子的。这避免了显式的存在性检查，因此消除了 TOCTOU 问题。\n\nD. 对绝对路径 $/users/U/N$ 使用单个创建调用，不带排exclusive性创建标志。在该调用返回后，检查返回的文件描述符的元数据，以确保它属于 $D_U$。在内核中，允许跟随最终组件中的符号链接，并依赖事后验证来捕获重定向错误。\n\n选择最佳选项。", "solution": "用户要求对一个关于两级目录系统中“检查时-使用时”（TOCTOU）漏洞的问题进行严格分析。任务包括验证问题陈述，如果问题有效，则推导出正确的解决方案并评估给定的选项。\n\n### 问题验证\n\n首先，对问题陈述进行严格的验证。\n\n#### 第 1 步：提取已知条件\n\n问题陈述提供了以下信息：\n- **系统**：一个两级目录系统。根目录为每个用户包含一个目录。\n- **实体**：\n    - 用户标识符：$U$\n    - 用户目录：$D_U$（位于根目录下，例如 `/users/U`）\n    - 要创建的文件：$N$\n    - 一个以有效用户标识符 $U$ 运行的程序 $P$。\n    - 一个攻击者进程 $Q$。\n- **含漏洞的流程**：\n    - 在时刻 $t_1$，程序 $P$ 使用谓词 $E(D_U,N,t_1)$ 检查 $N$ 是否存在于 $D_U$ 中。\n    - 如果检查结果为不存在，$P$ 在时刻 $t_2$ 发出对 $N$ 的创建调用。\n- **攻击者行为**：进程 $Q$ 可以在时间间隔 $(t_1, t_2)$ 内修改 $D_U$ 中的目录条目。\n- **漏洞**：“检查时-使用时”（TOCTOU）。\n- **基本定义和事实**：\n    - **原子操作**：在内核中作为单个不可分割的动作执行的操作。\n    - **访问控制**：目录操作由内核协调。\n    - $\\text{owner}(D)$：一个返回目录 $D$ 所有者标识符的函数。\n    - $\\text{perm}(U, D, \\text{op})$：一个谓词，如果用户 $U$ 对目录 $D$ 拥有操作 $\\text{op}$ 的权限，则为真。\n    - $E(D,N,t)$：一个谓词，如果在时刻 $t$，目录 $D$ 中存在名为 $N$ 的条目，则为真。它不区分文件类型。\n    - **符号链接**：符号链接遍历可以重定向路径解析，除非被阻止。\n    - **系统不变量**：所有用户文件路径的形式都为 `/users/U/N`，并且 $\\text{owner}(D_U)=U$。\n- **任务**：通过用原子操作替换两步过程来消除 TOCTOU 漏洞，并指定必要的内核端检查以强制执行不变量、防止符号链接重定向，以及将存在性测试和创建合并为一个不可分割的操作。\n\n#### 第 2 步：使用提取的已知条件进行验证\n\n- **科学上合理（关键）**：该问题描述了 TOCTOU 竞争条件，这是计算机安全领域一个典型且基本的漏洞，特别是在操作系统文件管理的背景下。原子操作、权限、符号链接和目录结构等概念都是操作系统领域中标准且成熟的。该场景是用于教授安全编程实践的典型示例。该问题在科学上是合理的。\n- **问题定义明确**：该问题定义明确。它清晰地定义了初始的不安全状态和期望的安全状态。目标是确定能够正确、完整地实现此安全状态的一套机制。基于已建立的操作系统设计原则，存在一个确定的解决方案。\n- **客观性（关键）**：该问题使用形式化和客观的语言陈述（例如，$U, D_U, N, t_1, t_2, E(D,N,t)$）。对系统行为的描述是技术性的，不含主观性或个人观点。\n- **其他缺陷**：问题陈述是自包含、一致的，并提供了足够的信息来推导解决方案。它不存在任何所列的无效标准。\n\n#### 第 3 步：结论和行动\n问题陈述是**有效的**。可以继续进行分析。\n\n### 解决方案推导\n\nTOCTOU 漏洞的核心在于检查（在 $t_1$）和使用（在 $t_2$）之间的时间差。在此间隔 $(t_1, t_2)$ 内，攻击者可以改变文件系统的状态，从而使“使用”操作所依据的前提失效。\n\n在此特定场景中，“检查”是 $E(D_U,N,t_1)$ 为假，而“使用”是在 $t_2$ 创建文件 $N$。例如，攻击者可以：\n1.  创建一个名为 $N$ 的常规文件。$P$ 随后的创建调用可能会失败或覆盖它，具体取决于所使用的标志。\n2.  创建一个名为 $N$ 的符号链接，指向一个敏感文件，例如系统配置文件或用户 $U$ 拥有的、程序 $P$ 有权写入的另一个文件。如果在时刻 $t_2$ 的 `create` 操作遵循符号链接并具有覆盖语义（例如 `open(path, O_WRONLY | O_TRUNC)`），程序 $P$ 可能会无意中销毁该链接的目标。\n\n为了消除此漏洞，检查和使用必须合并为由内核执行的单个**原子**操作。此原子操作必须具备以下属性：\n1.  **原子性**：检查 $N$ 的存在性以及在它不存在时创建它的操作必须是不可分割的。这通常通过在内核中使用父目录（$D_U$）数据结构上的锁来实现。\n2.  **排他性**：如果条目 $N$ 已存在，操作必须失败。这直接实现了“如果不存在，则创建”的逻辑，并挫败了攻击者创建同名文件的竞争。在 POSIX 系统中，此语义由 `open()` 系统调用的 `O_EXCL` 标志与 `O_CREAT` 标志结合提供。\n3.  **符号链接保护**：如果路径的最终组件（即 $N$）处存在符号链接，则操作不得跟随该符号链接。这可以防止操作被重定向到非预期的位置。在 POSIX 中，这是通过 `O_NOFOLLOW` 标志实现的。\n4.  **稳定的目录引用**：为防止在通往目录 $D_U$ 本身的路径上出现竞争条件（例如，攻击者将 `/users/U` 替换为符号链接），最佳实践是首先获取到目录 $D_U$ 的一个稳定句柄（文件描述符），然后相对于该句柄执行文件创建。POSIX 为此提供了 `openat()`。打开目录时应验证其确实是一个目录（例如，使用 `O_DIRECTORY` 标志）。\n5.  **不变量和权限强制执行**：在单个原子内核操作内部，所有必要的检查仍必须执行。这包括验证用户 $U$ 对目录 $D_U$ 具有创建权限（即 $\\text{perm}(U,D_U,\\text{create})$），以及任何系统特定的不变量（如 $\\text{owner}(D_U)=U$）均成立。\n\n一个完整且正确的解决方案必须体现所有这些原则。\n\n### 逐项分析\n\n现在，我们根据这套推导出的要求来评估每个选项。\n\n**A. 通过使用仅限目录的标志打开 $D_U$，获取一个指向 $D_U$ 的目录文件描述符 $d$，然后使用相关标志调用一个相对于 $d$ 的、针对名称 $N$ 的单一原子创建操作。这些标志的作用是：仅当文件不存在时才创建它，并禁止跟随作为最终组件的符号链接。在内核中，相对于 $d$ 解析 $N$，验证 $\\text{owner}(D_U)=U$ 和 $\\text{perm}(U,D_U,\\text{create})$，如果在操作发生的瞬间 $t$，$E(D_U,N,t)$ 为真则拒绝操作，阻止跟随作为最终组件的符号链接，并在一个覆盖存在性检查和插入操作的锁下将 $N$ 插入 $D_U$，若名称已存在则返回错误。**\n\n此选项全面地解决了所有要求。\n- 它使用了一个稳定的目录文件描述符 $d$，防止了在通往 $D_U$ 的路径上的竞争。\n- 它使用了相对于 $d$ 的单个原子创建调用。\n- 它指定了排他性创建（“仅当文件不存在时才创建”）。\n- 它指定了对符号链接攻击的防护（“禁止跟随作为最终组件的符号链接”）。\n- 它正确地概述了内核端的实现：验证所有权（$\\text{owner}(D_U)=U$）和权限（$\\text{perm}(U,D_U,\\text{create})$），在锁的保护下执行存在性检查和创建（确保原子性），并在文件已存在时返回错误。\n此选项与推导出的解决方案完全匹配。\n**结论：正确**\n\n**B. 在用户空间中循环：在时刻 $t$ 通过状态调用检查 $E(D_U,N,t)$，如果未找到条目则发出创建请求；如果因并发更改而失败，则重试。在内核中，仅依赖标准的访问控制列表（ACL）检查，并照常允许符号链接遍历。这确保了最终的成功，而无需特殊的原子语义。**\n\n此选项未能解决问题。\n- 它明确地在一个循环中保留了非原子的“先检查后操作”序列。漏洞窗口在每一次迭代中都存在。\n- 它没有“消除”漏洞，而是提出了一个恢复策略，如果攻击者持续攻击，可能会导致活锁。\n- 关键是，它声明“照常允许符号链接遍历”，这使得最危险的攻击向量完全暴露。一个带有写入/截断标志的 `open()` 调用仍然会跟随恶意链接并损坏目标文件。\n**结论：不正确**\n\n**C. 在时刻 $t_1$ 在 $D_U$ 中创建一个临时文件 $T$，然后在时刻 $t_2$ 将 $T$ 原子地重命名为 $N$。在内核中，允许重命名操作在 $N$ 并发出现时覆盖它，因为重命名是原子的。这避免了显式的存在性检查，因此消除了 TOCTOU 问题。**\n\n此选项使用了原子操作 (`rename`)，这对于某些原子更新是有效的模式。然而，在此上下文中它是有缺陷的。\n- 最初的逻辑是“如果不存在，则创建”。此选项将语义更改为“原子地替换 $N$ 处的任何东西”。标准的 `rename` 语义规定，如果目标（$N$）存在，它将被解除链接（覆盖）。这与排他性创建是不同的行为。如果攻击者创建了一个合法文件 $N$，此过程将销毁它，这并非最初的意图。\n- 虽然 `rename` 通常不会在其目标处跟随符号链接（它会替换链接本身），但所提出的逻辑（“允许重命名覆盖 $N$”）不符合问题中“*仅当文件不存在时*才创建文件”的要求。它用一个问题（TOCTOU）换来了另一个问题（无条件覆盖）。\n**结论：不正确**\n\n**D. 对绝对路径 $/users/U/N$ 使用单个创建调用，不带排他性创建标志。在该调用返回后，检查返回的文件描述符的元数据，以确保它属于 $D_U$。在内核中，允许跟随最终组件中的符号链接，并依赖事后验证来捕获重定向错误。**\n\n此选项从根本上是不安全的，并表现出对 TOCTOU 问题的误解。\n- 在操作*之后*执行检查（“事后验证”）被称为“使用时-检查时”（TOUTOC）漏洞。破坏性操作可能已经完成。例如，如果 `create` 调用是一个带有截断文件标志 (`O_TRUNC`) 的 `open()`，那么恶意符号链接的目标将在检查能够执行*之前*被清空。\n- 它通过“允许跟随最终组件中的符号链接”来明确地允许该漏洞。\n- 它不使用排他性创建标志，这意味着它会欣然打开攻击者植入的文件或链接。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3689375"}]}