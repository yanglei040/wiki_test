{"hands_on_practices": [{"introduction": "在现代数据中心中，理解网络附加存储的性能至关重要。第一个练习将探讨基于软件的 iSCSI 启动器与专用硬件卸载网络接口卡（NIC）之间的权衡。通过从第一性原理对 CPU 周期成本和会话建立时间进行建模，你将量化硬件加速在真实世界中的性能优势，这是系统设计中的一个关键概念。[@problem_id:3634733]", "problem": "一个存储团队正在评估两种使用 Internet 小型计算机系统接口 (iSCSI) 连接远程磁盘的方法：一种是使用主机中央处理器 (CPU) 的软件启动器，另一种是在硬件中实现协议处理的 iSCSI 卸载网络接口控制器 (NIC)。他们希望通过结合两个基于第一性原理的效果，来对跨多个会话的卸载方法的端到端收益进行原则性估算：这两个效果是持续数据传输期间节省的 CPU 秒数和会话登录期间节省的挂钟连接时间。假设以下广泛使用的基本原则：\n- 任务消耗的总 CPU 时间是执行的总周期数除以 CPU 频率，即 $t_{\\text{cpu}} = \\frac{\\text{cycles}}{f}$。\n- 网络栈中每字节和每数据包的处理成本分别被建模为恒定的周期成本 $a$（周期/字节）和 $p$（周期/数据包），总周期数是跨字节和数据包累加的。\n- 传输给定数量的有效载荷字节所需的数据包数量，是有效载荷字节数除以每个数据包的有效载荷的向上取整。\n- 1 mebibyte 等于 $2^{20}$ 字节，即 $1 \\text{ MiB} = 2^{20} \\text{ bytes}$。\n- 在 CPU 上进行哈希计算的 $L$ 字节认证工作负载，每字节消耗恒定的周期数。\n\n考虑以下具体场景。一个 CPU 频率为 $f$ 的主机运行 $N$ 个 iSCSI 会话，这些会话被顺序连接，然后以每个会话 $s$ 的应用有效载荷吞吐量，在 $T$ 秒的时间窗口内并发地持续进行读取。每个会话使用一个最大传输单元 (MTU)，其每个数据包的有效 TCP 有效载荷为 $\\text{pld}$ 字节。软件启动器产生每字节成本 $a_{\\text{sw}}$ 和每数据包成本 $p_{\\text{sw}}$，而卸载 NIC 产生的成本为 $a_{\\text{off}}$ 和 $p_{\\text{off}}$。在登录（连接）期间，两种实现都执行一个固定的控制握手，该握手包含 $k$ 次往返，往返时间 (RTT) 为 $\\text{RTT}$，并且两者都必须通过哈希认证 $L$ 字节；软件启动器对此哈希计算每字节需要 $h_{\\text{sw}}$ 个周期，而卸载 NIC 将 CPU 哈希成本降低到软件成本的一小部分 $\\rho$，但在登录时为每个会话引入了固定的固件设置延迟 $g$。假设 $k \\in \\mathbb{N}$，并且在比较连接时间时，控制握手延迟部分可以相互抵消，因为它在两种情况下是相同的。\n\n使用以下参数值：\n- $f = 3.2 \\times 10^{9} \\text{ 周期/秒}$，$N = 8$，$T = 10 \\text{ 秒}$，$s = 50 \\text{ MiB/s}$。\n- $\\text{pld} = 1460 \\text{ 字节}$。\n- $a_{\\text{sw}} = 3 \\text{ 周期/字节}$，$p_{\\text{sw}} = 6000 \\text{ 周期/数据包}$。\n- $a_{\\text{off}} = 0.3 \\text{ 周期/字节}$，$p_{\\text{off}} = 600 \\text{ 周期/数据包}$。\n- $k = 6$，$\\text{RTT} = 1.5 \\times 10^{-3} \\text{ 秒}$，$L = 64 \\text{ KiB}$ 且 $1 \\text{ KiB} = 1024 \\text{ 字节}$，$h_{\\text{sw}} = 20 \\text{ 周期/字节}$，$\\rho = 0.05$，$g = 2.0 \\times 10^{-4} \\text{ 秒}$。\n\n定义在所有 $N$ 个会话中，卸载 NIC 相对于软件启动器的组合时间优势 $M$ 为以下各项之和：\n- 在 $T$ 秒的持续读取窗口期间节省的总 CPU 秒数，该值根据软件和卸载之间数据路径周期成本的差异计算得出，以及\n- 在 $N$ 个顺序会话连接中节省的总挂钟连接（登录）时间，该值根据每个会话的软件和卸载客户端连接时间之间的差异计算得出。\n\n计算 $M$ 并以秒为单位表示您的最终答案。将您的答案四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是具有科学依据、提法得当且客观的。它使用成熟的关于网络处理中 CPU 成本的第一性原理模型，呈现了一个计算机系统中的标准性能建模场景。所有必要的参数和定义都已提供，不存在矛盾或歧义。因此，可以构建一个完整的解决方案。\n\n问题要求计算 iSCSI 卸载 NIC 相对于软件启动器的组合时间优势 $M$。这个优势被定义为两个部分之和：\n1.  在持续数据传输期间节省的总 CPU 秒数，我们将其表示为 $\\Delta t_{\\text{cpu,transfer}}$。\n2.  在所有会话中节省的总挂钟连接时间，我们将其表示为 $\\Delta t_{\\text{attach,total}}$。\n\n因此，总优势为 $M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}}$。我们将分别计算每个部分。\n\n首先，我们计算在持续数据传输期间节省的总 CPU 秒数 $\\Delta t_{\\text{cpu,transfer}}$。\n在所有 $N$ 个会话中，以每个会话 $s$ 的吞吐量持续传输 $T$ 时间，传输的应用有效载荷数据总量 $B_{\\text{total}}$ 为：\n$$B_{\\text{total}} = N \\times s \\times T$$\n吞吐量 $s$ 以 mebibytes 每秒（$\\text{MiB/s}$）给出，必须将其转换为字节每秒。使用给定的转换关系 $1 \\text{ MiB} = 2^{20} \\text{ bytes}$：\n$$B_{\\text{total}} = N \\times (s \\times 2^{20}) \\times T$$\n\n传输这些字节所需的数据包总数 $P_{\\text{total}}$ 由每个数据包的有效载荷 $\\text{pld}$ 决定。根据问题，这是总字节数除以有效载荷大小的向上取整：\n$$P_{\\text{total}} = \\left\\lceil \\frac{B_{\\text{total}}}{\\text{pld}} \\right\\rceil$$\n\n数据传输消耗的总 CPU 周期数是每字节和每数据包成本的总和。对于软件启动器，总周期数为：\n$$C_{\\text{sw,transfer}} = a_{\\text{sw}} B_{\\text{total}} + p_{\\text{sw}} P_{\\text{total}}$$\n对于卸载 NIC，CPU 产生的成本更低：\n$$C_{\\text{off,transfer}} = a_{\\text{off}} B_{\\text{total}} + p_{\\text{off}} P_{\\text{total}}$$\n\n使用卸载 NIC 节省的 CPU 周期数是两者之差：\n$$\\Delta C_{\\text{transfer}} = C_{\\text{sw,transfer}} - C_{\\text{off,transfer}} = (a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}$$\n\n节省的 CPU 时间 $\\Delta t_{\\text{cpu,transfer}}$ 是节省的周期数除以 CPU 频率 $f$：\n$$\\Delta t_{\\text{cpu,transfer}} = \\frac{\\Delta C_{\\text{transfer}}}{f} = \\frac{(a_{\\text{sw}} - a_{\\text{off}}) B_{\\text{total}} + (p_{\\text{sw}} - p_{\\text{off}}) P_{\\text{total}}}{f}$$\n\n接下来，我们计算节省的总挂钟连接时间 $\\Delta t_{\\text{attach,total}}$。\n会话是顺序连接的，所以节省的总时间是单个会话节省时间的 $N$ 倍。设 $\\Delta t_{\\text{attach,session}}$ 为一次会话登录节省的挂钟时间。\n$$\\Delta t_{\\text{attach,total}} = N \\times \\Delta t_{\\text{attach,session}}$$\n\n单个会话的连接时间包括一个网络握手部分和一个受 CPU 限制的认证部分。问题指出，握手延迟（$k \\times \\text{RTT}$）对于两种方法是相同的，在比较中会相互抵消。因此，我们只需要考虑在认证上花费的时间差异以及任何其他指定的延迟。\n\n软件启动器认证的挂钟时间 $t_{\\text{auth,sw}}$ 是哈希 $L$ 字节所需的 CPU 时间。大小 $L$ 以 kibibytes（$\\text{KiB}$）给出，必须使用 $1 \\text{ KiB} = 1024 \\text{ bytes}$ 转换为字节。设 $L_{\\text{bytes}} = L \\times 1024$。\n$$t_{\\text{auth,sw}} = \\frac{C_{\\text{auth,sw}}}{f} = \\frac{L_{\\text{bytes}} \\times h_{\\text{sw}}}{f}$$\n\n对于卸载 NIC，哈希的 CPU 成本减少了一个因子 $\\rho$。CPU 上认证的挂钟时间为：\n$$t_{\\text{auth,off}} = \\frac{\\rho \\times (L_{\\text{bytes}} \\times h_{\\text{sw}})}{f}$$\n然而，卸载 NIC 引入了一个额外的固定固件设置延迟 $g$。\n\n每种实现的总挂钟连接时间为：\n$$t_{\\text{attach,sw}} = t_{\\text{handshake}} + t_{\\text{auth,sw}}$$\n$$t_{\\text{attach,off}} = t_{\\text{handshake}} + t_{\\text{auth,off}} + g$$\n\n每个会话节省的时间是两者之差：\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{attach,sw}} - t_{\\text{attach,off}} = (t_{\\text{handshake}} + t_{\\text{auth,sw}}) - (t_{\\text{handshake}} + t_{\\text{auth,off}} + g)$$\n$$\\Delta t_{\\text{attach,session}} = t_{\\text{auth,sw}} - t_{\\text{auth,off}} - g = \\frac{L_{\\text{bytes}} h_{\\text{sw}}}{f} - \\frac{\\rho L_{\\text{bytes}} h_{\\text{sw}}}{f} - g = \\frac{(1 - \\rho) L_{\\text{bytes}} h_{\\text{sw}}}{f} - g$$\n\n在所有 $N$ 个会话中节省的总挂钟时间为：\n$$\\Delta t_{\\text{attach,total}} = N \\left(\\frac{(1 - \\rho) (L \\times 1024) h_{\\text{sw}}}{f} - g\\right)$$\n\n现在，我们将给定的数值代入这些表达式中。\n给定值：$f = 3.2 \\times 10^9 \\text{ 周期/秒}$，$N = 8$，$T = 10 \\text{ 秒}$，$s = 50 \\text{ MiB/s}$，$\\text{pld} = 1460 \\text{ 字节}$，$a_{\\text{sw}} = 3$，$p_{\\text{sw}} = 6000$，$a_{\\text{off}} = 0.3$，$p_{\\text{off}} = 600$，$L = 64 \\text{ KiB}$，$h_{\\text{sw}} = 20$，$\\rho = 0.05$，$g = 2.0 \\times 10^{-4} \\text{ 秒}$。\n\n$\\Delta t_{\\text{cpu,transfer}}$ 的计算：\n$B_{\\text{total}} = 8 \\times (50 \\times 2^{20} \\text{ 字节/秒}) \\times 10 \\text{ 秒} = 4000 \\times 2^{20} \\text{ 字节} = 4194304000 \\text{ 字节}$。\n$P_{\\text{total}} = \\lceil \\frac{4194304000}{1460} \\rceil = \\lceil 2872810.95... \\rceil = 2872811 \\text{ 个数据包}$。\n$\\Delta a = a_{\\text{sw}} - a_{\\text{off}} = 3 - 0.3 = 2.7$ 周期/字节。\n$\\Delta p = p_{\\text{sw}} - p_{\\text{off}} = 6000 - 600 = 5400$ 周期/数据包。\n$\\Delta C_{\\text{transfer}} = (2.7 \\times 4194304000) + (5400 \\times 2872811) = 11324620800 + 15513179400 = 26837800200 \\text{ 周期}$。\n$\\Delta t_{\\text{cpu,transfer}} = \\frac{26837800200}{3.2 \\times 10^9} \\approx 8.38681 \\text{ 秒}$。\n\n$\\Delta t_{\\text{attach,total}}$ 的计算：\n$L_{\\text{bytes}} = 64 \\text{ KiB} = 64 \\times 1024 \\text{ 字节} = 65536 \\text{ 字节}$。\n$1 - \\rho = 1 - 0.05 = 0.95$。\n$\\Delta t_{\\text{attach,session}} = \\frac{0.95 \\times 65536 \\times 20}{3.2 \\times 10^9} - 2.0 \\times 10^{-4} = \\frac{1245184}{3.2 \\times 10^9} - 0.0002 = 0.00038912 - 0.0002 = 0.00018912 \\text{ 秒}$。\n$\\Delta t_{\\text{attach,total}} = 8 \\times 0.00018912 \\text{ 秒} = 0.00151296 \\text{ 秒}$。\n\n最后，我们计算总优势 $M$：\n$M = \\Delta t_{\\text{cpu,transfer}} + \\Delta t_{\\text{attach,total}} = 8.3868125625 \\text{ 秒} + 0.00151296 \\text{ 秒} = 8.3883255225 \\text{ 秒}$。\n\n问题要求答案四舍五入到四位有效数字。\n$M \\approx 8.388 \\text{ 秒}$。", "answer": "$$\n\\boxed{8.388}\n$$", "id": "3634733"}, {"introduction": "虽然平均性能很重要，但系统的稳定性通常取决于对最坏情况或“长尾”延迟的理解和管理。本练习引入一个概率模型来描述不同磁盘挂载方法（包括快速的本地 NVMe 和较慢的基于网络的 iSCSI）的延迟特征。你将学习如何使用此模型计算延迟百分位数并设置合适的 I/O 超时，这是构建健壮且响应迅速的操作系统的关键任务。[@problem_id:3634744]", "problem": "操作系统必须为不同的磁盘连接方式选择安全的块I/O超时设置，同时控制错误的超时。考虑三种连接方式的单块读取延迟模型：非易失性内存主机控制器接口（NVMe）、串行高级技术附件（SATA）固态硬盘，以及基于以太网的互联网小型计算机系统接口（iSCSI）。对于每种连接方式，将每次请求的延迟建模为随机变量 $X = c + Z$，其中 $c$ 是一个非负常数，代表基础延迟，而 $Z$ 是一个随机变量，用于捕捉因排队或重试而产生的偶发性尾部延迟。假设 $Z$ 以概率 $1 - p$ 取值为 $0$，并以概率 $p$ 等于 $Y$，其中 $Y$ 独立于 $c$ 且服从速率为 $\\lambda$ 的指数分布。指数分布的累积分布函数为 $F_{Y}(y) = 1 - \\exp(-\\lambda y)$，其中 $y \\ge 0$。这个混合模型捕捉了在 $c$ 处存在一个质量点并带有一个指数尾的经验观察现象。\n\n对于每种连接方式，使用以下参数（单位均为毫秒）：\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$。\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$。\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$。\n\n使用上述基本定义并根据模型进行推理，完成以下任务：\n1. 推导 $X$ 的 $0.99$-分位数（第 $99$ 百分位数）延迟 $L_{99}$ 的表达式，并计算每种连接方式的 $L_{99}$。\n2. 为每种连接方式推荐一个操作系统超时时间 $t_{o}$，选择满足 $\\mathbb{P}(X > t_{o}) \\le \\theta$ 的最小 $t_{o}$，其中目标尾部超出概率为 $\\theta = 10^{-4}$。计算每种连接方式的 $t_{o}$。\n\n将所有数值答案四舍五入到四位有效数字。所有答案以毫秒为单位表示。以单行形式提供最终答案，包含六个值，顺序为：$L_{99}^{\\mathrm{NVMe}}$、$L_{99}^{\\mathrm{SATA}}$、$L_{99}^{\\mathrm{iSCSI}}$、$t_{o}^{\\mathrm{NVMe}}$、$t_{o}^{\\mathrm{SATA}}$、$t_{o}^{\\mathrm{iSCSI}}$。", "solution": "该问题陈述已经过验证，被确定为一个在应用概率和计算机系统性能分析领域中定义明确、有科学依据且客观的问题。所有必要的参数和定义均已提供，且不存在内部矛盾。\n\n单块读取的延迟由随机变量 $X = c + Z$ 建模。其中，$c$ 是一个恒定的基础延迟，$Z$ 是一个代表额外延迟的随机变量。变量 $Z$ 服从一个混合分布：它以概率 $1-p$ 为 $0$，并以概率 $p$ 服从速率为 $\\lambda$ 的指数分布。设这个指数随机变量为 $Y$。$Y$ 的累积分布函数 (CDF) 为 $F_Y(y) = 1 - \\exp(-\\lambda y)$，其中 $y \\ge 0$。\n\n首先，我们推导总延迟 $X$ 的 CDF，记为 $F_X(x) = \\mathbb{P}(X \\le x)$。\n$$F_X(x) = \\mathbb{P}(c + Z \\le x) = \\mathbb{P}(Z \\le x-c)$$\n令 $z' = x-c$。$Z$ 的支撑集是 $[0, \\infty)$，因为 $Y$ 的支撑集是 $[0, \\infty)$ 并且 $Z$ 也可以是 $0$。因此，如果 $x  c$，那么 $x-c  0$，且 $\\mathbb{P}(Z \\le x-c) = 0$。所以，对于 $x  c$，$F_X(x) = 0$。\n\n对于 $x \\ge c$，我们有 $x-c \\ge 0$。我们可以使用全概率定律来求 $Z$ 的 CDF。\n$$\\mathbb{P}(Z \\le z') = \\mathbb{P}(Z \\le z' | Z=0)\\mathbb{P}(Z=0) + \\mathbb{P}(Z \\le z' | Z=Y)\\mathbb{P}(Z=Y)$$\n由于 $z' \\ge 0$，因此当 $Z=0$ 时，$Z \\le z'$ 这一条件总是满足。\n$$\\mathbb{P}(Z \\le z') = 1 \\cdot (1-p) + \\mathbb{P}(Y \\le z') \\cdot p$$\n代入指数分布的 CDF，$F_Y(z') = 1 - \\exp(-\\lambda z')$:\n$$\\mathbb{P}(Z \\le z') = (1-p) + p(1 - \\exp(-\\lambda z')) = 1 - p + p - p\\exp(-\\lambda z') = 1 - p\\exp(-\\lambda z')$$\n将 $z' = x-c$ 代回，我们得到当 $x \\ge c$ 时 $X$ 的 CDF：\n$$F_X(x) = 1 - p\\exp(-\\lambda(x-c))$$\n这个 CDF 在 $x=c$ 处有一个不连续点。一个请求恰好在基础延迟 $c$ 完成的概率是 $\\mathbb{P}(X=c) = \\mathbb{P}(Z=0) = 1-p$。在此点处的 CDF 值为 $F_X(c) = \\mathbb{P}(X \\le c) = \\mathbb{P}(X=c) = 1-p$，这与我们推导出的公式一致：$F_X(c) = 1 - p\\exp(0) = 1-p$。\n\n1. 推导 $0.99$-分位数（第 $99$ 百分位数）延迟 $L_{99}$ 的表达式。\n$q$-分位数 $x_q$ 是满足 $F_X(x_q) = q$ 的值。我们需要找到 $L_{99}$ 使得 $F_X(L_{99}) = 0.99$。\n首先，我们检查分位数是位于 $c$ 处的质量点上，还是在指数尾部。在质量点处的 CDF 值为 $1-p$。\n对于 NVMe：$1 - p_{\\mathrm{NVMe}} = 1 - 0.02 = 0.98$。\n对于 SATA：$1 - p_{\\mathrm{SATA}} = 1 - 0.03 = 0.97$。\n对于 iSCSI：$1 - p_{\\mathrm{iSCSI}} = 1 - 0.05 = 0.95$。\n在这三种情况下，目标概率 $0.99$ 都大于 $1-p$。这意味着 $L_{99}$ 必须大于 $c$ 并且位于分布的连续指数尾部之内。我们求解 $L_{99}$：\n$$F_X(L_{99}) = 1 - p\\exp(-\\lambda(L_{99}-c)) = 0.99$$\n$$p\\exp(-\\lambda(L_{99}-c)) = 1 - 0.99 = 0.01$$\n$$\\exp(-\\lambda(L_{99}-c)) = \\frac{0.01}{p}$$\n对两边取自然对数：\n$$-\\lambda(L_{99}-c) = \\ln\\left(\\frac{0.01}{p}\\right) = -\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99}-c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{0.01}\\right)$$\n$$L_{99} = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{10^{-2}}\\right)$$\n\n现在我们为每种连接方式计算 $L_{99}$。\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$。\n$L_{99}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{0.01}\\right) = 0.12 + 0.35 \\ln(2) \\approx 0.12 + 0.35(0.693147) \\approx 0.362601$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{NVMe}} = 0.3626$ 毫秒。\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$。\n$L_{99}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{0.01}\\right) = 0.45 + 3.0 \\ln(3) \\approx 0.45 + 3.0(1.098612) \\approx 3.745836$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{SATA}} = 3.746$ 毫秒。\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$。\n$L_{99}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{0.01}\\right) = 1.30 + 10.0 \\ln(5) \\approx 1.30 + 10.0(1.609438) \\approx 17.39438$ 毫秒。\n保留四位有效数字，$L_{99}^{\\mathrm{iSCSI}} = 17.39$ 毫秒。\n\n2. 推荐一个操作系统超时时间 $t_{o}$。\n我们需要找到最小的 $t_o$，使得超过此超时时间的概率最多为 $\\theta = 10^{-4}$。\n$$\\mathbb{P}(X  t_o) \\le \\theta$$\n这等价于 $1 - \\mathbb{P}(X \\le t_o) \\le \\theta$，或者 $F_X(t_o) \\ge 1 - \\theta$。\n为了找到这样的最小 $t_o$，我们将 CDF 设置为这个所需的最小值：\n$$F_X(t_o) = 1 - \\theta = 1 - 10^{-4} = 0.9999$$\n其逻辑与第 1 部分中的分位数计算相同。对于所有三种连接方式，$1-p  0.9999$，所以超时时间 $t_o$ 将大于基础延迟 $c$。\n$$1 - p\\exp(-\\lambda(t_o-c)) = 1 - \\theta$$\n$$p\\exp(-\\lambda(t_o-c)) = \\theta$$\n$$\\exp(-\\lambda(t_o-c)) = \\frac{\\theta}{p}$$\n$$-\\lambda(t_o-c) = \\ln\\left(\\frac{\\theta}{p}\\right) = -\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o - c = \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n$$t_o = c + \\frac{1}{\\lambda}\\ln\\left(\\frac{p}{\\theta}\\right)$$\n\n现在我们用 $\\theta = 10^{-4}$ 为每种连接方式计算 $t_o$。\n- NVMe: $c_{\\mathrm{NVMe}} = 0.12$, $p_{\\mathrm{NVMe}} = 0.02$, $\\lambda_{\\mathrm{NVMe}} = \\frac{1}{0.35}$。\n$t_{o}^{\\mathrm{NVMe}} = 0.12 + 0.35 \\cdot \\ln\\left(\\frac{0.02}{10^{-4}}\\right) = 0.12 + 0.35 \\ln(200) \\approx 0.12 + 0.35(5.298317) \\approx 1.97441$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{NVMe}} = 1.974$ 毫秒。\n\n- SATA: $c_{\\mathrm{SATA}} = 0.45$, $p_{\\mathrm{SATA}} = 0.03$, $\\lambda_{\\mathrm{SATA}} = \\frac{1}{3.0}$。\n$t_{o}^{\\mathrm{SATA}} = 0.45 + 3.0 \\cdot \\ln\\left(\\frac{0.03}{10^{-4}}\\right) = 0.45 + 3.0 \\ln(300) \\approx 0.45 + 3.0(5.703782) \\approx 17.5613$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{SATA}} = 17.56$ 毫秒。\n\n- iSCSI: $c_{\\mathrm{iSCSI}} = 1.30$, $p_{\\mathrm{iSCSI}} = 0.05$, $\\lambda_{\\mathrm{iSCSI}} = \\frac{1}{10.0}$。\n$t_{o}^{\\mathrm{iSCSI}} = 1.30 + 10.0 \\cdot \\ln\\left(\\frac{0.05}{10^{-4}}\\right) = 1.30 + 10.0 \\ln(500) \\approx 1.30 + 10.0(6.214608) \\approx 63.4461$ 毫秒。\n保留四位有效数字，$t_{o}^{\\mathrm{iSCSI}} = 63.45$ 毫秒。\n\n所需的六个值是 $L_{99}^{\\mathrm{NVMe}}$、$L_{99}^{\\mathrm{SATA}}$、$L_{99}^{\\mathrm{iSCSI}}$、$t_{o}^{\\mathrm{NVMe}}$、$t_{o}^{\\mathrm{SATA}}$ 和 $t_{o}^{\\mathrm{iSCSI}}$。", "answer": "$$\\boxed{\\begin{pmatrix} 0.3626  3.746  17.39  1.974  17.56  63.45 \\end{pmatrix}}$$", "id": "3634744"}, {"introduction": "除了性能之外，确保系统完整性是操作系统的首要职责，尤其是在引导过程中。最后一个练习深入探讨一个关键的可靠性问题：由于标识符不明确，从不正确的克隆磁盘启动的风险。你将使用概率论分析此问题，并探索如何利用密码学保障措施来大幅降低错误引导的风险，从而亲身体验如何为系统安全进行设计。[@problem_id:3634761]", "problem": "一台服务器支持多种磁盘连接方式，包括串行高级技术附件（SATA）、非易失性内存快车（NVMe）和互联网小型计算机系统接口（iSCSI）。在早期引导期间，操作系统的设备枚举器以事件驱动的方式跨总线扫描附件，候选块设备的总体到达顺序可以建模为一个均匀随机排列，这反映了异步发现延迟和独立总线探测。引导配置通过文件系统通用唯一标识符（UUID）来识别根卷，该UUID定义为存储在文件系统超级块中的标准化通用唯一标识符（UUID）字符串。由于块级克隆，恰好有$k$个附件共享相同的文件系统UUID；其中一个是预期的根卷，而其余的$k-1$个是错误的克隆。所有其他附件都具有不匹配的文件系统UUID。在总线之间没有设备路径固定提示或持久排序保证。\n\n假设有$n_{S}$个SATA磁盘，$n_{N}$个NVMe命名空间，以及$n_{I}$个iSCSI逻辑单元号（LUN）；这些总数决定了枚举器扫描的池，但在其他方面不影响$k$个匹配附件中哪一个首先出现。系统当前选择其文件系统UUID与配置目标相等的第一个附件。\n\n然后你部署一个安全措施：引入$G$个独立的全局唯一标识符（GUID）命名空间，其中每个附件在配置时在每个命名空间中被分配一个全新的随机$128$位全局唯一标识符（GUID）。克隆保留了与预期根卷相同的文件系统UUID，但不共享任何新分配的GUID。引导接受规则变成一个合取：一个设备仅当其文件系统UUID和所有$G$个命名空间GUID都与配置值匹配时才被接受。将随机的$128$位GUID视为在附件间和命名空间内独立且均匀分布。\n\n从随机枚举和加密标识符独立性的第一性原理出发：\n- 推导在原始规则（仅匹配文件系统UUID）下从错误附件引导的概率$p_{misboot}$的表达式，用$k$表示。\n- 推导在安全措施下$p_{misboot}$的闭式表达式，作为$k$和$G$的函数。\n- 对$k=3$和$G=2$的情况，数值计算有安全措施的$p_{misboot}$，答案四舍五入到四位有效数字。将最终概率以科学记数法的小数形式表示。不需要单位。\n\n为具体起见，可以设$n_{S}=4$、$n_{N}=3$和$n_{I}=5$，并应说明在所述假设下，这些计数为何会或不会影响$p_{misboot}$。最终的数值答案必须是$k=3$和$G=2$时的带安全措施的$p_{misboot}$，四舍五入到四位有效数字。", "solution": "该问题要求推导在两种不同引导规则下的错误引导概率，并进行最终的数值计算。\n\n首先，我们讨论设备计数$n_{S}$、$n_{N}$和$n_{I}$的作用。设备总数为$N = n_{S} + n_{N} + n_{I}$。问题陈述操作系统以“均匀随机排列”的方式扫描设备，并选择*第一个*满足引导标准的设备。引导标准涉及匹配特定的文件系统UUID。有$k$个设备具有此目标UUID，另有$N-k$个设备没有。引导过程永远不会在$N-k$个设备中的任何一个上终止，因此它们与最终选择无关。决策完全在$k$个候选设备中做出。由于$N$个设备的整体排列是均匀随机的，因此$k$个候选设备的相对顺序也是一个大小为$k$的均匀随机排列。这意味着$k$个具有匹配UUID的设备中，每一个出现在候选序列中第一个位置的概率是相等的。因此，$n_{S}$、$n_{N}$和$n_{I}$的具体值（其总和为$N$）不影响错误引导的概率，因为该概率仅取决于$k$个候选设备组内的相对顺序。\n\n在原始规则下推导$p_{misboot}$：\n在原始规则下，系统从它找到的第一个具有正确文件系统UUID的设备启动。我们有$k$个这样的设备，包括1个正确的根设备和$k-1$个错误的克隆。如前所述，这$k$个设备中的每一个都有相同的机会成为从该集合中遇到的第一个设备。\n如果遇到的第一个设备是$k-1$个克隆之一，就会发生错误引导。此事件的概率是不利结果数除以可能结果总数。\n有$k-1$个不利结果（选择一个克隆）和$k$个可能的结果总数（选择任何一个具有匹配UUID的设备）。\n因此，错误引导的概率$p_{misboot}$为：\n$$p_{misboot} = \\frac{k-1}{k}$$\n\n在安全措施规则下推导$p_{misboot}$：\n在安全措施下，设备必须匹配文件系统UUID和所有$G$个配置的GUID。$k-1$个克隆共享文件系统UUID，但在$G$个命名空间中的每一个都被分配了全新的、随机的128位GUID。\n假设均匀分布，一个随机生成的128位GUID恰好与特定目标GUID匹配的概率是$p_{g} = \\frac{1}{2^{128}}$。\n由于$G$个GUID是独立的，单个克隆纯粹偶然拥有一整套匹配GUID（“GUID碰撞”）的概率是：\n$$p_{coll} = (p_{g})^{G} = \\left(\\frac{1}{2^{128}}\\right)^G = 2^{-128G}$$\n这个概率极小。只有当至少一个克隆发生GUID碰撞*并且*在真正的根卷之前被扫描时，才会发生错误引导。\n\n设$M$为（在$k-1$个克隆中）发生GUID碰撞的克隆数量。这是一个遵循二项分布的随机变量，$M \\sim \\text{Binomial}(k-1, p_{coll})$。恰好有$m$个碰撞克隆的概率是$P(M=m) = \\binom{k-1}{m} p_{coll}^m (1-p_{coll})^{k-1-m}$。\n能够通过所有检查（即“可引导”）的设备集合包括真正的根卷（它总能通过）和$M$个碰撞的克隆。可引导设备的总数是$1+M$。\n系统将从它遇到的这$1+M$个可引导设备中的第一个启动。如果这个设备是$M$个克隆中的一个，则发生错误引导。给定有$M=m$个碰撞克隆，则有$1+m$个可引导设备。根据对称性，这些设备中第一个被扫描到的是克隆的概率是$\\frac{m}{1+m}$。\n为了找到错误引导的总概率，我们计算这个条件概率在$M$所有可能值上的期望值：\n$$p_{misboot} = E\\left[\\frac{M}{1+M}\\right] = \\sum_{m=0}^{k-1} P(M=m) \\frac{m}{1+m}$$\n代入二项概率，我们得到：\n$$p_{misboot} = \\sum_{m=1}^{k-1} \\binom{k-1}{m} p_{coll}^m (1-p_{coll})^{k-1-m} \\frac{m}{1+m}$$\n我们使用组合恒等式$\\frac{m}{m+1}\\binom{k-1}{m} = \\frac{1}{k}\\binom{k}{m+1}$。求和变为：\n$$p_{misboot} = \\sum_{m=1}^{k-1} \\frac{1}{k}\\binom{k}{m+1} p_{coll}^m (1-p_{coll})^{k-1-m}$$\n令$j = m+1$。求和变换为：\n$$p_{misboot} = \\frac{1}{k} \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j-1} (1-p_{coll})^{k-j} = \\frac{1}{k \\cdot p_{coll}} \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j} (1-p_{coll})^{k-j}$$\n根据二项式定理，我们知道$\\sum_{j=0}^{k} \\binom{k}{j} p_{coll}^j (1-p_{coll})^{k-j} = 1$。从$j=2$到$k$的和是这个总和减去$j=0$和$j=1$的项：\n$$ \\sum_{j=2}^{k} \\binom{k}{j} p_{coll}^{j} (1-p_{coll})^{k-j} = 1 - \\binom{k}{0}p_{coll}^0(1-p_{coll})^k - \\binom{k}{1}p_{coll}^1(1-p_{coll})^{k-1} $$\n$$ = 1 - (1-p_{coll})^k - k \\cdot p_{coll} (1-p_{coll})^{k-1} $$\n将此代回，得到安全措施下错误引导概率的闭式表达式：\n$$p_{misboot} = \\frac{1}{k \\cdot p_{coll}} \\left[ 1 - (1-p_{coll})^k - k \\cdot p_{coll} (1-p_{coll})^{k-1} \\right]$$\n其中$p_{coll} = 2^{-128G}$。\n\n对$k=3$和$G=2$进行数值计算：\n对于这些值，碰撞概率为$p_{coll} = 2^{-128 \\times 2} = 2^{-256}$。\n我们将$k=3$代入推导出的表达式：\n$$p_{misboot} = \\frac{1}{3 \\cdot p_{coll}} \\left[ 1 - (1-p_{coll})^3 - 3 \\cdot p_{coll} (1-p_{coll})^2 \\right]$$\n展开方括号中的项：\n$$ 1 - (1 - 3p_{coll} + 3p_{coll}^2 - p_{coll}^3) - 3p_{coll}(1 - 2p_{coll} + p_{coll}^2) $$\n$$ = 1 - 1 + 3p_{coll} - 3p_{coll}^2 + p_{coll}^3 - (3p_{coll} - 6p_{coll}^2 + 3p_{coll}^3) $$\n$$ = 3p_{coll}^2 - 2p_{coll}^3 $$\n将此结果代回：\n$$p_{misboot} = \\frac{1}{3 \\cdot p_{coll}} (3p_{coll}^2 - 2p_{coll}^3) = p_{coll} - \\frac{2}{3}p_{coll}^2$$\n由于$p_{coll} = 2^{-256}$是一个极小的数，与$p_{coll}$相比，$\\frac{2}{3}p_{coll}^2$这一项可以忽略不计。因此，我们可以近似$p_{misboot} \\approx p_{coll} = 2^{-256}$。\n我们将其转换为科学记数法：\n$$ \\log_{10}(p_{misboot}) \\approx \\log_{10}(2^{-256}) = -256 \\log_{10}(2) \\approx -256 \\times 0.30103 \\approx -77.06368 $$\n$$ p_{misboot} \\approx 10^{-77.06368} = 10^{0.93632} \\times 10^{-78} \\approx 8.6358 \\times 10^{-78} $$\n四舍五入到四位有效数字，概率为$8.636 \\times 10^{-78}$。", "answer": "$$\\boxed{8.636 \\times 10^{-78}}$$", "id": "3634761"}]}