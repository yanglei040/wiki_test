{"hands_on_practices": [{"introduction": "要真正掌握空闲空间管理，我们首先需要理解其核心挑战之一：碎片。这个练习引导我们通过一个思想实验，来分析一个基本但广泛使用的分配算法——首次适应（First Fit）——在特定模式下的行为。通过推导在对抗性请求序列下产生的最大外部碎片，我们能深刻体会到分配策略如何直接影响内存利用率，并为设计更高效的系统打下基础。[@problem_id:3657317]", "problem": "考虑一个操作系统，它使用连续堆分配和首次适应（First Fit）策略（首次适应选择第一个足够大的空闲块来满足请求），并在释放时立即合并相邻的空闲块。系统没有进行内存紧缩，没有分配元数据开销，所有分配都按 $1$ 字节对齐。堆最初由一个大小为 $M$ 字节的单一空闲块组成。\n\n一个对手向空堆中发出 $n$ ($n \\ge 2$) 个分配请求，请求的大小交替为 $a$ 和 $b$，从 $a$ 开始。其中 $a$ 和 $b$ 是正整数，且满足 $a  b$。\n\n所有 $n$ 个请求的总大小恰好等于堆的总大小 $M$。在所有 $n$ 次分配完成后，所有大小为 $a$ 的已分配块都被释放，而所有大小为 $b$ 的已分配块保持已分配状态。\n\n请推导在释放过程之后，最大连续空闲块大小 $H$ 的解析表达式。", "solution": "在尝试解决问题之前，将首先根据指定标准对问题进行验证。\n\n### 第1步：提取已知条件\n问题陈述中提供的数据、变量和条件如下：\n- 内存分配是连续堆分配。\n- 放置策略是首次适应（First Fit）：选择足够大的最早（最低地址）的空闲块。\n- 释放操作涉及立即合并相邻的空闲块。\n- 没有内存紧缩。\n- 没有分配元数据的开销。\n- 分配按 $1$ 字节对齐。\n- 堆最初是一个大小为 $M$ 字节的单一空闲块。\n- 发出了一系列 $n$ 个分配请求。\n- 请求的大小在 $a$ 和 $b$ 之间交替，从 $a$ 开始。\n- $a$ 和 $b$ 是正整数。\n- 请求数量 $n \\geq 2$。\n- 堆的总大小 $M$ 等于所有 $n$ 个请求大小的总和。\n- 在所有 $n$ 次分配完成后，所有大小为 $a$ 的已分配块都被释放。\n- 所有大小为 $b$ 的已分配块保持已分配状态。\n- 目标是找到最大连续空闲块大小的解析表达式，记为 $H$。\n\n### 第2步：使用提取的已知条件进行验证\n对问题陈述的有效性进行评估：\n- **科学依据和客观性**：该问题基于操作系统内存管理的基本概念，特别是连续分配、放置算法（首次适应）和碎片。这些是计算机科学中公认的、正式的课题。语言精确且客观。\n- **适定性**：问题是自洽的。所有必要条件都已提供：堆的初始状态、分配算法、确切的请求序列、释放过程以及合并规则。堆大小 $M$ 被定义为恰好足够所有分配，确保分配阶段是完全确定的。问题要求一个单一的、特定的量（$H$），它是所定义过程的直接结果。约束条件 $a > 0$、$b > 0$ 和 $n \\geq 2$ 确保了这是一个非平凡的场景。问题没有欠定、过定或模棱两可之处。\n\n### 第3步：结论和行动\n该问题被认为是有效的，因为它是操作系统领域一个适定的、有科学依据的问题。将推导解决方案。\n\n### 解决方案的推导\n推导过程通过分析每个主要阶段（分配阶段和释放阶段）之后堆内存布局的状态来进行。\n\n**1. 分配阶段和内存布局**\n\n堆开始时是一个从地址 $0$ 开始、大小为 $M$ 的单一空闲块。分配策略是首次适应。请求的块大小交替变化，从 $a$ 开始。请求大小的序列是 $a, b, a, b, \\dots$。\n\n- **请求 1 (大小为 $a$)**：唯一的空闲块是整个大小为 $M$ 的堆。由于 $M$ 是所有 $n$ 个请求的总和，所以 $M \\geq a$。首次适应在堆的起始位置（地址 $0$）分配一个大小为 $a$ 的块。堆的状态变为：一个大小为 $a$ 的已分配块，后面跟着一个大小为 $M-a$ 的单一空闲块。\n\n- **请求 2 (大小为 $b$)**：唯一的空闲块是那个从地址 $a$ 开始、大小为 $M-a$ 的块。由于 $M-a$ 足以容纳剩余的 $n-1$ 个请求，所以它对于大小为 $b$ 的请求是足够大的。首次适应紧接着第一个块分配一个大小为 $b$ 的块。堆的状态变为：一个大小为 $a$ 的已分配块，一个大小为 $b$ 的已分配块，以及一个大小为 $M-a-b$ 的新空闲块。\n\n这个过程对所有 $n$ 个请求持续进行。在每一步 $k$（对于 $1 \\leq k \\leq n$），只有一个可用的空闲块，位于先前已分配块的末尾。首次适应算法别无选择，只能将新块放置在这个单一的空闲块中。因此，这 $n$ 个块从内存的起始位置开始被连续分配。\n\n由于所有请求块的总大小恰好为 $M$，在第 $n$ 次分配后，堆中没有剩余的空闲空间。最终的内存布局由 $n$ 个相邻的块组成。它们大小的序列正是请求的序列：$a, b, a, b, \\dots$。\n\n设 $P_i$ 是第 $i$ 个分配的块。如果 $i$ 是奇数，则 $P_i$ 的大小为 $a$；如果 $i$ 是偶数，则大小为 $b$。最终布局为：\n$[P_1(\\text{大小 } a)][P_2(\\text{大小 } b)][P_3(\\text{大小 } a)][P_4(\\text{大小 } b)] \\cdots [P_n]$\n\n**2. 释放和合并阶段**\n\n紧接着分配阶段，所有大小为 $a$ 的块都被释放。这些是索引 $i$ 为奇数的块 $P_i$。大小为 $b$ 的块（索引 $i$ 为偶数）保持已分配状态。\n\n我们来分析合并规则：“释放时立即合并相邻的空闲块”。当一个块被释放时，系统会检查它的直接邻居（较低地址和较高地址）。如果邻居也是一个空闲块，它们就会被合并。\n\n考虑一个正在被释放的大小为 $a$ 的任意块 $P_i$。由于其索引 $i$ 必须是奇数：\n- 它的左邻居是 $P_{i-1}$。因为 $i$ 是奇数且 $i \\geq 1$，所以 $i-1$ 是偶数。如果 $i > 1$，块 $P_{i-1}$ 的大小为 $b$ 并且保持已分配状态。如果 $i=1$，则没有左邻居（这是堆的起始位置）。\n- 它的右邻居是 $P_{i+1}$。因为 $i$ 是奇数，所以 $i+1$ 是偶数。如果 $i  n$，块 $P_{i+1}$ 的大小为 $b$ 并且也保持已分配状态。\n\n在这两种情况下，被释放块 $P_i$ 的邻居（如果存在）都是大小为 $b$ 的已分配块。因此，没有相邻的空闲块可以合并。无论 $a$ 和 $b$ 的相对大小如何，这个逻辑都成立。\n\n这个分析涵盖了所有内部块。我们还必须检查堆的边界。\n- 第一个块 $P_1$（大小为 $a$）被释放。它没有左邻居。它的右邻居是 $P_2$（大小为 $b$），它保持已分配状态。没有合并发生。\n- 如果 $n$ 是奇数，最后一个块 $P_n$（大小为 $a$）被释放。它没有右邻居。它的左邻居是 $P_{n-1}$（大小为 $b$），它保持已分配状态。没有合并发生。\n\n由于没有合并发生，最终的堆由大小为 $b$ 的已分配块和大小为 $a$ 的空闲块（空洞）交替组成。\n- 如果 $n$ 是偶数，布局为：$[空闲(a)][已分配(b)][空闲(a)][已分配(b)] \\cdots [空闲(a)][已分配(b)]$\n- 如果 $n$ 是奇数，布局为：$[空闲(a)][已分配(b)][空闲(a)] \\cdots [已分配(b)][空闲(a)]$\n\n在任何情况下，所有的空闲块都是不连续的，并且每个空闲块的大小都恰好为 $a$。因此，最大连续空闲块的大小 $H$ 就是 $a$。\n\n$$ H = a $$", "answer": "$$\n\\boxed{a}\n$$", "id": "3657317"}, {"introduction": "在现实世界的多线程操作系统中，多个进程或线程可能同时请求内存，这引入了并发问题。本练习聚焦于一个经典的并发陷阱——“检查时-使用时”（Time-of-Check to Time-of-Use, TOCTOU）竞争条件。你将不仅需要设计一种使用原子操作的无锁（lock-free）方案来确保分配的正确性，还需要运用概率模型来量化在高并发场景下分配失败的风险，从而将理论与实践紧密结合。[@problem_id:3624135]", "problem": "操作系统中的一个存储分配器使用位向量（位图）进行空闲空间管理。每个位标记一个块：位值为 $0$ 表示空闲块，位值为 $1$ 表示已分配块。位图被组织成机器字，每字 $b$ 位；在该系统中，$b = 64$。一个线程扫描位图，以寻找从索引 $i$ 开始的 $L_s = 96$ 个连续的空闲位。这段连续空间跨越 $W = 2$ 个 $64$-位字。由于检查时到使用时（time-of-check to time-of-use）的竞争，当线程验证该段空间为空闲后，在第一个线程更新位图之前，另一个线程可能会在这些字内进行分配。\n\nA 部分（概念性问题）。假设标准的原子原语可用，包括比较并交换（Compare-And-Swap, CAS），请为扫描线程提出一个无锁验证步骤，以确保其在声明占用该段空间时的正确性。解释导致验证失败的条件，以及线程在失败时应该怎么做。\n\nB 部分（计算性问题）。量化第一次尝试时验证失败的概率 $\\phi$。假设存在以下现实场景和随机模型：\n- 位图有 $N = 2^{20}$ 位。\n- 其他线程并发地执行分配尝试，这被建模为一个齐次泊松过程。共有 $T = 16$ 个这样的线程，每个线程以每秒 $r = 50{,}000$ 次尝试的速率发起分配尝试。\n- 其他线程的每次分配尝试都针对一段 $L_a = 64$ 位的连续空间，其起始位置在位图所有有效的起始位置中均匀随机选择。假设边界效应可以忽略不计，因为扫描线程找到的连续空间远离位图边缘。\n- 扫描线程最后一次读取这两个字与它对这些字发起第一次 CAS 尝试之间的时间风险窗口为 $\\Delta = 8 \\,\\mu\\mathrm{s}$。\n- 假设在这个短暂的窗口期内，几乎所有并发尝试都会成功，因此只需将任何重叠的尝试视为导致修改，从而改变了两个字中至少一个字的值。\n\n在这些假设下，从第一性原理推导 $\\phi$。将你最终的 $\\phi$ 的十进制答案四舍五入到四位有效数字。不要使用百分号；将 $\\phi$ 表示为一个无单位的纯小数。", "solution": "该问题被评估为具有科学依据、问题明确、客观且内部一致。提供了唯一解所需的所有数据。该场景描述了操作系统中一个经典的检查时到使用时（TOCTOU）竞争条件，而使用原子原语和随机模型对其进行分析的要求是计算机系统工程中一个有效且标准的练习。\n\nA 部分：无锁验证\n核心问题是扫描线程检查空闲空间与其后续使用（分配）该空间之间存在竞争条件。在扫描线程的读操作和写操作之间的时间间隔内，一个并发线程可能会修改位图字的状态。为在不使用传统锁的情况下解决此问题，扫描线程必须在提交自己的更新之前，原子地验证状态未发生改变。比较并交换（CAS）原子原语是实现此目的的理想选择。\n\n为扫描线程提出的无锁验证和更新过程如下：\n1.  线程扫描位图，并识别出一段候选的 $L_s = 96$ 个连续空闲位。这段空间跨越 $W=2$ 个字，我们将其分别表示为 $word_1$ 和 $word_2$，其内存地址分别为 $addr_1$ 和 $addr_2$。\n2.  线程读取这两个字的当前值，我们称之为 $old\\_val_1$ 和 $old\\_val_2$。它确认这些值确实代表了所需的连续空闲位块。\n3.  线程计算出分配这 $96$ 位空间后产生的新值 $new\\_val_1$ 和 $new\\_val_2$。这涉及到将相应的 $96$ 位从 $0$ 变为 $1$。\n4.  为声明占用该空间，线程执行两次连续的 CAS 操作。双字 CAS（DCAS）是理想的，因为它能使两个字的更新原子化，但假设只有单字 CAS 可用，则操作序列将是：\n    - `success_1 = CAS(addr_1, old_val_1, new_val_1)`\n    - `success_2 = CAS(addr_2, old_val_2, new_val_2)`\n\n验证步骤隐含在 CAS 操作中。`CAS(address, expected, new)` 操作仅当 `address` 处的当前值与 `expected` 相同时才会成功。\n\n如果 `success_1` 为 false 或 `success_2` 为 false，则验证失败。这种情况发生的确切条件是：在扫描线程读取了初始值（$old\\_val_1$ 和 $old\\_val_2$）之后，某个并发线程修改了 $word_1$ 或 $word_2$（或两者）。内存位置上的值不再与期望值匹配，因此 CAS 操作失败，从而正确地指示状态已改变，并防止了错误的分配。\n\n失败后，线程必须采取纠正措施。如果第一个 CAS 失败，状态未改变，线程可以简单地重新开始扫描以寻找新的空闲块。如果第一个 CAS 成功但第二个失败，位图将处于一个中间状态，其中一个字已更新而另一个未更新。尝试通过写回 $old\\_val_1$ 来“回滚”第一个 CAS 是不安全的，因为它可能会覆盖在此期间另一个线程所做的不同的、合法的分配。最稳健且最简单的恢复策略是接受部分分配尝试已失败，且资源可能被浪费。线程应完全中止当前尝试，并**从头开始**或从一个新位置重新扫描，以寻找另一个空闲的连续空间。部分声明的空间通常由系统级垃圾回收处理，或者通过设计分配器来避免关键分配跨越字边界。\n\nB 部分：失败概率\n我们被要求量化验证失败的概率 $\\phi$。如果在风险窗口 $\\Delta$ 期间，两个目标字中至少有一个被并发线程修改，则会发生此失败。\n\n并发分配尝试被建模为一个齐次泊松过程。总尝试率是并发线程数 $T$ 与每个线程的速率 $r$ 的乘积。\n$$ \\lambda_{\\text{total}} = T \\times r $$\n代入给定值，$T=16$ 和 $r=50{,}000 \\, \\text{s}^{-1}$：\n$$ \\lambda_{\\text{total}} = 16 \\times 50{,}000 \\, \\text{s}^{-1} = 800{,}000 \\, \\text{s}^{-1} = 8 \\times 10^{5} \\, \\text{s}^{-1} $$\n接下来，我们确定单次由其他线程发起的随机分配尝试与我们的目标区域冲突的概率 $P_{\\text{conflict}}$。我们的目标区域跨越 $W=2$ 个字，覆盖 $2 \\times b = 2 \\times 64 = 128$ 位。一次并发分配是针对一段 $L_a = 64$ 位的连续空间。其起始位置在大小为 $N = 2^{20}$ 位的位图的所有有效起始位置中均匀随机选择。\n\n长度为 $L_a$ 的分配的有效起始位置数为 $N_{\\text{pos}} = N - L_a + 1$。\n如果并发分配的 $L_a$ 位范围与我们的 $2b$ 位目标范围重叠，则发生冲突。设目标范围为一个长度为 $2b$ 的区间。一个从给定位置开始的长度为 $L_a$ 的分配，如果其区间与目标区间重叠，则会发生冲突。此类冲突起始位置的数量由两个区间的长度之和减一给出。\n$$ N_{\\text{conflict}} = (2b) + L_a - 1 $$\n当 $b=64$ 且 $L_a=64$ 时：\n$$ N_{\\text{conflict}} = 2 \\times 64 + 64 - 1 = 128 + 64 - 1 = 191 $$\n单次尝试导致冲突的概率是冲突起始位置数与总可能起始位置数的比值：\n$$ P_{\\text{conflict}} = \\frac{N_{\\text{conflict}}}{N_{\\text{pos}}} = \\frac{2b + L_a - 1}{N - L_a + 1} $$\n代入数值：\n$$ P_{\\text{conflict}} = \\frac{191}{2^{20} - 64 + 1} = \\frac{191}{1,048,576 - 63} = \\frac{191}{1,048,513} $$\n\n*冲突*分配尝试的速率 $\\lambda_{\\text{conflict}}$ 是总尝试率乘以冲突概率：\n$$ \\lambda_{\\text{conflict}} = \\lambda_{\\text{total}} \\times P_{\\text{conflict}} = (T \\times r) \\times \\frac{2b + L_a - 1}{N - L_a + 1} $$\n$$ \\lambda_{\\text{conflict}} = 8 \\times 10^5 \\, \\text{s}^{-1} \\times \\frac{191}{1,048,513} \\approx 145.73 \\, \\text{s}^{-1} $$\n\n在风险窗口 $\\Delta = 8 \\,\\mu\\mathrm{s} = 8 \\times 10^{-6} \\, \\mathrm{s}$ 内，冲突事件的数量 $k$ 服从泊松分布 $P(k) = \\frac{\\mu^k e^{-\\mu}}{k!}$。在此区间内事件的平均数 $\\mu$ 为：\n$$ \\mu = \\lambda_{\\text{conflict}} \\times \\Delta $$\n$$ \\mu = \\left( (T \\times r) \\frac{2b + L_a - 1}{N - L_a + 1} \\right) \\Delta $$\n代入数值：\n$$ \\mu = \\left( 8 \\times 10^5 \\times \\frac{191}{1,048,513} \\right) \\times 8 \\times 10^{-6} $$\n$$ \\mu = 6.4 \\times \\frac{191}{1,048,513} = \\frac{1222.4}{1,048,513} \\approx 0.001165839 $$\n\n如果在窗口 $\\Delta$ 内至少发生一次冲突事件，验证就会失败。这个概率 $\\phi$ 是 $P(k \\ge 1)$。\n$$ \\phi = P(k \\ge 1) = 1 - P(k=0) $$\n对于泊松分布，$P(k=0) = \\frac{\\mu^0 e^{-\\mu}}{0!} = e^{-\\mu}$。\n$$ \\phi = 1 - e^{-\\mu} = 1 - \\exp(-\\mu) $$\n代入 $\\mu$ 的值：\n$$ \\phi = 1 - \\exp(-0.001165839) $$\n$$ \\phi \\approx 1 - 0.998834834 = 0.001165166 $$\n将结果四舍五入到四位有效数字，我们得到：\n$$ \\phi \\approx 0.001165 $$\n用科学记数法表示，即为 $1.165 \\times 10^{-3}$。", "answer": "$$\\boxed{1.165 \\times 10^{-3}}$$", "id": "3624135"}, {"introduction": "当管理的存储空间达到海量规模时（例如，数百万个块），简单的线性扫描位图将变得非常低效。为了加速查找，现代系统采用了如 Fenwick 树或段树（segment tree）等高级数据结构。这个练习将你置于系统性能分析师的角色，要求你对这两种数据结构在执行关键的“查找第 $k$ 个空闲块”操作时的性能进行建模和比较。通过计算预期的查询延迟，你将学会如何基于底层硬件特性和算法复杂度来做出明智的技术选型。[@problem_id:3645638]", "problem": "一个文件系统的空闲空间管理器维护着一个包含 $N$ 个块的位图，其中位值为 $1$ 表示块空闲，位值为 $0$ 表示块已分配。该分配器支持“查找第$k$个空闲块”的查询：给定一个整数 $k \\geq 1$，返回按前缀顺序排列的第 $k$ 个空闲位所对应的块的索引（从零开始）。考虑使用两种数据结构来支持动态更新和高效查询：\n\n- Fenwick 树（二叉索引树），一种基于数组的结构，它在位图上维护前缀和，以支持在 $O(\\log N)$ 时间内完成更新和前缀和查询。\n- 线段树，同样是基于数组的（不使用指针节点），它在不相交的区间上维护子树和，以支持在 $O(\\log N)$ 时间内完成更新和区间和查询。\n\n假设位图大小为 $N = 2^{20}$，系统每秒处理 $10^{6}$ 次更新，这些更新均匀随机地分布在位图的各个位置上，每次更新会翻转单个位，并相应地维护所选树的计数值。在这些条件下，按如下方式对“查找第$k$个空闲块”查询的内存访问行为进行建模：\n\n- 由于更新是均匀随机的，且相对于树的大小而言非常频繁，因此假设在“查找第$k$个空闲块”查询期间的访问在私有缓存中具有可忽略的时间局部性，并且每次读取树数组元素会产生 $t_{r} = 75\\,\\mathrm{ns}$ 的平均读取延迟。\n- 在此模型中，与内存延迟相比，算术和索引计算的开销可以忽略不计。\n\n仅从“两种结构都实现了前缀和，并通过比较累积计数来支持自顶向下的选择”这一核心定义出发，推理出在 $N = 2^{20}$ 时，对于每种结构，完成单次“查找第$k$个空闲块”查询所需的数组元素读取次数。然后，使用上述延迟模型，确定哪种结构能为该查询带来更低的预测平均延迟，并以微秒为单位计算该延迟。\n\n以微秒表示最终延迟，并将答案四舍五入到三位有效数字。最终的方框答案中不要包含单位；单位只应出现在您的推理和结论文本中。", "solution": "该问题陈述是有效的，因为它在计算机科学领域，特别是在算法分析方面，具有科学依据，并且问题定义良好、客观且自洽。所提供的参数对于性能建模场景是符合实际的。任务是在指定的内存延迟模型下，通过比较 Fenwick 树和线段树这两种数据结构，确定在大小为 $N=2^{20}$ 的位图上执行“查找第$k$个空闲块”查询的更低平均延迟。该查询旨在寻找被标记为空闲（由位值 $1$ 表示）的第 $k$ 个块的从零开始的索引。\n\n分析的核心在于确定每种数据结构执行此查询所需的内存访问（数组元素读取）次数，因为问题陈述指出，算术成本可以忽略不计，且每次读取都会产生 $t_r = 75\\,\\mathrm{ns}$ 的延迟。\n\n设 $N = 2^{20}$。一个基于这 $N$ 个元素的平衡二叉树结构的高度为 $h = \\log_2(N) = \\log_2(2^{20}) = 20$。\n\n首先，我们分析线段树。一个建立在大小为 $N=2^{20}$ 的数组上的、基于数组的线段树，可以存储在一个大小为 $2N$ 的数组中。树的根节点位于索引 $1$ 处，代表整个位图的和。对于位于索引 $p$ 的任何内部节点，其左、右子节点分别位于索引 $2p$ 和 $2p+1$ 处。树的叶节点对应于位图中的各个块。\n\n“查找第$k$个空闲块”查询，也称为选择查询，在线段树上很自然地实现为从根节点开始的自顶向下遍历。算法流程如下：\n1. 从根节点（索引 $p=1$）开始。\n2. 在任意内部节点 $p$ 处，读取其左子节点（假设位于索引 $2p$）中存储的值。这个值 $c_{left}$ 是节点 $p$ 所覆盖范围的左半部分中空闲块的总数。这构成一次内存读取。\n3. 将目标排名 $k$ 与 $c_{left}$ 进行比较。\n   - 如果 $k \\leq c_{left}$，则第 $k$ 个空闲块位于左子树中。搜索通过下降到左子节点（新的 $p=2p$）继续进行，$k$ 的值保持不变。\n   - 如果 $k  c_{left}$，则第 $k$ 个空闲块位于右子树中。搜索通过下降到右子节点（新的 $p=2p+1$）继续进行，但排名更新为 $k' = k - c_{left}$，因为我们现在要在右半部分寻找第 $(k-c_{left})$ 个空闲块。\n4. 重复此过程，直到到达一个叶节点。该叶节点对应的索引即为查询结果。\n\n在高度为 $h$ 的线段树中，从根到叶的遍历路径包含 $h$ 步。在 $h=\\log_2(N)$ 个内部节点层级的每一层，都需要进行恰好一次内存读取（以获取左子节点的计数值），来决定是向左走还是向右走。因此，一次查询的总读取次数为：\n$$R_{seg} = \\log_2(N)$$\n对于 $N=2^{20}$，计算得出 $R_{seg} = 20$ 次读取。\n\n接下来，我们分析 Fenwick 树（或称二叉索引树，BIT）。问题陈述指出，我们应从“核心定义”出发，即 Fenwick 树高效地“实现前缀和”。Fenwick 树的典型操作是点更新和前缀和查询，两者都耗时 $O(\\log N)$。“查找第$k$个空闲块”查询不是一个基本操作。一种仅使用前缀和功能来实现此查询的直接方法是在索引范围 $[0, N-1]$ 上执行二分搜索。\n\n用于查找最小索引 $i$（使得截至 $i$ 的空闲块前缀和至少为 $k$）的二分搜索算法工作原理如下：\n1. 搜索空间是从 $0$ 到 $N-1$ 的索引集合。二分搜索将执行 $\\log_2(N)$ 次迭代。\n2. 在每次迭代中，选择一个中间索引 $m$。执行一次前缀和查询 `prefix_sum(m)`，以找出截至索引 $m$ 的空闲块数量。\n3. 在 Fenwick 树上，这次前缀和查询在最坏情况下需要对多达 $\\log_2(N)$ 个不同数组元素的值求和。每次访问都是一次内存读取。因此，单次前缀和查询的成本为 $\\log_2(N)$ 次读取。\n4. 将 `prefix_sum(m)` 的结果与 $k$ 进行比较以缩小搜索空间，然后继续二分搜索。\n\n该方法的总内存读取次数为二分搜索的步数乘以每步的读取次数：\n$$R_{fen} = (\\log_2(N)) \\times (\\text{每次前缀和的读取次数}) = (\\log_2(N)) \\times (\\log_2(N)) = (\\log_2(N))^2$$\n虽然存在一种更为优化的、时间复杂度为 $O(\\log N)$ 的 Fenwick 树选择算法，但它依赖于对该树内部索引映射的详细理解，这可以说是超出了问题措辞中所暗示的、仅将该结构用作简单前缀和预言机（oracle）的范畴。$(\\log_2(N))^2$ 的方法是将核心前缀和功能与标准搜索算法相结合的直接结果。\n\n对于 $N = 2^{20}$，读取次数为 $R_{fen} = (20)^2 = 400$ 次读取。\n\n现在，我们比较这两种结构。\n- 线段树读取次数：$R_{seg} = 20$\n- Fenwick 树读取次数：$R_{fen} = 400$\n\n显然，$R_{seg}  R_{fen}$。线段树提供了效率显著更高的查询实现，从而带来更低的预测平均延迟。\n\n我们使用给定的值 $t_r = 75\\,\\mathrm{ns}$ 来计算这个更低的延迟：\n$$L_{min} = L_{seg} = R_{seg} \\times t_r = 20 \\times 75\\,\\mathrm{ns} = 1500\\,\\mathrm{ns}$$\n问题要求答案以微秒（$\\mathrm{\\mu s}$）为单位，并四舍五入到三位有效数字。\n$$1500\\,\\mathrm{ns} = 1.500 \\times 10^3\\,\\mathrm{ns} = 1.500\\,\\mathrm{\\mu s}$$\n四舍五入到三位有效数字，延迟为 $1.50\\,\\mathrm{\\mu s}$。", "answer": "$$ \\boxed{1.50} $$", "id": "3645638"}]}