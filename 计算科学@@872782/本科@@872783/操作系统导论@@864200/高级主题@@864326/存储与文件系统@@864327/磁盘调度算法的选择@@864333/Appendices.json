{"hands_on_practices": [{"introduction": "这个练习清晰地揭示了 SCAN 和 LOOK 算法之间的根本区别。通过引入一个对跨越会产生惩罚的“墙”的概念，我们可以具体地量化 SCAN 盲目扫描到磁盘边缘所带来的成本，并与 LOOK 在处理完最后一个请求后就智能地反向移动的策略进行对比。这项实践将磨练你追踪算法执行过程的能力，并学会根据寻道距离来量化性能。[@problem_id:3681088]", "problem": "一个存储系统提供了一个磁盘，其连续的磁道编号从 $0$ 到 $199$。磁头臂的寻道时间被建模为与磁道距离成正比：如果磁头从磁道 $c_a$ 移动到 $c_b$，寻道成本与 $\\lvert c_b - c_a \\rvert$ 成正比。此外，有两个磁道范围被标记为介质缺陷簇：$[60,79]$ 和 $[140,149]$。一个可靠性策略将每个缺陷簇视为一堵无法无缝扫过的墙；穿过一堵墙需要一次重新校准的跳转，其成本被建模为一个额外的固定惩罚，等同于移动 $W$ 个磁道的距离，其中 $W = 20$。缺陷范围内的请求永远不会被排队，而范围外的请求可以按照与调度算法一致的任何顺序被服务。\n\n你必须选择一个能够感知墙的调度策略并分析其行为。考虑两种为适应墙的存在而调整的策略：\n\n- 感知墙的无回溯SCAN (WB-SCAN)：从当前的磁头位置和方向开始，磁头单调扫描，按磁道递增或递减的顺序服务请求。它会继续向该方向扫描，直到最近的物理边界（磁盘末端或墙的近侧）。当到达一堵墙时，它支付穿越惩罚 $W$ 以跳转到远侧边界，并继续沿相同方向扫描。它只在物理边界（磁盘末端）处反转方向，而不会在墙前的最后一个请求处反转，即使在该方向上边界之前没有剩余请求。\n\n- 感知墙的LOOK (WB-LOOK)：从当前的磁头位置和方向开始，磁头单调扫描，但在到达任何边界（墙或磁盘末端）之前，在当前方向上最后一个未完成请求处立即反转方向，从而避免不必要的边界移动。它仅当当前扫描方向上该墙之后至少有一个未完成请求时才会穿过一堵墙；穿过墙会产生惩罚 $W$，并且需要先移动到墙的近侧边界再穿越。\n\n假设磁头初始位于磁道 $c_0 = 50$，并向磁道号增加的方向移动。待处理请求集为 $R = \\{20, 30, 58, 85, 132, 155, 170, 190\\}$，所有这些请求都在缺陷范围之外。与寻道成本和穿墙惩罚相比，旋转延迟和传输时间可以忽略不计。系统的目标是最小化服务所有待处理请求一次所需的总移动量（寻道距离加上穿墙惩罚）。\n\n哪个选项最好地阐述了将缺陷簇视为墙的原则性选择标准，并正确分析了在给定实例上 WB-LOOK 相对于无回溯的 WB-SCAN 如何导航这些墙，包括最终的总移动量？\n\nA. 当墙附近的请求密度稀疏或 $W$ 相对于典型的请求间距离较大时，应优先选择 WB-LOOK，因为它在墙前的最后一个请求处反转方向，避免了不必要的边界移动和冗余的穿墙操作。对于给定的 $c_0$、$R$ 和墙，WB-LOOK 在磁道 $58$ 处反转方向，服务 $30$ 和 $20$，然后向上穿过第一堵墙一次和第二堵墙一次，从不无需求地移动到磁盘末端。其总移动量为 $224$，而 WB-SCAN 需要扫描到边界，并穿越两堵墙两次，同时也会移动到两个磁盘末端，总移动量为 $364$。\n\nB. 优先选择无回溯的 WB-SCAN，因为它消除了导致额外重新定位的反转；在有墙存在的情况下，WB-SCAN 会像 WB-LOOK 一样在墙前的最后一个请求处反转，因此两种策略在给定实例上产生相同的移动量 $224$。\n\nC. 当存在缺陷簇时，优先选择无回溯的 WB-SCAN，因为连续扫描可以最小化跳转惩罚和末端效应；在给定实例上, WB-SCAN 的总移动量为 $159$，严格小于 WB-LOOK 的 $224$。\n\nD. 仅当所有请求都位于每堵墙的同一侧时才优先选择 WB-LOOK；否则 WB-LOOK 必须遍历到物理末端以反转方向，并将像 WB-SCAN 一样穿越每堵墙两次，在给定实例上产生相同的总移动量 $364$。", "solution": "在尝试任何解决方案之前，将首先对问题陈述进行严格的验证过程。\n\n### 第 1 步：提取已知条件\n- **磁盘几何结构**：磁道编号从 $0$到 $199$。\n- **寻道成本模型**：从磁道 $c_a$ 移动到 $c_b$ 的成本与距离 $\\lvert c_b - c_a \\rvert$ 成正比。为简单起见，我们可以用移动的磁道数作为成本单位。\n- **缺陷簇（墙）**：两个范围被指定为墙：$[60, 79]$ 和 $[140, 149]$。\n- **穿墙惩罚**：穿过一堵墙会产生一个额外的固定成本，等同于移动 $W = 20$ 个磁道的距离。这是一个“重新校准的跳转”。\n- **请求处理**：对于缺陷范围内的磁道，不排队请求。\n- **初始状态**：磁盘磁头位于磁道 $c_0 = 50$，其初始移动方向是朝磁道号增加的方向（向上）。\n- **请求集**：待处理请求集为 $R = \\{20, 30, 58, 85, 132, 155, 170, 190\\}$。\n- **算法定义**：\n    - **感知墙的无回溯SCAN (WB-SCAN)**：磁头单调扫描，按顺序服务请求。它会继续向当前方向上最近的边界（磁盘末端 $0$ 或 $199$，或墙的近侧）移动，即使通向该边界的路径上没有请求。在墙处，它支付惩罚 $W$ 从近侧边界跳转到远侧边界，并继续扫描。方向反转只发生在物理磁盘末端（$0$ 和 $199$）。\n    - **感知墙的LOOK (WB-LOOK)**：磁头单调扫描，但在到达任何边界（墙或磁盘末端）之前，在当前方向上最后一个未完成请求处反转方向。它仅在当前扫描方向上墙的另一侧有未完成请求时才穿过墙。要穿过墙，必须先移动到墙的近侧边界，然后支付惩罚 $W$。\n- **目标**：最小化总移动量，定义为所有寻道距离和穿墙惩罚的总和。\n\n### 第 2 步：使用提取的已知条件进行验证\n1.  **科学依据**：该问题是操作系统中一个成熟的练习，特别是关于磁盘调度算法。引入“墙”是一个自定义约束，但它在数学上是明确定义的，并且可以作为处理存储介质上缺陷区域或其他物理不连续性的合理抽象。该问题在计算机科学原理上有科学依据。\n2.  **适定性**：算法的描述是确定性的。对于给定的初始状态和请求集，磁头移动序列和总成本是唯一确定的。该问题是适定的。\n3.  **客观性**：问题陈述使用了精确、客观的语言。\n4.  **完整性和一致性**：所提供的数据（初始位置、请求集、墙的位置、惩罚成本）是充分且一致的。算法的定义虽然密集，但却是自洽的。WB-LOOK 的定义，“在到达任何边界之前，在当前方向上最后一个未完成请求处立即反转”，略有歧义。它可能意味着墙前一个*分区*中的最后一个请求，也可能意味着在给定方向上*整个磁盘*上的最后一个请求。然而，这种歧义可以通过分析所提供的选项来解决，这些选项在此类问题中通常会澄清预期的解释。问题的结构意味着单一、正确的分析是可能的。\n\n### 第 3 步：结论与行动\n问题陈述是**有效的**。定义和约束足以推导出唯一解。我们可以继续进行分析。\n\n### 推导与分析\n\n我们将根据提供的定义分析两种算法的总移动量。为了分析，磁盘被墙划分为三个服务区域：$S_1 = [0, 59]$，$S_2 = [80, 139]$ 和 $S_3 = [150, 199]$。请求集也相应地被划分：$R_1 = \\{20, 30, 58\\}$，$R_2 = \\{85, 132\\}$ 和 $R_3 = \\{155, 170, 190\\}$。\n\n#### WB-SCAN 分析\n\nWB-SCAN 算法从磁盘的一端扫描到另一端，只在物理边界处反转方向。\n\n1.  **初始状态**：磁头位于 $c_0 = 50$，向 $199$ 移动。\n2.  **向上扫描 ($50 \\to 199$)**：\n    - 从 $50$ 移动到服务位于 $58$ 的请求。移动量：$|58 - 50| = 8$。\n    - 算法必须前进到第一堵墙（$[60, 79]$）的边界，即磁道 $59$。移动量：$|59 - 58| = 1$。\n    - 在 $59$ 处，穿过墙。成本：$W = 20$。磁头跳转到远侧，磁道 $80$。\n    - 继续扫描，服务位于 $85$ 和 $132$ 的请求。移动量：$|132 - 80| = 52$。\n    - 前进到第二堵墙（$[140, 149]$）的边界，即磁道 $139$。移动量：$|139 - 132| = 7$。\n    - 在 $139$ 处，穿过墙。成本：$W = 20$。磁头跳转到远侧，磁道 $150$。\n    - 继续扫描，服务位于 $155, 170, 190$ 的请求。移动量：$|190 - 150| = 40$。\n    - 前进到物理磁盘末端。移动量：$|199 - 190| = 9$。\n    - 向上扫描的总成本：$8 + 1 + 20 + 52 + 7 + 20 + 40 + 9 = 157$。\n3.  **向下扫描 ($199 \\to 0$)**：\n    - 磁头在 $199$ 处反转方向，并向 $0$ 移动。\n    - 前进到第二堵墙的边界（近侧是 $150$）。移动量：$|150 - 199| = 49$。\n    - 穿过墙。成本：$W = 20$。磁头跳转到 $139$。\n    - 前进到第一堵墙的边界（近侧是 $80$）。移动量：$|80 - 139| = 59$。\n    - 穿过墙。成本：$W = 20$。磁头跳转到 $59$。\n    - 继续扫描，服务位于 $30$ 和 $20$ 的请求。移动量：$|20 - 59| = 39$。\n    - 前进到物理磁盘末端。移动量：$|0 - 20| = 20$。\n    - 向下扫描的总成本：$49 + 20 + 59 + 20 + 39 + 20 = 207$。\n4.  **WB-SCAN 总移动量**：由于请求只服务一次，我们只需计算服务完所有请求所需的移动。向上扫描已经服务了 $\\{58, 85, 132, 155, 170, 190\\}$。向下扫描需要服务 $\\{30, 20\\}$。因此，总成本是向上扫描到 $199$ 然后向下扫描到 $20$。\n    $$ \\text{Total Cost} = \\underbrace{(157)}_{\\text{Up sweep}} + \\underbrace{(|150-199| + 20 + |80-139| + 20 + |20-59|)}_{\\text{Down sweep to last request}} = 157 + 49 + 20 + 59 + 20 + 39 = 344 $$\n    等一下，WB-SCAN的定义是它只在物理边界反转。所以它会从199一直扫描到0。所以总的寻道距离是两个完整的扫描。\n    向上扫描：$(199-50) + 2W = 149 + 40 = 189$。服务了所有向上的请求。\n    向下扫描：$(199-0) + 2W = 199 + 40 = 239$。服务了所有向下的请求。\n    总距离: $(199-50) + (199-0) + 2*2*W = 149 + 199 + 80 = 428$。这个计算方法不对。\n    让我们回到逐段计算。\n    向上扫描服务 $\\{58, 85, 132, 155, 170, 190\\}$。成本：$(58-50) + (132-58) + (190-132) + 2*W = 8 + 74 + 58 + 40 = 180$。这是错误的，因为SSTF的路径不是SCAN。\n    我们必须严格按照算法定义。\n    WB-SCAN Path: 50 -> 58 -> 59 ->(Jump to 80)-> 85 -> 132 -> 139 ->(Jump to 150)-> 155 -> 170 -> 190 -> 199.\n    Total Upward Seek: $(58-50) + (59-58) + (85-80) + (132-85) + (139-132) + (155-150) + (170-155) + (190-170) + (199-190) = 8+1+5+47+7+5+15+20+9 = 117$.\n    Total Upward Cost = $117 + 2W = 117+40 = 157$.\n    Reverse at 199.\n    Downward Path: 199 -> 150 ->(Jump to 139)-> 80 ->(Jump to 59)-> 30 -> 20 -> 0.\n    Total Downward Seek: $(199-150) + (139-80) + (59-30) + (30-20) + (20-0) = 49+59+29+10+20=167$.\n    Total Downward Cost = $167 + 2W = 167+40 = 207$.\n    Total WB-SCAN Cost = $157+207 = 364$.\n    这个分析是正确的。\n\n#### WB-LOOK 分析\n\nWB-LOOK 算法在给定方向上的最后一个请求处反转，避免移动到没有待处理请求的边界。\n\n1.  **初始状态**：磁头位于 $c_0 = 50$，向 $199$ 移动。\n2.  **初始向上移动**：\n    - 向上扫描，服务 $58$。移动量：$|58 - 50| = 8$。\n    - 位于 $58$ 的请求是第一堵墙前的最后一个请求。检查是否有向下的请求。有 ($\\{20, 30\\}$)。因此，它在 $58$ 处反转。\n3.  **第一次向下扫描**：\n    - 磁头位于 $58$，向 $0$ 移动。\n    - 它服务位于 $30$ 和 $20$ 的请求。移动量：$|20 - 58| = 38$。\n    - 位于 $20$ 的请求是这个方向的最后一个。所有其他待处理请求都在“向上”方向。磁头在 $20$ 处反转方向。\n4.  **最后一次向上扫描**：\n    - 磁头位于 $20$，向 $199$ 移动。\n    - 它必须移动到第一堵墙的边界 $59$。移动量：$|59 - 20| = 39$。\n    - 穿过墙。成本：$W = 20$。磁头跳转到 $80$。\n    - 向上扫描，服务 $85$ 和 $132$。移动量：$|132 - 80| = 52$。\n    - 它必须移动到第二堵墙的边界 $139$。移动量：$|139 - 132| = 7$。\n    - 穿过墙。成本：$W = 20$。磁头跳转到 $150$。\n    - 继续扫描，服务 $155, 170, 190$。移动量：$|190 - 150| = 40$。\n    - 位于 $190$ 的请求是最后一个请求。算法终止。\n5.  **WB-LOOK 总移动量**：\n    $$ \\text{Total Cost} = \\underbrace{8}_{\\text{50→58}} + \\underbrace{38}_{\\text{58→20}} + \\underbrace{39}_{\\text{20→59}} + \\underbrace{20}_{\\text{W}} + \\underbrace{52}_{\\text{80→132}} + \\underbrace{7}_{\\text{132→139}} + \\underbrace{20}_{\\text{W}} + \\underbrace{40}_{\\text{150→190}} = 224 $$\n这与解决方案中的推导一致。\n\n### 逐项分析选项\n\n**A. 当墙附近的请求密度稀疏或 $W$ 相对于典型的请求间距离较大时，应优先选择 WB-LOOK，因为它在墙前的最后一个请求处反转方向，避免了不必要的边界移动和冗余的穿墙操作。对于给定的 $c_0$、$R$ 和墙，WB-LOOK 在磁道 $58$ 处反转方向，服务 $30$ 和 $20$，然后向上穿过第一堵墙一次和第二堵墙一次，从不无需求地移动到磁盘末端。其总移动量为 $224$，而 WB-SCAN 需要扫描到边界，并穿越两堵墙两次，同时也会移动到两个磁盘末端，总移动量为 $364$。**\n- 选择标准是合理的。\n- WB-LOOK 的路径描述和计算（$224$）是正确的。\n- WB-SCAN 的行为描述和计算（$364$）是正确的。它在向上扫描时穿越两堵墙，在向下扫描时又穿越两堵墙，总共四次。嗯，等一下，我的WB-SCAN向下扫描成本计算是207，其中包含2次穿墙。向上成本157也包含2次穿墙。总共4次穿墙。\n- 选项A说“穿越两堵墙两次”，这可能意味着每堵墙穿越两次，总共四次。这是对的。\n- **结论：正确。**\n\n**B. 优先选择无回溯的 WB-SCAN，因为它消除了导致额外重新定位的反转；在有墙存在的情况下，WB-SCAN 会像 WB-LOOK 一样在墙前的最后一个请求处反转，因此两种策略在给定实例上产生相同的移动量 $224$。**\n- 与定义矛盾，WB-SCAN 不会在墙前反转。\n- **结论：不正确。**\n\n**C. 当存在缺陷簇时，优先选择无回溯的 WB-SCAN，因为连续扫描可以最小化跳转惩罚和末端效应；在给定实例上, WB-SCAN 的总移动量为 $159$，严格小于 WB-LOOK 的 $224$。**\n- 逻辑和数值均错误。\n- **结论：不正确。**\n\n**D. 仅当所有请求都位于每堵墙的同一侧时才优先选择 WB-LOOK；否则 WB-LOOK 必须遍历到物理末端以反转方向，并将像 WB-SCAN 一样穿越每堵墙两次，在给定实例上产生相同的总移动量 $364$。**\n- 对 LOOK 算法的根本误解。\n- **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3681088"}, {"introduction": "LOOK 算法总是优于 SCAN 吗？这个思想实验通过引入一个包含旋转延迟的更真实的性能模型，对这一简单结论提出了挑战。你将分析一个精心构建的场景，看看 SCAN “浪费”的寻道时间有时如何能够出人意料地与磁盘旋转对齐，从而可能弥补其性能劣势。这项练习旨在教导我们考虑多重性能因素并审视简单启发式方法的重要性。[@problem_id:3681127]", "problem": "一个磁盘有 $M$ 个均匀分布的扇区每磁道，旋转周期为 $T$（旋转一整圈的时间），磁头在相邻磁道柱面之间的移动被建模为每移动一个磁道柱面花费恒定时间 $\\alpha$。盘片匀速旋转，因此在时间 $t$ 磁头下扇区的角相位是 $\\theta(t) = 2\\pi t / T \\pmod{2\\pi}$。一个请求由一个数对 $(c, s)$ 定义，其中 $c$ 是磁道柱面索引，$s$ 是扇区索引，扇区角度为 $\\theta_{r}(s) = 2\\pi s / M$。一旦磁头定位到正确的磁道柱面并且请求的扇区转到磁头下方，控制器就可以开始处理该请求。一个请求的旋转延迟是指在磁头到达目标磁道柱面后，直到 $\\theta(t)$ 等于 $\\theta_{r}(s)$ 所需的最小正时间。假设与寻道时间和旋转延迟相比，传输时间可以忽略不计。\n\n考虑以下两种磁盘调度算法：\n\n- SCAN：磁头沿一个方向（此处为磁道柱面索引增加的方向）单调移动，处理其遇到的磁道柱面上的请求。它会继续移动到磁盘末端的最后一个磁道柱面，然后才反转方向。\n- LOOK：磁头也沿一个方向单调移动，但一旦当前方向上没有更多请求，它就立即反转方向（如果没有更远的请求，它不会移动到物理末端）。\n\n考虑以下特定的轨迹和参数，这些是经过科学上合理选择的：\n\n- 每磁道扇区数 $M = 100$，旋转周期 $T = 10\\,\\mathrm{ms}$（所以角速度 $\\omega = 2\\pi/T$）。\n- 每磁道柱面寻道时间 $\\alpha = 0.10\\,\\mathrm{ms}$。\n- 磁头起始于磁道柱面 $c_0 = 100$，初始相位 $\\theta(0) = 0$，方向为磁道柱面索引增加的方向。\n- 请求（所有请求都在时间 $t=0\\,\\mathrm{ms}$ 发出）：\n  1. $(c,s) = (120, 20)$，\n  2. $(150, 50)$，\n  3. $(80, 18)$，\n  4. $(30, 68)$。\n- 在所列出的最高磁道柱面之外没有其他请求。\n\n在所述模型下，根据第一性原理回答以下问题。你可以使用以下事实：磁道柱面 $c_a$ 和 $c_b$ 之间的寻道时间是 $|c_a - c_b| \\alpha$；每移动一个磁道柱面，旋转角度增加 $2\\pi \\alpha / T$；对于一个角度为 $\\theta_{r}(s)$ 的扇区，在时钟时间 $t_a$ 到达时，其旋转延迟是使得 $\\theta(t_a + \\Delta t) = \\theta_{r}(s)$ 成立的最小正时间 $\\Delta t$。\n\n在这一标准模型（没有磁道偏斜，没有跨磁道柱面的扇区重映射）下，哪个陈述正确地描述了何时 SCAN 会纯粹因旋转角度对齐而优于 LOOK，以及所构造的轨迹展示了什么？\n\nA. SCAN 优于 LOOK 的条件是，当且仅当额外的扫描到末端的时间 $d_{\\mathrm{end}}$ 满足 $d_{\\mathrm{end}} \\pmod T $ LOOK 算法在反转后的第一个请求上会遇到的旋转延迟；该轨迹表明 SCAN 严格优于 LOOK。\n\nB. 在此标准模型下，纯粹由于旋转角度对齐，SCAN 不可能严格优于 LOOK；至多，当 $d_{\\mathrm{end}}  T$ 时，SCAN 与 LOOK 持平，因为在第一个反向请求处的旋转延迟差异等于 $d_{\\mathrm{end}} \\pmod T$。该轨迹通过对齐展示了这样一种持平情况。\n\nC. 只要 $\\alpha  T/M$，SCAN 就更优，因为更小的每磁道柱面寻道时间总能对齐相位；该轨迹表明 SCAN 具有严格优势。\n\nD. 仅当当前方向之外有许多请求时，SCAN 才变得更优，而这与旋转对齐情况无关；该轨迹展示了这种效应。", "solution": "用户需要对 SCAN 和 LOOK 磁盘调度算法进行详细分析，基于一个特定的模型和数据轨迹，以确定在什么条件下 SCAN 可能比 LOOK 更优。\n\n### 第一步：提取已知条件\n\n-   每磁道扇区数, $M = 100$。\n-   旋转周期, $T = 10\\,\\mathrm{ms}$。\n-   每磁道柱面寻道时间, $\\alpha = 0.10\\,\\mathrm{ms}$。\n-   初始磁头位置, $c_0 = 100$。\n-   初始时间, $t_0 = 0\\,\\mathrm{ms}$。\n-   初始磁盘相位, $\\theta(0) = 0$。\n-   初始磁头方向：磁道柱面索引增加的方向。\n-   请求 (所有请求都在 $t=0\\,\\mathrm{ms}$ 发出):\n    1.  R1: $(c,s) = (120, 20)$\n    2.  R2: $(c,s) = (150, 50)$\n    3.  R3: $(c,s) = (80, 18)$\n    4.  R4: $(c,s) = (30, 68)$\n-   在所列出的最高磁道柱面索引 ($c=150$) 之外没有其他请求。\n-   磁道柱面 $c_a$ 和 $c_b$ 之间的寻道时间是 $|c_a - c_b| \\alpha$。\n-   传输时间可忽略不计。\n-   该模型假设没有磁道偏斜和扇区重映射。\n-   SCAN 算法在反转前会移动到磁盘的物理末端。\n-   LOOK 算法在处理完当前方向的最后一个请求后反转方向。\n\n### 第二步：使用提取的已知条件进行验证\n\n问题陈述提供了一个硬盘的详细物理模型和两种标准的调度算法。参数（$M$、$T$、$\\alpha$）在科学上是合理的。SCAN 和 LOOK 的定义是标准的。问题的核心是分析由旋转延迟效应引起的性能差异。\n\n存在一个模糊之处：没有提供计算 SCAN 算法确切路径所需的最大磁道柱面号 $C_{max}$。问题陈述 SCAN “会继续移动到磁盘末端的最后一个磁道柱面”。然而，问题要求的是对 SCAN *何时* *可能* 优于 LOOK 的一般性描述，以及*所构造的轨迹展示了什么*。这表明该问题是概念性的。我们可以研究是否存在一个合理的 $C_{max}$ 值，使得该轨迹能够展示一个关键原理。如果能找到这样一个值，并且它导出的结果与其中一个选项一致，那么这个问题在其上下文中可以被认为是适定的。该问题不要求一个独立于假设的单一数值答案，而是要求理解寻道时间和旋转延迟之间的相互作用。基于这种解释，该问题是有效的。\n\n### 第三步：推导与求解\n\n我们将首先推导 SCAN 和 LOOK 性能之间的一般关系，然后将其应用于具体的轨迹。处理一批请求的总时间是所有寻道时间和旋转延迟的总和。\n\n**一般性分析：SCAN vs. LOOK**\n\n让我们考虑两种算法产生分歧的点。SCAN 和 LOOK 都将以相同的顺序处理初始方向（磁道柱面索引增加）上的请求。对于给定的轨迹，两者都先处理 R1 ($c=120$)，然后处理 R2 ($c=150$)。设 $t_{dep, last}$ 为磁头完成前向扫描中最后一个请求（在 $c=150$ 处的 R2）服务的时间。\n\n此后，LOOK 反转方向并寻道至反向的下一个请求，即在 $c=80$ 处的 R3。\nSCAN 继续移动到磁盘的物理末端 $C_{max}$，反转方向，然后寻道至 $c=80$ 处的 R3。\n\n设 $c_{last} = 150$ 且 $c_{rev} = 80$。\nLOOK 到达 R3 的寻道时间是 $t_{seek,L} = |c_{last} - c_{rev}|\\alpha = |150 - 80|\\alpha = 70\\alpha$。\nLOOK 到达 $c=80$ 的时间是 $t_{arr,L} = t_{dep,last} + 70\\alpha$。\n\nSCAN 到达 R3 的寻道时间是移动 $150 \\to C_{max} \\to 80$ 的时间。\n$t_{seek,S} = ((C_{max} - c_{last}) + (C_{max} - c_{rev}))\\alpha = ((C_{max} - 150) + (C_{max} - 80))\\alpha$。\n我们可以用 LOOK 的寻道时间和 SCAN 的额外移动距离来表示它。\nSCAN 的额外移动是从 $c_{last} \\to C_{max} \\to c_{last}$。其花费的时间是 $d_{\\text{end}} = 2(C_{max} - c_{last})\\alpha = 2(C_{max} - 150)\\alpha$。\n$t_{seek,S} = |c_{last} - c_{rev}|\\alpha + 2(C_{max} - c_{last})\\alpha = t_{seek,L} + d_{\\text{end}}$。\nSCAN 到达 $c=80$ 的时间是 $t_{arr,S} = t_{dep,last} + t_{seek,S} = t_{dep,last} + t_{seek,L} + d_{\\text{end}} = t_{arr,L} + d_{\\text{end}}$。\n\n现在，让我们分析旋转延迟。对于在时间 $t_{arr}$ 到达、角度为 $\\theta_r$ 的请求，其旋转延迟 $L$ 由下式给出：\n$L = \\frac{T}{2\\pi} \\left( \\theta_r - \\theta(t_{arr}) \\right) \\pmod{2\\pi}$，其中对角度的模运算结果在 $[0, 2\\pi)$ 范围内。这可以写成 $L = (T \\frac{\\theta_r}{2\\pi} - t_{arr}) \\pmod T$，结果在 $[0,T)$ 范围内。\n\n设 $L_L$ 为 LOOK 在 $c_{rev}$ 处的旋转延迟，$L_S$ 为 SCAN 的旋转延迟。\n$L_L = (T \\frac{\\theta_r}{2\\pi} - t_{arr,L}) \\pmod T$。\n$L_S = (T \\frac{\\theta_r}{2\\pi} - t_{arr,S}) \\pmod T = (T \\frac{\\theta_r}{2\\pi} - (t_{arr,L} + d_{\\text{end}})) \\pmod T$。\n$L_S = ((T \\frac{\\theta_r}{2\\pi} - t_{arr,L}) - d_{\\text{end}}) \\pmod T = (L_L - d_{\\text{end}}) \\pmod T$。\n设 $d'_{\\text{end}} = d_{\\text{end}} \\pmod T$。则 $L_S = (L_L - d'_{\\text{end}}) \\pmod T$。\n\n从 $c_{last}$ 出发到在 $c_{rev}$ 完成服务的总耗时是：\n$\\Delta t_L = t_{seek,L} + L_L$。\n$\\Delta t_S = t_{seek,S} + L_S = (t_{seek,L} + d_{\\text{end}}) + (L_L - d'_{\\text{end}}) \\pmod T$。\n\n如果 $\\Delta t_S  \\Delta t_L$，则 SCAN 优于 LOOK。\n$t_{seek,L} + d_{\\text{end}} + (L_L - d'_{\\text{end}}) \\pmod T  t_{seek,L} + L_L$。\n$d_{\\text{end}} + (L_L - d'_{\\text{end}}) \\pmod T  L_L$。\n\n我们分析两种情况：\n1.  $L_L \\ge d'_{\\text{end}}$: 项 $(L_L - d'_{\\text{end}}) \\pmod T$ 变为 $L_L - d'_{\\text{end}}$。\n    不等式为 $d_{\\text{end}} + L_L - d'_{\\text{end}}  L_L \\implies d_{\\text{end}}  d'_{\\text{end}}$。这对于 $d_{\\text{end}} > 0$ 是不可能的，因为 $d'_{\\text{end}} \\le d_{\\text{end}}$。如果 $d_{\\text{end}} = 0$，则两种算法相同。如果 $d_{\\text{end}} = d'_{\\text{end}}$ (即 $d_{\\text{end}}  T$)，则可能出现平局，此时不等式变为 $d_{\\text{end}}  d_{\\text{end}}$，这是错误的。如果 $d_{\\text{end}} = d'_{\\text{end}}$，则等式 $\\Delta t_S = \\Delta t_L$ 成立，意味着 $d_{\\text{end}}  T$。\n2.  $L_L  d'_{\\text{end}}$: 项 $(L_L - d'_{\\text{end}}) \\pmod T$ 变为 $L_L - d'_{\\text{end}} + T$。\n    不等式为 $d_{\\text{end}} + L_L - d'_{\\text{end}} + T  L_L \\implies d_{\\text{end}} - d'_{\\text{end}} + T  0$。\n    由于 $d_{\\text{end}} \\ge d'_{\\text{end}}$ 且 $T > 0$，这是不可能的。\n\n这证实了 SCAN 永远不可能严格优于 LOOK ($\\Delta t_S \\nless \\Delta t_L$)。SCAN 能做到的最好情况是与 LOOK 打平。平局（$\\Delta t_S = \\Delta t_L$）当且仅当 $d_{\\text{end}}  T$ 且 $L_L \\ge d_{\\text{end}}$ 时发生。\n\n**具体轨迹分析**\n\n让我们计算直到分歧点之前的状态。\n1.  **处理 R1 (120, 20):**\n    -   从 $c=100$ 寻道至 $c=120$。 $\\Delta c = 20$。 $t_{seek1} = 20 \\alpha = 20 \\times 0.10\\,\\mathrm{ms} = 2\\,\\mathrm{ms}$。\n    -   到达 $c=120$ 的时间：$t_{A1} = 2\\,\\mathrm{ms}$。\n    -   到达时的磁盘角度：$\\theta(t_{A1}) = 2\\pi \\frac{t_{A1}}{T} = 2\\pi \\frac{2}{10} = 0.4\\pi$。\n    -   请求 R1 的目标角度：$\\theta_{r1} = 2\\pi \\frac{s}{M} = 2\\pi \\frac{20}{100} = 0.4\\pi$。\n    -   由于 $\\theta(t_{A1}) = \\theta_{r1}$，旋转延迟 $L_1 = 0$。\n    -   R1 的服务完成时间：$t_{S1} = 2\\,\\mathrm{ms}$。\n2.  **处理 R2 (150, 50):**\n    -   从 $c=120$ 寻道至 $c=150$。 $\\Delta c = 30$。 $t_{seek2} = 30 \\alpha = 3\\,\\mathrm{ms}$。\n    -   到达 $c=150$ 的时间：$t_{A2} = t_{S1} + t_{seek2} = 2 + 3 = 5\\,\\mathrm{ms}$。\n    -   到达时的磁盘角度：$\\theta(t_{A2}) = 2\\pi \\frac{5}{10} = \\pi$。\n    -   请求 R2 的目标角度：$\\theta_{r2} = 2\\pi \\frac{50}{100} = \\pi$。\n    -   再次完美对齐。旋转延迟 $L_2 = 0$。\n    -   R2 的服务完成时间：$t_{S2} = 5\\,\\mathrm{ms}$。这就是 $t_{dep,last}$。\n\n现在，两种算法产生分歧。\n**LOOK 处理 R3 (80, 18) 的路径：**\n-   从 $c=150$ 寻道至 $c=80$。 $\\Delta c = 70$。 $t_{seek3,L} = 70\\alpha = 7\\,\\mathrm{ms}$。\n-   到达时间：$t_{A3,L} = t_{S2} + t_{seek3,L} = 5 + 7 = 12\\,\\mathrm{ms}$。\n-   到达时的磁盘角度：$\\theta(t_{A3,L}) = 2\\pi \\frac{12}{10} \\pmod{2\\pi} = 2\\pi(0.2) = 0.4\\pi$。\n-   请求 R3 的目标角度：$\\theta_{r3} = 2\\pi \\frac{18}{100} = 0.36\\pi$。\n-   磁盘刚刚经过目标扇区。需要几乎整整一圈的旋转。\n-   旋转延迟 $L_{L,R3} = (T \\frac{18}{100} - 12) \\pmod{10} = (1.8 - 12) \\pmod{10} = -10.2 \\pmod{10} = 9.8\\,\\mathrm{ms}$。\n-   R3 的服务完成时间 (LOOK)：$t_{S3,L} = t_{A3,L} + L_{L,R3} = 12 + 9.8 = 21.8\\,\\mathrm{ms}$。\n\n**SCAN 处理 R3 (80, 18) 的路径：**\n-   问题的轨迹是为了展示一个原理而构造的。让我们看看是否能找到一个合理的 $C_{max}$ 值，从而导致平局。\n-   为了达成平局，我们需要 $d_{\\text{end}}  T$ 且 $L_{L,R3} \\ge d_{\\text{end}}$。我们有 $T=10$ 且 $L_{L,R3}=9.8$。所以我们需要 $d_{\\text{end}} \\le 9.8\\,\\mathrm{ms}$。\n-   $d_{\\text{end}} = 2(C_{max} - 150)\\alpha$。让我们选择 $d_{\\text{end}} = 9.8\\,\\mathrm{ms}$。\n-   $9.8 = 2(C_{max} - 150)(0.1) \\implies 49 = C_{max} - 150 \\implies C_{max} = 199$。对于一个磁盘来说，这是一个完全合理的最大磁道柱面号。\n-   当 $C_{max}=199$ 时，我们有 $d_{\\text{end}} = 9.8\\,\\mathrm{ms}$。\n-   SCAN 的寻道时间：$t_{seek3,S} = t_{seek3,L} + d_{\\text{end}} = 7 + 9.8 = 16.8\\,\\mathrm{ms}$。\n-   到达时间：$t_{A3,S} = t_{S2} + t_{seek3,S} = 5 + 16.8 = 21.8\\,\\mathrm{ms}$。\n-   到达时的磁盘角度：$\\theta(t_{A3,S}) = 2\\pi \\frac{21.8}{10} \\pmod{2\\pi} = 2\\pi(0.18) = 0.36\\pi$。\n-   这恰好是 R3 的目标角度 $\\theta_{r3}$。\n-   旋转延迟 $L_{S,R3} = 0$。\n-   R3 的服务完成时间 (SCAN)：$t_{S3,S} = t_{A3,S} + L_{S,R3} = 21.8 + 0 = 21.8\\,\\mathrm{ms}$。\n\n服务完成时间相同：$t_{S3,S} = t_{S3,L} = 21.8\\,\\mathrm{ms}$。该轨迹展示了一次平局。LOOK 遇到的接近整圈的旋转延迟（$9.8\\,\\mathrm{ms}$）被 SCAN 完美地转化为了有效的寻道时间，用于访问磁盘末端并返回，从而恰好准时到达目标磁道柱面。由于从 R3 离开的时间相同，两种算法处理所有后续请求（R4）的时间也将相同。\n\n### 逐项分析\n\n**A. SCAN 优于 LOOK 的条件是，当且仅当额外的扫描到末端的时间 $d_{\\mathrm{end}}$ 满足 $d_{\\mathrm{end}} \\pmod T $ LOOK 算法在反转后的第一个请求上会遇到的旋转延迟；该轨迹表明 SCAN 严格优于 LOOK。**\n-   我们的推导证明了 SCAN 永远不可能严格优于 LOOK。这个陈述是不正确的。\n-   该轨迹表明的是平局，而不是 SCAN “严格优于” LOOK。这个陈述是不正确的。\n-   条件 $d'_{\\text{end}}  L_L$ (以及 $L_L  d'_{end}$) 会导致 SCAN 严格变差。这个陈述是不正确的。\n-   结论：**不正确**。\n\n**B. 在此标准模型下，纯粹由于旋转角度对齐，SCAN 不可能严格优于 LOOK；至多，当 $d_{\\mathrm{end}}  T$ 时，SCAN 与 LOOK 持平，因为在第一个反向请求处的旋转延迟差异等于 $d_{\\mathrm{end}} \\pmod T$。该轨迹通过对齐展示了这样一种持平情况。**\n-   “SCAN 不可能严格优于 LOOK”：正确，如推导所示。\n-   “至多，当 $d_{\\mathrm{end}}  T$ 时，SCAN 与 LOOK 持平”：正确。平局发生在 $d_{\\text{end}}  T$ 且 $L_L \\ge d_{\\text{end}}$ 的情况下。所以 $d_{\\text{end}}  T$ 是平局的必要条件。\n-   “因为旋转延迟差异...等于 $d_{\\mathrm{end}} \\pmod T$”：在平局的情况下 ($d_{\\text{end}}  T, L_L \\ge d_{\\text{end}}$)，我们有 $L_S = L_L - d_{\\text{end}}$。差异 $|L_S - L_L|$ 是 $d_{\\text{end}}$，由于 $d_{\\text{end}}  T$，它等于 $d_{\\text{end}} \\pmod T$。这个推理正确地描述了平局的机制。\n-   “该轨迹通过对齐展示了这样一种持平情况”：正确，如我们使用合理的 $C_{max}=199$ 进行的计算所示。\n-   结论：**正确**。\n\n**C. 只要 $\\alpha  T/M$，SCAN 就更优，因为更小的每磁道柱面寻道时间总能对齐相位；该轨迹表明 SCAN 具有严格优势。**\n-   条件 $\\alpha  T/M$ 是 $0.10  10/100$，即 $0.10  0.10$。这个前提是错误的。\n-   “总能对齐相位”的说法是一个没有根据的泛化。\n-   该轨迹没有显示出“严格优势”。\n-   结论：**不正确**。\n\n**D. 仅当当前方向之外有许多请求时，SCAN 才变得更优，而这与旋转对齐情况无关；该轨迹展示了这种效应。**\n-   这误解了 SCAN 的角色。SCAN 移动到磁盘末端的行为是 LOOK 所避免的负担。在当前方向上但不在末端的更多请求会更有利于 LOOK。\n-   这个问题明确是关于旋转对齐的，而该选项忽略了这一点。\n-   该轨迹在 $c=150$ 之外没有请求，所以它不能展示这种效应。\n-   结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "3681127"}, {"introduction": "在许多系统中，按时完成磁盘请求比追求原始吞吐量更为重要。这项实践将你从理论分析带入动手实现，要求你为实时磁盘调度构建一个模拟器。你将实现并比较两种调度策略，它们都将最早截止期优先（EDF）原则与不同的寻道优化决胜局规则（SSTF 和 SCAN）相结合，从而让你在离散事件模拟和处理截止期调度挑战方面获得宝贵的实践经验。[@problem_id:3681126]", "problem": "考虑一个单一机械硬盘，其同心圆柱面由整数索引，有一个读写磁头，并对输入/输出 (I/O) 请求提供非抢占式服务。每个请求由到达时间 $a_i$（毫秒）、目标柱面 $c_i$（整数柱面单位）和必须完成的严格截止时间 $d_i$（毫秒）来表征。磁头位置是在时间 $t$ 时的整数柱面索引 $p(t)$，移动磁头距离 $\\Delta = |c_i - p(t)|$ 会产生寻道时间，该时间可以通过线性近似来建模，再加上一个包含旋转延迟和数据传输的固定服务时间项。该模型由一个经过充分检验的经验公式给出：\n$$\nT_{\\text{service}}(\\Delta) = T_0 + \\alpha \\cdot \\Delta + T_{\\text{fixed}},\n$$\n其中 $T_0$ 是寻道启动开销（毫秒），$\\alpha$ 是一个常数（毫秒/柱面），$T_{\\text{fixed}}$ 是旋转和传输项（毫秒）。一旦磁头开始为一个请求服务，直到完成之前都不能被抢占。\n\n在每个决策时刻，当至少有一个请求可用（已到达但尚未完成）时，调度程序会选择下一个要开始的请求。主要的选择策略是“最早截止时间优先 (Earliest Deadline First, EDF)”：在所有可用请求中，调度程序选择那些具有最小截止时间 $d_i = \\min\\{ d_j \\mid a_j \\le t \\}$ 的请求。如果只有一个请求具有最小截止时间，则选择该请求。如果存在多个请求共享相同的最小截止时间，则使用基于磁头移动启发式算法的决胜规则：\n\n- 对于 EDF 与“最短寻道时间优先 (Shortest Seek Time First, EDF+SSTF)”，在具有最小截止时间的请求中，选择使 $|c_i - p(t)|$ 最小化的请求。如果仍有平局，则选择较小的 $c_i$。\n\n- 对于 EDF 与 SCAN (EDF+SCAN)，维持一个扫描方向 $\\delta \\in \\{+1,-1\\}$，初始化为 $+1$（增加柱面索引）。在具有最小截止时间的请求中，如果 $\\delta = +1$，则选择满足 $c_i \\ge p(t)$ 的最小 $c_i$ 的请求；如果不存在这样的请求，则翻转方向 $\\delta \\leftarrow -1$ 并选择满足 $c_i \\le p(t)$ 的最大 $c_i$ 的请求。如果 $\\delta = -1$，则选择满足 $c_i \\le p(t)$ 的最大 $c_i$ 的请求；如果不存在这样的请求，则翻转方向 $\\delta \\leftarrow +1$ 并选择满足 $c_i \\ge p(t)$ 的最小 $c_i$ 的请求。扫描方向仅在当前一侧没有候选请求时才被迫改变。\n\n如果一个请求 $i$ 的完成时间 $t_{\\text{complete},i}$ 严格超过其截止时间 $d_i$，即 $t_{\\text{complete},i} > d_i$，则称该请求错过了其截止时间。对于给定的调度程序和请求轨迹，截止时间错过率 $m$ 定义为错过其截止时间的请求数量除以总请求数量。将 $m$ 表示为小数（而非百分比）。\n\n基于这些基本定义，编写一个完整的程序，该程序在给定强调截止时间接近 $t=0$ 毫秒的合成轨迹的情况下，在所述的非抢占式模型下模拟 EDF+SCAN 和 EDF+SSTF，并计算各自的截止时间错过率 $m$。所有时间量均以毫秒为单位。对所有测试用例统一使用以下磁盘服务模型参数：$T_0 = 0.2$ 毫秒，$\\alpha = 0.1$ 毫秒/柱面，以及 $T_{\\text{fixed}} = 0.1$ 毫秒。磁头扫描方向初始化为 $\\delta = +1$。磁盘柱面由整数索引，没有明确的界限，但所有给定的柱面索引都在一个现实的范围内。\n\n您的程序应实现一个离散事件模拟，该模拟：\n\n- 维护当前时间 $t$（毫秒）和磁头位置 $p(t)$（整数柱面）。\n\n- 当尚无请求到达或在当前时间 $t$ 没有可用请求时，将时间推进到下一个请求的到达时间。\n\n- 当一个或多个请求可用时，根据 EDF 选择下一个请求；如果多个请求共享最小截止时间，则应用适当的决胜规则（EDF+SCAN 或 EDF+SSTF）；立即开始服务；使用 $T_{\\text{service}}(\\Delta)$ 计算服务时间；将 $t$ 更新为完成时间；并更新磁头位置。\n\n- 计算每个请求的截止时间未命中情况，并为每个调度程序计算 $m$。\n\n要模拟的测试套件和参数：\n\n- 测试用例 1（磁头两侧均衡的最早截止时间，并带有额外的较晚截止时间的本地请求）：\n\n    - 初始磁头位置 $p(0) = 100$。\n\n    - 请求：\n        - $(a_1, c_1, d_1) = (0.0, 40, 12.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 60, 12.0)$,\n        - $(a_3, c_3, d_3) = (0.0, 140, 12.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 12.0)$,\n        - $(a_5, c_5, d_5) = (0.5, 95, 25.0)$,\n        - $(a_6, c_6, d_6) = (0.5, 105, 25.0)$。\n\n- 测试用例 2（所有截止时间相等，柱面分布广泛）：\n\n    - 初始磁头位置 $p(0) = 50$。\n\n    - 请求：\n        - $(a_1, c_1, d_1) = (0.0, 10, 10.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 20, 10.0)$,\n        - $(a_3, c_3, d_3) = (0.0, 30, 10.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 10.0)$,\n        - $(a_5, c_5, d_5) = (0.0, 170, 10.0)$。\n\n- 测试用例 3（零寻道和非常紧迫截止时间的边缘情况，包括服务开始后到达的请求）：\n\n    - 初始磁头位置 $p(0) = 100$。\n\n    - 请求：\n        - $(a_1, c_1, d_1) = (0.0, 100, 2.0)$,\n        - $(a_2, c_2, d_2) = (0.0, 90, 1.0)$,\n        - $(a_3, c_3, d_3) = (0.5, 110, 2.0)$,\n        - $(a_4, c_4, d_4) = (0.0, 160, 3.5)$,\n        - $(a_5, c_5, d_5) = (0.0, 40, 3.5)$。\n\n您的程序应生成一行输出，其中包含一个以逗号分隔的列表，用方括号括起来，并按以下顺序排列\n$[m_{\\text{EDF+SCAN}}^{(1)}, m_{\\text{EDF+SSTF}}^{(1)}, m_{\\text{EDF+SCAN}}^{(2)}, m_{\\text{EDF+SSTF}}^{(2)}, m_{\\text{EDF+SCAN}}^{(3)}, m_{\\text{EDF+SSTF}}^{(3)}]$，\n每个错过率四舍五入到四位小数。例如，输出应类似于 $[0.1234,0.5678,0.0000,0.2500,0.3333,0.5000]$，其中每个条目都是指定格式的小数。", "solution": "该问题要求模拟两种实时磁盘调度算法：“最早截止时间优先”结合“最短寻道时间优先”决胜规则 (EDF+SSTF) 和“最早截止时间优先”结合 SCAN 决胜规则 (EDF+SCAN)，以确定它们在给定的一组 I/O 请求轨迹下的各自的截止时间错过率。这可以使用离散事件模拟的方法进行建模和求解。\n\n磁盘系统的状态在任何时刻都可以用一个元组 $(t, p, \\delta, S)$ 来描述，其中 $t$ 是当前模拟时间（毫秒），$p$ 是读写磁头所在柱面的整数索引，$\\delta \\in \\{+1, -1\\}$ 是 EDF+SCAN 算法的当前扫描方向（初始化为 $+1$），$S$ 是所有 I/O 请求的状态集合。每个请求 $i$ 由其到达时间 $a_i$、目标柱面 $c_i$ 和截止时间 $d_i$ 定义，其状态包括它是否已完成。\n\n模拟通过将时间从一个事件推进到下一个事件来进行。事件可以是新请求的到达或服务的完成。然而，由于服务是非抢占式的，因此只有在磁盘变为空闲时，才会决定下一个要服务的请求。因此，模拟循环按以下步骤进行：\n\n1.  在当前时间 $t$，识别可用请求的集合，这些请求是那些已经到达 ($a_i \\le t$) 且尚未完成的请求。\n\n2.  如果可用请求集为空，则磁盘处于空闲状态。模拟时间 $t$ 将被推进到任何待处理（尚未到达）请求的最早到达时间 $a_j$。然后过程从新时间 $t$ 的第 1 步重新开始。\n\n3.  如果至少有一个可用请求，则到达一个决策时刻。调度程序必须选择下一个要服务的请求。\n    a.  **EDF 筛选**：主要的调度策略是“最早截止时间优先 (EDF)”。我们首先在所有可用请求中确定最小截止时间 $d_{\\min}$。然后，候选请求集由所有截止时间 $d_i$ 等于 $d_{\\min}$ 的可用请求组成。\n    b.  **决胜规则**：如果此候选集包含多个请求，则应用决胜规则：\n        i.  对于 **EDF+SSTF**，调度程序选择使寻道距离 $\\Delta_i = |c_i - p|$ 最小化的候选请求 $i$，其中 $p$ 是当前的磁头位置。如果仍然存在平局（多个请求具有相同的最小寻道距离），则选择柱面索引 $c_i$ 较小的那个。\n        ii. 对于 **EDF+SCAN**，调度程序考虑当前扫描方向 $\\delta$。如果 $\\delta = +1$，它会搜索 $c_i \\ge p$ 的候选请求。如果存在此类请求，它会选择其中 cylinder index $c_i$ 最小的那个。如果不存在此类请求，则反转方向 ($\\delta \\leftarrow -1$)，然后从截止时间为 $d_{\\min}$ 的完整候选集中选择满足 $c_i \\le p$ 的请求中 cylinder index $c_i$ 最大的那个。如果初始方向为 $\\delta = -1$，则应用对称的逻辑。只有在当前运动方向上没有候选者时，方向 $\\delta$ 才会反转。\n\n4.  一旦选定一个请求 $i$，其服务将立即开始。服务时间使用提供的经验公式计算：\n    $$T_{\\text{service}}(\\Delta_i) = T_0 + \\alpha \\cdot \\Delta_i + T_{\\text{fixed}}$$\n    其中 $\\Delta_i = |c_i - p|$ 是寻道距离，$T_0 = 0.2$ 毫秒，$\\alpha = 0.1$ 毫秒/柱面，以及 $T_{\\text{fixed}} = 0.1$ 毫秒。\n\n5.  然后更新系统状态。请求的完成时间为 $t_{\\text{complete},i} = t + T_{\\text{service}}(\\Delta_i)$。如果 $t_{\\text{complete},i} > d_i$，则该请求错过了其截止时间，一个用于记录错过截止时间的计数器会递增。模拟时间推进到完成时间，$t \\leftarrow t_{\\text{complete},i}$，磁头位置更新为刚完成请求的柱面，$p \\leftarrow c_i$。该请求被标记为已完成。\n\n6.  循环（步骤 1-5）重复进行，直到轨迹中的所有请求都已完成。\n\n7.  最后，截止时间错过率 $m$ 计算为错过截止时间的总数除以轨迹中的总请求数。\n\n这整个模拟过程是确定性的，并且对测试用例和调度算法的每种组合执行，以产生所需的六个错过率值。", "answer": "[0.5000,0.5000,1.0000,0.4000,1.0000,1.0000]", "id": "3681126"}]}