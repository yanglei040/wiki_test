{"hands_on_practices": [{"introduction": "要掌握非循环图目录系统，第一步是理解系统如何追踪文件和目录之间的连接。本练习将引导你手动模拟这一过程，重点关注 $st\\_nlink$ 字段，即“链接数”。通过在一系列文件系统操作中追踪链接数的变化，你将对系统底层机制，特别是对垃圾回收至关重要的引用计数，建立起具体而深入的理解。[@problem_id:3619462]", "problem": "一个操作系统支持一个作为有向无环图 (DAG) 的目录命名空间，允许对目录建立多个硬链接，只要不形成环路即可。文件状态字段 $st\\_nlink$ 报告指向一个 inode 的硬链接数量。使用以下模型：\n- 对于非目录文件 $F$，$st\\_nlink(F)$ 是指向 $F$ 的目录条目的数量。\n- 对于目录 $D$，$st\\_nlink(D)$ 计算每个指向 $D$ 的目录条目，包括 $D$ 自身的点条目“.”、任何父目录中命名为 $D$ 的条目，以及每个直接子目录中解析到 $D$ 的点点条目“..”。\n- 当在父目录 $P$ 内创建一个新的子目录 $C$ 时，新目录的 $st\\_nlink(C) = 2$ （为其“.”条目和父目录中命名它的条目），并且 $st\\_nlink(P)$ 增加 1，因为 $C$ 的“..”条目会解析到 $P$。\n- 当在某个其他目录 $Q$ 中为现有目录 $D$ 创建一个额外的硬链接时（这不会使 $D$ 的“..”解析到 $Q$），$st\\_nlink(D)$ 增加 1，而 $st\\_nlink(Q)$ 不变。\n- 取消链接一个非目录文件的名称会使目标的 $st\\_nlink$ 减 1。通过 $rmdir$ 删除一个空子目录会使其父目录的 $st\\_nlink$ 减 1，并删除该子目录。\n\n假设文件系统初始为空，只有一个根目录。执行以下操作序列，并且所有操作在无环性方面都是有效的：\n- 步骤 $1$：在根目录下创建目录 $/$P 和 $/$Q。\n- 步骤 $2$：在目录 $/$P 中，创建一个名为 $f$ 的常规文件。\n- 步骤 $3$：为 $/$P$/f$ 在路径 $/$Q$/g$ 创建一个硬链接。\n- 步骤 $4$：在目录 $/$P 中，创建一个名为 $C$ 的子目录。\n- 步骤 $5$：在目录 $/$Q 中，创建一个名为 $D$ 的子目录。\n- 步骤 $6$：在目录 $/$Q 中，创建一个名为 $C\\_alias$ 的额外硬链接，指向现有目录 $/$P$/$C$（这不会改变 $/$C$..\"$ 解析到哪个父目录）。\n- 步骤 $7$：在目录 $/$P$/$C$ 中，创建一个名为 $E$ 的子目录。\n- 步骤 $8$：取消链接 $/$P$/$f$。\n- 步骤 $9$：取消链接 $/$Q$/$C\\_alias$（移除指向 $/$P$/$C$ 的额外链接）。\n- 步骤 $10$：通过 $rmdir$ 删除空子目录 $/$P$/$C$/$E$。\n\n在步骤 $10$ 之后，以下哪个元组给出了 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ 的最终值？\n\nA. $\\;(3,\\;3,\\;2,\\;2,\\;1)$\n\nB. $\\;(3,\\;4,\\;3,\\;2,\\;1)$\n\nC. $\\;(2,\\;3,\\;2,\\;2,\\;1)$\n\nD. $\\;(3,\\;3,\\;3,\\;2,\\;2)$", "solution": "首先验证问题陈述的正确性和可解性。\n\n### 步骤 1：提取已知条件\n- 目录系统是一个有向无环图 (DAG)。\n- `st_nlink` 字段表示一个 inode 的链接数。\n- 对于非目录文件 $F$，$st\\_nlink(F)$ 是指向它的目录条目数。\n- 对于目录 $D$，$st\\_nlink(D)$ 是以下各项的总和：\n  1. 其自身的 `.` 条目。\n  2. 任何父目录中命名为 $D$ 的条目。\n  3. 来自每个直接子目录的 `..` 条目。\n- 在父目录 $P$ 中创建子目录 $C$：$st\\_nlink(C)$ 变为 $2$，而 $st\\_nlink(P)$ 增加 $1$。\n- 在目录 $Q$ 中为目录 $D$ 创建额外的硬链接：$st\\_nlink(D)$ 增加 $1$；$st\\_nlink(Q)$ 不变。\n- 取消链接一个非目录文件的名称：目标的 inode 的 $st\\_nlink$ 减 $1$。\n- 删除空子目录（`rmdir`）：父目录的 $st\\_nlink$ 减 $1$。\n- 初始条件：文件系统只包含根目录 `/`。\n- 操作序列：\n  1. 创建目录 `/P` 和 `/Q`。\n  2. 创建常规文件 `/P/f`。\n  3. 为 `/P/f` 创建硬链接 `/Q/g`。\n  4. 创建子目录 `/P/C`。\n  5. 创建子目录 `/Q/D`。\n  6. 为 `/P/C` 创建额外的硬链接 `/Q/C_alias`。\n  7. 创建子目录 `/P/C/E`。\n  8. 取消链接 `/P/f`。\n  9. 取消链接 `/Q/C_alias`。\n  10. `rmdir /P/C/E`。\n- 问题要求 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$ 的最终值。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在计算机科学领域，特别是在操作系统文件系统设计方面，具有科学依据。所提供的在基于 DAG 的目录系统中对 `st_nlink` 进行计数的模型，虽然并非普遍实现，但它是一个逻辑上一致且定义明确的概念。这个问题是适定的，具有清晰的初始状态、确定性的操作序列和具体的问题。语言客观且无歧义。所有术语都由所提供的规则充分定义。因此，该问题是有效的。\n\n### 步骤 3：结论与行动\n该问题有效。将进行逐步推导求解。\n\n### 解题推导\n我们将通过这十个操作序列来追踪五个指定 inode 的 `st_nlink` 值。令我们关心的元组为 $\\big(n_P, n_Q, n_C, n_D, n_f\\big)$，代表 $\\big(st\\_nlink(/P),\\, st\\_nlink(/Q),\\, st\\_nlink(/P/C),\\, st\\_nlink(/Q/D),\\, st\\_nlink(\\text{inode of }f)\\big)$。\n\n**初始状态：** 文件系统为空，只有根目录。 `/P`, `/Q`, `/P/C`, `/Q/D` 和 `f` 的 inode 尚不存在。它们的链接数实际上为 $0$。\n\n**步骤 1：** 创建目录 `/P` 和 `/Q`。\n- 创建了一个新目录 `/P`。根据规则，其链接数为 $2$。$n_P = 2$。\n- 创建了一个新目录 `/Q`。根据规则，其链接数为 $2$。$n_Q = 2$。\n- 元组: $\\big(2, 2, \\text{N/A}, \\text{N/A}, \\text{N/A}\\big)$。\n\n**步骤 2：** 创建一个常规文件 `/P/f`。\n- 为文件 `f` 创建了一个 inode，带有一个目录条目 `/P/f`。其链接数为 $1$。$n_f = 1$。\n- 元组: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 1\\big)$。\n\n**步骤 3：** 为 `/P/f` 在路径 `/Q/g` 创建一个硬链接。\n- 第二个目录条目 `/Q/g`现在指向 `f` 的 inode。其链接数增加 $1$。\n- $n_f$ 变为 $1+1 = 2$。\n- 元组: $\\big(2, 2, \\text{N/A}, \\text{N/A}, 2\\big)$。\n\n**步骤 4：** 创建子目录 `/P/C`。\n- 创建了一个新目录 `/P/C`。其链接数为 $2$。$n_C = 2$。\n- 父目录 `/P` 从 `/P/C` 获得了一个 `..` 链接。其链接数增加 $1$。\n- $n_P$ 变为 $2+1 = 3$。\n- 元组: $\\big(3, 2, 2, \\text{N/A}, 2\\big)$。\n\n**步骤 5：** 创建子目录 `/Q/D`。\n- 创建了一个新目录 `/Q/D`。其链接数为 $2$。$n_D = 2$。\n- 父目录 `/Q` 从 `/Q/D` 获得了一个 `..` 链接。其链接数增加 $1$。\n- $n_Q$ 变为 $2+1 = 3$。\n- 元组: $\\big(3, 3, 2, 2, 2\\big)$。\n\n**步骤 6：** 为 `/P/C` 创建额外的硬链接 `/Q/C_alias`。\n- 目标目录 `/P/C` 获得了一个新名称。其链接数增加 $1$。\n- $n_C$ 变为 $2+1 = 3$。\n- 根据规则，`/Q` 的链接数不变。\n- 元组: $\\big(3, 3, 3, 2, 2\\big)$。\n\n**步骤 7：** 创建子目录 `/P/C/E`。\n- 父目录 `/P/C` 从 `/P/C/E` 获得了一个 `..` 链接。其链接数增加 $1$。\n- $n_C$ 变为 $3+1 = 4$。\n- 元组: $\\big(3, 3, 4, 2, 2\\big)$。\n\n**步骤 8：** 取消链接 `/P/f`。\n- 目录条目 `/P/f` 被移除。目标 inode `f` 的链接数减少 $1$。\n- $n_f$ 变为 $2-1 = 1$。\n- 元组: $\\big(3, 3, 4, 2, 1\\big)$。\n\n**步骤 9：** 取消链接 `/Q/C_alias`。\n- 指向目录 `/P/C` 的额外硬链接被移除。与其创建过程对称，这会使目标目录的链接数减少 $1$。\n- $n_C$ 变为 $4-1 = 3$。\n- 元组: $\\big(3, 3, 3, 2, 1\\big)$。\n\n**步骤 10：** 通过 `rmdir` 删除空子目录 `/P/C/E`。\n- `/P/C/E` 的父目录是 `/P/C`。删除 `/P/C/E` 会移除从 `/P/C/E` 指向 `/P/C` 的 `..` 链接。父目录的链接数减少 $1$。\n- $n_C$ 变为 $3-1 = 2$。\n- 最终元组: $\\big(3, 3, 2, 2, 1\\big)$。\n\n最终推导出的值为 $st\\_nlink(/P) = 3$，$st\\_nlink(/Q) = 3$，$st\\_nlink(/P/C) = 2$，$st\\_nlink(/Q/D) = 2$，以及 $st\\_nlink(\\text{inode of }f) = 1$。\n\n### 逐项分析\n\n**A. $\\;(3,\\;3,\\;2,\\;2,\\;1)$**\n此元组与分步分析推导出的最终值相匹配。\n- $st\\_nlink(/P) = 3$：正确。链接包括其在 `/` 中的条目 `P`、其自身的 `.` 条目，以及来自其子目录 `/P/C` 的 `..` 条目。\n- $st\\_nlink(/Q) = 3$：正确。链接包括其在 `/` 中的条目 `Q`、其自身的 `.` 条目，以及来自其子目录 `/Q/D` 的 `..` 条目。\n- $st\\_nlink(/P/C) = 2$：正确。链接包括其在 `/P` 中的条目 `C` 和其自身的 `.` 条目。来自 `C_alias` 的链接（步骤 6）已被移除（步骤 9），来自 `/P/C/E` 的 `..` 链接（步骤 7）也已被移除（步骤 10）。\n- $st\\_nlink(/Q/D) = 2$：正确。链接包括其在 `/Q` 中的条目 `D` 和其自身的 `.` 条目。\n- $st\\_nlink(\\text{inode of }f) = 1$：正确。条目 `/P/f` 已被移除（步骤 8），只剩下条目 `/Q/g`。\n**结论：正确。**\n\n**B. $\\;(3,\\;4,\\;3,\\;2,\\;1)$**\n- $st\\_nlink(/Q)$ 的值为 $4$，这是不正确的。推导出的值为 $3$。\n- $st\\_nlink(/P/C)$ 的值为 $3$，这是不正确的。推导出的值为 $2$。这会是步骤 9 之后但步骤 10 之前的状态。\n**结论：不正确。**\n\n**C. $\\;(2,\\;3,\\;2,\\;2,\\;1)$**\n- $st\\_nlink(/P)$ 的值为 $2$，这是不正确的。推导出的值为 $3$。其链接数在步骤 4 中增加到 $3$，之后没有减少。\n**结论：不正确。**\n\n**D. $\\;(3,\\;3,\\;3,\\;2,\\;2)$**\n- $st\\_nlink(/P/C)$ 的值为 $3$，这是不正确的，原因如选项 B 所述。\n- $st\\_nlink(\\text{inode of }f)$ 的值为 $2$，这是不正确的。推导出的值为 $1$。这会是步骤 8 中取消链接操作之前的状态。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3619462"}, {"introduction": "在纸上推演了基本机理之后，合乎逻辑的下一步是亲手实现它。本练习将指导你构建一个功能完备的内存中非循环图（DAG）目录系统模拟器。这个过程不仅涉及设计核心数据结构和实现 `link`、`unlink` 等基本操作，更关键的是，你将编写用于检测并防止环路形成的代码，这是确保目录结构始终保持为非循环图的决定性约束。[@problem_id:3619453]", "problem": "您需要设计并实现一个自包含的教学模拟器，用于模拟一个建模为有向无环图 (DAG) 的目录系统。该模拟器必须完全在内存中运行，并严格强制其无环性。该模型应遵循以下源自标准操作系统目录抽象和成熟图论的第一性原理定义和规则。\n\n模拟器必须体现的核心定义如下：\n- 目录系统表示为一个有向图 $G = (V, E)$，其中 $V$ 是节点的有限集合， $E \\subseteq V \\times V$ 是一组有向边。\n- 每个节点 $v \\in V$ 代表一个文件系统对象，其类型为目录或文件。文件没有出边。目录可以有指向任何类型节点的出边。从一个目录出发的每条出边都由一个字符串名称标记。在单个目录内，名称必须是唯一的。\n- 图必须是无环的。环是一个节点序列 $(v_0, v_1, \\dots, v_k)$，其中 $k \\geq 1$，对于所有 $i \\in \\{0, 1, \\dots, k-1\\}$ 满足 $(v_i, v_{i+1}) \\in E$，并且 $(v_k, v_0) \\in E$。因此，任何会导致父节点可以从其未来的子节点到达的边的添加都必须被拒绝。\n- 每个节点 $v$ 维护一个入度（也称为引用计数），记作 $\\mathrm{in}(v) \\in \\mathbb{Z}_{\\ge 0}$，等于指向 $v$ 的目录条目数量。根目录是一个标识符为 $0$ 的特殊节点，它永远不会被垃圾回收。\n- 垃圾回收规则：当一条边被移除，且一个节点（非根节点）的入度变为 $0$ 时，该节点被删除。如果该节点是一个目录，则其所有出边都将被移除，其子节点的引用计数也相应递减；此过程可能递归地级联。\n\n您的模拟器必须实现以下命令，并带有明确的错误状态：\n- `link$(p, c, s)`: 从标识符为 $p$ 的父节点（必须是目录）向标识符为 $c$ 的子节点添加一条有向边，并在 $p$ 内部将其命名为字符串 $s$。\n  - 成功返回 $0$。\n  - 如果 $p$ 或 $c$ 未指向有效的现有节点，或 $p$ 不是目录，则返回 $-1$。\n  - 如果 $s$ 在 $p$ 中已绑定到另一个不同的子节点，则返回 $-2$。\n  - 如果从 $p$ 到 $c$ 已存在一条同名 $s$ 的边，则返回 $-3$。\n  - 如果添加该边会引入环（等价于，在添加前 $p$ 可以从 $c$ 到达），则返回 $-4$。\n- `unlink$(p, s)`: 从目录节点 $p$ 中移除指向其子节点的、名为 $s$ 的边。移除后，根据上述规则执行垃圾回收。\n  - 成功返回 $0$。\n  - 如果从 $p$ 出发不存在名为 $s$ 的边，则返回 $-5$。\n- `rename$(p, s_{\\text{old}}, s_{\\text{new}})$`: 将目录节点 $p$ 中现有边的名称从 $s_{\\text{old}}$ 更改为 $s_{\\text{new}}$。\n  - 成功返回 $0$。\n  - 如果 $s_{\\text{old}}$ 在 $p$ 中不存在，则返回 $-6$。\n  - 如果 $s_{\\text{new}}$ 在 $p$ 中已用于任何边，则返回 $-7$。\n\n模拟器还必须实现一个只读的 `show` 操作，用于计算当前图状态的不变量指标：\n- 设 $N$ 为活动节点的总数。\n- 设 $E$ 为活动有向边的总数。\n- 设 $B$ 为无环性的布尔指示符，当且仅当当前图没有有向环时 $B=1$，否则 $B=0$。\n- 设 $S$ 为一个整数校验和，定义为 $S = \\sum_{(p \\to c, s) \\in E} \\left( |s| + p + c \\right)$，其中 $|s|$ 表示字符串 $s$ 的长度，求和遍及所有由名称 $s$ 标记的目录边 $(p \\to c)$。\n\n必须指导您设计的算法事实：\n- 可达性由有向路径的存在来定义：如果存在一个序列 $u = v_0, v_1, \\dots, v_k = v$（其中 $k \\ge 0$）并且对所有 $i$ 都有 $(v_i, v_{i+1}) \\in E$，则节点 $u$ 可到达节点 $v$。在 `link$(p,c,s)$` 中拒绝环是通过在添加 $(p \\to c)$ 之前检查当前图 $G$ 中 $p$ 是否可从 $c$ 到达来实现的。\n- 使用颜色标记或已访问集合的标准深度优先搜索 (DFS) 适用于确定可达性和检测环，并因此用于评估 $B$。\n\n您的程序必须：\n- 为下面的每个测试用例构建新的 DAG 实例。\n- 根据测试序列的需要，提供内部辅助操作来创建目录和文件类型的节点。每个 DAG 中都必须存在标识符为 $0$ 的根目录，它是一个目录。\n- 执行以下测试套件，每个测试都在一个新的 DAG 实例上执行：\n  1. 测试用例 1 (正常路径): 创建目录 $A$ 和 $B$，以及文件 $F$。执行 `link$(0, A, \\text{\"home\"})$`、`link$(0, B, \\text{\"etc\"})$`、`link$(A, F, \\text{\"notes\"})$`。然后计算 `show` 指标并返回列表 $[N, E, B, S]$。\n  2. 测试用例 2 (拒绝成环): 创建目录 $A$。执行 `link$(0, A, \\text{\"home\"})$`。尝试执行 `link$(A, 0, \\text{\"back\"})$`。返回该尝试产生的整数错误代码（预计为一个负整数，表示因存在成环风险而被拒绝）。\n  3. 测试用例 3 (重命名冲突): 创建文件 $F$ 和 $G$。执行 `link$(0, F, \\text{\"x\"})$`、`link$(0, G, \\text{\"y\"})$`。尝试执行 `rename$(0, \\text{\"x\"}, \\text{\"y\"})$`。返回该尝试产生的整数错误代码（预计为一个负整数，表示目标名称冲突）。\n  4. 测试用例 4 (unlink 垃圾回收): 创建目录 $A$ 和文件 $F$。执行 `link$(0, A, \\text{\"home\"})$`、`link$(A, F, \\text{\"notes\"})$`。执行 `unlink$(0, \\text{\"home\"})$`。返回垃圾回收完成后整数形式的节点数 $N$。\n  5. 测试用例 5 (多父节点链接与取消链接): 创建目录 $A$ 和 $B$。执行 `link$(0, A, \\text{\"home\"})$`、`link$(0, B, \\text{\"etc\"})$`、`link$(B, A, \\text{\"alias\"})$`。执行 `unlink$(B, \\text{\"alias\"})$`。返回取消链接后整数形式的入度 $\\mathrm{in}(A)$。\n\n最终输出格式规范：\n- 您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。列表中的每个位置对应一个测试结果。测试用例 1 使用一个四元素列表，测试用例 2、3、4 和 5 使用单个整数。\n- 具体来说，输出必须具有确切的格式 $[[N,E,B,S],r_2,r_3,r_4,r_5]$，其中 $r_2$、$r_3$、$r_4$ 和 $r_5$ 是如上定义的整数。不允许有其他输出。\n- 本任务不涉及物理单位、角度或百分比；所有答案都是纯整数或整数列表，且所有数字都必须以普通整数形式报告。", "solution": "该问题要求设计并实现一个用于模拟无环图目录系统的模拟器。解决方案必须基于图论和操作系统原理的形式化定义。解决方案的核心在于将文件系统建模为有向无环图 (DAG) $G = (V, E)$，并正确实现状态修改操作（`link`、`unlink`、`rename`），以维护该结构的完整性，特别是其无环性和基于引用计数的垃圾回收机制。\n\n### 数据结构设计\n\n图 $G$ 由节点和边的集合表示。为了便于高效访问和管理，一个中心的 `DAG` 结构封装了整个状态。\n\n1.  **节点表示**：每个节点 $v \\in V$ 由一个 `Node` 结构体表示。该结构体包含：\n    *   一个整数标识符 `id`，作为节点的唯一键。\n    *   一个 `type` 枚举，可以是 `NODE_DIRECTORY` 或 `NODE_FILE`。\n    *   一个整数 `in_degree`，表示引用计数 $\\mathrm{in}(v)$。该计数是入边的数量，对应于链接到此节点的父目录数。\n    *   一个布尔标志 `is_active`，用于在逻辑上将节点标记为“活动”或被垃圾回收器“删除”。\n    *   对于 `NODE_DIRECTORY` 类型的节点，还有一个指向出边链表的指针。根据定义，文件节点没有出边。\n\n2.  **边表示**：每条带有名称标签 $s$ 的有向边 $(p, c) \\in E$ 由一个 `Edge` 结构体表示。该结构体包含：\n    *   一个字符数组 `name`，用于存储字符串标签 $s$。\n    *   一个整数 `child_id`，存储子节点 $c$ 的标识符。\n    *   一个 `next` 指针，构成一个从共同父目录 $p$ 出发的所有边组成的单向链表。\n\n3.  **图容器**：一个 `DAG` 结构体聚合了图的各个组件：\n    *   一个 `Node` 结构体数组 `nodes`，按节点 `id` 索引，可在 $O(1)$ 时间内访问任何给定标识符的节点。\n    *   一个整数 `next_node_id`，以确保为新创建的节点分配唯一的标识符。\n\n模拟始于一个位于 `id = 0` 的、单一的、活动的根目录，其 `in_degree` 在概念上为非零，并且不受垃圾回收的影响。\n\n### 算法实现\n\n**1. 通过可达性检查强制无环性**\n\n`link(p, c, s)` 操作必须保证从父节点 $p$ 添加一条到子节点 $c$ 的边不会引入环路。当且仅当图中已存在从 $c$ 到 $p$ 的路径时，才会创建环。因此，在添加边 $(p, c)$ 之前，我们必须执行一次可达性检查。\n\n“节点 $p$ 是否可从节点 $c$ 到达？”这个可达性查询使用迭代深度优先搜索 (DFS) 来解决。算法如下：\n*   初始化一个大小为 $|V|$ 的布尔数组 `visited`，所有条目设为 false。\n*   初始化一个栈，并将起始节点标识符 $c$ 推入栈中。\n*   将 $c$ 标记为已访问。\n*   当栈不为空时：\n    1.  弹出一个节点标识符 $u$。\n    2.  如果 $u$ 是目标节点 $p$，则路径存在。返回 `true`。\n    3.  对于节点 $u$ 的每个子节点 $v$：\n        *   如果 $v$ 尚未被访问，则将其标记为已访问并推入栈中。\n*   如果循环完成而未找到 $p$，则不存在路径。返回 `false`。\n\n如果此检查返回 `true`，则 `link` 操作以错误代码 $-4$ 中止。\n\n**2. 垃圾回收**\n\n垃圾回收基于引用计数。如果一个节点（非根节点）的 `in_degree` 降至 $0$，它就有资格被回收。此过程由 `unlink` 操作启动。\n\n`collect_garbage(v_id)` 过程是递归的：\n1.  检索与 `v_id` 对应的节点 $v$。\n2.  终止递归的基线条件是：如果 $v$ 已经是非活动状态，如果 $v$ 是根节点（ID 0），或者如果 $\\mathrm{in}(v) > 0$。\n3.  如果不满足基线条件，则将节点 $v$ 标记为非活动状态（`is_active = false`）。\n4.  如果 $v$ 是一个目录，则遍历其所有出边 $(v, w)$。对于每条这样的边：\n    *   递减子节点 $w$ 的 `in_degree`。\n    *   递归调用 `collect_garbage(w_id)`。\n    *   `Edge` 结构体本身分配的内存被释放。\n5.  遍历后，目录的边列表被清空。\n\n这种级联删除能正确回收所有不可达的子图。\n\n**3. 命令实现**\n\n面向用户的命令被实现为操作 `DAG` 数据结构的函数，并使用上述算法来保持一致性。\n\n*   `link(p, c, s)`: 首先，它验证节点 $p$ 和 $c$ 的存在性和类型。然后，它遍历 $p$ 的边列表以检查名称冲突（错误 $-2$）或重复边（错误 $-3$）。随后，它执行关键的无环性检查。如果所有检查都通过，它会分配一个新的 `Edge`，将其前置到父节点的边列表中，并增加子节点的 `in_degree`。\n\n*   `unlink(p, s)`: 它验证父节点 $p$ 并在其边列表中搜索名为 $s$ 的边。如果未找到，则返回错误 $-5$。如果找到，则从链表中移除该边并释放其内存。相应子节点的 `in_degree` 会递减，并对该子节点调用 `collect_garbage`，这可能触发级联操作。\n\n*   `rename(p, s_old, s_new)`: 它首先检查新名称 $s_{\\text{new}}$ 是否已在目录 $p$ 中使用，如果是则返回错误 $-7$。然后，它搜索名为 $s_{\\text{old}}$ 的边。如果找到，则更新名称；否则，返回错误 $-6$。\n\n**4. `show` 指标计算**\n\n`show` 操作计算描述图当前状态的四个指标。\n\n*   $N$ (总节点数): 通过遍历 `nodes` 数组并计算所有 `is_active` 为 true 的节点来计算。\n*   $E$ (总边数): 通过遍历所有活动节点来计算。如果一个节点是目录，则其边列表的大小会加到一个运行总和上。\n*   $B$ (无环性): 一个由全局环检测算法确定的布尔值。采用三色 DFS 遍历：\n    *   所有节点最初都是 `WHITE`（未访问）。\n    *   从图中每个 `WHITE` 节点开始遍历。\n    *   访问一个节点时，它被着色为 `GRAY`（访问中）。\n    *   如果遍历遇到一个 `GRAY` 节点，则表示发现了一条反向边，说明存在一个环。函数返回 $B=0$。\n    *   在一个节点的所有后代都被访问后，该节点被着色为 `BLACK`（已完成）。\n    *   如果对所有节点的遍历完成而没有发现环，则图是无环的，函数返回 $B=1$。\n*   $S$ (校验和): 通过遍历图中所有边 $(p \\to c, s)$ 并对每个边求和值 $|s| + p + c$ 来计算，其中 $|s|$ 是字符串名称的长度。\n\n这种全面的设计确保了问题陈述中指定的所有规则和行为都得到严格执行，从而实现一个正确且健壮的模拟。", "answer": "```c\n// The complete C code implementation is omitted for brevity.\n// A correct implementation would follow the logic described in the solution section\n// and produce the expected output for the test suite.\n```", "id": "3619453"}, {"introduction": "拥有一个可工作的非循环图模型后，你现在可以在其上构建一个实用的应用程序了。本练习模拟了磁盘使用统计工具（类似于 `du`）的实现。核心挑战在于如何正确计算总大小，即确保拥有多个硬链接的文件只被计算一次。这个实践不仅强化了图遍历算法的应用，还引入了如何使用位图等辅助数据结构来维护状态和保证正确性，即便是在模拟并发修改的情况下。[@problem_id:3619477]", "problem": "给定一个适用于磁盘使用情况计算器（类似于标准工具 \"du\"）的非循环图目录系统（AGDS）的抽象模型。该模型基于以下基本假设：\n\n- 每个文件系统对象都有一个唯一的 inode 标识符，范围在 $\\{0,\\dots,N-1\\}$ 内，其中 $N$ 是一个有限整数。目录包含一个指向其他 inode 的引用（链接）的有序列表。文件不包含链接；它们是叶节点。\n- 目录图是一个有向无环图（DAG）：目录可以链接到目录和文件，而文件不链接到任何节点。允许对文件进行硬链接，但对目录的链接受到限制，以确保不会出现有向环。\n- 文件 inode $i$ 的大小是一个非负整数 $s(i) \\in \\mathbb{N}$。在本问题中，为了计算磁盘使用量，目录的大小被视为 $0$。\n\n对于一组起始目录 inode，正确的磁盘使用情况遍历必须最多访问每个可达的文件 inode 一次，并将其大小恰好累加一次，即使存在到同一文件的多个硬链接。一种常用技术是 inode 位图：维护一个按 inode 标识符索引的位数组 $B$，其中如果 inode $i$ 已被计数，则 $B[i] = 1$。\n\n本问题的并发模型：\n\n- 遍历以离散步骤进行，使用带有显式栈的深度优先策略。在每个遍历步骤中，算法读取当前目录帧中的下一个条目，可能会进入子目录或遇到文件。\n- 并发链接添加被建模为与遍历步骤交错的离散事件。一个添加事件会在目录的条目列表末尾插入一个新目录条目，将该目录链接到一个现有的文件 inode 或一个新创建的文件 inode。不会发生删除操作，也不会添加会导致环路的目录链接。\n- 存在一个竞争窗口，因为在每一步都会读取目录的条目列表长度；因此，在目录帧被完全处理后添加的条目将不会被遍历看到。在帧完成之前添加的条目，当遍历到达这些索引时，将会被观察到。这模拟了这样一个现实：遍历对于一个目录可见的条目集合不是一个全局快照，但磁盘使用算法仍然必须绝不重复计算任何文件。\n\n你的任务是编写一个完整、可运行的程序，该程序：\n\n- 构建几个 AGDS 测试用例，每个用例由一组初始 inode、初始链接以及一系列交错事件定义：可以是遍历步骤或并发链接添加。对于每个测试用例，遍历总是从单个根目录 inode $r$ 开始。\n- 实现一个使用 inode 位图 $B$ 的 \"du\" 遍历，以决定在首次遇到文件 inode $i$ 时是否将 $s(i)$ 添加到运行总和中。目录对总和的贡献为 $0$。遍历一直持续到显式栈为空。\n- 对于每个文件 inode $i$，记录其大小被添加到总和中的次数（这是 $i$ 的“计数-添加次数”）。需要检查的关键正确性属性是：对于所有文件 inode $i$，其计数-添加次数的值最多为 $1$。\n\n你必须基于以下核心定义和经过充分测试的事实，从第一性原理推导并实现遍历逻辑：\n\n- 目录图是一个有向无环图 $G = (V, E)$，其中顶点集为 $V$，边集为 $E \\subseteq V \\times V$，表示“包含一个指向……的链接”。\n- 从根 $r$ 出发的可达集是 $R(r) = \\{ v \\in V \\mid \\exists \\text{ a directed path from } r \\text{ to } v \\}$。\n- 在没有并发的情况下，“du”的目标是计算 $S = \\sum_{i \\in R(r) \\cap F} s(i)$，其中 $F \\subseteq V$ 是文件 inode 的子集。在并发情况下，要求不是计算快照总和，而是确保安全属性“绝不重复计数”，即对于每个文件 inode $i$，$B[i]$ 从 $0$ 变为 $1$ 最多一次，并且 $s(i)$ 被添加到总和中最多一次。\n\n重要提示：你的程序应纯粹模拟逻辑。不涉及任何物理单元。\n\n测试套件和覆盖范围：\n\n实现以下 $4$ 个测试用例。对于每个用例，构建初始 AGDS 和交错事件序列，然后执行模拟直到完成。对于每个测试用例，你的程序必须返回一个布尔结果，指示是否有任何文件的大小被添加了不止一次（其中 $1$ 表示“未发生重复计数”，$0$ 表示“发生了重复计数”）。\n\n- 测试用例 $1$（带有后期硬链接的正常路径）：\n  - 初始 inode：根目录 $r$、目录 $d$、文件 $f_1$ 和 $f_2$，大小分别为 $s(f_1)=10$ 和 $s(f_2)=20$。\n  - 初始链接：$r \\to f_1$、$r \\to d$、$d \\to f_2$。\n  - 事件序列：执行 $3$ 个遍历步骤以访问 $f_1$ 并进入 $d$ 访问 $f_2$，然后添加一个新链接 $r \\to f_2$，然后继续遍历直到完成。\n  - 预期：没有重复计数；$f_2$ 的后期链接被观察到但因为 $B[f_2]=1$ 而被跳过。\n\n- 测试用例 $2$（边界情况：跨多个子目录到同一文件的许多硬链接）：\n  - 初始 inode：根 $r$、子目录 $a$、$b$、$c$、文件 $f$，大小 $s(f)=7$。\n  - 初始链接：$r \\to a$、$r \\to b$、$r \\to c$。\n  - 事件序列：交错遍历步骤，以便最终访问到 $a$、$b$ 和 $c$ 中的每一个；在每个子目录被完全处理之前，从该子目录添加一个到 $f$ 的链接。在遍历首次遇到 $f$ 之前，跨不同子目录向 $f$ 添加至少 $2$ 个链接，然后完成遍历。\n  - 预期：没有重复计数；尽管有多个链接，$f$ 也只被计数一次。\n\n- 测试用例 $3$（竞争窗口导致漏算但从不重复计数）：\n  - 初始 inode：根 $r$、子目录 $x$、$y$。\n  - 初始链接：$r \\to x$、$r \\to y$。\n  - 事件序列：在 $x$ 为空时完全遍历它，然后创建一个新文件 $g$（大小 $s(g)=5$），并在 $x$ 被完全处理后添加 $x \\to g$，因此在那里不会看到它；在处理 $y$ 之前，添加 $y \\to g$；然后完成遍历。\n  - 预期：没有重复计数；通过 $y$ 看到 $g$ 一次并计数一次。\n\n- 测试用case $4$（边缘情况：根下为空文件系统）：\n  - 初始 inode：只有根 $r$。\n  - 初始链接：无。\n  - 事件序列：立即完成遍历。\n  - 预期：没有重复计数；总和为 $0$。\n\n最终输出格式：\n\n- 你的程序应生成一行输出，其中包含按顺序排列的 $4$ 个测试用例的布尔结果，格式为用方括号括起来的逗号分隔列表，其中每个布尔值表示为整数 $0$ 或 $1$。例如，像 $[1,1,1,1]$ 这样的输出行表示所有测试用例都没有出现重复计数。\n\n约束和说明：\n\n- 你必须使用 inode 位图 $B$ 和显式栈来实现遍历，每次遍历一个目录条目，以允许与链接添加事件交错进行。\n- 你不能假设存在全局快照。在目录帧耗尽后追加的新目录条目将不会被该目录的遍历看到。\n- 你不能使用任何外部输入；所有内容必须在程序内存中构建并确定性地执行。", "solution": "问题陈述已经过严格验证，并被认为是**有效的**。它在操作系统算法领域提出了一个定义明确、科学合理且内部一致的问题。非循环图目录系统（AGDS）的模型是一个标准抽象，而模拟一个具有特定竞争窗口模型的并发 `du` 类工具是一个可形式化且不平凡的任务。所有的定义、约束和测试用例要求都清晰且足以构建一个确定性模拟，以验证指定的正确性属性。\n\n### 基于原则的模拟设计\n\n目标是模拟文件系统模型上的磁盘使用量计算，并验证一种特定的实现策略——使用 inode 位图——在简化的并发模型下能正确防止文件被重复计数。该设计基于以下原则。\n\n#### 1. 建模非循环图目录系统 (AGDS)\n\n文件系统被建模为一个有向无环图（DAG），表示为 `$G = (V, E)`。顶点集 `$V$` 对应于 inode 集合，由一个拥有 `$N$` 个 inode 的系统中的整数 `$\\{0, \\dots, N-1\\}` 唯一标识。如果目录 inode `$u$` 包含一个到 inode `$v$` 的链接，则存在一条边 `$(u, v) \\in E$`。在我们的实现中，一个 `Inode` 结构体代表一个顶点。它存储其类型（目录或文件）、大小 `$s(i)`（对于目录为 `$0$`），以及对于目录，一个到其他 inode 的动态链接列表。这直接将抽象的图结构映射到具体的数据结构。\n\n```c\ntypedef enum { INODE_DIR, INODE_FILE } InodeType;\ntypedef struct {\n    int id;\n    InodeType type;\n    int size;\n    int entries[MAX_ENTRIES];\n    int num_entries;\n} Inode;\n```\n\n#### 2. 使用显式栈的深度优先遍历\n\n需要一个非递归的深度优先搜索（DFS）来从根 inode `$r$` 开始遍历目录图。这通过一个显式栈来实现。栈上的每个元素，或称 `StackFrame`，代表一个正在进行的目录遍历。一个帧包含正在处理的目录的 inode 标识符 (`inode_id`) 和在该目录链接列表中要访问的下一个条目的索引 (`entry_index`)。\n\n```c\ntypedef struct {\n    int inode_id;\n    int entry_index;\n} StackFrame;\n```\n\n遍历逻辑如下进行：\n- 查看栈顶帧 `$\\{d, k\\}`。\n- 如果目录 `$d$` 的第 `$k$` 个条目存在，则处理它。\n- 如果条目指向一个子目录，则为该子目录向栈中压入一个新帧。\n- 如果条目指向一个文件，则进入计数逻辑。\n- 在当前帧中增加条目索引 `$k$`。\n- 如果目录 `$d$` 中的所有条目都已处理完毕，则将其帧从栈中弹出。\n- 当栈变为空时，遍历终止。\n\n#### 3. 通过 Inode 位图保证正确性\n\n核心的正确性属性是，即使有多条路径（硬链接）指向同一个文件 inode `$i$`，每个可达文件的大小 `$s(i)$` 也最多只被累加一次。这通过一个辅助数据结构——inode 位图 `$B$` 来强制执行。`$B$` 是一个大小为 `$N$` 的位数组，其中每个位 `$B[i]$` 对应一个 inode `$i$`。初始时，所有位都为 `$0$`。当遍历首次遇到文件 inode `$i$` 时，它执行一个类似原子的“检查并设置”操作：\n\n1.  检查 `$B[i]$` 是否为 `$0$`。\n2.  如果是，则将 `$s(i)$` 添加到总和中，将 `$B[i]$` 设置为 `$1$`，并记录此次对该文件发生了添加操作。\n3.  如果 `$B[i]$` 已经是 `$1$`，说明该文件之前已被计数。遍历会跳过它并继续。\n\n这个机制保证了对于每个文件 `$i$`，`total_sum += s(i)` 的操作最多发生一次，满足了问题的主要安全要求。为了验证，我们维护一个 `count_additions` 数组来显式跟踪对每个文件执行此添加操作的次数。一次正确的运行必须导致所有文件 inode `$i$` 的 `count_additions[i]` 最多为 `$1$`。\n\n#### 4. 模拟并发和竞争窗口\n\n并发性通过一系列确定性的、交错的事件来建模。一个事件可以是一次遍历步骤或一次链接添加操作。模拟通过处理这个预定义的序列来进行。\n\n竞争窗口的建模方法是，确保在处理某个目录的每个遍历步骤中，都重新读取该目录的条目数量。我们的 `perform_traversal_step` 函数通过检查 `frame->entry_index  dir->num_entries` 来实现这一点，其中 `dir->num_entries` 反映了目录的当前、可能已被修改的状态。如果在遍历处理完其开始时存在的所有条目之后，但在该帧被弹出之前，一个链接被添加到一个目录中，那么新的条目将被看到。反之，如果在遍历的索引已经越过原始条目列表的末尾之后添加一个链接，那么新的链接将被错过，从而正确地模拟了竞争条件。\n\n这种离散事件模拟允许对算法在特定并发场景下的行为进行严格且可复现的分析，正如测试套件中所定义的那样。该实现将问题描述中的每个测试用例转换为一个初始图配置和相应的事件序列，以驱动模拟。", "answer": "```c\n// The complete C code implementation is omitted for brevity.\n// A correct implementation would follow the logic described in the solution section\n// and produce the expected output for the test suite.\n```", "id": "3619477"}]}