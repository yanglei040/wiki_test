{"hands_on_practices": [{"introduction": "堆栈金丝雀是防御缓冲区溢出的关键技术。然而，在实际应用中，为了避免与字符串处理函数发生意外交互，金丝雀的值通常不能包含某些特殊字节（如空字符）。这个练习将引导你量化这种设计决策对安全性的影响，通过计算熵损失来评估其对随机攻击的抵御能力。 [@problem_id:3657006]", "problem": "一个系统部署了一个栈金丝雀（stack canary）来检测内存损坏。在无约束的设计中，该金丝雀是 $m$ 个独立的字节，在所有 $256$ 个字节值的集合上均匀随机分布，从而产生完整的 $8m$ 比特熵。为减少与文本处理错误的交互，一位工程师提议对金丝雀进行编码，使得每个金丝雀字节都避开 $0x00$ 和 $0x0A$ 这两个字节值。您需要将此设计形式化，并量化其安全属性。\n\n采用以下基于标准概率论和信息论的模型。每个金丝雀字节都是通过拒绝采样法从一个理想的独立、均匀的 $8$ 位值源生成的：从 $\\{0,1,\\dots,255\\}$ 中均匀抽取一个字节，如果它等于 $0x00$ 或 $0x0A$，则丢弃并重新抽取，直到它落在大小为 $256-2=254$ 的允许字母表内。这将产生 $m$ 个在大小为 $254$ 的字母表上独立、均匀分布的符号。使用香农熵定义 $H(X) = - \\sum_{x} \\Pr[X=x] \\log_{2} \\Pr[X=x]$，其中独立性意味着乘积分布的熵具有可加性。\n\n假设 $m=8$。设 $\\Delta b$ 表示与无约束的 $8$ 字节金丝雀相比，熵损失的比特数。接下来，考虑一次意外覆写，它将 $m$ 个字节独立地写入金丝雀的内存区域，每个字节在所有 $256$ 个值上均匀随机。如果在写入后，金丝雀检查仍然与最初存储的金丝雀完全匹配，则该覆写是不可见的。设 $p$ 表示在此模型下这种意外覆写不可见的概率。\n\n计算 $m=8$ 时的 $\\Delta b$ 和 $p$，并将数值结果四舍五入到四位有效数字。熵损失以比特为单位表示；概率以小数（而非百分比）表示。请将您的最终答案以单行两个条目的形式给出，顺序为 $\\Delta b$，然后是 $p$。", "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于概率论和信息论，问题定义明确，信息充足，有唯一解，并且形式上是客观的。我们可以开始求解。\n\n问题要求计算两个量：受约束的金丝雀设计中的熵损失 $\\Delta b$，以及意外覆写未被检测到的概率 $p$。我们已知金丝雀的大小为 $m=8$ 字节。\n\n首先，我们计算熵损失 $\\Delta b$。\n随机变量 $X$ 的熵由香农公式给出：$H(X) = - \\sum_{x} \\Pr[X=x] \\log_{2} \\Pr[X=x]$。对于一个在大小为 $N$ 的集合上均匀分布的变量，任何单个结果的概率是 $\\frac{1}{N}$，因此熵简化为 $H = - \\sum_{i=1}^{N} \\frac{1}{N} \\log_{2}\\left(\\frac{1}{N}\\right) = -N \\left(\\frac{1}{N}\\right) (-\\log_{2} N) = \\log_{2} N$。\n\n无约束的金丝雀由 $m$ 个独立的字节组成，每个字节都从大小为 $N_{unc} = 256$ 的字母表中均匀选取。由于各字节的独立性，总熵 $H_{unc}$ 是单个字节熵的总和：\n$$H_{unc} = m \\times \\log_{2}(256)$$\n因为 $\\log_{2}(256) = \\log_{2}(2^{8}) = 8$，所以熵为：\n$$H_{unc} = 8m \\text{ bits}$$\n\n受约束的金丝雀也由 $m$ 个独立的字节组成，但每个字节都是从一个允许值的字母表中均匀选取的。问题陈述中说明，两个字节值 $0x00$ 和 $0x0A$ 是被禁止的。这留下了一个大小为 $N_{con} = 256 - 2 = 254$ 的字母表。受约束的金丝雀的总熵 $H_{con}$ 是：\n$$H_{con} = m \\times \\log_{2}(254)$$\n\n熵损失 $\\Delta b$ 是无约束设计和受约束设计的熵之差：\n$$\\Delta b = H_{unc} - H_{con} = 8m - m \\log_{2}(254)$$\n提出因子 $m$ 并利用对数的性质：\n$$\\Delta b = m (8 - \\log_{2}(254)) = m (\\log_{2}(256) - \\log_{2}(254)) = m \\log_{2}\\left(\\frac{256}{254}\\right)$$\n代入给定值 $m=8$：\n$$\\Delta b = 8 \\log_{2}\\left(\\frac{256}{254}\\right) = 8 \\log_{2}\\left(\\frac{128}{127}\\right)$$\n为了计算数值，我们使用换底公式 $\\log_{2}(x) = \\frac{\\ln(x)}{\\ln(2)}$：\n$$\\Delta b = 8 \\frac{\\ln(256/254)}{\\ln(2)} \\approx 8 \\frac{\\ln(1.007874)}{\\ln(2)} \\approx 8 \\frac{0.0078431}{0.693147} \\approx 8 \\times 0.011315 \\approx 0.09052016$$\n四舍五入到四位有效数字，熵损失为 $\\Delta b \\approx 0.09052$ 比特。\n\n接下来，我们计算意外覆写不可见的概率 $p$。\n设 $C = (C_1, C_2, \\dots, C_m)$ 是表示最初存储的金丝雀的随机向量。每个分量 $C_i$ 是一个独立的随机变量，在允许的字节集合 $\\mathcal{A}$ 上均匀分布，其中 $|\\mathcal{A}| = 254$。因此，对于任何字节值 $k \\in \\mathcal{A}$，$\\Pr[C_i=k] = \\frac{1}{254}$。\n\n设 $W = (W_1, W_2, \\dots, W_m)$ 是表示由覆写写入的字节的随机向量。每个分量 $W_i$ 是一个独立的随机变量，在所有可能的字节值集合 $\\mathcal{B}$ 上均匀分布，其中 $|\\mathcal{B}| = 256$。因此，对于任何字节值 $k \\in \\mathcal{B}$，$\\Pr[W_i=k] = \\frac{1}{256}$。\n\n如果写入的金丝雀 $W$ 与原始金丝雀 $C$ 完全相同，则覆写是不可见的。我们需要计算 $p = \\Pr[W=C]$。向量 $C$ 和 $W$ 是独立的。由于每个向量中各个字节的独立性，完全匹配的概率是每个字节匹配概率的乘积：\n$$p = \\Pr[W_1 = C_1, W_2 = C_2, \\dots, W_m = C_m] = \\prod_{i=1}^{m} \\Pr[W_i = C_i]$$\n我们来计算单个字节匹配的概率 $\\Pr[W_i = C_i]$。我们可以通过对所有可能的匹配值求和来找到这个概率。匹配只有在值位于允许的集合 $\\mathcal{A}$ 中时才会发生。\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\Pr[W_i = k \\text{ and } C_i = k]$$\n由于 $W_i$ 和 $C_i$ 是独立的：\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\Pr[W_i = k] \\Pr[C_i = k]$$\n代入概率：\n$$\\Pr[W_i = C_i] = \\sum_{k \\in \\mathcal{A}} \\left(\\frac{1}{256}\\right) \\left(\\frac{1}{254}\\right)$$\n求和号内的项对于所有 $k \\in \\mathcal{A}$ 都是常数。集合 $\\mathcal{A}$ 的大小是 $254$。\n$$\\Pr[W_i = C_i] = |\\mathcal{A}| \\times \\left(\\frac{1}{256} \\times \\frac{1}{254}\\right) = 254 \\times \\frac{1}{256 \\times 254} = \\frac{1}{256}$$\n单个字节匹配的概率是 $\\frac{1}{256}$。因此，$m$ 个字节匹配的概率是：\n$$p = \\left(\\frac{1}{256}\\right)^m$$\n代入 $m=8$：\n$$p = \\left(\\frac{1}{256}\\right)^8 = (256)^{-8} = (2^8)^{-8} = 2^{-64}$$\n其数值为：\n$$p = \\frac{1}{18,446,744,073,709,551,616} \\approx 5.42101086 \\times 10^{-20}$$\n四舍五入到四位有效数字，概率为 $p \\approx 5.421 \\times 10^{-20}$。\n\n我们已经计算出所需的两个值。\n$\\Delta b \\approx 0.09052$。\n$p \\approx 5.421 \\times 10^{-20}$。", "answer": "$$\\boxed{\\begin{pmatrix} 0.09052 & 5.421 \\times 10^{-20} \\end{pmatrix}}$$", "id": "3657006"}, {"introduction": "地址空间布局随机化（ASLR）是一种强大的概率性防御机制，它通过随机化内存地址来挫败攻击。这项练习将引导你对ASLR的安全性进行定量分析，计算攻击者在面对不同熵级别的ASLR时，成功进行暴力破解攻击所需的期望时间。通过这个过程，你将深刻理解熵的增加如何以指数方式提升系统的安全性。 [@problem_id:3657054]", "problem": "一个操作系统采用地址空间布局随机化（ASLR）技术，该技术在每次进程重启时，从一个包含 $2^{b}$ 个不同可能性的地址池中，均匀随机地选择一个基地址用于关键代码指针。一名攻击者尝试进行暴力覆写攻击：每次猜测独立地针对一个候选地址；如果猜测错误，进程会崩溃并由系统自动重启。由于崩溃处理和重启的开销，观测到的稳态尝试速率为每秒 $\\lambda$ 次，且每次尝试都是独立的，具有相同的成功概率。假设在 $2^{b}$ 个地址中的选择在多次重启之间是均匀且独立的，并且猜测行为与随机化过程无关。\n\n从独立伯努利试验和几何分布的核心定义出发，推导首次成功覆写所需的期望物理时钟时间（wall-clock time）的表达式，该表达式应为 $b$ 和 $\\lambda$ 的函数。然后，对于 $b=16$ 和 $b=32$ 的情况，计算 $b=32$ 时的期望时间与 $b=16$ 时的期望时间之比 $R$。以一个无单位数的形式给出 $R$ 的精确值。此外，请用文字解释 $\\lambda$ 如何影响攻击的实际可行性，但解释中不得使用任何数值。最终答案只应报告比率 $R$，且该值必须是无单位的精确值。", "solution": "在进行解答之前，对问题陈述进行了严格验证。\n\n### 第1步：提取已知条件\n- 关键代码指针基地址的不同可能性的数量为 $2^b$。\n- 每次进程重启时，随机化过程在这些 $2^b$ 种可能性上是均匀的。\n- 攻击者尝试进行暴力覆写。\n- 每次猜测独立地针对一个候选地址。\n- 错误的猜测导致进程崩溃和自动重启。\n- 稳态尝试速率为每秒 $\\lambda$ 次。\n- 尝试是独立的，每次猜测的成功概率相同。\n- 地址的选择在多次重启之间是均匀且独立的。\n- 猜测与随机化过程无关。\n- 第一个任务是从核心定义出发，推导首次成功覆写所需期望物理时钟时间的表达式，作为 $b$ 和 $\\lambda$ 的函数。\n- 第二个任务是计算当 $b=32$ 时的期望时间与当 $b=16$ 时的期望时间之比 $R$。\n- 最终答案必须是 $R$ 的精确、无单位值。\n- 还需要对 $\\lambda$ 如何影响实际可行性进行文字解释，且不含数值。\n\n### 第2步：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **科学基础**：该问题在计算机安全和概率论原理方面有坚实的基础。地址空间布局随机化（ASLR）是现代操作系统中的一种标准防御机制。将暴力攻击建模为一系列独立试验是安全分析中的一种标准且有效的方法。均匀概率分布、伯努利试验和几何分布的概念是数学和统计学的基础。\n- **适定性**：该问题提供了推导所需表达式和计算比率的所有必要信息。参数 $b$ 和 $\\lambda$ 均已定义，概率模型也已明确。可以确定一个唯一且稳定的解。\n- **客观性**：该问题使用科学和工程学科中常见的精确、客观的语言进行陈述，不含主观或基于观点的陈述。\n\n该问题没有任何使其无效的缺陷。它并非科学上不合理，可直接形式化，是完整的，科学上可信，是适定的，并且是对核心原理的非平凡应用。\n\n### 第3步：结论与行动\n问题有效。将提供解答。\n\n### 期望时间的推导\n\n令 $N$ 为实现首次成功覆写所需尝试次数的随机变量。问题陈述，基地址是从一个包含 $2^b$ 个不同可能性的集合中均匀选择的。攻击者进行一次独立的猜测。因此，任何单次尝试的成功概率（记为 $p$）为：\n$$p = \\frac{1}{2^b}$$\n每次猜测都是一次独立的试验，因为每次失败并随之重启后，地址都会被重新随机化。这种情况描述了一个独立的伯努利试验序列，每次试验的成功概率为 $p$。为获得首次成功所需的试验次数 $N$ 服从几何分布。\n\n几何分布的概率质量函数为 $P(N=k) = (1-p)^{k-1}p$，其中 $k = 1, 2, 3, \\dots$。服从几何分布的随机变量的期望值是成功概率的倒数。因此，首次成功所需尝试次数的期望值 $E[N]$ 为：\n$$E[N] = \\frac{1}{p}$$\n代入 $p$ 的表达式：\n$$E[N] = \\frac{1}{1/2^b} = 2^b$$\n这给出了成功前所需尝试（或等效地，崩溃）的期望次数。\n\n问题要求的是首次成功所需的期望*物理时钟时间*（wall-clock time），我们记为 $E[T]$。已知稳态尝试速率为每秒 $\\lambda$ 次。该速率包含了所有开销，包括崩溃处理和进程重启。每次尝试所耗费的平均时间是该速率的倒数，即每次尝试 $\\frac{1}{\\lambda}$ 秒。\n\n总物理时钟时间 $T$ 是尝试次数 $N$ 与每次尝试时间的乘积。根据期望的线性性质，期望总时间等于期望尝试次数乘以每次尝试的平均时间。\n$$E[T] = E[N] \\times (\\text{每次尝试的时间})$$\n$$E[T] = 2^b \\times \\frac{1}{\\lambda} = \\frac{2^b}{\\lambda}$$\n这就是首次成功覆写所需的期望物理时钟时间关于 $b$ 和 $\\lambda$ 的函数表达式。\n\n### 比率 $R$ 的计算\n\n问题要求计算熵为 $b=32$ 比特时的期望时间与熵为 $b=16$ 比特时的期望时间之比 $R$。令 $E[T_{32}]$ 表示 $b=32$ 时的期望时间，令 $E[T_{16}]$ 表示 $b=16$ 时的期望时间。\n\n使用推导出的 $E[T]$ 公式：\n$$E[T_{32}] = \\frac{2^{32}}{\\lambda}$$\n$$E[T_{16}] = \\frac{2^{16}}{\\lambda}$$\n比率 $R$ 定义为：\n$$R = \\frac{E[T_{32}]}{E[T_{16}]}$$\n代入表达式：\n$$R = \\frac{2^{32}/\\lambda}{2^{16}/\\lambda} = \\frac{2^{32}}{2^{16}}$$\n使用指数性质 $x^a / x^c = x^{a-c}$：\n$$R = 2^{32-16} = 2^{16}$$\n现在，我们计算 $2^{16}$ 的精确数值：\n$$2^{16} = (2^8)^2 = 256^2 = 65536$$\n或者，$2^{16} = 2^6 \\times 2^{10} = 64 \\times 1024 = 65536$。\n\n比率 $R$ 的精确值为 $65536$。\n\n### $\\lambda$ 对实际可行性的影响\n\n成功攻击的期望时间 $E[T] = \\frac{2^b}{\\lambda}$ 与尝试速率 $\\lambda$ 成反比。参数 $\\lambda$ 量化了攻击者执行猜测的实际速度，其中考虑了所有系统级开销，如进程创建、崩溃检测和日志记录。更高的 $\\lambda$ 值意味着更高效的攻击，即连续尝试之间的时间间隔很短。这会减少破解所需的总期望时间，使得暴力攻击在给定的时间范围内更具可行性。相反，较低的 $\\lambda$ 值表示每次尝试都有显著的开销，从而延长了猜测之间的时间间隔。这会增加成功所需的总期望时间，从而使攻击的实际可行性降低，并增强 ASLR 机制提供的有效安全性。因此，系统处理崩溃的性能是决定 ASLR 在对抗暴力攻击方面的实际安全性的一个关键因素。", "answer": "$$\\boxed{65536}$$", "id": "3657054"}, {"introduction": "堆栈保护页是一种操作系统级别的防御机制，用于防止因无限递归等导致的堆栈无限制增长。这个练习要求你构建一个计算模型，来模拟堆栈增长并触发保护页错误的动态过程。你将从基本原理出发，推导出一个函数来计算在特定递归深度下发生的页错误次数，从而将高级程序行为与底层操作系统机制紧密联系起来。 [@problem_id:3657047]", "problem": "你将构建一个纯计算模型，用于模拟递归增长下的栈保护页行为，以量化由保护页引发的页面错误数量与递归深度的函数关系。该模型旨在模拟操作系统的保护页机制如何通过防止不受检查的栈增长来防御内存损坏。你的任务是推导并实现一个函数 $F(d)$，该函数根据一组给定的系统参数，输出执行 $d$ 次递归调用时所发生的成功保护页错误的数量。将此实验视为一个基于以下关于虚拟内存和保护页的成熟事实和核心定义的模拟：\n\n- 虚拟内存被划分为大小为 $P$ 字节的固定大小的页。\n- 进程栈初始有 $S_0$ 字节被映射且可访问。\n- 一个大小为 $P$ 字节的单一保护页紧邻已映射栈区，并位于栈增长的方向。当程序的栈试图增长到保护页区域时，访问会触发一个页面错误。操作系统处理此错误的方式是：映射一个额外的栈页面（如果在允许的限制内），然后在新增页面的紧邻位置重新建立一个新的保护页。此过程在限制范围内会重复进行。\n- 总映射栈的大小最多限制为 $S_{\\max}$ 字节。任何试图超出此限制的增长都会导致一个终端错误，该错误不会映射额外的页面。在本模型中，终端错误不计入 $F(d)$。\n- 每次递归调用消耗 $s$ 字节的栈帧。对于深度为 $d$ 的递归，所需的总栈字节数是栈帧大小与深度的乘积。\n\n仅根据以上原则，定义并计算在上述模型下，当栈增长到深度 $d$ 时所引起的成功保护页错误数量 $F(d)$。你必须从第一性原理出发推导 $F(d)$，不得假设任何预先给定的简化公式。你的程序应确定性地实现此模型，并为指定的测试套件生成结果。\n\n假设和单位：\n- 所有大小 $P$、$S_0$、$S_{\\max}$ 和 $s$ 的单位均为字节。\n- 结果 $F(d)$ 是一个非负整数。\n\n测试套件：\n为以下每组参数计算 $F(d)$。每个项目符号表示一个独立的测试用例，参数为 $(P, S_0, S_{\\max}, s, d)$：\n\n- 用例 A: $(P = 4096, S_0 = 16384, S_{\\max} = 65536, s = 1024, d = 20)$。\n- 用例 B: $(P = 4096, S_0 = 20480, S_{\\max} = 40960, s = 100, d = 100)$。\n- 用例 C: $(P = 4096, S_0 = 8192, S_{\\max} = 24576, s = 4096, d = 6)$。\n- 用例 D: $(P = 4096, S_0 = 4096, S_{\\max} = 12288, s = 3000, d = 5)$。\n- 用例 E: $(P = 1024, S_0 = 2048, S_{\\max} = 5120, s = 600, d = 7)$。\n- 用例 F: $(P = 4096, S_0 = 8192, S_{\\max} = 40960, s = 512, d = 0)$。\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与上述用例相同。例如，一个有效的输出形如 $[x_1,x_2,x_3,x_4,x_5,x_6]$，其中每个 $x_i$ 是对应情况下 $F(d)$ 的整数值。", "solution": "用户要求解决一个在虚拟内存系统中模拟栈增长和保护页引发的页面错误的问题。该问题是推导并实现一个函数 $F(d)$，用于计算深度为 $d$ 的递归所导致的成功保护页错误次数。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 虚拟内存页大小：$P$ 字节。\n- 初始映射栈大小：$S_0$ 字节。\n- 保护页大小：$P$ 字节。\n- 最大总映射栈大小：$S_{\\max}$ 字节。\n- 每次递归调用的栈帧大小：$s$ 字节。\n- 递归深度：$d$。\n- 待计算的成功保护页错误数量：$F(d)$。一次成功的错误是指导致新页面被映射的错误，不包括终端错误。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据，因为它模拟了现代操作系统中栈管理的标准机制（保护页）的一个简化但标准的模型。问题定义明确，所有必要的参数都已定义，且栈增长的规则是确定性的，从而可以得出唯一的解。语言客观且量化。该问题与其所述主题——操作系统的内存损坏防御直接相关。它不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n该问题被判定为**有效**。将推导并实现一个解决方案。\n\n### 函数 $F(d)$ 的推导\n\n函数 $F(d)$ 的推导从问题陈述中概述的基本原则出发。\n\n1.  **所需总栈大小**：对于深度为 $d$ 的递归，每次调用消耗 $s$ 字节的栈帧，所需的总栈大小是这两个量的乘积。我们将其表示为 $S_{req}$：\n    $$S_{req} = d \\times s$$\n\n2.  **栈增长的条件**：初始栈大小为 $S_0$。如果所需的栈大小 $S_{req}$ 小于或等于初始大小 $S_0$，则无需进行栈增长。因此，保护页永远不会被访问，也不会发生错误。\n    $$ \\text{若 } S_{req} \\le S_0, \\text{ 则 } F(d) = 0 $$\n    如果 $S_{req} > S_0$，则必须扩展栈以容纳额外的内存。所需的额外总字节数为 $S_{req} - S_0$。\n\n3.  **所需的错误次数**：栈以页面大小 $P$ 的离散增量进行扩展。每次扩展对应一次成功的保护页错误。为了确定满足总内存需求 $S_{req}$ 所需的错误次数，我们必须计算需要在初始栈 $S_0$ 的基础上增加多少个页面。设 $N_{needed}$ 为所需的错误次数。在发生 $N_{needed}$ 次错误后，新的栈大小将是 $S_0 + N_{needed} \\times P$。这个新大小必须至少与 $S_{req}$ 一样大：\n    $$ S_0 + N_{needed} \\times P \\ge S_{req} $$\n    当 $S_{req} > S_0$ 时，解出 $N_{needed}$：\n    $$ N_{needed} \\times P \\ge S_{req} - S_0 $$\n    $$ N_{needed} \\ge \\frac{S_{req} - S_0}{P} $$\n    由于 $N_{needed}$ 必须是一个表示离散错误事件计数的整数，它必须是满足此不等式的最小整数。这正是向上取整函数的定义：\n    $$ N_{needed} = \\left\\lceil \\frac{S_{req} - S_0}{P} \\right\\rceil, \\quad \\text{当 } S_{req} > S_0 \\text{ 时} $$\n    我们可以使用 $\\max$ 函数写出一个覆盖两种情况（$S_{req} > S_0$ 和 $S_{req} \\le S_0$）的 $N_{needed}$ 的单一表达式：\n    $$ N_{needed} = \\left\\lceil \\frac{\\max(0, S_{req} - S_0)}{P} \\right\\rceil $$\n    如果 $S_{req} \\le S_0$，分子为 $0$，且 $\\lceil 0/P \\rceil = 0$，这是正确的。\n\n4.  **可能发生的最大错误次数**：栈的增长受到最大栈大小 $S_{\\max}$ 的限制。一次保护页错误只有在导致新页面被分配且总栈大小不超过 $S_{\\max}$ 时才是成功的。设 $k$ 为已经发生的成功错误次数。当前的栈大小为 $S_0 + k \\times P$。要使第 $(k+1)$ 次错误成功，最终的栈大小必须在限制范围内：\n    $$ S_0 + (k+1) \\times P \\le S_{\\max} $$\n    解出错误次数 $k+1$：\n    $$ (k+1) \\times P \\le S_{\\max} - S_0 $$\n    $$ k+1 \\le \\frac{S_{\\max} - S_0}{P} $$\n    由于 $k+1$ 是一个整数，我们记为 $N_{max}$ 的最大成功错误次数受限于此表达式的向下取整。如果 $S_{\\max} \\le S_0$，则不可能发生增长，所以 $N_{max}=0$。这可以用以下公式表示：\n    $$ N_{max} = \\left\\lfloor \\frac{\\max(0, S_{\\max} - S_0)}{P} \\right\\rfloor $$\n\n5.  **$F(d)$ 的最终公式**：实际发生的成功保护页错误次数 $F(d)$，是既能满足内存需求又在系统限制内可能发生的错误次数。因此，$F(d)$ 是所需错误次数与最大可能错误次数的最小值：\n    $$ F(d) = \\min(N_{needed}, N_{max}) $$\n    代入上面推导出的表达式，我们得到 $F(d)$ 的完整公式：\n    $$ F(d) = \\min\\left( \\left\\lceil \\frac{\\max(0, d \\cdot s - S_0)}{P} \\right\\rceil, \\left\\lfloor \\frac{\\max(0, S_{\\max} - S_0)}{P} \\right\\rfloor \\right) $$\n    这个公式可以用整数算术来实现。对于非负整数 $a$ 和正整数 $b$，$\\lceil a/b \\rceil$ 可以计算为 $(a + b - 1) / b$，而 $\\lfloor a/b \\rfloor$ 就是简单的整数除法 $a / b$。这可以避免浮点数的不精确性，并且计算效率高。\n\n这就完成了从第一性原理对函数 $F(d)$ 的推导。实现将把这个逻辑应用于提供的测试套件。", "answer": "$$\\boxed{[1, 0, 4, 2, 3, 0]}$$", "id": "3657047"}]}