{"hands_on_practices": [{"introduction": "要理解可信计算，我们必须首先掌握其核心机制：度量启动（measured boot）。该过程的核心在于一个名为平台配置寄存器（PCR）的特殊硬件寄存器，它通过一种称为“扩展”的操作来记录系统组件的摘要。本练习 ([@problem_id:3679559]) 将复杂的哈希函数替换为一个简化的玩具函数，让你能够亲手计算PCR的扩展过程。通过这个练习，你将深入理解PCR值如何作为一个确定性的、不可逆的日志，一步步地记录下启动链中每个组件的“指纹”。", "problem": "您正在分析一个计算机系统中的可信启动序列。该系统使用可信平台模块（TPM）和平台配置寄存器（PCR）来记录可信计算基（TCB）的完整性。在可信启动中，每个组件的度量值都通过递推关系 $S' = H(S \\Vert d)$ 扩展到一个PCR中，其中 $S$ 是当前的PCR状态，$d$ 是下一个度量值，$H$ 是一个哈希函数。为便于精确计算，本练习使用以下玩具函数代替真实的密码学哈希函数：\n$$H(u \\Vert v) = (11u + 7v + 13) \\bmod 101.$$\n假设单个PCR被建模为一个状态机，其初始状态为 $S_0 = 0$。一项启动策略按照固定顺序度量并扩展恰好 $3$ 个TCB组件：引导加载程序、内核，然后是初始内存盘。清单列出引导加载程序的度量值为 $m_b = 23$，内核的度量值为 $m_k = 57$，初始内存盘的度量值为未知值 $x$。启动后，TPM报告的最终PCR状态为 $S_f = 88$。\n\n仅使用可信启动递推关系 $S' = H(S \\Vert d)$ 和上述玩具哈希函数 $H$，确定唯一的 $x \\in \\{0,1,\\ldots,100\\}$ 值，使得一个按给定顺序进行的恰好 $3$ 次扩展序列能从 $S_0$ 产生 $S_f$。\n\n请以整数模 $101$ 的形式提供您的答案。无需四舍五入，最终答案中不应包含任何单位。", "solution": "用户要求我在一个模拟的可信启动序列中，找到一个未知度量值 $x$ 的值。\n\n### 步骤 1：提取已知条件\n- 可信启动的递推关系为 $S' = H(S \\Vert d)$，其中 $S$ 是当前状态，$d$ 是度量值。\n- 玩具哈希函数定义为 $H(u \\Vert v) = (11u + 7v + 13) \\bmod 101$。\n- 平台配置寄存器（PCR）的初始状态为 $S_0 = 0$。\n- 按固定顺序进行恰好 $3$ 次度量。\n- 第一次度量是引导加载程序，$m_b = 23$。\n- 第二次度量是内核，$m_k = 57$。\n- 第三次度量是初始内存盘，其值为未知的 $x$。\n- $x$ 的取值范围是 $\\{0, 1, \\ldots, 100\\}$。\n- 经过 $3$ 次度量后的最终PCR状态为 $S_f = 88$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它使用了一个简化但数学上明确定义的模型来说明可信启动这一现实世界概念，这是操作系统安全领域的核心课题。使用“玩具”函数是一种公认的教学工具。该问题是适定的，提供了所有必要的信息（$S_0$、递推关系、函数 $H$、三个输入中的两个以及最终输出 $S_f$），从而可以唯一地确定第三个输入 $x$。计算涉及模运算，这是一种标准的数学工具。该问题是客观的，没有模棱两可或主观的术语。它没有违反任何无效性标准。所有给定的值都是整数，并且运算在整数模 $101$ 的范围内是封闭的。因此，该问题是有效的。\n\n### 步骤 3：进行求解\n该问题要求我们通过顺序应用度量扩展过程来确定第三个度量值 $x$。该过程包括三个步骤，从初始状态 $S_0$ 开始。\n\n设 $S_0$、$S_1$、$S_2$ 和 $S_3$ 为PCR的状态。已知 $S_0 = 0$。最终状态为 $S_3 = S_f = 88$。\n\n**第一次扩展（引导加载程序）：**\n第一次度量是引导加载程序的度量值，$d_1 = m_b = 23$。状态从 $S_0$ 转换到 $S_1$。\n$$S_1 = H(S_0 \\Vert m_b)$$\n使用给定值 $S_0 = 0$ 和 $m_b = 23$：\n$$S_1 = H(0 \\Vert 23) = (11 \\cdot 0 + 7 \\cdot 23 + 13) \\bmod 101$$\n$$S_1 = (0 + 161 + 13) \\bmod 101$$\n$$S_1 = 174 \\bmod 101$$\n为求余数，我们进行除法运算：$174 = 1 \\cdot 101 + 73$。\n$$S_1 = 73$$\n\n**第二次扩展（内核）：**\n第二次度量是内核的度量值，$d_2 = m_k = 57$。状态从 $S_1$ 转换到 $S_2$。\n$$S_2 = H(S_1 \\Vert m_k)$$\n使用计算出的值 $S_1 = 73$ 和给定的 $m_k = 57$：\n$$S_2 = H(73 \\Vert 57) = (11 \\cdot 73 + 7 \\cdot 57 + 13) \\bmod 101$$\n首先，计算乘积：\n$$11 \\cdot 73 = 803$$\n$$7 \\cdot 57 = 399$$\n现在将这些值代回表达式中：\n$$S_2 = (803 + 399 + 13) \\bmod 101$$\n$$S_2 = 1215 \\bmod 101$$\n为求余数，我们进行除法运算：$1215 = 12 \\cdot 101 + 3$。\n$$S_2 = 3$$\n\n**第三次扩展（初始内存盘）：**\n第三次也是最后一次度量是初始内存盘的值，$d_3 = x$。状态从 $S_2$ 转换到 $S_3$。已知最终状态为 $S_3 = S_f = 88$。\n$$S_3 = H(S_2 \\Vert x)$$\n使用计算出的值 $S_2 = 3$ 和最终状态 $S_3 = 88$：\n$$88 = H(3 \\Vert x) = (11 \\cdot 3 + 7 \\cdot x + 13) \\bmod 101$$\n这给了我们一个关于 $x$ 的线性同余方程：\n$$88 \\equiv (33 + 7x + 13) \\pmod{101}$$\n$$88 \\equiv (46 + 7x) \\pmod{101}$$\n为了解出 $x$，我们首先分离含有 $x$ 的项：\n$$88 - 46 \\equiv 7x \\pmod{101}$$\n$$42 \\equiv 7x \\pmod{101}$$\n模数 $101$ 是一个素数。由于 $\\gcd(7, 101) = 1$，所以 $7$ 在模 $101$ 下存在唯一的乘法逆元，我们可以用 $7$ “除”同余方程的两边。在这种情况下，除法在整数上是精确的。\n$$x \\equiv \\frac{42}{7} \\pmod{101}$$\n$$x \\equiv 6 \\pmod{101}$$\n问题指出 $x \\in \\{0, 1, \\ldots, 100\\}$。在此范围内，唯一与 $6$ 模 $101$ 同余的整数是 $6$。\n因此，初始内存盘度量值的唯一值为 $x=6$。", "answer": "$$\n\\boxed{6}\n$$", "id": "3679559"}, {"introduction": "在上一个练习的基础上，我们现在将从一个简化的模型转向一个更接近现实的场景。本练习 ([@problem_id:3679592]) 旨在揭示度量启动的一个关键特性：它对组件加载顺序的敏感性。通过比较预期的PCR值与TPM实际报告的值，你将亲眼见证启动顺序的微小改变如何导致最终哈希值的巨大差异，并理解为什么这个特性对于构建可信链至关重要。", "problem": "一个系统使用可信平台模块（TPM）实现度量启动。平台配置寄存器（PCR）的扩展操作由基本规则定义：从全零值 $PCR^{(0)} = 0^{256}$ 开始，每个新的度量摘要 $d$ 通过更新操作 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$ 并入，其中 $\\mathcal{H}$ 是一个抗碰撞的密码学哈希函数（例如，安全哈希算法256位（SHA-256）），而 $\\|$ 表示串联。在启动时度量的可信计算基（TCB）组件是三个软件组件 $A$、$B$ 和 $C$，清单（manifest）中按顺序 $(A,B,C)$ 列出它们及相应的摘要：\n- $d_{A} = \\mathrm{a3c1d2e4f50617293b4c5d6e7f8091a2b3c4d5e6f718293a4b5c6d7e8f9012ab}$,\n- $d_{B} = \\mathrm{0f1e2d3c4b5a69788796a5b4c3d2e1f0ffeeddccbbaa99887766554433221100}$,\n- $d_{C} = \\mathrm{ffffffff00000000aaaaaaaa55555555cccccccc33333333dddddddd22222222}$.\n\n为进行分析，我们提供了两个相关部分顺序中第一次和第二次扩展的预计算哈希链输出，以及两个候选完整顺序中第三次扩展的结果：\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) = \\mathrm{1111111122222222333333334444444455555555666666667777777788888888}$,\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) = \\mathrm{0123456789abcdeffedcba98765432100123456789abcdeffedcba9876543210}$,\n- $\\mathcal{H}(0^{256} \\,\\|\\, d_{C}) = \\mathrm{abcdef0123456780abcdef0123456780abcdef0123456780abcdef0123456780}$,\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) = \\mathrm{2222222233333333444444445555555566666666777777778888888899999999}$,\n- $\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) = \\mathrm{33333333444444445555555566666666777777778888888899999999aaaaaaaa}$.\n\n继续这些链进行第三次度量，产生以下结果：\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C}) = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$,\n- $\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$.\n\n一份TPM签注（quote）报告 $PCR_{0}$ 的证实值为\n$Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$。\n\n任务：\n1. 仅使用扩展规则 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$ 和提供的预计算结果，重构在遵循清单顺序 $(A,B,C)$ 的情况下预期的序列 $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$，并将最终预期的 $PCR_{0}^{(3)}$ 写成一个256位的十六进制字符串。\n2. 根据扩展操作的基本原理和给定数据，确定预期最终值与签注值 $Q$ 之间的差异是否纯粹由不同的组件顺序引起。使用提供的预计算结果，找出一个与 $Q$ 一致的顺序，并解释为什么顺序在度量启动中很重要。\n3. 通过计算预期的最终 $PCR_{0}^{(3)}$（对于清单顺序 $(A,B,C)$）与签注值 $Q$ 之间的汉明距离 $d_{H}$ 来量化差异。汉明距离 $d_{H}$ 是两个256位值在不同比特位的数量。仅提供 $d_{H}$ 的数值作为最终答案，无需四舍五入。", "solution": "该问题要求对涉及可信平台模块（TPM）及其平台配置寄存器（PCR）的度量启动过程进行三部分分析。该过程的核心是PCR扩展操作，定义为 $PCR \\leftarrow \\mathcal{H}(PCR \\,\\|\\, d)$，其中 $\\mathcal{H}$ 是一个密码学哈希函数，$PCR$ 是当前的寄存器值，$d$ 是新的度量摘要，而 $\\|$ 表示串联。我们被给予了初始状态 $PCR^{(0)} = 0^{256}$、三个组件摘要 $d_A$、$d_B$、$d_C$ 以及针对不同度量序列的几个预计算哈希值。\n\n**任务1：重构预期的PCR序列**\n\n第一个任务是重构在按清单顺序 $(A, B, C)$ 度量组件时产生的PCR值序列 $\\{PCR_{0}^{(1)}, PCR_{0}^{(2)}, PCR_{0}^{(3)}\\}$。我们从 $PCR_{0}^{(0)} = 0^{256}$ 开始，并使用提供的预计算哈希值顺序应用扩展规则。\n\n1.  **第一次度量（组件 A）：** 第一次PCR更新度量组件A。\n    $$PCR_{0}^{(1)} = \\mathcal{H}(PCR_{0}^{(0)} \\,\\|\\, d_{A}) = \\mathcal{H}(0^{256} \\,\\|\\, d_{A})$$\n    该值在问题描述中已提供：\n    $$PCR_{0}^{(1)} = \\mathrm{1111111122222222333333334444444455555555666666667777777788888888}$$\n\n2.  **第二次度量（组件 B）：** 第二次更新用组件B的摘要扩展新的 $PCR_{0}^{(1)}$。\n    $$PCR_{0}^{(2)} = \\mathcal{H}(PCR_{0}^{(1)} \\,\\|\\, d_{B}) = \\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B})$$\n    这个值也已提供：\n    $$PCR_{0}^{(2)} = \\mathrm{2222222233333333444444445555555566666666777777778888888899999999}$$\n\n3.  **第三次度量（组件 C）：** 最后一次更新用组件C的摘要扩展 $PCR_{0}^{(2)}$。这就得出了最终预期的PCR值。\n    $$PCR_{0}^{(3)} = \\mathcal{H}(PCR_{0}^{(2)} \\,\\|\\, d_{C}) = \\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{A}) \\,\\|\\, d_{B}) \\,\\|\\, d_{C})$$\n    问题为序列 $(A, B, C)$ 提供了这个最终值：\n    $$PCR_{0}^{(3)} = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$$\n如果启动过程严格遵循清单顺序 $(A, B, C)$，这就是预期的最终PCR值。\n\n**任务2：差异和顺序分析**\n\n第二个任务是分析上面计算出的预期最终PCR值与签注值 $Q$ 之间的差异，其中 $Q$ 值为：\n$$Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\n将其与顺序 $(A, B, C)$ 的预期值 $PCR_{0}^{(3)}$ 进行比较，我们发现它们并不相同。\n$PCR_{0}^{(3)} = \\mathrm{3adf...012}$\n$Q = \\mathrm{3bcf...092}$\n存在差异。问题询问这是否可以由不同的组件顺序来解释。提供的数据包含了度量顺序 $(B, A, C)$ 的最终PCR值：\n$$\\mathcal{H}(\\mathcal{H}(\\mathcal{H}(0^{256} \\,\\|\\, d_{B}) \\,\\|\\, d_{A}) \\,\\|\\, d_{C}) = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$$\n这个值与签注值 $Q$ 完全匹配。因此，该差异可以解释为系统按 $(B, A, C)$ 的顺序度量了组件，而不是指定的清单顺序 $(A, B, C)$。\n\n顺序之所以重要，是因为它对度量启动的安全保证至关重要。PCR扩展操作 $PCR_{new} = \\mathcal{H}(PCR_{old} \\,\\|\\, d)$ 是一个密码学链。在每一步中，前一个PCR值的整个状态都被用作计算下一个状态的哈希函数的输入的一部分。密码学哈希函数是确定性的，但对于串联的输入是不可交换的。也就是说，对于两个不同的输入 $x$ 和 $y$，$\\mathcal{H}(x \\,\\|\\, y) \\neq \\mathcal{H}(y \\,\\|\\, x)$ 的可能性极高。因此，最终的PCR值不仅是被度量组件的唯一密码学摘要，也是它们被度量的精确顺序的摘要。验证者将最终的PCR签注值与他们根据清单计算出的值进行比较，可以检测到启动过程中的任何偏差，包括组件的替换和启动顺序的更改。正是这个属性使得PCR能够充当启动过程的一个不可变的、对顺序敏感的日志。\n\n**任务3：量化差异**\n\n最后一个任务是通过计算预期的最终PCR值（对于顺序 $(A,B,C)$）与签注值 $Q$ 之间的汉明距离 $d_H$ 来量化差异。汉明距离是两个二进制字符串在不同比特位的数量。\n\n需要比较的两个256位值是：\n- 预期值, $E = PCR_{0}^{(3)} = \\mathrm{3adf1c0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba012}$\n- 签注值, $Q = \\mathrm{3bcf1d0b9e2f47a1c4d58376029b1e55f0a4c2d1b6e7f8930abcdeffedcba092}$\n\n我们逐个字符地比较这些字符串（每个字符代表一个4位的半字节），并对不同的半字节计算汉明距离的总和。\n\n- 位置 2 (半字节 2): $E$ 为 `a`, $Q$ 为 `b`。\n  - `a` (十六进制) = $1010_2$\n  - `b` (十六进制) = $1011_2$\n  - 按位异或: $1010_2 \\oplus 1011_2 = 0001_2$。置位（为1）的数量（population count）是 $1$。距离 = $1$。\n\n- 位置 3 (半字节 3): $E$ 为 `d`, $Q$ 为 `c`。\n  - `d` (十六进制) = $1101_2$\n  - `c` (十六进制) = $1100_2$\n  - 按位异或: $1101_2 \\oplus 1100_2 = 0001_2$。置位数量是 $1$。距离 = $1$。\n\n- 位置 6 (半字节 6): $E$ 为 `c`, $Q$ 为 `d`。\n  - `c` (十六进制) = $1100_2$\n  - `d` (十六进制) = $1101_2$\n  - 按位异或: $1100_2 \\oplus 1101_2 = 0001_2$。置位数量是 $1$。距离 = $1$。\n\n- 位置 63 (半字节 63): $E$ 为 `1`, $Q$ 为 `9`。\n  - `1` (十六进制) = $0001_2$\n  - `9` (十六进制) = $1001_2$\n  - 按位异或: $0001_2 \\oplus 1001_2 = 1000_2$。置位数量是 $1$。距离 = $1$。\n\n所有其他位置（1、4、5、7-62和64）的十六进制字符都是相同的。总汉明距离是不同位置上距离的总和。\n\n$$d_H(E, Q) = 1 + 1 + 1 + 1 = 4$$\n\n预期PCR值和签注PCR值之间的总汉明距离为 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3679592"}, {"introduction": "在掌握了PCR扩展的底层机制后，让我们将视角提升到整个系统层面，来分析安全启动与度量启动在真实世界中的协同与挑战。这个场景 ([@problem_id:3679582]) 探讨了UEFI安全启动和操作系统运行时安全策略之间的关键交接点，揭示了一个经典的信任链断裂漏洞。通过分析这个案例，你将学会从端到端的角度思考可信计算，并认识到即使启动过程本身是安全的，可信计算基（TCB）的任何一个薄弱环节都可能导致整个系统的安全防线崩溃。", "problem": "一台工作站配置为启用统一可扩展固件接口 (UEFI) 安全启动。平台密钥 ($PK$) 和签名数据库 ($db$) 包含操作系统供应商的证书。启动流程为：固件 $\\rightarrow$ 第一阶段加载程序 $\\rightarrow$ 引导加载程序 $\\rightarrow$ 内核镜像 $K$，其中每个操作系统前组件都由有效的签名授权。内核 $K$ 在启动时经过合法签名和验证。内核被配置为允许基于设备别名自动加载内核模块，并允许加载未签名的模块。系统中存在可信平台模块 (TPM)，但系统没有配置完整性度量架构 (IMA) 策略，也没有将任何密钥封装到平台配置寄存器 (PCR) 的值中。未使用全盘加密。\n\n一名拥有短暂物理访问权限的攻击者离线修改了根文件系统，植入一个与自动加载别名匹配的未签名内核模块 $M$，并确保相应的设备在启动时存在，从而导致内核自动请求并加载 $M$。\n\n仅使用以下基本定义：\n- 可信计算基 (TCB) 的定义：为保障安全而必须信任的所有组件的集合；任何一个组件的妥协都可能违反系统的安全策略。\n- UEFI 安全启动的定义：通过在控制权转移前验证数字签名，强制只执行经过授权和签名的操作系统前组件。\n- 使用可信平台模块 (TPM) 进行度量启动的定义：通过扩展操作 $PCR_i \\leftarrow H(PCR_i \\parallel m)$，使用单向压缩函数 $H(\\cdot)$ 将组件和事件顺序地哈希到 PCR 中；度量本身不强制执行策略，但与封装或评估策略结合使用时，可以实现检测和有条件地释放秘密。\n\n推断在上述条件下当机器启动时会发生什么，并选择所有正确的陈述。重点关注安全启动如何对 $M$ 作出反应，这对可信计算基意味着什么，以及必须锁定哪些部分才能恢复端到端的代码完整性。\n\nA. 因为 UEFI 安全启动已启用，且攻击者向文件系统添加了一个未签名的内核模块 $M$，固件将拒绝启动。系统无需任何进一步更改即受到保护。\n\nB. UEFI 安全启动将成功验证已签名的内核 $K$ 并完成启动。如果内核配置允许，它随后可能会加载未签名的 $M$，从而将可信计算基扩展到包含未验证的代码，并破坏了超越 $K$ 的信任链。要进行锁定，需要在安全启动激活时要求内核内模块签名验证和锁定（例如，强制执行 $CONFIG\\_MODULE\\_SIG\\_FORCE$ 和内核锁定），或禁用未签名模块的自动加载。\n\nC. 度量启动将阻止加载 $M$，因为当 $M$ 存在时 TPM PCR 会发生变化，因此不需要额外的防御措施。\n\nD. 将 $M$ 的哈希或证书添加到 UEFI 签名数据库 $db$ 中，将使安全启动将 $M$ 视为已授权，从而在不更改内核模块加载策略的情况下防止此攻击。\n\nE. 使用完整性度量架构 (IMA) 的“评估”策略来要求内核模块具有有效签名，并将关键秘密（例如，磁盘解密密钥）封装到特定的 PCR 值，可确保像添加 $M$ 这样的离线篡改要么导致模块加载失败，要么阻止解封。结合安全启动对 $K$ 的验证，这恢复了进入运行中内核代码路径的端到端信任链。\n\n选择所有适用的选项。", "solution": "首先将验证问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n\n- 系统配置：一台启用了统一可扩展固件接口 (UEFI) 安全启动的工作站。\n- 加密材料：平台密钥 ($PK$) 和签名数据库 ($db$) 包含操作系统供应商的证书。\n- 启动顺序：固件 $\\rightarrow$ 第一阶段加载程序 $\\rightarrow$ 引导加载程序 $\\rightarrow$ 内核镜像 $K$。\n- 操作系统前完整性：启动顺序中内核之前的每个组件都由有效的签名授权。\n- 内核完整性：内核镜像 $K$ 在启动时经过合法签名和验证。\n- 内核配置：\n    - 基于设备别名的内核模块自动加载功能已启用。\n    - 允许加载未签名的内核模块。\n- 可信平台模块 (TPM) 配置：\n    - 存在一个 TPM。\n    - 未配置完整性度量架构 (IMA) 策略。\n    - 没有密钥被封装到平台配置寄存器 (PCR) 的值中。\n- 磁盘加密：未使用全盘加密。\n- 攻击者行为：一名拥有短暂物理访问权限的攻击者离线修改了根文件系统。\n- 攻击载荷：一个未签名的内核模块 $M$ 被放置在文件系统上，与启动时存在的设备的自动加载别名匹配。\n- 基本依据：\n    - 可信计算基 (TCB) 的定义：其妥协可能违反系统安全策略的所有组件的集合。\n    - UEFI 安全启动的定义：在执行前验证操作系统前组件的数字签名。\n    - 使用 TPM 的度量启动的定义：通过 $PCR_i \\leftarrow H(PCR_i \\parallel m)$ 将组件的哈希值顺序地记录到 PCR 中，这提供了记录但本身不强制执行策略。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n对问题陈述的有效性进行分析。\n\n- **科学上合理**：该问题在计算机和操作系统安全原则方面有充分的依据。UEFI 安全启动、可信平台模块 (TPM)、度量启动、内核模块加载和可信计算基 (TCB) 等概念是该领域的标准课题。所描述的场景——已验证的内核与随后加载的未验证代码之间的信任链存在差距——是一个经典且现实的安全挑战。\n- **问题定义良好**：问题定义良好。系统的初始状态被清晰定义，攻击者的行为是具体的，问题要求基于所提供的定义对系统状态和潜在的缓解措施进行逻辑推断。可以得出一组唯一的正确结论。\n- **客观性**：语言精确且技术性强。它避免了主观或模糊的术语。\n- **完整性**：问题提供了所有必要的信息。它明确说明了安全启动的状态、内核关于模块签名的配置以及 TPM 的配置（存在但未用于强制执行）。这种详细程度足以推断出结果。\n- **一致性**：没有内部矛盾。组件及其配置的描述是一致的。\n\n### 步骤 3：结论与行动\n\n该问题是有效的。它描述了系统安全中一个连贯且可分析的场景。可以继续进行解题推导。\n\n### 解题推导\n\n分析将遵循启动过程以及内核随后的操作，基于所提供的定义和系统状态。\n\n1.  **UEFI 安全启动阶段**：机器开机。固件作为验证的信任根，开始安全启动过程。它使用其签名数据库 ($db$) 中的证书验证第一阶段加载程序的签名。签名有效，因此控制权被移交给加载程序。加载程序接着验证引导加载程序，后者再验证内核镜像 $K$。由于所有这些组件都已签名并获得授权，UEFI 安全启动成功完成其任务，并将控制权移交给内核 $K$。系统在此阶段没有出现任何错误地启动。UEFI 安全启动对根文件系统的内容（如恶意模块 $M$）一无所知，因为其范围仅限于验证它直接加载的组件（EFI 二进制文件）。\n\n2.  **内核执行阶段**：经过验证的内核 $K$ 开始执行。其任务之一是发现硬件并加载必要的驱动程序，这些驱动程序通常以内核模块的形式实现。问题陈述指出，内核被配置为自动加载模块并允许加载*未签名*的模块。当内核检测到一个设备的驱动程序别名与恶意模块 $M$ 匹配时，它将尝试从文件系统加载 $M$。由于配置明确允许未签名的模块，内核不执行签名检查。加载操作成功，模块 $M$ 中的代码被加载到内核空间并以最高系统权限执行。\n\n3.  **对可信计算基 (TCB) 的影响**：TCB 是必须信任的所有硬件和软件组件的集合。最初，TCB 包括安全启动固件、经过验证的加载程序和经过验证的内核 $K$。这建立了一条“信任链”。然而，当内核 $K$ 加载未经验证的恶意模块 $M$ 时，$M$ 的代码成为运行中内核的一部分。因此，TCB 被扩展以包括 $M$。由于 $M$ 是不受信任的，其被包含在 TCB 中意味着系统的安全策略被违反。由安全启动建立的信任链在内核从执行其自身已验证的代码过渡到执行来自 $M$ 的未验证代码时被打破。\n\n4.  **度量启动/TPM 的作用**：问题陈述指出存在一个 TPM，但没有配置 IMA 策略，也没有封装任何秘密。根据定义，度量启动是向 TPM 的 PCR 中记录度量（哈希）的过程。虽然固件和引导加载程序可能会将自身和内核度量到 PCR 中，但这种度量行为仅仅是一种日志记录形式。没有相应的强制执行机制（IMA 的“评估”策略、远程证明或本地解封秘密），PCR 值的变化对系统的操作没有影响。启动过程不会被中止，$M$ 的加载也不会被阻止。单独的度量提供了检测能力，但没有预防能力。\n\n### 逐项分析\n\n**A. 因为 UEFI 安全启动已启用，且攻击者向文件系统添加了一个未签名的内核模块 $M$，固件将拒绝启动。系统无需任何进一步更改即受到保护。**\n\n- **分析**：这个陈述是错误的。UEFI 安全启动验证其作为 EFI 二进制文件加载的操作系统前组件（引导加载程序、内核）。它不检查操作系统稍后将使用的文件系统内容。恶意模块 $M$ 不是由固件加载的，而是由内核加载的，这发生在安全启动过程成功完成并移交控制权之后很久。因此，固件将成功启动已签名的内核 $K$，并且不会检测或阻止 $M$ 的存在。\n- **结论**：错误。\n\n**B. UEFI 安全启动将成功验证已签名的内核 $K$ 并完成启动。如果内核配置允许，它随后可能会加载未签名的 $M$，从而将可信计算基扩展到包含未验证的代码，并破坏了超越 $K$ 的信任链。要进行锁定，需要在安全启动激活时要求内核内模块签名验证和锁定（例如，强制执行 $CONFIG\\_MODULE\\_SIG\\_FORCE$ 和内核锁定），或禁用未签名模块的自动加载。**\n\n- **分析**：这个陈述是对情况的精确和准确的描述。它正确地指出安全启动的责任以内核验证结束。它正确地解释了内核的不安全配置是允许未签名模块 $M$ 被加载的漏洞，从而用不受信任的代码扩展了 TCB。最后，它提出了正确且相关的对策：强制执行内核模块签名验证（例如，通过内核配置选项 `CONFIG_MODULE_SIG_FORCE`）并使用通常随安全启动自动激活的内核锁定功能来防止此类不安全操作。禁用模块自动加载也是一种有效但可能灵活性较低的缓解措施。\n- **结论**：正确。\n\n**C. 度量启动将阻止加载 $M$，因为当 $M$ 存在时 TPM PCR 会发生变化，因此不需要额外的防御措施。**\n\n- **分析**：这个陈述是错误的。它混淆了度量与强制执行。如问题中所定义，度量启动只是在 PCR 中记录加密哈希。问题明确指出，没有使用任何强制执行机制，如 IMA 策略或密钥封装。因此，虽然加载 $M$ *会*改变 PCR 值（如果 IMA 度量策略处于活动状态），但在所述配置中，这种变化不会触发任何阻止操作。系统不会“检查”PCR 来决定是否启动或加载模块。\n- **结论**：错误。\n\n**D. 将 $M$ 的哈希或证书添加到 UEFI 签名数据库 $db$ 中，将使安全启动将 $M$ 视为已授权，从而在不更改内核模块加载策略的情况下防止此攻击。**\n\n- **分析**：这个陈述是错误的。UEFI 签名数据库 ($db$) 由 UEFI 固件用于验证 EFI 应用程序（如引导加载程序和操作系统内核本身）。操作系统内核在加载自己的模块时不会查阅它。内核维护自己独立的密钥环和验证模块签名的机制。此外，本问题中的内核被配置为*根本不检查签名*，因此即使 $M$ 的签名在正确的内核密钥环中，它也会被忽略。将哈希放入 UEFI $db$ 与内核的模块加载器无关。\n- **结论**：错误。\n\n**E. 使用完整性度量架构 (IMA) 的“评估”策略来要求内核模块具有有效签名，并将关键秘密（例如，磁盘解密密钥）封装到特定的 PCR 值，可确保像添加 $M$ 这样的离线篡改要么导致模块加载失败，要么阻止解封。结合安全启动对 $K$ 的验证，这恢复了进入运行中内核代码路径的端到端信任链。**\n\n- **分析**：这个陈述正确地描述了一个健壮的解决方案，它扩展了由安全启动建立的信任链。可以配置 IMA 的“评估”策略以在运行时强制执行规则，例如要求所有加载的可执行内容（包括内核模块）都具有有效的数字签名。这将直接阻止未签名的模块 $M$ 被加载。关于封装秘密的部分是 TPM 和度量启动的另一个有效用途；如果系统的状态（包括新模块 $M$）偏离了“黄金”PCR 值，像磁盘加密密钥这样的秘密将不会被解封，从而有效地阻止被攻破的系统访问敏感数据。这种将用于操作系统前完整性的安全启动与用于运行时完整性的 IMA/TPM 相结合的方法，确实创建了一个端到端的信任链。\n- **结论**：正确。", "answer": "$$\\boxed{BE}$$", "id": "3679582"}]}