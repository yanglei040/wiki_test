## 引言
在一个日益复杂的数字世界中，确保计算系统的完整性和可信度是我们面临的根本挑战。一个系统从加电启动的那一刻起，其安全性就已奠定基础。然而，我们如何能确信，从固件到[操作系统](@entry_id:752937)的每一个环节都未经篡改？我们又如何能向远程方证明一个系统的可信状态？这些问题引出了可信计算领域的核心支柱：[安全启动](@entry_id:754616)、[度量启动](@entry_id:751820)以及[可信计算基](@entry_id:756201)（TCB）。

本文旨在系统性地剖析这些构建现代可信系统的基石。我们将深入探讨 TCB 的定义、[安全启动](@entry_id:754616)的强制执行角色以及[度量启动](@entry_id:751820)的报告功能。我们将展示这些理论在真实世界中的广泛应用，从保护核心系统到确保云环境安全，并探索其与数字取证等领域的联系。最后，你将通过一系列精心设计的练习，亲手操作和验证这些核心概念，将理论知识转化为实践能力。通过本次学习，你将掌握建立和验证系统[信任链](@entry_id:747264)的关键知识。

## 原理与机制

在理解了建立可信计算环境的基本目标之后，我们现在必须深入探讨实现这些目标的核心原理和技术机制。本章将系统地剖析构成现代可信系统基石的三个核心概念：**[可信计算基](@entry_id:756201) (Trusted Computing Base, TCB)**、**[安全启动](@entry_id:754616) (Secure Boot)** 和**[度量启动](@entry_id:751820) (Measured Boot)**。我们将从第一性原理出发，阐明它们各自的角色、相互关系以及在面对复杂威胁时的局限性。

### [可信计算基](@entry_id:756201)（TCB）：信任的最小化集合

在任何安全系统中，**[可信计算基](@entry_id:756201) (Trusted Computing Base, TCB)** 都是一个基础性概念。它被定义为系统中所有硬件、固件和软件组件的集合，这些组件的正确运行是强制执行系统安全策略所必需的。简而言之，TCB 是我们必须无条件信任、以确保整个系统安全的最小组件集合。如果 TCB 中的任何一个组件失效或被攻破，系统的安全属性就可能被破坏，无论其他安全检查多么完善。

设计安全系统的一个核心原则是**最小化 TCB**。一个更小、更简单的 TCB 更易于分析、验证和保护，从而减少了潜在的攻击面。然而，定义“最小”集合在实践中极具挑战性，因为它不仅包括执行安全检查的代码，还包括任何可能破坏这些检查完整性的组件。

让我们通过一个[操作系统](@entry_id:752937)启动链的例子来具体说明这一点。假设一个启动过程包括以下组件：实现度量[信任根](@entry_id:754420)（RTM）的处理器微码、UEFI 固件、[可信平台模块](@entry_id:756204)（[TPM](@entry_id:170576)）、[引导加载程序](@entry_id:746922)（Bootloader）、以及用于从磁盘加载内核的存储驱动程序。我们的安全策略要求：1) 只有经过授权的代码才能执行；2) 度量的结果必须准确反映实际运行的代码。

为了满足这些策略，TCB 必须包含哪些组件？显然，执行签名验证和度量功能的 UEFI 固件和[引导加载程序](@entry_id:746922)必须在 TCB 内。[TPM](@entry_id:170576) 和 RTM 作为信任的硬件根基，也理所当然是 TCB 的一部分。但存储驱动程序呢？它不执行任何验证或度量，似乎可以被排除在 TCB 之外。

这种想法是危险的，它忽略了一种被称为**“[检查时-使用时](@entry_id:756030)” (Time-of-Check to Time-of-Use, [TOCTOU](@entry_id:756027))** 的经典攻击。[引导加载程序](@entry_id:746922)执行安全检查的流程通常是：
1.  使用存储驱动程序将内核镜像从磁盘加载到内存中。
2.  在内存中验证内核镜像的[数字签名](@entry_id:269311)（检查时）。
3.  在内存中度量内核镜像，并将哈希值扩展到 [TPM](@entry_id:170576) 的 PCR 寄存器中（检查时）。
4.  跳转到内存中的内核镜像开始执行（使用时）。

在现代系统中，诸如存储控制器之类的硬件设备通常使用**直接内存访问 (Direct Memory Access, DMA)** 技术，允许它们在没有 CPU 干预的情况下直接读写[系统内存](@entry_id:188091)。如果存储驱动程序不属于 TCB，即它可能是恶意的或被攻破的，那么它可以在内核镜像通过验证和度量之后（第3步之后），但在 CPU 跳转到它之前（第4步之前），通过 DMA 指令悄悄地修改内存中的内核镜像。[@problem_id:3679566]

这种攻击将彻底破坏系统的安全性：实际执行的是未经签名、未经[正确度](@entry_id:197374)量的恶意代码，但[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)的所有检查却都已“成功”通过。这清晰地表明，任何有能力破坏“检查”与“使用”之间状态完整性的组件，都必须被包含在 TCB 内。因此，在这个例子中，最小 TCB 必须包括存储驱动程序。

在设计 TCB 时，架构师还需权衡不同的设计选择。例如，系统可以使用一个庞大、功能复杂的**[单体](@entry_id:136559)式[引导加载程序](@entry_id:746922) (monolithic bootloader)**，也可以使用一个由多个更小、更简单的阶段组成的**链式加载程序 (chained loader)**。链式设计能够显著减小 TCB 的代码总量，因为在任何一个时刻，只有负责验证下一阶段的代码需要被信任。例如，一个 120 KLOC 的[单体](@entry_id:136559)加载程序可能被一个总共 75 KLOC 的三阶段链式加载程序替代。然而，这种模块化设计可能会引入更多的配置“旋钮”或策略点（例如，每个阶段都有自己的配置选项）。如果每个配置旋钮都有独立的误配风险，那么增加旋钮总数可能会提高整个系统因配置错误而导致安全失效的概率。[@problem_id:3679580] 这揭示了在 TCB 设计中，代码复杂性与配置复杂性之间存在的微妙权衡。

### 强制执行信任：[安全启动](@entry_id:754616)

**[安全启动](@entry_id:754616) (Secure Boot)** 是一种**强制执行 (enforcement)** 机制，其核心目标是确保在启动过程的每个阶段，只有经过授权的、具有[有效数字](@entry_id:144089)签名的代码才能被执行。它扮演着一个“守门员”的角色，从系统加电的第一个瞬间开始，沿着启动链逐级传递信任。

[安全启动](@entry_id:754616)的机制基于一个**[信任链](@entry_id:747264) (chain of trust)**。这个链条始于一个硬件中的**[信任根](@entry_id:754420) (Root of Trust)**，它在物理上是不可篡改的。这个[信任根](@entry_id:754420)被称为**验证[信任根](@entry_id:754420) (Root of Trust for Verification, RTV)**。一种常见的实现方式是在处理器的**[只读存储器](@entry_id:175074) (Read-Only Memory, ROM)** 中固化一段启动代码和一个公钥。[@problem_id:3679563] 当系统启动时：
1.  处理器首先执行 ROM 中的代码。这段代码是不可变的，因此是隐式可信的。
2.  ROM 代码使用其内部固化的公钥来验证下一阶段软件（例如 UEFI 固件）的[数字签名](@entry_id:269311)。
3.  如果签名有效，控制权就移交给 UEFI 固件。现在，UEFI 固件成为[信任链](@entry_id:747264)中新的可信环节。
4.  UEFI 固件接着使用其信任的公钥（可能来自其自身的固件或受保护的可写存储中）来验证[引导加载程序](@entry_id:746922)的签名。
5.  这个过程一直持续下去，直到[操作系统内核](@entry_id:752950)被成功验证并加载。

[安全启动](@entry_id:754616)的强度直接来源于其[密码学](@entry_id:139166)基础。对于一个不知道签名密钥的攻击者来说，要为一个篡改过的软件组件伪造一个有效的签名，等同于进行一次随机猜测。如果签名或消息认证码（MAC）的标签长度为 $L$ 位，那么一次随机猜测成功的概率为 $p(L) = 2^{-L}$。[@problem_id:3679555] 对于[密码学](@entry_id:139166)上典型的长度，如 $L=128$ 或 $L=256$，这个概率小到可以忽略不计，使得通过随机篡改绕过[安全启动](@entry_id:754616)在实践中变得不可能。

然而，理解[安全启动](@entry_id:754616)的**局限性**至关重要。[安全启动](@entry_id:754616)验证的是代码在加载时的**真实性 (authenticity)** 和**完整性 (integrity)**，但它**不**断言代码的**语义正确性**或**无漏洞性**。换言之，一个由可信供应商签名、完美通过[安全启动](@entry_id:754616)验证的驱动程序，其内部仍可能包含逻辑错误或[内存安全](@entry_id:751881)漏洞。[@problem_g_id:3679560] 此外，[安全启动](@entry_id:754616)通常只验证可执行代码，而不会验证配置文件等非可执行数据。例如，攻击者可能无法修改内核本身，但可以通过修改[引导加载程序](@entry_id:746922)的配置文件来改变传递给内核的命令行参数，从而禁用某些安全策略。由于命令行参数是配置数据而非可执行代码，[安全启动](@entry_id:754616)通常不会阻止这种修改。[@problem_id:3679609]

### 报告信任：[度量启动](@entry_id:751820)

与[安全启动](@entry_id:754616)的“强制执行”角色不同，**[度量启动](@entry_id:751820) (Measured Boot)** 是一种**报告 (reporting)** 机制。它的目标不是阻止系统启动，而是为启动过程中的每一个组件（包括代码和关键配置）创建一个精确、可验证的加密记录。这个记录随后可用于**[远程证明](@entry_id:754241) (remote attestation)**，即向一个远程验证方证明设备当前的可信状态。

[度量启动](@entry_id:751820)的核心硬件是**[可信平台模块](@entry_id:756204) (Trusted Platform Module, [TPM](@entry_id:170576))**。[TPM](@entry_id:170576) 是一个安全密码处理器，提供了一系列关键功能，包括安全密钥生成与存储、加密操作以及一组称为**平台配置寄存器 (Platform Configuration Registers, PCRs)** 的特殊寄存器。[TPM](@entry_id:170576) 构成了**报告[信任根](@entry_id:754420) (Root of Trust for Reporting, RTR)**。

[度量启动](@entry_id:751820)的关键操作是 **PCR 扩展 (extend)**。这是一个单向的、具有累积效应的操作。当一个组件被度量时（通常是计算其内容的加密哈希值），这个哈希值 $m$ 会被用于更新一个 PCR 寄存器。其更新规则为：
$PCR_{new} \leftarrow H(PCR_{old} \Vert m)$
其中 $H$ 是一个抗碰撞的哈希函数（如 SHA-256），$\Vert$ 表示[串联](@entry_id:141009)操作。[@problem_id:3679554]

这个扩展操作具有几个关键的[密码学](@entry_id:139166)属性：
*   **仅追加性 (Append-only)**：每次扩展都将新的度量值与 PCR 的旧值结合在一起。最终的 PCR 值是整个度量序列的加密摘要，任何历史信息都不会丢失。
*   **顺序敏感性 (Order-sensitivity)**：由于[哈希函数](@entry_id:636237)和[串联](@entry_id:141009)操作的非交换性，改变度量值的顺序会产生完全不同的最终 PCR 值。例如，先度量组件 A 再度量组件 B，与先 B 再 A 得到的 PCR 结果是不同的。这确保了启动顺序的完整性。使用简单的位[异或](@entry_id:172120)（XOR）操作，如 $PCR' = PCR \oplus H(m)$，则会丧失顺序敏感性，因而是不安全的。[@problem_id:3679554]
*   **强加密承诺 (Strong cryptographic commitment)**：由于[哈希函数](@entry_id:636237)的[抗碰撞性](@entry_id:637794)，要找到一个不同的启动序列来“伪造”一个特定的最终 PCR 值，在计算上是不可行的。一次典型启动可能包含 50 次扩展操作，即便一个系统在一生中启动一百万次，在所有这些启动的最终 PCR 值中出现一次哈希碰撞的概率也微乎其微，对于 SHA-256 而言，其[数量级](@entry_id:264888)约为 $4.318 \times 10^{-66}$。[@problem_id:3679564]

为了使这些 PCR 值对远程方有意义，仅仅有最终的哈希值是不够的。设备还必须维护一个**事件日志 (Event Log)**，它按顺序列出了被度量的每个组件及其对应的哈希值。在[远程证明](@entry_id:754241)期间，设备使用 TPM 内部一个唯一的、受[硬件保护](@entry_id:750157)的**证明身份密钥 (Attestation Identity Key, AIK)** 对当前的 PCR 值进行签名，生成一个**[TPM](@entry_id:170576) 票据 ([TPM](@entry_id:170576) Quote)**。远程验证方接收到这个票据和事件日志后，会执行以下步骤：
1.  使用 AIK 公钥验证票据的签名，确保 PCR 值确实来自可信的 TPM。
2.  根据事件日志中的度量值，在本地重新计算预期的 PCR 值。
3.  将重计算的 PCR 值与票据中的值进行比较。如果一致，证明事件日志是真实的。
4.  最后，将事件日志中的每个度量值与一个已知良好的“黄金”清单进行比较，以确定设备的状态是否可信。[@problem_id:3679554]

这个过程凸显了 [TPM](@entry_id:170576) 对于可信[远程证明](@entry_id:754241)的必要性：它通过硬件将度量记录绑定到了一个唯一的设备身份上。没有 [TPM](@entry_id:170576)，任何由软件生成的度量报告都可能被恶意软件伪造，从而对远程方毫无价值。[@problem_id:3679563]

### 静态信任的局限性与高级主题

[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)提供了强大的启动时完整性保证，但它们主要处理的是**静态**或**加载时**的属性。一个在现代[操作系统](@entry_id:752937)中无处不在的挑战是，系统安全不仅取决于启动时的状态，还取决于运行时的行为以及软件供应链的完整性。

#### 动态 TCB 与运行时威胁

系统在启动后并非静止不变。[操作系统](@entry_id:752937)会动态加载内核模块、驱动程序和用户空间库。一个仅仅在启动时建立的[信任链](@entry_id:747264)如何扩展到这些动态加载的代码？答案在于将**动态 TCB (Dynamic TCB)** 的概念付诸实践。[@problem_id:3679583] 处于 TCB 中的组件（例如[操作系统内核](@entry_id:752950)）自身必须扮演一个可信的**加载器 (loader)** 的角色。当需要加载新代码时，这个可信加载器有责任在执行新代码**之前**对其进行度量，并将度量结果扩展到 PCR 中。这样，[信任链](@entry_id:747264)就从静态的启动过程动态地延伸到了系统的整个生命周期。

更严峻的挑战来自于**“已签名但有漏洞” (signed-but-vulnerable)** 的代码。假设一个由供应商签名的内核驱动程序 $D$ 属于 TCB。它能完美通过[安全启动](@entry_id:754616)的验证，其哈希值也与[度量启动](@entry_id:751820)的预期清单相符。然而，这个驱动程序内部存在一个[缓冲区溢出](@entry_id:747009)漏洞。攻击者可以在系统运行后，通过发送特制的数据触发这个漏洞，进而劫持程序的[控制流](@entry_id:273851)（例如通过[返回导向编程](@entry_id:754319) ROP），从而获得系统权限。[@problem_id:3679560]

这个场景深刻地揭示了**“TCB ≠ 安全”**。一个组件被包含在 TCB 中，意味着我们信任它去正确地执行其安全功能，但这并不代表它本身是无懈可击的。静态的完整性检查无法抵御运行时的漏洞利用。因此，必须引入补充性的缓解措施：
*   **运行时缓解**：**[控制流完整性](@entry_id:747826) (Control-Flow Integrity, CFI)** 等技术可以在运行时强制执行合法的程序执行路径，有效挫败 ROP 等攻击。同时，遵循**[最小权限原则](@entry_id:753740)**，将驱动程序等组件隔离在沙箱中运行，可以极大地减小其被攻破后对整个系统的影响。
*   **策略与管理**：[远程证明](@entry_id:754241)在这里展现了其超越简单启动验证的威力。即使无法阻止漏洞被利用，[度量启动](@entry_id:751820)可以使远程验证方检测到一个正在运行已知易受攻击版本的驱动程序 $D$ 的系统。基于这一信息，验证方可以决定将该设备隔离或拒绝向其提供服务，从而实现“检测与响应”。[@problem_id:3679560]

#### 软件供应链的挑战

最深层次的威胁来自于对软件**供应链**的攻击。假设攻击者攻破了软件供应商的构建服务器，并用一个恶意版本替换了其**编译器**。这个被篡改的编译器会在编译操作系统内核时，悄悄地植入一个后门。最终生成的内核虽然是恶意的，但它是由供应商的官方构建系统用合法的密钥签名的。其哈希值也会被记录在官方发布的清单中。[@problem_id:3679558]

在这种情况下，[安全启动](@entry_id:754616)和基本的[度量启动](@entry_id:751820)都将完全失效。[安全启动](@entry_id:754616)会接受合法的签名，而[远程证明](@entry_id:754241)会确认设备的度量值与（被污染的）官方清单相匹配。这个攻击之所以能成功，是因为信任的根源——即软件的构建过程——本身是未经检验的，它位于设备上所有验证机制的范围之外。

为了应对这类高级威胁，[信任链](@entry_id:747264)必须向前延伸，覆盖到软件的开发和构建过程：
*   **可验证的构建过程**：可以通过在设备上度量和证明构建环境的属性（例如编译器的哈希值）来实现。远程验证方可以将此信息与已批准的工具链清单进行核对。[@problem_s_id:3679558,3679558]
*   **可复现构建 (Reproducible Builds)**：这是一种保证使用相同的源代码总能生成逐位相同的二[进制](@entry_id:634389)文件的实践。通过让两个或多个使用不同工具链的独立方进行可复现构建，并将其结果发布到公共的**透明度日志 (transparency log)** 中，可以有效发现单方面的篡改。远程验证方只信任在日志中获得多方共识的构建结果。[@problem_id:3679558]
*   **软件物料清单 (SBOM) 与出处证明**：诸如 SLSA (Supply-chain Levels for Software Artifacts) 和 in-toto 之类的现代框架，旨在为软件制品创建可加密验证的**出处 (provenance)** 记录。这些记录详细说明了软件是如何构建的，包括源代码、依赖项和所使用的工具。远程验证方可以通过检查这些出处记录，来确保其信任的软件是在一个可信的环境中构建的。[@problem_id:3679558]

综上所述，建立一个真正可信的计算环境，是一个从硬件[信任根](@entry_id:754420)开始，贯穿启动加载、运行时行为，并一直延伸到软件开发与分发全过程的系统性工程。[安全启动](@entry_id:754616)和[度量启动](@entry_id:751820)是这个工程中至关重要的基础部分，但只有将它们与[纵深防御](@entry_id:203741)的其他层面相结合，才能构建出能够抵御复杂和高级威胁的弹性系统。