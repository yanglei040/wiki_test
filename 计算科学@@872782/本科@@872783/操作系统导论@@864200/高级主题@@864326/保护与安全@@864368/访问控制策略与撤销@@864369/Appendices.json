{"hands_on_practices": [{"introduction": "在类Unix系统中，用户组是协作项目的基石。本练习将引导你完成一个具体的实验，观察撤销用户组成员身份如何立即影响其文件访问权限。这个实践旨在展示自主访问控制（DAC）策略的动态特性，并阐明权限检查是如何在操作执行时实时进行的 [@problem_id:3619218]。", "problem": "一个操作系统实现了自主访问控制 (DAC)、强制访问控制 (MAC) 和基于角色的访问控制 (RBAC)。在典型的类 Unix 系统上，自主访问控制 (DAC) 使用所有者、组和其他用户的权限位，而目录上的设置组 ID (SGID) 位会使在该目录内创建的新文件继承该目录的组。在 DAC 下，一个进程对文件系统对象的有效访问权限是通过将进程的凭证（用户标识符和组标识符集）与对象的所有权字段进行比较，然后应用适当的权限类别来确定的：如果进程的用户标识符等于所有者，则应用所有者位；如果进程的任何组标识符等于文件的组，则应用组位；否则应用其他用户位。此外，系统使用进程创建掩码 (umask) 在文件创建时清除某些权限位。强制访问控制 (MAC) 可以基于标签和策略进一步限制访问，而基于角色的访问控制 (RBAC) 则通过角色而非身份或组来分配权限；然而，对于本实验，假设 MAC 没有强制执行任何额外的约束，并且 RBAC 未被配置为覆盖 DAC。\n\n设计并评估以下受控实验，该实验旨在演示当 SGID 目录导致新文件继承组时，撤销组成员身份如何影响有效权限。\n\n设置：\n- 有两个用户，$u_{alice}$ 和 $u_{bob}$，以及一个组 $G_{dev}$。\n- 目录 $D = \\text{/proj/dev}$ 的所有者是 $u_{alice}$，所属组为 $G_{dev}$，其模式为 $2775$（开头的 $2$ 设置了目录的 SGID 位，因此模式为 $rwxrwxr-x$）。除了模式位之外，不存在访问控制列表 (ACL) 条目。两位用户的进程 umask 均为 $002$。\n- 在时间 $t_1$，$u_{bob}$ 是 $G_{dev}$ 的成员，并通过身份验证以获取反映当前组成员身份的最新凭证。\n- 在时间 $t_1$，$u_{alice}$ 通过调用 $\\text{open}(\\text{\"}f_1\\text{\"}, O\\_CREAT)$ 在 $D$ 目录内创建文件 $f_1$，请求的模式为 $0666$。由于 umask 为 $002$，实际模式变为 $0664$；因为 $D$ 设置了 SGID，所以 $f_1$ 的组变为 $G_{dev}$，而 $f_1$ 的所有者是 $u_{alice}$。\n- 在 $t_1$ 之后，$u_{bob}$ 没有打开指向 $f_1$ 的文件描述符，也没有缓存除标准凭证外的任何能力。\n- 在时间 $t_2$，管理员撤销了 $u_{bob}$ 在 $G_{dev}$ 中的成员身份，并强制 $u_{bob}$ 重新进行身份验证，以确保其进程凭证反映了此次撤销。\n- 在时间 $t_3 > t_2$，$u_{alice}$ 在 $D$ 目录内创建文件 $f_2$，请求的模式为 $0666$；由于 umask 为 $002$，实际模式为 $0664$，并且由于 $D$ 上的 SGID， $f_2$ 的组为 $G_{dev}$，所有者为 $u_{alice}$。\n- 在时间 $t_4 > t_3$，$u_{bob}$ 尝试以下操作：写入 $f_1$，写入 $f_2$，并在 $D$ 中创建一个新文件 $f_3$，请求的模式为 $0666$。\n\n假设：\n- 没有活动的强制访问控制 (MAC) 标签或策略会拒绝或允许超出 DAC 范围的访问。\n- 没有对 $u_{bob}$ 生效的、会覆盖 DAC 结果的基于角色的访问控制 (RBAC) 角色。\n- 在 $D$、$f_1$ 或 $f_2$ 上，除了标准模式位外，没有设置 POSIX ACL。\n- 所有访问检查都在每次操作时发生；特别是，$u_{bob}$ 在 $t_2$ 之前没有为写入而打开 $f_1$。\n\n在时间 $t_4$ 观察到的以下哪组结果，正确地演示了在这些条件下撤销 $u_{bob}$ 在 $G_{dev}$ 中的成员身份所产生的影响？\n\nA. 在 $t_1$ 撤销之前，$u_{bob}$ 可以通过 $G_{dev}$ 组写入 $f_1$；在 $t_2$ 撤销并重新认证后，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。\n\nB. 撤销后 $u_{bob}$ 仍然可以写入 $f_1$，因为 SGID 位将组写权限“锁定”到 $D$ 中的文件上；$u_{bob}$ 不能写入 $f_2$，但可以创建 $f_3$，因为 SGID 授予创建权限而不管组成员身份。\n\nC. 撤销只影响未来的文件：$u_{bob}$ 保留对 $f_1$ 的写访问权限，但失去对 $f_2$ 的写访问权限；创建 $f_3$ 仍然被允许，因为 $u_{bob}$ 在 $t_1$ 时曾经是 $G_{dev}$ 的成员。\n\nD. 即使没有配置基于角色的访问控制 (RBAC) 来覆盖 DAC，在 $t_2$ 撤销 $u_{bob}$ 在 $G_{dev}$ 中的成员身份也不会因为 SGID 而影响对 $f_1$ 或 $f_2$ 的 DAC 结果；$u_{bob}$ 可以写入 $f_1$ 和 $f_2$，也可以在 $D$ 中创建 $f_3$。", "solution": "问题陈述描述了一个在类 Unix 操作系统上进行的受控实验，用于测试在自主访问控制 (DAC) 策略下，撤销组成员身份对文件访问权限的影响。分析需要精确应用 DAC、目录上的设置组 ID (SGID) 位以及进程创建掩码 (umask) 的规则。\n\n### 问题验证\n对提供的问题陈述进行验证。\n\n**步骤 1：提取已知条件**\n- **用户**：$u_{alice}$、$u_{bob}$\n- **组**：$G_{dev}$\n- **目录**：$D = \\text{/proj/dev}$\n    - 所有者：$u_{alice}$\n    - 组：$G_{dev}$\n    - 模式：$2775$（八进制），即 $rwxrwxr-x$ 并设置了 SGID 位。\n- **Umask**：两位用户均为 $002$（八进制）。\n- **时间线和事件**：\n    - **$t_1$**：$u_{bob}$ 是 $G_{dev}$ 的成员，并拥有反映此身份的凭证。$u_{alice}$ 在 $D$ 中创建文件 $f_1$，请求的模式为 $0666$。由于 umask $002$，最终文件的所有者为 $u_{alice}$，组为 $G_{dev}$（因 $D$ 上的 SGID），模式为 $0664$。$u_{bob}$ 没有持有指向 $f_1$ 的打开文件描述符。\n    - **$t_2$**：$u_{bob}$ 在 $G_{dev}$ 中的成员身份被撤销。$u_{bob}$ 重新进行身份验证以更新其凭证。\n    - **$t_3$**：$u_{alice}$ 在 $D$ 中创建文件 $f_2$，请求的模式为 $0666$。最终文件的所有者为 $u_{alice}$，组为 $G_{dev}$，模式为 $0664$。\n    - **$t_4$**：$u_{bob}$ 尝试三项操作：写入 $f_1$，写入 $f_2$，在 $D$ 中创建 $f_3$。\n- **假设**：没有覆盖性的 MAC 或 RBAC 策略，没有 POSIX ACL，访问检查在操作时进行。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题具有科学依据、提法得当且客观。它描述了操作系统安全中一个基于 POSIX 兼容文件系统语义的标准、可验证的场景。\n- 关于 DAC、目录上的 SGID 和 umask 功能的描述是准确的，并且与 Linux 等操作系统的既定原则一致。\n- 实验设置是自成体系的，并提供了所有必要的信息（用户、组、权限、操作），以推导出唯一的结果。\n- 问题没有矛盾。例如，从请求的模式和 umask 计算最终文件模式是正确的：有效权限为 `(requested_mode)  (~umask)`。对于请求模式 $0666_8$ 和 umask $0002_8$，计算结果为 $0666_8 \\text{ AND } (\\text{NOT } 0002_8) = 0666_8 \\text{ AND } 0775_8 = 0664_8$。\n- 语言精确且专业。\n\n**步骤 3：结论和行动**\n问题陈述是 **有效的**。可以推导出解决方案。\n\n### 解答推导\n解决方案是通过分析每个文件系统对象的权限以及用户 $u_{bob}$ 在尝试访问时的凭证来推导得出的。\n\n**1. 对象权限分析**\n- **目录 $D = \\text{/proj/dev}$**：\n    - 权限：模式 $2775_8$。这赋予所有者（$u_{alice}$）$rwx$ 权限，组（$G_{dev}$）$rwx$ 权限，以及其他用户 $r-x$ 权限。开头的 $2$ 设置了 SGID 位。要在目录中创建文件，进程需要对该目录同时拥有写（$w$）和执行（$x$）权限。\n- **文件 $f_1$（创建于 $t_1$）**：\n    - 所有者：$u_{alice}$\n    - 组：$G_{dev}$（因 $D$ 的 SGID 而继承）\n    - 模式：$0664_8$ ($rw-rw-r--$)。这赋予所有者读/写（$rw-$）权限，组读/写（$rw-$）权限，以及其他用户只读（$r--$）权限。\n- **文件 $f_2$（创建于 $t_3$）**：\n    - 所有者：$u_{alice}$\n    - 组：$G_{dev}$\n    - 模式：$0664_8$ ($rw-rw-r--$)。权限与 $f_1$ 相同。\n\n**2. 时间 $t_1$ 的访问分析（撤销前）**\n在时间 $t_1$，$u_{bob}$ 的进程凭证包含 $G_{dev}$ 的成员身份。当访问 $f_1$ 时：\n- 进程 UID ($u_{bob}$) 与文件所有者 UID ($u_{alice}$) 不匹配。\n- 进程 GID ($G_{dev}$) 与文件组 GID ($G_{dev}$) 匹配。\n- 因此，使用组权限。对于 $f_1$，组权限是 $rw-$。\n- 结论：在 $t_1$ 时，$u_{bob}$ 可以读写 $f_1$。\n\n**3. 时间 $t_4$ 的访问分析（撤销后）**\n在时间 $t_2$，$u_{bob}$ 在 $G_{dev}$ 中的成员身份被撤销，并且他重新进行了身份验证。在时间 $t_4$，$u_{bob}$ 运行的任何新进程都将拥有不包含 $G_{dev}$ 的凭证。访问检查在操作时（$t_4$）使用这些新凭证进行。\n\n- **尝试 1：写入文件 $f_1$**\n    - 目标：$f_1$（所有者：$u_{alice}$，组：$G_{dev}$，模式：$rw-rw-r--$）\n    - $u_{bob}$ 的凭证：UID 是 $u_{bob}$，GID **不**包含 $G_{dev}$。\n    - 访问检查：\n        1. UID 匹配？否 ($u_{bob} \\neq u_{alice}$)。\n        2. GID 匹配？否（$G_{dev}$ 不在 $u_{bob}$ 的 GID 集中）。\n        3. 默认使用“其他用户”权限。\n    - $f_1$ 的“其他用户”权限是 $r--$。这不授予写权限。\n    - **结果**：写操作被拒绝。\n\n- **尝试 2：写入文件 $f_2$**\n    - 目标：$f_2$（所有者：$u_{alice}$，组：$G_{dev}$，模式：$rw-rw-r--$）\n    - 访问检查与对 $f_1$ 的检查相同。$u_{bob}$ 不是所有者，也不在文件的组中，因此应用“其他用户”权限。\n    - “其他用户”权限是 $r--$。\n    - **结果**：写操作被拒绝。\n\n- **尝试 3：在目录 $D$ 中创建文件 $f_3$**\n    - 目标：$D$（所有者：$u_{alice}$，组：$G_{dev}$，模式：$rwxrwxr-x$）\n    - 操作：创建文件需要对所在目录拥有写（$w$）和执行（$x$）权限。\n    - $u_{bob}$ 的凭证：不是所有者，不在组中。\n    - 访问检查：应用“其他用户”权限。\n    - $D$ 的“其他用户”权限是 $r-x$。这授予了读和执行/搜索权限，但 **不** 授予写权限。\n    - **结果**：文件创建被拒绝。\n\n**结果总结：** 在 $t_4$ 时，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。撤销组成员身份，再加上重新进行身份验证，会有效且立即地移除所有依赖于该组成员身份的访问权限。\n\n### 逐项分析选项\n\n- **A. 在 $t_1$ 撤销之前，$u_{bob}$ 可以通过 $G_{dev}$ 组写入 $f_1$；在 $t_2$ 撤销并重新认证后，$u_{bob}$ 不能写入 $f_1$，不能写入 $f_2$，也不能在 $D$ 中创建 $f_3$。**\n    - 第一部分是正确的，正如对时间 $t_1$ 的分析所示。\n    - 第二部分列出了 $t_4$ 时的结果，与我们的推导完全匹配：所有三项尝试的操作都失败了。\n    - **结论：正确。**\n\n- **B. 撤销后 $u_{bob}$ 仍然可以写入 $f_1$，因为 SGID 位将组写权限“锁定”到 $D$ 中的文件上；$u_{bob}$ 不能写入 $f_2$，但可以创建 $f_3$，因为 SGID 授予创建权限而不管组成员身份。**\n    - 这个选项基于对 SGID 的误解。目录上的 SGID 影响新文件的组所有权，它不会“锁定”权限或覆盖基于当前凭证的标准 DAC 评估。根据推导，$u_{bob}$ 不能写入 $f_1$ 或创建 $f_3$。\n    - **结论：错误。**\n\n- **C. 撤销只影响未来的文件：$u_{bob}$ 保留对 $f_1$ 的写访问权限，但失去对 $f_2$ 的写访问权限；创建 $f_3$ 仍然被允许，因为 $u_{bob}$ 在 $t_1$ 时曾经是 $G_{dev}$ 的成员。**\n    - 这是不正确的。DAC 中的访问控制是动态的；它不依赖于文件创建的时间或历史上的组成员身份。权限在访问时进行检查。$u_{bob}$ 会失去对他所有依赖于 $G_{dev}$ 组成员身份的文件的访问权限，包括 $f_1$。他也不能创建 $f_3$。\n    - **结论：错误。**\n\n- **D. 即使没有配置基于角色的访问控制 (RBAC) 来覆盖 DAC，在 $t_2$ 撤销 $u_{bob}$ 在 $G_{dev}$ 中的成员身份也不会因为 SGID 而影响对 $f_1$ 或 $f_2$ 的 DAC 结果；$u_{bob}$ 可以写入 $f_1$ 和 $f_2$，也可以在 $D$ 中创建 $f_3$。**\n    - 这个选项声称撤销是无效的，这与事实恰恰相反。问题明确指出 $u_{bob}$ 重新进行身份验证，这意味着他的凭证已更新。DAC 使用这些更新后的凭证。SGID 位与此访问检查无关。此选项中预测的三个结果都是错误的。\n    - **结论：错误。**", "answer": "$$\\boxed{A}$$", "id": "3619218"}, {"introduction": "虽然直接撤销权限通常是有效的，但更复杂的系统特性（如POSIX访问控制列表，即ACLs）可能会引入意想不到的细微差别。本练习将展示一个看似违反直觉的场景：对单个文件撤销权限后，用户依然可以访问新创建的文件。这个案例揭示了默认ACL继承的重要概念，并教你如何在一个共享环境中正确地配置和管理权限 [@problem_id:3619191]。", "problem": "在一个遵循可移植操作系统接口（POSIX）草案访问控制列表（ACL）语义的类 Unix 系统中，考虑一个项目目录，其中自主访问控制（DAC）管理着谁可以访问对象。该目录旨在允许项目组成员之间进行协作，同时排除某个特定的前合作者。您被告知以下事实。\n\n- 目录名为 /share，具有用于组继承的设置组标识符（setgid）语义，其模式为 $2770$（即 $rwxrws---$）。其所属组为 team。用户 Bob 不是 team 组的成员。\n- /share 目录有一个默认访问控制列表（ACL），包含以下条目（以概念形式编写，非确切命令语法）：\n  - default:user::rwx\n  - default:group::r-x\n  - default:other::---\n  - default:mask:r-x\n  - default:user:bob:r--\n- Alice 是 team 成员，她的用户文件创建模式掩码（umask）为 $022$。她遵循常规的应用程序默认设置，在 /share 中以请求模式 $0666$ 创建常规文件，以请求模式 $0777$ 创建目录。\n- Alice 希望撤销 Bob 的访问权限。她通过执行一个删除用户 `user:bob` 的单个文件条目的命令，明确地将 Bob 从现有文件 old.txt 的 ACL 中移除。然后，在同一次会话中，她在 /share 中创建了一个新文件 new.txt。\n\n基本原理：在类 POSIX ACL 模型下的自主访问控制（DAC）中，目录的默认 ACL 会被新创建的文件和目录继承为其访问 ACL。文件上指定用户和组的有效权限受文件 ACL 掩码条目的限制。如果父目录有默认掩码，新文件的掩码将从该默认掩码继承；否则，掩码将从应用 umask 到请求模式后产生的文件模式的组类别中派生。umask 直接限制从请求模式计算出的基本权限位，但不会移除继承的指定用户或指定组的 ACL 条目；这些条目受掩码的约束。\n\n问题：哪个选项既正确解释了为什么在对 old.txt 进行单文件权限撤销后，Bob 仍然可以读取新文件 new.txt，又提出了一个仅使用用户文件创建模式掩码（umask）和重新设计目录默认 ACL 的最小充分修复方案，以使未来的权限撤销对新创建的文件有效，且不破坏预期的团队访问权限？\n\nA. 解释：目录的默认 ACL 包含 `default:user:bob:r--`，因此每个新创建的文件都会继承一个 `user:bob` 条目，并且继承的 `default:mask:r-x` 允许该读取权限，无论其他地方的单文件权限撤销如何。修复：从 /share 中移除 Bob 的默认 ACL 条目，并确保默认 ACL 掩码只允许预期的组访问（例如，保留 `default:group::r-x` 和 `default:mask:r-x`，但不保留 `default:user:bob`），并将 Alice 的 umask 收紧至 $027$。这样，在没有默认 ACL 的目录中，新文件创建的模式将不比所有者 `rw`、组 `r`、其他 `none` 更宽松（对于文件大约是 $0640$；对于目录大约是 $0750$），从而在保留团队访问权限的同时，防止 Bob 和其他非团队用户重新获得读取权限。\n\nB. 解释：$022$ 的 umask 直接授予了 Bob 对新文件的读取权限。修复：将 umask 更改为 $077$，并保持目录的默认 ACL 不变。\n\nC. 解释：权限撤销失败是因为目录缺少粘滞位，粘滞位允许其他用户绕过单文件 ACL 进行读取。修复：在 /share 上设置粘滞位并移除 setgid 位。\n\nD. 解释：因为 DAC 是自主的，所以无法对未来的对象强制执行权限撤销。修复：用基于角色的访问控制（RBAC）或强制访问控制（MAC）替换 DAC，这样系统无论目录默认设置如何都会阻止 Bob。\n\nE. 解释：Bob 通过 team 组继承重新获得了访问权限。修复：将 Bob 从 team 组中移除；目录 ACL 可以保持不变。\n\n选择唯一的最佳选项。", "solution": "我们从自主访问控制（DAC）与类 POSIX 访问控制列表（ACLs）、默认 ACL 继承以及用户文件创建模式掩码（umask）行为的基本原理出发。\n\n1) 定义和控制语义。\n\n- 在自主访问控制（DAC）下，对象的所有者可以自行决定授予或撤销访问权限，通常通过权限位和访问控制列表（ACLs）实现。\n- 目录可以有一个默认 ACL。当在该目录中创建新文件时，文件的访问 ACL 源自目录的默认 ACL。所有默认条目（`default:user`、`default:group`、`default:mask`、`default:other` 以及任何 `default:named-user` 或 `default:named-group`）都会被新对象继承为其访问 ACL 条目，其中 `default:mask` 会被复制为文件的掩码。\n- ACL 掩码限制了授予任何指定用户条目（所有者除外）、所属组和指定组的有效权限。因此，像 `user:bob:r--` 这样的条目会受到掩码的进一步限制；如果掩码是 `r-x`，Bob 的有效权限是 `r--` 和 `r-x` 的交集，结果仍然是 `r--`。\n- 值为 $u$ 的用户文件创建模式掩码（umask）会将请求的模式 $m$ 转换为新文件或目录的基本权限模式 $(m \\wedge \\neg u)$。如果不存在默认 ACL，这也决定了文件的组类别，并因此决定了掩码。如果存在默认 ACL 并指定了 `default:mask`，新文件将继承该掩码；umask 不会移除指定的 ACL 条目，也不会覆盖一个明确的默认 ACL 掩码。\n\n2) 将语义应用于该场景。\n\n- /share 目录具有 setgid 和模式 $2770$（$rwxrws---$），组为 team，并且有一个包含 `default:user:bob:r--` 和 `default:mask:r-x` 的默认 ACL。Bob 不在 team 组中。\n- Alice 以请求模式 $0666$ 和 umask $022$ 创建了一个常规文件 new.txt，产生的基础模式为 $(0666 \\wedge \\neg 022) = 0644$。然而，由于父目录有默认 ACL，新文件会继承该默认 ACL 作为其访问 ACL 条目。具体来说：\n  - 它继承了 `user:bob:r--`。\n  - 它继承了 `mask:r-x`。\n  - Bob 的有效权限是其指定用户条目与掩码的交集，即 $r-- \\wedge r-x = r--$。因此，Bob 可以读取 new.txt。\n- Alice 之前通过删除单个文件的 ACL 条目 `user:bob` 将 Bob 从 old.txt 中移除。该撤销操作仅适用于 old.txt。在 /share 中创建的新文件将继续继承 Bob 的默认 ACL 条目，因此该撤销对新对象不持续有效。这是带有默认 ACL 的 DAC 的一个典型陷阱：撤销单个文件的 ACL 不会改变父目录的默认 ACL，因此新文件可以重新授予访问权限。\n\n3) 使用 umask 和目录 ACL 重新设计进行修正。\n\n- 为防止 Bob 在 /share 中新创建的文件上重新获得访问权限，必须更改父目录的默认 ACL，使其不再授予 `user:bob` 任何权限。从 /share 中移除 `default:user:bob` 可确保新文件不会继承该条目。保留 `default:group::r-x` 和 `default:mask:r-x` 可维持预期的团队访问权限，同时继续将任何指定条目的有效权限限制在最多 `r-x`；由于没有 Bob 的指定条目，且他不在 team 组中，他将无法通过组或指定用户条目获得访问权限，而 `other::---` 则拒绝了通过其他人的访问。\n- 为在默认 ACL 之外或不存在默认 ACL 的情况下加强最小权限原则，Alice 还应将其 umask 从 $022$ 减少到 $027$。对于文件，请求模式为 $0666$，$0666 \\wedge \\neg 027 = 0640$，给予所有者 `rw`、组 `r`、其他 `none` 权限；对于目录，请求模式为 $0777$，$0777 \\wedge \\neg 027 = 0750$，给予所有者 `rwx`、组 `rx`、其他 `none` 权限。这符合团队的意图：团队成员（组）可以根据需要读取目录和文件，而非团队用户（包括 Bob）则无法读取。请注意，umask 不会覆盖明确的默认 ACL 掩码，但它确保在没有默认 ACL 的目录中，或对于 Alice 创建的新目录，基本权限不会泄露给其他人。\n\n4) 逐项分析。\n\n- 选项 A：此选项正确地指出了根本原因：目录的默认 ACL 包含 `default:user:bob:r--`，因此新文件继承了 `user:bob` 条目；`default:mask:r-x` 允许 Bob 读取。它还提出了最小充分的 DAC 修复方案：移除 Bob 的默认条目，并保留一个默认 ACL 掩码和组条目以保护团队访问；此外，将 umask 调整为 $027$，以便在没有默认 ACL 的地方，文件和目录以限制性的基本权限创建。这仅使用了 umask 和目录 ACL 重新设计，并实现了既定目标。结论：正确。\n\n- 选项 B：此选项将问题归因于 umask $022$，并建议仅将 umask 更改为 $077$，而保持默认 ACL 不变。这是不够的。在存在包含 `default:user:bob` 和明确 `default:mask` 的默认 ACL 的情况下，新文件会无论 umask 如何都继承这两者。umask 不会移除继承的指定用户条目，也不会覆盖明确的默认掩码；Bob 仍然会通过继承的 ACL 获得读取权限。结论：不正确。\n\n- 选项 C：此选项归咎于缺少粘滞位，并建议设置粘滞位并移除 setgid。粘滞位管理目录中的取消链接/重命名操作，而非读取权限。移除 setgid 会改变组继承，但不会移除为 Bob 继承的指定用户 ACL 条目。这既不能解释观察到的读取行为，也不能修复它。结论：不正确。\n\n- 选项 D：此选项声称 DAC 无法对未来对象强制执行权限撤销，并推荐使用基于角色的访问控制（RBAC）或强制访问控制（MAC）。虽然 MAC 可以取代 DAC 并可用于强制执行策略，但 DAC 在此无法强制执行撤销的前提是错误的；问题源于配置错误的默认 ACL，而非 DAC 的内在限制。问题可以在 DAC 内部通过重新设计默认 ACL 和调整 umask 来解决，如选项 A 所述。结论：不正确。\n\n- 选项 E：此选项断言 Bob 通过 team 组重新获得访问权限，并建议将 Bob 从该组中移除。场景中说明 Bob 不是 team 组的成员。他的访问权限来自 `default:named-user` 条目。这既不能解释该行为，也未提供相关的修复方案。结论：不正确。\n\n因此，正确的选择是移除 Bob 的 `default:named-user` 条目，保留适当的默认掩码和组条目以保护团队访问，并收紧 umask 以避免在其他地方产生意外的权限，即选项 A。", "answer": "$$\\boxed{A}$$", "id": "3619191"}, {"introduction": "从自主访问控制（DAC）转向强制访问控制（MAC），我们进入一个更严格的安全领域。本编码练习要求你模拟一个基于Bell-LaPadula模型的MAC系统，如SELinux。你将模拟一次权限撤销，并量化由异步数据刷新等系统级行为可能导致的“信息泄漏”，从而将抽象的安全策略与现实世界的安全漏洞联系起来 [@problem_id:3619227]。", "problem": "考虑一个强制执行安全增强型 Linux (SELinux) 强制访问控制 (MAC) 的云虚拟机。将系统建模为一个具有三个有序级别 $L_1 \\le L_2 \\le L_3$ 的保密格。主体（容器）和客体（挂载卷）被标记为 $L_1$、$L_2$ 或 $L_3$ 中的一个级别。操作系统强制执行 Bell–LaPadula 保密规则：一个级别为 $\\ell_s$ 的主体仅当 $\\ell_s \\ge \\ell_o$ 时（不上读），才能读取一个级别为 $\\ell_o$ 的客体；并且仅当 $\\ell_s \\le \\ell_o$ 时（不下写），才能向一个客体写入。假设卷可以以只读或读写方式挂载，并且对只读挂载的写入尝试无论标签如何都会被拒绝。\n\n假设在时间 $T_r$ 应用了一项管理性撤销，该撤销立即拒绝系统中所有级别为 $L_2$ 的主体的写入操作。读取操作仍受原始 Bell–LaPadula 规则的约束，不是本任务的重点。考虑写入系统调用可能在持久化之前将数据缓冲在内存中，并且一个挂载的卷可以选择性地具有“不安全的异步刷写”属性。如果刷写是由不安全的异步机制发起的，缓冲的写入可能会在时间 $T_r$ 之后被持久化，而无需查询当前主体的权限。相比之下，由主体发起的标准刷写被视为一次写入操作，必须遵守 Bell–LaPadula 规则和撤销策略。\n\n为以下操作语义建模：\n- 在时间 $t$ 从主体 $s$ 到客体 $o$ 的写入事件，仅当挂载为读写且在时间 $t$ 写入操作被 Bell–LaPadula 规则允许时，才将每个主体-客体对的缓冲区增加数据单元 $d$；此外，如果由于撤销导致 $t \\ge T_r$ 且 $\\ell_s = L_2$，则操作失败。\n- 在时间 $t$ 为主体 $s$ 和客体 $o$ 的一次刷写事件，会提交 $\\langle s,o\\rangle$ 的全部缓冲量到客体，并清空缓冲区。一次标准刷写必须在时间 $t$ 满足 Bell–LaPadula 写入规则，此外，如果 $t \\ge T_r$ 且 $\\ell_s = L_2$，则操作失败。一次不安全的异步刷写会忽略当前权限；它会提交缓冲区，无论在时间 $t$ 的撤销策略和 Bell–LaPadula 规则如何。\n- 将泄露状态定义为，由于在时间 $t \\ge T_r$ 发生且归因于级别为 $L_2$ 的主体的刷写事件而持久化的总数据单元。形式上，令 $B_{s,o}(t)$ 为在时间 $t$ 刷写前 $\\langle s,o\\rangle$ 的缓冲区，令 $\\mathrm{commit}(s,o,t)$ 为如果在时间 $t$ 的刷写持久化了缓冲区则为 $B_{s,o}(t)$，否则为 $0$。一个执行序列的泄露量为 $$\\mathrm{Leak} = \\sum_{\\text{flush events }(s,o,t)} \\left[ \\mathbf{1}(t \\ge T_r) \\cdot \\mathbf{1}(\\ell_s = L_2) \\cdot \\mathrm{commit}(s,o,t) \\right],$$ 其中 $\\mathbf{1}(\\cdot)$ 是指示函数。\n\n您的程序必须模拟以下测试套件。在所有情况下，都恰好有三个标签分别为 $\\ell(C_1)=L_1$、$\\ell(C_2)=L_2$、$\\ell(C_3)=L_3$ 的容器，以及三个标签分别为 $\\ell(V_1)=L_1$、$\\ell(V_2)=L_2$、$\\ell(V_3)=L_3$ 的卷。时间是离散的，以整数步长 $t \\in \\mathbb{Z}_{\\ge 0}$ 计量，并且 $T_r$ 是一个整数。未明确提及的挂载对该主体不可用（在写入检查时被视为只读）。\n\n测试用例 1（正常路径，安全挂载，无泄露）：\n- 撤销时间：$T_r = 3$。\n- $C_2$（$L_2$ 级别的容器）的挂载：$V_1$ 读写且安全，$V_2$ 读写且安全，$V_3$ 读写且安全。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 向 $V_2$ 写入 $d=10$ 个单元。\n  - 在 $t=2$ 时，$C_2$ 对 $V_2$ 执行标准刷写。\n  - 在 $t=4$ 时，$C_2$ 尝试向 $V_3$ 写入 $d=5$ 个单元。\n  - 在 $t=5$ 时，$C_2$ 对 $V_3$ 执行标准刷写。\n- 预期行为是，在 $t=1$ 和 $t=2$ 的撤销前写入和刷写成功，而对于 $C_2$ 在 $t \\ge T_r$ 的操作被拒绝，从而产生 $\\mathrm{Leak} = 0$。\n\n测试用例 2（不安全的异步刷写导致泄露）：\n- 撤销时间：$T_r = 3$。\n- $C_2$ 的挂载：$V_2$ 读写且不安全异步；$C_2$ 的其他挂载缺失。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 向 $V_2$ 写入 $d=8$ 个单元。\n  - 在 $t=4$ 时，为 $C_2$ 在 $V_2$ 上发生一次不安全的异步刷写。\n- 预期行为是，在 $t=1$ 的写入被缓冲，而在 $t=4$ 的不安全异步刷写尽管有撤销策略仍然提交了缓冲区，从而产生 $\\mathrm{Leak} = 8$。\n\n测试用例 3（边界情况：向下写入被拒绝，撤销后刷写被拒绝，无泄露）：\n- 撤销时间：$T_r = 3$。\n- $C_2$ 的挂载：$V_1$ 读写且安全，$V_3$ 读写且安全。\n- 按时间顺序的事件：\n  - 在 $t=1$ 时，$C_2$ 尝试向 $V_1$ 写入 $d=4$ 个单元。\n  - 在 $t=2$ 时，$C_2$ 向 $V_3$ 写入 $d=7$ 个单元。\n  - 在 $t=4$ 时，$C_2$ 对 $V_3$ 执行标准刷写。\n- 预期行为是，在 $t=1$ 的向下写入被 Bell–LaPadula 规则拒绝，在 $t=2$ 的向上写入被缓冲，而在 $t=4$ 的撤销后刷写被拒绝，从而产生 $\\mathrm{Leak} = 0$。\n\n您的任务是实现一个完整的程序，模拟这三个测试用例，并根据上述规则计算每个用例的泄露值 $\\mathrm{Leak}$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，顺序为 $[\\mathrm{Leak}_1,\\mathrm{Leak}_2,\\mathrm{Leak}_3]$，其中 $\\mathrm{Leak}_i$ 是为测试用例 $i$ 计算的泄露值。不涉及物理单位；所有量（如时间和数据单元）都是整数。输出必须与指定格式完全匹配。", "solution": "该问题要求模拟一个由 Bell–LaPadula 强制访问控制 (MAC) 模型管理的系统，该系统增加了特定的管理性撤销策略和两种类型的数据刷写机制。我们必须为三个不同的测试场景计算总数据泄露量。泄露定义为在撤销期间或之后由安全级别为 $L_2$ 的主体持久化的总数据单元。\n\n首先，我们为抽象的安全级别建立一个具体的表示：让有序级别 $L_1 \\le L_2 \\le L_3$ 分别由整数 $1$、$2$ 和 $3$ 表示。因此，对于容器（主体）有 $\\ell(C_1)=1$、$\\ell(C_2)=2$、$\\ell(C_3)=3$，对于卷（客体）有 $\\ell(V_1)=1$、$\\ell(V_2)=2$、$\\ell(V_3)=3$。\n\n系统状态由一组缓冲区中的数据量定义，每个主体-客体对 $\\langle s,o \\rangle$ 都有一个缓冲区，记为 $B_{s,o}$。当数据在泄露公式中概述的特定条件下从缓冲区提交到持久存储时，就会发生泄露：\n$$\n\\mathrm{Leak} = \\sum_{\\text{flush events }(s,o,t)} \\left[ \\mathbf{1}(t \\ge T_r) \\cdot \\mathbf{1}(\\ell_s = L_2) \\cdot \\mathrm{commit}(s,o,t) \\right]\n$$\n该公式仅在刷写事件的时间 $t$ 大于或等于撤销时间 $T_r$ 且主体 $s$ 的安全级别为 $\\ell_s = L_2$ 时，才累加提交的数据 $\\mathrm{commit}(s,o,t)$。\n\n我们通过逐个事件模拟每个测试用例，并应用给定的操作语义来继续。\n\n**访问控制规则分析**\n\n1.  **写入操作许可：** 在时间 $t$ 从主体 $s$ 到客体 $o$ 的写入操作被允许，当且仅当满足以下所有条件：\n    *   挂载是读写的。\n    *   满足 Bell–LaPadula “不下写”规则：$\\ell_s \\le \\ell_o$。\n    *   未触发撤销规则：即并非 $(t \\ge T_r \\text{ 且 } \\ell_s = L_2)$。\n\n2.  **标准刷写操作许可：** 标准刷写被视为一次写入操作。它被允许，当且仅当在时间 $t$ 满足以下所有条件：\n    *   挂载是读写的。\n    *   满足 Bell–LaPadula “不下写”规则：$\\ell_s \\le \\ell_o$。\n    *   未触发撤销规则：即并非 $(t \\ge T_r \\text{ 且 } \\ell_s = L_2)$。\n\n3.  **不安全的异步刷写操作：** 此刷写类型“忽略当前权限”，并总能成功提交缓冲区的内容。\n\n**测试用例 1 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$（级别 $\\ell(C_2)=2$）对 $V_1$（级别 $\\ell(V_1)=1$）、$V_2$（级别 $\\ell(V_2)=2$）和 $V_3$（级别 $\\ell(V_3)=3$）拥有读写、安全的挂载。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 向 $V_2$ 写入 $d=10$。\n    *   检查权限：挂载是读写的。Bell–LaPadula 规则 $\\ell(C_2) \\le \\ell(V_2)$ 变为 $2 \\le 2$，为真。时间 $t=1  T_r=3$，因此撤销不适用。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_2}$ 变为 $10$。\n*   **$t=2$：** $C_2$ 对 $V_2$ 执行标准刷写。\n    *   检查权限：挂载是读写的。规则 $2 \\le 2$ 为真。时间 $t=2  T_r=3$，因此撤销不适用。\n    *   **结果：** 刷写被**允许**。$\\mathrm{commit}(C_2, V_2, 2) = 10$。缓冲区 $B_{C_2, V_2}$ 被重置为 $0$。\n    *   泄露检查：事件时间 $t=2$ 在 $T_r=3$ 之前，因此指示函数 $\\mathbf{1}(t \\ge T_r)$ 为 $0$。对泄露的贡献为 $0$。\n*   **$t=4$：** $C_2$ 尝试向 $V_3$ 写入 $d=5$。\n    *   检查权限：挂载是读写的。规则 $\\ell(C_2) \\le \\ell(V_3)$ 变为 $2 \\le 3$，为真。但是，时间 $t=4 \\ge T_r=3$ 且主体级别为 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 写入被**拒绝**。缓冲区 $B_{C_2, V_3}$ 保持为 $0$。\n*   **$t=5$：** $C_2$ 对 $V_3$ 执行标准刷写。\n    *   检查权限：时间 $t=5 \\ge T_r=3$ 且 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 刷写被**拒绝**。$\\mathrm{commit}(C_2, V_3, 5) = 0$。\n    *   泄露检查：由于提交量为 $0$，对泄露的贡献为 $0$。\n*   **用例 1 的最终泄露量：** $\\mathrm{Leak}_1 = 0$。\n\n**测试用例 2 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$（级别 $\\ell(C_2)=2$）有一个挂载：$V_2$（级别 $\\ell(V_2)=2$），为读写和不安全异步。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 向 $V_2$ 写入 $d=8$。\n    *   检查权限：挂载是读写的。规则 $2 \\le 2$ 为真。时间 $t=1  T_r=3$。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_2}$ 变为 $8$。\n*   **$t=4$：** 为 $C_2$ 在 $V_2$ 上发生一次不安全的异步刷写。\n    *   检查权限：不安全的刷写忽略所有权限并总能成功。\n    *   **结果：** 刷写被**允许**。$\\mathrm{commit}(C_2, V_2, 4) = 8$。缓冲区 $B_{C_2, V_2}$ 被重置为 $0$。\n    *   泄露检查：事件时间 $t=4 \\ge T_r=3$，因此 $\\mathbf{1}(t \\ge T_r) = 1$。主体是 $C_2$，其 $\\ell(C_2)=2$，因此 $\\mathbf{1}(\\ell_s = L_2) = 1$。提交量为 $8$。对泄露的贡献是 $1 \\cdot 1 \\cdot 8 = 8$。\n*   **用例 2 的最终泄露量：** $\\mathrm{Leak}_2 = 8$。\n\n**测试用例 3 模拟**\n\n*   **设置：** $T_r = 3$。容器 $C_2$（级别 $\\ell(C_2)=2$）对 $V_1$（级别 $\\ell(V_1)=1$）和 $V_3$（级别 $\\ell(V_3)=3$）拥有读写、安全的挂载。所有缓冲区初始为零。\n*   **$t=1$：** $C_2$ 尝试向 $V_1$ 写入 $d=4$。\n    *   检查权限：挂载是读写的。Bell–LaPadula “不下写”规则 $\\ell(C_2) \\le \\ell(V_1)$ 变为 $2 \\le 1$，为假。\n    *   **结果：** 写入被**拒绝**。缓冲区 $B_{C_2, V_1}$ 保持为 $0$。\n*   **$t=2$：** $C_2$ 向 $V_3$ 写入 $d=7$。\n    *   检查权限：挂载是读写的。规则 $\\ell(C_2) \\le \\ell(V_3)$ 变为 $2 \\le 3$，为真。时间 $t=2  T_r=3$。\n    *   **结果：** 写入被**允许**。缓冲区 $B_{C_2, V_3}$ 变为 $7$。\n*   **$t=4$：** $C_2$ 对 $V_3$ 执行标准刷写。\n    *   检查权限：时间 $t=4 \\ge T_r=3$ 且主体级别为 $\\ell(C_2)=2$。撤销规则适用。\n    *   **结果：** 刷写被**拒绝**。$\\mathrm{commit}(C_2, V_3, 4) = 0$。缓冲区 $B_{C_2, V_3}$ 保持为 $7$。\n    *   泄露检查：由于提交量为 $0$，对泄露的贡献为 $0$。\n*   **用例 3 的最终泄露量：** $\\mathrm{Leak}_3 = 0$。\n\n**结果总结**\n三个测试用例计算出的泄露值是：\n*   测试用例 1：$\\mathrm{Leak}_1 = 0$\n*   测试用例 2：$\\mathrm{Leak}_2 = 8$\n*   测试用例 3：$\\mathrm{Leak}_3 = 0$\n这些将格式化为逗号分隔的列表 [0,8,0]。", "answer": "$$\\boxed{\\text{[0,8,0]}}$$", "id": "3619227"}]}