{"hands_on_practices": [{"introduction": "操作系统的一个核心任务是管理进程并保护它们的数据。这个练习将带你深入探讨一个实际问题：如何安全地在内存中存储密钥等机密信息，并确保它们只对授权的进程可用。[@problem_id:3631353] 通过模拟一个基于临时文件系统（tmpfs）和加密密封密钥的安全保险库，你将亲手实践如何利用加密技术将机密信息与特定的进程上下文（如用户ID、程序身份）绑定，并分析进程生命周期事件（如`fork`和`exec`）如何影响访问控制。", "problem": "您的任务是为操作系统设计并分析一个使用临时文件系统 (tmpfs) 和加密密封密钥的安全共享密钥保险库模型。该模型必须实现为一个完整的、可运行的程序。目标是探索进程创建与替换，以及线程生命周期事件，如何影响内存中密钥的访问控制和清理。您的程序必须计算并输出指定测试套件的结果。\n\n该安全保险库在临时文件系统上的易失性内存中存储条目。此内存旨在临时存在，并在特定条件下被清除。通过从不变的进程属性中派生解封密钥，保险库条目被视为密封到某个进程。模型必须遵守以下基本事实和定义，并避免使用未经证实的捷径：\n\n- 密封密钥由伪随机函数 (PRF) 和密钥派生函数 (KDF) 派生而来，这是两种广泛使用的密码学原语。对于没有密钥的攻击者来说，PRF 会将输入 $(\\text{key}, \\text{data})$ 确定性地映射到一个与随机无异的输出。KDF 从输入密钥和上下文中计算出派生密钥，以将密钥绑定到特定属性。PRF/KDF 的构造细节留给解决方案决定，但它们在模型内部对于不同上下文必须是确定性的和抗碰撞的。\n- 在操作系统进程模型中，基本语义包括：\n  - 通过 $fork$ 创建进程：创建一个子进程，作为父进程的近乎精确副本，继承内存映射与内容、用户标识符 $(u)$、组标识符 $(g)$ 以及当前的程序纪元 $(e)$，直到发生进一步变化。\n  - 通过 $exec$ 替换程序：进程映像被替换；进程标识符 $(u, g)$ 保持不变，而程序纪元 $(e)$ 被认为会变为一个新值。根据策略，用户空间清理处理程序可能在替换之前或期间运行。内存映射通常会被替换，但共享的 tmpfs 区域可以在文件系统级别持久存在，除非被显式清理。\n  - 线程取消：当一个线程收到取消请求时，注册的清理处理程序会运行，必须安全地擦除内存中的密钥以防止敏感数据残留。\n- 临时文件系统 (tmpfs) 的内容取决于挂載纪元 $(m)$，当挂载纪元改变时，驻留在 tmpfs 中的密钥被视为已清除。重新挂載或卸载会增加 $(m)$ 并使先前的内容失效。\n\n需要实现的模型要求：\n- 用一个从属性 $(K, u, g, e, m)$ 派生的密封绑定器来表示每个保险库条目，其中 $K$ 是用于密封的操作系统主密钥，$u$ 是用户标识符，$g$ 是组标识符，$e$ 是程序纪元，$m$ 是挂载纪元。保险库条目应包含一个存在标志，用以指示密钥是否存在于内存中。\n- 实现一个基于 PRF 的确定性 KDF 来计算该绑定器。在模型层面，该 PRF 必须充当一个确定性混合函数，其核心属性与伪随机函数一致。\n- 定义访问语义：一个进程当且仅当从当前 $(K, u, g, e, m)$ 计算出的派生密钥与存储的绑定器相等，并且保险库条目存在时，才能解封密钥。\n- 定义清理语义：\n  - 线程取消时，通过擦除其内存立即清除保险库条目，将存在标志设为 false。\n  - 执行 $exec$ 时，程序纪元 $(e)$ 变为一个新值；可选策略可能会触发清理，从而清除保险库条目。\n  - 挂载纪元改变 $(m \\rightarrow m')$ 时，tmpfs 内容被清除，使得保险库条目缺失且无法解封。\n\n需要模拟的状态转换模型：\n- 一个父进程在 $(K, u, g, e, m)$ 条件下创建一个密封的保险库条目，然后通过 $fork$ 创建一个子进程。\n- 子进程可以执行 $exec$ 以使 $(e \\rightarrow e')$。\n- 线程取消可能在子进程尝试访问之前或之后发生。\n- 挂载纪元可能在场景中的某个特定点发生改变 $(m \\rightarrow m')$。\n\n参数定义：\n- $K$ 是一个代表主密钥的 $64$ 位无符号整数。\n- $u$ 和 $g$ 是代表用户和组标识符的无符号整数。\n- $e$ 和 $m$ 是代表程序纪元和挂载纪元的非负整数。\n- 策略包括用于 $exec$ 时清理的布尔标志。\n\n测试套件：\n您的程序必须评估以下六个测试用例，每个用例都按规定参数化。对于每个用例，模拟事件序列并确定子进程是否能够访问密钥，以及序列结束后保险库是否为空。布尔值必须以整数形式输出：$1$ 表示 true，$0$ 表示 false。\n\n- 测试用例 1（正常路径，访问后清理）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - 子进程不执行 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之后。\n- 测试用例 2（执行 exec 并带有清理策略）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - 子进程执行 $exec$ 并将纪元更改为 $e' = 2$；$exec$ 时清理策略为 $1$。\n  - $exec$ 之外无取消操作。\n- 测试用例 3（访问前取消）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1002$, $g = 1002$, $e = 1$, $m = 1$.\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之前。\n- 测试用例 4（挂载纪元变更清除 tmpfs）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1002$, $e = 1$, $m$ 在子进程访问前从 $1$ 变为 $2$。\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 无取消操作。\n- 测试用例 5（子进程中组标识符变更，访问后清理）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g$ 在子进程 $fork$ 后、访问前从 $1005$ 变为 $1006$, $e = 1$, $m = 1$.\n  - 无 $exec$；$exec$ 时清理策略为 $0$。\n  - 取消发生在子进程尝试访问之后。\n- 测试用例 6（执行 exec 但不带清理策略，显示残留密钥风险）：\n  - $K = 0xA3B1C2D3E4F56789$, $u = 1001$, $g = 1001$, $e = 1$, $m = 1$.\n  - 子进程执行 $exec$ 并将纪元更改为 $e' = 2$；$exec$ 时清理策略为 $0$。\n  - 无取消操作。\n\n对于每个测试用例，您的程序必须计算两个输出：\n- 访问结果：子进程在序列操作后是否可以解封密钥，以整数 $0$ 或 $1$ 表示。\n- 保险库是否为空：序列操作结束后保险库是否为空，以整数 $0$ 或 $1$ 表示。\n\n最终输出格式：\n您的程序应生成单行输出，包含一个由六个序对组成的列表，每个测试用例一个，其中每个序对是按 $(\\text{access}, \\text{empty})$ 顺序排列的上述两个整数。该列表必须以逗号分隔，并用方括号括起来，其中每个序对本身也是一个用方括号括起来的逗号分隔列表。例如：$[[1,0],[0,1],\\dots]$。", "solution": "该问题要求设计并实现一个用于操作系统的安全密钥保险库的计算模型。该模型必须模拟密钥的访问控制如何受到进程生命周期事件（如 $fork()$ 和 $exec()$）、线程取消以及系统状态变化（如临时文件系统 (tmpfs) 的重新挂载）的影响。该解决方案基于操作系统和密码学的既定原则。\n\n**1. 基本原则**\n\n该模型基于三个核心领域：操作系统进程模型、临时文件系统语义和密码学密钥派生。\n\n- **进程与线程模型**：在类 UNIX 系统中，新进程通过 $fork()$ 创建，它会生成一个与父进程几乎完全相同的子进程。子进程继承父进程的内存、凭证（用户标识符 $u$、组标识符 $g$）和程序代码。$exec()$ 系统调用会将当前进程的内存和代码替换为新程序，但关键的是，$u$ 和 $g$ 等凭证会被保留。我们用“程序纪元” $e$ 来为程序身份建模，它在 $fork()$ 时被继承，但在 $exec()$ 时会改变。线程取消是终止一个线程的机制，它应触发清理处理程序以安全地擦除内存中的敏感数据。\n\n- **临时文件系统 (tmpfs)**：tmpfs 是一个易失性的内存文件系统。其内容是临时的，并且仅在挂载期间存在。我们通过将 tmpfs 与一个“挂载纪元” $m$ 关联来对此建模。任何使挂載失效的事件（例如，卸载或重新挂載）都被建模为 $m$ 的增加，这被定义为清除 tmpfs 的所有内容。\n\n- **密码学绑定**：密钥可以被密码学地“密封”或“绑定”到一个特定的上下文。这是通过使用密钥派生函数 (KDF) 实现的，该函数通常基于伪随机函数 (PRF) 构建。KDF 接受一个主密钥和一组上下文属性（例如，进程凭证、程序身份），并确定性地生成一个派生密钥。只有当当前上下文能够重现完全相同的派生密钥时，密钥才能被“解封”。这确保了密钥只在预期的条件下才能被访问。\n\n**2. 算法设计与状态建模**\n\n基于这些原则，我们构建了一个确定性仿真模型。\n\n- **状态表示**：\n  - **保险库条目**：一个保险库条目由两个部分表示：一个 `binder` 和一个 `存在标志`。\n    - `` `binder` `` 是一个 `` `unsigned long long` `` 类型的值，代表由 KDF 计算出的派生密钥。它根据上下文 $(K, u, g, e, m)$ 计算得出，其中 $K$ 是系统的主密钥，$(u, g)$ 是进程凭证，$e$ 是程序纪元，$m$ 是 tmpfs 挂载纪元。\n    - `存在标志` 是一个布尔值（表示为整数，$1$ 为 true，$0$ 为 false），指示密钥是否物理存在于内存中（即在 tmpfs 上）。\n  - **进程上下文**：一个进程由其当前属性 $(u, g, e)$ 定义。\n  - **系统上下文**：相关的系统级状态是挂载纪元 $m$ 和主密钥 $K$。\n\n- **密钥派生函数 (KDF)**：\n为模拟密码学绑定，我们实现一个确定性函数 `compute_binder(K, u, g, e, m)`。该函数必须是一个强混合函数，为每组唯一的输入生成唯一的输出，从而满足基于 PRF 的 KDF 的概念要求。对于此模型，采用了一个原则上类似于 FNV-1a 哈希算法的函数。它通过一系列与大素数的异或和乘法运算来组合输入 $(K, u, g, e, m)$，以生成一个 $64$位的 `binder` 值。\n$$ \\text{binder} = \\text{KDF}(K, u, g, e, m) $$\n\n- **访问语义**：\n一个进程当且仅当同时满足两个条件时，才能成功访问（解封）密钥：\n$1$. 保险库条目的 `存在标志` 必须为 true。\n$2$. 从进程当前上下文 $(K, u_{\\text{current}}, g_{\\text{current}}, e_{\\text{current}}, m_{\\text{current}})$ 计算出的 `binder` 必须与保险库条目中存储的 `binder` 完全匹配。\n$$ \\text{Access} = (\\text{is\\_present} = \\text{true}) \\land (\\text{KDF}(K, u_{\\text{current}}, g_{\\text{current}}, e_{\\text{current}}, m_{\\text{current}}) = \\text{binder}_{\\text{stored}}) $$\n\n- **状态转换逻辑**：\n每个测试用例的模拟都遵循严格的事件序列，并相应地更新状态变量：\n$1$. **初始化**：一个上下文为 $(u, g, e)$ 的父进程存在于一个主密钥为 $K$、挂载纪元为 $m$ 的系统中。\n$2$. **保险库创建**：父进程创建一个保险库条目。`binder` 使用初始上下文 $(K, u, g, e, m)$ 计算，其 `存在标志` 被设置为 true ($1$)。\n$3$. **Fork**：创建一个子进程。它继承父进程的上下文，因此其初始状态也为 $(u, g, e)$。保险库条目在共享的 tmpfs 中持久存在。\n$4$. **访问前事件**：测试用例场景规定了在子进程尝试访问保险库之前发生的事件。这些事件会修改子进程的上下文或保险库的状态：\n    - **组 ID 变更**：子进程的 $g$ 值被更新。\n    - **挂载纪元变更**：系统的 $m$ 更新为 $m'$，保险库的 `存在标志` 被设为 false ($0$)，模拟 tmpfs 清理。\n    - **$exec()$**：子进程的程序纪元 $e$ 变为 $e'$。如果 `cleanup_on_exec` 策略激活，`存在标志` 将被设为 false ($0$)。\n    - **访问前取消**：由于清理处理程序，`存在标志` 被设为 false ($0$)。\n$5$. **访问尝试**：子进程根据其*当前*上下文计算一个密钥，并根据上述定义的访问语义尝试访问保险库。结果（访问成功或失败）被记录下来。\n$6$. **访问后事件**：像线程取消这样的事件可能在访问尝试之后发生，这会将 `存在标志` 设为 false ($0$)。\n$7$. **最终状态**：`存在标志` 的最终状态决定了保险库是否为空。\n\n**3. 测试用例分析**\n\n该逻辑应用于每个测试用例。作为一个例子，我们来分析两个对比鲜明的案例：\n\n- **测试用例 1 (成功访问与清理)**：\n  - 父进程使用上下文 $(K, u=1001, g=1001, e=1, m=1)$ 创建保险库。保险库存在。\n  - 子进程通过 fork 产生，继承了相同的上下文。没有发生访问前事件。\n  - 子进程尝试访问。其上下文 $(1001, 1001, 1)$ 与创建 `binder` 时使用的上下文匹配，且保险库存在。因此，访问被授予。结果：**access = 1**。\n  - 访问*之后*发生了一次取消。这触发了清理，将 `存在标志` 设置为 false。\n  - 最终保险库状态为空。结果：**empty = 1**。\n\n- **测试用例 6 (因 `exec` 未清理导致的访问失败)**：\n  - 父进程使用上下文 $(K, u=1001, g=1001, e=1, m=1)$ 创建保险库。保险库存在。\n  - 子进程通过 fork 产生，继承了上下文。\n  - 子进程执行 $exec()$，将其程序纪元更改为 $e'=2$。`cleanup_on_exec` 策略为 false，因此保险库条目的 `存在标志` 保持为 true。\n  - 子进程尝试访问。其上下文现在是 $(1001, 1001, 2)$。它用 $e=2$ 计算出的 `binder` 与用 $e=1$ 创建的存储 `binder` 不匹配。访问被拒绝。结果：**access = 0**。\n  - 没有进一步的清理事件发生。`存在标志` 保持为 true。\n  - 最终保险库状态不为空，这代表存在残留密钥风险。结果：**empty = 0**。\n\n这种在 C 程序中实现的系统化模拟，可以根据模型定义，精确评估每种场景的安全影响。", "answer": "```c\n#include", "id": "3631353"}, {"introduction": "当数据在网络上传输时，仅仅加密内容是不够的；我们还必须防止攻击者截获并重放合法的消息，即“重放攻击”。这个实践任务将让你在操作系统内核网络栈的层面，为一个类似TLS的安全协议设计并实现一个关键的防御机制——抗重放窗口。[@problem_id:3631435] 你将通过实现一个基于位图的滑动窗口来跟踪记录序列号，从而亲身体验协议状态管理的复杂性，并分析在支持百万级并发连接的服务器上，这种安全机制的内存开销。", "problem": "要求您设计并分析一个适用于操作系统（OS）内核网络栈中类似传输层安全性（TLS）协议的逐套接字（per-socket）抗重放窗口机制。其密码学目标是通过使用单调递增的记录序列号来强制记录的新鲜性，从而防止重放攻击。根据密码学协议中新鲜性和抗重放性的基本定义，序列号必须非递减，并且每个唯一的序列号最多只能被处理一次。您的实现必须实现一个滑动窗口，该窗口根据传入记录的整数序列号来跟踪其接受或拒绝状态。\n\n此任务的基本基础：\n- 用于密码学协议的抗重放窗口在一个近期序列号窗口上维护接受状态。\n- 每个类似TLS的记录都携带一个单调递增的序列号 $s \\in \\mathbb{N}$。\n- 该窗口由一个以比特为单位的大小 $W \\in \\mathbb{N}$ 参数化。其状态必须跟踪已见过的最高序列号 $H \\in \\mathbb{N}$，以及一个长度为 $W$ 的位掩码，该位掩码指示最后 $W$ 个位置内的序列号是否已被接收。\n- 序列号为 $s$ 的记录在满足 $s  H$（推进窗口）或 $H - s  W$ 且窗口中对应的位尚未设置的条件下被接受。否则，该记录因重放或过于陈旧而被拒绝。\n\n程序要求：\n1. 实现一个逐套接字的抗重放窗口，该窗口维护：\n   - 至今观察到的最高序列号 $H$。\n   - 一个 $W$ 位的位图，其中位索引 $i$ 对应于序列号 $H - i$ 是否已被见过（索引 $i = 0$ 对应于 $H$ 本身）。\n   - 当接收到 $s  H$ 的新记录时，窗口必须向前滑动距离 $\\Delta = s - H$，丢弃掉出窗口的位，并将新引入的前导位置清零。如果 $\\Delta \\geq W$，则整个位图将被清零。\n2. 对于下方的每个测试用例，模拟处理给定的整数序列，并为每个序列号输出一个整数决策：$1$ 表示接受，$0$ 表示拒绝。\n3. 分析逐套接字状态的内存开销。假设一个套接字精确地维护一个 $W$ 位位图，外加 $M$ 字节的固定逐套接字元数据开销（用于簿记，如计数器和锁定状态）。计算：\n   - 每个套接字的内存（以字节为单位）：$m_{\\text{socket}} = \\lceil W/8 \\rceil + M$。\n   - $n$ 个套接字的总内存（以字节为单位）：$m_{\\text{total}} = n \\cdot m_{\\text{socket}}$。\n   以字节为单位，将 $m_{\\text{socket}}$ 和 $m_{\\text{total}}$ 作为整数报告。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。结果必须按以下顺序在所有测试用例中展平：对于按所列顺序的每个测试用例，首先输出该测试用例中所有序列号的接受决策，然后输出 $m_{\\text{socket}}$，再输出 $m_{\\text{total}}$。\n\n不涉及角度单位。所有内存量必须以字节为单位表示为整数。\n\n测试套件：\n- 测试用例 $1$：$W = 64$，$M = 24$，$n = 10^6$，序列 $\\{1, 2, 3, 2, 70, 69\\}$。\n- 测试用例 $2$：$W = 8$，$M = 16$，$n = 10^6$，序列 $\\{5, 5, 12, 4, 12, 20, 13\\}$。\n- 测试用例 $3$：$W = 128$，$M = 32$，$n = 10^6$，序列 $\\{1000, 900, 1000, 1128, 1127, 1128\\}$。\n- 测试用例 $4$：$W = 4096$，$M = 40$，$n = 10^6$，序列 $\\{1, 4097, 1\\}$。\n\n科学真实性和一致性说明：\n- 抗重放窗口是互联网协议安全（IPsec）和类似TLS的构造中广泛用于抗重放的机制，对于处理加密传输的内核级网络栈是必需的。\n- 规模 $n = 10^6$ 模拟了具有大约一百万个套接字的大规模服务器部署，这对于高并发下的内存规划是现实的。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，$[result1,result2,\\dots]$）。", "solution": "问题陈述被评估为 **有效**。它具有科学依据，定义明确，客观，并为设计和分析抗重放窗口机制提供了一套完整且一致的要求。指定的机制是IPsec和DTLS等密码协议中用于防止重放攻击的标准技术。其参数和规模对于现代服务器环境是现实的。\n\n解决方案的核心是为每个套接字实现一个有状态的抗重放窗口。此窗口的状态由两个组件定义：\n1.  $H$：至今接收到的最高序列号，一个初始化为 $0$ 的无符号整数。\n2.  一个大小为 $W$ 位的位图，我们可以将其表示为 $B$。此映射的位 $i$（从右到左，即索引 $0$ 是最低有效位）对应于序列号 $H-i$。位值为 $1$ 表示已接收到相应的序列号；$0$ 表示尚未接收。该位图初始化为全零。\n\n当序列号为 $s$ 的记录到达时，应用以下逻辑：\n\n1.  **情况1：$s  H$（最新记录）**\n    *   该记录被无条件接受（决策：$1$）。\n    *   窗口必须向前滑动以适应新的最高序列号。滑动距离为 $\\Delta = s - H$。\n    *   如果 $\\Delta \\ge W$，新窗口与旧窗口不重叠，因此整个位图 $B$ 被重置为全零。\n    *   如果 $\\Delta  W$，位图 $B$ 被逻辑左移 $\\Delta$ 位。这会丢弃最旧的 $\\Delta$ 个序列号的状态，并为 $\\Delta$ 个新序列号腾出空间。\n    *   最高序列号更新：$H \\leftarrow s$。\n    *   位图 $B$ 中对应于新 $H$ 的位（索引 $0$）被设置为 $1$，以标记其已被接收。\n\n2.  **情况2：$s \\le H$（可能是旧记录或重放记录）**\n    *   计算 $s$ 相对于 $H$ 的位置：$d = H - s$。\n    *   如果 $d \\ge W$，该序列号比窗口能跟踪的最旧记录还要旧。它因过于陈旧而被拒绝（决策：$0$）。\n    *   如果 $d  W$，该序列号落在当前窗口内。我们检查位图 $B$ 的第 $d$ 位。\n        *   如果第 $d$ 位是 $1$，则该记录是重复的（一次重放）。它被拒绝（决策：$0$）。\n        *   如果第 $d$ 位是 $0$，则该记录是新的并且在窗口内。它被接受（决策：$1$）。然后通过将位图 $B$ 的第 $d$ 位设置为 $1$ 来更新状态。\n\n一个套接字的内存开销是位图的大小加上任何固定的元数据。位图需要 $\\lceil W/8 \\rceil$ 字节。因此，$m_{\\text{socket}} = \\lceil W/8 \\rceil + M$ 字节。$n$ 个套接字的总内存是 $m_{\\text{total}} = n \\cdot m_{\\text{socket}}$。\n\n我们现在将此逻辑应用于每个测试用例。\n\n**测试用例1：** $W = 64$，$M = 24$，$n = 10^6$，序列 $\\{1, 2, 3, 2, 70, 69\\}$。\n初始状态：$(H=0, B=0x0)$。\n- $s=1$：$sH$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x1$。$H \\leftarrow 1$。状态：$(H=1, B=0x1)$。\n- $s=2$：$sH$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x3$。$H \\leftarrow 2$。状态：$(H=2, B=0x3)$。\n- $s=3$：$sH$。接受 ($1$)。$\\Delta = 1$。$B \\leftarrow (B \\ll 1) | 1 = 0x7$。$H \\leftarrow 3$。状态：$(H=3, B=0x7)$。\n- $s=2$：$s \\le H$。$d = H-s = 1$。由于 $d  W=64$，我们检查 $B$ 的位 $1$。在 $0x7$ 中，位 $1$ 已被设置。拒绝 ($0$)。状态不变。\n- $s=70$：$sH$。接受 ($1$)。$\\Delta = 70-3 = 67$。由于 $\\Delta \\ge W=64$，重置 $B \\leftarrow 0$。然后设置位 $0$，所以 $B \\leftarrow 0x1$。$H \\leftarrow 70$。状态：$(H=70, B=0x1)$。\n- $s=69$：$s \\le H$。$d = H-s = 1$。由于 $d  W=64$，我们检查 $B$ 的位 $1$。在 $0x1$ 中，位 $1$ 未被设置。接受 ($1$)。设置位 $1$：$B \\leftarrow B | (1 \\ll 1) = 0x3$。状态：$(H=70, B=0x3)$。\n决策：$1, 1, 1, 0, 1, 1$。\n内存：$m_{\\text{socket}} = \\lceil 64/8 \\rceil + 24 = 8 + 24 = 32$ 字节。$m_{\\text{total}} = 10^6 \\cdot 32 = 32000000$ 字节。\n\n**测试用例2：** $W = 8$，$M = 16$，$n = 10^6$，序列 $\\{5, 5, 12, 4, 12, 20, 13\\}$。\n初始状态：$(H=0, B=0x0)$。\n- $s=5$：$sH$。接受 ($1$)。$\\Delta = 5$。$B \\leftarrow (B \\ll 5) | 1 = 0x1$。$H \\leftarrow 5$。状态：$(H=5, B=0b00000001)$。\n- $s=5$：$s \\le H$。$d = H-s = 0$。由于 $d  W=8$，我们检查位 $0$。位 $0$ 已被设置。拒绝 ($0$)。\n- $s=12$：$sH$。接受 ($1$)。$\\Delta = 7$。$B \\leftarrow (B \\ll 7) | 1 = 0b10000001$。$H \\leftarrow 12$。状态：$(H=12, B=0b10000001)$。\n- $s=4$：$s \\le H$。$d = H-s = 8$。由于 $d \\ge W=8$，它过于陈旧。拒绝 ($0$)。\n- $s=12$：$s \\le H$。$d = H-s = 0$。由于 $d  W=8$，我们检查位 $0$。位 $0$ 已被设置。拒绝 ($0$)。\n- $s=20$：$sH$。接受 ($1$)。$\\Delta = 8$。由于 $\\Delta \\ge W=8$，重置 $B \\leftarrow 0$。然后设置位 $0$，$B \\leftarrow 0x1$。$H \\leftarrow 20$。状态：$(H=20, B=0b00000001)$。\n- $s=13$：$s \\le H$。$d = H-s = 7$。由于 $d  W=8$，我们检查位 $7$。位 $7$ 未被设置。接受 ($1$)。设置位 $7$：$B \\leftarrow B | (1 \\ll 7) = 0b10000001$。状态：$(H=20, B=0b10000001)$。\n决策：$1, 0, 1, 0, 0, 1, 1$。\n内存：$m_{\\text{socket}} = \\lceil 8/8 \\rceil + 16 = 1 + 16 = 17$ 字节。$m_{\\text{total}} = 10^6 \\cdot 17 = 17000000$ 字节。\n\n**测试用例3：** $W = 128$，$M = 32$，$n = 10^6$，序列 $\\{1000, 900, 1000, 1128, 1127, 1128\\}$。\n初始状态：$(H=0, B=\\{0x0, 0x0\\})$。我们使用两个 $64$ 位整数来表示 $128$ 位位图。\n- $s=1000$：$sH$。接受 ($1$)。$\\Delta = 1000 \\ge W=128$。重置 $B$。$H \\leftarrow 1000$。设置位 $0$。状态：$(H=1000, \\text{位 } 0 \\text{ 被设置})$。\n- $s=900$：$s \\le H$。$d = H-s = 100$。由于 $d  W=128$，检查位 $100$。未设置。接受 ($1$)。设置位 $100$。状态：$(H=1000, \\text{位 } 0, 100 \\text{ 被设置})$。\n- $s=1000$：$s \\le H$。$d = H-s = 0$。由于 $d  W=128$，检查位 $0$。位 $0$ 已被设置。拒绝 ($0$)。\n- $s=1128$：$sH$。接受 ($1$)。$\\Delta = 128$。由于 $\\Delta \\ge W=128$，重置 $B$。$H \\leftarrow 1128$。设置位 $0$。状态：$(H=1128, \\text{位 } 0 \\text{ 被设置})$。\n- $s=1127$：$s \\le H$。$d = H-s = 1$。由于 $d  W=128$，检查位 $1$。未设置。接受 ($1$)。设置位 $1$。状态：$(H=1128, \\text{位 } 0, 1 \\text{ 被设置})$。\n- $s=1128$：$s \\le H$。$d = H-s = 0$。由于 $d  W=128$，检查位 $0$。位 $0$ 已被设置。拒绝 ($0$)。\n决策：$1, 1, 0, 1, 1, 0$。\n内存：$m_{\\text{socket}} = \\lceil 128/8 \\rceil + 32 = 16 + 32 = 48$ 字节。$m_{\\text{total}} = 10^6 \\cdot 48 = 48000000$ 字节。\n\n**测试用例4：** $W = 4096$，$M = 40$，$n = 10^6$，序列 $\\{1, 4097, 1\\}$。\n初始状态：$(H=0, B=\\text{全零})$。\n- $s=1$：$sH$。接受 ($1$)。$\\Delta = 1  W=4096$。将 $B$ 左移 $1$ 位。$H \\leftarrow 1$。设置位 $0$。状态：$(H=1, \\text{位 } 0 \\text{ 被设置})$。\n- $s=4097$：$sH$。接受 ($1$)。$\\Delta = 4096$。由于 $\\Delta \\ge W=4096$，重置 $B$。$H \\leftarrow 4097$。设置位 $0$。状态：$(H=4097, \\text{位 } 0 \\text{ 被设置})$。\n- $s=1$：$s \\le H$。$d = H-s = 4096$。由于 $d \\ge W=4096$，它过于陈旧。拒绝 ($0$)。\n决策：$1, 1, 0$。\n内存：$m_{\\text{socket}} = \\lceil 4096/8 \\rceil + 40 = 512 + 40 = 552$ 字节。$m_{\\text{total}} = 10^6 \\cdot 552 = 552000000$ 字节。\n\n最终展平的结果列表是通过按顺序连接每个用例的决策序列和内存计算结果而形成的。", "answer": "```c\n#include", "id": "3631435"}, {"introduction": "在分布式和云计算环境中，我们如何能信任一个远程服务器上运行的软件是未经篡改的？这个高级实践将引导你构建一个远程证明协议，这是可信计算领域的基石。[@problem_id:3631438] 你将模拟使用可信平台模块（TPM）作为信任根，通过实现一个包含哈希、HMAC和随机数挑战的完整协议，来让一个进程向远程客户端证明其自身二进制文件和所加载模块的完整性，从而深刻理解操作系统在保障测量过程可信度方面的关键作用。", "problem": "您的任务是从操作系统的角度设计和验证一个远程证明协议，并使用密码学作为安全工具。目标是允许一个进程使用一个充当信任锚的可信平台模块 (TPM)，向远程客户端证明其当前执行的二进制文件和已加载模块的完整性。您必须实现一个完整的、可运行的程序，模拟证明过程，并在多种测试条件下对其进行验证。该协议必须使用 nonce 质询来保证新鲜性，并使用密钥散列消息认证码来保证真实性。\n\n使用的基本定义和事实如下：\n- 一个密码学哈希函数 $H$ 将任意长度的输入映射到固定长度的输出，并且必须满足抗原像性、抗第二原像性和抗碰撞性。对于本问题，使用一个等同于安全哈希算法256位 (SHA-256) 的实例，它产生 $256$ 位的输出，并以 $64$ 字节的块大小进行操作。\n- 带有底层哈希函数 $H$ 的密钥散列消息认证码 (HMAC) 定义为 $$\\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right),$$ 其中 $K$ 是密钥， $m$ 是消息，$\\oplus$ 是按位异或，$\\parallel$ 表示串联，$\\text{opad}$ 和 $\\text{ipad}$ 是根据标准为所选的 $H$ 定义的外部和内部填充，其块大小 $b = 64$ 字节。\n- nonce (number used once) 是一个仅使用一次的数字；当响应者在其认证响应中包含来自挑战者的 nonce 时，它提供了新鲜性。\n\n需要实现的协议描述：\n- 定义一个度量过程，其中一个进程有一个二进制镜像 $B$ 和一个已加载模块的列表 $\\{(N_i, M_i)\\}_{i=1}^k$，$N_i$ 是模块名，$M_i$ 是其内容。计算二进制文件哈希 $h_{\\text{bin}} = H(B)$ 和每个模块的哈希 $h_i = H(M_i)$。\n- 序列化一个引用消息 $\\mathcal{S}$，其中包含 $h_{\\text{bin}}$、计数 $k$、每对 $(N_i, h_i)$，以及由挑战者提供的新鲜性 nonce $n$。TPM 生成一个证明标签 $$t = \\operatorname{HMAC}_K(\\mathcal{S}),$$ 其中 $K$ 是驻留在 TPM 中的证明密钥。在现实场景中，$K$ 将是非对称的（用于数字签名）；在本练习中，将 TPM 建模为持有用于 $\\operatorname{HMAC}$ 的对称密钥，以专注于完整性和新鲜性属性。\n- 验证者检查：(i) 提供的标签 $t$ 是否等于 $\\operatorname{HMAC}_{K_{\\text{ver}}}(\\mathcal{S})$，其中 $K_{\\text{ver}}$ 是其拥有的证明密钥副本（或以其他方式安全建立的共享秘密），(ii) 引用中的 nonce 是否与其质询 $n_{\\text{challenge}}$ 匹配，以及 (iii) $h_{\\text{bin}}$ 和 $\\{h_i\\}$ 是否与允许的已知良好度量值的白名单匹配。当且仅当所有三个条件都成立时，裁决为真。\n\n在您的实现逻辑中需要分析和编码的操作系统角色：\n- 操作系统必须调节度量过程，以便用户空间不能任意伪造 $\\mathcal{S}$。实际上，度量源于内核或受信任的加载器，并且 TPM 密钥 $K$ 必须受到保护，使用户空间无法计算 $\\operatorname{HMAC}_K$，除非通过受信任的路径。操作系统还通过其动态加载器管理模块加载，并可以枚举已加载的模块，以确保度量日志反映实际状态。\n- 您的程序应通过结构上区分有权访问 $K$ 的“TPM 引用”函数和验证者函数，并通过检查验证者维护的白名单来模拟这种分离。您还必须包含演示欺骗攻击及其检测的测试用例（例如，被篡改的模块、不正确的密钥或错误的 nonce 质询），以体现操作系统的作用。\n\n测试套件规范：\n使用以下五个测试用例来检验正确性、覆盖率和边界条件。字符串代表字节数组，应按原样使用。\n- 案例 $1$ (正常路径): 二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，引用 nonce $n = \\text{\"N1\"}$，验证者质询 $n_{\\text{challenge}} = \\text{\"N1\"}$。白名单精确包含 $B$ 和两个模块的内容。\n- 案例 $2$ (模块内容被篡改，但标签真实): 二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.1\"}), (\\text{\"libbeta\"}, \\text{\"libbeta v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，引用 nonce $n = \\text{\"N1\"}$，验证者质询 $n_{\\text{challenge}} = \\text{\"N1\"}$。白名单期望的是 $\\text{\"libalpha v1.0\"}$ 和 $\\text{\"libbeta v1.0\"}$；证明标签有效，但度量值与白名单不匹配。\n- 案例 $3$ (错误的 HMAC 密钥): 二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\\_BAD\"}$，引用 nonce $n = \\text{\"N2\"}$，验证者质询 $n_{\\text{challenge}} = \\text{\"N2\"}$。验证者使用 $K_{\\text{ver}} = \\text{\"K\\_AIK\"}$；因此标签验证失败。\n- 案例 $4$ (错误的 nonce): 二进制文件 $B = \\text{\"APP\\_A v1.0\"}$，模块 $\\{(\\text{\"libalpha\"}, \\text{\"libalpha v1.0\"})\\}$，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，引用 nonce $n = \\text{\"N3\"}$，验证者质询 $n_{\\text{challenge}} = \\text{\"N4\"}$。标签在 $K$ 下有效，但由于 nonce 不匹配，新鲜性验证失败。\n- 案例 $5$ (边界情况，零模块): 二进制文件 $B = \\text{\"APP\\_MIN\"}$，模块 $\\{\\}$ (空集，$k = 0$)，TPM 签名密钥 $K = \\text{\"K\\_AIK\"}$，引用 nonce $n = \\text{\"N5\"}$，验证者质询 $n_{\\text{challenge}} = \\text{\"N5\"}$。白名单仅包含 $B$ 并期望零个模块。\n\n您的程序必须：\n- 实现等同于 SHA-256 的 $H$ 和如上定义的块大小 $b = 64$ 字节的 $\\operatorname{HMAC}$。\n- 计算证明引用消息 $\\mathcal{S}$ 为一个字符串，其中包含 $h_{\\text{bin}}$ 的十六进制表示、模块计数 $k$、每对 $(N_i, h_i)$（其中 $h_i$ 为十六进制）和 nonce $n$。标签 $t$ 是基于此精确序列化计算的。\n- 对于每个测试用例，使用 TPM 签名密钥 $K$ 计算标签 $t$，然后使用验证者的密钥 $K_{\\text{ver}}$、质询 nonce $n_{\\text{challenge}}$ 和预期的白名单内容进行验证。当且仅当标签验证、nonce 相等性和白名单相等性都成立时，布尔结果为真。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含测试套件的五个布尔结果，形式为方括号内以逗号分隔的列表，例如：$[\\text{true},\\text{false},\\text{true},\\text{false},\\text{true}]$。布尔值必须是小写的英文单词。\n\n本问题不涉及物理单位或角度单位；不使用百分比。所有数值量必须表示为如上所示的包含在 LaTeX 美元符号中的数字。", "solution": "用户提供的问题已经过分析并确定为有效。它在科学上基于密码学和操作系统安全的既定原则，问题阐述清晰，具有明确的目标和确定性的测试用例，并且与指定领域相关。虽然引用消息 $\\mathcal{S}$ 的确切序列化格式没有严格定义，但这种微小的不明确性并不妨碍创建唯一且正确的解决方案，因为可以为证明生成和验证阶段建立并实施一个合理且一致的格式。我将继续提供完整的解决方案。\n\n该问题要求模拟一个远程证明协议，这是一种基础安全机制，允许远程验证者获取关于目标系统（称为证明者）软件状态的可信信息。该协议的安全性依赖于三个核心密码学原理：\n\n1.  **完整性 (Integrity)**：使用密码学哈希函数，指定为 $H$ (SHA-256)，为二进制文件 ($B$) 和每个加载的模块 ($M_i$) 创建一个简洁且唯一的指纹（摘要）。对二进制文件或模块的任何修改，无论多么微小，都会导致一个截然不同的哈希值。这使得验证者可以通过将接收到的哈希值与已知良好值的白名单进行比较来检测篡改。\n\n2.  **真实性 (Authenticity)**：使用密钥散列消息认证码 $\\operatorname{HMAC}_K(\\cdot)$ 来证明证明度量是由持有秘密密钥 $K$ 的一方生成的。在此模型中，密钥驻留在可信平台模块 (TPM) 这一硬件安全锚中。持有相同密钥副本 ($K_{\\text{ver}}$) 的验证者可以对接收到的消息重新计算 HMAC，并检查其是否与提供的标签匹配。匹配则证明了消息的来源，确保它来自可信的 TPM 而非冒名顶替者。HMAC 的公式如下：\n    $$\n    \\operatorname{HMAC}_K(m) = H\\left((K \\oplus \\text{opad}) \\parallel H\\left((K \\oplus \\text{ipad}) \\parallel m\\right)\\right)\n    $$\n    其中 $K$ 是秘密密钥，$m$ 是消息，$\\oplus$ 是按位异或操作，$\\parallel$ 表示串联，而 $\\text{ipad}$ 和 $\\text{opad}$ 是根据哈希函数的块大小（对于 SHA-256 为 $b=64$ 字节）标准化的填充常量。\n\n3.  **新鲜性 (Freshness)**：使用 nonce ($n$)，即“仅使用一次的数字”，来防止重放攻击。验证者（挑战者）生成一个随机 nonce $n_{\\text{challenge}}$ 并将其发送给证明者。证明者必须在其签名的证明引用中包含这个确切的 nonce。当验证者收到引用时，它会检查嵌入的 nonce $n$ 是否与原始的挑战 $n_{\\text{challenge}}$ 匹配。这确认了证明是最近生成的，而不是对过去某个可能已受损状态的记录。\n\n实现将按照所述的角色和约束进行结构化。\n\n**密码学原语实现**：\nC 程序将包含一个独立的 SHA-256 哈希算法实现，符合 FIPS PUB 180-4 标准。这涉及初始化哈希状态、处理 $64$ 字节块的输入数据以及完成计算以生成 $256$ 位（$32$ 字节）摘要的函数。随后，将基于提供的公式实现一个 `hmac_sha256` 函数，使用 SHA-256 实现作为其底层哈希函数 $H$。\n\n**协议和数据结构实现**：\n- **度量和引用 (Measurement and Quoting)**：一组函数将模拟证明者方。该过程首先计算主应用程序二进制文件的 SHA-256 哈希 ($h_{\\text{bin}} = H(B)$) 和每个已加载模块的哈希 ($h_i = H(M_i)$)。\n- **引用序列化 ($\\mathcal{S}$)**：将产生的度量结果序列化为单个字符串 $\\mathcal{S}$，以进行 HMAC 计算。为此序列化选择的格式是一个以空格分隔的字符串：`` `[h_bin_hex] [k] [N1]:[h1_hex] [N2]:[h2_hex] ... [Nk]:[hk_hex] [nonce]` ``。每个 $32$ 字节哈希摘要的十六进制表示将是一个 $64$ 个字符的字符串。这种格式是明确的，并包含了所有必需的信息。\n- **TPM 模拟**：一个函数将通过计算证明标签 $t = \\operatorname{HMAC}_K(\\mathcal{S})$ 来模拟 TPM 的可信操作，并将证明者的秘密密钥 $K$ 作为输入。\n- **验证 (Verification)**：一个独立的验证函数模拟远程客户端。该函数将执行三个关键检查：\n    1.  **标签验证**：它使用验证者的密钥 $K_{\\text{ver}}$ 对收到的引用字符串 $\\mathcal{S}$ 重新计算 HMAC，并将其与收到的标签 $t$ 进行比较。\n    2.  **Nonce 验证**：它从字符串 $\\mathcal{S}$ 中解析出 nonce $n$，并将其与内部持有的挑战 nonce $n_{\\text{challenge}}$进行比较。\n    3.  **白名单验证**：它从 $\\mathcal{S}$ 中解析出二进制文件哈希 $h_{\\text{bin}}$ 和所有模块哈希 $\\{h_i\\}$，并将它们与预定义的已知良好哈希白名单进行比较。\n\n一个测试用例当且仅当所有三个验证步骤都成功时才算通过。程序将执行五个指定的测试用例，每个用例都旨在探测协议安全性的一个不同方面：一次成功的证明（案例1）、检测被篡改的内容（案例2）、检测无效的签名密钥（案例3）、检测重放或不正确的 nonce（案例4），以及正确处理没有模块的边界情况（案例5）。最终输出将是一个布尔数组，反映每个测试的结果。", "answer": "```c\n#include", "id": "3631438"}]}