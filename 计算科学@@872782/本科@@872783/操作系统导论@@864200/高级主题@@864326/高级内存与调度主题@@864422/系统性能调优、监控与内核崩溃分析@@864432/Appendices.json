{"hands_on_practices": [{"introduction": "操作系统内核中的许多错误并非源于复杂的逻辑，而是源于对底层硬件行为的细微误解。一个经典的例子是基于整数溢出的时间计算错误，这可能导致定时器提前触发，引发系统崩溃。本练习让你化身内核开发者，通过分析有符号和无符号整数在模运算下的行为，来推导出一个关键的时间间隔安全边界，从而从根本上理解和预防这类底层错误。", "problem": "操作系统 (OS) 内核维护一个时钟节拍计数器，通常称为 jiffies 计数器，记为 $J$。计数器 $J$ 在每个时钟节拍加 1，并在硬件中表示为一个无符号 $b$ 位整数，因此对 $J$ 的算术运算是在模 $2^b$ 下执行的。在时钟节拍时间 $t$，一个子系统调度了一个未来的检查，其时间为 $E \\equiv t + \\Delta t \\pmod{2^{b}}$，其中 $\\Delta t$ 是以 jiffies 为单位的正整数。\n\n内核用于判断当前时钟节拍值 $n$ 是否“到达或超过到期时间” $E$ 的谓词，其实现方式是：首先计算 $b$ 位差值 $D \\equiv E - n \\pmod{2^{b}}$，然后将这个 $b$ 位的量 $D$ 解释为范围在 $[-2^{b-1}, 2^{b-1} - 1]$ 内的有符号二进制补码整数，最后当且仅当 $D \\le 0$ 时，宣告“已到期或已过期”。系统过去曾发生崩溃，因为某些较大的 $\\Delta t$ 值导致该谓词在调度时间 $n = t$ 时立即求值为真，从而触发乱序执行和故障。\n\n仅从无符号 $b$ 位算术运算是模 $2^b$ 的，以及二进制补码解释将 $b$ 位模式映射到有符号范围 $[-2^{b-1}, 2^{b-1} - 1]$ 这两个基本事实出发，推导出 $\\Delta t$ 的最大整数值（以 jiffies 为单位）。该值必须保证，对于 $J$ 的每一种可能的回绕行为，谓词对于所有 $n \\in \\{t, t+1, \\dots, E-1\\}$ 都保持为假，而在 $n=E$ 时（以及此后）变为真。将您的最终界限表示为以 $b$ 为变量的闭式解析表达式。无需取整。以 jiffies 为单位表示该界限。", "solution": "问题要求解出时间延迟 $\\Delta t$ 的最大正整数值，以确保一个在时间 $t$ 调度、到期时间为 $E \\equiv t + \\Delta t \\pmod{2^b}$ 的计时器不会过早触发。系统的时间计数器 $J$ 是一个 $b$ 位无符号整数，因此所有时间相关的算术运算都在模 $2^b$ 下进行。\n\n首先，我们必须将到期谓词形式化。检查在给定的时间 $n$ 执行。差值 $D$ 被计算为一个无符号 $b$ 位整数：\n$$D_u \\equiv E - n \\pmod{2^b}$$\n这个代表了无符号值 $D_u \\in [0, 2^b-1]$ 的 $b$ 位整数模式，随后被解释为一个有符号二进制补码整数 $D_s \\in [-2^{b-1}, 2^{b-1}-1]$。无符号值 $D_u$ 和有符号值 $D_s$ 之间的关系如下：\n$$\nD_s =\n\\begin{cases}\nD_u   \\text{如果 } 0 \\le D_u  2^{b-1} \\\\\nD_u - 2^b  \\text{如果 } 2^{b-1} \\le D_u  2^b\n\\end{cases}\n$$\n“已到期或已过期”的谓词是 $D_s \\le 0$。我们来确定对于哪些无符号值 $D_u$ 这个条件成立：\n1.  如果 $D_u \\in [1, 2^{b-1}-1]$，则 $D_s = D_u > 0$。谓词为假。\n2.  如果 $D_u = 0$，则 $D_s = 0$。谓词 $D_s \\le 0$ 为真。\n3.  如果 $D_u \\in [2^{b-1}, 2^b-1]$，则 $D_s = D_u - 2^b$。在此范围内，$D_s$ 的最大值是 $(2^b-1) - 2^b = -1$，最小值是 $2^{b-1} - 2^b = -2^{b-1}$。在这种情况下，$D_s \\le -1$。谓词 $D_s \\le 0$ 为真。\n\n因此，“已到期或已过期”的谓词为真，当且仅当无符号差值 $D_u$ 在范围 $[2^{b-1}, 2^b-1]$ 内或 $D_u=0$。反之，谓词为假（“尚未到期”）当且仅当 $D_u \\in [1, 2^{b-1}-1]$。\n\n问题要求找到满足以下两个条件的最大正整数 $\\Delta t$，这两个条件对任何起始时间 $t$ 都成立：\n条件 A：对于从 $t$ 开始直到（但不包括）$E$ 的时钟节拍序列中的所有 $n$，谓词为假。该时钟节拍序列可以表示为 $n_k = (t+k) \\pmod{2^b}$，其中 $k \\in \\{0, 1, 2, \\dots, \\Delta t-1\\}$。\n条件 B：对于 $n=E$ 及所有后续时钟节拍，谓词为真。\n\n我们来分析条件 A。对于每个 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$，我们必须确保谓词为假。这意味着无符号差值 $D_u$ 必须落在“尚未到期”的范围 $[1, 2^{b-1}-1]$ 内。\n对于一个时钟节拍 $n_k = (t+k) \\pmod{2^b}$，其无符号差值为：\n$$D_u(k) \\equiv E - n_k \\pmod{2^b}$$\n代入 $E$ 和 $n_k$ 的定义：\n$$D_u(k) \\equiv \\left( (t+\\Delta t)\\pmod{2^b} - (t+k)\\pmod{2^b} \\right) \\pmod{2^b}$$\n使用性质 $(a-b)\\pmod{m} \\equiv (a\\pmod{m} - b\\pmod{m})\\pmod{m}$，我们得到：\n$$D_u(k) \\equiv (t+\\Delta t - (t+k)) \\pmod{2^b} \\equiv (\\Delta t - k) \\pmod{2^b}$$\n因此，为使条件 A 成立，我们要求：\n$$(\\Delta t - k) \\pmod{2^b} \\in [1, 2^{b-1}-1] \\quad \\forall k \\in \\{0, 1, \\dots, \\Delta t-1\\}$$\n我们来分析这个约束。\n如果我们选择一个 $\\Delta t$ 的值使得 $\\Delta t \\ge 2^{b-1}$，我们可以找到一个违反该条件的 $k$ 值。考虑 $k=0$（调度时刻）。差值为 $D_u(0) \\equiv \\Delta t \\pmod{2^b}$。如果 $2^{b-1} \\le \\Delta t  2^b$，那么 $D_u(0) = \\Delta t$，这在“已到期”的范围 $[2^{b-1}, 2^b-1]$ 内。这会导致立即的、过早的到期，也就是所描述的那个 bug。\n更一般地，对于任何 $\\Delta t \\ge 2^{b-1}$，我们必须证明存在一个 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$ 违反该条件。让我们选择 $k$ 使得 $\\Delta t - k = 2^{b-1}$。这得出 $k = \\Delta t - 2^{b-1}$。由于 $\\Delta t \\ge 2^{b-1}$，我们有 $k \\ge 0$。同样，由于 $2^{b-1} > 0$，我们有 $k  \\Delta t$。所以这个 $k$ 值在指定的范围内。对于这个 $k$，差值为：\n$$D_u(k) = (\\Delta t - (\\Delta t-2^{b-1})) \\pmod{2^b} = 2^{b-1} \\pmod{2^b} = 2^{b-1}$$\n这个值 $2^{b-1}$ 不在“尚未到期”的范围 $[1, 2^{b-1}-1]$ 内。因此，任何 $\\Delta t \\ge 2^{b-1}$ 的选择都将导致在时钟节拍 $n = t + (\\Delta t - 2^{b-1})$ 时发生过早到期。因此，我们必须有 $\\Delta t  2^{b-1}$。\n\n现在，我们考虑任何满足 $\\Delta t \\le 2^{b-1}-1$ 的正整数 $\\Delta t$。\n对于 $k \\in \\{0, 1, \\dots, \\Delta t-1\\}$，$\\Delta t - k$ 的值构成以下序列：\n$$\\Delta t, \\Delta t-1, \\dots, 2, 1$$\n由于 $1 \\le \\Delta t \\le 2^{b-1}-1$，这个序列中的每一项都是正数且小于 $2^b$。因此，模运算 $(\\dots)\\pmod{2^b}$ 不起作用。差值序列 $D_u(k)$ 就是简单的 $\\{\\Delta t, \\Delta t-1, \\dots, 1\\}$。\n此外，由于此序列中的最大值是 $\\Delta t$，且我们已将 $\\Delta t$ 约束为 $\\Delta t \\le 2^{b-1}-1$，所以序列中的每个值都落在 $[1, 2^{b-1}-1]$ 范围内。这正是“尚未到期”的范围。\n因此，如果 $1 \\le \\Delta t \\le 2^{b-1}-1$，条件 A 得到满足。\n\n接下来，我们分析条件 B。在到期时钟节拍 $n=E$ 时，差值为：\n$$D_u \\equiv E - E \\pmod{2^b} = 0$$\n有符号解释为 $D_s=0$。谓词 $D_s \\le 0$ 为真。这对任何 $\\Delta t$ 都成立。对于到期后的时钟节拍，例如 $n = (E+j) \\pmod{2^b}$ 其中 $j \\ge 1$：\n$$D_u \\equiv E - (E+j) \\pmod{2^b} = -j \\pmod{2^b}$$\n无符号结果将在范围 $[2^b-j, 2^b-1]$ 内，该范围属于“已到期”区域（除非 $j$ 是 $2^b$ 的大倍数，此时差值为 $0$）。所以条件 B 总是满足的。\n\n综合这些约束，计时器正确行为的要求是 $1 \\le \\Delta t  2^{b-1}$，或者更精确地说，由于 $\\Delta t$ 必须是整数，所以是 $1 \\le \\Delta t \\le 2^{b-1}-1$。问题要求 $\\Delta t$ 的最大整数值。这就是推导出的有效范围的上限。\n\n$\\Delta t$ 的最大整数值是 $2^{b-1}-1$。", "answer": "$$\n\\boxed{2^{b-1} - 1}\n$$", "id": "3686534"}, {"introduction": "在理解了如何预防底层崩溃之后，我们转向性能调优的核心：量化开销。线程迁移是操作系统调度器的常见操作，但它并非“免费”的；每次迁移都会带来性能损失，因为它破坏了CPU缓存的局部性。本练习引导你基于计算机体系结构的基本原理，构建一个精确的性能模型，将“迁移开销”这一抽象概念分解为具体的硬件成本，如缓存行填充和TLB重载。", "problem": "您的任务是量化和建模操作系统调度器线程迁移所产生的开销，并将其表示为线程缓存足迹的函数。目标是设计一个程序，该程序能基于分层缓存和一致性共享内存的基本原理建立模型，并针对一小组测试场景计算以纳秒为单位的总迁移开销。该程序必须生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。\n\n调度器迁移会将一个正在运行的线程从一个处理器核心移动到另一个，这会导致该线程的私有缓存驻留失效。在包含一级（L1）、二级（L2）和共享末级缓存（LLC）的分层缓存设计下，我们关注迁移后占主导地位的冷启动开销组件。请假设以下原则和核心定义作为您推导的基础：\n\n- 缓存行是缓存填充的最小单位。设缓存行大小为 $\\ell$ 字节。\n- 大小为 $S_3$ 字节的共享末级缓存（LLC）最多可容纳 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行；如果线程的工作集足迹 $C$ 超过 $S_3$，则只有 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行可以从LLC提供，其余必须从主内存中获取。\n- 转译后备缓冲器（TLB）是每个核心私有的；迁移会丢弃TLB状态，并要求为每个接触到的不同页面至少重新填充一个TLB条目。设页面大小为 $P$ 字节。\n- 设从LLC补充每个缓存行的成本为 $t_{\\text{llc}}$ 纳秒，从主内存补充每个缓存行的成本为 $t_{\\text{mem}}$ 纳秒。设每个页面的TLB重载成本为 $t_{\\text{tlb}}$ 纳秒。设每次迁移的固定调度器管理开销为 $t_{\\text{sched}}$ 纳秒。\n\n您必须仅从这些基本原则出发，推导出单次迁移开销 $\\Delta M(C)$ 的模型，该模型要考虑到必须从LLC与主内存获取的缓存行数量，以及必须在目标核心的TLB中重新建立的页面翻译数量。在推导模型时，请使用以下逻辑约束：\n\n- 由足迹 $C$ 隐含的不同缓存行数量为 $\\lceil C / \\ell \\rceil$。\n- 每次迁移，LLC最多可提供 $\\left\\lfloor S_3 / \\ell \\right\\rfloor$ 个缓存行；任何额外需要的缓存行都从主内存获取。\n- 由足迹所涉及的页面数量为 $\\lceil C / P \\rceil$。\n\n然后，对于给定的 $m$ 次诱发迁移，总开销为 $T(m, C)$，您必须为每个测试案例计算此值。\n\n物理和数值单位要求：将您的最终输出以纳秒为单位表示为浮点值，并四舍五入到两位小数。\n\n您的程序必须实现上述要求，并为下面的测试套件生成结果。请完全按照给定的参数进行使用。所有大小单位为字节，所有时间成本单位为纳秒。\n\n常量（所有测试案例相同）：\n- 缓存行大小 $\\ell = 64$。\n- LLC大小 $S_3 = 8388608$。\n- 页面大小 $P = 4096$。\n- 每个缓存行的LLC补充成本 $t_{\\text{llc}} = 30$。\n- 每个缓存行的内存补充成本 $t_{\\text{mem}} = 100$。\n- 每个页面的TLB重载成本 $t_{\\text{tlb}} = 5$。\n- 每次迁移的调度器管理开销 $t_{\\text{sched}} = 1500$。\n\n测试套件（每个案例指定足迹 $C$ 和迁移次数 $m$）：\n- 案例A（理想路径，小足迹可完全放入LLC）：$C = 262144$，$m = 10$。\n- 案例B（大足迹超过LLC）：$C = 33554432$，$m = 3$。\n- 案例C（边界条件，足迹恰好等于LLC）：$C = 8388608$，$m = 1$。\n- 案例D（边缘情况，零次迁移）：$C = 1048576$，$m = 0$。\n- 案例E（边缘情况，足迹小于一个缓存行）：$C = 32$，$m = 5$。\n\n最终输出格式规范：\n您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表。第 $i$ 个元素必须是第 $i$ 个测试案例的总迁移开销 $T(m, C)$，单位为纳秒，四舍五入到两位小数。例如，输出应类似于 $[x_1,x_2,x_3,x_4,x_5]$，其中每个 $x_i$ 是一个浮点数。", "solution": "目标是推导出一个模型，用于计算一个缓存足迹大小为 $C$ 的线程在经历 $m$ 次调度器迁移时所产生的总开销 $T(m, C)$。该模型将基于所提供的关于缓存、内存和TLB行为的基本原理。\n\n总开销 $T(m, C)$ 是迁移次数 $m$ 与单次迁移开销 $\\Delta M(C)$ 的乘积。如果 $m=0$，总开销为 $0$。对于 $m > 0$：\n$$T(m, C) = m \\cdot \\Delta M(C)$$\n\n根据问题定义，单次迁移开销 $\\Delta M(C)$ 是三个不同组成部分的总和：\n1.  固定的调度器管理开销 $t_{\\text{sched}}$。\n2.  重载转译后备缓冲器（TLB）的可变成本，我们表示为 $\\text{Cost}_{\\text{TLB}}(C)$。\n3.  重新填充处理器缓存的可变成本，我们表示为 $\\text{Cost}_{\\text{cache}}(C)$。\n\n因此，单次迁移开销为：\n$$\\Delta M(C) = t_{\\text{sched}} + \\text{Cost}_{\\text{TLB}}(C) + \\text{Cost}_{\\text{cache}}(C)$$\n\n现在，我们将根据所提供的原则，为每个可变组件推导其函数形式。\n\n首先，我们对TLB重载成本 $\\text{Cost}_{\\text{TLB}}(C)$ 进行建模。一次迁移会使核心的TLB失效。其成本与线程足迹所占用的不同内存页面的数量成正比。给定页面大小为 $P$ 字节，足迹为 $C$ 字节，页面数量 $N_P(C)$ 是比率 $C/P$ 的向上取整。\n$$N_P(C) = \\left\\lceil \\frac{C}{P} \\right\\rceil$$\n每个页面的重载成本为 $t_{\\text{tlb}}$，因此总TLB开销为：\n$$\\text{Cost}_{\\text{TLB}}(C) = N_P(C) \\cdot t_{\\text{tlb}} = \\left\\lceil \\frac{C}{P} \\right\\rceil \\cdot t_{\\text{tlb}}$$\n\n其次，我们对缓存补充成本 $\\text{Cost}_{\\text{cache}}(C)$ 进行建模。一次迁移迫使新核心将其本地缓存填充入线程的工作集。数据以大小为 $\\ell$ 的缓存行为单位进行获取。对于一个足迹 $C$，所需的唯一缓存行总数为：\n$$N_L(C) = \\left\\lceil \\frac{C}{\\ell} \\right\\rceil$$\n这些缓存行要么从共享的末级缓存（LLC）获取，要么从主内存获取。LLC的容量是有限的。LLC能容纳的最大缓存行数量为：\n$$N_{L3}^{\\text{max}} = \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor$$\n其中 $S_3$ 是LLC的大小（字节）。\n\n该模型区分了两种获取这些缓存行来源的场景：\n- 如果线程所需的缓存行数 $N_L(C)$ 不超过LLC的容量 $N_{L3}^{\\text{max}}$，则假定所有缓存行都驻留在LLC中，并从那里获取。\n- 如果所需的缓存行数 $N_L(C)$ 超过LLC的容量 $N_{L3}^{\\text{max}}$，LLC只能提供其容量上限的缓存行。剩余的缓存行必须从速度慢得多的主内存中获取。\n\n我们可以通过定义从LLC获取的缓存行数 $N_{\\text{from\\_llc}}(C)$ 和从主内存获取的缓存行数 $N_{\\text{from\\_mem}}(C)$ 来将其形式化：\n$$N_{\\text{from\\_llc}}(C) = \\min\\left( N_L(C), N_{L3}^{\\text{max}} \\right)$$\n$$N_{\\text{from\\_mem}}(C) = N_L(C) - N_{\\text{from\\_llc}}(C) = \\max\\left(0, N_L(C) - N_{L3}^{\\text{max}}\\right)$$\n\n总缓存补充成本是来自两个来源的成本之和，使用它们各自的单位缓存行补充成本 $t_{\\text{llc}}$ 和 $t_{\\text{mem}}$：\n$$\\text{Cost}_{\\text{cache}}(C) = \\left( N_{\\text{from\\_llc}}(C) \\cdot t_{\\text{llc}} \\right) + \\left( N_{\\text{from\\_mem}}(C) \\cdot t_{\\text{mem}} \\right)$$\n\n综合所有组件，单次迁移开销 $\\Delta M(C)$ 的完整公式为：\n$$\\Delta M(C) = t_{\\text{sched}} + \\left( \\left\\lceil \\frac{C}{P} \\right\\rceil \\cdot t_{\\text{tlb}} \\right) + \\left( \\min\\left(\\left\\lceil \\frac{C}{\\ell} \\right\\rceil, \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor\\right) \\cdot t_{\\text{llc}} \\right) + \\left( \\max\\left(0, \\left\\lceil \\frac{C}{\\ell} \\right\\rceil - \\left\\lfloor \\frac{S_3}{\\ell} \\right\\rfloor\\right) \\cdot t_{\\text{mem}} \\right)$$\n\n现在我们将这个模型应用到测试套件中，使用提供的常量：\n- $\\ell = 64$ 字节\n- $S_3 = 8388608$ 字节\n- $P = 4096$ 字节\n- $t_{\\text{llc}} = 30$ 纳秒\n- $t_{\\text{mem}} = 100$ 纳秒\n- $t_{\\text{tlb}} = 5$ 纳秒\n- $t_{\\text{sched}} = 1500$ 纳秒\n\n首先，我们计算LLC以缓存行为单位的容量：\n$$N_{L3}^{\\text{max}} = \\left\\lfloor \\frac{8388608}{64} \\right\\rfloor = \\lfloor 131072 \\rfloor = 131072 \\text{ 行}$$\n\n**案例A**：$C = 262144$，$m = 10$\n- $N_L(C) = \\lceil 262144 / 64 \\rceil = 4096$ 行\n- $N_P(C) = \\lceil 262144 / 4096 \\rceil = 64$ 页\n- 由于 $N_L(C) \\le N_{L3}^{\\text{max}}$，所有缓存行都来自LLC。\n- $\\Delta M(C) = 1500 + (64 \\cdot 5) + (4096 \\cdot 30) = 1500 + 320 + 122880 = 124700$ 纳秒\n- $T(m, C) = 10 \\cdot 124700 = 1247000$ 纳秒\n\n**案例B**：$C = 33554432$，$m = 3$\n- $N_L(C) = \\lceil 33554432 / 64 \\rceil = 524288$ 行\n- $N_P(C) = \\lceil 33554432 / 4096 \\rceil = 8192$ 页\n- 由于 $N_L(C) > N_{L3}^{\\text{max}}$，缓存行来自LLC和主内存。\n- $N_{\\text{from\\_llc}} = 131072$；$N_{\\text{from\\_mem}} = 524288 - 131072 = 393216$\n- $\\Delta M(C) = 1500 + (8192 \\cdot 5) + (131072 \\cdot 30) + (393216 \\cdot 100)$\n- $\\Delta M(C) = 1500 + 40960 + 3932160 + 39321600 = 43296220$ 纳秒\n- $T(m, C) = 3 \\cdot 43296220 = 129888660$ 纳秒\n\n**案例C**：$C = 8388608$，$m = 1$\n- $N_L(C) = \\lceil 8388608 / 64 \\rceil = 131072$ 行\n- $N_P(C) = \\lceil 8388608 / 4096 \\rceil = 2048$ 页\n- 此处 $N_L(C) = N_{L3}^{\\text{max}}$，因此所有缓存行都来自LLC。\n- $\\Delta M(C) = 1500 + (2048 \\cdot 5) + (131072 \\cdot 30) = 1500 + 10240 + 3932160 = 3943900$ 纳秒\n- $T(m, C) = 1 \\cdot 3943900 = 3943900$ 纳秒\n\n**案例D**：$C = 1048576$，$m = 0$\n- 由于 $m = 0$，没有发生迁移。\n- $T(m, C) = 0$ 纳秒\n\n**案例E**：$C = 32$，$m = 5$\n- $N_L(C) = \\lceil 32 / 64 \\rceil = 1$ 行\n- $N_P(C) = \\lceil 32 / 4096 \\rceil = 1$ 页\n- 由于 $N_L(C) \\le N_{L3}^{\\text{max}}$，所有缓存行都来自LLC。\n- $\\Delta M(C) = 1500 + (1 \\cdot 5) + (1 \\cdot 30) = 1500 + 5 + 30 = 1535$ 纳秒\n- $T(m, C) = 5 \\cdot 1535 = 7675$ 纳秒\n\n最终结果，四舍五入到两位小数，如下：A: $1247000.00$，B: $129888660.00$，C: $3943900.00$，D: $0.00$，E: $7675.00$。", "answer": "[1247000.00, 129888660.00, 3943900.00, 0.00, 7675.00]", "id": "3686454"}, {"introduction": "现代操作系统的性能瓶颈常常出现在多核协作的环节。当一个核心修改内存映射时，必须通知所有其他核心使其TLB（转译后备缓冲器）条目失效，这一过程称为“TLB Shootdown”，是典型的系统级同步开销。本练习将指导你运用排队论来为这一复杂的同步过程建模，从而分析在高并发下系统性能如何因竞争和等待而下降。", "problem": "给定一个场景，其中频繁的内存映射操作会触发跨多个处理器核心的转换后备缓冲区 (TLB) 汰除。一次 TLB 汰除需要所有其他核心接收到一个处理器间中断 (IPI)，并在发起线程继续执行之前确认 TLB 条目的失效。目标是设计一个工作负载模型，用以在 $n$ 个线程上进行频繁内存映射操作的情况下，隔离出完全由汰除机制导致的阻塞时间，并计算每次操作的预期阻塞时间，记为 $T_{shootdown}$，单位为微秒。\n\n将使用的基本假设和定义：\n- 转换后备缓冲区 (TLB)：每个核心维护的虚拟到物理地址转换的缓存。\n- 处理器间中断 (IPI)：一种用于中断其他核心以执行诸如使 TLB 条目失效等操作的机制。\n- 存在 $C$ 个在线核心。当一个线程发起 TLB 汰除时，会向其他 $C - 1$ 个核心发送 IPI。\n- 每个目标核心的确认时间是一个独立的指数随机变量，其速率参数为 $\\lambda$（单位：每微秒）。\n- 每次内存映射操作会在发起核心上本地使 $L$ 个页面失效，产生每页 $t_p$ 微秒的工作量。此外，还有 $t_b$ 微秒的 IPI 广播设置成本。\n- 在 $n$ 个线程中，每个线程以每秒 $r$ 次操作的速率执行内存映射操作。全局 TLB 汰除受单个全局锁保护，因此并发的汰除操作被序列化为单服务台队列。假设汰除请求的到达过程为泊松过程，服务时间为由上述量决定的指数分布。\n\n您的任务：\n1. 基于这些假设，推导每次汰除的预期服务时间，表示为 $C$、$\\lambda$、$L$、$t_p$ 和 $t_b$ 的函数，过程中不引入任何未声明的简化方法。\n2. 使用基于所述假设的有原则的单服务台排队模型，推导每次操作的预期阻塞时间 $T_{shootdown}$，表示为服务时间以及由 $n$ 个线程（每个线程每秒发出 $r$ 次操作）产生的总到达率的函数。\n\n单位与输出要求：\n- 以微秒表示 $T_{shootdown}$，并四舍五入到六位小数。\n- 本问题不涉及角度。\n- 如果涉及百分比，必须以小数形式表示，且不应使用百分号。\n- 您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,...]”）。\n\n测试套件：\n为以下参数集计算 $T_{shootdown}$。对于每个测试用例，所有时间量（$t_b$、$t_p$）的单位均为微秒，$\\lambda$ 的单位为每微秒。输出必须是一个浮点值列表，按下面提供的顺序对应每个用例的 $T_{shootdown}$。\n\n- Case A (理想情况): $n = 4$, $C = 8$, $r = 1000$, $L = 1$, $t_b = 3$, $t_p = 0.05$, $\\lambda = 0.1$。\n- Case B (近饱和边界): $n = 8$, $C = 32$, $r = 1700$, $L = 512$, $t_b = 3$, $t_p = 0.05$, $\\lambda = 0.1$。\n- Case C (单线程边界情况): $n = 1$, $C = 8$, $r = 100$, $L = 1$, $t_b = 3$, $t_p = 0.05$, $\\lambda = 0.1$。\n- Case D ($n$ 值大但每线程速率小的情况): $n = 64$, $C = 32$, $r = 100$, $L = 16$, $t_b = 3$, $t_p = 0.05$, $\\lambda = 0.1$。\n\n最终输出格式：\n- 您的程序应只生成一行输出：一个格式为“[x1,x2,x3,x4]”的列表，其中每个 $x_i$ 是对应情况计算出的 $T_{shootdown}$，以微秒表示并四舍五入到六位小数。", "solution": "步骤 $1$：跨 $C - 1$ 个核心的预期屏障时间。当一次汰除被发起时，发起核心会向其他 $C - 1$ 个核心发送处理器间中断 (IPI)，并等待直到所有核心都已确认。设来自每个目标核心的确认时间为一个独立的指数随机变量，其速率为 $\\lambda$（每微秒）。将确认时间记为 $X_1, X_2, \\ldots, X_{C-1}$，其中 $X_i \\sim \\text{Exponential}(\\lambda)$ 且相互独立。当最慢的确认到达时，屏障完成，即取最大值 $M = \\max\\{X_1, X_2, \\ldots, X_{C-1}\\}$。\n\n对于独立同分布的指数随机变量，其最大值的期望通过顺序统计量有一个已知的关系。设 $m = C - 1$。则期望最大值为\n$$\n\\mathbb{E}[M] = \\frac{H_m}{\\lambda},\n$$\n其中 $H_m$ 是第 $m$ 个调和数，\n$$\nH_m = \\sum_{k=1}^{m} \\frac{1}{k}.\n$$\n此结果源于指数随机变量顺序统计量的分解：排序后的指数变量之间的间隔是独立的指数变量，其速率分别为 $m\\lambda, (m-1)\\lambda, \\ldots, \\lambda$，因此最大值的均值是这些间隔的均值之和，\n$$\n\\mathbb{E}[M] = \\frac{1}{m\\lambda} + \\frac{1}{(m-1)\\lambda} + \\cdots + \\frac{1}{\\lambda} = \\frac{H_m}{\\lambda}.\n$$\n\n步骤 $2$：每次汰除的非屏障成本。除了等待确认之外，还有本地成本：\n- IPI 广播设置成本 $t_b$（单位：微秒）。\n- 本地失效成本 $L \\cdot t_p$（单位：微秒），针对 $L$ 个页面，每页 $t_p$ 微秒。\n\n因此，单次汰除的预期服务时间 $S$（单位：微秒）是这些组成部分的总和：\n$$\nS = t_b + L t_p + \\frac{H_{C-1}}{\\lambda}.\n$$\n\n步骤 $3$：跨 $n$ 个并发线程的到达率。$n$ 个线程中的每一个都以每秒 $r$ 次操作的速率发出内存映射操作，因此总到达率为\n$$\n\\alpha = n r \\quad \\text{(operations per second)}.\n$$\n为了与 $S$ 的单位（微秒）相匹配，将到达率转换为每微秒的操作次数：\n$$\na = \\frac{\\alpha}{10^6} = \\frac{n r}{10^6}.\n$$\n\n步骤 $4$：在全局汰除锁下的序列化。全局汰除锁将汰除操作序列化，这可以建模为单服务台队列。在到达过程为泊松过程（由于独立线程发出操作）和服务时间为指数分布（如上所述）的假设下，该队列是一个 $\\text{M}/\\text{M}/1$ 系统，其服务率为\n$$\n\\mu = \\frac{1}{S} \\quad \\text{(operations per microsecond)}.\n$$\n定义服务器利用率\n$$\n\\rho = \\frac{a}{\\mu} = a S.\n$$\n对于一个稳定系统，必须满足 $\\rho  1$。$\\text{M}/\\text{M}/1$ 系统中的预期在系统时间（等待时间加服务时间）为\n$$\nW = \\frac{1}{\\mu - a}.\n$$\n这可以根据 $S$ 和 $\\rho$ 重写为：\n$$\nW = \\frac{1}{\\frac{1}{S} - a} = \\frac{S}{1 - a S} = \\frac{S}{1 - \\rho}.\n$$\n量 $W$ 表示线程在汰除期间经历的预期阻塞时间，因为线程在继续执行前需要等待锁和服务的完成。因此，每次操作所需的汰除开销为\n$$\nT_{shootdown} = W = \\frac{S}{1 - \\rho} = \\frac{t_b + L t_p + \\frac{H_{C-1}}{\\lambda}}{1 - \\left(\\frac{n r}{10^6}\\right)\\left(t_b + L t_p + \\frac{H_{C-1}}{\\lambda}\\right)}.\n$$\n\n步骤 $5$：算法计算。为每个测试用例计算 $T_{shootdown}$：\n- 计算调和数 $H_{C-1} = \\sum_{k=1}^{C-1} \\frac{1}{k}$。\n- 计算 $S = t_b + L t_p + \\frac{H_{C-1}}{\\lambda}$。\n- 计算 $a = \\frac{n r}{10^6}$。\n- 计算 $\\rho = a S$ 并验证 $\\rho  1$。\n- 计算 $T_{shootdown} = \\frac{S}{1 - \\rho}$，单位为微秒。\n- 输出时四舍五入到六位小数。", "answer": "[32.776654, 1012.250591, 29.062534, 60.763590]", "id": "3686443"}]}