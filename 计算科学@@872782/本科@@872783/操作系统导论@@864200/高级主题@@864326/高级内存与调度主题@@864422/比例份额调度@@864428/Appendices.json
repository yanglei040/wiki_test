{"hands_on_practices": [{"introduction": "比例份额调度的一个关键实现是步幅调度（stride scheduling），它是一种确定性算法，通过为每个任务维护一个“步幅”和“通行值”来精确控制CPU分配。本练习将带你动手模拟一个分层步幅调度过程，这在类似Linux控制组（cgroups）的现代系统中非常普遍。通过亲手计算调度决策，你将深入理解该算法的核心机制，并掌握其在多层次资源竞争环境下的工作原理。", "problem": "考虑一个运行着分层比例共享调度器的单中央处理器 (CPU)。两个控制组 (cgroups) $G_{1}$ 和 $G_{2}$ 竞争 CPU；在每个 cgroup 内部，任务根据其各自的份额进行竞争。该调度器使用分层步长调度来实现比例共享。在 cgroup 级别，调度器维护每个 cgroup 的 pass 值和每个 cgroup 的步长。在每次调度决策时，它选择具有最小 pass 值的 cgroup（平局时选择 cgroup 索引较小者），然后将该 cgroup 的 pass 值增加其步长。在选定的 cgroup 内部，调度器维护每个任务的 pass 值和每个任务的步长，选择具有最小 pass 值的任务（平局时选择任务索引较小者），然后将该任务的 pass 值增加其步长。所有 pass 值初始均为 $0$。\n\n给定以下配置：\n- Cgroup 份额：$S_{G_{1}} = 3$, $S_{G_{2}} = 2$。\n- $G_{1}$ 中各任务的份额：任务 $T_{1}$ 的份额为 $s_{1} = 2$，任务 $T_{2}$ 的份额为 $s_{2} = 1$。\n- $G_{2}$ 中各任务的份额：任务 $T_{3}$ 的份额为 $s_{3} = 1$，任务 $T_{4}$ 的份额为 $s_{4} = 3$。\n\n分层步长调度使用以下步长常数：\n- 用于 cgroups 的全局常数 $K = 30$，得出 cgroup 步长为 $\\text{stride}(G_{i}) = \\frac{K}{S_{G_{i}}}$。\n- $G_{1}$ 的 cgroup 局部常数为 $K_{1} = 12$，$G_{2}$ 的 cgroup 局部常数为 $K_{2} = 12$，得出每个 cgroup 内各任务的步长为 $\\text{stride}(T_{j}) = \\frac{K_{g}}{s_{j}}$，其中 $K_{g}$ 是包含任务 $T_{j}$ 的 cgroup 的常数。\n\n任务的全局标识符定义如下：$T_{1}$ 的标识符为 $1$，$T_{2}$ 的标识符为 $2$，$T_{3}$ 的标识符为 $3$，$T_{4}$ 的标识符为 $4$。\n\n从所有 pass 值等于 $0$ 开始，计算在第 $11$ 次调度决策时被选中的任务的全局标识符（一个整数）。无需四舍五入；请提供最终的整数标识符。", "solution": "问题要求确定一个分层比例共享调度器在第 $11$ 个决策点调度的任务。调度策略被指定为分层步长调度。这个过程是确定性的，由控制组 (cgroups) 和单个任务的 pass 值和步长共同决定。\n\n首先，我们必须计算所有可调度实体的步长值。步长与份额成反比，使用提供的常数计算得出。\n\ncgroup 的份额为 $S_{G_{1}} = 3$ 和 $S_{G_{2}} = 2$。用于 cgroups 的全局常数为 $K = 30$。每个 cgroup 的步长 $\\text{stride}(G_i)$ 由 $\\frac{K}{S_{G_i}}$ 给出。\ncgroup $G_1$ 的步长是：\n$$ \\text{stride}(G_{1}) = \\frac{K}{S_{G_{1}}} = \\frac{30}{3} = 10 $$\ncgroup $G_2$ 的步长是：\n$$ \\text{stride}(G_{2}) = \\frac{K}{S_{G_{2}}} = \\frac{30}{2} = 15 $$\n\n接下来，我们计算每个 cgroup 内任务的步长。\n对于 cgroup $G_1$，任务为 $T_1$（份额 $s_1 = 2$）和 $T_2$（份额 $s_2 = 1$）。cgroup 局部常数为 $K_1 = 12$。该组中任务 $T_j$ 的步长为 $\\frac{K_1}{s_j}$。\n任务 $T_1$ 的步长是：\n$$ \\text{stride}(T_{1}) = \\frac{K_1}{s_{1}} = \\frac{12}{2} = 6 $$\n任务 $T_2$ 的步长是：\n$$ \\text{stride}(T_{2}) = \\frac{K_1}{s_{2}} = \\frac{12}{1} = 12 $$\n\n对于 cgroup $G_2$，任务为 $T_3$（份额 $s_3 = 1$）和 $T_4$（份额 $s_4 = 3$）。cgroup 局部常数为 $K_2 = 12$。该组中任务 $T_j$ 的步长为 $\\frac{K_2}{s_j}$。\n任务 $T_3$ 的步长是：\n$$ \\text{stride}(T_{3}) = \\frac{K_2}{s_{3}} = \\frac{12}{1} = 12 $$\n任务 $T_4$ 的步长是：\n$$ \\text{stride}(T_{4}) = \\frac{K_2}{s_{4}} = \\frac{12}{3} = 4 $$\n\n所有 cgroups 和任务的初始 pass 值均为 $0$。令 $P(X)$ 表示实体 $X$ 的 pass 值。\n初始状态：$P(G_1) = 0$, $P(G_2) = 0$, $P(T_1) = 0$, $P(T_2) = 0$, $P(T_3) = 0$, $P(T_4) = 0$。\n我们现在模拟 $11$ 个步骤的调度过程。\n\n第 $1$ 步：\n- Cgroup 选择：$P(G_1) = 0$ 且 $P(G_2) = 0$。平局时由较小索引打破，因此选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 0$ 且 $P(T_2) = 0$。平局时由较小索引打破，因此选择 $T_1$。\n- 调度：$T_1$。\n- 更新 pass 值：$P(T_1) \\leftarrow P(T_1) + \\text{stride}(T_1) = 0 + 6 = 6$。$P(G_1) \\leftarrow P(G_1) + \\text{stride}(G_1) = 0 + 10 = 10$。\n\n第 $2$ 步：\n- Cgroup 选择：$P(G_1) = 10$, $P(G_2) = 0$。选择 $G_2$。\n- 任务选择 (在 $G_2$ 中)：$P(T_3) = 0$, $P(T_4) = 0$。平局，选择 $T_3$。\n- 调度：$T_3$。\n- 更新 pass 值：$P(T_3) \\leftarrow 0 + 12 = 12$。$P(G_2) \\leftarrow 0 + 15 = 15$。\n\n第 $3$ 步：\n- Cgroup 选择：$P(G_1) = 10$, $P(G_2) = 15$。选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 6$, $P(T_2) = 0$。选择 $T_2$。\n- 调度：$T_2$。\n- 更新 pass 值：$P(T_2) \\leftarrow 0 + 12 = 12$。$P(G_1) \\leftarrow 10 + 10 = 20$。\n\n第 $4$ 步：\n- Cgroup 选择：$P(G_1) = 20$, $P(G_2) = 15$。选择 $G_2$。\n- 任务选择 (在 $G_2$ 中)：$P(T_3) = 12$, $P(T_4) = 0$。选择 $T_4$。\n- 调度：$T_4$。\n- 更新 pass 值：$P(T_4) \\leftarrow 0 + 4 = 4$。$P(G_2) \\leftarrow 15 + 15 = 30$。\n\n第 $5$ 步：\n- Cgroup 选择：$P(G_1) = 20$, $P(G_2) = 30$。选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 6$, $P(T_2) = 12$。选择 $T_1$。\n- 调度：$T_1$。\n- 更新 pass 值：$P(T_1) \\leftarrow 6 + 6 = 12$。$P(G_1) \\leftarrow 20 + 10 = 30$。\n\n第 $6$ 步：\n- Cgroup 选择：$P(G_1) = 30$, $P(G_2) = 30$。平局，选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 12$, $P(T_2) = 12$。平局，选择 $T_1$。\n- 调度：$T_1$。\n- 更新 pass 值：$P(T_1) \\leftarrow 12 + 6 = 18$。$P(G_1) \\leftarrow 30 + 10 = 40$。\n\n第 $7$ 步：\n- Cgroup 选择：$P(G_1) = 40$, $P(G_2) = 30$。选择 $G_2$。\n- 任务选择 (在 $G_2$ 中)：$P(T_3) = 12$, $P(T_4) = 4$。选择 $T_4$。\n- 调度：$T_4$。\n- 更新 pass 值：$P(T_4) \\leftarrow 4 + 4 = 8$。$P(G_2) \\leftarrow 30 + 15 = 45$。\n\n第 $8$ 步：\n- Cgroup 选择：$P(G_1) = 40$, $P(G_2) = 45$。选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 18$, $P(T_2) = 12$。选择 $T_2$。\n- 调度：$T_2$。\n- 更新 pass 值：$P(T_2) \\leftarrow 12 + 12 = 24$。$P(G_1) \\leftarrow 40 + 10 = 50$。\n\n第 $9$ 步：\n- Cgroup 选择：$P(G_1) = 50$, $P(G_2) = 45$。选择 $G_2$。\n- 任务选择 (在 $G_2$ 中)：$P(T_3) = 12$, $P(T_4) = 8$。选择 $T_4$。\n- 调度：$T_4$。\n- 更新 pass 值：$P(T_4) \\leftarrow 8 + 4 = 12$。$P(G_2) \\leftarrow 45 + 15 = 60$。\n\n第 $10$ 步：\n- Cgroup 选择：$P(G_1) = 50$, $P(G_2) = 60$。选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 18$, $P(T_2) = 24$。选择 $T_1$。\n- 调度：$T_1$。\n- 更新 pass 值：$P(T_1) \\leftarrow 18 + 6 = 24$。$P(G_1) \\leftarrow 50 + 10 = 60$。\n\n第 $11$ 步：\n- Cgroup 选择：$P(G_1) = 60$, $P(G_2) = 60$。平局，选择 $G_1$。\n- 任务选择 (在 $G_1$ 中)：$P(T_1) = 24$, $P(T_2) = 24$。平局，选择 $T_1$。\n- 调度：$T_1$。\n\n在第 $11$ 次调度决策时选择的任务是 $T_1$。问题要求该任务的全局标识符。$T_1$ 的标识符被给出为 $1$。", "answer": "$$ \\boxed{1} $$", "id": "3673648"}, {"introduction": "为了提高I/O密集型任务的响应速度，一些调度器引入了“睡眠奖励”机制，但这可能导致恶意任务通过操纵睡眠-运行周期来获得不公平的CPU份额。本练习模拟了这样一个场景，你需要运用积分来量化这种策略滥用所带来的影响，并评估一个常见的修复方法——设置奖励上限——的有效性。这个练习旨在揭示调度策略设计中的微妙权衡，以及在理论模型和实际安全性之间取得平衡的重要性。", "problem": "一个单处理器调度程序通过抽签机制实现比例份额策略：当多个任务可运行时，每个任务 $i$ 都有一个当前的票数 $t_i$，从长远来看，其预期的中央处理器 (CPU) 占用率等于 $t_i / \\sum_j t_j$。为了提高交互性，调度程序为因输入/输出 (I/O) 而阻塞的任务提供睡眠奖励：在睡眠期间，任务以速率 $\\sigma$（票/毫秒）累积奖励票；在运行时，其奖励以速率 $\\delta$（票/毫秒）确定性地衰减。任务 $i$ 在可运行时的有效票数是 $t_i^{\\mathrm{eff}}(t) = w_i + b_i(t)$，其中 $w_i$ 是固定的基础票数，$b_i(t)$ 是当前的奖励；奖励永远不会低于 $0$。\n\n考虑三个任务，它们的基础票数相等，$w_A = w_B = w_C = 10$。任务 $B$ 和 $C$ 是 CPU 密集型任务，从不睡眠，所以 $b_B(t) = 0$ 和 $b_C(t) = 0$ 始终成立。任务 $A$ 行为不当：它重复一个固定的周期性模式，旨在收获睡眠积分然后加以利用。在每个周期中，它睡眠 $S$ 毫秒以累积奖励，然后唤醒并保持可运行状态正好 $R$ 毫秒，之后发起新的 I/O 再次进入睡眠。假设 $\\sigma = 10$ 票/毫秒，$\\delta = 2$ 票/毫秒，$S = 5$ 毫秒，以及 $R = 20$ 毫秒。因此，在没有任何上限的情况下，任务 $A$ 唤醒时的奖励为 $b_A(0) = \\sigma S$，然后在 $R$ 毫秒的运行阶段，其奖励线性衰减为 $b_A(t) = \\max(0, \\sigma S - \\delta t)$，其中 $t \\in [0, R]$。\n\n现在考虑一种修复方案：对睡眠奖励设置上限，使得唤醒时 $b_A(0) = \\min(\\sigma S, b_{\\max})$，其中 $b_{\\max} = 20$ 票，并在运行时继续以每毫秒 $\\delta$ 的速率衰减，永不低于 $0$。\n\n仅使用上面陈述的比例份额调度的核心定义，并将时刻 $t$ 的瞬时预期 CPU 份额视为 $t_A^{\\mathrm{eff}}(t) / \\big(t_A^{\\mathrm{eff}}(t) + t_B^{\\mathrm{eff}}(t) + t_C^{\\mathrm{eff}}(t)\\big)$，确定任务 $A$ 在两种情况下的长期平均 CPU 分数：（i）无上限，和（ii）有上限 $b_{\\max} = 20$。长期平均 CPU 分数是瞬时预期 CPU 分数在整个周期内的时间平均值，该周期由一个 $R$ 毫秒的运行阶段和一个 $S$ 毫秒的睡眠阶段组成（在睡眠阶段，任务 A 的份额为 $0$）。\n\n哪个选项给出了正确的“无上限；有上限”的任务 $A$ 的长期平均 CPU 分数对？\n\n- A. 加上限前：$0.523$；加上限后：$0.329$。\n- B. 加上限前：$0.653$；加上限后：$0.333$。\n- C. 加上限前：$0.800$；加上限后：$0.600$。\n- D. 加上限前：$0.475$；加上限后：$0.400$。", "solution": "### 推导过程\n任务 A 一个周期的总时长是 $T_{cycle} = S + R = 5 \\text{ ms} + 20 \\text{ ms} = 25 \\text{ ms}$。\n任务 A 的长期平均 CPU 分数，记为 $\\bar{f}_A$，是 A 在一个周期内消耗的总 CPU 时间除以周期时长。该周期包括一个时长为 $S$ 的睡眠阶段（CPU 使用率为 $0$）和一个时长为 $R$ 的运行阶段。\n\n当任务 A 可运行时，其瞬时预期 CPU 分数为：\n$$f_A(t) = \\frac{t_A^{\\mathrm{eff}}(t)}{t_A^{\\mathrm{eff}}(t) + t_B^{\\mathrm{eff}}(t) + t_C^{\\mathrm{eff}}(t)} = \\frac{w_A + b_A(t)}{(w_A + b_A(t)) + w_B + w_C}$$\n代入基础票数 $w_A = w_B = w_C = 10$：\n$$f_A(t) = \\frac{10 + b_A(t)}{(10 + b_A(t)) + 10 + 10} = \\frac{10 + b_A(t)}{30 + b_A(t)}$$\n长期平均 CPU 分数是 $f_A(t)$ 在整个周期内的时间平均值。设 $t$ 为任务 A 变为可运行状态后经过的时间。\n$$\\bar{f}_A = \\frac{1}{S+R} \\left( \\int_0^S 0 \\cdot dt' + \\int_0^R f_A(t) \\cdot dt \\right) = \\frac{1}{25} \\int_0^{20} \\frac{10 + b_A(t)}{30 + b_A(t)} dt$$\n\n**情况 (i)：无奖励上限**\n\n首先，我们确定运行阶段的奖励函数 $b_A(t)$。任务 A 睡眠 $S=5$ 毫秒，以 $\\sigma=10$ 票/毫秒的速率累积奖励。\n唤醒时的初始奖励是 $b_A(0) = \\sigma S = 10 \\times 5 = 50$ 票。\n在运行阶段，该奖励以 $\\delta=2$ 票/毫秒的速率衰减。因此，对于 $t \\in [0, 20]$，奖励为：\n$$b_A(t) = b_A(0) - \\delta t = 50 - 2t$$\n由于运行阶段长为 $R=20$ 毫秒，最小奖励为 $b_A(20) = 50 - 2(20) = 10$，大于 $0$。因此，在整个运行阶段 $b_A(t) = 50 - 2t$。\n\n现在，我们计算平均分数：\n$$\\bar{f}_{A, \\text{no cap}} = \\frac{1}{25} \\int_0^{20} \\frac{10 + (50 - 2t)}{30 + (50 - 2t)} dt = \\frac{1}{25} \\int_0^{20} \\frac{60 - 2t}{80 - 2t} dt = \\frac{1}{25} \\int_0^{20} \\frac{30 - t}{40 - t} dt$$\n为了求解积分，我们重写被积函数：\n$$\\frac{30 - t}{40 - t} = \\frac{(40 - t) - 10}{40 - t} = 1 - \\frac{10}{40 - t}$$\n积分变为：\n$$\\int_0^{20} \\left(1 - \\frac{10}{40 - t}\\right) dt = \\left[ t + 10 \\ln(40 - t) \\right]_0^{20}$$\n$$= (20 + 10 \\ln(40 - 20)) - (0 + 10 \\ln(40 - 0))$$\n$$= 20 + 10 \\ln(20) - 10 \\ln(40) = 20 + 10 \\ln\\left(\\frac{20}{40}\\right) = 20 + 10 \\ln(0.5) = 20 - 10 \\ln(2)$$\n使用数值 $\\ln(2) \\approx 0.69315$：\n$$\\text{积分值} \\approx 20 - 10(0.69315) = 20 - 6.9315 = 13.0685$$\n最后，平均 CPU 分数为：\n$$\\bar{f}_{A, \\text{no cap}} = \\frac{1}{25} (20 - 10 \\ln(2)) \\approx \\frac{13.0685}{25} \\approx 0.52274$$\n\n**情况 (ii)：有奖励上限 $b_{\\max} = 20$**\n\n睡眠带来的潜在奖励仍然是 $\\sigma S = 50$。然而，它被限制在 $b_{\\max} = 20$ 的上限。\n唤醒时的初始奖励是 $b_A(0) = \\min(\\sigma S, b_{\\max}) = \\min(50, 20) = 20$ 票。\n在运行阶段，奖励衰减为 $b_A(t) = \\max(0, 20 - \\delta t) = \\max(0, 20 - 2t)$。\n当 $20 - 2t = 0$ 时，奖励达到 $0$，这发生在 $t = 10$ 毫秒。由于运行阶段持续 $R=20$ 毫秒，奖励函数是分段的：\n$$b_A(t) = \\begin{cases} 20 - 2t  & \\text{if } 0 \\le t \\le 10 \\\\ 0  & \\text{if } 10  t \\le 20 \\end{cases}$$\n平均分数的积分必须相应地分开计算：\n$$\\bar{f}_{A, \\text{cap}} = \\frac{1}{25} \\left( \\int_0^{10} \\frac{10 + (20 - 2t)}{30 + (20 - 2t)} dt + \\int_{10}^{20} \\frac{10 + 0}{30 + 0} dt \\right)$$\n第一个积分是：\n$$\\int_0^{10} \\frac{30 - 2t}{50 - 2t} dt = \\int_0^{10} \\frac{15 - t}{25 - t} dt = \\int_0^{10} \\left(1 - \\frac{10}{25 - t}\\right) dt$$\n$$= \\left[ t + 10 \\ln(25 - t) \\right]_0^{10} = (10 + 10 \\ln(15)) - (0 + 10 \\ln(25))$$\n$$= 10 + 10 \\ln\\left(\\frac{15}{25}\\right) = 10 + 10 \\ln\\left(\\frac{3}{5}\\right) = 10 - 10 \\ln\\left(\\frac{5}{3}\\right)$$\n第二个积分是：\n$$\\int_{10}^{20} \\frac{10}{30} dt = \\frac{1}{3} \\int_{10}^{20} dt = \\frac{1}{3} [t]_{10}^{20} = \\frac{1}{3} (20 - 10) = \\frac{10}{3}$$\n在 $[0, 20]$ 上的总积分值是这两部分之和：$10 - 10 \\ln(5/3) + 10/3$。\n使用 $\\ln(5/3) \\approx 0.51083$ 和 $10/3 \\approx 3.33333$：\n$$\\text{积分值} \\approx 10 - 10(0.51083) + 3.33333 = 10 - 5.1083 + 3.33333 = 8.22503$$\n平均 CPU 分数为：\n$$\\bar{f}_{A, \\text{cap}} = \\frac{1}{25} \\left( 10 - 10 \\ln(5/3) + \\frac{10}{3} \\right) \\approx \\frac{8.22503}{25} \\approx 0.32900$$\n\n### 逐项分析选项\n- **A. 加上限前：$0.523$；加上限后：$0.329$。**\n  我对“无上限”情况的计算结果是 $\\approx 0.523$。我对“有上限”情况的计算结果是 $\\approx 0.329$。这个选项与两个结果都匹配。\n  **结论：正确。**\n\n- **B. 加上限前：$0.653$；加上限后：$0.333$。**\n  “加上限前”的值 $0.653$ 不正确。“加上限后”的值 $0.333$ (即 $1/3$) 是一个看似合理但不正确的近似值；实际值略低。\n  **结论：不正确。**\n\n- **C. 加上限前：$0.800$；加上限后：$0.600$。**\n  两个值都不正确。对于无上限情况，$0.800$ 的值将要求 A 的平均票数为 $80$，这与模型不符。对于有上限情况，$0.600$ 的值将要求平均票数为 $30$，同样不符。\n  **结论：不正确。**\n\n- **D. 加上限前：$0.475$；加上限后：$0.400$。**\n  “加上限前”的值 $0.475$ 不正确。此选项中的值与推导不符。\n  **结论：不正确。**\n\n两种情况的推导值分别约为 $0.523$ 和 $0.329$，这与选项 A 完全对应。", "answer": "$$\\boxed{A}$$", "id": "3673641"}, {"introduction": "现代操作系统中广泛使用的完全公平调度器（CFS）通过一个名为“最小粒度”的参数来平衡调度的公平性与系统开销。虽然这个参数可以减少过于频繁的任务切换，但在某些极端情况下，它可能导致低权重任务长时间无法获得CPU。本练习将引导你分析一个这样的病态场景，并从第一性原理出发，计算出低权重任务可能遭遇的最长等待时间。通过这个计算，你将体会到调度器参数调优的复杂性及其对系统公平性的深远影响。", "problem": "考虑一个运行着完全公平调度器（CFS）的单核系统。所有任务都持续可运行。调度器为每个任务维护一个虚拟运行时间 $v_i$，该时间的增长与任务的实际运行时间成正比，并按其权重的倒数进行缩放：当任务 $i$ 运行了 $\\Delta t$ 的墙上时钟时间后，其虚拟运行时间增加 $\\Delta v_i = \\Delta t \\cdot \\frac{1}{w_i}$。在每次调度决策时，会选择具有最小 $v_i$ 的任务来下一次运行。CFS 强制执行一个最小单次调度执行时间，称为最小粒度，使得任何被选中的任务在调度器考虑其他任务之前，至少运行 $g$ 的墙上时钟时间。\n\n构建一个包含 $M$ 个高权重任务和一个低权重任务的病态场景，在该场景下，由于最小粒度导致高权重任务之间的长时间轮转，低权重任务在一个短的测量窗口内得不到任何 CPU 时间。具体来说，假设有 $M = 251$ 个高权重任务，每个任务的权重为 $w_H = 10$，以及一个低权重任务，其权重为 $w_L = 1$。最小粒度为 $g = 4 \\text{ ms}$。假设在墙上时钟时间 $t = 0$ 时，所有任务具有相等的虚拟运行时间 $v_0$，并且通过决胜机制首先选择低权重任务运行最小粒度时间 $g$。此后，调度器根据所描述的 CFS 规则在高权重任务中进行选择。\n\n在这些条件下，从第一性原理出发推导低权重任务再次被调度所需的最坏情况下的墙上时钟时间。忽略上下文切换成本，并假设没有外部中断。最终答案以秒为单位表示，并将数值结果四舍五入到四位有效数字。", "solution": "问题要求计算在一个初始运行之后，低权重任务再次被调度所需的最坏情况时间。给定一个系统，包含 $M = 251$ 个高权重任务，每个任务的权重为 $w_H = 10$，以及一个低权重任务，其权重为 $w_L = 1$。最小粒度为 $g = 4 \\text{ ms}$。\n\n令 $v_L(t)$ 为低权重任务在墙上时钟时间 $t$ 时的虚拟运行时间，令 $v_{H_j}(t)$ 为第 $j$ 个高权重任务的虚拟运行时间，其中 $j \\in \\{1, 2, \\dots, M\\}$。\n\n在初始时间 $t=0$ 时，所有任务具有相等的虚拟运行时间，我们将其表示为 $v_0$。\n$$v_L(0) = v_{H_j}(0) = v_0 \\quad \\text{for all } j \\in \\{1, \\dots, M\\}$$\n\n根据问题描述，低权重任务 $L$ 通过决胜机制首先被选中，并运行最小粒度时间 $g$。这次运行的持续时间是 $\\Delta t = g$。这次运行结束时的墙上时钟时间是 $t_1 = g$。任务 $L$ 的虚拟运行时间根据给定规则增加：\n$$\\Delta v_L = \\Delta t \\cdot \\frac{1}{w_L} = g \\cdot \\frac{1}{w_L}$$\n因此，低权重任务在时间 $t_1 = g$ 时的虚拟运行时间为：\n$$v_L(g) = v_L(0) + \\frac{g}{w_L} = v_0 + \\frac{g}{w_L}$$\n在此期间，高权重任务的虚拟运行时间不变，因为它们没有运行。\n$$v_{H_j}(g) = v_{H_j}(0) = v_0$$\n\n在时间 $t=g$ 时，调度器必须选择下一个任务。具有最小虚拟运行时间的任务被选中。比较虚拟运行时间：\n$$v_L(g) = v_0 + \\frac{g}{w_L} = v_0 + \\frac{g}{1} = v_0 + g$$\n$$v_{H_j}(g) = v_0$$\n由于 $g  0$，我们有 $v_{H_j}(g)  v_L(g)$。因此，调度器将选择一个高权重任务。所有 $M$ 个高权重任务具有相同的最小虚拟运行时间，因此调度器将通过某个决胜规则选择其中一个，比如 $H_1$。\n\n任务 $H_1$ 至少运行最小粒度时间 $g$。让我们假设它恰好运行了 $g$ 的时长。运行后，其虚拟运行时间变为：\n$$v_{H_1} \\to v_0 + \\frac{g}{w_H}$$\n此时，其他 $M-1$ 个高权重任务的虚拟运行时间仍为 $v_0$，这是系统中当前的最小值。调度器因此会选择另一个高权重任务，比如 $H_2$。这个过程会重复。这会产生一种“护航”（convoy）或“队列”（platoon）效应，调度器以轮询方式循环遍历所有 $M$ 个高权重任务，每个任务都运行最小粒度时间 $g$。这构成了低权重任务的最坏情况，因为高权重任务集体独占了 CPU。\n\n遍历所有 $M$ 个高权重任务的一整轮需要总共 $M \\cdot g$ 的墙上时钟时间。经过这样一轮之后，每个高权重任务都已运行了 $g$ 的时长。它们的虚拟运行时间将全部相等：\n$$v_H(\\text{after 1 rot}) = v_0 + \\frac{g}{w_H}$$\n低权重任务的虚拟运行时间仍然是 $v_L = v_0 + g/w_L$。由于 $w_H > w_L$，我们有 $g/w_H  g/w_L$，这意味着 $v_H  v_L$。因此，调度器将开始另一轮高权重任务的轮转。\n\n这个循环将会继续。只要高权重任务的虚拟运行时间小于低权重任务的虚拟运行时间，它们就会继续被调度。设 $k$ 是高权重任务组执行的完整轮转次数。经过 $k$ 轮轮转后，每个高权重任务都已总共运行了 $k$ 次，每次时长为 $g$。它们的虚拟运行时间将是：\n$$v_{H}^{(k)} = v_0 + k \\cdot \\frac{g}{w_H}$$\n自初始运行以来，低权重任务的虚拟运行时间保持不变：\n$$v_L = v_0 + \\frac{g}{w_L}$$\n只有当低权重任务的虚拟运行时间不再大于系统中的最小虚拟运行时间时，它才会被再次考虑调度。这将在 $v_{H}^{(k)}$ “追上” $v_L$ 时发生。任务 $L$ 有资格被调度的条件是 $v_L \\le v_{H}^{(k)}$。我们需要找到满足这个不等式的最小整数 $k$：\n$$v_0 + \\frac{g}{w_L} \\le v_0 + k \\cdot \\frac{g}{w_H}$$\n从两边减去 $v_0$ 并除以正常数 $g$：\n$$\\frac{1}{w_L} \\le k \\cdot \\frac{1}{w_H}$$\n$$k \\ge \\frac{w_H}{w_L}$$\n代入给定的权重 $w_H=10$ 和 $w_L=1$：\n$$k \\ge \\frac{10}{1} \\implies k \\ge 10$$\n所需的最小整数轮转次数是 $k=10$。\n\n低权重任务再次被调度前的总墙上时钟时间 $T$ 是任务 $L$ 的初始运行时间与 $M$ 个高权重任务进行 $k$ 轮轮转的时间之和。\n$$T = (\\text{initial run of } L) + k \\times (\\text{time for one rotation of } H \\text{ tasks})$$\n一轮轮转的时间是 $M \\cdot g$。\n$$T = g + k \\cdot M \\cdot g = g(1 + kM)$$\n现在，我们代入数值：\n$g = 4 \\text{ ms} = 4 \\times 10^{-3} \\text{ s}$\n$M = 251$\n$k = 10$\n\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (1 + (10) \\cdot (251))$$\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (1 + 2510)$$\n$$T = (4 \\times 10^{-3} \\text{ s}) \\cdot (2511)$$\n$$T = 10044 \\times 10^{-3} \\text{ s}$$\n$$T = 10.044 \\text{ s}$$\n问题要求答案四舍五入到四位有效数字。数字 $10.044$ 四舍五入到四位有效数字是 $10.04$。", "answer": "$$\\boxed{10.04}$$", "id": "3673701"}]}