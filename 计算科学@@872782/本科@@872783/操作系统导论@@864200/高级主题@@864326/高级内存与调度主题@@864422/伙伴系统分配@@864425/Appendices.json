{"hands_on_practices": [{"introduction": "在理想情况下，伙伴系统管理着一块完整、连续的内存区域。然而，在真实的计算机系统中，部分物理地址空间可能已被硬件设备或固件预留，形成无法使用的“空洞”。本练习将模拟这种情况，要求你确定在存在这些预留区域的情况下，通过伙伴合并规则所能形成的最大连续空闲块是多大。通过解决这个问题，你将更深入地理解伙伴系统的合并条件以及对齐约束如何影响内存的碎片化。[@problem_id:3624835]", "problem": "一个单处理器操作系统在一个大小为 $2^{20}$ 字节的连续物理区域上使用二进制伙伴内存分配器。最小可分配块大小为 $2^{12}$ 字节。该分配器遵循标准的伙伴系统规则：内存被划分为块，其大小是最小块大小的2的幂次方倍，并且两个相同阶的空闲块当且仅当它们都为空闲且其合并后的起始地址与下一个更高阶块的大小（以字节为单位）对齐时才会合并。一个阶为 $k$ 的块大小为 $2^{12} \\cdot 2^{k}$ 字节，并且必须从一个 $2^{12} \\cdot 2^{k}$ 的倍数的地址开始。\n\n在所管理的区域内有几个设备保留的子区域。保留的子区域被指定为半开字节区间 $[s,e)$，任何与任一保留子区域相交的最小块都被视为不可用，不能被合并或分配。保留的子区域是：\n- $[1000, 6000)$\n- $[133632, 140120)$\n- $[260096, 264192)$\n- $[717800, 725800)$\n- $[918600, 920600)$\n\n假设在这些保留子区域之外，所有内存最初都是空闲的，并且合并在伙伴规则允许的任何地方都贪婪地进行，但仅限于完全可用的块之间。\n\n从上述定义出发，并且除了这些定义之外不假设伙伴系统的任何未经证实的属性，确定在所有与约束条件兼容的可能合并之后，区域中某处可以存在至少一个阶为 $k$ 的完全空闲块的最大可实现连续阶 $k$。请将您的最终答案报告为整数 $k$。", "solution": "该问题要求在一个由二进制伙伴系统管理的区域内，受限于几个保留子区域施加的约束，找到一个完全空闲的连续内存块的最大阶 $k$。\n\n首先，我们在一个离散的框架中建立系统的参数。总内存大小为 $M = 2^{20}$ 字节，最小可分配块大小为 $S_{\\min} = 2^{12}$ 字节，这对应于一个阶为 $k=0$ 的块。我们可以将整个内存区域建模为一个由 $N$ 个大小为 $S_{\\min}$ 的“基本块”组成的连续数组。此类块的数量为：\n$$N = \\frac{M}{S_{\\min}} = \\frac{2^{20} \\text{ 字节}}{2^{12} \\text{ 字节}} = 2^{8} = 256$$\n这些基本块可以从 $i=0$ 到 $i=255$ 进行索引。索引为 $i$ 的基本块的字节地址范围是 $[i \\cdot S_{\\min}, (i+1) \\cdot S_{\\min})$，计算结果为 $[i \\cdot 4096, (i+1) \\cdot 4096)$。\n\n接下来，我们必须确定哪些基本块因设备保留子区域而变得不可用。如果一个基本块的地址范围与任何指定的保留区域相交，则该基本块是不可用的。对于一个由半开区间 $[s, e)$ 给出的保留区域，如果基本块 $i$ 对应的区间 $[i \\cdot 4096, (i+1) \\cdot 4096)$ 与 $[s, e)$ 有非空交集，那么该基本块就受到影响。受 $[s, e)$ 影响的基本块索引范围是从 $i_{start} = \\lfloor s / 4096 \\rfloor$ 到 $i_{end} = \\lfloor (e-1) / 4096 \\rfloor$。我们将此计算应用于每个保留子区域：\n1.  对于区域 $[1000, 6000)$：\n    $i_{start} = \\lfloor 1000 / 4096 \\rfloor = 0$。\n    $i_{end} = \\lfloor (6000 - 1) / 4096 \\rfloor = \\lfloor 5999 / 4096 \\rfloor = 1$。\n    受影响的基本块是索引为 $0$ 和 $1$ 的块。\n\n2.  对于区域 $[133632, 140120)$：\n    $i_{start} = \\lfloor 133632 / 4096 \\rfloor = 32$。\n    $i_{end} = \\lfloor (140120 - 1) / 4096 \\rfloor = \\lfloor 140119 / 4096 \\rfloor = 34$。\n    受影响的基本块是索引为 $32, 33, 34$ 的块。\n\n3.  对于区域 $[260096, 264192)$：\n    $i_{start} = \\lfloor 260096 / 4096 \\rfloor = 63$。\n    $i_{end} = \\lfloor (264192 - 1) / 4096 \\rfloor = \\lfloor 264191 / 4096 \\rfloor = 64$。\n    受影响的基本块是索引为 $63, 64$ 的块。\n\n4.  对于区域 $[717800, 725800)$：\n    $i_{start} = \\lfloor 717800 / 4096 \\rfloor = 175$。\n    $i_{end} = \\lfloor (725800 - 1) / 4096 \\rfloor = \\lfloor 725799 / 4096 \\rfloor = 177$。\n    受影响的基本块是索引为 $175, 176, 177$ 的块。\n\n5.  对于区域 $[918600, 920600)$：\n    $i_{start} = \\lfloor 918600 / 4096 \\rfloor = 224$。\n    $i_{end} = \\lfloor (920600 - 1) / 4096 \\rfloor = \\lfloor 920599 / 4096 \\rfloor = 224$。\n    受影响的基本块是索引为 $224$ 的块。\n\n通过取这些集合的并集，我们汇编出不可用基本块的完整索引集，记为 $U$：\n$$U = \\{0, 1, 32, 33, 34, 63, 64, 175, 176, 177, 224\\}$$\n\n一个阶为 $k$ 的伙伴块大小为 $S_k = 2^{12} \\cdot 2^k$ 字节，对应于 $2^k$ 个基本块。对齐要求规定起始地址必须是 $S_k$ 的倍数。在我们的离散框架中，这意味着起始基本块的索引（比如 $j$）必须是 $2^k$ 的倍数。这样的一个块覆盖了基本块索引的范围 $[j, j + 2^k - 1]$。为了使这个块“完全空闲”，这整个索引范围必须与不可用索引集 $U$ 不相交。\n\n我们正在寻找最大的整数 $k$，使得存在一个整数 $m \\geq 0$，满足索引区间 $[m \\cdot 2^k, (m+1) \\cdot 2^k - 1]$ 与 $U$ 没有交集。可能的最大阶是 $k=8$，它将覆盖整个区域（索引 $[0, 255]$）。我们按降序测试 $k$。\n\n测试 $k=6$：\n一个阶为 $6$ 的块由 $2^6 = 64$ 个基本块组成。可能的起始索引是 $64$ 的倍数，即 $0, 64, 128, 192$。我们检查相应的区间：\n-   位于索引 $0$ 的块：对应于索引范围 $[0, 63]$。该范围与 $U$ 在 $\\{0, 1, 32, 33, 34, 63\\}$ 处相交。此块不是空闲的。\n-   位于索引 $64$ 的块：对应于索引范围 $[64, 127]$。该范围与 $U$ 在 $\\{64\\}$ 处相交。此块不是空闲的。\n-   位于索引 $128$ 的块：对应于索引范围 $[128, 191]$。该范围与 $U$ 在 $\\{175, 176, 177\\}$ 处相交。此块不是空闲的。\n-   位于索引 $192$ 的块：对应于索引范围 $[192, 255]$。该范围与 $U$ 在 $\\{224\\}$ 处相交。此块不是空闲的。\n由于无法形成阶为 $6$ 的完全空闲块，因此最大可实现阶必须小于 $6$。\n\n测试 $k=5$：\n一个阶为 $5$ 的块由 $2^5 = 32$ 个基本块组成。可能的起始索引是 $32$ 的倍数：$0, 32, 64, 96, 128, 160, 192, 224$。我们寻找一个与 $U$ 不相交的区间。\n-   索引范围 $[0, 31]$：包含 $\\{0, 1\\} \\subset U$。不是空闲的。\n-   索引范围 $[32, 63]$：包含 $\\{32, 33, 34, 63\\} \\subset U$。不是空闲的。\n-   索引范围 $[64, 95]$：包含 $\\{64\\} \\subset U$。不是空闲的。\n-   索引范围 $[96, 127]$：我们检查其与 $U = \\{0, 1, 32, 33, 34, 63, 64, 175, 176, 177, 224\\}$ 是否有交集。$U$ 中的所有元素都不在整数范围 $[96, 127]$ 内。因此，这个块是完全空闲的。\n\n我们成功地找到了一个阶为 $k=5$ 的完全空闲块（具体来说，是对应于基本块索引 $[96, 127]$ 的那个）。因为我们已经证明了无法形成阶为 $k=6$ 的完全空闲块，所以最大可实现的连续阶为 $5$。", "answer": "$$\\boxed{5}$$", "id": "3624835"}, {"introduction": "内存分配不仅仅是满足请求的大小，还需要考虑地址对齐。某些硬件设备，如执行直接内存访问（DMA）的设备，对内存块的起始地址有严格的对齐要求。本练习探讨了当伙伴系统分配器必须满足这种严格的对齐约束时会发生什么。你将计算一个看似简单的内存请求在这种情况下所导致的内部碎片率，从而体会到外部硬件约束如何显著影响内存利用效率。[@problem_id:3624829]", "problem": "一个基于伙伴系统的连续区域分配器被用于管理随机存取存储器 (RAM)。伙伴系统将空闲内存组织成块，其大小是基本单位大小的2的整数次幂倍。设基本单位为一页，大小为 $2^{12}$ 字节，因此一个k阶块的大小为 $2^{k} \\cdot 2^{12}$ 字节，并且根据其构造，每个k阶块的起始地址都与 $2^{k} \\cdot 2^{12}$ 字节对齐。当一个大小为 $s$ 的请求到达时，分配器会选择满足 $2^{k} \\cdot 2^{12} \\ge s$ 的最小阶数 $k$，并返回该阶的一个块，由此产生的内部碎片等于分配块大小与请求大小之差。\n\n假设一个执行直接内存访问 (DMA) 的设备施加了严格的对齐要求：返回给请求者的每个分配块都必须始于一个与 $2^{20}$ 字节对齐的地址。分配器通过选择一个其块大小能保证这种对齐的阶数来强制执行此要求。\n\n考虑一个大小为 $64$ 千字节的请求。使用 $1$ 千字节 = $1024$ 字节。根据上述定义和伙伴块的对齐属性，确定在没有对齐约束的情况下分配器会选择的最小阶数，以及在 $2^{20}$ 字节对齐约束下它必须选择的最小阶数。然后，使用这些结果，计算定义如下的内部碎片率\n$$\\frac{\\text{allocated size} - \\text{requested size}}{\\text{allocated size}}.$$\n仅报告此内部碎片率作为最终答案。最终答案以小数形式表示，并四舍五入到四位有效数字。最终答案中不应包含任何单位。", "solution": "本题要求我们确定在伙伴系统分配器和硬件设备施加的特定约束下，一次内存分配请求的内部碎片率。我们首先将给定的信息形式化，然后进行分步计算。\n\n首先，我们确定系统的基本参数。\n内存的基本单位是一页，大小为 $2^{12}$ 字节。\n一个k阶内存块的大小，我们记为 $B_k$，由下式给出：\n$$B_k = 2^k \\cdot 2^{12} = 2^{k+12} \\text{ bytes}$$\n根据构造，一个k阶的块保证起始于一个内存地址，该地址是其自身大小 $B_k$ 的倍数。\n\n请求的内存区域大小为 $s = 64$ 千字节。我们使用给定的转换因子 $1$ 千字节 = $1024$ 字节，将此大小转换为字节。\n$$s = 64 \\times 1024 \\text{ bytes} = 2^6 \\times 2^{10} \\text{ bytes} = 2^{16} \\text{ bytes}$$\n\n题目要求考虑两种不同的分配情况，但最终答案仅取决于有对齐约束的情况。为了完整性，在进行最终计算之前，我们将对两种情况都进行分析。\n\n1.  **无特殊对齐约束的分配：**\n    分配器必须找到最小的阶数 $k$，使得块大小 $B_k$ 大于或等于请求的大小 $s$。\n    $$B_k \\ge s$$\n    $$2^{k+12} \\ge 2^{16}$$\n    对两边取以2为底的对数，我们得到：\n    $$k+12 \\ge 16$$\n    $$k \\ge 4$$\n    满足此条件的最小整数 $k$ 是 $k=4$。如果没有特殊约束，分配器会选择一个4阶的块。\n\n2.  **有特殊对齐约束的分配：**\n    直接内存访问 (DMA) 设备施加了更严格的要求：分配的块必须始于一个与 $2^{20}$ 字节对齐的地址。这意味着块的起始地址必须是 $2^{20}$ 的倍数。\n    伙伴系统保证一个k阶的块起始于一个地址，该地址是其大小 $B_k = 2^{k+12}$ 的倍数。\n    为确保分配器可能返回的*任何*k阶块都满足DMA对齐要求，该块的自然对齐必须至少与所要求的对齐一样严格。因此，块大小 $B_k$ 必须是所需对齐边界 $2^{20}$ 字节的倍数。这意味着：\n    $$B_k \\ge 2^{20}$$\n    $$2^{k+12} \\ge 2^{20}$$\n    再次，取以2为底的对数：\n    $$k+12 \\ge 20$$\n    $$k \\ge 8$$\n    保证 $2^{20}$ 字节对齐的最小整数阶数 $k$ 是 $k=8$。\n\n分配器必须同时满足大小要求（$s = 2^{16}$ 字节）和对齐要求（$2^{20}$ 字节边界）。\n设 $k_{final}$ 是分配器选择的阶数。\n根据大小要求，我们需要 $B_{k_{final}} \\ge 2^{16}$，这意味着 $k_{final} \\ge 4$。\n根据对齐要求，我们需要 $k_{final} \\ge 8$。\n为同时满足这两个条件，分配器必须选择满足 $k_{final} \\ge 4$ 和 $k_{final} \\ge 8$ 的最小整数阶数 $k_{final}$。这个最小整数是 $k_{final} = 8$。\n\n现在，我们可以计算分配块的大小。\n分配大小 $A$ 对应于阶数 $k_{final} = 8$ 的块大小：\n$$A = B_8 = 2^{8+12} = 2^{20} \\text{ bytes}$$\n\n请求的大小是 $s = 2^{16}$ 字节。\n内部碎片是分配大小与请求大小之差：\n$$\\text{Internal Fragmentation} = A - s = 2^{20} - 2^{16} \\text{ bytes}$$\n\n题目要求计算内部碎片率，其定义为：\n$$\\text{Ratio} = \\frac{\\text{allocated size} - \\text{requested size}}{\\text{allocated size}} = \\frac{A-s}{A}$$\n代入 $A$ 和 $s$ 的值：\n$$\\text{Ratio} = \\frac{2^{20} - 2^{16}}{2^{20}} = 1 - \\frac{2^{16}}{2^{20}} = 1 - 2^{16-20} = 1 - 2^{-4}$$\n$$2^{-4} = \\frac{1}{2^4} = \\frac{1}{16} = 0.0625$$\n$$\\text{Ratio} = 1 - 0.0625 = 0.9375$$\n\n题目要求答案以小数形式表示，并四舍五入到四位有效数字。计算出的值 $0.9375$ 已经恰好有四位有效数字（$9$、$3$、$7$、$5$）。因此，不需要进一步的四舍五入。", "answer": "$$\\boxed{0.9375}$$", "id": "3624829"}, {"introduction": "伙伴系统的一个潜在缺点是外部碎片问题，即随着时间的推移，内存空间可能被分割成许多不相邻的小空闲块，导致即使总空闲内存充足，也无法满足一个较大的内存请求。本练习设计了一个具体的工作负载场景来揭示这一现象。你需要确定最少需要多少次小内存分配，才能导致一个后续的大内存请求失败，从而亲身体验外部碎片是如何在伙伴系统中产生的，并思考可能的缓解策略。[@problem_id:3624862]", "problem": "一个内存分配器使用伙伴系统进行主存管理。管理的总内存为 $1\\,\\text{MiB}$，定义为 $2^{20}$ 字节。可分配的最小块大小为 $1\\,\\text{KiB}$，定义为 $2^{10}$ 字节。内存块按阶管理：对于整数 $i \\geq 0$，一个 $i$ 阶块的大小为 $2^{10+i}$ 字节。初始时，整个内存是一个最大阶的空闲块。\n\n分配器策略如下：为满足大小为 $s$ 的请求，它会选择满足 $2^{10+i} \\geq s$ 的最小阶 $i$，并查找是否存在一个 $i$ 阶的空闲块；如果不存在，它会递归地分裂可用的最小更高阶的空闲块（在该阶选择地址最低的空闲块），直到获得一个 $i$ 阶块。在各次分配之间不发生释放操作。\n\n考虑以下工作负载：\n- 首先，执行 $n$ 次连续的小块分配，每次分配的大小恰好为 $1\\,\\text{KiB}$。\n- 在这 $n$ 次分配之后，立即发出一个大小为 $256\\,\\text{KiB}$ 的大块分配请求。\n\n仅使用伙伴系统的核心定义和所述策略，确定使得 $256\\,\\text{KiB}$ 的大块请求失败的最小整数 $n$，即使此时剩余的总空闲内存可能超过 $256\\,\\text{KiB}$。您的推理必须明确说明先前的分裂操作如何阻止为大块请求形成合适的伙伴块。然后，简要提出一个缓解策略参数（例如，分裂预留规则），该参数可以在不改变总内存大小的情况下避免此失败；您无需量化其效果。\n\n您最终报告的答案必须是单个整数 $n$，不带单位。无需四舍五入。", "solution": "解答过程是通过确定大块分配请求在何种条件下失败，并找出需要多少次小块分配才能创造这些条件。\n\n1.  **分析分配请求**\n    -   小块分配的大小为 $s_{small} = 1\\,\\text{KiB} = 2^{10}$ 字节。分配器必须找到一个阶为 $i$ 的块，其中 $S_i = 2^{10+i} \\ge 2^{10}$。满足条件的最小阶为 $i=0$。因此，每次小块分配消耗一个 $0$ 阶块。\n    -   大块分配的大小为 $s_{large} = 256\\,\\text{KiB} = 256 \\times 2^{10} = 2^8 \\times 2^{10} = 2^{18}$ 字节。分配器必须找到一个阶为 $j$ 的块，其中 $S_j = 2^{10+j} \\ge 2^{18}$。这意味着 $10+j \\ge 18$，所以最小整数阶为 $j=8$。大块请求需要一个 $8$ 阶块。\n\n2.  **分析内存结构**\n    -   总内存是一个 $10$ 阶的块，大小为 $S_{10} = 2^{20}$ 字节。\n    -   大块请求需要一个 $8$ 阶块，大小为 $S_8 = 2^{18}$ 字节。\n    -   总内存空间可以概念上划分为若干个不重叠的 $8$ 阶块。这样的块的数量是 $N_8 = \\frac{S_{10}}{S_8} = \\frac{2^{20}}{2^{18}} = 2^2 = 4$。\n    -   这四个 $8$ 阶块，我们称之为 $Q_0, Q_1, Q_2, Q_3$，占据了整个地址空间。\n        -   $Q_0$：地址范围 $[0, 2^{18}-1]$\n        -   $Q_1$：地址范围 $[2^{18}, 2 \\cdot 2^{18}-1]$\n        -   $Q_2$：地址范围 $[2 \\cdot 2^{18}, 3 \\cdot 2^{18}-1]$\n        -   $Q_3$：地址范围 $[3 \\cdot 2^{18}, 4 \\cdot 2^{18}-1]$\n    -   从一个 $8$ 阶块可以创建出的 $0$ 阶块的数量是 $k = \\frac{S_8}{S_0} = \\frac{2^{18}}{2^{10}} = 2^8 = 256$。\n\n3.  **追踪分配过程**\n    -   分配策略是使用“地址最低的空闲块”。这个策略有一个关键的后果：分配器将从最低地址开始顺序地消耗内存来满足请求。它会完全耗尽 $Q_0$ 中可分配的 $0$ 阶块，然后才触及 $Q_1$，依此类推。\n    -   对 $8$ 阶块的请求将会失败，前提是没有任何 $8$ 阶的空闲块，也没有任何更高阶（$9$ 阶或 $10$ 阶）的空闲块可以分裂来创建一个。只有当所有四个原始的 $8$ 阶块（$Q_0, Q_1, Q_2, Q_3$）都已被“破坏”时，才会达到这种状态，即每个块都为了满足至少一次小块分配请求而被分裂。\n\n4.  **确定最小的 `n`**\n    -   要破坏 $Q_0$，一次小块分配（$n=1$）就足够了。它被放置在地址 $0$。然而，此时系统已经创建了许多阶的空闲块，包括一个 $8$ 阶块（$Q_0$ 的伙伴，即 $Q_1$）和一个 $9$ 阶块（$Q_0$ 和 $Q_1$ 的父块）。大块请求会成功。\n    -   要破坏 $Q_1$，我们必须首先耗尽 $Q_0$ 中的所有 $256$ 个 $0$ 阶块。这需要 $n=256$ 次分配。第 $(256+1)$ 次分配，即 $n=257$ 时，将是第一次从 $Q_1$ 中分配，从而分裂它。\n    -   要破坏 $Q_2$，我们必须首先耗尽 $Q_0$ 和 $Q_1$ 中的所有 $0$ 阶块。这需要 $n = 256 + 256 = 512$ 次分配。第 $(512+1)$ 次分配，即 $n=513$ 时，将分裂 $Q_2$。\n    -   要破坏 $Q_3$，我们必须首先耗尽 $Q_0$、$Q_1$ 和 $Q_2$ 中的所有 $0$ 阶块。这需要 $n = 256 + 256 + 256 = 3 \\times 256 = 768$ 次分配。\n    -   让我们分析 $n=768$ 次小块分配后的状态。块 $Q_0, Q_1, Q_2$ 完全被已分配的 $0$ 阶块填满。块 $Q_3$ 仍然是一个原始的、连续的、$8$ 阶空闲块。随后对 $8$ 阶块的请求将立即由 $Q_3$ 满足。因此，当 $n=768$ 时，大块请求成功。\n    -   下一次小块分配，即 $n=769$ 时，必须从 $Q_3$ 中分配。为此，分配器必须分裂 $8$ 阶块 $Q_3$。这次分裂后，所有四个原始的 $8$ 阶块都已被破坏。不存在任何 $8$ 阶的空闲块。此外，它们的父块（$9$ 阶）和祖父块（$10$ 阶）也已被分裂。\n    -   因此，在 $n=769$ 次小块分配之后，随后对 $8$ 阶块的请求将失败，因为任何空闲列表中都没有 $8$ 阶或更高阶的块可用。这是保证失败的最小 $n$ 值。\n\n5.  **分析空闲内存**\n    -   当 $n=769$ 时，已分配的总内存为 $769 \\times S_0 = 769 \\times 2^{10}$ 字节。\n    -   总内存为 $S_{10} = 2^{20} = 1024 \\times 2^{10}$ 字节。\n    -   总空闲内存为 $(1024 - 769) \\times 2^{10} = 255 \\times 2^{10}$ 字节，即 $255\\,\\text{KiB}$。\n    -   大块请求的大小为 $256\\,\\text{KiB}$。由于 $255\\,\\text{KiB}  256\\,\\text{KiB}$，请求也会因为总内存不足而失败。在这个特定场景中，由碎片化导致的结构性失败与容量失败同时发生。\n\n6.  **提出的缓解策略**\n    -   问题之所以出现，是因为小块分配被允许任意地碎片化大块。一个缓解策略是为大块请求预留大块。\n    -   一个合适的策略参数可以是**分裂预留阶**，记作 $i_{res}$。\n    -   修改后的策略将是：“一个阶为 $j \\geq i_{res}$ 的空闲块只能为了满足一个阶为 $k \\geq i_{res}-1$（或某个类似的阈值）的块请求而被分裂。”\n    -   对于这个问题，设置 $i_{res}=8$ 将意味着 $8$ 阶及更高阶（即 $8, 9, 10$ 阶）的块不能为了满足一个 $0$ 阶块的请求而被分裂。这将为大块请求保留大块库存，防止这种类型的碎片化导致的失败。小块分配将被限制在内存的一部分区域，而另一部分区域将为大块分配保留。", "answer": "$$\n\\boxed{769}\n$$", "id": "3624862"}]}