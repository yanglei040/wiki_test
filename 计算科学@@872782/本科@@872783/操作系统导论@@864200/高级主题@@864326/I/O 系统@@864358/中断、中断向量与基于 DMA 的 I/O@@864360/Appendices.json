{"hands_on_practices": [{"introduction": "在现实世界中，尤其是在高速网络环境下，原始中断率很容易使CPU不堪重负。本练习深入探讨了中断调节（interrupt moderation）这一关键优化技术，它用于平衡CPU效率和响应延迟。您将使用泊松过程的原理来为一个中断合并策略确定最佳参数，以确保在最小化CPU开销的同时满足延迟保证 [@problem_id:3650453]。", "problem": "一个网络接口控制器（NIC）使用直接内存访问（DMA）将接收到的数据包放入主内存的环形缓冲区中，在中断之间无需中央处理器（CPU）的干预。该NIC采用中断合并技术，并实施一种双参数合并策略：从每次中断开始，它会累积接收到的数据包，并在以下两个条件中较早发生者触发下一次中断：(i) 自上次中断以来第 $N$ 个数据包的到达，或 (ii) 自上次中断以来计时器在 $T$ 微秒后到期。假设每次中断的CPU成本是固定的，与 $N$ 和 $T$ 无关，并且数据包处理本身所占用的CPU资源与合并策略无关。\n\n假设数据包的到达过程是一个齐次泊松过程，其速率为每秒 $\\lambda$ 次到达。设计目标是最小化用于中断处理的CPU时间（等效于最小化每秒中断次数），同时确保每个数据包的中断触发延迟的第 $99$ 百分位数最多为界限 $L_{p99}$。此处，每个数据包的中断触发延迟定义为从数据包到达时刻到使其对操作系统可见的中断被触发的这段时间。\n\n仅使用关于泊松过程、独立到达和分位数基本定义的基本事实，从第一性原理出发进行推理。具体而言，您的推理应从以下事实开始：(a) 在任何长度为 $t$ 的时间间隔内，到达次数服从均值为 $\\lambda t$ 的泊松分布；(b) 对于泊松过程，在固定长度的时间间隔内的到达时间是均匀分布的。\n\n给定参数 $\\lambda = 1.0 \\times 10^{6}\\ \\mathrm{s}^{-1}$ 和 $L_{p99} = 100\\ \\mu\\mathrm{s}$，选择 $(N,T)$ 以在满足第 $99$ 百分位数延迟约束的条件下，最小化每秒中断次数。然后：\n\n- 将您选择的 $T^{\\star}$ 以微秒表示，并四舍五入至四位有效数字。\n- 选择最小的整数 $N^{\\star}$，使得在所述到达模型下，该选择能够以至少 $0.99$ 的概率保持中断最小化行为。\n- 以行向量 $\\bigl[T^{\\star}, N^{\\star}\\bigr]$ 的形式提供您的最终答案。\n\n在最终的方框答案中不要包含任何单位。按要求以微秒表示 $T^{\\star}$；$N^{\\star}$ 是一个无量纲的整数。", "solution": "问题要求我们确定中断合并策略的最优参数 $(N, T)$，以便在满足每个数据包延迟约束的条件下，最小化用于中断处理的CPU时间。最小化中断处理所花费的CPU时间等同于最小化中断率 $R_{int}$。中断率是平均中断间隔 $E[I]$ 的倒数。因此，目标是最大化 $E[I]$。\n\n连续中断之间的时间 $I$ 由策略决定：中断在 (i) 第 $N$ 个数据包到达，或 (ii) 计时器 $T$ 到期中较早发生者触发。设 $A_N$ 为自上次中断（假设上次中断在时间 0）以来的第 $N$ 个数据包的到达时间。那么，到下一次中断的时间由随机变量 $I = \\min(A_N, T)$ 给出。平均中断间隔为 $E[I] = E[\\min(A_N, T)]$。\n\n函数 $E[\\min(A_N, T)]$ 关于 $N$ 和 $T$ 都是单调递增的。为了最大化 $E[I]$，我们应该选择尽可能大的 $N$ 和 $T$，仅受延迟要求的约束。\n\n问题要求每个数据包的中断触发延迟 $L$ 的第 $99$ 百分位数最多为 $L_{p99}$。这表示为 $Q_L(0.99) \\le L_{p99}$，其中 $Q_L$ 是延迟分布的分位数函数。\n\n问题的结构提示了一个两步法：首先，确定在延迟约束下最大化 $E[I]$ 的理想策略。这个理想化过程将确定 $T^{\\star}$。其次，确定一个实际的 $N^{\\star}$ 值，使得真实策略能以高概率近似理想策略。\n\n当 $N \\to \\infty$ 时，$E[I]$ 达到绝对最大值。在这种理想情况下，数据包计数触发器永远不会触发，中断完全由计时器到期引起。中断之间的时间变为一个固定值 $I = T$。这就是问题中提到的“中断最小化行为”。\n\n现在我们分析这种理想化的、仅有计时器的策略的延迟。中断间隔的长度固定为 $T$。问题陈述了一个基本事实，即对于泊松过程，在固定长度的时间间隔内，数据包的到达时间服从均匀分布。设中断间隔为 $[0, T]$。一个数据包的到达时间 $t_{arr}$ 是一个随机变量，其分布为 $t_{arr} \\sim U(0, T)$。该数据包的延迟是其到达时刻到时间 $T$ 发生中断的时间，即 $L = T - t_{arr}$。由于 $t_{arr}$ 在 $[0, T]$上均匀分布，延迟 $L$ 也在 $[0, T]$上均匀分布。\n\n这个延迟分布 $L \\sim U(0, T)$ 的累积分布函数（CDF）是 $F_L(\\ell) = P(L \\le \\ell) = \\frac{\\ell}{T}$，其中 $\\ell \\in [0, T]$。延迟的第 $99$ 百分位数，我们记为 $q_{0.99}$，是使 $F_L(\\ell) = 0.99$ 的 $\\ell$ 值。\n$$ \\frac{q_{0.99}}{T} = 0.99 \\implies q_{0.99} = 0.99 T $$\n延迟约束为 $q_{0.99} \\le L_{p99}$，这转化为 $0.99 T \\le L_{p99}$。这意味着 $T \\le \\frac{L_{p99}}{0.99}$。\n为了在这种理想情况下最大化平均中断间隔 $E[I] = T$，我们必须选择 $T$ 的最大可能值。因此，最优的计时器设置为：\n$$ T^{\\star} = \\frac{L_{p99}}{0.99} $$\n给定参数 $L_{p99} = 100\\ \\mu\\mathrm{s}$，我们可以计算 $T^{\\star}$：\n$$ T^{\\star} = \\frac{100\\ \\mu\\mathrm{s}}{0.99} \\approx 101.0101... \\ \\mu\\mathrm{s} $$\n问题要求这个值以微秒为单位，并四舍五入到四位有效数字，得到 $T^{\\star} = 101.0\\ \\mu\\mathrm{s}$。\n\n接下来，我们必须选择最小的整数 $N^{\\star}$，以“至少 $0.99$ 的概率保持该选择的中断最小化行为”。这意味着中断应该由计时器（理想行为）触发的概率至少为 $0.99$。当中断由计时器 $T^{\\star}$ 触发时，当且仅当第 $N^{\\star}$ 个数据包在时间 $T^{\\star}$ 之前尚未到达。这个事件是 $A_{N^{\\star}} > T^{\\star}$。\n我们要求 $P(A_{N^{\\star}} > T^{\\star}) \\ge 0.99$。\n\n事件 $A_{N^{\\star}} > T^{\\star}$ 等价于在时间间隔 $[0, T^{\\star}]$ 内数据包到达的数量（我们记为 $K(T^{\\star})$）小于 $N^{\\star}$。所以，条件是 $P(K(T^{\\star})  N^{\\star}) \\ge 0.99$，或者 $P(K(T^{\\star}) \\le N^{\\star}-1) \\ge 0.99$。\n\n根据问题的假设，长度为 $t$ 的时间间隔内的到达次数服从均值为 $\\lambda t$ 的泊松分布。因此，$K(T^{\\star})$ 是一个泊松随机变量，其均值为 $\\mu = \\lambda T^{\\star}$。为了确保准确性，我们必须使用未四舍五入的 $T^{\\star}$ 值。\n$$ \\mu = \\lambda T^{\\star} = (1.0 \\times 10^{6}\\ \\mathrm{s}^{-1}) \\times \\left(\\frac{100 \\times 10^{-6}\\ \\mathrm{s}}{0.99}\\right) = \\frac{100}{0.99} \\approx 101.01 $$\n我们需要找到最小的整数 $N^{\\star}$，使得均值为 $\\mu = 100/0.99$ 的泊松分布在 $N^{\\star}-1$ 处的累积分布函数（CDF）值至少为 $0.99$。\n对于较大的均值 $\\mu$，泊松分布可以近似为均值为 $\\mu$、方差为 $\\mu$ 的正态分布。设 $K \\sim \\text{Poisson}(\\mu)$。使用带连续性校正的正态近似，我们有：\n$$ P(K \\le m) \\approx \\Phi\\left(\\frac{m + 0.5 - \\mu}{\\sqrt{\\mu}}\\right) $$\n其中 $\\Phi$ 是标准正态分布的累积分布函数。我们设 $m = N^{\\star}-1$，并要求该概率至少为 $0.99$：\n$$ \\Phi\\left(\\frac{(N^{\\star}-1) + 0.5 - \\mu}{\\sqrt{\\mu}}\\right) \\ge 0.99 $$\n$$ \\frac{N^{\\star} - 0.5 - \\mu}{\\sqrt{\\mu}} \\ge z_{0.99} $$\n其中 $z_{0.99}$ 是标准正态分布的第 $99$ 百分位数。其值为 $z_{0.99} \\approx 2.3263$。\n现在我们求解 $N^{\\star}$：\n$$ N^{\\star} \\ge \\mu + 0.5 + z_{0.99} \\sqrt{\\mu} $$\n代入 $\\mu = 100/0.99$ 的值：\n$$ N^{\\star} \\ge \\frac{100}{0.99} + 0.5 + 2.3263 \\sqrt{\\frac{100}{0.99}} $$\n$$ N^{\\star} \\ge 101.0101... + 0.5 + 2.3263 \\times \\frac{10}{\\sqrt{0.99}} $$\n$$ N^{\\star} \\ge 101.5101... + 2.3263 \\times 10.05037... $$\n$$ N^{\\star} \\ge 101.5101... + 23.3795... $$\n$$ N^{\\star} \\ge 124.8896... $$\n由于 $N^{\\star}$ 必须是整数，满足此不等式的最小整数是 $N^{\\star} = 125$。\n\n所选参数为 $T^{\\star} = 101.0\\ \\mu\\mathrm{s}$ 和 $N^{\\star} = 125$。最终答案应表示为行向量 $\\bigl[T^{\\star}, N^{\\star}\\bigr]$。", "answer": "$$ \\boxed{\\begin{pmatrix} 101.0  125 \\end{pmatrix}} $$", "id": "3650453"}, {"introduction": "掌握复杂系统的最有效方法是亲手构建它们。这最后一个实践练习将挑战您编写一个程序，模拟一个完整的、带有一个微小硬件缺陷的中断子系统。您的任务是实现一个操作系统层，它不仅能检测到这个硬件错误，还能应用纯软件的解决方法（使用优先级队列）来恢复正确、稳健的行为，从而展示弹性系统设计的核心原则 [@problem_id:3650411]。", "problem": "您必须编写一个完整、可运行的程序，该程序模拟一个带有缺陷优先级编码器的可编程中断控制器，为一个基本的操作系统中断子系统和中断向量表建模，并演示一种纯软件解决方案，即使在存在硬件缺陷的情况下也能恢复正确的优先级行为。上下文涉及中断、中断向量和基于直接内存访问（DMA）的输入/输出。\n\n假设以下基本定义和事实为基础，这些是标准的，不包含任何需要推导的目标结果：\n- 中断是一个异步事件，请求中央处理器暂时暂停当前任务并运行一个特定的处理程序。每个中断线都被分配一个数值优先级；较小的数值表示较高的优先级。如果多个中断处于待处理状态，一个正确的控制器必须选择具有最小数值级别的待处理中断。\n- 中断向量是一个由中断标识符索引的表，该表给出处理程序的入口点；为了本次模拟的目的，每个处理程序可以被建模为一次标识符更新或一个整数计数器的增量。\n- 直接内存访问（DMA）引擎自主执行内存传输，并通过中断信号通知完成。中央处理器不轮询设备；相反，它通过中断被通知，并分派相应的处理程序。\n- 一个正确的优先级编码器是中断控制器内部的一个实现细节，它将每个级别映射到一个可比较的键，以便首先选择数值优先级较低的级别。\n\n在模拟的硬件中，控制器的优先级编码存在缺陷：给定级别在 $\\{0,1,2,3,4,5,6,7\\}$ 中，位宽固定为 $W=3$ 位，控制器不是直接比较数值级别 $p$，而是比较 $p$ 的 $W$ 位编码的按位翻转。定义按位翻转函数为 $r_W(p)$，它将 $p$ 的 $W$ 位二进制展开映射到其比特位反序的整数。例如，当 $W=3$ 时：$r_3(0)=0$，$r_3(1)=4$，$r_3(2)=2$，$r_3(3)=6$，$r_3(4)=1$，$r_3(5)=5$，$r_3(6)=3$，$r_3(7)=7$。有缺陷的控制器选择一个待处理中断 $p^\\star$，它最小化 $r_W(p)$ 而不是最小化 $p$。\n\n您的任务是实现：\n- 一个中断控制器模型，它可以在两种模式下运行：正确模式（选择具有最小 $p$ 的待处理中断）和缺陷模式（选择具有最小 $r_W(p)$ 的待处理中断）。将待处理中断视为集合 $\\{0,1,2,3,4,5,6,7\\}$ 上的一个位掩码，每次选择从掩码中精确移除一个待处理中断。\n- 一个操作系统（OS）层，它：\n  1. 通过执行优先级排序的成对测试来检测缺陷：对于所有有序对 $(i,j)$，其中 $i \\in \\{0,1,\\dots,6\\}$ 且 $j \\in \\{i+1,i+2,\\dots,7\\}$，同时断言中断 $\\{i,j\\}$ 并观察硬件首先传递哪一个；如果任何测试产生的首次传递不是 $i$，操作系统必须声明控制器有缺陷。\n  2. 通过不信任硬件的交付顺序来隔离该缺陷，而是使用软件维护的按优先级队列。操作系统应在每次硬件交付时，将交付的中断标识符入队到其预期数值优先级的软件队列中，之后严格按照从最高优先级到最低优先级（即从 $p=0$ 到 $p=7$）的顺序从软件队列中分派，从而恢复正确的语义。从概念上讲，这模拟了先确认硬件（中断），然后在从中断向量调用处理程序之前，交由软件仲裁器处理。\n- 一个模拟的中断向量，它将每个中断标识符 $p \\in \\{0,1,\\dots,7\\}$ 映射到一个处理程序，当由操作系统分派时，该处理程序会增加与 $p$ 关联的计数器。您不需要为函数指针建模；使用整数计数器来表示处理程序的调用。\n\n此外，包括一个模拟的基于DMA的输入/输出工作负载，该负载会产生中断：\n- 一个DMA引擎，每当一次传输完成时，在级别 $p=4$ 引发一个中断。假设是确定性完成：在离散时间步 $t \\in \\{0,1,2,\\dots,T-1\\}$（其中 $T=30$）中，当 $t$ 为偶数时（即当 $t \\bmod 2 = 0$ 时），DMA引擎完成一次传输并发出中断信号。\n- 一个定时器设备，每 $K=5$ 个时间步，在级别 $p=1$ 引发一个中断，即当 $t \\bmod 5 = 0$ 时。\n- 一个网络接口控制器，当 $t \\bmod 7 = 3$ 时，在级别 $p=3$ 引发一个中断。\n在每个时间步，该步骤所有设备生成的中断同时变为待处理状态。\n\n您的程序必须计算以下测试套件的结果：\n- 测试A（在有缺陷的控制器上进行缺陷检测）：如果操作系统使用所述的成对方法检测到缺陷，则返回一个表示为整数 $1$ 的布尔值，否则返回 $0$。\n- 测试B（在正确的控制器上进行缺陷检测）：如果操作系统错误地声称存在缺陷，则返回 $1$，否则返回 $0$。一个正确的实现必须在此处返回 $0$。\n- 测试C（在没有软件解决方案的有缺陷硬件下的乱序）：考虑一个单一批次，其中 $\\{0,1,2,3,4,5,6,7\\}$ 中的所有级别同时待处理。让硬件根据有缺陷的规则重复选择并移除一个待处理中断，直到没有剩余，生成一个长度为 $8$ 的服务序列 $S$。设理想的升序序列为 $I=[0,1,2,3,4,5,6,7]$。计算 $S$ 相对于 $I$ 的逆序数，定义为索引对 $(a,b)$ 的数量，其中 $0 \\le a  b \\le 7$ 且 $S[a]  S[b]$。将此逆序数作为非负整数返回。\n- 测试D（在有缺陷的硬件下使用软件隔离和解决方案的乱序）：对于与测试C相同的单一批次，对操作系统进行建模，该系统首先确认每次硬件交付并按数值优先级将其入队，然后严格按照升序数值优先级的顺序从软件队列中分派。生成由软件仲裁器确定的服务序列，并如上计算其相对于 $I$ 的逆序数。将此逆序数作为非负整数返回。\n- 测试E（在使用软件解决方案的DMA压力下的饥饿检查）：在时间线 $t \\in \\{0,1,\\dots,29\\}$ 和所述的确定性设备下，假设硬件有缺陷，但操作系统使用隔离和软件仲裁器。在每个时间步，将所有硬件交付确认到软件队列中，然后严格按照从高到低优先级（升序数值）的顺序从软件队列中分派。计算在至少一个更高优先级的中断仍在软件队列中待处理时，一个较低优先级的中断被分派的次数。将此计数作为非负整数返回。\n- 测试F（边界条件）：在没有待处理中断且没有设备生成中断的情况下，尝试一次分派过程，如果系统没有执行任何分派并保持一致（即没有操作发生），则返回 $1$，否则返回 $0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序如下：$[\\text{A},\\text{B},\\text{C},\\text{D},\\text{E},\\text{F}]$。每个元素必须是一个整数。\n\n此问题不涉及物理单位。不涉及角度和百分比。该问题是通用的、纯逻辑的：任何 modern 编程语言都可以实现该模拟和所需的计算。请确保您的程序是自包含的，并且不需要任何输入。", "solution": "该问题要求模拟一个操作系统的中断子系统，以分析有缺陷的硬件优先级编码器的影响，并验证一种基于软件的缓解策略。解决方案将首先为每个组件建立理论和计算模型，然后逐步实现所需的测试。\n\n### 1. 为中断控制器和优先级编码建模\n\n该系统涉及来自集合 $\\{0, 1, 2, 3, 4, 5, 6, 7\\}$ 的中断优先级 $p$。较小的 $p$ 值表示较高的优先级。一个正确的可编程中断控制器（PIC）会服务具有最小 $p$ 值的待处理中断。\n\n指定的硬件缺陷在于优先级编码器。有缺陷的控制器不是比较优先级 $p$，而是比较 $p$ 的按位翻转变换。给定 $W=3$ 的位宽，变换函数 $r_W(p)$ 会翻转 $p$ 的 $W$ 位二进制表示的比特位。例如，优先级 $p=1$（二进制为 $001_2$）被映射为 $r_3(1)=100_2=4$。有缺陷的 PIC 会服务最小化 $r_3(p)$ 而不是 $p$ 的待处理中断 $p^\\star$。\n\n对于 $p \\in \\{0, \\dots, 7\\}$ 的完整映射如下：\n- $r_3(0) = r_3(000_2) = 000_2 = 0$\n- $r_3(1) = r_3(001_2) = 100_2 = 4$\n- $r_3(2) = r_3(010_2) = 010_2 = 2$\n- $r_3(3) = r_3(011_2) = 110_2 = 6$\n- $r_3(4) = r_3(100_2) = 001_2 = 1$\n- $r_3(5) = r_3(101_2) = 101_2 = 5$\n- $r_3(6) = r_3(110_2) = 011_2 = 3$\n- $r_3(7) = r_3(111_2) = 111_2 = 7$\n\n我们将实现一个函数 `select_interrupt`，它接受一个待处理中断的位掩码和一个模式（正确或缺陷）。在正确模式下，它找到最低的置位（set bit），代表最小的 $p$。在缺陷模式下，它遍历所有置位（待处理中断），并选择其优先级 $p$ 具有最小 $r_3(p)$ 值的那个。\n\n### 2. 为操作系统层建模\n\n操作系统层有两个关键功能：缺陷检测和一个基于软件的隔离与分派解决方案。\n\n**缺陷检测**：操作系统必须系统地测试硬件的优先级处理。对于每对优先级 $(i, j)$（其中 $i  j$），操作系统将同时为这两个级别断言中断。一个正确的 PIC 必须首先服务级别 $i$。如果有缺陷的 PIC 首先服务级别 $j$（这在 $r_3(j)  r_3(i)$ 时发生），则检测到缺陷。模拟将执行这些成对测试并报告是否发现缺陷。\n\n**软件隔离与解决方案**：在检测到缺陷时（或作为一种通用的防御措施），操作系统不再信任硬件的选择顺序。策略如下：\n1.  当硬件发出中断信号时，操作系统会确认它，但不会立即执行处理程序。相反，它会将中断标识符 $p$ 入队到一个由软件管理的、对应于优先级 $p$ 的队列中。\n2.  在确认硬件中断后，操作系统从其软件队列中分派处理程序。为了恢复正确的优先级行为，它严格按照 $p$ 的升序（从 $p=0$到 $p=7$）处理这些队列。对于每个级别，它会分派所有排队的中断，然后再移至下一个级别。\n\n这个两阶段过程（硬件确认到软件队列，然后从这些队列进行软件分派）有效地将硬件仅用作“某个”中断待处理的信号，而操作系统的软件仲裁器则做出关于接下来应运行哪个处理程序的最终的、正确的决策。我们将把这些软件队列建模为简单的 FIFO 缓冲区。\n\n### 3. 测试用例实现策略\n\n- **测试 A 和 B（缺陷检测）**：一个函数将遍历所有对 $(i,j)$，其中 $0 \\le i  j \\le 7$。对于每一对，它设置一个将第 $i$ 位和第 $j$ 位置位的待处理掩码，然后调用 `select_interrupt`。对于测试 A（有缺陷的控制器），它检查返回的中断是否曾经是 $j$。例如，对于 $(i=1, j=4)$，$14$ 但 $r_3(4)=1  r_3(1)=4$，有缺陷的控制器将选择 4，从而检测到缺陷。因此测试 A 的结果是 1。对于测试 B（正确的控制器），它检查返回的中断是否曾经不是 $i$。正确的控制器总是选择 $i$，因此不会检测到缺陷，结果为 0。\n\n- **测试 C（无解决方案下的乱序）**：有缺陷的硬件会按照 $r_3(p)$ 的递增顺序来服务中断。$r_3(p)$ 值的顺序是 $0, 1, 2, 3, 4, 5, 6, 7$，对应的优先级 $p$ 是 $0, 4, 2, 6, 1, 5, 3, 7$。因此，服务序列 $S = [0, 4, 2, 6, 1, 5, 3, 7]$。与理想序列 $I=[0, 1, 2, 3, 4, 5, 6, 7]$ 相比，逆序对为：(4,2), (4,1), (4,3); (2,1); (6,1), (6,5), (6,3); (5,3)。总计 $3 + 1 + 3 + 1 = 8$ 个逆序。\n\n- **测试 D（有解决方案下的乱序）**：尽管硬件以序列 $S$ 交付中断，但操作系统将它们全部入队。然后，软件仲裁器按正确的优先级顺序（$p=0, \\dots, 7$）进行分派。最终的分派序列将是理想的 $[0, 1, 2, 3, 4, 5, 6, 7]$。该序列相对于理想序列的逆序数为 0。\n\n- **测试 E（饥饿检查）**：该测试的核心是检查是否存在优先级倒置。软件解决方案的设计从根本上防止了这一点。分派逻辑是严格按顺序检查软件队列（从优先级0到7）。只有当所有更高优先级的队列（$0, \\dots, p-1$）都为空时，分派器才会处理队列 $p$。因此，在更高优先级的中断仍在软件队列中等待时，分派较低优先级中断的次数严格为 0。\n\n- **测试 F（边界条件）**：这是一个边界条件测试。当没有待处理中断时，硬件中断控制器不会发出任何信号。操作系统分派循环会检查所有软件队列，发现它们都是空的，然后无操作地结束。系统保持一致状态。因此，结果为 1。", "answer": "[1, 0, 8, 0, 0, 1]", "id": "3650411"}]}