{"hands_on_practices": [{"introduction": "要理解写缓冲区的性能，最基本的方法是将其建模为一个队列系统。这个练习将指导你通过一个简化的流体模型来分析系统的稳定性，通过比较数据写入速率和刷盘速率，你可以预测缓冲区何时会饱和。通过这个练习 [@problem_id:3690122]，你将掌握分析缓冲系统负载和稳定性的核心定量技能。", "problem": "一个操作系统使用写回（write-back）缓存策略，并带有一个驻留内存的写缓冲区。多个生产者线程生成应用程序的写请求并将其附加到缓冲区，而一个单独的异步刷新线程（flusher thread）将缓冲区的数据排空到存储设备。将该系统建模为一个连续速率（流体）队列，定义如下：\n\n- 令 $Q(t)$ 表示在时间 $t$ 的缓冲数据量。\n- 令 $\\lambda$ 表示写请求的长期平均生成率（缓冲区到达率）。\n- 令 $\\mu$ 表示刷新线程的长期平均持续排空率（缓冲区服务率）。\n- 假设 $Q(0)=Q_{0} \\ge 0$。\n- 当 $Q(t) > 0$ 时，刷新线程能以速率 $\\mu$ 运行；当 $Q(t)=0$ 时，缓冲区的数据量不能为负。\n- 缓冲区具有有限容量 $C$；当 $Q(t)$ 首次达到 $C$ 时，发生溢出。\n\n仅从基本流量守恒原理出发——即只要缓冲区非空，缓冲数据的瞬时变化率等于输入速率减去输出速率，且 $Q(t)$ 的下界为 $0$——回答以下问题：\n\n1) 使用上述原理，且不借助任何现成的排队论结果，论证缓冲区占用率的长期稳定性。陈述在何种关于 $\\lambda$ 和 $\\mu$ 的条件下，缓冲区占用率可以随时间保持有界，以及在何种条件下它会发散。\n\n2) 专门针对 $\\lambda > \\mu$ 且 $Q(0)=Q_{0} \\in (0,C)$ 的情况，推导 $Q(t)$ 在 $0 \\le t  t_{\\text{overflow}}$ 期间的闭式表达式，其中 $t_{\\text{overflow}}$ 是 $Q(t)$ 首次达到 $C$ 的时间。\n\n3) 对于一个具体系统，其参数为 $\\lambda = 2.4$ GB/s，$\\mu = 1.8$ GB/s，$C = 12$ GB，以及 $Q_{0} = 1.5$ GB，计算溢出时间 $t_{\\text{overflow}}$（以秒为单位）。最终答案以秒表示，并四舍五入到四位有效数字。", "solution": "问题要求分析一个建模为连续速率流体队列的写缓冲区。该分析必须从流量守恒的第一性原理推导得出。\n\n所提供的基本原理是，缓冲数据量的瞬时变化率 $\\frac{dQ(t)}{dt}$ 等于输入速率减去输出速率。输入速率是给定的恒定平均速率 $\\lambda$。输出速率是恒定的平均速率 $\\mu$，但这种排空只在缓冲区非空时发生，即 $Q(t) > 0$。此外，缓冲区数据量不能为负，即 $Q(t) \\ge 0$。\n\n这可以形式化为一个微分方程。对于 $Q(t) > 0$ 的任何时间 $t$，其动态由以下方程决定：\n$$\n\\frac{dQ(t)}{dt} = \\lambda - \\mu\n$$\n如果 $Q(t) = 0$，数据量不能再减少。因此，变化率必须为非负。这意味着当 $Q(t) = 0$ 时，$\\frac{dQ(t)}{dt} = \\max(0, \\lambda - \\mu)$。\n\n1) 缓冲区占用率的稳定性\n缓冲区占用率 $Q(t)$ 的长期行为（稳定性）完全取决于净速率的符号，即恒定值 $\\lambda - \\mu$。我们分析问题中提出的两种情况。\n\n情况一：有界占用率（稳定系统）\n为使缓冲区占用率随时间保持有界，它必须没有无限增长的趋势。当缓冲区非空时，如果净变化率为非正，则可满足此条件。\n如果 $\\lambda  \\mu$，则 $\\lambda - \\mu  0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt}  0$，这意味着缓冲区将会排空。如果缓冲区为空，$Q(t)=0$，只有当有数据到达时它才会开始填充，此时排空速率超过到达速率，将 $Q(t)$ 推向 $0$。该系统是自我调节的，占用率将保持有界。\n如果 $\\lambda = \\mu$，则 $\\lambda - \\mu = 0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt} = 0$。缓冲区的数据量将保持在其当前值不变。如果 $Q(t) = 0$，它将保持为 $0$。占用率不会无限增长；如果 $Q_00$，它将保持在初始水平 $Q_0$。因此，它也是有界的。\n因此，缓冲区占用率随时间保持有界的条件是 $\\lambda \\le \\mu$。\n\n情况二：发散占用率（不稳定系统）\n如果缓冲区占用率有持续增长的趋势，它将会发散。当净变化率为正时，就会发生这种情况。\n如果 $\\lambda  \\mu$，则 $\\lambda - \\mu  0$。在这种情况下，只要 $Q(t)  0$，我们就有 $\\frac{dQ}{dt}  0$。缓冲区的数据量将持续增加。即使缓冲区开始时为空，$Q(0)=0$，$\\frac{dQ}{dt} = \\lambda - \\mu  0$，所以它将立即开始填充并持续增长。在一个容量有限为 $C$ 的系统中，这种增长将持续到缓冲区溢出。在一个无容量限制的系统中，$Q(t)$ 将无界增长。\n因此，缓冲区占用率发散的条件是 $\\lambda  \\mu$。\n\n2) 针对 $\\lambda  \\mu$ 的情况推导 $Q(t)$\n我们给定 $\\lambda  \\mu$ 的特定情况，初始条件为 $Q(0) = Q_{0}$，其中 $Q_{0} \\in (0, C)$。\n由于 $Q_{0}  0$ 且净速率 $\\lambda - \\mu$ 是一个正常数，缓冲区数据量 $Q(t)$ 将从其初始状态线性增加。对于 $t  0$，它永远不会变为 $0$。因此，在整个时间区间 $0 \\le t  t_{\\text{overflow}}$ 内，系统由更简单的微分方程决定：\n$$\n\\frac{dQ}{dt} = \\lambda - \\mu\n$$\n这是一个系数恒定的一阶常微分方程。我们可以通过对时间从 $t=0$ 到一个通用时间 $t$ 进行积分来求解，相应的队列数据量为 $Q(0)=Q_{0}$ 和 $Q(t)$：\n$$\n\\int_{Q_{0}}^{Q(t)} dQ' = \\int_{0}^{t} (\\lambda - \\mu) dt'\n$$\n计算积分得到：\n$$\nQ(t) - Q_{0} = (\\lambda - \\mu)t\n$$\n求解 $Q(t)$，我们得到缓冲区数据量作为时间函数的闭式表达式：\n$$\nQ(t) = Q_{0} + (\\lambda - \\mu)t\n$$\n该表达式在 $0 \\le t  t_{\\text{overflow}}$ 期间有效。\n\n3) 计算溢出时间 $t_{\\text{overflow}}$\n给定系统参数如下：\n- 到达率 $\\lambda = 2.4$ GB/s\n- 服务率 $\\mu = 1.8$ GB/s\n- 缓冲区容量 $C = 12$ GB\n- 初始缓冲数据量 $Q_{0} = 1.5$ GB\n\n溢出时间 $t_{\\text{overflow}}$ 是缓冲区数据量 $Q(t)$ 首次达到容量 $C$ 的时间 $t$。我们使用第(2)部分得到的 $Q(t)$ 表达式，并令 $Q(t_{\\text{overflow}}) = C$：\n$$\nC = Q_{0} + (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n现在我们可以求解 $t_{\\text{overflow}}$：\n$$\nC - Q_{0} = (\\lambda - \\mu)t_{\\text{overflow}}\n$$\n$$\nt_{\\text{overflow}} = \\frac{C - Q_{0}}{\\lambda - \\mu}\n$$\n现在，我们将数值代入此方程。单位是一致的：$\\frac{\\text{GB}}{\\text{GB/s}} = \\text{s}$。\n$$\nt_{\\text{overflow}} = \\frac{12 - 1.5}{2.4 - 1.8}\n$$\n$$\nt_{\\text{overflow}} = \\frac{10.5}{0.6}\n$$\n$$\nt_{\\text{overflow}} = 17.5\n$$\n问题要求答案四舍五入到四位有效数字。精确值 $17.5$ 可以表示为 $17.50$ 以满足此要求。结果的单位是秒。", "answer": "$$\n\\boxed{17.50}\n$$", "id": "3690122"}, {"introduction": "虽然写缓冲能显著提升性能，但它也带来了数据一致性的挑战，尤其是在系统崩溃或断电时，缓冲区中的数据可能会丢失。本练习 [@problem_id:3690204] 探讨了一种经典的原子文件更新技术，它要求你仔细安排数据写入、刷盘（`fsync`）和文件重命名（`rename`）等操作的顺序，以确保即使在发生意外崩溃后，文件内容也始终保持一致和完整。", "problem": "在一个兼容可移植操作系统接口（POSIX）的操作系统（OS）上，一个应用程序使用两步协议来更新一个配置文件，以避免部分写入。该应用程序将新版本的配置写入临时文件路径 $\\mathrm{config.tmp}$，然后将 $\\mathrm{config.tmp}$ 重命名为现有的 $\\mathrm{config}$ 路径。存储栈使用操作系统页面缓存和设备回写缓存；这两个缓存都是易失性的，除非被显式刷新，否则在崩溃时可能会丢失缓冲的数据。关闭文件并不保证持久性。对普通文件使用函数 $\\mathrm{fsync}$ 会强制该文件的数据和 inode 元数据到达稳定存储；对目录使用函数 $\\mathrm{fsync}$ 会强制目录条目（包括添加、删除和重命名）和目录元数据到达稳定存储。重命名操作一旦被持久化，对于目录条目来说是原子的（即，读取者要么看到旧的名称映射，要么看到新的名称映射，但绝不会是混合状态），然而，除非强制，文件的数据块和目录元数据可能以不同的顺序被持久化。\n\n应用程序的基线序列（忽略可选的 $\\mathrm{fsync}$ 调用）如下：\n- 打开 $\\mathrm{config.tmp}$ 以进行写入。\n- 将 $N$ 字节的新配置写入 $\\mathrm{config.tmp}$。\n- 关闭 $\\mathrm{config.tmp}$。\n- 将 $\\mathrm{config.tmp}$ 重命名为 $\\mathrm{config}$（在持久化时原子地替换旧的 $\\mathrm{config}$）。\n\n你必须决定在何处放置 $\\mathrm{fsync}$ 调用，以在以下强崩溃一致性要求下保证原子性：\n\n定义（原子性要求）：对于在更新期间任何时间发生的任何崩溃（可能在序列中两个相邻的系统调用之间），恢复后的系统状态必须满足以下两个不变量：\n- 不变量 $\\mathrm{I1}$（可见时无撕裂内容）：如果在恢复后 $\\mathrm{config}$ 指向新版本，那么其内容必须恰好是应用程序写入的 $N$ 字节（没有截断、零值或陈旧的混合内容）。\n- 不变量 $\\mathrm{I2}$（名称切换成功后的持久性）：在应用程序所选序列中的最后一个调用成功返回后，任何后续的崩溃都不能使名称映射回滚；也就是说，恢复后 $\\mathrm{config}$ 继续指向新版本。\n\n假设源路径和目标路径在同一个父目录中。以下哪种 $\\mathrm{fsync}$ 的放置方式能保证上述定义的原子性？\n\nA. 完全不执行 `fsync` 调用。\n\nB. 重命名后，仅对父目录调用 `fsync`；不对文件调用 `fsync`。\n\nC. 重命名之前，对 `config.tmp` 调用 `fsync`；重命名之后，不对父目录调用 `fsync`。\n\nD. 重命名之前，对 `config.tmp` 调用 `fsync`；执行重命名；然后对父目录调用 `fsync`。\n\nE. 先执行重命名；然后对 `config`（重命名后的文件）调用 `fsync`；最后对父目录调用 `fsync`。", "solution": "为了确保原子文件更新，我们必须同时满足不变量 I1 和 I2，即使在任何时间点发生系统崩溃。\n\n**分析不变量 I1（可见时无撕裂内容）：**\n此不变量要求，如果 `config` 文件名指向新版本，则其内容必须是完整的。`rename` 操作使新版本可见。由于写缓冲和 I/O 调度器的存在，操作系统可能会在持久化 `config.tmp` 的数据之前，先持久化 `rename` 操作（对父目录的修改）。如果此时发生崩溃，`config` 文件将指向一个数据不完整或为空的 inode，从而违反 I1。\n\n为了防止这种情况，我们必须建立一个持久化顺序：首先确保 `config.tmp` 的所有数据都已写入稳定存储，然后才能执行 `rename`。`fsync(config.tmp)` 系统调用正是用于此目的。因此，任何正确的序列都必须在 `rename` 之前调用 `fsync(config.tmp)`。这个要求排除了选项 A、B 和 E。\n\n**分析不变量 I2（名称切换成功后的持久性）：**\n此不变量要求，一旦整个更新序列成功完成，`rename` 操作本身必须是持久的。`rename` 调用成功返回仅表示操作系统已在内存中接受了该请求，而不保证该目录更改已写入磁盘。如果在 `rename` 返回后、但在目录更改被持久化之前发生崩溃，`config` 将会回滚到旧版本，违反 I2。\n\n为了确保 `rename` 操作的持久性，我们必须在 `rename` 调用之后，对包含该文件条目的父目录调用 `fsync`。`fsync(父目录)` 会强制将目录的所有修改（包括 `rename` 操作）写入稳定存储。因此，任何正确的序列都必须在 `rename` 之后对父目录调用 `fsync`。这个要求排除了选项 C。\n\n**结论：**\n结合以上两个分析，唯一满足两个不变量的序列是：\n1.  将数据写入 `config.tmp`。\n2.  调用 `fsync(config.tmp)` 以确保持久化新数据。\n3.  调用 `rename(\"config.tmp\", \"config\")` 以原子地切换文件名。\n4.  调用 `fsync(父目录)` 以确保持久化 `rename` 操作。\n\n这个序列与选项 D 完全匹配。", "answer": "$$\\boxed{D}$$", "id": "3690204"}, {"introduction": "现实世界的操作系统内核采用比单一速率刷盘更复杂的策略来管理脏页。这个练习 [@problem_id:3690239] 让你模拟一种常见的高级刷新策略，其中系统根据脏页数量占缓存容量的比例（例如，背景刷新阈值和紧急刷新阈值）来触发不同强度的刷盘操作。通过编写程序来模拟这个动态过程，你将能够更深入地理解现代操作系统如何平衡性能和I/O负载。", "problem": "设计并实现一个完整、可运行的程序，用于模拟操作系统 (OS) 中文件系统页面缓存在写密集型工作负载下的动态变化。该模型使用回写式缓存，并包含脏页阈值和刷新线程。目标是预测刷新线程何时启动以及页面缓存是否会饱和。\n\n从以下基本定义和经过充分检验的事实出发。页面缓存保存最近访问的文件数据，并在进程写入数据时累积脏页，从而延迟回写到二级存储。设缓存容量为 $C$ 页，时间 $t$ 时的脏页数量为 $D(t)$，以页为单位。在写密集型工作负载下，$N$ 个进程以恒定速率 $\\{w_i\\}_{i=1}^N$（单位：页/秒）进行写入，因此总写入速率为 $W = \\sum_{i=1}^N w_i$（单位：页/秒）。回写刷新线程由两个阈值控制，这两个阈值表示为缓存容量的比率：后台刷新脏页阈值 $\\text{dirty\\_bg\\_ratio} = r_{\\text{bg}}$ 和最大脏页阈值 $\\text{dirty\\_ratio} = r_{\\text{max}}$，其中 $0  r_{\\text{bg}}  r_{\\text{max}}  1$。当 $D(t)$ 超过 $r_{\\text{bg}} \\cdot C$ 时，后台刷新以恒定速率 $f_{\\text{bg}}$（单位：页/秒）开始。当 $D(t)$ 超过 $r_{\\text{max}} \\cdot C$ 时，积极刷新以更高的恒定速率 $f_{\\text{max}}$（单位：页/秒）开始。脏页数量 $D(t)$ 受限于 $0 \\le D(t) \\le C$。\n\n程序必须为每个给定的测试用例计算以下量：\n- $t_{\\text{bg}}$：$D(t)$ 首次达到或超过 $r_{\\text{bg}} \\cdot C$ 的时间（秒），此时后台刷新线程启动。\n- $t_{\\text{max}}$：$D(t)$ 首次达到或超过 $r_{\\text{max}} \\cdot C$ 的时间（秒），此时积极刷新线程启动。\n- $t_{\\text{sat}}$：$D(t)$ 首次达到 $C$ 的时间（秒），此时页面缓存饱和。\n\n使用以下分段线性动力学模型。设初始脏页数量为 $D(0) = D_0$。总写入速率为 $W = \\sum_{i=1}^N w_i$。定义瞬时回写速率 $f(D)$ 如下：\n$$\nf(D) = \n\\begin{cases}\n0,  \\text{如果 } D  r_{\\text{bg}} \\cdot C, \\\\\nf_{\\text{bg}},  \\text{如果 } r_{\\text{bg}} \\cdot C \\le D  r_{\\text{max}} \\cdot C, \\\\\nf_{\\text{max}},  \\text{如果 } D \\ge r_{\\text{max}} \\cdot C,\n\\end{cases}\n$$\n脏页数量的变化率由经过充分检验的守恒定律给出：\n$$\n\\frac{dD}{dt} = W - f(D),\n$$\n并被限制在区间 $[0, C]$ 内。\n\n所有时间必须以秒为单位，表示为十进制浮点数。如果在恒定速率下某个事件永远不会发生（例如，没有写入，因此 $W = 0$ 且 $D(t)$ 永不增加），则该量的输出为 $-1.0$。\n\n测试套件。为以下参数集实现程序。对于每个测试用例，程序必须输出 $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$。\n\n- 测试用例 1（常规“理想路径”）：$C = 10000$，$r_{\\text{bg}} = 0.1$，$r_{\\text{max}} = 0.4$，$N = 3$，$\\{w_i\\} = \\{120, 80, 50\\}$，$f_{\\text{bg}} = 200$，$f_{\\text{max}} = 300$，$D_0 = 0$。\n- 测试用例 2（后台刷新恰好平衡写入的边界情况）：$C = 5000$，$r_{\\text{bg}} = 0.2$，$r_{\\text{max}} = 0.5$，$N = 2$，$\\{w_i\\} = \\{100, 100\\}$，$f_{\\text{bg}} = 200$，$f_{\\text{max}} = 400$，$D_0 = 0$。\n- 测试用例 3（无写入的边缘情况）：$C = 8000$，$r_{\\text{bg}} = 0.1$，$r_{\\text{max}} = 0.3$，$N = 2$，$\\{w_i\\} = \\{0, 0\\}$，$f_{\\text{bg}} = 100$，$f_{\\text{max}} = 200$，$D_0 = 0$。\n- 测试用例 4（即使积极刷新也无法跟上的饱和情况）：$C = 4000$，$r_{\\text{bg}} = 0.15$，$r_{\\text{max}} = 0.35$，$N = 4$，$\\{w_i\\} = \\{300, 250, 200, 150\\}$，$f_{\\text{bg}} = 500$，$f_{\\text{max}} = 800$，$D_0 = 0$。\n- 测试用例 5（后台刷新线程被触发但立即减少了脏页数量）：$C = 12000$，$r_{\\text{bg}} = 0.25$，$r_{\\text{max}} = 0.6$，$N = 1$，$\\{w_i\\} = \\{100\\}$，$f_{\\text{bg}} = 150$，$f_{\\text{max}} = 400$，$D_0 = 0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含结果，格式为子列表的逗号分隔列表，每个子列表的形式为 $[t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}]$，所有时间均以秒为单位，为保留六位小数的十进制浮点数，并由一对外部方括号括起来。例如：$[[1.000000,2.500000,-1.000000],[\\dots]]$。", "solution": "该问题要求通过分阶段分析来模拟页面缓存的动态行为。在每个阶段，脏页数量的变化率是恒定的，这使得我们可以用简单的线性方程来计算达到下一个阈值所需的时间。\n\n首先，我们根据给定的比率计算绝对的脏页阈值：\n- 后台阈值: $D_{\\text{bg}} = r_{\\text{bg}} \\cdot C$\n- 最大阈值: $D_{\\text{max}} = r_{\\text{max}} \\cdot C$\n\n然后，我们计算每个阶段的净变化率：\n- **阶段 1** (刷新前, $D  D_{\\text{bg}}$): 净速率 $R_1 = W$\n- **阶段 2** (后台刷新, $D_{\\text{bg}} \\le D  D_{\\text{max}}$): 净速率 $R_2 = W - f_{\\text{bg}}$\n- **阶段 3** (积极刷新, $D \\ge D_{\\text{max}}$): 净速率 $R_3 = W - f_{\\text{max}}$\n\n对于所有测试用例，$D_0=0$，所以模拟总是从阶段1开始。\n\n**第1步: 计算 $t_{\\text{bg}}$**\n要从 $D_0=0$ 达到 $D_{\\text{bg}}$，脏页数量需要增加 $D_{\\text{bg}}$。这只在 $R_1 > 0$ 时才可能发生。\n如果 $R_1 > 0$，所需时间为 $t_{\\text{bg}} = \\frac{D_{\\text{bg}} - D_0}{R_1} = \\frac{D_{\\text{bg}}}{W}$。\n如果 $R_1 \\le 0$，则 $t_{\\text{bg}}, t_{\\text{max}}, t_{\\text{sat}}$ 都为 $-1.0$。\n\n**第2步: 计算 $t_{\\text{max}}$**\n在时间 $t_{\\text{bg}}$ 时，系统有 $D_{\\text{bg}}$ 个脏页，并进入阶段2。要达到 $D_{\\text{max}}$，脏页数量需要从 $D_{\\text{bg}}$ 增加到 $D_{\\text{max}}$。这只在 $R_2 > 0$ 时才可能发生。\n如果 $R_2 > 0$，此阶段所需的时间为 $\\Delta t_2 = \\frac{D_{\\text{max}} - D_{\\text{bg}}}{R_2}$。总时间为 $t_{\\text{max}} = t_{\\text{bg}} + \\Delta t_2$。\n如果 $R_2 \\le 0$，系统永远不会达到 $D_{\\text{max}}$，因此 $t_{\\text{max}}$ 和 $t_{\\text{sat}}$ 都为 $-1.0$。\n\n**第3步: 计算 $t_{\\text{sat}}$**\n在时间 $t_{\\text{max}}$ 时，系统有 $D_{\\text{max}}$ 个脏页，并进入阶段3。要达到饱和状态 $C$，脏页数量需要从 $D_{\\text{max}}$ 增加到 $C$。这只在 $R_3 > 0$ 时才可能发生。\n如果 $R_3 > 0$，此阶段所需的时间为 $\\Delta t_3 = \\frac{C - D_{\\text{max}}}{R_3}$。总时间为 $t_{\\text{sat}} = t_{\\text{max}} + \\Delta t_3$。\n如果 $R_3 \\le 0$，系统永远不会饱和，因此 $t_{\\text{sat}}$ 为 $-1.0$。\n\n**测试用例计算:**\n- **用例 1:** $W=250, D_{\\text{bg}}=1000, D_{\\text{max}}=4000$.\n  $R_1=250, R_2=50, R_3=-50$.\n  $t_{\\text{bg}} = 1000/250 = 4.0$.\n  $\\Delta t_2 = (4000-1000)/50 = 60.0 \\implies t_{\\text{max}} = 4.0 + 60.0 = 64.0$.\n  $R_3  0 \\implies t_{\\text{sat}} = -1.0$.\n- **用例 2:** $W=200, D_{\\text{bg}}=1000, D_{\\text{max}}=2500$.\n  $R_1=200, R_2=0, R_3=-200$.\n  $t_{\\text{bg}} = 1000/200 = 5.0$.\n  $R_2 = 0 \\implies t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$.\n- **用例 3:** $W=0$.\n  $R_1 = 0 \\implies t_{\\text{bg}} = -1.0, t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$.\n- **用例 4:** $W=900, D_{\\text{bg}}=600, D_{\\text{max}}=1400$.\n  $R_1=900, R_2=400, R_3=100$.\n  $t_{\\text{bg}} = 600/900 \\approx 0.666667$.\n  $\\Delta t_2 = (1400-600)/400 = 2.0 \\implies t_{\\text{max}} = 0.666667 + 2.0 = 2.666667$.\n  $\\Delta t_3 = (4000-1400)/100 = 26.0 \\implies t_{\\text{sat}} = 2.666667 + 26.0 = 28.666667$.\n- **用例 5:** $W=100, D_{\\text{bg}}=3000, D_{\\text{max}}=7200$.\n  $R_1=100, R_2=-50, R_3=-300$.\n  $t_{\\text{bg}} = 3000/100 = 30.0$.\n  $R_2  0 \\implies t_{\\text{max}} = -1.0, t_{\\text{sat}} = -1.0$.", "answer": "[[4.000000, 64.000000, -1.000000], [5.000000, -1.000000, -1.000000], [-1.000000, -1.000000, -1.000000], [0.666667, 2.666667, 28.666667], [30.000000, -1.000000, -1.000000]]", "id": "3690239"}]}