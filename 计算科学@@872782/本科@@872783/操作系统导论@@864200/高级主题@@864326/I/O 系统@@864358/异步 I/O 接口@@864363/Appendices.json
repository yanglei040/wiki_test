{"hands_on_practices": [{"introduction": "要构建高性能的异步系统，首先必须理解其根本的性能限制。这个练习将引导你推导一个事件驱动服务器的最大可持续吞吐量。通过分析分配给服务器的CPU资源预算和处理单个事件所需的计算成本，你可以得出一个基本的性能基线，这是所有性能优化工作的起点。[@problem_id:3621630]", "problem": "考虑一个基于异步输入/输出 (I/O) 接口构建的事件驱动服务器。该服务器运行一个单线程事件循环，该循环从一个队列中拉取完成事件，并通过执行一系列有限的用户空间操作和非阻塞系统调用来处理每个完成事件。假设如下：\n\n- 事件循环在单个中央处理器 (CPU) 核心上调度，并受到操作系统调度程序强制执行的严格配额限制：在任何长度为 $t$ 秒的墙上时钟时间内，事件循环最多获得 $B \\cdot t$ 秒的 CPU 时间，其中 $B$ 是一个固定常数，满足 $0  B \\le 1$。\n- 每个已完成的 I/O 事件一旦出队，在被视为完全处理之前，需要在事件循环中消耗确定量的 CPU 处理时间 $c$（秒/事件）。\n- 完成队列足够大，只有当长期平均单位时间到达的事件数超过事件循环长期平均单位时间能处理的事件数时，它才会开始丢弃事件。\n- 事件循环本身在事件处理过程中绝不会以让出 CPU 的方式阻塞，并且任何轮询开销都已包含在 $c$ 中。\n\n仅根据这些假设以及队列稳定的核心定义（即其长期到达率不大于其长期服务率），推导出一个封闭形式的表达式，用于表示最大可持续事件到达率 $\\lambda_{\\max}$（事件/秒），使得系统在长期运行中不会丢弃事件。请将最终答案表示为事件/秒。不需要进行数值代入；仅用 $B$ 和 $c$ 表示该表达式。", "solution": "问题要求解一个单线程、事件驱动服务器的最大可持续事件到达率，记为 $\\lambda_{\\max}$。系统的稳定性取决于长期平均到达率不超过长期平均服务率的条件。因此，最大可持续到达率等于系统的最大长期平均服务率。我们用 $\\mu$ 表示服务率（单位：事件/秒）。目标是求出 $\\lambda_{\\max} = \\mu$。\n\n问题提供了以下关键参数和约束：\n1.  服务器的事件循环在单个 CPU 核心上调度。\n2.  分配给事件循环的 CPU 时间受配额限制。在任何持续时间为 $t$ 秒的墙上时钟时间内，事件循环最多被授予 $B \\cdot t$ 秒的 CPU 时间。常数 $B$ 是一个无量纲的分数，代表 CPU 份额，其中 $0  B \\le 1$。\n3.  每个事件的处理需要固定的 CPU 时间 $c$ 秒。$c$ 的单位是秒/事件。\n\n我们的目标是确定服务器在单位墙上时钟时间内可以处理的最大事件数。我们考虑一个任意的、足够长的墙上时钟时间间隔 $t$。\n\n在这个 $t$ 秒的时间间隔内，根据定义，事件循环可用的总 CPU 时间最多为 $B \\cdot t$ 秒。我们将这个可用的 CPU 时间称为 $T_{CPU}$。于是，我们有：\n$$T_{CPU} \\leq B \\cdot t$$\n为了找到最大可持续速率，我们必须考虑最大处理能力，这对应于事件循环完全利用其 CPU 配额的情况。因此，我们将可用的 CPU 时间精确地设为：\n$$T_{CPU} = B \\cdot t$$\n\n处理单个事件消耗 $c$ 秒的 CPU 时间。设 $N$ 为使用可用 CPU 时间 $T_{CPU}$ 可以处理的总事件数。$N$、$T_{CPU}$ 和 $c$ 之间的关系是：\n$$T_{CPU} = N \\cdot c$$\n\n将来自 CPU 配额的 $T_{CPU}$ 表达式代入，我们得到：\n$$B \\cdot t = N \\cdot c$$\n\n现在我们可以解出 $N$，即在墙上时钟时间间隔 $t$ 内处理的总事件数：\n$$N = \\frac{B \\cdot t}{c}$$\n\n平均服务率 $\\mu$ 定义为单位墙上时钟时间内处理的事件数。因此，我们可以通过将处理的事件数 $N$ 除以墙上时钟时间间隔的持续时间 $t$ 来计算 $\\mu$：\n$$\\mu = \\frac{N}{t}$$\n\n代入 $N$ 的表达式：\n$$\\mu = \\frac{\\frac{B \\cdot t}{c}}{t}$$\n\n通过约掉分子和分母中的项 $t$ 来简化表达式，得到长期平均服务率：\n$$\\mu = \\frac{B}{c}$$\n\n这个表达式的单位是一致的。参数 $B$ 是无量纲的（CPU 时间秒数 / 墙上时钟时间秒数），而 $c$ 的单位是秒/事件。因此，$\\mu$ 的单位是：\n$$\\frac{[\\text{dimensionless}]}{[\\text{seconds} / \\text{event}]} = \\frac{1}{\\text{seconds} / \\text{event}} = \\frac{\\text{events}}{\\text{second}}$$\n这证实了我们的表达式代表一个事件速率，符合要求。\n\n根据问题的稳定性判据，如果到达率 $\\lambda$ 不大于服务率 $\\mu$，队列将不会无限增长（因此在长期内不会丢弃事件）。因此，最大可持续到达率 $\\lambda_{\\max}$ 等于系统的最大服务率 $\\mu$。\n$$\\lambda_{\\max} = \\mu$$\n\n因此，最大可持续事件到达率的封闭形式表达式为：\n$$\\lambda_{\\max} = \\frac{B}{c}$$\n该表达式代表了服务器的基本容量限制，由其 CPU 分配比例和每个事件的处理成本决定。", "answer": "$$\\boxed{\\frac{B}{c}}$$", "id": "3621630"}, {"introduction": "异步I/O的核心优势在于其能够重叠计算和I/O等待时间，从而隐藏延迟。这个练习将探讨如何精确计算所需的并发I/O操作数量，以确保CPU核心始终有任务可处理，从而使系统达到计算瓶颈而非I/O瓶颈。掌握这一原理对于设计真正高效的异步应用至关重要。[@problem_id:3621649]", "problem": "考虑一个使用异步输入/输出 (AIO) 接口处理独立请求流的应用程序。每个请求都遵循一个两阶段流水线：一个 I/O 阶段和一个计算阶段。I/O 阶段包括向 AIO 子系统提交读取操作并等待其完成；计算阶段包括对数据执行确定性的计算。假设如下：\n- AIO 子系统最多可并发调度 $k$ 个未完成的 I/O 操作，每个操作的延迟是确定性的，为 $l$，并且在这种并发水平下没有吞吐量下降或排队延迟。\n- 计算阶段在一台拥有 $m$ 个相同中央处理器 (CPU) 核心的机器上运行，每个核心一次能处理一个请求。每个请求的计算时间是确定性的，等于 $c$。\n- 除了延迟 $l$ 之外，调度开销、数据传输带宽限制、内存限制和竞争效应都可以忽略不计。系统达到一个稳定状态，其中到达计算阶段的速率等于 I/O 操作的完成速率。\n\n仅使用操作系统和排队论的第一性原理——特别是吞吐量的基本定义和 Little’s law——推导出最小整数并发级别 $k^{\\*}$ 的精确闭式表达式，以确保 CPU 计算阶段在稳定状态下永远不会等待 I/O 完成。换句话说，找到最小的 $k^{\\*}$，使得 I/O 延迟被完全隐藏，且长期吞吐量受计算阶段而非 I/O 阶段的限制。请用符号表达式表示你的答案，该表达式应包含 $m$、$c$ 和 $l$。最终答案必须是单一的解析表达式；不要提供不等式或方程式。", "solution": "目标是找到最小整数并发级别，表示为 $k^{\\*}$，使得系统的吞吐量受计算阶段而非 I/O 阶段的限制。这意味着必须有持续供应的已完成的 I/O 请求可用于计算核心，以确保它们永远不会因等待数据而空闲。\n\n让 $\\lambda$ 代表系统的稳态吞吐量，定义为单位时间内处理的请求数。\n\n首先，我们确定计算阶段的最大可能吞吐量 $\\lambda_{\\text{compute}}$。计算阶段有 $m$ 个相同的核心，每个核心处理单个请求需要时间 $c$。单个核心的处理速率是每单位时间 $\\frac{1}{c}$ 个请求。由于这些核心并行处理独立的请求，它们的容量相加。因此，计算阶段的最大吞吐量是：\n$$\n\\lambda_{\\text{compute}} = m \\times \\frac{1}{c} = \\frac{m}{c}\n$$\n\n接下来，我们确定 I/O 阶段的最大可能吞吐量 $\\lambda_{\\text{I/O}}$。问题指导我们使用 Little's Law，该定律关联了稳定系统中的平均项目数 ($N$)、平均到达/离开速率（吞吐量，$\\lambda$) 以及项目在系统中花费的平均时间 ($T$)：\n$$\nN = \\lambda T\n$$\n在我们的 AIO 子系统的背景下：\n- $N$ 是并发的、未完成的 I/O 操作的数量。为了最大化 I/O 吞吐量，我们必须维持系统允许的尽可能多的并发操作，即 $k$ 个。因此，我们在系统容量处进行分析，此时 $N = k$。\n- $T$ 是请求在 I/O 阶段花费的时间，即确定性延迟 $l$。\n- $\\lambda$ 是 I/O 阶段的吞吐量，即 $\\lambda_{\\text{I/O}}$。\n\n将 Little's Law 应用于 I/O 子系统：\n$$\nk = \\lambda_{\\text{I/O}} \\cdot l\n$$\n求解 I/O 吞吐量可得：\n$$\n\\lambda_{\\text{I/O}} = \\frac{k}{l}\n$$\n\n计算阶段是瓶颈且从不等待 I/O 的条件意味着 I/O 阶段必须能够以至少与计算阶段处理请求的速率一样大的速率供应请求。这可以转化为以下不等式：\n$$\n\\lambda_{\\text{I/O}} \\ge \\lambda_{\\text{compute}}\n$$\n\n将 $\\lambda_{\\text{I/O}}$ 和 $\\lambda_{\\text{compute}}$ 的表达式代入不等式：\n$$\n\\frac{k}{l} \\ge \\frac{m}{c}\n$$\n\n我们正在寻找满足此条件的最小整数并发级别 $k^{\\*}$。为了找到 $k$，我们重新排列不等式：\n$$\nk \\ge \\frac{m \\cdot l}{c}\n$$\n\n由于 $k$ 必须是整数，满足此不等式的最小整数值是右侧的向上取整。向上取整函数 $\\lceil x \\rceil$ 给出大于或等于 $x$ 的最小整数。因此，最小整数并发级别 $k^{\\*}$ 是：\n$$\nk^{*} = \\left\\lceil \\frac{m \\cdot l}{c} \\right\\rceil\n$$\n该表达式表示在一次 I/O 操作完成所需的时间 ($l$) 内，为覆盖可完成的总计算工作 ($m/c$)，I/O 系统中必须“在途”的请求数量。向上取整函数正确处理了 $k^{\\*}$ 必须是整数的要求。", "answer": "$$\n\\boxed{\\left\\lceil \\frac{m \\cdot l}{c} \\right\\rceil}\n$$", "id": "3621649"}, {"introduction": "在掌握了性能优化之后，我们必须关注一个更微妙但同样重要的问题：正确性。这个练习揭示了一个常见的陷阱，即在同一个文件上混合使用高级缓冲I/O（如C语言的`FILE*`）和底层异步系统调用。通过这个案例，你将理解为什么这种做法会导致程序状态不一致，并可能引发数据损坏或丢失，从而学会如何编写更安全、更健壮的I/O代码。[@problem_id:3621602]", "problem": "一个程序同时使用 C 标准输入/输出库流和异步接口来操作一个普通文件。该文件通过单个打开文件描述被打开一次，产生一个文件描述符 $fd$，然后通过 $fdopen$ 将其包装成一个 C 标准输入/输出流 $FILE$。假设以下广泛接受且经过充分测试的基本事实和定义成立：\n- 操作系统内核为每个打开文件描述维护一个当前文件偏移量 $o$，该偏移量会因顺序读写而推进。\n- 在使用共享文件位置的描述符上调用系统调用 $read$ 会从当前偏移量 $o$ 读取数据，并将 $o$ 增加实际读取的字节数。\n- 调用系统调用 $pread$ 会从一个显式偏移量读取数据，而不会改变 $o$。\n- 函数 $dup$ 会产生一个新的文件描述符，它引用相同的打开文件描述，因此共享当前偏移量 $o$。\n- C 标准输入/输出流 $FILE$ 维护一个用户空间缓冲区（假设容量 $B = 8192$ 字节）以分摊系统调用的开销。函数 $fread$ 可以通过一次或多次底层的 $read$ 调用来填充此缓冲区，然后从此缓冲区服务于应用程序的读取请求，直到缓冲区耗尽才再次查询内核。$FILE$ 对象关于要传递的下一个字节的内部概念独立于内核的页面缓存，并取决于先前获取的数据和程序后续从流中读取的操作。\n- 在 Linux $io\\_uring$ 中，以偏移量 $-1$ 提交的操作会使用并推进共享文件位置 $o$（文件位置语义）。相反，$POSIX$ 异步输入/输出操作（如 $aio\\_read$）使用显式偏移量（来自 $aiocb \\rightarrow aio\\_offset$）并且不会改变 $o$。\n- 除非程序强制排序，否则异步操作可能在相对于 $fread$ 调用的任何时间完成。\n\n考虑一个大小为 $S = 16384$ 字节的文件，其中包含确定的字节 $b[0..S-1]$。程序使用 $fread$ 在 $FILE$ 流上执行顺序读取，但也在同一个底层文件上提交异步操作。假设 $fread$ 最初通过在偏移量 $o = 0$ 处执行一次底层 $read$ 操作读取 $4096$ 字节来填充其缓冲区，然后向调用者返回 $2048$ 字节，在用户空间缓冲区中留下 $2048$ 字节未读。在返回这 $2048$ 字节后，程序立即提交一个异步操作。异步操作完成后，程序再次调用 $fread$，期望接下来的 $2048$ 字节是序列 $b[2048..4095]$。\n\n以下哪种情况可能导致 $fread$ 的状态与内核关于文件位置和缓冲数据的概念变得不同步，从而使得后续的 $fread$ 调用要么跳过字节，要么重复字节，或者返回一个不等于下一个连续字节序列 $b[2048..4095]$ 的序列？选择所有适用的选项。\n\nA. 程序在 $fd$ 上提交一个 $io\\_uring$ 读操作 $IORING\\_OP\\_READ$，使用偏移量 $-1$ 读取 $4096$ 字节到一个不相关的内存缓冲区中。该异步读取在下一次调用 $fread$ 之前完成。\n\nB. 程序在 $fd$ 上提交一个 $POSIX$ 异步输入/输出 $aio\\_read$ 操作，其中 $aiocb \\rightarrow aio\\_offset = 4096$，以读取 $4096$ 字节到一个不相关的内存缓冲区中。该异步读取在下一次调用 $fread$ 之前完成。\n\nC. 程序在 $fd$ 上提交一个 $io\\_uring$ 写操作 $IORING\\_OP\\_WRITE$，使用偏移量 $-1$ 在当前文件位置 $o$ 写入 $4096$ 字节。写入的数据与 $fread$ 接下来要读取的区域重叠。该异步写入在下一次调用 $fread$ 之前完成。\n\nD. 程序首先通过 $fd2 = dup(fd)$ 复制描述符，然后在 $fd2$ 上提交一个 $io\\_uring$ 读操作 $IORING\\_OP\\_READ$，使用偏移量 $-1$ 读取 $4096$ 字节。该异步读取在下一次调用 $fread$ 之前完成。\n\nE. 程序第二次打开相同的路径名，获得一个新的、独立的文件描述符 $fd3$（不是通过 $dup$），然后在 $fd3$ 上提交一个等效于 $pread$ 的异步读取操作，从偏移量 $4096$ 读取 $4096$ 字节。该异步读取在下一次调用 $fread$ 之前完成。\n\n请根据上述基本定义和异步完成的并发特性给出你的推理，重点关注在每种情况下，$fread$ 的用户空间缓冲区状态和内核的打开文件描述偏移量 $o$ 是如何以及为何会发生偏离，以及 $fread$ 所看到的内核页面缓存内容是否可能与程序对 $b[0..S-1]$ 的预期顺序视图不同。不要依赖于库特定的未文档化行为；请根据所述的标准化语义进行推理。", "solution": "### 推导与选项分析\n\n问题的核心在于管理与文件描述符 $fd$ 和 `FILE*` 流共享的打开文件描述相关联的单个内核文件偏移量 $o$。如果外部操作在 C 标准库不知情的情况下修改了 $o$，就会发生不同步。\n\n**初始状态分析：**\n1.  程序第一次调用 $fread$。`FILE*` 流的缓冲区是空的。\n2.  `FILE*` 流的实现发出一个系统调用 `read(fd, internal_buffer, 4096)`，从初始文件偏移量 $o = 0$ 开始。\n3.  这个 `read` 成功。内核读取 $4096$ 字节 ($b[0..4095]$) 并将文件偏移量推进到 $o = 4096$。\n4.  `FILE*` 流的缓冲区现在填充了 $b[0..4095]$。\n5.  $fread$ 将前 $2048$ 字节 ($b[0..2047]$) 复制到应用程序的缓冲区并返回。\n6.  在此时，即提交异步操作之前，状态如下：\n    *   内核文件偏移量：$o = 4096$。\n    *   `FILE*` 流的缓冲区：包含 $b[0..4095]$。\n    *   `FILE*` 流的内部位置：指向其缓冲区中下一个要提供服务的字节，这对应于文件内容在偏移量 $2048$ 处。缓冲区中还剩下 $2048$ 字节 ($b[2048..4095]$)。\n    *   `FILE*` 流的期望：它已经消耗了直到偏移量 $4095$ 的数据。它期望下一次内核 `read` 将在偏移量 $4096$ 处发生。\n\n问题在于确定以下哪种异步操作，在下一次填充缓冲区的 `read` 之前完成，会改变内核偏移量 $o$，从而违背 `FILE*` 流的期望。\n\n**选项 A: 程序在 $fd$ 上提交一个 $io\\_uring$ 读操作 $IORING\\_OP\\_READ$，使用偏移量 $-1$ 读取 $4096$ 字节到一个不相关的内存缓冲区中。该异步读取在下一次调用 $fread$ 之前完成。**\n\n根据所提供的定义，`offset = -1` 的 $io\\_uring$ 操作会使用并推进共享文件位置 $o$。该操作在 $fd$ 上提交，而 $fd$ 使用共享的打开文件描述。在此操作之前，$o = 4096$。因此，异步读取将从偏移量 $4096$ 开始，并读取 $4096$ 字节。完成后，它将文件偏移量推进 $4096$。新的内核偏移量将是 $o = 4096 + 4096 = 8192$。`FILE*` 流不知道这一变化。当其缓冲区最终耗尽时（在提供了缓冲的 $b[2048..4095]$ 之后），它将发出一个 `read` 系统调用，期望从偏移量 $4096$ 开始获取数据。然而，`read` 将从当前偏移量 $o=8192$ 开始，导致它读取 $b[8192..]$，实际上跳过了字节 $b[4096..8191]$。这是一种导致数据跳过的不同步。\n\n*结论*：**正确**。\n\n**选项 B: 程序在 $fd$ 上提交一个 $POSIX$ 异步输入/输出 $aio\\_read$ 操作，其中 $aiocb \\rightarrow aio\\_offset = 4096$，以读取 $4096$ 字节到一个不相关的内存缓冲区中。该异步读取在下一次调用 $fread$ 之前完成。**\n\n问题指出，$POSIX$ $AIO$ 操作（如 $aio\\_read$）使用显式偏移量（这里是 $4096$）并且**不改变**共享文件偏移量 $o$。这种类型的 I/O 类似于 `pread`。该操作将读取字节 $b[4096..8191]$，但内核文件偏移量 $o$ 将保持在 $4096$ 不变。当 `FILE*` 流稍后发出其填充缓冲区的 `read` 时，它将正确地从 $o=4096$ 开始。没有发生文件偏移量的不同步。\n\n*结论*：**错误**。\n\n**选项 C: 程序在 $fd$ 上提交一个 $io\\_uring$ 写操作 $IORING\\_OP\\_WRITE$，使用偏移量 $-1$ 在当前文件位置 $o$ 写入 $4096$ 字节。写入的数据与 $fread$ 接下来要读取的区域重叠。该异步写入在下一次调用 $fread$ 之前完成。**\n\n与读操作类似，`offset = -1` 的 $io\\_uring$ 写操作会使用并推进共享文件位置 $o$。在此操作之前，$o = 4096$。`io_uring` 写操作将从偏移量 $4096$ 开始，并将偏移量推进到 $o = 4096 + 4096 = 8192$。这会导致与选项 A 中相同的文件偏移量不同步，从而导致未来的 `fread` 跳过数据。此外，此操作修改了范围 $[4096, 8191]$ 内的文件内容，这意味着未来 `fread` 最终读取的数据将不来自原始序列 $b$，这是另一种形式的不同步。就跳过字节而言，失败的主要原因是 $o$ 的修改。\n\n*结论*：**正确**。\n\n**选项 D: 程序首先通过 $fd2 = dup(fd)$ 复制描述符，然后在 $fd2$ 上提交一个 $io\\_uring$ 读操作 $IORING\\_OP\\_READ$，使用偏移量 $-1$ 读取 $4096$ 字节。该异步读取在下一次调用 $fread$ 之前完成。**\n\n$dup$ 的定义指出，新的文件描述符 ($fd2$) 引用与原始描述符 ($fd$) **相同的打开文件描述**。这意味着它们共享所有文件状态标志，以及至关重要的当前文件偏移量 $o$。因此，在 $fd2$ 上执行一个修改 $o$ 的操作，与在 $fd$ 上执行该操作是无法区分的。此场景在功能上与选项 A 相同。$fd2$ 上的 `io_uring` 读操作将从 $o = 4096$ 开始，并将其推进到 $o = 8192$。这会导致不同步，并将导致未来的 `fread` 跳过数据。\n\n*结论*：**正确**。\n\n**选项 E: 程序第二次打开相同的路径名，获得一个新的、独立的文件描述符 $fd3$（不是通过 $dup$），然后在 $fd3$ 上提交一个等效于 $pread$ 的异步读取操作，从偏移量 $4096$ 读取 $4096$ 字节。该异步读取在下一次调用 $fread$ 之前完成。**\n\n再次使用 `open()` 打开文件路径会创建一个**新的、独立的**打开文件描述。这个新的描述有自己的文件偏移量，与 $fd$ 关联的偏移量 $o$ 完全分离。我们将 $fd3$ 的偏移量称为 $o_3$。在 $fd3$ 上的操作将使用和修改 $o_3$，但对 $o$ 没有影响。此外，指定的操作是“等效于 $pread$”，它使用一个显式偏移量 ($4096$)，并且无论如何都不会修改其自身的文件偏移量 ($o_3$)。与 $fd$ 关联的内核文件偏移量 $o$ 保持为 $4096$，没有发生不同步。\n\n*结论*：**错误**。", "answer": "$$\\boxed{ACD}$$", "id": "3621602"}]}