{"hands_on_practices": [{"introduction": "在探究复杂的死锁场景之前，让我们从最基础的部分开始。第一个练习将挑战你识别在资源分配图中形成死锁环路所需的最基本条件。通过确定造成死锁所需的最少违规操作数量 [@problem_id:3677426]，你将具体理解“循环等待”条件在图中是如何体现的，为所有死锁分析打下坚实的基础。", "problem": "考虑一个系统，它有两种资源类型，表示为 $R_a$ 和 $R_b$，每种类型只有一个实例。系统中有 $n$ 个进程，表示为 $P_1, P_2, \\dots, P_n$，它们可能需要以嵌套方式获取这两种资源。系统规定了一个全局锁顺序：任何需要两种资源的进程都必须先获取 $R_a$ 再获取 $R_b$，我们用锁顺序 $R_a \\rightarrow R_b$ 来表示。资源分配图 (RAG) 定义如下：对于每个进程 $P_i$ 和资源 $R_x$，一条有向边 $P_i \\rightarrow R_x$ 表示 $P_i$ 正在请求 $R_x$，而一条有向边 $R_x \\rightarrow P_i$ 表示 $R_x$ 已分配给 $P_i$。假设死锁的四个常见必要条件均已满足：互斥、持有并等待、不可抢占和循环等待。\n\n在时间 $t$，系统处于以下快照状态：\n- 进程 $P_1$ 持有 $R_a$（存在一条分配边 $R_a \\rightarrow P_1$），并且在不释放 $R_a$ 的情况下，遵循全局锁顺序请求 $R_b$（存在一条请求边 $P_1 \\rightarrow R_b$）。\n- 恰好有一个进程 $P_k$ 违反了全局锁顺序。具体来说，$P_k$ 持有 $R_b$（存在一条分配边 $R_b \\rightarrow P_k$），并且在不释放 $R_b$ 的情况下请求 $R_a$（存在一条请求边 $P_k \\rightarrow R_a$）。\n- 所有其他进程，如果需要这两种资源，都遵守锁顺序 $R_a \\rightarrow R_b$。\n\n从资源分配图的核心定义以及一个众所周知的特性（即在单实例情况下，RAG 中的环是死锁的充分必要条件）出发，为时间 $t$ 的快照构建逻辑 RAG，并确定在这 $n$ 个进程中，要使 RAG 包含一个意味着此双资源系统中存在死锁的有向环，所需的最小锁顺序违规次数，记为 $v_{\\min}$。请用一个整数表示 $v_{\\min}$ 的值。无需四舍五入，也无需单位。", "solution": "问题要求在一个拥有两种单实例资源 $R_a$ 和 $R_b$ 的系统中，造成死锁所需的最小锁顺序违规次数 $v_{\\min}$。\n\n首先，我们建立理论基础。该系统由一组进程 $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$ 和一组资源类型 $\\mathcal{R} = \\{R_a, R_b\\}$ 组成。每种资源类型只有一个实例。系统状态可以通过资源分配图 (RAG) 来建模，它是一个有向图 $G = (V, E)$。顶点集为 $V = \\mathcal{P} \\cup \\mathcal{R}$。边集 $E$ 由两种类型组成：\n1.  如果进程 $P_i$ 正在等待资源类型 $R_x$ 的一个实例，则存在一条请求边 $P_i \\rightarrow R_x$。\n2.  如果资源类型 $R_x$ 的一个实例已分配给进程 $P_i$，则存在一条分配边 $R_x \\rightarrow P_i$。\n\n问题陈述中提到，死锁的四个必要条件（互斥、持有并等待、不可抢占和循环等待）均已满足。对于拥有单实例资源的系统，RAG 中存在环是发生死锁的充分必要条件。我们的任务是找出要形成这样一个环，必须违反既定锁顺序 $R_a \\rightarrow R_b$ 的最小进程数量。\n\n我们来分析形成环的条件。RAG 中的环必须同时涉及进程和资源。由于只有两种资源类型，环必须在进程和资源之间交替。最简单的可能环会涉及两个进程（例如 $P_i$ 和 $P_j$）以及两种资源（$R_a$ 和 $R_b$）。这样的环结构为 $P_i \\rightarrow R_x \\rightarrow P_j \\rightarrow R_y \\rightarrow P_i$，其中 $R_x, R_y \\in \\{R_a, R_b\\}$ 且 $R_x \\neq R_y$。\n\n不失一般性，我们假设 $R_x = R_a$ 且 $R_y = R_b$。那么环就是 $P_i \\rightarrow R_a \\rightarrow P_j \\rightarrow R_b \\rightarrow P_i$。\n我们来解释这个环中的边：\n-   $P_i \\rightarrow R_a$：进程 $P_i$ 正在请求资源 $R_a$。\n-   $R_a \\rightarrow P_j$：资源 $R_a$ 被进程 $P_j$ 持有。\n-   $P_j \\rightarrow R_b$：进程 $P_j$ 正在请求资源 $R_b$。\n-   $R_b \\rightarrow P_i$：资源 $R_b$ 被进程 $P_i$ 持有。\n\n总结环中涉及的两个进程的状态：\n-   进程 $P_i$ 持有 $R_b$ 并请求 $R_a$。\n-   进程 $P_j$ 持有 $R_a$ 并请求 $R_b$。\n\n现在，我们根据全局锁顺序规则来评估这个状态，该规则要求任何需要两种资源的进程都必须先获取 $R_a$ 再获取 $R_b$。\n-   进程 $P_j$ 的行为与此规则一致。它获取了 $R_a$ 现在请求 $R_b$。这是一个有效的操作序列。\n-   然而，进程 $P_i$ 持有 $R_b$ 并请求 $R_a$。要处于这种状态，它必须先获取了 $R_b$。随后请求 $R_a$ 的行为违反了 $R_a \\rightarrow R_b$ 的锁顺序。\n\n此分析表明，形成一个双进程、双资源的环，*要求* 其中一个进程违反全局锁顺序。如果两个进程都遵守锁顺序，一个持有 $R_b$ 的进程将永远不会请求 $R_a$，从而打破了形成循环等待条件的可能性。因此，违规次数必须至少为 $1$。我们已经确定 $v_{\\min} \\geq 1$。\n\n接下来，我们必须确定是否可能在只有一次违规的情况下发生死锁。问题陈述提供了一个时间 $t$ 的特定快照，使我们能够测试这一点。\n-   进程 $P_1$ 持有 $R_a$ 并请求 $R_b$。这对应于边 $R_a \\rightarrow P_1$ 和 $P_1 \\rightarrow R_b$。如前所述，$P_1$ 遵守了锁顺序协议。\n-   进程 $P_k$ 持有 $R_b$ 并请求 $R_a$。这对应于边 $R_b \\rightarrow P_k$ 和 $P_k \\rightarrow R_a$。这被明确说明是唯一违反锁顺序的行为。\n\n让我们为这个特定配置构建 RAG。该图包含以下有向边序列：$P_1 \\rightarrow R_b \\rightarrow P_k \\rightarrow R_a \\rightarrow P_1$。\n\n这个序列在 RAG 中构成了一个闭合的有向路径，即一个环。涉及的顶点和边如下：\n-   $P_1$ 请求 $R_b$（边 $P_1 \\rightarrow R_b$）。\n-   $R_b$ 被 $P_k$ 持有（边 $R_b \\rightarrow P_k$）。\n-   $P_k$ 请求 $R_a$（边 $P_k \\rightarrow R_a$）。\n-   $R_a$ 被 $P_1$ 持有（边 $R_a \\rightarrow P_1$）。\n\n由于 RAG 中存在一个环，并且资源是单实例的，因此存在一个涉及进程 $P_1$ 和 $P_k$ 的死锁。这个死锁状态是在只有一个进程 $P_k$ 违反全局锁顺序的情况下达成的。\n\n因此，我们已经证明：\n1.  形成死锁环至少需要一次锁顺序违规 ($v_{\\min} \\geq 1$)。\n2.  恰好一次锁顺序违规足以形成死锁环 ($v_{\\min} \\leq 1$)。\n\n结合这两点，要使 RAG 包含一个有向环，所需的最小锁顺序违规次数恰好是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3677426"}, {"introduction": "我们已经了解了死锁环路的基本结构，现在让我们将这些知识应用于一个著名的并发问题：哲学家就餐问题。这个练习使用资源分配图来为哲学家和叉子建模，让你能够直观地看到死锁为何会发生。更重要的是，通过对比一种成功的预防策略（层次资源排序）和一种有缺陷的循环方法 [@problem_id:3677360]，它展示了资源排序作为一种实用的死锁预防策略的强大威力。", "problem": "考虑一个按如下方式建模的“哲学家就餐”问题变体。有 $n$ 个哲学家 $P_1, P_2, \\dots, P_n$ 围绕一张圆桌而坐，还有 $n$ 把叉子 $R_1, R_2, \\dots, R_n$。叉子 $R_j$ 放置在哲学家 $P_j$ 和 $P_{j+1}$ 之间（索引对 $n$ 取模，因此 $R_n$ 在 $P_n$ 和 $P_1$ 之间）。每位哲学家 $P_i$ 需要两把叉子 $R_i$ 和 $R_{i+1}$ 才能就餐。假设每种资源类型（每把叉子）只有一个实例。根据资源分配图（RAG）的标准定义，构建一个包含进程顶点 $P_i$ 和资源顶点 $R_j$ 的图，其中请求边为 $P_i \\rightarrow R_j$，分配边为 $R_j \\rightarrow P_i$。\n\n一个系统策略对资源类型施加了严格全序：$R_1 \\prec R_2 \\prec \\cdots \\prec R_n$。每位哲学家必须按照 $\\prec$ 的严格递增顺序请求叉子：对哲学家 $P_i$ 而言，这意味着先请求 $\\min_{\\prec}\\{R_i, R_{i+1}\\}$，然后再请求 $\\max_{\\prec}\\{R_i, R_{i+1}\\}$。将此策略与单实例资源类型在RAG中形成环路的直观原因进行比较，并评估以下陈述。此外，考虑一个假设的变体策略，其中资源类型优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，并且哲学家们沿着这个循环的方向请求。\n\n以下哪些陈述是正确的？\n\nA. 在严格全序 $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$ 以及哲学家按递增顺序请求的约束下，资源分配图不能包含有向环；因此对于单实例叉子，死锁是不可能发生的。\n\nB. 即使有严格全序和递增顺序请求，在导出的等待图（wait-for graph）中仍然可能出现进程间的有向环，因此对于单实例叉子，死锁仍然是可能的。\n\nC. 严格全序消除了“占有并等待”（hold-and-wait）条件，因为哲学家被禁止在等待一个更高序的叉子时占有一个更低序的叉子。\n\nD. 如果资源类型的优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，那么沿着这个循环请求将无法阻止资源分配图中出现有向环。\n\nE. 严格全序保证了无论调度策略如何都不会发生饿死（starvation），因此每位哲学家最终都能获得两把叉子并就餐。", "solution": "问题描述了一个“哲学家就餐”问题的变体，并要求在两种不同的资源分配策略下，评估关于死锁和饿死的几个陈述。该问题定义明确，并基于操作系统理论的原理。\n\n首先，让我们根据所给的陈述来形式化系统组件和策略。\n- **进程**：有 $n$ 个哲学家，表示为进程集合 $\\mathcal{P} = \\{P_1, P_2, \\dots, P_n\\}$。\n- **资源**：有 $n$ 把叉子，表示为资源类型集合 $\\mathcal{R} = \\{R_1, R_2, \\dots, R_n\\}$。每种资源类型只有一个实例。\n- **资源需求**：哲学家 $P_i$ 需要两把叉子 $R_i$ 和 $R_{i+1}$，其中索引对 $n$ 取模（因此 $P_n$ 需要 $R_n$ 和 $R_1$）。\n- **死锁条件**：对于单实例资源类型，死锁存在的充要条件是资源分配图（RAG）中存在有向环。RAG中的环是一个交替出现的进程和资源的序列，例如 $P_a \\rightarrow R_x \\rightarrow P_b \\rightarrow R_y \\rightarrow \\dots \\rightarrow P_a$，表示一个等待进程的循环链。\n\n我们将分析两种策略。\n\n**策略1：严格全序**\n\n第一种策略对资源类型施加了严格全序：$R_1 \\prec R_2 \\prec \\cdots \\prec R_n$。哲学家必须根据此优先级关系按严格递增的顺序请求他们所需的叉子。\n\n我们来分析每位哲学家 $P_i$ 的请求顺序：\n- 对于任何哲学家 $P_i$（其中 $i \\in \\{1, 2, \\dots, n-1\\}$），所需的叉子是 $R_i$ 和 $R_{i+1}$。根据全序，$R_i \\prec R_{i+1}$。因此，$P_i$ 必须先请求 $R_i$，并且只有在获得 $R_i$ 之后才能请求 $R_{i+1}$。\n- 对于哲学家 $P_n$，所需的叉子是 $R_n$ 和 $R_1$。根据全序，$R_1 \\prec R_n$。因此，$P_n$ 必须先请求 $R_1$，并且只有在获得 $R_1$ 之后才能请求 $R_n$。\n\n这个策略是一种标准的死锁预防技术，称为分层资源分配。它通过打破循环等待条件出现的可能性来预防死锁。为了证明这一点，我们用反证法，假设RAG中存在一个环。一个环必须具有 $P_{i_1} \\rightarrow R_{j_1} \\rightarrow P_{i_2} \\rightarrow R_{j_2} \\rightarrow \\dots \\rightarrow P_{i_k} \\rightarrow R_{j_k} \\rightarrow P_{i_1}$ 的形式。\n\n- 边 $P_{i_m} \\rightarrow R_{j_m}$ 表示进程 $P_{i_m}$ 正在请求资源 $R_{j_m}$。\n- 边 $R_{j_{m-1}} \\rightarrow P_{i_m}$ 表示进程 $P_{i_m}$ 持有资源 $R_{j_{m-1}}$（其中索引 $m-1$ 对 $k$ 取模）。\n\n因此，对于环中的任何进程 $P_{i_m}$，它持有一个资源 $R_{j_{m-1}}$ 并正在请求另一个资源 $R_{j_m}$。该策略规定，一个进程只能请求比其当前持有的任何资源次序更高的资源。因此，对于环中的每一步，必须是所持有的资源次序低于所请求的资源。\n- $P_{i_1}$ 持有 $R_{j_k}$ 并请求 $R_{j_1} \\implies R_{j_k} \\prec R_{j_1}$。\n- $P_{i_2}$ 持有 $R_{j_1}$ 并请求 $R_{j_2} \\implies R_{j_1} \\prec R_{j_2}$。\n- ...\n- $P_{i_k}$ 持有 $R_{j_{k-1}}$ 并请求 $R_{j_k} \\implies R_{j_{k-1}} \\prec R_{j_k}$。\n\n将这些不等式串联起来得到 $R_{j_k} \\prec R_{j_1} \\prec R_{j_2} \\prec \\cdots \\prec R_{j_{k-1}} \\prec R_{j_k}$。这导致了 $R_{j_k} \\prec R_{j_k}$ 的陈述，它与严格序的非自反性相矛盾。因此，RAG中不可能存在环。\n\n**策略2：循环优先级**\n\n第二种假设的策略施加了一个循环优先级：$R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$。哲学家们沿着这个循环的方向请求叉子。\n\n我们来分析每位哲学家 $P_i$ 的请求顺序：\n- 对于任何哲学家 $P_i$（其中 $i \\in \\{1, 2, \\dots, n-1\\}$），所需的叉子是 $R_i$ 和 $R_{i+1}$。循环优先级是 $R_i \\rightarrow R_{i+1}$，因此 $P_i$ 先请求 $R_i$，然后请求 $R_{i+1}$。\n- 对于哲学家 $P_n$，所需的叉子是 $R_n$ 和 $R_1$。循环优先级是 $R_n \\rightarrow R_1$，因此 $P_n$ 先请求 $R_n$，然后请求 $R_1$。\n\n这种设置导致了经典的哲学家就餐死锁场景。考虑所有哲学家同时执行其协议第一步的情况：\n1.  $P_1$ 请求并获得 $R_1$。\n2.  $P_2$ 请求并获得 $R_2$。\n3.  ...\n4.  $P_n$ 请求并获得 $R_n$。\n\n此时，每位哲学家都持有一把叉子，并准备请求他们的第二把叉子。\n- $P_1$ 持有 $R_1$ 并请求 $R_2$，而 $R_2$ 被 $P_2$ 持有。所以 $P_1$ 等待。\n- $P_2$ 持有 $R_2$ 并请求 $R_3$，而 $R_3$ 被 $P_3$ 持有。所以 $P_2$ 等待。\n- ...\n- $P_{n-1}$ 持有 $R_{n-1}$ 并请求 $R_n$，而 $R_n$ 被 $P_n$ 持有。所以 $P_{n-1}$ 等待。\n- $P_n$ 持有 $R_n$ 并请求 $R_1$，而 $R_1$ 被 $P_1$ 持有。所以 $P_n$ 等待。\n\n这造成了一个循环等待条件。RAG将包含环路：\n$P_1 \\rightarrow R_2 \\rightarrow P_2 \\rightarrow R_3 \\rightarrow \\cdots \\rightarrow P_n \\rightarrow R_1 \\rightarrow P_1$。\n因此，该策略未能阻止死锁。\n\n现在，我们来评估每个陈述。\n\n**A. 在严格全序 $R_1 \\prec R_2 \\prec \\cdots \\prec R_n$ 以及哲学家按递增顺序请求的约束下，资源分配图不能包含有向环；因此对于单实例叉子，死锁是不可能发生的。**\n我们对策略1的分析证明了资源的严格全序可以防止在RAG中形成环路。对于单实例资源，RAG中没有环是无死锁的充分条件。\n结论：**正确**。\n\n**B. 即使有严格全序和递增顺序请求，在导出的等待图（wait-for graph）中仍然可能出现进程间的有向环，因此对于单实例叉子，死锁仍然是可能的。**\n等待图（WFG）中，如果进程 $P_i$ 正在等待由进程 $P_j$ 持有的资源，则存在一条从 $P_i$ 到 $P_j$ 的边。对于单实例资源类型，WFG中的环等价于RAG中的环。正如对陈述A的分析所确立的，严格全序策略可以防止RAG中出现环。因此，它也防止了WFG中出现环。该陈述声称环路可能出现是错误的。\n结论：**不正确**。\n\n**C. 严格全序消除了“占有并等待”（hold-and-wait）条件，因为哲学家被禁止在等待一个更高序的叉子时占有一个更低序的叉子。**\n“占有并等待”条件是死锁的四个必要条件之一，它指出一个进程必须在等待获取额外资源时至少持有一个资源。严格全序策略并没有消除这个条件。例如，哲学家 $P_1$ 请求 $R_1$，如果被授予，他将*占有* $R_1$ 同时*等待* $R_2$。该策略构建了“占有并等待”的条件，但并未消除它。所给出的理由也是有缺陷的；该策略要求哲学家在等待一个更高序的叉子时持有一个更低序的叉子，而不是禁止它。\n结论：**不正确**。\n\n**D. 如果资源类型的优先级是循环的 $R_1 \\rightarrow R_2 \\rightarrow \\cdots \\rightarrow R_n \\rightarrow R_1$，那么沿着这个循环请求将无法阻止资源分配图中出现有向环。**\n我们对策略2的分析表明，循环优先级允许出现这样一种情况：每位哲学家都获得一把叉子，并等待循环中的下一把，从而导致所有 $n$ 位哲学家之间的循环等待。这种循环依赖在RAG中表现为一个环，导致死锁。因此，该策略未能阻止有向环的出现。\n结论：**正确**。\n\n**E. 严格全序保证了无论调度策略如何都不会发生饿死（starvation），因此每位哲学家最终都能获得两把叉子并就餐。**\n无死锁并不意味着无饿死。饿死，或称无限期推迟，是指一个进程即使在资源可用的情况下也反复被拒绝访问资源。虽然全序策略可以防止死锁，但哲学家仍有可能饿死。例如，考虑 $P_{n-1}$（需要 $R_{n-1}$，然后是 $R_n$）及其邻居 $P_{n-2}$（需要 $R_{n-2}$，然后是 $R_{n-1}$）和 $P_n$（需要 $R_1$，然后是 $R_n$）。一个不幸的调度序列可能允许 $P_{n-2}$ 和 $P_n$ 以交替方式反复获得它们各自所需的叉子（$P_{n-2}$ 需要 $R_{n-1}$，$P_n$ 需要 $R_n$），使得 $P_{n-1}$ 永远无法同时获得 $R_{n-1}$ 和 $R_n$。该策略本身没有提供任何机制来确保公平性。\n结论：**不正确**。", "answer": "$$\\boxed{AD}$$", "id": "3677360"}, {"introduction": "预防死锁并非总是可行或高效的；有时，我们必须着眼于死锁的检测与恢复。本练习探讨了如何通过打破死锁存在的四大必要条件之一——“不可抢占”规则——来解除一个已经形成的死锁环路。通过分析一个同时包含可抢占资源 $R_{cpu}$ 和不可抢占资源 $R_{printer}$ 的场景 [@problem_id:3677400]，你将理解操作系统如何能主动干预以解决死锁，从而恢复系统的正常运行。", "problem": "在一门操作系统导论课程中，考虑以下场景。资源分配图（Resource-Allocation Graph, RAG）是一个有向二分图，其节点为进程和资源，边有两种类型：从进程到资源的请求边（表示为 $P_i \\to R_j$），代表进程 $P_i$ 正在等待资源 $R_j$；以及从资源到进程的分配边（表示为 $R_j \\to P_i$），代表资源 $R_j$ 当前由进程 $P_i$ 持有。当一组进程被阻塞，每个进程都在等待该组中另一个进程所持有的资源时，我们称系统处于死锁状态；对于单实例资源类型，RAG中存在有向环是死锁的充分必要条件。\n\n假设有两个进程 $P_1$ 和 $P_2$，以及两种资源类型：一个中央处理器（CPU），建模为单实例资源 $R_{cpu}$，以及一台打印机，建模为单实例资源 $R_{printer}$。CPU $R_{cpu}$ 是可抢占的，意味着操作系统可以强制将其从一个进程中解除分配并重新分配给其他进程，而打印机 $R_{printer}$ 是不可抢占的，意味着一旦分配，就不能被强制收回。\n\n最初，RAG具有以下边：\n- $R_{printer} \\to P_1$ (打印机分配给了 $P_1$),\n- $P_1 \\to R_{cpu}$ (进程 $P_1$ 请求CPU),\n- $R_{cpu} \\to P_2$ (CPU分配给了 $P_2$),\n- $P_2 \\to R_{printer}$ (进程 $P_2$ 请求打印机)。\n\n这形成了一个环路\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1.\n$$\n\n基于RAG和死锁的基本定义，评估允许抢占 $R_{cpu}$ 对上述环路的影响。哪个陈述最能描述抢占 $R_{cpu}$ 是否能打破这个否则会导致死锁的环路，以及为什么？\n\nA. 允许抢占 $R_{cpu}$ 可以通过从 $P_2$ 抢占 $R_{cpu}$ 并将其分配给 $P_1$ 来打破环路，使 $P_1$ 能够运行并最终释放 $R_{printer}$，从而防止死锁。\n\nB. 无论抢占策略如何，RAG中的环路总是意味着死锁，因此允许抢占 $R_{cpu}$ 不能打破环路或防止死锁。\n\nC. 只有当 $R_{printer}$ 也是可抢占的时，抢占 $R_{cpu}$ 才能打破环路；否则，环路必然持续存在，死锁依旧。\n\nD. 当两种资源都是单实例时，抢占 $R_{cpu}$ 不能打破持有并等待条件；因此，环路依然存在，死锁不可避免。", "solution": "我们从核心定义开始。资源分配图（RAG）用有向边表示进程和资源：请求边 $P_i \\to R_j$ 意味着进程 $P_i$ 正在等待资源 $R_j$，而分配边 $R_j \\to P_i$ 意味着资源 $R_j$ 由进程 $P_i$ 持有。对于单实例资源类型，RAG中的有向环是死锁的充分必要条件：如果存在环路，那么就有一组进程，每个进程都在等待该组中另一个进程持有的资源，从而无法取得进展。\n\n在给定场景中，有 $2$ 个进程（$P_1$，$P_2$）和 $2$ 种单实例资源类型（$R_{cpu}$ 和 $R_{printer}$）。存在的边如下：\n- $R_{printer} \\to P_1$，\n- $P_1 \\to R_{cpu}$，\n- $R_{cpu} \\to P_2$，\n- $P_2 \\to R_{printer}$。\n\n这形成了一个环路\n$$\nP_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1,\n$$\n在两个资源都不可抢占的假设下，这将意味着死锁，因为每个进程持有一个资源并等待另一个资源，两者都无法继续执行。\n\n然而，CPU $R_{cpu}$ 是明确可抢占的。抢占意味着操作系统可以强制从 $P_2$ 手中解除对 $R_{cpu}$ 的分配，并将其重新分配给另一个进程，例如 $P_1$。从RAG的角度来看，从 $P_2$ 抢占 $R_{cpu}$ 会移除分配边 $R_{cpu} \\to P_2$。如果操作系统接着将 $R_{cpu}$ 分配给 $P_1$，图中会增加一条分配边 $R_{cpu} \\to P_1$，并且请求边 $P_1 \\to R_{cpu}$ 会被满足并移除。此后，剩余的边为：\n- $R_{printer} \\to P_1$，\n- $R_{cpu} \\to P_1$，\n- $P_2 \\to R_{printer}$。\n\n在这些边中不存在环路：$P_2$ 请求 $R_{printer}$，该资源由 $P_1$ 持有，但 $P_1$ 同时持有 $R_{cpu}$ 和 $R_{printer}$，可以继续运行（使用 $R_{cpu}$）并完成使用 $R_{printer}$ 的临界区，最终释放 $R_{printer}$。一旦 $R_{printer}$ 被释放，$P_2$ 就可以获得 $R_{printer}$，系统得以继续运行而没有发生死锁。\n\n从死锁的四个必要条件——互斥、持有并等待、不可抢占和循环等待——来进行分析，请注意，允许对 $R_{cpu}$ 进行抢占使得该资源类型的“不可抢占”条件不再成立。通过移除分配边 $R_{cpu} \\to P_2$，循环等待条件被打破：先前存在的环路 $P_1 \\to R_{cpu} \\to P_2 \\to R_{printer} \\to P_1$ 不再存在，因为在关键的转换过程中 $R_{cpu}$ 不再由 $P_2$ 持有。因此，可以避免死锁。\n\n我们现在评估每个选项：\n\nA. 允许抢占 $R_{cpu}$ 可以通过从 $P_2$ 抢占 $R_{cpu}$ 并将其分配给 $P_1$ 来打破环路，使 $P_1$ 能够运行并最终释放 $R_{printer}$，从而防止死锁。这与上述推理一致。抢占 $R_{cpu}$ 移除了分配边 $R_{cpu} \\to P_2$，消除了环路，并将 $R_{cpu}$ 授予 $P_1$ 使得 $P_1$ 能够取得进展并释放 $R_{printer}$。结论 — 正确。\n\nB. 无论抢占策略如何，RAG中的环路总是意味着死锁，因此允许抢占 $R_{cpu}$ 不能打破环路或防止死锁。这是不正确的。“环路总是意味着死锁”这一陈述仅在静态分配模型下且没有抢占的单实例资源情况下成立。当资源可抢占时，操作系统可以改变分配状态，从而消除环路并防止死锁。结论 — 错误。\n\nC. 只有当 $R_{printer}$ 也是可抢占的时，抢占 $R_{cpu}$ 才能打破环路；否则，环路必然持续存在，死锁依旧。这是不正确的。如前所示，仅通过抢占 $R_{cpu}$ 就可以打破环路：移除 $R_{cpu} \\to P_2$ 就破坏了环路，即使 $R_{printer}$ 仍然是不可抢占的。打印机的不可抢占性并不会妨碍通过CPU来打破环路。结论 — 错误。\n\nD. 当两种资源都是单实例时，抢占 $R_{cpu}$ 不能打破持有并等待条件；因此，环路依然存在，死锁不可避免。这是不正确的。抢占 $R_{cpu}$ 通过强制 $P_2$ 释放 $R_{cpu}$，明确地打破了 $P_2$ 的持有并等待条件。环路被消除，死锁得以避免。单实例状态并不能否定抢占在打破循环等待方面的作用。结论 — 错误。\n\n因此，最佳描述由选项A给出。", "answer": "$$\\boxed{A}$$", "id": "3677400"}]}