{"hands_on_practices": [{"introduction": "当死锁发生时，操作系统需要一种策略来选择一个“牺牲品”进程以终止。这个选择并非随机，而是一个旨在最小化系统总“成本”的计算决策。这个练习 [@problem_id:3676663] 将引导你创建并应用一个加权评分函数，这是一种平衡进程优先级、已占用资源和重启成本等因素的实用方法，模拟了真实操作系统可能如何做出这一关键决策。", "problem": "考虑一个操作系统（OS），它必须通过进程终止或资源抢占的方式从检测到的死锁中恢复。使用以下基本事实和定义作为基本出发点。当且仅当资源分配图中存在有向环时，死锁才会出现。在从死锁中恢复时，一个共同的目标是选择一个牺牲进程，通过平衡几个考虑因素来最小化总体恢复影响：预期的回滚或重启代价，抢占能在多大程度上释放足够的资源以打破循环，以及由其优先级反映的进程的管理或服务重要性。令 $D$ 表示死锁进程的集合。对于每个 $i \\in D$，令 $c_i$ 为一个无量纲的回滚代价指数，令 $h_i$ 为当前持有的资源实例总数，令 $\\pi_i$ 为数字形式的优先级，其中较小的数值表示较高的优先级。假设存在由系统管理员选择的严格为正的无量纲权重 $\\lambda$、$\\mu$ 和 $\\nu$，分别用来编码回滚代价、持有资源和优先级的相对重要性。\n\n任务 $1$ (推导)：从陈述的基本事实和定义出发，为进程 $i$ 推导一个线性的牺牲者选择分数，该分数与倾向于终止回滚代价更小、持有资源更少和优先级更低（即数字优先级 $\\pi_i$ 更大）的进程的目标相一致，并且可以通过最小化该分数来选择牺牲者。请用 $\\lambda$、$\\mu$、$\\nu$、$c_i$、$h_i$ 和 $\\pi_i$ 给出该分数的符号表达式。\n\n任务 $2$ (应用)：在以下具体死锁实例上测试你推导出的分数。有资源类型 $R_A$、$R_B$ 和 $R_C$，每种各有 $1$ 个实例；还有第四种资源类型 $R_D$，有 $2$ 个实例。有三个进程 $P_1$、$P_2$ 和 $P_3$，其持有和请求情况如下：\n- $P_1$ 持有 $R_A$ 和 $1$ 个 $R_D$ 实例；$P_1$ 请求 $R_B$。\n- $P_2$ 持有 $R_B$；$P_2$ 请求 $R_C$。\n- $P_3$ 持有 $R_C$ 和 $1$ 个 $R_D$ 实例；$P_3$ 请求 $R_A$。\n这在 $P_1$、$P_2$ 和 $P_3$ 之间形成了一个死锁循环。各指数为 $c_1 = 1.8$, $h_1 = 2$, $\\pi_1 = 2$；$c_2 = 1.2$, $h_2 = 1$, $\\pi_2 = 4$；$c_3 = 2.6$, $h_3 = 2$, $\\pi_3 = 1$。使用权重 $\\lambda = 0.6$，$\\mu = 0.8$ 和 $\\nu = 0.5$。计算 $D$ 中每个进程的牺牲者分数，通过最小化该分数来确定牺牲者，并报告所选牺牲者分数的值。\n\n将您的最终数值答案表示为一个无量纲标量，并四舍五入到四位有效数字。", "solution": "该问题是有效的，因为它在科学上基于操作系统的原理，特别是死锁恢复的启发式方法，并且问题设定良好，具有完整且一致的数据和目标。\n\n**任务 1：牺牲者选择分数的推导**\n\n目标是为死锁进程集合 $D$ 中的进程 $i$ 推导一个线性分数，我们将其表示为 $S_i$。该分数的制定必须使其最小化能够选出一个与给定目标一致的牺牲进程。该分数将是进程的回滚代价指数 $c_i$、其持有的资源实例总数 $h_i$ 以及其数字优先级 $\\pi_i$ 的线性组合。该组合将由严格为正的无量纲常数 $\\lambda$、$\\mu$ 和 $\\nu$ 进行加权。\n\n选择标准是最小化分数 $S_i$。因此，使一个进程成为更理想的牺牲者的因素应导致较低的分数，而使其成为不那么理想的牺牲者的因素应导致较高的分数。\n\n$1$. **回滚代价 ($c_i$)**：目标是倾向于终止回滚代价*更小*的进程。这意味着具有较大回滚代价指数 $c_i$ 的进程不是一个好的牺牲者选择，因此应具有较高的分数。因此，分数 $S_i$ 必须是 $c_i$ 的增函数。对分数有贡献的线性项因此与 $c_i$ 成正比，并由其重要性因子 $\\lambda$ 加权。该项是 $+\\lambda c_i$。\n\n$2$. **持有资源 ($h_i$)**：目标是倾向于终止持有资源*更少*的进程。持有大量资源 $h_i$ 的进程是一个不那么理想的牺牲者，应具有较高的分数。因此，分数 $S_i$ 也必须是 $h_i$ 的增函数。该因素的线性项与 $h_i$ 成正比，并由 $\\mu$ 加权。该项是 $+\\mu h_i$。\n\n$3$. **优先级 ($\\pi_i$)**：目标是倾向于终止优先级*更低*的进程。问题定义了*更大*的数值 $\\pi_i$ 对应于更低的优先级。因此，具有较大 $\\pi_i$ 的进程是一个更理想的牺牲者，并且应该有一个*更低*的分数，以便在最小化过程中被选中。这意味着分数 $S_i$ 必须是 $\\pi_i$ 的减函数。为了在线性模型中实现这一点，涉及 $\\pi_i$ 的项必须有一个负系数。权重 $\\nu$ 代表优先级的重要性，由于 $\\nu$ 是严格为正的，该项必须构造为 $-\\nu \\pi_i$。\n\n将这三项结合起来，得到进程 $i$ 的总线性牺牲者选择分数：\n$$S_i = \\lambda c_i + \\mu h_i - \\nu \\pi_i$$\n这个表达式在 $c_i$、$h_i$ 和 $\\pi_i$ 上是线性的，并且最小化它满足了所有陈述的牺牲者选择目标。\n\n**任务 2：具体实例的应用**\n\n我们现在将推导出的分数函数应用于给定的死锁场景。死锁进程的集合是 $D = \\{P_1, P_2, P_3\\}$。\n\n给定的权重为：\n$\\lambda = 0.6$\n$\\mu = 0.8$\n$\\nu = 0.5$\n\n每个进程的参数为：\n- 对于 $P_1$：$c_1 = 1.8$, $h_1 = 2$, $\\pi_1 = 2$。\n- 对于 $P_2$：$c_2 = 1.2$, $h_2 = 1$, $\\pi_2 = 4$。\n- 对于 $P_3$：$c_3 = 2.6$, $h_3 = 2$, $\\pi_3 = 1$。\n\n我们计算每个进程的分数 $S_i$。\n\n**进程 $P_1$ 的分数**：\n$S_1 = \\lambda c_1 + \\mu h_1 - \\nu \\pi_1$\n$S_1 = (0.6)(1.8) + (0.8)(2) - (0.5)(2)$\n$S_1 = 1.08 + 1.6 - 1.0$\n$S_1 = 1.68$\n\n**进程 $P_2$ 的分数**：\n$S_2 = \\lambda c_2 + \\mu h_2 - \\nu \\pi_2$\n$S_2 = (0.6)(1.2) + (0.8)(1) - (0.5)(4)$\n$S_2 = 0.72 + 0.8 - 2.0$\n$S_2 = 1.52 - 2.0$\n$S_2 = -0.48$\n\n**进程 $P_3$ 的分数**：\n$S_3 = \\lambda c_3 + \\mu h_3 - \\nu \\pi_3$\n$S_3 = (0.6)(2.6) + (0.8)(2) - (0.5)(1)$\n$S_3 = 1.56 + 1.6 - 0.5$\n$S_3 = 3.16 - 0.5$\n$S_3 = 2.66$\n\n为了选择牺牲进程，我们在 $\\{S_1, S_2, S_3\\}$ 中找到最低分数：\n$$\\min(S_1, S_2, S_3) = \\min(1.68, -0.48, 2.66) = -0.48$$\n最低分数为 $-0.48$，对应于进程 $P_2$。因此，选择 $P_2$ 作为要终止的牺牲进程。\n\n问题要求给出所选牺牲者分数的数值，并四舍五入到四位有效数字。计算出的分数恰好是 $-0.48$。用四位有效数字表示，即为 $-0.4800$。", "answer": "$$\\boxed{-0.4800}$$", "id": "3676663"}, {"introduction": "终止进程是一种打破死锁循环的强制但有效的方法。然而，其后果在很大程度上取决于进程所持有的资源类型，特别是内核管理的资源和用户空间资源之间的区别。这个思想实验 [@problem_id:3676582] 挑战你分析一个涉及内核管理锁和用户空间锁的复杂场景，揭示了虽然终止可以解决主要的死锁，但可能会引入次要问题，例如“孤儿”资源，从而强调了仔细进行系统设计的必要性。", "problem": "考虑一个通用操作系统（OS）中由两个用户进程管理的共享数据结构。该操作系统为结构性更新强制执行内核管理的建议性文件锁，并允许在共享内存中使用用户空间互斥锁进行细粒度保护。设 $F$ 和 $G$ 表示两个内核管理的文件锁，设 $M$ 表示一个用户空间互斥锁。对于文件段 $\\alpha$ 的更新，推荐的获取顺序是先 $F$（外部）后 $M$（内部），类似地，对于文件段 $\\beta$ 的更新，推荐的获取顺序是先 $G$（外部）后 $M$（内部）。假设 $M$ 是一个非健壮的用户空间互斥锁（即，它不支持所有者死亡语义，并且在进程终止时不会自动释放）。\n\n在时间 $t_0$，进程 $P_1$ 在准备更新时获取了 $F$ 然后获取了 $M$，随后尝试获取 $G$。同时，进程 $P_2$ 获取了 $G$ 并随后尝试获取 $F$。结果是 $P_1$ 持有 $F$ 和 $M$ 并等待 $G$，而 $P_2$ 持有 $G$ 并等待 $F$。这在等待图（WFG）中创建了一个循环，WFG被定义为一个有向图，其顶点是进程，其边 $P_i \\rightarrow P_j$ 表示进程 $P_i$ 正在等待由进程 $P_j$ 当前持有的资源。具体来说，WFG包含边 $P_1 \\rightarrow P_2$（因为 $P_1$ 等待由 $P_2$ 持有的 $G$）和边 $P_2 \\rightarrow P_1$（因为 $P_2$ 等待由 $P_1$ 持有的 $F$），形成了一个循环 $\\{P_1, P_2\\}$，这表明在满足互斥、持有并等待、不可抢占和循环等待的条件下发生了死锁。\n\n一个死锁处理器选择进程 $P_1$ 进行终止。终止后，操作系统会释放由 $P_1$ 持有的内核管理的锁，因此 $F$ 被释放。然而，由于 $M$ 是一个非健壮的用户空间互斥锁，它在共享内存中仍然保持逻辑上的锁定状态，但没有活动的所有者，任何试图锁定 $M$ 的进程都将无限期阻塞，除非执行额外的恢复操作。\n\n假设在 $t_0$ 时没有其他进程持有或等待 $F$ 或 $G$。存在第三个进程 $P_3$，它被阻塞以等待获取 $M$（它不参与 $P_1$ 和 $P_2$ 之间的循环）。\n\n当像 $M$ 这样的内部锁在共享内存数据结构中仍然被持有时，从被终止的进程 $P_1$ 释放外部锁 $F$ 是否足以解决 $P_1$ 和 $P_2$ 之间的死锁？以下哪个陈述最能描述这种情况？\n\nA. 是的；释放被终止进程持有的任何锁总能解决死锁，无论内部锁的状态如何，因为死锁条件集减少了。\n\nB. 不；在实践中，进程终止不会释放任何锁，因此没有显式的应用级协调就无法解决死锁。\n\nC. 仅当被释放的外部锁对应于等待图循环中的一条边（此处为通过 $F$ 形成的 $P_2 \\rightarrow P_1$），并且被终止进程仍然持有的内部锁未出现在该循环上时，这才是充分的；否则，死锁可能持续存在。\n\nD. 是的，前提是内部锁是具有所有者死亡语义的健壮互斥锁，因为运行时会将 $M$ 标记为可恢复，以便其他进程可以继续；因此，在所有情况下，释放外部锁加上健壮的内部锁保证了死锁的解决。", "solution": "用户问题已按如下方式验证。\n\n### 步骤 1：提取已知条件\n- 进程：两个用户进程 $P_1$ 和 $P_2$，以及第三个进程 $P_3$。\n- 资源：\n    - $F$：一个内核管理的建议性文件锁。\n    - $G$：一个内核管理的建议性文件锁。\n    - $M$：一个共享内存中的用户空间互斥锁。\n- 资源属性：\n    - $M$ 是一个非健壮的用户空间互斥锁，意味着它在进程终止时不会自动释放。\n    - $F$ 和 $G$ 是内核管理的，意味着它们在进程终止时会自动释放。\n- $t_0$ 时刻的系统状态：\n    - $P_1$ 持有锁 $F$ 和互斥锁 $M$。\n    - $P_1$ 正在等待获取锁 $G$。\n    - $P_2$ 持有锁 $G$。\n    - $P_2$ 正在等待获取锁 $F$。\n    - $P_3$ 正在等待获取互斥锁 $M$。\n- 等待图（WFG）状态：\n    - 存在一条边 $P_1 \\rightarrow P_2$，因为 $P_1$ 等待由 $P_2$ 持有的 $G$。\n    - 存在一条边 $P_2 \\rightarrow P_1$，因为 $P_2$ 等待由 $P_1$ 持有的 $F$。\n    - 这些边形成一个循环 $\\{P_1, P_2\\}$，表示存在死锁。\n    - 存在一条边 $P_3 \\rightarrow P_1$，因为 $P_3$ 等待由 $P_1$ 持有的 $M$。\n- 死锁恢复操作：\n    - 一个死锁处理器选择进程 $P_1$ 进行终止。\n- 终止的后果：\n    - 操作系统释放由 $P_1$ 持有的内核管理的锁，因此 $F$ 被释放。\n    - 用户空间互斥锁 $M$ 保持逻辑锁定状态。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学性**：该问题牢固地基于操作系统原理，特别是并发控制和死锁。内核管理的文件锁、用户空间互斥锁（包括健壮和非健壮的）、等待图以及通过进程终止进行死锁恢复等概念都是标准的，并且得到了准确的表述。\n- **适定性**：该问题设定了一个清晰、具体的场景，并就一个明确操作的结果提出了一个精确的问题。所有相关进程和资源的状态都得到了明确的描述。\n- **客观性**：语言技术性强、精确且没有主观性。\n\n该问题没有表现出任何科学上不健全、不完整、矛盾或模糊等缺陷。内核级和用户级资源及其在进程终止时的行为之间的区别是该领域一个关键且有效的概念。\n\n### 步骤 3：结论与行动\n问题陈述是**有效的**。将推导出解决方案。\n\n### 推导\n问题的核心是确定终止进程 $P_1$ 是否能解决涉及 $P_1$ 和 $P_2$ 的死锁。死锁的特征是等待图（WFG）中存在一个循环。要解决死锁，必须打破这个循环。\n\n1.  **初始死锁状态分析**：\n    问题陈述了一个涉及进程 $P_1$ 和 $P_2$ 的死锁。让我们根据给定信息形式化WFG。图的顶点是进程，有向边 $P_i \\rightarrow P_j$ 表示 $P_i$ 正在等待由 $P_j$ 持有的资源。\n    - $P_1$ 持有 $\\{F, M\\}$ 并等待 $G$。\n    - $P_2$ 持有 $\\{G\\}$ 并等待 $F$。\n    - $P_3$ 等待 $M$。\n\n    $P_1$ 和 $P_2$ 之间的特定死锁循环由以下部分构成：\n    - $P_1$ 等待 $G$，而 $G$ 由 $P_2$ 持有。这建立了边 $P_1 \\rightarrow P_2$。\n    - $P_2$ 等待 $F$，而 $F$ 由 $P_1$ 持有。这建立了边 $P_2 \\rightarrow P_1$。\n    - 因此，循环是 $P_1 \\rightarrow P_2 \\rightarrow P_1$。\n\n    关键在于，互斥锁 $M$ 由 $P_1$ 持有，但*此循环内*的进程（即 $P_2$）没有等待 $M$。对 $M$ 的依赖涉及 $P_3$，创建了一条独立的边 $P_3 \\rightarrow P_1$，但这条边不是 $P_1 \\leftrightarrow P_2$ 循环的一部分。\n\n2.  **恢复操作分析**：\n    死锁处理器终止进程 $P_1$。根据操作系统原理和问题陈述，内核会回收与被终止进程相关的所有内核管理的资源。\n    - 锁 $F$ 是一个内核管理的资源。因此，在 $P_1$ 终止后，操作系统会释放锁 $F$。\n    - 锁 $F$ 变得对其他进程可用。\n\n3.  **恢复操作后的状态**：\n    - 进程 $P_2$ 之前被阻塞，等待锁 $F$。\n    - 由于 $F$ 现在被释放，$P_2$ 不再阻塞，可以成功获取 $F$。\n    - 一旦 $P_2$ 获取了 $F$，它将同时持有 $F$ 和 $G$，并且不再等待任何资源。它可以继续执行。\n    - 在WFG中，边 $P_2 \\rightarrow P_1$ 被消除，因为资源 $F$ 不再由 $P_1$（已不存在）持有，而是对 $P_2$ 可用并被其获取。\n    - 移除边 $P_2 \\rightarrow P_1$ 打破了循环 $P_1 \\rightarrow P_2 \\rightarrow P_1$。\n\n    因此，* $P_1$ 和 $P_2$ 之间的*死锁被明确地解决了。\n\n4.  **非健壮互斥锁 $M$ 的影响**：\n    问题正确地指出，非健壮的用户空间互斥锁 $M$ *不会*被释放。它在共享内存中保持锁定状态，但没有所有者。正在等待 $M$ 的进程 $P_3$ 将继续阻塞。此外，任何其他试图获取 $M$ 的进程也将无限期阻塞。这会产生一个新的可用性问题，如果另一个获取 $M$ 的进程（假设经过一些带外恢复后）后来需要一个由 $P_2$ 持有的资源，可能会导致饥饿或新的死锁。\n\n    然而，问题恰恰是“从被终止的进程 $P_1$ 释放外部锁 $F$ 是否足以解决 *$P_1$ 和 $P_2$ 之间的*死锁”。$M$ 的孤儿状态不会阻止 $P_2$ 解除阻塞。特定的 $P_1 \\leftrightarrow P_2$ 循环的解决不受 $M$ 状态的阻碍，因为 $M$ 不是该循环中涉及的资源。\n\n### 逐项分析\n\n**A. 是的；释放被终止进程持有的任何锁总能解决死锁，无论内部锁的状态如何，因为死锁条件集减少了。**\n“是的”这个结论对于这个特定的死锁是正确的。然而，其推理存在缺陷且过于简单化。“释放任何锁……总能解决死锁”这个说法是错误的；必须释放构成循环一部分的锁。 “无论内部锁的状态如何”这句话之所以在这种情况下成立，仅仅是因为内部锁 $M$ 不属于死锁循环的一部分。如果 $P_2$ 一直在等待 $M$，那么内部锁的状态将至关重要。因此，这不是*最好*的描述。**不正确**。\n\n**B. 不；在实践中，进程终止不会释放任何锁，因此没有显式的应用级协调就无法解决死锁。**\n这个陈述在事实上是错误的。操作系统被设计为在进程终止时（无论是正常还是异常）回收内核管理的资源，包括文件锁。其前提不正确，导致结论错误。**不正确**。\n\n**C. 仅当被释放的外部锁对应于等待图循环中的一条边（此处为通过 $F$ 形成的 $P_2 \\rightarrow P_1$），并且被终止进程仍然持有的内部锁未出现在该循环上时，这才是充分的；否则，死锁可能持续存在。**\n该陈述对情况进行了精确且正确的结构性分析。\n- 它正确地指出，释放一个锁对于解决死锁是有效的，只有当该锁是导致循环的资源时（释放 $F$ 打破了边 $P_2 \\rightarrow P_1$）。此条件已满足。\n- 它正确地指出了为什么内部锁 $M$ 的状态在这种特定情况下不是障碍的原因：$M$ 没有“出现在该循环上”，意味着循环中的进程（$P_2$）没有等待 $M$。此条件也已满足。\n- 它正确地暗示，如果这些条件没有被满足（例如，如果 $M$ 是循环的一部分且未被释放），死锁可能会持续存在。\n这个选项准确而全面地描述了为什么释放 $F$ 足以解决 $P_1$ 和 $P_2$ 之间的死锁。**正确**。\n\n**D. 是的，前提是内部锁是具有所有者死亡语义的健壮互斥锁，因为运行时会将 $M$ 标记为可恢复，以便其他进程可以继续；因此，在所有情况下，释放外部锁加上健壮的内部锁保证了死锁的解决。**\n这个选项没有回答所提出的问题。问题明确指出 $M$ 是一个*非健壮*的互斥锁。该选项将这一基本前提更改为一个假设情况，即 $M$ 是健壮的。虽然健壮互斥锁是解决影响 $P_3$ 的孤儿锁问题的一种方法，但讨论它们并不能描述给定情况的结果。这是对另一个问题的回答。**不正确**。", "answer": "$$\\boxed{C}$$", "id": "3676582"}, {"introduction": "除了终止进程，操作系统有时可以通过强制从一个进程收回资源并将其分配给另一个进程来恢复。为了安全地执行此操作，操作系统必须确保最终状态能让所有进程最终完成执行。这个问题 [@problem_id:3676623] 提供了一个基于银行家算法原理的动手计算练习，你将确定为使一个不安全系统恢复到安全状态所需抢占的最小资源数量，从而实践一种比简单终止更为精细的恢复策略。", "problem": "一个操作系统 (OS) 正在管理一种单一类型的可抢占资源 $R$，该资源共有 $T$ 个实例。系统中当前有 $n=4$ 个进程 $\\{P_{1},P_{2},P_{3},P_{4}\\}$。每个进程 $P_{i}$ 对资源 $R$ 有一个最大需求量 $C_{i}$，以及一个当前分配量 $A_{i}$。系统状态由需求向量 $C$ 和分配向量 $A$ 表示，可用资源单元数 $V$ 满足 $V = T - \\sum_{i=1}^{n} A_{i}$。\n\n基本前提：\n- 一个状态是安全的，如果存在一个所有进程的排列顺序，使得对于该顺序中的每个进程，其剩余需求 $N_{i} = C_{i} - A_{i}$ 不超过当前可用的 $R$ 资源单元数，并且在该进程完成后，它会释放其持有的所有 $A_{i}$ 个单元，从而在考虑下一个进程之前增加可用资源单元数。\n- 在一个涉及可抢占资源的死锁状态中，可以尝试通过从一个或多个进程中抢占 $R$ 的资源单元来增加 $V$ 以进行恢复。\n\n考虑以下具体系统：\n- $T = 17$，\n- $C = (7,5,9,6)$，\n- $A = (3,1,8,5)$。\n\n根据给定的 $T$ 和 $A$ 计算初始可用资源单元数 $V$。假设 $R$ 是可抢占的。你被允许从且仅从一个进程 $P_{3}$ 中抢占 $u$ 个 $R$ 资源单元，使其分配量从 $A_{3}$ 减少到 $A_{3} - u$，并将可用资源单元数增加到 $V + u$。没有其他进程被终止或抢占。仅使用上述基本定义，确定最小的整数 $u$，使得最终状态是安全的（即，存在一个所有四个进程都能根据安全状态定义完成的完整序列）。提供最小的 $u$ 作为你的最终答案。无需四舍五入，也无需单位。", "solution": "我们要找到最小的整数 $u$，使得从进程 $P_3$ 抢占 $u$ 个 $R$ 资源单元后，系统进入安全状态。\n\n我们首先分析系统的初始状态。\n资源 $R$ 的总实例数：$T=17$。\n需求向量 $C = (C_1, C_2, C_3, C_4) = (7, 5, 9, 6)$。\n分配向量 $A = (A_1, A_2, A_3, A_4) = (3, 1, 8, 5)$。\n已分配的单元总数为 $\\sum_{i=1}^{4} A_{i} = 3+1+8+5 = 17$。\n可用单元数为 $V = T - \\sum A_{i} = 17 - 17 = 0$。\n\n需求向量 $N$ 计算如下：$N = C - A$：\n$N_1 = C_1 - A_1 = 7 - 3 = 4$\n$N_2 = C_2 - A_2 = 5 - 1 = 4$\n$N_3 = C_3 - A_3 = 9 - 8 = 1$\n$N_4 = C_4 - A_4 = 6 - 5 = 1$\n所以，$N = (4, 4, 1, 1)$。\n\n初始时，可用单元为 $V=0$。由于所有进程的需求都大于0，没有进程可以完成。系统不处于安全状态（实际上，它已经死锁）。\n\n现在，我们考虑从 $P_3$ 抢占 $u$ 个单元。新状态将是：\n$P_3$ 的新分配量：$A'_3 = A_3 - u = 8 - u$。\n新分配向量：$A' = (3, 1, 8-u, 5)$。\n新可用单元数：$V' = V + u = 0 + u = u$。\n$P_3$ 的新需求：$N'_3 = C_3 - A'_3 = 9 - (8-u) = 1+u$。\n新需求向量：$N' = (4, 4, 1+u, 1)$。\n\n我们需要找到最小的整数 $u \\ge 1$（因为我们正在进行抢占），使得状态安全。为了使状态安全，必须存在一个可以完成的进程序列。\n\n我们从 $u=1$ 开始测试。\n\n情况 $u=1$:\n可用单元数：$V' = 1$。\n需求：$N' = (4, 4, 1+1, 1) = (4, 4, 2, 1)$。\n分配：$A' = (3, 1, 8-1, 5) = (3, 1, 7, 5)$。\n\n我们检查是否存在一个进程 $P_i$ 满足 $N'_i \\le V'$。\n$N'_1 = 4  1$ (否)\n$N'_2 = 4  1$ (否)\n$N'_3 = 2  1$ (否)\n$N'_4 = 1 \\le 1$ (是)\n\n所以，$P_4$ 可以运行。我们假设 $P_4$ 运行并完成。\n新的可用单元数 = 当前可用 + $P_4$的分配 = $V' + A'_4 = 1 + 5 = 6$。\n剩余进程：$\\{P_1, P_2, P_3\\}$。剩余需求：$N'_{1}=4, N'_{2}=4, N'_{3}=2$。\n\n现在，可用单元数为 6。我们检查下一个进程。\n$N'_1 = 4 \\le 6$ (是)\n$N'_2 = 4 \\le 6$ (是)\n$N'_3 = 2 \\le 6$ (是)\n所有剩余进程都可以被选择。我们选择 $P_3$（需求最小）。\n让 $P_3$ 运行。新的可用单元数 = $6 + A'_3 = 6 + 7 = 13$。\n剩余进程：$\\{P_1, P_2\\}$。剩余需求：$N'_{1}=4, N'_{2}=4$。\n\n现在，可用单元数为 13。$P_1$ 和 $P_2$ 都可以运行，因为他们的需求（4）小于 13。\n让 $P_1$ 运行。新的可用单元数 = $13 + A'_1 = 13 + 3 = 16$。\n剩余进程：$\\{P_2\\}$。其需求为 $N'_{2}=4 \\le 16$。所以 $P_2$ 可以运行。\n\n由于我们找到了一个安全序列（例如，$\\langle P_4, P_3, P_1, P_2 \\rangle$），系统在 $u=1$ 时是安全的。因为我们寻找的是最小的整数 $u$，所以答案是 1。", "answer": "$$ \\boxed{1} $$", "id": "3676623"}]}