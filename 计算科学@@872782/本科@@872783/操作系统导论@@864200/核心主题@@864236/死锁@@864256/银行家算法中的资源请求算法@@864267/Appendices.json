{"hands_on_practices": [{"introduction": "我们的第一个练习从一个有趣的思想实验开始：如果一个进程请求零个资源，会发生什么？这个看似“无操作”的请求，实际上是检验你是否真正理解银行家算法形式化规则的试金石。通过这个练习，你将学会区分算法的严格步骤和直觉上的假设，并明白即使是零请求也必须经过完整的安全检查流程。[@problem_id:3678119]", "problem": "一个操作系统（OS）课程中的计算系统使用 Dijkstra 的银行家算法来防止死锁。系统中有 $n = 4$ 个进程 $\\{P_0, P_1, P_2, P_3\\}$ 和 $m = 3$ 种资源类型 $\\{R_1, R_2, R_3\\}$。总资源量由向量 $\\vec{T} = (8, 7, 6)$ 给出。当前的分配矩阵 $A$ 和最大需求矩阵 $M$ 如下：\n$$\nA = \n\\begin{bmatrix}\n1  1  0 \\\\\n2  0  1 \\\\\n0  2  1 \\\\\n2  1  0\n\\end{bmatrix},\\quad\nM =\n\\begin{bmatrix}\n3  2  1 \\\\\n3  3  3 \\\\\n1  2  3 \\\\\n3  1  2\n\\end{bmatrix}.\n$$\n根据银行家算法的核心定义，需求矩阵 $N$ 定义为 $N = M - A$，可用资源向量 $\\vec{Available}$ 定义为 $\\vec{T} - \\sum \\text{rows of } A$。假设发生以下资源请求：进程 $P_3$ 发出请求 $Request_3 = \\vec{0}$，即 $Request_3 = (0, 0, 0)$。\n\n仅使用银行家算法中资源请求算法的基本步骤，这些步骤是：\n- 逐分量检查是否 $Request_i \\leq Need_i$。\n- 逐分量检查是否 $Request_i \\leq \\vec{Available}$。\n- 如果两项检查都通过，则假定分配，设置 $\\vec{Available} := \\vec{Available} - Request_i$，$A_i := A_i + Request_i$ 和 $N_i := N_i - Request_i$，然后运行安全性测试。\n以及基本的安全性测试，该测试初始化 $\\vec{Work} := \\vec{Available}$ 和对所有 $j$ 设置 $Finish[j] := \\text{false}$，然后重复寻找索引 $k$ 使得 $Finish[k] = \\text{false}$ 且 $N_k \\leq \\vec{Work}$，设置 $Finish[k] := \\text{true}$ 并更新 $\\vec{Work} := \\vec{Work} + A_k$，直到找不到这样的 $k$ 为止，\n\n回答以下问题。假设在安全性测试中，若有多个进程满足条件，则优先选择进程索引最小的那个。\n\n对于给定状态，哪个陈述最准确地描述了资源请求算法在处理 $Request_3 = \\vec{0}$ 时的行为，以及随后安全性测试中 $\\vec{Work}$ 和 $Finish$ 的演变过程？\n\nA. 零请求被批准，状态不变；安全性测试以 $\\vec{Work} = (3, 3, 4)$ 和 $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$ 开始，然后按顺序选择 $P_0, P_1, P_2, P_3$，最终 $\\vec{Work}$ 变为 $(8, 7, 6)$ 且所有 $Finish$ 项均为 $\\text{true}$。\n\nB. 零请求被拒绝，因为 $Request_3$ 必须是严格正的才能被处理；$\\vec{Work}$ 和 $Finish$ 保持未定义状态。\n\nC. 零请求被批准，安全性测试立即将 $Finish[3]$ 设置为 $\\text{true}$ 而不检查 $N_3 \\leq \\vec{Work}$；因此，在考虑其他进程之前，$\\vec{Work}$ 首先变为 $(5, 4, 4)$。\n\nD. 零请求被视为资源释放，因此 $\\vec{Available}$ 增加了 $A_3$；因此，安全性测试从 $\\vec{Work} = (5, 4, 4)$ 和 $Finish[3] = \\text{false}$ 开始。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确、客观且内容完整。\n\n### 第 1 步：提取已知条件\n- 进程数，$n = 4$：$\\{P_0, P_1, P_2, P_3\\}$。\n- 资源类型数，$m = 3$：$\\{R_1, R_2, R_3\\}$。\n- 总资源向量：$\\vec{T} = (8, 7, 6)$。\n- 分配矩阵 $A$：\n$$\nA = \n\\begin{bmatrix}\n1  1  0 \\\\\n2  0  1 \\\\\n0  2  1 \\\\\n2  1  0\n\\end{bmatrix}\n$$\n- 最大需求矩阵 $M$：\n$$\nM =\n\\begin{bmatrix}\n3  2  1 \\\\\n3  3  3 \\\\\n1  2  3 \\\\\n3  1  2\n\\end{bmatrix}\n$$\n- 需求矩阵定义：$N = M - A$。\n- 可用向量定义：$\\vec{Available} = \\vec{T} - \\sum \\text{rows of } A$。\n- 来自进程 $P_3$ 的资源请求：$Request_3 = (0, 0, 0)$。\n- 提供了资源请求算法的步骤。\n- 提供了安全性测试算法的步骤。\n- 安全性测试的决胜规则：优先选择最小的进程索引。\n\n### 第 2 步：使用提取的已知条件进行验证\n问题描述了应用 Dijkstra 银行家算法的一个标准场景，这是操作系统中避免死锁的一个基本概念。所提供的定义和算法都是典型的。我们必须检查初始状态的内部一致性。\n\n1.  **已分配资源总量**：我们对分配矩阵 $A$ 的各列求和。\n    - 已分配的 $R_1$ 总量：$1 + 2 + 0 + 2 = 5$。\n    - 已分配的 $R_2$ 总量：$1 + 0 + 2 + 1 = 4$。\n    - 已分配的 $R_3$ 总量：$0 + 1 + 1 + 0 = 2$。\n    总分配向量为 $\\sum_{i=0}^{3} A_i = (5, 4, 2)$。\n\n2.  **一致性检查**：已分配的资源总量不能超过系统中的总资源量。\n    - $\\sum A_i = (5, 4, 2) \\leq \\vec{T} = (8, 7, 6)$。该不等式逐分量成立（$5 \\leq 8$, $4 \\leq 7$, $2 \\leq 6$）。\n\n3.  **声明一致性检查**：分配给一个进程的资源数量不能超过其最大声明。这意味着对每个进程 $i$ 都有 $A_i \\leq M_i$。\n    - $P_0$：$A_0 = (1, 1, 0) \\leq M_0 = (3, 2, 1)$。成立。\n    - $P_1$：$A_1 = (2, 0, 1) \\leq M_1 = (3, 3, 3)$。成立。\n    - $P_2$：$A_2 = (0, 2, 1) \\leq M_2 = (1, 2, 3)$。成立。\n    - $P_3$：$A_3 = (2, 1, 0) \\leq M_3 = (3, 1, 2)$。成立。\n\n问题具有科学依据，定义明确，客观，且内部一致。\n\n### 第 3 步：结论与行动\n问题是有效的。可以继续求解过程。\n\n### 解题推导\n\n首先，我们计算系统的初始状态，特别是 `Available` 向量和 `Need` 矩阵。\n\n**1. 计算 `Available` 向量：**\n`Available` 向量是总资源减去已分配资源总量。\n$$\n\\vec{Available} = \\vec{T} - \\sum_{i=0}^{3} A_i = (8, 7, 6) - (5, 4, 2) = (3, 3, 4)\n$$\n\n**2. 计算 `Need` 矩阵：**\n`Need` 矩阵定义为 $N = M - A$。我们逐行计算。\n- $N_0 = M_0 - A_0 = (3, 2, 1) - (1, 1, 0) = (2, 1, 1)$。\n- $N_1 = M_1 - A_1 = (3, 3, 3) - (2, 0, 1) = (1, 3, 2)$。\n- $N_2 = M_2 - A_2 = (1, 2, 3) - (0, 2, 1) = (1, 0, 2)$。\n- $N_3 = M_3 - A_3 = (3, 1, 2) - (2, 1, 0) = (1, 0, 2)$。\n所以，`Need` 矩阵是：\n$$\nN = \n\\begin{bmatrix}\n2  1  1 \\\\\n1  3  2 \\\\\n1  0  2 \\\\\n1  0  2\n\\end{bmatrix}\n$$\n\n**3. 处理资源请求 $Request_3 = (0, 0, 0)$：**\n我们遵循针对 $P_3$ 的资源请求算法步骤。\n- **第 1 步：检查是否 $Request_3 \\leq Need_3$。**\n  - $Request_3 = (0, 0, 0)$。\n  - $Need_3 = (1, 0, 2)$。\n  - 条件 $(0, 0, 0) \\leq (1, 0, 2)$ 逐分量成立。检查通过。\n\n- **第 2 步：检查是否 $Request_3 \\leq \\vec{Available}$。**\n  - $Request_3 = (0, 0, 0)$。\n  - $\\vec{Available} = (3, 3, 4)$。\n  - 条件 $(0, 0, 0) \\leq (3, 3, 4)$ 逐分量成立。检查通过。\n\n- **第 3 步：尝试分配与安全性测试。**\n  由于两项检查都通过，算法继续执行。在运行安全性测试之前，系统状态被假设性地更新。\n  - $\\vec{Available} := \\vec{Available} - Request_3 = (3, 3, 4) - (0, 0, 0) = (3, 3, 4)$。\n  - $A_3 := A_3 + Request_3 = (2, 1, 0) + (0, 0, 0) = (2, 1, 0)$。\n  - $N_3 := N_3 - Request_3 = (1, 0, 2) - (0, 0, 0) = (1, 0, 2)$。\n  由于请求的资源为零，系统状态（$A$、$N$、$\\vec{Available}$）没有改变。请求被“批准”的意义是算法进入安全性测试阶段，而不是说请求被拒绝。\n\n**4. 运行安全性测试：**\n在（未改变的）状态上运行安全性测试。\n- **初始化：**\n  - $\\vec{Work} := \\vec{Available} = (3, 3, 4)$。\n  - $Finish := (\\text{false}, \\text{false}, \\text{false}, \\text{false})$。\n\n- **执行循环：** 寻找一个进程 $P_k$ 使得 $Finish[k] = \\text{false}$ 且 $N_k \\leq \\vec{Work}$。\n  - **第 1 轮迭代：** $\\vec{Work} = (3, 3, 4)$。\n    - 对于 $k=0$：$N_0 = (2, 1, 1) \\leq (3, 3, 4)$。成立。\n    - 由于在有多个选择时必须优先选择最小的索引，我们选择 $P_0$。\n    - $\\vec{Work} := \\vec{Work} + A_0 = (3, 3, 4) + (1, 1, 0) = (4, 4, 4)$。\n    - $Finish := (\\text{true}, \\text{false}, \\text{false}, \\text{false})$。\n\n  - **第 2 轮迭代：** $\\vec{Work} = (4, 4, 4)$。\n    - 对于 $k=1$：$N_1 = (1, 3, 2) \\leq (4, 4, 4)$。成立。\n    - 选择 $P_1$。\n    - $\\vec{Work} := \\vec{Work} + A_1 = (4, 4, 4) + (2, 0, 1) = (6, 4, 5)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{false}, \\text{false})$。\n\n  - **第 3 轮迭代：** $\\vec{Work} = (6, 4, 5)$。\n    - 对于 $k=2$：$N_2 = (1, 0, 2) \\leq (6, 4, 5)$。成立。\n    - 选择 $P_2$。\n    - $\\vec{Work} := \\vec{Work} + A_2 = (6, 4, 5) + (0, 2, 1) = (6, 6, 6)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{true}, \\text{false})$。\n\n  - **第 4 轮迭代：** $\\vec{Work} = (6, 6, 6)$。\n    - 对于 $k=3$：$N_3 = (1, 0, 2) \\leq (6, 6, 6)$。成立。\n    - 选择 $P_3$。\n    - $\\vec{Work} := \\vec{Work} + A_3 = (6, 6, 6) + (2, 1, 0) = (8, 7, 6)$。\n    - $Finish := (\\text{true}, \\text{true}, \\text{true}, \\text{true})$。\n\n- **安全性测试结论：**\n  $Finish$ 向量中的所有项都为 true，因此状态是安全的。找到的安全序列是 $\\langle P_0, P_1, P_2, P_3 \\rangle$。$\\vec{Work}$ 的最终值为 $(8, 7, 6)$，这与总资源 $\\vec{T}$ 正确匹配。\n\n### 逐项分析选项\n\n- **A. 零请求被批准，状态不变；安全性测试以 $\\vec{Work} = (3, 3, 4)$ 和 $Finish = (\\text{false}, \\text{false}, \\text{false}, \\text{false})$ 开始，然后按顺序选择 $P_0, P_1, P_2, P_3$，最终 $\\vec{Work}$ 变为 $(8, 7, 6)$ 且所有 $Finish$ 项均为 $\\text{true}$。**\n  该陈述与上面的分步推导完全匹配。零请求通过了检查，因此被“批准”并进入安全性测试。状态未改变。初始的 `Work` 向量是正确的。找到的进程序列和最终的 `Work` 向量也是正确的。\n  **结论：正确。**\n\n- **B. 零请求被拒绝，因为 $Request_3$ 必须是严格正的才能被处理；$\\vec{Work}$ 和 $Finish$ 保持未定义状态。**\n  这是不正确的。银行家算法使用小于等于比较（$Request_i \\leq Need_i$ 和 $Request_i \\leq \\vec{Available}$），零向量可以轻易满足这些条件。没有规则规定请求必须是严格正的。该请求被算法处理，而不是直接拒绝。\n  **结论：不正确。**\n\n- **C. 零请求被批准，安全性测试立即将 $Finish[3]$ 设置为 $\\text{true}$ 而不检查 $N_3 \\leq \\vec{Work}$；因此，在考虑其他进程之前，$\\vec{Work}$ 首先变为 $(5, 4, 4)$。**\n  这是不正确的。安全性测试算法与哪个进程发出请求无关。它遵循自己的循环，从索引 0 开始，检查所有 $Finish$ 标志为 false 的进程。它不会给予请求进程特殊的优先级或待遇。在不进行检查的情况下就设置 $Finish[3]$ 的前提违反了算法。\n  **结论：不正确。**\n\n- **D. 零请求被视为资源释放，因此 $\\vec{Available}$ 增加了 $A_3$；因此，安全性测试从 $\\vec{Work} = (5, 4, 4)$ 和 $Finish[3] = \\text{false}$ 开始。**\n  这是不正确的。问题明确指出 $P_3$ 发出的是一个*请求*。请求和释放是不同的操作。请求零资源在语义上不等同于释放一个进程当前持有的所有资源。这个选项混淆了整个资源管理方案中两个不同的部分。\n  **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3678119"}, {"introduction": "接下来，我们来探讨一个无效请求：请求负数个资源。一个健壮的资源管理器应该如何响应？这个练习揭示了输入验证在算法中的重要性，并强调了维持系统不变性（如非负分配和最大需求约束）是确保银行家算法正确运行的前提。[@problem_id:3678032]", "problem": "一个系统运行银行家算法以避免死锁。系统中有 $n=3$ 个进程 $\\{P_0,P_1,P_2\\}$ 和 $m=3$ 种资源类型。总资源向量为 $\\vec{T}=(6,5,7)$。当前的分配矩阵 $Allocation$（行对应于 $P_0,P_1,P_2$）为：\n- $P_0$: $(1,1,2)$\n- $P_1$: $(2,0,3)$\n- $P_2$: $(0,1,1)$\n\n最大需求矩阵 $Max$ 为：\n- $P_0$: $(3,2,3)$\n- $P_1$: $(4,2,3)$\n- $P_2$: $(2,3,2)$\n\n进程 $P_2$ 发出一个资源请求向量 $\\vec{R}_2 = (-1,2,1)$，其中第一个分量为负数。假设资源计数以及 $Allocation$、$Max$、$Need$、$Available$ 和任何请求向量的所有条目都旨在模拟实例计数，因此是非负整数集合的元素。\n\n选择所有关于资源管理器必须做什么以及忽略请求的非负性会产生什么后果的正确陈述：\n\nA. 资源管理器必须立即拒绝 $\\vec{R}_2$ 并保持状态不变，因为在进行任何进一步考虑之前，请求的每个分量都必须按分量满足 $\\vec{R}_2 \\ge \\vec{0}$。\n\nB. 如果跳过非负性检查并执行临时分配步骤 $Available := Available - \\vec{R}_2$ 和 $Allocation_2 := Allocation_2 + \\vec{R}_2$，那么 $Allocation_2$ 会出现负数条目，这违反了所有资源计数都是非负数的不变式。\n\nC. 如果跳过非负性检查，系统仍然是安全的，因为安全检查仍然会阻止任何不安全的授予；因此，没有不变式被违反。\n\nD. 如果跳过非负性检查，$Need_2$ 向量必然按分量减少，这使得完成更加困难，但所有条目都保持在区间 $[0, Max_2]$ 内。\n\nE. 如果跳过非负性检查并执行临时分配，$Need_2$ 向量的某个分量可能会增加到超过 $Max_2$，这使得银行家算法关于最大声明的基本前提失效。\n\n选择所有适用的选项。", "solution": "用户希望我验证问题陈述，如果有效，则根据银行家算法的原则分析给定选项来解决问题。\n\n### 问题验证\n\n**步骤1：提取给定信息**\n- 进程数，$n=3$，表示为 $\\{P_0, P_1, P_2\\}$。\n- 资源类型数，$m=3$。\n- 总资源向量：$\\vec{T}=(6,5,7)$。\n- 分配矩阵，$Allocation$：\n  - $Allocation_0 = (1,1,2)$\n  - $Allocation_1 = (2,0,3)$\n  - $Allocation_2 = (0,1,1)$\n- 最大需求矩阵，$Max$：\n  - $Max_0 = (3,2,3)$\n  - $Max_1 = (4,2,3)$\n  - $Max_2 = (2,3,2)$\n- 来自进程 $P_2$ 的资源请求：$\\vec{R}_2 = (-1,2,1)$。\n- 核心假设：所有资源计数（$Allocation$、$Max$、$Need$、$Available$ 和请求向量中的条目）都是非负整数。\n\n**步骤2：使用提取的信息进行验证**\n该问题具有科学依据，是操作系统中的一个标准主题（死锁避免）。所提供的数据是自洽且一致的。首先，我们计算初始状态向量。\n\n已分配资源的总量是 $Allocation$ 矩阵各行之和：\n$$ \\sum_{i=0}^{2} \\vec{Allocation}_i = (1,1,2) + (2,0,3) + (0,1,1) = (3,2,6) $$\n可用资源向量是总资源减去已分配资源：\n$$ \\vec{Available} = \\vec{T} - \\sum_{i=0}^{2} \\vec{Allocation}_i = (6,5,7) - (3,2,6) = (3,3,1) $$\n需求矩阵 $Need = Max - Allocation$ 对每个进程计算如下：\n- $ \\vec{Need}_0 = \\vec{Max}_0 - \\vec{Allocation}_0 = (3,2,3) - (1,1,2) = (2,1,1) $\n- $ \\vec{Need}_1 = \\vec{Max}_1 - \\vec{Allocation}_1 = (4,2,3) - (2,0,3) = (2,2,0) $\n- $ \\vec{Need}_2 = \\vec{Max}_2 - \\vec{Allocation}_2 = (2,3,2) - (0,1,1) = (2,2,1) $\n\n所有初始数据都是一致的。基本不变式 $\\vec{Allocation}_i \\le \\vec{Max}_i$ 对所有进程都成立。问题是适定的。请求向量 $\\vec{R}_2 = (-1,2,1)$ 由于其负分量而非常规，但问题的目标是分析此类请求的程序和逻辑后果，这是一个有效的理论练习，用于测试对算法不变式和所需检查的理解。问题没有缺陷。\n\n**步骤3：结论和行动**\n问题是有效的。我将继续进行解答。\n\n### 解答推导\n\n进程 $P_i$ 提出请求 $\\vec{R}_i$ 的资源请求算法包括一系列检查，然后进行安全性评估。\n1.  **有效性检查1：** 请求必须按分量非负：$\\vec{R}_i \\ge \\vec{0}$。请求是用于获取资源；释放资源是另一个独立操作。请求中的负分量是一个错误。\n2.  **有效性检查2：** 请求不能超过进程声明的最大需求：$\\vec{R}_i \\le \\vec{Need}_i$。\n3.  **可用性检查：** 请求不能超过当前可用资源：$\\vec{R}_i \\le \\vec{Available}$。\n4.  **临时授予与安全检查：** 如果前三个检查通过，系统临时授予请求，并使用安全算法检查结果状态是否安全。\n    - $\\vec{Available}' = \\vec{Available} - \\vec{R}_i$\n    - $\\vec{Allocation}_i' = \\vec{Allocation}_i + \\vec{R}_i$\n    - $\\vec{Need}_i' = \\vec{Need}_i - \\vec{R}_i$\n    - 如果新状态 $(\\vec{Available}', Allocation', Need')$ 是安全的，则最终授予请求。否则，状态将回滚，$P_i$ 必须等待。\n\n问题要求评估特定请求 $\\vec{R}_2 = (-1,2,1)$ 的后果，以及如果忽略非负性检查（步骤1）会发生什么。\n\n#### 逐项分析\n\n**A. 资源管理器必须立即拒绝 $\\vec{R}_2$ 并保持状态不变，因为在进行任何进一步考虑之前，请求的每个分量都必须按分量满足 $\\vec{R}_2 \\ge \\vec{0}$。**\n请求向量为 $\\vec{R}_2 = (-1,2,1)$。第一个分量是 $-1$，违反了条件 $\\vec{R}_2 \\ge \\vec{0}$。这个条件是资源请求算法中的第一个逻辑检查。其目的是确保请求在物理上是有意义的（不能请求负数个物品），并区分资源获取和资源释放。因此，一个正确实现的资源管理器必须将其识别为错误，立即拒绝该请求，并且不改变系统状态。\n**结论：正确。**\n\n**B. 如果跳过非负性检查并执行临时分配步骤 $Available := Available - \\vec{R}_2$ 和 $Allocation_2 := Allocation_2 + \\vec{R}_2$，那么 $Allocation_2$ 会出现负数条目，这违反了所有资源计数都是非负数的不变式。**\n让我们执行指定的计算。$P_2$ 的初始分配为 $\\vec{Allocation}_2 = (0,1,1)$。请求为 $\\vec{R}_2 = (-1,2,1)$。\n新的临时分配将是：\n$$ \\vec{Allocation}_2' = \\vec{Allocation}_2 + \\vec{R}_2 = (0,1,1) + (-1,2,1) = (0-1, 1+2, 1+1) = (-1,3,2) $$\n新分配向量的第一个分量是 $-1$。这违反了资源分配计数必须是非负整数的基本模型假设。一个进程被分配负数个资源在物理上是不可能的。\n**结论：正确。**\n\n**C. 如果跳过非负性检查，系统仍然是安全的，因为安全检查仍然会阻止任何不安全的授予；因此，没有不变式被违反。**\n这个陈述包含两个论断。论断1：“没有不变式被违反”。如选项B的分析所示，$Allocation$ 矩阵的非负性被违反了。我们将在选项E的分析中看到，$Need \\le Max$ 的不变式也被违反了。所以，这部分陈述是错误的。论断2：“系统仍然是安全的，因为安全检查仍然会阻止任何不安全的授予”。安全算法将在一个已损坏、物理上无意义的状态上运行。在这种条件下，安全算法的任何输出（“安全”或“不安全”）都是无意义的。系统状态不是“安全”的；它是无效的。初步检查的目的正是为了避免用这种无效数据污染核心的安全算法。\n**结论：不正确。**\n\n**D. 如果跳过非负性检查，$Need_2$ 向量必然按分量减少，这使得完成更加困难，但所有条目都保持在区间 $[0, Max_2]$ 内。**\n需求向量的更新规则是 $\\vec{Need}_2' = \\vec{Need}_2 - \\vec{R}_2$。$P_2$ 的初始需求为 $\\vec{Need}_2 = (2,2,1)$。请求为 $\\vec{R}_2 = (-1,2,1)$。\n新的临时需求向量是：\n$$ \\vec{Need}_2' = \\vec{Need}_2 - \\vec{R}_2 = (2,2,1) - (-1,2,1) = (2-(-1), 2-2, 1-1) = (3,0,0) $$\n将 $\\vec{Need}_2'=(3,0,0)$ 与 $\\vec{Need}_2=(2,2,1)$ 比较，第一个分量从 $2$ 增加到了 $3$。因此，向量“必然按分量减少”的说法是错误的。此外，$P_2$ 的最大需求为 $\\vec{Max}_2 = (2,3,2)$。对第一种资源的新需求 $3$ 超过了声明的最大需求 $2$。所以，条目保持在“区间 $[0, Max_2]$ 内”的说法也是错误的。\n**结论：不正确。**\n\n**E. 如果跳过非负性检查并执行临时分配，$Need_2$ 向量的某个分量可能会增加到超过 $Max_2$，这使得银行家算法关于最大声明的基本前提失效。**\n如选项D的计算所示，新的临时需求向量是 $\\vec{Need}_2' = (3,0,0)$。$P_2$ 的最大需求是 $\\vec{Max}_2 = (2,3,2)$。\n我们比较 $\\vec{Need}_2'$ 的第一个分量和 $\\vec{Max}_2$ 的第一个分量：$3 > 2$。\n这违反了银行家算法的一个基本不变式，即对于任何进程 $P_i$，其当前需求必须小于或等于其最大声明，即 $\\vec{Need}_i \\le \\vec{Max}_i$。向量 $\\vec{Need}_i$ 代表达到最大需求尚需的资源，所以它永远不能超过最大值。一个负数请求通过实际上增加进程的总声明超过其已声明的量，从而导致了这种违规。\n**结论：正确。**\n\n总而言之，陈述A、B和E是正确的。陈述A描述了一个正确实现的算法所要求的操作。陈述B和E描述了如果跳过初始检查，会发生的两种不同的、严重的对算法基本不变式的违反。", "answer": "$$\\boxed{ABE}$$", "id": "3678032"}, {"introduction": "掌握了基本规则后，让我们来做一个更深入的定量分析。在资源分配中，系统不仅是“安全”或“不安全”的二元状态，更重要的是了解系统离不安全状态有多近。这个练习要求你精确地找到那个临界点，即多分配一个资源实例就会使系统面临死锁风险，从而锻炼你完整应用安全检查算法并培养对资源管理更深刻的直觉。[@problem_id:3678059]", "problem": "一个操作系统使用银行家算法来避免死锁，该系统有 $n=4$ 个进程 $\\{P_0,P_1,P_2,P_3\\}$ 和 $m=3$ 种资源类型 $\\{A,B,C\\}$。当前状态由下述分配矩阵 (Allocation)、最大需求矩阵 (Max) 和可用资源向量 (Available) 给出：\n$$\n\\text{Allocation} =\n\\begin{pmatrix}\n0  1  0 \\\\\n2  0  0 \\\\\n3  0  2 \\\\\n2  1  1\n\\end{pmatrix},\\quad\n\\text{Max} =\n\\begin{pmatrix}\n7  5  3 \\\\\n3  2  2 \\\\\n9  2  2 \\\\\n4  3  3\n\\end{pmatrix},\\quad\n\\text{Available} =\n\\begin{pmatrix}\n3  3  4\n\\end{pmatrix}.\n$$\n进程 $P_2$ 发出一个仅针对资源类型 $A$ 的请求，该请求由单个整数 $k \\ge 0$ 参数化，其请求向量为\n$$\nRequest_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}.\n$$\n您必须根据银行家算法中的资源请求算法，判断操作系统现在是否会批准 $Request_2(k)$。请仅使用该算法的基本定义，即：需求关系 $\\text{Need} = \\text{Max} - \\text{Allocation}$，请求可接受性检查 $Request_i \\le \\text{Need}_i$ 和 $Request_i \\le \\text{Available}$（均为逐分量比较），以及在试探性地分配所请求资源后，通过是否存在安全序列来定义的安全状态测试。\n\n存在一个最大的整数 $k^\\ast$，使得批准 $Request_2(k^\\ast)$ 会使系统保持在安全状态，而批准 $Request_2(k^\\ast+1)$ 即使满足基本的可接受性检查，也无法通过安全状态测试。请确定这个阈值 $k^\\ast$。\n\n请以单个整数形式给出您的答案（无需四舍五入）。", "solution": "首先验证问题，以确保其科学上成立、定义明确且客观。\n\n### 步骤 1：提取已知条件\n问题为包含 $n=4$ 个进程 $\\{P_0,P_1,P_2,P_3\\}$ 和 $m=3$ 种资源类型 $\\{A,B,C\\}$ 的系统提供了以下数据：\n- 分配矩阵 (Allocation)：\n$$\n\\text{Allocation} =\n\\begin{pmatrix}\n0  1  0 \\\\\n2  0  0 \\\\\n3  0  2 \\\\\n2  1  1\n\\end{pmatrix}\n$$\n- 最大需求矩阵 (Maximum)：\n$$\n\\text{Max} =\n\\begin{pmatrix}\n7  5  3 \\\\\n3  2  2 \\\\\n9  2  2 \\\\\n4  3  3\n\\end{pmatrix}\n$$\n- 可用资源向量 (Available)：\n$$\n\\text{Available} =\n\\begin{pmatrix}\n3  3  4\n\\end{pmatrix}\n$$\n- 进程 $P_2$ 请求 $k \\ge 0$ 个资源类型 $A$ 的实例：\n$$\nRequest_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}\n$$\n- 问题要求找出最大的整数 $k^\\ast$，使得批准 $Request_2(k^\\ast)$ 会得到一个安全状态，而批准 $Request_2(k^\\ast+1)$ 虽然可接受，但会导致不安全状态。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题描述了一个应用银行家算法的标准场景，这是一种操作系统中成熟的死锁避免算法。所提供的数据（矩阵和向量）对于应用此算法是一致且完整的。所使用的术语是精确和标准的。快速的一致性检查表明，系统中的资源总量与已分配和可用的资源相符，且每个进程的最大需求不超过资源总量。该问题在科学上（计算机科学领域内）是成立的、定义明确且客观的。它不违反任何无效标准。因此，该问题是有效的。\n\n### 步骤 3：结论与行动\n问题有效。我们继续进行求解。\n\n### 求解推导\n求解过程需要对进程 $P_2$ 应用资源请求算法。该算法包括两个阶段：可接受性检查和安全性检查。\n\n首先，我们计算 `Need` 矩阵，其定义为 $\\text{Need} = \\text{Max} - \\text{Allocation}$。该矩阵的行 $\\text{Need}_i$ 表示每个进程 $P_i$ 仍然需要的资源。\n$$\n\\text{Need}_0 = \\begin{pmatrix} 7  5  3 \\end{pmatrix} - \\begin{pmatrix} 0  1  0 \\end{pmatrix} = \\begin{pmatrix} 7  4  3 \\end{pmatrix}\n$$\n$$\n\\text{Need}_1 = \\begin{pmatrix} 3  2  2 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  2  2 \\end{pmatrix}\n$$\n$$\n\\text{Need}_2 = \\begin{pmatrix} 9  2  2 \\end{pmatrix} - \\begin{pmatrix} 3  0  2 \\end{pmatrix} = \\begin{pmatrix} 6  2  0 \\end{pmatrix}\n$$\n$$\n\\text{Need}_3 = \\begin{pmatrix} 4  3  3 \\end{pmatrix} - \\begin{pmatrix} 2  1  1 \\end{pmatrix} = \\begin{pmatrix} 2  2  2 \\end{pmatrix}\n$$\n因此，完整的 `Need` 矩阵是：\n$$\n\\text{Need} =\n\\begin{pmatrix}\n7  4  3 \\\\\n1  2  2 \\\\\n6  2  0 \\\\\n2  2  2\n\\end{pmatrix}\n$$\n\n接下来，我们检查 $Request_2(k) = \\begin{pmatrix} k  0  0 \\end{pmatrix}$ 的可接受性。一个请求如果满足两个条件（向量逐分量比较不等式），则被认为是可接受的：\n1.  $Request_2(k) \\le \\text{Need}_2$\n2.  $Request_2(k) \\le \\text{Available}$\n\n应用这些条件：\n1.  $\\begin{pmatrix} k  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 6  2  0 \\end{pmatrix} \\Rightarrow k \\le 6$, $0 \\le 2$, $0 \\le 0$。这意味着 $k \\le 6$。\n2.  $\\begin{pmatrix} k  0  0 \\end{pmatrix} \\le \\begin{pmatrix} 3  3  4 \\end{pmatrix} \\Rightarrow k \\le 3$, $0 \\le 3$, $0 \\le 4$。这意味着 $k \\le 3$。\n\n两个条件必须同时满足，所以 $k$ 必须小于或等于 $3$。由于 $k \\ge 0$，因此只考虑 $k \\in \\{0, 1, 2, 3\\}$ 的请求。任何 $k > 3$ 的请求都会因为可用资源不足而立即被拒绝。\n\n问题陈述中提到 $Request_2(k^\\ast+1)$ 是可接受的。这意味着 $k^\\ast+1 \\le 3$，即 $k^\\ast \\le 2$。我们在寻找导致安全状态的最大的 $k$。我们应该从大到小测试 $k$ 的可能值。$k^\\ast$ 的候选值是 $2$、$1$ 和 $0$。根据问题描述，我们预期随着 $k$ 的增加，会观察到从安全状态到不安全状态的转变。\n\n让我们测试 $k=3$（这对应于潜在的 $k^\\ast = 2$）。\n如果 $k=3$，我们测试批准 $Request_2(3)$ 是否会导致安全状态。首先，我们构建假设的新状态：\n- $Request_2(3) = \\begin{pmatrix} 3  0  0 \\end{pmatrix}$\n- $\\text{Available}' = \\text{Available} - Request_2(3) = \\begin{pmatrix} 3  3  4 \\end{pmatrix} - \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 0  3  4 \\end{pmatrix}$\n- $\\text{Allocation}_2' = \\text{Allocation}_2 + Request_2(3) = \\begin{pmatrix} 3  0  2 \\end{pmatrix} + \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 6  0  2 \\end{pmatrix}$\n- $\\text{Need}_2' = \\text{Need}_2 - Request_2(3) = \\begin{pmatrix} 6  2  0 \\end{pmatrix} - \\begin{pmatrix} 3  0  0 \\end{pmatrix} = \\begin{pmatrix} 3  2  0 \\end{pmatrix}$\n\n现在我们使用 $\\text{Work} = \\text{Available}' = \\begin{pmatrix} 0  3  4 \\end{pmatrix}$ 和 $\\text{Finish} = (\\text{false, false, false, false})$ 来运行安全算法。\n`Need` 向量为 $\\text{Need}_0=(7,4,3)$, $\\text{Need}_1=(1,2,2)$, $\\text{Need}_2'=(3,2,0)$, $\\text{Need}_3=(2,2,2)$。\n- $P_0$ 能运行吗？ $\\text{Need}_0 = (7,4,3) \\not\\le (0,3,4)$。不能。\n- $P_1$ 能运行吗？ $\\text{Need}_1 = (1,2,2) \\not\\le (0,3,4)$。不能。\n- $P_2$ 能运行吗？ $\\text{Need}_2' = (3,2,0) \\not\\le (0,3,4)$。不能。\n- $P_3$ 能运行吗？ $\\text{Need}_3 = (2,2,2) \\not\\le (0,3,4)$。不能。\n没有进程可以获取其所需资源。安全算法未能找到可以完成的进程。因此，批准 $Request_2(3)$ 后的状态是 **不安全的**。\n\n这个 $k=3$ 的结果与问题描述中 $k^\\ast+1$ 的状态相符。这表明 $k^\\ast=2$。为了确认这一点，我们必须验证批准 $Request_2(2)$ 会导致一个 **安全** 状态。\n\n让我们测试 $k=2$。\n- $Request_2(2) = \\begin{pmatrix} 2  0  0 \\end{pmatrix}$。这是可接受的，因为 $2 \\le 3$ 且 $2 \\le 6$。\n- 假设的新状态：\n  - $\\text{Available}'' = \\text{Available} - Request_2(2) = \\begin{pmatrix} 3  3  4 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 1  3  4 \\end{pmatrix}$\n  - $\\text{Allocation}_2'' = \\text{Allocation}_2 + Request_2(2) = \\begin{pmatrix} 3  0  2 \\end{pmatrix} + \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 5  0  2 \\end{pmatrix}$\n  - $\\text{Need}_2'' = \\text{Need}_2 - Request_2(2) = \\begin{pmatrix} 6  2  0 \\end{pmatrix} - \\begin{pmatrix} 2  0  0 \\end{pmatrix} = \\begin{pmatrix} 4  2  0 \\end{pmatrix}$\n\n使用 $\\text{Work} = \\text{Available}'' = \\begin{pmatrix} 1  3  4 \\end{pmatrix}$ 和 $\\text{Finish} = (\\text{false, false, false, false})$ 运行安全算法。\n`Need` 向量为 $\\text{Need}_0=(7,4,3)$, $\\text{Need}_1=(1,2,2)$, $\\text{Need}_2''=(4,2,0)$, $\\text{Need}_3=(2,2,2)$。\n`Allocation` 向量（在一个进程结束后使用）是 $\\text{Allocation}_0=(0,1,0)$, $\\text{Allocation}_1=(2,0,0)$, $\\text{Allocation}_2''=(5,0,2)$, $\\text{Allocation}_3=(2,1,1)$。\n\n1.  初始化 $\\text{Work} = (1, 3, 4)$，$\\text{Finish} = (F, F, F, F)$。\n2.  寻找一个进程 $P_i$ 满足 $\\text{Finish}_i = F$ 且 $\\text{Need}_i \\le \\text{Work}$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (1,3,4)$。\n    - $P_1$：$\\text{Need}_1=(1,2,2) \\le (1,3,4)$。可以。\n    - 执行 $P_1$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_1 = (1,3,4) + (2,0,0) = (3,3,4)$。\n      $\\text{Finish} = (F, T, F, F)$。\n3.  寻找下一个进程。当前 $\\text{Work} = (3,3,4)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (3,3,4)$。\n    - $P_2$：$\\text{Need}_2''=(4,2,0) \\not\\le (3,3,4)$。\n    - $P_3$：$\\text{Need}_3=(2,2,2) \\le (3,3,4)$。可以。\n    - 执行 $P_3$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_3 = (3,3,4) + (2,1,1) = (5,4,5)$。\n      $\\text{Finish} = (F, T, F, T)$。\n4.  寻找下一个进程。当前 $\\text{Work} = (5,4,5)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\not\\le (5,4,5)$。\n    - $P_2$：$\\text{Need}_2''=(4,2,0) \\le (5,4,5)$。可以。\n    - 执行 $P_2$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_2'' = (5,4,5) + (5,0,2) = (10,4,7)$。\n      $\\text{Finish} = (F, T, T, T)$。\n5.  寻找下一个进程。当前 $\\text{Work} = (10,4,7)$。\n    - $P_0$：$\\text{Need}_0=(7,4,3) \\le (10,4,7)$。可以。\n    - 执行 $P_0$：\n      $\\text{Work} = \\text{Work} + \\text{Allocation}_0 = (10,4,7) + (0,1,0) = (10,5,7)$。\n      $\\text{Finish} = (T, T, T, T)$。\n\n所有进程都可以完成。已经找到了一个安全序列，例如 $\\langle P_1, P_3, P_2, P_0 \\rangle$。因此，批准 $Request_2(2)$ 后的状态是 **安全的**。\n\n我们已经证明：\n- 对于 $k=2$，请求被批准（可接受且导致安全状态）。\n- 对于 $k=3$，请求不被批准（可接受但导致不安全状态）。\n\n这与问题中对 $k^\\ast=2$ 和 $k^\\ast+1=3$ 的定义相符。请求被批准的最大整数 $k^\\ast$ 是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3678059"}]}