{"hands_on_practices": [{"introduction": "在掌握了如何判断一个状态是否安全之后 ([@problem_id:3678795])，我们进一步探讨安全与不安全状态之间的临界条件。这个练习 [@problem_id:3678749] 模拟了一个资源不足的场景，系统当前处于不安全状态。你需要计算为了使系统恢复安全，至少需要增加多少特定类型的资源。这个问题将引导你从静态分析转向动态的资源规划，理解安全状态对系统资源总量的敏感性，这在现实世界的容量规划和系统设计中至关重要。", "problem": "一个操作系统正在管理 $m=2$ 种不同的资源类型，表示为 $R_1$ 和 $R_2$。系统中有 $n=3$ 个独立进程 $P_0$、$P_1$ 和 $P_2$。系统范围内的资源总量为 $R_1^{\\text{tot}}=100$ 和 $R_2^{\\text{tot}}=3$。系统的当前状态由每个进程的当前分配向量（Allocation vector）和其声明的最大需求向量（Maximum vector）指定，以有序对 $(R_1,R_2)$ 的形式给出：\n- $P_0$：分配 $(10,1)$，最大需求 $(20,3)$。\n- $P_1$：分配 $(15,1)$，最大需求 $(25,3)$。\n- $P_2$：分配 $(5,1)$，最大需求 $(15,3)$。\n\n不存在其他进程。假设允许做的唯一更改是将 $R_2$ 的总量增加一个整数 $\\Delta \\ge 0$（使得 $R_2^{\\text{tot}}$ 变为 $3+\\Delta$），而分配量和最大需求量保持不变。目标是利用资源分配系统中安全状态的标准概念：如果存在某个进程完成序列，使得序列中的每个进程都能从轮到它时可用的资源中获取其剩余所需资源，并在完成后释放其分配的资源，从而可能使下一个进程得以执行，直到所有进程都完成，则该状态是安全的。\n\n确定最小的整数 $\\Delta$，使得仅将 $R_2^{\\text{tot}}$ 增加 $\\Delta$ 后，得到的状态是安全的。将 $\\Delta$ 的值以单个整数形式报告。无需四舍五入。", "solution": "问题要求找出使给定系统状态安全的最小整数值 $\\Delta \\ge 0$。初始总资源为 $R_1^{\\text{tot}}=100$ 和 $R_2^{\\text{tot}}=3$。$R_2$ 的数量增加到新的总量 $R_{2, \\text{new}}^{\\text{tot}} = 3 + \\Delta$。这个问题可以通过应用银行家算法来解决。\n\n首先，让我们将系统状态形式化。进程数量为 $n=3$，资源类型数量为 $m=2$。\n\n资源向量定义如下：\n系统中可用资源的总向量（Total）为 $E = (R_1^{\\text{tot}}, R_{2, \\text{new}}^{\\text{tot}}) = (100, 3+\\Delta)$。\n\n`Allocation` 矩阵（A）指定了当前分配给每个进程的资源。\n对 $P_0$：$A_0 = (10, 1)$\n对 $P_1$：$A_1 = (15, 1)$\n对 $P_2$：$A_2 = (5, 1)$\n$$ A = \\begin{pmatrix} 10 & 1 \\\\ 15 & 1 \\\\ 5 & 1 \\end{pmatrix} $$\n\n`Maximum` 矩阵（M）指定了每个进程可能请求的最大资源。\n对 $P_0$：$M_0 = (20, 3)$\n对 $P_1$：$M_1 = (25, 3)$\n对 $P_2$：$M_2 = (15, 3)$\n$$ M = \\begin{pmatrix} 20 & 3 \\\\ 25 & 3 \\\\ 15 & 3 \\end{pmatrix} $$\n\n接下来，我们计算 `Need` 矩阵（N），它表示每个进程完成其任务所需的剩余资源。进程 $i$ 的 `Need` 计算为 $N_i = M_i - A_i$。\n对 $P_0$：$N_0 = (20, 3) - (10, 1) = (10, 2)$\n对 $P_1$：$N_1 = (25, 3) - (15, 1) = (10, 2)$\n对 $P_2$：$N_2 = (15, 3) - (5, 1) = (10, 2)$\n$$ N = \\begin{pmatrix} 10 & 2 \\\\ 10 & 2 \\\\ 10 & 2 \\end{pmatrix} $$\n\n现在，我们计算 `Available` 向量（V），它表示当前未分配的资源。这是通过从总资源中减去所有已分配资源的总和来得到的。\n首先，通过对 `Allocation` 矩阵的列求和来找出总已分配资源：\n已分配的 $R_1$ 总量 = $10 + 15 + 5 = 30$。\n已分配的 $R_2$ 总量 = $1 + 1 + 1 = 3$。\n所以，总分配向量是 $(30, 3)$。\n\n`Available` 向量 $V$ 是：\n$V = E - (30, 3) = (100, 3+\\Delta) - (30, 3) = (70, \\Delta)$。\n\n安全性算法用于确定当前状态是否安全。如果存在一个进程序列 $\\langle P_{i_1}, P_{i_2}, \\dots, P_{i_n} \\rangle$，使得序列中的每个进程都能完成，则状态是安全的。安全性算法通过模拟寻找这样一个序列来工作。\n\n1.  设一个工作向量 $Work = Available = (70, \\Delta)$。\n2.  寻找一个进程 $P_i$，使其满足 $Need_i \\le Work$。\n    *   所有进程的需求都相同：$N_0 = N_1 = N_2 = (10, 2)$。\n    *   因此，条件是 $(10, 2) \\le (70, \\Delta)$。\n    *   这分解为两个不等式：$10 \\le 70$（成立）和 $2 \\le \\Delta$。\n3.  为了让算法能够找到第一个可执行的进程，$\\Delta$ 必须至少为 2。所以，最小的整数 $\\Delta$ 是 2。\n\n我们来验证当 $\\Delta=2$ 时，状态确实是安全的。\n*   初始 $Available = (70, 2)$。$Work = (70, 2)$。\n*   我们可以选择任何一个进程开始，例如 $P_0$，因为 $N_0 = (10, 2) \\le (70, 2)$。\n*   模拟 $P_0$ 完成并释放其资源：\n    $Work = Work + A_0 = (70, 2) + (10, 1) = (80, 3)$。\n*   现在，我们可以选择 $P_1$ 或 $P_2$。选择 $P_1$，因为 $N_1 = (10, 2) \\le (80, 3)$。\n*   模拟 $P_1$ 完成并释放其资源：\n    $Work = Work + A_1 = (80, 3) + (15, 1) = (95, 4)$。\n*   最后，只剩下 $P_2$，$N_2 = (10, 2) \\le (95, 4)$。\n*   $P_2$ 可以完成。\n\n由于我们找到了一个安全序列（例如 $\\langle P_0, P_1, P_2 \\rangle$），当 $\\Delta=2$ 时系统是安全的。因此，所需的最小整数 $\\Delta$ 是 2。", "answer": "$$\n\\boxed{2}\n$$", "id": "3678749"}, {"introduction": "前面的练习 [@problem_id:3678749] 关注于达到安全状态的最低条件，现在我们来更深入地探索安全状态的“丰富性”。一个安全状态保证了至少存在一条安全序列，但通常不止一条。这个练习 [@problem_id:3678785] 要求你找出一个给定状态下的所有安全序列，从而理解系统在资源调度上的灵活性。此外，本练习还引入了银行家算法的另一半关键功能——资源请求算法，通过评估批准一个新请求是否会导致系统进入不安全状态，让你全面掌握如何利用该算法在实践中动态地避免死锁。", "problem": "考虑一个系统，其中有 $n=3$ 个进程（标记为 $P_0$、$P_1$ 和 $P_2$）和 $m=1$ 种可重用资源类型。当前快照显示有 $Available=1$ 个可用实例，当前的 $Allocation$ 向量为 $[1,0,0]$（分别对应于 $P_0$、$P_1$、$P_2$），以及 $Max$ 向量为 $[2,1,1]$（表示每个进程声明的最大需求）。假设在标准设定下，当一个进程完成时，它会立即释放其持有的所有实例。一个状态是安全的，当且仅当存在一个所有进程的排列，使得每个进程都能从当前可用的资源加上先前已完成进程将释放的资源中，获得其剩余所需的实例。\n定义 $S$ 为在标准安全检查下，从给定快照出发可行的不同安全序列（所有3个进程的全排列）的数量。接下来，对于每个 $i \\in \\{0,1,2\\}$，考虑一个来自进程 $P_i$ 的大小为1的假设性立即单实例请求（在此快照中，每个此类请求都在该进程的剩余需求范围内）。设 $U$ 为这样的索引 $i$ 的数量：立即批准该请求（并相应更新快照）将使系统进入不安全状态。\n计算单个整数 $S - U$。最终答案以不带单位的整数表示，无需四舍五入。", "solution": "该问题要求计算 $S - U$，其中 $S$ 是安全序列的数量，$U$ 是导致不安全状态的请求数量。\n\n### 步骤 1：计算 `Need` 向量\n`Need` 向量表示每个进程为完成任务还需要的资源量，计算公式为 $Need = Max - Allocation$。\n- $Need_0 = Max_0 - Allocation_0 = 2 - 1 = 1$\n- $Need_1 = Max_1 - Allocation_1 = 1 - 0 = 1$\n- $Need_2 = Max_2 - Allocation_2 = 1 - 0 = 1$\n因此，`Need` 向量为 $[1, 1, 1]$。\n\n### 步骤 2：计算 $S$，即安全序列的数量\n我们使用安全性算法来确定是否存在安全序列，并计算其数量。\n- 初始可用资源 $Work = Available = 1$。\n- 检查哪个进程可以执行：\n  - $P_0$: $Need_0 = 1 \\le Work = 1$。可以执行。\n  - $P_1$: $Need_1 = 1 \\le Work = 1$。可以执行。\n  - $P_2$: $Need_2 = 1 \\le Work = 1$。可以执行。\n- 由于任何一个进程都可以作为序列的第一个进程，我们来分析其中一种情况，例如选择 $P_0$ 作为第一个执行的进程。\n  - $P_0$ 执行完毕后，释放其资源。新的可用资源 $Work = Available + Allocation_0 = 1 + 1 = 2$。\n  - 剩下的进程是 $P_1$ 和 $P_2$。它们的需求分别为 $Need_1=1$ 和 $Need_2=1$。两者都小于新的可用资源 $Work=2$。因此，剩下的两个进程可以按任意顺序执行（$P_1$ 然后 $P_2$，或者 $P_2$ 然后 $P_1$）。\n- 这表明，只要选择任何一个进程作为第一个，剩下的进程总能完成。由于有 3 个进程，第一个进程有 3 种选择，第二个有 2 种，第三个有 1 种。所有 $3! = 3 \\times 2 \\times 1 = 6$ 种排列都是有效的安全序列。\n- 因此，$S = 6$。\n\n### 步骤 3：计算 $U$，即导致不安全状态的请求数量\n我们需要逐一考虑每个进程 $P_i$ 发出一个单位资源请求的情况。\n- 初始状态：$Available=1$, $Allocation=[1,0,0]$, $Need=[1,1,1]$。\n- 请求是有效的，因为请求量 (1) 不超过任何进程的需求 ($Need_i=1$)，并且可行，因为请求量 (1) 不超过可用资源 ($Available=1$)。\n\n**情况 1：批准 $P_0$ 的请求**\n- 预分配：\n  - $Available = 1 - 1 = 0$\n  - $Allocation = [1+1, 0, 0] = [2, 0, 0]$\n  - $Need = [1-1, 1, 1] = [0, 1, 1]$\n- 安全性检查：\n  - 初始 $Work = 0$。\n  - $P_0$ 的 $Need_0 = 0 \\le Work$，可以执行。执行后，$Work = Work + Allocation_0 = 0 + 2 = 2$。\n  - 剩下 $P_1, P_2$。$Need_1=1 \\le 2$，$Need_2=1 \\le 2$。它们都可以执行。\n- 结论：状态是 **安全** 的。\n\n**情况 2：批准 $P_1$ 的请求**\n- 预分配：\n  - $Available = 1 - 1 = 0$\n  - $Allocation = [1, 0+1, 0] = [1, 1, 0]$\n  - $Need = [1, 1-1, 1] = [1, 0, 1]$\n- 安全性检查：\n  - 初始 $Work = 0$。\n  - $P_1$ 的 $Need_1 = 0 \\le Work$，可以执行。执行后，$Work = Work + Allocation_1 = 0 + 1 = 1$。\n  - 剩下 $P_0, P_2$。$Need_0=1 \\le 1$，$Need_2=1 \\le 1$。它们都可以执行。\n- 结论：状态是 **安全** 的。\n\n**情况 3：批准 $P_2$ 的请求**\n- 预分配：\n  - $Available = 1 - 1 = 0$\n  - $Allocation = [1, 0, 0+1] = [1, 0, 1]$\n  - $Need = [1, 1, 1-1] = [1, 1, 0]$\n- 安全性检查：\n  - 初始 $Work = 0$。\n  - $P_2$ 的 $Need_2 = 0 \\le Work$，可以执行。执行后，$Work = Work + Allocation_2 = 0 + 1 = 1$。\n  - 剩下 $P_0, P_1$。$Need_0=1 \\le 1$，$Need_1=1 \\le 1$。它们都可以执行。\n- 结论：状态是 **安全** 的。\n\n由于所有三种情况（批准 $P_0$, $P_1$, 或 $P_2$ 的请求）都导致安全状态，因此导致不安全状态的请求数量为 0。\n- 因此，$U = 0$。\n\n### 步骤 4：计算最终结果\n$S - U = 6 - 0 = 6$。", "answer": "$$\\boxed{6}$$", "id": "3678785"}]}