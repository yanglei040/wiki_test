{"hands_on_practices": [{"introduction": "银行家算法的核心在于其数据结构，特别是 $Need$ 需求矩阵。本练习将引导你设计一种高效的混合数据结构来表示 $Need$ 矩阵，通过分析时间和空间成本，你将学会在密集和稀疏两种表示方法之间做出明智选择。这个过程不仅能加深你对数据结构设计的理解，还能让你体会到在真实世界系统中，如何根据数据特性进行性能优化。[@problem_id:3622587]", "problem": "您正在设计数据结构，用于表示银行家死锁避免算法中的剩余资源需求矩阵 $Need$。银行家算法使用一种安全性检查：一个包含 $P$ 个进程和 $R$ 种资源类型的系统状态是安全的，前提是存在一个包含所有进程的序列，使得每个进程 $i$ 的需求都能由当前可用资源满足，即对于所有资源类型 $r$ 都有 $Need[i, r] \\leq Available[r]$，并且该进程完成时会释放其已分配的资源以供后续进程使用。基本定义是：$Need = Max - Allocation$（逐元素计算），其中对于所有进程 $i$ 和资源 $r$，都有 $Need[i, r] \\geq 0$。模拟一次典型的安全性检查需要对所有 $r$ 进行形如 $Need[i, r] \\leq Work[r]$ 的重复比较（其中 $Work$ 是 $Available$ 的一个副本，并随着进程的完成而更新）。\n\n您的任务是为矩阵 $Need$ 构建并分析一种混合列式表示法，其中每种资源类型 $r$ 对应一列。对于每列 $r$，可选择以下两种表示法之一：\n\n- 密集数组表示法：将所有 $P$ 个条目 $Need[0, r], Need[1, r], \\dots, Need[P-1, r]$ 存储为32位有符号整数。\n- 稀疏位集加值表示法：适用于列中非零条目数量 $k$ 较小的情况。该表示法包括：\n  - 一个包含 $P$ 位的位集，每个位对应一个进程索引 $i$，用于指示 $Need[i, r] \\neq 0$ 是否成立。\n  - 一个每字前缀数组，用于支持常数时间秩查询（计算到给定索引为止的置位位数），位集的每个机器字对应一个32位整数。\n  - 一个长度为 $k$ 的紧凑值数组，用于将非零的 $Need$ 值存储为16位无符号整数（假设所有 $Need[i, r]$ 都在 $[0, 65535]$ 范围内）。这些值按进程索引递增的顺序存储，以便与秩计算对齐。\n\n假设计算和内存模型具有以下经过充分测试的事实：\n- 密集表示法每个条目使用 $b_{\\text{int}} = 4$ 字节，因此一个密集列消耗 $P \\cdot b_{\\text{int}}$ 字节。\n- 稀疏位集使用 $w = 64$ 位的字。位集消耗 $\\lceil P/8 \\rceil$ 字节。前缀数组在位集的每个字上有一个32位整数，消耗 $\\lceil P/w \\rceil \\cdot b_{\\text{pref}}$ 字节，其中每个条目 $b_{\\text{pref}} = 4$ 字节。紧凑值数组消耗 $k \\cdot b_{\\text{val}}$ 字节，其中 $b_{\\text{val}} = 2$ 字节。\n- 在安全性检查中，比较密集形式下的一个进程-资源对的成本为：读取密集整数的成本 $c_{\\text{array}}$ 和进行不等式检查的成本 $c_{\\text{cmp}}$。\n- 在稀疏形式下，对于一个进程-资源对，测试位的成本为 $c_{\\text{bit}}$。如果该位为 $0$（概率为 $1 - f$，其中 $f = k/P$ 是非零比例），则不需要进一步操作。如果该位为 $1$（概率为 $f$），则计算秩以定位紧凑值的成本为 $c_{\\text{rank}}$，读取紧凑值的成本为 $c_{\\text{val}}$，以及执行不等式检查的成本为 $c_{\\text{cmp}}$。\n\n基于这些基本原理（银行家安全性检查以及所述的成本和内存模型），从第一性原理出发，推导出确定稀疏表示法在时间和内存两方面都比密集表示法更高效的交叉条件。具体来说，您必须：\n- 推导密集和稀疏表示法下每对的预期时间成本，将其表示为非零比例 $f$ 和常量 $c_{\\text{array}}, c_{\\text{cmp}}, c_{\\text{bit}}, c_{\\text{rank}}, c_{\\text{val}}$ 的函数。\n- 求解交叉非零比例 $f^\\star$，在该比例下稀疏表示法的预期时间成本等于密集表示法的时间成本。根据时间效率解释 $f  f^\\star$ 和 $f > f^\\star$ 这两种情况。\n- 推导具有 $P$ 个进程和 $k$ 个非零条目的列的稀疏内存成本，包括位集和前缀数组的开销，并求解使得稀疏内存不超过密集内存的最大整数基数 $k^\\star$。\n- 为列定义一个确定性的混合选择规则：当且仅当稀疏表示法在时间（对于实际的 $f = k/P$）和内存两方面都严格更优时，选择稀疏表示法；否则选择密集表示法。在任一维度上成本完全相等的情况下，优先选择密集表示法。\n\n您的程序必须实现这些推导，并在以下列参数测试套件上评估混合选择。对于所有测试，请使用固定的常量 $b_{\\text{int}} = 4$, $b_{\\text{val}} = 2$, $b_{\\text{pref}} = 4$, $w = 64$, $c_{\\text{array}} = 1.0$, $c_{\\text{cmp}} = 0.5$, $c_{\\text{bit}} = 0.2$, $c_{\\text{rank}} = 0.4$, $c_{\\text{val}} = 0.8$。每个测试用例提供 $(P, k)$：\n\n- 测试用例A（通用理想路径）：$P = 64$, $k = 4$。\n- 测试用例B（边界情况，完全密集）：$P = 64$, $k = 64$。\n- 测试用例C（大 $P$，非常稀疏）：$P = 1024$, $k = 32$。\n- 测试用例D（大 $P$，中等稀疏）：$P = 1024$, $k = 600$。\n\n对于每个测试用例，您的程序必须计算：\n- 交叉比例 $f^\\star$，作为一个四舍五入到六位小数的浮点值。\n- 内存交叉阈值 $k^\\star$，作为一个整数。\n- 针对实际 $f = k/P$ 的时间效率布尔值，如果稀疏表示法严格更快则为 $1$，否则为 $0$。\n- 内存效率布尔值，如果稀疏表示法使用的字节数严格更少则为 $1$，否则为 $0$。\n- 最终的混合选择，根据上述确定性规则，选择稀疏表示法为 $1$，选择密集表示法为 $0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例按A、B、C、D的顺序贡献一个子列表。每个子列表必须是 $[f^\\star, k^\\star, \\text{time\\_sparse\\_better}, \\text{memory\\_sparse\\_better}, \\text{choice}]$ 的形式，其中 $f^\\star$ 是一个四舍五入到六位小数的浮点数，其他条目是整数。例如，整个单行输出应类似于 $[[x_1,y_1,a_1,b_1,c_1],[x_2,y_2,a_2,b_2,c_2],[x_3,y_3,a_3,b_3,c_3],[x_4,y_4,a_4,b_4,c_4]]$，不含空格。", "solution": "该问题要求推导交叉条件，以确定银行家算法 $Need$ 矩阵中某一列的最优数据结构。选择在于密集数组和一种专门的稀疏表示法之间。选择标准是在处理时间和内存使用两方面都有严格的效率提升。\n\n分析过程是基于所提供的参数，为每种表示法推导时间和内存成本的数学模型，然后确定它们各自成本相等的交叉点。\n\n提供的常量如下：\n- 内存常量：整数大小 $b_{\\text{int}} = 4$ 字节，稀疏值大小 $b_{\\text{val}} = 2$ 字节，前缀数组条目大小 $b_{\\text{pref}} = 4$ 字节，以及机器字大小 $w = 64$ 位。\n- 时间成本常量：密集数组读取 $c_{\\text{array}} = 1.0$，比较 $c_{\\text{cmp}} = 0.5$，稀疏位测试 $c_{\\text{bit}} = 0.2$，稀疏秩计算 $c_{\\text{rank}} = 0.4$，以及稀疏值读取 $c_{\\text{val}} = 0.8$。\n\n设 $P$ 为进程数，$k$ 为 $Need$ 矩阵一列中的非零条目数。非零条目的比例为 $f = k/P$。\n\n**1. 预期时间成本分析**\n\n时间成本是针对单个进程-资源对的比较 $Need[i, r] \\leq Work[r]$ 进行分析的。\n\n**密集表示法的时间成本：**\n密集表示法的成本是恒定的。它涉及一次数组访问以读取值和一次比较。\n$$T_{\\text{dense}} = c_{\\text{array}} + c_{\\text{cmp}}$$\n\n**稀疏表示法的预期时间成本：**\n稀疏表示法的成本取决于条目 $Need[i, r]$ 是零还是非零。\n首先，在位集中测试一个位，成本为 $c_{\\text{bit}}$。\n位为 $0$（表示一个零值条目）的概率是 $(1 - f)$。在这种情况下，不需要进一步操作，因为 $0 \\leq Work[r]$ 总是成立。\n位为 $1$（表示一个非零条目）的概率是 $f$。在这种情况下，需要额外的工作：计算秩以找到值的索引（成本 $c_{\\text{rank}}$），读取紧凑值（成本 $c_{\\text{val}}$），并执行比较（成本 $c_{\\text{cmp}}$）。\n预期时间成本 $T_{\\text{sparse}}$ 是初始位测试成本与处理非零条目的预期成本之和：\n$$T_{\\text{sparse}}(f) = c_{\\text{bit}} + f \\cdot (c_{\\text{rank}} + c_{\\text{val}} + c_{\\text{cmp}})$$\n\n**时间交叉比例 ($f^\\star$)：**\n交叉比例 $f^\\star$ 是两种时间成本相等时的 $f$ 值，即 $T_{\\text{dense}} = T_{\\text{sparse}}(f^\\star)$。\n$$c_{\\text{array}} + c_{\\text{cmp}} = c_{\\text{bit}} + f^\\star \\cdot (c_{\\text{rank}} + c_{\\text{val}} + c_{\\text{cmp}})$$\n求解 $f^\\star$：\n$$f^\\star \\cdot (c_{\\text{rank}} + c_{\\text{val}} + c_{\\text{cmp}}) = c_{\\text{array}} + c_{\\text{cmp}} - c_{\\text{bit}}$$\n$$f^\\star = \\frac{c_{\\text{array}} + c_{\\text{cmp}} - c_{\\text{bit}}}{c_{\\text{rank}} + c_{\\text{val}} + c_{\\text{cmp}}}$$\n代入给定的成本常量：\n$$f^\\star = \\frac{1.0 + 0.5 - 0.2}{0.4 + 0.8 + 0.5} = \\frac{1.3}{1.7} \\approx 0.76470588...$$\n如果实际的非零元素比例 $f$ 小于 $f^\\star$，即 $f  f^\\star$，则稀疏表示法在时间上严格更高效。\n\n**2. 内存成本分析**\n\n**密集表示法的内存成本：**\n密集表示法存储 $P$ 个条目，每个条目的大小为 $b_{\\text{int}}$。\n$$M_{\\text{dense}}(P) = P \\cdot b_{\\text{int}}$$\n\n**稀疏表示法的内存成本：**\n稀疏表示法的内存成本是其三个组成部分的总和：\n1.  **位集**：需要 $P$ 个位。内存成本为 $\\lceil P/8 \\rceil$ 字节。\n2.  **前缀数组**：位集使用的每个 $w$ 位机器字存储一个 $b_{\\text{pref}}$ 字节的条目。字的数量是 $\\lceil P/w \\rceil$。内存成本为 $\\lceil P/w \\rceil \\cdot b_{\\text{pref}}$ 字节。\n3.  **紧凑值**：存储 $k$ 个非零值，每个值的大小为 $b_{\\text{val}}$。内存成本为 $k \\cdot b_{\\text{val}}$ 字节。\n\n稀疏表示法的总内存成本为：\n$$M_{\\text{sparse}}(P, k) = \\lceil P/8 \\rceil + \\lceil P/w \\rceil \\cdot b_{\\text{pref}} + k \\cdot b_{\\text{val}}$$\n这里，向上取整函数 $\\lceil x/y \\rceil$ 对于正整数 $x, y$ 可以使用整数算术 $(x + y - 1) / y$ 来计算。\n\n**内存交叉基数 ($k^\\star$)：**\n问题将 $k^\\star$ 定义为使得稀疏表示法的内存使用量不超过密集表示法的最大非零条目整数数量 $k$。\n$$M_{\\text{sparse}}(P, k) \\le M_{\\text{dense}}(P)$$\n$$\\lceil P/8 \\rceil + \\lceil P/w \\rceil \\cdot b_{\\text{pref}} + k \\cdot b_{\\text{val}} \\le P \\cdot b_{\\text{int}}$$\n求解 $k$：\n$$k \\cdot b_{\\text{val}} \\le P \\cdot b_{\\text{int}} - \\left( \\lceil P/8 \\rceil + \\lceil P/w \\rceil \\cdot b_{\\text{pref}} \\right)$$\n$$k \\le \\frac{P \\cdot b_{\\text{int}} - \\lceil P/8 \\rceil - \\lceil P/w \\rceil \\cdot b_{\\text{pref}}}{b_{\\text{val}}}$$\n由于 $k$ 必须是整数，$k^\\star$ 是右侧表达式的向下取整：\n$$k^\\star = \\left\\lfloor \\frac{P \\cdot b_{\\text{int}} - \\lceil P/8 \\rceil - \\lceil P/w \\rceil \\cdot b_{\\text{pref}}}{b_{\\text{val}}} \\right\\rfloor$$\n如果 $M_{\\text{sparse}}(P, k)  M_{\\text{dense}}(P)$，则稀疏表示法在内存上严格更高效。\n\n**3. 混合选择规则**\n\n当且仅当列的稀疏表示法在时间和内存两方面都严格优于密集表示法时，才选择稀疏表示法。否则，选择密集表示法。这意味着，如果在任一维度上成本/内存出现平局，则优先选择密集表示法。\n选择稀疏表示法的条件是：\n1.  **时间**：$T_{\\text{sparse}}(k/P)  T_{\\text{dense}} \\iff k/P  f^\\star$。\n2.  **内存**：$M_{\\text{sparse}}(P, k)  M_{\\text{dense}}(P)$。\n\n如果两个条件都满足，则选择稀疏（用 $1$ 表示）。否则，选择密集（用 $0$ 表示）。这些推导出的公式在C程序中实现，用于评估指定的测试用例。", "answer": "[[0.764706,122,1,1,1],[0.764706,122,0,1,0],[0.764706,1952,1,1,1],[0.764706,1952,1,1,1]]", "id": "3622587"}, {"introduction": "在银行家算法的安全检查中，频繁扫描以查找未完成的进程是性能的关键瓶颈之一。本练习聚焦于 $Finish$ 标志数组的实现，通过对比传统的布尔数组和紧凑的位集合两种数据结构，来量化分析性能差异。你将探索如何利用位级并行（bit-level parallelism）和硬件指令来加速扫描过程，从而深刻体会底层数据表示对算法效率的决定性影响。[@problem_id:3622562]", "problem": "考虑一个管理 $N$ 个进程的操作系统中，银行家算法的安全性检查循环所使用的数组 $Finish$ 的数据结构选择。数组 $Finish$ 记录哪些进程已完成安全性检查，其中 $Finish[i] = 1$ 表示已完成，$Finish[i] = 0$ 表示未完成。你需要比较两种表示方法和扫描策略，在对所有 $N$ 个进程进行一次完整扫描期间，用于识别未完成的进程。\n\n假设以下基本事实和定义：\n- 工作量与基本操作的计数成正比；期望总工作量是这些操作的期望计数之和。\n- 一个紧凑位集每个比特存储一个布尔值，并且可以一次处理一个机器字。\n- 寻找第一个置位 (FFS) 操作在常数时间内返回一个字中最低有效置位的索引。\n\n你将比较：\n1. 一个存储为字节的布尔数组（每个标志占用一个字节），顺序扫描。\n2. 一个存储在 $64$ 位字中的紧凑位集；扫描使用字级操作和寻找第一个置位 (FFS) 原语，通过对每个字的按位取反结果进行操作来枚举未完成进程的索引。\n\n假设：\n- 共有 $N = 4096$ 个进程。\n- 每个进程独立地以 $0.9$ 的概率完成，并以 $0.1$ 的概率未完成。\n- 在字节数组表示法中，扫描每个条目会产生每个被检查条目 $c_b = 1$ 个操作的固定成本。此外，每次检测到一个未完成的进程时，处理它会产生 $c_u = 2$ 个操作的固定开销（例如，将索引入队以进行后续的可接纳性检查）。同样的开销 $c_u$ 适用于两种表示法。\n- 在位集表示法中：\n  - 位集被划分为连续的 $64$ 位字；将字的數量表示为 $W$。\n  - 对于每个 $64$ 位字，执行一次 $64$ 位加载、一次按位取反和一次零测试，每个操作的成本分别为 $c_L = 1$、$c_I = 1$ 和 $c_Z = 1$。\n  - 对于字内的每个未完成进程（在取反后的掩码中为 $1$ 的位），除了共享的开销 $c_u = 2$ 之外，还执行一次成本为 $c_F=3$ 的FFS操作和一次成本为 $c_C=1$ 的清除最低置位操作。\n- 使用独立性和期望的线性性质来处理期望值；除了所述成本外，不要假设任何额外的分支或缓存惩罚。\n\n请从第一性原理推导出每种表示方法在一次完整扫描中的期望总操作数，然后计算期望加速比\n$$S = \\frac{\\text{字节数组扫描的期望总操作数}}{\\text{位集扫描的期望总操作数}}.$$\n将 $S$ 报告为一个纯数字。将您的答案四舍五入到四位有效数字。最终答案中不要包含任何单位。", "solution": "问题要求计算在银行家算法的安全性检查中，对 $Finish$ 数组使用紧凑位集表示法相对于字节数组表示法所实现的期望加速比 $S$。加速比 $S$ 定义为单次扫描的期望总操作数的比率。\n\n设 $E_B$ 为字节数组扫描的期望总操作数，$E_{BS}$ 为位集扫描的期望总操作数。则加速比为：\n$$S = \\frac{E_B}{E_{BS}}$$\n\n给定以下参数：\n- 进程数，$N = 4096$。\n- 进程完成的概率，$p_{fin} = 0.9$。\n- 进程未完成的概率，$p_{unfin} = 1 - p_{fin} = 0.1$。\n- 检查字节数组中一个条目的成本，$c_b = 1$。\n- 处理一个未完成进程的开销成本，$c_u = 2$。\n- 机器字大小，$k = 64$ 位。\n- 位集中的字数，$W = \\frac{N}{k} = \\frac{4096}{64} = 64$。\n- $64$位加载的成本，$c_L = 1$。\n- 按位取反操作的成本，$c_I = 1$。\n- 零测试的成本，$c_Z = 1$。\n- 寻找第一个置位 (FFS) 操作的成本，$c_F = 3$。\n- 清除最低置位操作的成本，$c_C = 1$。\n\n首先，我们推导字节数组表示法的期望操作数 $E_B$。\n一次扫描的总成本 $C_B$ 是扫描所有条目的成本与为每个找到的未完成进程产生的额外开销之和。\n设 $N_{unfin}$ 为代表未完成进程总数的随机变量。\n总成本由以下表达式给出：\n$$C_B = N \\cdot c_b + N_{unfin} \\cdot c_u$$\n为了找到期望成本 $E_B = E[C_B]$，我们使用期望的线性性质：\n$$E_B = E[N \\cdot c_b + N_{unfin} \\cdot c_u] = N \\cdot c_b + E[N_{unfin}] \\cdot c_u$$\n未完成进程的期望数量 $E[N_{unfin}]$，可以通过考虑 $N$ 个进程中的每一个都独立地以概率 $p_{unfin}$ 未完成来计算。设 $X_i$ 为一个指示变量，如果进程 $i$ 未完成，则 $X_i=1$，否则 $X_i=0$。那么 $E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = p_{unfin}$。\n未完成进程的总数是 $N_{unfin} = \\sum_{i=1}^{N} X_i$。\n根据期望的线性性质：\n$$E[N_{unfin}] = E\\left[\\sum_{i=1}^{N} X_i\\right] = \\sum_{i=1}^{N} E[X_i] = N \\cdot p_{unfin}$$\n将此代入 $E_B$ 的表达式中：\n$$E_B = N \\cdot c_b + (N \\cdot p_{unfin}) \\cdot c_u$$\n代入给定值：\n$$E_B = 4096 \\cdot 1 + (4096 \\cdot 0.1) \\cdot 2 = 4096 + 409.6 \\cdot 2 = 4096 + 819.2 = 4915.2$$\n\n接下来，我们推导紧凑位集表示法的期望操作数 $E_{BS}$。\n总成本 $C_{BS}$ 是处理 $W$ 个字中每一个的成本与处理每个未完成进程的成本之和。\n对于 $W$ 个字中的每一个，都会执行一次加载、一次 NOT 和一次零测试。这部分的总成本是 $W \\cdot (c_L + c_I + c_Z)$。\n对于在整个位集中找到的每个未完成进程，会产生一次FFS、一次清除最低置位操作和共享开销。每个未完成进程的成本是 $(c_F + c_C + c_u)$。\n总成本 $C_{BS}$ 是：\n$$C_{BS} = W \\cdot (c_L + c_I + c_Z) + N_{unfin} \\cdot (c_F + c_C + c_u)$$\n再次使用期望的线性性质来计算 $E_{BS} = E[C_{BS}]$：\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + E[N_{unfin}] \\cdot (c_F + c_C + c_u)$$\n我们已经确定 $E[N_{unfin}] = N \\cdot p_{unfin}$。代入可得：\n$$E_{BS} = W \\cdot (c_L + c_I + c_Z) + (N \\cdot p_{unfin}) \\cdot (c_F + c_C + c_u)$$\n代入给定值：\n$$W = \\frac{4096}{64} = 64$$\n$$E_{BS} = 64 \\cdot (1 + 1 + 1) + (4096 \\cdot 0.1) \\cdot (3 + 1 + 2)$$\n$$E_{BS} = 64 \\cdot 3 + 409.6 \\cdot 6$$\n$$E_{BS} = 192 + 2457.6 = 2649.6$$\n\n最后，我们计算加速比 $S$：\n$$S = \\frac{E_B}{E_{BS}} = \\frac{4915.2}{2649.6}$$\n$$S \\approx 1.85507246...$$\n将结果四舍五入到四位有效数字，我们得到 $S = 1.855$。", "answer": "$$\\boxed{1.855}$$", "id": "3622562"}, {"introduction": "经典的银行家算法通常处理整数数量的资源，但在现实世界中，如CPU份额或网络带宽等资源往往是小数。本练习将挑战你把银行家算法应用于这些场景，并探讨使用定点数表示时产生的舍入误差如何影响算法的安全性。通过推导一个确保算法正确性的最小“安全边际”，你将学会如何设计一个在面对计算精度限制时依然稳健可靠的系统。[@problem_id:3622589]", "problem": "考虑一个使用银行家算法的系统，该系统有两种资源类型：中央处理器（CPU）份额和输入/输出（I/O）带宽。系统中有 $n=3$ 个进程，分别标记为 $P_1$、$P_2$ 和 $P_3$。数据结构定义如下：$Max[i]$ 是进程 $i$ 的最大需求向量，$Allocation[i]$ 是进程 $i$ 的当前分配向量，$Need[i]$ 是进程 $i$ 的剩余需求向量，定义为 $Need[i] = Max[i] - Allocation[i]$，而 $Available$ 是当前可用资源的向量。银行家算法维护一个工作向量 $Work$，它被初始化为 $Available$，并且每当一个进程 $i$ 完成时，更新 $Work := Work + Allocation[i]$。如果存在一个进程的排序，使得对于该排序中的每个进程 $i$，在考虑进程 $i$ 时，$Need[i] \\leq Work$ 的不等式按分量成立，则该状态被认为是安全的。\n\n假设小数资源表示为定点整数，比例因子为 $10^{k}$，其中 $k=2$（也就是说，每个实数值 $v$ 在内部表示为整数 $\\mathrm{round}(v \\cdot 10^{2})$，并在此整数域中进行算术比较）。在这一比例下，$Available$、$Allocation[i]$、$Max[i]$ 和 $Need[i]$ 的所有分量都通过最近取整进行转换。具体来说，$Need[i]$ 首先通过实数算术计算为 $Max[i] - Allocation[i]$，然后以 $10^{2}$ 的比例取整到最近的定点整数。\n\n设初始的真实（实数）状态为\n- $Max[1] = (\\,0.50,\\, 0.40\\,)$, $Allocation[1] = (\\,0.20,\\, 0.10\\,)$,\n- $Max[2] = (\\,0.30,\\, 0.50\\,)$, $Allocation[2] = (\\,0.10,\\, 0.20\\,)$,\n- $Max[3] = (\\,0.20,\\, 0.30\\,)$, $Allocation[3] = (\\,0.05,\\, 0.05\\,)$,\n- $Available = (\\,0.40,\\, 0.35\\,)$.\n\n假设我们在缩放和取整之前，为 $Available$ 的每个分量增加一个安全边际 $\\delta$，因此基于整数的算法使用的是 $Available + (\\delta,\\delta)$ 的表示。请根据银行家算法和定点取整的核心定义，推导出 $\\delta$ 的精确最小值（以真实资源单位表示），该值需保证以下安全属性：如果基于整数的银行家算法（完全在比例为 $10^{2}$ 的定点整数表示上使用最近取整进行操作）为此状态找到了一个安全序列，那么无论舍入误差如何影响该序列中的每个比较和每个释放步骤，真实的（小数）状态也是安全的。\n\n将最小的 $\\delta$ 表示为单个实数。除了在 $k=2$ 的精确算术下得出的结果外，最终值无需进行取整。", "solution": "用户希望找到最小的安全边际 $\\delta$，以确保如果基于定点整数表示的银行家算法找到了一个安全序列，那么真实的（小数）状态也保证是安全的。\n\n令 $x_R$ 为一个实数值的资源量，$x_I$ 为其在比例 $100$ 下的定点整数表示。取整规则为 $x_I = \\mathrm{round}(100 \\cdot x_R)$。这意味着从整数重构实数值的误差是有界的：\n$$|x_R - \\frac{x_I}{100}| \\leq \\frac{0.5}{100} = 0.005$$\n我们将重构误差定义为 $\\epsilon_x = x_R - x_I/100$。其界为 $|\\epsilon_x| \\leq 0.005$。因此，$x_R = x_I/100 + \\epsilon_x$。\n\n题目规定，如果基于整数的算法找到一个安全序列，那么实数值系统也必须是安全的。设整数算法找到的安全序列为 $\\pi = \\langle P_{p_1}, P_{p_2}, ..., P_{p_n} \\rangle$。我们必须确保该序列对于实数值系统也是安全的。\n\n对于序列中的任意步骤 $j$（$j=1, \\dots, n$）以及每个资源分量（为清晰起见，我们省略分量下标，因为对两个分量的逻辑是相同的），整数算法得以继续的条件是：\n$$N_{I, p_j} \\leq W_{I, j-1}$$\n其中 $W_{I, 0} = \\mathrm{round}(100 \\cdot (V_R + \\delta))$ 并且当 $j  1$ 时 $W_{I, j-1} = W_{I, 0} + \\sum_{i=1}^{j-1} A_{I, p_i}$。\n\n我们必须为实数值系统保证的条件是：\n$$N_{R, p_j} \\leq W_{R, j-1}$$\n其中 $W_{R, 0} = V_R$ 并且当 $j  1$ 时 $W_{R, j-1} = V_R + \\sum_{i=1}^{j-1} A_{R, p_i}$。\n\n让我们用整数值及其误差来表示实数值。\n真实需求为 $N_{R, p_j} = N_{I, p_j}/100 + \\epsilon_N$。\n在步骤 $j$ 的可用真实工作量为 $W_{R, j-1} = V_R + \\sum_{i=1}^{j-1} A_{R, p_i}$。\n让我们将其与整数工作量 $W_{I, j-1}$ 联系起来。\n该和的各部分为：\n$V_{R} + \\delta = W_{I, 0}/100 + \\epsilon_{V+\\delta} \\implies V_R = W_{I, 0}/100 - \\delta + \\epsilon_{V+\\delta}$\n$A_{R, p_i} = A_{I, p_i}/100 + \\epsilon_{A_i}$\n将这些相加：\n$$W_{R, j-1} = \\left(\\frac{W_{I, 0}}{100} - \\delta + \\epsilon_{V+\\delta}\\right) + \\sum_{i=1}^{j-1} \\left(\\frac{A_{I, p_i}}{100} + \\epsilon_{A_i}\\right)$$\n$$W_{R, j-1} = \\frac{1}{100} \\left(W_{I, 0} + \\sum_{i=1}^{j-1} A_{I, p_i}\\right) - \\delta + \\left(\\epsilon_{V+\\delta} + \\sum_{i=1}^{j-1} \\epsilon_{A_i}\\right)$$\n令 $W_{I,R,j-1} = W_{I,j-1}/100$。令 $E_j = \\epsilon_{V+\\delta} + \\sum_{i=1}^{j-1} \\epsilon_{A_i}$ 为构成可用工作量的 $j$ 个项所累积的总误差。这个误差和的界为 $|E_j| \\leq j \\cdot 0.005$。\n因此，$W_{R, j-1} = W_{I,R,j-1} - \\delta + E_j$。\n\n现在，我们将这些表达式代入我们必须保证的不等式 $N_{R, p_j} \\leq W_{R, j-1}$ 中：\n$$\\frac{N_{I, p_j}}{100} + \\epsilon_N \\leq \\frac{W_{I, j-1}}{100} - \\delta + E_j$$\n我们正在寻找最小的 $\\delta$，以确保在给定 $N_{I, p_j} \\leq W_{I, j-1}$ 的情况下，该不等式成立。让我们重新排列以找到 $\\delta$ 的一个下界：\n$$\\delta \\geq \\frac{N_{I, p_j} - W_{I, j-1}}{100} + \\epsilon_N - E_j$$\n这个关于 $\\delta$ 的不等式必须“无论舍入误差如何影响每个比较”都成立。这意味着我们必须找到一个 $\\delta$，它大于或等于右侧（RHS）表达式可能的最大值，需要考虑到所有可能的舍入误差值和所有有效的整数检查。\n\n令 $\\Delta_I = W_{I, j-1} - N_{I, p_j}$。从整数安全检查中我们知道 $\\Delta_I \\geq 0$。\n不等式变为：\n$$\\delta \\geq \\frac{-\\Delta_I}{100} + \\epsilon_N - E_j$$\n为了找到 $\\delta$ 所需的下界，我们在所有可能性上最大化右侧表达式：\n$$\\max_{\\text{errors, }\\Delta_I} \\left(\\frac{-\\Delta_I}{100} + \\epsilon_N - E_j\\right) = \\max_{\\Delta_I \\geq 0} \\left(\\frac{-\\Delta_I}{100}\\right) + \\max(\\epsilon_N) - \\min(E_j)$$\n1.  当 $\\Delta_I$ 最小时，项 $\\frac{-\\Delta_I}{100}$ 最大化。由于 $\\Delta_I$ 是一个非负整数，其最小值为 $0$。这对应于最紧凑的整数检查情况，即 $N_{I, p_j} = W_{I, j-1}$。\n2.  单个 $Need$ 分量的误差 $\\epsilon_N$ 在 $\\max(\\epsilon_N) = 0.005$ 时最大化。\n3.  累积误差 $E_j$ 是 $j$ 个独立误差项的和，每个误差项都在 $[-0.005, 0.005]$ 范围内。当每个项都取最小值时，和 $E_j$ 最小化：$\\min(E_j) = j \\cdot (-0.005) = -0.005j$。\n\n代入这些最坏情况下的值：\n$$\\delta \\geq \\frac{-0}{100} + 0.005 - (-0.005j)$$\n$$\\delta \\geq 0.005 + 0.005j$$\n$$\\delta \\geq 0.005(j+1)$$\n这个条件必须对任何可能的安全序列的任何步骤 $j$ 都成立。对于 $n=3$ 个进程，一个安全序列最多可以有 $3$ 个步骤，所以 $j$ 可以是 $1$、$2$ 或 $3$。为确保该条件对所有可能的步骤都成立，我们必须满足最严格的要求，这对应于 $j$ 的最大值。\n$j$ 的最大值为 $n=3$。\n对于 $j=3$，条件是：\n$$\\delta \\geq 0.005(3+1)$$\n$$\\delta \\geq 0.005(4)$$\n$$\\delta \\geq 0.02$$\n对于所有可能的情景（任何安全序列、任何步骤 $j$、任何分量以及任何取整组合），满足此条件的 $\\delta$ 的最小值为 $0.02$。所提供的具体初始状态值对于此最坏情况的推导并非必需，但它们确认了在给定规则下安全状态可以存在。", "answer": "$$\\boxed{0.02}$$", "id": "3622589"}]}