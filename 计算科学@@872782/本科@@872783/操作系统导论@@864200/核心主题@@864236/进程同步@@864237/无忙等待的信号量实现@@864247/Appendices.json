{"hands_on_practices": [{"introduction": "理论学习之后，我们来通过一个思想实验，量化分析非忙等待信号量的核心优势。这个练习将信号量的抽象概念与一个非常实际的物理量——能耗——联系起来。通过计算在拥有$N$个线程的系统中，CPU的“睡眠”周期$C_{s}$与“活跃”周期$C_{a}$的比例，你将能更深刻地理解为什么让线程在无法推进时进入睡眠状态，对于构建高效和节能的系统至关重要 [@problem_id:3681510]。", "problem": "一个单核中央处理器 (CPU) 使用一种无忙等待的睡眠信号量实现。当一个线程对信号量执行等待操作且无法继续时，它将被取消调度，并且在被信号操作唤醒之前不消耗任何 CPU 周期。该操作系统是无滴答的（tickless），并且在没有任何可运行线程时会立即进入低功耗空闲状态。考虑一个有 $N$ 个独立线程的系统。每个线程在计算阶段和在睡眠信号量上的阻塞阶段之间交替。在稳态下，每个线程有 $0.9$ 的时间比例处于阻塞阶段，这一比例与其他线程无关且随时间保持不变。忽略所有唤醒、上下文切换和进入/退出空闲状态的开销，并假设平稳性和遍历性，从而使得长期时间比例等于相应的概率。\n\n设 CPU 频率为每秒 $f$ 个周期，并在一个长度为 $T$ 秒的长区间内观察该系统。定义 $C_{s}$ 为该区间内累积的 CPU 睡眠周期的期望数量，$C_{a}$ 为该区间内累积的 CPU 活动周期的期望数量。当且仅当至少有一个线程可运行时，CPU 处于活动状态。\n\n对于 $N = 12$ 的情况，计算期望比率 $R = \\frac{C_{s}}{C_{a}}$。将 $R$ 表示为一个纯数，并将您的答案四舍五入到四位有效数字。", "solution": "我们依赖的核心事实是：(i) 睡眠信号量实现会取消阻塞线程的调度，因此它们不消耗 CPU 周期；(ii) CPU 仅在至少有一个线程可运行时才处于活动状态，否则它会空闲；以及 (iii) 在平稳性和遍历性的假设下，长期时间比例等于其对应的概率。\n\n设 $p_{b}$ 为给定线程处于阻塞状态的稳态概率。已知 $p_{b} = 0.9$。对于 $N$ 个独立线程，所有 $N$ 个线程同时被阻塞的概率是\n$$\np_{\\text{all-blocked}} = p_{b}^{N} = (0.9)^{N}.\n$$\n因为 CPU 仅在所有线程都被阻塞时才空闲，所以 CPU 处于睡眠状态的长期时间比例是\n$$\np_{\\text{sleep}} = (0.9)^{N}.\n$$\nCPU 在至少有一个线程可运行时处于活动状态，这是一个互补事件，因此长期活动时间比例是\n$$\np_{\\text{active}} = 1 - (0.9)^{N}.\n$$\n在频率为每秒 $f$ 个周期、长度为 $T$ 秒的观察区间内，睡眠周期和活动周期的期望数量分别为\n$$\nC_{s} = f T \\, p_{\\text{sleep}} = f T \\, (0.9)^{N}, \\quad C_{a} = f T \\, p_{\\text{active}} = f T \\, \\bigl(1 - (0.9)^{N}\\bigr).\n$$\n因此，所求的比率简化为\n$$\nR = \\frac{C_{s}}{C_{a}} = \\frac{(0.9)^{N}}{1 - (0.9)^{N}},\n$$\n该比率与 $f$ 和 $T$ 无关。\n\n对于 $N = 12$,\n$$\n(0.9)^{12} = \\left(\\frac{9}{10}\\right)^{12} = \\frac{9^{12}}{10^{12}} = \\frac{282429536481}{10^{12}} = 0.282429536481.\n$$\n因此，\n$$\nR = \\frac{0.282429536481}{1 - 0.282429536481} = \\frac{0.282429536481}{0.717570463519}.\n$$\n进行除法运算，\n$$\nR \\approx 0.3935913625\\ldots\n$$\n四舍五入到四位有效数字，\n$$\nR \\approx 0.3936.\n$$", "answer": "$$\\boxed{0.3936}$$", "id": "3681510"}, {"introduction": "理解了为何要避免忙等待后，下一步是掌握如何正确实现。实现睡眠式信号量充满了挑战，其中“丢失唤醒”（lost wakeup）是一个臭名昭著的竞态条件。这个练习要求你分析一个有缺陷的$P(S)$操作实现，找出在检查信号量状态和线程进入睡眠状态之间的关键漏洞，并确定正确的原子修复方法 [@problem_id:3681456]。这个过程不仅能巩固你对原子性的理解，还能锻炼你审查并发代码的批判性思维能力。", "problem": "考虑一个具有整数状态 $S$ 的计数信号量，其目的是强制 $P(S)$ 在 $S = 0$ 时阻塞，并在 $S > 0$ 时递减 $S$；同时，$V(S)$ 会递增 $S$，并在必要时唤醒一个被阻塞的线程。实现必须避免忙等待。假设有一个互斥锁 $M$、一个等待线程队列 $Q$，以及调度原语 $\\text{park}()$ 和 $\\text{unpark}(t)$，其中 $t$ 是一个线程标识符。为了最小化持有 $M$ 的时间，有人提出了以下有缺陷的设计：\n\n- 提议的 $P(S)$ 实现：\n  - 步骤 1：$\\text{lock}(M)$。\n  - 步骤 2：如果 $S > 0$，则设置 $S := S - 1$，执行 $\\text{unlock}(M)$，然后返回。\n  - 步骤 3：$\\text{unlock}(M)$。\n  - 步骤 4：$\\text{enqueue}(Q, \\text{self})$。\n  - 步骤 5：$\\text{park}()$。\n\n- 提议的 $V(S)$ 实现：\n  - 步骤 1：$\\text{lock}(M)$。\n  - 步骤 2：如果 $\\text{empty}(Q)$，则设置 $S := S + 1$；否则，令 $t := \\text{dequeue}(Q)$ 并执行 $\\text{unpark}(t)$。\n  - 步骤 3：$\\text{unlock}(M)$。\n\n你可以视为理所当然的基本事实和定义：\n- 信号量由 $P(S)$ 和 $V(S)$ 的原子行为定义：$V(S)$ 的效果必须对一个 $P(S)$ 可见，要么通过唤醒一个休眠的线程，要么通过增加 $S$ 以使后续的 $P(S)$ 可以继续执行；不能有丢失的唤醒。\n- $\\text{lock}(M)$ 和 $\\text{unlock}(M)$ 为受保护的状态提供互斥，并在此状态上建立标准的 happens-before 顺序。\n- $\\text{park}()$ 会阻塞调用者，直到相应的 $\\text{unpark}(\\cdot)$ 被发出；如果调用 $\\text{park}()$ 时已被明确地 unparked，则立即返回。不允许自旋。\n- 除了队列 $Q$ 明确强制执行的公平性外，不保证任何其他公平性。\n\n从第一性原理出发分析该设计，并回答以下多项选择题。选择所有在其选项陈述的意义上正确的选项。\n\nA. 以下在两个线程 $T_1$ 和 $T_2$ 之间从 $S = 0$ 和 $\\text{empty}(Q)$ 开始的交错执行，展示了所提议设计中的一个丢失唤醒：\n- 步骤 1 ($t_1$)：$T_1$ 调用 $P(S)$，执行 $\\text{lock}(M)$，观察到 $S = 0$，执行 $\\text{unlock}(M)$（完成步骤 3），但尚未执行步骤 4。\n- 步骤 2 ($t_2$)：调度器切换到 $T_2$。$T_2$ 调用 $V(S)$，执行 $\\text{lock}(M)$，观察到 $\\text{empty}(Q)$，设置 $S := 1$，并执行 $\\text{unlock}(M)$。\n- 步骤 3 ($t_3$)：调度器切换回 $T_1$。$T_1$ 执行 $\\text{enqueue}(Q, \\text{self})$，然后执行 $\\text{park}()$。$T_1$ 将无限期地阻塞，因为没有线程会调用 $\\text{unpark}(T_1)$，并且 $S = 1$ 未被 $T_1$ 消耗。\n\nB. 以下在两个线程 $T_1$ 和 $T_2$ 之间从 $S = 0$ 和 $\\text{empty}(Q)$ 开始的交错执行，展示了所提议设计中的一个丢失唤醒：\n- 步骤 1 ($t_1$)：$T_1$ 调用 $P(S)$，执行 $\\text{lock}(M)$，观察到 $S = 0$，执行 $\\text{unlock}(M)$，然后立即执行 $\\text{enqueue}(Q, \\text{self})$ 和 $\\text{park}()$。\n- 步骤 2 ($t_2$)：$T_2$ 调用 $V(S)$，执行 $\\text{lock}(M)$，观察到 $Q$ 非空，将 $T_1$ 出队，执行 $\\text{unpark}(T_1)$，并执行 $\\text{unlock}(M)$。$T_1$ 被唤醒并从 $P(S)$ 返回，但没有递减 $S$。\n这显示了一个丢失唤醒，因为 $T_1$ 没有递减 $S$。\n\nC. 一个正确的、无需忙等待的修复方法是，通过将入队操作移到 $M$ 锁下并执行原子性的释放-休眠操作，使得检查和休眠相对于 $V(S)$ 逻辑上是原子的。具体来说：在 $P(S)$ 中，在步骤 1 之后，如果 $S = 0$，则在持有 $M$ 的同时执行 $\\text{enqueue}(Q, \\text{self})$，然后原子性地释放 $M$ 并阻塞（例如，通过一个将 $\\text{unlock}(M)$ 和 $\\text{park}()$ 作为单个不可中断步骤的原语）；唤醒后，重新获取 $M$，如果合适则递减 $S$，然后返回。等效地，使用一个类似于 Fast Userspace Mutex (FUTEX) 风格的 $\\text{futex\\_wait}(0)$，它原子性地检查 $S$ 并且仅当 $S$ 仍为 $0$ 时才休眠。这通过确保等待者要么在任何 $V(S)$ 观察到它之前在 $Q$ 中可见，要么在一个 $V(S)$ 已经使 $S > 0$ 的情况下不休眠，从而消除了丢失唤醒的问题。\n\nD. 一个正确的修复方法是在 $P(S)$ 的步骤 3 和步骤 4 之间插入一个完整的内存屏障以防止重排序，同时保持设计的其余部分不变。这可以在不改变锁定策略的情况下消除导致丢失唤醒的竞争。\n\nE. 一个正确的修复方法是通过将 $P(S)$ 的步骤 5 移动到步骤 3 之前，在调用 $\\text{park}()$ 期间保持持有 $M$ 锁。这可以防止在临界区内与 $V(S)$ 发生任何交错，从而防止丢失唤醒，同时为其他线程保留了进展性。", "solution": "用户请求对一个提议的信号量实现进行分析。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- 计数信号量状态：整数 $S$。\n- 操作：$P(S)$ 和 $V(S)$。\n- $P(S)$ 理想行为：如果 $S=0$ 则阻塞；如果 $S>0$ 则递减 $S$。\n- $V(S)$ 理想行为：递增 $S$；如果有阻塞的线程，则唤醒一个。\n- 实现组件：互斥锁 $M$，等待线程队列 $Q$，原语 $\\text{park}()$ 和 $\\text{unpark}(t)$。\n- 提议的 $P(S)$ 实现：\n  - 步骤 1：$\\text{lock}(M)$。\n  - 步骤 2：如果 $S > 0$，则设置 $S := S - 1$，执行 $\\text{unlock}(M)$，然后返回。\n  - 步骤 3：$\\text{unlock}(M)$。\n  - 步骤 4：$\\text{enqueue}(Q, \\text{self})$。\n  - 步骤 5：$\\text{park}()$。\n- 提议的 $V(S)$ 实现：\n  - 步骤 1：$\\text{lock}(M)$。\n  - 步骤 2：如果 $\\text{empty}(Q)$，则设置 $S := S + 1$；否则，令 $t := \\text{dequeue}(Q)$ 并执行 $\\text{unpark}(t)$。\n  - 步骤 3：$\\text{unlock}(M)$。\n- 基本事实：信号量不能有丢失的唤醒；$\\text{lock}(M)$ 和 $\\text{unlock}(M)$ 提供互斥并建立 happens-before 顺序；$\\text{park}()$ 阻塞调用者而不进行自旋。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在操作系统和并发编程领域有其科学依据。所使用的元素——信号量、互斥锁、调度原语——都是标准的、定义明确的概念。提议的实现及其可能包含的竞争条件（“丢失唤醒”问题）构成了该领域教学中使用的典型且现实的问题。问题陈述形式良好，提供了所有必要的定义、约束和待分析的算法。语言客观而精确。其设定在内部是一致的，并且没有违反任何计算机科学的基本原则。这是一个可验证且非平凡的问题。\n\n**步骤 3：结论和行动**\n问题陈述有效。将继续进行分析。\n\n**对提议实现的“第一性原理”分析**\n\n信号量实现的核心职责是确保其操作的原子性。对于 $P(S)$，这意味着一个线程必须原子性地检查信号量的值，并且如果它必须阻塞，那么在任何 $V(S)$ 操作试图唤醒它之前，它必须将自己注册为已阻塞。\n\n给定的 $P(S)$ 实现未能确保这种原子性。当一个线程发现 $S=0$ 时，它执行以下操作序列：\n$1$. $\\text{unlock}(M)$ (步骤 3)\n$2$. $\\text{enqueue}(Q, \\text{self})$ (步骤 4)\n$3$. $\\text{park}()$ (步骤 5)\n\n在步骤 3 和步骤 5 之间存在一个漏洞窗口。在线程解锁 $M$ 之后，操作系统调度器可以自由地抢占它并运行另一个线程。如果这第二个线程调用 $V(S)$，它将获取 $M$，检查等待队列 $Q$，并发现它是空的（因为第一个线程尚未执行步骤 4）。因此，$V(S)$ 操作将递增 $S$ 而不会发出 $\\text{unpark}()$ 调用。当第一个线程被重新调度时，它将继续将自己入队，然后调用 $\\text{park}()$，导致其阻塞。然而，对应于 $V(S)$ 调用的唤醒事件已经发生，但并未指向该线程。这是一个“丢失的唤醒”：该线程现在被阻塞了，但本应阻止它阻塞（或唤醒它）的信号已经丢失了。\n\n**逐选项分析**\n\n**A. 以下在两个线程 $T_1$ 和 $T_2$ 之间从 $S = 0$ 和 $\\text{empty}(Q)$ 开始的交错执行，展示了所提议设计中的一个丢失唤醒：[...]**\n\n该选项描述了从第一性原理推导出的确切的“丢失唤醒”场景。\n- $T_1$ 调用 $P(S)$，获取锁 $M$，看到 $S=0$，然后释放锁 $M$。在它能将自己加入队列 $Q$ 之前，它被抢占了。\n- $T_2$ 调用 $V(S)$，获取 $M$，并观察到 $Q$ 为空。根据实现，它将 $S$ 递增到 $1$ 并释放 $M$。没有调用 $\\text{unpark}()$。\n- $T_1$ 恢复执行。它将自己加入 $Q$，然后调用 $\\text{park}()$，导致其阻塞。\n最终状态是 $T_1$ 被阻塞并且在 $Q$ 中，而 $S=1$。来自 $V(S)$ 调用的“信用”现在在 $S$ 中，但本应消耗它的 $T_1$ 却在休眠。另一个线程后续调用 $P(S)$ 会发现 $S=1$，递减它，然后继续执行，使得 $T_1$ 被搁置。这是一个经典的丢失唤醒。该分析是合理的，并正确地指出了缺陷。\n\n结论：**正确**。\n\n**B. 以下在两个线程 $T_1$ 和 $T_2$ 之间从 $S = 0$ 和 $\\text{empty}(Q)$ 开始的交错执行，展示了所提议设计中的一个丢失唤醒：[...]**\n\n该选项描述了一个不同的场景。\n- $T_1$ 调用 $P(S)$，发现 $S=0$，并成功地将自己入队并休眠。\n- $T_2$ 调用 $V(S)$，在 $Q$ 中找到 $T_1$，将其出队，并调用 $\\text{unpark}(T_1)$。$T_1$ 被唤醒。\n该选项接着声称这是一个丢失唤醒，因为“$T_1$ 没有递减 $S$”。让我们分析一下状态。最初，$S=0$。在 $V(S)$ 的路径中，由于 $Q$ 不为空，$S$ *不*被递增。对 $\\text{unpark}(T_1)$ 的调用消耗了 $V(S)$ 信号。当 $T_1$ 唤醒时，它只是从 $P(S)$ 返回。$S$ 的最终值为 $0$。一个 $P$ 操作和一个 $V$ 操作已经发生，信号量概念值的净变化为 $0$。这是正确的信号量语义。该实现通过递增 $S$（如果没有等待者）或唤醒一个等待者（如果有等待者）来正确处理资源计数。在这个设计中，被唤醒的线程不应该递减 $S$，因为那将是对信号消耗的重复计算。因此，这个场景并不代表一个缺陷，更不用说丢失唤醒了。\n\n结论：**不正确**。\n\n**C. 一个正确的、无需忙等待的修复方法是，通过将入队操作移到 $M$ 锁下并执行原子性的释放-休眠操作，使得检查和休眠相对于 $V(S)$ 逻辑上是原子的。[...]**\n\n该选项提出了一个修复方案。核心思想是消除漏洞窗口。对于必须等待的线程，对 $P(S)$ 的提议更改是：\n$1$. （持有锁 $M$）$\\text{enqueue}(Q, \\text{self})$。\n$2$. 原子性地 $\\text{unlock}(M)$ 并调用 $\\text{park}()$。\n让我们分析这个修复方案。通过将入队操作移到由 $M$ 保护的临界区内，等待线程 $T_1$ 被保证在释放 $M$ 之前已经在 $Q$ 中。任何其他调用 $V(S)$ 的线程 $T_2$ 在 $T_1$ 释放 $M$ 之前无法获取它。当 $T_2$ 获取 $M$ 时，它将正确地看到 $T_1$ 在 $Q$ 中并发出唤醒。原子性的“释放并休眠”操作对于防止解锁和休眠调用本身之间的竞争至关重要。这确保了 $T_1$ 在释放锁之后但在正式进入休眠状态之前不会被抢占。当从互斥锁构建条件变量或信号量时，这个设计是解决丢失唤醒问题的标准的、教科书式的解决方案。提到 $\\text{futex\\_wait}$ 是一个准确的类比，因为该原语专门设计用于在内核级别解决这个原子性问题。\n\n结论：**正确**。\n\n**D. 一个正确的修复方法是在 $P(S)$ 的步骤 3 和步骤 4 之间插入一个完整的内存屏障以防止重排序 [...]**\n\n该选项提议使用内存屏障。序列将是 $\\text{unlock}(M)$，然后是一个内存屏障，然后是 $\\text{enqueue}(Q, \\text{self})$。内存屏障阻止编译器和 CPU 跨屏障对内存操作进行重排序。然而，“丢失唤醒”问题不是由内存重排序引起的；它是由操作系统调度器管理的线程交错执行引起的。内存屏障对调度器抢占线程的能力没有影响。选项 A 中描述的丢失唤醒场景仍然完全可能：一个线程可以在 $\\text{unlock}$（和屏障）与 $\\text{enqueue}$ 之间被切换出去。这个提议将一个高层逻辑竞争条件误认为是一个底层内存排序问题。\n\n结论：**不正确**。\n\n**E. 一个正确的修复方法是通过将 $P(S)$ 的步骤 5 移动到步骤 3 之前，在调用 $\\text{park}()$ 期间保持持有 $M$ 锁。[...]**\n\n该选项提议通过让等待线程在休眠时持有锁 $M$ 来解决问题。等待线程的序列将是：$\\text{lock}(M)$，$\\text{enqueue}(Q, \\text{self})$，$\\text{park}()$，然后在唤醒时，$\\text{unlock}(M)$。如果线程 $T_1$ 遵循此路径，它将在持有锁 $M$ 的同时进入休眠。现在，如果另一个线程 $T_2$ 试图调用 $V(S)$，它的第一步是调用 $\\text{lock}(M)$。它无法获取该锁，因为 $T_1$ 正持有它。但 $T_1$ 正在休眠，只能由 $T_2$ 唤醒。$T_2$ 被阻塞等待 $T_1$ 释放锁，而 $T_1$ 被阻塞等待 $T_2$ 唤醒它。这是一个死锁。声称这“为其他线程保留了进展性”是错误的；它会停止任何试图使用该信号量的线程的所有进展。\n\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3681456"}]}