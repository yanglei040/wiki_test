{"hands_on_practices": [{"introduction": "`test-and-set` 指令为单个共享资源提供了原子性的互斥访问，但在复杂的并发程序中，线程通常需要同时访问多个资源。这个思想实验将引导我们探讨当多个线程以不一致的顺序请求多个锁时，如何引发经典的死锁问题，即系统中的一组进程或线程相互等待对方持有的资源而陷入完全停顿。通过分析这个场景，我们将理解为何强制执行全局唯一的锁获取顺序是避免此类死锁的关键策略。[@problem_id:3686956]", "problem": "考虑一个操作系统 (OS) 中的并发程序，其中两个自旋锁使用硬件的测试并设置 (test-and-set) 指令来实现互斥。测试并设置指令原子地读取一个内存位置并将其设置为一个指定的值，同时返回先前的值；当用于构建锁时，一个线程会一直自旋，直到该指令返回一个“未锁定”的值，然后将该锁设置为“锁定”的值。现有两个锁 $L_A$ 和 $L_B$，分别保护两个不同的资源 $R_A$ 和 $R_B$。假设有两个线程 $T_1$ 和 $T_2$，调度在两个中央处理器 (CPU) 上，并且两个线程偶尔都需要联合访问 $R_A$ 和 $R_B$。由于遗留模块边界的限制，$T_1$ 在需要两个资源时会先获取 $L_A$ 然后尝试获取 $L_B$；对称地，$T_2$ 在需要两个资源时会先获取 $L_B$ 然后尝试获取 $L_A$。一旦一个线程持有一个锁，它在完成该资源的临界区之前不会释放该锁，并且锁仅由持有线程自愿释放。\n\n从基本原理出发，分析测试并设置的原子性、互斥和死锁条件（包括循环等待的可能性），并选择在此场景下所有为真的陈述。\n\nA. 当 $T_1$ 尝试获取 $L_A$ 然后获取 $L_B$，而 $T_2$ 尝试获取 $L_B$ 然后获取 $L_A$ 时，可能会发生死锁，因为互斥、持有并等待、不可抢占和循环等待这四个条件可以同时成立。\n\nB. 单个锁上的测试并设置的原子性隐式地使多个锁的获取也成为原子操作，从而阻止了循环等待，因此无论获取顺序如何都不会发生死锁。\n\nC. 强制执行一个全局的锁获取总顺序（例如，要求所有线程在需要两个锁时都先获取 $L_A$ 再获取 $L_B$）消除了循环等待条件，从而防止了死锁。\n\nD. 在实现锁时，使用比较并交换 (CAS) 代替测试并设置，同时保持相同的获取模式，可以消除死锁，因为 CAS 是一个更强的原子原语。\n\nE. 即使所有线程都遵守一个全局的锁顺序，饥饿也不可能发生，因为测试并设置自旋锁在竞争下保证有界等待。", "solution": "首先从与此场景相关的基本定义开始。硬件的测试并设置指令在单个内存位置的层面上提供了原子性：单个线程可以原子地读取并设置一个锁变量，确保了该锁的互斥性。由测试并设置构建的自旋锁会导致线程忙等待，直到锁显示为空闲，此时原子指令将锁设置为“锁定”状态。死锁分析采用经典的死锁必要条件（通常归功于 Coffman）：互斥、持有并等待、不可抢占和循环等待。如果所有四个条件同时存在，就可能发生死锁。\n\n分析给定的获取模式。线程 $T_1$ 获取 $L_A$ 然后尝试获取 $L_B$；线程 $T_2$ 获取 $L_B$ 然后尝试获取 $L_A$。因为锁仅在临界区结束时自愿释放，所以操作系统不会强行抢占资源所有权。\n\n评估每个选项：\n\nA. 当 $T_1$ 尝试获取 $L_A$ 然后获取 $L_B$，而 $T_2$ 尝试获取 $L_B$ 然后获取 $L_A$ 时，可能会发生死锁，因为互斥、持有并等待、不可抢占和循环等待这四个条件可以同时成立。推导：互斥条件成立，因为每个锁 $L_A$ 和 $L_B$ 一次只允许一个线程进入其临界区。持有并等待条件成立，因为 $T_1$ 可以在持有 $L_A$ 的同时等待 $L_B$，同时 $T_2$ 可以在持有 $L_B$ 的同时等待 $L_A$。不可抢占条件成立，因为操作系统不会从线程中强行移除一个锁；锁只有在持有者自愿退出其临界区时才被释放。循环等待条件成立，因为 $T_1$ 等待 $L_B$（由 $T_2$ 持有），而 $T_2$ 等待 $L_A$（由 $T_1$ 持有），在等待图中形成了一个环路。当这四个条件都存在时，死锁是可能发生的。因此，选项 A 是正确的。\n\nB. 单个锁上的测试并设置的原子性隐式地使多个锁的获取也成为原子操作，从而阻止了循环等待，因此无论获取顺序如何都不会发生死锁。推导：测试并设置的原子性适用于对单个内存位置的操作，而不是对跨越多个不同锁的一系列操作。获取 $L_A$ 然后获取 $L_B$ 并不是一个单一的原子事务；一个线程可能成功获取 $L_A$ 后，为获取 $L_B$ 而无限自旋。线程在不同锁之间交錯执行的可能性依然存在，如果获取顺序不一致，就可能产生循环等待。因此，单锁原子性并不意味着多锁原子性，这个陈述是错误的。\n\nC. 强制执行一个全局的锁获取总顺序（例如，要求所有线程在需要两个锁时都先获取 $L_A$ 再获取 $L_B$）消除了循环等待条件，从而防止了死锁。推导：施加一个严格的排序关系，比如说 $L_A \\prec L_B$，并要求任何需要这两个锁的线程都按递增顺序获取它们。假设（为了引出矛盾）在此策略下发生了循环等待。在一个环路中，每个线程持有一个锁并等待一个顺序更高的锁。但对于一个严格的总顺序，等待图中不可能存在环路：一个等待更高顺序锁的线程不可能成为一个返回到更低顺序锁的环路的一部分，因为该顺序是无环的。因此，循环等待被消除，死锁的一个必要条件被打破；死锁不会因此原因发生。选项 C 是正确的。\n\nD. 在实现锁时，使用比较并交换 (CAS) 代替测试并设置，同时保持相同的获取模式，可以消除死锁，因为 CAS 是一个更强的原子原语。推导：比较并交换 (CAS) 是一个原子指令，它仅当内存位置持有预期值时才更新它，但像测试并设置一样，它为单个内存位置提供原子性。所描述的死锁源于资源获取策略（不一致的锁顺序），而不是原子原语的缺陷。保持相同的获取模式会保留互斥、持有并等待、不可抢占和循环等待条件；CAS 既没有使多锁获取成为原子操作，也没有打破循环等待。因此，选项 D 是错误的。\n\nE. 即使所有线程都遵守一个全局的锁顺序，饥饿也不可能发生，因为测试并设置自旋锁在竞争下保证有界等待。推导：测试并设置自旋锁不保证有界等待或公平性；原则上，一个线程可能会无限自旋，而其他线程则反复获取和释放该锁（例如，在没有公平机制的重度竞争下）。全局锁顺序通过消除循环等待来防止死锁，但它没有引入公平性或有界等待。饥饿仍然是可能的。因此，选项 E 是错误的。\n\n总之，选项 A 和 C 是正确的；B、D 和 E 是错误的。", "answer": "$$\\boxed{AC}$$", "id": "3686956"}, {"introduction": "一个逻辑上正确的自旋锁在面对高并发竞争时，其性能可能会急剧下降。这种现象通常源于所谓的“缓存一致性风暴”（coherence storm），即多个处理器核心为了获取锁而激烈争抢缓存行的所有权，导致总线流量剧增和系统效率锐减。本练习旨在探讨如何通过设计智能的退避（backoff）策略来缓解这种竞争，通过在尝试获取锁失败后引入随机化和适应性延迟，从而稳定系统吞吐量，使其在高负载下依然保持高效。[@problem_id:3686949]", "problem": "考虑一个在缓存一致性多处理器上使用测试并设置 (TAS) 指令实现的单一共享自旋锁。测试并设置 (TAS) 指令原子地读取一个内存位置并将其设置为一个锁定值；如果先前的值表明锁是空闲的，调用线程就获得该锁；否则，尝试失败，线程必须重试。系统中有 $N$ 个相同的线程。每个线程在一个平均持续时间为 $t_{n}$ 的非临界区和一个受自旋锁保护的平均持续时间为 $t_{c}$ 的临界区之间交替执行。一次失败的 TAS 尝试会产生一致性流量和每次尝试大约 $\\tau$ 的停顿成本，而重复的并发 TAS 尝试会导致锁所在的缓存行在核心之间“乒乓”往返，从而增加锁的交接时间。假设机器提供了一个中央处理器 (CPU) 暂停指令，使得等待期间不会产生一致性流量，直到下一次 TAS 操作。\n\n你的任务是选择一种退避策略，该策略仅使用自上次成功以来连续失败的 TAS 操作次数 $k$（成功时将 $k$ 重置为 $0$）来适应竞争，并选择其吞吐量预测与第一性原理一致的策略。吞吐量定义为单位时间内成功获取锁的稳态速率，在没有锁转移开销的情况下，其上限为 $1/t_{c}$。\n\n哪个选项最好地同时指明了：\n- 一种基于 $k$ 的竞争自适应退避策略，以及\n- 一个关于当 $N$ 从小变到大时吞吐量行为的定性正确的预测？\n\nA. 带下限和上限的指数随机退避：在 $k$ 次连续失败后，等待一个随机时间 $W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}\\cdot 2^{k}\\right)$，但对窗口设置上限，使得 $W \\le s_{\\max}$；成功时重置为 $s_{\\min}$，并且在所有时候都添加小的随机抖动。预测：对于小的 $N$（例如，$N \\le 4$），下限 $s_{\\min}$ 使开销可忽略不计，因此吞吐量接近理想的 $1/t_{c}$；对于大的 $N$，窗口会扩大，直到每个有效时隙的预期竞争者数量为 $O(1)$，因此一致性风暴被抑制，锁交接开销保持为 $O(1)$，使得吞吐量接近一个常数 $1/\\left(t_{c}+O(\\tau)\\right)$，基本上与 $N$ 无关。\n\nB. 固定确定性延迟：每次失败后，等待固定的 $s_{0}$ 个周期（无随机性），与 $k$ 无关。预测：随着 $N$ 的增加，固定的延迟导致尝试变得均匀分布，因此吞吐量随 $N$ 严格增加，并且可能超过 $1/t_{c}$，因为固定延迟平滑了竞争。\n\nC. 无上限的线性随机退避：在 $k$ 次失败后，等待 $W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}+c\\cdot k\\right)$，无上限；成功时重置为 $s_{\\min}$。预测：对于大的 $N$，与指数退避相比，这避免了过度抑制，因此产生比指数退避更高的吞吐量；吞吐量会随着 $N$ 缓慢提升，因为平均窗口仅随 $k$ 线性扩展。\n\nD. 加性减少、乘性增加的确定性步骤：每次失败时，将当前等待时间乘以一个因子 $\\beta>1$；每次成功时，从当前等待时间中减去一个固定的 $\\delta>0$（但不能低于 $0$）；无随机性。预测：该方案会自我调整，使得平均窗口大小与 $N$ 成正比，在大的 $N$ 下产生吞吐量 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$，并且由于更好的调优，吞吐量会随着 $N$ 的增长而提高。\n\n选择正确的选项。", "solution": "用户要求对问题陈述进行严格验证，然后提供详细的解决方案和对所给选项的评估。\n\n### 问题验证\n\n**第1步：提取已知条件**\n- **系统**: 一个缓存一致性多处理器。\n- **同步原语**: 一个使用测试并设置 (TAS) 指令实现的单一共享自旋锁。\n- **TAS 语义**: 原子地读取一个内存位置并将其设置为一个锁定值。返回先前的值。如果先前的值表明‘空闲’，则获得锁。否则，尝试失败。\n- **工作负载**: $N$ 个相同的线程，每个线程在非临界区（平均持续时间 $t_n$）和临界区（平均持续时间 $t_c$）之间交替执行。\n- **竞争成本**: 一次失败的 TAS 尝试会产生 $\\tau$ 的成本（一致性流量、停顿）。并发的 TAS 尝试会导致缓存行“乒乓”效应。\n- **硬件特性**: 提供 CPU `pause` 指令用于等待，期间不产生一致性流量。\n- **退避策略约束**: 退避策略必须仅使用自上次成功获取以来连续失败的 TAS 操作次数 $k$ 来适应竞争。成功时 $k$ 重置为 $0$。\n- **性能指标**: 吞吐量，定义为单位时间内成功获取锁的稳态速率。问题陈述正确地指出，吞吐量的上限为 $1/t_c$。\n- **目标**: 选择一个正确指明了以下两点的选项：（1）一种基于 $k$ 的竞争自适应退避策略，以及（2）一个关于当 $N$ 变化时吞吐量行为的定性正确的预测。\n\n**第2步：使用提取的已知条件进行验证**\n根据验证标准检查问题陈述。\n\n- **科学性**: 该问题植根于计算机体系结构和操作系统的基本原理。诸如缓存一致性、原子指令 (TAS)、自旋锁、竞争、一致性风暴（缓存行乒乓效应）和退避算法等概念都是标准且成熟的主题。对其相互作用的描述是准确的。\n- **适定性**: 该问题是适定的。它要求从一组选项中确定对标准竞争控制机制及其性能特征的最佳描述。问题的定性性质适合于对系统性能的概念性理解，并且可以从第一性原理中推断出唯一的最佳答案。\n- **客观性**: 问题陈述是客观的，并使用了精确的技术术语。它不包含主观或基于意见的主张。\n\n该问题没有表现出任何无效性缺陷：\n1.  **科学上不健全**: 它没有违反任何科学原理。系统的物理特性描述正确。\n2.  **无法形式化**: 该问题是并发系统性能建模中的一个标准课题。\n3.  **设置不完整或矛盾**: 设置提供了足够的信息来推断不同策略的定性行为。\n4.  **不切实际或不可行**: 该场景是对多处理器系统中共享资源竞争的真实描述。\n5.  **不适定**: 问题是明确的。\n6.  **伪深刻/琐碎**: 该问题需要对竞争动态和不同退避策略的属性有非凡的理解。\n7.  **超出科学可验证性范围**: 选项中提出的主张可以并且已经被分析和经验性地研究过。\n\n**第3步：结论和行动**\n问题陈述是**有效的**。将推导解决方案。\n\n### 解决方案的推导\n\n问题的核心是在 $N$ 个竞争线程中管理对单一共享资源（自旋锁）的竞争。\n\n**竞争控制的第一性原理：**\n1.  **竞争问题**: 当锁被释放时，多个等待的线程可能会同时尝试 TAS 指令。在缓存一致性系统上，这会导致“一致性风暴”，即包含锁变量的缓存行在互连网络上被反复无效化和获取。这会产生大量的总线/互连流量，并显著增加锁交接的延迟。在最坏的情况下，随着 $N$ 的增加，吞吐量可能会崩溃。\n2.  **退避的作用**: 为了缓解这种情况，线程在一次失败的 TAS 尝试后应该等待（或“退避”）一段时间再重试。这是通过使用 `pause` 指令来完成的，以避免在等待时消耗执行资源和产生流量。\n3.  **有效退避策略的特性**：\n    *   **适应性**: 等待时间应随着竞争水平的增加而增加。竞争的一个局部启发式方法是连续失败尝试的次数 $k$。\n    *   **随机化**: 等待时间应该是随机的。如果所有线程都使用相同的确定性退避延迟，它们很可能会同步重试，导致大规模尝试和冲突的重复循环。随机化打破了这种对称性。\n4.  **吞吐量特性**：\n    *   绝对最大吞吐量是 $1/t_c$，只有在锁转移开销为零时才能实现。\n    *   对于小的 $N$，竞争很低，因此退避引起的开销应该很小。吞吐量应该接近 $1/t_c$。\n    *   对于大的 $N$，一个有效的退避算法应该能稳定系统。它应确保在平均情况下，当锁被释放时，只有少数、恒定数量的线程在积极尝试获取锁。这使得锁交接开销有界，即相对于 $N$ 是 $O(1)$。因此，每次获取的总时间变为 $t_c + \\text{常数开销}$。因此，吞吐量应该饱和并趋于一个小于 $1/t_c$ 的常数值。它不应该继续减少到零，也不应该随着 $N$ 的增加而继续增加。\n\n### 逐项分析\n\n**A. 带下限和上限的指数随机退避... 预测: ...吞吐量接近一个常数 $1/\\left(t_{c}+O(\\tau)\\right)$...**\n- **策略**: 提议的策略是截断的随机指数退避。等待时间 $W$ 从均匀分布 $\\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}\\cdot 2^{k}\\right)$ 中抽取，并受限于 $s_{\\max}$。这个机制是自适应的（等待时间随 $k$ 指数增长）、随机的（打破对称性）和有界的（避免病态延迟）。这是用于竞争控制的典型且高效的策略，用于以太网的 CSMA/CD 协议等上下文中。\n- **预测**: 该预测在定性上是正确的。\n    - 对于小的 $N$，竞争低，$k$ 小，退避最小，吞吐量接近理想的 $1/t_c$。\n    - 对于大的 $N$，退避窗口大小的指数增长有效地限制了活跃竞争者的数量，防止了一致性风暴。这导致了一个稳定、有界的锁交接时间，其特征为 $O(1)$，或者更具体地说，与几次失败尝试的成本 $O(\\tau)$ 相关。每次临界区执行的总时间变为 $t_c + \\text{常数开销}$。因此，吞吐量饱和于一个常数值 $1/(t_c + \\text{常数开销})$，这与 $1/(t_c + O(\\tau))$ 一致。\n- **结论**: **正确**。\n\n**B. 固定确定性延迟... 预测: ...吞吐量随 $N$ 严格增加，并且可能超过 $1/t_{c}$...**\n- **策略**: 使用固定的、确定性的延迟 $s_0$。这是有缺陷的。它不适应竞争的水平。更重要的是，它的确定性是一个关键弱点。如果多个线程同时失败，它们将等待相同的持续时间 $s_0$ 并同步重试，导致另一次冲突。\n- **预测**: 该预测存在根本性缺陷。\n    - “...吞吐量随 $N$ 严格增加”：这是不正确的。随着 $N$ 的增长，竞争加剧，一个非自适应的、确定性的方案很可能导致性能下降，而不是提高。\n    - “...可能超过 $1/t_c$”：这违反了第一性原理。临界区本身构成了一个串行瓶颈；它一次只能由一个线程执行，平均持续时间为 $t_c$。因此，最大完成率是 $1/t_c$。任何退避方案都不能将吞吐量提高到这个物理极限之上。\n- **结论**: **不正确**。\n\n**C. 无上限的线性随机退避... 预测: ...产生比指数退避更高的吞吐量；吞吐量会随着 $N$ 缓慢提升...**\n- **策略**: 该策略 $W \\sim \\mathrm{Uniform}\\!\\left(0,\\, s_{\\min}+c\\cdot k\\right)$ 是自适应和随机的。线性退避是一种可能的策略。\n- **预测**: 该预测是值得怀疑的。\n    - “...避免过度抑制...产生比指数退避更高的吞吐量”：这不是一个普遍真理。虽然一个未经调优的指数退避可能会过度抑制，但一个调优良好的指数退避被认为是鲁棒的。线性退避可能无法足够快地增加其延迟来平息非常高的竞争，可能导致比指数退避*更低*的吞吐量。\n    - “...吞吐量会随着 $N$ 缓慢提升”：这对于一个饱和系统来说是不正确的。一旦线程数 $N$ 足够大，以确保总有至少一个线程在等待进入临界区，增加更多的线程（$N' > N$）并不能提高吞吐量。在最好的情况下，一个理想的退避方案将维持一个恒定的饱和吞吐量。\n- **结论**: **不正确**。\n\n**D. 加性减少、乘性增加的确定性步骤... 预测: ...在大的 $N$ 下吞吐量 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$，随着 $N$ 的增长而提高...**\n- **策略**: 这描述了一个乘性增加、加性减少 (MIAD) 的方案。失败时，等待时间乘以 $\\beta > 1$；成功时，减少 $\\delta > 0$。关键缺陷是它是“确定性的”。与选项B一样，这种缺乏随机性会导致同步重试和冲突。\n- **预测**: 该预测在物理上是不现实的。\n    - 吞吐量形式 $\\approx \\left(1-\\Theta\\!\\left(1/N\\right)\\right)/t_{c}$ 意味着当 $N \\to \\infty$ 时，项 $\\Theta(1/N) \\to 0$，因此吞吐量接近理想极限 $1/t_c$。这表明当竞争变得无限大时，锁转移开销消失了，这是不可能的。获取锁总会有一些非零的开销。\n    - 它还声称吞吐量“随着 $N$ 的增长而提高”，正如对选项C的解释，这对于一个饱和系统来说不是预期的行为。\n- **结论**: **不正确**。\n\n基于分析，选项A既提供了一种标准、有效的算法（截断的随机指数退避），也对其性能特征（在高竞争下饱和到一个恒定的吞吐量）做出了定性正确的预测。", "answer": "$$\\boxed{A}$$", "id": "3686949"}, {"introduction": "在定性地理解了退避策略对性能的重要性之后，我们可以更进一步，利用数学工具来定量地分析自旋锁系统的性能。这个练习将引导你运用排队论（queueing theory）这一强大的分析框架，将争夺锁的线程们看作是一个 $M/G/1$ 排队系统。通过建立模型并推导，你将得出一个关于系统吞吐量的精确表达式，并深刻理解服务时间的可变性（variability）等因素是如何具体影响锁的竞争开销的。[@problem_id:3686955]", "problem": "对称多处理器上的一个共享临界区由一个测试并设置（TAS）自旋锁保护。当锁被持有时，竞争者会立即重试 TAS 指令，直到锁被释放。每次失败的 TAS 尝试都会引发一次一致性事务，在解锁交接期间消耗一个确定性的时间惩罚 $\\tau$ 秒，并且这些一致性事务在解锁点串行化，增加了连续进入临界区之间的时间。\n\n假设以下建模前提。\n\n- 竞争者根据速率为每秒 $\\lambda$ 个请求的泊松过程到达临界区。\n- 固有（无竞争）临界区服务时间 $S$ 在各个请求之间是独立同分布的，其均值为 $\\mathbb{E}[S] = 1/\\mu$，变异系数的平方为 $c_{s}^{2} = \\operatorname{Var}(S) / \\mathbb{E}[S]^{2}$。\n- 在稳态下，该锁以先到先服务（FCFS）的顺序调度进入，因此请求流和服务规则可以被建模为一个 $M/G/1$ 队列。\n- 由失败的 TAS 尝试引起的竞争开销计算如下：每次解锁时，如果有 $Q$ 个等待的竞争者，则会发生恰好 $Q$ 次失败的 TAS 尝试并串行化，在下一次服务开始前增加一个额外的交接时间 $Q \\tau$。\n- 使用一阶近似，即队列长度统计量 $Q$ 是根据 $S$ 计算的底层 $M/G/1$ 队列的统计量（也就是说，竞争开销不会改变决定队列统计量的 $S$ 的分布），并假设系统稳定 $\\rho \\equiv \\lambda \\mathbb{E}[S]  1$。\n\n从更新理论和 $M/G/1$ 排队论中经过充分检验的结果（例如，涉及 $\\mathbb{E}[S]$ 和 $\\mathbb{E}[S^{2}]$ 的表达式）出发，在上述近似条件下，推导出稳态吞吐量 $X$（每秒完成的临界区数量）作为 $\\lambda$、$\\mu$、$c_{s}^{2}$ 和 $\\tau$ 的闭式函数。在您的推导中，明确指出服务时间变异性 $c_{s}^{2}$ 如何影响解锁时的预期碰撞强度和平均等待时间。将最终吞吐量 $X(\\lambda,\\mu,c_{s}^{2},\\tau)$ 报告为单个闭式解析表达式。不需要数值近似，最终方框内的答案不应出现单位。", "solution": "用户希望找到一个由测试并设置（TAS）自旋锁保护的临界区的稳态吞吐量。问题为该系统提供了一个详细的模型，包括到达过程、服务时间以及由竞争引起的开销。\n\n### 第 1 步：模型形式化\n\n首先，我们根据给定的条件将问题形式化。\n- 竞争者的到达是一个速率为 $\\lambda$ 的泊松过程。\n- 固有服务时间 $S$ 的均值为 $\\mathbb{E}[S] = 1/\\mu$，变异系数的平方为 $c_s^2$。\n- 系统被建模为 M/G/1 队列。\n- 假设底层队列的稳定性条件为：$\\rho = \\lambda \\mathbb{E}[S] = \\lambda/\\mu  1$。\n- 在一次服务完成后，会产生 $Q\\tau$ 的开销时间，其中 $Q$ 是等待的竞争者数量，$\\tau$ 是每个竞争者的恒定惩罚。\n- 给出了一个关键的一阶近似：队列长度 $Q$ 的统计数据应从服务时间为 $S$ 的底层 M/G/1 队列计算得出，此计算忽略了额外的开销。\n\n问题要求计算稳态吞吐量 $X$，定义为每秒完成的临界区数量。在排队系统中，吞吐量可以有两种解释：\n1.  对于一个稳定系统，吞吐量等于到达率，即 $X = \\lambda$。\n2.  容量，或最大可能吞吐量，是系统在饱和时达到的最大服务率。\n\n鉴于问题要求将 $X$ 表示为所有模型参数（$\\lambda$、$\\mu$、$c_s^2$、$\\tau$）的函数，将 $X$ 简单地解释为 $\\lambda$ 将无法把其他参数纳入最终表达式中。因此，最合乎逻辑的解释是，问题要求的是在给定负载 $\\lambda$ 下系统的有效服务率。这个速率表示在由 $\\lambda$ 产生的竞争水平下，系统可以维持的最大吞吐量。我们将这个有效服务率表示为 $X$。\n\n有效服务率是平均有效服务时间 $\\mathbb{E}[S_{eff}]$ 的倒数。\n$$X = \\frac{1}{\\mathbb{E}[S_{eff}]}$$\n有效服务时间 $S_{eff}$ 是由于单个请求而导致锁不可用的总时间。它等于固有服务时间 $S$ 与交接开销之和，而交接开销取决于服务完成时的队列长度 $Q$。\n$$\\mathbb{E}[S_{eff}] = \\mathbb{E}[S] + \\mathbb{E}[\\text{Overhead}]$$\n开销由 $Q$ 个竞争进程引起，每个进程都导致一个惩罚 $\\tau$。因此，平均开销为 $\\mathbb{E}[Q\\tau]$。由于 $\\tau$ 是一个确定性常数，这可以简化为 $\\tau \\mathbb{E}[Q]$。\n$$\\mathbb{E}[S_{eff}] = \\mathbb{E}[S] + \\tau \\mathbb{E}[Q]$$\n\n### 第 2 步：计算平均队列长度 $\\mathbb{E}[Q]$\n\n问题的核心在于使用给定的近似值计算 $\\mathbb{E}[Q]$。我们使用基础 M/G/1 队列（到达率为 $\\lambda$，服务时间为 $S$）的统计数据。队列中等待的平均竞争者数量 $\\mathbb{E}[Q]$ 由 Pollaczek-Khinchine 公式给出，即队列中的平均顾客数 $L_q$。\n$$ \\mathbb{E}[Q] = L_q = \\frac{\\lambda^2 \\mathbb{E}[S^2]}{2(1-\\rho)} $$\n其中 $\\rho = \\lambda \\mathbb{E}[S]$。\n\n我们需要用给定的参数来表示 $\\mathbb{E}[S^2]$ 和 $\\rho$。\n- 基础系统的利用率为 $\\rho = \\lambda \\mathbb{E}[S] = \\lambda / \\mu$。\n- 服务时间的二阶矩 $\\mathbb{E}[S^2]$ 通过方差的定义与均值 $\\mathbb{E}[S]$ 和变异系数的平方 $c_s^2$ 相关联：\n$$ \\operatorname{Var}(S) = \\mathbb{E}[S^2] - (\\mathbb{E}[S])^2 $$\n$$ c_s^2 = \\frac{\\operatorname{Var}(S)}{(\\mathbb{E}[S])^2} = \\frac{\\mathbb{E}[S^2] - (\\mathbb{E}[S])^2}{(\\mathbb{E}[S])^2} = \\frac{\\mathbb{E}[S^2]}{(\\mathbb{E}[S])^2} - 1 $$\n求解 $\\mathbb{E}[S^2]$：\n$$ \\mathbb{E}[S^2] = (1+c_s^2)(\\mathbb{E}[S])^2 = \\frac{1+c_s^2}{\\mu^2} $$\n现在，我们将这些表达式代入 $\\mathbb{E}[Q]$ 的公式中：\n$$ \\mathbb{E}[Q] = \\frac{\\lambda^2 \\left( \\frac{1+c_s^2}{\\mu^2} \\right)}{2(1 - \\lambda/\\mu)} = \\frac{\\lambda^2 (1+c_s^2)}{2\\mu^2 \\left( \\frac{\\mu-\\lambda}{\\mu} \\right)} = \\frac{\\lambda^2 (1+c_s^2)}{2\\mu(\\mu-\\lambda)} $$\n\n### 第 3 步：服务时间变异性（$c_s^2$）的影响\n\n根据问题的要求，我们明确指出 $c_s^2$ 的影响。\n- **对预期碰撞强度的影响**：“预期碰撞强度”一词指的是解锁时失败的 TAS 尝试的预期次数，即 $\\mathbb{E}[Q]$。我们推导出的表达式 $\\mathbb{E}[Q] = \\frac{\\lambda^2(1+c_s^2)}{2\\mu(\\mu-\\lambda)}$ 表明，等待竞争者的预期数量与因子 $(1+c_s^2)$ 成正比。临界区服务时间的更高变异性（即更大的 $c_s^2$）会导致队列更具“突发性”，增加了在服务完成时发现一长队竞争者的概率。这反过来又增加了串行化开销。\n- **对平均等待时间的影响**：底层队列的平均等待时间 $W_q$ 通过利特尔法则（Little's Law）与 $\\mathbb{E}[Q]$ 相关：$W_q = L_q / \\lambda = \\mathbb{E}[Q]/\\lambda$。\n$$ W_q = \\frac{\\lambda(1+c_s^2)}{2\\mu(\\mu-\\lambda)} $$\n与队列长度类似，等待时间也随 $(1+c_s^2)$ 线性增加。更高的服务时间变异性增加了请求在开始服务前必须等待的平均时间。\n\n### 第 4 步：最终吞吐量表达式的推导\n\n现在我们组合出吞吐量 $X$ 的最终表达式。\n我们有平均有效服务时间：\n$$ \\mathbb{E}[S_{eff}] = \\mathbb{E}[S] + \\tau \\mathbb{E}[Q] = \\frac{1}{\\mu} + \\tau \\left( \\frac{\\lambda^2 (1+c_s^2)}{2\\mu(\\mu-\\lambda)} \\right) $$\n为了合并这些项，我们找到一个公分母 $2\\mu(\\mu-\\lambda)$：\n$$ \\mathbb{E}[S_{eff}] = \\frac{2(\\mu-\\lambda)}{2\\mu(\\mu-\\lambda)} + \\frac{\\lambda^2 (1+c_s^2) \\tau}{2\\mu(\\mu-\\lambda)} = \\frac{2(\\mu-\\lambda) + \\lambda^2 (1+c_s^2) \\tau}{2\\mu(\\mu-\\lambda)} $$\n吞吐量 $X$，被解释为有效服务率，是这个平均有效服务时间的倒数：\n$$ X = \\frac{1}{\\mathbb{E}[S_{eff}]} = \\frac{2\\mu(\\mu-\\lambda)}{2(\\mu-\\lambda) + \\lambda^2 (1+c_s^2) \\tau} $$\n这个表达式表示每秒完成的临界区速率，考虑了由竞争引起的开销。它是所有指定参数 $\\lambda$、$\\mu$、$c_s^2$ 和 $\\tau$ 的闭式函数。此公式在问题假设底层队列稳定（即 $\\lambda  \\mu$）的条件下有效。如果 $\\lambda \\geq \\mu$，$\\mathbb{E}[Q]$ 会变为无穷大，导致无限的开销和零吞吐量，这种情况被 $X$ 表达式的分母正确地捕捉到了。", "answer": "$$ \\boxed{\\frac{2\\mu(\\mu-\\lambda)}{2(\\mu-\\lambda) + \\lambda^2 (1+c_{s}^{2}) \\tau}} $$", "id": "3686955"}]}