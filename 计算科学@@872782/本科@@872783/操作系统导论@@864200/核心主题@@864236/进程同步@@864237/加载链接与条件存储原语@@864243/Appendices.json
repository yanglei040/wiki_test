{"hands_on_practices": [{"introduction": "我们实践的第一步是利用更底层的 `load-linked` (LL) 和 `store-conditional` (SC) 原语来构建一个众所周知的原子操作：`compare-and-swap` (CAS)。这个练习不仅能让你掌握 LL/SC 的基本重试循环模式，还将引导你从第一性原理出发，分析其正确性，并推导在竞争环境下的性能表现。通过这个练习[@problem_id:3621226]，你将深入理解原子操作的构建和其理论保障。", "problem": "考虑一个具有一致性缓存的共享内存多处理器，它提供加载链接 (Load-Link, LL) 和条件存储 (Store-Conditional, SC) 指令，其架构级语义如下：$LL(a)$ 读取地址 $a$ 的当前值，并对 $a$ 建立一个预留；随后的 $SC(a,v)$ 仅当自建立预留以来没有发生对 $a$ 的冲突存储时，才将值 $v$ 写入 $a$，否则 $SC(a,v)$ 失败且不写入。即使没有发生冲突存储，失败的 $SC$ 也可能以独立的概率 $\\sigma \\in [0,1)$ 伪失败。假设 $LL$ 具有 acquire 语义，成功的 $SC$ 具有 release 语义。\n\n软件接口公开了比较并交换 (Compare-And-Swap, CAS)：$CAS(a,e,n)$ 原子地读取 $a$，如果观察到的值等于 $e$，则写入 $n$；否则保持 $a$ 不变。它返回从 $a$ 读取的旧值。你需要使用 $LL/SC$ 来合成 $CAS(a,e,n)$ 的语义，并从第一性原理出发进行推理，以确定所合成的 $CAS$ 在给定架构模型下实现可线性化和无锁所需的最小正确性约束。你的推理必须从 $LL/SC$、$CAS$、可线性化性和无锁的核心定义开始；你不得假设超出这些定义的任何捷径属性。\n\n然后，考虑 $k$ 个可能向同一地址 $a$ 进行存储的并发干扰线程。将每个干扰线程对 $a$ 的存储建模为速率为 $\\lambda_i$ 的独立泊松过程，其中 $i \\in \\{1,2,\\dots,k\\}$，并定义 $\\Lambda = \\sum_{i=1}^{k} \\lambda_i$。假设一次 $LL$ 操作及其后续的决策逻辑和匹配的 $SC$ 尝试，在 $LL$ 结束和 $SC$ 发起之间占据一个长度为 $\\tau > 0$ 的确定性时间窗口，在此期间任何对 $a$ 的干扰存储都会破坏预留。假设连续的 $LL/SC$ 尝试之间由独立的思考时间隔开，使得跨尝试的干扰是独立同分布的，并且调用 $CAS$ 的线程仅将那些 $LL$ 读取的值等于 $e$ 但 $SC$ 失败（由于预留冲突或伪失败）的循环迭代计为重试。在此模型下，推导在合成的 $CAS$ 完成其写入之前（即，在观察到 $e$ 的 $LL$ 之后、第一次成功 $SC$ 之前，失败的 $SC$ 尝试的期望次数）的期望重试次数 $\\mathbb{E}[R]$ 的闭式解析表达式。\n\n你的最终答案必须是关于 $\\Lambda$、$\\tau$ 和 $\\sigma$ 的单个闭式解析表达式。最终答案中不要包含任何单位。", "solution": "所提出的问题是有效且定义明确的，包含三个部分：使用加载链接/条件存储 ($LL/SC$) 合成比较并交换 ($CAS$) 原子原语，从第一性原理证明其正确性，并在一个随机模型下推导其性能。\n\n首先，我们合成 $CAS(a, e, n)$ 的语义，该操作原子地从内存地址 $a$ 读取数据，如果其值等于 $e$，则写入 $n$。它返回最初读取的值。这可以通过在重试循环中使用 $LL/SC$ 来实现。$LL(a)$ 指令读取值并建立一个预留。$SC(a, n)$ 指令尝试写入，仅在预留完好时才能成功。\n\n合成的算法如下：\n函数 $CAS(a, e, n)$:\n$1.$ 启动一个无限循环。\n$2.$ 在循环内部，执行 $v_{old} \\leftarrow LL(a)$。这会读取地址 $a$ 的当前值到一个局部变量 $v_{old}$ 中，并对 $a$ 设置一个预留。$LL$ 指令具有 acquire 语义。\n$3.$ 将 $v_{old}$ 与期望值 $e$进行比较。\n$4.$ 如果 $v_{old} \\neq e$，则交换的前提条件不满足。操作必须在不修改内存的情况下失败。预留被隐式丢弃，函数返回 $v_{old}$。\n$5.$ 如果 $v_{old} = e$，则条件满足。尝试通过执行 $SC(a, n)$ 将新值 $n$ 原子地写入地址 $a$。\n$6.$ 检查 $SC$ 指令的结果。一次成功的 $SC$ 具有 release 语义。\n$7.a.$ 如果 $SC(a, n)$ 成功，这意味着自 $LL$ 操作以来没有其他处理器写入过 $a$（并且没有发生伪失败）。原子交换完成。函数返回 $v_{old}$（该值等于 $e$），循环终止。\n$7.b.$ 如果 $SC(a, n)$ 失败，则对 $a$ 的预留被一次冲突的存储或一个伪事件所破坏。此次 $SC$ 不会修改地址 $a$ 处的内存。循环进入下一次迭代，重试整个 $LL-SC$ 序列。\n\n其次，我们通过证明可线性化性和无锁性来确定该合成的正确性。\n\n可线性化性要求每个操作看起来都在其调用和响应之间的一个唯一的、可识别的“线性化点”上瞬时生效。\n对于我们合成的 $CAS$：\n- 如果 $CAS(a, e, n)$ 操作成功（即它将 $n$ 写入 $a$），线性化点是成功的 $SC(a, n)$ 指令被内存系统执行的那个瞬间。在这一刻，$a$ 在内存中的状态从 $e$ 原子地变为 $n$。操作返回 $e$，这是此时间点之前的值，符合 $CAS$ 的规范。\n- 如果 $CAS(a, e, n)$ 操作因为 $LL$ 读取的值 $v_{old} \\neq e$ 而失败，则没有写入发生。线性化点是 $LL(a)$ 指令读取值 $v_{old}$ 的那个瞬间。该操作等价于一次读取，并返回它观察到的值，这与 $CAS$ 的规范一致。\n- 循环内失败的 $SC$ 尝试不构成一个完整的 $CAS$ 操作，因此没有线性化点。它是一个尚未完成的操作的内部步骤。\n$LL$ 的 acquire 语义和成功的 $SC$ 的 release 语义确保了即使在具有宽松内存一致性模型的系统上，这些线性化点相对于其他线程中的内存操作也能被正确排序。\n\n无锁保证了系统级的进展，意味着在任何足够长的时间间隔内，至少有一个活动线程会完成其操作。\n考虑多个线程在同一地址 $a$ 上并发执行我们合成的 $CAS$。如果有两个或更多线程执行 $LL(a)$ 并读取了相同的值 $e$，它们都将继续尝试 $SC$。硬件会对这些并发的 $SC$ 尝试进行仲裁，保证最多只有一个能够成功。其 $SC$ 成功的线程完成了它的 $CAS$ 操作，从而取得了进展。所有其他因预留被成功写入破坏而导致 $SC$ 尝试失败的线程将循环并重试。因为一个线程取得了进展，所以整个系统也取得了进展。一次伪 $SC$ 失败（以概率 $\\sigma  1$ 发生）会导致一个线程重试，但不会无限期地停止进展。对于一个单独的、无竞争的线程，其连续发生无限次伪失败的概率是 $\\lim_{N \\to \\infty} \\sigma^N = 0$。因此，总能保证某个线程最终会成功，该算法是无锁的。\n\n第三，我们推导期望重试次数 $\\mathbb{E}[R]$。“重试”被定义为一次循环迭代，其中 $LL$ 读取了 $e$ 但随后的 $SC$ 失败了。我们被要求计算在一次成功的 $SC$ 之前的这类重试的期望次数。这是一个可以用几何分布建模的经典问题。设 $p$ 为在前面的 $LL$ 读取了 $e$ 的情况下，一次 $SC$ 尝试成功的概率。重试次数 $R$ 是指在第一次成功之前失败的次数。随机变量 $R$ 服从几何分布，其 $P(R = j) = (1-p)^j p$，其中 $j \\in \\{0, 1, 2, \\dots\\}$。这样一个随机变量的期望是 $\\mathbb{E}[R] = \\frac{1-p}{p}$。\n\n我们的任务简化为计算 $p$。一次 $SC$ 操作当且仅当两个独立的条件都满足时才会成功：\n$1.$ 在 $LL$ 和 $SC$ 之间持续时间为 $\\tau$ 的漏洞窗口内没有发生冲突存储。\n$2.$ 没有发生伪失败。\n\n设 $\\mathcal{E}_{conflict}$ 为发生冲突存储的事件，$\\mathcal{E}_{spur}$ 为发生伪失败的事件。成功的概率是 $p = P(\\mathcal{E}_{conflict}^c \\cap \\mathcal{E}_{spur}^c)$。\n问题陈述指出这些事件是独立的，所以 $p = P(\\mathcal{E}_{conflict}^c) P(\\mathcal{E}_{spur}^c)$。\n\n伪失败的概率给定为 $\\sigma$。因此，没有伪失败的概率是 $P(\\mathcal{E}_{spur}^c) = 1 - \\sigma$。\n\n来自 $k$ 个干扰线程的冲突存储被建模为 $k$ 个速率为 $\\lambda_i$ 的独立泊松过程的叠加。冲突存储的总到达过程是一个速率为 $\\Lambda = \\sum_{i=1}^{k} \\lambda_i$ 的单一泊松过程。\n如果在长度为 $\\tau$ 的时间窗口内至少发生一次存储事件，则发生冲突。此窗口内的事件数 $N(\\tau)$ 服从均值为 $\\mu = \\Lambda \\tau$ 的泊松分布。观察到 $j$ 个事件的概率是 $P(N(\\tau)=j) = \\frac{(\\Lambda \\tau)^j \\exp(-\\Lambda \\tau)}{j!}$。\n没有冲突的概率 $P(\\mathcal{E}_{conflict}^c)$ 是指在该窗口内发生零个事件的概率：\n$$P(\\mathcal{E}_{conflict}^c) = P(N(\\tau)=0) = \\frac{(\\Lambda \\tau)^0 \\exp(-\\Lambda \\tau)}{0!} = \\exp(-\\Lambda \\tau)$$\n结合这些概率，一次 $SC$ 尝试的总体成功概率是：\n$$p = P(\\mathcal{E}_{conflict}^c) P(\\mathcal{E}_{spur}^c) = \\exp(-\\Lambda \\tau) (1 - \\sigma)$$\n现在我们可以计算期望重试次数 $\\mathbb{E}[R]$：\n$$\\mathbb{E}[R] = \\frac{1-p}{p} = \\frac{1 - (1-\\sigma)\\exp(-\\Lambda \\tau)}{(1-\\sigma)\\exp(-\\Lambda \\tau)}$$\n这个表达式可以简化：\n$$\\mathbb{E}[R] = \\frac{1}{(1-\\sigma)\\exp(-\\Lambda \\tau)} - \\frac{(1-\\sigma)\\exp(-\\Lambda \\tau)}{(1-\\sigma)\\exp(-\\Lambda \\tau)} = \\frac{\\exp(\\Lambda \\tau)}{1-\\sigma} - 1$$\n这就是期望重试次数的最终闭式解析表达式。", "answer": "$$\\boxed{\\frac{\\exp(\\Lambda \\tau)}{1-\\sigma} - 1}$$", "id": "3621226"}, {"introduction": "在掌握了基本的构建模块后，我们将挑战一个更复杂的应用：使用 LL/SC 实现一个支持整数回绕的模块化 `fetch-and-add` 操作。这个练习[@problem_id:3654150]的核心在于验证并发执行下的线性一致性 (linearizability)，确保即使在多线程竞争和偶发性失败的情况下，操作的最终结果也与顺序执行等效。这能极大地锻炼你在复杂并发场景下设计和验证正确算法的能力。", "problem": "您的任务是通过构造和验证来确定抽象的 Load-Linked (LL) 和 Store-Conditional (SC) 原语是否可以在并发执行下实现一个正确的模块化 fetch-add 操作，同时正确处理整数回绕和伪失败，并保持线性化。验证过程必须表达为一个可运行的程序，该程序纯粹基于数学和逻辑构造运行，无外部输入。该程序必须实现一个模拟的基于 LL/SC 的模块化 fetch-add，执行一组有界的并发操作，然后基于从第一性原理推导出的形式化准则来判断其正确性。\n\n定义和基础：\n- 一个共享内存位置是一个单写入者变量，可以被原子地读取和写入。将共享状态定义为集合 $\\{0,1,\\dots,M-1\\}$ 中的一个无符号整数，其中 $M = 2^w$，对于给定的位宽 $w$。\n- Load-Linked (LL) 读取共享内存位置的当前值 $x$ 并将其链接，使得后续的存储条件操作以没有中间写入发生为条件。\n- Store-Conditional (SC) 尝试将新值 $y$ 写入同一位置，仅当自配对的 Load-Linked 操作以来没有发生中间写入时才会成功。即使没有中间写入，Store-Conditional 也可能发生伪失败。\n- 对于整数模 $M$ 和加数 $a$ 的模块化 fetch-add 操作，将状态 $x$ 映射到新状态 $(x + a) \\bmod M$，并向调用者返回旧状态 $x$。对于从初始状态 $x_0$ 开始的 $N$ 个此类操作，其顺序规范产生的返回值序列为 $r_i = (x_0 + i \\cdot a) \\bmod M$ (对于 $i \\in \\{0,1,\\dots,N-1\\}$)，最终状态为 $x_N = (x_0 + N \\cdot a) \\bmod M$。\n- 线性化要求每个操作看起来像是在其调用和响应之间的某个瞬间生效，并且总体效果必须等同于上述的顺序规范。\n- 回绕行为由模 $M = 2^w$ 的算术精确建模。整数溢出不是错误；它通过模运算表现为回繞。当 $\\gcd(a, M)  1$ 时会出现短周期，周期长度为 $L = \\frac{M}{\\gcd(a, M)}$；在 $L$ 次操作后，返回值的序列会重复。\n\n您的程序必须：\n- 实现一个模拟的基于 LL/SC 的模块化 fetch-add 函数，该函数：\n  - 读取当前值 $x$。\n  - 计算 $y = (x + a) \\bmod M$。\n  - 尝试条件性存储 $y$，并循环直到成功。该函数可以以指定的周期性注入 Store-Conditional 的确定性伪失败，以模拟 Store-Conditional 即使在没有干扰的情况下也可能失败。\n  - 在 Store-Conditional 成功时返回观察到的旧值 $x$。\n- 执行一组并发线程，每个线程在从初始状态 $x_0$ 开始的模 $M$ 共享计数器上，使用相同的加数 $a$ 执行指定数量的 fetch-add 操作。\n- 收集所有返回的旧值，并验证以下关于线性化和回绕的正确性标准：\n  1. 最终值等于 $x_N = (x_0 + N \\cdot a) \\bmod M$，其中 $N$ 是所有线程执行的总操作数。\n  2. 返回的旧值的多重集等于多重集 $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$，并考虑了当 $\\gcd(a, M)  1$ 时可能出现的回绕和周期重复。\n\n测试套件：\n提供以下测试用例，每个用例由元组 $(w, x_0, a, T, K, s)$ 定义，其中 $w$ 是位宽，$x_0$ 是初始状态，$a$ 是加数，$T$ 是线程数，$K$ 是每个线程的操作数，$s$ 是伪失败周期性（$s = 0$ 表示禁用）。设 $M = 2^w$ 且 $N = T \\cdot K$。\n- 测试用例 1: $(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$。这是一般情况；$N = 40$；不会发生回绕，因为 $5 + 40  256$。\n- 测试用例 2: $(w, x_0, a, T, K, s) = (8, 250, 1, 2, 10, 0)$。此用例测试回绕情况；$N = 20$；最终值为 $(250 + 20) \\bmod 256 = 14$。\n- 测试用例 3: $(w, x_0, a, T, K, s) = (8, 3, 2, 3, 60, 0)$。此用例强调周期重复，因为 $\\gcd(2, 256) = 2$；周期长度为 $L = \\frac{256}{2} = 128$，所以当 $N = 180  128$ 时，返回值的多重集中会出现重复项。\n- 测试用例 4: $(w, x_0, a, T, K, s) = (8, 0, 1, 3, 50, 2)$。此用例每 $2$ 次尝试注入一次确定性的 Store-Conditional 伪失败，同时仍要求取得进展；$N = 150$；最终值为 $(0 + 150) \\bmod 256 = 150$。\n\n输出规范：\n- 对于每个测试用例 $i \\in \\{1,2,3,4\\}$，程序必须计算一个布尔指示符 $b_i$，如果两个正确性标准都成立，则其值为 $1$，否则为 $0$。\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，格式应完全为 $[b_1,b_2,b_3,b_4]$。", "solution": "我们从 Load-Linked 和 Store-Conditional 的基本定义开始。Load-Linked (LL) 读取当前值并建立一个链接，该链接可被任何中间写入操作invalidate。Store-Conditional (SC) 尝试写入一个新值，且仅当此链接保持有效时才成功。重要的是，Store-Conditional 即使在没有中间写入的情况下也可能发生伪失败。带有加数 $a$ 和模数 $M = 2^w$ 的原子模块化 fetch-add 的规范是这样的：一个操作读取状态 $x$ 后，会产生新状态 $y = (x + a) \\bmod M$，并返回旧状态 $x$。\n\n对于从状态 $x_0$ 开始的 $N$ 次操作，其顺序规范产生：\n- 返回值序列：$r_i = (x_0 + i \\cdot a) \\bmod M$ (对于 $i \\in \\{0,1,\\dots,N-1\\}$)。\n- 最终状态：$x_N = (x_0 + N \\cdot a) \\bmod M$。\n\n线性化要求每个操作看起来像是在其调用和响应之间的某个瞬间发生，并且已完成操作的集合必须等同于顺序规范。在 LL/SC 中，每个成功的 Store-Conditional 操作都是线性化点，因为只有在没有中间写入使链接失效的情况下，写入才会原子地发生。伪失败不会损害线性化，因为没有写入发生；操作只是简单地重试直到成功。\n\n算法实现：\n- 我们通过一个循环来模拟 LL/SC，该循环由一次原子加载、一次新值的模 $M$ 计算以及一次仅在先前读取的值保持当前状态时才成功的原子条件存储组成。在每次尝试中，我们可选地注入一个确定性的伪失败周期 $s$：如果全局尝试计数器满足 $\\text{attempt} \\bmod s = 0$（且 $s  0$），我们使 Store-Conditional 尝试失败而不写入，然后重试。这模拟了伪失败，同时在 $s$ 是有限的情况下确保了进展。\n- 当条件存储成功时，我们返回旧值。\n\n正确性准则推导：\n1. 最终状态：因为每个成功的操作都写入 $y = (x + a) \\bmod M$，且 Store-Conditional 构成了线性化点，又因为算术是模 $M$ 的，所以在 $N$ 次成功的操作之后，最终状态必须是 $x_N = (x_0 + N \\cdot a) \\bmod M$。伪失败会增加尝试次数，但不会改变已执行的成功操作数 $N$，因此它们不影响最终状态。\n2. 返回值的多重集：每个成功的操作都会返回通过 LL 读取并链接且在 SC 之前保持不变的旧值 $x$。由于操作以某种顺序线性化，因此存在一个 $\\{0,1,\\dots,N-1\\}$ 的排列 $\\pi$，使得返回的多重集等于 $\\{(x_0 + i \\cdot a) \\bmod M \\mid i = 0,1,\\dots,N-1\\}$。并发性改变了顺序（即排列），但没有改变多重集。当 $\\gcd(a, M)  1$ 时，序列 $r_i$ 会以周期长度 $L = \\frac{M}{\\gcd(a, M)}$ 重复。因此，只要 $N  L$，多重集中就预期会出现重复项。我们的验证将观测到的多重集计数与顺序规范的预测计数进行比较；两者相等即可确立返回值的线性化。\n\n实现细节：\n- 我们为所有测试用例选择 $w = 8$，因此 $M = 2^w = 256$。通过与 $M - 1$ 进行掩码操作，在每次更新中实现回绕，并保证整数溢出按要求表现为模约简。\n- 对于测试用例 1，其中 $(w, x_0, a, T, K, s) = (8, 5, 1, 4, 10, 0)$，我们有 $N = 40$ 且 $x_N = (5 + 40) \\bmod 256 = 45$。没有发生回绕，多重集包含连续值 $5,6,\\dots,44$。\n- 对于测试用例 2，其中 $(8, 250, 1, 2, 10, 0)$，我们有 $N = 20$ 且 $x_N = (250 + 20) \\bmod 256 = 14$。发生了回绕；多重集包含值 $250,251,\\dots,255,0,1,\\dots,13$。\n- 对于测试用例 3，其中 $(8, 3, 2, 3, 60, 0)$，我们有 $N = 180$ 且 $x_N = (3 + 180 \\cdot 2) \\bmod 256 = 107$。由于 $\\gcd(2, 256) = 2$，周期长度为 $L = 128$。因此，多重集在 128 项后重复，最后 52 项与前 52 项重复。\n- 对于测试用例 4，其中 $(8, 0, 1, 3, 50, 2)$，我们有 $N = 150$ 且 $x_N = 150$。每 2 次尝试发生一次伪失败不会改变多重集或最终状态；它们只会增加尝试次数。\n\n验证方法：\n- 所有线程完成后，我们加载最终状态并计算预期的 $x_N$。我们比较两者是否相等。\n- 我们统计在 $\\{0,1,\\dots,M-1\\}$ 范围内返回值的观测计数。我们通过枚举 $i = 0$ 到 $N - 1$ 的 $r_i = (x_0 + i \\cdot a) \\bmod M$ 来构建预测计数。这些直方图的相等性确立了多重集属性。\n- 如果两个检查都通过，我们为该测试用例输出 $1$；否则，输出 $0$。\n\n最终输出是一行 $[b_1,b_2,b_3,b_4]$，其中每个 $b_i$ 是如上定义的测试用例 $i$ 的布尔结果。该程序具体展示了 LL/SC 能够正确实现带回绕的模块化 fetch-add，通过模运算处理整数溢出，并保持线性化，包括处理由 $\\gcd(a, M)$ 决定的周期长度和确定性 Store-Conditional 伪失败所带来的细微差别。", "answer": "[1,1,1,1]", "id": "3654150"}, {"introduction": "理论模型是理解并发原语的起点，但现实世界的硬件行为更为复杂。最后一个练习[@problem_id:3654106]将带领我们探索 LL/SC 在物理硬件上的一个重要特性：预留粒度 (reservation granule)。通过模拟实验，你将揭示为什么对一个地址的 SC 操作可能会因为对附近另一个地址的写入而失败，这一现象对于理解和避免伪共享 (false sharing) 等性能陷阱至关重要。", "problem": "您的任务是使用一个简化且科学上真实的模型来形式化链接加载（load-linked）和条件存储（store-conditional）原语的语义，然后实现一个程序，模拟一个实验以推断监控范围。您必须依赖的核心科学基础是以下定义：链接加载操作在包含一个地址的预留粒度上设置一个预留，随后的对同一地址的条件存储操作能否成功，当且仅当自预留建立以来，没有对该粒度内的任何字节发生过存储操作。预留粒度的大小是先验未知的，它正是决定监控范围的量。\n\n在本问题中，假设以下抽象了常见硬件行为的基本模型：\n- 一个内存行的大小为 $L$ 字节。\n- 行内的地址是字对齐的，字大小为 $W$ 字节，从而在行内产生 $n = L / W$ 个对齐的目标地址，其字节偏移量为 $t_i = i \\cdot W$，其中 $i \\in \\{0, 1, \\dots, n-1\\}$。\n- 在目标偏移量 $t_i$ 上的链接加载操作会在包含 $t_i$ 的大小为 $g$ 字节的预留粒度上设置一个预留。定义粒度索引函数 $G(x; g) = \\left\\lfloor x / g \\right\\rfloor$。\n- 在链接加载和条件存储之间，一个对抗方会发出一组位于字节偏移量 $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$ 的干扰存储。一个干扰存储 $s_j$ 被认为“在同一行内”，当且仅当 $0 \\le s_j  L$；否则，它位于不同的行，不会影响预留。\n- 在此模型下，对 $t_i$ 的条件存储失败的充要条件是，存在至少一个干扰存储 $s_j \\in S$ 满足 $0 \\le s_j  L$ 且 $G(s_j; g) = G(t_i; g)$。否则，它会成功。\n\n您的任务是为给定的内存行大小 $L$、字大小 $W$ 以及干扰存储偏移量集合 $S$ 实现一个实验模拟器。该模拟器必须遍历所有对齐的目标 $t_i = i \\cdot W$（其中 $i \\in \\{0, \\dots, n-1\\}$），判断在假设的预留粒度大小 $g \\in \\{8, 16, 64\\}$ 字节下条件存储是否失败，并为每个假设的 $g$ 值统计所有 $n$ 个目标中的失败次数。\n\n测试套件：\n您必须硬编码以下测试用例，每个用例由 $(L, W, S)$ 指定，其中 $L$ 以字节为单位， $W$ 以字节为单位， $S$ 是一个字节偏移量集合：\n- 测试 A: $L = 64$, $W = 8$, $S = \\{16\\}$。\n- 测试 B: $L = 64$, $W = 4$, $S = \\{80\\}$。\n- 测试 C: $L = 64$, $W = 16$, $S = \\{31\\}$。\n- 测试 D: $L = 64$, $W = 64$, $S = \\{8\\}$。\n- 测试 E: $L = 64$, $W = 4$, $S = \\{4, 20, 36, 52\\}$。\n\n对于每个测试用例，计算在所有 $n = L/W$ 个对齐目标上，每个 $g \\in \\{8, 16, 64\\}$ 对应的条件存储失败次数。一个干扰存储仅当其在同一行内时（即 $0 \\le s_j  L$）才会影响一个目标的结果。因此，每个测试用例的答案是三个整数，分别代表 $g = 8$、$g = 16$ 和 $g = 64$ 时的失败次数。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须包含所有测试的结果，按 A、B、C、D、E 的顺序串联，并且在每个测试内部，按 $g = 8$、然后 $g = 16$、然后 $g = 64$ 的顺序排列。例如，输出格式为\n“[a8,a16,a64,b8,b16,b64,c8,c16,c64,d8,d16,d64,e8,e16,e64]”\n其中，像 $a8$ 这样的符号表示指定测试和粒度大小下的整数失败计数。\n\n您的解决方案必须是一个完整的、可运行的程序，该程序完全按照规定实现此模拟，并且只打印上述单行内容。不需要也不允许用户输入。所有答案均为整数；不涉及物理单位或角度。", "solution": "该问题已被验证，并被确定为一项关于计算机科学和操作系统中基本概念建模的、结构良好且具有科学依据的练习。所提供的链接加载（load-linked）和条件存储（store-conditional）原语模型虽然经过简化，但抓住了许多处理器架构中基于预留的原子操作的基本机制。我们现在将进行形式化的求解。\n\n### 基于原则的模型形式化\n\n问题的核心是一个关于链接加载/条件存储（LL/SC）操作如何与干扰内存存储相互作用的形式化模型。该模型的关键要素是：\n\n1.  **内存布局**：一个内存行的大小为 $L$ 字节。访问是針對字对齐的地址进行的。字大小为 $W$ 字节，因此行内有 $n = L/W$ 个可能的目标地址。这些目标的字节偏移量由 $t_i = i \\cdot W$ 给出，其中目标索引 $i \\in \\{0, 1, \\dots, n-1\\}$。\n\n2.  **预留粒度**：在目标地址 $t_i$ 上的 `load-linked` 操作会在一个大小为 $g$ 字节的“预留粒度”上建立一个预留。模型通过其索引来定义包含字节偏移量 $x$ 的粒度，该索引由函数 $G(x; g) = \\lfloor x / g \\rfloor$ 计算得出。对于非负偏移量，这对应于整数除法。\n\n3.  **干扰与失败条件**：后续对目标地址 $t_i$ 的 `store-conditional` 操作会受到一组位于字节偏移量 $S = \\{s_0, s_1, \\dots, s_{m-1}\\}$ 的对抗性存储的干扰。一个存储 $s_j$ 仅当其与目标位于同一内存行内时（即 $0 \\le s_j  L$）才被视为潜在干扰。对 $t_i$ 的 `store-conditional` 失败的充要条件是，至少有一个这样的行内存储 $s_j$ 落在与目标 $t_i$ 相同的预留粒度内。形式上，失败发生的条件是：\n    $$ \\exists s_j \\in S \\text{ such that } (0 \\le s_j  L) \\land (G(s_j; g) = G(t_i; g)) $$\n    否则，`store-conditional` 成功。\n\n我们的任务是为给定的测试套件模拟此过程，计算对于每个假设的粒度大小 $g \\in \\{8, 16, 64\\}$ 字节，`store-conditional` 会失败的目标地址总数。\n\n### 算法解决方案\n\n模拟过程直接实现了模型的规则。对于由 $(L, W, S)$ 定义的每个测试用例以及每个假设的粒度大小 $g$，算法如下：\n\n1.  为当前测试用例和粒度大小初始化一个失败计数器为 $0$。\n2.  计算对齐目标的数量 $n = L/W$。\n3.  遍历每个目标索引 $i$，从 $0$ 到 $n-1$。\n    a. 确定目标偏移量 $t_i = i \\cdot W$。\n    b. 计算此目标的粒度索引：$G_t = \\lfloor t_i / g \\rfloor$。\n    c. 设置一个标志 `failure_for_this_target` 为 false。\n    d. 遍历集合 $S$ 中的每个存储偏移量 $s_j$。\n        i. 检查存储是否在行内：$0 \\le s_j  L$。\n        ii. 如果是，计算存储的粒度索引：$G_s = \\lfloor s_j / g \\rfloor$。\n        iii. 如果 $G_s = G_t$，则满足失败条件。将 `failure_for_this_target` 设置为 true，并中断对 stores 的内循环，因为一个干扰就足够了。\n    e. 如果 `failure_for_this_target` 为 true，则增加失败计数器。\n4.  遍历完所有目标后，失败计数器的值即为给定的 $(L, W, S, g)$ 的结果。\n\n### 示例演算：测试用例 C\n\n让我们将此算法应用于测试用例 C：$L = 64$，$W = 16$，$S = \\{31\\}$。\n-   目标数量 $n = L/W = 64/16 = 4$。\n-   目标偏移量 $t_i$: $\\{t_0, t_1, t_2, t_3\\} = \\{0, 16, 32, 48\\}$。\n-   干扰存储 $s_0 = 31$。这是行内的，因为 $0 \\le 31  64$。我们必须检查来自此存储的干扰。\n\n**情况 1：粒度大小 $g=8$**\n-   存储的粒度索引：$G(31; 8) = \\lfloor 31 / 8 \\rfloor = 3$。\n-   目标的粒度索引：\n    -   $G(t_0; 8) = G(0; 8) = 0$。\n    -   $G(t_1; 8) = G(16; 8) = 2$。\n    -   $G(t_2; 8) = G(32; 8) = 4$。\n    -   $G(t_3; 8) = G(48; 8) = 6$。\n-   存储的粒度索引 ($3$) 与任何目标的粒度索引 ($\\{0, 2, 4, 6\\}$) 都不匹配。\n-   结果：**$0$ 次失败**。\n\n**情况 2：粒度大小 $g=16$**\n-   存储的粒度索引：$G(31; 16) = \\lfloor 31 / 16 \\rfloor = 1$。\n-   目标的粒度索引：\n    -   $G(t_0; 16) = G(0; 16) = 0$。\n    -   $G(t_1; 16) = G(16; 16) = 1$。（匹配）\n    -   $G(t_2; 16) = G(32; 16) = 2$。\n    -   $G(t_3; 16) = G(48; 16) = 3$。\n-   存储的粒度索引 ($1$) 与目标 $t_1$ 的粒度索引匹配。\n-   结果：**$1$ 次失败**。\n\n**情况 3：粒度大小 $g=64$**\n-   存储的粒度索引：$G(31; 64) = \\lfloor 31 / 64 \\rfloor = 0$。\n-   目标的粒度索引：\n    -   $G(t_0; 64) = G(0; 64) = 0$。（匹配）\n    -   $G(t_1; 64) = G(16; 64) = 0$。（匹配）\n    -   $G(t_2; 64) = G(32; 64) = 0$。（匹配）\n    -   $G(t_3; 64) = G(48; 64) = 0$。（匹配）\n-   存储的粒度索引 ($0$) 与所有 $4$ 个目标的粒度索引都匹配。\n-   结果：**$4$ 次失败**。\n\n因此，测试用例 C 的计算结果是 $[0, 1, 4]$。通过将此相同过程应用于所有测试用例，我们得到完整的结果集。\n\n### 计算结果摘要\n\n-   **测试 A** ($L=64, W=8, S=\\{16\\}$): $[1, 2, 8]$\n-   **测试 B** ($L=64, W=4, S=\\{80\\}$): $[0, 0, 0]$ (存储不在行内)\n-   **测试 C** ($L=64, W=16, S=\\{31\\}$): $[0, 1, 4]$\n-   **测试 D** ($L=64, W=64, S=\\{8\\}$): $[0, 1, 1]$\n-   **测试 E** ($L=64, W=4, S=\\{4, 20, 36, 52\\}$): $[8, 16, 16]$\n\n最终程序将按指定顺序串联这些结果。", "answer": "[1,2,8,0,0,0,0,1,4,0,1,1,8,16,16]", "id": "3654106"}]}