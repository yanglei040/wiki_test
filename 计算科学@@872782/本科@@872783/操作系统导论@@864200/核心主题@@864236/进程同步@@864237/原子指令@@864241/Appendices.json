{"hands_on_practices": [{"introduction": "原子操作的核心在于其不可分割性。一个很自然的问题是：我们是否可以用多个较小的原子操作来构建一个更大的原子操作呢？这个练习将通过一个思想实验，揭示指令交错执行中隐藏的风险，并阐明为何真正的硬件原子性支持至关重要 ([@problem_id:3621937])。通过分析一个看似合理的128位CAS操作的模拟实现，你将亲眼见证它如何因“撕裂写”而失败，从而深刻理解原子性的真正含义。", "problem": "操作系统可以依赖处理器提供的原子指令来实现并发原语。考虑原子比较并交换（CAS）的定义：CAS 接受一个内存位置 $M$、一个期望值 $E$ 和一个目标值 $N$，并作为一个不可分割的操作执行检查并设置，仅当在操作瞬间 $M$ 等于 $E$ 时，才将 $M$ 的值设为 $N$ 并返回成功标志。相反，任何多条指令的序列都存在一个可能发生交错的时间窗口。假设一个顺序一致性内存模型，其中每条单独的指令（包括每个 $64$ 位 CAS）相对于其他指令都是原子的，但没有机制将多条指令组合成单个原子步骤。\n\n假设我们有一个 $128$ 位的共享对象 $X$，它由两个相邻的 $64$ 位字实现：$X_{hi}$ 和 $X_{lo}$。目标是使用两个 $64$ 位的 CAS 操作来模拟对 $X$ 的一个 $128$ 位 CAS。两个线程 $T_1$ 和 $T_2$ 同时尝试将 $X$ 从相同的期望值\n$$\nX = (X_{hi}, X_{lo}) = (A, B),\n$$\n更新为不同的新值：\n$$\nT_1 \\text{ 意图 } (A, B) \\rightarrow (C, D), \\quad T_2 \\text{ 意图 } (A, B) \\rightarrow (E, F).\n$$\n每个线程使用相同的模拟算法：它首先对 $X_{hi}$ 执行一个 $64$ 位 CAS，期望值为 $A$，目标值为 $C$（对于 $T_1$）或 $E$（对于 $T_2$）；然后对 $X_{lo}$ 执行一个 $64$ 位 CAS，期望值为 $B$，目标值为 $D$（对于 $T_1$）或 $F$（对于 $T_2$）。如果任何一个 CAS 失败，线程立即返回失败；没有回滚或加锁机制。\n\n所期望的 $128$ 位 CAS 的原子性要求线性一致性：每次更新尝试都必须表现为在单个瞬间发生，这样最多只有一个线程（$T_1$ 或 $T_2$）成功，并且 $X$ 的最终状态必须是 $(C, D)$、$(E, F)$ 中的一个，或者如果两者都失败则保持为 $(A, B)$，不允许出现或提交任何中间或“撕裂”的组合。\n\n以下哪种两个 $64$ 位 CAS 操作的交错是一个有效的反例，表明这个两步模拟不等同于一个真正的原子 $128$ 位 CAS？\n\nA. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并成功；$T_2$ 随后尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，并失败，然后返回失败。最终 $X$ 为 $(C, D)$。\n\nB. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_2$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $F$，并成功；然后 $T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并失败；然后 $T_2$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并失败。最终 $X$ 为 $(C, F)$。\n\nC. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_2$ 立即尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并失败；$T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并成功。最终 $X$ 为 $(C, D)$。\n\nD. $T_2$ 在 $T_1$ 开始前运行至完成：$T_2$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并成功；$T_2$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $F$，并成功；$T_1$ 随后尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，并失败，然后返回失败。最终 $X$ 为 $(E, F)$。\n\n选择所有正确选项。", "solution": "用户要求对所提供的问题陈述进行关键性验证，然后给出完整的解决方案并对给定选项进行评估。\n\n### 问题验证\n\n我将首先根据指定标准验证问题陈述。\n\n#### 步骤 1：提取已知条件\n\n问题提供了以下信息：\n*   定义了原子指令比较并交换（CAS）：`CAS(M, E, N)` 原子地检查内存位置 $M$ 的值是否等于期望值 $E$。如果相等，则将 $M$ 更新为新值 $N$，并返回成功标志。否则，操作失败。\n*   内存模型是顺序一致性的。单个指令，包括一个 $64$ 位 CAS，是原子的。\n*   没有硬件支持将多个指令组合成单个原子操作。\n*   一个共享的 $128$ 位对象 $X$ 由两个相邻的 $64$ 位字 $X_{hi}$ 和 $X_{lo}$ 组成。\n*   共享对象的初始状态为 $X = (X_{hi}, X_{lo}) = (A, B)$。\n*   两个线程 $T_1$ 和 $T_2$ 同时尝试将 $X$ 从 $(A, B)$ 更新为不同的新值。\n    *   $T_1$ 意图执行更新 $(A, B) \\rightarrow (C, D)$。\n    *   $T_2$ 意图执行更新 $(A, B) \\rightarrow (E, F)$。\n*   两个线程都使用的 $128$ 位 CAS 模拟算法是一个两步序列：\n    1.  对 $X_{hi}$ 执行一个 $64$ 位 CAS。\n    2.  对 $X_{lo}$ 执行一个 $64$ 位 CAS。\n*   $T_1$ 的具体序列是：\n    1.  `CAS({hi}, A, C)`\n    2.  `CAS({lo}, B, D)`\n*   $T_2$ 的具体序列是：\n    1.  `CAS({hi}, A, E)`\n    2.  `CAS({lo}, B, F)`\n*   失败条件：如果序列中的任何一个 CAS 失败，线程立即返回失败。没有回滚机制。\n*   原子性要求（线性一致性）：一个成功的模拟必须表现为在单个瞬间发生。这蕴含两个条件：\n    1.  最多只有一个线程（$T_1$ 或 $T_2$）可以成功。\n    2.  $X$ 的最终状态必须是三种可能性之一：如果 $T_1$ 成功，则为 $(C, D)$；如果 $T_2$ 成功，则为 $(E, F)$；或者如果两者都失败，则为 $(A, B)$。任何其他最终状态，例如“撕裂”或混合的组合，都违反了原子性。\n*   问题要求从选项中找出一个交错，作为此模拟算法原子性的反例。\n\n#### 步骤 2：使用提取的已知条件进行验证\n\n*   **科学依据充分：** 该问题牢固地建立在并发编程和操作系统的基本概念之上，特别是使用单字原子原语实现多字原子操作的挑战。比较并交换指令和线性一致性的概念在计算机科学中是标准且定义明确的。\n*   **问题定义明确：** 该问题定义明确。初始状态、每个线程的流程、成功和失败的条件以及正确结果的定义（线性一致性）都已明确说明。问题要求找出一个具体的反例，这是一个逻辑上合理且可解决的任务。\n*   **客观性：** 问题以精确、客观和正式的语言陈述。没有歧义或主观性。\n\n问题陈述没有违反任何无效性标准。在其领域内，这是一个标准的、合理的、定义明确的问题。\n\n#### 步骤 3：结论与行动\n\n问题陈述是**有效的**。我现在将通过分析所提供的选项来解决它。\n\n### 解题推导\n\n目标是找到一个反例，证明对于一个 $128$ 位的值，这个两步 $64$ 位 CAS 过程不是原子的。反例是一个执行轨迹（$T_1$ 和 $T_2$ 指令的交错），它违反了指定的线性一致性条件。最直接的违规是这样一种执行：$X$ 的最终状态既不是初始状态 $(A, B)$，也不是 $T_1$ 的目标状态 $(C, D)$，也不是 $T_2$ 的目标状态 $(E, F)$。这种状态通常被称为“撕裂写”。\n\n初始状态为 $X = (X_{hi}, X_{lo}) = (A, B)$。\n\n#### 逐项分析\n\n**A. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并成功；$T_2$ 随后尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，并失败，然后返回失败。最终 $X$ 为 $(C, D)$。**\n\n1.  初始状态：$X = (A, B)$。\n2.  $T_1$ 执行 `CAS({hi}, A, C)`。此操作成功，因为 $X_{hi}$ 是 $A$。状态变为 $X = (C, B)$。\n3.  $T_1$ 执行 `CAS({lo}, B, D)`。此操作成功，因为 $X_{lo}$ 是 $B$。状态变为 $X = (C, D)$。$T_1$ 报告成功。\n4.  $T_2$ 执行 `CAS({hi}, A, E)`。此操作失败，因为 $X_{hi}$ 现在是 $C$，而不是期望值 $A$。$T_2$ 报告失败。\n5.  最终状态：$X = (C, D)$。\n这个执行是线性一致的。它看起来就像 $T_1$ 的 $128$ 位操作在 $T_2$ 开始尝试之前成功完成。最终状态 $(C, D)$ 是有效结果之一。因此，这个轨迹不构成反例。\n\n**A 的结论：不正确。**\n\n**B. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_2$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $F$，并成功；然后 $T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并失败；然后 $T_2$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并失败。最终 $X$ 为 $(C, F)$。**\n\n1.  初始状态：$X = (A, B)$。\n2.  $T_1$ 执行 `CAS({hi}, A, C)`。此操作成功。状态变为 $X = (C, B)$。\n3.  发生交错。$T_2$ 执行 `CAS({lo}, B, F)`。此操作成功，因为 $X_{lo}$ 仍然是 $B$。状态变为 $X = (C, F)$。\n4.  $T_1$ 恢复并执行其第二步 `CAS({lo}, B, D)`。此操作失败，因为 $X_{lo}$ 现在是 $F$，而不是期望值 $B$。$T_1$ 报告失败。\n5.  $T_2$ 恢复并执行其第二步（它的第一步被交错了）`CAS({hi}, A, E)`。此操作失败，因为 $X_{hi}$ 是 $C$（被 $T_1$ 改变了），而不是期望值 $A$。$T_2$ 报告失败。\n6.  最终状态：$X = (C, F)$。\n在这种情况下，两个线程都报告失败。根据问题的原子性要求，如果两个线程都失败，状态必须保持为初始状态 $(A, B)$。然而，最终状态是 $(C, F)$，这是一个由 $T_1$ 的部分更新（$X_{hi}$ 的 $C$）和 $T_2$ 的部分更新（$X_{lo}$ 的 $F$）组成的“撕裂”状态。这个状态不是 $(A, B)$、$(C, D)$ 或 $(E, F)$。这个轨迹直接违反了线性一致性条件。\n\n**B 的结论：正确。**\n\n**C. $T_1$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $C$，并成功；$T_2$ 立即尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并失败；$T_1$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $D$，并成功。最终 $X$ 为 $(C, D)$。**\n\n1.  初始状态：$X = (A, B)$。\n2.  $T_1$ 执行 `CAS({hi}, A, C)`。此操作成功。状态变为 $X = (C, B)$。\n3.  $T_2$ 执行 `CAS({hi}, A, E)`。此操作失败，因为 $X_{hi}$ 是 $C$，而不是 $A$。$T_2$ 报告失败。\n4.  $T_1$ 执行 `CAS({lo}, B, D)`。此操作成功，因为 $X_{lo}$ 是 $B$。状态变为 $X = (C, D)$。$T_1$ 报告成功。\n5.  最终状态：$X = (C, D)$。\n这个执行是线性一致的。$T_1$ 成功完成了它的操作，而 $T_2$ 的尝试被抢占并失败。最终状态是一个有效的结果。这不是一个反例。\n\n**C 的结论：不正确。**\n\n**D. $T_2$ 在 $T_1$ 开始前运行至完成：$T_2$ 对 $X_{hi}$ 执行 CAS，期望值为 $A$，目标值为 $E$，并成功；$T_2$ 对 $X_{lo}$ 执行 CAS，期望值为 $B$，目标值为 $F$，并成功；$T_1$ 随后尝试对 $X_{hi}$ 执行 CAS，期望值为 $A$，并失败，然后返回失败。最终 $X$ 为 $(E, F)$。**\n\n1.  初始状态：$X = (A, B)$。\n2.  $T_2$ 执行 `CAS({hi}, A, E)`。此操作成功。状态变为 $X = (E, B)$。\n3.  $T_2$ 执行 `CAS({lo}, B, F)`。此操作成功。状态变为 $X = (E, F)$。$T_2$ 报告成功。\n4.  $T_1$ 执行 `CAS({hi}, A, C)`。此操作失败，因为 $X_{hi}$ 是 $E$，而不是 $A$。$T_1$ 报告失败。\n5.  最终状态：$X = (E, F)$。\n这是另一个线性一致的执行，与选项 A 对称。$T_2$ 原子地完成了它的操作，而 $T_1$ 随后的尝试失败了。最终状态是一个有效的结果。这不是一个反例。\n\n**D 的结论：不正确。**\n\n基于以上分析，只有选项 B 中描述的交错会导致一个违反原子 $128$ 位 CAS 正确性条件的状态。", "answer": "$$\\boxed{B}$$", "id": "3621937"}, {"introduction": "我们已经知道必须使用硬件提供的原子指令，比如比较并交换（CAS），但这是否就足够了呢？这个练习将介绍一个在使用原子指令时仍可能出现的、非常经典的逻辑缺陷——ABA问题 ([@problem_id:3621915])。通过在无锁数据结构中重现这一问题，你将学会构建更健壮的并发系统，并认识到不仅要关心指针当前的值，还需要追踪它的“版本”或历史。", "problem": "一个无锁的后进先出 (LIFO) 空闲列表被实现为一个单向链式栈，其头部使用原子比较并交换 (CAS) 指令进行更新。比较并交换 (CAS) 指令接受三个参数：一个地址、一个期望值和一个新值；它原子地将该地址的当前内容与期望值进行比较，并且仅当它们按位相等时，才写入新值，并返回操作是否成功。在基本设计中，头部是一个指向顶部节点的单字指针。考虑两个线程，每个线程执行推入 (push) 或弹出 (pop) 操作，所有更新都在成功的 CAS 操作时刻被线性化。\n\nA部分。请通过指定一个合理的交错执行序列，说明经典的 ABA 异常如何在没有任何标签或版本控制的空闲列表中发生。在该序列中，一个线程读取头指针为标记为 $A$ 的节点，另一个线程弹出 $A$，执行一系列的推入和弹出操作，并最终将头指针恢复为 $A$，导致第一个线程的过时 CAS 成功，尽管逻辑栈已经发生了改变。\n\n为了缓解 ABA 问题，头部被增强为一个打包在单个机器字中的对 $\\left(p, t\\right)$，其中 $p$ 是指针，$t$ 是一个 $b$ 位的标签。每当头部成功更新时，实现会将 $t$ 的值加 1（模 $2^{b}$），并使用对打包字的单个 CAS 操作来写入这个新的对。任何线程执行的 CAS 操作都会将 $p$ 和 $t$ 与其先前读取的过时值对进行比较。\n\nB部分。假设对于任何线程，从它读取 $\\left(p, t\\right)$ 的时刻到它执行其 CAS 的时刻之间，所有线程总共最多可以有 $n$ 次成功的头部更新。请从第一性原理出发，推导最小标签宽度 $b$ 作为 $n$ 的函数，以保证在该时间窗口内，没有任何过时的值对 $\\left(p, t\\right)$ 能够再次匹配当前的头部值对，即使指针 $p$ 被重用，从而避免了因标签回绕而导致过时的 CAS 操作成功。请将最终答案表示为关于 $n$ 的单个封闭形式解析表达式。不要假设任何特定的数据字大小，并将 $n$ 视为任意正整数。最终答案必须是一个不带单位的表达式。", "solution": "我们从比较并交换 (CAS) 的操作定义开始：对一个地址执行的 CAS 操作会原子地将当前值与一个期望值进行比较，并且当且仅当它们按位相等时，才写入一个新值。在一个实现为栈的无锁空闲列表中，推入 (push) 和弹出 (pop) 操作都使用 CAS 来更新头指针。线性一致性要求操作的逻辑效果在其 CAS 成功的那一刻发生。\n\nA部分要求演示 ABA 异常。考虑头部最初指向标记为 $A$ 的节点。一个典型的交错执行序列是：\n- 线程 $T_{1}$ 读取头指针并观察到 $A$。它基于此观察计算出一个新的头部，但在执行其 CAS 操作前被延迟。\n- 线程 $T_{2}$ 从栈中弹出 $A$。此时头部指向某个其他节点，比如说 $B$，或者如果栈的大小为 1，则变为 $\\text{null}$。\n- 线程 $T_{2}$ 继续按某种顺序推入和弹出其他节点。特别是，它可能将 $A$ 重新推入栈顶，从而将头指针恢复为 $A$。\n- 线程 $T_{1}$ 恢复执行并执行其 CAS 操作，该操作仅比较指针值。因为头指针再次变为 $A$，CAS 看到了期望的指针并成功执行，尽管在 $T_{1}$ 读取和执行 CAS 之间，栈的逻辑内容已经发生了任意改变。这就是 ABA 异常：观察到的值从 $A$ 变为某个 $X$ 再变回 $A$，掩盖了中间的变更。\n\nB部分通过增加一个版本标签来增强头部，以区分同一指针值的不同“实例”。头部是值对 $\\left(p, t\\right)$，其中 $t$ 是一个 $b$ 位计数器，在每次头部成功更新时，其值会加 1（模 $2^{b}$）。现在，线程执行的 CAS 操作会将其先前读取的值对与当前的 $p$ 和 $t$ 进行比较。目标是选择合适的 $b$，使得在任何线程读取 $\\left(p, t\\right)$ 后尝试执行 CAS 的时间窗口内，标签不会发生足以使其在指针 $p$ 被重用时回到相同值的情况。\n\n我们将此要求形式化：假设一个线程在时间 $\\tau$ 读取头部为 $\\left(p_{0}, t_{0}\\right)$。在 $\\tau$ 和该线程于时间 $\\tau'$ 执行 CAS 之间，假设所有线程总共有 $k$ 次成功的头部更新，其中 $k$ 满足 $1 \\leq k \\leq n$。每次成功的更新都会将标签值加 1（模 $2^b$）。因此，在时间 $\\tau'$，与头部关联的当前标签值为\n$$\nt' \\equiv t_{0} + k \\pmod{2^{b}}.\n$$\n为防止因标签回绕导致过时的 CAS 成功，我们必须确保在 $1 \\leq k \\leq n$ 范围内的任何 $k$ 都不会导致 $t' = t_{0}$（模 $2^b$）。也就是说，我们要求\n$$\n\\forall k \\in \\{1, 2, \\dots, n\\}, \\quad k \\not\\equiv 0 \\pmod{2^{b}}.\n$$\n等价地，我们要求模数 $2^b$ 大于该时间窗口内可能的最大增量次数，从而保证 $2^b$ 的任何倍数都不在集合 $\\{1, \\dots, n\\}$ 中。这个条件是\n$$\n2^{b} > n.\n$$\n满足这个严格不等式的最小整数 $b$ 可以通过对 $n+1$ 取以 2 为底的对数并使用上取整函数得到：\n$$\nb = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil.\n$$\n为了验证其最小性，假设 $b' = \\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil - 1$。那么 $2^{b'} \\leq n$，因此存在某个 $k = 2^{b'}$，满足 $1 \\leq k \\leq n$ 且 $k \\equiv 0 \\pmod{2^{b'}}$，这意味着标签可能回绕到相同的值。因此，任何更小的 $b$ 都不能保证在时间窗口内标签不被重用。所以，推导出的表达式是必要且充分的。\n\n此推导仅依赖于 CAS 的原子性定义、每次头部成功更改时标签加一的更新规则以及基本的模运算。它确保了即使指针 $p$ 再次出现（例如，由于内存重用），在最多 $n$ 次更新的任何窗口内，标签部分都会不同，从而防止过时的 CAS 在相同的 $\\left(p, t\\right)$ 对上成功。", "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(n+1\\right) \\right\\rceil}$$", "id": "3621915"}, {"introduction": "在理解了原子性的基本原理和潜在陷阱之后，现在是时候将这些知识付诸实践了。本练习要求你构建一个并发位图分配器，这是一个原子指令在现实世界中的常见应用场景 ([@problem_id:3621176])。这个实践不仅关乎正确性，更深入到性能层面：你将通过测量争用情况并探索哈希等技术来缓解冲突，从而打通从并发理论到高性能实现的桥梁。", "problem": "您需要设计并分析一个使用原子指令来操作单个位的并发位图分配器。该分配器维护一个长度为 $N$ 的共享位向量，其中每个位代表一个可分配的槽位：位值为 $0$ 表示槽位空闲，位值为 $1$ 表示槽位已分配。多个线程通过并发地设置位来尝试分配槽位。\n\n使用的基本原理和定义：\n- 在 C 标准内存模型下，原子读-改-写操作是可线性化的。一个原子操作在其调用和返回之间的某个点瞬时生效，产生一个与程序顺序一致的全序。这是计算机组成与体系结构中一个经过充分测试且被广泛接受的事实。\n- 一个正确的原子位测试并设置操作必须保证，对于特定位，只有一个分配器能观察到从 $0$ 到 $1$ 的转变；所有其他对该位的并发尝试都会观察到 $1$ 并记录为失败。这抓住了用于槽位获取的 Test-and-Set 和 Compare-and-Swap 语义的本质。\n- Load-Linked/Store-Conditional (LL/SC) 为原子更新提供了一种等效机制：一个线程加载一个值，然后仅在没有发生介入的存储操作时，有条件地存储一个新值。虽然程序中没有直接使用 LL/SC，但其语义证明了原子取并设方法的正确性。\n\n分配尝试模型：\n- 存在 $T$ 个线程，索引为 $i \\in \\{0,1,\\dots,T-1\\}$。\n- 每个线程执行 $M$ 次分配尝试。\n- 为减少竞争，每个线程使用一个哈希种子探测序列。定义一个线程专属的哈希函数\n$$ h(i) = (a \\cdot i + b) \\bmod N, $$\n其中 $a$ 和 $b$ 是整数参数。线程 $i$ 的第 $j$ 次尝试目标索引为\n$$ \\text{idx}(i,j) = \\left(h(i) + j \\cdot s\\right) \\bmod N, $$\n其中 $s$ 是一个步长。选择与 $N$ 互质的 $s$ 可以最大化重复前覆盖的索引范围，但程序会接受任何提供的 $s$。\n\n原子位测试并设置规范：\n- 对于索引 $k$ 处的目标位，分配器发出一个原子读-改-写操作，该操作设置该位并返回包含 $k$ 的先前字值。如果先前值中位 $k$ 等于 $0$，则该尝试计为成功；如果位 $k$ 为 $1$，则该尝试计为失败。这在位粒度上模拟了 Test-and-Set 语义。\n\n冲突的定义和度量：\n- 冲突定义为任何目标位已为 $1$ 的失败尝试。冲突率是\n$$ c = \\frac{F}{T \\cdot M}, $$\n其中 $F$ 是所有线程失败尝试的总数。\n\n您的任务：\n- 使用 C 语言的原子功能，实现一个带有原子位测试并设置的并发位图分配器。每个测试用例在线程间使用单个共享位图。每个线程根据 $h(i)$ 和 $\\text{idx}(i,j)$ 计算其探测序列，并尝试原子地设置相应的位。\n- 在所有线程完成其 $M$ 次尝试后，测量冲突率 $c$。\n\n测试套件：\n为以下参数集提供结果，每个参数集都作为一次独立的运行，使用一个初始化为全零的新位图：\n1. 情况 A (哈希，理想路径)：$N=1024$, $T=8$, $M=64$, $s=3$, $a=17$, $b=5$。\n2. 情况 B (基线，无哈希)：$N=1024$, $T=8$, $M=64$, $s=3$, $a=0$, $b=0$。\n3. 情况 C (边界，非字对齐的 $N$)：$N=1000$, $T=16$, $M=120$, $s=7$, $a=19$, $b=11$。\n4. 情况 D (边缘，高竞争和重复)：$N=64$, $T=32$, $M=128$, $s=1$, $a=0$, $b=0$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含四个情况的冲突率，格式为用方括号括起来的逗号分隔列表，四舍五入到六位小数，例如 $[c_A,c_B,c_C,c_D]$。\n\n科学真实性和约束条件：\n- 仅使用原子操作进行位设置；分配单个位时不允许使用锁。\n- 通过依赖原子读-改-写操作的可线性化特性，确保分配器在并发访问下是正确的。\n- 代码必须是自包含的，不需要输入，并且在给定参数下确定性地运行。\n\n答案类型：\n- 对于每个测试用例，输出一个四舍五入到六位小数的浮点数 $c$。将所有四个结果聚合到一行上的单个方括号列表中，如规范所示。", "solution": "问题陈述已经过分析并被认为是有效的。它在科学上基于并发编程和计算机体系结构的原理，其定义和参数完整一致，问题阐述清晰，其表述是客观的。任务是实现一个并发位图分配器的模拟，并在指定条件下测量其性能，这是计算机科学中一个标准的、可验证的问题。\n\n我们现在开始进行设计和求解。\n\n问题的核心是模拟一个并发位图分配器，并量化线程间的竞争，以冲突率来衡量。该分配器管理一个长度为 $N$ 的位向量，其中索引 $k$ 处的位为 $0$ 表示槽位空闲，为 $1$ 表示槽位已分配。$T$ 个线程各自并发执行 $M$ 次分配尝试，总共进行 $T \\cdot M$ 次尝试。\n\n首先，我们必须在内存中表示位图。由于 C11/C23 的原子操作是为整数类型而非单个位定义的，我们必须将位向量建模为一个原子无符号整数数组。一个常见且高效的选择是 `_Atomic unsigned long`。我们将一个 `unsigned long` 中的位数表示为 $B_{\\text{word}}$。这个值是系统相关的，可以通过一个常量表达式如 `sizeof(unsigned long) * CHAR_BIT` 来获得。表示 $N$ 位所需的 `unsigned long` 元素总数为 $\\lceil N / B_{\\text{word}} \\rceil$，这可以通过整数算术计算为 $(N + B_{\\text{word}} - 1) / B_{\\text{word}}$。我们将此数组表示为 `bitmap`。该位图初始化为全零，表示初始时所有槽位均为空。\n\n每个线程（索引为 $i \\in \\{0, 1, \\dots, T-1\\}$）执行一个包含 $M$ 次分配尝试的序列（索引为 $j \\in \\{0, 1, \\dots, M-1\\}$）。线程 $i$ 在其第 $j$ 次尝试中的目标位索引由一个以每个线程的哈希函数为种子的线性探测序列确定。哈希由以下公式给出：\n$$ h(i) = (a \\cdot i + b) \\bmod N $$\n第 $j$ 次尝试的目标索引则为：\n$$ \\text{idx}(i,j) = \\left(h(i) + j \\cdot s\\right) \\bmod N $$\n这里，$a$、$b$ 和 $s$ 是定义访问模式的整数参数。\n\n关键操作是原子位测试并设置。对于目标位索引 $k = \\text{idx}(i,j)$，我们必须对 `bitmap` 数组中包含该位的字执行原子读-改-写操作。`bitmap` 数组内的字索引是 $k_{\\text{word}} = \\lfloor k / B_{\\text{word}} \\rfloor$，该字内的位索引是 $k_{\\text{bit}} = k \\bmod B_{\\text{word}}$。\n\n为了设置该位，我们创建一个位掩码，$m = 1\\text{UL} \\ll k_{\\text{bit}}$。然后使用 C `stdatomic.h` 的内建函数 `atomic_fetch_or` 来执行原子操作。调用 `atomic_fetch_or([k_{\\text{word}}], m)` 会原子地对 `bitmap[k_{\\text{word}}]` 处的字与掩码 $m$ 执行按位或操作，并返回该字在修改*之前*的值。设这个先前的值为 $v_{\\text{old}}$。\n\n根据问题定义，如果目标位先前为 $0$，则分配尝试为成功。可以通过测试返回的值 $v_{\\text{old}}$ 中相应的位来检查此条件。如果 $(v_{\\text{old}} \\& m) = 0$，则该位为 $0$，分配成功。如果 $(v_{\\text{old}} \\& m) \\neq 0$，则该位已经是 $1$，意味着另一个线程先前已经分配了此槽位。这构成一次失败的尝试，也定义为一次冲突。\n\n为测量总冲突次数，我们使用一个初始化为 $0$ 的单个共享计数器 `total_failures`。此计数器必须是原子类型，例如 `_Atomic unsigned long long`，以允许多个线程安全地并发增加其值。每当一个线程检测到冲突时，它会原子地增加此计数器。\n\n单个测试用例的整体模拟过程如下：\n1. 初始化一个所需大小的共享 `bitmap`，并将所有位设置为 $0$。\n2. 初始化一个共享原子计数器 `total_failures` 为 $0$。\n3. 创建并启动 $T$ 个线程。每个线程被传递其唯一的 ID $i$ 以及当前测试用例的参数（$N$、$M$、$s$、$a$、$b$）。\n4. 每个线程 $i$ 执行一个从 $j=0$ 到 $M-1$ 的循环。在每次迭代中，它计算目标索引 $\\text{idx}(i,j)$，执行原子位测试并设置操作，如果发生冲突，则原子地增加 `total_failures`。\n5. 主线程使用 `thrd_join` 等待所有 $T$ 个线程完成执行。\n6. 一旦所有线程终止，读取 `total_failures` 计数器的最终值 $F$。\n7. 使用提供的公式计算冲突率 $c$：\n    $$ c = \\frac{F}{T \\cdot M} $$\n对于问题陈述中指定的四个测试用例中的每一个，都独立重复此整个过程。然后将得到的冲突率 $c_A, c_B, c_C, c_D$ 按要求格式化。对于此问题，使用带有宽松内存顺序（`memory_order_relaxed`）的 `atomic_fetch_or` 和 `atomic_fetch_add` 是足够的，因为我们只关心更新的原子性和最终计数，而不关心不同变量之间内存操作的相对顺序。", "answer": "[0.000000,0.875000,0.479167,0.984375]", "id": "3621176"}]}