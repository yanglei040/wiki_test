{"hands_on_practices": [{"introduction": "生产者-消费者问题是并发编程中的一个基本模型。这个练习将探讨一个常见的错误：在消费者代码中过早地发出信号。通过分析一个有缺陷的实现[@problem_id:3687132]，你将学习如何通过追踪线程交错执行的顺序来识别竞争条件，并掌握使用信号量保护共享缓冲区的正确模式。", "problem": "考虑一个使用计数信号量和二元互斥锁实现的经典有界缓冲区生产者-消费者问题。假设有两个生产者 $P_1$ 和 $P_2$ 以及一个消费者 $C$。缓冲区的容量为 $B$，共享整数 $count$ 追踪已占用槽位的数量。系统使用计数信号量 $empty$ 和 $full$，其初始值为 $empty = B - count$ 和 $full = count$，以及一个用于保护缓冲区和 $count$ 的二元互斥锁 $m$。原语的语义如下：$\\text{wait}(s)$ 原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞；$\\text{signal}(s)$ 原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。关键的正确性不变量是 $0 \\le count \\le B$ 必须始终成立，并且对缓冲区和 $count$ 的修改仅在持有锁 $m$ 时发生。\n\n假设预期的生产者序列如下：\n- $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$ 到缓冲区，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n\n然而，消费者的实现不正确，它会过早地调用 $\\text{signal}(empty)$：\n- $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n从科学上一致的初始状态 $B = 2$, $count = 2$, $empty = 0$, $full = 2$ 开始，并且 $P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上，构造一个交错执行序列，以显示 $C$ 过早调用 $\\text{signal}(empty)$ 如何导致违反不变量 $count \\le B$。然后，找出一个修正后的消费者序列，该序列通过遵守互斥和容量语义，确保不变量 $0 \\le count \\le B$ 在所有交错执行下都得以保持。\n\n以下哪个选项既\n- 提供了一个具体的交错执行（在上述有问题的消费者的前提下）使得 $count$ 超过 $B$，\n- 又提出了一个修正后的消费者操作顺序以防止在任何交错执行下发生此类违规？\n\nA. 演示违规的交错执行，然后是修正后的消费者：\n- 交错执行：\n  - $C$: $\\text{wait}(full)$，然后 $\\text{signal}(empty)$。\n  - $P_1$: $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$ 使得当 $B=2$ 时 $count = 3$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 修正后的消费者序列：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(empty)$。\n\nB. 未产生违规的交错执行，然后是不正确的消费者修复：\n- 交错执行：\n  - $C$: $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $\\text{signal}(empty)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n  - $P_1$: $\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$。\n- 提出的消费者修复（仍然过早）：\n  - $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\nC. 演示违规的交错执行，然后是不正确的消费者修复：\n- 交错执行：\n  - $C$: $\\text{wait}(full)$，然后 $\\text{signal}(empty)$。\n  - $P_1$: $\\text{wait}(empty)$，然后 $\\text{wait}(m)$。\n  - $C$: 在 $P_1$ 持有 $m$ 时，$\\text{wait}(m)$ 阻塞。\n  - $P_1$: $\\text{put}$，然后 $count := count + 1$ 使得当 $B = 2$ 时 $count = 3$，然后 $\\text{signal}(m)$。\n- 提出的消费者修复（将 $\\text{take}$ 移到互斥区之外）：\n  - $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(empty)$，然后 $\\text{signal}(m)$。\n\nD. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是不正确的消费者修复：\n- 交错执行：\n  - $C$: $\\text{wait}(full)$，然后 $\\text{signal}(full)$，然后 $\\text{wait}(m)$。\n  - $P_1$: $\\text{wait}(full)$ 成功，然后 $\\text{wait}(m)$，然后 $\\text{put}$，然后 $count := count + 1$ 使得当 $B = 2$ 时 $count = 3$。\n- 提出的消费者修复（顺序错误且缺少 $\\text{signal}(empty)$）：\n  - $\\text{wait}(full)$，然后 $\\text{wait}(m)$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n\n选择唯一的最佳选项。", "solution": "在继续之前，对问题陈述进行验证。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n- 进程：两个生产者，$P_1$ 和 $P_2$，以及一个消费者，$C$。\n- 缓冲区容量：$B$。\n- 共享状态：一个整数 $count$ 追踪已占用槽位的数量。\n- 同步原语：\n    - 计数信号量 $empty$，初始化为 $B - count$。\n    - 计数信号量 $full$，初始化为 $count$。\n    - 二元互斥锁 $m$。\n- 原语语义：\n    - $\\text{wait}(s)$：原子地将信号量 $s$ 减一，如果其值为 $0$ 则阻塞。\n    - $\\text{signal}(s)$：原子地将 $s$ 加一，并唤醒一个被阻塞的线程（如果有的话）。\n- 正确性不变量：$0 \\le count \\le B$ 必须始终成立。\n- 生产者逻辑：$\\text{wait}(empty)$，然后 $\\text{wait}(m)$，然后 $\\text{put}$ 到缓冲区，然后 $count := count + 1$，然后 $\\text{signal}(m)$，然后 $\\text{signal}(full)$。\n- 有问题的消费者逻辑：$\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$，然后从缓冲区 $\\text{take}$，然后 $count := count - 1$，然后 $\\text{signal}(m)$。\n- 特定初始状态：$B = 2$, $count = 2$, $empty = 0$, $full = 2$。$P_1$ 和 $P_2$ 最初都阻塞在 $\\text{wait}(empty)$ 上。互斥锁 $m$ 假定是可用的（值为 $1$）。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题在科学上基于并发编程和操作系统的原理。它描述了一个经典的同步问题（有界缓冲区），使用了标准的原语（信号量，互斥锁）。术语精确且客观。所提供的初始状态（$B=2, count=2, empty=0, full=2$）与定义（$empty=B-count=2-2=0$; $full=count=2$）是一致的。这是一个定义明确的问题，要求提供一个特定的执行轨迹来演示一个缺陷，并给出一个修正后的代码序列。对于软件环境而言，该设定并非不完整、矛盾或不切实际。它代表了一种常见的编程错误类型。\n\n**步骤3：结论与行动**\n问题陈述有效。将推导解决方案。\n\n### 解决方案的推导\n\n问题的核心在于有问题的消费者 $C$ 和一个生产者（比如 $P_1$）之间的交互。需要被违反的不变量是 $count \\le B$。我们需要展示一个交错执行如何能导致 $count > 2$。\n\n**1. 缺陷分析**\n\n标准的生产者-消费者解决方案使用 $empty$ 和 $full$ 信号量来强制执行缓冲区容量约束。生产者在生产前必须等待一个空槽位（通过调用 $\\text{wait}(empty)$），而消费者在消费前必须等待一个满槽位（通过调用 $\\text{wait}(full)$）。\n\n- **生产者**的逻辑是正确的：它等待一个空槽位（$\\text{wait}(empty)$），获取一个锁（$\\text{wait}(m)$）来更新共享状态，添加一个项目并增加 $count$，释放锁（$\\text{signal}(m)$），最后发出一个槽位已满的信号（$\\text{signal}(full)$）。\n- **消费者**的逻辑是有问题的。操作 $\\text{wait}(full)$ 和 $\\text{signal}(empty)$ 在概念上应该包围消费一个项目的过程。然而，给出的序列是 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$，然后 $\\text{wait}(m)$ 等。消费者在它实际获取锁 $m$ 并从缓冲区中移除项目*之前*，就发出了一个槽位已空的信号。这造成了一个竞争条件。消费者宣告了一个尚不存在的资源（一个空槽位）。\n\n**2. 构造一个违规的交错执行**\n\n让我们从初始状态开始追踪一次执行：$B=2$, $count=2$, $empty=0$, $full=2$, $m=1$。$P_1$ 和 $P_2$ 阻塞在 $\\text{wait}(empty)$ 上。\n\n1.  $C$ 开始执行。生产者们被阻塞，所以它们无法运行。\n2.  $C$ 执行 $\\text{wait}(full)$。$full$ 的值为 $2$，所以调用成功，$full$ 递减为 $1$。\n3.  $C$ 执行其有问题的指令：$\\text{signal}(empty)$。$empty$ 的值原为 $0$。此调用将 $empty$ 增至 $1$。由于 $P_1$（或 $P_2$）被阻塞在该信号量上，操作系统会解除 $P_1$ 的阻塞。$P_1$ 现在处于就绪状态，已完成其 $\\text{wait}(empty)$ 调用。\n4.  此时，发生上下文切换，调度器选择运行 $P_1$。消费者 $C$ 在执行 $\\text{wait}(m)$ 之前被抢占。\n5.  $P_1$ 执行它的下一条指令 $\\text{wait}(m)$。互斥锁 $m$ 是可用的（值为 $1$），所以 $P_1$ 获取它，$m$ 的值变为 $0$。$P_1$ 现在进入了它的临界区。\n6.  在其临界区内，$P_1$ 执行一个 $\\text{put}$ 操作。原本已满的缓冲区现在溢出了。\n7.  $P_1$ 执行 $count := count + 1$。$count$ 的值原为 $2$，现在被增加到 $3$。\n8.  此刻，不变量 $count \\le B$ 被违反，因为 $count = 3$ 而 $B = 2$。违规已经发生。$P_1$ 剩余的执行序列（$\\text{signal}(m)$，$\\text{signal}(full)$）以及 $C$ 最终的执行（它将在 $P_1$ 释放 $m$ 之前阻塞在 $\\text{wait}(m)$ 上）都不会改变这一事实。\n\n这个交错执行成功地演示了违规。\n\n**3. 提出一个修正后的消费者序列**\n\n为了修复这个错误，消费者必须在完成移除项目和相应地更新共享变量 $count$ *之后*，才能发出槽位已空的信号。对共享状态（缓冲区和 $count$）的修改必须由互斥锁 $m$ 保护。因此，$\\text{signal}(empty)$ 调用必须移到临界区之后。\n\n正确的、标准的消费者序列是：\n1.  $\\text{wait}(full)$: 等待缓冲区中至少有一个项目。\n2.  $\\text{wait}(m)$: 获取锁以访问共享状态。\n3.  $\\text{take}$: 从缓冲区中移除一个项目。\n4.  $count := count - 1$: 递减项目计数。\n5.  $\\text{signal}(m)$: 释放锁。\n6.  $\\text{signal}(empty)$: 向生产者发出信号，表示一个槽位已被释放。\n\n这个顺序确保了信号量 $empty$ 正确地表示可用槽位的数量，从而防止了导致违规的竞争条件。\n\n### 逐项分析\n\n**A. 演示违规的交错执行，然后是修正后的消费者：**\n- **交错执行：** 所描述的交错执行（$C$ 运行 $\\text{wait}(full)$，然后 $\\text{signal}(empty)$；然后 $P_1$ 被唤醒，获取 $m$，并将 $count$ 增加到 $3$）与上面推导出的违规轨迹完全匹配。这部分是正确的。\n- **修正后的消费者序列：** 提出的序列是 $\\text{wait}(full)$、$\\text{wait}(m)$、$\\text{take}$、$count := count - 1$、$\\text{signal}(m)$、$\\text{signal}(empty)$。这是如上所推导的标准正确实现。这部分是正确的。\n- **结论：** **正确**。\n\n**B. 未产生违规的交错执行，然后是不正确的消费者修复：**\n- **交错执行：** 这描述了一个 $C$ 在上下文切换前获取互斥锁的交错执行。如分析所示，这个特定的交错执行不会产生违规。任务是展示一个*确实*会产生违规的交错执行。这部分未能完成任务。\n- **提出的消费者修复：** 所谓的“修复”与原始的有问题的序列完全相同。这部分是不正确的。\n- **结论：** **不正确**。\n\n**C. 演示违规的交错执行，然后是不正确的消费者修复：**\n- **交错执行：** 这个交错执行的描述比选项 A 中稍微详细一些（明确显示了 $C$ 在 $m$ 上阻塞），但它在概念上是同样正确的违规演示。这部分是正确的。\n- **提出的消费者修复：** 提出的序列是 $\\text{wait}(full)$，然后 $\\text{take}$，然后 $\\text{wait}(m)$，... 这是有严重缺陷的。$\\text{take}$ 操作修改了共享缓冲区，但被放置在由互斥锁 $m$ 保护的临界区之外。这引入了另一种竞争条件。这部分是不正确的。\n- **结论：** **不正确**。\n\n**D. 使用过早的 $\\text{signal}(full)$ 演示违规的交错执行，然后是不正确的消费者修复：**\n- **交错执行：** 该交错执行描述了一个不同的错误，即过早的 $\\text{signal}(full)$。问题明确指出错误是过早的 $\\text{signal}(empty)$。此外，它错误地声称生产者等待 `full`，而实际上它们等待 `empty`。这部分与问题陈述不符。\n- **提出的消费者修复：** 提出的修复缺少了 $\\text{take}$ 操作和 $\\text{signal}(empty)$ 调用，这最终会导致系统死锁，因为生产者永远不会被通知。这部分是不正确的。\n- **结论：** **不正确**。\n\n基于以上分析，选项 A 是唯一一个既通过有效的交错执行正确演示了违规，又为消费者的逻辑提供了标准、正确的修复方案的选项。", "answer": "$$\\boxed{A}$$", "id": "3687132"}, {"introduction": "哲学家就餐问题是说明并发系统中死锁和资源分配挑战的经典寓言。这个练习探讨了一种旨在避免死锁的非对称策略，但它在不公平的调度器下仍然可能导致饥饿。通过这个思想实验[@problem_id:3625780]，你将学会区分死锁（一种安全性失败）和饥饿（一种活性失败），并理解调度策略对系统公平性的深远影响。", "problem": "考虑经典的哲学家就餐问题，有 $n$ 位哲学家，标记为 $P_0, P_1, \\dots, P_{n-1}$，围绕一张圆桌而坐。叉子 $F_i$ 位于哲学家 $P_i$ 和 $P_{(i+1) \\bmod n}$ 之间。每位哲学家永远在三个阶段中循环：思考、感到饥饿和进餐。进餐需要独占式地使用相邻的两把叉子。系统采用一种非对称的叉子拾取策略：索引为偶数 $i$ 的哲学家首先尝试拿起右边的叉子 $F_i$，然后是左边的叉子 $F_{(i-1) \\bmod n}$；索引为奇数 $i$ 的哲学家首先尝试拿起左边的叉子 $F_{(i-1) \\bmod n}$，然后是右边的叉子 $F_i$。获取叉子的过程是阻塞的：一旦哲学家拿到一把叉子，他们会一直等待直到第二把叉子可用；只有在进餐完成后才会释放叉子。假设除了这个非对称规则外，没有全局协调。一个抢占式调度器在每个瞬间选择哪个哲学家运行，并且可能是不公平的（允许它无限制地偏爱某些就绪的哲学家而不是其他哲学家）。进餐时间是有限的，且有上界 $\\Delta > 0$，思考时间也是有限的，且有上界 $\\tau > 0$。\n\n用于推理的基本定义：\n- 互斥（Mutual exclusion）：在任何时刻，每把叉子 $F_i$ 最多只能由 1 位哲学家持有。\n- 死锁（Deadlock）：一个状态，其中一个非空哲学家集合中的每位哲学家都至少持有 1 把叉子，并永远等待另一把叉子，因此无法取得任何进展（进餐）。\n- 有界等待（Bounded waiting / 公平性 fairness）：存在一个有限的界限 $B$，使得对于任何哲学家，从他们感到饥饿到他们进餐的这段时间内，最多有 $B$ 次其他进餐操作可以完成。\n\n专注于 $n = 5$ 的情况，哲学家为 $P_0, P_1, P_2, P_3, P_4$。在上述非对称策略下，哪个选项正确地指出了一个调度器行为及其结果，该结果展示了违反有界等待公平性（即有哲学家饿死）而系统又无死锁的情况？\n\nA. 调度器在 $P_0$ 饥饿时，恶意地交替运行 $P_1$ 和 $P_4$：每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时，调度器运行 $P_1$（奇数，先拿左叉）来抢占 $F_0$；当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$（偶数，先拿右叉）来抢占 $F_4$。这确保了 $P_0$ 的一个邻居总是持有 $P_0$ 接下来需要的叉子，因此 $P_0$ 永远无法获得两把叉子而持续饥饿，而其他哲学家则可以无限进餐；不会发生死锁，因为总有哲学家在进餐。\n\nB. 非对称策略消除了循环等待，因此对于任何 $n$ 和任何调度器，都能保证无死锁和有界等待；饿死现象不会发生。\n\nC. 增加一个值为 $n-1$ 的全局信号量来限制同时饥饿的哲学家数量，再结合非对称策略，可以在任何调度器下保证无饿死，因为最多只有 $n-1$ 个哲学家可以同时竞争叉子。\n\nD. 对于奇数 $n$，在非对称策略下，奇偶性的差异意味着相邻的哲学家竞争的是相反的“第一把”叉子，这迫使所有哲学家最终都能取得进展；因此，即使是不公平的调度器也无法导致任何哲学家饿死。", "solution": "用户提供了一个经典的哲学家就餐问题的变体，并要求找出一个在无死锁的情况下展示饿死现象的场景。\n\n### 问题验证\n\n**第一步：提取已知条件**\n\n*   **系统**：经典的哲学家就餐问题，有 $n$ 位哲学家，$P_0, P_1, \\dots, P_{n-1}$。\n*   **资源**：$n$ 把叉子，其中叉子 $F_i$ 位于哲学家 $P_i$ 和 $P_{(i+1) \\bmod n}$ 之间。\n*   **资源需求**：哲学家 $P_i$ 需要独占式地使用其左边的叉子 $F_{(i-1) \\bmod n}$ 和右边的叉子 $F_i$ 才能进餐。\n*   **非对称叉子拾取策略**：\n    *   索引为偶数的哲学家 $i$ 首先尝试拿起右边的叉子（$F_i$），然后是左边的叉子（$F_{(i-1) \\bmod n}$）。\n    *   索引为奇数的哲学家 $i$ 首先尝试拿起左边的叉子（$F_{(i-1) \\bmod n}$），然后是右边的叉子（$F_i$）。\n*   **获取协议**：获取叉子的过程是阻塞的。哲学家会持有第一把叉子，同时等待第二把。只有在进餐后才释放叉子。\n*   **调度器**：抢占式且可能不公平（可以无限期地忽略一个就绪的哲学家，而偏爱其他哲学家）。\n*   **时间界限**：进餐时间是有限的，且有上界 $\\Delta > 0$。思考时间是有限的，且有上界 $\\tau > 0$。\n*   **案例研究**：$n=5$，哲学家为 $P_0, P_1, P_2, P_3, P_4$。\n*   **定义**：\n    *   **互斥**：标准定义，每把叉子在同一时间只能被一个用户使用。\n    *   **死锁**：一个非空集合的哲学家陷入循环等待，阻止任何进一步的进展。\n    *   **有界等待（公平性）**：一个饥饿的哲学家将在有限数量的其他哲学家进餐后得以进餐。违反此原则即为饿死。\n*   **问题**：找出正确描述了导致违反有界等待（饿死）而无死锁的调度器行为的选项。\n\n**第二步：使用提取的已知条件进行验证**\n\n*   **科学性**：该问题是计算机科学中的一个典型问题，用于说明死锁和饿死等同步问题。非对称解决方案是一种标准技术。在不同调度假设下对其属性的分析是该主题的核心部分。该问题具有科学依据。\n*   **良构性（Well-Posed）**：该问题提供了一个特定的算法（非对称策略）和系统参数（抢占式、不公平的调度器），并要求分析其属性（死锁 vs. 饿死）。这是一个良构问题，有逻辑上可推导的答案。\n*   **客观性**：该问题以操作系统领域的精确、客观的语言陈述。\n*   **结论**：问题陈述是有效的。它是自洽的、一致的，并基于已建立的计算机科学原理。\n\n### 解答推导\n\n首先，让我们确定在 $n=5$ 的情况下每位哲学家拾取叉子的顺序：\n*   $P_0$ (偶数): 尝试右叉 $F_0$，然后是左叉 $F_4$。\n*   $P_1$ (奇数): 尝试左叉 $F_0$，然后是右叉 $F_1$。\n*   $P_2$ (偶数): 尝试右叉 $F_2$，然后是左叉 $F_1$。\n*   $P_3$ (奇数): 尝试左叉 $F_2$，然后是右叉 $F_3$。\n*   $P_4$ (偶数): 尝试右叉 $F_4$，然后是左叉 $F_3$。\n\n**死锁分析**\n众所周知，此策略是无死锁的。死锁需要一个哲学家循环，其中每个哲学家都持有一把叉子并等待循环中下一个哲学家持有的叉子。使用此策略无法形成这样的循环。快速分析表明，叉子上存在一个偏序关系，可以防止循环。例如，考虑对叉子 $F_4$ 的冲突，它被 $P_0$（第二选择）和 $P_4$（第一选择）需要。如果两者同时变得饥饿，$P_4$ 总能在 $P_0$ 能够请求它之前（因为 $P_0$ 必须先获得 $F_0$）就声明对 $F_4$ 的所有权。这种强制排序打破了形成涉及所有哲学家的“持有并等待”循环所需的对称性。问题陈述正确地假设系统是无死锁的。\n\n**有界等待（饿死）分析**\n问题指定了一个*不公平*的调度器。这一点至关重要。一个不公平的调度器可以无限期地忽略一个已经就绪可以运行的哲学家。我们可以利用这一点来构建一个哲学家饿死的场景。让我们专注于让 $P_0$ 饿死。\n\n$P_0$ 需要叉子 $F_0$ 和 $F_4$。这些分别与邻居 $P_1$ 和 $P_4$ 共享。\n*   $P_1$ 与 $P_0$ 竞争 $F_0$，并且两者都尝试将其作为第一把叉子拿起。\n*   $P_4$ 与 $P_0$ 竞争 $F_4$。$P_4$ 尝试先拿起它，而 $P_0$ 尝试后拿起它。\n\n一个恶意的调度器可以如下使 $P_0$ 饿死：\n1.  让 $P_0$ 变得饥饿。它已就绪，可以运行并尝试获取 $F_0$。\n2.  调度器可以选择让 $P_0$ 成功。$P_0$ 获取了 $F_0$，现在等待 $F_4$。\n3.  调度器现在激活 $P_4$，它刚刚完成了其（可能非常短的）思考时间，现在也饿了。\n4.  $P_4$ 的第一个动作是获取 $F_4$。由于 $F_4$ 是空闲的，$P_4$ 成功了。\n5.  此时，$P_0$ 持有 $F_0$ 并因等待 $F_4$ 而被阻塞。$P_4$ 持有 $F_4$ 并等待 $F_3$。\n6.  系统没有死锁。例如，假设 $P_3$ 正在思考，$F_3$ 是空闲的。调度器可以允许 $P_4$ 获取 $F_3$ 并进餐。\n7.  在进餐了 $\\Delta$ 时间后，$P_4$ 释放 $F_4$ 和 $F_3$ 并开始思考。\n8.  现在，$F_4$ 是空闲的，而 $P_0$（仍然持有 $F_0$）正在等待它。如果调度器运行 $P_0$，那么 $P_0$ 将获得 $F_4$ 并进餐。\n9.  然而，不公平的调度器可以拒绝运行 $P_0$。它可以等待 $P_4$ 完成其最短思考时间 $\\tau$，再次变得饥饿，然后运行 $P_4$。\n10. $P_4$ 将再次获取 $F_4$ 作为它的第一把叉子，再次阻塞 $P_0$。\n\n这个循环可以无限重复。$P_4$ 反复进餐，而 $P_0$ 持有 $F_0$ 并因等待 $F_4$ 而饿死。由于 $P_0$ 永久持有 $F_0$，它的另一个邻居 $P_1$ 也会饿死，因为 $P_1$ 永远无法获得它的第一把叉子 $F_0$。系统仍在取得进展（例如，$P_4$ 和 $P_2$ 可以进餐），所以没有死锁，但存在饿死，这违反了有界等待。\n\n### 逐项分析\n\n**A. 调度器在 $P_0$ 饥饿时，恶意地交替运行 $P_1$ 和 $P_4$：每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时，调度器运行 $P_1$（奇数，先拿左叉）来抢占 $F_0$；当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$（偶数，先拿右叉）来抢占 $F_4$。这确保了 $P_0$ 的一个邻居总是持有 $P_0$ 接下来需要的叉子，因此 $P_0$ 永远无法获得两把叉子而持续饥饿，而其他哲学家则可以无限进餐；不会发生死锁，因为总有哲学家在进餐。**\n\n该选项正确地得出结论，即通过邻居的恶意调度，可能在无死锁的情况下发生饿死。它描述的第二种情景，“当 $P_0$ 持有 $F_0$ 并准备尝试获取 $F_4$ 时，调度器运行 $P_4$ ... 来抢占 $F_4$”，是导致 $P_0$ 饿死的有效机制，如上面的推导所示。然而，第一种情景，“每当 $P_0$ 持有 $F_4$ 并准备尝试获取 $F_0$ 时”，描述了一个在给定策略下不可能发生的状态（$P_0$ 必须在 $F_4$ *之前*尝试获取 $F_0$）。尽管其中一个子句存在事实不准确之处，但该选项正确地指出了系统的根本漏洞：一个不公平的调度器可以利用哲学家的邻居来制造一个与死锁不同的饿死场景。在给定的选项中，此选项对该现象提供了最准确的高层次描述。\n\n结论：**正确**，尽管其描述中有一个显著的不精确之处。\n\n**B. 非对称策略消除了循环等待，因此对于任何 $n$ 和任何调度器，都能保证无死锁和有界等待；饿死现象不会发生。**\n\n此选项不正确。虽然非对称策略确实通过消除循环等待来防止死锁，但它本身并不能保证有界等待（即防止饿死）。无饿死需要一个公平的调度策略，而问题陈述中明确指出不保证这一点。\n\n结论：**不正确**。\n\n**C. 增加一个值为 $n-1$ 的全局信号量来限制同时饥饿的哲学家数量，再结合非对称策略，可以在任何调度器下保证无饿死，因为最多只有 $n-1$ 个哲学家可以同时竞争叉子。**\n\n管家/主人算法（将并发哲学家限制为 n-1）可以防止死锁。但是，如果没有公平的调度器，它不能保证无饿死。一个不公平的调度器仍然可以永久地偏爱 n-2 个哲学家的子集，使剩下的一个哲学家饿死，即使那个哲学家有机会进餐。声称它“在任何调度器下保证无饿死”是错误的。\n\n结论：**不正确**。\n\n**D. 对于奇数 $n$，在非对称策略下，奇偶性的差异意味着相邻的哲学家竞争的是相反的“第一把”叉子，这迫使所有哲学家最终都能取得进展；因此，即使是不公平的调度器也无法导致任何哲学家饿死。**\n\n此选项提出了一个事实不正确的前提。让我们检查一下 $n=5$ 时的相邻哲学家 $(P_i, P_{(i+1) \\bmod n})$。\n*   考虑邻居 $P_0$（偶数）和 $P_1$（奇数）。$P_0$ 的第一选择是叉子 $F_0$。$P_1$ 的第一选择也是叉子 $F_0$。他们竞争的是*相同*的第一把叉子，而不是相反的。\n*   考虑邻居 $P_2$（偶数）和 $P_3$（奇数）。$P_2$ 的第一选择是叉子 $F_2$。$P_3$ 的第一选择也是叉子 $F_2$。\n由于论证的前提是错误的，所以结论是站不住脚的。\n\n结论：**不正确**。\n\n### 结论\n\n选项 B、C 和 D 提出了根本上不正确的关于并发原理的主张。选项 A 正确地指出，在不公平的调度器下，指定的策略容易导致饿死（违反有界等待），尽管它是无死锁的。虽然其对饿死场景的描述包含一个关于可能系统状态的重大错误，但它是所提供的最佳答案。", "answer": "$$\\boxed{A}$$", "id": "3625780"}, {"introduction": "在许多实际应用中，一个线程可能需要在读取数据后获得写入权限，这就需要将读锁“升级”为写锁。这个练习要求你设计一个协议来解决这个问题，因为一个天真的实现可能会导致多个线程在尝试升级时发生死锁。通过解决这个问题[@problem_id:3625789]，你将不仅仅是分析问题，而是要亲自设计一个能确保无死锁、无饥饿和线性一致性的健壮并发协议。", "problem": "一个共享内存数据结构由一个读写锁 (RWLock) 保护。线程可以以共享模式（用 $R$ 表示）获取锁以进行并发读取，或者以独占模式（用 $W$ 表示）获取锁以进行互斥写入。我们希望支持一种“升级”操作，即持有 $R$ 的线程可以提升为 $W$ 而无需在此期间释放锁，从而使其先读后写的临界区是可线性化的。升级必须确保在读取和随后的写入之间没有其他 $W$ 插入。假设以下基础模型和事实：\n- $W$ 的互斥性：如果存在 $W$ 持有者，则并发读者数 $r$ 为 $0$，并且最多有 1 个写者处于活动状态。\n- $R$ 的共享访问：如果没有 $W$ 持有者，任意数量的读者都可以持有 $R$。\n- 原子读-改-写操作可用，特别是比较并交换 (CAS)。\n- 用于等待写者和升级者的队列是先入先出 (FIFO) 的。\n- 弱公平性：一个持续处于可运行状态的线程最终会被调度；没有线程会永远持有锁。\n- 升级的可线性化：一个从 $R$ 升级到 $W$ 的线程必须表现得好像其 $R$ 临界区和 $W$ 临界区是连续的，中间没有其他线程的 $W$ 操作插入。\n- 经典的读者-写者约束和死锁的 Coffman 条件适用：在互斥、持有并等待、无抢占和循环等待的条件下可能会出现死锁。\n\n考虑当多个线程在持有 $R$ 的同时尝试升级时存在的死锁风险。要求您选择一个协议，在上述假设下，既能保证升级请求的无死锁和进展（无饥饿），又能保持可线性化要求。\n\n哪个选项描述了一个正确的升级协议，该协议能够防止死锁并确保升级者的进展？\n\nA. 每个升级者持有其 $R$，设置一个线程级别的“升级中”标志，并忙等待直到读者数量 $r$ 变为 $1$，然后原子地提升为 $W$。在任何升级者等待期间，新读者正常进入。允许多个同时升级者存在。\n\nB. 在等待时最多只有 1 个升级者持有 $R$：升级者首先尝试使用 CAS 设置一个全局的 UpgradePending (升级待定) 标志；如果 CAS 成功，它将继续持有其 $R$，并且当 UpgradePending 被设置或有任何写者在等待时，所有新读者都会被阻塞。该升级者等待直到 $r=1$ 且没有活动的 $W$，然后原子地提升为 $W$，完成其写入，清除 UpgradePending 标志，并唤醒下一个等待者。如果 CAS 失败（另一个升级者已经持有该门控），该线程释放 $R$ 并进入写者 FIFO 队列。写者和升级者按 FIFO 顺序服务，当写者或升级者在排队时，新读者被阻塞。\n\nC. 升级者总是先释放其 $R$，然后排在现有写者之后作为写者入队，对新读者没有特殊的准入策略或壁垒。当它到达写者队列的头部时，它获取 $W$。\n\nD. 允许多个同时升级者存在，并给予其比写者更高的严格优先级，但新读者从不被阻塞。每个升级者在 $r \\neq 1$ 时忙等待，然后在可能时原子地提升为 $W$。写者在任何升级者之后等待；读者总是继续被允许进入。\n\n选择唯一的最佳选项。", "solution": "用户希望我扮演一名STEM教授，解决一个关于操作系统中读写锁升级协议的问题。\n\n### 问题验证\n\n首先，我必须验证问题陈述。\n\n**第一步：提取已知条件**\n\n- 一个共享内存数据结构由读写锁 (RWLock) 保护。\n- 共享模式用 $R$ 表示（并发读取）。\n- 独占模式用 $W$ 表示（互斥写入）。\n- “升级”操作允许持有 $R$ 的线程在不释放锁的情况下提升为 $W$。\n- 升级的目标是使先读后写的临界区可线性化。\n- 升级的约束：在读取和随后的写入之间不能有其他 $W$ 插入。\n- $W$ 的互斥性：如果存在 $W$ 持有者，并发读者数 $r$ 为 $0$，且最多有 1 个写者处于活动状态。\n- $R$ 的共享访问：如果没有 $W$ 持有者，任意数量的读者都可以持有 $R$。\n- 原子操作：比较并交换 (CAS) 可用。\n- 队列：等待的写者和升级者按先入先出 (FIFO) 顺序服务。\n- 公平性：假设弱公平性（一个持续可运行的线程最终会被调度）。没有线程会永远持有锁。\n- 升级的可线性化：$R$ 临界区和随后的 $W$ 临界区必须表现为连续的，中间没有其他线程的 $W$ 插入。\n- 死锁背景：问题提到了死锁的 Coffman 条件（互斥、持有并等待、无抢占、循环等待）的相关性。\n\n**第二步：使用提取的已知条件进行验证**\n\n- **科学依据：** 该问题是并发编程和操作系统中的一个经典且基础的课题。读写锁、锁升级、死锁、饥饿、可线性化以及像 CAS 这样的原子操作都是计算机科学中已经确立的概念。该问题在科学上是合理的。\n- **定义良好：** 该问题定义良好。它清晰地定义了初始状态（一个 RWLock 模型）、期望的操作（一个可线性化的升级）、约束条件（无死锁、进展）以及可用工具（CAS、FIFO 队列）。问题要求找到一个满足这些特定要求的协议。\n- **客观性：** 语言正式且客观。术语均使用其精确的技术含义。\n- **完整性和一致性：** 问题提供了足够的信息来分析所提出协议中可能出现的死锁和饥饿。对可线性化、无死锁和进展的要求相互一致，构成了一套连贯的并发原语设计目标。\n- **未检测到其他缺陷：** 问题并非不切实际、定义不善、微不足道或无法验证。它代表了并发系统中的一个真实世界设计挑战。\n\n**第三步：结论与行动**\n\n问题陈述有效。我将继续进行解答。\n\n### 解题推导\n\n实现一个可升级的读写锁的核心挑战在于，在确保进展和正确性（可线性化）的同时防止死锁。经典的死锁场景发生在两个或更多线程各自持有读锁 ($R$) 并同时尝试升级为写锁 ($W$) 时。\n\n让我们使用 Coffman 条件来分析这种死锁：\n1.  **互斥：** 写锁 ($W$) 根据定义是独占的。升级者需要独占访问权，但其他线程（读者或另一个升级候选者）持有锁。\n2.  **持有并等待：** 升级者在*持有*其读锁 ($R$) 的同时*等待*满足条件 $r=1$，这需要其他读者释放它们的锁。\n3.  **无抢占：** 问题指明升级发生在“在此期间不释放锁”，这是对所持有资源 ($R$) 的一种无抢占形式。\n4.  **循环等待：** 如果线程 $T_1$ 和线程 $T_2$ 都持有 $R$ 并都决定升级，那么 $T_1$ 等待 $T_2$ 释放其 $R$ 锁（以便 $r$ 能变为 $1$），同时 $T_2$ 等待 $T_1$ 释放其 $R$ 锁。这就形成了一个循环依赖。\n\n一个正确的协议必须打破这些条件中的至少一个。最实际可打破的条件是循环等待。这可以通过在任何给定时间只允许最多一个线程处于“尝试升级”状态来实现。\n\n此外，为了确保进展（活性），协议必须防止饥饿。一个等待读者数 $r$ 降至 $1$ 的升级者可能会因为新读者不断被允许进入而饿死。因此，一个有效的协议必须在升级启动后临时阻塞新读者。\n\n最后，为了实现可线性化，升级线程绝不能释放其 $R$ 锁然后再重新获取一个 $W$ 锁。这样做会创建一个时间窗口，让另一个写者可以介入，使得在 $R$ 锁下读取的数据对于后续的写操作可能变得陈旧。\n\n基于这些原则，一个正确的协议必须：\n1.  序列化升级尝试以防止循环等待死锁（例如，使用一个门控或一个特殊标志）。\n2.  在升级待处理期间阻塞新读者，以保证读者数量将耗尽，从而使升级者能够取得进展。\n3.  确保升级者从 $R$ 到 $W$ 的转换不释放锁，以保持可线性化。\n4.  采用公平的排队机制，以防止写者和潜在升级者之间发生饥饿。\n\n### 逐项分析\n\n**A. 每个升级者持有其 $R$，设置一个线程级别的“升级中”标志，并忙等待直到读者数量 $r$ 变为 $1$，然后原子地提升为 $W$。在任何升级者等待期间，新读者正常进入。允许多个同时升级者存在。**\n\n-   **死锁：** “允许多个同时升级者存在。” 该协议直接造成了上述的死锁场景。如果两个线程持有 $R$ 并尝试升级，它们将无限期地相互等待。\n-   **进展：** “新读者正常进入”。这可能导致升级者饥饿。连续不断的新读者流可以阻止读者数量 $r$ 降至 $1$。\n-   **结论：** **不正确**。\n\n**B. 在等待时最多只有 1 个升级者持有 $R$：升级者首先尝试使用 CAS 设置一个全局的 UpgradePending (升级待定) 标志；如果 CAS 成功，它将继续持有其 $R$，并且当 UpgradePending 被设置或有任何写者在等待时，所有新读者都会被阻塞。该升级者等待直到 $r=1$ 且没有活动的 $W$，然后原子地提升为 $W$，完成其写入，清除 UpgradePending 标志，并唤醒下一个等待者。如果 CAS 失败（另一个升级者已经持有该门控），该线程释放 $R$ 并进入写者 FIFO 队列。写者和升级者按 FIFO 顺序服务，当写者或升级者在排队时，新读者被阻塞。**\n\n-   **死锁：** “在等待时最多只有 1 个升级者持有 $R$”。这是通过对一个全局 `UpgradePending` 标志进行原子 CAS 操作来强制执行的。该机制充当一个门控，序列化了升级尝试，从而打破了循环等待条件。升级者之间的死锁得以防止。\n-   **进展：** “当 UpgradePending 被设置或有任何写者在等待时，所有新读者都会被阻塞”。这确保了当前的读者数量将耗尽，保证了条件 $r=1$ 最终会被满足，从而允许升级者继续进行。对写者和升级者使用 FIFO 队列确保了公平性并防止了饥饿。\n-   **可线性化：** 成功的升级者（“如果 CAS 成功”）“继续持有其 $R$”并原子地提升为 $W$。这通过确保没有其他写者可以插入来满足可线性化要求。对于失败的 CAS 的回退路径（释放 $R$，作为写者入队）是一种处理竞争而不死锁的策略；它中止了该线程的可线性化升级尝试，但允许系统公平地取得进展。该协议本身正确地为可线性化升级提供了一条路径。\n-   **结论：** **正确**。\n\n**C. 升级者总是先释放其 $R$，然后排在现有写者之后作为写者入队，对新读者没有特殊的准入策略或壁垒。当它到达写者队列的头部时，它获取 $W$。**\n\n-   **可线性化：** “升级者总是先释放其 $R$，然后作为写者入队”。这明确违反了可线性化要求。在释放 $R$ 锁和获取 $W$ 锁之间的时间间隔内，另一个线程可以获取 $W$ 锁，修改数据，然后释放它。升级线程的初始读取将与其最终的写入脱节。\n-   **进展：** “对新读者没有特殊的准入策略或壁垒”。这创建了一个读者优先的系统，可能导致所有写者（包括试图升级的线程）饥饿。\n-   **结论：** **不正确**。\n\n**D. 允许多个同时升级者存在，并给予其比写者更高的严格优先级，但新读者从不被阻塞。每个升级者在 $r \\neq 1$ 时忙等待，然后在可能时原子地提升为 $W$。写者在任何升级者之后等待；读者总是继续被允许进入。**\n\n-   **死锁：** “允许多个同时升级者存在”。与选项 A 一样，这重新引入了两个或多个升级线程之间的经典死锁。\n-   **进展：** “新读者从不被阻塞...读者总是继续被允许进入。” 与选项 A 一样，这会导致升级者饥饿，因为读者数量 $r$ 可能永远不会降至 $1$。\n-   **结论：** **不正确**。", "answer": "$$\\boxed{B}$$", "id": "3625789"}]}