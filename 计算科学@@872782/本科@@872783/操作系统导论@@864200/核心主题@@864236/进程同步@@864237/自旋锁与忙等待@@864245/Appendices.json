{"hands_on_practices": [{"introduction": "在我们追求性能优化之前，必须首先确保并发机制的正确性。此练习通过一个假设的错误场景（双重解锁）来探讨一个微妙但至关重要的概念：一个健壮的锁实现不仅需要跟踪其状态（锁定/未锁定），还必须跟踪其所有者。通过分析这个问题 [@problem_id:3684301]，你将加深对并发安全、状态机和设计能抵御用户代码错误的锁的重要性的理解。", "problem": "一个非递归自旋锁使用原子比较并交换（CAS）语义实现：在获取锁时，线程重复执行一个原子操作，试图将共享锁字从 $\\text{Unlocked}$ 状态更改为 $\\text{Locked}$ 状态，当操作失败时则进行自旋（忙等待）；在释放锁时，它以适当的内存顺序写回 $\\text{Unlocked}$，以确保临界区内的存储操作在解锁前对其他线程可见。考虑一个系统，有 $n \\geq 2$ 个线程在 $m \\geq 1$ 个中央处理器（CPU）上运行，其中锁保护一个共享数据结构。任何互斥机制的核心正确性要求是其安全性属性：在任何时刻，最多只有一个线程处于临界区内。对于非递归自旋锁，一个基本的额外要求是，只有成功获取锁的线程才能释放它。\n\n定义一个最小锁状态机，其状态为 $S = \\{\\text{Unlocked}, \\text{Locked}\\}$。允许的转换如下：\n- 由唯一的获取线程 $T_i$ 完成的 $\\text{Unlocked} \\rightarrow \\text{Locked}$ 转换，\n- 由同一个线程 $T_i$ 完成的 $\\text{Locked} \\rightarrow \\text{Unlocked}$ 转换。\n\n如果转换的前置条件未被满足（例如，在当前状态为 $\\text{Unlocked}$ 时尝试进行 $\\text{Locked} \\rightarrow \\text{Unlocked}$ 转换），或者身份约束被违反（例如，当 $T_i$ 是所有者时，一个线程 $T_j \\neq T_i$ 尝试解锁），则会发生非法转换。\n\n假设客户端代码中存在一个细微的错误：线程 $T_1$ 在没有中间加锁操作的情况下连续调用了两次解锁，即其预期的序列是 $\\text{lock}(T_1)$、临界区、$\\text{unlock}(T_1)$，但由于一个错误，它再次执行了 $\\text{unlock}(T_1)$。由于并发性，在第一次和第二次解锁调用之间，可能有某个其他线程 $T_2$ 获取了锁，因此在 $T_1$ 进行第二次解锁时，锁的状态可能是 $\\text{Locked}$，并且所有者可能是 $T_2$。\n\n你的任务是为该自旋锁配备不变量和断言，以便尽早检测到任何非法转换，包括这种双重释放场景，并且不会错误地标记有效的交错执行。你可以在锁中增加以下元数据，并在适当时原子地更新它们：\n- 一个所有者标识符 $o \\in \\{\\text{null}\\} \\cup \\{\\text{线程标识符}\\}$，\n- 每个线程的持有计数 $h_i \\in \\{0,1\\}$（因为锁是非递归的），\n- 每个线程的获取和释放计数器 $a_i$ 和 $r_i$。\n\n哪个选项指定了一组不变量和断言，能够在所有交错执行情况下必然检测到 $T_1$ 的第二次（错误的）解锁，同时在任何合法的获取或释放操作期间不会触发？\n\nA. 仅在解锁时断言状态前置条件：在任何解锁操作之前，检查 $s = \\text{Locked}$。在获取锁时，在尝试 CAS 之前断言 $s = \\text{Unlocked}$。不跟踪所有权或每个线程的计数。\n\nB. 维护并检查以下不变量和断言：\n- 线程 $T_i$ 获取锁的前置条件：断言 $s = \\text{Unlocked}$；在 CAS 成功后，设置 $s := \\text{Locked}$，$o := T_i$，增加 $a_i$，并设置 $h_i := 1$。\n- 线程 $T_i$ 解锁的前置条件：断言 $s = \\text{Locked}$，$o = T_i$，以及 $h_i = 1$；然后设置 $s := \\text{Unlocked}$，$o := \\text{null}$，$h_i := 0$，并增加 $r_i$。\n- 全局一致性：对于所有线程 $i$，断言 $r_i \\leq a_i$，并断言 $\\sum_i h_i \\in \\{0,1\\}$。\n这些条件拒绝当前线程不是所有者或锁未被持有时进行的任何解锁，并防止同一线程的双重释放。\n\nC. 仅维护全局计数器和状态一致性检查：定义 $A := \\sum_i a_i$ 和 $R := \\sum_i r_i$，在任何时候都断言 $R \\leq A$，并断言在全局时间线上状态在 $\\text{Unlocked}$ 和 $\\text{Locked}$ 之间交替转换。不跟踪 $o$ 或 $h_i$。\n\nD. 在解锁时，断言在写入 $s := \\text{Unlocked}$ 之前执行了一个存储-加载排序屏障；在获取锁时，断言在观察到 $s = \\text{Locked}$ 之后执行了一个加载-存储排序屏障。不跟踪 $o$、$h_i$ 或 $(a_i, r_i)$，也不断言状态前置条件。\n\n选择最佳选项。", "solution": "## 问题验证\n\n### 步骤 1：提取已知条件\n\n- **锁实现**：一个非递归自旋锁使用原子比较并交换（CAS）实现。\n- **获取操作**：一个线程重复执行原子操作，试图将共享锁字从 $\\text{Unlocked}$ 更改为 $\\text{Locked}$，当操作失败时进行自旋。\n- **释放操作**：锁的所有者以适当的内存顺序写回 $\\text{Unlocked}$。\n- **系统参数**：$n \\geq 2$ 个线程，$m \\geq 1$ 个 CPU。\n- **正确性要求**：\n    1.  **互斥（安全性）**：在任何时刻，最多只有一个线程处于临界区内。\n    2.  **释放时的所有权**：只有成功获取锁的线程才能释放它。\n- **锁状态机**：\n    - 状态 $S = \\{\\text{Unlocked}, \\text{Locked}\\}$。\n    - 允许的转换：由一个获取线程 $T_i$ 进行的 $\\text{Unlocked} \\rightarrow \\text{Locked}$。\n    - 允许的转换：由同一个线程 $T_i$ 进行的 $\\text{Locked} \\rightarrow \\text{Unlocked}$。\n- **错误场景**：一个线程 $T_1$ 连续执行两次 `unlock`。在 $T_1$ 的两次 `unlock` 调用之间，另一个线程 $T_2$ 可能获取了锁。要考虑的具体交错执行是：`lock(T_1)`，第一次 `unlock(T_1)`，`lock(T_2)`，第二次（错误的）`unlock(T_1)`。\n- **任务**：为自旋锁配备检测工具，以在所有交错执行情况下检测任何非法转换，特别是双重释放，并且不标记有效的操作。\n- **可用的检测元数据**：\n    - 所有者标识符 $o \\in \\{\\text{null}\\} \\cup \\{\\text{线程标识符}\\}$。\n    - 每个线程的持有计数 $h_i \\in \\{0, 1\\}$（对于非递归锁）。\n    - 每个线程的获取和释放计数器 $a_i$ 和 $r_i$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n根据验证标准评估问题陈述：\n\n1.  **科学依据**：该问题植根于并发编程和操作系统的基本概念，包括自旋锁、原子操作（CAS）、互斥和竞争条件。所描述的错误（双重释放）和检测技术（跟踪所有权、计数器）是该领域的标准和现实主题。\n2.  **定义明确**：该问题要求一组特定的不变量和断言来检测并发执行下定义明确的错误行为（双重解锁）。目标清晰且可形式化规定。\n3.  **客观性**：使用的语言是技术性的、精确的，并且没有主观或含糊的术语。场景和要求都是客观陈述的。\n4.  **不完整或矛盾的设置**：问题是自洽的。它提供了锁的行为、要检测的确切错误、可能的交错执行以及可用于检测的工具。没有矛盾之处。\n5.  **不切实际或不可行**：该场景是底层并发编程中常见且合理的编程错误。系统模型（$n$ 个线程，$m$ 个 CPU）是标准的。\n6.  **定义不当或结构不良**：问题结构良好，从一般原则到具体场景，再到一个明确的问题。在选项中它允许一个唯一的最佳解决方案。\n7.  **伪深刻、琐碎或同义反复**：问题并不琐碎。它需要仔细分析并发下的状态变化，并理解需要维护和检查哪些信息以确保逻辑正确性，并将其与其他方面（如内存可见性）区分开来。\n8.  **超出科学可验证范围**：所提出的解决方案（选项）都可以通过对状态转换的逻辑分析来验证。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。这是一个定义明确、科学上合理的计算机科学问题。现在将开始解决方案推导过程。\n\n## 解决方案推导\n\n核心任务是设计一套检查机制，以检测一个特定的非法操作：线程 $T_1$ 试图释放一个它当前并不拥有的锁。这种情况在给定的场景中出现：\n1.  线程 $T_1$ 获取锁。锁状态现在是 $(\\text{state}=\\text{Locked}, \\text{owner}=T_1)$。\n2.  $T_1$ 正确地释放锁。锁状态变为 $(\\text{state}=\\text{Unlocked}, \\text{owner}=\\text{null})$。\n3.  线程 $T_2$ 获取锁。状态变为 $(\\text{state}=\\text{Locked}, \\text{owner}=T_2)$。\n4.  $T_1$ 错误地再次尝试释放锁。此时，锁处于 $\\text{Locked}$ 状态，但其所有者是 $T_2$。\n\n$T_1$ 的非法释放将通过在 $T_2$ 处于其临界区时过早解锁来违反互斥性。因此，检测工具必须在第 4 步捕获此尝试。一个成功的检测机制必须在线程 $T_i$ 调用 `unlock` 时，能够验证 $T_i$ 确实是锁的当前合法所有者。这需要跟踪锁的所有权。\n\n### 逐项分析选项\n\n**A. 仅在解锁时断言状态前置条件：在任何解锁操作之前，检查 $s = \\text{Locked}$。在获取锁时，在尝试 CAS 之前断言 $s = \\text{Unlocked}$。不跟踪所有权或每个线程的计数。**\n\n让我们用这些断言来追踪这个错误场景：\n1.  `lock(T_1)`: $T_1$ 发现 $s=\\text{Unlocked}$，其 CAS 操作成功，设置 $s:=\\text{Locked}$。\n2.  `unlock(T_1)`: $T_1$ 断言 $s=\\text{Locked}$。这是真的。断言通过。$T_1$ 设置 $s:=\\text{Unlocked}$。\n3.  `lock(T_2)`: $T_2$ 发现 $s=\\text{Unlocked}$，其 CAS 操作成功，设置 $s:=\\text{Locked}$。\n4.  `unlock(T_1)` (错误的调用): $T_1$ 断言 $s=\\text{Locked}$。锁的状态确实是 $\\text{Locked}$（因为 $T_2$ 持有它）。断言**通过**了，然后 $T_1$ 错误地将 $s$ 设置为 $s:=\\text{Unlocked}$，破坏了锁的机制。\n\n这组断言未能检测到该错误。根本缺陷在于缺少所有权跟踪。仅仅知道锁是 `Locked` 状态是不够的；还必须知道*谁*锁定了它。\n\n**对 A 的结论：不正确。**\n\n**B. 维护并检查以下不变量和断言：...**\n该选项提出了一套全面的元数据：状态 $s$、所有者 $o$、每个线程的持有计数 $h_i$ 以及获取/释放计数器 $a_i, r_i$。关键的断言位于 `unlock` 路径上。\n\n让我们使用针对线程 $T_i$ 解锁的这些检查来重新追踪这个场景：`assert s = Locked, o = T_i, and h_i = 1`。\n\n1.  `lock(T_1)`: CAS 成功后，状态更新为：$s:=\\text{Locked}$, $o:=T_1$, $a_1$ 增加, $h_1:=1$。\n2.  `unlock(T_1)`: $T_1$ 检查前置条件。\n    - `assert s = Locked`: 真。\n    - `assert o = T_1`: 真。\n    - `assert h_1 = 1`: 真。\n    所有断言都通过。状态更新为：$s:=\\text{Unlocked}$, $o:=\\text{null}$, $h_1:=0$, $r_1$ 增加。\n3.  `lock(T_2)`: CAS 成功后，状态更新为：$s:=\\text{Locked}$, $o:=T_2$, $a_2$ 增加, $h_2:=1$。注意 $h_1$ 保持为 $0$。\n4.  `unlock(T_1)` (错误的调用): $T_1$ 检查前置条件。\n    - `assert s = Locked`: 真。锁被 $T_2$ 持有。\n    - `assert o = T_1`: **错误。** 当前所有者 $o$ 是 $T_2$。断言失败。\n    - `assert h_1 = 1`: **错误。** $T_1$ 的持有计数 $h_1$ 在其第 2 步的有效解锁期间被设置为 $0$。断言失败。\n\n由于至少有一个断言必然失败，非法的解锁尝试被检测到，从而防止了互斥性的破坏。这套检查足以在所有交错执行情况下捕获该错误。全局一致性检查（$r_i \\leq a_i$ 和 $\\sum_i h_i \\in \\{0, 1\\}$）提供了额外的正确性保证，尽管对于这个特定错误，每个操作的前置条件已经足够。\n\n**对 B 的结论：正确。**\n\n**C. 仅维护全局计数器和状态一致性检查：定义 $A := \\sum_i a_i$ 和 $R := \\sum_i r_i$，在任何时候都断言 $R \\leq A$，并断言在全局时间线上状态在 $\\text{Unlocked}$ 和 $\\text{Locked}$ 之间交替转换。不跟踪 $o$ 或 $h_i$。**\n\n这种方法使用聚合计数器，丢弃了每个线程的信息。让我们追踪这个场景：\n1.  `lock(T_1)`: $a_1$ 变为 $1$。$A=1, R=0$。$s: \\text{Unlocked} \\rightarrow \\text{Locked}$。\n2.  `unlock(T_1)`: $r_1$ 变为 $1$。$A=1, R=1$。检查 $R \\leq A$ 通过。$s: \\text{Locked} \\rightarrow \\text{Unlocked}$。\n3.  `lock(T_2)`: $a_2$ 变为 $1$。$A=2, R=1$。检查 $R \\leq A$ 通过。$s: \\text{Unlocked} \\rightarrow \\text{Locked}$。\n4.  `unlock(T_1)` (错误的): $r_1$ 变为 $2$。$A=2, R=2$。检查 $R \\leq A$ 通过。$s: \\text{Locked} \\rightarrow \\text{Unlocked}$。\n\n不变量 $R \\leq A$ 没有被违反。全局状态序列是 $\\text{Unlocked} \\rightarrow \\text{Locked} \\rightarrow \\text{Unlocked} \\rightarrow \\text{Locked} \\rightarrow \\text{Unlocked}$，这是一个有效的交替序列。这种方法粒度太粗，无法检测到错误的线程正在执行解锁操作。它可以检测到全局范围内解锁次数是否多于加锁次数，但无法检测所有权违规。\n\n**对 C 的结论：不正确。**\n\n**D. 在解锁时，断言在写入 $s := \\text{Unlocked}$ 之前执行了一个存储-加载排序屏障；在获取锁时，断言在观察到 $s = \\text{Locked}$ 之后执行了一个加载-存储排序屏障。不跟踪 $o$、$h_i$ 或 $(a_i, r_i)$，也不断言状态前置条件。**\n\n这个选项关注的是内存排序，这是锁实现正确性的另一个方面。内存屏障确保由不同 CPU 上的不同线程执行的内存操作（读和写）以一致的顺序出现。具体来说，解锁屏障确保临界区内的所有写操作在锁被释放之前对其他线程可见。获取屏障确保新临界区内的任何读写操作不会被重排到锁被获取之前发生。\n\n这些屏障对于锁*所保护的*代码的正确性至关重要，但它们本身并不验证加锁/解锁操作的逻辑顺序。所讨论的错误是一个逻辑错误（协议违规），而不是内存可见性错误。断言屏障的存在并不能阻止一个线程在它不是所有者时调用 `unlock`。一个带有错误客户端代码的实现会包含这些屏障，因此断言会通过，而逻辑缺陷仍未被检测到。\n\n**对 D 的结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3684301"}, {"introduction": "直觉上我们可能认为增加处理器核心总能提升性能，但在存在资源争用的系统中，这并非总是成立。本练习 [@problem_id:3684316] 是一个经典的性能建模问题，它提供了一个简洁的数学模型来揭示这一“扩展性悖论”。通过推导吞吐量函数并求解其极值，你将能够精确计算出系统的性能拐点，即超过该点后，增加更多核心反而会因自旋锁争用而导致性能下降。", "problem": "一个工作负载在一个对称多处理器上执行，该处理器拥有 $n$ 个相同的中央处理单元（CPU）核心。每个请求包含一个持续时间为 $u$ 的非关键计算和一个受单个自旋锁保护的临界区，当锁持有者无干扰运行时，临界区的持续时间为 $c$。所有核心持续有工作；锁是热点（每个请求都会获取一次锁）。在忙等待下，每个自旋中的 $n-1$ 个核心会重复轮询锁变量，产生缓存一致性流量，从而干扰锁持有者。根据经验，假设这种干扰给锁持有者上每次临界区的执行增加了 $\\alpha(n-1)$ 的额外延迟。忽略所有其他开销和上下文切换，并假设长时间运行，使得初始瞬态可以忽略不计。\n\n从第一性原理和定义出发，为在 $n$ 个核心上执行 $m$ 个请求的总完成时间建模，并推导稳态吞吐量 $X(n)$（以每秒请求数为单位），使其成为 $n$、$u$、$c$ 和 $\\alpha$ 的函数。然后，计算 $\\frac{dX}{dn}$ 并确定阈值核心数 $n^{\\star}$，在该值下 $\\frac{dX}{dn} = 0$，这样当 $n  n^{\\star}$ 时，由于自旋锁竞争，增加核心会严格降低吞吐量。\n\n使用参数值 $u = 8\\,\\text{ms}$，$c = 0.5\\,\\text{ms}$ 和 $\\alpha = 0.1\\,\\text{ms}$。提供 $n^{\\star}$ 的数值，四舍五入到四位有效数字。最终答案表示为一个无单位的纯数字。", "solution": "用户希望我首先验证问题陈述，如果有效，则提供一个合理的解决方案。\n\n### 第1步：提取已知条件\n-   CPU 核心数：$n$\n-   每个请求的非关键计算持续时间：$u$\n-   每个请求的临界区持续时间（无干扰）：$c$\n-   每个自旋核心的干扰延迟因子：$\\alpha$\n-   总请求数：$m$\n-   系统具体信息：对称多处理器，单个自旋锁，热点锁（所有核心持续有工作），忙等待。\n-   干扰模型：添加到临界区的延迟为 $\\alpha(n-1)$。\n-   假设：忽略其他开销和上下文切换；分析针对稳态（长时间运行）。\n-   目标：\n    1.  为 $m$ 个请求的总完成时间建模。\n    2.  推导稳态吞吐量 $X(n)$。\n    3.  计算导数 $\\frac{dX}{dn}$。\n    4.  找到阈值核心数 $n^{\\star}$，在该值下 $\\frac{dX}{dn} = 0$。\n-   用于数值计算的参数值：$u = 8\\,\\text{ms}$，$c = 0.5\\,\\text{ms}$，$\\alpha = 0.1\\,\\text{ms}$。\n\n### 第2步：使用提取的已知条件进行验证\n1.  **科学性：** 该问题描述了一个并行系统中锁竞争的标准性能建模场景。自旋者干扰导致锁持有者减速的模型是计算机体系结构中与缓存一致性协议相关的一个公认概念。对此开销使用线性模型是一种常见且有效的简化。该问题在科学上是合理的。\n2.  **适定性：** 该问题提供了所有必需的参数和一个明确的目标。目标是建立一个模型，用微积分进行分析，并找到一个最优值，这是一个定义明确的数学任务。预期会有一个唯一解。\n3.  **客观性：** 问题以精确的技术语言陈述（“临界区”、“自旋锁”、“吞吐量”）。没有主观或模棱两可的术语。\n4.  **缺陷检查：** 该问题不违反任何科学原理，不是比喻性的，是自包含的，物理上并非不可行（参数是合理的），并且不是不适定的或琐碎的。\n\n### 第3步：结论与行动\n问题是**有效的**。将提供解决方案。\n\n### 解题推导\n该问题要求对一个受单个自旋锁限制的多处理器系统的性能进行建模。我们将首先为完成 $m$ 个请求所需的总时间建模，然后推导吞吐量 $X(n)$。\n\n设 $T_m(n)$ 为在 $n$ 个核心上完成 $m$ 个请求的总时间。这些请求的执行涉及两种类型的工作：持续时间为 $u$ 的非关键计算和基础持续时间为 $c$ 的临界区执行。\n\n$m$ 个请求的非关键工作总量为 $m \\times u$。这项工作是可并行的。在有 $n$ 个核心的情况下，并假设完美并行化，这部分工作负载所花费的时间是 $\\frac{m u}{n}$。\n\n临界区必须串行执行，因为一次只有一个核心可以持有锁。共有 $m$ 个这样的临界区。问题指出，由于来自 $n-1$ 个自旋核心的竞争，单个临界区的执行时间会增加。一个临界区的有效持续时间 $c_{eff}$ 是基础时间 $c$ 加上干扰延迟：\n$$c_{eff}(n) = c + \\alpha(n-1)$$\n由于 $m$ 个临界区是串行化的，执行它们的总时间是它们各自持续时间的总和。假设系统处于稳态，锁从一个核心传递到另一个核心而没有空闲时间（一个“热点锁”），那么这个总时间是：\n$$T_{serial} = m \\times c_{eff}(n) = m(c + \\alpha(n-1))$$\n一个常见且有效的总完成时间 $T_m(n)$ 模型结合了并行化部分和串行化部分的时间：\n$$T_m(n) = \\frac{m u}{n} + m(c + \\alpha(n-1))$$\n该模型将工作负载表示为一个完全并行的部分和一个严格串行的部分，这对于此类系统是一个很好的近似。\n\n稳态吞吐量 $X(n)$ 定义为单位时间内完成的请求数。因此：\n$$X(n) = \\frac{m}{T_m(n)} = \\frac{m}{\\frac{m u}{n} + m(c + \\alpha(n-1))}$$\n我们可以消去因子 $m$：\n$$X(n) = \\frac{1}{\\frac{u}{n} + c + \\alpha(n-1)}$$\n为了找到使吞吐量最大化的核心数 $n^{\\star}$，我们需要找到使 $X(n)$ 对 $n$ 的导数为零的 $n$ 值。为此优化，我们将 $n$ 视为一个连续变量。\n我们可以将 $X(n)$ 写为：\n$$X(n) = \\left( u n^{-1} + c + \\alpha n - \\alpha \\right)^{-1}$$\n设分母为 $D(n) = u n^{-1} + (c-\\alpha) + \\alpha n$。那么 $X(n) = [D(n)]^{-1}$。使用链式法则求导：\n$$\\frac{dX}{dn} = -[D(n)]^{-2} \\cdot \\frac{dD}{dn}$$\n首先，我们求分母 $D(n)$ 的导数：\n$$\\frac{dD}{dn} = \\frac{d}{dn} \\left( u n^{-1} + c - \\alpha + \\alpha n \\right) = -u n^{-2} + \\alpha$$\n将此代回 $\\frac{dX}{dn}$ 的表达式中：\n$$\\frac{dX}{dn} = - \\frac{-u n^{-2} + \\alpha}{\\left( \\frac{u}{n} + c + \\alpha(n-1) \\right)^2} = \\frac{u n^{-2} - \\alpha}{\\left( \\frac{u}{n} + c + \\alpha(n-1) \\right)^2}$$\n为了找到阈值 $n^{\\star}$，我们令 $\\frac{dX}{dn} = 0$。由于分母是一个平方项，并且代表持续时间的总和，因此对于 $n \\ge 1$ 它是严格为正的。因此，我们只需要将分子设为零：\n$$u (n^{\\star})^{-2} - \\alpha = 0$$\n$$\\frac{u}{(n^{\\star})^2} = \\alpha$$\n$$(n^{\\star})^2 = \\frac{u}{\\alpha}$$\n由于 $n$ 必须为正，我们取正平方根：\n$$n^{\\star} = \\sqrt{\\frac{u}{\\alpha}}$$\n这个 $n^{\\star}$ 值代表了最大吞吐量的点。对于 $n  n^{\\star}$，分子 $u n^{-2} - \\alpha$ 为正，所以 $\\frac{dX}{dn}  0$，吞吐量随 $n$ 增加而增加。对于 $n  n^{\\star}$，分子为负，所以 $\\frac{dX}{dn}  0$，由于压倒性的竞争，增加更多核心会严格降低吞吐量。\n\n现在，我们代入给定的数值：$u = 8\\,\\text{ms}$ 和 $\\alpha = 0.1\\,\\text{ms}$。\n$$n^{\\star} = \\sqrt{\\frac{8}{0.1}} = \\sqrt{80}$$\n为了得到数值答案，我们计算 $\\sqrt{80}$ 的值：\n$$n^{\\star} = \\sqrt{16 \\times 5} = 4\\sqrt{5} \\approx 4 \\times 2.2360679... \\approx 8.9442719...$$\n问题要求将该值四舍五入到四位有效数字。\n$$n^{\\star} \\approx 8.944$$", "answer": "$$\\boxed{8.944}$$", "id": "3684316"}, {"introduction": "在上一个练习中我们从理论上分析了自旋锁的扩展性瓶颈，现在我们将从理论走向实践，探索一种具体的优化方案。本练习 [@problem_id:3684245] 要求你通过编程来量化一种锁重新设计方案所带来的性能提升。通过计算“自旋效率”这一指标，你将能清晰地比较混合式锁（结合有限自旋与线程休眠）相对于纯忙等待自旋锁的优势，从而对现代操作系统中锁的实现策略有更深入的认识。", "problem": "给定一个综合性但科学可靠的并发系统模型，其中多个线程竞争一个保护临界区的自旋锁。目标是形式化并计算“自旋效率”，该效率定义为有效工作周期与所有线程消耗的总周期之比。您必须实现一个程序，计算在锁重新设计之前和之后的自旋效率。该重新设计通过限制自旋时间然后停放线程来减少忙等待。\n\n使用的基本原理和定义：\n- 自旋锁（spinlock）是一种互斥机制，其中一个线程重复检查一个锁直到它变为可用；这种忙等待会消耗中央处理器（CPU）周期。\n- 临界区（critical section）是一段必须在互斥下执行的代码区域；每次进入都会执行消耗CPU周期的有效工作。\n- 有效工作周期（useful work cycles）是直接促成临界区工作完成的周期。\n- 忙等待周期（busy waiting cycles）是线程在无法进入临界区时，因主动在锁上自旋而消耗的周期。\n- 锁开销周期（lock overhead cycles）是锁本身的获取和释放操作所消耗的周期（不包括忙等待）。\n- 自旋效率（spin efficiency）定义为有效工作周期与所有线程总周期之比：$E = \\dfrac{\\text{有效工作周期}}{\\text{总周期}}$。\n\n系统模型和参数：\n- 设 $M$ 为竞争该锁的线程数。\n- 设 $A$ 为每个线程进入临界区的次数（获取次数）。\n- 设 $W$ 为每次进入临界区执行的有效工作的周期数。\n- 设 $C_{\\ell}$ 为每次进入临界区的锁开销周期数（获取 $+$ 释放）。\n- 重新设计前（纯忙等待自旋锁）：当一个线程持有锁 $W$ 个周期时，其他 $M-1$ 个线程在这 $W$ 个周期内持续自旋。\n- 重新设计后（有界自旋与线程停放）：每个等待的线程每次等待最多自旋 $S_{\\max}$ 个周期。如果在 $S_{\\max}$ 个周期后仍未获得锁且存在竞争，线程将停放（停放期间不消耗CPU周期）。当在有竞争的情况下释放锁且 $W  S_{\\max}$ 时，会唤醒恰好一个已停放的线程来接下来获取锁，这会产生一个 $R$ 周期的唤醒成本。假设第一次获取不需要唤醒；在 $W  S_{\\max}$ 和 $M1$ 的条件下，所有后续的获取都需要一次唤醒。\n\n计算假设：\n- 所有线程都执行其 $A$ 次获取，且获取操作由锁串行化。\n- 总获取次数为 $M \\cdot A$。\n- 锁开销在重新设计前后均适用：每次获取 $C_{\\ell}$ 个周期。\n- 为了此指标的目的，停放消耗零CPU周期。\n- 系统在其他方面是理想化的（没有I/O、没有抢占成本、除了所述成本外没有缓存或内存层次结构建模）。\n\n您的任务是为每个测试用例计算重新设计前和重新设计后的自旋效率。为此，请从给定的基本定义出发，推导出每种设计中所有线程的总周期。不要假设任何未说明的优化或成本。\n\n输出要求：\n- 每个答案必须是一个浮点数，表示自旋效率的小数值。\n- 您的程序应生成一行输出，其中包含一个逗号分隔的列表，并用方括号括起来的结果：[$e_{1,\\text{before}}$,$e_{1,\\text{after}}$,$e_{2,\\text{before}}$,$e_{2,\\text{after}}$,$e_{3,\\text{before}}$,$e_{3,\\text{after}}$,$e_{4,\\text{before}}$,$e_{4,\\text{after}}$]，其中 $e_{i,\\cdot}$ 表示测试用例 $i$ 的自旋效率。每个小数值打印时，小数点后应精确到 $6$ 位。\n\n测试套件：\n- 用例 1：$M=8$, $A=500$, $W=100$, $C_{\\ell}=5$, $S_{\\max}=20$, $R=200$。\n- 用例 2（边界情况，无竞争）：$M=1$, $A=1000$, $W=100$, $C_{\\ell}=5$, $S_{\\max}=20$, $R=200$。\n- 用例 3（有界自旋超过工作量，重新设计等同于基线）：$M=32$, $A=200$, $W=10$, $C_{\\ell}=5$, $S_{\\max}=50$, $R=200$。\n- 用例 4（小自旋边界下的重度竞争）：$M=16$, $A=50$, $W=1000$, $C_{\\ell}=5$, $S_{\\max}=10$, $R=200$。\n\n您的程序必须根据所述模型计算每个用例的两种效率，并以所描述的精确格式生成单行输出。", "solution": "将首先提取给定信息，然后评估其科学依据、一致性和结构，从而对问题进行验证。\n\n### 步骤1：提取给定信息\n\n- **定义**：\n    - **自旋锁**：一种互斥机制，线程重复检查一个锁，消耗CPU周期（忙等待）。\n    - **临界区**：需要互斥的代码区域，执行消耗CPU周期的有效工作。\n    - **有效工作周期**：直接促成临界区工作完成的周期。\n    - **忙等待周期**：线程在锁上自旋时消耗的周期。\n    - **锁开销周期**：用于获取和释放操作的周期，不包括忙等待。\n    - **自旋效率 ($E$)**：$E = \\dfrac{\\text{有效工作周期}}{\\text{总周期}}$。\n\n- **参数**：\n    - $M$：线程数。\n    - $A$：每个线程的临界区获取次数。\n    - $W$：每次进入临界区的有效工作周期。\n    - $C_{\\ell}$：每次进入临界区的锁开销周期。\n    - $S_{\\max}$：重新设计的锁中每次等待的最大自旋周期。\n    - $R$：停放线程的唤醒成本周期。\n\n- **系统模型（重新设计前）**：\n    - 纯忙等待自旋锁。\n    - 当一个线程持有锁 $W$ 个周期时，其他 $M-1$ 个线程自旋 $W$ 个周期。\n\n- **系统模型（重新设计后）**：\n    - 有界自旋锁。\n    - 等待的线程最多自旋 $S_{\\max}$ 个周期。\n    - 如果在有竞争的情况下 $S_{\\max}$ 个周期后未获得锁，线程将停放（消耗零周期）。\n    - 当在有竞争的情况下释放锁，并且 $W  S_{\\max}$ 时，恰好一个停放的线程被唤醒，成本为 $R$ 个周期。\n    - 第一次获取没有唤醒成本。在 $W  S_{\\max}$ 和 $M  1$ 的条件下，所有后续获取都会产生唤醒成本。\n\n- **假设**：\n    - 总获取次数 = $M \\cdot A$。\n    - 获取是串行化的。\n    - $C_{\\ell}$ 对两种设计都保持不变。\n    - 停放消耗零CPU周期。\n    - 系统是理想化的（没有其他成本，如I/O或抢占）。\n\n- **测试套件**：\n    - 用例 1: $M=8, A=500, W=100, C_{\\ell}=5, S_{\\max}=20, R=200$。\n    - 用例 2: $M=1, A=1000, W=100, C_{\\ell}=5, S_{\\max}=20, R=200$。\n    - 用例 3: $M=32, A=200, W=10, C_{\\ell}=5, S_{\\max}=50, R=200$。\n    - 用例 4: $M=16, A=50, W=1000, C_{\\ell}=5, S_{\\max}=10, R=200$。\n\n### 步骤2：使用提取的信息进行验证\n\n该问题建立了一个简化的但连贯且有科学依据的常见计算机科学场景模型（自旋锁竞争）。\n- **科学上合理的**：该模型基于操作系统和并发编程中的基本概念，如自旋锁、临界区和忙等待。通过计算CPU周期来建模性能是系统分析中的一种标准技术。它不违反任何科学原理。\n- **定义明确的**：参数和规则都清晰定义，为每个测试用例导出一个唯一的、可计算的解。\n- **客观的**：语言是精确和定量的。没有主观或模糊的术语。\n- **自洽且一致的**：解决问题所需的所有参数、定义和假设都已提供。没有内部矛盾。\n- **相关的**：问题直接关系到操作系统中自旋锁和忙等待的特定主题。\n\n这个问题没有缺陷；它是一个应用第一性原理来模拟系统性能的有效的、结构良好的练习。\n\n### 步骤3：结论与行动\n\n该问题是**有效的**。将推导并呈现一个解决方案。\n\n### 自旋效率公式的推导\n\n自旋效率 $E$ 定义为所有线程的总有效工作周期与消耗的总周期之比。设 $N_{total} = M \\cdot A$ 为总获取次数。\n\n**1. 总有效工作周期**\n\n有效工作是在临界区内完成的工作。$N_{total}$ 次获取中的每一次都执行 $W$ 个周期的有效工作。\n$$\n\\text{Cycles}_{\\text{useful}} = N_{\\text{total}} \\cdot W = (M \\cdot A) \\cdot W\n$$\n这个量在所有场景下都作为效率计算的分子。\n\n**2. 重新设计前的效率（纯忙等待）**\n\n在此模型中，对于每次获取，一个线程执行临界区，而其他 $M-1$ 个线程则忙等待。\n- **工作和开销周期**：获取锁的线程每次获取花费 $W$ 个周期用于有效工作，以及 $C_{\\ell}$ 个周期用于锁开销。在所有获取中，这是 $N_{total} \\cdot (W + C_{\\ell})$。\n- **忙等待周期**：对于每次获取，其余的 $M-1$ 个线程在临界区工作期间（即 $W$）自旋。总忙等待周期是 $N_{total} \\cdot (M-1) \\cdot W$。\n- **总周期**：消耗的总周期是所有线程所有活动周期的总和。\n$$\n\\text{Cycles}_{\\text{total, before}} = N_{\\text{total}} \\cdot (W + C_{\\ell}) + N_{\\text{total}} \\cdot (M-1) \\cdot W\n$$\n简化此表达式：\n$$\n\\text{Cycles}_{\\text{total, before}} = N_{\\text{total}} \\cdot (W + C_{\\ell} + MW - W) = N_{\\text{total}} \\cdot (C_{\\ell} + M \\cdot W)\n$$\n- **自旋效率（前）**：\n$$\nE_{\\text{before}} = \\frac{\\text{Cycles}_{\\text{useful}}}{\\text{Cycles}_{\\text{total, before}}} = \\frac{N_{\\text{total}} \\cdot W}{N_{\\text{total}} \\cdot (C_{\\ell} + M \\cdot W)} = \\frac{W}{C_{\\ell} + M \\cdot W}\n$$\n此公式对 $M  1$ 有效。如果 $M=1$，则没有竞争，因此忙等待项 $(M-1) \\cdot W$ 为零。该公式正确地简化为 $E = \\frac{W}{C_{\\ell} + W}$。\n\n**3. 重新设计后的效率（有界自旋与线程停放）**\n\n重新设计的锁的行为取决于有效工作持续时间 $W$ 是否超过最大自旋时间 $S_{\\max}$。我们必须处理两种主要情况，外加无竞争的特殊情况（$M=1$）。\n\n- **情况A：无竞争 ($M=1$)**\n只有一个线程时，没有自旋或停放。总周期仅仅是所有 $A$ 次获取的有效工作和锁开销之和。\n$$\n\\text{Cycles}_{\\text{total, after}} = A \\cdot (W + C_{\\ell})\n$$\n有效周期为 $A \\cdot W$。\n$$\nE_{\\text{after}} = \\frac{A \\cdot W}{A \\cdot (W + C_{\\ell})} = \\frac{W}{W + C_{\\ell}}\n$$\n这与 $M=1$ 时的“重新设计前”情况相同。\n\n- **情况B：有竞争 ($M1$) 且 $W \\le S_{\\max}$**\n如果临界区工作时间小于或等于最大自旋时间，等待的线程将旋转整个持续时间（$W$ 个周期）直到锁被释放。它永远不会达到 $S_{\\max}$ 的限制去停放。这种情况在功能上与纯忙等待模型相同。\n$$\nE_{\\text{after}} = E_{\\text{before}} = \\frac{W}{C_{\\ell} + M \\cdot W} \\quad (\\text{如果 } W \\le S_{\\max} \\text{ 且 } M1)\n$$\n\n- **情况C：有竞争 ($M1$) 且 $W  S_{\\max}$**\n这是最复杂的情况。等待的线程自旋 $S_{\\max}$ 个周期然后停放。随后的获取（第一次之后）会产生唤醒成本 $R$。我们将所有周期成本在总共 $N_{total}$ 次获取中求和。\n- **有效工作周期**：$\\text{Cycles}_{\\text{useful}} = N_{total} \\cdot W$。\n- **锁开销周期**：$\\text{Cycles}_{\\text{overhead}} = N_{total} \\cdot C_{\\ell}$。\n- **忙等待周期**：对于 $N_{total}$ 次获取中的每一次，$M-1$ 个等待的线程现在只自旋 $S_{\\max}$ 个周期。\n$$\n\\text{Cycles}_{\\text{wait}} = N_{total} \\cdot (M-1) \\cdot S_{\\max}\n$$\n- **唤醒周期**：除了第一次获取外，每次获取都会产生唤醒成本 $R$。共有 $N_{total} - 1$ 次这样的事件。\n$$\n\\text{Cycles}_{\\text{wakeup}} = (N_{total} - 1) \\cdot R\n$$\n- **总周期**：所有组成部分的总和。\n$$\n\\text{Cycles}_{\\text{total, after}} = \\text{Cycles}_{\\text{useful}} + \\text{Cycles}_{\\text{overhead}} + \\text{Cycles}_{\\text{wait}} + \\text{Cycles}_{\\text{wakeup}}\n$$\n$$\n\\text{Cycles}_{\\text{total, after}} = (N_{total} \\cdot W) + (N_{total} \\cdot C_{\\ell}) + (N_{total} \\cdot (M-1) \\cdot S_{\\max}) + ((N_{total} - 1) \\cdot R)\n$$\n- **自旋效率（后，情况C）**：\n$$\nE_{\\text{after}} = \\frac{N_{total} \\cdot W}{(N_{total} \\cdot W) + (N_{total} \\cdot C_{\\ell}) + (N_{total} \\cdot (M-1) \\cdot S_{\\max}) + ((N_{total} - 1) \\cdot R)}\n$$\n这个公式体现了重新设计锁的好处：忙等待项现在与 $S_{\\max}$ 而不是更大的 $W$ 成比例，但代价是增加了唤醒项 $R$。\n\n### 计算逻辑总结\n\n对于每个具有参数 $(M, A, W, C_{\\ell}, S_{\\max}, R)$ 的测试用例：\n\n1.  **计算 $E_{\\text{before}}$**：\n    $$\n    E_{\\text{before}} = \\frac{W}{C_{\\ell} + M \\cdot W}\n    $$\n\n2.  **计算 $E_{\\text{after}}$**：\n    - 如果 $M = 1$：\n      $$\n      E_{\\text{after}} = \\frac{W}{W + C_{\\ell}}\n      $$\n    - 如果 $M  1$ 且 $W \\le S_{\\max}$：\n      $$\n      E_{\\text{after}} = \\frac{W}{C_{\\ell} + M \\cdot W}\n      $$\n    - 如果 $M  1$ 且 $W  S_{\\max}$：\n      - 令 $N_{total} = M \\cdot A$。\n      - 令 $\\text{Numerator} = N_{total} \\cdot W$。\n      - 令 $\\text{Denominator} = (N_{total} \\cdot W) + (N_{total} \\cdot C_{\\ell}) + (N_{total} \\cdot (M-1) \\cdot S_{\\max}) + ((N_{total} - 1) \\cdot R)$。\n      $$\n      E_{\\text{after}} = \\frac{\\text{Numerator}}{\\text{Denominator}}\n      $$\n这些公式将被实现以计算给定测试套件的结果。请注意，为了计算，使用能够容纳可能较大的总周期计数的中间值的数据类型（例如，64位整数）至关重要，以避免在执行最终除法前发生溢出。", "answer": "[0.124224,0.224744,0.952381,0.952381,0.030769,0.030769,0.062480,0.738144]", "id": "3684245"}]}