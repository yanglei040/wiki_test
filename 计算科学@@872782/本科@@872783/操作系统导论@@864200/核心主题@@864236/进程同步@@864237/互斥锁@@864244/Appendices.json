{"hands_on_practices": [{"introduction": "理论是实践的基础，现在让我们将关于死锁的知识付诸实践。本练习将指导你解决经典的“哲学家就餐问题”，这是一个著名的并发问题，你需要通过实现“资源分层”这一死锁避免策略来确保系统不会陷入僵局。通过这个编码练习[@problem_id:3661790]，你将亲手构建一个无死锁的多线程程序，从而将抽象的Coffman条件与具体的代码实现联系起来。", "problem": "要求您使用互斥锁设计、实现并验证一个哲学家就餐问题的并发模拟，该模拟采用基于资源层级的死锁避免策略。从以下基本原理出发：Coffman 死锁条件指出，一个系统只有在以下四个条件同时成立时才会发生死锁：互斥、持有并等待、不可抢占和循环等待。在经典的哲学家就餐问题中，叉子被建模为互斥资源，因此互斥、持有并等待、以及不可抢占这三个条件通常在设计上就是成立的。因此，防止循环等待足以保证系统无死锁。防止循环等待的一个经过充分检验的方法是，对资源施加一个严格的全序关系，并要求线程只能按照此顺序的升序来获取资源。\n\n设计一个程序，创建 $n$ 个排列成环形的哲学家线程，索引从 $0$ 到 $n-1$。其中，哲学家 $i$ 需要叉子 $i$ 和叉子 $(i+1) \\bmod n$ 才能进餐。将每把叉子建模为一个互斥锁。通过根据叉子的索引对其施加一个严格的全序关系来实现资源层级，并要求每个哲学家必须先获取索引较小的叉子，然后再获取索引较大的叉子。在两把叉子是同一把的边界情况下（当 $n=1$ 时发生，因为 $(0+1) \\bmod 1 = 0$），哲学家在进餐前必须且仅需获取一次这把唯一的叉子。\n\n每个哲学家必须精确地执行 $k$ 个进餐周期。在一个进餐周期中，哲学家必须：\n- 遵循资源层级获取所需的叉子，\n- 执行一个代表进餐的常数时间临界区，\n- 释放所有持有的叉子。\n\n在所有哲学家线程终止后，验证每个哲学家是否都恰好完成了 $k$ 个进餐周期。程序必须为每个测试用例生成一个布尔值：如果每个哲学家都恰好进餐了 $k$ 次且程序成功终止，则输出 $1$，否则输出 $0$。\n\n测试套件：\n为以下参数集 $(n, k)$ 运行模拟，以覆盖典型情况、边界条件和较大规模的压力测试：\n- $(n, k) = (5, 100)$,\n- $(n, k) = (1, 100)$,\n- $(n, k) = (2, 100)$,\n- $(n, k) = (13, 50)$,\n- $(n, k) = (7, 0)$.\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个方括号括起来的逗号分隔的结果列表（例如，`[result_1,result_2,…,result_m]`）。对于上述测试套件，请打印 `[b_1,b_2,b_3,b_4,b_5]`，其中每个 $b_i$ 为 $1$ 或 $0$，定义如前。由于这些值是表示为整数的无量纲布尔值，因此输出不需要单位。", "solution": "当前问题要求设计并实现一个哲学家就餐问题的并发模拟。解决方案必须按照规定，通过采用资源层级策略来防止死锁。该系统由 $n$ 个哲学家和 $n$ 把叉子组成，它们分别被建模为线程和互斥锁。每个哲学家必须完成 $k$ 个“思考、获取叉子、进餐、释放叉子”的周期。\n\n### 基于原则的设计\n\n该解决方案基于并发编程和死锁理论的原则。Coffman 条件规定，只有当互斥、持有并等待、不可抢占和循环等待这四个条件都存在时，才会发生死锁。我们的设计本身就包含了前三个条件：\n1.  **互斥**：每把叉子都是一个互斥锁（`mtx_t`），根据其定义，它在同一时刻只能被一个线程持有。\n2.  **持有并等待**：一个哲学家获取一把叉子后，在等待获取第二把叉子时会一直持有第一把。\n3.  **不可抢占**：不能强制哲学家释放叉子；他们是在进餐后自愿释放的。\n\n因此，为了防止死锁，我们必须消除第四个条件：**循环等待**。\n\n### 通过资源层级避免死锁\n\n所规定的死锁避免策略是资源层级。这是一种标准技术，它对所有资源施加一个全局的全序关系。然后要求线程按照与该顺序一致的次序获取资源。\n\n1.  **资源建模**：$n$ 把叉子的索引从 $0$ 到 $n-1$。该索引是我们全序关系的基础。索引较低的叉子必须在索引较高的叉子之前被获取。\n\n2.  **获取逻辑**：\n    -   每个哲学家 $i$ （对于 $i \\in \\{0, 1, ..., n-1\\}$）位于叉子 $i$ 和叉子 $(i+1) \\bmod n$ 之间。\n    -   设哲学家 $i$ 所需的两把叉子为 $f_a = i$ 和 $f_b = (i+1) \\bmod n$。\n    -   获取协议如下：\n        -   确定索引较小的叉子，`first_fork = min(f_a, f_b)`。\n        -   确定索引较大的叉子，`second_fork = max(f_a, f_b)`。\n        -   哲学家必须首先锁定与 `first_fork` 对应的互斥锁。\n        -   只有这样，哲学家才能尝试锁定 `second_fork` 的互斥锁。\n\n3.  **打破循环**：该协议打破了循环等待条件。一个经典的死锁场景是每个哲学家都拿起左边的叉子，然后等待右边的叉子，从而形成一个循环依赖链。通过资源层级，这个链在哲学家 $n-1$ 处被打破，他需要叉子 $n-1$ 和 $0$。协议强制哲学家 $n-1$ 首先获取叉子 $0$，而不是获取叉子 $n-1$ 后等待叉子 $0$。由于哲学家 $0$ 也是将叉子 $0$ 作为他首先要获取的叉子，这两位哲学家将竞争叉子 $0$，从而使他们的执行串行化，防止了死锁循环。\n\n### 实现细节\n\n实现是一个使用 `threads.h` 库的 C 程序。\n\n1.  **主循环**：`main` 函数遍历指定的 $(n, k)$ 参数测试套件。对于每个测试用例，它都会组织和调度整个模拟过程。\n\n2.  **模拟设置**：对于每个使用参数 $n$ 和 $k$ 的模拟运行：\n    -   分配并初始化一个包含 $n$ 个互斥锁（`mtx_t`）的数组来代表叉子。\n    -   分配一个包含 $n$ 个计数器（`int`）的数组来跟踪每个哲学家进餐的次数。\n    -   创建 $n$ 个哲学家线程（`thrd_t`）。每个线程都会被传递其唯一的ID（$0$ 到 $n-1$）、哲学家总数 $n$、目标进餐周期数 $k$、一个指向其个人进餐计数器的指针，以及一个指向叉子互斥锁数组的指针。\n\n3.  **哲学家线程逻辑 (`philosopher_routine`)**：\n    -   核心逻辑位于此线程函数中。它执行一个循环 $k$ 次。\n    -   在每次迭代中，它实现叉子获取、进餐和释放的周期。\n    -   计算叉子索引，并应用 `min`/`max` 逻辑来确定获取顺序。\n    -   一个特殊的检查 `if (first_fork_idx != second_fork_idx)` 至关重要。它正确处理了 $n=1$ 的边界情况，此时所需的两把叉子是同一把（叉子 $0$）。这可以防止尝试锁定一个已经被持有的非递归互斥锁而导致的未定义行为。\n    -   成功获取必要的叉子后，“进餐”阶段是一个概念上的临界区。然后线程以与获取相反的顺序释放叉子。\n    -   一旦 $k$ 个周期的循环完成，线程通过将其进餐计数器设置为 $k$ 来记录其完成状态。\n\n4.  **验证**：创建所有线程后，主线程使用 `thrd_join` 等待它们全部完成。一旦所有哲学家都结束了，主线程就验证结果。它遍历进餐计数器。如果每个计数器都等于 $k$，则该测试用例的模拟成功，结果为 $1$。否则，结果为 $0$。\n\n5.  **清理**：销毁所有互斥锁，并释放所有动态分配的内存，以防止资源泄漏。\n\n最终程序汇集每个测试用例的布尔结果，并以指定的格式 `[b_1,b_2,...,b_m]` 打印它们。该解决方案是稳健的，并为所有给定的测试用例正确实现了规定的死锁避免机制，包括 $n=1$ 和 $k=0$ 等边界条件。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3661790"}, {"introduction": "正确的并发编程往往在于对细节的精确把握。本练习聚焦于互斥锁与条件变量（CV）结合使用时一个常见但极其微妙的错误：“信号丢失”和“虚假唤醒”。你将通过一个确定性的模拟程序[@problem_id:3661722]，对比错误和正确的等待逻辑，从而深刻理解为什么在使用条件变量时，必须采用 `while` 循环来重新检查条件，而不是简单的 `if` 判断。", "problem": "给定一个共享状态模型，其中有一个布尔谓词 $ready \\in \\{0,1\\}$，它由一个互斥锁 (mutex) 和一个条件变量 (CV) 保护，该条件变量可以通过信号唤醒线程。其基本原理是操作系统中互斥锁和条件变量的标准语义：互斥锁确保互斥访问，而条件变量提供一种机制，让线程阻塞直到共享状态的某个谓词为真。需要使用的核心且经过充分测试的规则是：(i) 当没有线程在等待时，条件变量的信号不会被记住，(ii) 条件变量的等待可能出现虚假唤醒，因此线程在被唤醒后必须总是重新检查谓词，以及 (iii) 条件变量的等待会原子性地释放关联的互斥锁，并在返回前重新获取它。你必须根据这些规则进行推理，以识别一个唤醒丢失的 bug，并正确地重新设计等待循环。\n\n你将模拟一个等待者线程与一个生产者线程在离散时间步 $t = 0, 1, 2, \\dots, H$ 上的交互，其中 $H$ 是一个有限的时间范围。该模拟使用一个具有以下语义的事件调度：\n\n- 在时间 $t = s_{\\text{wait\\_check}}$，等待者检查 $ready$。如果 $ready = 1$，它立即继续执行。如果 $ready = 0$，它打算等待。\n- 在时间 $t = s_{\\text{wait\\_enter}}$，如果等待者打算等待：\n    - 错误设计（有 bug 的循环）：它不重新检查 $ready$ 就加入条件变量的等待队列。\n    - 正确设计（已修复的循环）：它重新检查 $ready$；如果 $ready = 1$，它立即继续执行；否则它加入条件变量的等待队列。\n- 在时间 $t = s_{\\text{ready}}$，生产者设置 $ready := 1$。\n- 在时间 $t = s_{\\text{signal}}$，生产者发出一个条件变量信号。当且仅当等待者此时正在条件变量等待队列中时，此信号会唤醒恰好一个等待者。信号不会被存储；如果没有等待者在队列中，信号没有效果。\n- 在指定的虚假唤醒步骤 $t \\in S_{\\text{spurious}}$，可能会发生一次虚假唤醒。如果等待者此时在队列中，它会像被信号唤醒一样醒来。\n- 在单个时间步 $t$ 内，事件按固定顺序处理：等待者操作（检查或进入），然后生产者设置 $ready$，然后生产者发信号，然后虚假唤醒。这个全序关系确保了行为的确定性。\n\n当等待者在循环中没有重新检查谓词的情况下，解锁互斥锁并调用条件变量等待时，会发生唤醒丢失 bug。如果在等待者实际开始等待之前，信号发生且谓词已经为真，那么这个信号就会丢失（因为没有线程在等待），尽管 $ready = 1$，等待者仍可能无限期阻塞。另一个微妙的 bug 是未能防范虚假唤醒；如果等待循环使用单个 $if$ 而不是 $while$，一次虚假唤醒可能导致等待者在 $ready = 0$ 时继续执行，从而违反安全性。\n\n你的任务是编写一个程序，该程序在所描述的事件调度下，确定性地模拟错误等待设计和正确等待设计。对于每个测试用例，计算两个整数：\n\n- $w$：错误（有bug的）设计的结果。\n- $c$：正确（已修复的）设计的结果。\n\n结果必须按如下方式量化：\n\n- 返回 $1$：如果等待者恰好继续执行一次，并且在继续执行时谓词 $ready = 1$（安全进展）。\n- 返回 $0$：如果等待者在时间范围 $H$ 内从未继续执行（死锁或错过唤醒）。\n- 返回 $-1$：如果等待者在继续执行的时刻 $ready = 0$（由于虚假唤醒或不正确的循环导致的安全违规）。\n\n你的程序应为以下测试套件计算这些结果，每个测试套件由整数指定：\n\n- 测试用例 $1$ (正常路径，$ready$ 变为真后发出正常信号): $s_{\\text{wait\\_check}} = 1$, $s_{\\text{wait\\_enter}} = 2$, $s_{\\text{ready}} = 2$, $s_{\\text{signal}} = 3$, $H = 6$, $S_{\\text{spurious}} = \\emptyset$。\n- 测试用例 $2$ (因谓词已为真且信号在等待者入队前发出而导致的唤醒丢失): $s_{\\text{wait\\_check}} = 1$, $s_{\\text{wait\\_enter}} = 5$, $s_{\\text{ready}} = 3$, $s_{\\text{signal}} = 3$, $H = 10$, $S_{\\text{spurious}} = \\emptyset$。\n- 测试用例 $3$ (谓词变为真之前的虚假唤醒): $s_{\\text{wait\\_check}} = 1$, $s_{\\text{wait\\_enter}} = 2$, $s_{\\text{ready}} = 8$, $s_{\\text{signal}} = 8$, $H = 10$, $S_{\\text{spurious}} = \\{4\\}$。\n- 测试用例 $4$ (边界情况，等待者在初始检查时看到 $ready = 1$ 且从不等待): $s_{\\text{wait\\_check}} = 0$, $s_{\\text{wait\\_enter}} = 1$, $s_{\\text{ready}} = 0$, $s_{\\text{signal}} = 0$, $H = 6$, $S_{\\text{spurious}} = \\{3,5\\}$。\n\n你的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[w_1,c_1,w_2,c_2,w_3,c_3,w_4,c_4]$，其中 $w_i$ 和 $c_i$ 分别是测试用例 $i$ 的错误和正确结果。例如，对于某些结果，格式必须与 $[1,1,0,1,-1,1,1,1]$ 完全一样。此问题不涉及物理单位、角度或百分比；所有输出均为上文定义的整数。", "solution": "该问题已被验证为具有科学依据、定义明确且客观。它提供了一个确定性框架，用于模拟涉及互斥锁和条件变量的经典并发控制场景，这是操作系统中的一个基础课题。所有必要的参数和规则都已提供，从而可以得出一个唯一且有意义的解。\n\n核心任务是模拟一个等待者线程与一个生产者线程的交互行为，以展示标准条件变量等待循环的正确性，以及一个幼稚、有 bug 的实现的缺陷。模拟在离散时间步 $t \\in \\{0, 1, \\dots, H\\}$ 上展开，由固定的事件调度控制。\n\n我们可以用元组 $(\\text{ready}_t, \\text{state}_w_t)$ 来为任意时间 $t$ 的模拟状态建模，其中：\n- $\\text{ready}_t \\in \\{0, 1\\}$ 是共享布尔谓词的值。它在 $t=0$ 时初始化为 $0$。\n- $\\text{state}_w_t$ 是等待者线程的状态。它可以是以下之一：$\\text{IDLE}$、$\\text{WANTS\\_TO\\_WAIT}$ 或 $\\text{IN\\_QUEUE}$。\n\n模拟的结果由等待者是否以及在何种条件下继续执行来决定。结果是一个整数：\n- $1$：安全进展。等待者恰好继续执行一次，并且在继续执行的时刻，$\\text{ready} = 1$。\n- $0$：死锁或错过唤醒。等待者未能在模拟时间范围 $H$ 结束前继续执行。\n- $-1$：安全性违规。等待者在 $\\text{ready} = 0$ 时继续执行。\n\n模拟逻辑根据提供的事件调度和关键的步内事件顺序来演进状态：(1) 等待者操作，(2) 生产者设置 `ready`，(3) 生产者发信号，以及 (4) 虚假唤醒。\n\n让我们基于这些规则来分析这两种设计。\n\n**1. 错误（有 bug 的）设计**\n此设计对应于有缺陷的模式 `if (!ready) { cv_wait(, ); }`。它有两个主要弱点。\n\n首先，在等待者释放互斥锁和进入等待状态之间存在竞争条件。问题将此建模为 $s_{\\text{wait\\_check}}$ 和 $s_{\\text{wait\\_enter}}$ 之间的时间间隙。如果生产者在此间隙内设置 $\\text{ready} := 1$ 并发出信号，信号会因为等待者尚未在等待队列中而丢失。当等待者随后在 $t=s_{\\text{wait\\_enter}}$ 时不重新检查谓词就进入队列时，它将无限期地等待一个已经发生过的信号。这就是**唤醒丢失 bug**。测试用例 2 旨在暴露此缺陷。\n\n其次，该设计容易受到虚假唤醒的影响。虚假唤醒是指并非由生产者的有意信号引起的唤醒。如果等待者被虚假唤醒，`if` 语句不会促使重新评估谓词。等待者只是简单地从 `cv_wait` 返回并继续执行，即使 `ready` 仍然是 $0$。这构成了**安全性违规**。测试用例 3 演示了这种失败模式。\n\n**2. 正确（已修复的）设计**\n此设计实现了规范的等待循环：`while (!ready) { cv_wait(, ); }`。这种模式稳健地解决了错误设计的两个缺陷。\n\n`while` 循环确保了在线程尝试等待之前立即重新评估谓词。在我们的模拟中，在 $t=s_{\\text{wait\\_enter}}$ 时，等待者会重新检查 `ready`。如果在此期间它已变为 $1$，循环条件为假，等待者会正确地继续执行，而无需进入等待队列。这解决了唤醒丢失 bug。\n\n此外，`while` 循环确保在*每次*唤醒时（无论是真实的还是虚假的）都重新评估谓词。如果在 `ready` 仍为 $0$ 时发生虚假唤醒，循环条件仍然为真，等待者会通过 `cv_wait` 正确地重新进入等待状态。只有当它醒来并发现 `ready` 确实为 $1$ 时，它才会继续执行。这可以防止因虚假唤醒而导致的安全违规。\n\n**模拟算法**\nC 代码实现将遵循一个状态机模型。对于每种设计（错误的和正确的）和每个测试用例，模拟按以下步骤进行：\n- 初始化 $\\text{ready} = 0$，$\\text{state}_w = \\text{IDLE}$，以及结果为 $0$。\n- 对 $t$ 从 $0$ 到 $H$ 循环：\n    1.  **等待者操作阶段**：在 $t = s_{\\text{wait\\_check}}$ 时，如果 $\\text{ready} = 0$，将 $\\text{state}_w$ 转换到 $\\text{WANTS\\_TO\\_WAIT}$。如果 $\\text{ready} = 1$，等待者继续执行，结果为 $1$，本次运行的模拟终止。在 $t = s_{\\text{wait\\_enter}}$ 时，如果 $\\text{state}_w = \\text{WANTS\\_TO\\_WAIT}$：\n        - 对于正确的设计，重新检查 `ready`。如果为 $1$，则继续执行（结果为 $1$）。否则，转换到 $\\text{IN\\_QUEUE}$。\n        - 对于错误的设计，无条件地转换到 $\\text{IN\\_QUEUE}$。\n    2.  **生产者就绪阶段**：在 $t = s_{\\text{ready}}$ 时，设置 $\\text{ready} := 1$。\n    3.  **生产者信号阶段**：检查唤醒事件。如果在 $t$ 时刻满足 $t=s_{\\text{signal}}$ 或 $t \\in S_{\\text{spurious}}$，并且 $\\text{state}_w = \\text{IN\\_QUEUE}$，则发生唤醒。\n    4.  **唤醒处理**：如果发生唤醒：\n        - 对于正确的设计，检查 `ready`。如果为 $1$，则继续执行（结果为 $1$）。如果为 $0$，等待者保持在 $\\text{IN\\_QUEUE}$ 状态（概念上，它重新等待）。\n        - 对于错误的设计，等待者立即继续执行。如果此时 $\\text{ready} = 1$，结果为 $1$；如果 $\\text{ready} = 0$，结果为 $-1$。\n    5.  如果确定了 $1$ 或 $-1$ 的结果，则终止当前运行的模拟。\n- 如果循环完成而等待者没有继续执行，最终结果保持为 $0$。\n\n这个确定性模拟将通过对每个指定的测试用例应用这些规则来计算出结果 $[w_1, c_1, w_2, c_2, w_3, c_3, w_4, c_4]$。", "answer": "```c\n#include", "id": "3661722"}, {"introduction": "在真实世界的软件开发中，我们不仅要学会预防问题，更要掌握在问题发生后进行诊断和修复的能力。这个练习模拟了一个服务挂起的真实场景，你需要扮演一名系统工程师，通过分析捕获的线程堆栈跟踪和锁状态快照来诊断死锁。这个练习[@problem_id:3661769]将教会你如何构建“等待关系图”，从看似混乱的运行时数据中找出导致系统停滞的循环等待，并选择最稳健的策略来根除它。", "problem": "一个在符合 POSIX（Portable Operating System Interface）标准的操作系统（OS）上运行的多线程服务使用互斥锁来保护跨模块的共享状态。创建了三个互斥锁，标记为 $M_x$、$M_y$ 和 $M_z$，它们都使用默认属性。四个线程，标记为 $T_1$、$T_2$、$T_3$ 和 $T_4$，执行工作函数，这些函数有时会获取多个互斥锁。在挂钟时间 $t = 17{:}23{:}54$ 时，该服务表现为挂起状态。您触发了一次诊断捕获，该捕获停止了所有线程，并记录了它们的堆栈跟踪以及每个互斥锁经过插桩的持有者/等待者快照。捕获结果如下：\n\n- 线程 $T_1$ 堆栈（显示顶层帧）：\n  - $pthread\\_mutex\\_lock(M_y)$ 阻塞中\n  - 下方：持有 $M_x$ 后调用 $process\\_B$\n  - 插桩显示 $T_1$ 当前持有 $M_x$ 并正在尝试锁定 $M_y$\n\n- 线程 $T_2$ 堆栈（显示顶层帧）：\n  - $pthread\\_mutex\\_lock(M_x)$ 阻塞中\n  - 下方：持有 $M_y$ 后调用 $process\\_A$\n  - 插桩显示 $T_2$ 当前持有 $M_y$ 并正在尝试锁定 $M_x$\n\n- 线程 $T_3$ 堆栈（显示顶层帧）：\n  - $pthread\\_mutex\\_lock(M_z)$ 阻塞中\n  - 下方：未持有其他互斥锁时调用 $aux\\_work$\n  - 插桩显示 $T_3$ 正在尝试锁定 $M_z$\n\n- 线程 $T_4$ 堆栈（显示顶层帧）：\n  - $do\\_maintenance$ 运行中\n  - 插桩显示 $T_4$ 当前持有 $M_z$ 并且没有尝试锁定任何其他互斥锁\n\n- 互斥锁持有者/等待者快照（来自同一时刻的插桩）：\n  - $M_x$：持有者 $T_1$；等待者 $\\{T_2\\}$\n  - $M_y$：持有者 $T_2$；等待者 $\\{T_1\\}$\n  - $M_z$：持有者 $T_4$；等待者 $\\{T_3\\}$\n\n假设使用标准的互斥锁语义：在一个有竞争的互斥锁上调用 $pthread\\_mutex\\_lock$ 会使调用线程进入阻塞状态，并且互斥锁不能被抢占或从其持有者处强制拿走。死锁需要满足四个 Coffman 条件：互斥、持有并等待、不可抢占和循环等待。\n\n仅使用这些基本定义和捕获的数据，您希望既能诊断挂起问题，又能选择最健壮且侵入性最小的变更来防止问题复现。哪个选项正确描述了一种基于原则的调试方法：该方法使用堆栈跟踪来识别哪个线程持有哪个互斥锁以及哪个线程在等待哪个互斥锁，然后提出了一个修复方案，该方案能在所有代码路径上打破死锁的根本必要条件？\n\nA. 通过将每个阻塞的 $pthread\\_mutex\\_lock$ 帧映射到其目标互斥锁，并交叉引用插桩数据中的持有者来构建一个等待图：检测到边 $T_1 \\rightarrow M_y \\rightarrow T_2$ 和 $T_2 \\rightarrow M_x \\rightarrow T_1$，它们形成了一个环路，而 $T_3 \\rightarrow M_z \\rightarrow T_4$ 不属于环路的一部分。结论是 $T_1$ 和 $T_2$ 因在不同路径中锁获取顺序相反，在 $M_x$ 和 $M_y$ 上发生了死锁。通过在所有模块中强制执行严格的全局锁顺序 $M_x \\rightarrow M_y \\rightarrow M_z$，并用断言进行验证，从而在系统范围内打破循环等待。\n\nB. 结论是 $T_3$ 和 $T_4$ 在 $M_z$ 上发生了死 deadlock，因为 $T_3$ 被阻塞而 $T_4$ 持有 $M_z$。通过为所有 $pthread\\_mutex\\_lock$ 调用添加超时来解决，这样阻塞的线程最终会中止其锁尝试并继续执行。\n\nC. 诊断为饥饿而非死锁：$T_1$ 被阻塞是因为 $T_2$ 有更高的优先级并持续运行。通过将 $T_1$ 的调度器优先级提升到 $T_2$ 之上来修复，以确保它能更快地获取 $M_y$。\n\nD. 通过在 $process\\_B$ 中围绕 $M_y$ 插入先解锁后加锁的逻辑来避免环路：在尝试获取 $M_y$ 时临时释放 $M_x$，之后再重新获取 $M_x$。这种局部变更足以防止死锁，而无需全局策略。", "solution": "从基本定义开始。互斥锁确保互斥性：在任何时刻，最多只有一个线程可以持有一个互斥锁。根据 POSIX 语义，对一个已被锁定的互斥锁调用 $pthread\\_mutex\\_lock$ 会阻塞调用者，直到该互斥锁可用。Coffman 条件指出，当四个条件同时成立时会发生死锁：互斥、持有并等待（每个进程在等待其他资源时至少持有一个资源）、不可抢占（资源不能被强制拿走）以及循环等待（资源分配图中存在一个环路，使得每个进程都在等待下一个进程持有的资源）。\n\n从基本原理出发，诊断死锁需要构建一个等待/资源分配图。节点可以是线程（$T_i$）和互斥锁（$M_j$）。一条有向边 $T_i \\rightarrow M_j$ 表示线程 $T_i$ 当前阻塞等待获取互斥锁 $M_j$。一条有向边 $M_j \\rightarrow T_i$ 表示互斥锁 $M_j$ 当前被线程 $T_i$ 持有。一个在线程和互斥锁之间交替出现的环路表示循环等待，满足了第四个 Coffman 条件。如果互斥、持有并等待以及不可抢占条件也成立（对于标准互斥锁来说确实如此），那么系统就处于死锁状态。\n\n使用捕获的堆栈跟踪和插桩数据：\n\n- 对于 $T_1$：顶层帧显示 $pthread\\_mutex\\_lock(M_y)$ 阻塞中，插桩数据表明 $T_1$ 持有 $M_x$。因此，添加边 $T_1 \\rightarrow M_y$ 和 $M_x \\rightarrow T_1$。\n\n- 对于 $T_2$：顶层帧显示 $pthread\\_mutex\\_lock(M_x)$ 阻塞中，插桩数据表明 $T_2$ 持有 $M_y$。因此，添加边 $T_2 \\rightarrow M_x$ 和 $M_y \\rightarrow T_2$。\n\n- 对于 $T_3$：顶层帧显示 $pthread\\_mutex\\_lock(M_z)$ 阻塞中。插桩数据未显示 $T_3$ 持有任何其他互斥锁，因此添加边 $T_3 \\rightarrow M_z$。\n\n- 对于 $T_4$：插桩数据显示 $T_4$ 持有 $M_z$ 并且没有尝试锁定其他任何东西，因此添加边 $M_z \\rightarrow T_4$。\n\n现在分析该图：\n\n- 涉及 $T_1$、$T_2$、$M_x$ 和 $M_y$ 的子图包含 $T_1 \\rightarrow M_y \\rightarrow T_2 \\rightarrow M_x \\rightarrow T_1$。这是一个环路。互斥条件成立，因为 $M_x$ 和 $M_y$ 是互斥锁。持有并等待条件成立，因为 $T_1$ 在等待 $M_y$ 时持有 $M_x$，而 $T_2$ 在等待 $M_x$ 时持有 $M_y$。对于标准互斥锁，不可抢占条件成立。因此，所有四个 Coffman 条件都得到满足，$T_1$ 和 $T_2$ 发生了死锁。\n\n- 涉及 $T_3$、$T_4$ 和 $M_z$ 的子图包含 $T_3 \\rightarrow M_z \\rightarrow T_4$。没有从 $T_4$ 到另一个互斥锁的边。因此，这里没有环路，这不是死锁。这只是一个简单的争用，其中 $T_3$ 等待直到 $T_4$ 释放 $M_z$。\n\n为了防止问题复现，需要寻找一种能够在全局范围内打破其中一个 Coffman 条件的侵入性最小的变更。对于需要多个锁的代码库中出现的互斥锁死锁问题，最标准和最健壮的方法是强制执行严格的全局锁顺序。如果所有代码路径都按照 $M_x$，然后 $M_y$，然后 $M_z$（或任何一致的全序）的顺序获取锁，那么循环等待就不可能发生：因为代表“等待”的边总是从一个低阶锁指向一个高阶锁，从而产生一个无环偏序，所以不可能出现环路。这打破了循环等待条件，而无需改变互斥语义或要求抢占。可以使用断言来验证函数在调试版本中运行时是否违反了该顺序。\n\n评估每个选项：\n\nA. 该选项提出了基于原则的诊断方法：从堆栈跟踪和持有者数据构建等待图。它正确地识别了环路 $T_1 \\rightarrow M_y \\rightarrow T_2 \\rightarrow M_x \\rightarrow T_1$，并正确地排除了 $T_3$ 和 $T_4$ 的死锁情况。然后，它提出在所有模块中强制执行全局锁顺序 $M_x \\rightarrow M_y \\rightarrow M_z$，这从设计上就打破了循环等待条件。这与基本定义一致，且侵入性最小：它只需要修改代码以重新排序锁的获取并添加检查，而无需改变互斥锁的抽象。结论：正确。\n\nB. 该选项错误地诊断 $T_3$ 和 $T_4$ 之间存在死锁。图中没有环路；$T_3$ 在等待由 $T_4$ 持有的 $M_z$，但 $T_4$ 并未等待任何资源。因此，这不是死锁。此外，为 $pthread\\_mutex\\_lock$ 添加超时不是标准的 POSIX 功能，即使通过非阻塞尝试和重试来实现，也可能引入活锁或违反临界区的原子性保证。它没有解决 $T_1$ 和 $T_2$ 之间的实际环路。结论：错误。\n\nC. 该选项声称是由于调度器优先级导致的饥饿。捕获的数据明确显示是在互斥锁获取上阻塞，而不是抢占问题。当 $T_1$ 等待 $T_2$ 持有的 $M_y$ 同时 $T_2$ 等待 $T_1$ 持有的 $M_x$ 时，优先级变更无法解决这个环路。调度器变更无法打破互斥依赖关系。结论：错误。\n\nD. 该选项建议在尝试获取 $M_y$ 之前局部地解锁 $M_x$，然后再重新获取 $M_x$。虽然表面上这可能避免一个循环等待的实例，但它引入了一个窗口期，在此期间由 $M_x$ 保护的临界区是不受保护的，可能导致竞争和不变量违规。此外，如果没有一个一致的全局策略，其他路径仍然可能以相反的顺序获取锁并导致死锁。这不是一个健壮的、系统级的修复方案，并且可能降低正确性。结论：错误。\n\n因此，最佳选择是选项 A，它正确地使用堆栈跟踪来构建等待图，识别了死锁，并提出了一个恰当的全局锁顺序来打破循环等待条件。", "answer": "$$\\boxed{A}$$", "id": "3661769"}]}