{"hands_on_practices": [{"introduction": "我们将从一个看似微小的改动开始：交换Peterson算法入口协议中的前两行代码。这个练习至关重要，因为它直接揭示了为何算法中的操作顺序并非随意安排，而是保证互斥性的关键。通过分析这个有缺陷的版本[@problem_id:3669544]，你将学会如何敏锐地识别因指令排序不当而引发的竞态条件。", "problem": "考虑经典的双进程 Peterson 临界区问题解法。存在 $2$ 个进程 $P_0$ 和 $P_1$，它们在顺序一致性（SC）下共享 $3$ 个单写者/单读者原子变量：一个布尔数组 $flag[\\,]$，其中 $flag[i]$ 表示进入意图；以及一个整数 $turn \\in \\{0,1\\}$，用于打破僵局。对于进程 $P_i$，令 $j = 1 - i$。原始的进入协议在忙等待前按顺序执行以下两个操作：设置 $flag[i]$ 以表示兴趣，然后设置 $turn$ 将优先权交给另一个进程。在所考虑的修改版本中，这两行代码的顺序被交换，因此每个进程 $P_i$ 按程序顺序执行：\n- $turn := j$\n- $flag[i] := \\text{true}$\n- `while` $\\big(flag[j] \\land (turn = j)\\big)$ `do busy-wait`\n- 进入临界区\n- $flag[i] := \\text{false}$ 退出时执行\n\n假设系统满足顺序一致性（SC）并且对 $flag[\\,]$ 和 $turn$ 的读/写是原子的。仅使用临界区的安全性和活性核心定义：\n- 互斥性：在任何时刻，最多只有一个进程处于临界区内。\n- 前进性（无死锁）：如果没有进程在临界区内，并且有一个或多个进程希望进入，那么最终某个进程将得以进入。\n\n哪个选项正确地描述了此修改是否违反了互斥性或前进性，并提供了一个具体的交错调度（原子操作序列）来证明该违规？\n\nA. 互斥性被违反。示例调度，两个进程都从剩余区开始并尝试进入：\n- 步骤 $1$：$P_0$ 执行 $turn := 1$。\n- 步骤 $2$：$P_1$ 执行 $turn := 0$。\n- 步骤 $3$：$P_1$ 执行 $flag[1] := \\text{true}$。\n- 步骤 $4$：$P_1$ 计算 while 条件 $\\big(flag[0] \\land (turn = 0)\\big)$；由于 $flag[0] = \\text{false}$，它进入临界区。\n- 步骤 $5$：$P_0$ 执行 $flag[0] := \\text{true}$。\n- 步骤 $6$：$P_0$ 计算 while 条件 $\\big(flag[1] \\land (turn = 1)\\big)$；由于 $flag[1] = \\text{true}$ 且 $turn = 0$，它进入临界区。\n$P_1$ 和 $P_0$ 同时处于临界区中。\n\nB. 前进性被违反（两个进程都可能永远卡在忙等待中）。示例调度：\n- 步骤 $1$：$P_0$ 执行 $turn := 1$，然后执行 $flag[0] := \\text{true}$。\n- 步骤 $2$：$P_1$ 执行 $turn := 0$，然后执行 $flag[1] := \\text{true}$。\n- 步骤 $3$：两者都计算其 while 条件并永远忙等待，因为每个进程都看到对方的 $flag$ 为 $\\text{true}$ 并且 $turn$ 偏向对方进程。\n\nC. 在顺序一致性（SC）下，互斥性和前进性都没有被违反；用于打破僵局的机制仍然能确保当两个进程都有兴趣时只有一个进程继续前进。\n\nD. 互斥性得以保持，但前进性可能因活锁而被违反，其中两个进程重复设置 $turn$ 和 $flag[\\,]$ 并不断地相互谦让，而没有任何一个进入临界区。\n\n选择唯一最佳选项。", "solution": "该问题要求分析 Peterson 双进程临界区问题解法的一个修改版本。该修改涉及交换进入协议中前两个语句的顺序。我们必须确定此修改是否违反了互斥性或前进性属性。\n\n设两个进程为 $P_0$ 和 $P_1$。共享变量是一个布尔数组 $flag[2]$ 和一个整数 $turn \\in \\{0,1\\}$。我们假设标准初始状态，即两个进程都在其剩余区中，因此 $flag[0] = \\text{false}$ 且 $flag[1] = \\text{false}$。$turn$ 的初始值是任意的。对共享变量的所有读写都是原子的，并且系统遵循顺序一致性（SC）。\n\n对于一个进程 $P_i$（其中 $i \\in \\{0,1\\}$ 且 $j = 1-i$），修改后的协议如下：\n\n**进入区：**\n1.  $turn := j$\n2.  $flag[i] := \\text{true}$\n3.  `while` ($(flag[j] \\land (turn = j))$) `do` busy-wait\n\n**临界区：**\n...\n\n**退出区：**\n1.  $flag[i] := \\text{false}$\n\n我们将分析两个基本属性：互斥性和前进性。\n\n### 互斥性分析\n互斥性要求在任何给定时间最多只有一个进程可以处于其临界区内。为了测试是否存在违规，我们寻找一个可能的操作交错序列，该序列允许 $P_0$ 和 $P_1$ 同时进入它们的临界区。\n\n让我们考虑以下事件序列，从初始状态 $flag[0] = \\text{false}$，$flag[1] = \\text{false}$，以及任意的 $turn$ 值开始。\n\n1.  **$P_0$ 执行 `turn := 1`**。共享变量 $turn$ 的值现在为 $1$。共享变量的状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=1$)。\n2.  **$P_0$ 被抢占。**\n3.  **$P_1$ 执行 `turn := 0`**。共享变量 $turn$ 被覆盖，其值现在为 $0$。状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{false}$, $turn=0$)。\n4.  **$P_1$ 执行 `flag[1] := true`**。状态是 ($flag[0]=\\text{false}$, $flag[1]=\\text{true}$, $turn=0$)。\n5.  **$P_1$ 计算其 `while` 条件**：$flag[0] \\land (turn = 0)$。\n    -   表达式 $flag[0]$ 的计算结果为 $\\text{false}$。\n    -   因此，整个合取式为 $\\text{false}$。\n    -   $P_1$ 不会循环，继续进入其临界区。\n6.  **$P_1$ 处于其临界区中。$P_0$ 恢复执行。**\n7.  **$P_0$ 执行 `flag[0] := true`**。状态是 ($flag[0]=\\text{true}$, $flag[1]=\\text{true}$, $turn=0$)。\n8.  **$P_0$ 计算其 `while` 条件**：$flag[1] \\land (turn = 1)$。\n    -   表达式 $flag[1]$ 的计算结果为 $\\text{true}$。\n    -   表达式 $(turn = 1)$ 的计算结果为 $\\text{false}$，因为 $turn$ 当前为 $0$。\n    -   因此，整个合取式为 $\\text{false}$。\n    -   $P_0$ 不会循环，继续进入其临界区。\n\n此时，$P_1$ 和 $P_0$ 都处于各自的临界区中。这构成了对互斥性属性的明确违反。这个缺陷的产生原因在于，进程 $P_i$ 可以在升起自己的标志 $flag[i]$ 之前，就设置 $turn$ 变量以让步给 $P_j$。这使得 $P_j$ 可以看到 $P_i$ 没有兴趣（$flag[i]$ 为 $\\text{false}$）而继续前进，同时 $P_j$ 设置的 $turn$ 值也会随后允许 $P_i$ 进入。\n\n### 前进性分析\n前进性属性，根据定义，意味着无死锁：如果没有进程在其临界区内，并且一些进程希望进入，那么其中一个必须最终能够进入。如果两个进程都可能永久地阻塞在它们的 `while` 循环中，就会发生违规。\n\n为了进行反证，我们假设两个进程都发生了死锁。\n-   要使 $P_0$ 被阻塞，它必须在其 `while` 循环中忙等待。这要求其条件 $flag[1] \\land (turn = 1)$ 持续为真。这意味着 $flag[1] = \\text{true}$ 且 $turn = 1$。\n-   要使 $P_1$ 被阻塞，它必须在其 `while` 循环中忙等待。这要求其条件 $flag[0] \\land (turn = 0)$ 持续为真。这意味着 $flag[0] = \\text{true}$ 且 $turn = 0$。\n\n要使两个进程同时死锁，系统状态必须同时满足所有这些条件。这将要求 $turn = 1$ 和 $turn = 0$ 同时为真，这在逻辑上是不可能的，因为 $turn$ 是一个单一变量。因此，两个进程不可能同时卡在它们的 `while` 循环中。在任何时刻，至少有一个等待条件必须为假。因此，死锁不会发生，前进性属性没有被违反。\n\n### 选项评估\n\n**A. 互斥性被违反。示例调度，两个进程都从剩余区开始并尝试进入：...**\n该选项声称互斥性被违反，并提供了一个证明性的调度。\n-   该调度为：\n    1.  $P_0$ 执行 $turn := 1$。（状态：$turn=1$）\n    2.  $P_1$ 执行 $turn := 0$。（状态：$turn=0$）\n    3.  $P_1$ 执行 $flag[1] := \\text{true}$。（状态：$flag[1]=\\text{true}, turn=0$）\n    4.  $P_1$ 检查 $flag[0] \\land (turn = 0)$。由于 $flag[0]=\\text{false}$，条件为 $\\text{false}$，$P_1$ 进入其临界区。\n    5.  $P_0$ 执行 $flag[0] := \\text{true}$。（状态：$flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$）\n    6.  $P_0$ 检查 $flag[1] \\land (turn = 1)$。由于 $turn=0$，子表达式 $(turn=1)$ 为 $\\text{false}$。条件为 $\\text{false}$，$P_0$ 进入其临界区。\n-   该调度是有效的，并正确地显示了两个进程都处于临界区中。互斥性被违反的结论是正确的。\n-   **结论：正确。**\n\n**B. 前进性被违反（两个进程都可能永远卡在忙等待中）。示例调度：...**\n该选项声称存在前进性违规（死锁）。我上面的分析证明了死锁是不可能的。让我们分析所提供的调度：\n-   该调度为：\n    1.  $P_0$ 执行 $turn := 1$，然后执行 $flag[0] := \\text{true}$。（状态：$turn=1, flag[0]=\\text{true}$）\n    2.  $P_1$ 执行 $turn := 0$，然后执行 $flag[1] := \\text{true}$。（状态：$turn=0, flag[0]=\\text{true}, flag[1]=\\text{true}$）\n    3.  两者都计算其 while 条件。\n-   让我们根据最终状态（$flag[0]=\\text{true}, flag[1]=\\text{true}, turn=0$）检查条件：\n    -   $P_0$ 的条件：$flag[1] \\land (turn=1)$。这是 $\\text{true} \\land (\\text{false})$，结果为 $\\text{false}$。$P_0$ 不会忙等待；它进入临界区。\n    -   $P_1$ 的条件：$flag[0] \\land (turn=0)$。这是 $\\text{true} \\land (\\text{true})$，结果为 $\\text{true}$。$P_1$ 忙等待。\n-   该选项的结论“两者……永远忙等待”是错误的。$P_0$ 取得了进展。因此，该调度不会导致死锁。\n-   **结论：不正确。**\n\n**C. 在顺序一致性（SC）下，互斥性和前进性都没有被违反；用于打破僵局的机制仍然能确保当两个进程都有兴趣时只有一个进程继续前进。**\n该选项声称算法是正确的。我们的分析通过一个有效的反例显示了对互斥性的明确违反。在这个修改版本中，打破僵局的机制是有缺陷的。\n-   **结论：不正确。**\n\n**D. 互斥性得以保持，但前进性可能因活锁而被违反，其中两个进程重复设置 $turn$ 和 $flag[\\,]$ 并不断地相互谦让，而没有任何一个进入临界区。**\n该选项声称互斥性得以保持，这是错误的，如对选项 A 的分析所示。此外，协议中没有机制让进程在不进入临界区的情况下“重复设置 $turn$ 和 $flag[\\,]$”。一旦一个进程设置了它的标志，该标志将一直保持设置状态，直到它退出临界区。互斥性得以保持这个前提本身就足以使该选项无效。\n-   **结论：不正确。**\n\n分析证实，只有互斥性被违反，而前进性（无死锁）得以保持。选项 A 正确地指出了这一点，并提供了一个有效的反例。", "answer": "$$\\boxed{A}$$", "id": "3669544"}, {"introduction": "在真实世界的系统中，性能优化至关重要。这个练习[@problem_id:3669493]引入了一个巧妙的优化：只有在检测到竞争时才更新$turn$变量，以减少非竞争情况下的内存写入开销。你的任务是严格地分析，在顺序一致性模型下，这个优化是否还能保持算法的正确性（互斥性、前进性和有界等待），并思考其在现代处理器上的稳健性。", "problem": "两个进程，由索引 $i \\in \\{0,1\\}$ 和 $j = 1 - i$ 表示，共享两个布尔变量 $flag[0], flag[1]$ 和一个整数变量 $turn$。所有共享变量初始化为 $flag[0] = flag[1] = \\text{false}$，并且 $turn$ 在 $\\{0,1\\}$ 中任意取值。假设读写操作是原子的，并且内存模型提供顺序一致性（Sequential Consistency, SC），这意味着任何执行的结果都等同于所有进程的所有操作按照某种尊重每个独立进程程序顺序的交错次序执行的结果。\n\n考虑 Peterson 双进程互斥协议的以下变体。每个进程 $i$ 执行以下循环，其中 $j = 1 - i$：\n- 设置 $flag[i] \\leftarrow \\text{true}$。\n- 如果观察到 $flag[j]$ 为 $\\text{true}$，则设置 $turn \\leftarrow j$；否则，不写入 $turn$。\n- 当 $flag[j] \\land (turn = j)$ 时忙等待。\n- 执行临界区。\n- 设置 $flag[i] \\leftarrow \\text{false}$。\n- 执行剩余区。\n\n此变体与教科书中的 Peterson 解法的唯一区别在于对 $turn$ 的写入是条件性的：仅在检测到 $flag[j] = \\text{true}$ 时才写入 $turn$；在无竞争的情况下（$flag[j] = \\text{false}$），对 $turn$ 的写入被跳过。\n\n根据互斥（任何时候最多只有一个进程在临界区内）、前进（如果没有进程在临界区内且有进程希望进入，则某个进程最终会进入）和有界等待（一个希望进入临界区的进程不会被另一个进程无限次超越）的基本定义，并在上述 SC 和原子读/写假设下，确定关于此变体的哪些陈述是正确的。\n\n选择所有适用的选项。\n\nA. 与教科书中的 Peterson 解法相比，此变体在没有竞争时（即 `$flag[j] = \\text{false}$` 时）减少了对 `turn` 的写入，并且在具有原子读/写的 SC 模型下，它仍然保证互斥、前进和有界等待。\n\nB. 该变体可能违反互斥：如果两个进程在条件更新时都观察到 `$flag[j] = \\text{false}$`，那么它们都可能进入临界区，因为 `turn` 可能保留一个过时的值。\n\nC. 该变体可能发生死锁：如果两个进程都不更新 `turn`（因为每个进程都观察到 `$flag[j] = \\text{false}$`），它们都会在 `turn` 不变的情况下永远忙等待。\n\nD. 该变体在 SC 模型下保持了互斥和前进，但可能违反有界等待；一个进程可能会饿死，而另一个进程则重复地重新进入。\n\nE. 在没有 SC 的架构上，并且在缺少适当的内存排序原语（如内存栅栏）的情况下，教科书中的 Peterson 解法和此变体都可能失败；条件更新不能纠正弱内存模型下的重排序问题。", "solution": "问题要求分析 Peterson 双进程互斥算法的一个变体。分析将在指定的条件下进行：原子读/写操作和顺序一致性（SC）内存模型。需要验证的三个基本属性是互斥、前进和有界等待。\n\n对于进程 $i \\in \\{0, 1\\}$，其中 $j = 1 - i$，算法如下：\n1. 进入区：\n   1. $flag[i] \\leftarrow \\text{true}$。\n   2. 如果观察到 $flag[j]$ 为 $\\text{true}$，则 $turn \\leftarrow j$。\n   3. 当 $(flag[j] \\land (turn = j))$ 时忙等待。\n2. 临界区 (CS)。\n3. 退出区：\n   1. $flag[i] \\leftarrow \\text{false}$。\n4. 剩余区。\n\n共享变量初始化为 $flag[0] \\leftarrow \\text{false}$，$flag[1] \\leftarrow \\text{false}$，且 $turn$ 被设置为 $\\{0, 1\\}$ 中的一个任意值。\n\n### 在顺序一致性 (SC) 下的分析\n\n在 SC 模型下，所有进程的所有内存操作被合并到一个单一的总序中，该总序与每个独立进程的程序顺序一致。\n\n#### 1. 互斥 (Mutual Exclusion)\n为了证明互斥性，我们采用反证法，假设进程 $P_0$ 和 $P_1$ 同时处于其临界区中。\n- 如果 $P_0$ 在其 CS 中，它必须已经通过了其忙等待循环。这意味着当它最后一次评估条件 $(flag[1] \\land (turn = 1))$ 时，该条件为 $\\text{false}$。\n- 如果 $P_1$ 在其 CS 中，它必须已经通过了其忙等待循环。这意味着当它最后一次评估条件 $(flag[0] \\land (turn = 0))$ 时，该条件为 $\\text{false}$。\n\n任何进程 $i$ 要进入其 CS，必须先设置 $flag[i] \\leftarrow \\text{true}$。因此，如果两个进程都在其 CS 中，那么必然有 $flag[0] = \\text{true}$ 和 $flag[1] = \\text{true}$。\n\n鉴于两个标志都为 $\\text{true}$：\n- $P_0$ 要进入，其循环条件 $(\\text{true} \\land (turn = 1))$ 必须为 $\\text{false}$。这要求在它最后一次检查时 $turn = 0$。\n- $P_1$ 要进入，其循环条件 $(\\text{true} \\land (turn = 0))$ 必须为 $\\text{false}$。这要求在它最后一次检查时 $turn = 1$。\n\n设 $C_0$ 是 $P_0$ 对循环条件的最后一次（成功的）检查，而 $C_1$ 是 $P_1$ 的最后一次检查。在操作 $C_0$ 时，$turn$ 的值必须是 $0$。在操作 $C_1$ 时，$turn$ 的值必须是 $1$。\n\n让我们分析对共享变量 $turn$ 的写入操作。\n- $P_0$ 仅在观察到 $flag[1] = \\text{true}$ 时才写入 $turn \\leftarrow 1$。\n- $P_1$ 仅在观察到 $flag[0] = \\text{true}$ 时才写入 $turn \\leftarrow 0$。\n\n由于两个进程都在 CS 中，所以 $flag[0]$ 和 $flag[1]$ 都必须是 $\\text{true}$。这意味着如果它们在竞争，每个进程都会看到对方的标志为 $\\text{true}$，并会尝试写入 $turn$。SC 模型对这些写入施加了一个总序。设两个进程进入其 CS 之前对 $turn$ 的最后一次写入操作为 $W_{last}$。\n- 情况 1：$W_{last}$ 是 $P_0$ 写入 $turn \\leftarrow 1$。这次写入后，$turn$ 的值为 $1$。如果 $P_0$ 接着进入其等待循环，它将评估 $(flag[1] \\land (turn = 1))$，该值将为 $\\text{true}$（因为 $P_1$ 要在其 CS 中，$flag[1]$ 必须为 $\\text{true}$）。因此，$P_0$ 会被阻塞。它不可能进入其 CS。\n- 情况 2：$W_{last}$ 是 $P_1$ 写入 $turn \\leftarrow 0$。这次写入后，$turn$ 的值为 $0$。如果 $P_1$ 接着进入其等待循环，它将评估 $(flag[0] \\land (turn = 0))$，该值将为 $\\text{true}$。因此，$P_1$ 会被阻塞。\n\n最后写入 $turn$ 的进程实际上让步给了另一个进程，阻止了自己进入 CS。因此，在竞争情况下，Peterson 解法的核心逻辑得以保留。在无竞争情况下（例如，$P_0$ 在 $flag[1]$ 为 $\\text{false}$ 时运行），$P_0$ 会跳过对 $turn$ 的写入，并立即通过等待循环，因为条件的 $flag[1]$ 部分是 $\\text{false}$。如果 $P_1$ 随后尝试进入，它会看到 $flag[0] = \\text{true}$，设置 $turn \\leftarrow 0$，并被迫在条件 $(flag[0] \\land (turn = 0))$ 上等待。\n\n互斥性得到保证。\n\n#### 2. 前进 (Progress)\n前进要求，如果有进程希望进入其 CS 且没有进程在 CS 中，那么某个进程最终必须能够进入。这主要是一个避免死锁的问题。\n如果两个进程都永远卡在它们的忙等待循环中，就会发生死锁。\n- 如果 $(flag[1] \\land (turn = 1))$ 永久为 $\\text{true}$，$P_0$ 就会被卡住。\n- 如果 $(flag[0] \\land (turn = 0))$ 永久为 $\\text{true}$，$P_1$ 就会被卡住。\n\n如果两个进程都试图进入，它们都会将自己的标志设置为 $\\text{true}$。要发生死锁，需要两个循环条件都为 $\\text{true}$。这要求 $(turn = 1)$ 和 $(turn = 0)$ 同时成立，这是不可能的。因此，在任何时候，最多只有一个进程会因为 $turn$ 变量而被阻塞。另一个进程的循环条件将为 $\\text{false}$，使其能够进入其 CS。前进性得到保证。\n\n#### 3. 有界等待 (Bounded Waiting)\n有界等待意味着，一个希望进入其 CS 的进程 $P_i$ 将在另一个进程 $P_j$ 被允许无限次进入其 CS 之前进入。\n假设 $P_0$ 希望进入其 CS。它设置 $flag[0] \\leftarrow \\text{true}$，现在在其循环处等待。要使 $P_0$ 等待，必须有 $flag[1] = \\text{true}$ 和 $turn = 1$。这意味着 $P_1$ 也处于其进入区或临界区。\n$P_1$ 可以处于其 CS 中，因为它的等待条件 $(flag[0] \\land (turn = 0))$ 是 $\\text{false}$ 的（因为 $turn=1$）。\n现在，一旦 $P_1$ 退出其 CS，它会设置 $flag[1] \\leftarrow \\text{false}$。这立即导致 $P_0$ 的等待条件 $(flag[1] \\land (turn = 1))$ 变为 $\\text{false}$，允许 $P_0$ 继续执行。\n如果 $P_1$ 速度非常快，并在 $P_0$（现在已解除阻塞）得以运行之前尝试重新进入其 CS 会怎么样？\n- $P_1$ 循环回来并再次执行其进入协议。它设置 $flag[1] \\leftarrow \\text{true}$。\n- 然后它观察到 $flag[0]$ 为 $\\text{true}$（因为 $P_0$ 仍在等待进入）。\n- 因此，$P_1$ 执行条件写入：$turn \\leftarrow 0$。\n这个操作是关键。通过设置 $turn \\leftarrow 0$，$P_1$ 保证了 $P_0$ 的等待条件 $(flag[1] \\land (turn = 1))$ 将为 $\\text{false}$，因为现在 $turn \\neq 1$。$P_0$ 保证能够进入。同时，$P_1$ 现在将被卡在自己的等待循环中，评估 $(flag[0] \\land (turn = 0))$ 为 $\\text{true}$。\n因此，一个等待中的进程 $P_i$ 最多只能被 $P_j$ 超越一次。有界等待得到保证。\n\n### 在没有顺序一致性的架构上的分析\n\n在许多现代多核处理器上，内存一致性模型比 SC “更弱”。这意味着硬件为了性能可以重排序内存操作，例如，一个写操作后跟一个对不同位置的读操作，可能不会以程序顺序对其他处理器可见。Peterson 算法（及其此变体）依赖于 SC 提供的严格排序。例如，进程 $P_i$ 执行 $flag[i] \\leftarrow \\text{true}$，然后读取 $flag[j]$。在弱内存模型上，对 $flag[j]$ 的读取可能会在对 $flag[i]$ 的写入对 $P_j$ 可见之前执行。这可能导致 $P_0$ 和 $P_1$ 都读取到对方的标志为 $\\text{false}$，然后继续进入它们的临界区，从而违反互斥性。为了防止这种情况，需要使用内存栅栏（或屏障指令）来强制执行必要的排序。此变体中的条件更新不充当内存栅栏，也不能纠正这个根本性问题。\n\n### 评估选项\n\n**A. 与教科书中的 Peterson 解法相比，此变体在没有竞争时（即 `$flag[j] = \\text{false}$` 时）减少了对 `turn` 的写入，并且在具有原子读/写的 SC 模型下，它仍然保证互斥、前进和有界等待。**\n这个陈述是正确的。条件写入 `if ($flag[j]$)` 明确地避免了在无竞争情况下对 $turn$ 的写入，这是一种优化。如上面的详细分析所示，在 SC 模型下，所有三个正确性属性（互斥、前进和有界等待）都得以保留，因为在竞争情况（唯一困难的情况）下，该算法的逻辑与教科书中的 Peterson 解法变得相同。\n**结论：正确。**\n\n**B. 该变体可能违反互斥：如果两个进程在条件更新时都观察到 `$flag[j] = \\text{false}$`，那么它们都可能进入临界区，因为 `turn` 可能保留一个过时的值。**\n这个陈述是不正确的。“两个进程都观察到 `$flag[j] = \\text{false}$`” 的前提在 SC 模型下是不可能的。要让 $P_0$ 观察到 $flag[1]=\\text{false}$，它的读取必须在 $P_1$ 写入 $flag[1]$ 之前发生。要让 $P_1$ 观察到 $flag[0]=\\text{false}$，它的读取必须在 $P_0$ 写入 $flag[0]$ 之前发生。然而，每个进程在读取对方的标志*之前*都会写入自己的标志。这在 SC 模型所要求的操作总序中导致了逻辑矛盾。因此，这个前提是有缺陷的，互斥性不会以这种方式被违反。\n**结论：不正确。**\n\n**C. 该变体可能发生死锁：如果两个进程都不更新 `turn`（因为每个进程都观察到 `$flag[j] = \\text{false}$`），它们都会在 `turn` 不变的情况下永远忙等待。**\n这个陈述是不正确的。首先，如选项 B 所述，两个进程都观察到 `$flag[j] = \\text{false}$` 的前提在 SC 模型下是不可能的。其次，如果一个进程 $i$ 确实观察到 `$flag[j] = \\text{false}$`，其忙等待条件的第一部分 `($flag[j] \\land \\dots)` 将为 $\\text{false}$，它根本不会忙等待；它将直接进入临界区。该陈述在逻辑上不一致。\n**结论：不正确。**\n\n**D. 该变体在 SC 模型下保持了互斥和前进，但可能违反有界等待；一个进程可能会饿死，而另一个进程则重复地重新进入。**\n这个陈述是不正确的。它正确地指出了互斥和前进性得到了保持，但错误地声称有界等待被违反了。如分析所示，在 Peterson 解法中确保有界等待的机制仍然完整。一个进程 $j$ 在 $i$ 等待时试图重新进入 CS，会被迫设置 $turn \\leftarrow i$，这保证了 $i$ 将获得下一次机会。\n**结论：不正确。**\n\n**E. 在没有 SC 的架构上，并且在缺少适当的内存排序原语（如内存栅栏）的情况下，教科书中的 Peterson 解法和此变体都可能失败；条件更新不能纠正弱内存模型下的重排序问题。**\n这个陈述是正确的。一个众所周知的事实是，像 Peterson 这样的纯软件互斥算法在具有弱内存模型的处理器上是不正确的，除非使用显式的内存栅栏来对关键内存操作强制执行程序顺序。此变体中的修改（一个条件写入）是一个控制流的改变，而不是一个内存排序原语。它不能防止有害的重排序，因此不能修复该算法在此类架构上的脆弱性。原始算法和此变体都会以相同的方式失败。\n**结论：正确。**", "answer": "$$\\boxed{AE}$$", "id": "3669493"}, {"introduction": "让我们探索另一种设计变体。如果作为决胜关键的$turn$变量，只在进程*退出*临界区时更新，而不是在尝试进入时更新，算法的行为会发生什么变化？这个练习[@problem_id:3669502]旨在挑战你分析这种改变对算法公平性（如“有界等待”）以及进程访问临界区模式的影响。", "problem": "考虑一个系统，其中有两个并发进程 $P_0$ 和 $P_1$，它们使用一种类似于 Peterson 解法的修改版双进程协议来协调对共享临界区 (CS) 的访问。共享变量为 $flag[0]$、$flag[1]$（布尔值，初始为 $false$）和一个 $turn \\in \\{0,1\\}$（初始值任意但固定）。每个进程 $P_i$ 遵循一个进入协议，该协议设置 $flag[i] := true$，然后在一个断言 $(flag[j] \\land turn = j)$ 上进行忙等待，其中 $j = 1 - i$。退出协议设置 $flag[i] := false$ 并通过赋值 $turn := 1 - turn$ 来切换共享变量 $turn$ 的值（在进入协议期间不会对 $turn$ 进行赋值）。所有对共享变量的读写操作都假定是原子的，并遵循顺序一致性。互斥意味着在任何时候两个进程都不会同时处于临界区中。在此上下文中，公平性指的是有界等待 (Bounded Waiting, BW) 属性：如果 $P_i$ 设置 $flag[i] := true$，那么在 $P_i$ 最终进入临界区之前，$P_j$ 可以进入临界区的次数存在一个有限的界限；先到先服务 (First-Come-First-Served, FCFS) 更强，它要求在到达时间没有重叠的情况下，到达顺序决定服务顺序。\n\n基于上述基本定义和所述的内存假设，以下哪个陈述最能描述此变体的互斥和公平性属性？\n\nA. 互斥性得以保持。有界等待成立，并且在 $flag[0] = flag[1] = true$ 的持续竞争条件下，该协议强制对临界区的访问进行严格交替，但它不保证在所有到达模式下的先到先服务。\n\nB. 互斥性得以保持，但有界等待失败：一个进程可能饿死，而另一个进程可以任意多次进入临界区。\n\nC. 互斥性被违反：当两个进程并发地设置 $flag[i] := true$ 时，它们都可能同时进入临界区，因为对 $turn$ 的切换只在退出时发生。\n\nD. 互斥性得以保持，但公平性比原始的 Peterson 解法更差：在两个进程持续竞争时，一个进程在进入临界区前可能被超越不止一次。", "solution": "该问题陈述已经过验证，被认为是操作系统和并发领域中一个定义良好、有科学依据的问题。\n\n对于进程 $P_i$（其中 $i \\in \\{0,1\\}$ 且 $j = 1 - i$），协议如下：\n\n共享变量：\n- $flag[0], flag[1]$：布尔型，初始化为 $false$。\n- $turn$：整数 $\\in \\{0,1\\}$，初始化为一个任意但固定的值。\n\n$P_i$ 的进入协议：\n```\nflag[i] := true;\nwhile (flag[j] \\land turn = j) {\n    // busy wait\n}\n```\n\n$P_i$ 的临界区 (CS)：\n```\n// Critical Section code\n```\n\n$P_i$ 的退出协议：\n```\nflag[i] := false;\nturn := 1 - turn;\n```\n\n我们现在来分析此协议的属性。\n\n### 1. 互斥性\n\n为了证明互斥性，我们将使用反证法。假设进程 $P_0$ 和 $P_1$ 同时处于各自的临界区中。\n\n如果 $P_0$ 在其临界区内，它必须已经执行了其进入协议，并发现其 `while` 循环的条件为 $false$。$P_0$ 的条件是 `$flag[1] \\land turn = 1$`。为了让 $P_0$ 进入临界区，在其最终检查时，`$\\neg(flag[1] \\land turn = 1)$` 必定为真。\n\n类似地，如果 $P_1$ 在其临界区内，它必须发现其 `while` 循环的条件 `$flag[0] \\land turn = 0$` 为 $false$。为了让 $P_1$ 进入临界区，在其最终检查时，`$\\neg(flag[0] \\land turn = 0)$` 必定为真。\n\n当两个进程都在临界区内时，它们必须都已事先将各自的标志位设置为 $true$。因此，在同时占用临界区的那一刻，$flag[0] = \\text{true}$ 且 $flag[1] = \\text{true}$。\n\n让我们在这种状态下（$flag[0] = \\text{true}$ 且 $flag[1] = \\text{true}$）重新审视循环条件：\n- 为了让 $P_0$ 进入，其条件 `$(flag[1] \\land turn = 1)$` 必须为 $false$。因为 $flag[1]$ 为 $true$，这意味着 `$turn = 1$` 必须为 $\\text{false}$。因此，$P_0$ 必须观察到 $turn = 0$。\n- 为了让 $P_1$ 进入，其条件 `$(flag[0] \\land turn = 0)$` 必须为 $false$。因为 $flag[0]$ 为 $true$，这意味着 `$turn = 0$` 必须为 $\\text{false}$。因此，$P_1$ 必须观察到 $turn = 1$。\n\n为了让两个进程都进入临界区，共享变量 $turn$ 需要在同一时间既等于 $0$（以便 $P_0$ 继续）又等于 $1$（以便 $P_1$ 继续）。由于 $turn$ 在任何给定时刻只能持有一个值，这是一个矛盾。\n\n因此，两个进程不能同时处于临界区中。**互斥性得以保持。**\n\n### 2. 公平性（有界等待和交替）\n\n有界等待要求，如果一个进程 $P_i$ 表示希望进入临界区（通过设置 $flag[i] := true$），那么在 $P_i$ 被授予访问权限之前，另一个进程 $P_j$ 进入临界区的次数存在一个有限的界限。\n\n让我们考虑进程 $P_0$ 正在等待进入临界区。要使 $P_0$ 卡在它的 `while` 循环中，条件 `$flag[1] \\land turn = 1$` 必须为真。这意味着：\n1.  $flag[1] = true$：$P_1$ 要么在其临界区内，要么也在等待进入。\n2.  $turn = 1$：$turn$ 的值为1，这使得 $P_0$ 等待（因为 $P_0$ 的等待条件是 $turn=1$）。这意味着 $P_1$ 可以进入，因为它的等待条件 `$(flag[0] \\land turn=0)$` 由于 $turn \\neq 0$ 而为假。\n\n所以，如果 $P_0$ 正在等待，那么 $P_1$ 可能在其临界区内。让我们看看当 $P_1$ 退出其临界区时会发生什么。\n$P_1$ 执行其退出协议：\n1.  $flag[1] := false$。仅此操作就使 $P_0$ 的等待条件 `$(flag[1] \\land turn = 1)$` 变为 $false$，从而允许 $P_0$ 继续执行。\n2.  $turn := 1 - turn$。由于 $P_0$ 正在等待，我们知道 $turn$ 的值是 $1$。所以 $P_1$ 将设置 $turn := 1 - 1 = 0$。这也使得 $P_0$ 的等待条件为假。\n\n在 $P_1$ 退出临界区后，$P_0$ 保证能够进入。$P_1$ 无法在 $P_0$ 之前重新进入临界区，因为在退出时，$P_1$ 通过设置 $flag[1]:=false$ 放弃了其声明，并且还以一种解放 $P_0$ 的方式更改了 $turn$。为了让 $P_1$ 重新进入，它必须再次设置 $flag[1]:=true$，但到那时 $P_0$ 已经通过了其等待条件。\n\n因此，如果 $P_0$ 正在等待，$P_1$ 在 $P_0$ 保证进入之前最多只能进入临界区一次。这被称为 $1$ 有界等待。**有界等待得以保持。**\n\n此外，在 $flag[0]$ 和 $flag[1]$ 持续为 $true$ 的持续竞争条件下，退出部分的 `turn := 1 - turn` 语句强制实行严格交替。如果 $P_0$ 进入，`turn` 必须为 $0$。退出时，它将 `turn` 设置为 $1$。现在 $P_1$ 可以进入，而 $P_0$ 必须等待。当 $P_1$ 退出时，它将 `turn` 设置为 $0$，从而允许 $P_0$ 接下来进入。\n\n### 3. 先到先服务 (FCFS)\n\nFCFS 意味着如果 $P_i$ 比 $P_j$ 先到达（即先设置 $flag[i] := true$），那么 $P_i$ 应该在 $P_j$ 之前进入临界区。让我们用一个反例来测试这一点。\n\n假设初始状态为 $flag[0] = false$，$flag[1] = false$，且 $turn = 0$。\n考虑以下事件序列：\n1.  $P_1$ “到达”并执行 `flag[1] := true`。\n2.  在 $P_1$ 检查其 `while` 条件之前发生上下文切换。\n3.  $P_0$ 运行并执行其进入协议：`flag[0] := true`。\n4.  现在的状态是：$flag[0] = true$，$flag[1] = true$，$turn = 0$。\n5.  $P_0$ 检查其等待条件：`$(flag[1] \\land turn = 1)$`。该表达式求值为 `$(true \\land 0 = 1)$`，结果为 $false$。$P_0$ 进入临界区。\n6.  发生上下文切换。$P_1$ 恢复执行并检查其等待条件：`$(flag[0] \\land turn = 0)$`。该表达式求值为 `$(true \\land 0 = 0)$`，结果为 $true$。$P_1$ 必须等待。\n\n在这种情况下，$P_1$ 先设置了它的标志位，表示它先到达。然而，由于 $turn$ 的初始值和指令的交错执行，$P_0$ 先进入了临界区。因此，该协议**不保证先到先服务**。\n\n### 选项评估\n\n**A. 互斥性得以保持。有界等待成立，并且在 $flag[0] = flag[1] = true$ 的持续竞争条件下，该协议强制对临界区的访问进行严格交替，但它不保证在所有到达模式下的先到先服务。**\n- `互斥性得以保持。` - 这是**正确的**，如我们的分析所示。\n- `有界等待成立` - 这是**正确的**。等待是 $1$ 有界的。\n- `...强制实行严格交替...` - 这是**正确的**，因为 `turn` 变量在每次退出时都会切换。\n- `...不保证先到先服务...` - 这是**正确的**，如反例所示。\n这个陈述准确而全面地描述了该协议的属性。\n\n**B. 互斥性得以保持，但有界等待失败：一个进程可能饿死，而另一个进程可以任意多次进入临界区。**\n- 这是**不正确的**。如分析所示，有界等待成立。一个等待中的进程在另一个进程最多退出一次后保证可以进入。饿死是不可能的。\n\n**C. 互斥性被违反：当两个进程并发地设置 $flag[i] := true$ 时，它们都可能同时进入临界区，因为对 $turn$ 的切换只在退出时发生。**\n- 这是**不正确的**。`turn` 变量，尽管在进入阶段是静态的，但足以充当决胜者，确保在两个标志位都升起时只有一个进程能通过其 `while` 循环。互斥性得以保持。\n\n**D. 互斥性得以保持，但公平性比原始的 Peterson 解法更差：在两个进程持续竞争时，一个进程在进入临界区前可能被超越不止一次。**\n- 这是**不正确的**。分析表明，一个进程最多被“超越”一次，导致 $1$ 有界等待。原始的 Peterson 解法也表现出 $1$ 有界等待。因此，在有界等待方面，公平性属性并没有更差，而是等效的。\n\n**结论：**\n选项 A 是唯一正确且完整地描述了给定同步协议行为的陈述。", "answer": "$$\\boxed{A}$$", "id": "3669502"}]}