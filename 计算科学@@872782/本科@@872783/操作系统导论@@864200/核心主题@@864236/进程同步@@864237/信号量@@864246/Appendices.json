{"hands_on_practices": [{"introduction": "在编写复杂的并发代码之前，深刻理解信号量的核心不变量至关重要。这个练习 [@problem_id:3681948] 就像一场并发世界的侦探工作，要求你从一个记录了 $P$ 和 $V$ 操作的日志中，反向推导出信号量所需的最小初始容量。通过追踪资源获取和释放的净变化，你将能够精确计算出系统在任何时刻并发持有的最大资源数，从而掌握信号量计数的根本意义。", "problem": "计数信号量是一种具有整数状态的抽象数据类型。设 $S$ 为一个计数信号量，用于保护对一个相同资源池的访问。信号量 $S$ 被初始化为一个未知的非负整数 $k$，$k$ 等于最初可用的资源单元数量。操作 $P(S)$（也称为 wait 或 down）尝试获取一个单元：它仅在至少有一个单元可用时才能完成，此时 $S$ 的内部状态减 1；否则，调用者将阻塞，该操作直到未来的某个 $V(S)$ 操作增加了可用性后才能完成。操作 $V(S)$（也称为 signal 或 up）释放一个单元，并将 $S$ 的内部状态加 1，这可能允许一个阻塞的 $P(S)$ 操作完成。假设没有所有权要求：任何线程都可以调用 $V(S)$。\n\n给定一个由 6 个线程 $\\{A,B,C,D,E,F\\}$ 在 $S$ 上执行操作的完成轨迹。该轨迹按全局实时顺序列出了每个 $P(S)$ 或 $V(S)$ 操作完成的顺序。由于该轨迹只记录完成（而非尝试），一个本会阻塞的 $P(S)$ 操作在其可以出现之前，必须有足够的 $V(S)$ 操作完成以提供可用单元。\n\n观察到的完成轨迹是以下线程-操作对的有序序列：\n$(A,P)$, $(B,P)$, $(C,P)$, $(B,V)$, $(D,P)$, $(E,P)$, $(C,V)$, $(F,P)$, $(A,V)$, $(D,V)$, $(B,P)$, $(E,V)$, $(F,V)$, $(C,P)$, $(B,V)$, $(A,P)$, $(A,V)$, $(C,V)$, $(D,P)$, $(D,V)$.\n\n在上述标准计数信号量语义下，确定能使此轨迹合法的最小整数 $k$，合法意味着轨迹中没有一个已完成的 $P(S)$ 操作是在没有可用单元时完成的。请以单个整数（无单位）的形式提供您的答案。如果需要四舍五入，您会被指示四舍五入到指定的有效数字位数；然而，在本题中，需要的是精确整数。", "solution": "问题要求找出信号量初始计数的最小非负整数值 $k$，使得给定的已完成信号量操作轨迹是合法的。\n\n令轨迹中第 $t$ 个操作完成后的计数信号量 $S$ 的状态表示为 $S_t$。信号量的初始状态为 $S_0 = k$，其中 $k$ 是一个非负整数，表示初始可用资源的数量。\n\n信号量操作的标准语义如下：\n1.  第 $t$ 步的一个 $P(S)$ 操作（wait）仅当操作前信号量的值 $S_{t-1}$ 大于 0 时才能完成。由于信号量的值是整数，这等价于 $S_{t-1} \\ge 1$。操作完成后，信号量的值减一：$S_t = S_{t-1} - 1$。\n2.  第 $t$ 步的一个 $V(S)$ 操作（signal）无条件完成，并使信号量的值加一：$S_t = S_{t-1} + 1$。\n\n这些规则的一个直接推论是，信号量的内部状态必须始终为非负数。对于 $P$ 操作，如果 $S_{t-1} \\ge 1$，那么操作后 $S_t = S_{t-1} - 1 \\ge 0$。对于 $V$ 操作，如果 $S_{t-1} \\ge 0$，那么 $S_t = S_{t-1} + 1 \\ge 1$。由于初始状态 $k$ 是非负的，所以对于所有 $t \\ge 0$，信号量的值 $S_t$ 必须保持非负。\n\n为了分析该轨迹，我们可以定义一个函数 $C_t$，表示经过 $t$ 次操作后获取的资源净数量。这是截至第 $t$ 步已完成的 $P$ 操作总数减去已完成的 $V$ 操作总数。设 $P_t$ 和 $V_t$ 分别是轨迹前 $t$ 步中 $P$ 和 $V$ 操作的累积计数。那么，$C_t = P_t - V_t$。\n\n$t$ 次操作后信号量的值可以用其初始值 $k$ 和净获取量 $C_t$ 来表示：\n$$S_t = S_0 - (P_t - V_t) = k - C_t$$\n\n为了使轨迹合法，对于所有步骤 $t=1, \\dots, 20$，必须满足从信号量语义派生出的两个条件：\n1.  信号量的值绝不能为负：$S_t \\ge 0$。这意味着 $k - C_t \\ge 0$，即对于所有的 $t \\in \\{1, \\dots, 20\\}$，都有 $k \\ge C_t$。\n2.  对于任何是 $P$ 操作的步骤 $t$，操作前的值必须至少为 1：$S_{t-1} \\ge 1$。这意味着 $k - C_{t-1} \\ge 1$，即 $k \\ge 1 + C_{t-1}$。\n\n让我们分析一下这两个条件之间的关系。对于第 $t$ 步的任何 $P$ 操作，我们有 $C_t = C_{t-1} + 1$。第二个条件 $k \\ge 1 + C_{t-1}$ 可以重写为 $k \\ge C_t$。这意味着在第 $t$ 步进行 $P$ 操作的条件等价于要求 $k \\ge C_t$，其中 $C_t$ 是 $P$ 操作*之后*的净获取计数。\n\n对于第 $t$ 步的任何 $V$ 操作，我们有 $C_t = C_{t-1} - 1$。第一个条件 $k \\ge C_t$ 比 $k \\ge C_{t-1}$ 更宽松（而 $k \\ge C_{t-1}$ 必须成立，因为 $t-1$ 是轨迹中的一个有效步骤）。因此，对 $k$ 的关键约束来自于确保对所有 $t$ 都有 $S_t \\ge 0$。并发持有的资源的最大数量不得超过初始资源数量 $k$。\n\n综合以上分析，整个轨迹合法的唯一充要条件是，$k$ 必须在每一步 $t$ 都大于或等于净获取计数 $C_t$。为了找到最小的可能整数 $k$，我们必须找出 $C_t$ 在整个轨迹中达到的最大值。\n$$k_{min} = \\max_{t \\in \\{0, 1, \\dots, 20\\}} C_t$$\n\n我们现在计算给定轨迹中每一步的 $C_t$ 值。设 $C_0 = 0$。\n\n- $t=1: (A,P) \\implies C_1 = C_0 + 1 = 1$\n- $t=2: (B,P) \\implies C_2 = C_1 + 1 = 2$\n- $t=3: (C,P) \\implies C_3 = C_2 + 1 = 3$\n- $t=4: (B,V) \\implies C_4 = C_3 - 1 = 2$\n- $t=5: (D,P) \\implies C_5 = C_4 + 1 = 3$\n- $t=6: (E,P) \\implies C_6 = C_5 + 1 = 4$\n- $t=7: (C,V) \\implies C_7 = C_6 - 1 = 3$\n- $t=8: (F,P) \\implies C_8 = C_7 + 1 = 4$\n- $t=9: (A,V) \\implies C_9 = C_8 - 1 = 3$\n- $t=10: (D,V) \\implies C_{10} = C_9 - 1 = 2$\n- $t=11: (B,P) \\implies C_{11} = C_{10} + 1 = 3$\n- $t=12: (E,V) \\implies C_{12} = C_{11} - 1 = 2$\n- $t=13: (F,V) \\implies C_{13} = C_{12} - 1 = 1$\n- $t=14: (C,P) \\implies C_{14} = C_{13} + 1 = 2$\n- $t=15: (B,V) \\implies C_{15} = C_{14} - 1 = 1$\n- $t=16: (A,P) \\implies C_{16} = C_{15} + 1 = 2$\n- $t=17: (A,V) \\implies C_{17} = C_{16} - 1 = 1$\n- $t=18: (C,V) \\implies C_{18} = C_{17} - 1 = 0$\n- $t=19: (D,P) \\implies C_{19} = C_{18} + 1 = 1$\n- $t=20: (D,V) \\implies C_{20} = C_{19} - 1 = 0$\n\n对于 $t \\in \\{1, \\dots, 20\\}$，$C_t$ 的值序列为：\n$\\{1, 2, 3, 2, 3, 4, 3, 4, 3, 2, 3, 2, 1, 2, 1, 2, 1, 0, 1, 0\\}$。\n\n此序列中的最大值为：\n$$\\max(C_t) = 4$$\n这个最大值在轨迹中的两个点达到：在第 $6$ 个操作 $(E,P)$ 之后和第 $8$ 个操作 $(F,P)$ 之后。\n\n为了使轨迹合法，$k$ 必须至少等于这个最大值。因此，$k \\ge 4$。$k$ 的最小整数值是 $4$。\n\n为了验证，如果我们选择 $k=3$，轨迹将是非法的。在步骤 $t=6$ 时，操作是 $(E,P)$。此操作前的状态将是 $S_5 = k - C_5 = 3 - 3 = 0$。如果信号量的值为 0，则 $P$ 操作无法完成，因为它要求值至少为 1。因此，$k=3$ 不是一个有效的初始值。\n\n如果我们选择 $k=4$，第 $6$ 个操作前的状态是 $S_5 = k - C_5 = 4 - 3 = 1$。这是一个允许 $P$ 操作完成的有效状态。操作后，状态变为 $S_6 = S_5 - 1 = 0$，这是非负的。对所有 $P$ 操作的检查证实，$k=4$ 使整个轨迹合法。\n\n因此，使该轨迹合法的最小非负整数 $k$ 是 4。", "answer": "$$\\boxed{4}$$", "id": "3681948"}, {"introduction": "当系统中存在多个信号量（或锁）时，死锁便成为最臭名昭著的陷阱。这个练习 [@problem_id:3681944] 将你置于系统调试者的角色，面对一个包含多个线程和信号量的场景。你的任务是逐个时间步地追踪系统状态，分析资源持有和等待的依赖关系链，最终精确定位出形成循环等待、导致系统陷入僵局的确切时刻。", "problem": "考虑一个系统，它有两个计数信号量 $S$ 和 $T$，每个都初始化为整数值 $1$。所有信号量操作都遵循规范定义：“等待”操作 $P(X)$ 在 $X$ 的值严格大于 $0$ 时将其递减；否则，调用线程将被阻塞并进入 $X$ 的等待队列。“信号”操作 $V(X)$ 在没有线程等待时将 $X$ 递增；否则，一个等待的线程将出队并完成其挂起的 $P(X)$ 操作，使信号量的整数值保持在 $0$ 不变。队列使用先进先出 (FIFO) 规则。被阻塞的线程在被其等待的信号量上相应的 $V$ 操作解除阻塞之前，无法执行进一步的操作。所有 $P$ 和 $V$ 操作在其时间戳上的执行时间均可忽略不计。不存在对已持有信号量的抢占。\n\n三个线程 $T_1$、$T_2$ 和 $T_3$ 在给定的时间戳（以毫秒为单位）执行以下操作：\n- 在 $t = 0\\,\\mathrm{ms}$ 时，线程 $T_1$ 调用 $P(S)$。\n- 在 $t = 1\\,\\mathrm{ms}$ 时，线程 $T_2$ 调用 $P(T)$。\n- 在 $t = 2\\,\\mathrm{ms}$ 时，线程 $T_3$ 调用 $P(S)$。\n- 在 $t = 3\\,\\mathrm{ms}$ 时，线程 $T_1$ 调用 $P(T)$。\n- 在 $t = 4\\,\\mathrm{ms}$ 时，线程 $T_2$ 调用 $P(S)$。\n\n在 $t = 4\\,\\mathrm{ms}$ 之后没有进一步的 $P$ 或 $V$ 操作发生。仅使用计数信号量 $P$ 和 $V$ 的基本定义以及标准的死锁条件，重构在每个列出的时间戳下 $S$ 和 $T$ 的可能值及其等待队列的成员情况。然后，根据上述日志和给定的语义，确定该系统中可能出现真正死锁的最早时间戳 $t^\\star$（以毫秒为单位）。\n\n请用一个以毫秒为单位的数值时间戳表示你的最终答案。不要四舍五入；报告精确值。", "solution": "我们将在每个指定的时间戳跟踪系统的状态。状态由信号量 $S$ 和 $T$ 的整数值、它们各自的等待队列（我们将其表示为 $Q_S$ 和 $Q_T$）以及每个线程（$T_1, T_2, T_3$）的状态定义。\n\n**初始状态（$t = 0\\,\\mathrm{ms}$ 之前）：**\n- 信号量值：$S = 1$，$T = 1$。\n- 等待队列：$Q_S = []$，$Q_T = []$（均为空）。\n- 线程状态：$T_1$、$T_2$、$T_3$ 处于就绪状态。\n\n**在 $t = 0\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_1$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $1$，大于 $0$。操作成功。$S$ 被递减。$T_1$ 不阻塞并继续执行。在信号量逻辑的上下文中，$T_1$ 现在“持有”由 $S$ 代表的一个资源单位。\n- **$t = 0\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = []$\n  - $T = 1$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：就绪\n  - $T_3$：就绪\n\n**在 $t = 1\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_2$ 调用 $P(T)$。\n- **分析：** $T$ 的值为 $1$，大于 $0$。操作成功。$T$ 被递减。$T_2$ 不阻塞并继续执行。$T_2$ 现在“持有”由 $T$ 代表的一个资源单位。\n- **$t = 1\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = []$\n  - $T = 0$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：运行中\n  - $T_3$：就绪\n\n**在 $t = 2\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_3$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $0$。操作无法完成。线程 $T_3$ 被阻塞并添加到 $S$ 的等待队列中。$S$ 的值保持为 $0$。\n- **$t = 2\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = []$\n  - $T_1$：运行中\n  - $T_2$：运行中\n  - $T_3$：在 $S$ 上阻塞\n\n**在 $t = 3\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_1$ 调用 $P(T)$。\n- **分析：** $T$ 的值为 $0$。操作无法完成。线程 $T_1$ 被阻塞并添加到 $T$ 的等待队列中。$T$ 的值保持为 $0$。\n- **$t = 3\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$：在 $T$ 上阻塞\n  - $T_2$：运行中\n  - $T_3$：在 $S$ 上阻塞\n- **死锁检查：** 此时，$T_1$ 持有资源 $S$ 并等待资源 $T$。$T_3$ 等待资源 $S$。然而，$T_2$ 持有资源 $T$ 并且仍处于运行状态。因为 $T_2$ 没有被阻塞，理论上它可以执行一个 $V(S)$ 或 $V(T)$ 操作，这将打破依赖关系。因此，系统尚未处于死锁状态。\n\n**在 $t = 4\\,\\mathrm{ms}$ 时：**\n- **操作：** 线程 $T_2$ 调用 $P(S)$。\n- **分析：** $S$ 的值为 $0$。操作无法完成。线程 $T_2$ 被阻塞并添加到 $S$ 的等待队列中。由于队列是先进先出（FIFO）的，$T_2$ 被放置在 $T_3$ 之后。$S$ 的值保持为 $0$。\n- **$t = 4\\,\\mathrm{ms}$ 后的状态：**\n  - $S = 0$, $Q_S = [T_3, T_2]$\n  - $T = 0$, $Q_T = [T_1]$\n  - $T_1$：在 $T$ 上阻塞\n  - $T_2$：在 $S$ 上阻塞\n  - $T_3$：在 $S$ 上阻塞\n\n**在 $t^\\star = 4\\,\\mathrm{ms}$ 时的死锁分析：**\n如果满足以下四个必要条件，则发生死锁：\n1.  **互斥：** 这是使用初始化为 $1$ 的信号量来保护资源的内在属性。多个线程不能并发地将信号量的值减到 $0$ 以下。\n2.  **持有并等待：**\n    - $T_1$ 成功完成了 $P(S)$，因此它“持有”$S$。它现在被阻塞以等待 $T$。\n    - $T_2$ 成功完成了 $P(T)$，因此它“持有”$T$。它现在被阻塞以等待 $S$。\n    此条件已满足。\n3.  **不可抢占：** 问题指明资源（信号量的“单位”）不能被强行从线程中夺走。线程必须通过 $V$ 操作自愿释放资源。此条件成立。\n4.  **循环等待：** 这是在 $t = 4\\,\\mathrm{ms}$ 时出现的关键条件。我们可以将依赖关系可视化：\n    - 线程 $T_1$ 正在等待资源 $T$（请求边 $T_1 \\rightarrow T$）。\n    - 资源 $T$ 由线程 $T_2$ 持有（持有边 $T \\rightarrow T_2$）。\n    - 线程 $T_2$ 正在等待资源 $S$（请求边 $T_2 \\rightarrow S$）。\n    - 资源 $S$ 由线程 $T_1$ 持有（持有边 $S \\rightarrow T_1$）。\n    这形成了一个循环：$T_1 \\rightarrow T \\rightarrow T_2 \\rightarrow S \\rightarrow T_1$。\n\n在 $t = 4\\,\\mathrm{ms}$ 时，$T_2$ 调用 $P(S)$ 的操作导致 $T_2$ 阻塞，从而完成了循环等待条件。在这一瞬间，所有持有必要资源（$T_1$ 和 $T_2$）的线程本身也都被阻塞了。没有线程处于运行状态，并且由于没有安排进一步的 $V$ 操作，没有线程能被解除阻塞。系统处于一个真正的、不可恢复的死锁状态。\n\n这种死锁状态出现的最早时间戳，恰好是形成不可解决的循环等待所需的最后一个依赖关系建立的时刻。这发生在 $t = 4\\,\\mathrm{ms}$ 时，$T_2$ 在 $S$ 上阻塞。因此，$t^\\star = 4\\,\\mathrm{ms}$。", "answer": "$$\\boxed{4}$$", "id": "3681944"}, {"introduction": "从理论分析转向动手创造，这项压轴实践将让你构建一个完整的并发系统模型。在这个练习 [@problem_id:3681933] 中，你将实现一个点对点文件共享系统的离散时间模拟。你需要使用一个计数信号量来管理有限的上传“插槽”，并实现一个带有“老化”机制的优先级调度策略，从而将信号量的理论知识转化为可以运行和验证的实际代码。", "problem": "考虑一个由计数信号量协调的点对点文件共享的离散时间模拟。系统中存在 $n$ 个对等点，索引为 $i \\in \\{0,1,\\dots,n-1\\}$，以及一个固定数量的上传槽位 $k$ 代表并发容量。时间以单位节拍 $t = 0,1,2,\\dots$ 向前推进。每个对等点 $i$ 都有一个到达时间 $A_i \\in \\mathbb{Z}_{\\ge 0}$、一个上传持续时间 $D_i \\in \\mathbb{Z}_{0}$ 和一个初始的“一报还一报”信用值 $C_i \\in \\mathbb{R}_{\\ge 0}$。当 $t \\ge A_i$ 且对等点尚未开始上传时，它在时间 $t$ 变为等待状态。等待中的对等点会累积等待时间 $W_i(t)$，定义为其连续等待而未开始的节拍数，并可能在有槽位变为空闲时开始上传。一个内部值为 $S(t)$ 的计数信号量强制执行一个不变性，即并发运行的上传数量永远不超过 $k$，并且一个等待中的对等点只有在 $S(t)  0$ 时才能开始，之后信号量立即减 1（“等待”操作）。当一个正在运行的上传完成时，信号量加 1（“信号”操作）。\n\n调度器必须实现一个带有通过老化机制避免饿死的“一报还一报”优先级策略：在时间 $t$ 的所有等待中对等点中，它选择最多 $k - R(t)$ 个对等点开始上传，其中 $R(t)$ 是当前正在运行的上传数量，选择那些具有最大优先级的对等点 $$P_i(t) = C_i + \\alpha \\cdot W_i(t),$$ 其中 $\\alpha \\in \\mathbb{R}_{0}$ 是一个固定的老化权重。$P_i(t)$ 的平局必须通过最小的对等点索引来确定性地打破。一旦一个对等点在时间 $t$ 开始，它将精确运行 $D_i$ 个节拍然后完成，释放其槽位。在模拟中，每个对等点只执行一次上传。\n\n从计数信号量通过原子性的“等待”和“信号”操作来维护对 $k$ 个相同资源的安全访问这一基本定义出发，设计并实现一个单线程确定性程序来模拟此过程并产生可量化的输出。您的程序必须为每个测试用例计算：\n- 一个布尔值，表示为整数 $0$ 或 $1$，指示是否有任何对等点饿死；这里的饿死定义为对等点在模拟完成前从未开始的事件。在正确的老化机制下，如果所有对等点最终都开始了上传，则此值应为 $1$（表示没有饿死发生）。\n- 平均等待时间 $\\overline{W} = \\frac{1}{n}\\sum_{i=0}^{n-1}(S_i - A_i)$，其中 $S_i$ 是对等点 $i$ 的开始时间，作为一个浮点值打印，并精确到六位小数。\n- 开始顺序列表，包含对等点索引的精确开始顺序（如果在同一节拍有多个对等点开始，它们之间的顺序必须遵守按最小索引打破平局的规则）。\n\n使用以下明确给出参数的测试套件：\n\n测试用例 1（具有多个槽位的理想路径）：\n- $k = 2$\n- $n = 4$\n- 到达时间 $[0, 0, 1, 2]$\n- 持续时间 $[3, 2, 1, 2]$\n- 初始信用值 $[5, 3, 1, 4]$\n- 老化权重 $\\alpha = 0.5$\n\n测试用例 2（单个槽位和极端信用值偏差的边界情况）：\n- $k = 1$\n- $n = 3$\n- 到达时间 $[0, 0, 0]$\n- 持续时间 $[3, 3, 3]$\n- 初始信用值 $[100, 0, 0]$\n- 老化权重 $\\alpha = 1.0$\n\n测试用例 3（同时到达、不同持续时间和一个高信用值对等点的边缘情况）：\n- $k = 3$\n- $n = 5$\n- 到达时间 $[0, 0, 0, 0, 0]$\n- 持续时间 $[1, 2, 3, 4, 5]$\n- 初始信用值 $[0, 0, 10, 0, 0]$\n- 老化权重 $\\alpha = 0.1$\n\n最终输出格式要求：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个测试用例的结果本身就是一个形式为 $[\\,\\text{no\\_starvation},\\ \\overline{W},\\ [\\text{start\\_order}]\\,]$ 的列表。因此，对于上述三个测试用例，输出必须是 `\"[ [ns1,avg1,[o1,...]], [ns2,avg2,[o2,...]], [ns3,avg3,[o3,...]] ]\"` 的形式，但不含任何空格，如 `[[ns1,avg1,[o1,...]],[ns2,avg2,[o2,...]],[ns3,avg3,[o3,...]]]`。", "solution": "该模拟将作为一个离散时间过程来实现，以节拍 $t=0, 1, 2, \\dots$ 推进。只要不是所有对等点都已完成上传，模拟循环就会继续。\n\n**状态表示：**\n在整个模拟过程中，会维护每个对等点 $i$ 的状态，跟踪以下信息：\n- `status`：对等点的当前状态，可以是 `NOT_ARRIVED`（未到达）、`WAITING`（等待中）、`RUNNING`（运行中）或 `COMPLETED`（已完成）。\n- `wait_ticks`：一个用于 $W_i(t)$ 的计数器，表示对等点处于 `WAITING` 状态的节拍数。\n- `start_time`：对等点开始上传的时间节拍 $t$。\n- `completion_time`：对等点上传将完成的时间节拍，计算为 $S_i + D_i$。\n\n**模拟循环算法：**\n模拟通过迭代时间 $t$ 来进行。在每个节拍中，为了确保正确性，按特定顺序执行以下操作序列：\n\n1.  **处理完成事件**：遍历所有 `RUNNING` 状态的对等点。如果对等点 $i$ 的 `completion_time` 等于当前时间 $t$，其状态将变为 `COMPLETED`。每次完成时，信号量值 $S(t)$ 递增（一次“信号”操作），从而释放一个槽位。\n2.  **处理到达事件并更新等待时间**：遍历所有对等点。\n    - 如果状态为 `NOT_ARRIVED` 的对等点 $i$ 的到达时间 $A_i$ 等于当前时间 $t$，其状态将变为 `WAITING`。\n    - 如果对等点 $i$ 处于 `WAITING` 状态，其 `wait_ticks` 计数器递增。\n3.  **调度新的上传**：只要有可用槽位（$S(t)  0$）并且有对等点处于 `WAITING` 状态，就执行此步骤。在此子步骤的每次迭代中：\n    a. 识别出当前所有处于 `WAITING` 状态的对等点集合。\n    b. 如果此集合为空，则此时无法再调度更多对等点。\n    c. 对于 `WAITING` 集合中的每个对等点 $j$，使用其当前的 `wait_ticks` 作为 $W_j(t)$ 来计算其优先级 $P_j(t) = C_j + \\alpha \\cdot W_j(t)$。\n    d. 选择具有最大优先级的对等点。如果多个对等点共享相同的最大优先级，则应用打破平局的规则（最小索引 $i$）。\n    e. 选定的对等点被调度开始：\n        - 信号量值 $S(t)$ 递减（一次“等待”操作）。\n        - 对等点的 `status` 变为 `RUNNING`。\n        - 其 `start_time` 记录为当前时间 $t$。\n        - 其 `completion_time` 计算为 $t + D_i$。\n        - 其索引被附加到 `start_order` 列表中。\n4.  **推进时间**：增加模拟时间 $t$。\n\n一旦所有 $n$ 个对等点都达到 `COMPLETED` 状态，主循环就终止。最后，计算并格式化所需的输出（`no_starvation`、$\\overline{W}$ 和 `start_order`）。平均等待时间 $\\overline{W}$ 是根据记录的开始时间 $S_i$ 和给定的到达时间 $A_i$ 计算出来的。\n\n这个确定性的、分步的过程正确地模拟了指定的系统，并产生了所需的可量化结果。", "answer": "[[1,0.500000,[0,1,3,2]],[1,3.000000,[0,1,2]],[1,0.600000,[2,0,1,3,4]]]", "id": "3681933"}]}