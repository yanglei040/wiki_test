{"hands_on_practices": [{"introduction": "虚拟内存系统并非没有性能开销，当发生缺页时，系统需要耗费额外时间从磁盘加载数据，这会显著拖慢程序的执行速度。为了精确衡量这种影响，我们可以建立一个名为“有效访问时间”（Effective Access Time, EAT）的性能模型，它综合了内存命中和缺页中断的耗时。通过这个练习 [@problem_id:3689756]，你将学会如何量化虚拟内存系统的性能，并基于数据来判断某项优化措施（例如改进缓存策略）是否能带来足够大的收益，从而做出明智的工程决策。", "problem": "一个计算系统使用虚拟内存，允许进程进行逻辑内存寻址，而物理内存则通过页面进行访问。每次内存访问要么在主存中命中，要么触发一个必须被服务的缺页。设每次访问的主存延迟为 $t$，由缺页引起的额外服务时间为 $\\alpha$。设缺页概率为 $p_f$，并假设在一个长序列中，内存访问是独立同分布的。\n\n从数学期望的定义出发，将有效访问时间 (EAT) 建模为代表单次访问延迟的随机变量的期望值。然后，考虑一种缓存策略，它将缺页概率从 $p_{f0}$ 降低到 $p_{f1}$，其中 $p_{f1} < p_{f0}$。如果有效访问时间的减少量至少为基础主存延迟 $t$ 的 $\\delta$ 倍，则定义该缓存为“关键的”。形式上，如果无缓存时的有效访问时间与有缓存时的有效访问时间之差至少为 $\\delta t$，则该缓存是关键的。\n\n以闭合形式推导出阈值 $\\alpha^{\\star}$，使得缓存是关键的当且仅当 $\\alpha \\ge \\alpha^{\\star}$，该阈值用 $t$、$p_{f0}$、$p_{f1}$ 和 $\\delta$ 表示。\n\n最后，对于 $t = 80$ 纳秒、$p_{f0} = 0.03$、$p_{f1} = 0.012$ 和 $\\delta = 0.10$ 的情况，数值计算该阈值。将最终数值答案四舍五入到四位有效数字。以纳秒为单位表示最终阈值 $\\alpha^{\\star}$。", "solution": "问题陈述已经过验证，被认为是具有科学依据、提法恰当且客观的。它提供了一套完整且一致的定义和数值，用以推导和评估指定的阈值。\n\n设 $X$ 是表示单次内存访问延迟的随机变量。问题陈述指出，一次内存访问可能导致两种结果之一：\n$1$。在主存中命中，发生概率为 $1 - p_f$。此事件的延迟为 $t$。\n$2$。发生缺页，概率为 $p_f$。此事件的延迟是主存延迟和缺页服务时间之和，即 $t + \\alpha$。\n\n有效访问时间 (EAT) 定义为随机变量 $X$ 的数学期望，记作 $E[X]$。根据离散随机变量的期望定义，我们有：\n$$\n\\text{EAT} = E[X] = \\sum_{i} x_i P(X=x_i)\n$$\n在本例中，访问时间的可能值 $x_i$ 为 $t$ 和 $t+\\alpha$。它们各自的概率为 $1-p_f$ 和 $p_f$。\n$$\n\\text{EAT} = (t) \\cdot (1 - p_f) + (t + \\alpha) \\cdot p_f\n$$\n展开此表达式，我们得到：\n$$\n\\text{EAT} = t - t \\cdot p_f + t \\cdot p_f + \\alpha \\cdot p_f\n$$\n$$\n\\text{EAT} = t + \\alpha \\cdot p_f\n$$\n这就是有效访问时间的一般公式。\n\n现在，我们考虑所提出的两种场景：无缓存和有缓存。\n设 $\\text{EAT}_0$ 为无缓存时的有效访问时间，此时缺页概率为 $p_{f0}$。\n$$\n\\text{EAT}_0 = t + \\alpha \\cdot p_{f0}\n$$\n设 $\\text{EAT}_1$ 为采用缓存策略时的有效访问时间，此时缺页概率降低到 $p_{f1}$。\n$$\n\\text{EAT}_1 = t + \\alpha \\cdot p_{f1}\n$$\n问题将缓存策略定义为“关键的”，条件是 EAT 的减少量至少为基础主存延迟 $t$ 的 $\\delta$ 倍。这可以表示为以下不等式：\n$$\n\\text{EAT}_0 - \\text{EAT}_1 \\ge \\delta t\n$$\n我们将 $\\text{EAT}_0$ 和 $\\text{EAT}_1$ 的表达式代入此不等式：\n$$\n(t + \\alpha \\cdot p_{f0}) - (t + \\alpha \\cdot p_{f1}) \\ge \\delta t\n$$\n化简不等式左侧：\n$$\nt + \\alpha \\cdot p_{f0} - t - \\alpha \\cdot p_{f1} \\ge \\delta t\n$$\n$$\n\\alpha \\cdot p_{f0} - \\alpha \\cdot p_{f1} \\ge \\delta t\n$$\n提出因子 $\\alpha$：\n$$\n\\alpha (p_{f0} - p_{f1}) \\ge \\delta t\n$$\n问题要求解出阈值 $\\alpha^{\\star}$，使得条件满足当且仅当 $\\alpha \\ge \\alpha^{\\star}$。为了找到这个阈值，我们必须解关于 $\\alpha$ 的不等式。由于问题陈述缓存策略降低了缺页概率，我们有 $p_{f1} < p_{f0}$，这意味着 $(p_{f0} - p_{f1})$ 项为正。因此，我们可以用 $(p_{f0} - p_{f1})$ 除以不等式两边，而无需改变不等号的方向。\n$$\n\\alpha \\ge \\frac{\\delta t}{p_{f0} - p_{f1}}\n$$\n从这个不等式中，我们可以直接确定阈值 $\\alpha^{\\star}$：\n$$\n\\alpha^{\\star} = \\frac{\\delta t}{p_{f0} - p_{f1}}\n$$\n这就是阈值 $\\alpha^{\\star}$ 的闭合形式表达式。\n\n最后，我们使用给定的数值进行数值计算：$t = 80$ 纳秒，$p_{f0} = 0.03$，$p_{f1} = 0.012$，以及 $\\delta = 0.10$。\n将这些值代入 $\\alpha^{\\star}$ 的表达式中：\n$$\n\\alpha^{\\star} = \\frac{(0.10) \\cdot (80)}{0.03 - 0.012}\n$$\n$$\n\\alpha^{\\star} = \\frac{8}{0.018}\n$$\n$$\n\\alpha^{\\star} = \\frac{8}{\\frac{18}{1000}} = \\frac{8000}{18} = \\frac{4000}{9}\n$$\n计算数值：\n$$\n\\alpha^{\\star} = 444.444...\n$$\n问题要求将最终答案四舍五入到四位有效数字。前四位数字是 $4, 4, 4, 4$。第五位数字是 $4$，小于 $5$，所以我们舍去。\n$$\n\\alpha^{\\star} \\approx 444.4\n$$\n单位与延迟的单位相同，即纳秒。因此，阈值为 $444.4$ 纳秒。", "answer": "$$\n\\boxed{444.4}\n$$", "id": "3689756"}, {"introduction": "有效访问时间模型告诉我们，过高的缺页率是性能的“杀手”，但在实际编程中，是什么导致了高缺页率呢？关键在于“局部性原理”（locality of reference），特别是空间局部性，即程序倾向于访问邻近的内存地址。当代码的内存访问模式与数据的物理布局严重冲突时，就会导致系统反复地换入换出页面，即所谓的“颠簸”（thrashing）。这项练习 [@problem_id:3689767] 通过一个经典的矩阵遍历案例，生动地展示了空间局部性的巨大影响，你会看到一个简单的访问顺序调整如何导致缺页数量产生数量级的差异。", "problem": "考虑一台实现虚拟内存和固定大小分页的机器。一个程序分配了一个 $m \\times n$ 的元素矩阵，每个元素占用 $E$ 字节，在虚拟内存中以行主序连续布局。该矩阵的基虚拟地址与页边界对齐。系统使用请求分页，采用最近最少使用 (LRU) 替换策略，没有预取，并且开始时物理内存中没有驻留任何矩阵页面。该进程可用的物理页框恰好有 $f$ 个，并且在遍历期间没有其他内存活动竞争这些页框。当程序引用一个未驻留在物理内存中的虚拟页面时，就会发生缺页。\n\n您将比较对该矩阵的两种完整遍历：一种是按行主序访问元素，另一种是按列主序访问元素。对于两种遍历，每个矩阵元素都只被读取一次。仅使用以下给定的机器和工作负载参数：\n- $m = 1024$\n- $n = 1024$\n- $E = 8$ 字节\n- 页大小 $P = 4096$ 字节\n- 可用页框数 $f = 2$\n\n从虚拟内存、分页和引用局部性（包括时间局部性和空间局部性）的核心定义出发，推导在这些假设下每次遍历所产生的总缺页数。然后，计算比率\n$$\\rho = \\frac{\\text{列主序遍历的总缺页数}}{\\text{行主序遍历的总缺页数}}。$$\n给出 $\\rho$ 的最终答案，形式为一个无单位的精确整数。", "solution": "该问题是有效的，因为它在科学上基于操作系统原理，特别是虚拟内存管理，并且问题提法明确，为得到唯一解提供了所有必要的参数。\n\n这个问题需要分析内存访问模式及其与分页式虚拟内存系统的交互。关键概念是虚拟内存（为每个进程提供一个大的、私有的地址空间）；分页（将这个地址空间划分为固定大小的块，称为页，这些页被映射到物理内存的页框）；以及缺页（当程序引用当前不在物理内存中的页时发生）。这种系统的性能在很大程度上受到引用局部性原理的影响，该原理指出程序倾向于访问其最近访问过的内存位置附近的位置。空间局部性是指访问邻近内存地址的倾向，而时间局部性是指重新访问相同位置的倾向。\n\n首先，我们根据给定参数确定内存布局的相关参数。\n矩阵有 $m=1024$ 行和 $n=1024$ 列。\n每个元素为 $E=8$ 字节。\n页大小为 $P=4096$ 字节。\n\n一个页面可以容纳的元素数量是：\n$$ N_{E/P} = \\frac{P}{E} = \\frac{4096}{8} = 512 \\text{ 个元素/页} $$\n\n矩阵以行主序存储，意味着单行的元素在内存中是连续的。一行的字节大小是：\n$$ S_{row} = n \\times E = 1024 \\times 8 = 8192 \\text{ 字节} $$\n\n存储单行所需的页面数是：\n$$ N_{P/row} = \\frac{S_{row}}{P} = \\frac{8192}{4096} = 2 \\text{ 页/行} $$\n\n存储整个 $m \\times n$ 矩阵所需的虚拟页面总数是：\n$$ N_{pages} = m \\times N_{P/row} = 1024 \\times 2 = 2048 \\text{ 页} $$\n或者，矩阵的总大小是 $m \\times n \\times E = 1024 \\times 1024 \\times 8$ 字节。总页数是 $\\frac{m \\times n \\times E}{P} = \\frac{1024 \\times 1024 \\times 8}{4096} = \\frac{2^{10} \\times 2^{10} \\times 2^3}{2^{12}} = 2^{23-12} = 2^{11} = 2048$ 页。\n\n设 $F_{row}$ 为行主序遍历的总缺页数。\n在行主序遍历中，程序访问元素 `A[0][0], A[0][1], ..., A[0][n-1], A[1][0], ...`。由于矩阵是以行主序布局的，这种访问模式在虚拟内存中是顺序的。这种遍历表现出非常高的空间局部性。对任何新页面上的元素的第一次访问都会发生缺页。由于系统使用请求分页且没有预取，程序将接着访问同一页面上剩余的 $N_{E/P} - 1 = 511$ 个元素，所有这些访问都将是内存命中。因为遍历是纯粹顺序地通过矩阵的 $2048$ 个页面，并且只有 $f=2$ 个页框，所以它永远不需要重新调入一个很久以前被换出的页面。因此，对于每个唯一的页面，缺页恰好发生一次。总缺页数等于矩阵占用的总页数。\n$$ F_{row} = N_{pages} = 2048 $$\n\n设 $F_{col}$ 为列主序遍历的总缺页数。\n在列主序遍历中，程序访问元素 `A[0][0], A[1][0], ..., A[m-1][0], A[0][1], ...`。对于以行主序存储的矩阵，这种访问模式表现出非常差的空间局部性。\n让我们分析被访问的虚拟地址。元素 `A[i][j]` 的地址由其0索引位置 $(i, j)$ 决定，并与 $i \\times n + j$ 成正比。\n在列主序扫描中，`A[i][j]` 与下一个元素 `A[i+1][j]` 之间的虚拟地址跳跃是：\n$$ \\Delta_{\\text{address}} = ((i+1) \\times n + j) \\times E - (i \\times n + j) \\times E = n \\times E = 1024 \\times 8 = 8192 \\text{ 字节} $$\n这个地址跳跃等于 $2 \\times P$。这意味着在列扫描中，连续的元素访问相隔两个完整的页面大小。元素 `A[i][j]` 的虚拟页是 $VP(i, j) = \\lfloor \\frac{(i \\times n + j) \\times E}{P} \\rfloor = \\lfloor \\frac{(i \\times 1024 + j) \\times 8}{4096} \\rfloor = \\lfloor 2i + \\frac{j}{512} \\rfloor$。\n\n考虑第一列 ($j=0$) 的遍历。程序访问 `A[0][0], A[1][0], A[2][0], ...`。\n- 访问 `A[0][0]`：页 $VP(0,0)=0$。这导致一次缺页。页 $0$ 被加载到页框 1。驻留页集合为 $\\{P_0\\}$。\n- 访问 `A[1][0]`：页 $VP(1,0)=2$。这导致一次缺页。页 $2$ 被加载到页框 2。驻留页集合为 $\\{P_0, P_2\\}$。LRU 页是 $P_0$。\n- 访问 `A[2][0]`：页 $VP(2,0)=4$。这导致一次缺页。由于只有 $f=2$ 个页框，LRU 页 $P_0$ 被换出。页 $4$ 被加载。驻留页集合为 $\\{P_2, P_4\\}$。LRU 页是 $P_2$。\n- 访问 `A[3][0]`：页 $VP(3,0)=6$。这导致一次缺页。LRU 页 $P_2$ 被换出。页 $6$ 被加载。驻留页集合为 $\\{P_4, P_6\\}$。LRU 页是 $P_4$。\n\n这种现象，即由于局部性所需的工作集页面数超过了可用页框数，导致每次访问都引起缺页，被称为颠簸 (thrashing)。对于任意列 $j$，访问的页面序列是 $VP(0,j), VP(1,j), VP(2,j), \\dots$。页号为 $\\lfloor \\frac{j}{512} \\rfloor, \\lfloor 2 + \\frac{j}{512} \\rfloor, \\lfloor 4 + \\frac{j}{512} \\rfloor, \\dots$。这是一个公差为 $2$ 的等差数列。由于我们只有 $f=2$ 个页框，系统最多只能持有该序列中的两个页面。在任何一步，下一个需要的页面都保证不在内存中。因此，对每个元素 `A[i][j]` 的每一次内存访问都会导致一次缺页。\n\n矩阵中的元素总数是 $m \\times n$。\n$$ F_{col} = m \\times n = 1024 \\times 1024 = 1,048,576 $$\n\n最后，我们计算比率 $\\rho$：\n$$ \\rho = \\frac{F_{col}}{F_{row}} = \\frac{1024 \\times 1024}{2048} $$\n由于 $2048 = 2 \\times 1024$，我们有：\n$$ \\rho = \\frac{1024 \\times 1024}{2 \\times 1024} = \\frac{1024}{2} = 512 $$\n\n该比率表明，忽略数据布局从而未能利用空间局部性的访问模式会导致严重的性能损失，并引发颠簸。\n\n一个更普遍的比率推导证实了这一结果。\n$F_{col} = m \\times n$\n$F_{row} = \\frac{m \\times n \\times E}{P}$\n$$\\rho = \\frac{F_{col}}{F_{row}} = \\frac{m \\times n}{\\frac{m \\times n \\times E}{P}} = \\frac{P}{E}$$\n代入给定值：\n$$\\rho = \\frac{4096}{8} = 512$$", "answer": "$$\\boxed{512}$$", "id": "3689767"}, {"introduction": "我们已经看到，为了实现高性能，程序必须能够快速访问其活跃的内存区域。为了加速地址翻译过程，现代处理器内部集成了一个特殊的高速缓存，称为“转译后备缓冲器”（Translation Lookaside Buffer, TLB）。TLB 的“覆盖范围”（reach）衡量了它能够在不访问慢速页表的情况下直接转换多少内存地址，理想情况下，这个范围应能容纳整个程序的“工作集”（working set）。通过这项计算练习 [@problem_id:3689807]，你将理解 TLB 大小和页面大小等硬件参数如何直接决定系统支持内存密集型应用的能力。", "problem": "通用计算机上的一个进程使用虚拟内存 (VM)，它将其虚拟地址空间划分为大小为 $p$ 的固定大小的页面。处理器维护一个快表 (TLB)，它是近期页到帧转换的一个缓存；每个 TLB 条目精确映射一个虚拟页面。无需访问页表，TLB 能够直接转换的虚拟内存总量称为 TLB 覆盖范围。考虑一个系统，其页面大小 $p = 4\\,\\mathrm{KiB}$（其中 $1\\,\\mathrm{KiB} = 1024\\,\\mathrm{bytes}$ 且 $1\\,\\mathrm{MiB} = 1024^2\\,\\mathrm{bytes}$），一个当前拥有 $N_{\\text{entries}} = 256$ 个条目的 TLB，以及一个工作集大小为 $W = 19.7\\,\\mathrm{MiB}$ 的进程。\n\n仅使用上述关于 VM 页面和 TLB 条目的核心定义，首先确定当前 TLB 的覆盖范围，并以 $\\mathrm{MiB}$ 为单位表示。然后，确定所需的 $N_{\\text{entries}}$ 的最小整数值，以使 TLB 覆盖范围至少为工作集大小 $W$。请提供最小的 $N_{\\text{entries}}$ 作为最终答案；最终答案中不应包含单位。", "solution": "首先将对问题陈述进行验证，以确保其内容完整、科学上合理且提法得当。\n\n### 步骤 1：提取已知条件\n- 虚拟内存被划分为大小为 $p$ 的页面。\n- 每个 TLB 条目精确映射一个虚拟页面。\n- TLB 覆盖范围是 TLB 可以转换的虚拟内存总量。\n- 页面大小，$p = 4\\,\\mathrm{KiB}$。\n- 单位换算: $1\\,\\mathrm{KiB} = 1024\\,\\mathrm{bytes}$。\n- 单位换算: $1\\,\\mathrm{MiB} = 1024^2\\,\\mathrm{bytes}$。\n- 当前 TLB 条目数，$N_{\\text{entries}} = 256$。\n- 进程工作集大小，$W = 19.7\\,\\mathrm{MiB}$。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题具有科学依据，因为它基于计算机体系结构和操作系统中的基本和标准概念，即虚拟内存、分页和快表（TLB）。所提供的定义和数值在此背景下是符合实际且常用的。该问题提法得当，提供了计算唯一解所需的所有必要数据（$p$、$N_{\\text{entries}}$、$W$ 和单位定义）。语言客观而精确。该问题是完整、一致的，并且没有违反任何物理或逻辑原则。这是一个标准的、可形式化的问题，旨在测试对页面大小、TLB 大小和内存覆盖范围之间关系的理解。\n\n### 步驟 3：结论与行动\n该问题被判定为**有效**。将提供完整的解法。\n\n核心原理是 TLB 覆盖范围（我们可以表示为 $R_{\\text{TLB}}$）是所有 TLB 条目映射的页面可寻址的总内存。由于每个条目映射一个大小为 $p$ 的单个页面，因此 TLB 覆盖范围是条目数与页面大小的乘积。\n\nTLB 覆盖范围的公式是：\n$$R_{\\text{TLB}} = N_{\\text{entries}} \\times p$$\n\n首先，我们计算当前系统配置的 TLB 覆盖范围。\n已知条件是：\n- 当前条目数，$N_{\\text{entries}} = 256$。\n- 页面大小，$p = 4\\,\\mathrm{KiB}$。\n\n将这些值代入公式：\n$$R_{\\text{TLB}} = 256 \\times 4\\,\\mathrm{KiB} = 1024\\,\\mathrm{KiB}$$\n\n问题要求将此值以 MiB 表示。我们已知换算因子：$1\\,\\mathrm{KiB} = 1024\\,\\mathrm{bytes}$ 和 $1\\,\\mathrm{MiB} = 1024^2\\,\\mathrm{bytes}$。由此，我们可以推导出 KiB 和 MiB 之间的关系：\n$$1\\,\\mathrm{MiB} = 1024 \\times 1024\\,\\mathrm{bytes} = 1024 \\times (1\\,\\mathrm{KiB}) = 1024\\,\\mathrm{KiB}$$\n因此，当前的 TLB 覆盖范围是：\n$$R_{\\text{TLB}} = 1024\\,\\mathrm{KiB} = 1\\,\\mathrm{MiB}$$\n\n接下来，我们必须确定所需的 TLB 条目的最小数量，以使 TLB 覆盖范围至少等于工作集大小 $W$。设所需的条目数为 $N'_{\\text{entries}}$。该条件可以表示为一个不等式：\n$$N'_{\\text{entries}} \\times p \\ge W$$\n\n我们需要求解 $N'_{\\text{entries}}$：\n$$N'_{\\text{entries}} \\ge \\frac{W}{p}$$\n\n给定的数值是：\n- 工作集大小，$W = 19.7\\,\\mathrm{MiB}$。\n- 页面大小，$p = 4\\,\\mathrm{KiB}$。\n\n为了进行除法运算，我们必须将两个量表示为相同的单位。让我们将两者都转换为 KiB：\n$$W = 19.7\\,\\mathrm{MiB} = 19.7 \\times 1024\\,\\mathrm{KiB}$$\n$$p = 4\\,\\mathrm{KiB}$$\n\n现在，将这些值代入不等式：\n$$N'_{\\text{entries}} \\ge \\frac{19.7 \\times 1024\\,\\mathrm{KiB}}{4\\,\\mathrm{KiB}}$$\n\nKiB 单位相互抵消：\n$$N'_{\\text{entries}} \\ge 19.7 \\times \\frac{1024}{4}$$\n$$N'_{\\text{entries}} \\ge 19.7 \\times 256$$\n$$N'_{\\text{entries}} \\ge 5043.2$$\n\n由于 TLB 条目数必须是整数，且不等式要求该值大于或等于 $5043.2$，我们必须取满足此条件的最小整数。这可以通过对结果应用向上取整函数来实现。\n$$N'_{\\text{entries, min}} = \\lceil 5043.2 \\rceil = 5044$$\n\n因此，最少需要 $5044$ 个 TLB 条目来确保 TLB 覆盖范围能够覆盖进程的整个工作集。", "answer": "$$\\boxed{5044}$$", "id": "3689807"}]}