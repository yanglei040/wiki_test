{"hands_on_practices": [{"introduction": "掌握一种算法的最好方法之一就是亲手模拟它的执行过程。这个练习将指导你手动追踪一个展示了“局部性”特征的页面引用序列，并观察二次机会（时钟）算法在不同物理帧数量（$N=3$ 和 $N=4$）下的行为。通过这个实践，你将直观地理解系统内存容量如何直接影响页面置换决策和整体性能。[@problem_id:3679250]", "problem": "一个操作系统 (OS) 采用第二次机会页面置换算法，也称为时钟算法。该算法维护一个从 $0$ 到 $N-1$ 索引的帧循环列表，以及一个循环前进的“时钟指针”。每个帧包含一个页面和一个引用位（通常称为 $R$-位）。该算法遵循以下规则：\n- 每次内存引用到一个已驻留在帧中的页面时，该帧的 $R$-位在引用后立即被设置为 $1$；此时时钟指针不移动。\n- 发生缺页中断时，算法检查时钟指针下的帧。如果其 $R$-位为 $1$，则将其置为 $0$ 并将指针前进到下一个帧，重复此过程直到找到一个 $R$-位为 $0$ 的帧。该帧被选为牺牲帧，由发生中断的页面替换，插入页面的 $R$-位被设置为 $1$，然后时钟指针前进到刚刚用于插入的帧之后的下一个帧。\n- 最初，所有帧都是空的，所有 $R$-位都为 $0$，时钟指针指向帧 $0$。空帧被视为 $R$-位等于 $0$，并可能被选为牺牲帧。\n\n考虑以下具有三个局部性突发的固定引用串：\n- 突发 $A$：页面 $\\{1,2,3\\}$ 被重复访问，随后是突发 $B$：页面 $\\{4,5\\}$ 被重复访问，然后局部性变为新页面再返回，得出完整的引用串\n$$\n\\langle 1,\\,2,\\,3,\\,1,\\,2,\\,3,\\,4,\\,5,\\,4,\\,5,\\,6,\\,6,\\,1,\\,2,\\,3,\\,7,\\,8,\\,7,\\,8,\\,1,\\,3,\\,2 \\rangle.\n$$\n\n对于 $N=3$ 帧和 $N=4$ 帧的情况，根据上述规则精确地确定性模拟时钟算法，以获得在整个引用串中每次缺页中断时选择的牺牲帧索引的有序序列 $V_{3}$ 和 $V_{4}$。设\n$$\nS \\equiv \\sum_{i \\in V_{3}} i \\;+\\; \\sum_{j \\in V_{4}} j.\n$$\n计算 $S$ 的值。无需四舍五入。将最终答案表示为一个不带单位的纯数字。", "solution": "用户希望找到时钟（第二次机会）页面置換算法两次模拟的牺牲帧索引之和。\n\n### 问题验证\n根据指定的验证标准对问题陈述进行分析。\n\n**第 1 步：提取已知条件**\n- **算法**：第二次机会（时钟）页面置換算法。\n- **数据结构**：从 $0$ 到 $N-1$ 索引的帧循环列表，带有时钟指针。每个帧有一个页面和一个引用位（$R$-位）。\n- **初始状态**：所有帧为空，所有 $R$-位为 $0$，时钟指针指向帧 $0$。空帧被视为 $R=0$。\n- **算法规则**：\n  1.  **命中**：当内存引用到已驻留的页面时，该帧的 $R$-位被设置为 $1$。时钟指针不移动。\n  2.  **缺页中断**：\n      a. 算法检查时钟指针位置的帧。\n      b. 如果其 $R$-位为 $1$，则该位置为 $0$，指针前进到下一个帧。重复此过程，直到找到一个 $R$-位为 $0$ 的帧。\n      c. $R$-位为 $0$ 的帧被选为牺牲帧。\n      d. 发生中断的页面替换牺牲页面。\n      e. 新加载页面的帧的 $R$-位被设置为 $1$。\n      f. 时钟指针前进到牺牲帧紧邻的下一个帧。\n- **引用串**：$\\langle 1,\\,2,\\,3,\\,1,\\,2,\\,3,\\,4,\\,5,\\,4,\\,5,\\,6,\\,6,\\,1,\\,2,\\,3,\\,7,\\,8,\\,7,\\,8,\\,1,\\,3,\\,2 \\rangle$\n- **模拟情况**：\n  1.  $N=3$ 帧，产生牺牲序列 $V_3$。\n  2.  $N=4$ 帧，产生牺牲序列 $V_4$。\n- **最终计算**：计算 $S = \\sum_{i \\in V_{3}} i + \\sum_{j \\in V_{4}} j$。\n\n**第 2 步：使用提取的已知条件进行验证**\n- **科学上成立**：问题描述了时钟算法，这是操作系统中的一个标准主题。这些规则是该算法的一个有效、具体的实现。前提是合理的。\n- **定义明确**：引用串、初始条件和算法规则都以高精度指定。这确保了唯一的、确定性的模拟轨迹和单一的正确答案。\n- **客观**：问题以正式、客观的语言陈述，没有歧义或主观性断言。\n\n**第 3 步：结论与行动**\n问题是**有效的**，因为它在科学上成立、定义明确且客观。将提供完整的解决方案。\n\n### 求解过程\n\n解决方案要求用给定的引用串在 $N=3$ 和 $N=4$ 帧的情况下模拟时钟算法。对于每次缺页中断，我们必须记录牺牲帧的索引。每一步的状态由每个帧中的页面、其对应的 $R$-位以及时钟指针的位置定义。设 $F$ 为帧数组，$R$ 为 $R$-位数组，$H$ 为时钟指针。\n\n**情况 1：$N=3$ 帧**\n- 初始状态：$F=[ , , ]$，$R=[0,0,0]$，$H=0$，$V_3 = []$。\n\n1.  引用 **1**：**中断**。牺牲帧 $0$。$F=[1, , ]$，$R=[1,0,0]$，$H \\to 1$。$V_3=[0]$。\n2.  引用 **2**：**中断**。牺牲帧 $1$。$F=[1,2, ]$，$R=[1,1,0]$，$H \\to 2$。$V_3=[0,1]$。\n3.  引用 **3**：**中断**。牺牲帧 $2$。$F=[1,2,3]$，$R=[1,1,1]$，$H \\to (2+1)\\pmod 3 = 0$。$V_3=[0,1,2]$。\n4.  引用 **1**：命中。$R[0] \\to 1$。状态：$F=[1,2,3]$，$R=[1,1,1]$，$H=0$。\n5.  引用 **2**：命中。$R[1] \\to 1$。状态：$F=[1,2,3]$，$R=[1,1,1]$，$H=0$。\n6.  引用 **3**：命中。$R[2] \\to 1$。状态：$F=[1,2,3]$，$R=[1,1,1]$，$H=0$。\n7.  引用 **4**：**中断**。指针在 $0$。扫描：$R[0]=1 \\to 0, H \\to 1$；$R[1]=1 \\to 0, H \\to 2$；$R[2]=1 \\to 0, H \\to 0$。重新扫描指针在 $0$ 处：$R[0]=0$。牺牲帧 $0$。$F=[4,2,3]$，$R=[1,0,0]$，$H \\to 1$。$V_3=[0,1,2,0]$。\n8.  引用 **5**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[4,5,3]$，$R=[1,1,0]$，$H \\to 2$。$V_3=[0,1,2,0,1]$。\n9.  引用 **4**：命中。$R[0] \\to 1$。状态：$F=[4,5,3]$，$R=[1,1,0]$，$H=2$。\n10. 引用 **5**：命中。$R[1] \\to 1$。状态：$F=[4,5,3]$，$R=[1,1,0]$，$H=2$。\n11. 引用 **6**：**中断**。指针在 $2$。$R[2]=0$。牺牲帧 $2$。$F=[4,5,6]$，$R=[1,1,1]$，$H \\to 0$。$V_3=[0,1,2,0,1,2]$。\n12. 引用 **6**：命中。$R[2] \\to 1$。状态：$F=[4,5,6]$，$R=[1,1,1]$，$H=0$。\n13. 引用 **1**：**中断**。指针在 $0$。扫描：$R[0]=1 \\to 0, H \\to 1$；$R[1]=1 \\to 0, H \\to 2$；$R[2]=1 \\to 0, H \\to 0$。重新扫描指针在 $0$ 处：$R[0]=0$。牺牲帧 $0$。$F=[1,5,6]$，$R=[1,0,0]$，$H \\to 1$。$V_3=[0,1,2,0,1,2,0]$。\n14. 引用 **2**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[1,2,6]$，$R=[1,1,0]$，$H \\to 2$。$V_3=[0,1,2,0,1,2,0,1]$。\n15. 引用 **3**：**中断**。指针在 $2$。$R[2]=0$。牺牲帧 $2$。$F=[1,2,3]$，$R=[1,1,1]$，$H \\to 0$。$V_3=[0,1,2,0,1,2,0,1,2]$。\n16. 引用 **7**：**中断**。指针在 $0$。扫描：$R[0]=1 \\to 0, H \\to 1$；$R[1]=1 \\to 0, H \\to 2$；$R[2]=1 \\to 0, H \\to 0$。重新扫描指针在 $0$ 处：$R[0]=0$。牺牲帧 $0$。$F=[7,2,3]$，$R=[1,0,0]$，$H \\to 1$。$V_3=[0,1,2,0,1,2,0,1,2,0]$。\n17. 引用 **8**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[7,8,3]$，$R=[1,1,0]$，$H \\to 2$。$V_3=[0,1,2,0,1,2,0,1,2,0,1]$。\n18. 引用 **7**：命中。$R[0] \\to 1$。状态：$F=[7,8,3]$，$R=[1,1,0]$，$H=2$。\n19. 引用 **8**：命中。$R[1] \\to 1$。状态：$F=[7,8,3]$，$R=[1,1,0]$，$H=2$。\n20. 引用 **1**：**中断**。指针在 $2$。$R[2]=0$。牺牲帧 $2$。$F=[7,8,1]$，$R=[1,1,1]$，$H \\to 0$。$V_3=[0,1,2,0,1,2,0,1,2,0,1,2]$。\n21. 引用 **3**：**中断**。指针在 $0$。扫描：$R[0]=1 \\to 0, H \\to 1$；$R[1]=1 \\to 0, H \\to 2$；$R[2]=1 \\to 0, H \\to 0$。重新扫描指针在 $0$ 处：$R[0]=0$。牺牲帧 $0$。$F=[3,8,1]$，$R=[1,0,0]$，$H \\to 1$。$V_3=[0,1,2,0,1,2,0,1,2,0,1,2,0]$。\n22. 引用 **2**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[3,2,1]$，$R=[1,1,0]$，$H \\to 2$。$V_3=[0,1,2,0,1,2,0,1,2,0,1,2,0,1]$。\n\n$N=3$ 的牺牲帧序列为 $V_3 = \\langle 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1 \\rangle$。\n总和是 $\\sum_{i \\in V_3} i = 0+1+2+0+1+2+0+1+2+0+1+2+0+1 = 4 \\times (0+1+2) + 1 = 4 \\times 3 + 1 = 13$。\n\n**情况 2：$N=4$ 帧**\n- 初始状态：$F=[ , , , ]$，$R=[0,0,0,0]$，$H=0$，$V_4 = []$。\n\n1.  引用 **1**：**中断**。牺牲帧 $0$。$F=[1,,,]$，$R=[1,0,0,0]$，$H \\to 1$。$V_4=[0]$。\n2.  引用 **2**：**中断**。牺牲帧 $1$。$F=[1,2,,]$，$R=[1,1,0,0]$，$H \\to 2$。$V_4=[0,1]$。\n3.  引用 **3**：**中断**。牺牲帧 $2$。$F=[1,2,3,]$，$R=[1,1,1,0]$，$H \\to 3$。$V_4=[0,1,2]$。\n4.  引用 **1**：命中。$R[0]\\to 1$。\n5.  引用 **2**：命中。$R[1]\\to 1$。\n6.  引用 **3**：命中。$R[2]\\to 1$。\n7.  引用 **4**：**中断**。牺牲帧 $3$。$F=[1,2,3,4]$，$R=[1,1,1,1]$，$H \\to 0$。$V_4=[0,1,2,3]$。\n8.  引用 **5**：**中断**。指针在 $0$。扫描：$R[0]\\to 0, H\\to 1$；$R[1]\\to 0, H\\to 2$；$R[2]\\to 0, H\\to 3$；$R[3]\\to 0, H\\to 0$。重新扫描指针在 $0$ 处：$R[0]=0$。牺牲帧 $0$。$F=[5,2,3,4]$，$R=[1,0,0,0]$，$H\\to 1$。$V_4=[0,1,2,3,0]$。\n9.  引用 **4**：命中。$R[3]\\to 1$。状态：$R=[1,0,0,1]$，$H=1$。\n10. 引用 **5**：命中。$R[0]\\to 1$。状态：$R=[1,0,0,1]$，$H=1$。\n11. 引用 **6**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[5,6,3,4]$，$R=[1,1,0,1]$，$H\\to 2$。$V_4=[0,1,2,3,0,1]$。\n12. 引用 **6**：命中。$R[1]\\to 1$。\n13. 引用 **1**：**中断**。指针在 $2$。$R[2]=0$。牺牲帧 $2$。$F=[5,6,1,4]$，$R=[1,1,1,1]$，$H\\to 3$。$V_4=[0,1,2,3,0,1,2]$。\n14. 引用 **2**：**中断**。指针在 $3$。扫描：$R[3]\\to 0, H\\to 0$；$R[0]\\to 0, H\\to 1$；$R[1]\\to 0, H\\to 2$；$R[2]\\to 0, H\\to 3$。重新扫描指针在 $3$ 处：$R[3]=0$。牺牲帧 $3$。$F=[5,6,1,2]$，$R=[0,0,0,1]$，$H\\to 0$。$V_4=[0,1,2,3,0,1,2,3]$。\n15. 引用 **3**：**中断**。指针在 $0$。$R[0]=0$。牺牲帧 $0$。$F=[3,6,1,2]$，$R=[1,0,0,1]$，$H\\to 1$。$V_4=[0,1,2,3,0,1,2,3,0]$。\n16. 引用 **7**：**中断**。指针在 $1$。$R[1]=0$。牺牲帧 $1$。$F=[3,7,1,2]$，$R=[1,1,0,1]$，$H\\to 2$。$V_4=[0,1,2,3,0,1,2,3,0,1]$。\n17. 引用 **8**：**中断**。指针在 $2$。$R[2]=0$。牺牲帧 $2$。$F=[3,7,8,2]$，$R=[1,1,1,1]$，$H\\to 3$。$V_4=[0,1,2,3,0,1,2,3,0,1,2]$。\n18. 引用 **7**：命中。$R[1]\\to 1$。\n19. 引用 **8**：命中。$R[2]\\to 1$。\n20. 引用 **1**：**中断**。指针在 $3$。扫描：$R[3]\\to 0, H\\to 0$；$R[0]\\to 0, H\\to 1$；$R[1]\\to 0, H\\to 2$；$R[2]\\to 0, H\\to 3$。重新扫描指针在 $3$ 处：$R[3]=0$。牺牲帧 $3$。$F=[3,7,8,1]$，$R=[0,0,0,1]$，$H\\to 0$。$V_4=[0,1,2,3,0,1,2,3,0,1,2,3]$。\n21. 引用 **3**：命中。$R[0]\\to 1$。状态：$R=[1,0,0,1]$，$H=0$。\n22. 引用 **2**：**中断**。指针在 $0$。扫描：$R[0]\\to 0, H\\to 1$。指针在 $1$ 处：$R[1]=0$。牺牲帧 $1$。$F=[3,2,8,1]$，$R=[0,1,0,1]$，$H\\to 2$。$V_4=[0,1,2,3,0,1,2,3,0,1,2,3,1]$。\n\n$N=4$ 的牺牲帧序列为 $V_4 = \\langle 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 1 \\rangle$。\n总和是 $\\sum_{j \\in V_4} j = (0+1+2+3) + (0+1+2+3) + (0+1+2+3) + 1 = 3 \\times (0+1+2+3) + 1 = 3 \\times 6 + 1 = 18 + 1 = 19$。\n\n**最终计算**\n总和 $S$ 由下式给出：\n$$\nS = \\sum_{i \\in V_{3}} i + \\sum_{j \\in V_{4}} j = 13 + 19 = 32\n$$", "answer": "$$\\boxed{32}$$", "id": "3679250"}, {"introduction": "在理论之外，一个页面置换算法的实用性还取决于它如何处理真实的硬件约束，尤其是磁盘 I/O 的开销。这个编程练习要求你实现一个更完整的时钟算法版本，它不仅包含引用位（$R$ 位），还引入了“脏位”（$D$ 位）。通过区分“干净”页和“肮脏”页，你将学会如何量化页面置换过程中的不同成本，例如页面调入、调出以及代价高昂的回写操作。[@problem_id:3633455]", "problem": "考虑一个采用请求分页的系统，该系统具有一个由一组帧组成的固定大小的物理内存。该系统使用Clock页面置换算法，该算法维护一个在帧上循环移动的指针，每个帧存储一个引用位和一个脏位。其基本依据是操作系统中以下一组经过充分检验的定义和事实：页面错误会触发将出错的虚拟页面调入物理帧中；如果没有空闲帧，则会发生置换；引用位用于二次机会选择，指示最近是否被使用；脏位指示页面在内存中是否被修改，以及在换出时是否需要写回。Clock算法在一个循环指针下遍历所有帧；对于每个候选帧，如果其引用位为$1$，则将其清零为$0$并前移指针；如果引用位为$0$，则该帧被选为要换出的受害者。\n\n您必须编写一个完整的程序，针对给定的引用字符串测试套件，模拟使用Clock算法的请求分页，并为每个测试用例计算三个计数值：\n- 页面调入次数（从磁盘读入内存），记为$I$，\n- 页面调出次数（从内存换出，不论是否干净），记为$O$，\n- 写回次数（换出时将脏页写入磁盘），记为$W$。\n\n所有操作都在一个初始为空的内存上进行，其中所有帧的初始状态均为无效，引用位设置为$0$，脏位设置为$0$。Clock指针从帧索引$0$开始。对于虚拟页面$p$的每次访问（操作为$op \\in \\{R,W\\}$），请遵循以下从上述基本原理推导出的规则：\n- 如果页面$p$已在某个帧中，则为命中：将该帧的引用位设置为$1$，如果$op=W$，则同时将其脏位设置为$1$。此操作不产生页面调入和页面调出。\n- 如果页面$p$不在内存中，则为未命中并触发页面错误：\n  1. 如果存在任何空闲帧，则从当前Clock指针位置开始循环扫描，将$p$放入遇到的第一个空闲帧中，将其引用位设置为$1$，如果$op=W$则脏位设置为$1$否则为$0$，将该帧标记为有效，并将Clock指针前移一个位置。将$I$增加$1$。\n  2. 如果不存在空闲帧，则运行Clock置换循环：重复检查Clock指针处的帧；如果其引用位为$1$，则将其设置为$0$并前移指针；如果其引用位为$0$，则选择它作为受害者。换出受害者，将$O$增加$1$；如果其脏位为$1$，则将$W$增加$1$。将页面$p$装入受害帧中，引用位设置为$1$，如果$op=W$则脏位设置为$1$否则为$0$，将其标记为有效，并将Clock指针前移一个位置。同时将$I$增加$1$。\n\n设计您的程序，使其生成单行输出，其中包含用方括号括起来的结果，结果是一个逗号分隔的列表，每个测试用例的结果本身就是一个用方括号括起来的逗号分隔三元组$[I,O,W]$。例如，总体格式为$[[I_1,O_1,W_1],[I_2,O_2,W_2],\\dots]$。不涉及物理单位、角度或百分比；所有输出均为整数。\n\n使用以下测试套件，其中包括一般情况、边界条件和边缘情况。每个引用字符串都是一个$(p,op)$对的序列，其中$p$是页号，$op \\in \\{R,W\\}$：\n- 测试用例1：帧数$F=3$，引用字符串长度为$10$：$(1,R),(2,W),(3,R),(1,R),(4,W),(2,R),(5,W),(1,W),(2,W),(3,R)$。\n- 测试用例2：帧数$F=1$，引用字符串长度为$5$：$(1,R),(1,W),(2,R),(2,W),(1,R)$。\n- 测试用例3：帧数$F=4$，引用字符串长度为$10$：$(10,R),(11,R),(12,W),(13,R),(10,R),(11,W),(12,R),(13,W),(10,R),(11,R)$。\n- 测试用例4：帧数$F=2$，引用字符串长度为$7$：$(1,W),(2,W),(3,W),(1,W),(2,R),(3,R),(1,R)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的结果，结果是一个逗号分隔的列表，格式应与$[[I_1,O_1,W_1],[I_2,O_2,W_2],[I_3,O_3,W_3],[I_4,O_4,W_4]]$完全一致。", "solution": "问题陈述已经过验证，被认为是合理、定义明确且在操作系统原理方面有科学依据的。用于Clock页面置换算法模拟的规则是完整且无歧义的。因此，我们可以着手提供解决方案。\n\n该解决方案的核心是直接模拟一个由Clock算法管理的请求分页内存系统。其设计基于模拟物理内存帧的状态以及Clock指针为响应一系列内存访问而进行的移动。\n\n主要的数据结构是一个代表物理内存的结构体数组，其中每个元素对应一个帧。每个帧必须维护问题描述中说明的状态：\n- 一个有效性标志，我们可以用整数`$valid$`来建模，其中`$1$`表示帧被占用，`$0$`表示空闲。\n- 当前占用该帧的虚拟页面的页号，`$page\\_num$`。\n- 引用位，`$ref\\_bit \\in \\{0, 1\\}`。\n- 脏位，`$dirty\\_bit \\in \\{0, 1\\}`。\n\n模拟过程通过迭代给定引用字符串中的每次访问$(p, op)$来进行，其中$p$是页号，$op \\in \\{R, W\\}$是操作类型（读或写）。对于每次访问，模拟器首先确定是页面命中还是页面未命中（错误）。\n\n**1. 页面命中检测**\n对帧表进行线性扫描。如果找到一个帧`$j$`，满足`$page\\_table[j].valid = 1$`且`$page\\_table[j].page\\_num = p$`，则发生页面命中。\n- **命中时的操作**：根据规则，该帧的引用位被设置为`$1$`：`$page\\_table[j].ref\\_bit = 1$`。这标志着该页面最近被使用过。如果操作是写操作（`$op=W$`），则脏位也设置为`$1$`：`$page\\_table[j].dirty\\_bit = 1$`，表示该页面已被修改，如果以后被换出，则必须写回磁盘。不发生页面调入（$I$）、页面调出（$O$）或写回（$W$）。\n\n**2. 页面未命中（错误）处理**\n如果扫描完成仍未找到页面`$p$`，则发生页面错误。这需要将页面从二级存储器调入内存，因此页面调入计数器`$I$`增加`$1$`。后续操作取决于是否有空闲帧可用。\n\n- **情况2a：存在空闲帧**\n系统必须找到一个空闲帧来存放新页面。问题指定从Clock指针的当前位置开始循环扫描，以查找第一个可用的空闲帧。设该空闲帧的索引为`$frame\\_idx$`。\n- **操作**：将页面`$p$`放入此帧中。更新该帧的状态：`$valid`设置为`$1$`，`$page\\_num`设置为`$p$`，`$ref\\_bit`设置为`$1$`，如果`$op=W$`则`$dirty\\_bit$`设置为`$1$`否则为`$0$`。最后，Clock指针前移到循环缓冲区中的下一个帧：`$clock\\_hand = (frame\\_idx + 1) \\pmod{F}$`，其中`$F$`是总帧数。\n\n- **情况2b：无空闲帧（需要置换）**\n如果扫描显示没有空闲帧，则必须执行Clock置换算法来选择一个受害帧。\n- **受害者选择**：从当前的`$clock\\_hand`位置开始，算法循环检查各帧。\n  - 如果一个帧的`$ref\\_bit`为`$1$`，它将获得“第二次机会”：其`$ref\\_bit`被清除为`$0$`，并且`$clock\\_hand`前进到下一个帧。\n  - 这个过程重复进行，直到遇到一个`$ref\\_bit=0$`的帧。该帧被选为受害者。\n- **换出与置换**：\n  - 页面调出计数器`$O$`增加`$1$`。\n  - 如果受害帧的`$dirty\\_bit`为`$1$`，这意味着该页面在被覆盖之前必须保存到磁盘。相应地，写回计数器`$W$`增加`$1$`。\n  - 然后将新页面`$p$`加载到受害帧的位置。该帧的状态更新与有空闲帧的情况相同：`$page\\_num`设置为`$p$`，`$ref\\_bit`设置为`$1$`，`$dirty\\_bit$`根据`$op$`设置。\n  - Clock指针前移过新填充的帧：`$clock\\_hand = (victim\\_idx + 1) \\pmod{F}$`。\n\n对引用字符串中的每次访问重复整个过程。计数器`$I$`、`$O$`和`$W$`的最终值构成一个测试用例的结果。对测试套件中的每个测试用例，模拟都将重新初始化。最终输出将这些结果汇总成指定的列表格式。", "answer": "[[8,5,3],[3,2,2],[4,0,0],[7,5,4]]", "id": "3633455"}, {"introduction": "对算法的深刻理解不仅在于知道它如何工作，更在于能预测它在特定条件下的行为极限。这个练习是一个思想实验，它挑战你在一个特定的“稳态”场景下分析时钟算法的性能。在这个场景中，内存持续满载，且页面访问模式是严格的循环，通过推导一个页面从加载到被置换期间平均获得多少次“二次机会”，你将揭示该算法在压力下的内在运行机制。[@problem_id:3679266]", "problem": "一个单进程对 $W$ 个不同的虚拟页面执行一个无限的、严格的轮询引用串，重复地以 $p_{1}, p_{2}, \\dots, p_{W}, p_{1}, p_{2}, \\dots$ 的顺序访问页面。系统使用二次机会（时钟）页面置换算法，拥有 $N$ 个相同的物理页框，其中 $N = W - 1$。硬件在每次访问页面时将引用位 $R$ 设置为 $1$，而操作系统（OS）按如下方式实现该算法：发生页面错误时，它检查时钟指针处的页面；如果该页面的 $R = 0$，则选择将其换出；如果 $R = 1$，则操作系统设置 $R \\leftarrow 0$，前移指针，然后继续。在将发生错误的页面加载到页框中时，当前的访问会将该页面的 $R$ 位设置为 $1$。操作系统不执行任何周期性或基于计时器的引用位清除操作；引用位仅在算法检查页面并给予其二次机会时才被清除。时钟指针总是从紧跟在最近被替换的页框之后的那个页框开始。\n\n假设系统已预热至稳态，并且所有 $W$ 个页面都按照所述的严格轮询顺序被永久引用。对于一个特定的页面实例，定义随机变量 $X$ 为该页面从被加载到页框的瞬间到从内存中被换出的瞬间，被时钟指针遇到时其 $R = 1$ 并因此被给予“二次机会”的次数。\n\n仅使用二次机会算法的核心定义和给定的访问模式，确定在 $N = W - 1$ 的条件下，期望值 $\\mathbb{E}[X]$ 作为 $W$ 的函数的稳态值。将最终答案表示为单个实数；无需四舍五入。", "solution": "我们从二次机会（时钟）算法的核心定义和指定的访问模式开始分析。该算法维护一个常驻页面的循环列表，在发生页面错误时使用时钟指针扫描页框，并应用以下规则：当检查到引用位 $R = 1$ 的页框时，它将被给予“二次机会”，即重置 $R \\leftarrow 0$ 并在本次扫描中跳过它不予换出；当检查到 $R = 0$ 的页框时，该页框被选中换出。硬件在每次访问页面时都会将该页面的 $R$ 设置为 $1$。在本问题中，清除 $R$ 的唯一情况是当算法检查一个页框并给予其二次机会时。\n\n访问模式是对 $W$ 个不同页面的严格轮询，并且有 $N = W - 1$ 个页框。在稳态下，任何时刻都恰好有 $W$ 个页面中的 $N$ 个是常驻的，因此恰好有一个页面不在内存中。由于严格轮询序列中的下一次引用总是指向当前非常驻的那个唯一页面，所以在稳态下，每次引用都是一次页面错误。因此，在两次连续的页面错误之间，没有对其他常驻页面的中间命中；在两次错误之间，唯一其 $R$ 位被设置为 $1$ 的页面是刚刚为满足当前错误而加载的页面（并且那次引用将其 $R$ 设置为 $1$）。\n\n考虑时钟算法在连续错误下的动态过程：\n\n1. 定义“扫描错误”（sweep fault）为这样一种页面错误：在扫描开始时，所有 $N$ 个常驻页框的 $R$ 位都为 $1$。在这种情况下，时钟指针将检查所有 $N$ 个页框，观察到每个页框的 $R = 1$，将其重置为 $R = 0$，然后前移。经过一个完整的循环后，它返回到第一个被检查的页框，此时该页框的 $R = 0$，并将其换出。发生错误的页面被加载到该页框中，其 $R$ 位被设置为 $1$。这次扫描错误完成后，常驻集合包含 $1$ 个 $R = 1$ 的页面（新加载的页面）和 $N - 1$ 个 $R = 0$ 的页面（所有在扫描期间其引用位被清除的其他页面）。\n\n2. 在一次这样的扫描错误之后，考虑接下来的 $N - 1$ 次错误。在每一次错误中，指针将遇到的第一个页框的 $R$ 位都为 $0$（因为根据“每次引用都发生错误”的特性，自上次错误以来没有其他页面被引用过）。因此，这 $N - 1$ 次错误中的每一次都会立即换出第一个被检查的页框，而不在那一刻给予任何二次机会，并加载发生错误的页面，这会将其 $R$ 位设置为 $1$。\n\n在这 $N$ 次错误（一次扫描错误加上 $N - 1$ 次立即换出错误）之后， $N$ 个常驻页框将全部包含在最近 $N$ 次错误中加载的页面，因此每个页面的 $R$ 位都为 $1$。因此，下一次错误又是一次如步骤1所述的扫描错误。这样，该模式以 $N$ 次错误为周期重复：一次扫描错误，随后是 $N - 1$ 次立即换出错误。\n\n现在我们来分析一个特定页面实例从加载到换出所获得的二次机会次数。对于一个给定的页面，有两种可能的换出场景：\n\n- 情况 A：页面在一次扫描错误中被换出。在扫描期间，当时钟指针第一次检查到这个页面时，它的 $R$ 位必须是 $1$（因为它是在最近某次错误中加载的，并且除了加载时之外没有被引用过）。算法会给予它一次二次机会，并将 $R$ 设置为 $R \\leftarrow 0$。在同一次扫描的稍后阶段，在所有页框的 $R$ 位都被清除后，指针返回到这个页面，此时它的 $R = 0$，并将其换出。在这种情况下，该页面在被换出前恰好获得了 $1$ 次二次机会。\n\n- 情况 B：页面在一次扫描错误中幸存（即，它不是在循环返回时被选中的页框），并在随后的 $N - 1$ 次立即换出错误中的一次被换出。在紧邻的前一次扫描错误中，当这个页面被检查时，它的 $R = 1$ 并被给予了一次二次机会，所以它的 $R$ 位被清除为 $0$。由于每个中间的引用都是对非驻留页面的错误，并且不会触及这个页面，它的 $R$ 位保持为 $0$，直到时钟指针在后来的某次错误中返回到它，此时它被立即换出。在这种情况下，该页面在被换出前也恰好获得了 $1$ 次二次机会。\n\n在所述的动态过程中，这些是仅有的可能性。因此，对于每个页面实例，从加载到换出之间被给予的二次机会次数是确定性的 $X = 1$。因此，稳态期望值为\n$$\n\\mathbb{E}[X] = 1.\n$$\n这个值不依赖于 $W$，除了 $N = W - 1$ 这个约束条件，它导致了“每次引用都发生错误”的机制以及时钟算法的周期性扫描行为。", "answer": "$$\\boxed{1}$$", "id": "3679266"}]}