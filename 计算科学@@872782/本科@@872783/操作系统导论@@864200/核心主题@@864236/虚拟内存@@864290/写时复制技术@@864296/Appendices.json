{"hands_on_practices": [{"introduction": "要真正掌握写时复制（COW），关键在于理解其触发条件及其对性能的量化影响。这个练习 [@problem_id:3629158] 通过一个基本的概率模型，帮助你从第一性原理出发，推导在给定写入概率下，子进程预期会触发多少次COW页面错误。这种分析能力对于估算系统开销和理解COW在平均情况下的效率至关重要。", "problem": "一个操作系统通过通常称为 fork 的系统调用，在创建进程时实现写时复制（Copy-On-Write, COW）。fork 调用后，子进程和父进程立即共享相同的物理页面；所有共享映射都被标记为只读。当首次写入任何共享页面时，会发生一次 COW 缺页中断：内核分配一个新的物理页面，复制原始页面的内容，将发生中断的进程的页表更新为指向新的私有页面，并重试写入操作。同一进程后续对该页面的写入不会再引发 COW 缺页中断，因为该页面现在是私有且可写的。读取操作不会导致 COW 缺页中断。\n\n考虑一个进程，其地址空间由 $n$ 个虚拟内存页面组成，每个页面的大小为 $S$ 字节。fork 调用后，只有子进程可能会写入。对于这 $n$ 个页面中的每一个，子进程都独立地以概率 $p \\in [0,1]$ 对该页面进行恰好一次写入尝试，并以概率 $1-p$ 不对该页面进行任何写入。假设除了子进程自身的首次写入外，没有其他写入者，也没有其他会破坏共享的干预事件。每次 COW 缺页中断都会精确地复制一个大小为 $S$ 字节的页面。\n\n从概率论的基本原理（伯努利试验、指示器随机变量和期望的线性性）以及上面给出的 COW 的操作系统定义出发，推导一个用 $n$、$p$ 和 $S$ 表示的表达式，用于计算：\n- 子进程引发的 COW 缺页中断的期望次数，以及\n- 因 COW 而复制的总字节数的期望值。\n\n以字节为单位表示总字节数。将你的最终答案表示为一个两项的行矩阵，使用 LaTeX 的 `\\texttt{pmatrix}`，其中第一项等于 COW 缺页中断的期望次数，第二项等于复制的总字节数的期望值。最终答案中不要包含任何文字说明。", "solution": "该问题要求计算通过 `fork` 创建的子进程所引发的写时复制（COW）缺页中断的期望次数，以及因 COW 而复制的总字节数的期望值。这个问题定义明确，其科学基础植根于操作系统和概率论的原理，并包含了得出唯一解所需的所有信息。\n\n设 $n$ 为进程地址空间中的虚拟内存页面数量。\n设 $S$ 为每个页面的大小（以字节为单位）。\n设 $p$ 为子进程对任意给定页面进行写入尝试的概率。对 $n$ 个页面中每一个的写入尝试都是独立事件。\n\n当且仅当子进程尝试首次写入某个特定页面时，该页面上才会发生 COW 缺页中断。问题陈述，对于每个页面，子进程以概率 $p$ 进行恰好一次写入尝试。因此，对于一个给定的页面，发生 COW 缺页中断的概率为 $p$。\n\n为了求出 COW 缺页中断的期望次数，我们可以使用指示器随机变量来对该情况进行建模。让我们为每个页面 $i$ 定义一个指示器随机变量 $X_i$，其中 $i \\in \\{1, 2, \\dots, n\\}$。\n\n指示器随机变量 $X_i$ 定义如下：\n$$\nX_i = \\begin{cases}\n1  \\text{如果在页面 } i \\text{ 上发生 COW 缺页中断} \\\\\n0  \\text{如果在页面 } i \\text{ 上未发生 COW 缺页中断}\n\\end{cases}\n$$\n\n如果子进程写入页面 $i$，则在该页面上发生 COW 缺页中断。此事件的概率为 $p$。\n因此，$X_i$ 的概率分布为：\n$P(X_i = 1) = p$\n$P(X_i = 0) = 1-p$\n\n这是对每个页面 $i$ 的一次伯努利试验。伯努利随机变量的期望值是其成功的概率。因此，$X_i$ 的期望值为：\n$$E[X_i] = 1 \\cdot P(X_i=1) + 0 \\cdot P(X_i=0) = 1 \\cdot p + 0 \\cdot (1-p) = p$$\n\nCOW 缺页中断的总次数，我们称此随机变量为 $N_{faults}$，是所有 $n$ 个页面的指示器变量之和，因为如果 COW 发生，每个 $X_i$ 都计为一次中断。\n$$N_{faults} = \\sum_{i=1}^{n} X_i$$\n\n为了求出 COW 缺页中断的总期望次数，我们计算 $N_{faults}$ 的期望值。我们使用期望的线性性，该性质指出，随机变量之和的期望等于它们各自期望之和。无论这些随机变量是否独立，此性质都成立。在本问题中，事件被声明为独立的，但期望的线性性并不需要这个假设。\n$$E[N_{faults}] = E\\left[\\sum_{i=1}^{n} X_i\\right] = \\sum_{i=1}^{n} E[X_i]$$\n\n由于对所有页面 $i = 1, \\dots, n$，都有 $E[X_i] = p$，所以总和变为：\n$$E[N_{faults}] = \\sum_{i=1}^{n} p = n \\cdot p$$\n这就是子进程引发的 COW 缺页中断的期望次数。\n\n接下来，我们需要求出因 COW 而复制的总字节数的期望值。\n问题陈述，每次 COW 缺页中断都会导致复制一个大小为 $S$ 字节的页面。\n设 $B_{copied}$ 为表示复制的总字节数的随机变量。\n复制的总字节数是 COW 缺页中断的次数乘以每次中断复制的字节数。\n$$B_{copied} = N_{faults} \\cdot S$$\n\n我们想要找到 $B_{copied}$ 的期望值，即 $E[B_{copied}]$。\n$$E[B_{copied}] = E[N_{faults} \\cdot S]$$\n由于 $S$ 是一个常数，我们可以将其从期望中提取出来：\n$$E[B_{copied}] = S \\cdot E[N_{faults}]$$\n\n我们已经推导出 $E[N_{faults}] = np$。将此结果代入方程可得：\n$$E[B_{copied}] = S \\cdot (np) = npS$$\n这就是因 COW 而复制的总字节数的期望值。\n\n最终答案要求一个包含 COW 缺页中断期望次数和复制的总字节数期望值的两项行矩阵。\n第一项是 $E[N_{faults}] = np$。\n第二项是 $E[B_{copied}] = npS$。", "answer": "$$\\boxed{\\begin{pmatrix} np  npS \\end{pmatrix}}$$", "id": "3629158"}, {"introduction": "在理解了平均情况下的行为之后，分析系统的性能极限同样重要。此练习 [@problem_id:3629086] 构建了一个最坏情况场景，即子进程对每个共享页面都执行写操作，从而最大化COW的开销。通过计算完成这一系列操作所需的时间和内存带宽，你将学会如何识别和量化系统瓶颈，例如固定的页面错误处理开销和数据拷贝所需的时间。", "problem": "一个多处理操作系统在通过系统调用 fork 创建进程时使用写时复制 (COW) 技术。在 COW 机制下，子进程最初共享父进程的内存页面；对任何共享页面的第一次写入都会触发一次页面错误，此后操作系统会分配一个新的物理帧，并复制整个原始页面，然后才允许写入操作继续。考虑一个父进程，其私有地址空间大小为 $S$ 字节，按页面边界对齐，页面大小为 $P$ 字节。子进程执行一种最坏情况下的写入模式，通过在每个不同的页面中顺序地写入一个字节来最大化 COW 页面复制次数，其步长等于页面大小，并且从不重复访问一个页面。假设系统参数如下：\n- $S = 8\\,\\mathrm{GiB}$，其中 $1\\,\\mathrm{GiB} = 2^{30}\\,\\mathrm{bytes}$，\n- $P = 4\\,\\mathrm{KiB}$，其中 $1\\,\\mathrm{KiB} = 2^{10}\\,\\mathrm{bytes}$，\n- 操作系统处理每次页面错误的恒定开销为 $\\tau_{\\mathrm{pf}} = 2 \\times 10^{-6}\\,\\mathrm{s}$（例如，陷阱处理、页帧分配、页表更新、转译后备缓冲器 (TLB) 刷写），\n- 可用于数据移动的持续内存带宽预算为 $B_{\\mathrm{actual}} = 25\\,\\mathrm{GiB/s}$。\n\n使用以下基本事实：\n- 页面数量为 $N = S / P$。\n- 对一个先前共享的页面的 COW 写入需要复制整个页面，这在最坏情况下会引起两次大小均为 $P$ 的主存传输（一次读取旧页面和一次写入新页面），再加上应用程序实际写入的 $1$ 字节；在最坏情况下，缓存无法消除这些传输。\n- 对于持续流式传输，内存带宽通过 $t = D / B$ 将数据移动量 $D$（字节）与时间 $t$（秒）关联起来。\n\n从这些基本原理出发，推导出一个闭式表达式，用于计算在 $T_{\\mathrm{goal}} = 5.0\\,\\mathrm{s}$ 的截止日期内完成子进程在整个地址空间上每页写入一字节的操作所需的最小持续内存带宽 $B_{\\mathrm{req}}$（单位为 $\\mathrm{GiB/s}$），并在给定可用带宽 $B_{\\mathrm{actual}}$ 的情况下，计算实际完成时间 $T_{\\mathrm{actual}}$（单位为 $\\mathrm{s}$）。将 $B_{\\mathrm{req}}$ 以 $\\mathrm{GiB/s}$ 表示，将 $T_{\\mathrm{actual}}$ 以 $\\mathrm{s}$ 表示。将两个数值结果四舍五入到四位有效数字。", "solution": "问题陈述已经过验证，被认为是具有科学依据、适定且客观的。它提出了一个基于操作系统既定原则（特别是写时复制（COW）内存管理技术）的可解性能分析场景。所有必要的参数均已提供，目标也已明确定义。\n\n核心任务是确定一系列 COW 操作所需的总时间，然后利用这种关系求解所需的带宽和实际完成时间。\n\n首先，让我们根据给定的参数确定基本量。\n父进程地址空间的大小为 $S = 8\\,\\mathrm{GiB} = 8 \\times 2^{30}\\,\\mathrm{bytes} = 2^{3} \\times 2^{30}\\,\\mathrm{bytes} = 2^{33}\\,\\mathrm{bytes}$。\n页面大小为 $P = 4\\,\\mathrm{KiB} = 4 \\times 2^{10}\\,\\mathrm{bytes} = 2^{2} \\times 2^{10}\\,\\mathrm{bytes} = 2^{12}\\,\\mathrm{bytes}$。\n地址空间中的页面数量 $N$ 是总大小除以页面大小：\n$$N = \\frac{S}{P} = \\frac{2^{33}\\,\\mathrm{bytes}}{2^{12}\\,\\mathrm{bytes}} = 2^{21}$$\n数值上，$N = 2,097,152$ 个页面。\n\n问题描述了一个最坏情况，即子进程对 $N$ 个不同的页面各写入一次。每次对共享页面的这种写入都会触发一次页面错误和一次 COW 操作。完成整个序列的总时间是 $N$ 次 COW 事件各自所需时间的总和。\n\n让我们分析单个 COW 事件所需的时间 $T_{\\mathrm{fault}}$。该时间由两部分组成：\n1. 操作系统处理页面错误的恒定开销 $\\tau_{\\mathrm{pf}}$。\n2. 执行内存复制所需的时间 $t_{\\mathrm{copy}}$。\n\n问题指出，一次 COW 操作涉及读取原始页面并将其写入一个新分配的帧。这对应于每次错误的总数据传输量 $D_{\\mathrm{fault}} = P + P = 2P$ 字节。根据关系式 $t = D/B$，此数据传输所花费的时间取决于可用的内存带宽 $B$。因此，\n$$t_{\\mathrm{copy}} = \\frac{2P}{B}$$\n单次错误的总时间是开销和复制时间之和：\n$$T_{\\mathrm{fault}} = \\tau_{\\mathrm{pf}} + t_{\\mathrm{copy}} = \\tau_{\\mathrm{pf}} + \\frac{2P}{B}$$\n由于有 $N$ 个这样的独立顺序事件，完成该过程的总时间 $T_{\\mathrm{total}}$ 是单个事件时间的 $N$ 倍：\n$$T_{\\mathrm{total}}(B) = N \\times T_{\\mathrm{fault}} = N \\left( \\tau_{\\mathrm{pf}} + \\frac{2P}{B} \\right)$$\n这可以展开为：\n$$T_{\\mathrm{total}}(B) = N\\tau_{\\mathrm{pf}} + \\frac{2PN}{B}$$\n我们可以通过认识到 $PN = (S/P)P = S$ 来简化第二项。因此，传输的总数据量为 $2S$。总时间的表达式变为：\n$$T_{\\mathrm{total}}(B) = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B}$$\n这个方程是本问题的核心模型。总时间是总的固定操作系统开销 ($N\\tau_{\\mathrm{pf}}$) 和数据传输所花费的总时间 ($2S/B$) 之和。\n\n现在我们可以解决问题的两个部分。\n\n第 1 部分：推导所需的内存带宽 $B_{\\mathrm{req}}$。\n给定截止时间 $T_{\\mathrm{goal}} = 5.0\\,\\mathrm{s}$。我们需要找到能让进程恰好在此时间内完成的带宽 $B_{\\mathrm{req}}$。我们设 $T_{\\mathrm{total}}(B_{\\mathrm{req}}) = T_{\\mathrm{goal}}$：\n$$T_{\\mathrm{goal}} = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B_{\\mathrm{req}}}$$\n求解 $B_{\\mathrm{req}}$：\n$$T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}} = \\frac{2S}{B_{\\mathrm{req}}}$$\n$$B_{\\mathrm{req}} = \\frac{2S}{T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}}}$$\n这就是所需带宽的闭式表达式。现在，我们代入数值。\n首先，计算总的固定开销时间 $N\\tau_{\\mathrm{pf}}$：\n$$N\\tau_{\\mathrm{pf}} = 2^{21} \\times (2 \\times 10^{-6}\\,\\mathrm{s}) = 2,097,152 \\times 2 \\times 10^{-6}\\,\\mathrm{s} = 4.194304\\,\\mathrm{s}$$\n需要复制的总数据量为 $2S = 2 \\times 8\\,\\mathrm{GiB} = 16\\,\\mathrm{GiB}$。\n用于此数据传输的可用时间必须是 $T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}}$：\n$$T_{\\mathrm{goal}} - N\\tau_{\\mathrm{pf}} = 5.0\\,\\mathrm{s} - 4.194304\\,\\mathrm{s} = 0.805696\\,\\mathrm{s}$$\n现在我们可以计算 $B_{\\mathrm{req}}$：\n$$B_{\\mathrm{req}} = \\frac{16\\,\\mathrm{GiB}}{0.805696\\,\\mathrm{s}} \\approx 19.85981\\,\\mathrm{GiB/s}$$\n四舍五入到四位有效数字，我们得到 $B_{\\mathrm{req}} = 19.86\\,\\mathrm{GiB/s}$。\n\n第 2 部分：计算实际完成时间 $T_{\\mathrm{actual}}$。\n我们使用相同的总时间公式，但使用给定的实际带宽 $B_{\\mathrm{actual}} = 25\\,\\mathrm{GiB/s}$。\n$$T_{\\mathrm{actual}} = T_{\\mathrm{total}}(B_{\\mathrm{actual}}) = N\\tau_{\\mathrm{pf}} + \\frac{2S}{B_{\\mathrm{actual}}}$$\n我们已经计算出总开销 $N\\tau_{\\mathrm{pf}} = 4.194304\\,\\mathrm{s}$。使用实际带宽进行数据传输的时间是：\n$$\\frac{2S}{B_{\\mathrm{actual}}} = \\frac{16\\,\\mathrm{GiB}}{25\\,\\mathrm{GiB/s}} = 0.64\\,\\mathrm{s}$$\n实际总时间是这两个部分的总和：\n$$T_{\\mathrm{actual}} = 4.194304\\,\\mathrm{s} + 0.64\\,\\mathrm{s} = 4.834304\\,\\mathrm{s}$$\n四舍五入到四位有效数字，我们得到 $T_{\\mathrm{actual}} = 4.834\\,\\mathrm{s}$。\n\n所需带宽的闭式表达式为 $B_{\\mathrm{req}} = \\frac{2S}{T_{\\mathrm{goal}} - (S/P)\\tau_{\\mathrm{pf}}}$。$B_{\\mathrm{req}}$（单位 $\\mathrm{GiB/s}$）和 $T_{\\mathrm{actual}}$（单位 $\\mathrm{s}$）的数值结果分别为 $19.86$ 和 $4.834$。", "answer": "$$\\boxed{\\begin{pmatrix} 19.86  4.834 \\end{pmatrix}}$$", "id": "3629086"}, {"introduction": "写时复制并非一个孤立的机制，它与操作系统的其他子系统（如文件系统）有着复杂的交互。这个练习 [@problem_id:3629104] 将引导你深入探索一个精细但至关重要的场景：当COW应用于文件支持的私有内存映射时会发生什么。通过分析这一过程，你将揭示为何对私有映射的修改不会被写回到底层文件，并理解匿名页和页缓存之间的关键区别。", "problem": "在一个实现了请求分页、统一页缓存以及私有和共享映射标准语义的类 Unix 操作系统 (OS) 内核上，一个高级用户空间程序使用了内存映射文件。考虑一个常规的基于块的文件系统 (FS) 上大小为 $N$ 字节的常规文件。一个进程以读写方式打开该文件，并使用具有写权限的私有映射将其映射到某个虚拟地址 $X$。映射建立后，进程在映射区域内的一个位置存入一个值，从而在相应的虚拟页上引发一个写错误。\n\n请从第一性原理出发，利用以下基本事实来推理发生了什么，以及如何通过实验进行验证：\n- 虚拟内存通过每个进程的页表将虚拟页映射到物理帧；每个映射由一个页表条目 (PTE) 表示。PTE 编码了访问权限以及是否允许写入。\n- 页缓存存储按文件和偏移量索引的文件支持的页面；文件系统回写机制会将脏的文件支持的缓存页写入磁盘。\n- 文件的私有映射提供写时复制 (COW) 语义：最初，进程看到的是文件的页缓存内容；当第一次写入一个映射页面时，内核必须确保进程之间以及与底层文件的隔离。\n- 回写和通过 msync 与 fsync 进行数据同步的语义是为共享的文件支持的缓存页以及通过显式 write 系统调用写入的数据定义的。可移植操作系统接口 (POSIX) 不要求在私有映射上使用 msync 来使修改在文件中可见。\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 在文件支持的私有映射中，对一个干净的、由文件支持的页面的首次写入会触发写时复制 (COW) 错误：内核分配一个新的匿名页，复制数据，并更新进程的 PTE 以指向这个具有写权限的匿名页。原始的文件支持的页缓存页面保持干净。因为进程的脏页现在是匿名的（不在文件的页缓存中），所以文件系统回写机制不会将这些私有修改写入文件，并且在私有映射上调用 msync 或在文件描述符上调用 fsync 等操作不会将私有更改传播到文件。\n\nB. 在文件支持的私有映射中，写错误会就地将文件的页缓存页面标记为脏；因此，后台回写以及调用 msync 或 fsync 会将私有更改传播到磁盘上的文件。\n\nC. 可以设计一个决定性的用户空间测试如下：通过对一个新打开的文件描述符执行 read 操作，计算文件内容的强校验和 $H_{0}$；使用一个私有的、可写的映射来映射文件，并在映射中修改一些字节；然后使用 MS_SYNC 标志调用 msync，并在文件描述符上调用 fsync；取消映射；重新打开文件，并通过一条避免重用任何可能过时的内存中状态的路径（例如，使用 O_DIRECT 和正确对齐的缓冲读取，或者如果策略允许，则先清除缓存）读取文件来计算 $H_{1}$；最后，比较 $H_{0}$ 和 $H_{1}$。预期结果为 $H_{0}=H_{1}$，表明文件未改变，而从私有映射中读取（在取消映射前）会返回修改后的字节。\n\nD. 要使私有映射的修改到达文件，只需在修改后对文件描述符调用 fsync 即可；fsync 将定位并回写进程的私有脏页。\n\nE. 一个合适的测试是：在另一个进程中用共享映射来映射同一个文件，然后在第一个进程修改其私有映射并调用 msync 后，通过共享映射来读取；如果回写机制起作用，共享映射应该反映私有映射的写入，因此看到修改后的字节将证实内核已将私有脏页回写到文件。", "solution": "题目描述了一个类 Unix 操作系统中的标准场景，涉及文件的私有、可写内存映射。首先评估题目的有效性。\n\n**问题验证**\n\n题目陈述是有效的。它在科学上基于操作系统设计的公认原则，包括虚拟内存、请求分页、页缓存以及私有 (`MAP_PRIVATE`) 和共享 (`MAP_SHARED`) 内存映射之间的区别。所提供的基本事实准确地描述了像 Linux 这样的现代内核如何处理这些概念。这个问题提法恰当、客观且自包含，提出了一个关于系统行为的清晰问题，可以根据给定的原则进行推理。这是一个非平凡的问题，探究了内存管理和文件系统子系统之间微妙的相互作用。\n\n**从第一性原理推导**\n\n控制文件私有、可写映射行为的核心概念是**写时复制 (Copy-On-Write, COW)**。正如题目的基本事实所规定的，该机制对于提供隔离至关重要。让我们追踪一下事件的序列。\n\n1.  **映射建立**：进程请求文件的私有、可写映射。内核为指定的地址范围配置进程的虚拟内存区域 (VMA)，并注明这是给定文件的可写、私有映射。然后，内核填充该范围的进程页表条目 (PTE)。关键的是，为了实施 COW，内核在硬件页表中将这些 PTE 标记为**只读**，尽管 VMA 本身被标记为可写。这些 PTE 最初将指向位于内核统一页缓存中的文件相应页面。\n\n2.  **写错误**：进程试图向映射的虚拟地址范围内的字节写入。CPU 的内存管理单元 (MMU) 检测到对一个被其 PTE 标记为只读的页面的写入尝试。此违规行为触发一个页错误 (page fault)，这是一个进入内核的陷阱。\n\n3.  **内核错误处理 (COW)**：内核的页错误处理程序检查该错误。它确定错误发生在一个进程合法可写的 VMA 内的地址上，但错误是由对只读 PTE 的写入触发的。这种特定的组合表示私有映射上的 COW 错误。内核执行以下操作：\n    a. 分配一个新的、空的物理页帧。这个页面是**匿名内存**；它不与任何文件关联，专属于该进程。\n    b. 将原始文件支持页面（来自页缓存）的全部内容复制到这个新的匿名页面。\n    c. 更新进程中发生错误的虚拟页的 PTE。新的 PTE 现在指向新的匿名页面，并且其访问权限被更改为**读写**。\n    d. 内核从错误处理程序返回，CPU 重新执行导致错误的指令。现在写入成功，因为该页面被映射为可写。\n\n4.  **COW 的后果**：\n    *   **隔离**：进程现在拥有该页面的一个私有副本。它所做的任何修改都局限于这个匿名页，对可能映射了同一文件的其他进程不可见。文件页缓存中的原始页面保持不变，因此是“干净的”（非脏）。\n    *   **失去文件支持**：进程的虚拟页不再由文件支持；它由匿名内存支持。就像堆或栈内存一样，如果这个页面因内存压力需要被换出，它将被写入系统的交换区，而不是原始文件。\n    *   **同步语义**：像 `msync` 和 `fsync` 这样的系统调用旨在将文件的页缓存与磁盘存储同步。由于进程修改后的页面是匿名的，不再是文件页缓存的一部分，这些系统调用无法感知它，也没有机制将其内容写入文件。POSIX 标准明确指出了这种行为，声明 `msync` 对 `MAP_PRIVATE` 映射的效果是未指定的，在像 Linux 这样的系统实践中，它对传播私有更改没有影响。\n\n**逐项分析**\n\n**A. 在文件支持的私有映射中，对一个干净的、由文件支持的页面的首次写入会触发写时复制 (COW) 错误：内核分配一个新的匿名页，复制数据，并更新进程的 PTE 以指向这个具有写权限的匿名页。原始的文件支持的页缓存页面保持干净。因为进程的脏页现在是匿名的（不在文件的页缓存中），所以文件系统回写机制不会将这些私有修改写入文件，并且在私有映射上调用 msync 或在文件描述符上调用 fsync 等操作不会将私有更改传播到文件。**\n此陈述是对 COW 机制及其对私有文件映射后果的精确和完整描述。它正确地指出了匿名页的创建、原始页缓存页面的隔离，以及由此导致的 `msync` 或 `fsync` 无法持久化私有修改。\n**结论**：**正确**。\n\n**B. 在文件支持的私有映射中，写错误会就地将文件的页缓存页面标记为脏；因此，后台回写以及调用 msync 或 fsync 会将私有更改传播到磁盘上的文件。**\n此陈述是错误的。它描述的是**共享** (`MAP_SHARED`) 映射的行为，其中修改直接在页缓存页面上进行，从而对其他进程可见并受回写机制影响。这种行为与 `MAP_PRIVATE` 映射的“私有”和“写时复制”语义背道而驰。\n**结论**：**错误**。\n\n**C. 可以设计一个决定性的用户空间测试如下：通过对一个新打开的文件描述符执行 read 操作，计算文件内容的强校验和 $H_{0}$；使用一个私有的、可写的映射来映射文件，并在映射中修改一些字节；然后使用 MS_SYNC 标志调用 msync，并在文件描述符上调用 fsync；取消映射；重新打开文件，并通过一条避免重用任何可能过时的内存中状态的路径（例如，使用 O_DIRECT 和正确对齐的缓冲读取，或者如果策略允许，则先清除缓存）读取文件来计算 $H_{1}$；最后，比较 $H_{0}$ 和 $H_{1}$。预期结果为 $H_{0}=H_{1}$，表明文件未改变，而从私有映射中读取（在取消映射前）会返回修改后的字节。**\n此陈述概述了一个科学上合理的实验步骤，以验证理论行为。它正确地指出了各个步骤：建立基线 ($H_{0}$)，执行私有修改，尝试同步，然后在仔细避免缓存效应的情况下重新测量磁盘上的状态 ($H_{1}$)。预测结果 ($H_{0}=H_{1}$) 与我们关于私有修改不会写入文件的推导一致。额外的检查，即映射本身持有修改后的数据，证实了写入发生在进程的私有内存中。\n**结论**：**正确**。\n\n**D. 要使私有映射的修改到达文件，只需在修改后对文件描述符调用 fsync 即可；fsync 将定位并回写进程的私有脏页。**\n此陈述是错误的。如前所述，修改后的页面是匿名的，并与内核文件系统层管理的文件数据结构断开连接。`fsync` 系统调用作用于文件描述符及其在页缓存中的相关脏页。它没有机制来查找和回写进程的私有匿名页。\n**结论**：**错误**。\n\n**E. 一个合适的测试是：在另一个进程中用共享映射来映射同一个文件，然后在第一个进程修改其私有映射并调用 msync 后，通过共享映射来读取；如果回写机制起作用，共享映射应该反映私有映射的写入，因此看到修改后的字节将证实内核已将私有脏页回写到文件。**\n此陈述描述了一个有效的实验设置，但对预期结果得出了错误的结论。COW 机制确保了隔离。第一个进程的写入创建了一个私有副本。带有共享映射的第二个进程将继续看到来自页缓存的原始、未修改的数据。因此，从共享映射中读取**不会**显示修改。该测试实际上可以很好地证明隔离属性，但该陈述错误地暗示可能会看到修改后的字节，这是不正确的。其前提（“如果回写机制对私有页面起作用”）本身就是错误的。\n**结论**：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "3629104"}]}