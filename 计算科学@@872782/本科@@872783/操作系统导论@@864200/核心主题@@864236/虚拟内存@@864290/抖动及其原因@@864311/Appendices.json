{"hands_on_practices": [{"introduction": "颠簸最直观的症状是系统看起来非常繁忙，但CPU却几乎没有执行任何有用的计算。这个练习将构建一个简洁而深刻的模型来量化这一现象，即著名的“CPU利用率悬崖”。通过推导CPU利用率与缺页率之间的关系，我们将计算并比较在使用传统硬盘（HDD）和固态硬盘（SSD）作为交换设备时，系统性能崩溃的临界点在何处，从而揭示I/O性能对颠簸的决定性影响。[@problem_id:3688430]", "problem": "一个单核系统运行一个内存密集型工作负载，其指令流会产生一连串稳定的内存引用。在没有缺页的情况下，每次引用会消耗中央处理器（CPU）固定的计算时间 $t_{c}$。当发生缺页时，进程会被阻塞，直到该故障被处理完毕后才会恢复执行。假设在整个工作负载中，缺页服务和有效的指令执行之间没有有用的重叠（例如，因为所有可运行的进程在统计上是相同的，并且在故障频繁时倾向于同时被阻塞），并忽略预取和回写效应。平均缺页服务时间 $t_{pf}$ 是固定的操作系统开销 $t_{os}$ 和设备服务时间之和，而设备服务时间本身是页面访问延迟和传输时间之和。\n\n考虑两种交换存储技术：机械硬盘（HDD）和固态硬盘（SSD）。页面大小为 $S=8\\ \\mathrm{KB}$。对于HDD，平均寻道时间为 $t_{\\mathrm{seek,H}}=6.00\\ \\mathrm{ms}$，平均旋转延迟为 $t_{\\mathrm{rot,H}}=4.17\\ \\mathrm{ms}$，顺序传输带宽为 $B_{\\mathrm{H}}=160\\ \\mathrm{MB/s}$。对于SSD，访问延迟（控制器和闪存访问）为 $t_{\\mathrm{acc,S}}=0.060\\ \\mathrm{ms}$，顺序传输带宽为 $B_{\\mathrm{S}}=1000\\ \\mathrm{MB/s}$。两种设备的操作系统开销相同，均为 $t_{os}=0.100\\ \\mathrm{ms}$。取 $1\\ \\mathrm{KB}=1024\\ \\mathrm{bytes}$ 和 $1\\ \\mathrm{MB}=10^{6}\\ \\mathrm{bytes}$。\n\n假设在无故障情况下，每次引用的计算时间为 $t_{c}=100\\ \\mathrm{ns}$，并假设在给定的内存压力下，每次引用发生缺页的概率为 $p$。使用第一性原理和上述参数：\n\n- 推导每种设备的平均缺页服务时间 $t_{pf}$ 的表达式，并计算其值。\n- 仅使用CPU利用率 $C$ 等于用于有效计算的时间分数的定义，用 $t_{c}$、$p$ 和 $t_{pf}$ 表示 $C$，并对每种设备在 $p=1.0\\times10^{-3}$ 时的 $C$ 值进行评估。\n- 将CPU利用率降至阈值 $C_{\\min}=0.50$ 的点定义为颠簸的开始。对于每种设备，推导当 $C=C_{\\min}$ 时每次引用的临界缺页概率 $p^{\\star}$。然后，将颠簸边界移动因子 $s$ 定义为SSD的临界概率与HDD的临界概率之比，即 $s = p^{\\star}_{\\mathrm{SSD}}/p^{\\star}_{\\mathrm{HDD}}$。\n\n最终答案只报告 $s$ 的值，四舍五入到三位有效数字。报告的最终答案中不包含任何单位。在您的推导和中间计算中，时间单位使用毫秒，带宽单位使用兆字节/秒，并将任何中间的CPU利用率表示为0到1之间的纯小数。", "solution": "该问题经检验是自洽的，科学上基于操作系统性能建模的原理，并且是良构的。我们可以进行正式的求解。\n\n目标是确定颠簸边界移动因子 $s$，其定义为固态硬盘（SSD）与机械硬盘（HDD）的临界缺页概率之比，$s = p^{\\star}_{\\mathrm{SSD}}/p^{\\star}_{\\mathrm{HDD}}$。这需要多步推导。\n\n首先，我们推导给定存储设备的平均缺页服务时间 $t_{pf}$ 的表达式。问题陈述 $t_{pf}$ 是固定操作系统开销 $t_{os}$ 和设备服务时间之和。设备服务时间是访问延迟和数据传输时间之和。\n$$t_{pf} = t_{os} + t_{\\text{access}} + t_{\\text{transfer}}$$\n传输时间 $t_{\\text{transfer}}$ 是页面大小 $S$ 除以设备的顺序传输带宽 $B$。\n$$t_{\\text{transfer}} = \\frac{S}{B}$$\n我们必须首先将页面大小 $S=8\\ \\mathrm{KB}$ 转换为与给定带宽单位（$\\mathrm{MB/s}$）一致的兆字节（MB）单位。问题规定 $1\\ \\mathrm{KB}=1024\\ \\mathrm{bytes}$ 且 $1\\ \\mathrm{MB}=10^{6}\\ \\mathrm{bytes}$。\n$$S = 8\\ \\mathrm{KB} = 8 \\times 1024\\ \\mathrm{bytes} = 8192\\ \\mathrm{bytes}$$\n$$S = \\frac{8192}{10^{6}}\\ \\mathrm{MB} = 0.008192\\ \\mathrm{MB}$$\n\n现在，我们为每种设备计算 $t_{pf}$。\n\n对于机械硬盘（HDD）：\n访问延迟是寻道时间和旋转延迟之和：$t_{\\text{access,H}} = t_{\\mathrm{seek,H}} + t_{\\mathrm{rot,H}}$。\n给定值为 $t_{\\mathrm{seek,H}}=6.00\\ \\mathrm{ms}$ 和 $t_{\\mathrm{rot,H}}=4.17\\ \\mathrm{ms}$。\n$$t_{\\text{access,H}} = 6.00\\ \\mathrm{ms} + 4.17\\ \\mathrm{ms} = 10.17\\ \\mathrm{ms}$$\n传输时间使用带宽 $B_{\\mathrm{H}}=160\\ \\mathrm{MB/s}$ 计算。\n$$t_{\\text{transfer,H}} = \\frac{0.008192\\ \\mathrm{MB}}{160\\ \\mathrm{MB/s}} = 0.0000512\\ \\mathrm{s} = 0.0512\\ \\mathrm{ms}$$\n对于HDD，当 $t_{os}=0.100\\ \\mathrm{ms}$ 时，总缺页服务时间为：\n$$t_{pf,\\mathrm{H}} = t_{os} + t_{\\text{access,H}} + t_{\\text{transfer,H}} = 0.100\\ \\mathrm{ms} + 10.17\\ \\mathrm{ms} + 0.0512\\ \\mathrm{ms} = 10.3212\\ \\mathrm{ms}$$\n\n对于固态硬盘（SSD）：\n访问延迟直接给定为 $t_{\\text{access,S}} = t_{\\mathrm{acc,S}} = 0.060\\ \\mathrm{ms}$。\n传输时间使用带宽 $B_{\\mathrm{S}}=1000\\ \\mathrm{MB/s}$ 计算。\n$$t_{\\text{transfer,S}} = \\frac{0.008192\\ \\mathrm{MB}}{1000\\ \\mathrm{MB/s}} = 0.000008192\\ \\mathrm{s} = 0.008192\\ \\mathrm{ms}$$\n对于SSD，当 $t_{os}=0.100\\ \\mathrm{ms}$ 时，总缺页服务时间为：\n$$t_{pf,\\mathrm{S}} = t_{os} + t_{\\text{access,S}} + t_{\\text{transfer,S}} = 0.100\\ \\mathrm{ms} + 0.060\\ \\mathrm{ms} + 0.008192\\ \\mathrm{ms} = 0.168192\\ \\mathrm{ms}$$\n\n接下来，我们推导CPU利用率 $C$ 的表达式。CPU利用率是CPU用于有效计算的时间占总时间的分数。我们来考虑每次内存引用的平均耗时。一次引用有 $p$ 的概率导致缺页，有 $(1-p)$ 的概率不导致缺页。\n一次无故障引用的时间是计算时间 $t_c$。\n一次有故障的引用时间包括计算时间 $t_c$ 加上缺页服务时间 $t_{pf}$，在此期间CPU被阻塞（空闲）。一次缺页引用事件的总耗时为 $t_c + t_{pf}$。\n每次引用的平均总时间 $T_{\\text{avg}}$ 是加权平均值：\n$$T_{\\text{avg}} = (1-p)t_c + p(t_c + t_{pf}) = t_c - pt_c + pt_c + pt_{pf} = t_c + p \\cdot t_{pf}$$\n每次引用的有效计算时间总是 $t_c$。\n因此，CPU利用率 $C$ 是有效计算时间与平均总时间之比：\n$$C = \\frac{t_c}{T_{\\text{avg}}} = \\frac{t_c}{t_c + p \\cdot t_{pf}}$$\n题目要求我们评估在 $p = 1.0 \\times 10^{-3}$ 时每种设备的 $C$ 值。给定 $t_c = 100\\ \\mathrm{ns} = 1.0 \\times 10^{-4}\\ \\mathrm{ms}$。\n对于HDD：\n$$C_{\\mathrm{H}} = \\frac{1.0 \\times 10^{-4}\\ \\mathrm{ms}}{1.0 \\times 10^{-4}\\ \\mathrm{ms} + (1.0 \\times 10^{-3}) \\cdot (10.3212\\ \\mathrm{ms})} = \\frac{1.0 \\times 10^{-4}}{1.0 \\times 10^{-4} + 0.0103212} = \\frac{1.0 \\times 10^{-4}}{0.0104212} \\approx 0.00960$$\n对于SSD：\n$$C_{\\mathrm{S}} = \\frac{1.0 \\times 10^{-4}\\ \\mathrm{ms}}{1.0 \\times 10^{-4}\\ \\mathrm{ms} + (1.0 \\times 10^{-3}) \\cdot (0.168192\\ \\mathrm{ms})} = \\frac{1.0 \\times 10^{-4}}{1.0 \\times 10^{-4} + 0.000168192} = \\frac{1.0 \\times 10^{-4}}{0.000268192} \\approx 0.3729$$\n\n现在，我们找出颠簸开始时的临界缺页概率 $p^{\\star}$，其定义为 $C=C_{\\min}=0.50$。\n我们将 $C$ 的表达式设为等于 $C_{\\min}$，然后解出 $p^{\\star}$：\n$$C_{\\min} = \\frac{t_c}{t_c + p^{\\star} \\cdot t_{pf}}$$\n$$t_c + p^{\\star} \\cdot t_{pf} = \\frac{t_c}{C_{\\min}}$$\n$$p^{\\star} \\cdot t_{pf} = \\frac{t_c}{C_{\\min}} - t_c = t_c \\left(\\frac{1}{C_{\\min}} - 1\\right) = t_c \\frac{1-C_{\\min}}{C_{\\min}}$$\n$$p^{\\star} = \\frac{t_c}{t_{pf}} \\left(\\frac{1-C_{\\min}}{C_{\\min}}\\right)$$\n当 $C_{\\min}=0.50$ 时，项 $\\frac{1-C_{\\min}}{C_{\\min}} = \\frac{1-0.50}{0.50} = \\frac{0.50}{0.50} = 1$。临界概率的表达式简化为：\n$$p^{\\star} = \\frac{t_c}{t_{pf}}$$\n\n最后，我们推导颠簸边界移动因子 $s$，它是临界概率之比：\n$$s = \\frac{p^{\\star}_{\\mathrm{SSD}}}{p^{\\star}_{\\mathrm{HDD}}}$$\n代入推导出的 $p^{\\star}$ 表达式：\n$$s = \\frac{t_c / t_{pf,\\mathrm{S}}}{t_c / t_{pf,\\mathrm{H}}} = \\frac{t_{pf,\\mathrm{H}}}{t_{pf,\\mathrm{S}}}$$\n移动因子就是缺页服务时间之比。现在我们可以使用先前计算出的 $t_{pf,\\mathrm{H}}$ 和 $t_{pf,\\mathrm{S}}$ 的值来计算 $s$ 的值：\n$$s = \\frac{10.3212\\ \\mathrm{ms}}{0.168192\\ \\mathrm{ms}} \\approx 61.3655...$$\n按要求四舍五入到三位有效数字，我们得到：\n$$s \\approx 61.4$$\n这个结果表明，与使用HDD相比，使用SSD的系统在其CPU利用率下降到50%的颠簸阈值之前，可以容忍高出61倍以上的缺页概率。", "answer": "$$\\boxed{61.4}$$", "id": "3688430"}, {"introduction": "上一个练习表明，过高的缺页服务时间是灾难性的。这个练习将深入探究导致服务时间变长的根本原因：I/O子系统的饱和。我们将交换设备看作一个服务能力有限的服务器，通过分析其I/O请求队列，计算系统在不导致队列无限增长（即I/O拥塞）的情况下所能承受的最大总缺页率。这个练习帮助我们从排队论的视角理解颠簸，即缺页引起的I/O请求到达率超过了设备的服务率。[@problem_id:3688426]", "problem": "一个多道程序系统的虚拟内存由单个交换设备支持。该交换设备是一个固态硬盘 (SSD)，其峰值服务容量为 $C = 6.0 \\times 10^{4}$ 每秒输入/输出操作数 (IOPS)。操作系统使用请求分页和集群预取：每次缺页时，平均有 $k = 3$ 个页面被读入内存。页面置换策略为最近最少使用 (LRU) 算法，并且由于空闲帧池较小，平均有 $p_{d} = 0.4$ 的比例被置换出的页面是脏页，需要在缺页时进行同步写回。该交换设备与一个稳定的后台文件缓存写回操作共享，该操作持续消耗 $B = 1.2 \\times 10^{4}$ IOPS。假设来自缺页和后台流量的 I/O 请求是独立的，并且交换设备可以被建模为一个具有明确定义的长期平均服务率的单服务器队列。\n\n从基于操作系统性能和单服务器队列行为的队列稳定性第一性原理出发，推导出一个表达式，用于计算能避免交换设备队列无限增长的最大总缺页率 $PFR_{\\max}$（以每秒缺页次数为单位）。然后，根据给定参数计算 $PFR_{\\max}$ 的数值。以每秒缺页次数表示最终速率，并将答案四舍五入到四位有效数字。", "solution": "问题要求推导出一个多道程序系统在不导致其交换设备队列无限增长的情况下所能承受的最大总缺页率 $PFR_{\\max}$。该解将从单服务器队列稳定性的第一性原理推导得出。\n\n单服务器队列稳定性的基本原理是，请求的长期平均到达率 $\\lambda$ 必须小于或等于长期平均服务率 $\\mu$。如果 $\\lambda < \\mu$，则可以避免队列无限增长。在边界条件 $\\lambda = \\mu$ 时达到理论最大容量。\n\n设 $C$ 为交换设备的峰值服务容量，给定为 $C = 6.0 \\times 10^{4}$ 每秒输入/输出操作数 (IOPS)。这代表了服务器的最大服务率 $\\mu$。\n$$ \\mu = C $$\n\n到达交换设备的I/O请求总到达率 $\\lambda_{total}$ 是源自两个独立来源的请求之和：后台文件系统活动和缺页服务。\n$$ \\lambda_{total} = \\lambda_{PF} + \\lambda_{BG} $$\n其中 $\\lambda_{PF}$ 是由缺页引起的I/O速率，而 $\\lambda_{BG}$ 是由后台活动引起的I/O速率。\n\n问题指出，有一个稳定的后台文件缓存写回操作，消耗 $B = 1.2 \\times 10^{4}$ IOPS。这构成了后台到达率。\n$$ \\lambda_{BG} = B $$\n\n接下来，我们必须将由缺页引起的到达率 $\\lambda_{PF}$ 表示为总缺页率（我们表示为 $PFR$，单位为每秒缺页次数）的函数。每次缺页都会在交换设备上产生一定数量的I/O操作。这些操作包括将页面读入内存的读操作和换出脏页的写操作。\n\n1.  **读操作**：操作系统使用请求分页和集群预取。每次缺页时，平均从交换设备读入 $k = 3$ 个页面到内存中。假设每次页面读取对应于单个I/O操作，则每次缺页的读I/O次数为 $k$。\n    $$ \\text{I/Os}_{\\text{read}}/\\text{fault} = k $$\n\n2.  **写操作**：一次缺页需要释放内存中的一个页框。问题明确指出，采用最近最少使用 (LRU) 策略，并且平均有 $p_{d} = 0.4$ 的比例被置换出的页框是脏的。脏页必须在它的页框被重用之前写回到交换设备。这被指定为同步写回。干净的页面不需要写回。因此，每次缺页的平均写I/O次数为 $p_{d}$。\n    $$ \\text{I/Os}_{\\text{write}}/\\text{fault} = p_{d} \\times 1 + (1 - p_{d}) \\times 0 = p_{d} $$\n\n每次缺页产生的I/O操作总平均数是平均读操作和写操作次数之和。\n$$ \\text{I/Os}/\\text{fault} = k + p_{d} $$\n由缺页产生的总I/O到达率 $\\lambda_{PF}$ 是缺页率 ($PFR$) 与每次缺页的平均I/O次数的乘积。\n$$ \\lambda_{PF} = PFR \\times (k + p_{d}) $$\n\n现在，我们可以写出到达交换设备的总到达率的表达式：\n$$ \\lambda_{total} = PFR \\times (k + p_{d}) + B $$\n\n为避免队列无限增长，总到达率不能超过设备的服务容量。当总到达率等于服务率时，达到最大可持续缺页率 $PFR_{\\max}$。\n$$ \\lambda_{total} = \\mu $$\n$$ PFR_{\\max} \\times (k + p_{d}) + B = C $$\n\n我们现在可以求解 $PFR_{\\max}$：\n$$ PFR_{\\max} \\times (k + p_{d}) = C - B $$\n$$ PFR_{\\max} = \\frac{C - B}{k + p_{d}} $$\n这就是推导出的最大总缺页率的表达式。项 $C - B$ 代表可用于缺页服务的I/O容量，而 $k + p_{d}$ 是每次缺页的I/O成本。\n\n现在，我们使用给定参数计算数值：\n- $C = 6.0 \\times 10^{4}$ IOPS\n- $B = 1.2 \\times 10^{4}$ IOPS\n- $k = 3$\n- $p_{d} = 0.4$\n\n首先，计算分母，即每次缺页的平均I/O次数：\n$$ k + p_{d} = 3 + 0.4 = 3.4 $$\n\n接下来，计算分子，即可用于分页的I/O服务率：\n$$ C - B = (6.0 \\times 10^{4}) - (1.2 \\times 10^{4}) = 4.8 \\times 10^{4} \\text{ IOPS} $$\n\n最后，计算 $PFR_{\\max}$：\n$$ PFR_{\\max} = \\frac{4.8 \\times 10^{4}}{3.4} \\approx 14117.647... \\text{ faults/second} $$\n\n问题要求答案四舍五入到四位有效数字。\n$$ PFR_{\\max} \\approx 14120 \\text{ faults/second} $$\n用标准科学记数法表示，这是 $1.412 \\times 10^{4}$ 次缺页/秒。", "answer": "$$ \\boxed{1.412 \\times 10^{4}} $$", "id": "3688426"}, {"introduction": "缓解颠簸并非总是“增加内存”这么简单，系统设计中的一些优化决策可能带来意想不到的副作用。这个练习将探讨现代计算机体系结构中一个常见的权衡：大页面（Large Pages）的使用。我们将分析大页面在如何减少TLB未命中（TLB miss）的同时，却可能因内部碎片而增加进程的实际内存占用，反而将系统推入颠簸状态。这个案例研究揭示了在内存管理中，理解不同组件之间复杂的相互作用和设计权衡是多么重要。[@problem_id:3688450]", "problem": "一个计算系统运行三个独立的进程，分别表示为 $P_1$、$P_2$ 和 $P_3$，每个进程都在不相交的内存区域上进行紧密循环。该系统使用请求分页机制，这三个进程可用的物理内存量是固定的，记为 $B$，内存管理器可以在两种页面大小之间进行选择。每个进程时间片的转译后备缓冲器 (TLB) 容量为 $C$ 个条目。\n\n场景定义：\n- Peter J. Denning 的工作集模型将进程 $i$ 在时间窗口 $[t,t+\\Delta]$ 内的工作集 $W_i(t,\\Delta)$ 定义为该进程在该时间窗口内引用的不同虚拟页面的集合；工作集大小以页面数为单位，为 $|W_i(t,\\Delta)|$。进程 $i$ 在该窗口内所需的总工作集字节数等于 $|W_i(t,\\Delta)| \\cdot S_{\\text{page}}$，其中 $S_{\\text{page}}$ 是当前的页面大小。\n- 抖动是一种由于过多页面错误导致分页子系统主导执行的状态，通常在所有进程的总驻留需求超过可用物理内存 $B$ 时触发，从而导致页面被不断换出并再次发生页面错误。\n- 转译后备缓冲器 (TLB) 是近期虚拟到物理页面映射的缓存。其容量 $C$ 个条目限制了在一个时间片内可以同时保存多少个不同的页面映射；如果 $|W_i(t,\\Delta)| \\gg C$，预计会发生持续的 TLB 未命中。\n\n工作负载和参数：\n- 每个进程 $P_i$ 重复循环遍历 $k_i$ 个不相交的区域，每个区域的长度为 $L$，步幅等于小页面的大小，因此在 $[t,t+\\Delta]$ 期间，区域内的每个小页面都会被访问到。\n- 参数为 $L = 1.5\\,\\mathrm{MiB}$，$k_1 = 100$，$k_2 = 80$，$k_3 = 60$，$B = 400\\,\\mathrm{MiB}$，以及 $C = 128$。\n- 考虑两种页面大小：小页面 $p_s = 4\\,\\mathrm{KiB}$ 和大页面 $p_\\ell = 2\\,\\mathrm{MiB}$。\n\n假设 $[t,t+\\Delta]$ 足够长，以至于每个进程在该时间窗口内都会访问其所有区域中的所有地址，并且操作系统给予这三个进程对 $B$ 字节物理内存的独占访问权（$B$ 中不包括内存的其他用途）。对于 TLB，假设在一个进程的时间片内，其条目仅由该进程的引用进行预热，相关的覆盖范围度量是 $|W_i(t,\\Delta)| \\leq C$ 与 $|W_i(t,\\Delta)| \\gg C$ 的对比。\n\n对于此工作负载，以下哪些陈述是正确的？\n\nA. 在使用 $p_\\ell$ 的情况下，每个进程的 TLB 未命中率相对于 $p_s$ 显著下降，但系统在 $[t,t+\\Delta]$ 内会越过抖动阈值，因为总工作集字节数超过了 $B$；在使用 $p_s$ 的情况下，系统不会发生抖动。\n\nB. 对于此工作负载，工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）不受页面大小影响，因此从 $p_s$ 变为 $p_\\ell$ 不会使系统更早地进入抖动状态。\n\nC. 使用 $p_\\ell$ 时，每个进程的工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）都低于 $C$，因此在时间片内 TLB 预热后，未命中率保持在较低水平；使用 $p_s$ 时，工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）远超 $C$，因此预计会发生持续的 TLB 未命中。\n\nD. 增加页面大小总是会延迟抖动的发生，因为需要的页面更少；因此，使用 $p_\\ell$ 更早地越过抖动阈值是不可能的。\n\nE. 对于给定的参数，使用 $p_s$ 时的总工作集字节数为 $360\\,\\mathrm{MiB}$，而使用 $p_\\ell$ 时为 $480\\,\\mathrm{MiB}$；因此只有 $p_\\ell$ 会越过抖动阈值 $B = 400\\,\\mathrm{MiB}$。", "solution": "在进行求解之前，首先分析问题陈述的有效性。\n\n### 第一步：提取已知条件\n- **进程：** $P_1$、$P_2$、$P_3$（独立，在不相交的内存区域上循环）。\n- **物理内存：** $B = 400\\,\\mathrm{MiB}$。\n- **TLB 容量：** $C = 128$ 个条目。\n- **工作负载：** 进程 $P_i$ 在 $k_i$ 个不相交的区域上循环。\n- **区域大小：** $L = 1.5\\,\\mathrm{MiB}$。\n- **进程参数：** $k_1 = 100$，$k_2 = 80$，$k_3 = 60$。\n- **页面大小：** 小页面 $p_s = 4\\,\\mathrm{KiB}$，大页面 $p_\\ell = 2\\,\\mathrm{MiB}$。\n- **工作集定义：** $W_i(t,\\Delta)$ 是进程 $i$ 在 $[t,t+\\Delta]$ 时间段内引用的不同虚拟页面的集合。\n- **工作集字节数：** $|W_i(t,\\Delta)| \\cdot S_{\\text{page}}$。\n- **抖动条件：** 总驻留需求（总工作集字节数）> $B$。\n- **TLB 未命中条件：** 如果 $|W_i(t,\\Delta)| \\gg C$，则持续未命中。\n- **假设：** 时间窗口 $[t,t+\\Delta]$ 足以让每个进程访问其所有区域。这些进程独占访问 $B$ 字节的内存。\n\n### 第二步：使用提取的已知条件进行验证\n该问题在科学上基于操作系统内存管理的原理，包括请求分页、工作集、抖动和转译后备缓冲器 (TLB)。所提供的定义是标准的，并与文献（例如 Denning 的工作集模型）一致。问题陈述清晰，提供了所有必要的数值参数（$L, k_i, B, C, p_s, p_\\ell$）和明确的定义，从而可以得到一个唯一的、可计算的解。语言客观而精确。参数并非物理上不可能或相互矛盾。该问题不包含说明中列出的任何使之无效的缺陷。\n\n### 第三步：结论与行动\n该问题是 **有效的**。将推导出解答。\n\n### 推导\n问题的核心是评估系统在两种不同页面大小配置下的性能：小页面（$p_s$）和大页面（$p_\\ell$）。对于每种配置，我们必须计算：\n1.  每个进程的工作集大小（以页面为单位），$|W_i(t,\\Delta)|$，以分析 TLB 性能。\n2.  总工作集大小（以字节为单位），$\\sum_i |W_i(t,\\Delta)| \\cdot S_{\\text{page}}$，以分析抖动情况。\n\n首先，我们确定单位换算：\n$1\\,\\mathrm{MiB} = 2^{20}$ 字节。\n$1\\,\\mathrm{KiB} = 2^{10}$ 字节。\n$p_s = 4\\,\\mathrm{KiB} = 4 \\cdot 2^{10}$ 字节。\n$p_\\ell = 2\\,\\mathrm{MiB} = 2 \\cdot 2^{20}$ 字节。\n$L = 1.5\\,\\mathrm{MiB} = 1.5 \\cdot 2^{20}$ 字节。\n$B = 400\\,\\mathrm{MiB}$。\n\n每个进程 $P_i$ *引用* 的总内存为 $M_i = k_i \\cdot L$，因为区域是不相交的。\n$M_1 = 100 \\cdot 1.5\\,\\mathrm{MiB} = 150\\,\\mathrm{MiB}$。\n$M_2 = 80 \\cdot 1.5\\,\\mathrm{MiB} = 120\\,\\mathrm{MiB}$。\n$M_3 = 60 \\cdot 1.5\\,\\mathrm{MiB} = 90\\,\\mathrm{MiB}$。\n\n**情况 1：小页面 ($S_{\\text{page}} = p_s = 4\\,\\mathrm{KiB}$)**\n\n**工作集大小（以页面为单位）和 TLB 分析：**\n进程 $P_i$ 工作集中的页面数是覆盖总引用内存 $M_i$ 所需的不同小页面的数量。\n$|W_i(t,\\Delta)|_s = \\frac{M_i}{p_s}$\n$|W_1(t,\\Delta)|_s = \\frac{150\\,\\mathrm{MiB}}{4\\,\\mathrm{KiB}} = \\frac{150 \\cdot 2^{20}}{4 \\cdot 2^{10}} = \\frac{150 \\cdot 1024}{4} = 150 \\cdot 256 = 38400$ 页。\n$|W_2(t,\\Delta)|_s = \\frac{120\\,\\mathrm{MiB}}{4\\,\\mathrm{KiB}} = \\frac{120 \\cdot 1024}{4} = 120 \\cdot 256 = 30720$ 页。\n$|W_3(t,\\Delta)|_s = \\frac{90\\,\\mathrm{MiB}}{4\\,\\mathrm{KiB}} = \\frac{90 \\cdot 1024}{4} = 90 \\cdot 256 = 23040$ 页。\n\n对于所有三个进程， $|W_i(t,\\Delta)|_s$ 都在数万的量级，远大于 TLB 容量 $C=128$。\n$|W_i(t,\\Delta)|_s \\gg C$。\n因此，使用小页面时，所有进程都将经历持续的高 TLB 未命中率。\n\n**总工作集大小（以字节为单位）和抖动分析：**\n问题陈述中提到“区域内的每个小页面都会被访问到”，这意味着工作集字节数等于总引用内存，因为内部碎片极小。\n总工作集字节数 = $\\sum M_i = 150\\,\\mathrm{MiB} + 120\\,\\mathrm{MiB} + 90\\,\\mathrm{MiB} = 360\\,\\mathrm{MiB}$。\n我们将其与可用物理内存 $B=400\\,\\mathrm{MiB}$进行比较。\n由于 $360\\,\\mathrm{MiB} < 400\\,\\mathrm{MiB}$，总需求未超过可用内存。系统不会发生抖动。\n\n**情况 2：大页面 ($S_{\\text{page}} = p_\\ell = 2\\,\\mathrm{MiB}$)**\n\n**工作集大小（以页面为单位）和 TLB 分析：**\n进程 $P_i$ 访问 $k_i$ 个不相交的区域，每个区域的大小为 $L = 1.5\\,\\mathrm{MiB}$。页面大小为 $p_\\ell = 2\\,\\mathrm{MiB}$。由于每个区域的大小 $L$ 小于页面大小 $p_\\ell$，每个区域必须使用至少一个大页面映射到内存中。因为这些区域是不相交的，我们假设每个区域都需要自己独特的大页面。在页面数量方面最经济的映射方式是将每个区域对齐在单个大页面内。这给出了工作集大小的下限。\n$|W_i(t,\\Delta)|_\\ell = (\\text{区域数量}) \\times (\\text{每个区域的页面数}) = k_i \\times 1 = k_i$。\n$|W_1(t,\\Delta)|_\\ell = k_1 = 100$ 页。\n$|W_2(t,\\Delta)|_\\ell = k_2 = 80$ 页。\n$|W_3(t,\\Delta)|_\\ell = k_3 = 60$ 页。\n\n我们将其与 TLB 容量 $C=128$ 进行比较。\n对于所有三个进程， $|W_i(t,\\Delta)|_\\ell \\le 128$。\n因此，使用大页面时，每个进程的工作集都适合 TLB。在初始预热期之后，预计每个进程的 TLB 未命中率会很低。\n\n**总工作集大小（以字节为单位）和抖动分析：**\n总工作集字节数是所有进程使用的总页面数乘以页面大小。这考虑了内部碎片，即为一个较小的 $1.5\\,\\mathrm{MiB}$ 区域分配了一个完整的 $2\\,\\mathrm{MiB}$ 页面。\n大页面的总数 = $\\sum_i |W_i(t,\\Delta)|_\\ell = 100 + 80 + 60 = 240$ 页。\n总工作集字节数 = $240 \\text{ 页} \\times 2\\,\\mathrm{MiB/页} = 480\\,\\mathrm{MiB}$。\n我们把这个需求与可用的物理内存 $B=400\\,\\mathrm{MiB}$ 进行比较。\n由于 $480\\,\\mathrm{MiB} > 400\\,\\mathrm{MiB}$，总需求超过了可用内存。系统将会发生抖动。\n\n### 选项评估\n\n**A. 在使用 $p_\\ell$ 的情况下，每个进程的 TLB 未命中率相对于 $p_s$ 显著下降，但系统在 $[t,t+\\Delta]$ 内会越过抖动阈值，因为总工作集字节数超过了 $B$；在使用 $p_s$ 的情况下，系统不会发生抖动。**\n- **TLB 性能：** 使用 $p_s$ 时，$|W_i|_s \\gg 128$（高未命中率）。使用 $p_\\ell$ 时，$|W_i|_\\ell \\le 128$（低未命中率）。未命中率确实显著下降。这部分是正确的。\n- **使用 $p_\\ell$ 时的抖动：** 总工作集为 $480\\,\\mathrm{MiB}$，超过了 $B=400\\,\\mathrm{MiB}$。系统发生抖动。这部分是正确的。\n- **使用 $p_s$ 时的抖动：** 总工作集为 $360\\,\\mathrm{MiB}$，小于 $B=400\\,\\mathrm{MiB}$。系统不发生抖动。这部分是正确的。\n整个陈述与推导出的结果一致。\n**结论：正确**\n\n**B. 对于此工作负载，工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）不受页面大小影响，因此从 $p_s$ 变为 $p_\\ell$ 不会使系统更早地进入抖动状态。**\n前提“工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）不受页面大小影响”是错误的。对于 $P_1$， $|W_1|_s = 38400$ 页，而 $|W_1|_\\ell = 100$ 页。页面数量发生了巨大变化。因此，结论没有依据，而且也是不正确的，因为我们的分析表明系统在使用 $p_\\ell$ 时确实会发生抖动。\n**结论：错误**\n\n**C. 使用 $p_\\ell$ 时，每个进程的工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）都低于 $C$，因此在时间片内 TLB 预热后，未命中率保持在较低水平；使用 $p_s$ 时，工作集大小 $|W_i(t,\\Delta)|$（以页面为单位）远超 $C$，因此预计会发生持续的 TLB 未命中。**\n- **使用 $p_\\ell$ 时：** $|W_1|_\\ell=100$， $|W_2|_\\ell=80$， $|W_3|_\\ell=60$。都小于或等于 $C=128$。如陈述所述，这导致了低未命中率。这部分是正确的。\n- **使用 $p_s$ 时：** $|W_1|_s=38400$， $|W_2|_s=30720$， $|W_3|_s=23040$。都远超 $C=128$。如陈述所述，这导致了持续的高未命中率。这部分是正确的。\n该陈述准确地描述了两种页面大小下的 TLB 行为。\n**结论：正确**\n\n**D. 增加页面大小总是会延迟抖动的发生，因为需要的页面更少；因此，使用 $p_\\ell$ 更早地越过抖动阈值是不可能的。**\n前提“增加页面大小总是会延迟抖动的发生”是一个有缺陷的概括。虽然可能使用更少的页面，但更大的页面会由于内部碎片而显著增加总内存需求，正如本问题所示。总需求从 $360\\,\\mathrm{MiB}$ 增加到 $480\\,\\mathrm{MiB}$。使用 $p_\\ell$ 发生抖动是“不可能的”这一结论与我们的推导直接矛盾。\n**结论：错误**\n\n**E. 对于给定的参数，使用 $p_s$ 时的总工作集字节数为 $360\\,\\mathrm{MiB}$，而使用 $p_\\ell$ 时为 $480\\,\\mathrm{MiB}$；因此只有 $p_\\ell$ 会越过抖动阈值 $B = 400\\,\\mathrm{MiB}$。**\n- **使用 $p_s$ 时的总工作集：** 计算为 $\\sum M_i = 360\\,\\mathrm{MiB}$。这是正确的。\n- **使用 $p_\\ell$ 时的总工作集：** 计算为 $(\\sum k_i) \\cdot p_\\ell = 240 \\cdot 2\\,\\mathrm{MiB} = 480\\,\\mathrm{MiB}$。这是正确的。\n- **关于抖动的结论：** $360\\,\\mathrm{MiB} < 400\\,\\mathrm{MiB}$（使用 $p_s$ 不会抖动）。$480\\,\\mathrm{MiB} > 400\\,\\mathrm{MiB}$（使用 $p_\\ell$ 会抖动）。结论是正确的。\n该陈述提供了正确的数值结果，并从中得出了正确的结论。\n**结论：正确**", "answer": "$$\\boxed{ACE}$$", "id": "3688450"}]}