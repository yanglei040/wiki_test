{"hands_on_practices": [{"introduction": "理论知识与实际应用之间往往存在一道鸿沟。例如，文件中的数据结构很少会自然地与内存页的边界对齐。本练习将探讨如何正确使用内存映射来访问这些未对齐的数据，这要求我们深刻理解 `mmap` 系统调用对文件偏移量的页对齐要求，并熟练运用指针运算来精确定位映射区域内的数据。通过解决这个问题 [@problem_id:3658292]，你将掌握在真实世界场景中安全高效地访问文件数据的核心技巧。", "problem": "给定一个大文件，它存储了一个由定长记录组成的数组，这些记录背靠背地排列，记录之间没有填充。记录大小为 $R = 3600$ 字节。在一个兼容可移植操作系统接口 (POSIX) 的系统上，系统页面大小为 $P = 4096$ 字节，并且内存映射系统调用要求文件偏移量参数是 $P$ 的倍数。文件长度为 $L = 10{,}000{,}000$ 字节。你希望通过内存映射或定位读取来访问索引为 $i = 523$ 的记录。\n\n你可以假定的基本事实：\n- 虚拟内存映射是在页面粒度 $P$ 上创建和保护的。\n- 内存映射系统调用要求文件偏移量是 $P$ 的倍数。\n- 第 $i$ 条记录从文件偏移量 $O = i \\cdot R$ 开始。\n\n设 $O = i \\cdot R$ 为记录起始位置的字节偏移量。设 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 为不超过 $O$ 的最大页面对齐偏移量，并设 $\\Delta = O - A$ 为记录起始位置相对于 $A$ 的页内位移。假设映射返回一个基地址 $b$，对应于文件偏移量 $A$ 和长度 $\\ell$。\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 为了精确映射第 $i$ 条记录所需的字节，计算 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 和 $\\Delta = O - A$，以偏移量 $A$ 和长度 $\\ell = \\Delta + R$ 调用内存映射，然后使用指针算术在 $r = b + \\Delta$ 处寻址记录。只要 $O + R \\leq L$，即使 $O$ 未页面对齐，此操作也是安全的。\n\nB. 可以直接用偏移量 $O$ 调用内存映射；内核会隐式地将 $O$ 向下取整到一个页面边界，因此你可以设置 $\\ell = R$ 并使用 $b$ 作为记录指针。\n\nC. 使用偏移量为 $O$、长度为 $R$ 的定位读取（pread），返回的数据与通过正确的页面对齐映射和指针调整访问记录所得到的数据相同，并且它不要求偏移量 $O$ 是页面对齐的。只要 $O + R \\leq L$ 并且文件没有被并发截断，这种做法符合标准且是安全的。\n\nD. 映射长度 $\\ell$ 必须向上取整为页面大小的倍数，因此必须设置 $\\ell = \\left\\lceil \\frac{\\Delta + R}{P} \\right\\rceil \\cdot P$；否则，映射调用会违反接口规范。\n\nE. 对于 $R = 3600$，$i = 523$ 和 $P = 4096$ 的特定情况，我们有 $\\Delta + R > P$，因此记录相对于 $A$ 跨越了两个页面。如果错误地选择 $\\ell = R$（忽略了 $\\Delta$），解引用从 $b$ 开始的偏移量为 $[\\Delta, \\Delta + R)$ 的字节最终会访问到第二个页面，并因映射长度不足而产生故障。\n\nF. 如果 $O + R$ 超过 $L$ 的字节数少于 $P$ 字节，记录的超出部分可以通过映射安全读取并显示为零，因此只要 $\\ell \\geq \\Delta + R$，读取完整的 $R$ 字节就是安全的。", "solution": "用户希望我扮演一位一丝不苟、要求严格的 STEM 领域教授，来解决一个与内存映射文件相关的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   记录大小: $R = 3600$ 字节。\n-   系统页面大小: $P = 4096$ 字节。\n-   系统兼容 POSIX。\n-   内存映射系统调用要求文件偏移量参数是 $P$ 的倍数。\n-   文件长度: $L = 10,000,000$ 字节。\n-   目标记录索引: $i = 523$。\n-   基本假设：虚拟内存映射是在页面粒度 $P$ 上创建和保护的。\n-   基本假设：内存映射系统调用要求文件偏移量是 $P$ 的倍数。\n-   基本假设：第 $i$ 条记录从文件偏移量 $O = i \\cdot R$ 开始。\n-   定义：$O = i \\cdot R$ 是记录起始位置的字节偏移量。\n-   定义：$A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 是不超过 $O$ 的最大页面对齐偏移量。\n-   定义：$\\Delta = O - A$ 是记录起始位置相对于 $A$ 的页内位移。\n-   定义：映射返回一个基地址 $b$，对应于文件偏移量 $A$ 和长度 $\\ell$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准分析问题陈述：\n\n-   **科学基础**：该问题基于操作系统核心且成熟的概念，特别是 POSIX 兼容系统上的内存管理和文件 I/O。`mmap`（页面对齐的偏移量）的规则和 `pread` 的一般行为是对这些系统调用的事实性正确表述。该问题在科学上是合理的。\n-   **定义明确**：该问题提供了所有必要的数据（$R, P, L, i$）和清晰、形式化的定义（$O, A, \\Delta$），以分析情况并评估给定的陈述。可以确定一组明确的正确和错误陈述。\n-   **客观性**：语言技术性强、精确，没有任何主观性或歧义。\n-   **不完整或矛盾的设置**：问题是自包含且内部一致的。提供的“基本事实”加强了所涉及系统调用的标准行为。\n-   **不切实际或不可行**：页面大小、记录大小和文件长度的数值都在典型计算场景的实际范围内。\n-   **不恰当或结构不良**：问题结构良好，通过标准定义引导分析，将文件偏移量相对于页面边界进行分解。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。这是一个关于正确使用 `mmap` 和 `pread` 系统调用及其常见陷阱的良好问题。可以继续进行解题过程。\n\n### 解题推导\n\n首先，我们为给定参数计算具体数值。\n记录索引为 $i = 523$。\n记录大小为 $R = 3600$ 字节。\n页面大小为 $P = 4096$ 字节。\n文件长度为 $L = 10,000,000$ 字节。\n\n1.  **计算记录的起始偏移量 $O$**：\n    $O = i \\cdot R = 523 \\cdot 3600 = 1,882,800$ 字节。\n\n2.  **验证记录是否在文件边界内**：\n    记录占据字节范围 $[O, O + R - 1]$。记录的末尾在偏移量 $O + R - 1 = 1,882,800 + 3600 - 1 = 1,886,399$ 处。\n    由于 $1,886,399  10,000,000 = L$，整个记录都包含在文件内。\n\n3.  **计算页面对齐的基偏移量 $A$**：\n    `mmap` 调用需要一个作为页面大小 $P$ 倍数的偏移量。因此，我们必须找到包含偏移量 $O$ 的页面的起始位置。\n    $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P = \\left\\lfloor \\frac{1,882,800}{4096} \\right\\rfloor \\cdot 4096$\n    $1,882,800 \\div 4096 \\approx 459.6679$\n    $A = \\lfloor 459.6679 \\rfloor \\cdot 4096 = 459 \\cdot 4096 = 1,880,064$ 字节。\n\n4.  **计算页内位移 $\\Delta$**：\n    这是记录起始位置相对于页面对齐映射起始位置的偏移量。\n    $\\Delta = O - A = 1,882,800 - 1,880,064 = 2736$ 字节。\n\n有了这些值，我们现在可以分析此记录的内存映射原理。\n-   `mmap` 系统调用必须使用 `offset = A = 1,880,064` 来调用。\n-   映射将返回一个对应于文件偏移量 $A$ 的基指针 $b$。\n-   所需记录从文件偏移量 $O$ 开始。在虚拟地址空间中，这对应于地址 $b + \\Delta$。\n-   要访问大小为 $R$ 的整个记录，我们需要能够从地址 $b + \\Delta$ 读取到 $b + \\Delta + R - 1$。\n-   这意味着映射区域必须至少延伸到这个地址。映射的长度 $\\ell$ 必须满足 $b + \\ell - 1 \\geq b + \\Delta + R - 1$，简化为 $\\ell \\geq \\Delta + R$。\n-   所需的最小映射长度是 $\\ell_{min} = \\Delta + R = 2736 + 3600 = 6336$ 字节。\n\n### 逐项分析\n\n**A. 为了精确映射第 $i$ 条记录所需的字节，计算 $A = \\left\\lfloor \\frac{O}{P} \\right\\rfloor \\cdot P$ 和 $\\Delta = O - A$，以偏移量 $A$ 和长度 $\\ell = \\Delta + R$ 调用内存映射，然后使用指针算术在 $r = b + \\Delta$ 处寻址记录。只要 $O + R \\leq L$，即使 $O$ 未页面对齐，此操作也是安全的。**\n\n该陈述准确地描述了映射一个不从页面边界开始的文件区域的标准过程。\n-   偏移量必须是页面对齐的，因此使用 $A$ 是正确的。\n-   长度必须足以覆盖从映射开始（$A$）到记录结束（$O+R$）的数据。所需的长度是 $(O+R) - A = (O-A) + R = \\Delta+R$。所以，设置 $\\ell = \\Delta+R$ 是正确的最小长度。\n-   记录指针 $r$ 必须从映射的基地址 $b$ 调整页内位移 $\\Delta$，所以 $r = b + \\Delta$ 是正确的。\n-   该过程专为 $O$ 未页面对齐的情况设计，而条件 $O+R \\leq L$ 确保操作不会试图访问超出文件定义长度的数据。\n陈述的所有部分都与 `mmap` 的 POSIX 标准一致。\n\n**结论：正确。**\n\n**B. 可以直接用偏移量 $O$ 调用内存映射；内核会隐式地将 $O$ 向下取整到一个页面边界，因此你可以设置 $\\ell = R$ 并使用 $b$ 作为记录指针。**\n\n这个陈述根本上是错误的。`mmap` 的 POSIX 标准非常严格：`offset` 参数必须是页面大小的倍数。在这个问题中，$O = 1,882,800$ 不是 $P=4096$ 的倍数。使用非页面对齐的偏移量调用 `mmap` 将会失败，返回 `MAP_FAILED` 并将 `errno` 变量设置为 `EINVAL`（无效参数）。内核不会隐式地纠正无效的偏移量；它会拒绝该系统调用。\n\n**结论：错误。**\n\n**C. 使用偏移量为 $O$、长度为 $R$ 的定位读取（pread），返回的数据与通过正确的页面对齐映射和指针调整访问记录所得到的数据相同，并且它不要求偏移量 $O$ 是页面对齐的。只要 $O + R \\leq L$ 并且文件没有被并发截断，这种做法符合标准且是安全的。**\n\n这个陈述正确地描述了 `pread` 系统调用。\n-   `pread` 从给定的偏移量读取指定数量的字节。其签名为 `pread(fd, buf, count, offset)`。\n-   与 `mmap` 相比，`pread` 在某些任务中的一个关键特性和优势是其 `offset` 参数没有任何对齐要求。\n-   因此，使用偏移量 $O$ 和长度 $R$ 调用 `pread` 是直接且正确地将记录读入缓冲区的方​​法。\n-   获得的数据将与通过正确配置的内存映射访问的数据相同。\n-   安全条件（$O+R \\leq L$ 且没有并发截断）是有效且为保证正确性所必需的。该陈述完全准确。\n\n**结论：正确。**\n\n**D. 映射长度 $\\ell$ 必须向上取整为页面大小的倍数，因此必须设置 $\\ell = \\left\\lceil \\frac{\\Delta + R}{P} \\right\\rceil \\cdot P$；否则，映射调用会违反接口规范。**\n\n这是一个常见的误解。虽然内核以页面粒度管理内存并执行实际的映射，但传递给 `mmap` 系统调用本身的 `length` 参数并不要求是页面大小的倍数。`length` 参数定义了进程可访问区域的大小。如果进程试图访问距离基指针 `b` 大于或等于 `length` 的偏移量处的内存，它将收到一个 `SIGSEGV` 信号，即使底层的页面已被映射。指定所需的确切长度（例如 $\\ell = \\Delta+R$）是完全有效且通常是可取的，这并不违反 `mmap` 接口。\n\n**结论：错误。**\n\n**E. 对于 $R = 3600$，$i = 523$ 和 $P = 4096$ 的特定情况，我们有 $\\Delta + R  P$，因此记录相对于 $A$ 跨越了两个页面。如果错误地选择 $\\ell = R$（忽略了 $\\Delta$），解引用从 $b$ 开始的偏移量为 $[\\Delta, \\Delta + R)$ 的字节最终会访问到第二个页面，并因映射长度不足而产生故障。**\n\n让我们验证一下数值方面的说法。\n-   我们计算出 $\\Delta = 2736$ 字节，并且给定 $R = 3600$ 和 $P = 4096$。\n-   检查跨度：$\\Delta + R = 2736 + 3600 = 6336$ 字节。\n-   由于 $6336  4096$，我们有 $\\Delta + R  P$。这是正确的。记录从映射的第一个页面内 $2736$ 字节的偏移处开始，并延续 $3600$ 字节，因此延伸到了第二个页面。\n-   现在，考虑错误情景：`mmap` 以正确的偏移量 $A$ 调用，但长度不正确，为 $\\ell = R = 3600$。\n-   进程的有效虚拟地址范围是从 $b$ 到 $b + \\ell - 1$，即 $[b, b+3599]$。\n-   代码将尝试从地址 $b + \\Delta$ 访问到 $b + \\Delta + R - 1$。\n-   这对应于地址范围 $[b+2736, b+2736+3600-1] = [b+2736, b+6335]$。\n-   访问从 $b+2736$ 开始，这在有效的映射范围 $[b, b+3599]$ 之内。\n-   但是，访问一直持续到 $b+6335$。由于 $6335  3599$，任何超出 $b+3599$ 的访问都超出了请求的映射长度 $\\ell=3600$。\n-   这样的访问将导致分段错误（`SIGSEGV`）。故障的原因恰恰是映射长度不足。该陈述是对这一错误的正确分析。\n\n**结论：正确。**\n\n**F. 如果 $O + R$ 超过 $L$ 的字节数少于 $P$ 字节，记录的超出部分可以通过映射安全读取并显示为零，因此只要 $\\ell \\geq \\Delta + R$，读取完整的 $R$ 字节就是安全的。**\n\n这个陈述对映射超出文件末尾（EOF）时的行为提出了一个主张。根据 POSIX 标准，如果一个映射包含了文件结束符（EOF）所在的页面，那么对该页面内超出 EOF 的地址的任何引用都会被零填充。但是，对任何对应于完全超出 EOF 的*整个页面*中的文件偏移量的内存地址的引用，都将导致一个 `SIGBUS` 信号。\n条件“$O + R$ 超过 $L$ 的字节数少于 $P$ 字节”不足以保证安全。考虑一个长度为 $L = 4097$（刚刚进入第二个页面，其中 $P=4096$）的文件。假设一次读取的记录使得 $O+R = 8192$（第三个页面的开始）。这里，$(O+R)-L  4096 = P$。然而，这次读取试图访问一个完全超出文件末尾的页面中的地址，这将触发一个 `SIGBUS`。读取是不安全的。只有当整个读取操作都包含在拥有 EOF 的部分页面内时，安全性才成立。该陈述关于安全性的主张过于笼统，因此是错误的。\n\n**结论：错误。**", "answer": "$$\\boxed{ACE}$$", "id": "3658292"}, {"introduction": "处理远大于可用虚拟地址空间的数据是一个经典的系统设计挑战，在 32 位系统中尤为突出。本练习模拟了这样一个场景：你需要在有限且碎片化的虚拟地址空间中，高效地遍历一个巨型文件。通过这个实践 [@problem_id:3658332]，你将学会如何在地址空间碎片、映射开销和 I/O 吞吐量等多重约束下，计算出最优的滑动窗口大小，从而深入理解性能优化与系统资源管理之间的权衡。", "problem": "一个$32$位进程运行在一个操作系统（OS）上，该操作系统的内核永久占用虚拟地址空间的顶部$1\\,\\mathrm{GiB}$，剩余用户虚拟地址空间的大小为$U=3\\,\\mathrm{GiB}$。系统页面大小为$P=4\\,\\mathrm{KiB}$，分配粒度为$G=64\\,\\mathrm{KiB}$，因此任何内存映射文件视图的基地址和长度都必须按$G$的倍数对齐。内存映射接口会在每次映射之前和之后紧邻的位置自动强制施加一个$64\\,\\mathrm{KiB}$的保护区域，该区域不能被视图使用。单个映射视图的最大允许大小为$1\\,\\mathrm{GiB}$。该进程当前的分配导致用户空间碎片化，使得空闲用户空间恰好由四个不相交的连续空洞组成，大小分别为$768\\,\\mathrm{MiB}$、$512\\,\\mathrm{MiB}$、$192\\,\\mathrm{MiB}$和$64\\,\\mathrm{MiB}$。\n\n您必须通过在最大的可用空洞内的一个固定基地址上重复映射一个固定大小的窗口、取消映射、然后在同一基地址上重新映射下一个文件段（一种滑动固定基址策略），来顺序遍历一个大小为$F=137\\,\\mathrm{GiB}$的特大文件。每个窗口的映射-取消映射周期会产生$t_{m}=2.5\\times 10^{-3}\\,\\mathrm{s}$的开销，该开销与窗口大小无关。通过内存映射窗口访问时，存储子系统可维持$B=1.6\\,\\mathrm{GiB/s}$的顺序读取吞吐量。假设映射开销和数据传输时间线性相加得出总墙钟时间。所有映射和大小都必须按$G$的倍数对齐，并且必须遵守保护区域的规定。\n\n从基本的虚拟内存原理（有限的虚拟地址空间、页面和粒度对齐的映射以及连续性约束）出发，执行以下操作：\n- 在给定约束条件下，确定滑动策略允许的最大固定窗口大小$W$。\n- 计算使用此窗口大小$W$覆盖整个文件所需的映射窗口数量。\n- 使用简单的碎片化风险代理指标$r = 1 - L/F_{\\text{free}}$（其中$L$是最大空闲空洞的大小，$F_{\\text{free}}$是总空闲用户空间大小）来评估$r$。\n- 推导并计算使用滑动策略遍历整个文件的总时间$T_{\\text{total}}(W)$。\n\n将您计算出的$T_{\\text{total}}$的最终数值答案四舍五入到四位有效数字，并以秒为单位表示。您提交的最终答案必须是这个四舍五入后的单一数字。", "solution": "首先对问题进行验证，以确保其有科学依据、适定且客观。\n\n### 步骤 1：提取已知条件\n- 进程架构：一个$32$位进程。\n- 内核虚拟地址空间保留：顶部$1\\,\\mathrm{GiB}$。\n- 用户虚拟地址空间大小：$U=3\\,\\mathrm{GiB}$。\n- 系统页面大小：$P=4\\,\\mathrm{KiB}$。\n- 分配粒度：$G=64\\,\\mathrm{KiB}$。\n- 对齐约束：内存映射文件视图的基地址和长度必须按$G$的倍数对齐。\n- 保护区域：每个映射区域前后自动强制施加$64\\,\\mathrm{KiB}$。\n- 最大视图大小：$1\\,\\mathrm{GiB}$。\n- 空闲用户空间碎片情况：四个不相交的连续空洞，大小分别为$H_1=768\\,\\mathrm{MiB}$、$H_2=512\\,\\mathrm{MiB}$、$H_3=192\\,\\mathrm{MiB}$和$H_4=64\\,\\mathrm{MiB}$。\n- 待遍历的总文件大小：$F=137\\,\\mathrm{GiB}$。\n- 遍历策略：滑动固定基址（在固定基地址上重复映射-取消映射一个固定大小的窗口）。\n- 映射-取消映射周期开销：$t_{m}=2.5\\times 10^{-3}\\,\\mathrm{s}$。\n- 顺序读取吞吐量：$B=1.6\\,\\mathrm{GiB/s}$。\n- 总时间模型：映射开销和数据传输时间线性相加。\n- 碎片化风险代理指标定义：$r = 1 - L/F_{\\text{free}}$，其中$L$是最大空闲空洞的大小，$F_{\\text{free}}$是总空闲用户空间大小。\n- 最终答案要求：将$T_{\\text{total}}$四舍五入到四位有效数字。\n\n### 步骤 2：使用提取的已知条件进行验证\n对问题陈述进行有效性分析。\n- **科学依据**：所提出的概念是操作系统理论中的标准概念。一个$32$位地址空间对应$2^{32}$字节，即$4\\,\\mathrm{GiB}$。内核空间（$1\\,\\mathrm{GiB}$）和用户空间（$3\\,\\mathrm{GiB}$）之间的划分是一种常见的内存布局。内存映射文件、页面大小、分配粒度、保护区域和对齐约束都是虚拟内存管理中现实且成熟的概念。该问题具有科学依据。\n- **适定性**：问题清楚地定义了所有必要的参数、约束和关系。它要求计算可以从已知条件中推导出的特定量（$W$、$N$、$r$、$T_{\\text{total}}$）。解题路径是唯一且稳定的。\n- **客观性**：问题使用精确的技术语言陈述，没有主观或模糊的术语。\n- **完整性和一致性**：所提供的数据是自洽的。$3\\,\\mathrm{GiB}$的用户空间与$4\\,\\mathrm{GiB}$的总空间减去$1\\,\\mathrm{GiB}$的内核空间是一致的。所有单位和数值都已指定。各项约束互不矛盾。例如，保护区域大小（$64\\,\\mathrm{KiB}$）等于分配粒度（$G=64\\,\\mathrm{KiB}$），这是一个常见且逻辑上的简化。\n- **可行性**：文件大小、吞吐量和映射开销的数值都在现代计算系统的合理范围内。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是一个定义良好且自洽、基于成熟计算机科学原理的问题。可以继续进行求解。\n\n---\n\n### 解题推导\n\n我们将依次解决问题的每个部分。我们为计算建立一致的单位。我们将使用二进制前缀，其中$1\\,\\mathrm{KiB} = 2^{10}$字节，$1\\,\\mathrm{MiB} = 2^{20}$字节，$1\\,\\mathrm{GiB} = 2^{30}$字节。\n\n分配粒度为$G=64\\,\\mathrm{KiB}$。\n保护区域大小也是$64\\,\\mathrm{KiB}$，我们可以将其表示为$G$。\n\n**1. 确定允许的最大固定窗口大小 $W$。**\n滑动窗口策略在最大的可用空洞内使用一个固定的基地址。最大的空洞是$L = H_1 = 768\\,\\mathrm{MiB}$。\n一个大小为$W$的内存映射视图需要一块连续的虚拟地址空间。这个块必须能容纳视图本身以及两个保护区域。\n所需的总空间$S_{\\text{req}}$为：\n$$S_{\\text{req}} = (\\text{Guard Before}) + W + (\\text{Guard After})$$\n$$S_{\\text{req}} = G + W + G = W + 2G$$\n这个所需的连续空间必须完全容纳在最大的空洞$L$中。\n$$W + 2G \\le L$$\n问题陈述，视图的长度$W$必须是分配粒度$G$的倍数。因此，设$W = kG$，其中$k$为正整数。\n将此代入不等式：\n$$kG + 2G \\le L \\implies (k+2)G \\le L$$\n$$k+2 \\le \\frac{L}{G}$$\n我们需要计算$L/G$。\n$$L = 768\\,\\mathrm{MiB} = 768 \\times 1024\\,\\mathrm{KiB} = 786432\\,\\mathrm{KiB}$$\n$$G = 64\\,\\mathrm{KiB}$$\n$$\\frac{L}{G} = \\frac{786432\\,\\mathrm{KiB}}{64\\,\\mathrm{KiB}} = 12288$$\n所以，$k+2 \\le 12288$，这意味着$k \\le 12286$。\n$k$的最大整数值为$12286$。因此，允许的最大窗口大小$W$为：\n$$W = k_{\\text{max}}G = 12286 \\times 64\\,\\mathrm{KiB} = 786304\\,\\mathrm{KiB}$$\n以MiB表示：\n$$W = \\frac{786304}{1024}\\,\\mathrm{MiB} = 767.875\\,\\mathrm{MiB}$$\n我们还必须遵守最大视图大小为$1\\,\\mathrm{GiB}$的限制。由于$767.875\\,\\mathrm{MiB}  1024\\,\\mathrm{MiB}$（$1\\,\\mathrm{GiB}$），此约束得到满足。\n\n**2. 计算映射窗口的数量 $N$。**\n使用大小为$W$的窗口遍历总大小为$F=137\\,\\mathrm{GiB}$的文件。窗口数量$N$是总文件大小除以窗口大小，并向上取整到下一个整数（向上取整函数），因为文件的任何剩余部分都需要一次完整的映射操作。\n$$N = \\left\\lceil \\frac{F}{W} \\right\\rceil$$\n让我们将$F$和$W$都用相同的单位表示，例如GiB。\n$$F = 137\\,\\mathrm{GiB}$$\n$$W = 767.875\\,\\mathrm{MiB} = \\frac{767.875}{1024}\\,\\mathrm{GiB} = 0.7498779296875\\,\\mathrm{GiB}$$\n$$N = \\left\\lceil \\frac{137}{0.7498779296875} \\right\\rceil = \\left\\lceil 182.697... \\right\\rceil$$\n为了精确计算，我们使用以$G$为单位的值：\n注意，$1\\,\\mathrm{GiB} = 1024\\,\\mathrm{MiB} = 1024 \\times 1024\\,\\mathrm{KiB} = 16384 \\times 64\\,\\mathrm{KiB} = 16384 G$。\n所以，$F = 137 \\times 16384 G = 2244608 G$。\n而$W = 12286 G$。\n$$N = \\left\\lceil \\frac{2244608 G}{12286 G} \\right\\rceil = \\left\\lceil \\frac{2244608}{12286} \\right\\rceil = \\left\\lceil 182.697... \\right\\rceil = 183$$\n因此，需要$183$个映射窗口。\n\n**3. 评估碎片化风险代理指标 $r$。**\n该代理指标定义为$r = 1 - L/F_{\\text{free}}$。\n$L$是最大空闲空洞的大小：$L = 768\\,\\mathrm{MiB}$。\n$F_{\\text{free}}$是总空闲用户空间，即所有空洞大小的总和。\n$$F_{\\text{free}} = H_1 + H_2 + H_3 + H_4 = 768\\,\\mathrm{MiB} + 512\\,\\mathrm{MiB} + 192\\,\\mathrm{MiB} + 64\\,\\mathrm{MiB}$$\n$$F_{\\text{free}} = 1536\\,\\mathrm{MiB}$$\n现在我们计算$r$：\n$$r = 1 - \\frac{L}{F_{\\text{free}}} = 1 - \\frac{768\\,\\mathrm{MiB}}{1536\\,\\mathrm{MiB}} = 1 - \\frac{1}{2} = 0.5$$\n\n**4. 推导并计算总时间 $T_{\\text{total}}(W)$。**\n总时间是总映射开销和总数据传输时间之和。\n$$T_{\\text{total}} = T_{\\text{map}} + T_{\\text{transfer}}$$\n总映射开销是映射-取消映射周期数$N$乘以每个周期的开销$t_m$。\n$$T_{\\text{map}} = N \\times t_m = 183 \\times (2.5 \\times 10^{-3}\\,\\mathrm{s}) = 457.5 \\times 10^{-3}\\,\\mathrm{s} = 0.4575\\,\\mathrm{s}$$\n总数据传输时间是总文件大小$F$除以持续吞吐量$B$。\n$$T_{\\text{transfer}} = \\frac{F}{B} = \\frac{137\\,\\mathrm{GiB}}{1.6\\,\\mathrm{GiB/s}} = \\frac{137}{1.6}\\,\\mathrm{s} = 85.625\\,\\mathrm{s}$$\n总时间是这两个部分的总和：\n$$T_{\\text{total}} = 0.4575\\,\\mathrm{s} + 85.625\\,\\mathrm{s} = 86.0825\\,\\mathrm{s}$$\n问题要求将最终答案四舍五入到四位有效数字。\n$$T_{\\text{total}} \\approx 86.08\\,\\mathrm{s}$$\n第四位有效数字是$8$，其后的数字是$2$，因此我们舍去。最终的数值是$86.08$。", "answer": "$$\\boxed{86.08}$$", "id": "3658332"}, {"introduction": "内存映射不仅是强大的 I/O 工具，更是精细化管理进程虚拟内存的利器，尤其在构建健壮和安全的软件时。本练习将指导你运用 `mmap` 的内存保护标志（`PROT_NONE`）来创建“哨兵页”（Guard Pages），这是一种主动防御技术，可以即时捕获并定位缓冲区溢出等内存访问错误。通过完成这项实践 [@problem_id:3658310]，你将体会到如何利用操作系统底层机制来显著提升程序的稳定性和安全性。", "problem": "您正在为一个内存映射数组建模，该数组前后均由保护属性为“无”（PROT_NONE）的保护页保护，以捕获缓冲区溢出。在真实的操作系统中，内存保护是以虚拟内存页为粒度来强制执行的。以下基本事实将作为本问题的基础：\n\n- 虚拟内存被划分为大小为 $P$ 字节的页。所有保护都按页应用。\n- 一个连续的映射可以从与 $P$ 对齐的基地址 $B$ 开始。\n- 一个保护属性为“无”（PROT_NONE）的保护区域会拒绝所有访问；任何对保护区域中地址的读写尝试都会同步引发一个故障，并且故障虚拟地址就是程序试图访问的确切地址。\n- 如果一个长度为 $N$ 字节的数据区域被放置在保护页之间，操作系统会映射一个可访问的区域，其大小会向上取整到页大小的倍数，因为保护是按页应用的。令 $L' = \\lceil N / P \\rceil \\cdot P$。那么，数据的可访问映射占据半开区间 $[S, S + L')$，其中 $S = B + G \\cdot P$，$G$ 是两侧保护页的数量。前置保护区为 $[B, S)$，后置保护区为 $[S + L', B + (L' + 2 G P))$。\n- 任何对地址 $X \\in [S, S + L')$ 的访问都受到页面保护的允许。任何对 $X \\in [B, S)$ 或 $X \\in [S + L', B + (L' + 2 G P))$（或任何在 $[B, B + (L' + 2 G P))$ 之外的 $X$）的访问都是保护故障。如果发生保护故障，处理程序记录的违规地址就是被访问的地址 $X$。\n\n您的任务是编写一个程序，对于一组给定的测试用例，确定相对于数据数组起始位置 $S$ 的偏移量 $k$ 处的一次单字节访问是会被页面保护允许，还是会因访问保护区域（或整个映射之外）而产生故障。如果访问被允许，输出 $0$。如果会产生故障，输出违规的虚拟地址 $X = S + k$，格式为十进制整数。\n\n所有地址都必须视为以字节为单位的整数。总映射的起始地址 $B$ 是页对齐的。在以下所有测试用例中，两侧的保护页数量 $G = 1$。每个测试用例都提供了页大小 $P$ 和数据长度 $N$。单次尝试的访问由相对于 $S$ 的有符号偏移量 $k$ 指定。\n\n对于每个测试用例：\n- 计算 $S = B + G \\cdot P$。\n- 计算 $L' = \\lceil N / P \\rceil \\cdot P$。\n- 可访问区域为 $[S, S + L')$。\n- 总映射区域为 $[B, B + (L' + 2 G P))$。\n- 对于尝试的访问 $X = S + k$：\n  - 如果 $X \\in [S, S + L')$，输出 $0$。\n  - 否则，输出 $X$（违规地址），格式为十进制整数。\n\n使用以下测试套件。每个测试用例是一个元组 $(B, P, N, G, k)$，其中所有情况的 $G = 1$。为清晰起见，地址 $B$ 以十六进制和十进制两种形式给出；请将其视为整数（您可以在程序中使用十进制形式）：\n\n1. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 5000)$\n2. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 10100)$\n3. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 12288)$\n4. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = -16)$\n5. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 9999)$\n6. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 12287)$\n7. $(B = 0x10000000\\; (=\\, 268435456),\\; P = 4096,\\; N = 10000,\\; G = 1,\\; k = 1000000)$\n8. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = 3072)$\n9. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = -1024)$\n10. $(B = 0x20000000\\; (=\\, 536870912),\\; P = 1024,\\; N = 3072,\\; G = 1,\\; k = -2048)$\n11. $(B = 0x30000000\\; (=\\, 805306368),\\; P = 4096,\\; N = 8192,\\; G = 1,\\; k = 8191)$\n12. $(B = 0x30000000\\; (=\\, 805306368),\\; P = 4096,\\; N = 8192,\\; G = 1,\\; k = 8192)$\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。对于上面给出的每个测试用例，如果访问被允许，则输出 $0$；否则输出违规地址 $X$，格式为十进制整数。例如：$[r_1,r_2,\\dots,r_{12}]$。\n\n此问题不涉及任何物理单位或角度。所有输出均为整数。", "solution": "该问题已经过验证，被确定为一个定义明确、具有科学依据的计算建模练习，其内容涉及操作系统内存管理原理。所有提供的数据和定义都是自洽的，足以推导出唯一解。\n\n问题的核心是确定在给定地址的内存访问是落在允许区域内还是受保护的保护区域内。内存布局由几个参数定义：基地址 `$B$`、页大小 `$P$`、标称数据长度 `$N$` 以及数据区两侧的保护页数 `$G$`。对于所有测试用例，`$G=1$`。\n\n每个测试用例 `$(B, P, N, G, k)$` 的求解过程如下：\n\n1.  **定义地址和大小变量**：所有地址和大小都视为以字节为单位的整数。为适应可能的大地址空间，谨慎的做法是为所有相关变量（`$B$`、`$P$`、`$N$`、`$k$`、`$S$`、`$L'$` 和 `$X$`）使用 64 位整数类型，例如 C 语言中的 `long long`。\n\n2.  **计算数据区起始地址 `$S$`**：数据区前面有 `$G$` 个保护页。由于一个页的大小为 `$P$`，前置保护区的总大小为 `$G \\cdot P$`。因此，数据区的起始地址 `$S$` 位于距基地址 `$B$` 偏移 `$G \\cdot P$` 的位置。\n    $$S = B + G \\cdot P$$\n    对于所有给定的测试用例，`$G=1$`，所以这简化为 `$S = B + P$`。\n\n3.  **计算映射的数据区长度 `$L'$`**：操作系统以页大小的块为数据区分配内存。因此，实际分配的长度 `$L'$` 必须是请求的长度 `$N$` 向上取整到页大小 `$P$` 的下一个倍数。这等同于计算除法 `$N/P$` 的上限，然后乘以 `$P$`。\n    $$L' = \\left\\lceil \\frac{N}{P} \\right\\rceil \\cdot P$$\n    使用整数算术可以可靠地执行此计算，避免潜在的浮点不精确性：\n    $$L' = \\left( \\frac{N + P - 1}{P} \\right) \\cdot P$$\n    这里的除法是整数除法。\n\n4.  **定义允许的内存区间**：可用于数据的内存区域是半开区间 `$[S, S + L')$`。当且仅当 `$S \\le X  S + L'$` 时，对地址 `$X$` 的访问才被允许。\n\n5.  **计算目标访问地址 `$X$`**：问题没有将尝试的访问指定为绝对地址，而是相对于数据区起始位置 `$S$` 的有符号字节偏移量 `$k$`。访问的绝对虚拟地址 `$X$` 是：\n    $$X = S + k$$\n\n6.  **评估访问条件**：要确定访问是否被允许，我们检查地址 `$X$` 是否在允许的区间内。\n    $$S \\le X  S + L'$$\n    代入 `$X = S + k$`，我们得到：\n    $$S \\le S + k  S + L'$$\n    从不等式的所有部分减去 `$S$`，得到一个关于偏移量 `$k$` 的更简单的条件：\n    $$0 \\le k  L'$$\n    这个简化的条件是判断内存访问是否有效的决定性测试。\n\n7.  **确定输出**：\n    - 如果条件 `$0 \\le k  L'$` 为真，则访问被允许，要求的输出是 `$0$`。\n    - 如果条件为假，则访问是故障。访问发生在保护页内或完全在映射区域之外。在这种情况下，要求的输出是故障虚拟地址 `$X = S + k$`。\n\n将此过程应用于每个测试用例，即可得出最终的结果集。例如，对于测试用例 3：`$(B = 268435456, P = 4096, N = 10000, G = 1, k = 12288)$`。\n-   `$S = 268435456 + 1 \\cdot 4096 = 268439552$`。\n-   `$L' = ((10000 + 4096 - 1) / 4096) \\cdot 4096 = (14095 / 4096) \\cdot 4096 = 3 \\cdot 4096 = 12288$`。\n-   条件 `$0 \\le k  L'$` 变为 `$0 \\le 12288  12288$`，这是假的。\n-   输出是故障地址 `$X = S + k = 268439552 + 12288 = 268451840$`。\n\n对于测试用例 4：`$(B = 268435456, P = 4096, N = 10000, G = 1, k = -16)$`。\n-   `$S = 268439552$`。\n-   `$L' = 12288$`。\n-   条件 `$0 \\le k  L'$` 变为 `$0 \\le -16  12288$`，这是假的。\n-   输出是故障地址 `$X = S + k = 268439552 - 16 = 268439536$`。\n\n将定义的规则系统地应用于所有提供的测试用例，将产生所需的输出列表。", "answer": "$$\\boxed{[0, 0, 268451840, 268439536, 0, 0, 269439552, 536875008, 536870912, 536869888, 0, 805318656]}$$", "id": "3658310"}]}