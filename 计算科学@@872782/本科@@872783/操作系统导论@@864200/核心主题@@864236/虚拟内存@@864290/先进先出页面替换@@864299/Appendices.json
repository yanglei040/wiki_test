{"hands_on_practices": [{"introduction": "理解一个算法最好的方式就是观察它的实际运行过程。这个练习将引导你手动追踪先进先出（FIFO）算法如何处理一系列页面请求。通过在每一步记录内存帧的状态，你将具体地理解页面是如何被加载和淘汰的，并观察到 FIFO 简单的“最老页面先出”规则有时为何会导致次优决策。[@problem_id:3644489]", "problem": "一个进程在操作系统（OS）中，在请求分页虚拟内存环境下执行。先入先出（FIFO）页面置换策略维护一个按插入页框集合的时间排序的队列：当内存已满且发生未命中时，最老的页面（位于队首）首先被换出，并且队列顺序在命中时不会改变。最初，所有页框都是空的。引用串为 $S = [2,3,2,1,5,2,4,5,3,2,5,2]$，可用页框的数量为 $k = 3$。\n\n从请求分页、缺页和 FIFO 队列行为的核心定义出发，重建在引用串 $S$ 中每次引用时的 FIFO 队列状态，明确指出每一步是命中还是未命中，如果是未命中，则指出哪个页面被换出。解释你观察到的任何反直觉的行为是如何由队列顺序以及 FIFO 在命中时不调整顺序这一事实引起的。\n\n计算在 $k=3$ 的情况下，使用 FIFO 策略处理整个引用串所产生的总缺页次数。以单个整数形式提供最终答案，无需四舍五入。", "solution": "该问题要求在请求分页虚拟内存系统中分析先入先出（FIFO）页面置换算法。我们必须为给定的引用串重建内存状态，并计算总缺页次数。\n\n请求分页的基本原理是，只有当一个页面被引用且尚未在主存中时，它才会被从辅存加载到主存。访问一个不在内存中的页面的尝试称为缺页（page fault）或未命中（miss）。访问一个已在内存中的页面称为命中（hit）。系统拥有固定数量的物理内存槽，称为页框（page frames），用 $k$ 表示。在本题中，$k=3$。\n\nFIFO 页面置换策略将内存中的页面集合作为一个队列来管理。当一个页面被加载到内存时，它被添加到队列的尾部。当发生缺页且所有页框都已被占用时，队首的页面（即在内存中停留时间最长的页面）被选中换出。题目描述指出了 FIFO 策略的一个关键特性：队列顺序仅由插入时间决定，在命中时不会改变。最老的页面仍然是最老的，无论它最近被访问的频率或时间如何。\n\n给定的引用串为 $S = [2,3,2,1,5,2,4,5,3,2,5,2]$，可用页框数为 $k=3$。最初，所有页框都是空的。我们将追踪 FIFO 队列（代表内存中的页面）的状态以及每次引用的缺页情况。队首在左侧，队尾在右侧。\n\n1.  引用页面 $2$：页框为空。这是一次未命中。页面 $2$ 被加载。\n    -   缺页次数: $1$。\n    -   FIFO 队列: $[2]$。\n\n2.  引用页面 $3$：页框未满。这是一次未命中。页面 $3$ 被加载。\n    -   缺页次数: $1+1 = 2$。\n    -   FIFO 队列: $[2, 3]$。\n\n3.  引用页面 $2$：页面 $2$ 已在内存中。这是一次命中。\n    -   缺页次数: $2$。\n    -   FIFO 队列: $[2, 3]$（不变）。页面 $2$ 仍然是最老的页面。\n\n4.  引用页面 $1$：页框未满。这是一次未命中。页面 $1$ 被加载。\n    -   缺页次数: $2+1 = 3$。\n    -   FIFO 队列: $[2, 3, 1]$。页框现已满。\n\n5.  引用页面 $5$：页面 $5$ 不在内存中，且页框已满。这是一次未命中。队首的页面 $2$ 被换出。页面 $5$ 被插入队尾。\n    -   缺页次数: $3+1 = 4$。\n    -   FIFO 队列: $[3, 1, 5]$。\n\n6.  引用页面 $2$：页面 $2$ 不在内存中。这是一次未命中。队首的页面 $3$ 被换出。页面 $2$ 被插入队尾。\n    -   缺页次数: $4+1 = 5$。\n    -   FIFO 队列: $[1, 5, 2]$。\n\n7.  引用页面 $4$：页面 $4$ 不在内存中。这是一次未命中。队首的页面 $1$ 被换出。页面 $4$ 被插入队尾。\n    -   缺页次数: $5+1 = 6$。\n    -   FIFO 队列: $[5, 2, 4]$。\n\n8.  引用页面 $5$：页面 $5$ 在内存中。这是一次命中。\n    -   缺页次数: $6$。\n    -   FIFO 队列: $[5, 2, 4]$（不变）。\n\n9.  引用页面 $3$：页面 $3$ 不在内存中。这是一次未命中。队首的页面 $5$ 被换出。页面 $3$ 被插入队尾。\n    -   缺页次数: $6+1 = 7$。\n    -   FIFO 队列: $[2, 4, 3]$。\n\n10. 引用页面 $2$：页面 $2$ 在内存中。这是一次命中。\n    -   缺页次数: $7$。\n    -   FIFO 队列: $[2, 4, 3]$（不变）。页面 $2$ 仍然是最老的页面。\n\n11. 引用页面 $5$：页面 $5$ 不在内存中。这是一次未命中。队首的页面 $2$ 被换出。页面 $5$ 被插入队尾。\n    -   缺页次数: $7+1 = 8$。\n    -   FIFO 队列: $[4, 3, 5]$。\n\n12. 引用页面 $2$：页面 $2$ 不在内存中。这是一次未命中。队首的页面 $4$ 被换出。页面 $2$ 被插入队尾。\n    -   缺页次数: $8+1 = 9$。\n    -   FIFO 队列: $[3, 5, 2]$。\n\n模拟完成。总缺页次数为 $9$。\n\n在这个追踪过程中可以清楚地观察到 FIFO 的反直觉行为。例如，在步骤 $3$ 中，页面 $2$ 被引用（一次命中），表明它正在被活跃使用。然而，由于 FIFO 的队列顺序在命中时不会改变，页面 $2$ 仍然是“最老”的页面。因此，在步骤 $5$ 中，当必须换出一个页面为页面 $5$ 腾出空间时，最近使用过的页面 $2$ 被选为淘汰对象，仅仅因为它是在当前驻留页面中第一个被加载的。像最近最少使用（LRU）这样的算法，在步骤 $3$ 命中后会认为页面 $2$ 是最近使用过的页面，并在步骤 $5$ 中保护它不被换出。FIFO 策略对访问模式的忽略导致了可能还有用的页面被换出，这会增加缺页率。这一点在页面 $2$ 被换出后不久又重复发生缺页（步骤 $6, 12$）的情况中表现得很明显。这种看似简单公平的算法却表现不佳的现象，是页面置换算法研究中的一个重要教训。", "answer": "$$\\boxed{9}$$", "id": "3644489"}, {"introduction": "除了单次追踪，理解一个算法的性能如何随不同类型的工作负载而变化也至关重要。本练习探讨了一个程序的工作集大小（其活跃使用的独立页面数量）与可用内存帧数量之间的关系。你将分析内存充足与不足的场景，从而发现导致“颠簸”（thrashing）的条件——即系统花费更多时间交换页面而非执行有效工作的状态。[@problem_id:3644481]", "problem": "一个虚拟内存系统使用先进先出 (FIFO) 页面置换算法，其中当发生页面错误时，在内存中驻留时间最长的页面被置换出去，而当命中时则不发生置换。主存是全相联的，有 $k$ 个页框，这意味着任何页面都可以占据 $k$ 个页框中的任意一个。考虑一个由三个连续阶段组成的工作负载 $S$。在每个阶段开始时，所有页框都是空的，没有预取，并使用请求分页。在每个阶段中，引用流是对一组固定的不同虚拟页面的严格循环访问，重复指定的次数：\n\n- 阶段 1：对 $\\{A_1, A_2, A_3\\}$ 进行循环访问，重复 $50$ 次。\n- 阶段 2：对 $\\{B_1, B_2, B_3, B_4, B_5, B_6\\}$ 进行循环访问，重复 $40$ 次。\n- 阶段 3：对 $\\{C_1, C_2, C_3, C_4, C_5, C_6, C_7\\}$ 进行循环访问，重复 $28$ 次。\n\n对于一个对 $L$ 个不同页面的循环访问，循环中每个页面的重用间距 $\\delta$ 是指对该页面的两次连续引用之间引用的其他不同页面的数量，即 $\\delta = L - 1$。设页框数量为 $k = 4$。\n\n任务：\n1. 对于每个阶段，从给定的定义出发，根据第一性原理计算该阶段内的 FIFO 命中率。在你的推理中，明确指出哪些重用间距值 $\\delta \\in \\{2, 5, 6\\}$ 超过了 $k$，并解释其对命中与未命中的影响。\n2. 最后，通过汇总所有三个阶段的数据，计算整个工作负载 $S$ 的总体 FIFO 命中率。\n\n将最终的总体命中率表示为小数，并将答案四舍五入到 $4$ 位有效数字。", "solution": "该问题要求分析先进先出 (FIFO) 页面置换算法在特定工作负载下的性能。系统有 $k=4$ 个页框。工作负载由三个不同的阶段组成，在每个阶段开始时，内存页框都是空的。\n\nFIFO 的核心原理是，当发生页面错误时，在内存中驻留时间最长的页面被置换出去。要使页面 `P` 命中，`P` 必须存在于 $k$ 个页框之一。在对一组 $L$ 个不同页面的重复循环引用流中，一个页面 `P` 被引用，然后在 `P` 再次被引用之前，会引用 $\\delta = L-1$ 个其他不同的页面。FIFO 算法的行为关键取决于工作集大小 $L$ 和可用页框数 $k$ 之间的关系。\n\n让我们从第一性原理分析两种情况：\n1.  情况 $L \\le k$：引用流是 $(p_1, p_2, \\dots, p_L)$，重复进行。前 $L$ 次引用是针对不同的页面，这些页面都不在内存中。这些是强制性未命中。页面 $p_1, p_2, \\dots, p_L$ 被加载到 $L$ 个独立的页框中。由于 $L \\le k$，有足够的页框来容纳整个工作集。在这最初的 $L$ 次未命中之后，工作集的所有页面都驻留在内存中。下一次引用是 $p_1$，它在内存中被找到，导致命中。不发生置换。后续对 $p_2, \\dots, p_L$ 的引用也都是命中。所有后续的循环重复都将导致命中。因此，对于一个总引用次数为 $N$、不同页面数为 $L$ 且满足 $L \\le k$ 的阶段，将恰好有 $L$ 次初始未命中和 $N-L$ 次命中。\n\n2.  情况 $L > k$：引用流同样是 $(p_1, p_2, \\dots, p_L)$，重复进行。前 $k$ 次引用 $(p_1, \\dots, p_k)$ 是强制性未命中，并填满了所有 $k$ 个页框。内存中页面的 FIFO 队列是 $(p_1, \\dots, p_k)$，其中 $p_1$ 是“最老的”。第 $(k+1)$ 次引用是页面 $p_{k+1}$。这是一次未命中。页面 $p_1$ 被置换出去，$p_{k+1}$ 被加载进来。FIFO 队列变为 $(p_2, \\dots, p_k, p_{k+1})$。这个过程会持续下去。对于任何被加载到内存中的页面 $p_i$，它将在引用了 $L-1$ 个其他页面之后再次被引用。由于 $L > k$，我们有 $L-1 \\ge k$。这 $L-1$ 次中间的引用（也都是未命中）将导致至少 $k$ 次页面置换，这足以遍历整个页框集，并在页面 $p_i$ 再次被引用之前将其置换出去。因此，在最初的 $k$ 次强制性未命中之后，每次后续的内存访问也都会导致未命中。在这种情况下，每次引用都是一次页面错误。命中次数为 $0$。\n\n问题将重用间距定义为 $\\delta = L-1$。条件 $L \\le k$ 等价于 $\\delta+1 \\le k$，或 $\\delta \\le k-1$。条件 $L > k$ 等价于 $\\delta+1 > k$，或 $\\delta \\ge k$。当 $k=4$ 时，只有当 $\\delta \\le 3$ 时，稳态下才可能发生命中。\n\n现在我们将此分析应用于每个阶段。\n\n**任务 1：各阶段分析**\n\n**阶段 1：**\n- 工作集：$\\{A_1, A_2, A_3\\}$。不同页面的数量为 $L_1 = 3$。\n- 重复次数：$50$。总引用次数：$N_1 = L_1 \\times 50 = 3 \\times 50 = 150$。\n- 重用间距：$\\delta_1 = L_1 - 1 = 3 - 1 = 2$。\n- 我们有 $k=4$。发生命中的条件是 $\\delta_1 \\le k-1$，即 $2 \\le 3$。这是成立的。或者说，$L_1=3 \\le k=4$。\n- 根据我们的第一性原理分析，将有 $L_1 = 3$ 次初始强制性未命中，随后的所有其余引用都是命中。\n- 未命中次数：$M_1 = 3$。\n- 命中次数：$H_1 = N_1 - M_1 = 150 - 3 = 147$。\n- 阶段 1 的命中率：$h_1 = \\frac{H_1}{N_1} = \\frac{147}{150} = 0.98$。\n\n**阶段 2：**\n- 工作集：$\\{B_1, B_2, B_3, B_4, B_5, B_6\\}$。不同页面的数量为 $L_2 = 6$。\n- 重复次数：$40$。总引用次数：$N_2 = L_2 \\times 40 = 6 \\times 40 = 240$。\n- 重用间距：$\\delta_2 = L_2 - 1 = 6 - 1 = 5$。\n- 我们有 $k=4$。发生命中的条件是 $\\delta_2 \\le k-1$，即 $5 \\le 3$。这是不成立的。或者说，$L_2=6 > k=4$。\n- 根据我们的分析，工作集对于可用内存来说太大了。每次内存引用都会导致页面错误。\n- 未命中次数：$M_2 = N_2 = 240$。\n- 命中次数：$H_2 = 0$。\n- 阶段 2 的命中率：$h_2 = \\frac{H_2}{N_2} = \\frac{0}{240} = 0$。\n\n**阶段 3：**\n- 工作集：$\\{C_1, \\dots, C_7\\}$。不同页面的数量为 $L_3 = 7$。\n- 重复次数：$28$。总引用次数：$N_3 = L_3 \\times 28 = 7 \\times 28 = 196$。\n- 重用间距：$\\delta_3 = L_3 - 1 = 7 - 1 = 6$。\n- 我们有 $k=4$。发生命中的条件是 $\\delta_3 \\le k-1$，即 $6 \\le 3$。这是不成立的。或者说，$L_3=7 > k=4$。\n- 与阶段 2 类似，工作集大小超过了页框数量。每次内存引用都是一次页面错误。\n- 未命中次数：$M_3 = N_3 = 196$。\n- 命中次数：$H_3 = 0$。\n- 阶段 3 的命中率：$h_3 = \\frac{H_3}{N_3} = \\frac{0}{196} = 0$。\n\n**重用间距超过 k 的后果：**\n问题要求指出重用间距 $\\delta \\in \\{2, 5, 6\\}$ 中哪些超过了 $k=4$，并解释其后果。\n- 重用间距为 $\\delta_1=2$, $\\delta_2=5$ 和 $\\delta_3=6$。页框数量为 $k=4$。\n- 对于阶段 1，$\\delta_1 = 2$。这个值没有超过 $k=4$。实际上，它满足 $\\delta_1 \\le k-1$。其后果是，大小为 $L_1 = 3$ 的工作集可以容纳在 $k=4$ 个页框内，导致在初始强制性未命中后有很高的命中率。\n- 对于阶段 2，$\\delta_2 = 5$。这个值超过了 $k=4$。这意味着工作集大小 $L_2 = 6$ 大于页框数 $k=4$。其后果是，一个页面总是在其再次被引用之前就被从内存中置换出去。这种现象被称为颠簸 (thrashing)。每次访问都导致页面错误，命中率为 $0$。\n- 对于阶段 3，$\\delta_3 = 6$。这个值也超过了 $k=4$。其逻辑和后果与阶段 2 相同。工作集大小 $L_3=7$ 大于 $k=4$，导致颠簸和命中率为 $0$。\n\n**任务 2：总体 FIFO 命中率**\n\n为了计算整个工作负载 $S$ 的总体命中率，我们必须汇总所有三个阶段的总命中次数和总引用次数。\n- 总引用次数：$N_{total} = N_1 + N_2 + N_3 = 150 + 240 + 196 = 586$。\n- 总命中次数：$H_{total} = H_1 + H_2 + H_3 = 147 + 0 + 0 = 147$。\n- 总体命中率：$h_{overall} = \\frac{H_{total}}{N_{total}} = \\frac{147}{586}$。\n\n现在，我们计算其小数值并四舍五入到 $4$ 位有效数字。\n$h_{overall} = \\frac{147}{586} \\approx 0.2508532423...$\n前四位有效数字是 $2$、$5$、$0$ 和 $8$。第五位有效数字是 $5$，这要求将第四位数字向上舍入。\n因此，四舍五入后的总体命中率是 $0.2509$。", "answer": "$$ \\boxed{0.2509} $$", "id": "3644481"}, {"introduction": "我们通常期望页面替换算法在获得更多资源时表现更佳，但这并非总是如此。这最后一个练习将引导你体验 Belady 异常这一经典案例，这是一种与 FIFO 等特定算法相关的反直觉现象。通过比较在不同内存容量下的页面错误数量，你将亲身证明，对于 FIFO 算法，增加更多的内存帧有时反而会悖论性地 *增加* 页面错误次数，从而揭示其设计中的一个根本缺陷。[@problem_id:3623347]", "problem": "一个请求分页的虚拟内存系统维护一组固定大小的物理帧，并在发生缺页时使用先进先出 (FIFO) 策略替换页面，即驻留在内存中时间最长的页面（最先到达的页面）被换出。当引用的页面当前未驻留在任何帧中时，就会发生缺页。假设所有帧最初都是空的，如果存在空闲帧，引用会将页面加载到空闲帧中；否则，FIFO 策略会在加载新页面之前换出最旧的驻留页面。令 $f_{\\text{FIFO}}(k)$ 表示在给定引用字符串下，使用 $k$ 个帧并采用 FIFO 策略时的总缺页次数。\n\n给定经典引用序列 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$，计算 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$，并根据上述定义，解释为什么所得结果是 Belady 异常的一个例子，即在 FIFO 策略下，增加帧数反而可能导致缺页次数增加。\n\n将您的最终答案表示为一个包含两个元素的行矩阵 $\\begin{pmatrix} f_{\\text{FIFO}}(3)  f_{\\text{FIFO}}(4) \\end{pmatrix}$，其值为精确整数。无需四舍五入。", "solution": "问题陈述是完全自包含的，科学上基于操作系统内存管理的原理，并且问题提法是明确的。所有术语都是标准的且定义清晰，为唯一且可验证的解提供了基础。因此，该问题被认为是有效的。\n\n任务是计算给定引用序列 $S = (1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5)$ 在使用先进先出 (FIFO) 页面替换策略且分别有 $k=3$ 和 $k=4$ 个帧的情况下的缺页次数，记为 $f_{\\text{FIFO}}(3)$ 和 $f_{\\text{FIFO}}(4)$。随后，我们必须解释为什么这个结果展示了 Belady 异常。\n\nFIFO 策略的运作方式类似于一个队列。当必须换出一个页面时，选择在内存中停留时间最长的那个页面。我们将对每种情况跟踪内存帧的状态。缺页用 'F' 表示，命中用 'H' 表示。帧内容代表当前在内存中的页面集合。“到达顺序”队列显示了从最旧到最新的页面。\n\n**情况 1：$k=3$ 个帧**\n\n我们为 $f_{\\text{FIFO}}(3)$ 逐步模拟此过程。\n\n| 引用 | 页面 | 帧 (集合)     | 缺页/命中 | 到达顺序 (最旧 $\\rightarrow$ 最新) | 操作                         |\n|-----------|------|---------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$       | F         | $[1]$                                       | 将 $1$ 加载到空帧中。          |\n| 2         | $2$  | $\\{1, 2\\}$    | F         | $[1, 2]$                                    | 将 $2$ 加载到空帧中。          |\n| 3         | $3$  | $\\{1, 2, 3\\}$ | F         | $[1, 2, 3]$                                 | 将 $3$ 加载到空帧中。          |\n| 4         | $4$  | $\\{2, 3, 4\\}$ | F         | $[2, 3, 4]$                                 | 换出 $1$ (最旧的)，加载 $4$。          |\n| 5         | $1$  | $\\{3, 4, 1\\}$ | F         | $[3, 4, 1]$                                 | 换出 $2$ (最旧的)，加载 $1$。          |\n| 6         | $2$  | $\\{4, 1, 2\\}$ | F         | $[4, 1, 2]$                                 | 换出 $3$ (最旧的)，加载 $2$。          |\n| 7         | $5$  | $\\{1, 2, 5\\}$ | F         | $[1, 2, 5]$                                 | 换出 $4$ (最旧的)，加载 $5$。          |\n| 8         | $1$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | 页面 $1$ 在内存中。               |\n| 9         | $2$  | $\\{1, 2, 5\\}$ | H         | $[1, 2, 5]$                                 | 页面 $2$ 在内存中。               |\n| 10        | $3$  | $\\{2, 5, 3\\}$ | F         | $[2, 5, 3]$                                 | 换出 $1$ (最旧的)，加载 $3$。          |\n| 11        | $4$  | $\\{5, 3, 4\\}$ | F         | $[5, 3, 4]$                                 | 换出 $2$ (最旧的)，加载 $4$。          |\n| 12        | $5$  | $\\{5, 3, 4\\}$ | H         | $[5, 3, 4]$                                 | 页面 $5$ 在内存中。               |\n\n统计缺页次数 (F)，我们发现共有 $9$ 次缺页。\n因此，$f_{\\text{FIFO}}(3) = 9$。\n\n**情况 2：$k=4$ 个帧**\n\n接下来，我们为 $f_{\\text{FIFO}}(4)$ 模拟此过程。\n\n| 引用 | 页面 | 帧 (集合)       | 缺页/命中 | 到达顺序 (最旧 $\\rightarrow$ 最新) | 操作                         |\n|-----------|------|-----------------|-----------|---------------------------------------------|--------------------------------------|\n| 1         | $1$  | $\\{1\\}$         | F         | $[1]$                                       | 将 $1$ 加载到空帧中。          |\n| 2         | $2$  | $\\{1, 2\\}$      | F         | $[1, 2]$                                    | 将 $2$ 加载到空帧中。          |\n| 3         | $3$  | $\\{1, 2, 3\\}$   | F         | $[1, 2, 3]$                                 | 将 $3$ 加载到空帧中。          |\n| 4         | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | 将 $4$ 加载到空帧中。          |\n| 5         | $1$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | 页面 $1$ 在内存中。               |\n| 6         | $2$  | $\\{1, 2, 3, 4\\}$| H         | $[1, 2, 3, 4]$                              | 页面 $2$ 在内存中。               |\n| 7         | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | 换出 $1$ (最旧的)，加载 $5$。          |\n| 8         | $1$  | $\\{3, 4, 5, 1\\}$| F         | $[3, 4, 5, 1]$                              | 换出 $2$ (最旧的)，加载 $1$。          |\n| 9         | $2$  | $\\{4, 5, 1, 2\\}$| F         | $[4, 5, 1, 2]$                              | 换出 $3$ (最旧的)，加载 $2$。          |\n| 10        | $3$  | $\\{5, 1, 2, 3\\}$| F         | $[5, 1, 2, 3]$                              | 换出 $4$ (最旧的)，加载 $3$。          |\n| 11        | $4$  | $\\{1, 2, 3, 4\\}$| F         | $[1, 2, 3, 4]$                              | 换出 $5$ (最旧的)，加载 $4$。          |\n| 12        | $5$  | $\\{2, 3, 4, 5\\}$| F         | $[2, 3, 4, 5]$                              | 换出 $1$ (最旧的)，加载 $5$。          |\n\n统计缺页次数 (F)，我们发现共有 $10$ 次缺页。\n因此，$f_{\\text{FIFO}}(4) = 10$。\n\n**关于 Belady 异常的解释**\n\n计算出的值为 $f_{\\text{FIFO}}(3) = 9$ 和 $f_{\\text{FIFO}}(4) = 10$。我们观察到 $f_{\\text{FIFO}}(4) > f_{\\text{FIFO}}(3)$。这种增加分配的内存帧数反而导致缺页次数增加的现象，被称为 Belady 异常。这是一个反直觉的结果，因为人们通常期望更多的资源（即更多的帧）会提升性能（即导致更少的缺页）。\n\n该异常的发生是因为 FIFO 替换算法不考虑页面的使用历史或未来被引用的可能性；它只考虑到达时间。本例中出现异常的具体原因可以通过比较帧状态来确定。\n\n在第 $7$ 次引用时，引用串请求页面 $5$。\n- 在 $k=3$ 的情况下，帧中包含 $\\{2, 3, 4\\}$，页面 $1$ 在第 $4$ 次引用时已被换出。最旧的页面是 $2$，但根据跟踪记录，在第 7 次引用之前，帧的状态是 $\\{4, 1, 2\\}$。让我们精确一点。在第 7 次引用之前，帧的状态是 $\\{4, 1, 2\\}$，到达顺序为 $[4, 1, 2]$。页面 $4$ 是最旧的，被换出以加载页面 $5$。新状态为 $\\{1, 2, 5\\}$。关键是，页面 $1$ 和 $2$ 仍留在内存中。后续对 $1$ 和 $2$ 的引用都是命中。\n- 在 $k=4$ 的情况下，帧中包含 $\\{1, 2, 3, 4\\}$。最旧的页面是 $1$。为了加载页面 $5$，页面 $1$ 被换出。新状态为 $\\{2, 3, 4, 5\\}$。这次换出是有害的，因为页面 $1$ 在紧接着的下一步（第 $8$ 次引用）就被请求，导致立即发生缺页。\n\n较大的帧集（$k=4$）使得“错误”的页面（页面 $1$，它很快又被需要）成为最旧的驻留页面，从而成为替换的牺牲品。相比之下，较小的帧集（$k=3$）已经换出了那些不是立即需要的页面，从而形成了一种在后续引用中偶然表现更好的帧构成。\n\nBelady 异常是那些不属于“栈算法”的页面替换算法的特征。栈算法具有这样的特性：在引用字符串的任何一点，拥有 $k$ 个帧的内存中的页面集合总是拥有 $k+1$ 个帧的内存中页面集合的子集。FIFO 不满足此特性，如此处所示：在第 $7$ 次引用后，$k=3$ 的帧集合为 $\\{1, 2, 5\\}$，而 $k=4$ 的帧集合为 $\\{2, 3, 4, 5\\}$。前者不是后者的子集。\n\n最终计算值以一个包含两个元素的行矩阵形式呈现。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9 10 \\end{pmatrix}}\n$$", "id": "3623347"}]}