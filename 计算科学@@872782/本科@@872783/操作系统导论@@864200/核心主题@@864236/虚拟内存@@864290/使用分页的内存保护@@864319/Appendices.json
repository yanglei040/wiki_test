{"hands_on_practices": [{"introduction": "这个练习将带你深入分页机制最核心的概念：页面边界。我们将通过一个常见的编程错误——写入超出分配缓冲区的边界——来精确计算硬件首次触发页错误的虚拟地址[@problem_id:3657608]。通过这个实践，你将巩固对分页内存离散性的理解，并掌握内存管理单元（MMU）如何强制执行已映射和未映射区域之间的边界。", "problem": "考虑一个运行在实现了分页虚拟内存系统的进程，该系统使用固定大小的页面。每个页面的大小为 $P$ 字节，虚拟地址是以字节为单位的整数。中央处理器 (CPU) 会查询内存管理单元 (MMU) 来将每个虚拟地址转换为物理地址；MMU 使用页表层次结构，并在转换表明所引用的页面不存在或请求的访问违反了页面的保护位时，引发一个缺页中断。\n\n假设虚拟地址空间中存在如下的连续布局：\n- 一个具有写权限的已映射页面，其地址范围为 $[B, B+P)$。\n- 紧随其后的是一个由 $g$ 个连续页面组成的未映射间隙，其地址范围为 $[B+P, B+P+gP)$，其中 $g$ 是一个正整数。\n- 紧随该间隙之后的是另一个已映射页面（可能具有不同的保护属性），其地址范围为 $[B+P+gP, B+P+(g+1)P)$。\n\n一个线程从虚拟地址 $S$ 开始，对一个长度为 $L$ 字节的连续缓冲区执行一次前向、字节粒度的写入操作，其中 $B \\leq S  B+P$ 且 $L > B+P - S$，因此写入操作会跨越到下一个页面。写入操作触及的地址序列为递增的 $S, S+1, S+2, \\dots, S+L-1$。\n\n仅使用分页、页面边界和保护检查的定义，推导出在此次写入过程中 MMU 将引发中断的第一个虚拟地址，已知紧随 $[B, B+P)$ 之后的第一个页面是未映射间隙的第一个页面。将你的最终答案表示为一个仅包含 $S$ 和 $P$ 的、以字节为单位的闭式解析表达式。无需取整。\n\n此外，请提供一个简短的定性讨论，解释紧跟在间隙之后的已映射页面的保护位是否会影响硬件对首次访问间隙时所引发中断的分类（例如，是将其视为“不存在”中断还是“保护”中断）。你的讨论应仅基于 MMU 地址翻译和页面保护语义的基本原理。", "solution": "问题要求找出在顺序写入操作中将导致中断的第一个虚拟地址，并对该中断的性质进行定性讨论。我们将依次解决这两个部分。\n\n首先，我们必须确定第一个中断发生的虚拟地址。\n系统使用分页虚拟内存，页面大小固定为 $P$ 字节。一个虚拟地址 $V$ 位于一个特定的页面上。包含 $V$ 的页面的起始地址可以计算为 $P \\times \\lfloor V/P \\rfloor$，其中 $\\lfloor \\cdot \\rfloor$ 表示向下取整函数。包含 $V$ 的页面所跨越的地址范围是 $[P \\times \\lfloor V/P \\rfloor, P \\times \\lfloor V/P \\rfloor + P)$。\n\n问题描述一个写入操作始于虚拟地址 $S$，该地址位于一个地址范围为 $[B, B+P)$ 的已映射页面内。这意味着 $B$ 是一个页面的起始地址。根据通用公式，包含 $S$ 的页面的起始地址是 $P \\times \\lfloor S/P \\rfloor$。因此，我们可以建立以下等式：\n$$B = P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor$$\n这个页面具有写权限，因此对该页面内地址的任何写入访问都将成功，不会产生中断。写入操作按顺序访问地址 $S, S+1, S+2, \\dots$ 处的字节。因此，所有对地址 $V$ (满足 $S \\le V  B+P$) 的写入访问都是有效的。\n\n问题指明写入缓冲区的长度 $L$ 大于初始页面中的剩余空间，即 $L > (B+P) - S$。这个条件保证了写入操作将尝试访问超出第一个页面末尾的地址。第一个页面中最后一个有效地址是 $B+P-1$。顺序写入将访问此地址，然后尝试访问下一个字节，其地址为 $(B+P-1)+1 = B+P$。\n\n问题指出地址范围 $[B+P, B+P+gP)$ 是一个“未映射间隙”。这意味着在此范围内的任何地址 $V$ 都没有有效的虚拟到物理地址映射。当内存管理单元 (MMU) 尝试翻译虚拟地址 $B+P$ 时，它会发现相应的页表项 (PTE) 是无效的（例如，“存在”位为 $0$）。这次失败的翻译尝试会立即导致硬件引发一个缺页中断。\n\n由于写入操作从一个有效区域开始，按递增顺序访问地址，因此落入未映射间隙的第一个地址将是导致中断的第一个地址。这个地址恰好是 $B+P$。\n\n为了按要求将最终答案仅用 $S$ 和 $P$ 表示，我们代入之前推导出的 $B$ 的表达式：\n$$V_{\\text{fault}} = B+P = \\left( P \\times \\left\\lfloor \\frac{S}{P} \\right\\rfloor \\right) + P$$\n这个表达式可以通过提取公因数 $P$ 来简化：\n$$V_{\\text{fault}} = P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)$$\n这就是 MMU 将引发中断的第一个虚拟地址的闭式解析表达式。\n\n其次，我们提供关于中断类型的定性讨论。\n问题是，紧随未映射间隙之后的已映射页面的保护位是否会影响硬件对在地址 $V_{\\text{fault}} = B+P$ 处发生的中断的分类。\n\nMMU 执行的地址翻译机制是确定性的和局部化的。为了翻译一个虚拟地址 $V$，MMU 会确定其虚拟页号 (VPN)，即 $VPN(V) = \\lfloor V/P \\rfloor$，并用它来索引页表结构以找到相应的 PTE。中断发生在地址 $B+P$ 处，这是未映射间隙的第一个地址。MMU 的行为完全由包含此地址的页面的 PTE 内容决定。\n\n问题指出这个页面是“未映射”的。在 MMU 硬件的语境中，这意味着该页面的 PTE 将被标记为无效（例如，“存在”位或“有效”位被设为 $0$）。MMU 的逻辑优先进行此项检查。如果页面未被标记为存在，MMU 无法继续检查保护位（读/写/执行），因为没有有效的物理帧需要保护。MMU 会立即向 CPU 发送一个中断信号，硬件通常会将原因报告为“不存在”或“无效页面”中断。\n\n间隙之后的页面（起始地址为 $B+P+gP$）的属性由一个完全不同的 PTE 描述。MMU 硬件在翻译特定地址时不会预先查看其他的 PTE。地址 $B+P$ 的翻译过程与起始地址为 $B+P+gP$ 的页面的映射或保护状态无关。因此，紧跟间隙之后的已映射页面的保护位对首次访问间隙时所引发中断的分类完全没有影响。该中断的分类明确地基于被访问页面本身的无效映射。", "answer": "$$\\boxed{P \\times \\left( \\left\\lfloor \\frac{S}{P} \\right\\rfloor + 1 \\right)}$$", "id": "3657608"}, {"introduction": "在我们理解了页错误的基本机制后，下一个问题将探讨内存保护的一个经典安全应用：保护页（guard page）。操作系统通过在栈旁边放置一个不可写的页面，可以将悄无声息且危险的栈溢出转变为一个即时、可被检测的崩溃[@problem_id:3657704]。在这个练习中，你将计算栈的最大安全深度，并阐明为何这种设计对系统可靠性至关重要。", "problem": "一个操作系统使用请求分页，并由内存管理单元（MMU）强制执行每页的访问权限。每个虚拟内存页的大小为 $P$ 字节。某个线程的栈被放置在一个区域中，该区域的虚拟页面在具有读写权限（$\\text{rw}$，不可执行）的数据页和仅具有执行权限（$\\text{--x}$）的保护页之间交替出现，其重复模式为 $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$。栈向低地址方向增长。线程开始执行时，其栈指针与一个 $\\text{rw}$ 页的顶部对齐，且该页当前已用空间为 $0$ 字节。每次递归函数调用会消耗一个大小固定为 $F$ 字节的活动记录，该记录在栈上连续存放。当任何读或写操作的目标页面其对应的权限位（读或写）未被设置时，硬件会立即引发一个保护错误。\n\n从页面大小、页面权限和MMU的访问检查的定义出发，推导一个封闭形式的表达式，用于计算在这种配置下，在发生第一次保护错误之前可以完成的最大递归调用次数 $d$。你的推导应从第一性原理出发，明确指出限制栈增长的资源以及MMU如何强制执行该限制，不得引用任何预先推导的快捷公式。用 $P$ 和 $F$、标准数学运算符以及（如果需要）适当的整数取整运算符来表示你的最终答案。无需按有效数字进行舍入。此外，在你的推理过程中，用几句话解释与所有页面均为 $\\text{rw}$ 的设计相比，仅执行的保护页的存在如何防止静默的内存损坏。", "solution": "问题要求计算在发生保护错误前可以完成的最大递归调用次数 $d$。解决方案需要分析内存布局、栈增长机制以及内存管理单元（MMU）产生错误的条件。\n\n**第一步：问题验证**\n\n问题陈述的验证如下：\n- **提取的已知条件**：\n    - 页面大小：$P$ 字节。\n    - 活动记录大小：$F$ 字节。\n    - 页面权限模式：读/写（$\\text{rw}$）页与仅执行（$\\text{--x}$）的保护页交替出现。\n    - 栈增长方向：向低地址方向。\n    - 初始状态：栈指针与一个 $\\text{rw}$ 页的顶部对齐，已用空间为 $0$ 字节。\n    - 错误条件：对没有设置相应权限位的页面进行任何读或写操作都会引发硬件保护错误。\n\n- **验证结论**：\n    - 该问题在操作系统内存管理的原理上是**科学合理的**，包括虚拟内存、分页、内存保护和栈溢出。\n    - 该问题是**定义良好的**，提供了推导唯一解所需的所有参数（$P$，$F$）和条件。\n    - 语言是**客观**和精确的。\n    - 该问题没有提示中列出的使之无效的缺陷，如科学上不合理、模糊或不完整。\n\n该问题被认为是**有效的**。我们可以继续进行解答。\n\n**第二步：从第一性原理推导**\n\n操作系统为线程的栈配置了虚拟地址空间，使得可用的内存页被受保护的保护页隔开。其模式为 $\\text{rw}, \\text{--x}, \\text{rw}, \\text{--x}, \\dots$。每个页面，无论是 $\\text{rw}$ 数据页还是 $\\text{--x}$ 保护页，大小均为 $P$ 字节。\n\n栈向低内存地址方向增长。问题陈述，栈指针开始于一个 $\\text{rw}$ 页的顶部。我们将此页的起始地址（其最高地址）表示为 $A_{start}$。由于栈向下增长，它将消耗地址为 $A_{start}-1$、$A_{start}-2$ 等的内存。\n\n这个初始的 $\\text{rw}$ 页提供了一个大小为 $P$ 字节的连续内存块，其中允许读和写操作。此页中的地址范围从 $A_{start}-P$（包含，最低地址）到 $A_{start}-1$（包含，栈使用的最高地址）。地址空间中紧邻此页下方的页面是一个具有 $\\text{--x}$ 权限的保护页。任何试图对此保护页进行读或写的操作都会触发保护错误，因为该页没有设置必需的 $\\text{r}$ 或 $\\text{w}$ 权限位。\n\n每次递归函数调用消耗一个大小固定为 $F$ 字节的活动记录。当一个函数被调用时，其活动记录被压入栈中。对于 $d$ 次已完成的递归调用，栈上消耗的总内存是 $d$ 个活动记录大小的总和。由于每个活动记录的大小都是 $F$，总内存占用为 $d \\times F$ 字节。\n\n只要所有用于压入这些活动记录的内存写操作都发生在具有写权限的页面内，线程就可以无错误地执行。从初始配置开始，线程可以访问一个完整的 $\\text{rw}$ 页面，在遇到保护页之前，提供了恰好 $P$ 字节的可用栈空间。\n\n因此，已完成调用所消耗的总内存 $d \\times F$ 必须小于或等于可用的 $\\text{rw}$ 空间，即 $P$。这给了我们不等式：\n$$d \\times F \\le P$$\n\n我们正在寻找*已完成*调用的最大数量，这对应于满足此条件的 $d$ 的最大整数值。假设 $F > 0$（活动记录的大小必须为非零），我们可以两边都除以 $F$：\n$$d \\le \\frac{P}{F}$$\n\n由于 $d$ 必须是代表调用次数的整数，因此它可以取的最大值是小于或等于 $\\frac{P}{F}$ 的最大整数。根据定义，这就是表达式 $\\frac{P}{F}$ 的下取整函数。\n$$d_{max} = \\left\\lfloor \\frac{P}{F} \\right\\rfloor$$\n\n我们来验证一下。经过 $d_{max}$ 次调用后，总的栈使用量为 $d_{max} \\times F = \\lfloor \\frac{P}{F} \\rfloor \\times F$。根据下取整函数的定义，$\\lfloor x \\rfloor \\le x$，所以 $\\lfloor \\frac{P}{F} \\rfloor \\le \\frac{P}{F}$，这意味着 $\\lfloor \\frac{P}{F} \\rfloor \\times F \\le P$。因此，前 $d_{max}$ 次调用的所有内存访问都在初始的 $\\text{rw}$ 页面内。\n\n现在，考虑第 $(d_{max} + 1)$ 次调用。这次调用会尝试压入另一个大小为 $F$ 的活动记录。所需的总内存将是 $(d_{max} + 1) \\times F$。由于 $\\lfloor x \\rfloor > x - 1$，我们有 $\\lfloor \\frac{P}{F} \\rfloor > \\frac{P}{F} - 1$，这意味着 $\\lfloor \\frac{P}{F} \\rfloor + 1 > \\frac{P}{F}$。两边乘以 $F$ 得到 $(\\lfloor \\frac{P}{F} \\rfloor + 1) \\times F > P$。这表明第 $(d_{max} + 1)$ 次调用所需的内存超过了初始 $\\text{rw}$ 页面中可用的 $P$ 字节。写操作将跨越页面边界，并指向相邻的 $\\text{--x}$ 保护页内的地址，从而立即导致保护错误。因此，第 $(d_{max} + 1)$ 次调用无法完成。\n\n**第三步：保护页的作用**\n\n仅执行（$\\text{--x}$）保护页的存在是一个关键的安全性和可靠性特性。在一个所有页面都是 $\\text{rw}$ 的系统中，栈溢出（消耗比分配的更多的栈空间）会导致栈增长到相邻的内存区域，例如堆或其他线程的栈。这会静默地损坏该区域的数据，导致不可预测的程序行为、难以诊断的崩溃以及潜在的安全漏洞，如缓冲区溢出攻击。通过在栈的已分配区域旁边放置一个不可写的保护页，任何试图将栈增长超出其限制的尝试都会立即导致一个确定性的硬件保护错误。这个错误会被操作系统捕获，操作系统通常会终止违规进程，从而将一个静默的数据损坏错误转变为在错误发生的确切点上易于识别的崩溃。", "answer": "$$\\boxed{\\left\\lfloor \\frac{P}{F} \\right\\rfloor}$$", "id": "3657704"}, {"introduction": "真实世界的程序操作常常会跨越页面边界。最后一个练习将探讨一个关键挑战：当像内存复制这样的单一操作在相邻页面上遇到不同权限时会发生什么？你将分析由此产生的“部分写入”失败模式，并评估用于实现“全有或全无”（原子性）内存操作的操作系统级策略[@problem_id:3657635]，从而在硬件约束和健壮的软件设计之间架起一座桥梁。", "problem": "一个运行在 $64$ 位操作系统（OS）上的用户空间程序，其硬件通过内存管理单元（MMU）来实施虚拟内存保护。页面是大小为 $4096$ 字节的连续虚拟内存区域，每个页面都有一个关联的访问权限向量（例如，只读、读写）。当一条指令试图以该页面权限所不允许的方式访问页面时，MMU 会引发一个保护错误（protection fault）；发生此类错误时，操作系统会向该进程发送一个段错误信号（Signal Segmentation Violation, SIGSEGV）。考虑以下情况：\n\n- 一个目标数组起始于虚拟地址 $V$，满足 $V \\bmod 4096 = 4080$。\n- 包含目标数组起始位置的第一个页面具有读写权限，而紧随其后的页面是只读的。\n- 一个源缓冲区是完全可读的，且长度至少为 $64$ 字节。\n- 程序调用一个标准的 C 库函数，该函数以地址递增的顺序将字节从源复制到目标（假设它发出普通的存储指令写入目标，并且不使用预取或非错误抑制的推测性存储，这些操作可能会在到达页边界之前就写入边界之外）。\n\n从上述核心定义（页面大小和偏移量算术、MMU 对每页权限的强制执行、以及保护违规时进程的信号传递）出发，推断当尝试将 $64$ 字节从源复制到目标时可能出现的失败模式。然后，评估如何利用页面保护更改来设计一个“全有或全无”的复制操作（即要么完整写入 $64$ 字节，要么一个字节都不写入）。在这些假设下，选择所有正确的陈述。\n\nA. 在页面大小为 $4096$ 且目标页面偏移量为 $4080$ 的情况下，复制 $64$ 字节会先向第一个页面精确写入 $16$ 字节，然后首次尝试写入第二个页面时会触发保护错误，导致段错误信号（SIGSEGV）。错误发生后，目标区域包含了来自源的前 $16$ 个字节；第二个页面中的字节未被修改。\n\nB. 复制操作会无错误地完成，因为实现可以按需升级页面权限；当写入操作紧跟在对相邻页面的成功写入之后时，MMU 允许写入只读页面。\n\nC. 在复制前通过保护更改将第一个页面临时标记为只读，可以保证“全有或全无”的结果，而无需任何信号处理或回滚，因为 MMU 会阻止任何部分写入，并且程序之后可以简单地重新尝试复制以完成操作。\n\nD. 为确保在执行复制前实现“全有或全无”的语义，可以计算覆盖目标范围的页面集合，并尝试通过保护更改系统调用（例如，将两个页面都设为读写）来更改它们的保护以包含写访问权限。如果任何页面的保护更改失败，则中止复制，这样就不会写入任何字节；如果所有更改都成功，则执行 $64$ 字节的复制，然后恢复原始的保护配置。这种方法在页面粒度上实现了原子性。\n\nE. 在复制操作周围使用语言级异常（例如，try-catch 块）可以确保“全有或全无”的结果，因为异常在任何写入发生之前被抛出，从而防止了跨越页边界的部分复制。\n\n选择所有正确的选项。", "solution": "### 步骤 1：提取已知信息\n\n题目陈述提供了以下信息：\n- **系统：** 一个 $64$ 位操作系统（OS）。\n- **硬件：** 通过内存管理单元（MMU）实施虚拟内存保护。\n- **页面大小：** $4096$ 字节。\n- **页面定义：** 连续的虚拟内存区域。\n- **页面权限：** 每个页面都有一个关联的访问权限向量。\n- **错误机制：** 当一条指令试图以该页面权限所不允许的方式访问时，MMU 会产生一个保护错误。\n- **操作系统错误响应：** 发生此类错误时，操作系统向进程发送一个段错误信号（SIGSEGV）。\n- **目标数组地址：** 起始于虚拟地址 $V$。\n- **目标数组对齐：** $V \\bmod 4096 = 4080$。\n- **目标页面权限：** 包含目标数组起始位置的第一个页面具有读写权限。紧随其后的页面是只读的。\n- **源缓冲区：** 完全可读，且长度至少为 $64$ 字节。\n- **复制函数：** 一个标准的 C 库函数，使用普通的存储指令以地址递增的顺序将字节从源复制到目标。\n- **复制大小：** $64$ 字节。\n- **假设：** 复制函数不使用预取或非错误抑制的推测性存储，这些操作可能会在到达页边界之前就写入边界之外。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n题目陈述是操作系统和计算机体系结构背景下的一个明确定义且标准的场景。\n- **科学依据：** 关于虚拟内存、分页、页表、访问权限（读/写）、内存管理单元（MMU）行为、保护错误和信号传递（SIGSEGV）的描述完全符合现代计算机系统的基本原理。\n- **问题适定性：** 提供了分析该情况所需的所有必要参数。页面大小（$4096$ 字节）、目标数组的起始偏移量（$4080$ 字节）、复制大小（$64$ 字节）以及相关页面的权限都已明确说明。这使得对内存访问模式及其结果进行确定性分析成为可能。\n- **客观性：** 语言是技术性的、精确的，没有歧义或主观性。\n\n这个问题是理解内存保护机制的一个有效、具体且可形式化的练习。清单中未发现任何缺陷。\n\n### 步骤 3：结论与行动\n\n题目陈述是**有效的**。将推导出一个解决方案。\n\n### 推导与选项评估\n\n首先，让我们分析问题中描述的初始失败模式。\n\n页面大小为 $4096$ 字节。页面内的地址由从 $0$ 到 $4095$ 的偏移量来标识。\n目标数组起始于虚拟地址 $V$，其在页面内的偏移量为 $4080$。\n我们将包含地址 $V$ 的页面称为“页面 1”，后续页面称为“页面 2”。\n页面 1 具有读写权限。\n页面 2 具有只读权限。\n\n从地址 $V$ 开始，在页面 1 中可供写入的字节数计算如下：\n$$ \\text{页面 1 中剩余字节数} = \\text{页面大小} - \\text{起始偏移量} = 4096 - 4080 = 16 \\text{ 字节} $$\n这 $16$ 个字节对应于地址范围 $[V, V+15]$。\n\n程序尝试复制 $64$ 字节。复制操作按地址递增的顺序进行。\n1.  前 $16$ 个字节被复制到地址范围 $[V, V+15]$。所有这些地址都落在可写的页面 1 内。这 $16$ 次存储操作将成功。\n2.  第 $17$ 个字节将被写入地址 $V+16$。\n    - 虚拟地址 $V$ 可以写成 $V = k \\cdot 4096 + 4080$，其中 $k$ 是某个整数。\n    - 那么虚拟地址 $V+16$ 就是 $k \\cdot 4096 + 4080 + 16 = k \\cdot 4096 + 4096 = (k+1) \\cdot 4096$。\n    - 形式为 $(k+1) \\cdot 4096$ 的地址是下一个页面（即页面 2）的第一个字节（偏移量为 $0$）。\n3.  问题陈述指出页面 2 是只读的。\n4.  当 CPU 执行复制函数，试图向地址 $V+16$ 执行存储指令时，MMU 将检测到对只读页面的写入尝试。\n5.  MMU 将陷入（trap）到操作系统内核，发出一个保护错误信号。\n6.  操作系统的错误处理程序将识别原因，并向用户空间进程发送一个 SIGSEGV 信号。\n7.  关键的是，前 $16$ 次写入已经完成并修改了页面 1 中的内存。错误发生在第 $17$ 次写入时，该写入被阻止。所有后续的写入（第 $18$ 到 $64$ 次）也被阻止，因为进程要么被终止，要么控制权被转移到信号处理程序，从而中断了复制函数的正常执行流程。\n\n这个初步分析证实了复制操作会失败，导致 $16$ 字节的部分写入。\n\n现在，我们基于这一理解和内存管理的原则来评估每个选项。\n\n---\n\n**A. 在页面大小为 $4096$ 且目标页面偏移量为 $4080$ 的情况下，复制 $64$ 字节会先向第一个页面精确写入 $16$ 字节，然后首次尝试写入第二个页面时会触发保护错误，导致段错误信号（SIGSEGV）。错误发生后，目标区域包含了来自源的前 $16$ 个字节；第二个页面中的字节未被修改。**\n\n这个陈述与我们的推导分析完全匹配。关于成功写入第一个页面的 $16$ 字节的计算是正确的（$4096 - 4080 = 16$）。关于错误发生在对第二个只读页面的首次写入时的判断是正确的。其后果，即一个 SIGSEGV 信号和一个被部分修改的目标，也是正确的。\n\n结论：**正确**\n\n---\n\n**B. 复制操作会无错误地完成，因为实现可以按需升级页面权限；当写入操作紧跟在对相邻页面的成功写入之后时，MMU 允许写入只读页面。**\n\n这个陈述描述了一种在标准硬件 MMU 中不存在的行为。MMU 是由操作系统在页表中设置的权限的严格执行者。它不会根据“一次写入紧跟在对相邻页面的成功写入之后”之类的访问模式来动态更改权限。对标记为只读的页面的写入将始终导致错误，无论相邻页面发生了什么。对页面权限的任何更改都必须由操作系统通过特权指令明确完成，通常是响应进程的系统调用。\n\n结论：**不正确**\n\n---\n\n**C. 在复制前通过保护更改将第一个页面临时标记为只读，可以保证“全有或全无”的结果，而无需任何信号处理或回滚，因为 MMU 会阻止任何部分写入，并且程序之后可以简单地重新尝试复制以完成操作。**\n\n这个选项提出了一种“全有或全无”复制的策略。让我们来分析一下。如果程序在开始复制*之前*将第一个页面（页面 1）的权限更改为只读，那么第一次写入尝试（到地址 $V$）将针对一个现在是只读的页面。这将立即导致保护错误和 SIGSEGV。此时，没有字节被写入，因此满足了“无部分写入”的条件。然而，该陈述声称这可以在“无需任何信号处理”的情况下工作。保护错误会导致 SIGSEGV。如果进程没有为 SIGSEGV 设置自定义信号处理程序，默认操作是终止进程。因此，程序不能“之后简单地重新尝试复制”。为了从错误中恢复并实施策略的其余部分（恢复权限并重新尝试），必须有一个自定义的信号处理程序。声称这在没有信号处理的情况下可行是根本错误的。\n\n结论：**不正确**\n\n---\n\n**D. 为确保在执行复制前实现“全有或全无”的语义，可以计算覆盖目标范围的页面集合，并尝试通过保护更改系统调用（例如，将两个页面都设为读写）来更改它们的保护以包含写访问权限。如果任何页面的保护更改失败，则中止复制，这样就不会写入任何字节；如果所有更改都成功，则执行 $64$ 字节的复制，然后恢复原始的保护配置。这种方法在页面粒度上实现了原子性。**\n\n这描述了一种“预检”策略。\n1.  **识别页面：** 复制操作跨越从地址 $V$（页面 1 中的偏移量 $4080$）到 $V+63$ 的范围。范围在页面 1 中是 $[V, V+15]$，在页面 2 中是 $[V+16, V+63]$。因此，涉及两个页面。\n2.  **预检权限：** 程序使用系统调用（如 POSIX 系统上的 `mprotect`）来请求两个页面的写权限。从用户进程的角度来看，这个系统调用是一个原子操作。\n3.  **处理失败：** 如果操作系统拒绝了对任一页面的请求，系统调用将失败并返回一个错误。程序可以检查此返回值并中止操作。由于此时还没有复制任何字节，这满足了“全有或全无”中的“全无”部分。\n4.  **处理成功：** 如果系统调用成功，程序就保证了两个页面现在都是可写的。然后它可以继续进行 $64$ 字节的复制，这个过程将不会产生保护错误。之后，它可以恢复原始权限。这处理了“全有”部分。\n这是一个标准的、健壮且正确的软件模式，用于确保多页写入能够在中途不发生错误的情况下完成。对该过程的描述是准确的。最后的声明，即这在“页面粒度上实现了原子性”，也是正确的，因为检查是按页面进行的。\n\n结论：**正确**\n\n---\n\n**E. 在复制操作周围使用语言级异常（例如，try-catch 块）可以确保“全有或全无”的结果，因为异常在任何写入发生之前被抛出，从而防止了跨越页边界的部分复制。**\n\n这个陈述混淆了两个不同的概念：硬件生成的信号和语言级异常。在 C/C++ 中，`try-catch` 块不能捕获像 SIGSEGV 这样的硬件生成信号。即使在某些语言中，通过复杂的运行时机制可能做到这一点，但“异常在任何写入发生之前被抛出”这一根本性主张是错误的。正如在初步分析中确定的那样，SIGSEGV 是由第 $17$ 次写入尝试触发的，此时前 $16$ 次写入已经成功修改了内存。在错误生成之前，部分复制已经发生。因此，这种机制不能防止部分写入，也不能确保“全有或全无”的结果。\n\n结论：**不正确**", "answer": "$$\\boxed{AD}$$", "id": "3657635"}]}