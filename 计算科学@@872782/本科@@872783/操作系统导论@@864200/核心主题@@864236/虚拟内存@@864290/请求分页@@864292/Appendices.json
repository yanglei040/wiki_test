{"hands_on_practices": [{"introduction": "请求调页系统的性能不仅仅取决于内存速度，更是硬件和软件事件复杂相互作用的结果。有效访问时间（Effective Access Time, $EAT$）是量化这一综合性能的关键指标。本练习将引导你从基本原理出发，推导并计算$EAT$，从而深入理解转译后备缓冲区（TLB）命中、页错误以及它们对系统总体效率的深远影响。[@problem_id:3633443]", "problem": "一个计算机系统使用带有转译后备缓冲区（TLB）的请求调页机制。每次内存访问按以下步骤进行：首先，执行TLB查找；如果TLB命中，则引用的页面被翻译并仅访问主存。如果TLB未命中，硬件将执行页表遍历并填充TLB；如果页面在内存中（驻留），则访问在遍历后完成；否则，发生缺页中断，操作系统必须通过将页面从辅存调入主存来处理该中断，然后访问才能完成。假设各步骤之间没有重叠，且成本是可累加的。\n\n令有效访问时间（EAT）为完成单次内存访问的期望时间。使用以下定义作为您的基本依据：\n- TLB命中率为 $h$，因此TLB未命中率为 $1-h$。\n- TLB未命中时的缺页率为 $p$，因此TLB未命中时无缺页的概率为 $1-p$。\n- 主存访问时间为 $m$。\n- 当TLB未命中但页面在内存中时产生的额外开销（包括页表遍历和TLB填充）为 $d$。\n- 缺页中断的服务时间（包括磁盘I/O和所有操作系统开销，直到访问完成）为 $s$。\n\n从上述概率定义和请求调页执行流程出发，推导有效访问时间 $EAT$ 关于 $h$、$p$、$m$、$d$ 和 $s$ 的封闭形式解析表达式，不要引入任何快捷公式。然后，使用现实基线值 $h=0.98$、$p=1.0\\times 10^{-6}$、$m=0.08$ 微秒、$d=0.08$ 微秒和 $s=10{,}000$ 微秒来评估 $EAT$。将您的最终数值结果四舍五入到四位有效数字，并以微秒为单位表示。\n\n为了在您的推理中说明敏感性，定性讨论当 $h$、$p$ 和 $d$ 在基线值附近变化时 $EAT$ 如何变化，但只报告单一的基线 $EAT$ 值作为您的最终答案。", "solution": "该问题要求在一个带有转译后备缓冲区（TLB）的请求调页系统中，推导有效访问时间（$EAT$）的封闭形式解析表达式，然后进行数值评估和定性敏感性分析。推导将基于所提供的概率模型从第一性原理出发。\n\n有效访问时间（$EAT$）是完成单次内存访问所需时间的期望值。它可以通过将所有可能结果的成本与其各自的概率相乘后求和来计算。所描述的内存访问过程产生三种互斥且穷尽的结果。让我们分析每种情况的概率和时间成本。\n\n变量定义如下：\n- $h$：TLB命中率。因此TLB未命中率为 $1-h$。\n- $p$：TLB未命中时的缺页率。因此TLB未命中时页面在内存中的概率为 $1-p$。\n- $m$：主存访问时间。\n- $d$：TLB未命中但页面在内存中时的额外开销。\n- $s$：缺页中断的总服务时间。\n\n情况1：TLB命中\n这是最有利的结果。TLB查找成功，直接获得物理地址。然后通过单次主存访问完成访问。\n- 概率：TLB命中的概率直接给出为 $P_1 = h$。\n- 时间成本：这种情况的时间为主存访问时间，即 $T_1 = m$。\n\n情况2：TLB未命中，页面在内存中（无缺页中断）\n在这种情况下，TLB查找失败，但页面存在于主存中。硬件必须执行页表遍历来找到物理地址。\n- 概率：这个结果需要两个连续事件：TLB未命中，然后发现页面在内存中。TLB未命中的概率是 $1-h$。在TLB未命中的条件下，页面在内存中（无缺页）的概率是 $1-p$。总概率是两者的乘积：$P_2 = (1-h)(1-p)$。\n- 时间成本：一次TLB未命中会产生用于页表遍历和TLB更新的额外开销 $d$。在此之后，仍然必须执行内存访问本身，这需要时间 $m$。由于成本是可累加的，这种情况的总时间是 $T_2 = m+d$。\n\n情况3：TLB未命中，发生缺页中断\n这是最不利的结果。TLB查找失败，随后的页表遍历显示页面不在主存中，从而触发缺页中断。\n- 概率：这个结果需要一次TLB未命中和一次缺页中断。其概率是TLB未命中的概率 $1-h$ 与未命中时发生缺页中断的条件概率 $p$ 的乘积。因此，$P_3 = (1-h)p$。\n- 时间成本：问题将 $s$ 定义为缺页中断的总服务时间，其中包括所有磁盘I/O和操作系统开销，直到访问最终完成。因此，这一整个事件分支的时间成本是 $T_3 = s$。\n\n$EAT$ 是每种情况的概率和时间成本乘积之和：\n$EAT = P_1 T_1 + P_2 T_2 + P_3 T_3$\n\n代入概率和时间的表达式：\n$$EAT = h \\cdot m + (1-h)(1-p)(m+d) + (1-h)p \\cdot s$$\n这就是有效访问时间的封闭形式解析表达式。\n\n现在，我们使用给定的基线值来评估 $EAT$：\n$h = 0.98$\n$p = 1.0 \\times 10^{-6}$\n$m = 0.08$ 微秒\n$d = 0.08$ 微秒\n$s = 10000$ 微秒\n\n将这些值代入推导出的表达式：\n$$EAT = (0.98)(0.08) + (1-0.98)(1 - 1.0 \\times 10^{-6})(0.08 + 0.08) + (1-0.98)(1.0 \\times 10^{-6})(10000)$$\n\n让我们分开计算各项。\nTLB命中的项为：\n$T_{hit\\_contrib} = 0.98 \\times 0.08 = 0.0784$ $\\mu s$\n\nTLB未命中的项由两部分组成。未命中的概率是 $1-h = 1-0.98 = 0.02$。\nTLB未命中但页面在内存中的成本为：\n$T_{miss\\_resident\\_contrib} = (0.02) \\times (1 - 1.0 \\times 10^{-6}) \\times (0.08 + 0.08)$\n$T_{miss\\_resident\\_contrib} = 0.02 \\times (0.999999) \\times (0.16)$\n$T_{miss\\_resident\\_contrib} = 0.02 \\times 0.15999984 = 0.0031999968$ $\\mu s$\n\nTLB未命中且发生缺页中断的成本为：\n$T_{fault\\_contrib} = (0.02) \\times (1.0 \\times 10^{-6}) \\times (10000)$\n$T_{fault\\_contrib} = 0.02 \\times 0.01 = 0.0002$ $\\mu s$\n\n总 $EAT$ 是这些贡献的总和：\n$EAT = T_{hit\\_contrib} + T_{miss\\_resident\\_contrib} + T_{fault\\_contrib}$\n$EAT = 0.0784 + 0.0031999968 + 0.0002$\n$EAT = 0.0817999968$ $\\mu s$\n\n问题要求将结果四舍五入到四位有效数字。\n这个数字是 $0.0817999968$。前四位有效数字是 $8$、$1$、$7$ 和 $9$。第九位后面的数字是 $9$，大于或等于 $5$，所以我们将最后一位有效数字向上取整。\n$EAT \\approx 0.08180$ $\\mu s$。\n\n定性敏感性分析：\n推导出的公式为 $EAT = h \\cdot m + (1-h)[(1-p)(m+d) + p \\cdot s]$。\n\n-   对 $h$（TLB命中率）的敏感性：$EAT$ 对 $h$ 的变化高度敏感。公式可以重排为 $EAT = m + (1-h)[(1-p)d + p(s-m)]$。由于 $s \\gg m$ 且 $s \\gg d$，乘以 $(1-h)$ 的项是一个大的正数。因此，随着 $h$ 的减小（即TLB未命中率 $1-h$ 增加），$EAT$ 会显著增加。高TLB命中率对性能至关重要，因为它使系统能够避免与TLB未命中相关的昂贵代价。\n\n-   对 $p$（未命中时的缺页率）的敏感性：$EAT$ 公式包含项 $(1-h)ps$。与其它时间成本（$m$ 和 $d$）相比，缺页中断的时间代价 $s$ 是巨大的。在本题中，$s = 10000$ $\\mu s$，而 $m+d = 0.16$ $\\mu s$。其比率约为 $62500$。因此，即使一个极小的缺页率 $p$，在乘以TLB未命中率 $(1-h)$ 后，也会对整体 $EAT$ 产生显著影响。$p$ 的增加会通过增加极慢的缺页中断服务时间的贡献来直接提高加权平均值，导致 $EAT$ 急剧上升。\n\n-   对 $d$（TLB未命中开销）的敏感性：开销 $d$ 仅在TLB未命中但页面在内存中的情况下产生影响，其总概率为 $(1-h)(1-p)$。对于给定的高命中率（$h=0.98$），这个概率很小。$d$ 的增加会线性增加 $EAT$，但其影响被 $(1-h)(1-p)$（在这种情况下约为 $0.02$）所缩放。因此，尽管 $d$ 的增加会降低性能，但其效果不如 $h$ 下降或 $p$ 上升那么显著，除非TLB未命中率本身很高。在给定的数值示例中，$d=m$，这意味着无缺页未命中的代价是使该特定路径的访问时间加倍。", "answer": "$$\\boxed{0.08180}$$", "id": "3633443"}, {"introduction": "在理解了页错误的代价之后，研究决定页错误何时发生的替换算法至关重要。虽然我们直觉上可能认为分配更多内存帧总能减少页错误，但事实并非总是如此。本练习将通过先进先出（FIFO）替换算法，探讨这种名为“Belady异常”（Belady's Anomaly）的反直觉现象，揭示页面替换策略的微妙之处。[@problem_id:3633428]", "problem": "考虑一个操作系统中的请求调页，其中一个进程的虚拟内存被划分为页面，并且只有在执行过程中被请求的页面才被载入物理内存。当引用的页面当前未驻留在物理内存中时，就会发生缺页中断。当发生缺页中断且所有可用页框都已满时，页面替换算法会选择一个牺牲页面从内存中换出，以便为被请求的页面腾出空间。先进先出 (FIFO) 是一种页面替换算法，它换出驻留时间最长的页面。Belady 异常是在某些非栈算法（如 FIFO）下经验上观察到的一种现象，即对于相同的引用序列，增加页框数量可能导致缺页次数增加。栈算法是一种具有包含特性的页面替换算法：对于任何时间 $t$ 和任意数量的页框 $k$，拥有 $k$ 个页框的驻留集是拥有 $k+1$ 个页框的驻留集的子集，这意味着当 $k$ 增加时，缺页次数不会增加。最近最少使用 (LRU) 和最佳 (OPT) 算法都是栈算法。\n\n哪个选项给出了一个在 FIFO 算法下表现出 Belady 异常的有效引用序列，并正确解释了为什么这种异常不会在 LRU 和 OPT 等栈算法下发生？\n\nA. 引用序列 $2,1,3,4,2,1,5,2,1,3,4,5$。在 FIFO 算法下，对于此引用序列，当页框数从 $k=3$ 增加到 $k=4$ 时，缺页次数会增加。像 LRU 和 OPT 这样的栈算法不会表现出这种增加，因为它们满足包含特性，所以它们的缺页次数随 $k$ 的增加而单调非递增。\n\nB. 引用序列 $1,2,3,4,5,1,2,3,4,5$。在 FIFO 算法下，对于此引用序列，当页框数从 $k=3$ 增加到 $k=4$ 时，缺页次数会增加，并且最近最少使用算法也可能显示同样的增加，因为两者都基于换出顺序。\n\nC. 引用序列 $1,2,3,1,4,5,2,1,2,3,4,5$。在 FIFO 算法下，增加 $k$ 永远不会增加缺页次数，因为更多的内存总是会导致更少的缺页；LRU 和 OPT 下没有异常现象是由于更好的时间局部性，而不是任何包含特性。\n\nD. 引用序列 $7,0,1,2,0,3,0,4,2,3,0,3,2$。在 OPT 算法下，当工作集不可预测地变化时，可能会发生异常，而 LRU 仅在稳态下避免异常；因此，随着页框增多而导致的缺页增加也可能影响 OPT。", "solution": "用户希望我验证问题陈述，如果有效，则解决所提出的问题。\n\n首先，我将按要求执行验证步骤。\n\n### 步骤 1：提取已知条件\n- **概念**：操作系统中的请求调页。\n- **定义 1**：当引用的页面不在物理内存中时，发生缺页中断。\n- **定义 2**：当发生缺页中断且所有页框都已满时，页面替换算法会换出一个牺牲页面。\n- **算法 1**：先进先出 (FIFO) 换出驻留时间最长的页面。\n- **现象**：Belady 异常是指对于相同的引用序列，增加页框数量会导致缺页次数增加，这种现象在像 FIFO 这样的算法下被观察到。\n- **定义 3**：栈算法是一种具有包含特性的页面替换算法。\n- **定义 4**：包含特性指出，对于任何时间 $t$ 和任意数量的页框 $k$，拥有 $k$ 个页框的驻留集是拥有 $k+1$ 个页框的驻留集的子集。\n- **推论**：对于栈算法，随着 $k$ 的增加，缺页次数是单调非递增的。\n- **算法 2**：最近最少使用 (LRU) 和最佳 (OPT) 被作为栈算法的例子给出。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述提供了一套关于虚拟内存管理的标准、正确的操作系统理论领域的定义。\n- **科学基础（关键）**：请求调页、缺页中断、FIFO、LRU、OPT、Belady 异常、栈算法和包含特性等概念都是计算机科学中基础且事实准确的原则。\n- **问题定义明确**：问题要求找出一个在 FIFO 下表现出 Belady 异常的引用序列的正确示例，并为其在栈算法中不存在提供正确的理论解释。这是一个具体且可解决的问题。\n- **客观性（关键）**：语言是技术性的且无偏见。\n- **完整性与一致性**：所提供的定义是自洽的，并且足以评估选项。例如，它正确地指出 FIFO 是一种易受异常影响的非栈算法，而 LRU 和 OPT 是不受影响的栈算法。\n\n### 步骤 3：结论与行动\n问题陈述被判定为**有效**。这是一个基于计算机科学既定原则的、格式良好的问题。我现在将继续对每个选项进行全面分析。\n\n任务是找到这样一个选项：它提供一个引用序列，能展示 FIFO 算法的 Belady 异常，并正确解释为何像 LRU 和 OPT 这样的栈算法不会出现此异常。如果对于给定的引用序列，使用 $k+1$ 个页框时的缺页次数大于使用 $k$ 个页框时的缺页次数，就发生了 Belady 异常。\n\n### 逐选项分析\n\n**选项 A: 引用序列 $2,1,3,4,2,1,5,2,1,3,4,5$。在 FIFO 算法下，对于此引用序列，当页框数从 $k=3$ 增加到 $k=4$ 时，缺页次数会增加。像 LRU 和 OPT 这样的栈算法不会表现出这种增加，因为它们满足包含特性，所以它们的缺页次数随 $k$ 的增加而单调非递增。**\n\n让我们用 FIFO 算法测试引用序列 $S = (2, 1, 3, 4, 2, 1, 5, 2, 1, 3, 4, 5)$。\n\n**情况 1：$k=3$ 个页框**\n内存页框的状态如下所示。'F' 表示缺页中断。\n\n- `2`: $[2]$ F\n- `1`: $[2, 1]$ F\n- `3`: $[2, 1, 3]$ F (换出队列：$2 \\to 1 \\to 3$)\n- `4`: $[4, 1, 3]$ F (换出 $2$) (队列：$1 \\to 3 \\to 4$)\n- `2`: $[4, 2, 3]$ F (换出 $1$) (队列：$3 \\to 4 \\to 2$)\n- `1`: $[4, 2, 1]$ F (换出 $3$) (队列：$4 \\to 2 \\to 1$)\n- `5`: $[5, 2, 1]$ F (换出 $4$) (队列：$2 \\to 1 \\to 5$)\n- `2`: $[5, 2, 1]$ 命中\n- `1`: $[5, 2, 1]$ 命中\n- `3`: $[5, 3, 1]$ F (换出 $2$) (队列：$1 \\to 5 \\to 3$)\n- `4`: $[4, 3, 1]$ F (换出 $5$) (队列：$3 \\to 1 \\to 4$)\n- `5`: $[4, 3, 5]$ F (换出 $1$) (我第一遍分析时这一步出错。队列头是 `3` 而不是 `1`。让我从第一次引用开始仔细重新追踪)\n\n让我们用一个精确的 FIFO 队列重新追踪。队列的头部是要被换出的页面。\n\n**情况 1：$k=3$ 个页框（修正后的追踪）**\n- `2`: 缺页, 页框: $\\{2\\}$, 队列: $(2)$\n- `1`: 缺页, 页框: $\\{2, 1\\}$, 队列: $(2, 1)$\n- `3`: 缺页, 页框: $\\{2, 1, 3\\}$, 队列: $(2, 1, 3)$\n- `4`: 缺页, 换出 $2$, 页框: $\\{4, 1, 3\\}$, 队列: $(1, 3, 4)$\n- `2`: 缺页, 换出 $1$, 页框: $\\{4, 2, 3\\}$, 队列: $(3, 4, 2)$\n- `1`: 缺页, 换出 $3$, 页框: $\\{4, 2, 1\\}$, 队列: $(4, 2, 1)$\n- `5`: 缺页, 换出 $4$, 页框: $\\{5, 2, 1\\}$, 队列: $(2, 1, 5)$\n- `2`: 命中, 页框: $\\{5, 2, 1\\}$, 队列: $(2, 1, 5)$\n- `1`: 命中, 页框: $\\{5, 2, 1\\}$, 队列: $(2, 1, 5)$\n- `3`: 缺页, 换出 $2$, 页框: $\\{5, 3, 1\\}$, 队列: $(1, 5, 3)$\n- `4`: 缺页, 换出 $1$, 页框: $\\{5, 3, 4\\}$, 队列: $(5, 3, 4)$\n- `5`: 命中, 页框: $\\{5, 3, 4\\}$, 队列: $(5, 3, 4)$\n$k=3$ 时的总缺页次数：$9$。\n\n**情况 2：$k=4$ 个页框**\n- `2`: 缺页, 页框: $\\{2\\}$, 队列: $(2)$\n- `1`: 缺页, 页框: $\\{2, 1\\}$, 队列: $(2, 1)$\n- `3`: 缺页, 页框: $\\{2, 1, 3\\}$, 队列: $(2, 1, 3)$\n- `4`: 缺页, 页框: $\\{2, 1, 3, 4\\}$, 队列: $(2, 1, 3, 4)$\n- `2`: 命中, 页框: $\\{2, 1, 3, 4\\}$, 队列: $(2, 1, 3, 4)$\n- `1`: 命中, 页框: $\\{2, 1, 3, 4\\}$, 队列: $(2, 1, 3, 4)$\n- `5`: 缺页, 换出 $2$, 页框: $\\{5, 1, 3, 4\\}$, 队列: $(1, 3, 4, 5)$\n- `2`: 缺页, 换出 $1$, 页框: $\\{5, 2, 3, 4\\}$, 队列: $(3, 4, 5, 2)$\n- `1`: 缺页, 换出 $3$, 页框: $\\{5, 2, 1, 4\\}$, 队列: $(4, 5, 2, 1)$\n- `3`: 缺页, 换出 $4$, 页框: $\\{5, 2, 1, 3\\}$, 队列: $(5, 2, 1, 3)$\n- `4`: 缺页, 换出 $5$, 页框: $\\{4, 2, 1, 3\\}$, 队列: $(2, 1, 3, 4)$\n- `5`: 缺页, 换出 $2$, 页框: $\\{4, 5, 1, 3\\}$, 队列: $(1, 3, 4, 5)$\n$k=4$ 时的总缺页次数：$10$。\n\n比较：缺页次数从 $9$ 次（$k=3$ 时）增加到 $10$ 次（$k=4$ 时）。这个引用序列正确地展示了 FIFO 算法的 Belady 异常。\n\n解释部分：「像 LRU 和 OPT 这样的栈算法不会表现出这种增加，因为它们满足包含特性，所以它们的缺页次数随 $k$ 的增加而单调非递增。」这个陈述是标准、正确的理论解释。包含特性保证了对于一个栈算法，在任何时间点，驻留在 $k$ 个页框中的页面集合是驻留在 $k+1$ 个页框中的页面集合的子集。这意味着任何在 $k$ 个页框下命中的页面引用，在 $k+1$ 个页框下也必定命中。因此，$k+1$ 个页框的缺页次数不可能大于 $k$ 个页框的缺页次数。\n\n对 A 的结论：示例和解释都是正确的。\n**判断：正确**\n\n**选项 B: 引用序列 $1,2,3,4,5,1,2,3,4,5$。在 FIFO 算法下，对于此引用序列，当页框数从 $k=3$ 增加到 $k=4$ 时，缺页次数会增加，并且最近最少使用算法也可能显示同样的增加，因为两者都基于换出顺序。**\n\n让我们测试引用序列 $S = (1, 2, 3, 4, 5, 1, 2, 3, 4, 5)$。\n\n**情况 1：$k=3$ 个页框**\n这是一个简单的循环引用序列。用 $(1, 2, 3)$ 填满 3 个页框后，每次后续的访问都是对一个不在内存中的页面，从而导致缺页和换出。\n总缺页次数：$10$ 次（每次引用都是一次缺页）。\n\n**情况 2：$k=4$ 个页框**\n同样地，用 $(1, 2, 3, 4)$ 填满 4 个页框后，每次后续的访问都是对一个不在内存中的页面。\n总缺页次数：$10$ 次（每次引用都是一次缺页）。\n\n比较：两种情况下的缺页次数都是 $10$ 次。由于 $10 \\not> 10$，这个引用序列没有表现出 Belady 异常。陈述的第一部分是错误的。\n\n解释部分：「...并且最近最少使用算法也可能显示同样的增加，因为两者都基于换出顺序。」这从根本上是错误的。正如问题描述中所述，LRU 是一种栈算法，因此它对 Belady 异常免疫。\n\n对 B 的结论：示例和解释都是不正确的。\n**判断：不正确**\n\n**选项 C: 引用序列 $1,2,3,1,4,5,2,1,2,3,4,5$。在 FIFO 算法下，增加 $k$ 永远不会增加缺页次数，因为更多的内存总是会导致更少的缺页；LRU 和 OPT 下没有异常现象是由于更好的时间局部性，而不是任何包含特性。**\n\n陈述部分：「在 FIFO 算法下，增加 $k$ 永远不会增加缺页次数，因为更多的内存总是会导致更少的缺页」。这个陈述与 Belady 异常这一既定事实直接矛盾，而 Belady 异常是整个问题的前提。在这个背景下，这句话是公理上错误的。\n\n解释部分：「...LRU 和 OPT 下没有异常现象是由于更好的时间局部性，而不是任何包含特性。」虽然 LRU 的有效性归功于利用时间局部性，但证明其对 Belady 异常免疫的形式化属性是包含特性，该特性使其成为栈算法。该陈述错误地排除了包含特性作为原因。\n\n对 C 的结论：主要主张和解释在理论上都是有缺陷的。\n**判断：不正确**\n\n**选项 D: 引用序列 $7,0,1,2,0,3,0,4,2,3,0,3,2$。在 OPT 算法下，当工作集不可预测地变化时，可能会发生异常，而 LRU 仅在稳态下避免异常；因此，随着页框增多而导致的缺页增加也可能影响 OPT。**\n\n陈述和解释部分：整个理论解释都是不正确的。\n- 「在 OPT 算法下，...可能会发生异常」：这是错误的。问题陈述本身就正确地将 OPT 识别为一种栈算法，它不会表现出 Belady 异常。\n- 「...LRU 仅在稳态下避免异常...」：这是错误的。LRU 是一种栈算法，其对 Belady 异常的免疫性对任何引用序列都成立，而不仅限于在「稳态」下。\n- 「...随着页框增多而导致的缺页增加也可能影响 OPT」：这是对第一个错误主张的重申。\n\n对 D 的结论：理论解释包含多个与栈算法的既定定义相矛盾的根本性错误。\n**判断：不正确**\n\n基于详细分析，只有选项 A 提供了一个展示 Belady 异常的引用序列的正确示例，以及关于其在栈算法中不存在的正确理论推理。", "answer": "$$\\boxed{A}$$", "id": "3633428"}, {"introduction": "将操作系统理论与现实世界的软件工程联系起来，是成为一名优秀工程师的关键。理解请求调页机制能帮助程序员编写“内存感知”的代码，从而显著提升程序性能。最后的这个练习将通过对矩阵乘法应用一种名为“循环分块”（loop tiling）的优化技术，具体量化它如何能大幅减少页错误，展示了理论知识在实践中的巨大威力。[@problem_id:3633469]", "problem": "一个系统实现了请求调页：当访问一个当前不在物理内存中的虚拟页面时，会触发一个缺页中断，之后该页面被加载进来。假设页面置换策略为最近最少使用（LRU），并忽略转译后备缓冲区（TLB）的影响。考虑两个以行主序存储的 $N \\times N$ 元素的稠密方阵相乘。每个元素大小为 $s$ 字节，页面大小为 $P$ 字节，物理内存有 $F$ 个页框，每个页框可以容纳一个页面。\n\n您将比较矩阵乘法 $C = A \\times B$ 的两种实现方式：\n\n1. 一个朴素的三重循环，它通过对索引 $k$ 的内层循环计算每个 $C[i][j]$，没有任何分块操作。\n2. 一个循环分块版本，它使用边长为 $b$ 的方形块对 $i$、$j$ 和 $k$ 循环进行分块。$b$ 的选择要确保三个块（$A$、$B$ 和 $C$）所需的所有页面能同时装入内存，并且在一个块的计算完成之前，一旦加载的页面将保持驻留并被重复使用。\n\n使用以下具体参数：$N = 4096$，$s = 8$ 字节，$P = 4096$ 字节，$F = 64$ 个页框，以及块大小 $b = 16$。假设：\n\n- 行主序布局意味着任何单行的元素是连续的，并且一行恰好跨越 $N/E$ 个页面，其中 $E = P/s$ 是每页的元素数量。\n- 在朴素算法中，对于固定的 $(i,j)$，对 $k$ 的内层循环会访问 $B$ 的 $N$ 个不同页面（每行一个）。在 $F \\ll N$ 的条件下，时间局部性可以忽略不计，因此每次这样的访问都会导致一次缺页中断。内层循环中对 $A$ 的访问会顺序遍历第 $i$ 行的 $N/E$ 个页面，每页产生一次缺页中断。对于 $C$，当 $j$ 遍历第 $i$ 行时，该行的每个页面会产生一次缺页中断（对于给定的元素，该页面在内层 $k$ 循环中保持驻留）。\n- 在分块算法中，对于每个边长为 $b$ 的 $(i,j)$ 块对，以及对于每个 $k$ 块，用于 $A$ 块的 $b$ 个页面和用于 $B$ 块的 $b$ 个页面都只产生一次缺页中断，然后被重复使用；用于 $C$ 块的 $b$ 个页面在每个 $(i,j)$ 块对中只产生一次缺页中断，并在所有 $k$ 块的计算中保持驻留。约束条件 $3b \\leq F$ 确保了三个块的页面能同时装入内存。\n\n根据这些定义和假设，推导出朴素算法和分块算法的总缺页中断次数，然后计算定义为朴素算法缺页中断次数与分块算法缺页中断次数之比的缩减因子 $R$。将最终的 $R$ 值四舍五入到四位有效数字。提供一个实数作为最终答案。", "solution": "我们从请求调页的基本定义开始：当引用的虚拟页面不在物理内存中时，会发生缺页中断；加载页面可以解决该中断。在最近最少使用（LRU）策略下，由于页框数量有限，最近未被引用的页面会被换出。对于行主序存储，一行的元素在内存中是连续的；页面将这些连续的范围进行分区。\n\n给定页面大小 $P$ 和元素大小 $s$，每页的元素数量为\n$$\nE = \\frac{P}{s}.\n$$\n当 $P = 4096$ 且 $s = 8$ 时，我们得到\n$$\nE = \\frac{4096}{8} = 512.\n$$\n一行有 $N$ 个元素；由于每页包含 $E$ 个元素，单行跨越\n$$\n\\frac{N}{E} = \\frac{4096}{512} = 8\n$$\n个页面。\n\n我们分析每种算法的缺页中断次数。\n\n朴素算法：\n- 对于固定的 $(i,j)$，最内层关于 $k$ 的循环计算 $C[i][j] = \\sum_{k=0}^{N-1} A[i][k] \\cdot B[k][j]$。对于 $k = 0,1,\\dots,N-1$，访问 $B[k][j]$ 会跨越不同的行。在行主序布局中，元素 $B[k][j]$ 位于第 $k$ 行的 $\\frac{N}{E}$ 个页面之一中。随着 $k$ 的变化，每次迭代都会接触到与不同行 $k$ 相关联的页面。在 $F \\ll N$ 的情况下，计算一个 $j$ 所需的 $B$ 的不同页面的工作集超出了物理内存，内层循环中的时间局部性可以忽略不计；因此，$N$ 个不同的 $B$ 页面中的每一个都会导致一次缺页中断。因此，对于每个 $(i,j)$ 对，$B$ 贡献了 $N$ 次缺页中断，总共为\n$$\nN^3\n$$\n次缺页中断，遍及所有 $N^2$ 个对。\n\n- 对于 $A[i][k]$，随着 $k$ 的增加，我们连续地遍历第 $i$ 行。由于一行跨越 $\\frac{N}{E}$ 个页面，我们在内层循环中每跨越一个页面边界就会产生一次缺页中断；因此，对于每个 $(i,j)$，$A$ 贡献了 $\\frac{N}{E}$ 次缺页中断。遍及所有 $N^2$ 个对，这总计是\n$$\n\\frac{N^3}{E}.\n$$\n\n- 对于 $C[i][j]$，在关于 $k$ 的内层循环中，元素 $C[i][j]$ 被重复访问，因此在第一次接触后，其页面在该内层循环期间保持驻留。随着 $j$ 遍历第 $i$ 行，我们每遇到一个页面边界就产生一次缺页中断，即每行 $i$ 产生 $\\frac{N}{E}$ 次缺页中断。遍及 $N$ 行，这总计是\n$$\n\\frac{N^2}{E}.\n$$\n\n因此，朴素算法的总缺页中断次数为\n$$\n\\text{faults}_{\\text{naive}} = N^3 + \\frac{N^3}{E} + \\frac{N^2}{E}.\n$$\n代入 $N=4096$ 和 $E=512$，\n$$\n\\text{faults}_{\\text{naive}} = 4096^3 + \\frac{4096^3}{512} + \\frac{4096^2}{512}.\n$$\n计算每一项：\n- $4096^2 = 16{,}777{,}216$,\n- $4096^3 = 16{,}777{,}216 \\cdot 4096 = 68{,}719{,}476{,}736$,\n- $\\frac{4096^3}{512} = 134{,}217{,}728$,\n- $\\frac{4096^2}{512} = 32{,}768$.\n因此\n$$\n\\text{faults}_{\\text{naive}} = 68{,}719{,}476{,}736 + 134{,}217{,}728 + 32{,}768 = 68{,}853{,}727{,}232.\n$$\n\n分块算法：\n我们选择一个块大小 $b$，使得三个块（$A$、$B$、$C$）的所有页面能同时装入内存：$3b \\leq F$。当 $F = 64$ 时，设置 $b = 16$ 可得 $3b = 48 \\leq 64$。\n\n考虑一个边长为 $b$ 的 $(i,j)$ 块对。需要 $\\frac{N}{b}$ 个 $k$-块来累加完整的和。对于每个 $k$-块：\n- $A$ 块覆盖了 $b$ 行中每行的 $b$ 个连续列。在 $b \\leq E$ 的条件下，每行的 $b$ 个元素位于一个页面内；跨越 $b$ 行，就是 $b$ 个页面。这 $b$ 个页面在 $k$-块开始时产生一次缺页中断，然后在整个块的计算中被重复使用。\n- $B$ 块覆盖了 $k$ 范围内的 $b$ 行中每行的 $b$ 个连续列；类似地，这也需要 $b$ 个页面，在每个 $k$-块中产生一次缺页中断，并在块内被重复使用。\n- $C$ 块由 $b$ 行和 $b$ 列组成，总共需要 $b$ 个页面（在 $b \\leq E$ 的条件下每行一个页面），在每个 $(i,j)$ 块对中产生一次缺页中断，并在所有 $k$-块的计算中保持驻留，因为工作集满足 $3b \\leq F$。\n\n因此，对于一个 $(i,j)$ 块对，缺页中断次数为\n$$\nb + \\left(\\frac{N}{b}\\right)\\cdot (b + b) = b + 2N.\n$$\n总共有 $\\left(\\frac{N}{b}\\right)^2$ 个这样的 $(i,j)$ 块对，因此分块算法的总缺页中断次数为\n$$\n\\text{faults}_{\\text{tiled}} = \\left(\\frac{N}{b}\\right)^2 (2N + b) = \\frac{2N^3}{b^2} + \\frac{N^2}{b}.\n$$\n当 $N=4096$ 且 $b=16$ 时，\n$$\n\\text{faults}_{\\text{tiled}} = \\frac{2 \\cdot 4096^3}{16^2} + \\frac{4096^2}{16}.\n$$\n计算：\n- $16^2 = 256$,\n- $\\frac{2 \\cdot 4096^3}{256} = \\frac{4096^3}{128} = \\frac{68{,}719{,}476{,}736}{128} = 536{,}870{,}912$,\n- $\\frac{4096^2}{16} = \\frac{16{,}777{,}216}{16} = 1{,}048{,}576$.\n因此\n$$\n\\text{faults}_{\\text{tiled}} = 536{,}870{,}912 + 1{,}048{,}576 = 537{,}919{,}488.\n$$\n\n缩减因子 $R$ 是朴素算法与分块算法的缺页中断次数之比：\n$$\nR = \\frac{\\text{faults}_{\\text{naive}}}{\\text{faults}_{\\text{tiled}}} = \\frac{68{,}853{,}727{,}232}{537{,}919{,}488}.\n$$\n我们可以用 $N$、$E$ 和 $b$ 精确表示 $R$：\n$$\nR \\approx \\frac{N^3 (1 + 1/E)}{2N^3/b^2} = \\frac{b^2(1+1/E)}{2} = \\frac{16^2(1+1/512)}{2} = \\frac{256(513/512)}{2} = 128 \\cdot \\frac{513}{512} \\approx 128.25.\n$$\n进行精确计算：\n$$\nR = \\frac{68{,}853{,}727{,}232}{537{,}919{,}488} \\approx 128.0000609\n$$\n四舍五入到四位有效数字，\n$$\nR = 128.0.\n$$", "answer": "$$\\boxed{128.0}$$", "id": "3633469"}]}