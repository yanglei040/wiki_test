{"hands_on_practices": [{"introduction": "Belady 异常最反直觉的一点是，增加物理帧可能会导致更多的页面错误。为了亲身体验这一现象，我们将通过一个经典的例子，一步步追踪先进先出 (FIFO) 算法的执行过程。这个练习将帮助你精确地定位异常发生的瞬间，从而将抽象的理论概念转化为具体的计算步骤 [@problem_id:3623853]。", "problem": "一个单个进程运行在一个具有虚拟内存的系统上，该虚拟内存被组织成固定大小的页面和固定数量的物理页框。每次内存引用都指向一个虚拟页面。如果被引用的页面不存在于任何页框中，就会发生缺页中断，此时一个页面被加载到一个页框中，并且在必要时，根据页面置换策略，一个驻留页面被置换出去。使用的策略是先进先出 (FIFO)，它会置换在内存中驻留时间最长的页面；一次命中不会改变 FIFO 队列中页面的顺序。\n\n考虑一个包含 $k=5$ 个不同虚拟页面（标记为 $\\{1,2,3,4,5\\}$）的引用字符串：\n$$\nR \\;=\\; (\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,).\n$$\n假设物理页框集合初始为空，并且 FIFO 队列也初始为空。首先令页框数量为 $n=3$，然后考虑增加一个页框，使得总数变为 $n+1=4$ 个页框。\n\n定义 $F_{m}(i)$ 为使用 $m$ 个页框的 FIFO 算法在处理由 $R$ 的前 $i$ 个引用组成的前缀时所产生的累计缺页中断次数，其中 $i \\in \\{1,2,\\dots,|R|\\}$ 且 $m \\in \\{n,n+1\\}$。定义异常索引\n$$\ni^{\\star} \\;=\\; \\min \\big\\{\\, i \\in \\{1,2,\\dots,|R|\\} \\;\\big|\\; F_{n+1}(i) - F_{n}(i) \\;\\; 0 \\,\\big\\},\n$$\n即，在 FIFO 策略下，将页框数量从 $n$ 增加到 $n+1$ 会导致累计缺页中断次数严格增加的最早引用位置。\n\n从上述核心定义出发，追踪对于引用字符串 $R$，在 $m=n$ 和 $m=n+1$ 两种情况下 FIFO 队列的演变，计算所有相关 $i$ 的 $F_{n}(i)$ 和 $F_{n+1}(i)$，并确定 $i^{\\star}$ 的值。将 $i^{\\star}$ 的最终值以单个整数形式报告。不需要四舍五入，也不需要报告单位。", "solution": "问题陈述经验证具有科学依据、定义明确且客观。这是操作系统中页面置换算法分析的一个标准练习。所有必要的数据和定义都已提供，没有矛盾或歧义。该问题有效。\n\n目标是找到异常索引 $i^{\\star}$，它被定义为给定引用字符串 $R$ 中，使得使用 $m=n+1=4$ 个页框的累计缺页中断次数 $F_{n+1}(i)$ 严格大于使用 $m=n=3$ 个页框的缺页中断次数 $F_{n}(i)$ 的最早引用位置 $i$。\n$$\ni^{\\star} \\;=\\; \\min \\big\\{\\, i \\in \\{1, 2, \\dots, |R|\\} \\;\\big|\\; F_{n+1}(i) - F_{n}(i) \\;\\; 0 \\,\\big\\}\n$$\n引用字符串为 $R = (\\,1,\\,2,\\,3,\\,4,\\,1,\\,2,\\,5,\\,1,\\,2,\\,3,\\,4,\\,5\\,)$，页面置换算法为先进先出 (FIFO)。物理页框初始为空。\n\n我们将追踪 FIFO 算法在 $m=3$ 和 $m=4$ 个页框两种情况下的执行过程，以计算累计缺页中断次数的序列 $F_{3}(i)$ 和 $F_{4}(i)$。FIFO 队列将表示为一个有序列表，其中最左边的页面是最先进入的（最旧的），最右边的页面是最后进入的（最新的）。\n\n首先，我们追踪 $n=3$ 个页框的情况。\n$$\n\\begin{array}{|c|c|l|c|c|}\n\\hline\n\\textbf{索引 } i  \\textbf{引用}  \\textbf{FIFO 队列状态 (最旧} \\to \\textbf{最新)}  \\textbf{是否中断？}  \\textbf{累计中断次数 } F_{3}(i) \\\\\n\\hline\n1  1  (1)  \\text{是}  1 \\\\\n2  2  (1, 2)  \\text{是}  2 \\\\\n3  3  (1, 2, 3)  \\text{是}  3 \\\\\n4  4  (2, 3, 4) \\quad \\text{(置换 1)}  \\text{是}  4 \\\\\n5  1  (3, 4, 1) \\quad \\text{(置换 2)}  \\text{是}  5 \\\\\n6  2  (4, 1, 2) \\quad \\text{(置换 3)}  \\text{是}  6 \\\\\n7  5  (1, 2, 5) \\quad \\text{(置换 4)}  \\text{是}  7 \\\\\n8  1  (1, 2, 5)  \\text{否}  7 \\\\\n9  2  (1, 2, 5)  \\text{否}  7 \\\\\n10  3  (2, 5, 3) \\quad \\text{(置换 1)}  \\text{是}  8 \\\\\n11  4  (5, 3, 4) \\quad \\text{(置换 2)}  \\text{是}  9 \\\\\n12  5  (5, 3, 4)  \\text{否}  9 \\\\\n\\hline\n\\end{array}\n$$\n对于 $n=3$ 个页框，累计缺页中断次数的序列是 $F_{3} = (1, 2, 3, 4, 5, 6, 7, 7, 7, 8, 9, 9)$。\n\n接下来，我们追踪 $n+1=4$ 个页框的情况。\n$$\n\\begin{array}{|c|c|l|c|c|}\n\\hline\n\\textbf{索引 } i  \\textbf{引用}  \\textbf{FIFO 队列状态 (最旧} \\to \\textbf{最新)}  \\textbf{是否中断？}  \\textbf{累计中断次数 } F_{4}(i) \\\\\n\\hline\n1  1  (1)  \\text{是}  1 \\\\\n2  2  (1, 2)  \\text{是}  2 \\\\\n3  3  (1, 2, 3)  \\text{是}  3 \\\\\n4  4  (1, 2, 3, 4)  \\text{是}  4 \\\\\n5  1  (1, 2, 3, 4)  \\text{否}  4 \\\\\n6  2  (1, 2, 3, 4)  \\text{否}  4 \\\\\n7  5  (2, 3, 4, 5) \\quad \\text{(置换 1)}  \\text{是}  5 \\\\\n8  1  (3, 4, 5, 1) \\quad \\text{(置换 2)}  \\text{是}  6 \\\\\n9  2  (4, 5, 1, 2) \\quad \\text{(置换 3)}  \\text{是}  7 \\\\\n10  3  (5, 1, 2, 3) \\quad \\text{(置换 4)}  \\text{是}  8 \\\\\n11  4  (1, 2, 3, 4) \\quad \\text{(置换 5)}  \\text{是}  9 \\\\\n12  5  (2, 3, 4, 5) \\quad \\text{(置换 1)}  \\text{是}  10 \\\\\n\\hline\n\\end{array}\n$$\n对于 $n+1=4$ 个页框，累计缺页中断次数的序列是 $F_{4} = (1, 2, 3, 4, 4, 4, 5, 6, 7, 8, 9, 10)$。\n\n最后，我们比较每一步 $i$ 的 $F_{3}(i)$ 和 $F_{4}(i)$，以找到满足 $F_{4}(i) > F_{3}(i)$ 的最小 $i$。我们计算差值 $D(i) = F_{4}(i) - F_{3}(i)$。\n$$\n\\begin{array}{|c|c|c|c|}\n\\hline\n\\textbf{索引 } i  F_{3}(i)  F_{4}(i)  D(i) = F_{4}(i) - F_{3}(i) \\\\\n\\hline\n1  1  1  0 \\\\\n2  2  2  0 \\\\\n3  3  3  0 \\\\\n4  4  4  0 \\\\\n5  5  4  -1 \\\\\n6  6  4  -2 \\\\\n7  7  5  -2 \\\\\n8  7  6  -1 \\\\\n9  7  7  0 \\\\\n10  8  8  0 \\\\\n11  9  9  0 \\\\\n12  9  10  1 \\\\\n\\hline\n\\end{array}\n$$\n条件 $F_{4}(i) - F_{3}(i) > 0$ 在 $i=12$ 时首次满足，此时差值为 $10 - 9 = 1$。因此，异常索引为 $i^{\\star} = 12$。这种在 FIFO 策略下，对于某些引用字符串，增加可用页框数量反而导致缺页中断次数增加的现象，被称为 Belady 异常。", "answer": "$$\\boxed{12}$$", "id": "3623853"}, {"introduction": "既然 FIFO 算法会表现出 Belady 异常，一个自然的问题是：所有页面置换算法都如此吗？通过将 FIFO 与另一种常见的策略——最近最少使用 (LRU) 算法进行对比，我们可以更深入地理解异常背后的原因。这项练习不仅能让你看到不同算法的性能差异，还能揭示为何某些算法（如 LRU）能够“免疫”此异常 [@problem_id:3623877]。", "problem": "在一个请求分页的虚拟内存系统中，页面引用串是页面标识符的一个有限序列。当请求的页面没有驻留在可用的物理帧集合中时，就会发生缺页中断。考虑两种页面置换策略：先入先出 (FIFO) 和最近最少使用 (LRU)。先入先出 (FIFO) 总是淘汰驻留时间最长的页面，而不考虑其使用情况；而最近最少使用 (LRU) 淘汰的是最近一次访问时间距离现在最远的页面。对于一个策略 $P$ 和一个帧数 $n$，我们将缺页中断计数函数 $f_{P}(n)$ 定义为：在使用 $n$ 个可用帧，从一个初始为空的帧集合开始，并且没有预取的情况下，处理一个给定引用串时所产生的总缺页中断次数。\n\n设页面引用串为\n$$R = 1,2,3,4,1,2,5,1,2,3,4,5.$$\n假设帧初始为空，当发生未命中（缺页）时，如果存在任何空闲帧，则加载页面；否则，策略会选择一个牺牲页进行替换。当发生命中时，对于 FIFO 策略，驻留集保持不变；对于 LRU 策略，仅更新其近期性元数据。\n\n仅使用上述定义作为基本依据，推导字符串 $R$ 的 $f_{FIFO}(3)$、$f_{FIFO}(4)$、$f_{LRU}(3)$ 和 $f_{LRU}(4)$。然后，定义异常差距\n$$\\Delta \\equiv \\left(f_{FIFO}(4) - f_{FIFO}(3)\\right) - \\left(f_{LRU}(4) - f_{LRU}(3)\\right).$$\n用文字解释计算出的值说明了对于此引用串，先入先出 (FIFO) 策略下是否发生了 Belady 异常，以及最近最少使用 (LRU) 策略下是否可能发生 Belady 异常。将 $\\Delta$ 的值报告为一个精确整数，无需四舍五入。", "solution": "这个问题定义明确，并以操作系统原理（特别是页面置换算法）为科学基础。它提供了所有必要的定义、一个具体的引用串以及用于计算和分析的清晰指令。我们将通过系统地模拟先入先出 (FIFO) 和最近最少使用 (LRU) 算法在 $n=3$ 和 $n=4$ 个帧的情况下的行为，来确定各自的缺页中断次数。\n\n页面引用串给定如下\n$$R = 1,2,3,4,1,2,5,1,2,3,4,5.$$\n我们用 F 表示缺页中断，H 表示命中。\n\n**1. $f_{FIFO}(3)$ 的计算**\n我们模拟具有 $n=3$ 个帧的 FIFO 策略。帧集合被当作一个队列管理，其中队首的页面是驻留时间最长的页面，也是被淘汰的候选者。\n\n| 引用 | 帧 (从最老到最新) | 换入/换出 | 类型 | 缺页中断数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $4$ |\n| $1$ | $[3, 4, 1]$ | $2$ 换出, $1$ 换入| F | $5$ |\n| $2$ | $[4, 1, 2]$ | $3$ 换出, $2$ 换入| F | $6$ |\n| $5$ | $[1, 2, 5]$ | $4$ 换出, $5$ 换入| F | $7$ |\n| $1$ | $[1, 2, 5]$ | - | H | $7$ |\n| $2$ | $[1, 2, 5]$ | - | H | $7$ |\n| $3$ | $[2, 5, 3]$ | $1$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[5, 3, 4]$ | $2$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[5, 3, 4]$ | - | H | $9$ |\n\n对于有 $3$ 个帧的 FIFO 策略，总缺页中断次数为 $f_{FIFO}(3) = 9$。\n\n**2. $f_{FIFO}(4)$ 的计算**\n我们模拟具有 $n=4$ 个帧的 FIFO 策略。\n\n| 引用 | 帧 (从最老到最新) | 换入/换出 | 类型 | 缺页中断数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[1, 2, 3, 4]$ | $4$ 换入 | F | $4$ |\n| $1$ | $[1, 2, 3, 4]$ | - | H | $4$ |\n| $2$ | $[1, 2, 3, 4]$ | - | H | $4$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $5$ |\n| $1$ | $[3, 4, 5, 1]$ | $2$ 换出, $1$ 换入| F | $6$ |\n| $2$ | $[4, 5, 1, 2]$ | $3$ 换出, $2$ 换入| F | $7$ |\n| $3$ | $[5, 1, 2, 3]$ | $4$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[1, 2, 3, 4]$ | $5$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $10$|\n\n对于有 $4$ 个帧的 FIFO 策略，总缺页中断次数为 $f_{FIFO}(4) = 10$。\n\n**3. $f_{LRU}(3)$ 的计算**\n我们模拟具有 $n=3$ 个帧的 LRU 策略。帧集合根据最近使用情况作为一个堆栈或有序列表进行管理。最近最少使用的页面位于堆栈底部（或列表头部），而最近最多使用的页面位于顶部（或尾部）。\n\n| 引用 | 帧 (从LRU到MRU) | 换入/换出 | 类型 | 缺页中断数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $4$ |\n| $1$ | $[3, 4, 1]$ | $2$ 换出, $1$ 换入| F | $5$ |\n| $2$ | $[4, 1, 2]$ | $3$ 换出, $2$ 换入| F | $6$ |\n| $5$ | $[1, 2, 5]$ | $4$ 换出, $5$ 换入| F | $7$ |\n| $1$ | $[2, 5, 1]$ | - | H | $7$ |\n| $2$ | $[5, 1, 2]$ | - | H | $7$ |\n| $3$ | $[1, 2, 3]$ | $5$ 换出, $3$ 换入| F | $8$ |\n| $4$ | $[2, 3, 4]$ | $1$ 换出, $4$ 换入| F | $9$ |\n| $5$ | $[3, 4, 5]$ | $2$ 换出, $5$ 换入| F | $10$|\n\n对于有 $3$ 个帧的 LRU 策略，总缺页中断次数为 $f_{LRU}(3) = 10$。\n\n**4. $f_{LRU}(4)$ 的计算**\n我们模拟具有 $n=4$ 个帧的 LRU 策略。\n\n| 引用 | 帧 (从LRU到MRU) | 换入/换出 | 类型 | 缺页中断数 |\n|---|---|---|---|---|\n| $1$ | $[1]$ | $1$ 换入 | F | $1$ |\n| $2$ | $[1, 2]$ | $2$ 换入 | F | $2$ |\n| $3$ | $[1, 2, 3]$ | $3$ 换入 | F | $3$ |\n| $4$ | $[1, 2, 3, 4]$ | $4$ 换入 | F | $4$ |\n| $1$ | $[2, 3, 4, 1]$ | - | H | $4$ |\n| $2$ | $[3, 4, 1, 2]$ | - | H | $4$ |\n| $5$ | $[4, 1, 2, 5]$ | $3$ 换出, $5$ 换入| F | $5$ |\n| $1$ | $[4, 2, 5, 1]$ | - | H | $5$ |\n| $2$ | $[4, 5, 1, 2]$ | - | H | $5$ |\n| $3$ | $[5, 1, 2, 3]$ | $4$ 换出, $3$ 换入| F | $6$ |\n| $4$ | $[1, 2, 3, 4]$ | $5$ 换出, $4$ 换入| F | $7$ |\n| $5$ | $[2, 3, 4, 5]$ | $1$ 换出, $5$ 换入| F | $8$ |\n\n对于有 $4$ 个帧的 LRU 策略，总缺页中断次数为 $f_{LRU}(4) = 8$。\n\n**5. 结果分析与 $\\Delta$ 的计算**\n\n计算出的缺页中断次数为：\n- $f_{FIFO}(3) = 9$\n- $f_{FIFO}(4) = 10$\n- $f_{LRU}(3) = 10$\n- $f_{LRU}(4) = 8$\n\n**Belady 异常：**\n当增加可用帧的数量导致缺页中断次数增加时，就会发生这种异常。\n\n对于 **FIFO** 策略，我们观察到 $f_{FIFO}(4) = 10 > f_{FIFO}(3) = 9$。这表明对于给定的引用串 $R$，将帧数从 $3$ 增加到 $4$ 会导致额外一次缺页中断。因此，在这种特定场景下，**FIFO 策略发生了 Belady 异常**。原因是 FIFO 不是一种“堆栈算法”；在有 $n$ 个帧时内存中的页面集合不一定是 $n+1$ 个帧时内存中页面集合的子集。淘汰选择纯粹基于到达时间，而不是使用模式，这可能导致淘汰一个很快会再次需要的页面，而更多的帧数反而可能使这种情况恶化。\n\n对于 **LRU** 策略，我们观察到 $f_{LRU}(4) = 8  f_{LRU}(3) = 10$。将帧数从 $3$ 增加到 $4$ 减少了缺页中断次数，这是预期的行为。因此，**LRU 策略没有发生 Belady 异常**。这是因为 LRU 是一种堆栈算法。对于任何堆栈算法，在引用串的任何时刻，驻留在 $n$ 个帧中的页面集合总是驻留在 $n+1$ 个帧中页面集合的子集。此属性保证了缺页中断次数是帧数的非增函数，即对于任何 $n$ 都有 $f_{P}(n+1) \\leq f_{P}(n)$。\n\n**异常差距 $\\Delta$ 的计算：**\n异常差距定义为 $\\Delta \\equiv \\left(f_{FIFO}(4) - f_{FIFO}(3)\\right) - \\left(f_{LRU}(4) - f_{LRU}(3)\\right)$。\n代入计算出的值：\n$$ \\Delta = (10 - 9) - (8 - 10) $$\n$$ \\Delta = (1) - (-2) $$\n$$ \\Delta = 1 + 2 = 3 $$\n$\\Delta$ 的值为 $3$。这个值表示当帧数增加时，FIFO 策略性能变化（异常增加 1 次中断）与 LRU 策略性能变化（正常减少 2 次中断）之间的差异。", "answer": "$$\\boxed{3}$$", "id": "3623877"}, {"introduction": "Belady 异常不仅仅是页面错误数量的一次性增加，它揭示了 FIFO 算法性能的根本性不可预测性。这个练习将展示一个更复杂的场景：页面错误率并非随帧数单调变化，甚至可能出现先增后减的波动。完成这个追踪练习将让你深刻体会到，对于 FIFO 算法，简单地增加资源并不总能带来预期的性能提升 [@problem_id:3623856]。", "problem": "一个计算机系统使用先进先出（FIFO）页面置换算法。页面引用串是页面标识符的一个序列。当引用的页面不在任何页框中时，会发生缺页；如果存在空闲页框，则加载该页面，否则将驻留时间最长（即最早进入内存且仍在内存中的页面）的页面淘汰。所有页框最初都是空的，FIFO使用基于到达时间的严格队列规则；一次命中不会改变页面在队列中的位置。\n\n设 $f(k)$ 表示当有 $k$ 个页框时，FIFO算法在固定引用串上产生的缺页次数。考虑引用串\n$$\nR = \\langle 2,3,4,5,2,3,1,2,3,4,5,1 \\rangle,\n$$\n并设 $n=3$。\n\n仅使用上述操作定义，通过精确模拟FIFO算法来确定给定引用串 $R$ 的 $f(n)$、$f(n+1)$ 和 $f(n+2)$。将您的最终数值结果以行矩阵的形式报告，顺序为 $\\big(f(n),\\,f(n+1),\\,f(n+2)\\big)$。\n\n无需四舍五入。最终答案仅表达为行矩阵。", "solution": "问题陈述已经过验证，是自洽的、有科学依据且定义明確的。它描述了操作系统研究中的一个标准场景——页面置换算法的模拟。定义是精确的，并且所需的计算可以通过算法执行以得出唯一解。我们将通过模拟先进先出（FIFO）页面置换算法来求解，针对指定的页框数进行计算。\n\n任务是计算当页框数 $k \\in \\{3, 4, 5\\}$ 时，缺页次数 $f(k)$。给定的引用串为 $R = \\langle 2,3,4,5,2,3,1,2,3,4,5,1 \\rangle$。FIFO算法淘汰在内存中停留时间最长的页面。我们维护一个当前在页框中的页面队列，其中队首是最旧的页面，队尾是最近加载的页面。\n\n**情况 1：$k=n=3$ 个页框**\n\n我们用 $3$ 个页框来模拟这个过程。缺页用‘F’标记，命中用‘H’标记。我们跟踪页框的状态（作为一个集合）和FIFO队列（有序列表，从队首到队尾）。\n\n| 时间步 | 引用 | 页框内容（集合） | FIFO 队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{3, 4, 5\\}$ | $\\langle 3, 4, 5 \\rangle$ | F ($4$, 淘汰 $2$) |\n| $5$ | $2$ | $\\{4, 5, 2\\}$ | $\\langle 4, 5, 2 \\rangle$ | F ($5$, 淘汰 $3$) |\n| $6$ | $3$ | $\\{5, 2, 3\\}$ | $\\langle 5, 2, 3 \\rangle$ | F ($6$, 淘汰 $4$) |\n| $7$ | $1$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | F ($7$, 淘汰 $5$) |\n| $8$ | $2$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | H |\n| $9$ | $3$ | $\\{2, 3, 1\\}$ | $\\langle 2, 3, 1 \\rangle$ | H |\n| $10$ | $4$ | $\\{3, 1, 4\\}$ | $\\langle 3, 1, 4 \\rangle$ | F ($8$, 淘汰 $2$) |\n| $11$ | $5$ | $\\{1, 4, 5\\}$ | $\\langle 1, 4, 5 \\rangle$ | F ($9$, 淘汰 $3$) |\n| $12$ | $1$ | $\\{1, 4, 5\\}$ | $\\langle 1, 4, 5 \\rangle$ | H |\n\n当页框数为 $k=3$ 时，总缺页次数为 $9$。因此，$f(3) = 9$。\n\n**情况 2：$k=n+1=4$ 个页框**\n\n我们用 $4$ 个页框重复此模拟。\n\n| 时间步 | 引用 | 页框内容（集合） | FIFO 队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($4$) |\n| $5$ | $2$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $6$ | $3$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $7$ | $1$ | $\\{3, 4, 5, 1\\}$ | $\\langle 3, 4, 5, 1 \\rangle$ | F ($5$, 淘汰 $2$) |\n| $8$ | $2$ | $\\{4, 5, 1, 2\\}$ | $\\langle 4, 5, 1, 2 \\rangle$ | F ($6$, 淘汰 $3$) |\n| $9$ | $3$ | $\\{5, 1, 2, 3\\}$ | $\\langle 5, 1, 2, 3 \\rangle$ | F ($7$, 淘汰 $4$) |\n| $10$ | $4$ | $\\{1, 2, 3, 4\\}$ | $\\langle 1, 2, 3, 4 \\rangle$ | F ($8$, 淘汰 $5$) |\n| $11$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($9$, 淘汰 $1$) |\n| $12$ | $1$ | $\\{3, 4, 5, 1\\}$ | $\\langle 3, 4, 5, 1 \\rangle$ | F ($10$, 淘汰 $2$) |\n\n当页框数为 $k=4$ 时，总缺页次数为 $10$。因此，$f(4) = 10$。\n我们观察到 $f(4) > f(3)$，这是 Belady 异常的一个实例，它是 FIFO 算法的一个已知特性。\n\n**情况 3：$k=n+2=5$ 个页框**\n\n最后，我们用 $5$ 个页框进行模拟。\n\n| 时间步 | 引用 | 页框内容（集合） | FIFO 队列（最旧...最新） | 结果 |\n| :---: | :---: | :---: | :---: | :---: |\n| $1$ | $2$ | $\\{2\\}$ | $\\langle 2 \\rangle$ | F ($1$) |\n| $2$ | $3$ | $\\{2, 3\\}$ | $\\langle 2, 3 \\rangle$ | F ($2$) |\n| $3$ | $4$ | $\\{2, 3, 4\\}$ | $\\langle 2, 3, 4 \\rangle$ | F ($3$) |\n| $4$ | $5$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | F ($4$) |\n| $5$ | $2$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $6$ | $3$ | $\\{2, 3, 4, 5\\}$ | $\\langle 2, 3, 4, 5 \\rangle$ | H |\n| $7$ | $1$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | F ($5$) |\n| $8$ | $2$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $9$ | $3$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $10$ | $4$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $11$ | $5$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n| $12$ | $1$ | $\\{2, 3, 4, 5, 1\\}$ | $\\langle 2, 3, 4, 5, 1 \\rangle$ | H |\n\n引用串中的唯一页面集合是 $\\{1, 2, 3, 4, 5\\}$，其基数为 $5$。由于可用页框数 $k=5$ 等于唯一页面的数量，因此仅在首次引用每个唯一页面时才会发生缺页。在前 $7$ 个时间步之后，所有唯一页面都已加载到页框中，不再发生淘汰或缺页。\n当页框数为 $k=5$ 时，总缺页次数为 $5$。因此，$f(5) = 5$。\n\n**结果总结**\n计算出的缺页次数如下：\n$f(n) = f(3) = 9$\n$f(n+1) = f(4) = 10$\n$f(n+2) = f(5) = 5$\n\n问题要求将这些结果以行矩阵 $\\big(f(n),\\,f(n+1),\\,f(n+2)\\big)$ 的形式报告。\n代入我们找到的值：$\\begin{pmatrix} 9  10  5 \\end{pmatrix}$。", "answer": "$$\n\\boxed{\\begin{pmatrix} 9  10  5 \\end{pmatrix}}\n$$", "id": "3623856"}]}