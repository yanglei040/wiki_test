{"hands_on_practices": [{"introduction": "共享库的核心优势之一是节省物理内存，允许多个进程共享同一份代码副本。然而，只有当代码段（`.text` segment）保持真正只读时，这种共享才是最高效的。本实践将指导您构建一个计算模型，用以量化非位置无关代码（non-PIC）因“写时复制”（copy-on-write）机制而产生的额外内存开销，从而深刻理解为何位置无关代码（PIC）是现代共享库的基石。[@problem_id:3636956]", "problem": "您需要建模并量化在采用页式虚拟内存和写时复制（copy-on-write）的操作系统中，加载共享库时动态重定位对内存共享的影响。您将比较一个非位置无关代码（non-position-independent code, non-PIC）共享对象与一个位置无关代码（position-independent code, PIC）共享对象。目标是推导并计算在每种模型下，跨多个进程由重定位引起的额外私有内存；解释为什么在严格的“写异或执行”（write-xor-execute）策略下，non-PIC 文本重定位可能会失败；以及全局偏移表（Global Offset Table, GOT）和过程链接表（Procedure Linkage Table, PLT）的设计如何将重定位写入操作移出只读的文本段。\n\n使用的基本原理：\n- 大小为 $P$ 字节的虚拟内存页的定义，具有写时复制（copy-on-write）语义：如果 $k$ 个进程映射同一个基于文件的只读页面，它们共享一个物理副本。如果任何进程写入该页面，操作系统会为该进程创建一个私有副本。因此，在写时复制的页面上写入，会使每个进程的私有内存使用量在单个共享副本之外增加 $P$ 字节。\n- 运行时链接器通过动态重定位将解析后的地址写入重定位目标。\n- 在非位置无关模型中，文本段中的绝对地址需要文本重定位；写入文本段会导致每个进程对这些页面进行写时复制，或者在禁止将文本段设为可写的严格“写异或执行”策略下失败。\n- 在位置无关模型中，全局偏移表（GOT）存放待解析的地址，过程链接表（PLT）通过 GOT 进行间接跳转。重定位写入被重定向到可写的数据页（GOT）中，从而保持文本段为只读且完全可共享。\n\n数学模型与所需计算：\n- 设有名为 $N$ 的进程并发映射同一个共享对象。\n- 设页面大小为 $P$ 字节。\n- 设文本段大小为 $T$ 字节。设 non-PIC 文本重定位偏移量的集合为 $\\mathcal{O} = \\{o_1, o_2, \\dots, o_a\\}$，其中每个 $o_i$ 是动态链接器写入的、从文本段起始位置算起的字节偏移量，位于 $[0, T-1]$ 范围内。\n- 设 GOT 总大小为 $G$ 字节，分为大小为 $E$ 字节的条目。设需要重定位的 GOT 索引集合为 $\\mathcal{I} = \\{i_1, i_2, \\dots, i_b\\}$，其中每个 $i_j$ 是一个整数索引，满足 $0 \\le i_j \\cdot E  G$。这些 GOT 重定位在 non-PIC 和 PIC 两种情况下都会发生。\n- 定义因重定位而变“脏”（dirty）的文本页集合为 $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor \\dfrac{o}{P} \\right\\rfloor \\,\\middle|\\, o \\in \\mathcal{O} \\right\\}$，其基数为 $U_{\\text{text}} = \\left|\\mathcal{P}_{\\text{text}}\\right|$。\n- 定义因重定位而变“脏”的 GOT 页集合为 $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor \\dfrac{i \\cdot E}{P} \\right\\rfloor \\,\\middle|\\, i \\in \\mathcal{I} \\right\\}$，其基数为 $U_{\\text{got}} = \\left|\\mathcal{P}_{\\text{got}}\\right|$。\n- 仅由重定位引起的额外私有内存使用写时复制语义计算如下：\n  - 对于 non-PIC，文本页和 GOT 页都会变“脏”： \n    $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P$$\n  - 对于 PIC，只有 GOT 页会变“脏”（文本段保持只读且完全共享）：\n    $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P$$\n- 给定一个严格的“写异或执行”策略指示符 $\\sigma \\in \\{0,1\\}$，其中 $\\sigma = 1$ 禁止文本重定位。失败指示符为 \n  $$F = \\begin{cases}\n  1,  \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0,\\\\\n  0,  \\text{otherwise.}\n  \\end{cases}$$\n\n您的程序必须为每个测试用例计算四元组 \n$$\\left[F,\\; M_{\\text{nonpic}},\\; M_{\\text{pic}},\\; M_{\\text{nonpic}} - M_{\\text{pic}}\\right],$$ \n其中所有量都是以字节为单位的整数。差值 $M_{\\text{nonpic}} - M_{\\text{pic}}$ 表示通过使用位置无关代码节省的额外私有内存字节数；在此模型下，它将是非负的。\n\n单位：所有内存大小必须以字节表示。\n\n角度单位：不适用。\n\n百分比：不适用。\n\n需要在程序中实现的测试套件：\n- 用例 A（一般情况）：\n  - $P = 4096$, $N = 10$, $T = 16384$, $G = 4096$, $E = 8$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{100, 4095, 4096, 8191\\}$,\n  - $\\mathcal{I} = \\{0, 1\\}$.\n- 用例 B（无文本重定位，仅有 GOT 重定位，启用严格策略）：\n  - $P = 4096$, $N = 5$, $T = 4096$, $G = 4096$, $E = 8$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\emptyset$,\n  - $\\mathcal{I} = \\{0, 400\\}$.\n- 用例 C（所有文本重定位在单个页面内，偏移量重复，去重边界条件）：\n  - $P = 1024$, $N = 3$, $T = 2048$, $G = 1024$, $E = 16$, $\\sigma = 1$,\n  - $\\mathcal{O} = \\{0, 1, 1023\\}$,\n  - $\\mathcal{I} = \\{0\\}$.\n- 用例 D（由于条目大小，GOT 条目跨越两个页面；触及多个文本页；$N$ 大于1的最小值）：\n  - $P = 4096$, $N = 2$, $T = 32768$, $G = 9000$, $E = 500$, $\\sigma = 0$,\n  - $\\mathcal{O} = \\{0, 5000, 9000, 16000, 32000\\}$,\n  - $\\mathcal{I} = \\{0, 9\\}$.\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含一个逗号分隔的各测试结果列表，并用一对单独的方括号括起来。每个测试结果本身必须是方括号中的四个整数列表。输出中不允许有任何空格。\n- 示例总体形式： \n  - 对于 $k$ 个测试用例，输出应如下所示：\n  $$\"[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],\\dots,[r_{k,1},r_{k,2},r_{k,3},r_{k,4}]]\"$$", "solution": "该问题要求分析共享库的动态重定位所产生的内存开销，并比较位置无关代码（PIC）与非位置无关代码（non-PIC）。此分析的背景是一个采用虚拟内存、分页内存管理和写时复制（COW）机制的现代操作系统。\n\n### 基本原理\n\n1.  **虚拟内存与分页**：操作系统为每个进程提供其私有的虚拟地址空间，该空间被映射到称为“页”（page）的离散物理内存单元。一个页是大小为 $P$ 字节的连续虚拟内存块。\n\n2.  **共享库与写时复制 (COW)**：为了节省物理内存，当多个进程加载同一个共享库时，操作系统会将其相应的虚拟页映射到相同的物理内存页上。最初，这些页被标记为只读。如果任何进程试图写入这样一个共享页，COW 机制就会被触发。操作系统会拦截该写操作，分配一个新的物理页，将原始共享页的内容复制到新页上，并将写入进程的虚拟页映射到这个新的、私有的、可写的副本上。这在为只读数据最大化内存共享的同时，确保了进程隔离。对于一个最终所有 $N$ 个进程都会写入的单个页面，COW 故障的成本是创建 $N-1$ 个新的物理页，即在第一次写入触发初始分离后，为其余每个进程创建一个。总私有内存变为 $N \\cdot P$ 字节，比单个共享页增加了 $(N-1) \\cdot P$ 字节。\n\n3.  **动态重定位**：当程序使用共享库时，库中函数和全局变量的地址在编译时是未知的。动态链接器在加载时或运行时通过将实际虚拟地址写入指定位置来解析这些符号引用。这些写操作被称为重定位。\n\n4.  **非位置无关代码 (non-PIC)**：在这种较旧的模型中，编译器生成使用绝对地址的代码。因此，机器代码本身（`.text` 段）包含必须由动态链接器用正确地址进行修补的位置。这些被称为文本重定位。当进程加载一个 non-PIC 共享库时，动态链接器必须写入其 `.text` 段。这种写操作会为每个包含重定位目标的页面触发 COW。\n\n5.  **位置无关代码 (PIC) 与 GOT/PLT**：为避免文本重定位，现代系统使用 PIC。所有内存访问都相对于当前指令指针进行。对于外部符号，这是通过两个结构来协调的：\n    *   **全局偏移表 (GOT)**：位于可写数据段中的一个表，用于存储外部函数和变量的绝对地址。\n    *   **过程链接表 (PLT)**：位于文本段中的一个只读表，包含小的代码存根（stub）。当共享库中的函数首次被调用时，其 PLT 条目会调用动态链接器中的一个解析器例程。解析器找到该函数的真实地址并将其写入相应的 GOT 条目。之后对同一函数的调用会通过 PLT 重定向到 GOT，GOT 中现在包含了正确的地址，从而直接跳转到该地址。\n\n    这种设计确保了所有重定位写入都发生在可写的数据段（具体来说是 GOT），使得文本段保持原始状态（只读）。因此，文本段可以在所有进程之间共享，而不会因重定位触发 COW 故障。\n\n6.  **写异或执行 (W^X)**：一种安全策略，防止内存页同时既可写又可执行。这可以缓解某些类型的攻击，例如注入并执行恶意代码的缓冲区溢出。在严格的 W^X 策略下，尝试将可执行页（如 `.text` 段中的页）变为可写将会失败。因此，在这种策略下，加载需要文本重定位的 non-PIC 共享库是不可能的。\n\n### 数学模型推导\n\n该问题提供了一个形式化模型来量化内存影响。\n\n-   **唯一的“脏”页**：偏移量为 $o$ 的重定位会弄“脏”（dirty）索引为 $\\left\\lfloor o/P \\right\\rfloor$ 的页面。由于多个重定位可能落在同一页面内，我们必须计算受影响的*唯一*页面数量。被弄“脏”的唯一文本页集合为 $\\mathcal{P}_{\\text{text}} = \\left\\{ \\left\\lfloor o/P \\right\\rfloor \\mid o \\in \\mathcal{O} \\right\\}$，其基数为 $U_{\\text{text}} = |\\mathcal{P}_{\\text{text}}|$。类似地，对于 GOT，条目 $i$ 的重定位发生在偏移量 $i \\cdot E$ 处。被弄“脏”的唯一 GOT 页集合为 $\\mathcal{P}_{\\text{got}} = \\left\\{ \\left\\lfloor (i \\cdot E)/P \\right\\rfloor \\mid i \\in \\mathcal{I} \\right\\}$，其基数为 $U_{\\text{got}} = |\\mathcal{P}_{\\text{got}}|$。\n\n-   **额外私有内存计算**：对于每个被写入的唯一页面，在 $N$ 个进程中会创建 $N-1$ 个私有副本，每个副本的大小为 $P$。\n    -   对于 **non-PIC** 库，会发生文本重定位和 GOT 重定位。被弄“脏”的唯一页面总数为 $U_{\\text{text}} + U_{\\text{got}}$。因此，总的额外私有内存为：\n        $$M_{\\text{nonpic}} = (N - 1) \\cdot (U_{\\text{text}} + U_{\\text{got}}) \\cdot P$$\n    -   对于 **PIC** 库，只发生 GOT 重定位。文本段不会被写入，因此 $U_{\\text{text}}$ 不会产生 COW 开销。额外私有内存为：\n        $$M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{got}} \\cdot P$$\n\n-   **失败指示符 ($F$)**：该指示符模拟了 W^X 策略的效果。如果策略是严格的（$\\sigma=1$）并且存在任何文本重定位（$U_{\\text{text}} > 0$），加载过程就会失败。\n    $$F = \\begin{cases} 1,  \\text{if } \\sigma = 1 \\text{ and } U_{\\text{text}} > 0 \\\\ 0,  \\text{otherwise} \\end{cases}$$\n\n-   **内存节省**：差值 $M_{\\text{nonpic}} - M_{\\text{pic}}$ 量化了通过使用 PIC 实现的内存节省，这完全归功于避免了文本重定位：\n    $$M_{\\text{nonpic}} - M_{\\text{pic}} = (N - 1) \\cdot U_{\\text{text}} \\cdot P$$\n\n### 测试用例计算\n\n解决方案要求为每个给定的测试用例计算四元组 $\\left[F, M_{\\text{nonpic}}, M_{\\text{pic}}, M_{\\text{nonpic}} - M_{\\text{pic}}\\right]$。这涉及到通过找到给定重定位偏移量的唯一页面索引数来确定 $U_{\\text{text}}$ 和 $U_{\\text{got}}$，然后应用上述公式。\n\n**用例 A：** $P=4096, N=10, \\sigma=0, \\mathcal{O}=\\{100, 4095, 4096, 8191\\}, \\mathcal{I}=\\{0, 1\\}, E=8$。\n-   $U_{\\text{text}}$：偏移量 $100, 4095$ 映射到页面 $\\lfloor 100/4096 \\rfloor = \\lfloor 4095/4096 \\rfloor = 0$。偏移量 $4096, 8191$ 映射到页面 $\\lfloor 4096/4096 \\rfloor = \\lfloor 8191/4096 \\rfloor = 1$。唯一页面集合为 $\\{0, 1\\}$，因此 $U_{\\text{text}}=2$。\n-   $U_{\\text{got}}$：索引 $0, 1$ 产生的偏移量为 $0 \\cdot 8=0$ 和 $1 \\cdot 8=8$。两者都映射到页面 $\\lfloor 0/4096 \\rfloor = \\lfloor 8/4096 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=0$，因为 $\\sigma=0$。\n-   $M_{\\text{nonpic}} = (10-1) \\cdot (2+1) \\cdot 4096 = 9 \\cdot 3 \\cdot 4096 = 110592$ 字节。\n-   $M_{\\text{pic}} = (10-1) \\cdot 1 \\cdot 4096 = 9 \\cdot 4096 = 36864$ 字节。\n-   差值 = $110592 - 36864 = 73728$ 字节。\n-   结果：$[0, 110592, 36864, 73728]$\n\n**用例 B：** $P=4096, N=5, \\sigma=1, \\mathcal{O}=\\emptyset, \\mathcal{I}=\\{0, 400\\}, E=8$。\n-   $U_{\\text{text}}=0$ 因为 $\\mathcal{O}$ 为空。\n-   $U_{\\text{got}}$：索引 $0, 400$ 产生的偏移量为 $0, 3200$。两者都映射到页面 $\\lfloor 0/4096 \\rfloor = \\lfloor 3200/4096 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=0$ 因为 $U_{\\text{text}}=0$。\n-   $M_{\\text{nonpic}} = (5-1) \\cdot (0+1) \\cdot 4096 = 4 \\cdot 4096 = 16384$ 字节。\n-   $M_{\\text{pic}} = (5-1) \\cdot 1 \\cdot 4096 = 4 \\cdot 4096 = 16384$ 字节。\n-   差值 = $0$ 字节。\n-   结果：$[0, 16384, 16384, 0]$\n\n**用例 C：** $P=1024, N=3, \\sigma=1, \\mathcal{O}=\\{0, 1, 1023\\}, \\mathcal{I}=\\{0\\}, E=16$。\n-   $U_{\\text{text}}$：偏移量 $0, 1, 1023$ 都映射到页面 $\\lfloor 0/1024 \\rfloor = \\dots = \\lfloor 1023/1024 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{text}}=1$。\n-   $U_{\\text{got}}$：索引 $0$ 产生的偏移量为 $0$，映射到页面 $\\lfloor 0/1024 \\rfloor = 0$。集合为 $\\{0\\}$，因此 $U_{\\text{got}}=1$。\n-   $F=1$ 因为 $\\sigma=1$ 且 $U_{\\text{text}}=1 > 0$。\n-   $M_{\\text{nonpic}} = (3-1) \\cdot (1+1) \\cdot 1024 = 2 \\cdot 2 \\cdot 1024 = 4096$ 字节。\n-   $M_{\\text{pic}} = (3-1) \\cdot 1 \\cdot 1024 = 2 \\cdot 1024 = 2048$ 字节。\n-   差值 = $2048$ 字节。\n-   结果：$[1, 4096, 2048, 2048]$\n\n**用例 D：** $P=4096, N=2, \\sigma=0, \\mathcal{O}=\\{0, 5000, 9000, 16000, 32000\\}, \\mathcal{I}=\\{0, 9\\}, E=500$。\n-   $U_{\\text{text}}$：页面索引为 $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 5000/4096 \\rfloor=1$, $\\lfloor 9000/4096 \\rfloor=2$, $\\lfloor 16000/4096 \\rfloor=3$, $\\lfloor 32000/4096 \\rfloor=7$。集合为 $\\{0, 1, 2, 3, 7\\}$，因此 $U_{\\text{text}}=5$。\n-   $U_{\\text{got}}$：索引 $0, 9$ 产生的偏移量为 $0, 4500$。页面索引为 $\\lfloor 0/4096 \\rfloor=0$, $\\lfloor 4500/4096 \\rfloor=1$。集合为 $\\{0, 1\\}$，因此 $U_{\\text{got}}=2$。\n-   $F=0$ 因为 $\\sigma=0$。\n-   $M_{\\text{nonpic}} = (2-1) \\cdot (5+2) \\cdot 4096 = 1 \\cdot 7 \\cdot 4096 = 28672$ 字节。\n-   $M_{\\text{pic}} = (2-1) \\cdot 2 \\cdot 4096 = 1 \\cdot 2 \\cdot 4096 = 8192$ 字节。\n-   差值 = $28672 - 8192 = 20480$ 字节。\n-   结果：$[0, 28672, 8192, 20480]$", "answer": "```c\n#include", "id": "3636956"}, {"introduction": "理解了共享库的效率优势后，我们来探索其强大的灵活性。本实践聚焦于“符号劫持”（symbol interposition），这是一种允许预加载库（通过 `LD_PRELOAD`）覆盖其他库中函数的强大机制。通过本练习，您将模拟动态链接器的解析逻辑，预测在不同场景下哪个函数版本会被最终调用，并体会这一强大功能在调试、监控或扩展现有应用方面的巨大潜力。[@problem_id:3636919]", "problem": "您将实现一个完整的、可运行的程序，该程序在一个简化但科学上合理的“可执行与可链接格式 (ELF)”运行时解析的抽象模型下，为名为 \"open\" 的单一符号模拟动态链接器的符号介入。程序必须针对一个固定的测试套件，确定运行时链接器选择了哪个对象的 \"open\" 定义，以及这一选择是否构成了通过“负载预加载 (LD_PRELOAD)”机制的符号介入。程序必须生成单行输出来编码这些结果。\n\n本任务的基本依据是操作系统和动态链接领域中以下经过充分检验的事实和核心定义。动态链接器会构建一个带有有序搜索列表的全局解析作用域；列表中的靠前条目会对靠后条目进行介入。当应用 LD_PRELOAD 时，其指定的库被放置在搜索顺序的最前端。在安全执行上下文（例如，set-user-ID 二进制文件会引导动态加载器进入安全模式）中，基于环境的预加载会被忽略。一个符号定义必须以默认可见性进行全局导出，并匹配所需的符号版本，才有资格被解析。隐藏可见性通过使符号变为不可抢占来防止外部介入，而版本不匹配的定义则会被拒绝。\n\n使用以下定义来为运行时解析建模。假设有 $n$ 个动态加载的对象（包括主可执行文件）。每个对象由一个属性元组 $(\\text{id}, \\text{is\\_main}, \\text{load\\_source}, \\text{preload\\_order}, \\text{dep\\_order}, \\text{defines}, \\text{visibility}, \\text{version})$ 描述，其中：\n- $\\text{id} \\in \\mathbb{Z}$ 是在结果中报告的标识符（例如，主可执行文件为 $0$）。\n- $\\text{is\\_main} \\in \\{0,1\\}$ 指示对象是否为主可执行文件（$1$）或不是（$0$）。\n- $\\text{load\\_source} \\in \\{0,1\\}$ 指示是普通依赖（$0$）还是通过 LD\\_PRELOAD 加载（$1$）。\n- $\\text{preload\\_order} \\in \\mathbb{Z}$ 是在 LD\\_PRELOAD 库中的位置（数字越小表示在搜索列表中越靠前）；对于非 LD\\_PRELOAD 对象，此值设为 $-1$。\n- $\\text{dep\\_order} \\in \\mathbb{Z}$ 是在普通依赖中的加载顺序（数字越小表示在搜索列表中越靠前）；对于非依赖对象（如主可执行文件），此值设为 $-1$。\n- $\\text{defines} \\in \\{0,1\\}$ 指示对象是否定义了符号 \"open\"。\n- $\\text{visibility} \\in \\{0,1\\}$ 指示符号 \"open\" 的可见性是默认（$0$）还是隐藏（$1$）。\n- $\\text{version} \\in \\mathbb{Z}$ 是对象为 \"open\" 提供的符号版本。\n\n设全局所需版本为 $V_{\\text{req}} \\in \\mathbb{Z}$，并设 $\\text{secure} \\in \\{0,1\\}$ 指示安全执行是否激活（$1$）或未激活（$0$）。动态链接器的搜索顺序建模如下：\n- 如果 $\\text{secure} = 0$，搜索列表首先是按 $\\text{preload\\_order}$ 升序排序的 LD\\_PRELOAD 库，然后是主可执行文件（唯一的 $\\text{is\\_main} = 1$ 的对象），最后是按 $\\text{dep\\_order}$ 升序排序的普通依赖。\n- 如果 $\\text{secure} = 1$，LD\\_PRELOAD 库被忽略，搜索列表首先是主可执行文件，然后是按 $\\text{dep\\_order}$ 升序排序的普通依赖。\n\n将对象 $o$ 的资格谓词 $P(o)$ 定义为 $P(o) = (\\text{defines} = 1) \\land (\\text{visibility} = 0) \\land (\\text{version} = V_{\\text{req}})$。解析函数 $R$ 返回搜索列表中第一个使 $P(o)$ 为真的对象的 $\\text{id}$，如果不存在这样的对象，则返回 $-1$。将介入指示符 $I$ 定义为：如果选中的对象具有 $\\text{load\\_source} = 1$，则 $I$ 为 $1$，否则为 $0$；如果 $R = -1$，则 $I = 0$。\n\n用 C 语言实现一个程序，该程序硬编码下方的测试套件，并以指定格式将所有测试用例的结果打印在单一行上。程序不得执行任何文件输入或输出，并且除了基本计算和打印外，不得依赖任何操作系统功能。程序必须通过根据上述规则构建搜索顺序并应用谓词 $P$，来为每个测试用例计算 $R$ 和 $I$。\n\n测试套件：\n- 用例 $1$ (使用 LD\\_PRELOAD 成功介入的常规路径)：\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$。\n  - 对象：\n    - 主可执行文件 $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - 预加载库 $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - 普通依赖 $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- 用例 $2$ (安全执行忽略 LD\\_PRELOAD)：\n  - $\\text{secure} = 1$, $V_{\\text{req}} = 10$, $n = 3$。\n  - 对象：\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- 用例 $3$ (隐藏可见性阻止介入)：\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$。\n  - 对象：\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=1, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- 用例 $4$ (LD\\_PRELOAD 中版本不匹配导致回退)：\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$。\n  - 对象：\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- 用例 $5$ (多个 LD\\_PRELOAD 库，顺序决定介入)：\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 4$。\n  - 对象：\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L3$: $(\\text{id}=3, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=1, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=10)$。\n- 用例 $6$ (没有符合资格的提供者：边界情况)：\n  - $\\text{secure} = 0$, $V_{\\text{req}} = 10$, $n = 3$。\n  - 对象：\n    - $E$: $(\\text{id}=0, \\text{is\\_main}=1, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=-1, \\text{defines}=0, \\text{visibility}=0, \\text{version}=0)$。\n    - $L1$: $(\\text{id}=1, \\text{is\\_main}=0, \\text{load\\_source}=1, \\text{preload\\_order}=0, \\text{dep\\_order}=-1, \\text{defines}=1, \\text{visibility}=0, \\text{version}=20)$。\n    - $L2$: $(\\text{id}=2, \\text{is\\_main}=0, \\text{load\\_source}=0, \\text{preload\\_order}=-1, \\text{dep\\_order}=0, \\text{defines}=1, \\text{visibility}=0, \\text{version}=30)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表。该列表必须包含 $12$ 个整数：对于从 $1$ 到 $6$ 的每个测试用例 $i$，输出所选提供者的 $\\text{id}$，后跟介入指示符。格式为 $[\\text{id}_1,I_1,\\text{id}_2,I_2,\\dots,\\text{id}_6,I_6]$，不含多余的空格或文本。", "solution": "该问题要求根据一套形式化规则，实现一个模拟动态链接器符号解析过程的算法。解决方案的核心是为每个测试用例执行两个主要步骤：构建有序的符号搜索列表，然后遍历该列表以找到第一个符合条件的符号提供者。\n\n### 1. 数据表示与算法结构\n首先，我们需要将问题中定义的对象属性和测试用例参数在程序中表示出来。可以定义一个结构体来存储每个对象（可执行文件或库）的属性元组。整个程序将遍历一个包含六个测试用例的硬编码集合。\n\n对于每个测试用例，算法如下：\n1.  **构建搜索列表**：根据 `secure` 标志和对象类型，生成一个有序的对象列表。\n2.  **符号解析**：按顺序遍历列表，对每个对象应用资格谓词 `P(o)`。\n3.  **确定结果**：找到第一个满足 `P(o)` 的对象，记录其 `id` 作为解析结果 `R`，并根据其 `load_source` 属性确定介入指示符 `I`。\n\n### 2. 搜索列表构建\n搜索列表的顺序是解析的关键。\n-   **分类**：首先，将所有对象分为三组：`LD_PRELOAD` 库（`load_source == 1`）、主可执行文件（`is_main == 1`）和普通依赖库。\n-   **排序**：\n    -   对 `LD_PRELOAD` 库组，按 `preload_order` 升序排序。\n    -   对普通依赖库组，按 `dep_order` 升序排序。\n-   **组合**：根据 `secure` 标志组合成最终的搜索列表。\n    -   如果 `secure == 0`（非安全模式），顺序为：已排序的 `LD_PRELOAD` 库 -> 主可执行文件 -> 已排序的普通依赖。\n    -   如果 `secure == 1`（安全模式），`LD_PRELOAD` 库被忽略，顺序为：主可执行文件 -> 已排序的普通依赖。\n\n### 3. 符号解析与结果计算\n构建好搜索列表后，从头到尾遍历它。对于列表中的每个对象 `o`：\n-   检查其是否满足资格谓词 `P(o)`，即 `(defines == 1)  (visibility == 0)  (version == V_req)`。\n-   第一个满足此条件的 `o` 就是解析结果。\n    -   `R` 被设为该对象的 `id`。\n    -   如果该对象的 `load_source == 1`，则 `I` 设为 `1`（表示发生了介入）；否则 `I` 设为 `0`。\n    -   一旦找到，立即停止搜索并进入下一个测试用例。\n-   如果遍历完整个列表都没有找到符合条件的对象，则解析失败。\n    -   `R` 设为 `-1`。\n    -   `I` 设为 `0`。\n\n### 测试用例解析示例\n\n#### 用例 1: `[1, 1]`\n- `secure = 0`，`V_req = 10`。\n- 搜索顺序：`LD_PRELOAD` 库（L1，`preload_order=0`） -> 主可执行文件（E） -> 普通依赖（L2，`dep_order=0`）。即 `[L1, E, L2]`。\n- 检查 L1 (`id=1`)：`defines=1`, `visibility=0`, `version=10`。满足 `P(o)`。\n- **结果**：`R=1`。因为 L1 是 `LD_PRELOAD` 库，所以 `I=1`。\n\n#### 用例 2: `[2, 0]`\n- `secure = 1`，`V_req = 10`。\n- `LD_PRELOAD` 库 L1 被忽略。\n- 搜索顺序：主可执行文件（E） -> 普通依赖（L2）。即 `[E, L2]`。\n- 检查 E (`id=0`)：`defines=0`。不满足 `P(o)`。\n- 检查 L2 (`id=2`)：`defines=1`, `visibility=0`, `version=10`。满足 `P(o)`。\n- **结果**：`R=2`。L2 不是 `LD_PRELOAD` 库，所以 `I=0`。\n\n#### 用例 3: `[2, 0]`\n- `secure = 0`，`V_req = 10`。\n- 搜索顺序：`[L1, E, L2]`。\n- 检查 L1 (`id=1`)：`visibility=1`（隐藏）。不满足 `P(o)`。\n- 检查 E (`id=0`)：`defines=0`。不满足 `P(o)`。\n- 检查 L2 (`id=2`)：`defines=1`, `visibility=0`, `version=10`。满足 `P(o)`。\n- **结果**：`R=2`。`I=0`。\n\n#### 用例 4: `[2, 0]`\n- `secure = 0`，`V_req = 10`。\n- 搜索顺序：`[L1, E, L2]`。\n- 检查 L1 (`id=1`)：`version=20`，不等于 `V_req`。不满足 `P(o)`。\n- 检查 E (`id=0`)：`defines=0`。不满足 `P(o)`。\n- 检查 L2 (`id=2`)：`defines=1`, `visibility=0`, `version=10`。满足 `P(o)`。\n- **结果**：`R=2`。`I=0`。\n\n#### 用例 5: `[3, 1]`\n- `secure = 0`，`V_req = 10`。\n- `LD_PRELOAD` 库有 L3 (`preload_order=0`) 和 L1 (`preload_order=1`)。排序后为 `[L3, L1]`。\n- 搜索顺序：`[L3, L1, E, L2]`。\n- 检查 L3 (`id=3`)：`defines=1`, `visibility=0`, `version=10`。满足 `P(o)`。\n- **结果**：`R=3`。L3 是 `LD_PRELOAD` 库，所以 `I=1`。\n\n#### 用例 6: `[-1, 0]`\n- `secure = 0`，`V_req = 10`。\n- 搜索顺序：`[L1, E, L2]`。\n- 检查 L1 (`id=1`)：`version=20`。不满足 `P(o)`。\n- 检查 E (`id=0`)：`defines=0`。不满足 `P(o)`。\n- 检查 L2 (`id=2`)：`version=30`。不满足 `P(o)`。\n- 遍历完成，没有找到符合条件的对象。\n- **结果**：`R=-1`。`I=0`。\n\n将所有结果汇总，即可得到最终的输出。", "answer": "```c\n#include", "id": "3636919"}, {"introduction": "共享库的动态性也带来了独特的资源生命周期管理挑战。本实践将着重探讨“卸载后使用”（use-after-unload）这一严重风险，即当程序尝试调用一个已被卸载（unmapped）的库中的函数时发生的错误。您将通过模拟一个简化的“天真”卸载策略和一个安全的、基于引用计数的卸载策略，来直观地理解该问题，并掌握安全管理动态库生命周期的标准设计模式。[@problem_id:3636903]", "problem": "要求您设计一个精确、可执行的动态链接行为模型，以演示在回调到某个共享库的可能性仍然存在时卸载该库的风险。您的程序必须实现两种策略，并在一个固定的事件序列测试套件上，检查每种策略下的“卸载后使用”（use-after-unload）风险。这两种策略模拟了：(i) 一种简单的卸载方式，即在收到关闭请求时立即取消映射库；以及 (ii) 一种安全的卸载方式，它会延迟取消映射，直到所有引用都消失，并包含一个显式的关闭钩子（shutdown hook）来取消回调。\n\n基本原理。使用以下经过充分检验的事实和核心定义作为您模型的基础。当一个共享对象被动态链接时，该对象的代码和数据会被映射到进程的地址空间中；一个引用共享对象中代码的函数指针，仅在该代码保持映射状态时才有效。如果一个指向库函数的回调指针在该库被卸载后被调用，这次调用将尝试执行未映射的代码，这是一种“卸载后使用”风险。一种广泛使用的安全模式采用引用计数来推迟卸载，直到所有使用都被释放，有时还会结合一个显式的关闭钩子来取消或注销悬而未决的回调。您的模型应该抽象地、忠实地捕捉这些行为。\n\n形式化模型。您将模拟一个单一进程与一个单一动态加载库的交互。时间以离散的步长推进，索引为 $t \\in \\{1,2,\\dots,T\\}$。在每一步，恰好发生一个事件，该事件从以下字母表中抽取：\n- 注册回调：令牌 R\n- 注销回调：令牌 U\n- 触发回调：令牌 F（如果存在已注册的回调，则尝试调用）\n- 关闭请求（请求卸载库）：令牌 C\n- 获取一个非回调引用（例如，一个正在执行的任务）：令牌 A\n- 释放一个非回调引用：令牌 D\n- 执行关闭钩子（显式注销所有回调）：令牌 S\n\n简单策略的状态变量：\n- $L(t) \\in \\{0,1\\}$ 表示库当前是否被映射（$1$ 表示已映射）。\n- $N(t) \\in \\mathbb{N}_0$ 统计悬而未决的已注册回调数量。\n- 风险指示器 $H_{\\mathrm{naive}} \\in \\{0,1\\}$，如果在 $L(t)=0$ 且 $N(t)0$ 时发生任何 F 事件，则其值变为 $1$。\n\n安全策略的状态变量（带有关闭钩子的引用计数）：\n- $L(t) \\in \\{0,1\\}$ 表示库当前是否被映射。\n- $W(t) \\in \\{0,1\\}$ 表示一个待处理的关闭请求。\n- $N(t) \\in \\mathbb{N}_0$ 统计悬而未决的已注册回调数量。\n- $Q(t) \\in \\mathbb{N}_0$ 统计非回调引用（获取）的数量。\n- 引用计数为 $R(t) = N(t) + Q(t)$。\n- 风险指示器 $H_{\\mathrm{safe}} \\in \\{0,1\\}$，如果在 $L(t)=0$ 且 $N(t)0$ 时发生任何 F 事件，则其值变为 $1$。\n- 卸载条件：当且仅当 $W(t)=1$ 且 $R(t)=0$ 时，才会发生卸载。\n\n事件语义。初始化 $L(0)=1$, $W(0)=0$, $N(0)=0$, $Q(0)=0$，并且两个风险指示器均为 $0$。\n- R：$N \\leftarrow N+1$。在安全策略中，$R$ 也因此增加 $1$。\n- U：如果 $N0$，则 $N \\leftarrow N-1$。\n- F：如果 $L=0$ 且 $N0$，则将相应的风险指示器设为 $1$；否则状态无变化。\n- C（简单策略）：立即 $L \\leftarrow 0$。C（安全策略）：$W \\leftarrow 1$；如果 $R=0$ 则 $L \\leftarrow 0$，否则 $L$ 保持为 $1$ 直到 $R$ 变为 $0$。\n- A：$Q \\leftarrow Q+1$。\n- D：如果 $Q0$，则 $Q \\leftarrow Q-1$。\n- S（仅安全策略）：原子性地注销所有回调，即 $N \\leftarrow 0$；在简单策略中，此事件无效果。\n- 在安全策略中，任何事件变化后，如果 $W=1$ 且 $R=0$，则设置 $L \\leftarrow 0$。\n\n任务。实现一个程序，该程序：\n- 精确地编码上述语义。\n- 在下面的每个事件序列上模拟两种策略。\n- 对于每个序列，输出两个结果：首先是 $H_{\\mathrm{naive}}$，然后是 $H_{\\mathrm{safe}}$，每个结果为 $0$ 或 $1$。\n\n测试套件。使用以下 $5$ 个序列，每个序列都以连续的事件令牌字符串形式给出：\n- 序列 1：RFUC\n- 序列 2：RCFU\n- 序列 3：CF\n- 序列 4：RACFDU\n- 序列 5：RCSF\n\n覆盖理由。该套件包括一个正常情况（序列 1），一个在简单卸载策略下可复现的风险，即回调在关闭请求后触发（序列 2），一个没有回调的空操作关闭（序列 3），来自额外非回调引用的干扰（序列 4），以及使用显式关闭钩子在关闭请求后安全地分离回调（序列 5）。\n\n输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须按顺序包含 $10$ 个整数，对应于 $[H_{\\mathrm{naive}}^{(1)},H_{\\mathrm{safe}}^{(1)},H_{\\mathrm{naive}}^{(2)},H_{\\mathrm{safe}}^{(2)},\\dots,H_{\\mathrm{naive}}^{(5)},H_{\\mathrm{safe}}^{(5)}]$，且不含空格。例如：\"[0,0,1,0,0,0,1,0,1,0]\"。程序不应读取任何输入，也不应打印任何其他输出。", "solution": "此问题要求对两种共享库卸载策略（“简单策略”和“安全策略”）进行模拟，以检测“卸载后使用”（use-after-unload）的风险。我们将为每个给定的事件序列追踪两种策略下的状态变量，以确定最终的风险指示器值。\n\n两种策略的初始状态（$t=0$）均为：库已映射（$L=1$），无回调（$N=0$），无非回调引用（$Q=0$），无关闭请求（$W=0$），无风险（$H=0$）。\n\n风险条件是相同的：当“触发回调”（F）事件发生时，如果库未被映射（$L=0$）但仍有已注册的回调（$N>0$），则对应的风险标志 $H$ 被置为 1。\n\n下面是每个事件序列的详细追踪过程。\n\n### 序列 1: `RFUC`\n此序列代表正常的、无风险的操作。\n- **简单策略**:\n  1. `R`: $N=1$。\n  2. `F`: $L=1$，调用安全。$H_{\\mathrm{naive}}=0$。\n  3. `U`: $N=0$。\n  4. `C`: 库被卸载，$L=0$。此时 $N=0$。\n  **结果: $H_{\\mathrm{naive}}=0$**。\n- **安全策略**:\n  1. `R`: $N=1$，引用计数 $R=1$。\n  2. `F`: $L=1$，调用安全。$H_{\\mathrm{safe}}=0$。\n  3. `U`: $N=0$，引用计数 $R=0$。\n  4. `C`: 收到关闭请求，$W=1$。由于 $R=0$，卸载条件满足，库立即被卸载，$L=0$。\n  **结果: $H_{\\mathrm{safe}}=0$**。\n- **配对结果**: `[0,0]`\n\n### 序列 2: `RCFU`\n此序列旨在暴露简单策略的风险。\n- **简单策略**:\n  1. `R`: $N=1$。\n  2. `C`: 库立即被卸载，$L=0$。此时仍有回调注册，$N=1$。\n  3. `F`: 触发回调。此时 $L=0$ 且 $N>0$，满足风险条件。$H_{\\mathrm{naive}}$ 被置为 1。\n  4. `U`: $N=0$。风险标志保持为 1。\n  **结果: $H_{\\mathrm{naive}}=1$**。\n- **安全策略**:\n  1. `R`: $N=1$，引用计数 $R=1$。\n  2. `C`: 收到关闭请求，$W=1$。由于 $R=1>0$，库**不会**被卸载，$L$ 保持为 1。\n  3. `F`: 触发回调。此时 $L=1$，调用安全。\n  4. `U`: $N=0$，引用计数 $R=0$。事件处理后，检查到卸载条件（$W=1$ 且 $R=0$）满足，库现在被卸载，$L=0$。\n  **结果: $H_{\\mathrm{safe}}=0$**。\n- **配对结果**: `[1,0]`\n\n### 序列 3: `CF`\n此序列测试没有注册任何回调时的关闭操作。\n- **简单策略**:\n  1. `C`: 库被卸载，$L=0$。$N=0$。\n  2. `F`: 触发回调。虽然 $L=0$，但 $N=0$，因此不满足风险条件。\n  **结果: $H_{\\mathrm{naive}}=0$**。\n- **安全策略**:\n  1. `C`: 收到关闭请求，$W=1$。由于初始引用计数 $R=0$，库立即被卸载，$L=0$。\n  2. `F`: 触发回调。此时 $L=0$ 且 $N=0$，无风险。\n  **结果: $H_{\\mathrm{safe}}=0$**。\n- **配对结果**: `[0,0]`\n\n### 序列 4: `RACFDU`\n此序列展示了非回调引用如何同样能防止在安全策略下过早卸载。\n- **简单策略**: `A` 和 `D` 事件无效果，此序列等同于 `RCFU`。\n  1. `R`: $N=1$。\n  2. `C`: $L=0$。\n  3. `F`: $L=0$ 且 $N>0$。风险触发，$H_{\\mathrm{naive}}=1$。\n  **结果: $H_{\\mathrm{naive}}=1$**。\n- **安全策略**:\n  1. `R`: $N=1$，引用计数 $R=1$。\n  2. `A`: $Q=1$，引用计数 $R = N+Q = 1+1=2$。\n  3. `C`: 收到关闭请求，$W=1$。由于 $R=2>0$，库保持加载状态，$L=1$。\n  4. `F`: 触发回调。此时 $L=1$，调用安全。\n  5. `D`: $Q=0$，引用计数 $R = 1+0=1$。卸载条件仍不满足。\n  6. `U`: $N=0$，引用计数 $R = 0+0=0$。现在卸载条件满足，库被卸载，$L=0$。\n  **结果: $H_{\\mathrm{safe}}=0$**。\n- **配对结果**: `[1,0]`\n\n### 序列 5: `RCSF`\n此序列演示了显式关闭钩子（S 事件）的作用。\n- **简单策略**: `S` 事件无效果，此序列等同于 `RCF`。\n  1. `R`: $N=1$。\n  2. `C`: $L=0$。\n  3. `F`: $L=0$ 且 $N>0$。风险触发，$H_{\\mathrm{naive}}=1$。\n  **结果: $H_{\\mathrm{naive}}=1$**。\n- **安全策略**:\n  1. `R`: $N=1$，引用计数 $R=1$。\n  2. `C`: 收到关闭请求，$W=1$。由于 $R>0$，库保持加载状态，$L=1$。\n  3. `S`: 关闭钩子执行，所有回调被注销，$N=0$。引用计数 $R=0$。现在卸载条件满足，库被卸载，$L=0$。\n  4. `F`: 触发回调。虽然 $L=0$，但由于钩子已将回调清除（$N=0$），因此没有风险。\n  **结果: $H_{\\mathrm{safe}}=0$**。\n- **配对结果**: `[1,0]`\n\n### 最终结果汇总\n将所有测试序列的配对结果按顺序组合，得到最终的输出列表：`[0,0,1,0,0,0,1,0,1,0]`。", "answer": "```c\n#include", "id": "3636903"}]}