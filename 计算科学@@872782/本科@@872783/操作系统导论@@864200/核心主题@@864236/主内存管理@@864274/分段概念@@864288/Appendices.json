{"hands_on_practices": [{"introduction": "本练习将带你亲手实践分段机制中最核心的环节：地址转换。你将扮演内存管理单元(MMU)的角色，根据给定的段基址、段限长和偏移量，验证内存访问的合法性并计算最终的物理地址。这个过程将加深你对边界检查 $0 \\le o  l_i$ 重要性的理解，特别是它如何精确地防止经典的“差一错误”(off-by-one error) [@problem_id:3680307]。", "problem": "一个单处理器系统使用分段来进行内存管理。根据该模型的定义，每个逻辑地址是一个数对 $\\left(i, o\\right)$，其中 $i$ 是段索引，$o$ 是段 $i$ 内的非负字节偏移量。每个段 $i$ 都有一个基地址（起始物理地址）$b_i$ 和一个界限 $l_i$。系统对每次内存引用执行边界检查，验证 $0 \\le o  l_i$。如果边界检查通过，内存管理单元（MMU）将段基址和偏移量进行整数求和，从而形成物理地址。如果边界检查失败，MMU会引发分段错误。假设所有地址和界限都是精确的字节数，没有取整或对齐的副作用。\n\n考虑段 $i$，其基地址为 $b_i = 0x200000$，界限为 $l_i = 0x3000$。有两条指令使用偏移量 $o_1 = 0x2FFF$ 和 $o_2 = 0x3000$ 来引用此段。\n\n仅使用上述定义，确定哪个偏移量通过了边界检查，哪个导致了错误。解释为什么其中一个是差一错误（off-by-one）的情况。然后，通过执行所需的加法，计算有效偏移量的物理地址 $p$。将最终的物理地址以十六进制表示，并带有 $0x$ 前缀。无需取整。", "solution": "我们将根据所提供的定义对问题进行验证，如果有效，则进行求解。\n\n首先，从问题陈述中提取已知条件：\n- 逻辑地址是一个数对 $(i, o)$，其中 $i$ 是段索引，$o$ 是非负字节偏移量。\n- 每个段 $i$ 都有一个基地址 $b_i$ 和一个界限 $l_i$。\n- 边界检查由不等式 $0 \\le o  l_i$ 定义。\n- 如果边界检查通过，物理地址 $p$ 计算为 $p = b_i + o$。\n- 如果边界检查失败，则发生分段错误。\n- 对于特定的段 $i$，基地址为 $b_i = 0x200000$。\n- 对于同一个段，界限为 $l_i = 0x3000$。\n- 需要检查两个偏移量：$o_1 = 0x2FFF$ 和 $o_2 = 0x3000$。\n\n该问题具有科学依据，因为它描述了操作系统和计算机体系结构中使用的标准内存分段模型。问题提法得当（well-posed），提供了所有必要的数据（$b_i$, $l_i$, $o_1$, $o_2$）和一个清晰、明确的验证规则（$0 \\le o  l_i$）。没有矛盾或缺失的定义。因此，该问题被认为是有效的，并将提供解答。\n\n问题的核心在于边界检查条件的严格不等式 $o  l_i$。界限 $l_i$ 代表段的大小。对于一个大小为 $l_i$ 的段，有效的字节偏移量范围是从 $0$ 到 $l_i - 1$（包含两者）。这总共有 $l_i$ 个不同的地址。\n\n现在我们将根据边界检查条件 $0 \\le o  l_i$（其中 $l_i = 0x3000$）来测试每个偏移量。\n\n情况 1：偏移量 $o_1 = 0x2FFF$。\n边界检查变为 $0 \\le 0x2FFF  0x3000$。\n在十六进制运算中，$0x2FFF$ 正好比 $0x3000$ 小一。因此，不等式 $0x2FFF  0x3000$ 成立。由于偏移量也是非负的，条件 $0 \\le 0x2FFF  0x3000$ 完全满足。\n结论：偏移量 $o_1$ 通过边界检查。\n\n情况 2：偏移量 $o_2 = 0x3000$。\n边界检查变为 $0 \\le 0x3000  0x3000$。\n不等式 $0x3000  0x3000$ 不成立，因为一个数不能严格小于它自身。\n结论：偏移量 $o_2$ 未通过边界检查，将导致分段错误。\n\n偏移量 $o_2 = 0x3000$ 展示了差一错误（off-by-one）的情况。该段的有效偏移量范围是从 $0$ 到 $l_i - 1$。当 $l_i = 0x3000$ 时，最高有效偏移量是 $0x3000 - 1 = 0x2FFF$。尝试访问偏移量 $o_2 = 0x3000$ 是试图访问该段最后一个有效字节紧邻的后一个字节。这是一个经典的差一错误，内存管理单元的严格边界检查正是为了捕获此类错误而设计的。\n\n最后，我们为有效的偏移量 $o_1 = 0x2FFF$ 计算物理地址 $p$。物理地址是基地址和偏移量的和：\n$p = b_i + o_1$\n代入给定值：\n$p = 0x200000 + 0x2FFF$\n执行十六进制加法：\n$$\n\\begin{array}{@{}c@{\\,}c}\n   0x200000 \\\\\n+  0x002FFF \\\\\n\\hline\n   0x202FFF\n\\end{array}\n$$\n因此，有效内存引用的物理地址是 $p = 0x202FFF$。", "answer": "$$\n\\boxed{0x202FFF}\n$$", "id": "3680307"}, {"introduction": "在真实的操作系统中，一个进程通常包含多个段（如代码段、数据段和堆栈段）。本练习模拟了一个更复杂的场景：加载器错误地设置了段限长，导致程序在执行过程中出现本不应发生的内存访问故障。你的任务是诊断问题所在，并通过修正段限长来修复这些故障，同时确保内存保护不被破坏，从而体会段限长在内存保护中的关键作用 [@problem_id:3680294]。", "problem": "一个单进程程序被加载到一个基于分段的内存系统中。每个逻辑地址是一个数对 $(s, o)$，其中 $s$ 是段标识符，$o$ 是以字节为单位的非负偏移量。内存管理单元 (MMU) 使用一个段描述符 $\\langle B, L, \\text{perm} \\rangle$，其中包括基地址 $B$、包含性界限 $L$ 和权限 $\\text{perm}$。地址转换和保护遵循以下核心定义：\n- 边界检查：当且仅当 $0 \\le o \\le L$ 时，对 $(s,o)$ 的访问在边界内。\n- 权限检查：访问类型必须被该段的权限 $\\text{perm}$ 所允许；否则访问会产生故障。\n- 物理地址计算：如果访问在边界内且被允许，则物理地址为 $B + o$；否则，将引发故障。\n\n加载器错误地设置了三个段的界限字段。基地址和权限是正确的。这些段是：\n- 段 $0$ (代码)：基地址 $B_0 = 12000$，实际加载大小 $S_0 = 4096$ 字节，权限为只执行，加载器设置的界限 $L_0^{\\text{wrong}} = 2047$。\n- 段 $1$ (数据)：基地址 $B_1 = 50000$，实际加载大小 $S_1 = 3000$ 字节，权限为读和写，加载器设置的界限 $L_1^{\\text{wrong}} = 3500$。\n- 段 $2$ (堆栈)：基地址 $B_2 = 80000$，实际加载大小 $S_2 = 2048$ 字节，权限为读和写，加载器设置的界限 $L_2^{\\text{wrong}} = 1023$。\n\n程序发出了以下按时间排序的逻辑内存引用序列，每个引用为三元组 $(s, o, t)$，其中 $t \\in \\{\\text{R}, \\text{W}, \\text{X}\\}$ 表示读、写或执行：\n- $(0, 512, \\text{X})$\n- $(0, 3072, \\text{X})$\n- $(1, 2500, \\text{W})$\n- $(1, 2999, \\text{R})$\n- $(1, 3100, \\text{W})$\n- $(2, 1536, \\text{W})$\n- $(2, 2047, \\text{R})$\n- $(2, 2050, \\text{R})$\n- $(0, 3500, \\text{R})$\n\n假设实际加载大小 $S_s$ 定义了每个段 $s$ 的真实有效偏移范围 $o \\in \\{0, 1, \\dots, S_s - 1\\}$，这与加载器设置的界限无关。您只能更改界限字段 $L_0, L_1, L_2$；基地址和权限必须保持原样。选择修正后的界限 $L_0, L_1, L_2$，使得：\n- 序列中所有在段的实际加载范围之内（即 $0 \\le o \\le S_s - 1$）且被段权限允许的访问都能成功通过 MMU 检查（不产生故障）。\n- 序列中所有超出段的实际加载范围（即 $o \\ge S_s$）或违反权限的访问仍然产生故障。\n- 在满足这些约束的条件下，每个 $L_s$ 都应尽可能小。\n\n令 $S = L_0 + L_1 + L_2$ 为您修正后的包含性界限之和。计算 $S$。您的最终答案必须是一个数字。不需要四舍五入。", "solution": "我们从分段的核心定义开始。要使一个引用 $(s,o,t)$ 成功，必须满足两个条件：在包含性界限语义下，满足边界条件 $0 \\le o \\le L_s$；以及访问类型 $t$ 被该段权限所允许的权限条件。实际加载大小 $S_s$ 定义了必须保持受保护的真实有效偏移量 $0 \\le o \\le S_s - 1$；根据定义，偏移量 $o \\ge S_s$ 的访问是越界的，即使在修正后也必须产生故障。我们只能调整界限 $L_s$；基地址和权限是固定的。\n\n为了“在维持保护的同时阻止故障”，我们必须为每个段选择尽可能小的 $L_s$，使得所有在实际加载范围内且被段权限允许的访问序列都能通过，同时继续让那些越界或违反权限的访问产生故障。因此，对于每个段 $s$，最小的修正界限为\n$$\nL_s = \\max\\{\\, o \\mid (s,o,t)\\ \\text{出现在访问序列中,}\\ 0 \\le o \\le S_s - 1,\\ \\text{且}\\ t\\ \\text{对段}\\ s\\ \\text{是允许的} \\,\\}。\n$$\n这个 $L_s$ 是最小的，因为任何更小的值都会排除至少一个被允许的、在范围内的访问；它也维持了保护，因为 $L_s \\le S_s - 1$ 且权限未改变。\n\n现在我们根据给定的大小和权限，按段对访问序列进行分类。\n\n段 $0$ (代码)：$S_0 = 4096$ 意味着有效偏移量为 $0 \\le o \\le 4095$。权限：只执行；因此只允许 $\\text{X}$ 访问。\n- $(0, 512, \\text{X})$: $512 \\le 4095$，执行被允许 ⇒ 合法且必须成功。\n- $(0, 3072, \\text{X})$: $3072 \\le 4095$，执行被允许 ⇒ 合法且必须成功。\n- $(0, 3500, \\text{R})$: $3500 \\le 4095$，但读不被允许 ⇒ 无论 $L_0$ 为何都必须产生故障；它不对 $L_0$ 构成约束。\n因此，在被允许的、范围内的访问中，最大偏移量是 $\\max\\{512, 3072\\} = 3072$，所以\n$$\nL_0 = 3072.\n$$\n\n段 $1$ (数据)：$S_1 = 3000$ 意味着有效偏移量为 $0 \\le o \\le 2999$。权限：允许读和写。\n- $(1, 2500, \\text{W})$: $2500 \\le 2999$，写被允许 ⇒ 合法且必须成功。\n- $(1, 2999, \\text{R})$: $2999 \\le 2999$，读被允许 ⇒ 合法且必须成功。\n- $(1, 3100, \\text{W})$: $3100 \\ge 3000$，越界 ⇒ 修正后必须产生故障；它不能向上约束 $L_1$。\n在被允许的、范围内的访问中，最大偏移量是 $\\max\\{2500, 2999\\} = 2999$，所以\n$$\nL_1 = 2999.\n$$\n请注意，$L_1 = 2999 \\le S_1 - 1$ 确保了 $(1, 3100, \\text{W})$ 继续产生故障，从而与不正确的过大界限 $L_1^{\\text{wrong}} = 3500$ 相比，维持了保护。\n\n段 $2$ (堆栈)：$S_2 = 2048$ 意味着有效偏移量为 $0 \\le o \\le 2047$。权限：允许读和写。\n- $(2, 1536, \\text{W})$: $1536 \\le 2047$，写被允许 ⇒ 合法且必须成功。\n- $(2, 2047, \\text{R})$: $2047 \\le 2047$，读被允许 ⇒ 合法且必须成功。\n- $(2, 2050, \\text{R})$: $2050 \\ge 2048$，越界 ⇒ 修正后必须产生故障；它不能向上约束 $L_2$。\n在被允许的、范围内的访问中，最大偏移量是 $\\max\\{1536, 2047\\} = 2047$，所以\n$$\nL_2 = 2047.\n$$\n\n确定了最小修正包含性界限为 $(L_0, L_1, L_2) = (3072, 2999, 2047)$ 后，我们计算所要求的和\n$$\nS = L_0 + L_1 + L_2 = 3072 + 2999 + 2047 = 8118.\n$$\n这个 $S$ 对应的界限消除了对合法的、在范围内且被允许的访问产生的虚假故障，同时保留了对越界或不允许的访问产生的故障，从而维持了保护。", "answer": "$$\\boxed{8118}$$", "id": "3680294"}, {"introduction": "理论概念与实际系统实现之间往往存在鸿沟，安全漏洞常常在此产生。本练习将探讨操作系统内核在实现边界检查时必须面对的一个关键问题：整数溢出。通过分析一个边界案例，你将学会辨别不同检查策略的优劣，并理解为何一个看似简单的 $o + n \\le l$ 检查在有限字长的无符号整数运算下可能导致严重的安全漏洞 [@problem_id:3680289]。", "problem": "一个采用分段机制的操作系统（OS）将每个逻辑地址表示为一个序对 $\\langle s, o \\rangle$，其中 $s$ 是段标识符，$o$ 是偏移量。仅当偏移量满足 $0 \\le o  l(s)$ 时，中央处理器（CPU）才会将 $\\langle s, o \\rangle$ 映射到物理地址 $p = b(s) + o$，其中 $b(s)$ 是基地址，$l(s)$ 是段限长。考虑一个字长为 $w$ 位的机器。在此类机器上，$w$ 位无符号整数的加法和减法是按模 $2^w$ 执行的，并且无符号比较将位模式解释为 $[0, 2^w - 1]$ 范围内的整数。\n\n一个用户进程请求内核从一个段的偏移量 $o$ 开始复制 $n$ 字节，内核必须判断所请求的 $n$ 字节范围是否完全在该段的边界之内。假设一个 $w = 32$ 位的架构。考虑以下边界情况：\n- 段限长 $l = 2^{32} - 4$。\n- 请求的起始偏移量 $o = 2^{32} - 8$。\n- 请求的长度 $n = 16$ 字节。\n\n假设 $b(s)$ 是任意但固定的，并且内核必须仅使用硬件提供的对 $w$ 位整数类型的算术和比较来实现其决策。哪种方法通过确保检查 $o  l$ 使用无符号算术并避免因模加法而产生的漏洞，从而在一般情况下（包括此边界情况）都能做出正确决策以防止回绕访问？\n\nA. 将边界检查作为两个无符号比较来执行：首先验证 $o  l$，然后验证 $n \\le l - o$。如果任一比较失败，则拒绝请求。\n\nB. 对 $w$ 位整数执行单一的无符号检查 $o + n \\le l$。如果为真则接受，否则拒绝。\n\nC. 将 $o$、$l$ 和 $n$ 视为有符号32位整数，并使用有符号比较检查 $o  l$ 和 $o + n \\le l$。如果任一比较失败，则拒绝请求。\n\nD. 使用32位模加法计算物理地址 $p = b(s) + o$ 和 $q = p + n - 1$，然后通过无符号比较检查 $q \\le b(s) + l - 1$。如果为真则接受，否则拒绝。", "solution": "用户问题要求提供一个正确且健壮的内核级算法，以检查内存访问请求是否在内存段的边界内。该请求是在一个由限长 $l$ 定义的段内，从偏移量 $o$ 开始访问 $n$ 字节。有效偏移量的范围是 $[0, l-1]$。因此，请求的字节范围（从偏移量 $o$ 到 $o + n - 1$）必须完全包含在有效范围内。这可以用标准整数算术中的两个条件来表示：\n1. 起始偏移量必须有效：$o \\ge 0$。由于偏移量是无符号的，这个条件总是成立的。\n2. 结束偏移量必须有效：$o + n - 1  l$。\n\n条件2等价于 $o + n \\le l$。由于我们假设对于任何有意义的复制操作都有 $n>0$，条件 $o + n \\le l$ 也蕴含了 $o  l$。因此，在纯数学中，单一的检查 $o + n \\le l$ 是充分的。\n\n问题的核心在于使用 $w$ 位无符号整数算术来实现这个检查，其中加法是按模 $2^w$ 执行的。$o + n$ 的直接硬件实现会计算 $(o + n) \\pmod{2^w}$。如果 $o+n \\ge 2^w$，就会发生整数溢出，结果会“回绕”到一个较小的值。这可能导致本应失败的检查通过，从而产生安全漏洞。\n\n让我们使用题目提供的 $w = 32$ 的边界情况：\n- 段限长 $l = 2^{32} - 4$。\n- 请求的起始偏移量 $o = 2^{32} - 8$。\n- 请求的长度 $n = 16$ 字节。\n\n请求的访问范围是从偏移量 $o = 2^{32} - 8$ 到 $o+n-1 = (2^{32} - 8) + 16 - 1 = 2^{32} + 7$。\n有效的偏移量范围是 $[0, l-1]$，即 $[0, 2^{32} - 5]$。\n请求的范围明显超出了有效的段限长。因此，该请求必须被拒绝。\n\n现在，我们来评估每种提出的方法。\n\n**A. 将边界检查作为两个无符号比较来执行：首先验证 $o  l$，然后验证 $n \\le l - o$。如果任一比较失败，则拒绝请求。**\n\n这种方法分解了检查。让我们用给定的边界情况值，在32位无符号算术下分析它。\n1.  **第一次检查：$o  l$**\n    这将比较 $2^{32} - 8$ 和 $2^{32} - 4$。作为无符号比较，这是成立的。检查通过。\n2.  **第二次检查：$n \\le l - o$**\n    首先执行减法 $l - o$。由于第一次检查已经确定 $o  l$，无符号减法 $(l - o)$ 在模意义下不会下溢。硬件将计算出正确的数学差值。\n    $l - o = (2^{32} - 4) - (2^{32} - 8) = 4$。\n    然后比较 $n \\le 4$，即 $16 \\le 4$。这是不成立的。\n    由于第二次比较失败，内核拒绝该请求。\n\n这对于该边界情况是正确的结果。\n总的来说，这个方法是正确的。第一次检查 $o  l$ 确保了起始点在段内，并且关键地，确保了减法 $l-o$ 能得出从偏移量 $o$ 开始的段的真实剩余大小。第二次检查 $n \\le l-o$ 随后正确地验证了请求的长度 $n$ 是否能容纳在这个剩余空间内。这等价于检查 $o+n \\le l$，但又不容易受到 $o+n$ 溢出的影响。\n\n对A的结论：**正确**。\n\n**B. 对 $w$ 位整数执行单一的无符号检查 $o + n \\le l$。如果为真则接受，否则拒绝。**\n\n这种方法直接实现了数学上的检查，但它容易受到溢出的影响。\n1.  **使用32位无符号算术计算 $o + n$：**\n    $o + n = (2^{32} - 8) + 16 = 2^{32} + 8$。\n    硬件按模 $2^{32}$ 计算这个值：$(2^{32} + 8) \\pmod{2^{32}} = 8$。\n2.  **执行比较：**\n    检查变为 $8 \\le l$，即 $8 \\le 2^{32} - 4$。这是成立的。\n    内核会接受该请求。这是不正确的结果，因为它会导致越界访问（回绕写入到偏移量 $[0, 7]$）。这是一个经典的整数溢出漏洞。\n\n对B的结论：**不正确**。\n\n**C. 将 $o$、$l$ 和 $n$ 视为有符号32位整数，并使用有符号比较检查 $o  l$ 和 $o + n \\le l$。如果任一比较失败，则拒绝请求。**\n\n这种方法将位模式的解释从无符号更改为有符号。一个32位有符号整数（以二进制补码表示）的范围是从 $-2^{31}$ 到 $2^{31}-1$。\n- $l = 2^{32} - 4$ 的位模式是 `0xFFFFFFFC`。作为有符号整数，它表示 $-4$。\n- $o = 2^{32} - 8$ 的位模式是 `0xFFFFFFF8`。作为有符号整数，它表示 $-8$。\n- $n = 16$ 的位模式是 `0x00000010`。作为有符号整数，它表示 $16$。\n\n1.  **第一次检查：使用有符号比较进行 $o  l$。**\n    $-8  -4$ 吗？这是成立的。检查通过。\n2.  **第二次检查：使用有符号比较进行 $o + n \\le l$。**\n    $o+n$ 计算为 $-8 + 16 = 8$。\n    检查变为 $8 \\le -4$ 吗？这是不成立的。\n    内核拒绝该请求。对于这个特定的边界情况，结果是正确的。\n\n然而，这种方法通常不正确。偏移量和长度根本上是无符号量。将它们视为有符号数，在最高有效位为1的有效情况下会失败。例如，考虑一个段限长 $l = 2^{31}$。一个 $o=0$ 和 $n=1$ 的请求显然是有效的。\n- $l = 2^{31}$ 的位模式是 `0x80000000`。作为有符号整数，它被解释为 $-2^{31}$。\n- $o=0$ 和 $n=1$ 被解释为 $0$ 和 $1$。\n第一次检查 $o  l$ 变为 $0  -2^{31}$，这是不成立的。该请求将被错误地拒绝。\n\n对C的结论：**不正确**。\n\n**D. 使用32位模加法计算物理地址 $p = b(s) + o$ 和 $q = p + n - 1$，然后通过无符号比较检查 $q \\le b(s) + l - 1$。如果为真则接受，否则拒绝。**\n\n这种方法将检查移到物理地址空间中。其逻辑依赖于这样一个想法：在不等式两边加上基地址 $b(s)$ 然后执行模运算会得到正确的结果。这是错误的。不等式 $x \\le y$ 不一定能保持为 $(b+x)\\pmod{2^w} \\le (b+y)\\pmod{2^w}$。结果取决于 $b$ 的值。\n\n让我们用题目中给出的无效请求作为反例来证明这一点：$l = 2^{32} - 4$，$o = 2^{32} - 8$，$n = 16$。\n- 假设段基地址为 $b(s) = 4$。\n- $p = b(s) + o = 4 + (2^{32} - 8) = 2^{32} - 4$。硬件计算 $p = (2^{32} - 4) \\pmod{2^{32}} = 2^{32}-4$。\n- $q = p + n - 1 = (2^{32} - 4) + 16 - 1 = 2^{32} + 11$。硬件计算 $q = (2^{32} + 11) \\pmod{2^{32}} = 11$。\n- 物理地址上限是 $b(s) + l - 1 = 4 + (2^{32} - 4) - 1 = 2^{32} - 1$。硬件将其计算为 $(2^{32} - 1) \\pmod{2^{32}} = 2^{32}-1$。\n- 检查是 $q \\le b(s) + l - 1$。这变成 $11 \\le 2^{32}-1$。这是成立的。\n内核会接受该请求，这是不正确的结果。该方法失败，因为其正确性取决于 $b(s)$ 的任意值。\n\n对D的结论：**不正确**。\n\n总而言之，只有方法A在指定的硬件算术约束下，提供了一个普遍正确且健壮的、能避免整数溢出漏洞的解决方案。", "answer": "$$\\boxed{A}$$", "id": "3680289"}]}