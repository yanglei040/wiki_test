{"hands_on_practices": [{"introduction": "理解分段硬件的第一步是掌握如何精确界定一个内存段的边界。这个练习将带你深入段描述符的核心，特别是粒度（Granularity）位的作用。通过一个具体的计算任务，你将学会CPU如何解读20位的界限字段来确定一个段可寻址的总字节数，这是所有后续保护检查的基础。[@problem_id:3680504]", "problem": "考虑一个实现了英特尔（Intel）$32$位架构风格的硬件分段机制的中央处理器（CPU）。每个段由一个描述符定义，该描述符包含一个$20$位的界限字段和一个粒度位$G$。界限字段值$L$限制了段内的最大有效字节偏移量。粒度位$G$决定了如何解释该界限：当$G=0$时，界限以字节为单位；当$G=1$时，界限以大小为$4\\,\\mathrm{KiB}$的页为单位，其中一Kibibyte（KiB）定义为$2^{10}$字节。假设一个描述符，其粒度位设置为$G=1$，且$20$位的界限字段具有十六进制值$L=0x000F$。请从这些体系结构定义出发，并且不使用任何快捷公式，确定该段内可寻址的确切字节数。将最终答案表示为以字节为单位的十进制整数。无需进行四舍五入。", "solution": "这个问题提法明确，其科学基础是计算机体系结构的原理，特别是英特尔 x86 内存分段模型。所有必需的信息都已提供。\n\n目标是确定由给定段描述符定义的内存段内的可寻址字节总数。其基本的体系结构原理是：段内的有效字节偏移量范围是从 $0$ 到一个有效界限（表示为 $L_{eff}$）。因此，可寻址字节的总数是 $L_{eff} + 1$。问题要求我们首先根据提供的描述符字段计算出 $L_{eff}$。\n\n段描述符包含一个 $20$ 位的界限字段 $L$ 和一个粒度位 $G$。我们已知：\n1. 界限字段的值：十六进制为 $L = 0x0000\\mathrm{F}$。\n2. 粒度位的值：$G = 1$。\n\n粒度位 $G$ 决定了 CPU 如何解释 $20$ 位的界限值 $L$。\n- 如果 $G=0$，则 $L$ 中的值就是以字节为单位的有效界限，即 $L_{eff} = L$。\n- 如果 $G=1$，则 $L$ 中的值被解释为以页为单位的界限，其中每页大小为 $4\\,\\mathrm{KiB}$。\n\n在本题中，$G=1$。页面大小为 $4\\,\\mathrm{KiB}$，相当于 $4 \\times 2^{10} = 4096$ 字节。$4096$ 字节的大小可以用 $12$ 位表示，因为 $2^{12} = 4096$。\n\n当 $G=1$ 时，计算有效界限 $L_{eff}$ 的体系结构定义规定，$L$ 字段中的 $20$ 位值被视为一个 $32$ 位界限值的 $20$ 个最高有效位，而该界限的 $12$ 个最低有效位则全部设置为 $1$。这个操作可以用位逻辑来描述：将 $20$ 位的值 $L$ 左移 $12$ 位，然后与一个低 $12$ 位全为 $1$ 的掩码进行按位或（OR）运算。这个掩码是 $2^{12} - 1$，十进制为 $4095$，十六进制为 $0\\mathrm{xFFF}$。\n\n让我们将此应用于给定的值。\n界限字段值为 $L = 0x0000\\mathrm{F}$。作为一个 $20$ 位的二进制数，它是 $0000\\,0000\\,0000\\,0000\\,1111$。其整数值为 $15$。\n\n我们构造这个 $32$ 位的有效界限 $L_{eff}$。其高 $20$ 位取自 $L$，低 $12$ 位设置为 $1$。\n\n来自 $L$ 字段的值：$0x0000\\mathrm{F}$\n低 $12$ 位设置为 $1$：$0\\mathrm{xFFF}$\n\n结合这两部分，我们得到 $L_{eff}$。这可以直观地看作是将 $L$ 的各位后面跟上 $12$ 个 $1$ 位：\n$L_{eff} = (\\text{$L$ 的各位}) \\cdot 2^{12} + (2^{12}-1)$\n在十六进制中，这相当于将 $L$ 左移 $3$ 个十六进制位（因为 $12 \\text{ 位} = 3 \\times 4 \\text{ 位}$），然后用 `F` 填充低位。\n$L_{eff} = 0x0000\\mathrm{FFFF}$\n\n现在，我们将这个十六进制有效界限转换为十进制整数。\n$$L_{eff} = 0\\mathrm{x}\\mathrm{FFFF} = 15 \\times 16^3 + 15 \\times 16^2 + 15 \\times 16^1 + 15 \\times 16^0$$\n一个更直接的计算方法是认识到 $0\\mathrm{x}\\mathrm{FFFF}$ 比 $0\\mathrm{x}10000$ 小一。\n$$L_{eff} = 16^4 - 1 = 65536 - 1 = 65535$$\n所以，该段中的最大有效字节偏移量是 $65535$。\n\n可寻址字节偏移量的范围是 $[0, 1, 2, \\dots, L_{eff}]$。\n可寻址字节的总数是此范围内的元素个数，即 $L_{eff} - 0 + 1 = L_{eff} + 1$。\n$$ \\text{字节数} = L_{eff} + 1 = 65535 + 1 = 65536 $$\n该段确切包含 $65536$ 个可寻址字节。此结果是按要求提供的十进制整数。\n\n这可以通过考虑其大小来验证。当 $G=1$ 时，段大小由公式 $(L_{value}+1) \\times \\text{PageSize}$ 给出。\n当 $L = 0\\mathrm{x}0000\\mathrm{F}$ 时，其整数值为 $15$。\n页面大小为 $4096$ 字节。\n$$ \\text{大小} = (15 + 1) \\times 4096 = 16 \\times 4096 = 2^4 \\times 2^{12} = 2^{16} = 65536 $$\n这验证了从第一性原理得到的结果。可寻址的字节数为 $65536$。", "answer": "$$\\boxed{65536}$$", "id": "3680504"}, {"introduction": "分段机制的精髓不仅在于划分内存，更在于实施严格的保护策略。此练习聚焦于系统中最关键的段之一——栈段（Stack Segment）。你将分析当处理器加载栈段寄存器（$SS$）时执行的一系列严苛检查，理解为什么这些规则对于防止权限提升和维持系统稳定至关重要。[@problem_id:3680455]", "problem": "一个进程运行在一个实现了分段机制的 $32$ 位类 Intel $x86$ 中央处理器（CPU）上。逻辑地址由 $\\langle \\text{段选择子}, \\text{偏移量} \\rangle$ 构成，对于栈操作，硬件使用栈段（$SS$）和栈指针（扩展栈指针，$ESP$）来计算入栈和出栈的有效地址。段描述符位于全局描述符表（GDT）或局部描述符表（LDT）中，并包含诸如段位（$S$）、类型、向下扩展位（$E$）、可写位（$W$）、存在位（$P$）、描述符特权级（$DPL$）、基地址和界限等字段。特权模型包括当前特权级（$CPL$）和编码在段选择子中的请求特权级（$RPL$）。\n\n一个操作系统尝试通过执行 $MOV~SS,~\\text{selector}$ 来加载一个新的 $SS$，此时进程处于 $CPL=3$。该段选择子的 $RPL=3$，并指向一个 GDT 描述符，其字段为：$S=1$（代码/数据段）、数据段类型、$E=0$（向上扩展）、$W=0$（只读）、$P=1$（存在）、$DPL=3$，其基地址为 $B$，界限为 $L$，使得预期的 $ESP$ 会位于该描述符的可寻址范围内。假设分页权限是允许的，不会造成干扰。\n\n根据上述基本定义，推断加载 $SS$ 时发生的硬件检查、栈操作写入的必要性以及管理 $SS$ 加载的特权规则。然后回答以下多项选择题。选择所有正确的陈述。\n\nA. 当执行 $MOV~SS,~\\text{selector}$ 指令加载一个 $W=0$ 的数据段时，处理器会立即引发 `#GP`（通用保护故障）且不改变 $SS$ 的值，因为 $SS$ 必须引用一个可写的数据段，并且加载 $SS$ 时会强制要求 $DPL=CPL$ 和 $RPL=CPL$。\n\nB. 如果描述符的存在位是 $P=0$，那么执行 $MOV~SS$ 指令时引发的异常将是 `#NP`（段不存在），无论其他描述符检查是否通过。\n\nC. 只要 $DPL=CPL$，就允许将代码段加载到 $SS$ 中，因为栈操作主要是执行读取，不需要写权限。\n\nD. 作为一项安全策略，操作系统在加载 $SS$ 之前应验证目标描述符是一个可写的数据段（$W=1$）、存在于内存中（$P=1$），并且 $DPL=RPL=CPL$；如果任何检查失败，它应避免执行加载操作以防止故障。\n\nE. 对于一个有效的栈，描述符必须是一个向下扩展段（$E=1$）；尝试将向上扩展的数据段（$E=0$）用于 $SS$ 会导致 `#GP`。\n\nF. 成功加载 $SS$ 后，CPU 会抑制可屏蔽中断，直到下一条指令执行完毕；因此，一个安全的操作系统序列是先加载 $SS$，然后立即加载 $ESP$，以确保新的 $ESP$ 位于段的界限内。", "solution": "问题陈述已经过验证，被认为是有效的。它在科学上基于有据可查的 Intel x86 处理器架构，问题提出得当、客观，并为分析提供了一套完整且一致的参数。\n\n该问题要求分析在类 $32$ 位 x86 CPU 上加载栈段（$SS$）寄存器所涉及的硬件检查。主要指令是 $MOV~SS,~\\text{selector}$。此类操作的有效性由处理器保护机制强制执行的一套严格规则确定。让我们基于 Intel x86 架构，将这些规则作为第一原则进行阐述。\n\n当一条指令试图将段选择子加载到 $SS$ 寄存器时，处理器会按特定顺序执行以下检查。在任何一步失败都会产生特定的异常并终止操作。\n\n1.  **选择子有效性：**\n    *   选择子索引必须在描述符表（GDT 或 LDT）的界限内。否则，会发生通用保护故障（$\\#GP$）。\n    *   选择子不能是空选择子。如果是，则会发生 `#GP`。\n\n2.  **描述符和段存在性：**\n    *   处理器从 GDT 或 LDT 中获取描述符。检查描述符的存在位（$P$）。如果 $P=0$，则该段不在内存中。对于加载到 $SS$ 寄存器的操作，这会导致栈故障（$\\#SS$）。对于其他数据段寄存器（$DS, ES, FS, GS$），这会导致段不存在故障（$\\#NP$）。此检查具有高优先级。\n\n3.  **描述符类型和特权检查：**\n    *   描述符必须标识一个**可写的数据段**。\n        *   段位必须是 $S=1$（代码或数据段，而不是系统段）。\n        *   类型字段必须指明它是一个数据段，而不是代码段。\n        *   可写位（$W$）必须是 $W=1$。栈需要写权限以执行 $PUSH$ 操作。\n        *   尝试将代码段或只读数据段（$W=0$）的选择子加载到 $SS$ 中会导致 `#GP`。\n    *   特权级必须一致。对于在给定的当前特权级（$CPL$）加载到 $SS$ 的操作，以下条件必须成立：\n        *   段的描述符特权级（$DPL$）必须等于 $CPL$。因此，$DPL=CPL$。\n        *   编码在选择子中的请求特权级（$RPL$）也必须等于 $CPL$。因此，$RPL=CPL$。\n        *   这些特权检查中的不匹配（$DPL \\neq CPL$ 或 $RPL \\neq CPL$）会导致 `#GP`。\n\n需要注意的是，在加载 $SS$ 寄存器期间，不会检查向下扩展位（$E$）。栈段可以是向上扩展（$E=0$）段，也可以是向下扩展（$E=1$）段。$E$ 位仅影响后续使用 $SS$ 寄存器进行内存访问时（例如，在 $PUSH$ 或 $POP$ 期间）如何执行偏移量界限检查。\n\n在给定的问题场景中：\n*   $CPL=3$。\n*   选择子的 $RPL=3$。\n*   GDT 描述符具有：$S=1$、数据段类型、$E=0$（向上扩展）、$W=0$（只读）、$P=1$（存在）和 $DPL=3$。\n\n将硬件检查应用于此场景：\n1.  假设选择子非空且在 GDT 界限内。\n2.  存在位为 $P=1$，因此在此阶段不会产生 `#SS` 故障。\n3.  特权检查通过：$DPL=3=CPL$ 且 $RPL=3=CPL$。\n4.  数据段的类型检查通过。\n5.  可写位检查失败：描述符指向一个只读段（$W=0$），但 $SS$ 寄存器需要一个可写段（$W=1$）。此失败将导致通用保护故障（$\\#GP$）。\n\n现在我们评估每个选项。\n\n**A. 当执行 $MOV~SS,~\\text{selector}$ 指令加载一个 $W=0$ 的数据段时，处理器会立即引发 `#GP`（通用保护故障）且不改变 $SS$ 的值，因为 $SS$ 必须引用一个可写的数据段，并且加载 $SS$ 时会强制要求 $DPL=CPL$ 和 $RPL=CPL$。**\n该陈述与我们的分析完全一致。在给定场景中，导致故障的具体原因是目标段的只读性质（$W=0$）。硬件规则规定栈段必须是可写的。此违规会触发一个 `#GP`。指令失败，$SS$ 寄存器不会被修改。该陈述还正确列出了加载 $SS$ 时强制执行的特权检查（$DPL=CPL$ 和 $RPL=CPL$），这些检查在本例中恰好通过，但它们是所需验证的一部分。因此，该陈述是对事件及其根本原因的正确而完整的描述。\n结论：正确\n\n**B. 如果描述符的存在位是 $P=0$，那么执行 $MOV~SS$ 指令时引发的异常将是 `#NP`（段不存在），无论其他描述符检查是否通过。**\n该陈述讨论了对场景的一个假设性修改（$P=0$）。根据我们确立的原则，将一个指向不存在段（$P=0$）的选择子加载到 $SS$ 寄存器会产生栈故障（$\\#SS$），而不是段不存在故障（$\\#NP$）。$\\#NP$ 异常是在类似条件下加载到其他数据段寄存器（$DS, ES, FS, GS$）时保留的。该陈述错误地指明了异常的类型。\n结论：错误\n\n**C. 只要 $DPL=CPL$，就允许将代码段加载到 $SS$ 中，因为栈操作主要是执行读取，不需要写权限。**\n该陈述包含两个谬误。首先，硬件明确禁止将代码段的选择子加载到 $SS$；它必须是一个数据段。其次，栈操作“不需要写权限”的前提是根本错误的。栈是一种后进先出（LIFO）的数据结构，而作为栈核心功能的 `PUSH` 操作涉及向内存写入数据。因此，栈段必须是可写的。\n结论：错误\n\n**D. 作为一项安全策略，操作系统在加载 $SS$ 之前应验证目标描述符是一个可写的数据段（$W=1$）、存在于内存中（$P=1$），并且 $DPL=RPL=CPL$；如果任何检查失败，它应避免执行加载操作以防止故障。**\n该陈述描述了操作系统设计的一个最佳实践。所列出的检查——可写的数据段（$W=1$）、存在（$P=1$）以及匹配的特权级（$DPL=RPL=CPL$）——正是硬件所执行的检查。一个健壮的操作系统内核会在尝试硬件操作之前，在软件中执行这些验证，以维持系统稳定性并防止内核自身发生意外故障。这个策略是硬件严格规则的直接且合乎逻辑的推论。该陈述是关于安全和稳定系统编程的正确断言。\n结论：正确\n\n**E. 对于一个有效的栈，描述符必须是一个向下扩展段（$E=1$）；尝试将向上扩展的数据段（$E=0$）用于 $SS$ 会导致 `#GP`。**\n该陈述在事实上是不正确的。x86 架构允许栈段是向上扩展（$E=0$）或向下扩展（$E=1$）。$E$ 位仅改变内存访问时界限检查的逻辑（对于 $E=0$ 是 `offset \\leq limit`，而对于 $E=1$ 是 `offset  limit`）。`MOV SS` 指令不检查 $E$ 位，因此加载一个向上扩展段的选择子不会导致故障。\n结论：错误\n\n**F. 成功加载 $SS$ 后，CPU 会抑制可屏蔽中断，直到下一条指令执行完毕；因此，一个安全的操作系统序列是先加载 $SS$，然后立即加载 $ESP$，以确保新的 $ESP$ 位于段的界限内。**\n该陈述描述了 x86 架构的一个关键特性。任何加载 $SS$ 寄存器的指令（如 $MOV$、$LSS$ 或 $IRET$）都会自动禁止处理可屏蔽中断、调试陷阱和其他异常，直到*下一条*指令完成。这创建了一个原子性的双指令窗口（$MOV~SS, ...$; $MOV~ESP, ...$），允许在 $SS:ESP$ 处于不一致状态时不会发生中断的情况下，将栈段和栈指针一起更新。该陈述正确地指出了这一硬件特性及其预期用途。\n结论：正确", "answer": "$$\\boxed{ADF}$$", "id": "3680455"}, {"introduction": "检验你是否真正掌握了分段机制的最终方法，是亲手实现其核心逻辑。这个编程练习要求你构建一个模拟器，来复现跨段数据移动的过程，就像经典的x86字符串指令一样。你将需要精确地处理源和目标段的界限检查、指针的自动更新以及故障的优先顺序，从而将抽象的硬件规则转化为具体的代码实现。[@problem_id:3680444]", "problem": "你需要以程序形式实现一个纯逻辑模拟器，用于模拟基于分段的字符串跨段移动，其行为应与 Intel x86 字符串指令中使用的 Data Segment:Source Index (DS:SI) 和 Extra Segment:Destination Index (ES:DI) 进行的逐字节移动一致。目标是针对给定的参数集，计算成功移动的总字节数，以及因对源段和目标段进行界限检查而产生的故障行为。该模拟器必须严格按照下文定义的方式计算线性地址并执行界限检查。\n\n将使用的基本定义如下：\n- 一个段由基址 $B$ 和界限 $L$ 建模。基址 $B$ 是一个无符号整数，表示段的起始线性地址。界限 $L$ 是一个无符号整数，表示段内允许的最大偏移量（包含边界值）。对于偏移量为 $O$ 的任何内存访问，该访问有效当且仅当 $0 \\le O \\le L$。\n- 在基址为 $B$ 的段内，偏移量为 $O$ 的访问所对应的线性地址 $A$ 计算公式为 $A = B + O$。\n- 逐字节移动指令使用 $(\\text{DS}:\\text{SI})$ 对作为源，$(\\text{ES}:\\text{DI})$ 对作为目标。在每次迭代中，一个字节从源偏移量 $O_s$ 移动到目标偏移量 $O_d$。访问顺序为先读取源，后写入目标。如果任一访问相对于其段界限是无效的，操作将立即停止，并报告该次迭代的故障；不会再移动更多字节。\n- 方向标志 (Direction Flag, DF) 决定了每次成功移动字节后指针的更新方式。如果 $\\text{DF} = 0$，则 $\\text{SI} \\leftarrow \\text{SI} + 1$ 且 $\\text{DI} \\leftarrow \\text{DI} + 1$。如果 $\\text{DF} = 1$，则 $\\text{SI} \\leftarrow \\text{SI} - 1$ 且 $\\text{DI} \\leftarrow \\text{DI} - 1$。在一次迭代中，用于内存访问的偏移量是该次迭代开始时的当前 $\\text{SI}$ 和 $\\text{DI}$ 的值。\n- 重复计数 $N$ 指定了尝试移动的最大字节数。如果 $N = 0$，则不移动任何字节，也不会发生故障。\n- 故障优先级：因为首先尝试读取源，如果在同一次迭代中源和目标访问都无效，则源故障先发生。故障代码定义为：$0$ 表示无故障，$1$ 表示源界限故障，$2$ 表示目标界限故障。\n\n你的模拟器必须为每个测试用例计算：\n- 实际移动的总字节数，记为 $M$。\n- 故障代码 $F \\in \\{0, 1, 2\\}$，其中 $0$ 表示没有发生故障（整个重复计数 $N$ 已完成），$1$ 表示第一个非法访问是源读取，$2$ 表示第一个非法访问是目标写入。\n\n实现要求：\n- 在适当的情况下，将所有量建模为无符号 $32$ 位整数，但方向标志除外，它是一个在 $\\{0,1\\}$ 中的二进制指示符。\n- 在为访问计算线性地址 $A = B + O$ 之前，通过 $0 \\le O \\le L$ 强制检查偏移量的有效性。\n- 使用以下顺序：源有效性检查、目标有效性检查，然后执行移动和指针更新。在遇到第一个无效情况时立即停止。\n- 模拟器不应执行真实的内存写入；它只应计算计数值和故障代码。它仍应在有效性检查期间内部计算线性地址，以确保计算逻辑遵循 $A = B + O$。\n\n测试套件：\n提供一个模拟器，执行以下六个测试用例，每个用例指定为 $(B_{\\text{DS}}, L_{\\text{DS}}, B_{\\text{ES}}, L_{\\text{ES}}, \\text{SI}_0, \\text{DI}_0, N, \\text{DF})$：\n\n- 案例 1（顺利路径，在界限内正向复制）：$(4096, 63, 8192, 63, 8, 16, 16, 0)$。\n- 案例 2（在目标界限处精确边界成功）：$(12288, 31, 16384, 31, 16, 24, 8, 0)$。\n- 案例 3（复制中途目标越过界限）：$(20480, 40, 24576, 25, 0, 20, 10, 0)$。\n- 案例 4（复制中途源越过界限）：$(28672, 5, 32768, 100, 3, 0, 5, 0)$。\n- 案例 5（递减方向在第一个字节后导致下溢）：$(36864, 50, 40960, 50, 0, 0, 4, 1)$。\n- 案例 6（零长度复制）：$(45056, 100, 49152, 100, 0, 0, 0, 0)$。\n\n对于每个案例，生成一个 $[M, F]$ 对，其中 $M$ 是移动的字节数，$F$ 是如上文定义的故障代码。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。列表中的每个元素本身都是一个对应于一个测试用例的双元素列表 $[M, F]$，并按顺序排列。例如，对于三个案例，输出应类似于 $[[M_1,F_1],[M_2,F_2],[M_3,F_3]]$。对于上述指定的六个案例，你的输出必须为 $[[M_1,F_1],[M_2,F_2],[M_3,F_3],[M_4,F_4],[M_5,F_5],[M_6,F_6]]$ 的形式。", "solution": "问题陈述经过了严格审查，并被确定为**有效**。它为模拟基于分段的内存寻址和数据移动提供了一套自包含、逻辑一致且有科学依据的规则，这与 Intel x86 等历史计算机体系结构中的情况相符。其目标、约束和测试用例的规定具有足够的精度，足以得出一个唯一且可验证的解。\n\n该模拟遵循直接源自问题定义的以下算法。\n\n设给定测试用例的参数为 $(B_{\\text{DS}}, L_{\\text{DS}}, B_{\\text{ES}}, L_{\\text{ES}}, \\text{SI}_{\\text{initial}}, \\text{DI}_{\\text{initial}}, N, \\text{DF})$。\n设 $M$ 为成功移动的字节数，初始化为 $M=0$。\n设 $F$ 为故障代码，初始化为 $F=0$。\n设当前的源和目标索引指针为 $\\text{SI}$ 和 $\\text{DI}$，初始化为 $\\text{SI} \\leftarrow \\text{SI}_{\\text{initial}}$ 和 $\\text{DI} \\leftarrow \\text{DI}_{\\text{initial}}$。\n\n模拟按如下方式进行：\n1.  如果重复计数 $N$ 为 $0$，模拟立即终止。最终结果为 $[M, F] = [0, 0]$。\n2.  如果 $N  0$，则执行一个最多 $N$ 次迭代的循环。对于从 $0$ 到 $N-1$ 的每次迭代 $i$：\n    a.  设当前源偏移量为 $O_s = \\text{SI}$，目标偏移量为 $O_d = \\text{DI}$。\n    b.  **源访问验证**：检查源偏移量是否在其段的边界内。如果 $0 \\le O_s \\le L_{\\text{DS}}$，则访问有效。由于偏移量是无符号整数，这可以简化为检查 $O_s \\le L_{\\text{DS}}$。\n        i.  如果 $O_s  L_{\\text{DS}}$，则发生了源界限故障。设置 $F \\leftarrow 1$ 并立即终止循环。\n    c.  **目标访问验证**：如果源访问有效，则检查目标偏移量是否在其段的边界内。如果 $0 \\le O_d \\le L_{\\text{ES}}$，则访问有效。这可以简化为检查 $O_d \\le L_{\\text{ES}}$。\n        i.  如果 $O_d  L_{\\text{ES}}$，则发生了目标界限故障。设置 $F \\leftarrow 2$ 并立即终止循环。\n    d.  **成功移动**：如果源和目标访问均有效，则字节移动被视为成功。\n        i.  增加已移动字节的计数：$M \\leftarrow M + 1$。\n        ii. 根据方向标志 $\\text{DF}$ 更新下一次迭代的指针：\n            - 如果 $\\text{DF} = 0$：$\\text{SI} \\leftarrow \\text{SI} + 1$ 且 $\\text{DI} \\leftarrow \\text{DI} + 1$。\n            - 如果 $\\text{DF} = 1$：$\\text{SI} \\leftarrow \\text{SI} - 1$ 且 $\\text{DI} \\leftarrow \\text{DI} - 1$。注意，对于无符号整数，从 $0$ 递减会导致回绕到最大整数值。\n3.  循环终止后（无论是完成所有 $N$ 次迭代还是因故障而终止），$M$ 和 $F$ 的最终值构成结果对 $[M, F]$。\n\n现在我们将此算法应用于每个指定的测试用例。如规定，所有量都作为无符号 $32$ 位整数处理。\n\n**案例 1：** $(B_{\\text{DS}}=4096, L_{\\text{DS}}=63, B_{\\text{ES}}=8192, L_{\\text{ES}}=63, \\text{SI}_0=8, \\text{DI}_0=16, N=16, \\text{DF}=0)$\n- $\\text{SI}$ 从 $8$ 开始并递增。最后一次访问将在第 $15$ 次迭代（第 $16$ 个字节），届时 $\\text{SI} = 8 + 15 = 23$。由于 $23 \\le L_{\\text{DS}} (63)$，所有源访问都有效。\n- $\\text{DI}$ 从 $16$ 开始并递增。最后一次访问将在第 $15$ 次迭代，届时 $\\text{DI} = 16 + 15 = 31$。由于 $31 \\le L_{\\text{ES}} (63)$，所有目标访问都有效。\n- 循环无故障地完成了所有 $N=16$ 次迭代。\n- 结果：$[M, F] = [16, 0]$。\n\n**案例 2：** $(B_{\\text{DS}}=12288, L_{\\text{DS}}=31, B_{\\text{ES}}=16384, L_{\\text{ES}}=31, \\text{SI}_0=16, \\text{DI}_0=24, N=8, \\text{DF}=0)$\n- $\\text{SI}$ 的范围将从 $16$ 到 $16+7=23$。所有值都 $\\le L_{\\text{DS}} (31)$。所有源访问都有效。\n- $\\text{DI}$ 的范围将从 $24$ 到 $24+7=31$。在最后一次迭代（$i=7$）时，$\\text{DI}=31$。检查条件为 $31 \\le L_{\\text{ES}} (31)$，该条件为真。访问有效。\n- 循环无故障地完成了所有 $N=8$ 次迭代。\n- 结果：$[M, F] = [8, 0]$。\n\n**案例 3：** $(B_{\\text{DS}}=20480, L_{\\text{DS}}=40, B_{\\text{ES}}=24576, L_{\\text{ES}}=25, \\text{SI}_0=0, \\text{DI}_0=20, N=10, \\text{DF}=0)$\n- 随着 $\\text{SI}$ 和 $\\text{DI}$ 递增，迭代继续。我们检查 $\\text{DI}$ 是否超过 $L_{\\text{ES}} = 25$。\n- $i=0$: $\\text{DI}=20$。有效。$M=1$。\n- $i=1$: $\\text{DI}=21$。有效。$M=2$。\n- $i=2$: $\\text{DI}=22$。有效。$M=3$。\n- $i=3$: $\\text{DI}=23$。有效。$M=4$。\n- $i=4$: $\\text{DI}=24$。有效。$M=5$。\n- $i=5$: $\\text{DI}=25$。有效，因为 $25 \\le L_{\\text{ES}} (25)$。$M=6$。\n- $i=6$: 当前 $\\text{DI}=26$。在 $\\text{SI}=6$ 处的源访问有效（$6 \\le 40$）。在 $\\text{DI}=26$ 处的目标访问无效，因为 $26  L_{\\text{ES}} (25)$。\n- 发生目标故障（$F=2$）。循环终止。成功移动了 $6$ 个字节。\n- 结果：$[M, F] = [6, 2]$。\n\n**案例 4：** $(B_{\\text{DS}}=28672, L_{\\text{DS}}=5, B_{\\text{ES}}=32768, L_{\\text{ES}}=100, \\text{SI}_0=3, \\text{DI}_0=0, N=5, \\text{DF}=0)$\n- 随着 $\\text{SI}$ 和 $\\text{DI}$ 递增，迭代继续。我们检查 $\\text{SI}$ 是否超过 $L_{\\text{DS}} = 5$。\n- $i=0$: $\\text{SI}=3$。有效。$M=1$。\n- $i=1$: $\\text{SI}=4$。有效。$M=2$。\n- $i=2$: $\\text{SI}=5$。有效，因为 $5 \\le L_{\\text{DS}} (5)$。$M=3$。\n- $i=3$: 当前 $\\text{SI}=6$。在 $\\text{SI}=6$ 处的源访问无效，因为 $6  L_{\\text{DS}} (5)$。\n- 发生源故障（$F=1$）。循环终止。成功移动了 $3$ 个字节。\n- 结果：$[M, F] = [3, 1]$。\n\n**案例 5：** $(B_{\\text{DS}}=36864, L_{\\text{DS}}=50, B_{\\text{ES}}=40960, L_{\\text{ES}}=50, \\text{SI}_0=0, \\text{DI}_0=0, N=4, \\text{DF}=1)$\n- $\\text{DF}=1$，所以指针递减。\n- $i=0$: 当前 $\\text{SI}=0, \\text{DI}=0$。两者都是有效访问（$0 \\le 50$）。$M=1$。指针更新为 $\\text{SI} = 0 - 1 = 4294967295$ 和 $\\text{DI} = 0 - 1 = 4294967295$（假设为 32 位无符号整数）。\n- $i=1$: 当前 $\\text{SI}=4294967295$。检查源访问：$4294967295  L_{\\text{DS}} (50)$。这是无效的。\n- 发生源故障（$F=1$）。循环终止。成功移动了 $1$ 个字节。\n- 结果：$[M, F] = [1, 1]$。\n\n**案例 6：** $(B_{\\text{DS}}=45056, L_{\\text{DS}}=100, B_{\\text{ES}}=49152, L_{\\text{ES}}=100, \\text{SI}_0=0, \\text{DI}_0=0, N=0, \\text{DF}=0)$\n- 重复计数 $N$ 为 $0$。根据规则，不尝试任何操作。\n- 没有字节被移动，也没有故障发生。\n- 结果：$[M, F] = [0, 0]$。", "answer": "`[[16, 0], [8, 0], [6, 2], [3, 1], [1, 1], [0, 0]]`", "id": "3680444"}]}