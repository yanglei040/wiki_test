{"hands_on_practices": [{"introduction": "动态内存分配提供了极大的灵活性，但这并非没有代价。我们每分配一个内存块，实际占用的空间都超过了我们请求的有效载荷大小。这项动手计算将引导你剖析一个已分配内存块的内部结构，让你亲手计算包括头部和尾部等基本元数据，以及为满足硬件对齐要求而引入的填充字节。通过量化这些额外开销，你将对内部碎片和内存管理的隐藏成本有一个具体的认识。[@problem_id:3637495]", "problem": "一个用于操作系统课程的动态内存分配器，其实现的内存块带有显式元数据并遵循严格对齐。每个已分配的内存块在其有效载荷之前紧邻一个大小为 $h$ 的头部，在其有效载荷之后紧随一个大小为 $f$ 的尾部。分配器必须确保每个有效载荷的起始地址都与一个对齐量子 $a$ 对齐。该分配器在一个初始为空的堆上运行，该堆的基地址与 $a$ 对齐。它会顺序地放置内存块，连续的块之间没有间隙。为了在所有后续分配中保持有效载荷的对齐，分配器可以在头部之后立即插入最少非负字节数的填充，并且可以在块的末尾添加最少非负字节数的填充，以使块的总大小是 $a$ 的倍数。\n\n使用以下参数：头部大小 $h = 12$ 字节，尾部大小 $f = 4$ 字节，对齐量子 $a = 16$ 字节。考虑一个包含5个分配请求的序列，其有效载荷大小为 $\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ 字节。\n\n从以下基本定义出发：(i) 一个块的内部碎片是指该块内部不属于请求的有效载荷部分的字节数；(ii) 对齐意味着有效载荷的起始地址模 $a$ 同余于 $0$。请确定所有5个块中，不属于任何有效载荷的总字节数，这些字节完全由所述的元数据和对齐填充的相互作用产生（即，计算所有头部和尾部字节、为实现对齐而在有效载荷前插入的任何填充，以及为将块大小向上舍入为 $a$ 的倍数而在块末尾添加的任何填充）。\n\n请以整数字节数表示您的最终答案。无需进行四舍五入。最终数值答案的单位应为字节。", "solution": "该问题陈述已经过验证，被认为是具有科学依据、良定且客观的。它为解决操作系统动态内存分配研究中的一个标准问题，提供了一套完整且一致的参数和约束。\n\n该问题要求计算一个包含5次内存分配的序列中，非有效载荷字节的总数。这些非有效载荷字节包括块的元数据（头部和尾部）以及为满足对齐约束所需的任何填充。\n\n给定参数如下：\n- 头部大小：$h = 12$ 字节\n- 尾部大小：$f = 4$ 字节\n- 对齐量子：$a = 16$ 字节\n- 5个请求的有效载荷大小序列：$\\{s_1, s_2, s_3, s_4, s_5\\} = \\{13, 64, 7, 33, 2\\}$ 字节。\n\n我们来分析单个已分配块的结构。一个块由头部、可选的有效载荷前填充、有效载荷本身、尾部和可选的有效载荷后填充组成。每个块的总大小（包括所有部分）必须是对齐量子 $a$ 的倍数。\n\n分配器从一个与 $a$ 对齐的堆基地址开始，顺序放置内存块。设块 $i$ 的起始地址为 $B_i$。\n对于第一个块，$B_1$ 是堆的基地址，所以 $B_1 \\equiv 0 \\pmod a$。\n任何块 $i$ 的总大小（我们记为 $S_i$）都必须是 $a$ 的倍数。下一个块，即块 $i+1$，将从地址 $B_{i+1} = B_i + S_i$ 开始。由于 $B_i$ 是 $a$ 的倍数，而 $S_i$ 也是 $a$ 的倍数，因此 $B_{i+1}$ 也将是 $a$ 的倍数。根据归纳法，每个块的起始地址 $B_i$ 都与量子 $a$ 对齐。\n\n现在，我们来确定给定有效载荷大小 $s_i$ 的块的各个组成部分。\n1.  **头部**：块从地址 $B_i$ 开始，有一个大小为 $h$ 的头部。头部结束于地址 $B_i + h - 1$。\n2.  **有效载荷前填充**：有效载荷必须从一个地址 $P_i$ 开始，该地址是 $a$ 的倍数。这个地址必须大于或等于紧随头部之后的地址，即 $B_i + h$。由于 $B_i \\equiv 0 \\pmod a$，我们需要找到大于或等于 $B_i + h$ 的最小的 $a$ 的倍数。这等同于找到最小的非负填充量 $p_{\\text{pre},i}$，加到 $h$ 上使得 $h + p_{\\text{pre},i}$ 是 $a$ 的倍数。由于这个填充量仅取决于 $h$ 和 $a$，因此它对所有块都是恒定的。\n    有效载荷前的填充量由公式 $(a - (h \\pmod a)) \\pmod a$ 给出。\n    代入给定值：\n    $$p_{\\text{pre}} = (16 - (12 \\pmod{16})) \\pmod{16} = (16 - 12) \\pmod{16} = 4 \\text{ 字节}$$\n    因此，对于每个块，在头部和有效载荷之间都插入了 $4$ 字节的填充。块 $i$ 的有效载荷起始于地址 $P_i = B_i + h + p_{\\text{pre}} = B_i + 12 + 4 = B_i + 16$，该地址与 $a$ 对齐。\n\n3.  **有效载荷和尾部**：放置大小为 $s_i$ 的有效载荷，然后是一个大小为 $f$ 的尾部。\n\n4.  **块总大小和有效载荷后填充**：在最终取整之前，块的大小是头部、有效载荷前填充、有效载荷和尾部大小的总和。我们将这个未取整的大小称为 $U_i$。\n    $$U_i = h + p_{\\text{pre}} + s_i + f = 12 + 4 + s_i + 4 = 20 + s_i$$\n    块的总大小 $S_i$ 必须是大于或等于 $U_i$ 的最小的 $a$ 的倍数。这通过将 $U_i$ 向上取整到最接近的 $a$ 的倍数来计算。\n    $$S_i = a \\cdot \\left\\lceil \\frac{U_i}{a} \\right\\rceil = 16 \\cdot \\left\\lceil \\frac{20 + s_i}{16} \\right\\rceil$$\n    有效载荷后的填充量是 $p_{\\text{post},i} = S_i - U_i$。\n\n对于每个块，我们关心的量是非有效载荷字节数 $N_i$。这是块的总大小减去有效载荷的大小。\n$$N_i = S_i - s_i$$\n这等同于头部、尾部以及两部分填充的大小之和：$N_i = h + f + p_{\\text{pre}} + p_{\\text{post},i}$。\n\n我们现在为5个分配请求中的每一个计算 $N_i$。\n\n**块 1：** $s_1 = 13$ 字节\n- 未取整大小：$U_1 = 20 + 13 = 33$ 字节。\n- 块总大小：$S_1 = 16 \\cdot \\lceil \\frac{33}{16} \\rceil = 16 \\cdot 3 = 48$ 字节。\n- 非有效载荷字节数：$N_1 = S_1 - s_1 = 48 - 13 = 35$ 字节。\n\n**块 2：** $s_2 = 64$ 字节\n- 未取整大小：$U_2 = 20 + 64 = 84$ 字节。\n- 块总大小：$S_2 = 16 \\cdot \\lceil \\frac{84}{16} \\rceil = 16 \\cdot 6 = 96$ 字节。\n- 非有效载荷字节数：$N_2 = S_2 - s_2 = 96 - 64 = 32$ 字节。\n\n**块 3：** $s_3 = 7$ 字节\n- 未取整大小：$U_3 = 20 + 7 = 27$ 字节。\n- 块总大小：$S_3 = 16 \\cdot \\lceil \\frac{27}{16} \\rceil = 16 \\cdot 2 = 32$ 字节。\n- 非有效载荷字节数：$N_3 = S_3 - s_3 = 32 - 7 = 25$ 字节。\n\n**块 4：** $s_4 = 33$ 字节\n- 未取整大小：$U_4 = 20 + 33 = 53$ 字节。\n- 块总大小：$S_4 = 16 \\cdot \\lceil \\frac{53}{16} \\rceil = 16 \\cdot 4 = 64$ 字节。\n- 非有效载荷字节数：$N_4 = S_4 - s_4 = 64 - 33 = 31$ 字节。\n\n**块 5：** $s_5 = 2$ 字节\n- 未取整大小：$U_5 = 20 + 2 = 22$ 字节。\n- 块总大小：$S_5 = 16 \\cdot \\lceil \\frac{22}{16} \\rceil = 16 \\cdot 2 = 32$ 字节。\n- 非有效载荷字节数：$N_5 = S_5 - s_5 = 32 - 2 = 30$ 字节。\n\n所有5个块的非有效载荷字节总数是各个块的非有效载荷字节数之和：\n$$N_{\\text{total}} = N_1 + N_2 + N_3 + N_4 + N_5$$\n$$N_{\\text{total}} = 35 + 32 + 25 + 31 + 30$$\n$$N_{\\text{total}} = 153 \\text{ 字节}$$", "answer": "$$\\boxed{153}$$", "id": "3637495"}, {"introduction": "随着程序的运行，内存空间会逐渐变成由已用和空闲块组成的“碎片拼图”，这种状态被称为外部碎片。它可能导致在总空闲内存充足的情况下，新的分配请求仍然失败。本练习将介绍内存紧缩技术——解决外部碎片的终极方案，该技术通过移动已分配的内存块来形成一整块连续的空闲空间。你将计算这一操作的现实世界成本（以时间衡量）及其在减少碎片方面的直接收益。[@problem_id:3637454]", "problem": "一个操作系统（OS）管理一个总大小为 $64$ MiB 的连续随机存取存储器（RAM）区域，其字节地址从基地址 $0$ 开始计算。该内存目前包含以下活动分配，由它们的起始偏移量（距基地址，单位为 MiB）和大小（单位为 MiB）指定：\n分配 $A_{1}$：起始地址 $4$，大小 $6$；分配 $A_{2}$：起始地址 $12$，大小 $8$；分配 $A_{3}$：起始地址 $22$，大小 $2$；分配 $A_{4}$：起始地址 $28$，大小 $10$；分配 $A_{5}$：起始地址 $40$，大小 $5$；分配 $A_{6}$：起始地址 $48$，大小 $4$；分配 $A_{7}$：起始地址 $56$，大小 $3$。\n\n所有其他内存均为空闲。空闲区间（单位为 MiB）为 $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$, 和 $[59,64)$。\n\n从动态存储分配中外部碎片的基本定义以及数据传输带宽的定义出发，设计一种紧缩策略，该策略重新定位所有活动分配，以形成一个单一的连续空闲区域，同时按原始起始偏移的非递减顺序保留分配顺序，并确保在重新定位过程中没有重叠。根据此策略，确定：\n\n1. 重定位成本 $R$，定义为完成紧缩所需的总时间（以秒为单位），假设统一的重定位带宽为 $B = 64 \\times 2^{20}$ 字节/秒。将 $R$ 以秒表示。\n\n2. 外部碎片的减少量 $\\Delta F$，其中碎片度量 $F$ 定义为不属于最大连续空闲块的总空闲内存的比例，即 $F = 1 - \\frac{\\text{最大空闲块的大小}}{\\text{总空闲内存大小}}$。计算 $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$，结果为一个纯数（无量纲）。\n\n提供 $R$ 和 $\\Delta F$ 的精确值；不要四舍五入。最终答案必须以包含 $R$ 和 $\\Delta F$ 的行矩阵形式给出。", "solution": "问题陈述已经过验证，被认为是自洽、有科学依据且定义明确的。所有提供的数据都是一致的，足以推导出唯一的解。内存紧缩、外部碎片和数据传输带宽的概念是操作系统中的标准主题，其在问题中的定义是形式化且明确的。因此，我们可以着手求解。\n\n问题要求计算两个量：重定位成本 $R$ 和外部碎片的减少量 $\\Delta F$。我们将依次解决每个问题。\n\n首先，我们核实内存布局。总 RAM 大小为 $S_{RAM} = 64$ MiB。\n活动分配如下：\n$A_{1}$：起始地址 $4$ MiB，大小 $6$ MiB $\\rightarrow$ 区间 $[4, 10)$\n$A_{2}$：起始地址 $12$ MiB，大小 $8$ MiB $\\rightarrow$ 区间 $[12, 20)$\n$A_{3}$：起始地址 $22$ MiB，大小 $2$ MiB $\\rightarrow$ 区间 $[22, 24)$\n$A_{4}$：起始地址 $28$ MiB，大小 $10$ MiB $\\rightarrow$ 区间 $[28, 38)$\n$A_{5}$：起始地址 $40$ MiB，大小 $5$ MiB $\\rightarrow$ 区间 $[40, 45)$\n$A_{6}$：起始地址 $48$ MiB，大小 $4$ MiB $\\rightarrow$ 区间 $[48, 52)$\n$A_{7}$：起始地址 $56$ MiB，大小 $3$ MiB $\\rightarrow$ 区间 $[56, 59)$\n\n已分配内存的总大小是所有分配大小的总和：\n$$S_{alloc} = 6 + 8 + 2 + 10 + 5 + 4 + 3 = 38 \\text{ MiB}$$\n\n空闲区间给出为 $[0,4)$, $[10,12)$, $[20,22)$, $[24,28)$, $[38,40)$, $[45,48)$, $[52,56)$, 和 $[59,64)$。\n空闲内存的总大小是这些空闲块大小的总和：\n$$S_{free} = (4-0) + (12-10) + (22-20) + (28-24) + (40-38) + (48-45) + (56-52) + (64-59)$$\n$$S_{free} = 4 + 2 + 2 + 4 + 2 + 3 + 4 + 5 = 26 \\text{ MiB}$$\n\n已分配内存和空闲内存的总和为 $S_{alloc} + S_{free} = 38 + 26 = 64$ MiB，与总 RAM 大小相符，这证实了所提供数据的一致性。\n\n**1. 计算重定位成本 $R$**\n\n紧缩策略是将所有活动分配重定位到内存区域的起始位置（从地址 $0$ 开始），形成一个单一的连续块，并保持它们的相对顺序。重定位成本 $R$ 是移动数据所需的总时间。这个时间由移动的总数据量和内存带宽决定。\n\n该策略规定，紧缩后，所有分配将从地址 $0$ 开始连续排列。新的布局将是：\n$A_{1}$ 位于 $[0, 6)$\n$A_{2}$ 位于 $[6, 14)$\n$A_{3}$ 位于 $[14, 16)$\n$A_{4}$ 位于 $[16, 26)$\n$A_{5}$ 位于 $[26, 31)$\n$A_{6}$ 位于 $[31, 35)$\n$A_{7}$ 位于 $[35, 38)$\n\n第一个分配 $A_{1}$ 的原始起始地址是 $4$ MiB，而不是 $0$ MiB。因此，$A_{1}$ 必须被移动到其新位置，即地址 $0$。为了保持连续性和相对顺序，所有后续的分配也必须被移动到它们的新位置。因此，需要重定位的总数据量是所有活动分配大小的总和。\n\n需要移动的总数据量 = $S_{alloc} = 38$ MiB。\n为了计算时间，我们必须用一致的单位来表示数据大小和带宽。\n$1$ MiB = $2^{20}$ 字节。\n需要移动的总数据量 = $38 \\times 2^{20}$ 字节。\n\n给定的重定位带宽为 $B = 64 \\times 2^{20}$ 字节/秒。\n\n重定位成本 $R$ 是移动的总数据量与带宽的比值：\n$$R = \\frac{\\text{需要移动的总数据量}}{B} = \\frac{38 \\times 2^{20} \\text{ 字节}}{64 \\times 2^{20} \\text{ 字节/秒}}$$\n项 $2^{20}$ 被消掉了：\n$$R = \\frac{38}{64} = \\frac{19}{32} \\text{ 秒}$$\n\n**2. 计算外部碎片的减少量 $\\Delta F$**\n\n碎片度量定义为 $F = 1 - \\frac{\\text{最大空闲块的大小}}{\\text{总空闲内存大小}}$。碎片的减少量为 $\\Delta F = F_{\\text{before}} - F_{\\text{after}}$。\n\n首先，我们计算 $F_{\\text{before}}$。\n紧缩前空闲块的大小分别为 $4$、$2$、$2$、$4$、$2$、$3$、$4$ 和 $5$ MiB。\n最大空闲块的大小是这些值的最大值：\n$$\\text{最大空闲块的大小}_{\\text{before}} = \\max(\\{4, 2, 2, 4, 2, 3, 4, 5\\}) = 5 \\text{ MiB}$$\n总空闲内存为 $S_{free} = 26$ MiB。\n$$F_{\\text{before}} = 1 - \\frac{5 \\text{ MiB}}{26 \\text{ MiB}} = 1 - \\frac{5}{26} = \\frac{21}{26}$$\n\n接下来，我们计算 $F_{\\text{after}}$。\n紧缩后，所有已分配的块在内存的起始位置形成一个大小为 $S_{alloc} = 38$ MiB 的单一连续段。这使得所有空闲空间在内存的末尾合并成一个单一的连续块。\n这个单一空闲块的大小等于总空闲内存，$S_{free} = 26$ MiB。\n因此，紧缩后最大空闲块的大小是 $26$ MiB。\n$$F_{\\text{after}} = 1 - \\frac{26 \\text{ MiB}}{26 \\text{ MiB}} = 1 - 1 = 0$$\n\n最后，我们计算碎片的减少量 $\\Delta F$：\n$$\\Delta F = F_{\\text{before}} - F_{\\text{after}} = \\frac{21}{26} - 0 = \\frac{21}{26}$$\n\n两个所求的值是 $R = \\frac{19}{32}$ 和 $\\Delta F = \\frac{21}{26}$。", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{19}{32}  \\frac{21}{26} \\end{pmatrix}}$$", "id": "3637454"}, {"introduction": "高效的内存管理是一场策略博弈，当下的选择会直接影响未来的性能。本练习提出了一个有趣的困境：当一个被释放的块位于另外两个空闲块之间时，将三者全部合并是否总是最佳选择？通过使用最佳适配（Best-Fit）算法进行仔细分析，你将探索一种“部分合并”策略出人意料地优于“完全合并”的场景，因为它降低了未来的操作成本。这将锻炼你对算法设计和权衡取舍的批判性思维能力。[@problem_id:3637529]", "problem": "考虑一个操作系统（OS）中的动态存储分配（DSA）问题，该系统使用空闲列表执行连续内存分配。当一个进程释放一个先前分配的块时，分配器可能会应用合并（coalescing）操作，通过合并相邻的空闲块来减少外部碎片。假设在时间 $t_{0}$ 释放了一个大小为 $m$ 的块，其紧邻的左邻居是一个大小为 $l$ 的空闲块，而其紧邻的右邻居是一个大小为 $r$ 的空闲块。在处理即将到来的分配请求之前，分配器必须在两种策略之间做出选择：\n\n- 完全合并：将所有三个连续的空闲区域合并，形成一个总大小为 $t = l + m + r$ 的空闲块。\n- 部分合并：仅将释放的块与其左邻居合并，形成两个大小分别为 $k = l + m$ 和 $r$ 的空闲块。\n\n假设分配器使用最佳适配（Best-Fit, BF）算法，该算法选择能够满足分配请求的最小空闲块。当所选空闲块的大小严格大于请求大小时，BF 会分割该块，从而产生一次分割操作。精确适配的分配不会发生分割。为了进行局部分析，忽略系统中的任何其他空闲块，并假设空闲列表是按地址排序的，但 BF 是基于大小的，并且会不考虑地址而按大小选择。设接下来的两个分配请求按顺序到达，大小分别为 $x$（第一个）和 $y$（第二个）。将分割操作视为元数据开销和近期碎片成本的代表。\n\n在为即将到来的请求减少分割操作的意义上，以下哪个陈述正确地描述了通过部分合并留下两个较小空闲区比通过完全合并形成一个大空闲区性能严格更好的条件？选择所有适用项。\n\nA. 在 BF 算法下，如果接下来的两个请求大小满足 $x = r$ 和 $y = k = l + m$，那么对于这两个请求，部分合并产生的分割操作严格少于完全合并。\n\nB. 在 BF 算法下，只要 $x \\le k$ 和 $y \\le r$，部分合并导致的分配失败次数就少于完全合并。\n\nC. 设下一个请求的大小为一个随机变量 $S$，其分布支持在非负大小上。如果 $P\\!\\left(S \\in \\left(\\max\\!\\{k, r\\},\\, t\\right]\\right) \\approx 0$ 且 $P(S = r) + P(S = k) > 0$，那么相对于完全合并，部分合并最小化了下一个请求的期望分割操作次数。\n\nD. 在任何允许分割的策略下，完全合并在容量和分割次数两个指标上都严格优于部分合并；对于任何未来的请求序列，部分合并产生的分割操作次数都不可能严格少于完全合并。", "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n- **问题背景**：操作系统（OS）中的动态存储分配（DSA），采用连续内存分配和空闲列表。\n- **事件**：在时间 `$t_0$` 释放了一个大小为 `$m$` 的块。\n- **相邻块**：释放的块有一个紧邻的左邻居（空闲，大小为 `$l$`）和一个紧邻的右邻居（空闲，大小为 `$r$`）。\n- **策略 1（完全合并）**：将三个块合并成一个大小为 `$t = l + m + r$` 的空闲块。\n- **策略 2（部分合并）**：将释放的块与其左邻居合并，产生两个大小分别为 `$k = l + m$` 和 `$r$` 的空闲块。\n- **分配算法**：最佳适配（Best-Fit, BF），选择能够满足请求的最小空闲块。\n- **分割规则**：如果所选块的大小严格大于请求的大小，则该块被分割。精确适配的分配（`请求大小 = 块大小`）不产生分割。\n- **假设**：\n    1. 分析是局部的；系统中的任何其他空闲块都被忽略。\n    2. 空闲列表是按地址排序的，但 BF 搜索是基于大小的。\n    3. 接下来的两个分配请求是连续的，大小分别为 `$x$`（第一个）和 `$y$`（第二个）。\n- **度量标准**：分割操作的次数。如果一个策略导致的分割操作严格更少，则其性能“严格更好”。\n\n### 步骤 2：使用提取的已知信息进行验证\n- **科学性**：该问题在操作系统内存管理的原理上有充分的依据。动态存储分配、合并策略（完全合并 vs. 部分/延迟合并）、分配算法（最佳适配）以及碎片（分割操作会导致碎片）都是标准的、基本的概念。\n- **问题定义良好**：该问题定义良好。它定义了两种不同的策略，一个明确的分配算法（BF），以及一个精确、可量化的比较度量标准（分割操作次数）。问题要求找出在哪种条件下，一个策略根据这个度量标准优于另一个，这是一个可解的分析任务。\n- **客观性**：问题以客观、正式的语言陈述。所有术语如“最佳适配”、“合并”和“分割”在计算机科学中都有精确的含义。\n- **完整性和一致性**：“忽略任何其他空闲块”的简化假设使局部分析易于处理。关于空闲列表按地址排序而 BF 基于大小的陈述并不矛盾；它描述了一种可能的实现，其中列表维护（用于合并）与分配搜索策略是分开的。没有内部矛盾。\n- **其他缺陷**：该问题没有其他列出的缺陷。这是一个标准的、非平凡的、关于算法比较的分析问题，而不是隐喻性的、伪深刻的或无法验证的。\n\n### 步骤 3：结论与操作\n问题陈述是**有效的**，并为进行严谨的分析提供了坚实的基础。\n\n## 解题推导\n\n问题的核心是比较在两种不同的内存状态下，对于一个由两个请求 `$x$` 和 `$y$` 组成的序列，所产生的分割操作次数。\n\n- **完全合并状态**：一个大小为 `$t = l + m + r$` 的空闲块。\n- **部分合并状态**：两个大小分别为 `$k = l+m$` 和 `$r$` 的空闲块。注意 `$t = k+r$`。\n\n当从大小为 `$S_{block}$` 的块中为一个大小为 `$s$` 的请求进行分配，且 `$s  S_{block}$` 时，会发生分割操作。如果 `$s = S_{block}$`，则是精确适配，不发生分割。我们假设 `$l, m, r` 都是正数大小，所以 `$k>0, r>0, t>k, t>r$`。\n\n### 逐项分析\n\n**A. 在 BF 算法下，如果接下来的两个请求大小满足 $x = r$ 和 $y = k = l + m$，那么对于这两个请求，部分合并产生的分割操作严格少于完全合并。**\n\n让我们分析在给定的请求序列 `$x=r, y=k$` 下，每种策略的分割次数。\n\n- **完全合并：**\n    1.  **初始状态**：一个大小为 `$t = k+r$` 的空闲块。\n    2.  **请求 1（大小 $x=r$）**：唯一可用的块大小为 `$t$`。因为 `$k>0$`，我们有 `$r  k+r = t$`。请求从大小为 `$t$` 的块中得到满足。由于 `$r  t$`，这不是精确适配。发生 **1 次分割**。\n    3.  **请求 1 之后的状态**：剩余的空闲块大小为 `$t-x = (k+r) - r = k$`。\n    4.  **请求 2（大小 $y=k$）**：请求从大小为 `$k$` 的块中得到满足。这是精确适配。发生 **0 次分割**。\n    5.  **总分割次数（完全合并）**：`$1 + 0 = 1$`。\n\n- **部分合并：**\n    1.  **初始状态**：两个大小分别为 `$k$` 和 `$r$` 的空闲块。\n    2.  **请求 1（大小 $x=r$）**：可以满足请求的可用块集合包括大小为 `$r$` 的块，以及可能的大小为 `$k$` 的块（如果 `$r \\le k$`）。根据最佳适配（BF）规则，分配器必须选择足够大的最小块。大小为 `$r$` 的块是精确适配，因此是最小的可能适配。BF 将选择大小为 `$r$` 的块。这是精确适配。发生 **0 次分割**。\n    3.  **请求 1 之后的状态**：剩下大小为 `$k$` 的块。\n    4.  **请求 2（大小 $y=k$）**：请求从剩下的大小为 `$k$` 的块中得到满足。这是精确适配。发生 **0 次分割**。\n    5.  **总分割次数（部分合并）**：`$0 + 0 = 0$`。\n\n- **比较**：部分合并产生 `$0$` 次分割，而完全合并产生 `$1$` 次分割。因此，部分合并产生的分割操作严格更少。\n\n**选项 A 的结论**：**正确**。\n\n**B. 在 BF 算法下，只要 $x \\le k$ 和 $y \\le r$，部分合并导致的分配失败次数就少于完全合并。**\n\n这个陈述关心的是分配失败，而不是分割操作，后者是问题中定义的主要度量标准。然而，我们将按其书面内容评估该主张。它声称部分合并导致*严格更少*的失败。\n\n- **完全合并：**\n    1.  **初始状态**：一个大小为 `$t = k+r$` 的空闲块。\n    2.  **请求 1（大小 $x \\le k$）**：由于 `$x \\le k  k+r = t$`，请求总能被满足。**0 次失败**。\n    3.  **请求 1 之后的状态**：剩余块的大小为 `$t-x = k+r-x$`。\n    4.  **请求 2（大小 $y \\le r$）**：要满足此请求，我们需要 `$y \\le k+r-x$`。我们已知 `$y \\le r$` 和 `$x \\le k$`。从 `$x \\le k$` 可得 `-x \\ge -k$`，所以 `$k+r-x \\ge k+r-k = r$`。因此，我们有 `$y \\le r \\le k+r-x$`，这保证了第二个请求也能被满足。**0 次失败**。\n    5.  **总失败次数（完全合并）**：`$0$`。\n\n- **部分合并：**\n    最终，由于 `$x \\le k$` 和 `$y \\le r$`，并且在部分合并状态下，大小为 `$k$` 和 `$r$` 的块都是可用的，这两个请求都总能被满足。**0 次失败**。\n\n- **比较**：两种策略都导致 `$0$` 次失败。因此，部分合并导致的失败次数并**不严格少于**完全合并。\n\n**选项 B 的结论**：**错误**。\n\n**C. 设下一个请求的大小为一个随机变量 $S$，其分布支持在非负大小上。如果 $P\\!\\left(S \\in \\left(\\max\\!\\{k, r\\},\\, t\\right]\\right) \\approx 0$ 且 $P(S = r) + P(S = k) > 0$，那么相对于完全合并，部分合并最小化了下一个请求的期望分割操作次数。**\n\n这个选项提出了一个概率性论点。\n- **条件 1**：$P(S \\in (\\max\\{k, r\\}, t]) \\approx 0$。这意味着，几乎从不会有请求的大小恰好落在只有完全合并的块 `$t$` 才能满足，而部分合并的块 `$k$` 和 `$r$` 都不能满足的范围内。这个条件有效地消除了完全合并策略在容量上的主要优势。\n- **条件 2**：$P(S = r) + P(S = k) > 0$。这意味着，有非零的概率会收到大小正好是 `$k$` 或 `$r$` 的请求。\n\n让我们分析一下当这些请求到达时会发生什么：\n- **如果请求大小为 $S=r$**：\n    - 完全合并：从块 `$t$` 分配。由于 `$r  t$`，发生 **1 次分割**。\n    - 部分合并：从块 `$r$` 分配。这是**精确适配**，**0 次分割**。\n- **如果请求大小为 $S=k$**：\n    - 完全合并：从块 `$t$` 分配。由于 `$k  t$`，发生 **1 次分割**。\n    - 部分合并：从块 `$k$` 分配。这是**精确适配**，**0 次分割**。\n\n对于其他任何大小的请求 $S \\le \\max\\{k, r\\}$，两种策略很可能都会导致一次分割（除非 $S$ 恰好等于 $k$ 或 $r$）。但重要的是，在条件 2 所述的、有正概率发生的事件中，部分合并策略每次都避免了一次分割。由于在条件 1 所述的、完全合并唯一有优势的事件几乎从不发生，因此在计算期望分割次数时，部分合并策略的期望值将严格低于完全合并策略。\n\n**选项 C 的结论**：**正确**。它正确地识别出了一种负载模式，在这种模式下，保留多个较小的、与预期请求大小相匹配的块，比创建一个大的、通用的块更优。\n\n**D. 在任何允许分割的策略下，完全合并在容量和分割次数两个指标上都严格优于部分合并；对于任何未来的请求序列，部分合并产生的分割操作次数都不可能严格少于完全合并。**\n\n这是一个非常强的“总是更好”的主张。\n- **容量**：完全合并确实提供了更大的容量，能够满足大小在 $(\\max\\{k, r\\}, t]$ 范围内的请求，而部分合并无法满足。\n- **分割次数**：我们在对选项 A 的分析中已经构建了一个具体的反例（请求序列 `$x=r, y=k$`），其中部分合并产生的分割操作（0次）严格少于完全合并（1次）。\n\n由于存在一个反例，即部分合并在某些情况下在分割次数上表现更好，所以该选项的第二部分是错误的。\n\n**选项 D 的结论**：**错误**。", "answer": "$$\\boxed{AC}$$", "id": "3637529"}]}