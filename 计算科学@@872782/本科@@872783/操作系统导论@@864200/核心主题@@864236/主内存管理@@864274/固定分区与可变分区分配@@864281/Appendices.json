{"hands_on_practices": [{"introduction": "理论上，我们知道固定分区和可变分区策略都会导致内存浪费，但方式不同。这个练习将这种定性理解转化为定量分析。通过从第一性原理出发，你将推导出在特定假设下，对齐的可变分区方案与固定分区方案在内部碎片方面的预期差异，从而揭示它们之间微妙的权衡关系。[@problem_id:3644725]", "problem": "一个操作系统（OS）的内存管理器支持两种用于连续主内存段的分配方案。在这两种方案中，进程到达时带有独立的内存需求，该需求被建模为一个在 $\\{1,2,\\dots,b\\}$ 上均匀分布的整数值随机变量 $S$，其中 $b$ 是一个固定的最大分区大小。这两种方案定义如下：\n\n- 带对齐的可变分区分配：每次分配必须从一个地址开始，该地址是 $a$ 字节的倍数，其中 $a \\in \\mathbb{N}$ 是一个固定的对齐量子。为了为后续分配保持对齐，分配器将每个请求向上舍入到大于或等于 $S$ 的 $a$ 的最小倍数。因此，分配的大小为 $\\lceil S/a \\rceil a$ 字节。\n\n- 固定分区分配：主内存被划分为大小为 $b$ 字节的相等大小的固定分区。每个到达的进程都被放置在这样一个分区中。\n\n假设 $b$ 是 $a$ 的整数倍，即 $b = m a$，其中 $m \\in \\mathbb{N}$。将在给定方案下，大小为 $S$ 的请求的内部碎片定义为分配大小与 $S$ 之间的差值。令 $\\delta$ 表示使用带对齐的可变分区方案而非固定分区方案时，每个请求的预期额外内部碎片，即 $\\delta = \\mathbb{E}[\\text{waste}_{\\text{aligned}}] - \\mathbb{E}[\\text{waste}_{\\text{fixed}}]$。\n\n从第一性原理（内部碎片的定义和均匀分布的性质）出发，推导 $\\delta$ 作为 $a$ 和 $m$ 的函数的封闭形式表达式。请给出你的最终答案，形式为仅含 $a$ 和 $m$ 的单个封闭形式代数表达式。不需要数值近似或舍入。", "solution": "问题要求推导 $\\delta$ 的封闭形式表达式，$\\delta$ 是带对齐的可变分区方案相对于固定分区方案的预期额外内部碎片。量 $\\delta$ 定义为 $\\delta = \\mathbb{E}[\\text{waste}_{\\text{aligned}}] - \\mathbb{E}[\\text{waste}_{\\text{fixed}}]$。我们将从第一性原理出发，分别推导这两个期望值的表达式。\n\n内存请求大小 $S$ 是一个在集合 $\\{1, 2, \\dots, b\\}$ 上均匀分布的整数值随机变量。其概率质量函数为 $P(S=s) = \\frac{1}{b}$，对于任何 $s \\in \\{1, 2, \\dots, b\\}$。函数 $f(S)$ 的期望值由 $\\mathbb{E}[f(S)] = \\sum_{s=1}^{b} f(s) P(S=s) = \\frac{1}{b} \\sum_{s=1}^{b} f(s)$ 给出。\n\n首先，我们计算请求大小的期望值 $\\mathbb{E}[S]$。\n$$\n\\mathbb{E}[S] = \\frac{1}{b} \\sum_{s=1}^{b} s\n$$\n使用前 $b$ 个整数的和的公式 $\\sum_{s=1}^{b} s = \\frac{b(b+1)}{2}$，我们得到：\n$$\n\\mathbb{E}[S] = \\frac{1}{b} \\left( \\frac{b(b+1)}{2} \\right) = \\frac{b+1}{2}\n$$\n\n接下来，我们计算固定分区方案的预期内部碎片 $\\mathbb{E}[\\text{waste}_{\\text{fixed}}]$。\n内部碎片定义为分配大小减去请求大小。在固定分区方案中，每个进程都被分配一个大小为 $b$ 的分区。\n$$\n\\text{waste}_{\\text{fixed}}(S) = b - S\n$$\n利用期望的线性性质，预期的碎片为：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{fixed}}] = \\mathbb{E}[b - S] = b - \\mathbb{E}[S]\n$$\n代入 $\\mathbb{E}[S]$ 的表达式：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{fixed}}] = b - \\frac{b+1}{2} = \\frac{2b - (b+1)}{2} = \\frac{b-1}{2}\n$$\n给定约束 $b = ma$，我们可以用 $m$ 和 $a$ 来表示它：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{fixed}}] = \\frac{ma-1}{2}\n$$\n\n现在，我们计算带对齐的可变分区方案的预期内部碎片 $\\mathbb{E}[\\text{waste}_{\\text{aligned}}]$。\n在此方案中，对请求 $S$ 的分配大小向上舍入到对齐量子 $a$ 的最近倍数。分配的大小为 $\\lceil S/a \\rceil a$。\n$$\n\\text{waste}_{\\text{aligned}}(S) = \\lceil S/a \\rceil a - S\n$$\n预期的碎片为：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{aligned}}] = \\mathbb{E}[\\lceil S/a \\rceil a - S] = \\mathbb{E}[\\lceil S/a \\rceil a] - \\mathbb{E}[S] = a \\mathbb{E}[\\lceil S/a \\rceil] - \\mathbb{E}[S]\n$$\n我们需要计算 $\\mathbb{E}[\\lceil S/a \\rceil]$。使用期望的定义：\n$$\n\\mathbb{E}[\\lceil S/a \\rceil] = \\frac{1}{b} \\sum_{s=1}^{b} \\lceil s/a \\rceil\n$$\n我们已知 $b=ma$。求和是对从 $1$ 到 $ma$ 的 $s$ 进行的。我们可以根据 $\\lceil s/a \\rceil$ 的值对求和项进行分组。\n令 $k = \\lceil s/a \\rceil$。对于 $s$ 的连续 $a$ 个整数块，$k$ 的值是恒定的。\n- 对于 $s \\in \\{1, 2, \\dots, a\\}$，我们有 $\\lceil s/a \\rceil = 1$。共有 $a$ 个这样的项。\n- 对于 $s \\in \\{a+1, a+2, \\dots, 2a\\}$，我们有 $\\lceil s/a \\rceil = 2$。共有 $a$ 个这样的项。\n- ...\n- 对于 $s \\in \\{(k-1)a+1, \\dots, ka\\}$，我们有 $\\lceil s/a \\rceil = k$。\n- 这个过程持续到最后一组项。对于 $s \\in \\{(m-1)a+1, \\dots, ma\\}$，我们有 $\\lceil s/a \\rceil = m$。共有 $a$ 个这样的项。\n\n这个和可以重写为对 $k$ 的可能值（即 $1, 2, \\dots, m$）求和。\n$$\n\\sum_{s=1}^{ma} \\lceil s/a \\rceil = \\sum_{k=1}^{m} \\sum_{s=(k-1)a+1}^{ka} \\lceil s/a \\rceil = \\sum_{k=1}^{m} \\sum_{s=(k-1)a+1}^{ka} k\n$$\n内层求和有 $ka - ((k-1)a+1) + 1 = a$ 个项，每一项都等于 $k$。所以，内层求和为 $a k$。\n$$\n\\sum_{s=1}^{ma} \\lceil s/a \\rceil = \\sum_{k=1}^{m} (a k) = a \\sum_{k=1}^{m} k\n$$\n使用前 $m$ 个整数的和的公式：\n$$\n\\sum_{s=1}^{ma} \\lceil s/a \\rceil = a \\left( \\frac{m(m+1)}{2} \\right)\n$$\n现在，我们可以求出 $\\mathbb{E}[\\lceil S/a \\rceil]$：\n$$\n\\mathbb{E}[\\lceil S/a \\rceil] = \\frac{1}{b} \\left( a \\frac{m(m+1)}{2} \\right) = \\frac{1}{ma} \\left( a \\frac{m(m+1)}{2} \\right) = \\frac{m+1}{2}\n$$\n我们把这个结果代回到 $\\mathbb{E}[\\text{waste}_{\\text{aligned}}]$ 的表达式中：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{aligned}}] = a \\mathbb{E}[\\lceil S/a \\rceil] - \\mathbb{E}[S] = a \\left( \\frac{m+1}{2} \\right) - \\frac{b+1}{2}\n$$\n使用 $b = ma$：\n$$\n\\mathbb{E}[\\text{waste}_{\\text{aligned}}] = \\frac{a(m+1)}{2} - \\frac{ma+1}{2} = \\frac{am+a - ma - 1}{2} = \\frac{a-1}{2}\n$$\n\n最后，我们计算 $\\delta$，即两个预期碎片值之间的差值。\n$$\n\\delta = \\mathbb{E}[\\text{waste}_{\\text{aligned}}] - \\mathbb{E}[\\text{waste}_{\\text{fixed}}]\n$$\n代入推导出的表达式：\n$$\n\\delta = \\frac{a-1}{2} - \\frac{ma-1}{2}\n$$\n$$\n\\delta = \\frac{(a-1) - (ma-1)}{2} = \\frac{a-1-ma+1}{2} = \\frac{a-ma}{2}\n$$\n提出因子 $a$，我们得到 $\\delta$ 关于 $a$ 和 $m$ 的最终封闭形式表达式：\n$$\n\\delta = \\frac{a(1-m)}{2}\n$$", "answer": "$$\n\\boxed{\\frac{a(1-m)}{2}}\n$$", "id": "3644725"}, {"introduction": "理解内存分配器不仅仅是记住它们的定义，更重要的是能够预测它们的行为。本练习像一个“内存取证”谜题，要求你根据一系列内存操作和最终的内存布局，反向推断出系统所使用的具体分配算法。通过手动追踪不同策略下的内存状态，你将加深对首次适应、最佳适应和空闲块合并等策略的实践理解。[@problem_id:3644730]", "problem": "一个系统管理主内存，并按地址递增的顺序维护一个空闲块列表。一个单一的长时间运行的工作负载执行一系列的分配和释放操作。你只被告知以下基本规则和观察结果。\n\n- 在任何时候，主内存都是已分配块和空闲块的不相交并集。当通过释放操作产生相邻的空闲块时，根据分配器的策略，它们可能会也可能不会被合并。在向一个空闲块中进行分配时，如果该空闲块严格大于请求的大小，分配器可能会将该空闲块分割成一个已分配块和一个剩余的空闲块。\n- 在固定分区分配中，内存被预先划分为一组固定的分区，这些分区在运行时大小不变；进程占用整个分区，空闲块就是整个空闲分区。在可变分区分配中，内存开始时是一个连续的空闲区域，由分配器动态地进行分割和合并。首次适应（First-fit）算法选择地址顺序上第一个能满足请求的空闲块；最佳适应（best-fit）算法在所有能满足请求的空闲块中选择最小的一个。\n\n假设有以下初始条件和请求序列。\n\n- 最初，大小为 $M = 200$ 的整个内存是一个连续的空闲块。\n- 按时间顺序发生一系列请求和事件，其进程标识符和大小如下：\n  1) 分配大小为 $50$ 的 $P_1$，\n  2) 分配大小为 $40$ 的 $P_2$，\n  3) 分配大小为 $30$ 的 $P_3$，\n  4) 分配大小为 $25$ 的 $P_4$，\n  5) 释放 $P_3$，\n  6) 分配大小为 $20$ 的 $P_5$，\n  7) 分配大小为 $10$ 的 $P_7$，\n  8) 分配大小为 $20$ 的 $P_6$，\n  9) 释放 $P_2$，\n  10) 释放 $P_5$，\n  11) 分配大小为 $30$ 的 $P_8$。\n\n在事件 $11$ 发生后立即进行的内存转储显示，空闲列表（按地址递增顺序）恰好包含两个空闲块，其大小构成的多重集为 $\\{30, 35\\}$。\n\n根据上述基本定义以及观察到的初始和最终条件，下列哪种分配器特征与观察结果最一致？\n\nA. 固定分区分配（任何变体）\n\nB. 可变分区分配，采用首次适应算法，并在释放时立即合并相邻的空闲块\n\nC. 可变分区分配，采用最佳适应算法，并在释放时立即合并相邻的空闲块\n\nD. 可变分区分配，采用首次适应算法，但在释放时不进行合并\n\nE. 信息不足，无法区分首次适应和最佳适应，也无法区分固定分区和可变分区", "solution": "### 第1步：提取已知条件\n问题提供了以下信息：\n- **内存模型**：一个单一的主内存空间，是已分配块和空闲块（碎片）的不相交并集。空闲块的列表按地址递增顺序维护。\n- **分配/释放规则**：\n    - 向一个比请求大的空闲块中分配时，可能会分割该空闲块。\n    - 释放一个块可能会也可能不会导致与相邻的空闲块合并（coalescing）。\n- **分配器定义**：\n    - **固定分区**：内存被*预先*划分为固定大小的分区。进程占用整个分区。空闲块就是整个分区。\n    - **可变分区**：内存开始时是一个大的空闲块，并被动态地分割和合并。\n    - **首次适应**：选择地址顺序上第一个足够大的空闲块以满足请求。\n    - **最佳适应**：选择足够大以满足请求的最小空闲块。\n- **初始条件**：\n    - 总内存大小 $M = 200$。\n    - 整个内存最初是一个空闲块：`(address=0, size=200)`。\n- **事件序列**：\n    1. 分配大小为 $50$ 的 $P_1$。\n    2. 分配大小为 $40$ 的 $P_2$。\n    3. 分配大小为 $30$ 的 $P_3$。\n    4. 分配大小为 $25$ 的 $P_4$。\n    5. 释放 $P_3$。\n    6. 分配大小为 $20$ 的 $P_5$。\n    7. 分配大小为 $10$ 的 $P_7$。\n    8. 分配大小为 $20$ 的 $P_6$。\n    9. 释放 $P_2$。\n    10. 释放 $P_5$。\n    11. 分配大小为 $30$ 的 $P_8$。\n- **最终观察结果**：事件 11 之后，空闲列表恰好包含两个空闲块，其大小由多重集 $\\{30, 35\\}$ 给出。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据**：该问题使用了操作系统领域的标准、明确定义的概念，特别是内存管理算法（固定分区与可变分区，首次适应，最佳适应，合并）。这些概念在计算机科学教育的背景下是内部一致且事实正确的。\n- **适定性**：问题提供了一个初始状态，一个定义明确的操作序列，以及一个最终状态。它要求确定哪种给定的分配策略能够产生这个结果。这是一个可解的反向工程或验证问题。通过为每个策略系统地模拟过程，可以找到一个唯一的答案。\n- **客观性**：问题使用精确的技术语言陈述，没有主观或模糊的术语。\n问题是自洽的，不包含矛盾信息。分配和释放的总内存量与最终状态一致。净分配的内存为 $(50+40+30+25+20+10+20+30) - (30+40+20) = 225 - 90 = 135$。总的空闲空间应为 $200 - 135 = 65$。最终观察到的空闲块大小为 $30$ 和 $35$，它们的和是 $30+35=65$。这个内部一致性检查通过了。\n\n### 第3步：结论与行动\n问题陈述是**有效的**。我将通过为每种提议的分配策略模拟事件序列来推导解决方案。\n\n### 正确答案的推导\n\n我将跟踪整个事件序列中内存空闲列表的状态。空闲列表是一个 `(地址, 大小)` 元组的有序列表。\n\n**初始状态：** 内存为 `[0, 199]`。\n`空闲列表: [(0, 200)]`\n\n**事件 1-4：初始分配**\n由于只有一个空闲块，首次适应和最佳适应的行为相同。\n1.  **分配 $P_1(50)$：** $P_1$ 占用 `[0, 49]`。`空闲列表: [(50, 150)]`\n2.  **分配 $P_2(40)$：** $P_2$ 占用 `[50, 89]`。`空闲列表: [(90, 110)]`\n3.  **分配 $P_3(30)$：** $P_3$ 占用 `[90, 119]`。`空闲列表: [(120, 80)]`\n4.  **分配 $P_4(25)$：** $P_4$ 占用 `[120, 144]`。`空闲列表: [(145, 55)]`\n\n**事件 5：释放 $P_3$**\n-   位于 `[90, 119]` (大小 $30$) 的 $P_3$ 块被释放。它被已分配的块（位于 `[50, 89]` 的 $P_2$ 和位于 `[120, 144]` 的 $P_4$）包围，所以不会发生合并。\n-   `空闲列表: [(90, 30), (145, 55)]` (按地址排序)\n\n**事件 6：分配 $P_5(20)$**\n-   请求大小为 $20$。空闲块为 `(90, 30)` 和 `(145, 55)`。\n-   **首次适应：** 选择第一个足够的空闲块，即 `(90, 30)`。\n-   **最佳适应：** 选择最小的足够空闲块。由于 $30  55$，它也选择 `(90, 30)`。\n-   两种策略都将 $P_5$ 分配到 `[90, 109]`，分割了该空闲块。剩余的空闲块是 `(90+20, 30-20) = (110, 10)`。\n-   `空闲列表: [(110, 10), (145, 55)]`\n\n**事件 7：分配 $P_7(10)$**\n-   请求大小为 $10$。空闲块为 `(110, 10)` 和 `(145, 55)`。\n-   **首次适应：** 选择 `(110, 10)`。\n-   **最佳适应：** 选择 `(110, 10)` 因为它是最小的足够空闲块。\n-   两种策略都将 $P_7$ 分配到 `[110, 119]`。这是一个精确匹配，所以空闲块被完全消耗。\n-   `空闲列表: [(145, 55)]`\n\n**事件 8：分配 $P_6(20)$**\n-   请求大小为 $20$。只有一个空闲块，即 `(145, 55)`。\n-   $P_6$ 被分配到 `[145, 164]`，分割了该空闲块。剩余的空闲块是 `(145+20, 55-20) = (165, 35)`。\n-   `空闲列表: [(165, 35)]`\n\n此时，可变分区分配的策略尚未出现分歧。已分配块的内存布局是：\n$P_1[0,49]$, $P_2[50,89]$, $P_5[90,109]$, $P_7[110,119]$, $P_4[120,144]$, $P_6[145,164]$。\n\n**事件 9：释放 $P_2$**\n-   位于 `[50, 89]` (大小 $40$) 的 $P_2$ 块被释放。它与已分配的块 $P_1$ 和 $P_5$ 相邻。不可能进行合并。\n-   `空闲列表: [(50, 40), (165, 35)]`\n\n**事件 10：释放 $P_5$**\n-   位于 `[90, 109]` (大小 $20$) 的 $P_5$ 块被释放。\n-   位于 `[90, 109]` 的新空闲块与位于 `[50, 89]` 的现有空闲块紧邻。\n-   在这里，合并策略变得至关重要。\n\n-   **立即合并的情况（选项 B, C）：** 两个相邻的空闲块 `(50, 40)` 和 `(90, 20)` 被合并成一个更大的空闲块：`(50, 40+20) = (50, 60)`。\n    -   `空闲列表: [(50, 60), (165, 35)]`\n-   **不合并的情况（选项 D）：** 新的空闲块被直接添加到列表中。\n    -   `空闲列表: [(50, 40), (90, 20), (165, 35)]`\n\n**事件 11：分配 $P_8(30)$**\n-   我们现在为不同的策略测试最后一步。\n\n### 逐个选项分析\n\n**A. 固定分区分配（任何变体）**\n问题指出，在固定分区分配中，内存被*预先*划分为固定大小的分区。然而，初始条件是内存是一个大小为 $200$ 的连续空闲块。这符合可变分区分配的定义，而不是固定分区。此外，目标是最终得到大小为 $30$ 和 $35$ 的空闲块。在固定分区中，空闲块的大小是预先确定的，不会改变。通过分割动态创建具有这些特定大小的空闲块是可变分区分配的特征。因此，固定分区分配与问题设置不一致。\n**结论：不正确**\n\n**B. 可变分区分配，采用首次适应算法，并在释放时立即合并相邻的空闲块**\n-   从事件 10 开始，此策略的状态是 `空闲列表: [(50, 60), (165, 35)]`。\n-   事件 11：分配 $P_8(30)$。使用首次适应算法，分配器按地址顺序检查列表。\n-   第一个空闲块 `(50, 60)` 是足够的 ($60 \\ge 30$)。它被选中。\n-   $P_8$ 被分配到 `[50, 79]`。空闲块被分割，在地址 $50+30=80$ 处留下一个大小为 $60-30=30$ 的剩余空闲块。\n-   新的 `空闲列表` 是 `[(80, 30), (165, 35)]`。\n-   最终的空闲列表恰好包含两个空闲块，其大小构成的多重集为 $\\{30, 35\\}$。这与观察结果完全匹配。\n**结论：正确**\n\n**C. 可变分区分配，采用最佳适应算法，并在释放时立即合并相邻的空闲块**\n-   从事件 10 开始，此策略的状态是 `空闲列表: [(50, 60), (165, 35)]`。\n-   事件 11：分配 $P_8(30)$。使用最佳适应算法，分配器找到足够大的最小空闲块。可用的空闲块大小为 $60$ 和 $35$。\n-   两个空闲块都足够。最小的足够空闲块是大小为 $35$ 的那个。它被选中。\n-   $P_8$ 被分配到地址 $165$ 的空闲块。它占用空间 `[165, 194]`。剩余的空闲块大小为 $35-30=5$，地址为 $165+30=195$。\n-   新的 `空闲列表` 是 `[(50, 60), (195, 5)]`。\n-   最终的空闲列表有大小为 $\\{60, 5\\}$ 的空闲块。这与观察结果 $\\{30, 35\\}$ 不匹配。\n**结论：不正确**\n\n**D. 可变分区分配，采用首次适应算法，但在释放时不进行合并**\n-   从事件 10 开始，此策略的状态是 `空闲列表: [(50, 40), (90, 20), (165, 35)]`。\n-   事件 11：分配 $P_8(30)$。使用首次适应算法，第一个足够的空闲块是 `(50, 40)`。\n-   $P_8$ 被分配到 `[50, 79]`，在地址 $50+30=80$ 处留下一个大小为 $40-30=10$ 的剩余空闲块。\n-   新的 `空闲列表` 是 `[(80, 10), (90, 20), (165, 35)]`。\n-   最终状态有三个大小为 $\\{10, 20, 35\\}$ 的空闲块，这与观察到的“恰好两个空闲块”且大小为 $\\{30, 35\\}$ 的情况不符。\n**结论：不正确**\n\n**E. 信息不足，无法区分首次适应和最佳适应，也无法区分固定分区和可变分区**\n这是不正确的。如上所示，我们可以进行区分。选项 A（固定分区）与问题设置不一致。选项 C 和 D 导致的最终状态与观察结果相矛盾。只有选项 B 产生的最终状态与观察结果完全一致。因此，信息是充分的。\n**结论：不正确**", "answer": "$$\\boxed{B}$$", "id": "3644730"}, {"introduction": "在固定分区和可变分区之间做出选择，是操作系统设计中的一个基本决策，对系统性能有着深远影响。这个练习模拟了一个真实的混合工作负载场景，挑战你分析每种策略的长期影响。通过这个案例，你将具体地权衡固定分区方案中可预测的内部碎片与可变分区方案中潜在的、更具破坏性的外部碎片之间的利弊。[@problem_id:3644668]", "problem": "一个系统将一个大小为 $M = 128\\,\\text{KiB}$ 的连续内存池专用于一个网络子系统，该子系统表现出混合工作负载：频繁的小缓冲区分配和罕见的大会话释放与重新分配。考虑了两种分配器设计，每种设计都管理同一个内存池，并且都不允许在运行时进行压缩。\n\n- 固定分区设计 (F)：该内存池被划分为固定的、不重叠的分区，这些分区的大小或相对位置永不改变。具体来说，有 $16$ 个大小为 $4\\,\\text{KiB}$ 的小分区（槽位）（用于小缓冲区）和一个大小为 $64\\,\\text{KiB}$ 的大分区（用于大会话缓冲区）。一个请求必须完全容纳在一个分区内；小请求总是被定向到小槽位；大请求使用单个 $64\\,\\text{KiB}$ 的分区。\n- 可变分区设计 (V)：整个 $128\\,\\text{KiB}$ 是一个可变分区堆，由一个首次适应分配器管理，该分配器在释放时立即合并并且不进行压缩。每个分配请求都从一个合适的空闲块中消耗掉确切请求的大小（本问题忽略头部/对齐开销），并将任何更大的空闲块分裂成一个已分配部分和一个剩余部分。\n\n工作负载假设：\n\n- 稳态下，在任何时候都维持着 $n = 12$ 个活跃的小缓冲区，每个大小为 $s = 3\\,\\text{KiB}$，其开始和结束时间是交错的。\n- 最初，存在一个大小为 $L = 64\\,\\text{KiB}$ 的大会话分配。在时间 $t_1$，这个大会话分配被释放（一个罕见事件）。此后，小缓冲区的流转继续。在稍后的某个时间 $t_2 \\gg t_1$，大会话再次请求 $L = 64\\,\\text{KiB}$。\n\n使用以下核心定义：\n- 内部碎片是为满足请求而实际分配的内存与请求的大小之间的差值，对所有活跃的分配求和。\n- 外部碎片是指总空闲内存 $\\sum_j f_j$ 足以满足大小为 $R$ 的请求，但最大连续空闲块 $\\max_j f_j$ 小于 $R$ 的情况（因此请求因缺乏连续性而失败）。\n\n在这种情况下，以下哪些陈述是正确的？\n\nA. 在设计 F下，在稳态时（$t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区，由小缓冲区引起的总内部碎片恰好是 $12\\,\\text{KiB}$，并且如果 $64\\,\\text{KiB}$ 的分区是空闲的，那么在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求将总是成功。\n\nB. 在设计 V下，使用首次适应和立即合并，内部碎片为 $0$，并且只要总空闲内存至少为 $64\\,\\text{KiB}$，在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求保证会成功。\n\nC. 在设计 V下，即使在 $t_2$ 时的总空闲内存严格大于 $64\\,\\text{KiB}$，对 $L = 64\\,\\text{KiB}$ 的大请求也可能在稳态下失败，因为空闲空间可能被长寿命的小分配分割成不连续的碎片，其最大连续块小于 $64\\,\\text{KiB}$。\n\nD. 在设计 F下，由于固定的 $4\\,\\text{KiB}$ 槽位大小，每个小缓冲区的内部碎片会随时间无限增长，使其渐进地大于设计 V 在此工作负载下的外部碎片。\n\n选择所有适用的选项。", "solution": "### 问题验证\n\n**步骤 1：提取给定条件**\n\n问题陈述提供了以下信息：\n- 总内存池大小：$M = 128\\,\\text{KiB}$。\n- 两种设计都不允许运行时压缩。\n\n- **固定分区设计 (F):**\n    - $16$ 个大小为 $4\\,\\text{KiB}$ 的小分区。\n    - $1$ 个大小为 $64\\,\\text{KiB}$ 的大分区。\n    - 请求必须放入一个分区内。小请求使用小分区；大请求使用大分区。\n\n- **可变分区设计 (V):**\n    - 一个大小为 $128\\,\\text{KiB}$ 的可变分区堆。\n    - 分配算法：首次适应。\n    - `free` 时，立即合并。\n    - 分配开销（头部/对齐）被忽略；大小为 $S$ 的请求正好消耗 $S$。\n\n- **工作负载：**\n    - 稳态：$n = 12$ 个活跃的小缓冲区。\n    - 每个小缓冲区的大小：$s = 3\\,\\text{KiB}$。\n    - 初始状态：存在一个大小为 $L = 64\\,\\text{KiB}$ 的大会话分配。\n    - 在时间 $t_1$：$L = 64\\,\\text{KiB}$ 的分配被释放。\n    - 在时间 $t_2 \\gg t_1$：一个新的大小为 $L = 64\\,\\text{KiB}$ 的请求到达。\n\n- **定义：**\n    - 内部碎片：$\\sum (\\text{已分配大小} - \\text{请求大小})$，对所有活跃分配求和。\n    - 外部碎片：总空闲内存足以满足大小为 $R$ 的请求，但最大连续空闲块小于 $R$ 的情况。\n\n**步骤 2：使用提取的给定条件进行验证**\n\n1.  **科学依据充分：** 问题基于操作系统内存管理的基本概念，特别是固定分区和可变分区分配方案，以及相关的内部和外部碎片现象。这些概念是计算机科学课程中的标准内容。\n2.  **定义明确：** 问题是定义明确的。它提供了所有必要的量化数据（内存大小、分区数量、请求大小）和定性描述（首次适应、立即合并、交错工作负载），以便对两种设计进行严格分析。选项中提出的问题可以根据所提供的模型得到明确的回答。\n3.  **客观性：** 语言技术性强、精确且客观。\n4.  **一致性：** 参数是一致的。在设计 F 中，各分区大小之和等于总内存大小：$(16 \\times 4\\,\\text{KiB}) + 64\\,\\text{KiB} = 64\\,\\text{KiB} + 64\\,\\text{KiB} = 128\\,\\text{KiB} = M$。\n\n**步骤 3：结论与行动**\n\n问题陈述是有效的。它科学合理、自成体系、一致且定义明确。可以开始求解过程。\n\n### 求解推导\n\n这个问题要求分析两种内存分配设计，固定分区 (F) 和可变分区 (V)，在特定工作负载下的表现，并评估关于它们的碎片和分配成功率的陈述。\n\n#### 设计 F（固定分区）的分析\n\n在设计 F 中，内存被预先划分为静态分区。大小为 $s = 3\\,\\text{KiB}$ 的小请求从包含 $16$ 个槽位（每个大小为 $4\\,\\text{KiB}$）的池中得到满足。大小为 $L = 64\\,\\text{KiB}$ 的大请求从单个专用的 $64\\,\\text{KiB}$ 分区中得到满足。\n\n-   **内部碎片：** 当一个 $3\\,\\text{KiB}$ 的请求被放入一个 $4\\,\\text{KiB}$ 的分区时，已分配分区的一部分是未使用的。这就是内部碎片。\n    对于单个小缓冲区：\n    $$ \\text{内部碎片}_{\\text{小}} = (\\text{分区大小}) - (\\text{请求大小}) = 4\\,\\text{KiB} - 3\\,\\text{KiB} = 1\\,\\text{KiB} $$\n    在稳态下，有 $n = 12$ 个活跃的小缓冲区。这些缓冲区造成的总内部碎片是：\n    $$ \\text{总内部碎片}_{\\text{小}} = n \\times \\text{内部碎片}_{\\text{小}} = 12 \\times 1\\,\\text{KiB} = 12\\,\\text{KiB} $$\n\n-   **$t_2$ 时的分配成功性：**\n    在时间 $t_1$，大的 $64\\,\\text{KiB}$ 会话被释放，使得专用的 $64\\,\\text{KiB}$ 分区可用。小缓冲区的流转只发生在 $16$ 个小分区内。任何小缓冲区的分配都不能使用大分区。因此，在 $t_1$ 和 $t_2$ 之间，这个 $64\\,\\text{KiB}$ 的分区保持空闲和连续。当大小为 $L = 64\\,\\text{KiB}$ 的新请求在 $t_2$ 到达时，它将被定向到这个分区，该分区是空闲的，分配将成功。\n\n#### 设计 V（可变分区）的分析\n\n在设计 V 中，整个 $128\\,\\text{KiB}$ 池被视为一个单一的堆。使用首次适应策略从空闲块中进行分配。\n\n-   **内部碎片：** 问题陈述“每个分配请求都消耗掉确切请求的大小”。这是一个纯粹的可变分区方案的定义特征。分配的块大小与请求的大小相匹配。因此，根据这个定义，任何已分配的块*内部*都没有浪费的空间。\n    $$ \\text{内部碎片} = 0 $$\n\n-   **外部碎片与 $t_2$ 时的分配成功性**：\n    在稳态时（$t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区。\n    $$ \\text{总已分配内存} = n \\times s = 12 \\times 3\\,\\text{KiB} = 36\\,\\text{KiB} $$\n    系统中的总空闲内存是：\n    $$ \\text{总空闲内存} = M - \\text{总已分配内存} = 128\\,\\text{KiB} - 36\\,\\text{KiB} = 92\\,\\text{KiB} $$\n    在时间 $t_2$，一个大小为 $L = 64\\,\\text{KiB}$ 的请求到达。由于总空闲内存（$92\\,\\text{KiB}$）大于请求的大小（$64\\,\\text{KiB}$），理论上分配是可能的。然而，成功取决于是否存在一个*单一连续的空闲块*，其大小至少为 $64\\,\\text{KiB}$。\n    小分配和释放的“交错”流转可能导致外部碎片。在 $t_1$ 时，一个大的 $64\\,\\text{KiB}$ 连续块变为空闲。首次适应分配器在服务后续的 $3\\,\\text{KiB}$ 请求时，可能会从这个大的空闲块中切分出一些部分。如果这样一个 $3\\,\\text{KiB}$ 的分配变成长寿命的，它就会像一个“塞子”，阻止其两侧的空闲空间被合并，即使相邻的块被释放了。在足够长的时间内（$t_2 \\gg t_1$），这个过程可以将大的空闲块和堆的其余部分“撕碎”成许多更小的、不连续的空闲块。这是这类分配器的一个经典失效模式，即最大可用连续块可能变得比一个大的请求大小还要小，即使总空闲内存很充足。因此，$t_2$ 时的 $64\\,\\text{KiB}$ 请求*不*保证成功；它可能因外部碎片而失败。\n\n### 逐项分析\n\n**A. 在设计 F下，在稳态时（$t_1$ 和 $t_2$ 之间），有 $n = 12$ 个大小为 $s = 3\\,\\text{KiB}$ 的活跃小缓冲区，由小缓冲区引起的总内部碎片恰好是 $12\\,\\text{KiB}$，并且如果 $64\\,\\text{KiB}$ 的分区是空闲的，那么在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求将总是成功。**\n-   陈述的第一部分，关于内部碎片，如上计算是正确的：$12 \\times (4\\,\\text{KiB} - 3\\,\\text{KiB}) = 12\\,\\text{KiB}$。\n-   第二部分也是正确的。大分区与小缓冲区的流转是隔离的。它在 $t_1$ 被释放，并一直保持空闲直到 $t_2$ 的请求到来，保证了 $64\\,\\text{KiB}$ 分配的成功。条件“如果 $64\\,\\text{KiB}$ 的分区是空闲的”被问题的时间线所满足。\n-   **结论：正确。**\n\n**B. 在设计 V下，使用首次适应和立即合并，内部碎片为 $0$，并且只要总空闲内存至少为 $64\\,\\text{KiB}$，在 $t_2$ 时大小为 $L = 64\\,\\text{KiB}$ 的大请求保证会成功。**\n-   第一部分，“内部碎片为 $0$”，根据问题的可变分区方案定义是正确的。\n-   第二部分，“...只要总空闲内存至少为 $64\\,\\text{KiB}$，就保证成功”，这是不正确的。这个陈述忽略了外部碎片的可能性。总空闲内存是 $92\\,\\text{KiB}$，但不能保证其连续性。如果没有足够大的单个空闲块，请求可能会失败。\n-   **结论：错误。**\n\n**C. 在设计 V下，即使在 $t_2$ 时的总空闲内存严格大于 $64\\,\\text{KiB}$，对 $L = 64\\,\\text{KiB}$ 的大请求也可能在稳态下失败，因为空闲空间可能被长寿命的小分配分割成不连续的碎片，其最大连续块小于 $64\\,\\text{KiB}$。**\n-   这个陈述准确地描述了在设计 V 的背景下外部碎片的现象。正如我们的分析所确立的，在 $t_2$ 时的总空闲内存是 $92\\,\\text{KiB}$（大于 $64\\,\\text{KiB}$）。小分配的“交错”流转确实可能使堆碎片化，以至于最大的连续块小于 $64\\,\\text{KiB}$。所提供的理由是对潜在分配失败的正确解释。\n-   **结论：正确。**\n\n**D. 在设计 F下，由于固定的 $4\\,\\text{KiB}$ 槽位大小，每个小缓冲区的内部碎片会随时间无限增长，使其渐进地大于设计 V 在此工作负载下的外部碎片。**\n-   前提“每个小缓冲区的内部碎片会随时间无限增长”是错误的。对于固定分区（$4\\,\\text{KiB}$）中的任何给定小缓冲区请求（$3\\,\\text{KiB}$），内部碎片是恒定的：$4\\,\\text{KiB} - 3\\,\\text{KiB} = 1\\,\\text{KiB}$。它不随时间变化。\n-   由于前提是错误的，整个陈述无效。\n-   **结论：错误。**", "answer": "$$\\boxed{AC}$$", "id": "3644668"}]}