{"hands_on_practices": [{"introduction": "参数化算法的核心思想之一是通过一种称为“有界深度搜索树”的策略来控制组合爆炸。这种方法通过将递归深度限制为参数 $k$ 来系统地探索解空间。这个问题 [@problem_id:1434298] 将指导你分析一个用于解决集合覆盖问题的递归算法，通过估算其搜索树的大小，你将亲身体会到算法的运行时间如何能被表示为一个仅与参数 $k$ 相关的函数与一个输入规模的多项式函数的乘积，这正是固定参数可解（FPT）算法的标志。", "problem": "命中集问题（Hitting Set problem）是计算机科学中的一个经典问题。该问题的一个实例由一个元素全集 $U$、一个由 $U$ 的非空子集组成的集合 $C = \\{S_1, S_2, \\ldots, S_m\\}$ 以及一个正整数参数 $k$ 定义。问题是确定是否存在一个大小至多为 $k$ 的*命中集* $H \\subseteq U$（即 $|H| \\le k$），使得 $H$ “命中”$C$ 中的每一个集合（即对于所有的 $i=1, \\ldots, m$，都有 $H \\cap S_i \\ne \\emptyset$）。\n\n考虑以下为解决命中集问题而设计的递归算法，该算法以解的大小 $k$ 为参数。\n\n**算法 `RecursiveHittingSet(C_current, k_rem)`：**\n1.  如果集合 `C_current` 为空，意味着所有原始集合都已被命中。返回 `true`。\n2.  如果 `k_rem` 为 0 且 `C_current` 不为空，说明用于命中集的预算已耗尽，但仍有集合未被命中。返回 `false`。\n3.  从 `C_current` 中任选一个集合 $S$。\n4.  对于 $S$ 中的每个元素 $x$：\n    a. 令 `C_next` 为 `C_current` 中所有不包含元素 $x$ 的集合构成的子集。\n    b. 进行递归调用：`RecursiveHittingSet(C_next, k_rem - 1)`。\n    c. 如果该递归调用返回 `true`，则说明已找到一个有效的命中集。停止并返回 `true`。\n5.  如果循环结束而没有任何递归调用返回 `true`，则说明在给定的预算内无法命中集合 $S$ 及剩余集合。返回 `false`。\n\n该算法的执行过程可以看作一棵搜索树，其中每个节点对应一次递归调用。根节点代表初始调用，一个节点会为该步骤中选定的集合 $S$ 内的每个元素 $x$ 创建一个子节点，从而进行分支。\n\n令 $d_{max}$ 为原始输入集合 $C$ 中最大集合的大小。在最坏情况分析中，假设算法可能总是需要处理大小最多为 $d_{max}$ 的集合。下列哪个表达式给出了该搜索树中节点总数的关于参数 $k$ 和最大集合大小 $d_{max}$ 的最紧上界？\n\nA. $O(k \\cdot d_{max})$\n\nB. $O(k^{d_{max}})$\n\nC. $O((d_{max})^k)$\n\nD. $O(d_{max} \\log k)$", "solution": "在每次递归调用中，算法选择一个集合 $S$（其中 $|S| \\le d_{max}$），并为 $S$ 中的每个元素 $x$ 分支一次。在每个分支中，它将剩余预算减一，即 $k_{rem} \\mapsto k_{rem}-1$，并移除所有包含 $x$ 的集合。因此，在最坏情况下：\n- 每个节点的分支因子最多为 $d_{max}$。\n- 搜索树的深度最多为 $k$，因为在进行 $k$ 次选择后，如果仍有集合未被命中，步骤2中的参数检查将被触发。\n\n令 $T(k)$ 表示当剩余预算为 $k$ 时搜索树中的最大节点数。那么，最坏情况下的递推关系满足\n$$\nT(k) \\le 1 + d_{max} \\, T(k-1), \\quad T(0) \\le 1.\n$$\n展开该递推式可得\n$$\nT(k) \\le \\sum_{i=0}^{k} d_{max}^{i} = \\frac{d_{max}^{k+1}-1}{d_{max}-1} = O\\!\\left(d_{max}^{k}\\right) \\quad \\text{for } d_{max} \\ge 2.\n$$\n对于 $d_{max}=1$ 的平凡情况，节点数是 $O(k)$。表达式 $O((d_{max})^k)$ 准确地描述了当 $d_{max} \\ge 2$ 时的情况，这代表了问题的主要复杂性。\n\n此外，这个界在常数因子内是紧的：例如，考虑 $k+1$ 个两两不交且大小均为 $d_{max}$ 的集合，并要求一个大小至多为 $k$ 的命中集。算法在得出结论之前可能会探索一个深度为 $k$ 的完整 $d_{max}$ 叉树，从而产生 $\\Theta\\!\\left(d_{max}^{k}\\right)$ 个节点。\n\n在这些选项中，与此行为匹配的最紧上界是 $O\\!\\left((d_{max})^{k}\\right)$。", "answer": "$$\\boxed{C}$$", "id": "1434298"}, {"introduction": "在计算复杂性领域，我们不总需要为每个新问题都从零开始设计算法。参数化归约是一种强大的技术，它允许我们将一个问题转化为另一个已知问题，从而利用现有的求解器。这个问题 [@problem_id:1434317] 让你亲手构造一个从经典的 $k$-顶点覆盖问题到 $k$-有界可满足性问题的归约，通过这个练习，你将理解如何建立不同问题实例之间的精确对应关系，这是对问题进行分类和理解其内在难度的关键一步。", "problem": "一个工程团队正在处理一个网络监控问题。这个问题被称为 $k$-VERTEX-COVER，其目标是确定一个给定的网络图 $G=(V,E)$ 是否可以通过在节点子集 $V' \\subseteq V$ 上放置最多 $k$ 个传感器来进行“监控”，使得每条链接 $(u, v) \\in E$ 在其端点 $u$ 或 $v$ 上至少有一个传感器。\n\n该团队只能使用一个专门的求解器，该求解器用于解决一种名为 $k$-BOUNDED-SAT 的不同类型问题。该求解器接受一个合取范式 (CNF) 的布尔公式 $\\phi$——即一组子句的合取 (AND)，其中每个子句是文字的析取 (OR)——以及一个整数 $k$。它判断是否存在一个 $\\phi$ 的满足真值指派，其中最多有 $k$ 个变量被设为 TRUE。\n\n为了使用他们的求解器，团队需要将 $k$-VERTEX-COVER 的任何实例 $(G, k)$ 转换为 $k$-BOUNDED-SAT 的一个实例 $(\\phi, k)$。转换过程如下：\n1. 对于图中的每个顶点 $v \\in V$，创建一个唯一的布尔变量 $x_v$。\n2. 对于图中的每条边 $(u, v) \\in E$，使用变量 $x_u$ 和 $x_v$ 构造一个单独的子句。\n3. 最终的公式 $\\phi$ 是在步骤 2 中生成的所有子句的合取。\n\n此转换的设计具有以下性质：图 $G$ 存在一个大小最多为 $k$ 的顶点覆盖，当且仅当生成的公式 $\\phi$ 存在一个最多有 $k$ 个变量被设为 TRUE 的满足赋值。\n\n考虑一个特定的图 $G$，其顶点集为 $V = \\{a, b, c, d\\}$，边集为 $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$。根据所述的转换规则，以下哪个 CNF 公式是正确的输出 $\\phi$？与顶点 $a, b, c, d$ 对应的变量分别为 $x_a, x_b, x_c, x_d$。\n\nA. $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$\n\nB. $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$\n\nC. $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$\n\nD. $(x_a \\leftrightarrow x_b) \\land (x_b \\leftrightarrow x_c) \\land (x_c \\leftrightarrow x_d) \\land (x_d \\leftrightarrow x_a)$\n\nE. $(x_a \\land x_b \\land x_c \\land x_d)$", "solution": "问题要求我们根据所描述的转换规则，从一个给定的图 $G=(V, E)$ 构建一个特定的合取范式 (CNF) 公式 $\\phi$。这个转换在 $k$-VERTEX-COVER 问题和 $k$-BOUNDED-SAT 问题之间架起了一座桥梁。\n\n转换的核心思想是在两个问题的元素之间建立直接的对应关系。顶点 $v$ 属于顶点覆盖，被映射为其对应的布尔变量 $x_v$ 被赋值为 TRUE。大小约束 $k$ 对两个问题保持不变。\n\n顶点覆盖 $V'$ 的定义属性是，对于每条边 $(u, v) \\in E$，其至少一个端点必须在覆盖集中。用集合论的符号表示，即 $u \\in V'$ 或 $v \\in V'$。\n\n利用已建立的对应关系，条件“$u \\in V'$ 或 $v \\in V'$”被转换为逻辑条件“$x_u$ 为 TRUE 或 $x_v$ 为 TRUE”。这正是逻辑析取 $(x_u \\lor x_v)$。要成为一个有效的顶点覆盖，这个条件必须对图中的*每*条边都成立。\n\n该转换通过同时确保所有边都满足此属性来构造最终公式 $\\phi$。它的做法是为每条边 $(u, v) \\in E$ 创建一个形如 $(x_u \\lor x_v)$ 的子句。最终的公式 $\\phi$ 是所有这些子句的合取（逻辑与），这是 CNF 公式的要求。因此，转换的一般形式是：\n$$ \\phi = \\bigwedge_{(u,v) \\in E} (x_u \\lor x_v) $$\n\n现在，我们将这个一般规则应用于问题中给出的具体实例。\n图为 $G=(V,E)$，其中：\n- 顶点集为 $V = \\{a, b, c, d\\}$。\n- 边集为 $E = \\{(a, b), (b, c), (c, d), (d, a)\\}$。\n\n对应的布尔变量是 $x_a, x_b, x_c, x_d$。我们为 $E$ 中的每条边生成一个子句：\n1. 边 $(a, b)$ 产生子句 $(x_a \\lor x_b)$。\n2. 边 $(b, c)$ 产生子句 $(x_b \\lor x_c)$。\n3. 边 $(c, d)$ 产生子句 $(x_c \\lor x_d)$。\n4. 边 $(d, a)$ 产生子句 $(x_d \\lor x_a)$。\n\n最终的公式 $\\phi$ 是这四个子句的合取：\n$$ \\phi = (x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a) $$\n\n让我们将这个结果与给定的选项进行比较：\n- A: $(x_a \\land x_b) \\lor (x_b \\land x_c) \\lor (x_c \\land x_d) \\lor (x_d \\land x_a)$ 是析取范式 (DNF)，而不是 CNF。它错误地交换了 AND 和 OR 的角色。\n- B: $(\\neg x_a \\lor \\neg x_b) \\land (\\neg x_b \\lor \\neg x_c) \\land (\\neg x_c \\lor \\neg x_d) \\land (\\neg x_d \\lor \\neg x_a)$。子句 $(\\neg x_u \\lor \\neg x_v)$ 等价于 $\\neg(x_u \\land x_v)$，意味着 $u$ 和 $v$ 不能同时在所选集合中。这对应于独立集 (Independent Set) 的定义，而不是顶点覆盖 (Vertex Cover)。\n- C: $(x_a \\lor x_b) \\land (x_b \\lor x_c) \\land (x_c \\lor x_d) \\land (x_d \\lor x_a)$。这与我们推导出的公式完全匹配。\n- D: 这个选项使用了双条件 ($\\leftrightarrow$)，这不属于所描述的转换逻辑。\n- E: 这个选项是一个单一子句，这意味着所有边都以一种特定方式连接到所有顶点，但这对于给定的图是不成立的。只有当问题可以简化为单个巨大的 OR 子句时，它才可能是正确的，但情况并非如此。\n\n因此，正确的 CNF 公式在选项 C 中给出。", "answer": "$$\\boxed{C}$$", "id": "1434317"}, {"introduction": "核化是参数化算法设计中的另一个基石，其目标是在求解之前，将一个大的问题实例压缩成一个等价的、但规模小得多的“问题核”，其大小仅依赖于参数 $k$。实现核化的一个常用技巧是识别并处理问题中的“强制选择”，即那些必须属于任何有效解的元素。这个问题 [@problem_id:1434348] 提供了一个具体的顶点覆盖实例，让你在寻找最小解的过程中，练习识别哪些顶点是必不可少的，从而体验核化思想的初步应用。", "problem": "在计算复杂性理论中，顶点覆盖问题是一个经典的判定问题。给定一个无向图 $G=(V, E)$，其中 $V$ 是顶点集，$E$ 是边集，以及一个正整数参数 $k$，顶点覆盖是顶点集的一个子集 $S \\subseteq V$，使得对于每条边 $(u, v) \\in E$，至少有一个顶点 $u$ 或 $v$ 在 $S$ 中。该问题询问是否存在一个大小小于或等于 $k$ 的顶点覆盖。\n\n考虑这个问题的一个具体实例，该实例的图代表一个小型的计算机网络。顶点（网络中的节点）集合为 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6, v_7, v_8\\}$。边（直接连接）集合为 $E = \\{(v_1, v_2), (v_1, v_3), (v_1, v_4), (v_1, v_5), (v_2, v_6), (v_3, v_7), (v_4, v_8)\\}$。\n\n你的任务是找到一个最小的监控节点集合，这对应于找到一个顶点覆盖。你的监控预算允许你在最多 $k=4$ 个节点上放置传感器。为了简化解的搜索过程，你首先想要识别出任何关键节点，即那些在大小至多为 $k$ 的*任何*有效顶点覆盖中都*必须*包含的节点。\n\n对于给定的图，以下哪个集合恰好包含了在任何大小至多为4的顶点覆盖中都必须包含的顶点？\n\nA. $\\{v_1\\}$\n\nB. $\\{v_2, v_3, v_4\\}$\n\nC. $\\{v_6, v_7, v_8\\}$\n\nD. $\\{v_1, v_5\\}$\n\nE. 没有哪个顶点能保证存在于每个可能的解中。", "solution": "一个顶点覆盖 $C \\subseteq V$ 必须包含每条边的至少一个端点。考虑匹配 $M=\\{(v_1,v_5),(v_2,v_6),(v_3,v_7),(v_4,v_8)\\}$。这四条边是两两不相交的，所以 $|M|=4$。任何顶点覆盖都必须包含 $M$ 中每条边的至少一个端点，因此任何顶点覆盖的大小至少为 $4$。\n\n展示大小为 $4$ 的顶点覆盖以证明其最优性：\n1) 包含 $v_1$：那么边 $(v_1,v_2),(v_1,v_3),(v_1,v_4),(v_1,v_5)$ 都被 $v_1$ 覆盖。剩下的边 $(v_2,v_6),(v_3,v_7),(v_4,v_8)$ 是不相交的，所以我们必须从每条边中恰好选择一个端点，从而得到形如 $\\{v_1\\}\\cup\\{x_2,x_3,x_4\\}$ 的覆盖，其中 $x_2\\in\\{v_2,v_6\\}$, $x_3\\in\\{v_3,v_7\\}$, $x_4\\in\\{v_4,v_8\\}$，它们的大小都是 $4$。\n\n2) 不包含 $v_1$：为了覆盖 $(v_1,v_2),(v_1,v_3),(v_1,v_4),(v_1,v_5)$，我们必须包含 $v_2,v_3,v_4,v_5$。这个集合也覆盖了 $(v_2,v_6),(v_3,v_7),(v_4,v_8)$，所以 $\\{v_2,v_3,v_4,v_5\\}$ 是一个大小为 $4$ 的顶点覆盖。\n\n因此，最小顶点覆盖的大小恰好是 $4$，而大小至多为 $4$ 的顶点覆盖正是这些大小为 $4$ 的覆盖。\n\n要找出必须存在于每个此类覆盖中的顶点，我们测试每个候选者：\n- $v_1$ 不是必须的，因为 $\\{v_2,v_3,v_4,v_5\\}$ 是一个不包含 $v_1$ 的大小为 $4$ 的覆盖，所以 A 是错误的。\n- $\\{v_2,v_3,v_4\\}$ 并非都是必须的，因为 $\\{v_1,v_6,v_7,v_8\\}$ 是一个大小为 $4$ 的覆盖，它省略了 $v_2,v_3,v_4$ 中的每一个，所以 B 是错误的。\n- $\\{v_6,v_7,v_8\\}$ 并非都是必须的，因为 $\\{v_1,v_2,v_3,v_4\\}$ 是一个大小为 $4$ 的覆盖，它省略了 $v_6,v_7,v_8$ 中的每一个，所以 C 是错误的。\n- $\\{v_1,v_5\\}$ 并非都是必须的，因为 $\\{v_1,v_2,v_3,v_4\\}$ 是一个大小为 $4$ 的覆盖，它省略了 $v_5$，所以 D 是错误的。\n\n因此，没有哪个顶点能保证存在于每个大小至多为 $4$ 的顶点覆盖中。正确选项是 E。", "answer": "$$\\boxed{E}$$", "id": "1434348"}]}