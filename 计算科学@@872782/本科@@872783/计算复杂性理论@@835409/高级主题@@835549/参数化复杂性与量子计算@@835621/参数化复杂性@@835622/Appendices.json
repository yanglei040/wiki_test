{"hands_on_practices": [{"introduction": "理论是实践的基石。在深入研究参数化算法的设计技术之前，首要任务是能够准确识别一个算法是否属于固定参数可解（FPT）的范畴。这个问题 [@problem_id:1434065] 直接考察了FPT的定义，帮助我们澄清一个常见的误解：对参数 $k$ 的依赖函数 $f(k)$ 可以是任何可计算函数，无论其增长速度有多快，只要它与输入规模 $n$ 无关即可。", "problem": "一个计算生物学家团队正在开发一种名为“Motif-Interaction-Finder”的新算法，用于分析复杂的基因组数据。该算法的输入是一个长度为 $n$ 的DNA序列和一组包含 $k$ 个不同基因基序的集合，其相互作用有待研究。经过理论分析，该团队确定其算法的最坏情况时间复杂度为 $O(2^k k! \\cdot n^3)$。\n\n该团队需要根据参数化复杂性的原理对他们的算法进行分类。一个算法，如果其在大小为 $n$ 的输入上的运行时间可以被 $f(k) \\cdot p(n)$ 所限定，那么它就被定义为关于参数 $k$ 是固定参数可解的（Fixed-Parameter Tractable, FPT）。其中 $f$ 是任何只依赖于参数 $k$ 的可计算函数，而 $p(n)$ 是输入大小 $n$ 的一个多项式函数。\n\n根据给定的运行时间和FPT的定义，以下哪个陈述是关于“Motif-Interaction-Finder”算法相对于参数 $k$ 的正确分类？\n\nA. 该算法不是FPT，因为关于 $k$ 的函数 $2^k k!$ 是超指数增长的，因此不是一个可计算函数。\n\nB. 该算法是FPT，因为其运行时间可以分解为一个函数 $f(k) = 2^k k!$ 和一个多项式函数 $p(n) = n^3$。\n\nC. 该算法不是FPT，因为要使一个算法是固定参数可解的，其对 $k$ 的依赖性必须最多是指数级的（例如 $c^k$），而 $k!$ 项违反了这一点。\n\nD. 该算法仅当参数 $k$ 小于输入大小 $n$ 时才是FPT。\n\nE. 该算法不是FPT，因为整个运行时间表达式 $2^k k! \\cdot n^3$ 不是一个关于 $n$ 和 $k$ 的多项式。", "solution": "我们给定的运行时间界限为 $T(n,k)=O(2^{k} k! \\cdot n^{3})$，以及FPT的定义：一个算法关于参数 $k$ 是固定参数可解的，如果存在一个仅依赖于 $k$ 的可计算函数 $f$ 和一个多项式 $p$，使得对于所有大小为 $n$ 的输入，都有 $T(n,k) \\leq f(k) \\cdot p(n)$。\n\n为了对给定的算法进行分类，我们观察到其运行时间可以分解为\n$$\nT(n,k)=O\\big(f(k)\\cdot p(n)\\big),\n$$\n其中\n$$\nf(k)=2^{k} k! \\quad \\text{和} \\quad p(n)=n^{3}。\n$$\n函数 $f(k)=2^{k} k!$ 仅依赖于 $k$ 并且是可计算的，因为 $k\\mapsto 2^{k}$ 和 $k\\mapsto k!$ 都是可计算的，而可计算函数的乘积也是可计算的。因子 $p(n)=n^{3}$ 是一个关于 $n$ 的多项式。因此，根据FPT的定义，该算法关于参数 $k$ 是固定参数可解的。\n\n现在评估各个选项：\n- A 是错误的，因为 $2^{k} k!$ 是一个可计算函数；其增长率不影响可计算性。\n- B 是正确的，因为运行时间可以分解为 $f(k)=2^{k} k!$ 和 $p(n)=n^{3}$，这符合FPT的形式。\n- C 是错误的，因为FPT允许对 $k$ 有任何可计算的依赖关系，而不仅仅是最多指数级的；阶乘是被允许的。\n- D 是错误的，因为FPT分类不要求任何诸如 $k<n$ 的关系。\n- E 是错误的，因为FPT算法的运行时间不需要是关于 $n$ 和 $k$ 的多项式；它只需要是 $n$ 的多项式乘以一个关于 $k$ 的函数。", "answer": "$$\\boxed{B}$$", "id": "1434065"}, {"introduction": "核化（Kernelization）是设计FPT算法的核心技术之一，其思想是通过一系列在多项式时间内执行的“预处理规则”来压缩问题实例。这些规则必须是“安全”的，即不能改变问题的最终答案。通过这个练习 [@problem_id:1434062]，我们将亲手验证一个为“$k$-不相交三角形”问题设计的预处理规则的安全性，这有助于我们理解如何通过精简数据来隔离问题的核心难度。", "problem": "在计算复杂性理论中，尤其是在参数化算法的研究中，一个常用技术是应用预处理规则来简化问题实例。如果将一条规则应用于实例 $(I, k)$ 后，能得到一个新的、更小的实例 $(I', k')$，并且原始实例有解当且仅当新实例有解，那么这条规则被认为是“安全”的。\n\n考虑 **$k$-不交三角形** 问题：\n\n**输入：**一个无向图 $G = (V, E)$ 和一个正整数 $k$。\n**问题：**$G$ 是否包含一个由 $k$ 个顶点不交的三角形组成的集合（即，任意两个三角形没有公共顶点）？\n\n针对此问题，提出一条预处理规则如下：\n\n**规则：**如果存在一个顶点 $v \\in V$，其度 $\\text{deg}(v)$ 严格小于2，则从图中移除 $v$。新实例变为 $(G - \\{v\\}, k)$。\n\n以下哪个陈述为这条规则对于 $k$-不交三角形问题是安全的提供了最完整和最正确的理由？\n\nA. 要成为三角形的一个顶点，该顶点必须与另外两个自身也相连的顶点相连。这意味着参与构成三角形的任何顶点，其度必须至少为2。因此，度小于2的顶点不可能成为任何三角形的一部分，移除它不会影响一个潜在的解。\n\nB. 这条规则是安全的，因为预处理的目标是减少图中的顶点和边的数量，从而使后续寻找三角形的计算成本更低，同时不改变参数 $k$。\n\nC. 度小于2的顶点通常位于图的外围。图的核心部分，即更可能找到像三角形这样的复杂结构的地方，被保留了下来。\n\nD. 度为1的顶点是叶子节点。因为三角形是一个环，而叶子节点不能是任何环的一部分，所以移除它是安全的。这个逻辑可以扩展到度为0的孤立顶点。\n\nE. 如果一个顶点 $v$ 只有一个邻居 $u$，它无法构成三角形。要使 $v$ 位于一个三角形中，它的邻居 $u$ 需要与 $v$ 的另一个邻居相邻，但 $v$ 没有其他邻居。这个论证不适用于度为0的顶点。", "solution": "要确定给定的预处理规则为何是安全的，我们必须证明原始图 $G$ 有解当且仅当修改后的图 $G' = G - \\{v\\}$ 有解，其中 $v$ 是任意一个度小于2的顶点。让我们通过证明这种双向等价性来分析这个问题。\n\n设原始问题实例为 $(G, k)$，新实例为 $(G', k)$，其中对于一个顶点 $v$ 有 $\\text{deg}_G(v)  2$， $G' = G - \\{v\\}$。\n\n**第一部分：如果 $(G, k)$ 有解，那么 $(G', k)$ 有解。**\n\n假设 $G$ 有一个解。这意味着在 $G$ 中存在一个由 $k$ 个顶点不交的三角形组成的集合 $S = \\{T_1, T_2, \\dots, T_k\\}$。\n\n现在，考虑度 $\\text{deg}_G(v)  2$ 的顶点 $v$。我们需要确定 $v$ 是否能成为 $G$ 中任何三角形的一部分。一个三角形是由三个顶点（比如 $\\{a, b, c\\}$）组成的集合，使得边 $(a, b)$、$(b, c)$ 和 $(c, a)$ 都存在于图中。任何一个顶点要成为这个三角形的一部分，它必须与另外两个顶点相连。例如，顶点 $a$ 必须有到 $b$ 和 $c$ 的边。这意味着任何在三角形内的顶点，其度必须至少为2。\n\n在我们的情况中，顶点 $v$ 的度 $\\text{deg}_G(v)  2$。这意味着它的度为0或1。\n- 如果 $\\text{deg}_G(v) = 0$，$v$ 是一个孤立顶点，没有任何边。它不可能成为任何三角形的一部分。\n- 如果 $\\text{deg}_G(v) = 1$，$v$ 恰好与另一个顶点相连。它不可能成为三角形的一部分，因为这需要至少有两条与它关联的边。\n\n由于 $v$ 不可能成为 $G$ 中任何三角形的顶点，它也不可能成为解集 $S$ 中任何三角形的一部分。因此，$S$ 中的所有 $k$ 个三角形完全由来自 $V \\setminus \\{v\\}$ 的顶点组成。这意味着一个由 $k$ 个不交三角形组成的集合 $S$ 存在于由 $V \\setminus \\{v\\}$ 导出的子图中，而这个子图正是图 $G' = G - \\{v\\}$。\n\n因此，如果 $(G, k)$ 是一个“是”实例，那么 $(G', k)$ 也是一个“是”实例。\n\n**第二部分：如果 $(G', k)$ 有解，那么 $(G, k)$ 有解。**\n\n这个方向更直接。假设 $G' = G - \\{v\\}$ 有一个解。这意味着在 $G'$ 中存在一个由 $k$ 个顶点不交的三角形组成的集合 $S = \\{T_1, T_2, \\dots, T_k\\}$。\n\n图 $G'$ 是 $G$ 的一个子图。$G'$ 中的任何边和顶点也都在 $G$ 中。因此，集合 $S$ 中的所有三角形也存在于图 $G$ 中。由于这些三角形在 $G'$ 中是顶点不交的，它们在 $G$ 中也保持顶点不交（因为 $G$ 只是增加了顶点 $v$ 及其关联的边，而这些都不属于 $S$ 中任何三角形的一部分）。\n\n因此，如果 $(G', k)$ 是一个“是”实例，那么 $(G, k)$ 也是一个“是”实例。\n\n**结论与选项评估：**\n\n既然我们已经证明了双向蕴含关系，那么该规则是安全的。证明的核心在于第一部分的论证：一个度小于2的顶点不可能成为任何三角形的一部分。让我们基于这个推理来评估给出的选项。\n\n*   **A：** 该陈述正确地指出了根本原因。一个三角形中的顶点，其度必须至少为2。因此，任何度为0或1的顶点都与任何潜在的不交三角形解无关。移除它是安全的。这是一个完整且准确的理由。\n*   **B：** 该陈述描述了预处理的*目标*（简化实例），而不是这条特定规则为何*正确*或“安全”的数学证明。\n*   **C：** 这使用了“外围”和“核心”等非正式语言。虽然直观，但这并非严谨的数学论证，也未提供形式化的理由。\n*   **D：** 该陈述对于度为1的顶点的推理是正确的（叶子节点不能在环中），但比A的论证稍欠直接。A的推理基于三角形中顶点的直接局部属性，对于这个问题而言，这比环的一般属性是更根本的论证。\n*   **E：** 该陈述正确地分析了度为1顶点的情况，但明确指出它没有涵盖度为0的顶点。规则适用于任何度*严格小于2*的顶点，因此这个理由是不完整的。\n\n因此，选项A为该规则的安全性提供了最完整和最根本的理由。", "answer": "$$\\boxed{A}$$", "id": "1434062"}, {"introduction": "除了核化，有界搜索树（Bounded Search Tree）是设计FPT算法的另一强大范式。这种方法通过递归地探索解空间来寻找答案，但其关键在于确保搜索树的规模（例如深度或分支因子）受参数 $k$ 的限制，而非总输入规模 $n$。这个问题 [@problem_id:1434030] 模拟了一个为“支配集”问题设计的搜索算法，要求我们分析其递归调用的最坏情况，从而掌握估算FPT算法运行时间的关键技巧。", "problem": "一家新的电信公司计划在某城市部署一个基站网络。该城市的布局被建模为一个图 $G=(V, E)$，其中顶点集 $V$ 代表关键位置，边集 $E$ 代表直接的通信链路。一个放置在位置 $v \\in V$ 的基站可以为 $v$ 本身及其所有直接相连的位置（其邻居）提供服务。如果一个位置本身有基站，或者与一个有基站的位置相邻，则该位置被认为是“已覆盖”的。\n\n公司希望确定是否可能通过部署至多 $k$ 个基站来覆盖城市中的所有位置。由于市政规定，任何单个位置最多只允许与其他 $\\Delta$ 个位置有直接通信链路。\n\n为解决此问题，一位工程师提出了一个递归算法。该算法的执行过程如下：\n1. 如果所有位置都已被覆盖，则算法的当前探索路径成功终止。\n2. 如果 $k$ 个基站的预算已用尽（$k=0$），但仍有位置未被覆盖，则此探索路径失败。\n3. 否则，算法会识别一个任意的未覆盖位置 $u$。为确保 $u$ 被覆盖，必须在 $u$ 或其某个邻居处放置一个基站。\n4. 接着，算法通过独立的递归调用来探索这些可能性中的每一种。对于在位置 $v$（$v$ 是 $u$ 或其邻居之一）放置基站的每一种选择，都会进行一次新的递归调用，以剩余的 $k-1$ 个基站预算来覆盖网络的其余部分。\n\n令探索路径可以终止（无论是成功还是失败）的总方式数为“结果”数。这对应于完整递归调用树中的叶子节点数量。\n\n确定结果数量的最紧凑的最坏情况上界。将您的答案表示为预算 $k$ 和最大度 $\\Delta$ 的函数。", "solution": "令 $T(k,\\Delta)$ 表示在给定预算 $k$ 的情况下，对于所有最大度不超过 $\\Delta$ 的图以及算法所做的所有选择，递归树中可能的最大结果数（叶子节点数）。\n\n在任何剩余预算 $k0$ 的递归步骤中，算法选择一个未覆盖的顶点 $u$。为了覆盖 $u$，它会对在 $\\{u\\}\\cup N(u)$ 中的一个顶点上放置基站进行分支，其中 $N(u)$ 表示 $u$ 的邻居。此步骤中的分支数量最多为 $|N(u)|+1\\leq \\Delta+1$。每个分支将预算减少 $1$，因此从此步骤开始的每个子树都受 $T(k-1,\\Delta)$ 的限制。因此，\n$$\nT(k,\\Delta)\\leq (\\Delta+1) \\cdot T(k-1,\\Delta).\n$$\n当 $k=0$ 或所有顶点都被覆盖时，递归终止。在任何一种情况下，当前节点都是一个叶子节点。因此，基本情况满足\n$$\nT(0,\\Delta)=1.\n$$\n通过展开递推关系，我们得到\n$$\nT(k,\\Delta)\\leq (\\Delta+1)^{k} \\cdot T(0,\\Delta)=(\\Delta+1)^{k}.\n$$\n\n为了证明其紧密性，我们构建一个图，该图是 $k$ 个星形图的不交并，每个星形图都同构于 $K_{1,\\Delta}$（一个度为 $\\Delta$ 的中心和 $\\Delta$ 个叶子）。如果算法总是选择一个未覆盖星形图的中心作为 $u$，那么在 $k$ 个层级的每一个层级，都恰好有 $\\Delta+1$ 个分支（在中心或该星形图的任意一个叶子上放置），并且只有在每个星形图恰好放置一个基站后，即在深度为 $k$ 时，覆盖才会完成。因此，递归树是一个深度为 $k$ 的完全 $(\\Delta+1)$-叉树，恰好产生 $(\\Delta+1)^{k}$ 个叶子节点。因此，界 $(\\Delta+1)^{k}$ 既是最坏情况下的上界，也是紧密的。", "answer": "$$\\boxed{(\\Delta+1)^{k}}$$", "id": "1434030"}]}