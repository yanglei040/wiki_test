{"hands_on_practices": [{"introduction": "多证明者交互式证明（MIP）系统的一个核心思想是利用多个相互隔离的证明者来验证一个计算声明。这个练习将我们带入一个经典场景：图着色问题。通过分析一个简单的、不可2着色的图（一个三顶点循环），我们可以亲手计算出试图欺骗验证者的证明者们所能达到的最大成功概率，这个概率被称为协议的“可靠性界限”。这个实践旨在阐明，即使面对拥有无限计算能力的证明者，验证者的巧妙设计（即隔离和随机抽查）也能有效地限制他们撒谎的能力。[@problem_id:1432453]", "problem": "在理论计算机科学领域，多证明者交互式证明 (MIP) 系统被用于验证计算声明。\n考虑一个场景，其中验证者 Vic 想要检查一个关于地铁线路图可着色性的声明。\n该线路图由站点（顶点）和它们之间的直达隧道（边）组成。\n该声明称，此线路图是“2-可着色的”，这意味着可以为每个站点分配两种颜色（比如颜色 '0' 或 '1'）中的一种，使得没有任意两个由隧道连接的站点具有相同的颜色。\n\nVic 的计算能力有限，他寻求两个全能但可能不可信的证明者 P1 和 P2 的帮助。\n证明者们可以事先协调他们的策略，但在协议执行期间，他们被隔离在不同的房间里，无法进行交流。\n\n所讨论的特定地铁线路图是“Tri-Loop”，它由 A、B、C 三个站点组成。\n有隧道连接 A 和 B、B 和 C、以及 C 和 A，形成一个闭环。\n众所周知，这张线路图不是 2-可着色的。\n然而，证明者们会试图串通来欺骗 Vic，让他相信这张图是 2-可着色的。\n\nVic 采用以下单轮协议：\n1.  Vic 秘密地抛掷一枚均匀的硬币。\n2.  **如果硬币正面朝上（边测试）：** Vic 从三条隧道（边）中均匀随机地选择一条。假设所选隧道连接站点 $u$ 和 $v$。Vic 将站点 $u$ 发送给 P1，将站点 $v$ 发送给 P2。Vic 从 P1 收到颜色 $c_1$，从 P2 收到颜色 $c_2$。Vic 当且仅当 $c_1 \\neq c_2$ 时接受。\n3.  **如果硬币反面朝上（点测试）：** Vic 从三个站点（顶点）中均匀随机地选择一个，比如说 $w$。Vic 将站点 $w$ 同时发送给 P1 和 P2。Vic 从 P1 收到颜色 $c_1$，从 P2 收到颜色 $c_2$。Vic 当且仅当 $c_1 = c_2$ 时接受。\n\n假设证明者们设计了一个最优策略来最大化他们成功的机会，那么 Vic 接受“Tri-Loop”线路图是 2-可着色这一错误声明的最大概率是多少？请用最简分数表示你的答案。", "solution": "我们在不失一般性的前提下，用确定性响应函数来为每个证明者的单轮行为建模。\n这是因为 Vic 的查询是从一个固定分布中抽取的，并且接受概率在策略上是线性的；因此，任何概率性策略都是确定性策略的凸组合，而最优值在某个极点（确定性策略）上达到。\n\n设顶点集为 $\\{A,B,C\\}$。将证明者的确定性策略定义为函数 $f_{1},f_{2}:\\{A,B,C\\}\\to\\{0,1\\}$。记作\n$$\na_{X}=f_{1}(X),\\quad b_{X}=f_{2}(X)\\quad\\text{for }X\\in\\{A,B,C\\}.\n$$\n在边测试下（概率为 $\\frac{1}{2}$），Vic 均匀地选择三条边中的一条；我们用固定的方向 $(A,B)$、$(B,C)$、$(C,A)$ 来标记它们。\n对于边 $(u,v)$，Vic 当且仅当 $a_{u}\\neq b_{v}$ 时接受。\n在点测试下（概率为 $\\frac{1}{2}$），Vic 均匀地选择三个顶点 $w$ 中的一个，并当且仅当 $a_{w}=b_{w}$ 时接受。\n\n令\n$$\nS_{\\text{edge}}= \\mathbf{1}[a_{A}\\neq b_{B}] + \\mathbf{1}[a_{B}\\neq b_{C}] + \\mathbf{1}[a_{C}\\neq b_{A}],\n$$\n$$\nS_{\\text{vert}}= \\mathbf{1}[a_{A}=b_{A}] + \\mathbf{1}[a_{B}=b_{B}] + \\mathbf{1}[a_{C}=b_{C}],\n$$\n其中 $\\mathbf{1}[\\cdot]$ 是指示函数（当条件成立时值为 $1$，否则为 $0$）。接受概率为\n$$\nP=\\frac{1}{2}\\cdot\\frac{1}{3}S_{\\text{edge}}+\\frac{1}{2}\\cdot\\frac{1}{3}S_{\\text{vert}}=\\frac{S_{\\text{edge}}+S_{\\text{vert}}}{6}.\n$$\n因此，我们只需在六个比特 $a_{A},a_{B},a_{C},b_{A},b_{B},b_{C}$ 的所有赋值中最大化 $S_{\\text{edge}}+S_{\\text{vert}}$。\n\n固定 $a_{A},a_{B},a_{C}$，并对 $b_{A},b_{B},b_{C}$ 进行优化。将包含每个 $b_{X}$ 的项分组：\n- 与 $b_{A}$ 相关的项：$\\mathbf{1}[b_{A}=a_{A}] + \\mathbf{1}[b_{A}\\neq a_{C}]$。\n- 与 $b_{B}$ 相关的项：$\\mathbf{1}[b_{B}=a_{B}] + \\mathbf{1}[b_{B}\\neq a_{A}]$。\n- 与 $b_{C}$ 相关的项：$\\mathbf{1}[b_{C}=a_{C}] + \\mathbf{1}[b_{C}\\neq a_{B}]$。\n\n对于任意一对 $(x,y)\\in\\{0,1\\}^{2}$，定义 $f(b;x,y)=\\mathbf{1}[b=x]+\\mathbf{1}[b\\neq y]$。如果 $x=y$，那么对于 $b$ 的两种选择，都有 $f(b;x,y)=1$。如果 $x\\neq y$，那么选择 $b=x$ 会得到 $f=2$（而另一种选择得到 $0$）。因此，对 $b$ 的每一项进行优化，其最大值为2当且仅当相关的两个 $a$ 值不同（例如，对 $b_A$ 而言是 $a_A$ 和 $a_C$），否则最大值为1。\n\n因此，在给定 $a$ 的情况下，对 $b$ 优化的最大值为\n$$\nS_{\\text{edge}}+S_{\\text{vert}} \\le 6 - E,\n$$\n其中\n$$\nE=\\mathbf{1}[a_{A}=a_{C}] + \\mathbf{1}[a_{B}=a_{A}] + \\mathbf{1}[a_{C}=a_{B}].\n$$\n我们现在对 $a_{A},a_{B},a_{C}$ 最小化 $E$。\n$E$ 中的三个等式是 3-圈上的三个连续等式。\n仅用两种颜色，不可能同时满足三个连续的不等式 $a_{B}\\neq a_{A}$、 $a_{C}\\neq a_{B}$ 和 $a_{A}\\neq a_{C}$，因为 $a_{B}\\neq a_{A}$ 和 $a_{C}\\neq a_{B}$ 会强制 $a_{C}=a_{A}$，使得第三个不等式不成立。\n因此 $E\\ge 1$。\n这个界是紧的：取两个 $a$ 值相等，第三个不同（例如 $(a_{A},a_{B},a_{C})=(0,1,1)$），这在相邻顶点对中恰好产生一个等式，所以 $E=1$。\n\n因此 $S_{\\text{edge}}+S_{\\text{vert}}$ 的最大值等于 $6-1=5$，最优接受概率是\n$$\nP_{\\max}=\\frac{5}{6}.\n$$\n这个值是可以达到的。例如，选择 $(a_{A},a_{B},a_{C})=(0,1,1)$ 和 $(b_{A},b_{B},b_{C})=(0,1,1)$，这会得到 $S_{\\text{edge}}=2$，$S_{\\text{vert}}=3$，因此 $P=(2+3)/6=5/6$。", "answer": "$$\\boxed{\\frac{5}{6}}$$", "id": "1432453"}, {"introduction": "多证明者交互式证明的应用远不止于抽象的图论问题，它们也可以用来高效地验证大型数据结构的属性。本练习将探讨如何验证一个给定的矩阵是否为“置换矩阵”——一个在每行每列都恰好只有一个 1 的矩阵。通过设计一个包含“行检查”和“列检查”的协议，我们能体会到验证者如何从不同维度对证明者的回答进行交叉验证。这个过程不仅巩固了对 MIP 协议设计原则的理解，也展示了如何将这些原则应用于更具体的数据验证任务中。[@problem_id:1432452]", "problem": "在计算复杂性理论中，验证者可以使用多证明者交互式证明系统来验证由两个强大但不能通信的证明者提出的声明。考虑一个场景：验证者 V 得到一个公开的 $n \\times n$ 二进制矩阵 $M$，并希望确定它是否为置换矩阵。置换矩阵是一个方的二进制矩阵，其每行每列都恰好有一个 '1'，所有其他元素均为 '0'。\n\n验证者使用以下与证明者 P1 和 P2 的双证明者协议：\n1. 验证者抛掷一枚均匀的硬币，以相等的概率（各为 1/2）选择执行“行检查”或“列检查”。\n2. 如果选择“行检查”，验证者从 $\\{1, \\dots, n\\}$ 中均匀随机地选择一个行索引 $i$。它同时询问 P1 和 P2：“在第 $i$ 行中，'1' 的列索引是什么？” 设 P1 的回答为 $j_1$，P2 的回答为 $j_2$。当且仅当 $j_1 = j_2$ 且元素 $M_{i,j_1}$ 为 1 时，验证者接受。否则，验证者拒绝。\n3. 如果选择“列检查”，验证者从 $\\{1, \\dots, n\\}$ 中均匀随机地选择一个列索引 $j$。它同时询问 P1 和 P2：“在第 $j$ 列中，'1' 的行索引是什么？” 设 P1 的回答为 $i_1$，P2 的回答为 $i_2$。当且仅当 $i_1 = i_2$ 且元素 $M_{i_1,j}$ 为 1 时，验证者接受。否则，验证者拒绝。\n\n如果被查询的行或列没有 '1'，证明者仍必须提供一个答案。如果行或列有多个 '1'，证明者可以选择报告哪一个。两位证明者知道矩阵 $M$，并在协议开始前合作制定策略，以最大化使验证者接受的概率。然而，一旦协议开始，他们就不能通信。\n\n假设该协议在 $n=3$ 的情况下运行，并使用以下特定矩阵 $M$：\n$$ M = \\begin{pmatrix} 1  1  0 \\\\ 0  0  1 \\\\ 0  0  0 \\end{pmatrix} $$\n这个矩阵不是置换矩阵。验证者接受的最大概率是多少？请用最简分数表示你的答案。", "solution": "问题要求在给定指定的非置换矩阵 $M$ 的情况下，验证者接受的最大概率。这等同于找到证明者最优策略的成功概率。\n\n设 $A$ 为验证者接受的事件。设 $R$ 为验证者选择“行检查”的事件，设 $C$ 为验证者选择“列检查”的事件。根据协议，$P(R) = P(C) = 1/2$。\n总接受概率由全概率公式给出：\n$$ P(A) = P(A|R)P(R) + P(A|C)P(C) $$\n我们需要确定证明者的最优策略，然后计算条件概率 $P(A|R)$ 和 $P(A|C)$。\n\n证明者 P1 和 P2 在协议期间不能通信。因此，为了通过验证者的第一个检查（$j_1=j_2$ 或 $i_1=i_2$），他们必须对任何给定的问题都约定一个单一的答案。他们的最优策略是预先约定一个函数，将每个可能的查询（例如，“行 $i$”）映射到一个特定的答案（例如，“列 $j$”）。他们选择的答案将是能最大化通过验证者第二个检查（即 $M$ 中对应元素为 1）的机会的答案。\n\n**第 1 步：分析“行检查”分支**\n验证者以 $1/3$ 的均匀概率选择一个行 $i \\in \\{1, 2, 3\\}$。\n\n*   **如果验证者查询第 $i=1$ 行**：该行为 $(1, 1, 0)$。它在第 1 列和第 2 列包含 '1'。证明者的最优策略是约定返回列索引 1 或 2。例如，他们可以约定总是回答 $j=1$。然后验证者检查 $M_{1,1}=1$ 是否成立。因为这是真的，所以验证者接受。因此，对于这个查询，证明者可以确保验证者接受。接受的概率是 1。\n\n*   **如果验证者查询第 $i=2$ 行**：该行为 $(0, 0, 1)$。它在第 3 列包含一个 '1'。证明者唯一合乎逻辑的策略是约定回答 $j=3$。验证者检查 $M_{2,3}=1$ 是否成立。这是真的，所以验证者接受。接受的概率是 1。\n\n*   **如果验证者查询第 $i=3$ 行**：该行为 $(0, 0, 0)$。它不包含 '1'。证明者必须约定一个答案，比如列 $j$。然而，对于任何列 $j \\in \\{1, 2, 3\\}$，元素 $M_{3,j}$ 都是 0。验证者的检查将失败，验证者将拒绝。接受的概率是 0。\n\n给定“行检查”的情况下接受的条件概率是这些结果的平均值：\n$$ P(A|R) = \\frac{1}{3} \\times P(A|\\text{行 } 1) + \\frac{1}{3} \\times P(A|\\text{行 } 2) + \\frac{1}{3} \\times P(A|\\text{行 } 3) $$\n$$ P(A|R) = \\frac{1}{3}(1) + \\frac{1}{3}(1) + \\frac{1}{3}(0) = \\frac{2}{3} $$\n\n**第 2 步：分析“列检查”分支**\n验证者以 $1/3$ 的均匀概率选择一个列 $j \\in \\{1, 2, 3\\}$。\n\n*   **如果验证者查询第 $j=1$ 列**：该列为 $(1, 0, 0)^T$。它在第 1 行包含一个 '1'。证明者必须约定回答 $i=1$。验证者检查 $M_{1,1}=1$ 是否成立。这是真的，所以验证者接受。接受的概率是 1。\n\n*   **如果验证者查询第 $j=2$ 列**：该列为 $(1, 0, 0)^T$。它在第 1 行包含一个 '1'。证明者必须约定回答 $i=1$。验证者检查 $M_{1,2}=1$ 是否成立。这是真的，所以验证者接受。接受的概率是 1。\n\n*   **如果验证者查询第 $j=3$ 列**：该列为 $(0, 1, 0)^T$。它在第 2 行包含一个 '1'。证明者必须约定回答 $i=2$。验证者检查 $M_{2,3}=1$ 是否成立。这是真的，所以验证者接受。接受的概率是 1。\n\n在“列检查”的所有情况下，证明者都可以设计一种策略使验证者接受。给定“列检查”的情况下接受的条件概率是：\n$$ P(A|C) = \\frac{1}{3}(1) + \\frac{1}{3}(1) + \\frac{1}{3}(1) = 1 $$\n\n**第 3 步：计算总接受概率**\n现在，我们结合两个分支的结果。\n$$ P(A) = P(A|R)P(R) + P(A|C)P(C) $$\n$$ P(A) = \\left(\\frac{2}{3}\\right) \\times \\left(\\frac{1}{2}\\right) + (1) \\times \\left(\\frac{1}{2}\\right) $$\n$$ P(A) = \\frac{1}{3} + \\frac{1}{2} $$\n$$ P(A) = \\frac{2}{6} + \\frac{3}{6} = \\frac{5}{6} $$\n\n因此，验证者将接受的最大概率是 $5/6$。", "answer": "$$\\boxed{\\frac{5}{6}}$$", "id": "1432452"}, {"introduction": "除了组合学验证，代数方法为多证明者交互式证明提供了另一套强有力的工具。这个练习探讨了一个核心问题：如何验证一个给定的多项式是否恒等于零？这个问题在算法设计和密码学中至关重要。我们将分析一个利用随机化和有限域上多项式性质的协议，并通过它来理解著名的 Schwartz-Zippel 引理。这个实践揭示了，即便验证者无法检查多项式在所有点上的取值，她也可以通过查询证明者和一个随机点上的取值，以极高的概率做出正确判断。[@problem_id:1432516]", "problem": "在计算复杂性领域，研究多证明者交互式证明（MIP）系统是为了理解拥有多个不通信的全能证明者的计算能力。考虑一个场景，验证者 Victor 想要确定一个给定的双变量多项式 $P(x, y)$ 是否为零多项式（即 $P(x, y) \\equiv 0$）。该多项式的已知最大总次数为 $d$，其系数来自有限域 $\\mathbb{F}_q$，其中 $q$ 是一个远大于 $d$ 的素数。\n\nVictor 的计算资源有限，但他可以在任意给定点上对 $P(x,y)$ 进行求值。他使用了两个证明者，Prover 1 和 Prover 2，他们具有无限的计算能力并且知道多项式 $P(x, y)$。一旦协议开始，证明者之间就不能相互通信。Victor 执行以下协议：\n\n1.  Victor 从 $\\mathbb{F}_q \\times \\mathbb{F}_q$ 中均匀随机地选择一对值 $(r_x, r_y)$。\n2.  Victor 将 $r_x$ 发送给 Prover 1，并要求其提供单变量多项式 $p_1(y) = P(r_x, y)$。Prover 1 回复一个多项式，我们称之为 $Q_1(y)$。\n3.  Victor 将 $r_y$ 发送给 Prover 2，并要求其提供单变量多项式 $p_2(x) = P(x, r_y)$。Prover 2 回复一个多项式，我们称之为 $Q_2(x)$。\n4.  只有当以下所有条件都满足时，Victor 才接受 $P(x, y) \\equiv 0$：\n    a) 从 Prover 1 收到的多项式 $Q_1(y)$ 是零多项式。\n    b) 从 Prover 2 收到的多项式 $Q_2(x)$ 是零多项式。\n    c) 原始多项式在所选随机点 $(r_x, r_y)$ 处的值 $P(r_x, r_y)$ 为零。\n\n假设 $P(x, y)$ 实际上*不是*零多项式。证明者是恶意的，并会在协议开始前协同制定一个策略，以最大化他们能欺骗 Victor 使其接受的概率。Victor 错误接受的最大可能概率是多少？请用一个关于 $d$ 和 $q$ 的闭式解析表达式来表示你的答案。", "solution": "设 $P(x,y) \\in \\mathbb{F}_{q}[x,y]$ 是一个总次数至多为 $d$ 的非零多项式。Victor 从 $\\mathbb{F}_{q} \\times \\mathbb{F}_{q}$ 中均匀采样 $(r_{x},r_{y})$，将 $r_x$ 发送给 Prover 1，将 $r_y$ 发送给 Prover 2，并且仅在以下情况下接受：\na) $Q_{1}(y)$ 是零多项式，\nb) $Q_{2}(x)$ 是零多项式，\nc) $P(r_{x},r_{y})=0$。\n\n由于证明者是恶意的且计算能力无限，但不能影响 $P(r_{x},r_{y})$ 的值，他们可以通过始终回复零多项式来确保条件 a) 和 b) 成立。因此，在最佳作弊策略下，接受事件仅简化为条件 c)。因此，接受概率等于\n$$\n\\Pr[\\text{Victor accepts}]=\\Pr[P(r_{x},r_{y})=0].\n$$\n\n根据多元多项式的 Schwartz–Zippel 引理：如果 $P$ 是一个总次数至多为 $d$ 的非零多项式，并且每个变量都从一个有限集 $S \\subseteq \\mathbb{F}$（其中 $|S|=q$）中均匀抽取，那么\n$$\n\\Pr_{(r_{x},r_{y}) \\in S^{2}}[P(r_{x},r_{y})=0] \\le \\frac{d}{q}.\n$$\n将此引理应用于 $S=\\mathbb{F}_{q}$，可得\n$$\n\\Pr[P(r_{x},r_{y})=0] \\le \\frac{d}{q}.\n$$\n\n假定 $q$ 远大于 $d$，这个界是紧的。例如，选择 $d$ 个不同的元素 $a_{1},\\dots,a_{d} \\in \\mathbb{F}_{q}$ 并令\n$$\nP(x,y)=\\prod_{i=1}^{d}(x-a_{i}),\n$$\n该多项式总次数为 $d$ 并且与 $y$ 无关。那么，$P(r_{x},r_{y})=0$ 当且仅当 $r_{x} \\in \\{a_{1},\\dots,a_{d}\\}$，这种情况发生的概率为\n$$\n\\frac{d}{q}.\n$$\n因此，Victor 错误接受的最大可能概率恰好是 $\\frac{d}{q}$。", "answer": "$$\\boxed{\\frac{d}{q}}$$", "id": "1432516"}]}