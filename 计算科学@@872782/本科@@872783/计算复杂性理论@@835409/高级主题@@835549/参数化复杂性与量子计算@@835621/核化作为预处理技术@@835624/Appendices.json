{"hands_on_practices": [{"introduction": "理论必须通过实践来巩固。以下练习旨在帮助您将核化的概念应用于具体场景。第一个练习探讨了“支配规则”这一基本思想，即当一个选项在各方面都优于或等于另一个选项时，我们可以安全地简化问题。通过这个关于团队构建的实际问题 [@problem_id:1429664]，您将学会如何识别和应用这种强大的预处理技术。", "problem": "在计算复杂性理论中，核化（kernelization）是一种用于减小问题实例规模的预处理技术。考虑以下我们称之为**最小团队覆盖**（MINIMUM TEAM COVER）的决策问题：\n\n给定一个可用员工集合 $E$，其中每位员工 $e \\in E$ 都拥有一组特定的技能 $S_e$，一个目标所需技能集合 $S_{req}$，以及一个整数 $k$，我们能否选出一个最多由 $k$ 名员工组成的团队，使得 $S_{req}$ 中的每一项技能都至少被一名团队成员所覆盖？\n\n一家咨询公司正在分析此问题的一个小实例，以确定哪些预处理规则是有效的。一个有效的规则旨在通过从考虑范围内移除员工来简化实例，同时对于任何可能的 $k$ 和 $S_{req}$，都不会改变最小团队覆盖问题的答案。换句话说，如果存在一个最优（最小）的团队，那么从缩减后的员工池中，仍然应该能够找到一个最优团队。\n\n当前的候选人库及其技能如下：\n*   **Liam**: {'Version Control', 'API Design'}\n*   **Mia**: {'Database', 'UI/UX'}\n*   **Noah**: {'Version Control'}\n*   **Olivia**: {'Version Control', 'API Design', 'Testing'}\n*   **Ethan**: {'Database'}\n\n以下哪个陈述描述了可应用于此候选人库的有效预处理步骤？选择所有适用项。\n\nA. 移除 Liam，因为他的技能集是 Olivia 技能集的严格子集。\nB. 移除 Olivia，因为她的技能集严格包含 Liam 的技能集。\nC. 移除 Noah，因为他的技能集是 Liam 技能集的严格子集。\nD. 移除 Ethan，因为他的技能集是 Mia 技能集的严格子集。\nE. 移除任何员工都可能影响找到最优解的能力。", "solution": "我们为集合覆盖类问题形式化一个标准的支配（子集）归约规则。对于拥有技能集 $S_{x}$ 和 $S_{y}$ 的员工 $x$ 和 $y$，如果 $S_{x} \\subset S_{y}$，那么 $x$ 被 $y$ 支配，可以被安全地移除，而不会改变对于任何目标 $S_{req}$ 和任何 $k$ 的决策问题的答案。\n\n安全性证明：固定任意的 $S_{req}$ 和 $k$。考虑任何满足 $|T| \\leq k$ 的可行团队 $T$。如果 $x \\notin T$，那么从员工池中移除 $x$ 没有影响。如果 $x \\in T$，定义 $T' = (T \\setminus \\{x\\}) \\cup \\{y\\}$。那么 $|T'| = |T| \\leq k$，并且由于 $S_{x} \\subset S_{y}$，由 $T'$ 覆盖的技能集合包含了由 $T$ 覆盖的所有技能。因此 $T'$ 也是可行的。如果 $T$ 是一个最小规模的可行团队，那么 $T'$ 的规模与之相同，所以存在一个不使用 $x$ 的最优团队。因此，移除 $x$ 对所有的 $S_{req}$ 和 $k$ 都保持了可行性和最优性。反之，移除 $y$ 通常是不安全的，因为 $y$ 可能拥有 $S_x$ 中没有的技能，而这些技能可能是某个 $S_{req}$ 所需的。\n\n将此规则应用于给定的候选人库：\n- Liam 与 Olivia：$S_{\\text{Liam}} = \\{\\text{Version Control}, \\text{API Design}\\}$ 且 $S_{\\text{Olivia}} = \\{\\text{Version Control}, \\text{API Design}, \\text{Testing}\\}$。我们有 $S_{\\text{Liam}} \\subset S_{\\text{Olivia}}$，所以移除 Liam 是有效的。这验证了选项 A。\n- 移除 Olivia 因为她的技能集严格包含 Liam 的技能集（选项 B）通常是无效的：如果 $S_{req}$ 包含 Testing，只有 Olivia 提供该技能，所以移除 Olivia 可能会改变答案。\n- Noah 与 Liam（以及 Olivia）：$S_{\\text{Noah}} = \\{\\text{Version Control}\\} \\subset S_{\\text{Liam}}$ 且 $S_{\\text{Noah}} \\subset S_{\\text{Olivia}}$。因此根据支配规则，移除 Noah 是有效的。这验证了选项 C。\n- Ethan 与 Mia：$S_{\\text{Ethan}} = \\{\\text{Database}\\} \\subset S_{\\text{Mia}} = \\{\\text{Database}, \\text{UI/UX}\\}$。因此移除 Ethan 是有效的。这验证了选项 D。\n- 由于 A、C 和 D 都是有效的移除操作，所以陈述 E 是错误的。\n\n因此，有效的预处理步骤是 A、C 和 D。", "answer": "$$\\boxed{ACD}$$", "id": "1429664"}, {"introduction": "在上一个练习中，我们通过移除被支配的“选项”来简化问题。现在，我们将视角转向问题的“约束”本身。当一个约束被另一个更严格的约束所蕴含时，它就变得多余了。这个关于 $d$-集合覆盖问题 ($d$-Hitting Set) 的练习 [@problem_id:1429634] 将挑战您识别并移除这些冗余约束，这是简化逻辑和组合问题的关键一步。", "problem": "在计算复杂性理论中，$d$-Hitting Set（$d$-击中集）问题是一个经典的判定问题。该问题的一个实例由一个元组 $(U, \\mathcal{S}, k)$ 定义，其中 $U$ 是一个元素全集，$\\mathcal{S} = \\{S_1, S_2, \\ldots, S_m\\}$ 是 $U$ 的一个子集族，每个集合 $S_i$ 的大小最多为 $d$（即 $|S_i| \\le d$），$k$ 是一个正整数。问题是是否存在一个大小最多为 $k$（即 $|H| \\le k$）的“击中集”$H \\subseteq U$，它与集合族 $\\mathcal{S}$ 中的每个集合都有非空交集（即对所有 $i=1, \\ldots, m$ 都有 $H \\cap S_i \\neq \\emptyset$）。\n\n作为解决此问题的预处理步骤，我们通常寻找可以减小实例规模而不改变判定问题答案的简化规则。考虑一个 $d$-Hitting Set 的实例，其中对于集合族中的两个不同集合 $S_i \\in \\mathcal{S}$ 和 $S_j \\in \\mathcal{S}$，已知 $S_j$ 是 $S_i$ 的真子集（即 $S_j \\subset S_i$）。\n\n下列哪个陈述描述了一个可以对该实例进行的有效简化，同时保证简化后的实例是“是”实例当且仅当原始实例是“是”实例？\n\nA. 可以从集合族 $\\mathcal{S}$ 中移除集合 $S_i$。\nB. 可以从集合族 $\\mathcal{S}$ 中移除集合 $S_j$。\nC. 可以从集合族 $\\mathcal{S}$ 中同时移除集合 $S_i$ 和 $S_j$。\nD. 可以从全集 $U$ 中移除集合差 $S_i \\setminus S_j$ 中的所有元素，并因此从包含这些元素的 $\\mathcal{S}$ 中的任何集合中移除它们。\nE. 该实例的任何有效击中集都必须包含至少一个来自集合差 $S_i \\setminus S_j$ 的元素。", "solution": "该问题要求为 $d$-Hitting Set 问题寻找一个有效的归约规则，适用于输入集合族中一个集合 $S_j$ 是另一个集合 $S_i$ 的真子集的情况。一个归约规则是有效的，如果修改后的实例是“是”实例当且仅当原始实例是“是”实例。设原始实例为 $I = (U, \\mathcal{S}, k)$，提议的简化实例为 $I'$。我们需要证明 $I$ 有一个大小最多为 $k$ 的击中集当且仅当 $I'$ 也有。\n\n让我们逐一分析每个选项。\n\n**选项 A 的分析：可以从集合族 $\\mathcal{S}$ 中移除集合 $S_i$。**\n\n设新实例为 $I' = (U, \\mathcal{S}', k)$，其中 $\\mathcal{S}' = \\mathcal{S} \\setminus \\{S_i\\}$。我们需要证明，存在一个大小最多为 $k$ 的击中集 $H$ 用于实例 $I$ 当且仅当存在一个大小最多为 $k$ 的击中集 $H'$ 用于实例 $I'$。\n\n首先，假设原始实例 $I$ 存在一个大小最多为 $k$ 的击中集 $H$。\n根据定义，$H$ 与 $\\mathcal{S}$ 中的每个集合相交。这也包括了子集族 $\\mathcal{S}' = \\mathcal{S} \\setminus \\{S_i\\}$ 中的每个集合。因此，$H$ 也是实例 $I'$ 的一个有效击中集。所以，如果 $I$ 是一个“是”实例，那么 $I'$ 也是一个“是”实例。\n\n其次，假设简化实例 $I'$ 存在一个大小最多为 $k$ 的击中集 $H'$。\n根据定义，$H'$ 与 $\\mathcal{S}'$ 中的每个集合相交。为了证明 $H'$ 也是原始实例 $I$ 的一个击中集，我们只需要验证 $H'$ 与被移除的那个集合 $S_i$ 相交。\n由于 $S_j \\in \\mathcal{S}$ 且 $S_j \\neq S_i$，因此 $S_j \\in \\mathcal{S}'$。因为 $H'$ 是 $I'$ 的击中集，它必须与 $S_j$ 相交。这意味着存在一个元素 $x$，使得 $x \\in H'$ 且 $x \\in S_j$。\n我们已知的条件是 $S_j \\subset S_i$。根据子集的定义，$S_j$ 中的每个元素也都在 $S_i$ 中。因为 $x \\in S_j$，所以必有 $x \\in S_i$。\n因此，$x \\in H' \\cap S_i$，这意味着 $H'$ 与 $S_i$ 有非空交集。\n由于 $H'$ 与 $\\mathcal{S}'$ 中的每个集合相交，并且也与 $S_i$ 相交，所以它与 $\\mathcal{S}$ 中的每个集合都相交。因此，$H'$ 是原始实例 $I$ 的一个有效击中集。所以，如果 $I'$ 是一个“是”实例，那么 $I$ 也是一个“是”实例。\n\n由于两个实例解的存在性是等价的，所以这个简化是有效的。由 $S_i$ 施加的约束是冗余的，因为任何“击中”更严格约束 $S_j$ 的集合都会自动击中更宽松的约束 $S_i$。\n\n**选项 B 的分析：可以从集合族 $\\mathcal{S}$ 中移除集合 $S_j$。**\n\n这是一个无效的简化。考虑一个反例：\n设全集为 $U = \\{a, b\\}$。设集合族为 $\\mathcal{S} = \\{S_i, S_j\\}$，其中 $S_i = \\{a, b\\}$，$S_j = \\{a\\}$，并设 $k=1$。我们有 $S_j \\subset S_i$。\n根据此规则，简化后的实例将是 $I' = (U, \\{S_i\\}, k)$，即 $(U, \\{\\{a, b\\}\\}, 1)$。$I'$ 的一个有效击中集是 $H' = \\{b\\}$。\n然而，$H'=\\{b\\}$ 对于原始实例 $I$ 并不是一个有效的击中集，因为它不与 $S_j = \\{a\\}$ 相交。\n原始实例唯一的有效击中集是 $H=\\{a\\}$。通过移除 $S_j$，我们改变了问题，从而出现了一个新的、不正确的解。\n\n**选项 C 的分析：可以从集合族 $\\mathcal{S}$ 中同时移除集合 $S_i$ 和 $S_j$。**\n\n这也是无效的。如果仅仅移除 $S_j$ 是无效的（如上所示），那么同时移除 $S_j$ 和 $S_i$ 也必然是无效的，因为它从问题中移除了一个必要的约束（$S_j$）。例如，在选项 B 的反例中，同时移除 $\\{a,b\\}$ 和 $\\{a\\}$ 会留下一个空的集合族，对于这个空族，空集是一个大小为 0 的有效击中集。这显然不是原始问题的解。\n\n**选项 D 的分析：可以从全集 $U$ 中移除集合差 $S_i \\setminus S_j$ 中的所有元素。**\n\n这是一个无效的简化。从全集中移除元素可能会消除有效的解。\n考虑一个反例：\n设 $U=\\{a,b,c,d\\}$，实例的集合族为 $\\mathcal{S}' = \\{\\{a,d\\}, \\{b,d\\}, \\{a,c\\}, \\{a\\}\\}$，$k=2$。\n这里我们可以识别出 $S_i=\\{a,c\\}$ 和 $S_j=\\{a\\}$，所以 $S_j \\subset S_i$。集合差为 $S_i \\setminus S_j = \\{c\\}$。该规则建议从全集中移除元素 $c$。\n原始实例有一个大小为 2 的有效击中集 $\\{c,d\\}$，因为 $d$ 击中了 $\\{a,d\\}$ 和 $\\{b,d\\}$，而 $c$ 击中了 $\\{a,c\\}$（注意，任何击中 $\\{a,c\\}$ 或 $\\{a,d\\}$ 的集合都已经击中了 $\\{a\\}$）。\n如果我们应用该规则并移除 $c$，解 $\\{c,d\\}$ 就不再可能。新的待击中集合族（移除 $c$ 并应用规则 A 移除 $\\{a,c\\}$ 后）将是 $\\{\\{a,d\\}, \\{b,d\\}, \\{a\\}\\}$。这个问题的击中集必须包含 $a$（以击中 $\\{a\\}$）和 $d$（以击中 $\\{b,d\\}$），所以一个最小击中集是 $\\{a,d\\}$，大小为 2。虽然问题答案的大小不变，但通过移除 $c$，我们破坏了一个有效的解 $\\{c,d\\}$。若某个实例的唯一解恰好依赖于这类元素，则该规则将导致错误。因此，此规则无效。\n\n**选项 E 的分析：该实例的任何有效击中集都必须包含至少一个来自集合差 $S_i \\setminus S_j$ 的元素。**\n\n这是错误的。一个击中集必须与 $S_j$ 相交。如果它通过选择一个元素 $x \\in S_j$ 来实现这一点，那么它也就与 $S_i$ 相交了（因为 $x \\in S_j \\implies x \\in S_i$）。没有必要从 $S_i \\setminus S_j$ 中选择元素来满足与 $S_i$ 或 $S_j$ 相关的约束。例如，设 $U=\\{a, b, c\\}$，$\\mathcal{S}=\\{\\{a, b\\}, \\{a\\}, \\{c\\}\\}$，且 $k=2$。这里 $S_i=\\{a,b\\}$ 且 $S_j=\\{a\\}$。集合差是 $\\{b\\}$。一个有效的击中集是 $H=\\{a,c\\}$。这个集合不包含任何来自集合差 $S_i \\setminus S_j = \\{b\\}$ 的元素。因此，该陈述是错误的。\n\n根据以上分析，只有选项 A 描述了一个有效的简化。", "answer": "$$\\boxed{A}$$", "id": "1429634"}, {"introduction": "核化技术不仅限于直接移除元素或约束。更高级的规则会以一种可预测的方式转换问题，即使解的值不完全相同。本练习探讨了一种基于图结构对称性的归约规则：处理具有相同邻域的两个不相邻顶点。通过分析团划分问题 [@problem_id:1429650]，您将学习到归约如何在原始问题和核化问题之间建立一个有界的关系，这是参数化复杂性理论中的一个核心思想。", "problem": "在图论中，**团**（clique）是无向图中一个顶点子集，其中任意两个不同的顶点都相互邻接。对于给定的图 $G$ 和一个整数 $k$，**团划分问题**（Clique Partition Problem）旨在判断 $G$ 的顶点集是否可以被划分为至多 $k$ 个不相交的集合，其中每个集合都是一个团。这种划分中最少的团数记为 $\\chi_c(G)$。\n\n考虑一个场景，您正在分析一个大图 $G=(V, E)$。您识别出两个不同的顶点 $u$ 和 $v$，它们之間没有边连接。然而，它们拥有完全相同的邻居集合。该性质被正式地描述为它们的开邻域相同：$N(u) = N(v)$，其中 $N(x) = \\{y \\in V \\mid (x,y) \\in E\\}$。\n\n为了简化该图，您提出了一个规约规则：通过删除顶点 $v$ 及其所有相连的边来创建一个新图 $G'$。您计划首先确定 $G'$ 的团划分数，然后利用该结果推断出原始图 $G$ 的答案。\n\n对于任何图 $G$ 以及任何一对具有相同邻域的不邻接顶点 $u, v$，下列哪个陈述最准确、最完整地描述了 $\\chi_c(G)$ 和 $\\chi_c(G')$ 之间的数学关系？\n\nA. 关系总是 $\\chi_c(G) = \\chi_c(G')$。\nB. 关系总是 $\\chi_c(G) = \\chi_c(G') + 1$。\nC. 关系总是 $\\chi_c(G) = \\chi_c(G')$ 或 $\\chi_c(G) = \\chi_c(G') + 1$。\nD. 关系总是 $\\chi_c(G) = \\chi_c(G')$ 或 $\\chi_c(G) = \\chi_c(G') - 1$。\nE. 不存在确定性关系；差值 $\\chi_c(G) - \\chi_c(G')$ 可以是任何整数，具体取决于图的结构。", "solution": "设 $G=(V,E)$ 为任意图，设 $G'$ 是通过删除一个顶点 $v \\in V$ 得到的图。根据定义，团划分数 $\\chi_{c}(G)$ 是其不相交并集为 $V$ 的最小团数。\n\n首先，移除一个顶点不会需要更多的团：\n$$\n\\chi_{c}(G') \\leq \\chi_{c}(G).\n$$\n确实，取 $G$ 的一个最优团划分；从 $v$ 所在的团中删除 $v$ 会得到一个 $V \\setminus \\{v\\}$ 的划分，其团的数量至多与原来相同。\n\n其次，当将 $v$ 添加回 $G'$ 的任意团划分时，总可以将 $v$ 放入一个已有的团中（该团中所有顶点都与 $v$ 邻接），或者將 $v$ 自身作為一個單點團。因此，\n$$\n\\chi_{c}(G) \\leq \\chi_{c}(G') + 1.\n$$\n结合这两个不等式可得\n$$\n\\chi_{c}(G') \\leq \\chi_{c}(G) \\leq \\chi_{c}(G') + 1,\n$$\n因此\n$$\n\\chi_{c}(G) \\in \\{\\chi_{c}(G'),\\, \\chi_{c}(G') + 1\\}.\n$$\n\n我们现在证明，在所述条件 $u \\not\\sim v$ 且 $N(u)=N(v)$ 下，两种可能性都会发生。\n\n实现 $\\chi_{c}(G) = \\chi_{c}(G')$ 的例子。设 $W$ 是一个大小为 $t \\geq 2$ 的独立集，并添加两个顶点 $u$ 和 $v$，它们都与 $W$ 中的每个顶点邻接，但彼此不邻接。那么 $N(u)=N(v)=W$。在 $G' = G - v$ 中， $W$ 中的顶点两两不邻接，所以任何团划分都需要至少 $t$ 个团。通过取一个团 $\\{u,w^{*}\\}$ 和 $W \\setminus \\{w^{*}\\}$ 的 $t-1$ 个单点集，可以用 $t$ 个团实现划分，因此 $\\chi_{c}(G')=t$。在 $G$ 中，我们可以取两个团 $\\{u,w_{1}\\}$ 和 $\\{v,w_{2}\\}$，再加上 $W$ 中剩余顶点的 $t-2$ 个单点集，总数仍为 $t$ 个团。因此 $\\chi_{c}(G)=\\chi_{c}(G')$。\n\n实现 $\\chi_{c}(G) = \\chi_{c}(G') + 1$ 的例子。设图 $G$ 只有两个顶点 $u$ 和 $v$，它们之间没有边，也没有其他顶点。那么 $N(u)=N(v)=\\varnothing$ 且 $u \\not\\sim v$。这里 $G'$ 是关于 $\\{u\\}$ 的单顶点图，所以 $\\chi_{c}(G')=1$，而 $G$ 需要两个单点团，所以 $\\chi_{c}(G)=2=\\chi_{c}(G')+1$。\n\n因此，对于任何图 $G$ 和任何具有 $N(u)=N(v)$ 的不邻接顶点对 $u,v$，唯一可能的情况是\n$$\n\\chi_{c}(G) = \\chi_{c}(G') \\quad \\text{or} \\quad \\chi_{c}(G) = \\chi_{c}(G') + 1,\n$$\n并且两种情况都可能发生。这对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1429650"}]}