{"hands_on_practices": [{"introduction": "在理论学习之后，动手构建电路是检验和深化理解的最佳方式。这个练习将引导你为一个常见且重要的函数——“多数决”函数——设计一个单调电路。这个挑战不仅在于实现功能，更在于通过逻辑化简，找到尺寸最小、效率最高的电路实现方案，这是电路设计中的一个核心目标。[@problem_id:1432269]", "problem": "一个用于自动驾驶汽车的安全关键系统依赖于三个独立的传感器 $S_1, S_2,$ 和 $S_3$ 来监测某一环境状况。该系统采用冗余设计以确保可靠性。当且仅当三个传感器中至少有两个同时被触发时，系统的控制单元才会启动安全协议。\n\n设每个传感器的状态由一个布尔变量 $x_i$ 表示，其中如果传感器 $S_i$ 被触发，则 $x_i=1$，否则 $x_i=0$。启动安全协议的决策可以用一个布尔函数 $f(x_1, x_2, x_3)$ 来描述，如果应启动协议，则该函数输出 1，否则输出 0。\n\n这个逻辑必须使用**单调布尔电路**来实现。在本问题中，单调布尔电路是根据以下规则构建的门网络：\n-   电路的输入是变量 $x_1, x_2, x_3$。\n-   电路只包含与门（$\\land$）和或门（$\\lor$）。不允许使用其他类型的门（如非门）。\n-   每个门必须恰好有两个输入（即扇入数为 2）。\n-   电路必须有一个与函数 $f(x_1, x_2, x_3)$ 对应的单一输出。\n\n电路的**大小**定义为其包含的门的总数。电路的**深度**定义为从任何输入变量到最终输出门的最长路径的长度。\n\n找出实现函数 $f$ 的最有效率（即可能最小的大小）的单调布尔电路的大小 $S$ 和深度 $D$。请以一对整数 $(S, D)$ 的形式提供你的答案。", "solution": "问题要求计算一个函数 $f(x_1, x_2, x_3)$ 的最小尺寸单调电路的大小 $S$ 和深度 $D$。当该函数的输入中至少有两个为真时，函数值为真。这也被称为三变量的2-阈值函数，记为 $Th_2^3$。\n\n首先，我们必须用布尔运算来表示函数 $f(x_1, x_2, x_3)$。条件“$x_1, x_2, x_3$ 中至少有两个为真”可以写成所有可能的对都为真的析取形式：\n($x_1$ 为真 且 $x_2$ 为真) 或 ($x_1$ 为真 且 $x_3$ 为真) 或 ($x_2$ 为真 且 $x_3$ 为真)。\n用布尔代数表示法，即为：\n$$f(x_1, x_2, x_3) = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_2 \\land x_3)$$\n这是该函数的析取范式 (DNF)。\n\n构建电路的一个直接方法是直接实现这个表达式。\n1.  计算三个与项：\n    -   $g_1 = x_1 \\land x_2$（1个与门）\n    -   $g_2 = x_1 \\land x_3$（1个与门）\n    -   $g_3 = x_2 \\land x_3$（1个与门）\n2.  使用或门组合这些项。由于门被限制为2个输入，我们需要两个或门来组合这三个项：\n    -   $g_4 = g_1 \\lor g_2$（1个或门）\n    -   $f = g_4 \\lor g_3$（1个或门）\n\n计算门的数量，我们有3个与门和2个或门，总大小为5。虽然这种构造是有效的，但我们必须确定它是否是最有效率的（最小尺寸）。我们来研究一下是否可以简化布尔表达式以使用更少的门。\n\n我们可以对表达式进行因式分解。让我们从前两项中提取出 $x_1$：\n$$f(x_1, x_2, x_3) = (x_1 \\land (x_2 \\lor x_3)) \\lor (x_2 \\land x_3)$$\n我们来验证这是否是同一个函数。根据分配律，$x_1 \\land (x_2 \\lor x_3) = (x_1 \\land x_2) \\lor (x_1 \\land x_3)$。将其代回即可得到原始表达式，因此因式分解是正确的。\n\n现在，让我们根据这个新的表达式 $f = (x_1 \\land (x_2 \\lor x_3)) \\lor (x_2 \\land x_3)$ 来构建一个电路。我们可以按如下方式构建它：\n1.  计算最内层括号中的项：$g_1 = x_2 \\lor x_3$。这需要一个或门。\n2.  计算最终析取式中的第二项：$g_2 = x_2 \\land x_3$。这需要一个与门。\n3.  计算第一个主要项：$g_3 = x_1 \\land g_1 = x_1 \\land (x_2 \\lor x_3)$。这需要一个与门，它以 $x_1$ 和 $g_1$ 的输出作为输入。\n4.  计算最终函数：$f = g_3 \\lor g_2$。这需要一个或门，它以 $g_3$ 和 $g_2$ 的输出作为输入。\n\n总共，这个电路使用了1个或门（用于 $g_1$），1个与门（用于 $g_2$），1个与门（用于 $g_3$），和1个或门（用于 $f$）。门的总数是 $1+1+1+1 = 4$。\n由于这比最初的大小5要小，所以这是一个更有效率的设计。可以证明（尽管本问题不要求）对于使用2输入单调门的这个函数，大小为4确实是最优的。因此，最小大小为 $S=4$。\n\n接下来，我们计算这个大小为4的电路的深度 $D$。深度是从输入到输出的最长路径。\n-   输入 $x_1, x_2, x_3$ 的深度为0。\n-   门 $g_1 = x_2 \\lor x_3$ 和 $g_2 = x_2 \\land x_3$ 直接从源变量获取输入。它们的深度为1。\n-   门 $g_3 = x_1 \\land g_1$ 依赖于输入变量 $x_1$（深度0）和门 $g_1$ 的输出（深度1）。其深度为 $1 + \\max(\\text{depth}(x_1), \\text{depth}(g_1)) = 1 + \\max(0, 1) = 2$。\n-   最终的输出门 $f = g_3 \\lor g_2$ 依赖于 $g_3$（深度2）和 $g_2$（深度1）的输出。其深度为 $1 + \\max(\\text{depth}(g_3), \\text{depth}(g_2)) = 1 + \\max(2, 1) = 3$。\n\n最长的路径经过门 $g_1$，然后是 $g_3$，最后是 $f$。例如，从 $x_2$ 经由 $g_1$ 和 $g_3$ 到达 $f$ 的路径长度为3。因此，电路的深度为 $D=3$。\n\n最小大小为 $S=4$，对应的深度为 $D=3$。答案是这对数 $(4, 3)$。", "answer": "$$\\boxed{\\begin{pmatrix} 4  3 \\end{pmatrix}}$$", "id": "1432269"}, {"introduction": "理解单调电路背后计算的函数本身同样至关重要。此练习引入了“最小为真输入”的概念，这是刻画单调函数基本行为的一个强大工具。通过将一个给定的布尔表达式转换为其最简范式，你将学会如何系统地识别这些关键输入，从而揭示函数的核心逻辑结构。[@problem_id:1432217]", "problem": "在计算复杂性理论的研究中，一个布尔函数 $f: \\{0,1\\}^n \\to \\{0,1\\}$ 被称为**单调的**（monotone），如果对于任意两个输入向量 $u = (u_1, \\dots, u_n)$ 和 $v = (v_1, \\dots, v_n)$，当对所有的 $i=1, \\dots, n$ 都有 $u_i \\le v_i$ 时，$f(u) \\le f(v)$ 也成立。通俗地说，这意味着将输入中的某个0变为1，永远不会导致函数的输出从1变为0。这类函数仅使用逻辑与（$\\land$）和逻辑或（$\\lor$）运算符即可表示。\n\n对于一个单调函数 $f$，其**最小为真输入**（minimal true input）是一个输入向量 $v$，满足 $f(v) = 1$，但对于任何通过将 $v$ 中的单个1变为0而得到的向量 $v'$，都有 $f(v') = 0$。所有最小为真输入的集合完全刻画了一个单调函数。\n\n考虑如下定义的4变量单调布尔函数 $f(x_1, x_2, x_3, x_4)$：\n$$\nf(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor (x_3 \\land (x_1 \\lor x_4))\n$$\n下列哪个选项代表了函数 $f$ 的所有最小为真输入的完整集合？输入向量表示为二进制字符串，其中第 $i$ 个字符对应于 $x_i$ 的值。\n\nA. {`1100`, `1010`}\n\nB. {`1100`, `1010`, `1110`}\n\nC. {`1100`, `1010`, `0011`}\n\nD. {`0100`, `0010`, `0001`}\n\nE. {`1100`, `1010`, `0011`, `1011`}", "solution": "问题要求找出单调布尔函数 $f(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor (x_3 \\land (x_1 \\lor x_4))$ 的所有最小为真输入的完整集合。\n\n寻找单调函数最小为真输入的一种标准方法是，首先将其表达式化为最小析取范式（DNF）。对于单调函数，其最小析取范式中的每一项都精确对应一个最小为真输入。\n\n首先，我们应用 $\\land$ 对 $\\lor$ 的分配律，将给定的 $f$ 表达式展开为其析取范式。分配律为 $A \\land (B \\lor C) = (A \\land B) \\lor (A \\land C)$。\n将此定律应用于函数表达式的第二部分：\n$$\nx_3 \\land (x_1 \\lor x_4) = (x_3 \\land x_1) \\lor (x_3 \\land x_4)\n$$\n将此结果代回到 $f$ 的表达式中：\n$$\nf(x_1, x_2, x_3, x_4) = (x_1 \\land x_2) \\lor \\left( (x_1 \\land x_3) \\lor (x_3 \\land x_4) \\right)\n$$\n因此，$f$ 的析取范式为：\n$$\nf = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_3 \\land x_4)\n$$\n\n接下来，我们需要确保这是最小析取范式。我们可以使用吸收律来检查冗余，吸收律为 $P \\lor (P \\land Q) = P$。析取范式中的一个项如果被另一个项所蕴含，则该项是冗余的。对于单调函数，这意味着检查一个项（变量的合取）是否是另一个项的超集。例如，$(x_1 \\land x_2 \\land x_3)$ 会被 $(x_1 \\land x_2)$ 吸收。\n让我们检查我们析取范式中的三项：\n1. $T_1 = x_1 \\land x_2$\n2. $T_2 = x_1 \\land x_3$\n3. $T_3 = x_3 \\land x_4$\n\n这些项中没有一个项包含另一个项的所有变量。例如，$T_1$ 不包含 $x_3$（来自 $T_2$）或 $x_4$（来自 $T_3$），因此它不能被吸收。同样，$T_2$ 不能被 $T_1$ 或 $T_3$ 吸收，$T_3$ 也不能被 $T_1$ 或 $T_2$ 吸收。因此，析取范式 $f = (x_1 \\land x_2) \\lor (x_1 \\land x_3) \\lor (x_3 \\land x_4)$ 是最小的。\n\n这个最小析取范式中的每一项都对应一个最小为真输入。形如 $x_{i_1} \\land x_{i_2} \\land \\dots \\land x_{i_k}$ 的项对应的输入向量中，变量 $x_{i_1}, x_{i_2}, \\dots, x_{i_k}$ 被设为1，所有其他变量被设为0。这个输入是最小的，因为将这些指定变量中的任何一个设置为0都会使该项变为假，并且由于所有其他变量都已经是0，析取范式中的其他项也会是假，从而导致整个函数值为0。\n\n让我们从这些项中导出最小为真输入：\n- 从项 $x_1 \\land x_2$：我们设置 $x_1=1$, $x_2=1$，其余为0。这得到输入向量 $(1,1,0,0)$，对应二进制字符串 `1100`。\n- 从项 $x_1 \\land x_3$：我们设置 $x_1=1$, $x_3=1$，其余为0。这得到输入向量 $(1,0,1,0)$，对应二进制字符串 `1010`。\n- 从项 $x_3 \\land x_4$：我们设置 $x_3=1$, $x_4=1$，其余为0。这得到输入向量 $(0,0,1,1)$，对应二进制字符串 `0011`。\n\n因此，最小为真输入的完整集合是 {`1100`, `1010`, `0011`}。\n\n将此结果与给定选项进行比较：\n- A. {`1100`, `1010`} 不完整；它缺少了 `0011`。\n- B. {`1100`, `1010`, `1110`} 包含了 `1110`，但它不是一个最小为真输入。对于输入 `1110`，我们有 $f(1,1,1,0) = (1\\land1)\\lor(1\\land(1\\lor0)) = 1$。但是，如果我们将 $x_3$ 从1变为0，我们得到输入 `1100`。对于 `1100`，$f(1,1,0,0)=(1\\land1)\\lor(0\\land(1\\lor0))=1$。由于将一个1变为0并没有使函数值变为0，所以 `1110` 不是最小的。它被最小为真输入 `1100` “覆盖”了。\n- C. {`1100`, `1010`, `0011`} 是我们推导出的正确集合。\n- D. {`0100`, `0010`, `0001`} 表示只有一个1的输入。这些输入都不能使函数值为真。例如，$f(0,1,0,0) = (0\\land1)\\lor(0\\land(0\\lor0)) = 0$。\n- E. {`1100`, `1010`, `0011`, `1011`} 包含了正确的集合，但也包含了 `1011`。输入 `1011` 不是最小的。$f(1,0,1,1)=(1\\land0)\\lor(1\\land(1\\lor1))=1$。然而，它（在分量序上）包含两个最小为真输入作为子向量：`1010` 和 `0011`。例如，$f(1,0,1,0)=1$，所以将 $x_4$ 从1变为0并不会改变函数的输出值。因此 `1011` 不是最小的。\n\n因此，正确选项是C。", "answer": "$$\\boxed{C}$$", "id": "1432217"}, {"introduction": "单调电路和它们的等价公式（如析取范式 DNF）在表达能力上是否存在差异？这个问题将引导你探索一个展示电路相对于公式在简洁性上巨大优势的经典例子。通过分析一个特定电路家族转换为 DNF 时规模的指数级“爆炸”，你将亲身体会到为什么在计算复杂性理论中，电路被认为是比公式更强大的计算模型。[@problem_id:1432222]", "problem": "在计算复杂性理论中，单调布尔电路是一种仅使用与门（$\\wedge$）和或门（$\\vee$）构建的电路，其输入来自一组变量 $\\{x_1, x_2, \\ldots, x_n\\}$。单调电路不包含任何非门（$\\neg$）。电路的规模定义为其包含的总门数。\n\n任何由单调电路计算的函数都可以用等价的单调析取范式（DNF）公式表示。单调析取范式是一个或多个子句的或运算，其中每个子句是一个或多个输入变量的与运算（例如，$(x_1 \\wedge x_3) \\vee (x_2 \\wedge x_5)$）。\n\n存在一个标准的递归过程，可将单调电路转换为其DNF表示。令 $D(g)$ 表示由门 $g$ 计算的函数的DNF公式。\n- 如果 $g$ 是一个输入变量 $x_i$，则 $D(g) = x_i$。\n- 如果 $g$ 是一个输入为 $g_1$ 和 $g_2$ 的或门，则 $D(g) = D(g_1) \\vee D(g_2)$。\n- 如果 $g$ 是一个输入为 $g_1$ 和 $g_2$ 的与门，其中 $D(g_1) = \\bigvee_i A_i$ 且 $D(g_2) = \\bigvee_j B_j$，则通过应用分配律，有 $D(g) = \\bigvee_{i,j} (A_i \\wedge B_j)$。\n\n考虑一个由整数 $k \\ge 1$ 参数化的特定单调电路族，已知该电路族在转换为DNF时规模会显著增加。该电路有 $2k$ 个不同的输入变量：$\\{x_1, \\ldots, x_k, y_1, \\ldots, y_k\\}$。电路的构建方式如下：\n1. 第一层有 $k$ 个或门，其中第 $i$ 个门（对于 $i=1, \\ldots, k$）计算 $g_i = x_i \\vee y_i$。假设所有门的扇入均为2。\n2. 这 $k$ 个或门的输出被送入一个由 $k-1$ 个与门组成的平衡二叉树，以产生一个最终输出。\n\n该电路的总规模（计算所有或门和与门）为 $s = 2k-1$。\n\n你的任务是确定与此电路等价的最终单调DNF公式中的子句数量。请将答案表示为总电路规模 $s$ 的函数。", "solution": "该电路计算单调函数\n$$\nF=\\bigwedge_{i=1}^{k}(x_{i}\\vee y_{i}).\n$$\n定义 $C(g)$ 为单调DNF $D(g)$ 中的子句数量。\n\n根据给定的递归DNF构造方法：\n- 对于输入变量 $x_{i}$，$D(x_{i})=x_{i}$ 是一个单独的子句，因此 $C(x_{i})=1$，同理 $C(y_{i})=1$。\n- 对于或门，$D(g_{1}\\vee g_{2})=D(g_{1})\\vee D(g_{2})$，因此子句数量相加：\n$$\nC(g_{1}\\vee g_{2})=C(g_{1})+C(g_{2}).\n$$\n- 对于与门，如果 $D(g_{1})=\\bigvee_{i}A_{i}$ 且 $D(g_{2})=\\bigvee_{j}B_{j}$，则 $D(g_{1}\\wedge g_{2})=\\bigvee_{i,j}(A_{i}\\wedge B_{j})$，因此子句数量相乘：\n$$\nC(g_{1}\\wedge g_{2})=C(g_{1})\\,C(g_{2}).\n$$\n\n对于第一层的每个门 $g_{i}=x_{i}\\vee y_{i}$，利用或运算的加法性质以及 $C(x_{i})=C(y_{i})=1$，\n$$\nC(g_{i})=C(x_{i})+C(y_{i})=1+1=2.\n$$\n最终输出是 $k$ 个门 $g_{1},\\ldots,g_{k}$ 的与运算。利用与运算的乘法性质，\n$$\nC(F)=\\prod_{i=1}^{k}C(g_{i})=\\prod_{i=1}^{k}2=2^{k}.\n$$\n因为总电路规模为 $s=2k-1$，我们解出 $k$ 得到 $k=\\frac{s+1}{2}$。代入可得，\n$$\nC(F)=2^{\\frac{s+1}{2}}.\n$$\n因此，最终单调DNF中的子句数量作为电路规模 $s$ 的函数是 $2^{\\frac{s+1}{2}}$。", "answer": "$$\\boxed{2^{\\frac{s+1}{2}}}$$", "id": "1432222"}]}