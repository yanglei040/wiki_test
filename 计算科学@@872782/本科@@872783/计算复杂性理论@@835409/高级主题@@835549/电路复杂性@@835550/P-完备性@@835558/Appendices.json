{"hands_on_practices": [{"introduction": "要理解哪些问题是“内在地”顺序性的，一个有效的方法是首先研究一个看起来是顺序性但实际上可以高效并行化的问题。这个最大值表达式求值问题（MEEP）就是一个绝佳的例子，其任意嵌套的括号似乎强制规定了固定的计算顺序[@problem_id:1433477]。通过解决这个问题，你将发现一个关键的代数性质，它允许我们打破这种表面上的顺序依赖，从而揭示为什么该问题不属于P-完备问题，而是可以被高效并行解决的。", "problem": "在计算复杂性理论中，我们研究解决计算问题所需的资源。**P** 类包含所有可以由确定性顺序计算机在多项式时间内解决的判定问题。**NC** 类（Nick 类）是可以在拥有多项式数量处理器的并行计算机上在多对数时间内解决的判定问题的集合。NC 中的问题被认为是“高效可并行的”。人们普遍认为 NC 是 P 的一个真子集。\n\n如果 P 中的一个问题是 P 中“最难”的问题之一，那么它被称为 **P-完全** 问题。更正式地说，P 中的所有其他问题都可以通过对数空间归约到它。P-完全问题被认为是“内在顺序的”，并且不太可能属于 NC。如果发现任何 P-完全问题属于 NC，那将意味着 P = NC。\n\n考虑**最大表达式求值问题 (MEEP)**，其定义如下：给定一个包含一组整型变量 $x_1, x_2, \\dots, x_n$ 和二元运算符 `max(,)` 的完全括号化的表达式，以及每个变量的整数值，计算该表达式的最终值。此类表达式的一个例子是 `max(x_1, max(max(x_2, x_3), x_4))`。\n\n根据所提供的定义，确定最大表达式求值问题 (MEEP) 的最准确分类。\n\nA. MEEP 是 P-完全的，因为任意的括号嵌套强加了一个顺序求值顺序，这与其他 P-完全问题（如通用电路求值问题）类似。\n\nB. MEEP 属于 NC，因为 `max` 运算符满足结合律，这使得计算可以被重构并高效地并行执行，而不管初始的括号如何。\n\nC. MEEP 不在 P 中，因此不可能是 P-完全的，因为评估一个深度嵌套的表达式所需的步骤数与深度成正比，而深度可能与变量数量呈指数关系。\n\nD. MEEP 是 #P-完全的，因为该问题等价于计算在一个集合中找到最大元素所需的比较次数。\n\nE. MEEP 仅在表达式对应于一个平衡二叉树时才属于 NC。对于任意嵌套（不平衡）的表达式，该问题是 P-完全的。", "solution": "我们给定一个在整型变量 $x_{1},\\dots,x_{n}$ 上使用二元运算符 $\\max(\\cdot,\\cdot)$ 的完全括号化的表达式，并要求计算其最终值。关键的代数性质是 $\\max$ 满足结合律和交换律：\n$$\n\\max(a,\\max(b,c))=\\max(\\max(a,b),c)=\\max(a,b,c),\n$$\n并且它也满足幂等性：\n$$\n\\max(a,a)=a.\n$$\n因此，对于任何仅由应用于 $\\{x_{1},\\dots,x_{n}\\}$ 中变量（可能包含重复）的 $\\max$ 构建的完全括号化表达式 $E$，其值仅取决于出现的变量的多重集，并等于这些值的全局最大值。等价地，\n$$\n\\mathrm{MEEP}(E)=\\max\\{x_{i} : x_{i} \\text{ appears in } E\\}.\n$$\n\n为了对该问题进行分类，我们观察到计算 $n$ 个整数的最大值是高效可并行的。一个标准的并行归约算法使用 $O(n)$ 个处理器在 $O(\\log n)$ 时间内计算出最大值：定义 $y_{i}^{(0)}=x_{i}$ 对于 $1 \\le i \\le n$，并在每一轮 $t \\ge 1$ 中设置\n$$\ny_{i}^{(t)}=\\max\\bigl(y_{2i-1}^{(t-1)},\\,y_{2i}^{(t-1)}\\bigr)\n\\quad \\text{for} \\quad 1 \\le i \\le \\left\\lfloor \\frac{n}{2^{t}} \\right\\rfloor.\n$$\n经过 $T=\\lceil \\log_{2} n \\rceil$ 轮后，我们得到\n$$\ny_{1}^{(T)}=\\max_{1 \\le i \\le n} x_{i}.\n$$\n该算法在多项式数量的处理器上以多对数时间运行，因此它属于 $NC$。初始的括号形式不会限制并行求值，因为结合律保证了重新组合括号以形成平衡的归约树不会改变结果。\n\n因此：\n- 选项 A 是不正确的：结合律打破了任何所谓的内在顺序性。\n- 选项 C 是不正确的：任何此类表达式的深度最多与 $n$ 呈线性关系，并且无论如何我们都可以在多对数并行时间内进行求值。\n- 选项 D 是不正确的：MEEP 要求的是最大值，而不是一个计数；它不是一个计数问题，这里也不存在到 $\\#P$ 函数的归约。\n- 选项 E 是不正确的：即使对于不平衡的表达式，结合律也允许进行平衡的并行求值，因此该问题仍然属于 $NC$。\n\n因此，最准确的分类是 MEEP 属于 $NC$，因为结合律使得无论初始括号如何，都能进行高效的并行求值。", "answer": "$$\\boxed{B}$$", "id": "1433477"}, {"introduction": "在看了一个可以被并行化的问题之后，我们现在转向一个真正难以并行化的问题。并查集（Union-Find）数据结构中的“指针追逐”（pointer chasing）是内在顺序计算的典型例子[@problem_id:1433739]。在这个练习中，你需要追踪一个不带路径压缩优化的并查集操作序列，这迫使你一步一步地沿着父指针链来找到一个元素的根。这个过程直观地展示了P-完备问题的核心特征：每一步计算都严格依赖于前一步的结果，从而阻碍了并行处理。", "problem": "在并行计算的研究中，理解顺序依赖关系至关重要。并查集数据结构提供了此类依赖关系的一个经典示例。考虑一个包含 $N=16$ 个元素的系统，其索引从 0 到 15。这些元素使用并查集数据结构被组织成不相交的集合。\n\n最初，每个元素 $i \\in \\{0, 1, ..., 15\\}$ 都各自属于一个独立的集合。系统状态由一个父节点数组 $p$ 和一个秩数组 $r$ 来维护。对于每个元素 $i$，$p[i]$ 是其父节点，$r[i]$ 是其秩。最初，对于所有的 $i$，都有 $p[i] = i$ 且 $r[i] = 0$。\n\n`find(i)` 操作通过遍历父节点指针，直到到达一个其父节点是自身的元素，从而返回包含元素 $i$ 的集合的代表（或根节点）。在本问题中，`find` 操作 **不** 执行路径压缩。\n\n集合通过 `union(u, v)` 操作进行合并。该操作首先找到 $u$ 和 $v$ 的代表，我们称它们为 $r_u = \\text{find}(u)$ 和 $r_v = \\text{find}(v)$。如果 $r_u$ 和 $r_v$ 不同，则根据 **按秩合并** 的启发式规则和一个特定的平局打破规则来合并集合：\n- 如果 $r[r_u]  r[r_v]$，则将 $r_u$ 的父节点设置为 $r_v$。\n- 如果 $r[r_u] > r[r_v]$，则将 $r_v$ 的父节点设置为 $r_u$。\n- 如果 $r[r_u] = r[r_v]$，则将索引较小的根节点的父节点设置为索引较大的根节点，并将索引较大的根节点的秩加一。\n\n一个包含 15 个 `union` 操作的特定序列按给定顺序在系统上执行：\n1.  `union(1, 0)`\n2.  `union(3, 2)`\n3.  `union(5, 4)`\n4.  `union(7, 6)`\n5.  `union(9, 8)`\n6.  `union(11, 10)`\n7.  `union(13, 12)`\n8.  `union(15, 14)`\n9.  `union(2, 0)`\n10. `union(6, 4)`\n11. `union(10, 8)`\n12. `union(14, 12)`\n13. `union(4, 0)`\n14. `union(12, 8)`\n15. `union(8, 0)`\n\n在这整个操作序列完成后，包含元素 7 的集合的代表元素的索引是什么？", "solution": "我们将通过给定的 15 个操作序列来追踪并查集数据结构的状态，特别是父节点数组 `p` 和秩数组 `r`。共有 $N=16$ 个元素，索引从 0 到 15。\n\n**初始状态：**\n每个元素都是自己的父节点，并且秩为 0。\n$p = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]$\n$r = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]$\n\n`find(i)` 操作从 $i$ 开始沿着父节点指针找到其根节点。在没有路径压缩的情况下，它不会改变 `p` 数组。`union(u, v)` 操作根据它们根节点的秩来合并 $u$ 和 $v$ 的集合，并遵循指定的平局打破规则：如果秩相等，则索引较小的根节点指向索引较大的根节点。\n\n**操作 1-8：两两合并**\n\n这些操作合并了相邻的元素对。在每种情况下，两个元素都是秩为 0 的根节点。应用平局打破规则。\n1. `union(1, 0)`: 根节点是 1 和 0。秩相等（都为 0）。由于 $0  1$，我们设置 $p[0] = 1$，并且 $r[1]$ 变为 1。\n2. `union(3, 2)`: 根节点是 3 和 2。秩相等（都为 0）。由于 $2  3$，我们设置 $p[2] = 3$，并且 $r[3]$ 变为 1。\n3. `union(5, 4)`: 根节点是 5 和 4。秩相等（都为 0）。由于 $4  5$，我们设置 $p[4] = 5$，并且 $r[5]$ 变为 1。\n4. `union(7, 6)`: 根节点是 7 和 6。秩相等（都为 0）。由于 $6  7$，我们设置 $p[6] = 7$，并且 $r[7]$ 变为 1。\n5. `union(9, 8)`: 根节点是 9 和 8。秩相等（都为 0）。由于 $8  9$，我们设置 $p[8] = 9$，并且 $r[9]$ 变为 1。\n6. `union(11, 10)`: 根节点是 11 和 10。秩相等（都为 0）。由于 $10  11$，我们设置 $p[10] = 11$，并且 $r[11]$ 变为 1。\n7. `union(13, 12)`: 根节点是 13 和 12。秩相等（都为 0）。由于 $12  13$，我们设置 $p[12] = 13$，并且 $r[13]$ 变为 1。\n8. `union(15, 14)`: 根节点是 15 和 14。秩相等（都为 0）。由于 $14  15$，我们设置 $p[14] = 15$，并且 $r[15]$ 变为 1。\n\n完成这 8 个操作后，奇数索引的元素成为秩为 1 的根节点，并且每个都是其前面偶数索引元素的父节点。\n- 根节点: {1, 3, 5, 7, 9, 11, 13, 15}\n- 秩: 对于奇数 $i$，$r[i]=1$，否则为 0。\n- 根节点的父节点: 对于奇数 $i$，$p[i]=i$。\n- 非根节点的父节点: $p[0]=1, p[2]=3, p[4]=5, p[6]=7, p[8]=9, p[10]=11, p[12]=13, p[14]=15$。\n\n**操作 9-12：第一层合并**\n\n这些操作合并了上面创建的大小为 2 的集合。\n9. `union(2, 0)`: `find(2)` 的结果是 3。`find(0)` 的结果是 1。我们合并根节点 3 和 1。两者秩都为 1。由于 $1  3$，我们设置 $p[1] = 3$，并且 $r[3]$ 变为 2。\n10. `union(6, 4)`: `find(6)` 的结果是 7。`find(4)` 的结果是 5。我们合并根节点 7 和 5。两者秩都为 1。由于 $5  7$，我们设置 $p[5] = 7$，并且 $r[7]$ 变为 2。\n11. `union(10, 8)`: `find(10)` 的结果是 11。`find(8)` 的结果是 9。我们合并根节点 11 和 9。两者秩都为 1。由于 $9  11$，我们设置 $p[9] = 11$，并且 $r[11]$ 变为 2。\n12. `union(14, 12)`: `find(14)` 的结果是 15。`find(12)` 的结果是 13。我们合并根节点 15 和 13。两者秩都为 1。由于 $13  15$，我们设置 $p[13] = 15$，并且 $r[15]$ 变为 2。\n\n完成这 4 个操作后，我们有 4 个集合，每个大小为 4。\n- 根节点: {3, 7, 11, 15}\n- 秩: $r[3]=2, r[7]=2, r[11]=2, r[15]=2$。所有其他秩为 0 或 1。\n- 父节点链现在更长了。例如，`find(0)` 遵循路径 $0 \\to 1 \\to 3$。\n\n**操作 13-14：第二层合并**\n\n13. `union(4, 0)`: `find(4)` 遍历 $4 \\to 5 \\to 7$，所以根是 7。`find(0)` 遍历 $0 \\to 1 \\to 3$，所以根是 3。我们合并根节点 7 和 3。两者秩都为 2。由于 $3  7$，我们设置 $p[3] = 7$，并且 $r[7]$ 变为 3。\n14. `union(12, 8)`: `find(12)` 遍历 $12 \\to 13 \\to 15$，根是 15。`find(8)` 遍历 $8 \\to 9 \\to 11$，根是 11。我们合并根节点 15 和 11。两者秩都为 2。由于 $11  15$，我们设置 $p[11] = 15$，并且 $r[15]$ 变为 3。\n\n现在我们有两个大集合，每个大小为 8。\n- 根节点: {7, 15}\n- 秩: $r[7]=3, r[15]=3$。\n\n**操作 15：最终合并**\n\n15. `union(8, 0)`: `find(8)` 遍历 $8 \\to 9 \\to 11 \\to 15$，根是 15。`find(0)` 遍历 $0 \\to 1 \\to 3 \\to 7$，根是 7。我们合并最后两个根节点 15 和 7。两者秩都为 3。由于 $7  15$，我们设置 $p[7] = 15$，并且 $r[15]$ 变为 4。\n\n**最终状态与答案**\n\n所有操作结束后，全部 16 个元素都被合并到了一个单一的根节点下。最后一个操作将根节点 7 的父节点设置为 15。因此，15 是所有元素的唯一代表。\n\n问题要求的是包含元素 7 的集合的代表元素。我们可以通过从 7 开始追踪父节点指针直到到达根节点来找到它。\n- 元素是 7。\n- 所有操作结束后，我们查看 $p[7]$。最后一个操作设置了 $p[7] = 15$。\n- 然后我们查看 $p[15]$。由于 15 是最终的根节点，所以 $p[15]$ 仍然是 15。\n路径是 $7 \\to 15$。包含元素 7 的树的根是 15。", "answer": "$$\\boxed{15}$$", "id": "1433739"}, {"introduction": "现在，我们将顺序依赖性的概念推广到更抽象的代数结构中。此问题要求你对一个在非结合性运算下定义的表达式进行求值[@problem_id:1433489]。与我们第一个例子中可交换计算顺序的 `max` 运算不同，这里的运算不满足结合律，意味着括号决定的运算顺序至关重要且不可更改。这个练习揭示了为何对一个通用代数结构上的表达式求值是P-完备的，因为它模拟了“电路求值问题”（Circuit Value Problem）的计算依赖性，是P-完备理论的基石之一。", "problem": "考虑一个定义在元素集合 $S = \\{a, b, c\\}$ 上的有限代数结构。一个二元运算 $*$ 在此集合上定义如下：\n$a * a = a, \\quad a * b = c, \\quad a * c = b$\n$b * a = a, \\quad b * b = b, \\quad b * c = c$\n$c * a = b, \\quad c * b = a, \\quad c * c = a$\n\n注意，此运算不一定是结合的。给定一个由四个元素组成的未加括号的表达式：$E = a * b * c * a$。该表达式的一个有效括号化完全指定了运算的执行顺序。例如，一种括号化是 $((a*b)*c)*a$。\n\n确定表达式 $E$ 的所有不同括号化中，计算结果为元素 $c$ 的总数。\n\nA. 0\n\nB. 1\n\nC. 2\n\nD. 3\n\nE. 5", "solution": "我们有集合 $S=\\{a,b,c\\}$，其上的二元运算 $*$ 定义如下：\n$$a*a=a,\\quad a*b=c,\\quad a*c=b,$$\n$$b*a=a,\\quad b*b=b,\\quad b*c=c,$$\n$$c*a=b,\\quad c*b=a,\\quad c*c=a.$$\n考虑 $E=a*b*c*a$。四个因子的所有完全括号化有：\n1. $(((a*b)*c)*a)$\n2. $((a*(b*c))*a)$\n3. $((a*b)*(c*a))$\n4. $(a*((b*c)*a))$\n5. $(a*(b*(c*a)))$\n逐个计算：\n1. $a*b=c$，则 $(a*b)*c=c*c=a$，则 $((a*b)*c)*a=a*a=a$。\n2. $b*c=c$，则 $a*(b*c)=a*c=b$，则 $(a*(b*c))*a=b*a=a$。\n3. $a*b=c$ 且 $c*a=b$，则 $(a*b)*(c*a)=c*b=a$。\n4. $b*c=c$，则 $(b*c)*a=c*a=b$，则 $a*((b*c)*a)=a*b=c$。\n5. $c*a=b$，则 $b*(c*a)=b*b=b$，则 $a*(b*(c*a))=a*b=c$。\n恰好有两个括号化（4和5）的计算结果为 $c$。因此，总数为 $2$，对应选项C。", "answer": "$$\\boxed{C}$$", "id": "1433489"}]}