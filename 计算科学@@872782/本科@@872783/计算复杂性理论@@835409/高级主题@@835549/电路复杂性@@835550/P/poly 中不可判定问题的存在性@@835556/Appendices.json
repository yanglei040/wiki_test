{"hands_on_practices": [{"introduction": "要理解 P/poly 如何能解决不可判定问题，最简单的方法就是从“元语言”（tally language）入手。元语言是仅由单一符号（如 '1'）组成的字符串构成的语言。由于在任意给定的长度 $n$ 下，至多只有一个可能的字符串（即 $1^n$），所有解决不可判定性所需的非计算信息都可以被压缩到一位“建议”（advice）中。这个练习 [@problem_id:1423583] 将引导你构建并分析这样一个基础而又关键的例子。", "problem": "在计算复杂性理论中，我们分析语言的性质以理解计算的极限。本问题涉及一个基于图灵机行为构建的特定语言。\n\n假设所有确定性图灵机（TM）有一个标准的、可计算的枚举，记为 $M_1, M_2, M_3, \\dots$。考虑字母表 $\\{0,1\\}$ 上的语言 $L$ 定义如下：\n$$L = \\{1^n \\mid n \\ge 1 \\text{ 且第 } n\\text{ 个图灵机 } M_n \\text{ 在输入为空串时停机} \\}$$\n注意，字符串 $1^n$ 是一个由 $n$ 个连续的“1”组成的序列。\n\n为方便理解，我们提供以下标准定义：\n- **可判定语言**（Decidable Language）：如果存在一个图灵机，它对任何给定的输入字符串总能停机，并正确判断该字符串是否属于该语言，则该语言是可判定的。一个众所周知的事实是，停机问题是不可判定的。\n- **稀疏语言**（Sparse Language）：如果存在一个多项式 $p(n)$，使得对于所有 $n \\ge 1$，语言 $S$ 中长度为 $n$ 的字符串数量最多为 $p(n)$，那么该语言 $S$ 是稀疏的。这表示为 $|S \\cap \\{0,1\\}^n| \\le p(n)$。\n- **类 P/poly**：如果存在一个布尔电路序列 $\\{C_n\\}_{n \\ge 1}$ 和一个多项式 $q(n)$，使得对于每个 $n \\ge 1$ 都满足：(1) 电路 $C_n$ 的大小（门的数量）最多为 $q(n)$，并且 (2) 对于任何长度为 $n$ 的输入字符串 $x$，当且仅当 $x \\in A$ 时，电路 $C_n$ 输出 1，则语言 $A$ 属于复杂性类 P/poly。\n\n基于这些定义，以下关于语言 $L$ 的陈述中，哪一个是完整且正确的描述？\n\nA. $L$ 是可判定的、稀疏的，并且属于 P/poly。\n\nB. $L$ 是不可判定的、稀疏的，并且属于 P/poly。\n\nC. $L$ 是不可判定的、稀疏的，但不属于 P/poly。\n\nD. $L$ 是不可判定的、非稀疏的，并且属于 P/poly。\n\nE. $L$ 是可判定的、非稀疏的，并且不属于 P/poly。", "solution": "我们从可判定性、稀疏性和是否属于 P/poly 这几个方面来分析语言 $L=\\{1^n \\mid n\\ge 1\\text{ 且 }M_n\\text{ 在空输入上停机}\\}$。\n\n**不可判定性**：判定 $1^n$ 是否属于 $L$ 等价于判定第 $n$ 个图灵机 $M_n$ 是否在空输入上停机。这是一个版本的停机问题，是不可判定的。因此，$L$ 是不可判定的。\n\n**稀疏性**：对于每个长度 $n$，在所有长度为 $n$ 的字符串中，语言 $L$ 要么包含 $1^n$ 这一个字符串，要么不包含任何字符串。因此，对于所有 $n\\ge 1$，都有 $|L \\cap \\{0,1\\}^n| \\le 1$。取多项式 $p(n)=1$，这满足稀疏语言的定义。因此，$L$ 是稀疏的。\n\n**属于 P/poly**：对于每个输入长度 $n$，我们需要一个多项式大小的电路 $C_n$ 来判定语言 $L$。对于一个固定的 $n$，命题“$M_n$ 在空输入上停机”要么为真，要么为假。我们可以将这个真值（是/否）硬编码到电路中。\n- 如果 $M_n$ 停机，则 $1^n \\in L$。我们设计的电路 $C_n$ 在输入为 $1^n$ 时输出1，在其他任何长度为 $n$ 的输入上输出0。\n- 如果 $M_n$ 不停机，则 $1^n \\notin L$。我们设计的电路 $C_n$ 对所有长度为 $n$ 的输入都输出0。\n这两种情况下的电路都可以用 $O(n)$ 个门实现（例如，通过与门检查输入是否全为1）。由于电路大小是 $n$ 的多项式，并且这样的电路对每个 $n$ 都存在，所以 $L \\in \\text{P/poly}$。\n\n综合这三个事实，$L$ 是不可判定的、稀疏的，并且属于 P/poly。因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1423583"}, {"introduction": "在理解了元语言的构造后，我们自然会问：这种技术是否适用于结构更复杂的语言？此练习 [@problem_id:1423614] 将挑战你构建一个在每个长度 $n$ 上都*恰好*包含一个字符串的不可判定语言。这与元语言的“至多一个”不同，它要求我们在多个候选项中进行选择，从而让你更深入地理解建议字符串如何精确地编码不可计算的信息。", "problem": "考虑所有图灵机的一个标准枚举，其中 $M_i$ 表示第 $i$ 台图灵机，其中 $i \\in \\mathbb{N} = \\{1, 2, 3, \\ldots\\}$。令 $U$ 为在空字符串输入下会停机的图灵机的索引集合。形式上，$U = \\{i \\in \\mathbb{N} \\mid M_i \\text{ 在空输入上停机}\\}$。集合 $U$ 是一个著名的自然数不可判定集。\n\n考虑字母表 $\\Sigma = \\{0, 1\\}$ 上的以下语言。这些语言中哪一个满足以下所有三个性质？\n1. 该语言是不可判定的。\n2. 该语言属于复杂性类 P/poly。\n3. 对于每个整数 $n \\ge 1$，该语言恰好包含一个长度为 $n$ 的字符串。\n\n令 $\\mathrm{bin}(i)$ 表示整数 $i \\ge 1$ 的标准二进制表示，不含不必要的前导零。\n\nA) $L_A = \\{ 1^n \\mid n \\in U \\}$\n\nB) $L_B = \\{ w \\in \\{0, 1\\}^* \\mid |w| \\in U \\}$\n\nC) $L_C = \\{ 1^n \\mid n \\in U \\} \\cup \\{ 0^n \\mid n \\in \\mathbb{N} \\setminus U \\}$\n\nD) $L_D = \\{ \\mathrm{bin}(i) \\mid i \\in U \\}$\n\nE) $L_E = \\{ 0^n 1^n \\mid n \\in U \\}$", "solution": "我们根据三个要求的性质来分析每个候选语言：不可判定性、$\\text{P/poly}$ 成员资格，以及“每种长度一个”的性质（对于 $\\forall n \\ge 1$，语言中恰好有一个长度为 $n$ 的字符串）。\n\n首先，回忆一下 $U = \\{ i \\in \\mathbb{N} \\mid M_{i} \\text{ 在空输入上停机} \\}$ 是不可判定的。\n\n**检查“每种长度一个”的性质 (性质 3)：**\n\n- 对于 $L_A = \\{ 1^n \\mid n \\in U \\}$：对于每个长度 $n$，$L_A$ 包含 $1^n$ 当且仅当 $n \\in U$；否则它不包含任何长度为 $n$ 的字符串。因此，某些长度可能没有字符串，不满足性质 3。\n\n- 对于 $L_B = \\{ w \\in \\{0,1\\}^* \\mid |w| \\in U \\}$：对于给定的长度 $n$，要么所有 $2^n$ 个字符串都在语言中（如果 $n \\in U$），要么一个都不在（如果 $n \\notin U$）。不满足性质 3。\n\n- 对于 $L_C = \\{ 1^n \\mid n \\in U \\} \\cup \\{ 0^n \\mid n \\in \\mathbb{N} \\setminus U \\}$：对于每个长度 $n \\ge 1$，如果 $n \\in U$，则语言包含 $1^n$；如果 $n \\notin U$，则语言包含 $0^n$。在任何情况下，它都恰好包含一个长度为 $n$ 的字符串（要么是 $1^n$，要么是 $0^n$）。满足性质 3。\n\n- 对于 $L_D = \\{ \\mathrm{bin}(i) \\mid i \\in U \\}$：对于长度 $n$，语言包含的字符串是那些 $i$ 的二进制表示，其中 $2^{n-1} \\le i \\le 2^n - 1$ 且 $i \\in U$。这种 $i$ 的数量可以是零、一或多个，因此不能保证每种长度恰好一个。不满足性质 3。\n\n- 对于 $L_E = \\{ 0^n 1^n \\mid n \\in U \\}$：该语言只包含偶数长度（$2n$）的字符串。对于所有奇数长度，没有字符串。不满足性质 3。\n\n因此，只有 $L_C$ 满足性质 3。\n\n**验证 $L_C$ 的其余两个性质：**\n\n- **不可判定性 (性质 1)**：我们可以通过 $L_C$ 来判定 $U$。给定一个整数 $n$，要判断 $n$ 是否在 $U$ 中，只需检查字符串 $1^n$ 是否属于 $L_C$。如果 $1^n \\in L_C$，那么根据定义 $n \\in U$。如果 $1^n \\notin L_C$，那么 $n \\notin U$。如果 $L_C$ 是可判定的，这将提供一个判定 $U$ 的算法，但这与 $U$ 的不可判定性相矛盾。因此，$L_C$ 是不可判定的。\n\n- **$\\text{P/poly}$ 成员资格 (性质 2)**：对于每个输入长度 $n$，语言 $L_C$ 中恰好有一个字符串 $s_n$（$s_n=1^n$ 或 $s_n=0^n$）。我们可以为每个 $n$ 构建一个非一致性电路 $C_n$。这个电路将正确的字符串 $s_n$ 硬编码，并实现一个等价性测试：当且仅当输入等于 $s_n$ 时接受。这个测试可以在 $O(n)$ 大小的电路中完成，这是 $n$ 的多项式。因此，$L_C \\in \\text{P/poly}$。\n\n因此，只有语言 $L_C$ 满足所有三个性质。", "answer": "$$\\boxed{C}$$", "id": "1423614"}, {"introduction": "我们已经看到，少量的建议就能让多项式时间算法解决某些不可判定问题。但“少量”到底是多少？所有 P/poly 中的不可判定语言都只需要一位建议吗？这个高级练习 [@problem_id:1423621] 探讨了建议的“数量”问题。通过对比两个不同的不可判定语言，你将发现解决它们所需的建议大小可以截然不同——从常数大小到随输入规模对数增长。这揭示了非一致性计算模型内部更精细的结构。", "problem": "在计算复杂性理论中，P/poly 类包含的语言可以由一个多项式时间算法判定，该算法会接受一份“少量”的额外信息，称为“建议”，这份建议仅取决于输入的长度。这个框架使我们能够研究甚至不可判定问题的复杂性。\n\n如果存在一个多项式时间图灵机 (TM) $M$，对于任何输入串 $x \\in \\Sigma^*$，该图灵机 $M$ 在输入为 $\\langle x, a(|x|) \\rangle$ 时能正确判定 $x \\in L$ 是否成立，那么我们称语言 $L \\subseteq \\Sigma^*$ 可由一个建议函数 $a: \\mathbb{N} \\to \\Gamma^*$ 在多项式时间内判定。对于大小为 $n$ 的输入，建议的长度为 $|a(n)|$。我们将对大小为 $n$ 的输入，在多项式时间内判定语言 $L$ 所需的最小可能建议长度表示为 $f_L(n)$。\n\n令 $\\{M_i\\}_{i \\in \\mathbb{N}}$ 为所有图灵机的标准枚举，其中每个整数 $i$ 是机器 $M_i$ 的唯一描述。令 $K$ 为非负整数 $i$ 的集合，其中图灵机 $M_i$ 在接收其自身描述 $i$ 作为输入时会停机。集合 $K$ 是不可判定的。\n\n考虑以下两个语言：\n1.  一个一元语言 $L_1 \\subseteq \\{1\\}^*$ 定义为 $L_1 = \\{1^n \\mid n \\in K\\}$。\n2.  一个语言 $L_2 \\subseteq \\{0,1\\}^*$。令 $\\chi_K$ 为 $K$ 的无限特征序列，其中第 $i$ 位（从0开始索引）在 $i \\in K$ 时为 1，否则为 0。令 $\\chi_K[0..m-1]$ 表示 $\\chi_K$ 的长度为 $m$ 的前缀。语言 $L_2$ 定义为 $L_2 = \\{w \\in \\{0,1\\}^* \\mid |w|=n, n \\geq 2, \\text{ 且 } w \\text{ 的长度为 } \\lfloor \\log_2 n \\rfloor \\text{ 的前缀是 } \\chi_K[0..\\lfloor \\log_2 n \\rfloor - 1]\\}$。我们认为对于任何长度为 $n2$ 的字符串，$L_2$ 为空。\n\n令 $f_1(n)$ 和 $f_2(n)$ 分别为在多项式时间内判定 $L_1$ 和 $L_2$ 所需的最小建议长度，作为输入长度 $n$ 的函数。以下哪个选项正确描述了这些函数的渐进增长？\n\nA. $f_1(n) = \\Theta(1)$ 和 $f_2(n) = \\Theta(1)$\n\nB. $f_1(n) = \\Theta(1)$ 和 $f_2(n) = \\Theta(\\log n)$\n\nC. $f_1(n) = \\Theta(\\log n)$ 和 $f_2(n) = \\Theta(\\log n)$\n\nD. $f_1(n) = \\Theta(1)$ 和 $f_2(n) = \\Theta(n)$\n\nE. $L_1$ 和 $L_2$ 是不可判定的，因此即使有建议也无法在多项式时间内判定。", "solution": "我们回顾一下，建议函数 $a:\\mathbb{N}\\to\\Gamma^{*}$ 为每个输入长度 $n$ 分配一个字符串 $a(n)$，而一个多项式时间图灵机 $M$ 在接收到 $\\langle x,a(n)\\rangle$ 时，必须对每个长度为 $n$ 的输入 $x$ 正确判定 $L$。函数 $f_{L}(n)$ 是对于长度为 $n$ 的输入，可以达到的最小 $|a(n)|$（在所有能判定 $L$ 的对 $(M,a)$ 中）。\n\n**语言 $L_1$ (一元语言):** $L_1 = \\{1^n \\mid n \\in K\\}$。\n*   **上界**: 对于任何长度 $n$，只有一个可能的输入串 $1^n$。其成员资格仅取决于 $n$ 是否在 $K$ 中。我们可以定义建议 $a(n)$ 为一个比特：如果 $n \\in K$ 则为 '1'，否则为 '0'。一个多项式时间图灵机可以简单地输出这个建议比特。因此，建议长度为 1 即可。$f_1(n) \\le 1$，所以 $f_1(n) = O(1)$。\n*   **下界**: 假设 $f_1(n)=0$。这意味着存在一个多项式时间图灵机，无需任何建议即可判定 $L_1$。这等同于说 $L_1$ 是可判定的，但这与 $K$ 的不可判定性相矛盾。因此，必须有 $f_1(n) \\ge 1$（至少对于无穷多个 $n$）。\n*   结合上界和下界，我们得出 $f_1(n) = \\Theta(1)$。\n\n**语言 $L_2$ (二元语言):** 对于 $|w|=n \\ge 2$，$w \\in L_2$ 当且仅当 $w$ 的长度为 $m=\\lfloor\\log_2 n\\rfloor$ 的前缀是 $\\chi_K[0..m-1]$。\n*   **上界**: 对于每个输入长度 $n$，判定条件依赖于字符串 $\\chi_K[0..m-1]$。我们可以将这个字符串本身作为建议。令 $a(n) = \\chi_K[0..\\lfloor\\log_2 n\\rfloor-1]$。这个建议的长度是 $m = \\lfloor\\log_2 n\\rfloor$。一个多项式时间图灵机在接收到输入 $w$ 和建议 $a(n)$ 后，只需提取 $w$ 的前 $m$ 位并与 $a(n)$ 比较即可。这个过程是多项式时间的。因此，$f_2(n) \\le \\lfloor\\log_2 n\\rfloor = O(\\log n)$。\n*   **下界**: 固定任何一个用于判定 $L_2$ 的正确对 $(M,a)$。令 $m=\\lfloor\\log_2 n\\rfloor$，并记 $s_m=\\chi_K[0..m-1]$。一个标准的算法信息论结果是，停机集 $K$ 的特征序列前缀是算法随机的（不可压缩）。这意味着，存在一个常数 $c$，使得对于无穷多个 $m$，其条件柯尔莫哥洛夫复杂度 $C(s_m \\mid m)$ 满足 $C(s_m \\mid m) \\ge m-c$。如果对于这些 $m$ 对应的 $n$，建议的长度 $|a(n)|$ 显著小于 $m$（例如， $|a(n)|  m - c - d$ 对于某个常数 $d$），那么我们可以用一个较短的程序来生成 $s_m$：这个程序包含了判定器 $M$ 的描述、建议 $a(n)$ 和长度 $m$。这个程序的总长度会小于 $m-c$，从而与 $s_m$ 的复杂度下界矛盾。因此，建议的长度 $|a(n)|$ 必须至少为 $\\Omega(m) = \\Omega(\\log n)$。\n*   结合上界和下界，我们得出 $f_2(n) = \\Theta(\\log n)$。\n\n因此， $f_1(n) = \\Theta(1)$ 和 $f_2(n) = \\Theta(\\log n)$。", "answer": "$$\\boxed{B}$$", "id": "1423621"}]}