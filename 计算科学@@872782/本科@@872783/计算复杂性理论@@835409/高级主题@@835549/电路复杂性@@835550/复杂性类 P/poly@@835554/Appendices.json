{"hands_on_practices": [{"introduction": "理解P/poly这类非均匀复杂性类的最佳方式之一就是亲手构建电路族。这个练习将从一个基础但至关重要的问题开始：我们将为一个语言设计电路，该语言的成员资格仅取决于输入字符串的*长度*，而与其内容无关。通过这个练习，你将揭示非均匀性的一个核心特征：电路$C_n$可以为其指定的输入长度$n$高度特化，有时甚至可以简化到极致，从而清晰地展示P/poly的“非均匀”本质。[@problem_id:1454195]", "problem": "在计算复杂性理论中，多项式规模电路的语言类（记作 P/poly）在理解有效计算的极限方面扮演着至关重要的角色。如果存在一个布尔电路族 $\\{C_n\\}_{n \\ge 0}$ 和一个多项式 $p(n)$，使得以下条件成立，则二进制字母表 $\\{0, 1\\}$ 上的语言 $L$ 属于 P/poly：\n1. 对于每个非负整数 $n$，电路 $C_n$ 有 $n$ 个输入。\n2. 每个电路 $C_n$ 的大小（定义为其与门、或门和非门的总数）最多为 $p(n)$。\n3. 对于任何长度为 $n$ 的二进制字符串 $w$，电路 $C_n$ 输出 1 当且仅当 $w \\in L$。\n\n考虑语言 $L_{parity}$，它被定义为所有长度为偶数的二进制字符串的集合。\n$L_{parity} = \\{ w \\in \\{0, 1\\}^* \\mid |w| \\text{ is an even number} \\}$\n\n对于这个语言 $L_{parity}$，必须存在一个判定它的电路族 $\\{C_n\\}_{n \\ge 1}$。以下哪个陈述最能描述对于 $n \\ge 1$ 的电路 $C_n$ 的最小可能大小？\n\nA. $C_n$ 的大小必须随 $n$ 线性增长，即大小为 $\\Theta(n)$。\nB. $C_n$ 的大小可以是一个与 $n$ 无关的常数。\nC. $C_n$ 的大小必须随 $n$ 平方增长，即大小为 $\\Theta(n^2)$。\nD. $C_n$ 的大小必须随 $n$ 指数增长，即大小为 $\\Theta(2^n)$。\nE. 不存在这样的电路族，因为该语言是非一致的。", "solution": "给定语言 $L_{parity} = \\{ w \\in \\{0,1\\}^{*} \\mid |w| \\text{ is even} \\}$。对于一个固定的输入长度 $n$，由 $C_{n}$ 计算的判定函数是\n$$\nf_{n}(w) =\n\\begin{cases}\n1  \\text{if } n \\text{ is even},\\\\\n0  \\text{if } n \\text{ is odd},\n\\end{cases}\n$$\n对于所有 $w \\in \\{0,1\\}^{n}$。因此，对于每个固定的 $n$，$f_{n}$ 是 $\\{0,1\\}^{n}$ 上的一个常数函数，与输入位无关。\n\n要用带有与门、或门和非门的布尔电路来实现这样的函数：\n- 如果 $n$ 是偶数，定义 $C_{n}$ 输出重言式 $x_{1} \\vee \\neg x_{1}$，其值恒为 $1$。这使用一个非门和一个或门，所以大小是一个与 $n$ 无关的常数（具体为 $2$）。\n- 如果 $n$ 是奇数，定义 $C_{n}$ 输出矛盾式 $x_{1} \\wedge \\neg x_{1}$，其值恒为 $0$。这使用一个非门和一个与门，所以大小同样是一个与 $n$ 无关的常数（具体为 $2$）。\n\n因此，存在一个判定 $L_{parity}$ 的电路族 $\\{C_{n}\\}_{n \\ge 1}$，使得 $C_{n}$ 的大小受一个与 $n$ 无关的常数限制。这表明线性、平方或指数增长是不必要的。此外，陈述 E 是不正确的，因为 P/poly 明确允许非一致电路族，而在这里，一个简单的非一致常数大小的电路族就足够了。\n\n因此，正确的选项是电路大小可以是一个与 $n$ 无关的常数。", "answer": "$$\\boxed{B}$$", "id": "1454195"}, {"introduction": "在我们理解了电路如何针对特定长度进行特化之后，下一个自然的问题是：这种特化能编码多复杂的信息？此练习将探讨这一问题，要求我们分析一个特殊的语言，其定义依赖于将输入字符串与一个为每个长度预先定义的、任意的“阈值”字符串进行比较。这个实践深刻地展示了P/poly中“建议”(advice)的力量，即电路本身可以作为信息的载体，使得该复杂性类能够处理那些像P这样的均匀模型无法解决的问题。[@problem_id:1454160]", "problem": "在计算复杂性理论中，P/poly 类（非一致性多项式时间）表示可以由一个多项式大小的布尔线路族判定的语言。更形式化地，一个语言 $L \\subseteq \\{0,1\\}^*$ 属于 P/poly，如果存在一个多项式 $p(n)$ 和一个线路族 $\\{C_n\\}_{n \\in \\mathbb{N}}$，使得对于每个自然数 $n$：\n1. 线路 $C_n$ 最多有 $p(n)$ 个门。\n2. 对于任意长度为 $n$ 的字符串 $x$，如果 $x \\in L$，线路 $C_n$ 输出 1；如果 $x \\notin L$，则输出 0。\n\n注意，对于每个输入长度 $n$，线路 $C_n$ 都可以是不同的。\n\n考虑一个语言 $L$，它由一个任意的、固定的“阈值”字符串序列 $\\{s_n\\}_{n \\in \\mathbb{N}}$ 定义，其中每个 $s_n$ 是一个长度为 $n$ 的二进制字符串。语言 $L$ 是所有 $L_n$（对于 $n \\in \\mathbb{N}$）的并集，其中 $L_n$ 定义为：\n$$L_n = \\{x \\in \\{0,1\\}^n \\mid x \\text{ is lexicographically smaller than } s_n\\}$$\n例如，如果对于 $n=3$，固定的字符串是 $s_3 = 101$，那么字符串 $000, 001, 010, 011, 100$ 属于 $L_3$，而 $101, 110, 111$ 不属于。\n\n字符串序列 $\\{s_n\\}$ 是任意的；不要求它以任何方式是可计算的。下列哪个陈述提供了正确的理由来解释为什么语言 $L$ 必须属于 P/poly？\n\nA. 该语言属于 P/poly，因为可以构造一个单一的多项式时间图灵机。这台机器接受一个输入字符串 $x$ 和相应的字符串 $s_{|x|}$，按字典序比较它们，并相应地接受或拒绝。\nB. 该语言不一定属于 P/poly，因为序列 $\\{s_n\\}$ 可以基于一个不可计算问题来定义（例如，$s_n$ 编码了关于停机问题的信息）。P/poly 线路族不能解决不可计算问题。\nC. 对于每个输入长度 $n$，特定的字符串 $s_n$ 可以被硬编码到专用线路 $C_n$ 的逻辑中。这个线路使用数量为 $n$ 的多项式的门将输入 $x$ 与硬编码的 $s_n$ 进行比较。这样一个线路族 $\\{C_n\\}$ 的存在将该语言置于 P/poly 中。\nD. 该语言不一定属于 P/poly，因为为了处理一个任意的字符串 $s_n$，线路 $C_n$ 需要包含关于所有 $2^n$ 种可能的阈值字符串的信息，这将需要指数数量级的门。", "solution": "为了确定为什么语言 $L$ 属于 P/poly，我们必须分析 P/poly 的定义，并看它如何应用于给定的语言 $L$。P/poly 类的核心是其“非一致性”，这意味着我们被允许为每个输入长度 $n$ 使用一个不同的线路 $C_n$。这个线路 $C_n$ 只需要对长度为 $n$ 的输入有效，并且可以将特定于长度 $n$ 的信息“内建”到其结构中。\n\n让我们评估每个选项：\n\n**选项 A：** 这个陈述是错误的。它描述了一个*一致性*的计算模型，这是复杂性类 P 的典型特征。它假定一个单一的图灵机可以获取字符串 $s_{|x|}$ 然后进行比较。然而，问题指明序列 $\\{s_n\\}$ 是任意的，并且可能不是可计算的。如果 $\\{s_n\\}$ 是一个不可计算的序列，没有单一的图灵机可以为任意 $n$ 生成 $s_n$。因此，这个理由只有在 $\\{s_n\\}$ 是一个 P 可计算序列时才成立，而这并没有保证。\n\n**选项 B：** 这个陈述是错误的。它对 P/poly 的能力做出了错误的断言。P/poly 的非一致性使其可以包含不可计算的语言。对于每个长度 $n$，线路 $C_n$ 以其自身结构的形式被提供了“建议”(advice)。这个建议可以是一个不可计算的比特序列。例如，由所有满足“第 $n$ 个图灵机停机”的字符串 $1^n$ 组成的不可计算语言，可以由一个线路族来判定，其中线路 $C_n$ 只是一个连接到 '1' 或 '0' 的导线，这取决于对 $n$ 预先计算（但不可计算）的答案。因此，$\\{s_n\\}$ 的潜在不可计算性并不是语言 $L$ 属于 P/poly 的障碍。\n\n**选项 D：** 这个陈述是错误的。它误解了线路族的工作方式。对于任何给定的 $n$，语言 $L_n$ 是由*一个特定的字符串* $s_n$ 定义的。线路 $C_n$ 不需要处理所有可能的 $s_n$ 选择；它只需要对作为语言定义一部分的那个单一、固定的 $s_n$ 有效。因此，该线路不需要编码关于所有 $2^n$ 种可能性的信息，只需要编码关于一种可能性的信息。\n\n**选项 C：** 这个陈述是正确的。它精确地抓住了非一致性原则。对于每个输入大小 $n$，字符串 $s_n$ 是固定的。我们可以设计一个线路 $C_n$，将这个特定的字符串 $s_n$ “硬编码”到其门电路中。该线路接受一个 $n$ 比特的输入 $x$，并将其与硬编码的 $s_n$ 进行比较。一个用于两个 $n$ 比特字符串的标准字典序比较线路可以用与 $n$ 成正比的门数量（即大小为 $O(n)$）来构建。这可以通过从最高有效位到最低有效位逐一比较 $x$ 和 $s_n$ 的比特，并使用逻辑门来确定 $x$ 是否是第一个在另一方为 '1' 的位置上为 '0' 的字符串来完成。由于该线路的大小是 $O(n)$，它受 $n$ 的一个多项式限制（例如，对于某个常数 $c$，$p(n) = c \\cdot n$）。因为我们可以为每个 $n$ 构建这样一个多项式大小的线路 $C_n$，所以语言 $L = \\bigcup_n L_n$ 满足属于 P/poly 的定义。字符串序列 $\\{s_n\\}$ 充当了被整合到线路族 $\\{C_n\\}$ 设计中的“建议”。", "answer": "$$\\boxed{C}$$", "id": "1454160"}, {"introduction": "我们已经看到，P/poly可以利用非均匀信息来解决问题。现在，我们将探索这一能力的最终推论：P/poly包含不可判定语言。在这个练习中，你将通过混合一个常规的可判定语言（回文）和一个经典的不可判定语言（停机问题的一个版本）来构建一个新语言。这项练习将巩固一个关于P/poly的关键且常常令人惊讶的属性，通过展示如何在这个类中构造一个不可判定的语言，我们澄清了非均匀复杂性与可计算性极限之间的深刻联系。[@problem_id:1454149]", "problem": "设 $\\Sigma = \\{0,1\\}$ 为字母表。我们将通过组合一个来自复杂性类 P 的著名语言和一个不可判定语言来定义一个新语言。\n\n首先，设 $L_P$ 是 $\\Sigma$ 上的所有回文串的语言。一个字符串 $w$ 如果正读和反读相同，则它是一个回文串。形式上，$L_P = \\{ w \\in \\Sigma^* \\mid w = w^R \\}$，其中 $w^R$ 是 $w$ 的反转。已知 $L_P \\in P$。\n\n其次，我们定义一个不可判定的一元语言。一个一元语言是 $\\{1\\}^*$ 的一个子集。设 $M_i$ 表示在所有有效图灵机编码的标准固定枚举下，与整数 $i$ 对应的图灵机。定义一元语言 $L_T$ 如下：\n$$L_T = \\{1^i \\mid \\text{图灵机 } M_i \\text{ 在空串 } \\epsilon \\text{ 上停机} \\}$$\n你可以假设计算理论中的一个已知结果，即 $L_T$ 是一个不可判定语言。\n\n使用这两个语言，我们在字母表 $\\Sigma$ 上构造一个新语言 $L_{new}$。一个字符串 $x \\in \\Sigma^*$ 是否属于 $L_{new}$ 取决于其长度 $|x|$，具体如下：\n- 如果 $|x|$ 是奇数，那么 $x \\in L_{new}$ 当且仅当 $x$ 是一个回文串（即 $x \\in L_P$）。\n- 如果 $|x|$ 是偶数，那么 $x \\in L_{new}$ 当且仅当该长度的一元字符串在 $L_T$ 中（即 $1^{|x|} \\in L_T$）。\n\n语言 $L_{new}$ 属于以下哪个复杂性类？\n\nA. $P$ (多项式时间)\nB. $NP$ (非确定性多项式时间)\nC. $P/poly$ (带有多项式大小建议的多项式时间)\nD. $R$ (所有可判定语言的类)\nE. 以上都不是；该语言是不可判定的。", "solution": "问题要求我们将语言 $L_{new}$ 分类到给定的复杂性类之一。语言 $L_{new}$ 定义为：\n$L_{new} = \\{ x \\in \\{0,1\\}^* \\mid (|x| \\text{ 是奇数且 } x \\in L_P) \\lor (|x| \\text{ 是偶数且 } 1^{|x|} \\in L_T) \\}$。\n\n我们来分析一下选项。\n\n首先，我们检查 $L_{new}$ 是否是可判定的（即，是否在类 $R$ 中）。为了导出矛盾，我们假设 $L_{new}$ 可由某个总会停机的图灵机 $M_{new}$ 判定。然后，我们可以利用 $M_{new}$ 来判定对于任何偶数 $i$，$1^i$ 是否在 $L_T$ 中。算法如下：构造任意一个长度为 $i$ 的字符串 $x$（例如，$x=0^i$），然后在输入 $x$ 上运行 $M_{new}$。根据 $L_{new}$ 的定义，由于 $|x|=i$ 是偶数，$M_{new}$ 将接受 $x$ 当且仅当 $1^i \\in L_T$。这个过程为集合 $\\{1^i \\mid i \\text{ is even and } 1^i \\in L_T\\}$ 提供了一个判定器。然而，这个集合是不可判定的（这是停机问题的一个变体）。因此，我们的初始假设，即 $L_{new}$ 是可判定的，必然是错误的。由于 $L_{new}$ 不可判定，它不属于 $R$，也因此不属于 $P$ 或 $NP$。这就排除了选项 A、B 和 D。\n\n我们剩下选项 C ($P/poly$) 和选项 E (不可判定)。注意，在这种情况下，“不可判定”通常指的是图灵可判定性（一致性计算）。$P/poly$ 类是一个非一致性复杂性类，并且已知它包含不可判定的语言。我们来检查 $L_{new}$ 是否符合 $P/poly$ 的定义。\n\n一个语言 $L$ 在 $P/poly$ 中，如果存在一个多项式时间算法 $A$ 和一个建议字符串序列 $\\{a_n\\}_{n \\in \\mathbb{N}}$，使得对于每个长度 $n$，建议的大小 $|a_n|$ 受 $n$ 的多项式限制，并且对于任何长度为 $n$ 的输入 $x$，$A(x, a_n)$ 都能正确判定 $x \\in L$ 是否成立。建议字符串 $a_n$ 仅依赖于输入的长度 $n$，而不依赖于输入 $x$ 本身。\n\n我们来为 $L_{new}$ 构造算法和建议。\n\n定义建议序列 $\\{a_n\\}$ 如下：\n对于每个自然数 $n \\ge 0$，建议 $a_n$ 将是一个单独的比特。\n$$a_n = \\begin{cases} 1  \\text{如果 } 1^n \\in L_T \\\\ 0  \\text{如果 } 1^n \\notin L_T \\end{cases}$$\n这个建议序列在数学上是良定义的，尽管它不是可计算的（因为 $L_T$ 是不可判定的）。$P/poly$ 的定义不要求建议是可计算的。对所有 $n$，建议的大小为 $|a_n| = 1$。这受一个多项式限制，例如 $p(n)=1$。\n\n现在，我们定义多项式时间算法 $A(x, a_{|x|})$。设 $n = |x|$ 为输入字符串 $x$ 的长度。\n1. 检查 $n$ 是奇数还是偶数。\n2. 如果 $n$ 是奇数：\n   算法忽略建议 $a_n$。它检查 $x$ 是否为回文串。这可以通过比较第一个字符与最后一个字符，第二个字符与倒数第二个字符，依此类推来完成。这需要 $O(n)$ 时间。如果 $x$ 是回文串，算法接受。否则，它拒绝。这根据 $L_{new}$ 的定义正确地判定了奇数长度字符串的成员关系。\n3. 如果 $n$ 是偶数：\n   算法忽略输入字符串 $x$ 本身，只考虑建议比特 $a_n$。如果 $a_n = 1$，算法接受。如果 $a_n = 0$，算法拒绝。根据我们对建议的定义，$a_n=1$ 当且仅当 $1^n \\in L_T$。因此，该算法正确地判定了偶数长度字符串的成员关系。\n\n算法 $A$ 的总运行时间主要由回文检查决定，为 $O(n)$。这是一个多项式时间算法。\n\n由于我们构造了一个多项式时间算法和一个多项式大小的建议序列来正确判定 $L_{new}$，我们已经证明了 $L_{new} \\in P/poly$。\n\n因此，正确的分类是 $P/poly$。选项 E 是不正确的，因为该语言完全符合选项中提供的一个更具体（尽管是非一致性的）类的定义。", "answer": "$$\\boxed{C}$$", "id": "1454149"}]}