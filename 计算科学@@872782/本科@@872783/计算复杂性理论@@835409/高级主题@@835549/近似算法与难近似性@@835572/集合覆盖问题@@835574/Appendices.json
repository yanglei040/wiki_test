{"hands_on_practices": [{"introduction": "在我们尝试解决一个集合覆盖问题之前，一个基本问题是：它是否有解？这个练习将帮助你识别一个集合覆盖实例无解的关键条件。通过分析一个元素是如何被覆盖的，你将学会判断一个问题实例是否从根本上就是可解的，这是着手解决任何计算问题的第一步。[@problem_id:1462631]", "problem": "在集合覆盖问题中，我们给定一个元素全集 $U$ 和一个由 $U$ 的子集组成的子集族，记为 $S=\\{S_1, S_2, \\dots, S_m\\}$。一个解，称为集合覆盖，是 $S$ 的一个子集族，我们称之为 $C \\subseteq S$，其并集等于全集 $U$。也就是说，必须满足条件 $\\bigcup_{S_i \\in C} S_i = U$。如果不存在这样的子集族 $C$，则称该问题实例无解。\n\n考虑一个集合覆盖问题的具体实例，其中全集为 $U = \\{1, 2, 3, 4, 5, 6\\}$，初始子集族为 $S = \\{S_1, S_2, S_3, S_4\\}$。这些子集定义如下：\n- $S_1 = \\{1, 2, 3\\}$\n- $S_2 = \\{3, 4, 5\\}$\n- $S_3 = \\{1, 5\\}$\n- $S_4 = \\{2, 4, 6\\}$\n\n假设我们创建四个新的问题实例。在每个新实例中，可用的子集族，我们称之为 $S'$，是通过从原始子集族 $S$ 中移除恰好一个子集而形成的。\n\n以下哪种情况会导致集合覆盖实例 $(U, S')$ 无解？\n\nA) 实例，其中 $S' = S \\setminus \\{S_1\\}$\n\nB) 实例，其中 $S' = S \\setminus \\{S_2\\}$\n\nC) 实例，其中 $S' = S \\setminus \\{S_3\\}$\n\nD) 实例，其中 $S' = S \\setminus \\{S_4\\}$", "solution": "一个集合覆盖实例有解的必要条件是，$U$ 中的每个元素都必须出现在可用子集族中的至少一个子集里。计算原始子集对每个元素的覆盖情况：\n- $1 \\in S_{1}, S_{3}$\n- $2 \\in S_{1}, S_{4}$\n- $3 \\in S_{1}, S_{2}$\n- $4 \\in S_{2}, S_{4}$\n- $5 \\in S_{2}, S_{3}$\n- $6 \\in S_{4}$\n\n元素 $6$ 只出现在 $S_{4}$ 中，因此在任何覆盖中 $S_{4}$ 都是必需的。因此，如果移除 $S_{4}$，则没有任何子集族可以覆盖元素 $6$，该实例无解。这对应于选项 D。\n\n通过检查余下子集的并集是否等于 $U$ 来验证其他移除情况仍然可以构成一个覆盖：\n- A: $S'=\\{S_{2},S_{3},S_{4}\\}$ 且\n$$S_{2}\\cup S_{3}\\cup S_{4}=\\{3,4,5\\}\\cup\\{1,5\\}\\cup\\{2,4,6\\}=\\{1,2,3,4,5,6\\}=U.$$\n- B: $S'=\\{S_{1},S_{3},S_{4}\\}$ 且\n$$S_{1}\\cup S_{3}\\cup S_{4}=\\{1,2,3\\}\\cup\\{1,5\\}\\cup\\{2,4,6\\}=\\{1,2,3,4,5,6\\}=U.$$\n- C: $S'=\\{S_{1},S_{2},S_{4}\\}$ 且\n$$S_{1}\\cup S_{2}\\cup S_{4}=\\{1,2,3\\}\\cup\\{3,4,5\\}\\cup\\{2,4,6\\}=\\{1,2,3,4,5,6\\}=U.$$\n\n因此只有移除 $S_{4}$ 会导致实例无解。", "answer": "$$\\boxed{D}$$", "id": "1462631"}, {"introduction": "集合覆盖问题是 NP-难的，但我们可以使用贪心算法来找到一个近似解。这个练习将引导你手动执行贪心策略，即在每一步选择能覆盖最多新元素的集合。通过这个具体的例子，你将不仅理解贪心算法的运作机制，还将发现它为何不总能保证找到最优解，从而深入理解近似算法的权衡。[@problem_id:1462610]", "problem": "一个内容分发网络（CDN）需要决定部署哪些服务器配置来托管一组12个热门文件，这些文件被标记为F1到F12。目标是选择所需的最少数量的服务器配置，以确保所有12个文件在整个网络中都可用。现有五种可用的服务器配置，从C1到C5，每种配置都能存储这些文件的一个特定子集：\n\n- C1: `{F1, F2, F3, F4, F5, F6}`\n- C2: `{F7, F8, F9}`\n- C3: `{F10, F11, F12}`\n- C4: `{F1, F2, F3, F7, F8, F9}`\n- C5: `{F4, F5, F6, F10, F11, F12}`\n\n公司的部署策略基于贪心算法。该算法分步进行：在每一步中，它选择能覆盖最多尚未被先前所选配置覆盖的文件的服务器配置。如果覆盖的新文件数量出现平局，算法将选择索引最小的配置（例如，C1优先于C2被选择）。这个过程重复进行，直到所有12个文件都被覆盖。\n\n一个最优部署是指使用覆盖所有12个文件所需的最绝对少数量的服务器配置。\n\n计算贪心算法部署的配置数量与最优部署中的配置数量之比。将最终答案表示为十进制数值，并四舍五入到四位有效数字。", "solution": "令文件全集为 $\\mathcal{U}=\\{F_{1},F_{2},\\dots,F_{12}\\}$。这些配置是：\n$$\nC_{1}=\\{F_{1},F_{2},F_{3},F_{4},F_{5},F_{6}\\},\\quad\nC_{2}=\\{F_{7},F_{8},F_{9}\\},\\quad\nC_{3}=\\{F_{10},F_{11},F_{12}\\},\n$$\n$$\nC_{4}=\\{F_{1},F_{2},F_{3},F_{7},F_{8},F_{9}\\},\\quad\nC_{5}=\\{F_{4},F_{5},F_{6},F_{10},F_{11},F_{12}\\}.\n$$\n\n贪心选择过程是在每一步选择能增加最多未覆盖文件的配置；平局则由最小索引打破。\n\n步骤1（初始）：各个配置的大小为 $|C_{1}|=6$, $|C_{4}|=6$, $|C_{5}|=6$, $|C_{2}|=3$, $|C_{3}|=3$。$C_{1},C_{4},C_{5}$ 之间出现三方平局；根据平局规则，选择 $C_{1}$。现在已覆盖的集合是 $S_{1}=C_{1}=\\{F_{1},\\dots,F_{6}\\}$，未覆盖的集合是 $\\mathcal{U}\\setminus S_{1}=\\{F_{7},F_{8},F_{9},F_{10},F_{11},F_{12}\\}$。\n\n步骤2：新增的覆盖文件数量为\n$$\n|C_{2}\\setminus S_{1}|=3,\\quad |C_{3}\\setminus S_{1}|=3,\\quad |C_{4}\\setminus S_{1}|=3,\\quad |C_{5}\\setminus S_{1}|=3.\n$$\n出现平局；根据平局规则，选择 $C_{2}$。已覆盖的集合变为 $S_{2}=S_{1}\\cup C_{2}=\\{F_{1},\\dots,F_{9}\\}$，未覆盖的集合是 $\\{F_{10},F_{11},F_{12}\\}$。\n\n步骤3：新增的覆盖文件数量为\n$$\n|C_{3}\\setminus S_{2}|=3,\\quad |C_{5}\\setminus S_{2}|=3,\\quad |C_{1}\\setminus S_{2}|=0,\\quad |C_{2}\\setminus S_{2}|=0,\\quad |C_{4}\\setminus S_{2}|=0.\n$$\n$C_{3}$ 和 $C_{5}$ 之间出现平局；根据平局规则，选择 $C_{3}$。然后 $S_{3}=S_{2}\\cup C_{3}=\\mathcal{U}$。因此，贪心算法选择了3个配置。\n\n为了找到最优部署，观察到没有单个配置能覆盖所有12个文件，因为 $\\max_{i}|C_{i}|=6  12$。然而，\n$$\nC_{4}\\cup C_{5}=\\{F_{1},F_{2},F_{3},F_{7},F_{8},F_{9}\\}\\cup \\{F_{4},F_{5},F_{6},F_{10},F_{11},F_{12}\\}=\\mathcal{U},\n$$\n所以2个配置就足够了。因此，最优数量是2。\n\n所求的比率为\n$$\nr=\\frac{\\text{贪心算法配置数}}{\\text{最优配置数}}=\\frac{3}{2}=1.5.\n$$\n四舍五入到四位有效数字，结果是 $1.500$。", "answer": "$$\\boxed{1.500}$$", "id": "1462610"}, {"introduction": "计算复杂性理论的魅力之一在于不同问题之间的深刻联系。这个练习探讨了集合覆盖问题的一个特殊变体，其中每个集合的大小恰好为二。通过将元素视为图的顶点，将集合视为边，你将发现这个问题如何巧妙地转化为一个我们熟知的图论问题——最小边覆盖，这展示了抽象和归约在算法设计中的强大威力。[@problem_id:1462657]", "problem": "集合覆盖问题是计算机科学中的一个经典问题。在其判定问题形式中，其表述如下：给定一个元素全集 $U$、一个由 $U$ 的子集构成的集合 $S = \\{S_1, S_2, \\ldots, S_m\\}$ 以及一个整数 $k$，是否存在一个子集合 $S' \\subseteq S$ 且 $|S'| \\le k$，使得 $S'$ 中集合的并集等于全集 $U$？\n\n考虑该问题的一个特殊情况，我们称之为 SET-COVER-2。在 SET-COVER-2 中，集合 $S$ 中的每个子集的大小都被限制为恰好是 2。也就是说，对于所有的 $i \\in \\{1, 2, \\ldots, m\\}$，我们有 $|S_i| = 2$。\n\n这个特定的变体，SET-COVER-2，等价于一个关于无向图的著名问题。下列哪个图问题在计算上等价于 SET-COVER-2？\n\nA. 最小顶点覆盖 (MINIMUM VERTEX COVER)\n\nB. 最小边覆盖 (MINIMUM EDGE COVER)\n\nC. 最大独立集 (MAXIMUM INDEPENDENT SET)\n\nD. 最小支配集 (MINIMUM DOMINATING SET)\n\nE. 最大团 (MAXIMUM CLIQUE)", "solution": "为了确定哪个图问题等价于 SET-COVER-2，我们将从一个 SET-COVER-2 的实例构建一个图，并分析得到的问题。\n\nSET-COVER-2 问题的一个实例包含一个元素全集 $U = \\{u_1, u_2, \\ldots, u_n\\}$ 和一个子集集合 $S = \\{S_1, S_2, \\ldots, S_m\\}$，其中每个集合 $S_i$ 恰好包含来自 $U$ 的两个元素。目标是找到一个最小的子集合 $S' \\subseteq S$，其并集覆盖 $U$ 中的所有元素。\n\n让我们将这个实例转换为一个图问题。我们可以如下定义一个无向图 $G = (V, E)$：\n1.  令图的顶点集 $V$ 为元素全集 $U$。因此，$V = U$。\n2.  令图的边集 $E$ 为子集集合 $S$。由于每个集合 $S_i$ 恰好包含两个元素，例如 $S_i = \\{u_a, u_b\\}$，我们可以将其表示为连接我们图中相应顶点的一条边 $(u_a, u_b)$。因此，$E = \\{\\{u_a, u_b\\} \\mid \\{u_a, u_b\\} \\in S\\}$。\n\n现在，让我们在这个图 $G$ 的背景下重新审视 SET-COVER-2 的目标。该问题要求找到一个最小规模的子集合 $S' \\subseteq S$，使得 $U$ 中的每个元素都至少包含在 $S'$ 的一个集合中。\n\n将其转换到我们的图 $G$ 上：\n-   一个子集集合 $S'$ 对应于一个边子集 $E' \\subseteq E$。\n-   一个元素 $u \\in U$ 被 $S'$ “覆盖”意味着存在某个集合 $S_i \\in S'$ 使得 $u \\in S_i$。\n-   在图中，这意味着对于一个顶点 $v \\in V$（对应于一个元素 $u \\in U$），必须存在一条边 $e \\in E'$（对应于一个集合 $S_i \\in S'$），使得 $v$ 是 $e$ 的一个端点。换句话说，顶点 $v$ 必须与边子集 $E'$ 中的至少一条边相关联。\n\n“$U$ 中的*每个*元素都必须被子集合 $S'$ 覆盖”这个条件，转换为了“$V$ 中的*每个*顶点都必须与边子集 $E'$ 中的至少一条边相关联”这个条件。\n\n在图 $G=(V,E)$ 中，一个边子集 $E' \\subseteq E$，如果 $V$ 中的每个顶点都是 $E'$ 中至少一条边的端点，那么根据定义，这个子集就是一个图的**边覆盖** (edge cover)。寻找这样的最小边子集的问题就是**最小边覆盖** (MINIMUM EDGE COVER) 问题。\n\n因此，为一个 SET-COVER-2 实例寻找一个最小集合覆盖，完全等价于为由它构建的图寻找一个最小边覆盖。\n\n让我们简要地看一下其他选项：\n-   A. 最小顶点覆盖：该问题要求找到最小的*顶点*集合，使得该集合能“接触”到每一条*边*。这与我们的问题不同，我们的问题是寻找一个*边*集来接触到每一个*顶点*。\n-   C. 最大独立集：这涉及找到最大的顶点集合，使得其中任意两个顶点之间都没有边相连。它与用边覆盖所有顶点没有直接关系。\n-   D. 最小支配集：这涉及找到最小的*顶点*集合，使得所有其他顶点都与该集合中的至少一个顶点相邻。这是一个顶点选择问题，而不是边选择问题。\n-   E. 最大团：这涉及找到最大的完全子图。它与这里所要求的覆盖性质无关。\n\n因此，正确的等价问题是最小边覆盖。", "answer": "$$\\boxed{B}$$", "id": "1462657"}]}