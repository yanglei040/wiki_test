{"hands_on_practices": [{"introduction": "要利用 PCP 证明近似困难性，第一步是将概率性验证过程转化为一个大规模的优化问题，通常是约束满足问题（CSP）。这个练习将引导你理解这个转化的基本机制 [@problem_id:1418606]。它将阐明验证者的参数，如随机性和查询复杂度，如何直接决定最终生成的 CSP 实例的规模和结构。", "problem": "我们构建了一个可概率性检验证明（PCP）验证者的理论模型，用以分析其生成的约束系统的结构。该验证者设计用于处理输入规模为 $n$ 的判定问题。其操作定义如下：\n\n1.  验证者使用一个总长度为 $r(n)$ 的随机串 $R$。该随机串由两个独立部分 $R_1$ 和 $R_2$ 拼接而成，其长度分别为 $r_1(n)$ 和 $r_2(n)$，因此 $r(n) = r_1(n) + r_2(n)$。\n2.  第一部分 $R_1$ 用于确定性地从给定的证明串 $\\pi$ 中选择一组 $q(n)$ 个不同的查询位置。我们将由 $R_1$ 生成的查询位置集合记为 $Q(R_1)$。\n3.  第二部分 $R_2$ 用于确定性地选择一个接受谓词，记为 $V_{R_2}$。接受谓词是一个布尔函数，它以 $q(n)$ 个比特作为输入，并返回一个比特表示接受（1）或拒绝（0）。\n4.  对于一个给定的完整随机串 $R = R_1R_2$，验证者接受证明 $\\pi$ 当且仅当谓词 $V_{R_2}$ 在从证明串中位于 $Q(R_1)$ 的位置所读取的特定比特上求值为 1。\n\n在证明近似困难性的标准方法中，这个PCP系统被转换成一个约束满足问题（CSP）的实例。对于验证者可能从其随机串中产生的每一个由查询位置集 $Q$ 和接受谓词 $V$ 组成的唯一对 $(Q, V)$，都会生成一个不同的约束。\n\n假设从随机串到结果的映射是最大程度多样化的（即，不同的随机串尽可能产生不同的结果），那么为最终生成的CSP实例可能产生的最大约束数量是多少？请用 $r_1(n)$、$r_2(n)$ 和 $q(n)$ 将你的答案表示为一个单一的闭式解析表达式。为简化最终表达式，你可以将这些函数写作 $r_1$、$r_2$ 和 $q$。", "solution": "对于 $R_{1}$ 有 $2^{r_{1}}$ 种可能的串，对于 $R_{2}$ 有 $2^{r_{2}}$ 种可能的串。在最大多样性假设下，映射 $R_{1} \\mapsto Q(R_{1})$ 在所有 $2^{r_{1}}$ 种可能性上可以是单射的，从而最多产生 $2^{r_{1}}$ 个不同的查询集。对于接受谓词，作用于 $q$ 个比特上的不同布尔谓词的总数是 $2^{2^{q}}$，因此映射 $R_{2} \\mapsto V_{R_{2}}$ 最多能产生 $\\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right)$ 个不同的谓词。\n\n因为 $R_{1}$ 和 $R_{2}$ 是独立的，并拼接成 $R = R_{1}R_{2}$，所以它们各自的结果会两两组合。因此，不同的验证者结果集合是不同的 $Q$ 集合与不同的 $V$ 集合的笛卡尔积。于是，不同对 $(Q,V)$ 的最大数量——也就是生成的最大约束数量——是\n$$\n2^{r_{1}} \\cdot \\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right).\n$$\n这个数量总是最多为 $2^{r_{1}+r_{2}}$，即随机串的总数，符合要求。", "answer": "$$\\boxed{2^{r_{1}}\\min\\!\\left(2^{r_{2}},\\,2^{2^{q}}\\right)}$$", "id": "1418606"}, {"introduction": "在了解了 PCP 验证者如何生成 CSP 之后，下一步是理解 PCP 的“可满足性间隙”（即在“是”实例和“否”实例中接受概率的差异）如何转化为一个优化问题的“近似间隙”。这个实践问题通过一个从通用间隙-CSP 到经典集合覆盖问题的具体归约，展示了这一关键步骤 [@problem_id:1418609]。通过计算，你将精确地看到 PCP 的可靠性属性如何为高效近似算法设置一个可证明的障碍。", "problem": "可概率验证证明（PCP）定理为证明许多优化问题的近似困难性提供了一个强大的工具。这是通过创建从NP完全问题（如3-SAT）到优化问题实例的归约来实现的，这些实例在YES实例（可满足的3-SAT公式）和NO实例（不可满足的3-SAT公式）之间，其目标函数值存在一个可计算的“间隙”。\n\n考虑一个特定的基于PCP的归约，它将一个3-SAT公式转换为一种特殊类型的约束满足问题（CSP）。这个CSP，我们称之为$\\psi$，具有以下由PCP定理保证的性质：\n1.  CSP $\\psi$ 定义在一组$N$个变量 $\\{x_1, \\dots, x_N\\}$ 和一组$M$个约束 $\\{C_1, \\dots, C_M\\}$ 上。\n2.  该归约保证了一个“满足度间隙”：\n    -   如果原始的3-SAT公式是可满足的（YES情况），那么存在一个对$N$个变量的赋值，它能满足$\\psi$的所有$M$个约束。\n    -   如果原始的3-SAT公式是不可满足的（NO情况），那么对$N$个变量的任何赋值都不能满足超过$M$个约束中的$s$部分，其中$s  1$。\n3.  此外，生成的CSP是正则的，意味着每个变量$x_i$都恰好出现在$D$个约束中。\n\n现在，考虑一个从这个CSP $\\psi$到集合覆盖问题实例的标准归约。集合覆盖实例 $(\\mathcal{U}, \\mathcal{S})$ 的构造如下：\n-   要覆盖的全集 $\\mathcal{U}$ 是$\\psi$的所有$M$个约束的集合。\n-   可用子集的集合 $\\mathcal{S}$，包含对于每个变量$x_i$和每个可能的二进制值$v \\in \\{0, 1\\}$的一个集合$S_{i,v}$。集合$S_{i,v}$定义为当变量$x_i$被赋值为$v$时所有被满足的约束的集合。\n\n给定一个通过此过程生成的CSP实例$\\psi$，其参数如下：$N=2000$个变量，$M=25000$个约束，满足度间隙参数$s=0.6$，以及正则性参数$D=25$。\n\n你的任务是分析此实例的最优集合覆盖的大小。\n1.  在YES情况下（当CSP完全可满足时），最小集合覆盖的大小是多少，记为$k_{YES}$？\n2.  接下来，考虑NO情况。任何对应于一个有效赋值（即每个变量一个集合）的$N$个集合的集合最多可以覆盖$sM$个约束。为了覆盖剩余的约束，必须添加额外的集合。假设在最乐观的情况下，每个额外的集合都覆盖了最大可能数量的*新的、先前未被覆盖的*约束，那么覆盖所有$M$个约束所需的*额外*集合的最小数量是多少？\n3.  使用你前面部分的答案，NO情况下的最小集合覆盖的大小是多少，记为$k_{NO}$？\n4.  最后，计算该归约为集合覆盖问题建立的近似困难度间隙 $\\gamma = \\frac{k_{NO}}{k_{YES}}$。\n\n提供近似困难度间隙$\\gamma$的单一数值。将你的最终答案四舍五入到四位有效数字。", "solution": "我们给定一个CSP实例，它有$N$个变量，$M$个约束，正则性为$D$，满足度间隙为$s  1$。集合覆盖实例使用所有$M$个约束作为全集$\\mathcal{U}$，以及集合族$\\{S_{i,v}\\}$，其中$S_{i,v}$包含当$x_{i}=v$时被满足的所有约束。正则性意味着每个变量恰好出现在$D$个约束中，因此对于任何$i$和$v$，$S_{i,v}$的大小最多为$D$。\n\n1) YES情况。如果CSP是可满足的，则存在一个赋值$a:[N]\\to\\{0,1\\}$满足所有$M$个约束。选择$N$个集合$\\{S_{i,a(i)}: i\\in[N]\\}$会覆盖所有约束，因此\n$$\nk_{YES}\\leq N.\n$$\n在此归约的标准分析下，我们取\n$$\nk_{YES}=N.\n$$\n当$N=2000$时，得出$k_{YES}=2000$。\n\n2) NO情况的额外集合。任何对应于单个赋值的$N$个集合的集合最多覆盖$sM$个约束。因此，在这$N$个集合之后，未被覆盖的约束数量为\n$$\nM - sM = (1-s)M.\n$$\n在最乐观的情况下，每个额外的集合覆盖了最大可能数量的新的、先前未被覆盖的约束，根据正则性，这个数量最多为$D$。因此，所需的最小额外集合数量为\n$$\n\\left\\lceil \\frac{(1-s)M}{D} \\right\\rceil.\n$$\n代入$s=0.6$，$M=25000$和$D=25$，\n$$\n(1-s)M = 0.4 \\times 25000 = 10000,\\quad \\frac{10000}{25}=400,\n$$\n所以最小额外集合数量是$400$。\n\n3) NO情况的覆盖大小。因此，在NO情况下，最小集合覆盖的大小是\n$$\nk_{NO} = N + \\left\\lceil \\frac{(1-s)M}{D} \\right\\rceil = 2000 + 400 = 2400.\n$$\n\n4) 近似困难度间隙。间隙为\n$$\n\\gamma = \\frac{k_{NO}}{k_{YES}} = \\frac{2400}{2000} = 1.2.\n$$\n四舍五入到四位有效数字，结果是$1.200$。", "answer": "$$\\boxed{1.200}$$", "id": "1418609"}, {"introduction": "PCP 和近似困难性之间的联系是双向的。最后一个练习将探讨其反向的深刻含义，从而巩固对这种等价关系的理解 [@problem_id:1418576]。它提出了一个假设情景：如果我们为一个已知与 PCP 相关的难题找到了一个高效的近似算法，这意味着什么？这个思想实验揭示了，这样一个算法的存在将迫使 PCP 的可满足性间隙趋近于零，从而将近似算法的不存在性与著名的 P vs. NP 问题联系起来。", "problem": "在计算复杂性理论中，概率可验证证明（PCP）定理建立了优化问题的近似困难性与证明验证之间的深刻联系。本问题探讨了当发现某个特定问题的高效近似算法时，会产生的一个假设性推论。\n\n考虑“模2最大恰好3元线性方程组”（MAX-E3-LIN-2）问题。一个MAX-E3-LIN-2问题的实例包含一组域 $\\mathbb{F}_2 = \\{0, 1\\}$ 上的变量 $x_1, \\dots, x_m$ 和一组约束，其中每个约束都是一个恰好涉及三个不同变量的线性方程，即形式为 $x_i \\oplus x_j \\oplus x_k = b$，其中 $b \\in \\{0, 1\\}$ 且 $\\oplus$ 表示异或（XOR）运算（模2加法）。目标是找到一个对变量的赋值，以最大化被满足的方程总数。\n\n现在，设想一个由输入大小 $n$ 索引的PCP验证器族，其设计目的是判定一个语言 $L$。对于任何大小为 $n$ 的输入串，验证器 $V_n$ 对一个证明串进行操作。验证过程涉及一系列局部检查，其中每个检查都可以完美地表示为一个MAX-E3-LIN-2实例中的约束。验证器的性能由其完备性 $c(n)$ 和可靠性 $s(n)$ 来刻画。\n- 如果一个输入属于 $L$（一个YES实例），则存在一个证明，使得验证器以概率 $c(n)$ 接受。\n- 如果一个输入不属于 $L$（一个NO实例），则任何证明都使得验证器以至多为 $s(n)$ 的概率接受。\n\n给定以下两个前提：\n1. 已经发现MAX-E3-LIN-2问题存在一个多项式时间近似方案（PTAS）。PTAS是一种算法，对于任意给定的实例 $I$ 和任意误差参数 $\\epsilon  0$，它能产生一个解，其值在最优值的 $(1-\\epsilon)$ 乘法因子范围内。对于任何固定的 $\\epsilon$，该算法的运行时间是实例大小 $|I|$ 的多项式。\n2. 语言 $L$ 不在 P 类中，P 类是可在确定性多项式时间内解决的判定问题类。\n\n基于这些前提，关于验证器的完备性 $c(n)$ 和可靠性 $s(n)$，以下哪个陈述必然为真？\n\nA. 对于所有足够大的 $n$，$c(n) = 1$ 且 $s(n) \\le 1/2$。\n\nB. 间隙，定义为 $c(n) - s(n)$，对于所有足够大的 $n$ 必须是一个大于零的常数。\n\nC. 比率 $s(n)/c(n)$ 对于所有足够大的 $n$ 必须是一个严格小于1的常数。\n\nD. 当 $n \\to \\infty$ 时，比率 $s(n)/c(n)$ 必须趋近于1。\n\nE. 间隙 $c(n) - s(n)$ 必须是 $O(1/n^k)$，对于某个常数 $k0$。", "solution": "我们形式化验证器到优化问题的连接以及PTAS的影响。\n\n对于一个长度为 $n$ 的输入串 $x$，令 $V_n$ 为验证器。根据假设，$V_n$ 的每个局部检查都恰好是MAX-E3-LIN-2实例中的一个约束。通过汇总所有检查，我们可以构建一个实例 $I(x)$，其总共有 $M$ 个约束。令 $p^{\\ast}(x)$ 表示验证器 $V_n$ 在输入 $x$ 上对所有证明所能达到的最大接受概率。因为每个检查对应一个约束，并且接受事件是指被查询的约束得到满足，所以可满足约束的最优比例等于 $p^{\\ast}(x)$：\n$$\n\\frac{\\operatorname{OPT}(I(x))}{M}=p^{\\ast}(x).\n$$\n根据完备性和可靠性，\n$$\nx \\in L \\implies p^{\\ast}(x) \\ge c(n), \\qquad x \\notin L \\implies p^{\\ast}(x) \\le s(n).\n$$\n\nMAX-E3-LIN-2的PTAS保证，对于任何 $\\epsilon0$，在实例 $I(x)$ 上，它会返回一个值为 $\\operatorname{val}(I(x))$ 的赋值，满足\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\ge (1-\\epsilon)\\,\\frac{\\operatorname{OPT}(I(x))}{M}=(1-\\epsilon)\\,p^{\\ast}(x).\n$$\n\n假设存在一个常数 $\\delta0$ 和 $n_{0}$，使得对于所有 $n \\ge n_{0}$，\n$$\n\\frac{s(n)}{c(n)} \\le 1-\\delta.\n$$\n固定 $\\epsilon$ 且 $0\\epsilon\\delta$。对于任何 $|x|=n \\ge n_{0}$ 的YES实例，\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\ge (1-\\epsilon)\\,p^{\\ast}(x) \\ge (1-\\epsilon)\\,c(n)  (1-\\delta)\\,c(n) \\ge s(n).\n$$\n对于任何NO实例，任何赋值最多只能满足 $s(n)$ 比例的约束，所以\n$$\n\\frac{\\operatorname{val}(I(x))}{M} \\le s(n).\n$$\n因此，通过将获得的比例与 $(s(n),(1-\\epsilon)c(n))$ 区间内的任何阈值进行比较，就可以在确定性多项式时间内判定 $L$（因为对于固定的 $\\epsilon$，PTAS的运行时间是 $|I(x)|$ 的多项式，并且计算该比例也是多项式时间的），这意味着 $L \\in \\mathrm{P}$。这与前提 $L \\notin \\mathrm{P}$ 相矛盾。因此，$s(n)/c(n)$ 不可能对所有足够大的 $n$ 都被一个严格小于1的常数从上方界定。等价地，我们必须有\n$$\n\\lim_{n \\to \\infty} \\frac{s(n)}{c(n)}=1.\n$$\n\n现在来评估各个选项：\n- A会得出对于大的 $n$，$\\frac{s(n)}{c(n)} \\le \\frac{1}{2}$，这与我们刚刚推导出的必要条件相矛盾。\n- B断言存在一个常数加性间隙 $c(n)-s(n) \\ge \\gamma0$；如果再结合任何下界 $c(n) \\ge c_{0}0$，这将意味着 $\\frac{s(n)}{c(n)} \\le 1-\\gamma/c_{0}1$，再次与必要条件矛盾。即使没有一个统一的 $c_0$，B也不是前提所蕴含的；如果B为真，则可以通过一个固定的 $\\epsilon$ 实现多项式时间判定，因此在 $L \\notin \\mathrm{P}$ 的条件下B不成立。\n- C明确指出存在一个严格小于1的常数比率，我们刚刚排除了这种情况。\n- D陈述的正是所要求的条件 $\\frac{s(n)}{c(n)} \\to 1$。\n- E要求加性间隙有一个特定的多项式衰减率。前提只强制要求相对间隙趋于零；而加性间隙例如可以是 $\\Theta(1/\\ln n)$，它对于任何 $k0$ 都不是 $O(1/n^{k})$。因此E不是必然的推论。\n\n所以，唯一必然为真的陈述是D。", "answer": "$$\\boxed{D}$$", "id": "1418576"}]}