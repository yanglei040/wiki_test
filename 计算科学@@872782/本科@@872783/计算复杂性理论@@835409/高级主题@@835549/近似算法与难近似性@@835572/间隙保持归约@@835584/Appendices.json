{"hands_on_practices": [{"introduction": "一些计算问题，尽管出现在不同领域（如作业调度与箱子装箱），其底层结构却是相同的。本练习将展示一种最简单的间隙保持归约形式，其中一个问题可以直接重构为另一个问题，并完美地保持其近似间隙。我们将把一个带间隙的完工时间调度问题（Gap-Makespan）映射到一个带间隙的箱子装箱问题（Gap-Capacity）。[@problem_id:1425491]", "problem": "您是一家云计算公司的软件工程师。您的团队的任务是开发一种服务，用于在同构服务器集群上调度客户的作业。形式上，这是一个经典的在并行机器上调度作业以最小化完工时间（makespan）的问题。\n\n您正在关注该问题的一个基于承诺的决策版本，我们称之为 `Gap-Makespan`。一个 `Gap-Makespan` 的实例由一组具有已知处理时间 $\\{p_1, p_2, \\dots, p_n\\}$ 的 $n$ 个作业、$m$ 台同构服务器和一个目标截止时间 $T$ 来定义。该问题实例保证满足以下两个条件之一：\n1.  (是-实例) 最优完工时间小于或等于截止时间 $T$。即，$C_{\\max}^{*} \\le T$。\n2.  (否-实例) 最优完工时间严格大于 $T \\cdot g_{MS}$，其中 $g_{MS}  1$ 是一个性能差距参数。即，$C_{\\max}^{*}  T \\cdot g_{MS}$。\n\n您的任务是构建一个能够区分这两种情况的求解器。\n\n幸运的是，您的公司可以使用一个名为 `CapacityOptimizer` 的专有软件库。该库解决一个带间隙的装箱问题的版本，我们称之为 `Gap-Capacity`。一个 `Gap-Capacity` 的实例由一组大小为 $\\{s_1, s_2, \\dots, s_n\\}$ 的 $n$ 个物品、固定数量的 $k$ 个箱子和一个目标箱子容量 $C$ 来定义。`CapacityOptimizer` 库保证能正确区分以下两种情况：\n1.  (是-实例) 将所有物品装入 $k$ 个箱子所需的最小箱子容量小于或等于目标容量 $C$。\n2.  (否-实例) 将所有物品装入 $k$ 个箱子所需的最小箱子容量严格大于 $C \\cdot g_{CO}$，其中 $g_{CO}  1$ 是该库的内置性能差距。\n\n对于任何不满足这两个承诺之一的输入，该库的输出是未定义的。\n\n请描述一个通过调用 `CapacityOptimizer` 库来求解 `Gap-Makespan` 问题实例的步骤。根据您的步骤，如果 `CapacityOptimizer` 库保证性能差距为 $g_{CO}$，那么您的新调度服务可以保证的相应性能差距 $g_{MS}$ 是多少？请用一个关于 $g_{CO}$ 的符号表达式来表示您的答案。", "solution": "我们给定一个 Gap-Makespan 实例，其中作业的处理时间为 $\\{p_{1},\\dots,p_{n}\\}$，$m$ 台同构机器，以及一个目标截止时间 $T$。设最优完工时间为 $C_{\\max}^{*}$，定义为\n$$\nC_{\\max}^{*}=\\min_{\\{M_{1},\\dots,M_{m}\\}}\\max_{j\\in\\{1,\\dots,m\\}}\\sum_{i\\in M_{j}}p_{i},\n$$\n其中 $\\{M_{1},\\dots,M_{m}\\}$ 是将作业划分到分配给机器的 $m$ 个不相交的集合。\n\n按如下方式构建一个 Gap-Capacity 实例：\n- 物品：大小 $s_{i}=p_{i}$，对于 $i\\in\\{1,\\dots,n\\}$。\n- 箱子数量：$k=m$。\n- 目标容量：$C=T$。\n\n容量为 $C$ 的装箱可行性等价于存在一个完工时间至多为 $C$ 的调度，因为将物品装入 $m$ 个容量为 $C$ 的箱子意味着存在一个划分 $\\{M_{1},\\dots,M_{m}\\}$，使得对于所有 $j$ 都有 $\\sum_{i\\in M_{j}}p_{i}\\leq C$，这正是一个完工时间至多为 $C$ 的调度。因此，将物品装入 $k=m$ 个箱子所需的最小箱子容量等于最优完工时间：\n$$\nC_{\\text{pack}}^{*}=C_{\\max}^{*}.\n$$\n\n现在，对构建的容量为 $C=T$ 的 Gap-Capacity 实例调用 CapacityOptimizer。根据该库的保证，它会区分以下情况：\n- 是：$C_{\\text{pack}}^{*}\\leq T$，\n- 否：$C_{\\text{pack}}^{*}T\\cdot g_{CO}$。\n\n使用 $C_{\\text{pack}}^{*}=C_{\\max}^{*}$，这变为：\n- 是：$C_{\\max}^{*}\\leq T$，\n- 否：$C_{\\max}^{*}T\\cdot g_{CO}$。\n\n因此，步骤是：\n- 如果 CapacityOptimizer 返回“是”，则为 Gap-Makespan 输出“是”。\n- 如果 CapacityOptimizer 返回“否”，则为 Gap-Makespan 输出“否”。\n\n因为 Gap-Makespan 实例被承诺要么是 $C_{\\max}^{*}\\leq T$ 要么是 $C_{\\max}^{*}T\\cdot g_{MS}$，并且构建的 Gap-Capacity 实例满足相应的承诺，其中 $g_{MS}=g_{CO}$，所以该求解器能正确区分这两种承诺的情况。因此，Gap-Makespan 可实现的性能差距等于该库的差距：\n$$\ng_{MS}=g_{CO}.\n$$", "answer": "$$\\boxed{g_{CO}}$$", "id": "1425491"}, {"introduction": "接下来，我们来探索一种常见的归约技巧：创建一个原问题的放大版本。本练习涉及一个针对集合覆盖问题的“复制”归约，即复制宇宙中的每个元素和每个集合。通过分析这种变换，我们将看到最优解的规模如何可预测地扩大，而代表核心近似难度的间隙却保持不变。[@problem_id:1425437]", "problem": "在计算复杂性理论中，我们经常通过承诺问题的视角来研究优化问题，以分析其近似困难性。\n\n考虑最小集合覆盖问题。一个实例是一个对 $I = (U, S)$，其中 $U$ 是一个有限的元素全集，$S$ 是 $U$ 的一个子集族。目标是找到一个大小尽可能小的子集族 $S' \\subseteq S$，使得 $S'$ 中集合的并集能够覆盖整个全集 $U$。我们将这个最小子集族的大小，即最优解，表示为 $\\text{OPT}(I)$。\n\n让我们定义一个归约 $f$，它接受一个集合覆盖实例 $I=(U, S)$ 并生成一个新实例 $I' = f(I) = (U', S')$。新实例的构造如下：\n1.  对每个元素 $u \\in U$，我们创建两个新的、不同的元素 $u_A$ 和 $u_B$。新的全集 $U'$ 是所有这些新创建的元素的集合：$U' = \\{u_A \\mid u \\in U\\} \\cup \\{u_B \\mid u \\in U\\}$。\n2.  对每个集合 $S_j \\in S$，我们创建两个新集合 $S_{j,A}$ 和 $S_{j,B}$。集合 $S_{j,A}$ 定义为 $\\{u_A \\mid u \\in S_j\\}$，集合 $S_{j,B}$ 定义为 $\\{u_B \\mid u \\in S_j\\}$。新的集合族 $S'$ 由所有这些新创建的集合组成：$S' = \\{S_{j,A} \\mid S_j \\in S\\} \\cup \\{S_{j,B} \\mid S_j \\in S\\}$。\n\n现在，考虑集合覆盖问题的承诺问题变体，记为 Gap-SetCover$_{c}$。对于一个实例 $I$ 和一个整数 $k$，我们得到一个承诺，即要么 $\\text{OPT}(I) \\leq k$，要么 $\\text{OPT}(I)  c \\cdot k$，其中 $c  1$ 是某个常数。一个间隙保持归约将实例 $I$ 映射到实例 $I'$，使得如果 $\\text{OPT}(I) \\leq k$，则 $\\text{OPT}(I') \\leq \\alpha \\cdot k$；如果 $\\text{OPT}(I)  c \\cdot k$，则 $\\text{OPT}(I')  \\beta \\cdot c \\cdot k$，其中 $\\alpha$ 和 $\\beta$ 是某些常数。如果 $\\beta  \\alpha$，则称间隙被放大。如果 $\\beta = \\alpha$，则间隙被保持。\n\n下列哪个陈述正确描述了 $\\text{OPT}(I')$ 和 $\\text{OPT}(I)$ 之间的关系，以及相应的间隙归约参数 $\\alpha$ 和 $\\beta$？\n\nA. $\\text{OPT}(I') = \\text{OPT}(I)$，其中 $\\alpha=1, \\beta=1$。该归约是间隙保持的。\n\nB. $\\text{OPT}(I') = 2 \\cdot \\text{OPT}(I)$，其中 $\\alpha=2, \\beta=2$。该归约是间隙保持的。\n\nC. $\\text{OPT}(I') = 2 \\cdot \\text{OPT}(I)$，其中 $\\alpha=2, \\beta=1$。该归约是间隙缩小的。\n\nD. $\\text{OPT}(I') = (\\text{OPT}(I))^2$。间隙变换参数 $\\alpha, \\beta$ 不能表示为独立于 $k$ 的常数。\n\nE. 关系是 $\\text{OPT}(I')  2 \\cdot \\text{OPT}(I)$，因为 $I'$ 的一个最优解可能巧妙地混合来自'A'组和'B'组的集合。", "solution": "该问题要求我们找出集合覆盖实例 $I$ 的最优解大小与通过复制所有元素和集合构造的新实例 $I'$ 的最优解大小之间的关系。然后我们利用这种关系来分析该归约对问题近似间隙的影响。\n\n设 $I=(U, S)$ 为原始实例，$I'=(U', S')$ 是由归约 $f$ 创建的新实例。设 $\\text{OPT}(I)$ 和 $\\text{OPT}(I')$ 分别是 $I$ 和 $I'$ 的最小集合覆盖的大小。\n\n首先，我们将建立 $\\text{OPT}(I')$ 和 $\\text{OPT}(I)$ 之间的关系。我们将分两部分来完成：证明 $\\text{OPT}(I') \\leq 2 \\cdot \\text{OPT}(I)$，然后证明 $\\text{OPT}(I') \\geq 2 \\cdot \\text{OPT}(I)$。\n\n第1部分：证明 $\\text{OPT}(I') \\leq 2 \\cdot \\text{OPT}(I)$。\n设 $C_{opt} = \\{S_{i_1}, S_{i_2}, \\dots, S_{i_k}\\}$ 是实例 $I$ 的一个最优集合覆盖。根据定义，有 $|C_{opt}| = k = \\text{OPT}(I)$，且 $\\bigcup_{j=1}^{k} S_{i_j} = U$。\n我们可以基于 $C_{opt}$ 为 $I'$ 构造一个集合覆盖。考虑集合族 $C' \\subseteq S'$，定义如下：\n$C' = \\{S_{i_1, A}, S_{i_2, A}, \\dots, S_{i_k, A}\\} \\cup \\{S_{i_1, B}, S_{i_2, B}, \\dots, S_{i_k, B}\\}$。\n这个集合族的大小为 $|C'| = k + k = 2k = 2 \\cdot \\text{OPT}(I)$。\n现在我们必须检查 $C'$ 是否是 $U'$ 的一个有效覆盖。$C'$ 中集合的并集为：\n$$ \\bigcup_{S'' \\in C'} S'' = \\left( \\bigcup_{j=1}^{k} S_{i_j, A} \\right) \\cup \\left( \\bigcup_{j=1}^{k} S_{i_j, B} \\right) $$\n根据 $S_{j,A}$ 的构造，第一个并集覆盖了 $U_A$ 中的所有元素：\n$$ \\bigcup_{j=1}^{k} S_{i_j, A} = \\{u_A \\mid u \\in \\bigcup_{j=1}^{k} S_{i_j}\\} = \\{u_A \\mid u \\in U\\} = U_A $$\n类似地，第二个并集覆盖了 $U_B$ 中的所有元素：\n$$ \\bigcup_{j=1}^{k} S_{i_j, B} = \\{u_B \\mid u \\in \\bigcup_{j=1}^{k} S_{i_j}\\} = \\{u_B \\mid u \\in U\\} = U_B $$\n因此，$C'$ 中所有集合的并集是 $U_A \\cup U_B = U'$。这意味着 $C'$ 是 $I'$ 的一个有效集合覆盖。由于 $\\text{OPT}(I')$ 是*最小*集合覆盖的大小，我们必有 $\\text{OPT}(I') \\leq |C'|$。\n因此，我们证明了 $\\text{OPT}(I') \\leq 2 \\cdot \\text{OPT}(I)$。\n\n第2部分：证明 $\\text{OPT}(I') \\geq 2 \\cdot \\text{OPT}(I)$。\n设 $C'_{opt}$ 是 $I'$ 的一个最优集合覆盖。因此，$|C'_{opt}| = \\text{OPT}(I')$。\n全集 $U'$ 被划分为两个不相交的集合 $U_A$ 和 $U_B$。$S'$ 中形如 $S_{j,A}$ 的集合只包含来自 $U_A$ 的元素，而形如 $S_{j,B}$ 的集合只包含来自 $U_B$ 的元素。这意味着覆盖 $U'$ 的问题可以完美地分解为两个独立的子问题：一个是用来自 $S_A = \\{S_{j,A}\\}_{S_j \\in S}$ 的集合覆盖 $U_A$，另一个是用来自 $S_B = \\{S_{j,B}\\}_{S_j \\in S}$ 的集合覆盖 $U_B$。\n设 $C'_A = C'_{opt} \\cap S_A$ 和 $C'_B = C'_{opt} \\cap S_B$。由于 $S_A$ 和 $S_B$ 不相交，所以 $|C'_{opt}| = |C'_A| + |C'_B|$。\n$C'_A$ 中的集合必须覆盖 $U_A$ 的全部。设 $C_A \\subseteq S$ 是与 $C'_A$ 中集合对应的原始集合族。使用 $S_A$ 中的集合找到 $U_A$ 的最小覆盖问题，在结构上与使用 $S$ 中的集合找到 $U$ 的最小覆盖问题是相同的。因此，从 $S_A$ 中选取集合来覆盖 $U_A$ 的最小集合族的大小恰好是 $\\text{OPT}(I)$。这意味着 $|C'_A| \\geq \\text{OPT}(I)$。\n通过对称论证，$C'_B$ 中的集合必须覆盖 $U_B$ 的全部，而这样的最小集合族的大小也必须是 $\\text{OPT}(I)$。这意味着 $|C'_B| \\geq \\text{OPT}(I)$。\n结合这些结果，我们得到：\n$$ \\text{OPT}(I') = |C'_{opt}| = |C'_A| + |C'_B| \\geq \\text{OPT}(I) + \\text{OPT}(I) = 2 \\cdot \\text{OPT}(I) $$\n所以我们证明了 $\\text{OPT}(I') \\geq 2 \\cdot \\text{OPT}(I)$。\n\n结合第1部分和第2部分，我们有 $\\text{OPT}(I') \\leq 2 \\cdot \\text{OPT}(I)$ 和 $\\text{OPT}(I') \\geq 2 \\cdot \\text{OPT}(I)$，这意味着我们必须有等式：\n$$ \\text{OPT}(I') = 2 \\cdot \\text{OPT}(I) $$\n\n现在我们分析间隙变换。我们对 $I$ 有一个承诺：\n- 情况1（完备性）：$\\text{OPT}(I) \\leq k$。使用我们推导出的关系，这意味着 $\\text{OPT}(I') = 2 \\cdot \\text{OPT}(I) \\leq 2k$。这与形式 $\\text{OPT}(I') \\leq \\alpha \\cdot k$ 相匹配，其中 $\\alpha = 2$。\n- 情况2（可靠性）：$\\text{OPT}(I)  c \\cdot k$。这意味着 $\\text{OPT}(I') = 2 \\cdot \\text{OPT}(I)  2(c \\cdot k) = (2) \\cdot c \\cdot k$。这与形式 $\\text{OPT}(I')  \\beta \\cdot c \\cdot k$ 相匹配，其中 $\\beta = 2$。\n\n由于 $\\alpha = 2$ 且 $\\beta = 2$，我们有 $\\alpha = \\beta$。这意味着该归约是间隙保持的；它不放大间隙。\n这对应于选项B。让我们回顾一下其他选项：\nA. $\\text{OPT}(I')$ 的关系不正确。\nC. $\\beta$ 的值不正确。如果 $\\beta=1, \\alpha=2$，间隙会缩小，因此它是间隙缩小的。\nD. $\\text{OPT}(I')$ 的关系不正确。\nE. 不正确。子问题是完全不相交的，因此组合问题的最优解恰好是子问题最优解的和。\n\n因此，正确的陈述是B。", "answer": "$$\\boxed{B}$$", "id": "1425437"}, {"introduction": "并非所有归约都像直接映射或缩放那样直接。本练习将研究一种对图的结构性修改——添加一个通用顶点——并分析其对带间隙的顶点覆盖问题的影响。你将发现，这个直观的变换确实是一个有效的间隙保持归约，但它会压缩间隙，这揭示了近似困难性证明中的一个关键而微妙之处。[@problem_id:1425471]", "problem": "在计算复杂性理论中，许多优化问题都以其带间隙的决策形式进行研究。考虑最小顶点覆盖（VC）问题的带间隙决策版本，记作 `(1, s)`-GAP-VC。一个无向图的顶点覆盖是一个顶点子集，使得图中的每条边都至少与该子集中的一个顶点相关联。对于一个由图 `G` 和一个整数 `k` 组成的实例 `(G, k)`，我们有以下承诺：\n- **是实例**：`G` 的最小顶点覆盖的大小，记作 `vc(G)`，满足 `vc(G) = k`。\n- **否实例**：`G` 的最小顶点覆盖的大小满足 `vc(G)  s * k`，其中 `s  1` 为某个恒定的间隙因子。\n\n现在，考虑一个特定的图变换 $T$。给定一个有 $n$ 个顶点的无向图 $G=(V, E)$，变换 $T(G)$ 会生成一个新图 $G'=(V', E')$。新图 $G'$ 的构造方法是：在图 $G$ 中添加一个单独的新“通用”顶点（我们称之为 $u$），并将 $u$ 连接到所有原来在 $V$ 中的顶点。形式上， $V' = V \\cup \\{u\\}$ 且 $E' = E \\cup \\{(u,v) \\mid v \\in V\\}$。\n\n我们想知道这个变换是否可以作为一个从 `(1, s)`-GAP-VC 的实例 `(G, k)` 到 `(1, s')`-GAP-VC 的对应实例 `(G', k')` 的多项式时间保隙归约的一部分。具体来说，考虑将实例 `(G, k)` 映射到 `(G', k+1)` 的归约。假设对于任何输入实例 `(G, k)`，我们都有 `k  n-1`。\n\n以下哪个陈述正确地描述了该映射是否构成一个有效的保隙归约？\n\nA. 是的，这是一个保持原始间隙因子的保隙归约，因此 `s' = s`。\n\nB. 不，这不是一个保隙归约。虽然存在某种关系，但新的间隙 `s'` 不能是一个固定的常数；它必须依赖于原始问题实例中的参数 `k`。\n\nC. 不，这不是一个保隙归约，因为分析表明，对于任何 `s  1`，新的间隙因子 `s'` 将必须小于或等于 1。\n\nD. 是的，这是一个保隙归约，其中新的间隙因子 `s'` 是一个依赖于 `s` 的常数（例如，`s'=(s+1)/2`），并且严格小于 `s`。", "solution": "设 $G=(V,E)$ 且 $|V|=n$，令 $T(G)=G'=(V',E')$ 是通过添加一个与 $V$ 中每个顶点 $v$ 都相邻的通用顶点 $u$ 而形成的，因此 $V'=V \\cup \\{u\\}$ 且 $E'=E \\cup \\{(u,v): v \\in V\\}$。考虑映射 $(G,k) \\mapsto (G',k+1)$。\n\n首先，根据 $\\operatorname{vc}(G)$ 计算 $\\operatorname{vc}(G')$。$G'$ 的任何顶点覆盖都必须覆盖：\n- 所有原始边 $E$，以及\n- 所有新边 $\\{(u,v): v \\in V\\}$。\n\n如果 $u \\in$ 覆盖集中，那么所有新边都被 $u$ 覆盖，剩下的任务是覆盖 $E$，这需要至少 $\\operatorname{vc}(G)$ 个来自 $V$ 的顶点。因此存在一个大小为 $1+\\operatorname{vc}(G)$ 的覆盖集，且使用 $u$ 的情况下没有更小的覆盖集。\n\n如果 $u \\notin$ 覆盖集中，那么每条边 $(u,v)$ 都必须通过包含 $v$ 来覆盖，因此 $V$ 的所有顶点都必须在覆盖集中，得到的大小为 $n$。\n\n因此\n$$\n\\operatorname{vc}(G')=\\min\\{1+\\operatorname{vc}(G),\\,n\\}.\n$$\n对于任何 $n$ 顶点的图，$\\operatorname{vc}(G)=n-\\alpha(G)$，其中 $\\alpha(G)$ 是最大独立集的大小。由于 $\\alpha(G) \\ge 1$，我们有 $\\operatorname{vc}(G) \\le n-1$，因此 $1+\\operatorname{vc}(G) \\le n$。所以，对于所有的 $G$，都有\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G)\n$$\n\n现在分析在 $(G,k) \\mapsto (G',k+1)$ 下的间隙。\n\n是实例：如果 $\\operatorname{vc}(G) \\le k$，那么\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G) \\le 1+k = k',\n$$\n所以 $(G',k')$ 是一个是实例。\n\n否实例：如果 $\\operatorname{vc}(G)  s\\,k$，那么\n$$\n\\operatorname{vc}(G')=1+\\operatorname{vc}(G)  s\\,k + 1.\n$$\n为确保 $(G',k')$ 对于某个常数 $s'  1$ 是一个否实例，我们需要\n$$\n\\operatorname{vc}(G')  s'(k+1),\n$$\n如果\n$$\ns'(k+1) \\le s\\,k + 1 \\quad \\text{对于所有允许的 } k.\n$$\n成立，则该条件得到保证。\n\n等价地，\n$$\ns' \\le \\frac{s\\,k + 1}{k+1} = s - \\frac{s-1}{k+1}.\n$$\n在 $k \\ge 1$ 的范围内，右侧在 $k=1$ 时取最小值，得到\n$$\n\\min_{k \\ge 1} \\frac{s\\,k + 1}{k+1} = \\frac{s+1}{2}.\n$$\n因此，选择常数\n$$\ns'=\\frac{s+1}{2}\n$$\n可以确保对于所有 $k \\ge 1$ 都有 $s'(k+1) \\le s\\,k + 1$，因此只要 $\\operatorname{vc}(G)  s\\,k$，就有 $\\operatorname{vc}(G')  s'(k+1)$。由于 $s>1$，我们有 $1  s'  s$。\n\n注：如果允许 $k=0$，那么 $\\inf_{k \\ge 0} \\frac{s\\,k + 1}{k+1} = 1$，所以不存在满足条件的常数 $s' > 1$。在通常的 $k \\ge 1$ 限制下（或者在对 $k=0$ 进行平凡的预处理后），一个像 $(s+1)/2$ 这样的常数 $s'$ 是可行的。因此，所述映射构成一个有效的多项式时间保隙归约，其新的间隙因子是一个仅依赖于 $s$ 的、且严格更小的常数。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1425471"}]}