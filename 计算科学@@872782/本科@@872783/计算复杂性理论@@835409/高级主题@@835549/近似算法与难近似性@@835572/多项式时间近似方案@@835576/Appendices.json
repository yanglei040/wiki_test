{"hands_on_practices": [{"introduction": "理解算法的理论保证始于正确解读其时间复杂度。第一个练习将挑战你运用多项式时间近似方案 (PTAS) 和完全多项式时间近似方案 (FPTAS) 的形式化定义来对几种算法进行分类，这是分析近似方案的一项基本技能。", "problem": "一家名为 `ConnectSphere` 的科技公司正在处理一个与其分布式计算平台上的资源分配相关的、出了名的困难优化问题。该问题是已知的 NP 难问题。为了找到可行的解决方案，他们的算法部门开发了四种不同的近似算法。每种算法都接受一个大小为 $n$ 的问题实例和一个误差容限参数 $\\epsilon  0$ 作为输入，并产生一个保证在最优解的 $(1+\\epsilon)$ 因子范围内的解。\n\n公司需要评估这些算法中哪些可以归类为多项式时间近似方案 (Polynomial-Time Approximation Scheme, PTAS) 或完全多项式时间近似方案 (Fully Polynomial-Time Approximation Scheme, FPTAS)。定义如下：\n\n- **多项式时间近似方案 (PTAS)** 是一种近似算法，对于每个固定的 $\\epsilon  0$ 值，其运行时间是输入大小 $n$ 的多项式。该多项式的指数可以依赖于 $\\epsilon$。例如，运行时间为 $O(n^{1/\\epsilon})$ 的算法是一个 PTAS。\n- **完全多项式时间近似方案 (FPTAS)** 是一种 PTAS，其运行时间同时也是 $1/\\epsilon$ 的多项式。例如，运行时间为 $O((1/\\epsilon)^{2} \\cdot n^{3})$ 的算法是一个 FPTAS。\n\n四种提出算法的时间复杂度为：\n- **算法 1:** $T_1(n, \\epsilon) = O(n^4 + (1/\\epsilon)^3)$\n- **算法 2:** $T_2(n, \\epsilon) = O(n \\cdot 3^{1/\\epsilon})$\n- **算法 3:** $T_3(n, \\epsilon) = O(n^{2 + 1/\\epsilon})$\n- **算法 4:** $T_4(n, \\epsilon) = O(\\frac{1}{\\epsilon^2} \\cdot n^2 \\log n)$\n\n下列哪种算法符合完全多项式时间近似方案（FPTAS）的资格？\n\nA. 仅算法2\n\nB. 仅算法1和算法4\n\nC. 仅算法2和算法3\n\nD. 仅算法3\n\nE. 所有四种算法都是 FPTAS。", "solution": "我们使用以下定义：\n- 如果一个算法对于每个固定的 $\\epsilon0$，其运行时间都是关于 $n$ 的多项式，那么它就是一个 PTAS。\n- 如果一个算法是 PTAS，并且其运行时间同时也是关于 $n$ 和 $1/\\epsilon$ 的多项式，那么它就是一个 FPTAS。形式上，应存在常数 $a,b \\geq 0$ 和一个常数 $C0$，使得 $T(n,\\epsilon) \\leq C \\cdot n^{a} \\cdot (1/\\epsilon)^{b}$ 成立（可能相差一个 $n$ 的多对数因子）。\n\n我们逐一检查每个算法：\n\n算法1: $T_{1}(n,\\epsilon) = O(n^{4} + (1/\\epsilon)^{3})$。这是一个关于 $n$ 的多项式与一个关于 $1/\\epsilon$ 的多项式之和。因此，$T_{1}(n,\\epsilon)$ 同时是关于 $n$ 和 $1/\\epsilon$ 的多项式，所以算法1是 FPTAS。\n\n算法2: $T_{2}(n,\\epsilon) = O(n \\cdot 3^{1/\\epsilon}) = O(n \\cdot \\exp((\\ln 3)/\\epsilon))$。因子 $3^{1/\\epsilon}$ 是关于 $1/\\epsilon$ 的指数函数，并且不被任何关于 $1/\\epsilon$ 的多项式所界定。因此，它不是关于 $1/\\epsilon$ 的多项式，所以算法2不是 FPTAS（尽管它是一个 PTAS，因为对于固定的 $\\epsilon$，因子 $3^{1/\\epsilon}$ 是一个常数）。\n\n算法3: $T_{3}(n,\\epsilon) = O(n^{2+1/\\epsilon}) = O(n^{2} \\cdot n^{1/\\epsilon}) = O(n^{2} \\cdot \\exp((\\ln n)/\\epsilon))$。这里 $n$ 的指数依赖于 $1/\\epsilon$。如果对于某个固定的 $a,b$，FPTAS 的界 $T(n,\\epsilon) \\leq C \\cdot n^{a} \\cdot (1/\\epsilon)^{b}$ 成立，那么对于足够小的 $\\epsilon$，我们将有 $1/\\epsilon  a$，并且当 $n \\to \\infty$ 时，项 $n^{1/\\epsilon}$ 将超过任何固定的幂 $n^{a}$，这与该界矛盾。因此，算法3不是 FPTAS（尽管它是一个 PTAS，因为对于固定的 $\\epsilon$，运行时间是关于 $n$ 的多项式）。\n\n算法4: $T_{4}(n,\\epsilon) = O((1/\\epsilon)^{2} \\cdot n^{2} \\ln n)$。这是关于 $1/\\epsilon$ 的多项式，也是关于 $n$ 的多项式（因为对于足够大的 $n$，$n^{2} \\ln n$ 被一个更高次的 $n$ 的多项式所上界，如 $n^3$）。因此，算法4是 FPTAS。\n\n综合以上分析，只有算法1和算法4是 FPTAS。", "answer": "$$\\boxed{B}$$", "id": "1435966"}, {"introduction": "虽然 PTAS 提供了任意接近最优解的保证，但其实用性可能有限。这个问题 [@problem_id:1435944] 通过一个场景揭示了 PTAS 和 FPTAS 之间的关键区别：即使一个算法的运行时间对于固定的 $\\epsilon$ 是 $n$ 的多项式，但在高精度要求下，它也可能变得计算上不可行。这有力地提醒我们，运行时间对 $1/\\epsilon$ 的依赖性至关重要。", "problem": "一家专门从事物流的科技创业公司正在开发一种算法，以优化其自动驾驶无人机机队的配送路线。该问题是一个最小化问题，旨在找到访问 $n$ 个地点的集合的最短可能路径。他们正在使用一种被称为多项式时间近似方案（Polynomial-Time Approximation Scheme, PTAS）的算法。对于任何给定的误差容限 $\\epsilon  0$，PTAS保证其解的总长度不超过绝对最优解长度的 $(1+\\epsilon)$ 倍。\n\n该公司正在使用的特定PTAS实现具有已知的时间复杂度，以基本计算操作的数量来衡量，由函数 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$ 给出，其中 $n$ 是配送地点的数量，常数 $c = 10^5$。\n\n管理层已规定，对于一个拥有 $n=60$ 个配送地点的中型城市的新服务，计算出的无人机路线必须保证比数学上的最优路线长不超过 $2\\%$。计算该算法为满足此保证而进行单次路线计算所需的总基本操作数。将您的答案用科学记数法表示，并四舍五入到三位有效数字。", "solution": "该问题要求计算一个特定的近似算法为寻找无人机路线所需的基本操作数。该算法的性能由其时间复杂度函数和近似质量来描述。\n\n首先，让我们确定问题陈述中给出的参数。\n配送地点的数量是 $n=60$。\n时间复杂度函数中的常数是 $c=10^5$。\n时间复杂度函数是 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$。\n\n管理层的要求是，算法生成的路线长度不得超过最优路线的 $2\\%$。对于一个最小化问题，多项式时间近似方案（PTAS）产生一个值为 $S$ 的解，使得 $S \\le (1+\\epsilon) \\cdot OPT$，其中 $OPT$ 是最优解的值。\n\n一个比最优解长 $2\\%$ 的解可以表示为 $OPT + 0.02 \\cdot OPT = 1.02 \\cdot OPT$。\n因此，我们可以将近似保证因子 $(1+\\epsilon)$ 设为 $1.02$。\n$$1 + \\epsilon = 1.02$$\n求解误差容限 $\\epsilon$，我们得到：\n$$\\epsilon = 1.02 - 1 = 0.02$$\n\n现在我们有了所有必要的值，可以使用给定的时间复杂度函数 $T(n, \\epsilon)$ 来计算基本操作的数量。\n我们将 $n=60$，$c=10^5$ 和 $\\epsilon=0.02$ 代入公式 $T(n, \\epsilon) = c \\cdot n^{1/\\epsilon}$。\n\n首先，我们计算指数 $1/\\epsilon$：\n$$\\frac{1}{\\epsilon} = \\frac{1}{0.02} = 50$$\n\n现在，将这个指数和其他值代入函数 $T$：\n$$T(60, 0.02) = 10^5 \\cdot 60^{50}$$\n\n这是一个非常大的数字，所以我们必须使用对数来处理它，并将其表示为科学记数法。我们想找到一个值 $T$，使得 $T = A \\times 10^k$，其中 $1 \\le A  10$。\n让我们对该表达式取以10为底的对数：\n$$\\log_{10}(T) = \\log_{10}(10^5 \\cdot 60^{50})$$\n使用对数性质 $\\log(ab) = \\log(a) + \\log(b)$：\n$$\\log_{10}(T) = \\log_{10}(10^5) + \\log_{10}(60^{50})$$\n使用对数性质 $\\log(x^y) = y\\log(x)$ 和 $\\log_{10}(10^z) = z$：\n$$\\log_{10}(T) = 5 + 50 \\cdot \\log_{10}(60)$$\n我们可以近似计算 $\\log_{10}(60)$：\n$$\\log_{10}(60) = \\log_{10}(6 \\times 10) = \\log_{10}(6) + \\log_{10}(10) = \\log_{10}(2 \\times 3) + 1 = \\log_{10}(2) + \\log_{10}(3) + 1$$\n使用 $\\log_{10}(2) \\approx 0.30103$ 和 $\\log_{10}(3) \\approx 0.47712$ 的标准近似值：\n$$\\log_{10}(60) \\approx 0.30103 + 0.47712 + 1 = 1.77815$$\n现在我们将这个值代回 $\\log_{10}(T)$ 的表达式中：\n$$\\log_{10}(T) = 5 + 50 \\cdot (1.77815)$$\n$$\\log_{10}(T) = 5 + 88.9075$$\n$$\\log_{10}(T) = 93.9075$$\n这意味着 $T = 10^{93.9075}$。为了将其写成科学记数法，我们分离指数的整数和小数部分：\n$$T = 10^{0.9075} \\times 10^{93}$$\n现在我们计算尾数的值，即 $10^{0.9075}$：\n$$10^{0.9075} \\approx 8.0814$$\n所以，总操作数大约是：\n$$T \\approx 8.0814 \\times 10^{93}$$\n问题要求答案四舍五入到三位有效数字。\n$$T \\approx 8.08 \\times 10^{93}$$\n这个天文数字般的巨大数值说明了即使对于中等规模的输入和看似宽松的精度要求，使用此类PTAS也面临着实际挑战。尽管对于固定的 $\\epsilon$，该算法是“多项式时间”的，但多项式的次数 $1/\\epsilon$ 使其在计算上是不可行的。", "answer": "$$\\boxed{8.08 \\times 10^{93}}$$", "id": "1435944"}, {"introduction": "现在你已经能够区分不同的近似方案 [@problem_id:1435966] 并理解它们的实际意义 [@problem_id:1435944]，是时候亲手构建一个了。最后的这个练习将指导你为 0/1 背包问题设计一个完整的 FPTAS，它综合运用了值缩放和动态规划这一强大技术。", "problem": "考虑经典的 **0/1 背包问题**：给定 $n$ 个物品，每个物品 $i$ 都有一个正整数价值 $v_i > 0$ 和一个正整数重量 $w_i > 0$。还有一个容量为 $W$ 的背包。*可行解*是物品的一个子集，其总重量不超过 $W$。目标是找到一个可行解，使其总价值最大。该最大价值表示为 $V^*$。\n\n对于一个最大化问题，如果一个算法对于任意给定的误差参数 $\\epsilon > 0$，都能产生一个价值为 $V_{sol}$ 的解，满足 $V_{sol} \\ge (1-\\epsilon)V^*$，并且其运行时间在输入规模 $n$ 和 $1/\\epsilon$ 上都是多项式的，那么该算法就是一个*完全多项式时间近似方案 (FPTAS)*。\n\n考虑一个解决 0/1 背包问题的算法策略，该策略按以下步骤进行：\n1. 所有原始物品价值 $v_i$ 通过一个缩放和取整的过程，被转换为新的整数价值 $v'_i$。\n2. 然后使用一个基于动态规划的精确算法，来找到具有新价值 $v'_i$ 的问题实例的最大价值解。\n3. 第 2 步中找到的解所对应的物品集合作为原始问题的近似解返回。\n\n你的任务是完整地阐述这个策略，以创建一个有效的 FPTAS。这包括定义缩放变换和为缩放后的问题选择一个合适的精确算法。根据你的设计，确定函数 $f(n, \\epsilon)$，使得你的 FPTAS 的总运行时间为 $O(f(n, \\epsilon))$。假设 $n \\ge 2$ 且 $0  \\epsilon \\le 1$。", "solution": "我们将为 0/1 背包问题构建一个完全多项式时间近似方案 (FPTAS)。该问题的标准伪多项式时间解法是基于动态规划的，其运行时间为 $O(n \\cdot V^*)$，其中 $V^*$ 是最优解的总价值。当 $V^*$ 很大时，该算法效率低下。我们的目标是通过缩放价值来降低运行时间，同时保证解的质量。\n\n**1. 缩放和取整**\n\n首先，找到所有物品中的最大价值，记为 $V_{max} = \\max_{1 \\le i \\le n} v_i$。然后，定义一个缩放因子 $K$，它依赖于误差参数 $\\epsilon$ 和输入规模 $n$：\n$$K = \\frac{\\epsilon V_{max}}{n}$$\n利用这个因子，我们为每个物品 $i$ 计算一个新的、缩放后的价值 $v'_i$：\n$$v'_i = \\left\\lfloor \\frac{v_i}{K} \\right\\rfloor$$\n这些新的价值 $v'_i$ 都是整数，并且比原始价值 $v_i$ 小得多。\n\n**2. 动态规划求解缩放后的问题**\n\n现在，我们用原始重量 $w_i$ 和新的价值 $v'_i$ 来解决背包问题。我们可以使用一个动态规划算法，其状态 $DP[v']$ 表示获得总价值恰好为 $v'$ 所需的最小总重量。该DP的状态转移方程为：\n$$DP[v'] = \\min_{i \\in \\{1,\\dots,n\\}} \\{ DP[v' - v'_i] + w_i \\}$$\n初始化 $DP[0]=0$ 且所有其他 $DP[v'] = \\infty$。我们从所有使得 $DP[v'] \\le W$ 的 $v'$ 中，找到最大的那个 $v'_{sol}$。对应的物品集合就是我们的近似解。\n\n**3. 运行时间分析**\n\n该算法的运行时间由动态规划部分主导。DP表的大小取决于可能的最大总价值。在新问题中，最优解的总价值 $V'_{opt}$ 不会超过所有物品的缩放价值之和。由于最优解最多包含 $n$ 个物品，我们可以得到一个更紧的界：\n$$V'_{opt} = \\sum_{i \\in \\text{opt_set}} v'_i \\le \\sum_{i=1}^n v'_i = \\sum_{i=1}^n \\left\\lfloor \\frac{v_i}{K} \\right\\rfloor \\le \\sum_{i=1}^n \\frac{v_i}{K}$$\n在最优解中，每个物品的价值 $v_i$ 不超过 $V_{max}$，并且最多有 $n$ 个物品。因此，最优解的总价值 $V^*$ 最多为 $n \\cdot V_{max}$。\n所以，新问题的最大总价值可以被界定为：\n$$V'_{max\\_total} \\le \\frac{n \\cdot V_{max}}{K} = \\frac{n \\cdot V_{max}}{\\epsilon V_{max} / n} = \\frac{n^2}{\\epsilon}$$\n动态规划算法的复杂度为 $O(n \\cdot V'_{max\\_total})$。将上述界代入，得到总运行时间：\n$$T(n, \\epsilon) = O\\left(n \\cdot \\frac{n^2}{\\epsilon}\\right) = O\\left(\\frac{n^3}{\\epsilon}\\right)$$\n这个运行时间是 $n$ 和 $1/\\epsilon$ 的多项式，因此满足 FPTAS 的要求。所以，$f(n, \\epsilon) = \\frac{n^3}{\\epsilon}$。\n\n**4. 近似比分析 (证明其为 FPTAS)**\n\n设 $S_{opt}$ 为原始问题的最优解集，其总价值为 $V^*$。设 $S_{sol}$ 为我们算法找到的解集（即缩放问题的最优解），其在原始问题中的总价值为 $V_{sol}$。\n对于任意物品 $i$，由取整的性质可知：\n$$K \\cdot v'_i \\le v_i  K \\cdot (v'_i + 1)$$\n对于整个解集 $S_{opt}$，我们有：\n$$V^* = \\sum_{i \\in S_{opt}} v_i  \\sum_{i \\in S_{opt}} K(v'_i + 1) = K \\sum_{i \\in S_{opt}} v'_i + K|S_{opt}| \\le K \\sum_{i \\in S_{opt}} v'_i + K n$$\n我们的算法找到了缩放问题的最优解，所以其缩放总价值不小于任何其他可行解（包括 $S_{opt}$）的缩放总价值：\n$$\\sum_{i \\in S_{sol}} v'_i \\ge \\sum_{i \\in S_{opt}} v'_i$$\n现在看我们解的原始价值：\n$$V_{sol} = \\sum_{i \\in S_{sol}} v_i \\ge \\sum_{i \\in S_{sol}} K v'_i = K \\sum_{i \\in S_{sol}} v'_i \\ge K \\sum_{i \\in S_{opt}} v'_i$$\n结合之前的两个不等式：\n$$K \\sum_{i \\in S_{opt}} v'_i > V^* - Kn$$\n所以：\n$$V_{sol} > V^* - Kn$$\n代入 $K$ 的定义：\n$$V_{sol} > V^* - n \\left(\\frac{\\epsilon V_{max}}{n}\\right) = V^* - \\epsilon V_{max}$$\n由于 $V_{max}$ 是单个物品的最大价值，最优解的总价值 $V^*$ 必然大于等于 $V_{max}$ (假设该物品能放入背包，否则可以忽略)。因此，$V_{max} \\le V^*$。\n$$V_{sol} > V^* - \\epsilon V^* = (1-\\epsilon)V^*$$\n这证明了我们的算法是一个 $(1-\\epsilon)$-近似算法。结合运行时间分析，该算法是一个完整的 FPTAS。", "answer": "$$\\boxed{\\frac{n^{3}}{\\epsilon}}$$", "id": "1425213"}]}