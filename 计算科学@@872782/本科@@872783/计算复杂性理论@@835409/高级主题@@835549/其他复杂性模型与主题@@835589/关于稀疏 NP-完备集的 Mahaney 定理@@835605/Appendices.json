{"hands_on_practices": [{"introduction": "在应用一个定理之前，仔细检验其前提条件是否满足是至关重要的一步。马哈尼定理的一个核心前提是存在一个“稀疏”的 NP 完全语言。这个练习将带你实践如何验证一个语言是否满足稀疏性，通过分析一个具体的、我们熟知的语言 `COMPOSITES`（合数），你将理解为什么稀疏性是一个不可或缺的、非平凡的约束。[@problem_id:1431120]", "problem": "在计算复杂性理论中，一个语言 $L \\subseteq \\{0,1\\}^*$ 被定义为**稀疏的** (sparse)，如果存在一个多项式 $p(n)$，使得对于所有正整数 $n$，语言 $L$ 中长度为 $n$ 的字符串数量至多为 $p(n)$。也就是说，满足 $|L \\cap \\{0,1\\}^n| \\le p(n)$。\n\n**马哈尼定理** (Mahaney's Theorem) 指出，如果任何稀疏语言是 NP-完全的，那么 P = NP。\n\n现在，考虑语言 `COMPOSITES`，它被定义为所有表示合数的二进制字符串的集合。例如，字符串 \"110\"（表示整数 6）在 `COMPOSITES` 中，而字符串 \"101\"（表示整数 5）则不在其中。\n\n假设，一位计算机科学家证明了 `COMPOSITES` 语言是 NP-完全的。基于这个假设性的证明，以下哪个陈述正确地解释了为什么马哈尼定理**不能**被用来立即得出 P = NP 的结论？\n\nA. 语言 `COMPOSITES` 不是一个稀疏语言。\n\nB. 已知语言 `COMPOSITES` 不在 NP 类中。\n\nC. 马哈尼定理仅适用于已知在 P 类中的语言。\n\nD. 素数的数量是有限的，这意味着 `COMPOSITES` 不是稀疏的。\n\nE. 马哈尼定理不能应用于数论问题。", "solution": "根据定义，一个语言 $L \\subseteq \\{0,1\\}^*$ 是稀疏的，如果存在一个多项式 $p(n)$，使得对于所有正整数 $n$，都有 $|L \\cap \\{0,1\\}^{n}| \\leq p(n)$。\n\n马哈尼定理指出：如果存在一个（在多项式时间多一归约下）NP-完全的稀疏语言，那么 $P=NP$。因此，要将马哈尼定理应用于任何特定的 NP-完全语言 $L$，语言 $L$ 必须是稀疏的。\n\n考虑 $L=\\text{COMPOSITES}$。对于每个整数 $n \\geq 3$，我们考察 $\\{0,1\\}^{n}$ 中最高有效位为 $1$ 且最低有效位为 $0$ 的字符串子集。这样的字符串恰好有 $2^{n-2}$ 个，因为第一位固定为 $1$，最后一位固定为 $0$，剩下的 $n-2$ 位是任意的。每个这样的字符串编码了区间 $[2^{n-1},\\,2^{n}-2]$ 内的一个偶数。这个区间内的每个偶数都大于 $2$，因此是合数。所以，\n$$\n|\\text{COMPOSITES} \\cap \\{0,1\\}^{n}| \\;\\geq\\; 2^{n-2} \\quad \\text{for all } n \\geq 3.\n$$\n由于 $2^{n-2}$ 随 $n$ 指数级增长，对于任何多项式 $p(n)$，都存在一个 $n$ 使得 $2^{n-2} > p(n)$。因此，不存在一个多项式 $p(n)$ 能成为所有 $n$ 的 $|\\text{COMPOSITES} \\cap \\{0,1\\}^{n}|$ 的上界，所以 $\\text{COMPOSITES}$ 不是稀疏的。\n\n因此，即使在 `COMPOSITES` 是 NP-完全的假设下，也无法援引马哈尼定理来得出 $P=NP$ 的结论，因为其先决条件（即该 NP-完全语言是稀疏的）不成立。在这些选项中，这正是陈述 A。陈述 B、C、D 和 E 都是不正确的：COMPOSITES 属于 NP 类；马哈尼定理不要求该语言在 P 类中；素数的集合是无限的；并且该定理并未被限制不能应用于数论语言。", "answer": "$$\\boxed{A}$$", "id": "1431120"}, {"introduction": "理解了稀疏性之后，我们来关注马哈尼定理的另一个关键条件：“NP 完全”。这个术语经常与“NP 难”混淆，从而导致对理论结论的误读。本练习旨在通过辨析一个常见的逻辑谬误，帮助你精确区分 NP 完全和 NP 难这两个概念，这是准确运用马哈尼定理及其反证形式的基石。[@problem_id:1431081]", "problem": "在计算复杂性理论中，我们分析解决计算问题所需的资源。该分析依赖于几个关键定义：\n\n- **语言**（language）是有限字母表上的一组字符串。我们可以将语言看作是代表一个判定问题，其中语言中的字符串是“是”（yes）的实例。\n- 如果存在一个多项式 $p(n)$，使得语言 $S$ 中长度至多为 $n$ 的字符串数量受 $p(n)$ 的限制，则称该语言 $S$ 是**稀疏的**（sparse）。通俗地说，对于给定的输入大小，稀疏语言的“是”实例数量是多项式有界的。\n- 如果非确定性多项式时间（NP）类中的每个问题都可以在多项式时间内归约到语言 $L$，则称语言 $L$ 是**NP难的**（NP-hard）。NP难问题至少与NP中最难的问题一样难。\n- 如果语言 $L$ 既是NP难的，又本身属于NP类，则称其为**NP完全的**（NP-complete）。\n- **马哈尼定理**（Mahaney's Theorem）陈述：如果一个稀疏语言是NP完全的，那么 P = NP。\n\n一位正在上计算复杂性理论入门课程的学生根据这些定义提出了以下论点：\n\n“研究人员的压倒性共识是 P $\\neq$ NP。让我们接受这个作为工作假设。马哈尼定理的逆否命题是：如果 P $\\neq$ NP，那么没有稀疏语言可以是NP完全的。这是一个直接的逻辑推论。由此，我们可以得出结论，假设 P $\\neq$ NP，没有稀疏语言可以是NP难的。”\n\n该学生的最终结论在逻辑上是有缺陷的。以下哪个陈述最准确地指出了该学生推理中的错误？\n\nA. 该学生正确地陈述了马哈尼定理的逆否命题，但得出了一个不正确的最终结论。一个非NP完全的语言不一定不是NP难的；它可能是NP难的，但不属于NP类。\n\nB. 该学生的论证是无效的，因为 P $\\neq$ NP 假设未经证实，因此不能在有效的逻辑论证中用作前提。\n\nC. 稀疏集的概念与NP难度不相容。根据定义，一个NP难问题必须具有密集的实例集，以便允许所有NP问题的归约，因此稀疏的NP难语言是一个自相矛盾的术语。\n\nD. 该学生错误地构建了马哈尼定理的逆否命题。正确的逆否命题是：“如果 P = NP，那么至少存在一个稀疏语言不是NP完全的。”", "solution": "我们从马哈尼定理开始：“如果一个稀疏语言是NP完全的，那么 $P=NP$。”其逻辑上等价的逆否命题是：“如果 $P \\neq NP$，那么没有稀疏语言可以是NP完全的。”该学生对逆否命题的陈述是正确的。\n\n接下来，回想定义：一个语言是NP完全的，当且仅当它既是NP难的又属于 $NP$ 类。因此，\n- “非NP完全”意味着“要么不是NP难的，要么不属于 $NP$ 类（或两者皆是）。”\n- 因此，从“没有稀疏语言是NP完全的”，不能得出“没有稀疏语言是NP难的”的结论，因为在逻辑上一个稀疏语言可能既是NP难的又不属于 $NP$ 类。\n\n因此，该学生的错误在于从“没有稀疏语言是NP完全的”到“没有稀疏语言是NP难的”的无效推断。正确的识别是，“非NP完全”并不意味着“非NP难”，因为一个语言可以是NP难的而不属于 $NP$ 类。\n\n评估选项：\n- A 正确地指出了这个逻辑错误：一个语言可能因为不属于 $NP$ 类而未能成为NP完全，但它仍然可以是NP难的。\n- B 是不正确的：在条件论证中使用 $P \\neq NP$ 作为工作假设在逻辑上是可行的。\n- C 是错误的：稀疏性与NP难度在定义上并非不相容。\n- D 给出了一个不正确的逆否命题；该学生的逆否命题已经是正确的。\n\n因此，对该错误最准确的识别是 A。", "answer": "$$\\boxed{A}$$", "id": "1431081"}, {"introduction": "马哈尼定理的精髓不仅在于其结论（如果稀疏 NP 完全集存在，则 P = NP），更在于其构造性的证明过程。这个练习将挑战你像计算复杂性理论家一样思考，将证明的核心思想——即在多项式时间内枚举一个稀疏集——转化为一个强大的算法。通过解决这个为布尔可满足性问题（SAT）寻找具体解的搜索问题，你将揭示该定理背后所蕴含的深刻而实用的算法力量。[@problem_id:1431119]", "problem": "在计算复杂性理论中，不同复杂性类之间的关系是一个核心研究对象。Mahaney 定理提供了 NP 类（非确定性多项式时间）与稀疏集之间的一个深刻联系。一个集合 $S$ 被定义为稀疏的，如果存在一个多项式 $p$，使得 $S$ 中长度不超过 $n$ 的字符串数量（由普查函数 $C_S(n) = |\\{x \\in S : |x| \\le n\\}|$ 表示）受 $p(n)$ 的界定。\n\nMahaney 定理指出，如果任何 NP-完全问题有一个到稀疏集的多项式时间多一对一归约，那么 P = NP。该证明中使用的一项关键技术是，在该假设下，可以首先在多项式时间内（使用 SAT 预言机）计算普查函数 $C_S(n)$，然后同样在多项式时间内枚举稀疏集 $S$ 中直到给定长度的所有成员。\n\n考虑布尔可满足性 (SAT) 问题。假设 SAT 通过一个可计算的归约函数 $f$ 多项式时间多一对一归约到一个稀疏集 $S$。设 $\\phi$ 是一个给定的、具有 $n$ 个变量 $\\{x_1, \\ldots, x_n\\}$ 的可满足布尔公式。你的任务是找到 $\\phi$ 的字典序最小的满足赋值。一个赋值 $(v_1, \\ldots, v_n) \\in \\{0, 1\\}^n$ 在字典序上小于另一个赋值 $(v'_1, \\ldots, v'_n)$，如果在它们第一个不同的索引 $i$ 处，有 $v_i  v'_i$（将 0 视为小于 1）。\n\n下列哪个选项最好地描述了一个正确的、在多项式时间内运行的高效算法，该算法通过改编 Mahaney 定理证明中的技术来找到 $\\phi$ 的字典序最小满足赋值？\n\nA. 对可能的赋值空间使用二分搜索。在每一步中，构造一个新公式，断言该赋值在特定的字典序范围内。使用归约 $f$ 和稀疏集 $S$ 的预言机来检查这个新公式的可满足性。\n\nB. 应用标准的 SAT 自归约算法。对于从 $1$ 到 $n$ 的每个变量 $x_i$，创建临时公式 $\\phi' = \\phi[x_i=0]$。为了判断 $\\phi'$ 是否可满足，计算其归约 $f(\\phi')$ 并查询稀疏集 $S$ 的预言机。如果查询返回‘是’，则固定 $x_i=0$；否则，固定 $x_i=1$。\n\nC. 首先，使用带有 SAT 查询的二分搜索，为所有相关长度 $m$ 计算普查函数 $C_S(m)$。然后，对于给定的公式 $\\phi$，使用归约 $f$ 和普查信息来确认其可满足性。如果可满足，则输出一个预先计算好的、适用于所有可满足公式的通用满足赋值。\n\nD. 首先，使用一个涉及二分搜索和 SAT 预言机的多项式时间过程（即“普查计算技术”），找到并列出稀疏集 $S$ 中所有长度不超过 $f(\\psi)$ 最大可能长度的字符串，其中 $\\psi$ 是从 $\\phi$ 派生的任何子问题。存储这些字符串。然后，对 $\\phi$ 执行标准的自归约搜索，其中每个子问题的可满足性检查是通过计算其归约并在预先计算的 $S$ 字符串列表中检查其是否存在来实现的。", "solution": "我们给定一个从 SAT 到稀疏集 $S \\subseteq \\{0,1\\}^*$ 的多一对一归约 $f$，这意味着对于任何布尔公式 $\\psi$，$\\psi$ 可满足当且仅当 $f(\\psi) \\in S$。集合 $S$ 是稀疏的，因此存在一个多项式 $p$，使得对于所有 $n$，$C_{S}(n) \\le p(n)$，其中 $C_{S}(n) = |\\{x \\in S : |x| \\le n\\}|$。\n\n我们必须通过改编 Mahaney 定理证明中使用的技术，为给定的、具有变量 $\\{x_{1},\\ldots,x_{n}\\}$ 的可满足公式 $\\phi$ 找到字典序最小的满足赋值。关键技术是：\n1) 使用 SAT 预言机为所有相关长度 $m$ 计算普查函数 $C_{S}(m)$，以及\n2) 使用普查结果在多项式时间内枚举 $S$ 中直到这些长度的所有成员。\n\n首先，固定一个多项式 $q$ 来界定归约 $f$ 的输出长度。由于 $f$ 可在多项式时间内计算，因此存在一个多项式 $q$，使得对于任何长度为 $|\\psi|$ 的输入 $\\psi$，我们有 $|f(\\psi)| \\le q(|\\psi|)$。在对 $\\phi$ 进行标准的 SAT 自归约期间，我们仅通过固定 $\\phi$ 中变量的前缀来创建子公式 $\\psi$，因此每个这样的 $\\psi$ 的大小最多为 $c|\\phi|$，其中 $c$ 是某个常数。定义 \n$$\nL = q(c|\\phi|).\n$$\n那么对于自归约期间派生的每个子公式 $\\psi$，都有 $|f(\\psi)| \\le L$。\n\n使用 Mahaney 定理证明中的普查计算技术和 SAT 预言机，我们在多项式时间内计算所有 $m \\le L$ 的 $C_{S}(m)$。然后，再次使用相同的技术，我们枚举集合 \n$$\nT = \\{ y \\in S : |y| \\le L \\}.\n$$\n这个枚举是可以在多项式时间内完成的，因为 $|T| \\le C_{S}(L) \\le p(L)$，并且如证明中所示，枚举的每一步都可以通过对字典序区间的二分搜索结合 SAT 预言机查询来引导。我们存储 $T$ 以便进行成员资格查询。\n\n现在执行标准的自归约过程来找到字典序最小的满足赋值。对于 $i$ 从 $1$ 到 $n$：\n- 设 $\\psi$ 是通过将 $x_{1},\\ldots,x_{i-1}$ 固定为已选定的值，并设置 $x_{i}=0$ 而得到的公式。\n- 在多项式时间内计算 $y = f(\\psi)$。\n- 由于 $|y| \\le L$，我们有 $\\psi$ 可满足当且仅当 $y \\in S$，这等价于 $y \\in T$，因为 $T = S \\cap \\{0,1\\}^{\\le L}$。如果 $y \\in T$，则设置 $x_{i}=0$；否则，设置 $x_{i}=1$。\n\n正确性：在每一步中，我们都尽可能选择 $x_{i}=0$，从而确保最终的赋值在所有满足赋值中是字典序最小的。等价关系 $\\psi \\in \\text{SAT} \\Leftrightarrow f(\\psi) \\in S$ 保证了检查 $y \\in T$ 可以精确地判断每个子问题 $\\psi$ 的可满足性。\n\n复杂性：计算 $L$ 和 $f(\\psi)$ 的时间是关于 $|\\phi|$ 的多项式时间。通过带有 SAT 预言机的普查计算技术，计算 $C_{S}(m)$ 和枚举 $T$（对于 $m \\le L$）是多项式时间的，并且 $|T| \\le p(L)$ 是多项式有界的。自归约过程执行 $n$ 次成员资格检查 $y \\in T$，每次检查都可以通过查找在多项式时间内完成。因此，整个过程在多项式时间内运行。\n\n在这些选项中，这正是选项 D 所描述的：首先使用普查计算技术枚举 $S$ 直到所需的最大输出长度，然后运行标准的自归约，同时通过检查归约后的像是否存在于预计算的列表中来回答每个可满足性查询。选项 B 假定可以直接访问 $S$ 预言机，而不是通过枚举来模拟它；选项 A 没有改编普查枚举，也不是典型的 Mahaney 风格方法；选项 C 是不正确的，因为不存在通用的满足赋值。", "answer": "$$\\boxed{D}$$", "id": "1431119"}]}