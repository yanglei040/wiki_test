{"hands_on_practices": [{"introduction": "我们从一个基本问题开始，以建立对“愚弄集”（fooling set）方法的直观理解。这个练习将探讨如何为“等价性”函数（Equality function）建立通信复杂度的下界。通过构建一个简单的愚弄集，我们将揭示为什么即使是判断两个数字是否相等这样一个看似简单的任务，也需要一定量的通信。[@problem_id:1465070]", "problem": "在一个未来的智能城市中，车辆导航是在一个大小为 $N \\times N$ 的离散网格上管理的。网格位置由整数坐标 $(x, y)$ 表示，其中 $1 \\le x \\le N$ 且 $1 \\le y \\le N$。Alice Corp 和 Bob Inc. 各自运营一辆自动送货车。在某一时刻，Alice 的车辆位于位置 $(x_A, y_A)$，Bob 的车辆位于位置 $(x_B, y_B)$。\n\n为了管理交通和通信信道分配，他们需要确定他们的车辆是否在同一条南北向的街道上。这等同于检查它们的 x 坐标是否相同。这两家母公司决定使用一个双方通信协议来确定这一点。Alice 只知道她的车辆坐标 $(x_A, y_A)$，而 Bob 只知道他的车辆坐标 $(x_B, y_B)$。\n\n他们想要计算函数 $SVL_N((x_A, y_A), (x_B, y_B))$，如果 $x_A = x_B$ 该函数的值为 1，如果 $x_A \\neq x_B$ 则为 0。为了建立他们必须交换的比特数的理论下界，我们可以使用欺骗集方法。\n\n一个输入对集合 $S = \\{ (a_1, b_1), (a_2, b_2), \\dots, (a_k, b_k) \\}$，其中 $a_i$ 是 Alice 的输入，$b_i$ 是 Bob 的输入，如果它满足两个条件，就被称为函数 $f$ 的**欺骗集** (fooling set)：\n1.  **一致性 (Uniformity)**：存在一个常数值 $c \\in \\{0, 1\\}$，使得对于所有对 $(a_i, b_i) \\in S$，函数求值都得到这个常数：$f(a_i, b_i) = c$。\n2.  **欺骗属性 (Fooling Property)**：对于 $S$ 中任意两个不同的对 $(a_i, b_i)$ 和 $(a_j, b_j)$（即 $i \\neq j$），至少有一个“交叉”的输入组合会给出不同的结果：$f(a_i, b_j) \\neq c$ 或 $f(a_j, b_i) \\neq c$。\n\n假设 $N \\ge 4$，函数 $SVL_N$ 的最大可能欺骗集的大小是多少？\n\nA. 3\n\nB. $N-1$\n\nC. $N$\n\nD. $2N$\n\nE. $N^2$", "solution": "我们将函数形式化为\n$$\nSVL_{N}\\big((x_{A},y_{A}),(x_{B},y_{B})\\big)=\\begin{cases}\n1  \\text{若 } x_{A}=x_{B},\\\\\n0  \\text{若 } x_{A}\\neq x_{B}.\n\\end{cases}\n$$\n$SVL_{N}$ 的一个欺骗集 $S=\\{(a_{i},b_{i})\\}_{i=1}^{k}$ 必须满足：\n1) 一致性：存在一个常数 $c\\in\\{0,1\\}$ 使得对于所有的 $i$都有 $SVL_{N}(a_{i},b_{i})=c$。\n2) 欺骗属性：对于任意 $i\\neq j$，至少有 $SVL_{N}(a_{i},b_{j})\\neq c$ 或 $SVL_{N}(a_{j},b_{i})\\neq c$ 之一成立。\n\n下界（当 $c=1$ 时大小为 $N$ 的可实现性）：\n- 设 $c=1$。那么对于每一对 $(a_{i},b_{i})=((x_{A}^{(i)},y_{A}^{(i)}),(x_{B}^{(i)},y_{B}^{(i)}))$，我们必须有 $x_{A}^{(i)}=x_{B}^{(i)}$。\n- 考虑集合\n$$\nS_{1}=\\left\\{\\big((x,1),(x,1)\\big): x\\in\\{1,2,\\dots,N\\}\\right\\}.\n$$\n一致性成立，因为对于 $S_{1}$ 中的每个元素，都有 $x_{A}=x_{B}$，所以 $SVL_{N}=1$。\n对于任意两个 $x\\neq x'$ 的不同对，交叉输入 $((x,1),(x',1))$ 得出 $x\\neq x'$，因此\n$$\nSVL_{N}\\big((x,1),(x',1)\\big)=0\\neq 1,\n$$\n这满足欺骗属性。因此 $|S_{1}|=N$ 是一个有效的欺骗集，所以最大可能的大小至少为 $N$。\n\n对于任何 $c=1$ 欺骗集的上界：\n- 设 $S$ 是任何 $c=1$ 的欺骗集。那么对于每个 $(a_{i},b_{i})$，我们有 $x_{A}^{(i)}=x_{B}^{(i)}$。\n- 假设两个不同的对 $i\\neq j$ 具有相同的 $x$ 坐标，即 $x_{A}^{(i)}=x_{B}^{(i)}=x_{A}^{(j)}=x_{B}^{(j)}$。那么交叉输入满足\n$$\nSVL_{N}(a_{i},b_{j})=1 \\quad \\text{and} \\quad SVL_{N}(a_{j},b_{i})=1,\n$$\n这违反了欺骗属性（因为两个交叉值都与 $c=1$ 相同）。因此，$S$ 中所有对的 $x$ 值必须是不同的，这意味着 $|S|\\leq N$。\n\n任何欺骗集（包括 $c=0$）的全局上界：\n- 设 $S$ 是一个 $c=0$ 的欺骗集。记 $u_{i}=x_{A}^{(i)}$ 和 $v_{i}=x_{B}^{(i)}$。一致性意味着对于所有的 $i$ 都有 $u_{i}\\neq v_{i}$。\n- 假设存在 $i\\neq j$ 使得 $v_{i}=v_{j}$。考虑两个必需的交叉检查：\n$$\nSVL_{N}(a_{i},b_{j})=1 \\iff u_{i}=v_{j}=v_{i},\n$$\n和\n$$\nSVL_{N}(a_{j},b_{i})=1 \\iff u_{j}=v_{i}=v_{j}.\n$$\n这两个等式都将强制 $u_{i}=v_{i}$ 或 $u_{j}=v_{j}$，这与 $u_{i}\\neq v_{i}$ 和 $u_{j}\\neq v_{j}$ 相矛盾。因此，两个交叉评估的结果都等于 0，这违反了欺骗属性。因此，所有的 $v_i$ 必须是两两不同的，所以 $|S|\\leq N$。\n\n结合上下界：存在一个大小为 $N$ 的欺骗集（如 $c=1$ 时所构造的），且没有欺骗集的大小可以超过 $N$。因此，$SVL_N$ 的最大可能欺骗集的大小为 $N$，对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1465070"}, {"introduction": "在掌握了基本概念后，让我们将愚弄集方法应用到一个更复杂的场景中：验证两个二进制字符串是否互为反转。这个练习展示了该方法的强大之处，即如何处理结构化数据，并得出一个与输入长度 $n$ 成线性关系的紧密下界。通过这个实践，你将学会如何为涉及整个数据结构而非单个数值的函数构建一个指数级大小的愚弄集。[@problem_id:1465088]", "problem": "在一个分布式计算场景中，两方 Alice 和 Bob 需要执行一个数据验证任务。Alice 拥有一个长度为 $n$ 的二进制字符串 $x$，Bob 拥有一个相同长度 $n$ 的二进制字符串 $y$。他们想要确定 Bob 的字符串是否是 Alice 字符串的逆序。我们为此任务定义函数 $REV(x,y)$。给定 $x = x_1x_2...x_n$ 和 $y = y_1y_2...y_n$，该函数定义如下：\n$$\nREV(x,y) = \\begin{cases} 1   \\text{若对所有 } i \\in \\{1, 2, ..., n\\} \\text{，有 } y_i = x_{n-i+1} \\\\ 0  \\text{否则} \\end{cases}\n$$\nAlice 和 Bob 可以根据一个预先商定的确定性协议，通过一个信道相互发送比特来进行通信。一个协议的通信成本是在任何可能的输入对 $(x, y)$ 上交换的最大比特数。在最坏情况下，为了计算函数 $REV(x,y)$，他们必须交换的理论最小比特数是多少？你的答案应该是一个关于 $n$ 的封闭形式表达式。", "solution": "设 $n \\in \\mathbb{N}$ 且 $x,y \\in \\{0,1\\}^{n}$。定义 $\\operatorname{rev}(x)$ 为：对所有 $i \\in \\{1,\\dots,n\\}$，有 $\\operatorname{rev}(x)_{i}=x_{n-i+1}$。该函数 $REV(x,y)=1$ 当且仅当 $y=\\operatorname{rev}(x)$，否则 $REV(x,y)=0$。\n\n上界：存在一个成本为 $n$ 比特的确定性协议。例如，Alice 将 $n$ 比特的字符串 $x$ 发送给 Bob。Bob 在本地计算 $\\operatorname{rev}(x)$ 并将其与他的 $y$ 进行比较。如果 $y=\\operatorname{rev}(x)$，他输出 $1$，否则输出 $0$。因此，该协议的通信成本为 $n$，所以\n$$\nD(REV) \\leq n.\n$$\n\n下界：我们使用欺骗集方法。考虑集合\n$$\nS=\\{(x,\\operatorname{rev}(x)) : x \\in \\{0,1\\}^{n}\\}.\n$$\n对于 $S$ 中的每一个 $(x,\\operatorname{rev}(x))$，根据定义有 $REV(x,\\operatorname{rev}(x))=1$。从 $S$ 中取任意两个不同的元素 $(x,\\operatorname{rev}(x))$ 和 $(x',\\operatorname{rev}(x'))$，其中 $x \\neq x'$。那么\n$$\nREV\\bigl(x,\\operatorname{rev}(x')\\bigr)=1 \\iff \\operatorname{rev}(x')=\\operatorname{rev}(x) \\iff x'=x,\n$$\n这是错误的，所以 $REV\\bigl(x,\\operatorname{rev}(x')\\bigr)=0$。类似地，$REV\\bigl(x',\\operatorname{rev}(x)\\bigr)=0$。因此 $S$ 是一个大小为 $|S|=2^{n}$ 的 1-输入欺骗集。根据标准的欺骗集下界，确定性通信复杂度满足\n$$\nD(REV) \\geq \\log_{2}|S|=\\log_{2}(2^{n})=n.\n$$\n\n结合上界和下界，得到 $D(REV)=n$。因此，在最坏情况下交换的理论最小比特数是 $n$。", "answer": "$$\\boxed{n}$$", "id": "1465088"}, {"introduction": "除了愚弄集方法，我们还有其他强大的工具来分析通信复杂度。本练习将介绍一种基于线性代数的重要技术——对数秩下界（log-rank lower bound）。我们将把此方法应用于经典的“大于”函数（Greater-Than function），通过计算其通信矩阵的秩来确定一个精确的下界，从而为你提供解决通信下界问题的全新视角。[@problem_id:61771]", "problem": "在标准的双方通信复杂度模型中，两方（Alice 和 Bob）分别持有输入 $x \\in X$ 和 $y \\in Y$。他们的目标是通过一个确定性协议交换消息，协同计算函数 $f(x, y)$ 的值。确定性通信复杂度，记为 $D(f)$，是指对于最有效的 $f$ 协议，在最坏情况输入对 $(x, y)$ 下交换的最小比特数。\n\n为 $D(f)$ 提供下界的一个强大工具是通信矩阵 $M_f$。这是一个 $|X| \\times |Y|$ 的矩阵，其中对应于行 $x$ 和列 $y$ 的条目由 $M_f[x, y] = f(x, y)$ 给出。一个基本结果将该复杂度与此矩阵在实数域上的秩联系起来：\n$$\nD(f) \\ge \\lceil \\log_2(\\text{rank}_{\\mathbb{R}}(M_f)) \\rceil\n$$\n这被称为对数秩下界。\n\n考虑4位“大于”函数，$GT_4$。Alice 得到一个4位无符号整数 $x \\in \\{0, 1, \\dots, 15\\}$，Bob 得到一个4位无符号整数 $y \\in \\{0, 1, \\dots, 15\\}$。该函数定义如下：\n$$\nGT_4(x, y) = \\begin{cases} 1  \\text{若 } x  y \\\\ 0  \\text{若 } x \\le y \\end{cases}\n$$\n\n你的任务是计算 $GT_4$ 函数的确定性通信复杂度的对数秩下界。为此，你必须首先确定通信矩阵 $M_{GT_4}$ 的秩。", "solution": "4位“大于”函数的通信矩阵 $M_{GT_4}$ 是一个 $16 \\times 16$ 的矩阵，其行和列由输入 $x, y \\in \\{0, 1, \\dots, 15\\}$ 索引。矩阵条目定义如下：\n\n$$\nM_{GT_4}[x, y] = \\begin{cases} \n1  \\text{若 } x  y \\\\\n0  \\text{若 } x \\le y \n\\end{cases}\n$$\n\n\n该矩阵是一个严格下三角矩阵，其对角线及对角线上方元素为零，对角线下方元素为一。具体来说：\n- $x = 0$ 对应的行全为零。\n- 对于 $x = 1$，该行为 $[1, 0, 0, \\dots, 0]$。\n- 对于 $x = 2$，该行为 $[1, 1, 0, \\dots, 0]$。\n- ...\n- 对于 $x = 15$，该行为 $[1, 1, \\dots, 1, 0]$（15个1后跟一个0）。\n\n此矩阵在实数域上的秩 $\\text{rank}_{\\mathbb{R}}(M_{GT_4})$ 由线性无关的行数决定。从 $x = 1$ 到 $x = 15$ 的行是线性无关的，而 $x = 0$ 对应的行全为零，对秩没有贡献。要理解这一点，可以将这些行视为向量：\n- 行 $x = 1$：$(1, 0, 0, \\dots, 0)$\n- 行 $x = 2$：$(1, 1, 0, \\dots, 0)$\n- ...\n- 行 $x = 15$：$(1, 1, \\dots, 1, 0)$\n\n这些行构成了一个15维子空间的基。任何线性组合：\n\n$$\n\\sum_{k=1}^{15} a_k \\cdot \\text{row}_k = 0\n$$\n\n都意味着对于所有的 $k$，$a_k = 0$，这可以通过从最后一个非零条目开始令系数相等来证明。因此，秩为15。\n\n确定性通信复杂度的对数秩下界为：\n\n$$\nD(GT_4) \\ge \\lceil \\log_2(\\text{rank}_{\\mathbb{R}}(M_{GT_4})) \\rceil = \\lceil \\log_2(15) \\rceil\n$$\n\n因为 $2^3 = 8  15  16 = 2^4$，所以 $\\log_2(15)$ 介于3和4之间，因此：\n\n$$\n\\lceil \\log_2(15) \\rceil = 4\n$$\n\n所以，对数秩下界为4。", "answer": "$$ \\boxed{4} $$", "id": "61771"}]}