{"hands_on_practices": [{"introduction": "理解神谕图灵机（OTM）的最好方法之一就是亲手设计一个。这个练习 [@problem_id:1433319] 要求我们利用一个能即时判断任何数字是否为素数的“素数神谕”，来构建一个算法判断一个数是否为半素数。这项实践能帮助我们清晰地理解神谕如何充当一个“黑盒”子程序，将我们从复杂的子问题中解放出来，从而专注于更高层次的算法逻辑。", "problem": "神谕图灵机（OTM）是一种标准的图灵机，它配备了一条特殊的“神谕”带和三个特殊状态：`q_query`、`q_yes` 和 `q_no`。每当 OTM 进入 `q_query` 状态时，神谕会立即执行一次计算。如果当前在神谕带上的字符串属于一个预定义的神谕语言 $L_{oracle}$，机器就转换到 `q_yes` 状态；否则，它转换到 `q_no` 状态。这个查询-回答过程被视为一个单一的计算步骤。\n\n考虑一个 OTM，我们称之为 $M$，它可以访问一个用于语言 `PRIME` = {$k \\mid k$ 是一个质数，其中 $k$ 以二进制表示} 的神谕。机器 $M$ 的目标是判定语言 `SEMIPRIME` = {$n \\mid n$ 是一个半质数，其中 $n$ 以二进制表示}。半质数是一个自然数，它是两个质数（这两个质数不一定不同）的乘积。\n\n对于任意给定的整数输入 $n  1$，以下哪个描述准确地表示了机器 $M$ 为正确判定 `SEMIPRIME` 应该实现的高级算法？\n\nA. 遍历从 2 到 $n-1$ 的所有整数 $i$。对于每个 $i$，对 $i$ 查询 `PRIME` 神谕。如果神谕接受，则检查 $i$ 是否整除 $n$。如果整除，则停机并接受。如果循环完成仍未找到这样的 $i$，则停机并拒绝。\n\nB. 对输入 $n$ 查询 `PRIME` 神谕。如果神谕接受，则停机并拒绝。否则，遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对于每个 $i$，如果 $i$ 整除 $n$，则对 $i$ 查询 `PRIME` 神谕。如果神谕接受，则停机并接受。如果循环完成仍未找到这样的因子，则停机并拒绝。\n\nC. 遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对于每个 $i$，检查 $i$ 是否整除 $n$。如果整除，令 $j = n/i$。然后，对 $i$ 查询 `PRIME` 神谕，并对 $j$ 查询 `PRIME` 神谕。如果两个查询都被接受，则停机并接受。如果循环完成仍未找到这样的数对 $(i, j)$，则停机并拒绝。\n\nD. 对输入 $n$ 查询 `PRIME` 神谕。如果神谕接受，则停机并拒绝。否则，停机并接受。\n\nE. 遍历从 2 到 $\\lfloor \\sqrt{n} \\rfloor$ 的所有整数 $i$。对于每个 $i$，对 $i$ 查询 `PRIME` 神谕。如果神谕接受，检查 $n$ 是否能被 $i$ 整除但不能被 $i^2$ 整除。如果是，令 $j=n/i$ 并对 $j$ 查询 `PRIME` 神谕。如果第二个查询被接受，则停机并接受。如果循环完成，则拒绝。", "solution": "我们必须使用一个 PRIME 神谕来判定输入为 $n1$ 的 SEMIPRIME 语言。根据定义，当且仅当存在质数 $p$ 和 $q$ 使得 $n=pq$ 时，$n$ 是半质数，其中允许 $p=q$。令 $p \\leq q$；那么 $p \\leq \\sqrt{n}$，因为如果 $p\\sqrt{n}$，则 $pq  \\sqrt{n}\\cdot \\sqrt{n} = n$，这与前提矛盾。因此，$n$ 是半质数当且仅当存在一个整数 $i$ 满足 $2 \\leq i \\leq \\lfloor \\sqrt{n} \\rfloor$ 和 $i \\mid n$，并且 $i$ 和 $j = n/i$ 都是质数。\n\n因此，使用 PRIME 神谕，正确的高级算法必须：\n- 遍历 $i$ 从 $2$ 到 $\\lfloor \\sqrt{n} \\rfloor$。\n- 对于每个 $i$，测试可除性 $i \\mid n$。如果成立，则设置 $j=n/i$。\n- 对 $i$ 和 $j$ 查询神谕；当且仅当两者都是质数时接受。\n- 如果找不到这样的数对，则拒绝。\n\n这与选项 C 完全匹配。其他选项是不正确的：\n- A 接受任何有质数因子的 $n$，例如 $n=12$，其中 $i=2$ 是质数且整除 $n$，但 $12$ 不是半质数。\n- B 接受至少有一个小质数因子的合数，例如 $n=8$ 和 $i=2$，但 $8$ 不是半质数。\n- D 接受所有合数，因此错误地分类了非半质数的合数和质数的平方。\n- E 通过要求 $i^{2} \\nmid n$ 错误地排除了质数的平方，因此它会拒绝 $n=9$，而 $n=3\\cdot 3$ 是一个半质数。\n\n因此，只有选项 C 使用 PRIME 神谕正确地判定了 SEMIPRIME。", "answer": "$$\\boxed{C}$$", "id": "1433319"}, {"introduction": "神谕的能力取决于它能解决的问题的难度。这项练习 [@problem_id:1433316] 将我们带入计算复杂性理论的核心，利用一个能够解决布尔可满足性问题（$SAT$）的神谕——这是一个经典的 $NP$-完全问题。我们将看到，如何通过多次调用这个判定问题的神谕，来解决一个更复杂的搜索问题：在一个不可满足的逻辑公式中找到一个“最小不可满足核”。这个过程完美地诠释了图灵归约的概念，并让我们一窥 $P^{NP}$ 这类复杂性类的强大能力。", "problem": "在计算复杂性理论中，神谕图灵机是一种用于研究判定问题的抽象机器。它可以被看作是一台带有“黑箱”的标准图灵机，这个黑箱被称为神谕，能够在单次操作中判定某些问题。对于本问题，我们考虑一个用于解决布尔可满足性 (SAT) 问题的神谕。这个神谕记作 $\\mathcal{O}_{SAT}$，它接受任何合取范式 (CNF) 的布尔公式作为输入，如果公式是可满足的，则返回 `TRUE`，否则返回 `FALSE`。\n\n一个 CNF 公式是一个或多个子句的合取 (AND)，其中每个子句是文字（一个变量或其否定）的析取 (OR)。一个不可满足的 CNF 公式 $\\phi$ 可能包含一个其自身也不可满足的子句的更小子集。这样的子集被称为不可满足核。最小不可满足核是一个不可满足核，它具有这样的性质：如果从中移除任何单个子句，剩余的子句集就变得可满足。\n\n考虑以下算法 `ReduceCore`，它旨在寻找给定不可满足 CNF 公式 $\\phi = \\{C_1, C_2, \\ldots, C_m\\}$ 的一个最小不可满足核。该算法依赖于 $\\mathcal{O}_{SAT}$ 神谕。\n\n**算法：`ReduceCore`**\n1. 初始化一个工作子句集 $S$，作为输入公式 $\\phi$ 的一个副本。\n2. 按照给定的索引顺序，遍历原始公式 $\\phi$ 的子句 $C_1, C_2, \\ldots, C_m$。\n3. 对于原始公式中的每个子句 $C_i$，构造一个测试集 $S_{\\text{test}} = S \\setminus \\{C_i\\}$。注意，$S$ 可能已在之前的步骤中被修改。此测试是为了检查 $C_i$ 当前是否在 $S$ 中，以及它是否可以被移除。\n4. 如果 $C_i$ 在 $S$ 中，则用 $S_{\\text{test}}$ 查询神谕。如果 $\\mathcal{O}_{SAT}(S_{\\text{test}})$ 返回 `FALSE`（意味着在没有 $C_i$ 的情况下该集合仍然不可满足），则从工作集 $S$ 中永久移除 $C_i$。\n5. 迭代完成后，算法返回最终的工作集 $S$。\n\n给定以下在变量 $\\{a, b, c, d, e\\}$ 上的不可满足 CNF 公式 $\\Phi$。该公式由9个子句组成，索引如下：\n- $C_1: (a \\lor b)$\n- $C_2: (a \\lor \\neg b)$\n- $C_3: (\\neg a \\lor c)$\n- $C_4: (\\neg a \\lor \\neg c)$\n- $C_5: (a \\lor d)$\n- $C_6: (\\neg a \\lor \\neg d)$\n- $C_7: (a \\lor c \\lor d)$\n- $C_8: (b \\lor c)$\n- $C_9: (\\neg b \\lor \\neg c \\lor e)$\n\n当在输入公式 $\\Phi$ 上执行 `ReduceCore` 算法时，返回的最终集合中有多少个子句？", "solution": "初始化 $S=\\{C_{1},\\ldots,C_{9}\\}$。算法按顺序检查 $C_{1},\\ldots,C_{9}$。对于每个仍在 $S$ 中的 $C_{i}$，它查询 $\\mathcal{O}_{SAT}(S\\setminus\\{C_{i}\\})$，并且当且仅当神谕返回 FALSE（即，缩减后的集合仍然不可满足）时，移除 $C_{i}$。\n\n测试 $C_{1}$：考虑 $S\\setminus\\{C_{1}\\}=\\{C_{2},\\ldots,C_{9}\\}$。子句 $C_{3}:(\\neg a\\lor c)$ 和 $C_{4}:(\\neg a\\lor \\neg c)$ 共同排除了 $a=\\text{true}$ 的情况，因此可以设置 $a=\\text{false}$。于是 $C_{2}$ 变为 $\\neg b$，所以设置 $b=\\text{false}$；$C_{5}$ 变为 $d$，所以设置 $d=\\text{true}$；$C_{6}$ 被 $\\neg a$ 满足；$C_{7}$ 被 $c\\lor d$ 满足（因为 $d=\\text{true}$）；$C_{8}$ 被 $b\\lor c$ 满足（选择 $c=\\text{true}$）；$C_{9}$ 被 $\\neg b$ 满足。因此 $S\\setminus\\{C_{1}\\}$ 是可满足的，所以 $\\mathcal{O}_{SAT}$ 返回 TRUE，保留 $C_{1}$。\n\n测试 $C_{2}$：考虑 $S\\setminus\\{C_{2}\\}$。同样，$C_{3}$ 和 $C_{4}$ 使得 $a=\\text{false}$。于是 $C_{1}$ 变为 $b$，所以设置 $b=\\text{true}$；$C_{5}$ 变为 $d$，所以设置 $d=\\text{true}$；$C_{6}$ 被 $\\neg a$ 满足；$C_{7}$ 被 $c\\lor d$ 满足；$C_{8}$ 被 $b$ 满足；当 $b=\\text{true}$ 时，$C_{9}$ 需要 $\\neg c\\lor e$，所以可以选择，例如，$e=\\text{true}$。因此 $S\\setminus\\{C_{2}\\}$ 是可满足的；神谕返回 TRUE，保留 $C_{2}$。\n\n测试 $C_{3}$：考虑 $S\\setminus\\{C_{3}\\}=\\{C_{1},C_{2},C_{4},C_{5},C_{6},C_{7},C_{8},C_{9}\\}$。设置 $a=\\text{true}$ 和 $c=\\text{false}$；那么 $C_{4}$ 被 $\\neg c$ 满足，$C_{6}$ 变为 $\\neg d$，所以设置 $d=\\text{false}$，并且 $C_{1},C_{2},C_{5},C_{7}$ 都被 $a$ 满足。设置 $b=\\text{true}$，这样 $C_{8}$ 就被满足；$C_{9}$ 被 $\\neg c$ 满足。因此是可满足的；神谕返回 TRUE，保留 $C_{3}$。\n\n测试 $C_{4}$：考虑 $S\\setminus\\{C_{4}\\}$。设置 $a=\\text{true}$ 和 $c=\\text{true}$；那么 $C_{3}$ 被 $c$ 满足，$C_{6}$ 变为 $\\neg d$，所以设置 $d=\\text{false}$，并且 $C_{1},C_{2},C_{5},C_{7}$ 都被 $a$ 满足。例如，设置 $e=\\text{true}$ 使得 $C_{9}$ 被满足；$C_{8}$ 被 $c$ 满足。因此是可满足的；神谕返回 TRUE，保留 $C_{4}$。\n\n测试 $C_{5}$：考虑 $S\\setminus\\{C_{5}\\}$。子句对 $C_{3}$ 和 $C_{4}$ 排除了 $a=\\text{true}$ 的情况，所以 $a=\\text{false}$。于是 $C_{1}$ 变为 $b$ 而 $C_{2}$ 变为 $\\neg b$，这是一个矛盾。因此 $S\\setminus\\{C_{5}\\}$ 是不可满足的；神谕返回 FALSE，移除 $C_{5}$，所以 $S:=S\\setminus\\{C_{5}\\}$。\n\n测试 $C_{6}$：现在考虑 $S\\setminus\\{C_{6}\\}$，此时的 $S$ 不包含 $C_{5}$。同样的推理适用：$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，从而从 $C_{1}$ 和 $C_{2}$ 得到 $b$ 和 $\\neg b$，因此不可满足。神谕返回 FALSE，移除 $C_{6}$。\n\n测试 $C_{7}$：在 $C_{5}$ 和 $C_{6}$ 已被移除的情况下，考虑 $S\\setminus\\{C_{7}\\}$。同样，$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，从 $C_{1}$ 和 $C_{2}$ 产生 $b$ 和 $\\neg b$，因此不可满足。神谕返回 FALSE，移除 $C_{7}$。\n\n测试 $C_{8}$：考虑 $S\\setminus\\{C_{8}\\}$。和之前一样，$C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，所以 $C_{1}$ 和 $C_{2}$ 在 $b$ 上产生矛盾。因此不可满足；神谕返回 FALSE，移除 $C_{8}$。\n\n测试 $C_{9}$：考虑 $S\\setminus\\{C_{9}\\}=\\{C_{1},C_{2},C_{3},C_{4}\\}$。由于 $C_{3}$ 和 $C_{4}$ 迫使 $a=\\text{false}$，$C_{1}$ 变为 $b$ 而 $C_{2}$ 变为 $\\neg b$，产生矛盾。因此不可满足；神谕返回 FALSE，移除 $C_{9}$。\n\n迭代完成后，最终集合是 $S=\\{C_{1},C_{2},C_{3},C_{4}\\}$，它包含 $4$ 个子句，并且是包含关系上的最小不可满足集（移除这四个中的任何一个都会得到一个可满足的集合）。", "answer": "$$\\boxed{4}$$", "id": "1433316"}, {"introduction": "神谕不仅是解决问题的工具，更是探索计算理论边界的深刻概念。这个练习 [@problem_id:1433334] 引导我们思考一个非凡的问题：是否所有“不可解”的问题都具有相同的难度？通过使用神谕，我们可以构建出新的、难度更高的不可判定语言，从而形成一个无穷的难度等级阶梯。这项实践揭示了相对可计算性的核心思想，并引入了如图灵跳跃（Turing jump）这样的高级概念，展示了神谕在理论计算机科学中的奠基性作用。", "problem": "在可计算性理论中，神谕图灵机（Oracle Turing Machine, OTM）是标准图灵机（Turing Machine, TM）的一种变体，它增加了一个被称为“神谕”（oracle）的黑盒组件。对于一个语言 $L$，带有 $L$ 的神谕的 OTM $M^L$ 可以在一个计算步骤内判断任意给定的字符串 $s$ 是否属于 $L$。我们称语言 $A$ 图灵可归约到语言 $B$，记作 $A \\le_T B$，如果存在一个带有语言 $B$ 的神谕的 OTM 可以判定语言 $A$。如果该 OTM 在多项式时间内运行，我们称 $A$ 可在多项式时间内图灵归约到 $B$，记作 $A \\le_P^B$。\n\n这个概念允许我们比较不可判定问题的相对难度。本题要求你找出一对语言，用以展示不可判定性中的严格层级。\n\n设以下语言定义在字母表 $\\{0,1\\}$ 上：\n- **停机问题 ($H$)**：$H = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一个在输入 } w \\text{ 上会停机的图灵机} \\}$。\n- **相对化停机问题 ($H^L$)**：对于一个给定的神谕语言 $L$，$H^L = \\{ \\langle M^L, w \\rangle \\mid M^L \\text{ 是一个带有神谕 } L \\text{ 的 OTM，且在输入 } w \\text{ 上会停机} \\}$。注意，一个普通的图灵机可以被看作是从不查询其神谕的 OTM 的一个特例。\n\n你的任务是从以下选项中找出一对语言 $(A, B)$，使其同时满足以下所有四个条件：\n1. 语言 $A$ 是不可判定的。\n2. 语言 $B$ 是不可判定的。\n3. 语言 $A$ 可由一个带有语言 $B$ 的神谕的图灵机在多项式时间内判定（即 $A \\le_P^B$）。\n4. 语言 $B$ **不能**被任何带有语言 $A$ 的神谕的图灵机判定（即 $B \\not\\le_T A$）。\n\n以下哪对 $(A, B)$ 满足所有四个条件？\n\nA. $A = H$ 且 $B = H^H$\nB. $A = H^H$ 且 $B = H$\nC. $A = H$ 且 $B = \\overline{H}$ (其中 $\\overline{H}$ 是 $H$ 的补集)\nD. $A = \\{1^n \\mid n \\text{ 是一个素数}\\}$ 且 $B = H$\nE. $A = H$ 且 $B = H$", "solution": "我们利用关于图灵归约、神谕和图灵跳跃（Turing jump）的标准结论，逐一分析每个选项是否满足这四个条件。\n\n关键原理：\n- $H$ 是不可判定的。\n- 对于任何语言 $L$，其相对化停机问题 $H^{L}$（即图灵跳跃 $L'$）满足 $L' \\not\\le_{T} L$ 和 $L \\le_{T} L'$。特别地，$H^{H} \\not\\le_{T} H$ 且 $H \\le_{T} H^{H}$。此外，对于任意 $L$，$H^{L}$ 都是不可判定的。\n- 如果一个语言 $C$ 是可判定的，那么对于任何语言 $D$ 都有 $C \\le_{T} D$（可以忽略神谕）。\n- $H$ 和其补集 $\\overline{H}$ 是图灵等价的：$H \\equiv_{T} \\overline{H}$。\n\n选项 A: $A = H$, $B = H^{H}$。\n1. $A$ 是不可判定的：正确。\n2. $B$ 是不可判定的：正确，因为 $H^{H}$ 是 $H$ 的跳跃，因此是不可判定的（如果 $H^{H}$ 是可判定的，那么通过忽略神谕，$H^{H} \\le_{T} H$ 将不证自明地成立，这与 $H^{H} \\not\\le_{T} H$ 相矛盾）。\n3. $A \\le_{P}^{B}$：构造一个带 $H^{H}$ 神谕的多项式时间神谕图灵机来判定 $H$。对于输入 $\\langle M, w \\rangle$，在多项式时间内构造一个 OTM $\\widetilde{M}^{H}$ 的描述，该 OTM 忽略其神谕并模拟 $M$ 在其输入上的行为。用实例 $\\langle \\widetilde{M}^{H}, w \\rangle$ 查询 $H^{H}$-神谕。当且仅当 $M$ 在 $w$ 上停机时，神谕回答“是”。这个过程使用了一次神谕查询和多项式时间的预/后处理，因此 $H \\le_{P}^{H^{H}}$。\n4. $B \\not\\le_{T} A$：根据跳跃定理，$H^{H} \\not\\le_{T} H$。\n\n因此，A 满足所有四个条件。\n\n为完整起见，其他选项至少不满足一个条件：\n- B: $A = H^{H}$, $B = H$。这个选项不满足条件 3，因为 $H^{H} \\not\\le_{T} H$。\n- C: $A = H$, $B = \\overline{H}$。两者都是不可判定的，且 $H \\le_{P}^{\\overline{H}}$，但同时 $\\overline{H} \\le_{T} H$，因此不满足条件 4。\n- D: $A = \\{1^{n} \\mid n \\text{ 是素数}\\}$ 是可判定的（实际上是多项式时间内可判定的），因此不满足条件 1。\n- E: $A = H$, $B = H$ 使得条件 4 为假，因为 $B \\le_{T} A$ 是平凡成立的。\n\n因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1433334"}]}