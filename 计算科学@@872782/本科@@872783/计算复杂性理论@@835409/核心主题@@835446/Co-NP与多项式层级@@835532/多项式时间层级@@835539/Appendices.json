{"hands_on_practices": [{"introduction": "要理解像多项式时间层级这样的抽象概念，最好的方法是从具体问题入手。这个练习将层级的最底层 $P = \\Sigma_0^p$ 与一个非常直观的计算任务——电路验证——联系起来。通过将 `CHIP-VERIFY` 问题 [@problem_id:1461573] 分类，我们为理解更复杂的层级奠定了坚实的基础，并展示了如何将一个实际问题定位在计算复杂度的版图上。", "problem": "在集成电路设计领域，一项基本任务是验证所设计的逻辑电路在给定输入集下的行为是否符合预期。我们可以将此任务建模为一个名为 `CHIP-VERIFY` 的计算问题。\n\n布尔电路由一组门构成。每个门是与门（AND）、或门（OR）或非门（NOT）类型。该电路有一组主输入节点和一个指定的输出门。门与输入之间的连接是指定的，形成一个有向无环图。\n\n`CHIP-VERIFY` 问题定义如下：给定一个布尔电路的完整描述，以及对其每个主输入节点的布尔值（0 或 1）的具体赋值，确定该电路的指定输出门是否输出为 1。\n\n在计算复杂性理论中，多项式时间层级（PH）是一个复杂性类的层级结构，它推广了 P、NP 和 co-NP 等类。对于任意整数 $k \\ge 0$，定义了类 $\\Sigma_k^p$ 和 $\\Pi_k^p$。一个语言 $L$ 属于 $\\Sigma_k^p$ 当且仅当存在一个多项式时间图灵机 $V$ 和一个多项式 $q$，使得对于任意输入 $x$，我们有：\n$$x \\in L \\iff \\exists y_1 \\forall y_2 \\dots Q_k y_k, \\ V(x, y_1, y_2, \\dots, y_k) = 1$$\n其中每个 $y_i$ 是长度至多为 $q(|x|)$ 的字符串，且量词 $Q_k$ 在 $k$ 为奇数时是 $\\exists$，在 $k$ 为偶数时是 $\\forall$。如果一个语言的补集在 $\\Sigma_k^p$ 中，则该语言在 $\\Pi_k^p$ 中。该层级的基底定义为 $\\Sigma_0^p = \\Pi_0^p = P$，即多项式时间内可解问题的类。\n\n基于这些定义，多项式时间层级中，保证包含 `CHIP-VERIFY` 问题的最低复杂性类是什么？\n\nA. $\\Sigma_0^p$\n\nB. $\\Sigma_1^p$\n\nC. $\\Pi_1^p$\n\nD. $\\Sigma_2^p$\n\nE. 该问题不在多项式时间层级中。", "solution": "给定一个由与门、或门和非门组成的布尔电路，以及对所有主输入的指定赋值，我们需要确定指定的输出门是否输出为 1。这正是电路求值问题（Circuit Value Problem, CVP）的判定版本。\n\n要确定输出值，我们可以按照电路有向无环图的拓扑顺序计算门的值：\n1. 将每个主输入的值初始化为给定的赋值。\n2. 按照拓扑顺序，对每个门根据其类型（AND、OR、NOT）及其前驱节点的值计算其布尔值。\n3. 输出在指定输出门处计算出的值，当且仅当该值为 1 时接受。\n\n由于电路图是无环的，因此存在拓扑排序。每个门被处理一次，每条边被检查常数次，因此运行时间与电路描述的大小成线性关系，即与输入长度成多项式关系。因此，CHIP-VERIFY 可在多项式时间内求解，即 CHIP-VERIFY 属于 $P$。\n\n根据多项式时间层级的定义，其基底是 $P = \\Sigma_{0}^{p} = \\Pi_{0}^{p}$。由于 CHIP-VERIFY 属于 $P$，层级中保证包含它的最低类别是 $\\Sigma_{0}^{p}$。\n\n因此，在这些选项中，正确的是 A。", "answer": "$$\\boxed{A}$$", "id": "1461573"}, {"introduction": "多项式时间层级是通过“神谕机”（oracle machine）逐级构建的，即允许一个计算模型调用一个“黑箱”来瞬间解决另一个问题。这个练习 [@problem_id:1461565] 探讨了层级的第二个层次 $\\Sigma_2^p$ 的结构，它要求我们思考当一个非确定性图灵机（即解决 NP 问题的主体）获得了解决布尔可满足性问题 (SAT) 的超能力时，它能解决什么样的问题。这有助于我们深入理解神谕机在定义复杂度类中的核心作用，以及各层级之间是如何相互关联的。", "problem": "在计算复杂性理论中，我们分析解决计算问题所需的资源。非确定性多项式时间图灵机（NPTM）是一种理论计算模型，可以同时探索多个计算路径。预言图灵机是一种抽象机器，用于借助一个称为预言机（oracle）的子程序来研究判定问题，该预言机可以在单一步骤内解决一个特定的问题。\n\n布尔可满足性问题（SAT）是判断是否存在一个释义可以满足给定布尔公式的问题。\n\n多项式时间层级（PH）是一个复杂性类的层级结构，它推广了 P、NP 和 co-NP 等类。该层级的各级，对于整数 $k \\ge 0$ 表示为 $\\Sigma_k^p$ 和 $\\Pi_k^p$，定义如下：\n- $\\Sigma_0^p = \\Pi_0^p = P$\n- 对于 $k \\ge 0$：\n  - $\\Sigma_{k+1}^p = \\text{NP}^{\\Sigma_k^p}$，它表示可以由一台在多项式时间内运行、并带有一个对任何 $\\Sigma_k^p$-完备问题的预言机的 NPTM 所判定的语言集合。\n  - $\\Pi_{k+1}^p = \\text{co-}\\Sigma_{k+1}^p$\n\n考虑这样一个复杂性类，它包含所有可以由一台能够访问 SAT 问题预言机的非确定性多项式时间图灵机判定的语言。在多项式时间层级中，下列哪个类与这个类等价？\n\nA. $\\Sigma_1^p$\n\nB. $\\Pi_1^p$\n\nC. $\\Delta_2^p$\n\nD. $\\Sigma_2^p$\n\nE. $\\Pi_2^p$", "solution": "令 $C$ 表示所有可由一台能访问 SAT 预言机的非确定性多项式时间图灵机判定的语言的类。根据定义，$C=\\text{NP}^{\\text{SAT}}$。\n\n回想一下，在多项式时间多一归约下，SAT 是 $\\Sigma_1^p$-完备的（NP-完备的）。多项式时间层级的定义使得\n$$\n\\Sigma_2^p=\\text{NP}^{\\Sigma_1^p},\n$$\n也就是说，这是可以由一台在多项式时间内运行、并带有一个对任何 $\\Sigma_1^p$-完备问题的预言机的 NPTM 所判定的语言的类。\n\n首先，我们证明 $C \\subseteq \\Sigma_2^p$。由于 $\\text{SAT} \\in \\Sigma_1^p$，任何带有 SAT 预言机的 $\\text{NP}$ 机也是一台带有来自 $\\Sigma_1^p$ 的预言机的 $\\text{NP}$ 机，因此\n$$\n\\text{NP}^{\\text{SAT}} \\subseteq \\text{NP}^{\\Sigma_1^p}=\\Sigma_2^p.\n$$\n\n接下来，我们证明 $\\Sigma_2^p \\subseteq C$。设 $L \\in \\Sigma_2^p$。那么对于某个预言机 $O \\in \\Sigma_1^p$，有 $L \\in \\text{NP}^{O}$。因为 SAT 是 $\\Sigma_1^p$-完备的，所以存在一个多项式时间可计算的归约 $r$，使得对于所有的 $y$，$y \\in O$ 当且仅当 $r(y) \\in \\text{SAT}$。一台用预言机 $O$ 判定 $L$ 的 NPTM，可以通过将每次对 $O$ 的查询 $y$ 替换为对 SAT 的查询 $r(y)$，从而被一台用 SAT 作预言机的 NPTM 模拟。这个过程保持了多项式时间，所以\n$$\n\\text{NP}^{\\Sigma_1^p} \\subseteq \\text{NP}^{\\text{SAT}}.\n$$\n\n结合两个包含关系可得\n$$\n\\text{NP}^{\\text{SAT}}=\\Sigma_2^p.\n$$\n\n因此，问题中描述的类等于 $\\Sigma_2^p$，这对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1461565"}, {"introduction": "在计算理论中，判定问题（“是否存在一个解？”）和搜索问题（“请找出一个解。”）之间存在着深刻的联系。这个练习 [@problem_id:1461585] 介绍了一种名为“自可约性”（self-reducibility）的强大算法技巧。它向我们展示了，如何利用一个只能回答“是”或“否”的 $\\Sigma_k^p$ 神谕机，通过一系列巧妙的提问，一步步地构造出一个实际的解，即“见证”（witness）。这个过程不仅揭示了多项式时间层级中问题的内在结构，还为我们提供了将判定能力转化为构造能力的实用蓝图。", "problem": "在计算复杂性理论中，多项式时间层级 (Polynomial-Time Hierarchy, PH) 是一个复杂性类的层级结构，它推广了 P、NP 和 co-NP 等类。该层级中的类对于 $k \\ge 0$ 表示为 $\\Sigma_k^p$、$\\Pi_k^p$ 和 $\\Delta_k^p$。\n\n定义这些类的一种标准方法是通过量化布尔公式 (Quantified Boolean Formulas, QBF)。一个 QBF 的形式为 $Q_1 \\vec{x}_1 Q_2 \\vec{x}_2 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\dots, \\vec{x}_k)$，其中每个 $Q_i$ 是一个量词（$\\forall$ 或 $\\exists$），每个 $\\vec{x}_i$ 是一组布尔变量，而 $\\phi$ 是一个无量词的布尔公式。\n\n$\\Sigma_k^p$ 类对应于这样一类问题集合：这些问题可以通过判断具有 $k$ 个交替量词且以存在量词开头的 QBF 的真假来判定。形式上，令 $L_k$ 为所有具有以下形式的真 QBF 的语言：\n$$ \\exists \\vec{x}_1 \\forall \\vec{x}_2 \\exists \\vec{x}_3 \\dots Q_k \\vec{x}_k \\phi(\\vec{x}_1, \\vec{x}_2, \\dots, \\vec{x}_k) $$\n其中 $\\phi$ 是一个无量词的公式。判定 $L_k$ 成员资格的问题是 $\\Sigma_k^p$ 类完备的。\n\n假设对于某个固定的整数 $k \\ge 1$，您获得了一个用于语言 $L_k$ 的计算预言机。这个预言机可以在单一步骤内告诉您任何具有 $\\Sigma_k^p$ 量词结构的给定公式是真还是假。\n\n给定一个特定的公式 $\\Phi$，它被保证是语言 $L_k$ 中的一个真公式。该公式形式如下：\n$$ \\Phi = \\exists \\vec{x} \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(\\vec{x}, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\n这里，$\\vec{x} = (x_1, x_2, \\dots, x_n)$ 是最外层的 $n$ 个存在量化变量块。由于 $\\Phi$ 为真，因此至少存在一个对 $\\vec{x}$ 的满足赋值，称为“见证”，它使公式的其余部分为真。\n\n您的任务是设计一个算法，使用 $L_k$ 预言机来找到 $\\vec{x}$ 的一个这样的见证。确定您的算法在最坏情况下必须对 $L_k$ 预言机进行的精确调用次数。将您的答案表示为 $n$ 的函数。", "solution": "问题要求设计一个算法，使用一个能判定任何 $\\Sigma_k^p$ 公式真假的预言机，来为一个真的 $\\Sigma_k^p$ 公式的最外层存在量化变量找到一个满足赋值的见证。我们需要找出该算法所需的预言机调用次数。\n\n我们将使用的核心原则是自归约性。我们可以一次一个分量地构造 $\\vec{x}$ 的见证赋值 $\\vec{w} = (w_1, w_2, \\dots, w_n)$，从 $w_1$ 到 $w_n$。\n\n设给定的真公式为 $\\Phi = \\exists x_1, \\dots, x_n \\, \\Psi(x_1, \\dots, x_n)$，其中 $\\Psi$ 代表从第一个全称量词开始的公式的其余部分，即 $\\Psi(\\vec{x}) = \\forall \\vec{y}_1 \\dots \\psi(\\vec{x}, \\dots)$。\n\n**步骤 1：确定 $w_1$ 的值。**\n\n我们知道存在一个见证。这意味着要么存在一个以 $w_1=1$ 开始的见证，要么存在一个以 $w_1=0$ 开始的见证（或两者都存在）。为了确定 $w_1$ 可以取哪个值，我们可以测试其中一种可能性，比如 $w_1=1$。\n\n我们通过在原始公式 $\\Phi$ 中将 $x_1$ 固定为 1 来构造一个新公式 $\\Phi_1$：\n$$ \\Phi_1 = \\exists x_2, \\dots, x_n \\: \\forall \\vec{y}_1 \\: \\exists \\vec{y}_2 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(1, x_2, \\dots, x_n, \\vec{y}_1, \\dots, \\vec{y}_{k-1}) $$\n这个新公式 $\\Phi_1$ 询问的是，在第一个分量为 1 的情况下，是否存在一种方法来补全这个见证。观察到 $\\Phi_1$ 的量词结构仍然是一个以存在量词（$\\exists x_2, \\dots x_n$）开头的 $k$ 个交替量词的序列。因此，$\\Phi_1$ 是一个 $\\Sigma_k^p$ 公式，我们可以使用我们的 $L_k$ 预言机来判定它的真值。\n\n我们用公式 $\\Phi_1$ 对预言机进行一次调用。\n- **情况 1：预言机返回真。** 如果 $\\Phi_1$ 为真，这意味着存在一个以 1 开头的 $\\vec{x}$ 的见证。因此，我们可以明确地将 $w_1$ 设置为 1。我们的问题现在归约为在（经预言机确认的）真公式 $\\Phi_1$ 中为剩余变量 $(x_2, \\dots, x_n)$ 寻找一个见证。\n- **情况 2：预言机返回假。** 如果 $\\Phi_1$ 为假，这意味着不存在以 1 开头的 $\\vec{x}$ 的见证。然而，我们已知原始公式 $\\Phi$ 为真，这保证了至少存在一个见证。如果没有以 1 开始的见证，那么必定存在一个以 0 开始的见证。因此，我们可以明确地将 $w_1$ 设置为 0。我们不需要进行第二次预言机调用来确认这一点。问题现在归约为在将 $x_1$ 设置为 0 的公式中为 $(x_2, \\dots, x_n)$ 寻找一个见证。\n\n无论哪种情况，我们都通过恰好一次预言机调用来确定 $w_1$ 的正确值。\n\n**步骤 2：推广到 $w_i$。**\n\n我们可以推广这个过程。假设我们已经确定了见证的前 $i-1$ 个分量 $(w_1, w_2, \\dots, w_{i-1})$。我们现在需要找到 $w_i$。\n\n我们通过将前 $i-1$ 个变量固定为它们已确定的值，并将第 $i$ 个变量设置为 1，来构造一个公式 $\\Phi_i$：\n$$ \\Phi_i = \\exists x_{i+1}, \\dots, x_n \\: \\forall \\vec{y}_1 \\dots Q_k \\vec{y}_{k-1} \\: \\psi(w_1, \\dots, w_{i-1}, 1, x_{i+1}, \\dots, x_n, \\vec{y}_1, \\dots) $$\n同样，$\\Phi_i$ 是一个 $\\Sigma_k^p$ 公式，所以我们可以使用预言机。\n- 我们用 $\\Phi_i$ 查询预言机。\n- 如果预言机返回真，我们设置 $w_i=1$。\n- 如果预言机返回假，我们知道对于前缀 $(w_1, \\dots, w_{i-1})$ 必定存在一个有效的补全（根据前面步骤的构造）。如果这个补全不能以 1 继续，那么它必定能以 0 继续。所以，我们设置 $w_i=0$。\n\n对从 $i=1$到$n$的每个变量 $x_i$ 重复此过程。对于每个变量，我们构造一个新的 $\\Sigma_k^p$ 公式，并对 $L_k$ 预言机进行恰好一次调用，以确定其在见证中的正确赋值。\n\n**步骤 3：计算预言机调用的总次数。**\n\n算法迭代 $n$ 次，对 $\\vec{x}$ 中的每个变量迭代一次。在每次迭代中，它都恰好对 $L_k$ 预言机进行一次调用。因此，找到完整见证 $\\vec{w}$ 所需的预言机调用总次数恰好是 $n$。这在最坏情况下也成立，因为无论预言机的回答如何，该逻辑都要求每个变量调用一次。每个新公式 $\\Phi_i$ 的构造时间是关于原始公式 $\\Phi$ 大小的多项式时间，因此整个算法相对于预言机是在多项式时间内运行的。\n\n预言机调用的总次数等于最外层存在量化块中的变量数量，即 $n$。", "answer": "$$\\boxed{n}$$", "id": "1461585"}]}