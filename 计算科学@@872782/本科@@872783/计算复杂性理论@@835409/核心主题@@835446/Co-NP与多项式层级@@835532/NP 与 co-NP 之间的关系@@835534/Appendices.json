{"hands_on_practices": [{"introduction": "我们从一个基本但极具启发性的思想实验开始，它揭示了定义NP与co-NP关系的核心问题对：布尔可满足性问题（SAT）和重言式问题（TAUTOLOGY）。这个练习将要求你使用一个假设性的“预言机”，来展示这两个问题之间深刻的互补关系。理解这种对偶性是掌握NP和co-NP之间非对称性的第一步，即验证一个“是”的答案与验证一个“否”的答案之间的区别。[@problem_id:1444878]", "problem": "在计算复杂性理论领域，一种被称为预言机的假想机器可以在单个计算步骤内解决一个特定的判定问题。假设你有一个用于布尔可满足性问题 (SAT) 的预言机。这个预言机接收任何布尔公式作为输入，并立即返回两种输出之一：“SATISFIABLE”（如果存在至少一种对变量的真值赋值使公式为真）或“UNSATISFIABLE”（否则）。\n\n你的任务是使用这个 SAT 预言机来解决重言式 (TAUTOLOGY) 问题的一个实例。如果一个布尔公式对于其变量的*所有*可能的真值赋值都为真，那么它就是一个重言式。\n\n给定一个定义在变量集合 $\\{x_1, x_2, \\ldots, x_n\\}$ 上的任意布尔公式 $\\psi$，以下哪个过程能正确判断 $\\psi$ 是否为重言式？\n\nA. 构建公式 $\\phi = \\psi$。将 $\\phi$ 输入 SAT 预言机。当且仅当预言机报告“SATISFIABLE”时，断定 $\\psi$ 是一个重言式。\nB. 构建公式 $\\phi = \\psi$。将 $\\phi$ 输入 SAT 预言机。当且仅当预言机报告“UNSATISFIABLE”时，断定 $\\psi$ 是一个重言式。\nC. 构建公式 $\\phi = \\neg\\psi$。将 $\\phi$ 输入 SAT 预言机。当且仅当预言机报告“SATISFIABLE”时，断定 $\\psi$ 是一个重言式。\nD. 构建公式 $\\phi = \\neg\\psi$。将 $\\phi$ 输入 SAT 预言机。当且仅当预言机报告“UNSATISFIABLE”时，断定 $\\psi$ 是一个重言式。\nE. 无法使用 SAT 预言机解决重言式问题，因为重言式问题是 co-NP 完全问题，而 SAT 是 NP 完全问题。", "solution": "目标是使用一个用于布尔可满足性问题 (SAT) 的预言机来判断给定的布尔公式 $\\psi$ 是否为重言式。\n\n根据定义，如果一个公式 $\\psi$ 对其变量的*所有*可能的真值赋值都为真，那么它就是一个重言式。\n\n让我们考虑这个陈述的否定。如果存在*至少一个*真值赋值使得 $\\psi$ 为假，那么公式 $\\psi$ 就*不是*一个重言式。\n\n如果存在一个真值赋值使 $\\psi$ 为假，那么根据逻辑非的定义，同样的真值赋值必然会使公式 $\\neg\\psi$ 为真。\n\n反之，如果存在一个真值赋值使 $\\neg\\psi$ 为真，那么同样的赋值必然会使 $\\psi$ 为假。这意味着 $\\psi$ 并非对所有赋值都为真，因此它不是一个重言式。\n\n因此，我们建立了一个关键的逻辑等价关系：\n公式 $\\psi$ *不是*重言式 $\\iff$ 存在至少一个赋值使 $\\neg\\psi$ 为真。\n\n“存在至少一个赋值使 $\\neg\\psi$ 为真”这个陈述，正是公式 $\\neg\\psi$ 是可满足的定义。SAT 预言机就是用来回答这个问题的。如果我们将公式 $\\neg\\psi$ 提供给 SAT 预言机，当这样的赋值存在时，它将返回“SATISFIABLE”。\n\n因此，我们可以更新我们的等价关系：\n公式 $\\psi$ *不是*重言式 $\\iff$ 公式 $\\neg\\psi$ 是可满足的。\n\n然而，问题要求的是 $\\psi$ *是*重言式的条件。我们可以通过对上述等价关系的两边取非来得到这个条件。“$\\psi$ 不是重言式”的否定是“$\\psi$ 是重言式”。“$\\neg\\psi$ 是可满足的”的否定是“$\\neg\\psi$ 不是可满足的”（即“$\\neg\\psi$ 是不可满足的”）。\n\n这就给了我们最终的、决定性的等价关系：\n公式 $\\psi$ *是*重言式 $\\iff$ 公式 $\\neg\\psi$ 是不可满足的。\n\n因此，正确的流程是：\n1.  取输入公式 $\\psi$。\n2.  构建一个新公式 $\\phi$，它是输入公式的否定，即 $\\phi = \\neg\\psi$。\n3.  将这个新公式 $\\phi$ 输入 SAT 预言机。\n4.  如果预言机返回“UNSATISFIABLE”，我们可以断定 $\\psi$ 是一个重言式。如果它返回“SATISFIABLE”，我们断定 $\\psi$ 不是一个重言式。\n\n这个流程与选项 D 相匹配。\n\n让我们分析一下其他选项为什么不正确：\n- 选项 A：测试 $\\psi$ 是否可满足只能告诉我们 $\\psi$ 不是一个矛盾式。一个公式可以是可满足的但不是重言式（例如，$\\psi = x_1$）。\n- 选项 B：测试 $\\psi$ 是否不可满足是在测试 $\\psi$ 是否为一个矛盾式（即对所有赋值都为假），这与重言式正好相反。\n- 选项 C：这个选项颠倒了结论。如果 $\\neg\\psi$ 是可满足的，这意味着 $\\psi$ *不是*一个重言式。\n- 选项 E：这是一个常见的误解。存在一个像 SAT 这样的 NP 完全问题的预言机，使得复杂度类 NP 中的所有问题以及 co-NP 类中的所有问题都能被有效解决。由于重言式问题 (TAUTOLOGY) 是典型的 co-NP 完全问题，它确实可以使用 SAT 预言机来解决。所描述的过程是在给定一个预言机的情况下，将一个 co-NP 问题多项式时间归约到一个 NP 问题的一个例子。", "answer": "$$\\boxed{D}$$", "id": "1444878"}, {"introduction": "在上一节练习的基础上，我们现在来考虑一个重大的假想性发现。如果像TAUTOLOGY这样一个典型的co-NP完全问题被发现具有高效的“是”实例证明（即，被证明属于NP），会对整个计算复杂性理论的版图产生怎样的结构性影响？这个问题将揭示一个关键问题的地位如何能够导致整个复杂性类的崩塌。[@problem_id:1444859]", "problem": "在计算复杂性理论中，决策问题根据解决它们所需的资源被划分为不同的类别。两个基本的类别是 NP 和 co-NP。\n\n- **NP (非确定性多项式时间)** 类包含所有这样的决策问题：其“是”实例可以在多项式时间内由确定性图灵机验证，只要给定一个合适的证书或证明。\n- **co-NP** 类包含所有其补问题在 NP 中的决策问题。等价地，如果一个问题的“否”实例有一个可以在多项式时间内验证的证书，那么该问题就属于 co-NP。\n\n考虑 **TAUTOLOGY** (重言式) 问题：给定一个布尔逻辑公式，该公式是否对于其变量的所有可能真值赋值都为真？例如，公式 `A or (not A)` 是一个重言式。\n\n一个公认的结论是 TAUTOLOGY 属于 co-NP。现在，考虑一个假设情景：一位计算机科学家证明了 TAUTOLOGY 同时也属于 NP。对于这些复杂性类之间的关系，以下哪项将是最直接且最重要的推论？\n\nA. P = NP\nB. NP = co-NP\nC. SAT (布尔可满足性问题) 将被证明属于 P。\nD. 复杂性类 PSPACE 将会坍缩到 NP。\nE. P ≠ NP", "solution": "我们回顾一下标准的定义和归约。类 **co-NP** 是 **NP** 中语言的补集构成的集合，且补运算满足 $A \\in \\text{NP} \\iff \\bar{A} \\in \\text{co-NP}$ 以及 $A \\in \\text{co-NP} \\iff \\bar{A} \\in \\text{NP}$。语言 `TAUTOLOGY` (重言布尔公式的集合) 是一个在多项式时间多一归约下的著名 **co-NP-完全**问题。形式上，对于每一个 $L \\in \\text{co-NP}$，存在一个多项式时间可计算的函数 $f$，使得\n$$\nx \\in L \\iff f(x) \\in \\text{TAUTOLOGY}.\n$$\n假设 `TAUTOLOGY` $\\in \\text{NP}$。那么对于任何满足 $L \\leq_{m}^{p} \\text{TAUTOLOGY}$ 的 $L \\in \\text{co-NP}$，由于 **NP** 在多项式时间多一归约下是封闭的，我们得到\n$$\nL \\in \\text{NP}.\n$$\n因此，\n$$\n\\text{co-NP} \\subseteq \\text{NP}.\n$$\n接下来，使用补集。因为 `TAUTOLOGY` $\\in \\text{NP}$，我们有 $\\overline{\\text{TAUTOLOGY}} \\in \\text{co-NP}$。此外，由于 `TAUTOLOGY` 是 **co-NP-完全**的，它的补集 $\\overline{\\text{TAUTOLOGY}}$ 是 **NP-完全**的。确实，对于任何 $L \\in \\text{NP}$，我们有 $\\bar{L} \\in \\text{co-NP}$，因此存在一个多项式时间归约 $f$ 满足\n$$\nx \\in \\bar{L} \\iff f(x) \\in \\text{TAUTOLOGY} \\quad \\Longrightarrow \\quad x \\in L \\iff f(x) \\in \\overline{\\text{TAUTOLOGY}},\n$$\n所以 $L \\leq_{m}^{p} \\overline{\\text{TAUTOLOGY}}$。由于 $\\overline{\\text{TAUTOLOGY}} \\in \\text{co-NP}$ 并且 **co-NP** 在多项式时间多一归约下是封闭的，因此对于任何 $L \\in \\text{NP}$，\n$$\nL \\in \\text{co-NP}.\n$$\n所以，\n$$\n\\text{NP} \\subseteq \\text{co-NP}.\n$$\n结合这两个包含关系，可得\n$$\n\\text{NP} = \\text{co-NP}.\n$$\n这是最直接且最重要的推论。仅凭此假设，并不能推导出任何其他列出的坍缩（例如 P=NP 或 PSPACE 坍缩到 NP）。因此，正确选项是 B。", "answer": "$$\\boxed{B}$$", "id": "1444859"}, {"introduction": "我们的最后一个练习将探讨一个更具冲击力的假想情景。如果我们找到了一个多项式时间算法，能够解决一个同时对NP和co-NP都是难解的问题，那将意味着什么？这项练习将引导你推导计算复杂性理论中一个最重大的可能结果，即P、NP和co-NP这三个核心复杂性类的统一。[@problem_id:1444869]", "problem": "在计算复杂性理论中，我们根据解决决策问题所需的资源对其进行分类。让我们定义几个关键的复杂性类别：\n- **P (多项式时间):** 这类决策问题可以由一个算法在多项式时间内解决，即算法的步数是输入大小的多项式函数。\n- **NP (非确定性多项式时间):** 这类决策问题的“是”答案可以在给定一个合适的“证书”的情况下，在多项式时间内得到验证。\n- **co-NP:** 这类决策问题的补问题属于 NP。等价地说，这类问题的“否”答案可以在多项式时间内得到验证。\n\n如果存在一个多项式时间算法，能将问题 $L_1$ 的任何实例转换为问题 $L_2$ 的一个实例，并且答案（“是”或“否”）保持不变，我们就说问题 $L_1$ 可多项式时间归约到问题 $L_2$。如果 NP 类中的每个问题都可以多项式时间归约到某个问题，那么该问题就是 **NP-hard** 的。类似地，如果 co-NP 类中的每个问题都可以多项式时间归约到某个问题，那么该问题就是 **co-NP-hard** 的。\n\n假设经过多年的研究，一个特定的问题（我们称之为 $X$）被证明既是 NP-hard 的，也是 co-NP-hard 的。然后，出乎意料的是，一位计算机科学家发现了一个可以在多项式时间内解决问题 $X$ 的算法。\n\n假设所有这些发现都是正确的，那么对于复杂性类别 P、NP 和 co-NP 之间的关系，其最终的结论是什么？\n\nA. P = NP，但 NP ≠ co-NP。\nB. NP = co-NP，但 P 仍然是 NP 的真子集。\nC. P = NP = co-NP。\nD. P 是 NP 和 co-NP 交集的真子集，即 P ⊂ (NP ∩ co-NP)。\nE. 所描述的情况是一个逻辑矛盾，意味着关于问题 $X$ 的初始证明中至少有一个是错误的。", "solution": "根据假设，$X$ 在多项式时间多一归约下是 NP-hard 和 co-NP-hard 的，并且存在一个多项式时间算法可以判定 $X$，即 $X \\in P$。\n\nNP-hard 的含义是：对于任意语言 $L \\in \\text{NP}$，都存在一个多项式时间可计算的函数 $f$，使得对于所有输入 $x$，$x \\in L$ 当且仅当 $f(x) \\in X$。设 $A_{X}$ 是 $X$ 的一个多项式时间判定器。那么我们可以通过将 $x$ 映射到 $y = f(x)$ 并运行 $A_{X}(y)$ 来为任何 $L \\in \\text{NP}$ 得到一个多项式时间判定器。总时间是多项式的，因为它是两个多项式时间过程的组合。因此，$L \\in P$。由于这对任意的 $L \\in \\text{NP}$ 都成立，我们有 $NP \\subseteq P$。而 $P \\subseteq NP$ 总是成立的，因此 $P = NP$。\n\n类似地，co-NP-hard 的含义是：对于任意语言 $L \\in \\text{co-NP}$，都存在一个多项式时间可计算的归约 $g$，使得 $x \\in L$ 当且仅当 $g(x) \\in X$。使用与 $X$ 的多项式时间判定器相同的组合论证，我们得出对于所有 $L \\in \\text{co-NP}$ 都有 $L \\in P$，因此 $\\text{co-NP} \\subseteq P$。由于 $P \\subseteq \\text{co-NP}$ 总是成立的，我们得到 $P = \\text{co-NP}$。\n\n将这些等式结合起来，得到 $P = NP = \\text{co-NP}$。在给出的选项中，这正是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1444869"}]}