{"hands_on_practices": [{"introduction": "要确定一个命题公式是否为重言式，最直接的方法是构建其真值表。通过系统地检验所有可能的真值指派，我们可以明确地验证公式是否恒为真。这个练习将带你实践这一基本功，通过构建真值表来分析一个具体公式的逻辑性质 [@problem_id:1464066]，这是理解重言式定义的基石。", "problem": "在一门形式逻辑课程中，学生们的任务是对命题公式进行分类。如果一个公式对于其命题变量的所有可能真值赋值都为真，则该公式被定义为**重言式**。如果一个公式对于所有此类赋值都为假，则该公式为**矛盾式**。既非重言式也非矛盾式的公式称为**偶然式**。\n\n一位名叫 Alex 的学生分析了四个涉及命题变量 $p$ 和 $q$ 的不同公式，并对每个公式提出了一个论断。你的任务是确定 Alex 的哪个论断是正确的。\n\nA. 公式 $((p \\rightarrow q) \\land \\neg q) \\rightarrow \\neg p$ 是一个重言式。\n\nB. 公式 $(p \\lor q) \\land (\\neg p \\land \\neg q)$ 是一个偶然式。\n\nC. 公式 $(p \\rightarrow q) \\rightarrow p$ 是一个重言式。\n\nD. 公式 $(p \\land \\neg p) \\rightarrow q$ 是一个矛盾式。", "solution": "为了确定哪个论断是正确的，我们将通过构建其真值表来分析每个公式。真值“真”和“假”分别用 T 和 F 表示。\n\n**选项 A 分析：**\n公式为 $F_A = ((p \\rightarrow q) \\land \\neg q) \\rightarrow \\neg p$。\n我们一步一步地构建这个公式的真值表。表中的列代表变量和子表达式。\n仅当 $p$ 为 T 且 $q$ 为 F 时，蕴含 $p \\rightarrow q$ 才为假。\n| $p$ | $q$ | $\\neg p$ | $\\neg q$ | $p \\rightarrow q$ | $(p \\rightarrow q) \\land \\neg q$ | $F_A$ |\n|---|---|---|---|---|---|---|\n| T | T | F | F | T | F | T |\n| T | F | F | T | F | F | T |\n| F | T | T | F | T | F | T |\n| F | F | T | T | T | T | T |\n$F_A$ 的最后一列只包含 T 值。这意味着该公式是一个重言式。因此，Alex 在选项 A 中的论断是正确的。\n\n**选项 B 分析：**\n公式为 $F_B = (p \\lor q) \\land (\\neg p \\land \\neg q)$。\n我们构建它的真值表。\n| $p$ | $q$ | $\\neg p$ | $\\neg q$ | $p \\lor q$ | $\\neg p \\land \\neg q$ | $F_B$ |\n|---|---|---|---|---|---|---|\n| T | T | F | F | T | F | F |\n| T | F | F | T | T | F | F |\n| F | T | T | F | T | F | F |\n| F | F | T | T | F | T | F |\n$F_B$ 的最后一列只包含 F 值。这意味着该公式是一个矛盾式。Alex 声称它是一个偶然式。因此，选项 B 中的论断是不正确的。\n\n**选项 C 分析：**\n公式为 $F_C = (p \\rightarrow q) \\rightarrow p$。\n我们构建它的真值表。\n| $p$ | $q$ | $p \\rightarrow q$ | $F_C$ |\n|---|---|---|---|\n| T | T | T | T |\n| T | F | F | T |\n| F | T | T | F |\n| F | F | T | F |\n$F_C$ 的最后一列同时包含 T 和 F 值。这意味着该公式是一个偶然式。Alex 声称它是一个重言式。因此，选项 C 中的论断是不正确的。\n\n**选项 D 分析：**\n公式为 $F_D = (p \\land \\neg p) \\rightarrow q$。\n子表达式 $p \\land \\neg p$ 是一个矛盾式，意味着它永远为假。无论后件 $B$ 的真值如何，只要前件 $A$ 为假，蕴含 $A \\rightarrow B$ 就为真。在这种情况下，前件是 $p \\land \\neg p$，它永远为假。因此，蕴含式 $F_D$ 必须永远为真。\n让我们用真值表来验证这一点。\n| $p$ | $q$ | $\\neg p$ | $p \\land \\neg p$ | $F_D$ |\n|---|---|---|---|---|\n| T | T | F | F | T |\n| T | F | F | F | T |\n| F | T | T | F | T |\n| F | F | T | F | T |\n$F_D$ 的最后一列只包含 T 值，所以该公式是一个重言式。Alex 声称它是一个矛盾式。因此，选项 D 中的论断是不正确的。\n\n根据对所有四个选项的分析，只有选项 A 中的论斷是正确的。", "answer": "$$\\boxed{A}$$", "id": "1464066"}, {"introduction": "虽然真值表方法很可靠，但对于变量较多的复杂公式，它会变得非常繁琐。一种更高效、更优雅的方法是运用逻辑等价定律进行代数化简。这个练习旨在帮助你掌握如何通过符号操作来简化逻辑表达式，从而判断其是否为重言式 [@problem_id:1464065]，这种技巧在逻辑推理和电路设计中都至关重要。", "problem": "在命题逻辑中，一个复合命题根据其在所有原子命题的可能真值指派下的真值来进行分类。如果一个命题总是为真，则为**永真式**；如果总是为假，则为**永假式**；如果既不总是为真也不总是为假，则为**偶然式**。\n\n考虑涉及两个命题 $p$ 和 $q$ 的逻辑表达式：\n$$\n(p \\rightarrow q) \\lor (q \\rightarrow p)\n$$\n其中 $\\rightarrow$ 表示逻辑蕴含（如果...那么...），$\\lor$ 表示逻辑析取（或）。\n\n使用逻辑等价定律，化简此表达式并确定其分类。下列哪个陈述是正确的？\n\nA. 该表达式是永真式。\n\nB. 该表达式是永假式。\n\nC. 该表达式是偶然式。\n\nD. 该表达式逻辑等价于 $p \\land q$。\n\nE. 该表达式逻辑等价于 $p \\leftrightarrow q$。", "solution": "从给定的表达式开始，使用蕴含的等价式。根据蕴含的定义，对于任意命题 $r$ 和 $s$，$r \\rightarrow s \\equiv \\lnot r \\lor s$。将此应用两次可得\n$$\n(p \\rightarrow q) \\lor (q \\rightarrow p) \\equiv (\\lnot p \\lor q) \\lor (\\lnot q \\lor p).\n$$\n使用 $\\lor$ 的结合律和交换律对析取项进行重新排序和分组：\n$$\n(\\lnot p \\lor q) \\lor (\\lnot q \\lor p) \\equiv \\lnot p \\lor p \\lor q \\lor \\lnot q \\equiv (p \\lor \\lnot p) \\lor (q \\lor \\lnot q).\n$$\n应用排中律，该定律指出对于任意命题 $r$，$r \\lor \\lnot r \\equiv \\top$（一个永真式）。因此，\n$$\n(p \\lor \\lnot p) \\lor (q \\lor \\lnot q) \\equiv \\top \\lor \\top \\equiv \\top.\n$$\n由于该表达式可化简为一个永真式，因此它在所有真值指派下都为真。所以，正确的分类是该表达式为永真式，对应于选项A。", "answer": "$$\\boxed{A}$$", "id": "1464065"}, {"introduction": "将逻辑验证过程形式化为算法，是连接理论逻辑与计算复杂性理论的关键一步。这个练习将引导你分析一个用于检验重言式的递归算法 [@problem_id:1464042]。通过计算执行该算法所需的调用次数，你将直观地感受到解决重言式问题所固有的指数级复杂度，这是理解其在 co-NP 完备性中地位的重要实践。", "problem": "一名计算机科学专业的学生正在开发一个递归算法，用于判断一个给定的命题逻辑公式是否为重言式。该算法名为 `CheckTautology`，其操作如下：\n\n该函数定义为 `CheckTautology(F, A)`，其中 `F` 是一个命题公式，`A` 是一个将变量映射到布尔值（`True` 或 `False`）的赋值集合。令 `V(F)` 为公式 `F` 中出现的唯一变量的集合。该函数的行为由一个基本情况和一个递归步骤定义：\n\n- **基本情况**：如果 `A` 中已赋值的变量集合与公式中的变量集合 `V(F)` 相同，则函数使用 `A` 中的赋值来评估公式 `F`，并返回最终的布尔值（`True` 或 `False`）。\n- **递归步骤**：如果 `V(F)` 中存在未赋值的变量，算法会按字母顺序选择第一个尚未在 `A` 中赋值的变量 `p`。然后，它进行两次递归调用：一次将 `p` 赋值为 `True`，另一次将 `p` 赋值为 `False`。当且仅当这两次递归调用都返回 `True` 时，该函数返回 `True`；否则，返回 `False`。\n\n要检查公式 `F` 是否为重言式，需要进行一次初始调用 `CheckTautology(F, A_0)`，其中 `A_0` 是空的赋值集合。\n\n考虑以下命题公式 $\\phi$：\n$$ \\phi = (p \\to (q \\to r)) \\to ((p \\to q) \\to (p \\to r)) $$\n\n为判断 $\\phi$ 是否为重言式，总共需要调用 `CheckTautology` 函数多少次（包括初始调用）？", "solution": "令 $V(\\phi)$ 表示公式中的变量集合。对于 $\\phi=(p \\to (q \\to r)) \\to ((p \\to q) \\to (p \\to r))$，我们有\n$$\nV(\\phi)=\\{p,q,r\\}, \\quad |V(\\phi)|=3.\n$$\n当 $\\phi$ 是一个重言式时，函数 CheckTautology 会在所有赋值下对 $\\phi$ 进行求值，因为在每个非基本情况的调用中，它都会进行两次递归调用（对第一个未赋值的变量分别设为 $\\text{True}$ 和 $\\text{False}$），并且当且仅当两次调用都返回 $\\text{True}$ 时，它才返回 $\\text{True}$。由于 $\\phi$ 确实是一个重言式，没有分支会返回 `False`，因此不会发生提前终止，整个二叉递归树都将被探索。\n\n令 $T(n)$ 为当公式是重言式时，CheckTautology 对一个含有 $n$ 个不同变量的公式所进行的总调用次数（包括初始调用）。那么：\n- 基本情况：当 $n=0$ 时，恰好有一次调用，该调用立即求值并返回，所以\n$$\nT(0)=1.\n$$\n- 递归步骤：对于 $n \\geq 1$，顶层调用对含有 $n-1$ 个剩余未赋值变量的公式进行两次递归调用，并且我们计算当前调用本身，因此\n$$\nT(n)=1+2\\,T(n-1).\n$$\n通过定义 $S(n)=T(n)+1$ 来求解这个递推关系。那么\n$$\nS(n)=T(n)+1=\\bigl(1+2\\,T(n-1)\\bigr)+1=2\\bigl(T(n-1)+1\\bigr)=2\\,S(n-1),\n$$\n其中 $S(0)=T(0)+1=2$。因此\n$$\nS(n)=2^{n+1} \\quad \\Longrightarrow \\quad T(n)=S(n)-1=2^{n+1}-1.\n$$\n对于 $n=3$，\n$$\nT(3)=2^{4}-1=15.\n$$\n等价地，这与一个高度为 $3$ 的满二叉树的总节点数相匹配，该数目由 $\\sum_{k=0}^{3}2^{k}=2^{4}-1$ 给出。\n\n因此，包括初始调用在内的总调用次数为 $15$。", "answer": "$$\\boxed{15}$$", "id": "1464042"}]}