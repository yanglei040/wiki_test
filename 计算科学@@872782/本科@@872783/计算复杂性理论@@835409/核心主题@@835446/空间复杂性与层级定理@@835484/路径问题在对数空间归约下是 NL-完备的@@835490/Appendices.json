{"hands_on_practices": [{"introduction": "在我们构建归约之前，必须先理解其能力的边界。对数空间归约（logspace reduction）虽然强大，但并非没有限制。第一个练习将探讨一个与对数空间计算的输出大小相关的关键约束，阐明为何某些看似简单的转换不能被视为有效的归约。[@problem_id:1435076]", "problem": "一位系统工程师正在为一项物理实验设计一个微控制器。该控制器的主要任务是接收一个表示正整数 $N$ 的 $n$ 位二进制字符串 $B$，然后生成一串恰好 $N$ 个电压脉冲。该微控制器有一个用于 $B$ 的只读输入寄存器和一个用于脉冲的只写输出引脚。关键是，其内部的读/写工作内存极其有限，最多只能存储 $c \\log_2 n$ 比特，其中 $c$ 是一个小常数。用复杂性理论的语言来说，它运行的任何算法都必须是对数空间计算。\n\n该工程师设计了一种基于输入数 $N$ 的二进制展开的算法，$N = \\sum_{i=0}^{n-1} b_i 2^i$，其中 $b_i$ 是 $B$ 的第 $i$ 位。该算法用一个指针从 $i=n-1$ 向下迭代到 $0$。如果发现比特 $b_i$ 是'1'，它就执行一个子程序 `GeneratePowerOfTwoPulses(i)`，该子程序旨在产生恰好 $2^i$ 个脉冲。`GeneratePowerOfTwoPulses(i)` 的实现方式是通过模拟 $i$ 个嵌套循环，每个循环迭代两次。最内层循环的循环体触发一个脉冲。\n\n设计完之后，这位工程师就该算法的可行性及其与对数空间归约概念的关系提出了几项主张。对数空间归约是证明问题对于某个复杂性类是完全问题的一个基本工具。\n\n考虑以下陈述：\n\n(I) 工程师提出的将二进制输入 $N$ 转换为 $N$ 个脉冲的一元流的算法可以在指定的微控制器上实现，因为整个过程在对数空间内是可计算的，即 $O(\\log n)$。\n\n(II) 工程师提出的算法需要 $\\Theta(n)$ 的工作空间。因此，它不是一个对数空间计算，不能在指定的微控制器上实现。\n\n(III) 一个将数字从其二进制表示转换为一元表示的函数不被视为标准的对数空间归约，主要是因为该函数本身在对数空间内是不可计算的。\n\n(IV) 一个将数字从其二进制表示转换为一元表示的函数不被视为标准的对数空间归约，主要是因为通常情况下，该函数的输出长度不受其输入长度的多项式界限约束。\n\n以上陈述中哪些是正确的？\n\nA. I 和 III\nB. I 和 IV\nC. II 和 III\nD. II 和 IV\nE. 仅 II", "solution": "我们使用对数空间转换器（只读输入、只写输出和 $O(\\log n)$ 工作空间）的空间复杂度原则来分析每个陈述。\n\n首先，考虑子程序 $\\text{GeneratePowerOfTwoPulses}(i)$。根据设计，它模拟了 $i$ 个嵌套循环，每个循环迭代两次，最内层的循环输出一个脉冲。要确定性地模拟 $i$ 个嵌套的二元循环，机器必须维护每个循环的状态（第一次或第二次迭代）。这需要存储 $i$ 个一位的循环计数器。因此，该子程序需要 $\\Theta(i)$ 比特的工作内存。在最坏的情况下，当 $i=n-1$ 时，它需要 $\\Theta(n)$ 比特。外部算法还维护一个指向输入位的指针 $i$，这需要 $O(\\log n)$ 比特，但主要成本是子程序的 $\\Theta(n)$ 比特。因此，所提出的算法使用 $\\Theta(n)$ 的工作空间，并且不是一个对数空间计算。\n\n因此：\n- 陈述 (I) 是错误的，因为所指定的算法无法在 $O(\\log n)$ 空间内运行。\n- 陈述 (II) 是正确的，因为在最坏情况下，嵌套循环生成器需要 $\\Theta(n)$ 比特。\n\n接下来，考虑对数空间归约。一个具有 $O(\\log n)$ 工作空间的确定性对数空间转换器，其格局（configuration）数量最多是输入长度 $n$ 的多项式级别，因为格局的数量为\n$$\n|Q| \\cdot n^{O(1)} \\cdot 2^{O(\\log n)} = n^{O(1)}.\n$$\n如果机器停机，它不能重复访问一个格局；因此，步数受 $n$ 的多项式界限约束。因为它每步最多输出一个符号，所以输出长度也受 $n$ 的多项式界限约束。将一个 $n$ 位二进制表示映射到长度为 $N$ 的一元字符串的函数，其输出长度可能为 $N$，其中 $N$ 可以大到 $2^{n}-1$，这个长度不受 $n$ 的多项式界限约束。因此，由于其超多项式长度的输出，这样的函数不能成为一个标准的对数空间归约。\n\n因此：\n- 陈述 (III) 作为解释其为何不是标准对数空间归约的理由是错误的；主要问题是输出长度缺少多项式界限。\n- 陈述 (IV) 是正确的，因为输出不受输入长度的多项式界限约束。\n\n综合以上分析，正确的陈述是 II 和 IV。", "answer": "$$\\boxed{D}$$", "id": "1435076"}, {"introduction": "在构造归约时，最强大的技术之一是将额外的题目约束直接编码到新图的顶点和边结构中。本练习将通过一个实例让你亲手实践这种“状态编码”方法，我们将一个带有交替颜色约束的路径问题转化为一个标准的 `PATH` 问题。[@problem_id:1435018]", "problem": "在计算复杂性理论中，`PATH` 问题是复杂性类 NL 的一个基石。`PATH` 问题形式化定义如下：给定一个有向图 $G=(V, E)$、一个起始顶点 $s \\in V$ 和一个目标顶点 $t \\in V$，判断是否存在一条从 $s$ 到 $t$ 的路径。\n\n考虑一个相关问题，我们称之为 `ALTERNATING-BIPARTITE-PATH`。该问题的一个实例由一个元组 $(G, s, t, A, B)$ 给出，其中 $G=(V,E)$ 是一个有向图，$s,t \\in V$ 是起始和目标顶点，而 $A,B \\subseteq V$ 是两个不相交的顶点集合。一个“是”实例是指在图 $G$ 中存在一条路径 $P = (v_0, v_1, \\ldots, v_k)$，它满足以下所有条件：\n1. 路径以 $s$ 为起点，以 $t$ 为终点，即 $v_0 = s$ 且 $v_k = t$。\n2. 路径上的所有顶点，包括端点，都必须属于集合 $A$ 和 $B$ 的并集。也就是说，$\\{v_0, v_1, \\ldots, v_k\\} \\subseteq A \\cup B$。\n3. 路径必须在集合 $A$ 和集合 $B$ 的顶点之间严格交替。形式上，对于每一步 $i \\in \\{0, \\ldots, k-1\\}$，如果 $v_i \\in A$ 则 $v_{i+1} \\in B$，如果 $v_i \\in B$ 则 $v_{i+1} \\in A$。\n\n`ALTERNATING-BIPARTITE-PATH` 问题可以通过一个到 `PATH` 问题的对数空间归约来解决。标准的归约方法涉及构建一个新图 $G'=(V', E')$，其中 $V'$ 中的顶点不仅编码了其在原图 $G$ 中的位置，还编码了该位置是属于集合 $A$ 还是集合 $B$。\n\n现给定 `ALTERNATING-BIPARTITE-PATH` 的以下具体实例：\n- 顶点集为 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6\\}$。\n- 不相交集合为 $A = \\{v_1, v_2, v_5\\}$ 和 $B = \\{v_3, v_4\\}$。\n- 起始顶点为 $s = v_1$，目标顶点为 $t = v_2$。\n- 边集为 $E = \\{(v_1, v_3), (v_1, v_6), (v_2, v_4), (v_3, v_2), (v_3, v_5), (v_4, v_1), (v_4, v_5), (v_5, v_3), (v_6, v_2)\\}$。\n\n通过应用上述标准的对数空间归约，创建了一个关于新图 $G'=(V', E')$ 的 `PATH` 实例。计算这个新图 $G'$ 中的顶点数 $(|V'|)$ 和边数 $(|E'|)$。请以数对 $(|V'|, |E'|)$ 的形式给出答案。", "solution": "题目要求我们确定新图 $G'=(V', E')$ 的大小，该图是将一个给定的 `ALTERNATING-BIPARTITE-PATH` 实例通过对数空间归约到标准 `PATH` 问题所得到的结果。\n\n首先，我们来理解这个归约过程。与 `PATH` 问题相比，`ALTERNATING-BIPARTITE-PATH` 问题有一个额外的约束：路径必须在两个顶点集 $A$ 和 $B$ 之间交替。为了处理这个约束，我们可以构建一个新图 $G'$，其顶点编码了位于图 $G$ 中某个特定顶点并属于某个特定划分（$A$ 或 $B$）的状态。\n\n设 `ALTERNATING-BIPARTITE-PATH` 的一个实例为 $(G=(V, E), s, t, A, B)$。该归约构建了一个 `PATH` 的实例，即 $(G'=(V', E'), s', t')$。\n\n**新图 $G'$ 的构造**\n\n1.  **顶点集 $V'$**：图 $G$ 中的路径被限制在 $A \\cup B$ 的顶点内。因此，我们只需要考虑这些顶点。对于每个顶点 $v \\in A \\cup B$，我们在 $G'$ 中创建一个“带状态的”顶点。我们可以将 $V'$ 中的一个顶点表示为数对 $(v, S)$，其中 $v \\in A \\cup B$，$S$ 表示顶点 $v$ 属于哪个集合（$A$ 或 $B$）。\n    这意味着顶点集 $V'$ 是两组节点的并集：一组是 $A$ 中顶点的副本，另一组是 $B$ 中顶点的副本。\n    $V' = \\{(v, \\text{'A'}) \\mid v \\in A\\} \\cup \\{(v, \\text{'B'}) \\mid v \\in B\\}$。\n    因此，$V'$ 中的顶点总数为 $|V'| = |A| + |B|$。\n\n2.  **边集 $E'$**：如果一条边代表了 $G$ 中一条交替路径中的一个有效步骤，那么这条边就存在于 $G'$ 中。从顶点 $u$ 到顶点 $v$ 的一个有效步骤要求 $(u,v)$ 是 $E$ 中的一条边，并且 $u$ 和 $v$ 属于不同的划分（$A$ 和 $B$）。\n    - 如果存在一条边 $(u, v) \\in E$，其中 $u \\in A$ 且 $v \\in B$，我们就在 $E'$ 中添加一条从 $(u, \\text{'A'})$ 到 $(v, \\text{'B'})$ 的有向边。\n    - 如果存在一条边 $(u, v) \\in E$，其中 $u \\in B$ 且 $v \\in A$，我们就在 $E'$ 中添加一条从 $(u, \\text{'B'})$ 到 $(v, \\text{'A'})$ 的有向边。\n    不会创建其他边。这种构造确保了 $G'$ 中的任何路径都对应于 $G$ 中的一条严格交替路径。\n\n3.  **起始和目标顶点 $s'$ 和 $t'$**：\n    - 如果 $s \\in A$，起始顶点 $s'$ 为 $(s, \\text{'A'})$；如果 $s \\in B$，则为 $(s, \\text{'B'})$。\n    - 如果 $t \\in A$，目标顶点 $t'$ 为 $(t, \\text{'A'})$；如果 $t \\in B$，则为 $(t, \\text{'B'})$。\n    在 $G'$ 中存在从 $s'$ 到 $t'$ 的路径，当且仅当在 $G$ 中存在从 $s$ 到 $t$ 的有效交替路径。\n\n**将构造应用于给定实例**\n\n给定的实例是：\n- $V = \\{v_1, v_2, v_3, v_4, v_5, v_6\\}$\n- $A = \\{v_1, v_2, v_5\\}$\n- $B = \\{v_3, v_4\\}$\n- $s = v_1$, $t = v_2$\n- $E = \\{(v_1, v_3), (v_1, v_6), (v_2, v_4), (v_3, v_2), (v_3, v_5), (v_4, v_1), (v_4, v_5), (v_5, v_3), (v_6, v_2)\\}$\n- 允许在路径上出现的顶点集是 $A \\cup B = \\{v_1, v_2, v_3, v_4, v_5\\}$。顶点 $v_6$ 不在 $A \\cup B$ 中。\n\n**计算 $|V'|$**\n\n$G'$ 中的顶点数是集合 $A$ 和 $B$ 的大小之和。\n$|A| = 3$\n$|B| = 2$\n$|V'| = |A| + |B| = 3 + 2 = 5$。\n$V'$ 中的顶点是 $\\{(v_1, \\text{'A'}), (v_2, \\text{'A'}), (v_5, \\text{'A'}), (v_3, \\text{'B'}), (v_4, \\text{'B'}) \\}$。\n\n**计算 $|E'|**\n\n我们遍历 $E$ 中的每条边 $(u, v)$，并检查它是否为 $E'$ 贡献一条边。如果 $u, v \\in A \\cup B$ 且它们属于不同的集合，则该边会贡献一条边。\n\n1.  $(v_1, v_3)$: $v_1 \\in A$, $v_3 \\in B$。这创建了一条边 $((v_1, \\text{'A'}), (v_3, \\text{'B'}))$。(1)\n2.  $(v_1, v_6)$: $v_6 \\notin A \\cup B$。这条边被忽略。\n3.  $(v_2, v_4)$: $v_2 \\in A$, $v_4 \\in B$。这创建了一条边 $((v_2, \\text{'A'}), (v_4, \\text{'B'}))$。(2)\n4.  $(v_3, v_2)$: $v_3 \\in B$, $v_2 \\in A$。这创建了一条边 $((v_3, \\text{'B'}), (v_2, \\text{'A'}))$。(3)\n5.  $(v_3, v_5)$: $v_3 \\in B$, $v_5 \\in A$。这创建了一条边 $((v_3, \\text{'B'}), (v_5, \\text{'A'}))$。(4)\n6.  $(v_4, v_1)$: $v_4 \\in B$, $v_1 \\in A$。这创建了一条边 $((v_4, \\text{'B'}), (v_1, \\text{'A'}))$。(5)\n7.  $(v_4, v_5)$: $v_4 \\in B$, $v_5 \\in A$。这创建了一条边 $((v_4, \\text{'B'}), (v_5, \\text{'A'}))$。(6)\n8.  $(v_5, v_3)$: $v_5 \\in A$, $v_3 \\in B$。这创建了一条边 $((v_5, \\text{'A'}), (v_3, \\text{'B'}))$。(7)\n9.  $(v_6, v_2)$: $v_6 \\notin A \\cup B$。这条边被忽略。\n\n计算创建的边，我们发现 $E'$ 中有 7 条边。\n$|E'| = 7$。\n\n最终得到的数对是 $(|V'|, |E'|) = (5, 7)$。", "answer": "$$\\boxed{\\begin{pmatrix} 5  7 \\end{pmatrix}}$$", "id": "1435018"}, {"introduction": "归约的正确性取决于一个严格的逻辑等价关系：一个输入是“是”实例，当且仅当其转化后的实例也是“是”实例。最后一个练习通过一个思想实验来检验你对这一要求的理解，探讨一个看似微小的归约错误会如何使整个 `NL` 硬度证明失效。[@problem_id:1435034]", "problem": "在计算复杂性理论中，PATH 问题是理解 NL 类的基石。PATH 问题询问一个有向图 $G$ 是否包含两个指定顶点 $s$ 和 $t$ 之间的路径。复杂性类 NL（Nondeterministic Logarithmic-space，非确定性对数空间）包含所有能被使用与输入长度成对数关系大小的工作带的非确定性图灵机 (NTM) 解决的判定问题。\n\n为了证明 PATH 是 NL-难的，必须表明对于任何语言 $L \\in \\text{NL}$，都存在一个从 $L$ 到 PATH 的对数空间归约。标准证明过程如下：设 $L$ 是 NL 中的一个语言，由一个对数空间 NTM $M$ 决定。对于任何输入字符串 $w$，一个对数空间转换器会构建一个“构型图”$G_M(w)$。该图的顶点代表了机器 $M$ 在输入 $w$ 上的所有可能构型。当且仅当机器 $M$ 可以在一个计算步骤内从构型 $C_1$ 转换到 $C_2$ 时，才存在一条从 $C_1$ 到 $C_2$ 的有向边。因此，判定 $w \\in L$ 的问题等价于判定在 $G_M(w)$ 中是否存在一条从初始构型 $C_{start}$ 到唯一的接受构型 $C_{accept}$ 的路径。\n\n现在，考虑一个学生 Alice，她实现了一个对数空间转换器来执行此归约。她的转换器有一个微妙的错误。对于一个 NTM $M$ 的任何给定输入 $w$：\n- 它正确地生成所有可能构型的集合作为顶点。\n- 它正确地识别 $C_{start}$ 和 $C_{accept}$ 顶点。\n- 然而，在生成边时，如果所有有效的单步机器转移的集合非空，她的转换器会从最终的图表示中始终省略掉一个有效的转移。被省略的具体边可能因输入 $w$ 而异。\n\n鉴于 Alice 的实现中存在这个特定缺陷，这对她作为 PATH 问题 NL-难性证明的构造的有效性有何影响？\n\nA. PATH 的 NL-难性证明仍然完全有效。省略一条边是一个微不足道的错误，不会破坏对所有可能输入的基本逻辑等价性。\n\nB. 证明无效。该缺陷可能导致语言 $L$ 的一个“no”实例（即输入 $w \\notin L$）被映射到 PATH 的一个“yes”实例，因为错误的图可能包含一条本不应存在的路径。\n\nC. 证明无效。该缺陷可能导致语言 $L$ 的一个“yes”实例（即输入 $w \\in L$）被映射到 PATH 的一个“no”实例，因为被省略的边可能对所有接受计算路径都至关重要。\n\nD. 证明无效，但这主要是因为执行归约的转换器由于需要额外的逻辑来选择和省略一条边，不再能保证在对数空间内运行。\n\nE. PATH 的 NL-难性证明失败了，但该构造现在可以被视为 PATH 包含于 NL（即 PATH $\\in$ NL）的一个有效证明。", "solution": "我们将标准归约和该缺陷的影响形式化。\n\n1) 标准归约及其正确性条件：\n- 设 $L \\in \\text{NL}$ 且 $M$ 是一个决定 $L$ 的非确定性对数空间图灵机。\n- 在输入 $w$ 上，对数空间转换器构建构型图 $G_{M}(w)=(V,E)$，其顶点 $V$ 是 $M$ 在 $w$ 上的所有构型，并且当且仅当 $M$ 可以一步从构型 $C_{1}$ 转移到构型 $C_{2}$ 时，$(C_{1},C_{2}) \\in E$。\n- 令 $s=C_{start}$ 为唯一的起始构型， $t=C_{accept}$ 为唯一的接受构型。\n- 对 PATH 的归约的标准正确性条件是：\n$$\nw \\in L \\iff \\text{在 } G_{M}(w) \\text{ 中存在从 } s \\text{ 到 } t \\text{ 的路径。}\n$$\n\n2) Alice 在归约实例中的缺陷模型：\n- Alice 的转换器输出相同的顶点集 $V$，相同的 $s$ 和 $t$，但边集 $E'$ 是在 $E$ 非空时通过移除一个有效转移得到的。形式上，对于某个边 $e^{*} \\in E$（可能取决于 $w$），\n$$\nE' \\;=\\; E \\setminus \\{e^{*}\\}.\n$$\n- 因此，生成的实例是 $G'=(V,E')$，具有相同的 $s,t$。\n\n3) 对“no”方向的影响：\n- 假设 $w \\notin L$。那么在 $G_{M}(w)$ 中没有从 $s$ 到 $t$ 的路径：\n$$\nw \\notin L \\implies \\neg\\exists \\text{ 路径 } s \\leadsto t \\text{ in } G_{M}(w).\n$$\n- 移除边不能创建新路径。形式上，如果 $E' \\subseteq E$，那么在 $(V,E')$ 中的任何 $s \\leadsto t$ 路径也都是在 $(V,E)$ 中的 $s \\leadsto t$ 路径。因此，\n$$\n\\neg\\exists \\text{ 路径 } s \\leadsto t \\text{ in } (V,E) \\;\\implies\\; \\neg\\exists \\text{ 路径 } s \\leadsto t \\text{ in } (V,E').\n$$\n- 因此，一个“no”实例不会被 Alice 的缺陷映射成一个“yes”实例。选项 B 是错误的。\n\n4) 在缺陷下，“yes”实例变为“no”实例的存在性：\n- 为了保持 NL-难性，归约必须对所有 $w$ 满足：\n$$\nw \\in L \\iff \\exists \\text{ 路径 } s \\leadsto t \\text{ in } (V,E').\n$$\n- 我们证明这种等价性可能会失效。构造 $M$ 和 $w \\in L$ 使得 $G_{M}(w)$ 中恰好有一条 $s \\leadsto t$ 路径，并且除了该路径上的边之外没有其他边。一种方法是让 $M$ 在 $w$ 上是确定性的，有一个唯一的接受运行，并定义其转移函数，使得不在该运行上的每个构型都停机（没有出边）。那么 $E$ 中唯一的边恰好就是唯一的 $s \\leadsto t$ 路径上的边。\n- 由于当 $E$ 非空时，Alice 的缺陷会从 $E$ 中移除恰好一条边 $e^{*}$，它必然会移除那条唯一路径上的一条边。因此新图 $(V,E')$ 中没有 $s \\leadsto t$ 路径：\n$$\nw \\in L \\text{ 且 } E' = E \\setminus \\{e^{*}\\} \\text{ 并且 } e^{*} \\text{ 在唯一的 } s \\leadsto t \\text{ 路径上 } \\implies \\neg\\exists \\text{ 路径 } s \\leadsto t \\text{ in } (V,E').\n$$\n- 因此，存在输入 $w \\in L$，对于这些输入，有缺陷的归约会输出一个 PATH 的“no”实例。这破坏了所需的双向蕴含关系，并使归约无效。这正是选项 C 中描述的失败情况。\n\n5) 其余选项：\n- 选项 A 不正确，因为等价性必须对所有输入都成立；当一条边位于所有接受路径上时，移除这条边可能是致命的。\n- 选项 D 不正确，因为原则上空间界限不受影响；问题在于语义正确性，而非空间复杂度。\n- 选项 E 与 NL-难性无关；此外，这个有缺陷的归约并不能证明 $\\text{PATH} \\in \\text{NL}$（这一点是独立已知的）。\n\n结论：该缺陷可以通过删除对所有接受路径都至关重要的一条边，将 $L$ 的“yes”实例映射到 PATH 的“no”实例，因此，由于选项 C 中所述的原因，该证明无效。", "answer": "$$\\boxed{C}$$", "id": "1435034"}]}