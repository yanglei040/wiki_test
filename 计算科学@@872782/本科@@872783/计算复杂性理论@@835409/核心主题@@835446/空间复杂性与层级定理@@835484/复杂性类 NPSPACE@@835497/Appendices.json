{"hands_on_practices": [{"introduction": "为了理解像 `NPSPACE` 这样的复杂性类，我们最好从一个具体且直观的模型开始。这个练习旨在帮助我们将“对数空间”这一抽象概念具体化，通过一个字符串问题将其与一个实际的“在输入带上使用指针”的计算模型联系起来。通过解决这个问题，你将对非确定性图灵机如何在有限的内存下执行计算有一个更清晰的认识 [@problem_id:1453626]。", "problem": "在数据传输和验证领域，通常使用冗余来防止错误。考虑一个简化的协议，其中一个密钥（一个非空字符串 $v$）通过发送两个独立的、相同的 $v$ 的副本来传输。然而，传输信道可能会将这两个副本的各部分交错。结果是一个单一的接收字符串 $w$。接收端的系统必须验证 $w$ 是否可能由这个过程生成。\n\n形式上，我们说一个字符串 $w$ 是两个字符串 $x$ 和 $y$ 的交错，如果 $w$ 的字符可以被划分为两个子序列，当按顺序读取时，它们正好构成 $x$ 和 $y$。例如，`axbyc` 是 `abc` 和 `xy` 的一个交错。\n\n令语言 `TWIN_INTERLEAVE` 为给定字母表 $\\Sigma$ 上所有字符串 $w$ 的集合，其中 $w$ 是某个非空字符串 $v$ 与其自身的交错。例如，`ab` 不在该语言中，但 `aabb` 是（对于 $v$=`ab`，第一个副本使用索引1和4的字符，第二个副本使用索引2和3的字符），而 `abab` 不是。\n\n在计算复杂性理论中，一个已知的结果是 `TWIN_INTERLEAVING` 问题可以由一台非确定性图灵机在其工作带上使用相对于输入大小的对数空间来判定。这个复杂性类被称为 NL，即非确定性对数空间（`NL` ($\\mathrm{NSPACE}(\\log n)$)）。\n\n令 $n$ 为输入字符串 $w$ 的长度。下列哪个选项最能描述一台非确定性图灵机在该对数空间限制内判定 `TWIN_INTERLEAVE` 成员资格时，其工作带上的基本存储需求？\n\nA. 一个能够存储从 $0$ 到 $n$ 之间任意整数值的单个计数器。\n\nB. 固定数量的指针，其中每个指针是一个变量，用于存储输入字符串 $w$ 的索引（即一个从 $1$ 到 $n$ 的值）。\n\nC. 一个临时缓冲区，用于存放长度最大为 $n/2$ 的 $w$ 的子串。\n\nD. 一个足够大的内存段，用于存储完整的候选字符串 $v$。\n\nE. 两个栈，其中两个栈中存储的符号总数最多可达 $n$。", "solution": "我们将判定任务形式化如下：给定一个长度为 $n$ 的输入字符串 $w$，我们要判定它是否是某个非空字符串 $v$ 与其自身的交错。\n\n一个非确定性对数空间（NL）算法可以有效地解决这个问题。该算法的核心思想是，在不显式构造字符串 $v$ 的情况下，验证 $w$ 是否可以被划分为两个相同的子序列。这可以通过使用固定数量的指针来实现，这些指针指向输入字符串 $w$ 中的位置。例如，使用两个指针 $p_1$ 和 $p_2$ 来分别跟踪两个子序列的匹配进度。算法非确定性地在 $w$ 中为两个子序列寻找匹配的字符并相应地移动指针。由于每个指针存储一个 $1$ 到 $n$ 之间的索引，所以只需要 $O(\\log n)$ 的空间。因此，基本存储需求是固定数量的指针。", "answer": "$$\\boxed{B}$$", "id": "1453626"}, {"introduction": "在理解了非确定性空间之后，一个核心问题是它与确定性空间的关系。萨维奇定理（Savitch's Theorem）是连接这两者的基本桥梁，它表明非确定性在空间方面只带来多项式开销。本练习提供了一个直接应用萨维奇定理的机会，通过计算一个假设算法的确定性空间上限，你将能够巩固对该定理定量关系的理解 [@problem_id:1453645]。", "problem": "一位计算生物学家设计了一种新的非确定性算法，用于分析复杂蛋白质折叠路径的稳定性。输入规模为 $n$，它编码了蛋白质的一级结构和环境因素。\n\n该算法在任何单一非确定性计算路径上的性能由其内存使用量（空间复杂度）来表征。该使用量由两个主要部分组成：\n1. 一个用于存储蛋白质状态空间的主数据结构，需要与 $n^{2/5}$ 成正比的内存量。\n2. 一个用于递归路径查找搜索的辅助暂存空间，其峰值需要与 $n^{3/5}$ 成正比的内存量。\n\n在计算中内存最密集的部分，主数据结构和辅助暂存空间必须同时保存在内存中。为了验证算法的正确性，需要在标准的确定性机器上对其进行模拟。萨维奇定理（Savitch's theorem）提供了一种方法，来确定这种确定性模拟所需空间的一个上界。\n\n直接应用萨维奇定理，可以保证解决相同问题的*确定性*算法的空间复杂度的最紧上界是什么？请用大O表示法将答案表示为 $n$ 的函数。", "solution": "在任何单条计算路径上，该非确定性算法的峰值空间是两个同时存在的组成部分之和：需要 $O(n^{2/5})$ 空间的主数据结构和需要 $O(n^{3/5})$ 空间的辅助暂存空间。因此，非确定性空间复杂度为\n$$\ns(n)=\\Theta(n^{2/5}+n^{3/5})=\\Theta(n^{3/5}).\n$$\n根据萨维奇定理，对于任何 $s(n)\\ge \\log n$，我们有\n$$\n\\mathrm{NSPACE}(s(n))\\subseteq \\mathrm{DSPACE}(s(n)^{2}).\n$$\n这里，$s(n)=\\Theta(n^{3/5})$ 对于足够大的 $n$ 满足 $s(n)\\ge \\log n$，因此直接应用萨维奇定理可以得出一个确定性空间上界\n$$\n\\mathrm{DSPACE}(s(n)^{2})=\\mathrm{DSPACE}(\\Theta(n^{3/5})^{2})=\\mathrm{O}(n^{6/5}).\n$$\n因此，由萨维奇定理保证的、解决相同问题的确定性算法的最紧上界是 $O(n^{6/5})$。", "answer": "$$\\boxed{O(n^{6/5})}$$", "id": "1453645"}, {"introduction": "现在，我们可以挑战一个更复杂的问题，它将非确定性和递归结合在一起。这个矩阵生成问题中提出的算法，其“分而治之”的递归结构与萨维奇定理本身的证明思想惊人地相似。分析这个递归过程的空间复杂度，不仅能让你深入了解这类空间高效的模拟是如何工作的，还能锻炼你在复杂性分析中处理递归算法的关键技能 [@problem_id:1453632]。", "problem": "考虑**矩阵乘积生成 (MPG)** 问题。MPG 的一个实例是一个元组 $(n, p, S, T, L)$，其中：\n- $n$ 是一个正整数，表示矩阵的维度。\n- $p$ 是一个素数，定义了有限域 $F_p$。\n- $S = \\{G_1, G_2, \\ldots, G_m\\}$ 是一个包含 $m$ 个生成矩阵的集合，其中每个 $G_i$ 是一个 $n \\times n$ 矩阵，其元素属于 $F_p$。\n- $T$ 是一个 $n \\times n$ 的目标矩阵，其元素属于 $F_p$。\n- $L$ 是一个正整数，表示矩阵乘积允许的最大长度。\n\n该问题旨在判断是否存在一个整数 $k$（满足 $1 \\le k \\le L$）和 $k$ 个来自集合 $S$ 的矩阵序列 $M_1, M_2, \\ldots, M_k$（矩阵可以重复选择），使得它们的乘积等于目标矩阵 $T$。即 $T = M_k \\cdots M_2 M_1$。\n\n为了分析该问题的复杂性，一位计算机科学家提出了一个递归的非确定性过程 `Can_Reach(A, B, k)`。如果矩阵 `B` 可以通过将矩阵 `A` 右乘一个由 $S$ 中恰好 `k` 个矩阵构成的乘积得到，则该过程返回 `true`。形式上，如果存在一个来自 $S$ 的序列 $M_1, \\ldots, M_k$ 使得 $B = A \\cdot M_1 \\cdot M_2 \\cdots M_k$，则 `Can_Reach(A, B, k)` 为 `true`。所有算术运算都在 $F_p$ 中进行。\n\n该过程定义如下：\n1.  **基本情况 (k=1):** 遍历集合 $S$ 中的每个生成矩阵 $G_i$。如果 $A \\cdot G_i = B$，则返回 `true`。如果循环结束仍未找到这样的生成矩阵，则返回 `false`。\n2.  **递归步骤 (k>1):**\n    a. 非确定性地选择一个中间 $n \\times n$ 矩阵 $C$，其元素属于 $F_p$。\n    b. 递归调用 `Can_Reach(A, C, \\lfloor k/2 \\rfloor)`。\n    c. 递归调用 `Can_Reach(C, B, k - \\lfloor k/2 \\rfloor)`。\n    d. 如果两个递归调用都返回 `true`，则返回 `true`。否则，此非确定性路径失败。\n\n一台非确定性图灵机 (NTM) 可以通过首先非确定性地猜测一个长度 $k \\in \\{1, \\ldots, L\\}$，然后执行 `Can_Reach(I, T, k)` 来解决 MPG 问题，其中 $I$ 是 $n \\times n$ 的单位矩阵。\n\n为了进行复杂性分析，假设最大乘积长度为 $L = 2^{n^2}$。假设存储一个 $n \\times n$ 矩阵需要 $O(n^2)$ 的空间，存储一个值最大为 $L$ 的整数需要 $O(\\log L)$ 的空间。这个基于 NTM 的算法的空间复杂度作为 $n$ 的函数是多少？从以下选项中选择最紧的渐近上界。\n\nA. $O(n^2)$\n\nB. $O(n^3)$\n\nC. $O(n^4)$\n\nD. $O(n^6)$\n\nE. $O(2^{n^2})$", "solution": "我们分析运行该递归过程的 NTM 在单条计算路径上使用的非确定性空间。\n\n设 $L = 2^{n^2}$。机器首先猜测 $k \\in \\{1,\\ldots,L\\}$，这需要 $O(\\log L)$ 的空间。由于 $\\log_2 L = n^2$，因此这部分空间是 $O(n^2)$。\n\n考虑递归过程 $\\text{Can\\_Reach}(A,B,k)$。定义 $S(k)$ 为在处理参数为 $k$ 的调用时，单条非确定性路径上使用的空间（不包括只读输入）。我们只计算工作空间。\n\n基本情况 $k=1$：为了检查是否存在 $G_i \\in S$ 使得 $A G_i = B$，我们可以一次计算一个乘积，这需要存储一个 $n \\times n$ 的矩阵结果，即 $O(n^2)$ 的空间。因此，\n$$\nS(1) = O(n^2).\n$$\n\n递归情况 $k>1$：该算法\n1) 非确定性地选择一个中间矩阵 $C$ 并存储它，这需要 $O(n^2)$ 的空间；\n2) 递归调用 $\\text{Can\\_Reach}(A,C,\\lfloor k/2 \\rfloor)$，然后\n3) 调用 $\\text{Can\\_Reach}(C,B,k - \\lfloor k/2 \\rfloor)$。\n\n这两个递归调用是顺序执行的，但所选择的矩阵 $C$ 必须在两次调用期间都保持存在。因此，每一层递归都会增加：\n- 一个存储的矩阵 $C$：$O(n^2)$ 空间，\n- 一个存储的整数参数（例如当前的 $k$ 或其一半），大小为 $O(\\log L) = O(n^2)$。\n\n因此，每一层递归在更深层递归调用的基础上增加了 $O(n^2 + \\log L) = O(n^2)$ 的空间。写出递推关系式，\n$S(k) = S(\\lfloor k/2 \\rfloor) + O(n^2)$。\n递归深度为 $O(\\log_2 k) \\le O(\\log_2 L) = O(n^2)$。展开递推式可得\n$O(n^2 \\cdot \\log_2 k) + S(1) \\le O(n^2 \\cdot \\log_2 L) + O(n^2) = O(n^2 \\cdot n^2) + O(n^2) = O(n^4)$。\n\n因此，在最坏情况下，基于 NTM 的算法使用 $O(n^4)$ 的空间。在给定的选项中，最紧的渐近上界是 $O(n^4)$。", "answer": "$$\\boxed{C}$$", "id": "1453632"}]}