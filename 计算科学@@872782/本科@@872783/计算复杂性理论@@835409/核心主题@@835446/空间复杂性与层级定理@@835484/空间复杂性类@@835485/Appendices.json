{"hands_on_practices": [{"introduction": "计算复杂性理论中的空间复杂度衡量的是算法在计算过程中使用的“工作”内存量，这与存储输入本身所需的空间是分开的。这个练习旨在通过一个巧妙设计的计算模型来巩固这一核心概念。通过为一个具有两个独立读头的特殊图灵机设计算法，你将探索如何利用对输入的灵活访问来最小化工作带空间的使用，从而得出一个在空间效率上极为出色的解决方案。[@problem_id:1448405]", "problem": "考虑一种为分析字符串而设计的特殊图灵机（TM）。该机器配备一条只读的输入带和一条独立标准的读写工作带。特别地，它有两个独立的只读磁头，我们称之为 $H_1$ 和 $H_2$，可以在输入带上向左或向右移动。\n\n给定一个长度为 $n$ 的输入字符串 $w$，其中 $n$ 保证为正偶数。字符串中的符号来自有限字母表 $\\Sigma$。任务是为此机器设计一个算法，以确定字符串 $w$ 是否为偶数长度的回文串，即它可以表示为 $x x^R$ 的形式，其中 $x$ 是字符串的前半部分，$x^R$ 是 $x$ 的逆序。\n\n在这个特定的双磁头图灵机上，解决此问题的最节省空间的算法的空间复杂度是多少？空间复杂度定义为工作带上使用的单元格数量，作为输入长度 $n$ 的函数。\n\n从以下选项中选择正确的复杂度类别。\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(\\sqrt{n})$\n\nD. $O(n)$\n\nE. $O(n \\log n)$", "solution": "我们对机器模型进行形式化描述：输入带是只读的，并且有两个独立的磁头 $H_1$ 和 $H_2$，它们可以向左或向右移动。有一个独立的读写工作带，其空间复杂度是根据输入长度 $n$ 使用的不同单元格数量来衡量的。输入长度 $n$ 是一个正偶数，目标是判断是否 $w = x x^{R}$。\n\n使用两个只读磁头和常数工作带空间的算法：\n1. 将 $H_1$ 移动到第一个输入符号处，方法是将其向左移动直到读到左端标记，然后向右移动一次。\n2. 将 $H_2$ 移动到最后一个输入符号处，方法是将其向右移动直到读到右端标记，然后向左移动一次。\n3. 重复以下循环：\n   a. 读取 $H_1$ 和 $H_2$ 下的符号。如果它们不同，立即拒绝。\n   b. 将 $H_1$向右移动一个单元格，将 $H_2$ 向左移动一个单元格。\n   c. 如果 $H_2$ 现在读到左端标记，则接受。\n\n正确性论证：\n- 最初，$H_1$ 位于索引 $0$ 处，$H_2$ 位于索引 $n-1$ 处。在第 $t$ 次迭代中（从 $t=0$ 开始），比较的符号位于索引 $t$ 和 $n-1-t$ 处。如果 $w$ 不是偶数长度的回文串，那么存在某个 $i$ 满足 $0 \\le i  \\frac{n}{2}$，使得 $w[i] \\neq w[n-1-i]$，算法将在第 $t = i$ 次迭代时拒绝。如果所有这样的对都匹配，那么循环将继续进行，直到 $H_2$ 到达左端标记，此时机器接受。\n- 这个循环可能会比较每个对称对两次（一次在磁头交叉前，一次在交叉后），但这不影响正确性。\n\n空间使用情况：\n- 工作带从不用于存储索引、计数器或标记；所有控制都是通过在输入带上移动两个只读磁头来实现的。机器只需要常数数量的控制状态。因此，所使用的工作带单元格数量受一个与 $n$ 无关的常数限制。\n- 形式上，如果 $S(n)$ 表示在长度为 $n$ 的输入上使用的工作带单元格数量，那么存在一个常数 $c$，使得对于所有 $n$ 都有 $S(n) \\leq c$。因此，$S(n) \\in O(1)$。\n\n在给定选项中的最优性：\n- 没有任何算法可以使用少于常数的工作带空间，而所提出的算法实现了常数空间。因此，在所提供的选项中，最节省空间的复杂度类别是 $O(1)$。\n\n所以，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1448405"}, {"introduction": "在理解了如何衡量单个问题的空间复杂度后，我们转向研究整个复杂性类的属性。一个关键问题是，这些类在基本操作（如并集、交集或连接）下是否是封闭的。这个练习探讨了非确定性对数空间（$NL$）在字符串连接操作下的闭包性，并提出了一个看似合理的算法。你的任务是仔细审查这个算法的逻辑，识别其中在模拟子问题时可能出现的微妙陷阱，这是掌握对数空间计算技巧的关键一步。[@problem_id:1448432]", "problem": "在计算复杂性理论中，一个语言（language）是指在有限字母表 $\\Sigma$ 上的一个字符串集合。复杂性类非确定性对数空间 (**NL**) 包含所有可以由非确定性图灵机（NTM）在输入长度为 $n$ 时使用大小为 $O(\\log n)$ 的工作带判定的语言。\n\n两个语言 $L_1$ 和 $L_2$ 的串联（concatenation）被定义为语言 $L_1 \\circ L_2 = \\{w_1w_2 \\mid w_1 \\in L_1 \\text{ and } w_2 \\in L_2\\}$，其中 $w_1w_2$ 是将字符串 $w_2$ 附加到字符串 $w_1$ 后形成的字符串。\n\n一个基本问题是复杂性类在某些运算下是否是闭合的。考虑以下论断：“NL 类在串联运算下是闭合的。”\n\n为了研究这个论断，一位工程师提出了以下用于一台新 NTM（我们称之为 $M_{cat}$）的算法，以判定长度为 $n$ 的输入字符串 $w$ 是否属于 $L_1 \\circ L_2$。这里假设 $L_1, L_2 \\in \\text{NL}$ 分别由 NTM $M_1$ 和 $M_2$ 判定。\n\n**关于输入 $w$ 的 $M_{cat}$ 算法提议：**\n1.  非确定性地猜测一个分割点，即一个整数索引 $i$，其中 $0 \\le i \\le n$。这将输入 $w$ 分割成一个前缀 $u = w[1..i]$ 和一个后缀 $v = w[i+1..n]$。\n2.  为了检查前缀 $u$ 是否在 $L_1$ 中，该机器在*整个*输入字符串 $w$ 上模拟 $M_1$。但是，模拟过程被修改：如果在任何时候 $M_1$ 的输入带读写头试图移动到大于 $i$ 的位置，当前非确定性路径将立即被拒绝。\n3.  如果对 $M_1$ 的这个修改后的模拟进入了接受状态，那么机器接着检查后缀 $v$。它在*整个*输入字符串 $w$ 上模拟 $M_2$。这个模拟过程也被修改：如果在任何时候 $M_2$ 的输入带读写头试图读取位置 $k \\le i$ 上的符号，它将读到一个不属于原始字母表 $\\Sigma$ 的特殊符号 `$`。\n4.  如果（第3步中）对 $M_2$ 的模拟也进入了接受状态，那么 $M_{cat}$ 接受输入字符串 $w$。如果在某个给定的非确定性路径上，任何接受条件未被满足，该路径就拒绝。\n\n以下哪个陈述对该论断和所提议的算法提供了最准确的评估？\n\nA. 该论断是正确的，并且所提议的算法是一个有效的过程，它能在对数空间内正确地判定 $L_1 \\circ L_2$ 的成员资格。\n\nB. 该论断是正确的，但所提议的算法有缺陷。虽然其判定成员资格的逻辑是合理的，但它需要超过对数空间，因为它模拟了两个独立的机器，而每个机器都使用对数空间。\n\nC. 该论断是正确的，但所提议的算法有缺陷。所描述的过程没有正确地测试后缀字符串在 $L_2$ 中的成员资格，因为修改 $M_2$ 所见的输入带不等同于将后缀作为一个独立的输入在 $M_2$ 上运行。\n\nD. 该论断是错误的。存在语言 $L_1, L_2 \\in \\text{NL}$，使得它们的串联 $L_1 \\circ L_2$ 不在 NL 中。所提议算法中的缺陷是一个根本性的缺陷，无法在对数空间限制内修复。\n\nE. NL 在串联运算下的闭包性是复杂性理论中一个已知的开放问题，与 L vs. NL 问题密切相关。所提供的算法是一个已知的、但未成功的解决方案尝试。", "solution": "我们对该论断和所提议的算法进行分析，并充分关注对数空间模型以及为 NTM 模拟子输入的语义。\n\n首先，回顾定义：**NL** 是指可以由一台在只读输入带上使用 $O(\\log n)$ 空间的非确定性图灵机判定的语言类。要证明 **NL** 在串联运算下是闭合的，我们只需在给定判定 $L_{1} \\in \\text{NL}$ 的 $M_{1}$ 和判定 $L_{2} \\in \\text{NL}$ 的 $M_{2}$ 的情况下，构造一台使用 $O(\\log n)$ 空间来判定 $L_{1} \\circ L_{2}$ 的 NTM $M_{cat}$。\n\n一个标准的正确方法如下。对于长度为 $n$ 的输入 $w$，$M_{cat}$ 非确定性地猜测一个分割索引 $i \\in \\{0,1,\\dots,n\\}$，然后：\n- 通过跟踪模拟的输入读写头位置 $h_{1} \\in \\{0,1,\\dots,i+1\\}$，并在需要时将其转换为 $w$ 上的实际输入读写头位置，来模拟 $M_{1}$ 在前缀 $u = w[1..i]$ 上的运行。如果模拟的读写头试图从 $i$向右移动到 $i+1$，它应该读取 $u$ 的右端标记（或空白符）；类似地，如果它从位置 $1$ 向左移动到 $0$，它应该读取 $u$ 的左端标记。这可以通过使用 $O(\\log n)$ 位二进制数来维护 $h_{1}$，并在读取符号时将实际输入读写头重新定位到与 $h_{1}$ 对应的绝对索引来实现。由于重新扫描，时间可能会增加，但空间仍保持为 $O(\\log n)$。\n- 如果 $M_{1}$ 接受，那么它通过跟踪模拟的读写头位置 $h_{2} \\in \\{0,1,\\dots,|v|+1\\}$ 来模拟 $M_{2}$ 在后缀 $v = w[i+1..n]$ 上的运行，并将 $h_{2}=0$ 解释为 $v$ 的左端标记，将 $h_{2}=|v|+1$ 解释为右端标记。当 $1 \\leq h_{2} \\leq |v|$ 时，实际输入读写头移动到绝对位置 $i+h_{2}$，当 $h_{2} \\in \\{0,|v|+1\\}$ 时，则提供相应的端标记。同样，$h_{2}$ 用 $O(\\log n)$ 空间存储，并且模拟的工作带重用相同的 $O(\\log n)$ 空间预算。\n- 使用的总空间为 $O(\\log n)$，因为我们存储了：分割索引 $i$ 的二进制表示、每次一个模拟读写头计数器（$h_{1}$ 或 $h_{2}$），以及 $M_{1}$ 或 $M_{2}$ 的工作带，每个都使用 $O(\\log n)$ 空间。这些量是顺序重用的，所以总和是 $O(\\log n)$。\n\n因此，“**NL** 在串联运算下是闭合的”这一论断是正确的。\n\n接下来，我们评估工程师提议的算法。\n\n步骤 1（猜测 $i$）是合适的，并且使用 $O(\\log n)$ 空间来存储 $i$。\n\n然而，步骤 2 是有缺陷的。它提议在整个 $w$ 上模拟 $M_{1}$，但如果 $M_{1}$ 试图将其输入读写头移动到超过位置 $i$ 的地方，就立即拒绝。这并不能正确地在 $u$ 上模拟 $M_{1}$，因为在输入 $u$ 上，机器可能合法地移动到位置 $i+1$ 来读取右端标记（或空白符），其行为可能依赖于那个符号。强制在任何访问位置 $i+1$ 的尝试时立即拒绝，会错误地改变 $M_{1}$ 的行为，并可能导致拒绝有效的输入。\n\n步骤 3 试图通过在所有位置 $k \\leq i$ 处提供一个特殊符号来模拟 $M_2$ 在后缀 $v$ 上的运行。这同样不等同于将 $v$ 作为一个独立输入来模拟 $M_2$：一个准确的模拟必须为 $v$ 强制执行正确的左端标记语义（读写头不能自由地移动到左边任意多个返回相同符号的不同位置），跟踪在 $v$ 内部的相对读写头位置，并在恰好是边界 $i$ 和 $n$ 的地方提供正确的端标记。简单地用一个特殊符号替换所有 $k \\leq i$ 的位置，未能强制 $v$ 只有一个具有正确读写头移动约束的左边界单元；它改变了 $M_2$ 的转移结构，使其不同于在真实输入等于 $v$ 时的行为。因此，这种输入修改不是在 $v$ 上运行 $M_2$ 的有效模拟。\n\n关于空间使用，缺陷并不在于顺序模拟两个对数空间机器会超过 $O(\\log n)$ 空间；由于模拟是顺序进行的并且重用空间，总空间保持为 $O(\\log n)$。因此，认为该算法需要超过对数空间的反对意见是不正确的。\n\n综合以上几点：\n- 关于闭包性的论断是正确的。\n- 所提议的算法是有缺陷的，因为它限制或修改输入读写头访问的方法没有忠实地模拟 $M_1$ 在 $u$ 上的运行和 $M_2$ 在 $v$ 上的运行。\n- 最准确的批评是，修改 $M_2$ 所见的输入（以及类似地，对 $M_1$ 的拒绝规则）不等同于正确的子串模拟，尽管存在一个正确的对数空间构造方法。\n\n因此，正确的选项是断言该论断正确，但具体的提议过程因未能正确模拟后缀的成员资格测试而存在缺陷的陈述。", "answer": "$$\\boxed{C}$$", "id": "1448432"}, {"introduction": "复杂性理论的魅力不仅在于对问题进行分类，还在于揭示不同复杂性类之间深刻而意想不到的联系。这个高级练习将你带到该领域一个核心开放性问题的前沿：$L$ 是否等于 $NL$？通过一个假设（即 $L$ 在克林星号操作下是封闭的），你将推导出其对 $L$ 与 $NL$ 关系所产生的深远影响。这个问题将挑战你运用一种精妙的归约技巧，展示了如何通过探索抽象的闭包性质来攻击计算理论中的重大难题。[@problem_id:1448429]", "problem": "在计算复杂性理论中，**L** 是指能被确定性图灵机使用 $O(\\log n)$ 空间解决的判定问题类，而 **NL** 是对应的非确定性图灵机的问题类。一个主要的开放问题是 **L = NL** 是否成立。要解决这个问题，可以证明一个 **NL**-完全问题（例如 **PATH**）属于 **L**。**PATH** 问题询问的是，在一个给定的有向图 $G=(V, E)$ 中，是否存在一条从指定顶点 $s$ 到顶点 $t$ 的路径。\n\n探索此类问题的一个常用方法是，为一个复杂性类假设某个属性，然后观察其推论。假设我们认为 **L** 在克林星号（Kleene star）运算下是闭合的。这意味着如果一个语言 $A$ 属于 **L**，那么它的克林星号 $A^*$ 也属于 **L**。\n\n证明该假设蕴含 **L = NL** 的标准方法是，证明 **L** 也必须在一种“复合”运算下是闭合的，而这种运算可以用来解决 **PATH** 问题。对于一个由顶点对 $(u,v)$ 构成的字母表上的语言 $A$，它与自身的复合定义为：\n$$A \\circ A = \\{ (u, w) \\mid \\text{存在一个顶点 } v \\text{ 使得 } (u, v) \\in A \\text{ 且 } (v, w) \\in A \\}$$\n如果我们能证明对于任何 $A \\in \\text{L}$，判定 $A \\circ A$ 中成员资格的问题也属于 **L**（利用克林星号闭包的假设），我们就可以为 **PATH** 构建一个对数空间算法。\n\n你的任务是，利用 **L** 在克林星号下闭合这一事实，识别出一个对数空间算法用来判定给定对 $(u,w)$ 是否在 $A \\circ A$ 中所使用的正确方法。下列哪项正确描述了此类算法的核心？\n\nA. 算法检查字符串 $(u,w)$ 是否是语言 $(A \\cup A)^*$ 的成员。\n\nB. 算法通过遍历所有可能的中间顶点 $v \\in V$ 来直接构建语言 $A' = A \\circ A$，然后检查 $(u,w)$ 是否在 $A'$ 中。\n\nC. 算法构造语言 $A_1 = \\{ \\text{“$(x,y)\\#$”} \\mid (x,y) \\in A \\}$ 和 $A_2 = \\{ \\text{“\\#$(x,y)$”} \\mid (x,y) \\in A \\}$，形成 $L_{check} = (A_1 \\cup A_2)^*$，并检查 $L_{check}$ 是否对某个顶点 $v$ 包含了形如 “$(u,v)\\#(v,w)$” 的字符串。\n\nD. 算法非确定性地猜测一个中间顶点 $v$，然后确定性地检查 $(u,v)$ 和 $(v,w)$ 是否都在 $A$ 中。\n\nE. 算法构造语言 $A^*$，然后检查它是否包含一个字符串，其中 $(u,v)$ 和 $(v,w)$ 对某个顶点 $v$ 作为子串出现。", "solution": "给定一个语言 $A \\in \\mathrm{L}$，其字母表是顶点对 $(x,y)$ 的编码，我们想要一个确定性的对数空间过程，来判定给定的对 $(u,w)$ 是否在关系复合中：\n$$\nA \\circ A = \\{ (u,w) \\mid \\exists v \\text{ 使得 } (u,v) \\in A \\text{ 且 } (v,w) \\in A \\}.\n$$\n我们可以假设 $\\mathrm{L}$ 在克林星号下是闭合的。标准途径是利用这个假设来证明 $\\mathrm{L}$ 在一个合适的“复合”运算下也是闭合的，这进而通过重复平方（repeated squaring）的方法可以为 **PATH** 问题提供一个对数空间算法。\n\n其核心思想是将“$\\exists v$ 使得 $(u,v)\\in A$ 且 $(v,w)\\in A$”这个测试，规约为在一个可在 $\\mathrm{L}$ 中处理的星闭语言中的单个成员资格测试。为此，定义以下对数空间可识别的语言：\n- $A_{1} = \\{\\text{“$(x,y)\\#$”} \\mid \\text{“$(x,y)$”} \\in A\\}$,\n- $A_{2} = \\{\\text{“\\#$(x,y)$”} \\mid \\text{“$(x,y)$”} \\in A\\}$.\n\n由于 $A \\in \\mathrm{L}$，测试 $A_{1}$ 或 $A_{2}$ 的成员资格也在 $\\mathrm{L}$ 中：检查固定分隔符“$\\#$”在适当边界上的存在性是一个正则（因此是 $\\mathrm{L}$）检查，而剩余部分则由 $A$ 的 $\\mathrm{L}$ 判定器进行测试，同时实际上忽略该分隔符。由于 $\\mathrm{L}$ 在并集运算下是闭合的，所以 $A_{1} \\cup A_{2} \\in \\mathrm{L}$。根据假设的 $\\mathrm{L}$ 在星号运算下的闭包性，我们也有\n$$\nL_{\\mathrm{check}} = (A_{1} \\cup A_{2})^{*} \\in \\mathrm{L}.\n$$\n\n现在，要判定 $(u,w)$ 是否属于 $A \\circ A$，一个确定性对数空间图灵机可以遍历所有候选顶点 $v$，使用 $O(\\log n)$ 位来索引 $v$，并对每个 $v$ 构成短字符串\n$$\ns_{v} = \\text{“$(u,v)\\#(v,w)$”},\n$$\n之后在 $s_v$ 上调用 $L_{\\mathrm{check}}$ 的 $\\mathrm{L}$ 判定器。这可以在总共 $O(\\log n)$ 空间内完成，方法是模拟 $L_{\\mathrm{check}}$ 判定器的输入头，并根据当前的 $(u,v,w)$ 三元组即时回答其查询；在标准编码下，字符串 $s_{v}$ 的长度为 $O(\\log n)$，因此不需要超出 $O(\\log n)$ 的额外空间。\n\n正确性取决于分隔符所强制的对齐方式：$s_{v}$ 属于 $(A_{1} \\cup A_{2})^{*}$ 当且仅当它可以被分解为一串片段的连接，其中每个片段都属于 $A_{1}$ 或 $A_{2}$。因为 $s_{v}$ 以“(”开始，并且中间只包含一个“$\\#$”，唯一可行的分解方式是：一个覆盖到分隔符为止（包括分隔符）的前缀的 $A_{1}$ 片段（确保“$(u,v) \\in A$”），后跟一个覆盖从分隔符开始的后缀的 $A_{2}$ 片段（确保“$(v,w) \\in A$”）。因此，\n$$\ns_{v} \\in L_{\\mathrm{check}}\n\\;\\;\\Longleftrightarrow\\;\\;\n\\bigl((u,v) \\in A \\text{ 且 } (v,w) \\in A\\bigr).\n$$\n所以，\n$$\n(u,w) \\in A \\circ A\n\\;\\;\\Longleftrightarrow\\;\\;\n\\exists v \\text{ 使得 } s_{v} \\in L_{\\mathrm{check}}.\n$$\n在 $O(\\log n)$ 空间内枚举 $v$ 并调用 $L_{\\mathrm{check}}$ 的 $\\mathrm{L}$ 判定器，就产生了一个确定性对数空间算法。这正是选项 C 中描述的构造方法：构建 $A_{1}$ 和 $A_{2}$，利用星闭包假设形成 $L_{\\mathrm{check}} = (A_{1} \\cup A_{2})^{*}$，并检查是否存在 $v$ 使得“$(u,v)\\#(v,w)$”在 $L_{\\mathrm{check}}$ 中。其他选项要么没有以要求的方式利用星闭包（A、B、E），要么本质上是非确定性的（D），因此没有体现“在星闭包下的对数空间”方法。", "answer": "$$\\boxed{C}$$", "id": "1448429"}]}