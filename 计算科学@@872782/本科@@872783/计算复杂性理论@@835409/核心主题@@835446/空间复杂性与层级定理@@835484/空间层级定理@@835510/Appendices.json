{"hands_on_practices": [{"introduction": "掌握空间层次定理的第一步是能够熟练地应用其所有前提条件。这个练习提供了一个绝佳的起点，它要求我们比较两个增长速度非常接近的函数：$f(n) = n \\cdot \\log^* n$ 和 $g(n) = n \\cdot \\log n$。通过解决这个问题 [@problem_id:1463181]，你将练习检验空间可构造性、对数下界以及关键的“小o”渐进关系，这对于理解定理的适用范围至关重要。", "problem": "在计算复杂性理论中，空间层次定理（Space Hierarchy Theorem）是一个基本结果，它表明图灵机拥有更多空间就能解决更多问题。该定理的一个常见表述如下：\n\n*   **空间层次定理：** 设 $f(n)$ 和 $g(n)$ 是两个空间可构造函数，其中对于所有足够大的 $n$，$f(n) \\geq \\log n$。如果 $f(n) \\in o(g(n))$，则 $SPACE(f(n)) \\subsetneq SPACE(g(n))$ 成立。\n\n一个函数 $s(n)$ 被定义为**空间可构造的** (space-constructible)，如果存在一台图灵机，对于任意长度为 $n$ 的输入，它可以在 $O(s(n))$ 的空间内计算出 $s(n)$ 的值。在本题中，假设所有对数，包括迭代对数函数（$\\log^* n$）中的对数，都以 2 为底。\n\n考虑函数 $f(n) = n \\cdot \\log^* n$ 和 $g(n) = n \\cdot \\log n$。我们希望使用上述空间层次定理来确定复杂性类 $SPACE(f(n))$ 是否是类 $SPACE(g(n))$ 的真子集。\n\n下列哪个陈述正确地评估了该定理在此目的下的适用性？\n\nA. 该定理适用。$f(n)$ 和 $g(n)$ 都是空间可构造的，并且条件 $f(n) \\in o(g(n))$ 得到满足。\n\nB. 该定理不适用，因为 $g(n) = n \\cdot \\log n$ 不是一个空间可构造函数。\n\nC. 该定理不适用，因为 $f(n) = n \\cdot \\log^* n$ 不是一个空间可构造函数，因为 $\\log^* n$ 项极其缓慢的增长妨碍了在要求的空间界限内进行计算。\n\nD. 该定理不适用，因为条件 $f(n) \\in o(g(n))$ 未被满足。\n\nE. 该定理不适用，因为条件 $f(n) \\geq \\log n$ 对于所有足够大的 $n$ 都不满足。", "solution": "要确定空间层次定理是否可用于证明 $SPACE(n \\cdot \\log^* n) \\subsetneq SPACE(n \\cdot \\log n)$，我们必须验证该定理的所有前提条件对于 $f(n) = n \\cdot \\log^* n$ 和 $g(n) = n \\cdot \\log n$ 是否都满足。\n\n该定理有三个条件需要检查：\n1.  $f(n)$ 和 $g(n)$ 必须是空间可构造的。\n2.  对于所有足够大的 $n$，$f(n) \\geq \\log n$。\n3.  $f(n) \\in o(g(n))$。\n\n让我们逐步检查每个条件。\n\n**条件3：检查是否 $f(n) \\in o(g(n))$**\n\n小o符号 $f(n) \\in o(g(n))$ 意味着 $\\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = 0$。\n我们来计算这个极限：\n$$ \\lim_{n \\to \\infty} \\frac{f(n)}{g(n)} = \\lim_{n \\to \\infty} \\frac{n \\cdot \\log^* n}{n \\cdot \\log n} = \\lim_{n \\to \\infty} \\frac{\\log^* n}{\\log n} $$\n迭代对数函数 $\\log^* n$ 增长得极其缓慢。例如，$\\log^* (2^{65536}) = 5$。相比之下，对数函数 $\\log n$ 增长得快得多（尽管与多项式函数相比仍然很慢）。因为分母 $\\log n$ 无界增长，而分子 $\\log^* n$ 增长得慢得多，所以它们比值的极限为零。\n$$ \\lim_{n \\to \\infty} \\frac{\\log^* n}{\\log n} = 0 $$\n因此，条件 $f(n) \\in o(g(n))$ 得到满足。这排除了选项D。\n\n**条件2：检查是否 $f(n) \\geq \\log n$**\n\n我们需要检查是否对于所有足够大的 $n$，$n \\cdot \\log^* n \\geq \\log n$。\n对于 $n > 2$，我们有 $n > \\log n$。\n同样，对于 $n \\geq 2$，$\\log^* n \\geq 1$。\n因此，对于 $n > 2$，我们可以写出：\n$$ n \\cdot \\log^* n \\geq n \\cdot 1 = n > \\log n $$\n所以，条件 $f(n) \\geq \\log n$ 对所有 $n > 2$ 成立。这排除了选项E。\n\n**条件1：检查 $f(n)$ 和 $g(n)$ 是否是空间可构造的**\n\n如果一个函数 $s(n)$ 的值可以在 $O(s(n))$ 空间内计算出来，那么它就是空间可构造的。\n\n首先，我们来考虑 $g(n) = n \\cdot \\log n$。\n给定一个长度为 $n$ 的输入来计算 $g(n)$：\n1.  计算输入长度得到 $n$。这需要 $O(\\log n)$ 的空间来存储 $n$ 的二进制表示。\n2.  计算 $\\log n$。这可以使用在输入数字大小上为多项式空间的算法来完成，即对于某个小整数 $k$，$O((\\log n)^k)$。例如，$O((\\log n)^2)$ 是一个已知的界。\n3.  将 $n$ 与计算出的 $\\log n$ 相乘。这也需要 $n$ 的多对数空间。\n计算数值 $n \\log n$ 所需的总空间为 $O((\\log n)^k)$，其中 $k$ 是某个常数。我们必须检查这是否在 $O(g(n))$ 内。\n由于 $(\\log n)^k \\in o(n \\log n)$，用于计算的空间远在 $O(n \\log n)$ 的界限内。因此，$g(n) = n \\cdot \\log n$ 是空间可构造的。这排除了选项B。\n\n接下来，我们考虑 $f(n) = n \\cdot \\log^* n$。这是关键部分。\n给定一个长度为 $n$ 的输入来计算 $f(n)$：\n1.  计算输入长度得到 $n$，使用 $O(\\log n)$ 空间。\n2.  计算 $\\log^* n$。这可以通过以下迭代算法完成：\n    初始化一个计数器 `c = 0`。\n    初始化一个值 `v = n`。\n    当 `v > 1` 时：\n        设置 $v \\leftarrow \\log_2(v)$。\n        增加 `c`。\n    结果是 `c`。\n    这个子程序的空间复杂度取决于存储 `v` 和计算其对数所需的空间。存储的最大值是 $n$。计算 $\\log_2(v)$ 的空间在第一步（$v=n$）时最大。这一步需要 $O((\\log n)^2)$ 的空间。后续步骤需要的空间逐渐减少。计数器 `c` 的空间可以忽略不计 ($O(\\log(\\log^* n))$)。因此，计算 $\\log^* n$ 值的总空间是 $O((\\log n)^2)$。\n3.  将 $n$ 与计算出的 $\\log^* n$ 的值相乘。同样，这需要多对数空间。\n计算数值 $n \\log^* n$ 的总空间主要由对数计算决定，所以是 $O((\\log n)^2)$。\n我们必须检查这是否在 $O(f(n))$ 内。$(\\log n)^2 \\in O(n \\log^* n)$ 吗？是的，因为任何多对数函数的增长速度都慢于任何形式为 $n \\cdot p(n)$ 的函数，其中 $p(n)$ 是一个正的、非递减的函数。\n由于数值 $n \\log^* n$ 可以在 $O((\\log n)^2)$ 空间内计算，并且 $(\\log n)^2 \\in o(n \\log^* n)$，所以函数 $f(n) = n \\cdot \\log^* n$ 是空间可构造的。这排除了选项C。\n\n**结论**\n空间层次定理的全部三个条件都得到满足：\n1.  $f(n) = n \\cdot \\log^* n$ 和 $g(n) = n \\cdot \\log n$ 都是空间可构造的。\n2.  对于足够大的 $n$，$f(n) \\geq \\log n$。\n3.  $f(n) \\in o(g(n))$。\n\n因此，该定理可以被应用来得出结论 $SPACE(n \\cdot \\log^* n) \\subsetneq SPACE(n \\cdot \\log n)$。正确的推理在选项A中描述。", "answer": "$$\\boxed{A}$$", "id": "1463181"}, {"introduction": "一个常见的误解是，只要给予更多的空间，无论多少，都能解决更多的问题。这个练习 [@problem_id:1463147] 旨在纠正这一误区，它通过一个反例来挑战我们对空间层次定理的理解。通过分析 $SPACE(n^k)$ 和 $SPACE(n^k + n^{k-1}\\log(n))$，你将深刻体会到定理中“小o”条件的严格性——空间的增长必须是“渐进显著的”，而不仅仅是增加一个低阶项。", "problem": "空间层次定理是计算复杂性理论中的一个基本结果，它确立了空间复杂性类的层次结构。该定理阐述如下：\n对于任何空间可构造函数 $s_2(n)$，如果 $s_1(n)$ 是另一个空间可构造函数，使得 $s_1(n) \\in o(s_2(n))$，那么 $SPACE(s_1(n)) \\subsetneq SPACE(s_2(n))$。\n小o符号，$s_1(n) \\in o(s_2(n))$，意味着函数 $s_1(n)$ 渐近小于 $s_2(n)$，其形式化定义为 $\\lim_{n \\to \\infty} \\frac{s_1(n)}{s_2(n)} = 0$。一个函数 $f(n)$ 是空间可构造的，如果一台图灵机可以在长度为 $n$ 的输入上，在 $O(f(n))$ 的空间内计算出 $f(n)$。你可以假设下面出现的所有函数都是空间可构造的。\n\n考虑复杂性类 $C_1 = SPACE(n^k)$ 和 $C_2 = SPACE(n^k + n^{k-1}\\log(n))$，其中 $k \\ge 1$ 是一个固定的整数。一名学生声称，因为项 $n^{k-1}\\log(n)$ 的增长速度慢于 $n^k$，所以空间层次定理不能用来证明 $C_1$ 是 $C_2$ 的真子集。\n\n这名学生的说法正确吗？\n\nA. 是，因为 $\\lim_{n \\to \\infty} \\frac{n^k}{n^k + n^{k-1}\\log(n)} = 1$。\n\nB. 否，因为 $\\lim_{n \\to \\infty} \\frac{n^k}{n^k + n^{k-1}\\log(n)} = 0$。\n\nC. 是，因为 $n^k$ 和 $n^k + n^{k-1}\\log(n)$ 不是空间可构造的。\n\nD. 否，因为只要函数不相同，空间层次定理就适用。", "solution": "我们应用空间层次定理，该定理要求 $s_{1}(n) \\in o(s_{2}(n))$，即\n$$\n\\lim_{n\\to\\infty}\\frac{s_{1}(n)}{s_{2}(n)}=0.\n$$\n令 $s_{1}(n)=n^{k}$ 且 $s_{2}(n)=n^{k}+n^{k-1}\\log(n)$。计算\n$$\n\\lim_{n\\to\\infty}\\frac{n^{k}}{n^{k}+n^{k-1}\\log(n)}=\\lim_{n\\to\\infty}\\frac{1}{1+\\frac{\\log(n)}{n}}=1,\n$$\n因为 $\\lim_{n\\to\\infty}\\frac{\\log(n)}{n}=0$。因此 $n^{k}\\notin o\\!\\left(n^{k}+n^{k-1}\\log(n)\\right)$，所以空间层次定理的假设不成立，该定理不能用于得出 $SPACE(n^{k})\\subsetneq SPACE(n^{k}+n^{k-1}\\log(n))$ 的结论。\n\n此外，由于对于足够大的 $n$，我们有 $\\log(n)\\leq n$，因此\n$$\nn^{k}\\leq n^{k}+n^{k-1}\\log(n)\\leq n^{k}+n^{k}=2n^{k},\n$$\n所以 $O\\!\\left(n^{k}+n^{k-1}\\log(n)\\right)=O\\!\\left(n^{k}\\right)$，因此 $SPACE(n^{k})=SPACE(n^{k}+n^{k-1}\\log(n))$。这进一步证实了空间层次定理在此处不适用。\n\n因此，该学生关于定理不能用于证明真子集关系的说法是正确的，原因在于比率的极限是 $1$，而不是 $0$。正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1463147"}, {"introduction": "空间层次定理不仅是一个理论工具，它还能揭示计算复杂性谱系中一些最基本和最重要的结构。这个练习 [@problem_id:1463176] 将引导你应用该定理来证明关于对数空间类 L ($L = DSPACE(O(\\log n))$) 的一个根本性结论。你将看到，即使在计算资源极其有限的对数空间尺度上，一个无限精细的层次结构依然存在，这表明更多的空间总是意味着更强的计算能力。", "problem": "在计算复杂性理论中，确定性空间层级定理提供了一种方法，用于证明基于图灵机允许使用的内存（空间）量存在一个严格的复杂性类层级。该定理的一个版本可以表述如下：\n\n**定理（空间层级）：** 对于任何满足 $f(n) \\ge \\log_2 n$ 的空间可构造函数 $f(n)$，我们有 $\\text{DSPACE}(o(f(n))) \\subsetneq \\text{DSPACE}(O(f(n)))$。这意味着存在可以用 $O(f(n))$ 空间解决但无法用 $o(f(n))$ 空间解决的问题。\n\n一个函数 $f: \\mathbb{N} \\to \\mathbb{N}$ 被称为 **空间可构造的** (space-constructible)，如果存在一个确定性图灵机，在给定长度为 $n$ 的输入时，在其工作带上使用恰好 $O(f(n))$ 的空间来计算并输出 $f(n)$ 的值。\n\n让我们考虑对数空间复杂性类 L，其形式化定义为 $\\text{L} = \\text{DSPACE}(O(\\log n))$。现在，考虑函数 $s(n) = \\lceil \\log_2 n \\rceil$。\n\n以下哪个陈述是通过使用函数 $s(n)$ 应用空间层级定理得出的最准确的结论？\n\nA. 函数 $s(n)$ 是空间可构造的，并且满足 $s(n) \\ge \\log_2 n$。该定理意味着对于任何函数 $g(n)$，如果 $g(n) = o(\\log n)$，则复杂性类 $\\text{DSPACE}(g(n))$ 是 L 的一个真子集。\n\nB. 函数 $s(n)$ 不是空间可构造的，因为计算对数是一个复杂的数学运算，需要超过对数的空间。因此，空间层级定理不能应用于 $s(n)$。\n\nC. 该定理可以应用，并且它表明对于任何满足 $0 \\le c  1$ 的常数 $c$，复杂性类 $\\text{DSPACE}(c \\cdot \\log n)$ 是 L 的一个真子集。\n\nD. 该定理不能应用，因为对于所有是2的整数次幂的 $n$ 值，函数 $s(n)$ 违反了条件 $s(n) \\ge \\log_2 n$。\n\nE. 该定理可以应用，并且它证明了 L 是 P（可在多项式时间内解决的问题类）的一个真子集。", "solution": "我们已知确定性空间层级定理：对于任何满足 $f(n) \\ge \\log_{2} n$ 的空间可构造函数 $f(n)$，我们有\n$$\n\\text{DSPACE}(o(f(n))) \\subsetneq \\text{DSPACE}(O(f(n))).\n$$\n我们考虑 $s(n) = \\lceil \\log_{2} n \\rceil$ 和复杂性类 $\\text{L} = \\text{DSPACE}(O(\\log n))$。\n\n第一步：验证 $s(n)$ 是空间可构造的，并且满足下界条件。\n- 根据定义，$s(n) = \\lceil \\log_{2} n \\rceil$ 对所有 $n \\in \\mathbb{N}$ 满足\n$$\ns(n) = \\lceil \\log_{2} n \\rceil \\ge \\log_{2} n\n$$\n- 为证明 $s(n)$ 是空间可构造的，我们描述如何在长度为 $n$ 的输入上，在 $O(\\log n)$ 空间内计算 $s(n)$：\n  1. 通过扫描输入并维护一个二进制计数器，以二进制形式计算 $n$。这使用 $O(\\log n)$ 个单元。\n  2. 令 $L$ 为 $n$ 的二进制位数；对于 $n \\ge 1$，这等于 $L = \\lfloor \\log_{2} n \\rfloor + 1$。我们可以通过在增加计数器时跟踪最高有效位的位置来计算 $L$，使用 $O(\\log n)$ 空间。\n  3. 通过检查二进制表示是否只有一个 1 位来测试 $n$ 是否是 2 的幂；计算 1 的位数使用 $O(\\log n)$ 空间。\n  4. 如下输出 $s(n)$：\n     - 如果 $n$ 是 2 的幂，则 $s(n) = \\lceil \\log_{2} n \\rceil = \\log_{2} n = L - 1$。\n     - 否则，$s(n) = \\lceil \\log_{2} n \\rceil = L$。\n  所有步骤都使用 $O(\\log n)$ 空间，因此 $s(n)$ 是空间可构造的。\n\n第二步：将空间层级定理应用于 $f(n) = s(n)$。\n- 该定理得出\n$$\n\\text{DSPACE}(o(s(n))) \\subsetneq \\text{DSPACE}(O(s(n))).\n$$\n- 由于 $s(n) = \\Theta(\\log_{2} n)$，我们有 $O(s(n)) = O(\\log_{2} n)$ 和 $o(s(n)) = o(\\log_{2} n)$。\n- 因此，\n$$\n\\text{DSPACE}(o(\\log_{2} n)) \\subsetneq \\text{DSPACE}(O(\\log_{2} n)) = \\text{L}.\n$$\n- 具体来说，对于任何满足 $g(n) = o(\\log_{2} n)$ 的函数 $g(n)$，我们有\n$$\n\\text{DSPACE}(g(n)) \\subseteq \\text{DSPACE}(o(\\log_{2} n)) \\subsetneq \\text{L}.\n$$\n\n第三步：评估选项。\n- A 选项陈述了对于所有 $g(n) = o(\\log n)$，都有严格包含关系 $\\text{DSPACE}(g(n)) \\subsetneq \\text{L}$，这可以从上述推导中得出。因此 A 是正确的。\n- B 是错误的，因为如上所示，$s(n)$ 是空间可构造的。\n- C 不能由该定理推出：对于任何满足 $0 \\le c  1$ 的固定常数 $c$，我们有 $c \\log n = \\Theta(\\log n)$，所以 $\\text{DSPACE}(c \\cdot \\log n) = \\text{DSPACE}(O(\\log n)) = \\text{L}$；该定理分离的是 $o(\\log n)$ 和 $O(\\log n)$，而不是 $\\Theta(\\log n)$ 内部的常数因子。\n- D 是错误的，因为当 $n$ 是 2 的幂时，$s(n) = \\lceil \\log_{2} n \\rceil \\ge \\log_{2} n$ 等式成立。\n- E 是错误的，因为该定理并不意味着 $\\text{L} \\subsetneq \\text{P}$；事实上，$\\text{L} \\subsetneq \\text{P}$ 是否成立是未知的。\n\n因此，最准确的结论是 A。", "answer": "$$\\boxed{A}$$", "id": "1463176"}]}