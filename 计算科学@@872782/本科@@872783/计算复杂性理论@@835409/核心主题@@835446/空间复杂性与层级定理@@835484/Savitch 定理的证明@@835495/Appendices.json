{"hands_on_practices": [{"introduction": "在深入研究萨维奇定理的递归算法之前，我们必须首先理解其操作的基本对象：格局（configurations）。本练习将引导您计算一个非确定性图灵机可能存在的格局总数，这是量化问题搜索空间、理解最终复杂度界限中 $S(n)$ 项来源的关键一步。", "problem": "在计算复杂性理论的研究中，理解抽象机的资源使用是基础。考虑一个单带非确定性图灵机 (NTM)。这样一台机器在任何时刻的构型都由三个部分完全描述：其当前的内部状态、其工作带上写入的全部内容以及其磁头的当前位置。\n\n设该 NTM 有一个状态集 $Q$ 和一个带字母表 $\\Sigma$。该机器被设计为对于大小为 $s$ 的输入，其空间复杂度为 $f(s) = c \\log_2 s$，其中 $c$ 是一个正实数常数。这意味着对于任何大小为 $s$ 的输入，该机器在其工作带上最多使用 $f(s)$ 个单元格。\n\n推导此 NTM 可能处于的不同构型的最大数量的简化、明确公式。将你的答案表示为状态数 $|Q|$、带字母表大小 $|\\Sigma|$、常数 $c$ 和输入大小 $s$ 的函数。", "solution": "一个构型由以下几点确定：\n- 当前的内部状态（选择数：$|Q|$），\n- 在可能使用的单元格上的工作带全部内容（最多 $f(s)$ 个单元格中的每一个都可以包含 $|\\Sigma|$ 个符号中的任意一个，从而产生 $|\\Sigma|^{f(s)}$ 种可能性），\n- 工作带上的磁头位置（最多 $f(s)$ 种选择）。\n\n因此，由空间限制所允许的不同构型的最大数量为\n$$\nN_{\\max}(s)=|Q|\\cdot f(s)\\cdot |\\Sigma|^{f(s)}.\n$$\n当 $f(s)=c\\log_{2}(s)$ 时，这变成\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot |\\Sigma|^{c\\log_{2}(s)}.\n$$\n使用恒等式 $a^{\\log_{b}(x)}=x^{\\log_{b}(a)}$，其中 $a=|\\Sigma|$ 且 $b=2$，我们简化\n$$\n|\\Sigma|^{c\\log_{2}(s)}=s^{c\\log_{2}(|\\Sigma|)}.\n$$\n因此，一个明确的简化表达式是\n$$\nN_{\\max}(s)=|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}.\n$$", "answer": "$$\\boxed{|Q|\\cdot c\\log_{2}(s)\\cdot s^{c\\log_{2}(|\\Sigma|)}}$$", "id": "1437894"}, {"introduction": "萨维奇定理的标准证明依赖于将计算路径递归地划分为两半。本练习挑战您探索该算法的一个变体，该变体将路径分成三个部分。通过分析这种修改后的方法 [@problem_id:1437849]，您将更深刻地理解为什么空间复杂度是二次的，并证实该结果是“分而治之”策略的一个稳健特性，而不仅仅是二分法的人为产物。", "problem": "在计算复杂性理论中，萨维奇定理证明了，任何一个能被非确定性图灵机 (NTM) 在一定空间内解决的问题，也能被确定性图灵机 (DTM) 在一个二次方大的空间内解决。具体来说，该定理表明对于任何空间可构造函数 $S(n) \\ge \\log n$，都有 `NSPACE(S(n)) ⊆ DSPACE(S(n)^2)`。\n\n其证明依赖于一个递归算法，用于判断在 NTM 的计算图中，一个格局 $c_2$ 是否可以从一个格局 $c_1$ 到达。设对于大小为 $n$ 的输入，NTM 的最大格局数为 $N$。标准算法，我们称之为 `CAN-REACH(c_start, c_end, k)`，检查是否存在一条从 `c_start` 到 `c_end` 的长度至多为 $2^k$ 的路径。对于 $k>0$，该算法通过遍历所有可能的中间格局 $c_{mid}$，并递归地检查是否存在从 `c_start`到 $c_{mid}$ 和从 $c_{mid}$ 到 `c_end` 的路径，这两条路径的长度都至多为 $2^{k-1}$。这种对路径的二分法导致了 $O(S(n)^2)$ 的空间复杂度结果，因为递归深度为 $O(\\log N)$，而存储一个格局需要 $O(S(n))$ 的空间，其中 $\\log N$ 与 $S(n)$ 成正比。\n\n现在，考虑一个修改后的递归算法 `TRI-REACH(c_start, c_end, i)`，它被设计用来解决同样的可达性问题。这个新算法检查是否存在一条长度至多为 $3^i$ 的路径。对于 $i>0$，`TRI-REACH` 通过遍历所有可能的中间格局对 $(c_{mid1}, c_{mid2})$，并递归地验证以下三个子问题来工作：\n1. 存在一条从 $c_{start}$ 到 $c_{mid1}$ 的路径，其长度至多为 $3^{i-1}$。\n2. 存在一条从 $c_{mid1}$ 到 $c_{mid2}$ 的路径，其长度至多为 $3^{i-1}$。\n3. 存在一条从 $c_{mid2}$ 到 $c_{end}$ 的路径，其长度至多为 $3^{i-1}$。\n\n如果对于某个格局对 $(c_{mid1}, c_{mid2})$，所有三个递归检查都成功，则该算法返回真。否则，返回假。假设一台 DTM 使用这个 `TRI-REACH` 算法来模拟一台空间复杂度为 $S(n)$ 的 NTM。那么这次模拟的空间复杂度是多少，请用关于 $S(n)$ 的大O符号表示？", "solution": "设 $S(n)$ 是 NTM 的空间界限， $N$ 是在大小为 $n$ 的输入上不同格局的数量。对于一台固定的机器，存在一个常数 $\\alpha>1$ 使得\n$$\nN \\le \\alpha^{S(n)} \\cdot \\operatorname{poly}(n),\n$$\n因此，根据假设 $S(n) \\ge \\log_{2} n$，我们有\n$$\n\\log_{2} N = \\Theta(S(n)),\n$$\n\n过程 $\\operatorname{TRI\\mbox{-}REACH}(c_{\\text{start}},c_{\\text{end}},i)$ 判定长度至多为 $3^{i}$ 的路径内的可达性。要覆盖所有可能的路径，只需取\n$$\ni^{\\ast}=\\lceil \\log_{3} N \\rceil,\n$$\n所以递归深度为\n$$\nd = i^{\\ast} = \\Theta(\\log_{3} N) = \\Theta(\\log_{2} N).\n$$\n\n在任何递归层级，DTM 都必须存储：\n- 该次调用的参数 $c_{\\text{start}}$ 和 $c_{\\text{end}}$。\n- 编码当前格局对 $(c_{\\text{mid1}},c_{\\text{mid2}})$ 的循环变量。\n- 层级参数 $i$。\n\n每个格局需要 $O(S(n))$ 的空间来表示，存储循环索引的成本为 $O(\\log_{2} N)=O(S(n))$ 比特，而这被存储常数个格局的空间所主导。因此，每个递归层级的空间是\n$$\nO(S(n)).\n$$\n\n因为递归子调用是深度优先且顺序执行的，所以总空间是每层空间与递归深度的乘积：\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot \\log_{3} N\\big).\n$$\n使用 $\\log_{3} N = \\frac{\\log_{2} N}{\\log_{2} 3} = \\Theta(\\log_{2} N)$ 以及 $\\log_{2} N = \\Theta(S(n))$，我们得到\n$$\n\\text{Space}(n) = O\\big(S(n) \\cdot S(n)\\big) = O\\big(S(n)^{2}\\big).\n$$\n\n因此，尽管将路径分成了三段并遍历了中间格局对，其渐近空间复杂度与萨维奇的原始算法相比，在常数因子范围内保持不变。", "answer": "$$\\boxed{O\\!\\left(S(n)^{2}\\right)}$$", "id": "1437849"}, {"introduction": "萨维奇定理证明了确定性机器可以*判定*是否存在一条接受路径。这个实践问题将概念向前推进了一步，要求您分析一个不仅能判定，还能*构造*并输出实际接受路径的算法。这展示了如何将同样的空间高效递归技术应用于搜索问题，凸显了其 underlying 原理的强大功能和通用性 [@problem_id:1437882]。", "problem": "考虑一台非确定性图灵机 (NTM)，它在长度为 $n$ 的输入上最多使用 $S(n)$ 的空间，其中 $S(n) \\ge \\log n$。这台 NTM 的一个格局（configuration）可以通过其有限控制器的状态、工作带的内容以及磁头的位置来描述。存储一个格局所需的总大小为 $O(S(n))$。\n\n萨维奇定理提供了一个确定性算法来判断一台 NTM 是否接受一个输入。该证明的核心是一个递归函数，我们称之为 `REACH(c1, c2, k)`，它用于确定格局 `c2` 是否可以在最多 $2^k$ 步内从格局 `c1` 到达。\n- 当 $k=0$ 时，它检查 `c1 = c2`，或者 `c1` 是否可以在单步转移中得到 `c2`。\n- 当 $k>0$ 时，它遍历所有可能的中间格局 `cm`，并递归地检查 `REACH(c1, cm, k-1)` 和 `REACH(cm, c2, k-1)` 是否都为真。\n最大递归深度 $k$ 被选择为 $O(S(n))$，这个 `REACH` 算法可以在一台确定性图灵机上使用 $O(S(n)^2)$ 的空间实现。\n\n现在，让我们考虑一个修改后的任务：不仅仅是判断可达性，而是实际输出一条完整的接受计算路径（一个从起始格局 $c_{start}$ 到接受格局 $c_{accept}$ 的格局序列），每次打印一个格局。\n\n为了解决这个问题，提出了一个算法 `FINDPATH(c_start, c_accept)`。它的操作如下：\n1. 它首先通过调用 `REACH(c_start, c_accept, k_max)` 来验证 $c_{accept}$ 是否可以从 $c_{start}$ 到达，其中 $k_{max}$ 的数量级为 $S(n)$。如果不可达，算法终止。\n2. 如果路径存在，它打印起始格局 $c_{start}$。\n3. 然后它调用一个递归辅助过程 `GENERATE_PATH(c_1, c_2, k)`。初始调用为 `GENERATE_PATH(c_start, c_accept, k_max)`。\n4. `GENERATE_PATH(c_1, c_2, k)` 过程的设计目的是打印路径段的剩余部分，即从紧跟 $c_1$ 之后的格局直到并包括 $c_2$ 的所有路径上的格局。其逻辑如下：\n    - 如果 $c_1$ 与 $c_2$ 相同，它立即返回。\n    - 如果 $k=0$，这意味着 $c_2$ 在单步之后紧跟 $c_1$。该过程打印 $c_2$ 并返回。\n    - 如果 $k>0$，它通过遍历所有可能性来搜索一个中间格局 $c_m$。对于找到的第一个使得 `REACH(c_1, c_m, k-1)` 和 `REACH(c_m, c_2, k-1)` 都返回真的 $c_m$，它执行两个顺序的递归调用：`GENERATE_PATH(c_1, c_m, k-1)` 后跟 `GENERATE_PATH(c_m, c_2, k-1)`。在这些调用之后，它停止搜索中间点并返回。\n\n整个 `FINDPATH` 算法关于 $S(n)$ 的最紧渐近（大O）空间复杂度是多少？\n\nA. $O(S(n))$\n\nB. $O(S(n) \\log S(n))$\n\nC. $O(S(n)^2)$\n\nD. $O(S(n)^3)$\n\nE. $O(S(n) \\cdot 2^{S(n)})$", "solution": "问题要求 `FINDPATH` 算法的空间复杂度。我们分析该算法的组成部分及其空间需求。\n\n`FINDPATH` 算法包含三个主要步骤：\n1. 对 `REACH(c_start, c_accept, k_max)` 的单次调用。\n2. 打印起始格局 $c_{start}$。\n3. 对 `GENERATE_PATH(c_start, c_accept, k_max)` 的单次调用。\n\n由于这些步骤是顺序执行的，总空间复杂度将是任何一个步骤所使用的最大空间。\n\n步骤 1：`REACH` 的空间。\n问题描述中指出，最大递归深度为 $k_{max} = O(S(n))$ 的标准 `REACH` 算法使用 $O(S(n)^2)$ 的空间。这是萨维奇定理证明中的一个已知结果。`REACH(c1, c2, k)` 的空间复杂度是 $O(k \\cdot S(n))$。当 $k = k_{max} = O(S(n))$ 时，空间为 $O(S(n) \\cdot S(n)) = O(S(n)^2)$。\n\n步骤 2：打印的空间。\n打印单个格局 $c_{start}$ 需要将该格局保存在内存中，这需要 $O(S(n))$ 的空间。这小于步骤 1 的空间。\n\n步骤 3：`GENERATE_PATH` 的空间。\n这是分析中最复杂的部分。我们将 `GENERATE_PATH` 表示为 `GP`。我们需要确定 `GP(c1, c2, k)` 的空间复杂度。\n\n令 `Space_GP(k)` 为递归参数为 k 的 `GP` 调用所需的空间。\n`GP(c1, c2, k)` 的单个激活帧需要存储其参数（`c1`、`c2`、`k`）和局部变量（循环变量 `cm`）。存储两个格局和一个整数需要 $O(S(n)) + O(S(n)) + O(\\log k)$ 的空间。由于 $k=O(S(n))$ 且 $S(n) \\ge \\log n$，这可以简化为 $O(S(n))$。\n\n在 `GP(k)` 内部，算法顺序执行几个操作：\na. 它遍历 `cm`，这需要 $O(S(n))$ 的空间来存储当前的 `cm`。\nb. 对于每个 `cm`，它调用 `REACH(c1, cm, k-1)`。此调用的空间是 $O((k-1)S(n))$。\nc. 然后它调用 `REACH(cm, c2, k-1)`。空间也是 $O((k-1)S(n))$，并且重用前一个 `REACH` 调用的空间。\nd. 如果两个 `REACH` 调用都成功，它会进行两次递归调用：`GP(c1, cm, k-1)` 和 `GP(cm, c2, k-1)`。这些调用也是顺序的，所以它们重用空间。\n\n`GP(k)` 的空间复杂度可以用一个递推关系来描述。总空间是当前帧的空间加上其任何顺序子过程所使用的最大空间。\n`Space_GP(k) = O(S(n)) + max(Space_REACH(k-1), Space_GP(k-1))`\n其中 `Space_REACH(k-1)` 是 `REACH` 调用的空间，即 $O((k-1)S(n))$。\n所以，`Space_GP(k) = O(S(n)) + max(O((k-1)S(n)), Space_GP(k-1))`。\n\n让我们通过考虑完整的调用栈来分析总空间使用情况。一次对 `GP(k_max)` 的调用可以导致一连串的递归调用：`GP(k_max) \\to GP(k_max-1) \\to \\dots \\to GP(0)`。这个递归的最大深度是 $k_{max}$。\n\n考虑执行位于调用 `GP(j)` 内部的时刻，该调用是由调用链 `GP(k_{max}) \\to \\dots \\to GP(j+1)` 所调用的。\n在这一点上，调用栈上有 $(k_{max} - j + 1)$ 个 `GP` 的激活帧。每个帧占用 $O(S(n))$ 的空间。所以 `GP` 帧的栈占用了 $(k_{max} - j + 1) \\cdot O(S(n))$ 的空间。\n\n在执行 `GP(j)` 时，算法调用 `REACH(j-1)`。这个调用需要它自己的栈空间，即 $O((j-1)S(n))$。这个空间是在现有调用栈的顶部动态分配的。\n此时使用的总空间是 `GP` 调用栈的空间和 `REACH` 调用空间的总和：\n`TotalSpace(j) = (k_{max} - j + 1) \\cdot O(S(n)) + O((j-1)S(n))`\n\n让我们找到这个函数在 $j \\in \\{1, \\dots, k_{max}\\}$ 时的最大值。设 $C_1$ 和 $C_2$ 是大O表示法中的常数。\n`TotalSpace(j) \\approx C_1(k_{max} - j + 1)S(n) + C_2(j - 1)S(n)`\n`TotalSpace(j) \\approx (C_1 k_{max} + C_1 - C_2) S(n) + (C_2 - C_1)j S(n)`\n这是一个关于 j 的线性函数。最大值必定出现在定义域的边界，即在 $j=1$ 或 $j=k_{max}$ 处。\n\n- 当 $j=k_{max}$ 时：`GP` 栈很浅（深度为1）。调用是 `GP(k_{max})`，它会调用 `REACH(k_{max}-1)`。\n`TotalSpace(k_{max}) = O(S(n)) + O((k_{max}-1)S(n)) = O(k_{max} S(n))`。\n\n- 当 $j=1$ 时：`GP` 栈很深（深度为 $k_{max}$）。调用是 `GP(1)`，它会调用 `REACH(0)`。\n`TotalSpace(1) = k_{max} \\cdot O(S(n)) + O(0 \\cdot S(n)) = O(k_{max} S(n))`。\n\n在这两种情况下，以及对于其间的所有 j，总空间复杂度都受限于 $O(k_{max} S(n))$。\n因为 $k_{max} = O(S(n))$，所以 `GENERATE_PATH` 过程的空间复杂度是 $O(S(n) \\cdot S(n)) = O(S(n)^2)$。\n\n结论：\n- 步骤 1 (`REACH`) 的空间：$O(S(n)^2)$。\n- 步骤 3 (`GENERATE_PATH`) 的空间：$O(S(n)^2)$。\n\n`FINDPATH` 的总体空间复杂度是其顺序步骤中使用的空间的最大值，即 $\\max(O(S(n)^2), O(S(n)^2)) = O(S(n)^2)$。该算法成功地重构并打印了路径，而没有使用指数级的空间，因为它是在运行中重新生成路径段，而不是存储它们。空间复杂度与原始的判定算法保持相同。\n\n因此，最紧的渐近空间复杂度是 $O(S(n)^2)$。这与选项 C 相符。", "answer": "$$\\boxed{C}$$", "id": "1437882"}]}