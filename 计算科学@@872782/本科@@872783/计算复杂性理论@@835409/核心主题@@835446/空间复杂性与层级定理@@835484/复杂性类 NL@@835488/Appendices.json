{"hands_on_practices": [{"introduction": "这个练习为一个基础图论问题（检查连通性）提供了一个具体的算法。通过分析这种非确定性方法的内存需求，你将亲身体验如何计算对数空间复杂度，这是复杂度类 NL 的决定性特征。这个实践 [@problem_id:1453163] 对于建立“非确定性如何用极小的内存解决问题”的直觉至关重要。", "problem": "一个大规模的分布式数据存储网络被建模为一个无向图 $G=(V, E)$，其中顶点集合 $V$ 代表 $n$ 个不同的数据服务器，标记为从 $1$ 到 $n$。边集合 $E$ 代表这些服务器之间的直接、双向通信链接。一项关键的维护任务是确定两个特定的服务器，一个源服务器 $s$ 和一个目标服务器 $t$，是否位于网络的同一个连通分量中，这意味着理论上数据包可以在它们之间路由。\n\n一位初级工程师提出了以下非确定性算法来检查连通性：\n1. 初始化变量 `current_node` 为源服务器 $s$ 的标签。初始化一个整数计数器 `steps_taken` 为 0。这些都存储在一个工作带上。\n2. 如果 `current_node` 等于 $t$，算法停机并接受。\n3. 如果 `steps_taken` 等于 $n$，算法停机并拒绝。这可以防止非终止计算。\n4. 将 `steps_taken` 增加一。\n5. 非确定性地选择一个服务器 `next_node`，它是图中 `current_node` 的邻居。\n6. 将 `current_node` 更新为 `next_node` 的值。\n7. 转到步骤 2。\n\n假设该算法在一个非确定性图灵机上实现。图的结构被提供在一个只读输入带上（例如，以邻接表的形式），这不计入算法的空间复杂度。你的任务是确定执行此算法所需的可写工作带上的空间复杂度。该复杂度应使用大O表示法表示，并作为服务器总数 $n$ 的函数。\n\n下列哪项代表了此算法工作带空间复杂度的最紧上界？\n\nA. $O(1)$\n\nB. $O(\\log n)$\n\nC. $O(n)$\n\nD. $O(n \\log n)$\n\nE. $O(n^2)$", "solution": "问题要求计算给定非确定性算法在图灵机工作带上的空间复杂度。空间复杂度由算法在执行期间存储其使用的变量所需的内存量决定。代表图的输入位于只读带上，不计入此复杂度。让我们分析算法需要在其工作带上存储的每条信息所需的内存。\n\n该算法使用两个主要变量：`current_node` 和 `steps_taken`。\n\n首先，我们考虑变量 `current_node`。这个变量存储算法当前正在访问的服务器的标签。服务器的标签从 $1$ 到 $n$。要存储一个在 $[1, n]$ 范围内的整数值，我们需要的比特数与该范围大小的对数成正比。具体来说，要用二进制表示任何不超过 $n$ 的整数，我们需要 $\\lceil \\log_2 n \\rceil$ 个比特。用大O表示法来说，存储 `current_node` 所需的空间是 $O(\\log n)$。\n\n其次，我们分析计数器 `steps_taken` 所需的空间。这个计数器从 0 开始，在非确定性游走的每一步都会递增。当 `steps_taken` 达到 $n$ 时，算法有一个停止条件（步骤 3）。因此，这个计数器可以容纳的最大值是 $n$。与 `current_node` 变量类似，存储一个最大为 $n$ 的整数值需要 $O(\\log n)$ 的空间。\n\n第三，算法在步骤 5 中非确定性地选择一个邻居 `next_node`。机器可能需要一些临时暂存空间，以便从输入带上读取一个邻居的ID，并在覆盖 `current_node` 之前持有它。任何邻居的ID也是一个介于 $1$ 和 $n$ 之间的整数，因此存储这个临时值也需要 $O(\\log n)$ 的空间。\n\n工作带上所需的总空间是算法必须跟踪的所有变量所需空间的总和。这包括 `current_node`、`steps_taken` 以及在此过程中使用的任何临时变量。\n\n总空间 = `current_node`所需空间 + `steps_taken`所需空间 + 临时变量所需空间\n总空间 = $O(\\log n) + O(\\log n) + O(\\log n)$\n\n常数个 $O(\\log n)$ 项的和仍然是 $O(\\log n)$。\n\n因此，该算法在工作带上的总空间复杂度是 $O(\\log n)$。这意味着无向图的 s-t 连通性问题属于复杂度类 NL（非确定性对数空间）。\n\n让我们评估给出的选项：\nA. $O(1)$: 这意味着空间是常数，与服务器数量 $n$ 无关。这是不正确的，因为我们需要存储服务器标签，其大小取决于 $n$。\nB. $O(\\log n)$: 这与我们的推导相符。\nC. $O(n)$: 如果算法需要存储它所遍历的整个路径，情况就会是这样。所描述的算法巧妙地通过只存储当前位置来避免了这一点。\nD. $O(n \\log n)$: 这可能对应于存储一个长度最多为 $n$ 的路径，其中每个节点ID需要 $O(\\log n)$ 的空间。同样，该算法不这样做。\nE. $O(n^2)$: 这可能是将在工作带上存储图的邻接矩阵表示所需的空间，但算法并不是这样做的。\n\n因此，在这些选项中，最紧的上界是 $O(\\log n)$。", "answer": "$$\\boxed{B}$$", "id": "1453163"}, {"introduction": "在图可达性概念的基础上，本题引入了一个带有附加约束的变体——路径必须避开某些“陷阱”顶点。解决这个问题需要你思考如何调整已知的解题策略，特别是通过将新问题归约到经典的“有向图可达性”问题。这个练习 [@problem_id:1453185] 突显了计算复杂性理论中的一项关键技能：识别问题并将其形式化地归约，从而对新问题进行分类。", "problem": "考虑一个名为 `TRAP_PATH` 的判定问题。`TRAP_PATH` 的一个实例由一个元组 $(G, s, t, T)$ 定义，其中 $G=(V, E)$ 是一个有向图，包含顶点集 $V$ 和有向边集 $E$，$s \\in V$ 是一个指定的起始顶点，$t \\in V$ 是一个指定的目标顶点，$T \\subset V$ 是一组“陷阱”顶点。\n\n问题是：在图 $G$ 中是否存在一条从 $s$到 $t$ 的路径，该路径不经过集合 $T$ 中的任何顶点？一条路径是一个顶点序列 $(v_0, v_1, \\dots, v_k)$，满足 $v_0 = s$，$v_k = t$，并且对于所有 $i \\in \\{0, \\dots, k-1\\}$，边 $(v_i, v_{i+1})$ 都在 $E$ 中。如果对于所有 $i \\in \\{0, \\dots, k\\}$，都有 $v_i \\notin T$，则该路径避开了集合 $T$。\n\n假设输入采用标准编码，其中顶点数为 $n = |V|$，顶点从 $1$ 到 $n$ 编号。图由其邻接表表示法给出。输入还指定了 $s$、$t$ 的标号以及 $T$ 中的顶点标号列表。\n\n考虑以下标准计算复杂度类，其中空间有界类的复杂度是根据顶点数 $n$ 来衡量的：\n- L (对数空间): 可由确定性图灵机使用 $O(\\log n)$ 工作空间解决的问题。\n- NL (非确定性对数空间): 可由非确定性图灵机使用 $O(\\log n)$ 工作空间解决的问题。\n- P (多项式时间): 可由确定性图灵机在总输入规模的多项式时间内解决的问题。\n- NP (非确定性多项式时间): 可由非确定性图灵机在总输入规模的多项式时间内解决的问题。\n\n以下哪一项代表 `TRAP_PATH` 已知所属的最小复杂度类？\nA. L\n\nB. NL\n\nC. P\n\nD. NP", "solution": "为了确定 `TRAP_PATH` 的复杂度，我们证明它是 NL-完备的。\n\n**NL 成员身份**：\n`TRAP_PATH` 问题属于 NL。我们可以设计一个非确定性对数空间算法来解决它。首先，检查 $s$ 或 $t$ 是否在陷阱集 $T$ 中，如果是，则拒绝。否则，算法维护当前顶点（初始为 $s$）和步数计数器，两者都占用 $O(\\log n)$ 空间。在每一步，算法非确定性地选择一个邻居，并检查该邻居是否在 $T$ 中。如果不在 $T$ 中，则移动到该邻居。如果到达 $t$，则接受。整个过程符合 NL 的定义。\n\n**NL-困难性**：\n标准的有向图可达性问题 (PATH) 可以通过一个简单的对数空间归约映射到 `TRAP_PATH`：将一个 PATH 实例 $(G,s,t)$ 映射为一个 `TRAP_PATH` 实例 $(G,s,t,\\emptyset)$。因此，`TRAP_PATH` 是 NL-难的。\n\n由于 `TRAP_PATH` 既属于 NL 又是 NL-难的，所以它是 NL-完备的。在所列出的选项中，NL 是包含该问题的最小复杂度类。", "answer": "$$\\boxed{B}$$", "id": "1453185"}, {"introduction": "最后的这个实践挑战你判断一个图是否为无环图的复杂度，这是一个在任务调度等领域中常见的问题。其解决方案涉及到探索一个问题与其补问题之间的关系，并引入了 co-NL 这个复杂度类。通过这个问题 [@problem_id:1453166]，你将能体会到著名的 Immerman-Szelepcsényi 定理的精妙之处，该定理指出 $NL = co-NL$，这是关于非确定性对数空间计算能力的一个深刻结论。", "problem": "考虑一个名为 `TASK-ORDERING-VALIDATION` 的计算问题。在该问题中，给定一个包含 $n$ 个任务的集合，记为 $T = \\{t_1, t_2, \\dots, t_n\\}$，以及一个包含 $m$ 个先决依赖关系的集合 $D$。每个依赖关系是一个有序对 $(t_i, t_j)$，表示任务 $t_i$ 必须在任务 $t_j$ 开始之前完成。这个系统可以被建模为一个有向图 $G=(V, E)$，其中顶点 $V$ 对应于任务 $T$，且当且仅当 $(t_i, t_j)$ 是 $D$ 中的一个依赖关系时，存在一条从顶点 $t_i$ 到顶点 $t_j$ 的有向边。\n\n所有任务的一个有效顺序排序仅在依赖关系图不包含任何循环依赖（例如，任务 A 需要任务 B，任务 B 需要任务 C，而任务 C 需要任务 A）时才可能存在。这种循环依赖对应于图中的一个有向环，即一条由一条或多条边组成的、起点和终点相同的路径。`TASK-ORDERING-VALIDATION` 问题是判断给定的任务和依赖关系集合是否不含循环依赖。用图论的术语来说，这等价于判断对应的有向图 $G$ 是否是一个有向无环图（DAG）。\n\n令 NL 为可由非确定性图灵机使用对数内存空间（$O(\\log |input|)$）解决的判定问题的复杂性类，令 co-NL 为其补问题在 NL 中的问题的类。基于这些复杂性类的基本性质，关于 `TASK-ORDERING-VALIDATION` 问题的以下哪个陈述是正确的？\n\n假设图以标准格式（例如，邻接表）表示，其输入大小是 $n$ 和 $m$ 的多项式。\n\nA. `TASK-ORDERING-VALIDATION` 在 NL 中，但不知道它是否在 co-NL 中。\n\nB. `TASK-ORDERING-VALIDATION` 在 co-NL 中，但不知道它是否在 NL 中。\n\nC. `TASK-ORDERING-VALIDATION` 已知在 P 中，但不知道它是否在 NL 或 co-NL 中。\n\nD. `TASK-ORDERING-VALIDATION` 同时在 NL 和 co-NL 中。\n\nE. `TASK-ORDERING-VALIDATION` 是 NP-hard 的。", "solution": "我们将实例建模为一个有向图 $G=(V,E)$，其中 $|V|=n$ 且 $|E|=m$。该问题询问 $G$ 是否是无环的，即 $G$ 是否不包含有向环。令 $ACYCLIC$ 表示这个判定问题，令 $CYCLE$ 表示其补问题，即询问 $G$ 是否包含有向环。形式上，$ACYCLIC=\\overline{CYCLE}$。\n\n步骤1（证明 $CYCLE \\in \\mathrm{NL}$）：我们描述一个用于 $CYCLE$ 的非确定性对数空间算法。\n- 非确定性地选择一个起始顶点 $v_{0} \\in V$，并使用 $O(\\log n)$ 位存储其索引。\n- 维护一个计数器 $c$，初始化为 $1$ 且上限为 $n$，用 $O(\\log n)$ 位存储。\n- 维护当前顶点 $v$，初始化为 $v_{0}$，用 $O(\\log n)$ 位存储。\n- 重复：非确定性地选择一条出边 $(v,u) \\in E$（通过猜测一个邻居的索引并从输入中验证），设置 $v \\leftarrow u$，并增加 $c$。如果在任何步骤中 $v=v_{0}$ 且 $c \\geq 1$，则接受。如果 $c$ 超过 $n$，则在此分支上拒绝。\n正确性：如果 $G$ 有一个有向环，那么就存在一个长度为 $k$ 的简单环，其中 $1 \\leq k \\leq n$。机器可以通过选择环上的 $v_{0}$ 以及沿着环的 $k$ 条边来猜测该环，从而在至多 $n$ 步内到达 $v_{0}$ 并接受。如果 $G$ 没有环，那么任何不超过 $n$ 次的边遍历序列在至少一步之后都不会返回到 $v_{0}$，因此没有接受分支。空间：我们存储 $v_{0}$、$v$ 和计数器 $c$，每个都占用 $O(\\log n)$ 位，外加用于扫描输入和验证边的常数工作空间；因此总空间为 $O(\\log |input|)$。因此 $CYCLE \\in \\mathrm{NL}$。\n\n步骤2（补问题和 co-NL）：由于 $ACYCLIC=\\overline{CYCLE}$ 且 $CYCLE \\in \\mathrm{NL}$，根据 co-NL 的定义，可以得出 $ACYCLIC \\in \\mathrm{co\\text{-}NL}$。\n\n步骤3（Immerman–Szelepcsényi 定理）：根据 Immerman–Szelepcsényi 定理，$\\mathrm{NL}=\\mathrm{co\\text{-}NL}$。因此，$ACYCLIC$ 也在 $\\mathrm{NL}$ 中。\n\n步骤4（与已知的多项式时间算法的一致性）：另外，$ACYCLIC \\in \\mathrm{P}$，这可以通过例如深度优先搜索或用于拓扑排序的 Kahn 算法来证明。这与上述结论不矛盾，并且在标准假设下支持该问题不是 NP-hard 的。在给出的选项中，唯一正确的陈述是该问题同时属于 $\\mathrm{NL}$ 和 $\\mathrm{co\\text{-}NL}$。\n\n因此，正确选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1453166"}]}