{"hands_on_practices": [{"introduction": "这个练习将帮助你掌握交替图灵机（ATM）中存在状态的核心功能。我们将设计一个ATM来判断一个字符串是否**不是**回文串。这里的关键在于，证明一个字符串不是回文串，只需要找到**存在**一对不匹配的字符即可，这个任务完美地契合了ATM的存在“猜测”能力[@problem_id:1411937]。", "problem": "交替图灵机（Alternating Turing Machine, ATM）是一种非确定性图灵机，其状态分为两类：*存在*状态和*全称*状态。对于给定的输入，ATM的计算过程可以看作是一个格局树。\n- 如果当前状态是*存在*状态，那么只要存在至少一条从当前格局开始的计算路径（树中的一个分支）能够达到接受状态，机器就接受。\n- 如果当前状态是*全称*状态，那么只有当所有从当前格局开始的计算路径（树中的所有分支）都达到接受状态时，机器才接受。\n\n如果一个二进制字符串正着读和反着读都一样，那么它就被称为回文串。例如，\"1001\" 是一个回文串，但 \"1011\" 不是。设 $w^R$ 表示字符串 $w$ 的反转。一个字符串 $w$ 是回文串，当且仅当 $w = w^R$。\n\n考虑所有**非**回文串的二进制字符串构成的语言 $L$。你的任务是为一个能够判定该语言 $L$ 的ATM，找出正确的高层操作描述。输入字符串 $w$ 的长度为 $n$，其字符索引从 $0$ 到 $n-1$。\n\n以下哪个描述准确地概述了一个ATM的策略，该ATM当且仅当输入字符串 $w$ **不是**回文串时接受该输入？\n\nA. ATM从一个存在状态开始。它存在性地选择一个索引 $i$（其中 $0 \\le i  n/2$）。然后，它确定性地移动其带头以读取字符 $w[i]$ 和对称位置的字符 $w[n-1-i]$。如果 $w[i] \\neq w[n-1-i]$，机器在此计算路径上进入接受状态，否则进入拒绝状态。\n\nB. ATM从一个全称状态开始。它对每个索引 $i$（其中 $0 \\le i  n/2$）进行全称分支。对于每个分支，它确定性地检查 $w[i] \\neq w[n-1-i]$ 是否成立。如果不相等，该分支导向接受状态。只有当所有分支都导向接受时，机器才接受输入字符串。\n\nC. ATM从一个存在状态开始。它存在性地选择一个索引 $i$（其中 $0 \\le i  n/2$）。然后，它确定性地移动其带头以读取字符 $w[i]$ 和对称位置的字符 $w[n-1-i]$。如果 $w[i] = w[n-1-i]$，机器在此计算路径上进入接受状态，否则进入拒绝状态。\n\nD. ATM从一个存在状态开始并选择一个索引 $i$。然后它转换到一个全称状态，该状态分支为两个并行的检查：（1）验证 $w[i]$ 是 '0'，以及（2）验证 $w[n-1-i]$ 是 '1'。如果能找到一个索引 $i$，使得两个全称检查都成功，则机器接受。", "solution": "我们来形式化目标语言。设 $w$ 是一个长度为 $n$ 的二进制字符串，索引从 $0$ 到 $n-1$。定义对称索引对的集合为形如 $(i,n-1-i)$ 的对，其中 $i$ 满足 $0 \\le i  n/2$（将 $n/2$ 理解为整数除法）。那么，$w$ 是回文串当且仅当对于所有这样的 $i$，$w[i] = w[n-1-i]$。因此，$w$ 不是回文串当且仅当存在至少一个这样的 $i$ 使得 $w[i] \\ne w[n-1-i]$。用符号表示，\n$$\nw \\in L \\iff \\exists i \\in \\{0,1,\\dots,\\lfloor n/2 \\rfloor - 1\\} \\text{ such that } w[i] \\ne w[n-1-i].\n$$\n交替图灵机从一个存在状态接受，如果存在一个计算分支达到接受状态；从一个全称状态接受，如果所有计算分支都达到接受状态。因此，要精确地接受语言 $L$，机器必须实现上述的存在性条件：非确定性地选择一个索引 $i$，如果在该对称位置对上发现不匹配，则接受。\n\n现在我们通过将每个选项转换为逻辑条件来评估它们：\n\nA. 从存在状态开始，选择 $i$（其中 $0 \\le i  n/2$），如果 $w[i] \\ne w[n-1-i]$，则在该分支上接受。总的接受条件是\n$$\n\\exists i \\text{ with } 0 \\le i  n/2 \\text{ such that } w[i] \\ne w[n-1-i],\n$$\n这与 $w \\in L$ 的条件完全匹配。因此A是正确的。\n\nB. 从全称状态开始，对所有 $i$（其中 $0 \\le i  n/2$）进行分支，并且每个分支仅在 $w[i] \\ne w[n-1-i]$ 时接受。总的接受条件是\n$$\n\\forall i \\text{ with } 0 \\le i  n/2,\\ w[i] \\ne w[n-1-i],\n$$\n这个条件比非回文串的条件更严格，并且对于那些至少有一对相等对称位置的非回文串会失败。因此B是不正确的。\n\nC. 从存在状态开始，选择 $i$，如果 $w[i] = w[n-1-i]$ 则接受。总的接受条件是\n$$\n\\exists i \\text{ with } 0 \\le i  n/2 \\text{ such that } w[i] = w[n-1-i],\n$$\n这个条件会接受许多回文串（实际上是所有回文串）和一些非回文串；它没有描述语言 $L$。因此C是不正确的。\n\nD. 从存在状态开始选择 $i$，然后在该分支上全称地强制 $w[i]=0$ 和 $w[n-1-i]=1$。总的接受条件是\n$$\n\\exists i \\text{ with } 0 \\le i  n/2 \\text{ such that } \\big(w[i]=0 \\land w[n-1-i]=1\\big),\n$$\n这只捕捉了一种不匹配的情况，当不匹配是 $w[i]=1$，$w[n-1-i]=0$ 时就会失败。因此D是不正确的。\n\n因此，只有A正确描述了一个能精确接受非回文串的ATM。", "answer": "$$\\boxed{A}$$", "id": "1411937"}, {"introduction": "在理解了存在状态之后，这个练习将介绍它的“搭档”：全称状态。我们将解决图的不可达性（UNREACHABILITY）问题，即判断图中两个顶点之间是否**不存在**任何路径。这需要验证从起点出发的**所有**可能路径都无法到达终点，这是ATM全称分支能力的典型应用[@problem_id:1411930]。", "problem": "考虑一个有向图 $G = (V, E)$，其中 $V$ 是一个有限的顶点集合，$E$ 是一个表示有向边的顶点有序对集合。设 $s, t \\in V$ 分别是不同的源顶点和目标顶点。图可达性问题 (REACHABILITY) 旨在确定是否存在一条从 $s$ 到 $t$ 的路径。\n\n非确定性图灵机 (NTM) 可以解决 REACHABILITY 问题。其带上的输入是图 $G$ 以及顶点 $s$ 和 $t$ 的描述。NTM 的逻辑如下：它维护一个“当前顶点”（初始为 $s$）和一个步数计数器（初始为 0）。在一个循环中，它执行以下操作：\n1. 如果当前顶点 $u$ 等于 $t$，则机器停机并接受。\n2. 如果步数计数器达到 $|V|$（这是一个为防止在环上无限循环的限制），则机器在此计算路径上停机并拒绝。\n3. 否则，NTM 使用其非确定性（一个存在状态）来猜测一个顶点 $v$，使得 $(u, v) \\in E$。它将当前顶点更新为 $v$，增加步数计数器，并继续循环。如果 $u$ 没有出边，则此分支拒绝。\n只要其任何一个计算分支找到一条到 $t$ 的路径，整个机器就接受。\n\n现在，考虑其补问题，不可达性问题 (UNREACHABILITY)，该问题询问是否*没有*从 $s$ 到 $t$ 的路径。你的任务是描述一台解决 UNREACHABILITY 问题的交替图灵机 (ATM) 的高层计算逻辑。ATM 是 NTM 的一种推广，它同时具有存在状态（如果至少有一个后续计算接受，则接受）和全称状态（如果所有后续计算都接受，则接受）。\n\n设 $N = |V|$ 是图中的顶点数。下列哪个陈述正确地描述了用于判定 UNREACHABILITY 问题的 ATM 的核心逻辑？\n\nA. ATM 从当前顶点为 $s$、步数计数器为 0 开始。如果当前顶点 $u$ 是 $t$，它就拒绝。如果计数器达到 $N$，它就接受。否则，它进入一个**全称状态**，分支到 $u$ 的所有邻居。对于每个邻居 $v$，派生一个新的计算，其当前顶点为 $v$，计数器加一。如果一个顶点 $u \\neq t$ 没有邻居，该分支接受。如果所有分支都导致接受，则机器接受。\n\nB. ATM 从当前顶点 $s$ 开始。它进入一个**存在状态**，非确定性地猜测一个代表路径的顶点序列。如果路径到达 $t$，机器接受。如果所有长度小于 $N$ 的猜测路径都没有到达 $t$，机器拒绝。\n\nC. ATM 从当前顶点 $s$ 开始。它进入一个**全称状态**，并全称地分支到每个其他顶点 $v \\in V \\setminus \\{s,t\\}$。对于每个这样的分支，ATM 接着进入一个**存在状态**，以检查是否存在从 $s$ 到 $v$ 的路径以及是否存在从 $v$ 到 $t$ 的路径。如果对于任何 $v$ 这是真的，机器就拒绝。\n\nD. ATM 从当前顶点为 $s$、步数计数器为 0 开始。在一个循环中，它进入一个**存在状态**来猜测当前顶点 $u$ 的一个邻居 $v$。然后，它进入一个**全称状态**来验证 $v$ 不是 $t$ 并且步数计数器小于 $N$。如果这些条件对所有选择都成立，它就继续。如果有可能继续 $N$ 步，机器就接受。", "solution": "我们使用一个关于有界路径长度的归纳谓词来形式化判定 UNREACHABILITY 所需的性质。设 $G=(V,E)$ 是一个有向图，其中 $|V|=N$，$s,t \\in V$ 是固定的顶点。对于每个顶点 $u \\in V$ 和整数 $k \\geq 0$，定义谓词 $R_{k}(u)$ 表示：不存在从 $u$ 到 $t$ 的长度至多为 $k$ 的路径。\n\n我们通过对 $k$ 进行归纳来推导 $R_{k}(u)$：\n1. 归纳基础：从 $u$ 到 $t$ 存在长度至多为 $0$ 的路径，当且仅当 $u=t$。因此，\n$$\nR_{0}(u) \\iff u \\neq t.\n$$\n2. 归纳步骤：从 $u$ 到 $t$ 不存在长度至多为 $k+1$ 的路径，当且仅当 $u \\neq t$ 并且对于每个出边邻居 $v$（其中 $(u,v) \\in E$），不存在从 $v$ 到 $t$ 的长度至多为 $k$ 的路径。因此，\n$$\nR_{k+1}(u) \\iff \\bigl(u \\neq t\\bigr) \\land \\bigl(\\forall v \\in V \\text{ with } (u,v) \\in E,\\ R_{k}(v)\\bigr).\n$$\n\n如果 $R_{N-1}(s)$ 成立，则从 $s$ 到 $t$ 根本不存在路径，因为任何从 $s$ 到 $t$ 的路径都可以被缩短为一条简单路径，而在一个有 $N$ 个顶点的图中，任何简单路径的长度至多为 $N-1$。因此，判定 UNREACHABILITY 归约到判定 $R_{N-1}(s)$。\n\n交替图灵机可以自然地实现这个归纳过程：\n- ATM 的格局携带一个当前顶点 $u$ 和一个表示剩余长度预算的计数器 $c$。初始化为 $(u,c)=(s,N-1)$。\n- 如果 $u=t$，则拒绝，这对应于 $R_{0}(u) \\iff u \\neq t$ 以及归纳步骤中的左合取项。\n- 如果 $c=0$，则接受，因为 $R_{0}(u)$ 正是 $u \\neq t$，这一点我们已经通过前面的检查确保了。\n- 否则，进入一个全称状态，对于每个出边邻居 $v$（其中 $(u,v) \\in E$），派生一个关于 $(v,c-1)$ 的子计算。如果 $u$ 没有出边且 $u \\neq t$，那么对空集的全称量化是虚真的，所以该分支接受。整体接受要求所有派生的子计算都接受，这与归纳步骤的要求完全一致。\n\n这种行为等价于从 $(u,c)=(s,0)$ 开始，当计数器达到 $N$ 时接受，同时在每一步全称地分支到所有邻居，并在当前顶点等于 $t$ 时拒绝。这样的计数器约定只是将索引移动了一位，并保持了正确性，因为 $N$ 限定了任何简单路径的长度。\n\n与选项进行比较：\n- 选项 A 精确地实现了对 $R_{k}(u)$ 的全称分支归纳，使用一个由 $N$ 界定的计数器，在 $u=t$ 时拒绝，在计数器达到限制时接受，全称地探索所有邻居，并在没有邻居时虚接受。这与解决 UNREACHABILITY 问题的正确 ATM 逻辑相匹配。\n- 选项 B 使用存在状态在找到到 $t$ 的路径时接受，这判定的是 REACHABILITY 而不是 UNREACHABILITY。对于补问题，接受准则是相反的，所以这个选项不正确。\n- 选项 C 滥用了交替：它全称地分支到各个顶点上，然后如果存在路径 $s \\to v$ 和 $v \\to t$，则存在性地接受。在全称状态下，接受要求所有子计算都接受；当存在一个见证时让一个子计算接受，并不能在存在见证时强制拒绝，这与预期的逻辑相矛盾。因此，它是不正确的。\n- 选项 D 存在性地选择邻居，并全称地只强制执行局部条件，如果在避开 $t$ 的情况下有可能继续 $N$ 步，则接受。如果存在一条长的、避开 $t$ 的游走，这将导致接受，但这并不意味着 $t$ 是不可达的。因此，它是不正确的。\n\n因此，正确的描述由选项 A 给出。", "answer": "$$\\boxed{A}$$", "id": "1411930"}, {"introduction": "最后一个练习将结合使用存在状态和全称状态，来解决一个更复杂的问题：判断一个图是否恰好只有一个完美匹配。解决这个问题需要一个两步的逻辑——首先，**存在性地**找到一个完美匹配，然后**全局性地**验证它是唯一的一个。这种“存在-全称”($\\exists\\forall$)的结构展示了“交替”的真正威力，并揭示了ATM与多项式层级中更高级的复杂性类之间的联系[@problem_id:1411943]。", "problem": "鲁棒验证协议的设计是计算机科学的一个核心主题。考虑一个任务分配系统的场景，其中有 $n$ 个任务，由顶点集 $U$ 表示，以及 $n$ 个计算资源，由顶点集 $V$ 表示。任务和资源之间的兼容性被建模为一个二分图 $G=(U \\cup V, E)$，其中如果任务 $u \\in U$ 可以由资源 $v \\in V$ 处理，则存在一条边 $(u, v) \\in E$。“完美分配”是每个任务到唯一资源的完整分配，这对应于图 $G$ 中的一个完美匹配。完美匹配被正式定义为边的一个子集 $M \\subseteq E$，使得图 $U \\cup V$ 中的每个顶点都恰好是 $M$ 中一条边的端点。\n\n你的目标是为交替图灵机（ATM）设计一个高层算法，该算法可以判定语言 `UniquePerfectMatching`，该语言由所有恰好有一个完美匹配的二分图组成。ATM 是一种非确定性图灵机，其状态分为存在状态和全称状态。从存在状态出发，如果至少有一条计算路径导向接受状态，则机器接受。从全称状态出发，只有当所有计算路径都导向接受状态时，机器才接受。\n\n以下哪种 ATM 的高层描述正确地判定了给定的二分图 $G=(U \\cup V, E)$（其中 $|U|=|V|=n$）是否恰好有一个完美匹配？\n\nA. 从一个存在状态开始，猜测一个边集 $M_1$。机器检查 $M_1$ 是否为一个完美匹配。如果是，机器转换到一个全称状态。从此全称状态，它猜测另一个边集 $M_2$。如果 $M_2$ 不是一个完美匹配，或者 $M_2$ 与 $M_1$ 相同，则这条全称路径导向接受。如果对 $M_1$ 的初始存在性猜测是一个有效的完美匹配，并且从该点开始的所有后续全称路径都导向接受，则整个 ATM 接受。\n\nB. 从一个全称状态开始，猜测一个边集 $M_1$。机器转换到一个存在状态，猜测另一个边集 $M_2$。如果 $M_1$ 是一个完美匹配，$M_2$ 是一个完美匹配，并且 $M_1$ 与 $M_2$ 不同，则该路径导向接受。如果对于每一个初始的全称性猜测 $M_1$，都存在一个存在性猜测 $M_2$ 使得该路径被接受，则整个 ATM 接受。\n\nC. 从一个存在状态开始，猜测两个不同的边集 $M_1$ 和 $M_2$。如果 $M_1$ 和 $M_2$ 都是完美匹配，则机器接受。\n\nD. 从一个全称状态开始，猜测一个边集 $M$。如果 $M$ 不是一个完美匹配，则机器在这条路径上接受。如果这对所有可能的边集 $M$ 都成立，则整个 ATM 接受。\n\nE. 从一个存在状态开始，猜测一个边集 $M_1$。机器检查 $M_1$ 是否为一个完美匹配。如果不是，此路径拒绝。如果是，机器转换到一个全称状态，并猜测另一个边集 $M_2$。仅当 $M_2$ 是一个完美匹配且 $M_2$ 与 $M_1$ 不同时，这条全称路径才导向接受。", "solution": "要为 `UniquePerfectMatching` 问题确定正确的交替图灵机（ATM）算法，我们首先需要使用带量词的形式逻辑来表达“图 $G$ 恰好有一个完美匹配”这一条件。然后，这个逻辑结构可以直接映射到 ATM 的计算步骤。\n\n一个图 $G$ 恰好有一个完美匹配，需要同时满足两个条件：\n1.  存在至少一个完美匹配。\n2.  不存在两个不同的完美匹配。\n\n让我们用 `IsPM(M)` 表示一个谓词，如果边集 $M$ 是图 $G$ 中的一个完美匹配，则该谓词为真。我们可以将具有唯一完美匹配的性质写成一个逻辑公式：\n\n$$ \\exists M_1 \\left( \\text{IsPM}(M_1) \\land \\forall M_2 \\left( \\text{IsPM}(M_2) \\implies M_2 = M_1 \\right) \\right) $$\n\n这个公式读作：“存在一个边集 $M_1$，使得 $M_1$ 是一个完美匹配，并且对于所有的边集 $M_2$，如果 $M_2$ 是一个完美匹配，那么 $M_2$ 必须等于 $M_1$。”\n\n逻辑联结词 `P ⇒ Q` 等价于 `¬P ∨ Q`。将此应用于我们公式的内部部分，我们得到：\n\n$$ \\forall M_2 \\left( \\neg \\text{IsPM}(M_2) \\lor M_2 = M_1 \\right) $$\n\n这读作：“对于所有的边集 $M_2$，要么 $M_2$ 不是一个完美匹配，要么 $M_2$ 等于 $M_1$。”\n\n因此，唯一完美匹配的完整逻辑陈述是：\n$$ \\exists M_1 \\left( \\text{IsPM}(M_1) \\land \\forall M_2 \\left( \\neg \\text{IsPM}(M_2) \\lor M_2 = M_1 \\right) \\right) $$\n\n现在我们可以将这个结构翻译成一个 ATM 算法：\n\n1.  **`∃ M₁`**: 计算从一个存在状态开始。在此状态下，ATM 非确定性地“猜测”一个边集 $M_1$。这意味着机器会分支成多个计算路径，每个可能的边集 $M_1$ 对应一条路径。如果这些分支中的任何一个最终接受，则机器接受。\n\n2.  **`IsPM(M₁)`**: 猜测 $M_1$ 后，机器执行一个确定性检查，以验证 $M_1$ 是否确实是一个完美匹配。这包括检查 $M_1$ 是否包含 $|U|=n$ 条边，以及 $U \\cup V$ 中的每个顶点的度是否恰好为一。这个检查可以在多项式时间内完成。如果 $M_1$ 不是一个完美匹配，这个存在性分支失败并拒绝。\n\n3.  **`∧`**: 如果 `IsPM(M₁)` 检查通过，机器继续评估合取式的第二部分。\n\n4.  **`∀ M₂`**: 为了评估全称量化的部分，机器从一个存在状态转换到一个全称状态。在此状态下，机器非确定性地“猜测”另一个边集 $M_2$。因为该状态是全称的，所有这些计算分支（每个可能的 $M_2$ 对应一个）都必须导向一个接受状态，这部分计算才能成功。\n\n5.  **`¬IsPM(M₂) ∨ M₂ = M₁`**: 对于每个全称猜测的 $M_2$，机器执行另一个确定性检查。它评估 `IsPM(M₂)` 是否为假，或者 `M₂` 是否与最初猜测的 `M₁` 相同。如果此条件成立，则全称分支接受。如果条件不成立（意味着 $M_2$ 是一个完美匹配且它不同于 $M_1$），则此全称分支拒绝。任何一个全称分支的拒绝都会导致整个全称计算（从 `∀ M₂` 步骤开始）拒绝。\n\n当且仅当存在一种方式选择一个完美匹配 $M_1$，使得对于所有其他可能的边集 $M_2$，它们要么不是完美匹配，要么就是 $M_1$ 本身时，此 ATM 才接受。这恰好对应于唯一完美匹配的定义。\n\n我们来分析给定的选项：\n- **A**: 这个选项精确地描述了我们推导出的算法。它从对 $M_1$ 的一个存在性猜测开始，验证它是一个完美匹配，然后切换到一个全称状态来猜测 $M_2$，并且如果“$M_2$ 不是一个完美匹配，或者 $M_2$ 与 $M_1$ 相同”，则在一条全称路径上接受。这是正确的。\n- **B**: 这描述了一个 `∀∃`（或 $\\Pi_2$）计算。其逻辑不正确，并且会检查一个与唯一完美匹配不同的属性。\n- **C**: 这个仅含存在状态的机器检查是否存在至少两个完美匹配。它判定的是我们语言的补集的一个子集。\n- **D**: 这个仅含全称状态的机器检查是否根本没有完美匹配。它判定的是语言 `NonPerfectMatching`（即图中没有完美匹配），这与判断唯一性是不同的问题。\n- **E**: 这个选项有正确的交替结构（`∃∀`），但全称部分的逻辑是有缺陷的。它要求 $M_2$ 是一个*不同*的完美匹配才能使路径接受，这与证明唯一性所需要的恰好相反。\n\n因此，选项 A 是唯一一个正确描述了用于判定 `UniquePerfectMatching` 语言的 ATM 的选项。", "answer": "$$\\boxed{A}$$", "id": "1411943"}]}