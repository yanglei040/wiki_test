{"hands_on_practices": [{"introduction": "在对数空间中设计算法，最基本的操作之一就是跟踪我们在输入中的位置。这个练习将通过一个简单但基础的模式匹配问题，向您展示如何使用一个占用 $O(\\log n)$ 空间的计数器来迭代访问输入中的每个位置。掌握这项技能是构建更复杂对数空间算法的第一步。[@problem_id:1452617]", "problem": "如果一个语言可以由一台确定性图灵机（TM）使用与输入大小的对数成正比的工作带内存量来判定，即对于长度为 $n$ 的输入使用 $O(\\log n)$ 空间，则称该语言属于复杂度类 L（对数空间）。该类的标准模型假设图灵机有一个只读输入带和一个独立的读写工作带。\n\n考虑语言 $A = \\{w \\in \\{0,1\\}^* \\mid w = (01)^k \\text{ for some integer } k \\ge 1\\}$，它由一个或多个子串 \"01\" 的串联组成的字符串构成。\n\n虽然这个语言是正则的，并且可以在常数 $O(1)$ 空间内判定，但我们感兴趣的是分析一种依赖于显式跟踪输入字符串中位置的通用算法策略。下列哪个陈述准确地描述了一个确定性图灵机在对数空间约束内判定语言 $A$ 的有效算法？\n\nA. 图灵机在其工作带上维护一个从1开始的二进制计数器 `i`。对于每个从1到 $n-1$ 的 `i`，它将其输入头移动到位置 `i`，并检查字符 `input[i]` 是否为 '0' 且字符 `input[i+1]` 是否为 '1'。如果对于任何 `i`，此条件不成立，则机器拒绝。如果循环完成，则接受。\n\nB. 图灵机使用一个从1开始的工作带计数器 `i`。在一个从 $i=1$ 到 $n$ 的循环中，它读取输入带上位置 `i` 的字符。它验证如果 `i` 是奇数，则字符为 '0'；如果 `i` 是偶数，则字符为 '1'。如果有任何检查失败，则拒绝。循环结束后，它执行最终检查：如果总长度 `n` 是奇数，则拒绝。否则，接受。\n\nC. 图灵机进行两次扫描。在第一次扫描中，它计算 '0' 的总数，并将此计数以二进制形式存储在其工作带上。在第二次扫描中，它计算 '1' 的总数。当且仅当 '0' 的数量等于 '1' 的数量，字符串的第一个字符是 '0'，最后一个字符是 '1' 时，它才接受。\n\nD. 图灵机作为一个双状态自动机运行，在‘期望0’状态和‘期望1’状态之间交替。因为这种方法只使用常数空间（$O(1)$），对于非常数 $n$ 而言，这小于对数空间，所以语言 $A$ 不被认为属于类 L。\n\nE. 图灵机只需要检查两个条件：字符串的总长度 $n$ 是偶数，并且位置 $n/2$ 的字符是 '0'，位置 $n/2 + 1$ 的字符是 '1'。如果两者都为真，则接受。", "solution": "我们必须判定哪个陈述描述了一个正确的确定性图灵机算法，该算法使用至多 $O(\\log n)$ 的工作带空间（标准的只读输入带和独立的工作带）来判定语言 $A=\\{(01)^{k}\\mid k\\ge 1\\}$。一个在位置 $1,\\dots,n$ 范围内变化并以二进制存储的工作带计数器使用 $O(\\log n)$ 空间，因此任何维护这样一个计数器并且此外只使用常数数量辅助位的算法都保持在对数空间限制内。\n\n从正确性（恰好接受 $A$）和空间两方面分析每个选项。\n\nA. 该算法检查从 $i=1$ 到 $n-1$ 的所有相邻对 $(\\text{`input[i]`},\\text{`input[i+1]`})$ 是否等于 $(0,1)$。考虑 $w=0101$ 且 $n=4$。当 $i=2$ 时，该对是 $(1,0)$，所以机器拒绝。然而，$0101 \\in A$。因此，A 作为一个判定过程是不正确的，尽管其空间使用量为 $O(\\log n)$。\n\nB. 该算法检查对于从 $1$ 到 $n$ 的每个位置 $i$，如果 $i$ 是奇数，则符号为 $0$；如果 $i$ 是偶数，则符号为 $1$，最后如果 $n$ 是奇数则拒绝，否则接受。正确性：\n- 如果 $w \\in A$，则 $w=(01)^{k}$ 对于某个 $k \\ge 1$，因此对于每个奇数 $i$，$w[i]=0$，对于每个偶数 $i$，$w[i]=1$，并且 $n=2k$ 是偶数。因此算法接受。\n- 反之，如果算法接受，则对于所有的 $i$，符号模式都匹配：奇数位置是 $0$，偶数位置是 $1$，并且 $n$ 是偶数。因此 $w$ 等于 $(01)^{n/2}$，其中 $n/2 \\ge 1$，所以 $w \\in A$。\n空间：维护一个二进制计数器 $i$ 和常数数量的标志位在工作带上使用 $O(\\log n)$ 空间。因此 B 是一个判定 $A$ 的有效的 $O(\\log n)$ 空间算法。\n\nC. 它当且仅当 $0$ 和 $1$ 的计数匹配，并且第一个符号是 $0$，最后一个是 $1$ 时才接受。这个条件不足以强制交替。例如，$w=0011$ 满足计数相等、首位为 $0$、末位为 $1$，但 $w \\notin A$。因此，C 是不正确的。\n\nD. 它声claim使用 $O(1)$ 空间意味着该语言不在 L 类中。这是错误的，因为 $O(1)\\subseteq O(\\log n)$。如果一个语言可以在常数空间内被判定，那么它就在 L 类中。因此，D 是不正确的。\n\nE. 它只检查 $n$ 是偶数，并且中间边界满足 `input[n/2]`=0 和 `input[n/2+1]`=1。这并不能强制整个字符串的交替。反例 $w=0011$（长度为 $4$）满足这些检查，但不在 $A$ 中。因此，E 是不正确的。\n\n因此，在所有选项中，唯一一个在 $O(\\log n)$ 空间内判定 $A$ 的有效算法是 B。", "answer": "$$\\boxed{B}$$", "id": "1452617"}, {"introduction": "对数空间算法的真正威力在于其计数能力，这使得它们能够解决有限自动机无法处理的问题。这个实践将探讨经典的语言 $\\{0^n 1^n \\mid n \\ge 1\\}$，它要求算法“记住”它所看到的 '0' 的数量。通过实现一个二进制计数器，您将亲身体验到，只需 $O(\\log n)$ 的空间就足以完成这项看似需要线性内存的任务。[@problem_id:1452636]", "problem": "考虑一个用于数据验证协议的简化模型。数据包流由一个二进制字符串表示。一个有效的“突发”（burst）被定义为一个非空的'0'序列（代表请求类型的数据包）后跟一个非空的'1'序列（代表释放类型的数据包）。如果'0'的数量等于'1'的数量，则该突发被认为是“平衡的”（balanced）。\n\n你需要分析判断一个传入的突发是否是平衡的所需的计算资源。这个任务由一台确定性图灵机（TM）建模，该图灵机有一个只读的输入带和一个独立的可读写的工作带。对于长度为 $N$ 的输入，该TM使用的空间是其在工作带上访问的单元格数量。复杂度类 **L**，也称为 DLOGSPACE，是所有可以由这样的TM使用 $O(\\log N)$ 工作带空间解决的判定问题的集合。\n\n设平衡突发的语言为 $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$。假设给TM的任何输入字符串 $w$ 都保证是一个有效的突发，即其形式为 $0^k 1^m$，其中 $k, m \\ge 1$ 是整数。问题是 $L_{bal}$ 是否属于类 **L**。\n\n下列哪个陈述提供了最准确和最根本的原因来解释判定 $L_{bal}$ 的空间复杂度？\n\nA. TM可以在输入带上为它找到的每一个'1'划掉一个'0'。由于这类操作不使用工作带，该算法在常数工作空间内运行，而常数空间是对数空间的子集。\nB. 语言 $L_{bal}$ 是一个确定性上下文无关语言（DCFL）。所有DCFL已知都可以在对数空间内判定，因此 $L_{bal}$ 必定在 **L** 中。\nC. TM可以使用其工作带维护一个二进制计数器。它可以扫描输入以计算'0'的数量，存储结果，然后将其与'1'的数量进行比较。二进制计数器所需的空间与其所持有的值的对数成正比，该值最多为输入长度。\nD. 这个问题可以由一个双向确定性有限自动机（2DFA）解决，而已知由2DFA判定的语言类是 **L** 的一个子集。\nE. 这个问题可以由一台非确定性TM解决，该TM猜测字符串的中点并验证两半部分。由于从 Immerman–Szelepcsényi 定理可知，非确定性对数空间（**NL**）等于 **L**，因此该问题在 **L** 中。", "solution": "正确陈述是C。让我们分析为什么它正确以及为什么其他选项不正确。\n\n问题要求一个算法，使用仅 $O(\\log N)$ 的工作带空间来判定语言 $L_{bal} = \\{0^n 1^n \\mid n \\ge 1\\}$，其中 $N$ 是输入字符串的长度。对于一个输入 $w = 0^n 1^n$，其长度为 $N = 2n$。\n\n**正确选项（C）的分析：**\n\n这个选项描述了一个可行的对数空间算法。一台具有只读输入带和工作带的确定性图灵机可以如下实现此算法：\n\n1.  在工作带上初始化一个二进制计数器为0。我们称这个计数器为 `C`。\n2.  从左到右扫描输入带。对于读头遇到的每个'0'，增加计数器 `C` 的值。\n3.  输入保证为 $0^k 1^m$ 的形式。当机器读到第一个'1'时，它已经完成了对'0'的计数。此时，计数器 `C` 的值为 $k$。\n4.  然后机器继续扫描输入带上的'1'。对于它读到的每个'1'，它减少计数器 `C` 的值。\n5.  在读头经过输入的最后一个字符后，机器检查计数器 `C` 的值。\n    *   如果 `C` 为0，这意味着'0'的数量等于'1'的数量（$k=m$）。机器接受。\n    *   如果 `C` 不为0，这意味着 $k \\ne m$。机器拒绝。\n    *   可以进行一个额外的检查：如果 `C` 变为负数（或在所有'1'被读取完之前达到0），这意味着 $k  m$，机器可以立即拒绝。\n\n让我们分析这个算法的空间复杂度。计数器上存储的最大值是 $k$，即'0'的数量。要以二进制形式存储一个整数 $k$，我们需要 $\\lfloor \\log_2 k \\rfloor + 1$ 个比特（带单元）。输入长度为 $N = k+m$。由于接受的输入必须是平衡的（$k=m=n$），因此 $N=2n$，空间为 $O(\\log n)$。在输入为 $0^k 1^m$ 的一般情况下，空间为 $O(\\log k)$。由于 $k  N$，所需的空间受 $O(\\log N)$ 的限制。因此，语言 $L_{bal}$ 是在对数空间内可判定的，且 $L_{bal} \\in \\mathbf{L}$。选项C正确地描述了这一基本机制。\n\n**不正确选项的分析：**\n\n*   **A:** 复杂度类 **L** 的标准定义假设图灵机具有*只读*输入带。因此，在该模型中，划掉或修改输入带不是一个有效的操作。即使使用可以修改输入带的不同模型，该带上使用的空间也会计入总空间复杂度，使其成为一个线性空间（$O(N)$）算法，而不是对数空间算法。\n\n*   **B:** 这个陈述包含两个断言。第一个，‘$L_{bal}$ 是一个确定性上下文无关语言（DCFL）’，是正确的。它可以通过一个确定性下推自动机来识别，该自动机为每个'0'执行压栈操作，为每个'1'执行弹栈操作。然而，第二个断言，‘所有DCFL已知都可以在对数空间内判定’，是错误的。类 DCFL 并不包含在 **L** 中。存在一些不确定是否在 **L** 中的 DCFL，并且普遍认为 $\\mathbf{L} \\subsetneq \\text{DCFL}$。\n\n*   **D:** 这个选项声称该问题可以由一个双向确定性有限自动机（2DFA）解决，这是一种可以在输入带上左右移动其读头的有限自动机。由2DFA判定的语言类是 **L** 的子集，这是正确的。然而，2DFA是否能判定语言 $\\{0^n 1^n\\}$ 是一个长期的开放问题。人们普遍推测它不能。因此，不能将此作为 $L_{bal}$ 在 **L** 中的有效理由。\n\n*   **E:** 这个陈述依赖于 $L = NL$ 的论断，其中 **NL** 是非确定性对数空间。这是计算复杂性理论中最著名的未解问题之一。虽然 Immerman–Szelepcsényi 定理证明了 $\\mathbf{NL} = \\text{co-}\\mathbf{NL}$，但它并未解决 $L$ vs $NL$ 的问题。人们普遍认为 $L \\ne NL$。因此，假设 $L = NL$ 来证明一个结论是错误的。无论如何，判定 $L_{bal}$ 的问题并不需要非确定性，正如C中的正确算法所示。", "answer": "$$\\boxed{C}$$", "id": "1452636"}, {"introduction": "在内存极度受限的环境中，我们必须重新思考算法设计中的时空权衡。这个练习探讨了如何在未排序的数组中查找重复元素——一个通常用哈希表或排序来高效解决的问题。您将学习到，通过牺牲计算时间（采用嵌套循环重复扫描输入），我们可以在严格的 $O(\\log n)$ 空间限制下解决这个问题，这揭示了对数空间算法设计的一个核心策略。[@problem_id:1452612]", "problem": "一个嵌入式系统被设计用于监控和验证来自传感器网络的数据日志的完整性。该系统具有极其有限的随机存取存储器（RAM），但它可以只读访问存储日志的大容量存储设备。某一天的日志表示为一个包含 $n$ 个整数值传感器读数的序列。如果任何传感器读数被记录超过一次，则会标记一个严重错误。\n\n形式上，输入是一个包含 $n$ 个整数的只读数组 $A$。数组中整数的值保证在范围 $[1, n^2]$ 内。输入的总大小被认为是 $O(n \\log n)$ 比特。你的任务是分析用于确定数组 $A$ 中是否存在至少一个重复值的算法。如果一个算法的辅助空间复杂度（除输入存储外使用的内存）为 $O(\\log n)$，则该算法被认为是“对数空间”算法。\n\n下列哪个提出的算法能正确确定数组 $A$ 是否包含任何重复值，并且在对数空间约束下运行？\n\nA. 初始化一个空的哈希集合。从第一个元素到最后一个元素遍历数组 $A$。对于每个元素 $A[i]$，检查它是否已在哈希集合中。如果是，则找到了一个重复项。如果不是，则将 $A[i]$ 添加到哈希集合中。如果到达数组末尾仍未找到重复项，则不存在重复项。\n\nB. 使用嵌套循环结构。外层循环使用索引 $i$ 从 $0$ 迭代到 $n-1$。内层循环使用索引 $j$ 从 $i+1$ 迭代到 $n-1$。在内层循环中，读取 $A[i]$ 和 $A[j]$ 的值并进行比较。如果 $A[i]$ 等于 $A[j]$，则找到了一个重复项。如果循环完成而没有找到任何匹配项，则不存在重复项。\n\nC. 首先，在内存中创建数组 $A$ 的一个可变副本。然后，对该副本应用一个原地排序算法，如 Heapsort。最后，遍历一次排序后的副本，将每个元素与其紧邻的下一个元素进行比较。如果任何两个相邻元素相同，则存在重复项。\n\nD. 使用索引 $i$ 从 $0$ 到 $n-2$ 遍历数组 $A$。在每次迭代中，将元素 $A[i]$ 与下一个元素 $A[i+1]$ 进行比较。如果它们相等，则找到了一个重复项，算法终止。如果循环完成，则不存在重复项。", "solution": "要解决这个问题，我们必须根据两个标准来分析每个提出的算法：正确性（如果存在重复项，它是否总能找到？）和空间复杂度（它是否在 $O(\\log n)$ 的辅助空间内运行？）。\n\n**选项A的分析：**\n该算法使用一个哈希集合来跟踪目前已经见过的元素。\n*   **正确性：** 该算法是正确的。如果遇到的元素 $A[i]$ 已经在哈希集合中，它必定是先前见过的元素的重复。如果循环完成，则意味着每个元素都是唯一的。\n*   **空间复杂度：** 所需空间由哈希集合的最大大小决定。在最坏情况下，即数组 $A$ 中的所有 $n$ 个元素都不同，哈希集合需要存储所有 $n$ 个元素。每个元素是最大为 $n^2$ 的整数，需要 $O(\\log(n^2)) = O(\\log n)$ 比特的存储空间。因此，总空间复杂度为 $O(n \\log n)$。这是多项式空间，而不是对数空间。所以，这个选项违反了空间约束。\n\n**选项B的分析：**\n该算法使用一对嵌套循环来比较数组中每一对不同的元素。\n*   **正确性：** 该算法是正确的。它对所有满足 $i  j$ 的元素对 $(A[i], A[j])$ 进行暴力检查。如果数组中存在重复的元素对，比如在索引 $p$ 和 $q$ 处（其中 $p  q$），算法最终会设置 $i=p$ 和 $j=q$，发现 $A[p] = A[q]$，并正确报告重复。如果不存在重复项，则不会找到这样的元素对。\n*   **空间复杂度：** 该算法需要内存来存储循环的状态和被比较的值。循环索引 $i$ 和 $j$ 的范围是从 $0$ 到 $n-1$。存储这样大小的整数大约需要 $\\log_2(n)$ 比特，即 $O(\\log n)$ 的空间。该算法还从输入数组中读取两个值 $A[i]$ 和 $A[j]$ 进行比较。问题说明这些值的范围在 $[1, n^2]$ 内。存储这样的值需要 $\\log_2(n^2) = 2 \\log_2(n)$ 比特，这也是 $O(\\log n)$ 的空间。总的辅助内存是这些少量变量的空间之和，即 $O(\\log n) + O(\\log n) = O(\\log n)$。因此，该算法满足对数空间约束。\n\n**选项C的分析：**\n该算法涉及复制数组、对副本进行排序，然后扫描相邻的重复项。\n*   **正确性：** 该算法是正确的。排序会把所有相同的元素聚集在一起，因此对排序后的数组进行单次遍历以检查相邻元素就足以找到重复项。\n*   **空间复杂度：** 第一步是“在内存中创建数组 $A$ 的一个可变副本”。正如在选项A的分析中确定的，数组 $A$ 包含 $n$ 个元素，每个元素需要 $O(\\log n)$ 比特。因此，一个完整的副本需要 $O(n \\log n)$ 的空间。这立即违反了 $O(\\log n)$ 的空间约束。问题还指出输入位于只读设备上，这使得对原始数据进行原地排序成为不可能，从而强调了需要一个副本。\n\n**选项D的分析：**\n该算法遍历数组，并且只将每个元素与其紧邻的下一个元素进行比较。\n*   **正确性：** 该算法是不正确的。问题说明数组 $A$ 是未排序的。重复项不保证出现在相邻位置。例如，考虑当 $n=4$ 时的数组 $A = [10, 20, 30, 10]$。重复的值是 10，但它的两个实例并不相邻。该算法会比较 $(10, 20)$、$(20, 30)$ 和 $(30, 10)$，找不到相等的值，并错误地得出没有重复项的结论。\n*   **空间复杂度：** 该算法使用一个索引 $i$，需要 $O(\\log n)$ 的空间。它的空间效率非常高，但由于它不能正确解决问题，因此是无效的。\n\n**结论：**\n只有算法B既能正确处理未排序的数组，又满足严格的 $O(\\log n)$ 空间复杂度要求。", "answer": "$$\\boxed{B}$$", "id": "1452612"}]}