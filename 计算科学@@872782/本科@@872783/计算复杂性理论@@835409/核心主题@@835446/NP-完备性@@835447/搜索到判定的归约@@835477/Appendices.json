{"hands_on_practices": [{"introduction": "我们从一个基础但非常普遍的场景开始。这个练习将向你展示如何通过系统地“删除”元素来将一个大的搜索空间缩小到一个具体的解。通过这个来自生物信息学的例子，你将学会最直接的搜索到判定转化策略，即逐个测试问题中的每个组件的重要性。[@problem_id:1446692]", "problem": "在生物信息学领域，研究人员将蛋白质-蛋白质相互作用（PPI）网络建模为图，其中蛋白质是顶点，两个蛋白质之间的显著相互作用是一条边。一项关键任务是寻找功能“基序”，它们是小的、重复出现的相互作用模式。\n\n假设你是一名计算生物学家，正在处理一个大型PPI网络，该网络由一个图 $G=(V, E)$ 表示，其中 $|V|=n$。你正在寻找一个特定的、已知的功能基序，它由一个较小的图 $H=(V_H, E_H)$ 表示，其中 $|V_H|=k$。该基序预计在 $G$ 中以*导出子图*的形式出现。由顶点子集 $S \\subseteq V$ 导出的 $G$ 的子图是一个包含顶点 $S$ 以及 $E$ 中连接 $S$ 内两个顶点的所有边的图。\n\n你可以使用一个名为 `HAS_MOTIF` 的假设的、复杂的计算服务。该服务充当一个判定预言机：你向它提供任何图 $G'$，如果 $G'$ 包含一个与 $H$ 同构的导出子图，它会立即返回 YES，否则返回 NO。该服务每次使用的成本非常高，但你已经通过一次初始调用确认了 `HAS_MOTIF(G)` 返回 YES。\n\n你的任务是设计一个算法，利用 `HAS_MOTIF` 预言机来找到 $G$ 中构成基序 $H$ 实例的那 $k$ 个顶点的实际集合。你的算法需要对 `HAS_MOTIF` 预言机进行的最大调用次数是多少，才能保证找到一个此类基序的顶点集？请将你的答案表示为 $n$ 和 $k$ 的函数。", "solution": "我们给定一个判定预言机 HAS_MOTIF，对于任何输入图，当且仅当该图包含一个与具有 $k$ 个顶点的固定模式 $H$ 同构的导出子图时，它才返回 YES。我们已经确认对于初始图 $G=(V,E)$（其中 $|V|=n$），HAS_MOTIF$(G)$ 返回 YES。目标是找到一个特定的顶点集 $S \\subseteq V$（其中 $|S|=k$），它在 $G$ 中导出一个 $H$ 的副本，同时最小化额外的预言机调用次数。\n\n我们设计一个自归约算法，通过逐个删除顶点来收缩图，并始终保持当前图仍然包含一个 $H$ 的导出副本这一性质。过程如下：\n1. 初始化当前图 $G_{current} := G$。\n2. 当 $G_{current}$ 的顶点数大于 $k$ 时，我们必须找到一个可以安全移除的顶点。\n3. 我们遍历 $G_{current}$ 中的顶点 $v$。对于每一个 $v$，我们查询预言机 `HAS_MOTIF`$(G_{current} - v)$。\n   - 如果返回 YES，这意味着即使移除了 $v$，$G_{current}$ 中仍然存在一个基序。这说明 $v$ 不是构成所有剩余基序的必需部分。因此，我们可以安全地将 $v$ 永久移除。我们更新 $G_{current} := G_{current} - v$，然后回到步骤2，开始寻找下一个要移除的顶点。\n   - 如果返回 NO，这意味着 $v$ 是 $G_{current}$ 中所有现存基序的必需部分。我们不能移除它，所以我们继续遍历 $G_{current}$ 中的下一个顶点，直到找到一个可以移除的顶点。\n\n正确性：由于我们知道 $G_{current}$（初始为 $G$）包含一个 $k$ 顶点的基序，而其当前的顶点数大于 $k$，所以图中必然至少存在一个不属于*某个*基序的顶点。因此，在步骤3的遍历中，我们保证能找到一个返回 YES 的顶点并将其移除。我们重复此过程，直到图的大小恰好为 $k$。此时，这个 $k$-顶点图根据我们的不变量，必然包含一个 $H$ 的导出副本，因此它本身就与 $H$ 同构。其顶点集就是我们所求的解。\n\n查询复杂度上界：我们需要移除 $n-k$ 个顶点才能将图的大小从 $n$ 减少到 $k$。在最坏的情况下，为了找到一个可以移除的顶点，我们可能需要多次调用预言机。假设当前图有 $m$ 个顶点，而其中一个 $k$ 顶点基序的顶点集合为 $S_{motif}$。我们最坏的情况是先测试了 $S_{motif}$ 中的所有 $k$ 个顶点，预言机都返回 NO。但是，当我们测试第 $k+1$ 个顶点时（它必然不在 $S_{motif}$ 中），预言机一定会返回 YES。因此，为了移除一个顶点，最多需要 $k+1$ 次调用。但是，一个更紧密的分析表明，总调用次数不会超过 $n$。\n一个更简洁的论证是：我们总共需要进行 $n-k$ 次成功的删除（YES 回答）。每次我们得到 NO 的回答，我们都识别出了一个对于当前图中所有解都必不可少的顶点。由于最终的解只有 $k$ 个顶点，我们在整个过程中最多只能识别出 $k$ 个不同的“必不可少”的顶点。因此，NO 回答的总数最多为 $k$。\n因此，算法进行的总预言机调用次数最多为：\n$$(\\text{YES 回答数}) + (\\text{NO 回答数}) \\le (n-k) + k = n$$\n此计数假定我们利用了初始 `HAS_MOTIF(G)` 为 YES 的信息，无需重复该调用。因此，该算法保证最多通过 $n$ 次对 `HAS_MOTIF` 的调用找到一个有效的 $H$ 的 $k$-顶点实例。", "answer": "$$\\boxed{n}$$", "id": "1446692"}, {"introduction": "在掌握了基本的迭代移除策略后，我们将探索一种更高效的组合方法。这个练习结合了二分搜索和自归约技术，首先确定最优解的“规模”，然后才去构造解本身。通过解决这个项目管理中的依赖问题，你将学会一种强大的两阶段模式，这在处理优化问题时非常有用。[@problem_id:1446683]", "problem": "一家大型软件公司的项目经理正在监督一个包含 $N$ 个不同编程任务的项目。这些任务相互依赖；例如，任务A可能需要在任务B开始之前完成。这些依赖关系可以用一个有向图 $G$ 来表示，其中每个任务是一个顶点，从顶点 $u$ 到顶点 $v$ 的有向边表示任务 $u$ 必须在任务 $v$ 之前完成。\n\n不幸的是，由于规划不善，任务依赖图中包含了循环依赖（即有向环）。例如，任务A依赖于B，B依赖于C，而C又依赖于A。这样的环路使得无法确定一个有效的任务执行顺序。为了解决这个问题，经理必须“外包”一部分任务，这等同于从图中移除相应的顶点（及其关联的边）。目标是外包一个规模尽可能小的任务集合，以打破所有的环路。\n\n该经理可以访问一个专门的外部咨询服务，这个服务充当一个预言机。该服务提供一个函数 `CAN_BREAK(G', k)`，它接受一个任务图 $G'$ 和一个整数 $k$。如果通过外包最多 $k$ 个任务可以打破 $G'$ 中的所有环路，该函数返回`True`，否则返回`False`。\n\n设计一个高效的算法，利用 `CAN_BREAK` 预言机来找到一个必须外包的最小规模的特定任务集合。在最坏情况下，你的算法需要调用 `CAN_BREAK` 预言机总共多少次？请用 $N$（任务总数）的函数来表示你的答案。", "solution": "设 $G=(V,E)$ 是有向任务图，其中 $|V|=N$。要找的解是一个最小反馈顶点集（FVS）。预言机 `CAN_BREAK(G, k)` 判断图 $G$ 是否存在一个大小不超过 $k$ 的反馈顶点集。我们将其表示为谓词 $P(k) \\equiv \\text{CAN\\_BREAK}(G, k)$，这个谓词在 $k$ 上是单调非递减的：如果可以用 $k$ 个顶点打破所有环路，那么用任何大于 $k$ 的数量也一定可以。\n\n算法分两步进行：\n\n步骤1（找到最小规模 $k^{\\ast}$）。我们利用 $P(k)$ 的单调性，在 $k$ 的取值范围 $\\{0, 1, \\ldots, N\\}$ 上进行二分搜索，以找到使得 $P(k)$ 为真的最小整数 $k^{\\ast}$。此过程最多需要 $\\lceil \\log_{2}(N+1) \\rceil$ 次预言机调用。\n\n步骤2（自归约构造解）。在确定了最小规模 $k^{\\ast}$ 之后，我们通过自归约来构造一个具体的解集。我们按任意固定顺序遍历所有 $N$ 个原始任务（顶点）。我们维护一个当前图 $H$（初始为 $G$），一个当前解集 $S$（初始为空），以及一个剩余预算 $r$（初始为 $k^{\\ast}$）。\n对于原图中的每个顶点 $v$：\n我们测试从当前图 $H$ 中移除 $v$ 的后果。我们向预言机查询 `CAN_BREAK(H - {v}, r)`。\n - 如果返回“假”（False），这意味着在当前图 $H$ 中，任何大小为 $r$ 的解都必须包含 $v$。因此，$v$ 是一个必需的成员。我们将 $v$ 加入解集 $S$，并将预算减一，即 $r := r-1$。\n - 如果返回“真”（True），这意味着在 $H$ 中存在一个大小为 $r$ 的解不包含 $v$。因此，$v$ 不是必需的，我们可以将它排除在解集之外，同时保持预算 $r$ 不变。\n在任何一种情况下，我们都已对 $v$ 作出决策，因此我们从当前图 $H$ 中移除 $v$ 以便在更小的图上考虑下一个顶点。\n\n我们对所有 $N$ 个顶点都执行此决策一次。在此过程中，图 $H$ 不断缩小，并且我们准确地识别出构成一个最小解集所需的全部成员。此阶段需要 $N$ 次预言机调用。\n\n总预言机调用次数：将两步的调用次数相加，最坏情况下的总调用次数为 $N + \\lceil \\log_{2}(N+1) \\rceil$ 次。", "answer": "$$\\boxed{N+\\lceil \\log_{2}(N+1)\\rceil}$$", "id": "1446683"}, {"introduction": "搜索到判定转化的思想并不局限于图论问题。这个练习将带你进入数论领域，在一个有界但可能非常大的空间内寻找解的组成部分。通过设计一个算法，迭代地确定解的每个分量，你将解决一个经典的数论问题，并学会分析其在不同搜索空间结构下的复杂度。[@problem_id:1446695]", "problem": "在计算复杂性理论领域，搜索到决策归约（search-to-decision reduction）是一种使用相应决策问题的预言机来解决搜索问题的方法。搜索问题需要找到一个解，而决策问题只询问是否存在解。\n\n考虑将一个整数表示为平方和的问题，这是数论和计算机科学中一个备受关注的课题。假设您可以使用一个特定的计算预言机，我们称之为 `DECIDE_SUM_SQUARES`。这个预言机接受两个输入：一个非负整数 $M$ 和一个正整数 $j$。如果 $M$ 可以表示为 $j$ 个非负整数的平方和（即，如果存在非负整数 $y_1, y_2, \\ldots, y_j$ 使得 $y_1^2 + y_2^2 + \\dots + y_j^2 = M$），它返回 `True`，否则返回 `False`。您可以假设每次调用此预言机花费常数时间。\n\n您的任务是设计一个算法，利用这个预言机来解决相应的搜索问题：对于给定的非负整数 $N$ 和正整数 $k$，找到一组 $k$ 个非负整数 $\\{x_1, x_2, \\ldots, x_k\\}$ 使得 $x_1^2 + x_2^2 + \\dots + x_k^2 = N$。\n\n假设对于给定的输入 $N$ 和 $k$，解总是保证存在的，请确定您的算法为找到这样一组整数所需调用 `DECIDE_SUM_SQUARES` 预言机的最大次数。将您的答案表示为 $N$ 和 $k$ 的函数。", "solution": "我们构建一个标准的搜索到决策自归约（search-to-decision self-reduction），该算法使用预言机一次确定一个平方项。算法维护一个剩余和以及剩余的平方项数量。\n\n算法：\n- 初始化剩余和 $R := N$ 以及剩余数量 $j := k$。\n- 对于从 $1$ 到 $k-1$ 的每个位置 $i$（等价地，当 $j \\geq 2$ 时）：\n  - 对于从 $0$ 到 $\\lfloor \\sqrt{R} \\rfloor$ 的 $t$：\n    - 查询 $\\texttt{DECIDE\\_SUM\\_SQUARES}(R - t^{2}, j-1)$。\n    - 如果预言机返回 True，则设置 $x_{i} := t$，更新 $R := R - t^{2}$ 和 $j := j-1$，并跳出内层循环以移动到下一个位置。\n- 当 $j = 1$ 时，剩余的 $R$ 必定是一个完全平方数（由预言机响应保证的不变性），因此设置 $x_{k} := \\sqrt{R}$，无需再调用预言机。\n\n正确性可以通过归纳法得出：在每个阶段，如果预言机对某个 $t$ 返回 True，则余数 $R - t^{2}$ 可以表示为 $j-1$ 个平方的和，因此继续这个过程将得到一个完整的表示。因为保证对于给定的 $N$ 和 $k$ 存在解，所以在每个阶段，$\\{0,1,\\ldots,\\lfloor \\sqrt{R} \\rfloor\\}$ 中至少有一个 $t$ 会成功。\n\n预言机调用复杂度：\n- 在一个固定的阶段，剩余和为 $R$，剩余数量为 $j \\geq 2$，我们按递增顺序尝试 $t$。在最坏的情况下，成功的 $t$ 是最后一个尝试的，因此该阶段的预言机调用次数最多为 $\\lfloor \\sqrt{R} \\rfloor + 1$。\n- 由于在整个过程中 $R \\leq N$，每个阶段最多使用 $\\lfloor \\sqrt{N} \\rfloor + 1$ 次预言机调用。\n- 这样的阶段正好有 $k-1$ 个（当 $j=1$ 时我们不需要任何调用）。\n\n因此，该算法使用的预言机调用次数的绝对最坏情况上界，表示为 $N$ 和 $k$ 的函数，是\n$$\n(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr).\n$$\n这个界限是该算法作为一个保证而达到的，与剩余和如何演变无关，并且它与直观的 $O(k \\sqrt{N})$ 行为以及一个精确的表达式相匹配。", "answer": "$$\\boxed{(k-1)\\bigl(\\lfloor \\sqrt{N} \\rfloor + 1\\bigr)}$$", "id": "1446695"}]}