{"hands_on_practices": [{"introduction": "当我们初次面对子集和问题时，一个常见的直觉是采用贪心策略——即每次都选择可选集合中最大的数。这个练习旨在通过一个具体的反例，清晰地揭示为什么这种看似合理的简单方法并不能保证找到正确解 [@problem_id:1463403]。理解贪心算法的局限性，是认识子集和问题内在复杂性并探索更优算法的第一步。", "problem": "一名计算机专业的学生正在研究子集和问题（Subset-Sum problem），该问题旨在判断一个给定的整数集合中，是否存在一个非空子集，其元素之和等于一个特定的目标值。该学生实现了一个贪心算法来解决这个问题。该算法的工作流程如下：\n\n1.  从一个空的解子集和初始目标值 $T$ 开始。\n2.  从可用整数集合 $S$ 中，选择小于或等于剩余目标值的最大整数。\n3.  将这个整数添加到解子集中，并从剩余目标值中减去它的值。\n4.  从可用集合 $S$ 中移除所选的整数。\n5.  重复步骤2-4，直到剩余目标值变为零（找到解）或没有更多整数可选（算法失败）。\n\n该学生在整数集合 $S = \\{10, 7, 6, 5\\}$ 上测试此算法，目标值为 $T = 12$。贪心算法未能找到解。然而，一个和为 $T$ 的有效子集确实存在。以下哪个是正确的子集？\n\nA. $\\{10\\}$\n\nB. $\\{7, 6\\}$\n\nC. $\\{7, 5\\}$\n\nD. $\\{5, 6\\}$\n\nE. 不存在这样的子集", "solution": "问题要求我们找出 $S = \\{10, 7, 6, 5\\}$ 的一个正确子集，其和为目标值 $T = 12$。题目告诉我们，一个特定的贪心算法未能找到这个解。我们首先追踪贪心算法的执行过程来理解它为什么会失败，然后我们将检查给出的选项以找到正确的解。\n\n首先，让我们追踪所描述的贪心算法。\n整数集合为 $S = \\{10, 7, 6, 5\\}$，目标值为 $T = 12$。$S$ 中的整数已经按降序排列，这对于贪心选择过程很方便。\n\n步骤 1：当前目标值为12。$S$ 中最大的整数是10。由于 $10 \\le 12$，算法选择10。\n- 部分解子集现在是 $\\{10\\}$。\n- 剩余目标值变为 $12 - 10 = 2$。\n- 可用整数集合变为 $\\{7, 6, 5\\}$。\n\n步骤 2：当前目标值为2。可用整数为 $\\{7, 6, 5\\}$。\n- 最大的可用整数是7。由于 $7 > 2$，不能选择它。\n- 次大的可用整数是6。由于 $6 > 2$，不能选择它。\n- 再次大的可用整数是5。由于 $5 > 2$，不能选择它。\n\n步骤 3：可用集合中没有剩下的整数小于或等于剩余目标值2。算法终止，未能将目标值减到0。贪心方法只找到了子集 $\\{10\\}$，其和为10，而不是12。因此，贪心算法失败了，正如问题所述。\n\n现在，我们需要找到正确的子集。我们可以通过检查提供的多项选择题选项来做到这一点。\n\nA. 子集是 $\\{10\\}$。其元素之和为10。这不等于目标值 $T = 12$。\n\nB. 子集是 $\\{7, 6\\}$。其元素之和为 $7 + 6 = 13$。这不等于目标值 $T = 12$。\n\nC. 子集是 $\\{7, 5\\}$。其元素之和为 $7 + 5 = 12$。这等于目标值 $T = 12$。这是一个有效的解。\n\nD. 子集是 $\\{5, 6\\}$。其元素之和为 $5 + 6 = 11$。这不等于目标值 $T = 12$。\n\nE. 这个选项声称不存在这样的子集。这是错误的，因为我们在选项C中找到了一个有效的子集。\n\n因此，和为 $T=12$ 的 $S$ 的正确子集是 $\\{7, 5\\}$。", "answer": "$$\\boxed{C}$$", "id": "1463403"}, {"introduction": "既然简单的贪心算法不可行，我们需要更严谨的方法。动态规划是解决子集和问题的标准算法，其时间复杂度为 $O(n T)$。然而，这个练习 [@problem_id:1463375] 引导我们进行更深层次的思考：算法的效率不仅取决于其步骤数量，还与输入的编码方式息息相关。通过对比二进制和一元制编码，本题挑战我们去理解伪多项式时间的概念，并揭示了计算复杂性理论的一个核心洞见。", "problem": "子集和问题（SUBSET-SUM）是计算复杂性理论中一个经典的决策问题。它要求判断一个给定的非负整数集合 $S = \\{s_1, s_2, \\dots, s_n\\}$ 中是否存在一个非空子集，其元素之和等于一个给定的目标整数 $T$。\n\n解决此问题的一个标准方法是使用动态规划（DP）算法。该算法构建一个二维布尔表 `can_sum[i][j]`，其中 `can_sum[i][j]` 为真的条件是当且仅当可以使用前 `i` 个整数 $\\{s_1, \\dots, s_i\\}$ 的一个子集构成和为 `j`。该表的大小为 $(n+1) \\times (T+1)$，并且每个条目都可以根据先前的条目在常数时间内计算得出。这使得总时间复杂度为 $O(n T)$。\n\n通常，我们假设输入数字是以二进制编码的。那么，输入的大小就是表示集合 $S$ 中所有整数和目标 $T$ 所需的总比特数。在这种二进制编码下，$O(n T)$ 的运行时间被归类为伪多项式时间，因为 $T$ 的值可能比表示它所用的比特数（约为 $\\log_2 T$）大指数级别。\n\n现在，设想一个不同的场景，其中集合 $S$ 中的所有整数和目标 $T$ 都是以一元编码（unary encoding）提供的。在一元系统中，整数 $k$ 由一个包含 $k$ 个相同符号的字符串表示（例如，数字 5 可以表示为 '11111'）。因此，一元编码输入的大小是所涉及的所有整数的数值之和。\n\n对于同样的 $O(n T)$ 动态规划算法，你将如何根据这种新的一元编码输入的规模来对其时间复杂度进行分类？\n\n从以下选项中选择最准确的陈述。\n\nA. 该算法在多项式时间内运行，这意味着这个版本的子集和问题（使用一元输入）属于复杂性类别 P。\n\nB. 该算法仍然是伪多项式时间的，因为其运行时间仍然取决于目标 $T$ 的数值大小。\n\nC. 该算法的运行时间相对于输入规模变为指数级的，使其效率低于二进制编码。\n\nD. 子集和问题本身的复杂性类别从 NP-完全 变为 P，无论使用何种算法。\n\nE. 无法进行运行时间分析，因为元素数量 $n$ 与一元输入的大小无关。", "solution": "我们已知用于解决子集和问题的动态规划算法会构建一个大小为 $(n+1)\\times(T+1)$ 的表，并在假设每个表项都可由先前表项在常数时间内计算得出的情况下，以 $O(nT)$ 的时间运行。\n\n我们将此运行时间与一元编码下的输入规模进行比较。设输入为集合 $S=\\{s_{1},\\dots,s_{n}\\}$ 和目标 $T$。在一元编码中，每个 $s_{i}$ 的表示长度为 $\\Theta(s_{i})$，而 $T$ 的表示长度为 $\\Theta(T)$。考虑到分隔符或列表结构，会额外增加 $\\Theta(n)$ 个符号。因此，总输入长度 $L$ 满足\n$$\nL=\\Theta\\!\\left(T+\\sum_{i=1}^{n} s_{i}+n\\right).\n$$\n特别地，这意味着对于合适的正常数 $c_{1}$ 和 $c_{2}$，有以下界限\n$$\nT \\leq c_{1} L,\\quad n \\leq c_{2} L\n$$\n因为 $T$ 和 $n$ 各自都受总长度的支配。因此，算法的时间 $O(nT)$ 可以用 $L$ 来表示其上界，即\n$$\nO(nT) = O((c_{2}L)(c_{1}L)) = O(L^{2}),\n$$\n这相对于一元输入规模是多项式的。\n\n因此，在一元编码下，该 $O(nT)$ 的动态规划算法相对于输入规模在多项式时间内运行。因此，根据此算法分析，一元编码版本的子集和问题属于复杂性类别 P。相对于一元输入规模，它不再仅仅是伪多项式时间，也没有理由声称其运行时间呈指数级增长。\n\n因此，最准确的选项是：该算法在多项式时间内运行，从而将这个一元编码版本的子集和问题归入 P 类。", "answer": "$$\\boxed{A}$$", "id": "1463375"}, {"introduction": "在找到一个可行的算法（如动态规划）之后，优化其资源消耗（如时间和空间）是算法设计的关键环节。标准的动态规划解法虽然正确，但其 $O(n \\cdot t)$ 的空间复杂度在目标和 $t$ 很大时可能变得无法接受。这个练习 [@problem_id:1463442] 专注于分析并优化动态规划算法的空间复杂度，引导你发现计算过程中的依赖关系，并掌握一种将空间从 $O(n \\cdot t)$ 压缩至 $O(t)$ 的经典技巧。", "problem": "子集和问题（SUBSET-SUM problem）是计算机科学中的一个经典问题：给定一个非负整数集合 $S = \\{s_1, s_2, \\ldots, s_n\\}$ 和一个目标整数和 $t$，判断是否存在 $S$ 的一个非空子集，其元素之和恰好为 $t$。\n\n解决此问题的一个标准方法是使用动态规划（Dynamic Programming, DP）。我们可以构建一个大小为 $(n+1) \\times (t+1)$ 的二维布尔表，称之为 $P$。表中的一个条目 $P[i][j]$ 为 `true` 表示可以使用前 $i$ 个元素 $\\{s_1, \\ldots, s_i\\}$ 的一个子集构成和 $j$，否则为 `false`。该表使用以下递推关系填充：\n$P[i][j] = P[i-1][j] \\lor P[i-1][j - s_i]$\n（其中第二项仅在 $j \\ge s_i$ 时考虑）。基本情况通常是 $P[0][0] = \\text{true}$ 和 $P[0][j] = \\text{false}$（对于 $j > 0$）。问题的最终答案由 $P[n][t]$ 给出。\n\n分析这个标准算法的空间复杂度以及优化它的逻辑。请考虑以下陈述：\n\nI. 上述标准的二维动态规划算法的空间复杂度为 $O(n \\cdot t)$。\nII. 通过注意到只需要前一列的值，空间复杂度可以优化到 $O(n + t)$。\nIII. 空间优化是可能的，因为任何状态 $(i, j)$（使用前 $i$ 个元素构成和 $j$）的计算仅依赖于前一行 $i-1$ 的状态。\nIV. 为了使用单个一维数组实现此优化，遍历可能和 $j$ 的内层循环必须按递增顺序处理（例如，从 $j = s_i$ 到 $j = t$）。\n\n以上哪些陈述是正确的？\n\nA. 仅 I\n\nB. 仅 I 和 III\n\nC. 仅 II 和 IV\n\nD. I, III, 和 IV\n\nE. 以上全部", "solution": "我们如下定义动态规划表：对于整数 $i \\in \\{0,1,\\ldots,n\\}$ 和 $j \\in \\{0,1,\\ldots,t\\}$，令 $P[i][j]$ 为一个布尔值，表示 $\\{s_{1},\\ldots,s_{i}\\}$ 的某个子集之和是否为 $j$。递推关系为\n$$\nP[i][j] = P[i-1][j] \\lor \\bigl(j \\ge s_{i} \\land P[i-1][j - s_{i}]\\bigr),\n$$\n基本情况为 $P[0][0] = \\text{true}$ 和 $P[0][j] = \\text{false}$（对于所有 $j > 0$）。\n\n陈述 I：该表有 $(n+1)(t+1)$ 个布尔条目。因此，标准二维动态规划使用的空间为 $\\Theta(n t)$，即 $O(n \\cdot t)$。因此，陈述 I 是正确的。\n\n陈述 III：从递推关系来看，每个 $P[i][j]$ 仅依赖于 $P[i-1][j]$ 和 $P[i-1][j - s_{i}]$，即只依赖于索引为 $i-1$ 的前一行。这种在 $i$ 上的局部性正是空间优化成为可能的原因。因此，陈述 III 是正确的。\n\n空间优化逻辑：定义一个一维数组 $D[j]$ 来表示和为 $j \\in \\{0,\\ldots,t\\}$ 的当前行的值。为了原地模拟从行 $i-1$到行 $i$ 的转换，我们必须确保在计算更新\n$$\nD[j] \\leftarrow D[j] \\lor D[j - s_{i}],\n$$\n时，所使用的值 $D[j - s_{i}]$ 来自前一行，而不是当前行中已经更新过的值。这可以通过将 $j$ 从 $t$ 向下递减迭代到 $s_{i}$ 来实现。结果， $D$ 只需要 $O(t)$ 的空间，外加用于索引和临时变量的常数额外空间，因此优化后的空间是 $O(t)$。\n\n陈述 II：它声称通过只使用前一列，优化后的空间为 $O(n + t)$，但依赖关系是在前一行上，并且标准的优化使用一个长度为 $t+1$ 的一维数组，实现 $O(t)$ 的空间复杂度，而不是 $O(n + t)$。因此，陈述 II 是不正确的。\n\n陈述 IV：它声称内层循环必须按递增顺序处理 $j$。如上所示，递增顺序将允许 $s_{i}$ 被多次重复使用，因为 $D[j - s_{i}]$ 可能已经包含了当前迭代中 $s_{i}$ 的贡献。例如，在将 $D[s_{i}]$ 设置为 true 后，递增扫描将允许 $D[2 s_{i}] \\leftarrow D[2 s_{i}] \\lor D[s_{i}]$ 变为 true，这相当于使用了两次 $s_{i}$，对于 0-1 子集问题来说是不正确的。因此我们必须按递减顺序迭代 $j$，陈述 IV 是错误的。\n\n因此，只有陈述 I 和 III 是正确的。", "answer": "$$\\boxed{B}$$", "id": "1463442"}]}