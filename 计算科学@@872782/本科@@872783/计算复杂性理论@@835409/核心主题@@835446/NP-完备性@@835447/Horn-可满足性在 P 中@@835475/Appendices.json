{"hands_on_practices": [{"introduction": "要掌握 Horn-SAT 算法，最好的方法就是亲手实践。这个练习将带你一步步模拟求解 Horn 公式的“标记”过程，让你直观地感受这个多项式时间算法是如何通过迭代推理，从一组初始事实和规则中确定哪些变量最终必须为真的。通过一个软件特征激活的场景，你可以清楚地看到逻辑蕴含关系如何逐步传播，最终达到一个稳定的不动点。 [@problem_id:1427138]", "problem": "一个用于管理软件功能激活的系统由六个布尔特征的状态定义，这些特征由变量 $x_1, x_2, x_3, x_4, x_5, x_6$ 表示。变量值为1表示相应功能为“开启”(`ON`)，而值为0表示为“关闭”(`OFF`)。\n\n系统的状态由一个应用一组规则的迭代激活算法确定。该过程如下：\n1.  最初，所有功能都设置为“关闭”(`OFF`)（所有变量均为0）。\n2.  然后，系统应用一组激活规则。这是分轮次进行的。在每一轮中，算法检查每条规则。如果当前“开启”(`ON`)的功能集满足某条规则的先决条件，则该规则的目标功能将被“开启”(`ON`)（其变量设置为1）。\n3.  这个分轮次应用规则的过程会一直持续，直到完整的一轮结束后没有任何新功能被“开启”(`ON`)。\n\n系统的激活规则如下：\n- **规则1：** 功能1为“开启”(`ON`)。\n- **规则2：** 功能2为“开启”(`ON`)。\n- **规则3：** 如果功能1为“开启”(`ON`)，则功能3被“开启”(`ON`)。\n- **规则4：** 如果功能3和功能4为“开启”(`ON`)，则功能5被“开启”(`ON`)。\n- **规则5：** 如果功能5为“开启”(`ON`)，则功能6被“开启”(`ON`)。\n- **规则6：** 如果功能2和功能6为“开启”(`ON`)，则功能4被“开启”(`ON`)。\n\n算法完成后，这些功能的最终状态是什么？该状态应表示为向量 $(x_1, x_2, x_3, x_4, x_5, x_6)$。\n\nA. (1, 1, 0, 0, 0, 0)\n\nB. (1, 1, 1, 0, 0, 0)\n\nC. (1, 1, 1, 1, 0, 0)\n\nD. (1, 1, 1, 1, 1, 1)\n\nE. (1, 0, 1, 0, 0, 0)", "solution": "我们将这些规则形式化为关于布尔变量 $x_{1},\\dots,x_{6}$ 的蕴含关系：\n- 规则1：$x_{1}=1$。\n- 规则2：$x_{2}=1$。\n- 规则3：$x_{1}=1 \\Rightarrow x_{3}=1$。\n- 规则4：$(x_{3}=1) \\land (x_{4}=1) \\Rightarrow x_{5}=1$。\n- 规则5：$x_{5}=1 \\Rightarrow x_{6}=1$。\n- 规则6：$(x_{2}=1) \\land (x_{6}=1) \\Rightarrow x_{4}=1$。\n\n该算法从全零状态开始，并重复应用这些蕴含关系，直到完整一轮中没有新的变量变为$1$。设第 $t$ 轮后的状态表示为 $x^{(t)}=(x_{1}^{(t)},x_{2}^{(t)},x_{3}^{(t)},x_{4}^{(t)},x_{5}^{(t)},x_{6}^{(t)})$。\n\n初始化得到\n$$\nx^{(0)}=(0,0,0,0,0,0).\n$$\n\n第1轮：\n- 根据规则1和规则2，我们设置 $x_{1}^{(1)}=1$ 和 $x_{2}^{(1)}=1$。\n- 由于 $x_{1}^{(1)}=1$，规则3适用，所以 $x_{3}^{(1)}=1$。\n- 规则4需要 $x_{3}=1$ 和 $x_{4}=1$ 同时成立，但 $x_{4}^{(1)}=0$，因此不适用。\n- 规则5需要 $x_{5}=1$，该条件不满足，因此不适用。\n- 规则6需要 $x_{2}=1$ 和 $x_{6}=1$ 同时成立，但 $x_{6}^{(1)}=0$，因此不适用。\n因此，在第1轮结束时，\n$$\nx^{(1)}=(1,1,1,0,0,0).\n$$\n\n第2轮：\n- 规则1、2和3已经满足，除了 $x_{1}=1$、$x_{2}=1$、$x_{3}=1$ 之外没有产生新的变化。\n- 规则4仍然不满足，因为它除了需要 $x_{3}=1$ 外还需要 $x_{4}=1$，但 $x_{4}=0$。\n- 规则5仍然不满足，因为它需要 $x_{5}=1$，而这是假的。\n- 规则6仍然不满足，因为它需要 $x_{6}=1$，而这是假的。\n在这一轮中没有新的功能被开启，所以算法终止。\n\n因此最终状态是\n$$\n(x_{1},x_{2},x_{3},x_{4},x_{5},x_{6})=(1,1,1,0,0,0),\n$$\n这对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1427138"}, {"introduction": "在理解了如何为可满足的 Horn 公式找到一个模型之后，一个自然的问题是：当一个公式不可满足时，我们如何定位其矛盾的根源？这个练习要求你从一个已知的不可满足公式中，找出一个最小的子句集合，它本身就是不可满足的。这能帮助你更深入地理解 Horn 子句中的逻辑推导链条，以及如何通过一系列蕴含关系最终推导出假（$\\text{false}$）。 [@problem_id:1427107]", "problem": "霍恩子句（Horn clause）是至多包含一个正文字的子句（文字的析取）。它们通常可以方便地写成蕴涵式。霍恩子句有三种类型：\n1.  **事实**（或单元子句）：只有一个正文字的子句，例如 $p$。这可以看作是一个前提为空的蕴涵式：$\\text{true} \\rightarrow p$。\n2.  **规则**（或定子句）：有一个正文字和一个或多个负文字的子句，例如 $(\\neg x_1 \\lor \\neg x_2 \\lor y)$。这在逻辑上等价于蕴涵式 $(x_1 \\land x_2) \\rightarrow y$。\n3.  **目标**（或负子句）：只有负文字的子句，例如 $(\\neg x_1 \\lor \\neg x_2)$。这等价于 $(x_1 \\land x_2) \\rightarrow \\text{false}$。\n\n霍恩公式（Horn formula）是霍恩子句的合取。考虑下面的霍恩公式 $\\Phi$，它是下面列出的八个子句的合取，涉及命题变量 $p, q, r, s, t, u, v$。已知该公式是不可满足的。\n\n- C1: $p$\n- C2: $q$\n- C3: $p \\rightarrow r$\n- C4: $q \\rightarrow s$\n- C5: $(r \\land s) \\rightarrow t$\n- C6: $(p \\land q) \\rightarrow u$\n- C7: $t \\rightarrow v$\n- C8: $t \\rightarrow \\text{false}$\n\n如果 $\\Phi$ 的一个子句子集本身是不可满足的，但从中移除任何一个子句都会得到一个可满足的公式，则称该子集为*最小不可满足子集*。\n\n下列哪个子句集合构成了 $\\Phi$ 的一个最小不可满足子集？\n\nA. {C1, C2, C3, C4, C5, C8}\n\nB. {C1, C2, C3, C4, C5, C7, C8}\n\nC. {C1, C2, C3, C4, C5, C6, C8}\n\nD. {C1, C2, C5, C8}\n\nE. {C1, C2, C3, C4, C5, C6, C7, C8}", "solution": "我们使用霍恩子句上的前向链来分析每个候选集合。推导出矛盾的唯一方法是推导出 $t$，然后使用 $t \\rightarrow \\text{false}$。\n\n集合 A: {C1, C2, C3, C4, C5, C8}。\n- 不可满足性：从 C1 我们有 $p$。结合 C3，我们从 $p \\rightarrow r$ 得到 $r$。从 C2 我们有 $q$。结合 C4，我们从 $q \\rightarrow s$ 得到 $s$。结合 C5，即 $(r \\land s) \\rightarrow t$，我们推导出 $t$。结合 C8，即 $t \\rightarrow \\text{false}$，我们推导出 $\\text{false}$。因此该集合是不可满足的。\n- 最小性：移除任何一个子句都会阻止推导出 $t$ 或阻止最终的矛盾：\n  - 移除 C1：$p$ 不可用，所以无法推导出 $r$，因此无法推导出 $t$，所以没有矛盾。\n  - 移除 C2：情况对称；无法推导出 $s$，因此无法推导出 $t$。\n  - 移除 C3：无法从 $p$ 推导出 $r$，因此无法推导出 $t$。\n  - 移除 C4：无法从 $q$ 推导出 $s$，因此无法推导出 $t$。\n  - 移除 C5：无法推导出 $t$。\n  - 移除 C8：即使可以推导出 $t$，也没有子句可以强制推导出 $\\text{false}$。\n  在每种情况下，得到的集合都是可满足的。因此 A 是一个最小不可满足子集。\n\n集合 B: {C1, C2, C3, C4, C5, C7, C8}。\n- 这个集合是不可满足的（如 A 所示），但不是最小的：移除 C7 会得到集合 A，而集合 A 仍然是不可满足的。因此 B 不是最小的。\n\n集合 C: {C1, C2, C3, C4, C5, C6, C8}。\n- 这个集合是不可满足的（如 A 所示），但不是最小的：移除 C6 会得到集合 A，而集合 A 仍然是不可满足的。因此 C 不是最小的。\n\n集合 D: {C1, C2, C5, C8}。\n- 这个集合是可满足的：选择一个赋值，其中 $p=\\text{true}$，$q=\\text{true}$，$r=\\text{false}$，$s=\\text{false}$，$t=\\text{false}$，以及任意的 $u,v$。那么，C1 和 C2 因为 $p,q$ 为真而满足；在 C5 中，前提 $(r \\land s)$ 为假，所以蕴涵式成立；在 C8 中，前提 $t$ 为假，所以蕴涵式成立。无法推导出矛盾。因此 D 不是不可满足的。\n\n集合 E: {C1, C2, C3, C4, C5, C6, C7, C8}。\n- 这个集合是不可满足的（因为它包含了 A），但不是最小的：移除 C6 或 C7 会得到一个仍然包含 A 的集合，该集合仍然是不可满足的。因此 E 不是最小的。\n\n因此，选项中唯一的最小不可满足子集是 A。", "answer": "$$\\boxed{A}$$", "id": "1427107"}, {"introduction": "计算复杂性理论的核心思想之一是“规约”，即利用一个已知的有效算法来解决新的问题。这个高级练习将引导你超越简单地执行算法，而是将其作为一个“黑箱”工具来使用。你需要设计一个高效的方法来判定在一个 Horn 公式中，某个特定变量是否存在一个可满足赋值使其为真，这展示了如何将一个新问题转化为我们已经知道如何解决的 Horn-SAT 问题，从而证明新问题同样可以在多项式时间内解决。 [@problem_id:1427111]", "problem": "在人工智能领域，知识库通常由一组逻辑规则构建而成。一类特别高效且富有表达力的规则可以使用霍恩子句来建模。考虑一个使用此类知识库的医疗诊断系统。该系统的状态由一组命题变量描述，其中每个变量可能代表一个症状（例如 `has_fever`）或一个诊断（例如 `has_flu`）。\n\n让我们正式定义这些组件：\n- **文字 (literal)** 是一个命题变量（一个正文字，例如 $x$）或其否定（一个负文字，例如 $\\neg x$）。\n- **霍恩子句 (Horn clause)** 是一个最多只包含一个正文字的文字析取。霍恩子句及其常见逻辑等价的例子如下：\n    1. 定子句 (definite clause): $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k \\lor q$，它等价于 $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow q$。这代表一条规则，例如，“如果一个病人发烧且咳嗽，那么他们可能得了流感。”\n    2. 负子句 (negative clause): $\\neg p_1 \\lor \\neg p_2 \\lor \\dots \\lor \\neg p_k$，它等价于 $(p_1 \\land p_2 \\land \\dots \\land p_k) \\rightarrow \\text{FALSE}$。这代表一个约束，例如，“一个病人不能同时患有疾病A和疾病B。”\n    3. 事实 (fact): $q$，它等价于 $\\text{TRUE} \\rightarrow q$。这代表一个观察到的事实，例如，“该病人发烧了。”\n- **霍恩公式 (Horn formula)** $\\Phi$ 是霍恩子句的合取 (AND)。\n- **满足赋值 (satisfying assignment)** 是对所有变量的真值赋值（TRUE/FALSE），使得整个公式 $\\Phi$ 的值为 TRUE。\n\n对于诊断系统而言，一个关键的查询是确定某个特定的诊断在逻辑上是否可能。给定代表整个知识库的霍恩公式 $\\Phi$ 和代表一个潜在诊断的特定变量 $x$，开发者需要一个算法来解决 **HORN-EXIST-TRUE** 问题：确定是否存在*任何*使变量 $x$ 的值为 TRUE 的 $\\Phi$ 的满足赋值。\n\n对于给定的霍恩公式 $\\Phi$ 和变量 $x$，以下哪个陈述正确描述了一种在多项式时间内解决 HORN-EXIST-TRUE 问题的方法？\n\nA. 该问题等价于检查 $\\Phi$ 的可满足性。如果 $\\Phi$ 有任何满足赋值，那么对于任何变量 $v$，都必然存在某个满足赋值使得 $v$ 为 TRUE。\n\nB. 使用标准的线性时间 Horn-SAT 算法找到 $\\Phi$ 的最小满足赋值。当且仅当变量 $x$ 在这个最小赋值中被赋为 TRUE 时，它才能在某个满足赋值中被设为 TRUE。\n\nC. 通过添加子句 $(\\neg x)$ 来修改公式 $\\Phi$，并检查结果公式是否可满足。如果结果公式不可满足，那么就可以将 $x$ 设为 TRUE。\n\nD. 该问题是 NP 完全的，是通用布尔可满足性问题 (SAT) 的一个已知的难解变体，因此据信不存在多项式时间算法。\n\nE. 通过添加子句 $(x)$ 来修改公式 $\\Phi$，形成一个新的公式 $\\Phi'$。当且仅当这个新公式 $\\Phi'$ 可满足时，$\\Phi$ 才能在 $x$ 为 TRUE 的情况下被满足。", "solution": "该问题要求一个多项式时间算法，以确定在一个给定的霍恩公式 $\\Phi$ 的任何满足赋值中，变量 $x$ 是否可以被设为 TRUE。这就是 HORN-EXIST-TRUE 问题。我们需要评估所提出的方法。关键在于将此问题与标准的霍恩可满足性 (Horn-SAT) 问题联系起来，后者已知可在多项式时间（实际上是线性时间）内解决。\n\n让我们分析一下 HORN-EXIST-TRUE($\\Phi, x$) 和 Horn-SAT 之间的关系。我们正在寻找一个赋值 $A$，使得 $A \\models \\Phi$ 并且 $A(x) = \\text{TRUE}$。\n\n考虑选项 E 中的提议。我们构建一个新公式 $\\Phi' = \\Phi \\land (x)$。\n首先，我们观察到 $\\Phi'$ 也是一个霍恩公式。原始公式 $\\Phi$ 是霍恩子句的合取。新子句 $(x)$ 本身就是一个霍恩子句（它包含一个正文字和零个负文字，等价于 $\\text{TRUE} \\rightarrow x$）。霍恩子句的合取结果仍然是霍恩公式。由于 Horn-SAT 可在多项式时间内解决，因此检查 $\\Phi'$ 的可满足性也可以在多项式时间内完成。\n\n现在，我们必须证明这种方法是正确的。也就是说，我们必须证明“存在一个使 $x=\\text{TRUE}$ 的 $\\Phi$ 的满足赋值”当且仅当“$\\Phi'$ 是可满足的”。\n\n**第一部分：(⇒) 假设存在一个使 $x=\\text{TRUE}$ 的 $\\Phi$ 的满足赋值。**\n设这个赋值为 $A$。根据定义，我们有：\n1. $A \\models \\Phi$ ($A$ 满足 $\\Phi$)\n2. $A(x) = \\text{TRUE}$\n\n我们要证明 $\\Phi'$ 是可满足的。一个赋值如果满足合取式中的每一部分，那么它就满足这个合取式。\n公式为 $\\Phi' = \\Phi \\land (x)$。\n- $A$ 是否满足 $\\Phi$？是的，根据假设 (1)。\n- $A$ 是否满足子句 $(x)$？是的，因为一个赋值要满足单个文字的子句，它必须将该文字赋值为 TRUE，而我们从 (2) 中知道 $A(x) = \\text{TRUE}$。\n由于 $A$ 同时满足 $\\Phi$ 和 $(x)$，它是它们合取式 $\\Phi'$ 的一个满足赋值。因此，$\\Phi'$ 是可满足的。\n\n**第二部分：(⇐) 假设 $\\Phi' = \\Phi \\land (x)$ 是可满足的。**\n根据定义，这意味着存在一个赋值，我们称之为 $A'$，使得 $A' \\models \\Phi'$。\n由于 $A'$ 满足合取式 $\\Phi \\land (x)$，它必须满足每一部分：\n1. $A' \\models \\Phi$\n2. $A' \\models (x)$\n\n从 (2) 可知，为了使 $A'$ 满足子句 $(x)$，必须有 $A'(x) = \\text{TRUE}$。\n从 (1) 可知，这个相同的赋值 $A'$ 是原始公式 $\\Phi$ 的一个满足赋值。\n所以，我们找到了一个赋值，即 $A'$，它满足 $\\Phi$ 并且其中 $x$ 被赋值为 TRUE。这正是 HORN-EXIST-TRUE 问题所要求的。\n\n这就证明了检查 $\\Phi' = \\Phi \\land (x)$ 的可满足性是解决 HORN-EXIST-TRUE($\\Phi, x$) 的一个正确且多项式时间的方法。因此，选项 E 是正确的。\n\n我们简要分析一下为什么其他选项不正确：\n- **A**: 这是错误的。一个公式可以是可满足的，但某些变量在所有满足赋值中都可能被强制为 FALSE。例如，$\\Phi = (x \\rightarrow \\text{FALSE})$ 是一个霍恩公式（等价于 $\\neg x$）。它通过将 $x=\\text{FALSE}$ 来满足。不存在 $x=\\text{TRUE}$ 的满足赋值。\n- **B**: 这是不正确的。标准的 Horn-SAT 算法找到的是*最小满足赋值*，其中值为 TRUE 的变量集合是最小的。这个赋值告诉我们哪些变量在任何满足赋值中都*必须*为 TRUE。一个变量 $x$ 在最小模型中可能为 FALSE，但在其他非最小的满足赋值中可以被设为 TRUE。例如，考虑 $\\Phi = (p \\rightarrow q)$。其最小模型是 $\\{p=\\text{FALSE}, q=\\text{FALSE}\\}$。在这里，$p$ 是 FALSE。然而，赋值 $\\{p=\\text{TRUE}, q=\\text{TRUE}\\}$ 也满足 $\\Phi$。所以，$p$ 有可能为真，即使它在最小模型中为假。\n- **C**: 通过添加 $(\\neg x)$ 来修改 $\\Phi$ 是在测试错误的属性。$(\\neg x)$ 等价于 $(x \\rightarrow \\text{FALSE})$，这是一个霍恩子句。公式 $\\Phi \\land (\\neg x)$ 是可满足的，当且仅当存在一个 $\\Phi$ 的满足赋值，其中 $x$ 为 FALSE。该选项建议，如果这个新公式*不可满足*，那么就可以将 $x$ 设为 TRUE。这意味着 $\\Phi$ 的*每个*满足赋值都必须有 $x=\\text{TRUE}$。这回答的是“$x$ 必须为真吗？”，而不是“$x$ 可以为真吗？”。\n- **D**: 这是不正确的。如上所示，该问题在多项式时间内归约为 Horn-SAT，而 Horn-SAT 是复杂性类别 P (可在多项式时间内解决) 中的一个经典问题。因此，HORN-EXIST-TRUE 也属于 P，而不是 NP 完全的。\n\n基于此分析，选项 E 提供了正确且计算上高效的方法。", "answer": "$$\\boxed{E}$$", "id": "1427111"}]}