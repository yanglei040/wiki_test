{"hands_on_practices": [{"introduction": "理解2-SAT算法的核心在于将逻辑子句转化为图结构。本练习将让你直接实践构建这种“蕴含图”并探索其属性，特别是通过追踪图中的路径来确定节点间的可达性，这是检查可满足性的基础步骤。[@problem_id:1410675]", "problem": "计算机科学中的一个常见问题是确定布尔公式的可满足性。对于2-合取范式 (2-CNF) 的公式——即每个子句最多是两个文字的析取的公式——存在一种基于图论的高效算法。本问题探讨了该算法核心的图构造方法的行为。\n\n其过程如下：给定一个包含 $n$ 个变量 $\\{x_1, \\dots, x_n\\}$ 的2-CNF公式 $\\phi$，我们构造一个有向图。该图的顶点集由 $2n$ 个顶点组成，每个文字（即每个 $x_i$ 及其否定 $\\neg x_i$）都有一个独立的顶点。对于公式 $\\phi$ 中存在的每个形如 $(a \\lor b)$ 的子句，在图中添加两条有向边：一条从代表 $\\neg a$ 的顶点到代表 $b$ 的顶点的边，以及一条从代表 $\\neg b$ 的顶点到代表 $a$ 的顶点的边。\n\n考虑一个定义在六个变量 $\\{x_1, x_2, x_3, x_4, x_5, x_6\\}$ 上的特定2-CNF公式 $\\phi$。该公式由以下七个子句的合取 (AND) 给出：\n1.  $(x_1 \\lor \\neg x_1)$\n2.  $(\\neg x_2 \\lor x_1)$\n3.  $(x_3 \\lor \\neg x_2)$\n4.  $(x_4 \\lor \\neg x_3)$\n5.  $(x_5 \\lor \\neg x_4)$\n6.  $(x_6 \\lor \\neg x_5)$\n7.  $(x_2 \\lor \\neg x_6)$\n\n将上述过程应用于该公式 $\\phi$，确定从代表文字 $\\neg x_1$ 的顶点出发，通过任意长度（包括长度为零）的有向路径可以到达的不同顶点的总数。", "solution": "我们按照规定构造蕴含图：对于每个子句 $(a \\lor b)$，添加有向边 $\\neg a \\to b$ 和 $\\neg b \\to a$。顶点是 $12$ 个文字 $\\{x_{i}, \\neg x_{i} : i \\in \\{1,\\dots,6\\}\\}$。\n\n处理每个子句以列出边：\n1. $(x_{1} \\lor \\neg x_{1})$ 给出 $\\neg x_{1} \\to \\neg x_{1}$ 和 $x_{1} \\to x_{1}$。\n2. $(\\neg x_{2} \\lor x_{1})$ 给出 $x_{2} \\to x_{1}$ 和 $\\neg x_{1} \\to \\neg x_{2}$。\n3. $(x_{3} \\lor \\neg x_{2})$ 给出 $\\neg x_{3} \\to \\neg x_{2}$ 和 $x_{2} \\to x_{3}$。\n4. $(x_{4} \\lor \\neg x_{3})$ 给出 $\\neg x_{4} \\to \\neg x_{3}$ 和 $x_{3} \\to x_{4}$。\n5. $(x_{5} \\lor \\neg x_{4})$ 给出 $\\neg x_{5} \\to \\neg x_{4}$ 和 $x_{4} \\to x_{5}$。\n6. $(x_{6} \\lor \\neg x_{5})$ 给出 $\\neg x_{6} \\to \\neg x_{5}$ 和 $x_{5} \\to x_{6}$。\n7. $(x_{2} \\lor \\neg x_{6})$ 给出 $\\neg x_{2} \\to \\neg x_{6}$ 和 $x_{6} \\to x_{2}$。\n\n我们现在计算从起始顶点 $\\neg x_{1}$ 可达的顶点集（路径长度任意，包括零长度）。用起始顶点初始化可达集：$\\{\\neg x_{1}\\}$。\n\n从 $\\neg x_{1}$ 出发的边是 $\\neg x_{1} \\to \\neg x_{1}$ (自环) 和 $\\neg x_{1} \\to \\neg x_{2}$。因此我们添加 $\\neg x_{2}$。\n\n从 $\\neg x_{2}$ 出发的唯一边是 $\\neg x_{2} \\to \\neg x_{6}$，所以添加 $\\neg x_{6}$。\n\n从 $\\neg x_{6}$ 出发的唯一边是 $\\neg x_{6} \\to \\neg x_{5}$，所以添加 $\\neg x_{5}$。\n\n从 $\\neg x_{5}$ 出发的唯一边是 $\\neg x_{5} \\to \\neg x_{4}$，所以添加 $\\neg x_{4}$。\n\n从 $\\neg x_{4}$ 出发的唯一边是 $\\neg x_{4} \\to \\neg x_{3}$，所以添加 $\\neg x_{3}$。\n\n从 $\\neg x_{3}$ 出发的唯一边是 $\\neg x_{3} \\to \\neg x_{2}$，该顶点已在可达集中。因此，探索在 $\\neg x_{2}, \\neg x_{3}, \\neg x_{4}, \\neg x_{5}, \\neg x_{6}$ 之间形成了一个环路。\n\n从上面的边列表中可以看出，从这些负文字出发的边都没有指向任何正文字；所有从负源点出发的边都指向负目标点。因此，完整的可达集是\n$$\nR=\\{\\neg x_{1}, \\neg x_{2}, \\neg x_{3}, \\neg x_{4}, \\neg x_{5}, \\neg x_{6}\\},\n$$\n可达的不同顶点数量为 $|R|=6$。", "answer": "$$\\boxed{6}$$", "id": "1410675"}, {"introduction": "在掌握了基本蕴含图的构建之后，让我们来挑战一个更进一步的问题。本练习将探讨蕴含图模型的灵活性，通过将异或（XOR）等非标准逻辑约束首先转化为标准的2-CNF形式，然后推导出相应的图结构，从而将其整合到2-SAT框架中。这有助于巩固蕴含图代表逻辑推论这一核心原则。[@problem_id:1410702]", "problem": "在计算复杂性理论的研究中，2-可满足性（2-SAT）问题是一个基石，它被认为是复杂性类 NL（非确定性对数空间）的完全问题。解决 2-SAT 问题的标准算法涉及根据给定的 2-合取范式（2-CNF）公式构建一个“蕴含图”。对于一个包含变量 $x_1, \\dots, x_n$ 的公式 $\\Phi$，其蕴含图 $G_{\\Phi}$ 有 $2n$ 个顶点，代表文字集合 $\\{x_1, \\neg x_1, \\dots, x_n, \\neg x_n\\}$。$\\Phi$ 中的每个形如 $(a \\lor b)$ 的子句都被转换成 $G_{\\Phi}$ 中的两条有向边：一条从 $\\neg a$ 到 $b$ 的边和一条从 $\\neg b$ 到 $a$ 的边。这些边代表了逻辑蕴含关系 $(\\neg a \\implies b)$ 和 $(\\neg b \\implies a)$。\n\n现在考虑对标准 2-SAT 问题的一个扩展，其中除了形如 $(l_i \\lor l_j)$ 的标准子句外，我们引入一种新型约束：异或（XOR）子句，记为 $(x_i \\oplus x_j)$。当且仅当布尔变量 $x_i$ 和 $x_j$ 的真值不同时，该子句被满足。\n\n为了使用标准的蕴含图框架解决这个扩展问题，必须首先将每个 XOR 子句转换为一组等价的标准 2-CNF 子句。为了正确地为一个 XOR 子句 $(x_i \\oplus x_j)$ 建模，必须向蕴含图中添加下列哪组有向边？\n\nA. $\\{\\neg x_i \\to x_j, \\neg x_j \\to x_i\\}$\n\nB. $\\{x_i \\to \\neg x_j, x_j \\to \\neg x_i\\}$\n\nC. $\\{x_i \\to x_j, \\neg x_i \\to \\neg x_j, x_j \\to x_i, \\neg x_j \\to \\neg x_i\\}$\n\nD. $\\{x_i \\to \\neg x_j, \\neg x_j \\to x_i, \\neg x_i \\to x_j, x_j \\to \\neg x_i\\}$\n\nE. $\\{x_i \\to x_j, x_j \\to \\neg x_i\\}$", "solution": "我们从布尔变量上的 XOR 约束的逻辑意义开始：$x_{i} \\oplus x_{j}$ 为真，当且仅当 $x_{i}$ 和 $x_{j}$ 具有不同的真值。等价地，\n$$\nx_{i} \\oplus x_{j} \\equiv (x_{i} \\land \\neg x_{j}) \\lor (\\neg x_{i} \\land x_{j}).\n$$\n该条件的一个标准 2-CNF 表示是\n$$\n(x_{i} \\lor x_{j}) \\land (\\neg x_{i} \\lor \\neg x_{j}),\n$$\n这可以通过检查真值表来验证，或者通过观察到这个范式强制要求“至少一个为真”和“至少一个为假”，因此恰好一个为真。\n\n在 2-SAT 的蕴含图中，每个子句 $(a \\lor b)$ 产生蕴含关系 $(\\neg a \\implies b)$ 和 $(\\neg b \\implies a)$，这被表示为有向边 $\\neg a \\to b$ 和 $\\neg b \\to a$。\n\n将此规则应用于这两个子句：\n1) 对于 $(x_{i} \\lor x_{j})$，我们添加边\n$$\n\\neg x_{i} \\to x_{j}, \\quad \\neg x_{j} \\to x_{i}.\n$$\n2) 对于 $(\\neg x_{i} \\lor \\neg x_{j})$，令 $a = \\neg x_{i}$ 且 $b = \\neg x_{j}$。那么 $\\neg a = x_{i}$ 且 $\\neg b = x_{j}$，因此我们添加边\n$$\nx_{i} \\to \\neg x_{j}, \\quad x_{j} \\to \\neg x_{i}.\n$$\n\n收集为单个 XOR 子句 $(x_{i} \\oplus x_{j})$ 建模所需的所有蕴含关系，我们得到集合\n$$\n\\{\\, x_{i} \\to \\neg x_{j}, \\ \\neg x_{j} \\to x_{i}, \\ \\neg x_{i} \\to x_{j}, \\ x_{j} \\to \\neg x_{i} \\,\\},\n$$\n这与选项 D 相符。", "answer": "$$\\boxed{D}$$", "id": "1410702"}, {"introduction": "我们已经探讨了如何判断一个公式*是否*可满足，这是“判定问题”。最后的这个练习将我们从判定问题引向“搜索问题”：即*找到*一个具体的可满足赋值。本练习将介绍一种强大的算法技巧，它利用一个判定预言机（一个仅回答可满足性“是”或“否”的黑盒）来逐步构建一个完整的解，这展示了计算复杂性理论中一个被称为自归约的关键概念。[@problem_id:1410686]", "problem": "2-可满足性（2-SAT）问题询问的是，一个给定的 2-合取范式（2-CNF）布尔公式是否存在一个满足赋值。一个 2-CNF 公式是多个子句的合取（AND），其中每个子句是至多两个文字的析取（OR）。一个文字是一个变量或其否定。\n\n对于任何 2-CNF 公式 $\\phi$，我们可以构建一个蕴含图 $G_\\phi$。$G_\\phi$ 的顶点是 $\\phi$ 的所有文字（即，对于每个变量 $x_i$，我们都有代表 $x_i$ 和 $\\neg x_i$ 的顶点）。对于 $\\phi$ 中每个形如 $(\\alpha \\lor \\beta)$ 的子句，我们在 $G_\\phi$ 中添加两条有向边：一条表示蕴含关系 $\\neg \\alpha \\to \\beta$，另一条表示 $\\neg \\beta \\to \\alpha$。\n\n一个基本定理指出，一个 2-CNF 公式 $\\phi$ 是不可满足的，当且仅当存在一个变量 $x_i$，使得 $x_i$ 和 $\\neg x_i$ 位于 $G_\\phi$ 的同一个强连通分量（SCC）中。这等价于在 $G_\\phi$ 中，既存在从 $x_i$ 到 $\\neg x_i$ 的路径，也存在从 $\\neg x_i$ 到 $x_i$ 的路径。\n\n判断有向图中两个顶点之间是否存在路径是一个属于复杂性类非确定性对数空间（**NL**）的问题。因此，2-SAT 的判定问题属于 **co-NL**，并且根据 Immerman-Szelepcsényi 定理（**NL** = **co-NL**），它也属于 **NL**。这意味着存在一个高效的（多项式时间）判定算法来解决 2-SAT 问题。\n\n假设给定一个包含 $n$ 个变量 $\\{x_1, x_2, \\ldots, x_n\\}$ 的 2-CNF 公式 $\\phi$，并保证该公式是可满足的。你还可以使用一个预言机 `IS_SAT(psi)`，它接受任何 2-CNF 公式 `psi` 作为输入，如果 `psi` 可满足则返回 `true`，否则返回 `false`。下列哪个迭代过程保证能为 $\\phi$ 找到一个满足赋值？\n\nA. 初始化一个空赋值。对于 $i$ 从 1 到 $n$：询问预言机 `IS_SAT`($\\phi \\land x_i$)。如果结果为 `true`，则永久地将 $x_i$ 设为 `true`，并将 $\\phi$ 更新为 $\\phi \\land x_i$。否则，永久地将 $x_i$ 设为 `false`，并将 $\\phi$ 更新为 $\\phi \\land \\neg x_i$。\n\nB. 对于每个变量 $x_i$ 从 1 到 $n$：独立地查询预言机 `IS_SAT`($\\phi \\land x_i$)。如果预言机返回 `true`，则赋值 $x_i = \\text{true}$。否则，赋值 $x_i = \\text{false}$。\n\nC. 对于每个变量 $x_i$ 从 1 到 $n$：为原始公式 $\\phi$ 构建蕴含图。如果在此图中存在从文字 $x_i$ 到文字 $\\neg x_i$ 的路径，则赋值 $x_i = \\text{false}$。否则，赋值 $x_i = \\text{true}$。\n\nD. 初始化所有变量为未赋值状态。选择一个未赋值的变量 $x_i$。赋值 $x_i = \\text{true}$ 并检查这个部分赋值是否违反了任何子句。如果违反了，则回溯并赋值 $x_i = \\text{false}$。如果找到了一个不会立即导致矛盾的值，就将该赋值永久化，并对下一个未赋值的变量重复此过程。", "solution": "我们分析每个过程，并确定它是否保证能利用给定的预言机为可满足的 2-CNF 公式 $\\phi$ 找到一个满足赋值。\n\n对 A 的论断：保证能找到一个满足赋值。\n对变量进行归纳证明：\n- 不变性：在为 $x_{1},\\dots,x_{i-1}$ 赋值后，令 $\\phi_{i-1}$ 表示 $\\phi$ 与这些赋值的合取。不变性是 $\\phi_{i-1}$ 是可满足的。\n- 基础情况：根据假设，$\\phi_{0}=\\phi$ 是可满足的。\n- 归纳步骤：在第 $i$ 步，算法查询 $\\text{IS\\_SAT}(\\phi_{i-1} \\land x_{i})$。如果返回 true，那么存在一个扩展了 $x_{i}=\\text{true}$ 的赋值可以满足 $\\phi_{i-1}$，因此设置 $x_{i}=\\text{true}$ 保持了可满足性。否则，由于 $\\phi_{i-1}$ 是可满足的，那么 $\\text{IS\\_SAT}(\\phi_{i-1} \\land \\neg x_{i})$ 必定为 true（两个单元扩展中至少有一个是可满足的），因此设置 $x_{i}=\\text{false}$ 也保持了可满足性。因此，不变性对于 $\\phi_{i}$ 仍然成立。\n- 经过 $n$ 步后，$\\phi_{n}$ 是可满足的并且固定了所有变量，因此所选择的完整赋值满足 $\\phi$。\n因此，A 是正确的。\n\nB 的反例：不保证。\n令\n$$\n\\phi \\;=\\; (x \\lor y)\\;\\land\\;(\\neg x \\lor z)\\;\\land\\;(\\neg y \\lor \\neg z).\n$$\n这个 $\\phi$ 是可满足的（例如，$x=\\text{false},\\,y=\\text{true},\\,z=\\text{false}$ 满足所有子句）。\n对原始的 $\\phi$ 独立地查询预言机得到：\n- $\\text{IS\\_SAT}(\\phi \\land x)=\\text{true}$（例如，$x=\\text{true},\\,y=\\text{false},\\,z=\\text{true}$ 可行），\n- $\\text{IS\\_SAT}(\\phi \\land y)=\\text{true}$（例如，$y=\\text{true},\\,x=\\text{false},\\,z=\\text{false}$ 可行），\n- $\\text{IS\\_SAT}(\\phi \\land z)=\\text{true}$（例如，$z=\\text{true},\\,y=\\text{false},\\,x=\\text{true}$ 可行）。\n过程 B 接着会设置 $x=y=z=\\text{true}$，但这个赋值使得 $(\\neg y \\lor \\neg z)$ 为假，因此它不满足 $\\phi$。所以 B 不保证成功。\n\nC 的反例与归约：不保证。\n关键等价关系：对于一个 2-CNF $\\phi$ 和变量 $x_{i}$，在蕴含图 $G_{\\phi}$ 中存在从 $x_{i}$ 到 $\\neg x_{i}$ 的路径，当且仅当 $\\phi \\land x_{i}$ 是不可满足的。\n- 如果在 $G_{\\phi}$ 中存在 $x_{i}\\to\\neg x_{i}$，添加单元子句 $x_{i}$ 会增加边 $\\neg x_{i}\\to x_{i}$，使得 $x_{i}$ 和 $\\neg x_{i}$ 属于同一个强连通分量，这使得 $\\phi \\land x_{i}$ 不可满足。\n- 反之，如果 $\\phi \\land x_{i}$ 是不可满足的，那么在 $G_{\\phi \\land x_{i}}$ 中唯一的新边是 $\\neg x_{i}\\to x_{i}$，而不可满足性意味着 $x_{i}$ 和 $\\neg x_{i}$ 在同一个强连通分量中；因此在 $G_{\\phi}$ 中必定已经存在一条路径 $x_{i}\\to\\neg x_{i}$。\n因此 C 的规则“当且仅当存在 $x_{i}\\to\\neg x_{i}$ 时赋值 $x_{i}=\\text{false}$，否则 $x_{i}=\\text{true}$”等价于“当且仅当 $\\text{IS\\_SAT}(\\phi \\land x_{i})=\\text{true}$ 时赋值 $x_{i}=\\text{true}$，否则 $x_{i}=\\text{false}$”，并且这是在原始的 $\\phi$ 上独立应用的。这与 B 的陷阱相同，因此上面同样的 $\\phi$ 表明 C 也可能失败（它会设置 $x=y=z=\\text{true}$，这不是一个满足赋值）。所以 C 不保证成功。\n\nD 的反例推理：按其描述不保证。\n该过程仅在赋值立即导致某个子句为假时才拒绝该赋值，否则就将赋值“永久化”，并没有规定在后续出现冲突时重新考虑早前的选择。考虑\n$$\n\\phi \\;=\\; (\\neg x \\lor z)\\;\\land\\;(\\neg x \\lor \\neg z).\n$$\n这个 $\\phi$ 是可满足的（例如，$x=\\text{false}$，z 取任意值）。过程 D 可能首先选择 $x$ 并尝试 $x=\\text{true}$，这不会立即导致任何子句为假：子句变成了单元子句 $z$ 和单元子句 $\\neg z$，在当前的部分赋值下它们尚未被证伪。算法接着将 $x=\\text{true}$ 永久化并转向 $z$。尝试 $z=\\text{true}$ 会立即证伪 $(\\neg x \\lor \\neg z)$；回溯到 $z=\\text{false}$ 会立即证伪 $(\\neg x \\lor z)$。在尝试了 $z$ 的两个值之后，由于 $x$ 早先已被声明为永久的，算法无法继续找到满足赋值 $x=\\text{false}$。由于所描述的过程不包括在后续冲突时修正早前的永久赋值，因此它不保证成功。\n\n结论：只有 A 保证能利用预言机为任何可满足的 $\\phi$ 找到一个满足赋值。", "answer": "$$\\boxed{A}$$", "id": "1410686"}]}