{"hands_on_practices": [{"introduction": "我们常常利用相应判定问题的“神谕机”（oracle）来解决一个搜索问题。本练习 [@problem_id:1447183] 提供了一个使用团问题（CLIQUE problem）的经典范例，它将演示一个两阶段策略：首先确定最大团的大小，然后逐个识别构成团的顶点。这种方法是自归约性（self-reducibility）的核心。", "problem": "一位工程师的任务是分析一个复杂通信网络的结构，该网络可以被建模为一个无向图 $G=(V, E)$，其中 $V$ 是 $n$ 个通信节点的集合，$E$ 是它们之间 $m$ 条直接链路的集合。工程师需要识别一个“核心通信枢纽”，它被定义为图中的一个最大团。团是一个顶点子集，其中任意两个不同的顶点都由一条边相连，而最大团是图中可能的最大规模的团。\n\n为了协助这项任务，工程师可以使用一个专门的硬件预言机。这个预言机提供一个函数 `HAS_CLIQUE(G', k')`，它以一个图 $G'$ 和一个整数 $k'$ 作为输入。如果 $G'$ 包含一个大小至少为 $k'$ 的团，则返回 `true`，否则返回 `false`。每次调用这个预言机都被视为一个计算步骤。\n\n你的任务是设计一个算法，利用这个预言机来找到构成图 $G$ 中一个最大团的顶点集合。你的算法对于一个有 $n$ 个顶点的图，最多需要调用 `HAS_CLIQUE` 预言机多少次？请用一个关于 $n$ 的封闭形式解析表达式来表示你的答案。", "solution": "问题要求设计一个算法，使用一个决策预言机在图 $G$ 中找到一个最大团，并确定所需的最大预言机调用次数。解决方案可以分为两个主要阶段：首先，确定最大团的大小；其次，识别构成这样一个团的顶点。\n\n**阶段一：确定最大团的大小 ($k_{\\max}$)**\n\n我们可以利用的核心性质是团问题的单调性。如果一个图包含一个大小为 $k$ 的团，那么它也必然包含所有小于 $k$ 的大小的团。这个性质使得该问题适合使用二分搜索。我们可以在 $[1, n]$ 的范围内搜索使得预言机 `HAS_CLIQUE(G, k)` 返回 `true` 的最大整数 $k$。\n\n让我们来定义二分搜索过程：\n1. 初始化搜索范围：`low = 1`，`high = n`。\n2. 初始化一个变量来存储至今找到的最大团的大小：`k_max = 0`。\n3. 当 `low = high` 时：\n    a. 计算中点：`mid = floor((low + high) / 2)`。\n    b. 调用预言机：`result = HAS_CLIQUE(G, mid)`。\n    c. 如果 `result` 为 `true`，意味着存在一个大小为 `mid` 的团。这可能是我们的最大团，或者可能存在一个更大的团。因此，我们记录下这个大小，`k_max = mid`，并通过调整搜索空间到上半部分来尝试找到一个更大的团：`low = mid + 1`。\n    d. 如果 `result` 为 `false`，意味着大小为 `mid` 的团不存在。因此，任何大于 `mid` 的团也必然不存在。我们必须在下半部分搜索一个更小的团：`high = mid - 1`。\n\n当二分搜索循环终止时，`k_max` 将保存图 $G$ 中最大团的大小。在大小为 $n$ 的范围上进行二分搜索，需要的查询次数等于 $\\lceil \\log_{2}(n) \\rceil$。\n\n**阶段二：识别最大团的顶点**\n\n既然我们已经知道最大团的大小是 $k_{\\max}$，我们就可以使用一种自归约方法来找到构成这样一个团的具体顶点。最有效的方法是一个排除过程。\n\n算法流程如下：\n1. 初始化一个候选顶点集 `V_cand`，使其为原图的整个顶点集 `V`。\n2. 逐一遍历原图顶点集 $V$ 中的每个顶点 $v$。对于每个 $v$：\n    a. 创建一个临时图 $G'$，它是由 `V_cand \\setminus \\{v\\}` 中的顶点诱导出的 $G$ 的子图。\n    b. 调用预言机：`result = HAS_CLIQUE(G', k_max)`。\n    c. 如果 `result` 为 `true`，这意味着即使从我们当前的候选集中移除 $v$，一个大小为 $k_{\\max}$ 的团仍然存在。这表明 $v$ 不是必需的，因此我们可以通过将 `V_cand` 更新为 `V_cand \\setminus \\{v\\}` 来永久地将其从候选集中丢弃。\n    d. 如果 `result` 为 `false`，这意味着在当前候选集中，$v$ 对于形成任何 $k_{\\max}$-团都是必需的。因此，我们必须保留 $v$，并且不修改 `V_cand`。\n\n对原图 $G$ 的所有 $n$ 个顶点重复此过程。对于 $n$ 个顶点中的每一个，我们都恰好调用一次预言机来决定是保留还是从候选池中丢弃它。在遍历所有 $n$ 个顶点之后，最终的集合 `V_cand` 将恰好包含 $k_{\\max}$ 个顶点。这些顶点构成一个最大团，因为我们已经系统地排除了所有并非严格必需的、用以形成一个大小为 $k_{\\max}$ 的团的顶点。此阶段的预言机调用次数恰好为 $n$。\n\n**总预言机调用次数**\n\n总预言机调用次数是阶段一和阶段二调用次数的总和。\n总调用次数 = (寻找 $k_{\\max}$ 的调用次数) + (寻找顶点的调用次数)\n总调用次数 = $\\lceil \\log_{2}(n) \\rceil + n$\n\n因此，该算法所需的最大预言机调用次数为 $n + \\lceil \\log_{2}(n) \\rceil$。", "answer": "$$\\boxed{n + \\lceil \\log_{2}(n) \\rceil}$$", "id": "1447183"}, {"introduction": "在上一练习的基础上，本题将展示自归约性不仅能找到*任意*解，更可以通过巧妙设计来寻找具有特定性质的解。这个问题 [@problem_id:1447155] 挑战你设计一个算法，为布尔可满足性问题（SAT）找到一个*极小满足赋值*（minimal satisfying assignment），这突显了在自归约过程中变量赋值的顺序和逻辑至关重要。本练习将加深你对算法选择如何影响最终解性质的理解。", "problem": "在计算复杂性理论中，布尔可满足性问题 (SAT) 是一个基础性问题。给定一个由变量集合 $\\{x_1, x_2, \\ldots, x_n\\}$ 构成的合取范式 (CNF) 的布尔公式 $\\phi$，问题在于确定是否存在一组对变量的 TRUE 或 FALSE 赋值，使得整个公式的计算结果为 TRUE。\n\n假设你可以使用一个名为 SAT 预言机的假设设备。这个预言机由函数 `is_sat(ψ)` 表示，它接受任何布尔公式 `ψ` 作为输入，如果 `ψ` 是可满足的，则立即返回 TRUE，否则返回 FALSE。虽然这样的预言机可以告诉你*是否存在*一个可满足赋值，但它不直接提供这个赋值。\n\n一个称为自归约性的著名过程利用这个预言机来为给定的可满足公式 $\\phi$ 找到一个可满足赋值。然而，一个公式可以有许多可满足赋值。我们感兴趣的是一种特定类型的赋值，称为*最小可满足赋值*。一个可满足赋值 $A$ 被定义为**最小**的，如果对于 $A$ 中任何被赋值为 TRUE 的变量 $x_i$，将其值翻转为 FALSE（同时保持所有其他变量赋值不变）会导致一个不再满足 $\\phi$ 的赋值。\n\n你的任务是确定一个正确且有保证的算法，该算法使用 SAT 预言机为给定的可满足公式 $\\phi$ 找到一个这样的最小可满足赋值。所考虑的算法逐个变量地（从 $x_1$ 到 $x_n$）构建赋值。在下面的描述中，$\\psi$ 表示一个逐步构建的公式，初始为 $\\psi = \\phi$。最终的赋值表示为 $A$。\n\n以下哪种算法能够正确并保证为任何可满足的输入公式 $\\phi$ 找到一个最小可满足赋值？\n\nA. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$:\n_    _如果 `is_sat`($\\psi \\land x_i$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n返回 $A$。\n\nB. 初始化 $\\psi = \\phi$。\n对于 $i = 1, \\ldots, n$:\n_    _如果 `is_sat`($\\psi \\land \\neg x_i$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_i$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_i$。\n返回 $A$。\n\nC. 首先，使用标准的自归约方法（算法 A）找到一个任意的可满足赋值 $A_0$。\n初始化 $A = A_0$。\n对于 $i = 1, \\ldots, n$:\n_    _如果 $A(x_i)$ 为 TRUE：\n_    _    _令 $A'$ 为与 $A$ 相同但将 $x_i$ 设置为 FALSE 的赋值。\n_    _    _如果 $A'$ 满足 $\\phi$：\n_    _    _    _更新 $A \\leftarrow A'$。\n返回 $A$。\n\nD. 对于 $i = 1, \\ldots, n$:\n_    _令 $\\phi_T = \\phi \\land x_i$ 且 $\\phi_F = \\phi \\land \\neg x_i$。\n_    _如果 `is_sat`($\\phi_T$) 为 TRUE 且 `is_sat`($\\phi_F$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{FALSE}$。\n_    _否则如果 `is_sat`($\\phi_T$) 为 TRUE：\n_    _    _设置 $A(x_i) = \\text{TRUE}$。\n_    _否则：\n_    _    _设置 $A(x_i) = \\text{FALSE}$。\n返回 $A$。", "solution": "我们需要一个算法，它总是返回一个可满足赋值，并保证最小性，即对于输出中设置为 TRUE 的每个变量，将其翻转为 FALSE 同时保持所有其他变量固定，会使公式变得不可满足。\n\n算法 B：\n- 正确性（返回一个可满足赋值）：维持一个不变式，即在迭代 $i$ 开始时，工作公式 $\\psi$ 等于 $\\phi$ 与 $x_{1},\\ldots,x_{i-1}$ 的固定值相合取，并且是可满足的。在步骤 $i$，算法查询 `is_sat`($\\psi \\land \\neg x_{i}$)。如果为 TRUE，则设置 $x_{i}=\\text{FALSE}$ 并更新 $\\psi \\leftarrow \\psi \\land \\neg x_{i}$，根据预言机的回答，$\\psi$ 仍然是可满足的。否则，它设置 $x_{i}=\\text{TRUE}$ 并更新 $\\psi \\leftarrow \\psi \\land x_{i}$。这是安全的，因为 $\\psi$ 是可满足的，并且 $\\psi \\equiv (\\psi \\land x_{i}) \\lor (\\psi \\land \\neg x_{i})$；如果 $\\psi \\land \\neg x_{i}$ 是不可满足的，那么 $\\psi \\land x_{i}$ 必须是可满足的（否则 $\\psi$ 将是不可满足的）。通过归纳法，在 $n$ 步之后，$\\psi$ 包含了所有变量的赋值并且是可满足的，因此生成的 $A$ 满足 $\\phi$。\n\n- 最小性：设 $i$ 是任何满足 $A(x_{i})=\\text{TRUE}$ 的索引。这种情况只在步骤 $i$ 中 `is_sat`($\\psi \\land \\neg x_{i}$) 返回 FALSE 时发生，此时 $\\psi$ 已经包含了 $A$ 中 $x_{1},\\ldots,x_{i-1}$ 的固定值。预言机的 FALSE 回答意味着不存在对 $x_{i+1},\\ldots,x_{n}$ 的赋值可以满足 $\\psi \\land \\neg x_{i}$。特别是，如果我们取 $A$ 中使用的 $x_{i+1},\\ldots,x_{n}$ 的最终值，那么\n$$\n\\phi \\land \\bigwedge_{j", "answer": "$$\\boxed{B}$$", "id": "1447155"}, {"introduction": "本练习将自可约性的概念推向一个更高级、更贴近复杂性理论证明的场景，即当神谕机本身存在严格限制时我们该如何应对。这个思想实验 [@problem_id:1446952] 探讨了如何使用一个只接受特定类型输入（例如，立方图）的神谕机，来解决在规约过程中产生的、不符合该类型的一般子问题。解决问题的关键在于理解一种被称为“小工具”（gadget）的构造，它被用来“修复”子问题，使其满足神谕机的要求，这本身是计算复杂性理论中一个非常强大的技术。", "problem": "在计算复杂性理论中，许多NP难问题表现出一种称为自可约性的性质。这意味着，如果我们有一个假设的机器或“预言机”，可以立即解决问题的判定版本（例如，对“该图是否具有大小至少为k的独立集？”回答“是”或“否”），我们就可以使用这个预言机来为问题的完整搜索版本构建一个解（例如，“在该图中找到一个最大独立集”）。\n\n考虑三次图（每个顶点的度都恰好为3的图）的最大独立集（MIS）问题。这是一个NP难问题。给定一个有 $n$ 个顶点的三次图 $G$ 和一个预言机 `CubicIS_Decision(G_query, k)`，如果三次图 `G_query` 具有大小至少为 `k` 的独立集，该预言机返回 `True`，否则返回 `False`。注意，该预言机仅对三次图有效。\n\n你的目标是设计一个算法来找到 $G$ 的一个实际的最大独立集。第一步是通过对图 $G$ 进行 $O(\\log n)$ 次预言机调用来确定MIS的大小，我们称之为 $K$。第二步，也是更复杂的一步，是逐个顶点地构建这个集合。对此，一种标准的自可约方法是遍历图的每个顶点 $v$，并判断 $v$ 是否属于*任何*大小为 $K$ 的MIS。一个邻域为 $N(v)$ 的顶点 $v$ 属于某个大小为 $K$ 的MIS，当且仅当子图 $G' = G - (\\{v\\} \\cup N(v))$ 的MIS大小为 $K-1$。\n\n问题在于 $G'$ 不一定是三次图，因为移除 $v$ 及其邻居会降低其他顶点的度。为了使用预言机，必须从 $G'$ 构建一个新的、有效的三次图 $G_{test}$。一种常见的技术是，取这个非三次图 $G'$，并附加一个特殊设计的、固定的“修复”配件图 $H$，以生成三次图 $G_{test}$。\n\n假设你设计了一个完美的配件和连接方法。你已经严格证明，对于通过上述过程产生的任何图 $G'$，你的测试图的最大独立集大小 $\\alpha(G_{test})$ 与有缺陷的图的最大独立集大小 $\\alpha(G')$ 之间，通过以下简单的加性方程关联：\n$$ \\alpha(G_{test}) = \\alpha(G') + \\Delta $$\n为了使这个方程能让你通过对每个顶点 $v$ 调用一次 `CubicIS_Decision` 预言机来确定 $\\alpha(G') = K-1$ 是否成立，项 $\\Delta$ 必须具备以下哪个性质？\n\nA. $\\Delta$ 必须是一个固定的整数常量，仅由配件图 $H$ 的设计和连接规则决定，与特定图 $G'$ 的结构无关。\n\nB. $\\Delta$ 必须精确等于 $\\alpha(H)$，即孤立配件图 $H$ 的最大独立集大小。\n\nC. $\\Delta$ 必须是一个整数，其值取决于配件图 $H$ 的顶点与图 $G'$ 的顶点之间的邻接关系。\n\nD. $\\Delta$ 必须是一个明确依赖于 $K$（原始图 $G$ 的最大独立集大小）的值。\n\nE. 对于任何非平凡的配件，这样简单的加性关系都不可能成立；$\\alpha(G_{test})$ 和 $\\alpha(G')$ 之间总是需要一个更复杂的、非加性的关系。", "solution": "我们首先重申三次图 $G$（有 $n$ 个顶点）上最大独立集（MIS）问题的判定版本和搜索版本之间的关系。令 $\\alpha(G)$ 表示 $G$ 的最大独立集大小。使用预言机 $\\text{CubicIS\\_Decision}(G,k)$，我们可以得到\n$$\nK=\\max\\{k:\\text{CubicIS\\_Decision}(G,k)=\\text{True}\\}.\n$$\n这可以通过对 $k$ 进行二分搜索，在 $O(\\log n)$ 次预言机调用内找到。\n\n为了确定对每个顶点 $v \\in V(G)$，$v$ 是否属于某个大小为 $K$ 的MIS，我们定义导出子图\n$$\nG' = G - \\big(\\{v\\} \\cup N(v)\\big).\n$$\n那么，$v$ 包含在 $G$ 的某个大小为 $K$ 的MIS中，当且仅当\n$$\n\\alpha(G') = K - 1.\n$$\n正向成立，因为移除 $v$ 和 $N(v)$ 后， $G'$ 中的任何独立集都可以通过添加 $v$ 来扩展成 $G$ 中的一个独立集。反向成立，因为如果 $\\alpha(G') \\ge K$，那么添加 $v$ 将得到 $G$ 中一个大小至少为 $K+1$ 的独立集，这与 $K$ 的最大性相矛盾。因此，必然有 $\\alpha(G') \\le K - 1$，所以 $\\alpha(G') \\ge K - 1$ 等价于 $\\alpha(G')=K-1$。\n\n因为 $G'$ 不一定是三次图，我们不能直接对 $G'$ 查询预言机。根据设计，我们通过一个固定的连接方法附加一个固定的配件图 $H$ 来形成一个三次测试图 $G_{\\text{test}}$，并且我们已经严格地建立了加性关系\n$$\n\\alpha(G_{\\text{test}}) = \\alpha(G') + \\Delta,\n$$\n其中 $\\Delta$ 是与配件和连接构造相关的某个项。为了使用单次预言机调用来判断 $\\alpha(G') = K-1$ 是否成立，我们选择阈值\n$$\nk_{\\text{test}} = (K - 1) + \\Delta,\n$$\n并查询 $\\text{CubicIS\\_Decision}(G_{\\text{test}}, k_{\\text{test}})$。根据加性关系，预言机返回True当且仅当\n$$\n\\alpha(G_{\\text{test}}) \\ge k_{\\text{test}} \\quad \\Longleftrightarrow \\quad \\alpha(G') + \\Delta \\ge (K-1) + \\Delta \\quad \\Longleftrightarrow \\quad \\alpha(G') \\ge K - 1.\n$$\n如上所述，这等价于 $\\alpha(G') = K - 1$，从而回答了 $v$ 是否包含在某个大小为 $K$ 的MIS中。\n\n为了使这个方案能对每个顶点 $v$ 使用单次预言机调用就起作用，$k_{\\text{test}}$ 的值必须在调用前是已知的。因此，项 $\\Delta$ 必须是预先知道的，并且对于因移除 $\\{v\\}\\cup N(v)$ 而产生的实例，它不能依赖于 $G'$ 的具体结构。具体来说：\n- $\\Delta$ 必须是一个固定的整数常量，仅由所选的配件图 $H$ 和固定的连接规则决定，与 $G'$ 无关。这确保了 $k_{\\text{test}}$ 可以从 $K$ 和配件的规格中计算出来，而无需任何额外的预言机使用。因此 A 是必要的。\n- $\\Delta$ 未必等于 $\\alpha(H)$。当 $H$ 连接到 $G'$ 时，接口约束可能会强制或禁止 $H$ 内部的选择，因此有效的偏移量 $\\Delta$ 可能与 $\\alpha(H)$ 不同。因此 B 不是必要的。\n- 如果 $\\Delta$ 依赖于 $H$ 和 $G'$ 之间的邻接关系，那么它会随 $G'$ 的变化而变化。这将违反“一个已知的阈值对所有情况都统一适用”的要求，所以 C 不是必要的，而且实际上与要求相矛盾。\n- $\\Delta$ 未必依赖于 $K$。典型的构造会使 $\\Delta$ 独立于实例参数 $K$。因此 D 不是必要的。\n- 这种形式的加性关系在配件构造中是标准的；因此这并非不可能。所以 E 是错误的。\n\n因此，必要的性质恰好是 A。", "answer": "$$\\boxed{A}$$", "id": "1446952"}]}