{"hands_on_practices": [{"introduction": "要真正理解一个复杂性类，一个有效的方法是解构它。第一个练习探讨了随机性在亚瑟-梅林协议中的根本作用。通过设想一个无法生成随机比特的验证者亚瑟，我们可以精确地确定这个受限模型所捕获的复杂性类，从而体会到 $AM$ 的独特之处。[@problem_id:1450703]", "problem": "在计算复杂性理论中，AM 类（代表 Arthur-Merlin）刻画了这样一类语言，其成员资格可以通过一个两轮交互式协议来验证。对于长度为 $n$ 的输入字符串 $x$，协议按以下方式进行：\n1.  验证者 Arthur，一个概率多项式时间图灵机，生成一个长度为 $n$ 的多项式次方的随机字符串 $r$，并将其发送给证明者 Merlin。\n2.  证明者 Merlin，拥有无限计算能力，接收 $r$ 并返回一个长度为 $n$ 的多项式次方的响应字符串 $y$（“证明”）。\n3.  然后，Arthur 基于输入 $x$、他的随机字符串 $r$ 和 Merlin 的响应 $y$ 确定性地计算一个结果。\n\n如果存在满足以下条件的协议，则语言 $L$ 属于 AM：\n-   **完备性：** 如果 $x \\in L$，Merlin 存在一种策略选择 $y$，使得 Arthur 以至少 $2/3$ 的概率接受（基于 $r$ 的选择）。\n-   **可靠性：** 如果 $x \\notin L$，对于 Merlin 使用的任何策略选择 $y$，Arthur 以至多 $1/3$ 的概率接受（基于 $r$ 的选择）。\n\n现在，考虑这个类的一个修改版本，我们称之为 DAM (Deterministic-Arthur-Merlin)。在 DAM 协议中，Arthur 是一个确定性多项式时间图灵机，这意味着他无法访问随机比特。因此，在第一步中，Arthur 向 Merlin 发送一个预定义的、空的或恒定的字符串，因为他无法生成随机的挑战。然后 Merlin 发送他的证明 $y$，Arthur 根据 $x$ 和 $y$ 做出最终的确定性决定。\n\n下列哪个复杂性类等价于 DAM？\n\nA. P (多项式时间)\n\nB. NP (非确定性多项式时间)\n\nC. co-NP\n\nD. BPP (有界错误概率多项式时间)\n\nE. PSPACE (多项式空间)", "solution": "让我们分析修改后的复杂性类 DAM (Deterministic-Arthur-Merlin) 的定义。\n\nDAM 中语言 $L$ 的协议如下：\n1.  对于给定的输入字符串 $x$，Arthur，一个确定性多项式时间机器，准备一条消息发送给 Merlin。由于 Arthur 是确定性的并且无法访问随机性，他的消息不能依赖于随机字符串。他只能基于 $x$ 计算一条消息。然而，标准的 AM 协议将 Arthur 的第一条消息作为随机性的*唯一*来源。在一个确定性变体中，这条消息是固定的（例如，一个空字符串），并且不包含 Merlin 尚不具备的任何信息。因此，第一轮是无关紧要的，我们可以将协议建模为 Merlin 简单地向 Arthur 发送一个证明字符串 $y$。\n2.  Merlin，凭借其无限的计算能力，向 Arthur 发送一个证明字符串 $y$。$y$ 的长度必须是 $x$ 长度的多项式。\n3.  Arthur，一个确定性多项式时间验证者，接收 $y$ 并根据输入 $x$ 和证明 $y$ 决定是接受还是拒绝。我们用一个多项式时间算法 $V(x, y)$ 来表示 Arthur 的验证过程，该算法对于“接受”输出 1，对于“拒绝”输出 0。\n\n现在让我们将 AM 的完备性和可靠性条件转换到 DAM 的上下文中。由于没有随机性，接受的概率要么是 0，要么是 1。\n\n-   **完备性：** 如果 $x \\in L$，必须存在一种 Merlin 的策略使得 Arthur 接受。由于 Arthur 的最终决定是确定性的，这意味着必须存在一个证明字符串 $y$（多项式长度），使得 $V(x, y) = 1$。其“概率”为 1，满足 $\\geq 2/3$ 的条件。\n\n-   **可靠性：** 如果 $x \\notin L$，对于 Merlin 使用的任何策略，Arthur 都必须拒绝。这意味着对于 Merlin 可能发送的任何证明字符串 $y$，Arthur 的验证都必须失败。也就是说，对于所有（多项式长度的）字符串 $y$，$V(x, y) = 0$。接受的“概率”为 0，满足 $\\leq 1/3$ 的条件。\n\n所以，一个语言 $L$ 属于 DAM 当且仅当存在一个确定性多项式时间算法 $V$ 和一个多项式函数 $p$，使得对于任何输入字符串 $x$：\n$x \\in L \\iff \\exists y$ 满足 $|y| \\leq p(|x|)$ 使得 $V(x, y) = 1$。\n\n这恰好是复杂性类 NP (非确定性多项式时间) 的基于验证者的定义。在 NP 的语境中，字符串 $y$ 被称为“证书”或“见证”。NP 的定义是：一个语言 $L$ 属于 NP，如果存在一个多项式时间验证者 $V$，使得对于每一个 $x$，$x \\in L$ 当且仅当存在一个在 $|x|$ 上是多项式长度的证书 $y$，$V$ 会接受它。\n\n我们推导出的 DAM 定义与 NP 的定义完全相同。\n\n让我们考虑其他选项：\n-   **A. P:** 如果 Arthur 可以在多项式时间内自己决定该语言，而不需要 Merlin 的证明，那么情况就是这样。我们的定义允许存在这样一些问题，其中找到证明 $y$ 可能很困难，但验证它很容易，这正是那些尚不知道是否属于 P 的 NP 问题（如 SAT）的本质。\n-   **C. co-NP:** 如果一个语言的补集在 NP 中，那么该语言就在 co-NP 中。这意味着对于“否”实例（$x \\notin L$），存在一个简短的非成员资格证明。我们的 DAM 定义要求为“是”实例（$x \\in L$）提供证明。\n-   **D. BPP:** 这个类是由概率算法定义的。我们明确地从 Arthur 那里移除了随机性，所以结果类不是概率性的。\n-   **E. PSPACE:** 虽然 NP 包含在 PSPACE 中，但没有理由相信它们是相等的。DAM 协议只授予 Arthur 多项式时间，而不是多项式空间，所以没有理由让它像 PSPACE 一样强大。\n\n因此，修改后的类 DAM 等价于 NP。", "answer": "$$\\boxed{B}$$", "id": "1450703"}, {"introduction": "交互式证明不仅是理论上的概念，它们还为高效验证复杂断言提供了强大的框架。这个实践问题将我们从抽象的定义带入一个线性代数中的具体应用。你将分析一个用于验证矩阵秩的协议，并看到随机性如何让一个计算成本可能很高的任务拥有一个惊人简单和快速的验证过程。[@problem_id:1450673]", "problem": "在计算复杂性理论领域，一个Arthur-Merlin（AM）协议是一种交互式证明系统，其中一个计算能力有界、概率性的验证者（Arthur）与一个全能但可能不可信的证明者（Merlin）进行交互。为了本问题的目的，考虑一个单轮协议，其中Merlin向Arthur发送一个单一的证明字符串。然后Arthur执行一个随机化计算，该计算必须在输入大小的多项式时间内完成，以决定是接受还是拒绝Merlin的声明。\n\n考虑以下判定问题：给定一个 $n \\times n$ 矩阵 $M$，其元素来自一个大有限域 $\\mathbb{F}_q$，以及一个整数 $k$（其中 $1 \\leq k \\leq n$），判定 $M$ 的秩是否至少为 $k$。Merlin的目标是构建一个证明来说服Arthur $\\text{rank}(M) \\geq k$。Arthur的验证算法应该非常高效，理想情况下应避免像完整行列式计算这样计算上昂贵的基本操作。\n\n以下哪项描述了针对此任务的一个正确且高效的协议，同时满足完备性（Arthur以概率1接受一个真实的声明）和可靠性（Arthur以至多1/2的概率接受一个虚假的声明）的条件？\n\nA. Merlin识别出 $M$ 的一个 $k \\times k$ 子矩阵 $A$。Arthur选择两个随机向量 $u, v \\in \\mathbb{F}_q^k$ 并发送给Merlin。Merlin返回一个标量 $\\alpha$，声称其等于 $u^T A v$。然后Arthur自己计算 $u^T A v$，如果他的结果与 $\\alpha$ 匹配，则接受。\n\nB. Merlin识别出 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称其非奇异，并将其行和列索引发送给Arthur。然后Arthur随机选择 $k$ 个向量 $v_1, \\dots, v_k \\in \\mathbb{F}_q^k$，计算像向量 $u_i = A v_i$（对于 $i=1, \\dots, k$），如果向量集合 $\\{u_1, \\dots, u_k\\}$ 是线性无关的，则接受。\n\nC. Merlin识别出 $M$ 的 $k$ 个列，声称它们是线性无关的，形成一个 $n \\times k$ 的子矩阵 $M_C$。他将这些列的索引发送给Arthur。Arthur构造一个随机的 $k \\times n$ 矩阵 $R$ 并计算 $k \\times k$ 的乘积矩阵 $P = R M_C$。如果 $P$ 的行列式非零，则Arthur接受。\n\nD. Merlin识别出 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称其非奇异。他计算一个矩阵 $B$，声称是 $A$ 的逆矩阵。他将 $A$ 的索引和矩阵 $B$ 发送给Arthur。Arthur选择一个随机向量 $v \\in \\mathbb{F}_q^k$，计算 $w = Bv$，然后计算 $w' = Aw$。如果 $w'$ 等于原始向量 $v$，则Arthur接受。\n\nE. Merlin识别出 $M$ 的一个 $k \\times k$ 子矩阵 $A$，声称其非奇异，并将其索引发送给Arthur。Arthur选择一个随机向量 $r \\in \\mathbb{F}_q^k$ 并作为挑战发送给Merlin。然后Merlin找到并返回一个向量 $x$，声称是方程组 $Ax = r$ 的解。如果 $Ax$ 确实等于 $r$，则Arthur接受。", "solution": "我们需要一个单轮协议：Merlin发送一个证明字符串；然后Arthur执行一个随机化的多项式时间验证，其完备性为1，可靠性至多为 $\\frac{1}{2}$。该判定问题是验证 $\\operatorname{rank}(M) \\geq k$ 是否成立。这等价于 $M$ 中存在一个 $k \\times k$ 的非奇异子矩阵 $A$，因为 $\\operatorname{rank}(M) \\geq k$ 当且仅当 $M$ 有 $k$ 个线性无关的列（或行），这又等价于存在一个行列式非零的 $k \\times k$ 子矩阵。\n\n考虑选项D。Merlin识别出一个 $k \\times k$ 的子矩阵 $A$ 并提供一个声称是 $A^{-1}$ 的矩阵 $B$。Arthur选择一个随机向量 $v \\in \\mathbb{F}_{q}^{k}$，计算 $w = B v$，然后计算 $w' = A w = A(Bv)$，如果 $w' = v$ 则接受。验证的断言是 $A B v = v$。令 $I_{k}$ 表示 $k \\times k$ 的单位矩阵。\n\n完备性：如果 $\\operatorname{rank}(M) \\geq k$，则存在一个 $k \\times k$ 的非奇异子矩阵 $A$。如果Merlin发送了正确的 $B = A^{-1}$，那么 $A B = I_k$。因此对于任意 $v \\in \\mathbb{F}_{q}^{k}$，\n$$\nA(B v) = (A B) v = I_k v = v\n$$,\n所以Arthur在其随机选择上的接受概率为 $1$。因此完备性为 $1$。\n\n可靠性：如果 $\\operatorname{rank}(M)  k$，那么每个 $k \\times k$ 的子矩阵 $A$ 都是奇异的，因此不存在任何 $B$ 使得 $A B = I_k$。对于Merlin发送的任何矩阵 $B$，定义误差矩阵\n$$\nE \\triangleq A B - I_k.\n$$\n由于 $A$ 是奇异的，所以 $E \\neq 0$。Arthur接受当且仅当 $E v = 0$。对于一个从 $\\mathbb{F}_{q}^{k}$ 中均匀随机选取的向量 $v$，接受概率等于\n$$\n\\Pr_{v \\leftarrow \\mathbb{F}_{q}^{k}}[E v = 0] = \\frac{|\\operatorname{ker}(E)|}{q^{k}} = \\frac{q^{\\dim(\\operatorname{ker}(E))}}{q^{k}}.\n$$\n因为 $E \\neq 0$，我们有 $\\operatorname{rank}(E) \\geq 1$，所以根据秩-零度定理，\n$$\n\\dim(\\operatorname{ker}(E)) = k - \\operatorname{rank}(E) \\leq k - 1,\n$$\n这意味着\n$$\n\\Pr[\\text{accept}] \\leq \\frac{q^{k-1}}{q^{k}} = \\frac{1}{q} \\leq \\frac{1}{2}.\n$$\n因此可靠性至多为 $\\frac{1}{2}$。Arthur的计算仅使用在 $\\mathbb{F}_{q}$ 上的矩阵-向量乘法，需要 $O(k^{2})$ 次域运算，以及从 $M$ 中提取 $A$ 的元素，避免了完整的行列式计算。\n\n现在考虑其他选项：\n\nA. 这是多轮的（Arthur向Merlin发送 $u, v$），并且不测试非奇异性：无论 $A$ 是否奇异，$u^{T} A v$ 的等式都可能成立。它既不满足单轮约束，也不满足可靠性要求。\n\nB. Merlin发送一个 $k \\times k$ 子矩阵 $A$ 的索引。Arthur随机选择 $v_{1},\\dots,v_{k} \\in \\mathbb{F}_{q}^{k}$，如果 $\\{A v_{i}\\}$ 是线性无关的，则接受。即使 $A$ 是非奇异的，随机选择的 $\\{v_{i}\\}$ 也可能以正概率线性相关，导致对真实声明的拒绝。因此完备性小于1，违反了要求。\n\nC. Merlin发送 $k$ 个独立列的索引，形成 $M_{C}$。Arthur选择一个随机的 $R \\in \\mathbb{F}_{q}^{k \\times n}$，如果 $\\det(R M_{C}) \\neq 0$ 则接受。当 $M_{C}$ 具有满列秩时，随着 $R$ 均匀变化，$R M_{C}$ 在 $\\mathbb{F}_{q}^{k \\times k}$ 上均匀分布，所以\n$$\n\\Pr[\\det(R M_{C}) \\neq 0] = \\prod_{i=0}^{k-1} \\left(1 - q^{-(k-i)}\\right)  1,\n$$\n因此完备性小于1，违反了要求。\n\nE. 这是一个标准的交互式证明：Arthur发送一个随机的 $r \\in \\mathbb{F}_{q}^{k}$，Merlin返回一个满足 $A x = r$ 的 $x$。它的完备性为1，可靠性至多为 $\\frac{1}{q}$，但它不是单轮的，因为Arthur向Merlin发送了一个挑战。因此它违反了单轮约束。\n\n只有D满足单轮、完备性为1、可靠性至多为 $\\frac{1}{2}$ 和高效性的要求。", "answer": "$$\\boxed{D}$$", "id": "1450673"}, {"introduction": "$AM$ 协议的能力超越了简单的存在性证明，它还能够验证更复杂的性质，如计数和唯一性。最后的这个练习要求你为唯一可满足性问题 (UNIQUE-SAT) 设计一个协议，这需要使用强大的算术化技术。该方法将逻辑公式转换为多项式，使亚瑟能够通过在随机点上检查代数恒等式来验证关于解的数量的断言。[@problem_id:1450707]", "problem": "在计算复杂性理论中，Arthur-Merlin (AM) 类刻画了可通过特定交互式证明系统解决的判定问题。一个 AM 协议涉及对输入串 $w$ 的三轮通信：\n1.  **Merlin - Arthur:** 全能但不可信的巫师 Merlin 向 Arthur 发送一个证明串 $m_1$。\n2.  **Arthur - Merlin:** 概率多项式时间验证者 Arthur 向 Merlin 发送一个公共随机串 $r$。\n3.  **Merlin - Arthur:** Merlin 向 Arthur 发送最后一个证明串 $m_2$。\n然后 Arthur 基于 $w$、$m_1$、$r$ 和 $m_2$ 进行多项式时间计算以决定接受或拒绝。该协议必须满足：\n-   **完备性：** 如果 $w$ 在语言中，则存在一种 Merlin 的策略，使得 Arthur 以至少 $2/3$ 的概率接受。\n-   **可靠性：** 如果 $w$ 不在语言中，则对于 Merlin 使用的任何策略，Arthur 以至多 $1/3$ 的概率接受。\n\n考虑语言 UNIQUE-SAT，它由所有恰好有一个满足赋值的布尔可满足性公式组成。你的任务是为 UNIQUE-SAT 设计一个 AM 协议的核心。\n\n假设协议开始时，Merlin 发送一个字符串 $a$，他声称这是给定具有 $n$ 个变量的公式 $\\phi$ 的唯一满足赋值。Arthur 在多项式时间内验证 $\\phi(a)$ 确实为真。核心挑战在于接下来的交互阶段，Merlin 必须说服 Arthur 这个赋值的*唯一性*。以下哪项描述了这种交互式唯一性证明的有效且正确的机制？\n\nA. Arthur 选择一个随机哈希函数 $h: \\{0,1\\}^n \\to \\{0,1\\}^n$ 和一个随机值 $z \\in \\{0,1\\}^n$。他将 $(h, z)$ 发送给 Merlin。为了让 Arthur 相信唯一性，Merlin 必须证明不存在赋值 $y \\neq a$ 使得 $\\phi(y)$ 为真且 $h(y) = z$。\n\nB. Arthur 和 Merlin 同意将公式 $\\psi(y) = \\phi(y) \\land (y \\neq a)$ 算术化为一个在一个大有限域 $\\mathbb{F}_q$ 上的低次多元多项式 $P(y_1, \\dots, y_n)$。Arthur 从 $\\mathbb{F}_q^n$ 中发送一个随机点 $(r_1, \\dots, r_n)$ 给 Merlin。Merlin 回复一个单变量多项式序列 $g_1, \\dots, g_n$。Arthur 通过检查 $g_i$ 之间以及与最终求值 $P(r_1, \\dots, r_n)$ 的关系，来验证这些多项式正确地编码了“$P(y)$ 在所有 $y \\in \\{0,1\\}^n$ 上的和为零”这一断言。\n\nC. Arthur 和 Merlin 同意将公式 $\\psi(y) = \\phi(y) \\land (y \\neq a)$ 算术化为一个多项式 $P(y_1, \\dots, y_n)$。Arthur 生成一个单一的随机点 $r = (r_1, \\dots, r_n)$ 并发送给 Merlin。Merlin 必须计算并返回数值 $v = P(r)$。当且仅当 $v=0$ 时，Arthur 才接受该赋值是唯一的。\n\nD. Merlin 构建一个图，其中顶点是 $2^n$ 个可能的变量赋值。然后他向 Arthur 提供一个证书，证明与赋值 $a$ 对应的顶点在所有满足赋值所构成的子图中形成一个大小为一的连通分量。\n\nE. Merlin 将唯一性声明重新表述为真量化布尔公式 (TQBF) $\\exists x \\forall y ((\\phi(x)) \\land (\\phi(y) \\implies y=x))$。然后他与 Arthur 进行一个已知的 TQBF 的 AM 协议，以证明这个新公式为真。", "solution": "我们必须说服 Arthur，Merlin 发送的赋值 $a \\in \\{0,1\\}^n$ 是 $\\phi$ 的唯一满足赋值。令 $\\psi(y)$ 是由\n$$\n\\psi(y) \\equiv \\phi(y) \\land (y \\neq a).\n$$\n定义的布尔谓词。$a$ 的唯一性等价于\n$$\n\\sum_{y \\in \\{0,1\\}^{n}} \\psi(y) \\;=\\; 0.\n$$\n为了将其置于 AM 框架中，我们将 $\\psi$ 算术化为一个在足够大的有限域 $\\mathbb{F}_{q}$ 上的低次多元多项式 $P \\in \\mathbb{F}_{q}[y_1,\\dots,y_n]$，使得：\n- 对于所有 $y \\in \\{0,1\\}^{n}$，$P(y) \\in \\{0,1\\}$ 且 $P(y) = 1$ 当且仅当 $\\psi(y)$ 为真。\n- $P$ 的总次数以一个关于 $n$ 的多项式为界。\n\n定义目标和\n$$\nS \\;=\\; \\sum_{y \\in \\{0,1\\}^{n}} P(y).\n$$\n断言“$a$ 是唯一的”等价于 $S=0$。这个断言可以通过标准的求和检验协议 (sumcheck protocol) 来验证，该协议是一个公共掷币交互式证明，因此可以在 AM 格式中实现，其中 Arthur 一次性发送他所有的随机选择。\n\n具体来说，对于 $i=1,\\dots,n$，定义单变量多项式\n$$\ng_{1}(X_{1}) \\;=\\; \\sum_{y_{2},\\dots,y_{n} \\in \\{0,1\\}} P(X_{1},y_{2},\\dots,y_{n}),\n$$\n并且，对于 $i \\geq 2$，归纳定义\n$$\ng_{i}(X_{i}) \\;=\\; \\sum_{y_{i+1},\\dots,y_{n} \\in \\{0,1\\}} P(r_{1},\\dots,r_{i-1},X_{i},y_{i+1},\\dots,y_{n}),\n$$\n其中 $(r_{1},\\dots,r_{n}) \\in \\mathbb{F}_{q}^{n}$ 是 Arthur 的随机挑战。每个 $g_{i}$ 的次数最多为 $P$ 在相应变量上的次数，因此最多是关于 $n$ 的多项式。\n\n一个与 AM 兼容的执行过程如下：\n- Merlin 首先发送 $a$，Arthur 在多项式时间内检查 $\\phi(a)$ 是否为真。\n- Arthur 从 $\\mathbb{F}_{q}^{n}$ 中均匀随机抽样 $(r_{1},\\dots,r_{n})$，并将其作为单个公共随机串发送。\n- Merlin 回复所声称的单变量多项式序列 $g_{1},\\dots,g_{n}$。\n\nArthur 执行以下多项式时间检查：\n1. 检查 $g_{1}(0) + g_{1}(1) = 0$ (这编码了断言 $S=0$)。\n2. 对于每个 $i=1,\\dots,n-1$，检查一致性：\n$$\ng_{i}(r_{i}) \\stackrel{?}{=} g_{i+1}(0) + g_{i+1}(1).\n$$\n3. 最后，检查\n$$\ng_{n}(r_{n}) \\stackrel{?}{=} P(r_{1},\\dots,r_{n}),\n$$\n其中 Arthur 通过在该点计算 $\\psi$ 的算术化结果，在多项式时间内自己计算 $P(r_{1},\\dots,r_{n})$。这个求值是高效的，因为 $P$ 是通过标准的低次扩展从 $\\phi$ 和谓词 $(y \\neq a)$ 获得的。\n\n完备性：如果 $a$ 是唯一的，则 $S=0$。一个诚实的 Merlin 可以提供正确的 $g_{i}$ 多项式。所有检查都确定性地通过，因此 Arthur 以至少 $\\frac{2}{3}$ 的概率接受（实际上，在理想化设置中，对于 Arthur 的随机性，概率为 $1$）。\n\n可靠性：如果存在 $y \\neq a$ 使得 $\\phi(y)$ 为真，那么 $S \\geq 1$，所以任何声称 $S=0$ 的 $g_i$ 序列必定在某一步不一致。根据标准的求和检验可靠性和 Schwartz–Zippel 引理，在随机的 $(r_{1},\\dots,r_{n})$ 上，一个不一致的序列通过所有检查的概率至多为\n$$\n\\frac{\\deg(P)}{|\\mathbb{F}_{q}|}\n$$\n乘以一个关于 n 的多项式因子（因为有一系列检查）。选择一个关于 $n$ 的多项式大小的 $|\\mathbb{F}_{q}|$ 可以确保这个作弊概率至多为 $\\frac{1}{3}$。因此，AM 的完备性和可靠性要求都得到了满足。\n\n因此，有效的机制正是选项 B 中描述的算术化加求和检验方法。\n\n其他选项为什么失败：\n- A: 对于 $h:\\{0,1\\}^{n} \\to \\{0,1\\}^{n}$ 和随机的 $z$，第二个解与 $z$ 碰撞的概率是 $2^{-n}$，这是指数级小的，并且不能通过多项式次数的重复来提升到常数。此外，如果没有算术化的交互式证明结构，为每个 $(h,z)$ 证明不存在性是 coNP-难的。\n- C: 单一的随机点求值 $P(r)$ 无法提供整个超立方体上的和为零的证书，并且让 Merlin 报告 $P(r)$ 是无用的，除非 Arthur 能够独立验证它，但这无论如何都会归结为完整的求和检验框架；如其所述，这是不可靠的。\n- D: 所描述的图有 $2^{n}$ 个顶点；在满足赋值中构造并验证一个单点连通分量的证书是无法在多项式时间内检查的。\n- E: TQBF 是 PSPACE-完全的，并且不知道它是否在 AM 中；调用一个用于 TQBF 的 AM 协议是无效的。\n\n因此，只有 B 描述了一种证明唯一性的正确 AM 机制。", "answer": "$$\\boxed{B}$$", "id": "1450707"}]}