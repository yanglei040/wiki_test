{"hands_on_practices": [{"introduction": "随机算法的威力并不仅仅在于它在大多数情况下是正确的。BPP类的核心在于，对于“是”和“否”的输入，算法的接受概率之间必须存在一个明确的“鸿沟”。这个练习将挑战你对这一基本定义的理解，让你辨析为什么一个看似可靠的概率保证，若缺少了这个关键的概率鸿沟，可能仍不足以将一个问题归入BPP。[@problem_id:1450963]", "problem": "考虑一个语言 $L$。假设存在一个多项式时间的概率图灵机 (PTM) $M$，对于任何输入字符串 $w$，它具有以下特性：\n1. 如果 $w \\in L$，那么 $M$ 接受 $w$ 的概率至少是 $0.9$。\n2. 如果 $w \\notin L$，那么 $M$ 拒绝 $w$ 的概率至少是 $0.1$。\n\n这样一台机器 $M$ 的存在是否必然意味着语言 $L$ 属于复杂性类 BPP (有界错误概率多项式时间)？请选择最佳的推理。\n\nA. 是的，因为可以使用放大技术将错误概率降低到任何期望的量，这是 BPP 的定义特征。\n\nB. 不是，因为对于不在 $L$ 中的字符串，拒绝概率太低了。BPP 对“否”实例要求有高得多的拒绝概率。\n\nC. 是的，因为对于在 $L$ 中的字符串，接受概率是 $0.9$，这大于 BPP 的标准阈值 $2/3$。\n\nD. 不是，因为对于在 $L$ 中的字符串的接受概率和不在 $L$ 中的字符串的接受概率之间没有保证的差距。\n\nE. 在不知道界定 $M$ 运行时间的具体多项式的情况下，无法确定。", "solution": "设 $L$ 是一个语言，设 $M$ 是一个具有所述性质的多项式时间概率图灵机。对于任何输入 $w$，记\n$$\np_{\\text{yes}}(w) := \\Pr[M \\text{ accepts } w \\mid w \\in L], \\quad p_{\\text{no}}(w) := \\Pr[M \\text{ accepts } w \\mid w \\notin L].\n$$\n给定的条件是：\n$$\nw \\in L \\implies p_{\\text{yes}}(w) \\geq 0.9, \\quad w \\notin L \\implies \\Pr[M \\text{ rejects } w] \\geq 0.1 \\iff p_{\\text{no}}(w) \\leq 0.9.\n$$\n因此，两种情况之间唯一能保证的关系是\n$$\np_{\\text{yes}}(w) \\geq 0.9 \\quad \\text{and} \\quad p_{\\text{no}}(w) \\leq 0.9,\n$$\n这允许对所有 $w$ 都有 $p_{\\text{yes}}(w) = p_{\\text{no}}(w) = 0.9$。因此，在“是”实例和“否”实例上的接受概率之间没有保证的优势（差距）。\n\n根据定义，如果存在一个多项式时间的 PTM $N$ 和一个常数 $\\epsilon \\in (0, \\tfrac{1}{2})$，使得对于所有的 $w$ 都满足以下条件，则 $L \\in \\mathrm{BPP}$：\n$$\nw \\in L \\implies \\Pr[N \\text{ accepts } w] \\geq \\tfrac{1}{2} + \\epsilon, \\quad\nw \\notin L \\implies \\Pr[N \\text{ accepts } w] \\leq \\tfrac{1}{2} - \\epsilon.\n$$\n只有当存在这样一个常数差距 $\\epsilon>0$ 时，通过独立重复和多数表决的标准放大技术才能指数级快速地减少错误。如果“是”实例和“否”实例的接受概率可以相等（例如，都是 $0.9$），那么就没有可供放大的偏差，重复执行也无法产生一个有界错误的决策器。\n\n一个具体的反例说明了这个问题：考虑一台机器 $M_{0}$，它忽略其输入，并以 $0.9$ 的概率接受，以 $0.1$ 的概率拒绝。对于任何语言 $L$ 和任何输入 $w$，如果 $w \\in L$，则 $\\Pr[M_{0} \\text{ accepts } w] = 0.9 \\geq 0.9$，并且如果 $w \\notin L$，则 $\\Pr[M_{0} \\text{ rejects } w] = 0.1 \\geq 0.1$。因此，$M_{0}$ 满足所述性质，但它没有在“是”实例和“否”实例之间提供任何区分，并且不能被放大成为一个用于 $L$ 的 BPP 决策器。\n\n因此，仅仅存在这样一台机器 $M$ 并不意味着 $L \\in \\mathrm{BPP}$。正确的推理是，在“是”实例和“否”实例上的接受概率之间没有保证的差距。\n\n因此，最佳选项是 D。", "answer": "$$\\boxed{D}$$", "id": "1450963"}, {"introduction": "一旦我们拥有了BPP算法所要求的概率鸿沟，我们如何利用它来获得几乎确定的答案？答案是“放大”（amplification）技术，即多次运行算法并采纳多数票结果。这个练习将这一抽象概念具体化：你需要计算为了使算法的错误率低于宇宙射线导致硬件错误的概率，需要重复运行多少次。通过这个计算，你将亲身体会到放大技术如何将一个有微小错误的算法，转变为一个在现实世界中极其可靠的工具。[@problem_id:1450962]", "problem": "一个复杂度类 BPP（有界错误概率多项式时间）中的算法被设计用于解决一个判定问题。对于任意给定的输入，它有双边错误概率，这意味着它可能返回错误的答案（当正确答案是“否”时返回“是”，或反之），其概率至多为 $p=1/3$。\n\n为了提高该算法的可靠性，采用了一种标准的放大技术：在相同的输入上将算法运行 $k$ 次，并对结果进行汇总。对于本问题，我们定义整个过程失败的条件为：单次运行出错的次数至少为总运行次数 $k$ 的一半。\n\n你的任务是确定这种放大技术需要有多鲁棒，才能超越其运行硬件的物理限制。计算所需的最小整数重复次数 $k$，以确保算法的整体失败概率严格小于由随机高能粒子引起的硬件错误概率。假设在单次计算中，此类硬件错误（例如由宇宙射线引起的比特翻转）的概率为 $P_{\\text{cosmic}} = 2.5 \\times 10^{-15}$。\n\n为了进行计算，我们提供以下形式的 Chernoff 界。设 $X_1, \\dots, X_k$ 是独立的指示随机变量，其中 $P(X_i=1)=p$。设 $X = \\sum_{i=1}^k X_i$ 是这些变量的和，并设 $\\mu = E[X] = kp$ 是其和的期望。对于任意 $\\delta > 0$，$X$ 偏离其均值的概率有如下界：\n$$P(X \\ge (1+\\delta)\\mu) \\le \\exp\\left(-\\frac{\\delta^2 \\mu}{3}\\right)$$\n\n请给出满足条件的最小整数 $k$ 作为你的答案。你可以使用数值 $\\ln(10) \\approx 2.3026$ 和 $\\ln(2.5) \\approx 0.9163$。", "solution": "我们考虑对 BPP 算法进行 $k$ 次独立重复。设 $X_{i}$ 为第 $i$ 次运行结果不正确的指示变量，其中 $P(X_{i}=1)=p=\\frac{1}{3}$，并定义 $X=\\sum_{i=1}^{k}X_{i}$。那么 $X \\sim \\text{Binomial}(k,p)$ 并且 $\\mu=E[X]=kp=\\frac{k}{3}$。整个过程被定义为失败，如果至少一半的运行是不正确的，即事件 $\\{X \\ge \\frac{k}{2}\\}$。\n\n我们应用给定的 Chernoff 界。选择 $\\delta>0$ 使得 $(1+\\delta)\\mu=\\frac{k}{2}$。将 $\\mu=\\frac{k}{3}$ 代入可得\n$$\n(1+\\delta)\\frac{k}{3}=\\frac{k}{2}\\quad\\Rightarrow\\quad 1+\\delta=\\frac{3}{2}\\quad\\Rightarrow\\quad \\delta=\\frac{1}{2}.\n$$\nChernoff 界表明\n$$\nP\\!\\left(X \\ge (1+\\delta)\\mu\\right) \\le \\exp\\!\\left(-\\frac{\\delta^{2}\\mu}{3}\\right).\n$$\n当 $\\delta=\\frac{1}{2}$ 且 $\\mu=\\frac{k}{3}$ 时，我们得到\n$$\nP\\!\\left(X \\ge \\frac{k}{2}\\right) \\le \\exp\\!\\left(-\\frac{\\left(\\frac{1}{2}\\right)^{2}\\cdot \\frac{k}{3}}{3}\\right)=\\exp\\!\\left(-\\frac{k}{36}\\right).\n$$\n\n我们要求算法的整体失败概率严格小于硬件错误概率 $P_{\\text{cosmic}}=2.5 \\times 10^{-15}$：\n$$\n\\exp\\!\\left(-\\frac{k}{36}\\right)  2.5 \\times 10^{-15}.\n$$\n两边取自然对数并解出 $k$，\n$$\n-\\frac{k}{36}  \\ln(2.5) + \\ln\\!\\left(10^{-15}\\right)=\\ln(2.5) - 15\\ln(10),\n$$\n$$\n\\frac{k}{36} > 15\\ln(10) - \\ln(2.5),\n$$\n$$\nk > 36\\bigl(15\\ln(10) - \\ln(2.5)\\bigr).\n$$\n使用提供的近似值 $\\ln(10)\\approx 2.3026$ 和 $\\ln(2.5)\\approx 0.9163$，\n$$\n15\\ln(10) - \\ln(2.5) \\approx 15\\cdot 2.3026 - 0.9163 = 34.539 - 0.9163 = 33.6227,\n$$\n$$\n36 \\cdot 33.6227 \\approx 1210.4172.\n$$\n由于不等式是严格的，满足条件的最小整数 $k$ 是\n$$\nk=1211.\n$$", "answer": "$$\\boxed{1211}$$", "id": "1450962"}, {"introduction": "BPP的计算能力在多大程度上依赖于其使用的随机性？如果一个概率算法只能使用有限的随机比特，它的计算能力会发生什么变化？这个问题探讨了BPP与经典确定性计算类P之间的深刻联系。通过分析一个只使用对数数量随机比特的算法，你将发现随机性的力量并非无限，当随机资源受限时，我们可以通过一种巧妙的确定性方法完全消除随机性，从而证明该问题实际上属于P类。[@problem_id:1450965]", "problem": "一家科技初创公司开发了一种名为 `PathCheck` 的新颖概率算法，用于解决一个他们称之为 `DYNAMIC-PATH-VALIDITY` 的判定问题。该问题旨在确定，在满足一组复杂且动态变化的约束条件下，网络中的一条指定路径是否仍然有效。这些约束的具体性质是专有的，但 `PathCheck` 算法的性能特征是已知的。\n\n对于任何大小为 $n$ 的给定输入实例（编码了网络和路径），`PathCheck` 算法具有以下特性：\n1.  它总是在一个由多项式 $p(n) = n^4 + 100n^2$ 界定的时间内停止。\n2.  它精确使用 $k(n) = 10 \\log_2(n)$ 个随机比特来做出决策。\n3.  该算法的双边错误概率至多为 $\\epsilon = 1/4$。也就是说，对于任何输入，`PathCheck` 返回错误答案的概率至多为 $1/4$。\n\n回顾以下复杂性类的定义：\n- **P (多项式时间)**：可由一个确定性算法在步数为输入大小 $n$ 的多项式函数内解决的判定问题类。\n- **BPP (有界错误概率多项式时间)**：可由一个概率算法在多项式时间内解决的判定问题类，其中对于任何输入，算法给出正确答案的概率至少为 $2/3$。常数 $2/3$ 可以被任何大于 $1/2$ 的常数替换，而不会改变该类。\n\n*仅*根据 `PathCheck` 算法的这些已知特性，关于 `DYNAMIC-PATH-VALIDITY` 问题的复杂性类，可以得出的最强的确定性结论是什么？\n\nA. `DYNAMIC-PATH-VALIDITY` 属于 P。\n\nB. `DYNAMIC-PATH-VALIDITY` 属于 BPP，但没有足够的信息断定它属于 P。\n\nC. `DYNAMIC-PATH-VALIDITY` 属于 NP，但没有足够的信息断定它属于 BPP。\n\nD. `DYNAMIC-PATH-VALIDITY` 不属于 BPP，因为其错误概率 $1/4$ 并非小于或等于 $1/3$。\n\nE. `PathCheck` 的特性不足以将 `DYNAMIC-PATH-VALIDITY` 归入任何比 EXP (指数时间) 更小的复杂性类中。", "solution": "给定一个针对输入大小为 $n$ 的概率算法 `PathCheck`，其具有以下特性：\n- 运行时间由多项式 $p(n) = n^{4} + 100 n^{2}$ 界定。\n- 精确使用 $k(n) = 10 \\log_{2}(n)$ 个随机比特。\n- 对任何输入的双边错误概率至多为 $\\epsilon = \\frac{1}{4}$。\n\n首先，请注意 `PathCheck` 在大小为 $n$ 的输入上使用的随机比特串（种子）的总数为\n$$\nS(n) = 2^{k(n)} = 2^{10 \\log_{2}(n)} = \\left(2^{\\log_{2}(n)}\\right)^{10} = n^{10}.\n$$\n对于任何固定的输入 $x$，错误概率的上界意味着导致错误答案的种子数量（记为 $B(x)$）满足\n$$\n|B(x)| \\le \\epsilon \\cdot S(n) = \\frac{1}{4} n^{10}.\n$$\n因此，产生正确答案的种子数量（记为 $G(x)$）满足\n$$\n|G(x)| = S(n) - |B(x)| \\ge n^{10} - \\frac{1}{4} n^{10} = \\frac{3}{4} n^{10}  \\frac{1}{2} n^{10}.\n$$\n因此，对于任何输入 $x$，严格超过一半的种子会产生正确的答案。\n\n按如下方式为该判定问题构造一个确定性算法：枚举所有 $S(n) = n^{10}$ 个种子 $r \\in \\{0,1\\}^{k(n)}$，对输入 $x$ 使用固定的随机性 $r$ 运行 `PathCheck`，并取多数输出结果。这样做是可行的，因为大多数种子会产生正确的答案，所以多数票决的结果等于对 $x$ 的正确判定。\n\n这个确定性模拟的运行时间至多为\n$$\nT(n) \\le S(n) \\cdot p(n) = n^{10} \\left(n^{4} + 100 n^{2}\\right) = n^{14} + 100 n^{12},\n$$\n这是一个关于 $n$ 的多项式。因此，该问题存在一个确定性多项式时间算法，这意味着该问题属于 P。\n\n虽然给定的特性也证明了该问题属于 BPP（因为正确率 $\\frac{3}{4} \\ge \\frac{2}{3}$ 且运行时间是多项式的），但从“仅使用 $O(\\log n)$ 个随机比特”这一额外事实可以得出的最强确定性结论是，通过在多项式时间内穷举所有种子，该问题属于 P。因此，正确选项是 A。", "answer": "$$\\boxed{A}$$", "id": "1450965"}]}