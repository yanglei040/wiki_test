{"hands_on_practices": [{"introduction": "我们从一个直观的例子开始，来掌握交互式证明系统的基本构成。这个练习要求我们分析一个判断给定整数是否为“非平方数”的简单协议，通过这个过程，我们将具体地理解证明者（Prover）和验证者（Verifier）的角色，以及完备性（completeness）和可靠性（soundness）这两个核心概念是如何被评估的。[@problem_id:1452378]", "problem": "在计算复杂性理论领域，一个交互式证明系统涉及两方：一个全能的证明者（Merlin）和一个计算能力有限的验证者（Arthur）。Merlin 的目标是说服 Arthur 一个给定的输入字符串属于某个语言。该系统的有效性通过两个属性来衡量：\n\n*   **完备性**：如果一个陈述为真，一个诚实的 Merlin 应该能够以高概率说服 Arthur。一个协议的完备性是 Arthur 接受一个真陈述的最小概率。\n*   **可靠性**：如果一个陈述为假，一个欺骗的 Merlin 不应该能够说服 Arthur。可靠性错误是 Arthur 接受一个假陈述的最大概率。\n\n考虑语言 $\\text{NON-SQUARE}$，它由所有大于1且不是完全平方数的正整数组成（例如，2, 3, 5, 6, 7, 8, 10 属于 NON-SQUARE，而 4, 9, 16 不属于）。\n\nMerlin 和 Arthur 进行以下单轮协议来确定一个给定的整数 $n  1$ 是否属于 NON-SQUARE：\n\n1.  **Merlin 的步骤**：Merlin 拥有无限的计算能力，因此知道 $n$ 的素数分解。他向 Arthur 提供一个正整数，我们称之为 $p$。\n2.  **Arthur 的验证**：Arthur 是一个多项式时间验证者，他对从 Merlin 收到的整数 $p$ 执行以下检查：\n    *   **检查 A**：Arthur 验证 $p$ 是一个素数并且 $p$ 整除 $n$。\n    *   **检查 B**：Arthur 计算使得 $p^k$ 整除 $n$ 的最大整数指数 $k$。然后他检查这个指数 $k$ 是否为奇数。\n3.  **Arthur 的决定**：如果检查 A 和检查 B 都通过，Arthur 就确信 $n$ 不是一个完全平方数，并接受。如果任一检查失败，或者 Merlin 未能提供一个可以通过检查的整数 $p$，Arthur 就拒绝。\n\n为本题之目的，假设 Arthur 拥有一个高效且完美的素性测试算法。\n\n这个协议的完备性和可靠性错误概率分别是多少？\n\nA. 完备性 = $1$，可靠性错误 = $1$\n\nB. 完备性 = $1$，可靠性错误 = $1/2$\n\nC. 完备性 = $1$，可靠性错误 = $0$\n\nD. 完备性 = $2/3$，可靠性错误 = $1/3$\n\nE. 完备性 = $1/2$，可靠性错误 = $1/2$\n\nF. 完备性 = $0$，可靠性错误 = $1$", "solution": "将 $n1$ 的唯一素数分解写作\n$$\nn=\\prod_{i=1}^{t} q_{i}^{e_{i}},\n$$\n其中 $q_{i}$ 是不同的素数，且 $e_{i} \\in \\mathbb{N}$。一个标准的数论事实是：\n$$\nn \\text{ 是一个完全平方数 } \\Longleftrightarrow \\forall i,\\ e_{i} \\text{ 是偶数},\n$$\n等价地，\n$$\nn \\in \\text{NON-SQUARE} \\Longleftrightarrow \\exists i \\text{ 使得 } e_{i} \\text{ 是奇数}。\n$$\n\n完备性：假设 $n\\in \\text{NON-SQUARE}$。那么存在一个下标 $j$ 使得 $e_{j}$ 是奇数。Merlin 可以发送 $p=q_{j}$。Arthur 验证 $p$ 是素数且 $p\\mid n$（检查 A），这是成立的，因为 $q_{j}\\mid n$。然后 Arthur 计算使 $p^{k}\\mid n$ 成立的最大 $k$，根据分解的定义，该值等于 $k=e_{j}$，并检查 $k$ 是否为奇数（检查 B），这也是成立的。所有的检查都是确定性的并且都能通过，所以 Arthur 以概率 $1$ 接受。因此，完备性等于 $1$。\n\n可靠性：假设 $n$ 是一个完全平方数。那么每一个 $e_{i}$ 都是偶数。考虑 Merlin 可能发送的任何消息 $p$。如果 $p$ 不是素数或 $p\\nmid n$，检查 A 失败，Arthur 拒绝。如果 $p$ 是 $n$ 的一个素因子，那么使 $p^{k}\\mid n$ 成立的最大 $k$ 是偶数（等于相应的 $e_{i}$），所以检查 B 失败，Arthur 拒绝。因此，没有任何欺骗策略能使 Arthur 接受；对假陈述的接受概率为 $0$。因此，可靠性错误等于 $0$。\n\n因此，完备性 $=1$ 且可靠性错误 $=0$，对应于选项 C。", "answer": "$$\\boxed{C}$$", "id": "1452378"}, {"introduction": "在实践中，许多交互式协议并非完美无缺，而是存在一个微小的“可靠性误差”，即验证者有一定概率被不诚实的证明者欺骗。这个练习将向我们展示一个至关重要的技术——“概率放大”（amplification），即通过重复执行协议来将这个错误概率降低到任意小的水平。[@problem_id:1452374] 我们将通过一个具体的计算，来理解如何确保协议满足极高的安全标准。", "problem": "交互式证明（IP）系统是一种协议，其中一个强大但不可信的证明者（Prover）试图让一个计算能力有限的验证者（Verifier）相信某个陈述的真实性。图非同构（GNI）的协议是这类系统的一个经典例子，用于证明两个给定的图在结构上并不相同。\n\n假设一个验证者正在使用一个特定的IP协议来判断两个给定的图 $G_0$ 和 $G_1$ 是否为非同构的。该协议具有以下性质：\n1.  **完美完备性**：如果图确实是非同构的（即陈述为真），证明者总能说服验证者。验证者以概率1接受。\n2.  **可靠性错误**：如果图是同构的（即陈述为假），一个恶意的证明者可以欺骗验证者接受这个错误的陈述，其概率最多为 $s = 1/2$。\n\n为了降低被欺骗的概率，验证者决定独立地运行该协议 $n$ 次。只有当证明者成功通过所有 $n$ 次独立试验时，验证者才会接受图是非同构的这一声明。此任务的网络安全策略要求，这个重复协议的总体可靠性错误必须严格小于灾难性的全系统故障的概率，该概率估计为 $P_{fail} = 3.5 \\times 10^{-31}$。\n\n满足此安全策略所需的最小整数重复次数 $n$ 是多少？", "solution": "在一个具有完美完备性和可靠性错误 $s$ 的交互式证明中，如果验证者独立运行协议 $n$ 次，并且仅在所有 $n$ 次试验都接受时才接受，那么总的可靠性错误的上界为 $s^{n}$，因为恶意的证明者必须在所有独立的试验中都成功。此处 $s=\\frac{1}{2}$，因此重复协议的可靠性错误为 $\\left(\\frac{1}{2}\\right)^{n}$。\n\n安全性要求是总的可靠性错误严格小于 $P_{fail}=3.5 \\times 10^{-31}$。因此 $n$ 必须满足\n$$\n\\left(\\frac{1}{2}\\right)^{n}  3.5 \\times 10^{-31}.\n$$\n对两边取 $\\log_{10}$，我们得到\n$$\nn \\log_{10}\\!\\left(\\frac{1}{2}\\right)  \\log_{10}\\!\\left(3.5 \\times 10^{-31}\\right).\n$$\n由于 $\\log_{10}\\!\\left(\\frac{1}{2}\\right)=-\\log_{10}(2)$，上式变为\n$$\n-n \\log_{10}(2)  \\log_{10}(3.5) - 31,\n$$\n两边同乘以 $-1$ (这会使不等号反向) 得到\n$$\nn \\log_{10}(2)  31 - \\log_{10}(3.5).\n$$\n因此，最小整数 $n$ 是\n$$\nn = \\left\\lceil \\frac{31 - \\log_{10}(3.5)}{\\log_{10}(2)} \\right\\rceil.\n$$\n数值上，$\\log_{10}(2) \\approx 0.30102999566$ 且 $\\log_{10}(3.5) \\approx 0.544068044$，所以\n$$\n\\frac{31 - \\log_{10}(3.5)}{\\log_{10}(2)} \\approx \\frac{30.455931956}{0.30102999566} \\approx 101.1724\\ldots,\n$$\n因此，满足该不等式的最小整数 $n$ 是\n$$\nn=102.\n$$\n快速验证一下：$2^{-101} \\approx 3.94 \\times 10^{-31}$，这个值尚未低于 $3.5 \\times 10^{-31}$，而 $2^{-102} \\approx 1.97 \\times 10^{-31}  3.5 \\times 10^{-31}$。", "answer": "$$\\boxed{102}$$", "id": "1452374"}, {"introduction": "交互式证明的巨大威力体现在其能够将复杂的组合问题转化为代数问题，这一过程称为“算术化”（arithmetization）。这个练习以大家熟悉的数独游戏为例，展示了如何利用强大的“和校验协议”（sum-check protocol）来验证一个解的唯一性。[@problem_id:1452382] 通过这个实践，我们将初步接触到证明 $IP=PSPACE$ 这类重大成果的核心技术。", "problem": "一个全能的证明者 Peggy，希望让一个计算能力有限但多疑的验证者 Victor 相信一个标准 $9 \\times 9$ 数独谜题的性质。具体来说，Peggy 声称给定的谜题有唯一解。\n\n为了将其形式化，他们约定了以下设置。数独网格的状态由 $m = 9 \\times 9 \\times 9 = 729$ 个布尔变量表示，统称为 $Z = (z_1, z_2, \\dots, z_m)$。对这些变量的一次特定赋值对应于将网格的每个单元格填入一个从 1 到 9 的数字。数独的规则，连同给定谜题的初始提示，可以被编码成一个单一的布尔公式 $\\phi(Z)$。当且仅当 $Z$ 表示该谜题的一个有效且完整的解时，这个公式 $\\phi(Z)$ 的值为真（或 1）。\n\n为了利用代数技术，布尔公式 $\\phi(Z)$ 被转换成一个在大的有限域 $\\mathbb{F}_q$ 上的多线性多项式 $p(z_1, \\dots, z_m)$。多项式 $p$ 具有这样的性质：对于任何赋值 $Z \\in \\{0,1\\}^m$，$p(Z) = \\phi(Z)$。因此，数独谜题的总解数由以下和式给出：\n$$N = \\sum_{z_1 \\in \\{0,1\\}} \\sum_{z_2 \\in \\{0,1\\}} \\cdots \\sum_{z_m \\in \\{0,1\\}} p(z_1, z_2, \\dots, z_m)$$\nPeggy 声称的唯一解等价于声称 $N=1$。\n\nPeggy 和 Victor 决定使用和校验交互式协议来验证这一声明。该协议分轮进行，每一轮都对一个变量的求和进行评估和检查。第一轮关注变量 $z_1$。令多项式 $g_1(Z_1)$ 定义为：\n$$g_1(Z_1) = \\sum_{z_2 \\in \\{0,1\\}} \\cdots \\sum_{z_m \\in \\{0,1\\}} p(Z_1, z_2, \\dots, z_m)$$\n协议将首先检验声明 $\\sum_{z_1 \\in \\{0,1\\}} g_1(z_1) = 1$。\n\n在和校验协议的第一轮中，以下哪个选项正确描述了证明者发送给验证者的第一条消息，以及验证者随后发送给证明者的第一条消息？\n\nA. 证明者致验证者：对唯一解网格的随机置换版本的密码学承诺。验证者致证明者：一个随机挑战比特 $b \\in \\{0,1\\}$。\n\nB. 证明者致验证者：由其系数指定的多项式 $g_1(Z_1)$。验证者致证明者：一个随机元素 $r_1 \\in \\mathbb{F}_q$。\n\nC. 证明者致验证者：两个数值 $g_1(0)$ 和 $g_1(1)$。验证者致证明者：一个随机元素 $r_1 \\in \\mathbb{F}_q$。\n\nD. 证明者致验证者：完整已解的数独网格。验证者致证明者：一个接受比特 $b \\in \\{0,1\\}$。\n\nE. 证明者致验证者：一个随机元素 $r_1 \\in \\mathbb{F}_q$。验证者致证明者：由其系数指定的多项式 $g_1(Z_1)$。", "solution": "我们将声称的计数形式化为对布尔超立方体的求和：\n$$N=\\sum_{z_{1}\\in\\{0,1\\}}\\sum_{z_{2}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(z_{1},z_{2},\\dots,z_{m}),$$\n其声明为 $N=1$。\n\n为第一轮定义单变量多项式：\n$$g_{1}(Z_{1})=\\sum_{z_{2}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(Z_{1},z_{2},\\dots,z_{m}).$$\n由于 $p$ 是多线性的（每个变量的次数最多为 1），$g_{1}$ 是一个关于 $Z_{1}$ 的次数最多为 1 的单变量多项式。\n\n在和校验协议中，证明者发送一个声称的单变量多项式 $h_{1}(Z_{1})$，意图使其等于 $g_{1}(Z_{1})$。验证者通过验证\n$$h_{1}(0)+h_{1}(1)=1,$$\n来检查声称的总和的一致性，并强制执行已知的次数界限 $\\deg(h_{1})\\leq 1$。接下来，为了通过随机自规约将此轮与下一轮联系起来，验证者从域中抽样一个随机元素\n$$r_{1}\\in\\mathbb{F}_{q}$$\n并将 $r_{1}$ 发送给证明者。在下一轮中，证明者必须生成\n$$g_{2}(Z_{2})=\\sum_{z_{3}\\in\\{0,1\\}}\\cdots\\sum_{z_{m}\\in\\{0,1\\}} p(r_{1},Z_{2},\\dots,z_{m}),$$\n然后验证者将检查一致性条件\n$$h_{1}(r_{1})=\\sum_{z_{2}\\in\\{0,1\\}} g_{2}(z_{2}).$$\n\n与选项比较：\n- 证明者必须发送单变量多项式 $g_{1}(Z_{1})$（例如，通过其系数），而不仅仅是两个评价值 $g_{1}(0)$ 和 $g_{1}(1)$，因为验证者需要在随机点 $r_{1}$ 处对其求值并强制执行次数界限。\n- 验证者的第一条消息是一个随机元素 $r_{1}\\in\\mathbb{F}_{q}$。\n\n因此，正确的描述是：证明者发送多项式 $g_{1}(Z_{1})$（通过系数），验证者以一个随机元素 $r_{1}\\in\\mathbb{F}_{q}$ 回应，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1452382"}]}