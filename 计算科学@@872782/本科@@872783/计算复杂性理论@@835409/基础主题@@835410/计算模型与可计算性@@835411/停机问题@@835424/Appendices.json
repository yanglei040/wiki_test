{"hands_on_practices": [{"introduction": "停机问题的不可解性证明的核心是优美的对角化论证。这个思想实验不仅仅是一个抽象概念，我们可以通过一个具体的构造来理解它。下面的练习将引导你构建一台“对角”图灵机，这台机器的设计本身就会导向一个逻辑悖论，从而直观地揭示为何一个能够判断所有程序是否停机的通用“停机检查器”不可能存在。[@problem_id:1457066]", "problem": "在可计算性理论的研究中，我们经常分析被称为图灵机的假设计算机器的行为。对于这个问题，我们考虑一组图灵机，记为 $M_1, M_2, M_3, \\dots$。每台机器都可以通过一个有限的符号串来唯一地描述，记为 $\\langle M_i \\rangle$。我们可以将一台机器的描述（例如 $\\langle M_j \\rangle$）作为另一台机器 $M_i$ 的输入。这个计算的结果，记为 $M_i(\\langle M_j \\rangle)$，是机器 $M_i$ 要么最终停机（`HALT`），要么永远运行（`LOOP`）。\n\n前三台这样的机器在前三个输入上的行为总结在下表中：\n\n| | 输入 $\\langle M_1 \\rangle$ | 输入 $\\langle M_2 \\rangle$ | 输入 $\\langle M_3 \\rangle$ |\n| :--- | :--- | :--- | :--- |\n| **机器 $M_1$** | `LOOP` | `HALT` | `HALT` |\n| **机器 $M_2$** | `HALT` | `LOOP` | `HALT` |\n| **机器 $M_3$** | `LOOP` | `LOOP` | `LOOP` |\n\n例如，第二行第三列的条目表明，当机器 $M_2$ 收到输入串 $\\langle M_3 \\rangle$ 时，它最终会停机：$M_2(\\langle M_3 \\rangle) \\to \\text{`HALT`}$。第一行第一列的条目表明 $M_1(\\langle M_1 \\rangle) \\to \\text{`LOOP`}$。\n\n现在，我们定义一台新的图灵机，称为“对角线机”$D$。$D$ 的行为是针对*任何*机器描述 $\\langle M_i \\rangle$作为输入而定义的：\n1.  在接收到输入 $\\langle M_i \\rangle$ 后，机器 $D$ 首先确定机器 $M_i$ 在其自身描述 $M_i(\\langle M_i \\rangle)$ 上运行的结果。这等价于查看上述表格（的无限大版本）的对角线条目。\n2.  如果 $M_i(\\langle M_i \\rangle)$ 的结果是 `HALT`，那么机器 $D$ 就被定义为进入无限`LOOP`。\n3.  如果 $M_i(\\langle M_i \\rangle)$ 的结果是 `LOOP`，那么机器 $D$ 就被定义为 `HALT`。\n\n本质上，$D$ 的构造使其行为与对角线条目相反。由于 $D$ 是一台图灵机，它也必须有自己的字符串描述 $\\langle D \\rangle$。\n\n当机器 $D$ 以其自身的描述 $\\langle D \\rangle$ 作为输入运行时，其最终行为是什么？\n\nA. $D$ 在输入 $\\langle D \\rangle$ 上会停机（HALT）。\n\nB. $D$ 在输入 $\\langle D \\rangle$ 上会循环（LOOP）。\n\nC. 行为未定义，因为 $D$ 不是原始表格中的机器之一（$M_1, M_2, M_3$）。\n\nD. 所描述的机器 $D$ 是自相矛盾的，因此无法被构造出来。", "solution": "我们给定了一个可数的图灵机列表 $\\{M_{1},M_{2},\\dots\\}$，其编码为 $\\langle M_{i}\\rangle$，以及一台机器 $D$ 的定义。$D$ 在输入 $\\langle M_{i}\\rangle$ 时，首先确定 $M_{i}(\\langle M_{i}\\rangle)$ 的结果，然后执行相反的操作：如果 $M_{i}(\\langle M_{i}\\rangle)$ 停机，则 $D$ 循环；如果 $M_{i}(\\langle M_{i}\\rangle)$ 循环，则 $D$ 停机。\n\n形式上，对于每个 $i$，\n$$\nD(\\langle M_{i}\\rangle)=\\text{HALT} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{LOOP},\n$$\n等价地，\n$$\nD(\\langle M_{i}\\rangle)=\\text{LOOP} \\iff M_{i}(\\langle M_{i}\\rangle)=\\text{HALT}.\n$$\n\n由于 $D$ 是一台图灵机，它有一个编码 $\\langle D\\rangle$。将 $M_{i}=D$ 代入，得出自应用条件\n$$\nD(\\langle D\\rangle)=\\text{HALT} \\iff D(\\langle D\\rangle)=\\text{LOOP}.\n$$\n在这个二值设定中，没有任何结果能满足这个等价关系：假设 $D(\\langle D\\rangle)=\\text{HALT}$ 会导出 $D(\\langle D\\rangle)=\\text{LOOP}$，而假设 $D(\\langle D\\rangle)=\\text{LOOP}$ 会导出 $D(\\langle D\\rangle)=\\text{HALT}$。因此，对于输入 $\\langle D\\rangle$，$D$ 无法被赋予一个一致的行为。\n\n因此，$D$ 的定义预设了能够判定任意 $i$ 的 $M_{i}(\\langle M_{i}\\rangle)$ 的能力，而当这个定义应用于满足 $M_{i}=D$ 的 $i$ 时，便会导致矛盾。在标准的可计算性理论中，这表明这样的 $D$ 不能被构造成一台图灵机。正确的选项是，所描述的 $D$ 是自相矛盾的，无法被构造出来。", "answer": "$$\\boxed{D}$$", "id": "1457066"}, {"introduction": "一旦我们证明了某个问题（如停机问题）是不可解的，我们就可以用它作为基石，通过一种称为“归约”（reduction）的强大技术来证明其他问题也是不可解的。这个练习是一个经典的归约构造任务。你将需要设计一台新的图灵机，用以证明：如果有人能解决“空输入停机问题”，那么他就能解决我们已知不可能解决的通用“接受问题”。[@problem_id:1457092]", "problem": "在理论计算机科学中，一个关键结果是图灵机接受问题的不可判定性。设图灵机 (TM) 是一种形式计算模型，类似于一个计算机程序。与接受问题相对应的语言表示为 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台接受输入串 } w \\text{ 的图灵机} \\}$。一个基础定理是：不存在任何算法，能够对所有配对 $\\langle M, w \\rangle$ 判定 $M$ 是否接受 $w$。换句话说，$A_{TM}$ 是一个不可判定语言。\n\n现在，考虑一个相关但看似更简单的问题。我们定义语言 $HALT_{\\epsilon} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台在空输入串 } \\epsilon \\text{ 上停机的图灵机} \\}$。一位计算机科学家推测 $HALT_{\\epsilon}$ 也是不可判定的。为了研究这一点，她试图证明，如果存在一个可以判定 $HALT_{\\epsilon}$ 的假设算法，那么就可以用它作为子程序来构建一个能判定不可能问题 $A_{TM}$ 的算法，从而导致矛盾。\n\n策略如下：为了判定给定的图灵机 $M$ 是否接受字符串 $w$（即，解决 $A_{TM}$ 的一个实例 $\\langle M, w \\rangle$），我们首先构建一个新的图灵机，称之为 $M_{construct}$。$M_{construct}$ 的行为是根据 $M$ 和 $w$ 特别设计的。然后，我们将 $M_{construct}$ 的描述输入给我们假设的 $HALT_{\\epsilon}$ 判定器。这个判定器的输出（即 $M_{construct}$ 是否在 $\\epsilon$ 上停机）应该能明确地告诉我们 $M$ 是否接受 $w$。\n\n以下哪项正确描述了机器 $M_{construct}$ 在空字符串 $\\epsilon$ 上运行时所必需的行为，从而使得该策略能成功证明 $HALT_{\\epsilon}$ 是不可判定的？\n\nA. 在输入 $\\epsilon$ 上，$M_{construct}$ 模拟 $M$ 在输入 $w$ 上的行为。如果模拟显示 $M$ 接受 $w$，$M_{construct}$ 就停机。如果模拟显示 $M$ 拒绝 $w$，$M_{construct}$ 就进入一个无限循环。\n\nB. 在输入 $\\epsilon$ 上，$M_{construct}$ 模拟 $M$ 在输入 $w$ 上的行为。如果模拟显示 $M$ 在 $w$ 上停机（无论接受或拒绝），$M_{construct}$ 就停机。否则，它进入一个无限循环。\n\nC. 在输入 $\\epsilon$ 上，$M_{construct}$ 模拟 $M$ 在空字符串 $\\epsilon$ 上的行为。如果模拟显示 $M$ 接受 $\\epsilon$，$M_{construct}$ 就停机。如果模拟显示 $M$ 拒绝 $\\epsilon$，$M_{construct}$ 就进入一个无限循环。\n\nD. 在输入 $\\epsilon$ 上，$M_{construct}$ 模拟 $M$ 在输入 $w$ 上的行为。如果模拟显示 $M$ 接受 $w$，$M_{construct}$ 就进入一个无限循环。如果模拟显示 $M$ 拒绝 $w$，$M_{construct}$ 就停机。\n\nE. 在输入 $\\epsilon$ 上，$M_{construct}$ 模拟 $M$ 在输入 $w$ 上的行为。它被设计成当且仅当 $M$ 接受 $w$ 时，才进入一个接受状态。", "solution": "我们的目标是证明，一个用于 $HALT_{\\epsilon}=\\{\\langle M\\rangle\\mid M \\text{ 在 } \\epsilon \\text{ 上停机}\\}$ 的假设判定器，可以被用来判定 $A_{TM}=\\{\\langle M,w\\rangle\\mid M \\text{ 接受 } w\\}$。这需要一个可计算的转换 $f$，它将任意配对 $\\langle M,w\\rangle$ 映射到一台机器 $\\langle M_{construct}\\rangle$，使得以下等价关系成立：\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\n如果存在这样的 $f$，那么给定一个 $HALT_{\\epsilon}$ 的判定器，我们就可以通过应用 $f$ 并在 $\\langle M_{construct}\\rangle$ 上运行该判定器来判定 $A_{TM}$。由于 $A_{TM}$ 是不可判定的，这将意味着 $HALT_{\\epsilon}$ 也是不可判定的。\n\n因此，$M_{construct}$ 必须被定义为：它在输入 $\\epsilon$ 上停机，当且仅当 $M$ 接受 $w$。一个正确的构造方法是：\n- 在输入 $\\epsilon$ 上，模拟 $M$ 在输入 $w$ 上的行为。\n- 如果模拟显示 $M$ 接受 $w$，那么就停机（例如，接受）。\n- 如果模拟显示 $M$ 拒绝 $w$，那么就永远循环。\n- 如果 $M$ 在 $w$ 上不停机，模拟就永远不会结束，因此 $M_{construct}$ 也不停机。\n\n这确保了以下精确的等价关系\n$$\n\\langle M,w\\rangle\\in A_{TM}\\iff M\\text{ 接受 }w\\iff M_{construct}\\text{ 在 } \\epsilon \\text{ 上停机}\\iff \\langle M_{construct}\\rangle\\in HALT_{\\epsilon}.\n$$\n因此，$HALT_{\\epsilon}$ 的判定器将能够通过映射 $\\langle M,w\\rangle\\mapsto \\langle M_{construct}\\rangle$ 来判定 $A_{TM}$，而这是一个矛盾。所以 $HALT_{\\epsilon}$ 是不可判定的。\n\n在这些选项中：\n- A 精确匹配了所需的构造。\n- B 使得在 $\\epsilon$ 上停机对应于 $M$ 在 $w$ 上因任何原因停机，这归约到了一般的停机问题而不是接受问题；它没有按照策略的要求去判定 $A_{TM}$。\n- C 模拟 $M$ 在 $\\epsilon$ 而不是 $w$ 上的行为，破坏了与给定实例 $\\langle M,w\\rangle$ 所需的对应关系。\n- D 使得在 $\\epsilon$ 上停机对应于 $M$ 拒绝 $w$，这并不能如所述那样判定 $A_{TM}$。\n- E 的描述是模糊的：进入接受状态意味着停机，但这并不排除当 $M$ 拒绝 $w$ 时也通过拒绝来停机的情况，因此它不能保证停机与接受之间所需的“当且仅当”条件。\n\n因此，正确的描述是 A。", "answer": "$$\\boxed{A}$$", "id": "1457092"}, {"introduction": "在构造数学证明时，逻辑的严谨性至关重要，归约证明尤其如此。归约的方向决定了证明的有效性。这个练习剖析了一个常见的逻辑错误：将一个待证问题归约到一个已知的不可解问题，并错误地得出结论。通过分析这个谬误，你将巩固对归约工作原理的理解，并明白为何正确的归约方向是分类问题难度的关键。[@problem_id:1457073]", "problem": "一位计算理论课程的学生 Alice 接到一项任务，需要证明一个特定的语言 $\\text{TOTAL\\_TM}$ 是不可判定的。该语言定义为 $\\text{TOTAL\\_TM}$ = $\\{ \\langle M \\rangle \\mid M \\text{ 是一个在所有可能的输入字符串上都会停机的图灵机 (TM)} \\}$。\n\nAlice 知道标准的停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一个在输入 } w \\text{ 上会停机的图灵机} \\}$ 是一个著名的不可判定语言。\n\n为了证明她的论点，她正确地构造了一个可计算函数 $f$，该函数将 $\\text{TOTAL\\_TM}$ 的任何实例 $\\langle M \\rangle$ 转换为 $A_{TM}$ 的一个实例 $\\langle M', w' \\rangle = f(\\langle M \\rangle)$，使得 $\\langle M \\rangle \\in \\text{TOTAL\\_TM}$ 当且仅当 $\\langle M', w' \\rangle \\in A_{TM}$。这建立了一个从 $\\text{TOTAL\\_TM}$ 到 $A_{TM}$ 的映射归约（记为 $\\text{TOTAL\\_TM} \\le_m A_{TM}$）。\n\nAlice 随后总结了她的证明：“既然我已经证明了 $\\text{TOTAL\\_TM}$ 可以归约到 $A_{TM}$，并且我们知道 $A_{TM}$ 是不可判定的，那么从逻辑上可以得出 $\\text{TOTAL\\_TM}$ 也必定是不可判定的。”\n\n下列哪个陈述最好地解释了 Alice 推理中的根本性缺陷？\n\nA. 为了通过归约证明一个语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约 *到* $P$（即，证明 $U \\le_m P$），而不是反过来。Alice 的归约方向对于她所要达成的目标是错误的。\n\nB. 语言 $\\text{TOTAL\\_TM}$ 不是图灵可识别的，而 $A_{TM}$ 是。映射归约仅在处于相同可识别性类别的语言之间有效（即，两者都是可识别的，或两者都不是）。\n\nC. Alice 的论证是循环论证。为了构造可计算函数 $f$，她必须已经隐含地假设了一种判定 $\\text{TOTAL\\_TM}$ 的方法，这与她试图证明的论点相矛盾。\n\nD. 这个归约是无效的，因为已知 $\\text{TOTAL\\_TM}$ 是一个比 $A_{TM}$ “更难”的问题。计算理论的一个基本定理是，不能将一个计算上更难的问题归约到一个更容易的问题。\n\nE. 任何从接受单个编码 $\\langle M \\rangle$ 作为输入的语言到接受一个对 $\\langle M, w \\rangle$ 作为输入的语言的归约，都存在固有缺陷，因为它需要制造原始输入中不存在的信息（字符串 $w$）。", "solution": "给定语言 $\\text{TOTAL\\_TM} = \\{ \\langle M \\rangle \\mid M \\text{ 在所有输入上停机} \\}$ 和停机问题 $A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 在输入 } w \\text{ 上停机} \\}$，其中已知 $A_{TM}$ 是不可判定的。Alice 展示了一个映射归约 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$ 并得出结论 $\\text{TOTAL\\_TM}$ 是不可判定的。\n\n回顾定义：对于语言 $A$ 和 $B$，$A \\le_{m} B$ 意味着存在一个全可计算函数 $f$，使得对于所有字符串 $x$，\n$$x \\in A \\iff f(x) \\in B.$$\n\n映射归约的关键性质：\n- 如果 $A \\le_{m} B$ 且 $B$ 是可判定的，那么 $A$ 也是可判定的。证明：给定一个用于 $B$ 的判定器，通过计算 $f(x)$ 并运行用于 $B$ 的判定器来判定输入 $x$ 上的 $A$；当且仅当 $B$ 的判定器接受时接受。\n- 这个陈述的逆否命题是：如果 $A$ 是不可判定的且 $A \\le_{m} B$，那么 $B$ 也是不可判定的。\n\n因此，要通过归约证明目标语言 $P$ 是不可判定的，必须将一个已知的不可判定语言 $U$ 归约到 $P$，即证明 $U \\le_{m} P$。这样，如果 $P$ 是可判定的，那么 $U$ 也将是可判定的，这与 $U$ 的已知不可判定性相矛盾。\n\n然而，Alice 证明的是 $\\text{TOTAL\\_TM} \\le_{m} A_{TM}$。根据上述基本性质，这个蕴含关系只能得出：\n$$\\text{如果 } A_{TM} \\text{ 是可判定的，那么 } \\text{TOTAL\\_TM} \\text{ 将是可判定的。}$$\n但由于 $A_{TM}$ 是不可判定的，这个条件句没有告诉我们任何关于 $\\text{TOTAL\\_TM}$ 可判定性的信息。因此，Alice 的结论不成立。\n\n一个具体的例子说明这种归约方向不能证明不可判定性：设 $L$ 是任何可判定的语言。设 $D$ 是它的判定器。定义一个可计算函数 $f$，它在输入 $x$ 上运行 $D(x)$，如果 $D$ 接受，则输出一个固定的对 $\\langle M_{halt}, w_{halt} \\rangle \\in A_{TM}$；如果 $D$ 拒绝，则输出一个固定的对 $\\langle M_{loop}, w_{loop} \\rangle \\notin A_{TM}$。那么 $x \\in L \\iff f(x) \\in A_{TM}$，因此 $L \\le_{m} A_{TM}$，但 $L$ 是可判定的。因此，证明 $P \\le_{m} A_{TM}$ 并不能确定 $P$ 是不可判定的。\n\n因此，根本性的缺陷在于归约的方向。这对应于选项 A。其他选项是错误的，因为：映射归约不要求具有相同的可识别性状态（B 是错误的），构造 $f$ 并不假设存在 $\\text{TOTAL\\_TM}$ 的判定器（C 是错误的），“从更难到更容易”的措辞并非正式的标准（D 具有误导性），以及通过可计算的填充或硬编码从单个输入生成对是标准做法（E 是错误的）。", "answer": "$$\\boxed{A}$$", "id": "1457073"}]}