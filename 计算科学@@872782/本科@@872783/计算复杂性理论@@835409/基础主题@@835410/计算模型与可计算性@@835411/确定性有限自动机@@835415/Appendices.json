{"hands_on_practices": [{"introduction": "理论知识是基础，但真正的理解来自于实践。本节的第一个练习将引导你设计一个确定性有限自动机（DFA），其任务是识别包含偶数个'a'和奇数个'b'的字符串。这个问题的核心在于理解DFA的状态如何作为一种“记忆”形式，你需要确定机器在处理输入时必须跟踪哪些关键信息，并为每种信息组合定义一个独立的状态。通过这个练习[@problem_id:1421354]，你将掌握将语言属性系统地映射到DFA状态的基本技能。", "problem": "考虑字母表 $\\Sigma = \\{a, b\\}$。令 $L$ 为由字母表 $\\Sigma$ 上所有包含偶数个 'a' 和奇数个 'b' 的字符串组成的语言。确定性有限自动机 (DFA) 是一种有限状态机，它通过一系列状态来处理字符串，从而接受或拒绝它们。识别语言 $L$ 的 DFA 最少需要多少个状态？\n\nA. 2\n\nB. 3\n\nC. 4\n\nD. 5\n\nE. 6", "solution": "为了解决这个问题，我们需要确定一个确定性有限自动机 (DFA) 在逐个字符处理字符串以判断其是否属于语言 $L$ 时，必须记住的关键信息。一个字符串的接受条件取决于两个独立的属性：'a' 数量的奇偶性和 'b' 数量的奇偶性。\n\n我们来分析一下自动机需要跟踪的属性：\n1.  到目前为止，机器是否已经看到了偶数个或奇数个 'a'？\n2.  到目前为止，机器是否已经看到了偶数个或奇数个 'b'？\n\nDFA 中的一个状态必须编码这两个问题的答案。我们可以用一个有序对 $(P_a, P_b)$ 来表示机器的状态，其中 $P_a$ 是已见 'a' 数量的奇偶性，$P_b$ 是已见 'b' 数量的奇偶性。每种奇偶性可以是'偶数'或'奇数'。\n\n这就给出了四种可能的奇偶性组合，这对应了所需的最小状态数：\n1.  状态 $q_0$：（偶数个 'a'，偶数个 'b'）\n2.  状态 $q_1$：（偶数个 'a'，奇数个 'b'）\n3.  状态 $q_2$：（奇数个 'a'，偶数个 'b'）\n4.  状态 $q_3$：（奇数个 'a'，奇数个 'b'）\n\n让我们更正式地定义状态和转移：\n状态集合为 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n字母表为 $\\Sigma = \\{a, b\\}$。\n\n起始状态必须对应于空字符串的属性。空字符串有零个 'a' 和零个 'b'。由于零是偶数，所以初始状态表示偶数个 'a' 和偶数个 'b'。因此，起始状态是 $q_0$。\n\n接受状态必须符合语言 $L$ 的定义，即要求偶数个 'a' 和奇数个 'b'。因此，唯一的接受状态是 $q_1$。\n\n现在，我们来考虑这些状态之间的转移：\n- 从状态 $q_0$（偶数个 'a'，偶数个 'b'）出发：\n  - 读入 'a' 时，'a' 的数量奇偶性变为奇数，而 'b' 的数量奇偶性保持偶数。自动机转移到状态 $q_2$（奇数个 'a'，偶数个 'b'）。\n  - 读入 'b' 时，'b' 的数量奇偶性变为奇数，而 'a' 的数量奇偶性保持偶数。自动机转移到状态 $q_1$（偶数个 'a'，奇数个 'b'）。\n\n- 从状态 $q_1$（偶数个 'a'，奇数个 'b'）出发：\n  - 读入 'a' 时，'a' 的数量奇偶性变为奇数。自动机转移到状态 $q_3$（奇数个 'a'，奇数个 'b'）。\n  - 读入 'b' 时，'b' 的数量奇偶性变回偶数。自动机转移到状态 $q_0$（偶数个 'a'，偶数个 'b'）。\n\n- 从状态 $q_2$（奇数个 'a'，偶数个 'b'）出发：\n  - 读入 'a' 时，'a' 的数量奇偶性变回偶数。自动机转移到状态 $q_0$（偶数个 'a'，偶数个 'b'）。\n  - 读入 'b' 时，'b' 的数量奇偶性变为奇数。自动机转移到状态 $q_3$（奇数个 'a'，奇数个 'b'）。\n\n- 从状态 $q_3$（奇数个 'a'，奇数个 'b'）出发：\n  - 读入 'a' 时，'a' 的数量奇偶性变回偶数。自动机转移到状态 $q_1$（偶数个 'a'，奇数个 'b'）。\n  - 读入 'b' 时，'b' 的数量奇偶性变回偶数。自动机转移到状态 $q_2$（奇数个 'a'，偶数个 'b'）。\n\n所有四个状态都可以从起始状态 $q_0$ 到达。例如：\n- $q_0$ 是起始状态。\n- 读入 'b' 可以到达 $q_1$。\n- 读入 'a' 可以到达 $q_2$。\n- 读入 'ab' 可以到达 $q_3$。\n\n此外，所有四个状态都是可区分的。例如，从状态 $q_0$ 出发，字符串 'b' 会导向一个接受状态 ($q_1$)，但从状态 $q_2$ 出发，字符串 'b' 会导向一个非接受状态 ($q_3$)。这意味着 $q_0$ 和 $q_2$ 必须是不同的状态。对于所有状态对，都可以进行类似的论证。由于所有四个状态都是区分不同奇偶性组合所必需的，因此最小 DFA 必须正好有 4 个状态。", "answer": "$$\\boxed{C}$$", "id": "1421354"}, {"introduction": "一个DFA的结构不仅定义了它接受哪些字符串，还揭示了其语言的深层性质。在这个练习中，你将分析一个给定的DFA，并判断它所接受的语言是有限的还是无限的。这个任务要求你检查DFA的状态转换图，特别是寻找从起始状态可达并能到达接受状态的循环，这是判断语言无限性的关键[@problem_id:1362810]。这项实践将帮助你建立起自动机的图结构与其所识别语言的全局属性之间的直观联系。", "problem": "一个网络工程师团队正在为一个控制系统设计一个简单的验证协议。该协议接受由字母表 $\\Sigma = \\{0, 1\\}$ 表示的二进制信号序列。序列的有效性由一个确定性有限自动机（DFA）来检查。一个序列被认为是有效的，当且仅当DFA在处理完整个序列后停在一个接受状态。\n\n该DFA记为 $M$，由5元组 $(Q, \\Sigma, \\delta, q_0, F)$ 正式定义，其中：\n- 状态集合为 $Q = \\{S_0, S_1, S_2, S_3, S_4, S_5\\}$。\n- 输入字母表为 $\\Sigma = \\{0, 1\\}$。\n- 初始状态为 $q_0 = S_0$。\n- 接受状态集合为 $F = \\{S_4\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to Q$ 由下表给出：\n\n| 当前状态 | 输入 '0' | 输入 '1' |\n| :-----------: | :-------: | :-------: |\n|    $S_0$      |   $S_1$   |   $S_2$   |\n|    $S_1$      |   $S_0$   |   $S_3$   |\n|    $S_2$      |   $S_5$   |   $S_4$   |\n|    $S_3$      |   $S_3$   |   $S_4$   |\n|    $S_4$      |   $S_5$   |   $S_5$   |\n|    $S_5$      |   $S_5$   |   $S_5$   |\n\n设 $L(M)$ 是此DFA接受的所有有效信号序列的语言。你的任务是确定这个语言的性质。下列哪个陈述是正确的？\n\nA. 语言 $L(M)$ 是有限的。\n\nB. 语言 $L(M)$ 是无限的。\n\nC. 语言 $L(M)$ 是空的（不包含任何字符串）。\n\nD. 语言 $L(M)$ 是有限的还是无限的是不可判定的。", "solution": "我们分析给定的DFA $M=(Q,\\Sigma,\\delta,q_{0},F)$ 的接受情况，其中 $Q=\\{S_{0},S_{1},S_{2},S_{3},S_{4},S_{5}\\}$，$\\Sigma=\\{0,1\\}$，$q_{0}=S_{0}$，$F=\\{S_{4}\\}$，且转移函数如题目所述。如果运行在 $S_4$ 结束，则字符串被接受。从表中可以看出，一旦自动机进入 $S_4$ 状态，任何后续输入都会导致其进入 $S_5$ 状态，而 $S_5$ 是一个非接受的陷阱状态：$\\delta(S_{4},0)=S_{5}$，$\\delta(S_{4},1)=S_{5}$，以及 $\\delta(S_{5},0)=\\delta(S_{5},1)=S_{5}$。因此，任何被接受的字符串都必须在首次到达 $S_4$ 时恰好结束；如果字符串要被接受，那么在进入 $S_4$ 之后不能再有任何符号。\n\n要确定 $L(M)$ 是有限的还是无限的，我们只需检查是否存在一个从初始状态可达且不包含 $S_4$ 的环，并且从这个环可以到达 $S_4$。如果存在这样的环，我们就可以沿着这个环“泵送”（重复）任意次，然后通过一个最终的转移到达 $S_4$，从而产生无限多个被接受的字符串。\n\n从转移表中可知，$S_3$ 是从初始状态可达的：\n$$S_{0}\\xrightarrow{0}S_{1}\\xrightarrow{1}S_{3}.$$\n在 $S_3$ 状态，输入为0时有一个自环：\n$$\\delta(S_{3},0)=S_{3},$$\n并且从 $S_3$ 状态，输入1会使其转移到接受状态 $S_4$：\n$$\\delta(S_{3},1)=S_{4}.$$\n因此，对于每个整数 $k\\geq 0$，字符串\n$$w_{k}=010^{k}1$$\n都会被接受，因为其运行路径为\n$$S_{0}\\xrightarrow{0}S_{1}\\xrightarrow{1}S_{3}\\xrightarrow{0^{k}}S_{3}\\xrightarrow{1}S_{4}.$$\n对于不同的 $k$，这些字符串都是不同的，所以存在无限多个被接受的字符串。因此 $L(M)$ 是无限的。它既非空也非有限，并且由于该DFA是完全指定的，该问题是可判定的；因此选项D是错误的。\n\n因此，正确选项是B。", "answer": "$$\\boxed{B}$$", "id": "1362810"}, {"introduction": "在更复杂的应用中，我们不仅需要设计DFA，还需要比较它们或其部分的行为，例如在进行DFA最小化或等价性测试时。状态的可区分性是这些高级操作的核心概念。这个练习[@problem_id:1421340]模拟了一个诊断场景，你需要找到一个能区分两个特定DFA状态的最短（按字典序）输入序列。通过解决这个问题，你将实践一种系统的、算法化的方法来寻找区分字符串，这在调试和优化状态机时是一项非常实用的技能。", "problem": "一个简化版机械臂的控制系统被建模为一个确定性有限自动机（DFA），记作 $M$。DFA 的状态表示机械臂的当前配置，输入串对应于命令序列。某些配置被指定为‘操作任务完成’状态。\n\nDFA $M$ 由五元组 $(Q, \\Sigma, \\delta, S_0, F)$ 正式定义，其中：\n- 状态集为 $Q = \\{S_0, S_1, S_2, S_3, S_4, S_5\\}$。\n- 输入字母表为 $\\Sigma = \\{0, 1\\}$。\n- 起始状态为 $S_0$。\n- ‘操作任务完成’（接受）状态集为 $F = \\{S_5\\}$。\n- 转移函数 $\\delta: Q \\times \\Sigma \\to Q$ 由以下规则定义：\n  - $\\delta(S_0, 0) = S_1$\n  - $\\delta(S_0, 1) = S_5$\n  - $\\delta(S_1, 0) = S_3$\n  - $\\delta(S_1, 1) = S_0$\n  - $\\delta(S_2, 0) = S_4$\n  - $\\delta(S_2, 1) = S_0$\n  - $\\delta(S_3, 0) = S_1$\n  - $\\delta(S_3, 1) = S_0$\n  - $\\delta(S_4, 0) = S_2$\n  - $\\delta(S_4, 1) = S_2$\n  - $\\delta(S_5, 0) = S_5$\n  - $\\delta(S_5, 1) = S_5$\n\n如果存在一个输入串 $w \\in \\Sigma^*$，在处理 $w$ 后，其中一个结果状态在 $F$ 中而另一个不在，那么两个状态 $p, q \\in Q$ 就被认为是可区分的。形式上，$(\\delta^*(p, w) \\in F \\text{ 且 } \\delta^*(q, w) \\notin F)$ 或 $(\\delta^*(p, w) \\notin F \\text{ 且 } \\delta^*(q, w) \\in F)$，其中 $\\delta^*$ 是扩展转移函数。\n\n假设一个软件错误导致控制器进入了两个特定的非接受状态 $S_1$ 或 $S_2$ 之一，但未知具体是哪一个。为了诊断问题，您必须找到一个能够区分它们俩的输入序列。\n\n确定能够区分状态 $S_1$ 和 $S_2$ 的字典序最小的二进制串 $w$。二进制串按字典序排序，即短串在前，长度相同的串按字母顺序排序（例如，'01' 在 '10' 之前）。", "solution": "我们必须找到字典序最小的 $w \\in \\{0,1\\}^{*}$，使得 $\\delta^{*}(S_{1},w)$ 和 $\\delta^{*}(S_{2},w)$ 中恰好有一个属于 $F=\\{S_{5}\\}$。\n\n首先，考虑 $w=\\varepsilon$。那么 $\\delta^{*}(S_{1},\\varepsilon)=S_{1}\\notin F$ 且 $\\delta^{*}(S_{2},\\varepsilon)=S_{2}\\notin F$，所以 $\\varepsilon$ 无法区分。\n\n接下来，考虑所有长度为1的串：\n- 对于 $w=0$：$\\delta^{*}(S_{1},0)=S_{3}\\notin F$，$\\delta^{*}(S_{2},0)=S_{4}\\notin F$。\n- 对于 $w=1$：$\\delta^{*}(S_{1},1)=S_{0}\\notin F$，$\\delta^{*}(S_{2},1)=S_{0}\\notin F$。\n没有长度为1的串可以区分。\n\n现在，按字典序考虑所有长度为2的串：\n- 对于 $w=00$：从 $S_{1}$ 出发，$0\\to S_{3}$，然后 $0\\to S_{1}$；从 $S_{2}$ 出发，$0\\to S_{4}$，然后 $0\\to S_{2}$。最终状态都不在 $F$ 中。\n- 对于 $w=01$：从 $S_{1}$ 出发，$0\\to S_{3}$，然后 $1\\to S_{0}$；从 $S_{2}$ 出发，$0\\to S_{4}$，然后 $1\\to S_{2}$。最终状态都不在 $F$ 中。\n- 对于 $w=10$：从 $S_{1}$ 或 $S_{2}$ 出发，$1\\to S_{0}$，然后 $0\\to S_{1}$；不在 $F$ 中。\n- 对于 $w=11$：从 $S_{1}$ 或 $S_{2}$ 出发，$1\\to S_{0}$，然后 $1\\to S_{5}\\in F$。两者都被接受。\n没有长度为2的串可以区分。\n\n继续检查长度为3的串，按字典序：\n- 对于 $w=000$：从 $S_{1}$ 出发，$0\\to S_{3}$，$0\\to S_{1}$，$0\\to S_{3}$；从 $S_{2}$ 出发，$0\\to S_{4}$，$0\\to S_{2}$，$0\\to S_{4}$。两者都不在 $F$ 中。\n- 对于 $w=001$：从 $S_{1}$ 出发，$0\\to S_{3}$，$0\\to S_{1}$，$1\\to S_{0}$；从 $S_{2}$ 出发，$0\\to S_{4}$，$0\\to S_{2}$，$1\\to S_{0}$。两者都不在 $F$ 中。\n- 对于 $w=010$：从 $S_{1}$ 出发，$0\\to S_{3}$，$1\\to S_{0}$，$0\\to S_{1}$；从 $S_{2}$ 出发，$0\\to S_{4}$，$1\\to S_{2}$，$0\\to S_{4}$。两者都不在 $F$ 中。\n- 对于 $w=011$：明确计算两条路径。\n  从 $S_{1}$ 出发：$\\delta(S_{1},0)=S_{3}$，然后 $\\delta(S_{3},1)=S_{0}$，然后 $\\delta(S_{0},1)=S_{5}\\in F$。\n  从 $S_{2}$ 出发：$\\delta(S_{2},0)=S_{4}$，然后 $\\delta(S_{4},1)=S_{2}$，然后 $\\delta(S_{2},1)=S_{0}\\notin F$。\n因此 $\\delta^{*}(S_{1},011)\\in F$ 且 $\\delta^{*}(S_{2},011)\\notin F$，所以 $w=011$ 可以区分。\n\n由于没有长度小于3的串可以区分，并且在长度为3的串中 $011$ 是字典序中第一个可以区分的，所以字典序最小的区分串是 $011$。", "answer": "$$\\boxed{011}$$", "id": "1421340"}]}