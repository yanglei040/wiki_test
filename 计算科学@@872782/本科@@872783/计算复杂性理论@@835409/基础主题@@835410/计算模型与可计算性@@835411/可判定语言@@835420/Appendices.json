{"hands_on_practices": [{"introduction": "为了真正理解“可判定”的含义，我们首先需要掌握图灵机如何通过具体的算法步骤来解决一个问题。这个练习将抽象的图灵机模型应用于我们所熟悉的二进制加法任务，让你亲身体验如何将一个算法分解为磁带操作和状态转换。通过设计一个判定简单算术语言的图灵机，你将为理解更复杂的计算问题奠定坚实的基础 [@problem_id:1419574]。", "problem": "考虑字母表 $\\Sigma = \\{0, 1, +, =\\}$ 上的语言 $L$。该语言由所有表示有效二进制加法的字符串组成。一个字符串 $w$ 属于 $L$ 当且仅当它的形式为 $x+y=z$，其中 $x, y, z$ 是由 $\\{0, 1\\}$ 中的字符组成的非空字符串，并且二进制字符串 $x$ 的数值加上二进制字符串 $y$ 的数值等于二进制字符串 $z$ 的数值。例如，字符串 \"101+10=111\" 属于 $L$，因为二进制数 101（十进制 5）加上二进制数 10（十进制 2）等于二进制数 111（十进制 7）。字符串 \"1+1=10\" 也属于 $L$。然而，字符串 \"11+1=101\" 不属于 $L$。\n\n需要设计一台确定性的单带图灵机（TM）来判定这个语言 $L$。我们关心的是，在图灵机执行初始扫描以验证输入字符串恰好包含一个 '+' 符号和一个 '=' 符号，并且 '+' 出现在 '=' 之前，其核心计算逻辑。\n\n从已验证的格式开始，以下哪个高层描述概述了图灵机完成判定过程的正确程序？\n\nA. 图灵机找到操作数串 $x$ 和 $y$。它在较短的操作数前面填充前导零，直到其长度与较长的操作数相同。然后，它从右到左逐位移动，对填充后的 $x$ 和 $y$ 的相应位执行按位异或（XOR）操作。然后将结果字符串与字符串 $z$ 逐位比较。当且仅当异或操作的结果与 $z$ 完全相同时，图灵机接受。\n\nB. 图灵机将 '+' 和 '=' 符号替换为空白符号。然后它重复扫描整个带子。在每次扫描中，它找到对应于 $x$ 的字符串中最右边的 '1' 和对应于 $y$ 的字符串中最右边的 '1'，将两者都改为 '0'，并找到对应于 $z$ 的字符串中最左边的 '0' 并将其改为 '1'。如果这个过程结束后（$x$ 或 $y$ 中不再有 '1'），字符串 $z$ 全由 '1' 组成，则图灵机接受。\n\nC. 图灵机从右到左工作。它标记 $z$ 的最右边的数字，然后是 $y$ 的最右边的数字，然后是 $x$ 的最右边的数字。如果来自 $x$ 和 $y$ 的数字之和与来自 $z$ 的数字不匹配，它就拒绝（例如，如果 $x$ 有一个 '1'，$y$ 有一个 '0'，而 $z$ 有一个 '0'）。它不使用其内部状态来处理进位。如果和为 2（来自 '1'+'1'），它只是检查 $z$ 中相应的数字是否为 '0'。它继续这个过程，一次向左移动一个数字，直到所有数字都被标记。如果所有检查都通过，它就接受。\n\nD. 图灵机使用其有限控制器（内部状态）来记忆一个进位位，初始设置为 0。它从右到左处理这三个数。在每一步中，它读取 $x$ 和 $y$ 的最右边未标记的数字（将较短数字的末端视为 0）并将它们与进位相加。它验证和模 2 的结果与 $z$ 的相应数字匹配。如果不匹配，图灵机拒绝。然后它将进位位更新为和除以 2 的整数部分。为了避免重复处理数字，它会标记每个处理过的数字（例如，将 '0' 替换为 $0_m$，将 '1' 替换为 $1_m$）。在处理完 $x$ 和 $y$ 的所有数字后，它会验证 $z$ 的任何剩余数字是否与最终的进位值一致。如果所有检查都通过，图灵机接受。", "solution": "我们假设输入已被验证为恰好包含一个 '+' 符号和一个 '=' 符号，且 '+' 在 '=' 的左边，并且 $x$、$y$、$z$ 是三个非空的二进制子串。判定 $L$ 的正确性归结为检查带进位的标准二进制加法：对于从右到左的每个位位置 $i$，如果 $a_{i}$ 是 $x$ 的第 $i$ 位（如果 $i$ 超过长度则为 $0$），$b_{i}$ 是 $y$ 的第 $i$ 位（或为 $0$），$k$ 是该步骤的输入进位，那么期望的输出位是\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2},\n$$\n而输出进位是\n$$\nk' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor.\n$$\n一个正确的图灵机必须在从右到左移动的同时精确地实现这个逻辑，并防止重复处理数字（例如，通过标记已处理的符号）。\n\n我们现在分析每个选项：\n\nA. 这提议用前导零填充较短的操作数，并计算填充后的 $x$ 和 $y$ 的按位异或，然后与 $z$ 比较。按位异或对应于在每个位置计算 $(a_{i} + b_{i}) \\bmod 2$，但从不传播进位。因此，它没有实现 $k' = \\left\\lfloor (a_{i} + b_{i} + k)/2 \\right\\rfloor$。一个简单的反例是 $x=1, y=1, z=10$。$1$ 和 $1$ 的异或结果是 $0$，这与 $z=10$ 不匹配，所以这个过程会拒绝一个有效的字符串。因此A是错误的。\n\nB. 这个过程重复地将 $x$ 中最右边的 '1' 与 $y$ 中最右边的 '1' 配对，并将 $z$ 中最左边的 '0' 翻转为 '1'，如果最后 $z$ 全变为 '1' 则接受。这个过程忽略了位置权重 $2^{i}$，只操作计数和极端位置，因此它不对应于带进位的二进制加法。例如，考虑 $x=1, y=0, z=1$，这是有效的。由于 $y$ 中没有 '1'，没有最右边的 '1' 对可以处理；算法无法继续消除 $x$ 中的 '1'，也无法达到一个正确的接受配置。因此它未能接受一个有效的输入，并且不能判定 $L$。因此B是错误的。\n\nC. 这个过程在每个位置检查两个操作数位之和与 $z$ 的位是否相符，但明确不使用任何进位。使用上面的方程，这错误地在所有位置强制执行 $s_{i} \\equiv a_{i} + b_{i} \\pmod{2}$，且 $k \\equiv 0$。对于 $x=1, y=1, z=10$，在最低有效位，我们有 $a_{0}+b_{0}=2$，$z_{0}=0$，所以它通过了那个位置，但在下一个位置，它实际上是检查 $0+0$ 与 $z_{1}=1$ 是否相符，并拒绝。因此C错误地拒绝了一个有效的输入。因此C是错误的。\n\nD. 这与带进位的标准二进制加法算法相匹配。图灵机在其有限控制器中使用一个进位位 $k \\in \\{0,1\\}$，初始为 $0$。在每一步中，它：\n- 定位 $x$ 和 $y$ 的最右边未标记的数字（将左端以外的位置视为 $0$），以及 $z$ 的相应最右边未标记的数字。\n- 计算 $t = a_{i} + b_{i} + k$，检查 $z_{i} \\equiv t \\bmod 2$ 是否成立。如果不成立，则拒绝。\n- 将进位更新为 $k' = \\left\\lfloor t/2 \\right\\rfloor$。\n- 标记已处理的数字（例如，用 $0_{m}$ 替换 $0$，用 $1_{m}$ 替换 $1$）以避免重复处理，并向左移动一个位置重复操作。\n\n在 $x$ 和 $y$ 的所有数字都被标记后，它验证 $z$ 的剩余数字是否与最终的进位值一致：如果 $k=1$，它要求剩下的 $z$ 中恰好有一个数字等于 $1$，其后只有 $0$（或者如果之前已经匹配，则没有更多数字）；如果 $k=0$，它要求所有剩下的 $z$ 数字都为 $0$。这正是\n$$\ns_{i} \\equiv a_{i} + b_{i} + k \\pmod{2}, \\quad k' = \\left\\lfloor \\frac{a_{i} + b_{i} + k}{2} \\right\\rfloor,\n$$\n的语义，从右到左实现，并通过标记来确保终止性和正确性。因此 D 概述了一个判定 $L$ 的正确决策过程。\n\n结论：在初始格式检查之后，只有D为判定 $L$ 的图灵机提供了正确的高层描述。", "answer": "$$\\boxed{D}$$", "id": "1419574"}, {"introduction": "并非所有语言都能被有限自动机或下推自动机这样的简单模型所识别。这个练习引入了一个需要图灵机全部计算能力的语言，即 $L = \\{A^i B^j C^{i \\times j} \\mid i \\ge 1, j \\ge 1\\}$。通过分析为何该语言超越了上下文无关语言的范畴，并构思一个图灵机如何判定它，你将对乔姆斯基谱系有更深刻的认识，并锻炼为图灵机设计高层算法以证明语言可判定性的能力 [@problem_id:1419581]。", "problem": "一个生物工程团队正在研究模拟脱氧核糖核酸（DNA）某些特性的合成聚合物。这些聚合物是由包含三种不同单体（A型、B型和C型）的字母表构成的字符串。一个聚合物被称为“结构稳定”的，当且仅当它遵循一个严格的构成规则。该规则要求聚合物必须由一个或多个A型单体的连续块构成，其后紧跟着一个或多个B型单体的连续块，然后又紧跟着一个或多个C型单体的连续块。此外，稳定性的一个关键条件是，C型单体的数量必须恰好等于A型单体数量与B型单体数量的乘积。\n\n设 $L$ 是字母表 $\\Sigma = \\{A, B, C\\}$ 上代表所有结构稳定聚合物的字符串所构成的语言。该语言可以形式化地表示为 $L = \\{ A^i B^j C^k \\mid i \\ge 1, j \\ge 1, \\text{ and } k = i \\times j \\}$。\n\n根据乔姆斯基层级（Chomsky hierarchy）和计算理论，对于语言 $L$ 最精确的分类是什么？\n\nA. $L$ 是一个正则语言。\n\nB. $L$ 是一个上下文无关语言，但不是正则语言。\n\nC. $L$ 是一个可判定语言（也称为递归语言），但不是上下文无关语言。\n\nD. $L$ 是一个图灵可识别语言（也称为递归可枚举语言），但不是可判定语言。\n\nE. $L$ 不是一个图灵可识别语言。", "solution": "我们分析字母表 $\\Sigma = \\{A,B,C\\}$ 上的形式语言 $L = \\{ A^{i} B^{j} C^{k} \\mid i \\ge 1, j \\ge 1, k = i j \\}$。\n\n首先，$L$ 不是正则的。我们用反证法：假设 $L$ 是正则的。考虑正则语言 $R_{1} = A^{+} B C^{+}$，该语言强制字符串中只有一个 $B$。那么\n$$\nL \\cap R_{1} = \\{ A^{i} B C^{i} \\mid i \\ge 1 \\}.\n$$\n定义同态 $h$ 为 $h(A) = a$, $h(B) = \\epsilon$ 以及 $h(C) = c$。根据正则语言在与正则语言求交和同态映射下的封闭性，如果 $L$ 是正则的，那么 $h(L \\cap R_{1})$ 也将是正则的。但是\n$$\nh(L \\cap R_{1}) = \\{ a^{i} c^{i} \\mid i \\ge 1 \\},\n$$\n根据正则语言的泵引理，这个语言不是正则的。这个矛盾表明 $L$ 不是正则的。\n\n其次，$L$ 不是上下文无关的。令 $\\Psi(L) \\subseteq \\mathbb{N}^{3}$ 表示 $L$ 的帕里赫图像（Parikh image），即\n$$\n\\Psi(L) = \\{ (i,j,k) \\in \\mathbb{N}^{3} \\mid i \\ge 1, j \\ge 1, k = i j \\}.\n$$\n根据帕里赫定理（Parikh’s theorem），任何上下文无关语言的帕里赫图像都是半线性的。我们用反证法：假设 $L$ 是上下文无关的，那么 $\\Psi(L)$ 将是半线性的。我们将 $\\Psi(L)$ 与线性集\n$$\nM = \\{ (n,n,k) \\mid n \\in \\mathbb{N}, k \\in \\mathbb{N} \\},\n$$\n相交。由于半线性集在交集运算下是封闭的，我们得到的结果也必须是半线性的。我们得到\n$$\n\\Psi(L) \\cap M = \\{ (n,n,k) \\mid k = n^{2}, n \\ge 1 \\}.\n$$\n将其投影到第三个坐标上（这是一个线性映射，半线性集在此类映射下是封闭的），得到完全平方数集合\n$$\n\\{ n^{2} \\mid n \\ge 1 \\}.\n$$\n然而，$\\mathbb{N}$ 的半线性子集恰好是有限个算术级数的并集，而平方数集合不是有限个算术级数的并集（因为连续平方数之间的间隔无限增大）。这个矛盾表明 $L$ 不是上下文无关的。\n\n第三，$L$ 是可判定的（递归的）。一个确定性图灵机可以通过以下步骤来判定 $L$：\n1) 验证输入的形式是否为 $A^{+} B^{+} C^{+}$。\n2) 设 $i$ 为 $A$ 符号的数量，$j$ 为 $B$ 符号的数量。对于 $j$ 个 $B$ 中的每一个，从 $C$ 块中划掉恰好 $i$ 个符号（模拟重复加法来检查 $k = i j$）。当且仅当处理完所有 $B$ 符号后，所有的 $C$ 符号不多不少正好被划掉时，接受该字符串。该过程对所有输入都会停机，因此 $L$ 是可判定的。\n\n综上所述，$L$ 是可判定的，但既不是上下文无关的，也不是正则的。在所提供的选项中，最精确的分类是 $L$ 是一个可判定语言（递归的），但不是上下文无关的。", "answer": "$$\\boxed{C}$$", "id": "1419581"}, {"introduction": "在可计算性理论中，一个核心技巧是利用已有的判定器来构建新的判定器，这表明可判定性是一个可以在相关问题之间传递的稳健性质。本题挑战你基于一个已知语言 $L$ 的判定器，为新语言 $L_{HALF}$ 设计一个判定算法。更进一步，通过分析新算法的时间复杂度，你将直观地看到可判定性与计算效率之间的关系，这是连接“什么问题可计算”与“什么问题可高效计算”的关键桥梁 [@problem_id:1419573]。", "problem": "设 $\\Sigma = \\{0, 1\\}$ 为二进制字母表。一个语言 $L \\subseteq \\Sigma^*$ 已知是可判定的，其判定器是一台称为 $M_L$ 的图灵机（TM）。对于任何长度为 $n$（其中 $n \\ge 2$）的输入字符串，$M_L$ 的最坏情况时间复杂度（即，它停机所需的最大步数）由函数 $T_L(n) = K n \\log_2(n)$ 给出，其中 $K$ 是一个正常数，$\\log_2$ 表示以 2 为底的对数。\n\n我们从 $L$ 派生出一个新语言 $L_{HALF}$：\n$L_{HALF} = \\{w \\in \\Sigma^* \\mid \\text{存在字符串 } y \\in \\Sigma^* \\text{ 使得 } |y| = |w| \\text{ 且 } wy \\in L\\}$\n其中 $wy$ 是字符串 $w$ 和 $y$ 的拼接。\n\n为 $L_{HALF}$ 构建一个名为 $M_{HALF}$ 的判定器，其操作如下。对于任何给定的长度为 $m \\ge 1$ 的输入字符串 $w$，$M_{HALF}$ 会枚举字母表 $\\Sigma$ 上所有长度为 $m$ 的可能字符串 $y$。对于每一个这样的 $y$，它会构造字符串 $wy$，并以 $wy$ 为输入，将图灵机 $M_L$ 作为子程序运行。如果 $M_L$ 对任何一个 $y$ 接受了 $wy$，那么 $M_{HALF}$ 会立即停机并接受 $w$。如果所有可能的字符串 $y$ 都已尝试过，且 $M_L$ 拒绝了所有的 $wy$，那么 $M_{HALF}$ 会停机并拒绝 $w$。\n\n根据 $M_{HALF}$ 的构造和 $M_L$ 的时间复杂度，确定 $M_{HALF}$ 的时间复杂度关于其输入长度 $m$ 的最紧大O上界。\n\nA. $O(m \\log_2 m)$\n\nB. $O(m 2^m)$\n\nC. $O(\\log_2 m \\cdot 2^m)$\n\nD. $O(m \\log_2 m \\cdot 2^m)$\n\nE. $O(m (\\log_2 m)^2 \\cdot 2^m)$\n\nF. $O((m \\log_2 m)^2)$", "solution": "设 $M_{HALF}$ 的输入为 $w$，其长度为 $|w|=m\\ge 1$。根据构造，$M_{HALF}$ 枚举所有 $|y|=m$ 的 $2^{m}$ 个字符串 $y$，并在拼接字符串 $wy$ 上运行 $M_{L}$。$wy$ 的长度为\n$$\nn=|wy|=|w|+|y|=2m.\n$$\n$M_{L}$ 在长度为 $n$ 的输入上的最坏情况运行时间是\n$$\nT_{L}(n)=K\\,n\\log_{2}(n).\n$$\n代入 $n=2m$ 可得\n$$\nT_{L}(2m)=K\\,(2m)\\log_{2}(2m)=2K\\,m\\left(\\log_{2}(m)+1\\right),\n$$\n这里使用了 $\\log_{2}(2m)=\\log_{2}(m)+\\log_{2}(2)=\\log_{2}(m)+1$。\n\n因此，对于每个 $y$，调用 $M_{L}$ 的时间成本为 $O\\!\\left(m\\log_{2}m\\right)$。在最坏情况下，$M_{HALF}$ 会测试所有 $2^{m}$ 个字符串 $y$，因此在调用 $M_{L}$ 上花费的总时间是\n$$\n2^{m}\\cdot T_{L}(2m)=2^{m}\\cdot 2K\\,m\\left(\\log_{2}(m)+1\\right)=O\\!\\left(m\\log_{2}m\\cdot 2^{m}\\right).\n$$\n枚举每个 $y$ 并构造 $wy$ 的额外开销对于每个 $y$ 最多是 $m$ 的线性时间，总共贡献了最多 $O\\!\\left(m\\cdot 2^{m}\\right)$，这在渐近意义上被 $O\\!\\left(m\\log_{2}m\\cdot 2^{m}\\right)$ 所主导。\n\n因此，$M_{HALF}$ 的时间复杂度关于 $m$ 的最紧大O上界是 $O\\!\\left(m\\log_{2}m\\cdot 2^{m}\\right)$，对应于选项 D。", "answer": "$$\\boxed{D}$$", "id": "1419573"}]}