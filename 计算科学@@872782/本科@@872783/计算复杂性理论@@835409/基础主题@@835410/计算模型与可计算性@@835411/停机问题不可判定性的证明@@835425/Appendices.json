{"hands_on_practices": [{"introduction": "为了真正理解一个不可解问题的含义，我们可以做一个思想实验：假设我们拥有一个能解决它的“神谕”（oracle）。这个练习将引导你使用一个假设性的停机问题神谕，来解决一个看似不同但相关的问题。这个过程是“规约”（reduction）思想的精髓，它是计算理论中证明问题不可解性的核心工具。[@problem_id:1438125]", "problem": "在可计算性理论的研究中，我们经常探索算法的可计算能力的极限。一个核心的不可解问题是停机问题：判断一个任意的图灵机 (TM) 在给定输入上是否会停机。\n\n假设你被授权访问一个假想的“预言机”，一个名为 `HALT_ORACLE` 的黑箱函数。这个预言机接受任意图灵机 `M` 的描述和一个输入字符串 `s`，并立即提供一个明确的答案。具体来说，如果机器 `M` 在输入 `s` 上运行时会停机，`HALT_ORACLE(M, s)` 就返回 `true`，如果 `M` 永远运行，则返回 `false`。\n\n你的任务是使用这个强大的预言机来解决一个不同但相关的问题，我们称之为 `HW_PROBLEM`。`HW_PROBLEM` 的问题是：对于任意图灵机 `P` 和输入字符串 `w`，`P` 在输入 `w` 上的执行过程中，是否会曾经在其输出带上写入特定的字符串 \"hello world\"？\n\n你必须设计一个算法，作为 `HW_PROBLEM` 的一个**判定器**。判定器是一种算法，对于任何给定的输入（在此例中是 `P` 和 `w`），它都保证会停机并提供正确的“是”或“否”的答案。\n\n以下哪个算法能为任意给定的图灵机 `P` 和输入 `w` 正确且总是能判定 `HW_PROBLEM`？\n\nA. 模拟 $P$ 在 $w$ 上的执行。如果在此过程中观察到 \"hello world\" 被写入，则停机并回答“是”。如果 $P$ 停机但从未写入 \"hello world\"，则回答“否”。\n\nB. 首先查询 $\\text{HALT\\_ORACLE}(P, w)$。如果返回 `false`，则立即输出“否”。如果返回 `true`，则模拟 $P$ 在 $w$ 上的执行，并检查最终输出中是否包含 \"hello world\"。如果包含，则回答“是”，否则回答“否”。\n\nC. 构造一个新机器 $P'$，该机器忽略其自身输入，并按如下方式模拟 $P$ 在 $w$ 上的行为：如果 $P$ 在其执行过程中的任何时刻写入了 \"hello world\"，则 $P'$ 立即停机。如果 $P$ 停机但从未写入 \"hello world\"，则 $P'$ 进入一个无限循环。然后，你的算法查询 $\\text{HALT\\_ORACLE}(P', \\epsilon)$（其中 $\\epsilon$ 是空字符串），并返回与预言机相同的答案。\n\nD. 构造一个新机器 $P''$，该机器模拟 $P$ 在 $w$ 上的执行。只有在 $P$ 停机后，$P''$ 才检查 $P$ 的输出。如果输出中包含 \"hello world\"，则 $P''$ 停机。否则，$P''$ 进入无限循环。然后，你的算法查询 $\\text{HALT\\_ORACLE}(P'', \\epsilon)$ 并返回其结果。", "solution": "题目要求我们判定，对于任意图灵机 $P$ 和输入 $w$，在 $P$ 对输入 $w$ 的执行过程中，它是否曾写入字符串 \"hello world\"。我们可以使用一个预言机 $\\text{HALT\\_ORACLE}(M,s)$，它当且仅当 $M$ 在输入 $s$ 上停机时返回真，否则返回假。一个正确的判定器必须在所有输入上都停机，并返回正确的“是/否”答案。\n\n分析每个提议的算法：\n\n选项 A：$D$ 模拟 $P$ 在 $w$ 上的执行，如果它观察到 \"hello world\"，则回答“是”，如果 $P$ 停机但没有写入 \"hello world\"，则回答“否”。这不是一个判定器。如果 $P$ 在没有写入 \"hello world\" 的情况下永远运行，那么 $D$ 将永远模拟下去，永不停止。因此 A 未能保证总是停机。\n\n选项 B：$D$ 查询 $\\text{HALT\\_ORACLE}(P,w)$。如果返回假， $D$ 输出“否”。如果为真，$D$ 模拟 $P$ 在 $w$ 上的执行（现在保证会停机）并检查最终输出中是否有 \"hello world\"。这是不正确的：存在这样的机器 $P$，它在输入 $w$ 上，在某个有限的时间点写入 \"hello world\"，然后继续永远运行。在这种情况下，$\\text{HALT\\_ORACLE}(P,w)$ 返回假，所以 $D$ 输出“否”，但目标问题的正确答案是“是”，因为 \"hello world\" 在执行过程中被写入了。因此 B 是不正确的。\n\n选项 C：$D$ 构造一个机器 $P'$，它忽略自己的输入并模拟 $P$ 在 $w$ 上的执行，同时监视写入操作。$P'$ 的行为如下：\n- 如果 $P$ 曾写入 \"hello world\"，那么 $P'$ 立即停机。\n- 如果 $P$ 停机但没有写入 \"hello world\"，那么 $P'$ 进入一个无限循环。\n- 如果 $P$ 在没有写入 \"hello world\" 的情况下永远运行，那么 $P'$ 也永远运行（继续模拟）。\n然后 $D$ 查询 $\\text{HALT\\_ORACLE}(P',\\epsilon)$，其中 $\\epsilon$ 是空字符串。正确性分析：\n- 如果 $P$ 在 $w$ 上曾写入 \"hello world\"，那么 $P'$ 会停机，所以 $\\text{HALT\\_ORACLE}(P',\\epsilon)$ 返回真，$D$ 输出“是”。\n- 如果 $P$ 在 $w$ 上从未写入 \"hello world\"，有两种子情况：\n  1. $P$ 停机但没有写入 \"hello world\"：那么 $P'$ 会永远循环，所以预言机返回假，$D$ 输出“否”。\n  2. $P$ 永远运行但没有写入 \"hello world\"：那么 $P'$ 也永远不会停机，所以预言机返回假，$D$ 输出“否”。\n在所有情况下，$D$ 都在一次预言机查询后停机并给出正确答案。因此 C 是一个有效的判定器。\n\n选项 D：$D$ 构造一个机器 $P''$，它模拟 $P$ 在 $w$ 上的执行，并且只有在检测到 $P$ 停机后才检查最终输出；如果存在 \"hello world\"，它就停机，否则就循环。当 $P$ 在 $w$ 上写入 \"hello world\" 然后继续永远运行（永不停机）时，这个方法会失败。在这种情况下，$P''$ 永远不会停机，因为它在检查之前要等待 $P$ 停机，所以 $\\text{HALT\\_ORACLE}(P'',\\epsilon)$ 返回假，$D$ 输出“否”，这是不正确的，因为 \"hello world\" 确实在执行过程中被写入了。因此 D 是不正确的。\n\n因此，只有选项 C 使用预言机正确且总是能判定该问题。", "answer": "$$\\boxed{C}$$", "id": "1438125"}, {"introduction": "掌握了规约的基本思想后，下一步是亲手构造一个规约来证明一个问题是不可判定的。在这个实践中，你需要设计一台新的图灵机，其行为巧妙地依赖于另一台机器的停机行为。这种构造是证明许多计算机科学问题（例如，编译器中的某些分析任务）不可判定的基石。[@problem_id:1438139]", "problem": "在计算复杂性理论的研究中，证明一个问题是不可判定的常用技巧是，证明该问题的一个假想判定器可被用于解决停机问题。这通常涉及构造一台新的图灵机（TM），其性质依赖于另一台机器的行为。\n\n你的任务是设计这样一台图灵机。设 $M$ 是一台任意的图灵机，$w$ 是 $M$ 的一个任意输入串。我们在字母表 $\\{0, 1\\}$ 上定义一个特定的正则语言 $L_R$，它是所有包含 \"00\" 作为子串的字符串的集合。形式上，$L_R = \\{s \\in \\{0, 1\\}^* \\mid s \\text{ 包含 \"00\" 作为子串}\\}$。你可以假设一台能判定 $L_R$ 的图灵机（即，对于 $L_R$ 中的任何字符串，它都会停机并接受；对于不在 $L_R$ 中的任何字符串，它都会停机并拒绝）是现成可用的。\n\n你需要指定一台新图灵机 $M'$ 的设计，它接受一个字符串 $x \\in \\{0, 1\\}^*$ 作为输入。$M'$ 的构造依赖于 $M$ 和 $w$，且其行为必须满足以下两个条件：\n1.  如果 $M$ 在输入 $w$ 上停机，则 $M'$ 接受的语言，记为 $L(M')$，必须等于 $L_R$。\n2.  如果 $M$ 在输入 $w$ 上不停机，则 $M'$ 接受的语言 $L(M')$ 必须是空语言 $\\emptyset$。\n\n以下哪项关于 $M'$ 在其输入 $x$ 上的高级算法描述正确地满足了这些要求？选择所有适用的选项。\n\nA. 在输入 $x$ 上，$M'$ 首先模拟图灵机 $M$ 在输入 $w$ 上的运行。如果这个模拟停机，$M'$ 接着在其自身的输入 $x$ 上运行一个 $L_R$ 的判定器。如果 $x \\in L_R$ 它就接受，如果 $x \\notin L_R$ 它就拒绝。如果 $M$ 在 $w$ 上的模拟不停机，$M'$ 也不停机。\n\nB. 在输入 $x$ 上，$M'$ 首先模拟图灵机 $M$ 在输入 $w$ 上的运行。如果这个模拟停机，$M'$ 立即接受 $x$。如果 $M$ 在 $w$ 上的模拟不停机，$M'$ 也不停机。\n\nC. 在输入 $x$ 上，$M'$ 模拟图灵机 $M$ 在输入 $x$ 上的运行。如果这个模拟停机，$M'$ 接着检查字符串 $w$ 是否属于语言 $L_R$。如果 $w \\in L_R$，$M'$ 接受 $x$。否则，它拒绝 $x$。\n\nD. 在输入 $x$ 上，$M'$ 在 $x$ 上运行一个 $L_R$ 的判定器。如果 $x \\in L_R$，$M'$ 接受。如果 $x \\notin L_R$，$M'$ 拒绝。不使用 $M$ 在 $w$ 上的行为。\n\nE. 在输入 $x$ 上，$M'$ 首先在 $x$ 上运行一个 $L_R$ 的判定器。如果 $x \\notin L_R$，它立即拒绝。如果 $x \\in L_R$，它接着模拟图灵机 $M$ 在输入 $w$ 上的运行。如果这个模拟停机，$M'$ 接受。如果模拟不停机，$M'$ 也不停机。", "solution": "我们必须构造一台机器 $M'$，它依赖于一个给定的图灵机 $M$ 和一个固定的输入 $w$，使得：\n- 如果 $M$ 在 $w$ 上停机，则 $L(M') = L_{R}$，其中 $L_{R}$ 是包含子串 \"00\" 的所有二进制串构成的正则语言。\n- 如果 $M$ 在 $w$ 上不停机，则 $L(M') = \\emptyset$。\n\n回顾一下，对于任何图灵机 $T$，其语言 $L(T)$ 是 $T$ 停机并接受的那些输入的集合。$T$ 拒绝或不停机的输入不在 $L(T)$ 中。因此，为确保 $L(M') = \\emptyset$，只需 $M'$ 从不接受任何输入（它可以拒绝或进入循环）。\n\n我们逐一分析每个提出的构造：\n\n选项A：在输入 $x$ 上，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果模拟停机，$M'$ 在 $x$ 上运行一个 $L_{R}$ 的判定器，并且当且仅当 $x \\in L_{R}$ 时接受；如果模拟不停机，$M'$ 也不停机。\n- 如果 $M$ 在 $w$ 上停机，那么对于每个 $x$，$M'$ 会运行到 $L_{R}$ 判定器，并恰好接受那些在 $L_{R}$ 中的 $x$，所以 $L(M') = L_{R}$。\n- 如果 $M$ 在 $w$ 上不停机，那么对于每个 $x$，$M'$ 永远不会到达接受状态；因此没有输入被接受，$L(M') = \\emptyset$。\n因此 A 满足两个要求。\n\n选项B：在输入 $x$ 上，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果模拟停机，$M'$ 立即接受 $x$；否则它不停机。\n- 如果 $M$ 在 $w$ 上停机，那么每个 $x$ 都会被接受，所以 $L(M') = \\{0,1\\}^*$，这不等于 $L_{R}$。\n因此 B 失败。\n\n选项C：在输入 $x$ 上，$M'$ 模拟 $M$ 在 $x$ 上的运行。如果模拟停机，$M'$ 当且仅当 $w \\in L_{R}$ 时接受 $x$，否则拒绝。\n- 这使得 $L(M')$ 要么是 $M$ 的停机集（如果 $w \\in L_{R}$），要么是空集（如果 $w \\notin L_{R}$），并且它不依赖于 $M$ 是否在 $w$ 上停机。因此它不满足对 $M$ 在 $w$ 上行为的依赖性要求。\n因此 C 失败。\n\n选项D：在输入 $x$ 上，$M'$ 判定 $L_{R}$，忽略 $M$ 和 $w$。\n- 那么无论 $M$ 是否在 $w$ 上停机，$L(M') = L_{R}$ 恒成立，这违反了当 $M$ 在 $w$ 上不停机时 $L(M') = \\emptyset$ 的要求。\n因此 D 失败。\n\n选项E：在输入 $x$ 上，$M'$ 首先判定 $x$ 是否在 $L_{R}$ 中。如果 $x \\notin L_{R}$，它立即拒绝。如果 $x \\in L_{R}$，它模拟 $M$ 在 $w$ 上的运行，并且如果该模拟停机则接受；否则它不停机。\n- 如果 $M$ 在 $w$ 上停机，那么对于每个 $x \\in L_{R}$，$M'$ 最终会接受，而对于 $x \\notin L_{R}$，$M'$ 会拒绝。因此 $L(M') = L_{R}$。\n- 如果 $M$ 在 $w$ 上不停机，那么对于 $x \\in L_{R}$，$M'$ 不会停机（永不接受），而对于 $x \\notin L_{R}$，它会拒绝。因此没有输入被接受，$L(M') = \\emptyset$。\n因此 E 满足两个要求。\n\n正确的构造恰好是 A 和 E。", "answer": "$$\\boxed{AE}$$", "id": "1438139"}, {"introduction": "停机问题的不可判定性不仅仅是图灵机的一个怪癖，它具有普遍性。本练习将探讨一个更简单的计算模型——双计数器机——并揭示只要一个系统足够强大（即图灵完备），它就会继承停机问题这一根本限制。这有助于我们理解，计算的极限是任何足够复杂的计算系统都固有的。[@problem_id:1438132]", "problem": "在可计算性理论领域，停机问题是不可判定问题的一个经典例子。对于一个给定的计算模型，例如图灵机（TM），停机问题是：给定一个机器的描述和初始输入，该机器最终会停机，还是会永远运行下去？已经证明，不存在一个通用算法可以解决所有可能的图灵机输入的停机问题。\n\n一名计算机科学专业的学生提出了一种新的、极简的计算模型，称为双计数器机（2-CM）。一个2-CM由一个有限的状态集和两个计数器组成，每个计数器都可以存储任何非负整数。该机器根据一个简单的指令程序进行操作。这些指令可以增加一个计数器、减少一个计数器，或者根据一个计数器当前是否为零来条件跳转到另一条指令。\n\n该学生推测，由于2-CM模型比图灵机（具有无限长的带子）简单得多，其版本的停机问题可能是可判定的。也就是说，可能存在一种算法，可以确定任何给定的2-CM在给定的初始计数器值集上是否会停机。\n\n然而，可计算性理论中的一个基本结果指出，**任何图灵机都可以由一台双计数器机来模拟**。这意味着对于任何图灵机及其输入，都可以构造一个等价的2-CM，该2-CM停机的条件当且仅当原始的图灵机停机。\n\n根据这些信息，下列哪个陈述对双计数器机停机问题（“2-CM停机问题”）的可判定性给出了最准确的结论？\n\nA. 2-CM停机问题是不可判定的。如果它是可判定的，那么人们可以通过先将图灵机转换为其等价的2-CM，然后使用2-CM的判定器来构造一个图灵机停机问题的判定器。这将与已知的图灵机停机问题的不可判定性相矛盾。\n\nB. 2-CM停机问题是可判定的。用2-CM模拟图灵机并不意味着它们具有相同的可判定性属性。2-CM更简单的结构（缺少无限长的带子）允许对其状态和计数器值的循环进行分析，而这是图灵机的无限带所不允许的。\n\nC. 2-CM停机问题是不可判定的，但仅限于那些主动模拟图灵机的2-CM。对于并非作为图灵机模拟器构建的2-CM，由于其指令集有限，停机问题是可判定的。\n\nD. 从给定的信息中无法确定2-CM停机问题的可判定性。一个2-CM可以模拟一个图灵机这一事实，并不足以就2-CM本身的属性得出结论。\n\nE. 2-CM停机问题是可判定的。模拟能力仅意味着这些机器在计算能力上是等价的（图リング完备），但可判定性是一个与问题相关的独立属性，而非与机器的能力相关。", "solution": "我们对停机问题和归约论证进行形式化。\n\n定义图灵机停机问题语言\n$$\nH_{\\mathrm{TM}}=\\{ \\langle M,x \\rangle \\mid \\text{图灵机 } M \\text{ 在输入 } x \\text{ 上停机} \\}.\n$$\n定义双计数器机停机问题语言\n$$\nH_{2\\mathrm{CM}}=\\{ \\langle C,\\vec{v} \\rangle \\mid \\text{双计数器机 } C \\text{ 在初始计数器值 } \\vec{v} \\text{ 上停机} \\}.\n$$\n\n根据“任何图灵机都可以由一台双计数器机模拟，并保持其停机行为”这一既定事实，存在一个有效的（可计算的）转换，该转换在输入一个编码 $\\langle M,x \\rangle$ 时，会输出一个2-CM及其初始计数器的编码 $\\langle C_{M,x},\\vec{v}_{0} \\rangle$，使得\n$$\n\\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff \\langle C_{M,x},\\vec{v}_{0} \\rangle \\in H_{2\\mathrm{CM}}.\n$$\n等价地，存在一个可计算函数 $f$ 满足\n$$\nf(\\langle M,x \\rangle)=\\langle C_{M,x},\\vec{v}_{0} \\rangle \\quad \\text{并且} \\quad \\langle M,x \\rangle \\in H_{\\mathrm{TM}} \\iff f(\\langle M,x \\rangle) \\in H_{2\\mathrm{CM}}.\n$$\n这是一个多一归约 $H_{\\mathrm{TM}} \\leq_{m} H_{2\\mathrm{CM}}$。\n\n采用反证法，假设 $H_{2\\mathrm{CM}}$ 是可判定的。那么存在一个判定器 $D_{2\\mathrm{CM}}$，对于每个输入 $y$，$D_{2\\mathrm{CM}}(y)$ 都能正确地判定 $y$ 是否属于 $H_{2\\mathrm{CM}}$。我们可以如下构造一个 $H_{\\mathrm{TM}}$ 的判定器 $D_{\\mathrm{TM}}$：在输入 $\\langle M,x \\rangle$ 时，计算 $f(\\langle M,x \\rangle)$ 并在其结果上运行 $D_{2\\mathrm{CM}}$；输出相同的答案。根据 $f$ 所保持的等价性，这个 $D_{\\mathrm{TM}}$ 可以判定 $H_{\\mathrm{TM}}$。\n\n然而，一个基本结果是 $H_{\\mathrm{TM}}$ 是不可判定的。这个矛盾表明，$H_{2\\mathrm{CM}}$ 是可判定的这一假设是错误的。因此，$H_{2\\mathrm{CM}}$ 是不可判定的。\n\n评估各个选项：\n- A 正确地陈述了归约论证以及其与已知的 $H_{\\mathrm{TM}}$ 不可判定性之间的矛盾。\n- B 和 E 错误地声称问题是可判定的；可计算模拟的存在足以通过上述归约来传递不可判定性。\n- C 是不正确的，因为不可判定性是针对整个语言而言的；只要存在编码了图灵机行为的实例，就足以使整个停机问题变得不可判定。\n- D 是不正确的，因为给定的信息足以通过多一归约得出不可判定的结论。\n\n因此，正确选项是A。", "answer": "$$\\boxed{A}$$", "id": "1438132"}]}