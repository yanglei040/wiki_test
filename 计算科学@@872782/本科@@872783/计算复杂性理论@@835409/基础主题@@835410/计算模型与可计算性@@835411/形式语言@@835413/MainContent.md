## 引言
形式语言是计算机科学的理论基石，它为描述和处理结构化信息（如编程语言、数据格式和[生物序列](@entry_id:174368)）提供了一套严谨的数学框架。在数字世界中，我们如何精确地定义“合法”的模式，并设计算法来高效地识别和解析它们？这正是[形式语言理论](@entry_id:264088)试图解决的核心问题。它弥合了抽象的数学概念与具体的计算实践之间的鸿沟，使我们能够系统地分析计算问题的内在复杂性。

本文将带领读者深入探索形式语言的核心世界。我们将分为三个主要部分：
- 在“**原理与机制**”一章中，我们将从最基础的[计算模型](@entry_id:152639)——有限自动机和[正则语言](@entry_id:267831)——出发，逐步深入到更具[表达能力](@entry_id:149863)的[下推自动机](@entry_id:274593)和[上下文无关文法](@entry_id:266529)，并探讨计算的理论边界，即[可判定性](@entry_id:152003)与[不可判定性](@entry_id:145973)问题。
- 接着，在“**应用与跨学科联系**”一章中，我们将展示这些抽象理论如何在现实世界中大放异彩，揭示其在[编译器设计](@entry_id:271989)、数字电路、[生物信息学](@entry_id:146759)乃至[计算语言学](@entry_id:636687)中的关键作用。
- 最后，“**动手实践**”部分提供了一系列精选练习，旨在帮助读者将理论知识转化为解决实际问题的能力，通过构建自动机和转换文法来巩固所学。

通过本篇内容的学习，您将不仅掌握形式语言的基本概念，更能理解其作为一种思维工具，在解决跨领域复杂问题时的强大威力。

## 原理与机制

本章旨在系统性地阐述[形式语言理论](@entry_id:264088)中的核心原理与机制。我们将从最简单的计算模型——有限自动机——出发，逐步过渡到更具[表达能力](@entry_id:149863)的[下推自动机](@entry_id:274593)，并探讨与这些计算模型等价的文法系统。最终，我们将触及[计算理论](@entry_id:273524)的边界，讨论哪些关于形式语言的问题是可计算的，哪些是不可计算的。

### [正则语言](@entry_id:267831)与有限自动机

[正则语言](@entry_id:267831)构成了形式语言层级结构（乔姆斯基谱系）的基础，它们可以通过最简单的计算设备——有限自动机——来识别。理解有限自动机是深入学习计算理论的基石。

#### 确定性有限自动机 (DFA)

**确定性有限自动机 (Deterministic Finite Automaton, DFA)** 是一个数学模型，它通过处理一个输入符号串并根据预设的规则转换其内部状态来工作。其核心特征在于其“确定性”：对于任何给定的[状态和](@entry_id:193625)输入符号，转移到的下一个状态是唯一确定的。

一个 DFA 可以形式化地定义为一个五元组 $M = (Q, \Sigma, \delta, q_0, F)$，其中：
- $Q$ 是一个有穷的**状态 (states)** 集合。
- $\Sigma$ 是一个有穷的**字母表 (alphabet)**，包含所有可能的输入符号。
- $\delta: Q \times \Sigma \to Q$ 是**[转移函数](@entry_id:273897) (transition function)**，它指定了在某个状态下接收到某个输入符号后应转移到的下一个状态。
- $q_0 \in Q$ 是**起始状态 (start state)**。
- $F \subseteq Q$ 是**接受状态 (final or accepting states)** 的集合。

DFA 的计算过程是：从起始状态 $q_0$ 开始，依次读取输入字符串的每个符号，并根据[转移函数](@entry_id:273897) $\delta$ 更新当前状态。当整个字符串读取完毕后，如果 DFA 停留在某个接受状态 $f \in F$，则该字符串被**接受**；否则，该字符串被**拒绝**。DFA 接受的所有字符串的集合称为该 DFA 识别的**语言**，记为 $L(M)$。

DFA 的本质在于其有穷的内存，即它的状态集合 $Q$ 是有限的。这意味着 DFA 只能“记住”关于已读输入前缀的有限信息。一个经典的应用是利用状态来追踪某个可数的属性。例如，我们可以设计一个 DFA 来识别包含奇数个 '1' 的二进制串。该 DFA 仅需两个状态：一个表示已读部分包含偶数个 '1'（起始状态），另一个表示奇数个 '1'（接受状态）。每当读到 '1' 时，状态就发生翻转；读到 '0' 时，状态保持不变 [@problem_id:1424577]。

同样，我们也可以设计一个 DFA 来判断一个二[进制](@entry_id:634389)串所代表的数值模 3 的余数。由于任何数模 3 的余数只有 0, 1, 2 三种可能，我们可以用三个状态 $R_0, R_1, R_2$ 来分别代表这三种余数。如果当前状态为 $R_r$，代表已读前缀的数值为 $v \equiv r \pmod 3$。当下一个输入位是 $b$ 时，新的数值变为 $2v+b$。因此，新的余数 $r'$ 满足 $r' \equiv (2r+b) \pmod 3$。这直接定义了状态之间的转移规则。例如，从状态 $R_1$ 读到 '0'，新余数为 $(2 \times 1 + 0) \pmod 3 = 2$，故转移到 $R_2$ [@problem_id:1424613]。

#### [非确定性有限自动机 (NFA)](@entry_id:263987)

与 DFA 不同，**[非确定性有限自动机](@entry_id:273744) (Nondeterministic Finite Automaton, NFA)** 在计算过程中引入了“选择”的概念。对于某个[状态和](@entry_id:193625)输入符号，NFA 可能有多个下一状态可供选择，甚至允许在不消耗任何输入符号的情况下进行状态转移（称为 $\epsilon$-转移）。

一个 NFA 的[转移函数](@entry_id:273897)形式为 $\delta: Q \times (\Sigma \cup \{\epsilon\}) \to \mathcal{P}(Q)$，其中 $\mathcal{P}(Q)$ 是状态集 $Q$ 的幂集（所有[子集](@entry_id:261956)的集合）。这意味着一次转移的结果是一个状态的**集合**，而非单个状态。一个输入串被 NFA 接受，只要存在至少一条从起始状态开始的转移路径，在处理完整个字符串后能够到达某个接受状态。

NFA 在设计上通常比等价的 DFA 更简洁、更直观。例如，要识别所有以 `baa` 结尾的二[进制](@entry_id:634389)串，我们可以直观地设计一个 4 状态的 NFA [@problem_id:1424604]：
- $q_0$：起始状态，[循环等待](@entry_id:747359)，直到遇到一个 `b`，可以选择跳到 $q_1$。
- $q_1$：猜测 `b` 是 `baa` 的第一个字符，等待一个 `a`。
- $q_2$：已看到 `ba`，等待最后一个 `a`。
- $q_3$：已看到 `baa`，接受状态。

这种“猜测”和“并行探索”的能力正是非确定性的体现。

#### NFA 与 DFA 的等价性：[子集构造法](@entry_id:271646)

尽管 NFA 看起来比 DFA 更强大，但一个核心的结论是：对于任何 NFA，都存在一个识别相同语言的 DFA。这意味着 NFA 和 DFA 在计算能力上是**等价**的。将一个 NFA 转换为等价的 DFA 的标准算法称为**[子集构造法](@entry_id:271646) (Subset Construction)**。

该算法的核心思想是，构造出的 DFA 的每一个状态都对应原 NFA 中可能达到的一个**状态[子集](@entry_id:261956)**。DFA 的起始状态是 NFA 起始状态的 $\epsilon$-[闭包](@entry_id:148169)（即从起始状态出发，仅通过 $\epsilon$-转移能到达的所有状态的集合）。然后，我们系统地计算从每个已知的 DFA 状态（即 NFA 状态[子集](@entry_id:261956)）出发，在接收到字母表中的每个符号后，会转移到哪个新的 NFA 状态[子集](@entry_id:261956)。这个过程不断重复，直到没有新的 DFA 状态产生为止。DFA 的接受状态是那些包含了至少一个原 NFA 接受状态的状态[子集](@entry_id:261956)。

例如，对于前面提到的识别以 `baa` 结尾的语言的 NFA [@problem_id:1424604]，其状态集为 $\{q_0, q_1, q_2, q_3\}$，起始状态为 $q_0$，接受状态为 $\{q_3\}$。通过[子集构造法](@entry_id:271646)，我们可以得到一个等价的 DFA。其状态将是 NFA 状态的[子集](@entry_id:261956)：
1.  起始状态是 $\{q_0\}$。
2.  从 $\{q_0\}$ 读到 `b`，可以停在 $q_0$ 或前进到 $q_1$，因此 DFA 转移到新状态 $\{q_0, q_1\}$。
3.  从 $\{q_0, q_1\}$ 读到 `a`，在 $q_0$ 上会停在 $q_0$，在 $q_1$ 上会前进到 $q_2$，因此 DFA 转移到新状态 $\{q_0, q_2\}$。
4.  从 $\{q_0, q_2\}$ 读到 `a`，在 $q_0$ 上会停在 $q_0$，在 $q_2$ 上会前进到 $q_3$，因此 DFA 转移到新状态 $\{q_0, q_3\}$。由于这个新状态包含 NFA 的接受状态 $q_3$，所以它在 DFA 中是一个接受状态。
通过继续这个过程，我们发现最终只需要 4 个这样的[子集](@entry_id:261956)状态就能构成一个完整的 DFA。

#### [正则语言](@entry_id:267831)的[闭包性质](@entry_id:136899)

一个语言类别的**[闭包性质](@entry_id:136899) (closure properties)** 是指对该类别中的语言进行某种运算后，结果仍然属于该类别。[正则语言](@entry_id:267831)在一系列运算下是封闭的，这使得我们可以通过组合简单的[正则语言](@entry_id:267831)来构建复杂的[正则语言](@entry_id:267831)。

**交集运算**是一个重要的例子。如果 $L_1$ 和 $L_2$ 是两个[正则语言](@entry_id:267831)，那么它们的交集 $L_1 \cap L_2$ 也是一个[正则语言](@entry_id:267831)。这一性质可以通过**乘积构造法 (Product Construction)** 来证明。假设 $M_1 = (Q_1, \Sigma, \delta_1, q_{0,1}, F_1)$ 和 $M_2 = (Q_2, \Sigma, \delta_2, q_{0,2}, F_2)$ 分别是识别 $L_1$ 和 $L_2$ 的 DFA。我们可以构造一个新的 DFA $M_{int}$ 来识别 $L_1 \cap L_2$。
- $M_{int}$ 的状态集是 $Q_1 \times Q_2$，即两个原 DFA 状态的[笛卡尔积](@entry_id:154642)。
- $M_{int}$ 的起始状态是 $(q_{0,1}, q_{0,2})$。
- $M_{int}$ 的接受状态集是 $F_1 \times F_2$。
- $M_{int}$ 的[转移函数](@entry_id:273897)为 $\delta((q_1, q_2), a) = (\delta_1(q_1, a), \delta_2(q_2, a))$。

这个乘积自动机[实质](@entry_id:149406)上是并行地模拟了 $M_1$ 和 $M_2$ 的计算过程。一个输入串被 $M_{int}$ 接受，当且仅当它同时被 $M_1$ 和 $M_2$ 接受。

例如，考虑两个语言：$L_1$ 是包含奇数个 '1' 的二[进制](@entry_id:634389)串， $L_2$ 是其数值模 3 余 1 的二进制串 [@problem_id:1424577]。$L_1$ 的最小 DFA 有 2 个状态（奇偶性），$L_2$ 的最小 DFA 有 3 个状态（模 3 的余数）。通过乘积构造，我们可以得到一个识别 $L_1 \cap L_2$ 的 DFA，它有 $2 \times 3 = 6$ 个状态。每个状态 $(p, r)$ 同时追踪了 '1' 的奇偶性 $p$ 和数值模 3 的余数 $r$。经过可达性分析和最小化验证，可以确认这个 6 状态的 DFA 是最小的。

[正则语言](@entry_id:267831)在**同态 (homomorphism)** 运算下也是封闭的。同态是一个替换规则，它将字母表中的每个符号映射为一个字符串。例如，一个将二进制位翻转（0 变 1，1 变 0）的操作就是一个简单的同态。如果一个语言是正则的，那么对其中所有字符串应用同态后形成的新语言也是正则的 [@problem_id:1424613]。

#### [正则语言](@entry_id:267831)的局限性：[泵引理](@entry_id:275448)

尽管[正则语言](@entry_id:267831)用途广泛，但其计算能力有其根本局限。DFA 的有限内存意味着它无法解决需要无限“计数”或匹配嵌套结构的问题。**[正则语言](@entry_id:267831)的[泵引理](@entry_id:275448) (Pumping Lemma for Regular Languages)** 是证明一个语言**不是**[正则语言](@entry_id:267831)的有力工具。

[泵引理](@entry_id:275448)指出：对于任何[正则语言](@entry_id:267831) $L$，存在一个常数 $p$（称为**泵长度**），使得任何 $L$ 中长度不小于 $p$ 的字符串 $s$ 都可以被分解为三部分 $s = xyz$，并满足以下条件：
1.  $|xy| \le p$
2.  $|y| \ge 1$
3.  对于所有整数 $i \ge 0$，字符串 $xy^iz$ 仍然在 $L$ 中。

直观上，这意味着任何足够长的字符串在被 DFA 处理时，必然会经过一个状态循环。这个循环对应的子串 $y$ 可以被“泵”任意次（删除、重复一次或多次），而得到的字符串仍然被接受。

为了证明一个语言不是正则的，我们通常使用[反证法](@entry_id:276604)。假设它是正则的，那么它必须满足[泵引理](@entry_id:275448)。我们构造一个特殊的、足够长的字符串 $s$，然后证明无论如何根据引理规则分解 $s$，总能找到一个 $i$ 使得 $xy^iz$ 不在该语言中，从而产生矛盾。

例如，考虑语言 $L = \{A^m P^k T^n \mid m, n \ge 1, k = m \times n\}$ [@problem_id:1424561]。假设 $L$ 是正则的，泵长度为 $p$。我们选择字符串 $s = A^p P^{p^2} T^p$，该字符串在 $L$ 中（$m=p, n=p, k=p^2$）。根据引理，由于 $|xy| \le p$ 且 $s$ 以 $p$ 个 $A$ 开头，子串 $y$ 必定完全由 $A$ 组成，设 $y = A^t$ 且 $1 \le t \le p$。现在考虑“泵”一次后的字符串 $s' = xy^2z = A^{p+t} P^{p^2} T^p$。在这个新字符串中，A 的数量为 $m' = p+t$，P 的数量为 $k' = p^2$，T 的数量为 $n' = p$。为了使 $s'$ 仍在 $L$ 中，必须满足 $k' = m' \times n'$，即 $p^2 = (p+t) \times p = p^2 + pt$。然而，由于 $p \ge 1$ 且 $t \ge 1$，我们有 $pt > 0$，因此 $p^2 \neq p^2 + pt$。这个矛盾证明了我们的初始假设是错误的，因此 $L$ 不是一个[正则语言](@entry_id:267831)。

### [上下文无关语言](@entry_id:271751)与[下推自动机](@entry_id:274593)

当我们需要描述具有嵌套结构或需要依赖关系的语言时，[正则语言](@entry_id:267831)就显得力不从心了。例如，编程语言中的括号匹配、HTML 标签的嵌套等。**[上下文无关语言](@entry_id:271751) (Context-Free Languages, CFLs)** 提供了更强的[表达能力](@entry_id:149863)来处理这类结构。

#### [上下文无关文法](@entry_id:266529) (CFG)

**[上下文无关文法](@entry_id:266529) (Context-Free Grammar, CFG)** 是一种形式化的语法描述系统，它由一组产生式规则构成，用于生成语言中的所有字符串。其“上下文无关”的名称来源于其产生式规则的形式：规则的左侧总是一个单独的非终结符，这意味着这个非终结符可以被替换，而无需考虑它周围的“上下文”。

一个 CFG 由一个四元组 $G = (V, \Sigma, R, S)$ 定义：
- $V$ 是一个有穷的**变量 (variables)** 或**非终结符 (non-terminals)** 集合。
- $\Sigma$ 是一个有穷的**终结符 (terminals)** 集合（即语言的字母表），且 $V \cap \Sigma = \emptyset$。
- $R$ 是一组**产生式规则 (production rules)**，形式为 $X \to w$，其中 $X \in V$，$w \in (V \cup \Sigma)^*$ 是一个由变量和终结符组成的字符串。
- $S \in V$ 是**起始符号 (start symbol)**。

从起始符号 $S$ 开始，通过反复应用产生式规则，将[变量替换](@entry_id:141386)为规则右侧的字符串，直到所有变量都被终结符替换，这个过程称为**推导 (derivation)**。一个文法生成的所有终结符串的集合就是该文法定义的语言。

CFG 在描述语言结构时非常强大。例如，[正则语言](@entry_id:267831)的[闭包性质](@entry_id:136899)（如并集）在[上下文无关语言](@entry_id:271751)中依然适用。如果 $L_1$ 和 $L_2$ 是两个 CFL，那么它们的并集 $L_1 \cup L_2$ 也是一个 CFL。我们可以通过构造一个新的起始符号 $S$，并添加规则 $S \to S_1 \mid S_2$ 来实现，其中 $S_1$ 和 $S_2$ 分别是 $L_1$ 和 $L_2$ 的起始符号。

考虑语言 $L = \{ a^m b^n c^k \mid m,n,k \ge 1 \text{ and } (m=n \text{ or } n=k) \}$ [@problem_id:1424598]。这个语言可以看作两个子语言的并集：$L_1 = \{ a^n b^n c^k \mid n, k \ge 1 \}$ 和 $L_2 = \{ a^m b^n c^n \mid m, n \ge 1 \}$。我们可以分别为 $L_1$ 和 $L_2$ 设计文法模块，然后将它们组合起来：
- 对于 $L_1$，我们需要匹配等量的 $a$ 和 $b$，以及任意数量的 $c$。这可以由规则 $S_1 \to XC, X \to aXb \mid ab, C \to cC \mid c$ 生成。
- 对于 $L_2$，我们需要任意数量的 $a$ 和等量的 $b$ 和 $c$。这可以由规则 $S_2 \to AY, A \to aA \mid a, Y \to bYc \mid bc$ 生成。
- 最终，整个语言 $L$ 的文法就是将两者结合：$S \to S_1 \mid S_2$，即 $S \to XC \mid AY$。

#### 文法的[歧义](@entry_id:276744)性

一个重要的概念是**文法的[歧义](@entry_id:276744)性 (ambiguity)**。如果一个文法可以为某个字符串生成多个不同的**最左推导 (leftmost derivation)** 或**分析树 (parse tree)**，则该文法是[歧义](@entry_id:276744)的。在[编译器设计](@entry_id:271989)等应用中，歧义性通常是不希望出现的，因为它意味着对同一段代码可以有多种不同的语法解释。

例如，考虑为偶数长度的回文串（如 `abba`）设计的文法 [@problem_id:1424559]。文法 $G_A: S \to aSa \mid bSb \mid \epsilon$ 是**无[歧义](@entry_id:276744)**的。对于任何一个偶数长度的回文串，其推导路径是唯一确定的：字符串以 `a` 开头和结尾，就必须使用 $S \to aSa$ 规则；以 `b` 开头和结尾，就必须使用 $S \to bSb$。这个过程递归进行，选择是唯一的。

相比之下，文法 $G_D: S \to SS \mid a \mid b$ 能够生成所有非空二[进制](@entry_id:634389)串，但它是**高度歧义**的。例如，对于字符串 `aba`，我们可以有两种分析方式：`(ab)a` 或 `a(ba)`，这对应着两种不同的分析树，因此文法是[歧义](@entry_id:276744)的。

#### [下推自动机](@entry_id:274593) (PDA)

与有限自动机对应于[正则语言](@entry_id:267831)一样，**[下推自动机](@entry_id:274593) (Pushdown Automaton, PDA)** 是识别[上下文无关语言](@entry_id:271751)的计算模型。PDA 本质上是一个增加了**栈 (stack)** 的 NFA。这个栈提供了无限的存储空间，但访问受限：只能在栈顶进行**压入 (push)** 和**弹出 (pop)** 操作（后进先出，LIFO）。

正是这个栈结构，使得 PDA 能够处理需要“记忆”和“匹配”的嵌套结构。例如，在处理括号匹配时，PDA 可以在遇到左括号时将其压入栈中，在遇到右括号时从栈顶弹出一个左括号进行匹配。

一个重要的理论结果是：**一个语言是上下文无关的，当且仅当存在一个 PDA 能够识别它。** 这意味着 CFG 和 PDA 在计算能力上是等价的。

#### 从 CFG 到 PDA 的转换

存在一个标准算法，可以将任何 CFG 转换为一个等价的、通过**空栈接受 (acceptance by empty stack)** 的 PDA。这个 PDA 通常只有一个状态，它通过操作栈来模拟文法的最左推导。

转换算法的规则如下：
1.  **扩展规则**：对于文法中的每个产生式 $X \to w$，创建一个 PDA 转移规则 $(q, \epsilon, X) \to (q, w)$。这个规则不消耗输入，它的作用是：当栈顶是变量 $X$ 时，将 $X$ 弹出，然后将字符串 $w$（从右到左）压入栈。这模拟了用 $w$ 替换 $X$ 的推导步骤。
2.  **匹配规则**：对于字母表中的每个终结符 $t$，创建一个 PDA 转移规则 $(q, t, t) \to (q, \epsilon)$。这个规则的作用是：如果当前输入符号和栈顶的终结符相同，则将它们都消耗掉（即读取输入并弹出栈顶）。

例如，考虑文法 $G$：$S \to aA, A \to bAc, A \to \epsilon$ [@problem_id:1424602]。使用上述算法，我们可以构造一个等价的 PDA：
- 扩展规则：
  - 来自 $S \to aA$: $(q, \epsilon, S) \to (q, aA)$
  - 来自 $A \to bAc$: $(q, \epsilon, A) \to (q, bAc)$
  - 来自 $A \to \epsilon$: $(q, \epsilon, A) \to (q, \epsilon)$
- 匹配规则：
  - 来自终结符 $a, b, c$: $(q, a, a) \to (q, \epsilon)$, $(q, b, b) \to (q, \epsilon)$, $(q, c, c) \to (q, \epsilon)$

这个 PDA 通过非确定性地选择应用哪个产生式规则，并匹配输入中的终结符，精确地模拟了原 CFG 的所有可能推导。

#### [上下文无关语言](@entry_id:271751)的局限性

虽然比[正则语言](@entry_id:267831)更强大，但 CFL 也有其局限。例如，语言 $L = \{a^n b^n c^n \mid n \ge 0\}$ 是一个经典的非[上下文无关语言](@entry_id:271751)。PDA 的单一栈结构不足以同时确保 $a, b, c$ 的数量相等。

证明一个语言不是 CFL，除了使用针对 CFL 的[泵引理](@entry_id:275448)外，利用[闭包性质](@entry_id:136899)也是一种强大的技巧。与[正则语言](@entry_id:267831)不同，CFL 在**交集**运算下是**不封闭**的（但与[正则语言](@entry_id:267831)的交集是封闭的）。

我们可以利用这一性质来证明一个更复杂的语言不是 CFL。例如，考虑语言 $L' = \{ w \in \{a, b, c\}^* \mid |w|_a = |w|_b = |w|_c \}$，即包含相同数量 $a,b,c$ 的所有字符串 [@problem_id:1424595]。如果我们假设 $L'$ 是 CFL，那么它与[正则语言](@entry_id:267831) $R = a^*b^*c^*$ 的交集也必须是 CFL。然而，这个交集 $L' \cap R$ 正好是语言 $\{a^n b^n c^n \mid n \ge 0\}$，而我们已知后者不是 CFL。这个矛盾证明了 $L'$ 本身就不是一个[上下文无关语言](@entry_id:271751)。

### [可判定性](@entry_id:152003)与[不可判定性](@entry_id:145973)

在建立了形式语言和自动机的理论模型之后，一个自然的问题是：关于这些模型，有哪些问题是我们可以通过算法来自动回答的？这就是[计算理论](@entry_id:273524)中的**[可判定性](@entry_id:152003) (decidability)** 问题。

#### 自动机的可[判定问题](@entry_id:636780)

对于有限自动机，许多重要的问题都是**可判定**的，即存在一个算法，对于任何输入总能停机并给出正确的“是”或“否”的答案。

一个基本的例子是**DFA 的空语言问题 (Emptiness Problem)**：给定一个 DFA $M$，其接受的语言 $L(M)$ 是否为空集？ [@problem_id:1424609] 这个问题是可判定的，并且存在高效的算法。

我们可以将 DFA 视为一个[有向图](@entry_id:272310)，其中状态是顶点，转移是边。$L(M)$ 为空，当且仅当从起始状态 $q_0$ 出发，没有任何路径可以到达任何一个接受状态 $f \in F$。因此，空语言问题就转化为了一个图的**[可达性问题](@entry_id:273375)**。我们可以使用[广度优先搜索 (BFS)](@entry_id:272706) 或[深度优先搜索](@entry_id:270983) (DFS) 等标准[图遍历](@entry_id:267264)算法来解决。从 $q_0$ 开始遍历图，记录所有可达的顶点。遍历结束后，检查是否有任何一个接受状态被访问过。

该算法的效率很高。如果 DFA 有 $N$ 个状态，字母表大小为 $k$，那么对应的图有 $N$ 个顶点和 $N \times k$ 条边。BFS/DFS 的时间复杂度为 $O(\text{顶点数} + \text{边数})$，即 $O(N + Nk)$。由于 $N \ge 1, k \ge 1$，这可以简化为 $O(Nk)$。这表明检查一个 DFA 是否“有用”是一个计算上很“容易”的任务。

#### 形式语言的[不可判定问题](@entry_id:145078)

然而，当我们转向更强大的模型如[上下文无关文法](@entry_id:266529)时，许多问题就变得**不可判定 (undecidable)** 了。这意味着不存在一个算法，能对所有可能的输入都给出正确的停机回答。

一个核心的[不可判定问题](@entry_id:145078)是**CFG 的等价性问题 (Equivalence Problem)**：给定两个 CFG $G_1$ 和 $G_2$，它们生成的语言是否相同，即 $L(G_1) = L(G_2)$？

证明一个问题是不可判定的，标准的证明技巧是**归约 (reduction)**。我们从一个已知的[不可判定问题](@entry_id:145078)（如**停机问题**或**[波斯特对应问题](@entry_id:270784) (Post's Correspondence Problem, PCP)**）出发，证明如果我们可以解决我们关心的新问题，那么我们就能解决那个已知的[不可判定问题](@entry_id:145078)。这构成了一个矛盾，因此新问题也必定是不可判定的。

PCP 是一个关于匹配多米诺骨牌字符串的游戏。一个 PCP 实例包含一组“骨牌”，每个骨牌上有一个顶部字符串和一个底部字符串。目标是找到一个骨牌序列，使得按顺序连接所有顶部字符串得到的结果，与连接所有底部字符串得到的结果完全相同。PCP 已被证明是不可判定的。

我们可以将 PCP 归约到 CFG 的等价性问题上。对于一个给定的 PCP 实例，我们可以构造两个 CFG，$G_{top}$ 和 $G_{bottom}$ [@problem_id:1424583]。这两个文法会生成形如“一个可能的解的前半部分”和“解的后半部分（索引序列的逆序）”的字符串。
- $L_{top}$ 会生成形如 $t_{i_1} t_{i_2} \dots t_{i_m} c_{i_m} \dots c_{i_2} c_{i_1}$ 的字符串，其中 $t_j$ 是第 $j$ 个骨牌的顶部字符串，$c_j$ 是代表索引的特殊符号。
- $L_{bottom}$ 会生成形如 $b_{i_1} b_{i_2} \dots b_{i_m} c_{i_m} \dots c_{i_2} c_{i_1}$ 的字符串，其中 $b_j$ 是底部字符串。

这两个语言的交集 $L_{top} \cap L_{bottom}$ 中的每一个字符串，都对应着 PCP 的一个解。虽然 CFL 的交集不一定是 CFL，但可以证明“这两个语言是否相等”这一问题是不可判定的。其核心思想是，如果 $L_{top}$ 和 $L_{bottom}$ 完全相等，意味着对于任何索引序列，顶部字符串和底部字符串的连接总是不同的，这通常与 PCP 无解有关。反之，如果它们不相等，就意味着存在某个索引序列，使得顶部和底部字符串的连接不同，这为寻找 PCP 解提供了线索。通过一个更精巧的构造，可以证明，如果能判定任意两个 CFL 是否相等，就能判定任意 PCP 实例是否有解。由于后者是不可判定的，前者也必然是不可判定的。

这个例子深刻地揭示了计算的极限：即使是像“两个语法规则集是否等价”这样看似定义明确的问题，也不存在通用的算法能对其进行解答。