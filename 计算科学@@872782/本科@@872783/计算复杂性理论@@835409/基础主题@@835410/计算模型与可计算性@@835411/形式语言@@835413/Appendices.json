{"hands_on_practices": [{"introduction": "我们从一项基本技能开始：根据正则表达式构建非确定性有限自动机 (NFA)。练习 [@problem_id:1424597] 要求为识别给定语言的 NFA 找到所需的最少状态数。这不仅仅是机械地应用构造规则；它要求你首先分析并简化正则表达式，揭示其所描述语言的更深层本质，然后推断出最小自动机的结构。这个过程能磨练你发现等价关系和设计高效自动机的能力。", "problem": "在计算理论中，一个非确定性有限自动机 (NFA) 由一个五元组 $(Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中 $Q$ 是一个有限的状态集合，$\\Sigma$ 是一个有限的符号字母表，$\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$ 是转移函数（其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集），$q_0 \\in Q$ 是起始状态，以及 $F \\subseteq Q$ 是接受（或最终）状态的集合。\n\n考虑字母表 $\\Sigma = \\{a, b\\}$ 上的语言 $L$，它由以下正则表达式定义：\n$$ (a^*b \\cup b^*a)^+ $$\n一个接受语言 $L$ 的 NFA 所需的最小状态数是多少？\n\nA. 1\n\nB. 2\n\nC. 3\n\nD. 4\n\nE. 5", "solution": "我们分析正则表达式 $R = a^{*}b \\cup b^{*}a$ 以及在 $\\Sigma = \\{a, b\\}$ 上的语言 $L = R^{+}$。\n\n首先，观察到 $a \\in R$，因为当 $b$ 出现零次时，$b^{*}a$ 产生 $a$；同样，$b \\in R$，因为当 $a$ 出现零次时，$a^{*}b$ 产生 $b$。因此 $\\{a, b\\} \\subseteq R$。由于 $L = R^{+}$ 是 $R$ 中元素的所有有限拼接的集合，所以 $\\{a, b\\}$ 上的每个非空字符串都是 $a$ 和 $b$ 的拼接，而它们都在 $R$ 中。因此，\n$$\n\\{a, b\\}^{+} \\subseteq L.\n$$\n反过来，在 $L = R^{+}$ 中的每个字符串都是由长度至少为 $1$ 的块拼接而成，所以 $L \\subseteq \\{a, b\\}^{+}$。因此，\n$$\nL = \\{a, b\\}^{+}.\n$$\n\n我们现在确定 $L = \\Sigma^{+}$ 所需的 NFA 最小状态数。\n\n下界：任何单状态 NFA 都无法在不接受 $\\epsilon$ 的情况下识别 $\\Sigma^{+}$。如果这个唯一的状态是接受状态，那么 $\\epsilon$ 会被接受；如果它是拒绝状态，那么任何非空字符串都不能被接受，因为所有的计算都会在同一个拒绝状态结束。对于单个状态，Epsilon转移没有帮助，因为是否接受 $\\epsilon$ 完全取决于起始状态是否是接受状态。因此至少需要 $2$ 个状态。\n\n上界（构造性）：一个 $2$ 状态的 NFA 就足够了。令 $Q = \\{q_{0}, q_{1}\\}$，其中起始状态为 $q_{0}$，接受状态集为 $F = \\{q_{1}\\}$。定义转移\n$$\n\\delta(q_{0}, a) = \\{q_{1}\\}, \\quad \\delta(q_{0}, b) = \\{q_{1}\\}, \\quad \\delta(q_{1}, a) = \\{q_{1}\\}, \\quad \\delta(q_{1}, b) = \\{q_{1}\\}.\n$$\n那么该自动机恰好接受 $\\Sigma^{+}$。因此，一个 NFA 的最小状态数是 $2$。\n\n在选项中，这对应于 B。", "answer": "$$\\boxed{B}$$", "id": "1424597"}, {"introduction": "超越了正则语言，这个练习 [@problem_id:1424576] 挑战你处理一个经典的上下文无关语言：回文。你将完成一个下推自动机 (PDA) 的设计，它使用栈来实现超越有限自动机的记忆能力。这项实践对于理解栈如何识别嵌套或镜像结构至关重要，并突显了非确定性在猜测字符串中点时的强大作用。", "problem": "考虑字母表 $\\Sigma = \\{a, b\\}$ 上的所有回文构成的语言 $L$。回文是一个正读和反读都相同的字符串。形式上，$L = \\{w \\in \\{a,b\\}^* \\mid w = w^R\\}$，其中 $w^R$ 表示字符串 $w$ 的反转。\n\n我们正在设计一个非确定性下推自动机 (PDA)，记为 $M$，用来接受该语言 $L$。该 PDA 由一个元组 $M = (Q, \\Sigma, \\Gamma, \\delta, q_0, Z_0, F)$ 定义，包含以下组件：\n- 状态 $Q = \\{q_0, q_1, q_2\\}$\n- 输入字母表 $\\Sigma = \\{a, b\\}$\n- 栈字母表 $\\Gamma = \\{a, b, Z_0\\}$，其中 $Z_0$ 是初始栈符号。\n- 开始状态 $q_0$\n- 最终状态集 $F = \\{q_2\\}$\n\n该 PDA 的预期逻辑如下：\n1. 在状态 $q_0$ 中，读取输入字符串的前半部分，并将相应的符号推入栈中。\n2. 非确定性地猜测字符串的中间位置，并转移到状态 $q_1$。此转移可能会也可能不会消耗输入符号，以处理偶数和奇数长度的回文。\n3. 在状态 $q_1$ 中，读取输入字符串的后半部分，将每个符号与栈顶符号进行匹配，并将其弹出。\n4. 如果整个输入字符串已被读取，并且栈中只剩下初始符号 $Z_0$，则转移到最终状态 $q_2$。\n\n部分转移规则 $\\delta$ 已经定义。转移规则的书写格式为 $\\delta(\\text{当前状态}, \\text{输入符号}, \\text{栈顶符号}) = \\{(\\text{下一状态}, \\text{要推入的字符串})\\}$。\n- **推入规则 (在状态 $q_0$ 中):**\n    - $\\delta(q_0, a, X) = \\{(q_0, aX)\\}$，对于任意栈符号 $X \\in \\Gamma$\n    - $\\delta(q_0, b, X) = \\{(q_0, bX)\\}$，对于任意栈符号 $X \\in \\Gamma$\n- **接受规则:**\n    - $\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$\n\n您的任务是确定完成该 PDA 所需的正确的附加转移规则集，以便它能正确接受语言 $L$。以下哪组规则正确地表示了“猜测中间”和“弹出”阶段？注意 $\\epsilon$ 表示空字符串。\n\nA.\n- $\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nB.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nC.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$\n\nD.\n- $\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_0, a, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_0, b, X) = \\{(q_1, X)\\}$ 对于任意 $X \\in \\Gamma$\n- $\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$\n- $\\delta(q_1, b, a) = \\{(q_1, \\epsilon)\\}$", "solution": "目标是构建一个下推自动机 (PDA)，以识别字母表 $\\Sigma=\\{a,b\\}$ 上的回文语言 $L = \\{w \\mid w=w^R\\}$。该 PDA 必须能正确处理偶数长度、奇数长度的回文以及空字符串。\n\n给定的 PDA 结构使用三个状态：$q_0$ 用于推入阶段，$q_1$ 用于弹出阶段，$q_2$ 作为最终（接受）状态。\n\n我们来逐步分析必要的逻辑：\n\n1.  **推入阶段：** PDA 从状态 $q_0$ 开始。对于输入字符串 $w$ 的前半部分，它应该读取符号并将它们推入栈中。这创建了前半部分的反向记录。已提供的规则 `$\\delta(q_0, a, X) = \\{(q_0, aX)\\}$` 和 `$\\delta(q_0, b, X) = \\{(q_0, bX)\\}$`（对于任意 $X \\in \\Gamma$）正确地实现了这一点。对于一个输入符号 $c$，它被推入到栈中任何已存在的内容（$X$）之上，使得栈内容变为 $cX$。\n\n2.  **猜测中间：** 这是关键的非确定性步骤。PDA 必须猜测何时到达了字符串的中间。\n    *   **偶数长度的回文：** 对于像 `abba` 这样的字符串，中间位置在两个 `b` 之间。在读取 `ab` 之后，栈中包含 `baZ_0`（从底到顶）。PDA 必须在不消耗任何输入符号的情况下，从推入状态（$q_0$）转移到弹出状态（$q_1$）。实现这一点的规则是 `$\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$`（对于任意栈符号 $X$）。该规则保持栈不变，并转移到状态 $q_1$ 开始匹配阶段。\n    *   **奇数长度的回文：** 对于像 `aba` 这样的字符串，中间是符号 `b`。在读取 `a` 之后，栈中包含 `aZ_0`。PDA 需要读取中间符号 `b`，但*不*执行任何栈操作，因为这个中心字符没有对应的匹配项。然后它必须转移到状态 $q_1$。实现这一点的规则是 `$\\delta(q_0, a, X) = \\{(q_1, X)\\}$` 和 `$\\delta(q_0, b, X) = \\{(q_1, X)\\}$`（对于栈顶的任意符号 $X$）。这些规则消耗一个输入符号（中间那个），但保持栈的原样，然后转移到弹出状态 $q_1$。\n\n3.  **弹出阶段：** 一旦进入状态 $q_1$，PDA 就开始读取字符串的后半部分。对于它读取的每个输入符号，它必须与栈顶的符号相匹配。如果匹配，栈顶符号就被弹出。例如，如果输入是 `a` 并且栈顶是 `a`，自动机应该弹出 `a` 并保持在状态 $q_1$。所需的规则是 `$\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$` 和 `$\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$`。输出中的 `$\\epsilon$` 表示没有东西被推回栈中，这实际上是一个弹出操作。\n\n4.  **接受：** 在整个字符串被读取完毕后，如果自动机成功匹配了后半部分的所有符号，栈应该只包含初始符号 $Z_0$。给定的接受规则 `$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$` 允许自动机此时转移到最终状态 $q_2$，从而接受该字符串。空字符串也是一个回文。自动机可以通过从 $q_0$ 开始，立即采用 $\\epsilon$-转移 `$\\delta(q_0, \\epsilon, Z_0) = \\{(q_1, Z_0)\\}$` 到达 $q_1$，然后采用接受转移 `$\\delta(q_1, \\epsilon, Z_0) = \\{(q_2, Z_0)\\}$` 来接受空字符串。\n\n现在，我们来评估给出的选项：\n\n*   **选项 A：** 规则 `$\\delta(q_0, a, a) = \\{(q_1, \\epsilon)\\}$` 和 `$\\delta(q_0, b, b) = \\{(q_1, \\epsilon)\\}$` 对于“猜测中间”是不正确的。它们意味着要转移到状态 $q_1$，自动机必须读取一个与栈顶匹配的输入符号并将其弹出。这不符合先推入字符串前半部分再匹配后半部分的逻辑。\n\n*   **选项 B：** 这个选项只包含了用于猜测中间的规则 `$\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$`。这能正确处理偶数长度的回文，但没有提供处理奇数长度回文中间字符的方法。像 `aba` 这样的奇数长度回文会被拒绝，因为 PDA 对于读取中间的 `b` 没有定义转移。\n\n*   **选项 C：** 这个选项提供了“猜测中间”和“弹出”阶段所需的完整规则集。\n    *   `$\\delta(q_0, \\epsilon, X) = \\{(q_1, X)\\}$` 处理偶数长度的情况。\n    *   `$\\delta(q_0, a, X) = \\{(q_1, X)\\}$` 和 `$\\delta(q_0, b, X) = \\{(q_1, X)\\}$` 通过消耗中间符号而不改变栈来处理奇数长度的情况。\n    *   `$\\delta(q_1, a, a) = \\{(q_1, \\epsilon)\\}$` 和 `$\\delta(q_1, b, b) = \\{(q_1, \\epsilon)\\}$` 正确地实现了对字符串后半部分的匹配和弹出操作。\n    这组规则是正确的。\n\n*   **选项 D：** 这个选项有正确的猜测中间的规则，但其弹出规则是错误的。规则 `$\\delta(q_1, a, b) = \\{(q_1, \\epsilon)\\}$` 意味着“如果输入是 `a`，则弹出 `b`”。这无法匹配一个回文。对于回文 `aba`，在推入 `a` 并读取中心 `b` 后，栈中包含 `aZ_0`。下一个输入是 `a`。该规则集没有为 `(q_1, a, a)` 提供转移，所以自动机会卡住并拒绝。\n\n因此，唯一正确且完整的规则集在选项 C 中提供。", "answer": "$$\\boxed{C}$$", "id": "1424576"}, {"introduction": "在学习了自动机之后，我们现在转向语言的文法表示。这个问题 [@problem_id:1424566] 将指导你完成将上下文无关文法 (CFG) 转换为乔姆斯基范式 (CNF) 的系统过程。掌握这个算法流程至关重要，因为 CNF 是一种标准化形式，它简化了语法分析，并且是计算理论中许多重要算法（如用于判断语言成员资格的 CYK 算法）的先决条件。", "problem": "上下文无关文法 (CFG) 是一种形式文法，其中每个产生式规则都具有 $V \\rightarrow w$ 的形式，其中 $V$ 是一个单一的非终结符号，$w$ 是一个由终结符和/或非终结符组成的字符串。\n\n如果一个 CFG 的每个产生式规则都属于以下形式之一，那么它就处于乔姆斯基范式 (CNF) 中：\n1. $A \\rightarrow BC$，其中 $A, B, C$ 是非终结符号。\n2. $A \\rightarrow a$，其中 $A$ 是一个非终结符号，$a$ 是一个终结符号。\n此外，如果空串 $\\epsilon$ 属于该语言，则允许规则 $S \\rightarrow \\epsilon$，其中 $S$ 是起始符号，前提是 $S$ 不出现在任何规则的右侧。\n\n考虑以下上下文无关文法 $G$，其非终结符号集为 $V = \\{S, A, B\\}$，终结符号集为 $\\Sigma = \\{a, b\\}$，$S$ 为起始符号。其产生式规则 $P$ 如下：\n$S \\rightarrow aSA$\n$A \\rightarrow bB$\n$B \\rightarrow S \\mid \\epsilon$\n\n您的任务是将文法 $G$ 转换为乔姆斯基范式下的等价文法 $G'$。请从以下选项中选择一个正确表示 $G'$ 的产生式规则集的选项。在选项中，$S'$ 是新的起始符号，任何其他新的非终结符号都表示为 $V_x$ 或 $X_y$。\n\nA.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nB.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow S$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nC.\n$S' \\rightarrow V_a X_1$\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nD.\n$S \\rightarrow V_a X_1$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a X_1$\n$X_1 \\rightarrow S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$\n\nE.\n$S' \\rightarrow V_a S A$\n$S \\rightarrow V_a S A$\n$A \\rightarrow V_b B$\n$A \\rightarrow b$\n$B \\rightarrow V_a S A$\n$V_a \\rightarrow a$\n$V_b \\rightarrow b$", "solution": "我们从给定的文法开始，其非终结符为 $V=\\{S,A,B\\}$，终结符为 $\\Sigma=\\{a,b\\}$，起始符号为 $S$，产生式如下：\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB,\\quad B \\rightarrow S \\mid \\epsilon $$\n\n步骤 1：识别可空非终结符。由于 $B \\rightarrow \\epsilon$，$B$ 是可空的。因为 $A \\rightarrow bB$，$A$ 可以推导出 $b$ 但不能推导出 $\\epsilon$，所以 $A$ 不是可空的。$S$ 也不是可空的，因为它的规则 $S \\rightarrow aSA$ 包含终结符 $a$，并且没有仅由可空符号构成的右侧。\n\n步骤 2：消除 $\\epsilon$-产生式。移除 $B \\rightarrow \\epsilon$，并为任何包含 $B$ 的产生式添加一个省略 $B$ 的变体。唯一的此类产生式是 $A \\rightarrow bB$，它产生一个额外的 $A \\rightarrow b$。因此，在消除 $\\epsilon$ 后，我们得到：\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow S $$\n\n步骤 3：消除单元产生式。唯一的单元产生式是 $B \\rightarrow S$。将其替换为 $B$ 采用 $S$ 的产生式，即 $B \\rightarrow aSA$，并移除 $B \\rightarrow S$。我们得到：\n$$ S \\rightarrow aSA,\\quad A \\rightarrow bB \\mid b,\\quad B \\rightarrow aSA $$\n\n步骤 4：为转换为乔姆斯基范式做准备，方法是分离长右侧中的终结符并进行二元化。首先为出现在长度大于1的右侧中的终结符引入新的非终结符：$V_{a} \\rightarrow a$ 和 $V_{b} \\rightarrow b$。然后，通过引入新变量 $X_1 \\rightarrow SA$ 将任何长度大于2的右侧二元化。替换后得到如下规则：\n*   $S \\rightarrow aSA$ 变为 $S \\rightarrow V_a X_1$。\n*   $B \\rightarrow aSA$ 变为 $B \\rightarrow V_a X_1$。\n*   $A \\rightarrow bB$ 变为 $A \\rightarrow V_b B$。\n*   $A \\rightarrow b$ 规则本身已是 CNF 格式，予以保留。\n\n步骤 5：引入一个新的起始符号 $S'$，它不出现在任何右侧。为了避免单元产生式 $S' \\rightarrow S$，我们直接定义 $S'$ 来镜像 $S$ 的产生式：\n$$ S' \\rightarrow V_{a}X_{1} $$\n\n将所有 CNF 产生式收集起来，我们得到：\n$S' \\rightarrow V_a X_1$,\n$S \\rightarrow V_a X_1$,\n$A \\rightarrow V_b B \\mid b$,\n$B \\rightarrow V_a X_1$,\n$X_1 \\rightarrow SA$,\n$V_a \\rightarrow a$,\n$V_b \\rightarrow b$。\n这与选项 C 匹配。\n\n其他选项无效的原因：\n- A 省略了 $A \\rightarrow b$，这是在消除 $B \\rightarrow \\epsilon$ 后所必需的，因此改变了语言。\n- B 保留了单元产生式 $B \\rightarrow S$，这在 CNF 中是不允许的。\n- D 缺少选项描述中指定的新起始符号 $S'$。\n- E 包含长度为3的右侧（例如，$S' \\rightarrow V_{a}SA$），违反了 CNF 的二元形式要求。\n\n因此，正确选项是 C。", "answer": "$$\\boxed{C}$$", "id": "1424566"}]}