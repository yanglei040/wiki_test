{"hands_on_practices": [{"introduction": "映射可归约性是证明问题不可判定性的强大工具。掌握它的最佳方式就是亲手构造归约。我们将从一个基本问题开始：如何证明判定一个图灵机是否恰好只接受一个字符串（我们称之为 $ONE_{TM}$ 语言）是不可判定的。我们的策略是，将通用的图灵机接受问题 $A_{TM}$ 归约到 $ONE_{TM}$，通过构造一个新的图灵机 $M'$，它的行为完全取决于原始图灵机 $M$ 是否接受输入 $w$ [@problem_id:1431361]。", "problem": "在可计算性理论中，证明一个语言是不可判定的一个核心方法是，展示一个从已知不可判定语言到该语言的映射归约。令 $A_{TM}$ 为图灵机（TM）的接受问题，定义为 $A_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ 是一个 TM 且 } M \\text{ 接受字符串 } w\\}$。语言 $A_{TM}$ 是已知的不可判定语言。\n\n考虑语言 $ONE_{TM}$，它被定义为所有接受一个恰好包含一个字符串的语言的图灵机的集合：\n$$ONE_{TM} = \\{\\langle M \\rangle \\mid M \\text{ 是一个 TM 且 } |L(M)| = 1\\}$$\n其中 $L(M)$ 是机器 $M$ 的语言，而 $|L(M)|$ 表示该语言中字符串的数量。\n\n为了证明 $ONE_{TM}$ 是不可判定的，可以构造一个可计算函数 $f$，它接受一个输入 $\\langle M, w \\rangle$ 并输出一个新图灵机 $M'$ 的描述。这个函数必须满足映射归约的条件：$\\langle M, w \\rangle \\in A_{TM}$ 当且仅当 $\\langle M' \\rangle \\in ONE_{TM}$。\n\n令 $s_0$ 为一个固定的非空字符串（例如，$s_0 = \\text{\"computation\"}$）。函数 $f$ 基于 $M$ 和 $w$ 构造 $M'$。以下哪种关于 $M'$ 在任意输入字符串 $x$ 上的行为的描述，正确地实现了这个归约？\n\nA. 在输入 $x$ 上，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果该模拟接受，$M'$ 就接受 $x$。否则，$M'$ 拒绝 $x$。\n\nB. 在输入 $x$ 上，$M'$ 模拟 $M$ 在 $x$ 上的运行。如果该模拟接受，$M'$ 也接受 $x$。机器 $M'$ 还被硬编码为无论 $M$ 的行为如何都接受字符串 $s_0$。\n\nC. 在输入 $x$ 上，$M'$ 首先检查是否 $x = s_0$。如果 $x \\neq s_0$，$M'$ 立即拒绝。如果 $x = s_0$，$M'$ 则接着模拟 $M$ 在 $w$ 上的运行。如果该模拟接受，$M'$ 就接受其输入 $s_0$。否则，$M'$ 拒绝。\n\nD. 在输入 $x$ 上，$M'$ 的行为与 $M$ 无关。它检查是否 $x = w$。如果是，$M'$ 接受。如果 $x \\neq w$，$M'$ 拒绝。", "solution": "我们要构造一个可计算函数 $f$，将输入 $\\langle M,w \\rangle$ 映射到一个图灵机 $M'$，使得\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}.$$\n根据定义，$\\langle M' \\rangle \\in ONE_{TM}$ 意味着 $|L(M')|=1$。我们固定一个特定的非空字符串 $s_{0}$。\n\n定义 $f$ 如下：对于输入 $\\langle M,w \\rangle$，输出图灵机 $M'$ 的编码，该图灵机在输入 $x$ 上执行以下操作：\n1. 如果 $x \\neq s_{0}$，拒绝。\n2. 如果 $x = s_{0}$，模拟 $M$ 在 $w$ 上的运行；如果模拟接受，则接受 $s_{0}$；如果模拟停机并拒绝，则拒绝 $s_{0}$；如果模拟不停机，则 $M'$ 在 $s_{0}$ 上也不停机。\n\n这个 $f$ 是可计算的，因为 $M'$ 的描述可以通过硬编码一个与 $s_{0}$ 的比较以及在 $w$ 上对 $M$ 的模拟，从 $M$ 的代码、字符串 $w$ 和固定的字符串 $s_{0}$ 中有效地构造出来。\n\n正确性：\n- 如果 $\\langle M,w \\rangle \\in A_{TM}$，那么 $M$ 接受 $w$。因此，在输入 $x=s_{0}$ 上，$M'$ 接受；而在所有 $x \\neq s_{0}$ 上，$M'$ 拒绝。所以 $L(M')=\\{s_{0}\\}$ 且 $|L(M')|=1$，于是 $\\langle M' \\rangle \\in ONE_{TM}$。\n- 如果 $\\langle M,w \\rangle \\notin A_{TM}$，那么 $M$ 不接受 $w$（要么拒绝，要么不停机）。因此，对于 $x=s_{0}$，$M'$ 不接受；对于 $x \\neq s_{0}$，$M'$ 拒绝。所以 $L(M')=\\varnothing$ 且 $|L(M')|=0$，于是 $\\langle M' \\rangle \\notin ONE_{TM}$。\n\n因此 $\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in ONE_{TM}$，这与描述 C 相匹配。\n\n为什么其他选项是错误的：\n- 选项 A 会使得：如果 $M$ 接受 $w$，则 $L(M')=\\Sigma^{*}$；否则 $L(M')=\\varnothing$。$|L(M')|$ 永远不等于 1。\n- 选项 B 确保了无论 $M$ 如何，$s_{0} \\in L(M')$，并且可能根据 $M$ 的行为包含其他字符串，因此 $|L(M')|$ 很少等于 1，并且没有编码 $M$ 是否接受 $w$ 的信息。\n- 选项 D 完全忽略了 $M$，总是产生一个单元素语言 $\\{w\\}$，这破坏了与 $A_{TM}$ 所要求的等价关系。\n\n因此，正确的实现是选项 C。", "answer": "$$\\boxed{C}$$", "id": "1431361"}, {"introduction": "在上一个练习中，我们将单个计算结果映射到了一个“存在性”属性（存在一个被接受的字符串）。现在，我们来挑战一个“普遍性”属性：判定一个图灵机是否接受所有偶数长度的字符串（$L_{EVEN}$ 语言）。这里的核心挑战在于，如何让一个单一的、不确定的事件（$M$ 是否接受 $w$）决定新机器 $M'$ 在一个无限输入集上的行为。这个练习将帮助你掌握如何根据一个条件，精确地控制新机器的语言，使其要么包含一个无限集，要么一个都不包含 [@problem_id:1431374]。", "problem": "在可计算性理论中，证明一个语言是不可判定的基本方法之一是通过映射归约。设 $\\Sigma = \\{0, 1\\}$ 为字母表。考虑图灵机（TM）接受问题的著名不可判定语言：\n$$A_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ is a TM that accepts string } w \\}$$\n现在，考虑一个不同的语言 $L_{EVEN}$，它与图灵机在偶数长度字符串上的行为有关：\n$$L_{EVEN} = \\{ \\langle M \\rangle \\mid M \\text{ is a TM and } L(M) \\text{ contains all strings of even length over } \\Sigma \\}$$\n为了证明 $L_{EVEN}$ 是不可判定的，我们可以构造一个从 $A_{TM}$ 到 $L_{EVEN}$ 的映射归约。这需要定义一个可计算函数 $f$，它将输入 $\\langle M, w \\rangle$ 转换为输出 $\\langle M' \\rangle$，使得 $\\langle M, w \\rangle \\in A_{TM}$ 当且仅当 $\\langle M' \\rangle \\in L_{EVEN}$。\n\n下列哪项正确描述了由这样的归约函数 $f$ 构造出的机器 $M'$ 的行为？\n\nA. 对于输入 $x$，机器 $M'$ 模拟 $M$ 在 $w$ 上的运行。如果 $M$ 接受 $w$，$M'$ 就拒绝 $x$。如果 $M$ 不接受 $w$（拒绝或进入无限循环），$M'$ 就接受 $x$。\n\nB. 对于输入 $x$，机器 $M'$ 模拟 $M$ 在 $w$ 上的运行。如果 $M$ 接受 $w$，$M'$ 接着模拟 $M$ 在 $x$ 上的运行，且其行为与 $M$ 在 $x$ 上的行为一致。如果 $M$ 不接受 $w$，$M'$ 就拒绝 $x$。\n\nC. 对于输入 $x$，机器 $M'$ 首先检查 $x$ 的长度（记为 $|x|$）是否为偶数。如果 $|x|$ 是奇数，$M'$ 就拒绝。如果 $|x|$ 是偶数，$M'$ 忽略 $x$ 并模拟 $M$ 在 $w$ 上的运行。如果模拟结果显示 $M$ 接受 $w$，则 $M'$ 接受 $x$。\n\nD. 对于输入 $x$，机器 $M'$ 首先检查 $x$ 的长度（记为 $|x|$）是否为偶数。如果 $|x|$ 是偶数，$M'$ 就接受。如果 $|x|$ 是奇数，$M'$ 模拟 $M$ 在 $w$ 上的运行，并在 $M$ 接受 $w$ 的情况下接受。", "solution": "我们的目标是构造一个可计算函数 $f$，它将 $A_{TM}$ 的实例 $\\langle M,w \\rangle$ 映射到 $L_{EVEN}$ 的实例 $\\langle M' \\rangle$，使得\n$$\\langle M,w \\rangle \\in A_{TM} \\iff \\langle M' \\rangle \\in L_{EVEN}.$$\n回顾一下，$L_{EVEN} = \\{\\langle M \\rangle \\mid E \\subseteq L(M)\\}$，其中\n$$E = \\{x \\in \\Sigma^{*} : |x| \\text{ is even}\\}.$$\n\n通过从 $\\langle M,w \\rangle$ 构造 $M'$ 来定义 $f$ 如下。对于输入 $x$，机器 $M'$：\n1. 检查 $|x|$ 的奇偶性。\n2. 如果 $|x|$ 是奇数，$M'$ 拒绝 $x$。\n3. 如果 $|x|$ 是偶数，$M'$ 模拟 $M$ 在 $w$ 上的运行。如果模拟接受，$M'$ 就接受 $x$；如果模拟不接受（拒绝或不停止），则 $M'$ 不接受 $x$。\n\n这个构造是可计算的，因为检查奇偶性以及将一个固定的对 $M$ 在 $w$ 上的模拟硬编码进 $M'$ 都是有效的操作。\n\n正确性证明：\n- 如果 $\\langle M,w \\rangle \\in A_{TM}$，则 $M$ 接受 $w$。因此，对于每个 $|x|$ 为偶数的 $x$，根据步骤 3，$M'$ 接受 $x$。所以 $E \\subseteq L(M')$，从而 $\\langle M' \\rangle \\in L_{EVEN}$。\n- 如果 $\\langle M,w \\rangle \\notin A_{TM}$，则 $M$ 不接受 $w$。那么对于每个 $|x|$ 为偶数的 $x$，步骤 3 中的模拟永远不会导致接受，所以 $M'$ 不接受这样的 $x$。因此，存在一个偶数长度的字符串不在 $L(M')$ 中，所以 $E \\nsubseteq L(M')$ 并且 $\\langle M' \\rangle \\notin L_{EVEN}$。\n\n因此，这个 $M'$ 满足了所要求的当且仅当条件，并且其描述的行为与选项 C 相符。\n\n检查其他选项：\n- A 颠倒了条件，使得当 $M$ 不接受 $w$ 时 $L(M') = \\Sigma^{*}$，而当 $M$ 接受 $w$ 时 $L(M')$ 为空集，这无法得出 $E \\subseteq L(M')$ 当且仅当 $M$ 接受 $w$。\n- B 使得当 $M$ 接受 $w$ 时，$L(M')$ 依赖于 $L(M)$ 在任意 $x$ 上的行为，这不能保证包含所有偶数长度的字符串。\n- D 使得所有偶数长度的字符串都被接受，而不管 $M$ 和 $w$ 如何，这破坏了归约。\n\n因此，正确的描述是 C。", "answer": "$$\\boxed{C}$$", "id": "1431374"}, {"introduction": "映射归约的威力远不止于证明语言属性的不可判定性，它还能应用于不同的计算模型及其物理行为。在这个练习中，我们将探讨一个非标准的计算模型：双磁头图灵机。我们将证明，判定这样一个机器的两个磁头是否会在计算过程中发生碰撞（即占据同一个格子）是不可判定的。我们将通过一个巧妙的构造，将标准的停机问题 $HALT_{TM}$ 归约到这个问题，从而将“停机”这一计算事件转化为“磁头碰撞”这一物理事件 [@problem_id:1431410]。这展示了可归约性在不同计算范式之间建立联系的强大能力。", "problem": "在可计算性理论中，标准的图灵机（TM）是一种计算模型，它带有一条无限长的纸带和一个读写头。双头单带图灵机（2-HTM）是其一种变体，它拥有一条无限长的纸带，但有两个独立的读写头，我们称之为 $H_1$ 和 $H_2$。该机器的转移函数形式为 $\\delta: Q \\times \\Gamma^2 \\to Q \\times \\Gamma^2 \\times \\{L, R, S\\}^2$，其中 $Q$ 是状态集，$\\Gamma$ 是带字母表，而 $\\{L, R, S\\}$ 分别代表读写头向左、向右和保持不动。这意味着机器的下一步操作由其当前状态和两个读写头读取到的符号共同决定。\n\n如果一台 2-HTM $T$ 在其计算过程中的任何时刻，它的两个读写头 $H_1$ 和 $H_2$ 占据了纸带上的同一个格子，我们称之为发生了“读写头碰撞”。\n\n我们来定义两种语言。首先是著名的图灵机不可判定停机问题：\n$HALT_{TM} = \\{\\langle M, w \\rangle \\mid M \\text{ is a TM that halts on input string } w\\}$。\n\n第二种是关于 2-HTM 行为的语言：\n$HEAD_{COLLIDE} = \\{\\langle T \\rangle \\mid T \\text{ is a 2-HTM that, when started on a completely blank tape, eventually has a head collision}\\}$。\n\n为了证明 $HEAD_{COLLIDE}$ 是不可判定的，我们可以构造一个从 $HALT_{TM}$ 出发的映射归约。这需要定义一个可计算函数 $f$，它将任意给定的输入 $\\langle M, w \\rangle$ 转换为一个特定的 2-HTM 的描述，记作 $T = f(\\langle M, w \\rangle)$。这个转换必须满足映射归约的核心属性：$M$ 在输入 $w$ 上停机，当且仅当 $T$ 在空白纸带上启动后会发生读写头碰撞。\n\n下列哪个陈述提供了最有效和直接的策略，用于构造 2-HTM $T$，以正确实现归约 $HALT_{TM} \\le_m HEAD_{COLLIDE}$？\n\nA. 机器 $T$ 将其读写头 $H_1$ 和 $H_2$ 放置在纸带段的两端。$H_1$ 模拟 $M$ 在 $w$ 上的运行，而 $H_2$ 在模拟的每一步都向 $H_1$ 移动一步。当且仅当 $M$ 永远运行时，碰撞保证会发生。\n\nB. $T$ 的一个读写头（比如 $H_1$）用于在纸带的一个区域上执行对图灵机 $M$ 在输入 $w$ 上的模拟。另一个读写头 $H_2$ 保持静止于一个远离模拟区域的指定“目标”格子上。当且仅当对 $M$ 的模拟达到停机状态时，$T$ 进入一个特殊状态，在该状态下它指示 $H_1$ 移动到目标格子，从而引发碰撞。\n\nC. $T$ 的两个读写头 $H_1$ 和 $H_2$ 从同一个格子开始。$H_1$ 保持静止，而 $H_2$ 写入输入 $w$ 然后向右无限移动。对 $M$ 在 $w$ 上的模拟完全编码在 $T$ 的有限状态控制器中。碰撞在第一步就发生，使得是否属于 $HEAD_{COLLIDE}$ 变得平凡，且与 $M$ 的行为无关。\n\nD. 两个读写头 $H_1$ 和 $H_2$ 都用于模拟 $M$ 在 $w$ 上的计算。$H_1$ 模拟 $M$ 纸带的左半部分，$H_2$ 模拟右半部分。如果 $M$ 的计算需要其读写头从一半越过到另一半，读写头就会在纸带的中心点碰撞，这一事件被设计为对应于 $M$ 停机。\n\nE. 机器 $T$ 使用读写头 $H_1$ 模拟 $M$ 在 $w$ 上的运行。读写头 $H_2$完美地镜像 $H_1$ 的移动（例如，如果 $H_1$向左移动，$H_2$也向左移动），但在同一纸带上一个独立的、并行的符号轨道上进行。如果对 $M$ 的模拟停机，$T$ 进入一个清理阶段，将 $H_2$ 移动到 $H_1$ 的轨道上以引起碰撞。", "solution": "我们寻求一个可计算的映射 $f$，它将序偶 $\\langle M,w \\rangle$ 映射到双头单带图灵机 $T$ 的编码 $\\langle T \\rangle$，使得\n$$\n\\langle M,w \\rangle \\in HALT_{TM} \\iff \\langle T \\rangle \\in HEAD_{COLLIDE}.\n$$\n最直接的构造是让一个读写头模拟 $M$在 $w$ 上的运行，而将另一个读写头固定在一个指定的目标格子上。只有当模拟的计算停机时，我们才将模拟用的读写头移动到目标格子，以强制发生读写头碰撞。\n\n将此策略形式化：给定 $\\langle M,w \\rangle$，定义 $T=f(\\langle M,w \\rangle)$ 如下。\n\n1. 在空白纸带上进行初始化。$T$ 使用其两个读写头 $H_{1}$ 和 $H_{2}$ 执行一个有限的设置过程：\n- 选择一个指定的目标格子（例如，物理纸带位置 $0$）。在该格子上写入一个唯一的标记符号 $\\#$。将 $H_{2}$ 放置在这个目标格子上，并使其此后永远保持静止；这是通过转移函数始终为 $H_{2}$ 输出移动指令 $S$ 来强制执行的。\n- 选择一个与目标格子不相交的模拟区域。为了确保永远不相交，固定一个可计算的双射 $g:\\mathbb{Z}\\to\\mathbb{N}$，并将模拟的纸带格子 $i\\in\\mathbb{Z}$ 表示在物理纸带位置 $p(i)=-g(i)-1$ 上。因此，每个模拟的格子都存储在严格为负的物理位置上。将 $H_{1}$ 放置在模拟区域（例如，在 $p(0)$ 处），并确保位置为 $0$ 的目标格子永远不被模拟过程使用。\n\n2. 编码输入。对 $T$进行编程，使得 $H_{1}$ 将 $M$ 在输入 $w$ 上的模拟初始纸带写入模拟区域：对于与 $w$ 的每个符号相对应的 $i$，在 $p(i)$ 处写入该符号，并在其他地方写入空白符。这是一个有限的、可计算的初始化过程。\n\n3. 模拟阶段。当被模拟的机器 $M$ 尚未达到停机状态时，$T$ 使用 $H_{1}$ 来模拟 $M$ 的一步操作：\n- 在有限控制器中维护 $M$ 的当前模拟状态和当前模拟读写头索引 $i\\in\\mathbb{Z}$。\n- 为了读取或写入模拟格子 $i$，将 $H_{1}$ 移動到物理位置 $p(i)$，读取或写入存储在那里的符号，根据 $M$ 的转移函数更新模拟状态，并相应地将 $i$ 更新为 $i-1$、$i$ 或 $i+1$。因为 $p(i)$ 始终严格为负，所以 $H_{1}$ 在此模拟阶段永远不会访问位置 $0$ 处的目标格子。与此同时，$H_{2}$ 保持在目标格子上静止不动。\n\n4. 停机时碰撞阶段。当且仅当被模拟的 $M$ 进入停机状态时，$T$ 转换到一个特殊阶段，在此阶段它忽略模拟数据并反复将 $H_{1}$ 向右移动，直到它到达 $H_{2}$ 静止不动的位置 $0$ 处的目标格子。当 $H_{1}$ 第一次到达位置 $0$ 时，两个读写头占据同一个格子，即发生读写头碰撞。\n\n归约的正确性：\n- 如果 $M$ 在 $w$ 上停机，那么模拟阶段会在有限时间内达到一个停机的模拟状态，然后 $T$ 进入停机时碰撞阶段。在该阶段，$H_{1}$ 向右移动到目标格子并与 $H_{2}$ 碰撞。因此 $\\langle T \\rangle \\in HEAD_{COLLIDE}$。\n- 如果 $M$ 不在 $w$ 上停机，那么模拟阶段永远不会停止。在整个模拟过程中，$H_{1}$ 被限制在严格为负的位置，而 $H_{2}$ 保持在位置 $0$ 静止不动。因此永远不会发生碰撞，且 $\\langle T \\rangle \\notin HEAD_{COLLIDE}$。\n\n$f$ 的可计算性：给定 $\\langle M,w \\rangle$，$T$ 的描述可以通过将 $M$ 和 $w$ 硬编码到 $T$ 的有限控制器中，并使用固定的可计算函数 $g$ 来定位模拟格子来有效地生成。因此 $f$ 是可计算的，并且满足所要求的双向蕴含关系。\n\n因此，归约 $HALT_{TM} \\le_{m} HEAD_{COLLIDE}$ 通过上述策略得以实现，该策略与选项 B 相符。\n\n为什么其他选项失败或较差：\n- A 颠倒了条件（它表明碰撞发生当且仅当 $M$ 永远运行），这没有实现到 $HEAD_{COLLIDE}$ 所需的映射。\n- C 使碰撞立即发生且与 $M$ 和 $w$ 无关，从而无法产生归约。\n- D 将碰撞与读写头越过事件而不是停机联系起来，这通常不对应于 $M$ 停机。\n- E 可以被设计出来，但在单条纸带上的“独立轨道”方面引入了不必要的复杂性和模糊性；B 是直接、标准的构造，它清晰地强制实现了当且仅当停机时才发生碰撞。", "answer": "$$\\boxed{B}$$", "id": "1431410"}]}