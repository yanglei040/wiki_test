{"hands_on_practices": [{"introduction": "在理论计算机科学中，随机存取机（RAM）模型常常被简化到只包含最核心的指令集。这个练习将带你体验如何在一个缺少减法指令的极简RAM模型上，仅使用位运算和加法来实现减法。通过这个过程，你将能更深刻地理解计算机底层是如何利用二进制补码表示法来统一处理加减运算的。[@problem_id:1440626]", "problem": "考虑一个在理论计算机科学中用于分析算法的简化版随机存取机器（Random Access Machine, RAM）模型。该机器拥有一组寄存器 `R0, R1, R2, ...`，每个寄存器可以存储一个 $w$ 位整数。所有的算术运算都使用二进制补码表示法进行。\n\n该机器的指令集是有限的。它支持以下操作，其中 `Ri`、`Rj` 和 `Rk` 是任意寄存器，`k` 是一个整数常量：\n\n*   `ADD Ri, Rj, Rk`：计算寄存器 `Ri` 和 `Rj` 中值的和，并将结果存储在寄存器 `Rk` 中。此操作等效于 `Rk ← Ri + Rj`。\n*   `NOT Ri, Rj`：对寄存器 `Ri` 中的值执行按位非操作，并将结果存储在寄存器 `Rj` 中。此操作等效于 `Rj ← ~Ri`。\n*   `LOADC k, Ri`：将整数常量 `k` 加载到寄存器 `Ri` 中。此操作等效于 `Ri ← k`。\n*   `COPY Ri, Rj`：将寄存器 `Ri` 中的值复制到寄存器 `Rj` 中。此操作等效于 `Rj ← Ri`。\n\n值得注意的是，该机器缺少减法指令。你的任务是仅使用可用的指令来实现操作 `R1 ← R2 - R3`。你可以使用除 `R1`、`R2` 和 `R3` 之外的寄存器作为临时存储。\n\n以下哪个指令序列正确地计算了 `R2 - R3` 的值并将最终结果存储在 `R1` 中？\n\nA.\n1. `NOT R3, R4`\n2. `ADD R2, R4, R1`\n\nB.\n1. `LOADC 1, R4`\n2. `NOT R2, R5`\n3. `ADD R5, R4, R5`\n4. `ADD R3, R5, R1`\n\nC.\n1. `LOADC 1, R4`\n2. `ADD R3, R4, R5`\n3. `NOT R5, R5`\n4. `ADD R2, R5, R1`\n\nD.\n1. `LOADC 1, R4`\n2. `NOT R3, R5`\n3. `ADD R5, R4, R5`\n4. `ADD R2, R5, R1`", "solution": "目标：在一台使用 $w$ 位二进制补码的 RAM 上，仅用 ADD、NOT、LOADC、COPY 指令实现 $R1 \\leftarrow R2 - R3$。\n\n关键的二进制补码恒等式（所有算术运算均在模 $2^{w}$ 下进行）：\n$$-x = \\operatorname{NOT}(x) + 1,\\qquad \\operatorname{NOT}(x) = -x - 1.$$\n因此，\n$$R2 - R3 = R2 + (-R3) = R2 + \\big(\\operatorname{NOT}(R3) + 1\\big).$$\n所以正确的序列必须计算 $\\operatorname{NOT}(R3)$，然后加 $1$，最后再加 $R2$。\n\n逐一检查每个选项：\n\n选项 A：\n1. 执行 NOT 后，$R4 = \\operatorname{NOT}(R3) = -R3 - 1$。\n2. 然后 $R1 = R2 + R4 = R2 + \\operatorname{NOT}(R3) = R2 - R3 - 1$。\n这与目标值相差 $-1$，所以不正确。\n\n选项 B：\n1. $R4 = 1$。\n2. $R5 = \\operatorname{NOT}(R2) = -R2 - 1$。\n3. $R5 = R5 + R4 = (-R2 - 1) + 1 = -R2$。\n4. $R1 = R3 + R5 = R3 - R2$。\n这计算的是 $R3 - R2$，而不是 $R2 - R3$，所以不正确。\n\n选项 C：\n1. $R4 = 1$。\n2. $R5 = R3 + 1$。\n3. $R5 = \\operatorname{NOT}(R5) = -(R3 + 1) - 1 = -R3 - 2$。\n4. $R1 = R2 + R5 = R2 - R3 - 2$。\n这与目标值相差 $-2$，所以不正确。\n\n选项 D：\n1. $R4 = 1$。\n2. $R5 = \\operatorname{NOT}(R3) = -R3 - 1$。\n3. $R5 = R5 + R4 = (-R3 - 1) + 1 = -R3$。\n4. $R1 = R2 + R5 = R2 + (-R3) = R2 - R3$。\n这与目标完全匹配，所以正确。\n\n因此，正确的序列是选项 D。", "answer": "$$\\boxed{D}$$", "id": "1440626"}, {"introduction": "算法的核心在于逻辑和控制流。这个练习要求你在一个简单的RAM模型上，用最少的指令编写一个计算绝对值的程序。这不仅是对指令集熟悉度的考验，更是对如何用最基本的条件跳转指令（`JGTZ`）来构建高级编程语言中常见的 `if-then-else` 结构的实践。[@problem_id:1440594]", "problem": "一个简单的随机存取机 (RAM) 模型操作一组寄存器 `R1, R2, R3, ...`，这些寄存器可以存储整数值。一个程序是一系列从1开始编号的指令。该机器支持以下指令集：\n\n- `COPY Ri Rj`：将寄存器 `Ri` 中的整数复制到寄存器 `Rj`。\n- `ADD Ri Rj Rk`：计算 `Ri` 和 `Rj` 中整数的和，并将结果存储在 `Rk` 中 (`Rk ← Ri + Rj`)。\n- `SUB Ri Rj Rk`：通过从 `Ri` 中的整数减去 `Rj` 中的整数来计算差值，并将结果存储在 `Rk` 中 (`Rk ← Ri - Rj`)。\n- `JGTZ Ri L`：如果寄存器 `Ri` 中的整数严格大于0，则程序跳转到第 `L` 行。否则，它按顺序执行下一条指令。\n\n当指令指针移动到大于程序中总指令数的行号时，程序终止。\n\n假设初始时，一个任意整数 `x` 被放置在寄存器 `R1` 中。所有其他寄存器 (`R2`, `R3`, `...`) 都初始化为值 0。您的任务是确定一个最短的可能程序，该程序能确保在终止时，`x` 的绝对值（记为 `$|x|$`）存储在寄存器 `R1` 中，无论 `x` 的初始值是什么。\n\n这样的程序所需的最少指令数是多少？", "solution": "目标是为指定的随机存取机 (RAM) 模型编写一个程序，计算最初存储在寄存器 `R1` 中的整数 `x` 的绝对值。我们需要找到所需的最少指令数。\n\n绝对值 `$|x|$` 的定义是：\n- 如果 `x \\geq 0`，则 `$|x| = x$`。\n- 如果 `x  0`，则 `$|x| = -x$`。\n\n这个定义是条件性的。执行的操作取决于 `x` 的符号。因此，我们的程序必须实现这种条件逻辑。在我们的 RAM 模型中，唯一可用的条件指令是 `JGTZ Ri L`，意为“如果大于零则跳转”。这条指令可以区分正数 (`x > 0`) 和非正数 (`x \\leq 0`)。\n\n让我们基于应用于 `R1`（其中存有 `x`）的 `JGTZ` 指令来分析各种情况。\n\n**情况 1: `x > 0`**\n在这种情况下，`$|x| = x$`。`R1` 中的值已经是正确的。程序不应对 `R1` 做任何操作。`JGTZ R1 L` 指令将触发一个跳转。我们可以利用这个跳转来跳过任何会修改 `R1` 的指令。\n\n**情况 2: `x \\leq 0`**\n在这种情况下，`JGTZ R1 L` 不会引起跳转，程序将继续执行下一条指令。\n- 如果 `x = 0`，则 `$|x| = 0$`。`R1` 中的值已经是正确的。\n- 如果 `x  0`，则 `$|x| = -x$`。程序必须计算 `-x` 并将其存储在 `R1` 中。\n\n操作 `-x` 可以表示为 `0 - x`。根据问题描述，除 `R1` 外的所有寄存器都初始化为 0。我们可以使用任何其他寄存器，比如 `R2`，它初始值为 0。减法 `0 - x` 可以用指令 `SUB R2 R1 R1` 来实现。这条指令计算 `R2 - R1` 并将结果存储在 `R1` 中。由于 `R2` 是 0 而 `R1` 是 `x`，这将导致 `R1` 的新值为 `0 - x`，即 `-x`。\n\n注意，如果 `x` 是 0，`SUB R2 R1 R1` 将计算 `R1 ← 0 - 0 = 0`，这对于 `$|0|$` 也是正确的。所以，单条指令 `SUB R2 R1 R1` 正确地处理了所有非正数情况 (`x \\leq 0`)。\n\n现在我们可以构建一个程序。我们需要一个条件跳转来处理 `x > 0` 的情况，以及一个减法来处理 `x \\leq 0` 的情况。\n\n让我们尝试构建最短的可能程序。\n我们能用 1 条指令完成吗？\n- 一条 `SUB`、`ADD` 或 `COPY` 指令会无条件执行。例如，`SUB R2 R1 R1` 会错误地将 `x=5` 变为 `-5`。\n- 一条 `JGTZ` 指令只改变程序流程；它不修改 `R1` 中的数据。\n因此，单条指令是不够的。\n\n让我们尝试构建一个 2 指令的程序。\n我们需要第一条指令是条件跳转。如果 `x > 0`，我们希望跳过下一条指令并终止。如果程序跳转到大于总指令数的行号，程序就会终止。对于一个 2 指令的程序，跳转到第 3 行将导致终止。\n\n考虑以下程序：\n1. `JGTZ R1 3`\n2. `SUB R2 R1 R1`\n\n让我们针对 `x` 的三种可能性来追踪其执行过程：\n\n- **如果 `x > 0` (例如, `x = 5`):**\n  - 第 1 行: 执行 `JGTZ R1 3`。因为 `R1 > 0`，程序跳转到第 3 行。\n  - 因为没有第 3 行，程序终止。\n  - `R1` 中的值保持为 `x`。最终值为 `x`，即 `$|x|$`。这是正确的。\n\n- **如果 `x  0` (例如, `x = -5`):**\n  - 第 1 行: 执行 `JGTZ R1 3`。因为 `R1` 不大于 0，不执行跳转。\n  - 第 2 行: 执行 `SUB R2 R1 R1`。`R1` 得到 `R2 - R1`。初始时，`R2=0` 且 `R1=x`。所以 `R1` 变为 `0 - x = -x`。对于 `x=-5`，`R1` 变为 `5`。\n  - 程序然后试图继续执行第 3 行。因为没有第 3 行，它终止了。\n  - `R1` 中的最终值是 `-x`，即 `$|x|$`。这是正确的。\n\n- **如果 `x = 0`:**\n  - 第 1 行: 执行 `JGTZ R1 3`。因为 `R1` 不大于 0，不执行跳转。\n  - 第 2 行: 执行 `SUB R2 R1 R1`。`R1` 得到 `R2 - R1`，即 `0 - 0 = 0`。\n  - 程序终止。\n  - `R1` 中的最终值是 `0`，即 `$|0|$`。这是正确的。\n\n这个 2 指令的程序正确地计算了任何整数 `x` 的绝对值。由于我们已经论证了 1 条指令是不够的，因此所需的最少指令数是 2。", "answer": "$$\\boxed{2}$$", "id": "1440594"}, {"introduction": "对内存和调用栈的精确理解是编写安全、可靠软件的基石。这个练习模拟了一个经典的“栈溢出”场景，你将通过追踪一段有缺陷的代码，亲眼见证一个简单的数组越界写操作如何覆盖函数的返回地址，从而劫持程序的执行流程。这个实践将揭示抽象的RAM模型与现实世界中软件安全问题之间深刻的联系。[@problem_id:1440630]", "problem": "考虑一个假设的随机存取存储器（RAM）模型，它具有为理论分析而设计的简化架构。该机器具有以下规格：\n\n**架构:**\n*   **内存:** 一个字节可寻址的内存数组 `M`，从 0 开始索引。对于本问题，假设每个整数值占用一个内存地址。\n*   **寄存器:** 四个通用整数寄存器 `r0, r1, r2, r3`。\n*   **特殊寄存器:** 一个程序计数器（`PC`），用于存放下一条要执行指令的地址；以及一个栈指针（`SP`），指向栈顶元素。\n*   **栈:** 栈向下增长，即从高内存地址向低内存地址增长。`SP` 寄存器始终指向最近压入栈的值所在的内存地址。\n\n**指令集:**\n*   `CONST r_i, val`: 将整数常量 `val` 赋值给寄存器 `r_i`。\n*   `MOV r_i, r_j`: 将寄存器 `r_j` 的值复制到 `r_i`。\n*   `ADD r_i, r_j, r_k`: 计算 `r_j + r_k` 并将结果存储在 `r_i` 中。\n*   `SUB r_i, r_j, r_k`: 计算 `r_j - r_k` 并将结果存储在 `r_i` 中。\n*   `LOAD r_i, r_j`: 从 `r_j` 指定的内存地址加载值到 `r_i`。（`r_i ← M[r_j]`）。\n*   `STORE r_i, r_j`: 将寄存器 `r_j` 的值存储到 `r_i` 指定的内存地址。（`M[r_i] ← r_j`）。\n*   `CALL addr`: 将返回地址（`PC+1`）压入栈中（`SP` 减一，然后设置 `M[SP] ← PC+1`），然后跳转到 `addr`（设置 `PC ← addr`）。\n*   `RET`: 从栈中弹出返回地址到 `PC`（设置 `PC ← M[SP]`，然后 `SP` 加一）。\n*   `PUSH r_i`: 将 `r_i` 的值压入栈中（`SP` 减一，然后设置 `M[SP] ← r_i`）。\n*   `POP r_i`: 从栈顶弹出一个值到 `r_i`（设置 `r_i ← M[SP]`，然后 `SP` 加一）。\n*   `HALT`: 终止程序执行。\n\n**场景:**\n一个程序被加载到机器的内存中。机器的初始状态如下：\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0 = 0`, `r1 = 0`, `r2 = 0`, `r3 = 0`\n*   所有其他内存位置均初始化为 0。\n\n存储在内存中的程序代码如下：\n\n```\n// Main function\n100: CALL 200\n101: HALT\n\n// Subroutine\n200: PUSH r1         // Function prologue: save caller's context\n201: MOV r1, SP      // Use r1 as a frame pointer\n202: CONST r2, 3\n203: SUB SP, SP, r2  // Allocate a 3-element buffer on the stack\n204: CONST r2, 4     // Buggy index for buffer access\n205: CONST r3, 300   // Value to write\n206: ADD r0, SP, r2  // Calculate target address: base of buffer + index\n207: STORE r0, r3    // Write value to calculated address\n208: MOV SP, r1      // Function epilogue: deallocate buffer\n209: POP r1          // Restore caller's context\n210: RET             // Return to caller\n\n// Unrelated code block\n300: CONST r0, 999\n301: HALT\n```\n\n从初始状态开始跟踪该程序的执行。当 `HALT` 指令被执行时，寄存器 `r0` 中存储的值是多少？", "solution": "我们将逐步跟踪程序的执行，记录程序计数器（`PC`）、栈指针（`SP`）、相关寄存器（`r0`、`r1`、`r2`、`r3`）和关键内存位置的状态。\n\n**初始状态:**\n*   `PC = 100`\n*   `SP = 1024`\n*   `r0=0, r1=0, r2=0, r3=0`\n\n**执行跟踪:**\n\n**1. `MAIN` 函数执行:**\n*   `PC=100`: `CALL 200`\n    *   `CALL` 指令首先将返回地址（`PC+1 = 101`）压入栈中。\n    *   `SP` 减一：`SP = 1024 - 1 = 1023`。\n    *   返回地址被存储：`M[1023] = 101`。\n    *   `PC` 被设置为子程序的地址：`PC = 200`。\n*   **状态:** `PC=200`, `SP=1023`, `M[1023]=101`。\n\n**2. `SUB` 函数序言:**\n*   `PC=200`: `PUSH r1`\n    *   `SP` 減一：`SP = 1023 - 1 = 1022`。\n    *   `r1` 的值（为0）被存储：`M[1022] = 0`。\n*   `PC=201`: `MOV r1, SP`\n    *   `SP` 的值（1022）被复制到 `r1`。`r1` 现在将作为此函数调用的帧指针。`r1 = 1022`。\n*   `PC=202`: `CONST r2, 3`\n    *   寄存器 `r2` 被设置为 3。`r2 = 3`。\n*   `PC=203`: `SUB SP, SP, r2`\n    *   `SP` 被更新：`SP = SP - r2 = 1022 - 3 = 1019`。这会在栈上分配一个包含3个元素的缓冲区。\n*   **序言结束后的栈布局:**\n    *   `SP = 1019`。\n    *   缓冲区：`M[1019]`, `M[1020]`, `M[1021]`。\n    *   保存的 `r1`：`M[1022]`（位于 `r1`，即帧指针处）。\n    *   返回地址：`M[1023]`（位于 `r1+1` 处）。\n*   **状态:** `PC=204`, `SP=1019`, `r1=1022`, `r2=3`, `M[1022]=0`, `M[1023]=101`。\n\n**3. `SUB` 函数体（溢出）:**\n*   `PC=204`: `CONST r2, 4`\n    *   寄存器 `r2` 被覆写为值 4。这是有问题的索引。`r2 = 4`。\n*   `PC=205`: `CONST r3, 300`\n    *   寄存器 `r3` 被设置为 300。这是将要写入的值。`r3 = 300`。\n*   `PC=206`: `ADD r0, SP, r2`\n    *   计算目标内存地址。代码意图访问缓冲区中的一个元素，该缓冲区的基地址是 `SP`。\n    *   `r0 = SP + r2 = 1019 + 4 = 1023`。\n*   `PC=207`: `STORE r0, r3`\n    *   `r3` 的值（300）被存储到 `r0` 指定的内存地址（1023）。\n    *   `M[1023] = 300`。\n    *   **关键在于，这条指令用新值 `300` 覆盖了存储在 `M[1023]` 的原始返回地址（`101`）。**\n*   **状态:** `PC=208`, `r0=1023`, `r3=300`, `M[1023]=300`。\n\n**4. `SUB` 函数尾声与 `RET`:**\n*   `PC=208`: `MOV SP, r1`\n    *   `SP`被重置为帧指针的值，从而释放局部缓冲区。`SP = r1 = 1022`。\n*   `PC=209`: `POP r1`\n    *   从栈中恢复 `r1` 的保存值。\n    *   `r1 = M[SP] = M[1022] = 0`。\n    *   `SP` 加一：`SP = 1022 + 1 = 1023`。\n*   `PC=210`: `RET`\n    *   `RET` 指令从栈顶弹出返回地址到 `PC`。\n    *   `PC = M[SP] = M[1023]`。\n    *   由于第3步中的覆盖操作，`M[1023]` 的值是 `300`。\n    *   因此，`PC = 300`。\n    *   `SP` 加一：`SP = 1023 + 1 = 1024`。\n*   **状态:** 控制流已被劫持。程序没有返回到地址 `101`，而是跳转到了地址 `300`。`PC=300`, `SP=1024`, `r1=0`。\n\n**5. 被劫持的代码执行:**\n*   `PC=300`: `CONST r0, 999`\n    *   值 `999` 被賦值给寄存器 `r0`。`r0 = 999`。\n*   `PC=301`: `HALT`\n    *   程序终止。\n\n**结论:**\n在程序终止时，寄存器 `r0` 中的最终值为 999。", "answer": "$$\\boxed{999}$$", "id": "1440630"}]}