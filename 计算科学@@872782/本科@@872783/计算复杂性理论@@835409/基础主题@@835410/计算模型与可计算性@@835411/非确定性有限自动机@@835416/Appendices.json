{"hands_on_practices": [{"introduction": "理解非确定性有限自动机（NFA）如何处理输入字符串是掌握其概念的第一步。与确定性有限自动机（DFA）不同，NFA可以同时处于多个状态，这个练习将帮助你追踪这种并行执行的过程，特别是包含无需消耗输入符号即可进行状态转换的 $\\epsilon$-转移。通过这个练习 [@problem_id:1388210]，你将学会计算NFA在读取输入后所有可能达到的状态集合。", "problem": "一位计算机科学家正在设计一个基于非确定性有限自动机 (NFA) 的简单词法分析工具，用于检测二进制数据流中的特定模式。该 NFA 形式化定义如下，包含以下组成部分：\n- 状态集合 $Q = \\{q_0, q_1, q_2, q_3\\}$。\n- 输入字母表 $\\Sigma = \\{0, 1\\}$。\n- 起始状态 $q_{start} = q_0$。\n- 接受状态集合 $F = \\{q_3\\}$。\n\n转移函数 $\\delta: Q \\times (\\Sigma \\cup \\{\\epsilon\\}) \\to \\mathcal{P}(Q)$，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集，$\\epsilon$ 表示空字符串，由以下规则表给出。请注意，如果某个状态-输入对未在表中列出，则其转移指向空集 $\\emptyset$。\n\n- $\\delta(q_0, 0) = \\{q_0\\}$\n- $\\delta(q_0, 1) = \\{q_0, q_1\\}$\n- $\\delta(q_1, 0) = \\{q_2\\}$\n- $\\delta(q_1, \\epsilon) = \\{q_2\\}$\n- $\\delta(q_2, 1) = \\{q_3\\}$\n- $\\delta(q_3, 0) = \\{q_3\\}$\n- $\\delta(q_3, 1) = \\{q_3\\}$\n\n给定输入字符串 `101`，请确定在处理完整个字符串后，该自动机可能处于的所有可能状态的集合。请从以下选项中选择正确的集合。\n\nA. $\\{q_0, q_1, q_3\\}$\n\nB. $\\{q_0, q_1, q_2, q_3\\}$\n\nC. $\\{q_3\\}$\n\nD. $\\{q_0, q_2\\}$\n\nE. $\\{q_0, q_1, q_2\\}$", "solution": "对于一个带有 $\\epsilon$-转移的 NFA，在每一步中，我们首先计算当前状态集的 $\\epsilon$-闭包，然后根据输入符号进行转移，最后再次计算所得状态集的 $\\epsilon$-闭包。令 $\\text{E}(S)$ 表示集合 $S$ 的 $\\epsilon$-闭包。未指定的转移指向空集。\n\n初始闭包：\n$$\nS_{0}=\\text{E}(\\{q_{0}\\})=\\{q_{0}\\}\n$$\n\n读取第一个符号 $1$ 后：\n$$\nT_{1}=\\bigcup_{q\\in S_{0}}\\delta(q,1)=\\delta(q_{0},1)=\\{q_{0},q_{1}\\}\n$$\n$$\nS_{1}=\\text{E}(T_{1})=\\{q_{0},q_{1}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2}\\}\n$$\n\n读取第二个符号 $0$ 后：\n$$\nT_{2}=\\bigcup_{q\\in S_{1}}\\delta(q,0)=\\delta(q_{0},0)\\cup\\delta(q_{1},0)\\cup\\delta(q_{2},0)=\\{q_{0}\\}\\cup\\{q_{2}\\}\\cup\\emptyset=\\{q_{0},q_{2}\\}\n$$\n$$\nS_{2}=\\text{E}(T_{2})=\\{q_{0},q_{2}\\}\n$$\n\n读取第三个符号 $1$ 后：\n$$\nT_{3}=\\bigcup_{q\\in S_{2}}\\delta(q,1)=\\delta(q_{0},1)\\cup\\delta(q_{2},1)=\\{q_{0},q_{1}\\}\\cup\\{q_{3}\\}=\\{q_{0},q_{1},q_{3}\\}\n$$\n$$\nS_{3}=\\text{E}(T_{3})=\\{q_{0},q_{1},q_{3}\\}\\cup\\delta(q_{1},\\epsilon)=\\{q_{0},q_{1},q_{2},q_{3}\\}\n$$\n\n因此，在处理完整个字符串 $101$ 后，可能的状态集合是 $\\{q_{0},q_{1},q_{2},q_{3}\\}$，这对应于选项 B。", "answer": "$$\\boxed{B}$$", "id": "1388210"}, {"introduction": "在学会了如何追踪NFA的运行后，下一步便是亲手构建一个。这个练习 [@problem_id:1388241] 提出了一个经典的设计挑战：识别所有以特定子串结尾的字符串。它完美地展示了“非确定性”的核心优势，即自动机能够“猜测”某个字符可能是我们所寻找的结尾模式的开始，从而极大地简化了设计。", "problem": "在理论计算机科学领域，非确定性有限自动机（NFA）是一种用于识别文本字符串中模式的计算模型。一个 NFA 由一个 5-元组 $M = (Q, \\Sigma, \\delta, q_0, F)$ 形式化定义，其中：\n- $Q$ 是一个有限的状态集合。\n- $\\Sigma$ 是一个有限的输入符号集合，称为字母表。\n- $\\delta: Q \\times \\Sigma \\to \\mathcal{P}(Q)$ 是转移函数，其中 $\\mathcal{P}(Q)$ 是 $Q$ 的幂集。\n- $q_0 \\in Q$ 是起始状态。\n- $F \\subseteq Q$ 是最终（或接受）状态的集合。\n\n如果从 $q_0$ 开始，在处理完整个字符串后，存在至少一个转移序列能够导向 $F$ 中的一个状态，那么这个 NFA 就接受该字符串。\n\n考虑语言 $L$，它由字母表 $\\Sigma = \\{a, b\\}$ 上所有以子串 'ab' 结尾的字符串组成。以下哪个形式化描述正确地表示了一个恰好接受语言 $L$ 的 NFA？在所有选项中，状态集合为 $Q=\\{q_0, q_1, q_2\\}$，字母表为 $\\Sigma = \\{a, b\\}$，起始状态为 $q_0$。未明确定义的转移被假定映射到空集 $\\emptyset$。\n\nA. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nB. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n\nC. $F = \\{q_2\\}$，且转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$\n   - $\\delta(q_2, a) = \\{q_2\\}$\n   - $\\delta(q_2, b) = \\{q_2\\}$\n\nD. $F = \\{q_0, q_2\\}$，且转移函数 $\\delta$ 定义如下：\n   - $\\delta(q_0, a) = \\{q_0, q_1\\}$\n   - $\\delta(q_0, b) = \\{q_0\\}$\n   - $\\delta(q_1, b) = \\{q_2\\}$", "solution": "问题要求我们找出一个非确定性有限自动机（NFA），该自动机接受所有在字母表 $\\Sigma = \\{a, b\\}$ 上以子串 'ab' 结尾的字符串所构成的语言 $L$。让我们分析这个语言的特性，然后评估每个选项。\n\n语言 $L$ 包括像 \"ab\"、\"aab\"、\"bab\" 和 \"abbab\" 这样的字符串。它不包括像空字符串 $\\epsilon$、\"a\"、\"b\"、\"ba\" 或 \"aba\" 这样的字符串。用于此语言的 NFA 必须能够处理任意前缀，然后识别出结尾的 'ab' 序列。\n\n我们来逐一分析每个选项：\n\n**选项 A 分析：**\n- $Q = \\{q_0, q_1, q_2\\}$，起始状态 $q_0$， $F = \\{q_2\\}$。\n- 转移：$\\delta(q_0, a) = \\{q_0, q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n\n这个 NFA 的逻辑可以解释如下：\n- 状态 $q_0$ 是初始状态，也是一个“搜索”状态。它消耗任意的 'a' 和 'b' 序列。循环 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$ 允许自动机在处理任何前缀时保持在该状态。\n- 转移 $\\delta(q_0, a) \\ni q_1$ 是非确定性的。当 NFA 在状态 $q_0$ 读取一个 'a' 时，它可以“猜测”这个 'a' 可能是期望的 \"ab\" 后缀的开始。它会生成一条新的计算路径，转移到状态 $q_1$。\n- 状态 $q_1$ 代表了这样一个假设：看到的最后一个字符是 \"ab\" 中的 'a'。\n- 如果下一个字符是 'b'，转移 $\\delta(q_1, b) = \\{q_2\\}$ 将这条路径带到最终状态 $q_2$。如果字符串在此结束，它就被接受。\n- 如果在状态 $q_1$ 读取任何其他字符（例如 'a'），或者在状态 $q_2$ 读取任何字符，该路径会因为没有定义的转移而终止。\n\n让我们用一些字符串来测试这个 NFA：\n- 字符串 \"aab\"：\n    1. 从 $q_0$ 开始。读取 'a'。$\\delta(q_0, a) = \\{q_0, q_1\\}$。NFA 现在处于状态集合 $\\{q_0, q_1\\}$ 中。\n    2. 读取 'a'。从 $q_0$ 出发，$\\delta(q_0, a) = \\{q_0, q_1\\}$。从 $q_1$ 出发，$\\delta(q_1, a) = \\emptyset$。结果状态的并集是 $\\{q_0, q_1\\} \\cup \\emptyset = \\{q_0, q_1\\}$。NFA 处于状态 $\\{q_0, q_1\\}$。\n    3. 读取 'b'。从 $q_0$ 出发，$\\delta(q_0, b) = \\{q_0\\}$。从 $q_1$ 出发，$\\delta(q_1, b) = \\{q_2\\}$。结果状态的并集是 $\\{q_0\\} \\cup \\{q_2\\} = \\{q_0, q_2\\}$。\n    4. 字符串结束。最终的状态集合是 $\\{q_0, q_2\\}$。因为这个集合包含一个最终状态（$q_2 \\in F$），所以字符串 \"aab\" 被接受。正确。\n- 字符串 \"aba\"：\n    1. 从 $q_0$ 开始。读取 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读取 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读取 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\emptyset$。状态为 $\\{q_0, q_1\\}$。\n    4. 字符串结束。最终的状态集合是 $\\{q_0, q_1\\}$。这个集合不包含任何来自 $F$ 的状态。字符串 \"aba\" 被拒绝。正确。\n这个构造正确地接受所有以 \"ab\" 结尾的字符串，并拒绝所有其他字符串。因此，选项 A 是正确答案。\n\n**选项 B 分析：**\n- $F = \\{q_2\\}$，$\\delta(q_0, a) = \\{q_1\\}$，$\\delta(q_0, b) = \\{q_0\\}$，$\\delta(q_1, b) = \\{q_2\\}$。\n这个 NFA 在其转移上是确定性的（每个都映射到单元素集或空集）。问题在于转移 $\\delta(q_0, a) = \\{q_1\\}$。一旦读取一个 'a'，自动机必须转移到 $q_1$ 并且永远不能返回到 $q_0$。\n- 让我们测试 \"aab\"。从 $q_0$ 开始。读取 'a'。转到 $q_1$。读取 'a'。$\\delta(q_1, a) = \\emptyset$。计算路径在没有到达最终状态的情况下中止。\"aab\" 字符串被拒绝，但它应该被接受。因此，选项 B 是不正确的。这个 NFA 只接受形式为 $b^k ab$（其中 $k \\ge 0$）的字符串。\n\n**选项 C 分析：**\n- $F = \\{q_2\\}$。这个 NFA 与 A 相似，但在最终状态 $q_2$ 上增加了自循环：$\\delta(q_2, a) = \\{q_2\\}$ 和 $\\delta(q_2, b) = \\{q_2\\}$。\n这些循环意味着一旦自动机到达最终状态 $q_2$（即，一旦它看到了一个 \"ab\" 子串），无论后面跟什么字符，它都将保持在该最终状态。\n- 让我们测试 \"aba\"。\n    1. 从 $q_0$ 开始。读取 'a'。状态为 $\\{q_0, q_1\\}$。\n    2. 读取 'b'。从 $q_0 \\to \\{q_0\\}$，从 $q_1 \\to \\{q_2\\}$。状态为 $\\{q_0, q_2\\}$。\n    3. 读取 'a'。从 $q_0 \\to \\{q_0, q_1\\}$，从 $q_2 \\to \\{q_2\\}$。状态为 $\\{q_0, q_1, q_2\\}$。\n    4. 字符串结束。最终的状态集合包含 $q_2 \\in F$。字符串 \"aba\" 被接受。这是不正确的，因为 \"aba\" 并不以 \"ab\" 结尾。这个 NFA 接受任何*包含* \"ab\"作为子串的字符串。因此，选项 C 是不正确的。\n\n**选项 D 分析：**\n- $F = \\{q_0, q_2\\}$。这个 NFA 的转移与选项 A 中正确的 NFA 相同，但最终状态的集合不同。在这里，起始状态 $q_0$ 也是一个最终状态。\n因为 $q_0$ 是一个最终状态，所以空字符串 $\\epsilon$ 会被接受，这是不正确的。此外，考虑转移 $\\delta(q_0, a) \\ni q_0$ 和 $\\delta(q_0, b) = \\{q_0\\}$。对于*任何*输入字符串，都存在一条仅停留在状态 $q_0$ 的路径。由于 $q_0$ 是一个接受状态，这条路径将导致该字符串被接受。例如，对于字符串 \"b\"，自动机可以遵循路径 $q_0 \\xrightarrow{b} q_0$，在最终状态结束。所以 \"b\" 被接受了。这是不正确的。这个 NFA 接受 $\\Sigma^*$ 中的所有字符串。因此，选项 D 是不正确的。\n\n基于以上分析，只有选项 A 正确地描述了用于指定语言的 NFA。", "answer": "$$\\boxed{A}$$", "id": "1388241"}, {"introduction": "这个实践将展示NFA相对于DFA的强大之处，特别是处理那些需要“向后看”的语言。对于“倒数第k个字符是1”这样的模式，DFA需要记住大量的历史信息，而NFA则可以优雅地通过非确定性来“猜测”这个关键字符的位置。通过构建这个自动机 [@problem_id:1432804]，你将深刻体会到NFA在解决某些特定问题时简洁而高效的特点。", "problem": "在设计简单的网络包过滤器时，一项常见的任务是检查数据流中的特定模式以对传入数据进行分类。考虑一个简化模型，其中过滤器处理器监视一个二进制数据流。如果一个数据包（表示为二进制字符串）的倒数第三位是 '1'，则处理器必须升起一个标志。从数据流开始到当前点的任何比特序列都可以被视为一个数据包。\n\n设语言 $L$ 是字母表 $\\Sigma = \\{0, 1\\}$ 上所有二进制字符串的集合，其中倒数第三个符号是 '1'。例如，字符串 `10110` 属于 $L$，因为它的倒数第三个符号是 '1'，但 `10010` 不属于 $L$。\n\n识别语言 $L$ 的非确定性有限自动机（NFA）所需的最少状态数是多少？\n\nA. 3\nB. 4\nC. 5\nD. 8", "solution": "我们将语言形式化为 $L = \\{\\, u 1 a b \\mid u \\in \\{0,1\\}^{*},\\, a \\in \\{0,1\\},\\, b \\in \\{0,1\\} \\,\\}$，即倒数第三个符号是 $1$ 的二进制字符串集合。等价地，对于 $w \\in \\{0,1\\}^{*}$，$w \\in L$ 当且仅当 $|w| \\geq 3$ 且 $w$ 的第 $(|w|-2)$ 个符号等于 $1$。\n\n上界（存在一个4状态的NFA）：构造一个NFA，其状态集为 $\\{q_{0}, q_{1}, q_{2}, q_{3}\\}$，起始状态为 $q_{0}$，接受状态为 $q_{3}$，转移如下：\n- 从 $q_{0}$ 接收输入 $0$ 到达 $q_{0}$；接收输入 $1$ 到达 $q_{0}$ 和 $q_{1}$。这非确定性地猜测所看到的 $1$ 是倒数第三个符号。\n- 从 $q_{1}$ 接收输入 $0$ 或 $1$ 到达 $q_{2}$。\n- 从 $q_{2}$ 接收输入 $0$ 或 $1$ 到达 $q_{3}$。\n- $q_{3}$ 没有出边。\n当输入结束时恰好处于 $q_{3}$ 状态即为接受。如果一个字符串 $w$ 的倒数第三个位置恰好是 $1$，那么存在一个运行路径，在读取那个 $1$ 时从 $q_{0}$ 转移到 $q_{1}$，然后恰好消耗两个符号到达 $q_{3}$，因此接受该字符串。如果 $w \\notin L$，那么没有路径可以在猜测一个 $1$ 之后，后面恰好还剩两个符号；因此没有路径可以在输入结束时停在 $q_{3}$。因此4个状态足够了。\n\n下界（至少需要4个状态）：我们使用NFA的扩展愚弄集方法。如果对于所有 $(x,y) \\in S$，都有 $xy \\in L$，并且对于 $S$ 中任意两个不同的元素 $(x_{1},y_{1})$ 和 $(x_{2},y_{2})$，至少有一个 $x_{1}y_{2}$ 或 $x_{2}y_{1}$ 不在 $L$ 中，那么集合 $S \\subseteq \\Sigma^{*} \\times \\Sigma^{*}$ 是 $L$ 的一个扩展愚弄集。任何识别 $L$ 的NFA必须至少有 $|S|$ 个状态。\n\n定义\n$$\nS \\;=\\; \\{\\, (\\epsilon,\\, 1 0 0),\\; (1,\\, 0 0),\\; (1 0,\\, 0),\\; (1 0 0,\\, \\epsilon) \\,\\}.\n$$\n对于 $S$ 中的每个 $(x,y)$，$xy = 1 0 0 \\in L$，因为它的倒数第三个符号是 $1$。对于不同的配对，至少有一个交叉连接产生的字符串长度小于3，因此不在 $L$ 中（根据定义，长度 $|w|<3$ 的字符串没有倒数第三个符号，因此不在 $L$ 中）。具体来说：\n- $\\epsilon \\cdot 0 0 = 0 0$，$1 \\cdot 0 = 1 0$，$1 0 \\cdot \\epsilon = 1 0$，以及 $\\epsilon \\cdot \\epsilon = \\epsilon$ 的长度都小于3，因此不在 $L$ 中。\n因此，$S$ 是一个大小为4的扩展愚弄集，这意味着任何识别 $L$ 的NFA都至少需要4个状态。\n\n结合上界和下界，识别 $L$ 的NFA所需的最少状态数为4，对应于选项B。", "answer": "$$\\boxed{B}$$", "id": "1432804"}]}