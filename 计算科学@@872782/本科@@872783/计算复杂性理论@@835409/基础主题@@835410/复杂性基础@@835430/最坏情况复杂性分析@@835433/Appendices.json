{"hands_on_practices": [{"introduction": "我们从一个常见的编程任务开始：寻找两个集合的交集。这个练习探讨了使用嵌套循环的最直接方法。通过分析这个简单的算法，你将练习当运行时间依赖于多个输入的大小时，如何确定其最坏情况下的复杂度，这是一个基础且重要的技能 [@problem_id:1469548]。", "problem": "一位程序员的任务是为电子商务平台开发一项功能。该功能需要识别用户愿望清单中的哪些商品正在打折。愿望清单由一个包含唯一整数产品ID的数组表示，我们称之为 `wishlist`，其大小为 $m$。打折商品列表由第二个包含唯一整数产品ID的数组 `saleItems` 表示，其大小为 $n$。\n\n为了找到共同的商品，该程序员实现了一个直接的算法。该算法遍历 `wishlist` 数组中的每个产品ID。对于愿望清单中的每个产品ID，它会接着遍历 `saleItems` 数组中的每个产品ID以检查是否匹配。\n\n该算法的最坏情况时间复杂度是多少，用大O表示法表示，并作为数组大小 $m$ 和 $n$ 的函数？\n\nA. $O(m + n)$\n\nB. $O(m \\log n + n \\log m)$\n\nC. $O(mn)$\n\nD. $O(\\max(m, n))$\n\nE. $O(\\min(m, n))$", "solution": "让外层循环遍历 `wishlist` 数组的 $m$ 个元素，对于每个元素，内层循环扫描 `saleItems` 数组的所有 $n$ 个元素以检查是否匹配。\n\n假设每次比较和循环开销花费常数时间 $c > 0$。那么，在最坏情况下（即没有提前终止，并且每个内层循环都扫描所有 $n$ 个项目），常数时间操作的总数是\n$$\nT(m,n) = \\sum_{i=1}^{m} \\sum_{j=1}^{n} c = c \\sum_{i=1}^{m} \\left( \\sum_{j=1}^{n} 1 \\right) = c \\sum_{i=1}^{m} n = c m n.\n$$\n因此，在渐近意义上，\n$$\nT(m,n) \\in O(mn).\n$$\n在所描述的算法中，没有预处理或辅助数据结构会改变这个界限，并且ID的唯一性也不会减少每次外层迭代的最坏情况比较次数。\n\n因此，最坏情况时间复杂度是 $O(mn)$，对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1469548"}, {"introduction": "并非所有算法都是简单的循环；许多算法采用巧妙的策略来提高性能。这个问题 [@problem_id:1469569] 挑战你分析一种“跳跃扫描”搜索算法，它将大步跳跃与线性扫描相结合。确定其最坏情况下的复杂度，需要你仔细考虑其不同阶段之间的相互作用，并找出需要最多计算工作的场景。", "problem": "一位程序员正在设计一种名为“跳跃扫描搜索”（Skip-Scan Search）的自定义搜索算法，用于在一个包含 `n` 个不同元素的大型、已排序数组 `A` 中查找目标值 `x`。该数组为 0 索引，意即其元素为 `A[0], A[1], ..., A[n-1]`。该算法的行为由一个整数步长 `k` 决定，其中 $1  k  n$。\n\n“跳跃扫描搜索”算法分两个连续的阶段运行：\n\n1.  **跳跃阶段：** 算法首先检查索引为 `k-1` 的元素。如果该元素小于 `x`，它将向前“跳跃”以检查索引为 `2k-1` 的元素。这个过程会持续进行，算法会依次检查索引为 `j \\cdot k - 1`（其中 `j = 1, 2, 3, \\ldots`）的元素，只要索引 `j \\cdot k - 1` 在数组边界内（即小于 `n`）并且元素 `A[j \\cdot k - 1]` 小于目标值 `x`。\n\n2.  **扫描阶段：** 当在某个步骤 `j`，元素 `A[j \\cdot k - 1]` 大于或等于 `x`，或者索引 `j \\cdot k - 1` 不再小于 `n` 时，跳跃阶段终止。\n    *   如果跳跃阶段因 `A[j \\cdot k - 1] \\ge x` 而停止，算法将从索引 `(j-1) \\cdot k` 开始对元素块进行线性扫描。\n    *   如果跳跃阶段因检查了所有可能的跳跃点（直到索引 `m \\cdot k - 1`，其中 `(m+1) \\cdot k - 1 \\ge n`）且发现它们都小于 `x` 而停止，算法将从索引 `m \\cdot k` 开始对数组的最后一段进行线性扫描。\n    线性扫描将持续进行，直到找到元素 `x` 或该块被完全扫描。为提高效率，在跳跃阶段已检查过的任何元素都不会在扫描阶段再次检查。\n\n你的任务是确定在最坏情况下该算法执行的最大可能比较次数。单次“比较”指的是访问一个数组元素并将其值与 `x` 进行比较。请将你的答案表示为关于 `n` 和 `k` 的封闭形式解析表达式。", "solution": "设数组长度为 $n$，步长为 $k$。该算法的比较次数由跳跃阶段和扫描阶段的比较次数之和决定。\n\n1.  **跳跃阶段：** 算法以大小为 $k$ 的步长在数组中前进。在最坏情况下，为了定位包含目标值的区间，算法需要进行 $\\lfloor n/k \\rfloor$ 次跳跃。例如，当目标值非常大，接近或超过数组中的所有元素时，算法会一直跳跃到接近数组末尾。\n\n2.  **扫描阶段：** 在跳跃阶段结束后，算法在一个大小不超过 $k$ 的块内进行线性扫描。在最坏情况下（例如，目标值是该块的倒数第二个元素，或者根本不存在），此扫描需要 $k-1$ 次比较，因为块的右边界元素（跳跃点）已经在跳跃阶段被检查过。\n\n**最坏情况分析：**\n总比较次数是跳跃阶段和扫描阶段的比较次数之和。在最坏情况下，我们需要进行最大次数的跳跃，然后进行最大次数的扫描。这导致总比较次数为这两个部分之和。\n\n总比较次数 $C(n,k) = (\\text{跳跃次数}) + (\\text{扫描次数})$\n\n在最坏情况下，这个值为 $\\lfloor n/k \\rfloor + (k-1)$。例如，考虑当目标元素位于数组中某个位置，需要算法先进行 $\\lfloor n/k \\rfloor$ 次跳跃才能到达其所在区间，然后在该区间内进行 $k-1$ 次扫描才能找到它。\n\n因此，该算法在最坏情况下执行的最大比较次数的封闭形式表达式为：\n$$\n\\left\\lfloor \\frac{n}{k}\\right\\rfloor + k - 1\n$$", "answer": "$$\\boxed{\\left\\lfloor \\frac{n}{k}\\right\\rfloor + k - 1}$$", "id": "1469569"}, {"introduction": "现在，我们将注意力从迭代算法转移到递归算法，这是计算机科学的基石。这个练习介绍了一个算法，其运行时间由一个递推关系描述。你的任务是解决这个递推关系 [@problem_id:1469561]，这是分析“分治”算法和理解每个递归步骤的成本如何影响整体复杂度的关键技能。", "problem": "一个为特定形式的分层数据分析而设计的实验性算法，作用于一个大小为 $n$ 的输入数组。为简便起见，假设 $n$ 总是 4 的幂。该算法的流程被递归地定义如下：\n\n1.  如果输入大小 $n$ 为 1，算法终止，耗时为常数时间。\n2.  如果 $n  1$，算法首先对整个数组执行一次全局合并操作。此操作所需时间与数组大小的平方成正比，由 $c n^2$ 给出，其中 $c$ 为某个正常数。\n3.  合并之后，算法在两个不同的、不重叠的子问题上递归地调用自身：\n    a. 第一个递归调用处理一个大小为 $n/2$ 的子数组。\n    b. 第二个递归调用处理另一个大小为 $n/4$ 的子数组。\n\n总时间复杂度 $T(n)$ 是合并步骤的时间与两次递归调用的时间之和。\n\n以下哪项表示该算法最坏情况时间复杂度 $T(n)$ 的最紧渐近上界和下界（大$\\Theta$表示法）？\n\nA. $\\Theta(n \\log n)$\n\nB. $\\Theta(n^{\\log_{2}(\\phi)})$，其中 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 是黄金比例。\n\nC. $\\Theta(n^2)$\n\nD. $\\Theta(n^2 \\log n)$\n\nE. $\\Theta(n^3)$", "solution": "我们根据描述将问题形式化为递推关系。设 $T(1)=\\Theta(1)$，对于 $n1$，有\n$$\nT(n)=T\\!\\left(\\frac{n}{2}\\right)+T\\!\\left(\\frac{n}{4}\\right)+c n^{2},\n$$\n其中 $c0$ 是一个常数。我们使用 Akra–Bazzi 定理来分析这个递推式。将递推式写成 $T(x)=\\sum_{i=1}^{k} a_{i} T(b_{i} x)+g(x)$ 的形式，其中 $a_{1}=1$, $a_{2}=1$, $b_{1}=\\frac{1}{2}$, $b_{2}=\\frac{1}{4}$，以及 $g(x)=c x^{2}$。从中求解 $p$：\n$$\n\\sum_{i=1}^{2} a_{i} b_{i}^{p}=1 \\quad \\Longleftrightarrow \\quad \\left(\\frac{1}{2}\\right)^{p}+\\left(\\frac{1}{4}\\right)^{p}=1.\n$$\n令 $y=2^{-p}$。则 $y+y^{2}=1$，即\n$$\ny^{2}+y-1=0.\n$$\n其正根为\n$$\ny=\\frac{-1+\\sqrt{1+4}}{2}=\\frac{-1+\\sqrt{5}}{2}=\\frac{1}{\\phi},\n$$\n其中 $\\phi=\\frac{1+\\sqrt{5}}{2}$ 是黄金比例。因此 $2^{-p}=\\frac{1}{\\phi}$，这意味着\n$$\np=\\log_{2}(\\phi).\n$$\n因为 $1  \\phi  2$，所以 $0  p  1$。Akra–Bazzi 定理指出，如果 $g(x)=\\Omega(x^{p+\\epsilon})$ 对于某个 $\\epsilon0$ 成立，那么 $T(x)=\\Theta(g(x))$。在这种情况下，$g(x)=cx^2$。由于 $p \\approx 0.694  2$，我们可以选择一个 $\\epsilon$（例如 $\\epsilon=0.5$），使得 $p+\\epsilon  2$。显然，$x^2$ 的增长速度比 $x^{p+\\epsilon}$ 更快，因此 $g(x) = \\Omega(x^{p+\\epsilon})$ 的条件满足。\n\n因此，递推关系的解由 $g(n)$ 项主导，这意味着\n$$\nT(n) = \\Theta(g(n)) = \\Theta(n^2).\n$$\n这对应于选项C。", "answer": "$$\\boxed{C}$$", "id": "1469561"}]}