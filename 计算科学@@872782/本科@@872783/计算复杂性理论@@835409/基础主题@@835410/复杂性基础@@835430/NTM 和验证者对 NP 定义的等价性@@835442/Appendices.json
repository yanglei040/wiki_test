{"hands_on_practices": [{"introduction": "理论是抽象的，而实践有助于我们巩固理解。这项练习将引导你将一个基于验证者的语言定义转换为一个非确定性图灵机（NTM）。通过处理一个需要两个独立“证书”的非标准场景，你将亲手实践“猜测并验证”这一核心思想，从而深刻理解非确定性如何被用来有效地“寻找”一个解。[@problem_id:1422203]", "problem": "在计算复杂性理论中，NP 类可以通过两种等价的方式来定义：要么是可由多项式时间非确定性图灵机（NTM）判定的语言集合，要么是具有多项式时间验证机的语言集合。\n\n考虑字母表 $\\{0,1\\}$ 上的一个语言 $L$。一个确定性图灵机 $V$ 作为 $L$ 的验证机。对于一个输入串 $x$，验证机 $V$ 接受两个额外的字符串 $c_1$ 和 $c_2$，称为证据（certificates）。语言 $L$ 被定义为所有满足存在证据 $c_1$ 和 $c_2$ 使得 $V(x, c_1, c_2)$ 接受的字符串 $x$ 的集合。\n\n给定以下性质：\n1.  验证机 $V$ 总是在输入串 $x$ 长度的多项式时间内停机。设此运行时间由 $T(|x|)$ 界定，其中 $T$ 是一个多项式。\n2.  对于任何 $x \\in L$，都存在证据 $c_1$ 和 $c_2$ 使得 $V(x, c_1, c_2)$ 接受，并且这些证据的长度由 $x$ 长度的多项式界定。具体来说， $|c_1| \\le p(|x|)$ 且 $|c_2| \\le q(|x|)$，其中 $p$ 和 $q$ 是多项式。\n\n基于 NP 的验证机定义和 NTM 定义之间的等价性，可以构造一个 NTM（我们称之为 $N$）来判定语言 $L$。以下哪个选项正确描述了 NTM $N$ 在给定输入 $x$ 上判定 $L$ 的高级算法？\n\nA. NTM $N$ 在其工作带上非确定性地写入一个长度最多为 $p(|x|)$ 的字符串，一个特殊的分隔符，然后是另一个长度最多为 $q(|x|)$ 的字符串。然后它使用输入 $x$ 和这两个猜测的字符串作为 $c_1$ 和 $c_2$，确定性地模拟验证机 $V$。当且仅当 $V$ 的模拟接受时，$N$ 接受。\n\nB. NTM $N$ 在其工作带上非确定性地写入一个长度最多为 $p(|x|) + q(|x|)$ 的单个字符串 $c$。然后它将 $c$ 精确地分成两半以获得两个字符串，并用它们作为 $c_1$ 和 $c_2$ 来运行 $V(x, c_1, c_2)$ 的模拟。当且仅当此模拟接受时，$N$ 接受。\n\nC. NTM $N$ 派生出两个独立的非确定性计算。一个路径猜测一个长度最多为 $p(|x|)$ 的证据 $c_1$ 并模拟 $V(x, c_1, \\epsilon)$，其中 $\\epsilon$ 是空串。另一个路径猜测一个长度最多为 $q(|x|)$ 的证据 $c_2$ 并模拟 $V(x, \\epsilon, c_2)$。如果这些计算中至少有一个接受，$N$ 就接受。\n\nD. NTM $N$ 确定性地搜索所有可能的证据对 $(c_1, c_2)$，其中 $|c_1| \\le p(|x|)$ 且 $|c_2| \\le q(|x|)$。对于每一对，它都模拟 $V(x, c_1, c_2)$。如果在多项式时间限制内有任何一个模拟接受，$N$ 就接受。\n\nE. NTM $N$ 非确定性地猜测一个长度最多为 $p(|x|)$ 的单个证据 $c_1$，并模拟验证机 $V(x, c_1, c_1)$，即对两个所需的证据使用相同的字符串。当且仅当此模拟接受时，$N$ 接受。", "solution": "该问题要求构建一个非确定性图灵机 (NTM) $N$，用于判定一个由验证机 $V$ 定义的语言 $L$。该验证机 $V$ 接受两个独立的证据 $c_1$ 和 $c_2$。\n\n语言 $L$ 的定义是：\n$$L = \\{x \\in \\{0,1\\}^* \\mid \\exists c_1, c_2 \\text{ such that } |c_1| \\le p(|x|), |c_2| \\le q(|x|), \\text{ and } V(x, c_1, c_2) \\text{ accepts}\\}$$\n在这里，$V$ 是一个确定性多项式时间验证机，而 $p, q$ 是界定证据长度的多项式。\n\n如果对于任何输入 $x \\in L$，至少有一条计算路径接受，而对于任何 $x \\notin L$，所有计算路径都拒绝，那么我们就说一个 NTM 判定语言 $L$。NTM 的运行时间必须是 $|x|$ 的多项式。\n\n证明 NP 的验证机定义和 NTM 定义等价性的标准构造方法，是利用 NTM 的非确定性能力来“猜测”证据，然后利用其确定性能力对猜测的证据运行验证机。我们针对有两个证据的情况调整这个构造方法。\n\nNTM $N$ 在处理输入 $x$ 时将分两个阶段工作：\n\n**阶段 1：猜测阶段（非确定性）**\n这个阶段的核心任务是生成所需的见证（witness），在这个问题中即为证据对 $(c_1, c_2)$。由于 NTM 通常以非确定性方式在其工作带上写入单个字符串，因此 NTM 必须猜测一个能同时编码 $c_1$ 和 $c_2$ 的单个字符串。一个稳健且通用的方法是将它们用一个不在证据字母表中的特殊分隔符连接起来（或使用其他一些无歧义的编码）。\n\nNTM 将执行以下操作：\n1.  非确定性地写入一个旨在作为 $c_1$ 的比特序列。机器在每一步都非确定性地选择是写入 0、1，还是停止写入 $c_1$。此过程被限制以生成一个长度最多为 $p(|x|)$ 的字符串。\n2.  在带上写入一个特殊的分隔符 '#'。\n3.  非确定性地写入第二个旨在作为 $c_2$ 的比特序列。此过程被限制以生成一个长度最多为 $q(|x|)$ 的字符串。\n\n写入带上的字符串总长度最多为 $p(|x|) + 1 + q(|x|)$，这是 $|x|$ 的多项式。这个猜测阶段需要多项式时间。\n\n**阶段 2：验证阶段（确定性）**\n猜测阶段之后，NTM 在该计算路径的剩余部分转换为完全确定性模式。\n1.  NTM 扫描它刚刚在其工作带上写入的字符串。它使用 '#' 分隔符将字符串解析为两部分，从而识别出 $c_1$ 和 $c_2$。\n2.  然后它模拟确定性验证机 $V$。模拟在输入 $(x, c_1, c_2)$ 上执行，其中 $x$ 是 NTM 的原始输入，而 $c_1, c_2$ 是刚刚猜测和解析出的字符串。\n3.  如果 $V$ 的模拟接受，NTM $N$ 进入接受状态。如果 $V$ 的模拟拒绝，NTM $N$ 进入拒绝状态。\n\n**正确性和时间复杂度分析：**\n-   **如果 $x \\in L$：** 根据定义，存在至少一对证据 $(c_1^*, c_2^*)$ 使得 $V$ 接受。NTM 的非确定性性质确保了存在一条计算路径，在该路径上它恰好猜测出 $c_1 = c_1^*$ 和 $c_2 = c_2^*$。在这条路径上，确定性验证阶段将模拟 $V(x, c_1^*, c_2^*)$，该模拟将接受。因此，NTM $N$ 将接受。\n-   **如果 $x \\notin L$：** 根据定义，对于允许长度范围内的所有可能的证据对 $(c_1, c_2)$，$V(x, c_1, c_2)$ 都会拒绝。这意味着无论 NTM 在阶段 1 中猜测什么字符串，阶段 2 中随后的 $V$ 的模拟都将拒绝。因此，$N$ 的所有计算路径都将拒绝，NTM $N$ 正确地拒绝。\n-   **时间复杂度：** 猜测阶段需要 $O(p(|x|) + q(|x|))$ 的时间。$V$ 的模拟运行时间是其总输入大小（即 $|x|+|c_1|+|c_2|$）的多项式。由于 $|c_1|$ 和 $|c_2|$ 由 $|x|$ 的多项式界定，因此模拟时间也是 $|x|$ 的多项式。两个多项式之和仍然是多项式，所以 NTM $N$ 的整个过程在多项式时间内运行。\n\n现在，我们来评估给出的选项：\n\n-   **A：** 这个选项准确地描述了“猜测并验证”的两阶段过程。它通过顺序猜测两个独立的证据（用一个符号分隔），然后模拟验证机，正确地处理了这两个证据。这与我们推导出的构造方法相匹配。\n\n-   **B：** 这个选项是错误的，因为它假设两个证据可以通过将一个更大的证据精确地分成两半来获得。如果所需的多项式界不同（即 $p(|x|) \\neq q(|x|)$），或者即使它们相同但所需的特定证据长度不同，这种方法也会失败。例如，如果 $x$ 需要长度为 5 的 $c_1$ 和长度为 10 的 $c_2$，这种方法永远找不到它们。\n\n-   **C：** 这个选项有根本性的缺陷。语言定义要求 *同时* 存在一个 $c_1$ 和一个 $c_2$ *共同* 起作用。这个选项测试的是是否存在一个与空 $c_2$ 一起起作用的 $c_1$，或者一个与空 $c_1$ 一起起作用的 $c_2$。这是一个不同的逻辑条件，定义了一个不同的语言。\n\n-   **D：** 这个选项描述的是一个 *确定性* 算法，而不是非确定性算法。它本质上是在对证据空间进行蛮力搜索。虽然这可以正确判定该语言，但可能的证据数量是 $|x|$ 的指数级别，所以这个算法将在指数时间内运行，而不是多项式时间。这描述的是一个用于 EXPTIME 类中语言的机器，而不是 NP。\n\n-   **E：** 这个选项错误地假设两个证据必须相同 ($c_1 = c_2$)。问题陈述了一个接受两个证据的验证机，除非另有说明，否则这两个证据是独立的。这种方法不够通用，无法判定 $L$。\n\n因此，选项 A 为 NTM $N$ 提供了正确且通用的构造方法。", "answer": "$$\\boxed{A}$$", "id": "1422203"}, {"introduction": "在证明 NTM 定义等价于验证者定义时，我们通常将 NTM 的计算路径作为证书。这个练习要求我们反过来，深入分析验证这一过程的计算成本。通过评估验证一个包含完整计算历史（即所有配置序列）的证书所需的时间，你将把抽象的证明概念与单带图灵机上具体的时间复杂度分析联系起来，探索理论在实际模型中的效率。[@problem_id:1422200]", "problem": "在计算复杂性理论中，复杂性类别 NP（非确定性多项式时间）可以通过两种等效的方式来定义。第一种定义指出，如果存在一台非确定性图灵机（NTM），它能在输入大小的多项式时间内判定语言 $L$，则语言 $L$ 属于 NP。假设对于大小为 $n = |x|$ 的输入 $x$，这台 NTM 在任何计算分支上最多运行 $p(n)$ 步，其中 $p$ 是一个多项式。\n\n第二种定义指出，如果存在一台确定性多项式时间图灵机 $V$（称为验证机）和一个多项式 $q$，使得对于任何输入字符串 $x$：\n$x \\in L \\iff \\text{存在一个证书字符串 } c \\text{，满足 } |c| \\le q(|x|) \\text{，使得 } V(x, c) \\text{ 接受。}$\n\n在证明 NTM 定义蕴含验证机定义的标准证明中，证书 $c$ 通常被选择为一个字符串，该字符串编码了 NTM 在其某条接受计算路径上所做出的非确定性选择序列。\n\n考虑一种验证机的替代构造方法。我们不使用选择序列，而是让证书（我们称之为 $c'$）成为一个编码了 NTM 在某条接受计算路径上的完整格局序列 $C_0, C_1, C_2, \\dots, C_k$ 的字符串，其中 $k \\le p(n)$。每个格局 $C_i$ 必须编码 NTM 的状态、其带头位置，以及在第 $i$ 步时其带上从开头到最右边的非空白符号的全部内容。\n\n假设验证机 $V$ 是一台 **单带** 确定性图灵机，请分析这个新验证过程的时间复杂度。确定验证证书 $c'$ 所需的 $V$ 的运行时间的最紧可能上界。请用大O表示法将答案表示为 $p(n)$ 的函数。", "solution": "设 $x$ 为输入， $n = |x|$，并设给定的 NTM 在任何分支上最多运行 $p(n)$ 步。设 $k \\leq p(n)$ 是证书 $c'$ 编码的接受路径中的格局数量，格局序列为 $C_{0},C_{1},\\dots,C_{k}$。\n\n步骤 1：界定每个格局的大小。\n在第 $i$ 步，带头最多从其起始位置移动了 $i$ 个单元格，并且在原始输入右侧最多引入了 $i$ 个新的非空白单元格。因此，如果我们用 $R_{i}$ 表示 $C_{i}$ 中带上到最右边非空白符号的带前缀长度，则\n$$\nR_{i} \\leq n + i \\leq n + p(n).\n$$\n令 $R \\coloneqq \\max_{0 \\leq i \\leq k} R_{i} \\leq n + p(n)$。一个格局的描述包括状态、带头位置以及到最右边非空白符号为止的带内容，其长度为 $O(R)$（状态和带头位置只贡献对数级的开销）。因此，每个 $C_{i}$ 的长度为 $O(R)$，整个证书的长度满足\n$$\n|c'| = O\\big(k R\\big) = O\\big(p(n)\\,(n + p(n))\\big).\n$$\n\n步骤 2：单带验证机必须检查什么。\n一个正确的验证机 $V$ 必须检查：\n- $C_{0}$ 是输入 $x$ 的正确初始格局（包括 $C_{0}$ 的带内容与 $x$ 匹配）：这通过一次从左到右的扫描需要 $O(n)$ 的时间。\n- 对于每个 $i \\in \\{0,\\dots,k-1\\}$，检查 $C_{i+1}$ 是否由 $C_{i}$ 经过一次有效的 NTM 转移得到：这需要检查状态和带头的更新是否与转移函数一致，并且除了可能在带头单元格处（以及可能在最右边的非空白边界处），$C_{i}$ 和 $C_{i+1}$ 的带内容在所有其他位置都一致。\n- $C_{k}$ 是接受格局：根据格局的编码，这需要 $O(1)$ 的时间。\n\n步骤 3：在单带上比较相邻格局的成本。\n对于单带确定性图灵机，比较两个长度为 $\\Theta(R)$ 的相邻块是否相等（或除了一个常数大小的窗口外是否相等）在最坏情况下需要 $\\Theta(R^{2})$ 的时间。标准的上界是通过常规的划掉算法或穿梭算法实现的，该算法对每个位置在 $\\Theta(R)$ 的距离上来回移动；这产生了一个 $O(R^{2})$ 的算法。此外，已知语言 $\\{w \\# w : w \\in \\Sigma^{*}\\}$ 在单带机上需要 $\\Omega(R^{2})$ 的时间，这意味着对此类比较存在一个匹配的 $\\Omega(R^{2})$ 下界。因此，验证 $C_{i+1}$ 与 $C_{i}$ 在除了受转移影响的常数大小邻域之外的所有地方都匹配，需要的时间为\n$$\n\\Theta(R^{2})\n$$\n每个相邻对 $(C_{i},C_{i+1})$。\n\n步骤 4：总验证时间。\n有 $k \\leq p(n)$ 个相邻对，所以验证所有转移的总时间是\n$$\nO\\big(k \\cdot R^{2}\\big) = O\\big(p(n)\\,(n + p(n))^{2}\\big).\n$$\n包括检查 $C_{0}$ 与 $x$ 的 $O(n)$ 成本不会改变渐近界限。因此，\n$$\nT_{V}(n) = O\\big(p(n)\\,(n + p(n))^{2}\\big).\n$$\n\n如果希望将界限纯粹表示为 $p(n)$ 的函数，通常会对 NTM 进行规范化，使其首先扫描输入（强制 $p(n) \\geq n$ 同时保持多项式运行时间），从而得到 $R = \\Theta(p(n))$，因此\n$$\nT_{V}(n) = O\\big(p(n) \\cdot p(n)^{2}\\big) = O\\big(p(n)^{3}\\big).\n$$\n这个界限在常数因子内是紧的：存在 NTM 计算，其中 $k = \\Theta(p(n))$ 且 $R = \\Theta(p(n))$，对于这些计算，每次相邻对的检查在单带上需要 $\\Omega(R^{2}) = \\Omega(p(n)^{2})$ 的时间，从而给出一个总的下界 $\\Omega(p(n)^{3})$。\n\n因此，对于这种格局序列证书的单带验证机，作为 $p(n)$ 函数的最紧可能上界是 $O\\big(p(n)^{3}\\big)$。", "answer": "$$\\boxed{O\\!\\left(p(n)^{3}\\right)}$$", "id": "1422200"}, {"introduction": "这个练习是一个思想实验，旨在挑战你对 NP 定义边界的直觉。我们引入一个看似更强大的计算模型，其中验证者可以访问一个指数级长度的证书。通过分析这个模型的计算能力，你将发现，决定一个复杂性类的真正关键是验证过程本身的资源限制（如多项式时间），而不是潜在证据的庞大规模。[@problem_id:1422176]", "problem": "在计算复杂性理论中，类 NP 通常使用多项式时间验证机来定义。如果存在一个多项式 $p(n)$ 和一个多项式时间的确定性图灵机（DTM），称为验证机 $V$，使得对于任何长度为 $n = |x|$ 的输入字符串 $x$，语言 $L$ 属于 NP：\n1.  如果 $x \\in L$，则存在一个长度至多为 $p(n)$ 的证据字符串 $w$，使得 $V(x, w)$ 接受。\n2.  如果 $x \\notin L$，对于所有长度至多为 $p(n)$ 的证据字符串 $w$，$V(x, w)$ 拒绝。\n\n考虑一个新的复杂性类，我们称之为 `OracleNP`。该类通过修改验证机模型来定义。如果存在两个多项式 $p(n)$ 和 $q(n)$，以及一个 DTM $V_O$，使得对于任何长度为 $n=|x|$ 的输入字符串 $x$，语言 $L$ 属于 `OracleNP`：\n-   验证机 $V_O$ 的运行时间以 $q(n)$ 为界。\n-   $V_O$ 可以通过谕示机访问证据字符串 $y$。这意味着 $V_O$ 可以在单个计算步骤中，将一个二进制索引 $i$ 写入一个特殊的查询带，并接收 $y$ 的第 $i$ 位，记作 $y_i$。\n-   证据 $y$ 的长度可以达到 $2^{p(n)}$。因此，$V_O$ 查询的索引 $i$ 的值可以达到 $2^{p(n)}$。\n\n`OracleNP` 的接受和拒绝条件是：\n1.  如果 $x \\in L$，则存在一个长度至多为 $2^{p(n)}$ 的证据字符串 $y$，使得 $V_O$ 在给定输入 $x$ 和对 $y$ 的谕示机访问权限的情况下接受。\n2.  如果 $x \\notin L$，对于所有长度至多为 $2^{p(n)}$ 的证据字符串 $y$，$V_O$ 在给定输入 $x$ 和对 $y$ 的谕示机访问权限的情况下拒绝。\n\n根据这些定义，确定 `OracleNP` 类与其他著名复杂性类之间的关系。\n\nA. `OracleNP` = P\nB. `OracleNP` = NP\nC. `OracleNP` = PSPACE\nD. `OracleNP` = EXPTIME\nE. `OracleNP` 真包含 NP，但被包含在 PSPACE 中。\nF. NP 真包含 `OracleNP`。", "solution": "我们将由多项式时间确定性验证机定义的、能通过谕示机访问指数级长度证据字符串（对单个比特进行随机访问查询）的类与标准 NP 进行比较。\n\n首先，我们对模型进行形式化。对于 OracleNP 中的语言 $L$，存在多项式 $p(n)$ 和 $q(n)$ 以及一个 DTM $V_{O}$，使得在输入为 $x$ 且 $|x|=n$ 时，$V_{O}$ 的运行时间至多为 $q(n)$，并可在任何步骤中发出一个查询索引 $i$（二进制形式），并接收一个长度至多为 $2^{p(n)}$ 的辅助字符串 $y$ 的比特 $y_{i}$。接受条件是对 $y$ 存在性的：\n1. 如果 $x \\in L$，则存在 $|y| \\leq 2^{p(n)}$ 的 $y$ 使得 $V_{O}^{y}(x)$ 接受。\n2. 如果 $x \\notin L$，则对于所有这样的 $y$，$V_{O}^{y}(x)$ 拒绝。\n\n我们通过两个包含关系来证明 OracleNP 等于 NP。\n\n包含关系 $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$：设 $L \\in \\mathrm{NP}$，其验证机 $V$ 的运行时间至多为 $r(n)$，并使用长度至多为 $s(n)$ 的证据 $w$，其中 $r$ 和 $s$ 是多项式。定义 $V_{O}$，在输入 $x$ 时，它只查询其谕示机证据 $y$ 的前 $s(n)$ 个位置来读取一个假定的 $w$，然后模拟 $V(x,w)$。由于 $V_{O}$ 的运行时间是 $n$ 的多项式时间，因此 $L$ 属于 OracleNP。所以 $\\mathrm{NP} \\subseteq \\mathrm{OracleNP}$。\n\n包含关系 $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$：设 $L \\in \\mathrm{OracleNP}$，其多项式为 $p,q$，验证机为 $V_{O}$，如上所述。我们构造一个标准的 NP 验证机 $U$，其具有一个多项式大小的证据，该证据编码了一个可接受的谕示机交互过程。因为 $V_{O}$ 的运行时间至多为 $q(n)$，所以它最多可以发出 $q(n)$ 次查询。在特定谕示机 $y$ 下，其对输入 $x$ 的计算序列完全由 $x$ 和对这些查询的回答所决定。\n\n定义证据 $w$ 为一个长度至多为 $T \\leq q(n)$ 的记录，它由在唯一运行中遇到的查询-回答信息序列组成：对于 $t=1,\\dots,T$，包括查询的索引 $i_{t}$（二进制形式，长度至多为 $p(n)$）和回答比特 $b_{t} \\in \\{0,1\\}$。因此 $|w| \\leq T\\,(p(n)+1) \\leq q(n)\\,(p(n)+1)$，这是 $n$ 的多项式。\n\n验证机 $U$ 在输入 $x$ 和证据 $w$ 时，逐步模拟 $V_{O}(x)$，最多模拟 $q(n)$ 步。每当 $V_{O}$ 写入一个查询索引，称之为 $\\hat{i}_{t}$，模拟器就从 $w$ 中读取下一对 $(i_{t},b_{t})$，并检查 $i_{t}=\\hat{i}_{t}$ 是否成立。它维护一个先前见过的索引的字典以强制一致性：如果一个索引重复出现，它会检查新提供的 $b_{t}$ 是否与记录的比特匹配。然后它将 $b_{t}$ 作为谕示机的回答，并继续模拟。如果在任何时候索引不匹配、一致性检查失败或模拟超过 $q(n)$ 步，$U$ 就会拒绝。如果模拟在 $q(n)$ 步内停机并处于接受状态，$U$ 就接受。\n\n正确性：\n- 如果 $x \\in L$，存在 $y$ 使得 $V_{O}^{y}(x)$ 接受。设 $w$ 是该接受运行的记录：即按顺序排列的对 $(i_{t},y_{i_{t}})$ 的序列。那么 $U$ 的模拟将精确地复现该运行并接受。\n- 如果 $x \\notin L$，则对于每个 $y$，$V_{O}^{y}(x)$ 都会拒绝。对于任何声称的记录 $w$，它要么与 $V_{O}$ 的确定性行为不一致（导致 $U$ 检测到不匹配或不一致并拒绝），要么它忠实地模拟了某个谕示机运行，而该运行必然以拒绝告终；因此 $U$ 拒绝。\n\n因此，$L \\in \\mathrm{NP}$ 且 $\\mathrm{OracleNP} \\subseteq \\mathrm{NP}$。\n\n结合两个包含关系，得出 $\\mathrm{OracleNP}=\\mathrm{NP}$。因此，在所列选项中，正确的关系是 OracleNP 等于 NP。", "answer": "$$\\boxed{B}$$", "id": "1422176"}]}