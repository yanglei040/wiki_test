{"hands_on_practices": [{"introduction": "本节的第一个练习阐明了优化问题和判定问题之间最直接的关系：如何利用一个强大的优化预言机（oracle）来瞬间解决一个相关的判定问题。我们将探索一个网络工程中的假设场景，在给定一个能够告诉我们网络绝对最佳性能的工具的情况下，判断该网络是否能满足某一特定的性能门槛[@problem_id:1437415]。", "problem": "在网络工程和计算理论领域，我们通常区分优化问题和判定问题。\n\n考虑以下优化问题：\n- **问题名称**：`MAX_BANDWIDTH`\n- **输入**：一个表示为图 $G$ 的网络，其中节点是服务器，带权边代表直接连接的容量。\n- **输出**：一个实数，表示整个网络中*任意*不同节点对之间可实现的最大数据带宽。\n\n现在，考虑相关的判定问题：\n- **问题名称**：`CAN_SUPPORT_SERVICE`\n- **输入**：一个网络图 $G$ 和一个所需的带宽阈值 $B > 0$。\n- **输出**：如果网络中存在至少一对节点可以支持不小于 $B$ 的通信带宽，则输出 'YES'。否则，输出 'NO'。\n\n假设你有一个假设性的“神谕机”（oracle）——一个黑盒计算设备，它可以为你提供的任何网络图 $G$ 立即解决 `MAX_BANDWIDTH` 问题。你的任务是设计一个算法，利用这个神谕机来解决 `CAN_SUPPORT_SERVICE` 判定问题。\n\n以下哪个过程能正确且最高效地使用 `MAX_BANDWIDTH` 神谕机解决 `CAN_SUPPORT_SERVICE(G, B)` 问题？\n\nA.\n1. 将网络图 $G$ 作为输入提供给 `MAX_BANDWIDTH` 神谕机。\n2. 设神谕机的数值输出为 $M$。\n3. 如果 $M \\geq B$，算法返回 'YES'。\n4. 否则，算法返回 'NO'。\n\nB.\n1. 将网络图 $G$ 和阈值 $B$ 都作为输入提供给 `MAX_BANDWIDTH` 神谕机。\n2. 如果神谕机返回一个大于 0 的值，算法返回 'YES'。\n3. 否则，算法返回 'NO'。\n\nC.\n1. 找出网络图 $G$ 中所有唯一的节点对 $(u, v)$。\n2. 对每一对节点，都以图 $G$ 为输入调用 `MAX_BANDWIDTH` 神谕机。\n3. 如果其中任何一次调用返回的值 $M \\geq B$，算法立即返回 'YES'。\n4. 如果检查完所有节点对后该条件都未满足，算法返回 'NO'。\n\nD.\n1. 将网络图 $G$ 作为输入提供给 `MAX_BANDWIDTH` 神谕机。\n2. 设神谕机的数值输出为 $M$。\n3. 如果 $M > B$，算法返回 'YES'。\n4. 否则，算法返回 'NO'。\n\nE.\n1. 首先，检查图 $G$ 中的边数是否大于或等于阈值 $B$。\n2. 如果是，则调用 `MAX_BANDWIDTH` 神谕机。如果神谕机返回一个正数，算法返回 'YES'。\n3. 否则，算法返回 'NO'。", "solution": "我们将优化神谕机和判定谓词形式化，以推导出正确的归约。\n\n设 $\\text{bw}(u,v)$ 表示图 $G$ 中节点 $u$ 和 $v$ 之间可实现的最大带宽。`MAX_BANDWIDTH` 的优化神谕机返回\n$$\nM^{\\ast}=\\max_{u\\neq v}\\text{bw}(u,v).\n$$\n判定问题 $\\text{CAN\\_SUPPORT\\_SERVICE}(G,B)$ 询问是否存在\n$$\n\\exists\\,(u,v)\\text{ with }u\\neq v\\text{ such that }\\text{bw}(u,v)\\geq B.\n$$\n根据有限集上最大值的基本性质，以下等价关系成立：\n$$\n\\left(\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\right)\\quad\\Longleftrightarrow\\quad \\max_{u\\neq v}\\text{bw}(u,v)\\geq B,\n$$\n也就是说，\n$$\n\\exists\\,(u,v):\\text{bw}(u,v)\\geq B\\quad\\Longleftrightarrow\\quad M^{\\ast}\\geq B.\n$$\n因此，调用一次 $\\text{MAX\\_BANDWIDTH}$ 神谕机以获得 $M^{\\ast}$，并且当且仅当 $M^{\\ast}\\geq B$ 时返回 'YES' 的算法是正确的。\n\n在给定的过程中：\n- A 精确地实现了这个单次调用比较 $M\\geq B$，因此是正确的，并且只使用了一次神谕机，是最高效的。\n- B 是无效的，因为神谕机只接受 $G$ 作为输入，并且它检查的是 $M>0$ 而不是 $M\\geq B$，这在 $0", "answer": "$$\\boxed{A}$$", "id": "1437415"}, {"introduction": "这个练习将情况反转，展示了一种更常见也更强大的技术：如何使用一个简单的“是/否”判定预言机来为一个优化问题找到一个精确的数值解。我们将解决一个几何优化问题——为一组服务点找到最小的广播覆盖半径——而我们唯一可用的工具只能告诉我们一个*给定*的半径是否足够[@problem_id:1437394]。这个过程凸显了在计算理论中二分搜索的广泛应用和强大能力。", "problem": "一家电信公司正在设计一种算法，以找到新广播塔的最佳位置和功率。该广播塔必须为一组 $n$ 个指定的服务地点提供覆盖，这些地点由二维平面上的一组点 $P = \\{p_1, p_2, \\dots, p_n\\}$ 表示，其中每个点由其坐标 $p_i = (x_i, y_i)$ 给出。\n\n为了最小化运营成本，该公司希望找到一个能够覆盖所有 $n$ 个地点的单个圆形覆盖区域的最小可能广播半径 $R_{min}$。这个圆的圆心可以是平面上的任何点。\n\n工程团队为您提供了一个功能强大但运行成本高昂的模拟工具，该工具可以建模为一个“黑盒”预言机函数 `CAN_COVER(P, r)`。该函数接受点集 $P$ 和半径 $r$ 作为输入。如果存在某个半径为 $r$ 的圆可以包围 $P$ 中的所有点，则返回 `true`，否则返回 `false`。对该预言机的每次调用都算作一个计算步骤。\n\n对位置数据的初步分析确定了一个边界值 $C_{max}$，使得对于集合 $P$ 中的所有点 $(x_i, y_i)$，已知 $|x_i| \\le C_{max}$ 且 $|y_i| \\le C_{max}$。\n\n你的任务是设计一个策略，使用 `CAN_COVER` 预言机来找到最小半径 $R_{min}$。具体来说，对于给定的精度 $\\epsilon > 0$，确定保证找到一个估计半径 $R_{est}$ 所需的 `CAN_COVER` 的最小调用次数，使得绝对误差至多为 $\\epsilon$，即 $|R_{est} - R_{min}| \\le \\epsilon$。\n\n将你的答案表示为一个关于 $C_{max}$ 和 $\\epsilon$ 的闭式解析表达式。", "solution": "令 $R_{min}$ 为覆盖 $P$ 中所有点的圆的最小半径。预言机谓词 $f(r) := \\mathtt{CAN\\_COVER}(P, r)$ 是单调的：当 $r  R_{min}$ 时 $f(r) = \\text{false}$，当 $r \\ge R_{min}$ 时 $f(r) = \\text{true}$。\n\n先验几何界限：由于每个 $p_{i}$ 都位于正方形 $\\{(x,y): |x| \\le C_{max}, |y| \\le C_{max}\\}$ 内，以原点为圆心、半径为 $C_{max}\\sqrt{2}$ 的圆覆盖了整个正方形，因此\n$$\n0 \\le R_{min} \\le C_{max}\\sqrt{2}.\n$$\n因此，我们可以初始化一个搜索区间 $[L_{0}, U_{0}] = [0, C_{max}\\sqrt{2}]$，该区间保证包含 $R_{min}$，且无需任何预言机调用。\n\n对 $r \\in [L, U]$ 进行二分搜索：在每一步查询中点 $m = \\frac{L+U}{2}$。如果 $f(m) = \\text{true}$，则 $R_{min} \\le m$，因此设置 $U \\leftarrow m$；否则 $R_{min}  m$，因此设置 $L \\leftarrow m$。根据归纳法，经过 $t$ 次预言机调用后，维持的区间 $[L_{t}, U_{t}]$ 包含 $R_{min}$，并且其长度为\n$$\nU_{t} - L_{t} \\le \\frac{U_{0} - L_{0}}{2^{t}} = \\frac{C_{max}\\sqrt{2}}{2^{t}}.\n$$\n如果我们输出中点 $R_{est} = \\frac{L_{t} + U_{t}}{2}$ 作为估计值，则最坏情况下的绝对误差至多是区间长度的一半：\n$$\n|R_{est} - R_{min}| \\le \\frac{U_{t} - L_{t}}{2} \\le \\frac{C_{max}\\sqrt{2}}{2^{t+1}}.\n$$\n为了保证 $|R_{est} - R_{min}| \\le \\epsilon$，只需满足\n$$\n\\frac{C_{max}\\sqrt{2}}{2^{t+1}} \\le \\epsilon\n\\quad \\Longleftrightarrow \\quad\nt \\ge \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right).\n$$\n由于调用次数必须是整数，在最坏情况下所需的最小预言机调用次数是\n$$\n\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil.\n$$\n这个界是最佳的：经过 $t$ 次二分预言机调用后，任何算法只能将 $R_{min}$ 约束到一个长度至少为 $\\frac{C_{max}\\sqrt{2}}{2^{t}}$ 的区间内，因此（通过选择中点）能保证的最佳绝对误差至少为 $\\frac{C_{max}\\sqrt{2}}{2^{t+1}}$，从而得出相同的必要条件。", "answer": "$$\\boxed{\\left\\lceil \\log_{2}\\!\\left(\\frac{C_{max}\\sqrt{2}}{2\\epsilon}\\right) \\right\\rceil}$$", "id": "1437394"}, {"introduction": "在上一练习的基础上，我们最后的这个练习将展示判定预言机不仅能用来寻找单个数值，还能用来重构一个复杂的、结构化的解决方案。我们将学习如何利用一个只能判断系统是否存在错误的模型检测预言机，一步步地构造出导致系统发生故障的具体事件序列[@problem_id:1437398]。在软件和硬件验证领域，这种从一个“存在性”证明（知道错误存在）到“构造性”证明（知道错误如何发生）的飞跃是至关重要的。", "problem": "在形式化验证领域，模型检测是一种用于自动验证系统模型是否满足给定规约的技术。一种常见的规约类型是安全性质，它断言“坏事永不发生”。\n\n考虑一个建模为有限迁移系统的系统，它可以由一个元组 $M = (S, s_{init}, T, B)$ 形式化地描述，其中：\n- $S$ 是一个有限的状态集合。\n- $s_{init} \\in S$ 是初始状态。\n- $T \\subseteq S \\times S$ 是迁移关系。一个序对 $(s, s') \\in T$ 表示系统可以从状态 $s$ 迁移到状态 $s'$。\n- $B \\subseteq S$ 是一个“坏”状态或不安全状态的集合。\n\n系统的一条轨迹（或执行路径）是一个状态序列 $\\pi = (\\pi_0, \\pi_1, \\dots, \\pi_m)$，其中 $\\pi_0 = s_{init}$ 且对于所有 $0 \\le i  m$，都有 $(\\pi_i, \\pi_{i+1}) \\in T$。该轨迹的长度为 $m$。\n\n如果一条轨迹包含至少一个来自集合 $B$ 的状态，则称其为“违规轨迹”。模型检测器的任务通常是找到这样一条轨迹，它可作为该安全性质的一个反例。\n\n你被授予访问一个黑盒决策预言机 `CheckViolation(M, k)` 的权限。该预言机接收一个系统模型 $M = (S, s_{init}, T, B)$ 和一个非负整数 $k$ 作为输入。如果在模型 $M$ 中存在一条从 $s_{init}$ 开始、长度至多为 $k$ 的违规轨迹，它返回 `true`，否则返回 `false`。你可以根据需要，使用任何有效的模型和任何整数 $k$ 多次调用此预言机。\n\n你的任务是设计一个使用此预言机来找到一个具体反例的程序。\n\n考虑以下具体的迁移系统 $M_{spec}$：\n- 状态集合 $S = \\{s_0, s_1, s_2, s_3, s_4, s_5, s_6\\}$\n- 初始状态 $s_{init} = s_0$\n- 坏状态集合 $B = \\{s_6\\}$\n- 迁移关系 $T = \\{(s_0, s_1), (s_0, s_2), (s_1, s_3), (s_2, s_4), (s_3, s_5), (s_4, s_0), (s_5, s_6)\\}$\n\n请描述一个通用算法，该算法使用 `CheckViolation` 预言机为任何给定的有限迁移系统（假设存在违规轨迹）找到一条最短违规轨迹。然后，将你的算法应用于系统 $M_{spec}$ 以找到最短违规轨迹。你的最终答案应该是构成此轨迹的状态标签序列。", "solution": "我们首先形式化地定义仅使用决策预言机来搜索最短反例意味着什么。设 $M=(S,s_{init},T,B)$ 为一个有限迁移系统，并将谓词 $V(k)$ 定义为预言机结果 $V(k)=\\text{CheckViolation}(M,k)$，当且仅当存在一条从 $s_{init}$ 开始、长度至多为 $k$ 的违规轨迹时，该预言机返回真。谓词 $V(k)$ 对 $k$ 是单调的，具体来说，如果 $V(k)$ 为真，那么对于所有 $k'\\geq k$，$V(k')$ 也为真。此外，如果存在任何违规轨迹，那么必然存在一条最短违规轨迹，其长度至多为 $\\lvert S\\rvert-1$，因为对于任何给定的违规轨迹，如果在到达 $B$ 之前有状态重复，那么可以移除其间的循环而不会失去违规性；在具有 $\\lvert S\\rvert$ 个节点的图中，任何简单路径的长度至多为 $\\lvert S\\rvert-1$。\n\n寻找最短违规轨迹的通用算法：\n1. 长度发现（二分搜索）。定义 $U=\\lvert S\\rvert-1$ 并首先查询 $V(U)$。如果 $V(U)$ 为假，则不存在违规轨迹。否则，在区间 $[0,U]$ 上执行二分搜索，以找到满足 $V(k^{\\ast})$ 为真的最小 $k^{\\ast}$。正确性源于 $V(k)$ 的单调性以及最短违规长度的上限。\n2. 使用受限初始状态通过前缀扩展进行路径重构。确定 $k^{\\ast}$ 后，按如下方式重构一条长度恰好为 $k^{\\ast}$ 的具体路径。维护一个当前状态 $s$ 和一个剩余预算 $r$，初始化为 $s:=s_{init}$ 和 $r:=k^{\\ast}$。当 $r0$ 且 $s\\notin B$ 时，执行：\n   - 枚举 $\\text{Post}(s)=\\{s'\\in S:(s,s')\\in T\\}$。\n   - 对于 $\\text{Post}(s)$ 中的每个 $s'$，构建一个修改后的模型 $M'=(S,s',T,B)$，该模型与 $M$ 相同，只是初始状态设置为 $s'$。查询 $\\text{CheckViolation}(M',r-1)$。\n   - 如果对于某个 $s'$，预言机返回真，则存在一条从 $s'$ 开始、长度至多为 $r-1$ 的违规轨迹，因此存在一条从 $s$ 开始、长度恰好为 $r$ 的最短违规轨迹，其下一状态是 $s'$。将 $s'$ 附加到路径前缀上，更新 $s:=s'$ 和 $r:=r-1$，然后继续。\n此过程在每一步都必须成功，因为根据 $k^{\\ast}$ 的定义，存在一条从 $s$ 开始的长度为 $r$ 的违规后缀，因此其在下一位置的直接后继 $s'$ 将通过预算为 $r-1$ 的预言机测试。循环在 $r=0$ 且当前状态在 $B$ 中时终止，从而得到一条最短违规轨迹。\n\n应用于 $M_{spec}$：\n我们有 $S=\\{s_{0},s_{1},s_{2},s_{3},s_{4},s_{5},s_{6}\\}$，$s_{init}=s_{0}$，$B=\\{s_{6}\\}$ 以及 $T=\\{(s_{0},s_{1}),(s_{0},s_{2}),(s_{1},s_{3}),(s_{2},s_{4}),(s_{3},s_{5}),(s_{4},s_{0}),(s_{5},s_{6})\\}$。上界为 $U=\\lvert S\\rvert-1=6$。评估预言机以找到 $k^{\\ast}$：\n- $\\text{CheckViolation}(M_{spec},3)$ 为假，因为任何从 $s_{0}$ 到 $s_{6}$ 的路径都必须经过 $s_{5}$，然后是 $s_{3}$，再然后是 $s_{1}$，这至少需要 4 次迁移。\n- $\\text{CheckViolation}(M_{spec},5)$ 为真，因为存在一条长度为 $4\\leq 5$ 到达 $s_{6}$ 的路径（如下所示）。\n- 通过二分法，测试 $\\text{CheckViolation}(M_{spec},4)$，结果为真；因此最小违规长度为 $k^{\\ast}=4$。\n\n为 $k^{\\ast}=4$ 重构路径：\n- 初始化 $s:=s_{0}$ 和 $r:=4$。计算 $\\text{Post}(s_{0})=\\{s_{1},s_{2}\\}$。\n  - 对于 $s_{1}$，构造 $M'=(S,s_{1},T,B)$ 并查询 $\\text{CheckViolation}(M',3)$。结果为真，因为 $s_{1}\\to s_{3}\\to s_{5}\\to s_{6}$ 在 3 步内到达 $B$。选择 $s_{1}$，设置 $s:=s_{1}$ 和 $r:=3$。\n- 现在 $s=s_{1}$，$r=3$，且 $\\text{Post}(s_{1})=\\{s_{3}\\}$。对于 $s_{3}$，$\\text{CheckViolation}((S,s_{3},T,B),2)$ 为真，路径为 $s_{3}\\to s_{5}\\to s_{6}$。选择 $s_{3}$，更新 $s:=s_{3}$，$r:=2$。\n- 现在 $s=s_{3}$，$r=2$，且 $\\text{Post}(s_{3})=\\{s_{5}\\}$。对于 $s_{5}$，$\\text{CheckViolation}((S,s_{5},T,B),1)$ 为真，路径为 $s_{5}\\to s_{6}$。选择 $s_{5}$，更新 $s:=s_{5}$，$r:=1$。\n- 现在 $s=s_{5}$，$r=1$，且 $\\text{Post}(s_{5})=\\{s_{6}\\}$。对于 $s_{6}$，$\\text{CheckViolation}((S,s_{6},T,B),0)$ 为真，因为 $s_{6}\\in B$。选择 $s_{6}$，更新 $s:=s_{6}$，$r:=0$ 并终止。\n重构出的最短违规轨迹是 $(s_{0},s_{1},s_{3},s_{5},s_{6})$。", "answer": "$$\\boxed{\\begin{pmatrix}s_{0}  s_{1}  s_{3}  s_{5}  s_{6}\\end{pmatrix}}$$", "id": "1437398"}]}