{"hands_on_practices": [{"introduction": "计算复杂性理论的核心是研究决策问题，即答案为“是”或“否”的问题。然而，许多现实世界中的挑战，如优化路线或安排日程，本质上是优化问题，目标是找到最佳解决方案。本练习将通过著名的旅行商问题 (TSP) 作为一个具体例子，指导你如何将一个优化问题转化为一个决策问题，并理解“证书”这一概念，它是定义 NP 类的关键 [@problem_id:1460208]。", "problem": "一家科技公司正在为其自动送货无人机机群设计一个复杂的调度系统。这些无人机必须访问一组 $n$ 个不同的送货地点。该系统可以获取任意两个地点 $u$ 和 $v$ 之间的精确旅行时间 $t(u, v)$。一个关键的挑战是找到一条能最小化总旅行时间的最优路线。这是著名的旅行商问题 (TSP) 的一个变体。\n\n在计算复杂性理论中，为了对像 TSP 这样的问题进行难度分类，我们通常将它们从*优化问题*（要求找到最佳解）转换为*判定问题*（答案为“是”或“否”）。如果一个问题的判定版本的任何“是”实例都可以被有效验证，那么该问题就被称为属于 NP 类（非确定性多项式时间）。这个验证过程涉及在相对于问题输入规模的多项式时间内，检查一个被称为*证书*或*见证*的建议解。\n\n考虑无人机路线规划问题的判定版本。输入包括 $n$ 个地点、所有旅行时间 $t(u, v)$ 的集合，以及一个最大允许的总旅行时间 $K$。问题是在这个时间限制内是否存在一个有效的旅行路线可以完成。\n\n以下哪个选项正确地指出了该问题的形式化判定问题和一个有效的证书，该证书能让“是”的答案在多项式时间内得到验证？\n\nA. **判定问题：** 是否存在一条访问每个地点恰好一次并返回起点的旅行路线，其总旅行时间至多为 $K$？ **证书：** 旅行路线总旅行时间的数值。\n\nB. **判定问题：** 访问每个地点恰好一次并返回起点的旅行路线，其可能的最短旅行时间是多少？ **证书：** 构成一个完整旅行路线的 $n$ 个地点的特定有序序列。\n\nC. **判定问题：** 是否存在一条访问每个地点恰好一次并返回起点的旅行路线，其总旅行时间至多为 $K$？ **证书：** 用于找到该旅行路线的计算机算法的描述。\n\nD. **判定问题：** 是否存在一条访问每个地点-恰好一次并返回起点的旅行路线，其总旅行时间至多为 $K$？ **证书：** 构成一个完整旅行路线的 $n$ 个地点的特定有序序列（例如，地点1 -> 地点5 -> ... -> 地点1）。", "solution": "要解决这个问题，我们必须正确识别两个组成部分：旅行商问题 (TSP) 的判定版本和一个用于“是”实例的有效证书。\n\n首先，让我们分析判定问题的表述。计算复杂性理论，特别是对 NP 类的研究，侧重于判定问题，这些问题的答案是“是”或“否”。原始的 TSP 是一个优化问题：它问的是“一条旅行路线的*最小*总距离/时间是多少？”为了将其转换为判定问题，我们引入一个阈值，在问题描述中以 $K$ 给出。相应的判定问题不是要找到最小值，而是要确定是否存在满足特定标准的解。因此，正确的判定问题是：“是否存在一条访问每个地点恰好一次并返回起点的旅行路线，其总旅行时间至多为 $K$？”\n\n让我们检查一下选项中提出的判定问题：\n- 选项 B 问：“……可能的最短旅行时间是多少？” 这是问题的优化版本，而不是判定版本。因此，选项 B 是不正确的。\n- 选项 A、C 和 D 都提出了正确的判定问题：“是否存在一条旅行路线……其总旅行时间至多为 $K$？” 所以，我们现在必须评估这些选项中提出的证书。\n\n其次，让我们分析证书的概念。对于一个在 NP 类中的问题，“是”的答案必须能在多项式时间内被验证。这意味着如果有人声称答案是“是”，他们必须提供一个证据（即证书），让我们能够快速确认他们的说法。证书本身不是找到解的方法，而是解本身或其表示。验证者是一个算法，它将问题实例（地点、时间、$K$）和证书作为输入，并在多项式时间内确认该证书是否证明了这是一个“是”实例。\n\n让我们评估剩余选项（A、C 和 D）的证书：\n- **选项 A 证书：** “旅行路线总旅行时间的数值。”\n假设证书是数字 `120.5`。为了验证这一点，我们需要确认确实存在一条总时间为 `120.5`（即 $\\le K$）的旅行路线。但仅仅拥有这个数字对我们没有帮助。我们仍然需要去寻找一条具有该特定总时间的旅行路线，这和原问题一样困难。证书必须使验证变得容易。因此，仅一个数值不是一个有效的证书。这排除了选项 A。\n\n- **选项 C 证书：** “用于找到该旅行路线的计算机算法的描述。”\n证书是代表解的一份数据，而不是找到解的过程。验证一个算法是否正确，以及它是否确实能找到这样的旅行路线，是一个复杂得多的问题（与程序验证相关），这并不是复杂性理论中证书验证的含义。验证者的任务是检查一个给定的解，而不是一个给定的求解方法。因此，这不是一个有效的证书。这排除了选项 C。\n\n- **选项 D 证书：** “构成一个完整旅行路线的 $n$ 个地点的特定有序序列（例如，地点1 -> 地点5 -> ... -> 地点1）。”\n这是一个有效的证书。让我们看看验证者如何使用它。给定一个包含 $n$ 个地点的序列，验证者可以在多项式时间内执行以下步骤：\n1.  检查该序列是否是所有 $n$ 个地点的排列（即，它是否恰好访问每个地点一次）。这可以通过排序或使用哈希表在与 $n \\log n$ 或 $n$ 成比例的时间内完成。\n2.  计算由该序列定义的旅行路线的总旅行时间。这包括对旅行路线的 $n$ 段路程的 $n$ 个旅行时间求和（例如，$t(L_1, L_2) + t(L_2, L_3) + \\dots + t(L_n, L_1)$）。这是一个简单的 $n$ 个数字的求和，是一个线性时间操作，即 $O(n)$。\n3.  将计算出的总时间与阈值 $K$ 进行比较。这是一个单一的比较，是一个常数时间操作，即 $O(1)$。\n由于所有的验证步骤都可以在多项式时间内执行（实际上，相对于地点数量 $n$ 是线性时间），因此这个序列是一个有效的证书。\n\n选项 D 中的判定问题和证书都是正确的。", "answer": "$$\\boxed{D}$$", "id": "1460208"}, {"introduction": "我们通常将 P 类问题描述为可以被“高效”解决的问题。但“高效”在计算理论中有着严格的数学定义。本练习将探讨“多项式时间”这一概念的精确边界，解释为什么一个运行时间为 $O(n^{\\log_2 n})$ 的算法，尽管比指数时间快得多，但仍不符合 P 类的标准 [@problem_id:1460190]。这有助于我们清晰地界定这个至关重要的复杂性类的范围。", "problem": "在计算复杂性理论中，**P** 类被定义为所有可以由确定性图灵机在多项式时间内解决的判定问题的集合。如果一个算法对于规模为 $n$ 的输入，其运行时间 $T(n)$ 受 $O(n^k)$ 的限制，其中 $k$ 是某个**常数**非负整数，则称该算法在多项式时间内运行。\n\n假设一位计算机科学家为某个判定问题开发了一种新算法。该算法的最坏情况时间复杂度被确定为 $T(n) = O(n^{\\log_2 n})$。根据标准定义，这个新算法并不能证明该问题属于 **P** 类。\n\n以下哪个陈述为这一结论提供了正确的原因？\n\nA. 时间复杂度表达式中的指数 $\\log_2 n$ 是输入规模 $n$ 的函数，而不是一个固定常数。\n\nB. 时间复杂度 $O(n^{\\log_2 n})$ 是一种指数时间复杂度，根据定义，它不是多项式的。\n\nC. 任何包含对数项（如 $\\log_2 n$）的时间复杂度表达式都不能被归类为多项式时间。\n\nD. 指数的底数 $n$ 是表示输入规模的变量，而对于多项式时间，它必须是一个常数。\n\nE. 该问题可以在多项式时间内被验证，但给定的复杂度表明它不能在多项式时间内被解决。", "solution": "根据 P 类的定义，一个判定问题属于 P 类，如果存在一个常数非负整数 $k$ 和一个常数 $c>0$，使得对于所有足够大的输入规模 $n$，运行时间 $T(n)$ 满足 $T(n) \\leq c\\,n^{k}$，即 $T(n) = O(n^{k})$，其中 $k$ 与 $n$ 无关。\n\n给定的时间复杂度为 $T(n) = O(n^{\\log_{2}(n)})$。请注意，指数 $\\log_{2}(n)$ 依赖于 $n$，并且不是一个固定常数。因此，对于任何常数 $k$，$n^{\\log_{2}(n)}$ 都不具有 $n^{k}$ 的形式。仅凭这一点，我们就无法得出该算法在多项式时间内运行的结论。具体来说，对于任何固定的常数 $k$，因为当 $n \\to \\infty$ 时 $\\log_{2}(n) \\to \\infty$，所以存在一个 $N$，使得对于所有 $n > N$，都有 $\\log_{2}(n) > k$，这意味着\n$$\nn^{\\log_{2}(n)} > n^{k}.\n$$\n因此，对于每个固定的 $k$，$n^{\\log_{2}(n)} \\notin O(n^{k})$，这表明它是超多项式 (superpolynomial) 的。\n\n使用指数规则重写该复杂度也很有启发性：\n$$\nn^{\\log_{2}(n)} = 2^{\\log_{2}(n)\\cdot \\log_{2}(n)} = 2^{(\\log_{2}(n))^{2}},\n$$\n这表明其增长是次指数的 (subexponential)（因为对于任何 $a>0$，$(\\log_{2}(n))^{2} = o(n^{a})$，所以 $2^{(\\log_{2}(n))^{2}} = o(2^{n^{a}})$），但如上所述，它仍然是超多项式的。因此，陈述 B 是不正确的，因为 $O(n^{\\log_{2}(n)})$ 并不是通常意义上的指数时间，即对于某个常数 $c>1$ 的 $O(c^{n})$。\n\n陈述 C 是错误的，因为仅仅存在对数项并不排除多项式时间；例如，对于所有 $n \\geq 2$，$n\\log_{2}(n) \\leq n^{2}$，因此 $O(n\\log_{2}(n)) \\subseteq O(n^{2})$，这是多项式时间。陈述 D 是错误的，因为在多项式时间中，变量 $n$ 确实是底数，而指数是常数；声称底数必须是常数是一种误解。陈述 E 讨论了可验证性（一个 NP 概念），与仅基于给定上界来判断是否属于 P 类的标准无关。\n\n因此，正确的原因是指数不是一个固定常数，而是 $n$ 的函数。", "answer": "$$\\boxed{A}$$", "id": "1460190"}, {"introduction": "在复杂性分析中，我们很少从零开始分析一个新问题。更常见的方法是，我们使用一种称为“归约”的强大工具，将其与已知问题进行比较。本练习将阐释多项式时间归约 ($A \\le_p B$) 的基本逻辑，展示它如何让我们能够根据一个问题的复杂性来推断另一个问题的复杂性 [@problem_id:1460220]。掌握这一概念对于理解 NP 完全性理论至关重要。", "problem": "在计算复杂性理论中，我们根据解决问题所需的资源对问题进行分类。P 类包含所有可以由确定性图灵机在多项式时间内解决的判定问题。如果存在一个多项式时间算法，可以将问题 A 的任何实例转换为问题 B 的一个实例，使得问题 A 的原始实例的答案为“是”当且仅当问题 B 的转换实例的答案为“是”，那么我们称问题 A 可多项式归约到问题 B，记作 $A \\le_p B$。\n\n假设给定两个判定问题，问题 A 和问题 B。您已知以下两个事实：\n1. 问题 B 属于复杂性类 P。\n2. 问题 A 可多项式归约到问题 B ($A \\le_p B$)。\n\n仅根据这些信息，关于问题 A 的复杂性，您能得出的最准确的结论是什么？\n\nA. 问题 A 属于 P。\n\nB. 问题 A 是 NP-完全的。\n\nC. 问题 A 属于 NP，但无法确定其是否属于 P。\n\nD. 问题 A 必定至少与问题 B 一样难。\n\nE. 无法对问题 A 的复杂性得出任何有意义的结论。", "solution": "我们已知问题 B 属于 P，且问题 A 可多项式时间归约到问题 B，记作 $A \\le_{p} B$。根据多项式时间多一归约的定义，存在一个函数 $f$，使得对于任意输入 $x$，都有\n$$x \\in A \\iff f(x) \\in B,$$\n并且 $f$ 可由一台确定性图灵机在输入大小的多项式时间内计算得出。具体来说，存在一个多项式 $p$，使得计算 $f$ 的时间最多为 $p(|x|)$。此外，输出的大小也受多项式限制，即存在一个多项式 $s$，使得对于所有 $x$ 都有\n$$|f(x)| \\leq s(|x|) \\quad \\text{for all } x.$$\n\n因为 B 属于 P，所以存在一台确定性图灵机 $M_{B}$，它能在输入大小的多项式时间内判定 B。也就是说，存在一个多项式 $q$，使得对于任意输入 $y$，都有\n$$T_{B}(|y|) \\leq q(|y|).$$\n\n我们构造一个判定 A 的确定性算法如下：对于输入 $x$，计算 $y = f(x)$，然后在输入 $y$ 上运行 $M_{B}$ 并输出其判定结果。算法的正确性源于归约的性质 $x \\in A \\iff f(x) \\in B$。\n\n对于一个大小为 $|x| = n$ 的输入 $x$，其总运行时间 $T_{A}(n)$ 的上界为计算 $f(x)$ 的时间加上在 $y=f(x)$ 上判定 B 的时间：\n$$T_{A}(n) \\leq p(n) + q(|f(x)|).$$\n利用大小限制 $|f(x)| \\leq s(n)$，我们得到\n$$T_{A}(n) \\leq p(n) + q(s(n)).$$\n由于 $p$、$q$ 和 $s$ 都是多项式，复合函数 $q \\circ s$ 是一个多项式，而多项式之和也是一个多项式。因此，存在一个多项式 $t$，使得\n$$T_{A}(n) \\leq t(n),$$\n这表明 A 可在多项式时间内判定；即 $A \\in \\text{P}$。\n\n因此，最准确的结论是问题 A 属于 P。断言问题 A 是 NP-完全的、仅仅属于 NP、或者至少与 B 一样难的选项都是不成立的；实际上，$A \\le_{p} B$ 表明 A 的难度不高于 B。", "answer": "$$\\boxed{A}$$", "id": "1460220"}]}