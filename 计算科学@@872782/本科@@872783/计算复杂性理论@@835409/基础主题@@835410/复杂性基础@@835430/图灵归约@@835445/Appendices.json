{"hands_on_practices": [{"introduction": "在计算理论中，一个常见且强大的技术是利用一个能回答“是/否”问题的“判定”预言机来找到一个实际的解决方案，即解决一个“搜索”问题。本练习通过一个具体的项目调度场景，向你展示了如何应用这种方法。掌握这种从判定到搜索的归约是理解算法设计和计算复杂性之间联系的关键一步。[@problem_id:1468109]", "problem": "在计算复杂性理论领域，一种常见的技术是使用一个解决判定问题（一个“是/否”问题）的子程序来帮助解决相关的搜索问题（一个“找到一个例子”的问题）。本问题探讨了这样一种情景。\n\n假设您是一家资助机构的项目经理。您有一份拨款提案列表，每个提案都有一个要求的起始周和结束周。您的任务是选择一个尽可能大的拨款项目集合进行资助，但有一个限制条件：作为唯一的评审员，您不能评审两个时间区间重叠的拨款项目。\n\n您可以使用一个强大的、预先存在的计算子程序，名为 `HAS_SCHEDULE_OF_SIZE_K`。该子程序接受两个参数：一个拨款项目集合 `G` 和一个整数 `k`。如果存在一个大小至少为 `k` 的 `G` 的无冲突子集，它就返回 `True`，否则返回 `False`。如果两个拨款项目的时间区间重叠，则它们是冲突的。时间区间定义为 `[起始周, 结束周)`，这意味着它包括起始周，但不包括结束周。\n\n您的目标是使用这个 `HAS_SCHEDULE_OF_SIZE_K` 子程序来找到一个特定的、最大规模的、无冲突的拨款项目集合。您必须使用以下确定性算法：\n\n1.  首先，确定整个原始拨款项目集合 $T$ 的无冲突时间表的最大可能规模 $k_{max}$。\n2.  初始化一个空的时间表 $S = \\emptyset$ 和一个候选拨款项目集合 $U = T$。\n3.  按索引递增的顺序遍历原始集合 $T$ 中的每个拨款项目 $g$。\n    a. 让我们将当前考虑的拨款项目称为 $g_{current}$。如果 $g_{current}$ 不在当前的候选集合 $U$ 中，则跳过它。\n    b. 为了决定是否将 $g_{current}$ 添加到您的解决方案中，您必须确定它是否是一个“安全”的选择。一个选择是安全的，如果选择了 $g_{current}$ 之后，仍然有可能形成一个达到目标规模的完整时间表。为了测试这一点，构建一个临时集合 $U_{test}$，其中包含 $U \\setminus \\{g_{current}\\}$ 中所有与 $g_{current}$ 不冲突的拨款项目。\n    c. 查询预言机：`HAS_SCHEDULE_OF_SIZE_K(U_{test}, |S| + k_{max} - 1)`。等等，这行代码似乎过于复杂。让我们简化一下逻辑。\n\n让我们更清晰地重述构建阶段（步骤2和3）的核心逻辑：\n\n2.  初始化最终时间表 $S = \\emptyset$ 和可供考虑的拨款项目集合 $U = T$。\n3.  按索引顺序遍历原始集合 $T$ 中的拨款项目 $g_1, g_2, \\dots, g_n$。对于每个拨款项目 $g_i$：\n    a. 检查选择 $g_i$ 是否是一个“安全操作”。一个操作是安全的，如果承诺选择 $g_i$ 后，我们仍然可以形成一个最大规模的时间表。为了测试这一点，我们看是否可以从剩余的兼容拨款项目中形成一个大小为 ($k_{max} - |S| - 1$) 的时间表。具体来说，定义 $U_{compatible} = \\{ g' \\in U \\setminus \\{g_i\\} \\mid g' \\text{ 与 } g_i \\text{ 不冲突} \\}$。查询预言机：`HAS_SCHEDULE_OF_SIZE_K(U_{compatible}, k_{max} - |S| - 1)`。\n    b. 如果预言机返回 `True`，则 $g_i$ 是一个安全选择。将 $g_i$ 添加到您的时间表 $S$ 中，并将可用拨款项目集合 $U$ 更新为仅包含与您的新选择兼容的项目，即 $U = U_{compatible}$。\n    c. 如果预言机返回 `False`，则选择 $g_i$ 是一个死胡同。不要将其添加到 $S$ 中。只需将 $g_i$ 从可用拨款项目集合 $U$ 中移除，然后继续下一个拨款项目。\n\n给定以下六个拨款项目的集合 $T$，下面哪个选项代表您的算法将构建的最终时间表 $S$？拨款项目由其索引标识。\n\n-   $g_1$：（索引=1，开始=1，结束=5）\n-   $g_2$：（索引=2，开始=0，结束=3）\n-   $g_3$：（索引=3，开始=4，结束=7）\n-   $g_4$：（索引=4，开始=6，结束=9）\n-   $g_5$：（索引=5，开始=2，结束=4）\n-   $g_6$：（索引=6，开始=8，结束=10）\n\n选择列出最终时间表 $S$ 中拨款项目索引的选项。\n\nA. {1, 4}\n\nB. {3, 5, 6}\n\nC. {1, 4, 6}\n\nD. {2, 3, 6}", "solution": "给定六个拨款项目的（半开）区间：\n$g_{1}=[1,5)$, $g_{2}=[0,3)$, $g_{3}=[4,7)$, $g_{4}=[6,9)$, $g_{5}=[2,4)$, $g_{6}=[8,10)$。\n两个区间 $[a,b)$ 和 $[c,d)$ 如果重叠则发生冲突，即如果并非 $(b \\leq c$ 或 $d \\leq a)$。\n\n首先，确定 $T=\\{g_{1},\\dots,g_{6}\\}$ 的无冲突子集的最大可能规模 $k_{\\max}$。集合 $\\{g_{2},g_{3},g_{6}\\}$ 是无冲突的，因为 $[0,3)$ 在 $[4,7)$ 开始之前结束，而 $[4,7)$ 在 $[8,10)$ 开始之前结束，所以存在一个大小为 $3$ 的无冲突集合。为了确定上限，请注意在 $\\{g_{1},g_{2},g_{5}\\}$ 中最多只能选择一个（每对都重叠），在 $\\{g_{3},g_{4}\\}$ 中最多只能选择一个（它们重叠），而 $g_{6}$ 与 $g_{4}$ 重叠，但不与 $g_{3}$ 重叠。因此，总大小最多为 $1+1+1=3$。所以，\n$$\nk_{\\max}=3.\n$$\n\n现在使用 $S=\\emptyset$ 和 $U=T$ 运行构建过程，按索引顺序遍历 $g_{1},g_{2},\\dots,g_{6}$。在每一步中，对于当前 $g_{i}\\in U$，定义 $U_{\\text{compatible}}=\\{g'\\in U\\setminus\\{g_{i}\\}: g'\\text{ 与 }g_{i}\\text{ 不冲突}\\}$ 并查询\n$$\n\\text{HAS\\_SCHEDULE\\_OF\\_SIZE\\_K}\\big(U_{\\text{compatible}},\\,k_{\\max}-|S|-1\\big).\n$$\n\n考虑 $g_{1}=[1,5)$。它在 $U\\setminus\\{g_{1}\\}$ 中的兼容拨款项目是 $g_{4}=[6,9)$ 和 $g_{6}=[8,10)$，所以 $U_{\\text{compatible}}=\\{g_{4},g_{6}\\}$。使用 $k_{\\max}-|S|-1=3-0-1=2$ 进行查询，询问在 $\\{g_{4},g_{6}\\}$ 中是否存在一个大小至少为 $2$ 的无冲突子集。由于 $g_{4}$ 和 $g_{6}$ 重叠，最大的无冲突子集大小为 $1$，所以预言机返回 False。因此不添加 $g_{1}$；从 $U$ 中移除 $g_{1}$。\n\n考虑 $g_{2}=[0,3)$。此时 $U$ 为 $T\\setminus\\{g_{1}\\}$，与 $g_{2}$ 兼容的拨款项目是 $g_{3}$、$g_{4}$ 和 $g_{6}$，所以 $U_{\\text{compatible}}=\\{g_{3},g_{4},g_{6}\\}$。使用 $k_{\\max}-|S|-1=3-0-1=2$ 进行查询。在 $\\{g_{3},g_{4},g_{6}\\}$ 中，子集 $\\{g_{3},g_{6}\\}$ 是大小为 $2$ 的无冲突集合，所以预言机返回 True。因此 $g_{2}$ 是安全的；将其添加到 $S$ 并设置 $U=\\{g_{3},g_{4},g_{6}\\}$。\n\n考虑 $g_{3}=[4,7)$。在 $U\\setminus\\{g_{3}\\}=\\{g_{4},g_{6}\\}$ 中，只有 $g_{6}$ 与 $g_{3}$ 兼容，所以 $U_{\\text{compatible}}=\\{g_{6}\\}$。使用 $k_{\\max}-|S|-1=3-1-1=1$ 进行查询。由于 $\\{g_{6}\\}$ 有一个大小为 $1$ 的无冲突子集，预言机返回 True。将 $g_{3}$ 添加到 $S$ 并设置 $U=\\{g_{6}\\}$。\n\n考虑 $g_{4}$。它不在 $U$ 中，所以跳过。\n\n考虑 $g_{5}$。它不在 $U$ 中，所以跳过。\n\n考虑 $g_{6}=[8,10)$。现在 $U\\setminus\\{g_{6}\\}=\\emptyset$，所以 $U_{\\text{compatible}}=\\emptyset$。使用 $k_{\\max}-|S|-1=3-2-1=0$ 进行查询。一个大小至少为 $0$ 的子集总是存在的（空集），所以预言机返回 True。将 $g_{6}$ 添加到 $S$ 并设置 $U=\\emptyset$。\n\n算法终止，得到 $S=\\{g_{2},g_{3},g_{6}\\}$，对应选项 D。", "answer": "$$\\boxed{D}$$", "id": "1468109"}, {"introduction": "理解归约的形式化属性对于深入研究计算理论至关重要。这个练习探讨了图灵归约的一个基本性质：如果一个问题可以用某个预言机解决，那么它的反问题（补集）也可以用同一个预言机解决。通过构造一个简单的“答案翻转”机制，这个练习将加深你对图灵归约定义的理解。[@problem_id:1468144]", "problem": "在计算复杂性理论的研究中，我们经常使用可归约性的概念来分析不同判定问题之间的关系。设 $A$ 和 $B$ 是两个语言，它们是基于同一字母表 $\\Sigma$ 的字符串集合。语言 $A$ 的补集，记作 $\\overline{A}$，是 $\\Sigma^*$ 中所有不属于 $A$ 的字符串的集合。\n\n如果存在一个使用语言 $B$ 的谕示来判定语言 $A$ 的谕示图灵机（OTM），我们称语言 $A$ 图灵可归约于语言 $B$，记作 $A \\le_T B$。“判定器”是一种图灵机，它保证在所有输入上都会停机，并且总是以“接受”或“拒绝”状态结束。语言 $B$ 的谕示可以被看作一个黑盒，它可以瞬间回答任何给定的字符串 $q$ 是否是语言 $B$ 的成员。\n\n假设给定一个 OTM，我们称之为 $M_A$，它是语言 $A$ 的一个判定器，并使用语言 $B$ 的谕示。这意味着对于任何输入字符串 $w$：\n- 如果 $w \\in A$，$M_A$ 停机并接受。\n- 如果 $w \\notin A$，$M_A$ 停机并拒绝。\n\n你的任务是确定如何构建一个新的 OTM，我们称之为 $M_{\\overline{A}}$，它使用相同的语言 $B$ 的谕示来判定补集语言 $\\overline{A}$。对于任意给定的输入字符串 $w$，下列哪个陈述正确且完整地描述了这样一台机器 $M_{\\overline{A}}$ 的行为？\n\nA. 在输入 $w$ 上，$M_{\\overline{A}}$ 模拟 $M_A$ 在 $w$ 上的运行。如果 $M_A$ 的模拟停机并接受，那么 $M_{\\overline{A}}$ 停机并拒绝。如果 $M_A$ 的模拟停机并拒绝，那么 $M_{\\overline{A}}$ 停机并接受。\n\nB. 在输入 $w$ 上，$M_{\\overline{A}}$ 模拟 $M_A$ 在 $w$ 上的运行。然而，每当被模拟的 $M_A$ 向其 $B$ 的谕示查询字符串 $q$ 时，新机器 $M_{\\overline{A}}$ 会首先使用一个独立的子程序来判定 $q \\in \\overline{B}$，并向模拟提供相反的答案。这需要一个 $\\overline{B}$ 的谕示。\n\nC. 在输入 $w$ 上，$M_{\\overline{A}}$ 模拟 $M_A$ 在 $w$ 上的运行。如果 $M_A$ 将进入其接受状态，$M_{\\overline{A}}$ 就进入其拒绝状态。如果 $M_A$ 将进入其拒绝状态，$M_{\\overline{A}}$ 就进入其接受状态。如果 $M_A$ 在输入 $w$ 上会无限循环，$M_{\\overline{A}}$ 也会无限循环。\n\nD. 不可能仅使用 $B$ 的谕示来构造一个判定 $\\overline{A}$ 的谕示图灵机 $M_{\\overline{A}}$。必要的信息不可用。\n\nE. 在输入 $w$ 上，$M_{\\overline{A}}$ 运行 $M_A$ 在 $w$ 上的模拟。如果 $M_A$ 的模拟接受了，$M_{\\overline{A}}$ 就接受；如果 $M_A$ 的模拟拒绝了，$M_{\\overline{A}}$ 就拒绝，实际上是复制了 $M_A$ 的行为。", "solution": "我们给定一个使用语言 $B$ 的谕示来判定 $A$ 的谕示图灵机 $M_{A}$。根据判定器的定义，对于每个输入 $w \\in \\Sigma^{*}$，如果 $w \\in A$，机器 $M_{A}$ 会停机并接受；如果 $w \\notin A$，它会停机并拒绝。\n\n要构造一个使用相同的 $B$ 的谕示来判定 $\\overline{A}$ 的谕示图灵机 $M_{\\overline{A}}$，请在输入 $w$ 上按以下步骤操作：\n- 在输入 $w$ 上模拟 $M_{A}$，将每个谕示查询 $q$ 直接转发给 $B$ 的谕示，并使用谕示的答案继续模拟。这只使用了 $B$ 的谕示。\n- 当被模拟的 $M_{A}$ 停机时，反转其判定结果：如果它接受，则拒绝；如果它拒绝，则接受。\n\n正确性证明：\n- 如果 $w \\in \\overline{A}$，那么 $w \\notin A$。由于 $M_{A}$ 判定 $A$，它会在 $w$ 上停机并拒绝。因此，$M_{\\overline{A}}$ 将此结果翻转为接受，所以 $M_{\\overline{A}}$ 恰好接受那些 $w \\in \\overline{A}$。\n- 如果 $w \\notin \\overline{A}$，那么 $w \\in A$。由于 $M_{A}$ 判定 $A$，它会在 $w$ 上停机并接受。因此，$M_{\\overline{A}}$ 将此结果翻转为拒绝，所以 $M_{\\overline{A}}$ 恰好拒绝那些 $w \\notin \\overline{A}$。\n- 停机性：因为 $M_{A}$ 在所有输入上都会停机，所以模拟在所有输入上也会停机，并且反转步骤也会停机。因此 $M_{\\overline{A}}$ 是一个判定器。\n\n在这些选项中，这个行为被选项 A 精确地描述了。选项 B 错误地要求一个 $\\overline{B}$ 的谕示。选项 C 引入了一个关于无限循环的不必要且可能产生误导的条款；虽然在给定 $M_{A}$ 是一个判定器的假设下，这个条款是空洞地为真，但它不是对判定器构造的一个清晰的描述。选项 D 是错误的，而选项 E 是不正确的，因为它没有反转判定结果。", "answer": "$$\\boxed{A}$$", "id": "1468144"}, {"introduction": "图灵归约不仅适用于可判定问题，更是在不可判定领域中比较问题难度的核心工具。这个经典的练习将带你进入计算理论的核心地带，探索两个著名的不可判定问题——停机问题和全集问题——之间的关系。通过为一个问题构造一个巧妙的“代理”图灵机，你将学会如何证明一个不可判定问题至少和另一个一样“难”。[@problem_id:1468089]", "problem": "在理论计算机科学领域，我们通常根据计算难度对问题进行分类。两个著名的不可判定问题与图灵机（TM）的行为有关，图灵机是一种计算的数学模型。\n\n第一个是停机问题（Halting Problem），它询问给定的图灵机 $M$ 是否会在特定的输入字符串 $w$ 上停机。与此问题对应的语言表示为 $HALT_{TM} = \\{ \\langle M, w \\rangle \\mid M \\text{ 是一台图灵机且 } M \\text{ 在输入 } w \\text{ 上停机} \\}$。\n\n第二个问题询问一台图灵机是否会对*每一个*可能的输入停机。该问题的语言是 $TOTAL_{TM} = \\{ \\langle M \\rangle \\mid M \\text{ 是一台图灵机且 } M \\text{ 在所有输入上都停机} \\}$。\n\n尽管这两种语言都是不可判定的，但可以使用一个假设的设备——称为另一语言的“预言机”（oracle）——来解决其中一个。$TOTAL_{TM}$ 的预言机是一个黑盒字程序，当给定任意图灵机 $\\langle M' \\rangle$ 的描述时，它可以立即并正确地确定 $\\langle M' \\rangle \\in TOTAL_{TM}$ 是否成立。\n\n你的任务是为一台新的图灵机（我们称之为 $M'$）确定正确的设计，该图灵机可以与 $TOTAL_{TM}$ 预言机结合使用，以判定停机问题的一个任意实例 $\\langle M, w \\rangle$。整个判定过程如下：\n1. 接收一个输入 $\\langle M, w \\rangle$。\n2. 基于 $M$ 和 $w$ 构造一台新图灵机 $M'$ 的描述。\n3. 用 $\\langle M' \\rangle$ 查询 $TOTAL_{TM}$ 预言机。\n4. 预言机对 $M'$ 的是/否回答必须直接对应于 $M$ 是否在 $w$ 上停机的是/否回答。\n\n以下哪项关于 $M'$ 在任意输入 $x$ 上的行为描述构成了用于此目的的正确设计？\n\nA. 对于任何输入 $x$，机器 $M'$ 忽略 $x$ 并模拟 $M$ 在固定字符串 $w$ 上的运行。$M'$ 停机当且仅当 $M$ 在 $w$ 上的模拟停机。\n\nB. 对于任何输入 $x$，机器 $M'$ 模拟 $M$ 在该输入 $x$ 上的运行。$M'$ 停机当且仅当 $M$ 在 $x$ 上的模拟停机。\n\nC. 对于任何输入 $x$，机器 $M'$ 忽略 $x$ 并模拟 $M$ 在固定字符串 $w$ 上的运行。如果 $M$ 的模拟停机，$M'$ 就进入一个无限循环。如果 $M$ 的模拟不停机，$M'$ 就立即停机。\n\nD. 对于任何输入 $x$，机器 $M'$ 首先模拟 $M$ 在固定字符串 $w$ 上的运行。如果此模拟停机，$M'$ 接着模拟 $M$ 在其自身输入 $x$ 上的运行，并且当且仅当这第二个模拟停机时，$M'$ 才停机。\n\nE. 这种对 $M'$ 的构造是不可能的，因为 $HALT_{TM}$ 和 $TOTAL_{TM}$ 都定义了不可判定的语言。", "solution": "我们给定了一个用于 $TOTAL_{TM}=\\{\\langle N\\rangle\\mid N\\text{ 在所有输入上都停机}\\}$ 的预言机。要使用这个预言机来判定 $HALT_{TM}=\\{\\langle M,w\\rangle\\mid M\\text{ 在 }w\\text{ 上停机}\\}$，我们必须对于一个任意输入 $\\langle M,w\\rangle$，构造一台图灵机 $M'$，使得\n$$\n\\langle M,w\\rangle\\in HALT_{TM}\\iff \\langle M'\\rangle\\in TOTAL_{TM}.\n$$\n这要求 $M'$ 是全函数（total）当且仅当 $M$ 在 $w$ 上停机。\n\n考虑选项 A 中描述的构造：定义 $M'$，使其在任何输入 $x$ 上都忽略 $x$ 并模拟 $M$ 在固定输入 $w$ 上的运行，当且仅当该模拟停机时，$M'$ 才停机。\n\n我们验证其等价性：\n- 假设 $M$ 在 $w$ 上停机。那么由 $M'$ 执行的对 $M$ 在 $w$ 上的模拟会停机。因为 $M'$ 忽略其输入 $x$，所以对于每个 $x$ 都会发生相同的行为。因此，对于所有 $x$，$M'(x)$ 都会停机，所以 $\\langle M'\\rangle\\in TOTAL_{TM}$。\n- 反之，假设 $M$ 在 $w$ 上不停机。那么 $M'$ 中的模拟永不停止，并且因为 $M'$ 忽略 $x$，所以对于每个 $x$，$M'(x)$ 都不会停机。因此，$\\langle M'\\rangle\\notin TOTAL_{TM}$。\n\n综合以上两点，\n$$\n\\langle M,w\\rangle\\in HALT_{TM}\\iff \\langle M'\\rangle\\in TOTAL_{TM}.\n$$\n因此，在 $\\langle M'\\rangle$ 上查询 $TOTAL_{TM}$ 预言机会得到“是”的回答，当且仅当 $M$ 在 $w$ 上停机，这与对 $HALT_{TM}$ 所需的判定完全匹配。\n\n为了完整起見，其他选项未能产生所需的等价性：\n- 选项 B 使 $M'$ 成为全函数当且仅当 $M$ 是全函数，这并不能反映 $M$ 是否在特定输入 $w$ 上停机。\n- 选项 C 反转了对应关系：$M'$ 是全函数当且仅当 $M$ 不在 $w$ 上停机，因此预言机的“是”回答将意味着 $M$ 不在 $w$ 上停机，而不是直接的对应关系。\n- 选项 D 使得 $M'$ 成为全函数，仅当 $M$ 在 $w$ 上停机且 $M$ 在所有输入上都停机时；因此，它是在确认 $M$ 在 $w$ 上停机后，再判定 $M$ 是否是全函数，这不符合所需属性。\n- 选项 E 是不正确的，因为通过选项 A 中的构造，存在从 $HALT_{TM}$ 到 $TOTAL_{TM}$ 的预言机归约。\n\n因此，正确的设计是选项 A。", "answer": "$$\\boxed{A}$$", "id": "1468089"}]}