{"hands_on_practices": [{"introduction": "我们从卷积神经网络（CNN）架构的一个基本问题开始：如何控制特征图的尺寸。在本实践中，我们将推导出一个卷积层的输出要保持与输入相同的高度和宽度（即“same”卷积）所需的精确填充量。这项练习将深化你对卷积核大小、步长和空洞率如何相互作用并共同决定层几何形状的理解。[@problem_id:3126176]", "problem": "考虑卷积神经网络（CNN）中的一个二维卷积层，该层作用于一个高度为 $H$、宽度为 $W$ 的输入特征图。该层使用大小为 $k \\times k$ 的方形卷积核，两个空间维度上的膨胀（dilation）为 $d$，步幅（stride）为 $s$，并在空间边界上应用零填充（zero-padding）。假设使用通用库中实现的标准互相关（即没有卷积核翻转），并且每个空间维度两侧的填充量均为整数值。\n\n从网格上的离散卷积以及膨胀和步幅的定义出发，推导输出高度独立于 $H$ 等于输入高度的条件，以及宽度的类似条件。证明该条件强制要求每个空间维度的总填充量、有效感受野和步幅之间存在特定的关系。然后，假设对于所有 $H$ 都能保持空间大小的唯一允许选择是 $s=1$，推导每个空间维度的最小总填充量 $P_{\\text{total}}(d,k)$ 的封闭形式表达式，该表达式保证输出高度和宽度分别等于 $H$ 和 $W$。在你的推导中，解释为什么当 $k$ 为奇数时，对称的每侧填充 $p = \\frac{d\\,(k-1)}{2}$ 可以实现精确的“相同”卷积（\"same\" convolution），并分析当 $k$ 为偶数时出现的“差一”不对称性，根据 $d$ 的奇偶性区分不同情况。\n\n仅报告 $P_{\\text{total}}(d,k)$ 的单一封闭形式表达式作为你的最终答案。不包含任何单位。无需进行数值四舍五入。", "solution": "问题要求推导所需的最小总填充量 $P_{\\text{total}}(d, k)$，以确保二维卷积层的输出空间维度与输入空间维度相同，这种配置通常被称为“相同”卷积（\"same\" convolution）。我们首先将输入和输出维度之间的关系形式化。\n\n设输入特征图的一个空间维度大小为 $N_{in}$（代表高度 $H$ 或宽度 $W$）。卷积层有一个大小为 $k$ 的卷积核、膨胀因子 $d$、步幅 $s$，以及沿该维度应用的总零填充量 $P_{\\text{total}}$。填充由两侧的整数值填充量 $p_{left}$ 和 $p_{right}$ 组成，使得 $P_{\\text{total}} = p_{left} + p_{right}$。\n\n卷积核的有效大小，即其感受野范围，不仅仅是 $k$，而是通过膨胀被扩大了。膨胀后的卷积核覆盖了 $k_{eff}$ 个输入元素的范围，由下式给出：\n$$k_{eff} = d \\cdot (k-1) + 1$$\n这个公式的由来是：$k$ 个卷积核权重之间有 $k-1$ 个间隙，每个间隙的大小为 $d-1$。总范围是权重的数量加上间隙的总大小：$k + (k-1)(d-1) = k + kd - k - d + 1 = kd - d + 1 = d(k-1) + 1$。\n\n应用总填充 $P_{\\text{total}}$ 后，输入维度的有效大小变为 $N_{in} + P_{\\text{total}}$。膨胀后的卷积核左上角元素在这个填充后的输入上可能的位置数量是 $(N_{in} + P_{\\text{total}}) - k_{eff} + 1$。对于步幅 $s$，输出元素的数量 $N_{out}$ 由标准公式给出：\n$$N_{out} = \\left\\lfloor \\frac{(N_{in} + P_{\\text{total}}) - k_{eff}}{s} \\right\\rfloor + 1$$\n代入 $k_{eff}$ 的表达式，我们得到：\n$$N_{out} = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - (d(k-1) + 1)}{s} \\right\\rfloor + 1$$\n\n第一个任务是找到对于任何输入大小 $N_{in} \\ge 1$，$N_{out} = N_{in}$ 都成立的条件。\n设 $N_{out} = N_{in}$：\n$$N_{in} = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s} \\right\\rfloor + 1$$\n$$N_{in} - 1 = \\left\\lfloor \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s} \\right\\rfloor$$\n根据向下取整函数（floor function）的定义，$\\lfloor x \\rfloor = y$ 等价于 $y \\le x  y+1$。应用此定义，我们得到双重不等式：\n$$N_{in} - 1 \\le \\frac{N_{in} + P_{\\text{total}} - d(k-1) - 1}{s}  N_{in}$$\n两边乘以 $s$（其中 $s \\ge 1$ 是一个正整数）：\n$$s(N_{in} - 1) \\le N_{in} + P_{\\text{total}} - d(k-1) - 1  s N_{in}$$\n这个不等式必须对所有 $N_{in} \\ge 1$ 的值都成立。我们重新整理各项以分离出 $N_{in}$：\n$$(s-1)N_{in} - s \\le P_{\\text{total}} - d(k-1) - 1  (s-1)N_{in}$$\n为了使这个不等式对所有 $N_{in}$ 都成立，依赖于 $N_{in}$ 的项不能让中间的常数项逸出边界。如果 $s > 1$，那么 $s-1 > 0$，下界 $(s-1)N_{in} - s$ 和上界 $(s-1)N_{in}$ 都随 $N_{in}$ 增长。它们之间的区间 $[(s-1)N_{in} - s, (s-1)N_{in})$ 的宽度固定为 $s$，但其位置会移动。一个常数值 $P_{\\text{total}} - d(k-1) - 1$ 不可能对所有的 $N_{in}$ 都停留在这个移动的区间内。满足该条件的唯一方法是使 $N_{in}$ 的系数为零。这强制要求 $s-1=0$，即 $s=1$。\n\n这个推导证实了问题的假设，即 $s=1$ 是独立于输入维度保持空间大小所必需的。当 $s=1$ 时，不等式简化为：\n$$-1 \\le P_{\\text{total}} - d(k-1) - 1  0$$\n由于 $P_{\\text{total}}$、$d$ 和 $k$ 都是整数，表达式 $P_{\\text{total}} - d(k-1) - 1$ 必须是一个整数。满足 $-1 \\le z  0$ 的唯一整数 $z$ 是 $z=-1$。因此，我们必须有：\n$$P_{\\text{total}} - d(k-1) - 1 = -1$$\n$$P_{\\text{total}} = d(k-1)$$\n这是在 $s=1$ 时保证 $N_{out} = N_{in}$ 的唯一总填充值。因此，它是最小且唯一的值。我们可以将其表示为 $P_{\\text{total}}(d,k) = d(k-1)$。\n\n问题还要求证明这会强制总填充量、有效感受野和步幅之间存在一种关系。我们有 $s=1$ 和 $P_{\\text{total}} = d(k-1)$。有效感受野是 $k_{eff} = d(k-1)+1$。因此，关系是 $P_{\\text{total}} = k_{eff} - 1$。\n\n最后，我们分析这个总填充量的实现方式。$P_{\\text{total}}$ 必须被分成两侧的填充量 $p_{left}$ 和 $p_{right}$，且它们必须是整数。\n如果 $k$ 是奇数，那么 $k-1$ 是偶数。因此，所需的总填充量 $P_{\\text{total}} = d(k-1)$ 始终是一个偶数，无论 $d$ 是奇数还是偶数。一个偶数的总填充量可以被完美地平衡，允许在每侧进行对称填充：\n$$p = p_{left} = p_{right} = \\frac{P_{\\text{total}}}{2} = \\frac{d(k-1)}{2}$$\n这保持了输出特征图与输入的空间对齐。\n\n如果 $k$ 是偶数，那么 $k-1$ 是奇数。总填充量 $P_{\\text{total}} = d(k-1)$ 的奇偶性现在取决于膨胀 $d$ 的奇偶性。\n- 如果 $d$ 是偶数，$P_{\\text{total}}$ 是偶数（偶数 $\\times$ 奇数 = 偶数）。此时同样可以进行对称填充 $p = \\frac{d(k-1)}{2}$。\n- 如果 $d$ 是奇数，$P_{\\text{total}}$ 是奇数（奇数 $\\times$ 奇数 = 奇数）。由于 $P_{\\text{total}}$ 是奇数，它不能被分成两个相等的整数部分。这强制要求进行不对称填充，即 $p_{left} \\neq p_{right}$。例如，可以选择 $p_{left} = \\lfloor \\frac{P_{\\text{total}}}{2} \\rfloor = \\frac{d(k-1)-1}{2}$ 和 $p_{right} = \\lceil \\frac{P_{\\text{total}}}{2} \\rceil = \\frac{d(k-1)+1}{2}$。这种不可避免的不对称性导致输出特征图相对于输入产生半个像素的空间偏移，这就是所提到的“差一”不对称性。\n\n尽管存在关于对称或不对称应用的这些实现细节，每个维度所需的总填充量是唯一确定的。保证输出大小等于输入大小的最小总填充量的封闭形式表达式是 $P_{\\text{total}}(d,k) = d(k-1)$。", "answer": "$$\n\\boxed{d(k-1)}\n$$", "id": "3126176"}, {"introduction": "在我们理解了如何计算填充之后，本实践将通过编程练习来探索不同填充策略的实际影响。我们将研究“零填充”和“循环填充”如何影响卷积的输出，尤其是在图像边界附近。这将帮助你建立关于边界伪影的直观认识，并理解在何种情境下一种填充选择可能优于另一种。[@problem_id:3111157]", "problem": "您将研究在卷积神经网络（CNN）中通常称为卷积的离散二维操作中，填充（padding）选择所带来的影响。在CNN实践中，使用的操作是二维离散互相关（cross-correlation），其核（kernel）具有有限支撑集（finite support），应用于输入图像，并根据给定的填充规则进行评估。您的任务是比较在合成周期性纹理上，半径为 $p$ 的循环填充（circular padding）与零填充（zero padding）的效果，并检验循环填充能减少边界伪影（boundary artifacts）这一假设。您必须编写一个完整且可运行的程序，为每个测试用例计算一个布尔结果，并按如下规定将它们作为单个列表在一行中输出。\n\n基本原理和定义：\n- 令 $I \\in \\mathbb{R}^{N \\times N}$ 为一个离散图像，由像素坐标 $(i,j)$ 索引，其中 $i \\in \\{0,\\dots,N-1\\}$ 且 $j \\in \\{0,\\dots,N-1\\}$。\n- 令 $K \\in \\mathbb{R}^{k \\times k}$ 为一个有限支撑集核，其中 $k$ 为奇数，并定义核的半宽为 $p = \\lfloor k/2 \\rfloor$。\n- $I$ 与 $K$ 的CNN互相关（在实践中常被称为卷积），记为 $O = I \\star K$，在像素 $(i,j)$ 处的定义为\n$$\nO[i,j] \\;=\\; \\sum_{u=-p}^{p} \\sum_{v=-p}^{p} K[u+p,v+p] \\cdot \\widetilde{I}[i+u,\\, j+v],\n$$\n其中 $\\widetilde{I}$ 的扩展规则取决于填充方案：\n    - 零填充：对于 $\\{0,\\dots,N-1\\} \\times \\{0,\\dots,N-1\\}$ 范围外的任何 $(x,y)$，设置 $\\widetilde{I}[x,y] = 0$。\n    - 循环填充：将索引对 $N$ 取模，即 $\\widetilde{I}[x,y] = I[x \\bmod N,\\, y \\bmod N]$。\n- 此处的周期性纹理是一个函数 $I$，它由离散正弦波构成，其参数是 $2\\pi/N$ 的整数倍，因此 $I$ 在边长为 $N$ 的离散环面（discrete torus）上满足周期性边界条件。\n- 定义两个数组 $A,B \\in \\mathbb{R}^{N \\times N}$ 在掩码（mask）$M \\in \\{0,1\\}^{N \\times N}$ 上的均方误差（MSE）为\n$$\n\\mathrm{MSE}_M(A,B) \\;=\\; \n\\begin{cases}\n\\frac{1}{m} \\sum_{i=0}^{N-1}\\sum_{j=0}^{N-1} M[i,j]\\;\\big(A[i,j]-B[i,j]\\big)^2,  \\text{若 } m = \\sum M[i,j]  0,\\\\\n0,  \\text{若 } m = 0.\n\\end{cases}\n$$\n- 定义宽度为 $p$ 的边界环形掩码（boundary ring mask）为：如果 $i \\in \\{0,\\dots,p-1\\} \\cup \\{N-p,\\dots,N-1\\}$ 或 $j \\in \\{0,\\dots,p-1\\} \\cup \\{N-p,\\dots,N-1\\}$，则 $M_{\\mathrm{bdry}}[i,j] = 1$，否则 $M_{\\mathrm{bdry}}[i,j] = 0$。定义内部掩码为 $M_{\\mathrm{int}} = 1 - M_{\\mathrm{bdry}}$。\n\n待检验的假设：\n- 对于周期性纹理 $I$，循环填充与离散环面上的预期计算相匹配，因此相对于零填充能减少边界伪影。操作上，对于相同的 $I$ 和 $K$：\n    - 零填充输出相对于循环填充输出的边界环均方误差，严格大于循环填充输出相对于其自身的边界环均方误差。\n    - 在内部区域，两种填充方案都应与环面计算一致，因此内部均方误差在数值上应可忽略不计。\n\n程序要求：\n- 使用以下公式构造大小为 $N \\times N$ 的合成周期性纹理 $I$：\n$$\nI[i,j] \\;=\\; a_1 \\sin\\!\\Big(\\tfrac{2\\pi f_1}{N}\\, i\\Big) \\;+\\; a_2 \\cos\\!\\Big(\\tfrac{2\\pi f_2}{N}\\, j\\Big) \\;+\\; a_3 \\sin\\!\\Big(\\tfrac{2\\pi}{N}\\,(f_3 i + f_4 j)\\Big),\n$$\n其中振幅 $a_1,a_2,a_3$ 和整数频率 $f_1,f_2,f_3,f_4$ 在下文每个测试用例中指定。\n- 对每个测试用例，计算三个输出：\n    - $T$：使用循环填充计算的参考输出（这代表在离散环面上的预期操作）。\n    - $C$：使用循环填充计算的输出（与用于 $T$ 的算子相同）。\n    - $Z$：使用零填充计算的输出。\n- 对每个测试用例，使用上面定义的宽度为 $p=\\lfloor k/2 \\rfloor$ 的边界和内部掩码，计算四个均方误差：$\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T)$、$\\mathrm{MSE}_{\\mathrm{bdry}}(C,T)$、$\\mathrm{MSE}_{\\mathrm{int}}(Z,T)$ 和 $\\mathrm{MSE}_{\\mathrm{int}}(C,T)$。\n- 当且仅当以下两个条件同时成立时，判定该测试用例的布尔结果为真：\n    - 边界伪影减少：$\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T) > \\mathrm{MSE}_{\\mathrm{bdry}}(C,T) + \\varepsilon$。\n    - 内部一致性：$\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$ 且 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) \\le \\varepsilon$。\n此处 $\\varepsilon$ 是一个小的数值容差，您必须将其设置为一个合理的固定值（例如，$\\varepsilon = 10^{-12}$）。\n\n测试套件（为覆盖性而设计的三个案例）：\n- 案例1（理想路径，较大图像，平滑核）：\n    - $N = 64$。\n    - 核尺寸 $k=5$，填充半径 $p=2$。\n    - 核 $K$ 是一个归一化的盒式滤波器（box filter）：对于所有 $u,v \\in \\{-2,-1,0,1,2\\}$，设置 $K[u+p,v+p] = 1/25$。\n    - 纹理参数：$a_1 = 0.6$, $a_2 = 0.35$, $a_3 = 0.25$, $f_1 = 4$, $f_2 = 7$, $f_3 = 9$, $f_4 = 5$。\n- 案例2（不同核类型，中等图像）：\n    - $N = 17$。\n    - 核尺寸 $k=3$，填充半径 $p=1$。\n    - 核 $K$ 是 $3 \\times 3$ 的离散拉普拉斯算子\n    $$\n    K \\;=\\; \\begin{bmatrix}\n    0  -1  0\\\\\n    -1  4  -1\\\\\n    0  -1  0\n    \\end{bmatrix}.\n    $$\n    - 纹理参数：$a_1 = 0.5$, $a_2 = 0.4$, $a_3 = 0.3$, $f_1 = 3$, $f_2 = 5$, $f_3 = 2$, $f_4 = 1$。\n- 案例3（边界主导场景，小图像，与图像同尺寸的核）：\n    - $N = 5$。\n    - 核尺寸 $k=5$，填充半径 $p=2$。\n    - 核 $K$ 与案例1中相同，是归一化的盒式滤波器。\n    - 纹理参数：$a_1 = 0.75$, $a_2 = 0.25$, $a_3 = 0.5$, $f_1 = 1$, $f_2 = 2$, $f_3 = 1$, $f_4 = 1$。\n\n最终输出格式要求：\n- 您的程序应生成一行输出，其中包含三个测试用例的布尔结果，以方括号括起来的逗号分隔列表形式表示，无空格，并按案例1、2、3的顺序排列。例如：`[True,False,True]`。\n\n角度单位和物理单位：\n- 三角函数内部使用的所有角度都以弧度为单位。\n- 没有物理单位；所有量均为无量纲实数。\n\n约束条件：\n- 您必须直接在代码中实现这些操作，不得依赖外部文件或用户输入。除了Python标准库外，唯一允许的库是执行环境中指定的库。容差 $\\varepsilon$ 必须是固定的，并且对所有情况都相同。", "solution": "该问题要求研究填充对二维离散互相关操作的影响，该操作在卷积神经网络（CNN）的背景下通常被称为卷积。我们需要检验一个假设：对于具有周期性边界条件的信号，循环填充在减轻边界伪影方面优于零填充。\n\n这一假设的理论基础在于离散傅里叶变换（DFT）的性质。离散卷积定理指出，空间域中的循环卷积等价于频域中的逐元素乘积。具体来说，如果 $O = I \\circledast K$，其中 $\\circledast$ 表示循环卷积，则 $\\mathcal{F}(O) = \\mathcal{F}(I) \\odot \\mathcal{F}(K)$，其中 $\\mathcal{F}$ 是DFT，$\\odot$ 是哈达玛（逐元素）积。问题中定义的周期性纹理可以由其离散傅里叶谱完美表示。通过循环填充实现的循环卷积，尊重了信号的周期性，并正确地在离散环面 $\\mathbb{Z}_N \\times \\mathbb{Z}_N$ 上计算了该操作。相比之下，零填充通过在信号周围填充零来有效地在边界处截断信号，当边界处的信号值非零时，这会引入高频伪影。这种不连续性违反了信号固有的周期性。\n\n问题将操作指定为互相关：\n$$\nO[i,j] \\;=\\; \\sum_{u=-p}^{p} \\sum_{v=-p}^{p} K[u+p,v+p] \\cdot \\widetilde{I}[i+u,\\, j+v]\n$$\n其中 $k$ 是核大小，$p = \\lfloor k/2 \\rfloor$ 是核的半宽，$\\widetilde{I}$ 是填充后的输入图像。离散卷积会在求和中使用 $\\widetilde{I}[i-u, j-v]$。然而，对于一个点对称的核 $K$，即 $K[u+p, v+p] = K[-u+p, -v+p]$，互相关和卷积的操作是相同的。所有三个测试用例中使用的核——归一化盒式滤波器和离散拉普拉斯算子——确实是对称的。因此，从卷积定理推导出的逻辑直接适用。\n\n检验该假设的方法如下：\n1.  **生成参考输出 $T$**：这是使用循环填充计算的。它代表了在离散环面上执行互相关的基准真相，这对于周期性输入信号 $I$ 来说是数学上理想的操作。\n2.  **生成测试输出**：我们计算两个输出：使用循环填充的 $C$ 和使用零填充的 $Z$。根据定义，$C$ 将与 $T$ 相同。\n3.  **评估性能**：我们使用均方误差（MSE）将 $Z$ 与参考 $T$ 进行比较，该比较分为两个区域：宽度为 $p$ 的边界环和内部区域。MSE 定义为：\n    $$\n    \\mathrm{MSE}_M(A,B) \\;=\\; \\frac{1}{\\sum M} \\sum_{i,j} M[i,j]\\;\\big(A[i,j]-B[i,j]\\big)^2\n    $$\n    其中 $M$ 是边界掩码 $M_{\\mathrm{bdry}}$ 或内部掩码 $M_{\\mathrm{int}}$。\n4.  **假设验证**：对于给定的测试用例，如果满足由小容差 $\\varepsilon=10^{-12}$ 控制的两个条件，则认为假设为真：\n    a. **边界伪影减少**：零填充在边界区域的误差必须显著大于循环填充的误差。由于循环填充的误差 $\\mathrm{MSE}_{\\mathrm{bdry}}(C,T)$ 根据定义为零（在机器精度范围内），这简化为 $\\mathrm{MSE}_{\\mathrm{bdry}}(Z,T) > \\varepsilon$。\n    b. **内部一致性**：在远离边界的区域，两种填充方法应产生相同的结果，因为核的支撑集不会超出图像的原始域。因此，两种填充方案在内部的误差都必须可以忽略不计：$\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$ 和 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) \\le \\varepsilon$。由于 $\\mathrm{MSE}_{\\mathrm{int}}(C,T) = 0$，这实际上是检验 $\\mathrm{MSE}_{\\mathrm{int}}(Z,T) \\le \\varepsilon$。\n\n实现将首先定义用于生成周期性纹理 $I$、掩码 $M_{\\mathrm{bdry}}$ 和 $M_{\\mathrm{int}}$ 以及计算MSE的函数。一个核心函数将直接实现互相关求和，以适应`'circular'`或`'zero'`的填充逻辑。每个测试用例都将通过生成所需的输入（$I$、$K$），计算输出（$T, Z$），计算指定的四个MSE值，并应用布尔决策逻辑来处理。\n\n每个测试用例的具体参数如下：\n\n**案例1：** $N=64, k=5, p=2$。核是一个 $5 \\times 5$ 的归一化盒式滤波器（$K_{ij} = 1/25$）。纹理是正弦波之和，参数为 $a_1=0.6, a_2=0.35, a_3=0.25, f_1=4, f_2=7, f_3=9, f_4=5$。我们预计假设会成立，因为图像相对于核较大，为边界和内部区域提供了清晰的区分。\n\n**案例2：** $N=17, k=3, p=1$。核是一个 $3 \\times 3$ 的离散拉普拉斯算子。纹理参数为 $a_1=0.5, a_2=0.4, a_3=0.3, f_1=3, f_2=5, f_3=2, f_4=1$。此案例在较小的素数维度图像上测试了不同类型的核（高通滤波器）。基本原理保持不变，因此我们预计假设会成立。\n\n**案例3：** $N=5, k=5, p=2$。核仍然是 $5 \\times 5$ 的盒式滤波器。纹理参数为 $a_1=0.75, a_2=0.25, a_3=0.5, f_1=1, f_2=2, f_3=1, f_4=1$。这是一个极端情况，其中核的支撑集大小 $k$ 等于图像维度 $N$。内部区域仅包含位于 $(2,2)$ 的单个像素，而图像的其余部分被视为边界。这为边界效应提供了一个严格的测试。对于任何输出像素，在循环填充下，核将“环绕”图像，而在零填充下，它将与大片零区域相互作用。差异应该会很明显。在 $(2,2)$ 处的零填充内部计算仍然涉及访问原始图像像素，因为对于 $u,v \\in \\{-2,\\dots,2\\}$，索引 $2+u$ 和 $2+v$ 仍在 $\\{0,\\dots,4\\}$ 范围内。因此，我们预计内部误差可以忽略不计，而边界误差会很大，从而证实该假设。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by testing the hypothesis about padding in 2D cross-correlation.\n    \"\"\"\n    \n    # Define the tolerance epsilon as required.\n    epsilon = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"N\": 64, \"k\": 5,\n            \"kernel_type\": \"box\",\n            \"texture_params\": {\"a1\": 0.6, \"a2\": 0.35, \"a3\": 0.25, \"f1\": 4, \"f2\": 7, \"f3\": 9, \"f4\": 5}\n        },\n        {\n            \"N\": 17, \"k\": 3,\n            \"kernel_type\": \"laplacian\",\n            \"texture_params\": {\"a1\": 0.5, \"a2\": 0.4, \"a3\": 0.3, \"f1\": 3, \"f2\": 5, \"f3\": 2, \"f4\": 1}\n        },\n        {\n            \"N\": 5, \"k\": 5,\n            \"kernel_type\": \"box\",\n            \"texture_params\": {\"a1\": 0.75, \"a2\": 0.25, \"a3\": 0.5, \"f1\": 1, \"f2\": 2, \"f3\": 1, \"f4\": 1}\n        }\n    ]\n\n    results = []\n    \n    # Helper functions\n    \n    def create_periodic_texture(N, a1, a2, a3, f1, f2, f3, f4):\n        \"\"\"Generates the NxN periodic texture image.\"\"\"\n        i_coords, j_coords = np.meshgrid(np.arange(N), np.arange(N), indexing='ij')\n        term1 = a1 * np.sin(2 * np.pi * f1 * i_coords / N)\n        term2 = a2 * np.cos(2 * np.pi * f2 * j_coords / N)\n        term3 = a3 * np.sin(2 * np.pi * (f3 * i_coords + f4 * j_coords) / N)\n        return term1 + term2 + term3\n\n    def cross_correlate(I, K, padding_mode):\n        \"\"\"Performs 2D cross-correlation with specified padding.\"\"\"\n        N = I.shape[0]\n        k = K.shape[0]\n        p = k // 2\n        O = np.zeros_like(I)\n\n        for i in range(N):\n            for j in range(N):\n                accumulator = 0.0\n                for u in range(-p, p + 1):\n                    for v in range(-p, p + 1):\n                        src_i, src_j = i + u, j + v\n                        pixel_val = 0.0\n                        if padding_mode == 'circular':\n                            pixel_val = I[src_i % N, src_j % N]\n                        elif padding_mode == 'zero':\n                            if 0 = src_i  N and 0 = src_j  N:\n                                pixel_val = I[src_i, src_j]\n                        \n                        accumulator += K[u + p, v + p] * pixel_val\n                O[i, j] = accumulator\n        return O\n        \n    def calculate_mse(A, B, mask):\n        \"\"\"Calculates Mean Squared Error between A and B over a mask.\"\"\"\n        m = np.sum(mask)\n        if m == 0:\n            return 0.0\n        error = np.sum(mask * (A - B)**2) / m\n        return error\n\n    for case in test_cases:\n        N = case[\"N\"]\n        k = case[\"k\"]\n        p = k // 2\n        \n        # 1. Construct image and kernel\n        I = create_periodic_texture(N, **case[\"texture_params\"])\n        \n        if case[\"kernel_type\"] == \"box\":\n            K = np.full((k, k), 1.0 / (k * k))\n        elif case[\"kernel_type\"] == \"laplacian\":\n            K = np.array([[0, -1, 0], [-1, 4, -1], [0, -1, 0]], dtype=float)\n\n        # 2. Compute outputs T, C, and Z\n        # T is the reference, using circular padding\n        T = cross_correlate(I, K, 'circular')\n        # C is the test output with circular padding (will be identical to T)\n        C = T\n        # Z is the test output with zero padding\n        Z = cross_correlate(I, K, 'zero')\n\n        # 3. Define masks\n        M_bdry = np.zeros((N, N), dtype=int)\n        boundary_indices = list(range(p)) + list(range(N - p, N))\n        for i in range(N):\n            for j in range(N):\n                if i in boundary_indices or j in boundary_indices:\n                    M_bdry[i, j] = 1\n        M_int = 1 - M_bdry\n\n        # 4. Compute MSEs\n        mse_bdry_zt = calculate_mse(Z, T, M_bdry)\n        mse_bdry_ct = calculate_mse(C, T, M_bdry)\n        mse_int_zt = calculate_mse(Z, T, M_int)\n        mse_int_ct = calculate_mse(C, T, M_int)\n\n        # 5. Decide boolean result\n        cond1 = mse_bdry_zt > mse_bdry_ct + epsilon\n        cond2 = mse_int_zt = epsilon and mse_int_ct = epsilon\n        \n        result = cond1 and cond2\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3111157"}, {"introduction": "在研究了卷积的力学结构和实际效果之后，我们现在转向使其如此强大的核心原理：平移等变性（translation equivariance）。这项编程实践将让你能够通过数值方法验证这一关键属性，观察它在循环卷积网络中如何成立，而在其他边界条件下又如何失效。理解等变性是掌握CNN为何天然适用于处理如图像这类空间数据的关键。[@problem_id:3126241]", "problem": "您的任务是利用离散卷积、有限网格上的平移算子以及逐点非线性的基本性质，设计并验证平移等变空间预测网络。平移等变性意味着，对于一个作用于二维数组的函数 $f$ 和一个平移算子 $T_{\\delta}$，关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 对所有有效的输入 $x$ 和平移 $\\delta$ 都成立。除非另有明确说明，网格是有限的，并采用周期性边界条件。\n\n使用的基本基础和定义：\n- 二维离散信号是一个函数 $x: \\{0,\\dots,H-1\\} \\times \\{0,\\dots,W-1\\} \\to \\mathbb{R}$，表示为一个形状为 $H \\times W$ 的数组。\n- 循环平移算子 $T_{\\delta}$，其中 $\\delta = (\\delta_y,\\delta_x)$，其作用方式为 $(T_{\\delta} x)[i,j] = x[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W]$。\n- 在周期性边界条件下，使用大小为奇数 $k_h \\times k_w$ 且中心位于 $(\\lfloor k_h/2 \\rfloor,\\lfloor k_w/2 \\rfloor)$ 的核 $k$ 进行的二维离散互相关由下式给出：\n  $$ (x \\star_{\\mathrm{circ}} k)[i,j] = \\sum_{m=0}^{k_h-1}\\sum_{n=0}^{k_w-1} x\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big)\\, k[m,n], $$\n  其中 $c_h = \\lfloor k_h/2 \\rfloor$ 且 $c_w = \\lfloor k_w/2 \\rfloor$。\n- 逐点非线性 $\\sigma$ 对每个空间位置独立作用，例如 $\\sigma(u) = \\max(u,0)$（修正线性单元）。\n- 在整个空间上均匀加上的一个常数偏置 $b \\in \\mathbb{R}$ 会产生 $y[i,j] = u[i,j] + b$。\n\n任务：\n- 设计一小组由循环互相关层、常数偏置和逐点非线性组成的网络，每个网络都生成一个 $H \\times W$ 的空间图。对于一个指定的反例，使用零填充（非循环）互相关来说明一个失败案例。\n- 对于每个网络，通过从定义出发进行推理，解析地验证在哪种边界条件下关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 对所有 $x$ 和 $\\delta$ 成立，在哪种条件下不成立。\n- 实现一个程序，使用最大绝对差准则和容差 $\\epsilon$ 来数值上测试等变关系 $f(T_{\\delta} x) = T_{\\delta} f(x)$，并为每个测试用例报告一个布尔值，指示该属性是否在容差范围内成立。\n\n数值细节和约束：\n- 使用形状为 $H \\times W$ 的数组，其中 $H = 16$，$W = 16$。\n- 所有核必须具有奇数空间维度。\n- 对于循环层，使用如上定义的循环互相关。对于一个非循环案例，使用零填充互相关，它将域外的值视为零，并返回一个相同形状的数组。\n- 在任何要求使用非线性的地方，使用修正线性单元 $\\sigma(u) = \\max(u,0)$。\n- 使用容差 $\\epsilon = 10^{-9}$ 通过条件 $\\max_{i,j} |A[i,j] - B[i,j]| \\le \\epsilon$ 来判定相等。\n- 随机性必须是可复现的。对于每个测试用例，使用提供的种子 $s$ 初始化一个伪随机数生成器，并从标准正态分布中独立抽取输入和核的所有条目。\n\n测试套件：\n每个测试用例指定 $(H,W,\\delta,\\text{架构},\\text{核尺寸},\\text{种子})$。实现以下六个案例，并评估属性 $f(T_{\\delta} x) = T_{\\delta} f(x)$。\n\n- 案例 A（理想路径，单层）：\n  - $H = 16$, $W = 16$, $\\delta = (3,-5)$，架构：一个核尺寸为 $3 \\times 3$ 的循环互相关层，加上一个常数偏置，然后是一个修正线性单元，种子 $s = 0$。\n- 案例 B（层的组合）：\n  - $H = 16$, $W = 16$, $\\delta = (7,2)$，架构：两个循环互相关层，核尺寸均为 $3 \\times 3$，每个层都有自己的常数偏置，在第一层和第二层之后都应用一个修正线性单元，种子 $s = 1$。\n- 案例 C（零填充下的失败）：\n  - $H = 16$, $W = 16$, $\\delta = (5,4)$，架构：一个核尺寸为 $3 \\times 3$ 的零填充互相关层（非循环），加上一个常数偏置，然后是一个修正线性单元，种子 $s = 2$。\n- 案例 D（偏置不变性，大平移）：\n  - $H = 16$, $W = 16$, $\\delta = (15,-16)$，架构：一个核尺寸为 $3 \\times 3$ 的循环互相关层，加上一个非零常数偏置，然后是一个修正线性单元，种子 $s = 3$。\n- 案例 E（逐点线性头）：\n  - $H = 16$, $W = 16$, $\\delta = (1,1)$，架构：一个核尺寸为 $3 \\times 3$ 的循环互相关层，然后是一个修正线性单元，再然后是一个通过带有自身偏置的 $1 \\times 1$ 循环互相关实现的逐点线性层，种子 $s = 4$。\n- 案例 F（扩张循环层）：\n  - $H = 16$, $W = 16$, $\\delta = (2,-3)$，架构：一个循环互相关层，其核是通过在基础 $3 \\times 3$ 核中以扩张因子 $d = 2$ 插入零来构建的，从而得到一个有效核尺寸为 $5 \\times 5$ 的核，加上一个常数偏置，然后是一个修正线性单元，种子 $s = 5$。\n\n程序输入和输出：\n- 没有外部输入。您的程序必须按规定在内部构建六个测试用例，使用提供的种子生成随机输入和核，以容差 $\\epsilon = 10^{-9}$ 评估每个案例的等变关系，并将六个布尔结果汇总到一行输出中，格式为方括号内以逗号分隔的列表，例如 $[\\text{True},\\text{False},\\dots]$，其中包含恰好六个条目，没有额外的空白字符。", "solution": "该问题要求对几个由标准组件构建的小型神经网络架构的平移等变性进行分析。如果对于任何有效的输入信号 $x$ 和任何平移向量 $\\delta$，关系式 $f(T_{\\delta} x) = T_{\\delta} f(x)$ 成立，则函数 $f$ 是平移等变的。这里，$T_{\\delta}$ 是在大小为 $H \\times W$ 的有限二维网格上定义的循环平移算子。该网格由索引 $\\{0, \\dots, H-1\\} \\times \\{0, \\dots, W-1\\}$ 定义。\n\n平移算子 $T_{\\delta}$，其中 $\\delta = (\\delta_y, \\delta_x)$，定义为 $(T_{\\delta} x)[i,j] = x[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W]$。此操作将信号 $x$ 的内容按向量 $\\delta$ 进行平移，并采用周期性边界条件。\n\n一个网络 $f$ 被构建为基本操作的复合，$f = f_L \\circ f_{L-1} \\circ \\dots \\circ f_1$。平移等变性在复合下是保持的。如果两个函数 $g$ 和 $h$ 各自是平移等变的，那么它们的复合 $g \\circ h$ 也是平移等变的。这可以如下证明：\n$$ (g \\circ h)(T_{\\delta} x) = g(h(T_{\\delta} x)) $$\n根据 $h$ 的等变性，$h(T_{\\delta} x) = T_{\\delta} h(x)$。代入可得：\n$$ g(T_{\\delta} h(x)) $$\n根据 $g$ 的等变性，应用于输入 $y = h(x)$：\n$$ g(T_{\\delta} y) = T_{\\delta} g(y) \\implies g(T_{\\delta} h(x)) = T_{\\delta} g(h(x)) = T_{\\delta} (g \\circ h)(x) $$\n因此，我们有 $(g \\circ h)(T_{\\delta} x) = T_{\\delta} (g \\circ h)(x)$。要确定一个网络 $f$ 是否是平移等变的，我们必须分析其每个组成层。\n\n构建模块是：\n1.  循环互相关\n2.  常数偏置的加法\n3.  逐点非线性\n4.  零填充互相关（用于一个反例）\n\n让我们逐一分析每个组件的平移等变性。\n\n1.  **循环互相关 ($C_k$)**：\n设操作为 $y = x \\star_{\\mathrm{circ}} k$。输出由下式给出：\n$$ y[i,j] = (x \\star_{\\mathrm{circ}} k)[i,j] = \\sum_{m=0}^{k_h-1}\\sum_{n=0}^{k_w-1} x\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big)\\, k[m,n] $$\n其中 $c_h = \\lfloor k_h/2 \\rfloor$ 且 $c_w = \\lfloor k_w/2 \\rfloor$。\n为了测试等变性，我们比较 $T_{\\delta}(x \\star_{\\mathrm{circ}} k)$ 和 $(T_{\\delta} x) \\star_{\\mathrm{circ}} k$。\n\n首先，让我们计算平移后的输出 $(T_{\\delta} y)[i,j]$：\n$$ (T_{\\delta} y)[i,j] = y[(i-\\delta_y) \\bmod H, (j-\\delta_x) \\bmod W] $$\n代入 $y$ 的定义：\n$$ (T_{\\delta} y)[i,j] = \\sum_{m, n} x\\Big(\\big(((i-\\delta_y) \\bmod H) + m-c_h\\big) \\bmod H, \\big(((j-\\delta_x) \\bmod W) + n-c_w\\big) \\bmod W\\Big) \\, k[m,n] $$\n由于模运算的性质，这可以简化为：\n$$ (T_{\\delta} y)[i,j] = \\sum_{m, n} x\\big((i-\\delta_y+m-c_h) \\bmod H, (j-\\delta_x+n-c_w) \\bmod W\\big) \\, k[m,n] $$\n\n接下来，我们计算平移后输入的输出 $y' = (T_{\\delta} x) \\star_{\\mathrm{circ}} k$：\n$$ y'[i,j] = \\sum_{m,n} (T_{\\delta} x)\\big((i+m-c_h) \\bmod H, (j+n-c_w) \\bmod W\\big) \\, k[m,n] $$\n使用 $T_{\\delta}$ 的定义，$(T_{\\delta} x)[a,b] = x[(a-\\delta_y)\\bmod H, (b-\\delta_x)\\bmod W]$，我们得到：\n$$ y'[i,j] = \\sum_{m,n} x\\Big(\\big((i+m-c_h)\\bmod H - \\delta_y\\big) \\bmod H, \\big((j+n-c_w)\\bmod W - \\delta_x\\big) \\bmod W\\Big) \\, k[m,n] $$\n这再次简化为：\n$$ y'[i,j] = \\sum_{m,n} x\\big((i+m-c_h-\\delta_y) \\bmod H, (j+n-c_w-\\delta_x) \\bmod W\\big) \\, k[m,n] $$\n$(T_{\\delta} y)[i,j]$ 和 $y'[i,j]$ 的表达式是相同的。因此，循环互相关是一种平移等变操作。只要边界条件是周期的，这个结论就成立，而与核的值或大小无关，包括 $1 \\times 1$ 的核和扩张核。\n\n2.  **常数偏置的加法 ($B_b$)**：\n设操作为 $y[i,j] = u[i,j] + b$。\n平移后的输出是 $(T_{\\delta} y)[i,j] = y[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] = u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] + b$。\n平移后输入的输出是 $(T_{\\delta} u + b)[i,j] = (T_{\\delta} u)[i,j] + b = u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] + b$。\n这两个表达式是相同的。因此，加上一个常数偏置是一种平移等变操作。\n\n3.  **逐点非线性 ($\\Sigma$)**：\n设操作为 $y[i,j] = \\sigma(u[i,j])$，其中 $\\sigma$ 是一个独立应用于每个元素的函数。\n平移后的输出是 $(T_{\\delta} y)[i,j] = y[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W] = \\sigma\\big(u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W]\\big)$。\n平移后输入的输出是 $\\sigma(T_{\\delta} u)[i,j] = \\sigma\\big((T_{\\delta} u)[i,j]\\big) = \\sigma\\big(u[(i-\\delta_y)\\bmod H, (j-\\delta_x)\\bmod W]\\big)$。\n表达式是相同的。任何逐点操作，包括修正线性单元（ReLU），都是平移等变的。\n\n4.  **零填充互相关 ($C'_k$)**：\n此操作的定义与循环互相关类似，但来自网格 $\\{0, \\dots, H-1\\} \\times \\{0, \\dots, W-1\\}$ 外部的输入被视为零。这打破了网格的周期性对称。考虑一个输入信号 $x$，它在所有位置都为零，除了边界附近的一个点，例如 $x[0,0]=1$。输出 $y = C'_k(x)$ 将具有由核 $k$ 决定的模式。现在考虑一个平移后的输入 $x' = T_\\delta x$。如果 $\\delta$ 使得非零元素从边界移开到网格内部，互相关将使用相邻的信号值（在本例中为零）而不是填充的零来计算。得到的输出模式 $y' = C'_k(x')$ 在形状上将与 $y$ 相同。然而，如果我们计算原始输出的平移 $T_\\delta y$，结果将是原始输出模式的简单平移，包括由边界引起的任何伪影。这两个结果 $y'$ 和 $T_\\delta y$ 通常不匹配，因为填充与信号的相互作用方式取决于其相对于边界的位置。因此，使用零填充的互相关不是平移等变的。\n\n**测试用例分析：**\n\n-   **案例 A**：`circ_corr` $\\to$ `bias` $\\to$ `relu`。这是在周期性边界条件下三个平移等变操作的复合。因此，最终的网络是**等变的**。\n-   **案例 B**：`(circ_corr -> bias -> relu)` $\\to$ `(circ_corr -> bias -> relu)`。这是两个块的复合，根据案例 A 的结论，每个块都是等变的。等变函数的复合是等变的。该网络是**等变的**。\n-   **案例 C**：`zero_pad_corr` $\\to$ `bias` $\\to$ `relu`。该网络以一个零填充互相关层开始，该层不是平移等变的。单个非等变层的存在使得整个网络**非等变的**。\n-   **案例 D**：`circ_corr` $\\to$ `bias` $\\to$ `relu`。这与案例 A 的架构相同。平移向量 $\\delta = (15,-16) \\equiv (-1,0) \\pmod{16}$ 的具体值和非零偏置不会改变等变性的基本属性。该网络是**等变的**。\n-   **案例 E**：`circ_corr(3x3)` $\\to$ `relu` $\\to$ `circ_corr(1x1)` $\\to$ `bias`。$1 \\times 1$ 的互相关是逐点缩放，这是一种平移等变操作。所有其他组件也是等变的。该网络是等变块的复合，因此是**等变的**。\n-   **案例 F**：`dilated_circ_corr` $\\to$ `bias` $\\to$ `relu`。扩张循环互相关是循环互相关的一个特例，其中核具有插入零的稀疏结构。循环互相关的等变性证明与核的具体值无关，仅取决于循环求和。因此，该层也是等变的。该网络是**等变的**。\n\n测试套件的预期布尔结果为：[True, True, False, True, True, True]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import correlate2d\n\ndef solve():\n    \"\"\"\n    Solves the problem by numerically testing the translation equivariance\n    of different network architectures specified in the test cases.\n    \"\"\"\n\n    # --- Helper Functions for Network Layers ---\n\n    def circular_translation(x, delta):\n        \"\"\"Applies circular translation T_delta to a 2D array x.\"\"\"\n        # delta = (delta_y, delta_x)\n        # np.roll shifts array elements. A shift of (dy, dx) moves the\n        # element at (r, c) to (r+dy, c+dx).\n        # We want (T_delta x)[i,j] = x[i-delta_y, j-delta_x].\n        # This corresponds to shifting the content by delta.\n        return np.roll(x, shift=delta, axis=(0, 1))\n\n    def circular_cross_correlation(x, k):\n        \"\"\"Performs circular cross-correlation.\"\"\"\n        return correlate2d(x, k, mode='same', boundary='wrap')\n\n    def zero_padding_cross_correlation(x, k):\n        \"\"\"Performs zero-padding cross-correlation.\"\"\"\n        return correlate2d(x, k, mode='same', boundary='fill', fillvalue=0)\n\n    def relu(x):\n        \"\"\"Applies the Rectified Linear Unit pointwise.\"\"\"\n        return np.maximum(x, 0)\n    \n    def create_dilated_kernel(base_kernel, dilation_factor):\n        \"\"\"Creates a dilated kernel from a base kernel.\"\"\"\n        kh_base, kw_base = base_kernel.shape\n        d = dilation_factor\n        \n        # Effective kernel size calculation\n        kh_dil = kh_base + (kh_base - 1) * (d - 1)\n        kw_dil = kw_base + (kw_base - 1) * (d - 1)\n        \n        dilated_kernel = np.zeros((kh_dil, kw_dil))\n        \n        for i in range(kh_base):\n            for j in range(kw_base):\n                dilated_kernel[i * d, j * d] = base_kernel[i, j]\n                \n        return dilated_kernel\n\n    # --- Test Case Definitions ---\n    \n    test_cases = [\n        # Case A: (H, W, delta, architecture, kernel_sizes, seed)\n        (16, 16, (3, -5), 'A', [(3, 3)], 0),\n        # Case B\n        (16, 16, (7, 2), 'B', [(3, 3), (3, 3)], 1),\n        # Case C\n        (16, 16, (5, 4), 'C', [(3, 3)], 2),\n        # Case D\n        (16, 16, (15, -16), 'D', [(3, 3)], 3),\n        # Case E\n        (16, 16, (1, 1), 'E', [(3, 3), (1, 1)], 4),\n        # Case F\n        (16, 16, (2, -3), 'F', [(3, 3)], 5),\n    ]\n\n    results = []\n    epsilon = 1e-9\n\n    for case in test_cases:\n        H, W, delta, arch, kernel_sizes, seed = case\n        \n        # Initialize RNG for reproducibility for each case\n        np.random.seed(seed)\n        \n        # Generate random input\n        x = np.random.standard_normal((H, W))\n\n        # Define the network function f(x) for the current architecture\n        if arch == 'A':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k) + b)\n        \n        elif arch == 'B':\n            k1 = np.random.standard_normal(kernel_sizes[0])\n            b1 = np.random.standard_normal()\n            k2 = np.random.standard_normal(kernel_sizes[1])\n            b2 = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(relu(circular_cross_correlation(z, k1) + b1), k2) + b2)\n            \n        elif arch == 'C':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(zero_padding_cross_correlation(z, k) + b)\n            \n        elif arch == 'D':\n            k = np.random.standard_normal(kernel_sizes[0])\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k) + b)\n\n        elif arch == 'E':\n            k1 = np.random.standard_normal(kernel_sizes[0])\n            k2 = np.random.standard_normal(kernel_sizes[1])\n            b2 = np.random.standard_normal()\n            f = lambda z: circular_cross_correlation(relu(circular_cross_correlation(z, k1)), k2) + b2\n\n        elif arch == 'F':\n            k_base = np.random.standard_normal(kernel_sizes[0])\n            k_dilated = create_dilated_kernel(k_base, dilation_factor=2)\n            b = np.random.standard_normal()\n            f = lambda z: relu(circular_cross_correlation(z, k_dilated) + b)\n            \n        # --- Equivariance Test ---\n        # LHS: f(T_delta(x))\n        x_translated = circular_translation(x, delta)\n        lhs = f(x_translated)\n\n        # RHS: T_delta(f(x))\n        fx = f(x)\n        rhs = circular_translation(fx, delta)\n        \n        # Compare LHS and RHS\n        max_abs_diff = np.max(np.abs(lhs - rhs))\n        is_equivariant = max_abs_diff = epsilon\n        results.append(is_equivariant)\n\n    # Print results in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126241"}]}