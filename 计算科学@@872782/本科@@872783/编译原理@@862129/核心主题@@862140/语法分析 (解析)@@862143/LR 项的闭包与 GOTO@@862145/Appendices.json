{"hands_on_practices": [{"introduction": "第一个练习旨在巩固基础。我们将从一个简单的文法开始，手动构建初始状态 $I_0$ 和一个后续状态，从而精确地理解 `closure` 和 `goto` 操作如何协同工作来构建分析器的状态机。通过这个练习 [@problem_id:3627177]，你将为后续更复杂的挑战打下坚实的基础。", "problem": "考虑由产生式 $S \\to A \\mid B$、$A \\to aA \\mid a$ 和 $B \\to bB \\mid b$ 给出的上下文无关文法，其中 $S$ 是开始符号，$a$ 和 $b$ 是终结符。通过引入带有产生式 $S' \\to S$ 的新开始符号 $S'$ 来增广该文法。在规范的从左到右扫描、反向最右推导（LR）分析器且具有 1 符号向前看（LR(1)）的框架下进行操作。仅使用 LR(1) 项目的核心定义、字符串上的 $\\mathrm{FIRST}$ 函数、LR(1) 项目的 $\\mathrm{closure}$ 操作以及 LR(1) 项目集上的 $\\mathrm{goto}$ 转移，从基本定义出发完成以下任务：\n\n- 构建初始 LR(1) 项目集 $I_{0} = \\mathrm{closure}(\\{[S' \\to \\cdot S, \\$]\\})$.\n- 构建 $I_{1} = \\mathrm{goto}(I_{0}, S)$.\n- 构建 $I_{2} = \\mathrm{goto}(I_{0}, a)$.\n\n令 $N$ 表示 $I_{0}$、$I_{1}$ 和 $I_{2}$ 中 LR(1) 项目数量的总和（即 $N = |I_{0}| + |I_{1}| + |I_{2}|$)。计算 $N$。你的最终答案必须是一个实数值，无需四舍五入。", "solution": "在尝试解答之前，对问题进行验证。\n\n### 第 1 步：提取已知条件\n- **文法产生式**：$S \\to A \\mid B$、$A \\to aA \\mid a$ 和 $B \\to bB \\mid b$。\n- **开始符号**：$S$。\n- **终结符**：$a$, $b$。\n- **增广文法**：引入新的开始符号 $S'$ 及产生式 $S' \\to S$。\n- **框架**：规范 LR(1) 分析。\n- **待使用的定义**：LR(1) 项目、字符串上的 $\\mathrm{FIRST}$ 函数、$\\mathrm{closure}$ 操作、$\\mathrm{goto}$ 转移。\n- **任务**：\n    1. 构建 $I_{0} = \\mathrm{closure}(\\{[S' \\to \\cdot S, \\$]\\})$.\n    2. 构建 $I_{1} = \\mathrm{goto}(I_{0}, S)$.\n    3. 构建 $I_{2} = \\mathrm{goto}(I_{0}, a)$.\n    4. 计算 $N = |I_{0}| + |I_{1}| + |I_{2}|$.\n\n### 第 2 步：使用提取的已知条件进行验证\n- **科学依据**：该问题基于形式语言与自动机理论，特别是 LR(1) 分析，这是编译原理和计算机科学中的一个标准和基础课题。所有提到的概念（LR(1) 项目、闭包、goto、FIRST 集）都是该领域中精确定义的数学对象。该问题在科学上是合理的。\n- **适定性**：该文法是无歧义的，并且操作（$\\mathrm{closure}$、$\\mathrm{goto}$）是确定性算法，会产生唯一的项目集。问题要求计算这些特定集合的大小及其总和，这将导出一个唯一的数值答案。\n- **客观性**：该问题使用计算机科学中精确和标准的术语进行陈述。没有歧义、主观性或基于观点性的语言。\n\n### 第 3 步：结论与行动\n该问题是有效的，因为它具有科学依据、适定性和客观性。将提供一个解决方案。\n\n### 解答\n\n该问题要求计算给定上下文无关文法在项目集 $I_0$、$I_1$ 和 $I_2$ 中 LR(1) 项目的总数。将按要求从基本定义出发进行解答。\n\n给定文法 $G$ 的产生式为：\n$S \\to A \\mid B$\n$A \\to aA \\mid a$\n$B \\to bB \\mid b$\n\n非终结符集合是 $\\{S, A, B\\}$，终结符集合是 $\\{a, b\\}$。开始符号是 $S$。\n\n增广文法 $G'$ 引入了一个新的开始符号 $S'$ 和一个产生式 $S' \\to S$。输入结束标记用 $\\$$ 表示。一个 LR(1) 项目的形式为 $[A \\to \\alpha \\cdot \\beta, x]$，其中 $A \\to \\alpha \\beta$ 是一个产生式，$x$ 是一个终结符（向前看符号）。\n\n首先，我们需要非终结符的 $\\mathrm{FIRST}$ 集，这在 $\\mathrm{closure}$ 操作中会用到。\n- $\\mathrm{FIRST}(A)$：根据产生式 $A \\to aA$ 和 $A \\to a$，从 $A$ 推导出的第一个终结符必定是 $a$。因此，$\\mathrm{FIRST}(A) = \\{a\\}$。\n- $\\mathrm{FIRST}(B)$：根据产生式 $B \\to bB$ 和 $B \\to b$，从 $B$ 推导出的第一个终结符必定是 $b$。因此，$\\mathrm{FIRST}(B) = \\{b\\}$。\n- $\\mathrm{FIRST}(S)$：根据产生式 $S \\to A$ 和 $S \\to B$，$\\mathrm{FIRST}(S) = \\mathrm{FIRST}(A) \\cup \\mathrm{FIRST}(B) = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。\n\n$\\mathrm{closure}$ 操作定义如下：对于一个项目集 $I$，$\\mathrm{closure}(I)$ 是包含 $I$ 的最小集合，使得对于集合中的任何项目 $[A \\to \\alpha \\cdot B \\beta, x]$，对于任何产生式 $B \\to \\gamma$，以及对于任何终结符 $y \\in \\mathrm{FIRST}(\\beta x)$，项目 $[B \\to \\cdot \\gamma, y]$ 也在此集合中。\n\n$\\mathrm{goto}$ 操作定义为：$\\mathrm{goto}(I, X)$ 是所有满足 $[A \\to \\alpha \\cdot X \\beta, x]$ 在 $I$ 中的项目 $[A \\to \\alpha X \\cdot \\beta, x]$ 的集合的闭包。\n\n**任务 1：构建 $I_0 = \\mathrm{closure}(\\{[S' \\to \\cdot S, \\$]\\})$**\n我们从核心集 $\\{[S' \\to \\cdot S, \\$]\\}$ 开始。\n1.  初始项目是 $[S' \\to \\cdot S, \\$]$。点后面是非终结符 $S$。跟在 $S$ 后面的字符串是空串（$\\epsilon$），向前看符号是 $\\$$。我们需要计算 $\\mathrm{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $S$ 的所有产生式对应的项目以及这个向前看符号加入集合。\n    - $S \\to A$：加入 $[S \\to \\cdot A, \\$]$。\n    - $S \\to B$：加入 $[S \\to \\cdot B, \\$]$。\n    现在的项目集是 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$]\\}$。\n\n2.  考虑新项目 $[S \\to \\cdot A, \\$]$。点后面是非终结符 $A$。跟在 $A$ 后面的字符串是 $\\epsilon$，向前看符号是 $\\$$。$\\mathrm{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $A$ 的所有产生式对应的项目以及这个向前看符号加入集合。\n    - $A \\to aA$：加入 $[A \\to \\cdot aA, \\$]$。\n    - $A \\to a$：加入 $[A \\to \\cdot a, \\$]$。\n    现在的集合是 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$]\\}$。\n\n3.  考虑新项目 $[S \\to \\cdot B, \\$]$。点后面是非终结符 $B$。跟在 $B$ 后面的字符串是 $\\epsilon$，向前看符号是 $\\$$。$\\mathrm{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $B$ 的所有产生式对应的项目以及这个向前看符号加入集合。\n    - $B \\to bB$：加入 $[B \\to \\cdot bB, \\$]$。\n    - $B \\to b$：加入 $[B \\to \\cdot b, \\$]$。\n    现在的集合是 $\\{[S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$], [B \\to \\cdot bB, \\$], [B \\to \\cdot b, \\$]\\}$。\n\n4.  新项目 $[A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$], [B \\to \\cdot bB, \\$], [B \\to \\cdot b, \\$]$ 的点后面都是终结符（$a$ 或 $b$）。闭包规则仅在点后是非终结符时适用。因此，不能再添加更多项目。\n\n$I_0$ 的最终项目集是：\n$I_0 = \\{ [S' \\to \\cdot S, \\$], [S \\to \\cdot A, \\$], [S \\to \\cdot B, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$], [B \\to \\cdot bB, \\$], [B \\to \\cdot b, \\$] \\}$。\n$I_0$ 中的项目数量是 $|I_0| = 7$。\n\n**任务 2：构建 $I_1 = \\mathrm{goto}(I_0, S)$**\n1.  在 $I_0$ 中找到所有点在 $S$ 之前的项目。只有一个这样的项目：$[S' \\to \\cdot S, \\$]$。\n2.  将点越过 $S$ 移动，形成新集合的核心：$\\{[S' \\to S \\cdot, \\$]\\}$。\n3.  计算此核心集的闭包：$\\mathrm{closure}(\\{[S' \\to S \\cdot, \\$]\\})$.\n4.  项目 $[S' \\to S \\cdot, \\$]$ 的点在产生式的末尾。因此，闭包操作无法添加新项目。\n\n$I_1$ 的最终项目集是：\n$I_1 = \\{ [S' \\to S \\cdot, \\$] \\}$。\n$I_1$ 中的项目数量是 $|I_1| = 1$。这对应于分析器的接受状态。\n\n**任务 3：构建 $I_2 = \\mathrm{goto}(I_0, a)$**\n1.  在 $I_0$ 中找到所有点在终结符 $a$ 之前的项目。它们是 $[A \\to \\cdot aA, \\$]$ 和 $[A \\to \\cdot a, \\$]$。\n2.  在这些项目中将点越过 $a$ 移动，形成新集合的核心：$\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$]\\}$。\n3.  计算此核心集的闭包：$\\mathrm{closure}(\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$]\\})$.\n    - 项目 $[A \\to a \\cdot, \\$]$ 的点在末尾，所以它不添加新项目。\n    - 项目 $[A \\to a \\cdot A, \\$]$ 的点后面是非终结符 $A$。跟在 $A$ 后面的字符串是 $\\epsilon$，向前看符号是 $\\$$。我们需要计算 $\\mathrm{FIRST}(\\epsilon \\$) = \\{\\$\\}$。我们将 $A$ 的所有产生式对应的项目以及这个向前看符号加入集合。\n        - $A \\to aA$：加入 $[A \\to \\cdot aA, \\$]$。\n        - $A \\to a$：加入 $[A \\to \\cdot a, \\$]$。\n    集合变为 $\\{[A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$]\\}$。\n\n4.  新加入的项目点后面是终结符 $a$，所以不能再添加更多项目。\n\n$I_2$ 的最终项目集是：\n$I_2 = \\{ [A \\to a \\cdot A, \\$], [A \\to a \\cdot, \\$], [A \\to \\cdot aA, \\$], [A \\to \\cdot a, \\$] \\}$。\n$I_2$ 中的项目数量是 $|I_2| = 4$。\n\n**最终计算**\n问题要求计算 $N$，即这三个集合中项目数量的总和。\n$N = |I_0| + |I_1| + |I_2|$\n$N = 7 + 1 + 4$\n$N = 12$", "answer": "$$\n\\boxed{12}\n$$", "id": "3627177"}, {"introduction": "展望符的计算是LR(1)分析中的一个难点，尤其是当遇到可推导出空串 $\\epsilon$ 的非终结符时。本练习 [@problem_id:3627141] 将聚焦于这个核心问题，通过一个精心设计的场景，你将实践展望符如何“穿透”可空非终结符，这是保证分析正确性的一个关键细节。", "problem": "考虑一个上下文无关文法，其非终结符为 $\\{S, A\\}$，终结符为 $\\{a\\}$，产生式为 $S \\to A\\,A$ 和 $A \\to a\\,A \\mid \\epsilon$。使用规范的自左向右扫描、最右推导、带一个前瞻符号 (LR(1)) 项目的构造方法。一个 LR(1) 项目写为 $[X \\to \\alpha\\,\\cdot\\,\\beta, t]$ 的形式，其中 $X \\to \\alpha\\beta$ 是一个产生式，点表示分析器的位置，而 $t$ 是一个单独的前瞻终结符。对于一个 LR(1) 项目集 $I$ 的闭包操作 $\\mathrm{closure}(I)$ 定义为：重复应用以下规则直到没有新项目可以添加为止：对于 $I$ 中的任意项目 $[X \\to \\alpha\\,\\cdot\\,Y\\,\\beta, a] \\in I$ 和任意产生式 $Y \\to \\gamma$，将每个项目 $[Y \\to \\cdot\\,\\gamma, b]$ 添加到集合中，其中每个 $b \\in \\mathrm{FIRST}(\\beta a)$。此处，对于一个符号串 $\\omega$，$\\mathrm{FIRST}(\\omega)$ 是可以从 $\\omega$ 推导出的字符串的起始终结符集合，并且如果 $\\epsilon \\in \\mathrm{FIRST}(\\beta)$，则 $\\mathrm{FIRST}(\\beta a)=\\left(\\mathrm{FIRST}(\\beta)\\setminus\\{\\epsilon\\}\\right)\\cup\\{a\\}$。将不同的前瞻终结符视为产生不同的 LR(1) 项目；不要通过合并前瞻集来合并项目。\n\n从单个 LR(1) 项目 $[S \\to \\cdot\\,A\\,A, \\$]$ 开始，其中 $\\$$ 表示输入结束标记并被视为一个终结符，且 $\\mathrm{FIRST}(\\$)=\\{\\$\\}$，计算集合 $\\mathrm{closure}(\\{[S \\to \\cdot\\,A\\,A, \\$]\\})$ 的基数。请将最终答案表示为一个整数。无需四舍五入。", "solution": "该问题陈述经核实具有科学依据，问题定义明确且客观。它提供了获得唯一解所需的完整且一致的定义和数据。该问题是编译器理论中关于构造 LR(1) 分析状态的一个标准练习。\n\n该问题要求计算对给定的一个 LR(1) 项目的初始集合执行 $\\mathrm{closure}$ 操作后所得集合的基数。文法和计算规则都已明确给出。\n\n给定的上下文无关文法 $G$ 具有以下组成部分：\n- 非终结符：$N = \\{S, A\\}$\n- 终结符：$T = \\{a\\}$\n- 开始符号：$S$（隐含的，因为它是起始项目产生式中的非终结符）\n- 产生式 $P$：\n  1. $S \\to A\\,A$\n  2. $A \\to a\\,A$\n  3. $A \\to \\epsilon$（其中 $\\epsilon$ 表示空串）\n\n$\\mathrm{closure}$ 操作需要计算文法中非终结符的 $\\mathrm{FIRST}$ 集。\n\n首先，我们计算 $\\mathrm{FIRST}(A)$：\n根据产生式 $A \\to a\\,A$，终结符 $a$ 属于 $\\mathrm{FIRST}(A)$。\n根据产生式 $A \\to \\epsilon$，空串 $\\epsilon$ 属于 $\\mathrm{FIRST}(A)$。\n因此，$\\mathrm{FIRST}(A) = \\{a, \\epsilon\\}$。\n\n问题定义的起始项目集为 $I = \\{[S \\to \\cdot\\,A\\,A, \\$]\\}$。我们需要计算 $C = \\mathrm{closure}(I)$。该过程从 $C = I$ 开始。然后，我们根据闭包规则迭代地向 $C$ 中添加项目，直到没有新项目可以添加为止。\n\n闭包规则规定：对于集合中的任意项目 $[X \\to \\alpha\\,\\cdot\\,Y\\,\\beta, t]$（其中 $Y$ 是一个非终结符），以及对于任意产生式 $Y \\to \\gamma$，我们必须为每个终结符 $b \\in \\mathrm{FIRST}(\\beta\\,t)$ 添加项目 $[Y \\to \\cdot\\,\\gamma, b]$。\n\n让我们开始计算：\n初始集：$C_0 = \\{[S \\to \\cdot\\,A\\,A, \\$]\\}$。\n\n我们处理来自 $C_0$ 的项目 $[S \\to \\cdot\\,A\\,A, \\$]$。\n- 该项目具有 $[X \\to \\alpha\\,\\cdot\\,Y\\,\\beta, t]$ 的形式，其中 $X=S$，$\\alpha=\\epsilon$，$Y=A$，$\\beta=A$，前瞻终结符为 $t=\\$$.\n- 我们需要为新项目找到前瞻符号，它们由集合 $\\mathrm{FIRST}(\\beta\\,t) = \\mathrm{FIRST}(A\\,\\$)$ 给出。\n- 为了计算 $\\mathrm{FIRST}(A\\,\\$)$，我们使用所提供的规则：因为 $\\epsilon \\in \\mathrm{FIRST}(A)$，所以 $\\mathrm{FIRST}(A\\,\\$) = (\\mathrm{FIRST}(A)\\setminus\\{\\epsilon\\}) \\cup \\mathrm{FIRST}(\\$)$。\n- 题目给定 $\\mathrm{FIRST}(\\$) = \\{\\$\\}$。\n- 因此，$\\mathrm{FIRST}(A\\,\\$) = (\\{a, \\epsilon\\}\\setminus\\{\\epsilon\\}) \\cup \\{\\$\\} = \\{a, \\$\\}$。\n- 新项目的前瞻符号是 $a$ 和 $\\$$。\n\n现在，我们为 $A$ 的每个产生式（$A \\to a\\,A$ 和 $A \\to \\epsilon$）以及每个前瞻符号添加项目。问题指明，具有不同前瞻符号的项目是不同的。\n- 对于产生式 $A \\to a\\,A$：\n  - 前瞻符号为 $a$：添加 $[A \\to \\cdot\\,a\\,A, a]$。\n  - 前瞻符号为 $\\$$：添加 $[A \\to \\cdot\\,a\\,A, \\$]$。\n- 对于产生式 $A \\to \\epsilon$：\n  - 前瞻符号为 $a$：添加 $[A \\to \\cdot, a]$。\n  - 前瞻符号为 $\\$$：添加 $[A \\to \\cdot, \\$]$。\n\n完成这第一步后，项目集为：\n$C_1 = C_0 \\cup \\{[A \\to \\cdot\\,a\\,A, a], [A \\to \\cdot\\,a\\,A, \\$], [A \\to \\cdot, a], [A \\to \\cdot, \\$] \\}$。\n所以，当前集合是：\n1. $[S \\to \\cdot\\,A\\,A, \\$]$\n2. $[A \\to \\cdot\\,a\\,A, a]$\n3. $[A \\to \\cdot\\,a\\,A, \\$]$\n4. $[A \\to \\cdot, a]$\n5. $[A \\to \\cdot, \\$]$\n\n现在，我们必须检查对任何新添加的项目应用闭包规则是否会生成更多项目。\n- 考虑项目 2：$[A \\to \\cdot\\,a\\,A, a]$。点在终结符 $a$ 之前。闭包规则仅在点位于非终结符之前时适用。因此，不会添加新项目。\n- 考虑项目 3：$[A \\to \\cdot\\,a\\,A, \\$]$。同样，点在终结符之前，因此不会添加新项目。\n- 考虑项目 4：$[A \\to \\cdot, a]$。点在产生式规则的末尾（$\\gamma=\\epsilon$）。这样的项目是一个“规约”项目，不会通过闭包规则添加新项目。\n- 考虑项目 5：$[A \\to \\cdot, \\$]$。这也是一个规约项目，不会添加新项目。\n\n由于没有新项目可以添加到集合中，闭包过程终止。最终的集合是 $C_1$。\n集合 $\\mathrm{closure}(\\{[S \\to \\cdot\\,A\\,A, \\$]\\})$ 由以下 $5$ 个不同的项目组成：\n1. $[S \\to \\cdot\\,A\\,A, \\$]$\n2. $[A \\to \\cdot\\,a\\,A, a]$\n3. $[A \\to \\cdot, a]$\n4. $[A \\to \\cdot\\,a\\,A, \\$]$\n5. $[A \\to \\cdot, \\$]$\n\n问题要求计算此集合的基数。通过计算不同项目的数量，我们发现基数为 $5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3627141"}]}