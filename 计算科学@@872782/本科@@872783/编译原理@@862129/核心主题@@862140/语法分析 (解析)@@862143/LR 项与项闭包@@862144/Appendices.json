{"hands_on_practices": [{"introduction": "要构建一个LR分析器，我们首先需要掌握两个核心操作：$closure$（闭包）和 $goto$（转移）。$closure$ 操作通过扩展项集来包含所有可能即将开始的产生式，而 $goto$ 操作则模拟了在识别一个文法符号后分析器的状态转换。这个练习 [@problem_id:3655618] 将引导你完成一次完整的计算，从一个给定的初始项集出发，计算其闭包，然后执行一次 $goto$ 转移，从而让你牢固掌握构建LR(0)自动机的基本步骤。", "problem": "考虑上下文无关文法，其产生式为 $S \\to AB$，$A \\to a \\mid \\epsilon$ 和 $B \\to b$。在从左到右、反向最右推导（LR）分析的框架下，使用 $LR(0)$ 项目进行分析。令 $I$ 为初始包含项目 $[S \\to \\cdot AB]$ 的单元素集合的闭包。仅使用 $LR(0)$ 项目、项目闭包和 $\\operatorname{goto}$ 函数的核心定义，通过首先在 $I$ 的项目中将点前进越过 $A$ 得到所有项目，然后求其闭包，来构造 $\\operatorname{goto}(I, A)$。令 $n$ 表示基数 $|\\operatorname{goto}(I, A)|$。请对 $\\operatorname{goto}(I, A)$ 中包含的项目给出一个简洁的解释，说明产生式右部的哪一部分已被识别，以及接下来期望出现什么符号，然后报告 $n$ 的确切值。你的最终答案应该是 $n$ 的单个整数值。", "solution": "问题要求计算给定上下文无关文法的 $LR(0)$ 项目集 $\\operatorname{goto}(I, A)$ 的基数。该文法的产生式为 $S \\to AB$、$A \\to a \\mid \\epsilon$ 和 $B \\to b$。集合 $I$ 定义为初始项目集 $\\{[S \\to \\cdot AB]\\}$ 的闭包。\n\n设给定的上下文无关文法为 $G$。非终结符集为 $V = \\{S, A, B\\}$，终结符集为 $\\Sigma = \\{a, b\\}$，产生式集 $P$ 为：\n$1.$ $S \\to AB$\n$2.$ $A \\to a$\n$3.$ $A \\to \\epsilon$\n$4.$ $B \\to b$\n\n一个 $LR(0)$ 项目是一个在右侧（RHS）某个位置带有点（$\\cdot$）的产生式。问题需要两个主要计算：首先，构造项目集 $I$；其次，构造项目集 $\\operatorname{goto}(I, A)$。\n\n首先，我们通过对初始集合 $\\{[S \\to \\cdot AB]\\}$ 应用闭包运算来计算集合 $I$。\n一个项目集 $J$ 的闭包，记作 $\\operatorname{closure}(J)$，计算如下：\n$1.$ 最初，$\\operatorname{closure}(J)$ 包含 $J$ 中的所有项目。\n$2.$ 如果一个项目 $[X \\to \\alpha \\cdot Y \\beta]$ 在 $\\operatorname{closure}(J)$ 中，并且 $Y \\to \\gamma$ 是一个产生式，那么将项目 $[Y \\to \\cdot \\gamma]$ 添加到 $\\operatorname{closure}(J)$ 中（如果它尚不在其中）。\n$3.$ 重复步骤 2，直到没有新项目可以添加到 $\\operatorname{closure}(J)$ 中。\n\n我们来计算 $I = \\operatorname{closure}(\\{[S \\to \\cdot AB]\\})$。\n$1.$ 我们从初始项目集 $\\{[S \\to \\cdot AB]\\}$ 开始。\n$2.$ 项目 $[S \\to \\cdot AB]$ 的点右侧紧邻非终结符 $A$。因此，我们必须添加所有对应于 $A$ 的产生式的项目。$A$ 的产生式是 $A \\to a$ 和 $A \\to \\epsilon$。这给了我们新项目 $[A \\to \\cdot a]$ 和 $[A \\to \\cdot]$（对应于 $A \\to \\epsilon$）。\n$3.$ 我们当前的项目集是 $\\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$。\n$4.$ 现在我们检查新添加的项目。\n   - 对于 $[A \\to \\cdot a]$，点右侧的符号是终结符 $a$。这不会导致添加任何新项目。\n   - 对于 $[A \\to \\cdot]$，点右侧没有符号。这是一个规约项目，也不会导致添加任何新项目。\n$5.$ 由于没有新项目可以添加，闭包操作完成。得到的项目集是：\n$$I = \\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$$\n\n接下来，我们计算集合 $\\operatorname{goto}(I, A)$。$\\operatorname{goto}$ 函数定义如下：对于一个项目集 $J$ 和一个文法符号 $X$，$\\operatorname{goto}(J, X)$ 是所有形如 $[P \\to \\alpha X \\cdot \\beta]$ 的项目集合的闭包，其中 $[P \\to \\alpha \\cdot X \\beta]$ 属于 $J$。\n\n要计算 $\\operatorname{goto}(I, A)$，我们首先确定新集合的“核心”。这个核心由 $I$ 中所有点右侧是非终结符 $A$ 的项目组成，并将点前进越过 $A$。\n查看集合 $I = \\{[S \\to \\cdot AB], [A \\to \\cdot a], [A \\to \\cdot]\\}$，只有项目 $[S \\to \\cdot AB]$ 是形如 $[P \\to \\alpha \\cdot A \\beta]$ 的。这里，$P=S$，$\\alpha=\\epsilon$，并且 $\\beta=B$。\n将点前进越过 $A$，我们得到项目 $[S \\to A \\cdot B]$。\n因此，$\\operatorname{goto}$ 集的核心是 $\\{[S \\to A \\cdot B]\\}$。\n\n现在，我们必须计算这个核心集的闭包：$\\operatorname{goto}(I, A) = \\operatorname{closure}(\\{[S \\to A \\cdot B]\\})$.\n$1.$ 我们从集合 $\\{[S \\to A \\cdot B]\\}$ 开始。\n$2.$ 项目 $[S \\to A \\cdot B]$ 的点右侧紧邻非终结符 $B$。因此，我们必须添加所有 $B$ 的产生式对应的项目。$B$ 唯一的产生式是 $B \\to b$。这给了我们新项目 $[B \\to \\cdot b]$。\n$3.$ 我们当前的项目集是 $\\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}$。\n$4.$ 我们检查新添加的项目 $[B \\to \\cdot b]$。点右侧的符号是终结符 $b$，所以没有新项目被添加。\n$5.$ 闭包操作完成。得到的项目集是：\n$$\\operatorname{goto}(I, A) = \\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}$$\n\n该集合中项目的解释如下。集合 $\\operatorname{goto}(I, A)$ 代表 LR 自动机中的一个状态，该状态是在识别了一个可以规约为非终结符 $A$ 的输入终结符序列后达到的。\n- 核心项目 $[S \\to A \\cdot B]$ 表示对应于非终结符 $A$ 的一部分输入已被成功分析，分析器现在期望看到一个可以规约为非终结符 $B$ 的终结符序列，以完成产生式 $S \\to AB$。\n- 闭包项目 $[B \\to \\cdot b]$ 指示分析器如何开始识别期望的 $B$：通过看到终结符 $b$。\n\n最后，问题要求计算 $n$ 的值，即集合 $\\operatorname{goto}(I, A)$ 的基数。\n$$n = |\\operatorname{goto}(I, A)| = |\\{[S \\to A \\cdot B], [B \\to \\cdot b]\\}|$$\n该集合包含两个不同的项目。因此，基数为 $2$。\n$n = 2$。", "answer": "$$\\boxed{2}$$", "id": "3655618"}, {"introduction": "掌握了基本操作后，让我们来构建一个分析器的起始状态 $I_0$。这个练习 [@problem_id:3655684] 将从一个增广文法开始，通过计算初始项的闭包来生成 $I_0$。在这个过程中，你将直面LR(0)分析中的一个典型问题——“移入/归约冲突”（shift/reduce conflict），并理解为何在某个状态下，分析器既可以移入一个终结符，又可以进行归约，从而产生不确定性。", "problem": "考虑一个上下文无关文法，其开始符号为 $S$，产生式为 $S \\to aS \\mid Sb \\mid \\epsilon$。通过引入新的开始符号 $S'$ 和产生式 $S' \\to S$ 来增广该文法。仅使用 $LR(0)$ 项目、项目闭包和 $goto$ 函数的标准定义，构造初始 $LR(0)$ 项目集 $I_0 = \\mathrm{CLOSURE}(\\{\\,S' \\to \\cdot S\\,\\})$。从基本原理出发，在 $I_0$ 中识别一个项目集，该项目集同时包含已完成的项目 $[\\,S \\to \\epsilon \\cdot\\,]$ 和至少一个点号位于终结符 $a$ 或 $b$ 之前的项目，从而使得在该终结符上可以进行移入操作。解释为什么这种情况在 $LR(0)$ 分析框架中构成了一个移入/规约冲突。最后，计算该项目集中存在的不同 $LR(0)$ 移入/规约冲突的总数。将你的最终答案表示为一个没有单位的整数。不需要四舍五入。", "solution": "问题要求我们分析给定的上下文无关文法，构建其初始 $LR(0)$ 项目集 $I_0$，并确定该集合内移入/规约冲突的数量。\n\n文法 $G$ 的开始符号为 $S$，其产生式如下：\n$1$. $S \\to aS$\n$2$. $S \\to Sb$\n$3$. $S \\to \\epsilon$\n\n首先，我们通过引入新的开始符号 $S'$ 和新的产生式 $S' \\to S$ 来增广该文法。增广后的文法 $G'$ 如下：\n$0$. $S' \\to S$\n$1$. $S \\to aS$\n$2$. $S \\to Sb$\n$3$. $S \\to \\epsilon$\n\n下一步是构造初始 $LR(0)$ 项目集，记为 $I_0$。该集合被定义为从增广产生式派生出的初始项目的闭包，即 $I_0 = \\mathrm{CLOSURE}(\\{\\,[S' \\to \\cdot S]\\,\\})$。\n\n$\\mathrm{CLOSURE}$ 操作定义如下：\n如果一个项目 $[A \\to \\alpha \\cdot B \\beta]$ 位于一个项目集中，并且 $B \\to \\gamma$ 是文法中的一个产生式，那么项目 $[B \\to \\cdot \\gamma]$ 也必须在该集合的闭包中。重复此过程，直到没有新项目可以添加为止。\n\n我们来计算 $I_0$：\n$1$. 我们从只包含增广产生式对应项目的初始项目集开始：$\\{[S' \\to \\cdot S]\\}$。\n\n$2$. 在 $[S' \\to \\cdot S]$ 中，点号位于非终结符 $S$ 之前。因此，我们必须添加所有对应于 $S$ 的产生式的项目，且点号位于产生式右部的开头。$S$ 的产生式为 $S \\to aS$、$S \\to Sb$ 和 $S \\to \\epsilon$。添加相应的项目后，我们的集合变为：\n$\\{ [S' \\to \\cdot S], [S \\to \\cdot aS], [S \\to \\cdot Sb], [S \\to \\epsilon \\cdot] \\}$\n请注意，产生式 $S \\to \\epsilon$ 产生项目 $[S \\to \\cdot]$，根据问题的表示法，为清晰起见，我们将其写作 $[S \\to \\epsilon \\cdot]$。\n\n$3$. 现在我们检查对新添加的项目应用闭包规则是否能加入更多新项目：\n- 对于 $[S \\to \\cdot aS]$，点号位于终结符（$a$）之前，因此不添加新项目。\n- 对于 $[S \\to \\cdot Sb]$，点号位于非终结符 $S$ 之前。我们必须添加 $S$ 的产生式对应的项目。然而，项目 $[S \\to \\cdot aS]$、$[S \\to \\cdot Sb]$ 和 $[S \\to \\epsilon \\cdot]$ 已经存在于我们的集合中。所以，不添加新项目。\n- 对于 $[S \\to \\epsilon \\cdot]$，点号位于末尾（这是一个已完成或规约项目），因此不添加新项目。\n\n闭包过程完成。初始 $LR(0)$ 项目集为：\n$$ I_0 = \\{ [S' \\to \\cdot S], [S \\to \\cdot aS], [S \\to \\cdot Sb], [S \\to \\epsilon \\cdot] \\} $$\n\n问题要求我们在 $I_0$ 中识别构成移入/规约冲突的情况。一个 $LR(0)$ 移入/规约冲突发生在一个项目集中，如果它同时包含：\n- 一个*移入*项目，其形式为 $[A \\to \\alpha \\cdot t \\beta]$，其中 $t$ 是一个终结符。这表示分析器可以将输入中的终结符 $t$ 移入到栈上。\n- 一个*规约*项目，它是一个形式为 $[B \\to \\gamma \\cdot]$ 的已完成项目。在 $LR(0)$ 框架中，这表示分析器可以使用产生式 $B \\to \\gamma$ 执行规约操作，而不管下一个输入符号是什么。\n\n让我们在这种背景下分析项目集 $I_0$。该文法的终结符是 $a$ 和 $b$。\n\n- **对终结符 $a$ 的分析：**\n  - 项目 $[S \\to \\cdot aS]$ 存在于 $I_0$ 中。点号位于终结符 $a$ 之前。这对应于对输入 $a$ 的**移入**动作。\n  - 项目 $[S \\to \\epsilon \\cdot]$ 也存在于 $I_0$ 中。这是一个已完成项目。在一个 $LR(0)$ 分析器中，此项目指示对任何向前看终结符执行**规约**动作（使用产生式 $S \\to \\epsilon$）。因此，它为输入 $a$ 指定了一个规约动作。\n  - 由于集合 $I_0$ 指示分析器在输入终结符 $a$ 上同时进行`shift`和`reduce`，因此对于终结符 $a$ 存在一个**移入/规约冲突**。\n\n- **对终结符 $b$ 的分析：**\n  - $I_0$ 中是否存在形式为 $[A \\to \\alpha \\cdot b \\beta]$ 的项目？不存在。项目 $[S \\to \\cdot Sb]$ 的点号在非终结符 $S$ 之前，而不是终结符 $b$ 之前。因此，对输入 $b$ 没有移入动作。\n  - 项目 $[S \\to \\epsilon \\cdot]$ 存在于 $I_0$ 中，它指示对输入 $b$ 执行**规约**动作。\n  - 对于终结符 $b$，只有一个已定义的动作：`reduce`。不存在冲突。\n\n一个独立的移入/规约冲突是为每个发生冲突的（状态，终结符）对定义的。在我们的例子中，状态是 $I_0$。\n- 对于序对 $(I_0, a)$，存在一个移入/规约冲突。\n- 对于序对 $(I_0, b)$，不存在冲突。\n\n因此，在项目集 $I_0$ 中恰好存在一个独立的移入/规约冲突。\n\n最后的任务是计算项目集 $I_0$ 中存在的不同 $LR(0)$ 移入/规约冲突的总数。根据上述分析，这个数字是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3655684"}, {"introduction": "除了移入/归约冲突，LR分析还可能遇到另一种冲突：“归约/归约冲突”（reduce/reduce conflict）。这种情况发生在一个状态包含多个“完成项”（completed items）时，导致分析器无法确定应该使用哪个产生式进行归约。通过分析一个包含多个可空非终结符链的复杂文法 [@problem_id:3655630]，你将学会如何识别这种情况，并加深对文法二义性如何体现在LR项集中的理解。", "problem": "考虑以下上下文无关文法，其具有显式的空串产生式，旨在形成一个可空非终结符链。设开始符号为 $S$，增广开始符号为 $S'$。终结符为 $\\{a,b,c,d,e\\}$，非终结符为 $\\{S,A,B,C,D,E\\}$。产生式如下：\n$$\n\\begin{aligned}\n0.\\quad S' \\to S \\\\\n1.\\quad S \\to A\\,B \\;\\mid\\; C\\,D \\;\\mid\\; E \\\\\n2.\\quad A \\to \\epsilon \\;\\mid\\; a \\\\\n3.\\quad B \\to \\epsilon \\;\\mid\\; b \\\\\n4.\\quad C \\to \\epsilon \\;\\mid\\; c \\\\\n5.\\quad D \\to \\epsilon \\;\\mid\\; d\\,E \\\\\n6.\\quad E \\to \\epsilon \\;\\mid\\; e\n\\end{aligned}\n$$\n将一个 $\\epsilon$-产生式 $X \\to \\epsilon$ 视为具有单个 $\\text{LR}(0)$ 项目 $X \\to \\cdot$，其中点 $\\cdot$ 标记了在右侧的位置。根据 $\\text{LR}(0)$（从左到右，最右推导，零前瞻）方法，为该增广文法构建初始的规范项目集 $I_0 = \\operatorname{CLOSURE}(\\{\\,S' \\to \\cdot S\\,\\})$。然后，确定在 $I_0$ 中同时出现了多少个不同的已完成项目（即形式为 $X \\to \\gamma \\cdot$ 的项目，其中右侧 $\\gamma$ 可以是任意的，包括 $\\gamma=\\epsilon$）。\n\n你的最终答案必须是等于该计数的单个整数。无需四舍五入，也不涉及单位。", "solution": "问题要求为给定的上下文无关文法构建初始的规范 $\\text{LR}(0)$ 项目集，记为 $I_0$。随后，我们必须确定此项目集中的已完成项目的数量。已完成项目定义为点（$\\cdot$）出现在产生式右侧最末端的项目，例如 $X \\to \\gamma \\cdot$。\n\n文法规定了开始符号 $S$、增广开始符号 $S'$、产生式、终结符 $\\{a,b,c,d,e\\}$ 和非终结符 $\\{S,A,B,C,D,E\\}$。\n产生式如下：\n$$\n\\begin{aligned}\n0.\\quad S' \\to S \\\\\n1.\\quad S \\to A\\,B \\mid C\\,D \\mid E \\\\\n2.\\quad A \\to \\epsilon \\mid a \\\\\n3.\\quad B \\to \\epsilon \\mid b \\\\\n4.\\quad C \\to \\epsilon \\mid c \\\\\n5.\\quad D \\to \\epsilon \\mid d\\,E \\\\\n6.\\quad E \\to \\epsilon \\mid e\n\\end{aligned}\n$$\n问题说明，一个空串产生式 $X \\to \\epsilon$ 产生单个 $\\text{LR}(0)$ 项目 $X \\to \\cdot$。由于点位于空的右侧末端，这个项目本身就是一个已完成项目。\n\n初始项目集 $I_0$ 定义为包含增广文法单个初始项目的集合的闭包，即 $I_0 = \\operatorname{CLOSURE}(\\{S' \\to \\cdot S\\})$。\n\n$\\text{LR}(0)$ 项目集 $I$ 的 $\\operatorname{CLOSURE}$ 算法定义如下：\n$1$. 初始化一个集合 $J$ 为 $I$。\n$2$. 重复直到没有更多项目可以添加到 $J$ 中：对于 $J$ 中每个形如 $[A \\to \\alpha \\cdot B \\beta]$ 的项目，其中 $B$ 是一个非终结符，将所有产生式项目 $[B \\to \\cdot \\gamma]$ 添加到 $J$ 中。\n$3$. 得到的集合 $J$ 就是闭包。\n\n注意，标准的 $\\text{LR}(0)$ 闭包算法不会“看穿”可空非终结符。问题描述中的“可空非终结符链”这一短语是该文法的一个属性，它会导致分析冲突（具体来说，是 $I_0$ 中的规约/规约冲突），但这并不会改变构建 $\\text{LR}(0)$ 项目集的过程。我们必须严格遵守指定的 $\\text{LR}(0)$ 方法。\n\n让我们来计算 $I_0 = \\operatorname{CLOSURE}(\\{S' \\to \\cdot S\\})$。\n\n最初，我们称之为 $J$ 的项目集仅包含来自增广开始符号的项目：\n$J = \\{S' \\to \\cdot S\\}$。\n\n接下来，我们迭代地应用闭包规则。\n**步骤1：** 项目 $S' \\to \\cdot S$ 在 $J$ 中。点在非终结符 $S$ 之前。因此，我们必须将所有对应于 $S$ 的产生式的项目添加到 $J$ 中。$S$ 的产生式是 $S \\to A\\,B$、$S \\to C\\,D$ 和 $S \\to E$。这会将项目 $S \\to \\cdot A\\,B$、$S \\to \\cdot C\\,D$ 和 $S \\to \\cdot E$ 添加到我们的集合中。\n此步骤后，$J = \\{S' \\to \\cdot S, S \\to \\cdot A\\,B, S \\to \\cdot C\\,D, S \\to \\cdot E\\}$。\n\n**步骤2：** 我们检查新添加的项目，寻找紧跟在点之后的任何非终结符。\n- 项目 $S \\to \\cdot A\\,B$ 在点后有非终结符 $A$。我们添加 $A$ 的所有产生式对应的项目。产生式是 $A \\to \\epsilon$ 和 $A \\to a$。这会添加项目 $A \\to \\cdot$ 和 $A \\to \\cdot a$。\n- 项目 $S \\to \\cdot C\\,D$ 在点后有非终结符 $C$。我们添加 $C$ 的所有产生式对应的项目。产生式是 $C \\to \\epsilon$ 和 $C \\to c$。这会添加项目 $C \\to \\cdot$ 和 $C \\to \\cdot c$。\n- 项目 $S \\to \\cdot E$ 在点后有非终结符 $E$。我们添加 $E$ 的所有产生式对应的项目。产生式是 $E \\to \\epsilon$ 和 $E \\to e$。这会添加项目 $E \\to \\cdot$ 和 $E \\to \\cdot e$。\n\n此步骤后，集合 $J$ 为：\n$J = \\{S' \\to \\cdot S, S \\to \\cdot A\\,B, S \\to \\cdot C\\,D, S \\to \\cdot E, A \\to \\cdot a, A \\to \\cdot, C \\to \\cdot c, C \\to \\cdot, E \\to \\cdot e, E \\to \\cdot\\}$。\n\n**步骤3：** 我们检查步骤2中添加的项目。\n- 项目 $A \\to \\cdot a$、$C \\to \\cdot c$ 和 $E \\to \\cdot e$ 在点后是终结符，因此闭包规则不适用。\n- 项目 $A \\to \\cdot$、$C \\to \\cdot$ 和 $E \\to \\cdot$ 是已完成项目，在点后没有符号，因此闭包规则不适用。\n\n由于此步骤中没有添加新项目，算法终止。最终的集合 $I_0$ 就是当前的集合 $J$。\n$I_0 = \\{S' \\to \\cdot S, S \\to \\cdot A\\,B, S \\to \\cdot C\\,D, S \\to \\cdot E, A \\to \\cdot a, A \\to \\cdot, C \\to \\cdot c, C \\to \\cdot, E \\to \\cdot e, E \\to \\cdot\\}$。\n集合 $I_0$ 总共包含 $10$ 个项目。\n\n最后的任务是计算 $I_0$ 中不同已完成项目的数量。一个已完成项目形如 $X \\to \\gamma \\cdot$。我们检查 $I_0$ 中的每个项目：\n$1$. $S' \\to \\cdot S$：未完成。点在开头。\n$2$. $S \\to \\cdot A\\,B$：未完成。点在开头。\n$3$. $S \\to \\cdot C\\,D$：未完成。点在开头。\n$4$. $S \\to \\cdot E$：未完成。点在开头。\n$5$. $A \\to \\cdot a$：未完成。点在终结符 $a$ 之前。\n$6$. $A \\to \\cdot$：**已完成**。该项目来自产生式 $A \\to \\epsilon$。右侧为空，因此点在末尾。\n$7$. $C \\to \\cdot c$：未完成。点在终结符 $c$ 之前。\n$8$. $C \\to \\cdot$：**已完成**。该项目来自产生式 $C \\to \\epsilon$。\n$9$. $E \\to \\cdot e$：未完成。点在终结符 $e$ 之前。\n$10$. $E \\to \\cdot$：**已完成**。该项目来自产生式 $E \\to \\epsilon$。\n\n通过检查，集合 $I_0$ 中恰好有 $3$ 个已完成项目。它们是 $A \\to \\cdot$、$C \\to \\cdot$ 和 $E \\to \\cdot$。\n在单个状态 $I_0$ 中存在这 $3$ 个已完成项目会产生规约/规约冲突，这意味着该文法不是 $\\text{LR}(0)$ 文法。这是文法结构（特别是可空非终结符）的直接结果，但这并不改变计算结果。\n\n$I_0$ 中不同已完成项目的数量为 $3$。", "answer": "$$\\boxed{3}$$", "id": "3655630"}]}