## 引言

[LR分析](@entry_id:751545)是[编译器设计](@entry_id:271989)中最强大、最通用的自底向上[语法分析技术](@entry_id:753181)之一。其核心思想是，通过一个“移入-归约”的过程，逆向构造出输入串的最右推导。但这个过程并非盲目猜测，而是由一个精确的决策引擎——一个确定性有限自动机（DFA）——来驱动。这个自动机在每一步都为分析器提供明确的指令：是应该将下一个输入符号“移入”分析栈，还是应该将栈顶的一串符号“归约”为一个非终结符。

然而，从一个抽象的文法到这样一个具体的、能够指导分析的自动机，这中间存在一个关键的知识鸿沟。我们如何系统地、算法化地构建这个“大脑”呢？这个自动机中的“状态”究竟代表了什么？我们又如何根据这些状态来做出移入或归约的决策？

本文旨在填补这一鸿沟，深入剖析[LR分析](@entry_id:751545)器的核心构造过程——LR(0)项集规范族的构建。通过阅读本文，您将学习到：
*   **原理与机制**：我们将详细介绍构成自动机状态的“[LR(0)项目](@entry_id:751535)”，并掌握用于构建完整状态集的核心操作：`CLOSURE`（闭包）和 `GOTO`（转移）函数。您将理解这些机制如何共同创建一个能够捕捉文法所有可能分析路径的有限自动机。
*   **应用与跨学科关联**：我们将[超越理论](@entry_id:203777)，展示LR(0)项集规范族作为一个强大的诊断工具，如何被应用于发现和解决编程语言设计中的[歧义](@entry_id:276744)问题（如[运算符优先级](@entry_id:168687)和悬垂else），以及它在协议分析、机器人规划等领域的建模应用。
*   **动手实践**：通过一系列精心设计的练习，您将有机会亲手构建项目集、识别分析冲突，并学习如何通过文法转换来解决这些问题，从而将理论知识转化为实践技能。

让我们从构建这个自动机的基本构件开始，在第一章“原理与机制”中，探索这一切是如何运作的。

## 原理与机制

在上一章中，我们介绍了 LR 解析的总体思想：它是一种自底向上的[解析技术](@entry_id:753181)，通过移入-归约过程，在“反向”构建最右推导。这种解析器的核心是一个确定性有限自动机（DFA），它精确地指导解析器在每一步应该采取的动作——是移入下一个输入符号，还是将句柄归约为一个非终结符。本章将深入探讨构建这个自动机的核心原理与机制。这个自动机也被称为 **LR(0) 自动机**，其状态的集合被称为 **LR(0) 项目的规范族 (canonical collection of LR(0) item sets)**。理解其构建过程是掌握所有 LR 解析变体（包括 SLR、LALR 和 LR(1)）的基石。

### LR(0) 项目：解析器知识状态的快照

为了构建能够指导移入-归约决策的自动机，我们首先需要一种方法来精确描述解析器在任意时刻的“知识状态”。解析器已经看到了输入的一部分，并期望看到另一部分，从而完成一个产生式的识别。这种状态可以用一个 **LR(0) 项目 (LR(0) item)** 来表示。

一个 **LR(0) 项目** 是一个在其产生式体右侧某处标有一个点（$\cdot$）的文法产生式。这个点不是一个语法符号，而是一个标记，用于指明解析的进度。例如，对于一个产生式 $A \to XYZ$，我们可以得到四个不同的 LR(0) 项目：
- $[A \to \cdot XYZ]$: 我们期望识别一个能从 $X$ 推导出的字符串。
- $[A \to X \cdot YZ]$: 我们刚刚识别了一个从 $X$ 推导出的字符串，现在期望识别一个从 $Y$ 推导出的字符串。
- $[A \to XY \cdot Z]$: 我们已经识别了 $X$ 和 $Y$，现在期望识别 $Z$。
- $[A \to XYZ \cdot]$: 我们已经成功识别了整个产生式体 $XYZ$。这种项目被称为**完成项目 (completed item)** 或**归约项目 (reduce item)**。

这个点（$\cdot$）将产生式体分为两部分：点的左边是已经识别的符号序列（对应于解析栈的顶部），点的右边是期望在输入中看到的符号序列。因此，一个 LR(0) 项目集合可以精确地描述解析器在当前输入点上所有可能的有效状态。

### `CLOSURE` 运算：预测未来

假设当前解析状态包含一个项目 $[A \to \alpha \cdot B \beta]$，其中 $B$ 是一个非终结符。这意味着我们期望接下来在输入中看到一个可以由 $B$ 推导出的符号串。为了准备好识别这个符号串，解析器需要知道所有可能的起始情况，即所有 $B$ 的产生式。这就是 **`CLOSURE`（闭包）** 运算的职责。

**`CLOSURE(I)`** 运算的目的是为一个项目集 $I$ 增加所有“隐含”的预测。它的定义如下：

1.  首先，将 $I$ 中的所有项目加入 `CLOSURE(I)`。
2.  然后，重复以下步骤直至 `CLOSURE(I)` 不再增大：
    如果 `CLOSURE(I)` 中存在一个项目 $[A \to \alpha \cdot B \beta]$（其中 $B$ 是一个非终结符），并且文法中存在一个产生式 $B \to \gamma$，那么就将项目 $[B \to \cdot \gamma]$ 加入 `CLOSURE(I)`。

`CLOSURE` 运算本质上是一个预测过程。每当点（$\cdot$）位于一个非终结符 $B$ 之前，它就将所有 $B$ 的产生式以初始状态（即点在最左边）的形式添加到当前的项目集中。这个过程是递归的，因为新加入的项目可能自身又在点后有一个非终结符，从而触发新一轮的添加。

例如，考虑以下[增广文法](@entry_id:746575) [@problem_id:3626875]：
$S' \to S$
$S \to TT$
$T \to aT \mid b$

如果我们从初始项目 $[S' \to \cdot S]$ 开始计算闭包，过程如下：
1.  初始集合 $I = \{ [S' \to \cdot S] \}$。
2.  点在非终结符 $S$ 之前，所以我们加入所有 $S$ 的产生式：$I$ 变为 $\{ [S' \to \cdot S], [S \to \cdot TT] \}$。
3.  现在，新加入的项目 $[S \to \cdot TT]$ 的点在非终结符 $T$ 之前，我们必须加入所有 $T$ 的产生式：$I$ 变为 $\{ [S' \to \cdot S], [S \to \cdot TT], [T \to \cdot aT], [T \to \cdot b] \}$。
4.  新加入的项目 $[T \to \cdot aT]$ 和 $[T \to \cdot b]$ 的点都在终结符之前，不会再触发新的添加。因此，[闭包运算](@entry_id:747392)完成。

最终得到的项目集 $I_0 = \{ [S' \to \cdot S], [S \to \cdot TT], [T \to \cdot aT], [T \to \cdot b] \}$ 代表了解析开始时的完整状态。

特别地，如果一个非终结符是**可空的 (nullable)**，即它可以推导出空串 $\epsilon$（例如，存在产生式 $A \to \epsilon$），那么 `CLOSURE` 运算会引入一个归约项目 [@problem_id:3626882]。例如，如果一个项目集包含 $[S \to \cdot A c]$ 且文法中有产生式 $A \to \epsilon$，那么[闭包运算](@entry_id:747392)将加入项目 $[A \to \cdot \epsilon]$，我们通常将其写作 $[A \to \cdot]$。这表示解析器在当前位置有一种可能性是“什么都不看”，直接完成对 $A$ 的识别。这对于理解后续的解析冲突至关重要。

### `GOTO` 函数：在状态间转移

`CLOSURE` 运算为我们提供了在一个状态内部进行预测的能力，而 **`GOTO` (转移)** 函数则定义了自动机如何在不同状态之间进行转换。`GOTO(I, X)` 函数模拟了解析器在当前状态 $I$ 下成功识别了语法符号 $X$ 后的新状态。

`GOTO(I, X)` 的定义如下：
对于项目集 $I$ 和语法符号 $X$（可以是终结符或非终结符），`GOTO(I, X)` 是所有形如 $[A \to \alpha X \cdot \beta]$ 的项目的闭包，其中 $[A \to \alpha \cdot X \beta]$ 必须是 $I$ 中的一个项目。

这个过程分为两步：
1.  **核心计算 (Kernel computation)**：从 $I$ 中筛选出所有点（$\cdot$）后面紧跟着符号 $X$ 的项目。对于每个这样的项目，构造一个新项目，将点向右移动过 $X$。这些新项目构成了新状态的**核心 (kernel)**。
2.  **闭包应用 (Closure application)**：对这个核心项目集应用 `CLOSURE` 运算，得到完整的目标状态。

`GOTO` 函数是自动机状态转换的驱动力。例如，从我们之前计算出的状态 $I_0 = \{ [S' \to \cdot S], [S \to \cdot TT], [T \to \cdot aT], [T \to \cdot b] \}$ 出发：
- $\operatorname{GOTO}(I_0, T)$: 在 $I_0$ 中，只有一个项目的点后是 $T$，即 $[S \to \cdot TT]$。将点移过 $T$，我们得到核心项目 $[S \to T \cdot T]$。对此核心取[闭包](@entry_id:148169)，由于点后是 $T$，我们需要再次加入 $T$ 的产生式，得到新状态 $I_2 = \{ [S \to T \cdot T], [T \to \cdot aT], [T \to \cdot b] \}$。

这个过程也让我们能清晰地划分两类项目 [@problem_id:3655642]：
- **核心项目 (Kernel items)**：一个状态的核心项目，即通过 `GOTO` 函数直接生成的项目（在应用闭包之前）。它们共同的特点是点不在产生式体的最左端。此外，初始的增广项目 $[S' \to \cdot S]$ 也被定义为核心项目。
- **非核心项目 (Non-kernel items)**：所有通过 `CLOSURE` 运算添加进来的项目。根据 `CLOSURE` 的定义，这些项目必然形如 $[B \to \cdot \gamma]$，即它们的点总是在产生式体的最左端。这是因为 `CLOSURE` 的作用就是为了“预测”一个非终结符的展开，所以它总是从该非终结符产生式的起点开始。

### LR(0) 项目的规范族：构建解析器的“大脑”

现在我们拥有了构建自动机的所有工具。**LR(0) 项目的规范族 (The canonical collection of LR(0) item sets)** 就是 LR(0) 自动机的所有状态的集合。其构建算法如下：

1.  创建一个状态集合 $C$，初始时只包含初始状态 $I_0 = \operatorname{CLOSURE}(\{[S' \to \cdot S]\})$。
2.  重复以下步骤直至在一次完整遍历中没有新状态被添加到 $C$ 中：
    -   对于 $C$ 中的每一个状态 $I_i$ 和文法中的每一个语法符号 $X$：
    -   计算 $I_j = \operatorname{GOTO}(I_i, X)$。
    -   如果 $I_j$ 非空且不在 $C$ 中，则将 $I_j$ 添加到 $C$ 中。

这个过程最终会停止，因为文法中的产生式数量是有限的，每个产生式中点的位置也是有限的，所以可能的项目总数是有限的，从而可能的项目集（状态）数量也是有限的。

这个最终的集合 $C$ 和 `GOTO` 函数一起，构成了 LR(0) 自动机。每个项目集是一个状态，每个非空的 `GOTO(I, X)` 定义了一条从状态 $I$ 到另一个状态的、标记为 $X$ 的有向边。

文法的结构特征，如递归，会在自动机中留下清晰的印记 [@problem_id:3626844]。例如，右递归产生式（如 $S \to BS$）常常在自动机中形成自循环：一个状态在读入符号 $B$ 后，通过 `GOTO` 函数可能会转移回自身。而[左递归](@entry_id:751232)（如 $S \to SA$）则通常表现为一条路径，最终导向一个包含归约项目的状态，准备将已识别的 $S$ 和 $A$ 归约回 $S$。

### 从自动机到行动：解析冲突的根源

构建好的 LR(0) 自动机是生成解析表的基础。解析表的每一行对应自动机的一个状态，每一列对应一个终结符或一个非终结符。表的条目规定了相应的动作：

- **移入 (Shift)**：如果状态 $I_i$ 中包含项目 $[A \to \alpha \cdot a \beta]$（其中 $a$ 是一个终结符），并且 $\operatorname{GOTO}(I_i, a) = I_j$，则解析表中 `ACTION[i, a]` 的条目为“移入 $j$”（shift $j$）。

- **归约 (Reduce)**：如果状态 $I_i$ 中包含一个完成项目 $[A \to \alpha \cdot]$（其中 $A \ne S'$），则对于**所有**终结符 $t$，`ACTION[i, t]` 的条目都为“按产生式 $A \to \alpha$ 归约”。这是 LR(0) 解析最关键也最“天真”的规定。

- **接受 (Accept)**：如果状态 $I_i$ 中包含项目 $[S' \to S \cdot]$，则 `ACTION[i, $$]`（`$$` 是输入结束符）的条目为“接受”。

- **转移 (Goto)**：如果 $\operatorname{GOTO}(I_i, A) = I_j$（其中 $A$ 是一个非终结符），则 `GOTO[i, A]` 的条目为 $j$。

当一个解析表的单元格需要填入多个动作时，就产生了**冲突 (conflict)**。对于 LR(0) 自动机，主要存在两种冲突：

1.  **移入-归约冲突 (Shift-Reduce Conflict)**：如果一个状态同时包含项目 $[A \to \alpha \cdot a \beta]$ 和 $[B \to \gamma \cdot]$，那么在终结符 $a$ 上，解析器既可以执行“移入”动作，也可以执行“归约”动作。

    一个经典的例子是“悬垂 else”问题 [@problem_id:3626821]。对于文法 $S \to \mathtt{if}\ E\ \mathtt{then}\ S \mid \mathtt{if}\ E\ \mathtt{then}\ S\ \mathtt{else}\ S \mid \dots$，在解析了形如 `if E then S` 的输入后，自动机会进入一个状态，其中包含类似如下的项目集：
    $\{ [S \to \mathtt{if}\ E\ \mathtt{then}\ S \cdot], [S \to \mathtt{if}\ E\ \mathtt{then}\ S \cdot \mathtt{else}\ S] \}$
    如果下一个输入符号是 `else`，第一个项目要求归约（因为它是一个完成项目），而第二个项目要求移入 `else`。LR(0) 解析器无法做出决定，因为它不向后看任何符号。

    另一个例子是模糊的表达式文法 $E \to E + E \mid id$ [@problem_id:3626867]。当解析器看到形如 `id + id` 的输入后，可能进入一个状态，其中包含项目集 $\{ [E \to E+E \cdot], [E \to E \cdot + E] \}$。如果下一个输入是 `+`，解析器既可以归约已有的 `E+E`，也可以移入 `+` 以期形成更长的表达式。这种冲突直接反映了文法中没有指定 `+` 的[结合性](@entry_id:147258)。

2.  **[归约-归约冲突](@entry_id:754169) (Reduce-Reduce Conflict)**：如果一个状态同时包含两个或多个不同的完成项目，例如 $[A \to \alpha \cdot]$ 和 $[B \to \beta \cdot]$，那么对于任何输入终结符，解析器都不知道应该按哪个产生式进行归约。[@problem_id:3626865]

如果一个文法的 LR(0) 规范族在构建解析表时，任何一个单元格都没有出现多重定义（即没有冲突），那么该文法就是 **LR(0) 文法**。然而，由于 LR(0) 的归约决策完全不考虑下一个输入符号，它的能力非常有限，很多实用的文法都不是 LR(0) 的。

### LR(0) 的局限与向前看的必要性

LR(0) 解析的弱点在于其“一刀切”的归约策略：一旦遇到一个完成项目 $[A \to \alpha \cdot]$，它就试图在任何下一个终结符面前进行归约。这显然过于草率。一个更智能的策略是，仅当下一个输入符号**可能**跟在 $A$ 之后时，才进行归约。

这引出了 **SLR(1) (Simple LR)** 解析。SLR(1) 使用与 LR(0) 完全相同的自动机（即 LR(0) 规范族），但修改了归约规则：

- **SLR(1) 归约规则**：如果状态 $I_i$ 中包含完成项目 $[A \to \alpha \cdot]$，则仅对**所有**在 $\mathrm{FOLLOW}(A)$ 集合中的终结符 $t$，将 `ACTION[i, t]` 设置为“按 $A \to \alpha$ 归约”。

$\mathrm{FOLLOW}(A)$ 是所有可能在文法推导中紧跟在非终结符 $A$ 之后的终结符集合。通过使用 $\mathrm{FOLLOW}$ 集，SLR(1) 大大减少了不必要的归约动作，从而解决了许多 LR(0) 中存在的冲突。

让我们通过一个例子来量化这种改进 [@problem_id:3626879]。考虑文法 $S' \to S, S \to Aa, A \to d$。假设在某个状态我们遇到了归约项目 $[A \to d \cdot]$。
-   在 LR(0) 中，我们会在所有终结符列（比如 $a、c、d、\$$）都填入归约动作。
-   在 SLR(1) 中，我们首先计算 $\mathrm{FOLLOW}(A)$。由于产生式 $S \to Aa$，我们知道 $a$ 可以跟在 $A$ 后面，所以 $\mathrm{FOLLOW}(A) = \{a\}$。因此，我们只在 $a$ 这一列填入归约动作。
-   相比之下，SLR(1) 消除了在 $c、d、\$$ 列上的无效归约动作，从而提高了决策的精确性。

许多非 LR(0) 的文法，在引入了 $\mathrm{FOLLOW}$ 集作为向前看符号（lookahead）的简单形式后，其冲突得以解决，这样的文法就是 **SLR(1) 文法** [@problem_id:3626865]。例如，如果一个状态中存在移入-归约冲突，形如 $\{ [A \to \alpha \cdot a \beta], [B \to \gamma \cdot] \}$，只要终结符 $a$ 不在 $\mathrm{FOLLOW}(B)$ 集合中，这个冲突在 SLR(1) 解析表中就不存在了。同样，对于[归约-归约冲突](@entry_id:754169) $\{ [A \to \alpha \cdot], [B \to \beta \cdot] \}$，只要 $\mathrm{FOLLOW}(A)$ 和 $\mathrm{FOLLOW}(B)$ 两个集合不相交，冲突也能被解决。

尽管 SLR(1) 已经比 LR(0) 强大得多，但 $\mathrm{FOLLOW}$ 集是一种全局性的信息，有时仍然不够精确。更强大的 LR 解析方法，如 LALR(1) 和 LR(1)，会为自动机状态的构建过程引入更精细的向前看符号信息，但这将以更复杂的状态或构造过程为代价。我们将在后续章节中探讨这些更强大的技术。