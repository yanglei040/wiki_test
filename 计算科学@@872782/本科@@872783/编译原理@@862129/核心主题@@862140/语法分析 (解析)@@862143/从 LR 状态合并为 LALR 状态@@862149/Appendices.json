{"hands_on_practices": [{"introduction": "理解 $\\text{LALR}(1)$ 状态合并的最佳方式是完整地实践一个例子。第一个练习 [@problem_id:3648903] 提供了一个简单的文法，其状态合并过程是“安全的”——它成功地减少了状态数量，而没有产生任何分析冲突。通过这个练习，你将巩固对构建 $\\text{LR}(1)$ 项目集并进行合并的核心机制的理解。", "problem": "考虑增广文法，其产生式为 $S' \\to S$，$S \\to C C$ 和 $C \\to c C \\mid d$。使用 $\\text{LR}(1)$（带1个前瞻符号的向前看、从左到右扫描、最右推导）和 $\\text{LALR}(1)$（向前看 $\\text{LR}(1)$）的基本定义，其中一个 $\\text{LR}(1)$ 项目具有 $[A \\to \\alpha \\cdot \\beta, a]$ 的形式，并且其规范集族由标准的 $\\operatorname{closure}$ 和 $\\operatorname{goto}$ 操作构建，请完成以下操作：\n\n- 使用标准的 $\\operatorname{closure}$ 和 $\\operatorname{goto}$ 定义，从 $[S' \\to \\cdot S, \\$]$ 开始，为该增广文法构建规范 $\\text{LR}(1)$ 项目集。\n- 识别所有核心等价的 $\\text{LR}(1)$ 项目集对或组，其中一个集合的核心是通过删除其 $\\text{LR}(1)$ 项目的前瞻符号得到的，即将其视为 $\\text{LR}(0)$ 项目。\n- 通过合并每组核心等价的状态来构造 $\\text{LALR}(1)$ 自动机，并从分析器动作的基本原理出发，论证为何对于此文法，合并操作不会引入移入-归约或归约-归约冲突。\n\n将合并核心等价的 $\\text{LR}(1)$ 状态后得到的不同 $\\text{LALR}(1)$ 状态的精确总数作为最终答案。最终答案应表示为一个精确整数，无需四舍五入。", "solution": "该问题要求为给定文法构建 $\\text{LALR}(1)$ 自动机，从规范 $\\text{LR}(1)$ 项目集开始。这涉及三个主要步骤：首先，构建完整的 $\\text{LR}(1)$ 项目集族；其次，识别这些集合中哪些是核心等价的；第三，合并这些等价集合以形成 $\\text{LALR}(1)$ 状态，并证明对于这个特定文法，此合并过程不会引入分析冲突。\n\n增广文法由以下产生式给出：\n$1$. $S' \\to S$\n$2$. $S \\to C C$\n$3$. $C \\to c C$\n$4$. $C \\to d$\n\n一个 $\\text{LR}(1)$ 项目的形式为 $[A \\to \\alpha \\cdot \\beta, a]$，其中 $A \\to \\alpha\\beta$ 是一个产生式，$a$ 是一个作为前瞻符号的终结符。为简洁起见，我们将一组仅在前瞻符号上不同的项目，例如 $\\{[A \\to \\alpha \\cdot \\beta, a_1], [A \\to \\alpha \\cdot \\beta, a_2], \\dots \\}$，表示为单个条目 $[A \\to \\alpha \\cdot \\beta, a_1/a_2/\\dots]$。\n\n首先，我们必须确定非终结符的 $\\operatorname{FIRST}$ 集，这是 $\\operatorname{closure}$ 操作所需要的。\n$\\operatorname{FIRST}(C)$ 从其产生式 $C \\to cC$ 和 $C \\to d$ 推导得出。因此，$\\operatorname{FIRST}(C) = \\{c, d\\}$。\n$\\operatorname{FIRST}(S)$ 从 $S \\to CC$ 推导得出。因此，$\\operatorname{FIRST}(S) = \\operatorname{FIRST}(C) = \\{c, d\\}$。\n\n现在我们构建规范 $\\text{LR}(1)$ 项目集族，从初始项目 $[S' \\to \\cdot S, \\$]$ 的闭包开始。\n\n$I_0 = \\operatorname{closure}(\\{[S' \\to \\cdot S, \\$]\\})$\n项目 $[S' \\to \\cdot S, \\$]$ 意味着我们可能会看到一个从 $S$ 推导出的字符串。$S$ 后面的前瞻符号是 $\\$$。因此，我们为 $S$ 的产生式添加前瞻符号为 $\\$$ 的项目。\n$[S \\to \\cdot CC, \\$]$。由于点在一个非终结符 $C$ 之前，我们为 $C$ 的产生式添加项目。这些新项目的前瞻符号是 $\\operatorname{FIRST}(C\\$)$，因为 $C$ 不可为空，所以它等于 $\\operatorname{FIRST}(C)$。因此，前瞻符号是 $c$ 和 $d$。\n$I_0 = \\{[S' \\to \\cdot S, \\$], [S \\to \\cdot CC, \\$], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n\n接下来，我们计算 $I_0$ 在所有文法符号 $S, C, c, d$ 上的 $\\operatorname{goto}$ 函数。\n\n$\\operatorname{goto}(I_0, S) = \\operatorname{closure}(\\{[S' \\to S \\cdot, \\$]\\}) = I_1$\n$I_1 = \\{[S' \\to S \\cdot, \\$]\\}$ (接受状态)\n\n$\\operatorname{goto}(I_0, C) = \\operatorname{closure}(\\{[S \\to C \\cdot C, \\$]\\}) = I_2$\n对于 $[S \\to C \\cdot C, \\$]$，点在 $C$ 之前。前瞻符号是 $\\operatorname{FIRST}(\\epsilon\\$) = \\{\\$\\}$。\n$I_2 = \\{[S \\to C \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n\n$\\operatorname{goto}(I_0, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, c/d]\\}) = I_3$\n对于 $[C \\to c \\cdot C, c/d]$，点在 $C$ 之前。前瞻符号是 $\\operatorname{FIRST}(\\epsilon(c/d)) = \\{c, d\\}$。\n$I_3 = \\{[C \\to c \\cdot C, c/d], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n\n$\\operatorname{goto}(I_0, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, c/d]\\}) = I_4$\n$I_4 = \\{[C \\to d \\cdot, c/d]\\}$ (归约状态)\n\n现在我们为新状态 $I_2, I_3, I_4$ 计算转移。\n\n从 $I_2$ 出发：\n$\\operatorname{goto}(I_2, C) = \\operatorname{closure}(\\{[S \\to CC \\cdot, \\$]\\}) = I_5$\n$I_5 = \\{[S \\to CC \\cdot, \\$]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_2, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, \\$]\\}) = I_6$\n对于 $[C \\to c \\cdot C, \\$]$，新的 $C$ 产生式的前瞻符号是 $\\operatorname{FIRST}(\\epsilon\\$) = \\{\\$\\}$。\n$I_6 = \\{[C \\to c \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n\n$\\operatorname{goto}(I_2, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, \\$]\\}) = I_7$\n$I_7 = \\{[C \\to d \\cdot, \\$]\\}$ (归约状态)\n\n从 $I_3$ 出发：\n$\\operatorname{goto}(I_3, C) = \\operatorname{closure}(\\{[C \\to cC \\cdot, c/d]\\}) = I_8$\n$I_8 = \\{[C \\to cC \\cdot, c/d]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_3, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, c/d]\\}) = I_3$ (一个到自身的循环)\n\n$\\operatorname{goto}(I_3, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, c/d]\\}) = I_4$\n\n从 $I_4$ 出发：这是一个归约状态，所以没有出向转移。\n\n从 $I_5$ 出发：这是一个归约状态，所以没有出向转移。\n\n从 $I_6$ 出发：\n$\\operatorname{goto}(I_6, C) = \\operatorname{closure}(\\{[C \\to cC \\cdot, \\$]\\}) = I_9$\n$I_9 = \\{[C \\to cC \\cdot, \\$]\\}$ (归约状态)\n\n$\\operatorname{goto}(I_6, c) = \\operatorname{closure}(\\{[C \\to c \\cdot C, \\$]\\}) = I_6$ (一个到自身的循环)\n\n$\\operatorname{goto}(I_6, d) = \\operatorname{closure}(\\{[C \\to d \\cdot, \\$]\\}) = I_7$\n\n状态 $I_7, I_8, I_9$ 是归约状态，因此没有更多状态需要生成。我们已经找到了所有 $10$ 个 $\\text{LR}(1)$ 状态（从 $I_0$ 到 $I_9$）。\n\n规范 $\\text{LR}(1)$ 项目集如下：\n$I_0 = \\{[S' \\to \\cdot S, \\$], [S \\to \\cdot CC, \\$], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n$I_1 = \\{[S' \\to S \\cdot, \\$]\\}$\n$I_2 = \\{[S \\to C \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n$I_3 = \\{[C \\to c \\cdot C, c/d], [C \\to \\cdot cC, c/d], [C \\to \\cdot d, c/d]\\}$\n$I_4 = \\{[C \\to d \\cdot, c/d]\\}$\n$I_5 = \\{[S \\to CC \\cdot, \\$]\\}$\n$I_6 = \\{[C \\to c \\cdot C, \\$], [C \\to \\cdot cC, \\$], [C \\to \\cdot d, \\$]\\}$\n$I_7 = \\{[C \\to d \\cdot, \\$]\\}$\n$I_8 = \\{[C \\to cC \\cdot, c/d]\\}$\n$I_9 = \\{[C \\to cC \\cdot, \\$]\\}$\n\n接下来，我们识别核心等价的集合。一个 $\\text{LR}(1)$ 项目集的核心是通过移除前瞻符号得到的 $\\text{LR}(0)$ 项目集。\n$\\operatorname{core}(I_0) = \\{S' \\to \\cdot S, S \\to \\cdot CC, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_1) = \\{S' \\to S \\cdot\\}$\n$\\operatorname{core}(I_2) = \\{S \\to C \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_3) = \\{C \\to c \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_4) = \\{C \\to d \\cdot\\}$\n$\\operatorname{core}(I_5) = \\{S \\to CC \\cdot\\}$\n$\\operatorname{core}(I_6) = \\{C \\to c \\cdot C, C \\to \\cdot cC, C \\to \\cdot d\\}$\n$\\operatorname{core}(I_7) = \\{C \\to d \\cdot\\}$\n$\\operatorname{core}(I_8) = \\{C \\to cC \\cdot\\}$\n$\\operatorname{core}(I_9) = \\{C \\to cC \\cdot\\}$\n\n通过比较这些核心，我们识别出以下几组核心等价的状态：\n1. $\\operatorname{core}(I_3) = \\operatorname{core}(I_6)$\n2. $\\operatorname{core}(I_4) = \\operatorname{core}(I_7)$\n3. $\\operatorname{core}(I_8) = \\operatorname{core}(I_9)$\n\n$\\text{LALR}(1)$ 自动机是通过合并这些核心等价的集合形成的。新状态是原始状态中项目的并集。\n$I_{36} = I_3 \\cup I_6 = \\{[C \\to c \\cdot C, c/d/\\$], [C \\to \\cdot cC, c/d/\\$], [C \\to \\cdot d, c/d/\\$]\\}$\n$I_{47} = I_4 \\cup I_7 = \\{[C \\to d \\cdot, c/d/\\$]\\}$\n$I_{89} = I_8 \\cup I_9 = \\{[C \\to cC \\cdot, c/d/\\$]\\}$\n\n不同的 $\\text{LALR}(1)$ 状态是：$I_0, I_1, I_2, I_5$ 以及三个新的合并状态 $I_{36}, I_{47}, I_{89}$。\n$\\text{LALR}(1)$ 状态的总数是 $4 + 3 = 7$。\n\n最后，我们必须证明为什么这种合并不会引入冲突。如果合并过程导致某个状态在面对单个前瞻符号时，可能存在多个动作（移入或归约），那么 $\\text{LALR}(1)$ 分析器中就会出现冲突。\n原始的 $\\text{LR}(1)$ 自动机是无冲突的，这在构建过程中已经得到验证。\n我们来分析这些合并后的状态：\n- **$I_{36}$**：此状态只包含移入型项目（点不在产生式的末尾）。合并这类状态不会产生归约-归约或移入-归约冲突，因为没有涉及归约项目。分析器在输入为 $c$ 或 $d$ 时将执行移入操作。\n- **$I_{47}$**：合并 $I_4 = \\{[C \\to d \\cdot, c/d]\\}$ 和 $I_7 = \\{[C \\to d \\cdot, \\$]\\}$。结果状态是 $I_{47} = \\{[C \\to d \\cdot, c/d/\\$]\\}$。在此状态下，分析器的动作是在前瞻符号为 $c$、$d$ 或 $\\$$ 时，按产生式 $C \\to d$ 进行归约。由于此状态中只有一个产生式规则，因此不会发生归约-归约冲突。此外，没有移入项目，所以也不会发生移入-归约冲突。如果前瞻符号集不互斥且产生式规则不同，则可能会产生冲突，但此处规则是相同的（$C \\to d$）。\n- **$I_{89}$**：合并 $I_8 = \\{[C \\to cC \\cdot, c/d]\\}$ 和 $I_9 = \\{[C \\to cC \\cdot, \\$]\\}$。结果状态是 $I_{89} = \\{[C \\to cC \\cdot, c/d/\\$]\\}$。这里的动作是在前瞻符号为 $c$、$d$ 或 $\\$$ 时，按产生式 $C \\to cC$ 进行归约。与 $I_{47}$ 的情况类似，这里只有一个产生式规则，因此没有引入冲突。\n\n总而言之，对于此文法，合并核心等价状态是安全的。在涉及归约项目的情况下（$I_4$ 和 $I_7$；$I_8$ 和 $I_9$），被合并的两个状态中用于归约的产生式规则是相同的，并且它们原始的前瞻符号集是互斥的。因此，它们的并集只是为一个单一、明确的归约动作扩展了前瞻符号集。只包含移入项的状态（$I_3$ 和 $I_6$）的合并本身也是安全的。这证实了最终的 $\\text{LALR}(1)$ 分析器是无冲突的。\n\n不同的 $\\text{LALR}(1)$ 状态的最终数量是 $7$。", "answer": "$$\\boxed{7}$$", "id": "3648903"}, {"introduction": "在看到了一个成功的合并案例后，理解合并在何时以及为何会失败至关重要。下一个练习 [@problem_id:3648858] 提出了一个 $\\text{LR}(1)$ 但非 $\\text{LALR}(1)$ 的文法，这意味着状态合并过程会引入归约-归约冲突。通过找出一个能够区分原始 $\\text{LR}(1)$ 状态，但在合并后的 $\\text{LALR}(1)$ 状态中导致歧义的输入串，你将具体地理解这些冲突在实践中是如何体现的。", "problem": "考虑一个上下文无关文法，其开始符号为 $S$，终结符为 $\\{a,b,t,x,y\\}$，由以下产生式定义\n- $S \\rightarrow a\\,A\\,x$\n- $S \\rightarrow a\\,B\\,y$\n- $S \\rightarrow b\\,A\\,y$\n- $S \\rightarrow b\\,B\\,x$\n- $A \\rightarrow t$\n- $B \\rightarrow t$\n使用 $\\text{LR}(1)$（自左向右扫描，反向最右推导，带 $1$ 个前瞻符号）项目的规范定义、用于 $\\text{LR}(1)$ 项目集的闭包和 goto 构建方法，以及从规范 $\\text{LR}(1)$ 状态构建向前看 LR ($\\text{LALR}$) 分析器的标准合并规则（通过对每个项目取其前瞻集合的并集，来合并具有相同 $\\text{LR}(0)$ 核心的状态）。\n\n从这些基本定义出发，完成以下任务：\n1. 分别确定在扫描前缀 $a\\,t$ 和 $b\\,t$ 后立即到达的两个规范 $\\text{LR}(1)$ 项目集。从第一性原理出发，论证这两个 $\\text{LR}(1)$ 项目集具有相同的 $\\text{LR}(0)$ 核心，但其前瞻符号分配不同。\n2. 在终结符字母表 $\\{a,b,t,x,y\\}$上定义一个测试输入后缀 $\\omega$，该后缀能区分这两个未合并的 $\\text{LR}(1)$ 状态，即当将 $\\omega$ 附加到固定的前缀 $a\\,t$ 和 $b\\,t$ 后， $\\text{LR}(1)$ 分析器将在这两个状态下对相同的下一个终结符采取不同的归约动作。然后，解释这两个状态的 LALR 合并如何通过在同一个下一个终结符上创建模糊的（归约-归约）动作来消除这种区分。\n3. 设 $\\ell$ 表示这样的区分后缀 $\\omega$ 的最小长度（以终结符数量计），该后缀在步骤 2 所述的 LALR 构建下也变得模糊。计算 $\\ell$ 的值。\n\n你的最终答案必须是 $\\ell$ 的一个单一整数值。不要在最终值之外提供任何额外的评论。", "solution": "该问题要求分析给定上下文无关文法的 $\\text{LR}(1)$ 和 $\\text{LALR}(1)$ 属性。我们将通过构建相关的 $\\text{LR}(1)$ 状态，分析它们的属性，并确定能揭示相应 $\\text{LALR}(1)$ 分析器中归约-归约冲突的区分后缀的最小长度来进行。\n\n给定的文法产生式如下：\n$S \\rightarrow a\\,A\\,x$\n$S \\rightarrow a\\,B\\,y$\n$S \\rightarrow b\\,A\\,y$\n$S \\rightarrow b\\,B\\,x$\n$A \\rightarrow t$\n$B \\rightarrow t$\n\n我们首先通过引入新的开始符号 $S'$ 和输入结束标记 $\\$$ 来创建增广文法。其产生式为：\n$P_0: S' \\rightarrow S$\n$P_1: S \\rightarrow a\\,A\\,x$\n$P_2: S \\rightarrow a\\,B\\,y$\n$P_3: S \\rightarrow b\\,A\\,y$\n$P_4: S \\rightarrow b\\,B\\,x$\n$P_5: A \\rightarrow t$\n$P_6: B \\rightarrow t$\n\n一个 $\\text{LR}(1)$ 项目是一个在其右侧带有一个点，并带有一个前瞻终结符的产生式，记作 $[A \\rightarrow \\alpha . \\beta, z]$。\n\n步骤 1：构建相关的 $\\text{LR}(1)$ 状态。\n\n初始状态 $I_0$ 是初始项目 $[S' \\rightarrow .S, \\$]$ 的闭包。\n为了计算闭包，对于项目 $[D \\rightarrow \\gamma . C \\delta, a]$ 中紧跟在点后面的任何非终结符 $C$，我们添加 $C$ 的产生式。新项目的前瞻符号由 $\\text{FIRST}(\\delta a)$ 给出。\n$I_0 = \\text{closure}(\\{[S' \\rightarrow .S, \\$]\\})$\n点在 $S$ 之前。我们添加所有 $S$ 的产生式，前瞻符号为 $\\$$。\n$I_0 = \\{ [S' \\rightarrow .S, \\$], [S \\rightarrow .a\\,A\\,x, \\$], [S \\rightarrow .a\\,B\\,y, \\$], [S \\rightarrow .b\\,A\\,y, \\$], [S \\rightarrow .b\\,B\\,x, \\$] \\}$\n\n接下来，我们计算扫描符号 $a$ 和 $b$ 后到达的状态。\n扫描 $a$ 后到达的状态是 $I_1 = \\text{goto}(I_0, a)$。\n$I_1 = \\text{closure}(\\{ [S \\rightarrow a.A\\,x, \\$], [S \\rightarrow a.B\\,y, \\$] \\})$\n点在 $A$ 之前，前瞻符号为 $x$（来自 $\\text{FIRST}(x\\$)$）。我们添加 $A$ 的产生式。\n点在 $B$ 之前，前瞻符号为 $y$（来自 $\\text{FIRST}(y\\$)$）。我们添加 $B$ 的产生式。\n这得到：\n$I_1 = \\{ [S \\rightarrow a.A\\,x, \\$], [S \\rightarrow a.B\\,y, \\$], [A \\rightarrow .t, x], [B \\rightarrow .t, y] \\}$\n\n扫描 $b$ 后到达的状态是 $I_2 = \\text{goto}(I_0, b)$。\n$I_2 = \\text{closure}(\\{ [S \\rightarrow b.A\\,y, \\$], [S \\rightarrow b.B\\,x, \\$] \\})$\n点在 $A$ 之前，前瞻符号为 $y$（来自 $\\text{FIRST}(y\\$)$）。我们添加 $A$ 的产生式。\n点在 $B$ 之前，前瞻符号为 $x$（来自 $\\text{FIRST}(x\\$)$）。我们添加 $B$ 的产生式。\n这得到：\n$I_2 = \\{ [S \\rightarrow b.A\\,y, \\$], [S \\rightarrow b.B\\,x, \\$], [A \\rightarrow .t, y], [B \\rightarrow .t, x] \\}$\n\n现在我们计算扫描前缀 $a\\,t$ 和 $b\\,t$ 后到达的状态。\n在 $a\\,t$ 之后的状态是 $I_3 = \\text{goto}(I_1, t)$。我们在 $I_1$ 的项目中将点移过 $t$。\n$I_3 = \\text{closure}(\\{ [A \\rightarrow t., x], [B \\rightarrow t., y] \\})$\n由于点都在末尾，闭包就是该集合本身。\n$$I_3 = \\{ [A \\rightarrow t., x], [B \\rightarrow t., y] \\}$$\n\n在 $b\\,t$ 之后的状态是 $I_4 = \\text{goto}(I_2, t)$。我们在 $I_2$ 的项目中将点移过 $t$。\n$I_4 = \\text{closure}(\\{ [A \\rightarrow t., y], [B \\rightarrow t., x] \\})$\n由于点都在末尾，闭包就是该集合本身。\n$$I_4 = \\{ [A \\rightarrow t., y], [B \\rightarrow t., x] \\}$$\n\n这完成了任务的第一部分，即确定了两个 $\\text{LR}(1)$ 项目集。现在我们论证它们具有相同的 $\\text{LR}(0)$ 核心但前瞻符号不同。\n一个 $\\text{LR}(1)$ 项目集的 $\\text{LR}(0)$ 核心是通过从每个项目中移除前瞻部分得到的。\n$I_3$ 的 $\\text{LR}(0)$ 核心是 $\\{ A \\rightarrow t., B \\rightarrow t. \\}$。\n$I_4$ 的 $\\text{LR}(0)$ 核心是 $\\{ A \\rightarrow t., B \\rightarrow t. \\}$。\n这两个核心是相同的。\n\n然而，前瞻符号的分配是不同的。\n在状态 $I_3$ 中：项目 $[A \\rightarrow t.]$ 的前瞻符号是 $\\{x\\}$，而项目 $[B \\rightarrow t.]$ 的前瞻符号是 $\\{y\\}$。\n在状态 $I_4$ 中：项目 $[A \\rightarrow t.]$ 的前瞻符号是 $\\{y\\}$，而项目 $[B \\rightarrow t.]$ 的前瞻符号是 $\\{x\\}$。\n状态 $I_3$ 和 $I_4$ 是不同的 $\\text{LR}(1)$ 状态。\n\n步骤 2：区分后缀和 LALR 冲突分析。\n\n如果一个 $\\text{LR}(1)$ 分析器在看到后缀 $\\omega$ 的第一个符号时，在状态 $I_3$ 和 $I_4$ 中采取不同的动作，则称后缀 $\\omega$ 能够区分这两个状态。在状态 $I_3$ 和 $I_4$ 中的动作都是归约，因为所有项目的点都在末尾。\n\n在状态 $I_3$ 中，在前缀 $a\\,t$ 之后：\n- 如果下一个输入符号是 $x$，分析器使用产生式 $A \\rightarrow t$ 进行归约。\n- 如果下一个输入符号是 $y$，分析器使用产生式 $B \\rightarrow t$ 进行归约。\n\n在状态 $I_4$ 中，在前缀 $b\\,t$ 之后：\n- 如果下一个输入符号是 $x$，分析器使用产生式 $B \\rightarrow t$ 进行归约。\n- 如果下一个输入符号是 $y$，分析器使用产生式 $A \\rightarrow t$ 进行归约。\n\n让我们定义区分后缀 $\\omega = x$。\n当分析器处于状态 $I_3$（在看到 $a\\,t$ 之后）且下一个输入是 $x$ 时，它执行按 $A \\rightarrow t$ 归约。\n当分析器处于状态 $I_4$（在看到 $b\\,t$ 之后）且下一个输入是 $x$ 时，它执行按 $B \\rightarrow t$ 归约。\n由于按 $A \\rightarrow t$ 归约和按 $B \\rightarrow t$ 归约是不同的动作（对应于产生式 $P_5$ 和 $P_6$），后缀 $\\omega = x$ 成功地区分了这两个状态。\n\n现在，考虑 LALR 构建。具有相同 $\\text{LR}(0)$ 核心的状态被合并。因此，$I_3$ 和 $I_4$ 被合并成一个单一状态，我们称之为 $I_{34}$。这个合并状态中的项目是通过对每个相应的 $\\text{LR}(0)$ 项目取其前瞻符号的并集而形成的。\n- 对于项目核心 $[A \\rightarrow t.]$，前瞻符号来自 $I_3$ 的 $\\{x\\}$ 和来自 $I_4$ 的 $\\{y\\}$。其并集是 $\\{x, y\\}$。\n- 对于项目核心 $[B \\rightarrow t.]$，前瞻符号来自 $I_3$ 的 $\\{y\\}$ 和来自 $I_4$ 的 $\\{x\\}$。其并集是 $\\{x, y\\}$。\n\n合并后的 $\\text{LALR}(1)$ 状态是：\n$$I_{34} = \\{ [A \\rightarrow t., \\{x, y\\}], [B \\rightarrow t., \\{x, y\\}] \\}$$\n在 LALR 分析器中，无论是在前缀 $a\\,t$ 还是 $b\\,t$ 之后，分析器都会进入状态 $I_{34}$。如果下一个输入符号是 $x$（我们后缀 $\\omega$ 的第一个符号），我们查询状态 $I_{34}$ 和前瞻符号 $x$ 的分析表。\n- 项目 $[A \\rightarrow t., \\{x, y\\}]$ 指示分析器通过 $A \\rightarrow t$ 进行归约。\n- 项目 $[B \\rightarrow t., \\{x, y\\}]$ 指示分析器通过 $B \\rightarrow t$ 进行归约。\n这构成了一个归约-归约冲突。分析器无法决定应用哪个归约。同样地，在前瞻符号 $y$ 上也会发生相同的冲突。因此，LALR 构建所要求的合并引入了规范 $\\text{LR}(1)$ 分析器中不存在的模糊性。该文法是 $\\text{LR}(1)$ 的，但不是 $\\text{LALR}(1)$ 的。\n\n步骤 3：计算最小长度 $\\ell$。\n\n我们寻求能触发 LALR 冲突的区分后缀 $\\omega$ 的最小长度 $\\ell$。\n设 $\\omega$ 的长度为 $|\\omega|$。\n是否可以 $|\\omega| = 0$？如果 $\\omega$ 是空字符串，那么前瞻符号是输入结束标记 $\\$$。状态 $I_3$ 中的前瞻符号集合是 $\\{x, y\\}$，在 $I_4$ 中也是 $\\{x, y\\}$。符号 $\\$$ 在这两个状态中都不是任何归约的前瞻符号。一个 $\\text{LR}(1)$ 分析器在这两种情况下都会报告语法错误。没有区分动作。因此，$\\ell > 0$。\n\n是否可以 $|\\omega| = 1$？设 $\\omega$ 是一个单一的终结符，$\\omega = z$。\n为了使 $z$ 成为一个区分符号，它必须在 $I_3$ 和 $I_4$ 中触发不同的归约。如步骤 2 所示，$z=x$ 和 $z=y$ 都满足这个条件。\n我们选择 $\\omega = x$。\n- 在 $\\text{LR}(1)$ 中的区分：在 $a\\,t$ 之后，当前瞻符号为 $x$ 时，归约为 $A \\rightarrow t$。在 $b\\,t$ 之后，当前瞻符号为 $x$ 时，归约为 $B \\rightarrow t$。这两个动作是不同的。\n- 在 $\\text{LALR}(1)$ 中的模糊性：在合并后的状态 $I_{34}$ 中，当前瞻符号为 $x$ 时，在 $A \\rightarrow t$ 和 $B \\rightarrow t$ 之间存在一个归约-归约冲突。\n因此，存在一个长度为 $1$ 的后缀，它满足问题的所有标准。\n\n由于 $\\ell > 0$ 且存在一个长度为 $1$ 的有效后缀，最小长度 $\\ell$ 必定为 $1$。\n因此，这样一个区分后缀 $\\omega$ 的最小长度是 $\\ell = 1$。", "answer": "$$\\boxed{1}$$", "id": "3648858"}, {"introduction": "我们最后的练习 [@problem_id:3648837] 从特定的文法转向更抽象和形式化的分析。你将不再需要从头构建状态，而是直接获得两个核等价状态的基本属性，并应用一个形式化准则来判断它们的合并是否会产生冲突。这个练习旨在锻炼你直接对冲突条件进行推理的能力，这是理解分析器生成工具和诊断分析问题的关键技能。", "problem": "考虑通过合并共享相同核心的 $\\text{LR}(1)$（带单符号前瞻的从左到右最右推导）状态来构建 $\\text{LALR}(1)$ 分析表的标准方法。一个 $\\text{LR}(1)$ 项目写作 $[A \\rightarrow \\alpha \\, . \\, \\beta, a]$，其中 $A \\rightarrow \\alpha\\beta$ 是一个产生式，点表示在右部的位置，而 $a$ 是一个终结符前瞻符号。归约项目是任何形如 $[A \\rightarrow \\alpha \\, ., a]$ 的项目。一个状态的核心是其所有项目在抹去前瞻符号后构成的集合。\n\n如果两个 $\\text{LR}(1)$ 状态在忽略前瞻符号后具有相同的项目集，则它们是核心等价的。当将核心等价的 $\\text{LR}(1)$ 状态合并成一个单一的 $\\text{LALR}(1)$ 状态时，相应项目的前瞻集会进行并集操作。如果在某个状态中存在两个不同的归约项目，它们都规定在同一个终结符上进行归约操作，那么就会产生归约-归约冲突。\n\n为一对具有共同核心的核心等价 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$ 定义一个局部合并阻塞准则。对于核心中的每个不同归约项目 $r_{i}$，令 $L_{i}^{(1)}$ 和 $L_{i}^{(2)}$ 分别为其在 $I_{1}$ 和 $I_{2}$ 中的前瞻集。在合并后的状态中，归约项目 $r_{i}$ 的前瞻集为 $L_{i} = L_{i}^{(1)} \\cup L_{i}^{(2)}$。令冲突集为\n$$\nC = \\left\\{\\, t \\in \\Sigma \\;\\middle|\\; \\text{存在不同的归约项目 } r_{i} \\neq r_{j} \\text{ 使得 } t \\in L_{i} \\text{ 且 } t \\in L_{j} \\,\\right\\},\n$$\n其中 $\\Sigma$ 是终结符集。如果 $|C| > 0$，则合并被阻塞。合并阻塞冲突指数定义为基数 $|C|$。\n\n现在考虑以下两个核心等价的 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$，它们的共同核心恰好由两个归约项目 $r_{A}$ 和 $r_{B}$ 组成：\n- 核心 $K = \\{ [A \\rightarrow \\alpha \\, ., \\_],\\; [B \\rightarrow \\beta \\, ., \\_] \\}$，其中下划线表示被抹去的前瞻符号。\n- 在 $I_{1}$ 中，前瞻集为 $L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。\n- 在 $I_{2}$ 中，前瞻集为 $L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。\n\n假设 $I_{1}$ 和 $I_{2}$ 各自是无冲突的（即，对于每个状态，其不同归约项目的前瞻集是不相交的）。使用上面定义的局部合并阻塞准则，计算由 $I_{1}$ 和 $I_{2}$ 合并形成的状态的合并阻塞冲突指数 $|C|$。将 $|C|$ 的最终值以单个整数形式给出。无需四舍五-入。", "solution": "首先验证问题以确保其科学基础可靠、问题设定良好且客观。\n\n**步骤 1：提取已知条件**\n- 背景是从 $\\text{LR}(1)$ 状态构造 $\\text{LALR}(1)$ 分析表。\n- 一个 $\\text{LR}(1)$ 项目的形式为 $[A \\rightarrow \\alpha \\, . \\, \\beta, a]$，其中 $A \\rightarrow \\alpha\\beta$ 是一个产生式，点标记当前位置，$a$ 是一个终结符前瞻符号。\n- 一个归约项目的形式为 $[A \\rightarrow \\alpha \\, ., a]$。\n- 一个 $\\text{LR}(1)$ 状态的核心是其所有项目在抹去前瞻符号后构成的集合。\n- 合并核心等价的 $\\text{LR}(1)$ 状态涉及对相应项目的前瞻集取并集。\n- 为两个核心等价的 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$ 定义了一个局部合并阻塞准则。\n- 对于共同核心中的每个不同归约项目 $r_{i}$，其在 $I_{1}$ 中的前瞻集为 $L_{i}^{(1)}$，在 $I_{2}$ 中的为 $L_{i}^{(2)}$。\n- 在合并状态中，$r_{i}$ 的前瞻集是 $L_{i} = L_{i}^{(1)} \\cup L_{i}^{(2)}$。\n- 合并状态的冲突集定义为 $C = \\left\\{\\, t \\in \\Sigma \\;\\middle|\\; \\text{存在不同的归约项目 } r_{i} \\neq r_{j} \\text{ 使得 } t \\in L_{i} \\text{ 且 } t \\in L_{j} \\,\\right\\}$。\n- 合并阻塞冲突指数定义为 $|C|$。\n- 给定了两个特定的核心等价 $\\text{LR}(1)$ 状态，$I_{1}$ 和 $I_{2}$。\n- 它们的共同核心 $K$ 恰好由两个归约项目组成：$K = \\{ [A \\rightarrow \\alpha \\, ., \\_],\\; [B \\rightarrow \\beta \\, ., \\_] \\}$。我们将这些核心项目分别表示为 $r_{A}$ 和 $r_{B}$。\n- 状态 $I_{1}$ 中的前瞻集：$L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。\n- 状态 $I_{2}$ 中的前瞻集：$L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。\n- 有一个明确的假设：$I_{1}$ 和 $I_{2}$ 各自是无冲突的。\n- 任务是计算合并后状态的合并阻塞冲突指数 $|C|$。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题定义明确，植根于标准编译器理论。$\\text{LR}(1)$ 项目、状态、核心以及 $\\text{LALR}(1)$ 合并过程的定义都是正确的。归约-归约冲突的概念，以及通过检查单个状态中不同归约产生式的前瞻集是否不相交来识别该冲突的方法，是基础性的。该问题在一个提议的合并情境下将此检查形式化。\n状态 $I_{1}$ 和 $I_{2}$ 各自无冲突的假设与给定数据一致。\n- 在状态 $I_{1}$ 中，两个不同归约项目的前瞻集是 $L_{A}^{(1)} = \\{ a \\}$ 和 $L_{B}^{(1)} = \\{ b, c \\}$。它们的交集是 $L_{A}^{(1)} \\cap L_{B}^{(1)} = \\{ a \\} \\cap \\{ b, c \\} = \\emptyset$。因此，$I_{1}$ 是无冲突的。\n- 在状态 $I_{2}$ 中，两个不同归约项目的前瞻集是 $L_{A}^{(2)} = \\{ b \\}$ 和 $L_{B}^{(2)} = \\{ a \\}$。它们的交集是 $L_{A}^{(2)} \\cap L_{B}^{(2)} = \\{ b \\} \\cap \\{ a \\} = \\emptyset$。因此，$I_{2}$ 是无冲突的。\n由于问题内部一致、科学上合理，并为唯一解提供了所有必要信息，因此判定其有效。\n\n**步骤 3：结论与行动**\n问题有效。将提供完整解答。\n\n**解题过程**\n目标是计算通过合并两个核心等价的 $\\text{LR}(1)$ 状态 $I_{1}$ 和 $I_{2}$ 而形成的 $\\text{LALR}(1)$ 状态的合并阻塞冲突指数 $|C|$。\n\n这些状态的共同核心包含两个不同的归约项目，我们用它们对应的产生式来表示：$r_{A}$ 代表 $A \\rightarrow \\alpha$，$r_{B}$ 代表 $B \\rightarrow \\beta$。问题给出了这两个项目中，在每个 $\\text{LR}(1)$ 状态内的前瞻集。\n\n首先，我们计算合并状态中每个归约项目的前瞻集。根据问题定义，合并状态中项目的前瞻集是其在原始状态中前瞻集的并集。\n\n对于归约项目 $r_{A}$（来自产生式 $A \\rightarrow \\alpha$），其在合并状态中的前瞻集 $L_{A}$ 为：\n$$\nL_{A} = L_{A}^{(1)} \\cup L_{A}^{(2)}\n$$\n代入给定的集合：\n$$\nL_{A} = \\{ a \\} \\cup \\{ b \\} = \\{ a, b \\}\n$$\n\n对于归约项目 $r_{B}$（来自产生式 $B \\rightarrow \\beta$），其在合并状态中的前瞻集 $L_{B}$ 为：\n$$\nL_{B} = L_{B}^{(1)} \\cup L_{B}^{(2)}\n$$\n代入给定的集合：\n$$\nL_{B} = \\{ b, c \\} \\cup \\{ a \\} = \\{ a, b, c \\}\n$$\n\n现在我们得到了提议的合并后 $\\text{LALR}(1)$ 状态中完整的归约项目及其关联的前瞻集：\n- 在前瞻符号 $\\{ a, b \\}$ 上按 $A \\rightarrow \\alpha$ 归约。\n- 在前瞻符号 $\\{ a, b, c \\}$ 上按 $B \\rightarrow \\beta$ 归约。\n\n接下来，我们必须找到冲突集 $C$。问题将 $C$ 定义为存在不同归约项目 $r_{i}$ 和 $r_{j}$，使得终结符 $t$ 同时存在于它们的前瞻集 $L_{i}$ 和 $L_{j}$ 中的所有 $t$ 的集合。在我们的例子中，不同的归约项目是 $r_{A}$ 和 $r_{B}$，它们在合并状态中的前瞻集是 $L_{A}$ 和 $L_{B}$。如果一个终结符 $t$ 同时在 $L_{A}$ 和 $L_{B}$ 中，它就会引起归约-归约冲突。因此，冲突集 $C$ 是这两个前瞻集的交集：\n$$\nC = L_{A} \\cap L_{B}\n$$\n使用计算出的集合 $L_{A}$ 和 $L_{B}$：\n$$\nC = \\{ a, b \\} \\cap \\{ a, b, c \\} = \\{ a, b \\}\n$$\n\n最后，合并阻塞冲突指数定义为冲突集的基数 $|C|$。\n$$\n|C| = |\\{ a, b \\}| = 2\n$$\n状态 $I_{1}$ 和 $I_{2}$ 的合并在终结符 $a$ 和 $b$ 上引入了归约-归约冲突。此类冲突终结符的数量为 $2$。", "answer": "$$\\boxed{2}$$", "id": "3648837"}]}