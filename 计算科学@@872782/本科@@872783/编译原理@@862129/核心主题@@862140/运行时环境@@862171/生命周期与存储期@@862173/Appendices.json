{"hands_on_practices": [{"introduction": "第一个练习将变量生命周期这个抽象概念，置于一个经典的编译器问题中：寄存器分配。通过将生命周期建模为时间线上的简单区间，我们可以将最小化寄存器使用的挑战转化为一个易于理解的图论问题。这个练习将帮助你可视化生命周期的冲突，并计算出一段代码的峰值资源需求 [@problem_id:3649943]。", "problem": "一个简单命令式语言的编译器通过对沿线性化程序点序列的变量生命周期进行推理，来执行存储位置（例如，物理寄存器）的分配。一个变量的活跃范围是指从其首次定义到其最后一次使用的连续程序点集合，包含起始点，不包含结束点，这可以建模为一维时间线上的一个半开区间。这种建模类似于项目管理中的甘特图，其中任务占据时间区间，当多个任务同时活动时会发生资源冲突。\n\n考虑一个线性代码片段，其程序点是全序的，并被视为时间线上的离散索引。变量集合 $\\{x_1, x_2, \\dots, x_{12}\\}$ 的活跃范围由以下半开区间 $\\left[s,e\\right)$ 指定，其中 $s$ 和 $e$ 是整数程序点，一个变量在满足 $s \\leq t  e$ 的任何程序点 $t$ 都被认为是活跃的：\n\n- $x_1: [0, 7)$\n- $x_2: [3, 12)$\n- $x_3: [5, 10)$\n- $x_4: [9, 15)$\n- $x_5: [11, 17)$\n- $x_6: [13, 20)$\n- $x_7: [14, 18)$\n- $x_8: [16, 22)$\n- $x_9: [1, 4)$\n- $x_{10}: [8, 9)$\n- $x_{11}: [2, 6)$\n- $x_{12}: [19, 24)$\n\n你需要从第一性原理出发进行推理：定义变量的活跃范围、由活跃范围重叠引起的干涉图，以及线性代码的区间图与这些干涉图之间的等价性。利用这些基础知识以及关于区间图和图着色的成熟理论，推导为什么最小化资源冲突可以归结为一个区间着色问题，其最小颜色数等于同时重叠区间的最大数量。\n\n最后，计算量 $P$，它被定义为在给定区间集合中，于任何程序点上同时活跃的变量的最大数量。请用一个不带单位的整数表达你的最终答案，不要四舍五入。", "solution": "该问题要求我们找到在任何给定时间点同时活跃的变量的最大数量，这个数量决定了寄存器分配所需的最小资源数。这个过程可以通过将变量的生命周期建模为区间，并将问题转化为寻找区间图中最大团（maximum clique）的大小来解决。\n\n**理论基础**\n\n1.  **活跃范围与区间**: 每个变量的生命周期（活跃范围）被建模为时间线上的一个半开区间 $[s, e)$。如果一个程序点 $t$ 满足 $s \\le t  e$，则该变量在点 $t$ 是活跃的。\n2.  **干涉与冲突图**: 如果两个变量的生命周期区间重叠（即它们的交集非空），它们就相互“干涉”，不能被分配到同一个寄存器。所有变量及其干涉关系构成一个**干涉图**，其中每个变量是一个顶点，每对干涉的变量之间有一条边。这种图被称为**区间图**。\n3.  **图着色**: 寄存器分配问题等价于对干涉图进行图着色。所需的最少寄存器数量等于图的**色数** $\\chi(G)$。\n4.  **完美图性质**: 区间图是**完美图**，其色数等于其**最大团规模** $\\omega(G)$。在我们的场景中，一个团是一组在某个时间点上同时活跃的变量。因此，$\\omega(G)$ 就等于在所有程序点中，同时活跃变量数量的最大值。\n\n**计算峰值活跃数 (P)**\n\n我们需要计算在任何时间点 $t$ 同时活跃的变量的最大数量。我们可以通过“扫描线”算法来实现，即检查在每个区间的起点和终点处，活跃变量集合的变化。\n\n给定的活跃范围：\n- $x_1: [0, 7)$, $x_2: [3, 12)$, $x_3: [5, 10)$, $x_4: [9, 15)$, $x_5: [11, 17)$, $x_6: [13, 20)$, $x_7: [14, 18)$, $x_8: [16, 22)$, $x_9: [1, 4)$, $x_{10}: [8, 9)$, $x_{11}: [2, 6)$, $x_{12}: [19, 24)$\n\n我们按时间顺序检查关键时间点定义的区间内的活跃变量数量：\n- $t \\in [0, 1)$: {$x_1$}。数量 = 1。\n- $t \\in [1, 2)$: {$x_1, x_9$}。数量 = 2。\n- $t \\in [2, 3)$: {$x_1, x_9, x_{11}$}。数量 = 3。\n- $t \\in [3, 4)$: {$x_1, x_2, x_9, x_{11}$}。数量 = 4。\n- $t \\in [4, 5)$: {$x_1, x_2, x_{11}$}。数量 = 3。\n- $t \\in [5, 6)$: {$x_1, x_2, x_3, x_{11}$}。数量 = 4。\n- $t \\in [6, 7)$: {$x_1, x_2, x_3$}。数量 = 3。\n- $t \\in [7, 8)$: {$x_2, x_3$}。数量 = 2。\n- $t \\in [8, 9)$: {$x_2, x_3, x_{10}$}。数量 = 3。\n- $t \\in [9, 10)$: {$x_2, x_3, x_4$}。数量 = 3。\n- $t \\in [10, 11)$: {$x_2, x_4$}。数量 = 2。\n- $t \\in [11, 12)$: {$x_2, x_4, x_5$}。数量 = 3。\n- $t \\in [12, 13)$: {$x_4, x_5$}。数量 = 2。\n- $t \\in [13, 14)$: {$x_4, x_5, x_6$}。数量 = 3。\n- $t \\in [14, 15)$: {$x_4, x_5, x_6, x_7$}。数量 = 4。\n- $t \\in [15, 16)$: {$x_5, x_6, x_7$}。数量 = 3。\n- $t \\in [16, 17)$: {$x_5, x_6, x_7, x_8$}。数量 = 4。\n- $t \\in [17, 18)$: {$x_6, x_7, x_8$}。数量 = 3。\n- $t \\in [18, 19)$: {$x_6, x_8$}。数量 = 2。\n- $t \\in [19, 20)$: {$x_6, x_8, x_{12}$}。数量 = 3。\n- $t \\in [20, 22)$: {$x_8, x_{12}$}。数量 = 2。\n- $t \\in [22, 24)$: {$x_{12}$}。数量 = 1。\n\n通过检查上述所有区间的活跃变量数量，我们发现最大值为4。\n因此，量 $P = 4$。这意味着至少需要4个寄存器（或存储位置）来分配这些变量而不会发生冲突。", "answer": "$$\\boxed{4}$$", "id": "3649943"}, {"introduction": "在上一个练习的基础上，我们现在来解决一个更复杂的内存分配场景：优化栈帧。在这里，并非所有变量都大小相同，这为每个生命周期区间增加了一个“权重”。这个问题要求你计算任意时间点的内存使用峰值，它直接决定了一个函数所需的最小栈空间大小 [@problem_id:3649968]。", "problem": "编译器后端必须为局部变量分配栈帧偏移量，以确保生命周期重叠的不同变量在内存中不会重叠。考虑一个单一函数，其局部变量的生命周期被建模为抽象指令时间轴上的半开时间区间，其大小以字节为单位给出。变量的生命周期是其从首次定义到最后一次使用的时间区间，其存储期是必须为该变量保留栈槽的时间段。生命周期在时间上重叠的两个变量不能占用同一个栈字节；生命周期不相交的变量可以重用相同的栈字节。每个变量在其生命周期内必须被分配一个固定的、连续的栈段。\n\n给定以下一组局部变量，每个变量都有一个大小和时间轴上的生命周期区间 $[a_i,b_i)$，其中 $a_i$ 和 $b_i$ 是整数且 $a_i  b_i$：\n- 变量 $v_1$：大小 $14$ 字节，生命周期 $[1,7)$。\n- 变量 $v_2$：大小 $20$ 字节，生命周期 $[3,11)$。\n- 变量 $v_3$：大小 $18$ 字节，生命周期 $[0,4)$。\n- 变量 $v_4$：大小 $12$ 字节，生命周期 $[6,9)$。\n- 变量 $v_5$：大小 $10$ 字节，生命周期 $[8,12)$。\n- 变量 $v_6$：大小 $26$ 字节，生命周期 $[2,5)$。\n\n假设栈从偏移量 $0$ 开始“向上”增长，分配的“高度” $H$ 是指在所有时间内，任何已分配字节所能达到的最小最大偏移量，从 $0$ 开始测量（因此分配区域为 $[0,H)$）。仅从生命周期、存储期以及生命周期重叠的变量在内存中不得重叠的核心定义出发，推导出为所有变量在其生命周期内分配固定偏移量所需的可证明的最小栈高度 $H$。将最终结果表示为一个整数字节数。无需四舍五入。以字节为单位表示最终答案。", "solution": "该问题要求找到容纳一组具有不同大小和生命周期的局部变量所需的最小栈帧大小（高度）。基本约束是，任何两个生命周期重叠的变量必须分配到不重叠的内存区域。由于每个变量在其整个生命周期内都被分配一个固定的偏移量，这意味着在任何给定的时间点 $t$，所有“活跃”的变量（即 $t$ 在其生命周期区间内）必须同时存在于内存中。\n\n在特定时间点 $t$ 所需的总内存量是当时所有活跃变量大小的总和。设 $s_i$ 为变量 $v_i$ 的大小，$L_i = [a_i, b_i)$ 为其生命周期。在时间 $t$ 并发使用的总内存大小由函数 $S(t)$ 给出：\n$$S(t) = \\sum_{v_i \\text{ s.t. } t \\in L_i} s_i$$\n    \n由于栈分配必须满足*所有*时间点的内存需求，因此栈的总高度 $H$ 必须至少与整个执行过程中观察到的峰值内存需求相等。因此，可证明的最小栈高度 $H$ 正是这个最大值：\n$$H = \\max_{t \\ge 0} S(t)$$\n    \n$S(t)$ 函数的值仅在变量生命周期的起点 ($a_i$) 和终点 ($b_i$) 发生变化。为了找到 $S(t)$ 的最大值，我们只需要在由这些事件点定义的每个基本区间上评估它。\n\n给定的变量是：\n- $v_1$：大小 $s_1 = 14$，生命周期 $L_1 = [1, 7)$\n- $v_2$：大小 $s_2 = 20$，生命周期 $L_2 = [3, 11)$\n- $v_3$：大小 $s_3 = 18$，生命周期 $L_3 = [0, 4)$\n- $v_4$：大小 $s_4 = 12$，生命周期 $L_4 = [6, 9)$\n- $v_5$：大小 $s_5 = 10$，生命周期 $L_5 = [8, 12)$\n- $v_6$：大小 $s_6 = 26$，生命周期 $L_6 = [2, 5)$\n\n我们按时间顺序计算每个区间的内存需求：\n- $t \\in [0, 1)$: 活跃变量 $\\{v_3\\}$。总大小 = $18$。\n- $t \\in [1, 2)$: 活跃变量 $\\{v_1, v_3\\}$。总大小 = $14 + 18 = 32$。\n- $t \\in [2, 3)$: 活跃变量 $\\{v_1, v_3, v_6\\}$。总大小 = $14 + 18 + 26 = 58$。\n- $t \\in [3, 4)$: 活跃变量 $\\{v_1, v_2, v_3, v_6\\}$。总大小 = $14 + 20 + 18 + 26 = 78$。\n- $t \\in [4, 5)$: 活跃变量 $\\{v_1, v_2, v_6\\}$。总大小 = $14 + 20 + 26 = 60$。\n- $t \\in [5, 6)$: 活跃变量 $\\{v_1, v_2\\}$。总大小 = $14 + 20 = 34$。\n- $t \\in [6, 7)$: 活跃变量 $\\{v_1, v_2, v_4\\}$。总大小 = $14 + 20 + 12 = 46$。\n- $t \\in [7, 8)$: 活跃变量 $\\{v_2, v_4\\}$。总大小 = $20 + 12 = 32$。\n- $t \\in [8, 9)$: 活跃变量 $\\{v_2, v_4, v_5\\}$。总大小 = $20 + 12 + 10 = 42$。\n- $t \\in [9, 11)$: 活跃变量 $\\{v_2, v_5\\}$。总大小 = $20 + 10 = 30$。\n- $t \\in [11, 12)$: 活跃变量 $\\{v_5\\}$。总大小 = $10$。\n\n计算出的内存需求峰值为：\n$$H = \\max\\{18, 32, 58, 78, 60, 34, 46, 32, 42, 30, 10\\} = 78$$\n    \n峰值内存需求发生在时间区间 $[3, 4)$。因此，所需的最小栈高度为78字节。", "answer": "$$\\boxed{78}$$", "id": "3649968"}, {"introduction": "我们的最后一个练习，从分析动态资源需求转向了静态安全验证领域，其灵感来源于像 Rust 这样的现代语言。你将扮演一个“借用检查器”，运用形式化规则来验证引用不会比它所指向的数据活得更久。这个练习展示了编译器如何利用生命周期约束，在程序运行前就防止整类的内存错误 [@problem_id:3649953]。", "problem": "考虑一个用于具有显式分配和释放功能的语言中简单单函数程序的第一性原理借用检查器。该函数执行一系列线性程序点 $t_0, t_1, \\dots, t_9$，期间发生以下事件，其中顺序 $t_0 \\prec t_1 \\prec \\dots \\prec t_9$ 表示严格全序的执行顺序：\n\n- 在 $t_1$：分配所有者变量 $a$。\n- 在 $t_2$：分配所有者变量 $b$。\n- 在 $t_3$：通过借用 $a$ 创建引用 $r_1$。\n- 在 $t_4$：使用 $r_1$ 一次。\n- 在 $t_5$：显式丢弃 $a$。\n- 在 $t_6$：通过借用 $b$ 创建引用 $r_2$。\n- 在 $t_6$：立即使用 $r_2$ 一次。\n- 在 $t_7$：显式丢弃 $b$。\n- 在 $t_8$：再次通过借用 $a$ 创建引用 $r_3$。\n- 在 $t_9$：从函数返回。\n\n我们将每个所有者或引用 $v$ 的生命周期建模为一个程序点闭区间 $[s_v, e_v]$，其中 $s_v \\preceq e_v$，并基于以下基本事实：\n\n- 所有者的存储期从其分配开始，到其显式丢弃结束，如果没有发生丢弃，则到函数退出时结束。因此，对于所有者 $a$ 和 $b$，有 $[s_{\\alpha_a}, e_{\\alpha_a}] = [t_1, t_5]$ 和 $[s_{\\alpha_b}, e_{\\alpha_b}] = [t_2, t_7]$。\n- 引用的存储期从其借用开始，结束时间不早于其最后一次使用；如果引用被创建但未使用，则其结束时间即为其创建时间。因此，$s_{\\beta_{r_1}} = t_3$ 且 $e_{\\beta_{r_1}} = t_4$，$s_{\\beta_{r_2}} = t_6$ 且 $e_{\\beta_{r_2}} = t_6$，$s_{\\beta_{r_3}} = t_8$ 且 $e_{\\beta_{r_3}} \\succeq t_8$。\n- “存活长于”关系通过生命周期的集合包含关系定义：一个所有者生命周期 $\\alpha$ 存活长于一个引用生命周期 $\\beta$，当且仅当 $[s_{\\alpha}, e_{\\alpha}] \\supseteq [s_{\\beta}, e_{\\beta}]$，这等价于不等式对 $s_{\\alpha} \\preceq s_{\\beta}$ 和 $e_{\\alpha} \\succeq e_{\\beta}$。对于指向所有者 $o$ 的每个引用，借用检查器强制执行此意义上的约束 $\\alpha_o \\ge \\beta_{\\text{ref}}$。\n\n在这些经过充分检验的规则下，检查器必须判断约束 $\\alpha_a \\ge \\beta_{r_1}$、$\\alpha_b \\ge \\beta_{r_2}$ 和 $\\alpha_a \\ge \\beta_{r_3}$ 是否联合可满足，如果可满足，则找出一个遵循上述存储期事实的最小生命周期解。\n\n哪个选项最能描述该约束系统的可满足性以及一个一致的生命周期分配？\n\nA. 如果检查器将 $e_{\\alpha_a}$ 扩展到 $t_9$，得到 $[s_{\\alpha_a}, e_{\\alpha_a}] = [t_1, t_9]$ 和 $[s_{\\beta_{r_3}}, e_{\\beta_{r_3}}] = [t_8, t_9]$，从而确保 $\\alpha_a \\ge \\beta_{r_3}$，则约束是可满足的。\n\nB. 使用最小结束点 $e_{\\beta_{r_1}} = t_4$、$e_{\\beta_{r_2}} = t_6$ 和 $e_{\\beta_{r_3}} = t_9$，约束是可满足的，因为每个 $e_{\\alpha}$ 都大于其对应的 $e_{\\beta}$。\n\nC. 约束是不可满足的，因为 $s_{\\beta_{r_3}} = t_8 \\succ e_{\\alpha_a} = t_5$，所以不存在满足 $\\alpha_a \\ge \\beta_{r_3}$ 的分配。\n\nD. 如果检查器将 $e_{\\beta_{r_3}}$ 截断到 $t_5$，使得对于 $r_3$ 而言 $e_{\\alpha_a} \\succeq e_{\\beta_{r_3}}$ 成立，则约束是可满足的。", "solution": "此问题要求我们扮演一个借用检查器，根据给定的程序事件和生命周期规则，判断三项借用约束是否能够同时满足。\n\n**生命周期定义**\n\n根据问题描述，我们首先确定每个所有者和引用的生命周期区间 $[s, e]$：\n-   所有者 $a$：在 $t_1$ 分配，在 $t_5$ 丢弃。生命周期 $\\alpha_a = [t_1, t_5]$。\n-   所有者 $b$：在 $t_2$ 分配，在 $t_7$ 丢弃。生命周期 $\\alpha_b = [t_2, t_7]$。\n-   引用 $r_1$ (借用 $a$)：在 $t_3$ 创建，在 $t_4$ 使用。生命周期 $\\beta_{r_1} = [t_3, t_4]$。\n-   引用 $r_2$ (借用 $b$)：在 $t_6$ 创建并使用。生命周期 $\\beta_{r_2} = [t_6, t_6]$。\n-   引用 $r_3$ (借用 $a$)：在 $t_8$ 创建，未使用。生命周期 $\\beta_{r_3}$ 从 $t_8$ 开始，即 $[t_8, e_{r_3}]$，其中 $e_{r_3} \\succeq t_8$。\n\n**约束验证**\n\n借用检查的核心规则是：引用的生命周期必须被其所有者的生命周期所包含（即“存活长于”关系）。形式上，对于借用所有者 $o$ 的引用 $ref$，必须满足 $\\alpha_o \\supseteq \\beta_{ref}$，这等价于 $s_{\\alpha_o} \\preceq s_{\\beta_{ref}}$ 且 $e_{\\alpha_o} \\succeq e_{\\beta_{ref}}$。\n\n我们逐一检查三个约束：\n\n1.  **约束 $\\alpha_a \\supseteq \\beta_{r_1}$**:\n    -   需要验证 $[t_1, t_5] \\supseteq [t_3, t_4]$。\n    -   这要求 $t_1 \\preceq t_3$ 且 $t_5 \\succeq t_4$。\n    -   根据程序点的严格顺序 $t_1 \\prec t_3 \\prec t_4 \\prec t_5$，这两个条件都成立。\n    -   结论：此约束**满足**。\n\n2.  **约束 $\\alpha_b \\supseteq \\beta_{r_2}$**:\n    -   需要验证 $[t_2, t_7] \\supseteq [t_6, t_6]$。\n    -   这要求 $t_2 \\preceq t_6$ 且 $t_7 \\succeq t_6$。\n    -   根据程序点的严格顺序 $t_2 \\prec t_6 \\prec t_7$，这两个条件都成立。\n    -   结论：此约束**满足**。\n\n3.  **约束 $\\alpha_a \\supseteq \\beta_{r_3}$**:\n    -   需要验证 $[t_1, t_5] \\supseteq [t_8, e_{r_3}]$。\n    -   这要求 $t_1 \\preceq t_8$ 且 $t_5 \\succeq e_{r_3}$。\n    -   第一个条件 $t_1 \\preceq t_8$ 成立。\n    -   第二个条件 $t_5 \\succeq e_{r_3}$ 必须与引用 $r_3$ 自身的生命周期规则 $e_{r_3} \\succeq t_8$ 结合。\n    -   这意味着必须有 $t_5 \\succeq e_{r_3} \\succeq t_8$，这蕴含了 $t_5 \\succeq t_8$。\n    -   然而，根据程序点的严格顺序，我们有 $t_5 \\prec t_8$。这是一个矛盾。\n    -   简而言之，引用 $r_3$ 在 $t_8$ 创建，是在其所有者 $a$ 于 $t_5$ 被销毁*之后*。这是一个典型的“用后借用”错误。\n    -   结论：此约束**不可满足**。\n\n由于第三个约束无法满足，整个约束系统是**不可满足的**。因此，该程序违反了借用检查规则。\n\n**选项分析**\n\n-   A：错误。检查器不能忽略显式的 `drop` 指令来延长所有者的生命周期。\n-   B：错误。断言约束是可满足的，但实际上不是。其理由也不成立。\n-   C：正确。它准确地指出了不可满足性的根本原因：引用 $r_3$ 的生命周期始于 $t_8$，而其所有者 $a$ 的生命周期已于 $t_5$ 结束，违反了“存活长于”的约束。\n-   D：错误。将 $r_3$ 的生命周期结束点设为 $t_5$ 将导致一个无效的区间 $[t_8, t_5]$，因为结束点早于起始点。\n\n因此，选项C是唯一正确的描述。", "answer": "$$\\boxed{C}$$", "id": "3649953"}]}