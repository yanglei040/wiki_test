{"hands_on_practices": [{"introduction": "理解不同参数传递机制最直接的方法，就是观察它们在处理“别名”（aliasing）这一核心问题时的不同行为。本练习 [@problem_id:3661405] 设计了一个巧妙的场景：将同一个变量作为多个参数传递给一个函数。通过追踪在传值调用（pass-by-value）、传引用调用（pass-by-reference）、传结果调用（pass-by-result）和复制传入/传出（copy-in/copy-out）这四种机制下变量的最终状态，你将亲手揭示它们在语义上的根本差异。", "problem": "考虑一个微小、确定性、过程调用的语言，它具有整型变量和以下语义。函数调用根据指定的参数传递机制将实际参数绑定到形式参数。语句按程序顺序执行。在赋值语句 $x := E$ 中，表达式 $E$ 使用其变量的当前值进行求值，然后将结果写入名为 $x$ 的位置。除了参数传递机制提供的绑定外，没有别名分析。四种参数传递机制定义如下，并应作为您推理的基础：\n\n- 按值传递 (Pass-by-value)：每个形式参数在调用入口处接收相应实际参数值的副本；形式参数是独立的局部变量；对形式参数的修改不影响调用者的变量。\n- 按引用传递 (Pass-by-reference)：每个形式参数成为相应实际参数存储位置的别名；如果为多个形式参数提供了相同的实际变量，则这些形式参数会别名到同一位置；所有的读取和写入都直接反映并修改调用者的变量。\n- 按结果传递 (Pass-by-result)：每个形式参数在调用入口处是一个独立的未初始化局部变量；在整个调用过程中，形式参数是独立的局部变量；在调用退出时，形式参数的最终值按形式参数从左到右的顺序复制回相应实际参数的存储位置。\n- 复制传入/复制传出 (Copy-in/copy-out) (按值结果传递 pass-by-value-result)：在调用入口处，每个形式参数接收其相应实际参数值的副本；在调用期间，形式参数是独立的局部变量；在调用退出时，形式参数的最终值按形式参数从左到右的顺序复制回相应实际参数的存储位置。\n\n假设表达式使用标准整数算术，并且上述的从左到右顺序是调用退出时执行复制回传的实际顺序。\n\n程序片段如下：\n- 调用者中的初始状态：变量 $a$ 的值为 $a = 5$。\n- 函数定义：$f(u,v)$ 的函数体由按顺序执行的三个语句组成：\n  $u := 3$;\n  $v := u + 4$;\n  $u := v + 5$。\n- 调用点：调用者执行 $f(a,a)$。\n\n令 $V_{\\mathrm{val}}$ 为按值传递调用后 $a$ 的最终值；令 $V_{\\mathrm{ref}}$ 为按引用传递调用后 $a$ 的最终值；令 $V_{\\mathrm{res}}$ 为使用从左到右复制回传的按结果传递调用后 $a$ 的最终值；令 $V_{\\mathrm{cio}}$ 为使用从左到右复制回传的复制传入/复制传出调用后 $a$ 的最终值。\n\n计算单个量\n$$S \\;=\\; V_{\\mathrm{val}} \\;+\\; V_{\\mathrm{ref}} \\;+\\; V_{\\mathrm{res}} \\;+\\; V_{\\mathrm{cio}}.$$\n提供 $S$ 的精确整数值。无需四舍五入。", "solution": "问题陈述已经过严格验证，并被认为是有效的。这是一个在计算机科学领域内，特别是在编程语言语义学和编译器原理方面，定义明确的问题。参数传递机制的定义清晰、自洽且一致。初始条件和程序片段的规定没有歧义。因此，可以构建一个合理的解决方案。\n\n问题要求我们追踪函数调用 $f(a,a)$ 在四种不同参数传递机制下的执行过程，并确定在每种情况下调用者作用域中变量 $a$ 的最终值。$a$ 的初始值给定为 $a=5$。函数 $f(u,v)$ 的函数体为：\n1. $u := 3$;\n2. $v := u + 4$;\n3. $u := v + 5$;\n\n让我们依次分析每种机制。\n\n### 按值传递 ($V_{\\mathrm{val}}$)\n根据定义，形式参数接收实际参数值的副本。形式参数是函数作用域内的局部变量，对它们的任何修改都不会影响调用者的变量。\n\n1.  **调用入口：** 创建局部变量 $u$ 和 $v$。实际参数 $a$ 的值 $5$ 被复制到 $u$ 和 $v$ 中。因此，函数内部的初始状态是 $u=5$ 和 $v=5$。调用者的变量 $a$ 在其位置上保持值 $5$，与 $u$ 和 $v$ 完全分离。\n2.  **执行 $f(u,v)$：**\n    - 语句1：$u := 3$。局部变量 $u$ 更新为 $3$。状态：$u=3$, $v=5$。调用者的 $a$ 不受影响，仍为 $5$。\n    - 语句2：$v := u + 4$。表达式 $u+4$ 求值为 $3+4=7$。此结果赋给局部变量 $v$。状态：$u=3, v=7$。调用者的 $a$ 不受影响。\n    - 语句3：$u := v + 5$。表达式 $v+5$ 求值为 $7+5=12$。此结果赋给局部变量 $u$。状态：$u=12, v=7$。调用者的 $a$ 不受影响。\n3.  **调用退出：** 函数返回。局部变量 $u$ 和 $v$ 被销毁。没有值被复制回调用者。\n4.  **最终值：** 调用者的变量 $a$ 在整个调用过程中从未被修改。其值仍为 $5$。\n因此，$V_{\\mathrm{val}} = 5$。\n\n### 按引用传递 ($V_{\\mathrm{ref}}$)\n根据定义，形式参数成为相应实际参数存储位置的别名。由于调用是 $f(a,a)$，形式参数 $u$ 和 $v$ 都成为同一存储位置（即变量 $a$ 的位置）的别名。对 $u$ 或 $v$ 的任何读取或写入都直接影响变量 $a$。\n\n1.  **调用入口：** $u$ 和 $v$ 都引用 $a$ 的位置。最初，该位置的值为 $5$。\n2.  **执行 $f(u,v)$：**\n    - 语句1：$u := 3$。此赋值修改了 $u$ 别名的位置，即 $a$ 的位置。$a$ 的值变为 $3$。\n    - 语句2：$v := u + 4$。该表达式读取 $u$ 的值并加 $4$。由于 $u$ 和 $v$ 都别名到 $a$，这等价于 $a := a + 4$。$a$ 的当前值为 $3$，所以表达式求值为 $3+4=7$。此结果被写入 $v$ 别名的位置，即 $a$ 的位置。$a$ 的值变为 $7$。\n    - 语句3：$u := v + 5$。这等价于 $a := a + 5$。$a$ 的当前值为 $7$，所以表达式求值为 $7+5=12$。此结果被写入 $u$ 别名的位置，即 $a$ 的位置。$a$ 的值变为 $12$。\n3.  **调用退出：** 别名 $u$ 和 $v$ 不再存在。\n4.  **最终值：** 调用者变量 $a$ 的最终值为 $12$。\n因此，$V_{\\mathrm{ref}} = 12$。\n\n### 按结果传递 ($V_{\\mathrm{res}}$)\n根据定义，形式参数是独立的、未初始化的局部变量。在调用退出时，它们的最终值按从左到右的顺序复制回实际参数的位置。\n\n1.  **调用入口：** 创建两个新的、未初始化的局部变量 $u$ 和 $v$。它们彼此独立，也与调用者的变量 $a$ 独立。调用者的 $a$ 仍为 $5$。\n2.  **执行 $f(u,v)$：**\n    - 语句1：$u := 3$。局部变量 $u$ 被赋值为 $3$。状态：$u=3$。\n    - 语句2：$v := u + 4$。表达式求值为 $3+4=7$。局部变量 $v$ 被赋值为 $7$。状态：$u=3, v=7$。\n    - 语句3：$u := v + 5$。表达式求值为 $7+5=12$。局部变量 $u$ 更新为 $12$。状态：$u=12, v=7$。\n3.  **调用退出（复制回传）：** 形式参数的最终值被复制回实际参数。实际参数是 $(a, a)$，形式参数是 $(u, v)$。复制回传按形式参数从左到右的顺序执行。\n    - 第一步（对于 $u$）：$u$ 的最终值 $12$ 被复制到第一个实际参数 $a$ 的位置。$a$ 的值变为 $12$。\n    - 第二步（对于 $v$）：$v$ 的最终值 $7$ 被复制到第二个实际参数 $a$ 的位置。$a$ 的值变为 $7$。之前的值 $12$ 被覆盖。\n4.  **最终值：** $a$ 的最终值是最后一次复制回传操作的结果，即 $7$。\n因此，$V_{\\mathrm{res}} = 7$。\n\n### 复制传入/复制传出 (按值结果传递) ($V_{\\mathrm{cio}}$)\n该机制结合了入口处的按值传递和出口处的按结果传递。\n\n1.  **调用入口（复制传入）：** 创建两个新的、独立的局部变量 $u$ 和 $v$。它们用相应实际参数的值进行初始化。\n    - $u$ 接收第一个实际参数 $a$ 的值，因此 $u=5$。\n    - $v$ 接收第二个实际参数 $a$ 的值，因此 $v=5$。\n    - 在函数执行期间，调用者的 $a$ 保持为 $5$。\n2.  **执行 $f(u,v)$：**\n    - 语句1：$u := 3$。局部变量 $u$ 更新为 $3$。状态：$u=3, v=5$。\n    - 语句2：$v := u + 4$。表达式求值为 $3+4=7$。局部变量 $v$ 更新为 $7$。状态：$u=3, v=7$。\n    - 语句3：$u := v + 5$。表达式求值为 $7+5=12$。局部变量 $u$ 更新为 $12$。状态：$u=12, v=7$。\n3.  **调用退出（复制传出）：** 形式参数的最终值按从左到右的顺序复制回实际参数的位置。此步骤与按结果传递的情况相同。\n    - 第一步（对于 $u$）：$u$ 的值 ($12$) 被复制到 $a$。$a$ 的值变为 $12$。\n    - 第二步（对于 $v$）：$v$ 的值 ($7$) 被复制到 $a$。$a$ 的值变为 $7$。\n4.  **最终值：** $a$ 的最终值为 $7$。\n因此，$V_{\\mathrm{cio}} = 7$。\n\n请注意，对于这个特定的函数体，由于形式参数的初始值在被读取之前立即被覆盖，按结果传递和复制传入/复制传出的行为是相同的。\n\n### 最终计算\n问题要求计算总和 $S = V_{\\mathrm{val}} + V_{\\mathrm{ref}} + V_{\\mathrm{res}} + V_{\\mathrm{cio}}$。\n代入计算出的值：\n$S = 5 + 12 + 7 + 7$\n$S = 17 + 14$\n$S = 31$\n$S$ 的最终整数值为 $31$。", "answer": "$$\n\\boxed{31}\n$$", "id": "3661405"}, {"introduction": "在掌握了基本变量的参数传递后，我们将挑战一个更贴近真实编程的场景：处理数组和切片。本练习 [@problem_id:3661407] 让你操作重叠的数组切片，这在处理大型数据集时是常见的情况。通过比较传引用调用和复制-传入/传出调用机制下的结果，你将更深刻地理解数据依赖和副作用如何通过参数传递影响程序状态，尤其是在循环操作中，这对于编写正确且可预测的代码至关重要。", "problem": "考虑一个简单的命令式语言，其数组和连续切片被建模为对单个底层内存数组的视图。一个基索引为 $s$、长度为 $L$ 的切片，将其元素访问 $x[i]$ 映射到底层内存位置 $M[s+i]$，其中 $i \\in \\{0,\\dots,L-1\\}$。索引是基于 $0$ 的，所有算术均为整数算术。\n\n设底层内存为长度为 $7$ 的数组 $M$，其初始状态为\n$$\nM = [7,1,4,2,6,3,5].\n$$\n定义过程 $h(a,b)$，该过程对两个等长（长度均为 $L$）的切片 $a$ 和 $b$ 操作如下。对于从 $0$ 到 $L-1$ 递增的 $i$，循环体执行单个赋值语句\n$$\na[i] := b[i] + b\\big((i+1) \\bmod L\\big),\n$$\n其中 $b((i+1) \\bmod L)$ 表示 $b$ 在索引 $(i+1) \\bmod L$ 处的元素（环绕索引）。\n\n一个调用者以重叠的切片作为实际参数来调用 $h$：\n- $a$ 是 $M$ 的切片，基地址为 $s_a = 1$，长度为 $L = 4$，因此 $a[i]$ 是 $M[1+i]$ 的别名，其中 $i \\in \\{0,1,2,3\\}$；\n- $b$ 是 $M$ 的切片，基地址为 $s_b = 2$，长度为 $L = 4$，因此 $b[i]$ 是 $M[2+i]$ 的别名，其中 $i \\in \\{0,1,2,3\\}$。\n\n运行三个独立的实验，每个实验都从上面给出的相同初始 $M$ 开始，唯一的不同在于对两个参数使用的参数传递机制：\n1. 对 $a$ 和 $b$ 均使用引用传递。\n2. 对 $a$ 和 $b$ 均使用值传递（调用后没有结果写回 $M$）。\n3. 对 $a$ 和 $b$ 均使用复制传入/复制传出（也称为值结果传递）：在调用入口，每个形参接收其实参切片的一个新副本（复制传入）；在返回时，每个形参的最终切片内容按形参列表从左到右的顺序（先 $a$，后 $b$）写回到相应的实参切片（复制传出）。\n\n令 $M_{\\mathrm{ref}}$、$M_{\\mathrm{val}}$ 和 $M_{\\mathrm{cio}}$ 分别表示实验 $1$、$2$ 和 $3$ 中调用结束后的最终底层内存数组。计算单个标量\n$$\nS \\;=\\; M_{\\mathrm{ref}}[3] \\;+\\; M_{\\mathrm{val}}[3] \\;+\\; M_{\\mathrm{cio}}[3].\n$$\n请以单个整数形式提供你的答案。无需四舍五入，无单位。", "solution": "该问题是有效的，因为它科学地基于程序设计语言语义的原理，特别是参数传递机制。问题提法清晰，所有必要的数据和定义都已提供，可得出一个唯一的、可计算的解。语言客观且无歧义。我们开始求解。\n\n长度为 $7$ 的底层内存数组 $M$ 的初始状态为：\n$$ M = [7, 1, 4, 2, 6, 3, 5] $$\n过程 $h(a,b)$ 以 $M$ 的两个重叠切片作为参数被调用，每个切片长度为 $L=4$：\n- 实参 $a$ 是基地址为 $s_a=1$ 的切片，对应于内存位置 $M[1], M[2], M[3], M[4]$ 上的视图。初始时，该切片包含 $[1, 4, 2, 6]$。\n- 实参 $b$ 是基地址为 $s_b=2$ 的切片，对应于内存位置 $M[2], M[3], M[4], M[5]$ 上的视图。初始时，该切片包含 $[4, 2, 6, 3]$。\n\n过程体为从 $0$ 到 $L-1=3$ 的 $i$ 执行一个循环：\n$$ a[i] := b[i] + b\\big((i+1) \\bmod L\\big) $$\n我们分析这三个独立的实验。\n\n### 实验 1：引用传递\n\n在引用传递中，形参 $a$ 和 $b$ 是实参切片的别名。对形参的任何修改都会直接且立即影响底层内存数组 $M$。赋值语句 $a[i] := \\dots$ 修改 $M[1+i]$，而从 $b[\\cdot]$ 读取数据则访问 $M[2+\\cdot]$ 中的当前值。\n\n让我们从 $M_0 = [7, 1, 4, 2, 6, 3, 5]$ 开始，逐步跟踪执行过程。\n\n- **对于 $i=0$**：\n  赋值语句为 $a[0] := b[0] + b[1]$。\n  这转换为 $M[1+0] := M[2+0] + M[2+1]$，即 $M[1] := M[2] + M[3]$。\n  使用 $M$ 中的当前值：$M[1] := 4 + 2 = 6$。\n  $M$ 的状态变为 $[7, 6, 4, 2, 6, 3, 5]$。\n\n- **对于 $i=1$**：\n  赋值语句为 $a[1] := b[1] + b[2]$。\n  这转换为 $M[1+1] := M[2+1] + M[2+2]$，即 $M[2] := M[3] + M[4]$。\n  使用 $M$ 中的当前值：$M[2] := 2 + 6 = 8$。\n  $M$ 的状态变为 $[7, 6, 8, 2, 6, 3, 5]$。\n\n- **对于 $i=2$**：\n  赋值语句为 $a[2] := b[2] + b[3]$。\n  这转换为 $M[1+2] := M[2+2] + M[2+3]$，即 $M[3] := M[4] + M[5]$。\n  使用 $M$ 中的当前值：$M[3] := 6 + 3 = 9$。\n  $M$ 的状态变为 $[7, 6, 8, 9, 6, 3, 5]$。\n\n- **对于 $i=3$**：\n  赋值语句为 $a[3] := b[3] + b((3+1) \\bmod 4)$，可简化为 $a[3] := b[3] + b[0]$。\n  这转换为 $M[1+3] := M[2+3] + M[2+0]$，即 $M[4] := M[5] + M[2]$。\n  关键在于，我们必须使用 $M[2]$ 的**更新后**的值，即 $8$。\n  使用 $M$ 中的当前值：$M[4] := 3 + 8 = 11$。\n  $M$ 的状态变为 $[7, 6, 8, 9, 11, 3, 5]$。\n\n此实验的最终内存数组为 $M_{\\mathrm{ref}} = [7, 6, 8, 9, 11, 3, 5]$。\n因此，$M_{\\mathrm{ref}}[3] = 9$。\n\n### 实验 2：值传递\n\n在值传递中，过程接收实参的副本。过程 $h$ 对这些本地副本进行操作。问题指明，对于这种机制，没有结果会写回 $M$。\n- 在入口处，创建切片 $a$ 的一个本地副本：$a_{\\mathrm{local}} = [1, 4, 2, 6]$。\n- 创建切片 $b$ 的一个本地副本：$b_{\\mathrm{local}} = [4, 2, 6, 3]$。\n过程操作这些本地副本，但由于结果不会被复制回去，原始数组 $M$ 保持不变。\n最终的内存数组与初始数组相同：$M_{\\mathrm{val}} = [7, 1, 4, 2, 6, 3, 5]$。\n因此，$M_{\\mathrm{val}}[3] = 2$。\n\n### 实验 3：复制传入/复制传出（值结果传递）\n\n该机制涉及三个阶段：复制传入、执行和复制传出。\n\n- **复制传入**：在调用入口，制作实参切片的本地副本。\n  - $a_{\\mathrm{local}}$ 是从 $M[1]$ 开始的切片的一个副本：$a_{\\mathrm{local}} = [1, 4, 2, 6]$。\n  - $b_{\\mathrm{local}}$ 是从 $M[2]$ 开始的切片的一个副本：$b_{\\mathrm{local}} = [4, 2, 6, 3]$。\n\n- **执行**：过程使用这些本地副本运行。循环根据从 $b_{\\mathrm{local}}$ 读取的值来修改 $a_{\\mathrm{local}}$。由于 $b_{\\mathrm{local}}$ 从未被写入，它在整个执行过程中保持其初始复制的值。\n  - 让我们跟踪对 $a_{\\mathrm{local}}$ 的更新：\n    - **$i=0$**：$a_{\\mathrm{local}}[0] := b_{\\mathrm{local}}[0] + b_{\\mathrm{local}}[1] = 4 + 2 = 6$。\n    - **$i=1$**：$a_{\\mathrm{local}}[1] := b_{\\mathrm{local}}[1] + b_{\\mathrm{local}}[2] = 2 + 6 = 8$。\n    - **$i=2$**：$a_{\\mathrm{local}}[2] := b_{\\mathrm{local}}[2] + b_{\\mathrm{local}}[3] = 6 + 3 = 9$。\n    - **$i=3$**：$a_{\\mathrm{local}}[3] := b_{\\mathrm{local}}[3] + b_{\\mathrm{local}}[0] = 3 + 4 = 7$。\n  - 在过程结束时，本地切片的最终状态是：\n    - $a_{\\mathrm{local, final}} = [6, 8, 9, 7]$。\n    - $b_{\\mathrm{local, final}} = [4, 2, 6, 3]$（未改变）。\n\n- **复制传出**：在返回时，最终本地切片的内容被复制回原始实参的内存位置。问题指明复制传出的顺序是从左到右：先 $a$，后 $b$。\n  - 我们从初始内存数组开始：$M = [7, 1, 4, 2, 6, 3, 5]$。\n  - **传出 $a$**：$a_{\\mathrm{local, final}}$ 的内容被写到 $a$ 的切片位置，即 $M[1], M[2], M[3], M[4]$。\n    - $M[1] := 6$, $M[2] := 8$, $M[3] := 9$, $M[4] := 7$。\n    - 此步骤后，$M$ 变为 $[7, 6, 8, 9, 7, 3, 5]$。\n  - **传出 $b$**：$b_{\\mathrm{local, final}}$ 的内容被写到 $b$ 的切片位置，即 $M[2], M[3], M[4], M[5]$。这发生在 $a$ 的复制传出*之后*。\n    - $M[2] := 4$（覆盖了 $a$ 复制传出时的 $8$）。\n    - $M[3] := 2$（覆盖了 $a$ 复制传出时的 $9$）。\n    - $M[4] := 6$（覆盖了 $a$ 复制传出时的 $7$）。\n    - $M[5] := 3$（覆盖了原来的 $3$）。\n  - $M$ 的最终状态是 $[7, 6, 4, 2, 6, 3, 5]$。\n\n此实验的最终内存数组为 $M_{\\mathrm{cio}} = [7, 6, 4, 2, 6, 3, 5]$。\n因此，$M_{\\mathrm{cio}}[3] = 2$。\n\n### 最终计算\n\n我们需要计算标量 $S = M_{\\mathrm{ref}}[3] + M_{\\mathrm{val}}[3] + M_{\\mathrm{cio}}[3]$。\n代入我们求得的值：\n- $M_{\\mathrm{ref}}[3] = 9$\n- $M_{\\mathrm{val}}[3] = 2$\n- $M_{\\mathrm{cio}}[3] = 2$\n\n$$ S = 9 + 2 + 2 = 13 $$\n最终答案是 $13$。", "answer": "$$\n\\boxed{13}\n$$", "id": "3661407"}, {"introduction": "参数传递不仅关乎程序的语义正确性，也直接影响其运行效率，这是从理论走向实践的关键一步。本练习 [@problem_id:3661409] 将带你从编译器设计者的视角，审视参数传递的底层实现和性能优化问题。你将为一个拥有有限寄存器的目标机器设计参数传递策略，通过优化参数顺序来最小化因栈操作产生的内存访问开销，从而体会理论概念在真实系统中的工程权衡。", "problem": "一个用于内部领域特定语言的编译器后端，其目标机器使用固定数量的通用参数寄存器来传递按值传递的参数，超出部分则溢出到栈上。该接口是内部的，编译器被允许在调用点和被调用者处一致地重排参数列表，而不会改变程序语义。每个参数都是一个单独的机器字。目标机器提供恰好 $R$ 个单字长的参数寄存器；任何额外的参数都通过栈来传递。假设每次调用的动态内存流量遵循以下成本模型：\n- 每个通过栈传递的参数会引起调用者执行恰好 $1$ 次动态字存储。\n- 如果被调用者在调用执行期间使用了这样一个参数 $u_i$ 次，则每次使用都会引起被调用者从栈中执行一次动态字加载（寄存器压力阻止了跨次使用的重用）。因此，其每次调用的动态栈流量为 $1 + u_i$ 个字。\n- 通过参数寄存器传递的参数引起的动态栈流量为零。\n在重排后的列表中，参数从左到右分配给寄存器，直到 $R$ 个寄存器用尽；所有剩余的参数都溢出到栈上。\n\n仅从按值传递和调用约定的核心定义以及所述的机器模型出发，完成以下任务：\n1) 对于任意固定的参数顺序，推导溢出参数的数量以及每次调用的总动态栈字流量的表达式，该表达式应是关于 $N$、$R$ 以及每个参数的动态使用次数的多重集 $\\{u_i\\}_{i=1}^{N}$ 的函数。然后，使用第一性原理进行推理，在可用寄存器数量的约束下最小化此成本，推导出通过重排参数可实现的最小可能动态栈流量。描述一种在该模型下能达到此最小值的确定性启发式排序规则。\n2) 考虑一个具体的调用，有 $N = 10$ 个按值传递的参数和 $R = 3$ 个参数寄存器。在原始的源程序顺序中，动态使用次数为\n$\\{u_1,u_2,\\dots,u_{10}\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$。\n计算在上述模型下，通过重排参数可实现的每次调用的最小总动态栈字流量。只需报告这个最小数值作为你的最终答案。无需四舍五入。", "solution": "问题陈述经审阅后被认为是有效的。这是一个适定 (well-posed) 的优化问题，基于编译器设计和计算机体系结构的标准（尽管是简化的）概念，特别是调用约定和寄存器分配。所有必要的数据和定义都已提供，没有内部矛盾、歧义或违反科学原理之处。该问题可以被严格地形式化和解决。\n\n令 $N$ 为按值传递参数的总数，$R$ 为可用的通用参数寄存器数量，$\\{u_i\\}_{i=1}^{N}$ 为这些参数的动态使用次数的多重集。\n\n**第1部分：一般性推导**\n\n问题指定了一种调用约定，其中列表中的前 $R$ 个参数通过寄存器传递，任何后续参数都通过栈传递。编译器可以自由地重排参数。\n\n首先，我们确定给定顺序下溢出参数的数量。如果参数总数 $N$ 小于或等于寄存器数量 $R$（即 $N \\le R$），所有参数都可以通过寄存器传递，没有参数溢出。如果 $N  R$，前 $R$ 个参数通过寄存器传递，剩下的 $N - R$ 个参数则溢出到栈上。因此，对于任意排序，溢出参数的数量为 $\\max(0, N - R)$。\n\n接下来，我们推导每次调用的总动态栈字流量的表达式。根据成本模型：\n- 通过寄存器传递的参数产生 $0$ 栈流量。\n- 通过栈传递的参数 $i$ 会产生调用者 $1$ 次字存储和被调用者 $u_i$ 次字加载的成本，总共为 $1 + u_i$ 个动态栈字。\n\n设所选列表顺序中的参数为 $\\{p_1, p_2, \\dots, p_N\\}$，其对应的使用次数为 $\\{v_1, v_2, \\dots, v_N\\}$。注意 $\\{v_i\\}$ 是原始 $\\{u_i\\}$ 的一个排列。对于此顺序，参数 $p_{R+1}, \\dots, p_N$ 会溢出。总动态栈流量 $T$ 是这些溢出参数的成本之和。\n如果 $N \\le R$，$T = 0$。\n如果 $N  R$，总流量为：\n$$ T = \\sum_{k=R+1}^{N} (1 + v_k) $$\n这个表达式可以展开为：\n$$ T = \\sum_{k=R+1}^{N} 1 + \\sum_{k=R+1}^{N} v_k = (N-R) + \\sum_{k=R+1}^{N} v_k $$\n项 $(N-R)$ 代表调用者存储每个溢出参数的固定成本。这一项是常数，不依赖于参数顺序。因此，要最小化总流量 $T$，我们必须最小化第二项 $\\sum_{k=R+1}^{N} v_k$，即溢出到栈上的参数的使用次数之和。\n\n为了实现这种最小化，我们应该选择使用次数最低的参数进行溢出。这在逻辑上等同于选择使用次数最高的参数放入 $R$ 个可用寄存器中，因为这样可以避免产生 $(1+u_i)$ 形式的最大成本。\n\n这导出了实现最小栈流量的确定性排序规则：\n1. 按参数的动态使用次数 $u_i$ 的**降序**对其进行排序。\n2. 编译器应按此排序顺序安排参数列表。\n\n设原始的使用次数多重集为 $\\{u_i\\}_{i=1}^{N}$。我们将这些次数按非递减（升序）顺序排序，得到有序集合 $\\{u_{(1)}, u_{(2)}, \\dots, u_{(N)}\\}$，其中 $u_{(1)} \\le u_{(2)} \\le \\dots \\le u_{(N)}$。\n\n最优策略是将使用次数最高的 $R$ 个参数 $\\{u_{(N-R+1)}, \\dots, u_{(N)}\\}$ 分配给寄存器。剩下的具有最低使用次数的 $N-R$ 个参数 $\\{u_{(1)}, \\dots, u_{(N-R)}\\}$ 则溢出到栈上。\n\n最小可能动态栈流量 $T_{min}$ 是这 $N-R$ 个溢出参数的成本之和。\n如果 $N \\le R$，$T_{min} = 0$。\n如果 $N  R$，最小流量为：\n$$ T_{min} = \\sum_{i=1}^{N-R} (1 + u_{(i)}) = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n\n这个策略可被证明是最优的。假设存在一个最优分配，其中一个使用次数为 $u_a$ 的参数 $p_a$ 在寄存器中，而另一个使用次数为 $u_b$ 的参数 $p_b$ 在栈上，且满足 $u_a  u_b$。总成本包含项 $(1+u_b)$。如果我们交换它们，将 $p_b$ 放入寄存器，将 $p_a$ 放到栈上，新的成本将包含项 $(1+u_a)$。由于 $u_a  u_b$，因此 $(1+u_a)  (1+u_b)$，总成本减少了。这与最初的最优分配假设相矛盾。因此，在任何最优分配中，寄存器中的每个参数的使用次数必须大于或等于栈上任何参数的使用次数。所规定的排序规则满足此条件。\n\n**第2部分：具体计算**\n\n我们给定一个具体的调用：\n- 参数总数：$N = 10$\n- 参数寄存器数量：$R = 3$\n- 动态使用次数的多重集：$\\{u_i\\} = \\{5, 1, 8, 0, 3, 1, 13, 2, 0, 1\\}$\n\n首先，我们确定溢出参数的数量。由于 $N  R$，将有 $N - R = 10 - 3 = 7$ 个参数溢出到栈上。剩下的 $R=3$ 个参数将通过寄存器传递。\n\n为了最小化总动态栈流量，我们必须将使用次数最低的 $7$ 个参数溢出。我们首先将使用次数的多重集按非递减顺序排序：\n$$ \\{0, 0, 1, 1, 1, 2, 3, 5, 8, 13\\} $$\n使用次数最高的 $R=3$ 个参数，即 $\\{13, 8, 5\\}$，被放入寄存器。它们对栈流量的贡献为 $0$。\n\n使用次数最低的 $N-R = 7$ 个参数，即 $\\{0, 0, 1, 1, 1, 2, 3\\}$，被溢出到栈上。\n\n最小总动态栈流量 $T_{min}$ 是这 $7$ 个溢出参数的成本之和。我们使用第1部分推导出的公式：\n$$ T_{min} = \\sum_{i=1}^{7} (1 + u_{(i)}) $$\n其中 $\\{u_{(i)}\\}_{i=1}^7$ 是 $7$ 个最低的使用次数。\n$$ T_{min} = (1 + 0) + (1 + 0) + (1 + 1) + (1 + 1) + (1 + 1) + (1 + 2) + (1 + 3) $$\n$$ T_{min} = 1 + 1 + 2 + 2 + 2 + 3 + 4 $$\n$$ T_{min} = 15 $$\n或者，使用另一种形式的方程：\n$$ T_{min} = (N-R) + \\sum_{i=1}^{N-R} u_{(i)} $$\n$$ T_{min} = 7 + (0 + 0 + 1 + 1 + 1 + 2 + 3) $$\n$$ T_{min} = 7 + 8 $$\n$$ T_{min} = 15 $$\n每次调用的最小总动态栈字流量为 $15$。", "answer": "$$\\boxed{15}$$", "id": "3661409"}]}