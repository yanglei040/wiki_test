{"hands_on_practices": [{"introduction": "本练习将词法作用域的理论概念与内存布局的具体实现联系起来。我们将通过从基本原则出发，计算精确的内存偏移量，来探索编译器如何利用“display”机制高效地访问外层作用域中的变量。这项实践对于理解抽象的作用域规则如何转化为机器层面的地址至关重要。[@problem_id:3620063]", "problem": "您正在为一种具有词法作用域和 display 机制的块结构语言设计代码生成。该实现使用一个 display，以便访问在词法深度 $l$ 处声明的非局部变量。访问方式是首先从 display 条目 $\\text{display}[l]$ 加载帧基地址，然后加上一个相对寻址偏移量 $\\delta$ 以形成有效地址。\n\n假设有以下机器和运行时约定：\n- 机器字长为 $w$ 字节，其中 $w = 8$。\n- display 条目 $\\text{display}[l]$ 指向词法深度为 $l$ 的当前活动过程的活动记录的基地址。\n- 对于一个词法深度为 $l$ 的过程，其活动记录以一个控制前缀开始，该前缀的大小（以字为单位）等于 $2 + (l+1)$。这些字包括一个保存的返回地址（$1$ 个字）、一个动态链接或调用者状态字（$1$ 个字），以及一个用于保存在进入时将被覆盖的 display 条目的区域（$l+1$ 个字）。局部变量区紧跟在该控制前缀之后。\n- 每个标量局部变量恰好占用 $1$ 个字，并被分配一个从零开始的槽索引 $s \\in \\{0,1,2,\\dots\\}$，该索引相对于其活动记录内局部变量区的起始位置。\n\n一个当前正在执行的、词法深度为 $4$ 的过程 $Q$ 需要访问以下非局部标量变量，每个变量都由其声明时的词法深度 $l$ 和在其自身活动记录的局部变量区内的槽索引 $s$ 来标识：\n- 变量 $a$：$l=0$, $s=5$。\n- 变量 $b$：$l=1$, $s=3$。\n- 变量 $c$：$l=2$, $s=9$。\n- 变量 $d$：$l=0$, $s=2$。\n- 变量 $e$：$l=3$, $s=1$。\n\n您的任务：\n1. 根据 display 机制的基本原理和给定的活动记录布局，推导出一个通用表达式，用于计算在词法深度 $l$ 声明、槽索引为 $s$ 的变量的相对寻址偏移量 $\\delta$（以字节为单位），该表达式应以 $w$、$l$ 和 $s$ 表示。\n2. 使用推导出的表达式和给定的 $w$，计算 $a$、$b$、$c$、$d$ 和 $e$ 各自的 $\\delta$。\n3. 令 $S$ 为这五个偏移量的总和（即 $S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e$）。计算 $S$ 并将您的最终答案以字节为单位表示为一个精确整数。无需四舍五入。", "solution": "该问题要求推导一个通用公式，用于计算在带有 display 机制的块结构语言中访问非局部变量时使用的相对寻址偏移量 $\\delta$，然后使用此公式计算一组特定变量的此类偏移量之和。该问题定义明确，并包含了所有必要信息。\n\n首先，我们将推导在词法深度 $l$ 声明、槽索引为 $s$ 的变量的相对寻址偏移量 $\\delta$（以字节为单位）的通用表达式。访问方法是将偏移量 $\\delta$ 加到活动记录的基地址上，该基地址由 display 条目 $\\text{display}[l]$ 提供。因此，$\\delta$ 表示变量的存储位置相对于其声明所在的活动记录起始点的偏移量。\n\n一个词法深度为 $l$ 的过程的活动记录按顺序由两部分组成：一个控制前缀和一个局部变量区。总偏移量 $\\delta$ 是控制前缀的大小与变量在局部变量区内偏移量之和。\n\n对于词法深度为 $l$ 的过程，其控制前缀的大小被指定为 $2 + (l+1)$ 个字。我们将其大小用字节表示。给定机器字长 $w$，控制前缀的大小 $P_{size}$ 为：\n$$ P_{size} = (2 + (l+1)) \\times w = (l+3)w $$\n\n局部变量区紧跟在控制前缀之后。一个标量局部变量被分配一个从零开始的槽索引 $s$，该索引是相对于局部变量区的起始位置。每个这样的变量恰好占用 $1$ 个字。因此，一个槽索引为 $s$ 的变量相对于局部变量区起点的偏移量 $L_{offset}$ 为：\n$$ L_{offset} = s \\times w $$\n\n从活动记录起始点算起的总相对寻址偏移量 $\\delta$ 是前缀大小和局部偏移量之和：\n$$ \\delta(l, s) = P_{size} + L_{offset} = (l+3)w + sw $$\n提取公因子 $w$，我们得到 $\\delta$ 的通用表达式：\n$$ \\delta(l, s) = (l + s + 3)w $$\n该表达式以变量声明的词法深度 $l$、其槽索引 $s$ 以及机器字长 $w$ 来表示。\n\n接下来，我们使用这个表达式为每个指定变量计算 $\\delta$。题目给出的字长为 $w = 8$ 字节。将这个值代入我们推导出的公式中，得到：\n$$ \\delta(l, s) = (l + s + 3) \\times 8 $$\n\n我们现在计算每个变量的偏移量：\n- 变量 $a$：$l=0$, $s=5$。\n  $$ \\delta_a = (0 + 5 + 3) \\times 8 = 8 \\times 8 = 64 \\text{ bytes} $$\n- 变量 $b$：$l=1$, $s=3$。\n  $$ \\delta_b = (1 + 3 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ bytes} $$\n- 变量 $c$：$l=2$, $s=9$。\n  $$ \\delta_c = (2 + 9 + 3) \\times 8 = 14 \\times 8 = 112 \\text{ bytes} $$\n- 变量 $d$：$l=0$, $s=2$。\n  $$ \\delta_d = (0 + 2 + 3) \\times 8 = 5 \\times 8 = 40 \\text{ bytes} $$\n- 变量 $e$：$l=3$, $s=1$。\n  $$ \\delta_e = (3 + 1 + 3) \\times 8 = 7 \\times 8 = 56 \\text{ bytes} $$\n\n最后，我们计算这五个偏移量的总和 $S$：\n$$ S = \\delta_a + \\delta_b + \\delta_c + \\delta_d + \\delta_e $$\n代入计算出的值：\n$$ S = 64 + 56 + 112 + 40 + 56 $$\n进行求和：\n$$ S = 328 \\text{ bytes} $$\n这些偏移量的总和是 $328$ 字节。", "answer": "$$\\boxed{328}$$", "id": "3620063"}, {"introduction": "从静态内存布局转向函数的动态行为，本练习将处理一个经典且经常被误解的概念：闭包如何捕获循环变量。通过比较按引用捕获和按值捕获的语义，您将学会准确预测程序输出，并理解在支持头等函数的语言中常见错误的根源。这个动手思维实验是掌握词法环境微妙之处的关键。[@problem_id:3620080]", "problem": "给定一种小型的、具有词法作用域和一等函数特性的语言，该语言有两种可选的闭包捕获语义。该语言采用值传递，并且由 let 绑定的名称表示可变的位置。在标准的 for 循环中，循环变量名表示一个在每次迭代中都会被更新的单一可变位置。运行时实现了真正的闭包，因此闭包捕获的任何位置在定义函数返回后仍然存在。\n\n考虑下面的函数，它构造并返回一个 thunk (无参闭包) 列表，这些 thunk 读取一个非局部名称；然后是一个应用点，在循环和一个中间赋值之后调用返回的闭包：\n\nfunction makeF(n):\n    res = []\n    for i = 1 to n:\n        res.push( fun() { return i } )\n    i = 99\n    return res\n\nlet fs = makeF(3)\nprint fs[0](), fs[1](), fs[2]()\n\n假设有以下精确的语义和约束：\n- 词法作用域：每个 thunk 中的自由变量 $i$ 指的是创建该 thunk 的 makeF 活动记录中 $i$ 的绑定（而不是任何调用者的环境）。\n- 循环绑定模型：名称 $i$ 在循环入口处被绑定到一个单一的可变位置，每次迭代都将一个新的数值赋给同一位置；循环后的语句 i = 99 也会写入该位置。\n- 每个 thunk 中自由变量 $i$ 的两种闭包捕获变体：\n  1) 引用捕获：闭包记录一个指向定义环境中由 $i$ 表示的位置的引用；求值 thunk 会读取该位置当时的内容。\n  2) 值捕获：闭包在 thunk 创建时记录 $i$ 当前数值的一份副本；该 thunk 的求值结果就是那个被复制的值。\n- 运行时对捕获的位置执行逃逸安全分配，这样当闭包的生命周期超过其定义活动记录时，不会出现悬垂引用。\n\n现在也考虑以下重构，它在每次迭代中引入了一个新的内部绑定：\n\nfunction makeF_refactored(n):\n    res = []\n    for i = 1 to n:\n        let j = i\n        res.push( fun() { return j } )\n    i = 99\n    return res\n\nlet gs = makeF_refactored(3)\nprint gs[0](), gs[1](), gs[2]()\n\n问题：哪个选项正确地描述了这两个程序在两种捕获语义下的可观察输出，并解释了原因？选择唯一最佳答案。\n\n选项：\n- A) 在引用捕获下，makeF 打印 $\\left(3, 3, 3\\right)$；在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获读取循环计数器的最终值，而赋值语句 $i = 99$ 发生在闭包创建之后，不会影响它们。\n- B) 在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$；在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获共享了 $i$ 的单一位置（最后更新为 $99$），值捕获在 thunk 创建时复制了 $1$、$2$ 和 $3$，而引入 $j$ 为每次迭代创建了一个新的位置，每个 thunk 都引用该位置。\n- C) 在引用捕获下，makeF 打印 $\\left(1, 2, 3\\right)$；在值捕获下，makeF 打印 $\\left(1, 1, 1\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。原因：引用捕获在每次迭代创建闭包时冻结了值，而值捕获在调用时根据第一次迭代计算值。\n- D) 在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$；在值捕获下，makeF 打印 $\\left(3, 3, 3\\right)$。在引用捕获下，makeF_refactored 打印 $\\left(99, 99, 99\\right)$。原因：值捕获在循环结束时记录循环的最终值，而引入 $j$ 不会改变所引用的位置。\n- E) 在引用捕获下，makeF 会导致悬垂引用，因为 $i$ 是一个局部变量；在值捕获下，makeF 和 makeF_refactored 都打印 $\\left(1, 2, 3\\right)$。原因：循环变量 $i$ 位于栈上，除非被复制，否则无法被安全捕获。", "solution": "首先将验证问题陈述的科学合理性、完整性和客观性。\n\n**步骤 1：提取已知条件**\n\n问题提供了以下定义、约束和代码片段：\n\n-   **语言语义**：\n    -   词法作用域，一等函数。\n    -   值传递求值策略。\n    -   `let`-绑定的名称表示可变位置。\n    -   闭包是真正的闭包并且会持久存在。运行时执行逃逸安全分配，防止悬垂引用。\n\n-   **循环语义**：\n    -   在 `for` 循环中，循环变量名（例如，$i$）表示一个在每次迭代中都会被更新的单一可变位置。\n\n-   **闭包捕获变体**：\n    -   **引用捕获**：闭包记录一个指向其定义环境中自由变量内存位置的引用。当闭包被求值时，它会在调用时从该位置读取值。\n    -   **值捕获**：闭包在创建时记录自由变量数值的一份副本。\n\n-   **第一个程序 (`makeF`)**：\n    ```\n    function makeF(n):\n        res = []\n        for i = 1 to n:\n            res.push( fun() { return i } )\n        i = 99\n        return res\n    ```\n    执行方式：`let fs = makeF(3)`, `print fs[0](), fs[1](), fs[2]()`。\n\n-   **第二个程序 (`makeF_refactored`)**：\n    ```\n    function makeF_refactored(n):\n        res = []\n        for i = 1 to n:\n            let j = i\n            res.push( fun() { return j } )\n        i = 99\n        return res\n    ```\n    执行方式：`let gs = makeF_refactored(3)`, `print gs[0](), gs[1](), gs[2]()`。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n根据验证标准对问题陈述进行评估：\n\n-   **科学依据**：该问题牢固地植根于编程语言理论和编译器设计的原则。词法作用域、闭包、引用捕获与值捕获、可变状态等概念在计算机科学中是基础且定义明确的。该场景是用于教授这些概念的经典示例，并代表了现实世界语言（例如，JavaScript 中循环里的 `var` 与 `let`）中的行为。\n-   **问题定义明确**：该问题被精确地规定。它定义了循环变量（单一可变位置）、`let` 绑定（新的可变位置）和两种捕获机制的语义。根据这些规则，两个程序的行为都可以被唯一且逻辑地确定。\n-   **客观性**：语言是形式化且无歧义的。所有术语在计算机科学领域内都有标准含义。\n-   **完整性与一致性**：问题是自包含的。它提供了所有必要的信息，包括关键细节，即循环变量 `$i$` 在整个循环执行期间占据单一位置，以及 `let` 创建一个新位置的事实。它还通过指定“逃逸安全分配”明确排除了悬垂指针问题的可能性。没有矛盾之处。\n\n**步骤 3：结论与行动**\n\n问题陈述是**有效的**。这是一个在编程语言语义学中定义明确、有科学依据的问题。现在可以进行严谨的解答推导。\n\n**解答推导**\n\n我们将根据指定的语义分析两个函数的执行过程。两种情况下的调用都是 `$n = 3$`。\n\n**情况 1：`makeF` 使用引用捕获**\n\n1.  函数 `$makeF$` 以 `$n=3$` 被调用。创建一个空列表 `$res$`。\n2.  `for` 循环开始。为循环变量 `$i$` 分配一个单一的可变位置。我们将其表示为 `$L_i$`。\n3.  **迭代 1**：`$i$` 被设为 `$1$`。`$L_i$` 中的值为 `$1$`。一个 thunk `$T_0 = fun() \\{ return\\ i \\}` 被创建。在引用捕获下，`$T_0$` 捕获了 `$i$` 的位置的引用，即 `$L_i$`。\n4.  **迭代 2**：`$i$` 被设为 `$2$`。`$L_i$` 中的值更新为 `$2$`。一个新的 thunk `$T_1 = fun() \\{ return\\ i \\}` 被创建。它也捕获了同一位置 `$L_i$` 的引用。\n5.  **迭代 3**：`$i$` 被设为 `$3$`。`$L_i$` 中的值更新为 `$3$`。第三个 thunk `$T_2 = fun() \\{ return\\ i \\}` 被创建，同样捕获了 `$L_i$` 的引用。\n6.  循环终止。列表 `$res$` 现在包含三个 thunk：`$T_0$`、`$T_1$` 和 `$T_2$`。**关键在于，所有三个 thunk 都持有对同一个内存位置 `$L_i$` 的引用。**\n7.  语句 `$i = 99$` 被执行。这将值 `$99$` 写入由 `$i$` 表示的位置，即 `$L_i$`。\n8.  函数返回列表 `$res$`，该列表被赋给 `$fs$`。\n9.  print 语句执行 `$fs[0]()$`、`$fs[1]()$` 和 `$fs[2]()$`。\n    -   `$fs[0]()$`：thunk `$T_0$` 被调用。它从其捕获的位置 `$L_i$` 读取值。`$L_i$` 中的当前值为 `$99$`。结果是 `$99$`。\n    -   `$fs[1]()$`：thunk `$T_1$` 被调用。它也从 `$L_i$` 读取。结果是 `$99$`。\n    -   `$fs[2]()$`：thunk `$T_2$` 被调用。它也从 `$L_i$` 读取。结果是 `$99$`。\n10. 最终输出是 `($99, 99, 99$)`。\n\n**情况 2：`makeF` 使用值捕获**\n\n1.  步骤 1-2 相同。为循环变量创建了一个单一位置 `$L_i$`。\n2.  **迭代 1**：`$i$` 是 `$1$`。一个 thunk `$T_0'$` 被创建。在值捕获下，`$T_0'$` 捕获了 `$i$` 当前值的*副本*。值 `$1$` 被存储在 `$T_0'$` 的闭包内。\n3.  **迭代 2**：`$i$` 是 `$2$`。一个 thunk `$T_1'$` 被创建，捕获了值 `$2$`。\n4.  **迭代 3**：`$i$` 是 `$3$`。一个 thunk `$T_2'$` 被创建，捕获了值 `$3$`。\n5.  循环终止。列表 `$res$` 包含 `$T_0'$`、`$T_1'$` 和 `$T_2'$`。\n6.  语句 `$i = 99$` 更新了位置 `$L_i$`，但这对于已经复制到 thunk 中的值没有影响。\n7.  函数返回 `$res$`。执行时：\n    -   `$fs[0]()$` 返回其捕获的值 `$1$`。\n    -   `$fs[1]()$` 返回其捕获的值 `$2$`。\n    -   `$fs[2]()$` 返回其捕获的值 `$3$`。\n8.  最终输出是 `($1, 2, 3$)`。\n\n**情况 3：`makeF_refactored` 使用引用捕获**\n\n1.  函数 `$makeF\\_refactored$` 以 `$n=3$` 被调用。创建一个空列表 `$res$`。\n2.  `for` 循环开始，循环变量共享一个单一位置 `$L_i$`。\n3.  **迭代 1**：`$i$` 是 `$1$`。语句 `let j = i` 被执行。由于这个 `let` 在循环体内，**每次迭代都会为 `$j$` 创建一个新的可变位置**。我们称此位置为 `$L_{j,1}$`。`$i$` 的值（`$1$`）被复制到 `$L_{j,1}$` 中。thunk `$G_0 = fun() \\{ return\\ j \\}$` 被创建。它的自由变量是 `$j$`。它通过引用捕获了本次迭代中 `$j$` 的位置，即 `$L_{j,1}$`。\n4.  **迭代 2**：`$L_i$` 中的 `$i$` 更新为 `$2$`。语句 `let j = i` 再次被执行。一个**新的、独立的可变位置** `$L_{j,2}$` 被创建。值 `$2$` 被复制到 `$L_{j,2}$` 中。thunk `$G_1$` 被创建并捕获了对 `$L_{j,2}$` 的引用。\n5.  **迭代 3**：`$L_i$` 中的 `$i$` 更新为 `$3$`。为 `$j$` 创建了第三个位置 `$L_{j,3}$`，其值为 `$3$`。thunk `$G_2$` 被创建并捕获了对 `$L_{j,3}$` 的引用。\n6.  循环终止。列表 `$res$` 包含 `$G_0$`、`$G_1$` 和 `$G_2$`，它们分别引用三个不同的位置：`$L_{j,1}$`、`$L_{j,2}$` 和 `$L_{j,3}$`。\n7.  语句 `$i = 99$` 更新了位置 `$L_i$`。这不影响任何 `$L_j$` 位置。\n8.  函数返回 `$res$`，该列表被赋给 `$gs$`。\n9.  print 语句执行 `$gs[0]()$`、`$gs[1]()$` 和 `$gs[2]()$`。\n    -   `$gs[0]()$`：从其捕获的位置 `$L_{j,1}$` 读取，返回 `$1$`。\n    -   `$gs[1]()$`：从其捕获的位置 `$L_{j,2}$` 读取，返回 `$2$`。\n    -   `$gs[2]()$`：从其捕获的位置 `$L_{j,3}$` 读取，返回 `$3$`。\n10. 最终输出是 `($1, 2, 3$)`。\n\n**推导输出总结：**\n-   `$makeF$` 使用引用捕获：`($99, 99, 99$)`\n-   `$makeF$` 使用值捕获：`($1, 2, 3$)`\n-   `$makeF\\_refactored$` 使用引用捕捕获：`($1, 2, 3$)`\n\n**逐项选项分析**\n\n-   **A)** “在引用捕获下，makeF 打印 $\\left(3, 3, 3\\right)$...” 这是不正确的。它忽略了语句 `$i = 99$`，该语句在循环之后、但在 thunk 被调用之前，将 `$i$` 的单一共享位置从 `$3$` 更新为 `$99$`。“在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。” 这部分是正确的。“在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。” 这部分也是正确的。然而，由于第一个论断和推理存在缺陷，整个选项是无效的。\n    **结论：不正确。**\n\n-   **B)** “在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$...” 这与我们的推导相符。“...在值捕获下，makeF 打印 $\\left(1, 2, 3\\right)$。” 这也与我们的推导相符。“在引用捕获下，makeF_refactored 打印 $\\left(1, 2, 3\\right)$。” 这也相符。给出的原因是：“引用捕获共享了 $i$ 的单一位置（最后更新为 $99$），”这正确地解释了第一个结果。“...值捕获在 thunk 创建时复制了 $1$、$2$ 和 $3$，”这正确地解释了第二个结果。“...而引入 $j$ 为每次迭代创建了一个新的位置，每个 thunk 都引用该位置，”这正确地解释了第三个结果。该选项的所有部分都与我们的严谨推导一致。\n    **结论：正确。**\n\n-   **C)** “在引用捕获下，makeF 打印 $\\left(1, 2, 3\\right)$...” 这是不正确的。它混淆了在重构函数上下文中的引用捕获和值捕获。“...在值捕获下，makeF 打印 $\\left(1, 1, 1\\right)$。” 这同样是不正确的。`$i$` 的值在每次迭代中都会改变，而值捕获是在创建时捕获该值。\n    **结论：不正确。**\n\n-   **D)** “在引用捕获下，makeF 打印 $\\left(99, 99, 99\\right)$...” 这是正确的。“...在值捕获下，makeF 打印 $\\left(3, 3, 3\\right)$。” 这是不正确的。它错误地假设值仅在循环结束后才被捕获。“...在引用捕获下，makeF_refactored 打印 $\\left(99, 99, 99\\right)$。” 这是不正确的。它没有认识到 `let j` 在每次迭代中创建了一个新的绑定，从而将捕获的位置彼此隔离，并与对 `$i$` 的最终更新隔离。\n    **结论：不正确。**\n\n-   **E)** “...makeF 会导致悬垂引用...” 这个陈述与问题的一个前提直接矛盾：“运行时对捕获的位置执行逃逸安全分配，这样当闭包的生命周期超过其定义活动记录时，不会出现悬垂引用”。因此，这个选项基于一个错误的前提。\n    **结论：不正确。**", "answer": "$$\\boxed{B}$$", "id": "3620080"}, {"introduction": "在前一个练习的基础上，我们现在将扮演编译器设计者的角色。我们不再仅仅是识别“循环中的闭包”问题，而是要设计一个静态分析规则来自动检测它。这项实践弥合了理解语言语义与创建能帮助程序员编写更安全代码的实用工具之间的鸿沟。[@problem_id:3619989]", "problem": "考虑一门一阶、词法作用域的语言，其具有一等函数和闭包，并遵循以下语义，这些语义在编译器进行闭包转换后被广泛使用：\n\n- 函数字面量会生成一个闭包，该闭包携带其自由变量的环境。在按引用捕获模型下，闭包 $\\lambda$ 使用的每个自由变量 $x$ 都由一个存储 $x$ 当前值的环境单元表示。闭包持有对该单元的引用。\n- for 循环的索引变量 $v$ 在进入循环前被分配一个单一的可变单元；该单元在每次迭代时更新。也就是说，每次迭代时 $v$ 的绑定不变，只有其单元的内容发生变化。\n- 词法作用域决定了哪些变量是自由的：函数字面量 $\\lambda$ 的自由变量集合 $\\mathrm{FV}(\\lambda)$ 是在 $\\lambda$ 中使用但未在 $\\lambda$ 自身中绑定的标识符集合。\n- 如果存在一个控制流路径，在该路径上闭包 $\\lambda$ 可以在当前迭代动态结束后被调用，则称该闭包 $\\lambda$ 逃逸出该次迭代。\n- 数组 $H$ 是一个堆对象。将闭包 $\\lambda$ 追加到 $H$ 中会存储 $\\lambda$ 以备将来潜在的使用；调用 $\\mathrm{schedule}(\\lambda)$ 会将该闭包入队，以便在循环结束后运行。\n\n现在考虑以下场景。设 $N, M \\ge 1$ 为整数。我们创建一个空数组 $H$，然后执行两个嵌套循环：对于 $i$ 遍历 $0, 1, \\dots, N-1$ 和 $j$ 遍历 $0, 1, \\dots, M-1$，我们构建一个引用 $i$ 和 $j$ 的闭包 $\\lambda$，并将其追加到 $H$ 中。在两个循环都结束后，我们遍历 $H$ 并对每个存储的闭包调用 $\\mathrm{schedule}$。在上述语义下，$H$ 中的每个闭包都引用了用于 $i$ 和 $j$ 的相同的环境单元。\n\n你的任务是选择一个健全的静态检查器规则和一个保持语义的重构建议，以防止在此场景中意外地按引用捕获 $i$ 和 $j$。就此问题而言，如果一个闭包可能因为按引用捕获和循环单元复用而观察到 $i$ 或 $j$ 的最终值而不是每次迭代的值，检查器就必须发出警告，那么该检查器是健全的。如果重构能使得每个被调度的闭包观察到创建该闭包时 $i$ 和 $j$ 的当前迭代值，那么该重构是保持语义的。\n\n在所述模型下，以下哪些检查器和重构设计是正确的？选择所有适用的选项。\n\nA. 检查器：对于语法上位于循环体内的每个函数字面量 $\\lambda$，其循环索引集为 $V_{\\mathrm{loop}}$，计算 $\\mathrm{FV}(\\lambda)$。如果 $\\mathrm{FV}(\\lambda) \\cap V_{\\mathrm{loop}} \\ne \\varnothing$ 且 $\\lambda$ 可能逃逸出当前迭代，则为每个 $v \\in \\mathrm{FV}(\\lambda) \\cap V_{\\mathrm{loop}}$ 发出警告。重构：通过在内层循环中添加语句 $i' := i$ 和 $j' := j$ 来引入每次迭代的副本，并重写闭包使其仅引用 $i'$ 和 $j'$；此外，确保闭包按值捕获 $i'$ 和 $j'$（例如，通过将 $i'$ 和 $j'$ 作为参数传递给一个立即外围的、构造该闭包的函数，或者如果可用的话，使用按值捕获的功能）。\n\nB. 检查器：仅当一个闭包在创建它的同一条语句中被语法上传递给一个已知的异步函数（如 $\\mathrm{schedule}$）时才发出警告；如果闭包被存储在数组中或赋值给变量以供后续使用，则不警告。重构：将闭包调用移到循环之外以减少开销，但代码其余部分保持不变。\n\nC. 检查器：对任何引用了在闭包外部声明的变量的闭包出现都发出警告，无论该闭包是否逃逸，也无论该变量是否随循环变化。重构：将 $i$ 和 $j$ 标记为常量（只读）声明，使其值不能改变，但保持按引用捕获不变。\n\nD. 检查器：不发出警告。依赖标准的闭包转换和 lambda 提升来自动将对 $i$ 和 $j$ 的引用转换为每次应用的副本；假设编译器会将 $i$ 和 $j$ 提升为闭包参数，从而无需更改源代码即可避免意外的按引用捕获。重构：无需重构。\n\nE. 检查器：仅对 $j$（内层循环索引）发出警告，因为 $j$ 在内层循环中会变化，但不对 $i$（外层循环索引）发出警告，因为在任何一次固定的内层循环迭代中 $i$ 不会变化。重构：在循环前将 $i$ 提升为全局变量，使其不再是闭包的自由变量；保持 $j$ 不变。", "solution": "问题陈述是有效的。它描述了编程语言实现中一个关于词法作用域、一等闭包和可变循环变量相互作用的众所周知的问题。所提供的语义——特别是按引用捕获与每个循环索引变量在迭代中复用单一内存单元的组合——是连贯的，并且代表了多种真实世界语言（例如，早期的 JavaScript、Go）中的行为。任务是确定一个健全的静态分析规则和一个正确的重构技术，以解决由此产生的“意外捕获”问题。\n\n问题的核心在于三种特定语义的组合：\n1.  **循环变量分配**：循环变量 $i$ 和 $j$ 各自绑定到一个单一的可变内存单元，该单元在其各自循环的整个持续期间都存在。该单元中的值在每次迭代时更新。例如，有一个用于 $i$ 的单元，其内容从 $0$ 变为 $1$，依此类推，直到 $N-1$。\n2.  **按引用捕获**：当函数字面量 $\\lambda$ 被创建时，它形成一个闭包。这个闭包在创建时刻并不存储其自由变量（如 $i$ 和 $j$）的*值*。相反，它存储了对这些变量内存单元的*引用*。\n3.  **延迟执行**：这些闭包被存储在数组 $H$ 中，并且只有在两个循环都完成后才通过 $\\mathrm{schedule}$ 执行。\n\n结果是，所有在 $H$ 中创建和存储的 $N \\times M$ 个闭包都包含了对 $i$ 的*同一个*单元和对 $j$ 的*同一个*单元的引用。当这些闭包最终被执行时，它们都将从这些共享单元中读取当前值。到那时，循环已经结束，$i$ 和 $j$ 的单元将持有它们循环后的最终值（例如，$N$ 和 $M$，或者 $N-1$ 和 $M-1$，这取决于确切的循环终止语义；关键事实是这个值是最终的，并且对所有闭包都是相同的）。这与程序员可能的意图相悖，程序员可能希望为每次不同的迭代捕获 $i$ 和 $j$ 的特定值。\n\n一个健全的检查器必须能识别出任何捕获了循环变量的闭包可能在其创建迭代结束后执行的情况。一个正确的重构必须确保每个闭包观察到的是创建闭包时循环变量的值。\n\n**选项 A 分析**\n\n-   **检查器**：提议的检查器在以下情况发出警告：在循环内部定义的函数字面量 $\\lambda$ 捕获了循环索引变量（即 $\\mathrm{FV}(\\lambda) \\cap V_{\\mathrm{loop}} \\ne \\varnothing$）并且闭包 $\\lambda$ 可能逃逸出当前迭代。\n    -   这准确地描述了问题发生的条件。捕获非循环索引变量，或者捕获一个只在同一次迭代中使用的闭包中的循环索引变量，是安全的。捕获一个可变的、共享的循环索引单元并且生命周期超过该次迭代的组合才是产生风险的原因。\n    -   在给定场景中，闭包 $\\lambda$ 引用了 $i$ 和 $j$，所以 $\\mathrm{FV}(\\lambda) \\cap V_{\\mathrm{loop}} = \\{i, j\\} \\ne \\varnothing$。闭包被追加到一个堆分配的数组 $H$ 中，所以它明显逃逸出了迭代。这个检查器会正确地触发。根据问题的定义，这是一条健全的规则。\n\n-   **重构**：建议是在内层循环中引入新的、每次迭代都创建的变量 $i' := i$ 和 $j' := j$，并让闭包捕获这些新变量。\n    -   这是解决此问题的经典方案。通过在循环体内声明一个像 $i'$ 这样的新变量，*每次迭代*都会为 $i'$ 分配一个新的内存单元。这个新单元用 $i$ 的当前值初始化。然后闭包捕获对这个每次迭代都不同的单元的引用。由于这个单元的内容在初始化后永远不会被修改，闭包将始终观察到该迭代的正确值。\n    -   “确保闭包按值捕获 $i'$ 和 $j'$”的建议也是正确的。虽然基础语言模型是按引用捕获，但这种效果可以通过一些模式来实现，比如将值作为参数传递给生成闭包的另一个函数。这将值冻结在新的参数绑定中。这个提议是鲁棒的。\n    -   此重构能产生期望的行为，因此根据问题的定义是“保持语义的”。\n\n-   **结论**：**正确**。\n\n**选项 B 分析**\n\n-   **检查器**：这个检查器仅当闭包直接传递给像 $\\mathrm{schedule}$ 这样的函数时才发出警告。它明确表示“如果闭包被存储在数组中或赋值给变量以供后续使用，则不警告”。\n    -   这个检查器是不健全的。将闭包存储在数据结构中（如数组 $H$）是它逃逸出一次迭代并在稍后被调用的主要机制。该检查器将无法检测到问题陈述中描述的确切场景中的问题。\n\n-   **重构**：它建议将调用移到循环之外。\n    -   在问题场景中，调用（`schedule`）已经是在循环外部执行的。建议“保持代码不变”并不能解决底层的捕获问题。这个重构是错误的。\n\n-   **结论**：**不正确**。\n\n**选项 C 分析**\n\n-   **检查器**：这个检查器对捕获了*任何*外部变量的*任何*闭包都会发出警告，无论上下文如何。\n    -   这个规则过于宽泛了。捕获自由变量是闭包的一个基本且预期的特性。许多捕获是完全安全的（例如，捕获不可变变量，或不逃逸的闭包）。这样的检查器会在任何非平凡的程序中产生数量巨大、难以处理的误报，使其在实践中毫无用处。\n\n-   **重构**：它建议将 $i$ 和 $j$ 标记为常量（`只读`）。\n    -   这在逻辑上是不可能的。变量 $i$ 和 $j$ 是循环索引变量；它们存在的目的就是在每次迭代中被修改以驱动循环。`for` 循环结构内在地依赖于其索引变量的可变性。\n\n-   **结论**：**不正确**。\n\n**选项 D 分析**\n\n-   **检查器**：这个选项建议不发出警告，并依赖编译器自动修复问题。\n    -   这与问题的前提相矛盾，该前提明确定义了一种问题*确实*会发生的语言语义。任务是为给定的系统设计一个检查器，而不是假设一个不同的、更复杂的系统。虽然一些现代编译器确实执行此优化，但这并不能保证，而且问题是在不执行此优化的语义下定义的。\n\n-   **重构**：“无需重构。”\n    -   这是不正确的，因为在给定的语义下，要达到期望的结果，更改是绝对必要的。\n\n-   **结论**：**不正确**。\n\n**选项 E 分析**\n\n-   **检查器**：它建议只对内层循环变量 $j$ 发出警告，而对外层循环变量 $i$ 不发出警告，理由是在内层循环执行期间 $i$ 是常量。\n    -   这个推理是有缺陷的。虽然在内层循环的单次执行期间 $i$ 是常量，但在那段时间创建的闭包也逃逸出了*外层*循环。当所有循环结束并且闭包被执行时，$i$ 的共享单元已经被多次更新，并将持有其最终值。因此，捕获 $i$ 与捕获 $j$ 一样有问题。该检查器不健全，因为它漏掉了与 $i$ 相关的错误。\n\n-   **重构**：它建议将 $i$ 提升为全局变量。\n    -   这是无稽之谈。循环索引变量内在地与其循环结构绑定；它不能是全局变量。这会破坏循环的控制流。此外，保持 $j$ 不变也未能解决问题的另一半。\n\n-   **结论**：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3619989"}]}