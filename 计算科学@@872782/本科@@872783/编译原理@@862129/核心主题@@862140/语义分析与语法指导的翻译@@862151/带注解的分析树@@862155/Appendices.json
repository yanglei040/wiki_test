{"hands_on_practices": [{"introduction": "我们的第一个练习将深入探讨属性语法的核心应用。我们将处理一个具有歧义性的算术表达式文法，并通过为运算符节点添加优先级（$prec$）和结合性（$assoc$）属性来解决这个歧义。这个过程将帮助你理解编译器如何根据这些规则构建唯一的解析树，并最终计算出表达式的值。[@problem_id:3621665]", "problem": "考虑一个歧义表达式文法 $G$，它只有一个非终结符 $E$ 和产生式 $E \\rightarrow E \\text{^} E \\mid E * E \\mid E + E \\mid \\text{num}$，其中 $\\text{num}$ 表示一个正整数字面量。在一个注解分析树和属性文法的框架中，每个由二元运算符标记的内部节点都将用两个属性进行注解：一个数值优先级属性 $prec$ 和一个结合性属性 $assoc$。这些属性应编码常规的算术意图，即幂运算比乘法绑定得更紧密，乘法比加法绑定得更紧密，并且幂运算是右结合的，而乘法和加法是左结合的。你需要纯粹使用这些属性来消除分析的歧义，方法是强制在树结构中高优先级的运算符支配低优先级的运算符，并且同一优先级上的冲突根据结合性来解决。\n\n设预期的属性值为 $prec(\\text{^})=3$，$prec(*)=2$，$prec(+)=1$，以及 $assoc(\\text{^})=\\text{right}$，$assoc(*)=\\text{left}$，$assoc(+)=\\text{left}$。此外，在每个 $E$-节点上定义一个综合属性 $val$，它根据以下语义基础给出该节点处子表达式的数值：如果 $E \\rightarrow \\text{num}$，则 $val$ 是该字面量的整数值；如果 $E \\rightarrow E_1 + E_2$，则 $val = E_1.val + E_2.val$；如果 $E \\rightarrow E_1 * E_2$，则 $val = E_1.val \\times E_2.val$；如果 $E \\rightarrow E_1 \\text{^} E_2$，则 $val = E_1.val^{E_2.val}$。\n\n从上下文无关文法的语法树和属性文法的注解语法树的基本定义出发，确定由给定的 $prec$ 和 $assoc$ 属性对输入字符串 $s = 2 \\text{^} 3 \\text{^} 2 + 4 * 5 + 6$ 所强制规定的唯一括号化形式。然后，使用上述 $val$ 的语义基础，计算 $s$ 的消歧分析中根节点的 $val$ 的数值。将最终值表示为一个精确整数。无需四舍五入。", "solution": "此问题要求执行两步过程：首先，利用给定的运算符优先级和结合性规则，为输入字符串 $s = 2 \\text{^} 3 \\text{^} 2 + 4 * 5 + 6$ 推导出唯一的语法分析树结构；其次，根据该树结构和提供的语义规则，计算根节点的综合属性 $val$ 的值。\n\n文法为 $E \\rightarrow E \\text{^} E \\mid E * E \\mid E + E \\mid \\text{num}$。\n运算符属性如下：\n- **优先级**：$prec(\\text{^})=3$ (最高), $prec(*)=2$, $prec(+)=1$ (最低)。\n- **结合性**：$assoc(\\text{^})=\\text{right}$, $assoc(*)=\\text{left}$, $assoc(+)=\\text{left}$。\n\n**步骤 1：确定唯一的分析树结构（括号化）**\n\n分析树的结构由运算符的优先级和结合性决定。高优先级的运算符在低优先级的运算符之前进行计算，这意味着它们在语法树中处于更深（更低）的层次。对于优先级相同的运算符，结合性规则决定分组：左结合意味着从左到右分组（例如，$a+b+c$ 解析为 $(a+b)+c$），右结合则意味着从右到左分组（例如，$a \\text{^} b \\text{^} c$ 解析为 $a \\text{^} (b \\text{^} c)$）。\n\n我们来分析输入字符串 $s = 2 \\text{^} 3 \\text{^} 2 + 4 * 5 + 6$。\n字符串中的运算符为 $\\text{^}, \\text{^}, +, *, +$。\n\n1.  **最高优先级**：幂运算符 $\\text{^}$ 具有最高优先级（$prec=3$）。表达式中涉及幂运算的部分是 $2 \\text{^} 3 \\text{^} 2$。由于存在两个优先级相同的幂运算符，我们应用其结合性规则，即右结合 ($assoc(\\text{^})=\\text{right}$)。因此，这部分从右到左分组，结构为 $2 \\text{^} (3 \\text{^} 2)$。这个子表达式必须在任何加法或乘法运算之前求值。\n\n2.  **次高优先级**：乘法运算符 $*$ 具有次高优先级（$prec=2$）。涉及乘法的子表达式是 $4 * 5$。其分组是简单的 $(4 * 5)$。\n\n3.  **最低优先级**：加法运算符 $+$ 具有最低优先级（$prec=1$）。在处理完高优先级运算后，表达式的结构可以视为 $(2 \\text{^} (3 \\text{^} 2)) + (4 * 5) + 6$。这里有两个优先级相同的加法运算符。根据其左结合性 ($assoc(+)=\\text{left}$) 规则，表达式从左到右分组。因此，最终结构为 $((2 \\text{^} (3 \\text{^} 2)) + (4 * 5)) + 6$。\n\n所以，唯一确定的、完全括号化的表达式如下：\n$$((2 \\text{^} (3 \\text{^} 2)) + (4 * 5)) + 6$$\n\n**步骤 2：计算综合属性 `val`**\n\n我们现在根据推导出的括号化结构和 `val` 属性的语义规则，自底向上地计算表达式的数值。\n\n1.  计算最内层的括号表达式 $(3 \\text{^} 2)$：\n    $$3^2 = 9$$\n    表达式变为 $((2 \\text{^} 9) + (4 * 5)) + 6$。\n\n2.  计算下一个内层表达式 $(2 \\text{^} 9)$：\n    $$2^9 = 512$$\n    表达式变为 $(512 + (4 * 5)) + 6$。\n\n3.  计算另一个括号表达式 $(4 * 5)$：\n    $$4 \\times 5 = 20$$\n    表达式变为 $(512 + 20) + 6$。\n\n4.  计算剩余括号内的和 $(512 + 20)$：\n    $$512 + 20 = 532$$\n    表达式变为 $532 + 6$。\n\n5.  最后，执行根节点的操作，即最后的加法：\n    $$532 + 6 = 538$$\n\n最终结果 $538$ 是输入字符串 $s$ 的消歧分析树根节点的综合属性 $val$ 的值。", "answer": "$$\\boxed{538}$$", "id": "3621665"}, {"introduction": "在掌握了如何使用属性来解析表达式后，我们来挑战一个逆向问题：“反解析”。这个练习要求你从一个给定的解析树出发，生成其对应的中缀表达式字符串，同时插入最少数量的括号以确保表达式的结构不会在重新解析时丢失。这项实践能加深你对运算符优先级和结合性规则如何影响代码表示的理解，是代码格式化工具（pretty-printer）设计的关键一步。[@problem_id:3621753]", "problem": "考虑一个中缀表达式语言，其二元运算符包括 $+$、$-$、$*$、$/$ 和 $^$ (幂运算)，叶子节点为标识符。该语言使用上下文无关文法进行解析，并通过运算符优先级和结合性来消除歧义。解析树的每个内部节点都标注了两个综合属性：$\\operatorname{prec}$，即该节点运算符的优先级；以及 $\\operatorname{assoc}$，即该运算符的结合性。标识符是叶子节点，没有运算符；为了便于比较，将叶子节点视为具有 $\\operatorname{prec} = +\\infty$。优先级和结合性如下：\n- $+$ 和 $-$：$\\operatorname{prec} = 1$，$\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n- $*$ 和 $/$：$\\operatorname{prec} = 2$，$\\operatorname{assoc} = \\mathrm{left}$ (左结合)。\n- $^$：$\\operatorname{prec} = 3$，$\\operatorname{assoc} = \\mathrm{right}$ (右结合)。\n\n反解析器必须为给定的解析树生成中缀字符串，同时插入最少数量的括号，以保证重新解析该字符串（使用相同的优先级和结合性）时，能够精确地得到原始的解析树。\n\n从优先级的基本定义（即决定绑定强度的顺序）和结合性的基本定义（即在优先级相同时决定分组的决胜规则）出发，推导一个基于属性的决策规则。对于每个父节点（其运算符优先级为 $\\operatorname{prec}_{p}$，结合性为 $\\operatorname{assoc}_{p}$），该规则仅根据子树根节点的运算符优先级 $\\operatorname{prec}_{c}$ 以及该子树是左子节点还是右子节点，来决定是否为给定的子树添加括号。然后，将你推导出的规则应用于如下定义的具体解析树 $T$：\n- $T$ 的根节点是运算符 $-$，其左子节点为 $A$，右子节点为 $B$。\n- 子树 $A$ 的根节点是 $/$，其左子节点为 $A_{1}$，右子节点为 $A_{2}$。\n- 子树 $A_{1}$ 的根节点是 $+$，其叶子节点为 $a$ 和 $b$。\n- 子树 $A_{2}$ 的根节点是 $*$，其左叶子节点为 $c$，右子节点为 $A_{2b}$。\n- 子树 $A_{2b}$ 的根节点是 $^$，其叶子节点为 $d$ 和 $e$。\n- 子树 $B$ 的根节点是 $^$，其左子节点为 $B_{1}$，右子节点为 $B_{2}$。\n- 子树 $B_{1}$ 的根节点是 $^$，其叶子节点为 $f$ 和 $g$。\n- 子树 $B_{2}$ 的根节点是 $+$，其叶子节点为 $h$ 和 $i$。\n\n计算当反解析器为 $T$ 生成中缀字符串时，所插入的最少括号对的总数。请用一个整数表示你的最终答案。", "solution": "该问题要求我们首先推导一个用于最小化括号插入的通用规则，然后在给定的解析树 $T$ 上应用此规则，并统计所需的括号对数量。\n\n**第一步：推导最小化括号规则**\n\n设父节点的运算符为 $op_p$，其优先级为 $\\operatorname{prec}_p$，结合性为 $\\operatorname{assoc}_p$。其子节点的根运算符为 $op_c$，优先级为 $\\operatorname{prec}_c$。当且仅当默认的优先级和结合性规则会破坏原始树结构时，才需要在子表达式周围添加括号。\n\n1.  **优先级比较 ($\\operatorname{prec}_c$ vs $\\operatorname{prec}_p$)**\n    - 如果 $\\operatorname{prec}_c > \\operatorname{prec}_p$：子节点的操作绑定更紧密，自然分组正确，**无需括号**。\n    - 如果 $\\operatorname{prec}_c  \\operatorname{prec}_p$：父节点的操作绑定更紧密，会“窃取”子节点的操作数，破坏分组，**需要括号**。\n\n2.  **优先级相等 ($\\operatorname{prec}_c = \\operatorname{prec}_p$)**\n    此时由结合性决定。\n    - **左子节点**：表达式形如 `( ... op_c ... ) op_p ...`\n        - 如果 $op_p$ 是**左结合**，默认分组为 `( ... op_c ... ) op_p ...`，与树结构一致，**无需括号**。\n        - 如果 $op_p$ 是**右结合**，默认分组为 `... op_c ( ... op_p ... )`，与树结构冲突，**需要括号**。\n    - **右子节点**：表达式形如 `... op_p ( ... op_c ... )`\n        - 如果 $op_p$ 是**左结合**，默认分组为 `( ... op_p ... ) op_c ...`，与树结构冲突，**需要括号**。\n        - 如果 $op_p$ 是**右结合**，默认分组为 `... op_p ( ... op_c ... )`，与树结构一致，**无需括号**。\n\n**括号规则总结：**\n为子表达式添加括号，如果其根运算符 $op_c$ 和父运算符 $op_p$ 满足以下任一条件：\n1.  $\\operatorname{prec}_c  \\operatorname{prec}_p$。\n2.  $\\operatorname{prec}_c = \\operatorname{prec}_p$，且该子表达式是**左**子节点，并且 $op_p$ 是**右结合**。\n3.  $\\operatorname{prec}_c = \\operatorname{prec}_p$，且该子表达式是**右**子节点，并且 $op_p$ 是**左结合**。\n\n叶子节点（标识符）的 $\\operatorname{prec} = +\\infty$，因此永远不会被加括号。\n\n**第二步：将规则应用于树 T**\n\n运算符属性：\n-   `+`, `-`：$\\operatorname{prec} = 1$, $\\operatorname{assoc} = \\mathrm{left}$。\n-   `*`, `/`：$\\operatorname{prec} = 2$, $\\operatorname{assoc} = \\mathrm{left}$。\n-   `^`：$\\operatorname{prec} = 3$, $\\operatorname{assoc} = \\mathrm{right}$。\n\n我们自顶向下检查每个非叶子节点的子节点：\n\n-   **父节点: `-` (根)** ($\\operatorname{prec}_p=1$, left-assoc)\n    -   左子节点 (根为 `/`, $\\operatorname{prec}_c=2$): $\\operatorname{prec}_c > \\operatorname{prec}_p$。无需括号。\n    -   右子节点 (根为 `^`, $\\operatorname{prec}_c=3$): $\\operatorname{prec}_c > \\operatorname{prec}_p$。无需括号。\n\n-   **父节点: `/` (A的根)** ($\\operatorname{prec}_p=2$, left-assoc)\n    -   左子节点 $A_1$ (根为 `+`, $\\operatorname{prec}_c=1$): $\\operatorname{prec}_c  \\operatorname{prec}_p$。根据规则1，**需要括号 (1)**。\n    -   右子节点 $A_2$ (根为 `*`, $\\operatorname{prec}_c=2$): $\\operatorname{prec}_c = \\operatorname{prec}_p$。这是右子节点，父节点是左结合。根据规则3，**需要括号 (2)**。\n\n-   **父节点: `*` (A₂的根)** ($\\operatorname{prec}_p=2$, left-assoc)\n    -   左子节点: `c` (叶子)。无需括号。\n    -   右子节点 $A_{2b}$ (根为 `^`, $\\operatorname{prec}_c=3$): $\\operatorname{prec}_c > \\operatorname{prec}_p$。无需括号。\n\n-   **父节点: `^` (B的根)** ($\\operatorname{prec}_p=3$, right-assoc)\n    -   左子节点 $B_1$ (根为 `^`, $\\operatorname{prec}_c=3$): $\\operatorname{prec}_c = \\operatorname{prec}_p$。这是左子节点，父节点是右结合。根据规则2，**需要括号 (3)**。\n    -   右子节点 $B_2$ (根为 `+`, $\\operatorname{prec}_c=1$): $\\operatorname{prec}_c  \\operatorname{prec}_p$。根据规则1，**需要括号 (4)**。\n\n其他所有子节点均为叶子节点，无需加括号。\n\n**结论**\n总共有4个位置需要插入括号：\n1.  子树 $A_1$ ($a+b$) 周围，因为 `+` (prec=1) 的优先级低于其父节点 `/` (prec=2)。\n2.  子树 $A_2$ ($c*d^e$) 周围，因为 `*` (prec=2) 与其父节点 `/` (prec=2) 优先级相同，且它是左结合运算符的右子节点。\n3.  子树 $B_1$ ($f^g$) 周围，因为 `^` (prec=3) 与其父节点 `^` (prec=3) 优先级相同，且它是右结合运算符的左子节点。\n4.  子树 $B_2$ ($h+i$) 周围，因为 `+` (prec=1) 的优先级低于其父节点 `^` (prec=3)。\n\n最终生成的字符串为 `((a+b) / (c*d^e)) - ((f^g)^(h+i))`。\n总共需要插入 **4** 对括号。", "answer": "$$\\boxed{4}$$", "id": "3621753"}, {"introduction": "最后一个练习将展示注解解析树在解决复杂优化问题中的强大能力。我们将为一个矩阵表达式文法设计属性，用以追踪矩阵的维度（$shape$）和计算成本（$cost$）。通过评估不同解析方式的成本，我们可以找到计算表达式的最高效路径，这在科学计算和数据库查询优化等领域是一个经典的挑战。[@problem_id:3621717]", "problem": "给定用于矩阵表达式的歧义上下文无关文法（Context-Free Grammar, CFG）\n$$\nM \\to M * M \\mid M + M \\mid M^{\\top} \\mid \\text{id},\n$$\n其中 $\\text{id}$ 表示矩阵标识符。请定义一个综合属性规范，为每个语法分析树节点标注两个属性：\n- $shape \\in \\mathbb{N} \\times \\mathbb{N}$，给出子表达式的矩阵维度 $(rows, cols)$，以及\n- $cost \\in \\mathbb{R}_{\\ge 0} \\cup \\{\\infty\\}$，给出计算该子表达式的标量运算成本。\n\n假设类型和成本遵循以下基本规则：\n- 如果 $X$ 的形状为 $(r,k)$ 且 $Y$ 的形状为 $(k,c)$，则 $X * Y$ 的形状为 $(r,c)$，成本为 $r \\cdot k \\cdot c$。\n- 如果 $X$ 和 $Y$ 具有相同的形状 $(r,c)$，则 $X + Y$ 的形状为 $(r,c)$，成本为 $r \\cdot c$。\n- 如果 $X$ 的形状为 $(r,c)$，则 $X^{\\top}$ 的形状为 $(c,r)$，成本为 $0$。\n- 每个标识符 $\\text{id}$ 的形状从符号表中可知，其成本为 $0$。\n- 任何类型不匹配的组合都会产生 $cost = \\infty$ 和未定义的 $shape$。\n\n由于该文法对于 $*$ 和 $+$ 是有歧义的，请将非终结符 $M$ 的属性解释为：在针对同一终结符串的所有语法分析树中，选择有限成本中的最小值，其 $shape$ 取自成本最小的那个选项。\n\n使用这种基于属性的解释，计算表达式的最小总成本\n$$\nA * B * C \\; + \\; D^{\\top} * E,\n$$\n符号表如下\n- $A : (10,100)$,\n- $B : (100,5)$,\n- $C : (5,50)$,\n- $D : (50,10)$,\n- $E : (50,50)$.\n\n一元转置 $^{\\top}$ 的绑定比二元运算符更紧密；二元运算符通过语法分析被完全括号化，并且可以按任何与词元顺序一致的方式进行分组。请提供最小总成本，结果为精确整数（不要四舍五入）。最终答案中不要包含任何单位。", "solution": "此问题要求我们根据属性文法规则，找到计算给定矩阵表达式的最小成本。由于文法是歧义的，我们需要考虑所有可能的合法解析方式（括号化），并选择成本最低的一种。这本质上是一个动态规划问题，类似于矩阵链乘法。\n\n**1. 设定问题**\n表达式为 `A * B * C + Dᵀ * E`。我们首先处理优先级最高的转置运算。\n- 矩阵 `D` 的形状是 $(50, 10)$。\n- 矩阵 `Dᵀ` 的形状是 $(10, 50)$，计算成本为 $0$。\n\n现在，问题简化为计算 `A * B * C + D' * E` 的最小成本，其中 `D'` 代表 `Dᵀ`。\n操作数序列为 $M_1, M_2, M_3, M_4, M_5$，其中：\n- $M_1=A: (10,100)$, cost=0\n- $M_2=B: (100,5)$, cost=0\n- $M_3=C: (5,50)$, cost=0\n- $M_4=D': (10,50)$, cost=0\n- $M_5=E: (50,50)$, cost=0\n\n运算符序列为 `*`, `*`, `+`, `*`。我们用动态规划方法，计算计算从 $M_i$ 到 $M_j$ 的子链的最小成本 `cost[i,j]` 和结果形状 `shape[i,j]`。\n\n**2. 动态规划求解**\n\n**子链长度 L = 2:**\n- `cost[1,2]` for $A*B$: shape=(10,100) * (100,5) -> (10,5). 成本 = $10 \\times 100 \\times 5 = 5000$.\n- `cost[2,3]` for $B*C$: shape=(100,5) * (5,50) -> (100,50). 成本 = $100 \\times 5 \\times 50 = 25000$.\n- `cost[3,4]` for $C+D'$: shape=(5,50) + (10,50). 形状不匹配。成本 = $\\infty$.\n- `cost[4,5]` for $D'*E$: shape=(10,50) * (50,50) -> (10,50). 成本 = $10 \\times 50 \\times 50 = 25000$.\n\n**子链长度 L = 3:**\n- `cost[1,3]` for $A*B*C$:\n  - $(A*B)*C$: `cost[1,2]` + `cost[3,3]` + $10 \\times 5 \\times 50 = 5000 + 0 + 2500 = 7500$.\n  - $A*(B*C)$: `cost[1,1]` + `cost[2,3]` + $10 \\times 100 \\times 50 = 0 + 25000 + 50000 = 75000$.\n  - **最小 `cost[1,3]` = 7500**, `shape[1,3]` = (10,50).\n- `cost[2,4]` for $B*C+D'$:\n  - $(B*C)+D'$: shape=(100,50) + (10,50). 不匹配。成本 = $\\infty$.\n  - $B*(C+D')$: `cost[3,4]` 为 $\\infty$. 成本 = $\\infty$.\n  - **`cost[2,4]` = $\\infty$**.\n- `cost[3,5]` for $C+D'*E$:\n  - $(C+D')*E$: `cost[3,4]` 为 $\\infty$. 成本 = $\\infty$.\n  - $C+(D'*E)$: shape=(5,50) + (10,50). 不匹配。成本 = $\\infty$.\n  - **`cost[3,5]` = $\\infty$**.\n\n**子链长度 L = 4:**\n- `cost[1,4]` for $A*B*C+D'$:\n  - 分割在第一个 `*`: $A*(B*C+D')$. `cost[2,4]` 为 $\\infty$.\n  - 分割在第二个 `*`: $(A*B)*(C+D')$. `cost[3,4]` 为 $\\infty$.\n  - 分割在 `+`: $(A*B*C)+D'$. `shape[1,3]`=(10,50), `shape[4,4]`=(10,50). 匹配。\n    成本 = `cost[1,3]` + `cost[4,4]` + $10 \\times 50 = 7500 + 0 + 500 = 8000$.\n  - **最小 `cost[1,4]` = 8000**, `shape[1,4]` = (10,50).\n- `cost[2,5]` for $B*C+D'*E$: 所有分割都涉及不兼容的子问题（如`cost[2,4]`, `cost[3,5]`）或不兼容的运算，因此 **`cost[2,5]` = $\\infty$**.\n\n**子链长度 L = 5 (整个表达式):**\n- `cost[1,5]` for $A*B*C+D'*E$:\n  - 分割在第一个 `*`: $A*(B*C+D'*E)$. `cost[2,5]` 为 $\\infty$.\n  - 分割在第二个 `*`: $(A*B)*(C+D'*E)$. `cost[3,5]` 为 $\\infty$.\n  - 分割在 `+`: $(A*B*C)+(D'*E)$.\n    - `cost[1,3]` = 7500, `shape[1,3]` = (10,50).\n    - `cost[4,5]` = 25000, `shape[4,5]` = (10,50).\n    - 形状匹配。加法成本 = $10 \\times 50 = 500$.\n    - 总成本 = $7500 + 25000 + 500 = 33000$.\n  - 分割在第三个 `*`: $(A*B*C+D')*E$.\n    - `cost[1,4]` = 8000, `shape[1,4]` = (10,50).\n    - `cost[5,5]` = 0, `shape[5,5]` = (50,50).\n    - 形状匹配。乘法成本 = $10 \\times 50 \\times 50 = 25000$.\n    - 总成本 = $8000 + 0 + 25000 = 33000$.\n\n**3. 结论**\n通过动态规划，我们考察了所有合法的解析方式。有两种解析方式能产生有限的成本，它们的成本恰好相同。\n1. `((A*B)*C) + (Dᵀ*E)`\n2. `(((A*B)*C) + Dᵀ) * E`\n\n这两种方式的成本都是33000。因此，表达式的最小总成本是33000。", "answer": "$$ \\boxed{33000} $$", "id": "3621717"}]}