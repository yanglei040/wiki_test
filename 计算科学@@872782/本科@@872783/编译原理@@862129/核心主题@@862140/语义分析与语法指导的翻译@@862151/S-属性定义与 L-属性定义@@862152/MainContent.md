## 引言
在将源代码翻译成可执行程序的过程中，编译器不仅需要理解代码的语法结构，更要把握其深层的语义。语法导向定义（Syntax-Directed Definition, SDD）正是连接语法和语义的桥梁，它通过为文法符号附加属性，并为产生式编写语义规则，实现了对程序意义的系统化计算。然而，属性之间的依赖关系错综复杂，如果处理不当，将导致[计算效率](@entry_id:270255)低下甚至无法计算。这就引出了一个核心问题：我们如何对语法导向定义进行分类，以确保属性能够被高效、有序地评估？

本文聚焦于解决这一问题的两种最重要的方法：[S-属性定义](@entry_id:754469)和L-属性定义。通过学习本文，你将掌握区分这两种定义的关键原则，理解它们各自的优势与局限。
- 在**“原理与机制”**一章中，我们将深入剖析[S-属性定义](@entry_id:754469)纯粹的自下而上信息流和L-属性定义强大的从左到右上下文传递能力，并阐明它们的评估方式。
- 在**“应用与跨学科联系”**一章中，我们将跳出理论，探讨这些定义在[编译器设计](@entry_id:271989)（如类型检查、作用域管理）和更广泛领域（如Web技术、信息安全）中的实际应用。
- 最后，在**“动手实践”**部分，你将有机会通过具体问题，亲手设计属性规则，将理论知识转化为解决实际问题的能力。

现在，让我们从最基础的原理开始，探索这两种强大的语法导向翻译工具。

## 原理与机制

在[语法分析](@entry_id:267960)的基础上，语法导向定义（Syntax-Directed Definition, SDD）为我们提供了一个强大的形式化框架，用于将语义信息与文法结构相关联。通过为文法符号关联**属性**（attributes）并为产生式编写**语义规则**（semantic rules），我们可以计算出从简单的类型检查到复杂的[代码生成](@entry_id:747434)等各种任务所需的值。然而，并非所有属性依赖关系都是平等的。为了确保属性可以被高效、系统地计算，我们将 SDD 分为不同的类别。本章将深入探讨两个最重要的类别：**[S-属性定义](@entry_id:754469)**（S-attributed definitions）和**L-属性定义**（L-attributed definitions）。我们将阐明它们的核心原理、工作机制，以及它们各自适用的场景。

### [S-属性定义](@entry_id:754469)：自下而上的综合之力

最直观、最简单的一类语法导向定义是 [S-属性定义](@entry_id:754469)。其核心特征在于它完全依赖于一种特定类型的属性。

**定义：[S-属性定义](@entry_id:754469)**

一个语法导向定义如果**只使用[综合属性](@entry_id:755750)**（synthesized attributes），则称之为 **[S-属性定义](@entry_id:754469)**。

**[综合属性](@entry_id:755750)**是一种在分析树节点上计算的属性，其值完全由其**子节点**的属性值或该节点自身的词法单元值确定。这一定义蕴含了一种清晰且单向的信息流：信息从分析树的叶节点开始，逐层向上传递，最终汇集于根节点。这种自下而上的信息流动，我们称之为**综合**（synthesis）。

#### 评估 [S-属性定义](@entry_id:754469)

由于信息流动的方向是固定的（总是向上），[S-属性定义](@entry_id:754469)的评估过程非常直观。可以在分析树上进行一次**[后序遍历](@entry_id:273478)**（post-order traversal）来完成所有属性的计算。在遍历过程中，只有当一个节点的所有子节点的属性值都计算完毕后，才计算该节点的[综合属性](@entry_id:755750)。

这种评估顺序与**自下而上**（bottom-up）的[语法分析](@entry_id:267960)策略（如 LR 分析法）完美契合。当分析器执行一次**规约**（reduction）时，产生式右侧的符号（代表子节点）已经被处理，它们的属性值是已知的。此时，分析器可以立即执行与该产生式关联的语义规则，计算出代表产生式左侧非终结符（父节点）的[综合属性](@entry_id:755750)。

#### [S-属性定义](@entry_id:754469)的典型应用

[S-属性定义](@entry_id:754469)在处理那些其语义值完全由其组成部分的语义值决定的任务时，表现得尤为出色。换句话说，如果一个语法结构的含义是“上下文无关”的，那么 [S-属性定义](@entry_id:754469)通常就足够了。

**示例 1：计算表达式中使用过的变量集合**

考虑一个典型的算术表达式文法，我们的任务是计算每个子表达式中使用过的所有变量（标识符）的集合 [@problem_id:3668938]。这个任务是“上下文无关”的，因为一个子表达式（如 `$a + b$`）所使用的变量集合，并不会因为它出现在 `$(a + b) * c$` 还是 `$d - (a + b)$` 中而改变。

我们可以为每个非终结符 $E$、$T$ 和 $F$ 定义一个[综合属性](@entry_id:755750) $used$，它是一个存储变量名的集合。

对于产生式 $F \to \boldsymbol{id}$，该子表达式使用的变量就是这个标识符本身。因此，语义规则为：
$F \to \boldsymbol{id}: \quad F.used = \{ \boldsymbol{id}.lexeme \}$
其中 `id.lexeme` 是词法分析器提供的标识符字符串。

对于产生式 $F \to \boldsymbol{num}$，数字字面量不是变量，所以使用的变量集合为空：
$F \to \boldsymbol{num}: \quad F.used = \varnothing$

对于像 $E \to E_1 + T$ 这样的产生式，整个表达式使用的变量集合是其两个子表达式使用变量集合的并集：
$E \to E_1 + T: \quad E.used = E_1.used \cup T.used$

其他产生式，如 $T \to F$ 或 $F \to (E)$，只是将子节点的属性值向上传递：
$T \to F: \quad T.used = F.used$
$F \to (E): \quad F.used = E.used$

在所有这些规则中，父节点的属性 $E.used$ 或 $T.used$ 等，都只依赖于其子节点 $E_1.used$、$T.used$ 或 $F.used$。信息严格地自下而上传递，这正是 [S-属性定义](@entry_id:754469)的精髓。

**示例 2：计算括号的嵌套深度**

另一个 [S-属性定义](@entry_id:754469)的例子是计算括号表达式的最大嵌套深度 [@problem_id:3668976]。考虑文法 $E \to (E) \mid EE \mid \epsilon$。我们可以定义一个[综合属性](@entry_id:755750) $depth$：

*   $E \to \epsilon: \quad E.depth = 0$ (空字符串深度为0)
*   $E \to (E_1): \quad E.depth = E_1.depth + 1$ (每对括号使深度加一)
*   $E \to E_1 E_2: \quad E.depth = \max(E_1.depth, E_2.depth)$ ([串联](@entry_id:141009)的表达式深度取两者中的较大值)

即使文法 $E \to EE$ 是模糊的，对于给定的字符串如 `(()())`，无论分析树如何构造（例如，是 `(())` 和 `()` 的[串联](@entry_id:141009)，还是 `()` 和 `()()` 的[串联](@entry_id:141009)），由于 $\max$ 函数满足结合律和交换律，最终计算出的 $depth$ 值都是相同的。这进一步说明了 [S-属性定义](@entry_id:754469)在处理[组合性](@entry_id:637804)问题上的鲁棒性。

其他适合 [S-属性定义](@entry_id:754469)的任务还包括构建[抽象语法树](@entry_id:633958)（AST）、计算表达式的[真值表](@entry_id:145682) [@problem_id:3669002] 等。它们的共同点是，父节点的语义完全由其直接组成部分的语义组合而成。

### L-属性定义：融合从左到右的上下文

尽管 [S-属性定义](@entry_id:754469)很强大，但它有一个根本性的限制：信息只能向上流动。然而，许多重要的语言特性依赖于从左到右传递的上下文信息。例如，在使用一个变量之前必须先声明它。[S-属性定义](@entry_id:754469)无法处理这类问题。为了解决这个问题，我们引入了 L-属性定义。

#### 引入继承属性的必要性

让我们思考一个简单的变量声明文法 [@problem_id:3669049]：
$D \to T \ \boldsymbol{id};$
$T \to \text{int} \mid \text{float}$

我们的任务是将类型信息（例如 `INT` 或 `FLOAT`）从非终结符 $T$ 传递给标识符 $\boldsymbol{id}$ 的分析树节点，以便后续步骤（如符号表构建）可以使用。类型信息起源于 $T$ 的子节点（$\text{int}$ 或 $\text{float}$），并通过[综合属性](@entry_id:755750) $T.val$ 传递给 $T$。

现在，我们如何在 $D \to T \ \boldsymbol{id};$ 这条产生式中，将 $T.val$ 的值赋给 $\boldsymbol{id}$ 呢？$\boldsymbol{id}$ 是 $T$ 的**兄弟节点**。[S-属性定义](@entry_id:754469)只允许信息从子节点流向父节点，不允许在兄弟节点之间横向流动。因此，纯粹的 [S-属性定义](@entry_id:754469)无法完成这个任务。

我们需要一种新的属性——**继承属性**（inherited attribute），它允许信息从父节点或兄弟节点流向子节点。

**定义：L-属性定义**

一个语法导向定义如果其每个**继承属性**的计算规则都满足以下条件，则称之为 **L-属性定义**（L-attributed definition）：
对于一个产生式 $A \to X_1 X_2 \dots X_n$，符号 $X_i$ 的一个继承属性的值只能依赖于：
1.  父节点 $A$ 的**继承**属性。
2.  $X_i$ 的**左侧兄弟节点** $X_1, X_2, \dots, X_{i-1}$ 的任意属性（继承或综合）。

“L”代表“Left-to-right”（从左到右）。这个限制确保了属性的计算可以与一次从左到右的分析过程同步进行。L-属性定义可以使用任意的[综合属性](@entry_id:755750)，但对继承属性的依赖关系施加了严格的从左到右的约束。

#### 评估 L-属性定义与依赖图

L-属性的限制保证了我们总能找到一个有效的属性[计算顺序](@entry_id:749112)。对于产生式 $A \to X_1 X_2 \dots X_n$，计算可以在一次**深度优先、从左到右**的遍历中完成。当遍历到节点 $X_i$ 时，其父节点 $A$ 的继承属性和所有左兄弟 $X_1, \dots, X_{i-1}$ 的属性都已经计算完毕，因此 $X_i$ 的继承属性可以被计算。

我们可以通过构建产生式的**[属性依赖图](@entry_id:746573)**来形式化地检查一个 SDD 是否为 L-属性定义 [@problem_id:3669026]。图的节点是产生式中所有符号的属性，如果属性 $\alpha$ 的计算需要属性 $\beta$ 的值，就画一条从 $\beta$到$\alpha$ 的有向边。如果对于任何一个符号 $X_i$ 的继承属性，存在一个从其右兄弟 $X_j$ ($j>i$) 的任何属性出发到达它的路径，那么该定义就**不是** L-属性的。例如，在产生式 $A \to X Y Z$ 中，如果规则包含 $Y.in := g(Z.syn)$，那么就存在从右兄弟 $Z$ 到左兄弟 $Y$ 的信息流，这违反了 L-属性的定义。

### L-属性定义的经典模式与应用

L-属性定义极大地扩展了语法导向翻译的能力，使其能够处理需要上下文信息的复杂任务。

#### 模式 1：从左兄弟向右兄弟传递信息

回到之前的变量声明问题 $D \to T \ \boldsymbol{id};$ [@problem_id:3669049]。我们可以为 $\boldsymbol{id}$ 定义一个继承属性 $type$，其值直接从左兄弟 $T$ 的[综合属性](@entry_id:755750) $val$ 获得：
$D \to T \ \boldsymbol{id};: \quad \boldsymbol{id}.type := T.val$

这条规则完全符合 L-属性的定义，因为右侧符号 $\boldsymbol{id}$ 的继承属性依赖于其左兄弟 $T$ 的属性。更一般地，对于产生式 $A \to B C$，允许 $C$ 的继承属性依赖于 $B$ 的[综合属性](@entry_id:755750)（$C.i := f(B.s)$）是 L-属性定义的一个标志性特征 [@problem_id:3669003]。这要求我们必须先完成对子树 $B$ 的评估以获得 $B.s$，然后才能计算 $C.i$ 并开始对子树 $C$ 的评估。

#### 模式 2：在列表中“穿线”传递属性

L-属性定义最强大的应用之一是在一个列表中“穿线”（threading）传递一个属性，这对于处理作用域和声明至关重要。考虑一个语句列表的文法，我们需要检查变量在使用前是否已声明 [@problem_id:3668937]：
$L \to L_1 \ St \mid St$

为了实现“先声明后使用”的规则，每个语句 $St$ 都需要知道它之前所有语句声明的变量集合。我们可以设计一套属性来传递这个“环境”（如符号表）：
*   $L$ 和 $St$ 都有一个继承属性 $in$（表示进入该节点前的环境）和一个[综合属性](@entry_id:755750) $out$（表示离开该节点后的环境）。

语义规则如下：
*   $S \to L: \quad L.in = \emptyset$ (程序开始时环境为空)
*   $L \to St: \quad St.in = L.in, \quad L.out = St.out$ (列表只有一个语句)
*   $L \to L_1 \ St: \quad L_1.in = L.in, \quad St.in = L_1.out, \quad L.out = St.out$
*   $St \to \text{int } \boldsymbol{id};: \quad St.out = St.in \cup \{\boldsymbol{id}.lexeme\}$ (声明语句向环境中添加新变量)
*   $St \to \boldsymbol{id} = \dots;: \quad \text{check}(\boldsymbol{id}.lexeme \in St.in)$ (使用变量时检查环境)

关键在于规则 $L \to L_1 \ St$。首先，将父节点 $L$ 的输入环境 $L.in$ 传递给左边的子列表 $L_1$。在处理完 $L_1$ 后，它会生成一个更新后的输出环境 $L_1.out$。然后，这个环境被用作右兄弟 $St$ 的输入环境 $St.in$。这个过程就像一根线，将环境从列表的第一个语句“穿”到最后一个语句，完美地实现了从左到右的上下文传递。

#### 模式 3：使用累加器进行计算

L-属性定义也常用于处理那些在 [S-属性定义](@entry_id:754469)下不太自然的计算，尤其是当文法是右递归时。考虑一个右递归的加法文法，并使用 L-属性定义来计算总和 [@problem_id:3668986] [@problem_id:3669032]。
文法：
$E \to T R$
$R \to + T R_1 \mid \epsilon$

我们可以使用一个继承属性 $in$ 作为[累加器](@entry_id:175215)，自左向右累积总和：
*   $T \to \boldsymbol{id}: \quad T.val = \text{lookup}(\boldsymbol{id}.lexeme)$ ([综合属性](@entry_id:755750))
*   $E \to T R: \quad R.in = T.val$ (用第一个数初始化[累加器](@entry_id:175215))
*   $R \to + T R_1: \quad R_1.in = R.in + T.val$ (将当前数加到累加器中，传递给右侧)
*   $R \to \epsilon: \quad R.syn = R.in$ (在列表末尾，将[累加器](@entry_id:175215)的最终值作为[综合属性](@entry_id:755750)返回)
*   $R \to + T R_1: \quad R.syn = R_1.syn$ (将最终结果向上传递)
*   $E \to T R: \quad E.val = R.syn$ (将最终结果赋给根节点)

对于输入 `x + y + z`（假设 $x=10, y=5, z=2$），属性计算流程如下：
1.  $E \to T R$: 计算 $T.val = 10$，然后设置 $R.in = 10$。
2.  $R \to + T R_1$: 计算 $T.val=5$，然后设置 $R_1.in = R.in + T.val = 10 + 5 = 15$。
3.  $R_1 \to + T R_2$: 计算 $T.val=2$，然后设置 $R_2.in = R_1.in + T.val = 15 + 2 = 17$。
4.  $R_2 \to \epsilon$: 到达末尾，将累加值返回，$R_2.syn = R_2.in = 17$。
5.  这个结果 $17$ 逐层作为[综合属性](@entry_id:755750)向上传递，最终 $E.val$ 得到 $17$。

这个模式清晰地展示了继承属性如何将左侧的计算结果（累加和）作为上下文传递给右侧的计算。这种技术与用于消除[左递归](@entry_id:751232)的文法转换（例如，将 $E \to E + T$ 转换为 $E \to T E', E' \to + T E' \mid \epsilon$）结合得非常好，使得原本需要自下而上解析的左结合运算，也能在自顶向下的解析过程中通过 L-属性定义来完成。

### 总结与比较

[S-属性定义](@entry_id:754469)和 L-属性定义为我们提供了两种不同但互补的工具来进行语法导向翻译。

*   **[S-属性定义](@entry_id:754469)**：
    *   **属性**：只使用[综合属性](@entry_id:755750)。
    *   **信息流**：纯粹自下而上。
    *   **评估**：通过[后序遍历](@entry_id:273478)，自然地与自下而上（LR）的[语法分析](@entry_id:267960)相结合。
    *   **适用性**：适用于上下文无关的计算，其中节点的语义是其子节点语义的[简单函数](@entry_id:137521)（如表达式求值、类型构造）。

*   **L-属性定义**：
    *   **属性**：使用[综合属性](@entry_id:755750)和受限的继承属性。
    *   **信息流**：自下而上，并且允许从父节点到子节点、从左兄弟到右兄弟的自上而下和从左到右的信息流。
    *   **评估**：通过一次深度优先、从左到右的遍历，自然地与自顶向下（LL）的[语法分析](@entry_id:267960)相结合。
    *   **适用性**：功能更强大，能够处理需要上下文信息的任务，如类型检查、符号表构建和[代码生成](@entry_id:747434)中的短路求值 [@problem_id:3669002]。

[S-属性定义](@entry_id:754469)是 L-属性定义的一个[真子集](@entry_id:152276)。每个 [S-属性定义](@entry_id:754469)都是一个 L-属性定义（因为它没有任何继承属性，所以没有违反 L-属性的限制），但反之不成立。选择哪种定义取决于待解决的语义任务的内在依赖关系。如果任务的本质是从左到右传递信息，那么 L-属性定义就是必不可少的工具。