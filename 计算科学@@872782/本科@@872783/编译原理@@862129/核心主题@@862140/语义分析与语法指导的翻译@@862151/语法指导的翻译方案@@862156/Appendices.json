{"hands_on_practices": [{"introduction": "本练习将引导你使用语法导向翻译（SDT）进行实时验证，这是一个在解析过程中检查结构正确性的核心任务。我们将设计一个SDT来检查括号和方括号是否平衡且正确嵌套，这是解析器设计中的一个基本问题。通过这个实践，你将学会如何利用属性作为计数器和栈来实施超越上下文无关文法能力的语义规则，并实现早期错误检测。[@problem_id:3673796]", "problem": "语法导向翻译（SDT）的一项核心任务是，在扫描输入时设计属性驱动的动态检查，以验证结构的良构性。这种检查方式必须遵循从左到右的解析顺序，并在违规行为变得不可避免时尽早检测出来。我们从以下基本概念出发：语法导向定义（SDD）将属性与文法符号相关联，而语法导向翻译（SDT）将语义动作嵌入到产生式中，以便在解析过程中计算属性值。在用于预测分析器的 L-属性 SDT 中，继承属性沿产生式从左到右流动，而综合属性则沿解析树向上流动。\n\n考虑一个由上下文无关文法生成的、包含良嵌套和正确匹配的圆括号和方括号的语言。请使用一种预测性的、非左递归的范式，该范式能精确生成所有平衡的圆括号 $\\texttt{(}\\,\\texttt{)}$ 和方括号 $\\texttt{[}\\,\\texttt{]}$ 字符串。你的任务是构建一个 SDT，在单次从左到右的解析过程中，维护开始符号 $S$ 的两个属性作为计数器：$S.\\text{parBalance}$ 用于记录当前未匹配的 $\\texttt{(}$ 的数量，以及 $S.\\text{brackBalance}$ 用于记录当前未匹配的 $\\texttt{[}$ 的数量。此外，为了验证类型正确的嵌套并报告最早的不可避免的错配，还需维护一个后进先出结构 $S.\\text{stack}$ 和一个错误索引 $S.\\text{errorIndex}$。预期的行为是：\n- 在消耗 $\\texttt{(}$ 时增加 $S.\\text{parBalance}$，在消耗 $\\texttt{)}$ 时减少它；对于 $\\texttt{[}$ 和 $\\texttt{]}$，对 $S.\\text{brackBalance}$ 进行类似操作。\n- 在消耗一个开放分隔符时，将其推入 $S.\\text{stack}$；在消耗一个闭合分隔符时，检查 $S.\\text{stack}$ 的栈顶是否是相应的开放分隔符，否则，如果 $S.\\text{errorIndex}$ 尚未设置，则将其设置为当前输入位置；如果匹配，则将其弹出。\n- 如果一次递减操作将使 $S.\\text{parBalance}$ 或 $S.\\text{brackBalance}$ 变为负数，则如果 $S.\\text{errorIndex}$ 尚未设置，将其设置为当前输入位置。\n- 如果解析结束时 $S.\\text{stack}$ 不为空，则不会设置新的错误索引（除非它已在之前被设置），因为第一个不可避免的错配本应在最早违反良构性的闭合符号处被检测到。\n\n你必须：\n1. 为该语言指定一个预测性上下文无关文法 $G$，并用语义动作为其添加注释以实现上述 SDT，将 $S.\\text{parBalance}$、$S.\\text{brackBalance}$、$S.\\text{stack}$ 和 $S.\\text{errorIndex}$ 作为你更新的属性。\n2. 简要说明为什么该文法适用于从左到右的检查，以及为什么该 SDT 能检测到最早的不可避免的错配。\n3. 将你的 SDT 应用于具体输入字符串 $\\texttt{([][([)])]([[]])}$，其中最左边字符的位置为 $1$，后续每个字符的位置依次加 $1$。计算单一诊断量 $E$，其定义为解析后 $S.\\text{errorIndex}$ 的值，并约定如果没有检测到错配，则 $E = 0$。\n\n给出 $E$ 的最终值，为一个整数。无需四舍五入。答案必须是一个数字。", "solution": "用户提供的问题是有效的，因为它科学地基于编译器理论的原理，问题表述清晰且客观。它提供了一个明确、独立的任务，即设计一个语法导向翻译（SDT）方案并将其应用于特定输入。\n\n解决方案按要求分为三部分呈现：SDT 的规范，其属性的论证，以及将其应用于给定输入字符串以计算诊断值 $E$。\n\n### 1. 语法导向翻译（SDT）规范\n\n一个适用于良嵌套圆括号和方括号语言的预测性上下文无关文法 $G$ 是一个右递归文法，它本质上是非左递归的，因此适用于 LL($1$) 预测分析器。设 $S$ 为开始符号，代表一个平衡结构序列。\n\n**文法 $G$：**\n产生式如下：\n$S \\rightarrow ( S ) S$\n$S \\rightarrow [ S ] S$\n$S \\rightarrow \\epsilon$\n\n该文法是 LL($1$) 文法，因为产生式的选择由前看符号唯一确定：\n- 如果前看符号是 '('，使用 $S \\rightarrow ( S ) S$。\n- 如果前看符号是 '['，使用 $S \\rightarrow [ S ] S$。\n- 如果前看符号是 ')'、']' 或输入结束标记 '$'，使用 $S \\rightarrow \\epsilon$。\n\n该 SDT 通过嵌入在解析过程中操作一组全局属性的语义动作来实现。这些属性对应于为开始符号 $S$ 指定的属性：\n- $S.\\text{parBalance}$：一个用于记录开放圆括号的整型计数器。\n- $S.\\text{brackBalance}$：一个用于记录开放方括号的整型计数器。\n- $S.\\text{stack}$：一个后进先出（LIFO）栈，用于追踪开放分隔符的嵌套情况。\n- $S.\\text{errorIndex}$：一个整型变量，用于存储首次检测到错误的位置，初始化为 $0$。\n\n此外，分析器维护一个内部状态变量 $pos$，表示当前在输入字符串中的 1-索引位置。\n\n**初始状态：** 解析开始前，属性初始化如下：\n$S.\\text{parBalance} = 0$\n$S.\\text{brackBalance} = 0$\n$S.\\text{stack} = []$（一个空栈）\n$S.\\text{errorIndex} = 0$\n$pos = 1$\n\n**语义动作：**\n在从左到右解析过程中，消耗一个终结符时执行以下动作。\n\n1.  **在位置 $pos$ 消耗 `(` 时：**\n    - 更新平衡计数：$S.\\text{parBalance} \\leftarrow S.\\text{parBalance} + 1$。\n    - 推入栈：$\\text{push}(S.\\text{stack}, '(')$。\n    - 前进输入指针：$pos \\leftarrow pos + 1$。\n\n2.  **在位置 $pos$ 消耗 `)` 时：**\n    - 检查错误：如果 ($S.\\text{parBalance} \\le 0$) 或 ($\\text{isEmpty}(S.\\text{stack})$) 或 ($\\text{top}(S.\\text{stack}) \\ne '('$)，则：\n        - 如果 $S.\\text{errorIndex} = 0$，则设置 $S.\\text{errorIndex} \\leftarrow pos$。\n    - 如果未发现错误：\n        - 更新平衡计数：$S.\\text{parBalance} \\leftarrow S.\\text{parBalance} - 1$。\n        - 从栈中弹出：$\\text{pop}(S.\\text{stack})$。\n    - 前进输入指针：$pos \\leftarrow pos + 1$。\n\n3.  **在位置 $pos$ 消耗 `[` 时：**\n    - 更新平衡计数：$S.\\text{brackBalance} \\leftarrow S.\\text{brackBalance} + 1$。\n    - 推入栈：$\\text{push}(S.\\text{stack}, '[')$。\n    - 前进输入指针：$pos \\leftarrow pos + 1$。\n\n4.  **在位置 $pos$ 消耗 `]` 时：**\n    - 检查错误：如果 ($S.\\text{brackBalance} \\le 0$) 或 ($\\text{isEmpty}(S.\\text{stack})$) 或 ($\\text{top}(S.\\text{stack}) \\ne '['$)，则：\n        - 如果 $S.\\text{errorIndex} = 0$，则设置 $S.\\text{errorIndex} \\leftarrow pos$。\n    - 如果未发现错误：\n        - 更新平衡计数：$S.\\text{brackBalance} \\leftarrow S.\\text{brackBalance} - 1$。\n        - 从栈中弹出：$\\text{pop}(S.\\text{stack})$。\n    - 前进输入指针：$pos \\leftarrow pos + 1$。\n\n在整个字符串被解析后，$S.\\text{errorIndex}$ 的最终值即为结果 $E$。问题指定，对于未完成的序列（非空栈），在末尾不报告错误，这遵循了“最早不可避免错配”原则。\n\n### 2. 论证\n\n文法 $G$ 适用于从左到右的检查，因为它是一个 LL($1$) 文法。产生式规则的选择完全由当前的前看符号决定，这允许进行确定性的、无需回溯的单遍解析。这种结构非常适合嵌入在处理每个词法单元时动态执行的动作。\n\n该 SDT 能检测到最早的不可避免错配，原因如下：\n- **即时检测：** 对于任何闭合分隔符 `)` 或 `]`，会立即执行有效性检查。该检查验证两个条件：(1) 是否有相应的开放分隔符可以闭合（平衡计数器 $ 0$），以及 (2) 嵌套顺序是否正确（栈上最后一个开放的分隔符与当前闭合的分隔符匹配）。\n- **首次错误原则：** `errorIndex` 仅在当前值为 $0$ 时才被设置。这确保了只有在从左到右扫描过程中检测到的第一个错误的位置被记录下来。任何后续的错误在设置索引时都会被忽略。\n- **不可避免的错配：** 当良构性规则被破坏的那一刻，错误就变得“不可避免”。例如，在字符串前缀 $\\texttt{([}$ 中，如果接下来的字符是 `)`，那么该字符串将变得无法修复地格式错误。SDT 会在 `)` 的位置正确地标记此错误。字符串末尾未闭合的分隔符（例如，在 $\\texttt{([}$ 中）不被视为“最早”的不可避免错误，因为直到字符串结束，一个有效的续写仍然是可能的。指定的 SDT 逻辑通过在解析结束时不对非空栈设置错误索引来正确反映这一点。\n\n### 3. 应用于输入字符串\n\n任务是将 SDT 应用于输入字符串 $\\texttt{([][([)])]([[]])}$，并找出 $S.\\text{errorIndex}$ 的最终值。\n\n**输入字符串：** $\\texttt{([][([)])]([[]])}$\n**初始状态：** $S.\\text{parBalance} = 0$, $S.\\text{brackBalance} = 0$, $S.\\text{stack} = []$, $S.\\text{errorIndex} = 0$。\n\n下表追踪了分析器逐字符消耗输入字符串时各属性的状态（栈顶显示在右侧）。\n\n| 位置 | 字符 | 动作 | $S.\\text{parBalance}$ | $S.\\text{brackBalance}$ | $S.\\text{stack}$ | $S.\\text{errorIndex}$ |\n|:---:|:----:|:---|:---:|:---:|:---|:---:|\n| 1 | `(`   | 推入 `(`             | 1 | 0 | `['(']` | 0 |\n| 2 | `[`   | 推入 `[`             | 1 | 1 | `['(', '[']` | 0 |\n| 3 | `]`   | 弹出 `[` (匹配)      | 1 | 0 | `['(']` | 0 |\n| 4 | `[`   | 推入 `[`             | 1 | 1 | `['(', '[']` | 0 |\n| 5 | `(`   | 推入 `(`             | 2 | 1 | `['(', '[', '(']` | 0 |\n| 6 | `[`   | 推入 `[`             | 2 | 2 | `['(', '[', '(', '[']` | 0 |\n| **7** | `)`   | **不匹配！** 栈顶为 `[`。设置 $S.\\text{errorIndex}$。 | 2 | 2 | `['(', '[', '(', '[']` | **7** |\n| 8 | `]`   | 弹出 `[` (匹配)      | 2 | 1 | `['(', '[', '(']` | 7 |\n| 9 | `)`   | 弹出 `(` (匹配)      | 1 | 1 | `['(', '[']` | 7 |\n| 10 | `]`  | 弹出 `[` (匹配)      | 1 | 0 | `['(']` | 7 |\n| 11 | `(`  | 推入 `(`             | 2 | 0 | `['(', '(']` | 7 |\n| 12 | `[`  | 推入 `[`             | 2 | 1 | `['(', '(', '[']` | 7 |\n| 13 | `[`  | 推入 `[`             | 2 | 2 | `['(', '(', '[', '[']` | 7 |\n| 14 | `]`  | 弹出 `[` (匹配)      | 2 | 1 | `['(', '(', '[']` | 7 |\n| 15 | `]`  | 弹出 `[` (匹配)      | 2 | 0 | `['(', '(']` | 7 |\n| 16 | `)`  | 弹出 `(` (匹配)      | 1 | 0 | `['(']` | 7 |\n| 17 | `)`  | 弹出 `(` (匹配)      | 0 | 0 | $[]$ (空) | 7 |\n\n在位置 $pos=7$ 处，输入字符是 `)`。栈顶是 `[`。这是一个类型不匹配。根据 `)` 的语义动作，满足了错误条件。由于 $S.\\text{errorIndex}$ 是 $0$，它被更新为当前位置 $7$。分析器继续处理字符串的其余部分，但 $S.\\text{errorIndex}$ 的值不再改变。\n\n在整个字符串被解析后，$S.\\text{errorIndex}$ 的最终值为 $7$。因此，诊断量 $E$ 是 $7$。", "answer": "$$\\boxed{7}$$", "id": "3673796"}, {"introduction": "在掌握了验证技术的基础上，我们进入编译的核心任务：翻译。本练习将要求你创建一个SDT，将算术表达式转换为一个简单栈式机的指令序列。这个过程将演示如何利用综合属性，根据文法结构（如此处的左结合性）逐步构建目标代码，这是从源代码生成可执行代码的关键一步。[@problem_id:3673805]", "problem": "考虑用于左结合乘法表达式的上下文无关文法，其由 $E \\rightarrow E * T \\mid T$ 和 $T \\rightarrow \\mathrm{id}$ 给出。设计一个语法导向翻译（SDT）方案，该方案为每个非终结符 $X \\in \\{E, T\\}$ 使用一个综合属性 $X.\\mathrm{code}$，以生成用于在栈式机上求值表达式的指令序列。该栈式机支持指令 $\\mathrm{LOAD}(x)$（将标识符 $x$ 的值压入栈）和 $\\mathrm{MUL}$（弹出栈顶的两个值 $r_{2}$ 和 $r_{1}$，计算 $r_{1} \\times r_{2}$，并将结果压入栈）。所有标识符都根据一个环境映射 $\\sigma$ 进行求值，其中 $\\sigma(x)$ 是绑定到标识符 $x$ 的实数值。\n\n从上下文无关文法的基础定义和给定栈式机的操作语义出发，提出一个能够正确实施文法所定义的左结合求值，并对 $E.\\mathrm{code}$ 进行标注以使生成的代码能正确地进行压栈和弹栈操作的 SDT。\n\n然后，将您的 SDT 应用于输入表达式 $w * x * y * z$，其环境映射为 $\\sigma(w) = \\frac{6}{5}$，$\\sigma(x) = -3$，$\\sigma(y) = \\frac{7}{5}$，以及 $\\sigma(z) = 2$。生成代码后，根据指定的语义在栈式机上概念性地执行它，并计算出最终栈顶值的精确值。无需四舍五入；请用精确的分数或小数形式表示您的答案，不要使用百分号。", "solution": "本题要求为一个给定的上下文无关文法设计一个语法导向翻译（SDT）方案，将此 SDT 应用于一个特定的输入表达式，并通过概念性地执行生成的代码来找出最终的数值结果。\n\n### 问题验证\n首先，对问题陈述进行验证。\n\n**1. 提取的已知条件：**\n*   **文法：** $E \\rightarrow E * T \\mid T$ 及 $T \\rightarrow \\mathrm{id}$。\n*   **结合性：** 左结合乘法。\n*   **属性：** 为每个非终结符 $X \\in \\{E, T\\}$ 设定的一个综合属性 $X.\\text{code}$。该属性是一个指令序列。\n*   **目标机：** 栈式机。\n*   **指令：**\n    *   $\\mathrm{LOAD}(x)$：将标识符 $x$ 的值压入栈。\n    *   $\\mathrm{MUL}$：弹出栈顶的两个值，$r_2$（栈顶）和 $r_1$（次栈顶），计算 $r_1 \\times r_2$，并将结果压入栈。\n*   **环境：** $\\sigma$，一个从标识符到实数值的映射。\n*   **输入表达式：** $w * x * y * z$。\n*   **特定环境：** $\\sigma(w) = \\frac{6}{5}$，$\\sigma(x) = -3$，$\\sigma(y) = \\frac{7}{5}$，以及 $\\sigma(z) = 2$。\n*   **目标：** 设计 SDT，为输入生成代码，执行代码，并找出最终值。\n\n**2. 验证结论：**\n该问题是 **有效的**。在编译器理论的既定领域内，这是一个定义明确且自洽的问题。文法、机器语义和翻译任务都得到了清晰和形式化的定义。不存在科学或逻辑上的矛盾，没有缺失信息，也没有主观因素。该问题是语法导向翻译中的一个标准练习。\n\n### 第一部分：语法导向翻译（SDT）方案的设计\n\n目标是为文法中的每个产生式定义语义规则，以生成一个栈式机指令序列。非终结符 $X$ 的属性 $X.\\text{code}$ 将存储用于计算由 $X$ 派生的表达式并将结果留在栈顶的指令序列。我们用 $||$ 表示指令序列的连接。\n\n**产生式 1：$T \\rightarrow \\mathrm{id}$**\n这个产生式代表了表达式的基本情况，即单个标识符。为对其求值，我们必须将其值加载到栈上。词法单元 $\\mathrm{id}$ 的词法值（名称）可通过一个属性获得，我们将其表示为 $\\mathrm{id}.\\text{lexval}$。\n语义规则是：\n$T.\\text{code} := \"\\mathrm{LOAD}(\" \\ || \\ \\mathrm{id}.\\text{lexval} \\ || \\ \")\"$\n\n**产生式 2：$E \\rightarrow T$**\n这个产生式处理只包含单个项的表达式。计算此类表达式的代码就是计算该项本身的代码。\n语义规则是：\n$E.\\text{code} := T.\\text{code}$\n\n**产生式 3：$E \\rightarrow E_1 * T$**\n这是捕捉左结合性的左递归产生式。为了计算 $E_1 * T$ 形式的表达式，我们必须首先计算左子表达式 $E_1$，它会将其结果留在栈上。然后，我们计算右子表达式 $T$，它会将其结果放在 $E_1$ 结果的上方。最后，我们执行乘法指令，该指令弹出两个结果并压入它们的乘积。\n综合属性的语义规则在自底向上解析期间应用。$E_1$ 和 $T$ 的代码此时已经生成。因此，我们可以将它们连接起来。\n语义规则是：\n$E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$\n\n完整的 SDT 总结如下：\n| 产生式                | 语义规则                                              |\n|------------------------|-------------------------------------------------------|\n| $T \\rightarrow \\mathrm{id}$  | $T.\\text{code} := \"\\mathrm{LOAD}(\\mathrm{id}.\\text{lexval})\"$ |\n| $E \\rightarrow T$        | $E.\\text{code} := T.\\text{code}$                      |\n| $E \\rightarrow E_1 * T$  | $E.\\text{code} := E_1.\\text{code} \\ || \\ T.\\text{code} \\ || \\ \"\\mathrm{MUL}\"$ |\n\n### 第二部分：为 $w * x * y * z$ 生成代码\n\n我们将 SDT 应用于输入字符串 $w * x * y * z$。左递归文法自然地导向左结合解析。该表达式被解析为 $(((w * x) * y) * z)$。我们可以通过模拟自底向上解析（或标注分析树）来追踪代码生成过程。\n\n1.  **解析 $w$**:\n    *   $T \\rightarrow \\mathrm{id}_w \\implies T.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n    *   $E \\rightarrow T \\implies E_1.\\text{code} = \"\\mathrm{LOAD}(w)\"$\n\n2.  **解析 $w * x$**: 这对应于产生式 $E \\rightarrow E_1 * T_x$。\n    *   对于子表达式 $x$：$T_x \\rightarrow \\mathrm{id}_x \\implies T_x.\\text{code} = \"\\mathrm{LOAD}(x)\"$\n    *   对于表达式 $w * x$：$E_2.\\text{code} = E_1.\\text{code} \\ || \\ T_x.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL}\"$\n\n3.  **解析 $(w * x) * y$**: 这对应于产生式 $E \\rightarrow E_2 * T_y$。\n    *   对于子表达式 $y$：$T_y \\rightarrow \\mathrm{id}_y \\implies T_y.\\text{code} = \"\\mathrm{LOAD}(y)\"$\n    *   对于表达式 $(w * x) * y$：$E_3.\\text{code} = E_2.\\text{code} \\ || \\ T_y.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL}\"$\n\n4.  **解析 $((w * x) * y) * z$**: 这对应于产生式 $E \\rightarrow E_3 * T_z$。\n    *   对于子表达式 $z$：$T_z \\rightarrow \\mathrm{id}_z \\implies T_z.\\text{code} = \"\\mathrm{LOAD}(z)\"$\n    *   对于完整表达式：$E.\\text{code} = E_3.\\text{code} \\ || \\ T_z.\\text{code} \\ || \\ \"\\mathrm{MUL}\" = \"\\mathrm{LOAD}(w) \\ \\mathrm{LOAD}(x) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(y) \\ \\mathrm{MUL} \\ \\mathrm{LOAD}(z) \\ \\mathrm{MUL}\"$\n\n最终生成的指令序列是：\n$\\mathrm{LOAD}(w)$, $\\mathrm{LOAD}(x)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(y)$, $\\mathrm{MUL}$, $\\mathrm{LOAD}(z)$, $\\mathrm{MUL}$\n\n### 第三部分：概念性执行与最终值计算\n\n我们在给定环境下执行此代码序列：$\\sigma(w) = \\frac{6}{5}$，$\\sigma(x) = -3$，$\\sigma(y) = \\frac{7}{5}$，$\\sigma(z) = 2$。\n栈由列表 `[...]` 表示，栈顶在右侧。\n\n1.  **初始栈：** `[]`\n2.  **$\\mathrm{LOAD}(w)$：** `[ $\\frac{6}{5}$ ]`\n3.  **$\\mathrm{LOAD}(x)$：** `[ $\\frac{6}{5}$, $-3$ ]`\n4.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = -3$。\n    *   弹出 $r_1 = \\frac{6}{5}$。\n    *   计算 $r_1 \\times r_2 = \\frac{6}{5} \\times (-3) = -\\frac{18}{5}$。\n    *   压入结果。栈：`[ $-\\frac{18}{5}$ ]`\n5.  **$\\mathrm{LOAD}(y)$：** `[ $-\\frac{18}{5}$, $\\frac{7}{5}$ ]`\n6.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = \\frac{7}{5}$。\n    *   弹出 $r_1 = -\\frac{18}{5}$。\n    *   计算 $r_1 \\times r_2 = (-\\frac{18}{5}) \\times (\\frac{7}{5}) = -\\frac{126}{25}$。\n    *   压入结果。栈：`[ $-\\frac{126}{25}$ ]`\n7.  **$\\mathrm{LOAD}(z)$：** `[ $-\\frac{126}{25}$, $2$ ]`\n8.  **$\\mathrm{MUL}$：**\n    *   弹出 $r_2 = 2$。\n    *   弹出 $r_1 = -\\frac{126}{25}$。\n    *   计算 $r_1 \\times r_2 = (-\\frac{126}{25}) \\times 2 = -\\frac{252}{25}$。\n    *   压入结果。栈：`[ $-\\frac{252}{25}$ ]`\n\n执行结束时，栈顶的值为 $-\\frac{252}{25}$。该值也可以表示为 $-10.08$。根据题目要求，使用精确的分数形式是合适的。\n最终计算：\n$$\n\\left( \\left( \\frac{6}{5} \\times (-3) \\right) \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{18}{5} \\times \\frac{7}{5} \\right) \\times 2 = \\left( -\\frac{126}{25} \\right) \\times 2 = -\\frac{252}{25}\n$$", "answer": "$$\\boxed{-\\frac{252}{25}}$$", "id": "3673805"}, {"introduction": "最后的这个练习将挑战一个更高级的主题：控制流结构的翻译。我们将为三元条件运算符（`? :`）设计一个SDT，利用一种称为“回填”（backpatching）的技术来生成高效的短路求值代码。此练习将引入 `truelist` 和 `falselist` 这两个强大的属性概念，用于管理和解析跳转目标，这对于编译if-then-else和循环等语句至关重要。[@problem_id:3673774]", "problem": "考虑一个用于处理带三元条件运算符的表达式的编译器片段。该语言具有布尔关系原子和三元运算符，其写法为 $E \\to E_1 \\; ? \\; E_2 \\; : \\; E_3$，其中 $E_1$、$E_2$ 和 $E_3$ 是布尔表达式。该编译器使用语法制导翻译 (SDT) 来生成带有回填（backpatching）的短路求值中间表示 (IR)。每个关系原子 $id \\;\\text{relop}\\; id$ 的 IR 均以标准的布尔短路求值风格生成，包含两个四元式：一个 $\\text{if}$-条件跳转和一个无条件跳转，每个跳转都带有一个临时的目标字段，将通过回填来填充。编译器维护一个全局计数器 $nextquad$，指示下一个要生成的四元式的索引。\n\n你需要为产生式 $E \\to E_1 \\; ? \\; E_2 \\; : \\; E_3$ 设计 SDT，使用属性 $E.\\text{truelist}$ 和 $E.\\text{falselist}$（它们是未解析跳转目标的列表），并结合适当的标记非终结符来捕获 $E_2$ 和 $E_3$ 的起始点，以及回填操作。该 SDT 必须实现短路求值语义：如果 $E_1$ 求值为真，控制流将转到 $E_2$ 代码的开头；如果 $E_1$ 求值为假，控制流将转到 $E_3$ 代码的开头；最终的表达式 $E$ 根据所选分支求值为真或假，并应携带其总体的真假情况合并后的回填列表。\n\n设计完 SDT 后，将其应用于以下具体的输入表达式：\n$$(a_1  b_1) \\; ? \\; \\big((c_2 \\neq d_2) \\; ? \\; (p_3 \\le q_3) \\; : \\; (r_4 = s_4)\\big) \\; : \\; \\big((t_5  u_5) \\; ? \\; (v_6 \\ge w_6) \\; : \\; (x_7  y_7)\\big).$$\n\n假设：\n- 为任何关系原子 $X \\;\\text{relop}\\; Y$ 生成的唯一代码是布尔短路求值风格的两个四元式，一个 $\\text{if}$-条件跳转和一个无条件 $\\text{goto}$，两者的目标都带有占位符，将通过回填来解析。\n- 标记非终结符或三元产生式的 SDT 动作不会生成额外的四元式；回填仅填充目标，不生成新的四元式。\n- 全局计数器的初始值为 $nextquad = 30$。\n\n在这些假设下，确定给定表达式完全翻译和回填后 $nextquad$ 的最终值。请提供一个精确的整数作为答案。不要包含任何单位。如果需要四舍五入，请保留四位有效数字，但此处期望的是一个精确的整数。", "solution": "该问题陈述已经过严格验证，被认为是编译器原理领域中一个有效、独立且定义明确的问题，具体涉及布尔表达式的语法制导翻译。它在科学上基于成熟的编译器理论，表述客观，并提供了足够的信息来推导出唯一的解决方案。\n\n核心任务是确定全局计数器 $\\text{nextquad}$ 的最终值，该计数器跟踪下一个要生成的中间表示 (IR) 四元式的索引。根据问题陈述，$\\text{nextquad}$ 的值仅在生成代码时增加。问题明确地描述了生成代码的条件，并附带两个关键约束：\n1. 每个形式为 $id \\;\\text{relop}\\; id$ 的关系原子的 IR 恰好由两个四元式组成。\n2. 标记非终结符或与三元运算符产生式相关的语义动作不会生成额外的四元式。\n\n在计算 $\\text{nextquad}$ 的最终值之前，为三元产生式 $E \\to E_1 \\; ? \\; E_2 \\; : \\; E_3$ 设计一个合适的语法制导翻译 (SDT) 是有益的。这个设计将确认控制流逻辑可以仅通过回填来实现，而无需生成任何新的四元式，从而遵守了问题的约束。\n\n让我们在产生式中引入标记非终结符 $M_1$ 和 $M_2$，以分别捕获 $E_2$ 和 $E_3$ 代码的起始地址。修改后的产生式为 $E \\to E_1 \\; ? \\; M_1 \\; E_2 \\; : \\; M_2 \\; E_3$。相关的语义规则如下：\n\n标记 $M$ 的综合属性 $M.\\text{quad}$ 将存储其求值时的 $\\text{nextquad}$ 值。标记的语义规则是：\n$M \\to \\epsilon \\quad \\{ M.\\text{quad} := \\text{nextquad}; \\}$\n\n主产生式的语义规则是：\n$E \\to E_1 \\; ? \\; M_1 \\; E_2 \\; : \\; M_2 \\; E_3 \\quad \\{$\n$\\quad \\text{backpatch}(E_1.\\text{truelist}, M_1.\\text{quad});$\n$\\quad \\text{backpatch}(E_1.\\text{falselist}, M_2.\\text{quad});$\n$\\quad E.\\text{truelist} := \\text{merge}(E_2.\\text{truelist}, E_3.\\text{truelist});$\n$\\quad E.\\text{falselist} := \\text{merge}(E_2.\\text{falselist}, E_3.\\text{falselist});$\n$\\}$\n\n这里，$\\text{backpatch}(L, t)$ 将列表 $L$ 中所有跳转的目标设置为四元式索引 $t$。函数 $\\text{merge}(L_1, L_2)$ 连接两个跳转目标列表。此 SDT 方案正确地实现了三元运算符的短路求值逻辑。如果 $E_1$ 为真，控制流跳转到 $E_2$ 代码的起始处（地址 $M_1.\\text{quad}$）。如果 $E_1$ 为假，控制流跳转到 $E_3$ 代码的起始处（地址 $M_2.\\text{quad}$）。最终表达式 $E$ 的真假取决于 $E_2$ 和 $E_3$ 的结果，因此它们各自的真列表和假列表被合并。关键是，这些语义动作都不涉及生成新的四元式；它们只操作列表并填充已生成四元式中的目标地址。这证实了问题中只有关系原子生成代码这一约束的有效性。\n\n基于此，$\\text{nextquad}$ 最终值的计算简化为一个计数问题。生成的四元式总数完全由输入表达式中关系原子的数量决定。嵌套三元运算符的复杂结构影响回填逻辑，但不影响生成代码的总量。\n\n给定的输入表达式是：\n$$(a_1  b_1) \\; ? \\; \\big((c_2 \\neq d_2) \\; ? \\; (p_3 \\le q_3) \\; : \\; (r_4 = s_4)\\big) \\; : \\; \\big((t_5  u_5) \\; ? \\; (v_6 \\ge w_6) \\; : \\; (x_7  y_7)\\big).$$\n\n我们必须识别并计算此表达式中每个不同的关系原子。这些原子是表达式抽象语法树的叶节点。它们是：\n1. $a_1  b_1$\n2. $c_2 \\neq d_2$\n3. $p_3 \\le q_3$\n4. $r_4 = s_4$\n5. $t_5  u_5$\n6. $v_6 \\ge w_6$\n7. $x_7  y_7$\n\n总共有 $7$ 个关系原子。\n\n根据问题陈述，每个关系原子恰好生成 $2$ 个四元式。\n因此，生成的四元式总数，我们称之为 $N_{quads}$，是：\n$$N_{quads} = (\\text{关系原子数}) \\times (\\text{每个原子的四元式数})$$\n$$N_{quads} = 7 \\times 2 = 14$$\n\n全局计数器的初始值给定为 $\\text{nextquad}_{initial} = 30$。该计数器指示下一个要写入的四元式的索引。生成 $14$ 个四元式将消耗从 $30$ 到 $30 + 14 - 1 = 43$ 的索引。在索引 $43$ 处写入最后一个四元式后，计数器将递增以指向下一个可用位置。\n\n计数器的最终值 $\\text{nextquad}_{final}$ 计算如下：\n$$\\text{nextquad}_{final} = \\text{nextquad}_{initial} + N_{quads}$$\n$$\\text{nextquad}_{final} = 30 + 14 = 44$$\n\n表达式完全翻译后，$\\text{nextquad}$ 的最终值将是 $44$。", "answer": "$$\\boxed{44}$$", "id": "3673774"}]}