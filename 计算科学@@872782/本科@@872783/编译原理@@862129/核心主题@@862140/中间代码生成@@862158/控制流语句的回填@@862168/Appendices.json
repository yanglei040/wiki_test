{"hands_on_practices": [{"introduction": "本章的第一个练习是一个基础性的实践。它好比给你一块缺少部分连线的电路板和一张电路图，你的任务是根据 `if-then-else` 和 `while` 语句的逻辑（特别是短路求值逻辑 $\\land$ 和 $\\lor$）来正确地连接各个组件（代码块）。这个练习直接考察了回填技术的核心机制——如何解析和填充前向跳转指令的目标地址。[@problem_id:3623495]", "problem": "考虑一个编译器前端，它为结构化控制流构造生成一种三地址中间表示 (IR)，形式为四元式。这些四元式从 $1$ 开始索引，使用条件分支和无条件分支。其跳转目标由占位符符号 $?$ 表示，必须通过回填来解析。该 IR 遵循以下被广泛接受的基础原则：\n\n- 逻辑合取 ($\\land$) 和逻辑析取 ($\\lor$) 的短路语义：对于 $E_{1} \\land E_{2}$，如果 $E_{1}$ 为假，则整个表达式为假；否则对 $E_{2}$ 求值。对于 $E_{1} \\lor E_{2}$，如果 $E_{1}$ 为真，则整个表达式为真；否则对 $E_{2}$ 求值。\n- 回填：布尔表达式被编译以生成对应于真和假结果的未解析跳转列表，一旦这些目标（then部分、else部分、循环体或出口）的入口点已知，就将这些跳转回填。\n- 结构化控制流：对于 $\\text{if}$–$\\text{then}$–$\\text{else}$ 语句，条件的真出口指向then块，假出口指向else块；then块以跳转到条件语句后的汇合点结束。对于 $\\text{while}$ 循环，条件在循环头处重新求值；真出口指向循环体，假出口指向循环后的出口点；循环体以跳转回循环头结束。\n\n下面的 IR 四元式流使用占位符 $?$ 表示必须回填的未解析分支目标。它编码的程序结构是一个 $\\text{if}$–$\\text{then}$–$\\text{else}$ 语句，后跟一个赋值语句，然后是一个带有短路条件的 $\\text{while}$ 循环：\n\n- $1$: if $a  b$ goto $?$\n- $2$: goto $?$\n- $3$: if $c \\neq d$ goto $?$\n- $4$: goto $?$\n- $5$: $x := x + 1$\n- $6$: goto $?$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p \\le q$ goto $?$\n- $10$: goto $?$\n- $11$: if $r  s$ goto $?$\n- $12$: goto $?$\n- $13$: $y := y + 2$\n- $14$: goto $?$\n- $15$: $\\text{noop}$\n\n任务：\n\n1. 仅使用上述基础原则，确定每个占位符 $?$ 的最终回填目标，以使 IR 正确实现：\n   - 一个 $\\text{if}$ 条件 $(a  b) \\land (c \\neq d)$，其then块在四元式 $5$ 处，else块在四元式 $7$ 处，条件语句后的汇合点在四元式 $8$ 处。\n   - 一个 $\\text{while}$ 循环，其条件为 $(p \\le q) \\lor (r  s)$，循环体从四元式 $13$ 开始，循环头在四元式 $9$ 处，出口点在四元式 $15$ 处。\n2. 枚举被回填的四元式索引集合。\n3. 设校验和 $\\Sigma$ 定义为\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i},\n$$\n其中 $P$ 是被回填的四元式索引集合，$t_{i}$ 是四元式 $i$ 的最终回填目标索引。精确计算 $\\Sigma$ 的整数值。无需四舍五入。仅报告 $\\Sigma$ 的值作为你的最终答案。\n\n你的回答必须包括回填后完整的四元式数组和对被回填索引的清晰枚举，但最终答案必须是上面指定的单个数字。", "solution": "我们从所述的基础原则开始：逻辑合取和逻辑析取的短路求值，以及 $\\text{if}$–$\\text{then}$–$\\text{else}$ 和 $\\text{while}$ 构造的结构规则，并使用回填来解析条件和无条件跳转目标，一旦相应的块入口或出口点已知。\n\n首先，我们分析 $\\text{if}$–$\\text{then}$–$\\text{else}$ 部分。条件是 $(a  b) \\land (c \\neq d)$，其then块在四元式 $5$ 处，else块在四元式 $7$ 处，条件语句后的汇合点在四元式 $8$ 处。\n\n- 对于短路语义下的逻辑合取 $E_{1} \\land E_{2}$：\n  - 如果 $E_{1}$ 为假，整个条件为假，控制转移到else块。\n  - 如果 $E_{1}$ 为真，继续对 $E_{2}$ 求值。\n  - 如果 $E_{2}$ 为真，整个条件为真，控制转移到then块。\n  - 如果 $E_{2}$ 为假，控制转移到else块。\n\n将此应用于四元式：\n\n- 四元式 $1$ 是对 $E_{1}$ 的测试：if $a  b$ goto $?$。\n  - 四元式 $1$ 的真分支应该转到四元式 $3$ 处对 $E_{2}$ 的求值，所以我们将四元式 $1$ 的目标回填为 $3$。\n- 四元式 $2$ 是测试 $E_{1}$ 后的假分支：goto $?$。\n  - 假结果应该转到四元式 $7$ 处的else块，所以我们将四元式 $2$ 的目标回填为 $7$。\n- 四元式 $3$ 是对 $E_{2}$ 的测试：if $c \\neq d$ goto $?$。\n  - 真分支应该转到四元式 $5$ 处的then块，所以我们将四元式 $3$ 的目标回填为 $5$。\n- 四元式 $4$ 是测试 $E_{2}$ 后的假分支：goto $?$。\n  - 假结果应该转到四元式 $7$ 处的else块，所以我们将四元式 $4$ 的目标回填为 $7$。\n- 四元式 $5$ 是then块体：$x := x + 1$。\n- 四元式 $6$ 是到汇合点的跳转：goto $?$。\n  - 执行完then块后，我们必须跳过else块，转到四元式 $8$ 处的汇合点，所以我们将四元式 $6$ 的目标回填为 $8$。\n- 四元式 $7$ 是else块体：$x := x - 1$。\n- 四元式 $8$ 是条件语句后的汇合点：$y := 0$。\n\n接下来，我们分析 $\\text{while}$ 循环，其条件为 $(p \\le q) \\lor (r  s)$，循环体从四元式 $13$ 开始，循环头在四元式 $9$ 处，出口在四元式 $15$ 处。\n\n- 对于短路语义下的逻辑析取 $E_{1} \\lor E_{2}$：\n  - 如果 $E_{1}$ 为真，整个条件为真，控制转移到循环体。\n  - 如果 $E_{1}$ 为假，继续对 $E_{2}$ 求值。\n  - 如果 $E_{2}$ 为真，转移到循环体。\n  - 如果 $E_{2}$ 为假，转移到循环出口。\n\n将此应用于四元式：\n\n- 四元式 $9$ 是对 $E_{1}$ 的测试：if $p \\le q$ goto $?$。\n  - 真分支转到四元式 $13$ 处的循环体，所以我们将四元式 $9$ 的目标回填为 $13$。\n- 四元式 $10$ 是在 $E_{1}$ 为假时转移去求值 $E_{2}$ 的跳转：goto $?$。\n  - 它应该转到四元式 $11$ 处的下一个测试，所以我们将四元式 $10$ 的目标回填为 $11$。\n- 四元式 $11$ 是对 $E_{2}$ 的测试：if $r  s$ goto $?$。\n  - 真分支转到四元式 $13$ 处的循环体，所以我们将四元式 $11$ 的目标回填为 $13$。\n- 四元式 $12$ 是测试 $E_{2}$ 后的假分支：goto $?$。\n  - 假结果退出循环，所以我们将四元式 $12$ 的目标回填为 $15$。\n- 四元式 $13$ 是循环体：$y := y + 2$。\n- 四元式 $14$ 是循环的返回边：goto $?$。\n  - 它必须将控制权转回四元式 $9$ 处的循环头以重新求值条件，所以我们将四元式 $14$ 的目标回填为 $9$。\n- 四元式 $15$ 是循环出口点：$\\text{noop}$。\n\n因此，回填后完整的四元式数组是：\n\n- $1$: if $a  b$ goto $3$\n- $2$: goto $7$\n- $3$: if $c \\neq d$ goto $5$\n- $4$: goto $7$\n- $5$: $x := x + 1$\n- $6$: goto $8$\n- $7$: $x := x - 1$\n- $8$: $y := 0$\n- $9$: if $p \\le q$ goto $13$\n- $10$: goto $11$\n- $11$: if $r  s$ goto $13$\n- $12$: goto $15$\n- $13$: $y := y + 2$\n- $14$: goto $9$\n- $15$: $\\text{noop}$\n\n被回填的四元式索引集合为 $P = \\{1, 2, 3, 4, 6, 9, 10, 11, 12, 14\\}$，对应的回填目标 $\\{t_{i}\\}$ 是：\n- $t_{1} = 3$\n- $t_{2} = 7$\n- $t_{3} = 5$\n- $t_{4} = 7$\n- $t_{6} = 8$\n- $t_{9} = 13$\n- $t_{10} = 11$\n- $t_{11} = 13$\n- $t_{12} = 15$\n- $t_{14} = 9$\n\n我们现在计算校验和\n$$\n\\Sigma \\;=\\; \\sum_{i \\in P} i \\times t_{i}\n\\;=\\;\n(1 \\times 3)\n+ (2 \\times 7)\n+ (3 \\times 5)\n+ (4 \\times 7)\n+ (6 \\times 8)\n+ (9 \\times 13)\n+ (10 \\times 11)\n+ (11 \\times 13)\n+ (12 \\times 15)\n+ (14 \\times 9).\n$$\n逐项计算：\n- $1 \\times 3 = 3$\n- $2 \\times 7 = 14$\n- $3 \\times 5 = 15$\n- $4 \\times 7 = 28$\n- $6 \\times 8 = 48$\n- $9 \\times 13 = 117$\n- $10 \\times 11 = 110$\n- $11 \\times 13 = 143$\n- $12 \\times 15 = 180$\n- $14 \\times 9 = 126$\n\n求和，\n$$\n\\Sigma = 3 + 14 + 15 + 28 + 48 + 117 + 110 + 143 + 180 + 126 = 784.\n$$\n因此，所需的校验和是 $784$。", "answer": "$$\\boxed{784}$$", "id": "3623495"}, {"introduction": "在掌握了基础之后，我们来挑战一个更复杂的场景。现实世界的程序中充满了嵌套结构，本练习就模拟了这种情况，要求处理嵌套循环和 `break` 语句。这个练习将重点展示回填如何处理作用域，特别是像 `break` 这样需要跳出当前循环，但不能影响外层循环的语句。你需要仔细追踪编译器的状态（如 `nextquad` 计数器）来理解目标地址是如何在代码生成过程中动态确定的。[@problem_id:3623441]", "problem": "考虑一个编译器中的控制流语句翻译方案，该方案将三地址码（Three-Address Code (TAC)）生成到一个由全局计数器 $nextquad$ 索引的线性四元式序列中。该编译器使用回填方法：布尔表达式产生前向跳转列表（$truelist$ 和 $falselist$）；循环维护一个 $breaklist$，用于捕获从 $break$ 语句到循环出口的未回填跳转。以下基本事实定义了推导的基础：\n\n- 关系条件的布尔测试被翻译成两个 TAC 四元式：一个用于真分支的条件跳转和一个用于假分支的无条件跳转。因此，每个布尔表达式 $E$ 贡献 $2$ 个四元式，并生成包含待后续回填的已生成跳转索引的 $E.truelist$ 和 $E.falselist$。\n- 对于形式为 $while\\ (B)\\ do\\ S$ 的 $while$ 语句，翻译方案如下：\n  1. 在生成 $B$ 之前，记录 $M$，定义为 $M = nextquad$。\n  2. 翻译 $B$ 以产生 $B.truelist$ 和 $B.falselist$。\n  3. 在 $S$ 的开头记录 $N = nextquad$，并将 $B.truelist$ 回填到 $N$。\n  4. 翻译 $S$。\n  5. 生成一条回边 $goto\\ M$。\n  6. 在生成回边后，令 $L = nextquad$；将 $B.falselist$ 和循环的 $breaklist$ 回填到 $L$。\n- 对于 $if\\ (B)\\ then\\ S_1\\ else\\ S_2$ 语句，方案如下：\n  1. 翻译 $B$，产生 $B.truelist$ 和 $B.falselist$。\n  2. 记录 $N_{then} = nextquad$ 并将 $B.truelist$ 回填到 $N_{then}$；翻译 $S_1$。\n  3. 生成 $goto\\ \\_\\_\\_$（一个 TAC 四元式）以跳过 $S_2$，并将其索引收集到一个 $nextlist$ 中，以便后续回填到“if之后”的汇合点。\n  4. 记录 $N_{else} = nextquad$ 并将 $B.falselist$ 回填到 $N_{else}$；翻译 $S_2$。\n  5. 在 $S_2$ 之后，令 $J = nextquad$；将步骤 3 中的 $nextlist$ 回填到 $J$。\n- 循环内的 $break$ 会生成 $1$ 个 TAC 四元式 $goto\\ \\_\\_\\_$，并将其索引附加到最内层嵌套循环的 $breaklist$ 中。该 $breaklist$ 会被回填到上述 $while$ 方案中定义的循环出口标签 $L$。\n\n给定以下嵌套的控制流程序片段：\n\n- 程序：\n  - $while\\ (E_1)\\ do$\n    - $while\\ (E_2)\\ do$\n      - $if\\ (E_3)\\ then$\n        - $break;$\n      - $else$\n        - $S_a;$\n      - $S_b;$\n    - $S_c;$\n\n假设 TAC 生成成本如下：\n- 每个布尔表达式 $E_i$ 生成 $2$ 个 TAC 四元式。\n- 语句 $break$ 生成 $1$ 个 TAC 四元式。\n- 语句 $S_a$ 生成 $3$ 个 TAC 四元式。\n- 语句 $S_b$ 生成 $2$ 个 TAC 四元式。\n- 语句 $S_c$ 生成 $1$ 个 TAC 四元式。\n- 在 $if$ 翻译中，用于 $then$ 部分末尾的无条件 $goto$ 生成 $1$ 个 TAC 四元式。\n\n假设全局计数器初始满足 $nextquad = q_0$ 且 $q_0 = 500$。请严格按照上述翻译方案进行应用，不进行任何优化或省略。计算内层 $if$ 的 $then$ 块内的 $break$ 最终被回填到的精确四元式索引。您的答案必须是一个整数（无单位，不进行四舍五入）。", "solution": "该问题要求对给定的编译器翻译方案进行精确追踪，以确定特定 `break` 语句的目标四元式索引。这里使用回填方法生成三地址码（TAC），其中每个四元式的位置由一个全局计数器（我们将其表示为 $q$）跟踪。初始值给定为 $q_0 = 500$。\n\n该程序片段具有嵌套结构：\n- 外层循环：`while` ($E_1$) `do` {$S_{outer}$}\n- 内层循环：`while` ($E_2$) `do` {$S_{inner}$}\n- `if` 语句：`if` ($E_3$) `then` `break;` `else` {$S_a$;}\n\n我们将根据指定规则，在编译器处理该片段时，逐步追踪计数器 $q$ 的值。\n\n1.  **外层 `while` 循环 (`while (E_1) ...`)**：\n    - 记录循环条件测试开始的地址：$M_1 = q = 500$。\n    - 翻译布尔表达式 $E_1$。根据题目，这会生成 $2$ 个四元式。计数器更新为：$q = 500 + 2 = 502$。这两个四元式是 $E_1$ 的真假情况的跳转指令。\n    - 循环体的开始位于当前地址，$N_1 = q = 502$。$E_1$ 的真列表（包含第一个跳转的索引 $500$）被回填到目标 $N_1$。\n\n2.  **外层循环体（包含内层 `while` 循环）**：\n    - 外层循环体内的第一条语句是内层 `while` 循环。翻译从 $q=502$ 开始。\n\n3.  **内层 `while` 循环 (`while (E_2) ...`)**：\n    - 记录此循环条件测试开始的地址：$M_2 = q = 502$。\n    - 翻译布尔表达式 $E_2$，生成 $2$ 个四元式。计数器更新为：$q = 502 + 2 = 504$。位于索引 $502$ 和 $503$ 的这两个跳转填充了 $E_2$ 的真假列表。\n    - 内层循环体的开始位于当前地址，$N_2 = q = 504$。$E_2$ 的真列表（包含索引 $502$）被回填到目标 $N_2$。\n\n4.  **内层循环体（包含 `if-else` 和 $S_b$）**：\n    - 从 $q=504$ 开始，继续翻译内层循环体。第一条语句是 `if` 语句。\n\n5.  **`if (E_3) then ... else ...` 语句**：\n    - 翻译布尔表达式 $E_3$，生成 $2$ 个四元式。计数器变为 $q = 504 + 2 = 506$。位于索引 $504$ 和 $505$ 的跳转填充了 $E_3$ 的真假列表。\n    - `then` 块从 $N_{then} = q = 506$ 开始。$E_3$ 的真列表（包含索引 $504$）被回填到目标 $N_{then}$。\n    - `then` 块包含一个 `break` 语句。根据规则，`break` 生成 $1$ 个形式为 `goto ___` 的 TAC 四元式。此四元式在当前地址 $q=506$ 生成。这个 `goto` 的索引 $506$ 被添加到最内层嵌套循环（`while (E_2)` 循环）的 `$breaklist$` 中。我们称这个列表为 `$breaklist_2$`。生成此四元式后，计数器增加：$q = 506 + 1 = 507$。\n    - 在 `then` 块之后，生成一个无条件跳转以跳过 `else` 块。这需要 $1$ 个四元式。这个 `goto ___` 在索引 $q=507$ 处生成，其索引被添加到一个名为 `$nextlist$` 的列表中。计数器更新为：$q = 507 + 1 = 508$。\n    - `else` 块从 $N_{else} = q = 508$ 开始。$E_3$ 的假列表（包含索引 $505$）被回填到目标 $N_{else}$。\n    - 翻译 `else` 块中的语句 $S_a$。它生成 $3$ 个四元式。计数器变为 $q = 508 + 3 = 511$。\n    - `if-else` 语句的翻译结束。语句后的汇合点位于当前地址 $J = q = 511$。$nextlist$（包含索引 $507$）被回填到此目标 $J$。\n\n6.  **继续内层循环体**：\n    - 翻译 `if` 语句后面的语句 $S_b$。它生成 $2$ 个四元式。计数器变为 $q = 511 + 2 = 513$。\n\n7.  **内层 `while` 循环的收尾**：\n    - 内层 `while` 循环的循环体现已完全翻译。应用 `while` 语句规则的最后步骤。\n    - 生成一条无条件回边 `goto M_2`。我们记录了 $M_2 = 502$。这条指令是一个单独的四元式，放置在索引 $q=513$ 处。计数器增加：$q = 513 + 1 = 514$。\n    - 紧跟在内层循环生成代码之后的地址定义了循环的出口点。设其为 $L_2$。因此，$L_2 = q = 514$。\n    - 根据 `while` 规则，循环的 `falselist`（来自 $E_2$）和循环的 `breaklist`（`$breaklist_2$`）都被回填到这个出口地址 $L_2$。\n\n`if` 块中的 `break` 语句在索引 $506$ 处生成了一个 `goto` 四元式。对此四元式的引用存储在 `$breaklist_2$` 中。此列表被回填到目标 $L_2$。计算出的 $L_2$ 的值为 $514$。因此，索引 $506$ 处的 `goto` 指令被补全为 `goto 514`。\n\n`break` 被回填到的四元式索引是 $514$。", "answer": "$$\n\\boxed{514}\n$$", "id": "3623441"}, {"introduction": "最后一个练习是一个诊断挑战。这一次，你不再是简单地正确实现回填，而是要去分析一个出错的案例，这会导致程序陷入无限循环。这个实践将我们从机械地应用算法，带入到更深层次的概念理解，要求我们像编译器开发者一样思考，如何调试自己的工具。它强调了回填技术必须维护的“不变量”的重要性，并引入了控制流图（Control Flow Graph, CFG）等形式化方法来推理程序的行为。[@problem_id:3623500]", "problem": "编译器使用标准的回填（backpatching）方法将结构化控制流翻译成三地址码。对于布尔表达式，它维护一个真列表和一个假列表，记为 $\\mathtt{truelist}$ 和 $\\mathtt{falselist}$，这两个列表是待稍后回填的不完整跳转的集合。对于语句，它维护一个下一条指令列表，记为 $\\mathtt{nextlist}$，其中包含应回填至该语句后继者的不完整跳转。其核心不变量为：对于 while 语句 $\\mathtt{while}\\ (B)\\ S$，$B.\\mathtt{truelist}$ 中的条目被回填到 $S$ 的第一条指令，而 $B.\\mathtt{falselist}$ 中的条目被回填到循环之后的第一条指令。控制流图（CFG）的节点是基本块（首指令在程序的第一条指令处、跳转的目标处、以及紧跟在跳转指令之后的指令处），而边由条件跳转、无条件跳转以及顺序执行到下一条指令所引发。\n\n考虑为某个循环在回填前生成的以下三地址码，其中最左边的整数是指令编号，标记 $M$ 和 $N$ 分别记录了由语法制导翻译捕获的循环头和循环后的第一条指令（因此 $M$ 指向测试，而 $N$ 指向循环后的代码）：\n\n- $10$: if $x  y$ goto $\\_$ \n- $11$: goto $\\_$ \n- $12$: $...$ $S$ 的代码开始 $...$\n- $13$: $...$\n- $14$: $...$ $S$ 的代码结束 $...$\n- $15$: goto $10$\n- $16$: $...$ 循环后的代码开始 $...$\n\n在解析完 $B$ 之后、回填之前的那个时间点，$B.\\mathtt{truelist} = \\{10\\}$（在 $10$ 处的条件跳转）且 $B.\\mathtt{falselist} = \\{11\\}$，以及 $S.\\mathtt{nextlist} = \\varnothing$。编译器回填例程中的一个错误，错误地将 $B.\\mathtt{falselist}$ 回填到 $M$（即指令 $10$）而不是 $N$（即指令 $16$）。最终回填后的代码是：\n\n- $10$: if $x  y$ goto $12$\n- $11$: goto $10$\n- $12$: $...$ $S$ 的代码开始 $...$\n- $13$: $...$\n- $14$: $...$ $S$ 的代码结束 $...$\n- $15$: goto $10$\n- $16$: $...$ 循环后的代码开始 $...$\n\n即使条件 $x  y$ 初始为假，该程序也会表现出无限循环，因为控制流是 $10 \\to 11 \\to 10 \\to 11 \\to \\cdots$。\n\n要求你仅使用第一性原理来诊断这个回填错误：即回填列表的不变量和控制流图（CFG）的定义，以及标准的可达性和支配性概念。以下哪种诊断方法可以被证明能识别出这个回填错误，并将其正确归因于 $B.\\mathtt{falselist}$ 的错误目标？\n\n选择所有适用的选项。\n\nA. 构建 CFG，为条件跳转（到目标和顺序执行）、无条件跳转以及当没有跳转覆盖时的顺序执行边引入边。使用记录的循环后首指令标记 $N$（指令 $16$），检查从循环测试（指令 $10$）沿假后继路径到 $N$ 的可达性。如果不存在这样的路径，则报告 $B.\\mathtt{falselist}$ 的回填错误，并通过追踪 $B.\\mathtt{falselist}$ 中的哪个指令没有被回填到 $N$ 来识别出有问题的 goto 语句。\n\nB. 构建 CFG 并计算支配节点。将任何头节点不支配其尾节点的回边标记为此循环中回填错误的证据。如果存在这样的边，则将无限循环归因于错误回填的 $B.\\mathtt{falselist}$。\n\nC. 使用列表来源信息而不构建完整的 CFG：通过检查 $B.\\mathtt{falselist}$ 中的每个条目是否都已回填到 $N$（循环后首指令的标记），并且没有 $B.\\mathtt{falselist}$ 中的条目被回填到 $M$（循环头标记），来验证 while 语句的不变量。如果 $B.\\mathtt{falselist}$ 的某个成员等于 $M$，则报告回填错误和导致该问题的确切指令索引。\n\nD. 在任何输入上执行生成的代码，如果它在固定的超时时间内没有终止，则将不终止归因于循环体中不正确的 $\\mathtt{nextlist}$ 回填，而不是 $B.\\mathtt{falselist}$。\n\nE. 重编号指令，以强制所有条件的假分支边都指向严格更大的指令编号。如果程序随后在给定输入上终止，则断定原始的不终止是由错误回填的 $B.\\mathtt{falselist}$ 引起的。\n\n只应选择那些根据上述定义保证能找到这类特定的回填错误并正确定位其原因的方法。以所有正确选项的集合形式给出你的答案。", "solution": "首先验证问题陈述，以确保其在科学上是可靠、定义明确且客观的。\n\n### 第一步：提取已知信息\n\n- **编译器方法**：用于将结构化控制流翻译成三地址码的标准回填方法。\n- **数据结构**：\n    - `truelist`：布尔表达式 $B$ 的一个不完整跳转集合，应回填到真出口。\n    - `falselist`：布尔表达式 $B$ 的一个不完整跳转集合，应回填到假出口。\n    - `nextlist`：语句 $S$ 的一个不完整跳转集合，应回填到该语句的后继语句。\n- **`while (B) S` 的不变量**：\n    - $B.\\mathtt{truelist}$ 中的条目被回填到 $S$ 的第一条指令。\n    - $B.\\mathtt{falselist}$ 中的条目被回填到循环之后的第一条指令。\n- **CFG 定义**：\n    - 节点是基本块。\n    - 首指令在第一条指令处、跳转的目标处以及紧跟在跳转指令之后的指令处。\n    - 边由条件跳转、无条件跳转和顺序执行引发。\n- **场景代码（回填前）**：\n    - $10$: if $x  y$ goto $\\_$\n    - $11$: goto $\\_$\n    - $12$: $...$ $S$ 的代码开始 $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ 循环后的代码开始 $...$\n- **场景状态**：\n    - 标记 $M$ 指向指令 $10$（循环头）。\n    - 标记 $N$ 指向指令 $16$（循环后）。\n    - $B.\\mathtt{truelist} = \\{10\\}$。\n    - $B.\\mathtt{falselist} = \\{11\\}$。\n    - $S.\\mathtt{nextlist} = \\varnothing$。\n- **错误**：$B.\\mathtt{falselist}$ 被错误地回填到 $M$（指令 $10$）而不是 $N$（指令 $16$）。\n- **回填后的结果代码**：\n    - $10$: if $x  y$ goto $12$\n    - $11$: goto $10$\n    - $12$: $...$ $S$ 的代码开始 $...$\n    - $...$\n    - $15$: goto $10$\n    - $16$: $...$ 循环后的代码开始 $...$\n- **问题**：根据第一性原理，识别哪种诊断方法可以被证明能识别出该回填错误，并将其正确归因于 $B.\\mathtt{falselist}$ 的错误目标。\n\n### 第二步：使用提取的已知信息进行验证\n\n问题陈述定义明确，并基于编译器设计中已确立的原则，特别是语法制导翻译和代码生成。回填、三地址码、控制流图（CFG）和支配节点的概念都是计算机科学中的标准概念。该场景提出了一个具体、 plausible 的错误，并要求用形式化方法来检测它。问题是自包含的，提供了所有必要的定义和数据。它是客观的，不包含任何科学或事实上的不健全之处。\n\n### 第三步：结论与行动\n\n问题陈述是**有效的**。解决方案将通过根据所提供的原则分析每个提议的方法来进行。\n\n### 基于原则的推导与选项分析\n\n问题的核心在于违反了结构化程序设计翻译的一个基本不变量。对于一个 `while` 循环，布尔条件必须提供两条不同的路径：一条进入（或继续）循环体，另一条退出循环。在回填的背景下，这转化为：\n- $B.\\mathtt{truelist}$ 中的跳转必须被回填到循环体的开始（$S$）。\n- $B.\\mathtt{falselist}$ 中的跳转必须被回填到紧跟在循环之后的指令（$N$）。\n\n所描述的错误是 $B.\\mathtt{falselist}$ 中的一条指令（指令 $11$）被回填到了循环头 $M$（指令 $10$），而不是循环出口 $N$（指令 $16$）。这造成了一种情况，即条件的“假”路径导回条件本身，使得当条件为假时循环永远无法终止。一个有效的诊断方法必须能检测到这个特定的违规行为并确定其原因。\n\n让我们分析一下错误代码的控制流图（CFG）。首指令是指令 $10$（跳转的目标）、$11$（跟在条件跳转之后）、$12$（跳转的目标）和 $16$（跟在跳转之后）。\n基本块是：\n- $B_1$：指令 $10$\n- $B_2$：指令 $11$\n- $B_3$：指令 $12-15$\n- $B_4$：指令 $16$ 及之后\n\n边是：\n- $B_1 \\to B_3$（从 $10$ 的 `if` 到 $12$ 的真分支）\n- $B_1 \\to B_2$（假分支，从 $10$ 顺序执行到 $11$）\n- $B_2 \\to B_1$（从 $11$ 到 $10$ 的无条件跳转）\n- $B_3 \\to B_1$（从 $15$ 到 $10$ 的无条件跳转）\n\n注意，没有指向 $B_4$ 的边，这意味着循环后的代码是不可达的。\n\n**A. 构建 CFG... 检查从循环测试（指令 $10$）沿假后继路径到 $N$（指令 $16$）的可达性。**\n\n此方法提议构建 CFG 并执行可达性分析。循环测试在指令 $10$。其“假后继”路径始于从节点 $B_1$（包含 $10$）到节点 $B_2$（包含 $11$）的边。沿着这条路径，我们有循环 $B_1 \\to B_2 \\to B_1 \\to \\dots$。节点 $B_4$（包含 $N=16$）从 $B_1$ 或 $B_2$ 均不可达。因此，“如果不存在这样的路径，则报告回填错误”的检查将正确触发一个错误。该方法接着提议“通过追踪 $B.\\mathtt{falselist}$ 中的哪个指令没有被回填到 $N$ 来识别出有问题的 goto 语句”。编译器有元数据 $B.\\mathtt{falselist}=\\{11\\}$。通过检查生成的代码，它可以看到指令 $11$ 是 `goto 10`。由于目标 $10 \\neq N$，该方法正确地识别了列表中的指令及其不正确的 回填。这个方法是可靠的，并且能正确地归因。\n结论：**正确**。\n\n**B. 构建 CFG 并计算支配节点。将任何头节点不支配其尾节点的回边标记为...**\n\n此方法依赖于 CFG 中回边的定义，即一条边 $(u, v)$，其中头节点 $v$ 支配尾节点 $u$。此属性用于识别自然循环。让我们计算我们的 CFG 的支配节点，以 $B_1$ 为入口。\n- $\\mathrm{dom}(B_1) = \\{B_1\\}$\n- $\\mathrm{dom}(B_3) = \\{B_1, B_3\\}$\n- $\\mathrm{dom}(B_2) = \\{B_1, B_2\\}$\n回边是指向支配节点的边。\n- 边 $B_3 \\to B_1$：头是 $B_1$，尾是 $B_3$。$B_1 \\in \\mathrm{dom}(B_3)$。这是一条有效的回边。\n- 边 $B_2 \\to B_1$：头是 $B_1$，尾是 $B_2$。$B_1 \\in \\mathrm{dom}(B_2)$。这也是一条有效的回边。\n提议的检查是“将任何头节点不支配其尾节点的回边标记出来”。在我们的案例中，两条回边的头节点都支配其尾节点。因此，此方法将**不会**标记任何错误。这个错误创建了一个结构上有效（但语义上不正确）的循环。仅靠支配性分析不足以检测这种逻辑错误。\n结论：**不正确**。\n\n**C. 使用列表来源信息而不构建完整的 CFG：通过检查 $B.\\mathtt{falselist}$ 中的每个条目是否都已回填到 $N$...来验证 while 语句的不变量...**\n\n此方法绕过了复杂的图分析，而是直接使用编译器维护的元数据（列表和标记）来验证回填不变量。`while` 语句的不变量明确要求 $B.\\mathtt{falselist}$ 中的所有指令都回填到目标 $N$。提议的检查是遍历 $B.\\mathtt{falselist}$ 中的条目，并验证其回填的目标确实是 $N$。\n在这种情况下，$B.\\mathtt{falselist} = \\{11\\}$ 且 $N = 16$。检查会审查回填后代码中的指令 $11$，即 `goto 10`。目标是 $10$。由于 $10 \\neq 16$，不变量被违反。该方法正确报告了回填错误，并识别出确切的指令（$11$）和列表（$B.\\mathtt{falselist}$）。这是一种直接、精确且可证明正确的方法来发现这种特定错误。\n结论：**正确**。\n\n**D. 在任何输入上执行生成的代码，如果它在固定的超时时间内没有终止，则将不终止归因于不正确的 $\\mathtt{nextlist}$ 回填...**\n\n此方法提议使用动态分析（测试）而非静态分析。虽然测试可以揭示错误的存在（不终止），但作为一种诊断工具，它有几个根本性的缺陷。\n1. 这不是一个*证明*。它只对被测试的特定输入有效。对于不同的初始状态（例如 $x \\ge y$），循环可能正确终止（通过进入循环体，并在变量适当改变时最终退出），而错误将不会被发现。\n2. 固定的超时是任意的，可能导致假阳性（对于一个正确但运行时间长的循环）或假阴性（如果超时太长）。\n3. 归因不正确。它将问题归咎于 $\\mathtt{nextlist}$，而实际的错误在于 $B.\\mathtt{falselist}$ 的回填。在给定的场景中，循环体 $S$ 甚至从未被进入，所以 $S.\\mathtt{nextlist}$（反正也是空的）是无关的。\n结论：**不正确**。\n\n**E. 重编号指令，以强制所有条件的假分支边都指向严格更大的指令编号。如果程序随后终止...则断定原始的不终止是由错误回填的 $B.\\mathtt{falselist}$ 引起的。**\n\n这是另一种基于启发式修改后进行测试的方法。“重编号指令”这个说法很模糊。如果它仅仅意味着改变标签（例如 $10 \\to 100, 11 \\to 101$），`goto 100` 仍然会保留无限循环。一个更宽容的解释是，它的意思是强制一种代码布局，使得所有“假”情况的控制流都向前走。从指令 $10$ 出发的假路径是顺序执行到 $11$。指令 $11$ 是 `goto 10`，一个向后跳转。该方法似乎建议改变这个跳转，使其指向前方。这本质上是提出了一个“修复”（将 $11$ 回填指向 $16$）然后重新测试。与选项 D 一样，这是一种动态分析，而不是静态证明。这是一种“猜测并检查”的方法，而不是一种从第一性原理出发发现并归因错误的诊断方法。它不能证明性地识别出回填错误；它只是观察到某个特定的更改在一个测试用例上修复了一个症状。\n结论：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3623500"}]}