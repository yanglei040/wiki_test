{"hands_on_practices": [{"introduction": "编译器设计的核心任务之一是在不同的抽象层次上转换代码。这个练习将带你逆向工程一段基于 `goto` 的非结构化代码，将其重构为等价的结构化形式（如 `while` 循环和 `if` 语句）。通过这个过程，你不仅能加深对控制流基本模式的理解，还将学习如何使用控制流图（CFG）和圈复杂度等形式化工具来分析和验证代码结构[@problem_id:3677965]。", "problem": "考虑以下使用整数变量 $i$、$n$、$s$、$t$ 和 $r$ 的基于 goto 的程序。初始条件为 $s \\leftarrow 0$ 且 $n \\ge 0$ 是一个给定的输入。标签用 $L_{k}$ 表示（其中 k 为整数），控制转移使用条件或无条件跳转。\n\n$L_{0}$: $i \\leftarrow 0$; $s \\leftarrow 0$; goto $L_{1}$\n\n$L_{1}$: if $i \\ge n$ goto $L_{7}$ else goto $L_{2}$\n\n$L_{2}$: $t \\leftarrow i \\times i$; if $(t \\bmod 3) = 0$ goto $L_{5}$ else goto $L_{4}$\n\n$L_{4}$: $s \\leftarrow s + t$; goto $L_{6}$\n\n$L_{5}$: $s \\leftarrow s - i$; goto $L_{6}$\n\n$L_{6}$: $i \\leftarrow i + 1$; goto $L_{1}$\n\n$L_{7}$: if $s  0$ goto $L_{9}$ else goto $L_{8}$\n\n$L_{8}$: $r \\leftarrow s$; goto $L_{10}$\n\n$L_{9}$: $r \\leftarrow -s$; goto $L_{10}$\n\n$L_{10}$: halt\n\n从编译器设计中翻译控制流语句的基本原则出发，即将结构化构造翻译为带有标签、条件跳转和基本块的中间表示（IR），请执行以下操作：\n\n1. 使用循环和条件语句将此程序重构为结构化构造，使其在语义上等同于给定的基于 goto 的版本，并且不改变为 $r$ 计算的可观察行为。\n2. 使用针对 $if$ 语句和 $while$ 循环的标准翻译方案，将结构化版本重新降级为规范的三地址码中间表示（IR），并引入标签和条件/无条件跳转来划分基本块。\n3. 构建重新降级后 IR 的控制流图（CFG），识别其基本块和它们之间的有向边，并证明该 CFG 与原始基于 goto 的程序的 CFG 同构（从而建立 IR 的等价性）。\n4. 计算重新降级后 IR 的 CFG 的圈复杂度，结果为一个实数值。将最终的圈复杂度值作为你的答案。无需四舍五入。\n\n你的最终答案必须是重新降级后 IR 的 CFG 的圈复杂度值。", "solution": "问题陈述是有效的。它在编译器原理领域内提出了一个明确定义的任务，提供了一个自包含、逻辑一致且无歧义的基于 goto 的程序用于控制流分析。该问题在既有的计算机科学理论中有科学依据，并且可以通过形式化的、客观的方法解决。我们将继续执行四个要求的任务。\n\n### 1. 重构为结构化构造\n\n可以分析所提供的基于 goto 的程序，以揭示其底层的结构化逻辑。\n\n- 标签 $L_{0}$ 处的语句（`i - 0; s - 0;`）是在任何循环之前仅执行一次的初始化步骤。\n- 从 $L_{1}$ 开始到从 $L_{6}$ 跳回 $L_{1}$ 的代码块形成一个循环。$L_{1}$ 处的入口条件是 `if i >= n goto L_exit`，这等价于一个 `while (i  n)` 循环。\n- 在这个循环内部（标签 $L_{2}$ 到 $L_{6}$），程序计算 `t - i * i`。根据条件 `(t mod 3) = 0`，它会遵循两条路径之一：\n    - 如果 `(t mod 3) = 0` 为假，它会继续到 $L_{4}$ 并执行 `s - s + t`。\n    - 如果 `(t mod 3) = 0` 为真，它会继续到 $L_{5}$ 并执行 `s - s - i`。\n    - 两条路径在 $L_{6}$ 处汇合，在此处循环计数器 `i` 递增（`i - i + 1`），并且控制返回到 $L_{1}$ 的循环条件。这个结构是一个嵌套在循环内的 `if-else` 语句。\n- 循环终止后（当 `i >= n` 时），控制转移到 $L_{7}$。标签 $L_{7}$、$L_{8}$ 和 $L_{9}$ 处的语句计算 $s$ 的绝对值并将其存储在 $r$ 中。具体来说，`if s  0` 则 `r - -s`，否则 `r - s`。\n- 最后，程序在 $L_{10}$ 处停止。\n\n基于此分析，语义上等价的结构化程序是：\n```c\ns = 0;\ni = 0;\nwhile (i  n) {\n    t = i * i;\n    if ((t % 3) == 0) {\n        s = s - i;\n    } else {\n        s = s + t;\n    }\n    i = i + 1;\n}\nif (s  0) {\n    r = -s;\n} else {\n    r = s;\n}\nhalt;\n```\n注意，初始化 `s - 0` 在问题中明确给出，并且也出现在 $L_0$ 处。效果是相同的。\n\n### 2. 重新降级为三地址码 IR\n\n使用结构化控制流语句的标准翻译方案，我们可以将上述程序降级为三地址码中间表示（IR）。此过程涉及创建由标签和跳转划分的基本块。\n\n- **块 $B'_{0}$ (初始化):**\n  `i - 0`\n  `s - 0`\n  `goto B'_{1}`\n\n- **块 $B'_{1}$ (循环头):**\n  `if i >= n goto B'_{6}`\n  `else goto B'_{2}`\n\n- **块 $B'_{2}$ (循环体，条件):**\n  `t - i * i`\n  `tmp - t mod 3`\n  `if tmp = 0 goto B'_{4}`\n  `else goto B'_{3}`\n\n- **块 $B'_{3}$ (内层 `else` 分支):**\n  `s - s + t`\n  `goto B'_{5}`\n\n- **块 $B'_{4}$ (内层 `then` 分支):**\n  `s - s - i`\n  `goto B'_{5}`\n\n- **块 $B'_{5}$ (循环增量):**\n  `i - i + 1`\n  `goto B'_{1}`\n\n- **块 $B'_{6}$ (循环后，绝对值):**\n  `if s  0 goto B'_{8}`\n  `else goto B'_{7}`\n\n- **块 $B'_{7}$ (绝对值 `else` 分支):**\n  `r - s`\n  `goto B'_{9}`\n\n- **块 $B'_{8}$ (绝对值 `then` 分支):**\n  `r - -s`\n  `goto B'_{9}`\n\n- **块 $B'_{9}$ (停止):**\n  `halt`\n\n该 IR 由 10 个基本块组成，标记为 $B'_{0}$ 到 $B'_{9}$。\n\n### 3. 控制流图（CFG）构建与同构\n\n首先，我们识别**原始**基于 goto 的程序的基本块。基本块始于作为跳转目标的标签或程序的开头，并以跳转或紧接在另一个首指令之前结束。原始代码中的首指令是标签 $L_{0}, L_{1}, L_{2}, L_{4}, L_{5}, L_{6}, L_{7}, L_{8}, L_{9}, L_{10}$ 处的指令。这产生了 10 个基本块，我们用 $B_{k}$ 表示从标签 $L_{k}$ 开始的块（即 $B_0, B_1, B_2, B_4, B_5, B_6, B_7, B_8, B_9, B_{10}$）。\n\n原始程序的控制流图 $G = (V, E)$ 有一个顶点集 $V = \\{B_{0}, B_{1}, B_{2}, B_{4}, B_{5}, B_{6}, B_{7}, B_{8}, B_{9}, B_{10}\\}$（$|V| = N = 10$）和一个由跳转决定的有向边集 $E$：\n- $E = \\{ (B_{0}, B_{1}), (B_{1}, B_{2}), (B_{1}, B_{7}), (B_{2}, B_{4}), (B_{2}, B_{5}), (B_{4}, B_{6}), (B_{5}, B_{6}), (B_{6}, B_{1}), (B_{7}, B_{8}), (B_{7}, B_{9}), (B_{8}, B_{10}), (B_{9}, B_{10}) \\}$\n边的数量为 $|E| = 12$。\n\n**重新降级后 IR** 的 CFG $G' = (V', E')$ 有一个顶点集 $V' = \\{B'_{0}, B'_{1}, B'_{2}, B'_{3}, B'_{4}, B'_{5}, B'_{6}, B'_{7}, B'_{8}, B'_{9}\\}$（$|V'| = N = 10$）和一个有向边集 $E'$：\n- $E' = \\{ (B'_{0}, B'_{1}), (B'_{1}, B'_{2}), (B'_{1}, B'_{6}), (B'_{2}, B'_{3}), (B'_{2}, B'_{4}), (B'_{3}, B'_{5}), (B'_{4}, B'_{5}), (B'_{5}, B'_{1}), (B'_{6}, B'_{7}), (B'_{6}, B'_{8}), (B'_{7}, B'_{9}), (B'_{8}, B'_{9}) \\}$\n边的数量为 $|E'| = 12$。\n\n为了证明 $G$ 和 $G'$ 是同构的，我们必须展示一个保持邻接关系的双射 $f: V \\to V'$。让我们根据每个块的功能角色来定义映射：\n- $f(B_{0}) = B'_{0}$ (初始化)\n- $f(B_{1}) = B'_{1}$ (循环头)\n- $f(B_{2}) = B'_{2}$ (循环体预条件)\n- $f(B_{4}) = B'_{3}$ (内层 `if` 的 `else` 路径)\n- $f(B_{5}) = B'_{4}$ (内层 `if` 的 `then` 路径)\n- $f(B_{6}) = B'_{5}$ (循环增量和继续)\n- $f(B_{7}) = B'_{6}$ (循环后条件)\n- $f(B_{8}) = B'_{7}$ (外层 `if` 的 `else` 路径)\n- $f(B_{9}) = B'_{8}$ (外层 `if` 的 `then` 路径)\n- $f(B_{10}) = B'_{9}$ (停止/退出)\n\n这个函数 $f$ 是 $V$ 和 $V'$ 之间的一个双射。我们检查对于任何边 $(u, v) \\in E$，边 $(f(u), f(v)) \\in E'$ 也成立。例如，$(B_{6}, B_{1}) \\in E$，在 $G'$ 中对应的边是 $(f(B_{6}), f(B_{1})) = (B'_{5}, B'_{1})$，它在 $E'$ 中。类似地，$(B_{2}, B_{4}) \\in E$ 对应于 $(f(B_{2}), f(B_{4})) = (B'_{2}, B'_{3}) \\in E'$。一个完整的检查确认了所有 12 条边在该映射下都得以保留。因此，重新降级后 IR 的 CFG 与原始程序的 CFG 是同构的。\n\n### 4. 圈复杂度计算\n\n控制流图的圈复杂度 $M$ 可以使用几个等价的公式计算。我们将使用基于图中节点数、边数和连通分量数的公式。对于具有单个入口和单个出口点的 CFG，存在 $P=1$ 个连通分量。公式为：\n$$M = E - N + 2P$$\n使用重新降级后 IR 的 CFG（它与原始 CFG 同构），我们有：\n- 节点数（基本块） $N = 10$。\n- 边数（控制转移） $E = 12$。\n- 连通分量数 $P = 1$。\n\n将这些值代入公式：\n$$M = 12 - 10 + 2(1) = 2 + 2 = 4$$\n\n或者，我们可以使用公式 $M = D + 1$，其中 $D$ 是判定节点（出度为 2 的节点）的数量。\n图中的判定节点是：\n1.  $B'_{1}$ (或 $B_{1}$): `if i >= n`\n2.  $B'_{2}$ (或 $B_{2}$): `if tmp = 0`\n3.  $B'_{6}$ (或 $B_{7}$): `if s  0`\n共有 $D=3$ 个判定节点。因此，复杂度为：\n$$M = 3 + 1 = 4$$\n\n两种方法得出了相同的结果。CFG 的圈复杂度为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3677965"}, {"introduction": "将高级语言的控制结构翻译成机器指令时，编译器必须处理具体的硬件细节。本练习将理论与实践相结合，要求你为一个 `do-while` 循环计算程序计数器（PC）相对跳转的位移量[@problem_id:3677994]。这个计算过程将帮助你理解代码在内存中的布局方式，以及编译器如何将逻辑上的“跳转到循环头部”精确地转换为一条机器指令。", "problem": "考虑一个编译器，它使用经典的布尔表达式短路求值回填技术，将一个高级 do-while 循环翻译成三地址码。目标机器使用程序计数器 (PC) 相对条件分支：位于指令地址 $i$ 的条件分支指令编码了一个整数位移 $\\delta$，当且仅当 $T = (i + 1) + \\delta$ 时，控制流转移到目标地址 $T$，其中地址以指令为单位计数，且标号不占用指令槽位。\n\n对于形式为 do $S$ while $(B)$ 的语句，其翻译方案基于以下核心定义：\n- do-while 的语义：循环体 $S$ 在布尔表达式 $B$ 求值之前至少执行一次；如果 $B$ 的值为真，则控制流重复该循环；否则，退出循环。\n- 布尔表达式的回填：翻译 $B$ 会生成一个代码序列以及两个列表 $B.true$ 和 $B.false$，$B.true$ 和 $B.false$ 包含目标地址尚不确定的条件和无条件跳转指令的地址。回填 $B.true$ 会将目标地址设置为循环头，使得当表达式为真时继续循环；回填 $B.false$ 会将目标地址设置为循环出口，使得当表达式为假时离开循环。\n\n假设对于一个特定的 do-while 循环，有以下具体的布局约束：\n- 循环的第一条指令（循环头）位于地址 $pc_{0} = 1000$。\n- 翻译循环体 $S$ 产生恰好 $\\ell_{S} = 73$ 条指令。\n- 翻译布尔表达式 $B$ 产生恰好 $\\ell_{B} = 9$ 条指令，其位于地址 $pc_{end}$ 的最后一条指令是唯一的条件分支，其为真时的目标将被回填至循环头。所有标号不占用指令槽位，且在回填过程中不引入额外的指令。\n\n在这些条件下，将 $B$ 的代码紧跟在循环体 $S$ 之后，编译器将 $B.true$ 回填至位于 $pc_{0}$ 的循环头。仅使用上述基础知识和定义，确定当 $B$ 的值为真时，位于 $pc_{end}$ 的条件分支指令中必须编码的带符号PC相对位移 $\\delta$ 是多少，以跳转回循环头。请以整数形式提供最终答案。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是合理、自洽且定义明确的。它提出了一个编译器构造中的标准场景，涉及将控制流语句翻译为使用程序计数器 (PC) 相对寻址的机器级指令。所有必要的参数都已提供，目标也已明确定义。\n\n我们的目标是确定一个条件分支指令的带符号PC相对位移，记为 $\\delta$。目标地址 $T$、分支指令地址 $i$ 和位移 $\\delta$ 之间的关系由以下公式给出：\n$$T = (i + 1) + \\delta$$\n这个公式模拟了一种常见的体系结构，其中在应用位移之前，PC会先前进到下一条指令的地址。为了求出 $\\delta$，我们可以重新整理这个方程：\n$$\\delta = T - (i + 1)$$\n\n我们必须根据问题的具体说明来确定目标地址 $T$ 和分支指令地址 $i$ 的值。\n\n1.  **确定目标地址 $T$**：\n    问题描述了一个 `do S while (B)` 循环的翻译。在这种循环中，如果条件 $B$ 为真，控制流会跳转回循环的开始处，以重新执行循环体 $S$。问题指出，条件分支的为真目标被回填至循环头。循环头的地址，也就是语句 $S$ 的第一条指令的地址，被给出为 $pc_{0}$。\n    因此，目标地址 $T$ 是：\n    $T = pc_{0} = 1000$\n\n2.  **确定分支指令地址 $i$**：\n    条件分支被指定为为布尔表达式 $B$ 生成的代码的最后一条指令。要找到它的地址，我们必须确定生成代码在内存中的布局。\n    `do S while (B)` 生成的代码结构是 $S$ 的代码紧跟着 $B$ 的代码。\n    - 循环的第一条指令，即循环体 $S$ 代码的开始，位于地址 $pc_{0} = 1000$。\n    - $S$ 的代码包含 $\\ell_{S} = 73$ 条指令。这些指令占据了从 $pc_{0}$ 到 $pc_{0} + \\ell_{S} - 1$ 的地址范围。\n      具体来说，就是从地址 $1000$ 到 $1000 + 73 - 1 = 1072$。\n    - 布尔表达式 $B$ 的代码紧跟在 $S$ 的代码之后。因此，它的第一条指令位于地址 $(pc_{0} + \\ell_{S} - 1) + 1 = pc_{0} + \\ell_{S}$。\n      具体来说，就是地址 $1073$。\n    - $B$ 的代码包含 $\\ell_{B} = 9$ 条指令。这个代码块的最后一条指令是我们所寻找的条件分支指令。它的地址 $i$（问题中记为 $pc_{end}$）是序列中的最后一个地址。\n    该地址可以计算为 $B$ 代码块的起始地址加上其指令数再减一。\n    $i = pc_{end} = (pc_{0} + \\ell_{S}) + \\ell_{B} - 1$\n    代入给定的值：\n    $i = 1000 + 73 + 9 - 1 = 1000 + 82 - 1 = 1081$\n    所以，条件分支指令位于地址 $i = 1081$。\n\n3.  **计算位移 $\\delta$**：\n    现在我们将确定的 $T$ 和 $i$ 的值代入整理后的 $\\delta$ 公式中：\n    $$\\delta = T - (i + 1)$$\n    $$\\delta = 1000 - (1081 + 1)$$\n    $$\\delta = 1000 - 1082$$\n    $$\\delta = -82$$\n\n位移是负数，这对于一个将控制流返回到程序中较早点（循环头）的跳转来说是符合预期的。跳转的幅度 $82$ 对应于循环体 ($S$) 和条件检查 ($B$) 中的总指令数，即 $\\ell_S + \\ell_B = 73 + 9 = 82$。从地址 $i = 1081$ 的指令发出的跳转必须到达 $T = 1000$。PC首先递增到 $1082$，然后加上位移 $\\delta = -82$，得到正确的目标地址 $1082 + (-82) = 1000$。", "answer": "$$\\boxed{-82}$$", "id": "3677994"}]}