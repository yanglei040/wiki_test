## 引言
在将源代码转化为高效机器指令的漫长旅程中，编译器依赖于一系列精心设计的[中间表示](@entry_id:750746)。一种初步的表示是[抽象语法树](@entry_id:633958)（AST），它忠实地反映了代码的结构，但往往包含大量冗余计算，直接生成代码会导致性能不佳。为了弥补这一缺陷，编译器需要一种更精炼、更利于分析和优化的[数据结构](@entry_id:262134)。[表达式有向无环图](@entry_id:749185)（DAG）正是解决这一问题的核心工具，它通过识别[并合](@entry_id:147963)并重复的计算，为生成紧凑、快速的目标代码奠定了基础。

本文将带领读者深入探索表达式 DAG 的世界。你将学习到：
-   在第一章“原理与机制”中，我们将阐述 DAG 的基本动机，即如何从树[结构演进](@entry_id:186256)到图结构以消除[公共子表达式](@entry_id:747510)。我们将详细介绍构建 DAG 的经典算法（如[值编号](@entry_id:756409)），并探讨如何处理交换律、浮点数异常、内存访问和副作用等现实世界中的复杂语义，以确保优化的正确性和安全性。
-   在第二章“应用与跨学科联系”中，我们将视野扩展到 DAG 在[编译器优化](@entry_id:747548)（如[指令选择](@entry_id:750687)、[循环不变量](@entry_id:636201)提升）以及更广阔领域的应用。你将看到 DAG 的思想如何连接编译器与计算机体系结构，并成为驱动机器学习（通过[自动微分](@entry_id:144512)）和实时图形学等前沿技术的关键。
-   最后，在“动手实践”部分，你将有机会通过一系列精心设计的练习，亲手构建 DAG、分析其属性并解决实际的[优化问题](@entry_id:266749)，从而将理论知识转化为实践能力。

现在，让我们从理解 DAG 的基本原理开始，揭示其作为编译器中强大优化工具的奥秘。

## 原理与机制

在前一章节中，我们探讨了编译器如何将源代码解析为[抽象语法树](@entry_id:633958)（AST），这是一种忠实反映代码句法结构的[数据结构](@entry_id:262134)。然而，AST 在表示计算时往往存在冗余。为了生成更高效的目标代码，编译器需要一种更精炼的[中间表示](@entry_id:750746)，它不仅能捕捉表达式的语义，还能揭示优化机会。本章将深入探讨这样一种核心表示——**[有向无环图](@entry_id:164045)（Directed Acyclic Graph, DAG）**，阐述其构建原理、优化机制及其在处理复杂语言特性时的扩展。

### 从树到图：DAG 的动机

[抽象语法树](@entry_id:633958)（AST）是表达式的直接、分层表示。在 AST 中，每个操作符和每个操作数实例都对应一个唯一的节点。这种表示方式虽然直观，但却无法识别并合并计算中的重复部分，即**[公共子表达式](@entry_id:747510)（Common Subexpressions, CSE）**。

考虑表达式 $E = x \times y + x \times z + y \times z + x \times y$。如果用 AST 来表示，它将包含七个内部节点（四个乘法和三个加法）和八个[叶节点](@entry_id:266134)（$x$、$y$、$z$ 的每次出现）。这种表示直接对应于一种朴素的[代码生成](@entry_id:747434)策略，即不经优化地执行每一次运算。因此，总共需要七次算术指令。[@problem_id:3641820]

然而，仔细观察该表达式，我们会发现子表达式 $x \times y$ 出现了两次。如果我们在第一次计算 $x \times y$ 后保存其结果，并在第二次需要时重用它，就可以节省一次乘法运算。DAG 正是为系统性地实现这种重用而设计的。

**[有向无环图](@entry_id:164045)（DAG）**是一种比 AST 更紧凑的图结构。与树不同，DAG 允许节点有多个父节点。其核心思想是：对于任何一个唯一的变量、常量或子表达式的计算结果，DAG 中只存在一个代表它的节点。如果一个子表达式在代码中出现多次，所有引用它的地方都会指向这同一个 DAG 节点。

对于表达式 $E$，其 DAG 表示将为每个唯一变量（$x$, $y$, $z$）创建一个叶节点，并为每个唯一的子表达式（$x \times y$, $x \times z$, $y \times z$, 以及后续的加法结果）创建一个内部节点。由于 $x \times y$ 是一个[公共子表达式](@entry_id:747510)，它在 DAG 中只对应一个节点。因此，整个表达式的 DAG 只需要六个内部节点（三个乘法和三个加法）。通过从 AST 的七次运算减少到 DAG 的六次运算，我们通过[公共子表达式消除](@entry_id:747511)（CSE）节省了一次算术指令。这种节点和运算的节省正是采用 DAG 的主要动机。[@problem_id:3641820]

### 构建 DAG：算法与数据结构

构建 DAG 的过程旨在系统性地识别和合并[公共子表达式](@entry_id:747510)。有多种算法可以实现这一点，我们从一个基础算法开始，然后介绍一种更通用、更强大的技术。

#### 基础栈算法

对于简单的后缀表达式，我们可以使用一个基于栈的算法来构建 DAG。该算法在处理后缀记号流时，维护一个指向已创建 DAG 节点的指针栈。

其工作流程如下：
1.  当遇到一个**操作数**（变量或常量）时，检查该操作数是否已有对应的[叶节点](@entry_id:266134)。如果有，则获取指向该节点的指针；如果没有，则创建一个新的[叶节点](@entry_id:266134)，并获取其指针。然后，将该指针压入栈中。
2.  当遇到一个**操作符**时，从栈中弹出所需数量的操作数指针（对于二元操作符是两个）。这些弹出的指针将成为新操作节点的子节点。
3.  在创建新的操作节点之前，检查是否已存在一个具有相同操作符和完全相同的（指针相等的）有序子节点的节点。
    *   如果存在，则重用该节点。将其指针压入栈中。
    *   如果不存在，则创建一个新的内部节点，其操作符为当前操作符，子节点为刚从栈中弹出的节点。然后将指向这个新节点的指针压入栈中。

让我们通过处理后缀表达式 $a \ b \ + \ c \ d \ + \ *$ 来具体说明。[@problem_id:3641821]
-   处理 $a$ 和 $b$：创建或找到 $a$ 和 $b$ 的[叶节点](@entry_id:266134)，并将它们的指针压入栈。
-   处理第一个 $+$：弹出 $b$ 和 $a$ 的指针，创建一个新的节点 $N_1$，表示 $a+b$。将 $N_1$ 的指针压入栈。
-   处理 $c$ 和 $d$：创建或找到 $c$ 和 $d$ 的叶节点，并将它们的指针压入栈。
-   处理第二个 $+$：弹出 $d$ 和 $c$ 的指针。此时，我们需要检查是否存在一个与即将创建的节点 $N_{new} = \text{Node}(+, \text{Node}(c), \text{Node}(d))$ 等价的现有节点。唯一的加法节点是 $N_1 = \text{Node}(+, \text{Node}(a), \text{Node}(b))$。由于它们的子节点指针不同（$\text{Node}(c)$ 不等于 $\text{Node}(a)$），它们不满足**结构相等性（structural equality）**。因此，我们必须创建一个新的节点 $N_2$ 来表示 $c+d$。将 $N_2$ 的指针压入栈。
-   处理 $*$：弹出 $N_2$ 和 $N_1$ 的指针，创建一个新的根节点 $N_3$ 来表示 $(a+b) \times (c+d)$。

在这个例子中，由于没有发现结构上完全相同的子表达式，最终的 DAG 是一棵树，包含了三个操作节点。这个过程展示了最基本的 CSE 规则：只有当操作符和子节点指针完全相同时，节点才被重用。

#### [值编号](@entry_id:756409)与散列预留

上述栈算法对于简单的表达式流是有效的，但对于处理由独立语句组成的基本块（basic block）时，我们需要一种更强大的机制。**[值编号](@entry_id:756409)（Value Numbering）**就是这样一种技术。其核心思想是为程序中计算出的每个唯一值分配一个唯一的“[值编号](@entry_id:756409)”。如果两个计算产生相同的[值编号](@entry_id:756409)，它们就是等价的，可以进行 CSE。

在实践中，[值编号](@entry_id:756409)通常通过**散列预留（hash-consing）**来实现。编译器维护一个全局哈希表，将表达式的规范化表示映射到其[值编号](@entry_id:756409)（或直接映射到 DAG 节点）。

考虑以下三地址代码序列：[@problem_id:3641816]
1.  $t_1 = a + b$
2.  $t_2 = a + b$
3.  $t_3 = t_1 \times c$

使用[值编号](@entry_id:756409)和散列预留构建 DAG 的过程如下：
1.  **初始化**：为输入变量 $a$, $b$, $c$ 分配初始[值编号](@entry_id:756409)，例如 $\mathrm{VN}(a)=1, \mathrm{VN}(b)=2, \mathrm{VN}(c)=3$。[哈希表](@entry_id:266620)为空。
2.  **处理 $t_1 = a + b$**：
    *   获取操作数的[值编号](@entry_id:756409)：$(\mathrm{VN}(a), \mathrm{VN}(b)) \rightarrow (1, 2)$。
    *   构造一个**规范化的键（canonical key）**。由于加法是交换的，我们不能简单地使用 $(\text{`+`}, 1, 2)$ 作为键，因为 $b+a$ 会生成 $(\text{`+`}, 2, 1)$。一个标准的规范化策略是对操作数的[值编号](@entry_id:756409)进行排序，得到元组 $(1, 2)$。因此，键为 $k_1 = \langle \text{`+`}, (1, 2) \rangle$。
    *   在[哈希表](@entry_id:266620)中查找 $k_1$。未找到。
    *   创建一个新的 DAG 节点，为其分配一个新的[值编号](@entry_id:756409)，例如 $\mathrm{VN}=4$。
    *   更新[哈希表](@entry_id:266620)：$\text{table}[k_1] = 4$。
    *   记录结果变量的[值编号](@entry_id:756409)：$\mathrm{VN}(t_1) = 4$。
3.  **处理 $t_2 = a + b$**：
    *   同样，获取操作数的[值编号](@entry_id:756409) $(1, 2)$ 并构造规范化的键 $k_2 = \langle \text{`+`}, (1, 2) \rangle$。
    *   在[哈希表](@entry_id:266620)中查找 $k_2$。**找到**！哈希表返回已存在的[值编号](@entry_id:756409) $4$。
    *   这表明 $a+b$ 是一个[公共子表达式](@entry_id:747510)。我们不创建新节点，而是重用现有的。
    *   记录结果变量的[值编号](@entry_id:756409)：$\mathrm{VN}(t_2) = 4$。现在，$t_1$ 和 $t_2$ 都映射到相同的值。
4.  **处理 $t_3 = t_1 \times c$**：
    *   获取操作数的[值编号](@entry_id:756409)：$(\mathrm{VN}(t_1), \mathrm{VN}(c)) \rightarrow (4, 3)$。
    *   假设乘法不满足交换律，我们保持操作数顺序，键为 $k_3 = \langle \text{`*`}, (4, 3) \rangle$。
    *   在[哈希表](@entry_id:266620)中查找 $k_3$。未找到。
    *   创建新节点，分配[值编号](@entry_id:756409) $\mathrm{VN}=5$，更新[哈希表](@entry_id:266620)，并设置 $\mathrm{VN}(t_3) = 5$。

这个过程精确地展示了现代编译器如何通过规范化和散列来高效地识别[公共子表达式](@entry_id:747510)。

### 扩展等价性：语义规则

结构相等性是 CSE 的基础，但仅靠它会错失许多优化机会。为了更充分地利用 DAG，编译器必须理解并应用代数和语言的语义规则。

#### [交换律](@entry_id:141214)与规范化

正如[值编号](@entry_id:756409)示例所示，处理**交换律（commutativity）**是至关重要的。对于像加法或乘法这样的交换操作，表达式 $a+b$ 和 $b+a$ 应该被视为等价。实现这一点的关键在于**规范化（canonicalization）**，即为等价的表达式创建一个唯一的、标准的表示形式。

最常用的规范化方法是为操作数定义一个**确定性的全[序关系](@entry_id:138937)（deterministic total order）**，并在构造哈希键之前始终按此顺序[排列](@entry_id:136432)操作数。这个全[序关系](@entry_id:138937)必须稳定且独立于编译环境，以确保编译过程是确定性的。一个健壮的排序策略可能按以下层次进行：[@problem_id:3641785]
1.  **[类型类](@entry_id:276976)别**：例如，整数类型优先于浮点类型，[浮点](@entry_id:749453)类型优先于指针类型。
2.  **类型属性**：在同一类别内，按位宽（如 32 位、64 位）、有无符号等排序。
3.  **值类别**：常量优先于变量/计算结果。
4.  **值本身**：如果都是常量，则按其数值大小排序。
5.  **唯一标识符**：如果以上都相同（例如，两个不同的计算结果具有相同的类型），则使用一个稳定的、确定性的标识符（如 SSA 变量名或 DAG 节点 ID）作为最终的决胜局。

通过这种严格的规范化，编译器可以可靠地识别出如 $a+b$ 和 $b+a$ 这样的等价表达式，而无需复杂的[模式匹配](@entry_id:137990)。

#### [浮点](@entry_id:749453)语义与语义标志

优化并非总是安全的，尤其是在处理[浮点数](@entry_id:173316)时。[IEEE 754](@entry_id:138908) 浮点标准包含一些违反直观代数定律的特殊情况。例如，`NaN`（Not a Number）值的存在破坏了等式的**[自反性](@entry_id:137262)（reflexivity）**。根据标准，$x == x$ 在 $x$ 为 `NaN` 时求值为 `false`。[@problem_id:3641853]

这意味着，编译器不能盲目地将表达式 $x == x$ 优化（或称为“折叠”）为常量 `true`，因为如果 $x$ 在运行时可能是 `NaN`，这种优化会改变程序的行为。

为了在保证安全的前提下进行更激进的优化，编译器引入了**语义标志（semantic flags）**。这些标志是附加在 IR 节点上的[元数据](@entry_id:275500)，用于承载关于值的额外信息。例如：
-   **`NoNaN`**：此标志断言一个[浮点](@entry_id:749453)值永远不会是 `NaN`。如果变量 $x$ 带有 `NoNaN` 标志，那么将 $x == x$ 折叠为 `true` 就是安全的。
-   **`CommuteAdd` / `Reassociate`**（通常合称为 “fast-math” 标志）：标准浮[点加法](@entry_id:177138)并非完全可交换或可结合的（由于舍入误差和特殊值处理）。这些标志明确授权编译器可以进行交换或重组操作，从而启用前面讨论的基于排序的规范化。

这些标志允许程序员或编译器前端（基于语言标准或分析）向后端优化器传递更高层次的语义信息，从而在特定条件下解锁更强大的优化。[@problem_id:3641853]

### 超越纯表达式：处理副作用与控制流

到目前为止，我们讨论的都是纯粹的、无副作用的计算。然而，真实的程序充满了副作用（如变量赋值、I/O）和复杂的控制流。一个实用的 DAG 表示必须能够精确地建模这些情况，以防止不正确的优化。

#### 副作用与[求值顺序](@entry_id:749112)

考虑 C 语言中的表达式 $x++ + y + x$。这个表达式的语义因**副作用（side effect）**和严格的**从左到右求值（left-to-right evaluation）**顺序而变得复杂。后置自增操作符 `x++` 的求值结果是 $x$ 的旧值，但它会产生一个副作用：在计算下一个操作数（即 $y$）之前，将 $x$ 的值加一。[@problem_id:3641806]

因此，表达式中的第一个 $x$（来自 `x++`）指的是 $x$ 的原始值，而第二个 $x$ 指的是递增后的值。简单地将两个 $x$ 合并为 DAG 中的一个节点是错误的。

为了正确建模这种情况，现代编译器通常结合使用两种技术：
1.  **[静态单赋值形式](@entry_id:755286)（Single Static Assignment, SSA）**：在 SSA 形式中，每个变量只被赋值一次。当一个变量被修改时，会创建一个新的版本。对于 $x++$，我们会引入两个版本：$x_0$（原始值）和 $x_1$（递增后的值，$x_1 = x_0 + 1$）。表达式因此被改写为 $(x_0 \text{ in value}) + y + x_1$。由于 $x_0$ 和 $x_1$ 是不同的 SSA 变量，CSE 不会错误地合并它们。
2.  **控制边或效应链（Control Edges or Effect Chains）**：为了强制执行[求值顺序](@entry_id:749112)，DAG 中会引入一种特殊的边，称为**控制边**或**效应边**。这些边不传递数据，只表示顺序依赖。一个有副作用的操作（如 `x++`）会消耗一个“效应标记”并产生一个新的，任何必须在该副作用之后执行的操作都必须依赖于这个新的效应标记。这形成了一条效应链，确保了副作用的正确排序。

#### 隐式[控制流](@entry_id:273851)与陷阱

表达式内部也可能包含隐式控制流。一个典型的例子是 C 语言中的短路[逻辑运算符](@entry_id:142505) ``。在表达式 $p \ \\ \ (p->f)$ 中，如果 $p$ 为空指针（值为 0），则 `` 的左操作数为假，整个表达式的结果为假，右操作数 `p->f` **永远不会被求值**。[@problem_id:3641846]

这种行为至关重要，因为它避免了当 $p$ 为空时对 `p->f` 的解引用，这是一个会导致程序崩溃的**陷阱（trapping）**操作。因此，对 `p->f` 的求值是**[控制依赖](@entry_id:747830)于（control-dependent on）** `p != 0` 这个条件的。

在 DAG 中，这种[控制依赖](@entry_id:747830)关系必须被显式建模。这意味着 `p->f` 节点不能被自由地提前计算（即，投机执行）。任何试图将该表达式重新排序为 `(p->f)  p` 的优化都是非法的，因为它会改变程序的行为（在 $p$ 为空时引入陷阱）。

#### 内存操作：终极挑战

对内存的读写（加载和存储）是副作用中最复杂的一种。两个从相同地址的加载操作是否可以被视为[公共子表达式](@entry_id:747510)，取决于它们之间是否有存储操作可能改变该地址的值。

-   **无干预存储**：对于表达式 `*(p+2) + *(p+2)`，两个加载操作 `*(p+2)` 之间没有其他代码。因此，它们读取的是同一内存版本下的同一地址，可以安全地进行 CSE。[@problem_id:3641808]

-   **有干预存储**：考虑序列 `$a = *t; \text{store}(q, s); b = *t;`。默认情况下，编译器必须保守地假设存储到地址 $q$ 的操作可能会改变地址 $t$ 处的值。因此，第二次加载 `*t` 不能重用第一次加载的结果。
    为了解决这个问题，编译器使用**别名分析（Alias Analysis）**来判断两个指针 $t$ 和 $q$ 是否可能指向同一内存位置。
    -   **No-alias**：如果分析证明 $t$ 和 $q$ 绝不指向同一位置，那么存储操作不会影响 `*t` 的值，CSE 是安全的。
    -   **May-alias**：如果分析无法排除它们指向同一位置的可能性，编译器必须保守行事，禁止 CSE。
    -   **Must-alias**：如果分析证明 $t$ 和 $q$ 必然指向同一位置，那么第二次加载将读取刚刚存储的值 $s$。这不是 CSE，而是一种称为“存储到加载前递”的优化。

    为了在 DAG 中形式化地表示内存依赖，编译器采用**内存 SSA** 或**内存版本化**。每次存储操作都会创建一个新的“内存版本”，而加载操作则依赖于特定的内存版本。这样，两个加载操作只有在地址相同且依赖的内存版本也相同时，才被认为是等价的。[@problem_id:3641808]

-   **`volatile` 访问**：最后，某些内存访问被语言（如 C 中的 `volatile` 关键字）标记为不应被优化的。对于表达式 `*vp + *vp`（其中 `vp` 是 `volatile` 指针），程序员明确指示编译器这两个读取操作是**可观察的行为（observable behaviors）**，必须严格执行两次。即使它们读取相同的地址且之间没有存储，编译器也**绝不能**将它们合并。在 DAG 中，`volatile` 加载被视为具有不可消除的副作用，每个加载操作都必须表示为一个独立的、不可合并的节点。[@problem_id:3641795]

### DAG 的应用：代码生成与调度

构建一个精确的 DAG 本身不是目的，而是手段。一旦构建完成，DAG 就在后续的编译阶段中发挥关键作用，特别是在代码生成中。

首先，DAG 的结构直接指导**指令选择（instruction selection）**。DAG 中的每个内部节点通常对应目标机器的一条或多条指令。因此，DAG 中的内部节点总数可以作为最终生成代码大小的一个良好近似。

其次，也是更重要的一点，DAG 为**指令调度（instruction scheduling）**提供了灵活性。DAG 定义了计算之间的数据依赖关系，但它并不规定一个唯一的求值顺序。任何满足依赖关系的线性排序，即图的**拓扑排序（topological sort）**，都是一个合法的求值顺序。

这种灵活性对于优化至关重要，尤其是对于**寄存器分配（register allocation）**。不同的求值顺序会导致不同的**寄存器压力（register pressure）**，即在任何给定时刻需要同时保持在寄存器中的活跃值的数量。

考虑表达式 $(a+b)\cdot(c+d) + (a+b)\cdot e$。其 DAG 有一个共享节点 $t_1 = a+b$。一个可能的拓扑序是 $(t_1=a+b, \ t_2=c+d, \ t_3=t_1 \cdot t_2, \ t_4=t_1 \cdot e, \ t_5=t_3+t_4)$。[@problem_id:3641890]

一个好的调度策略旨在最小化峰值寄存器压力。一个著名的启发式规则（如 Sethi-Ullman 算法所体现的）是**优先计算具有更多依赖的（或“更重”）的子树**。在这个例子中，子树 $(a+b)\cdot(c+d)$ 比 $(a+b)\cdot e$ 需要更多的计算。因此，先完整计算出 $t_3=(a+b)\cdot(c+d)$ 的调度顺序通常更优。这样做可以尽早释放计算 $t_2=c+d$ 所需的中间寄存器。

通过分析可以发现，评估此表达式所需的最小峰值寄存器数量是 3。这个下界可以通过以下方式推导：在计算 $t_2=c+d$ 的某个时刻，值 $c$ 和 $d$ 必须是活跃的。同时，之前计算出的 $t_1=a+b$ 也必须保持活跃，因为它在后续的计算中仍然需要被使用。因此，在这一刻，至少需要三个寄存器来分别存放 $t_1, c, d$。通过一个精心设计的调度序列，可以证明峰值压力确实可以被控制在 3。[@problem_id:3641890]

总而言之，DAG 不仅是一种用于消除冗余计算的强大工具，它还是一种丰富的[中间表示](@entry_id:750746)，能够精确地建模复杂的语言语义，并为[代码生成](@entry_id:747434)和调度等后端优化提供关键的洞察和灵活性。