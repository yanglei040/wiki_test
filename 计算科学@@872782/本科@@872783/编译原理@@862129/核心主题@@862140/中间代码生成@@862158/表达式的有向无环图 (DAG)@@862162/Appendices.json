{"hands_on_practices": [{"introduction": "我们从一个基础练习开始。这项练习将指导你为一个简单的算术表达式构建一个有向无环图（DAG），并展示该结构如何内在地执行公共子表达式消除（CSE）。通过运用交换律和结合律等代数性质，我们可以最大化节点共享，从而最小化所需的操作数量，这是编译优化的核心目标之一。[@problem_id:3641786]", "problem": "编译器后端使用有向无环图（DAG）为基本块构建表达式表示，其中每个内部节点代表一个二元运算符，每个叶节点代表一个操作数。在这种表示中，通过确保具有相同操作数集的相同运算符应用由单个共享节点表示，来执行公共子表达式消除（CSE）。对于二元加法和乘法，利用加法和乘法具有结合律和交换律的数学事实，在确定节点身份时对操作数集进行规范化；不要使用任何其他代数变换，例如分配律或引入不存在的数字常量。假设与变量对应的叶节点不计为操作，只有二元加法和二元乘法节点计为操作。\n\n给定表达式\n$$\nx\\cdot y + z\\cdot w + x\\cdot y + z\\cdot w + t,\n$$\n根据上述规则构建具有最大化共享的表达式DAG，并确定在CSE后剩余的二元运算节点的最小数量。按顺序报告乘法节点的数量、加法节点的数量以及二元运算节点的总数。将你的最终答案表示为一个行矩阵。", "solution": "这个问题是有效的，因为它是编译器理论领域内一个明确定义的问题，具体涉及使用有向无环图（DAG）的表达式表示和通过公共子表达式消除（CSE）进行优化。DAG构建和优化的规则已明确说明。\n\n需要表示的表达式是：\n$$\nE = x \\cdot y + z \\cdot w + x \\cdot y + z \\cdot w + t\n$$\n目标是构建一个具有最大化共享的DAG，应用CSE以及加法和乘法的交换律和结合律，并计算得到的二元运算节点的最小数量。运算符节点严格为二元节点。变量 $x, y, z, w, t$ 是叶节点，不计为运算节点。\n\n首先，我们识别乘法运算。表达式包含两个不同的乘法子表达式：\n$1$. 子表达式 $x \\cdot y$ 出现了两次。由于公共子表达式消除，两个实例将在DAG中由单个共享节点表示。我们将此操作的结果表示为 $N_1 = \\text{node}(\\cdot, x, y)$。这算作一个乘法节点。\n$2$. 子表达式 $z \\cdot w$ 也出现了两次。同样，两个实例将由第二个共享节点表示。我们将其结果表示为 $N_2 = \\text{node}(\\cdot, z, w)$。这算作第二个乘法节点。\n\n问题指出，使用交换律来规范化操作数集。例如，如果表达式包含 $y \\cdot x$，它将被视为与 $x \\cdot y$ 相同。在这个问题中，重复的子表达式是相同的，因此这个规则可以直接应用。\n没有其他乘法运算。因此，乘法节点的最小数量是 $2$。\n\n接下来，我们分析加法运算。在执行乘法之后，表达式可以用节点 $N_1$、$N_2$ 和叶节点 $t$ 重写为：\n$$\nE = N_1 + N_2 + N_1 + N_2 + t\n$$\n这是一个五项之和。问题指出，我们可以使用加法的结合律和交换律来重新排列和重组这些项，以最大化共享（即，在加法中创建公共子表达式）。被相加的项的多重集是 $\\{N_1, N_1, N_2, N_2, t\\}$。\n我们可以将这个和重新排列和重组如下：\n$$\nE = (N_1 + N_2) + (N_1 + N_2) + t\n$$\n这种分组是最佳的，因为它创建了重复的子表达式 $(N_1 + N_2)$。让我们为这个加法结构构建DAG：\n$1$. 我们为公共子表达式 $N_1 + N_2$ 创建一个节点。我们称这个节点为 $N_3 = \\text{node}(+, N_1, N_2)$。这是我们的第一个加法节点。交换律的性质确保 $N_2 + N_1$ 会由同一个节点表示。\n$2$. 有了这个新节点，表达式变为 $N_3 + N_3 + t$。我们必须使用二元加法来计算它。我们可以将其分组为 $(N_3 + N_3) + t$。\n$3$. 我们为子表达式 $N_3 + N_3$ 创建一个节点。我们称这个节点为 $N_4 = \\text{node}(+, N_3, N_3)$。请注意，该节点有两个指向同一个子节点 $N_3$ 的指针。这是我们的第二个加法节点。\n$4$. 最后，我们创建DAG的根节点，它代表整个表达式。该节点计算 $N_4$ 的结果与叶节点 $t$ 的和。设其为 $N_5 = \\text{node}(+, N_4, t)$。这是我们的第三个加法节点。\n\n按照这种构造，我们使用了三个不同的加法节点：$N_3$、$N_4$ 和 $N_5$。对这五项的任何其他分组都无法用少于三个二元加法节点来实现。例如，一个简单的、不进行重组的左结合求值，如 $(((N_1+N_2)+N_1)+N_2)+t$，不会创建任何公共加法子表达式，并且需要四个加法节点。\n\n总结如下：\n- 乘法节点数量：$2$（用于 $x \\cdot y$ 和 $z \\cdot w$）。\n- 加法节点数量：$3$（用于 $(x \\cdot y + z \\cdot w)$，用于将此子表达式与自身相加，以及用于加上 $t$）。\n- 二元运算节点总数：$2 + 3 = 5$。\n\n最终答案要求按顺序提供这三个数字，并以行矩阵的形式呈现。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n2  3  5\n\\end{pmatrix}\n}\n$$", "id": "3641786"}, {"introduction": "现实世界的程序不仅仅是纯粹的算术运算，它们还与内存交互。这项练习引入了一个关键的复杂性：内存别名分析（memory aliasing）。你将学习如何在DAG中为加载（load）和存储（store）操作建模，并理解为何两个语法上完全相同的加载操作，在存在一个可能修改了该内存位置的中间存储操作时，不一定能被视为公共子表达式。[@problem_id:3641783]", "problem": "考虑两个 $32$ 位整数数组 $A$ 和 $B$，一个可能指向某个内存区域的指针 $P$，以及一个在以下直线代码片段中未被修改的整数索引 $i$。假设 $A$ 和 $B$ 均未被声明为 volatile，并且没有函数调用。代码采用静态单赋值（SSA）形式，最终计算表示为一个有向无环图（DAG），其中加载节点由地址表达式和一个代表其别名集相关抽象内存状态的内存版本标记进行注释。\n\n代码如下：\n$$\n\\begin{aligned}\nt_0 \\leftarrow A[i] \\\\\n*P \\leftarrow v \\\\\nt_1 \\leftarrow A[i] \\\\\nt_2 \\leftarrow B[i] \\\\\nx \\leftarrow t_0 + t_1 + t_2\n\\end{aligned}\n$$\n\n一项别名分析报告了以下事实：\n- $A$ 和 $B$ 是不相交的数组：$\\mathrm{NoAlias}(A, B)$。\n- 指针 $P$ 可能引用 $A$ 区域，但不引用 $B$ 区域：$\\mathrm{MayAlias}(P, A)$ 和 $\\mathrm{NoAlias}(P, B)$。\n- 索引 $i$ 在整个序列中保持不变。\n\n使用以下基本原理来推导表达式 DAG：\n- 用于表达式的有向无环图（DAG）会合并相同纯计算的节点。\n- 一次内存加载被视为一个依赖于相关抽象内存版本的节点；两次加载可以用一个共享的 DAG 节点表示，当且仅当它们从相同的内存版本读取相同的地址表达式，并且根据别名分析，在程序顺序中没有中间的存储操作可能会写入该地址。\n- 一次存储操作会更新其可能写入的别名集的抽象内存版本。\n\n在这些条件下，哪个陈述正确地描述了用于 $x$ 的 DAG 中哪些加载节点可以共享，哪些必须是不同的？\n\nA. 将两次 $A[i]$ 加载合并为一个 DAG 节点，因为它们的地址表达式相同；将 $B[i]$ 加载保留为独立节点。\n\nB. 将两次 $A[i]$ 加载保留为不同的 DAG 节点，因为中间通过 $P$ 的存储操作可能与 $A$ 别名，从而可能更新 $A[i]$；$B[i]$ 的加载是一个不受该存储影响的单一节点，因为 $P$ 不与 $B$ 别名。\n\nC. 所有三次加载都必须是不同的 DAG 节点，因为任何中间的存储操作都会强制创建一个新的全局内存版本，而不管别名信息如何。\n\nD. 将 $A[i]$ 和 $B[i]$ 的加载合并为一个 DAG 节点，因为它们共享相同的索引 $i$；别名分析结果与加载的 DAG 节点共享无关。", "solution": "问题陈述被评估为有效。这是一个基于编译器设计既定原则的适定问题，特别涉及到通过有向无环图（DAG）进行代码优化以及使用别名分析来处理内存操作。所给条件自洽、一致，并且足以推导出唯一解。\n\n这个问题的核心是确定哪些计算是冗余的，并且可以在 DAG 中用单个节点表示。对于加载操作，这由公共子表达式消除（CSE）原则决定，在存在内存操作的情况下，该原则必须由别名分析来指导。\n\n让我们遵循所提供的规则，追踪表达式 $x \\leftarrow t_0 + t_1 + t_2$ 的 DAG 构建过程。关键是追踪每个相关别名集的抽象内存状态，或称“版本”。别名分析将内存划分为至少两个不相交的关注集：一个包含数组 $A$，另一个包含数组 $B$。指针 $P$ 可能与包含 $A$ 的集合别名，但不会与包含 $B$ 的集合别名。\n\n设 $M_A$ 为包含数组 $A$ 的别名集的内存版本标记，设 $M_B$ 为包含数组 $B$ 的别名集的内存版本标记。\n\n最初，在代码片段执行之前，设内存版本为 $M_A^{(0)}$ 和 $M_B^{(0)}$。\n\n1.  **指令：$t_0 \\leftarrow A[i]$**\n    这是一个加载操作。地址由 $A$ 的基地址和索引 $i$ 决定。为此加载创建一个 DAG 节点。此节点依赖于地址表达式（我们可表示为 $\\mathrm{addr}(A[i])$）及其别名集的当前内存版本 $M_A^{(0)}$。此加载的节点是 $\\mathrm{Load}(\\mathrm{addr}(A[i]), M_A^{(0)})$。变量 $t_0$ 现在与此节点产生的值相关联。\n\n2.  **指令：$*P \\leftarrow v$**\n    这是一个存储操作。我们必须查阅别名分析结果来确定它对我们内存版本的影响。\n    -   $\\mathrm{MayAlias}(P, A)$：通过指针 $P$ 的存储*可能*会修改 $A$ 内存区域内的一个位置。因为修改是可能的，所以保守的编译器必须假设此别名集的内存状态已改变。因此，内存版本 $M_A$ 被更新。设新版本为 $M_A^{(1)}$。\n    -   $\\mathrm{NoAlias}(P, B)$：通过指针 $P$ 的存储*不会*修改 $B$ 内存区域内的任何位置。编译器可以对此确定无疑。因此，$B$ 的内存状态不受影响，其版本仍为 $M_B^{(0)}$。\n    此指令后，活动的内存版本是 $M_A^{(1)}$ 和 $M_B^{(0)}$。\n\n3.  **指令：$t_1 \\leftarrow A[i]$**\n    这是从地址 $\\mathrm{addr}(A[i])$ 的第二次加载。加载操作共享 DAG 节点的规则是它们必须从相同的地址和相同的内存版本读取。\n    -   地址表达式 $\\mathrm{addr}(A[i])$ 与第一次加载相同。\n    -   然而，这次加载发生在对 $*P$ 的存储之后。$A$ 的别名集的当前内存版本是 $M_A^{(1)}$。\n    因此，这次加载由节点 $\\mathrm{Load}(\\mathrm{addr}(A[i]), M_A^{(1)})$ 表示。\n    由于 $M_A^{(1)} \\ne M_A^{(0)}$，此节点与为 $t_0$ 创建的节点是不同的。两次从 $A[i]$ 的加载不能被合并。\n\n4.  **指令：$t_2 \\leftarrow B[i]$**\n    这是从地址 $\\mathrm{addr}(B[i])$ 的一次加载。\n    -   地址表达式 $\\mathrm{addr}(B[i])$ 与 $\\mathrm{addr}(A[i])$ 不同，因为 $\\mathrm{NoAlias}(A, B)$。因此，仅凭这一点，这次加载就不能与从 $A[i]$ 的加载共享一个节点。\n    -   这次加载依赖于 $B$ 的别名集的内存版本，即 $M_B^{(0)}$。对 $*P$ 的存储没有影响这个版本。\n    此加载的节点是 $\\mathrm{Load}(\\mathrm{addr}(B[i]), M_B^{(0)})$。\n\n5.  **指令：$x \\leftarrow t_0 + t_1 + t_2$**\n    这个表达式组合了三次加载的结果。DAG 将包含加法操作符节点，其输入为上面推导出的三个不同的加载节点。\n\n总而言之，我们在 DAG 中需要三个不同的加载节点：\n-   一个用于 $t_0 \\leftarrow A[i]$，依赖于内存版本 $M_A^{(0)}$。\n-   第二个，不同的节点用于 $t_1 \\leftarrow A[i]$，依赖于内存版本 $M_A^{(1)}$。\n-   第三个，不同的节点用于 $t_2 \\leftarrow B[i]$，依赖于不同的地址和内存版本 $M_B^{(0)}$。\n\n现在，我们根据这个推导过程来评估每个选项。\n\n**A. 将两次 $A[i]$ 加载合并为一个 DAG 节点，因为它们的地址表达式相同；将 $B[i]$ 加载保留为独立节点。**\n这个陈述是**不正确**的。虽然两次从 $A[i]$ 加载的地址表达式确实相同，但这并非合并它们 DAG 节点的充分条件。中间的存储操作 $*P \\leftarrow v$ 可能与 $A$ 别名（$\\mathrm{MayAlias}(P, A)$），这迫使编译器假设 $A$ 的内存状态发生了变化。第一次加载依赖于存储*之前*的内存状态，而第二次加载依赖于存储*之后*的内存状态。由于内存版本不同，这些节点不能被合并。\n\n**B. 将两次 $A[i]$ 加载保留为不同的 DAG 节点，因为中间通过 $P$ 的存储操作可能与 $A$ 别名，从而可能更新 $A[i]$；$B[i]$ 的加载是一个不受该存储影响的单一节点，因为 $P$ 不与 $B$ 别名。**\n这个陈述是**正确**的。它准确地描述了情况。两次从 $A[i]$ 的加载必须由不同的节点表示，因为中间的存储操作 $*P \\leftarrow v$ 由于 $\\mathrm{MayAlias}(P, A)$ 这个事实，对于从 $A$ 的别名集加载而言，构成了一个“内存屏障”。$A[i]$ 的值必须被重新加载。该陈述也正确地指出，从 $B[i]$ 的加载不受此特定存储的影响，因为别名分析保证了没有重叠（$\\mathrm{NoAlias}(P, B)$）。\n\n**C. 所有三次加载都必须是不同的 DAG 节点，因为任何中间的存储操作都会强制创建一个新的全局内存版本，而不管别名信息如何。**\n这个陈述是**不正确**的。虽然“所有三次加载都必须是不同的”这个结论是正确的，但其提供的推理是有缺陷的。该陈述声称“任何中间的存储操作都会强制创建一个新的全局内存版本，而不管别名信息如何”。这是错误的。细粒度别名分析的全部目的就是为了*避免*将内存视为一个单一的整体块。在这里，对 $*P$ 的存储更新了 $A$ 的别名集的内存版本，但*没有*更新 $B$ 的别名集的内存版本。如果规则如 C 中所述，那么别名分析对于此项优化将毫无用处。\n\n**D. 将 $A[i]$ 和 $B[i]$ 的加载合并为一个 DAG 节点，因为它们共享相同的索引 $i$；别名分析结果与加载的 DAG 节点共享无关。**\n这个陈述是**不正确**的。它在两个基本点上存在缺陷。首先，从 $A[i]$ 和 $B[i]$ 的加载访问的是不同的内存地址，因为 $A$ 和 $B$ 是不相交的数组（$\\mathrm{NoAlias}(A, B)$）。加载的 DAG 节点只有在地址相同时才能共享。共享索引 $i$ 是无关紧要的。其次，“别名分析结果无关紧要”的说法是完全错误的，并且与内存感知编译器优化的基本原则以及问题陈述本身提供的规则相矛盾。别名分析是确定中间存储是否使先前加载无效的关键组成部分。", "answer": "$$\\boxed{B}$$", "id": "3641783"}, {"introduction": "DAG的用途远不止识别冗余计算，它更是生成高效代码的蓝图。这项练习将展示DAG的拓扑排序如何对应于一个有效的指令序列。通过探索不同的指令调度方案，你将分析它们对关键硬件资源——寄存器——的影响，并学习如何计算和最小化寄存器压力。[@problem_id:3641827]", "problem": "给定算术表达式 $E = a \\cdot b + a \\cdot c + a \\cdot d$。将 $E$ 建模为一个表达式有向无环图（DAG），其中每个内部节点是二元运算符，每个叶节点是变量。拓扑序是内部节点的任意一种线性化，该线性化遵循子节点先于父节点的约束。考虑一个简单的加载/存储机器模型，其中每个二元算术运算都要求两个操作数都在寄存器中，并将结果覆盖其中一个操作数寄存器。变量 $a$、$b$、$c$ 和 $d$ 最初存储在内存中，在使用前必须加载到寄存器中。不允许重算内部节点，也不允许溢出临时变量；也就是说，一旦计算出内部节点的临时结果，它必须保留在寄存器中，直到其最后一次使用。将寄存器压力定义为在与所选拓扑序相对应的直线求值调度中，任何程序点上同时存在的、寄存器中的活跃值的最大数量。\n\n使用 $E$ 的DAG，展示两种不同的有效内部节点拓扑序，它们分别对应两种直线调度：一种是先计算所有乘积，然后执行加法；另一种是在生成乘积的同时交错进行加法，以累积一个运行总和。对于每种调度，根据上述模型计算确切的寄存器压力，并从第一性原理出发证明你的计数。最后，确定在所有有效的DAG拓扑序中，可能的最小寄存器压力是多少。将你的最终答案表示为一个整数。", "solution": "该问题陈述是编译器理论中一个明确定义好的练习，具体涉及表达式求值的指令调度和寄存器分配。有向无环图（DAG）、拓扑排序、寄存器压力和简化的机器模型等概念都是标准的，并为该问题提供了科学基础。给定的条件是自洽、一致且足以推导出一个唯一解的。因此，该问题被认为是有效的。\n\n算术表达式为 $E = a \\cdot b + a \\cdot c + a \\cdot d$。我们将其建模为一个DAG。假设加法具有标准的从左到右结合性，该表达式被解析为 $E = ((a \\cdot b) + (a \\cdot c)) + (a \\cdot d)$。该DAG由变量 $a, b, c, d$ 的叶节点和运算符的内部节点组成。值得注意的是，变量 $a$ 是一个公共子表达式，被三个乘法节点共享。内部节点是：\n- $N_1 = a \\cdot b$\n- $N_2 = a \\cdot c$\n- $N_3 = a \\cdot d$\n- $N_4 = N_1 + N_2$\n- $N_5 = N_4 + N_3$ (这是DAG的根节点)\n\n指定的机器模型是一种加载/存储架构，其中二元运算的形式为 `OP R_dest, R_src`，它计算 `R_dest \\leftarrow R_dest op R_src`。这意味着目标寄存器中的值被结果覆盖。一个值从其定义（被加载或计算）开始，直到其最后一次使用为止，被认为是活跃的。寄存器压力是在求值调度中任何一点上必须保存在寄存器中的同时活跃值的最大数量。我们不允许将临时结果溢出到内存中。\n\n我们需要分析与内部节点 $\\{N_1, N_2, N_3, N_4, N_5\\}$ 的两种不同拓扑序相对应的两种求值调度。依赖关系是 $N_1$ 和 $N_2$ 必须在 $N_4$ 之前计算，而 $N_4$ 和 $N_3$ 必须在 $N_5$ 之前计算。\n\n**调度1：先计算所有乘积，然后执行加法。**\n\n此策略的一个有效拓扑序是 $(N_1, N_2, N_3, N_4, N_5)$。相应的指令调度和活跃性分析如下。我们将变量 $x$ 的值表示为 $x$，节点 $N_i$ 的临时结果表示为 $t_i$。在每一步跟踪寄存器中的活跃值集合。\n\n1. `LOAD R1, a` --- 活跃值: $\\{a\\}$。数量 = $1$。寄存器 $R_1$ 保存 $a$。我们将 $a$ 保留在 $R_1$ 中，因为所有三个乘积都需要它。\n2. `LOAD R2, b` --- 活跃值: $\\{a, b\\}$。数量 = $2$。$R_1$ 中有 $a$，$R_2$ 中有 $b$。\n3. `MUL R2, R1` --- $R_2 \\leftarrow R_2 \\cdot R_1$ ($b \\cdot a$)。结果 $t_1$ 在 $R_2$ 中。值 $b$ 被消耗（最后一次使用）。活跃值: $\\{a, t_1\\}$。数量 = $2$。$R_1$ 中有 $a$，$R_2$ 中有 $t_1$。\n4. `LOAD R3, c` --- 活跃值: $\\{a, t_1, c\\}$。数量 = $3$。$R_1(a)$, $R_2(t_1)$, $R_3(c)$。\n5. `MUL R3, R1` --- $R_3 \\leftarrow R_3 \\cdot R_1$ ($c \\cdot a$)。结果 $t_2$ 在 $R_3$ 中。值 $c$ 被消耗。活跃值: $\\{a, t_1, t_2\\}$。数量 = $3$。$R_1(a)$, $R_2(t_1)$, $R_3(t_2)$。\n6. `LOAD R4, d` --- 活跃值: $\\{a, t_1, t_2, d\\}$。数量 = $4$。$R_1(a)$, $R_2(t_1)$, $R_3(t_2)$, $R_4(d)$。**这是压力最大的点。**\n7. `MUL R4, R1` --- $R_4 \\leftarrow R_4 \\cdot R_1$ ($d \\cdot a$)。结果 $t_3$ 在 $R_4$ 中。值 $d$ 和 $a$ 被消耗（这是 $a$ 的最后一次使用）。寄存器 $R_1$ 现在空闲。活跃值: $\\{t_1, t_2, t_3\\}$。数量 = $3$。$R_2(t_1)$, $R_3(t_2)$, $R_4(t_3)$。\n8. `ADD R2, R3` --- $R_2 \\leftarrow R_2 + R_3$ ($t_1 + t_2$)。结果 $t_4$ 在 $R_2$ 中。值 $t_1, t_2$ 被消耗。寄存器 $R_3$ 现在空闲。活跃值: $\\{t_4, t_3\\}$。数量 = $2$。$R_2(t_4)$, $R_4(t_3)$。\n9. `ADD R2, R4` --- $R_2 \\leftarrow R_2 + R_4$ ($t_4 + t_3$)。结果 $t_5$（最终结果）在 $R_2$ 中。值 $t_4, t_3$ 被消耗。寄存器 $R_4$ 现在空闲。活跃值: $\\{t_5\\}$。数量 = $1$。\n\n同时活跃值的最大数量是 $4$。因此，此调度的寄存器压力是 $4$。\n\n**调度2：将加法与乘法交错进行。**\n\n此策略的一个有效拓扑序是 $(N_1, N_2, N_4, N_3, N_5)$。这对应于先计算 $(a \\cdot b + a \\cdot c)$，然后再加上 $a \\cdot d$。\n\n1. `LOAD R1, a` --- 活跃值: $\\{a\\}$。数量 = $1$。\n2. `LOAD R2, b` --- 活跃值: $\\{a, b\\}$。数量 = $2$。\n3. `MUL R2, R1` --- 计算 $t_1 = b \\cdot a$。值 $b$ 被消耗。活跃值: $\\{a, t_1\\}$。数量 = $2$。$R_1(a)$, $R_2(t_1)$。\n4. `LOAD R3, c` --- 活跃值: $\\{a, t_1, c\\}$。数量 = $3$。$R_1(a)$, $R_2(t_1)$, $R_3(c)$。\n5. `MUL R3, R1` --- 计算 $t_2 = c \\cdot a$。值 $c$ 被消耗。活跃值: $\\{a, t_1, t_2\\}$。数量 = $3$。$R_1(a)$, $R_2(t_1)$, $R_3(t_2)$。\n6. `ADD R2, R3` --- 计算 $t_4 = t_1 + t_2$。值 $t_1, t_2$ 被消耗。寄存器 $R_3$ 被释放。活跃值: $\\{a, t_4\\}$。数量 = $2$。$R_1(a)$, $R_2(t_4)$。\n7. `LOAD R3, d` --- 活跃值: $\\{a, t_4, d\\}$。数量 = $3$。$R_1(a)$, $R_2(t_4)$, $R_3(d)$。\n8. `MUL R3, R1` --- 计算 $t_3 = d \\cdot a$。值 $d, a$ 被消耗。寄存器 $R_1$ 被释放。活跃值: $\\{t_4, t_3\\}$。数量 = $2$。$R_2(t_4)$, $R_3(t_3)$。\n9. `ADD R2, R3` --- 计算 $t_5 = t_4 + t_3$。值 $t_4, t_3$ 被消耗。寄存器 $R_3$ 被释放。活跃值: $\\{t_5\\}$。数量 = $1$。\n\n此调度中同时活跃值的最大数量是 $3$。因此，此调度的寄存器压力是 $3$。\n\n**可能的最小寄存器压力**\n\n我们已经展示了一个压力为 $3$ 的调度。现在我们证明不可能实现更低的压力（即压力为 $2$）。\n\n假设可以使用最多 $2$ 个寄存器来执行求值。考虑第一个乘积的计算，例如 $N_1 = a \\cdot b$。可以使用序列 `LOAD R1, a; LOAD R2, b; MUL R1, R2`，这会使结果 $t_1$ 存入 $R_1$，并且 $R_2$ 空闲。到目前为止，我们最多使用了 $2$ 个寄存器。此后，$t_1$ 是活跃的，并占用一个寄存器，比如 $R_1$。\n\n要完成整个表达式的求值，必须计算另一个乘积，例如 $N_2 = a \\cdot c$。要计算 $N_2$，其操作数 $a$ 和 $c$ 必须被加载到寄存器中。\n- $t_1$ 是活跃的，必须保留在 $R_1$ 中（因为不允许溢出）。\n- 在我们压力为 $2$ 的假设下，我们只有一个可用的寄存器 $R_2$。\n- 我们可以用 `LOAD R2, c` 将其中一个操作数（比如 $c$）加载到 $R_2$ 中。\n- 此时，$R_1$ 保存着 $t_1$，$R_2$ 保存着 $c$。两个寄存器都被占用。\n- 要执行乘法 $a \\cdot c$，值 $a$ 也必须在寄存器中。然而，没有空闲的寄存器了。当前寄存器中的值 $t_1$ 和 $c$ 与 $a$ 是不同的（在一般情况下）。\n\n因此，在计算出一个临时乘积（必须保持活跃）并准备计算第二个乘积时，我们需要同时为三个不同的值准备寄存器：第一个临时结果（例如 $t_1$），以及下一个乘积的两个操作数（例如 $a$ 和 $c$）。这至少需要 $3$ 个寄存器。\n\n寄存器压力可以为 $2$ 的假设导致了矛盾。因此，最小可能寄存器压力必须大于 $2$。由于我们已经明确地构建了一个寄存器压力为 $3$ 的调度，因此在所有有效的拓扑序中，最小可能寄存器压力为 $3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3641827"}]}