{"hands_on_practices": [{"introduction": "在将源代码转换为中间表示（IR）时，首要任务是确保语义的等价性。一个看似简单的语句，其背后可能隐藏着复杂的求值顺序和副作用规则。本练习将通过一个复合赋值语句，探讨如何利用四元式和三元式来精确地表示运算的顺序和副作用，这是保证编译器正确性的基石。[@problem_id:3665452]", "problem": "一个编译器前端接收到复合赋值语句 $a \\mathrel{+}= b \\mathrel{+}= c$。该语言的语义要求，在对外部复合赋值 $a \\mathrel{+}= (\\cdot)$ 进行求值之前，必须先对右侧的复合赋值 $b \\mathrel{+}= c$ 进行完全求值和提交（即，更新 $b$ 的值）。所有变量都表示一个环中的标量值，在该环中加法是封闭且无副作用的，并且赋值操作会原子性地更新程序变量而不会重排。假设在执行该语句之前的初始状态为 $a = a_0$、 $b = b_0$、 $c = c_0$，其中 $a_0$、$b_0$ 和 $c_0$ 是表示初始值的符号。\n\n使用中间表示的核心定义：\n- 在四元式中，每条指令是一个四元组 $(\\text{op}, \\text{arg}_1, \\text{arg}_2, \\text{result})$。\n- 在三元式中，每条指令是一个三元组 $(\\text{op}, \\text{arg}_1, \\text{arg}_2)$，指令 $i$ 的结果由其位置引用 $(i)$ 表示。要将计算值存入命名变量，请使用存储形式 $(\\text{store}, v, x)$，其中 $v$ 是值，$x$ 是目标符号。\n- 在间接三元式中，一个额外的指针数组将执行顺序位置映射到三元式索引，从而通过指针数组重定向对 $(i)$ 的引用，在代码移动下保持语义。\n\n任务：根据上述语言语义，推导出一个实现语句 $a \\mathrel{+}= b \\mathrel{+}= c$ 的语义正确的四元式序列和一个语义正确的三元式序列（并解释间接三元式如何在代码移动下保持正确性），过程中不得进行会违反这些语义的代数简化或重排。然后，从正确消歧的三元式序列中，推断出 $a$ 的最终值（用 $a_0$、$b_0$ 和 $c_0$ 表示）。\n\n请提供 $a$ 的最终值（表示为 $a_f$）关于 $a_0$、$b_0$ 和 $c_0$ 的单一封闭形式解析表达式作为你的最终答案。无需四舍五入。不要包含任何单位。", "solution": "该问题要求为语句 $a \\mathrel{+}= b \\mathrel{+}= c$ 推导中间表示，并确定 $a$ 的最终值。对问题陈述的验证证实了其在编译原理原则内的合理性、自洽性和可形式化性。\n\n首先，我们必须正确解释给定复合赋值语句的语义。在像 C、C++ 和 Java 这样的语言中，赋值运算符是右结合的。因此，表达式 $a \\mathrel{+}= b \\mathrel{+}= c$ 被解析为 $a \\mathrel{+}= (b \\mathrel{+}= c)$。问题陈述提供了与此解释一致的显式语义：“在对外部复合赋值 $a \\mathrel{+}= (\\cdot)$ 进行求值之前，必须先对右侧的复合赋值 $b \\mathrel{+}= c$ 进行完全求值和提交（即，更新 $b$ 的值）。”\n\n这规定了一个精确的操作序列：\n1.  首先对内部表达式 $b \\mathrel{+}= c$ 进行求值。此操作计算 $b$ 和 $c$ 的当前值之和，然后将 $b$ 的值更新（提交）为此和。\n2.  表达式 $(b \\mathrel{+}= c)$ 的值是更新后 $b$ 的新值。\n3.  接下来对外部表达式 $a \\mathrel{+}= (\\cdot)$ 进行求值。它使用 $a$ 的当前值和由内部表达式产生的值。\n4.  此操作计算和，然后将 $a$ 的值更新为此和。\n\n设变量的初始值为 $a_0$、$b_0$ 和 $c_0$。我们可以逐步跟踪求值过程：\n-   **步骤 1：求值 $b \\mathrel{+}= c$。**\n    -   计算和：$b_0 + c_0$。\n    -   更新 $b$：$b$ 的新值变为 $b_0 + c_0$。\n    -   此表达式的结果是赋的值，即 $b_0 + c_0$。\n\n-   **步骤 2：求值 $a \\mathrel{+}= (b_0 + c_0)$。**\n    -   此时 $a$ 的值仍为其初始值 $a_0$。\n    -   计算和：$a_0 + (b_0 + c_0)$。\n    -   更新 $a$：$a$ 的最终值变为 $a_0 + b_0 + c_0$。\n\n通过这种语义分析，我们可以推导出中间表示。\n\n**四元式表示**\n四元式是一种四字段结构 $(\\text{op}, \\text{arg}_1, \\text{arg}_2, \\text{result})$。临时变量被显式命名（例如，$t_1, t_2$）。\n\n1.  为了求值 $b \\mathrel{+}= c$，我们首先计算和。我们将其存储在临时变量 $t_1$ 中。\n    $$(\\text{add}, b, c, t_1)$$\n    这计算出 $t_1 \\leftarrow b + c$。此时，$b$ 和 $c$ 持有其初始值 $b_0$ 和 $c_0$，所以 $t_1$ 持有 $b_0 + c_0$。\n\n2.  接下来，我们必须将这个值提交给 $b$。这是一个赋值或移动操作。\n    $$(\\text{mov}, t_1, \\_, b)$$\n    这会更新 $b$ 使得 $b \\leftarrow t_1$。现在，变量 $b$ 持有值 $b_0 + c_0$。下划线 `_` 表示一个未使用的参数字段。\n\n3.  现在我们求值外部赋值 $a \\mathrel{+}= \\dots$。右侧是内部表达式的结果，即存储在 $t_1$ 中的值。我们将 $a$ 的当前值与 $t_1$ 相加。我们将其存储在第二个临时变量 $t_2$ 中。\n    $$(\\text{add}, a, t_1, t_2)$$\n    这计算出 $t_2 \\leftarrow a + t_1$。此时，$a$ 持有其初始值 $a_0$，而 $t_1$ 持有 $b_0 + c_0$。因此，$t_2$ 持有 $a_0 + (b_0 + c_0)$。\n\n4.  最后，我们将此结果提交给 $a$。\n    $$(\\text{mov}, t_2, \\_, a)$$\n    这会更新 $a$ 使得 $a \\leftarrow t_2$。变量 $a$ 现在持有其最终值。\n\n完整的、语义正确的四元式序列是：\n1.  $(\\text{add}, b, c, t_1)$\n2.  $(\\text{mov}, t_1, \\_, b)$\n3.  $(\\text{add}, a, t_1, t_2)$\n4.  $(\\text{mov}, t_2, \\_, a)$\n\n**三元式表示**\n三元式是一种三字段结构 $(\\text{op}, \\text{arg}_1, \\text{arg}_2)$。结果不存储在显式临时变量中，而是通过计算它们的指令的位置（索引）来引用，表示为 $(i)$。对于向命名变量的赋值，需要一个单独的 `store` 指令。\n\n1.  第一个操作是 $b$ 和 $c$ 的加法。\n    $$(0): (\\text{add}, b, c)$$\n    此操作的结果被隐式引用为 $(0)$。它对应于 $b_0 + c_0$。\n\n2.  必须将此结果存储在 $b$ 中，以满足 $b \\mathrel{+}= c$ 的语义。\n    $$(1): (\\text{store}, (0), b)$$\n    该指令获取指令 $(0)$ 的结果，并将其存储在变量 $b$ 的内存位置。此指令之后，$b$ 被更新。\n\n3.  接下来，我们执行外部赋值 $a \\mathrel{+}= \\dots$ 的加法。这涉及将 $a$ 的当前值与内部表达式的结果相加，内部表达式的结果即指令 $(0)$ 的结果。\n    $$(2): (\\text{add}, a, (0))$$\n    此操作的结果，引用为 $(2)$，对应于 $a_0 + (b_0 + c_0)$。\n\n4.  最后，必须将此结果存储在 $a$ 中。\n    $$(3): (\\text{store}, (2), a)$$\n    该指令获取指令 $(2)$ 的结果，并将其存储在变量 $a$ 中。\n\n完整的、语义正确的三元式序列是：\n- $(0): (\\text{add}, b, c)$\n- $(1): (\\text{store}, (0), b)$\n- $(2): (\\text{add}, a, (0))$\n- $(3): (\\text{store}, (2), a)$\n\n**间接三元式表示**\n间接三元式增加了一个间接层：一个指向三元式的指针列表决定了执行顺序。三元式表本身保持不变。对于上面推导的序列，三元式表将包含四个指令，而执行顺序将由一个指针数组表示。\n\n-   **三元式表：**\n    -   $T_0: (\\text{add}, b, c)$\n    -   $T_1: (\\text{store}, (0), b)$\n    -   $T_2: (\\text{add}, a, (0))$\n    -   $T_3: (\\text{store}, (2), a)$\n\n-   **执行指针数组：** `[0, 1, 2, 3]`\n\n这种间接性的目的是为了便于代码优化。优化器只需通过排列指针数组就可以重排指令，而无需改变三元式表或其中的引用（如此处指令 $T_2$ 中对 $(0)$ 的引用）。对于这个具体问题，数据依赖是严格的：$(1)$ 依赖于 $(0)$，$(2)$ 依赖于 $(0)$，而 $(3)$ 依赖于 $(2)$。因此，$(0)$ 必须在 $(1)$ 和 $(2)$ 之前，而 $(2)$ 必须在 $(3)$ 之前。这四条指令之间不可能进行任何相对重排而不违反语义。然而，如果这些指令是包含独立计算的更大代码块的一部分，间接三元式表示将允许调度器将那些独立的指令与此序列交错执行，以提高指令级并行度，这只需修改指针数组即可。其正确性得以保持，因为三元式 $T_2$ 中的引用 $(0)$ 始终指向 $T_0$ 的结果，无论 $T_0$ 和 $T_2$ 在执行序列中被放置在何处（只要数据依赖关系得到遵守）。\n\n**$a$ 的最终值**\n为了找到 $a$ 的最终值（表示为 $a_f$），我们在初始状态为 $a=a_0$、$b=b_0$、$c=c_0$ 的情况下跟踪三元式序列的执行。\n\n-   指令 $(0): (\\text{add}, b, c)$ 求值为 $b_0 + c_0$。引用 $(0)$ 的值为 $b_0 + c_0$。\n-   指令 $(1): (\\text{store}, (0), b)$ 更新程序状态的内部模型。与变量 $b$ 关联的值变为 $b_0 + c_0$。\n-   指令 $(2): (\\text{add}, a, (0))$ 求值为 $a + \\text{value}(0)$。 $a$ 的值是其初始值 $a_0$。 $(0)$ 的值是 $b_0 + c_0$。结果是 $a_0 + (b_0 + c_0)$。引用 $(2)$ 的值是 $a_0 + b_0 + c_0$。\n-   指令 $(3): (\\text{store}, (2), a)$ 更新程序状态。与变量 $a$ 关联的值变为 $(2)$ 的值。\n\n因此，$a$ 的最终值为：\n$$a_f = a_0 + b_0 + c_0$$\n这个结果与我们最初的语义分析一致。关键在于复合赋值 `b += c` 会更新 `b` 并求值为 `b` 的*新*值，然后该新值被用于 `a += ...` 操作。", "answer": "$$\\boxed{a_{0} + b_{0} + c_{0}}$$", "id": "3665452"}, {"introduction": "编程语言中的副作用，尤其是在数组索引和指针运算中，是编译器设计中的一个经典难题。一个微小的疏忽就可能导致“差一错误”(off-by-one error)。本练习将挑战你为一个包含后自增操作符的复杂数组赋值语句生成三元式序列，这要求你仔细追踪变量在求值过程中每一步的状态变化，以确保生成的代码既正确又稳健。[@problem_id:3665519]", "problem": "考虑一个简单的命令式语言，它支持数组和后自增运算符。表达式 $k++$ 的值为 $k$ 的原始值，并在产生该值后立即将 $k$ 增加 $1$ 作为副作用。赋值运算符在计算其右侧之前先计算其左侧（包括任何索引计算和副作用），然后执行存储操作。中间代码使用三地址风格的操作 $load(arr, i)$ 来读取 $arr$ 在索引 $i$ 处的元素，以及 $store(arr, i, v)$ 来将值 $v$ 写入 $arr$ 的索引 $i$ 处。\n\n回顾核心定义：\n- 四元式是一个四元组 $(op, arg_1, arg_2, result)$，其中有一个显式名称 $result$ 用于存放操作的输出。\n- 三元式是一个三元组 $(op, arg_1, arg_2)$，其结果是未命名的，通过三元式在序列中的位置（索引）隐式标识。如果第 $n$ 个三元式是 $(op, arg_1, arg_2)$，其结果可以被后续的三元式引用为 $(n)$。\n- 间接三元式表示引入了一个指针表 $P$，其中 $P[i]$ 指向要执行的第 $i$ 个三元式。对先前结果的使用仍然引用三元式索引（例如 $(n)$），但通过更改 $P$ 而不是重新编号三元式来实现重排序。\n\n要求您使用三元式对单个语句 $arr[k++] = arr[k] + 1$ 进行建模，以使得：\n- 左侧的索引使用 $k++$ 作为值产生的 $k$ 的原始值。\n- 右侧使用后自增副作用发生后 $k$ 的更新值。\n- 该表示在后续三元式通过索引引用早期计算时避免了差一错误，并且在转换为间接三元式时保持语义正确（因此通过指针表 $P$ 进行的局部重排序不会改变所引用的特定三元式结果）。\n\n假设三元式遵循以下约定：\n- 三元式 $(copy, x, -)$ 返回变量 $x$ 的当前值作为其结果，而不改变 $x$。\n- 三元式 $(+, x, c)$ 返回 $x$ 与常数 $c$ 的和。\n- 三元式 $(assign, x, y)$ 将值 $y$ 赋给变量 $x$，并返回所赋的值作为其结果。\n- 三元式 $(load, arr, i)$ 返回 $load(arr, i)$ 的值。\n- 三元式 $(store, arr@i, v)$ 表示 $store(arr, i, v)$ 的副作用，并可能返回一个未使用的未定义占位符。\n- 三元式 $(postinc, x, -)$ 返回 $x$ 的原始值，然后将 $x$ 增加 $1$ 作为副作用。\n\n在所述语义下，哪个选项正确地用三元式表示了 $arr[k++] = arr[k] + 1$，避免了因位置引用而导致的差一错误，并且在转换为间接三元式时保持稳定？\n\nA. 使用单个后自增三元式，并在两侧重用其结果：\n- $0$: $(postinc, k, -)$\n- $1$: $(load, arr, (0))$\n- $2$: $(+, (1), 1)$\n- $3$: $(store, arr@(0), (2))$\n\nB. 为左侧快照 $k$ 的原始值，然后增加 $k$，接着使用更新后的 $k$ 读取右侧，最后使用快照进行存储：\n- $0$: $(copy, k, -)$\n- $1$: $(+, k, 1)$\n- $2$: $(assign, k, (1))$\n- $3$: $(load, arr, (2))$\n- $4$: $(+, (3), 1)$\n- $5$: $(store, arr@(0), (4))$\n\nC. 首先使用当前的 $k$ 计算右侧，然后增加 $k$，再使用（可能已改变的）$k$ 进行存储：\n- $0$: $(load, arr, k)$\n- $1$: $(+, (0), 1)$\n- $2$: $(store, arr@k, (1))$\n- $3$: $(postinc, k, -)$\n\nD. 使用间接三元式指针表 $P$ 来证明两侧使用相同快照是合理的，理由是重排序可以稍后处理：\n- 三元式：\n  - $0$: $(copy, k, -)$\n  - $1$: $(+, k, 1)$\n  - $2$: $(assign, k, (1))$\n  - $3$: $(load, arr, (0))$\n  - $4$: $(+, (3), 1)$\n  - $5$: $(store, arr@(0), (4))$\n- 指针表 $P$：$P[0]=0$, $P[1]=1$, $P[2]=2$, $P[3]=3$, $P[4]=4$, $P[5]=5$\n\n选择正确的选项。", "solution": "首先将验证用户提供的问题陈述的科学性和逻辑完整性。\n\n### 步骤 1：提取已知条件\n- **语言和语句**：一种命令式语言，待编译的语句为 `$arr[k++] = arr[k] + 1$`。\n- **运算符语义**：\n    - 后自增 `$k++$`：求值为 `$k$` 的当前值，然后立即将 `$k$` 增加 `$1$`。\n    - 赋值 `$LHS = RHS$`：\n        1. 计算左侧（`$LHS$`），包括所有索引计算和副作用。\n        2. 计算右侧（`$RHS$`）。\n        3. 执行存储操作（将 `$RHS$` 的结果赋给由 `$LHS$` 确定的位置）。\n- **中间表示（IR）**：三元式，形式为 `$(op, arg_1, arg_2)$` 的三元组。第 $n$ 个三元式的结果被隐式引用为 `$(n)$`。\n- **间接三元式**：一种扩展，其中指针表 `$P$` 决定执行顺序，但引用 `$(n)$` 仍指向静态列表中的第 $n$ 个三元式。\n- **语义约束**：表示必须在给定语义下是正确的，避免位置引用错误，并且在转换为间接三元式时保持稳定。\n- **三元式定义**：\n    - `$(copy, x, -)$`：返回变量 `$x$` 的值。\n    - `$(+, x, c)$`：返回 `$x + c$`。\n    - `$(assign, x, y)$`：将 `$y$` 赋给 `$x$`，并返回 `$y$`。\n    - `$(load, arr, i)$`：返回 `$arr[i]$` 的内容。\n    - `$(store, arr@i, v)$`：将值 `$v$` 存入 `$arr[i]$`。\n    - `$(postinc, x, -)$`：返回 `$x$` 的原始值，然后将 `$x$` 增加 `$1$`。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题陈述定义明确，并基于编译器构造的原理，特别是中间代码生成。源语言语句、运算符和目标三元式表示的语义都定义得足够精确，可以进行严谨的推导。\n\n让我们根据提供的规则解构语句 `$arr[k++] = arr[k] + 1$`。设 `$k_{orig}$` 为执行该语句前 `$k$` 的值。\n\n1.  **计算 LHS**：`$LHS$` 是 `$arr[k++]$`。这涉及到为存储操作计算内存地址。\n    - 计算索引表达式 `$k++$`。\n    - 根据其定义，它产生值 `$k_{orig}$`。这个值将是存储操作的有效索引。\n    - 紧接着，副作用发生：`$k$` 被递增。`$k$` 的新值为 `$k_{orig} + 1$`。\n    - 在 `$LHS$` 计算结束时，目标地址由索引 `$k_{orig}$` 确定，并且程序状态已更新为 `$k = k_{orig} + 1$`。\n\n2.  **计算 RHS**：`$RHS$` 是 `$arr[k] + 1$`。这在 `$LHS$` *之后* 计算。\n    - 这里使用的 `$k$` 的值是其当前值，即 `$k_{orig} + 1$`。\n    - 计算表达式 `$arr[k]$`，即 `$(load, arr, k_{orig} + 1)$`。\n    - 然后将值 `$1$` 与加载结果相加。\n\n3.  **执行存储**：将 `$RHS$` 的计算结果存储在 `$LHS$` 计算期间确定的位置。\n    - 最终操作是 `$(store, arr, k_{orig}, \\text{RHS 的结果})$`。\n\n综合这些步骤，该语句在语义上等同于：`store(arr, k_orig, load(arr, k_orig + 1) + 1)`。\n\n该问题具有科学依据，提法恰当且客观。未发现使其无效的缺陷。\n\n### 步骤 3：结论与行动\n问题是 **有效的**。继续进行解答。\n\n### 正确三元式表示的推导\n一个正确的三元式序列必须实现以下逻辑：`store(arr, k_orig, load(arr, k_orig + 1) + 1)`。这需要：\n1.  捕获 `$k$` 的原始值 `$k_{orig}$`，用于最终的存储索引。\n2.  将 `$k$` 递增到 `$k_{orig} + 1$`。\n3.  使用 `$k$` 的新值从 `$arr$` 中执行加载操作。\n4.  计算要存储的最终值。\n5.  使用保存的 `$k$` 的原始值执行存储操作。\n\n在三元式中表示这一点的最稳健方法是，特别是在考虑到间接三元式的稳定性要求时，尽可能使用位置引用 `$(n)$` 来明确所有数据依赖关系。\n\n让我们构建这个序列：\n1.  保存 `$k$` 的原始值。\n    - `$(copy, k, -)$`。这将产生 `$k_{orig}$`。设其为三元式 `$(0)`。\n2.  递增 `$k$`。这可以分两步完成。\n    - `$(+, k, 1)$`。这将计算 `$k_{orig} + 1$`。设其为三元式 `$(1)`。\n    - `$(assign, k, (1))$`。这将 `$k$` 更新为新值。这个三元式的结果，比如说 `$(2)`，也是新值 `$k_{orig} + 1$`。\n3.  计算 `$RHS$`。\n    - `$(load, arr, (2))$`。我们使用递增的显式结果 `$(2)$` 作为索引。这会得到 `$arr[k_{orig} + 1]`。设其为三元式 `$(3)`。\n    - `$(+, (3), 1)$`。这将计算 `$arr[k_{orig} + 1] + 1$`。设其为三元式 `$(4)`。\n4.  执行存储。\n    - `$(store, arr@(0), (4))$`。这使用从 `$(0)` 中保存的 `$k$` 的原始值作为索引，并使用从 `$(4)` 计算出的 `$RHS$` 值作为要存储的值。\n\n这个序列正确且稳健地实现了所需的语义。\n\n### 逐项分析选项\n\n**A. 使用单个后自增三元式，并在两侧重用其结果：**\n- `$0$: $(postinc, k, -)$` — 结果 `$(0)$` 是 `$k_{orig}$`。副作用：`$k$` 变为 `$k_{orig} + 1$`。\n- `$1$: $(load, arr, (0))$` — 这从 `$arr` 的索引 `$(0)`（即 `$k_{orig}$`）处加载。这是不正确的。`$RHS$` 的加载必须使用*更新后*的 `$k$` 值，即 `$k_{orig} + 1$`。\n- `$2$: $(+, (1), 1)$`\n- `$3$: $(store, arr@(0), (2))$`\n该序列计算的是 `$arr[k_{orig}] = arr[k_{orig}] + 1$`。这在语义上是错误的。\n**结论：错误**\n\n**B. 为左侧快照 $k$ 的原始值，然后增加 $k$，接着使用更新后的 $k$ 读取右侧，最后使用快照进行存储：**\n- `$0$: $(copy, k, -)$` — 结果 `$(0)` 是 `$k_{orig}$`。这保存了 `$LHS$` 的索引。\n- `$1$: $(+, k, 1)$` — 结果 `$(1)` 是 `$k_{orig} + 1$`。\n- `$2$: $(assign, k, (1))$` — `$k$` 更新为 `$k_{orig} + 1$`。结果 `$(2)` 是 `$k_{orig} + 1$`。这完成了 `$k++$` 的副作用。\n- `$3$: $(load, arr, (2))$` — 这从 `$arr` 的索引 `$(2)`（即 `$k_{orig} + 1$`）处加载。这正确地计算了 `$RHS$` 的 `$arr[k]$`。\n- `$4$: $(+, (3), 1)$` — 这计算了最终的 `$RHS$` 值。\n- `$5$: $(store, arr@(0), (4))$` — 这将 `$RHS$` 值 `$(4)` 存储在索引 `$(0)`（即 `$k_{orig}$`）处。\n这个序列完美匹配推导出的正确实现。它正确地区分了用于 `$LHS$` 索引的 `$k$` 值和用于 `$RHS$` 访问的 `$k$` 值。使用显式的位置引用使得数据流清晰而稳健。\n**结论：正确**\n\n**C. 首先使用当前的 $k$ 计算右侧，然后增加 $k$，再使用（可能已改变的）$k$ 进行存储：**\n- `$0$: $(load, arr, k)$` — 开始时，`$k = k_{orig}$`。所以这加载了 `$arr[k_{orig}]$`。\n- `$1$: $(+, (0), 1)$` — 计算 `$arr[k_{orig}] + 1$`。\n- `$2$: $(store, arr@k, (1))$` — 将此值存回 `$arr[k_{orig}]$`。\n- `$3$: $(postinc, k, -)$` — 在赋值完成后递增 `$k$`。\n该序列计算 `$arr[k] = arr[k] + 1; k++;`。计算顺序完全违反了问题的规范，其中 `$LHS$` 上 `$k++$` 的副作用必须在 `$RHS$` 计算之前发生。\n**结论：错误**\n\n**D. 使用间接三元式指针表 P 来证明两侧使用相同快照是合理的，理由是重排序可以稍后处理：**\n这个选项提出了一个有缺陷的理由。语句 `$arr[k++] = arr[k] + 1$` 从根本上需要两个不同的 `$k$` 值：用于 `$LHS$` 索引的原始值和用于 `$RHS$` 索引的递增后的值。不能“在两侧使用相同的快照”。间接三元式是一种用于在保持数据依赖性的同时对指令进行重排序的优化技术；它们不能改变源代码的基本语义。所提供的理由在科学上是不成立的。\n尽管此选项中列出的三元式序列与选项 B 中的正确序列相同，但必须根据其全部内容（包括文本理由）来评估整个选项。这个理由是错误的，使得整个选项成为一个干扰项，它助长了对问题语义和间接三元式功能的误解。\n**结论：错误**", "answer": "$$\\boxed{B}$$", "id": "3665519"}, {"introduction": "一个优秀的中间表示不仅要正确，还要为后续的优化阶段提供便利。IR的结构可以直接影响代码生成的效率，尤其是在寄存器资源有限的情况下。这个练习将让你亲手分析和比较两种不同的求值策略——一种是固定的四元式顺序，另一种是灵活的三元式调度——看看它们对寄存器溢出成本的直接影响，从而深刻理解IR设计对性能优化的重要性。[@problem_id:3665545]", "problem": "考虑在 $R=3$ 个通用寄存器的约束下，为表达式 $E=(a+b)+(c+d)+(e+f)$ 生成中间代码的策略。在编译器使用的经典中间表示中，四元式通过显式命名的临时变量（例如，$t_1=a+b$）来编码每个操作，而三元式使用位置索引，从而通过操作索引来引用结果，而无需引入新名称。间接三元式通过一个指向三元式的索引表进一步允许重排序，从而在不重命名的情况下实现灵活的调度。\n\n假设以下基础模型：\n- 机器提供 $R=3$ 个寄存器，可用于存放操作数和临时变量。\n- 一个二元加法操作接收两个寄存器操作数，并将其结果放入其中一个寄存器中（即，结果可以覆盖其中一个操作数寄存器）。\n- 一个临时值从其创建到最后一次使用之间被认为是活跃的；如果所需的活跃临时变量数量超过可用寄存器数量，则必须将某些值存储（溢出）到内存中，然后重新加载。\n- 将一个溢出的临时变量存储到内存的代价是 $\\sigma$（以抽象周期为单位），而从内存中重新加载一个溢出的临时变量的代价是 $\\lambda$（以抽象周期为单位）。\n- 所有基本变量 $a,b,c,d,e,f$ 最初都驻留在内存中，并且在使用前必须加载；然而，这些初始加载不计入溢出代价。只有因寄存器压力（临时变量的溢出）而发生的存储和重新加载才会计入溢出代价。\n\n在这些假设下，比较两种调度策略引起的溢出代价：\n1. 一种基于四元式的调度，它按照程序顺序计算显式临时变量，即 $t_1=a+b$、$t_2=c+d$、$t_3=e+f$，然后是 $t_4=t_1+t_2$ 和 $E=t_4+t_3$，并且不允许跨越这些四元式边界进行重排序。\n2. 一种三元式（或间接三元式）调度，它通过在生成每对和之后、计算下一对之前立即进行成对累加，来最小化同时活跃的临时变量的最大数量，并受限于相同的 $R=3$ 约束和相同的加法语义。\n\n根据活跃性和寄存器压力的基本原理，推导每种策略的最小溢出代价，并将两者之差（四元式溢出代价减去三元式溢出代价）表示为关于 $\\lambda$ 和 $\\sigma$ 的单个闭式解析表达式。无需四舍五入。你的最终答案必须是这个单一的表达式。", "solution": "该问题要求在 $R=3$ 个通用寄存器的约束下，对表达式 $E=(a+b)+(c+d)+(e+f)$ 的两种不同中间代码生成和调度策略的溢出代价进行比较分析。将临时变量溢出到内存的代价是 $\\sigma$，重新加载它的代价是 $\\lambda$。\n\n我们将通过追踪寄存器使用情况和临时变量的活跃性，从基本原理出发分析每种策略。一个临时变量从其创建到最后一次使用期间都是活跃的。如果在任何时刻所需的寄存器数量超过了可用寄存器数量 $R$，就会发生溢出。在给定步骤中所需的寄存器数量是持有当前活跃临时变量所需的寄存器数量与为当前计算持有操作数所需的寄存器数量之和。机器模型规定，一个二元加法 `op R_dest, R_src` 使用两个寄存器操作数，并用结果覆盖其中一个。将变量从内存加载到寄存器是一个 `LOAD` 操作。\n\n**策略 1 分析：基于四元式的调度**\n\n该策略遵循严格的程序顺序，我们可以将其表示为一系列赋值：\n$1.$ $t_1 = a+b$\n$2.$ $t_2 = c+d$\n$3.$ $t_3 = e+f$\n$4.$ $t_4 = t_1+t_2$\n$5.$ $E = t_4+t_3$\n\n让我们追踪寄存器分配和活跃性。我们将寄存器表示为 $R_1$、$R_2$、$R_3$。\n\n- **步骤 1：计算 $t_1 = a+b$**\n  - `LOAD R1, a`\n  - `LOAD R2, b`\n  - `ADD R1, R2` (结果 $t_1$ 现在位于 $R_1$ 中)\n  - 在此步骤结束时，临时变量 $t_1$ 是活跃的，因为它在步骤 4 中需要被使用。它被保存在 $R_1$ 中。活跃临时变量集合为 {$t_1$}。我们有 2 个空闲寄存器（$R_2$、$R_3$）。\n\n- **步骤 2：计算 $t_2 = c+d$**\n  - $t_1$ 是活跃的，并占用 $R_1$。我们使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, c`\n  - `LOAD R3, d`\n  - `ADD R2, R3` (结果 $t_2$ 现在位于 $R_2$ 中)\n  - 在此步骤结束时，$t_1$ 和 $t_2$ 都是活跃的。它们分别保存在 $R_1$ 和 $R_2$ 中。活跃临时变量集合为 {$t_1, t_2$}。我们有 1 个空闲寄存器（$R_3$）。\n\n- **步骤 3：计算 $t_3 = e+f$**\n  - 此时，$t_1$（在 $R_1$ 中）和 $t_2$（在 $R_2$ 中）是活跃的。我们需要计算 $t_3=e+f$，这要求在加法之前将两个操作数 $e$ 和 $f$ 加载到寄存器中。这需要 2 个空闲寄存器。然而，我们只有 1 个空闲寄存器 $R_3$。\n  - 同时需要的寄存器总数为 2 个（用于保存活跃临时变量 $t_1, t_2$）加上 2 个（用于加载操作数 $e, f$），总共需要 4 个寄存器。\n  - 由于我们只有 $R=3$ 个寄存器，存在寄存器压力，溢出是不可避免的。我们必须将一个活跃的临时变量存储到内存中以释放一个寄存器。让我们溢出 $t_1$。\n  - `STORE mem_t1, R1` (产生代价：$\\sigma$)。这释放了 $R_1$。\n  - 现在，我们可以继续计算 $t_3$。$R_2$ 保存着 $t_2$。$R_1$ 和 $R_3$ 是空闲的。\n  - `LOAD R1, e`\n  - `LOAD R3, f`\n  - `ADD R1, R3` (结果 $t_3$ 现在位于 $R_1$ 中)\n  - 在此步骤结束时，活跃临时变量集合为 {$t_1, t_2, t_3$}。$t_2$ 在 $R_2$ 中，$t_3$ 在 $R_1$ 中，$t_1$ 在内存中。\n\n- **步骤 4：计算 $t_4 = t_1+t_2$**\n  - 操作数是 $t_1$ 和 $t_2$。$t_2$ 在 $R_2$ 中。$t_1$ 在内存中，必须被重新加载。我们有一个空闲寄存器 $R_3$。\n  - `LOAD R3, mem_t1` (产生代价：$\\lambda$)。现在 $t_1$ 在 $R_3$ 中。\n  - `ADD R2, R3` (结果 $t_4=t_1+t_2$ 现在位于 $R_2$ 中)。\n  - 在此步骤结束时，临时变量 $t_1$ 和 $t_2$ 不再活跃。新的临时变量 $t_4$ 是活跃的，并且来自步骤 3 的 $t_3$ 也仍然是活跃的。它们分别保存在 $R_2$ 和 $R_1$ 中。\n\n- **步骤 5：计算 $E = t_4+t_3$**\n  - 操作数是 $t_4$（在 $R_2$ 中）和 $t_3$（在 $R_1$ 中）。两者都在寄存器中。\n  - `ADD R1, R2` (最终结果 $E$ 在 $R_1$ 中)。\n  - 不需要进一步的溢出或重新加载。\n\n策略 1 的总溢出代价是单次溢出和单次重新加载的代价之和。\n$C_1 = \\sigma + \\lambda$。\n\n**策略 2 分析：基于三元式/间接三元式的调度**\n\n该策略允许重排序操作以最小化寄存器压力。一种优化的求值顺序是深度优先地遍历表达式树，它会立即使用中间结果，从而缩短它们的活跃范围。一个这样的顺序是：\n$1.$ $t_1 = a+b$\n$2.$ $t_2 = c+d$\n$3.$ $t_3 = t_1+t_2$\n$4.$ $t_4 = e+f$\n$5.$ $E = t_3+t_4$\n\n让我们追踪这个最优顺序的寄存器需求。\n\n- **步骤 1：计算 $t_1 = a+b$**\n  - `LOAD R1, a`; `LOAD R2, b`; `ADD R1, R2`。\n  - 结果 $t_1$ 在 $R_1$ 中。此步骤中使用的最大寄存器数量为 2。\n  - 活跃临时变量：{$t_1$}。持有临时变量的寄存器数量：1。\n\n- **步骤 2：计算 $t_2 = c+d$**\n  - $t_1$ 是活跃的并且保存在 $R_1$ 中。我们需要加载 $c$ 和 $d$。我们可以使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, c`; `LOAD R3, d`。\n  - 此时，我们需要 1 个寄存器用于活跃临时变量 $t_1$，以及 2 个寄存器用于操作数 $c$ 和 $d$。总需求为 $1+2=3$ 个寄存器。由于 $R=3$，这在没有溢出的情况下是可行的。\n  - `ADD R2, R3`。结果 $t_2$ 在 $R_2$ 中。\n  - 活跃临时变量：{$t_1, t_2$}。持有临时变量的寄存器数量：2（$R_1$ 和 $R_2$）。\n\n- **步骤 3：计算 $t_3 = t_1+t_2$**\n  - 操作数 $t_1$ 和 $t_2$ 已经分别在寄存器 $R_1$ 和 $R_2$ 中。\n  - `ADD R1, R2`。结果 $t_3$ 在 $R_1$ 中。\n  - 此操作后，$t_1$ 和 $t_2$ 不再活跃。它们唯一的用途是计算 $t_3$。\n  - 活跃临时变量：{$t_3$}。持有临时变量的寄存器数量：1（$R_1$）。\n\n- **步骤 4：计算 $t_4 = e+f$**\n  - $t_3$ 是活跃的并且保存在 $R_1$ 中。我们需要加载 $e$ 和 $f$。我们可以使用空闲寄存器 $R_2$ 和 $R_3$。\n  - `LOAD R2, e`; `LOAD R3, f`。\n  - 所需的总寄存器数量再次为 1（用于 $t_3$）+ 2（用于 $e, f$）= 3。由于 $R=3$，这是可以的。\n  - `ADD R2, R3`。结果 $t_4$ 在 $R_2$ 中。\n  - 活跃临时变量：{$t_3, t_4$}。持有临时变量的寄存器数量：2（$R_1$ 和 $R_2$）。\n\n- **步骤 5：计算 $E = t_3+t_4$**\n  - 操作数 $t_3$ 和 $t_4$ 分别在寄存器 $R_1$ 和 $R_2$ 中。\n  - `ADD R1, R2`。结果 $E$ 在 $R_1$ 中。\n  - 此步骤后没有活跃的临时变量。\n\n在整个优化求值过程中，任何时刻所需的最大寄存器数量为 $3$。由于我们有 $R=3$ 个可用寄存器，因此无需进行溢出。\n因此，策略 2 的溢出代价为 $C_2 = 0$。\n\n**溢出代价的差异**\n\n问题要求计算四元式溢出代价与三元式溢出代价之间的差值。\n差值 = $C_1 - C_2 = (\\sigma + \\lambda) - 0 = \\sigma + \\lambda$。\n产生这个差异的原因是，刚性的四元式调度导致了一个高寄存器压力的点（需要 3 个活跃临时变量同时存在），而通过间接三元式实现的灵活调度通过立即使用中间结果避免了这一点，将同时活跃的临时变量峰值数量保持在 2。", "answer": "$$\n\\boxed{\\sigma + \\lambda}\n$$", "id": "3665545"}]}