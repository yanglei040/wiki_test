{"hands_on_practices": [{"introduction": "科学计算和数据分析中的一个常见任务是归约操作，例如对数组中的所有元素求和。编译器必须选择最高效的方式来执行此操作。此练习 [@problem_id:3653217] 要求你对两种基本策略进行建模和比较：一种是简单的顺序累加，另一种是并行的向量化归约树。通过构建一个基于延迟模型的决策框架，你将亲身体验编译器如何利用量化分析来发掘硬件并行性（SIMD），并做出针对硬件感知的优化选择。", "problem": "您的任务是形式化并实现一个决策框架，用于在两种基于循环的归约策略之间进行选择，以最小化预测的延迟。给定需要通过加法进行归约的元素数量 $N$ 和机器向量宽度 $w$。这两种策略是：\n- 标量线性归约（串行循环携带累加）。\n- 在宽度为 $w$ 的单个向量单元上执行的成对向量归约树。\n\n使用以下来自编译原理的基础知识：\n- 在编译器的模型中，由于定点算术中加法具有结合律，并且除了累加到单个变量之外没有其他跨迭代的副作用，因此允许对加法归约进行重排序；因此，它只有一个循环携带依赖。\n- 在模型中，单个标量加法是一个原子步骤，具有单位延迟。\n- 在宽度为 $w$ 的向量单元上，单个向量加法在一个步骤中执行 $w$ 个成对加法，具有单位延迟，并且该单元一次只处理一条向量指令。\n- 只有一个活动的执行上下文：没有多线程，向量操作之间没有重叠；唯一可用的选择是如何将加法打包到向量指令中。\n\n将延迟模型定义如下：\n- 标量线性归约：对于 $N$ 个输入，如果 $N \\ge 1$，标量加法次数为 $N - 1$，否则为 $0$。由于每个标量加法的延迟为单位延迟，因此标量延迟为 $L_{\\text{scalar}}(N) = \\max(N - 1, 0)$。\n- 成对向量归约树：在层级 $r$，当前活跃元素数量为 $n_r$，通过形成对并相加来产生下一个层级的活跃元素数量 $n_{r+1}$。具体来说，初始化 $n_0 = N$，然后迭代\n  $$a_r = \\left\\lfloor \\frac{n_r}{2} \\right\\rfloor,$$\n  $$v_r = \\left\\lceil \\frac{a_r}{w} \\right\\rceil,$$\n  $$n_{r+1} = \\left\\lceil \\frac{n_r}{2} \\right\\rceil,$$\n  直到对于某个 $R$ 有 $n_R = 1$。总延迟为\n  $$L_{\\text{vectree}}(N, w) = \\sum_{r=0}^{R-1} v_r.$$\n直观地讲，$a_r$ 是层级 $r$ 所需的成对加法次数，每个向量指令执行 $w$ 次加法，因此 $v_r$ 是该层级的向量指令数量，而下一层的活跃元素数 $n_{r+1}$ 会在 $n_r$ 为奇数时将那个落单的元素传递下去。\n\n您的框架必须选择产生较小延迟的策略。如果两种延迟相等，则选择标量策略来打破平局。\n\n用 C 编程语言实现一个完整的、可运行的程序，该程序：\n- 根据上述定义精确计算 $L_{\\text{scalar}}(N)$ 和 $L_{\\text{vectree}}(N, w)$。\n- 根据指定的平局打破规则选择延迟最小的策略。\n- 对于每个测试用例，输出一个双元素列表 $[c, L]$，其中如果选择标量策略，则 $c$ 为 $0$，如果选择向量树策略，则 $c$ 为 $1$，而 $L$ 是所选的最小延迟，表示为一个非负整数。\n\n您的程序必须在没有输入的情况下运行，并且必须处理以下参数对 $(N, w)$ 的测试套件：\n- $(N, w) = (1, 4)$\n- $(N, w) = (2, 4)$\n- $(N, w) = (7, 8)$\n- $(N, w) = (1000, 8)$\n- $(N, w) = (1024, 16)$\n- $(N, w) = (100, 1)$\n- $(N, w) = (1000000, 32)$\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个结果本身就是一个双元素列表，按测试用例的顺序排列。例如，格式必须是：\n$$[[c_1, L_1],[c_2, L_2],\\ldots,[c_k, L_k]]$$\n输出格式中，除了方括号内部分隔值所需的逗号外，不插入任何其他空格，且总共只有一行输出。", "solution": "该问题已经过验证，被确定为是定义良好、有科学依据且内部一致的。\n\n目标是创建一个决策框架，用于在串行标量方法和并行基于向量的树方法之间选择最优的归约策略。决策依据是在一台向量单元宽度为 $w$ 的机器上，对 $N$ 个元素求和时，最小化一个已定义的延迟模型。\n\n### 基于原则的设计\n\n#### 1. 延迟模型形式化\n\n最优策略的选择取决于对其预测延迟的量化比较。我们按照所给定的定义，对两种延迟模型进行形式化。所有变量均表示非负整数。\n\n**a. 标量线性归约延迟, $L_{\\text{scalar}}(N)$**\n\n此策略涉及串行累加。对 $N$ 个元素求和需要 $N-1$ 次加法。例如，`sum = x[0]; for (i=1; i", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3653217"}, {"introduction": "真实世界中的编译器优化不是孤立的决策，而是一系列复杂步骤的一部分。例如，能否对一个循环进行向量化，可能首先取决于另一项转换，比如函数内联。此练习 [@problem_id:3653269] 模拟了一个更复杂的优化流水线，你必须首先根据成本阈值决定是否内联一个函数，然后才能考虑向量化。通过实现这个包含更精细成本模型的两阶段决策逻辑，你将学习到不同优化阶段之间如何相互作用，以及编译器如何使用启发式策略在代码大小、开销和性能增益之间进行权衡。", "problem": "你的任务是为编译器设计并实现一个简化的循环优化框架，该框架用于转换形为对数组中每个元素应用一个函数的循环。函数调用形式为 $f(A[i])$，且已知 $f$ 是一个纯函数，意味着其输出仅取决于其输入，并且没有副作用。该优化器必须对由内联阈值控制的选择性内联以及后续的向量化进行建模。你的程序必须实现优化器的决策逻辑，并使用一个有原则的成本模型来计算预测的运行时。\n\n用于推导和设计的基础定义：\n- 纯函数没有副作用，其求值仅依赖于其输入。如果 $f$ 是纯函数，那么对不同 $i$ 值求值 $f(A[i])$ 不会产生跨元素效应；因此，不存在循环携带依赖。没有循环携带依赖是允许通过单指令多数据（SIMD）进行向量化的先决条件。\n- 函数内联将调用点替换为函数体。内联消除了调用开销，并且当函数体对优化器可见时，可以启用向量化。\n- 用于运行时估计的成本模型将算术运算、内存操作和各种开销的成本相加。向量化会根据硬件和实现将算术成本和内存成本降低一定的因子，并为每次向量迭代增加开销。\n\n问题框架：\n- 考虑一个通过对每个元素应用函数 $f$ 来转换长度为 $n$ 的数组的循环。设向量宽度为 $w$，其中 $w \\ge 1$。$f$ 的每个元素的标量算术成本为 $c_{\\text{body}}$，每个元素的标量内存成本（用于加载和存储的总和）为 $c_{\\text{mem}}$，未内联时每个元素的函数调用开销为 $c_{\\text{call}}$。内联阈值为 $t$。当内联时，循环可能会被向量化；当向量化时，算术成本降低因子为 $\\gamma$，内存成本降低因子为 $\\delta$，两者均为严格正值。每次向量化迭代（处理 $w$ 个元素）会增加一个开销 $c_{\\text{vec\\_iter}}$。所有成本均以抽象周期为单位。\n- 优化器必须首先决定是否内联：当且仅当 $c_{\\text{body}} \\le t$ 时进行内联。如果不内联，则不能应用向量化。如果内联，则仅在 $w \\ge 2$ 且与标量内联循环相比严格减少预测运行时的情况下，才尝试向量化。\n\n你的解决方案需要产生的推导和运行时公式：\n- 未内联的预测运行时（标量，带函数调用）：$$T_{\\text{NI}} = n \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} + c_{\\text{call}} \\right).$$\n- 内联但未向量化的预测运行时（标量内联）：$$T_{\\text{IN}} = n \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} \\right).$$\n- 内联且向量化的预测运行时（向量化内联），并处理尾部：设 $m = \\left\\lfloor \\frac{n}{w} \\right\\rfloor$ 且 $r = n \\bmod w$，\n  $$T_{\\text{IV}} = m \\cdot \\left( \\frac{c_{\\text{body}} \\cdot w}{\\gamma} + \\frac{c_{\\text{mem}} \\cdot w}{\\delta} + c_{\\text{vec\\_iter}} \\right) + r \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} \\right).$$\n- 当且仅当 $w \\ge 2$ 且 $T_{\\text{IV}}  T_{\\text{IN}}$ 时进行向量化。\n\n你的程序必须为每个测试用例输出优化器的两个决策以及所选转换的预测运行时：\n- 内联决策是一个整数 $0$ 或 $1$。\n- 向量化决策是一个整数 $0$ 或 $1$。\n- 预测运行时是一个以抽象周期为单位的浮点数。\n\n测试套件：\n提供并使用以下 $5$ 个测试用例，每个用例由 $(n, w, c_{\\text{body}}, c_{\\text{mem}}, c_{\\text{call}}, t, \\gamma, \\delta, c_{\\text{vec\\_iter}})$ 指定：\n\n- 测试用例 1：$n = 1000$, $w = 4$, $c_{\\text{body}} = 20$, $c_{\\text{mem}} = 10$, $c_{\\text{call}} = 15$, $t = 25$, $\\gamma = 4$, $\\delta = 4$, $c_{\\text{vec\\_iter}} = 5$。\n- 测试用例 2：$n = 64$, $w = 8$, $c_{\\text{body}} = 30$, $c_{\\text{mem}} = 15$, $c_{\\text{call}} = 20$, $t = 30$, $\\gamma = 4$, $\\delta = 2$, $c_{\\text{vec\\_iter}} = 300$。\n- 测试用例 3：$n = 32$, $w = 1$, $c_{\\text{body}} = 10$, $c_{\\text{mem}} = 20$, $c_{\\text{call}} = 5$, $t = 12$, $\\gamma = 1$, $\\delta = 1$, $c_{\\text{vec\\_iter}} = 5$。\n- 测试用例 4：$n = 10$, $w = 4$, $c_{\\text{body}} = 50$, $c_{\\text{mem}} = 10$, $c_{\\text{call}} = 12$, $t = 40$, $\\gamma = 4$, $\\delta = 4$, $c_{\\text{vec\\_iter}} = 2$。\n- 测试用例 5：$n = 103$, $w = 8$, $c_{\\text{body}} = 18$, $c_{\\text{mem}} = 12$, $c_{\\text{call}} = 10$, $t = 20$, $\\gamma = 8$, $\\delta = 4$, $c_{\\text{vec\\_iter}} = 6$。\n\n最终输出格式：\n你的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，每个测试用例的结果以 $[\\text{inline\\_flag},\\text{vectorize\\_flag},\\text{predicted\\_time}]$ 的形式嵌套。例如，三个用例的输出应如下所示：$[[1,0,123.0],[0,0,456.0],[1,1,78.0]]$。你的程序必须按照上述顺序为五个指定的测试用例输出且仅输出这样的一行。", "solution": "问题陈述已经过分析和验证。它在科学上基于编译器优化的原理，定义良好且自包含。所提供的参数和逻辑足以确定每个测试用例的唯一、有意义的解决方案。因此，下面提供了一个合理的解决方案。\n\n该问题要求设计一个简化的循环优化框架，该框架在三种可能的循环转换策略之间做出决策：带函数调用的标量循环（不内联）、函数体已内联的标量循环，以及函数体已内联的向量化循环。决策基于一个预测执行时间（以抽象周期为单位）的成本模型。\n\n优化逻辑遵循一个两阶段的决策过程：首先是内联决策，如果选择了内联，则接着进行向量化决策。最终的预测运行时对应于此逻辑所选最优转换的成本。\n\n成本模型由三个运行时公式定义：\n\n1. 未内联的预测运行时 $T_{\\text{NI}}$ 是在 $n$ 个元素上执行循环的成本，其中每个元素产生函数体的算术成本（$c_{\\text{body}}$）、内存访问成本（$c_{\\text{mem}}$）和函数调用开销（$c_{\\text{call}}$）。\n$$T_{\\text{NI}} = n \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} + c_{\\text{call}} \\right)$$\n\n2. 内联但未向量化的预测运行时 $T_{\\text{IN}}$ 消除了 $n$ 个元素中每个元素的函数调用开销。\n$$T_{\\text{IN}} = n \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} \\right)$$\n\n3. 同时进行内联和向量化的预测运行时 $T_{\\text{IV}}$ 以大小为 $w$（向量宽度）的块处理元素。循环由 $m = \\left\\lfloor \\frac{n}{w} \\right\\rfloor$ 次向量化迭代和一个由 $r = n \\bmod w$ 个元素组成的尾部（以标量方式处理）组成。在每次向量化迭代中，算术成本降低一个因子 $\\gamma$，内存成本降低一个因子 $\\delta$，并增加一个每次向量迭代的开销 $c_{\\text{vec\\_iter}}$。尾部元素的处理成本与标量内联情况相同。\n$$T_{\\text{IV}} = m \\cdot \\left( \\frac{c_{\\text{body}} \\cdot w}{\\gamma} + \\frac{c_{\\text{mem}} \\cdot w}{\\delta} + c_{\\text{vec\\_iter}} \\right) + r \\cdot \\left( c_{\\text{body}} + c_{\\text{mem}} \\right)$$\n\n优化算法如下进行：\n\n**步骤 1：内联决策**\n当且仅当函数 $f$ 的每个元素的标量算术成本 $c_{\\text{body}}$ 不超过内联阈值 $t$ 时，才进行内联。\n- 如果 $c_{\\text{body}} \\le t$，则决定内联（内联标志 = $1$）。继续步骤 2。\n- 如果 $c_{\\text{body}} > t$，则决定不内联（内联标志 = $0$）。循环不进行向量化（向量化标志 = $0$），最终预测运行时为 $T_{\\text{NI}}$。该用例的处理终止。\n\n**步骤 2：向量化决策（以内联为前提）**\n如果函数已被内联，优化器将评估向量化的好处。仅当向量宽度 $w$ 大于或等于 $2$（$w \\ge 2$）时，才尝试向量化。决策基于比较标量内联循环（$T_{\\text{IN}}$）和向量化内联循环（$T_{\\text{IV}}$）的预测运行时。\n- **条件检查**：如果 $w  2$，则无法进行向量化。循环保持标量状态（向量化标志 = $0$），最终运行时为 $T_{\\text{IN}}$。\n- **成本比较**：如果 $w \\ge 2$，计算 $T_{\\text{IN}}$ 和 $T_{\\text{IV}}$。当且仅当向量化能严格减少运行时，才选择向量化。\n  - 如果 $T_{\\text{IV}}  T_{\\text{IN}}$，则决定向量化（向量化标志 = $1$）。最终预测运行时为 $T_{\\text{IV}}$。\n  - 如果 $T_{\\text{IV}} \\ge T_{\\text{IN}}$，则向量化无益。循环保持标量状态（向量化标志 = $0$），最终预测运行时为 $T_{\\text{IN}}$。\n\n**示例说明：测试用例 1**\n让我们将此算法应用于第一个测试用例，其参数为：\n$(n, w, c_{\\text{body}}, c_{\\text{mem}}, c_{\\text{call}}, t, \\gamma, \\delta, c_{\\text{vec\\_iter}}) = (1000, 4, 20, 10, 15, 25, 4, 4, 5)$。\n\n- **步骤 1：内联决策**\n  - 算术成本为 $c_{\\text{body}} = 20$。内联阈值为 $t = 25$。\n  - 因为 $20 \\le 25$，所以函数被内联。内联标志设置为 $1$。\n\n- **步骤 2：向量化决策**\n  - 向量宽度为 $w = 4$。因为 $4 \\ge 2$，所以考虑向量化。\n  - 首先，计算标量内联运行时：\n    $$T_{\\text{IN}} = 1000 \\cdot (20 + 10) = 30000$$\n  - 接下来，计算向量化内联运行时。元素数量 $n=1000$ 可以被向量宽度 $w=4$ 整除。\n    - 向量迭代次数：$m = \\lfloor 1000 / 4 \\rfloor = 250$。\n    - 尾部元素数量：$r = 1000 \\bmod 4 = 0$。\n    - $$T_{\\text{IV}} = 250 \\cdot \\left( \\frac{20 \\cdot 4}{4} + \\frac{10 \\cdot 4}{4} + 5 \\right) + 0 \\cdot (20 + 10)$$\n    - $$T_{\\text{IV}} = 250 \\cdot (20 + 10 + 5) = 250 \\cdot 35 = 8750$$\n  - 比较成本：$T_{\\text{IV}} = 8750$ 和 $T_{\\text{IN}} = 30000$。\n  - 因为 $8750  30000$，所以向量化是有益的。向量化标志设置为 $1$。\n  - 最终预测运行时为 $T_{\\text{IV}} = 8750.0$。\n\n- **测试用例 1 的最终结果**：优化器的决策是内联=1，向量化=1，预测运行时为 $8750.0$ 个周期。", "answer": "```c\n// The complete and compilable C program goes here.\n// Headers must adhere to the specified restrictions.\n#include", "id": "3653269"}]}