{"hands_on_practices": [{"introduction": "在进行任何循环变换之前，编译器必须严格证明变换的合法性——即它不会改变程序的原始语义。这项练习将带你深入这一核心任务。我们将运用数据依赖分析和方向向量这两个基本工具，来判断在一个给定的场景中，循环交换是否是安全的。通过这个实践，你将掌握判断循环变换合法性的基本功。", "problem": "您正在一个编译器中分析一个完美嵌套的双层循环，该编译器面向具有行主序数组布局的随机存取存储器 (RAM)。该程序对一个大小为 $N \\times N$（其中 $N \\geq 3$）的二维数组 $A$ 进行操作，并且数组 $A$ 在循环嵌套之前被初始化。循环索引在以下有限的凸迭代空间中进行迭代：\n- 对于外层循环，$i$ 的范围是从 $1$ 到 $N-1$。\n- 对于内层循环，$j$ 的范围是从 $1$ 到 $N-1$。\n\n循环体对 $A$ 执行两次写操作和一次读操作，如下所示：\n- 写入 $A[i][j]$，\n- 写入 $A[i][j+1]$，\n- 读取 $A[i+1][j]$。\n\n假设没有别名，也没有修改 $A$ 的中间函数调用。程序的语义仅取决于对 $A$ 的内存操作的相对顺序。\n\n任务：使用数据依赖（流依赖、反依赖和输出依赖）的基本定义以及嵌套循环的方向/距离向量，将原始执行顺序视为字典序，其中 $i$ 是外层循环，$j$ 是内层循环，记作 $(i,j)$。考虑将循环交换为 $(j,i)$，并通过检查置换后的方向向量来确定语义是否得以保留。循环交换是合法的，当且仅当对于每个依赖方向向量，在应用置换后，第一个不相等的分量不表示汇点（sink）先于源点（source）（即，置换后最左边的非相等方向不是“”）。\n\n定义合法性指示符 $L$ 如下\n$$\nL =\n\\begin{cases}\n1,  \\text{如果从 } (i,j) \\text{ 到 } (j,i) \\text{ 的交换保留语义，}\\\\\n0,  \\text{否则。}\n\\end{cases}\n$$\n\n仅使用方向/距离向量推理作为基本依据，计算此循环嵌套的 $L$。答案必须是等于 $0$ 或 $1$ 的单个实数。不允许进行重命名变换（例如值拆分或临时变量创建）。您无需提供任何四舍五入，也不适用任何物理单位。", "solution": "该问题要求我们确定交换一个完美嵌套的双层循环的合法性。合法性由一个指示变量 $L$ 表示，其中对于合法的交换，$L=1$，否则 $L=0$。合法性分析必须基于使用方向向量形式化的数据依赖关系。\n\n首先，让我们为分析建立框架。循环嵌套的执行在迭代向量 $(i,j)$ 的集合上定义了一个字典序。如果 $i_1  i_2$ 或者 ($i_1 = i_2$ 且 $j_1  j_2$)，则迭代 $(i_1, j_1)$ 在迭代 $(i_2, j_2)$ 之前执行，记作 $(i_1, j_1) \\prec (i_2, j_2)$。\n\n如果满足以下条件，则从迭代 $\\vec{I}_1 = (i_1, j_1)$ 中的一个操作到迭代 $\\vec{I}_2 = (i_2, j_2)$ 中的一个操作存在数据依赖：\n1. 两个操作访问相同的内存位置。\n2. 至少有一个操作是写操作。\n3. 执行顺序为 $\\vec{I}_1 \\prec \\vec{I}_2$。\n\n循环体包含对大小为 $N \\times N$ 的二维数组 $A$ 的三个内存操作：\n- $S_1$: 写入 $A[i][j]$。\n- $S_2$: 写入 $A[i][j+1]$。\n- $S_3$: 读取 $A[i+1][j]$。\n\n迭代空间由 $1 \\le i \\le N-1$ 和 $1 \\le j \\le N-1$ 定义。\n\n一个依赖由距离向量 $\\vec{d} = \\vec{I}_2 - \\vec{I}_1 = (i_2-i_1, j_2-j_1) = (d_i, d_j)$ 和方向向量 $\\vec{v} = (\\text{sgn}(d_i), \\text{sgn}(d_j))$ 来表征，其中 $\\text{sgn}$ 是符号函数，其值在 $\\{-, 0, +\\}$ 中。对于一个由循环携带的依赖，其距离向量必须是字典序正的，即 $\\vec{d} \\succ (0,0)$。\n\n我们分析两个不同迭代 $\\vec{I}_1$ 和 $\\vec{I}_2$（其中 $\\vec{I}_1 \\prec \\vec{I}_2$）之间所有可能的操作对，以找出所有循环携带的依赖。\n\n1.  **流依赖（写后读，RAW）：** 从在 $\\vec{I}_1$ 的写操作到在 $\\vec{I}_2$ 的读操作。\n    - $S_1(\\vec{I}_1) \\to S_3(\\vec{I}_2)$: `write A[i_1][j_1]` 到 `read A[i_2+1][j_2]`。\n      为了发生内存冲突，我们需要 $i_1 = i_2+1$ 且 $j_1 = j_2$。这得到距离向量分量 $d_i = i_2 - i_1 = -1$。由于 $d_i  0$，$\\vec{I}_1$ 将在 $\\vec{I}_2$ 之后执行，这违反了依赖条件 $\\vec{I}_1 \\prec \\vec{I}_2$。因此，不存在依赖。\n    - $S_2(\\vec{I}_1) \\to S_3(\\vec{I}_2)$: `write A[i_1][j_1+1]` 到 `read A[i_2+1][j_2]`。\n      为了发生冲突，需要 $i_1 = i_2+1$ 且 $j_1+1 = j_2$。这得到 $d_i = i_2 - i_1 = -1$，再次违反了 $\\vec{I}_1 \\prec \\vec{I}_2$。不存在依赖。\n\n2.  **反依赖（读后写，WAR）：** 从在 $\\vec{I}_1$ 的读操作到在 $\\vec{I}_2$ 的写操作。\n    - $S_3(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `read A[i_1+1][j_1]` 到 `write A[i_2][j_2]`。\n      为了发生冲突，需要 $i_1+1 = i_2$ 且 $j_1 = j_2$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, 0)$。\n      由于 $i_2 = i_1+1 > i_1$，条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足。\n      如果存在有效的迭代向量，则此依赖存在。对于 $N \\ge 3$，我们可以选择 $i_1=1, j_1=1$，得到 $\\vec{I}_1 = (1,1)$ 和 $\\vec{I}_2 = (2,1)$。两者都在迭代空间内。\n      方向向量为 $\\vec{v}_1 = (\\text{sgn}(1), \\text{sgn}(0)) = (+, 0)$。\n\n    - $S_3(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `read A[i_1+1][j_1]` 到 `write A[i_2][j_2+1]`。\n      为了发生冲突，需要 $i_1+1 = i_2$ 且 $j_1 = j_2+1$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (1, -1)$。\n      由于 $i_2 = i_1+1 > i_1$，条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足。\n      如果存在有效的迭代向量，则此依赖存在。我们需要 $1 \\le i_1 \\le N-2$ 且 $2 \\le j_1 \\le N-1$。对于 $N \\ge 3$，我们可以选择 $i_1=1, j_1=2$，得到 $\\vec{I}_1=(1,2)$ 和 $\\vec{I}_2=(2,1)$。两者都是有效的迭代。\n      方向向量为 $\\vec{v}_2 = (\\text{sgn}(1), \\text{sgn}(-1)) = (+, -)$。\n\n3.  **输出依赖（写后写，WAW）：** 从在 $\\vec{I}_1$ 的写操作到在 $\\vec{I}_2$ 的写操作。\n    - $S_1(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `write A[i_1][j_1]` 到 `write A[i_2][j_2]`。冲突意味着 $\\vec{I}_1 = \\vec{I}_2$，因此没有循环携带的依赖。\n    - $S_2(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `write A[i_1][j_1+1]` 到 `write A[i_2][j_2+1]`。冲突意味着 $\\vec{I}_1 = \\vec{I}_2$，因此没有循环携带的依赖。\n    - $S_1(\\vec{I}_1) \\to S_2(\\vec{I}_2)$: `write A[i_1][j_1]` 到 `write A[i_2][j_2+1]`。\n      为了发生冲突，需要 $i_1=i_2$ 且 $j_1=j_2+1$。这得到 $d_j = j_2 - j_1 = -1$。由于 $d_i=0$，一个有效的依赖需要 $j_1  j_2$，但这与 $j_1 > j_2$ 相矛盾。没有依赖。\n    - $S_2(\\vec{I}_1) \\to S_1(\\vec{I}_2)$: `write A[i_1][j_1+1]` 到 `write A[i_2][j_2]`。\n      为了发生冲突，需要 $i_1=i_2$ 且 $j_1+1=j_2$。\n      距离向量为 $\\vec{d} = (i_2-i_1, j_2-j_1) = (0, 1)$。\n      由于 $i_1=i_2$ 且 $j_2 = j_1+1 > j_1$，条件 $\\vec{I}_1 \\prec \\vec{I}_2$ 得到满足。\n      这个依赖是有效的。对于 $N \\ge 3$，选择 $i_1=1, j_1=1$，得到 $\\vec{I}_1=(1,1)$ 和 $\\vec{I}_2=(1,2)$。\n      方向向量为 $\\vec{v}_3 = (\\text{sgn}(0), \\text{sgn}(1)) = (0, +)$。\n\n循环携带的依赖由其方向向量总结如下：\n- $\\vec{v}_1 = (+, 0)$\n- $\\vec{v}_2 = (+, -)$\n- $\\vec{v}_3 = (0, +)$\n\n根据问题陈述，从 $(i,j)$ 到 $(j,i)$ 的循环交换是合法的，当且仅当对于每个依赖方向向量 $\\vec{v} = (v_i, v_j)$，置换后的向量 $\\vec{v}' = (v_j, v_i)$ 是字典序非负的。如果一个向量的第一个非零分量是负的（'-'），则该向量是字典序负的。这意味着如果任何置换后的方向向量是字典序负的，则该变换是非法的。\n\n让我们测试我们的方向向量：\n1.  对于 $\\vec{v}_1 = (+, 0)$，置换后的向量是 $\\vec{v}'_1 = (0, +)$。这是字典序正的。此依赖不阻止交换。\n2.  对于 $\\vec{v}_2 = (+, -)$，置换后的向量是 $\\vec{v}'_2 = (-, +)$。第一个分量是负的（'-'）。此向量是字典序负的。这个依赖的存在使得循环交换非法。\n3.  对于 $\\vec{v}_3 = (0, +)$，置换后的向量是 $\\vec{v}'_3 = (+, 0)$。这是字典序正的。此依赖不阻止交换。\n\n具有方向向量 $\\vec{v}_2 = (+, -)$ 的反依赖的存在使得从 $(i,j)$ 到 $(j,i)$ 的循环交换非法。这个依赖在交换后会反转，意味着一个本应在另一个之前发生的操作将会在其之后发生，从而违反了程序的语义。例如，从 $\\vec{I}_1=(1,2)$ 到 $\\vec{I}_2=(2,1)$ 的反依赖确保了在迭代 $(1,2)$ 的 `read A[2][2]` 发生在迭代 $(2,1)$ 的 `write A[2][2]` 之前。交换后，迭代向量变为 $(j,i)$。读操作发生在 $(2,1)$，写操作发生在 $(1,2)$。由于 $(1,2) \\prec (2,1)$，写操作将在读操作之前执行，这是不正确的。\n\n由于循环交换是非法的，合法性指示符 $L$ 为 $0$。", "answer": "$$\\boxed{0}$$", "id": "3652959"}, {"introduction": "仅仅合法是不够的；我们进行优化的最终目的是提升性能。这项练习将探讨循环交换的“原因”——它如何通过改变内存访问模式（例如，从大步长访问变为连续访问）来显著影响缓存性能。你将亲手构建一个量化的成本模型，直观地看到这种变换带来的性能权衡，并理解优化决策背后的考量。", "problem": "考虑两个以行主序存储的稠密二维矩形数组：一个形状为 $N \\times M$ 的数组 $A$ 和一个形状为 $M \\times N$ 的数组 $B$，其中 $N$ 和 $M$ 是正整数，满足 $N \\geq 1$ 和 $M \\geq 1$。在行主序布局中，元素 $A[i][j]$ 相对于 $A$ 的基地址的地址偏移量为 $i \\cdot M + j$，而 $B[j][i]$ 相对于 $B$ 的基地址的地址偏移量为 $j \\cdot N + i$。考虑一个执行类似转置计算的嵌套迭代空间 $\\{(i,j) \\mid 0 \\leq i \\leq N-1,\\ 0 \\leq j \\leq M-1\\}$：对于每个 $(i,j)$，读取 $A[i][j]$ 的值并将其写入 $B[j][i]$。循环交换会改变 $i$ 和 $j$ 的迭代顺序。\n\n使用以下基本依据进行局部性和成本建模：\n- 在行主序中，与最右侧索引关联的维度在内存中是连续的。因此，当 $i$ 是外层循环，$j$ 是内层循环时，对 $A[i][j]$ 的访问在内存中是步幅为1的（连续），而对 $B[j][i]$ 的访问是步幅为 $k = N$ 的流。当 $j$ 是外层循环，$i$ 是内层循环（交换后），对 $B[j][i]$ 的访问变为步幅为1，而对 $A[i][j]$ 的访问变为步幅为 $k' = M$ 的流。\n- 一个缓存行包含 $L$ 个元素（假设 $L \\geq 1$ 是一个整数），且数组足够大，以至于一旦缓存行被驱逐，就不会有时间重用；忽略行内空间重用之外的容量和冲突效应。\n- 对于读取操作，一次缓存命中成本为 $h_r$ 个周期，一次缓存未命中成本为 $c_r$ 个周期，其中 $c_r \\geq h_r \\geq 0$。\n- 对于写入操作，假设采用写分配、写回策略：对一个不存在的缓存行的首次写入会产生一次分配并最终写回的成本，为 $c_{wa}$ 个周期；对同一驻留行的后续写入命中成本为 $h_w$ 个周期，其中 $c_{wa} \\geq h_w \\geq 0$。\n- 对于步幅为1的流，每 $L$ 个元素有一次未命中，随后是 $L-1$ 次命中。对于步幅为 $s \\geq L$ 的流，假设每次访问都映射到不同的缓存行，因此都会未命中。\n\n通过指出每种顺序中哪个数组是步幅为1、哪个是步幅为k，来提供一个两种循环顺序的具体例子，然后构建如下成本模型。设 $C_{\\text{orig}}$ 表示当 $i$ 为外层循环、$j$ 为内层循环时的总预期执行成本（以周期为单位），设 $C_{\\text{int}}$ 表示当 $j$ 为外层循环、$i$ 为内层循环（交换后的顺序）时的总预期执行成本（以周期为单位）。在上述假设下，并进一步假设 $k = N \\geq L$ 和 $k' = M \\geq L$，推导出一个单一、完全简化、封闭形式的解析表达式来表示差值\n$$\\Delta C \\triangleq C_{\\text{int}} - C_{\\text{orig}}$$\n该表达式是关于 $N$、$M$、$L$、$c_r$、$h_r$、$c_{wa}$ 和 $h_w$ 的函数。你的最终答案必须是单一的解析表达式。如果你引入任何辅助量，它们必须在代数上被消除，以使最终表达式仅依赖于 $N$、$M$、$L$、$c_r$、$h_r$、$c_{wa}$ 和 $h_w$。以周期为单位表示最终的成本差异。无需四舍五入。", "solution": "我们将通过首先提取所有已知条件，然后评估其科学合理性、完整性和客观性来验证该问题。\n\n### 步骤 1：提取已知条件\n- **数组和存储**:\n  - 数组 $A$：稠密、矩形、二维，形状为 $N \\times M$。\n  - 数组 $B$：稠密、矩形、二维，形状为 $M \\times N$。\n  - 两个数组均以行主序存储。\n  - $N$ 和 $M$ 是正整数，满足 $N \\geq 1$ 和 $M \\geq 1$。\n- **地址偏移量**:\n  - $A[i][j]$ 的地址偏移量为 $i \\cdot M + j$。\n  - $B[j][i]$ 的地址偏移量为 $j \\cdot N + i$。\n- **计算**:\n  - 迭代空间： $\\{(i,j) \\mid 0 \\leq i \\leq N-1,\\ 0 \\leq j \\leq M-1\\}$。\n  - 操作：对于每个 $(i,j)$，从 $A[i][j]$ 读取一个元素并写入 $B[j][i]$。\n- **循环顺序**:\n  - 原始顺序 ($C_{\\text{orig}}$)：$i$ 是外层循环，$j$ 是内层循环。\n  - 交换后顺序 ($C_{\\text{int}}$)：$j$ 是外层循环，$i$ 是内层循环。\n- **局部性和步幅**:\n  - 原始顺序：对 $A[i][j]$ 的访问是步幅为1。对 $B[j][i]$ 的访问是步幅为 $k=N$。\n  - 交换后顺序：对 $B[j][i]$ 的访问是步幅为1。对 $A[i][j]$ 的访问是步幅为 $k'=M$。\n- **缓存和成本模型**:\n  - 缓存行大小：$L$ 个元素，$L \\geq 1$ 是一个整数。\n  - 时间重用：假设在外层循环迭代之间被驱逐的缓存行没有时间重用。\n  - 读取成本：一次缓存命中成本为 $h_r$ 个周期；一次缓存未命中成本为 $c_r$ 个周期，其中 $c_r \\geq h_r \\geq 0$。\n  - 写入策略：写分配、写回。\n  - 写入成本：一次未命中（分配并最终写回）成本为 $c_{wa}$ 个周期；一次命中成本为 $h_w$ 个周期，其中 $c_{wa} \\geq h_w \\geq 0$。\n- **流访问成本假设**:\n  - 步幅为1的流：每 $L$ 个元素有一次未命中，随后是 $L-1$ 次命中。\n  - 步幅为 $s \\geq L$ 的流：每次访问都是一次未命中。\n- **推导的特定假设**:\n  - $k = N \\geq L$。\n  - $k' = M \\geq L$。\n- **目标**:\n  - 推导出一个单一、完全简化、封闭形式的解析表达式来表示 $\\Delta C \\triangleq C_{\\text{int}} - C_{\\text{orig}}$，该表达式是关于 $N, M, L, c_r, h_r, c_{wa}, h_w$ 的函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n问题定义明确且科学合理。\n- **科学依据**：问题基于计算机体系结构（缓存、内存布局）和编译器优化（循环交换）的基本概念。成本模型是用于性能分析的标准简化抽象。行主序的地址计算是正确的。\n- **定义良好**：提供了构建确定性成本模型所需的所有常量、变量和函数关系。目标陈述清晰，并且可以从给定的前提中推导出唯一解。\n- **客观性**：问题以精确的技术语言陈述，没有主观性或歧义。\n- **完整性和一致性**：问题是自洽的。约束 $N \\geq L$ 和 $M \\geq L$ 是为模型的相关部分（大步幅访问）指定的。所提供的信息中没有矛盾。\n\n### 步骤 3：结论与行动\n问题是**有效的**。我们将按要求推导解答。\n\n### 解答推导\n总计算成本是所有内存访问成本的总和。共有 $N \\cdot M$ 次迭代，每次迭代涉及一次从数组 $A$ 的读取和一次向数组 $B$ 的写入。内存访问总次数为 $2 \\cdot N \\cdot M$。\n\n首先，我们按照描述确定每种循环顺序的访问模式。\n- **原始循环顺序**：`for i from 0 to N-1 { for j from 0 to M-1 { B[j][i] = A[i][j]; } }`。$j$ 的内层循环访问 $A[i][0], A[i][1], \\dots, A[i][M-1]$ 和 $B[0][i], B[1][i], \\dots, B[M-1][i]$。如题所给，对 $A$ 的访问是步幅为1，对 $B$ 的访问是步幅为 $N$。\n- **交换后的循环顺序**：`for j from 0 to M-1 { for i from 0 to N-1 { B[j][i] = A[i][j]; } }`。$i$ 的内层循环访问 $A[0][j], A[1][j], \\dots, A[N-1][j]$ 和 $B[j][0], B[j][1], \\dots, B[j][N-1]$。如题所给，对 $A$ 的访问是步幅为 $M$，对 $B$ 的访问是步幅为1。\n\n我们现在为 $C_{\\text{orig}}$ 和 $C_{\\text{int}}$ 构建成本模型。\n\n**原始循环顺序的成本 ($C_{\\text{orig}}$)**\n\n1.  **从 A 读取的成本 ($C_{A, \\text{orig}}^{\\text{read}}$)**：对 $A$ 的访问模式是步幅为1。根据模型，每访问 $L$ 个元素，就有1次未命中和 $L-1$ 次命中。读取的总元素数量为 $N \\cdot M$。\n    - 未命中次数 = $\\frac{N \\cdot M}{L}$。\n    - 命中次数 = $N \\cdot M \\cdot (1 - \\frac{1}{L}) = N \\cdot M \\cdot \\frac{L-1}{L}$。\n    - 总读取成本：$C_{A, \\text{orig}}^{\\text{read}} = \\left(\\frac{N \\cdot M}{L}\\right) c_r + \\left(N \\cdot M \\cdot \\frac{L-1}{L}\\right) h_r$。\n    - 化简得：$C_{A, \\text{orig}}^{\\text{read}} = \\frac{N \\cdot M}{L} (c_r + (L-1)h_r) = N \\cdot M \\left( h_r + \\frac{c_r - h_r}{L} \\right)$。\n\n2.  **写入 B 的成本 ($C_{B, \\text{orig}}^{\\text{write}}$)**：对 $B$ 的访问模式是步幅为 $N$。我们有假设 $N \\geq L$。因此，每次对 $B$ 的访问都是一次缓存未命中。在写分配策略下，每次未命中产生 $c_{wa}$ 的成本。\n    - 总写入成本：$C_{B, \\text{orig}}^{\\text{write}} = (N \\cdot M) \\cdot c_{wa}$。\n\n3.  **总原始成本 ($C_{\\text{orig}}$)**：\n    $$C_{\\text{orig}} = C_{A, \\text{orig}}^{\\text{read}} + C_{B, \\text{orig}}^{\\text{write}} = N \\cdot M \\left( h_r + \\frac{c_r - h_r}{L} \\right) + N \\cdot M \\cdot c_{wa}$$\n    $$C_{\\text{orig}} = N \\cdot M \\left( h_r + c_{wa} + \\frac{c_r - h_r}{L} \\right)$$\n\n**交换后循环顺序的成本 ($C_{\\text{int}}$)**\n\n1.  **从 A 读取的成本 ($C_{A, \\text{int}}^{\\text{read}}$)**：对 $A$ 的访问模式是步幅为 $M$。我们有假设 $M \\geq L$。因此，每次对 $A$ 的访问都是一次缓存未命中。\n    - 总读取成本：$C_{A, \\text{int}}^{\\text{read}} = (N \\cdot M) \\cdot c_r$。\n\n2.  **写入 B 的成本 ($C_{B, \\text{int}}^{\\text{write}}$)**：对 $B$ 的访问模式是步幅为1。这与原始循环顺序的读取情况类似，但使用的是写入成本。每写入 $L$ 个元素，就有1次写入未命中（成本为 $c_{wa}$）和 $L-1$ 次写入命中（成本为 $h_w$）。\n    - 未命中次数 = $\\frac{N \\cdot M}{L}$。\n    - 命中次数 = $N \\cdot M \\cdot \\frac{L-1}{L}$。\n    - 总写入成本：$C_{B, \\text{int}}^{\\text{write}} = \\left(\\frac{N \\cdot M}{L}\\right) c_{wa} + \\left(N \\cdot M \\cdot \\frac{L-1}{L}\\right) h_w$。\n    - 化简得：$C_{B, \\text{int}}^{\\text{write}} = \\frac{N \\cdot M}{L} (c_{wa} + (L-1)h_w) = N \\cdot M \\left( h_w + \\frac{c_{wa} - h_w}{L} \\right)$。\n\n3.  **总交换后成本 ($C_{\\text{int}}$)**：\n    $$C_{\\text{int}} = C_{A, \\text{int}}^{\\text{read}} + C_{B, \\text{int}}^{\\text{write}} = N \\cdot M \\cdot c_r + N \\cdot M \\left( h_w + \\frac{c_{wa} - h_w}{L} \\right)$$\n    $$C_{\\text{int}} = N \\cdot M \\left( c_r + h_w + \\frac{c_{wa} - h_w}{L} \\right)$$\n\n**成本差异的推导 ($\\Delta C$)**\n\n现在，我们计算差值 $\\Delta C = C_{\\text{int}} - C_{\\text{orig}}$。\n$$\\Delta C = N \\cdot M \\left( c_r + h_w + \\frac{c_{wa} - h_w}{L} \\right) - N \\cdot M \\left( h_r + c_{wa} + \\frac{c_r - h_r}{L} \\right)$$\n提取公因子 $N \\cdot M$：\n$$\\frac{\\Delta C}{N \\cdot M} = \\left( c_r + h_w + \\frac{c_{wa}}{L} - \\frac{h_w}{L} \\right) - \\left( h_r + c_{wa} + \\frac{c_r}{L} - \\frac{h_r}{L} \\right)$$\n按成本参数分组各项：\n$$\\frac{\\Delta C}{N \\cdot M} = (c_r - \\frac{c_r}{L}) - (h_r - \\frac{h_r}{L}) - (c_{wa} - \\frac{c_{wa}}{L}) + (h_w - \\frac{h_w}{L})$$\n$$\\frac{\\Delta C}{N \\cdot M} = c_r\\left(1 - \\frac{1}{L}\\right) - h_r\\left(1 - \\frac{1}{L}\\right) - c_{wa}\\left(1 - \\frac{1}{L}\\right) + h_w\\left(1 - \\frac{1}{L}\\right)$$\n提取公因子 $\\left(1 - \\frac{1}{L}\\right)$：\n$$\\frac{\\Delta C}{N \\cdot M} = \\left(1 - \\frac{1}{L}\\right) (c_r - h_r - c_{wa} + h_w)$$\n$$\\frac{\\Delta C}{N \\cdot M} = \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\n最后，乘以 $N \\cdot M$ 得到 $\\Delta C$ 的完全简化表达式：\n$$\\Delta C = N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})$$\n此表达式仅是指定变量 $N, M, L, c_r, h_r, c_{wa}$ 和 $h_w$ 的函数，符合要求。", "answer": "$$\\boxed{N \\cdot M \\cdot \\frac{L-1}{L} (c_r - h_r + h_w - c_{wa})}$$", "id": "3652895"}, {"introduction": "虽然方向向量很直观，但现代编译器使用一种更强大的代数框架——多面体模型（Polyhedral Model）——来分析和变换循环。这最后一个练习将向你介绍这一高级模型。你将学习如何用数学方式表示循环嵌套及其依赖关系，并使用仿射调度（affine schedule）来形式化地表达和验证循环交换的合法性，一窥现代编译器自动优化的奥秘。", "problem": "考虑以下二维循环嵌套，它在多面体模型中构成一个静态控制部分（SCoP）：\nfor $i = 2$ to $N$ do\n  for $j = 2$ to $M$ do\n    $S(i,j):\\quad A[i][j] = 3 \\cdot A[i][j-1] - 2 \\cdot A[i-1][j] + B[i-1][j-1]$\n假设 $N \\ge 2$ 且 $M \\ge 2$，并且数组 $B$ 在此 SCoP 内是只读的。使用多面体模型的基础知识，将循环表示为迭代域的多面体，指定语句 $S$ 的仿射访问函数，并推导由 $S$ 中的读写操作引起的所有关于数组 $A$ 的语句内流依赖距离向量。然后，计算一个对应于循环交换（先按 $j$ 排序，再按 $i$ 排序）的仿射调度，并验证表示为依赖约束 $D \\cdot \\theta \\ge 0$ 的合法性条件，其中 $D$ 遍历 $S$ 的流依赖距离向量，而 $\\theta$ 是交换调度的第一调度维度的系数向量。最后，提供实现循环交换的二维调度函数的闭式解析表达式作为你的答案。", "solution": "该问题是有效的，因为它提法明确，科学上基于编译器理论（特别是多面体模型）的原理，并且包含了推导出解决方案所需的所有必要信息。\n\n该问题要求对给定的循环嵌套进行分析，确定其数据依赖关系，并制定和验证与循环交换相对应的仿射调度。\n\n循环嵌套如下：\nfor $i = 2$ to $N$ do\n  for $j = 2$ to $M$ do\n    $S(i,j):\\quad A[i][j] = 3 \\cdot A[i][j-1] - 2 \\cdot A[i-1][j] + B[i-1][j-1]$\n\n首先，我们将语句 $S$ 的迭代域表示为一个多面体。迭代向量为 $\\vec{p} = \\begin{pmatrix} i \\\\ j \\end{pmatrix}$。域 $\\mathcal{D}_S$ 是满足循环边界的整数点 $(i, j)$ 的集合：\n$$ \\mathcal{D}_S = \\{ (i, j) \\in \\mathbb{Z}^2 \\mid 2 \\le i \\le N \\land 2 \\le j \\le M \\} $$\n\n接下来，我们确定语句 $S$ 中对数组 $A$ 的仿射内存访问函数。该语句涉及对数组 $A$ 的一次写操作和两次读操作。设迭代向量为 $\\vec{p} = (i, j)^T$。\n1.  对 $A[i][j]$ 的写访问：访问函数为 $f_W(\\vec{p}) = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} i \\\\ j \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$。\n2.  对 $A[i][j-1]$ 的读访问：访问函数为 $f_{R1}(\\vec{p}) = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} i \\\\ j \\end{pmatrix} + \\begin{pmatrix} 0 \\\\ -1 \\end{pmatrix}$。\n3.  对 $A[i-1][j]$ 的读访问：访问函数为 $f_{R2}(\\vec{p}) = \\begin{pmatrix} 1  0 \\\\ 0  1 \\end{pmatrix} \\begin{pmatrix} i \\\\ j \\end{pmatrix} + \\begin{pmatrix} -1 \\\\ 0 \\end{pmatrix}$。\n\n我们现在推导数组 $A$ 的语句内流依赖（写后读）。如果在一个迭代 $\\vec{p}_w$ 中写入的内存位置在字典序更后的一个迭代 $\\vec{p}_r$ 中被读取，则存在从 $\\vec{p}_w$ 到 $\\vec{p}_r$ 的流依赖。依赖向量为 $\\vec{d} = \\vec{p}_r - \\vec{p}_w$。\n\n情况1：涉及 $f_{R1}$ 的依赖。\n条件是 $f_W(\\vec{p}_w) = f_{R1}(\\vec{p}_r)$。设 $\\vec{p}_w = (i_w, j_w)^T$ 且 $\\vec{p}_r = (i_r, j_r)^T$。\n$$ \\begin{pmatrix} i_w \\\\ j_w \\end{pmatrix} = \\begin{pmatrix} i_r \\\\ j_r - 1 \\end{pmatrix} $$\n这意味着 $i_w = i_r$ 且 $j_w = j_r - 1$。依赖向量是 $\\vec{d}_1 = \\vec{p}_r - \\vec{p}_w = \\begin{pmatrix} i_r - i_w \\\\ j_r - j_w \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}$。此依赖由 $j$ 循环承载。由于 $(0, 1)$ 是字典序为正的，因此这是原始循环顺序中的一个有效流依赖。\n\n情况2：涉及 $f_{R2}$ 的依赖。\n条件是 $f_W(\\vec{p}_w) = f_{R2}(\\vec{p}_r)$。\n$$ \\begin{pmatrix} i_w \\\\ j_w \\end{pmatrix} = \\begin{pmatrix} i_r - 1 \\\\ j_r \\end{pmatrix} $$\n这意味着 $i_w = i_r - 1$ 且 $j_w = j_r$。依赖向量是 $\\vec{d}_2 = \\vec{p}_r - \\vec{p}_w = \\begin{pmatrix} i_r - i_w \\\\ j_r - j_w \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}$。此依赖由 $i$ 循环承载。由于 $(1, 0)$ 是字典序为正的，因此这是一个有效的流依赖。\n\n流依赖距离向量的集合是 $D = \\{ \\vec{d}_1, \\vec{d}_2 \\} = \\{ (0, 1)^T, (1, 0)^T \\}$。\n\n现在，我们提出了一个与循环交换相对应的仿射调度。原始调度可以看作是 $\\Theta_{orig}(i, j) = (i, j)^T$。循环交换对应于先按 $j$ 排序迭代，然后再按 $i$ 排序。此变换的一个有效仿射调度是：\n$$ \\Theta(i, j) = \\begin{pmatrix} j \\\\ i \\end{pmatrix} $$\n这可以写成矩阵变换 $\\Theta(\\vec{p}) = T\\vec{p}$，其中 $T = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix}$ 且 $\\vec{p} = (i, j)^T$。\n\n为了验证此变换的合法性，我们必须检查对于每个依赖向量 $\\vec{d} \\in D$，变换后的依赖向量 $T\\vec{d}$ 都是字典序为正的（$T\\vec{d} >_{lex} \\vec{0}$）。\n\n对于 $\\vec{d}_1 = (0, 1)^T$：\n$$ T\\vec{d}_1 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} $$\n由于 $(1, 0)^T$ 是字典序为正的，此依赖得以保留。\n\n对于 $\\vec{d}_2 = (1, 0)^T$：\n$$ T\\vec{d}_2 = \\begin{pmatrix} 0  1 \\\\ 1  0 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} $$\n由于 $(0, 1)^T$ 是字典序为正的，此依赖也得以保留。\n\n在新调度下，两个依赖向量都导致字典序为正的时间差，因此循环交换是合法的变换。\n\n该问题还要求验证合法性条件 $D \\cdot \\theta \\ge 0$。这里，$\\theta$ 是第一调度维度的系数向量。我们调度的第一维度是 $\\theta_1(i, j) = j$，其形式为 $c_{11}i + c_{12}j$，对应的系数向量为 $\\vec{\\theta} = (0, 1)^T$。让我们检查每个依赖向量 $\\vec{d} \\in D$ 的点积：\n对于 $\\vec{d}_1 = (0, 1)^T$：$\\vec{d}_1 \\cdot \\vec{\\theta} = (0)(0) + (1)(1) = 1$。由于 $1 > 0$，该依赖由此调度维度承载。\n对于 $\\vec{d}_2 = (1, 0)^T$：$\\vec{d}_2 \\cdot \\vec{\\theta} = (1)(0) + (0)(1) = 0$。由于结果为 $0$，此依赖不由第一维度承载，必须由后续维度承载。第二维度是 $\\theta_2(i, j) = i$，系数向量为 $\\vec{\\theta}'=(1, 0)^T$。用它来检查 $\\vec{d}_2$：$\\vec{d}_2 \\cdot \\vec{\\theta}' = (1)(1) + (0)(0) = 1 > 0$。该依赖由第二维度满足。\n完整的合法性条件得到满足。\n\n二维调度函数的闭式解析表达式为 $\\Theta(i, j) = (j, i)^T$。对于一个泛型迭代 $(i, j)$，此函数的输出是时间向量 $(j, i)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\nj \\\\\ni\n\\end{pmatrix}\n}\n$$", "id": "3652925"}]}