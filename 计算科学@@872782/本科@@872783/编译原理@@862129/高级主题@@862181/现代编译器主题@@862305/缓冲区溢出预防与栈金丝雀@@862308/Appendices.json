{"hands_on_practices": [{"introduction": "编译器在实现栈金丝雀等安全机制时，需要在不同的插桩策略之间做出权衡。例如，编译器可以选择在每个函数返回点都插入检查代码，或者将所有返回路径重定向到一个执行单次检查的公共尾声。本练习旨在帮助你量化分析这两种策略在编译时复杂度和运行时开销上的差异，从而深入理解编译器设计中的性能权衡。[@problem_id:3625563]", "problem": "编译器插入栈金丝雀（stack canary）检测来缓解缓冲区溢出。考虑一个包含 $m$ 个函数集合 $\\{f_{1},\\dots,f_{m}\\}$ 的程序。对于函数 $f_{i}$，设 $n_{i}$ 是其返回语句的数量（即其控制流图（CFG）中的退出点数量）。编译器可以为金丝雀检查选择两种代码生成策略：\n- 策略 $\\mathcal{P}$（per-exit）：在每条返回语句处直接插入一个金丝雀检查。\n- 策略 $\\mathcal{S}$（single-epilogue）：通过将每个返回重写为到唯一的尾声（epilogue）块的无条件跳转，来将函数重构为单个尾声。该尾声块执行一次金丝雀检查，然后返回。\n\n假设使用以下现实的成本模型，其中所有成本都是独立于 $i$ 和输入的正常数：\n- 在函数序言（prologue）中写入金丝雀的成本为每次动态调用 $c_{\\text{pro}}$ 个周期。\n- 执行金丝雀检查的成本为每次执行检查的动态调用点 $c_{\\text{chk}}$ 个周期。\n- 在策略 $\\mathcal{S}$ 中，每次动态调用时，在唯一执行路径上插入的到尾声的无条件跳转的成本为 $c_{\\text{jmp}}$ 个周期。\n- 对于策略 $\\mathcal{P}$，假设除了返回本身之外没有引入额外的跳转；金丝雀检查被内联放置在每个返回处。\n\n设在某次执行期间，$f_{i}$ 的动态调用次数为 $k_{i}$，并定义总动态调用次数为 $K \\coloneqq \\sum_{i=1}^{m} k_{i}$。假设对于每次调用，都只执行 $1$ 个返回点（即精确地只走一条退出路径），并且没有如 $longjmp$ 这样的非局部退出。忽略所有缓存和流水线副作用；将成本建模为所有调用的每次调用成本的总和。\n\n任务：\n- 仅使用上述定义和标准渐进符号，根据 $n_{i}$ 证明策略 $\\mathcal{P}$ 和策略 $\\mathcal{S}$ 的每函数静态插桩（static instrumentation）的复杂度类别，并解释它们为何不同。\n- 然后，当使用两种策略中成本更高的一种时，推导在整个程序执行期间增加的总运行时成本（以周期为单位）的最坏情况下的紧凑闭式表达式，该表达式应是 $K$、$c_{\\text{pro}}$、$c_{\\text{chk}}$ 和 $c_{\\text{jmp}}$ 的函数。请以单个简化的解析表达式给出最终的最坏情况总成本。不需要四舍五入。最终表达式中不应包含单位。", "solution": "问题陈述被评估为有效。它在科学上基于编译器设计和计算机安全的原理，特别是关于基于栈的缓冲区溢出缓解措施。该问题设定良好，提供了一套清晰一致的定义、假设和成本模型。它客观且没有歧义，允许进行严谨、形式化的求解。\n\n我们将按顺序解决这两个任务：首先是静态插桩复杂度，其次是最坏情况下增加的总运行时成本。\n\n### 第一部分：静态插桩复杂度\n\n静态插桩复杂度指的是编译器在编译时修改单个函数 $f_{i}$ 代码这一任务的计算复杂度。该复杂度是返回语句数量 $n_{i}$ 的函数。\n\n对于策略 $\\mathcal{P}$（per-exit），编译器必须为函数 $f_{i}$ 执行以下操作：\n1.  在函数的控制流图（CFG）中识别所有 $n_{i}$ 个返回语句（退出点）。\n2.  在这 $n_{i}$ 个位置中的每一个位置，插入对应于金丝雀检查的指令序列。\n\n所做的工作与必须修改的位置数量成正比。由于 $n_{i}$ 个不同的位置需要插入代码，因此策略 $\\mathcal{P}$ 的静态插桩复杂度属于复杂度类 $\\Theta(n_{i})$。\n\n对于策略 $\\mathcal{S}$（single-epilogue），编译器必须为函数 $f_{i}$ 执行以下操作：\n1.  创建一个单一的新基本块，作为公共尾声。该块包含金丝雀检查指令，后面跟着一条单一的返回指令。此步骤的复杂度相对于 $n_{i}$ 是常数，即 $\\Theta(1)$。\n2.  识别所有 $n_{i}$ 个原始返回语句。\n3.  在这 $n_{i}$ 个位置中的每一个位置，用一个指向新创建的公共尾声块的无条件跳转指令替换返回指令。\n\n主要的工作是遍历并修改 $n_{i}$ 个原始返回点。因此，策略 $\\mathcal{S}$ 的静态插桩复杂度也属于复杂度类 $\\Theta(n_{i})$。\n\n问题问的是它们为何不同。虽然两种策略都属于相同的渐近复杂度类 $\\Theta(n_{i})$，但插桩的性质及其对最终机器代码的影响有显著不同。\n-   **操作类型**：策略 $\\mathcal{P}$ 在 $n_{i}$ 个位置执行*代码插入*。策略 $\\mathcal{S}$ 在 $n_{i}$ 个位置执行*代码替换*（或*修补*），并创建一个新的代码块。\n-   **代码大小（代码膨胀）**：对于策略 $\\mathcal{P}$，增加的代码总大小是金丝雀检查代码序列大小的 $n_{i}$ 倍。对于策略 $\\mathcal{S}$，增加的代码由一个检查代码实例加上 $n_{i}$ 条跳转指令组成。如果检查代码序列显著大于一条跳转指令，策略 $\\mathcal{S}$ 会导致代码大小显著减小，尤其是在 $n_{i}$ 很大时。\n-   **CFG 修改**：策略 $\\mathcal{P}$ 仅修改现有基本块的内容。策略 $\\mathcal{S}$ 通过创建一个新节点（尾声块）并将 $n_{i}$ 条终止边重定向到这个新节点，从而改变了 CFG 本身的结构。\n\n总而言之，尽管它们的编译时算法复杂度与 $n_{i}$ 的伸缩性相同，但这两种策略在实现细节、对最终代码大小的影响以及对控制流图的修改方面有所不同。\n\n### 第二部分：最坏情况下增加的总运行时成本\n\n增加的运行时成本是每次函数调用时由金丝雀插桩引入的动态开销。我们首先确定每种策略每次调用的成本。根据问题陈述，每次调用只执行一个返回路径，因此该成本与函数索引 $i$ 和返回数量 $n_{i}$ 无关。\n\n设 $C_{\\mathcal{P}}$ 为策略 $\\mathcal{P}$ 每次调用的增加成本。\n-   在函数序言中写入一个金丝雀，成本为 $c_{\\text{pro}}$。\n-   在唯一执行的退出路径上，执行一次内联的金丝雀检查，成本为 $c_{\\text{chk}}$。\n-   没有引入额外的跳转。\n因此，每次调用的成本为 $C_{\\mathcal{P}} = c_{\\text{pro}} + c_{\\text{chk}}$。\n\n设 $C_{\\mathcal{S}}$ 为策略 $\\mathcal{S}$ 每次调用的增加成本。\n-   在函数序言中写入一个金丝雀，成本为 $c_{\\text{pro}}$。\n-   执行的退出路径被重写为到尾声的无条件跳转。这个跳转的成本为 $c_{\\text{jmp}}$。\n-   尾声执行一次金丝雀检查，成本为 $c_{\\text{chk}}$。\n因此，每次调用的成本为 $C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}$。\n\n问题要求计算使用两种策略中“成本更高”的一种时的总成本。我们必须比较 $C_{\\mathcal{P}}$ 和 $C_{\\mathcal{S}}$。\n$$C_{\\mathcal{S}} - C_{\\mathcal{P}} = (c_{\\text{pro}} + c_{\\text{jmp}} + c_{\\text{chk}}) - (c_{\\text{pro}} + c_{\\text{chk}}) = c_{\\text{jmp}}$$\n问题陈述所有成本均为正常数，因此 $c_{\\text{jmp}}  0$。这意味着 $C_{\\mathcal{S}}  C_{\\mathcal{P}}$。因此，就动态运行时成本而言，策略 $\\mathcal{S}$ 始终是成本更高的策略。\n\n任何单次函数调用的最坏情况增加成本是两种成本中的最大值：\n$$C_{\\text{worst-per-call}} = \\max(C_{\\mathcal{P}}, C_{\\mathcal{S}}) = C_{\\mathcal{S}} = c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}}$$\n整个程序执行期间增加的总运行时成本是每次动态调用成本的总和。由于每次调用的最坏情况成本是恒定的，我们将此成本乘以总动态调用次数 $K$。\n$$C_{\\text{total-worst}} = K \\times C_{\\text{worst-per-call}}$$\n代入 $C_{\\text{worst-per-call}}$ 的表达式，我们得到：\n$$C_{\\text{total-worst}} = K (c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})$$\n这就是最坏情况下增加的总运行时成本的紧凑闭式表达式。", "answer": "$$\n\\boxed{K(c_{\\text{pro}} + c_{\\text{chk}} + c_{\\text{jmp}})}\n$$", "id": "3625563"}, {"introduction": "理论上的安全机制在应用于实际系统时，必须适应其资源限制。特别是在嵌入式系统中，CPU性能和内存大小都极为有限，这要求工程师在安全、性能和内存占用之间做出精确的权衡。通过这个练习，你将为一个假想的嵌入式设备选择最佳的金丝雀大小，以在满足严格的安全和时序约束的同时，最小化系统开销。[@problem_id:3625579]", "problem": "一个嵌入式控制单元使用编译器插入的栈金丝雀（stack canaries）来缓解基于栈的缓冲区溢出。一个大小为 $k$ 位的栈金丝雀被放置在每个受保护函数的栈帧中，并在函数返回时进行检查。假设以下基本事实成立：当金丝雀值从所有 $k$ 位字符串中均匀随机抽取，并在攻击尝试期间保密时，攻击者的溢出在单次尝试中无声通过检查的概率为 $2^{-k}$；每个活动的受保护栈帧恰好持有一个金丝雀；复制和比较金丝雀的开销与处理的字节数成线性关系。\n\n该设备是单线程的，并运行一个周期性控制循环。中央处理器（CPU）的频率为 $f = 80 \\times 10^{6}$ 周期/秒，循环周期为 $T = 2 \\times 10^{-3}$ 秒。在一个周期内的最坏情况下，有 $W = 40$ 次受保护函数激活（每次激活创建一个受保护的栈帧，随后销毁它）。编译器用于放置和检查金丝雀的代码序列，每次激活有 $c_{0} = 10$ 周期的固定开销，外加与金丝雀大小成正比的额外开销，为每字节 $c_{1} = 6$ 周期，这包括了函数序言和尾声的总和。设计者规定了一个硬性预算，即金丝雀处理所消耗的 CPU 周期不能超过每个周期可用 CPU 周期的 $r = 0.015$。\n\n专门用于在同时活动的帧中存储金丝雀的静态随机存取存储器（SRAM）预算为 $B = 256$ 字节。最多可以同时存在 $D_{\\max} = 40$ 个受保护的帧（最坏情况下的调用深度）。每个金丝雀以整数个字节存储，因此 $k$ 必须是 $8$ 的倍数，每个金丝雀占用 $\\lceil k/8 \\rceil$ 字节。\n\n安全性要求是，在单次尝试中，未被检测到的栈破坏攻击的概率必须最多为 $p_{\\mathrm{req}} = 10^{-9}$。在这些约束和假设下，选择 $k$（以位为单位）以最小化开销，同时满足安全性要求且不违反时间或 SRAM 约束。给出与所有约束一致的唯一最小可行 $k$。将您的最终答案表示为整数位数。", "solution": "目标是确定栈金丝雀大小（用 $k$ 表示，单位为位）的唯一最小可行整数值，该值满足所有给定的约束条件。这些约束涉及安全性、时间（CPU开销）和内存（SRAM使用）。问题还规定 $k$ 必须是 $8$ 的倍数，并且目标是最小化开销。总开销是 $k$ 的增函数，因此最小化开销等同于找到 $k$ 的最小可行值。\n\n我们将按顺序分析每个约束，以推导出 $k$ 的有效范围。\n\n1.  **安全性约束：**\n    攻击者的单次溢出尝试未被检测到的概率为 $2^{-k}$。这个概率必须不大于所要求的最大概率 $p_{\\mathrm{req}} = 10^{-9}$。这建立了一个不等式：\n    $$2^{-k} \\le 10^{-9}$$\n    为了解出 $k$，我们对不等式两边取以 $2$ 为底的对数。\n    $$\\log_{2}(2^{-k}) \\le \\log_{2}(10^{-9})$$\n    使用对数性质 $\\log_b(a^c) = c\\log_b(a)$，可以简化为：\n    $$-k \\le -9 \\log_{2}(10)$$\n    两边乘以 $-1$ 会反转不等号：\n    $$k \\ge 9 \\log_{2}(10)$$\n    我们可以使用换底公式计算 $\\log_{2}(10)$ 的值：$\\log_{2}(10) = \\frac{\\ln(10)}{\\ln(2)} \\approx \\frac{2.302585}{0.693147} \\approx 3.321928$。\n    $$k \\ge 9 \\times 3.321928 \\approx 29.89735$$\n    由于 $k$ 必须是整数，满足安全性要求的 $k$ 的最小值为 $30$。\n    $$k \\ge 30$$\n\n2.  **时间约束：**\n    在一个控制循环周期 $T = 2 \\times 10^{-3}$ 秒内可用的 CPU 总周期数是 CPU 频率 $f = 80 \\times 10^{6}$ 周期/秒与周期时长的乘积。\n    $$C_{\\text{total}} = f \\times T = (80 \\times 10^{6}) \\times (2 \\times 10^{-3}) = 160000 \\text{ cycles}$$\n    用于金丝雀处理的预算是这个总数的 $r = 0.015$。\n    $$C_{\\text{budget}} = r \\times C_{\\text{total}} = 0.015 \\times 160000 = 2400 \\text{ cycles}$$\n    每次激活的金丝雀操作成本包括一个固定开销 $c_{0} = 10$ 周期和一个与金丝雀大小（以字节为单位）成正比的可变部分。由于 $k$ 是 $8$ 的倍数，其大小（以字节为单位）是 $k/8$。可变开销为每字节 $c_{1} = 6$ 周期。每次激活的成本是：\n    $$C_{\\text{activation}} = c_{0} + c_{1} \\times \\frac{k}{8} = 10 + 6 \\times \\frac{k}{8} = 10 + \\frac{3}{4}k$$\n    在最坏情况下，每个周期有 $W = 40$ 次受保护函数激活。每个周期的总开销不能超过预算。\n    $$W \\times C_{\\text{activation}} \\le C_{\\text{budget}}$$\n    $$40 \\times \\left(10 + \\frac{3}{4}k\\right) \\le 2400$$\n    两边除以 $40$：\n    $$10 + \\frac{3}{4}k \\le 60$$\n    $$\\frac{3}{4}k \\le 50$$\n    $$k \\le \\frac{200}{3} \\approx 66.667$$\n    由于 $k$ 必须是整数，时间约束意味着 $k \\le 66$。\n\n3.  **SRAM 约束：**\n    金丝雀的 SRAM 预算为 $B = 256$ 字节。这个内存必须能容纳最坏情况下同时活动的帧数（$D_{\\max} = 40$）的金丝雀。每个金丝雀的内存使用量为 $k/8$ 字节。\n    总 SRAM 使用量为 $S_{\\text{used}} = D_{\\max} \\times \\frac{k}{8}$。这不能超过预算 $B$。\n    $$D_{\\max} \\times \\frac{k}{8} \\le B$$\n    $$40 \\times \\frac{k}{8} \\le 256$$\n    $$5k \\le 256$$\n    $$k \\le \\frac{256}{5} = 51.2$$\n    由于 $k$ 必须是整数，这意味着 $k \\le 51$。这个上限比时间约束得出的上限更严格。\n\n4.  **综合约束与最小化：**\n    我们必须找到一个整数 $k$，同时满足所有推导出的条件：\n    - 来自安全性：$k \\ge 30$。\n    - 来自 SRAM：$k \\le 51$。\n    - 来自问题陈述：$k$ 必须是 $8$ 的倍数。\n\n    综合这些不等式，$k$ 的可行范围是 $30 \\le k \\le 51$。现在我们找出这个范围内的 $8$ 的倍数：\n    $8$ 的倍数是 $8, 16, 24, 32, 40, 48, 56, \\dots$。\n    位于区间 $[30, 51]$ 内的倍数是 $32$、$40$ 和 $48$。\n    所有可行的 $k$ 值的集合是 $\\{32, 40, 48\\}$。\n\n    问题要求选择 $k$ 以最小化开销。总开销为 $C_{\\text{canary}} = 40 \\times (10 + \\frac{3}{4}k)$，这是 $k$ 的一个单调递增函数。因此，为了最小化开销，我们必须从可行解集合中选择最小值。\n    集合 $\\{32, 40, 48\\}$ 中的最小值是 $32$。\n\n    因此，满足所有要求的唯一最小可行金丝雀大小是 $k=32$ 位。", "answer": "$$\\boxed{32}$$", "id": "3625579"}, {"introduction": "虽然栈金丝雀是有效的防御手段，但它并非没有性能成本，尤其是在深度递归等场景下。一个先进的编译器优化思路是，如果能通过静态分析证明在某些代码路径上不可能发生缓冲区溢出，就可以安全地省略金丝雀检查。这个练习将引导你分析这种优化策略的性能收益，并理解其背后的安全原理，即如何利用形式化证明来消除不必要的运行时安全开销。[@problem_id:3625643]", "problem": "一种用于具有自动存储期（栈）的语言的现代编译器使用栈金丝雀（stack canaries）来防御缓冲区溢出。在标准方案中，编译器在每个函数的栈帧中，于局部缓冲区和控制数据之间插入一个金丝雀值。在函数入口处，写入金丝雀会产生固定的周期成本；在函数退出时，检查金丝雀也会产生固定的周期成本。考虑一个最大递归深度为 $d$ 的递归函数，这意味着在递归峰值时，调用栈上存在该函数的 $d$ 个活跃栈帧。假设没有进行尾调用消除，并且函数在到达基本情况后会一直返回到最初的调用者。\n\n仅使用以下基本事实：\n- 每次递归调用都会分配一个新的栈帧，因此在递归峰值时，该函数的活跃栈帧数量恰好为 $d$。\n- 对于编译器为其植入金丝雀的每个栈帧，函数序言会写入一次金丝雀，函数尾声会检查一次金丝雀；这些是每个帧的常数时间操作。\n- 累计金丝雀成本是在整个调用和返回路径上，所有被植入金丝雀的帧的单位帧成本之和。\n\n假设测得的周期成本如下：在函数序言中写入金丝雀的成本为 $c_{w} = 9$ 个周期，在函数尾声中检查金丝雀的成本为 $c_{v} = 21$ 个周期。递归深度为 $d = 19$。一项可靠的范围分析证明，对于所有深度超过阈值 $t = 7$ 的帧（深度从最外层调用计为 1，每次递归调用增加 1），在函数的参数不变量条件下，所有局部缓冲区的写入都在边界之内。在此证明下，一项编译器优化提议省略在那些深度严格大于 $t$ 的内层帧中插入金丝雀，但保留深度为 1 到 $t$ 的帧的金丝雀。\n\n任务：\n1. 根据第一性原理及上述事实，推导出在 (i) 完全植入（每个帧都有金丝雀）和 (ii) 选择性植入（仅在深度至多为 $t$ 的帧上使用金丝雀）两种情况下，累计金丝雀周期成本的表达式，该表达式应使用 $c_{w}$、$c_{v}$、$d$ 和 $t$ 表示。\n2. 使用提供的数值，计算选择性植入与完全植入相比所节省的确切周期数。将您的最终答案以单个整数形式给出。\n3. 基于所述的证明条件，简要论证在内层帧（深度大于 $t$）中省略金丝雀是否能保持安全性，并阐明支持您结论的原理。您的论证不应改变任务2中要求的数值结果。\n\n无需近似计算；请为节省的周期数提供一个确切的整数。最终答案框中请勿包含任何单位。", "solution": "该问题要求分析一项在递归函数中选择性省略栈金丝雀的编译器优化所带来的计算成本节省。解决方案将首先推导成本的通用表达式，然后计算具体的数值节省量，最后基于所提供的信息论证该优化的安全性。\n\n让我们定义给定的参数：\n- $d$: 最大递归深度。\n- $t$: 金丝雀省略的深度阈值。当深度 $k$ 满足 $1 \\le k \\le t$ 时使用金丝雀。\n- $c_w$: 在函数序言中写入一个金丝雀的周期成本。\n- $c_v$: 在函数尾声中验证一个金丝雀的周期成本。\n\n递归函数的执行包括一个“调用”阶段，其中递归从深度 1 加深到 $d$；以及一个“返回”阶段，其中函数从深度 $d$ 返回到 1。问题陈述没有尾调用消除，因此 $d$ 次调用中的每一次都会创建一个新的栈帧，并且每个帧随后在返回时被销毁。\n\n**任务1：累计成本表达式的推导**\n\n**(i) 完全植入成本 ($C_{\\text{full}}$)**\n在完全植入的情况下，从深度 $k=1$到 $k=d$ 的每个栈帧都由一个金丝雀保护。\n在调用阶段，每个（共 $d$ 个）函数调用的序言部分都会写入一个金丝雀。写入金丝雀的总成本是帧数乘以每个帧的写入成本：\n$$C_{\\text{write, full}} = d \\cdot c_w$$\n在返回阶段，当 $d$ 个函数中的每一个返回时，其尾声部分都会检查金丝雀。验证金丝雀的总成本是帧数乘以每个帧的验证成本：\n$$C_{\\text{verify, full}} = d \\cdot c_v$$\n累计金丝雀周期成本是整个执行路径上所有写入和验证成本的总和。\n$$C_{\\text{full}} = C_{\\text{write, full}} + C_{\\text{verify, full}} = d \\cdot c_w + d \\cdot c_v$$\n提出因子 $d$，我们得到完全植入下的总成本表达式：\n$$C_{\\text{full}} = d (c_w + c_v)$$\n\n**(ii) 选择性植入成本 ($C_{\\text{selective}}$)**\n在选择性植入的情况下，仅为深度 $k$ 满足 $1 \\le k \\le t$ 的帧插入和检查金丝雀。深度 $k  t$ 的帧不被植入。\n因此，被植入的帧数为 $t$。\n在调用阶段，仅为前 $t$ 个帧（深度 1 到 $t$）写入金丝雀。总写入成本为：\n$$C_{\\text{write, selective}} = t \\cdot c_w$$\n类似地，在返回阶段，也仅对这相同的 $t$ 个帧检查金丝雀。总验证成本为：\n$$C_{\\text{verify, selective}} = t \\cdot c_v$$\n选择性植入的累计金丝雀周期成本是这些成本的总和：\n$$C_{\\text{selective}} = C_{\\text{write, selective}} + C_{\\text{verify, selective}} = t \\cdot c_w + t \\cdot c_v$$\n提出因子 $t$，我们得到选择性植入下的总成本表达式：\n$$C_{\\text{selective}} = t (c_w + c_v)$$\n\n**任务2：节省的周期数计算**\n\n节省的周期数（我们记为 $S$）是完全植入的成本与选择性植入的成本之差。\n$$S = C_{\\text{full}} - C_{\\text{selective}}$$\n代入任务1中推导出的表达式：\n$$S = d(c_w + c_v) - t(c_w + c_v)$$\n提出公因式 $(c_w + c_v)$:\n$$S = (d - t)(c_w + c_v)$$\n该表达式表示由于不对深度大于 $t$ 的 $(d-t)$ 个帧中的每一个执行写入和检查操作所带来的节省。\n\n现在，我们代入给定的数值：\n- $d = 19$\n- $t = 7$\n- $c_w = 9$ 周期\n- $c_v = 21$ 周期\n\n计算过程如下：\n$$S = (19 - 7)(9 + 21)$$\n$$S = (12)(30)$$\n$$S = 360$$\n因此，该优化所节省的确切周期数为 $360$。\n\n**任务3：安全性的论证**\n\n支持此优化安全性的基本原理是：一项安全缓解措施仅在其旨在防止的威胁确实可能发生时才有必要。\n问题陈述中提到，一项“可靠的范围分析证明，对于所有深度超过阈值深度 $t=7$ 的帧……所有局部缓冲区的写入都在边界之内”。\n栈金丝雀是一种专门设计用于检测基于栈的缓冲区溢出的防御机制，而缓冲区溢出是越界内存写入的后果。金丝雀被放置在栈上，位于局部缓冲区和控制数据（如返回地址）之间。如果缓冲区写入溢出其预定边界，它将覆盖金丝雀。函数的尾声会检查金丝雀的值是否被修改，如果被修改，它可以终止程序，以防止可能被劫持的控制流的执行。\n“可靠的范围分析”一词意味着一个保证正确的形式化证明。该证明确定，对于深度大于 $t$ 的栈帧，任何缓冲区写入都绝不会超出其分配的边界。如果不可能发生越界写入，那么在这些特定的帧中就不可能发生缓冲区溢出。\n因此，在这些帧中使用金丝雀是多余的。它所防御的事件已经被证明不会发生。为深度大于 $t$ 的帧省略金丝雀不会引入漏洞，因为金丝雀所检测的根本条件（缓冲区溢出）已被静态地证明不存在。程序的安全性得以保持，因为它现在依赖于可靠范围分析的形式化证明的正确性，而不是依赖于金丝雀对那些特定帧的运行时检测。", "answer": "$$\\boxed{360}$$", "id": "3625643"}]}