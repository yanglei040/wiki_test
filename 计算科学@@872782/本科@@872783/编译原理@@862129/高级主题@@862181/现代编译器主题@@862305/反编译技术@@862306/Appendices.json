{"hands_on_practices": [{"introduction": "反编译的第一步是理解和简化从机器代码中提升出来的中间表示（IR）。数据流分析，特别是常量传播，是揭示代码真实意图的强大技术。通过这个练习[@problem_id:3636449]，你将亲手实践如何通过跟踪常量值来剪除不可能的执行路径，并将看似复杂的计算简化为其最核心的逻辑。", "problem": "给定一个函数经提升后的中间表示（IR），该函数来自一个处理机器码和静态已知只读数据的反编译器流水线。该函数接受一个整数输入参数 $n \\in \\mathbb{Z}$ 并返回一个整数。该 IR 通过一个包含基本块 $B_{0}$、$B_{1}$、$B_{2}$ 和 $B_{3}$ 的控制流图（CFG）来表达，并具有以下语义。地址为 $\\alpha$ 的单个只读内存位置包含常量 $7$，提升器将其表示为从只读数据加载。所有算术运算都在数学整数上进行，没有环绕。该函数如下，使用赋值运算符 $:=$：\n\n- 在 $B_{0}$ 中：\n  - $K := \\mathrm{ROLOAD}(\\alpha)$\n  - $a := K - 7$\n  - if $(a \\neq 0)$ then goto $B_{\\mathrm{dead}}$ else goto $B_{1}$\n- 在 $B_{1}$ 中：\n  - $b := 2$\n  - if $\\big((b + a) \\neq 2\\big)$ then goto $B_{2}$ else goto $B_{3}$\n- 在 $B_{2}$ 中：\n  - $c := n \\cdot 0$\n  - $t := c + b$\n  - goto $B_{3}$\n- 在 $B_{3}$ 中：\n  - $x := n + b + K - 9$\n  - return $x$\n\n假设 $B_{\\mathrm{dead}}$ 没有副作用，如果到达该块则立即返回。请使用标准的前向数据流分析，在经典常量格 $L = \\mathbb{Z} \\cup \\{\\top, \\bot\\}$（其中 $\\bot$ 表示不可达，$\\top$ 表示未知的非常量）上，对此 IR 进行跨基本块的全局常量传播。使用由常规常量传播规则定义的交运算 $\\sqcap$。基于此分析的不动点，生成简化（移除死路径并折叠表达式）后的反编译高级伪代码，然后通过显式写出并应用形式为 $x' = f(x)$ 的程序状态向量状态转移方程来验证简化的正确性，证明只有一条路径是可行的。\n\n最后，从您简化的伪代码中，提取以输入 $n$ 表示的返回值的封闭形式解析表达式。请提供这个单一表达式作为您的最终答案。无需四舍五入，最终答案中不包含任何单位。", "solution": "首先对问题进行验证性检查。\n\n### 步骤 1：提取给定条件\n- **输入参数**：一个整数 $n \\in \\mathbb{Z}$。\n- **返回值**：一个整数。\n- **控制流图 (CFG)**：由基本块 $B_{0}$、$B_{1}$、$B_{2}$、$B_{3}$ 构成。还提到了一个额外的块 $B_{\\mathrm{dead}}$。\n- **只读数据**：地址为 $\\alpha$ 的内存位置包含常量值 $7$。这表示为 `ROLOAD($\\alpha$)`。\n- **算术语义**：所有算术运算都在数学整数上进行，没有环绕。\n- **IR 语义**：\n    - **在 $B_{0}$ 中**：\n        1. $K := \\mathrm{ROLOAD}(\\alpha)$\n        2. $a := K - 7$\n        3. if $(a \\neq 0)$ then goto $B_{\\mathrm{dead}}$ else goto $B_{1}$\n    - **在 $B_{1}$ 中**：\n        1. $b := 2$\n        2. if $\\big((b + a) \\neq 2\\big)$ then goto $B_{2}$ else goto $B_{3}$\n    - **在 $B_{2}$ 中**：\n        1. $c := n \\cdot 0$\n        2. $t := c + b$\n        3. goto $B_{3}$\n    - **在 $B_{3}$ 中**：\n        1. $x := n + b + K - 9$\n        2. return $x$\n- **$B_{\\mathrm{dead}}$ 语义**：没有副作用，到达后立即返回。\n- **分析任务**：使用前向数据流分析执行全局常量传播。\n- **分析所用的格**：$L = \\mathbb{Z} \\cup \\{\\top, \\bot\\}$，其中 $\\top$ 代表未知的非常量值，$\\bot$ 代表不可达/未定义的状态。\n- **交运算 ($\\sqcap$)**：由标准常量传播规则定义。对于任意值 $v_1, v_2 \\in L$：\n    - $v \\sqcap \\bot = v$ 且 $\\bot \\sqcap v = v$（$\\bot$ 是交运算的单位元）\n    - 对于 $v \\neq \\bot$，$v \\sqcap \\top = \\top$ 且 $\\top \\sqcap v = \\top$\n    - 若 $c_1 = c_2$ 且 $c_1, c_2 \\in \\mathbb{Z}$，则 $c_1 \\sqcap c_2 = c_1$\n    - 若 $c_1 \\neq c_2$ 且 $c_1, c_2 \\in \\mathbb{Z}$，则 $c_1 \\sqcap c_2 = \\top$\n- **目标**：\n    1. 在分析后生成简化的高级伪代码。\n    2. 使用状态转移方程验证简化过程。\n    3. 提取最终返回值关于 $n$ 的封闭形式表达式。\n\n### 步骤 2：使用提取的给定条件进行验证\n该问题具有科学依据、是良定的且客观的。\n- **科学依据**：该问题是编译原理中的一个经典练习，具体涉及数据流分析（常量传播）、控制流图简化和代码生成/反编译。格、交运算和分析算法都是标准概念。\n- **良定性**：IR 被完全指定，分析框架已定义，期望的输出是明确的。可以通过指定的程序推导出一个唯一的、有意义的解。\n- **客观性**：问题使用形式化的、无歧义的计算机科学术语陈述。没有主观因素。\n- 问题是自洽的，且内部一致。\n\n### 步骤 3：结论与行动\n问题有效。将提供解答。\n\n### 解题过程\n\n解题过程包括三个主要部分：(1) 执行常量传播数据流分析，(2) 根据分析结果简化 IR，(3) 验证简化过程并提取最终表达式。\n\n#### 1. 常量传播分析\n\n我们执行一个前向数据流分析，以确定变量在各个程序点上的常量值。每个点的状态是一个从变量 $\\{K, a, b, c, t, x\\}$ 到格 $L$ 中值的映射。输入参数 $n$ 在函数入口处被视为 $\\top$。分析过程迭代进行，直到达到不动点。\n\n**初始化**：\n- 每个块的输入状态映射都初始化为所有变量映射到 $\\bot$。\n- 函数入口处（$B_0$ 的输入）的状态为 $n \\mapsto \\top$。\n- 我们使用一个工作列表算法，初始时包含入口块 $B_0$。\n\n**迭代 1**：\n- **处理 $B_0$**：\n    - $B_0$ 的输入状态为 $n \\mapsto \\top$，所有其他变量 $\\mapsto \\bot$。\n    - 指令 $K := \\mathrm{ROLOAD}(\\alpha)$：由于 $\\mathrm{ROLOAD}(\\alpha)$ 加载常量 $7$，变量 $K$ 的状态变为 $7$。\n    - 指令 $a := K - 7$：使用 $K$ 的值，我们计算 $a := 7 - 7 = 0$。变量 $a$ 的状态变为 $0$。\n    - 从 $B_0$ 输出的状态是 $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, \\dots \\}$。省略号表示未赋值的变量仍为 $\\bot$。\n    - 条件分支 `if (a != 0)`：当 $a=0$ 时，条件 $0 \\neq 0$ 确定为假。因此，控制流无条件地进入 $B_1$。通往 $B_{\\mathrm{dead}}$ 的路径是不可达的（死代码）。\n    - 我们将 $B_0$ 的输出状态传播到 $B_1$，并将 $B_1$ 添加到工作列表中。\n\n- **处理 $B_1$**：\n    - $B_1$ 的输入状态是来自 $B_0$ 的输出状态：$\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, \\dots \\}$。\n    - 指令 $b := 2$：变量 $b$ 的状态变为 $2$。\n    - 分支前的状态为 $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, \\dots \\}$。\n    - 条件分支 `if ((b + a) != 2)`：当 $b=2$ 且 $a=0$ 时，条件是 $(2 + 0) \\neq 2$，简化为 $2 \\neq 2$，这确定为假。因此，控制流无条件地进入 $B_3$。通往 $B_2$ 的路径是不可达的。\n    - 我们将 $B_1$ 的输出状态传播到 $B_3$，并将 $B_3$ 添加到工作列表中。\n\n- **处理 $B_3$**：\n    - $B_3$ 的输入状态来自其前驱。此时，只有 $B_1$ 对其有贡献。从 $B_2$ 流入的状态仍然全是 $\\bot$。交运算为 $IN(B_3) = OUT(B_1) \\sqcap OUT(B_2)$。因为 $OUT(B_2)$ 全是 $\\bot$，且 $\\bot$ 是 $\\sqcap$ 的单位元，所以 $B_3$ 的输入状态就是来自 $B_1$ 的状态：$\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, \\dots \\}$。\n    - 指令 $x := n + b + K - 9$：我们使用已知的常量值来评估此表达式：$x := n + 2 + 7 - 9 = n + 0 = n$。由于 $n \\mapsto \\top$，结果是 $x \\mapsto \\top$。\n    - $B_3$ 的输出状态为 $\\{ n \\mapsto \\top, K \\mapsto 7, a \\mapsto 0, b \\mapsto 2, x \\mapsto \\top, \\dots \\}$。\n\n工作列表现在为空，后续迭代不会改变任何状态映射。已达到不动点。分析结论是基本块 $B_{\\mathrm{dead}}$ 和 $B_2$ 是不可达的。\n\n#### 2. IR 简化与伪代码生成\n\n基于分析结果，我们可以通过传播常量和消除死代码来简化 IR。\n\n- **基本块 $B_0$**：赋值 `K := ROLOAD($\\alpha$)` 被替换为 `K := 7`。赋值 `a := K - 7` 变为 `a := 0`。分支 `if (a != 0)` 变为 `if (0 != 0)`，这是一个到 $B_1$ 的无条件跳转。\n- **基本块 $B_1$**：它从 $B_0$ 接收到 `a=0`。赋值 `b := 2` 被保留。分支 `if ((b + a) != 2)` 变为 `if ((2 + 0) != 2)`，这是一个到 $B_3$ 的无条件跳转。\n- **基本块 $B_2$**：此块被识别为不可达，并被完全移除。\n- **基本块 $B_3$**：此块从 $B_1$ 到达，带有常量值 `K=7` 和 `b=2`。赋值 `x := n + b + K - 9` 经过常量折叠：\n$$x := n + 2 + 7 - 9$$\n$$x := n + 9 - 9$$\n$$x := n$$\n\n整个 CFG 塌缩成一个导向 `return x` 的单一线性操作序列。合并逻辑后，函数的行为简化为计算 $x=n$ 并返回它。\n\n**简化后的高级伪代码**：\n```\nfunction simplified_function(n: integer): integer\n  return n\nend function\n```\n\n#### 3. 使用状态转移方程进行验证\n\n我们验证只有一条执行路径是可行的。设状态为程序变量 $(K, a, b, c, t, x)$ 的值和程序计数器（PC）的元组。输入 $n$ 是一个符号常量。\n\n**初始状态**：$S_0 = (\\text{PC}=B_0, K=?, a=?, b=?, c=?, t=?, x=?)$\n\n1.  **在 $B_0$ 处**：\n    - $K := \\mathrm{ROLOAD}(\\alpha) \\implies K' = 7$。\n    - $a := K - 7 \\implies a' = 7 - 7 = 0$。\n    - 分支前状态：$(K=7, a=0, \\dots)$。\n    - `if (a != 0)`：条件是 $0 \\neq 0$，为假。\n    - **路径可行性**：到 $B_{\\mathrm{dead}}$ 的分支不可行。唯一可行的转移是到 $B_1$。\n    - $B_0$ 之后的状态：$S_1 = (\\text{PC}=B_1, K=7, a=0, b=?, \\dots)$。\n\n2.  **在 $B_1$ 处**：\n    - 进入时状态：$S_1$。\n    - $b := 2 \\implies b' = 2$。\n    - 分支前状态：$(K=7, a=0, b=2, \\dots)$。\n    - `if ((b + a) != 2)`：条件是 $(2 + 0) \\neq 2$，即 $2 \\neq 2$，为假。\n    - **路径可行性**：到 $B_2$ 的分支不可行。唯一可行的转移是到 $B_3$。\n    - $B_1$ 之后的状态：$S_2 = (\\text{PC}=B_3, K=7, a=0, b=2, c=?, \\dots)$。\n\n3.  **在 $B_3$ 处**：\n    - 进入时状态：$S_2$。\n    - $x := n + b + K - 9 \\implies x' = n + 2 + 7 - 9 = n$。\n    - **最终计算**：返回值为 $x=n$。\n\n此状态转移分析确认了唯一可行的执行路径是 $B_0 \\rightarrow B_1 \\rightarrow B_3$。所执行的简化是正确的。\n\n#### 最终表达式\n\n该函数的返回值是变量 $x$ 的值。从简化和验证后的逻辑来看，$x$ 的表达式为：\n$$x = n$$\n这就是以输入 $n$ 表示的返回值的封闭形式解析表达式。", "answer": "$$\\boxed{n}$$", "id": "3636449"}, {"introduction": "在简化了表达式之后，反编译的下一个核心挑战是重构原始的高级控制结构。底层的机器代码只使用简单的条件跳转，而像 C 或 Java 这样的高级语言则使用如 `if-else` 和循环这样的结构化语句。本练习[@problem_id:3636537]将引导你使用支配性（dominance）和后置支配性（post-dominance）这些编译器理论中的基本概念，从一段汇编代码的控制流图中恢复出嵌套的 `if-else` 结构。", "problem": "反编译器通过分析控制流图（CFG）及其支配和后支配关系来恢复结构化控制流。考虑以下简化的 x86-32 汇编代码片段（假设为 Intel 语法，并且每个标签引入一个唯一的基本块（BB），具有常规的顺序执行语义）：\n\nentry:\n  mov eax, [x]\n  test eax, eax           ; sets Sign Flag (SF) and Zero Flag (ZF)\n  js L_neg                ; jump if SF=1 (negative)\n  cmp eax, [y]            ; sets ZF based on eax == [y]\n  je L_eq                 ; jump if ZF=1 (equal)\nL_ne:\n  add eax, 5\n  jmp L_join\nL_eq:\n  imul eax, 3\n  sub eax, 4\n  jmp L_join\nL_neg:\n  neg eax\n  add eax, 7\n  imul eax, 2\nL_join:\n  lea eax, [eax + 3*eax]  ; multiply eax by 4\n  sub eax, 6\n  mov [out], eax\n  ret\n\n假设 Intel 扩展标志寄存器 (EFLAGS) 具有标准语义：如果结果的最高有效位为 $1$，则设置符号标志 (SF)；如果结果为 $0$，则设置零标志 (ZF)。控制流图（CFG）在标签 $entry$ 处有一个入口，在 $ret$ 处有一个出口。为了计数的目的，将 $\\{\\text{neg}, \\text{add}, \\text{sub}, \\text{imul}, \\text{lea}\\}$ 中的任何指令定义为一次算术运算；其他指令不计为算术运算。\n\n任务：\n1. 使用 CFG 中支配和后支配的标准定义（如果从入口到节点 $n$ 的每条路径都经过节点 $d$，则节点 $d$ 支配节点 $n$；如果从节点 $n$ 到出口的每条路径都经过节点 $p$，则节点 $p$ 后支配节点 $n$），恢复代码片段所隐含的结构化高级 if-else 嵌套，并通过识别哪些基本块（BB）支配或后支配分支点和合并点来证明该结构的合理性。不要提供代码；仅以文字形式提供结构描述。\n\n2. 设 $p \\in [0,1]$ 是 $js$ 处分支被采纳的概率（即在 $test$ 之后 $SF=1$），设 $q \\in [0,1]$ 是在 $js$ 分支未被采纳的情况下，$je$ 处分支被采纳的条件概率（即在 $cmp$ 之后 $ZF=1$）。根据这些定义，推导出一个封闭形式表达式，表示代码片段单次运行所执行的算术运算的期望数量。\n\n将最终的期望算术运算次数表示为关于 $p$ 和 $q$ 的单一简化解析表达式。不需要四舍五入。最终答案必须仅以封闭形式表达式给出。", "solution": "该问题要求对给定的 x86-32 汇编代码片段进行两部分分析。第一部分是使用支配和后支配分析来恢复高级控制结构。第二部分是根据分支的概率信息，推导执行的算术运算的期望数量。\n\n首先，我们必须从汇编代码构建控制流图（CFG）。一个基本块（BB）是一个具有单一入口点和单一出口点的指令序列。所提供的标签和分支指令定义了 CFG 的结构。\n\n基本块如下：\n1.  **B_entry**：该块从 `entry` 标签开始，到第一个条件跳转结束。\n    ```assembly\n    entry:\n      mov eax, [x]\n      test eax, eax\n      js L_neg\n    ```\n    该块有两个后继节点：如果跳转被采纳（`SF=1`），则为 `B_neg`；如果顺序执行，则为 `B_cmp`。\n\n2.  **B_cmp**：该块在 `js` 指令之后开始，到 `je` 跳转结束。\n    ```assembly\n    cmp eax, [y]\n    je L_eq\n    ```\n    该块有两个后继节点：如果跳转被采纳（`ZF=1`），则为 `B_eq`；如果顺序执行，则为 `B_ne`。\n\n3.  **B_ne**：该块对应于 `L_ne` 标签。\n    ```assembly\n    L_ne:\n      add eax, 5\n      jmp L_join\n    ```\n    该块有一个后继节点：`B_join`。\n\n4.  **B_eq**：该块对应于 `L_eq` 标签。\n    ```assembly\n    L_eq:\n      imul eax, 3\n      sub eax, 4\n      jmp L_join\n    ```\n    该块有一个后继节点：`B_join`。\n\n5.  **B_neg**：该块对应于 `L_neg` 标签。\n    ```assembly\n    L_neg:\n      neg eax\n      add eax, 7\n      imul eax, 2\n    ```\n    该块顺序执行到其后继节点 `B_join`。\n\n6.  **B_join**：该块对应于 `L_join` 标签，并包含最终的 `ret` 指令。\n    ```assembly\n    L_join:\n      lea eax, [eax + 3*eax]\n      sub eax, 6\n      mov [out], eax\n      ret\n    ```\n    该块是函数的出口块。\n\nCFG 可总结如下：\n- `B_entry` 分支到 `B_neg` 和 `B_cmp`。\n- `B_cmp` 分支到 `B_eq` 和 `B_ne`。\n- `B_neg`、`B_eq` 和 `B_ne` 都进入 `B_join`。\n- `B_join` 是唯一的出口点。\n\n**第 1 部分：控制流结构恢复**\n\n为了恢复高级结构，我们分析 CFG 的支配和后支配属性。\n- 如果从入口节点到节点 $n$ 的每条路径都必须经过节点 $d$，则节点 $d$ **支配** 节点 $n$。\n- 如果从节点 $n$ 到出口节点的每条路径都必须经过节点 $p$，则节点 $p$ **后支配** 节点 $n$。\n\n一个结构化的 `if-then-else` 语句对应于 CFG 中具有单一入口（头部）和单一出口（合并点）的区域。头部必须支配该区域中的所有块，而合并点必须后支配该区域中的所有块。\n\n1.  **外部结构**：\n    - 分支在 `B_entry` 中，它充当头部。作为入口块，`B_entry` 支配 CFG 中的所有其他块。\n    - 从 `B_entry` 开始的两条路径分别通向 `B_neg` 和 `B_cmp`。\n    - 所有可能的执行路径（`B_entry` $\\rightarrow$ `B_neg` $\\rightarrow$ `B_join`；`B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_eq` $\\rightarrow$ `B_join`；`B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_ne` $\\rightarrow$ `B_join`）在退出前都必须汇合于 `B_join`。\n    - 因此，`B_join` 后支配 `B_entry` 及所有中间块（`B_neg`、`B_cmp`、`B_eq`、`B_ne`）。\n    - 这种单入口（`B_entry`）、单出口（`B_join`）的模式识别出一个 `if-else` 结构。测试条件是 `js L_neg`。`then` 子句对应于通过 `B_neg` 的路径。`else` 子句对应于通过 `B_cmp` 的路径。\n\n2.  **内部结构**：\n    - 在外部结构的 `else` 子句中，我们从 `B_cmp` 开始。\n    - `B_cmp` 包含第二个条件分支 `je L_eq`。该块充当嵌套区域的头部。\n    - `B_cmp` 受 `B_entry` 支配，并支配其后继节点 `B_eq` 和 `B_ne`。\n    - 从 `B_cmp` 出发的路径通向 `B_eq` 和 `B_ne`。\n    - `B_eq` 和 `B_ne` 都有 `B_join` 作为它们唯一的后继节点。因此，`B_join` 后支配 `B_eq` 和 `B_ne`。\n    - 这形成了一个以 `B_cmp` 为头部、`B_join` 为合并点的嵌套 `if-else` 结构。测试条件是 `je L_eq`。`then` 子句是 `B_eq`。`else` 子句是 `B_ne`。\n\n**结构描述**：该汇编代码片段实现了一个嵌套的 `if-else` 结构。外部 `if` 的条件基于 `test eax, eax` 的结果，对应于检查 `eax` 的值是否为负。如果为负，则执行块 `B_neg` 中的代码。否则（如果为零或正），则执行一个嵌套的 `if-else` 结构。内部 `if` 的条件在块 `B_cmp` 中，基于 `cmp eax, [y]`，检查 `eax` 是否等于内存地址 `y` 处的值。如果相等，则执行块 `B_eq` 中的代码；否则，执行块 `B_ne` 中的代码。所有三种可能的执行路径（`B_neg`、`B_eq`、`B_ne`）都在块 `B_join` 处合并，该块包含函数返回前所有路径共有的代码。\n\n**第 2 部分：算术运算的期望数量**\n\n设 $N$ 是表示执行的算术运算数量的随机变量。算术运算集合定义为 $\\{\\text{neg}, \\text{add}, \\text{sub}, \\text{imul}, \\text{lea}\\}$。\n\n首先，我们计算每个相关基本块中的算术运算数量：\n- `B_neg`：`neg`、`add`、`imul` $\\implies 3$ 次运算。\n- `B_eq`：`imul`、`sub` $\\implies 2$ 次运算。\n- `B_ne`：`add` $\\implies 1$ 次运算。\n- `B_join`：`lea`、`sub` $\\implies 2$ 次运算。\n- 根据定义，所有其他块（`B_entry`、`B_cmp`）包含 $0$ 次算术运算。\n\n总运算次数取决于执行路径。`B_join` 中的代码在每条路径上都会执行。\n- **路径 1**：`B_entry` $\\rightarrow$ `B_neg` $\\rightarrow$ `B_join`。如果 `js` 分支被采纳，则走这条路径。\n  - 运算次数，$C_1 = (B_{neg} \\text{中的运算}) + (B_{join} \\text{中的运算}) = 3 + 2 = 5$。\n  - 此路径的概率给定为 $P_1 = p$。\n\n- **路径 2**：`B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_eq` $\\rightarrow$ `B_join`。如果 `js` 分支未被采纳，且随后的 `je` 分支被采纳，则走这条路径。\n  - 运算次数，$C_2 = (B_{eq} \\text{中的运算}) + (B_{join} \\text{中的运算}) = 2 + 2 = 4$。\n  - `js` 分支未被采纳的概率是 $1-p$。`je` 分支被采纳的条件概率是 $q$。\n  - 此路径的概率是 $P_2 = (1-p)q$。\n\n- **路径 3**：`B_entry` $\\rightarrow$ `B_cmp` $\\rightarrow$ `B_ne` $\\rightarrow$ `B_join`。如果 `js` 分支未被采纳，且随后的 `je` 分支也未被采纳，则走这条路径。\n  - 运算次数，$C_3 = (B_{ne} \\text{中的运算}) + (B_{join} \\text{中的运算}) = 1 + 2 = 3$。\n  - `js` 分支未被采纳的概率是 $1-p$。`je` 分支未被采纳的条件概率是 $1-q$。\n  - 此路径的概率是 $P_3 = (1-p)(1-q)$。\n\n算术运算的期望数量 $E[N]$ 是每条路径上的运算数量与该路径概率的乘积之和：\n$$ E[N] = C_1 P_1 + C_2 P_2 + C_3 P_3 $$\n$$ E[N] = 5 \\cdot p + 4 \\cdot (1-p)q + 3 \\cdot (1-p)(1-q) $$\n\n现在，我们简化这个表达式：\n$$ E[N] = 5p + (4q - 4pq) + (3 - 3q - 3p + 3pq) $$\n$$ E[N] = (5p - 3p) + (4q - 3q) + (-4pq + 3pq) + 3 $$\n$$ E[N] = 2p + q - pq + 3 $$\n\n因此，算术运算的期望数量是 $2p + q - pq + 3$。", "answer": "$$\\boxed{2p + q - pq + 3}$$", "id": "3636537"}, {"introduction": "当代码的逻辑和控制结构被重构后，最后一步是生成清晰易读的高级语言代码。现代反编译器内部广泛使用静态单赋值（SSA）形式，但最终输出必须是使用常规变量的代码。这个练习[@problem_id:3636454]聚焦于从 SSA 转换回常规变量的关键优化步骤——副本合并（copy coalescing），你将通过解决一个图论问题来智能地合并变量，以最大限度地减少冗余的赋值操作，从而提高最终代码的可读性。", "problem": "反编译器必须将程序从静态单赋值形式（SSA）转换回常规变量。在 SSA 中，每个变量名仅被赋值一次，控制流连接处的合并由 $\\varphi$-函数表示。在 SSA 消除期间，会插入副本（移动操作）以协调 $\\varphi$-函数，并在直线代码中连接 SSA 名称。一项标准的优化是副本合并：当 SSA 名称的生存期不重叠时，将它们合并成一个单一的常规变量名，从而消除相应的副本。此任务的基础是：\n- SSA、生存期和干涉的定义：两个 SSA 名称可以合并当且仅当它们不干涉，其中干涉意味着它们的生存期在某个程序点重叠。\n- 干涉图：节点是 SSA 名称；两个节点之间的边表示干涉。任何合并的 SSA 名称组都必须是干涉图中的一个独立集（组内没有边）。\n- 副本边：两个 SSA 名称之间的每条副本边，带有一个整数权重 $w$，代表了 $w$ 次副本指令的出现，如果这些名称最终被分在同一个合并组中（即成为同一个常规变量），这些指令就可以被消除。\n\n考虑以下实例，该实例源自一个真实的控制流图（CFG），其 SSA 名称为 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6\\}$，其中干涉边为\n$$I = \\{(v_1,v_3),(v_1,v_5),(v_2,v_4),(v_2,v_5),(v_3,v_4),(v_3,v_6)\\},$$\n带权重的副本边为\n$$M = \\{(v_1,v_2; w=3),\\ (v_2,v_3; w=2),\\ (v_3,v_4; w=2),\\ (v_4,v_5; w=1),\\ (v_5,v_6; w=2),\\ (v_1,v_6; w=1)\\}.$$\n\n您将执行保守副本合并：选择一个将 $V$ 划分为不相交的合并组的方案，使得每个组都是干涉图 $I$ 中的一个独立集。消除的副本总权重 $W_{\\text{coal}}$ 是 $M$ 中所有端点在合并后位于同一合并组内的副本边的权重 $w$ 之和。设 $K$ 为合并组的数量（即最终常规变量名的数量）。\n\n定义一个无量纲的可读性分数\n$$R = 2 \\cdot W_{\\text{coal}} - K.$$\n\n从上述基础定义和约束出发，确定能使 $W_{\\text{coal}}$ 最大化的合并方案，然后计算相应的可读性分数 $R$。将您的最终答案表示为单个实数值。无需四舍五入；给出精确的整数值。", "solution": "用户想要解决一个副本合并问题，这是一个与编译器优化相关的特定类型的图划分问题。\n\n### 步骤1：问题形式化\n\n首先，我们通过提取和结构化给定信息来形式化问题。\nSSA 名称（顶点）的集合是 $V = \\{v_1, v_2, v_3, v_4, v_5, v_6\\}$。\n\n问题在此集合 $V$ 上定义了两种关系：\n1.  一个干涉图 $G_I = (V, I)$，其中一条边 $(u, v) \\in I$ 表示 SSA 名称 $u$ 和 $v$ 不能在同一个合并组中。一个合并组必须是 $G_I$ 中的一个独立集。干涉边的集合是：\n    $$I = \\{(v_1,v_3), (v_1,v_5), (v_2,v_4), (v_2,v_5), (v_3,v_4), (v_3,v_6)\\}$$\n2.  一个副本边集合 $M$，其中每条边 $(u,v; w)$ 代表一个副本指令，如果 $u$ 和 $v$ 被合并到同一个组中，则会带来收益（权重）$w$。副本边及其权重的集合是：\n    $$M = \\{(v_1,v_2; w=3), (v_2,v_3; w=2), (v_3,v_4; w=2), (v_4,v_5; w=1), (v_5,v_6; w=2), (v_1,v_6; w=1)\\}$$\n\n目标是找到 $V$ 的一个划分 $P = \\{P_1, P_2, \\ldots, P_K\\}$，该划分满足两个条件：\n1.  划分中的每个集合 $P_i$ 都是干涉图 $G_I$ 中的一个独立集。\n2.  消除的副本总权重 $W_{\\text{coal}}$ 被最大化。$W_{\\text{coal}}$ 是所有副本边 $(u, v; w) \\in M$ 的权重之和，其中 $u$ 和 $v$ 属于划分 $P$ 中的同一个组 $P_i$。\n\n在找到使 $W_{\\text{coal}}$ 最大化的最优划分后，我们必须计算可读性分数 $R = 2 \\cdot W_{\\text{coal}} - K$，其中 $K$ 是划分中的组数。\n\n### 步骤2：分析约束和潜在的合并\n\n一条副本边 $(u,v;w) \\in M$ 仅当顶点 $u$ 和 $v$ 可以被置于同一组中时，才能将其权重 $w$ 贡献给 $W_{\\text{coal}}$。如果它们相互干涉，即 $(u,v) \\in I$，则这是不可能的。我们首先识别出这种“不可能的”副本边。\n\n-   $(v_1,v_2; w=3)$: 不存在干涉边 $(v_1,v_2) \\in I$。可以合并。\n-   $(v_2,v_3; w=2)$: 不存在干涉边 $(v_2,v_3) \\in I$。可以合并。\n-   $(v_3,v_4; w=2)$: 存在干涉边 $(v_3,v_4) \\in I$。**不可能**合并。权重 $w=2$ 永远无法获得。\n-   $(v_4,v_5; w=1)$: 不存在干涉边 $(v_4,v_5) \\in I$。可以合并。\n-   $(v_5,v_6; w=2)$: 不存在干涉边 $(v_5,v_6) \\in I$。可以合并。\n-   $(v_1,v_6; w=1)$: 不存在干涉边 $(v_1,v_6) \\in I$。可以合并。\n\n设 $M'$ 为可能的副本边集合：\n$M' = \\{(v_1,v_2; w=3), (v_2,v_3; w=2), (v_5,v_6; w=2), (v_4,v_5; w=1), (v_1,v_6; w=1)\\}$。\n这些可能边的总权重是 $3+2+2+1+1=9$。\n\n### 步骤3：寻找最优划分\n\n这是一个组合优化问题。鉴于图的规模很小，我们可以系统地分析各种选择。解决此问题的一个常用启发式方法是贪心方法，即我们按照副本权重的降序来考虑合并配对。\n\n1.  初始状态：每个顶点都在其自己的组中。划分为 $\\{\\{v_1\\}, \\{v_2\\}, \\{v_3\\}, \\{v_4\\}, \\{v_5\\}, \\{v_6\\}\\}$。$W_{\\text{coal}}=0$。\n2.  按权重排序的可能边：$(v_1,v_2; 3)$、$(v_2,v_3; 2)$、$(v_5,v_6; 2)$、$(v_4,v_5; 1)$、$(v_1,v_6; 1)$。\n\n**迭代1**: 考虑边 $(v_1, v_2; w=3)$。\n-   $v_1$ 和 $v_2$ 在不同的组中。\n-   合并后的组 $\\{v_1,v_2\\}$ 必须是一个独立集。由于 $(v_1,v_2) \\notin I$，这是有效的。\n-   我们合并它们，形成组 $\\{v_1,v_2\\}$。划分为 $\\{\\{v_1,v_2\\}, \\{v_3\\}, \\{v_4\\}, \\{v_5\\}, \\{v_6\\}\\}$。\n-   $W_{\\text{coal}}$ 变为 $3$。\n\n**迭代2**: 考虑边 $(v_2, v_3; w=2)$。\n-   $v_2$ 在组 $\\{v_1,v_2\\}$ 中，$v_3$ 在组 $\\{v_3\\}$ 中。\n-   我们测试合并这些组：$\\{v_1,v_2\\} \\cup \\{v_3\\} = \\{v_1,v_2,v_3\\}$。\n-   $\\{v_1,v_2,v_3\\}$ 是一个独立集吗？不是，因为 $(v_1,v_3) \\in I$。\n-   合并被拒绝。$W_{\\text{coal}}$ 仍然是 $3$。这揭示了一个冲突：如果合并意味着创建组 $\\{v_1,v_2,v_3\\}$，我们就不能同时从 $(v_1,v_2)$ 和 $(v_2,v_3)$ 中获益。\n\n**迭代3**: 考虑边 $(v_5, v_6; w=2)$。\n-   $v_5$ 和 $v_6$ 在不同的组中。\n-   合并后的组 $\\{v_5,v_6\\}$ 是一个独立集，因为 $(v_5,v_6) \\notin I$。\n-   我们合并它们，形成 $\\{v_5,v_6\\}$。划分变为 $\\{\\{v_1,v_2\\}, \\{v_3\\}, \\{v_4\\}, \\{v_5,v_6\\}\\}$。\n-   $W_{\\text{coal}}$ 变为 $3+2=5$。\n\n**迭代4**: 考虑边 $(v_4, v_5; w=1)$。\n-   $v_4$ 在组 $\\{v_4\\}$ 中，$v_5$ 在组 $\\{v_5,v_6\\}$ 中。\n-   我们测试合并这些组：$\\{v_4\\} \\cup \\{v_5,v_6\\} = \\{v_4,v_5,v_6\\}$。\n-   $\\{v_4,v_5,v_6\\}$ 是一个独立集吗？我们检查所有配对：$(v_4,v_5) \\notin I$, $(v_4,v_6) \\notin I$, $(v_5,v_6) \\notin I$。是的，它是一个独立集。\n-   我们进行合并，将组更新为 $\\{v_4,v_5,v_6\\}$。划分现在是 $\\{\\{v_1,v_2\\}, \\{v_3\\}, \\{v_4,v_5,v_6\\}\\}$。\n-   $W_{\\text{coal}}$ 变为 $5+1=6$。\n\n**迭代5**: 考虑边 $(v_1, v_6; w=1)$。\n-   $v_1$ 在组 $\\{v_1,v_2\\}$ 中，$v_6$ 在组 $\\{v_4,v_5,v_6\\}$ 中。\n-   我们测试合并这些组：$\\{v_1,v_2\\} \\cup \\{v_4,v_5,v_6\\} = \\{v_1,v_2,v_4,v_5,v_6\\}$。\n-   这是一个独立集吗？不是，原因有多个。例如，$(v_1,v_5) \\in I$。\n-   合并被拒绝。$W_{\\text{coal}}$ 仍然是 $6$。\n\n贪心算法终止。得到的最终划分为 $P = \\{\\{v_1,v_2\\}, \\{v_4,v_5,v_6\\}, \\{v_3\\}\\}$。这个划分有 $K=3$ 个组。\n总权重为 $W_{\\text{coal}} = w(v_1,v_2) + w(v_4,v_5) + w(v_5,v_6) = 3 + 1 + 2 = 6$。\n\n我们来验证这是否是可能的最大权重。识别出的关键冲突是：\n1.  $(v_1,v_2; w=3)$ 和 $(v_2,v_3; w=2)$ 之间，因为 $\\{v_1,v_2,v_3\\}$ 不是一个独立集。为了最大化权重，我们必须选择权重为 $3$ 的边，而不是权重为 $2$ 的边。\n2.  实现包含 $\\{v_1,v_6\\}$ 的组（增益 $w=1$）和实现包含 $\\{v_5,v_6\\}$ 的组（增益 $w=2$）之间，因为 $\\{v_1,v_5,v_6\\}$ 不是一个独立集。贪心选择是优先考虑权重为 $2$ 的。\n\n我们推导出的划分与做出这两个局部最优（贪心）选择是一致的。更深入的分析证实，没有其他合并组合可以实现更高的总权重。例如，优先考虑 $w(v_2,v_3)=2$ 而不是 $w(v_1,v_2)=3$ 将导致可能的最大 $W_{\\text{coal}}$ 为 $2 + w(v_4,v_5) + w(v_5,v_6) = 2+1+2=5$，这是次优的。因此，$W_{\\text{coal}} = 6$ 确实是最大值。\n\n此外，划分 $\\{\\{v_1,v_2\\}, \\{v_4,v_5,v_6\\}, \\{v_3\\}\\}$ 是达到此最大权重的唯一划分，因为对顶点 $v_3$ 的任何其他放置都会违反干涉约束。因此，$K$ 的值也是唯一确定的。\n\n### 步骤4：计算可读性分数\n\n确定了最优合并方案后，我们现在可以计算可读性分数 $R$。\n-   最大化的消除副本总权重：$W_{\\text{coal}} = 6$。\n-   最优划分中的合并组数量：$K = 3$。\n\n可读性分数的定义为 $R = 2 \\cdot W_{\\text{coal}} - K$。\n代入数值：\n$$R = 2 \\cdot 6 - 3 = 12 - 3 = 9$$\n\n相应的可读性分数为 $9$。", "answer": "$$\\boxed{9}$$", "id": "3636454"}]}