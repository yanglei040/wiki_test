{"hands_on_practices": [{"introduction": "编译的第一步，即词法分析，看似简单，但此处的错误可能会产生连锁的安全效应。本练习探讨了一个有缺陷的词法分析器如何错误地解释整数文字，从而颠覆语言的类型系统并导致危险的符号错误。通过构建一个能暴露此类漏洞的测试用例并设计稳健的解析规则，你将理解正确处理数据表示在保障软件安全中的关键作用。[@problem_id:3629625]", "problem": "考虑一种类C语言 MiniC，其编译器前端使用确定性有限自动机（DFA）进行词法分析。MiniC 拥有有符号 $32$ 位整数 $\\mathrm{int32}$，其范围为 $[-2^{31}, 2^{31}-1]$（二进制补码），以及无符号 $32$ 位整数 $\\mathrm{u32}$，其范围为 $[0, 2^{32}-1]$。无后缀的整数字面量应由语义分析根据其数学值 $v \\in \\mathbb{Z}$ 来选择一个可以表示该值的类型，而带后缀的字面量（例如，字母‘U’表示无符号类型）则应强制使用相应的无符号类型。对于二元运算符，MiniC 在代码生成前应用常规算术转换来计算两个操作数的公共类型。\n\n一项安全审计揭示，词法分析器在对带后缀的字面量进行分词时存在错误，它会将任何尾随的字母分割成一个独立的标识符词元。此外，词法分析器会立即将字面量的数值存储在一个定宽的有符号 $32$ 位容器中，这实际上是将任何数学值 $v$ 映射为 $v \\pmod{2^{32}}$，然后将其解释为 $[-2^{31}, 2^{31}-1]$ 范围内的有符号数。结果是，一个预期值 $\\ge 2^{31}$ 的字面量在其词元中被记录为一个负的有符号数。在后续阶段，一个有缺陷的后端启发式方法仅根据字面量词元来选择比较操作的有符号性（而不是根据常规算术转换计算出的公共类型），因此一个被错误分类的字面量会强制进行有符号比较。\n\n你的任务是完成两个基于词法分析和整数表示基本原理的目标：\n\n- 设计一个最小化的确定性测试，该测试在所述的词法分析器和后端启发式方法下会可靠地失败。失败的原因是符号性不匹配导致比较的真值相对于该语言的预期语义发生了翻转。你的测试应使用一个类型为 $\\mathrm{u32}$ 的变量 $n$ 和一个带无符号后缀的字面量，该字面量表示一个等于或大于 $2^{31}$ 的边界值。\n- 提出一套健壮的字面量类型规则，从数字字面量的正则语言性质及其所表示的数学整数 $v$ 出发，从构造上消除此漏洞。这些规则必须明确如何识别后缀、如何存储 $v$、如何选择类型，以及在代码生成前如何应用转换，包括有符号和无符号类型的精确范围公式。\n\n哪个选项既提供了一个最小化的失败测试，又提供了一套字面量类型规则，能够可证明地防止由错误分类引起的符号性错误，同时不破坏有效的程序？\n\nA. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为无符号边界值 $2^{31}$ 且带后缀‘U’的字面量进行比较。选择输入 $n = 1$ 并检查 $n > \\text{literal}$ 是否为真。在有缺陷的词法分析器下，字面量词元将 $v = 2^{31}$ 存储为有符号值 $-2^{31}$，并且后端会生成一个有符号比较，因此条件评估为 $1 > -2^{31}$，结果为假，这与预期的无符号语义 $1 > 2^{31}$（结果为真）相矛盾。规则：将数字字面量视为一个正则语言，其 DFA 将后缀作为字面量词元的一部分；在词法分析期间，将数学值 $v \\in \\mathbb{Z}$ 存储在一个无界整数中；在语义分析时，如果存在后缀，则将其确定性地映射到确切的目标无符号类型；如果不存在后缀，则从一个有序的候选序列中选择能够表示 $v$ 的最小类型；对于宽度为 $w$ 的类型，有符号范围计算为 $[-2^{w-1}, 2^{w-1}-1]$，无符号范围计算为 $[0, 2^{w}-1]$；只有在类型选择之后，才将 $v$ 转换为所选类型；对于二元运算符，在代码生成前使用常规算术转换计算公共类型；如果 $v$ 超出所选类型的范围，则发出诊断信息。\n\nB. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为 $2^{31}-1$ 且带后缀‘LL’的字面量进行比较。选择 $n=1$ 并检查 $n \\le \\text{literal}$。由于 $2^{31}-1$ 可以容纳在有符号 $32$ 位整数中，该错误不会改变符号，因此测试不会失败。规则：仅在解析器中而不是词法分析器中识别后缀；在词法分析时将 $v$ 存储在有符号 $32$ 位整数中，然后通过重新解释位来“修复”类型；依赖常量折叠来调整符号性。\n\nC. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个小的十进制字面量（例如，一个严格小于 $2^{31}$ 的值）且带后缀‘U’进行比较。选择 $n=1$ 并检查 $n > \\text{literal}$。由于对于小值，符号不会翻转，因此错误分类没有效果，测试无法检测到该错误。规则：如果后缀无法识别，则忽略它；无论值大小，都将无后缀字面量的类型默认为有符号 $\\mathrm{int32}$；在不计算公共类型的情况下，对每个操作数单独执行转换。\n\nD. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为 $2^{64}-1$ 且带后缀‘ULL’的字面量进行比较。选择 $n=1$ 并检查 $n \\le \\text{literal}$。有缺陷的词法分析器会将该值截断为有符号 $32$ 位整数，而解析器随后会因常量折叠中的溢出而拒绝该程序，因此该测试在不同实现中是不确定的。规则：接受任意顺序的后缀字母，但立即将数值 $v$ 存储在有符号 $32$ 位整数中；如果 $v$ 溢出，则进行模 $2^{32}$ 的环绕并继续；仅从左操作数选择比较的符号性。\n\n选择最佳选项。", "solution": "问题陈述描述了类C语言 MiniC 编译器中的一组漏洞。这些漏洞源于三个不同缺陷的相互作用：\n1.  词法分析缺陷：词法分析器错误地对带后缀的整数字面量（例如 `2147483648U`）进行分词，将其分割成一个整数字面量词元（`2147483648`）和一个独立的标识符词元（`U`）。\n2.  数据表示缺陷：词法分析器立即将数字字符串转换为定宽的有符号 $32$ 位整数。由于二进制补码表示法，这导致数学值 $v \\ge 2^{31}$ 会“环绕”并被存储为负数。具体来说，一个值 $v$ 通过先计算 $v \\pmod{2^{32}}$，然后将结果的位模式解释为有符号 $32$ 位整数，从而映射到一个存储值 $v_s$。\n3.  后端启发式缺陷：比较操作的符号性由字面量词元的类型（现在是错误的符号类型）决定，而不是由语言规定的常规算术转换推导出的公共类型决定。\n\n任务是找出一个选项，该选项既能提供一个在这些条件下可靠失败的最小化测试用例，又能提供一套可证明修复这些漏洞的健壮的字面量类型规则。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n- 语言：MiniC，类C。\n- 数据类型：\n    - $\\mathrm{int32}$：有符号 $32$ 位整数，范围 $[-2^{31}, 2^{31}-1]$，二进制补码。\n    - $\\mathrm{u32}$：无符号 $32$ 位整数，范围 $[0, 2^{32}-1]$。\n- 字面量语义（预期）：\n    - 无后缀字面量由语义分析根据其数学值 $v \\in \\mathbb{Z}$ 确定类型。\n    - 带后缀的字面量（例如，带'U'）强制使用相应的无符号类型。\n- 运算符语义（预期）：\n    - 二元运算符使用常规算术转换来寻找操作数的公共类型。\n- 编译器缺陷：\n    1.  词法分析器将后缀从字面量中分离出来，创建一个独立的标识符词元。\n    2.  词法分析器将字面量的数值存储在一个有符号 $32$ 位容器中，通过模 $2^{32}$ 运算将 $v$ 映射到 $[-2^{31}, 2^{31}-1]$ 范围内的一个值。值 $v \\ge 2^{31}$ 会被存储为负数。\n    3.  后端启发式方法使用字面量词元（现在是不正确的）的符号性进行比较，绕过了常规算术转换。\n- 任务目标：\n    1.  设计一个最小化的确定性测试，该测试会引起符号性不匹配，从而翻转比较的结果。测试必须使用一个 $\\mathrm{u32}$ 变量 $n$ 和一个表示边界值 $\\ge 2^{31}$ 且带无符号后缀的字面量。\n    2.  提出健壮的字面量类型规则来消除此漏洞。\n\n**步骤 2：使用提取的已知信息进行验证**\n问题陈述在科学上基于计算机科学的既定原则，包括编译器设计（词法分析、语义分析、代码生成）、数据表示（二进制补码整数）和类型系统。所描述的错误是合理的实现错误。问题提法良好，提供了清晰的背景和具体、可解决的任务。所用语言客观而精确。问题没有违反任何无效标准。\n\n**步骤 3：结论与行动**\n问题陈述是**有效**的。可以进行分析。\n\n### 解决方案推导\n\n**第一部分：设计最小化失败测试**\n\n目标是创建一个其真值会被该错误翻转的比较。这需要一个场景：预期的无符号比较得到一个结果，而强制的有符号比较得到相反的结果。\n\n1.  **选择字面量**：我们需要一个带有无符号后缀且数学值 $v \\ge 2^{31}$ 的字面量。满足条件的最小边界值是 $v = 2^{31}$。其十进制表示为 $2147483648$。带有无符号后缀，字面量为 `2147483648U`。\n2.  **分析预期语义**：\n    - 变量 $n$ 的类型为 $\\mathrm{u32}$。\n    - 字面量 `2147483648U` 的值为 $v = 2^{31}$，并且是显式无符号的。其类型应为 $\\mathrm{u32}$。\n    - 比较 `n > 2147483648U` 涉及两个 $\\mathrm{u32}$ 类型的操作数。公共类型是 $\\mathrm{u32}$，因此执行无符号比较。\n    - 让我们为 $n$ 选择一个较小的值，例如 $n=1$。表达式为 $1 > 2^{31}$。这在数学上是**真**的。\n3.  **分析错误语义**：\n    - 词法分析器看到 `2147483648U`。它产生两个词元：一个用于 $2147483648$ 的整数字面量和一个标识符 `U`。\n    - 词法分析器将值 $v = 2^{31}$ 存储在一个有符号 $32$ 位容器中。$2^{31}$ 的二进制表示是一个 $1$ 后面跟着 $31$ 个零：`1000...000`。在二进制补码中，此位模式表示有符号值 $-2^{31}$。因此，字面量词元包含值 $-2^{31}$。\n    - 后端看到比较 `n > literal`。由于存在缺陷的启发式方法，它检查字面量的词元，看到一个有符号值，并强制进行*有符号比较*。\n    - 比较变成了对 $1 > -2^{31}$ 的有符号求值。这在数学上是**假**的。\n\n测试用例 `u32 n = 1; if (n > 2147483648U) ...` 成功地展示了这一失败，因为在正确语义下条件评估为 `true`，而在错误实现下评估为 `false`。这个测试是最小化的，因为它使用了触发环绕行为的最小整数值。\n\n**第二部分：设计健壮的字面量类型规则**\n\n这些规则必须从构造上解决每一个缺陷。\n\n1.  **词法分析**：数字字面量的正则语言（及其对应的DFA）必须定义为将后缀作为词元的一部分。词法分析器不应执行任何语义解释或向定宽类型的转换。它应将数字的完整字符串表示（例如 `\"2147483648\"`）和后缀（例如 `\"U\"`）传递给解析器，或者最好是将数字解析为任意精度整数类型以保留数学值 $v$。\n2.  **语义分析**：这是确定类型的正确阶段。\n    - 字面量的抽象语法树（AST）节点将包含其数学值 $v$ 和任何后缀信息。\n    - **带后缀的字面量**：如果存在后缀（例如 `U`），它决定了目标类型（例如无符号）。然后编译器检查 $v$ 是否在该类型的有效范围内（例如，对于 $\\mathrm{u32}$，是否 $v \\in [0, 2^{32}-1]$？）。如果不在，则产生编译时错误。\n    - **无后缀的字面量**：如果没有后缀，编译器应从一个潜在类型的有序列表中（例如 $\\mathrm{int32}$、$\\mathrm{u32}$ 等）选择第一个可以表示 $v$ 的类型。为此，精确的范围定义至关重要：有符号 $w$ 位整数为 $[-2^{w-1}, 2^{w-1}-1]$，无符号为 $[0, 2^w-1]$。\n3.  **二元操作和代码生成**：对于任何二元运算符，两个操作数的类型（在语义分析期间确定）用于通过语言指定的常规算术转换来找到一个公共类型。然后后端根据这个公共类型接收一条指令（例如，“无符号小于”），并生成相应的机器代码。后端绝不能有自己的临时类型推断启发式方法。\n\n这些规则清晰地分离了关注点（词法分析 vs. 解析 vs. 语义），并确保在生成任何代码之前正确且无损地推导出类型信息，从而消除了该漏洞。\n\n### 逐项分析选项\n\n**A. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为无符号边界值 $2^{31}$ 且带后缀‘U’的字面量进行比较。选择输入 $n = 1$ 并检查 $n > \\text{literal}$ 是否为真。在有缺陷的词法分析器下，字面量词元将 $v = 2^{31}$ 存储为有符号值 $-2^{31}$，并且后端会生成一个有符号比较，因此条件评估为 $1 > -2^{31}$，结果为假，这与预期的无符号语义 $1 > 2^{31}$（结果为真）相矛盾。规则：将数字字面量视为一个正则语言，其 DFA 将后缀作为字面量词元的一部分；在词法分析期间，将数学值 $v \\in \\mathbb{Z}$ 存储在一个无界整数中；在语义分析时，如果存在后缀，则将其确定性地映射到确切的目标无符号类型；如果不存在后缀，则从一个有序的候选序列中选择能够表示 $v$ 的最小类型；对于宽度为 $w$ 的类型，有符号范围计算为 $[-2^{w-1}, 2^{w-1}-1]$，无符号范围计算为 $[0, 2^{w}-1]$；只有在类型选择之后，才将 $v$ 转换为所选类型；对于二元运算符，在代码生成前使用常规算术转换计算公共类型；如果 $v$ 超出所选类型的范围，则发出诊断信息。**\n- **测试分析**：提议的测试用例及其分析与上面推导的完全相同。它是最小化、确定性的，并通过显示翻转的真值正确地暴露了错误。\n- **规则分析**：提议的规则是对一个健壮的编译器前端的全面和正确的描述。它们直接解决了所有三个已识别的缺陷：词法分析器正确地对后缀进行分词，无界整数防止了过早的环绕，并且类型选择/转换在语义分析期间得到正确处理，没有为有缺陷的后端启发式方法留下空间。范围公式是正确的。\n- **结论**：**正确**。\n\n**B. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为 $2^{31}-1$ 且带后缀‘LL’的字面量进行比较。选择 $n=1$ 并检查 $n \\le \\text{literal}$。由于 $2^{31}-1$ 可以容纳在有符号 $32$ 位整数中，该错误不会改变符号，因此测试不会失败。规则：仅在解析器中而不是词法分析器中识别后缀；在词法分析时将 $v$ 存储在有符号 $32$ 位整数中，然后通过重新解释位来“修复”类型；依赖常量折叠来调整符号性。**\n- **测试分析**：该测试使用值 $2^{31}-1$，它是有符号 $32$ 位整数的最大正值。由于 $v  2^{31}$，涉及负数环绕的错误不会被触发。该选项中的分析正确地指出测试不会失败，因此它不是一个有效的用于演示该错误的测试。`LL` 后缀也可能意味着一个 $64$ 位类型，这在 MiniC 的问题描述中并未指定。\n- **规则分析**：提议的规则存在根本性缺陷。将后缀识别与词法分析器分离是一个糟糕的设计。将值存储在有符号 $32$ 位容器中正是我们需要修复的错误，因为信息会丢失。试图稍后“修复”它是不健壮的。\n- **结论**：**不正确**。\n\n**C. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个小的十进制字面量（例如，一个严格小于 $2^{31}$ 的值）且带后缀‘U’进行比较。选择 $n=1$ 并检查 $n > \\text{literal}$。由于对于小值，符号不会翻转，因此错误分类没有效果，测试无法检测到该错误。规则：如果后缀无法识别，则忽略它；无论值大小，都将无后缀字面量的类型默认为有符号 $\\mathrm{int32}$；在不计算公共类型的情况下，对每个操作数单独执行转换。**\n- **测试分析**：与选项 B 类似，此测试使用的值不会触发关键的错误机制（$v \\ge 2^{31}$）。该选项自己的推理证实了该测试是无效的。\n- **规则分析**：这些规则不正确且危险。静默忽略后缀会改变程序员的意图。将所有无后缀字面量默认为 $\\mathrm{int32}$ 将使得无法在没有后缀的情况下表示像 $3 \\times 10^9$ 这样的大无符号常量，这与标准C行为背道而驰。绕过常规算术转换会破坏C类型系统的核心部分。\n- **结论**：**不正确**。\n\n**D. 测试：令 $n$ 为 $\\mathrm{u32}$ 类型，并将其与一个预期为 $2^{64}-1$ 且带后缀‘ULL’的字面量进行比较。选择 $n=1$ 并检查 $n \\le \\text{literal}$。有缺陷的词法分析器会将该值截断为有符号 $32$ 位整数，而解析器随后会因常量折叠中的溢出而拒绝该程序，因此该测试在不同实现中是不确定的。规则：接受任意顺序的后缀字母，但立即将数值 $v$ 存储在有符号 $32$ 位整数中；如果 $v$ 溢出，则进行模 $2^{32}$ 的环绕并继续；仅从左操作数选择比较的符号性。**\n- **测试分析**：值 $2^{64}-1$ 过大，没有必要。虽然它确实会触发环绕（在有符号 $32$ 位词元中它会变成 $-1$），但它也可能触发编译器中的其他错误处理路径（例如，常量的溢出错误），正如选项本身所指出的。与使用 $2^{31}$ 相比，这使得它成为一个可靠性较低且非最小化的测试。\n- **规则分析**：所提出的规则是对一个损坏的编译器的描述，而不是一个修复方案。它们明确指出要将值存储在带有环绕的有符号 $32$ 位容器中，这本身就是漏洞所在。仅从左操作数选择符号性是武断且不正确的。\n- **结论**：**不正确**。\n\n基于详细分析，选项A是唯一一个既提供了正确、最小化的失败测试，又提供了一套健壮、合理的规则来修复该漏洞的选项。", "answer": "$$\\boxed{A}$$", "id": "3629625"}, {"introduction": "编译器优化旨在提升性能，但有时会无意中引入安全漏洞，尤其是在时序侧信道方面。本练习将探讨一种常见的优化——强度削减（strength reduction）——如何通过改变代码的执行时间特性，将一个原本安全的程序变得易受攻击。通过分析该优化如何放大与秘密数据相关的时序差异，你将学会如何设计实验来检测此类泄漏，并构思相应的缓解策略。[@problem_id:3629623]", "problem": "一个实现意图通过强制执行数据无关的控制流和固定的循环边界来抵抗侧信道攻击，但它允许内存访问步幅依赖于一个从秘密派生的值。考虑一个长度为 $N$ 的数组 $A$ 和一个秘密 $x$。一个预处理步骤将 $x$ 映射到一个整数 $b \\in \\{0,1,2\\}$，并设置一个步幅 $s = 2^{4b}$，因此 $s \\in \\{16,64,256\\}$。循环执行恰好 $N$ 次访问，迭代变量 $i$ 的范围从 $0$ 到 $N-1$，计算索引 $j_i = (i \\cdot s) \\pmod N$，并将 $A[j_i]$ 累加到一个运行总和中。编译目标是一个现代处理器，其中整数乘法在不同操作数间具有近似固定的延迟，而内存子系统的行为则依赖于访问步幅（例如，缓存和转译后备缓冲器的交互会产生与步幅相关的吞吐量）。使用了两种编译器配置：一种是没有循环强度削减和最小化优化的基线配置，另一种是应用了循环强度削减的激进优化器，它将 $j_i = (i \\cdot s) \\pmod N$ 替换为归纳变量更新 $j_{i+1} = (j_i + s) \\pmod N$。\n\n使用以下基本原则：\n- 常数时间编程的定义：执行时间 $T$ 必须独立于秘密输入，即 $T(x)$ 对于 $x$ 是不变的。\n- 广泛观察到的处理器行为：整数乘法的延迟在不同操作数间近似恒定，而内存访问吞吐量会随步幅变化；因此，强度削减前的每次迭代时间模型为 $C_{\\text{iter}}(s) \\approx C_{\\text{mul}} + C_{\\text{mem}}(s)$，强度削减后为 $C_{\\text{iter}}(s) \\approx C_{\\text{mem}}(s)$。\n- 侧信道泄漏的统计检测：可以通过重复试验和假设检验来评估观测到的总时间 $T$ 与秘密派生特征（例如，$z = \\log_2 s$）之间的相关性。\n\n哪个选项最好地提出了一个科学合理的测试，以揭示由优化器引起的、与秘密相关步幅 $s$ 相关的时序可变性，并概述了在保持抗侧信道能力的同时保留计算正确性的缓解措施？请选择测试方法能够分离优化器的循环强度削减效应，并且其缓解策略能够从与时间相关的资源中移除秘密的影响，同时不引入与秘密相关的控制流的选项。\n\nA. 将 $N$ 固定为一个大的2的幂，并通过从 $x$ 派生的 $b \\in \\{0,1,2\\}$ 设置 $s = 2^{4b}$，使 $s \\in \\{16,64,256\\}$。运行恰好 $N$ 次迭代并计算 $j_i = (i \\cdot s) \\pmod N$。在两种模式下编译：无循环强度削减的基线模式（例如，禁用相关的优化遍）和启用循环强度削减的激进优化模式。在每种模式下，对每个步幅使用时间戳计数器（TSC）收集 $K$ 个时间样本 $T$，并在每次运行之间随机化缓存状态以避免混淆效应。测试 $T$ 与 $z = \\log_2 s$ 之间的相关系数是否仅在激进优化下具有统计显著性。使用每次迭代的时间模型 $C_{\\text{iter}}(s)$ 解释结果，并得出结论：强度削减移除了近似恒定的 $C_{\\text{mul}}$，放大了与步幅相关的 $C_{\\text{mem}}(s)$，从而引入了与 $s$ 相关的时序可变性。缓解措施：通过重写算法以使用固定步幅 $s = 1$ 并应用掩码累加来消除与秘密相关的地址和步幅，从而无论 $x$ 为何，所有 $N$ 个元素都以相同顺序被访问；将被秘密污染的算术和索引操作限制在标注为禁用循环强度削减的函数内（例如，一个函数级优化屏障），同时通过经验测试验证 $T$ 与 $x$ 无关；可选择通过以固定模式接触每个缓存行中的一个代表性元素来均衡缓存足迹以平滑 $C_{\\text{mem}}(s)$，并用重复测量统计数据验证时序不再与 $z$ 相关。\n\nB. 改变秘密 $x$ 以触发一个条件分支，当 $b=2$ 时跳过一半的迭代，使用激进优化进行编译，并仅在激进优化下使用TSC测量 $T$。将观察到的时间差异归因于循环强度削减，并通过启用分支预测提示来缓解，同时保持步幅与秘密相关，因为分支预测会消除时序可变性。\n\nC. 固定 $N$ 并从 $x$ 中选择 $s \\in \\{16,64,256\\}$，但只运行 $M = N/s$ 次迭代，以便总迭代次数随 $x$ 变化。在无优化和激进优化两种情况下测量 $T$，并使用单样本均值来断定强度削减导致了泄漏。通过禁用内联（例如，关闭函数内联）来缓解，同时保持与秘密相关的步幅不变，因为内联是侧信道泄漏的主要来源。\n\nD. 将 $s$ 固定为一个与 $x$ 无关的常数，并在激进优化下运行时间测量，在每次运行之间刷新缓存以消除缓存效应。如果观察到任何时间变化，将其归因于对秘密相关算术的强度削减。缓解措施：启用帧指针和调试信息，这将限制优化器并减少时间差异，而无需重写算法。", "solution": "问题陈述是计算机安全领域中一个有效且定义明确的场景，特别是关于由编译器优化引起的侧信道攻击。\n\n### 第1步：提取已知条件\n- 长度为 $N$ 的数组 $A$。\n- 一个秘密 $x$。\n- 一个预处理步骤将 $x$ 映射到整数 $b \\in \\{0,1,2\\}$。\n- 步幅 $s$ 从 $b$ 派生：$s = 2^{4b}$，这意味着 $s \\in \\{16, 64, 256\\}$。\n- 循环精确执行 $N$ 次，迭代变量 $i$ 从 $0$ 到 $N-1$。\n- 在每次迭代中，计算索引 $j_i = (i \\cdot s) \\pmod N$。\n- 值 $A[j_i]$被累加到一个总和中。\n- 目标是一个现代处理器，其整数乘法具有近似固定的延迟，但内存访问吞吐量依赖于访问步幅 $s$。\n- 存在两种编译器配置：\n    1.  基线：无循环强度削减。\n    2.  激进：应用循环强度削减，将索引计算从 $j_i = (i \\cdot s) \\pmod N$ 更改为增量更新 $j_{i+1} = (j_i + s) \\pmod N$。\n- 提供了基本原则：\n    1.  常数时间定义：执行时间 $T$ 必须独立于秘密 $x$，即 $T(x)$ 是不变的。\n    2.  每次迭代的时间模型：强度削减前，$C_{\\text{iter}}(s) \\approx C_{\\text{mul}} + C_{\\text{mem}}(s)$。强度削减后，$C_{\\text{iter}}(s) \\approx C_{\\text{mem}}(s)$，其中 $C_{\\text{mul}}$ 是常数，$C_{\\text{mem}}(s)$ 依赖于步幅 $s$。\n    3.  统计检测：总时间 $T$ 与秘密派生特征（例如，$z = \\log_2 s$）之间的相关性可用于检测泄漏。\n\n### 第2步：使用提取的已知条件进行验证\n- **科学依据：** 该问题牢固地植根于计算机体系结构和编译器理论的既定原则。不同的内存访问步幅 ($s$) 会因缓存行使用、TLB命中/未命中和内存预取器行为而导致不同性能，这是一个有据可查的现象。循环强度削减是一种标准的编译器优化。该场景描述了一个经典的例子，说明一个看似无害的性能优化如何引入安全漏洞（时序侧信道）。时间模型是合理的一阶近似。\n- **定义明确：** 该问题定义明确。它设置了一个特定的计算场景，并要求找到最佳方法来测试假设的漏洞然后进行缓解。一个好答案的标准被清晰定义：分离优化器的影响并提出有效的缓解措施。\n- **客观性：** 该问题以客观、技术性的语言陈述。\n- **结论：** 该问题是有效的。它提出了一个编译器安全领域中现实且可分析的场景。\n\n### 第3步：推导解决方案\n问题的核心在于理解循环强度削减如何影响总执行时间对源于秘密的步幅 $s$ 的依赖性。\n\n设总执行时间为 $T(s)$。鉴于有 $N$ 次迭代，忽略循环开销，总时间为 $T(s) = N \\cdot C_{\\text{iter}}(s)$。\n\n1.  **基线编译器（无强度削减）：**\n    每次迭代的成本由模型 $C_{\\text{iter, baseline}}(s) \\approx C_{\\text{mul}} + C_{\\text{mem}}(s)$ 给出。\n    总时间为 $T_{\\text{baseline}}(s) \\approx N \\cdot (C_{\\text{mul}} + C_{\\text{mem}}(s)) = N \\cdot C_{\\text{mul}} + N \\cdot C_{\\text{mem}}(s)$。\n    在这里，执行时间有两个组成部分。第一部分，$N \\cdot C_{\\text{mul}}$，相对于源于秘密的步幅 $s$ 来说是大的且恒定的。第二部分，$N \\cdot C_{\\text{mem}}(s)$，随 $s$ 变化。在许多实际场景中，$C_{\\text{mem}}(s)$ 的变化可能相对于 $C_{\\text{mul}}$ 的量级来说很小。因此，来自内存系统的时序信号被每次迭代中乘法的大量、恒定时间的工作所掩盖或减弱。$T_{\\text{baseline}}(s)$ 对 $s$ 的依赖性可能很弱，难以进行统计测量。\n\n2.  **激进编译器（有强度削减）：**\n    编译器用一个更廉价的加法替换了循环内昂贵的乘法 $i \\cdot s$，该加法位于时序关键路径之外（归纳变量更新）。\n    现在每次迭代的成本为 $C_{\\text{iter, aggressive}}(s) \\approx C_{\\text{mem}}(s)$。\n    总时间为 $T_{\\text{aggressive}}(s) \\approx N \\cdot C_{\\text{mem}}(s)$。\n    在这种情况下，来自乘法的大量、恒定项消失了。总执行时间现在与依赖步幅的内存访问时间成正比。$C_{\\text{mem}}(s)$ 的任何变化都将直接反映在总时间 $T_{\\text{aggressive}}(s)$ 中。这放大了时序侧信道，使得 $T$ 和 $s$ 之间的相关性更强，更容易检测。\n\n**推导结论：** 循环强度削减优化通过从循环中移除恒定时间的乘法，使程序的执行时间对与秘密相关的步幅 $s$ 更加敏感，从而引入了一个可检测的时序侧信道漏洞。\n\n一个科学合理的测试因此必须：\n- 比较基线编译代码与激进优化代码的时序行为。\n- 使用严格的统计方法对大量样本进行分析，以确认执行时间 $T$ 和源于秘密的步幅 $s$ 之间的显著相关性仅在激进优化版本中出现（或显著增强）。\n\n一个合理的缓解策略必须：\n- 移除与时间相关的操作对秘密的依赖。这可以通过以下任一方式实现：\n    a) 重写算法使其数据无关（例如，使用固定步幅和掩码操作），这从根本上消除了原因。\n    b) 特别地阻止有害的优化（例如，使用编译器指令或函数属性）以恢复乘法的掩盖效果。\n\n### 逐项分析\n\n**A. 将 $N$... 设置 $s \\in \\{16,64,256\\}$... 在两种模式下编译：基线... 和激进... 收集 $K$ 个时间样本... 测试 $T$ 和 $z = \\log_2 s$ 之间的相关系数是否仅在激进优化下具有统计显著性... 缓解措施：通过重写算法以使用固定步幅 $s = 1$ 并应用掩码累加来消除与秘密相关的地址... 将被秘密污染的算术... 限制在标注为禁用循环强度削减的函数内... 可选择均衡缓存足迹... 用重复测量统计数据验证...**\n\n- **分析：** 该选项提出了一个方法论上完美的实验。它正确地指出了需要比较两种编译器配置以分离循环强度削减的影响。它规定了适当的实验控制，如收集大量样本（$K$）和随机化缓存状态。统计检验（相关系数）适用于量化时间 $T$ 和与秘密相关的特征 $z = \\log_2 s$ 之间的关系。对结果的解释与我们的推导完全吻合。所提出的缓解措施是全面的，并代表了最佳实践：为实现数据无关性而重写（最稳健）或局部禁用有害优化（一种务实的替代方案）。最后的验证步骤对任何安全修复都至关重要。\n- **结论：** **正确**。\n\n**B. 改变秘密 $x$ 以触发一个条件分支，当 $b=2$ 时跳过一半的迭代，使用激进优化进行编译，并仅在激进优化下使用TSC测量 $T$。将观察到的时间差异归因于循环强度削减，并通过启用分支预测提示来缓解...**\n\n- **分析：** 这个选项存在根本性缺陷。问题陈述明确指出“恰好 $N$ 次访问”，意味着数据无关的控制流。选项B将问题改变为一个带有秘密相关分支的问题，这是一种公然且不同类型的侧信道漏洞。它没有测试循环强度削减对内存访问模式的影响。此外，其缓解策略毫无意义；分支预测并不能消除时序信道，其误预测本身就是泄漏的主要来源。\n- **结论：** **不正确**。\n\n**C. 固定 $N$ 并从 $x$ 中选择 $s \\in \\{16,64,256\\}$，但只运行 $M = N/s$ 次迭代... 使用单样本均值来断定强度削减导致了泄漏。通过禁用内联来缓解...**\n\n- **分析：** 这个选项在多个方面都是错误的。首先，与选项B一样，它通过使迭代次数（$M=N/s$）依赖于秘密来改变问题的基本结构，这与“恰好 $N$ 次访问”的约束相矛盾。这引入了一个易于检测的时序泄漏，与正在研究的微妙机制无关。其次，“单样本均值”在统计上是无意义的，代表了糟糕的科学方法论。第三，禁用内联的缓解措施是错误的；根本原因是循环强度削减，而不是函数内联。\n- **结论：** **不正确**。\n\n**D. 将 $s$ 固定为一个与 $x$ 无关的常数，并在激进优化下运行时间测量... 缓解措施：启用帧指针和调试信息...**\n\n- **分析：** 这个选项的测试方法论是无效的。如果步幅 $s$ 是固定的且不依赖于秘密 $x$，那么关于 $x$ 的信息就没有通道可以通过依赖步幅的时序泄漏出去。这个实验无法检测到所讨论的漏洞。缓解策略也很差；依赖调试标志（“启用帧指针”）的副作用来保护代码不是一种可靠或有原则的方法。需要一种有针对性的方法。\n- **结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "3629623"}, {"introduction": "安全考量必须深入到编译器的后端，甚至包括其最关键的任务之一：寄存器分配。本练习将带你探究寄存器分配中的一个积极优化——合并（coalescing）——如何无意中将秘密数据和公开数据分配到同一个物理寄存器中。这种行为会因硬件的数据残留效应（data remanence）而导致信息泄漏，你将通过修改寄存器分配的底层约束来学习如何从根本上实施安全策略。[@problem_id:3629593]", "problem": "考虑一个编译器后端，该后端通过对干涉图进行图着色来执行寄存器分配。干涉图定义为 $G=(V,E)$，其中每个节点 $v \\in V$ 是一个临时变量，当且仅当 $u$ 和 $v$ 在某个程序点同时活跃时，存在一条无向边 $(u,v) \\in E$。分配器有 $k$ 个物理寄存器，表示为集合 $R=\\{r_1,\\dots,r_k\\}$，并使用合并技术来消除移动指令：如果存在一条移动指令 $u \\leftarrow v$ 且 $(u,v) \\notin E$，合并器可以将 $u$ 和 $v$ 合并为单个节点，以倾向于为它们分配相同的颜色。假设采用标准的合并启发式方法，该方法通过检查度约束来避免产生可着色性冲突，但不考虑安全标签。\n\n在此背景下，假设存在一个敏感度标签函数 $s:V \\rightarrow \\{\\mathsf{S},\\mathsf{P}\\}$，其中 $\\mathsf{S}$ 表示“秘密”，$\\mathsf{P}$ 表示“公开”。安全目标是一个寄存器级的不干涉策略：在整个执行过程中，任何物理寄存器都不应在未进行显式清理的情况下，持有秘密和公开数据，即使是在不重叠的时间段内。该目标的动机是微架构残留效应，即当一个寄存器被重用于不同敏感度级别的数据时，残留位或部分宽度写入可能会泄露寄存器的先前内容。\n\n考虑对临时变量 $s_1, p_1, p_2 \\in V$ 的以下抽象操作序列：\n- $s_1$ 由一个秘密输入定义，因此 $s(s_1)=\\mathsf{S}$。\n- 存在一条由早期优化插入的移动指令 $p_1 \\leftarrow s_1$，$p_1$ 仅在下游的公开上下文中使用；假设 $s(p_1)=\\mathsf{P}$。\n- 存在一条移动指令 $p_2 \\leftarrow p_1$，$p_2$ 稍后在公开上下文中使用；$s(p_2)=\\mathsf{P}$。\n\n假设在正常数据流下，$s_1$、$p_1$ 和 $p_2$ 的活跃区间两两之间不干涉（例如，$s_1$ 在移入 $p_1$ 后立即失效，$p_1$ 在移入 $p_2$ 后失效）。在标准合并器下，合并 $(s_1,p_1)$ 然后合并 $(p_1,p_2)$ 是合法的，这可能将三者合并成一个单一节点。假设寄存器文件有 $k=4$ 个寄存器，且程序的其余部分寄存器压力较低，因此在正常约束下，这种合并会成功。\n\n哪种干涉图和着色约束能最好地强制执行所述的安全目标，同时在可能的情况下保留图的可着色性，并特别防止任何导致单个物理寄存器在不同时间持有秘密和公开数据的合并或分配结果？请选择最佳选项。\n\nA. 引入一个对敏感度感知的着色域限制和一个合并保护：将寄存器文件划分为两个不相交的集合 $R_{\\mathsf{S}} \\subset R$ 和 $R_{\\mathsf{P}} \\subset R$，使得 $R_{\\mathsf{S}} \\cap R_{\\mathsf{P}} = \\emptyset$ 且 $R_{\\mathsf{S}} \\cup R_{\\mathsf{P}} = R$。对于每个节点 $v \\in V$，如果 $s(v)=\\mathsf{S}$，则将其允许的颜色限制为 $C(v) = R_{\\mathsf{S}}$；如果 $s(v)=\\mathsf{P}$，则限制为 $C(v) = R_{\\mathsf{P}}$。此外，禁止对任何满足 $s(u) \\neq s(v)$ 的移动指令 $(u \\leftarrow v)$ 进行合并，并确保合并后的节点继承与 $s$ 一致的单一标签。可选地，添加“安全边” $E_{\\sigma} = \\{(u,v) \\mid s(u) \\neq s(v) \\text{ and } (u,v) \\in M\\}$，其中 $M$ 是与移动相关的对的集合，以防止合并器考虑跨标签的偏好。\n\nB. 仅当秘密-公开对同时活跃时，在它们之间添加人为的干涉边，即，将 $E$ 扩展为 $E' = E \\cup \\{(u,v) \\mid s(u)=\\mathsf{S}, s(v)=\\mathsf{P}, \\text{ and } u,v \\text{ overlap in liveness}\\}$，但除了标准的度检查外，不限制着色域或合并。\n\nC. 全局禁用所有合并，保持干涉图 $G$ 不变，并从完整的寄存器集 $R$ 中进行分配，不施加任何基于敏感度的域限制。\n\nD. 保持合并和分配不变，但插入动态清理指令，当一个标记为 $\\mathsf{S}$ 的节点之后，一个标记为 $\\mathsf{P}$ 的节点被分配到同一个寄存器时，该指令会将该寄存器清零；不添加任何干涉图或着色约束。\n\n选择正确的选项。", "solution": "用户希望我分析一个编译器安全问题，验证其前提，然后从给定选项中确定最佳解决方案。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n*   **系统**：一个使用图着色进行寄存器分配的编译器后端。\n*   **干涉图**：$G=(V,E)$，其中 $V$ 是临时变量的集合，如果临时变量 $u$ 和 $v$ 同时活跃，则存在边 $(u,v) \\in E$。\n*   **寄存器**：$k$ 个物理寄存器，$R=\\{r_1,\\dots,r_k\\}$。\n*   **合并**：如果不存在干涉边 $(u,v) \\in E$，可以通过合并节点 $u$ 和 $v$ 来消除移动指令 $u \\leftarrow v$。合并器使用标准的基于度的启发式方法。\n*   **安全模型**：\n    *   一个敏感度标签函数 $s:V \\rightarrow \\{\\mathsf{S},\\mathsf{P}\\}$，其中 $\\mathsf{S}$ 是“秘密”，$\\mathsf{P}$ 是“公开”。\n    *   **安全目标**：一个物理寄存器在执行期间任何时候都不能同时持有秘密和公开数据，即使在非重叠的时间段内，除非进行了显式清理。这是为了缓解微架构残留问题。\n*   **示例场景**：\n    *   临时变量：$s_1, p_1, p_2 \\in V$。\n    *   标签：$s(s_1)=\\mathsf{S}$, $s(p_1)=\\mathsf{P}$, $s(p_2)=\\mathsf{P}$。\n    *   操作：一个移动指令 $p_1 \\leftarrow s_1$ 和一个移动指令 $p_2 \\leftarrow p_1$。\n    *   活跃性：$s_1, p_1, p_2$ 的活跃范围两两不相交（它们之间没有干涉边）。\n    *   编译器行为：标准的合并器可能会将 $s_1, p_1, p_2$ 合并成一个节点，然后分配给一个物理寄存器。\n    *   寄存器数量：$k=4$。寄存器压力较低，因此标准合并在度约束下不会受阻。\n*   **问题**：确定哪套最佳的干涉图和着色约束可以强制执行安全目标，并防止寄存器同时持有 $\\mathsf{S}$ 和 $\\mathsf{P}$ 数据，同时在可能的情况下保持可着色性。\n\n**步骤2：使用提取的已知条件进行验证**\n\n*   **科学基础**：该问题在科学上是合理的。它牢固地基于编译器设计的既定原则（通过图着色进行寄存器分配、活跃性分析、合并）和计算机安全（信息流控制、像数据残留这样的微架构侧信道）。所描述的场景是一个典型的例子，说明了标准编译器优化如何可能违反安全策略。\n*   **良定性**：该问题是良定的。它清楚地定义了初始状态、系统行为、安全目标以及一个具体的策略违规示例。问题要求在一组选项中找出最佳的强制执行机制，这需要对每个选项的有效性和权衡进行清晰的分析。\n*   **客观性**：该问题以精确、客观和技术性的语言陈述。它没有歧义和主观性陈述。\n*   **缺陷检查**：该问题没有违反任何列出的无效标准。它是一个在安全编译领域内有效且表述良好的问题。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。我将继续进行详细的解决方案分析。\n\n###\n### 基于原则的推导和选项分析\n\n问题的核心是在寄存器级别强制执行一个不干涉策略。该策略规定，单个物理寄存器不能用于存储秘密（$\\mathsf{S}$）和公开（$\\mathsf{P}$）数据，即使在不同时间。给出的例子展示了标准的编译器优化，特别是移动合并，如何违反此策略。由于临时变量 $s_1$（$\\mathsf{S}$）、$p_1$（$\\mathsf{P}$）和 $p_2$（$\\mathsf{P}$）的活跃范围不相交，干涉图中它们之间没有边。移动指令 $p_1 \\leftarrow s_1$ 和 $p_2 \\leftarrow p_1$ 使它们成为合并的候选对象。标准的合并器会将它们合并成一个单一节点 $\\{s_1, p_1, p_2\\}$，该节点将被分配给一个单一的物理寄存器。该寄存器将首先持有一个秘密值（来自 $s_1$），然后是公开值（来自 $p_1$ 和 $p_2$），由于数据残留的风险，这直接违反了安全目标。\n\n为了强制执行该策略，寄存器分配器必须能够感知安全标签。任何有效的解决方案都必须阻止将标签为 $\\mathsf{S}$ 的临时变量和标签为 $\\mathsf{P}$ 的临时变量分配给同一个物理寄存器，无论它们的活跃范围是否重叠。\n\n让我们根据这个要求来评估每个选项。\n\n**A. 引入一个对敏感度感知的着色域限制和一个合并保护：将寄存器文件划分为两个不相交的集合 $R_{\\mathsf{S}} \\subset R$ 和 $R_{\\mathsf{P}} \\subset R$，使得 $R_{\\mathsf{S}} \\cap R_{\\mathsf{P}} = \\emptyset$ 且 $R_{\\mathsf{S}} \\cup R_{\\mathsf{P}} = R$。对于每个节点 $v \\in V$，如果 $s(v)=\\mathsf{S}$，则将其允许的颜色限制为 $C(v) = R_{\\mathsf{S}}$；如果 $s(v)=\\mathsf{P}$，则限制为 $C(v) = R_{\\mathsf{P}}$。此外，禁止对任何满足 $s(u) \\neq s(v)$ 的移动指令 $(u \\leftarrow v)$ 进行合并，并确保合并后的节点继承与 $s$ 一致的单一标签。可选地，添加“安全边” $E_{\\sigma} = \\{(u,v) \\mid s(u) \\neq s(v) \\text{ and } (u,v) \\in M\\}$，其中 $M$ 是与移动相关的对的集合，以防止合并器考虑跨标签的偏好。**\n\n该选项提出了一种全面的、静态的强制执行机制，它在图着色约束的层面上操作。\n1.  **寄存器分区**：将物理寄存器集 $R$ 划分为不相交的子集 $R_{\\mathsf{S}}$ 和 $R_{\\mathsf{P}}$ 是强制执行该策略的直接而稳健的方法。来自 $R_{\\mathsf{S}}$ 的寄存器永远不能用于公开临时变量，来自 $R_{\\mathsf{P}}$ 的寄存器永远不能用于秘密临时变量。这完全消除了跨域重用的可能性。这是对图节点的一种预着色或域限制。\n2.  **合并保护**：禁止合并具有不同安全标签（例如 $s(u) \\neq s(v)$）的临时变量的规则至关重要。如果我们合并 $s_1$ 和 $p_1$，产生的节点将具有冲突的颜色约束：它的颜色必须在 $R_{\\mathsf{S}}$ 中（由于 $s_1$），也必须在 $R_{\\mathsf{P}}$ 中（由于 $p_1$）。由于 $R_{\\mathsf{S}} \\cap R_{\\mathsf{P}} = \\emptyset$，将不存在有效的颜色。因此，必须阻止这种合并。这个保护措施正确地识别并防止了这个问题。\n3.  **安全边**：添加“安全边”是在标准图着色框架内实现合并保护的一种具体方式。干涉图中的边 $(u,v)$ 表示 $u$ 和 $v$ 不能被合并，并且必须被赋予不同的颜色。\n该选项提供了一套完整且正确的约束，它修改了图着色问题以使其具备安全感知能力。它直接防止了所描述的违规行为。虽然对寄存器文件进行分区可能会通过限制每种数据类型可用的寄存器数量来降低性能，但它严格地强制执行了所要求的安全策略。\n\n**结论**：**正确**。这是一种在寄存器分配器中强制执行信息流安全的成熟且合理的技术。\n\n**B. 仅当秘密-公开对同时活跃时，在它们之间添加人为的干涉边，即，将 $E$ 扩展为 $E' = E \\cup \\{(u,v) \\mid s(u)=\\mathsf{S}, s(v)=\\mathsf{P}, \\text{ and } u,v \\text{ overlap in liveness}\\}$，但除了标准的度检查外，不限制着色域或合并。**\n\n该选项不充分。标准的干涉边*已经*存在于任何同时活跃的两个临时变量之间。因此，“$u,v$ overlap in liveness”的条件意味着边 $(u,v) \\in E$ 已经存在。该选项实际上没有为同时活跃的临时变量提出任何新的措施。更重要的是，它完全没有解决核心问题，即为具有*不重叠*活跃范围的临时变量重用寄存器。在示例中，$s_1$ 和 $p_1$ 不是同时活跃的，所以这个规则不会在它们之间添加任何边。合并器仍然会合并它们，安全策略仍然会被违反。\n\n**结论**：**不正确**。\n\n**C. 全局禁用所有合并，保持干涉图 $G$ 不变，并从完整的寄存器集 $R$ 中进行分配，不施加任何基于敏感度的域限制。**\n\n禁用合并可以防止 $s_1$ 和 $p_1$ 被合并成一个节点的特定违规路径。然而，它并没有解决根本问题。在禁用合并的情况下，$s_1$ 和 $p_1$ 仍然是独立的节点，它们之间没有干涉边。一个对安全无感的分配器可以自由地将 $s_1$ 分配给一个物理寄存器，比如 $r_i$。在 $s_1$ 的活跃范围结束后，$r_i$ 变得可用。当分配器需要为 $p_1$ 分配寄存器时，它可能会选择重用 $r_i$。这导致了相同的结果：物理寄存器 $r_i$ 首先持有一个秘密值，然后持有一个公开值。因此，安全策略仍然被违反。\n\n**结论**：**不正确**。\n\n**D. 保持合并和分配不变，但插入动态清理指令，当一个标记为 $\\mathsf{S}$ 的节点之后，一个标记为 $\\mathsf{P}$ 的节点被分配到同一个寄存器时，该指令会将该寄存器清零；不添加任何干涉图或着色约束。**\n\n该选项描述了一种有效的安全技术，称为寄存器清理或净化。它通过显式清除寄存器的状态来解决残留威胁。安全目标本身就提到了这种可能性：“...没有显式清理的情况下”。因此，作为一种安全解决方案，这是可行的。然而，问题要求的是一种基于“**干涉图和着色约束**”的解决方案。该选项明确指出“**不添加任何干涉图或着色约束**”。它绕过了图着色阶段，在代码生成后期通过插入新指令来解决问题。虽然它实现了安全目标，但它没有按照问题的提问方式来回答问题。问题是关于如何修改寄存器分配器的约束，而不是关于替代的运行时缓解措施。选项A直接且正确地回答了关于修改着色约束的问题。因此，在问题框架的背景下，选项A是更优的选择。\n\n**结论**：**不正确**。尽管是一种有效的安全机制，但它不是问题陈述所要求的基于“干涉图和着色约束”的解决方案。\n\n### 结论\n\n选项A提供了在图着色算法层面唯一完整且正确的约束集。它正确地识别了需要根据安全标签限制可用寄存器（颜色）的集合，以及防止跨安全域的不安全移动合并。这通过静态地阻止任何物理寄存器被用于秘密和公开两种临时变量，从而直接强制执行了指定的不干涉策略。", "answer": "$$\\boxed{A}$$", "id": "3629593"}]}