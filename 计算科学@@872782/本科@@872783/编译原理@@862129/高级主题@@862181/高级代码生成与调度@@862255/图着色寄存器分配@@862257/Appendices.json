{"hands_on_practices": [{"introduction": "寄存器分配的核心思想是将变量的生命周期转化为一个图论问题。这个基础练习将引导你走完从分析简单代码到完成图着色的整个过程，帮助你巩固对活跃度分析、构建冲突图以及确定所需最少寄存器数量的理解[@problem_id:3675472]。通过这个练习，你将亲手实践寄存器分配的基础理论。", "problem": "考虑以下直线式三地址码（Three-Address Code, TAC），其中三地址码是一种表示形式，每条指令最多有三个操作数，并赋值给一个目标地址：\n\n指令 $1$：$x := a + b$；指令 $2$：$y := x + c$；指令 $3$：$z := y + d$\n\n假设存在以下上下文和约定：\n- 变量 $a$、$b$、$c$ 和 $d$ 在基本块的入口处是活跃的（入口活跃），并且在块内被使用之前未被定义。\n- 在指令 $3$ 之后，紧随该块有一个单次使用点，其中 $z$ 作为该块的结果被消耗，使得 $z$ 在末尾是出口活跃的。\n- 变量的活跃性按标准数据流意义定义：如果一个变量的当前值可能在从某个程序点开始的某条路径上被读取，则该变量在该程序点是活跃的。\n- 变量的活跃范围是指从其成为入口活跃或被定义开始，直到其可能影响可观察结果的最后一次使用为止的程序点集合。\n- 如果两个变量的活跃范围在任何程序点上重叠，则它们相互冲突；冲突图在相互冲突的变量之间有一条边。\n- 通过图着色进行寄存器分配，即将颜色（寄存器）分配给变量，以使相邻顶点不共享同一颜色。所需的最少寄存器数量是允许对冲突图进行有效着色的最小颜色数。\n\n任务：\n- 使用上述三地址码和假设，计算所有变量 $a$、$b$、$c$、$d$、$x$、$y$ 和 $z$ 的活跃范围，以指令之间的边界为索引：指令 $1$ 之前、指令 $1$ 和指令 $2$ 之间、指令 $2$ 和指令 $3$ 之间，以及指令 $3$ 之后但在 $z$ 的最终使用之前。\n- 沿此线性顺序绘制相应的活跃区间，并通过连接区间重叠的变量对来构建冲突图。\n- 选择一个有效的冲突图着色方案，并确定所需的最少颜色数。\n\n请提供所需的最少寄存器数量作为您的最终答案。答案必须是一个没有单位的整数。无需四舍五入。", "solution": "问题陈述经评估为**有效**。它是自包含的，科学上基于编译器理论的原则，并且是适定的。三地址码（TAC）、变量活跃性、活跃范围、冲突图和图着色的定义都是标准且无歧义的。所提供的代码和假设是一致的，足以推导出唯一的解。\n\n求解过程分为四个步骤：\n1.  执行活跃性分析，以确定每个程序点的活跃变量集合。\n2.  为每个变量定义活跃范围（或活跃区间）。\n3.  基于重叠的活跃范围构建冲突图。\n4.  确定冲突图的色数，该色数对应于所需的最少寄存器数量。\n\n我们将程序点定义在指令的边界上：\n-   $P_0$：指令1之前的点。\n-   $P_1$：指令1和指令2之间的点。\n-   $P_2$：指令2和指令3之间的点。\n-   $P_3$：指令3之后、但在$z$的最终使用之前的点。\n\n活跃性分析从基本块的末尾向后进行。指令 $i$ 的入口活跃集 $\\text{Live}_{\\text{in}}(i)$ 是根据其出口活跃集 $\\text{Live}_{\\text{out}}(i)$，使用标准的数据流方程计算得出的：\n$$ \\text{Live}_{\\text{in}}(i) = (\\text{Live}_{\\text{out}}(i) \\setminus \\text{def}(i)) \\cup \\text{use}(i) $$\n其中 $\\text{def}(i)$ 是指令 $i$ 定义的变量集合，$\\text{use}(i)$ 是指令 $i$ 使用的变量集合。一条指令的出口活跃集是其后继指令的入口活跃集。\n\n**步骤1：活跃性分析**\n\n-   **在点 $P_3$（指令3之后）：**\n    问题陈述指出 $z$ 在该块出口处是活跃的。因此，该点的活跃变量集是 $\\{z\\}$。这也是指令3的出口活跃集。\n    $$ \\text{Live}_{\\text{out}}(\\text{Inst } 3) = \\{z\\} $$\n\n-   **对于指令3: $z := y + d$**：\n    -   $\\text{def}(\\text{Inst } 3) = \\{z\\}$\n    -   $\\text{use}(\\text{Inst } 3) = \\{y, d\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 3) = (\\text{Live}_{\\text{out}}(\\text{Inst } 3) \\setminus \\{z\\}) \\cup \\{y, d\\} = (\\{z\\} \\setminus \\{z\\}) \\cup \\{y, d\\} = \\{y, d\\}$。\n    -   在点 $P_2$ 的活跃变量集是 $\\{y, d\\}$。这也是 $\\text{Live}_{\\text{out}}(\\text{Inst } 2)$。\n\n-   **对于指令2: $y := x + c$**：\n    -   $\\text{Live}_{\\text{out}}(\\text{Inst } 2) = \\text{Live}_{\\text{in}}(\\text{Inst } 3) = \\{y, d\\}$\n    -   $\\text{def}(\\text{Inst } 2) = \\{y\\}$\n    -   $\\text{use}(\\text{Inst } 2) = \\{x, c\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 2) = (\\text{Live}_{\\text{out}}(\\text{Inst } 2) \\setminus \\{y\\}) \\cup \\{x, c\\} = (\\{y, d\\} \\setminus \\{y\\}) \\cup \\{x, c\\} = \\{d, x, c\\}$。\n    -   在点 $P_1$ 的活跃变量集是 $\\{c, d, x\\}$。这也是 $\\text{Live}_{\\text{out}}(\\text{Inst } 1)$。\n\n-   **对于指令1: $x := a + b$**：\n    -   $\\text{Live}_{\\text{out}}(\\text{Inst } 1) = \\text{Live}_{\\text{in}}(\\text{Inst } 2) = \\{c, d, x\\}$\n    -   $\\text{def}(\\text{Inst } 1) = \\{x\\}$\n    -   $\\text{use}(\\text{Inst } 1) = \\{a, b\\}$\n    -   $\\text{Live}_{\\text{in}}(\\text{Inst } 1) = (\\text{Live}_{\\text{out}}(\\text{Inst } 1) \\setminus \\{x\\}) \\cup \\{a, b\\} = (\\{c, d, x\\} \\setminus \\{x\\}) \\cup \\{a, b\\} = \\{a, b, c, d\\}$。\n    -   在点 $P_0$ 的活跃变量集是 $\\{a, b, c, d\\}$。这证实了问题陈述中 $a$、$b$、$c$ 和 $d$ 是该块的入口活跃变量。\n\n各程序点活跃变量总结：\n-   在 $P_0$：$\\{a, b, c, d\\}$\n-   在 $P_1$：$\\{c, d, x\\}$\n-   在 $P_2$：$\\{d, y\\}$\n-   在 $P_3$：$\\{z\\}$\n\n**步骤2：活跃范围**\n\n一个变量的活跃范围是它处于活跃状态的程序点集合。\n-   $a$：从 $P_0$ 活跃到在指令1中被使用。范围：$[P_0, P_1)$。\n-   $b$：从 $P_0$ 活跃到在指令1中被使用。范围：$[P_0, P_1)$。\n-   $x$：由指令1定义，从 $P_1$ 活跃到在指令2中被使用。范围：$[P_1, P_2)$。\n-   $c$：从 $P_0$ 活跃到在指令2中被使用。范围：$[P_0, P_2)$。\n-   $y$：由指令2定义，从 $P_2$ 活跃到在指令3中被使用。范围：$[P_2, P_3)$。\n-   $d$：从 $P_0$ 活跃到在指令3中被使用。范围：$[P_0, P_3)$。\n-   $z$：由指令3定义，从 $P_3$ 活跃到在该块后被使用。范围：$[P_3, \\text{end})$。\n\n**步骤3：构建冲突图**\n\n如果两个变量的活跃范围重叠，则它们发生冲突。我们列出在任何程序点同时活跃的所有变量对。\n-   在 $P_0$，活跃变量集是 $\\{a, b, c, d\\}$。这些变量中的任意一对都相互冲突。这构成了一个大小为4的团（记作 $K_4$）。边：$(a,b), (a,c), (a,d), (b,c), (b,d), (c,d)$。\n-   在 $P_1$，活跃变量集是 $\\{c, d, x\\}$。这些变量中的任意一对都相互冲突。边：$(c,d), (c,x), (d,x)$。\n-   在 $P_2$，活跃变量集是 $\\{d, y\\}$。这两个变量相互冲突。边：$(d,y)$。\n-   在 $P_3$，活跃变量集是 $\\{z\\}$。没有涉及 $z$ 的冲突。\n\n冲突图 $G$ 的完整边集是在所有点上发现的冲突的并集。该图的邻接表如下：\n-   $a$: $\\{b, c, d\\}$\n-   $b$: $\\{a, c, d\\}$\n-   $c$: $\\{a, b, d, x\\}$\n-   $d$: $\\{a, b, c, x, y\\}$\n-   $x$: $\\{c, d\\}$\n-   $y$: $\\{d\\}$\n-   $z$: $\\emptyset$\n\n**步骤4：最少寄存器数量（色数）**\n\n所需的最少寄存器数量是冲突图 $G$ 的色数 $\\chi(G)$。\n色数必须至少与图中最大团的大小 $\\omega(G)$ 一样大。通过对点 $P_0$ 的分析，我们识别出一个由顶点 $\\{a, b, c, d\\}$ 组成的大小为4的团。因此，$\\omega(G) \\ge 4$，这意味着 $\\chi(G) \\ge 4$。所以，至少需要4个寄存器。\n\n我们现在通过尝试对图进行4-着色来检查4个寄存器是否足够。设颜色为 $C_1, C_2, C_3, C_4$。\n1.  用不同的颜色为 $K_4$ 团 $\\{a, b, c, d\\}$ 的顶点着色：\n    -   color($a$) := $C_1$\n    -   color($b$) := $C_2$\n    -   color($c$) := $C_3$\n    -   color($d$) := $C_4$\n2.  为剩余的顶点（$x$、$y$、$z$）着色。\n    -   顶点 $x$ 与 $c$（颜色 $C_3$）和 $d$（颜色 $C_4$）相邻。我们可以为其分配除 $C_3$ 或 $C_4$ 之外的任何颜色。我们选择 $C_1$。color($x$) := $C_1$。这是有效的，因为 $x$ 不与 $a$ 相邻。\n    -   顶点 $y$ 仅与 $d$（颜色 $C_4$）相邻。我们可以为其分配除 $C_4$ 之外的任何颜色。我们选择 $C_1$。color($y$) := $C_1$。这是有效的。\n    -   顶点 $z$ 没有邻居。我们可以为其分配任何颜色。我们选择 $C_1$。color($z$) := $C_1$。\n\n一个有效的4-着色方案是：\n-   $a$: $C_1$\n-   $b$: $C_2$\n-   $c$: $C_3$\n-   $d$: $C_4$\n-   $x$: $C_1$\n-   $y$: $C_1$\n-   $z$: $C_1$\n\n由于存在4-着色方案，4个寄存器是足够的，因此 $\\chi(G) \\le 4$。\n结合两个边界条件 $\\chi(G) \\ge 4$ 和 $\\chi(G) \\le 4$，我们得出结论，色数恰好为4。\n\n因此，所需的最少寄存器数量为4。", "answer": "$$\\boxed{4}$$", "id": "3675472"}, {"introduction": "在掌握了基础知识后，我们将探讨一项关键优化技术：合并（coalescing），它可以消除多余的`move`指令。然而，这项优化并非没有风险，本练习将探讨一种特殊情况：激进地合并两个变量，反而可能使图更难着色，甚至导致溢出（spill）[@problem_id:3666803]。这个例子启发我们为何需要更“保守”的合并策略，以确保优化不会适得其反。", "problem": "考虑寄存器分配的标准图着色模型。一个干预图 $G=(V,E)$ 表示变量（节点），其中边表示变量之间不能共享同一个寄存器。设 $k$ 为可用机器寄存器的数量。Chaitin-风格的分配器的简化阶段会重复移除度数小于 $k$ 的节点；如果不存在这样的节点，则选择一个节点作为溢出候选者。合并操作将两个与移动指令相关且不干预的节点 $x$ 和 $y$ 替换为单个节点，该节点代表将 $x$ 和 $y$ 分配给同一个寄存器，这可能减少移动指令但会改变干预图。\n\n给定一个最坏情况的结构模式，其中两个不干预的节点 $x$ 和 $y$ 与移动指令相关，它们的度分别为 $d_x$ 和 $d_y$，并且恰好共享一个共同的干预邻居。$x$ 和 $y$ 的所有其他邻居都是不同的。假设 $k$ 是固定的。\n\n1) 构建一个符合此模式的具体实例，以说明合并 $x$ 和 $y$ 如何能创建一个度至少为 $k$ 的节点，从而可能在简化阶段强制选择溢出。在您的构建中使用以下参数：$k=9$, $d_x=4$ 和 $d_y=6$。\n\n2) 从第一性原理出发进行推广。令 $N(x)$ 和 $N(y)$ 表示 $x$ 和 $y$ 在 $G$ 中的邻居集合。在所述的最坏情况模式下（$x$ 和 $y$ 不干预、与移动指令相关，且 $|N(x)\\cap N(y)|=1$），推导最小整数阈值 $t(k)$，使得只要 $d_x+d_y \\ge t(k)$，合并 $x$ 和 $y$ 就会产生一个度至少为 $k$ 的合并节点。请以 $k$ 的闭式表达式形式提供 $t(k)$。\n\n你的最终答案必须是 $t(k)$ 的表达式。不需要四舍五入，也不涉及单位。请将最终答案表示为单个闭式解析表达式。", "solution": "该问题涉及在干预图中合并两个节点的影响，这是通过图着色进行寄存器分配的核心操作。设干预图为 $G=(V, E)$，其中 $V$ 是变量（或临时变量）的集合，边 $(u, v) \\in E$ 表示变量 $u$ 和 $v$ 同时活跃，因此不能分配给同一个寄存器。\n\n我们给定两个节点 $x$ 和 $y$ 作为合并的目标。这意味着它们与移动指令相关（例如，涉及像 `move y, x` 这样的指令）并且互不干预，即 $(x, y) \\notin E$。合并操作将 $x$ 和 $y$ 合并成一个单一的新节点，我们称之为 $xy$。这个新节点 $xy$ 的邻居是所有曾是 $x$ 或 $y$ 邻居的节点。如果 $N(u)$ 表示节点 $u$ 的邻居集合，那么合并后节点的邻域是 $N(xy) = N(x) \\cup N(y)$。\n\n一个节点的度是其邻居的数量。因此，合并节点的度 $d_{xy}$ 是原始邻域并集的基数：$d_{xy} = |N(xy)| = |N(x) \\cup N(y)|$。使用两个集合的容斥原理，其并集的大小由下式给出：\n$$|N(x) \\cup N(y)| = |N(x)| + |N(y)| - |N(x) \\cap N(y)|$$\n设 $d_x = |N(x)|$ 和 $d_y = |N(y)|$ 分别是节点 $x$ 和 $y$ 的度。那么合并节点的度可以表示为：\n$$d_{xy} = d_x + d_y - |N(x) \\cap N(y)|$$\n问题指定了一个“最坏情况的结构模式”，其中 $x$ 和 $y$ 恰好共享一个共同邻居。这意味着它们的邻居集合的交集只有一个元素：$|N(x) \\cap N(y)| = 1$。将此代入度数公式可得：\n$$d_{xy} = d_x + d_y - 1$$\n这个方程是解决问题两个部分的基础。\n\n对于第一部分，我们必须构建一个具体的实例。给定可用寄存器数量 $k=9$，以及待合并节点的度 $d_x=4$ 和 $d_y=6$。在 Chaitin 风格的分配器的简化阶段，度数小于 $k$ 的节点会从图中移除并压入栈中。如果合并操作创建了一个度数不小于 $k$ 的节点，就会出现一个潜在问题，因为这个新节点不能立即被简化，并可能导致溢出。我们想要证明合并 $x$ 和 $y$ 可以创建一个度至少为 $k$ 的节点。\n使用推导出的公式和给定的参数：\n$$d_{xy} = d_x + d_y - 1 = 4 + 6 - 1 = 9$$\n结果节点的度是 $9$。由于 $k=9$，我们有 $d_{xy} = k$。一个节点只有在其度严格小于 $k$ 时才是可简化的。因为 $d_{xy} = 9$ 不小于 $k=9$，所以新节点 $xy$ 是不可简化的。\n这证实了合并操作在这些条件下可以创建一个可能强制溢出的节点。一个具体的图实例包括：\n- 节点 $x$ 和 $y$。\n- 一个共同邻居，节点 $z$。\n- $x$ 的 $d_x - 1 = 4 - 1 = 3$ 个不同邻居，它们不是 $y$ 的邻居，我们称之为 $\\{a_1, a_2, a_3\\}$。\n- $y$ 的 $d_y - 1 = 6 - 1 = 5$ 个不同邻居，它们不是 $x$ 的邻居，我们称之为 $\\{b_1, b_2, b_3, b_4, b_5\\}$。\n邻域分别为 $N(x) = \\{z, a_1, a_2, a_3\\}$ 和 $N(y) = \\{z, b_1, b_2, b_3, b_4, b_5\\}$。在合并之前，两个节点都是可简化的，因为 $d_x = 4  9$ 且 $d_y = 6  9$。合并之后，新节点 $xy$ 的邻域为 $N(xy) = N(x) \\cup N(y) = \\{z, a_1, a_2, a_3, b_1, b_2, b_3, b_4, b_5\\}$，其度为 $d_{xy}=9$。\n\n对于第二部分，我们推广这个结果来推导最小整数阈值 $t(k)$。我们寻求关于和 $d_x + d_y$ 的条件，使得合并节点的度 $d_{xy}$ 至少为 $k$。这意味着我们需要：\n$$d_{xy} \\ge k$$\n在问题的结构约束（$|N(x) \\cap N(y)| = 1$）下，代入我们的 $d_{xy}$ 公式：\n$$d_x + d_y - 1 \\ge k$$\n为了找到度数之和的阈值，我们解关于 $d_x + d_y$ 的不等式：\n$$d_x + d_y \\ge k + 1$$\n这个不等式表明，如果节点 $x$ 和 $y$ 的度数之和大于或等于 $k+1$，那么合并节点的度 $d_{xy}$ 就保证至少为 $k$。问题要求和 $d_x + d_y$ 的最小整数阈值 $t(k)$。根据推导出的不等式，要满足该条件，$d_x+d_y$ 必须的最小整数值是 $k+1$。任何小于这个值的和，比如 $k$，将导致 $d_{xy} = k-1$，这小于 $k$。因此，阈值恰好是 $k+1$。\n因此，最小整数阈值 $t(k)$ 由以下表达式给出：\n$$t(k) = k + 1$$", "answer": "$$\\boxed{k+1}$$", "id": "3666803"}, {"introduction": "本章的最后一个练习将你的理解推向一个更深的层次，展示一个在真实编译器中存在的复杂权衡。这个练习揭示了一种精妙的编译策略：有时，主动溢出某个变量反而是有利的[@problem_id:3666838]。通过从冲突图中移除一个“连接度”极高的变量，我们可能为合并一整条`move`指令链创造机会，从而在权衡了溢出代价$C_{\\text{spill}}$和移动指令代价$C_{\\text{move}}$之后，获得净性能提升。", "problem": "考虑一个在具有 $k=5$ 个物理寄存器的目标上执行 $N$ 次的循环体。其中间表示包含四个临时变量之间的一系列复制操作，写作传送指令：\n- $t_{2} \\leftarrow t_{1}$，\n- $t_{3} \\leftarrow t_{2}$，\n- $t_{4} \\leftarrow t_{3}$。\n\n此外，还有五个活跃范围 $p$、$q$、$r$、$s$ 和 $u$，它们在循环内被使用和重定义，因此 $p$、$q$、$r$、$s$ 和 $u$ 中的每一个都在循环体的部分区间内是活跃的。活跃性的安排使得，在发生传送指令的三个程序点上，同步活跃集分别为：\n- 在 $t_{2} \\leftarrow t_{1}$ 处：$\\{t_{1},p,q,r,u\\}$，\n- 在 $t_{3} \\leftarrow t_{2}$ 处：$\\{t_{2},p,q,s,u\\}$，\n- 在 $t_{4} \\leftarrow t_{3}$ 处：$\\{t_{3},p,r,s,u\\}$。\n\n循环中没有其他活跃范围。假设循环体内是线性代码（无分支），并且所有五个活跃范围 $p$、$q$、$r$、$s$、$u$ 每次迭代都被使用一次然后重定义一次，因此它们如上所述在循环体内是活跃的。\n\n使用标准的通过图着色进行寄存器分配的干涉图模型：如果两个节点（活跃范围）在某个程序点上同时活跃，则它们相互干涉。如果保守合并规则（例如 George 或 Briggs 准则）认为合并对于 $k$-可着色性是安全的，则与传送指令相关的节点可以被合并。设执行成本模型为：\n- 每条传送指令的动态执行成本为 $C_{\\text{move}}$。\n- 因溢出一个活跃范围而产生的每次内存访问的动态执行成本为 $C_{\\text{spill}}$。\n\n假设我们考虑两种分配策略：\n- 策略 A（不溢出，不合并）：使用 $k=5$ 进行分配，不合并任何 $t_{1}$、$t_{2}$、$t_{3}$、$t_{4}$。这是可能的，因为最大同步活跃度为 $5$。循环每次迭代执行 $3$ 条传送指令，不进行溢出访问。\n- 策略 B（将 $u$ 溢出到内存，然后将 $t_{1}$、$t_{2}$、$t_{3}$、$t_{4}$ 完全合并为一个节点）：溢出 $u$ 使得对整个链的合并对于 $k=5$ 是保守安全的，因此所有三条传送指令都被消除。由于 $u$ 每次迭代被使用和重定义一次，溢出操作每次迭代会引入恰好 $2$ 次内存访问（在使用前一次加载，在重定义后一次存储）。\n\n仅从活跃性、干涉图和 $k$-着色的保守合并的核心定义出发，解释为什么策略 A 允许使用 $k=5$ 进行着色但不能保守地合并整个链，而策略 B 允许使用 $k=5$ 进行着色并允许合并整个链。然后，使用给定的成本模型，推导单次循环迭代中 $C_{\\text{spill}}$ 与 $C_{\\text{move}}$ 的盈亏平衡比 $r^{\\ast}$，使得当 $\\frac{C_{\\text{spill}}}{C_{\\text{move}}}  r^{\\ast}$ 时，策略 B 的执行成本严格低于策略 A。提供 $r^{\\ast}$ 的简化解析表达式。不要对答案进行四舍五入。", "solution": "该问题要求基于干涉图模型，对给定循环体的两种寄存器分配策略进行分析，并推导成本盈亏平衡点。我们首先验证问题陈述。\n\n### 问题验证\n**步骤 1：提取已知条件**\n- 物理寄存器数量：$k=5$。\n- 循环执行次数：$N$ 次。\n- 传送指令：$t_{2} \\leftarrow t_{1}$，$t_{3} \\leftarrow t_{2}$，$t_{4} \\leftarrow t_{3}$。\n- 活跃范围：$p, q, r, s, u$ 和临时变量 $t_1, t_2, t_3, t_4$。\n- 特定程序点上的同步活跃集：\n  - 在 $t_{2} \\leftarrow t_{1}$ 处：$L_1 = \\{t_{1}, p, q, r, u\\}$。\n  - 在 $t_{3} \\leftarrow t_{2}$ 处：$L_2 = \\{t_{2}, p, q, s, u\\}$。\n  - 在 $t_{4} \\leftarrow t_{3}$ 处：$L_3 = \\{t_{3}, p, r, s, u\\}$。\n- 所有其他活跃范围均已考虑，干涉仅由这些集合确定。\n- 成本模型：每次传送为 $C_{\\text{move}}$，每次因活跃范围溢出而产生的内存访问为 $C_{\\text{spill}}$。\n- 策略 A：不溢出，不合并。成本为每次迭代 $3$ 次传送。陈述中说明 $k=5$ 着色是可能的。\n- 策略 B：溢出活跃范围 $u$。合并链 $t_1, t_2, t_3, t_4$。成本为每次迭代 $2$ 次与溢出相关的内存访问。陈述中说明这是可能的。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在编译器设计的标准理论框架内定义良好，特别是在通过图着色进行寄存器分配方面。活跃性、干涉图、图着色、保守合并（Briggs/George 准则）和溢出的概念都是标准的。给定的条件是自足的，足以构建和分析两种策略的干涉图。问题的假设——即策略 A 中着色是可能的，策略 B 中合并是可能的——是需要解释的断言，这是一个有效的教学结构。该问题具有科学依据、客观且定义明确。\n\n**步骤 3：结论与行动**\n问题有效。将继续进行求解。\n\n### 分析与求解\n通过图着色进行寄存器分配的核心是干涉图 $G=(V, E)$，其中 $V$ 是活跃范围（临时变量）的集合，如果活跃范围 $a$ 和 $b$ 在程序中的任何一点同时活跃，则存在一条边 $(a, b) \\in E$。根据定义，由传送指令关联的两个活跃范围，例如 $t_2 \\leftarrow t_1$ 中的 $t_1$ 和 $t_2$，不互相干涉，假设 $t_1$ 的活跃性在此指令处结束，而 $t_2$ 的活跃性从此开始。\n\n如果图中的每个节点都可以被赋予 $k$ 种颜色之一，且任意两个相邻节点颜色不同，则该图是 $k$-可着色的。一个关于 $k$-可着色性的关键启发式法则是：如果一个图可以通过迭代移除任何度数小于 $k$ 的节点来化简，那么该图是 $k$-可着色的。\n\n合并两个与传送指令相关的节点 $u$ 和 $v$（它们不互相干涉）意味着将它们融合成一个单一节点。保守合并启发式算法确保这种合并不会使一个 $k$-可着色的图变得不可着色。Briggs 准则指出，如果合并后的节点 $uv$ 的度数大于或等于 $k$ 的邻居数量少于 $k$，则可以合并两个节点 $u$ 和 $v$。\n\n**策略 A：不溢出，不合并**\n\n首先，我们根据给定的活跃集构建干涉图 $G$。节点集合为 $V = \\{t_1, t_2, t_3, t_4, p, q, r, s, u\\}$。边由共存于任何活跃集 $L_1, L_2, L_3$ 中的任意一对变量形成。传送链中的临时变量 $t_1, t_2, t_3, t_4$ 具有不相交的活跃范围，因此彼此不干涉。\n\n每个节点的邻居和度数计算如下：\n- $t_1$ 的邻居来自 $L_1$：$\\text{Neigh}(t_1) = \\{p, q, r, u\\}$。$\\text{deg}(t_1) = 4$。\n- $t_2$ 的邻居来自 $L_2$：$\\text{Neigh}(t_2) = \\{p, q, s, u\\}$。$\\text{deg}(t_2) = 4$。\n- $t_3$ 的邻居来自 $L_3$：$\\text{Neigh}(t_3) = \\{p, r, s, u\\}$。$\\text{deg}(t_3) = 4$。\n- 临时变量 $t_4$ 由 $t_4 \\leftarrow t_3$ 定义。由于没有给出包含 $t_4$ 的活跃集，并且干涉仅由给定的集合确定，因此 $t_4$ 没有干涉。$\\text{deg}(t_4) = 0$。\n- $p$ 的邻居是包含 $p$ 的任何集合中其他变量的并集：$\\text{Neigh}(p) = \\{t_1, q, r, u\\} \\cup \\{t_2, q, s, u\\} \\cup \\{t_3, r, s, u\\} = \\{t_1, t_2, t_3, q, r, s, u\\}$。$\\text{deg}(p) = 7$。\n- 类似地，我们找到其他节点的度数：\n  - $\\text{Neigh}(q) = \\{t_1, t_2, p, r, s, u\\}$。$\\text{deg}(q) = 6$。\n  - $\\text{Neigh}(r) = \\{t_1, t_3, p, q, s, u\\}$。$\\text{deg}(r) = 6$。\n  - $\\text{Neigh}(s) = \\{t_2, t_3, p, q, r, u\\}$。$\\text{deg}(s) = 6$。\n  - $\\text{Neigh}(u) = \\{t_1, t_2, t_3, p, q, r, s\\}$。$\\text{deg}(u) = 7$。\n\n该图包含几个 $5$-团（例如，$L_1$, $L_2$, $L_3$），因此其色数至少为 $5$。问题正确地指出 $5$-着色是可能的。这依赖于结构化代码的干涉图的属性，这类图通常是完美图，意味着其色数等于其团数。最大团大小为 $5$，因此该图是 $5$-可着色的。\n\n现在，我们解释为什么链 $t_1, t_2, t_3, t_4$ 不能被完全合并。让我们尝试合并由传送指令 $t_2 \\leftarrow t_1$ 关联的 $t_1$ 和 $t_2$。新合并节点 $T_{12}$ 的邻居将是 $t_1$ 和 $t_2$ 邻居的并集：$\\text{Neigh}(T_{12}) = \\text{Neigh}(t_1) \\cup \\text{Neigh}(t_2) = \\{p, q, r, u\\} \\cup \\{p, q, s, u\\} = \\{p, q, r, s, u\\}$。\n这些邻居在原始图中的度数是 $\\text{deg}(p)=7$, $\\text{deg}(q)=6$, $\\text{deg}(r)=6$, $\\text{deg}(s)=6$, 和 $\\text{deg}(u)=7$。所有这些度数都 $\\ge k=5$。\n根据 Briggs 准则，$T_{12}$ 的度数 $\\ge k$ 的邻居数量必须小于 $k$。在这里，有 $5$ 个这样的邻居。由于 $5$ 并不严格小于 $k=5$，保守合并条件不成立。因此，即使是链中的第一次合并也是不被允许的。因此，整个链无法被合并。\n\n**策略 B：溢出 `u`，然后合并**\n\n在此策略中，活跃范围 $u$ 被溢出到内存。这等同于在着色前从干涉图中移除节点 $u$ 及其所有关联的边。设新图为 $G'$。\n\n$G'$ 中的节点和度数（$k=5$）为：\n- $\\text{deg}'(t_1) = |\\{p, q, r\\}| = 3$。\n- $\\text{deg}'(t_2) = |\\{p, q, s\\}| = 3$。\n- $\\text{deg}'(t_3) = |\\{p, r, s\\}| = 3$。\n- $\\text{deg}'(t_4) = 0$。\n- $\\text{deg}'(p) = |\\{t_1, t_2, t_3, q, r, s\\}| = 6$。\n- $\\text{deg}'(q) = |\\{t_1, t_2, p, r, s\\}| = 5$。\n- $\\text{deg}'(r) = |\\{t_1, t_3, p, q, s\\}| = 5$。\n- $\\text{deg}'(s) = |\\{t_2, t_3, p, q, r\\}| = 5$。\n\n现在，我们尝试合并链 $t_1, t_2, t_3, t_4$。我们从 $t_4$ 到 $t_1$ 的顺序进行。\n1.  **合并 $t_3 \\leftarrow t_4$**：合并后的节点 $T_{34}$ 的邻居为 $\\text{Neigh}'(t_3) \\cup \\text{Neigh}'(t_4) = \\{p, r, s\\}$。这些邻居在 $G'$ 中的度数为 $\\text{deg}'(p)=6$, $\\text{deg}'(r)=5$, $\\text{deg}'(s)=5$。这三个都是“高度数”节点（度数 $\\ge k=5$）。高度数邻居的数量是 $3$。由于 $3  k=5$，满足 Briggs 准则。合并是安全的。设新图为 $G''$。\n\n2.  **合并 $t_2 \\leftarrow T_{34}$**：这对应于原始的传送指令 $t_3 \\leftarrow t_2$。在 $G''$ 中，合并后的节点 $T_{234}$ 的邻居为 $\\text{Neigh}''(t_2) \\cup \\text{Neigh}''(T_{34}) = \\{p, q, s\\} \\cup \\{p, r, s\\} = \\{p, q, r, s\\}$。需要考虑 $G''$ 中的节点度数。$T_{234}$ 的邻居是 $\\{p, q, r, s\\}$。它们在 $G''$ 中的度数很容易发现对于 $p, q, r$ 是 $\\ge 5$，对于 $s$ 是 $5$。我们只计算合并节点在原始 $G'$ 中的邻居。合并节点 $T_{234}$ 的邻居是 $\\{p,q,r,s\\}$。它们在 $G'$ 中的原始度数是 $\\text{deg}'(p)=6$, $\\text{deg}'(q)=5$, $\\text{deg}'(r)=5$, $\\text{deg}'(s)=5$。所有 4 个邻居的度数都 $\\ge k=5$。高度数邻居的数量是 $4$。由于 $4  k=5$，根据 Briggs 准则，这次合并也是安全的。设新图为 $G'''$。\n\n3.  **合并 $t_1 \\leftarrow T_{234}$**：这对应于原始的传送指令 $t_2 \\leftarrow t_1$。最终合并的节点 $T = T_{1234}$ 的邻居为 $\\text{Neigh}'''(t_1) \\cup \\text{Neigh}'''(T_{234}) = \\{p, q, r\\} \\cup \\{p, q, r, s\\} = \\{p, q, r, s\\}$。邻居的数量是 $4$。即使它们都是高度数节点，由于 $4  k=5$，合并也是安全的。\n\n由于所有合并都是保守安全的，整个链可以被合并。最终的图由节点 $\\{T, p, q, r, s\\}$ 组成。节点 $T$ 连接到 $p, q, r, s$。移除 $u$ 后，节点 $\\{p, q, r, s\\}$ 自身形成一个 $4$-团（$K_4$）。因此，最终的图是一个 $K_5$（轮图 $W_5$），它是 $5$-可着色的。\n\n**成本分析**\n\n我们需要求出盈亏平衡比 $r^{\\ast} = \\frac{C_{\\text{spill}}}{C_{\\text{move}}}$，使得策略 B 的成本严格低于策略 A。\n\n- **策略 A 的成本, $C_A$**：在此策略中，没有发生溢出。三条传送指令（$t_2 \\leftarrow t_1, t_3 \\leftarrow t_2, t_4 \\leftarrow t_3$）在 $N$ 次循环迭代中每次都被执行。\n  $$ C_A = 3 \\times C_{\\text{move}} \\quad (\\text{每次迭代}) $$\n\n- **策略 B 的成本, $C_B$**：在此策略中，活跃范围 $u$ 被溢出。问题陈述 $u$ 在每次迭代中使用一次并重定义一次。这需要在每次迭代中进行一次使用前的内存加载和一次重定义后的内存存储，总共两次内存访问。所有三条传送指令都通过合并被消除。\n  $$ C_B = 2 \\times C_{\\text{spill}} \\quad (\\text{每次迭代}) $$\n\n当 $C_B  C_A$ 时，策略 B 的成本严格低于策略 A。\n$$ 2 \\times C_{\\text{spill}}  3 \\times C_{\\text{move}} $$\n为了找到关于比率 $r = \\frac{C_{\\text{spill}}}{C_{\\text{move}}}$ 的条件，我们将不等式两边同时除以 $C_{\\text{move}}$（一个正成本）。\n$$ 2 \\left( \\frac{C_{\\text{spill}}}{C_{\\text{move}}} \\right)  3 $$\n$$ 2r  3 $$\n$$ r  \\frac{3}{2} $$\n问题要求找到盈亏平衡比 $r^{\\ast}$，使得策略 B 成本更低的条件是 $r  r^{\\ast}$。根据我们推导出的不等式，这个值是 $r^{\\ast} = \\frac{3}{2}$。", "answer": "$$\\boxed{\\frac{3}{2}}$$", "id": "3666838"}]}