{"hands_on_practices": [{"introduction": "在深入研究复杂的成本计算之前，掌握重物质化背后的基本原理至关重要。其主要目标是通过缩短值在寄存器中的生命周期来减轻“寄存器压力”。本练习 [@problem_id:3668375] 是一个概念性挑战，要求您分析重物质化如何缩小变量的活跃范围，进而减少其与其他变量争夺有限寄存器空间的潜在冲突。", "problem": "考虑一个循环，其中归纳变量为 $i$，地址表达式 $a = \\text{base} + i \\cdot \\text{stride}$ 在循环内部使用，并在循环结束后立即使用一次。\n\n假设存在以下规范的控制流：一个前置头部（preheader）初始化 $i$，一个单入口单出口的循环在每次迭代中将 $i$ 增加一个固定的增量 $\\text{stride}$，并在 $i$ 达到边界 $N$ 时终止，还有一个出口块（exit block）恰好使用一次 $a$。目标架构支持通过单条指令从 $\\text{base}$、$i$ 和 $\\text{stride}$ 计算出 $a$。\n\n当前的寄存器分配器维护一个虚拟寄存器 $v_a$，用于在整个循环中及出口块中保存 $a$ 的运行值（例如，通过计算一次 $a$，然后在每次迭代中加上 $\\text{stride}$ 来更新它）。现在考虑一种“重新物质化”（rematerialization）变换，它不将 $v_a$ 跨循环传递，而是在出口处从 $\\text{base}$、$i$ 和 $\\text{stride}$ 在一个新的虚拟寄存器 $v_a^{\\text{exit}}$ 中重新计算 $a$。\n\n使用以下编译器理论中的基本定义：\n- 如果一个变量的当前值可能在从某个程序点开始的某条路径上被读取，之后才被覆盖，则该变量在该程序点是“活跃”的（live）。虚拟寄存器的“活跃范围”（live range）是它处于活跃状态的程序点的集合。活跃范围长度的减少意味着其活跃的程序点严格变少。\n- “冲突图”（interference graph）每个节点代表一个虚拟寄存器，如果两个节点的活跃范围在任何程序点重叠，则它们之间存在一条边。一个节点的“冲突度”（interference degree）$\\Delta$ 是其邻居的数量。\n\n假设 $\\text{base}$、$i$ 和 $\\text{stride}$ 在出口处要么已经可用，要么它们本身重新物质化的成本很低，因此在出口块中重新计算 $a$ 是合法的，并且相对于“溢出”（spill）操作其成本可以忽略不计。\n\n哪个陈述最好地描述了在循环出口处重新物质化 $a$ 对原始 $v_a$ 的活跃范围长度和冲突度 $\\Delta$ 的影响？\n\nA. 如果在出口处重新物质化 $a$，$v_a$ 的活跃范围将不再跨越循环至出口；它会严格缩短，在循环内最后一次使用后结束。因此，$v_a$ 会失去所有因与循环外的值重叠而产生的冲突，并且不会在出口处获得新的冲突，所以它的冲突度 $\\Delta$ 会弱性减少且绝不增加。\n\nB. 在出口处重新物质化 $a$ 不会影响 $v_a$ 的活跃范围，因为 $a$ 依赖于在循环中更新的 $i$；为保持正确性，$v_a$ 必须在整个循环中保持活跃，因此 $\\Delta$ 不变。\n\nC. 在出口处重新物质化 $a$ 会延长 $v_a$ 的活跃范围，因为 $i$ 必须保持活跃直到出口，这增加了同时活跃值的数量，从而增加了 $v_a$ 的 $\\Delta$。\n\nD. 其好处取决于 $\\text{stride}$：只有当 $\\text{stride} = 0$ 或 $\\text{stride} = 1$ 时，重新物质化才能缩短活跃范围；否则，$a = \\text{base} + i \\cdot \\text{stride}$ 中的乘法会阻止 $v_a$ 的 $\\Delta$ 减少。", "solution": "用户希望我分析在编译器优化背景下，重新物质化变换对虚拟寄存器的活跃范围和冲突度的影响。\n\n### 问题验证\n\n首先，我将验证问题陈述。\n\n**步骤1：提取已知条件**\n\n问题提供了以下信息和定义：\n- 一个带有归纳变量 $i$ 的循环。\n- 一个地址表达式 $a = \\text{base} + i \\cdot \\text{stride}$。\n- 值 $a$ 在循环内部使用，并在循环结束后立即使用一次。\n- 控制流是规范的：一个前置头部（preheader）初始化 $i$，一个单入口单出口的循环在每次迭代中将 $i$ 增加一个固定的增量 $\\text{stride}$，并在 $i$ 达到边界 $N$ 时终止。一个出口块（exit block）使用一次 $a$。\n- 目标架构可以通过单条指令从 $\\text{base}$、$i$ 和 $\\text{stride}$ 计算出 $a$。\n- 原始的寄存器分配策略维护一个虚拟寄存器 $v_a$，用于在整个循环及出口块中保存 $a$ 的值。\n- 考虑一种重新物质化变换：$v_a$ 不跨循环传递；而是在出口处从 $\\text{base}$、$i$ 和 $\\text{stride}$ 在一个新的虚拟寄存器 $v_a^{\\text{exit}}$ 中重新计算 $a$。\n- 一个变量在某个程序点上被定义为活跃的，如果它的值可能在将来的某条路径上被读取，然后才被覆盖。\n- 虚拟寄存器的活跃范围是它处于活跃状态的程序点的集合。\n- 活跃范围长度的减少意味着寄存器活跃的程序点严格变少。\n- 冲突图以虚拟寄存器为节点，如果两个节点的活跃范围重叠，则它们之间存在一条边。\n- 一个节点的冲突度 $\\Delta$ 是其邻居的数量。\n- 假设 $\\text{base}$、$i$ 和 $\\text{stride}$ 在出口处可用或重新物质化的成本低廉，并且重新计算的成本相对于溢出操作可以忽略不计。\n\n**步骤2：使用提取的已知条件进行验证**\n\n- **科学基础**：该问题牢固地植根于编译器构建理论，特别是在寄存器分配和优化领域。归纳变量、活跃性分析、活跃范围、冲突图和重新物质化等概念是该领域中标准且定义明确的主题。所提供的所有定义都与标准编译器文献一致。\n- **良构性（Well-Posed）**：问题结构清晰。它提出了一个初始场景（变换前）和一个修改后的场景（变换后），并要求描述这种变化。所有必要的术语都已定义，并且相关假设（例如，重新计算的输入可用）使问题可解。可以根据所提供的定义推導出唯一且有意义的结论。\n- **客观性**：语言技术性强、精确，没有歧义或主观性陈述。\n\n问题陈述没有科学或事实上的不健全之处，是可形式化的，并且与所述主题直接相关。它不是不完整、矛盾或结构不良的。\n\n**步骤3：结论与行动**\n\n问题陈述是有效的。我将继续进行解答。\n\n### 解答推导\n\n问题的核心是比较在重新物质化变换前后，虚拟寄存器 $v_a$ 的活跃范围。\n\n**1. 重新物质化前 $v_a$ 的活跃范围**\n\n在原始方案中，虚拟寄存器 $v_a$ 用于保存表达式 $a = \\text{base} + i \\cdot \\text{stride}$ 的值。该值在循环内部使用，并且关键地，在紧随循环的块（“出口块”）中也使用一次。\n\n为了满足在出口块中的使用，循环最后一次迭代计算出的 $a$ 的值必须保持可用，直到那个使用点。根据活跃性的定义，如果 $v_a$ 的当前值可能在未来被使用，那么它在任何程序点都是活跃的。因此，$v_a$ 在从循环内最后一次更新、跨越循环出口边、直到出口块中其最终使用点的路径上都是活跃的。所以 $v_a$ 的活跃范围横跨整个循环并延伸到出口块中。\n\n**2. 重新物质化后 $v_a$ 的活跃范围**\n\n重新物质化变换改变了这一点。现在，通过从 $\\text{base}$、$i$ 和 $\\text{stride}$ 重新计算 $a$ 并将其存储在一个新的虚拟寄存器 $v_a^{\\text{exit}}$ 中，来满足出口块中对 $a$ 的使用。\n\n结果是，原始的虚拟寄存器 $v_a$ 在循环结束后就不再需要了。它的最后一次使用现在是循环体*内部*的最后一次使用。在这次循环内的最后一次使用之后，$v_a$ 中的值将永远不会再被读取。因此，根据活跃性的定义，$v_a$ 在退出循环时是“死的”（dead）。\n\n比较这两种情况，$v_a$ 的活跃范围被缩短了。它不再包含从循环到出口块中使用点的路径上的程序点。这是 $v_a$ 活跃的程序点数量的严格减少。\n\n**3. 对冲突度 $\\Delta(v_a)$ 的影响**\n\n冲突度 $\\Delta(v_a)$ 是其活跃范围与 $v_a$ 的活跃范围重叠的其他虚拟寄存器的数量。设原始活跃范围为 $L_{old}(v_a)$，新的、缩短的活跃范围为 $L_{new}(v_a)$。我们已经确定 $L_{new}(v_a) \\subset L_{old}(v_a)$。\n\n- 会产生新的冲突吗？不会。如果 $L_{new}(v_a) \\cap L(v_x) \\neq \\emptyset$，那么因为 $L_{new}(v_a)$ 是 $L_{old}(v_a)$ 的子集，必然有 $L_{old}(v_a) \\cap L(v_x) \\neq \\emptyset$。所以，变换后存在的任何冲突必然在变换前就存在。该变换不能增加冲突度。\n\n- 能消除已有的冲突吗？是的。可能对于某个寄存器 $v_x$，其活跃范围仅在被移除的那部分与 $v_a$ 的活跃范围重叠。也就是说，$L_{old}(v_a) \\cap L(v_x) \\neq \\emptyset$，但 $L_{new}(v_a) \\cap L(v_x) = \\emptyset$。如果 $v_x$ 仅在跨越循环出口时活跃，而在 $v_a$ 保持活跃的循环体内部不活跃，就会发生这种情况。在这种情况下，$v_a$ 和 $v_x$ 之间的冲突边被消除，$\\Delta(v_a)$ 减少。\n\n结合这两点，冲突度 $\\Delta(v_a)$ 要么保持不变（如果所有预先存在的冲突都发生在 $L_{new}(v_a)$ 内），要么减少（如果某些冲突只发生在活跃范围被移除的部分）。它绝不会增加。这恰好被描述为“弱性减少”。\n\n### 逐项分析选项\n\n**A. 如果在出口处重新物质化 $a$，$v_a$ 的活跃范围将不再跨越循环至出口；它会严格缩短，在循环内最后一次使用后结束。因此，$v_a$ 会失去所有因与循环外的值重叠而产生的冲突，并且不会在出口处获得新的冲突，所以它的冲突度 $\\Delta$ 会弱性减少且绝不增加。**\n\n该陈述准确地反映了上述推导。$v_a$ 的活跃范围被严格缩短，因为它在出口块中的使用被消除了。这种缩短意味着它的新活跃范围是原始活跃范围的子集，因此不会形成新的冲突。那些仅限于循环外区域（在循环内最后一次使用之后）的现有冲突被移除。因此，冲突度 $\\Delta$ 只能减少或保持不变，这是一种弱性减少。\n**结论：正确。**\n\n**B. 在出口处重新物质化 $a$ 不会影响 $v_a$ 的活跃范围，因为 $a$ 依赖于在循环中更新的 $i$；为保持正确性，$v_a$ 必须在整个循环中保持活跃，因此 $\\Delta$ 不变。**\n\n这是不正确的。重新物质化的全部目的和定义就是为了打破这种活跃性依赖。正确性是通过从其组成部分（$\\text{base}$、$i$、$\\text{stride}$）重新推导值来维持的，而不是通过在 $v_a$ 中保留旧值。$v_a$ 必须保持活跃的前提是错误的。\n**结论：不正确。**\n\n**C. 在出口处重新物质化 $a$ 会延长 $v_a$ 的活跃范围，因为 $i$ 必须保持活跃直到出口，这增加了同时活跃值的数量，从而增加了 $v_a$ 的 $\\Delta$。**\n\n这是不正确的。该变换*缩短*了 $v_a$ 的活跃范围，而不是延长它。虽然保存 $i$ 的寄存器的活跃范围可能会延伸到重新计算点，但这并不影响 $v_a$ 的活跃范围。该陈述混淆了重新计算的输入的活跃性要求与被替换的原始值的活跃性。缩短的活跃范围不可能导致 $v_a$ 的冲突度增加。\n**结论：不正确。**\n\n**D. 其好处取决于 $\\text{stride}$：只有当 $\\text{stride} = 0$ 或 $\\text{stride} = 1$ 时，重新物质化才能缩短活跃范围；否则，$a = \\text{base} + i \\cdot \\text{stride}$ 中的乘法会阻止 $v_a$ 的 $\\Delta$ 减少。**\n\n这是不正确的。活跃范围分析和重新物质化的逻辑基于程序的数据流和控制流，而不是所涉及的具体算术值或运算符（只要重新计算是可能的，这是一个已知条件）。$\\text{stride}$ 的值与活跃范围能否缩短无关。缩短活跃范围的能力仅取决于用一个新的计算来替换循环外的使用。乘法的存在并不会改变这一基本原则。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3668375"}, {"introduction": "有了概念性的理解之后，我们现在可以量化决策过程。编译器必须做出权衡：是重新计算一个值的成本更低，还是将其保存到内存中稍后重新加载的成本更低？本练习 [@problem_id:3668340] 将引导您推导出一个基本的成本效益阈值，基于一个简化的成本模型，为判断何时重物质化是更高效的选择提供一个清晰的数学法则。", "problem": "执行寄存器分配（RA）的编译器必须对一个其生存期无法完全分配到寄存器中的值做出决定：是将其溢出（spill）到内存并在每次使用时重新加载，还是在每次使用时通过从其操作数重新计算来再物质化（rematerialize）该值。考虑一个成本模型，其中所有动态成本在独立事件之间线性相加，并以每次执行的机器周期为单位进行测量。令 $C_{\\text{spill}}$ 表示如果该值被溢出，在整个生存期内累积的总动态成本，包括任何一次性存储和所有重新加载。令 $C_{\\text{rm}}$ 表示每次使用时再物质化该值的动态成本（例如，重新生成一个立即数并应用一个简单算术运算的成本）。令 $U$ 表示该值在程序执行剖面中的动态使用次数，定义为所有静态使用点的执行次数之和。\n\n仅从这些定义和独立成本线性可加的假设出发，推导出一个用 $C_{\\text{spill}}$ 和 $U$ 表示的阈值表达式 $C_{\\text{rm}}^{*}$，使得当且仅当 $C_{\\text{rm}}$ 低于此阈值时，选择再物质化能够最小化总动态成本。用 $C_{\\text{rm}}$ 和 $C_{\\text{rm}}^{*}$ 陈述决策准则。\n\n然后用下面的计算示例来验证该表达式。一个值 $v$ 有三个静态使用点：一个在基本块 $B_{1}$ 中，执行 $10$ 次；一个在 $B_{2}$ 中，执行 $2$ 次；一个在 $B_{3}$ 中，执行 $2$ 次，因此动态使用次数是这些使用点执行次数的总和。如果溢出，$v$ 会产生一次性存储成本 $c_{s} = 12$ 个周期，以及每次动态使用产生 $c_{\\ell} = 6$ 个周期的重载成本，所以总溢出成本是一次性存储成本加上所有动态使用的重载成本之和。如果再物质化，$v$ 可以在每次使用时通过加载一个立即数并执行一个单独的算术运算来重新计算，其成本分别为 $c_{\\text{imm}} = 2$ 个周期和 $c_{\\text{op}} = 1$ 个周期，所以每次使用的再物质化成本是这些操作成本的总和。\n\n计算：\n1. 阈值 $C_{\\text{rm}}^{*}$。\n2. 决策指示符 $D$，如果选择再物质化，则 $D = 1$，否则 $D = 0$。\n\n将数值阈值以每次使用的机器周期为单位表示，决策指示符表示为无量纲值。将最终答案以行矩阵 $\\begin{pmatrix} C_{\\text{rm}}^{*}  D \\end{pmatrix}$ 的形式报告。", "solution": "该问题要求推导一个决策准则，用于在两种编译器优化策略之间进行选择：将值溢出到内存或进行再物质化。这两种策略适用于无法在整个生存期内都保存在寄存器中的值。决策应基于最小化总动态成本，以机器周期为单位。\n\n首先，我们根据所提供的定义，为每种策略建立总动态成本。令 $C_{\\text{total, spill}}$ 为溢出策略的总成本，令 $C_{\\text{total, rm}}$ 为再物质化策略的总成本。\n\n问题将 $C_{\\text{spill}}$ 定义为溢出策略的总动态成本，包括一次性存储和所有后续的重新加载。因此，我们有：\n$$C_{\\text{total, spill}} = C_{\\text{spill}}$$\n\n问题将 $C_{\\text{rm}}$ 定义为每次使用时再物质化该值的动态成本。该值的总动态使用次数由 $U$ 给出。问题陈述成本在独立事件之间线性相加。由于再物质化在 $U$ 次动态使用中的每一次都会执行，因此该策略的总成本是每次使用的成本乘以使用次数：\n$$C_{\\text{total, rm}} = C_{\\text{rm}} \\times U$$\n\n为了最小化总动态成本，编译器当且仅当再物质化的总成本严格小于溢出的总成本时，才应选择再物质化。这给了我们以下不等式：\n$$C_{\\text{total, rm}}  C_{\\text{total, spill}}$$\n代入总成本的表达式，我们得到：\n$$C_{\\text{rm}} \\times U  C_{\\text{spill}}$$\n\n问题要求一个阈值 $C_{\\text{rm}}^{*}$，使得当 $C_{\\text{rm}}  C_{\\text{rm}}^{*}$ 时，再物质化恰好是最佳选择。为了推导这个阈值，我们在不等式中分离出 $C_{\\text{rm}}$。假设该值至少被使用一次，那么动态使用次数 $U$ 是一个正整数（$U \\ge 1$）。因此，我们可以在不等式两边同时除以 $U$ 而不改变其方向：\n$$C_{\\text{rm}}  \\frac{C_{\\text{spill}}}{U}$$\n通过将此不等式与所需形式 $C_{\\text{rm}}  C_{\\text{rm}}^{*}$ 进行比较，我们可以直接确定阈值 $C_{\\text{rm}}^{*}$：\n$$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U}$$\n决策准则是：如果 $C_{\\text{rm}}  C_{\\text{rm}}^{*}$，则选择再物质化；否则，选择溢出。\n\n接下来，我们将此形式化推导应用于计算示例，以计算 $C_{\\text{rm}}^{*}$ 和决策指示符 $D$ 的数值。\n\n1.  **计算动态使用次数, $U$**。\n    $U$ 是所有静态使用点执行次数的总和。\n    $$U = 10 + 2 + 2 = 14$$\n\n2.  **计算总溢出成本, $C_{\\text{spill}}$**。\n    该成本包括一次性存储成本 $c_{s} = 12$ 个周期，以及每次动态使用 $U$ 次时产生的重载成本 $c_{\\ell} = 6$ 个周期。\n    $$C_{\\text{spill}} = c_{s} + (c_{\\ell} \\times U) = 12 + (6 \\times 14) = 12 + 84 = 96$$\n    总溢出成本为 $96$ 个周期。\n\n3.  **计算每次使用的再物质化成本, $C_{\\text{rm}}$**。\n    该成本是加载立即数的成本 $c_{\\text{imm}} = 2$ 个周期和单个算术运算的成本 $c_{\\text{op}} = 1$ 个周期的总和。\n    $$C_{\\text{rm}} = c_{\\text{imm}} + c_{\\text{op}} = 2 + 1 = 3$$\n    每次使用的再物质化成本是 $3$ 个周期。\n\n4.  **计算阈值, $C_{\\text{rm}}^{*}$**。\n    使用推导出的公式以及计算出的 $C_{\\text{spill}}$ 和 $U$ 的值：\n    $$C_{\\text{rm}}^{*} = \\frac{C_{\\text{spill}}}{U} = \\frac{96}{14} = \\frac{48}{7}$$\n    阈值是 $\\frac{48}{7}$ 机器周期/每次使用。\n\n5.  **确定决策指示符, $D$**。\n    我们通过比较实际的每次使用成本 $C_{\\text{rm}}$ 和阈值 $C_{\\text{rm}}^{*}$ 来应用决策准则：\n    $$C_{\\text{rm}} = 3$$\n    $$C_{\\text{rm}}^{*} = \\frac{48}{7} \\approx 6.857$$\n    需要检查的不等式是 $C_{\\text{rm}}  C_{\\text{rm}}^{*}$，即 $3  \\frac{48}{7}$。两边乘以 $7$ 得到 $21  48$，这是成立的。\n    由于条件满足，再物质化是成本最低的策略。问题定义决策指示符 $D$ 在选择再物质化时为 $1$。因此：\n    $$D = 1$$", "answer": "$$\\boxed{\\begin{pmatrix} \\frac{48}{7}  1 \\end{pmatrix}}$$", "id": "3668340"}, {"introduction": "简单的成本模型具有指导意义，但现实世界中的编译器必须考虑到并非所有代码的执行频率都相同。这最后一个练习 [@problem_id:3668302] 引入了一个更复杂的模型，该模型考虑了动态执行频率。通过分析一个涉及循环的常见场景，您将看到根据代码的运行频率对成本进行加权如何能够带来更准确和有效的优化决策。", "problem": "考虑一个编译器在执行寄存器分配时，可以选择将变量溢出或在其使用处重新物化。假设一个程序由基本块 $B_i$ 表示，其估算的动态执行频率为 $f(B_i)$。对于一个变量 $v$，将频率加权溢出成本定义为 $C_{\\text{spill}}(v) = \\sum_i f(B_i)\\cdot c_i$，其中 $c_i$ 是基本块 $B_i$ 中由溢出代码（存储和重载）贡献的单次执行总成本。类似地，将频率加权重新物化成本定义为 $C_{\\text{rm}}(v) = \\sum_j f(B_j)\\cdot r_j$，其中 $r_j$ 是在基本块 $B_j$ 中通过在其使用处重计算 $v$ 所贡献的单次执行总成本。仅使用优化器应最小化期望动态成本（各基本块成本的频率加权和）这一基本原则，推导出一个决策规则，以确定何时应为变量 $v$ 选择重新物化而不是溢出。\n\n然后，在以下示例控制流图上测试该决策：\n- 有两个基本块：一个循环体 $B_0$，其频率为 $f(B_0)=100$；以及一个循环前置/退出块 $B_1$，其频率为 $f(B_1)=1$。\n- 变量 $v$ 在 $B_1$ 中定义一次，在 $B_0$ 的每次迭代中使用两次，并在循环后失效。\n- 如果 $v$ 被溢出，编译器在其定义处插入一条存储指令，并在 $B_0$ 的每次使用前插入一条重载指令。单次操作成本为：存储成本 $s=5$，重载成本 $\\ell=8$。\n- 如果 $v$ 被重新物化，其在 $B_0$ 中的每次使用都将以成本 $r=3$ 进行重计算，并且在其定义处不插入存储指令。\n\n使用频率加权成本模型和你的决策规则，计算该程序的标量值 $S = C_{\\text{spill}}(v) - C_{\\text{rm}}(v)$。将 $S$ 报告为单个整数（无需四舍五入）。", "solution": "该问题要求完成两个主要任务：首先，基于成本最小化原则，推导一个在溢出和重新物化之间进行选择的决策规则；其次，通过计算成本差异，将此规则应用于一个具体示例。\n\n首先，我们推导决策规则。问题指出，优化器的基本原则是最小化期望动态成本。变量 $v$ 的溢出和重新物化的期望动态成本分别由 $C_{\\text{spill}}(v)$ 和 $C_{\\text{rm}}(v)$ 给出。它们被定义为各基本块成本的频率加权和：\n$$C_{\\text{spill}}(v) = \\sum_i f(B_i)\\cdot c_i$$\n$$C_{\\text{rm}}(v) = \\sum_j f(B_j)\\cdot r_j$$\n其中 $f(B_i)$ 是基本块 $B_i$ 的执行频率，而 $c_i$ 和 $r_j$ 是一个基本块内溢出和重新物化代码的单次执行成本。\n\n为最小化总成本，优化器必须比较这两种替代方案的成本。如果重新物化的总成本低于溢出的总成本，则重新物化是首选方案。因此，当且仅当以下条件成立时，为变量 $v$ 选择重新物化：\n$$C_{\\text{rm}}(v)  C_{\\text{spill}}(v)$$\n\n接下来，我们将此成本模型应用于给定的控制流图。该程序包含两个基本块：一个循环体 $B_0$ 和一个循环前置/退出块 $B_1$。它们的动态执行频率分别为 $f(B_0) = 100$ 和 $f(B_1) = 1$。变量 $v$ 在 $B_1$ 中定义一次，在 $B_0$ 中使用两次。\n\n现在我们来计算这个特定情况下的成本 $C_{\\text{spill}}(v)$ 和 $C_{\\text{rm}}(v)$。\n\n计算溢出成本 $C_{\\text{spill}}(v)$：\n如果 $v$ 被溢出，则在其定义处（即基本块 $B_1$）插入一条存储指令，并在其两次使用前（即基本块 $B_0$）各插入一条重载指令。\n单次操作成本为：存储成本 $s = 5$，重载成本 $\\ell = 8$。\n\n基本块 $B_1$ 中与溢出相关的单次执行成本，记为 $c_1$，是单条存储指令的成本。因此，$c_1 = s = 5$。\n基本块 $B_0$ 中与溢出相关的单次执行成本，记为 $c_0$，是两条重载指令的成本。因此，$c_0 = 2 \\cdot \\ell = 2 \\cdot 8 = 16$。\n\n总的频率加权溢出成本是各基本块成本之和：\n$$C_{\\text{spill}}(v) = f(B_0) \\cdot c_0 + f(B_1) \\cdot c_1$$\n代入给定值：\n$$C_{\\text{spill}}(v) = 100 \\cdot 16 + 1 \\cdot 5 = 1600 + 5 = 1605$$\n\n计算重新物化成本 $C_{\\text{rm}}(v)$：\n如果 $v$ 被重新物化，其值将在基本块 $B_0$ 的每次使用处被重计算。在 $B_1$ 的定义处不需要存储指令。每次重计算的成本为 $r = 3$。\n\n基本块 $B_1$ 中的单次执行重新物化成本，记为 $r_1$，为零，因为在 $B_1$ 中没有对 $v$ 的使用，也未插入存储指令。因此，$r_1 = 0$。\n基本块 $B_0$ 中的单次执行重新物化成本，记为 $r_0$，是在其两次使用处重计算 $v$ 的成本。因此，$r_0 = 2 \\cdot r = 2 \\cdot 3 = 6$。\n\n总的频率加权重新物化成本是各基本块成本之和：\n$$C_{\\text{rm}}(v) = f(B_0) \\cdot r_0 + f(B_1) \\cdot r_1$$\n代入数值：\n$$C_{\\text{rm}}(v) = 100 \\cdot 6 + 1 \\cdot 0 = 600 + 0 = 600$$\n\n最后，问题要求计算标量值 $S$，定义为两种成本之差：\n$$S = C_{\\text{spill}}(v) - C_{\\text{rm}}(v)$$\n使用我们计算出的值：\n$$S = 1605 - 600 = 1005$$\n由于 $S > 0$，我们有 $C_{\\text{spill}}(v) > C_{\\text{rm}}(v)$，我们推导的决策规则会正确地为这种情况选择重新物化，因为它能带来更低的期望动态成本。计算出的 $S$ 值为 $1005$。", "answer": "$$\\boxed{1005}$$", "id": "3668302"}]}