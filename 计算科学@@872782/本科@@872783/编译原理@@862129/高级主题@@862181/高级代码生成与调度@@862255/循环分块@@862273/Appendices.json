{"hands_on_practices": [{"introduction": "在应用循环分块来提升性能之前，我们必须首先确保这种变换是合法的，即它不会改变程序的原始语义。这个基本前提依赖于仔细分析循环携带的相关性。本练习将引导你探讨一个存在特定数据相关性的循环，并解释为何直接分块可能不合法，以及如何通过一种名为循环倾斜（loop skewing）的技术来恢复合法性，为性能优化铺平道路。[@problem_id:3653878]", "problem": "考虑一个完美嵌套的双层循环程序，其迭代域为 $\\{(i,j) \\mid 0 \\le i \\le N-1,\\ 0 \\le j \\le M-1\\}$，由默认的字典序调度 $(i,j)$ 执行。其中有一个单一语句，在 $(i,j)$ 空间中引发了一个循环携带依赖，其距离向量为 $d=(1,0)$。假设您希望对两个循环都应用矩形循环分块（条带挖掘），块大小分别为 $T_i$ 和 $T_j$，然后按其块索引的字典序执行这些块。在分块之前，您也可以应用一个形式为 $j' = j + S i$ 的幺模偏斜变换（其中 $S$ 为整数）。\n\n请仅从循环携带依赖、作为依赖图拓扑排序的合法调度、以及仿射变换对依赖距离向量的影响等基本定义出发，回答以下问题：\n\n- 使用依赖向量 $d=(1,0)$ 和调度合法性的定义，解释为什么仅沿 $j$ 维度分块不需要偏斜来保持合法性，而当对二维带 $(i,j)$ 进行分块时，可能需要对 $j$ 相对于 $i$ 进行偏斜，以满足一个充分的合法性条件，即所有带内依赖分量都为非负，并且沿最后一个分块维度的分量为严格正数。\n- 构建最小整数偏斜因子 $S$，使得在应用偏斜 $j' = j + S i$ 后，用大小为 $T_i$ 和 $T_j$ 的矩形对带 $(i,j')$ 进行分块，并按 $(\\lfloor i/T_i \\rfloor,\\ \\lfloor j'/T_j \\rfloor)$ 的字典序执行这些块，所产生的调度，其依赖在分块带上的投影具有非负分量，并且沿最后一个维度的分量为严格正数。\n\n你的最终答案必须是最小整数 $S$，且必须是一个单独的数字。如果你提供一个数值，则不需要四舍五入。", "solution": "问题要求解释为什么在特定的合法性条件下，对二维带进行分块需要循环偏斜，并推导出最小整数偏斜因子。我们首先将依赖、调度和变换的概念形式化。\n\n循环携带依赖由一个距离向量 $\\vec{d}$ 表示。依赖存在于从迭代 $\\vec{p}$ 到迭代 $\\vec{q} = \\vec{p} + \\vec{d}$。如果对于每个依赖，其依赖源 $\\vec{p}$ 都在其依赖宿 $\\vec{q}$ 之前执行，则该调度是合法的。对于一个迭代向量 $\\vec{x}$ 上的字典序调度，这意味着 $\\vec{q}$ 的调度向量必须在字典序上大于 $\\vec{p}$ 的调度向量。给定的初始调度是在 $(i,j)$ 上的字典序，依赖距离向量为 $\\vec{d} = (1,0)$。存在一个从迭代 $(i,j)$ 到 $(i+1,j)$ 的依赖。调度向量之差为 $(i+1,j) - (i,j) = (1,0)$，这在字典序上为正。因此，原始的未分块循环是合法的。\n\n循环分块将迭代空间划分为多个块（tiles），并添加外层循环来遍历这些块。一种常见的块执行调度是按块索引的字典序进行。这个新调度的合法性必须得到保持。分块合法性的一个充分条件，也是问题中指定的条件是，对于任何依赖向量，其在分块维度上的投影必须所有分量都为非负，并且对应于最后一个分块维度的分量必须是严格正数。这确保了依赖在块空间中总是“向前”流动，从而使调度变得直接简单。\n\n让我们分析问题第一部分提出的两种情况。\n\n情况1：仅沿 $j$ 维度分块。\n仅沿 $j$ 维度分块对应于将迭代空间划分为垂直条带。分块带是一维的，仅包含 $j$ 循环。依赖向量为 $\\vec{d} = (1,0)$。这个依赖向量在一维带 $(j)$ 上的投影就是它的 $j$ 分量，即 $0$。一个依赖，其向量在分块带上的投影为零向量，是块内（或带内）依赖。它不跨越块边界。块的执行顺序与此依赖无关。在每个块（条带）内，原始的 $(i,j)$ 字典序足以保持合法性。因此，不需要偏斜，因为该依赖不是由分块的循环携带的。\n\n情况2：对二维带 $(i,j)$ 进行分块。\n这里，两个循环都被分块。分块带是 $(i,j)$，此带内的依赖向量为 $\\vec{d} = (1,0)$。我们将问题中陈述的合法性条件应用于该向量。\n1. 所有分量必须为非负。$\\vec{d}$ 的分量是 $d_i=1$ 和 $d_j=0$。$1 \\ge 0$ 和 $0 \\ge 0$ 都成立。条件的这一部分得到满足。\n2. 沿最后一个分块维度的分量必须是严格正数。最后一个分块维度是 $j$。依赖向量的 $j$ 分量是 $d_j=0$。这不是严格正数 ($0 \\not> 0$)。\n因此，依赖向量 $\\vec{d}=(1,0)$ 违反了为二维带 $(i,j)$ 分块指定的充分合法性条件。为了满足这个严格的条件，依赖向量必须被变换。这就是为什么需要偏斜。像 $(1,0)$ 这样的依赖向量意味着同一行中相邻块之间的依赖，即块 $(I-1, J)$ 和块 $(I, J)$ 之间。尽管在字典序的块执行下这是完全合法的，但它不满足那个更严格的条件，该条件旨在使所有依赖在块空间的最后一个维度上都有一个正分量。\n\n现在，我们来构建最小整数偏斜因子 $S$。问题要求在分块前应用一个偏斜变换 $j' = j+Si$。这是一个可以用矩阵表示的仿射变换。新的迭代空间由 $(i,j')$ 坐标化，因为对 $i$ 的变换是单位变换，$i'=i$。我们找到将原始坐标 $(i,j)$ 映射到新坐标 $(i,j')$ 的变换矩阵 $M_S$。\n$$\n\\begin{pmatrix} i' \\\\ j' \\end{pmatrix} = \\begin{pmatrix} 1  & 0 \\\\ S & 1 \\end{pmatrix} \\begin{pmatrix} i \\\\ j \\end{pmatrix}\n$$\n这个线性变换对依赖向量 $\\vec{d}$ 的作用是乘以相同的矩阵 $M_S$。原始依赖向量为 $\\vec{d} = (1,0)$。在偏斜后的 $(i, j')$ 空间中，新的依赖向量 $\\vec{d'}$ 是：\n$$\n\\vec{d'} = M_S \\vec{d} = \\begin{pmatrix} 1 & 0 \\\\ S & 1 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} = \\begin{pmatrix} (1)(1) + (0)(0) \\\\ (S)(1) + (1)(0) \\end{pmatrix} = \\begin{pmatrix} 1 \\\\ S \\end{pmatrix}\n$$\n偏斜之后，我们对二维带 $(i,j')$ 进行分块。在这个分块带中的依赖向量是 $\\vec{d'} = (1,S)$。我们现在将合法性条件应用于这个新向量 $\\vec{d'}$。\n1. 所有分量必须为非负：\n   - 第一个分量是 $1$，而 $1 \\ge 0$ 总是成立。\n   - 第二个分量是 $S$，所以我们要求 $S \\ge 0$。\n2. 沿最后一个分块维度的分量必须是严格正数：\n   - 最后一个分块维度是 $j'$。依赖向量的相应分量是 $S$。\n   - 我们要求 $S > 0$。\n\n结合这两个条件，$S \\ge 0$ 和 $S > 0$，我们发现偏斜因子 $S$ 必须是一个正整数。问题要求最小整数偏斜因子 $S$。正整数集合是 $\\{1, 2, 3, \\dots\\}$。这个集合中的最小值是 $1$。\n因此，最小整数偏斜因子是 $S=1$。使用此偏斜，依赖向量变为 $(1,1)$，它满足条件，因为两个分量都是非负的，且最后一个分量是严格正数。", "answer": "$$\n\\boxed{1}\n$$", "id": "3653878"}, {"introduction": "一旦确定循环分块是合法的，下一个关键问题就是：我们应该选择多大的分块尺寸（tile size）？分块尺寸的选择是一个精妙的权衡过程，过小则无法充分利用数据重用，过大则可能超出缓存容量导致数据被频繁换出。本练习提供了一个具体的场景，让你从第一性原理出发，推导分块尺寸如何同时受到缓存容量限制和直接映射缓存中冲突失效（conflict miss）的制约。[@problem_id:3653910]", "problem": "考虑以下对一个以行主序存储的二维数组进行操作的双重嵌套循环：\nfor i in 0..N-1:\n    for j in 0..M-1:\n        A[i][j] = A[i][j] + 1\n\n现对此循环嵌套应用循环分块技术，使用边长为 $T$ 的方形分块，即选择 $T_i = T_j = T$ 并按如下方式迭代分块：\nfor i0 in 0..N-1 step T:\n    for j0 in 0..M-1 step T:\n        for ii in 0..T-1:\n            for jj in 0..T-1:\n                A[i0+ii][j0+jj] = A[i0+ii][j0+jj] + 1\n\n假设具体的机器和数据特征如下：\n- 数组 $A$ 的维度为 $N \\times M$，其中 $N$ 和 $M$ 足够大，可以忽略边界分块。取 $M = 1024$。\n- 数组 $A$ 的元素大小为 $E = 8$ 字节（双精度浮点数）。\n- 内存布局严格为行主序：$A[i][j]$ 的地址是 $A_{\\text{base}} + (i \\cdot M + j) \\cdot E$。\n- 一级（L1）缓存是直接映射的，容量 $C = 32768$ 字节，缓存行大小 $L = 64$ 字节。共有 $S = C / L$ 个缓存行/组。\n- 中央处理器（CPU）按所示顺序执行内层循环；在每个分块内，元素以 $j$ 最快变化的方式被访问。假设没有访问其他数组，并且在每个分块开始时 L1 缓存是冷的，但在处理一个分块时不受其他活动干扰。\n\n你的目标是选择一个最大的整数分块边长 $T$，使得在处理任何单个分块时：\n1) 就必须同时持有的不同缓存行而言，分块的总缓存足迹永远不超过 L1 缓存容量（从而避免分块内的容量驱逐），以及\n2) 在分块内固定列偏移处跨越 $T$ 行的访问模式不会在直接映射的 L1 缓存中引起冲突抖动（从而避免分块内的冲突驱逐）。\n\n根据行主序寻址和直接映射缓存索引的基本原理推导出这两个约束，并计算满足这两个约束的最大整数 $T$。最终答案只报告这个 $T$ 值（无单位）。由于 $T$ 根据定义是整数，因此不需要进行舍入操作。", "solution": "我们的目标是找到满足容量和冲突两个约束的最大整数分块边长 $T$。\n\n首先，我们明确缓存的参数：\n- 缓存容量 $C = 32768$ 字节\n- 缓存行大小 $L = 64$ 字节\n- 元素大小 $E = 8$ 字节\n- 数组列数 $M = 1024$\n- 由于缓存是直接映射的，缓存行的总数（也即缓存组数）为 $S = C/L = 32768 / 64 = 512$。\n\n**约束 1：容量约束**\n\n一个大小为 $T \\times T$ 的分块的工作集必须能够完全放入L1缓存中，以避免容量未命中。该分块由 $T$ 行组成，每行包含 $T$ 个元素。\n一个行段（分块的一行）的数据大小为 $T \\times E = 8T$ 字节。由于内存对齐的不确定性，一个行段可能跨越多个缓存行。一个常用的保守估计是，一个 $T \\times T$ 的分块访问的 $T$ 个行段，其总数据量 $T \\times T \\times E$ 必须小于缓存容量 $C$。\n$T \\times T \\times 8 \\le 32768$\n$T^2 \\le 4096$\n$T \\le \\sqrt{4096} = 64$\n\n一个更精确的模型考虑了每行数据段由于未对齐可能带来的额外开销。一个 $T \\times T$ 的分块由 $T$ 个不连续的行段组成。每个行段大小为 $8T$ 字节。在最坏的情况下，每个行段的起始地址都刚好跨越一个缓存行边界，导致每个行段都需要 $\\lceil 8T/64 \\rceil + 1 = \\lceil T/8 \\rceil + 1$ 个缓存行。总共需要 $T \\times (\\lceil T/8 \\rceil + 1)$ 个缓存行。这个不等式求解起来比较复杂。\n我们采用一个介于两者之间的简单模型：整个分块的数据量为 $T^2$ 个元素，总字节数为 $8T^2$。假设这些数据在内存中不是连续的，但在理想情况下，它们占用的缓存行数约为 $\\lceil 8T^2 / 64 \\rceil = \\lceil T^2 / 8 \\rceil$。这忽略了数据在内存中的分散性。\n考虑到问题中分块是由 $T$ 个独立的行段组成的，我们分析最坏情况下的缓存足迹。每个行段长度为 $8T$ 字节，最坏情况下需要 $\\lfloor (8T-1)/64 \\rfloor + 2$ 个缓存行。为简单起见，我们使用一个常见的保守估计：$T$ 个行段，每个段的内存足迹约为 $8T$ 字节。由于它们在内存中不连续，我们假设每个行段独立映射到缓存。一个 $T \\times T$ 分块的总数据量为 $8T^2$ 字节，这必须小于缓存容量。\n$8T^2 \\le 32768 \\implies T^2 \\le 4096 \\implies T_{\\text{cap}} \\le 64$。\n所以，基于容量的约束是 $T \\le 64$。\n\n**约束 2：冲突约束**\n\n由于缓存是直接映射的，当多个内存地址映射到同一个缓存索引时，就会发生冲突。缓存行索引由以下公式计算：\n$\\text{Index} = (\\text{内存地址} / L) \\pmod{S}$\n\n我们考虑在分块内沿同一列的访问模式，例如访问 $A[i_0][j_0], A[i_0+1][j_0], \\dots, A[i_0+T-1][j_0]$。\n根据行主序布局，$A[i][j]$ 的地址为 $A_{\\text{base}} + (i \\cdot M + j) \\cdot E$。\n$A[i][j_0]$ 和 $A[i+1][j_0]$ 的地址差为：\n$\\Delta_{\\text{addr}} = (( (i+1) \\cdot M + j_0 ) \\cdot E) - (( i \\cdot M + j_0 ) \\cdot E) = M \\cdot E = 1024 \\times 8 = 8192$ 字节。\n\n这个地址差对应于 $\\Delta_{\\text{lines}} = \\Delta_{\\text{addr}} / L = 8192 / 64 = 128$ 个缓存行。\n这意味着，当访问同一列中的两个连续元素时，它们的缓存行索引会相差 $128$（模 $S$）。\n我们来观察索引序列：\n- 访问 $A[i_0][j_0]$ 的索引为 $idx_0$。\n- 访问 $A[i_0+1][j_0]$ 的索引为 $(idx_0 + 128) \\pmod{512}$。\n- 访问 $A[i_0+2][j_0]$ 的索引为 $(idx_0 + 256) \\pmod{512}$。\n- 访问 $A[i_0+3][j_0]$ 的索引为 $(idx_0 + 384) \\pmod{512}$。\n- 访问 $A[i_0+4][j_0]$ 的索引为 $(idx_0 + 512) \\pmod{512} = idx_0$。\n\n这个索引序列的周期长度为 $S / \\gcd(\\Delta_{\\text{lines}}, S) = 512 / \\gcd(128, 512) = 512 / 128 = 4$。\n这意味着，当访问同一列的第5个元素时，其缓存行索引会与第1个元素相同，从而在直接映射缓存中产生冲突，将第一个元素的数据驱逐出缓存。\n为了避免在处理一个分块时发生这种冲突，分块的高度 $T$ 必须小于或等于这个不发生冲突的周期长度。\n因此，我们得到冲突约束：$T_{\\text{conf}} \\le 4$。\n\n**结论**\n\n为了同时满足容量约束和冲突约束，分块边长 $T$ 必须满足：\n$T \\le \\min(T_{\\text{cap}}, T_{\\text{conf}})$\n$T \\le \\min(64, 4)$\n$T \\le 4$\n\n因此，满足这两个约束的最大整数分块边长 $T$ 是 $4$。", "answer": "$$\n\\boxed{4}\n$$", "id": "3653910"}, {"introduction": "我们进行循环分块的最终目标是提升程序性能，而不仅仅是减少缓存不命中次数。屋顶线性能模型（Roofline Performance Model）为我们提供了一个强大的框架，用以理解程序性能是被计算能力还是内存带宽所限制。本练习将循环分块置于这一更广阔的性能图景中，要求你分析不同分块策略如何影响计算的算术强度（arithmetic intensity），并确定需要多大的分块才能使一个内存密集型（memory-bound）的计算核心转变为计算密集型（compute-bound）。[@problem_id:3653939]", "problem": "考虑一个二维模糊核应用于一个 $N \\times N$ 的双精度值数组。每个输出点由一个 $3 \\times 3$ 的邻域（半径 $r=1$）计算得出，每次输出执行 $9$ 次乘法和 $8$ 次加法，总计每次输出 $f=17$ 次浮点运算。假设以下基本事实：\n\n- 算术强度 $AI$ 定义为总浮点运算次数除以与主存之间传输的总字节数。\n- Roofline 性能模型 (RPM) 将屋脊点描述为 $R = P_{\\text{peak}} / B$，其中 $P_{\\text{peak}}$ 是峰值浮点吞吐率（单位为每秒浮点运算次数），$B$ 是可持续主存带宽（单位为每秒字节数）。如果 $AI \\ge R$，则该核函数是计算受限的；否则，它是内存受限的。\n- 双精度值占用 $8$ 字节。\n- 使用流式存储，因此每次输出写入仅向内存贡献一次 $8$ 字节的存储，无任何所有权读取流量。\n- 在一个瓦片内，从内存中取出的所有输入数据都会被完全重用，直到该瓦片的输出计算完成；不同瓦片之间没有数据重用，并且可以忽略瓦片内的容量/冲突未命中，因为瓦片的内存足迹适合缓存。\n\n您将比较两种瓦片化策略：\n\n1. 矩形瓦片化：一个瓦片计算 $t_x \\times t_y$ 个输出，加载半径 $r=1$ 的光环区域，因此其唯一的输入内存足迹为 $(t_x+2)\\times(t_y+2)$，并写入 $t_x t_y$ 个输出。\n2. 条带状瓦片化（仅在一个维度上进行瓦片化）：一个条带计算单行中的 $s \\times 1$ 个输出。为了计算这 $s$ 个半径为 $r=1$ 的输出，该条带加载跨越 $(s+2)$ 列的 $3$ 行输入（中间行及其垂直相邻行），并写入 $s$ 个输出。\n\n假设机器的峰值性能 $P_{\\text{peak}} = 100 \\times 10^{9}$ 次浮点运算/秒，可持续带宽 $B = 200 \\times 10^{9}$ 字节/秒。仅使用上述定义并仔细计算每个瓦片内的重用：\n\n- 推导条带的算术强度 $AI_{\\text{strip}}(s)$ 作为 $s$ 的函数。\n- 使用 Roofline 屋脊点 $R$ 来确定最小的实数条带宽度 $s$，使得 $AI_{\\text{strip}}(s)$ 恰好等于 $R$。\n\n提供 $s$ 的最终阈值作为一个单一数字。无需四舍五入。", "solution": "我们的目标是找到使模糊核的性能从内存受限转为计算受限的最小条带宽度 $s$。根据屋顶线性能模型，这个临界点发生在核的算术强度（AI）等于机器的屋脊点（Ridge Point, R）时。\n\n**第一步：计算屋脊点 $R$**\n\n屋脊点 $R$ 是峰值计算吞吐率与内存带宽的比值。\n- 峰值性能 $P_{\\text{peak}} = 100 \\times 10^{9}$ FLOPS/s\n- 内存带宽 $B = 200 \\times 10^{9}$ bytes/s\n\n$$R = \\frac{P_{\\text{peak}}}{B} = \\frac{100 \\times 10^{9} \\text{ FLOPS/s}}{200 \\times 10^{9} \\text{ bytes/s}} = 0.5 \\text{ FLOPS/byte}$$\n\n**第二步：推导条带化策略的算术强度 $AI_{\\text{strip}}(s)$**\n\n算术强度 $AI$ 定义为总浮点运算次数与总内存传输字节数的比值。\n$$AI_{\\text{strip}}(s) = \\frac{\\text{总浮点运算次数}}{\\text{总内存传输字节数}}$$\n\n我们分析一个计算 $s \\times 1$ 个输出的条带分块：\n\n1.  **总浮点运算次数**：\n    该条带计算 $s$ 个输出点，每个点需要 $f=17$ 次浮点运算。\n    $$\\text{总浮点运算次数} = s \\times 17 = 17s$$\n\n2.  **总内存传输字节数**：\n    这是从主存加载的字节数和向主存存储的字节数之和。\n    -   **加载字节数**：为了计算一行中的 $s$ 个输出点（半径 $r=1$），需要加载一个 $3 \\times (s+2r) = 3 \\times (s+2)$ 的输入区域。每个元素是 $8$ 字节的双精度浮点数。\n        $$\\text{加载字节数} = 3 \\times (s+2) \\times 8 = 24(s+2) = 24s + 48 \\text{ 字节}$$\n    -   **存储字节数**：该条带计算并写回 $s$ 个输出点。\n        $$\\text{存储字节数} = s \\times 8 = 8s \\text{ 字节}$$\n    -   **总传输字节数** = 加载字节数 + 存储字节数\n        $$\\text{总内存传输字节数} = (24s + 48) + 8s = 32s + 48 \\text{ 字节}$$\n\n现在，我们可以写出算术强度的表达式：\n$$AI_{\\text{strip}}(s) = \\frac{17s}{32s + 48}$$\n\n**第三步：求解阈值宽度 $s$**\n\n我们将算术强度设为等于屋脊点 $R$，以找到临界宽度 $s$。\n$$AI_{\\text{strip}}(s) = R$$\n$$\\frac{17s}{32s + 48} = 0.5$$\n\n接下来，我们解这个关于 $s$ 的方程：\n$$17s = 0.5 \\times (32s + 48)$$\n$$17s = 16s + 24$$\n从等式两边减去 $16s$：\n$$s = 24$$\n\n因此，当条带宽度 $s$ 为 $24$ 时，该计算核心的算术强度恰好等于机器的屋脊点。对于任何大于 $24$ 的宽度，该核心将变为计算受限。因此，最小阈值宽度是 $24$。", "answer": "$$ \\boxed{24} $$", "id": "3653939"}]}