{"hands_on_practices": [{"introduction": "要掌握线性扫描寄存器分配，第一步是理解其核心机制。这个练习 [@problem_id:3650259] 将引导你在一小段直线代码上追踪该算法，通过确定每个临时变量的活动区间，并模拟分配器处理这些区间的过程，来计算避免溢出所需的最小寄存器数量 $k^{\\star}$。通过这个亲手实践，你将为分配器如何动态管理寄存器和应对寄存器压力建立起基本直觉。", "problem": "考虑一个直线中间表示（IR）块，其中临时变量 $t_{1}, t_{2}, \\dots, t_{11}$ 在标记为整数 $1, 2, \\dots, 12$ 的程序点被定义和使用。该 IR 如下：\n\n在程序点 $1$ 处：$t_{1} \\leftarrow a + b$。\n在程序点 $2$ 处：$t_{2} \\leftarrow t_{1} + c$。\n在程序点 $3$ 处：$t_{3} \\leftarrow t_{1} \\times t_{2}$。\n在程序点 $4$ 处：$t_{4} \\leftarrow t_{3} + d$。\n在程序点 $5$ 处：$t_{5} \\leftarrow t_{2} + t_{4}$。\n在程序点 $6$ 处：$t_{6} \\leftarrow t_{5} + e$。\n在程序点 $7$ 处：$t_{7} \\leftarrow t_{6} + t_{3}$。\n在程序点 $8$ 处：$t_{8} \\leftarrow t_{7} + t_{4}$。\n在程序点 $9$ 处：$t_{9} \\leftarrow t_{8} + t_{2}$。\n在程序点 $10$ 处：$t_{10} \\leftarrow t_{9} + t_{1}$。\n在程序点 $11$ 处：$t_{11} \\leftarrow t_{10} + t_{5}$。\n在程序点 $12$ 处：$\\text{out} \\leftarrow t_{11} + t_{6}$。\n\n假设在一个直线块中，活跃性（liveness）和活跃区间（live intervals）采用标准定义：临时变量 $t_{i}$ 的活跃区间是半开区间 $[s_{i}, e_{i})$，其中 $s_{i}$ 是 $t_{i}$ 被定义的索引，而 $e_{i}$ 是 $t_{i}$ 被使用的最大索引加一。\n\n应用线性扫描寄存器分配（Linear Scan Register Allocation, LSRA）。线性扫描寄存器分配（LSRA）按 $s_{i}$ 递增的顺序处理区间，维护一个按结束索引排序的活跃区间集合，在处理 $t_{i}$ 时，使任何满足 $e_{j} \\le s_{i}$ 的活跃区间 $j$ 过期，并且如果在 $t_i$ 的开始处（过期后），活跃集的大小为 $k$，它会执行一个溢出决策来保持寄存器中最多有 $k$ 个区间。假设每个临时变量在其整个活跃区间内都需要一个寄存器，并且忽略任何合并（coalescing）操作。\n\n你的任务：\n- 根据活跃性的基本原理，从 IR 中推导出活跃区间 $[s_{i}, e_{i})$。\n- 概念上跟踪 LSRA 遍历起始点 $s_{i}$ 的过程，并确定何时会根据 $k$ 的值发生溢出决策。\n- 最后，计算最小整数 $k^{\\star}$，使得在使用 LSRA 算法时，在该块中的任何位置都不会发生溢出决策。\n\n将你的最终答案表示为单个整数 $k^{\\star}$。无需四舍五入，也没有单位。你展示的计算过程可以包括指出对于特定的 $k$ 值，溢出将在何处发生，但最终答案必须仅为 $k^{\\star}$ 的值。", "solution": "目标是确定所需的最小整数寄存器数量，记为 $k^{\\star}$，以便使用线性扫描寄存器分配（LSRA）算法为给定的中间表示（IR）块中的所有临时变量分配寄存器，而无需任何溢出（spill）。\n\n首先，我们必须推导出每个临时变量 $t_i$ 的活跃区间。根据问题定义，活跃区间是一个半开区间 $[s_i, e_i)$，其中 $s_i$ 是 $t_i$ 被定义的程序点，而 $e_i$ 是 $t_i$ 被使用的最大程序点加一。\n\n我们分析 IR，以找出每个临时变量 $t_i$ 的定义点（$s_i$）和所有使用点。最后一次使用点决定了 $e_i$。\n\n- 对于 $t_1$：在 $s_1=1$ 处定义。在程序点 $2$、$3$ 和 $10$ 处使用。最后一次使用在程序点 $10$，因此 $e_1 = 10+1=11$。区间为 $[1, 11)$。\n- 对于 $t_2$：在 $s_2=2$ 处定义。在程序点 $3$、$5$ 和 $9$ 处使用。最后一次使用在程序点 $9$，因此 $e_2 = 9+1=10$。区间为 $[2, 10)$。\n- 对于 $t_3$：在 $s_3=3$ 处定义。在程序点 $4$ 和 $7$ 处使用。最后一次使用在程序点 $7$，因此 $e_3 = 7+1=8$。区间为 $[3, 8)$。\n- 对于 $t_4$：在 $s_4=4$ 处定义。在程序点 $5$ 和 $8$ 处使用。最后一次使用在程序点 $8$，因此 $e_4 = 8+1=9$。区间为 $[4, 9)$。\n- 对于 $t_5$：在 $s_5=5$ 处定义。在程序点 $6$ 和 $11$ 处使用。最后一次使用在程序点 $11$，因此 $e_5 = 11+1=12$。区间为 $[5, 12)$。\n- 对于 $t_6$：在 $s_6=6$ 处定义。在程序点 $7$ 和 $12$ 处使用。最后一次使用在程序点 $12$，因此 $e_6 = 12+1=13$。区间为 $[6, 13)$。\n- 对于 $t_7$：在 $s_7=7$ 处定义。唯一的使用在程序点 $8$。最后一次使用在程序点 $8$，因此 $e_7 = 8+1=9$。区间为 $[7, 9)$。\n- 对于 $t_8$：在 $s_8=8$ 处定义。唯一的使用在程序点 $9$。最后一次使用在程序点 $9$，因此 $e_8 = 9+1=10$。区间为 $[8, 10)$。\n- 对于 $t_9$：在 $s_9=9$ 处定义。唯一的使用在程序点 $10$。最后一次使用在程序点 $10$，因此 $e_9 = 10+1=11$。区间为 $[9, 11)$。\n- 对于 $t_{10}$：在 $s_{10}=10$ 处定义。唯一的使用在程序点 $11$。最后一次使用在程序点 $11$，因此 $e_{10} = 11+1=12$。区间为 $[10, 12)$。\n- 对于 $t_{11}$：在 $s_{11}=11$ 处定义。唯一的使用在程序点 $12$。最后一次使用在程序点 $12$，因此 $e_{11} = 12+1=13$。区间为 $[11, 13)$。\n\n接下来，我们应用 LSRA 算法。该算法按起始点 $s_i$ 排序来处理区间。为了在为新区间 $t_i$ 分配寄存器时避免溢出，可用寄存器的数量 $k$ 必须严格大于 `active` 集合中已有的区间数量（即那些已经开始但尚未结束的区间）。因此，所需的最小寄存器数量 $k^{\\star}$，比为新区间分配寄存器之前活跃区间数量的最大值多一。这等价于找出在程序中任意一点上同时重叠的活跃区间的最大数量。\n\n让我们跟踪 LSRA 的过程以及在分配每个新区间 $t_i$ 之前 `active` 集合的大小（记为 $|\\text{active}|$）。区间按 $t_1, t_2, \\ldots, t_{11}$ 的顺序处理。\n\n1.  处理 $t_1$（在 $s_1=1$ 开始）：`active` 集合为空。$|\\text{active}|=0$。需要 $k  0$。\n2.  处理 $t_2$（在 $s_2=2$ 开始）：没有区间过期。`active` 集合为 $\\{t_1\\}$。$|\\text{active}|=1$。需要 $k  1$。\n3.  处理 $t_3$（在 $s_3=3$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2\\}$。$|\\text{active}|=2$。需要 $k  2$。\n4.  处理 $t_4$（在 $s_4=4$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3\\}$。$|\\text{active}|=3$。需要 $k  3$。\n5.  处理 $t_5$（在 $s_5=5$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4\\}$。$|\\text{active}|=4$。需要 $k  4$。\n6.  处理 $t_6$（在 $s_6=6$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4, t_5\\}$。$|\\text{active}|=5$。需要 $k  5$。\n7.  处理 $t_7$（在 $s_7=7$ 开始）：没有区间过期。`active` 集合为 $\\{t_1, t_2, t_3, t_4, t_5, t_6\\}$。$|\\text{active}|=6$。为了无溢出地分配 $t_7$，我们需要 $k  6$。这确定了 $k^{\\star} \\ge 7$。分配后，`active` 集合的大小变为 $7$。\n8.  处理 $t_8$（在 $s_8=8$ 开始）：$t_3$ 的区间是 $[3, 8)$。由于 $e_3 = 8 \\le s_8=8$，它会过期并从 `active` 集合中移除。`active` 集合变为 $\\{t_1, t_2, t_4, t_5, t_6, t_7\\}$。$|\\text{active}|=6$。同样，为了无溢出地分配 $t_8$，我们需要 $k  6$。这证实了 $k^{\\star} \\ge 7$ 的要求。\n9.  处理 $t_9$（在 $s_9=9$ 开始）：$t_4$（$[4, 9)$）和 $t_7$（$[7, 9)$）的区间过期，因为 $e_4=9 \\le 9$ 和 $e_7=9 \\le 9$。`active` 集合变为 $\\{t_1, t_2, t_5, t_6, t_8\\}$。$|\\text{active}|=5$。这需要 $k  5$。\n10. 处理 $t_{10}$（在 $s_{10}=10$ 开始）：区间 $t_2$（$[2, 10)$）和 $t_8$（$[8, 10)$）过期。`active` 集合变为 $\\{t_1, t_5, t_6, t_9\\}$。$|\\text{active}|=4$。这需要 $k  4$。\n11. 处理 $t_{11}$（在 $s_{11}=11$ 开始）：区间 $t_1$（$[1, 11)$）和 $t_9$（$[9, 11)$）过期。`active` 集合变为 $\\{t_5, t_6, t_{10}\\}$。$|\\text{active}|=3$。这需要 $k  3$。\n\n遇到的最严格的要求是 $k  6$，这在处理 $t_7$ 和 $t_8$ 时出现。满足 $k  6$ 的最小整数 $k$ 是 $7$。\n\n或者，$k^{\\star}$ 是在任意程序点 $p$ 上同时活跃的区间的最大数量。让我们检查在程序点 $p=7$ 处的活跃区间数量：\n- $t_1: [1, 11)$ 在 $7$ 处是活跃的。\n- $t_2: [2, 10)$ 在 $7$ 处是活跃的。\n- $t_3: [3, 8)$ 在 $7$ 处是活跃的。\n- $t_4: [4, 9)$ 在 $7$ 处是活跃的。\n- $t_5: [5, 12)$ 在 $7$ 处是活跃的。\n- $t_6: [6, 13)$ 在 $7$ 处是活跃的。\n- $t_7: [7, 9)$ 在 $7$ 处是活跃的。\n所有七个区间 $\\{t_1, t_2, t_3, t_4, t_5, t_6, t_7\\}$ 在程序点 $7$ 处同时活跃。并发活跃的临时变量数量为 $7$。这个峰值压力决定了所需的最小寄存器数量。\n\n因此，为避免任何溢出所需的最小寄存器数量是 $7$。", "answer": "$$\\boxed{7}$$", "id": "3650259"}, {"introduction": "在理想情况下，我们有足够的寄存器。但现实中，当寄存器压力超过可用寄存器数量时，分配器必须将一些值“溢出”到内存中。这个练习 [@problem_id:3650266] 探讨了溢出启发式这一关键概念，要求你在一个给定的嵌套循环中，面对三个同时活跃但只有两个可用寄存器的窘境，通过分析不同溢出选择的动态代价，做出最优决策以最小化对程序性能的影响。", "problem": "一个编译器后端使用线性扫描寄存器分配，并在循环边界进行活跃范围分裂。考虑以下的三层嵌套循环和值的生命周期。在最内层循环中，有 $R=2$ 个可用的物理寄存器来存放三个同时活跃的值 $x$、$y$ 和 $s$。在最内层循环之外，只有 $x$ 可能是活跃的，并且没有额外的寄存器压力。\n\n程序结构如下，外层循环的迭代次数为 $N_{o}=100$，中层循环为 $N_{m}=50$，内层循环为 $N_{i}=20$：\n\n- 在每次外层循环迭代开始时，定义一次 $x$。值 $x$ 相对于中层和内层循环是循环不变的，并且在它们内部永不被重新定义。\n- 在每次中层循环迭代开始时，定义一次 $y$。值 $y$ 相对于内层循环是循环不变的，并且不在相关的中层循环迭代之外使用。\n- 在每次中层循环迭代开始时，定义一个累加器 $s$。然后，在每次内层循环迭代中：\n  - 使用一次 $x$ 和一次 $y$ 来计算对 $s$ 的更新。\n  - 每次内层循环迭代更新一次 $s$（因此 $s$ 在内层循环迭代之间是活跃的）。\n- 每次内层循环完成后，在中层循环体中有一次对 $x$ 的使用。中层循环完成后，在外层循环体中有对 $x$ 的最后一次使用。外层循环的最后一次使用可以重用在最后一个内层循环之后立即执行的任何 $x$ 的重载操作。\n\n只允许在最内层循环的入口和出口处分裂活跃范围。在内层循环中，由于 $x$、$y$ 和 $s$ 同时活跃且 $R=2$，必须从 $\\{x,y,s\\}$ 中选择一个值，在内层循环的整个持续时间内将其溢出。在内层循环之外，可以将 $x$ 保存在寄存器中，而没有额外的压力。\n\n动态溢出代价模型如下：\n\n- 每次执行的对溢出值的加载操作代价为 $1$，每次执行的对溢出值的存储操作代价为 $1$。总动态溢出代价 $C$ 是在所有迭代中执行的溢出加载和存储操作的总数。\n- 如果 $v \\in \\{x,y\\}$ 在其活跃范围内的任何点被溢出，那么在其循环级别定义之后，每次定义的循环迭代都会执行一次存储，以将其值存入内存。对于 $x$，这是每次外层循环迭代一次；对于 $y$，这是每次中层循环迭代一次。\n- 如果一个值在内层循环内被溢出，并且在某个给定的中层循环迭代的内层循环体中被使用了 $U$ 次，那么它对该中层循环迭代贡献 $U$ 次加载。\n- 如果 $x$ 在内层循环内被溢出，那么对于每次中层循环迭代，在内层循环完成后，需要一次加载才能在中层循环体中使用一次 $x$。在外层循环结束时对 $x$ 的最后一次使用会重用来自最后一次中层循环迭代的加载操作，不产生额外加载。\n- 如果 $s$ 在内层循环内未保存在寄存器中，那么每次内层循环迭代都会执行一次对 $s$ 的加载和一次对 $s$ 的存储。\n\n假设没有其他同时活跃的值，没有函数调用，也没有调用约定的影响。选择能最小化 $C$ 的内层循环分裂和溢出位置方案，并将最小的 $C$ 计算为一个精确的整数（内存操作的数量）。无需四舍五入。用一个数字表示你的最终答案。", "solution": "在尝试求解之前，必须首先验证问题陈述的科学合理性、完整性和客观性。\n\n**问题验证**\n\n**步骤1：提取已知条件**\n\n问题陈述中提供的明确数据、变量和条件如下：\n- **系统参数：**\n    - 寄存器分配算法：线性扫描，并在循环边界进行活跃范围分裂。\n    - 可用物理寄存器数量：$R=2$。\n    - 最内层循环中同时活跃的值：$x, y, s$。\n- **循环迭代次数：**\n    - 外层循环：$N_{o}=100$。\n    - 中层循环：$N_{m}=50$。\n    - 内层循环：$N_{i}=20$。\n- **值的生命周期和使用模式：**\n    - $x$：每次外层循环迭代定义一次。每次内层循环迭代使用一次，每次中层循环迭代（内层循环之后）使用一次。最后一次使用发生在中层循环最后一次迭代之后。\n    - $y$：每次中层循环迭代定义一次。每次内层循环迭代使用一次。\n    - $s$：每次中层循环迭代定义一次。每次内层循环迭代更新（读取和写入）一次。\n- **溢出策略：**\n    - 活跃范围只能在最内层循环的入口和出口处分裂。\n    - 必须从集合 $\\{x, y, s\\}$ 中指定一个值，在内层循环的整个持续时间内将其溢出。\n- **溢出代价模型：**\n    - 总动态溢出代价 $C$ 是因溢出而执行的所有加载和存储操作的总和。\n    - 每次加载或存储操作的代价为 $1$。\n    - 如果 $x$ 被溢出，则每次外层循环迭代执行一次存储（总共 $N_o$ 次）。\n    - 如果 $y$ 被溢出，则每次中层循环迭代执行一次存储（总共 $N_o \\times N_m$ 次）。\n    - 在内层循环中使用一个溢出值，每次使用的代价是 $1$ 次加载。\n    - 如果 $x$ 被溢出，其在中层循环体中的使用代价为每次中层循环迭代 $1$ 次加载。$x$ 的最后一次使用重用了最后一次加载，没有额外代价。\n    - 如果 $s$ 被溢出，内层循环中的每次更新代价为 $1$ 次加载和 $1$ 次存储。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据所需标准对问题进行评估：\n- **科学上成立：**该问题牢固地基于编译器设计的既定原则，特别是寄存器分配。线性扫描算法、活跃范围、溢出和代价模型是计算机科学中标准的、可形式化的概念。该场景是循环嵌套中寄存器压力超过可用寄存器的典型实例。\n- **良构性：**该问题提供了一个明确定义的状态、一组清晰的约束条件和一个要最小化的目标函数。可能的溢出选择集合是离散的（溢出 $x$、$y$ 或 $s$），并且每种选择的代价都可以根据给定数据计算得出。这确保了唯一且有意义的解的存在。\n- **客观性：**问题以精确、量化的术语陈述。所有操作、它们的频率和代价都得到了明确的定义。没有主观或基于意见的元素。\n- **完整性与一致性：**问题是自洽的。它提供了所有必要的迭代次数、使用频率和代价规则。约束条件是一致的；例如，有 $3$ 个活跃值（$x, y, s$）但只有 $2$ 个寄存器（$R=2$）的条件正确地确立了溢出其中一个值的必要性。\n\n**步骤3：结论与行动**\n\n问题是有效的。这是编译器原理领域内一个定义明确的优化问题。开始求解。\n\n**求解推导**\n\n任务是确定在最内层循环执行期间，应溢出三个值（$x$、$y$ 或 $s$）中的哪一个，以最小化总动态溢出代价 $C$。我们必须计算这三种互斥情况下的代价，并选择代价最小的一种。设这些代价分别为 $C_x$、$C_y$ 和 $C_s$。\n\n每个循环级别的总执行次数为：\n- 外层循环：$N_o = 100$ 次。\n- 中层循环：$N_o \\times N_m = 100 \\times 50 = 5000$ 次。\n- 内层循环：$N_o \\times N_m \\times N_i = 100 \\times 50 \\times 20 = 100000$ 次。\n\n**情况1：溢出值 $x$**\n\n如果溢出 $x$，产生的代价如下：\n1.  **初始存储：**每次定义 $x$ 时，会执行一次将其存储到其内存位置的操作。$x$ 在每次外层循环迭代中定义一次。\n    - 存储代价 = $N_o = 100$。\n2.  **内层循环加载：**$x$ 在每次内层循环迭代中使用一次。由于它被溢出，每次使用都需要一次加载。\n    - 内层循环加载代价 = $1 \\times (N_o \\times N_m \\times N_i) = 100000$。\n3.  **中层循环加载：**在内层循环完成后，$x$ 在中层循环体中使用一次。这发生在每次中层循环迭代中，并且需要一次加载。\n    - 中层循环加载代价 = $1 \\times (N_o \\times N_m) = 5000$。\n4.  **外层循环加载：**$x$ 的最后一次使用重用了最后一次中层循环迭代的加载操作，不产生额外代价。\n\n溢出 $x$ 的总代价 $C_x$ 是这些部分的总和：\n$$C_x = N_o + (N_o \\times N_m \\times N_i) + (N_o \\times N_m)$$\n$$C_x = 100 + (100 \\times 50 \\times 20) + (100 \\times 50) = 100 + 100000 + 5000 = 105100$$\n\n**情况2：溢出值 $y$**\n\n如果溢出 $y$，产生的代价如下：\n1.  **初始存储：**每次定义 $y$ 时，会执行一次存储操作。$y$ 在每次中层循环迭代中定义一次。\n    - 存储代价 = $N_o \\times N_m = 100 \\times 50 = 5000$。\n2.  **内层循环加载：**$y$ 在每次内层循环迭代中使用一次，每次都需要一次加载。\n    - 内层循环加载代价 = $1 \\times (N_o \\times N_m \\times N_i) = 100000$。\n值 $y$ 不在内层循环之外使用，因此没有其他溢出代价。\n\n溢出 $y$ 的总代价 $C_y$ 是这些部分的总和：\n$$C_y = (N_o \\times N_m) + (N_o \\times N_m \\times N_i)$$\n$$C_y = (100 \\times 50) + (100 \\times 50 \\times 20) = 5000 + 100000 = 105000$$\n\n**情况3：溢出值 $s$**\n\n如果累加器 $s$ 被溢出，代价模型规定内层循环中的每次更新都需要一次加载和一次存储。\n1.  **内层循环加载和存储：**$s$ 的值在每次内层循环迭代中更新一次。这包括加载旧值，计算新值，然后存储新值。\n    - 每次内层循环迭代的代价 = $1$ 次加载 + $1$ 次存储 = $2$。\n    - 总代价 = $2 \\times (N_o \\times N_m \\times N_i) = 2 \\times 100000 = 200000$。\n没有其他为溢出 $s$ 指定的代价。\n\n溢出 $s$ 的总代价 $C_s$ 是：\n$$C_s = 2 \\times N_o \\times N_m \\times N_i$$\n$$C_s = 2 \\times (100 \\times 50 \\times 20) = 2 \\times 100000 = 200000$$\n\n**比较与最终答案**\n\n我们比较这三种情况的总动态溢出代价：\n- $C_x = 105100$\n- $C_y = 105000$\n- $C_s = 200000$\n\n溢出值 $y$ 可获得最低代价。\n$$C_{min} = \\min(C_x, C_y, C_s) = \\min(105100, 105000, 200000) = 105000$$\n\n最小动态溢出代价是 $105000$。这个结果是通过在最内层循环中溢出值 $y$，同时将 $x$ 和 $s$ 保留在两个可用的寄存器中得到的。", "answer": "$$\\boxed{105000}$$", "id": "3650266"}, {"introduction": "当必须腾出寄存器时，溢出到内存并非唯一的选择。对于某些特定类型的值，例如可以由几条指令生成的常数，重新计算（或“重物质化”）它们可能比从内存中加载更高效。这个问题 [@problem_id:3650284] 引入了重物质化这一巧妙的优化，通过计算成本交叉点 $r^{\\ast}=\\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$，你将对内存访问与指令计算之间的权衡有一个定量的理解，这是现代编译器设计中的一个核心考量。", "problem": "考虑一个目标机器，它有 $R$ 个可分配的通用寄存器和一个线性扫描寄存器分配器。成本模型如下：每次内存访问（加载或存储）的成本为 $c_{\\text{mem}}$，每条算术/逻辑指令的成本为 $c_{\\text{alu}}$。假设所有内存访问的成本相同，为 $c_{\\text{mem}}$，所有算术/逻辑指令的成本也相同，为 $c_{\\text{alu}}$。\n\n给定以下直线型代码片段（伪汇编），其中一个 $32$-位立即数 $K$ 的常数具象化需要恰好 $t=2$ 条算术/逻辑指令（例如，一条高位立即数构建指令和一条立即数加法指令），并且 $K$ 在后面的 $U=5$ 个位置被使用：\n- 在程序点 $p_1$ 处，通过具象化常数 $K$ 定义了一个可重具象化的值 $k$（这个定义本身使用了程序语义中已有的算术/逻辑指令，不是可选的）。\n- 在 $p_1$ 和程序点 $p_2, p_3, p_4, p_5, p_6$ 之间，值 $k$ 被使用了恰好 $U=5$ 次，在这些点各使用一次。\n- 由于 $R=2$ 个可分配寄存器的寄存器压力以及其他临时变量（未显示）的活跃范围，线性扫描分配器必须在 $p_1$ 之后立即溢出 $k$；$k$ 无法在其所有使用点之间都驻留在寄存器中。\n\n考虑两种分配策略：\n1. 基准溢出策略：在 $p_1$ 处将 $k$ 存储到其溢出槽中，并在其 $U=5$ 次使用的每次之前立即从内存中重新加载 $k$。\n2. 重具象化策略：不在 $p_1$ 处存储 $k$，而是在其 $U=5$ 次使用的每次之前，通过每次使用 $t=2$ 条算术/逻辑指令重新具象化 $K$ 来重新计算 $k$。\n\n假设两种策略之间没有其他成本差异，并假设 $p_1$ 处的定义在两种策略中都必须存在，以便按程序语义要求初始计算 $k$。重具象化策略减少了内存流量，但增加了指令总数。\n\n将交叉点定义为比率 $r^{\\ast}=\\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$ 的值，在该值下，基准溢出策略的总成本等于重具象化策略的总成本。计算上述场景的 $r^{\\ast}$，并将最终答案表示为一个无单位的简化精确表达式。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是有效的。这是一个在编译器优化领域，特别是寄存器分配方面，定义良好的问题。所有必要的数据都已提供，目标明确且可形式化。\n\n目标是确定交叉点，该交叉点由比率 $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$ 定义，在该点上，基准溢出策略的总成本等于重具象化策略的总成本。设 $C_{\\text{spill}}$ 表示溢出策略产生的总额外成本，设 $C_{\\text{remat}}$ 表示重具象化策略的总额外成本。在程序点 $p_1$ 处值 $k$ 的初始定义成本对两种策略是共同的，因此在比较中予以排除。\n\n首先，我们分析基准溢出策略的成本 $C_{\\text{spill}}$。\n问题陈述指出，由于寄存器压力，值 $k$ 必须在其定义点 $p_1$ 之后立即溢出。这意味着分配器插入一条 `store` 指令，将 $k$ 的值从寄存器写入其在内存中的溢出槽。这个单一操作产生 $c_{\\text{mem}}$ 的成本。\n随后，在 $k$ 的 $U=5$ 次使用（在点 $p_2$ 到 $p_6$）的每次之前，该值必须从内存读回到寄存器中。这需要在每次使用前插入一条 `load` 指令。由于有 $U=5$ 次使用，这导致了 $U$ 次加载操作。这些加载的总成本是 $U \\times c_{\\text{mem}}$。\n溢出策略的总额外成本是初始存储成本和后续加载成本的总和：\n$$ C_{\\text{spill}} = 1 \\cdot c_{\\text{mem}} + U \\cdot c_{\\text{mem}} = (U+1) c_{\\text{mem}} $$\n鉴于使用次数为 $U=5$，成本为：\n$$ C_{\\text{spill}} = (5+1) c_{\\text{mem}} = 6 c_{\\text{mem}} $$\n\n接下来，我们分析重具象化策略的成本 $C_{\\text{remat}}$。\n在这种策略中，值 $k$ 在其定义点 $p_1$ 之后不会被存储到内存，因此没有 `store` 成本。取而代之的是，在每次使用前重新计算该值，而不是从内存中加载。\n值 $k$ 是通过具象化一个常数 $K$ 来定义的，这需要 $t=2$ 条算术/逻辑指令。这个重新计算过程在 $U=5$ 次使用的每一次之前都会执行。\n额外的算术/逻辑指令总数是使用次数与每次重具象化所需指令数的乘积，即 $U \\times t$。\n单条算术/逻辑指令的成本是 $c_{\\text{alu}}$。因此，重具象化策略的总额外成本是：\n$$ C_{\\text{remat}} = (U \\cdot t) \\cdot c_{\\text{alu}} $$\n给定值 $U=5$ 和 $t=2$，成本为：\n$$ C_{\\text{remat}} = (5 \\cdot 2) c_{\\text{alu}} = 10 c_{\\text{alu}} $$\n\n交叉点出现在两种策略的成本相等时：\n$$ C_{\\text{spill}} = C_{\\text{remat}} $$\n代入成本的推导表达式：\n$$ (U+1) c_{\\text{mem}} = (U \\cdot t) c_{\\text{alu}} $$\n题目要求我们求出比率 $r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}}$。我们可以通过重新整理方程来求得此值：\n$$ r^{\\ast} = \\frac{c_{\\text{mem}}}{c_{\\text{alu}}} = \\frac{U \\cdot t}{U+1} $$\n现在，我们将指定的数值 $U=5$ 和 $t=2$ 代入此表达式：\n$$ r^{\\ast} = \\frac{5 \\cdot 2}{5+1} = \\frac{10}{6} $$\n简化分数得到最终结果：\n$$ r^{\\ast} = \\frac{5}{3} $$\n该值表示内存访问成本与ALU操作成本的比率，在该比率下，两种策略的成本相等。", "answer": "$$\\boxed{\\frac{5}{3}}$$", "id": "3650284"}]}