{"hands_on_practices": [{"introduction": "这个首个练习将引导你完成 if-conversion 的核心过程。你将学习如何使用 $\\min$ 和 $\\max$ 等代数惯用法，将控制依赖转换为纯粹的数据流图。通过分析关键路径的延迟，你将具体理解这种转换如何减少执行时间，尤其是在支持微操作融合等功能的现代处理器上。", "problem": "考虑以下标量内核，该内核使用控制相关的更新来钳制和组合整数值：\n\n对于每个索引 $i$，\n- 令 $t \\leftarrow A[i] - B[i]$。\n- 如果 $t > \\mathrm{hi}$，则 $t \\leftarrow \\mathrm{hi}$。\n- 如果 $t < \\mathrm{lo}$，则 $t \\leftarrow \\mathrm{lo}$。\n- 如果 $t < C[i]$，则 $u \\leftarrow C[i]$，否则 $u \\leftarrow t$。\n- 令 $v \\leftarrow u + D[i]$。\n- 如果 $v < k$，则 $R[i] \\leftarrow v$，否则 $R[i] \\leftarrow k$。\n\n假设所有输入 $A[i]$、$B[i]$、$C[i]$、$D[i]$、$\\mathrm{lo}$、$\\mathrm{hi}$ 和 $k$ 在时间 $0$ 时均在寄存器中可用（无内存延迟），并且机器是一个理想的乱序执行核心，具有足够的发射宽度和资源，因此只有真数据依赖链决定生成 $R[i]$ 的延迟。编译器面向一个类似精简指令集计算 (RISC) 的指令集架构，并可能执行 if-转换，使用谓词执行来消除控制依赖。\n\n给定以下关于谓词执行和惯用法的基本定义和成本模型：\n- 谓词执行将每个控制相关的赋值转换为一个数据相关的操作，该操作使用由比较生成的谓词，例如条件移动（缩写为 conditional move (cmov)）或选择 (select)。\n- if-转换后的形式可以使用 min 和 max 代数惯用法来表示：$\\min(x, y)$ 和 $\\max(x, y)$，当条件和操作数的选择与惯用法模式匹配时，编译器会识别它们。\n- 延迟（寄存器到寄存器），单位为周期：\n  - 整数加法或减法：$L_{a} = 1$。\n  - 生成谓词的比较：$L_{c} = 1$。\n  - 消耗谓词的选择或条件移动：$L_{s} = 2$。\n  - 被识别时作为单条指令的融合 min 或 max 惯用法：$L_{mm} = 1$。\n- 微操作 (uop) 计数和融合机会：\n  - 整数加法或减法：$1$ 个 uop。\n  - 比较：$1$ 个 uop。\n  - 选择或条件移动：$1$ 个 uop。\n  - 识别的 min 或 max 惯用法：$1$ 个 uop（在适用时，这会替换 compare+select 对，将两个 uop 减少为一个）。\n  - 在原始的分支代码中，每个紧随条件分支的比较指令可以在前端宏融合成一个单一的融合 uop 以用于取指/发射，但这不改变真数据依赖链的延迟。if-转换后没有分支，因此分支宏融合不适用。\n\n任务：\n- 使用 min 和 max 惯用法重写内核（即，用 $\\min$ 和 $\\max$ 而不是控制流来表达），并通过 $\\min$ 和 $\\max$ 的定义以及谓词执行的语义来证明其正确性。\n- 在上述成本模型下，计算在以下两种 if-转换实现中，单次迭代生成 $R[i]$ 的关键路径数据依赖长度（单位为周期）：\n  - 实现 $\\mathcal{S}$：使用一个比较加一个选择来实现每个 $\\min$ 或 $\\max$（无惯用法识别）。每个 $\\min$ 或 $\\max$ 的数据依赖贡献是 $L_{c} + L_{s}$。\n  - 实现 $\\mathcal{M}$：将每个 $\\min$ 或 $\\max$ 实现为一个延迟为 $L_{mm}$ 的已识别融合惯用法指令（启用惯用法识别）。\n  在两种实现中，加法或减法使用 $L_{a}$，并假设所有输入在时间 $0$ 时都已就绪。\n- 量化实现 $\\mathcal{S}$ 和 $\\mathcal{M}$ 中每次迭代的 uop 数量，并简要解释 uop 融合机会与原始分支形式有何不同。\n- 最后，报告一个数字：在给定延迟下，实现 $\\mathcal{S}$ 和 $\\mathcal{M}$ 中每次迭代的最佳情况关键路径延迟（单位为周期）。\n\n在答案框中以整数周期数表示您的最终答案，不带单位或任何额外文本。", "solution": "该问题已经过验证，被认为是科学上合理的、问题定义明确且客观的。它为分析编译器优化及其在模型架构上的性能影响提供了一个清晰、独立且一致的场景。因此，下面提供完整的解决方案。\n\n该标量内核通过一系列涉及条件更新的操作来处理每个元素 $i$。为了分析其在 if-转换下的性能，我们首先使用 $\\min$ 和 $\\max$ 函数将控制相关的逻辑转换为数据流表示。这种转换基于谓词执行的语义，其中条件赋值被数据相关的选择所取代。\n\n对于索引 $i$，操作序列如下：\n1.  令 $t \\leftarrow A[i] - B[i]$。\n2.  如果 $t > \\mathrm{hi}$，则 $t \\leftarrow \\mathrm{hi}$。\n3.  如果 $t < \\mathrm{lo}$，则 $t \\leftarrow \\mathrm{lo}$。\n4.  如果 $t < C[i]$，则 $u \\leftarrow C[i]$，否则 $u \\leftarrow t$。\n5.  令 $v \\leftarrow u + D[i]$。\n6.  如果 $v < k$，则 $R[i] \\leftarrow v$，否则 $R[i] \\leftarrow k$。\n\n让我们将每个条件步骤转换为其等价的 `min`/`max` 形式：\n\n- 步骤 1：一个简单的减法。我们称结果为 $t_0$。\n    $t_0 \\leftarrow A[i] - B[i]$\n\n- 步骤 2：“如果 $t > \\mathrm{hi}$ 则 $t \\leftarrow \\mathrm{hi}$” 的作用是当 $t$ 的值超过 $\\mathrm{hi}$ 时将其设置为 $\\mathrm{hi}$，否则保持不变。这等同于取当前值和 $\\mathrm{hi}$ 的最小值。\n    $t_1 \\leftarrow \\min(t_0, \\mathrm{hi})$\n\n- 步骤 3：“如果 $t < \\mathrm{lo}$ 则 $t \\leftarrow \\mathrm{lo}$” 的作用是当 $t$ 的值小于 $\\mathrm{lo}$ 时将其设置为 $\\mathrm{lo}$，否则保持不变。这等同于取当前值和 $\\mathrm{lo}$ 的最大值。\n    $t_2 \\leftarrow \\max(t_1, \\mathrm{lo})$\n    步骤 2 和 3 的组合有效地将值 $t_0$ 钳制在范围 $[\\mathrm{lo}, \\mathrm{hi}]$ 内。\n\n- 步骤 4：“如果 $t < C[i]$ 则 $u \\leftarrow C[i]$ 否则 $u \\leftarrow t$” 选择了两个值 $t$ 和 $C[i]$ 中较大的一个。这是最大值函数的定义。\n    $u \\leftarrow \\max(t_2, C[i])$\n\n- 步骤 5：一个简单的加法。\n    $v \\leftarrow u + D[i]$\n\n- 步骤 6：“如果 $v < k$ 则 $R[i] \\leftarrow v$ 否则 $R[i] \\leftarrow k$” 选择了两个值 $v$ 和 $k$ 中较小的一个。这是最小值函数的定义。\n    $R[i] \\leftarrow \\min(v, k)$\n\n整个计算可以表示为一个数据流链：\n$t_0 \\leftarrow A[i] - B[i]$\n$t_1 \\leftarrow \\min(t_0, \\mathrm{hi})$\n$t_2 \\leftarrow \\max(t_1, \\mathrm{lo})$\n$u \\leftarrow \\max(t_2, C[i])$\n$v \\leftarrow u + D[i]$\n$R[i] \\leftarrow \\min(v, k)$\n\n由于所有输入 ($A[i]$、$B[i]$、$C[i]$、$D[i]$、$\\mathrm{lo}$、$\\mathrm{hi}$、$k$) 在时间 $0$ 时均可用，并且我们假设一个理想的乱序执行核心，因此关键路径延迟由最长的真数据依赖链决定。在这种情况下，计算构成了一个单一的线性依赖链。总延迟是此链中每个操作延迟的总和。\n\n给定的延迟如下：\n- 整数加法或减法：$L_{a} = 1$ 周期。\n- 比较：$L_{c} = 1$ 周期。\n- 选择/条件移动：$L_{s} = 2$ 周期。\n- 融合的 min/max 惯用法：$L_{mm} = 1$ 周期。\n\n我们现在计算两种指定实现的关键路径延迟。\n\n**实现 $\\mathcal{S}$ （无惯用法识别）**：每个 $\\min$ 或 $\\max$ 操作都实现为一个 `compare`（比较）后跟一个 `select`（选择）。这样一个序列的延迟是 $L_{c} + L_{s} = 1 + 2 = 3$ 个周期。\n\n1.  $t_0$ 在时间 $T(t_0) = 0 + L_a = 1$ 时就绪。\n2.  $t_1$ 依赖于 $t_0$。$T(t_1) = T(t_0) + (L_c + L_s) = 1 + 3 = 4$。\n3.  $t_2$ 依赖于 $t_1$。$T(t_2) = T(t_1) + (L_c + L_s) = 4 + 3 = 7$。\n4.  $u$ 依赖于 $t_2$。$T(u) = T(t_2) + (L_c + L_s) = 7 + 3 = 10$。\n5.  $v$ 依赖于 $u$。$T(v) = T(u) + L_a = 10 + 1 = 11$。\n6.  $R[i]$ 依赖于 $v$。$T(R[i]) = T(v) + (L_c + L_s) = 11 + 3 = 14$。\n\n实现 $\\mathcal{S}$ 的关键路径延迟是 $14$ 个周期。\n\n**实现 $\\mathcal{M}$ （有惯用法识别）**：每个 $\\min$ 或 $\\max$ 操作都实现为一个延迟为 $L_{mm} = 1$ 周期的单一融合指令。\n\n1.  $t_0$ 在时间 $T(t_0) = 0 + L_a = 1$ 时就绪。\n2.  $t_1$ 依赖于 $t_0$。$T(t_1) = T(t_0) + L_{mm} = 1 + 1 = 2$。\n3.  $t_2$ 依赖于 $t_1$。$T(t_2) = T(t_1) + L_{mm} = 2 + 1 = 3$。\n4.  $u$ 依赖于 $t_2$。$T(u) = T(t_2) + L_{mm} = 3 + 1 = 4$。\n5.  $v$ 依赖于 $u$。$T(v) = T(u) + L_{a} = 4 + 1 = 5$。\n6.  $R[i]$ 依赖于 $v$。$T(R[i]) = T(v) + L_{mm} = 5 + 1 = 6$。\n\n实现 $\\mathcal{M}$ 的关键路径延迟是 $6$ 个周期。\n\n接下来，我们量化每次迭代的微操作 (uops) 数量。该内核包含 $1$ 次减法、$1$ 次加法和 $4$ 次 min/max 操作。\n\n- 在实现 $\\mathcal{S}$ 中，每个 `min`/`max` 是一个 `compare`（$1$ uop）加上一个 `select`（$1$ uop），总共 $2$ 个 uop。\n  $\\mathcal{S}$ 的 uop 数量 = $1_{\\text{sub}} + 4 \\times (1_{\\text{cmp}} + 1_{\\text{sel}}) + 1_{\\text{add}} = 1 + 4 \\times 2 + 1 = 10$ 个 uop。\n\n- 在实现 $\\mathcal{M}$ 中，每个 `min`/`max` 是一个单一的融合指令（$1$ uop）。\n  $\\mathcal{M}$ 的 uop 数量 = $1_{\\text{sub}} + 4 \\times (1_{\\text{min/max}}) + 1_{\\text{add}} = 1 + 4 + 1 = 6$ 个 uop。\n\n原始分支代码和 if-转换形式之间的融合机会有很大不同。在原始代码中，主要的融合机会是*宏融合* (macro-fusion)，即一个 `compare` 指令和其后的 `conditional branch`（条件分支）在前端融合成一个单一的 uop 用于取指和译码。这会导致根据数据相关的执行路径，执行的 uop 数量是可变的。相比之下，在 if-转换的实现 $\\mathcal{M}$ 中，机会是*微操作融合* (micro-op fusion)（或指令选择期间的惯用法识别）。一个 `compare`-`select` 模式被一个单一的、专门的 `min` 或 `max` 指令所取代。这种融合对每个此类模式都会发生，导致执行的 uop 总数是固定的，并且在这种情况下更低（$\\mathcal{M}$ 为 $6$ 个 uop，而 $\\mathcal{S}$ 为 $10$ 个）。\n\n最后，最佳情况的关键路径延迟是为实现 $\\mathcal{S}$ 和 $\\mathcal{M}$ 计算的延迟中的最小值。\n最佳情况延迟 $= \\min(14, 6) = 6$ 个周期。", "answer": "$$\\boxed{6}$$", "id": "3663804"}, {"introduction": "在掌握了基本原理之后，这个实践将 if-conversion 置于一个实际应用场景中：为 SIMD（单指令，多数据）执行优化代码。你将建立一个性能模型，以比较传统的分支循环与其对应的谓词化 SIMD 版本，同时考虑分支预测错误的代价等因素。这个练习展示了消除分支对于释放数据并行硬件的全部潜力是何等重要。", "problem": "给定一个应用于图像的分支标量阈值循环。该图像表示为一个包含 $N$ 个像素的一维数组，其中每个像素是一个非负整数强度值。该标量循环将每个像素与一个阈值 $T$ 进行比较，并根据是否满足阈值条件向输出写入 $255$ 或 $0$。该分支标量循环的形式如下：对于每个索引 $i$，如果 $\\text{in}[i] \\ge T$，则 $\\text{out}[i] \\leftarrow 255$；否则 $\\text{out}[i] \\leftarrow 0$。要求您使用向量长度为 $VL$（每次向量操作处理的元素数量）的“单指令多数据”（SIMD）谓词执行来移植此计算，并计算谓词 SIMD 版本相对于分支标量版本的预期加速比。该加速比是阈值命中率 $r$（给定像素满足 $\\text{in}[i] \\ge T$ 的概率）和向量长度 $VL$ 的函数。\n\n本问题的基本依据包括以下经过充分验证的事实和定义：\n- 一个随机变量的期望值是其所有可能值的概率加权平均值。如果一个概率为 $r$ 的事件产生代价 $P$，否则代价为 $0$，那么预期的额外代价是 $r \\cdot P$。\n- 在一个以处理器周期为单位的简单成本模型中，一条指令有关联的周期成本。一个循环的总周期是其组成操作周期的总和。对于每个元素的预期成本，当对 $N$ 个独立元素进行聚合时，需除以 $N$。\n- 谓词 SIMD 用掩码计算和选择操作替换分支，这些操作对 $VL$ 个元素步调一致地执行，使得每个元素的成本等于每个向量的成本除以 $VL$。\n\n假设采用以下以周期为单位的成本模型，该模型对于现代乱序超标量处理器是科学上可信的：\n- 对于分支标量循环，每个元素产生一个基本成本，该成本等于加载成本 $c_{\\text{ld}}$、比较成本 $c_{\\text{cmp}}$、存储成本 $c_{\\text{st}}$ 和分支解析开销 $c_{\\text{br}}$ 的总和。此外，对于意外的已执行分支，会产生一个分支误预测惩罚 $P$。在一个静态“预测不执行”的预测器模型下，满足阈值的像素被视为“已执行”，其概率为 $r$，并预期会产生惩罚 $P$。因此，标量分支循环的每个元素的预期成本是基本成本加上 $r \\cdot P$。\n- 对于谓词 SIMD 循环，对于每个包含 $VL$ 个元素的向量，有一次成本为 $C_{\\text{vld}}$ 的向量加载，一次成本为 $C_{\\text{vcmp}}$ 的向量比较，一次成本为 $C_{\\text{vblend}}$ 的向量混合/选择，以及一次成本为 $C_{\\text{vst}}$ 的向量存储。没有数据相关的分支成本。SIMD 版本的每个元素的成本是这些每个向量的成本之和除以 $VL$。\n\n您的任务是：\n1. 使用上述基本事实，推导分支标量循环的每个元素的预期成本，作为 $r$ 的函数。除了基本事实所暗示的公式外，不要使用任何快捷公式。\n2. 使用上述基本事实，推导谓词 SIMD 循环的每个元素的成本，作为 $VL$ 的函数。\n3. 将加速比 $S(r, VL)$ 定义为标量每个元素的预期成本与谓词 SIMD 每个元素的成本之比。\n4. 使用 C 语言（标准 $C23$）实现一个程序，使用给定的常数计算下面指定的测试套件中每个测试用例的 $S(r, VL)$。程序必须生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个加速比值必须打印为四舍五入到六位小数的浮点数。\n\n在您的模型中使用的常数：\n- 每个元素的标量成本：$c_{\\text{ld}} = 1$，$c_{\\text{cmp}} = 1$，$c_{\\text{st}} = 1$，$c_{\\text{br}} = 1$，以及分支误预测惩罚 $P = 15$。\n- 每个向量的谓词 SIMD 成本：$C_{\\text{vld}} = 3$，$C_{\\text{vcmp}} = 3$，$C_{\\text{vblend}} = 3$，$C_{\\text{vst}} = 3$。\n\n测试套件（每个用例是一对 $(r, VL)$）：\n- 用例 $1$：$r = 0$，$VL = 4$。\n- 用例 $2$：$r = 0.5$，$VL = 4$。\n- 用例 $3$：$r = 1.0$，$VL = 4$。\n- 用例 $4$：$r = 0.1$，$VL = 8$。\n- 用例 $5$：$r = 0.9$，$VL = 8$。\n- 用例 $6$：$r = 0.5$，$VL = 1$。\n- 用例 $7$：$r = 0.5$，$VL = 16$。\n- 用例 $8$：$r = 0.2$，$VL = 16$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如 $[x_1,x_2,\\dots,x_8]$，其中每个 $x_i$ 是为用例 $i$ 计算并四舍五入到六位小数的加速比。不应打印任何额外文本。", "solution": "我们首先根据所述的期望值和指令成本聚合的基本原则，在每个元素和每个向量的成本层面上，形式化分支标量和谓词单指令多数据（SIMD）版本的阈值循环。\n\n对于分支标量循环，考虑一个元素。无论分支结果如何，所涉及的操作都包括一次加载、一次比较、一次存储以及解析分支指令。设每个元素的周期成本分别为 $c_{\\text{ld}}$、$c_{\\text{cmp}}$、$c_{\\text{st}}$ 和 $c_{\\text{br}}$。在一个静态“预测不执行”的分支预测器下，分支默认被预测为不执行。当条件为真时，分支变为已执行状态并被误预测。如果我们将一个元素满足阈值的概率表示为 $r$（阈值命中率），那么误预测事件发生的概率为 $r$。设误预测惩罚为 $P$ 个周期。根据期望值的定义，由误预测引起的预期额外成本为 $r \\cdot P$。因此，标量分支循环的每个元素的预期成本是\n$$\nC_{\\text{branch}}(r) = c_{\\text{ld}} + c_{\\text{cmp}} + c_{\\text{st}} + c_{\\text{br}} + r \\cdot P.\n$$\n使用提供的常数 $c_{\\text{ld}} = 1$、$c_{\\text{cmp}} = 1$、$c_{\\text{st}} = 1$、$c_{\\text{br}} = 1$ 和 $P = 15$，这在数值上简化为\n$$\nC_{\\text{branch}}(r) = 1 + 1 + 1 + 1 + 15 r = 4 + 15 r.\n$$\n\n对于谓词 SIMD 循环，谓词执行用掩码计算和选择（混合）操作替换了分支，这些操作一次性作用于 $VL$ 个元素。每个向量的操作包括一次向量加载、一次向量比较、一次向量混合/选择以及一次向量存储。设它们每个向量的周期成本分别为 $C_{\\text{vld}}$、$C_{\\text{vcmp}}$、$C_{\\text{vblend}}$ 和 $C_{\\text{vst}}$。由于在谓词执行下这些成本不依赖于数据，因此每个向量的总成本是\n$$\nC_{\\text{SIMD,vector}} = C_{\\text{vld}} + C_{\\text{vcmp}} + C_{\\text{vblend}} + C_{\\text{vst}}.\n$$\n为了得到每个元素的成本，将每个向量的成本除以每个向量处理的元素数量 $VL$，得到\n$$\nC_{\\text{SIMD,elem}}(VL) = \\frac{C_{\\text{vld}} + C_{\\text{vcmp}} + C_{\\text{vblend}} + C_{\\text{vst}}}{VL}.\n$$\n使用提供的常数 $C_{\\text{vld}} = 3$、$C_{\\text{vcmp}} = 3$、$C_{\\text{vblend}} = 3$ 和 $C_{\\text{vst}} = 3$，我们得到\n$$\nC_{\\text{SIMD,elem}}(VL) = \\frac{3 + 3 + 3 + 3}{VL} = \\frac{12}{VL}.\n$$\n\n将加速比 $S(r, VL)$ 定义为标量每个元素的预期成本与谓词 SIMD 每个元素的成本之比，即\n$$\nS(r, VL) = \\frac{C_{\\text{branch}}(r)}{C_{\\text{SIMD,elem}}(VL)}.\n$$\n代入上面推导出的表达式，\n$$\nS(r, VL) = \\frac{4 + 15 r}{12 / VL} = \\left(4 + 15 r\\right) \\cdot \\frac{VL}{12}.\n$$\n\n在算法上，程序必须为每个测试用例 $(r, VL)$ 实现以下步骤：\n1. 使用 $C_{\\text{branch}}(r) = 4 + 15 r$ 计算 $C_{\\text{branch}}(r)$。\n2. 使用 $C_{\\text{SIMD,elem}}(VL) = 12 / VL$ 计算 $C_{\\text{SIMD,elem}}(VL)$。\n3. 计算 $S(r, VL)$ 为 $C_{\\text{branch}}(r) / C_{\\text{SIMD,elem}}(VL)$。\n4. 打印结果 $S(r, VL)$，四舍五入到六位小数。\n\n我们现在评估指定的测试套件：\n- 用例 1：$r = 0$，$VL = 4$。$C_{\\text{branch}}(0) = 4 + 15 \\cdot 0 = 4$。$C_{\\text{SIMD,elem}}(4) = 12 / 4 = 3$。$S(0,4) = 4 / 3 = 1.\\overline{3}$，四舍五入到六位小数为 $1.333333$。\n- 用例 2：$r = 0.5$，$VL = 4$。$C_{\\text{branch}}(0.5) = 4 + 15 \\cdot 0.5 = 11.5$。$C_{\\text{SIMD,elem}}(4) = 3$。$S(0.5,4) = 11.5 / 3 \\approx 3.833333$。\n- 用例 3：$r = 1.0$，$VL = 4$。$C_{\\text{branch}}(1.0) = 4 + 15 = 19$。$C_{\\text{SIMD,elem}}(4) = 3$。$S(1.0,4) = 19 / 3 \\approx 6.333333$。\n- 用例 4：$r = 0.1$，$VL = 8$。$C_{\\text{branch}}(0.1) = 4 + 1.5 = 5.5$。$C_{\\text{SIMD,elem}}(8) = 12 / 8 = 1.5$。$S(0.1,8) = 5.5 / 1.5 \\approx 3.666667$。\n- 用例 5：$r = 0.9$，$VL = 8$。$C_{\\text{branch}}(0.9) = 4 + 13.5 = 17.5$。$C_{\\text{SIMD,elem}}(8) = 1.5$。$S(0.9,8) = 17.5 / 1.5 \\approx 11.666667$。\n- 用例 6：$r = 0.5$，$VL = 1$。$C_{\\text{branch}}(0.5) = 11.5$。$C_{\\text{SIMD,elem}}(1) = 12$。$S(0.5,1) = 11.5 / 12 \\approx 0.958333$。\n- 用例 7：$r = 0.5$，$VL = 16$。$C_{\\text{SIMD,elem}}(16) = 12 / 16 = 0.75$。$S(0.5,16) = 11.5 / 0.75 \\approx 15.333333$。\n- 用例 8：$r = 0.2$，$VL = 16$。$C_{\\text{branch}}(0.2) = 4 + 3 = 7$。$C_{\\text{SIMD,elem}}(16) = 0.75$。$S(0.2,16) = 7 / 0.75 \\approx 9.333333$。\n\n程序将计算这些值，并将它们以单个方括号括起来的、逗号分隔的列表形式打印出来，每个值都四舍五入到六位小数。", "answer": "```c\n#include <stdio.h>\n\nint main() {\n    double r_cases[] = {0.0, 0.5, 1.0, 0.1, 0.9, 0.5, 0.5, 0.2};\n    int vl_cases[] = {4, 4, 4, 8, 8, 1, 16, 16};\n    int num_cases = sizeof(r_cases) / sizeof(r_cases[0]);\n\n    printf(\"[\");\n    for (int i = 0; i  num_cases; ++i) {\n        double r = r_cases[i];\n        double vl = (double)vl_cases[i];\n        \n        double speedup = (4.0 + 15.0 * r) * vl / 12.0;\n        \n        printf(\"%.6f\", speedup);\n        if (i  num_cases - 1) {\n            printf(\",\");\n        }\n    }\n    printf(\"]\\n\");\n\n    return 0;\n}\n```", "id": "3663829"}, {"introduction": "虽然 if-conversion 是一项强大的优化技术，但它并非普遍适用，编译器在应用时必须格外小心。最后一个练习将挑战你思考一个关键的边界情况：if-conversion 与未定义行为（Undefined Behavior, UB）之间的相互作用。通过分析一个推测执行路径可能引发致命错误的场景，你将理解编译器转换、语言语义和硬件行为之间的深层联系，并认识到为什么正确性必须始终是首要考虑的问题。", "problem": "执行if转换的编译器使用谓词执行将控制依赖替换为数据依赖。考虑以下C函数，其编写风格旨在避免显式的数字字面量，同时在不评估未定义行为（UB）的执行上保持现实和良定义：\n\n\nint g(int *p, int r) {\n    if (p) {\n        return *p;\n    } else {\n        return r / (r - r);\n    }\n}\n\n\n假设一个典型的优化编译器，用于像C这样具有未定义行为（UB）语义的语言，以及一个可能支持也可能不支持故障抑制谓词指令的目标架构。编译器希望对该分支进行if转换，通过使两个分支臂表现为一个谓词块或通过选择传递值的方式，来提高指令级并行性。您的任务是根据第一性原理（源语言语义和程序转换的as-if规则、架构性谓词语义，以及可能引发陷阱的操作的定义）来推理，当UB仅存在于某些输入的未执行路径上时，此类转换的合法性和风险。特别是，分析当原始控制流不会执行UB路径时，一种推测性执行两个分支臂的转换可能会新暴露该UB路径的风险。\n\n下列哪个陈述是正确的？选择所有适用项。\n\nA. 在任何目标上，将分支重写为急切计算两个分支臂，并使用条件移动或选择指令来挑选最终结果，是语义保持的，因为未使用的结果在影响程序之前被丢弃了。\n\nB. 如果目标架构的谓词执行保证了谓词为假的谓词指令既不评估其操作数也不引发异常，那么用条件的否定来保护除法操作，可以使得if转换对于原始程序未执行UB的输入是语义保持的。\n\nC. 即使未执行的路径包含UB，只要原始控制流阻止了其在给定输入上的执行，编译器就不能引入一个转换，使得该行为在这些输入上变得可观察；as-if规则要求在有定义行为的执行上保持行为不变。\n\nD. 因为UB给予编译器不受限制的自由，它可以在原始程序中假设分母表达式永远不等于$0$并折叠掉该除法，这使得if转换总是安全的，无论该除法是否会被执行。", "solution": "该问题要求分析对一个C函数应用if转换的合法性，该函数包含一个分支，其中一条路径表现出未定义行为（UB）。需要应用的核心原则是C语言的`as-if`规则、UB的语义，以及在各种硬件架构上推测性执行的行为。\n\n### 步骤 1：问题验证\n\n问题陈述是有效的。它展示了一个良定义的C函数：\n```c\nint g(int *p, int r) {\n    if (p) {\n        return *p;\n    } else {\n        return r / (r - r);\n    }\n}\n```\n问题正确地指出了关键要素：一个条件分支，一个良定义的路径（`if (p)`为真），以及一个带有未定义行为的路径（`else`分支，其中包含`r / (r - r)`）。除法 `r / (r - r)` 简化为 `r / 0`。在C标准中，整数除以零被明确定义为UB。问题关注的是在这种背景下，if转换（一种标准的编译器优化）的合法性。这是一个编译器设计中经典的、不简单的问题，需要理解语言语义和硬件现实之间的相互作用。该问题具有科学依据，提法恰当，且是客观的。\n\n### 步骤 2：从第一性原理推导\n\n编译器转换的指导原则是 **as-if规则**。该规则规定，只要转换后程序的可观察行为与原始程序在所有具有确定行为的执行上的可观察行为相同，编译器就可以执行任何转换。可观察行为包括程序终止、I/O以及对`volatile`变量的访问。崩溃或硬件异常构成了一种可观察行为。\n\n我们来分析原始函数`g(p, r)`的行为：\n1.  **情况：`p`不为`NULL`**。条件`if (p)`求值为真。函数执行`return *p;`。假设`p`指向一个有效的`int`，这个执行路径是良定义的。包含除零操作的`else`块永远不会被执行。可观察的行为是函数返回`p`所指向的值。\n2.  **情况：`p`为`NULL`**。条件`if (p)`求值为假。函数尝试执行`return r / (r - r);`。表达式`r - r`保证为$0$。C标准规定有符号整数除以零导致未定义行为。在这种情况下，标准对程序的行为没有任何要求。\n\n**if转换变换：**\nif转换旨在移除控制依赖（`if`语句），并用数据依赖取而代之。这种转换的一般形式涉及推测性地执行两个分支，然后选择正确的结果。对于函数`g`，这在概念上等同于：\n\n```\n// if转换的概念表示\nbool condition = (p != NULL);\nint value_if_true = *p;\nint value_if_false = r / (r - r); // 推测性执行UB路径\nint result = select(condition, value_if_true, value_if_false);\nreturn result;\n```\n\n关键问题出现在`p`不为`NULL`时。在原始程序中，这是一个良定义的执行。在转换后的程序中，表达式`value_if_false = r / (r - r);`总是被求值。在大多数常见的处理器架构（例如x86，A32/T32模式下的ARM）上，整数除零指令会触发硬件异常（陷阱）。这个陷阱通常会导致操作系统终止程序（例如，在类Unix系统上产生`SIGFPE`信号）。\n\n因此，对于一个良定义的输入（`p != NULL`），原始程序返回一个值，而简单转换后的程序会崩溃。这是可观察行为的改变，根据`as-if`规则，这种转换是**非法的**。\n\n### 步骤 3：逐项分析\n\n**A. 在任何目标上，将分支重写为急切计算两个分支臂，并使用条件移动或选择指令来挑选最终结果，是语义保持的，因为未使用的结果在影响程序之前被丢弃了。**\n\n这个陈述是**不正确的**。其推理存在缺陷。它关注的是计算的*结果*被丢弃，但忽略了计算本身的*副作用*。计算`r / 0`的行为可能产生一个可观察的副作用，即导致程序终止的陷阱。这个陷阱发生在推测性执行期间，远在结果可能被“丢弃”之前。如上文分析所示，在一个对除零操作产生陷阱的典型目标架构上，这种转换改变了程序在良定义输入（`p != NULL`时）上的行为，违反了as-if规则。因此，它在“任何目标上”都不是语义保持的。\n\n**B. 如果目标架构的谓词执行保证了谓词为假的谓词指令既不评估其操作数也不引发异常，那么用条件的否定来保护除法操作，可以使得if转换对于原始程序未执行UB的输入是语义保持的。**\n\n这个陈述是**正确的**。它描述了一种特定的架构特性，称为**故障抑制谓词执行**（例如，在英特尔的Itanium架构中是一个显著特性）。转换在概念上如下所示：\n\n1.  设谓词`P`在`p != NULL`时为真，否则为假。\n2.  计算`then`分支的值：`value_if_true = *p;`。这是安全的，因为它只需要在`P`为真时是正确的。\n3.  `else`分支的计算由否定的谓词`!P`保护：`if (!P) value_if_false = r / 0;`\n4.  最终的`select`或条件移动指令选择结果。\n\n关键在于，用于`value_if_false = r / 0`的硬件指令将是一个谓词指令。当`p != NULL`时，谓词`!P`为假。选项中指定的架构保证意味着，这个带谓词的除零指令变成了一个空操作（no-op）；它不访问其操作数，并且关键的是，不引发故障。因此，对于良定义的情况（`p != NULL`），转换后的代码不会产生陷阱，并能正确地从`then`分支产生结果，保持了原始程序的行为。对于UB的情况（`p == NULL`），转换后的代码可能会也可能不会产生陷阱，这与原始程序的UB是一致的。因此，该转换是语义保持的。\n\n**C. 即使未执行的路径包含UB，只要原始控制流阻止了其在给定输入上的执行，编译器就不能引入一个转换，使得该行为在这些输入上变得可观察；as-if规则要求在有定义行为的执行上保持行为不变。**\n\n这个陈述是**正确的**。这是`as-if`规则应用于此场景的精确而准确的陈述。\n-   “未执行的路径包含UB”：这是`p != NULL`时的`else`分支。\n-   “原始控制流阻止了其执行”：`if (p)`检查确保了这一点。\n-   “编译器就不能引入一个转换，使得该行为在这些输入上变得可观察”：在一个先前良定义的执行路径上引入陷阱（一种可观察行为）是非法的。\n-   “as-if规则要求在有定义行为的执行上保持行为不变”：这是形式化的理由。\n\n这个陈述正确地指出了使得朴素的if转换在这种情况下非法的根本性约束。\n\n**D. 因为UB给予编译器不受限制的自由，它可以在原始程序中假设分母表达式永远不等于$0$并折叠掉该除法，这使得if转换总是安全的，无论该除法是否会被执行。**\n\n这个陈述是**不正确的**。关于UB的推理虽然微妙但有根本性的缺陷。当编译器遇到会产生UB的代码时，它被允许假设在任何良定义的程序路径上，这样的代码**永远不会被执行**。在这种情况下，`r / (r - r)`操作仅在`p`为`NULL`时执行。因此，编译器被允许假设对于任何良定义的执行，`p`永远不为`NULL`。这可能允许编译器完全消除`else`分支，并将函数简化为`return *p;`。然而，该选项声称编译器可以“假设分母表达式永远不等于$0$”。分母是`r - r`。这是一个数学上和逻辑上的确定事实，即`r - r`为`0`。编译器的推理虽然强大，但不能基于假设逻辑矛盾（如`$0 \\ne 0$`）来进行。编译器是基于程序状态（`p != NULL`）进行推理，而不是违反算术公理。因为该选项中推理的前提是不成立的，所以结论是无效的。", "answer": "$$\\boxed{BC}$$", "id": "3663865"}]}