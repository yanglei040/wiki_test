{"hands_on_practices": [{"introduction": "要真正理解模调度，最好的方法莫过于观察其执行时的节律性。这个练习将问题反转：你不是去创建一个调度，而是要分析一个真实的执行轨迹，从中发现其固有的节奏——启动间隔（$II$）。通过这种“逆向工程”的方法[@problem_id:3658362]，你将以一种具体、可触的方式，牢固掌握$II$的根本定义。", "problem": "给定一个在模调度（modulo scheduling）下由软件流水（software-pipelined）循环产生的稳态硬件发射追踪。在每次循环迭代中，会精确执行一次加载（load）、一次乘法（multiply）和一次加法（add）操作，分别表示为 $\\mathrm{L}$、$\\mathrm{M}$ 和 $\\mathrm{A}$。该模调度的启动间隔（Initiation Interval, II）是未知的。根据定义，启动间隔（II）是在稳态下，连续两次迭代中对应操作的发射时间之间的恒定周期数。在核心（kernel，即重复的稳态模式）中，每个操作都有一个固定的、模 $II$ 的核心偏移量。\n\n在周期窗口 $t \\in [\\,1, 35\\,]$ 内观察到带有时间戳的已发射操作追踪。该追踪（按操作类型分组）如下：\n- $\\mathrm{L}$ 在以下周期发射：$ \\{\\, 1, 6, 11, 16, 21, 26, 31 \\,\\}$。\n- $\\mathrm{M}$ 在以下周期发射：$ \\{\\, 3, 8, 13, 18, 23, 28, 33 \\,\\}$。\n- $\\mathrm{A}$ 在以下周期发射：$ \\{\\, 4, 9, 14, 19, 24, 29, 34 \\,\\}$。\n\n假设：\n- 所列窗口位于循环的稳态内（忽略 $[\\,1, 35\\,]$ 之外的任何前导或后继部分）。\n- 机器每个周期最多只能发射每种操作类型的一个实例，且给定的时间是发射时间（而非完成时间）。\n- 在该窗口内的追踪中没有丢失或多余的记录。\n\n任务：\n- 根据第一性原理，通过检测连续迭代中相应操作出现的周期性，推断出启动间隔 $II$。\n- 利用观察到的周期性结构，重构操作 $\\mathrm{L}$、$\\mathrm{M}$ 和 $\\mathrm{A}$ 的核心偏移量 $o_{\\mathrm{L}}$、$o_{\\mathrm{M}}$ 和 $o_{\\mathrm{A}}$（模 $II$）。\n\n仅报告 $II$ 的值作为你的最终答案。请以精确整数形式表示，无需四舍五入。", "solution": "对问题陈述进行严格评估后，认定其有效。该问题在科学上基于编译器理论和计算机体系结构的原理，特别是针对流水线处理器的指令调度。问题提法恰当、客观，并包含充足且一致的数据以确定唯一解。\n\n解决此问题的核心原理是在模调度背景下启动间隔（$II$）的定义。对于处于稳态的循环，II 是连续循环迭代中相应操作的发射时间之间相隔的恒定数量的时钟周期。设 $t_{op, i}$ 表示特定操作类型 $op$ 在第 $i$ 次迭代中的发射时间。那么，对于任意两个连续的迭代 $i$ 和 $i+1$，其关系如下：\n$$t_{op, i+1} = t_{op, i} + II$$\n这意味着对于任何给定的操作类型，其发射时间序列必须构成一个公差等于启动间隔 $II$ 的等差数列。我们现在将分析为每种操作类型提供的带时间戳的追踪，以确定这个公共周期。\n\n首先，我们检查加载操作 $\\mathrm{L}$ 的发射时间。观察到的发射时间集合是：\n$$T_{\\mathrm{L}} = \\{1, 6, 11, 16, 21, 26, 31\\}$$\n我们计算此序列中连续时间戳之间的差值：\n$6 - 1 = 5$\n$11 - 6 = 5$\n$16 - 11 = 5$\n$21 - 16 = 5$\n$26 - 21 = 5$\n$31 - 26 = 5$\n差值是恒定的，等于 $5$。根据启动间隔的定义，这个公差代表了 $II$ 的值。因此，从操作 $\\mathrm{L}$ 的追踪中，我们推断出 $II = 5$。\n\n接下来，我们对乘法操作 $\\mathrm{M}$ 进行同样的分析。观察到的发射时间集合是：\n$$T_{\\mathrm{M}} = \\{3, 8, 13, 18, 23, 28, 33\\}$$\n我们计算连续时间戳之间的差值：\n$8 - 3 = 5$\n$13 - 8 = 5$\n$18 - 13 = 5$\n$23 - 18 = 5$\n$28 - 23 = 5$\n$33 - 28 = 5$\n差值同样是恒定的，等于 $5$。这个结果与对操作 $\\mathrm{L}$ 的分析一致，并独立地确认了 $II = 5$。\n\n最后，我们分析加法操作 $\\mathrm{A}$ 的发射时间。观察到的发射时间集合是：\n$$T_{\\mathrm{A}} = \\{4, 9, 14, 19, 24, 29, 34\\}$$\n我们计算连续时间戳之间的差值：\n$9 - 4 = 5$\n$14 - 9 = 5$\n$19 - 14 = 5$\n$24 - 19 = 5$\n$29 - 24 = 5$\n$34 - 29 = 5$\n差值再次为恒定的 $5$。操作 $\\mathrm{A}$ 的追踪提供了第三个一致的验证，即启动间隔为 $II = 5$。\n\n通过对所有三种操作类型的周期性行为进行严格分析，并发现它们有一致的 $5$ 个周期的周期，我们得出结论，启动间隔是 $II = 5$。\n\n问题还要求重构核心偏移量，表示为 $o_{\\mathrm{L}}$、$o_{\\mathrm{M}}$ 和 $o_{\\mathrm{A}}$。一个操作的核心偏移量是其发射时间模启动间隔，即 $o_{op} = t_{op} \\pmod{II}$。我们可以使用相应追踪中的任意一个发射时间。\n对于加载操作 $\\mathrm{L}$，使用第一个发射时间 $t=1$：\n$$o_{\\mathrm{L}} = 1 \\pmod{5} = 1$$\n对于乘法操作 $\\mathrm{M}$，使用第一个发射时间 $t=3$：\n$$o_{\\mathrm{M}} = 3 \\pmod{5} = 3$$\n对于加法操作 $\\mathrm{A}$，使用第一个发射时间 $t=4$：\n$$o_{\\mathrm{A}} = 4 \\pmod{5} = 4$$\n重构后的核心包含操作 $\\mathrm{L}$、$\\mathrm{M}$ 和 $\\mathrm{A}$，它们在每个重复的 $II=5$ 个周期的间隔内，分别在周期 $1$、$3$ 和 $4$ 发射。\n\n要求的最终答案是启动间隔 $II$ 的值。", "answer": "$$\\boxed{5}$$", "id": "3658362"}, {"introduction": "在理解了启动间隔的概念后，下一步是掌握编译器的核心任务：从循环代码和机器限制中确定最佳的$II$。本练习[@problem_id:3658402]将指导你计算两个基本的下界——资源限制的最小启动间隔（$ResMII$）和递推限制的最小启动间隔（$RecMII$）。你将综合这两个约束，构建一个无冲突的有效调度方案，从而将理论计算与指令放置的实践相结合。", "problem": "一个编译器使用模调度，在一台拥有两个算术逻辑单元 (ALU) 和一个乘法单元 (MUL) 的机器上对一个循环进行流水线化。ALU 执行加法操作，MUL 执行乘法操作。所有功能单元都是完全流水线化的，发射率为每个周期 $1$ 次，一个操作仅在其发射的周期内占用其单元。加法延迟为 $1$ 个周期，乘法延迟为 $2$ 个周期；也就是说，一个加法在开始后 $1$ 个周期产生其结果，一个乘法在开始后 $2$ 个周期产生其结果。\n\n考虑每次迭代 $i$ 的以下循环体：\n- $N_1$: $x_i \\leftarrow a_i + b_i$ (加法),\n- $N_2$: $y_i \\leftarrow c_i + d_i$ (加法),\n- $N_3$: $s_i \\leftarrow s_{i-1} + e_i$ (加法，从迭代 $i-1$到 $i$ 的循环携带依赖，依赖距离为 $1$),\n- $N_4$: $z_i \\leftarrow x_i \\times k$ (乘法，依赖于同一次迭代中的 $N_1$)。\n\n假设寄存器数量无限，内存访问与计算完全重叠（没有来自内存的额外资源或延迟约束），并且只有所述的功能单元和延迟约束调度。\n\n从模调度中关于资源吞吐量和依赖时序的基本原理出发，确定此循环在给定机器上的资源约束的最小启动间隔 (ResMII)，然后以计算出的 $ResMII$ 相等的启动间隔构建一个无冲突的模调度核心。该核心必须：\n- 为每个操作 $N_1$, $N_2$, $N_3$, $N_4$ 分配一个模启动时间 $t(N_j) \\in \\{0, 1, \\ldots, \\mathrm{II}-1\\}$,\n- 在每个模时间点上遵守资源容量（每个模时间点发射的加法不超过 $2$ 个，乘法不超过 $1$ 个）,\n- 满足所有数据依赖时序约束，包括循环携带依赖。\n\n将您的最终答案表示为 $ResMII$ 的数值。无需四舍五入。", "solution": "用户提供的问题陈述已经过分析，并被认为是有效的。这是一个基于编译器理论和计算机体系结构原理的适定问题，特别是在指令级并行和软件流水线领域。所有参数和约束都已明确定义，没有内部矛盾或事实不准确之处。\n\n该问题要求我们确定给定循环体的资源约束的最小启动间隔 ($ResMII$)，并为该 $II$ 构建一个有效的模调度。启动间隔 ($II$) 是软件流水线循环中连续迭代开始之间的时钟周期数。最小可能 $II$，记为 $MII$，受资源可用性和循环携带数据依赖的双重约束。\n$$\nMII = \\max(ResMII, RecMII)\n$$\n\n首先，我们计算 $ResMII$。这取决于循环的资源使用情况。对于每种资源类型 $r$，最小间隔是需要该资源的操作数量 $N_r$ 与该类型可用功能单元数量 $R_r$ 之比的向上取整。总的 $ResMII$ 是所有资源类型中得出的最大值。\n$$\nResMII = \\max_{r} \\left\\lceil \\frac{N_r}{R_r} \\right\\rceil\n$$\n循环体包含以下操作：\n- $N_1$: 加法 (ALU)\n- $N_2$: 加法 (ALU)\n- $N_3$: 加法 (ALU)\n- $N_4$: 乘法 (MUL)\n\n每种资源类型的操作数量为：\n- 用于 ALU 的加法：$N_{ALU} = 3$\n- 用于 MUL 的乘法：$N_{MUL} = 1$\n\n可用的机器资源为：\n- ALU 单元：$R_{ALU} = 2$\n- MUL 单元：$R_{MUL} = 1$\n\n每种资源类型对 $ResMII$ 的贡献是：\n- 对于 ALU：$\\text{ResMII}_{\\text{ALU}} = \\left\\lceil \\frac{N_{ALU}}{R_{ALU}} \\right\\rceil = \\left\\lceil \\frac{3}{2} \\right\\rceil = \\lceil 1.5 \\rceil = 2$\n- 对于 MUL：$\\text{ResMII}_{\\text{MUL}} = \\left\\lceil \\frac{N_{MUL}}{R_{MUL}} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1$\n\n总的 $ResMII$ 是这些值的最大值：\n$$\nResMII = \\max(2, 1) = 2\n$$\n\n接下来，我们计算 $RecMII$。这取决于循环携带依赖，也称为递归。对于涉及一系列操作的递归循环，$RecMII$ 是该循环中操作延迟总和与依赖距离总和之比的向上取整。\n$$\nRecMII = \\max_{\\text{recurrences } p} \\left\\lceil \\frac{\\sum_{\\text{ops } j \\in p} \\text{latency}(j)}{\\sum_{\\text{deps } e \\in p} \\text{distance}(e)} \\right\\rceil\n$$\n在这个问题中，有一个指定的递归：\n- 操作 $N_3: s_i \\leftarrow s_{i-1} + e_i$ 依赖于其自身在前一次迭代中的结果。这形成了一个递归循环 $N_3 \\to N_3$。\n- 操作 $N_3$（加法）的延迟为 $L(N_3) = 1$ 个周期。\n- 依赖距离给定为 $\\delta = 1$ 次迭代。\n\n此递归的 $RecMII$ 为：\n$$\nRecMII = \\left\\lceil \\frac{L(N_3)}{\\delta} \\right\\rceil = \\left\\lceil \\frac{1}{1} \\right\\rceil = 1\n$$\n\n现在，我们可以找到总的最小启动间隔 ($MII$)：\n$$\nMII = \\max(ResMII, RecMII) = \\max(2, 1) = 2\n$$\n最小可能的启动间隔是 $2$ 个周期。问题要求的是 $ResMII$ 的值，我们计算出其值为 $2$。我们现在必须验证是否可以为 $II = ResMII = 2$ 构建一个无冲突的调度。\n\n模调度为循环体中的每个操作 $N_j$ 分配一个启动时间 $t(N_j) \\in \\{0, 1, \\dots, II-1\\}$。对于 $II=2$，可能的时间是 $t=0$ 和 $t=1$。调度必须同时满足资源和依赖约束。\n\n对于从操作 $N_u$ 到 $N_v$ 的依赖，其延迟为 $L(N_u)$，距离为 $\\delta$，数据依赖约束由以下不等式表示：\n$$\nt(N_u) + L(N_u) \\le t(N_v) + \\delta \\times II\n$$\n让我们分析在 $II=2$ 的情况下我们问题的依赖关系：\n1.  迭代内依赖 $N_1 \\to N_4$:\n    - $N_u=N_1$, $N_v=N_4$, $L(N_1)=1$ (加法延迟), $\\delta=0$.\n    - $t(N_1) + 1 \\le t(N_4) + 0 \\times 2 \\implies t(N_1) + 1 \\le t(N_4)$.\n2.  循环携带依赖 $N_3 \\to N_3$:\n    - $N_u=N_3$, $N_v=N_3$, $L(N_3)=1$ (加法延迟), $\\delta=1$.\n    - $t(N_3) + 1 \\le t(N_3) + 1 \\times 2 \\implies 1 \\le 2$. 这是一个平凡的约束，总是被满足，并证实了我们对 $RecMII$ 的计算。\n\n主要的调度约束是 $t(N_1) + 1 \\le t(N_4)$。由于 $t(N_1)$ 和 $t(N_4)$ 必须在 $\\{0, 1\\}$ 中，这个不等式只有在 $t(N_1)=0$ 且 $t(N_4)=1$ 时才能满足。\n\n让我们固定这些分配，并调度剩余的操作 $N_2$（加法）和 $N_3$（加法）。\n- 在时间 $t=0$ 调度：我们已经调度了 $N_1$（加法）。使用了一个 ALU。我们还剩下一个 ALU 单元和一个 MUL 单元。\n- 在时间 $t=1$ 调度：我们已经调度了 $N_4$（乘法）。使用了一个 MUL。我们还剩下两个 ALU 单元和零个 MUL 单元。\n\n我们可以将剩余的两个加法操作 $N_2$ 和 $N_3$ 放入可用的槽位。一个可能的有效调度是：\n- 在时间 $t=0$ 放置 $N_2$（加法）。\n- 在时间 $t=1$ 放置 $N_3$（加法）。\n\n提议的核心调度如下：\n- $t(N_1) = 0$\n- $t(N_2) = 0$\n- $t(N_3) = 1$\n- $t(N_4) = 1$\n\n让我们验证这个调度：\n- **资源约束：**\n  - 在时间 $t=0$：发射 $N_1$ 和 $N_2$。这需要 $2$ 个 ALU。机器有 $2$ 个 ALU。这是有效的。\n  - 在时间 $t=1$：发射 $N_3$ 和 $N_4$。这需要 $1$ 个 ALU 和 $1$ 个 MUL。机器有 $2$ 个 ALU 和 $1$ 个 MUL。这是有效的。\n- **依赖约束：**\n  - $t(N_1) + 1 \\le t(N_4) \\implies 0 + 1 \\le 1$，成立。\n\n该调度是有效的。这证实了该循环可以以 $II=2$ 的启动间隔进行流水线化，该值等于计算出的 $ResMII$。\n\n问题要求的是资源约束的最小启动间隔 ($ResMII$) 的数值。根据我们的推导，这个值是 $2$。", "answer": "$$\\boxed{2}$$", "id": "3658402"}, {"introduction": "一个有效的调度不仅要满足资源和延迟约束，还必须保证数据正确性。这个高级练习[@problem_id:3658367]探讨了一个微妙但至关重要的问题：重叠的循环迭代如何产生“隐藏”的数据冒险（反相关）。你将分析一个看似合法的调度方案，理解变量名重用如何导致冲突，并确定需要通过模变量展开（Modulo Variable Expansion, MVE）来解决此问题的最小程度，以确保调度的最终正确性。", "problem": "考虑以下一个循环，该循环旨在通过模调度进行软件流水化，其启动间隔 (II) 定义为 $\\mathrm{II}$。循环体包含四个相关操作，它们在单发射、全流水的功能单元上执行，并具有所述的延迟（以周期为单位）：\n- $S_1$：生成标量 $x$，延迟为 $2$。\n- $S_2$：消耗 $x$ 生成 $y$，延迟为 $1$。\n- $S_4$：消耗 $x$ 生成 $\\mathrm{tmp}$，延迟为 $5$。\n- $S_5$：消耗 $\\mathrm{tmp}$ 更新一个累加器，延迟为 $1$。\n\n假设在一个候选的模调度中，$\\mathrm{II} = 2$，对于迭代 $i \\in \\mathbb{Z}_{\\ge 0}$，操作在以下绝对时间（以周期为单位）被放置：\n- $S_1$ 在时间 $2i + 0$ 发射，并在时间 $2i + 2$ 写入 $x$。\n- $S_2$ 在时间 $2i + 3$ 发射（在其发射时间读取 $x$ 作为输入）。\n- $S_4$ 在时间 $2i + 5$ 发射（在其发射时间读取 $x$ 作为输入）。\n- $S_5$ 在时间 $2i + 10$ 发射。\n\n这些放置与真相关和资源使用情况一致。读取发生在操作的发射时间，写入发生在操作的完成时间。模变量展开 (MVE) 的展开因子为 $K$，它为标量 $x$ 分配 $K$ 个不同的名称，并每 $K$ 次迭代以循环方式重用每个名称；设置 $K=1$ 意味着每个迭代都重用同一个名称。\n\n仅使用数据相关、生存期和模调度时间语义 $t_{i}(O) = T(O) + i \\cdot \\mathrm{II}$（对于迭代 $i$ 中的操作 $O$）的基本定义，分析当 $K=1$ 时产生的对 $x$ 的隐藏的读后写反相关，并确定所需的最小整数展开因子 $K$，以消除此反相关，从而使调度变得可行。使用所述的时序模型：对同一名称的后续写入必须严格晚于最后一次读取完成的时间（即，写入时间必须严格大于最后一次读取的时间）。请以单个整数形式提供你的答案，不带单位。", "solution": "首先根据指定标准对问题进行验证。\n\n**步骤 1：提取已知条件**\n- **主题**：用于软件流水的模调度。\n- **启动间隔**：$\\mathrm{II} = 2$ 周期。\n- **操作与延迟**：\n  - $S_1$：生成标量 $x$，延迟 $L(S_1) = 2$ 周期。\n  - $S_2$：消耗 $x$，延迟 $L(S_2) = 1$ 周期。\n  - $S_4$：消耗 $x$，延迟 $L(S_4) = 5$ 周期。\n  - $S_5$：消耗 $\\mathrm{tmp}$，延迟 $L(S_5) = 1$ 周期。\n- **迭代 $i$ 的候选模调度时间**：\n  - $S_1$ 在时间 $t_i(S_1) = 2i + 0$ 发射。\n  - $S_2$ 在时间 $t_i(S_2) = 2i + 3$ 发射。\n  - $S_4$ 在时间 $t_i(S_4) = 2i + 5$ 发射。\n  - $S_5$ 在时间 $t_i(S_5) = 2i + 10$ 发射。\n- **时序模型**：\n  - 读取发生在操作的发射时间。\n  - 写入发生在操作的完成时间，即（发射时间 + 延迟）。\n  - 反相关约束：对一个名称的写入必须严格晚于对同一名称的最后一次读取的时间。\n- **模变量展开 (MVE)**：\n  - 展开因子 $K$ 为一个标量提供 $K$ 个不同的名称，每 $K$ 次迭代重用一次。\n- **目标**：确定所需的最小整数展开因子 $K$，以解决对标量变量 $x$ 的读后写（WAR）反相关。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学基础**：该问题在编译器设计的既定理论中有充分的依据，特别是指令调度和优化技术，如软件流水、模调度和寄存器重命名（通过模变量展开）。\n- **良定性**：该问题提供了一套完整的定义、约束和数据，用以计算 $K$ 的唯一整数值。\n- **客观性**：语言正式且精确，没有主观或模棱两可的陈述。\n- **缺陷检查**：该问题没有违反任何列出的无效标准。如上所述，调度满足真相关。例如，对于迭代 $i$ 中关于 $x$ 的 $S_1 \\rightarrow S_2$ 相关，来自 $S_1$ 的写入发生在时间 $t_i(S_1) + L(S_1) = (2i+0)+2 = 2i+2$，而 $S_2$ 的读取发生在时间 $t_i(S_2) = 2i+3$。由于 $2i+2 \\le 2i+3$，该相关得到满足。该问题关注于跨迭代的名称重用所创建的反相关，这是该领域的标准分析。\n\n**步骤 3：结论与行动**\n问题有效。将推导解答。\n\n**解答推导**\n\n该问题要求找到最小的整数模变量展开因子 $K$，以消除对标量变量 $x$ 的读后写（WAR）反相关。这种反相关源于软件流水调度中循环迭代的重叠执行。\n\n首先，我们必须描述 $x$ 的单个值的生存期。在任何给定的迭代 $i$ 中，操作 $S_1$ 会产生一个新值 $x$。我们将其表示为 $x_i$。\n\n当迭代 $i$ 中的操作 $S_1$ 完成时，值 $x_i$ 被写入其存储位置（即其生命周期开始）。迭代 $i$ 中 $S_1$ 的发射时间是 $t_i(S_1) = 2i$。其延迟为 $L(S_1) = 2$ 周期，因此写入时间是：\n$$t_{write}(x_i) = t_i(S_1) + L(S_1) = 2i + 2$$\n\n这个值 $x_i$ 在同一次迭代 $i$ 中被操作 $S_2$ 和 $S_4$ 消耗（读取）。根据时序模型，读取发生在消耗操作的发射时间。\n$x_i$ 的读取时间是：\n- 被 $S_2$ 读取：$t_{read,S2}(x_i) = t_i(S_2) = 2i + 3$\n- 被 $S_4$ 读取：$t_{read,S4}(x_i) = t_i(S_4) = 2i + 5$\n\n值 $x_i$ 的生存期延续到其最后一次使用。因此，最后一次读取的时间是：\n$$t_{last\\_read}(x_i) = \\max(t_{read,S2}(x_i), t_{read,S4}(x_i)) = \\max(2i+3, 2i+5) = 2i+5$$\n\n如果 $x_i$ 的存储位置在时间 $t_{last\\_read}(x_i)$ 或之前被后续操作覆盖，则会发生 WAR 反相关冲突。问题规定写入时间必须严格大于最后一次读取的时间。\n\n使用因子为 $K$ 的模变量展开，我们为变量 $x$ 使用 $K$ 个不同的名称。在迭代 $i$ 中使用的名称每 $K$ 次迭代重用一次。因此，用于值 $x_i$ 的存储位置将被用于值 $x_{i+K}$，该值由迭代 $i+K$ 中的操作 $S_1$ 产生。\n\n这个后续的、可能产生冲突的写入时间是迭代 $i+K$ 中 $S_1$ 的完成时间：\n$$t_{write}(x_{i+K}) = t_{i+K}(S_1) + L(S_1) = (2(i+K)) + 2 = 2i + 2K + 2$$\n\n为确保调度可行，对重用名称的写入必须严格在对该名称的最后一次读取完成之后发生。这给了我们以下不等式：\n$$t_{write}(x_{i+K})  t_{last\\_read}(x_i)$$\n\n代入我们推导出的表达式：\n$$2i + 2K + 2  2i + 5$$\n\n项 $2i$ 出现在两侧，可以消去，从而得到一个与具体迭代 $i$ 无关的不等式：\n$$2K + 2  5$$\n\n求解 $K$：\n$$2K  3$$\n$$K  \\frac{3}{2}$$\n$$K  1.5$$\n\n由于展开因子 $K$ 必须是整数，满足此条件的最小整数值 $K$ 是 $2$。\n因此，需要至少 $K=2$ 个不同的名称用于变量 $x$，才能通过消除读后写反相关使调度变得可行。", "answer": "$$\n\\boxed{2}\n$$", "id": "3658367"}]}