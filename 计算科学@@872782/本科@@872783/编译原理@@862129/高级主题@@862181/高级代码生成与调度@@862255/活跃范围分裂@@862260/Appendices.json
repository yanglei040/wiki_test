{"hands_on_practices": [{"introduction": "本练习 [@problem_id:3651136] 提出了一个循环中常见的场景：需要一个值，但寄存器压力很高。你将定量地比较两种基本的编译器策略：通过溢出一个现有变量来腾出空间，或者分割新值的活跃范围并在循环内重新计算它（再物质化）。这个实践揭示了驱动活跃范围分割的核心经济权衡，即溢出成本与计算成本之间的权衡。", "problem": "考虑以下用于简单循环的三地址风格的中间表示（Intermediate Representation，IR），以及一个具体的机器模型和一个用于研究循环不变量值的生命周期分裂和重物质化效果的简化寄存器分配场景：\n- 代码\n  - 循环前置头部（Preheader）：计算一个循环不变的类地址常量\n    - $c := \\text{base} + 4096$\n    - $i := 0$\n    - $acc := 0$\n  - 循环体（重复 $T$ 次迭代）：\n    - $t := \\mathrm{load}[p + i]$\n    - $acc := acc + t \\times c$\n    - $i := i + 4$\n    - if $(i  M)$ goto loop head\n- 存活集合假设\n  - 在乘法 $t \\times c$ 之前的程序点，除 $c$ 之外的同时存活值的集合基数为 $3$：具体为 $\\{acc, i, t\\}$。\n  - 如果 $c$ 在整个循环体中保持存活，那么该点的峰值同时存活集合的基数为 $4$（即上述三个值加上 $c$）。\n  - 假设编译器无法通过进一步重调度或更改使用来减少该程序点的峰值存活数。\n- 寄存器和成本模型\n  - 目标机器有 $R = 3$ 个通用寄存器可用于此循环。\n  - 用于溢出（spilling）的内存操作具有累加成本：每次用于溢出的 $\\mathrm{store}$ 或 $\\mathrm{load}$ 操作成本为 $C_{\\mathrm{mem}} = 6$ 个周期，且这些成本是独立且不可重叠的。\n  - 一条将 $c$ 从 $\\text{base}$ 和立即数 $4096$ 重物质化（rematerialize）的单一立即数加法指令（例如，地址计算 $\\mathrm{lea}$）的成本为 $C_{\\mathrm{remat}} = 1$ 个周期。\n  - 循环运行 $T = 100$ 次迭代。\n  - 忽略缓存未命中，并假设在所比较的策略中所有其他循环指令都相同；只计算下述策略之间有差异的成本。\n- 两种待比较的分配策略\n  - 策略 K (Keep - 保持)：在循环前置头部中计算一次 $c$，并使 $c$ 在整个循环中保持存活。由于循环内的峰值存活数为 $4$ 而 $R = 3$，假设分配器在关键点恰好溢出一个其他值，导致每次迭代产生一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n  - 策略 S (Split + Rematerialize - 分裂+重物质化)：在循环入口处分裂 $c$ 的生命周期，使得 $c$ 不在整个循环中存活。而是在循环内部、每次使用 $c$ 之前，通过一条单一的立即数加法指令来重物质化 $c$。这会将关键点的峰值存活数减少到 $3$，从而消除了溢出。\n\n回顾控制存活性和寄存器分配的基本定义：\n- 如果一个值的当前内容可能在被重新定义之前的某条路径上被使用，则该值在该程序点是存活的。\n- 一个程序点上同时存活的值的峰值数量，是在该点避免溢出所需寄存器数量的下限。\n- 如果同时存活的值的数量超过可用寄存器数量 $k$ 个，那么至少有 $k$ 个值必须被溢出。在这个简化模型中，当超出数量为 $1$ 时，通常每次迭代会引发至少一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n- 重物质化（Rematerialization）是重新计算一个廉价的表达式（例如，基于不变量的立即数加法），而不是从内存中加载它或让它在高压区域保持存活。\n\n问题：在上述假设和此成本模型下，关于哪种策略能最小化由寄存器压力产生的动态成本，以及相比另一种策略能节省多少，以下哪个陈述是正确的？\n\nA. 在循环入口处分裂 $c$ 的生命周期，并在每次迭代中使用前立即重物质化它，与保持 $c$ 存活相比，严格地减少了动态成本，在 $T=100$ 时节省了 $1101$ 个周期；在此模型下，这是两种策略中的最优策略。\n\nB. 保持 $c$ 在整个循环中存活成本更低，因为在循环前置头部计算一次 $c$ 节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期，这超过了 $2T \\cdot C_{\\mathrm{mem}} = 1200$ 个周期的溢出流量成本；因此它节省了 $1100$ 个周期。\n\nC. 在给定的假设下，两种策略的成本相等，因为策略 K 中的溢出 $\\mathrm{store}$ 和 $\\mathrm{load}$ 操作可以被其他指令重叠和隐藏，使其累加成本实际上为 $0$。\n\nD. 分裂 $c$ 的生命周期会增加循环回边处的冲突，并迫使每次迭代产生两次溢出，成本为 $2400$ 个周期，因此策略 K 明显更好。", "solution": "### 问题验证\n\n#### 第 1 步：提取已知信息\n\n问题提供了以下信息：\n\n*   **代码结构：**\n    *   循环前置头部：$c := \\text{base} + 4096$; $i := 0$; $acc := 0$\n    *   循环体：$t := \\mathrm{load}[p + i]$; $acc := acc + t \\times c$; $i := i + 4$; if $(i  M)$ goto loop head\n*   **存活集合假设：**\n    *   在乘法 $t \\times c$ 之前的点，除 $c$ 之外的存活值集合为 $\\{acc, i, t\\}$，其基数为 $3$。\n    *   如果 $c$ 保持存活，该点的同时存活集合的峰值基数为 $4$。\n    *   编译器无法通过重调度来减少这个峰值存活数。\n*   **寄存器和成本模型：**\n    *   可用通用寄存器数量：$R = 3$。\n    *   用于溢出（spilling）的内存操作（store 或 load）成本：$C_{\\mathrm{mem}} = 6$ 个周期。这些成本是累加且不可重叠的。\n    *   重物质化 $c$ 的成本：每次 $C_{\\mathrm{remat}} = 1$ 个周期。\n    *   循环迭代次数：$T = 100$。\n    *   分析应只计算两种策略之间有差异的成本。\n*   **分配策略：**\n    *   **策略 K (Keep - 保持)：** $c$ 在循环前置头部计算一次。循环内的峰值存活数为 $4$。由于 $R=3$，这迫使一个值被溢出，每次迭代产生一次 $\\mathrm{store}$ 和一次 $\\mathrm{load}$。\n    *   **策略 S (Split + Rematerialize - 分裂+重物质化)：** $c$ 的生命周期被分裂。$c$ 在每次循环迭代中使用前被重物质化。峰值存活数减少到 $3$，从而消除了溢出。\n\n#### 第 2 步：使用提取的已知信息进行验证\n\n*   **科学依据：** 该问题牢固地植根于编译器设计的原理，特别是寄存器分配。生命周期、寄存器压力、溢出、生命周期分裂和重物质化等概念是该领域的标准主题。成本模型虽然简化，但反映了现实中的权衡，即内存访问（$C_{\\mathrm{mem}}=6$）比简单的算术指令（$C_{\\mathrm{remat}}=1$）昂贵得多。该问题在科学上是合理的。\n*   **适定性：** 该问题是适定的。它提供了一个清晰的、量化的场景，包含了所有必要的参数（$R$、$T$、$C_{\\mathrm{mem}}$、$C_{\\mathrm{remat}}$）以及关于每种策略后果（溢出次数等）的明确假设。问题要求对成本进行具体比较，这可以从给定的信息中唯一确定。\n*   **客观性：** 问题陈述是客观的，并使用了编译器理论中的精确术语。它建立了一个“简化模型”来预先固定复杂编译器启发式算法（如决定溢出哪个变量）的结果，这是创建可解的分析性问题的有效方法。\n\n该问题没有任何无效性缺陷。它是自包含的、一致的、有科学依据的并且是适定的。\n\n#### 第 3 步：结论与行动\n\n问题陈述是**有效的**。现在开始求解过程。\n\n### 解题推导\n\n任务是比较两种不同寄存器分配策略在 $T=100$ 次迭代中由寄存器压力产生的总动态成本。我们必须计算两种策略之间所有不同的成本。\n\n**策略 K (Keep - 保持)：**\n在此策略中，值 $c$ 在循环前置头部计算一次，并在整个循环执行期间都保存在一个寄存器中。\n1.  **循环前置头部成本：** 计算 $c := \\text{base} + 4096$ 在循环开始前执行一次。这是一条立即数加法指令，其成本等同于重物质化成本，即 $C_{\\mathrm{remat}} = 1$ 个周期。这是此策略产生的一项成本，而策略 S 中不存在同样形式的成本（因为策略 S 的循环前置头部没有计算值 `c`）。\n2.  **循环体成本：** 问题指出，保持 $c$ 存活会将同时存活变量的峰值数量提高到 $4$。由于只有 $R=3$ 个寄存器，必须将一个值溢出到内存。问题明确指出，此溢出在每次迭代中会引发一次 $\\mathrm{store}$ 操作和一次 $\\mathrm{load}$ 操作。\n    *   一次 store 的成本：$C_{\\mathrm{mem}} = 6$ 个周期。\n    *   一次 load 的成本：$C_{\\mathrm{mem}} = 6$ 个周期。\n    *   每次迭代的总溢出成本：$C_{\\mathrm{spill\\_iter}} = C_{\\mathrm{mem}} + C_{\\mathrm{mem}} = 6 + 6 = 12$ 个周期。\n3.  **策略 K 的总成本：** 总成本是一次性的循环前置头部计算成本与所有迭代中累积的溢出成本之和。\n    $$ \\text{Cost}_K = C_{\\mathrm{remat}} + T \\times C_{\\mathrm{spill\\_iter}} $$\n    $$ \\text{Cost}_K = 1 + 100 \\times 12 = 1 + 1200 = 1201 \\text{ 个周期} $$\n\n**策略 S (Split + Rematerialize - 分裂+重物质化)：**\n在此策略中，$c$ 的生命周期被分裂，因此它不在循环迭代之间存活。而是在循环内部、每次需要它之前重新计算。\n1.  **循环前置头部成本：** 循环前置头部没有计算 $c$。\n2.  **循环体成本：** 问题指出，此策略将峰值存活数减少到 $3$。由于有 $R=3$ 个寄存器，避免了溢出。但是，必须在每次迭代中重新计算值 $c$。\n    *   每次迭代的重物质化成本：$C_{\\mathrm{remat}} = 1$ 个周期。\n3.  **策略 S 的总成本：** 总成本是在 $T$ 次迭代中每次重物质化 $c$ 的累积成本。\n    $$ \\text{Cost}_S = T \\times C_{\\mathrm{remat}} $$\n    $$ \\text{Cost}_S = 100 \\times 1 = 100 \\text{ 个周期} $$\n\n**比较：**\n我们比较两种策略的总成本：\n*   $\\text{Cost}_K = 1201$ 个周期。\n*   $\\text{Cost}_S = 100$ 个周期。\n\n策略 S 明显比策略 K 成本更低。使用策略 S 而非策略 K 所节省的总成本为：\n$$ \\text{Savings} = \\text{Cost}_K - \\text{Cost}_S = 1201 - 100 = 1101 \\text{ 个周期} $$\n因此，策略 S（分裂+重物质化）是两者中的最优选择，它减少了 $1101$ 个周期的动态成本。\n\n### 逐项分析选项\n\n**A. 在循环入口处分裂 $c$ 的生命周期，并在每次迭代中使用前立即重物质化它，与保持 $c$ 存活相比，严格地减少了动态成本，在 $T=100$ 时节省了 $1101$ 个周期；在此模型下，这是两种策略中的最优策略。**\n该陈述与我们的推导完全一致。\n*   策略 S 降低了动态成本：$\\text{Cost}_S = 100$ 小于 $\\text{Cost}_K = 1201$。\n*   节省了 $1101$ 个周期。\n*   它是所提出的两种策略中的最优策略。\n该陈述是**正确的**。\n\n**B. 保持 $c$ 在整个循环中存活成本更低，因为在循环前置头部计算一次 $c$ 节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期，这超过了 $2T \\cdot C_{\\mathrm{mem}} = 1200$ 个周期的溢出流量成本；因此它节省了 $1100$ 个周期。**\n该陈述包含多个错误。\n*   “保持 $c$ 存活...成本更低”：这是错误的。我们的分析表明，它的成本要高出 $1101$ 个周期。\n*   “...节省了 $T \\cdot C_{\\mathrm{remat}} = 100$ 个周期...”：这个前提是有缺陷的。计算一次 $c$ 避免了 $T-1=99$ 次重物质化，在该特定操作上节省了 $99$ 个周期，但这迫使产生了 $1200$ 个周期的溢出成本。数字 $100$ 代表策略 S 中重物质化的总成本，而不是策略 K 的节省量。\n*   “...这超过了... $1200$ 个周期...”：大约 $100$ 个周期的节省不可能超过 $1200$ 个周期的成本。逻辑推理是颠倒的。\n*   “...它节省了 $1100$ 个周期”：该策略成本更高，并且我们计算出的差额是 $1101$，而不是 $1100$。\n该陈述是**不正确的**。\n\n**C. 在给定的假设下，两种策略的成本相等，因为策略 K 中的溢出 $\\mathrm{store}$ 和 $\\mathrm{load}$ 操作可以被其他指令重叠和隐藏，使其累加成本实际上为 $0$。**\n这个陈述直接与问题的一个前提相矛盾。问题指出溢出成本是“$C_{\\mathrm{mem}} = 6$ 个周期，且这些成本是独立且不可重叠的”。因此，它们的成本不能被认为是 $0$。\n该陈述是**不正确的**。\n\n**D. 分裂 $c$ 的生命周期会增加循环回边处的冲突，并迫使每次迭代产生两次溢出，成本为 $2400$ 个周期，因此策略 K 明显更好。**\n这个陈述歪曲了生命周期分裂的效果。\n*   “分裂 $c$ 的生命周期会增加冲突...”：分裂 $c$ 的生命周期的根本目的和明确效果是*减少*冲突和寄存器压力。问题明确证实了这一点：“这会将峰值存活数减少到 $3$”。\n*   “...并迫使每次迭代产生两次溢出...”：这是错误的。通过将峰值存活数减少到与寄存器数量相匹配（$3$），策略 S *消除了*溢出，正如问题所述。因此，$2400$ 个周期（$2 \\times (100 \\times 12)$）的成本是毫无根据的。\n*   “...因此策略 K 明显更好”：这个结论是基于错误的前提得出的，并且与正确结果相反。\n该陈述是**不正确的**。", "answer": "$$\\boxed{A}$$", "id": "3651136"}, {"introduction": "在简单权衡的基础上，本练习 [@problem_id:3651153] 将活跃范围分割形式化为一个结构化的优化问题。你将学习把一个变量的活跃范围建模为一系列片段，并应用动态规划来寻找“溢出”和“驻留寄存器”状态的最优序列。这个练习展示了一种强大而系统的方法，用以确定在连续代码区域内最有利可图的分割策略。", "problem": "考虑一个线性代码区域，其中单个变量 $x$ 在 $8$ 个连续段（索引为 $i \\in \\{1,2,\\dots,8\\}$）上是活跃的。假设我们已经测量了程序的动态行为，因此对于每个段 $i$，我们有一个净节省密度 $b_{i}$，它表示在段 $i$ 期间将 $x$ 保留在寄存器中的寄存器驻留代价密度与溢出代价密度之间的差值。也就是说，正的 $b_{i}$ 意味着在段 $i$ 期间将 $x$ 保留在寄存器中相对于在该段中溢出可以降低预期代价，而负的 $b_{i}$ 意味着在该段中溢出更划算。假设这些密度已经包含了执行频率和使用密度；它们总结如下：$b_{1}=3$，$b_{2}=2$，$b_{3}=-1$，$b_{4}=-4$，$b_{5}=5$，$b_{6}=4$，$b_{7}=-2$，$b_{8}=1$。对 $x$ 进行活跃范围分裂允许编译器在这个线性化的活跃范围内于两种模式之间切换：寄存器驻留模式和溢出模式。每次模式之间的转换（一次切割）都会因插入的复制或移动指令以及流水线扰动而产生固定的代价 $p$。设 $p=3$。编译器在段 1 之前以溢出模式开始，并在段 8 之后以溢出模式结束。\n\n将这 $8$ 个段上的决策建模为选择 $x$ 的活跃范围的一个划分，该划分由交替的溢出和寄存器驻留运行段组成，其中任何模式的改变都算作一次切割并产生代价 $p$。总净节省定义为所有置于寄存器驻留模式的段的 $b_{i}$ 之和，减去代价 $p$ 乘以切割次数。仅使用活跃性、溢出/重载代价以及活跃范围分裂作为带代价的模式改变的语义等基本定义，推导出 $x$ 活跃范围的最优划分，并计算最大总净节省。将最终答案表示为单个实数。无需四舍五入。", "solution": "用户希望找到变量 $x$ 的最优活跃范围分裂方案。\n\n### 步骤 1：提取已知条件\n- 变量 $x$ 的活跃范围跨越 $8$ 个连续段，索引为 $i \\in \\{1, 2, \\dots, 8\\}$。\n- 在段 $i$ 期间将 $x$ 保留在寄存器中的净节省密度由 $b_i$ 给出。\n- 净节省密度的值为：$b_{1}=3$，$b_{2}=2$，$b_{3}=-1$，$b_{4}=-4$，$b_{5}=5$，$b_{6}=4$，$b_{7}=-2$，$b_{8}=1$。\n- 编译器可以为 $x$ 选择两种模式：寄存器驻留或溢出。\n- 模式之间的转换称为一次切割，并产生固定的代价 $p$。\n- 一次切割的代价是 $p=3$。\n- 段 1 之前的状态是溢出模式。\n- 段 8 之后的状态必须是溢出模式。\n- 目标是找到活跃范围的划分，以最大化总净节省，总净节省定义为所有寄存器驻留段的 $b_i$ 之和减去所有切割的总代价。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学依据：**该问题是活跃范围分裂的标准表述，这是编译器设计中一种成熟的优化技术。所使用的概念（活跃性、溢出代价、寄存器代价、转换代价）是该领域的基础。\n- **良态问题：**该问题是良态的。它寻求在一个有限的可能划分集合上最大化一个已定义的目标函数。保证存在唯一的最大值。\n- **客观性：**该问题是客观陈述的，具有精确的数值数据（$b_i$, $p$）和对要最大化的量的清晰、形式化的定义。\n- **完整性和一致性：**问题提供了所有必要的数据和约束。初始和最终状态条件都已明确定义。没有矛盾之处。\n\n### 步骤 3：结论和行动\n问题是有效的。将推导求解。\n\n### 解题推导\n这个问题可以用动态规划来建模和求解。我们需要确定在每个段结束时，考虑到溢出或寄存器驻留两种可能的模式，可能的最大净节省是多少。\n\n令 $S_i$ 为截至段 $i$ 结束时，变量 $x$ 处于溢出模式下所累积的最大净节省。\n令 $R_i$ 为截至段 $i$ 结束时，变量 $x$ 处于寄存器驻留模式下所累积的最大净节省。\n\n从段 $i-1$ 结束到段 $i$ 结束的状态转换由以下递推关系决定：\n\n为了在段 $i$ 之后处于溢出模式（计算 $S_i$），我们有两种可能：\n1. 在段 $i-1$ 之后处于溢出模式（总节省为 $S_{i-1}$），并在段 $i$ 期间保持溢出模式。没有从 $b_i$ 获得节省，也没有新的切割。节省额保持为 $S_{i-1}$。\n2. 在段 $i-1$ 之后处于寄存器驻留模式（总节省为 $R_{i-1}$），并在段 $i$ 期间切换到溢出模式。此转换是一次切割，产生代价 $p$。节省额变为 $R_{i-1} - p$。\n\n因此，$S_i$ 的递推关系是：\n$$S_i = \\max(S_{i-1}, R_{i-1} - p)$$\n\n为了在段 $i$ 之后处于寄存器驻留模式（计算 $R_i$），我们有两种可能：\n1. 在段 $i-1$ 之后处于寄存器驻留模式（总节省为 $R_{i-1}$），并在段 $i$ 期间保持寄存器驻留模式。我们从此段中获得收益 $b_i$。节省额变为 $R_{i-1} + b_i$。\n2. 在段 $i-1$ 之后处于溢出模式（总节省为 $S_{i-1}$），并在段 $i$ 期间切换到寄存器驻留模式。这是一次切割（代价为 $p$），我们获得收益 $b_i$。节省额变为 $S_{i-1} - p + b_i$。\n\n因此，$R_i$ 的递推关系是：\n$$R_i = \\max(R_{i-1} + b_i, S_{i-1} - p + b_i)$$\n\n初始条件，在段 1 之前（用索引 0 表示），由问题陈述给出。编译器以溢出模式开始，所以初始节省为 $0$。在没有切割的情况下不可能处于寄存器驻留模式，因此我们可以用 $-\\infty$ 的节省来对此状态建模。\n$S_0 = 0$\n$R_0 = -\\infty$\n\n我们已知 $p=3$ 和收益向量 $b = (3, 2, -1, -4, 5, 4, -2, 1)$。现在我们可以计算 $i=1, \\dots, 8$ 时 $S_i$ 和 $R_i$ 的值。\n\n**对于 $i=1$ ($b_1 = 3$)：**\n$S_1 = \\max(S_0, R_0 - p) = \\max(0, -\\infty - 3) = 0$\n$R_1 = \\max(R_0 + b_1, S_0 - p + b_1) = \\max(-\\infty + 3, 0 - 3 + 3) = 0$\n\n**对于 $i=2$ ($b_2 = 2$)：**\n$S_2 = \\max(S_1, R_1 - p) = \\max(0, 0 - 3) = 0$\n$R_2 = \\max(R_1 + b_2, S_1 - p + b_2) = \\max(0 + 2, 0 - 3 + 2) = \\max(2, -1) = 2$\n\n**对于 $i=3$ ($b_3 = -1$)：**\n$S_3 = \\max(S_2, R_2 - p) = \\max(0, 2 - 3) = \\max(0, -1) = 0$\n$R_3 = \\max(R_2 + b_3, S_2 - p + b_3) = \\max(2 + (-1), 0 - 3 + (-1)) = \\max(1, -4) = 1$\n\n**对于 $i=4$ ($b_4 = -4$)：**\n$S_4 = \\max(S_3, R_3 - p) = \\max(0, 1 - 3) = \\max(0, -2) = 0$\n$R_4 = \\max(R_3 + b_4, S_3 - p + b_4) = \\max(1 + (-4), 0 - 3 + (-4)) = \\max(-3, -7) = -3$\n\n**对于 $i=5$ ($b_5 = 5$)：**\n$S_5 = \\max(S_4, R_4 - p) = \\max(0, -3 - 3) = \\max(0, -6) = 0$\n$R_5 = \\max(R_4 + b_5, S_4 - p + b_5) = \\max(-3 + 5, 0 - 3 + 5) = \\max(2, 2) = 2$\n\n**对于 $i=6$ ($b_6 = 4$)：**\n$S_6 = \\max(S_5, R_5 - p) = \\max(0, 2 - 3) = \\max(0, -1) = 0$\n$R_6 = \\max(R_5 + b_6, S_5 - p + b_6) = \\max(2 + 4, 0 - 3 + 4) = \\max(6, 1) = 6$\n\n**对于 $i=7$ ($b_7 = -2$)：**\n$S_7 = \\max(S_6, R_6 - p) = \\max(0, 6 - 3) = 3$\n$R_7 = \\max(R_6 + b_7, S_6 - p + b_7) = \\max(6 + (-2), 0 - 3 + (-2)) = \\max(4, -5) = 4$\n\n**对于 $i=8$ ($b_8 = 1$)：**\n$S_8 = \\max(S_7, R_7 - p) = \\max(3, 4 - 3) = \\max(3, 1) = 3$\n$R_8 = \\max(R_7 + b_8, S_7 - p + b_8) = \\max(4 + 1, 3 - 3 + 1) = \\max(5, 1) = 5$\n\n遍历所有 $8$ 个段后，我们得到两种可能模式的最终最大节省：$S_8 = 3$ 和 $R_8 = 5$。\n\n问题陈述指出，编译器在段 8 之后必须以溢出模式结束。\n- 如果最优选择序列导致状态 $S_8$，则变量已经处于溢出模式，总节省为 $S_8 = 3$。这满足结束条件。\n- 如果最优选择序列导致状态 $R_8$，则变量处于寄存器驻留模式。为了满足结束条件，必须进行最后一次切割以转换回溢出模式。这次切割会产生额外的代价 $p$。因此，这条路径的总节省为 $R_8 - p = 5 - 3 = 2$。\n\n最大总净节省是这两种可能性的最大值。\n最大节省 $= \\max(S_8, R_8 - p) = \\max(3, 2) = 3$。\n\n与此节省额对应的最优划分是将变量 $x$ 在段 5 和 6 中保留在寄存器中，而在所有其他段中溢出。收益为 $b_5 + b_6 = 5+4 = 9$。有两次切割：一次是在段 5 之前从溢出模式切换到寄存器模式，另一次是在段 7 之前从寄存器模式切换到溢出模式。总代价为 $2 \\times p = 2 \\times 3 = 6$。净节省为 $9 - 6 = 3$。", "answer": "$$\\boxed{3}$$", "id": "3651153"}, {"introduction": "我们最后的练习 [@problem_id:3651198] 进入了一个更真实的场景，其中涉及复杂的控制流，例如频繁执行的循环和很少进入的错误路径。你将分析如何以一种更精细的方式应用活跃范围分割，仅在程序的“热”路径上将变量保留在寄存器中，而在“冷”路径上让其保持溢出状态。这个练习展示了如何利用性能分析信息来指导智能的分割决策，从而最小化溢出代码的预期动态成本。", "problem": "考虑一个编译器后端，在寄存器分配之后，单个变量 $v$ 被全局溢出到一个栈槽中。给定一个控制流图（CFG），它包含一个入口块、一个热循环以及一个带有冷门错误路径的循环后分支：\n- 块 $B_0$（入口）：定义 $v$ 一次，然后跳转到循环预备头。\n- 循环预备头 $H$：顺序执行到循环头 $L$。\n- 循环体 $B$：在循环内执行。每次循环迭代都包含对 $v$ 的两次使用和一次定义，该定义为下一次迭代更新其值。\n- 循环出口 $X$：从 $X$ 开始，控制流以 $0.99$ 的概率分支到正常路径 $N$（不再使用 $v$），或以 $0.01$ 的概率分支到冷门错误路径 $C$，在路径 $C$ 上有一次对 $v$ 的使用。\n\n假设每次函数调用，循环精确迭代 $N = 1000$ 次。假设由于溢出和重载引起的动态内存流量的成本模型如下：\n- 每次从溢出槽加载的成本为 $c_L = 4$ 个周期。\n- 每次存储到溢出槽的成本为 $c_S = 4$ 个周期。\n- 寄存器到寄存器的移动成本为 $c_M = 1$ 个周期，但除非选项明确使用，否则可以忽略此类移动。\n- 每次函数调用的期望动态成本是所有动态执行的加载和存储的总和，每个操作乘以其成本；当分支是概率性的时候，使用其概率。\n\n定义和约束：\n- 活跃范围分裂会创建一个子范围，其中 $v$ 被保存在一个专用寄存器 $t$ 中，使用/定义都引用 $t$；在溢出区域和寄存器内区域的边界处，进入时需要一次重载（从溢出槽加载到 $t$），如果值对于可能后续使用 $v$ 的溢出区域是活跃的（live-out），则退出时需要一次写回到溢出槽。\n- 正确性要求：任何对 $v$ 的使用都必须观察到该路径上的最新定义。当 $v$ 处于仅寄存器的子范围时，任何离开该子范围进入溢出区域的路径，都必须在溢出区域的使用发生之前，将当前值物化到内存中。\n- 你可以根据需要在关键边（critical edges）上进行分裂，以便只在其中一个出向分支上放置存储或加载操作。\n\n目标：提出一个重新分裂和部分重载的方案，使得只有 $v$ 的热子范围被保留在寄存器中并进行重载，而其他区域保持溢出状态，并且在满足正确性的前提下，最小化每次调用的期望动态溢出成本。\n\n哪个选项最能满足目标？\n\nA. 为 $v$ 创建一个覆盖整个循环的仅寄存器子范围。在循环预备头 $H$ 中插入一次重载，在进入循环前将 $v$ 加载到寄存器 $t$ 中。在整个循环中将 $v$ 保留在 $t$ 中，并在 $X$ 中插入一次无条件存储，在分支到 $N$ 或 $C$ 之前将 $t$ 写回到溢出槽。在循环外（包括在 $C$ 中），保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。\n\nB. 为 $v$ 创建一个覆盖整个循环的仅寄存器子范围。在循环预备头 $H$ 中插入一次重载，在进入循环前将 $v$ 加载到 $t$ 中。在整个循环中将 $v$ 保留在 $t$ 中。不要在 $X$ 中存储。相反，分裂关键边 $X \\rightarrow C$（如果需要），并且只在通往 $C$ 的冷路径上放置一个存储，以将 $v$ 的当前值物化到内存中；然后在 $C$ 中，在其单次使用前执行加载。在循环外的所有地方（包括 $N$ 和 $C$）都保持 $v$ 溢出。\n\nC. 在所有地方都保持 $v$ 溢出。在所有块中，包括循环和冷路径 $C$，在每次使用前立即插入一次重载，在每次定义后立即插入一次存储。\n\nD. 为 $v$ 创建一个每次只跨越单次迭代的仅寄存器子范围：在每次迭代中，在循环头 $L$ 的顶部将 $v$ 重载到 $t$ 中；在迭代内使用和定义 $t$；然后在每次迭代的循环末尾将 $t$ 存回内存。在循环外，保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。\n\nE. 为 $v$ 创建一个覆盖循环的仅寄存器子范围，在 $H$ 中进行一次重载，并且在 $X$ 或之后的所有路径上都不进行存储。在其他所有地方保持 $v$ 溢出，并在 $C$ 中直接使用溢出的值，而不在循环后插入任何额外的存储。\n\n在所述模型和约束下，选择既能保持正确性又能最小化每次函数调用的期望动态溢出成本的选项。不提供部分分数；选择唯一的最佳选项。", "solution": "用户提供了一个关于编译器优化的问题陈述，特别是关于溢出变量的活跃范围分裂。我将首先验证问题陈述，然后进行严谨的求解。\n\n### 第 1 步：提取已知条件\n\n-   **变量和状态**：单个变量 $v$ 被全局溢出到一个栈槽中。\n-   **控制流图（CFG）**：\n    -   入口块 $B_0$ 定义 $v$ 一次。\n    -   一个由预备头 $H$、循环头 $L$ 和循环体 $B$ 组成的循环。\n    -   循环迭代 $N = 1000$ 次。\n    -   循环体 $B$ 每次迭代包含对 $v$ 的两次使用和一次定义。\n    -   循环出口块是 $X$。\n    -   从 $X$ 开始，控制流以 $P(N) = 0.99$ 的概率流向正常路径 $N$。路径 $N$ 上没有对 $v$ 的后续使用。\n    -   从 $X$ 开始，控制流以 $P(C) = 0.01$ 的概率流向冷门错误路径 $C$。路径 $C$ 上有一次对 $v$ 的使用。\n-   **成本模型**：\n    -   加载成本：$c_L = 4$ 个周期。\n    -   存储成本：$c_S = 4$ 个周期。\n-   **定义**：\n    -   活跃范围分裂涉及创建一个子范围，其中 $v$ 被保存在寄存器 $t$ 中。\n    -   进入仅寄存器子范围需要一次重载（从溢出槽加载）。\n    -   如果值对于溢出区域是活跃的（live-out），则退出时需要一次存储到溢出槽。\n-   **正确性约束**：任何对 $v$ 的使用都必须观察到其执行路径上最近的前驱定义所产生的值。\n-   **目标**：在保持正确性的同时，最小化每次函数调用的期望动态溢出成本。\n\n### 第 2 步：使用提取的已知条件进行验证\n\n问题陈述在编译器构造和优化领域具有科学依据。控制流图、全局溢出、活跃范围、活跃性分析和活跃范围分裂等概念都是标准且定义明确的。问题提取得很好：它提供了所有必要的数据（CFG结构、迭代次数、概率、指令计数和成本），用于构建一个目标函数（期望动态成本），并在明确的正确性约束下进行最小化。问题以客观、技术性的语言表述。没有矛盾、歧义或缺失信息会妨碍形式化分析。\n\n### 第 3 步：判断与行动\n\n问题是有效的。我现在将通过分析每个提议方案的期望成本来推导出解决方案。\n\n### 解决方案推导\n\n目标是最小化期望动态成本，即与溢出变量 $v$ 相关的所有动态执行的加载和存储指令的成本总和。在概率路径上执行的指令成本需按该路径的概率进行加权。\n\n#### 基线成本（全局溢出）\n\n首先，让我们分析 $v$ 被全局溢出的初始状态的成本，这对应于选项 C 中描述的策略。\n1.  **块 $B_0$**：发生一次对 $v$ 的定义。由于 $v$ 的值在第一次循环迭代中被使用，所以它在 $B_0$ 之后是活跃的（live-out）。因此，在 $B_0$ 中的定义之后必须跟一条存储指令。\n    -   $B_0$ 中的成本：$1 \\times c_S = 4$ 个周期。每次调用执行一次。\n2.  **循环体 $B$**：有两次对 $v$ 的使用和一次定义。对于一个全局溢出的变量，每次使用前都有一次加载，每次定义后都有一次存储。\n    -   每次迭代的成本：$2 \\times c_L + 1 \\times c_S = 2 \\times 4 + 1 \\times 4 = 12$ 个周期。\n    -   循环总成本：$N \\times 12 = 1000 \\times 12 = 12000$ 个周期。\n3.  **冷路径 $C$**：有一次对 $v$ 的使用，需要一次前置加载。该路径被采用的概率为 $0.01$。\n    -   路径 $C$ 的期望成本：$P(C) \\times (1 \\times c_L) = 0.01 \\times 4 = 0.04$ 个周期。\n\n完全溢出方案（选项 C）的总期望成本为：\n$C_{total} = C_{B_0} + C_{loop} + E[C_C] = 4 + 12000 + 0.04 = 12004.04$ 个周期。\n\n现在，我们评估每个选项。\n\n#### 逐个选项分析\n\n**A. 为 $v$ 创建一个覆盖整个循环的仅寄存器子范围。在循环预备头 $H$ 中插入一次重载，在进入循环前将 $v$ 加载到寄存器 $t$ 中。在整个循环中将 $v$ 保留在 $t$ 中，并在 $X$ 中插入一次无条件存储，在分支到 $N$ 或 $C$ 之前将 $t$ 写回到溢出槽。在循环外（包括在 $C$ 中），保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。**\n\n-   **正确性**：\n    -   $B_0$ 中的定义后跟着一次存储（此选项未包含其成本，但对于重载是必需的）。$H$ 中的重载正确地将此值加载到寄存器 $t$ 中。\n    -   循环内部的所有操作都在 $t$ 上进行，这是正确的。\n    -   $X$ 中的无条件存储将 $t$ 的最终值物化回 $v$ 的溢出槽。\n    -   $C$ 中随后的加载将正确读取此物化值。\n    -   该方案是**正确的**。\n\n-   **成本分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。成本 = $c_S = 4$。（这是一个必要的前提条件）。\n    2.  $H$ 中的重载：执行一次。成本 = $c_L = 4$。\n    3.  循环：所有操作都在寄存器 $t$ 上进行。成本 = $0$。\n    4.  $X$ 中的无条件存储：执行一次。成本 = $c_S = 4$。\n    5.  $C$ 中的加载：以 $0.01$ 的概率执行。期望成本 = $0.01 \\times c_L = 0.04$。\n    -   总期望成本 (A)：$4 + 4 + 4 + 0.04 = 12.04$ 个周期。\n\n**B. 为 $v$ 创建一个覆盖整个循环的仅寄存器子范围。在循环预备头 $H$ 中插入一次重载，在进入循环前将 $v$ 加载到 $t$ 中。在整个循环中将 $v$ 保留在 $t$ 中。不要在 $X$ 中存储。相反，分裂关键边 $X \\rightarrow C$（如果需要），并且只在通往 $C$ 的冷路径上放置一个存储，以将 $v$ 的当前值物化到内存中；然后在 $C$ 中，在其单次使用前执行加载。在循环外的所有地方（包括 $N$ 和 $C$）都保持 $v$ 溢出。**\n\n-   **正确性**：\n    -   $H$ 中的重载是正确的。循环中对 $t$ 的操作是正确的。\n    -   从循环退出时，$v$ 的值仅在通往 $C$ 的路径上是活跃的。在通往 $N$ 的路径上不是活跃的。\n    -   仅在边 $X \\rightarrow C$ 上放置存储，可以正确地仅在需要时物化该值。$C$ 中随后的加载会读取正确的值。\n    -   该方案是**正确的**。\n\n-   **成本分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。成本 = $c_S = 4$。\n    2.  $H$ 中的重载：执行一次。成本 = $c_L = 4$。\n    3.  循环：成本 = $0$。\n    4.  边 $X \\rightarrow C$ 上的存储：以 $0.01$ 的概率执行。期望成本 = $0.01 \\times c_S = 0.04$。\n    5.  $C$ 中的加载：以 $0.01$ 的概率执行。期望成本 = $0.01 \\times c_L = 0.04$。\n    -   总期望成本 (B)：$4 + 4 + 0.04 + 0.04 = 8.08$ 个周期。\n\n**C. 在所有地方都保持 $v$ 溢出。在所有块中，包括循环和冷路径 $C$，在每次使用前立即插入一次重载，在每次定义后立即插入一次存储。**\n\n-   **正确性**：这是朴素、未优化的全局溢出策略。它本身是正确的，因为每次使用前都有加载，每次定义后都有存储，确保了数据流的一致性。\n    -   该方案是**正确的**。\n\n-   **成本分析**：如上述基线分析中所计算。\n    -   总期望成本 (C)：$12004.04$ 个周期。\n\n**D. 为 $v$ 创建一个每次只跨越单次迭代的仅寄存器子范围：在每次迭代中，在循环头 $L$ 的顶部将 $v$ 重载到 $t$ 中；在迭代内使用和定义 $t$；然后在每次迭代的循环末尾将 $t$ 存回内存。在循环外，保持 $v$ 溢出，并在 $C$ 中的使用前插入一次加载。**\n\n-   **正确性**：在每次迭代中，都会重载前一次迭代的值。在迭代内部，对 $t$ 的操作是一致的。该值被存回以供下一次迭代使用。在最后一次迭代之后，正确的值位于内存中，供 $C$ 中的使用。\n    -   该方案是**正确的**。\n\n-   **成本分析**：\n    1.  $B_0$ 中定义后的存储：执行一次。成本 = $c_S = 4$。\n    2.  循环（$1000$ 次迭代）：在每次迭代中，都有一次重载和一次存储。\n        -   每次迭代的成本：$c_L + c_S = 4 + 4 = 8$。\n        -   循环总成本：$1000 \\times 8 = 8000$。\n    3.  $C$ 中的加载：以 $0.01$ 的概率执行。期望成本 = $0.01 \\times c_L = 0.04$。\n    -   总期望成本 (D)：$4 + 8000 + 0.04 = 8004.04$ 个周期。\n\n**E. 为 $v$ 创建一个覆盖循环的仅寄存器子范围，在 $H$ 中进行一次重载，并且在 $X$ 或之后的所有路径上都不进行存储。在其他所有地方保持 $v$ 溢出，并在 $C$ 中直接使用溢出的值，而不在循环后插入任何额外的存储。**\n\n-   **正确性**：$v$ 的值在循环内部被修改了 $1000$ 次，最终值驻留在寄存器 $t$ 中。该选项提议*不进行任何存储*操作来将此最终值写回溢出槽。$v$ 的原始值（循环前的值）仍然在溢出槽中。$C$ 中的使用将加载这个过时的、不正确的值。这违反了“任何对 v 的使用都必须观察到最新的定义”的正确性约束。\n    -   该方案是**不正确的**。\n\n### 比较与结论\n\n让我们比较一下正确选项的总期望成本：\n-   成本(A) = $12.04$ 个周期\n-   成本(B) = $8.08$ 个周期\n-   成本(C) = $12004.04$ 个周期\n-   成本(D) = $8004.04$ 个周期\n\n在所有正确的选项中，最低的期望成本是 $8.08$ 个周期，由选项 B 实现。该策略之所以优越，是因为它在整个热循环期间将变量限制在寄存器中，从而消除了其中所有的 $3000$ 次内存操作，并且它智能地将所需的回存操作仅放置在实际需要该值的低概率冷路径上，避免了在高概率正常路径上的成本。选项 A 不是最优的，因为它的无条件存储是浪费的。选项 C 和 D 由于在循环内部产生内存操作而导致成本急剧增加。\n\n因此，选项 B 代表了所有选项中的最优策略。", "answer": "$$\\boxed{B}$$", "id": "3651198"}]}