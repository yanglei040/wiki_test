{"hands_on_practices": [{"introduction": "在溢出一个寄存器之前，我们必须首先确定将其值存放到内存的哪个位置。当函数栈帧的大小在运行时动态变化时（例如，使用变长数组），这个问题就变得非常棘手。本练习 [@problem_id:3667841] 探讨了如何利用一个稳定的帧指针（$FP$）来正确、可靠地寻址溢出槽，这是确保程序正确性的基础技术。", "problem": "一个函数被编译到一个目标平台，其运行时堆栈向低地址方向增长。该机器模型提供了一个栈指针 $SP$ 和一个帧指针 $FP$，并且应用程序二进制接口 (ABI) 要求被调用者保存的寄存器必须溢出（spill）到函数活动记录的内存中。编译器的寄存器分配器可能会使用“基址加立即数”寻址模式插入溢出加载和存储指令，即形如 $[B + c]$ 的内存操作数，其中 $B$ 是一个基址寄存器，$c$ 是一个编译时常量偏移。\n\n考虑一个测试函数，它使用可变大小的自动存储（变长数组），这是通过一个动态分配内建函数实现的，该函数在运行时根据输入调整 $SP$，调整量依赖于输入。该函数具有以下结构：\n\n- 函数序言（Prologue）：通过将 $SP$ 从 $SP_0$ 更新为 $SP_1 = SP_0 - F$ 来分配一个大小为 $F$ 字节的固定大小帧。然后设置 $FP \\leftarrow SP_1$，并保持 $FP$ 直到函数尾声（epilogue）都不变。\n- 函数体（Body）：在一个包含 $k$ 次迭代的循环中，每次迭代都执行一次可变大小的分配，在第 $i$ 次迭代中将 $SP$ 改变 $-d_i$（其中 $d_i > 0$ 在编译时未知），执行一些可能触发溢出和重载的计算，然后通过将 $SP$ 恢复到其先前的值来释放动态分配，为下一次迭代做准备。\n- 函数尾声（Epilogue）：将 $SP$ 恢复到 $SP_0$ 并返回。\n\n假设在函数体的不同点，寄存器分配器必须将一个值溢出到函数帧中的一个槽位，并在稍后重新加载它。溢出指令必须引用一个内存位置，该位置在任何动态分配和释放序列之后，无论当前的 $SP$ 值如何，都必须是有效的，并且不得违反 ABI 不变式，例如保持动态分配区域的内容和布局。\n\n从基本原理出发，分析为帧的固定部分维护一个专用的 $FP$ 所引入的不变性，以及由于动态分配导致的 $SP$ 的可变性。设 $A_{\\text{spill}}$ 表示溢出指令用来访问其内存槽的有效地址。设 $A_{\\text{dyn}}(t)$ 表示在函数内部时刻 $t$ 的可变大小区域的顶部，并假设 $SP(t)$ 反映了这种可变性，而 $FP$ 在整个时间 $t$ 内保持不变。\n\n在上述约束条件下，以下哪种溢出槽管理策略能确保溢出加载和存储在动态帧增长的情况下保持正确？\n\nA. 在活动记录的静态大小部分内保留一个固定的溢出区域，并使用相对于 $FP$ 的操作数 $A_{\\text{spill}} = FP + c$ 来寻址溢出，其中 $c$ 是在函数序言中选择的编译时常量；将可变大小的分配严格放置在该固定区域之下，以便在函数序言之后 $FP$ 永远不会被调整。\n\nB. 使溢出槽相对于 $SP$，并在每次溢出和重载时，使用一个时变偏移量 $c(t)$ 重新计算 $A_{\\text{spill}} = SP + c(t)$，该偏移量取决于当前活动的动态分配；让寄存器分配器将 $SP(t)$ 作为一个虚拟寄存器来跟踪，并在每个程序点发出适当的立即数。\n\nC. 在每次溢出前插入一次栈保存，并在之后立即进行一次栈恢复，以便在每次溢出和重载期间，$SP$ 被临时重置为其在函数序言时的值；使用相对于 $SP$ 的寻址方式，其常量偏移量是为函数序言状态计算的。\n\nD. 依赖 ABI 提供的 $SP$ 下方的保证“红色区域”（red zone），并将溢出槽放置在该红色区域中，假设中断或信号不会干扰它，并且动态分配不会与之重叠；使用相对于 $SP$ 的寻址方式进入红色区域。\n\nE. 在线程局部存储中分配溢出槽，并按函数标识进行索引，这样栈的增长就不会影响它们的地址；让寄存器分配器将线程局部基指针视作溢出基址。\n\n选择唯一的最佳选项。", "solution": "该问题陈述在科学上是合理的、定义明确且客观的。它描述了编译器设计中的一个典型问题，涉及在存在动态堆栈分配（如 C 语言的 `alloca` 或变长数组）时对栈帧的管理。所有给定条件都是一致且充分的，足以从计算机体系结构和编译器构造的基本原理推导出解决方案。\n\n**从基本原理推导**\n\n核心要求是为寄存器溢出槽找到一种内存寻址方案，该方案能在整个函数执行期间提供一个稳定的地址，尽管栈指针 `$SP$` 会波动。可用的寻址模式是基址加立即数，即 `$[B + c]`，其中 `$B$` 是一个基址寄存器，$c$ 是一个编译时常量。\n\n问题定义了两个用于栈管理的主要指针寄存器：栈指针 `$SP$` 和帧指针 `$FP$`。\n1.  **栈指针, $SP$**: 根据定义，`$SP(t)$` 跟踪时刻 `$t$` 的栈顶。问题明确指出，`$SP$` 在运行时会根据一些在编译时未知的量（`$d_i$`）进行修改。因此，从编译器的静态角度来看，`$SP$` 的值是动态且不可预测的。如果我们使用 `$SP$` 作为基址寄存器 `$B$`，操作数 `$[SP + c]` 将引用内存地址 `$SP(t) + c$`。由于 `$SP(t)$` 是变化的，这个表达式并不表示一个固定的内存位置。在时刻 `$t_1$` 存储在地址 `$SP(t_1) + c$` 的值，无法在稍后的时刻 `$t_2$` 从 `$SP(t_2) + c$` 可靠地加载，如果 `$SP(t_1) \\neq SP(t_2)$`。因此，使用 `$SP$` 作为基址并带一个常量偏移来访问帧中的固定槽位，是根本不正确的。\n\n2.  **帧指针, $FP$**: 问题指明，在函数序言中，`$FP$` 被设置为指向栈帧的固定大小部分的基址（`$FP \\leftarrow SP_1$`），并且至关重要的是，`$FP$` *直到函数尾声都保持不变*。这使得 `$FP$` 在整个函数体执行期间成为一个不变量。它作为活动记录的一个稳定锚点或参考点。\n\n有了这个不变量，我们可以将所有需要稳定地址的数据放置在固定大小的帧部分内，地址范围从 `$SP_1$` 到 `$SP_0 - 1 = SP_1 + F - 1$`。这包括固定大小的局部变量、保存的被调用者保存寄存器，以及对本问题最重要的，寄存器溢出槽。任何这样的槽位都可以相对于稳定的 `$FP$` 进行寻址。地址 `$A_{\\text{spill}}$` 可以计算为 `$FP + c$`，其中 `$c$` 是进入固定帧的一个编译时常量偏移。由于 `$FP$` 是常量且 `$c$` 是常量，有效地址 `$FP + c$` 在函数执行期间是恒定的。对 `$[FP + c]` 的溢出和加载将始终访问相同的内存位置，无论 `$SP$` 如何因在更低地址发生的动态分配（`$SP(t) \\le FP$`）而波动。\n\n这就确立了一个原则：使用一个不变的帧指针来管理同时包含固定大小和可变大小组件的栈帧，是标准且正确的方法。\n\n**逐项分析**\n\n**A. 在活动记录的静态大小部分内保留一个固定的溢出区域，并使用相对于 $FP$ 的操作数 $A_{\\text{spill}} = FP + c$ 来寻址溢出，其中 $c$ 是在函数序言中选择的编译时常量；将可变大小的分配严格放置在该固定区域之下，以便在函数序言之后 $FP$ 永远不会被调整。**\n这个选项与从基本原理得出的推论完全一致。它使用不变量 `$FP$` 作为基址寄存器，使用编译时常量 `$c$` 作为偏移量。溢出槽被放置在帧的静态部分，该部分不受在更低地址发生的动态分配的干扰。这是教科书式的标准解决方案。\n**结论：正确**\n\n**B. 使溢出槽相对于 $SP$，并在每次溢出和重载时，使用一个时变偏移量 $c(t)$ 重新计算 $A_{\\text{spill}} = SP + c(t)$，该偏移量取决于当前活动的动态分配；让寄存器分配器将 $SP(t)$ 作为一个虚拟寄存器来跟踪，并在每个程序点发出适当的立即数。**\n这个选项在多个方面存在缺陷。首先，它提出了一个时变偏移量 `$c(t)$`。问题明确将寻址模式限制为 `$[B + c]`，其中 `$c$` 是一个*编译时常量*。时变偏移量不能作为立即数编码在指令中，并且需要运行时计算，这可能需要额外的寄存器和指令，违反了指定的寻址模式。其次，即使可能，与使用提供的 `$FP$` 相比，这也是一种极为复杂和低效的方法。\n**结论：错误**\n\n**C. 在每次溢出前插入一次栈保存，并在之后立即进行一次栈恢复，以便在每次溢出和重载期间，$SP$ 被临时重置为其在函数序言时的值；使用相对于 $SP$ 的寻址方式，其常量偏移量是为函数序言状态计算的。**\n这个策略试图使 `$SP$` 暂时稳定。在函数体中进行任何动态分配之前，`$SP$` 的“函数序言值”是 `$SP_1$`，它等于 `$FP$`。因此，这个选项通过执行类似以下的序列来有效地模拟相对于 `$FP$` 的寻址：保存当前 `$SP$`，设置 `$SP \\leftarrow FP$`，执行溢出/加载 `$[SP + c]`，恢复旧的 `$SP$`。虽然这在功能上可行（它使得 `$[SP + c]` 访问与 `$[FP + c]`相同的位置），但效率极低，为每一次溢出和加载都增加了几条指令。鉴于选项 A 提供了一个直接的、单指令的解决方案，这不是“最佳”策略。\n**结论：错误**\n\n**D. 依赖 ABI 提供的 $SP$ 下方的保证“红色区域”（red zone），并将溢出槽放置在该红色区域中，假设中断或信号不会干扰它，并且动态分配不会与之重叠；使用相对于 $SP$ 的寻址方式进入红色区域。**\n“红色区域”（red zone）是当前 `$SP$` 下方的一个小区域，叶函数（leaf function）可以在不递减 `$SP$` 的情况下使用它。然而，所描述的函数不是叶函数，而且关键是，它执行的动态分配会*明确地改变 `$SP$`*。当 `$SP$` 减少 `$d_i$` 时，旧的红色区域被消耗并成为已分配堆栈的一部分。任何存储在旧红色区域中相对于旧 `$SP$` 的数据，与新 `$SP$` 的偏移量将不同，并可能被覆盖。任何修改 `$SP$` 的操作都会使红色区域失效，因此这个策略对于本问题来说是根本上不成立的。\n**结论：错误**\n\n**E. 在线程局部存储中分配溢出槽，并按函数标识进行索引，这样栈的增长就不会影响它们的地址；让寄存器分配器将线程局部基指针视作溢出基址。**\n这种方法会提供一个稳定的内存地址，因为线程局部存储（TLS）不在栈上。然而，问题明确指出，“ABI 要求被调用者保存的寄存器必须溢出到函数活动记录的内存中”。活动记录（或栈帧）位于栈上。TLS 是一个不同的内存段。因此，这个策略违反了问题的一个主要约束。与基于栈的溢出相比，它也是一个重得多的机制，特别是在考虑可重入性和递归时。\n**结论：错误**\n\n根据分析，选项 A 是唯一一个在给定约束条件下正确、高效且规范地解决该问题的选项。", "answer": "$$\\boxed{A}$$", "id": "3667841"}, {"introduction": "当一个寄存器的值必须被保存时，溢出到内存并非唯一选择。本练习 [@problem_id:3667822] 展示了一个带有 `asm` 约束的场景，迫使我们考虑将值移动到空闲寄存器等替代方案。它还强调了将循环不变量的溢出操作提升到循环之外的强大优化，教导我们如何通过战术决策来最小化成本。", "problem": "您正在一个编译器后端中，围绕一个循环内的内联汇编 (asm) 块实现一个局部寄存器分配决策。目标机器有可分配的整数寄存器 $\\{r_0,r_1,r_2,r_3,r_4,r_5\\}$。该内联汇编块列出了一个销毁集 $\\{r_0,r_1\\}$，意味着在 asm 执行后，$r_0$ 和 $r_1$ 中的值是未定义的，并且必须被编译器视为已销毁。假设销毁操作适用于 asm 的整个持续时间，并且编译器无法检查 asm 的主体。在一个包含 $N$ 次迭代的循环中，紧邻 asm 之前的程序点，分配器已经分配了：\n- 变量 $x$ 在 $r_0$ 中，且 $x$ 在每次迭代中（循环内）紧随 asm 之后被使用；\n- 变量 $y$ 在 $r_2$ 中，且 $y$ 在每次迭代中都跨 asm 活跃，并在循环内部多次使用，因此期望在 asm 期间将 $y$ 保留在寄存器中；\n- 变量 $z$ 在 $r_1$ 中，且 $z$ 是循环不变量，在整个循环中都活跃，并且仅在循环退出后使用一次（在循环体内没有使用）；\n- 寄存器 $r_3$ 和 $r_4$ 保存着其他在循环内跨 asm 活跃的临时变量，因此不可用；\n- 寄存器 $r_5$ 是在 asm 边界上唯一未被销毁的空闲寄存器。\n\n假设一个简单且一致的成本模型：\n- 将寄存器存储到其溢出槽（一次溢出存储）的成本为 $c_s = 3$；\n- 从其溢出槽加载一个值（一次重载）的成本为 $c_l = 3$；\n- 在寄存器之间移动一个值（一次寄存器间移动）的成本为 $c_m = 1$。\n\n编译器必须确保关于活跃性和 asm 销毁集的语义正确性，并最小化整个循环的预期总成本。您可以假设跨 asm 的代码移动仅受销毁集和常规数据依赖的限制；除了所列销毁集所暗示的约束之外，没有其他别名或内存屏障约束。\n\n哪种策略是正确的，并且能在 $N$ 次迭代中最小化总预期成本？\n\nA. 在每个 asm 之前立即溢出 $x$ 和 $z$，并在每个 asm 之后立即重载它们。\n\nB. 在进入循环之前，将 $z$ 溢出一次，并将其重载推迟到循环后其单次使用之前；在每次迭代中，在 asm 之前将 $x$ 从 $r_0$ 移动到未被销毁的空闲寄存器 $r_5$ 中，使其在不溢出的情况下跨越 asm 生存。\n\nC. 在进入循环之前，将 $z$ 从 $r_1$ 移动到未被销毁的空闲寄存器 $r_5$ 中，并在整个循环中将其保留在那里；在每次迭代中，在 asm 之前溢出 $x$ 并立即重载它。\n\nD. 在每次迭代中，在 asm 之前溢出 $y$ 以释放 $r_2$，然后在 asm 之前将 $x$ 和 $z$ 都移动到未被销毁的寄存器中；在每次迭代中，在 asm 之后立即重载 $y$。\n\n您的答案应基于以下基本定义：(i) 如果一个变量可能在某个路径上被使用，之后才被重新定义，那么它在该程序点是活跃的，(ii) 对寄存器的 asm 销毁意味着在 asm 之后不能依赖其值，除非该值已保存在别处，(iii) 溢出操作将一个活跃值存储到内存中，而重载操作将其取回，从而相应地扩展或缩短活跃范围。使用这些定义来推理正确性和总成本。假设对于此成本分析，$N \\ge 1$ 是一个在编译时已知的正整数，但不要假设 $N$ 的任何特殊值。", "solution": "为确定最优策略，我们必须分析每个选项在 $N$ 次循环迭代中的正确性和总成本。成本使用给定的模型计算：溢出存储 ($c_s = 3$)、重载 ($c_l = 3$) 和寄存器移动 ($c_m = 1$)。\n\n核心问题是在 asm 块执行期间保留变量 $x$ (在 $r_0$ 中) 和 $z$ (在 $r_1$ 中) 的值，因为它们所在的寄存器被销毁。变量 $y$ 在 $r_2$ 中是安全的，因为 $r_2$ 未被销毁。我们有一个空闲、未被销毁的寄存器 $r_5$ 可用。\n\n**选项 A 分析**\n- **正确性**：此策略正确。在 asm 之前将两个变量都溢出到内存，并在之后重载它们，可以保留它们的值。\n- **成本**：此操作在每次迭代中执行。每次迭代的成本是为 $x$ 和 $z$ 各进行一次溢出存储和一次重载。每次迭代的总成本 = $c_s(x) + c_l(x) + c_s(z) + c_l(z) = 3 + 3 + 3 + 3 = 12$。总成本 = $12N$。\n\n**选项 B 分析**\n- **正确性**：此策略正确。对于循环不变量 $z$，在循环前将其溢出一次，并在循环后重载，是一种有效的优化（循环不变量代码外提）。对于 $x$，在 asm 之前将其移动到空闲寄存器 $r_5$ 可以正确地保留其值，因为 $r_5$ 未被销毁。asm 之后，该值在 $r_5$ 中可供使用。\n- **成本**：$z$ 的溢出发生一次（成本 $c_s = 3$）。$z$ 的重载发生一次（成本 $c_l = 3$）。在循环内部，$x$ 的移动发生 $N$ 次（每次迭代成本 $c_m = 1$）。总成本 = $c_s(z) + N \\times c_m(x) + c_l(z) = 3 + N \\times 1 + 3 = N + 6$。\n\n**选项 C 分析**\n- **正确性**：此策略正确。在循环前将循环不变量 $z$ 移动到空闲寄存器 $r_5$ 可以保留其在整个循环中的值。然而，这占用了 $r_5$。由于循环内没有可用的空闲寄存器，$x$ 必须在每次迭代中溢出到内存并重载。\n- **成本**：$z$ 的移动在循环前发生一次（成本 $c_m = 1$）。在循环内部，$x$ 被溢出和重载 $N$ 次。每次迭代中 $x$ 的成本为 $c_s + c_l = 3 + 3 = 6$。总成本 = $c_m(z) + N \\times (c_s(x) + c_l(x)) = 1 + N \\times 6 = 6N + 1$。\n\n**选项 D 分析**\n- **正确性**：此策略正确但效率低下。它不必要地溢出了 $y$，而 $y$ 已经在一个安全的寄存器 ($r_2$) 中，仅仅是为了释放一个寄存器。这与将像 $y$ 这样的常用变量保留在寄存器中的目标相悖。\n- **成本**：在每次迭代中，它溢出 $y$ ($c_s=3$)，移动 $x$ ($c_m=1$)，移动 $z$ ($c_m=1$)，并重载 $y$ ($c_l=3$)。每次迭代的总成本 = $3 + 1 + 1 + 3 = 8$。总成本 = $8N$。\n\n**成本比较**\n比较 $N \\ge 1$ 的总成本：\n- 成本(A) = $12N$\n- 成本(B) = $N + 6$\n- 成本(C) = $6N + 1$\n- 成本(D) = $8N$\n\n比较 B 和 C：$N + 6$ 与 $6N + 1$。当 $N=1$ 时，两个成本都是 $7$。当 $N > 1$ 时，$N + 6 < 6N + 1$（因为 $5 < 5N$）。所以 B 优于或等于 C。\n将 B 与 A 和 D 比较：对于所有 $N \\ge 1$，$N+6$ 明显小于 $12N$ 和 $8N$。\n\n策略 B 是最优的。它正确地对 $z$ 的溢出/重载应用了循环不变量代码外提，并通过利用唯一的空闲寄存器，对循环变量 $x$ 使用了成本更低的寄存器移动操作。", "answer": "$$\\boxed{B}$$", "id": "3667822"}, {"introduction": "通常，编译器在必须进行溢出时，可以选择溢出哪个变量。错误的选择可能会不必要地降低程序性能。本练习 [@problem_id:3667851] 介绍了一种复杂的、数据驱动的方法，它利用性能剖析得出的路径概率来选择能够最小化预期性能开销的溢出候选者，从而展示了性能剖析制导优化（PGO）的威力。", "problem": "一个为具有 $R$ 个体系结构寄存器的目标平台设计的编译器，在一个控制流图（CFG）上使用全局寄存器分配。在某个特定的程序点，活跃集的大小为 $L = R + 1$，因此必须溢出一个活跃范围。程序结构是一个动态频繁的单路多分支（例如 switch 语句），它创建了 $3$ 条不相交的、最终重新汇合的无环路径。对于函数的单次调用，基于剖析的路径概率为 $p_1 = \\frac{4}{5}$、$p_2 = \\frac{3}{20}$ 和 $p_3 = \\frac{1}{20}$，根据构造，它们满足 $p_1 + p_2 + p_3 = 1$。活跃性分析确定了三个候选活跃范围，表示为 $v_A$、$v_B$ 和 $v_C$，从正确性的角度来看，它们是同等可溢出的。然而，由于使用密度的不同，它们的动态内存操作计数（由溢出及后续沿路径的重载所引起的加载和存储的总和）因路径而异。设 $c_i(v)$ 表示如果活跃范围 $v \\in \\{v_A, v_B, v_C\\}$ 被溢出，在路径 $i \\in \\{1,2,3\\}$ 上执行的内存操作数。测得的计数如下：\n$$\nc_1(v_A) = 30,\\quad c_2(v_A) = 2,\\quad c_3(v_A) = 1,\n$$\n$$\nc_1(v_B) = 18,\\quad c_2(v_B) = 6,\\quad c_3(v_B) = 6,\n$$\n$$\nc_1(v_C) = 10,\\quad c_2(v_C) = 12,\\quad c_3(v_C) = 12.\n$$\n假设单次函数调用以概率 $p_i$ 选择一条路径 $i$，并且在该路径上，所选的溢出确定性地产生 $c_i(v)$ 次内存操作。一个路径概率加权的溢出启发式算法倾向于溢出那些由溢出引起的内存操作偏向于冷路径的活跃范围。使用离散随机变量的期望定义，推导出每个候选溢出的期望内存操作数，并根据路径概率加权的启发式算法选择使期望最小化的候选项。作为对比，一个朴素的路径无关启发式算法会忽略剖析信息，并使用 $3$ 条路径的均匀平均值来选择溢出对象。\n\n在每个启发式算法做出选择后，计算朴素启发式算法的期望内存操作数与路径概率加权启发式算法的期望内存操作数之比。将最终比率表示为单个实数。无需四舍五入。", "solution": "该问题已经过验证，被认为是编译器优化领域一个有效且适定（well-posed）的问题。\n\n**已知条件：**\n- 体系结构寄存器数量：$R$。\n- 活跃集大小：$L = R + 1$。\n- 需要的溢出数量：$1$。\n- 不相交路径数量：$3$。\n- 路径概率：$p_1 = \\frac{4}{5}$，$p_2 = \\frac{3}{20}$，$p_3 = \\frac{1}{20}$。\n- 待溢出的候选活跃范围：$v_A$、$v_B$、$v_C$。\n- 候选项 $v$ 在路径 $i$ 上的动态内存操作计数 $c_i(v)$：\n  - $c_1(v_A) = 30$，$c_2(v_A) = 2$，$c_3(v_A) = 1$。\n  - $c_1(v_B) = 18$，$c_2(v_B) = 6$，$c_3(v_B) = 6$。\n  - $c_1(v_C) = 10$，$c_2(v_C) = 12$，$c_3(v_C) = 12$。\n\n**问题陈述：**\n目标是计算由朴素的路径无关启发式算法所做选择导致的期望内存操作数，与由最优的路径概率加权启发式算法所做选择导致的期望内存操作数之比。\n\n**1. 路径概率加权启发式算法分析**\n\n此启发式算法选择使期望内存操作数最小化的溢出候选项。溢出一个活跃范围 $v$ 的期望内存操作数，记为 $E[C(v)]$，计算方法是每条路径上的代价乘以采用该路径的概率，然后求和。公式为：\n$$E[C(v)] = \\sum_{i=1}^{3} p_i \\cdot c_i(v)$$\n\n我们计算每个候选活跃范围（$v_A$, $v_B$, $v_C$）的期望代价。为便于计算，我们注意到 $p_1 = \\frac{4}{5} = \\frac{16}{20}$。\n\n对于候选项 $v_A$：\n$$E[C(v_A)] = p_1 c_1(v_A) + p_2 c_2(v_A) + p_3 c_3(v_A) = \\left(\\frac{16}{20}\\right)(30) + \\left(\\frac{3}{20}\\right)(2) + \\left(\\frac{1}{20}\\right)(1)$$\n$$E[C(v_A)] = \\frac{480 + 6 + 1}{20} = \\frac{487}{20} = 24.35$$\n\n对于候选项 $v_B$：\n$$E[C(v_B)] = p_1 c_1(v_B) + p_2 c_2(v_B) + p_3 c_3(v_B) = \\left(\\frac{16}{20}\\right)(18) + \\left(\\frac{3}{20}\\right)(6) + \\left(\\frac{1}{20}\\right)(6)$$\n$$E[C(v_B)] = \\frac{288 + 18 + 6}{20} = \\frac{312}{20} = 15.6$$\n\n对于候选项 $v_C$：\n$$E[C(v_C)] = p_1 c_1(v_C) + p_2 c_2(v_C) + p_3 c_3(v_C) = \\left(\\frac{16}{20}\\right)(10) + \\left(\\frac{3}{20}\\right)(12) + \\left(\\frac{1}{20}\\right)(12)$$\n$$E[C(v_C)] = \\frac{160 + 36 + 12}{20} = \\frac{208}{20} = 10.4$$\n\n比较期望代价：$E[C(v_C)] = 10.4 < E[C(v_B)] = 15.6 < E[C(v_A)] = 24.35$。\n路径概率加权的启发式算法选择期望代价最小的候选项，即 $v_C$。此最优选择的期望内存操作数为 $E_{opt} = E[C(v_C)] = 10.4$。\n\n**2. 朴素的路径无关启发式算法分析**\n\n此启发式算法忽略给定的路径概率，而是使用 $3$ 条路径的均匀平均值。这等价于假设一个均匀概率分布，其中 $p'_1 = p'_2 = p'_3 = \\frac{1}{3}$。该启发式算法为每个候选项计算平均代价 $Avg(v)$：\n$$Avg(v) = \\frac{1}{3} \\sum_{i=1}^{3} c_i(v) = \\frac{c_1(v) + c_2(v) + c_3(v)}{3}$$\n\n对于候选项 $v_A$：\n$$Avg(v_A) = \\frac{30 + 2 + 1}{3} = \\frac{33}{3} = 11$$\n\n对于候选项 $v_B$：\n$$Avg(v_B) = \\frac{18 + 6 + 6}{3} = \\frac{30}{3} = 10$$\n\n对于候选项 $v_C$：\n$$Avg(v_C) = \\frac{10 + 12 + 12}{3} = \\frac{34}{3} \\approx 11.33$$\n\n比较平均代价：$Avg(v_B) = 10 < Avg(v_A) = 11 < Avg(v_C) \\approx 11.33$。\n朴素启发式算法选择平均代价最小的候选项，即 $v_B$。\n\n问题要求的是朴素启发式算法做出选择后所产生的*实际*期望内存操作数。为了求得此值，我们必须使用实际的路径概率（$p_1, p_2, p_3$）来评估溢出 $v_B$ 的真实期望代价。这个值在第一部分已经计算过了。\n朴素启发式算法所做选择的期望代价为 $E_{naive\\_choice} = E[C(v_B)] = 15.6$。\n\n**3. 比率计算**\n\n最后一步是计算朴素启发式算法的期望代价与路径概率加权启发式算法的期望代价之比。\n$$Ratio = \\frac{E_{naive\\_choice}}{E_{opt}}$$\n$$Ratio = \\frac{15.6}{10.4}$$\n\n为了精确计算，我们使用前面推导出的分数形式：\n$$E_{naive\\_choice} = E[C(v_B)] = \\frac{312}{20}$$\n$$E_{opt} = E[C(v_C)] = \\frac{208}{20}$$\n$$Ratio = \\frac{312/20}{208/20} = \\frac{312}{208}$$\n我们可以化简这个分数：\n$$\\frac{312}{208} = \\frac{156}{104} = \\frac{78}{52} = \\frac{39}{26} = \\frac{3}{2}$$\n作为一个实数，该比率为 $1.5$。这表明，与最优的、基于剖析的启发式算法所做的选择相比，朴素启发式算法所做的选择预计会产生多 $50\\%$ 的内存操作。", "answer": "$$ \\boxed{1.5} $$", "id": "3667851"}]}