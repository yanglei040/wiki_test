{"hands_on_practices": [{"introduction": "深入理解超块和超指令块形成的第一步是掌握其核心机制：if-conversion。这个过程将程序中的控制依赖关系转化为基于“谓词”（predicates）的数据依赖关系，从而消除分支指令，形成一个线性的指令序列。本练习 ([@problem_id:3673048]) 将引导你为一个给定的控制流图（CFG）推导守护谓词（guard predicates），这是构建超指令块的基础。", "problem": "一个用于谓词化指令集架构 (ISA) 的编译器，试图通过 if-转换，从一个控制流图 (CFG) 内的多个候选菱形结构中形成一个单一超指令块。给定一个结构化的控制流图 (CFG)，其基本块和边描述如下。有一个入口块 $S$，它流向一个基于条件 $c_1$ 的条件分支，其真边指向块 $A$，假边指向块 $B$。从块 $A$ 出发，有一个基于条件 $c_2$ 的条件分支，其真边指向块 $C$，假边指向块 $D$。从块 $B$ 出发，有一个基于条件 $c_3$ 的条件分支，其真边指向块 $E$，假边指向块 $F$。所有块 $C, D, E, F$ 都流向一个单一的连接块 $J$，该连接块再流向出口。假设除了内部计算外，所有块 $A, B, C, D, E, F$ 都没有副作用，并且可以被安全地谓词化；同时假设在数据依赖和内存安全条件下，推测执行是合法的，并且连接块 $J$ 后支配所有块 $A, B, C, D, E, F$。\n\n仅使用控制依赖、支配/后支配的基本原理以及谓词执行的标准 if-转换语义（不假设任何特殊的快捷公式），通过消除内部控制流并代之以谓词，形成一个包含块 $A, B, C, D, E, F$ 的单入口超指令块。设入口谓词为 $1$ (真)。定义守卫谓词 $p_A, p_B, p_C, p_D, p_E, p_F$，它们分别精确地指示了在 if-转换后，块 $A, B, C, D, E, F$ 中的指令何时被提交。令 $p_1, \\dots, p_6$ 按顺序 $(p_A, p_B, p_C, p_D, p_E, p_F)$ 对应。\n\n此外，按如下方式构建由 if-转换过程引出的谓词依赖图：当且仅当 $p_Y$ 是通过在构建过程中沿着遇到的某一个条件分支对 $p_X$ 进行精化而形成时（即，在从 $S$ 出发的唯一简单路径上，由一系列求值条件所引出的精化关系中，$p_Y$ 是 $p_X$ 的直接子节点），则存在一条有向边 $p_X \\to p_Y$。令 $d$ 为集合 $\\{p_A, p_B, p_C, p_D, p_E, p_F\\}$ 中此类有向边的总数。\n\n请以行矩阵 $\\big(p_1\\;p_2\\;p_3\\;p_4\\;p_5\\;p_6\\;d\\big)$ 的形式给出最终答案，其中每个 $p_i$ 都必须是基于 $\\{c_1, c_2, c_3\\}$ 且仅使用 $\\land$, $\\lor$, 和 $\\lnot$ 的简化布尔表达式，$d$ 是一个精确整数。无需四舍五入。不要包含任何单位。", "solution": "问题陈述已经过验证，被认为是编译器理论领域内一个适定且有科学依据的问题。它提供了一个关于控制流图 (CFG) 的完整且一致的描述，并要求基于基本原理，推导用于 if-转换的守卫谓词，并分析由此产生的谓词依赖图。\n\n任务是通过应用 if-转换，从给定的 CFG 结构中形成一个单一超指令块。此过程将控制依赖转换为对谓词的数据依赖。基本块的守卫谓词决定了该块内的指令结果是否会被提交。一个块的谓词为真，当且仅当原始程序中的控制流会到达该块。\n\nCFG 的结构如下：\n1. 块 $S$ 基于条件 $c_1$ 进行分支。真路径通向块 $A$，假路径通向块 $B$。\n2. 块 $A$ 基于条件 $c_2$ 进行分支。真路径通向块 $C$，假路径通向块 $D$。\n3. 块 $B$ 基于条件 $c_3$ 进行分支。真路径通向块 $E$，假路径通向块 $F$。\n4. 块 $C$, $D$, $E$, 和 $F$ 全部汇合于一个单一的连接块 $J$。\n\n我们现在将为每个块 $A, B, C, D, E, F$ 推导守卫谓词。这些谓词表示为 $p_A, p_B, p_C, p_D, p_E, p_F$，对应于 $p_1, \\dots, p_6$。\n\n1.  **块 $A$ 的谓词 ($p_1 = p_A$):**\n    如果从 $S$ 出发的控制流选择了基于 $c_1$ 的分支的真边，则块 $A$ 被执行。该块入口点的谓词是 $1$。因此，执行 $A$ 的条件就是 $c_1$ 为真。\n    $$p_A = 1 \\land c_1 = c_1$$\n\n2.  **块 $B$ 的谓词 ($p_2 = p_B$):**\n    如果从 $S$ 出发的控制流选择了基于 $c_1$ 的分支的假边，则块 $B$ 被执行。这意味着条件 $c_1$ 必须为假。\n    $$p_B = 1 \\land (\\lnot c_1) = \\lnot c_1$$\n\n3.  **块 $C$ 的谓词 ($p_3 = p_C$):**\n    仅当控制流首先到达块 $A$，然后选择从 $A$ 出发的基于 $c_2$ 的分支的真边时，块 $C$ 才被执行。到达 $C$ 的条件是到达其前驱 $A$ 的条件与从 $A$ 出发的分支条件的合取。\n    $$p_C = p_A \\land c_2 = c_1 \\land c_2$$\n\n4.  **块 $D$ 的谓词 ($p_4 = p_D$):**\n    如果控制流到达块 $A$，然后选择基于 $c_2$ 的分支的假边，则块 $D$ 被执行。这要求 $c_2$ 为假。\n    $$p_D = p_A \\land (\\lnot c_2) = c_1 \\land (\\lnot c_2)$$\n\n5.  **块 $E$ 的谓词 ($p_5 = p_E$):**\n    如果控制流首先到达块 $B$，然后选择基于 $c_3$ 的分支的真边，则块 $E$ 被执行。这要求 $c_3$ 为真。\n    $$p_E = p_B \\land c_3 = (\\lnot c_1) \\land c_3$$\n\n6.  **块 $F$ 的谓词 ($p_6 = p_F$):**\n    如果控制流到达块 $B$，然后选择基于 $c_3$ 的分支的假边，则块 $F$ 被执行。这要求 $c_3$ 为假。\n    $$p_F = p_B \\land (\\lnot c_3) = (\\lnot c_1) \\land (\\lnot c_3)$$\n\n因此，谓词如下：\n$p_1 = c_1$\n$p_2 = \\lnot c_1$\n$p_3 = c_1 \\land c_2$\n$p_4 = c_1 \\land (\\lnot c_2)$\n$p_5 = (\\lnot c_1) \\land c_3$\n$p_6 = (\\lnot c_1) \\land (\\lnot c_3)$\n\n接下来，我们必须构建谓词依赖图并找出边的数量 $d$。问题定义了一条有向边 $p_X \\to p_Y$ 存在，“当且仅当 $p_Y$ 是通过沿着恰好一个条件分支对 $p_X$ 进行精化而形成的”。这对应于块 $Y$ 是块 $X$ 的直接控制流后继，并且 $p_Y = p_X \\land (\\text{分支条件})$ 的情况。我们被要求计算这类边的数量 $d$，其中源谓词和目标谓词都在集合 $\\{p_A, p_B, p_C, p_D, p_E, p_F\\}$ 中。\n\n让我们检查这些精化关系的谓词推导过程：\n- $p_C = c_1 \\land c_2 = p_A \\land c_2$。因此，$p_C$ 是 $p_A$ 的一个精化。这产生了边 $p_A \\to p_C$。$p_A$ 和 $p_C$ 都在集合中。\n- $p_D = c_1 \\land (\\lnot c_2) = p_A \\land (\\lnot c_2)$。因此，$p_D$ 是 $p_A$ 的一个精化。这产生了边 $p_A \\to p_D$。$p_A$ 和 $p_D$ 都在集合中。\n- $p_E = (\\lnot c_1) \\land c_3 = p_B \\land c_3$。因此，$p_E$ 是 $p_B$ 的一个精化。这产生了边 $p_B \\to p_E$。$p_B$ 和 $p_E$ 都在集合中。\n- $p_F = (\\lnot c_1) \\land (\\lnot c_3) = p_B \\land (\\lnot c_3)$。因此，$p_F$ 是 $p_B$ 的一个精化。这产生了边 $p_B \\to p_F$。$p_B$ 和 $p_F$ 都在集合中。\n\n谓词 $p_A$ 和 $p_B$ 是初始谓词 $1$ 的精化，而初始谓词 $1$ 不在指定的集合中。集合 $\\{p_A, \\dots, p_F\\}$ 中没有其他谓词是另一个谓词的精化。例如，$p_C = c_1 \\land c_2$ 不是 $p_B = \\lnot c_1$ 的精化。\n\n限制在指定的节点集内，谓词依赖图有以下四条边：\n1. $p_A \\to p_C$\n2. $p_A \\to p_D$\n3. $p_B \\to p_E$\n4. $p_B \\to p_F$\n\n因此，有向边的总数 $d$ 为 $4$。\n\n最终答案是行矩阵 $\\big(p_1\\;p_2\\;p_3\\;p_4\\;p_5\\;p_6\\;d\\big)$，它汇集了推导出的谓词和边的数量。", "answer": "$$ \\boxed{ \\begin{pmatrix} c_1  \\lnot c_1  c_1 \\land c_2  c_1 \\land (\\lnot c_2)  (\\lnot c_1) \\land c_3  (\\lnot c_1) \\land (\\lnot c_3)  4 \\end{pmatrix} } $$", "id": "3673048"}, {"introduction": "理论上，if-conversion 是一个强大的工具，但在实践中，我们必须处理各种复杂情况以保证程序语义的正确性。并非所有指令都可以被谓词化，像函数调用、内存栅栏（memory fences）和易失性内存访问（volatile memory access）等操作需要特殊处理。本练习 ([@problem_id:3673046]) 模拟了这些真实世界的挑战，要求你在一个假设的机器模型下，判断不同超指令块形成方案的合法性，从而加深对转换正确性约束的理解。", "problem": "考虑一个控制流图（CFG）中可进行 if-转换的直线区域候选。入口块 $B_0$ 计算一个布尔谓词 $p$，如果 $p$ 为真，则分支到 $B_1$，否则分支到 $B_2$。这些块包含以下操作（伪操作按每个块内的程序顺序列出；下标表示块局部临时变量，并非全局唯一）：\n\n- $B_0$：从先前可用的值计算 $p$；如果 $p$ 为真，则根据 $p$ 分支到 $B_1$，否则到 $B_2$。\n- $B_1$：\n  - $v_1 \\leftarrow \\text{volatile\\_load}[A]$ （从地址 $A$ 进行的一次 volatile 加载）\n  - fence （一个内存屏障）\n  - $t_1 \\leftarrow v_1 + c$ （与常量 $c$ 的纯算术运算）\n  - call $f(t_1)$ （一个可能写入内存并可能引发同步异常的函数调用）\n- $B_2$：\n  - $u_2 \\leftarrow \\text{load}[B]$ （从地址 $B$ 进行的一次 non-volatile 加载）\n  - $z_2 \\leftarrow d / u_2$ （一个可能因除零而陷阱的整数除法，其中 $d$ 为常量）\n- $B_3$（$B_1$ 和 $B_2$ 的合并点）：\n  - $\\text{res} \\leftarrow \\phi(t_1, z_2)$ （分别从 $B_1$ 或 $B_2$ 中选择）\n  - $\\text{store}[C] \\leftarrow \\text{res}$\n\n假设以下机器和语言模型，这些是您唯一可以使用的既定事实：\n\n- 指令集架构（ISA）支持对所有以下类别的非控制指令进行谓词化：算术、non-volatile 加载和存储、以及整数除法。当一条谓词化指令的谓词求值为假时，该指令没有架构效果，也不能引发任何同步异常。\n- 函数调用和内存屏障是不可谓词化的。调用可能执行任意的内存效应，并可能引发异常。屏障强制所有在程序顺序上位于屏障之前的内存操作，在任何程序顺序上位于屏障之后的内存操作之前变得可见；编译器不得在程序顺序上跨越屏障重排序任何内存操作。\n- Volatile 内存操作是可观察事件：在任何实际执行的路径上，它们都不得相对于其他 volatile 操作或屏障在程序顺序上被推测执行、消除或重排序。Non-volatile 加载和算术运算可以被推测执行，前提是它们是谓词化的，并且当它们原始的动态实例本不会执行时，它们的谓词为假，因为谓词为假的指令没有效果且不引发异常。\n- 超块（hyperblock）是一个通过 if-转换和（如果需要）尾部复制形成的单入口区域，其目的是通过谓词化消除区域内的内部控制依赖。该转换必须保留所有可观察的行为，包括内存效应、volatile 访问顺序、屏障和精确异常。\n\n在上述假设下，判断以下哪个候选的超块构造在语义上是合法的。每个选项描述了超块 $H$（紧接在 $B_0$ 之后）内部包含哪些代码，以及其余操作如何安排。\n\nA. 通过 if-转换将以下操作合并成一个单一的线性谓词化序列来形成 $H$：谓词为 $p$ 的 volatile 加载 $v_1 \\leftarrow \\text{volatile\\_load}[A]$，谓词为 $\\lnot p$ 的 non-volatile 加载 $u_2 \\leftarrow \\text{load}[B]$，谓词为 $p$ 的算术运算 $t_1 \\leftarrow v_1 + c$，以及谓词为 $\\lnot p$ 的除法 $z_2 \\leftarrow d / u_2$。在屏障和调用之前结束 $H$。在 $H$ 之后，根据 $p$ 进行分支：如果 $p$ 为真，则执行屏障然后调用 $f(t_1)$，并接续到 $B_3$；如果 $\\lnot p$ 为真，则直接跳到 $B_3$。\n\nB. 与 A 类似，但也将屏障和调用包含在 $H$ 内部，尝试将屏障和调用都以 $p$ 为谓词，以便当 $\\lnot p$ 为真时不执行它们。\n\nC. 像 A 一样形成 $H$，但在 $H$ 的线性顺序中，将来自 $B_2$ 的、以 $\\lnot p$ 为谓词的操作（non-volatile 加载和除法）调度在以 $p$ 为谓词的 volatile 加载和（位于 $H$ 之后的）屏障之间。也就是说，$H$ 内部的顺序为：以 $p$ 为谓词的 $v_1 \\leftarrow \\text{volatile\\_load}[A]$，然后是以 $\\lnot p$ 为谓词的 $u_2 \\leftarrow \\text{load}[B]$，然后是以 $\\lnot p$ 为谓词的 $z_2 \\leftarrow d / u_2$。之后（在 $H$ 之外）是通过 $H$ 之后基于 $p$ 的分支来保护的屏障和调用。\n\nD. 将 volatile 加载 $v_1 \\leftarrow \\text{volatile\\_load}[A]$ 提升到 $p$ 的计算之前，即移入 $B_0$ 中，在执行时不用 $p$ 来保护它（因为 $p$ 尚不可用），意图是通过使其所有使用都以 $p$ 为谓词来在之后抵消其影响。\n\nE. 像 A 一样将屏障和调用保持在 $H$ 之外，但尝试通过将 $z_2 \\leftarrow d / u_2$ 替换为以 $\\lnot p$ 为谓词的除法，并在除数为零时条件分支到一个异常处理程序，来将 $B_2$ 中的潜在陷阱包含在 $H$ 内部；该异常处理程序是 $H$ 的一个出口。\n\n选择所有合法的选项，并基于关于谓词化、volatile 和屏障语义、调用以及精确异常的基本原则来证明您的选择。用所有正确选项的字母作答。", "solution": "问题陈述提供了一个控制流图片段和一套用于假设机器的规则，并要求确定几种提议的用于形成超块的转换的合法性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- **控制流图 (CFG)：**\n  - 块 $B_0$：计算一个布尔谓词 $p$，如果 $p$ 为真，则分支到 $B_1$，否则到 $B_2$。\n  - 块 $B_1$ (真路径):\n    1. $v_1 \\leftarrow \\text{volatile\\_load}[A]$\n    2. fence\n    3. $t_1 \\leftarrow v_1 + c$\n    4. call $f(t_1)$ (可能写入内存，可能引发同步异常)\n  - 块 $B_2$ (假路径):\n    1. $u_2 \\leftarrow \\text{load}[B]$\n    2. $z_2 \\leftarrow d / u_2$ (可能因除零而陷阱)\n  - 块 $B_3$ (合并点):\n    1. $\\text{res} \\leftarrow \\phi(t_1, z_2)$\n    2. $\\text{store}[C] \\leftarrow \\text{res}$\n- **机器和语言模型：**\n  - **谓词化：** 支持对算术、non-volatile 加载/存储和整数除法进行谓词化。谓词为假的指令没有架构效果，也不能引发同步异常。\n  - **不可谓词化：** 函数调用和内存屏障不可谓词化。\n  - **调用：** 可能有任意的内存效应并引发异常。\n  - **屏障：** 强制内存操作的程序顺序。内存操作不能跨越屏障重排序。\n  - **Volatile 操作：** 是可观察事件。它们不得在任何执行路径上相对于其他 volatile 操作或屏障被推测执行、消除或重排序。\n  - **推测执行：** 如果 non-volatile 加载和算术运算是谓词化的且其谓词为假，则可以被推测执行。\n  - **超块定义：** 通过 if-转换形成的单入口区域，通过谓词化消除内部控制依赖。\n  - **合法性标准：** 转换必须保留所有可观察的行为（内存效应、volatile 访问顺序、屏障、精确异常）。\n\n**步骤 2：使用提取的已知条件进行验证**\n问题陈述在编译器设计和计算机体系结构的原则上是科学合理的。if-转换、超块、谓词化、volatile 内存、内存屏障和精确异常等概念在该领域是标准的。所提供的规则是一个一致且连贯的公理化模型，描述了一个合理的指令集架构。这个问题是定义良好的，要求根据这套规则来确定几个具体选项的合法性。语言是客观和技术性的。该问题没有指令中列出的缺陷。\n\n**步骤 3：结论和行动**\n该问题是**有效的**。解决方案将通过对照所提供的规则分析每个选项来展开。\n\n### 推导与选项分析\n\n问题的核心是在给定约束下应用 if-转换的规则来形成一个合法的超块。一个转换是合法的，当且仅当它为所有可能的执行路径保留了原始程序的可观察语义。关键约束是：\n1.  **不可谓词化的指令：** `fence` 和 `call f(t_1)` 不能包含在谓词化序列中。它们必须通过在超块之后重新引入控制流（一个基于 $p$ 的分支）来处理。\n2.  **Volatile 语义：** `volatile_load[A]` 是一个可观察事件。它必须仅在 $p$ 为真时执行。它不能被推测执行（无条件执行）。在真路径上，它相对于 `fence` 的顺序必须被保留。\n3.  **异常语义：** 除法 `d / u_2` 可能会陷阱。这个陷阱必须仅在 $p$ 为假且 $u_2$ 为零时发生。谓词化指令模型（指出谓词为假的指令不能引发异常）是确保这一点的机制。\n\n**选项 A：通过 if-转换加载和算术运算来形成 $H$，将屏障和调用置于一个分支之下。**\n\n- **提议的转换：**\n  - 形成一个超块 $H$，包含：\n    - $[p] \\quad v_1 \\leftarrow \\text{volatile\\_load}[A]$\n    - $[\\lnot p] \\quad u_2 \\leftarrow \\text{load}[B]$\n    - $[p] \\quad t_1 \\leftarrow v_1 + c$\n    - $[\\lnot p] \\quad z_2 \\leftarrow d / u_2$\n  - 在 $H$ 之后，使用一个基于 $p$ 的分支：\n    - 如果为真，执行 `fence` 然后 `call f(t_1)`，接着进入 $B_3$。\n    - 如果为假，直接进入 $B_3$。\n- **分析：**\n  - **Volatile 加载：** `volatile_load[A]` 以 $p$ 为谓词。它只会在原始的 $p$-真路径被采用时执行。它没有被推测执行。这是合法的。\n  - **屏障和调用：** 这些不可谓词化的指令被正确地放置在超块之后由一个新分支创建的 $p$-真路径上。这保留了它们原始的执行条件。这是一种称为“控制流恢复”的标准技术。\n  - **内存排序：** 在原始程序中，`volatile_load[A]` 在程序顺序上位于 `fence` 之前。在转换后的代码中，如果 $p$ 为真，执行的操作序列是 $H$ *内部* 的谓词化 `volatile_load`，然后是 $H$ *之后* 的 `fence`。顺序得以保留。\n  - **异常：** 除法 $z_2 \\leftarrow d / u_2$ 以 $\\lnot p$ 为谓词。根据规则，它只有在其谓词为真时才能陷阱。这意味着陷阱只能在 $p$ 为假时发生，这与原始程序的行为相匹配。异常语义得以保留。\n- **结论：** 此转换遵守了所有给定的机器约束。所有操作都得到了正确处理。**正确**。\n\n**选项 B：与 A 类似，但对屏障和调用进行谓词化。**\n\n- **提议的转换：** 将 `fence` 和 `call f(t_1)` 包含在超块 $H$ 内部，并以 $p$ 为谓词。\n- **分析：** 问题陈述明确规定了一条规则：“函数调用和内存屏障是不可谓词化的。” 此选项直接违反了给定机器模型的这一基本假设。\n- **结论：** 根据问题的明确规则，该转换是非法的。**不正确**。\n\n**选项 C：像 A 一样形成 $H$，但交错来自 $B_1$ 和 $B_2$ 的操作。**\n\n- **提议的转换：** 为超块 $H$ 提议了一个特定的指令调度：\n  1. $[p] \\quad v_1 \\leftarrow \\text{volatile\\_load}[A]$\n  2. $[\\lnot p] \\quad u_2 \\leftarrow \\text{load}[B]$\n  3. $[\\lnot p] \\quad z_2 \\leftarrow d / u_2$\n- **分析：** 此选项是选项 A 的一个更具体的实例。问题在于这种特定的排序是否合法。需要检查的关键约束是内存操作相对于 `fence` 的排序。原始顺序是 `volatile_load[A]`，然后是 `fence`。在这里，`load[B]` 及其后续除法的指令在文本上被放置在 `volatile_load` 和 `fence`（如果 $p$ 为真，则在 $H$ 之后执行）之间。\n  - 规则规定：“编译器不得在程序顺序上跨越屏障重排序任何内存操作”。\n  - 我们来分析两条执行路径：\n    - 如果 $p$ 为真：执行的操作序列是 `volatile_load[A]` ... `fence`。`load[B]` 的谓词为假，因此成为一个空操作（no-op）；它不构成一个已执行的内存操作。`volatile_load[A]` 和 `fence` 之间的基本顺序得以保留。\n    - 如果 $p$ 为假：`volatile_load[A]` 是一个空操作。`load[B]` 执行。超块后的基于 $p$ 的分支不会被采纳，因此 `fence` 不会执行。在这种情况下，`load[B]` 在原始程序中从未与 `fence` 有序，因为它们位于互斥的路径上。\n  - 该转换是合法的，因为它保留了原始程序中存在的所有排序依赖关系。在 $p$-真路径上的关键依赖 `volatile_load[A]` $\\rightarrow$ `fence` 得以维持。在它们之间放置谓词关闭的指令并不会违反这一点。\n- **结论：** 这种调度是 A 中策略的合法实现。**正确**。\n\n**选项 D：将 volatile 加载提升到 $p$ 的计算之前。**\n\n- **提议的转换：** 将 `volatile_load[A]` 从 $B_1$ 移到 $B_0$ 中，在计算 $p$ 之前无条件执行。\n- **分析：** 关于 volatile 操作的规则指出：“它们不得被推测执行”。推测执行是在知道一条指令是否在执行路径上之前就执行它。将 volatile 加载从 $p$-真分支提升到在 $B_0$ 中无条件执行，意味着即使程序最终走 $p$-假路径，它也会执行。这是一个对具有可观察副作用的操作进行非法推测执行的典型例子。从 volatile 地址加载的行为本身就是副作用，无法在之后被“抵消”。\n- **结论：** 此转换违反了对 volatile 操作的非推测执行规则。**不正确**。\n\n**选项 E：在超块内部包含一个用于异常处理的条件分支。**\n\n- **提议的转换：** 将单个谓词化除法替换为 $H$ 内的一个序列：一个谓词化除法，后跟一个到异常处理程序的条件分支。\n- **分析：** 问题将超块定义为一个区域，其中“区域内的内部控制依赖通过谓词化被消除”。形成超块的目的是创建一个没有内部分支的、长的、线性的指令序列，这更便于编译器为指令级并行进行调度。\n  - 此选项提议在超块*内部*重新引入一个条件分支。这与问题中所述的超块形成的意图和定义相悖。\n  - 此外，这种机制是不必要的。ISA 模型已经提供了正确的语义：`[!p] z_2 - d / u_2`。这条指令只有在其谓词（$\\lnot p$）为真时才会执行，因此也只有在这种情况下才能陷阱。这精确地保留了原始程序的异常行为，而无需添加任何额外的控制流。\n- **结论：** 此转换是非法的，因为它重新引入了内部控制流，违反了超块形成的原则。**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3673046"}, {"introduction": "编译器的优化并非孤立存在，一项优化决策会深远影响后续阶段。超指令块的形成通过线性化代码和改变变量的生命周期，直接影响寄存器分配的难度。本练习 ([@problem_id:3672986]) 将让你亲手分析一个经过超指令块转换后的代码序列，通过计算变量的存活区间（liveness）来确定所需的最小寄存器数量，让你体会到优化阶段之间的紧密联系。", "problem": "考虑编译器后端中的一个代码区域，该区域将通过沿热路径形成超块，然后通过if-转换形成超区块来进行优化。原始区域表示为一个控制流图 (CFG)，其中控制流图 (CFG) 是一个有向图，其节点是基本块，边代表可能的控制转移。该代码在变量 $a$、$b$、$c$、$d$（假设为入口处活跃的输入）和临时变量 $t_1,\\dots,t_7$ 上使用三地址操作。转换前的 CFG 由以下基本块组成：\n\n- 块 $B_0$：\n  - $t_1 \\leftarrow a + b$\n  - 如果谓词 $p$ 为真，则跳转到 $B_1$，否则跳转到 $B_2$。\n- 块 $B_1$：\n  - $t_2 \\leftarrow t_1 \\times c$\n  - 跳转到 $B_3$。\n- 块 $B_2$：\n  - $t_3 \\leftarrow t_1 + c$\n  - 跳转到 $B_3$。\n- 块 $B_3$：\n  - 根据 $p$ 将 $t_2$ 和 $t_3$ $\\phi$-合并到 $t_4$ 中\n  - 如果谓词 $q$ 为真，则跳转到 $B_4$，否则跳转到 $B_5$。\n- 块 $B_4$：\n  - $t_5 \\leftarrow t_4 + d$\n  - 跳转到 $B_6$。\n- 块 $B_5$：\n  - $t_6 \\leftarrow t_4 \\times d$\n  - 跳转到 $B_6$。\n- 块 $B_6$：\n  - $t_7 \\leftarrow t_5 + t_6$\n  - 返回 $t_7$。\n\n超块是一个单入口、多出口的区域，通过选择一条热路径并执行尾部复制来消除侧入口而构建。超区块是一个谓词化的、经过if-转换的区域，它通过在谓词下推测执行操作并使用 select 操作合并值来移除内部控制流。在沿热路径 $B_0 \\rightarrow B_1 \\rightarrow B_3 \\rightarrow B_4 \\rightarrow B_6$ 形成超块，并对两个二元分支应用超区块if-转换（使得每个条件分支的两侧都在谓词下计算其值，并用 select 合并）之后，超块中的代码变成了一个带谓词化的单一直线序列：\n\n- 指令 $1$：$t_1 \\leftarrow a + b$。\n- 指令 $2$：$t_2 \\leftarrow t_1 \\times c$（由谓词 $p$ 保护）。\n- 指令 $3$：$t_3 \\leftarrow t_1 + c$（由谓词 $\\lnot p$ 保护）。\n- 指令 $4$：$t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$。\n- 指令 $5$：$t_5 \\leftarrow t_4 + d$（由谓词 $q$ 保护）。\n- 指令 $6$：$t_6 \\leftarrow t_4 \\times d$（由谓词 $\\lnot q$ 保护）。\n- 指令 $7$：$t_7 \\leftarrow t_5 + t_6$。\n- 指令 $8$：返回 $t_7$。\n\n在转换后的区域中，假设以下条件：\n- 谓词 $p$ 和 $q$ 存放在一个独立的谓词寄存器文件中，不参与通用寄存器分配。\n- 对于活跃性分析，如果一个值可能在从某个程序点开始的某条路径上被使用，且在使用前未被重新定义，则该值在该程序点是活跃的。谓词化定义保守地生成在后续合并中可能需要的值，因此 $t_2$ 和 $t_3$ 都被视为被 $\\mathrm{select}$ 使用，而 $t_5$ 和 $t_6$ 都被视为被最终的加法使用。\n- 冲突图 (IG) 为 $\\{a,b,c,d,t_1,t_2,t_3,t_4,t_5,t_6,t_7\\}$ 中的每个变量设一个节点，如果对应的两个值在任何程序点同时活跃，则连接这两个节点的边存在。\n- 寄存器分配器在冲突图上使用图着色算法，您必须确定在不发生溢出的情况下，足以分配所有这些值所需的最小通用寄存器数量。\n\n仅使用上述转换后的直线序列，首先更新由该超块和超区块形成所引起的活跃性信息和相应的冲突关系，然后确定在不发生溢出的情况下，分配 $\\{a,b,c,d,t_1,t_2,t_3,t_4,t_5,t_6,t_7\\}$ 中所有值所需的最小通用寄存器数量。请以单个整数形式表示您的答案。无需四舍五入。不要包含任何单位。", "solution": "用户希望找到在给定的超区块中分配变量而不发生溢出所需的最小寄存器数量。这个数量等价于代码冲突图 $G$ 的色数，记为 $\\chi(G)$。\n\n问题陈述，代码已被转换为一个由谓词化指令组成的单一直线序列。这样一个块内变量的冲突图是一个区间图。对于任何区间图 $G$，其色数等于其最大团的大小，即 $\\omega(G)$。冲突图中的一个团对应于在某个程序点上同时活跃的一组变量。因此，任务简化为找到在程序中任何一个点上活跃的变量的最大数量。这也被称为最大寄存器压力。\n\n我们通过从块的末尾向后计算每条指令入口和出口处的活跃变量集合来进行活跃性分析。设 $L_{in}(i)$ 和 $L_{out}(i)$ 分别为指令 $i$ 入口处和出口处的活跃变量集合。设 $\\mathrm{def}(i)$ 是指令 $i$ 定义（写入）的变量集合，$\\mathrm{use}(i)$ 是指令 $i$ 使用（读取）的变量集合。对于一个直线指令序列，我们有以下关系：\n$$L_{out}(i) = L_{in}(i+1)$$\n$$L_{in}(i) = (L_{out}(i) \\setminus \\mathrm{def}(i)) \\cup \\mathrm{use}(i)$$\n\n指令序列如下：\n1. $t_1 \\leftarrow a + b$\n2. $t_2 \\leftarrow t_1 \\times c$\n3. $t_3 \\leftarrow t_1 + c$\n4. $t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$\n5. $t_5 \\leftarrow t_4 + d$\n6. $t_6 \\leftarrow t_4 \\times d$\n7. $t_7 \\leftarrow t_5 + t_6$\n8. return $t_7$\n\n我们进行向后分析：\n\n- **指令 8 (`return $t_7$`)**：变量 $t_7$ 被使用。函数返回后，没有局部变量是活跃的。\n  - $L_{out}(8) = \\emptyset$\n  - $L_{in}(8) = (\\emptyset \\setminus \\emptyset) \\cup \\{t_7\\} = \\{t_7\\}$\n\n- **指令 7 (`$t_7 \\leftarrow t_5 + t_6$`)**：\n  - $L_{out}(7) = L_{in}(8) = \\{t_7\\}$\n  - $\\mathrm{def}(7) = \\{t_7\\}$，$\\mathrm{use}(7) = \\{t_5, t_6\\}$\n  - $L_{in}(7) = (\\{t_7\\} \\setminus \\{t_7\\}) \\cup \\{t_5, t_6\\} = \\{t_5, t_6\\}$\n\n- **指令 6 (`$t_6 \\leftarrow t_4 \\times d$`)**：\n  - $L_{out}(6) = L_{in}(7) = \\{t_5, t_6\\}$\n  - $\\mathrm{def}(6) = \\{t_6\\}$，$\\mathrm{use}(6) = \\{t_4, d\\}$\n  - $L_{in}(6) = (\\{t_5, t_6\\} \\setminus \\{t_6\\}) \\cup \\{t_4, d\\} = \\{t_4, t_5, d\\}$\n\n- **指令 5 (`$t_5 \\leftarrow t_4 + d$`)**：\n  - $L_{out}(5) = L_{in}(6) = \\{t_4, t_5, d\\}$\n  - $\\mathrm{def}(5) = \\{t_5\\}$，$\\mathrm{use}(5) = \\{t_4, d\\}$\n  - $L_{in}(5) = (\\{t_4, t_5, d\\} \\setminus \\{t_5\\}) \\cup \\{t_4, d\\} = \\{t_4, d\\}$\n\n- **指令 4 (`$t_4 \\leftarrow \\mathrm{select}(p, t_2, t_3)$`)**：\n  - $L_{out}(4) = L_{in}(5) = \\{t_4, d\\}$\n  - $\\mathrm{def}(4) = \\{t_4\\}$，$\\mathrm{use}(4) = \\{t_2, t_3\\}$\n  - $L_{in}(4) = (\\{t_4, d\\} \\setminus \\{t_4\\}) \\cup \\{t_2, t_3\\} = \\{d, t_2, t_3\\}$\n\n- **指令 3 (`$t_3 \\leftarrow t_1 + c$`)**：\n  - $L_{out}(3) = L_{in}(4) = \\{d, t_2, t_3\\}$\n  - $\\mathrm{def}(3) = \\{t_3\\}$，$\\mathrm{use}(3) = \\{t_1, c\\}$\n  - $L_{in}(3) = (\\{d, t_2, t_3\\} \\setminus \\{t_3\\}) \\cup \\{t_1, c\\} = \\{d, t_1, t_2, c\\}$\n\n- **指令 2 (`$t_2 \\leftarrow t_1 \\times c$`)**：\n  - $L_{out}(2) = L_{in}(3) = \\{d, t_1, t_2, c\\}$\n  - $\\mathrm{def}(2) = \\{t_2\\}$，$\\mathrm{use}(2) = \\{t_1, c\\}$\n  - $L_{in}(2) = (\\{d, t_1, t_2, c\\} \\setminus \\{t_2\\}) \\cup \\{t_1, c\\} = \\{d, t_1, c\\}$\n\n- **指令 1 (`$t_1 \\leftarrow a + b$`)**：\n  - $L_{out}(1) = L_{in}(2) = \\{d, t_1, c\\}$\n  - $\\mathrm{def}(1) = \\{t_1\\}$，$\\mathrm{use}(1) = \\{a, b\\}$\n  - $L_{in}(1) = (\\{d, t_1, c\\} \\setminus \\{t_1\\}) \\cup \\{a, b\\} = \\{a, b, c, d\\}$\n\n每条指令入口处的活跃变量集合如下：\n- $L_{in}(1) = \\{a, b, c, d\\}$，大小 $4$\n- $L_{in}(2) = \\{t_1, c, d\\}$，大小 $3$\n- $L_{in}(3) = \\{t_1, t_2, c, d\\}$，大小 $4$\n- $L_{in}(4) = \\{t_2, t_3, d\\}$，大小 $3$\n- $L_{in}(5) = \\{t_4, d\\}$，大小 $2$\n- $L_{in}(6) = \\{t_4, t_5, d\\}$，大小 $3$\n- $L_{in}(7) = \\{t_5, t_6\\}$，大小 $2$\n- $L_{in}(8) = \\{t_7\\}$，大小 $1$\n\n在任何程序点（即任何 $L_{in}(i)$ 或 $L_{out}(i)$）的所有活跃集合中的最大大小决定了最大团的大小，即 $\\omega(G)$。观察到的最大大小是 $4$。这发生在指令 $1$ 的入口处（活跃集 $\\{a, b, c, d\\}$）和指令 $3$ 的入口处（活跃集 $\\{t_1, t_2, c, d\\}$）。\n\n因此，最大团的大小为 $\\omega(G) = 4$。对于区间图，色数等于团数，所以 $\\chi(G) = \\omega(G) = 4$。这意味着为图着色需要最少 $4$ 个寄存器，这对应于在不发生溢出的情况下分配变量。", "answer": "$$\n\\boxed{4}\n$$", "id": "3672986"}]}