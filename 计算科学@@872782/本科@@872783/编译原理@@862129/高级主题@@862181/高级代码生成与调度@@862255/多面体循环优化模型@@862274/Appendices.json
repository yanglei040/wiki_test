{"hands_on_practices": [{"introduction": "任何循环变换的基础都必须保证不违反原始程序的数据依赖关系。这个练习将带你亲手实践多面体模型的核心技能：依赖分析。通过形式化地检查两条语句之间的读后写（WAR）、写后读（RAW）和写后写（WAW）依赖，你将能够确定一个看似简单的语句重排是否合法，从而深刻理解为何依赖性是保证程序正确性的基石 [@problem_id:3663286]。", "problem": "考虑一个单层嵌套循环，其迭代变量为 $i$，数组 $A$、$B$ 和 $C$ 的长度为 $N$，其中 $N \\geq 5$。该循环按 $i$ 的严格递增顺序执行，并且数组 $A$、$B$ 和 $C$ 之间没有混叠。循环内的语句是：\n$$S_1: A[i] = A[i-2] + B[i],$$\n$$S_2: A[i-2] = A[i-3] + C[i],$$\n对所有满足 $3 \\leq i \\leq N-1$ 的整数 $i$ 成立。假设在每次迭代中，循环体内的原始程序顺序是 $S_1$ 后跟 $S_2$。\n\n使用多面体循环优化模型，从迭代域、仿射访问函数、程序顺序调度以及依赖方向向量和距离的核心定义出发进行推理。判断将 $S_1$ 重排到 $S_2$ 之后执行（即，交换它们，使每个 $i$ 的循环体变为 $S_2$ 后跟 $S_1$）在顺序语义下是否合法，需要考虑写后读（RAW）、读后写（WAR）和写后写（WAW）依赖。\n\n你的最终答案必须是一个数字：如果重排是合法的，则返回 $1$；如果不合法，则返回 $0$。不需要四舍五入。答案不带单位。", "solution": "该问题要求我们判断在一个循环内重排两个语句 $S_1$ 和 $S_2$ 是否是符合顺序语义的合法变换。此分析将使用多面体模型进行，该模型为循环优化提供了一个形式化的推理框架。一个变换是合法的，当且仅当它保留了原始程序的所有数据依赖。\n\n首先，我们通过定义迭代域、内存访问函数和程序调度来形式化该问题。\n\n循环的变量 $i$ 从 $3$ 迭代到 $N-1$。语句 $S_1$ 和 $S_2$ 都在此循环内执行。两个语句的迭代域是与循环迭代器值相对应的整数点集。由于这是一个单层嵌套循环，迭代向量就是标量 $i$。\n$S_1$ 和 $S_2$ 的迭代域 $\\mathcal{D}$ 为：\n$$ \\mathcal{D} = \\{i \\in \\mathbb{Z} \\mid 3 \\leq i \\leq N-1 \\} $$\n\n语句如下：\n$S_1: A[i] = A[i-2] + B[i]$\n$S_2: A[i-2] = A[i-3] + C[i]$\n\n每个语句的内存访问可以表示为迭代变量 $i$ 的仿射函数。由于数组 $A$、$B$ 和 $C$ 之间没有混叠，我们只需要分析对数组 $A$ 的依赖。\n数组 $A$ 的访问函数是：\n- 对于 $S_1$：\n  - 写访问： $f_{W,A,1}(i) = i$\n  - 读访问： $f_{R,A,1}(i) = i-2$\n- 对于 $S_2$：\n  - 写访问： $f_{W,A,2}(i) = i-2$\n  - 读访问： $f_{R,A,2}(i) = i-3$\n\n原始的程序顺序，或称调度，定义了所有语句实例的执行序列。在原始程序中，每次迭代中 $S_1$ 在 $S_2$ 之前执行。我们可以用向量 $(k, i)$ 表示语句 $S_k$ 在迭代 $i$ 中的一个实例的调度。执行顺序是这些向量的字典序。\n- $S_1(i)$ 的调度： $(1, i)$\n- $S_2(i)$ 的调度： $(2, i)$\n对于任意给定的迭代 $i$，$(1, i)$ 在字典序上小于 $(2, i)$，这意味着 $S_1(i)$ 在 $S_2(i)$ 之前执行。对于任意两次迭代 $i$ 和 $j$，其中 $i  j$，在迭代 $i$ 中的任何语句实例都在迭代 $j$ 中的任何实例之前执行。\n\n如果语句实例 $S_a(i)$ 在实例 $S_b(j)$ 之前执行，它们都访问相同的内存位置，并且其中至少有一次访问是写操作，那么就存在从 $S_a(i)$ 到 $S_b(j)$ 的数据依赖。重排语句 $S_1$ 和 $S_2$ 是合法的，当且仅当没有依赖被违背。一个从 $S_1(i)$ 到 $S_2(i)$ 的依赖（一个循环无关依赖）将会被这次交换所违背，因为新的顺序会将依赖的汇点（$S_2(i)$）置于源点（$S_1(i)$）之前。因此，当且仅当存在一个从 $S_1$ 到 $S_2$ 的循环无关依赖时，这次交换是非法的。\n\n我们现在寻找这样的循环无关依赖，它们发生在同一次迭代内的语句实例之间。我们测试从 $S_1(i)$ 到 $S_2(i)$ 的写后读（RAW）、读后写（WAR）和写后写（WAW）依赖，其中 $i \\in \\mathcal{D}$。\n\n1.  **RAW 依赖 ($S_1(i) \\to_{\\text{RAW}} S_2(i)$)**：在同一次迭代中，$S_1$ 写入一个位置，而 $S_2$ 从该位置读取。\n    这要求 $S_1$ 的写访问函数等于 $S_2$ 的读访问函数。\n    $$ f_{W,A,1}(i) = f_{R,A,2}(i) $$\n    $$ i = i - 3 $$\n    $$ 0 = -3 $$\n    这是一个矛盾，因此不存在从 $S_1$ 到 $S_2$ 的循环无关 RAW 依赖。\n\n2.  **WAW 依赖 ($S_1(i) \\to_{\\text{WAW}} S_2(i)$)**：在同一次迭代中，$S_1$ 和 $S_2$ 写入相同的位置。\n    这要求写访问函数相等。\n    $$ f_{W,A,1}(i) = f_{W,A,2}(i) $$\n    $$ i = i - 2 $$\n    $$ 0 = -2 $$\n    这是一个矛盾，因此不存在从 $S_1$ 到 $S_2$ 的循环无关 WAW 依赖。\n\n3.  **WAR 依赖 ($S_1(i) \\to_{\\text{WAR}} S_2(i)$)**：在同一次迭代中，$S_1$ 从一个位置读取，而 $S_2$ 写入该位置。\n    这要求 $S_1$ 的读访问函数等于 $S_2$ 的写访问函数。\n    $$ f_{R,A,1}(i) = f_{W,A,2}(i) $$\n    $$ i - 2 = i - 2 $$\n    这个方程对所有 $i$ 的值都成立。因此，对于每个迭代 $i \\in \\mathcal{D}$，都存在一个从 $S_1(i)$到 $S_2(i)$ 的关于内存位置 $A[i-2]$ 的 WAR（反）依赖。\n\n这个循环无关 WAR 依赖 $S_1(i) \\to_{\\text{WAR}} S_2(i)$ 的存在意味着，为了保持程序语义，在同一次迭代 $i$ 中，语句 $S_1$ 中对 $A[i-2]$ 的读取必须发生在语句 $S_2$ 中对 $A[i-2]$ 的写入之前。原始的程序顺序遵循了此依赖。\n\n如果我们交换这两个语句，循环体内部的新顺序将变为 $S_2$ 后跟 $S_1$。对于任何迭代 $i$，语句 $S_2(i)$ 将在 $S_1(i)$ 之前执行。这将导致对 $A[i-2]$ 的写入发生在对 $A[i-2]$ 的读取之前。因此，$S_1(i)$ 将会读取由 $S_2(i)$ 计算出的 $A[i-2]$ 的新值，而不是它本应读取的来自前一次迭代的值。这违背了依赖关系，并改变了程序的计算结果。\n\n为了完整起见，我们可以检查其他的（循环携带）依赖，尽管它们不影响此特定变换的合法性。对于 $i  j$：\n-   $S_1(i) \\to S_2(j)$：\n    -   RAW：$f_{W,A,1}(i) = f_{R,A,2}(j) \\implies i = j-3 \\implies j-i=3$。存在一个距离为 $3$ 的循环携带 RAW 依赖。\n    -   WAW：$f_{W,A,1}(i) = f_{W,A,2}(j) \\implies i = j-2 \\implies j-i=2$。存在一个距离为 $2$ 的循环携带 WAW 依赖。\n    -   WAR：$f_{R,A,1}(i) = f_{W,A,2}(j) \\implies i-2 = j-2 \\implies i=j$。对于 $i  j$ (循环携带) 不存在WAR依赖。\n-   $S_2(i) \\to S_1(j)$：\n    -   RAW：$f_{W,A,2}(i) = f_{R,A,1}(j) \\implies i-2 = j-2 \\implies i=j$。对于 $i  j$ 不存在 RAW 依赖。\n    -   WAW：$f_{W,A,2}(i) = f_{W,A,1}(j) \\implies i-2 = j$。这对于 $i  j$ 是不可能的。\n    -   WAR：$f_{R,A,2}(i) = f_{W,A,1}(j) \\implies i-3 = j$。这对于 $i  j$ 是不可能的。\n\n这些循环携带依赖都不会因在循环体内部交换语句而受到影响。唯一相关的依赖是循环无关的 WAR 依赖。由于存在这样的依赖，交换语句 $S_1$ 和 $S_2$ 是非法的。\n\n因此，重排是不合法的。最终答案是 $0$。", "answer": "$$\\boxed{0}$$", "id": "3663286"}, {"introduction": "在理解了依赖关系后，下一步就是设计新的执行顺序（即“调度”）来优化性能。本练习将向你展示如何分析一个非平凡的仿射调度函数——具体来说，是一种称为“倾斜”（skewing）的技术——如何能在保持程序正确性的同时，揭示出循环中固有的并行维度。你将学会如何根据多面体模型的因果关系约束来判断调度的合法性，并量化其所暴露的并行性 [@problem_id:3663326]。", "problem": "考虑整数参数 $N$ 和 $M$ 的迭代域 $D=\\{(i,j)\\in\\mathbb{Z}^{2}\\mid 0\\le i  M,\\ 0\\le j  N\\}$，以及一个在该域上具有一致流依赖向量 $d=(\\Delta i, \\Delta j)=(0,1)$ 的循环。\n给定一个多维仿射调度 $\\theta:\\mathbb{Z}^2\\to\\mathbb{Z}^2$，定义为 $\\theta(i,j)=(i,\\ j-i)$。\n\n如果该调度合法，即对于任何从迭代点 $p$ 到 $p'$ 的依赖，它都保持了因果关系 $\\theta(p) \\prec_{\\text{lex}} \\theta(p')$，则设 $L=1$，否则设 $L=0$。\n\n一个调度维度 $k$ 是并行的，如果对于所有依赖，依赖距离向量的第 $k$ 个分量 $\\delta_k = (\\theta(p') - \\theta(p))_k = 0$。设 $P$ 是构成最外层并行带的并行调度维度的数量。\n\n求出值 $L$ 和 $P$，并将最终答案以行矩阵 $\\begin{pmatrix}L  P\\end{pmatrix}$ 的形式给出。", "solution": "该问题要求我们为给定的多面体循环优化场景确定两个值：合法性指示符 $L$ 和并行调度维度的数量 $P$。\n\n首先，我们确定调度 $\\theta$ 的合法性。一个调度被定义为合法的，如果对于从迭代点 $p$ 到迭代点 $p'$ 的每一个依赖，该调度都保持了执行顺序。这意味着为 $p$ 安排的时间必须在字典序上小于为 $p'$ 安排的时间。问题将此条件表述为 $\\theta(p) \\prec_{\\text{lex}} \\theta(p')$。设 $p=(i,j)$ 为源迭代， $d=(\\Delta i, \\Delta j)=(0,1)$ 为一致流依赖向量。那么目标迭代是 $p' = p+d = (i, j+1)$。\n\n合法性条件可以用依赖距离向量 $\\delta$ 来重述，它被定义为目标迭代和源迭代的调度时间之差：\n$$ \\delta = \\theta(p') - \\theta(p) $$\n当且仅当对于所有依赖，这个距离向量是字典序正的，即 $\\delta \\succ_{\\text{lex}} 0$，该调度才是合法的。如果一个向量 $v=(v_1, v_2, \\dots, v_n)$ 的第一个非零分量是正的，那么这个向量是字典序正的。\n\n给定的调度是 $\\theta:\\mathbb{Z}^{2}\\to\\mathbb{Z}^{2}$，定义为 $\\theta(i,j)=(i,\\ j-i)$。\n让我们计算源迭代和目标迭代的调度时间。\n源迭代是 $p=(i,j)$。其调度时间为：\n$$ \\theta(p) = \\theta(i,j) = (i,\\ j-i) $$\n目标迭代是 $p'=(i, j+1)$。其调度时间为：\n$$ \\theta(p') = \\theta(i, j+1) = (i, (j+1)-i) = (i, j-i+1) $$\n\n现在，我们计算依赖距离向量 $\\delta$：\n$$ \\delta = \\theta(p') - \\theta(p) = (i, j-i+1) - (i, j-i) $$\n$$ \\delta = (i-i, (j-i+1)-(j-i)) $$\n$$ \\delta = (0, 1) $$\n对于这种一致依赖和仿射调度，依赖距离向量是恒定的。我们必须检查 $\\delta = (0,1)$ 是否为字典序正。$\\delta$ 的第一个分量是 $0$。然后我们检查第二个分量，它是 $1$。因为 $1  0$，所以向量 $\\delta=(0,1)$ 是字典序正的。\n$$ (0,1) \\succ_{\\text{lex}} (0,0) $$\n该调度遵守了依赖因果关系。因此，该调度是合法的。合法性指示符 $L$ 为 $1$。\n$$ L=1 $$\n\n接下来，我们确定并行调度维度的数量 $P$。问题将调度维度 $k$ 定义为并行的，如果依赖距离向量的第 $k$ 个分量为 $0$。数量 $P$ 是形成最外层并行带的此类维度的计数。这对应于依赖距离向量中前导零的数量。\n\n我们计算出的依赖距离向量是 $\\delta = (\\delta_1, \\delta_2) = (0,1)$。\n我们来检查它的分量：\n1.  第一个分量是 $\\delta_1 = 0$。根据定义，第一个调度维度是并行的。这意味着对于给定的依赖，所有相关的操作都被映射到变换后迭代空间的第一个维度中的相同坐标。\n2.  第二个分量是 $\\delta_2 = 1$。由于这个分量非零，第二个调度维度不是并行的；它是顺序的。这个维度承载了依赖关系，确保了正确性。\n\n向量 $\\delta=(0,1)$ 中前导零的数量为一个。这个单一的并行维度构成了一个外层并行带。因此，并行调度维度的数量是 $1$。\n$$ P=1 $$\n\n问题要求以行矩阵 $\\begin{pmatrix}L  P\\end{pmatrix}$ 的形式给出最终答案。代入我们求得的值：\n$$ \\begin{pmatrix} 1  1 \\end{pmatrix} $$\n这表明该调度是合法的，并且它揭示了一个循环级别的并行维度。", "answer": "$$ \\boxed{\\begin{pmatrix} 1  1 \\end{pmatrix}} $$", "id": "3663326"}, {"introduction": "有时，循环中固有的依赖关系会形成一个环，从而阻碍像并行分块（tiling）这样强大的优化。本练习探讨了一种高级但非常实用的变换策略：通过引入临时数组来修改程序，从而打破依赖环。我们将分析如何将一个本质上串行的计算（如高斯-赛德尔迭代）转化为一个可并行的计算（如雅可比迭代），为实现大规模并行计算铺平道路 [@problem_id:3663289]。", "problem": "考虑在多面体模型中编写的以下二维高斯-赛德尔式更新。迭代域是整数多面体 $$D = \\{(i,j)\\in \\mathbb{Z}^2 \\mid 1 \\le i \\le N,\\ 1 \\le j \\le N\\},$$ 其中 $N \\in \\mathbb{Z}_{0}$。单个语句 $S(i,j)$ 对每个 $(i,j)\\in D$ 执行，并使用四点邻居和当前元素对数组 $A$ 进行原位更新：\n$$\n\\text{写: } W_A(i,j) = (i,j),\\quad\n\\text{读: } R_A(i,j) = \\{(i-1,j),\\ (i,j-1),\\ (i+1,j),\\ (i,j+1),\\ (i,j)\\},\n$$\n边界外的读取会以标准方式钳位到有效索引。在 $(i,j)$ 的字典序执行顺序（例如，行主序）中，$S(i,j)$ 在同一遍（sweep）内对 $S(i-1,j)$ 和 $S(i,j-1)$ 存在流依赖，当沿 $i$ 和 $j$ 同时应用矩形分块时，这些依赖会引发一个环。\n\n设矩形块由一个分块映射定义\n$$\n\\tau(i,j) = \\big(b_i, b_j, x_i, x_j\\big),\\quad\nb_i = \\left\\lfloor \\frac{i-1}{p} \\right\\rfloor,\\quad b_j = \\left\\lfloor \\frac{j-1}{q} \\right\\rfloor,\\quad\nx_i = i - b_i p,\\quad x_j = j - b_j q,\n$$\n对于给定的块大小 $p,q \\in \\mathbb{Z}_{0}$。块坐标为 $(b_i,b_j)$，块内坐标为 $(x_i,x_j)$。在原始的原位更新下，沿 $+i$ 和 $+j$ 方向的依赖在块级依赖图中产生一个环，这会强制串行化（例如，通过波前调度）并阻止所有块并行运行。\n\n在多面体模型中，打破这种依赖环的一个常用策略是引入一个新的临时数组并修改访问函数，使得计算阶段只读取更新前的值并只写入临时数组，随后是一个单独的复制/更新阶段，将临时数组的内容提交到原始数组。这有时被描述为通过数组展开将高斯-赛德尔更新转换为雅可比式两阶段更新。\n\n要求您选择一个能正确修改访问函数的变换，以便在仅按 $(b_i,b_j)$ 排序的块调度下打破依赖环并启用并行块，即：\n$$\n\\Theta_{\\text{tile}}(i,j) = (b_i, b_j),\n$$\n当不存在块间依赖时，所有位于不同 $(b_i,b_j)$ 的块都允许在计算阶段并发执行。\n\n哪个选项精确地指定了访问函数修改和阶段排序，从而为计算阶段产生一个无环的块级依赖图，使得所有块在 $\\Theta_{\\text{tile}}$ 下都能并行，并且在科学上是合理的？\n\nA. 将所有对 $A$ 的写操作 $W_A(i,j)$ 替换为对一个新的临时数组 $B$ 的写操作 $W_B(i,j) = (i,j)$，并保持所有对 $A$ 的读操作不变：$R_A(i,j)$ 如给定。在整个域 $D$ 上完成计算阶段后，执行一个单独的复制阶段 $C(i,j)$，其写操作为 $W_A^{\\text{copy}}(i,j) = (i,j)$，读操作为 $R_B^{\\text{copy}}(i,j) = (i,j)$，即 $A(i,j) \\gets B(i,j)$。使用 $\\Theta_{\\text{tile}}$ 并行执行所有块的计算阶段，然后在不引入块间读取的情况下逐元素（或逐块）地执行复制阶段。\n\nB. 将对 $A$ 的写操作替换为对 $B$ 的写操作 $W_B(i,j) = (i,j)$，但从 $B$ 读取“较早”的邻居，如 $R_B(i,j) \\supset \\{(i-1,j),(i,j-1)\\}$，并从 $A$ 读取“较晚”的邻居，如 $R_A(i,j) \\supset \\{(i+1,j),(i,j+1),(i,j)\\}$。在每个块完成后立即执行按块复制 $A \\gets B$。\n\nC. 保持对 $A$ 的写操作不变，$W_A(i,j) = (i,j)$，但将所有邻居读取重定向到临时数组 $B$，即 $R_B(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$，并且不显式地用 $A$ 初始化 $B$。因为读取操作来自 $B$，所以允许块在 $\\Theta_{\\text{tile}}$ 下并行运行。\n\nD. 写入 $B$，$W_B(i,j) = (i,j)$，然后在同一 $(i,j)$ 迭代内立即通过 $A(i,j) \\gets B(i,j)$ 进行复制（即，在元素粒度上交错计算和复制）。保持从 $A$ 的原始邻居读取，并允许在 $\\Theta_{\\text{tile}}$ 下并行执行块，因为每个元素在邻居读取它之前都已提交。\n\n选择正确的选项。", "solution": "本题要求确定正确的变换，以实现高斯-赛德尔式更新中块的并行执行。\n\n### 第一步：提取已知信息\n- **迭代域**: $D = \\{(i,j)\\in \\mathbb{Z}^2 \\mid 1 \\le i \\le N,\\ 1 \\le j \\le N\\}$，对于某个常量 $N \\in \\mathbb{Z}_{0}$。\n- **语句**: $S(i,j)$ 对域 $D$ 中的每个点 $(i,j)$ 执行。\n- **访问函数**:\n    - 写入数组 $A$：$W_A(i,j) = (i,j)$。\n    - 读取数组 $A$：$R_A(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$。\n- **执行顺序和依赖**: 对于 $(i,j)$ 的字典序执行顺序，语句 $S(i,j)$ 对 $S(i-1,j)$ 和 $S(i,j-1)$ 存在流依赖。\n- **分块**: 矩形块由映射 $\\tau(i,j) = (b_i, b_j, x_i, x_j)$ 定义，其中：\n    - 块坐标：$b_i = \\lfloor \\frac{i-1}{p} \\rfloor$, $b_j = \\lfloor \\frac{j-1}{q} \\rfloor$，对于块大小 $p, q \\in \\mathbb{Z}_{0}$。\n    - 块内坐标：$x_i = i - b_i p$, $x_j = j - b_j q$。\n- **问题**: 流依赖产生了块间依赖，这在块调度 $\\Theta_{\\text{tile}}(i,j) = (b_i, b_j)$ 下阻止了所有块的并行执行。\n- **目标**: 找到一个修改访问函数的变换，为计算阶段创建一个无环的块级依赖图，从而允许所有块并发执行。\n\n### 第二步：使用提取的已知信息进行验证\n问题陈述在编译器优化领域，特别是在多面体模型方面，具有科学依据。它描述了一个标准场景：一个具有模板式依赖的常规循环嵌套（高斯-赛德尔松弛），它在分块时限制了并行性。目标是应用一种已知技术——数组展开，将更新转换为雅可比式更新，以实现更大的并行性。术语（迭代域、访问函数、依赖、分块、块调度）都是标准的并且使用正确。该问题定义明确、客观，并包含足够的信息来确定正确的变换。不存在科学或逻辑上的缺陷。\n\n### 第三步：结论与行动\n问题是有效的。将对选项进行严格的推导和评估。\n\n### 基于原理的推导\n核心问题是在单次计算遍（sweep）内存在流依赖。具体来说，对于字典序调度 $(i,j)$，$A(i,j)$ 的计算依赖于在同一遍中已更新的值 $A(i-1,j)$ 和 $A(i,j-1)$。设更新函数为 $f$。更新操作为 $A(i,j) \\gets f(A(i-1,j), A(i,j-1), \\dots)$。\n\n如果语句 $S_1$ 写入一个内存位置，随后 $S_2$ 读取该位置，并且 $S_1$ 在 $S_2$ 之前执行，则存在从 $S_1$ 到 $S_2$ 的流依赖。\n1.  **从 $S(i-1,j)$ 到 $S(i,j)$ 的依赖**：$S(i-1,j)$ 写入 $A(i-1,j)$。之后，$S(i,j)$ 读取 $A(i-1,j)$。这是一个流依赖，其依赖向量为 $\\mathbf{d}_1 = (i,j) - (i-1,j) = (1,0)$。\n2.  **从 $S(i,j-1)$ 到 $S(i,j)$ 的依赖**：$S(i,j-1)$ 写入 $A(i,j-1)$。之后，$S(i,j)$ 读取 $A(i,j-1)$。这是一个流依赖，其依赖向量为 $\\mathbf{d}_2 = (i,j) - (i,j-1) = (0,1)$。\n\n从 $A(i+1,j)$ 和 $A(i,j+1)$ 的读取是来自稍后将在该遍中更新的位置。因此，这些读取访问的是该遍开始时的值，不会引入额外的流依赖。\n\n当应用分块时，这些依赖可能会跨越块边界。\n- 对于 $\\mathbf{d}_1 = (1,0)$：一次迭代 $(i,j)$ 可能依赖于 $(i-1,j)$。如果 $i-1$ 是块宽度 $p$ 的倍数，那么 $(i,j)$ 和 $(i-1,j)$ 位于不同的块中。具体来说，包含 $(i,j)$ 的块依赖于其左侧的块。\n- 对于 $\\mathbf{d}_2 = (0,1)$：一次迭代 $(i,j)$ 可能依赖于 $(i,j-1)$。如果 $j-1$ 是块高度 $q$ 的倍数，那么 $(i,j)$ 和 $(i,j-1)$ 位于不同的块中。包含 $(i,j)$ 的块依赖于其“上方”的块。\n\n这些块间依赖意味着块 $(b_i, b_j)$ 必须等到其相邻块 $(b_i-1, b_j)$ 和 $(b_i, b_j-1)$ 产生必要的边界值后才能开始执行。这阻止了所有块的同时并行执行。\n\n为了在计算阶段打破这些依赖，我们必须确保没有计算会读取在同一阶段写入的值。这可以通过使用一个临时数组（比如 $B$）将高斯-赛德尔更新转换为雅可比式更新来实现。这种技术被称为数组展开或私有化。\n\n该变换涉及两个不同的阶段：\n1.  **计算阶段**：所有计算都从原始数组 $A$（它持有遍开始前的状态）中读取，并将其结果写入临时数组 $B$。\n    - 更新变为：$B(i,j) \\gets f(A(i-1,j), A(i,j-1), A(i+1,j), A(i,j+1), A(i,j))$。\n    - 对于此阶段中的任意两次迭代 $S'(i_1, j_1)$ 和 $S'(i_2, j_2)$：\n        - 所有读取都来自数组 $A$。\n        - 所有写入都写入数组 $B$。\n        - 由于 $(i_1, j_1) \\neq (i_2, j_2)$，它们写入不同的位置 $B(i_1, j_1)$ 和 $B(i_2, j_2)$。\n        - 不存在一次迭代写入一个位置而另一次迭代读取该位置的情况。因此，在计算阶段的任意两次迭代之间不存在流依赖、反依赖或输出依赖。\n    - 由于没有依赖关系，所有迭代 $(i,j) \\in D$ 可以按任何顺序执行，包括完全并行。这意味着所有块都可以并发执行，没有任何块间依赖。\n\n2.  **复制阶段**：在整个域 $D$ 的计算阶段完成后，将临时数组 $B$ 的结果复制回原始数组 $A$。\n    - 复制操作为：$A(i,j) \\gets B(i,j)$，对于所有 $(i,j) \\in D$。\n    - 每个复制操作 $C(i,j)$ 从唯一的位置 $B(i,j)$ 读取并写入唯一的位置 $A(i,j)$。这些操作之间没有依赖关系。\n    - 因此，复制阶段也可以完全并行化。\n\n必须在计算阶段和复制阶段之间放置一个全局同步屏障以确保正确性。此变换正确地消除了计算阶段的块间依赖，实现了既定目标。\n\n### 各选项分析\n\n**A. 将所有对 $A$ 的写操作 $W_A(i,j)$ 替换为对一个新的临时数组 $B$ 的写操作 $W_B(i,j) = (i,j)$，并保持所有对 $A$ 的读操作不变：$R_A(i,j)$ 如给定。在整个域 $D$ 上完成计算阶段后，执行一个单独的复制阶段 $C(i,j)$，其写操作为 $W_A^{\\text{copy}}(i,j) = (i,j)$，读操作为 $R_B^{\\text{copy}}(i,j) = (i,j)$，即 $A(i,j) \\gets B(i,j)$。使用 $\\Theta_{\\text{tile}}$ 并行执行所有块的计算阶段，然后在不引入块间读取的情况下逐元素（或逐块）地执行复制阶段。**\n此选项准确地描述了上面推导的雅可比式变换。计算阶段只从 $A$ 读取并写入 $B$，这消除了计算循环嵌套中迭代之间的所有依赖。这正确地导致了计算阶段的块级依赖图是无环的（实际上是空的），允许所有块并行运行。随后的复制阶段正确地提交了结果。这是标准的、正确的方法。\n**结论：正确**\n\n**B. 将对 $A$ 的写操作替换为对 $B$ 的写操作 $W_B(i,j) = (i,j)$，但从 $B$ 读取“较早”的邻居，如 $R_B(i,j) \\supset \\{(i-1,j),(i,j-1)\\}$，并从 $A$ 读取“较晚”的邻居，如 $R_A(i,j) \\supset \\{(i+1,j),(i,j+1),(i,j)\\}$。在每个块完成后立即执行按块复制 $A \\gets B$。**\n这种变换是有缺陷的。通过从临时数组 $B$ 中读取“较早”的邻居，它重新引入了我们旨在消除的流依赖。$B(i,j)$ 的计算现在依赖于在同一阶段计算的 $B(i-1,j)$ 和 $B(i,j-1)$。这导致了依赖向量 $(1,0)$ 和 $(0,1)$，产生了块间依赖，并阻止了所有块的并行执行。按块复制还会引入复杂的竞争条件和不正确的语义。\n**结论：不正确**\n\n**C. 保持对 $A$ 的写操作不变，$W_A(i,j) = (i,j)$，但将所有邻居读取重定向到临时数组 $B$，即 $R_B(i,j) = \\{(i-1,j), (i,j-1), (i+1,j), (i,j+1), (i,j)\\}$，并且不显式地用 $A$ 初始化 $B$。因为读取操作来自 $B$，所以允许块在 $\\Theta_{\\text{tile}}$ 下并行运行。**\n这个选项在科学上是不合理的。它建议从一个未初始化的数组 $B$ 中读取。基于未定义数据的计算将产生无意义的结果。在任何有效的实现中，$B$ 都需要首先用 $A$ 的内容进行初始化。如果我们假设有这样一个初始化步骤 ($B \\gets A$)，计算阶段将是 $A(i,j) \\gets f(B(\\dots))$。虽然这允许并行执行（从 $B$ 读，向 $A$ 写），但原选项所述的方式由于使用了未初始化的数据而存在根本性缺陷。\n**结论：不正确**\n\n**D. 写入 $B$，$W_B(i,j) = (i,j)$，然后在同一 $(i,j)$ 迭代内立即通过 $A(i,j) \\gets B(i,j)$ 进行复制（即，在元素粒度上交错计算和复制）。保持从 $A$ 的原始邻居读取，并允许在 $\\Theta_{\\text{tile}}$ 下并行执行块，因为每个元素在邻居读取它之前都已提交。**\n这种变换在功能上等同于原始的原位更新。序列 `temp = calculation_from_A; B(i,j) = temp; A(i,j) = B(i,j);` 可简化为 `A(i,j) = calculation_from_A;`。临时数组 $B$ 是完全多余的。因此，所有原始的流依赖，例如从 $S(i-1,j)$ 到 $S(i,j)$ 的依赖，都被保留了下来。声称这允许并行块是错误的；块间依赖依然存在，该变换没有实现任何目的。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3663289"}]}