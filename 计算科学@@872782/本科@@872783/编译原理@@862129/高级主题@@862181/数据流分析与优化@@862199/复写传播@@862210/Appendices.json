{"hands_on_practices": [{"introduction": "编译器在处理中间代码时，尤其是在内联函数或生成临时包装对象后，常常会产生一长串冗余的复制指令，例如 $w_{1} := v_{1}$, $x_{1} := w_{1}$, $y_{1} := x_{1}$。这个练习将引导你使用一个高效的数据结构——并查集（Union-Find），来系统地处理这种复制链。通过将所有持有相同值的变量划入等价类，并用唯一的代表元替换它们，我们可以彻底消除这些冗余的副本，这是掌握副本传播核心机制的基础实践。[@problem_id:3633963]", "problem": "编译器正在优化一段线性中间表示（IR）序列，该序列源于引入了冗余包装器临时变量的内联对象构造函数。所考虑的优化是副本传播，即在安全的情况下，用一个临时变量的源来替换其使用，然后移除无用的副本赋值。该程序采用静态单赋值（SSA）形式，因此每次赋值都会产生一个新的版本化名称。所有包装器都是不可变的，其内联构造函数是底层引用的纯转发器，并且除了标量算术外，IR 中没有副作用操作。特别地，存在一个只读取其参数而不修改任何变量的纯调用。\n\n使用以下核心定义作为基本依据：\n- 副本传播定义在形如 $a := b$ 的直接副本上，其中 $a$ 和 $b$ 都是标量临时变量。其安全性由值相等性决定：如果出现 $a := b$ 且 $b$ 随后没有以影响到达 $a$ 的使用的值的方式被重新定义，则 $a$ 的任何使用都可以被 $b$ 替换，而不会改变程序语义。\n- 由临时变量上的副本语句引起的相等性是一种等价关系，产生表示相同值的不相交的名称集合。维护这些集合的标准方法是不相交集并（也称为并查集）数据结构，该数据结构由操作 $\\mathrm{find}$（获取集合代表）和 $\\mathrm{union}$（当观察到副本 $a := b$ 时合并两个集合）定义。\n\n考虑以下单个基本块中的 SSA IR 序列，其中内联包装器构造函数产生链式副本。指令顺序自上而下，SSA 版本下标表示不同的定义：\n1. $v_{1} := \\mathrm{load}(A)$\n2. $w_{1} := v_{1}$\n3. $x_{1} := w_{1}$\n4. $y_{1} := x_{1}$\n5. $\\mathrm{call\\_pure}(y_{1})$\n6. $v_{2} := v_{1} + 1$\n7. $w_{2} := v_{2}$\n8. $t_{1} := w_{2}$\n9. $u_{1} := t_{1}$\n10. $z_{1} := y_{1}$\n\n假设：\n- $\\mathrm{load}(A)$ 产生一个新的标量值，且不与任何其他变量别名。\n- $\\mathrm{call\\_pure}(y_{1})$ 是一个纯函数，只读取其输入；它不写入内存或重新赋值任何临时变量。\n- 算术运算 $v_{2} := v_{1} + 1$ 定义了一个新的 SSA 名称 $v_{2}$，其值不同于 $v_{1}$；它不修改 $v_{1}$。\n\n应用一种基于并查集的副本传播，该传播：\n- 对每个直接副本 $a := b$ 执行 $\\mathrm{union}(a,b)$，以构建表示相同值的 SSA 名称的等价类。\n- 对于每个等价类，选择由 $\\mathrm{find}$ 返回的代表，该代表是该类中程序顺序里最早的 SSA 名称。\n- 在上述 SSA 和纯度假设下，在保持语义的情况下，将所有非代表名称的使用重写为类代表。\n- 移除那些定义了在重写后不再有任何不同使用的名称的无用副本赋值。\n\n根据这些规则，确定上述序列中被此优化消除的形如 $a := b$ 的赋值语句的确切数量。将你的最终答案表示为单个整数。不需要四舍五入，也不涉及物理单位。", "solution": "用户提供了一个编译器优化领域的问题，具体关注于静态单赋值（SSA）中间表示（IR）序列中的副本传播。任务是根据基于并查集数据结构的特定算法，确定被消除的副本赋值的数量。\n\n该问题是有效的，因为它在科学上基于既定的编译器理论，问题陈述清晰，算法确定，并使用客观、形式化的语言。它自成体系，没有矛盾。我现在将着手解决。\n\n解决方案需要应用问题陈述中定义的三个阶段过程：\n1. 使用并查集数据结构构建持有相同值的变量的等价类。\n2. 通过将其等价类的代表替换临时变量的所有使用来重写 IR。\n3. 识别并计数在重写阶段后变得无用（即，定义的变量不再被使用）的副本赋值。\n\n初始的 IR 序列是：\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$\n3.  $x_{1} := w_{1}$\n4.  $y_{1} := x_{1}$\n5.  $\\mathrm{call\\_pure}(y_{1})$\n6.  $v_{2} := v_{1} + 1$\n7.  $w_{2} := v_{2}$\n8.  $t_{1} := w_{2}$\n9.  $u_{1} := t_{1}$\n10. $z_{1} := y_{1}$\n\n形如 $a := b$ 的副本赋值是指令 $2$、$3$、$4$、$7$、$8$、$9$ 和 $10$。\n\n**阶段 1：构建等价类**\n\n我们将按程序顺序处理每个副本赋值，以构建等价类。每个类的代表被定义为该类中按程序顺序最早的 SSA 名称。\n\n- 最初，每个变量都在其自己的集合中：$\\{v_{1}\\}, \\{w_{1}\\}, \\{x_{1}\\}, \\{y_{1}\\}, \\{v_{2}\\}, \\{w_{2}\\}, \\{t_{1}\\}, \\{u_{1}\\}, \\{z_{1}\\}$。\n\n- 指令 2：$w_{1} := v_{1}$。我们执行 $\\mathrm{union}(w_{1}, v_{1})$。由于 $v_{1}$ 在 $w_{1}$ 之前定义，因此 $v_{1}$ 成为代表。集合为 $\\{v_{1}, w_{1}\\}$。\n\n- 指令 3：$x_{1} := w_{1}$。我们执行 $\\mathrm{union}(x_{1}, w_{1})$。$w_{1}$ 所在集合的代表是 $v_{1}$。由于 $v_{1}$ 在 $x_{1}$ 之前定义，因此 $v_{1}$ 仍然是代表。集合变为 $\\{v_{1}, w_{1}, x_{1}\\}$。\n\n- 指令 4：$y_{1} := x_{1}$。我们执行 $\\mathrm{union}(y_{1}, x_{1})$。$x_{1}$ 所在集合的代表是 $v_{1}$。由于 $v_{1}$ 在 $y_{1}$ 之前定义，因此 $v_{1}$ 仍然是代表。集合变为 $\\{v_{1}, w_{1}, x_{1}, y_{1}\\}$。\n\n- 指令 7：$w_{2} := v_{2}$。我们执行 $\\mathrm{union}(w_{2}, v_{2})$。$v_{2}$ 在 $w_{2}$ 之前定义，所以 $v_{2}$ 是代表。这形成了一个新的等价类 $\\{v_{2}, w_{2}\\}$。\n\n- 指令 8：$t_{1} := w_{2}$。我们执行 $\\mathrm{union}(t_{1}, w_{2})$。$w_{2}$ 所在集合的代表是 $v_{2}$。由于 $v_{2}$ 在 $t_{1}$ 之前定义，因此 $v_{2}$ 仍然是代表。集合变为 $\\{v_{2}, w_{2}, t_{1}\\}$。\n\n- 指令 9：$u_{1} := t_{1}$。我们执行 $\\mathrm{union}(u_{1}, t_{1})$。$t_{1}$ 所在集合的代表是 $v_{2}$。由于 $v_{2}$ 在 $u_{1}$ 之前定义，因此 $v_{2}$ 仍然是代表。集合变为 $\\{v_{2}, w_{2}, t_{1}, u_{1}\\}$。\n\n- 指令 10：$z_{1} := y_{1}$。我们执行 $\\mathrm{union}(z_{1}, y_{1})$。$y_{1}$ 所在集合的代表是 $v_{1}$。由于 $v_{1}$ 在 $z_{1}$ 之前定义，因此 $v_{1}$ 仍然是代表。第一个集合变为 $\\{v_{1}, w_{1}, x_{1}, y_{1}, z_{1}\\}$。\n\n处理完所有副本指令后，我们得到两个不相交的等价类：\n1.  $C_{1} = \\{v_{1}, w_{1}, x_{1}, y_{1}, z_{1}\\}$，对于任何 $s \\in C_{1}$，其代表为 $\\mathrm{find}(s) = v_{1}$。\n2.  $C_{2} = \\{v_{2}, w_{2}, t_{1}, u_{1}\\}$，对于任何 $s \\in C_{2}$，其代表为 $\\mathrm{find}(s) = v_{2}$。\n\n**阶段 2：重写 IR 使用**\n\n我们现在用其等价类的代表替换每个变量的使用。\n\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$ (右侧 $v_{1}$ 是一个代表，不变)\n3.  $x_{1} := w_{1} \\implies x_{1} := \\mathrm{find}(w_{1}) \\implies x_{1} := v_{1}$\n4.  $y_{1} := x_{1} \\implies y_{1} := \\mathrm{find}(x_{1}) \\implies y_{1} := v_{1}$\n5.  $\\mathrm{call\\_pure}(y_{1}) \\implies \\mathrm{call\\_pure}(\\mathrm{find}(y_{1})) \\implies \\mathrm{call\\_pure}(v_{1})$\n6.  $v_{2} := v_{1} + 1$ (右侧 $v_{1}$ 是一个代表，不变)\n7.  $w_{2} := v_{2}$ (右侧 $v_{2}$ 是一个代表，不变)\n8.  $t_{1} := w_{2} \\implies t_{1} := \\mathrm{find}(w_{2}) \\implies t_{1} := v_{2}$\n9.  $u_{1} := t_{1} \\implies u_{1} := \\mathrm{find}(t_{1}) \\implies u_{1} := v_{2}$\n10. $z_{1} := y_{1} \\implies z_{1} := \\mathrm{find}(y_{1}) \\implies z_{1} := v_{1}$\n\n重写后的 IR（在死代码消除之前）是：\n1.  $v_{1} := \\mathrm{load}(A)$\n2.  $w_{1} := v_{1}$\n3.  $x_{1} := v_{1}$\n4.  $y_{1} := v_{1}$\n5.  $\\mathrm{call\\_pure}(v_{1})$\n6.  $v_{2} := v_{1} + 1$\n7.  $w_{2} := v_{2}$\n8.  $t_{1} := v_{2}$\n9.  $u_{1} := v_{2}$\n10. $z_{1} := v_{1}$\n\n**阶段 3：计数被消除的（无用）副本赋值**\n\n如果一个副本赋值所定义的变量在重写阶段后没有任何使用，则该赋值是无用的。我们检查每一个原始的副本赋值。\n\n-   指令 2：$w_{1} := v_{1}$。定义的变量是 $w_{1}$。它唯一的原始用途是在指令 $3$ 中，该指令现在是 $x_{1} := v_{1}$。因此，$w_{1}$ 没有剩余的用途。该赋值是无用的，被消除。\n-   指令 3：$x_{1} := w_{1}$。定义的变量是 $x_{1}$。它唯一的原始用途是在指令 $4$ 中，该指令现在是 $y_{1} := v_{1}$。因此，$x_{1}$ 没有剩余的用途。该赋值是无用的，被消除。\n-   指令 4：$y_{1} := x_{1}$。定义的变量是 $y_{1}$。它的原始用途是在指令 $5$ 和 $10$ 中，这两个指令现在是 $\\mathrm{call\\_pure}(v_{1})$ 和 $z_{1} := v_{1}$。因此，$y_{1}$ 没有剩余的用途。该赋值是无用的，被消除。\n-   指令 7：$w_{2} := v_{2}$。定义的变量是 $w_{2}$。它唯一的原始用途是在指令 $8$ 中，该指令现在是 $t_{1} := v_{2}$。因此，$w_{2}$ 没有剩余的用途。该赋值是无用的，被消除。\n-   指令 8：$t_{1} := w_{2}$。定义的变量是 $t_{1}$。它唯一的原始用途是在指令 $9$ 中，该指令现在是 $u_{1} := v_{2}$。因此，$t_{1}$ 没有剩余的用途。该赋值是无用的，被消除。\n-   指令 9：$u_{1} := t_{1}$。定义的变量是 $u_{1}$。在给定的代码块中它没有原始用途。它没有剩余的用途。该赋值是无用的，被消除。\n-   指令 10：$z_{1} := y_{1}$。定义的变量是 $z_{1}$。在给定的代码块中它没有原始用途。它没有剩余的用途。该赋值是无用的，被消除。\n\n所有七个副本赋值都被消除了。最终优化后的代码将是：\n1. $v_{1} := \\mathrm{load}(A)$\n2. $\\mathrm{call\\_pure}(v_{1})$\n3. $v_{2} := v_{1} + 1$\n\n被消除的副本赋值数量为 $7$。", "answer": "$$\\boxed{7}$$", "id": "3633963"}, {"introduction": "在真实的程序中，代码很少是直线型的；控制流分支与合并是常态。这个练习将探讨副本传播在遇到控制流汇合点（join point）时面临的关键挑战：来自不同执行路径的变量可能携带不同的值。通过对比经典的（非SSA）数据流分析与基于静态单赋值（SSA）形式的分析，你将理解为何SSA中的$\\phi$函数能优雅地解决这个问题，从而为更深层次的优化打开大门。[@problem_id:3633986]", "problem": "考虑一个由四个基本块 $B_0$、$B_1$、$B_2$ 和 $B_3$ 组成的控制流图（CFG）。块 $B_0$ 包含一个基于谓词 $c$ 的条件，如果 $c$ 为真，则分支到 $B_1$，否则分支到 $B_2$。块 $B_1$ 和 $B_2$ 在 $B_3$ 处汇合。程序片段如下，其中符号 $:=$ 表示赋值：\n\n- 在 $B_1$ 中：$x := y$。\n- 在 $B_2$ 中：$x := z$。\n- 在 $B_3$ 中：$w := x$。\n\n假设 $y$ 和 $z$ 在 $B_0$ 之前已定义，并且在 $B_1$ 或 $B_2$ 中 $y$ 和 $z$ 都未被修改。同时假设 $x$ 仅由 $B_1$ 和 $B_2$ 中所示的赋值语句定义。不存在影响 $x$、$y$、$z$ 或 $w$ 的副作用或别名。\n\n你需要根据编译器原理中的基本定义进行推理：\n\n- 控制流图（CFG）是一个有向图，其节点是基本块，其边代表可能的控制流转移。在汇合点（join node），多个前驱节点在此汇合，并且无论从哪个前驱节点到达，后续的语句都会执行。\n- 静态单赋值（SSA）形式是一种表示形式，其中每个变量只被赋值一次；在汇合点，特殊的 $\\phi$-函数会合并来自不同前驱节点的值。在一个有前驱节点 $P_1$ 和 $P_2$ 的汇合点，$\\phi$-函数 $u := \\phi(u_1, u_2)$ 的语义是：如果控制流来自 $P_1$，则 $u$ 取 $u_1$ 的值，否则 $u$ 取 $u_2$ 的值。\n- 经典复写传播（不使用 SSA）是一种前向数据流优化，当赋值语句 $u := v$ 是到达变量 $u$ 使用点的所有路径上的唯一到达复写，并且在这些路径上 $v$ 没有被重新定义时，它会用源变量 $v$ 替换变量 $u$ 的使用。到达复写（reaching copy）指的是一个复写赋值，在其到达使用点的路径上，其左侧变量未被重新定义所“杀死”（killed）。\n\n将该程序转换为 SSA 形式，然后分析在汇合点，基于 SSA 的复写传播与 $\\phi$-函数如何交互，并将其与在同一汇合点的经典数据流复写传播进行比较。在给定假设下，以下哪些陈述是正确的？\n\nA. 在经典的非 SSA 表示中，在 $B_3$ 处，语句 $w := x$ 不能通过复写传播转换为 $w := y$ 或 $w := z$，因为不同的复写 $x := y$ 和 $x := z$ 沿着不同的路径到达 $x$ 的使用点。\n\nB. 在 SSA 形式中，该片段变为：在 $B_1$ 中为 $x_1 := y$，在 $B_2$ 中为 $x_2 := z$，在 $B_3$ 中为语句 $x_3 := \\phi(x_1, x_2)$ 和 $w_1 := x_3$。基于 SSA 的复写传播可以用其源来替换 $\\phi$-函数的参数，得到 $x_3 := \\phi(y, z)$，然后通过将所有 $w_1$ 的使用替换为 $x_3$ 来消除复写 $w_1 := x_3$。\n\nC. 在 SSA 形式中，因为两个前驱赋值都是复写，所以 $\\phi$-函数 $x_3 := \\phi(x_1, x_2)$ 可以在汇合点简化为 $x_3 := y$，从而使 $w_1 := x_3$ 可以进一步化简为 $w_1 := y$。\n\nD. 在经典的非 SSA 表示中，在 $B_3$ 处引入 $w := \\phi(y, z)$ 来替换 $w := x$ 是一个有效的复写传播步骤，因为它在汇合点准确地将到达的复写合并为单个表达式。\n\nE. 一个经典的复写传播过程可以合法地将汇合点的代码转换为一个条件表达式 $w := c ? y : z$ 来消除 $x$，因为这保持了与原始 CFG 相同的语义。\n\n选择所有正确的选项。", "solution": "首先验证问题陈述，以确保其科学上合理、定义明确且客观。\n\n**步骤 1：提取已知条件**\n- 一个控制流图（CFG）有四个基本块：$B_0$、$B_1$、$B_2$、$B_3$。\n- 控制流：$B_0$ 在谓词 $c$ 为真时分支到 $B_1$，在 $c$ 为假时分支到 $B_2$。$B_1$ 和 $B_2$ 都流向 $B_3$（一个汇合点）。\n- 赋值语句：\n    - 在 $B_1$ 中：$x := y$。\n    - 在 $B_2$ 中：$x := z$。\n    - 在 $B_3$ 中：$w := x$。\n- 假设：\n    - $y$ 和 $z$ 在 $B_0$ 之前已定义。\n    - 在 $B_1$ 或 $B_2$ 中，$y$ 和 $z$ 都未被修改。\n    - $x$ 仅由 $B_1$ 和 $B_2$ 中的赋值语句定义。\n    - 不存在影响 $x, y, z, w$ 的副作用或别名。\n- 提供的定义：\n    - CFG（控制流图），汇合点。\n    - 静态单赋值（SSA）形式，$\\phi$-函数。\n    - 经典复写传播（要求在所有路径上存在唯一的到达复写）。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在编译器理论领域具有科学依据。CFG、SSA 和复写传播的概念都是标准的。问题定义明确，提供了具体的代码结构和清晰的定义作为基础。所给的假设消除了潜在的歧义（例如，$x$ 的其他定义、别名问题），使问题自洽且可解。语言精确客观。该问题不违反任何无效性标准。\n\n**步骤 3：结论与行动**\n问题陈述有效。将根据提供的定义推导出解决方案。\n\n**推导与分析**\n\n问题的核心是比较两种不同的程序表示——经典的非 SSA 形式和 SSA 形式——如何影响复写传播在控制流汇合点的适用性。\n\n**1. 经典（非 SSA）表示下的分析**\n\n我们分析基本块 $B_3$ 中的语句 $w := x$。根据所提供的定义，经典复写传播只有在“$x := v$ 是到达该使用点的 **所有路径上的唯一到达复写**”时，才能用复写赋值 $x := v$ 的右侧来替换 $x$ 的使用。\n\n- 从程序入口到 $B_3$ 的路径必须经过 $B_1$ 或 $B_2$。\n- **路径 1（通过 $B_1$）：** 控制流为 $B_0 \\rightarrow B_1 \\rightarrow B_3$。在这条路径上，到达 $B_3$ 中 $x$ 使用点的复写赋值是来自块 $B_1$ 的 $x := y$。\n- **路径 2（通过 $B_2$）：** 控制流为 $B_0 \\rightarrow B_2 \\rightarrow B_3$。在这条路径上，到达 $B_3$ 中 $x$ 使用点的复写赋值是来自块 $B_2$ 的 $x := z$。\n\n在块 $B_3$ 中 $w := x$ 对 $x$ 的使用点，存在两个不同的到达复写定义：$x := y$ 和 $x := z$。“唯一到达复写”的条件未被满足。因此，经典的复写传播过程不能将 $x$ 替换为 $y$ 或 $z$。这样做是错误的，因为它会忽略另一条路径上传播的值。例如，对于任何谓词 $c$ 为假的执行情况，将 $w := x$ 替换为 $w := y$ 都是不正确的。\n\n**2. 静态单赋值（SSA）表示下的分析**\n\n我们首先将程序片段转换为 SSA 形式。在 SSA 中，每个变量只被赋值一次。当一个变量的多个定义到达一个汇合点时，会插入一个 $\\phi$-函数来创建一个新的、唯一的定义。\n\n- $B_1$ 中的赋值 $x := y$ 定义了 $x$ 的一个新版本，记为 $x_1$。该语句变为 $x_1 := y$。\n- $B_2$ 中的赋值 $x := z$ 定义了 $x$ 的另一个新版本，记为 $x_2$。该语句变为 $x_2 := z$。\n- 在汇合点 $B_3$，$x_1$ 和 $x_2$ 这两个定义相遇。引入一个 $\\phi$-函数将它们合并成一个单一的新版本 $x_3$。该语句为 $x_3 := \\phi(x_1, x_2)$，其中参数分别对应前驱节点 $B_1$ 和 $B_2$。\n- $B_3$ 中 $w := x$ 对 $x$ 的使用现在必须引用支配它的唯一 $x$ 的定义，即 $x_3$。对 $w$ 的赋值也需要重命名，例如重命名为 $w_1$。该语句变为 $w_1 := x_3$。\n\n相关块的 SSA 形式如下：\n- 在 $B_1$ 中：$x_1 := y$。\n- 在 $B_2$ 中：$x_2 := z$。\n- 在 $B_3$ 中：\n    - $x_3 := \\phi(x_1, x_2)$\n    - $w_1 := x_3$\n\n现在，我们分析这种 SSA 形式下的复写传播。在 SSA 中，传播更简单，因为每个变量名都指向一个唯一定义。\n- 我们有复写 $x_1 := y$。$\\phi$-函数中对 $x_1$ 的使用可以被 $y$ 替换。\n- 我们有复写 $x_2 := z$。$\\phi$-函数中对 $x_2$ 的使用可以被 $z$ 替换。\n- 此步骤之后，$\\phi$-函数变为：$x_3 := \\phi(y, z)$。这是一个有效的 SSA 优化，通常被称为“SSA 复写传播”，或者可以作为更通用的“稀疏条件常量传播”（SCCP）算法的一部分。\n- 现在我们有语句 $w_1 := x_3$。这是一个复写赋值。任何后续对 $w_1$ 的使用都可以被 $x_3$ 替换。这是一个标准的复写消除/传播步骤。\n\n**逐项评估**\n\n**A. 在经典的非 SSA 表示中，在 $B_3$ 处，语句 $w := x$ 不能通过复写传播转换为 $w := y$ 或 $w := z$，因为不同的复写 $x := y$ 和 $x := z$ 沿着不同的路径到达 $x$ 的使用点。**\n该陈述是我们对经典非 SSA 情况分析的直接结果。在 $B_3$ 的入口处，数据流事实是存在两个关于 $x$ 的到达复写定义。根据所提供的经典复写传播的定义，该定义要求唯一的到达复写，因此该优化被阻止。\n**结论：正确。**\n\n**B. 在 SSA 形式中，该片段变为：在 $B_1$ 中为 $x_1 := y$，在 $B_2$ 中为 $x_2 := z$，在 $B_3$ 中为语句 $x_3 := \\phi(x_1, x_2)$ 和 $w_1 := x_3$。基于 SSA 的复写传播可以用其源来替换 $\\phi$-函数的参数，得到 $x_3 := \\phi(y, z)$，然后通过将所有 $w_1$ 的使用替换为 $x_3$ 来消除复写 $w_1 := x_3$。**\n该陈述准确地描述了转换为 SSA 并执行优化的过程。向 SSA 的转换是正确的。随后将 $y$ 和 $z$ 传播到 $\\phi$-函数中是标准的 SSA 优化。消除复写 $w_1 := x_3$ 也是一个标准的复写传播步骤。\n**结论：正确。**\n\n**C. 在 SSA 形式中，因为两个前驱赋值都是复写，所以 $\\phi$-函数 $x_3 := \\phi(x_1, x_2)$ 可以在汇合点简化为 $x_3 := y$，从而使 $w_1 := x_3$ 可以进一步化简为 $w_1 := y$。**\n该陈述提出了一个无效的简化。将复写传播到 $\\phi$-函数后，我们得到 $x_3 := \\phi(y, z)$。其语义是，如果控制流来自 $B_1$，$x_3$ 接收 $y$ 的值；如果控制流来自 $B_2$，$x_3$ 接收 $z$ 的值。只有当能保证 $y$ 和 $z$ 相等时，将其简化为 $x_3 := y$ 才是有效的，但我们不能做此假设。这将改变程序的语义。\n**结论：错误。**\n\n**D. 在经典的非 SSA 表示中，在 $B_3$ 处引入 $w := \\phi(y, z)$ 来替换 $w := x$ 是一个有效的复写传播步骤，因为它在汇合点准确地将到达的复写合并为单个表达式。**\n该陈述混淆了不同的概念。$\\phi$-函数是 SSA 中间表示特有的一个抽象。它不是“经典非 SSA 表示”中的一条指令。所描述的转换不是经典定义的复写传播（即简单的替换）。这种转换合成了一条新的、复杂的指令，该指令在语义上表示了 SSA 的汇合操作。\n**结论：错误。**\n\n**E. 一个经典的复写传播过程可以合法地将汇合点的代码转换为一个条件表达式 $w := c ? y : z$ 来消除 $x$，因为这保持了与原始 CFG 相同的语义。**\n虽然转换 $w := c ? y : z$ 在语义上等同于原始的控制流，但它不是“复写传播”。这是一种更高级的优化，称为*if-转换*（if-conversion）或*谓词化*（predication）。它涉及分析控制依赖（即 $B_1$ 和 $B_2$ 中的赋值对谓词 $c$ 的依赖）并将其转换为数据依赖。一个简单的复写传播过程，如定义所述，不会执行如此复杂的结构转换。\n**结论：错误。**", "answer": "$$\\boxed{AB}$$", "id": "3633986"}, {"introduction": "除了控制流，副本传播还必须应对更棘手的语义挑战，例如指针和函数调用可能带来的副作用。这个练习模拟了一个场景，其中一个函数调用通过地址（别名）修改了一个变量，这可能会使得先前建立的副本关系失效。通过分析这个案例，你将学会为何编译器必须采取保守策略，并理解流敏感分析（flow-sensitive analysis）在保证优化正确性方面的重要性。[@problem_id:3634027]", "problem": "考虑一个单线程过程 $F$ 中的一个中间表示（IR，Intermediate Representation，一种类似三地址码的形式）的直线代码片段，该过程有局部标量变量 $x$、$y$、$w$、$v$ 以及一个对过程 $h$ 的调用，该调用传递了一个局部变量的地址。符号  表示取地址运算符，参数传递是引用传递，即 $h$ 可以通过传递的指针进行写操作。假设存在一个标准的过程序内控制流图（CFG，Control Flow Graph，即由控制流连接的基本块构成的有向图），该图是线性的，并且严格按程序顺序求值。该代码片段如下：\n\n- 语句 $1$：$x := y$\n- 语句 $2$：$h(\\y)$\n- 语句 $3$：$w := y + 1$\n- 语句 $4$：$y := x$\n- 语句 $5$：$v := y + 2$\n- 语句 $6$：$\\mathrm{return}\\; w + v$\n\n关于 $h$ 的假设：\n- $h$ 可能会写入其参数指定的内存位置，即调用 $h(\\y)$ 可能会对 $y$ 进行赋值。\n- $h$ 不会通过 $x$ 的地址访问任何内存；除了语句 $2$ 中显式的  外，不存在 $x$ 或 $y$ 的其他别名。\n- $h$ 对 $x$ 没有隐藏的副作用，也不执行并发操作，并且没有异步效应。\n\n一个编译器尝试进行流敏感的复制传播，其目标是在变量可被证明相等时，用一个变量替换另一个变量的使用。该优化基于以下基本原则：\n\n- 赋值语义：在语句 $1$ 中，$x := y$ 将 $x$ 设置为存储在 $y$ 中的当前值。\n- 引用调用语义：在语句 $2$ 中，$h(\\y)$ 可能会改变 $y$；这等同于在语句 $2$ 执行期间对 $y$ 进行了某种写操作，但 $h$ 不会写入 $x$。\n- 复制传播的数据流安全条件：仅当从建立 $x = y$ 的定义点到该使用点的所有路径上，都没有对 $x$ 或 $y$ 的中间写操作（包括通过别名的间接写入）时，用 $x$ 替换 $y$ 的使用才是可靠的。\n\n在这些假设下，以下哪些对 $y$ 的替换为 $x$ 的操作能保证语义保持不变？\n\nA. 在语句 $3$ 和语句 $5$ 中都用 $x$ 替换 $y$。\n\nB. 仅在语句 $5$ 中用 $x$ 替换 $y$。\n\nC. 仅在语句 $3$ 中用 $x$ 替换 $y$。\n\nD. 在语句 $3$ 和语句 $5$ 中用 $x$ 替换 $y$ 都不是可靠的。\n\n选择唯一的最佳选项。", "solution": "对用户提供的问题陈述进行验证。\n\n### 第一步：提取已知条件\n- **代码片段：** 一个由六条语句组成的中间表示（IR）序列。\n  - 语句 $1$：$x := y$\n  - 语句 $2$：$h(\\y)$\n  - 语句 $3$：$w := y + 1$\n  - 语句 $4$：$y := x$\n  - 语句 $5$：$v := y + 2$\n  - 语句 $6$：$\\mathrm{return}\\; w + v$\n- **上下文：** 该代码片段位于一个单线程过程 $F$ 中。控制流是线性的，语句按程序顺序执行。\n- **变量：** 局部标量变量为 $x$、$y$、$w$ 和 $v$。\n- **函数调用 `h`：**\n  - `h` 接受一个指向变量的指针。在语句 $2$ 中，它被调用并传入 $y$ 的地址（`y`）。\n  - 参数传递是引用传递，意味着 $h$ 可以写入其参数的内存位置。\n  - 假设 $h(\\y)$ 可能会给 $y$ 赋一个新值。\n- **假设：**\n  - $h$ 不访问或修改 $x$。\n  - 除了在调用 $h$ 时由 `` 创建的别名外，不存在 $x$ 或 $y$ 的其他别名。\n  - $h$ 没有其他隐藏的副作用，也不存在并发或异步事件。\n- **优化任务：** 执行流敏感的复制传播。\n- **数据流安全条件：** “仅当从建立 $x = y$ 的定义点到该使用点的所有路径上，都没有对 $x$ 或 $y$ 的中间写操作（包括通过别名的间接写入）时，用 $x$ 替换 $y$ 的使用才是可靠的。”\n\n### 第二步：使用提取的已知条件进行验证\n根据验证标准评估问题陈述。\n- **科学性：** 该问题设置在编译器设计的背景下，这是计算机科学中一个成熟的子领域。所有概念，包括中间表示（IR）、复制传播、数据流分析、别名和引用调用，都是标准且严格定义的。该问题在科学上是合理的。\n- **良构性：** 该问题提供了一个特定的代码序列，定义了操作的语义，并为转换陈述了清晰明确的安全条件。它要求基于这些规则得出一个明确的结论。可以推导出一个唯一的、正确的答案。\n- **客观性：** 问题以精确、正式的语言陈述，没有主观性或歧义。\n- **完整性和一致性：** 问题是自洽的。提供的关于函数 $h$ 的假设至关重要，并且足以解决数据流分析问题。设置中没有矛盾之处。\n- **现实性：** 该场景是编译器优化中的一个经典且现实的问题。分析函数调用的影响，特别是涉及指针或引用的调用，是编译器为确保正确性而必须保守处理的一个基本挑战。\n\n### 第三步：结论与行动\n问题陈述内部一致、科学合理且良构。因此，它是**有效的**。现在开始求解过程。\n\n### 解题推导\n\n任务是确定在语句 $3$ 和语句 $5$ 中，何处可以安全地用变量 $x$ 替换变量 $y$ 的使用。这需要进行流敏感的数据流分析，以跟踪一个“复制事实”，我们可以将其表示为属性 $x=y$。分析逐条语句进行。一条语句可以*生成*一个复制事实（例如，像 $x:=y$ 这样的赋值），也可以*杀死*一个复制事实（例如，对复制对中的任一变量进行赋值）。\n\n**程序片段分析：**\n\n1.  **语句 $1$ 之后：$x := y$**\n    - 这条赋值语句*生成*了复制事实 $x=y$。在语句 $1$ 之后的程序点，可用复制集包括 $x=y$。\n\n2.  **在语句 $2$ 处：$h(\\y)$**\n    - 问题陈述指出，函数 $h$ 被调用时传入了 $y$ 的地址，并且 $h$ “可能会写入其参数指定的内存位置”。\n    - 为保证语义保持不变，编译器必须做出保守的假设。由于 $h$ *可能*会写入 $y$，分析必须假设它*确实*写入了 $y$。\n    - 对 $y$ 的写入是对 $y$ 的重新定义。根据安全条件，对复制对中任一变量的任何重新定义都会使该复制事实无效（或*杀死*该事实）。\n    - 在这里，对 $y$ 的潜在写入杀死了由语句 $1$ 生成的复制事实 $x=y$。根据假设，$x$ 的值保持不变，但 $y$ 的值现在是未知的，因此不再能保证 $x=y$。\n    - 在语句 $2$ 之后的程序点，可用复制集为空。\n\n3.  **在语句 $3$ 处：$w := y + 1$**\n    - 我们必须确定此语句中 $y$ 的使用是否可以被 $x$ 替换。\n    - 我们应用数据流安全条件：从建立 $x=y$ 的定义点到此使用点的所有路径上，是否都没有对 $x$ 或 $y$ 的中间写操作？\n    - 建立 $x=y$ 的相关定义是语句 $1$。\n    - 从语句 $1$ 到语句 $3$ 的路径是 $1 \\rightarrow 2 \\rightarrow 3$。\n    - 这条路径包含语句 $2$，$h(\\y)$，它充当了对 $y$ 的中间写操作（一个*杀死*操作）。\n    - 因此，安全条件被违反。在语句 $3$ 中用 $x$ 替换 $y$ 是**不可靠的**，并且不能保持语义。\n\n4.  **语句 $4$ 之后：$y := x$**\n    - 这是一条新的赋值语句。它是一个复制赋值，*生成*了复制事实 $y=x$（等同于 $x=y$）。\n    - 任何先前涉及 $y$ 的复制事实都已被杀死，但这条语句明确地重新建立了 $x$ 和 $y$ 的相等性。\n    - 在语句 $4$ 之后的程序点，可用复制集现在包括 $x=y$。\n\n5.  **在语句 $5$ 处：$v := y + 2$**\n    - 我们必须确定此语句中 $y$ 的使用是否可以被 $x$ 替换。\n    - 我们再次应用数据流安全条件。现在，建立 $x=y$ 的相关定义是语句 $4$。\n    - 从语句 $4$ 到语句 $5$ 中 $y$ 的使用点的路径是直接的控制流边 $4 \\rightarrow 5$。\n    - 这条路径是否包含对 $x$ 或 $y$ 的任何中间写操作？不。在语句 $4$ 完成和在语句 $5$ 中使用 $y$ 之间，没有执行其他语句，因此没有对 $x$ 或 $y$ 的修改发生。\n    - 安全条件得到满足。在语句 $5$ 中用 $x$ 替换 $y$ 是**可靠的**，并且能保持语义。\n\n**分析结论：**\n- 在语句 $3$ 中用 $y$ 替换 $x$ 是**不安全的**。\n- 在语句 $5$ 中用 $y$ 替换 $x$ 是**安全的**。\n\n### 逐项分析\n\n**A. 在语句 $3$ 和语句 $5$ 中都用 $x$ 替换 $y$。**\n- **分析：** 此选项声称两个替换都是可靠的。我们的分析表明，由于对 $h(\\y)$ 的调用可能修改 $y$，语句 $3$ 中的替换是不可靠的。\n- **结论：** 错误。\n\n**B. 仅在语句 $5$ 中用 $x$ 替换 $y$。**\n- **分析：** 此选项声称在语句 $5$ 中的替换是可靠的，但在其他地方则不然（言下之意，在语句 $3$ 中不可靠）。我们的分析证实，在语句 $5$ 中的替换是可靠的，因为复制事实 $x=y$ 在语句 $4$ 处生成，并且在语句 $5$ 使用前没有被杀死。这也正确地暗示了在语句 $3$ 中的替换是不可靠的。\n- **结论：** 正确。\n\n**C. 仅在语句 $3$ 中用 $x$ 替换 $y$。**\n- **分析：** 此选项声称在语句 $3$ 中的替换是可靠的，但在语句 $5$ 中不是。这与我们的发现相反。在语句 $3$ 中的替换是不可靠的。\n- **结论：** 错误。\n\n**D. 在语句 $3$ 和语句 $5$ 中用 $x$ 替换 $y$ 都不是可靠的。**\n- **分析：** 此选项声称两个替换都不可靠。我们的分析表明，在语句 $5$ 中的替换是可靠的。\n- **结论：** 错误。", "answer": "$$\\boxed{B}$$", "id": "3634027"}]}