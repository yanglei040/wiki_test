{"hands_on_practices": [{"introduction": "本练习旨在巩固对前向“可能”分析的理解。它要求你为包含 `switch` 等复杂控制结构的代码构建控制流图（CFG），然后系统地应用迭代数据流算法，以追踪哪些变量定值可能到达程序的各个点。通过这个过程，你将加深对到达定值分析这一经典前向分析问题的掌握。[@problem_id:3642723]", "problem": "考虑以下直线型伪代码，该代码使用带有显式贯穿（fall-through）语义的 `switch` 语句实现多路分支。每个编号的标签 $n_i$ 表示一个包含单条语句的程序点，但 $n_3$ 除外，它是 `switch` 分派点。程序如下：\n\n$n_1$: $a \\leftarrow 0$\n\n$n_2$: $b \\leftarrow 0$\n\n$n_3$: 根据 $t$ 的值进行 switch，情况如下：\n- 情况 $0$: \n  $n_4$: $a \\leftarrow 1$\n  （贯穿到情况 $1$）\n- 情况 $1$:\n  $n_5$: $b \\leftarrow a + 2$\n  中断并跳出 switch\n- 情况 $2$:\n  $n_6$: $c \\leftarrow b + 3$\n  （贯穿到情况 $3$）\n- 情况 $3$:\n  $n_7$: $a \\leftarrow c + 4$\n  （贯穿到默认情况）\n- 默认情况:\n  $n_8$: $b \\leftarrow a + b$\n\n$n_9$: $d \\leftarrow a + b$\n\n为该程序的控制流图（CFG）建模，其中 $n_3$ 有出边指向每个匹配情况的第一条语句，以及在没有情况匹配时指向默认情况；当没有 `break` 时，贯穿会创建一条从一个情况体（case body）的最后一条语句到下一个情况体的第一条语句的边。$n_5$ 处的显式 `break` 将控制权转移到 $n_9$（紧随 `switch` 之后的点）。\n\n使用一个基于CFG边的标准前向“可能到达定义”（May-Reaching-Definitions）分析。将每个赋值与一个唯一定义标识符关联如下：\n- $n_1$ 处的 $d_1$ 定义了 $a$，\n- $n_2$ 处的 $d_2$ 定义了 $b$，\n- $n_4$ 处的 $d_3$ 定义了 $a$，\n- $n_5$ 处的 $d_4$ 定义了 $b$，\n- $n_6$ 处的 $d_5$ 定义了 $c$，\n- $n_7$ 处的 $d_6$ 定义了 $a$，\n- $n_8$ 处的 $d_7$ 定义了 $b$，\n- $n_9$ 处的 $d_8$ 定义了 $d$。\n\n对于每个CFG边 $(n_i \\rightarrow n_j)$，在以下语义下建立基于边的前向 $GEN(n_i \\rightarrow n_j)$ 和 $KILL(n_i \\rightarrow n_j)$ 集合：\n- 如果 $n_i$ 包含某个变量 $x$ 的定义，那么 $GEN(n_i \\rightarrow n_j) = \\{d_k\\}$，其中 $d_k$ 是 $n_i$ 处定义的唯一标识符，而 $KILL(n_i \\rightarrow n_j)$ 是该过程中 $x$ 的所有其他定义的集合（即，除 $d_k$ 外所有对 $x$ 的定义）。\n- 如果 $n_i$ 不包含定义，那么 $GEN(n_i \\rightarrow n_j) = \\varnothing$ 且 $KILL(n_i \\rightarrow n_j) = \\varnothing$。\n\n然后，使用这些基于边的 $GEN$/$KILL$ 集合和以并集为汇集（meet）运算符的标准前向“可能到达定义”数据流方程，确定可能到达 $n_9$ 之前程序点的不同定义的数量。以一个整数形式报告你的最终答案，该整数等于 $RD_{\\text{in}}(n_9)$ 的基数，其中 $RD_{\\text{in}}(n_9)$ 表示所有可以通过遵循 `switch` 和贯穿语义的CFG路径到达 $n_9$ 之前的点的定义标识符的集合。", "solution": "该问题陈述清晰，其科学基础根植于编译器理论的原理，并且是客观的。它为给定伪代码片段上的前向“可能到达定义”分析提供了完整的规范。构建控制流图（CFG）、定义分析集和应用数据流方程的所有必要规则都已明确陈述且内部一致。因此，该问题是有效的，可以推导出一个解决方案。\n\n第一步是根据所提供的伪代码和分支规则对程序的控制流图（CFG）进行建模。图的节点是编号的程序点 $n_1$ 到 $n_9$。边由控制流决定：\n- 顺序流：$(n_1 \\rightarrow n_2)$，$(n_2 \\rightarrow n_3)$。\n- 从 $n_3$ 开始的 `switch` 分派：问题指出，$n_3$ 有出边指向每个情况的第一条语句以及默认情况。这产生了边 $(n_3 \\rightarrow n_4)$、$(n_3 \\rightarrow n_5)$、$(n_3 \\rightarrow n_6)$、$(n_3 \\rightarrow n_7)$ 和 $(n_3 \\rightarrow n_8)$。\n- 贯穿：情况 $0$ 贯穿到情况 $1$，创建边 $(n_4 \\rightarrow n_5)$。情况 $2$ 贯穿到情况 $3$，创建边 $(n_6 \\rightarrow n_7)$。情况 $3$ 贯穿到默认情况，创建边 $(n_7 \\rightarrow n_8)$。\n- `break`：$n_5$ 处的 `break` 将控制权转移到 switch 之后的位置，即 $n_9$。这创建了边 $(n_5 \\rightarrow n_9)$。\n- switch 结束：在 $n_8$ 的默认情况体执行后，控制流转到下一条语句 $n_9$。这创建了边 $(n_8 \\rightarrow n_9)$。\n所以，目标节点 $n_9$ 的前驱是 $n_5$ 和 $n_8$。\n\n接下来，我们建立定义和 $GEN/KILL$ 集合。问题为定义 $d_1, \\dots, d_8$ 分配了唯一的标识符。我们首先按它们定义的变量对这些定义进行分组：\n- 变量 $a$：$Defs(a) = \\{d_1, d_3, d_6\\}$\n- 变量 $b$：$Defs(b) = \\{d_2, d_4, d_7\\}$\n- 变量 $c$：$Defs(c) = \\{d_5\\}$\n- 变量 $d$：$Defs(d) = \\{d_8\\}$\n\n问题指定了 $GEN$ 和 $KILL$ 集合的基于边的公式。对于一条边 $(n_i \\rightarrow n_j)$：\n- 如果 $n_i$ 包含变量 $x$ 的定义 $d_k$，那么 $GEN(n_i \\rightarrow n_j) = \\{d_k\\}$ 且 $KILL(n_i \\rightarrow n_j) = Defs(x) \\setminus \\{d_k\\}$。\n- 如果 $n_i$ 不包含定义，则 $GEN(n_i \\rightarrow n_j) = \\varnothing$ 且 $KILL(n_i \\rightarrow n_j) = \\varnothing$。\n基于此，源于带定义节点的边的 $GEN/KILL$ 集合如下：\n- $n_1: a \\leftarrow 0$。对于边 $(n_1 \\rightarrow n_2)$，$GEN = \\{d_1\\}$，$KILL = \\{d_3, d_6\\}$。\n- $n_2: b \\leftarrow 0$。对于边 $(n_2 \\rightarrow n_3)$，$GEN = \\{d_2\\}$，$KILL = \\{d_4, d_7\\}$。\n- $n_4: a \\leftarrow 1$。对于边 $(n_4 \\rightarrow n_5)$，$GEN = \\{d_3\\}$，$KILL = \\{d_1, d_6\\}$。\n- $n_5: b \\leftarrow a + 2$。对于边 $(n_5 \\rightarrow n_9)$，$GEN = \\{d_4\\}$，$KILL = \\{d_2, d_7\\}$。\n- $n_6: c \\leftarrow b + 3$。对于边 $(n_6 \\rightarrow n_7)$，$GEN = \\{d_5\\}$，$KILL = \\varnothing$。\n- $n_7: a \\leftarrow c + 4$。对于边 $(n_7 \\rightarrow n_8)$，$GEN = \\{d_6\\}$，$KILL = \\{d_1, d_3\\}$。\n- $n_8: b \\leftarrow a + b$。对于边 $(n_8 \\rightarrow n_9)$，$GEN = \\{d_7\\}$，$KILL = \\{d_2, d_4\\}$。\n对于节点 $n_3$，它没有定义，所以其所有出边的 $GEN=\\varnothing$ 和 $KILL=\\varnothing$。\n\n到达定义（$RD$）分析是一个前向“可能”（may）分析，因此汇集运算符是集合并集（$\\cup$）。数据流方程为：\n$$RD_{in}(n_j) = \\bigcup_{(n_i, n_j) \\in Edges} RD_{edge}(n_i \\rightarrow n_j)$$\n$$RD_{edge}(n_i \\rightarrow n_j) = (RD_{in}(n_i) \\setminus KILL(n_i \\rightarrow n_j)) \\cup GEN(n_i \\rightarrow n_j)$$\n我们初始化 $RD_{in}(n_1) = \\varnothing$ 以及所有其他节点 $k$ 的 $RD_{in}(n_k) = \\varnothing$。我们进行迭代，直到集合收敛。\n\n**迭代 1：**\n1.  $RD_{in}(n_1) = \\varnothing$。\n2.  $RD_{edge}(n_1 \\rightarrow n_2) = (RD_{in}(n_1) \\setminus \\{d_3, d_6\\}) \\cup \\{d_1\\} = \\{d_1\\}$。\n3.  $RD_{in}(n_2) = RD_{edge}(n_1 \\rightarrow n_2) = \\{d_1\\}$。\n4.  $RD_{edge}(n_2 \\rightarrow n_3) = (RD_{in}(n_2) \\setminus \\{d_4, d_7\\}) \\cup \\{d_2\\} = (\\{d_1\\} \\setminus \\{d_4, d_7\\}) \\cup \\{d_2\\} = \\{d_1, d_2\\}$。\n5.  $RD_{in}(n_3) = RD_{edge}(n_2 \\rightarrow n_3) = \\{d_1, d_2\\}$。\n6.  对于所有边 $(n_3 \\rightarrow n_j)$，$RD_{edge}(n_3 \\rightarrow n_j) = (RD_{in}(n_3) \\setminus \\varnothing) \\cup \\varnothing = \\{d_1, d_2\\}$。\n7.  $RD_{in}(n_4) = RD_{edge}(n_3 \\rightarrow n_4) = \\{d_1, d_2\\}$。\n8.  $RD_{edge}(n_4 \\rightarrow n_5) = (RD_{in}(n_4) \\setminus \\{d_1, d_6\\}) \\cup \\{d_3\\} = (\\{d_1, d_2\\} \\setminus \\{d_1, d_6\\}) \\cup \\{d_3\\} = \\{d_2, d_3\\}$。\n9.  $RD_{in}(n_5) = RD_{edge}(n_3 \\rightarrow n_5) \\cup RD_{edge}(n_4 \\rightarrow n_5) = \\{d_1, d_2\\} \\cup \\{d_2, d_3\\} = \\{d_1, d_2, d_3\\}$。\n10. $RD_{in}(n_6) = RD_{edge}(n_3 \\rightarrow n_6) = \\{d_1, d_2\\}$。\n11. $RD_{edge}(n_6 \\rightarrow n_7) = (RD_{in}(n_6) \\setminus \\varnothing) \\cup \\{d_5\\} = \\{d_1, d_2, d_5\\}$。\n12. $RD_{in}(n_7) = RD_{edge}(n_3 \\rightarrow n_7) \\cup RD_{edge}(n_6 \\rightarrow n_7) = \\{d_1, d_2\\} \\cup \\{d_1, d_2, d_5\\} = \\{d_1, d_2, d_5\\}$。\n13. $RD_{edge}(n_7 \\rightarrow n_8) = (RD_{in}(n_7) \\setminus \\{d_1, d_3\\}) \\cup \\{d_6\\} = (\\{d_1, d_2, d_5\\} \\setminus \\{d_1, d_3\\}) \\cup \\{d_6\\} = \\{d_2, d_5, d_6\\}$。\n14. $RD_{in}(n_8) = RD_{edge}(n_3 \\rightarrow n_8) \\cup RD_{edge}(n_7 \\rightarrow n_8) = \\{d_1, d_2\\} \\cup \\{d_2, d_5, d_6\\} = \\{d_1, d_2, d_5, d_6\\}$。\n15. 最后，我们计算到 $n_9$ 的输入：\n    - $RD_{edge}(n_5 \\rightarrow n_9) = (RD_{in}(n_5) \\setminus \\{d_2, d_7\\}) \\cup \\{d_4\\} = (\\{d_1, d_2, d_3\\} \\setminus \\{d_2, d_7\\}) \\cup \\{d_4\\} = \\{d_1, d_3, d_4\\}$。\n    - $RD_{edge}(n_8 \\rightarrow n_9) = (RD_{in}(n_8) \\setminus \\{d_2, d_4\\}) \\cup \\{d_7\\} = (\\{d_1, d_2, d_5, d_6\\} \\setminus \\{d_2, d_4\\}) \\cup \\{d_7\\} = \\{d_1, d_5, d_6, d_7\\}$。\n16. $RD_{in}(n_9) = RD_{edge}(n_5 \\rightarrow n_9) \\cup RD_{edge}(n_8 \\rightarrow n_9) = \\{d_1, d_3, d_4\\} \\cup \\{d_1, d_5, d_6, d_7\\} = \\{d_1, d_3, d_4, d_5, d_6, d_7\\}$。\n\n**迭代 2：**\n必须执行第二次迭代以检查是否收敛。\n使用迭代1的值重新计算 $n_1, \\dots, n_8$ 的 $RD_{in}$ 集合。\n1.  $RD_{in}(n_2)$ 依赖于 $RD_{in}(n_1)=\\varnothing$，无变化。\n2.  $RD_{in}(n_3)$ 依赖于 $RD_{in}(n_2)$，无变化。\n3.  $RD_{in}(n_4)$ 依赖于 $RD_{in}(n_3)$，无变化。\n4.  $RD_{in}(n_5)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_4)$，无变化。\n5.  $RD_{in}(n_6)$ 依赖于 $RD_{in}(n_3)$，无变化。\n6.  $RD_{in}(n_7)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_6)$，无变化。\n7.  $RD_{in}(n_8)$ 依赖于 $RD_{in}(n_3)$ 和 $RD_{in}(n_7)$，无变化。\n由于从 $n_1$ 到 $n_8$ 的任何节点的 $RD_{in}$ 集合都没有改变，因此用于计算 $RD_{in}(n_9)$ 的输入保持不变。因此，算法已经收敛。\n\n可能到达 $n_9$ 之前程序点的定义集合是：\n$$RD_{in}(n_9) = \\{d_1, d_3, d_4, d_5, d_6, d_7\\}$$\n问题要求这个集合中不同定义的数量，即其基数。\n$$|RD_{in}(n_9)| = |\\{d_1, d_3, d_4, d_5, d_6, d_7\\}| = 6$$\n可以到达该点的定义是：\n- $d_1$：$a$ 的初始定义。通过不经过 $n_4$ 或 $n_7$ 的路径到达（例如，当 $t=1$ 时的路径）。\n- $d_3$：情况 $0$ 中 $a$ 的定义。通过当 $t=0$ 时的路径到达。\n- $d_4$：情况 $1$ 中 $b$ 的定义。通过当 $t=0$ 或 $t=1$ 时的路径到达。\n- $d_5$：情况 $2$ 中 $c$ 的定义。通过当 $t=2$ 时的路径到达。\n- $d_6$：情况 $3$ 中 $a$ 的定义。通过当 $t=2$ 或 $t=3$ 时的路径到达。\n- $d_7$：默认情况中 $b$ 的定义。通过当 $t=2$、$t=3$ 或默认情况时的路径到达。\n唯一不能到达的定义是 $d_2$（$b$ 的初始定义），因为每条到 $n_9$ 的路径都包含对 $b$ 的后续重定义（$d_4$ 或 $d_7$）。定义 $d_8$ 是在 $n_9$ 处生成的，所以它不在 $RD_{in}(n_9)$ 中。\n\n不同定义的总数是 $6$。", "answer": "$$\\boxed{6}$$", "id": "3642723"}, {"introduction": "本练习将焦点转向后向分析及其实现效率。你不仅需要执行一个经典的活性变量分析，还将比较两种不同的工作列表算法（FIFO 与基于逆后序的优先级队列），凭经验发现为何处理顺序对迭代求解器的性能至关重要，尤其是在处理带有循环的程序时。[@problem_id:3642671]", "problem": "考虑一个在控制流图（CFG）上进行活性分析的后向数据流分析实例。目标是比较两种工作列表策略，并量化它们在求解活性方程时对收敛速度的影响。\n\n使用以下内容作为基本依据：\n- 对于每个基本块 $n$，后向活性传递方程为\n$$\\mathrm{OUT}[n] \\;=\\; \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{IN}[s], \\qquad \\mathrm{IN}[n] \\;=\\; \\mathrm{USE}[n] \\;\\cup\\; \\left(\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]\\right)。$$\n- 格（lattice）是变量的有限幂集，按集合包含关系排序，其交运算（meet）为集合并集，底元素（bottom）为 $\\emptyset$。\n- 对所有基本块 $n$，初始化 $\\mathrm{IN}[n] \\leftarrow \\emptyset$ 和 $\\mathrm{OUT}[n] \\leftarrow \\emptyset$。\n- 该工作列表算法维护一个基于集合的工作列表，其中从不包含重复的基本块。初始时，将所有基本块插入工作列表。当工作列表非空时，根据所选策略移除一个基本块 $n$，根据其后继的当前 $\\mathrm{IN}$ 值重新计算 $\\mathrm{OUT}[n]$，再重新计算 $\\mathrm{IN}[n]$，如果 $\\mathrm{IN}[n]$ 发生变化，则将 $n$ 的所有当前不在工作列表中的前驱插入工作列表。不要因为 $n$ 自身的变化而将其重新插入。每次从工作列表中移除一个基本块计为一个处理步骤。\n\n该CFG有基本块 $B_1, B_2, B_3, B_4, B_5$，其后继为\n- $\\mathrm{succ}(B_1) = \\{B_2, B_3\\}$,\n- $\\mathrm{succ}(B_2) = \\{B_4\\}$,\n- $\\mathrm{succ}(B_3) = \\{B_4\\}$,\n- $\\mathrm{succ}(B_4) = \\{B_2, B_5\\}$,\n- $\\mathrm{succ}(B_5) = \\varnothing$,\n其变量 $\\{a,b\\}$ 上的 $\\mathrm{USE}/\\mathrm{DEF}$ 集合为\n- $B_1$: $\\mathrm{USE} = \\varnothing$, $\\mathrm{DEF} = \\{a\\}$,\n- $B_2$: $\\mathrm{USE} = \\{a\\}$, $\\mathrm{DEF} = \\{b\\}$,\n- $B_3$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\varnothing$,\n- $B_4$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\{a\\}$,\n- $B_5$: $\\mathrm{USE} = \\varnothing$, $\\mathrm{DEF} = \\varnothing$.\n\n比较以下两种工作列表移除策略：\n- 先进先出（FIFO）：使用一个队列，初始顺序为 $B_1, B_2, B_3, B_4, B_5$，从队头移除，并按基本块索引递增的顺序将新添加的前驱附加到队尾。\n- 逆后序（RPO）优先级：从 $B_1$ 开始对前向CFG进行深度优先搜索，按基本块索引递增的顺序访问后继，根据完成时间分配后序编号，逆后序即为后序编号的降序序列。维护一个以在此逆后序序列中的位置为键的优先级工作列表；每一步移除位置值最小（在RPO中最早）的基本块。任意但确定性地解决平局；不允许工作列表中有重复项。\n\n任务：\n1. 仅根据后向活性分析的基本性质，定性预测这两种策略中哪一种可能在该CFG上产生更少的处理步骤，并说明你的预测理由。\n2. 然后，通过在两种策略下执行指定的工作列表算法直至收敛来进行经验验证。设 $C_{\\mathrm{FIFO}}$ 为FIFO策略下的总移除块数，$C_{\\mathrm{RPO}}$ 为RPO策略下的总移除块数。报告单个数值 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$。\n\n你的最终答案必须是 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$ 的精确值。", "solution": "该问题要求进行定性预测和经验计算，以比较两种工作列表策略（FIFO 和 RPO）在后向活性分析中的效率。\n\n### 第1部分：定性预测\n\n数据流分析问题的特点是信息流动的方向。在后向分析（如活性分析）中，一个基本块 $n$ 入口处（即 $\\mathrm{IN}[n]$）的数据流事实取决于该块出口处（$\\mathrm{OUT}[n]$）的事实，而后者又取决于其后继入口处（$\\mathrm{IN}[s]$ for $s \\in \\mathrm{succ}(n)$）的事实。因此，信息从后继“向后”传播到前驱，与控制流的方向相反。\n\n一个高效的工作列表算法会以与数据流方向一致的顺序处理基本块，从而最大限度地减少因其依赖项变化而必须重新处理一个块的次数。对于后向分析，这意味着理想的处理顺序是在一个块的所有后继都已被处理且其数据流信息稳定之后，才处理该块。因此，一个近似于控制流图（CFG）逆拓扑排序的顺序是理想的。前向CFG的后序遍历提供了这样一种排序。\n\n问题指定了两种策略：\n1.  **先进先出（FIFO）**：该策略没有施加任何结构化的顺序。其效率取决于队列中块的初始排列以及CFG的具体结构。它本身并非为前向或后向分析而优化。\n2.  **逆后序（RPO）**：已知前向CFG的逆后序是*前向*数据流分析的一种高效启发式方法。它倾向于以拓扑排序的顺序访问节点，确保在处理一个块时，其前驱的数据流信息很可能是最新的。\n\n当RPO策略应用于*后向*分析时，它会系统性地产生反效果。通过以前向流高效的顺序处理块，它内在地以后向流低效的顺序处理它们。一个块 $n$ 很可能在其后继 $s \\in \\mathrm{succ}(n)$ 之前被处理，而它需要从这些后继获取信息来计算其 $\\mathrm{OUT}[n]$ 集合。这导致基于不完整信息的初始计算（例如，在处理 $s$ 之前使用 $\\mathrm{IN}[s] = \\emptyset$），这迫使 $n$ 在其后继的信息可用时被重新添加回工作列表并稍后重新处理。这种处理顺序与数据流方向之间的系统性错位预计会导致更多的块处理步骤。\n\nFIFO策略没有表现出这种与数据流方向的系统性对立。虽然不是最优的，但其结构性较弱的性质使其不太可能成为最差的。因此，预测对于此后向分析，RPO策略的效率将低于FIFO。这意味着RPO的总移除块数 $C_{\\mathrm{RPO}}$ 将大于FIFO的总移除块数 $C_{\\mathrm{FIFO}}$。\n\n### 第2部分：经验验证\n\n我们现在将跟踪两种策略下工作列表算法的执行过程，以确定确切的处理步骤数。状态由每个块的 $\\mathrm{IN}$ 集合定义，记为 $I_1, \\dots, I_5$。初始时，所有的 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合都为 $\\emptyset$。\n\n数据流方程为：\n$\\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{succ}(n)} \\mathrm{IN}[s]$\n$\\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup (\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n])$\n\n相关集合为：\n- $B_1$: $\\mathrm{USE} = \\emptyset$, $\\mathrm{DEF} = \\{a\\}$\n- $B_2$: $\\mathrm{USE} = \\{a\\}$, $\\mathrm{DEF} = \\{b\\}$\n- $B_3$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\emptyset$\n- $B_4$: $\\mathrm{USE} = \\{b\\}$, $\\mathrm{DEF} = \\{a\\}$\n- $B_5$: $\\mathrm{USE} = \\emptyset$, $\\mathrm{DEF} = \\emptyset$\n\n前驱为：\n- $\\mathrm{pred}(B_1) = \\emptyset$\n- $\\mathrm{pred}(B_2) = \\{B_1, B_4\\}$\n- $\\mathrm{pred}(B_3) = \\{B_1\\}$\n- $\\mathrm{pred}(B_4) = \\{B_2, B_3\\}$\n- $\\mathrm{pred}(B_5) = \\{B_4\\}$\n\n#### FIFO 策略执行过程\n\n初始工作列表是一个队列 $W = [B_1, B_2, B_3, B_4, B_5]$。步骤计数器 $C_{\\mathrm{FIFO}}$ 初始化为 $0$。\n\n1.  **步骤 1**：移除 $B_1$。$C_{\\mathrm{FIFO}}=1$。$O_1 = I_2 \\cup I_3 = \\emptyset$。$I_1' = \\emptyset \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$。$I_1$ 未改变。$W = [B_2, B_3, B_4, B_5]$。\n2.  **步骤 2**：移除 $B_2$。$C_{\\mathrm{FIFO}}=2$。$O_2 = I_4 = \\emptyset$。$I_2' = \\{a\\} \\cup (\\emptyset \\setminus \\{b\\}) = \\{a\\}$。$I_2$ 改变。添加前驱 $\\{B_1, B_4\\}$。$B_4$ 在 $W$ 中。添加 $B_1$。$W = [B_3, B_4, B_5, B_1]$。\n3.  **步骤 3**：移除 $B_3$。$C_{\\mathrm{FIFO}}=3$。$O_3 = I_4 = \\emptyset$。$I_3' = \\{b\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{b\\}$。$I_3$ 改变。添加前驱 $B_1$。$B_1$ 在 $W$ 中。$W = [B_4, B_5, B_1]$。\n4.  **步骤 4**：移除 $B_4$。$C_{\\mathrm{FIFO}}=4$。$O_4 = I_2 \\cup I_5 = \\{a\\} \\cup \\emptyset = \\{a\\}$。$I_4' = \\{b\\} \\cup (\\{a\\} \\setminus \\{a\\}) = \\{b\\}$。$I_4$ 改变。添加前驱 $\\{B_2, B_3\\}$。$W = [B_5, B_1, B_2, B_3]$。\n5.  **步骤 5**：移除 $B_5$。$C_{\\mathrm{FIFO}}=5$。$O_5 = \\emptyset$。$I_5' = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$。$I_5$ 未改变。$W = [B_1, B_2, B_3]$。\n6.  **步骤 6**：移除 $B_1$。$C_{\\mathrm{FIFO}}=6$。$O_1 = I_2 \\cup I_3 = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。$I_1' = \\emptyset \\cup (\\{a, b\\} \\setminus \\{a\\}) = \\{b\\}$。$I_1$ 改变。无前驱可添加。$W = [B_2, B_3]$。\n7.  **步骤 7**：移除 $B_2$。$C_{\\mathrm{FIFO}}=7$。$O_2 = I_4 = \\{b\\}$。$I_2' = \\{a\\} \\cup (\\{b\\} \\setminus \\{b\\}) = \\{a\\}$。$I_2$ 未改变。$W = [B_3]$。\n8.  **步骤 8**：移除 $B_3$。$C_{\\mathrm{FIFO}}=8$。$O_3 = I_4 = \\{b\\}$。$I_3' = \\{b\\} \\cup (\\{b\\} \\setminus \\emptyset) = \\{b\\}$。$I_3$ 未改变。$W = []$。\n\n工作列表为空。算法终止。总处理步骤数为 $C_{\\mathrm{FIFO}} = 8$。\n\n#### RPO 策略执行过程\n\n首先，我们确定逆后序。从 $B_1$ 开始的深度优先搜索（按索引递增顺序访问后继）过程为 $B_1 \\to B_2 \\to B_4 \\to B_5$。$B_2$ 是 $B_4$ 的一个后继，但它是一个祖先节点，表明存在一条后向边。然后我们回溯，并从 $B_1$ 访问 $B_3$。\n- 后序完成时间：$B_5(1)$, $B_4(2)$, $B_2(3)$, $B_3(4)$, $B_1(5)$。\n- 后序序列：$(B_5, B_4, B_2, B_3, B_1)$。\n- 逆后序（RPO）序列：$(B_1, B_3, B_2, B_4, B_5)$。\n一个块的优先级是其在RPO序列中的位置（位置值越小，优先级越高）。优先级：$p(B_1)=1, p(B_3)=2, p(B_2)=3, p(B_4)=4, p(B_5)=5$。\n\n初始工作列表是一个集合 $W = \\{B_1, B_2, B_3, B_4, B_5\\}$。步骤计数器 $C_{\\mathrm{RPO}}$ 初始化为 $0$。\n\n1.  **步骤 1**：提取 $B_1$ ($p=1$)。$C_{\\mathrm{RPO}}=1$。$O_1 = I_2 \\cup I_3 = \\emptyset$。$I_1' = \\emptyset$。未改变。$W = \\{B_2, B_3, B_4, B_5\\}$。\n2.  **步骤 2**：提取 $B_3$ ($p=2$)。$C_{\\mathrm{RPO}}=2$。$O_3 = I_4 = \\emptyset$。$I_3' = \\{b\\}$。$I_3$ 改变。添加前驱 $B_1$。$W = \\{B_1, B_2, B_4, B_5\\}$。\n3.  **步骤 3**：提取 $B_1$ ($p=1$)。$C_{\\mathrm{RPO}}=3$。$O_1 = I_2 \\cup I_3 = \\emptyset \\cup \\{b\\} = \\{b\\}$。$I_1' = \\{b\\}$。$I_1$ 改变。无前驱。$W = \\{B_2, B_4, B_5\\}$。\n4.  **步骤 4**：提取 $B_2$ ($p=3$)。$C_{\\mathrm{RPO}}=4$。$O_2 = I_4 = \\emptyset$。$I_2' = \\{a\\}$。$I_2$ 改变。添加前驱 $\\{B_1, B_4\\}$。$B_4$ 在 $W$ 中。添加 $B_1$。$W = \\{B_1, B_4, B_5\\}$。\n5.  **步骤 5**：提取 $B_1$ ($p=1$)。$C_{\\mathrm{RPO}}=5$。$O_1 = I_2 \\cup I_3 = \\{a\\} \\cup \\{b\\} = \\{a, b\\}$。$I_1' = \\{b\\}$。$I_1$ 未改变。$W = \\{B_4, B_5\\}$。\n6.  **步骤 6**：提取 $B_4$ ($p=4$)。$C_{\\mathrm{RPO}}=6$。$O_4 = I_2 \\cup I_5 = \\{a\\} \\cup \\emptyset = \\{a\\}$。$I_4' = \\{b\\}$。$I_4$ 改变。添加前驱 $\\{B_2, B_3\\}$。$W = \\{B_2, B_3, B_5\\}$。\n7.  **步骤 7**：提取 $B_3$ ($p=2$)。$C_{\\mathrm{RPO}}=7$。$O_3 = I_4 = \\{b\\}$。$I_3' = \\{b\\}$。$I_3$ 未改变。$W = \\{B_2, B_5\\}$。\n8.  **步骤 8**：提取 $B_2$ ($p=3$)。$C_{\\mathrm{RPO}}=8$。$O_2 = I_4 = \\{b\\}$。$I_2' = \\{a\\}$。$I_2$ 未改变。$W = \\{B_5\\}$。\n9.  **步骤 9**：提取 $B_5$ ($p=5$)。$C_{\\mathrm{RPO}}=9$。$O_5 = \\emptyset$。$I_5' = \\emptyset$。$I_5$ 未改变。$W = \\emptyset$。\n\n工作列表为空。算法终止。总处理步骤数为 $C_{\\mathrm{RPO}} = 9$。\n\n#### 最终计算\n\n两种策略的步骤数分别为 $C_{\\mathrm{FIFO}} = 8$ 和 $C_{\\mathrm{RPO}} = 9$。问题要求计算 $C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}}$ 的值。\n$$C_{\\mathrm{RPO}} - C_{\\mathrm{FIFO}} = 9 - 8 = 1$$\n经验结果证实了定性预测，即RPO策略对于此后向分析问题效率较低。", "answer": "$$\\boxed{1}$$", "id": "3642671"}, {"introduction": "这个练习将探讨与“可能”分析相对的“必须”分析。通过分析一个带有短路求值逻辑的布尔表达式，你将学习如何确定哪些子表达式在不同的控制流路径上是*保证*被求值的。这清晰地揭示了“必须”分析的核心原则，以及如何运用交集（intersection）作为其汇合运算符。[@problem_id:3642706]", "problem": "考虑程序中的以下基本块，并假设一个标准的控制流图 (CFG)，其中该块有两条分别标记为“true”和“false”的出边，通向其后继节点。该语言对逻辑与和逻辑或都采用短路语义。\n\n该块计算条件\n$\\big( (x \\neq 0) \\,\\wedge\\, ((y/x) > 1) \\big) \\,\\vee\\, \\big( (z - y) < 3 \\big)$\n，如果条件为真，则分支到“true”后继节点，否则分支到“false”后继节点。此块内没有赋值操作；所有变量 $x$、$y$ 和 $z$ 在进入该块前均已定义。\n\n将数据流域定义为此条件中语法上出现的算术子表达式集合：\n$\\mathcal{E} = \\{\\, y/x,\\; z - y \\,\\}$.\n我们研究对此块出边的一个前向 must 分析，该分析会为每条出边 $e$ 计算集合 $GEN^{\\rightarrow}(e)$，此集合包含 $\\mathcal{E}$ 中那些在每条到达边 $e$ 的块内求值路径（由短路语义引起）上都保证被求值的表达式。该块内没有重定义，所以没有需要“杀死”的项；因此，对于每条出边 $e$，$KILL^{\\rightarrow}(e) = \\varnothing$。该分析的前向 must 性质要求，对于每条边 $e$，一个表达式属于 $GEN^{\\rightarrow}(e)$ 的充分必要条件是，它在所有终止于 $e$ 的块内求值路径上都被求值。\n\n请仅使用短路求值和前向 must 属性的基本定义，确定以下量的值：\n$N \\;=\\; \\big|\\, GEN^{\\rightarrow}(\\text{true edge}) \\,\\big| \\;-\\; \\big|\\, GEN^{\\rightarrow}(\\text{false edge}) \\,\\big|$.\n请以单个整数形式给出答案。无需四舍五入。", "solution": "该问题要求对一个具有短路求值语义的布尔表达式进行“必须求值”（must-evaluated）分析。我们需要确定在哪些路径上特定的子表达式被保证求值，然后计算“true”分支和“false”分支上必须求值的表达式集合大小之差。\n\n让我们将总条件表示为 $C \\equiv C_1 \\vee C_2$，其中 $C_1 \\equiv (x \\neq 0) \\wedge ((y/x) > 1)$ 且 $C_2 \\equiv (z - y)  3$。\n我们关注的子表达式集是 $\\mathcal{E} = \\{ y/x, z-y \\}$。\n\n根据短路求值规则：\n- $A \\wedge B$：仅当 $A$ 为真时才对 $B$ 求值。\n- $A \\vee B$：仅当 $A$ 为假时才对 $B$ 求值。\n\n**分析通往“true”边的路径**\n当 $C$ 为真时，程序走“true”边。这发生在以下情况：\n1.  **路径 T1**: $C_1$ 为真。\n    - 这要求 $(x \\neq 0)$ 为真，并且 $((y/x) > 1)$ 也为真。为了检查后者，必须计算 $y/x$。\n    - 由于 $C_1$ 为真，$\\vee$ 运算短路，不会对 $C_2$ 求值。\n    - 在此路径上求值的 $\\mathcal{E}$ 中表达式：$\\{y/x\\}$。\n2.  **路径 T2**: $C_1$ 为假且 $C_2$ 为真。\n    - $C_1$ 为假有两种可能：\n        - **路径 T2a**: $(x \\neq 0)$ 为假。$\\wedge$ 运算短路，不计算 $y/x$。然后对 $C_2$ 求值并发现其为真。为了检查 $C_2$，必须计算 $z-y$。\n        - 在此路径上求值的 $\\mathcal{E}$ 中表达式：$\\{z-y\\}$。\n        - **路径 T2b**: $(x \\neq 0)$ 为真，但 $((y/x) > 1)$ 为假。为了检查这一点，必须计算 $y/x$。然后对 $C_2$ 求值并发现其为真，这又需要计算 $z-y$。\n        - 在此路径上求值的 $\\mathcal{E}$ 中表达式：$\\{y/x, z-y\\}$。\n\n$GEN^{\\rightarrow}(\\text{true edge})$ 是所有通往“true”边的路径上所求值表达式集合的交集。\n$$GEN^{\\rightarrow}(\\text{true edge}) = \\{y/x\\} \\cap \\{z-y\\} \\cap \\{y/x, z-y\\} = \\varnothing$$\n因此, $|\\,GEN^{\\rightarrow}(\\text{true edge})\\,| = 0$。\n\n**分析通往“false”边的路径**\n当 $C$ 为假时，程序走“false”边。这要求 $C_1$ 和 $C_2$ 都为假。\n因为 $C_1$ 必须为假，$\\vee$ 运算不会短路，所以 $C_2$ 总是会被求值。这意味着在任何通往“false”边的路径上，$z-y$ 都必须被计算。\n1.  **路径 F1**: $C_1$ 为假因为 $(x \\neq 0)$ 为假。\n    - $\\wedge$ 运算短路，不计算 $y/x$。\n    - 然后对 $C_2$ 求值，发现其为假。这需要计算 $z-y$。\n    - 在此路径上求值的 $\\mathcal{E}$ 中表达式：$\\{z-y\\}$。\n2.  **路径 F2**: $C_1$ 为假因为 $(x \\neq 0)$ 为真但 $((y/x) > 1)$ 为假。\n    - 为了检查 $((y/x) > 1)$，必须计算 $y/x$。\n    - 然后对 $C_2$ 求值，发现其为假。这需要计算 $z-y$。\n    - 在此路径上求值的 $\\mathcal{E}$ 中表达式：$\\{y/x, z-y\\}$。\n\n$GEN^{\\rightarrow}(\\text{false edge})$ 是所有通往“false”边的路径上所求值表达式集合的交集。\n$$GEN^{\\rightarrow}(\\text{false edge}) = \\{z-y\\} \\cap \\{y/x, z-y\\} = \\{z-y\\}$$\n因此, $|\\,GEN^{\\rightarrow}(\\text{false edge})\\,| = 1$。\n\n**最终计算**\n我们被要求计算 $N = |\\,GEN^{\\rightarrow}(\\text{true edge})\\,| - |\\,GEN^{\\rightarrow}(\\text{false edge})\\,|$。\n$$N = 0 - 1 = -1$$", "answer": "$$\n\\boxed{-1}\n$$", "id": "3642706"}]}