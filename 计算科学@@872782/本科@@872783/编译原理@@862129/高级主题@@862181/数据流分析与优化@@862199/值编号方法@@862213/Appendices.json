{"hands_on_practices": [{"introduction": "第一个练习直击值编号的核心。我们将看到编译器如何识别出表面上不同的代码片段，如 `$7+5$`、`$12$` 和 `$3 \\times 4$`，实际上具有相同的值。这个练习通过常量折叠（一种编译器在编译时计算常量表达式的基础优化）来阐释*等价类*的概念。[@problem_id:3681968]", "problem": "在线性代码的局部值编号中，编译器根据选定的等价关系将表达式划分为多个等价类，并为等价的表达式分配相同的值编号。考虑一个按顺序执行以下三个赋值语句的基本块：$x := 7 + 5$， $y := 12$，$z := 3 \\times 4$。假设该值编号算法在整数算术上运行，并使用以下基本原则和规则：\n\n- 基本语义：整数在 $+$、$-$、$\\times$ 和精确 $\\div$ 运算下的算术遵循标准的结合律和交换律公理（针对 $+$ 和 $\\times$），并且 $\\times$ 对 $+$ 满足分配律。整数上的常量表达式通过常量折叠被求值为单个整数常量。\n- 等价定义：如果两个表达式在此基本块上下文的所有执行中都求值为同一个整数，则它们是等价的。特别地，同一整数常量的所有出现都是等价的；任何通过常量折叠得到该整数的表达式也与之等价。\n- 规范化：每个整数常量 $k$ 都有一个唯一的规范代表；所有与 $k$ 等价的表达式都映射到同一个代表。\n- 值编号协议：从上到下扫描语句，当首次遇到一个规范代表时，为其分配未使用的最小正整数作为其值编号；任何后续与现有代表等价的表达式都将重用其值编号。\n\n从一个空的值表开始，将这些规则应用于这三个语句。处理完所有三个语句后，出现的不同值编号的总数是多少？请以单个整数形式提供您的答案。无需四舍五入。", "solution": "问题陈述已根据所需标准进行解析和验证。\n\n**第一步：提取已知条件**\n- **代码：** 一个包含三个顺序赋值语句的基本块：\n    1. `$x := 7 + 5$`\n    2. `$y := 12$`\n    3. `$z := 3 \\times 4$`\n- **算法：** 局部值编号。\n- **初始状态：** 值表为空。\n- **规则：**\n    1.  **语义：** 标准整数算术与常量折叠。像 `$a+b$` 或 `$c \\times d$` 这样的表达式（其中 `$a, b, c, d$` 是整数常量）被求值为单个整数常量。\n    2.  **等价性：** 如果两个表达式在基本块内求值为相同的整数值，则它们是等价的。\n    3.  **规范化：** 每个整数常量作为其等价类的唯一规范代表。\n    4.  **编号协议：** 语句按顺序处理。当首次看到一个规范代表时，会为其分配未使用的最小正整数作为其值编号。后续其规范代表已在表中的表达式将重用现有的值编号。\n\n**第二步：使用提取的已知条件进行验证**\n该问题具有科学依据，定义明确且客观。它描述了编译器理论中的一个标准算法（局部值编号），具有清晰、明确的规则集和明确定义的初始状态。语言正式而精确。问题是自包含且一致的。未发现任何缺陷。\n\n**结论：** 问题有效。\n\n**第三步：求解推导**\n我们将根据指定的规则模拟值编号过程，跟踪值表的状态，该表将规范代表（整数常量）映射到其分配的值编号。我们还将跟踪已使用的值编号集合。\n\n- **初始状态：**\n  - 值表：`{}` (空)\n  - 不同值编号的集合：`\\emptyset`\n  -下一个可用的值编号：`$1$`\n\n- **处理语句1：`$x := 7 + 5$`**\n  1.  右侧 (RHS) 是表达式 `$7 + 5$`。\n  2.  根据常量折叠规则，此表达式被求值。结果是整数常量 `$12$`。\n  3.  因此，表达式 `$7 + 5$` 的规范代表是 `$12$`。\n  4.  我们检查规范代表 `$12$` 是否存在于值表中。它不存在，因为表是空的。\n  5.  由于这是首次遇到规范代表 `$12$`，我们为其分配下一个可用的值编号，即 `$1$`。\n  6.  值表更新为：`ValueTable[12] = 1`。\n  7.  变量 `$x$` 与值编号 `$1$` 相关联。\n  - **语句1之后的状态：**\n    - 值表：`{12 \\to 1}`\n    - 不同值编号的集合：`\\{1\\}`\n    - 下一个可用的值编号：`$2$`\n\n- **处理语句2：`$y := 12$`**\n  1.  RHS 是表达式 `$12$`。\n  2.  这个表达式已经是一个整数常量，所以它的规范代表是 `$12$`。\n  3.  我们检查规范代表 `$12$` 是否存在于值表中。它存在；`ValueTable[12]` 是 `$1$`。\n  4.  根据协议，我们重用现有的值编号。表达式 `$12$` 的值编号是 `$1$`。\n  5.  没有分配新的值编号。\n  6.  变量 `$y$` 与值编号 `$1$` 相关联。\n  - **语句2之后的状态：**\n    - 值表：`{12 \\to 1}`\n    - 不同值编号的集合：`\\{1\\}`\n    - 下一个可用的值编号：`$2$`\n\n- **处理语句3：`$z := 3 \\times 4$`**\n  1.  RHS 是表达式 `$3 \\times 4$`。\n  2.  应用常量折叠，此表达式求值为整数常量 `$12$`。\n  3.  因此，表达式 `$3 \\times 4$` 的规范代表是 `$12$`。\n  4.  我们检查规范代表 `$12$` 是否存在于值表中。它存在；`ValueTable[12]` 是 `$1$`。\n  5.  我们重用现有的值编号。表达式 `$3 \\times 4$` 的值编号是 `$1$`。\n  6.  没有分配新的值编号。\n  7.  变量 `$z$` 与值编号 `$1$` 相关联。\n  - **语句3之后的状态：**\n    - 值表：`{12 \\to 1}`\n    - 不同值编号的集合：`\\{1\\}`\n    - 下一个可用的值编号：`$2$`\n\n**结论：**\n处理完所有三个语句后，我们建立了一个等价类，由规范整数 `$12$` 代表。这个类被分配了值编号 `$1$`。表达式 `$7 + 5$`、`$12$` 和 `$3 \\times 4$` 都是等价的。在整个过程中分配的所有不同值编号的集合是 `\\{1\\}`。不同值编号的总数是该集合的基数，即 `$1$`。", "answer": "$$\\boxed{1}$$", "id": "3681968"}, {"introduction": "在掌握了单个代码块内的局部分析之后，我们现在将范围扩大。本练习将处理一个更真实的场景，其中涉及控制流——即分支和合并。你将探索全局值编号 (Global Value Numbering, GVN) 如何与静态单赋值 (Static Single Assignment, SSA) 形式以及 `phi` 函数协同工作，以跨越不同的执行路径跟踪并证明值的等价性。[@problem_id:3681958]", "problem": "考虑以下以控制流图（CFG；Control Flow Graph）表示的程序片段，该图具有菱形结构和汇合点，并采用静态单赋值形式（SSA；Static Single Assignment form）书写。程序从块 $B_0$ 开始，然后分支到块 $B_1$ 和 $B_2$，最后在块 $B_3$ 处汇合。变量 $a$ 和 $b$ 是输入，在分支前没有被重新定义。这些块是：\n\n- $B_0$: $a := \\text{input}()$; $b := \\text{input}()$; if $\\text{cond}$ then goto $B_1$ else goto $B_2$.\n- $B_1$: $p := a$; $q := b$; $x := p + q$; goto $B_3$.\n- $B_2$: $r := a$; $s := b$; $y := r + s$; goto $B_3$.\n- $B_3$: $t := \\phi(x, y)$; \\text{return } $t$.\n\n假设一个全局值编号（GVN；Global Value Numbering）算法满足以下条件：\n- 为每个值定义（包括拷贝）关联一个值编号。\n- 拷贝操作 $u := v$ 会使得 $u$ 获得与 $v$ 相同的值编号。\n- 为二元操作 $op(u_1, u_2)$ 所赋的值编号仅由操作符 $op$ 以及 $u_1$ 和 $u_2$ 的值编号决定。\n- 对于一个 $\\phi$ 函数，如果其所有输入操作数具有相同的值编号，则该 $\\phi$ 函数的结果也获得该相同的值编号。\n\n其意图是为这样一种情况建模：相同的表达式出现在不同的路径上，但仅在经过不同的替换之后才出现，具体来说，一条路径上有 $x := (p + q)$，另一条路径上有 $y := (r + s)$，并且由于之前的拷贝操作，有 $p = r$ 和 $q = s$。\n\n以下哪个陈述最好地描述了 GVN 在 $B_3$ 中推断出什么以及原因为何？\n\nA. $B_1$ 和 $B_2$ 内的局部值编号足以证明 $x$ 和 $y$ 在汇合点是等价的，因此全局算法是不必要的。\n\nB. 因为拷贝操作使得 $p$ 和 $r$ 共享一个值编号，$q$ 和 $s$ 共享一个值编号，所以 GVN 会为 $x$ 和 $y$ 分配相同的值编号；因此在 $B_3$ 中，$t := \\phi(x, y)$ 也会获得该相同的值编号。\n\nC. 如果不利用 $+$ 的交换律，GVN 无法证明 $x$ 和 $y$ 是等价的，所以它们会得到不同的值编号，并且 $t$ 在 $B_3$ 中得到一个新的值编号。\n\nD. 汇合点的 $\\phi$ 函数必须总是引入一个与其操作数不同的新值编号，即使其操作数共享一个值编号，因为合并本质上是非等式的。", "solution": "用户提供了一个关于对一个以静态单赋值（SSA）形式表示的程序进行全局值编号（GVN）的问题陈述。任务是验证该问题，并且如果问题有效，则推导出关于指定 GVN 算法行为的正确结论。\n\n### 步骤 1：提取已知条件\n\n- **控制流图（CFG）**：一个菱形结构，包含一个起始块 `$B_0$`，两个到块 `$B_1$` 和 `$B_2$` 的条件分支，以及一个汇合块 `$B_3$`。\n- **SSA 形式的程序**：\n    - **块 `$B_0$**：`$a := \\text{input}()$; $b := \\text{input}()$; if $\\text{cond}$ then goto $B_1$ else goto $B_2$`。\n    - **块 `$B_1$**：`$p := a$; $q := b$; $x := p + q$; goto $B_3$`。\n    - **块 `$B_2$**：`$r := a$; $s := b$; $y := r + s$; goto $B_3$`。\n    - **块 `$B_3$**：`$t := \\phi(x, y)$; \\text{return } $t$`。\n- **输入变量**：`$a$` 和 `$b$` 是输入，在分支前没有被重新定义。\n- **GVN 算法规则**：\n    1.  为每个值定义关联一个值编号。\n    2.  拷贝操作 `$u := v$` 会使得 $u$ 获得与 `$v$` 相同的值编号。\n    3.  二元操作 `$op(u_1, u_2)$` 所赋的值编号仅由 `$op$` 以及 `$u_1$` 和 `$u_2$` 的值编号决定。\n    4.  对于一个 `$\\phi$` 函数，如果其所有输入操作数具有相同的值编号，则该 `$\\phi$` 函数的结果也获得该相同的值编号。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n问题陈述清晰、自洽地描述了一个程序片段和一种特定变体的全局值编号算法。\n- **科学上成立**：控制流图、静态单赋值形式、`$\\phi$`-函数和全局值编号等概念是编译器设计和优化理论中基础且成熟的原则。该设置是用于说明这些概念的标准教科书示例。\n- **良构的**：这是一个良构问题。程序结构被明确定义，支配算法行为的规则也已列出。这些规则足以确定性地追踪值编号在程序中的分配过程。通过应用这些规则可以得出一个唯一的结论。\n- **客观的**：该问题以计算机科学中常见的精确、客观和技术性语言陈述。它没有歧义、主观性和观点。\n- **结论**：该问题没有违反任何无效标准。这是一个来自编译器原理领域的有效、良构的问题。\n\n### 步骤 3：判定与行动\n问题是**有效的**。现在将通过应用给定的 GVN 规则到该程序片段来推导解决方案。\n\n### 解决方案推导\n\n令 `$VN(v)$` 表示分配给变量 `$v$` 的值编号。我们将沿着控制流图追踪值编号的分配过程。\n\n1.  **块 `$B_0$`**：\n    - 变量 `$a$` 和 `$b$` 从外部输入初始化。由于它们代表可能不同的值，因此被赋予不同的值编号。\n    - 设 `$VN(a) = 1$`。\n    - 设 `$VN(b) = 2$`。\n    - 这些值编号是“全局的”，对所有被其支配的块（`$B_1$`、`$B_2$` 和 `$B_3$`）都可用。\n\n2.  **经过块 `$B_1$` 的路径**：\n    - `$p := a$`: 这是一个拷贝操作。根据 GVN 规则 2，`$p$` 获得与 `$a$` 相同的值编号。因此，`$VN(p) = VN(a) = 1$`。\n    - `$q := b$`: 这也是一个拷贝操作。根据 GVN 规则 2，`$q$` 获得与 `$b$` 相同的值编号。因此，`$VN(q) = VN(b) = 2$`。\n    - `$x := p + q$`: 这是一个二元操作。根据 GVN 规则 3，`$x$` 的值编号由操作符 (`$+$`) 及其操作数 (`$p$` 和 `$q$`) 的值编号决定。该值编号代表抽象值 `value(1) + value(2)`。\n    - 我们将此复合值编号表示为 `$VN(x) = f(+, VN(p), VN(q)) = f(+, 1, 2)$`。我们可以为此分配一个新的整数，比如 `$VN(x) = 3$`。\n\n3.  **经过块 `$B_2$` 的路径**：\n    - `$r := a$`: 一个拷贝操作。使用 `$a$` 的全局已知值编号，`$VN(r) = VN(a) = 1$`。\n    - `$s := b$`: 一个拷贝操作。使用 `$b$` 的全局已知值编号，`$VN(s) = VN(b) = 2$`。\n    - `$y := r + s$`: 一个二元操作。`$y$` 的值编号由操作符 (`$+$`) 以及 `$r$` 和 `$s$` 的值编号决定。\n    - `$VN(y) = f(+, VN(r), VN(s)) = f(+, 1, 2)$`。\n    - GVN 算法会识别出这是与 `$x$` 的表达式相同的操作符和操作数值编号的组合。因此，`$y$` 被赋予与 `$x$` 相同的值编号。\n    - `$VN(y) = VN(x) = 3$`。\n\n4.  **在块 `$B_3$` 处汇合**：\n    - `$t := \\phi(x, y)$`: 这个 `$\\phi$`-函数合并了来自路径 `$B_1$` 的 `$x$` 的值和来自路径 `$B_2$` 的 `$y$` 的值。\n    - 我们已经确定 `$VN(x) = 3$` 且 `$VN(y) = 3$`。\n    - 现在我们应用 GVN 规则 4：“对于一个 `$\\phi$` 函数，如果其所有输入操作数具有相同的值编号，则该 `$\\phi$` 函数的结果也获得该相同的值编号。”\n    - 由于 `$\\phi$`-函数的两个操作数 `$x$` 和 `$y$` 具有相同的值编号 (`$3$`)，`$\\phi$`-函数的结果（赋给 `$t$`）也获得此值编号。\n    - 因此，`$VN(t) = 3$`。\n\n分析表明，GVN 成功地证明了表达式 `$p+q$` 和 `$r+s$` 在不同控制流路径上的等价性，并且这种等价性通过汇合点的 `$\\phi$`-函数得以传播。\n\n### 逐项分析选项\n\n**A. $B_1$ 和 $B_2$ 内的局部值编号足以证明 $x$ 和 $y$ 在汇合点是等价的，因此全局算法是不必要的。**\n- **分析**：局部值编号（Local Value Numbering）仅限于单个基本块。对 `$B_1$` 进行一次 LVN 遍（pass）将根据 `$a$` 和 `$b$` 的局部拷贝确定 `$x$` 的值。对 `$B_2$` 进行另一次独立的 LVN 遍将根据其局部拷贝确定 `$y$` 的值。然而，LVN 无法在 `$B_1$` 中的变量和 `$B_2$` 中的变量之间建立关系。要证明 `$VN(x) = VN(y)$`，算法必须知道 `$VN(p) = VN(r)$` 和 `$VN(q) = VN(s)`，这需要关于 `$a$` 和 `$b$` 的信息跨块传播。这正是*全局*算法的功能。\n- **判定**：不正确。\n\n**B. 因为拷贝操作使得 $p$ 和 $r$ 共享一个值编号，$q$ 和 $s$ 共享一个值编号，所以 GVN 会为 $x$ 和 $y$ 分配相同的值编号；因此在 $B_3$ 中，$t := \\phi(x, y)$ 也会获得该相同的值编号。**\n- **分析**：这个陈述准确地总结了推导过程。`$p$` 和 `$r$`（都是 `$a$` 的拷贝）的等价性以及 `$q$` 和 `$s$`（都是 `$b$` 的拷贝）的等价性是关键。这导致 `$x$` 和 `$y$` 都是将相同的操作 (`$+$`) 应用于具有相同值编号的操作数上，从而得出 `$VN(x) = VN(y)$`。该陈述通过应用为 `$\\phi$`-函数明确说明的规则（GVN 规则 4）得出了正确的结论，即当 `$\\phi$`-函数的所有操作数都等价时，其结果 `$t$` 获得与操作数相同的值编号。\n- **判定**：正确。\n\n**C. 如果不利用 $+$ 的交换律，GVN 无法证明 $x$ 和 $y$ 是等价的，所以它们会得到不同的值编号，并且 $t$ 在 $B_3$ 中得到一个新的值编号。**\n- **分析**：如推导所示，`$x$` 和 `$y$` 的表达式分别是 `$p+q$` 和 `$r+s$`。在解析了拷贝之后，就值编号而言，两个表达式都等价于 `$a+b$`。GVN 算法从值编号的有序对 `$(VN(p), VN(q))$` 计算 `$VN(x)`，并从 `$(VN(r), VN(s))$` 计算 `$VN(y)`。由于 `$VN(p) = VN(r)$` 和 `$VN(q) = VN(s)$`，操作数值编号的有序对是相同的。不需要交换律。举例来说，如果 `$B_2$` 中的表达式是 `$y := s + r$`，那么交换律就是必需的，因为这需要算法知道 `$f(+, v_1, v_2) = f(+, v_2, v_1)$`。但这里不是这种情况。\n- **判定**：不正确。\n\n**D. 汇合点的 $\\phi$ 函数必须总是引入一个与其操作数不同的新值编号，即使其操作数共享一个值编号，因为合并本质上是非等式的。**\n- **分析**：该陈述对 `$\\phi$`-函数做出了一个一般性断言，而这与问题陈述中提供的规则直接矛盾。GVN 规则 4 明确定义了此场景下的行为：“如果其所有输入操作数具有相同的值编号，则该 `$\\phi$` 函数的结果也获得该相同的值编号。” 我们必须遵循给定的规则。尽管可能存在不同的 GVN 实现，但此处指定的实现是在此条件下通过 `$\\phi$`-节点传播值编号的。\n- **判定**：不正确。", "answer": "$$\\boxed{B}$$", "id": "3681958"}, {"introduction": "一项技术的强大之处不仅在于其能力，也在于其局限性。这最后一个练习旨在探索值编号的一个关键边界条件：`volatile` 内存访问。本练习将挑战你对程序正确性和*可观察行为*的思考，阐明为何优化器绝不能将两次看似相同的对同一地址的 `volatile` 读取视为等价。[@problem_id:3682025]", "problem": "编译器执行全局值编号（Global Value Numbering, GVN），其核心结构是一个同余映射（congruence map），该映射将作用于操作数的操作符与一个规范值编号（canonical value number）关联起来。其正确性的基础是可观察等价性（observational equivalence）的定义：当且仅当一个优化保留了程序的可观察行为（observable behavior）时，该优化才是可靠的（sound）。特别是，可能与输入/输出或外部状态交互的操作是可观察的，如果消除或合并这些操作可能改变观察结果，则绝不能进行消除或合并。此外，值编号依赖于这样一个原则：如果一个操作符是确定性的（deterministic）且无副作用（side-effect-free），那么将其应用于同一同余类（congruence class）中的操作数，会产生同一同余类的结果。\n\n考虑以下中间表示中的直线型代码（straight-line code），其中指针 $p$ 指向一个可能映射到设备寄存器的内存位置：\n\n$x = \\mathrm{volatile}(*p)$\n\n$y = \\mathrm{volatile}(*p)$\n\n$z = x + y$\n\n假设程序文本中恰好有 $2$ 次 volatile 加载，并且没有对 $*p$ 的显式写入，同时假设目标语言规定 $\\mathrm{volatile}$ 加载具有可观察行为，并且即使地址和程序可见的内存状态没有改变，连续读取也可能产生不同的值。GVN 实现使用一个同余映射，该映射由操作符签名（operator signature）及其操作数的值编号作为键。该映射既用于检测也用于创建等价类（equivalence classes）。\n\n哪种说法最能描述在值编号中对 $\\mathrm{volatile}$ 加载的可靠处理方法，以及应如何在同余映射中表示易变性（volatility）？\n\nA. 因为在 $x = \\mathrm{volatile}(*p)$ 和 $y = \\mathrm{volatile}(*p)$ 中操作符和操作数在文本上是相同的，所以 $x$ 和 $y$ 必须被置于同一个同余类中；编译器可以用 $x$ 替换 $y$。\n\nB. $\\mathrm{volatile}$ 加载必须被视为产生全新的、不可等价的值，即使操作数相同。在同余映射的操作符签名中扩展一个易变性标签，确保每次 $\\mathrm{volatile}$ 加载都产生一个不同的值编号，从而防止与同一地址上任何其他 $\\mathrm{volatile}$ 加载发生基于查找的等价。\n\nC. 只要程序文本中没有对 $*p$ 的中间写入操作，就可以将 $x$ 和 $y$ 等同起来，因为程序可见的内存状态没有改变。\n\nD. 如果别名分析（alias analysis）证明 $p$ 指向一个无别名区域，则 $x$ 和 $y$ 可以被等同起来；易变性仅在存在别名时才重要。\n\nE. 在值编号中将 $\\mathrm{volatile}$ 加载建模为 $p$ 的纯函数，但为它们在每个基本块中分配一个单一的唯一值编号，以限制优化范围。", "solution": "用户希望我分析一个关于编译器中全局值编号（GVN）及其与 `volatile` 内存访问交互的问题。\n\n### 问题验证\n\n**第一步：提取已知条件**\n- 当且仅当一个优化保留了程序的可观察行为时，该优化才是可靠的。\n- 与输入/输出或外部状态交互的操作是可观察的。\n- 一个确定性且无副作用的操作符，当应用于同一同余类中的操作数时，产生的结果也在同一同余类中。\n- 代码段是：\n  $x = \\mathrm{volatile}(*p)$\n  $y = \\mathrm{volatile}(*p)$\n  $z = x + y$\n- $p$ 是一个指向可能为设备寄存器的内存位置的指针。\n- 程序文本中恰好有 $2$ 次 `volatile` 加载，并且没有对 $*p$ 的显式写入。\n- `volatile` 加载具有可观察行为。\n- `volatile` 加载在连续读取时可能产生不同的值，即使地址和程序可见的内存状态未改变。\n- GVN 使用由操作符签名和其操作数值编号作为键的同余映射。\n\n**第二步：使用提取的已知条件进行验证**\n该问题陈述在编译器构造的原理上是科学严谨的，特别是涉及程序优化和中间表示。全局值编号、可观察等价性以及 `volatile` 关键字的语义等概念是计算机科学和系统编程（例如，在 C 和 C++ 等语言中）的标准主题。问题提得很明确，要求在一个标准优化框架（GVN）中对一个特定情况（`volatile` 加载）进行可靠的处理。语言客观而精确。前提条件是一致的，并提供了足够的信息来确定正确的方法。该问题没有违反任何无效标准。\n\n**第三步：结论与行动**\n该问题是**有效的**。我将继续进行解题推导和选项分析。\n\n### 解题推导\n\n任何编译器优化正确性的核心原则是保留程序的可观察行为。问题陈述明确定义了 `volatile` 加载具有可观察行为。它还指出，从同一地址 `*p` 进行两次连续的 `volatile` 加载可能会产生不同的值。\n\n我们来分析一下代码：\n$1. \\ x = \\mathrm{volatile}(*p)$\n$2. \\ y = \\mathrm{volatile}(*p)$\n$3. \\ z = x + y$\n\n`volatile` 访问的基本属性是它必须严格按照其在源代码中出现的方式执行。编译器被禁止相对于其他 `volatile` 访问重新排序 `volatile` 访问，也禁止将其优化掉。在这种情况下，程序语义要求在内存位置 `*p` 处发生两次不同的读取操作。第一次读取的结果存储在 $x$ 中，第二次读取的结果存储在 $y$ 中。\n\n全局值编号（GVN）是一种识别那些保证计算出相同值的表达式的优化。如果它找到两个这样的表达式，它可以用第一个结果的简单副本来替换第二个计算。例如，如果编译器确定 `a op b` 和 `c op d` 是等价的（即，`op` 相同，且 `a` 和 `c` 的值编号、`b` 和 `d` 的值编号分别相等），它将为这两个表达式的结果分配相同的值编号。\n\n让我们将此应用于给定的问题。这两个操作是 `volatile(*p)`。操作符是 `volatile load`，操作数是地址 `p`。对于这两个指令，`p` 的值编号是相同的。一个天真实现的 GVN 会为其同余映射使用一个像 `(VOLATILE_LOAD, value_number(p))` 这样的键。当遇到第一条指令 $x = \\mathrm{volatile}(*p)$ 时，它会为 $x$ 创建一个新的值编号，比如 $v_1$，并存储映射 `(VOLATILE_LOAD, value_number(p)) -> v_1`。当遇到第二条指令 $y = \\mathrm{volatile}(*p)$ 时，它会查找相同的键 `(VOLATILE_LOAD, value_number(p))`，找到已存在的值编号 $v_1$，并将其赋给 $y$。这将意味着 $x$ 和 $y$ 是等价的，从而允许编译器将代码转换为：\n\n$1. \\ x = \\mathrm{volatile}(*p)$\n$2. \\ y = x$\n$3. \\ z = x + y$\n\n这种转换用寄存器复制替换了第二次 `volatile` 加载，将对 `volatile` 位置 `*p` 的读取次数从两次减少到一次。然而，问题指出 `volatile` 加载是一种可观察行为，并且连续读取可能产生不同的值。假设第一次读取产生 $v_{read1}$，第二次读取产生 $v_{read2}$，其中 $v_{read1} \\neq v_{read2}$。原始程序将计算 $z = v_{read1} + v_{read2}$。优化后的程序将计算 $z = v_{read1} + v_{read1}$。这些结果是不同的，这意味着优化改变了程序的可观察行为。这是一个不可靠的转换。\n\n因此，一个可靠的 GVN 实现必须将每次 `volatile` 加载都视为产生一个全新的、唯一的值，该值不能与任何其他值等同，即使是由文本上相同的 `volatile` 加载产生的值也不行。为实现这一点，GVN 机制必须确保在同余映射中对 `volatile` 加载的查找永远不会基于先前的 `volatile` 加载而成功。这意味着每次 `volatile` 加载都必须为映射生成一个唯一的键，或者 `volatile` 加载必须完全绕过查找机制，总是生成一个全新的值编号。\n\n### 逐项分析\n\n**A. 因为在 $x = \\mathrm{volatile}(*p)$ 和 $y = \\mathrm{volatile}(*p)$ 中操作符和操作数在文本上是相同的，所以 $x$ 和 $y$ 必须被置于同一个同余类中；编译器可以用 $x$ 替换 $y$。**\n这个说法描述了一个不可靠的优化。如上所述，将 $x$ 和 $y$ 等同并消除第二次 `volatile` 加载违反了 `volatile` 的语义，并改变了程序的可观察行为。由于 `volatile` 限定符的存在，操作的文本相同性是无关紧要的。\n结论：**不正确**。\n\n**B. `volatile` 加载必须被视为产生全新的、不可等价的值，即使操作数相同。在同余映射的操作符签名中扩展一个易变性标签，确保每次 `volatile` 加载都产生一个不同的值编号，从而防止与同一地址上任何其他 `volatile` 加载发生基于查找的等价。**\n这个说法正确地指出了对 `volatile` 加载的必要处理方式。它们必须总是产生一个新的值编号。提议的实现策略——为每次 `volatile` 加载在操作符签名中扩展一个唯一的标签——是实现这一目标的可靠方法。例如，第一次加载的同余映射键可以是 `(LOAD, vn(p), id_1)`，第二次加载的键是 `(LOAD, vn(p), id_2)`，其中 `id_1 \\neq id_2`。这将防止第二次加载时在映射中“命中”，从而强制为 $y$ 创建一个新的、不同的值编号。这保留了两个独立的、可观察的加载操作。\n结论：**正确**。\n\n**C. 只要程序文本中没有对 $*p$ 的中间写入操作，就可以将 $x$ 和 $y$ 等同起来，因为程序可见的内存状态没有改变。**\n这个说法从根本上误解了 `volatile`。`volatile` 的目的是为了表明内存位置可能被当前程序线程控制和可见范围之外的方式改变（例如，硬件、中断服务例程、另一个线程）。程序代码中没有写入操作不足以保证该值是稳定的。因此，将 $x$ 和 $y$ 等同是不安全的。\n结论：**不正确**。\n\n**D. 如果别名分析（alias analysis）证明 $p$ 指向一个无别名区域，则 $x$ 和 $y$ 可以被等同起来；易变性仅在存在别名时才重要。**\n这个说法错误地将别名与易变性混为一谈。别名分析确定多个指针是否可以指向同一内存位置。易变性是关于一个内存位置的值是否会不可预测地改变。这是两个正交的概念。即使一个 `volatile` 内存位置没有别名，也必须小心处理，因为它的值仍然可以被外部代理修改。`p` 的无别名状态并不能使其消除 `volatile` 加载变得安全。\n结论：**不正确**。\n\n**E. 在值编号中将 `volatile` 加载建模为 $p$ 的纯函数，但为它们在每个基本块中分配一个单一的唯一值编号，以限制优化范围。**\n这个说法内部矛盾且不正确。将 `volatile` 加载建模为纯函数与其真实语义直接相反。纯函数是确定性且无副作用的，而 `volatile` 加载（从编译器的角度看）是非确定性的，并且具有可观察的副作用（读取本身）。此外，每个基本块分配一个单一的唯一值编号仍然会错误地将同一块内的两次 `volatile` 加载（如问题中的 `x` 和 `y`）等同起来，导致与选项 A 中描述的相同的不可靠优化。\n结论：**不正确**。", "answer": "$$\\boxed{B}$$", "id": "3682025"}]}