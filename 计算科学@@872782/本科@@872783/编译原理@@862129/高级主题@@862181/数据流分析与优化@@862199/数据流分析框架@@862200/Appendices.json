{"hands_on_practices": [{"introduction": "我们的第一个实践是经典的到达定值分析。通过手动计算 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集合，并逐步迭代直至达到不动点，你将牢固掌握前向“may”分析的完整机制。在这个过程中，请特别注意单个基本块内部的定值是如何相互作用的，这是正确应用“最后写入者获胜”原则的关键细节。[@problem_id:3665951]", "problem": "考虑以下针对三个变量 $x$、$y$ 和 $z$ 的直线代码段的控制流图（CFG）。每个赋值都是一个唯一性定义，标记为 $d_i$（其中 $i \\in \\{1,2,3,4,5,6,7\\}$），唯一不是定义的操作是条件分支。CFG 节点（基本块）及其内容如下：\n- 块 $B_1$：\n  - $d_1$: $x := 0$\n  - $d_2$: $y := 0$\n  - 无条件分支到 $B_2$。\n- 块 $B_2$：\n  - $d_3$: $x := 1$\n  - $d_4$: $y := 2$\n  - $d_5$: $x := 3$\n  - 基于 $c$ 的条件分支，如果为真则跳转到 $B_3$，如果为假则跳转到 $B_4$。\n- 块 $B_3$：\n  - $d_6$: $y := 4$\n  - 无条件分支到 $B_5$。\n- 块 $B_4$：\n  - $d_7$: $x := 5$\n  - 无条件分支到 $B_5$。\n- 块 $B_5$：\n  - 在计算 $z := x + y$ 中使用了 $x$ 和 $y$（此使用本身在进入 $B_5$ 之前不会引入新的到达定义）。\n\n你需要使用经典的数据流框架，根据以下规范执行一次标准的前向“可能”(may)到达定义（RD）分析：\n- 方向：前向。\n- 交汇运算符：集合并集。\n- 每个块 $B$ 的传递函数：基于块内的“最后写入者获胜”原则，通过 $\\mathrm{GEN}[B]$ 和 $\\mathrm{KILL}[B]$ 计算。\n- 定义的全集为 $D = \\{d_1,d_2,d_3,d_4,d_5,d_6,d_7\\}$。\n- 边界条件：$\\mathrm{IN}[B_1] = \\varnothing$。\n- 对于 $\\mathrm{KILL}$ 集，一个定义 $d \\in D$ 会被任何对同一变量的后续定义所“杀掉”（kill）；在一个块内，只有对给定变量的最后一次定义属于 $\\mathrm{GEN}$，而该块中对同一变量的更早的定义不属于 $\\mathrm{GEN}$，并被认为在该块内被“杀掉”。\n\n这个 CFG 是故意设计得既简约又足以推翻一种朴素的到达定义假设，即认为在条件分支之前的块内较早定义可能只到达其中一个后继节点：在一个基本块中，一个单独的 $\\mathrm{OUT}[B]$ 会流向所有后继节点，并且块内的重定义必须用“最后写入者获胜”原则来处理。\n\n设 $\\mathrm{IN}[B_5]$ 为在不动点处到达 $B_5$ 入口的 $D$ 中定义的集合。定义标量\n$$\nS \\;=\\; \\sum \\{\\, i \\mid d_i \\in \\mathrm{IN}[B_5] \\text{ and } d_i \\text{ is a definition of } x \\text{ or } y \\,\\}.\n$$\n计算 $S$。你的最终答案必须是一个实数值。无需四舍五入。", "solution": "该问题定义明确，且基于编译器理论的原理，特别是数据流分析。我们将通过应用标准的到达定义迭代算法来解决它。\n\n定义的全集是 $D = \\{d_1, d_2, d_3, d_4, d_5, d_6, d_7\\}$。\n这些定义涉及变量 $x$ 和 $y$。设 $D_x$ 是变量 $x$ 的定义集， $D_y$ 是变量 $y$ 的定义集。\n$D_x = \\{d_1, d_3, d_5, d_7\\}$\n$D_y = \\{d_2, d_4, d_6\\}$\n\n首先，我们计算每个基本块 $B$ 的 $\\mathrm{GEN}$ 和 $\\mathrm{KILL}$ 集。$\\mathrm{GEN}[B]$ 是在 $B$ 内部能够到达 $B$ 末尾的定义的集合。根据“最后写入者获胜”规则，这是 $B$ 中每个被赋值变量的最后定义的集合。$\\mathrm{KILL}[B]$ 是程序中被 $B$ 内的定义所“杀掉”的所有定义的集合。如果块 $B$ 包含对变量 $v$ 的定义，那么它会“杀掉”任何对 $v$ 的其他定义。\n\n块 $B_1$：包含 $d_1: x := 0$ 和 $d_2: y := 0$。\n$\\mathrm{GEN}[B_1] = \\{d_1, d_2\\}$。\n$B_1$ 定义了 $x$ 和 $y$。它会“杀掉”所有其他对 $x$ 和 $y$ 的定义。\n$\\mathrm{KILL}[B_1] = (D_x \\setminus \\{d_1\\}) \\cup (D_y \\setminus \\{d_2\\}) = \\{d_3, d_5, d_7\\} \\cup \\{d_4, d_6\\} = \\{d_3, d_4, d_5, d_6, d_7\\}$。\n\n块 $B_2$：包含 $d_3: x := 1$、$d_4: y := 2$ 和 $d_5: x := 3$。\n$x$ 的最后定义是 $d_5$。$y$ 的最后定义是 $d_4$。定义 $d_3$ 在块内被“杀掉”。\n$\\mathrm{GEN}[B_2] = \\{d_4, d_5\\}$。\n$B_2$ 定义了 $x$ 和 $y$。它会“杀掉”所有其他对 $x$ 和 $y$ 的定义。\n$\\mathrm{KILL}[B_2] = (D_x \\setminus \\{d_5\\}) \\cup (D_y \\setminus \\{d_4\\}) = \\{d_1, d_3, d_7\\} \\cup \\{d_2, d_6\\} = \\{d_1, d_2, d_3, d_6, d_7\\}$。\n\n块 $B_3$：包含 $d_6: y := 4$。\n$\\mathrm{GEN}[B_3] = \\{d_6\\}$。\n$B_3$ 定义了 $y$。它会“杀掉”所有其他对 $y$ 的定义。\n$\\mathrm{KILL}[B_3] = D_y \\setminus \\{d_6\\} = \\{d_2, d_4\\}$。\n\n块 $B_4$：包含 $d_7: x := 5$。\n$\\mathrm{GEN}[B_4] = \\{d_7\\}$。\n$B_4$ 定义了 $x$。它会“杀掉”所有其他对 $x$ 的定义。\n$\\mathrm{KILL}[B_4] = D_x \\setminus \\{d_7\\} = \\{d_1, d_3, d_5\\}$。\n\n块 $B_5$：包含一个使用，但没有定义。\n$\\mathrm{GEN}[B_5] = \\varnothing$。\n$\\mathrm{KILL}[B_5] = \\varnothing$。\n\n对于通过并集实现路径交汇的前向分析，其数据流方程为：\n$$\n\\mathrm{OUT}[B] = \\mathrm{GEN}[B] \\cup (\\mathrm{IN}[B] \\setminus \\mathrm{KILL}[B])\n$$\n$$\n\\mathrm{IN}[B] = \\bigcup_{P \\in \\mathrm{pred}(B)} \\mathrm{OUT}[P]\n$$\n给定 CFG 的具体方程是：\n$\\mathrm{IN}[B_1] = \\varnothing$ (边界条件)\n$\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1]$\n$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2]$\n$\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2]$\n$\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] \\cup \\mathrm{OUT}[B_4]$\n\n我们迭代求解这些方程，将所有的 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合初始化为 $\\varnothing$。\n\n迭代 0：所有集合均为空集 $\\varnothing$。\n\n迭代 1：\n$\\mathrm{IN}[B_1] = \\varnothing$\n$\\mathrm{OUT}[B_1] = \\mathrm{GEN}[B_1] \\cup (\\mathrm{IN}[B_1] \\setminus \\mathrm{KILL}[B_1]) = \\{d_1, d_2\\} \\cup (\\varnothing \\setminus \\dots) = \\{d_1, d_2\\}$\n$\\mathrm{IN}[B_2] = \\mathrm{OUT}[B_1] = \\{d_1, d_2\\}$\n$\\mathrm{OUT}[B_2] = \\mathrm{GEN}[B_2] \\cup (\\mathrm{IN}[B_2] \\setminus \\mathrm{KILL}[B_2]) = \\{d_4, d_5\\} \\cup (\\{d_1, d_2\\} \\setminus \\{d_1, d_2, d_3, d_6, d_7\\}) = \\{d_4, d_5\\} \\cup \\varnothing = \\{d_4, d_5\\}$\n$\\mathrm{IN}[B_3] = \\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$\n$\\mathrm{OUT}[B_3] = \\mathrm{GEN}[B_3] \\cup (\\mathrm{IN}[B_3] \\setminus \\mathrm{KILL}[B_3]) = \\{d_6\\} \\cup (\\{d_4, d_5\\} \\setminus \\{d_2, d_4\\}) = \\{d_6\\} \\cup \\{d_5\\} = \\{d_5, d_6\\}$\n$\\mathrm{IN}[B_4] = \\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$\n$\\mathrm{OUT}[B_4] = \\mathrm{GEN}[B_4] \\cup (\\mathrm{IN}[B_4] \\setminus \\mathrm{KILL}[B_4]) = \\{d_7\\} \\cup (\\{d_4, d_5\\} \\setminus \\{d_1, d_3, d_5\\}) = \\{d_7\\} \\cup \\{d_4\\} = \\{d_4, d_7\\}$\n$\\mathrm{IN}[B_5] = \\mathrm{OUT}[B_3] \\cup \\mathrm{OUT}[B_4] = \\{d_5, d_6\\} \\cup \\{d_4, d_7\\} = \\{d_4, d_5, d_6, d_7\\}$\n\n迭代 2：我们使用迭代 1 的值重新计算所有集合。\n$\\mathrm{IN}[B_1] = \\varnothing$ (无变化)\n$\\mathrm{OUT}[B_1] = \\{d_1, d_2\\}$ (无变化)\n$\\mathrm{IN}[B_2] = \\{d_1, d_2\\}$ (无变化)\n$\\mathrm{OUT}[B_2] = \\{d_4, d_5\\}$ (无变化)\n$\\mathrm{IN}[B_3] = \\{d_4, d_5\\}$ (无变化)\n$\\mathrm{OUT}[B_3] = \\{d_5, d_6\\}$ (无变化)\n$\\mathrm{IN}[B_4] = \\{d_4, d_5\\}$ (无变化)\n$\\mathrm{OUT}[B_4] = \\{d_4, d_7\\}$ (无变化)\n$\\mathrm{IN}[B_5] = \\{d_4, d_5, d_6, d_7\\}$ (无变化)\n\n由于在迭代 2 中没有集合的值发生变化，算法已经达到了一个不动点。到达块 $B_5$ 入口的定义集合是 $\\mathrm{IN}[B_5] = \\{d_4, d_5, d_6, d_7\\}$。\n\n问题要求计算满足 $d_i \\in \\mathrm{IN}[B_5]$ 且 $d_i$ 是 $x$ 或 $y$ 的定义的索引 $i$ 的和 $S$。我们检查 $\\mathrm{IN}[B_5]$ 的元素：\n- $d_4$: $y := 2$。这是 $y$ 的一个定义。其索引是 $4$。\n- $d_5$: $x := 3$。这是 $x$ 的一个定义。其索引是 $5$。\n- $d_6$: $y := 4$。这是 $y$ 的一个定义。其索引是 $6$。\n- $d_7$: $x := 5$。这是 $x$ 的一个定义。其索引是 $7$。\n\n$\\mathrm{IN}[B_5]$ 中的所有定义都是针对 $x$ 或 $y$ 的。需要求和的索引集合是 $\\{4,5,6,7\\}$。\n和 $S$ 计算如下：\n$$\nS = 4 + 5 + 6 + 7 = 22\n$$", "answer": "$$\n\\boxed{22}\n$$", "id": "3665951"}, {"introduction": "在掌握了前向分析之后，本练习将带你挑战活跃变量分析，这是一个典型的后向分析问题。其主要挑战不仅在于逆转信息流动的方向，还在于精确地为程序构建控制流模型。在应用数据流方程之前，你需要将 `break` 和 `continue` 等结构化控制流命令准确地转换为控制流图（CFG）。[@problem_id:3635622]", "problem": "给定一个结构化语言的单过程代码片段，其中包含标量整型变量 $a$、$b$、$c$ 和 $x$。该片段由一个循环构成，循环体中同时包含 $break$ 和 $continue$ 语句。该循环及其语句通过一系列带编号的程序点给出。每个语句标签 $P_i$ 标识了执行相应语句之前的程序点。控制流遵循 $while$、$if$、$break$ 和 $continue$ 的常规结构化语义。\n\n- $P_1$：循环头，条件为 $a  b$。\n- $P_2$：赋值语句 $x := a + c$。\n- $P_3$：条件语句 $if\\ (x > b)$ 则跳转至 $P_4$，否则跳转至 $P_5$。\n- $P_4$：赋值语句 $c := c + 1$，然后是条件语句 $if\\ (c > a)$ 则 $break$ 循环，否则顺序执行至 $P_5$。\n- $P_5$：条件语句 $if\\ (x  c)$ 则跳转至 $P_6$，否则跳转至 $P_7$。\n- $P_6$：赋值语句 $a := a + 1$，然后 $continue$ 循环（即跳转至位于 $P_1$ 的循环头）。\n- $P_7$：赋值语句 $b := b - x$，然后顺序执行至循环体末尾并跳转至位于 $P_1$ 的循环头。\n- $P_8$：循环结束后，是一个带有表达式 $a + c$ 的 $return$ 语句。\n\n基本和建模要求：\n- 使用活性变量的基本定义：如果从一个程序点存在一条路径，变量在该路径上被使用，且在此之前没有被重新定义，那么该变量在该程序点是活跃的。\n- 使用控制流图（Control Flow Graph, CFG）对程序进行建模。图中的节点是与上述程序点 $P_1$ 至 $P_8$ 对齐的基本块，边反映实际的控制转移，包括由 $break$ 和 $continue$ 引起的转移。\n- 将 $P_8$ 处的 $return$ 语句视为使用了其表达式中的变量。没有其他副作用或外部使用；没有函数调用。\n\n任务：\n1) 通过列出由结构化语义产生的每个 $P_i$ 的后继节点，构建最小的正确 CFG。特别注意 $P_4$ 处的 $break$ 和 $P_6$ 处的 $continue$。指出如果不为 $break$ 和 $continue$ 建模而天真地将代码线性化，会缺失哪些为保持正确性所必需的控制流边。\n2) 使用标准的活性变量反向数据流分析，根据每个 $P_i$ 处的语句计算块级别的 $USE$ 和 $DEF$ 集合，计算在正确 CFG 上所有 $i \\in \\{1,2,3,4,5,6,7,8\\}$ 的 live-in 和 live-out 集合 $IN[P_i]$ 和 $OUT[P_i]$，从出口 $P_8$ 之后没有活跃变量开始。\n3) 考虑一个忽略了 $break$ 和 $continue$ 的非局部控制转移的朴素线性化模型：在这个朴素模型中，控制流从 $P_4$ 处的 $break$ 顺序执行到 $P_5$，如同它是一个空操作；从 $P_6$ 处的 $continue$ 顺序执行到 $P_7$，如同它是一个空操作；所有其他控制转移保持与结构化代码中一致。在此朴素模型下，重新计算程序点 $P_6$（紧邻赋值语句 $a := a + 1$ 之前）的 $IN[P_6]$。\n4) 令 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$ 为朴素线性化模型与正确 CFG 在 $P_6$ 处的 live-in 集合大小之差，定义为 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。计算 $\\Delta$ 的精确值，结果为单个整数。无需四舍五入。将最终答案表示为一个纯数字，不带任何单位。", "solution": "首先对问题进行严格的验证过程。\n\n### 步骤 1：提取已知条件\n- **变量**：标量整数 $a$、$b$、$c$ 和 $x$。\n- **程序点和语义**：\n    - $P_1$：循环头，条件为 $a  b$。\n    - $P_2$：赋值语句 $x := a + c$。\n    - $P_3$：条件语句 `if (x > b)` 则跳转至 $P_4$，否则跳转至 $P_5$。\n    - $P_4$：赋值语句 $c := c + 1$，然后 `if (c > a)` 则 `break`，否则顺序执行至 $P_5$。\n    - $P_5$：条件语句 `if (x  c)` 则跳转至 $P_6$，否则跳转至 $P_7$。\n    - $P_6$：赋值语句 $a := a + 1$，然后 `continue`。\n    - $P_7$：赋值语句 $b := b - x$，然后循环回到 $P_1$。\n    - $P_8$：循环后 `return a + c`。\n- **活性定义**：如果从一个程序点存在一条路径，变量在该路径上被使用，且该使用不被该变量的重新定义所拦截，则该变量在此程序点是活跃的。\n- **建模**：一个控制流图 (CFG)，节点为 $P_1, \\dots, P_8$。$P_8$ 处的语句 `return a + c` 构成了对变量 $a$ 和 $c$ 的使用。\n- **朴素模型定义**：一个修改后的 CFG，其中 $P_4$ 处的 `break` 被视为顺序执行到 $P_5$，$P_6$ 处的 `continue` 被视为顺序执行到 $P_7$。\n- **目标**：计算 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。\n\n### 步骤 2：使用提取的已知条件进行验证\n- **科学基础**：该问题很好地基于编译器理论的原理，特别是静态程序分析和数据流分析。CFG、活性、`break` 和 `continue` 的概念在计算机科学中是标准的且有正式定义。\n- **适定性**：该问题是自洽的，并提供了构建 CFG 和执行分析所需的所有必要信息。任务是具体的，并导向一个唯一的数值结果。\n- **客观性**：语言精确且技术性强，没有主观性。\n\n### 步骤 3：结论与行动\n该问题被判定为**有效**。这是一个标准的、定义明确的程序分析问题。现在开始求解过程。\n\n### 任务 1：构建正确的控制流图 (CFG)\n\nCFG 是一个有向图 $G = (N, E)$，其中节点 $N = \\{P_1, P_2, \\dots, P_8\\}$ 是程序点（被视作基本块），边 $E$ 代表控制流。每个节点的后继节点由程序语义确定。\n\n- $P_1$ (`while (a  b)`)：如果条件为真，控制流传递到位于 $P_2$ 的循环体。如果为假，循环终止，控制流传递到循环后的语句 $P_8$。\n  - $Succ(P_1) = \\{P_2, P_8\\}$\n- $P_2$ (`x := a + c`)：无条件顺序执行到 $P_3$。\n  - $Succ(P_2) = \\{P_3\\}$\n- $P_3$ (`if (x > b)`)：条件分支到 $P_4$ 或 $P_5$。\n  - $Succ(P_3) = \\{P_4, P_5\\}$\n- $P_4$ (`c := c + 1; if (c > a) break;`)：如果条件 `c > a` 为真，`break` 语句将控制流转移到 $P_8$。否则，控制流顺序执行到 $P_5$。\n  - $Succ(P_4) = \\{P_5, P_8\\}$\n- $P_5$ (`if (x  c)`)：条件分支到 $P_6$ 或 $P_7$。\n  - $Succ(P_5) = \\{P_6, P_7\\}$\n- $P_6$ (`a := a + 1; continue;`)：`continue` 语句将控制流转移到位于 $P_1$ 的循环头。\n  - $Succ(P_6) = \\{P_1\\}$\n- $P_7$ (`b := b - x`)：控制流顺序执行至循环体末尾，这意味着隐式地将控制流转回位于 $P_1$ 的循环头。\n  - $Succ(P_7) = \\{P_1\\}$\n- $P_8$ (`return a + c`)：这是过程的出口块。它没有后继节点。\n  - $Succ(P_8) = \\emptyset$\n\n在朴素的线性化模型中会缺失的控制流边是那些非局部转移：\n1.  由 `break` 语句产生的边 $P_4 \\rightarrow P_8$。朴素模型会错误地假设从 $P_4$ 顺序执行到 $P_5$。\n2.  由 `continue` 语句产生的边 $P_6 \\rightarrow P_1$。朴素模型会错误地假设从 $P_6$ 顺序执行到 $P_7$。\n\n### 任务 2：在正确的 CFG 上进行活性变量分析\n\n活性分析是一个反向数据流分析问题。对于一个基本块 $B$，相关的方程是：\n$$OUT[B] = \\bigcup_{S \\in Succ(B)} IN[S]$$\n$$IN[B] = USE[B] \\cup (OUT[B] \\setminus DEF[B])$$\n\n首先，我们根据每个块 $P_i$ 中被读取和写入的变量来定义 $USE$ 和 $DEF$ 集合。\n- $USE[P_1] = \\{a, b\\}, DEF[P_1] = \\emptyset$\n- $USE[P_2] = \\{a, c\\}, DEF[P_2] = \\{x\\}$\n- $USE[P_3] = \\{x, b\\}, DEF[P_3] = \\emptyset$\n- $USE[P_4] = \\{a, c\\}, DEF[P_4] = \\{c\\}$ (在 $c+1$ 中对 $c$ 的读取发生在写入之前)\n- $USE[P_5] = \\{x, c\\}, DEF[P_5] = \\emptyset$\n- $USE[P_6] = \\{a\\}, DEF[P_6] = \\{a\\}$\n- $USE[P_7] = \\{b, x\\}, DEF[P_7] = \\{b\\}$\n- $USE[P_8] = \\{a, c\\}, DEF[P_8] = \\emptyset$\n\n我们初始化所有 $i \\in \\{1, \\dots, 8\\}$ 的 $IN[P_i] = \\emptyset$ 并迭代直到达到不动点。$OUT[P_8]$ 始终为 $\\emptyset$。\n\n**迭代 1：**\n- $IN[P_8] = USE[P_8] \\cup (OUT[P_8] \\setminus DEF[P_8]) = \\{a, c\\}$\n- $OUT[P_7] = IN[P_1] = \\emptyset$\n- $IN[P_7] = USE[P_7] \\cup (OUT[P_7] \\setminus DEF[P_7]) = \\{b, x\\} \\cup (\\emptyset \\setminus \\{b\\}) = \\{x\\}$\n- $OUT[P_6] = IN[P_1] = \\emptyset$\n- $IN[P_6] = USE[P_6] \\cup (OUT[P_6] \\setminus DEF[P_6]) = \\{a\\} \\cup (\\emptyset \\setminus \\{a\\}) = \\emptyset$\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\emptyset \\cup \\{x\\} = \\{x\\}$\n- $IN[P_5] = USE[P_5] \\cup (OUT[P_5] \\setminus DEF[P_5]) = \\{x, c\\} \\cup (\\{x\\} \\setminus \\emptyset) = \\{x, c\\}$\n- $OUT[P_4] = IN[P_5] \\cup IN[P_8] = \\{x, c\\} \\cup \\{a, c\\} = \\{a, c, x\\}$\n- $IN[P_4] = USE[P_4] \\cup (OUT[P_4] \\setminus DEF[P_4]) = \\{a, c\\} \\cup (\\{a, c, x\\} \\setminus \\{c\\}) = \\{a, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, c, x\\} \\cup \\{x, c\\} = \\{a, c, x\\}$\n- $IN[P_3] = USE[P_3] \\cup (OUT[P_3] \\setminus DEF[P_3]) = \\{x, b\\} \\cup (\\{a, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = USE[P_2] \\cup (OUT[P_2] \\setminus DEF[P_2]) = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $IN[P_1] = USE[P_1] \\cup (OUT[P_1] \\setminus DEF[P_1]) = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n\n**迭代 2：**\n- $IN[P_1]$ 从 $\\emptyset$ 变为 $\\{a, b, c\\}$。这将向后传播。\n- $OUT[P_7] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_7] = \\{b, x\\} \\cup (\\{a, b, c\\} \\setminus \\{b\\}) = \\{b, x\\} \\cup \\{a, c\\} = \\{a, b, c, x\\}$\n- $OUT[P_6] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_6] = \\{a\\} \\cup (\\{a, b, c\\} \\setminus \\{a\\}) = \\{a\\} \\cup \\{b, c\\} = \\{a, b, c\\}$\n- 剩下的集合也会更新，但我们已经找到了正确 CFG 所需的值。让我们验证收敛性。\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\{a, b, c\\} \\cup \\{a, b, c, x\\} = \\{a, b, c, x\\}$\n- $IN[P_5] = \\{x, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_4] = IN[P_5] \\cup IN[P_8] = \\{a, b, c, x\\} \\cup \\{a, c\\} = \\{a, b, c, x\\}$\n- $IN[P_4] = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{c\\}) = \\{a, b, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, b, c, x\\}$\n- $IN[P_3] = \\{x, b\\} \\cup (\\{a, b, c, x\\} \\setminus \\emptyset) = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = \\{a, c\\} \\cup (\\{a, b, c, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $IN[P_1] = \\{a, b\\} \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n\n第三次迭代显示没有变化。过程已经收敛。对于正确的 CFG，我们有：\n$$IN_{\\text{correct}}[P_6] = \\{a, b, c\\}$$\n$$|IN_{\\text{correct}}[P_6]| = 3$$\n\n### 任务 3：在朴素线性化模型上进行活性变量分析\n\n在朴素模型中，`break` 和 `continue` 被忽略，导致顺序执行的控制流。后继列表发生变化：\n- $Succ_{\\text{naive}}(P_4) = \\{P_5\\}$ (到 $P_8$ 的边被移除)\n- $Succ_{\\text{naive}}(P_6) = \\{P_7\\}$ (到 $P_1$ 的边被替换为到 $P_7$ 的边)\n所有其他后继列表保持不变。$USE$ 和 $DEF$ 集合不变。\n\n我们重新计算活性集合。我们关心的是 $IN_{\\text{naive}}[P_6]$。\n\n**迭代 1 (朴素模型)：**\n- $IN[P_8] = \\{a, c\\}$\n- $OUT[P_7] = IN[P_1] = \\emptyset$\n- $IN[P_7] = \\{x\\}$\n- $OUT[P_6] = IN[P_7] = \\{x\\}$ (后继是 $P_7$)\n- $IN[P_6] = \\{a\\} \\cup (\\{x\\} \\setminus \\{a\\}) = \\{a, x\\}$\n- $OUT[P_5] = IN[P_6] \\cup IN[P_7] = \\{a, x\\} \\cup \\{x\\} = \\{a, x\\}$\n- $IN[P_5] = \\{x, c\\} \\cup (\\{a, x\\} \\setminus \\emptyset) = \\{a, c, x\\}$\n- $OUT[P_4] = IN[P_5] = \\{a, c, x\\}$ (后继只有 $P_5$)\n- $IN[P_4] = \\{a, c\\} \\cup (\\{a, c, x\\} \\setminus \\{c\\}) = \\{a, c, x\\}$\n- $OUT[P_3] = IN[P_4] \\cup IN[P_5] = \\{a, c, x\\}$\n- $IN[P_3] = \\{a, b, c, x\\}$\n- $OUT[P_2] = IN[P_3] = \\{a, b, c, x\\}$\n- $IN[P_2] = \\{a, b, c\\}$\n- $OUT[P_1] = IN[P_2] \\cup IN[P_8] = \\{a, b, c\\}$\n- $IN[P_1] = \\{a, b, c\\}$\n\n**迭代 2 (朴素模型)：**\n- $IN[P_1]$ 发生了变化，所以我们传播新的信息。\n- $OUT[P_7] = IN[P_1] = \\{a, b, c\\}$\n- $IN[P_7] = \\{b, x\\} \\cup (\\{a, b, c\\} \\setminus \\{b\\}) = \\{a, b, c, x\\}$\n- $OUT[P_6] = IN[P_7] = \\{a, b, c, x\\}$ (这是与正确模型相比的关键变化)\n- $IN[P_6] = \\{a\\} \\cup (\\{a, b, c, x\\} \\setminus \\{a\\}) = \\{a\\} \\cup \\{b, c, x\\} = \\{a, b, c, x\\}$\n\n后续迭代显示收敛，因为其余集合已稳定。因此，对于朴素 CFG：\n$$IN_{\\text{naive}}[P_6] = \\{a, b, c, x\\}$$\n$$|IN_{\\text{naive}}[P_6]| = 4$$\n\n在 $IN_{\\text{naive}}[P_6]$ 中多出的活跃变量 $x$ 是因为分析错误地假设存在一条从 $P_6$到 $P_7$的路径，而 $x$ 在 $P_7$ 中被使用。这条路径在正确的 CFG 中不存在。\n\n### 任务 4：计算差值 $\\Delta$\n\n我们需要计算 $\\Delta = |IN_{\\text{naive}}[P_6]| - |IN_{\\text{correct}}[P_6]|$。\n使用前面任务的结果：\n$|IN_{\\text{naive}}[P_6]| = 4$\n$|IN_{\\text{correct}}[P_6]| = 3$\n\n因此，差值为：\n$$\\Delta = 4 - 3 = 1$$", "answer": "$$\\boxed{1}$$", "id": "3635622"}, {"introduction": "最后的这项实践将你的理解从手动计算提升到理论验证的层面。你将不再是解决单个数据流问题，而是设计一个测试工具，来通过实验验证单调框架的基本定理。这个练习连接了理论与实践的鸿沟，证明了单调性和与访问顺序无关性等性质不仅是抽象概念，更是确保数据流分析在真实编译器中可靠运行的坚实保障。[@problem_id:3635627]", "problem": "您的任务是构建一个自包含的测试工具，以经验性地验证一个作为单调框架实现的前向位向量数据流分析的属性。该工具必须生成小型随机控制流图（CFG），以经典的 $Gen/Kill$ 形式分配随机的数据流传递函数，然后在多种访问顺序下运行不动点计算，以检查两个属性：（i）迭代状态在集合包含关系下的单调性，以及（ii）最终不动点与访问顺序的无关性。\n\n您必须遵循的基本要素包括：\n\n- 一个定义在有限幂集格 $(\\mathcal{P}(U), \\subseteq)$ 上的数据流框架，其中 $U$ 是一个大小为 $m \\in \\mathbb{N}$ 的有限事实全域，由集合包含关系 $\\subseteq$ 排序，其底元素为 $\\emptyset$，顶元素为 $U$。\n- 一个具有前驱节点交会（meet over predecessors）的前向数据流分析。对于每个具有前驱节点集 $Pred(n)$ 的节点 $n$，数据流方程为：\n  - $IN_n$ 是前驱节点上的交会操作：$IN_n = \\bigcup_{p \\in Pred(n)} OUT_p$。\n  - 节点 $n$ 处的传递函数是一个应用于 $IN_n$ 的 $Gen/Kill$ 风格函数，由 $OUT_n = (IN_n \\setminus Kill_n) \\cup Gen_n$ 给出，其中 $Gen_n \\subseteq U$ 和 $Kill_n \\subseteq U$ 是节点局部子集。此函数在 $\\subseteq$ 关系下是单调的。\n- 所寻求的不动点是在有限格上这组单调方程的最小不动点，其存在性由 Knaster-Tarski 定理保证。\n\n您的程序必须：\n\n1. 将事实集合表示为长度为 $m$ 的位向量（当 $m \\leq 64$ 时，使用带适当掩码的 $64$ 位无符号整数）。每个数学实体——集合、函数、运算符——都必须严格按照上述定义处理。\n2. 通过以概率 $p \\in [0,1]$ 包含有向边 $i \\to j$ 来生成具有 $N$ 个节点（$N \\leq 6$）的随机小型 CFG。根据一个参数允许或禁止自环。每个测试用例使用确定性伪随机数生成器进行播种，以确保可复现性。\n3. 为每个节点 $n$ 分配随机的 $Gen_n$ 和 $Kill_n$ 子集（$U$ 的子集），这些子集在节点间独立，但在分析内部保持一致。\n4. 为上述单调框架实现一个标准的基于工作列表的前向不动点求解器。数据流方程必须严格按照规定执行：\n   - $IN_n = \\bigcup_{p \\in Pred(n)} OUT_p$，\n   - $OUT_n = (IN_n \\setminus Kill_n) \\cup Gen_n$，\n   在指定的入口节点（以节点索引 $0$ 为入口），$IN_{entry} = \\emptyset$。\n5. 在三种不同的访问/调度顺序下运行求解器：\n   - 每一步选择升序节点索引。\n   - 每一步选择降序节点索引。\n   - 每一步随机选择节点（使用提供的种子）。\n   混沌迭代应通过从工作列表中重复选择一个节点，重新计算其 $IN_n$ 和 $OUT_n$，并在 $OUT_n$ 增长时将其后继节点入队来实现。当没有 $OUT_n$ 发生变化时，算法必须终止。\n6. 检查并记录每个测试用例的两个属性：\n   - 单调性：在整个迭代过程中，对于每个节点 $n$，$IN_n$ 和 $OUT_n$ 值的序列必须在 $\\subseteq$ 关系下是单调非递减的（即，没有迭代步骤会产生严格减少）。这必须在三种访问顺序下都成立。\n   - 访问顺序无关性：最终的不动点（所有 $n = 0,1,\\dots,N-1$ 的 $OUT_n$ 集合）在三种访问顺序下必须完全相同。\n7. 对每个测试用例，生成一个编码为两个整数列表 $[b_1,b_2]$ 的结果，其中 $b_1 \\in \\{0,1\\}$ 编码单调性是否在所有三种顺序下都成立（$1$ 表示是，$0$ 表示否），$b_2 \\in \\{0,1\\}$ 编码最终不动点在所有三种顺序下是否匹配（$1$ 表示是，$0$ 表示否）。\n\n不涉及物理单位。不涉及角度。百分比必须表示为 $[0,1]$ 区间内的小数。\n\n使用以下参数值的测试套件。对于每种情况，参数为 $(N, m, p, \\text{self\\_loops}, \\text{seed\\_graph}, \\text{seed\\_order})$：\n\n- 测试用例 1（边界情况：空全域）：$(1, 0, 0.0, 0, 12345, 54321)$。\n- 测试用例 2（边界情况：可能带自环的单个节点）：$(1, 1, 1.0, 1, 202311, 202312)$。\n- 测试用例 3（正常路径：小型随机图）：$(4, 6, 0.35, 0, 111, 222)$。\n- 测试用例 4（更大的全域，允许循环）：$(6, 32, 0.5, 1, 777, 888)$。\n- 测试用例 5（稠密图）：$(5, 8, 1.0, 0, 999, 1000)$。\n- 测试用例 6（不连通图）：$(3, 5, 0.0, 0, 42, 4242)$。\n\n最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个元素本身是对应一个测试用例的两个整数列表 $[b_1,b_2]$，顺序与上面相同。例如：`[[1,1],[1,0],[1,1],[1,1],[1,1],[1,1]]`。不应打印任何其他文本。", "solution": "该问题要求构建一个软件测试工具，以经验性地验证一个特定的前向位向量数据流分析的基本属性。该分析被定义为一个单调框架，理论上保证了其收敛性和确定性。我们的任务是实现这个框架，并验证其行为在一系列不同的测试用例中是否与理论预测一致。\n\n### 问题形式化与理论基础\n\n该分析在一个幂集格 $(\\mathcal{P}(U), \\subseteq)$ 上运行，其中 $U$ 是一个包含 $m$ 个抽象事实的有限全域。$U$ 的子集是我们格中的元素，按标准集合包含关系 $\\subseteq$ 排序。该格是完备的，其底元素是空集 $\\emptyset$，顶元素是全域 $U$。对于寻求最小解（表示“可能”信息）的前向分析，交会操作（meet operator, $\\wedge$）是集合并集（$\\cup$）。\n\n分析的状态由控制流图（CFG）中每个节点 $n$ 的两个集合捕获：\n1. $IN_n$：在进入节点 $n$ 时为真的事实集合。\n2. $OUT_n$：在离开节点 $n$ 时为真的事实集合。\n\n定义这些集合之间关系的数据流方程如下：\n\n对于任何具有前驱节点集 $Pred(n)$ 的节点 $n$，其输入集是其前驱节点输出集的交会。鉴于交会操作是并集，即：\n$$IN_n = \\bigcup_{p \\in Pred(n)} OUT_p$$\n对于图的指定入口节点（我们将其设为节点 0），它在图中没有前驱节点，因此其输入初始化为格的底元素：\n$$IN_{entry} = \\emptyset$$\n\n节点传递函数 $f_n$ 的作用是将输入集 $IN_n$ 转换为输出集 $OUT_n$。问题指定了一个 $Gen/Kill$ 风格的传递函数：\n$$OUT_n = f_n(IN_n) = (IN_n \\setminus Kill_n) \\cup Gen_n$$\n这里，$Gen_n \\subseteq U$ 和 $Kill_n \\subseteq U$ 是与节点 $n$ 相关联的常量集合。$Kill_n$ 表示在节点 $n$ 的操作中失效的事实，而 $Gen_n$ 表示新生成的事实。\n\n这个方程组构成了一个单调框架。传递函数 $f_n$ 的单调性是一个关键属性。让我们正式验证它。我们必须证明对于任意两个集合 $X_1, X_2 \\in \\mathcal{P}(U)$，如果 $X_1 \\subseteq X_2$，那么 $f_n(X_1) \\subseteq f_n(X_2)$。\n- 假设 $X_1 \\subseteq X_2$。\n- 集合差集操作在其第一个参数上是单调的：$X_1 \\subseteq X_2 \\implies (X_1 \\setminus Kill_n) \\subseteq (X_2 \\setminus Kill_n)$。\n- 集合并集操作是单调的：如果 $A \\subseteq B$，那么对于任何集合 $C$，有 $(A \\cup C) \\subseteq (B \\cup C)$。\n- 应用这一点，我们得到 $(X_1 \\setminus Kill_n) \\cup Gen_n \\subseteq (X_2 \\setminus Kill_n) \\cup Gen_n$。\n- 这恰好是 $f_n(X_1) \\subseteq f_n(X_2)$。因此，传递函数是单调的。\n\n根据 Knaster-Tarski 定理，任何在完备格上的单调函数都存在一个不动点集合，包括一个最小不动点和一个最大不动点。对于一个单调方程组，一个标准的工作列表（或混沌迭代）算法，从底元素（所有 $IN_n$ 和 $OUT_n$ 集合均为 $\\emptyset$）开始，保证收敛到该系统的最小不动点。\n\n### 算法与实现设计\n\n实现的核心是一个基于工作列表的求解器。我们使用一个 $64$ 位无符号整数（`uint64_t`）将集合（事实）表示为位向量，因为全域的最大大小 $m$ 是 $64$。\n- 全域大小：$m$。\n- 集合表示：`uint64_t`。如果事实 $i$ 在集合中，则第 $i$ 位为 $1$，否则为 $0$。\n- 全域掩码：一个掩码 $M_U = (1 \\ll m) - 1$（对于 $m  64$）或 $M_U = \\sim 0ULL$（对于 $m=64$）确保操作限制在 $m$ 个事实内。\n- 集合并集 ($\\cup$)：按位或 (`|`)。\n- 集合差集 ($A \\setminus B$)：按位与和补码 (`A  (~B)`)。\n- 集合包含 ($A \\subseteq B$)：测试 `(A  B) == A`。\n\n求解器算法按以下步骤进行：\n1.  **初始化**：对所有节点 $n=0, \\dots, N-1$，初始化 $OUT_n = 0$。初始化一个包含所有节点的工作列表（例如，一个布尔数组）。\n2.  **迭代**：当工作列表不为空时：\n    a. 根据指定的调度策略（升序、降序或随机）从工作列表中选择一个节点 $u$。将 $u$ 从工作列表中移除。\n    b. 计算 $u$ 的新输入：$IN_u^{new} = \\bigvee_{p \\in Pred(u)} OUT_p$。对于入口节点 $u=0$，$IN_0$ 总是 $\\emptyset$ ($0$)。\n    c. 检查 $IN_u$ 的单调性。新输入必须是旧输入的超集：$IN_u^{old} \\subseteq IN_u^{new}$。\n    d. 计算 $u$ 的新输出：$OUT_u^{new} = (IN_u^{new} \\text{  } (\\sim Kill_u)) \\text{ | } Gen_u$。\n    e. 检查 $OUT_u$ 的单调性。新输出必须是旧输入的超集：$OUT_u^{old} \\subseteq OUT_u^{new}$。\n    f. 如果 $OUT_u^{new}$ 与 $OUT_u^{old}$ 不同（即它增大了）：\n        i. 更新 $OUT_u = OUT_u^{new}$。\n        ii. 将 $u$ 的所有后继节点添加到工作列表。\n3.  **终止**：当工作列表变空时，算法终止，这表示已达到不动点（没有 $OUT_n$ 值可以再改变）。\n\n该过程针对三种不同的从工作列表中选择节点的调度策略执行：\n-   **升序**：从工作列表中选择索引最小的节点。\n-   **降序**：从工作列表中选择索引最大的节点。\n-   **随机**：使用带种子的伪随机数生成器（PRNG），从工作列表中均匀随机地选择一个节点，以保证可复现性。\n\n### 验证属性\n\n实现必须验证两个理论上保证的关键属性：\n1.  **单调性 ($b_1$)**：在所有三种调度策略下执行求解器的整个过程中，对于每个节点 $n$，$IN_n$ 和 $OUT_n$ 的值序列必须是非递减的。也就是说，对于任何迭代步骤 $k$，$IN_n^{(k)} \\subseteq IN_n^{(k+1)}$ 且 $OUT_n^{(k)} \\subseteq OUT_n^{(k+1)}$。我们的实现会跟踪此属性，并在第一次违反时将 $b_1$ 设置为 $0$。\n2.  **访问顺序无关性 ($b_2$)**：关于单调框架上的混沌迭代理论保证了算法会收敛到唯一的最小不动点，而与节点访问顺序无关。因此，所有 $OUT_n$ 值的最终状态在三种调度策略下必须完全相同。我们通过比较最终的状态向量来验证这一点。\n\n对于每个测试用例，预期的理论结果是 $[1, 1]$，这确认了实现正确地模拟了单调框架，并且该框架的属性成立。提供的测试用例涵盖了边界条件（例如，空全域、单个节点）和更复杂的图结构，以确保鲁棒性。该测试工具是对这些经典编译器理论结果的经验性确认。", "answer": "[[1,1],[1,1],[1,1],[1,1],[1,1],[1,1]]", "id": "3635627"}]}