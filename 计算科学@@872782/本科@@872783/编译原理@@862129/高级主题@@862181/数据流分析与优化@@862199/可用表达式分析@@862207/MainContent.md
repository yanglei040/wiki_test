## 引言
在追求程序性能的极致之路上，编译器扮演着至关重要的角色。其中，消除代码中的冗余计算是一项基础而高效的优化策略。然而，编译器如何能安全地确定一个计算是“冗余”的呢？这正是**[可用表达式](@entry_id:746600)分析 (Available Expressions Analysis)**所要解决的核心问题。该技术是数据流分析领域的经典方法，通过[静态分析](@entry_id:755368)程序的控制流，精确地追踪哪些表达式的值在程序的任意一点上是“可用”的，即已经被计算出来且仍然有效，从而为[代码优化](@entry_id:747441)提供坚实的理论依据。

本文将系统性地引导你深入探索[可用表达式](@entry_id:746600)分析的世界。你将学习到：

在**“原理与机制”**一章中，我们将奠定理论基础，详细解释[可用表达式](@entry_id:746600)的定义、其作为前向“必达”分析的特性，并建立起基于Gen/Kill集的数据流方程。通过具体的例子，你将掌握如何通过迭代法求解这些方程，直至达到[不动点](@entry_id:156394)。

随后，在**“应用与跨学科关联”**一章中，我们将理论付诸实践，探讨[可用表达式](@entry_id:746600)分析如何直接驱动诸如[公共子表达式消除](@entry_id:747511)(CSE)和[循环不变代码外提](@entry_id:751465)(LICM)等关键优化。我们还将视野拓宽，讨论其在[部分冗余消除](@entry_id:753187)(PRE)、[过程间分析](@entry_id:750770)以及与其他计算机科学领域的关联。

最后，通过**“动手实践”**部分提供的精选练习，你将有机会亲自应用所学知识，解决涉及指针、[异常处理](@entry_id:749149)和复杂控制流的实际问题，从而将理论理解转化为实践能力。

让我们从最核心的原理开始，揭开[可用表达式](@entry_id:746600)分析的神秘面纱。

## 原理与机制

在[编译器优化](@entry_id:747548)领域，识别并复用已计算的表达式结果是一项基础而强大的技术。这一过程的核心是**[可用表达式](@entry_id:746600)分析 (Available Expressions Analysis)**，一种静态的数据流分析方法，用于确定在程序的每个点上，哪些表达式的值已经被计算出来并且仍然有效。本章将深入探讨[可用表达式](@entry_id:746600)分析的原理、[数据流](@entry_id:748201)框架、核心机制以及在处理复杂程序构造（如指针和循环）时的实际考量。

### [可用表达式](@entry_id:746600)的基本原理

#### 定义与直觉

一个表达式 $e$ 在程序点 $p$ 被认为是**可用 (available)** 的，当且仅当从程序入口到点 $p$ 的**每一条**执行路径上，$e$ 都已经被计算过，并且自最后一次计算后，$e$ 的任何操作数都未被重新定义。

这个定义包含两个关键要素：

1.  **“每一条路径” (All Paths)**：这表明[可用表达式](@entry_id:746600)分析是一种**必达 (must)** 分析。一个表达式必须在所有通往某点的路径上都可用，才能在该点被认为是可用的。如果只在部分路径上可用，那么在合并点就不能保证其值的有效性。
2.  **“已经计算且未被重定义” (Computed and Not Redefined)**：这决定了分析的方向。我们关心的是“过去”发生了什么——表达式是否已经被计算，其依赖的变量值自那时起是否保持不变。因此，这是一种**前向 (forward)** 分析，信息沿着[控制流](@entry_id:273851)的方向传播。

例如，考虑一段代码 `t1 := a + b; ...; t2 := a + b;`。如果分析确定在计算 `t2` 之前，表达式 `a+b` 是可用的，那么编译器就可以安全地将第二个 `a+b` 的计算替换为对 `t1` 的简单引用，从而避免一次冗余的加法运算。这就是所谓的**[公共子表达式消除](@entry_id:747511) (Common Subexpression Elimination, CSE)**，是[可用表达式](@entry_id:746600)分析最直接的应用之一。

### [可用表达式](@entry_id:746600)的[数据流](@entry_id:748201)分析框架

为了系统地进行分析，我们使用数据流分析的通用框架来形式化[可用表达式](@entry_id:746600)。该框架由分析方向、交汇操作和[传递函数](@entry_id:273897)三个部分定义。

#### 分析方向：前向分析

如前所述，一个表达式的可用性取决于其历史计算状态。我们需要从程序入口开始，顺着控制流的方向，逐步计算每个程序点的[可用表达式](@entry_id:746600)集合。

#### 交汇操作：交集

当多条[控制流](@entry_id:273851)路径在一个点（例如，`if-else` 语句或循环头之后的合并点）[汇合](@entry_id:148680)时，我们需要合并来自不同路径的信息。根据“必达”原则，一个表达式在汇合点可用，必须保证它在所有前驱路径的末端都可用。这一逻辑自然对应于集合的**交集 ($\cap$)** 操作。

#### [传递函数](@entry_id:273897)：Gen与Kill集

对于一个基本块 $B$（一段无分支的连续指令序列），我们需要一个**[传递函数](@entry_id:273897) (transfer function)** 来描述该基本块如何改变[可用表达式](@entry_id:746600)的集合。该函数基于进入块 $B$ 的[可用表达式](@entry_id:746600)集合 $IN[B]$，计算出离开块 $B$ 的[可用表达式](@entry_id:746600)集合 $OUT[B]$。

这个过程通过两个局部信息集来建模：

-   **$gen[B]$**：在基本块 $B$ 内部计算，并且在离开 $B$ 时仍然有效的表达式集合。这些表达式被块 $B$ “生成”了可用性。
-   **$kill[B]$**：由于其操作数在块 $B$ 内部被重新赋值，而变得不再可用的表达式集合。这些表达式的可用性被块 $B$ “杀死”了。

[传递函数](@entry_id:273897)的[标准形式](@entry_id:153058)如下：
$OUT[B] = gen[B] \cup (IN[B] - kill[B])$

这个公式的直观解释是：离开一个基本块时可用的表达式，等于在该块内新生成的表达式，加上那些进入该块时可用且未被该块杀死的表达式。

综合起来，整个数据流分析由以下一组方程定义，其中 $\text{pred}(B)$ 代表块 $B$ 的所有前驱基本块的集合：
$IN[B] = \bigcap_{P \in \text{pred}(B)} OUT[P]$
$OUT[B] = gen[B] \cup (IN[B] - kill[B])$

分析从程序入口开始（通常假设入口处的 $IN$ 集为[空集](@entry_id:261946)），通过迭代计算所有基本块的 $IN$ 和 $OUT$ 集，直到达到一个**[不动点](@entry_id:156394) (fixed point)**，即所有集合不再发生变化为止。

### 计算Gen与Kill集：核心机制

[传递函数](@entry_id:273897)的准确性完全取决于 $gen$ 和 $kill$ 集的精确计算。

#### 生成 (Generation)

一个表达式的可用性始于它的计算。当一个指令如 `t := x + y` 执行时，它在程序中生成了表达式 `x+y`。因此，`x+y` 会被加入到其所在基本块的 $gen$ 集中。

需要注意的是，表达式的粒度很重要。例如，在指令 `s := (x+y)*z` 中，被计算的顶级表达式是 `(x+y)*z`。在标准的[可用表达式](@entry_id:746600)分析中，我们通常将 `(x+y)*z` 和它的子表达式 `x+y` 视为两个不同的[数据流](@entry_id:748201)事实。因此，该指令会生成 `(x+y)*z`，但通常不认为它也生成了 `x+y`，除非分析被设计为同时处理子表达式 [@problem_id:3622945]。精确的分析需要独立追踪每个感兴趣的表达式。

#### 杀死 (Killing)

当一个表达式的操作数被赋予新值时，该表达式之前计算的结果就失效了。例如，一条指令 `x := ...` 会重新定义变量 `x`。因此，任何依赖于 `x` 的表达式，如 `x+y`、`z*x` 或 `x-w`，都会被“杀死”。这些表达式必须从可用集合中移除。

一个基本块的 $kill$ 集是所有其操作数在该块内被重新定义的表达式的集合。

#### 块内分析

在计算单个基本块的 $gen$ 和 $kill$ 集时，指令的顺序至关重要。考虑以下代码块 [@problem_id:3622870]：
1.  `t1 := x + y`
2.  `y := y - 1`
3.  `t2 := y + x`

-   指令1计算了 `x+y`。
-   但指令2立即重定义了 `y`，因此表达式 `x+y` 的可用性被杀死。即使它刚被计算，它也不能在块的出口处保持可用。
-   指令3计算了 `y+x` (使用 `y` 的新值)。由于此后块内没有对 `x` 或 `y` 的重定义，这个新计算的 `y+x` 在块的出口是可用的。

因此，对于这个块，$gen[B]$ 包含 `y+x`，但不包含 `x+y`。$kill[B]$ 则包含所有依赖于 `y` 的表达式，因为 `y` 被重定义了。

### 求解数据流方程：一个完整示例

让我们通过一个具体的例子来演示如何通过迭代求解[数据流](@entry_id:748201)方程 [@problem_id:3622891] [@problem_id:3622924]。考虑以下包含四个基本块的[控制流图](@entry_id:747825)，我们的目标是分析表达式 $e_1 = x+y$、$e_2 = x+z$ 和 $e_3 = y+z$ 的可用性。

-   $B_1$: `t1 := x + y`；然后根据条件分支到 $B_2$ 或 $B_3$。
-   $B_2$: `x := x + 1; t2 := x + z; t3 := y + z`；然后跳转到 $B_4$。
-   $B_3$: `t4 := y + z`；然后跳转到 $B_4$。
-   $B_4$: 合并点。

**第一步：计算 $gen$ 和 $kill$ 集**

-   **$B_1$**: 计算 `x+y`。$gen[B_1] = \{e_1\}$，$kill[B_1] = \emptyset$。
-   **$B_2$**: `x` 被重定义，杀死所有含 `x` 的表达式。然后计算 `x+z` 和 `y+z`。$kill[B_2] = \{e_1, e_2\}$，$gen[B_2] = \{e_2, e_3\}$。
-   **$B_3$**: 计算 `y+z`。$gen[B_3] = \{e_3\}$，$kill[B_3] = \emptyset$。
-   **$B_4$**: 无指令。$gen[B_4] = \emptyset$，$kill[B_4] = \emptyset$。

**第二步：迭代求解**

我们假设程序入口处没有可用的表达式，即 $IN[B_1] = \emptyset$。我们初始化所有其他块的 $OUT$ 集为[空集](@entry_id:261946)，然后开始迭代。

**迭代 1：**

1.  $OUT[B_1] = gen[B_1] \cup (IN[B_1] - kill[B_1]) = \{e_1\} \cup (\emptyset - \emptyset) = \{e_1\}$。

2.  $IN[B_2] = OUT[B_1] = \{e_1\}$。
    $OUT[B_2] = gen[B_2] \cup (IN[B_2] - kill[B_2]) = \{e_2, e_3\} \cup (\{e_1\} - \{e_1, e_2\}) = \{e_2, e_3\} \cup \emptyset = \{e_2, e_3\}$。

3.  $IN[B_3] = OUT[B_1] = \{e_1\}$。
    $OUT[B_3] = gen[B_3] \cup (IN[B_3] - kill[B_3]) = \{e_3\} \cup (\{e_1\} - \emptyset) = \{e_1, e_3\}$。

4.  $IN[B_4] = OUT[B_2] \cap OUT[B_3] = \{e_2, e_3\} \cap \{e_1, e_3\} = \{e_3\}$。
    $OUT[B_4] = gen[B_4] \cup (IN[B_4] - kill[B_4]) = \emptyset \cup (\{e_3\} - \emptyset) = \{e_3\}$。

**迭代 2：**

我们重复此过程，将上一轮计算出的 $OUT$ 值作为新的输入。
1.  $OUT[B_1]$ 不变。
2.  $IN[B_2]$ 和 $IN[B_3]$ 不变，因此 $OUT[B_2]$ 和 $OUT[B_3]$ 也不变。
3.  $IN[B_4]$ 的计算依赖于 $OUT[B_2]$ 和 $OUT[B_3]$，它们都未改变，因此 $IN[B_4]$ 保持为 $\{e_3\}$，$OUT[B_4]$ 也保持不变。

由于所有集合的值在[本轮](@entry_id:169326)迭代中都没有改变，系统达到了[不动点](@entry_id:156394)。

**结论**：在合并点 $B_4$ 的入口处，$IN[B_4] = \{e_3\}$，意味着只有表达式 $y+z$ 是可用的。为什么？因为尽管两条路径都在其内部计算了 `y+z`，但 `x+y` ($e_1$) 只在通往 $B_3$ 的路径上幸存，而在通往 $B_2$ 的路径上被杀死。`x+z` ($e_2$) 只在 $B_2$ 内部计算，在通往 $B_3$ 的路径上从未出现。根据交集规则，只有在所有路径上都幸存的 $e_3$ 才是最终在 $B_4$ 入口处可用的。

### 高级主题与实际考量

真实的程序比上述简单示例要复杂得多。一个稳健的[可用表达式](@entry_id:746600)分析必须处理函数调用、[指针别名](@entry_id:753540)、循环和不同的表达式表示等问题。

#### [函数调用](@entry_id:753765)与[指针别名](@entry_id:753540)

[函数调用](@entry_id:753765)是[可用表达式](@entry_id:746600)分析中的一个主要障碍，因为调用可能产生未知的**副作用 (side effects)**。

-   **最保守的方法**：假设任何[函数调用](@entry_id:753765)都可能修改任何全局变量或通过指针传递的变量。在这种模型下，一个[函数调用](@entry_id:753765)会杀死几乎所有涉及这些变量的[可用表达式](@entry_id:746600) [@problem_id:3622904]。这虽然安全，但会严重削弱优化的机会。

-   **更精确的方法**：现代编译器通过**[过程间分析](@entry_id:750770) (interprocedural analysis)** 来获得关于函数副作用的更精确信息，例如一个函数的 `Mod` 集，即该函数可能修改的变量集合。

-   **[指针别名](@entry_id:753540) (Pointer Aliasing)**：当程序使用指针时，情况变得更加复杂。两个不同的指针变量可能指向同一个内存地址，这种现象称为**别名**。一个通过指针的写操作（如 `*p = ...`）可能会修改多个看似无关的变量。
    -   [可用表达式](@entry_id:746600)分析必须是保守的：如果一个指针 `p` **可能[别名](@entry_id:146322) (may-alias)** 一个变量 `x`，那么对 `*p` 的写操作必须被视为对 `x` 的潜在重定义，从而杀死所有包含 `x` 的表达式。只有当**[别名](@entry_id:146322)分析 (alias analysis)** 能够证明 `p` **没有[别名](@entry_id:146322) (no-alias)** `x` 时，我们才能安全地假设 `x` 未被修改 [@problem_id:3622904]。
    -   形式上，使用**[指向分析](@entry_id:753542) (points-to analysis)** 的结果，一个通过指针 `r` 的写操作 `r->f := v` 会杀死表达式 `p->f`，如果 `r` 和 `p` 可能指向的对象集合有交集，即 $Pts(r) \cap Pts(p) \neq \emptyset$ [@problem_id:3622888]。

#### 循环中的[可用表达式](@entry_id:746600)

循环是优化的热点。如果一个表达式在循环的每次迭代中都被计算，并且其值在循环内部不改变，那么它就是一个**[循环不变量](@entry_id:636201) (loop-invariant)**。[可用表达式](@entry_id:746600)分析是识别这类表达式的关键。

考虑一个循环，其头部为 $H$，前置头部（循环外进入循环的唯一路径）为 $P$，循环体为 $B$，回边为 $U$。一个表达式在循环头 $H$ 处可用，意味着它在从 $P$ 进入循环时是可用的，并且在循环的每次迭代（通过 $B$ 和 $U$）后仍然是可用的。

-   如果一个表达式在 $P$ 中被计算（生成），并且在循环体 $B$ 和回边块 $U$ 中都**不**被杀死，那么它将是[循环不变量](@entry_id:636201)，在 $H$ 处总是可用 [@problem_id:3622947]。这种表达式的计算可以被安全地提到循环外部，即**代码外提 (code motion)**。
-   相反，如果表达式在回边 $U$ 中被杀死（例如，`x := x+1` 杀死了 `x*y`），那么即使它在循环体 $B$ 中被计算，它在下一次迭代的循环头 $H$ 处也不会是可用的（因为它在回边路径上不可用）[@problem_id:3622947]。
-   这也凸显了 `kill` 集定义准确性的重要性。一个有缺陷的 `kill` 集（例如，由于对[别名](@entry_id:146322)处理不当而未能杀死表达式）会导致不安全的优化，即编译器错误地认为一个表达式可用而复用其旧值，导致程序错误 [@problem_id:3622947]。

#### 表达式的粒度：[语法与语义](@entry_id:148153)

我们如何表示表达式？
-   **语法表示**：这是最简单的方法，将表达式视为字符串。在这种模型下，`x+y` 和 `y+x` 是两个完全不同的表达式。这种分析实现简单，但错失了基于代数定律（如[交换律](@entry_id:141214)）的优化机会 [@problem_id:3622870]。
-   **语义表示**：更强大的方法是使用**[值编号](@entry_id:756409) (Value Numbering)** 等技术，将具有相同数学意义的表达式归入同一个**[等价类](@entry_id:156032)**。例如，`x+y` 和 `y+x` 属于同一个[等价类](@entry_id:156032) $[x+y]$。
    -   在这种模型下，对等价类进行分析。计算 `y+x` 会生成 $[x+y]$ 的可用性。对 `y` 的赋值会杀死所有包含 `y` 的等价类，如 $[x+y]$ 和 $[y+z]$ [@problem_id:3622870]。这种方法更强大，能发现更多的冗余计算。

### 与其他数据流分析的对比

将[可用表达式](@entry_id:746600)分析与其他类型的[数据流](@entry_id:748201)分析进行比较，有助于更深刻地理解其本质。

#### Must vs. May 分析

[可用表达式](@entry_id:746600)分析是**必达 (must)** 分析，因为它要求属性在**所有**路径上成立，其交汇操作是**交集**。与之相对的是**可能 (may)** 分析，它只要求属性在**至少一条**路径上成立，其交汇操作是**并集 ($\cup$)**。

例如，**可能[可用表达式](@entry_id:746600)**分析将确定一个表达式是否在某条路径上被计算而未被杀死。这两种分析服务于不同目的，它们在交汇点的不同处理方式是其根本区别 [@problem_id:3622935]。

#### 前向 vs. [后向分析](@entry_id:746642)

[可用表达式](@entry_id:746600)分析是**前向 (forward)** 分析，它推断的是程序“过去”的状态。与之相对的是**后向 (backward)** 分析，它推断的是程序“未来”的状态。

一个经典的[后向分析](@entry_id:746642)是**[活跃变量分析](@entry_id:751374) (Live Variable Analysis)** 或**预期表达式分析 (Anticipable/Very Busy Expressions Analysis)**。预期表达式在点 $p$ 是“非常繁忙”的，如果从 $p$ 出发的**所有**路径上，该表达式都将被使用，且在其操作数被重定义之前。这种分析从程序出口向入口[反向传播](@entry_id:199535)信息，用于其他优化，如[部分冗余消除](@entry_id:753187) [@problem_id:3622909]。[可用表达式](@entry_id:746600)和预期表达式的对偶性是数据流分析领域一个优美而深刻的概念。