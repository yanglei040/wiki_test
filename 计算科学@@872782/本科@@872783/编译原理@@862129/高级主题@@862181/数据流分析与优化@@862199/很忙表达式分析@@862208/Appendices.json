{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。“非常繁忙表达式”分析的核心在于其“必须”（must）属性，即一个表达式必须在**所有**未来的路径上都被求值。本练习 [@problem_id:3682374] 设计了一个简单的带有分支和跳转的控制流，旨在帮助你直观地理解这一关键概念，看看一条“绕行”的路径是如何影响表达式的“繁忙”状态的。", "problem": "考虑以下带有显式 goto 和合并的直线型代码片段。设目标表达式为 $e \\equiv x + y$。假设 $b$ 是一个布尔值，其求值没有副作用，也不会修改 $x$ 或 $y$。同时，假设除了明确显示的语句外，其他任何语句都没有隐藏的副作用。\n\n$S_1$: if $(b)$ goto $S_2$ else goto $S_4$\n\n$S_2$: $t \\leftarrow x + y$\n\n$S_3$: goto $S_5$\n\n$S_4$: goto $S_5$\n\n$S_5$: $y \\leftarrow y + 1$\n\n$S_6$: $u \\leftarrow x + y$\n\n控制流转移如下：从 $S_1$ 到 $S_2$ 或 $S_4$；从 $S_2$ 到 $S_3$；从 $S_3$ 和 $S_4$ 到 $S_5$ 处的合并点；然后到 $S_6$。\n\n定义（基本依据）：如果从程序点 $p$ 开始的每条路径上，表达式 $e$ 的求值都发生在对 $e$ 的任何操作数进行任何赋值之前，那么表达式 $e$ 在该程序点 $p$ 是非常繁忙的（very busy）。这是数据流分析中的一个后向必须（backward must）属性。\n\n问题：根据上述定义，在下列哪个程序点，$x+y$ 是非常繁忙的？\n\nA. 紧接在 $S_1$ 之前\n\nB. 紧接在 $S_2$ 之前\n\nC. 紧接在 $S_4$ 之前\n\nD. 紧接在 $S_5$ 之前\n\nE. 紧接在 $S_6$ 之前\n\n选择所有适用项。您的论证应依据所述定义和所描述的控制流，特别注意使用 goto 跳过 $S_2$ 处计算的路径以及路径在 $S_5$ 处重新汇合的情况。", "solution": "问题要求确定在哪些程序点，表达式 $e \\equiv x + y$ 是“非常繁忙的”（very busy）。\n\n首先，我们根据所提供的信息将问题形式化。\n该程序由一系列语句 $S_1$ 到 $S_6$ 组成。其控制流图（CFG）如下：\n- 一个初始块进入 $S_1$。\n- 从 $S_1$ 有两个分支：到 $S_2$ 或到 $S_4$。\n- 从 $S_2$，控制流转向 $S_3$。\n- 从 $S_4$，控制流转向 $S_5$。\n- 从 $S_3$，控制流转向 $S_5$。因此，$S_5$ 是来自 $S_3$ 和 $S_4$ 路径的合并点。\n- 从 $S_5$，控制流转向 $S_6$。\n- 在 $S_6$ 之后，该代码片段结束。\n\n这些语句是：\n- $S_1$: `if (b) goto S_2 else goto S_4`\n- $S_2$: `t ← x + y`\n- $S_3$: `goto S_5`\n- $S_4$: `goto S_5`\n- $S_5$: `y ← y + 1`\n- $S_6$: `u ← x + y`\n\n目标表达式是 $e \\equiv x + y$。 $e$ 的操作数是 $x$ 和 $y$。\n- 表达式 $e$ 在语句 $S_2$ 和 $S_6$ 中被求值。\n- 在语句 $S_5$ 中，$e$ 的一个操作数被修改（对 $e$ 而言是一次“扼杀”（kill）），其中 $y$ 被赋予一个新值。\n\n提供的定义是：“如果从程序点 $p$ 开始的每条路径上，表达式 $e$ 的求值都发生在对 $e$ 的任何操作数进行任何赋值之前，那么表达式 $e$ 在该程序点 $p$ 是非常繁忙的。”\n\n我们现在将分析选项中指定的每个程序点。\n\nA. **紧接在 $S_1$ 之前**\n设紧接在 $S_1$ 之前的程序点为 $p_1$。从 $p_1$ 开始，有两条可能的路径穿过该代码片段：\n1. 路径 1: $S_1 \\rightarrow S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n2. 路径 2: $S_1 \\rightarrow S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n定义要求该条件对*每条*路径都成立。让我们检查路径 2。\n- 在这条路径上，第一个涉及 $e$ 或其操作数的语句是 $S_5$，它包含赋值语句 $y \\leftarrow y + 1$。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上第一次对 $e$ 的求值发生在后面的语句 $S_6$ 中。\n- 因此，在路径 2 上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n由于从 $p_1$ 开始的一条路径不满足该条件，所以表达式 $x+y$ 在紧接在 $S_1$ 之前不是非常繁忙的。\n**结论：不正确**\n\nB. **紧接在 $S_2$ 之前**\n设紧接在 $S_2$ 之前的程序点为 $p_2$。从 $p_2$ 开始只有一条路径：\n1. 路径 1: $S_2 \\rightarrow S_3 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n让我们检查这条路径。\n- 这条路径上的第一个语句就是 $S_2$。\n- $S_2$ 包含了求值 $t \\leftarrow x + y$。\n- 在这条路径上，此求值之前没有对 $x$ 或 $y$ 的赋值（第一次这样的赋值是在 $S_5$ 中，它在 $S_2$ 之后）。\n- 因此，沿着这条路径，对 $e$ 的求值发生在对 $e$ 的任何操作数进行赋值之前。\n因为这是从 $p_2$ 开始的唯一路径，所以条件对“每条路径”都成立。因此，表达式 $x+y$ 在紧接在 $S_2$ 之前是非常繁忙的。\n**结论：正确**\n\nC. **紧接在 $S_4$ 之前**\n设紧接在 $S_4$ 之前的程序点为 $p_4$。从 $p_4$ 开始只有一条路径：\n1. 路径 1: $S_4 \\rightarrow S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n让我们检查这条路径。\n- 这条路径上的第一个语句是 $S_4$，它是一个 `goto` 语句，不影响 $e$ 或其操作数。\n- 下一个语句是 $S_5$，它包含赋值语句 $y \\leftarrow y + 1$。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上第一次对 $e$ 的求值发生在后面的语句 $S_6$ 中。\n- 因此，在这条路径上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n条件不成立。因此，表达式 $x+y$ 在紧接在 $S_4$ 之前不是非常繁忙的。\n**结论：不正确**\n\nD. **紧接在 $S_5$ 之前**\n设紧接在 $S_5$ 之前的程序点为 $p_5$。从 $p_5$ 开始只有一条路径：\n1. 路径 1: $S_5 \\rightarrow S_6 \\rightarrow \\dots$\n\n让我们检查这条路径。\n- 第一个语句是 $S_5$，它包含赋值语句 $y \\leftarrow y + 1$。这是对 $e$ 的一个操作数的赋值。\n- 这条路径上第一次对 $e$ 的求值发生在下一个语句 $S_6$ 中。\n- 因此，在这条路径上，对 $e$ 的操作数的赋值发生在对 $e$ 的求值*之前*。\n条件不成立。因此，表达式 $x+y$ 在紧接在 $S_5$ 之前不是非常繁忙的。\n**结论：不正确**\n\nE. **紧接在 $S_6$ 之前**\n设紧接在 $S_6$ 之前的程序点为 $p_6$。从 $p_6$ 开始只有一条路径：\n1. 路径 1: $S_6 \\rightarrow \\dots$\n\n让我们检查这条路径。\n- 这条路径上的第一个语句就是 $S_6$。\n- $S_6$ 包含了求值 $u \\leftarrow x + y$。\n- 在此求值之前没有对 $x$ 或 $y$ 的赋值（或在 $S_6$ 内部，在求值之前没有）。\n- 因此，沿着这条路径，对 $e$ 的求值发生在对 $e$ 的任何（可能后续的）操作数进行赋值之前。\n因为这是从 $p_6$ 开始的唯一路径，所以条件对“每条路径”都成立。因此，表达式 $x+y$ 在紧接在 $S_6$ 之前是非常繁忙的。\n**结论：正确**\n\n分析总结：\n- A：不是非常繁忙的。\n- B：非常繁忙的。\n- C：不是非常繁忙的。\n- D：不是非常繁忙的。\n- E：非常繁忙的。\n\n正确的选项是 B 和 E。", "answer": "$$\\boxed{BE}$$", "id": "3682374"}, {"introduction": "除了在所有路径上被求值外，一个非常繁忙的表达式还必须在其任何操作数被重新定义之前被使用。这个“杀死”（kill）操作是数据流分析中的一个关键点。本练习 [@problem_id:3682423] 探讨了一个更微妙的场景：当表达式的操作数只在某个条件分支中被修改时会发生什么？这能帮助你深入理解“杀死”集合如何与“必须在所有路径上”这一要求相互作用。", "problem": "考虑以下带有条件分支的直线代码片段，该片段以控制流图（CFG）的形式表示，并具有赋值和条件的常规语义。所有变量都是标量整数，条件 $c$ 是一个布尔值。该片段包含对同一二元算术表达式 $x+y$ 的两次计算，两次计算之间有一次对 $x$ 的递增操作：\n- 第 $1$ 行：$t_1 := x + y$\n- 第 $2$ 行：if $c$ then $x := x + 1$ else skip\n- 第 $3$ 行：$t_2 := x + y$\n假设 $c$ 是一个任意布尔值，并且没有关于其值的额外信息（也就是说，不知道 $c$ 是总是为真还是总是为假）。关注表达式 $x+y$ 和以下两个程序点：\n- $P_{\\text{entry}}$：紧邻第 $1$ 行之前的程序点。\n- $P_{1}$：紧邻第 $1$ 行之后、第 $2$ 行之前的程序点。\n使用非常活跃表达式的标准定义：如果从程序点 $p$ 开始并通向程序出口（或所考虑区域的末尾）的每一条路径上，在表达式 $e$ 中出现的任何变量被赋值之前，都有对 $e$ 的后续求值，那么表达式 $e$ 在程序点 $p$ 是非常活跃的。同时使用标准的“杀死”（kill）概念：语句 $v := \\cdots$ 会杀死任何包含变量 $v$ 的表达式，其意义在于，从该语句开始，该表达式先前预期的值若不重新计算便无法重用。\n\n仅根据这些定义和上述代码片段，下列哪些陈述是正确的？选择所有适用项。\n\nA. 对于在 $P_{1}$ 点的非常活跃分析而言，赋值语句 $x := x + 1$ 杀死了表达式 $x+y$；因此 $x+y$ 在 $P_{1}$ 点不是非常活跃的，但由于在第1行即将进行求值，$x+y$ 在 $P_{\\text{entry}}$ 点是非常活跃的。\n\nB. 赋值语句 $x := x + 1$ 没有杀死 $x+y$，因为该表达式在第3行被重新计算；因此 $x+y$ 在 $P_{1}$ 和 $P_{\\text{entry}}$ 两点都是非常活跃的。\n\nC. 只有当 $x$ 和 $y$ 在下一次求值之前都被赋值时，赋值语句才会杀死 $x+y$；因为在第2行只有 $x$ 被赋值，所以 $x+y$ 在 $P_{1}$ 点仍然是非常活跃的。\n\nD. 仅当已知 $c$ 绝对为假时，表达式 $x+y$ 才会在 $P_{1}$ 点非常活跃；否则，在真分支上可能执行的 $x := x + 1$ 会阻止 $x+y$ 在 $P_{1}$ 点成为非常活跃的表达式。", "solution": "问题陈述经过严格验证，是有效的。这是一个在编译器理论中的数据流分析标准框架下定义明确的问题。“非常活跃表达式”和“杀死”概念的定义是标准的、无歧义的。所给的代码片段简单且足以进行所要求的分析。\n\n我们需要确定表达式 `$x+y$` 在两个程序点：`$P_{\\text{entry}}$`（第1行之前）和 `$P_1$`（第1行之后，第2行之前）的“非常活跃”状态。\n\n非常活跃表达式的定义如下：如果从程序点 `$p$` 开始并通向出口的**每一条路径**上，在表达式 `$e$` 中出现的任何变量被**赋值之前**，都有对 `$e$` 的后续求值，那么表达式 `$e$` 在程序点 `$p$` 就是非常活跃的。这是一个后向数据流分析问题。“每一条路径”的要求意味着在控制流汇合点（或在后向分析中的分叉点），其汇流操作符是交集。\n\n让我们从代码片段的末尾开始反向分析 `$x+y$` 的非常活跃性。\n\n1.  **在第3行之后（即该片段的出口点）：** 表达式 `$x+y$` 不是非常活跃的，因为没有后续路径，因此也没有后续求值。\n\n2.  **在第3行之前：** 只有一条向前的路径，即执行第3行：`$t_2 := x + y$`。这是对 `$x+y$` 的一次求值，并且它发生在对 `$x$` 或 `$y$` 的任何其他赋值之前。因此，`$x+y$` 在第3行之前是非常活跃的。这个点是第2行条件语句之后的汇合点。\n\n3.  **在程序点 $P_1$（第2行之前）：** 为了确定 `$x+y$` 在 `$P_1$` 是否非常活跃，我们必须检查从 `$P_1$` 出发的所有路径。由于条件 `if c` 的存在，有两条路径：\n    *   **路径A（'true'分支）：** 执行语句 `$x := x + 1$`。这是对变量 `$x$` 的一次赋值，而 `$x$` 出现在表达式 `$x+y$` 中。根据定义，对表达式中任何变量的赋值都会阻止该表达式在该路径上被预期。问题陈述指出，语句 `$v := \\cdots$` 会 *杀死* 任何包含 `$v$` 的表达式。因此，赋值语句 `$x := x + 1$` 杀死了对 `$x+y$` 的预期。尽管 `$x+y$` 稍后在第3行被求值，但这次求值发生在变量 `$x$` 被重新定义*之后*。因此，沿着这条路径，不满足非常活跃的条件。\n    *   **路径B（'false'分支）：** 执行 `skip` 语句。这不会修改任何变量。路径继续到第3行，在那里 `$x+y$` 被求值。沿着这条路径，`$x+y$` 在其任何组成变量被重新赋值之前就被求值了。因此，沿着这条路径，满足非常活跃的条件。\n\n    “非常活跃”的定义要求条件在**每一条路径**上都成立。由于路径A不满足该条件，表达式 `$x+y$` 在程序点 `$P_1$` **不是非常活跃的**。问题明确指出 `$c$` 是任意的，因此我们必须假设两条路径都是可能的。\n\n4.  **在程序点 $P_{\\text{entry}}$（第1行之前）：** 从 `$P_{\\text{entry}}$` 出发，只有一条向前的路径，直接通向第1行：`$t_1 := x + y$`。这是对表达式 `$x+y$` 的一次求值。这次求值是路径上的第一个事件，因此它必然发生在对 `$x$` 或 `$y$` 的任何重新定义之前。因此，表达式 `$x+y$` 在程序点 `$P_{\\text{entry}}$` **是非常活跃的**。\n\n分析总结：\n*   在 `$P_{\\text{entry}}$`，`$x+y$` 是非常活跃的。\n*   在 `$P_1$`，`$x+y$` 不是非常活跃的。\n\n现在我们来评估每个选项。\n\n**A. 对于在 $P_{1}$ 点的非常活跃分析而言，赋值语句 $x := x + 1$ 杀死了表达式 $x+y$；因此 $x+y$ 在 $P_{1}$ 点不是非常活跃的，但由于在第1行即将进行求值，$x+y$ 在 $P_{\\text{entry}}$ 点是非常活跃的。**\n这段陈述与我们的分析完全一致。真分支上的赋值 `$x := x + 1$` 确实杀死了对 `$x+y$` 的预期。因为“非常活跃”属性必须在所有路径上都成立，而它在这条路径上不成立，所以 `$x+y$` 在 `$P_1$` 不是非常活跃的。该陈述还正确地得出结论，即由于第1行的立即求值，`$x+y$` 在 `$P_{\\text{entry}}$` 是非常活跃的。\n**结论：正确**\n\n**B. 赋值语句 $x := x + 1$ 没有杀死 $x+y$，因为该表达式在第3行被重新计算；因此 $x+y$ 在 $P_{1}$ 和 $P_{\\text{entry}}$ 两点都是非常活跃的。**\n这段陈述曲解了数据流分析中“杀死”的概念。对变量 `$v$` 的赋值会杀死任何包含 `$v$` 的表达式。表达式稍后被重新计算这一事实并不能否定“杀死”操作。路径上的“杀死”行为意味着赋值前表达式的值无法使用，这破坏了该路径上的“非常活跃”条件。如上所述，`$x+y$` 在 `$P_1$` 非常活跃的结论是错误的。\n**结论：不正确**\n\n**C. 只有当 $x$ 和 $y$ 在下一次求值之前都被赋值时，赋值语句才会杀死 $x+y$；因为在第2行只有 $x$ 被赋值，所以 $x+y$ 在 $P_{1}$ 点仍然是非常活跃的。**\n这段陈述给出了一个错误的“杀死”定义。如果表达式中的**任何**一个变量被重新定义，该表达式就会被杀死。修改 `$x$` 足以杀死 `$x+y$`。这个前提是错误的，因此 `$x+y$` 在 `$P_1$` 仍然非常活跃的结论也是错误的。\n**结论：不正确**\n\n**D. 仅当已知 $c$ 绝对为假时，表达式 $x+y$ 才会在 $P_{1}$ 点非常活跃；否则，在真分支上可能执行的 $x := x + 1$ 会阻止 $x+y$ 在 $P_{1}$ 点成为非常活跃的表达式。**\n这段陈述提供了一个正确而细致的解释。如果已知 `$c$` 为假，控制流将绕过赋值语句 `$x := x + 1$`，从而有效地将代码简化为一条直线，其中 `$x+y$` 在第3行被求值，而在此期间 `$x$` 或 `$y$` 没有任何中间修改。在这种假设情况下，`$x+y$` 在 `$P_1$` 点将是非常活跃的。该陈述的后半部分，“否则，在真分支上可能执行的 `$x := x + 1$` 会阻止 `$x+y$` 在 `$P_1$` 点成为非常活跃的表达式”，正确地指出了在问题给出的 `$c$` 为任意值的情况下，`$x+y$` 不是非常活跃的原因。这是对“每一条路径”规则的精确描述。\n**结论：正确**", "answer": "$$\\boxed{AD}$$", "id": "3682423"}, {"introduction": "理解了基本概念后，我们便可以将它们整合到一个系统性的算法框架中。本练习 [@problem_id:3682446] 要求你进行一次完整的后向数据流分析。你需要为每个基本块系统地计算 $Gen$ 和 $Kill$ 集合，并应用数据流方程进行迭代，直到找到不动点解，从而最终确定程序入口处的非常繁忙表达式。这个过程将概念性的理解转化为具体的计算技能。", "problem": "考虑以下用于单个过程的、使用三地址码的中间表示（IR）。该 IR 被划分为具有显式控制流的基本块。所有变量 $a$、$b$、$c$ 和 $d$ 都是标量程序变量；所有 $t_i$ 都是不同的临时变量。运算符 $+$ 表示整数加法，并且没有发生别名。该 IR 如下：\n\n基本块 $B_1$：\n1. $t_0 := d  0$\n2. if $t_0$ goto $B_2$ else goto $B_3$\n\n基本块 $B_2$：\n3. $t_1 := a + b$\n4. $a := a - c$\n5. $t_4 := a + b$\n6. goto $B_4$\n\n基本块 $B_3$：\n7. $t_2 := a + b$\n8. $b := b - c$\n9. $t_5 := a + b$\n10. goto $B_4$\n\n基本块 $B_4$：\n11. $t_6 := a + b$\n12. $t_7 := a + c$\n13. return $t_6$\n\n假设一个标准的控制流图，其中 $B_1$ 分支到 $B_2$ 和 $B_3$， $B_2$ 和 $B_3$ 都流入 $B_4$，而 $B_4$ 流向过程出口。你需要执行非常忙碌表达式分析，该分析定义为一种针对表达式出现次数的后向、交集（必须）数据流分析，遵循以下规则：\n\n- 如果一个表达式 $e$ 具有相同的运算符和相同顺序的操作数变量，则它在整个 IR 中被认为是相同的；临时变量的标识是无关紧要的。例如，$t_1 := a + b$ 和 $t_2 := a + b$ 都计算相同的表达式 $a + b$，并且不假设交换律（所以 $a + b \\neq b + a$）。\n- 对程序变量 $x$ 的赋值会杀死（kill）每个在语法上包含 $x$ 作为操作数的表达式。\n- 候选表达式的全集仅限于 IR 中出现的不同的、非临时变量的二元加法。\n\n将过程出口视为一个边界，在此处没有非常忙碌的表达式。基于这些基础，并在不考虑临时变量名称的情况下进行分析，确定在基本块 $B_1$ 入口处非常忙碌的不同候选表达式的数量。请以单个数值作为最终答案。", "solution": "问题要求我们对给定的三地址码片段执行非常忙碌表达式分析。在某个程序点上的一个非常忙碌表达式，是指从该点出发的每条路径上都会被求值，并且在其任何组成变量被重新定义之前求值的表达式。这是一种后向、交集（必须）数据流分析。\n\n首先，我们确定候选表达式的全集，该全集被指定为不同的、非临时变量的二元加法的集合。检查中间表示（IR），我们找到以下表达式：\n- 在基本块 $B_2$ 中：$a+b$\n- 在基本块 $B_3$ 中：$a+b$\n- 在基本块 $B_4$ 中：$a+b$ 和 $a+c$\n\n因此，构成我们全集 $U$ 的不同表达式的集合是 $U = \\{a+b, a+c\\}$。\n\n该分析由每个基本块 $B$ 的以下数据流方程控制：\n$$VB_{out}[B] = \\bigcap_{S \\in \\text{Succ}(B)} VB_{in}[S]$$\n$$VB_{in}[B] = Gen[B] \\cup (VB_{out}[B] - Kill[B])$$\n其中 $VB_{in}[B]$ 和 $VB_{out}[B]$ 分别是在基本块 $B$ 入口和出口处的非常忙碌表达式集合。Succ($B$) 是 $B$ 的后继基本块集合。\n\n集合 $Gen[B]$ 和 $Kill[B]$ 定义如下：\n- $Kill[B]$：全集 $U$ 中被该基本块“杀死”的表达式集合。如果一个表达式的任何操作数变量在基本块 $B$ 内被赋予新值，则该表达式被杀死。\n- $Gen[B]$：全集 $U$ 中被该基本块“生成”的表达式集合。如果一个表达式在 $B$ 中被求值，并且在求值之前它的任何操作数都未在 $B$ 中被重新定义，则该表达式被生成。\n\n我们现在为每个基本块计算这些集合：\n\n基本块 $B_1$：\n1. $t_0 := d  0$\n2. if $t_0$ goto $B_2$ else goto $B_3$\n没有对变量 $a$、 $b$ 或 $c$ 进行赋值。没有对 $U$ 中的表达式进行求值。\n$Kill[B_1] = \\emptyset$\n$Gen[B_1] = \\emptyset$\n\n基本块 $B_2$：\n3. $t_1 := a + b$\n4. $a := a - c$\n5. $t_4 := a + b$\n第 4 行对 $a$ 的赋值会杀死所有包含 $a$ 的表达式。\n$Kill[B_2] = \\{a+b, a+c\\}$\n表达式 $a+b$ 在第 3 行被求值。在此行之前，$a$ 和 $b$ 在 $B_2$ 中都没有被重新定义。因此，$a+b$ 被生成。表达式 $a+b$ 也在第 5 行被求值，但这发生在第 4 行 $a$ 被重新定义之后，所以这次求值不计入 $Gen[B_2]$。\n$Gen[B_2] = \\{a+b\\}$\n\n基本块 $B_3$：\n7. $t_2 := a + b$\n8. $b := b - c$\n9. $t_5 := a + b$\n第 8 行对 $b$ 的赋值会杀死所有包含 $b$ 的表达式。\n$Kill[B_3] = \\{a+b\\}$\n表达式 $a+b$ 在第 7 行被求值。在此行之前，$a$ 和 $b$ 在 $B_3$ 中都没有被重新定义。因此，$a+b$ 被生成。第 9 行的求值发生在 $b$ 被重新定义之后，所以它不计入 $Gen[B_3]$。\n$Gen[B_3] = \\{a+b\\}$\n\n基本块 $B_4$：\n11. $t_6 := a + b$\n12. $t_7 := a + c$\n13. return $t_6$\n没有对 $a$、 $b$ 或 $c$ 进行赋值。\n$Kill[B_4] = \\emptyset$\n$a+b$ 和 $a+c$ 都被求值，并且它们的操作数在块内没有被重新定义。\n$Gen[B_4] = \\{a+b, a+c\\}$\n\n控制流图由以下给出：\nSucc($B_1$) = {$B_2, B_3$}\nSucc($B_2$) = {$B_4$}\nSucc($B_3$) = {$B_4$}\nSucc($B_4$) = {Exit}\n\n边界条件是在过程出口处没有非常忙碌的表达式：$VB_{in}[\\text{Exit}] = \\emptyset$。\n对于交集（必须）分析，我们将所有其他块的集合初始化为全集 $U = \\{a+b, a+c\\}$。然后我们进行迭代，直到达到不动点。以逆拓扑顺序（$B_4, B_3, B_2, B_1$）处理基本块可以加快收敛速度。\n\n初始化：\n$VB_{in}[B_1] = VB_{in}[B_2] = VB_{in}[B_3] = VB_{in}[B_4] = U = \\{a+b, a+c\\}$\n$VB_{out}[B_1] = VB_{out}[B_2] = VB_{out}[B_3] = VB_{out}[B_4] = U = \\{a+b, a+c\\}$\n\n迭代 1：\n1.  基本块 $B_4$：\n    $VB_{out}[B_4] = VB_{in}[\\text{Exit}] = \\emptyset$。\n    $VB_{in}[B_4] = Gen[B_4] \\cup (VB_{out}[B_4] - Kill[B_4]) = \\{a+b, a+c\\} \\cup (\\emptyset - \\emptyset) = \\{a+b, a+c\\}$。\n\n2.  基本块 $B_2$：\n    $VB_{out}[B_2] = VB_{in}[B_4] = \\{a+b, a+c\\}$。\n    $VB_{in}[B_2] = Gen[B_2] \\cup (VB_{out}[B_2] - Kill[B_2]) = \\{a+b\\} \\cup (\\{a+b, a+c\\} - \\{a+b, a+c\\}) = \\{a+b\\} \\cup \\emptyset = \\{a+b\\}$。\n\n3.  基本块 $B_3$：\n    $VB_{out}[B_3] = VB_{in}[B_4] = \\{a+b, a+c\\}$。\n    $VB_{in}[B_3] = Gen[B_3] \\cup (VB_{out}[B_3] - Kill[B_3]) = \\{a+b\\} \\cup (\\{a+b, a+c\\} - \\{a+b\\}) = \\{a+b\\} \\cup \\{a+c\\} = \\{a+b, a+c\\}$。\n\n4.  基本块 $B_1$：\n    $VB_{out}[B_1] = VB_{in}[B_2] \\cap VB_{in}[B_3] = \\{a+b\\} \\cap \\{a+b, a+c\\} = \\{a+b\\}$。\n    $VB_{in}[B_1] = Gen[B_1] \\cup (VB_{out}[B_1] - Kill[B_1]) = \\emptyset \\cup (\\{a+b\\} - \\emptyset) = \\{a+b\\}$。\n\n在第一次迭代结束时，集合为：\n$VB_{in}[B_1] = \\{a+b\\}$\n$VB_{in}[B_2] = \\{a+b\\}$\n$VB_{in}[B_3] = \\{a+b, a+c\\}$\n$VB_{in}[B_4] = \\{a+b, a+c\\}$\n\n迭代 2：\n我们使用迭代 1 结束时的值重复该过程。\n1.  基本块 $B_4$：$VB_{out}[B_4]$ 仍然是 $\\emptyset$，所以 $VB_{in}[B_4]$ 保持为 $\\{a+b, a+c\\}$。无变化。\n2.  基本块 $B_2$：$VB_{out}[B_2]$ 仍然是 $VB_{in}[B_4] = \\{a+b, a+c\\}$，所以 $VB_{in}[B_2]$ 保持为 $\\{a+b\\}$。无变化。\n3.  基本块 $B_3$：$VB_{out}[B_3]$ 仍然是 $VB_{in}[B_4] = \\{a+b, a+c\\}$，所以 $VB_{in}[B_3]$ 保持为 $\\{a+b, a+c\\}$。无变化。\n4.  基本块 $B_1$：$VB_{out}[B_1]$ 是 $VB_{in}[B_2] \\cap VB_{in}[B_3] = \\{a+b\\} \\cap \\{a+b, a+c\\} = \\{a+b\\}$。这与之前对 $VB_{out}[B_1]$ 的计算结果没有变化。因此，$VB_{in}[B_1]$ 保持为 $\\{a+b\\}$。无变化。\n\n由于在第二次迭代期间没有集合发生变化，算法已达到不动点。在基本块 $B_1$ 入口处的最终非常忙碌表达式集合是 $VB_{in}[B_1] = \\{a+b\\}$。\n\n问题要求的是在基本块 $B_1$ 入口处非常忙碌的不同候选表达式的数量。这是集合 $VB_{in}[B_1]$ 的基数。\n$$|VB_{in}[B_1]| = |\\{a+b\\}| = 1$$\n因此，在基本块 $B_1$ 入口处有 $1$ 个不同的表达式是非常忙碌的。", "answer": "$$\\boxed{1}$$", "id": "3682446"}]}