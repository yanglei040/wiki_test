{"hands_on_practices": [{"introduction": "要真正掌握常量传播与折叠，最好的方法莫过于亲手追踪编译器的优化过程。这个练习将通过一个简单的算术赋值链，展示常量传播与折叠的核心机制。它旨在强调，编译器必须严格遵循目标机器的运算规则（例如本例中的32位二进制补码整数运算）来执行计算，以确保优化后的程序与原始程序的行为完全一致。[@problem_id:3631667]", "problem": "一个编译器优化遍对一个类型化的中间表示中的一个简单的三赋值片段执行常量传播和常量折叠。目标机器模型使用具有回绕语义的 $32$ 位二进制补码整数，这意味着对 $32$ 位值的算术运算是按模 $2^{32}$ 计算，然后通过二进制补码表示解释为范围 $[-2^{31}, 2^{31}-1]$ 内的值。除非是在模 $2^{32}$ 算术中的等价变换，否则不得使用任何改变求值顺序或依赖于在模算术下不被保留的性质（例如在潜在溢出下的无限制结合律或分配律）的代数变换。\n\n考虑以下片段：\n- $a \\leftarrow 2$\n- $b \\leftarrow a + 3$\n- $c \\leftarrow b \\times 4$\n\n仅使用在指定的 $32$ 位二进制补码回绕语义下的常量传播（替换已知常量值）和常量折叠（对操作数为编译时常量的表达式进行积极求值）原则，赋给 $c$ 的最终常量值是多少？请用一个十进制整数表示你的答案。无需四舍五入。", "solution": "我们从 $n$ 位二进制补码算术的基本定义开始。对于 $n = 32$，整数算术是按模 $2^{32}$ 执行的。每个运算 $+$ 和 $\\times$ 都被作为环 $\\mathbb{Z}/2^{32}\\mathbb{Z}$ 上的运算来求值，产生一个在 $\\{0,1,\\dots,2^{32}-1\\}$ 中的余数，然后通过二进制补码双射将其解释为范围 $[-2^{31}, 2^{31}-1]$ 内的有符号值。在这些语义下，常量折叠是保持语义的，因为在 $\\mathbb{Z}/2^{32}\\mathbb{Z}$ 中对带有编译时常量的表达式求值，会产生与运行时求值相同的剩余类。\n\n该优化遍应用了两个核心变换：\n- 常量传播：如果一个变量已知持有一个常量值，则在后续表达式中用该常量替换该变量。\n- 常量折叠：如果一个表达式的操作数是常量，则在编译时使用机器算术语义（此处为模 $2^{32}$ 运算）对该表达式进行求值。\n\n我们将这些逐步应用于给定的片段。\n\n步骤 $1$：赋值语句 $a \\leftarrow 2$ 将 $a$ 绑定到常量值 $2$。在 $\\mathbb{Z}/2^{32}\\mathbb{Z}$ 中，这只是 $2$ 的剩余类。\n\n步骤 $2$：对于 $b \\leftarrow a + 3$，常量传播将 $a$ 替换为 $2$，得到 $b \\leftarrow 2 + 3$。然后，常量折叠在模 $2^{32}$ 算术下对加法进行求值：\n$$\n2 + 3 \\equiv 5 \\pmod{2^{32}}.\n$$\n由于 $5$ 位于 $[0, 2^{32}-1]$ 内，并且也位于有符号范围 $[-2^{31}, 2^{31}-1]$ 内，它表示有符号整数 $5$。因此 $b$ 是常量 $5$。\n\n步骤 $3$：对于 $c \\leftarrow b \\times 4$，常量传播将 $b$ 替换为 $5$，得到 $c \\leftarrow 5 \\times 4$。常量折叠在模 $2^{32}$ 下对乘法进行求值：\n$$\n5 \\times 4 \\equiv 20 \\pmod{2^{32}}.\n$$\n同样，$20$ 同时位于无符号余数范围和有符号可表示范围内，因此它对应于有符号整数 $20$。所以，$c$ 是常量 $20$。\n\n我们强调，除了直接求值外，没有要求或使用任何代数重组；计算通过按书面形式执行操作并使用模 $2^{32}$ 算术就地折叠它们，从而遵守了指定的语义。因为所有中间结果 $2$、$5$ 和 $20$ 都严格在安全有符号范围 $[-2^{31}, 2^{31}-1]$ 内，所以在这个特定序列中没有发生回绕，但即使发生了回绕，在给定模型下，模 $2^{32}$ 的折叠仍然会与运行时求值相匹配。\n\n因此，经过常量传播和常量折叠后，赋给 $c$ 的最终常量值是 $20$。", "answer": "$$\\boxed{20}$$", "id": "3631667"}, {"introduction": "在掌握了基本原理之后，让我们来探索一个涉及位运算的更复杂的场景。这个实践将展示常量传播不仅仅是为了预先计算数值，它更是其他强大优化的关键“催化剂”，例如死代码消除。通过在编译时确定条件语句的结果，编译器能够极大地简化程序的控制流，从而生成更小、更快的代码。[@problem_id:3631632]", "problem": "考虑一个用于简单命令式语言的一阶、流不敏感的优化管道，该语言包含对无符号整数的位运算符和条件分支。该管道执行常量折叠和常量传播，然后进行死分支消除。您可以使用的基本基础包括以下核心定义和事实：\n\n1. 对无符号整数的位运算符是按位操作的：对于每个比特位，按位与（AND）返回合取，按位或（OR）返回析取，按位异或（XOR）返回奇偶性，按位非（NOT）翻转该位。形式上，如果 $u$ 和 $v$ 是无符号整数，那么：\n   - 在 $u$ 和 $v$ 均为 $1$ 的比特位上，$(u \\ \\ \\ v)$ 的对应位为 $1$。\n   - 在 $u$ 或 $v$ 至少有一个为 $1$ 的比特位上，$(u \\ | \\ v)$ 的对应位为 $1$。\n   - 在 $u$ 或 $v$ 恰好有一个为 $1$ 的比特位上，$(u \\oplus v)$ 的对应位为 $1$。\n   - $(\\sim u)$ 的每一位都是 $u$ 相应位的补。\n   - 移位操作 $u \\ll k$ 和 $u \\gg k$ 将 $u$ 的比特模式向左或向右移动 $k$ 位，并用零填充。\n\n2. 常量折叠（Constant folding）将操作数均为编译时常量的任何运算符应用求值为一个编译时常量结果。常量传播（Constant propagation）将已知的变量常量值替换到其使用点。\n\n3. 在这种语言中，当且仅当测试值等于 $0$ 时，分支条件的求值结果为假，否则为真。死分支消除（Dead branch elimination）会移除在编译时确定其条件为假的分支。\n\n假设所有对变量 $x$、$a$、$b$、$c$ 和 $d$ 的位运算都是在无符号 $8$ 位整数上进行的，采用模 $256$ 算术；特别地，$\\sim$ 是 $8$ 位按位取反，任何以十六进制书写的常量都根据需要隐式地屏蔽为 $8$ 位。累加器 $s$ 的求和是作为精确的数学整数加法（而非模算术）执行的。考虑以下使用位运算符 $ \\ $ (AND)、$ | $ (OR)、$\\oplus$ (exclusive OR)、$\\sim$ (NOT) 和 $\\ll$ (left shift) 书写的序列：\n\n- $x \\leftarrow \\mathtt{0xF0}$。\n- $a \\leftarrow x \\ \\ \\ \\mathtt{0x0F}$。\n- $b \\leftarrow \\bigl(x \\ | \\ \\mathtt{0x0F}\\bigr) \\ \\ \\ \\mathtt{0xFF}$。\n- $c \\leftarrow \\bigl( (a \\ll 2) \\ | \\ (x \\ \\ \\ \\mathtt{0x03}) \\bigr)$。\n- $d \\leftarrow \\bigl( (\\sim x) \\ \\ \\ \\mathtt{0xFF} \\bigr) \\ \\ \\ \\mathtt{0x0F}$。\n- $s \\leftarrow 1$。\n- 如果 $\\bigl( (x \\ \\ \\ \\mathtt{0x0F}) \\neq 0 \\bigr)$ 或 $(a \\neq 0)$，则设置 $s \\leftarrow s + 100$，否则设置 $s \\leftarrow s + b$，然后：\n  - 如果 $(c \\neq 0)$，则设置 $s \\leftarrow s + 1000$，否则设置 $s \\leftarrow s + d$。\n- 最后，返回 $s + \\bigl( (x \\oplus \\mathtt{0xAA}) \\ \\ \\ \\mathtt{0x0F} \\bigr)$。\n\n彻底应用常量折叠和常量传播，然后消除在给定语义下变得不可达的任何死分支。最终返回的整数是多少？请用一个精确的整数表示你的答案，不带单位。不需要四舍五入。", "solution": "任务是通过对给定的操作序列应用常量折叠、常量传播和死分支消除来确定最终返回的整数值。所有操作都在无符号 $8$ 位整数上执行。我们将按顺序评估每个步骤，并在确定常量值后进行传播。\n\n首先，我们将给定的十六进制常量表示为其 $8$ 位二进制形式：\n- $\\mathtt{0xF0} = 11110000_2$\n- $\\mathtt{0x0F} = 00001111_2$\n- $\\mathtt{0xFF} = 11111111_2$\n- $\\mathtt{0x03} = 00000011_2$\n- $\\mathtt{0xAA} = 10101010_2$\n\n优化过程如下：\n\n1.  $x \\leftarrow \\mathtt{0xF0}$。\n    变量 $x$ 被赋予常量值 $\\mathtt{0xF0}$，十进制为 $240$。该值将被传播到所有后续对 $x$ 的使用中。\n\n2.  $a \\leftarrow x \\ \\ \\ \\mathtt{0x0F}$。\n    由于 $x$ 是编译时常量，此表达式可以被折叠。\n    $$a = \\mathtt{0xF0} \\ \\ \\ \\mathtt{0x0F} = 11110000_2 \\ \\ \\ 00001111_2 = 00000000_2$$\n    因此，$a$ 被赋予常量值 $\\mathtt{0x00}$，十进制为 $0$。\n\n3.  $b \\leftarrow \\bigl(x \\ | \\ \\mathtt{0x0F}\\bigr) \\ \\ \\ \\mathtt{0xFF}$。\n    此表达式仅涉及常量，可以被折叠。\n    $$x \\ | \\ \\mathtt{0x0F} = 11110000_2 \\ | \\ 00001111_2 = 11111111_2 = \\mathtt{0xFF}$$\n    $$b = \\mathtt{0xFF} \\ \\ \\ \\mathtt{0xFF} = 11111111_2 = \\mathtt{0xFF}$$\n    因此，$b$ 被赋予常量值 $\\mathtt{0xFF}$，十进制为 $255$。\n\n4.  $c \\leftarrow \\bigl( (a \\ll 2) \\ | \\ (x \\ \\ \\ \\mathtt{0x03}) \\bigr)$。\n    我们将 $a$ 和 $x$ 的常量值传播到表达式中。\n    - 或运算的左半部分是 $(a \\ll 2)$。由于 $a=0$，我们有 $0 \\ll 2 = 0$。\n    - 右半部分是 $(x \\ \\ \\ \\mathtt{0x03})$。由于 $x=\\mathtt{0xF0}$，我们有：\n    $$x \\ \\ \\ \\mathtt{0x03} = 11110000_2 \\ \\ \\ 00000011_2 = 00000000_2 = 0$$\n    - 组合这两个部分得到：\n    $$c = 0 \\ | \\ 0 = 0$$\n    因此，$c$ 被赋予常量值 $0$。\n\n5.  $d \\leftarrow \\bigl( (\\sim x) \\ \\ \\ \\mathtt{0xFF} \\bigr) \\ \\ \\ \\mathtt{0x0F}$。\n    可以使用 $x$ 的常量值折叠此表达式。操作 $\\sim x$ 是一个 $8$ 位按位非。对于 $8$ 位类型，` 0xFF` 操作是多余的，但为了完整性我们对其进行求值。\n    $$\\sim x = \\sim 11110000_2 = 00001111_2 = \\mathtt{0x0F}$$\n    $$(\\sim x) \\ \\ \\ \\mathtt{0xFF} = \\mathtt{0x0F} \\ \\ \\ \\mathtt{0xFF} = \\mathtt{0x0F}$$\n    $$d = \\mathtt{0x0F} \\ \\ \\ \\mathtt{0x0F} = \\mathtt{0x0F}$$\n    因此，$d$ 被赋予常量值 $\\mathtt{0x0F}$，十进制为 $15$。\n\n6.  $s \\leftarrow 1$。\n    累加器 $s$ 初始化为值 $1$。\n\n7.  接下来，我们分析第一个条件语句：`如果 \\(\\bigl( (x \\ \\ \\ \\mathtt{0x0F}) \\neq 0 \\bigr)\\) 或 \\((a \\neq 0)\\)，则...`\n    使用传播的 $x$ 和 $a$ 的常量值来评估条件。\n    - `or` 的左侧是 $(x \\ \\ \\ \\mathtt{0x0F}) \\neq 0$。我们已经在步骤2中计算出 $x \\ \\ \\ \\mathtt{0x0F} = 0$。该条件变为 $0 \\neq 0$，结果为假。\n    - `or` 的右侧是 $a \\neq 0$。我们已经在步骤2中计算出 $a=0$。该条件变为 $0 \\neq 0$，结果为假。\n    - 完整的条件是 $(\\text{假}) \\lor (\\text{假})$，其求值结果为假。\n    根据死分支消除的原则，`then` 块 ($s \\leftarrow s + 100$) 是不可达的，因此被消除。`else` 块 ($s \\leftarrow s + b$) 总是被执行。\n    $s$ 的值被更新：\n    $$s \\leftarrow s + b = 1 + 255 = 256$$\n\n8.  我们继续分析第二个条件语句：`如果 \\((c \\neq 0)\\)，则...`\n    使用传播的值 $c=0$ 来评估条件。\n    - 条件是 $c \\neq 0$，变为 $0 \\neq 0$。这是假。\n    再次应用死分支消除。`then` 块 ($s \\leftarrow s + 1000$) 被消除，`else` 块 ($s \\leftarrow s + d$) 被执行。\n    $s$ 的值再次被更新，使用 $s$ 的当前值 ($256$) 和 $d$ 的常量值 ($15$)：\n    $$s \\leftarrow s + d = 256 + 15 = 271$$\n\n9.  最后，我们评估返回表达式：$s + \\bigl( (x \\oplus \\mathtt{0xAA}) \\ \\ \\ \\mathtt{0x0F} \\bigr)$。\n    $s$ 的当前值是 $271$。我们折叠括号中的常量表达式。\n    - 首先，我们计算 $x \\oplus \\mathtt{0xAA}$：\n    $$x \\oplus \\mathtt{0xAA} = 11110000_2 \\oplus 10101010_2 = 01011010_2 = \\mathtt{0x5A}$$\n    - 接下来，我们计算与 $\\mathtt{0x0F}$ 的按位与：\n    $$\\mathtt{0x5A} \\ \\ \\ \\mathtt{0x0F} = 01011010_2 \\ \\ \\ 00001111_2 = 00001010_2 = \\mathtt{0x0A}$$\n    $\\mathtt{0x0A}$ 的十进制值是 $10$。\n    最终返回的值是这个和：\n    $$\\text{返回值} = s + 10 = 271 + 10 = 281$$\n\n在应用了指定的优化之后，代码被简化为一系列常量赋值和加法，从而得出一个单一的确定性结果。", "answer": "$$\\boxed{281}$$", "id": "3631632"}, {"introduction": "任何编译器优化的一个关键原则是“健全性”——即优化绝不能改变程序的可观察行为。最后的这个练习将深入探讨这一原则，通过一个包含潜在运行时错误的表达式，来检验我们的理解。它突出了一个正确实现的优化器必须如何尊重语言的语义规则（如此处的布尔表达式短路求值），以避免引入原始代码中本不会发生的错误。[@problem_id:3631626]", "problem": "一个编译器在中间表示（IR）上执行常量传播和常量折叠，同时遵循短路布尔语义和异常行为。考虑一个具有从左到右求值和析取短路语义的表达式：对于析取 $A \\lor B$，如果 $A$ 的值为 $\\mathrm{true}$，则 $B$ 不会被求值。在整数算术中，当且仅当除法操作在运行时被实际求值时，除以零会引发一个运行时异常。常量传播将已知为常量的变量替换为其值，而常量折叠则对完全由常量组成的表达式进行求值。\n\n给定一个包含整型变量 $x$ 和 $y$ 的程序状态，其中已知 $x$ 在编译时满足 $x = 0$，$y$ 在编译时未知。考虑以下从左到右求值的 IR 级计算序列：\n\n1. 计算布尔值 $C := (x == 0) \\lor \\left(\\frac{y}{x} > 2\\right)$。\n2. 如果 $C$ 为 $\\mathrm{true}$，则赋值 $a := y + 5$；否则赋值 $a := x - 3$。\n3. 赋值 $z := a - y$。\n\n在编译器必须保留短路语义和异常行为（特别地，在源语义不会对 $\\frac{y}{x}$ 求值的任何执行中，编译器都不能引入对它的求值）的约束下，对该序列应用常量传播和常量折叠。在优化后的程序中，$z$ 的确切最终值是多少？请提供确切的整数值；无需四舍五入，也无单位。", "solution": "该问题要求对给定的中间表示（IR）指令序列应用常量传播和常量折叠这两种编译器优化，同时严格遵守语言指定的语义，特别是逻辑析取的短路求值和保留除零操作的异常行为。\n\n初始状态表明，整型变量 $x$ 在编译时已知其值为 $0$，而整型变量 $y$ 在编译时是未知的。操作序列按从左到右的顺序求值。\n\n让我们分析计算序列的每一步：\n\n1.  **计算 $C := (x == 0) \\lor \\left(\\frac{y}{x} > 2\\right)$**\n\n    编译器首先尝试优化布尔变量 $C$ 的表达式。该表达式是一个逻辑析取（OR），它遵循短路语义。这意味着如果左操作数的值为 $\\mathrm{true}$，则右操作数不会被求值。\n\n    左操作数是 $(x == 0)$。\n    通过常量传播，编译器将变量 $x$ 替换为其已知的编译时值 $0$。表达式变为 $(0 == 0)$。\n    通过常量折叠，编译器对这个常量表达式求值。比较 $(0 == 0)$ 的结果是 $\\mathrm{true}$。\n\n    因此，$C$ 的原始表达式在编译时被简化为 $C := \\mathrm{true} \\lor \\left(\\frac{y}{x} > 2\\right)$。\n\n    根据析取的短路求值规则，由于左操作数为 $\\mathrm{true}$，整个析取表达式的结果为 $\\mathrm{true}$，而右操作数 $\\left(\\frac{y}{x} > 2\\right)$ **不会被求值**。这是关键的一点。问题指出编译器必须保留异常行为。对右操作数的简单求值会涉及代入 $x = 0$，导致表达式 $\\frac{y}{0}$，这将引发一个除零异常。通过正确实现短路语义，编译器避免了在原始未优化程序中不会发生的情况下引入此异常。\n\n    因此，编译器可以将 $C$ 的整个表达式折叠为常量值 $\\mathrm{true}$。第一条指令被优化掉，并被 $C$ 为 $\\mathrm{true}$ 这一判定所取代。\n\n2.  **如果 $C$ 为 $\\mathrm{true}$，则赋值 $a := y + 5$；否则赋值 $a := x - 3$。**\n\n    编译器已经确定条件 $C$ 总是为 $\\mathrm{true}$。因此，条件分支可以在编译时被解析。\n    `if` 分支，$a := y + 5$，总是会被执行。\n    `else` 分支，$a := x - 3$，是不可达的，构成了死代码。编译器将消除它。\n\n    该操作简化为无条件赋值 $a := y + 5$。\n    由于 $y$ 的值在编译时未知，此表达式不能被折叠成一个常量。然而，编译器现在知道 $a$ 的值由表达式 $y + 5$ 表示。\n\n3.  **赋值 $z := a - y$。**\n\n    这是最后一步。编译器使用从上一步推导出的信息。它知道 $a$ 等价于 $y + 5$。\n    使用常量（或在本例中为表达式）传播，编译器将 $a$ 的表达式代入此赋值语句中：\n    $z := (y + 5) - y$。\n\n    然后编译器可以对此表达式进行代数化简。\n    $z := y + 5 - y$\n    涉及未知变量 $y$ 的项相互抵消：$y - y = 0$。\n    $z$ 的表达式简化为：\n    $z := 5$。\n\n    编译器成功地确定，尽管存在未知变量 $y$，但 $z$ 的最终值始终是常量 $5$。整个计算序列被优化为单个赋值语句：$z := 5$。\n\n因此，在优化后的程序中，$z$ 的确切最终值为 $5$。", "answer": "$$\\boxed{5}$$", "id": "3631626"}]}