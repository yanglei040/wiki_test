{"hands_on_practices": [{"introduction": "任何编译器优化都存在权衡。去虚拟化并非没有代价，它会引入额外的开销（例如类型检查或“守卫”）。本练习旨在帮助您将这种权衡形式化，通过建立一个简单的成本效益模型，您将能够量化地判断去虚拟化在何时是有效的，并理解其对性能剖析数据准确性的敏感性 [@problem_id:3637422]。", "problem": "一个编译器正在考虑对一门面向对象语言中的多态调用点进行去虚拟化。在基线情况下，调用通过虚拟分派执行，其每次调用的延迟是一个常数 $c_{indirect}$ 个周期。在去虚拟化的情况下，编译器会插入一个在每次调用时执行的运行时类型守卫。如果预测的热点接收者类存在，则执行直接调用；否则，回退到原始的间接调用。假设一个基于全期望定律和以下基本事实的线性期望成本模型：直接调用的延迟是一个常数 $c_{direct}$ 个周期；类型守卫在每次调用时都会产生一个常数 $c_{guard}$ 个周期的开销；热点接收者情况出现的概率为 $p_{hot}$。从这些基本原理出发，推导出去虚拟化相对于基线的每次调用的期望性能增益 $g$ 的表达式。\n\n对于一个特定的调用点，测量得到 $c_{indirect} = 17$ 个周期，$c_{direct} = 4$ 个周期，以及 $c_{guard} = 3$ 个周期。一次剖析引导优化 (PGO) 运行估计 $p_{hot}$ 为 $p_{hot}^{est} = 0.88$，但随后在即时 (JIT) 编译器中的一次运行时采样显示，真实的热点情况概率为 $p_{hot}^{true} = 0.786$。\n\n任务：\n- 使用推导出的 $g$ 的表达式，计算在估计概率下的期望增益 $g^{est}$ 和在真实概率下的期望增益 $g^{true}$。\n- 推导出一阶灵敏度 $\\frac{\\partial g}{\\partial p_{hot}}$，并用它来量化 $g$ 如何随着对 $p_{hot}$ 的错误估计而变化。\n- 报告期望增益的绝对误差 $|g^{true} - g^{est}|$，单位为周期。将你报告的答案四舍五入到四位有效数字，并以周期为单位表示。", "solution": "基线情况下，每次调用的期望成本是 $c_{indirect}$，因为每个调用都是间接分派的。在去虚拟化的情况下，运行时类型守卫在每次调用时执行，并产生一个常数 $c_{guard}$ 个周期的开销。有 $p_{hot}$ 的概率，会以成本 $c_{direct}$ 进行直接调用；有 $1 - p_{hot}$ 的概率，会以成本 $c_{indirect}$ 进行间接调用。根据全期望定律和期望的线性性质，去虚拟化后的期望成本为\n$$\n\\text{Cost}_{\\text{devirt}} = c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}.\n$$\n每次调用的期望增益 $g$ 是基线成本减去去虚拟化后的成本：\n$$\ng = c_{indirect} - \\left(c_{guard} + p_{hot}\\,c_{direct} + (1 - p_{hot})\\,c_{indirect}\\right).\n$$\n代数化简此表达式：\n\n$$\n\\begin{aligned}\ng = c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - (1 - p_{hot})\\,c_{indirect} \\\\\n  = c_{indirect} - c_{guard} - p_{hot}\\,c_{direct} - c_{indirect} + p_{hot}\\,c_{indirect} \\\\\n  = p_{hot}\\,(c_{indirect} - c_{direct}) - c_{guard}.\n\\end{aligned}\n$$\n\n这就是从基本期望值推理得出的期望增益模型。\n\n接下来，计算在估计概率和真实概率下的期望增益。使用 $c_{indirect} = 17$，$c_{direct} = 4$ 和 $c_{guard} = 3$，我们得到 $c_{indirect} - c_{direct} = 17 - 4 = 13$。\n\n对于估计值 $p_{hot}^{est} = 0.88$，\n\n$$\ng^{est} = p_{hot}^{est}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.88 \\cdot 13 - 3 = 11.44 - 3 = 8.44.\n$$\n\n\n对于真实概率 $p_{hot}^{true} = 0.786$，\n\n$$\ng^{true} = p_{hot}^{true}\\,(c_{indirect} - c_{direct}) - c_{guard} = 0.786 \\cdot 13 - 3 = 10.218 - 3 = 7.218.\n$$\n\n\n由于错误估计导致的期望增益的绝对误差是\n\n$$\n|g^{true} - g^{est}| = |7.218 - 8.44| = | -1.222| = 1.222.\n$$\n\n\n为了分析灵敏度，对 $g$ 关于 $p_{hot}$ 求导：\n\n$$\n\\frac{\\partial g}{\\partial p_{hot}} = c_{indirect} - c_{direct}.\n$$\n\n因此，对于一个小的变化 $\\Delta p_{hot}$，$g$ 的一阶变化近似为\n\n$$\n\\Delta g \\approx \\frac{\\partial g}{\\partial p_{hot}} \\,\\Delta p_{hot} = (c_{indirect} - c_{direct})\\,\\Delta p_{hot}.\n$$\n\n因为 $g$ 是 $p_{hot}$ 的精确线性函数，所以这个一阶近似对于任何 $\\Delta p_{hot}$ 都是精确的：\n\n$$\ng(p_{hot}^{true}) - g(p_{hot}^{est}) = (c_{indirect} - c_{direct})\\,(p_{hot}^{true} - p_{hot}^{est}).\n$$\n\n这里，$\\Delta p_{hot} = p_{hot}^{true} - p_{hot}^{est} = 0.786 - 0.88 = -0.094$，所以\n\n$$\n|g^{true} - g^{est}| = |(c_{indirect} - c_{direct})\\,\\Delta p_{hot}| = |13 \\cdot (-0.094)| = 1.222.\n$$\n\n\n四舍五入到四位有效数字并以周期为单位表示，绝对误差为 $1.222$ 个周期。", "answer": "$$\\boxed{1.222}$$", "id": "3637422"}, {"introduction": "在确定了去虚拟化的潜在收益后，接下来的问题是编译器如何*证明*这种优化是安全的。这需要复杂的静态分析技术。本练习将挑战您像编译器一样思考，通过分析一段 Java 代码，您将识别出要在一个调用点准确推断对象类型所需的程序分析组合，例如类层次结构分析和常量传播 [@problem_id:3637449]。", "problem": "一个用于 Java 编程语言的优化编译器，当它能够在调用点证明接收者的动态类型时，会通过特化虚调用的方式应用去虚拟化技术。考虑以下小型 Java 程序，它使用了一个用于区分不同子类的 final 字段和一个枚举，而不是使用数字标签：\n\n```java\nenum Tag { CONST, ADD }\nabstract class Node {\n  final Tag tag;\n  Node(Tag t) { this.tag = t; }\n  abstract int eval();\n}\nfinal class Const extends Node {\n  final int value;\n  Const(int v) { super(Tag.CONST); this.value = v; }\n  int eval() { return value; }\n}\nfinal class Add extends Node {\n  final Node l, r;\n  Add(Node l, Node r) { super(Tag.ADD); this.l = l; this.r = r; }\n  int eval() { return l.eval() + r.eval(); }\n}\nclass Factory {\n  static Node mk(boolean b, int v) {\n    if (b) return new Const(v);\n    else return new Add(new Const(v), new Const(v));\n  }\n}\nclass Use {\n  static int run(boolean b, int v) {\n    Node n = Factory.mk(b, v);\n    if (n.tag == Tag.CONST) {\n      return ((Const) n).eval();\n    } else {\n      return n.eval();\n    }\n  }\n}\n```\n\n假设编译器采用：\n- 稀疏条件常量传播 (SCCP; 一种在控制流图中传播常量值的数据流分析)，\n- 类层次结构分析 (CHA; 一种限定可能的动态接收者类的集合的静态分析)，\n- 指向分析 (一种别名分析，用于在程序的控制流下追踪引用变量 $n$ 可能指向哪些分配点)，以及\n- Java 语言规范中关于 final 字段的语义 (final 字段在构造期间被赋值，并且在安全发布的明确定义条件下，之后不会被修改)。\n\n从动态分派（一种基于运行时接收者对象的动态类型的方法调用解析）、数据流常量传播（对常量值的流敏感推断）和别名分析（对引用及其突变的推理）的基本定义出发，且不假设任何特殊情况的公式，确定以下哪个假设集合足以让编译器 (i) 将 final 字段值 $tag$ 从对象的分配点传播到分支，(ii) 确立分支条件 $n.tag == \\mathrm{Tag.CONST}$ 意味着在 then-分支中接收者的确切动态类型是 $\\mathrm{Const}$，在 else-分支中是 $\\mathrm{Add}$，并因此 (iii) 将调用编译为对 $\\mathrm{Const.eval}$ 和 $\\mathrm{Add.eval}$ 的直接调用，而无需运行时守卫。\n\n选择唯一的最佳选项。\n\nA. 字段 $tag$ 被声明为 final，并且仅在每个子类的构造函数中被赋值为一个唯一的枚举常量（对于 $\\mathrm{Const}$ 是 $\\mathrm{Tag.CONST}$，对于 $\\mathrm{Add}$ 是 $\\mathrm{Tag.ADD}$）；类 $\\mathrm{Const}$ 和 $\\mathrm{Add}$ 被声明为 final；不存在对 $tag$ 的反射或低级写入（例如，通过 $\\texttt{java.lang.reflect}$ 或 $\\texttt{sun.misc.Unsafe}$）；指向分析证明了调用点的接收者 $n$ 来自 $\\mathrm{Const}$ 或 $\\mathrm{Add}$ 的构造函数；类层次结构分析 (CHA) 遵循封闭世界假设，因此不可能有 $\\mathrm{Node}$ 的其他子类。在这些条件下，SCCP 可以传播 $tag$ 的值，从 $tag$ 到子类的映射在可达的分配点之间是单射的，并且去虚拟化为直接调用是可靠的，无需运行时守卫。\n\nB. 仅将 $tag$ 声明为 final 就足够了；既不需要别名分析也不需要类层次结构分析，并且反射更新或动态类加载不影响去虚拟化的可靠性。\n\nC. 逃逸分析证明了 $n$ 没有逃逸出方法 $\\mathrm{Use.run}$；因此，编译器可以无条件地将虚调用替换为直接调用目标，而不管 $tag$ 的值。\n\nD. 编译器将检查 $n.tag == \\mathrm{Tag.CONST}$ 视为等同于 $\\texttt{instanceof Const}$ 测试，并基于该假设进行去虚拟化，即使没有证明每个子类构造函数都赋了不同的 $tag$ 值，也没有排除反射写入；并且允许开放世界的动态类加载。", "solution": "用户提供了一个来自编译器优化领域的问题，具体涉及像 Java 这样的面向对象语言中虚方法调用的去虚拟化。任务是验证问题陈述，如果有效，则确定哪个假设集足以让编译器基于一个手动实现的类型标签来执行特定的去虚拟化。\n\n### 问题验证\n\n**步骤 1：提取已知信息**\n\n问题陈述提供了以下信息：\n1.  **代码片段：**\n    *   一个枚举 `Tag`，包含常量 `Tag.CONST` 和 `Tag.ADD`。\n    *   一个抽象类 `Node`，带有一个 `final Tag tag` 字段和一个抽象方法 `abstract int eval()`。\n    *   一个 final 类 `Const`，它扩展了 `Node`，存储一个 `int value`，在构造函数中将其 `tag` 设置为 `Tag.CONST`，并实现 `eval()` 以返回 `value`。\n    *   一个 final 类 `Add`，它扩展了 `Node`，存储两个 `Node` 引用 `l` 和 `r`，在构造函数中将其 `tag` 设置为 `Tag.ADD`，并实现 `eval()` 以返回 `l.eval() + r.eval()`。\n    *   一个 `Factory` 类，其静态方法 `mk(boolean b, int v)` 根据布尔值 `b` 返回一个 `new Const(v)` 或一个 `new Add(...)`。\n    *   一个 `Use` 类，其静态方法 `run(boolean b, int v)` 通过 `Factory` 创建一个 `Node n`，然后执行一个条件判断：`if (n.tag == Tag.CONST)`。\n2.  **假设的编译器分析：**\n    *   稀疏条件常量传播 (SCCP)。\n    *   类层次结构分析 (CHA)。\n    *   指向分析。\n3.  **假设的语言语义：**\n    *   Java 语言规范 (JLS) 中关于 `final` 字段的语义。\n4.  **编译器的目标：**\n    *   (i) 将 `tag` 字段的值从对象分配点传播到分支条件。\n    *   (ii) 证明条件 `n.tag == Tag.CONST` 意味着在 `then`-分支 中接收者的动态类型是 `Const`，在 `else`-分支 中是 `Add`。\n    *   (iii) 将调用编译为对 `Const.eval()` 和 `Add.eval()` 的直接调用，而无需运行时守卫。\n5.  **问题：**\n    *   确定所提供的哪个假设集足以实现此目标。\n\n**步骤 2：使用提取的已知信息进行验证**\n\n根据验证标准对问题进行评估：\n*   **科学上成立：** 该问题牢固地定位于编译器理论和实践中。使用类层次结构分析、基于守卫的类型推断（此处使用手动标签）和常量传播的去虚拟化是标准的、有据可查的优化技术。所给的 Java 代码提供了一个典型的例子。该问题是可靠的。\n*   **适定性：** 该问题提供了清晰的背景、具体的代码示例、可用的程序分析列表以及一个精确的目标。它要求从一个多项选择列表中找出一个充分的条件集。这种结构基于已建立的程序分析原则，导向一个唯一的最佳答案。该问题是适定的。\n*   **客观性：** 该问题使用来自计算机科学的精确技术术语进行描述（`devirtualization`、`SCCP`、`CHA`、`points-to analysis`、`dynamic dispatch`、`final fields`）。没有歧义或主观语言。\n\n该问题没有任何无效性缺陷。它在科学上不是不可靠的，也不是不完整、模棱两可或微不足道的。这是一个关于几种高级编译器优化之间相互作用的实质性问题。\n\n**步骤 3：结论与行动**\n\n问题陈述是 **有效的**。现在将进行求解过程。\n\n### 从第一性原理推导\n\n目标是可靠地对 `Use.run` 内部的 `eval()` 调用进行去虚拟化。该方法的核心是：\n```java\nNode n = Factory.mk(b, v);\nif (n.tag == Tag.CONST) {\n  return ((Const) n).eval();\n} else {\n  return n.eval();\n}\n```\n由于强制类型转换后表达式的静态类型，调用 `((Const) n).eval()` 已经是直接调用。挑战在于 `else`-分支 内的虚调用 `n.eval()`。要将其去虚拟化为对 `Add.eval()` 的直接调用，编译器必须证明在该程序路径上，由 `n` 引用的对象的动态类型是 `Add`。\n\n这需要编译器将几个信息片段链接在一起，对应于提示中的三个子目标：\n\n1.  **传播 `tag` 的值：** 为了对条件 `n.tag == Tag.CONST` 进行推理，编译器必须确定 `n.tag` 的可能值。\n    *   需要**指向分析**来确定引用 `n` 可以指向在 `Factory.mk` 内部的两个特定分配点创建的对象：`new Const(v)` 和 `new Add(...)`。\n    *   `tag` 字段是 `final` 的。根据 JLS 语义，它的值在构造期间设置并且不会改变。\n    *   通过分析构造函数，编译器看到 `Const` 分配点将 `tag` 初始化为常量 `Tag.CONST`，而 `Add` 分配点将 `tag` 初始化为 `Tag.ADD`。\n    *   **稀疏条件常量传播 (SCCP)** 可以利用来自指向分析的流信息和 `final` 字段的不变性来传播这些常量值。它得出结论，读取 `n.tag` 将得到 `Tag.CONST` 或 `Tag.ADD`。\n\n2.  **将 `tag` 值与动态类型关联起来：** 这是关键的推断步骤。\n    *   在 `then`-分支中，条件 `n.tag == Tag.CONST` 成立。编译器需要证明这意味着 `n` 的类型是 `Const`。\n    *   在 `else`-分支中，条件 `n.tag != Tag.CONST` 成立。编译器需要证明这意味着 `n` 的类型是 `Add`。\n    *   为了建立这种关联，编译器必须知道 `n` 可能具有的完整类型集合以及与每种类型关联的 `tag` 值。\n    *   **类层次结构分析 (CHA)** 会发现 `Node` 的子类。在这段代码中，它找到了 `Const` 和 `Add`。\n    *   然而，Java 支持动态类加载。`Node` 的一个新子类可能在运行时被加载。为了排除这种情况，编译器必须在**封闭世界假设**下运行，该假设假定编译时看到的类是运行时将存在的唯一类。有了这个假设，CHA 可以保证 `Const` 和 `Add` 是静态类型为 `Node` 的对象的*唯一*可能的具体类型。\n    *   然后编译器可以构建一个映射：类型 `Const` $\\rightarrow$ `tag` 是 `Tag.CONST`；类型 `Add` $\\rightarrow$ `tag` 是 `Tag.ADD`。由于 `Tag.CONST` != `Tag.ADD`，对于已知的子类集合，此映射是单射的。\n    *   这个逻辑依赖于 `tag` 值在构造后的不变性。虽然 `final` 提供了这个保证，但像反射（`java.lang.reflect.Field.set`）或 `sun.misc.Unsafe` 这样的机制可以绕过它。因此，一个可靠的编译器还必须假设**没有发生此类反射或低级写入**。\n    *   给定所有这些条件，编译器可以得出结论：如果 `n.tag == Tag.CONST`，类型必须是 `Const`。如果 `n.tag != Tag.CONST`，由于唯一其他可能的类型是 `Add`，所以类型必须是 `Add`。\n\n3.  **编译为直接调用：**\n    *   由于在两个分支中都证明了 `n` 的类型，去虚拟化就变得很简单。`then`-分支中的调用已经是直接的。在 `else`-分支中，编译器可以将虚调用 `n.eval()` 替换为对 `Add.eval()` 的直接调用。不需要运行时类型检查（守卫）。\n\n### 逐项分析\n\n**A. 字段 `tag` 被声明为 `final` 并且仅在每个子类构造函数中被赋值为一个唯一的枚举常量（对于 `Const` 是 `Tag.CONST`，对于 `Add` 是 `Tag.ADD`）；类 `Const` 和 `Add` 被声明为 `final`；不存在对 `tag` 的反射或低级写入（例如，通过 `java.lang.reflect` 或 `sun.misc.Unsafe`）；指向分析证明了调用点的接收者 `n` 来自 `Const` 或 `Add` 的构造函数；类层次结构分析 (CHA) 遵循封闭世界假设，因此不可能有 `Node` 的其他子类。在这些条件下，SCCP 可以传播 `tag` 的值，从 `tag` 到子类的映射在可达的分配点之间是单射的，并且去虚拟化为直接调用是可靠的，无需运行时守卫。**\n\n这个选项全面列出了从第一性原理推导出的所有必要条件：`final` 且唯一赋值的 `tag`、不存在反射写入、使用指向分析以及 CHA 在封闭世界假设下的关键作用。它正确地描述了其结果：SCCP 可以传播值，标签到类型的映射是单射的，并且去虚拟化是可靠的。\n\n**结论：** **正确**。\n\n**B. 仅将 `tag` 声明为 `final` 就足够了；既不需要别名分析也不需要类层次结构分析，并且反射更新或动态类加载不影响去虚拟化的可靠性。**\n\n这个选项在多个方面都是不正确的。\n*   仅将 `tag` 声明为 `final` 是不够的。没有别名（指向）分析，编译器无法将引用 `n` 与初始化 `tag` 的分配点联系起来。\n*   没有 CHA（以及封闭世界观），编译器无法证明 `n.tag != Tag.CONST` 意味着类型是 `Add`，因为可能存在其他未知的 `Node` 子类。\n*   允许反射更新会破坏 `tag` 的常量性，使检查变得无用。允许开放世界的动态类加载会破坏对 `else`-分支 的推理。\n\n**结论：** **不正确**。\n\n**C. 逃逸分析证明了 `n` 没有逃逸出方法 `Use.run`；因此，编译器可以无条件地将虚调用替换为直接调用目标，而不管 `tag`。**\n\n这个选项误用了逃逸分析的概念。虽然对象 `n` 确实没有逃逸出 `Use.run` 方法，但仅凭这一事实无法确定其具体类型。`n` 的类型取决于来自参数 `b` 的数据流。逃逸分析有助于诸如栈分配或锁消除之类的优化，但它不能解决数据依赖的类型不确定性。声称可以“无条件地，无论 `tag` 如何”进行去虚拟化是错误的，因为编译器不知道应该进行*哪一个*直接调用（`Const.eval` 还是 `Add.eval`）。\n\n**结论：** **不正确**。\n\n**D. 编译器将检查 `n.tag == Tag.CONST` 视为等同于一个 `instanceof Const` 测试，并基于该假设进行去虚拟化，即使没有证明每个子类构造函数都赋了不同的 `tag` 值或排除反射写入；并且允许开放世界的动态类加载。**\n\n这个选项描述了一个不可靠且不正确的编译器。编译器不能在没有证明的情况下做出等价的“假设”。\n*   如果编译器没有证明标签赋值是唯一的（例如，如果 `Add` 也使用了 `Tag.CONST`），那么这个假设就是错误的。\n*   如果可能存在反射写入，那么检查点的 `tag` 值可能与对象的原始类型无关。\n*   如果允许开放世界加载，`n.tag != Tag.CONST` 并不意味着类型是 `Add`，这会使 `else`-分支 中的去虚拟化无效。\n做出这样假设的编译器会生成不正确的代码，可能导致运行时错误（例如，`ClassCastException` 或调用错误的方法）。\n\n**结论：** **不正确**。", "answer": "$$\\boxed{A}$$", "id": "3637449"}, {"introduction": "为了实现去虚拟化，编译器需要一种在运行时访问对象类型信息的机制。实现这一目标有多种方式，每种方式都有其自身的成本。本练习将带您从理论走向工程实践，您将通过分析内存开销和查找延迟，定量比较两种常见的实现策略——胖指针和侧边表，从而揭示编译器开发者在现实世界中面临的权衡 [@problem_id:3637444]。", "problem": "一位编译器实现者正在评估在一个$64$位架构的面向对象运行时中实现去虚拟化的两种机制：(i) 内联携带类型标识符的胖指针，以及 (ii) 将对象地址映射到类型标识符的外部旁路表。该实现者希望在内存开销和虚调用查找延迟方面对这两种方法进行定量比较，然后对于给定的工作负载，将这些指标聚合成一个以中央处理器（CPU）周期为单位的单一标量总成本。\n\n假设以下基本事实和定义：\n- 一个基准指针占用$8$字节。一个胖指针额外携带一个$4$字节的类型标识符，并且由于对齐，其大小向上取整到$16$字节。因此，每个指针因“胖化”而产生的额外内存是$16$字节和$8$字节之间的差值。\n- 旁路表在标准均匀哈希模型下使用带有线性探测的开放寻址法。每个表项存储一个$8$字节的对象地址和一个$4$字节的类型标识符，外加$4$字节的填充以将表项对齐到$16$字节。对于$N$个对象，当负载因子为$\\rho$时，表的容量为$N/\\rho$个表项，忽略对于大$N$的向上取整效应。\n- 对于均匀哈希模型下使用线性探测的成功查找，将使用教科书中的期望探测次数。\n- 对旁路表的每次探测耗费$c$个周期。通过胖指针读取已在寄存器中的类型标识符耗费$t_f$个周期。\n- 为了将整个运行期间的内存开销和延迟合并为单一的标量成本，假设每字节额外内存占用的摊销内存惩罚因子为$w_m$个周期。一种方案的总成本被定义为运行期间的内存成本与所有虚调用的动态查找成本之和。\n\n考虑一个分配了$N = 10^{6}$个对象的程序。每个对象平均有$d = 3$个驻留在堆上的出指针字段。每个对象参与$V = 20$次需要类型标识符进行去虚拟化的虚调用。旁路表在负载因子$\\rho = 0.8$下运行，每次探测成本为$c = 4$个周期。胖指针的查找成本为$t_f = 1$个周期。摊销内存惩罚为$w_m = 0.5$个周期/字节。\n\n仅使用基本定义和经过充分检验的公式与事实，从第一性原理推导出：\n- 胖指针和旁路表的总内存开销（以字节为单位）。\n- 胖指针和旁路表的每次虚调用的期望查找延迟（以周期为单位）。\n- 每种方案在整个运行期间的总成本，定义为 $C_{\\text{fat}} = w_m \\cdot M_{\\text{fat}} + N \\cdot V \\cdot \\ell_{\\text{fat}}$ 和 $C_{\\text{side}} = w_m \\cdot M_{\\text{side}} + N \\cdot V \\cdot \\ell_{\\text{side}}$。\n\n然后计算标量差 $\\Delta C = C_{\\text{fat}} - C_{\\text{side}}$。以周期为单位表示最终结果。将你的最终答案作为一个单独的数字提供。不要四舍五入。", "solution": "任务是定量比较两种去虚拟化机制：胖指针和旁路表。这通过为每种机制计算一个总成本指标来实现，该指标将内存开销和查找延迟合并为一个以CPU周期为单位的单一标量值。然后我们将计算这些总成本的差值。\n\n提供的参数如下：\n- 对象数量: $N = 10^{6}$\n- 每个对象的平均出指针字段数: $d = 3$\n- 每个对象的虚调用次数: $V = 20$\n- 旁路表负载因子: $\\rho = 0.8$\n- 旁路表探测成本: $c = 4$ 周期\n- 胖指针查找成本: $t_f = 1$ 周期\n- 摊销内存惩罚因子: $w_m = 0.5$ 周期/字节\n\n胖指针方案的总成本由 $C_{\\text{fat}} = w_m \\cdot M_{\\text{fat}} + N \\cdot V \\cdot \\ell_{\\text{fat}}$ 给出，旁路表方案的总成本由 $C_{\\text{side}} = w_m \\cdot M_{\\text{side}} + N \\cdot V \\cdot \\ell_{\\text{side}}$ 给出。我们将系统地推导每个组成部分。\n\n首先，我们确定每种方案的内存开销。\n\n**1. 总内存开销 ($M$)**\n\n**对于胖指针 ($M_{\\text{fat}}$):**\n一个胖指针的大小为$16$字节，而一个基准指针为$8$字节。因此，每个指针的额外内存为 $16 - 8 = 8$ 字节。程序有$N$个对象，每个对象平均有$d$个出指针。因此，被“胖化”的指针总数为 $N \\cdot d$。总内存开销是指针数量与每个指针的额外内存的乘积。\n$$M_{\\text{fat}} = (N \\cdot d) \\cdot (16 \\text{ 字节} - 8 \\text{ 字节})$$\n代入给定值：\n$$M_{\\text{fat}} = (10^{6} \\cdot 3) \\cdot 8 = 24 \\times 10^{6} \\text{ 字节}$$\n\n**对于旁路表 ($M_{\\text{side}}$):**\n旁路表是一个将对象地址映射到类型标识符的开放寻址哈希表。它需要存储所有$N$个对象的信息。在负载因子为$\\rho$的情况下，为了容纳$N$个对象，表的容量（表项数量）必须是 $N/\\rho$。每个表项包含一个$8$字节的对象地址、一个$4$字节的类型标识符和$4$字节的填充，总表项大小为$16$字节。总内存开销是哈希表的总大小。\n$$M_{\\text{side}} = \\left(\\frac{N}{\\rho}\\right) \\cdot (\\text{表项大小})$$\n代入给定值：\n$$M_{\\text{side}} = \\left(\\frac{10^{6}}{0.8}\\right) \\cdot 16 = (1.25 \\times 10^{6}) \\cdot 16 = 20 \\times 10^{6} \\text{ 字节}$$\n\n其次，我们确定每次虚调用的期望查找延迟。\n\n**2. 期望查找延迟 ($\\ell$)**\n\n**对于胖指针 ($\\ell_{\\text{fat}}$):**\n问题陈述，从胖指针读取类型标识符的成本由常量$t_f$给出。\n$$\\ell_{\\text{fat}} = t_f = 1 \\text{ 周期}$$\n\n**对于旁路表 ($\\ell_{\\text{side}}$):**\n延迟是在哈希表中成功查找所花费的时间。问题指定使用教科书中的公式，该公式用于计算在均匀哈希假设下，使用线性探测的哈希表中成功搜索的期望探测次数。即：\n$$E[\\text{探测次数}] = \\frac{1}{2} \\left(1 + \\frac{1}{1 - \\rho}\\right)$$\n查找延迟是期望探测次数乘以每次探测的成本$c$。\n$$\\ell_{\\text{side}} = c \\cdot E[\\text{探测次数}] = c \\cdot \\frac{1}{2} \\left(1 + \\frac{1}{1 - \\rho}\\right)$$\n代入给定值：\n$$\\ell_{\\text{side}} = 4 \\cdot \\frac{1}{2} \\left(1 + \\frac{1}{1 - 0.8}\\right) = 2 \\left(1 + \\frac{1}{0.2}\\right) = 2(1 + 5) = 12 \\text{ 周期}$$\n\n第三，我们计算每种方案在整个运行期间的总成本。虚调用的总次数是 $N \\cdot V$。\n\n**3. 总成本 ($C$)**\n\n**对于胖指针 ($C_{\\text{fat}}$):**\n总成本是摊销内存成本与总动态查找成本之和。\n$$C_{\\text{fat}} = w_m \\cdot M_{\\text{fat}} + (N \\cdot V) \\cdot \\ell_{\\text{fat}}$$\n$$C_{\\text{fat}} = (0.5) \\cdot (24 \\times 10^{6}) + (10^{6} \\cdot 20) \\cdot 1$$\n$$C_{\\text{fat}} = 12 \\times 10^{6} + 20 \\times 10^{6} = 32 \\times 10^{6} \\text{ 周期}$$\n\n**对于旁路表 ($C_{\\text{side}}$):**\n类似地，旁路表的总成本为：\n$$C_{\\text{side}} = w_m \\cdot M_{\\text{side}} + (N \\cdot V) \\cdot \\ell_{\\text{side}}$$\n$$C_{\\text{side}} = (0.5) \\cdot (20 \\times 10^{6}) + (10^{6} \\cdot 20) \\cdot 12$$\n$$C_{\\text{side}} = 10 \\times 10^{6} + 240 \\times 10^{6} = 250 \\times 10^{6} \\text{ 周期}$$\n\n最后，我们计算所要求的标量差 $\\Delta C = C_{\\text{fat}} - C_{\\text{side}}$。\n\n**4. 成本差异 ($\\Delta C$)**\n$$\\Delta C = C_{\\text{fat}} - C_{\\text{side}}$$\n$$\\Delta C = (32 \\times 10^{6}) - (250 \\times 10^{6})$$\n$$\\Delta C = -218 \\times 10^{6} \\text{ 周期}$$\n这等价于单个数字 $-218000000$。", "answer": "$$\\boxed{-218000000}$$", "id": "3637444"}]}