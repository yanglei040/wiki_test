{"hands_on_practices": [{"introduction": "闭包的生命周期常常会超过创建它的函数的生命周期，这使得将捕获的变量存储在栈上变得不可行。这个练习挑战你像编译器设计者一样思考，精确地确定为了支持“向上 funarg”问题（即闭包逃逸其定义作用域），必须从函数的栈帧中迁移到堆上的最小数据集。通过分析 [@problem_id:3680362]，你将理解堆分配环境（heap-allocated environment）这一核心概念的必要性和具体实现策略。", "problem": "考虑一台机器上的一个常规调用栈，该机器有专门的帧指针 (FP) 和栈指针 (SP)。一个活动记录按从高到低的地址顺序包含：一个保存的返回地址 (RA)、一个保存的旧帧指针 (old FP)、被调用者保存的寄存器、编译器生成的溢出槽和临时变量、用于局部变量和被视为局部变量的参数的空间，以及为被调用者发出的调用准备的出参区域。根据标准定义，一个栈分配对象的生命周期在其活动记录被弹出时结束，而一个生命周期超过其创建调用的闭包必须在创建它的活动记录的生命周期之外保留其词法环境的存储。\n\n一个函数 $f$ 拥有局部变量 $x$ 和 $y$，并返回一个闭包 $k$。在 $f$ 返回后，该闭包 $k$ 会引用 $x$ 和 $y$。您必须转换 $f$，以使 $k$ 在稍后被调用时是有效的。假设采用词法作用域、值传递参数，并且 $f$ 不会将其局部变量的引用传递给其他线程。该实现支持一种闭包对象，它由一个代码指针和一个指向堆分配块的环境指针 (EP) 组成。\n\n以下哪种编译器策略能正确地识别出必须从 $f$ 的活动记录中移动到堆上的内容，以及如何调整生命周期和指针以在保持语义的同时实现最小开销？\n\nA. 在返回闭包时，将 $f$ 的整个活动记录（包括保存的 RA、保存的旧 FP、被调用者保存的寄存器、溢出槽、局部变量和出参区域）移动到堆中。之后对 $k$ 的调用直接重用这个驻留在堆上的帧，访问时无需重写代码。\n\nB. 分配一个堆环境，其中只包含 $f$ 的被捕获局部变量（此处为 $x$ 和 $y$，以及闭包实际引用的任何其他局部变量）。将闭包代码中的所有访问重写为通过环境指针 (EP) 进行加载和存储，而不是通过相对于 $FP$ 的地址。不要移动保存的 RA、保存的旧 $FP$、被调用者保存的寄存器、未被捕获的溢出槽或出参区域。如果在 $f$ 内部获取了某个被捕获局部变量的地址，则将该地址重写为指向堆环境中相应的单元，以使别名保持有效。\n\nC. 通过在返回时不弹出 $f$ 的原始栈帧来使其保持活动状态；将原始的 $FP$ 作为闭包的环境指针传递。这可以保持所有相对于 $FP$ 的地址的有效性，并避免任何代码重写。\n\nD. 将被捕获的局部变量和被调用者保存的寄存器区域移动到堆中，以便保留闭包创建时的寄存器状态。同时将保存的 RA 也保留在堆中，以便在需要时进行栈回溯。重写任何静态链接以指向旧的 $FP$。\n\nE. 仅将被捕获的局部变量的值复制到堆环境中，但将之前获取的这些局部变量的地址仍指向其原始的栈槽。在每次调用 $k$ 时，通过在堆环境和原始栈槽之间复制值来进行同步，以保留别名的引用语义。\n\n选择唯一的最佳策略。", "solution": "问题描述了编译器设计和运行时系统中的一个经典场景，称为“向上函数参数问题”（upward funarg problem）。一个函数 $f$ 创建了一个闭包 $k$，该闭包捕获了（或形成了词法绑定到）$f$ 的局部变量。这个闭包 $k$ 随后从 $f$ 返回，意味着其生命周期可能超过 $f$ 的活动记录的生命周期。由于被捕获的变量 $x$ 和 $y$ 通常在 $f$ 的活动记录内的栈上分配，当 $f$ 返回时它们将被释放。之后对 $k$ 的任何调用都将访问无效内存，导致未定义行为。任务是确定正确的编译器策略来解决此问题，同时保持程序语义和效率（“最小开销”）。\n\n一个有效的策略必须确保任何被捕获的变量（“逃逸”变量）的存储空间能够持续存在，只要闭包本身还可能被调用。实现这一目标的标准且最有效的方法是将这类变量分配在堆上而不是栈上。问题指出，该实现提供了一个闭包对象，由一个代码指针和一个指向堆分配块的环境指针 ($EP$) 组成，这是用于此目的的标准机制。\n\n一个正确解决方案的核心原则是：\n$1$. **识别：** 编译器必须识别出哪些变量的生命周期需要被延长。这些是 $f$ 的局部变量中被闭包 $k$ 引用（“捕获”）的变量。在本例中，我们被告知是 $x$ 和 $y$。这个过程被称为逃逸分析。\n$2$. **存储迁移：** 这些被识别出的变量的存储必须从栈移动到一个能比栈帧存在更久的位置，也就是堆。\n$3$. **访问重写：** 访问这些已迁移变量的代码，无论是在原函数 $f$ 中还是在闭包 $k$ 中，都必须被重写。原始的访问是相对于帧指针 ($FP$) 的。新的访问必须相对于指向堆分配环境的指针，也就是存储在闭包对象中的环境指针 ($EP$) 。\n$4$. **语义保持：** 转换必须是语义透明的。这一点在获取了被捕获变量的地址时尤其重要。所有指向该变量的指针都必须引用一个单一的、规范的内存位置。如果变量被移动到堆上，任何获取其地址的操作都必须产生其在堆上的位置的地址，而不是其原始的（且现已不存在的）栈位置的地址。\n$5$. **效率：** 策略应具有最小的开销。这意味着只移动必要的数据，并避免复杂、低效的运行时机制。\n\n基于这些原则，我们来评估给出的选项。\n\n**A. 在返回闭包时，将 $f$ 的整个活动记录（包括保存的 RA、保存的旧 FP、被调用者保存的寄存器、溢出槽、局部变量和出参区域）移动到堆中。之后对 $k$ 的调用直接重用这个驻留在堆上的帧，访问时无需重写代码。**\n\n这个策略效率极低。活动记录包含大量与闭包 $k$ 无关的数据。保存的返回地址 (RA) 和保存的旧帧指针 (old FP) 是对 $f$ 调用的动态链接链的一部分，对 $k$ 毫无意义。被调用者保存的寄存器是由 $f$ 为其调用者保存的，并在 $f$ 返回时恢复。出参区域是为 $f$ 发出的调用准备的，而不是为 $k$ 发出的调用。将所有这些数据移动到堆会产生巨大的、不必要的复制开销和内存使用。它违反了“最小开销”的要求。虽然它似乎通过避免一些代码重写来简化访问，但它是一个重量级且在概念上不纯粹的解决方案。\n**结论：不正确。**\n\n**B. 分配一个堆环境，其中只包含 $f$ 的被捕获局部变量（此处为 $x$ 和 $y$，以及闭包实际引用的任何其他局部变量）。将闭包代码中的所有访问重写为通过环境指针 (EP) 进行加载和存储，而不是通过相对于 $FP$ 的地址。不要移动保存的 RA、保存的旧 $FP$、被调用者保存的寄存器、未被捕获的溢出槽或出参区域。如果在 $f$ 内部获取了某个被捕获局部变量的地址，则将该地址重写为指向堆环境中相应的单元，以使别名保持有效。**\n\n这个策略与上面得出的原则完美契合。\n- 它很高效（“最小开销”），因为它只为实际逃逸的变量（$x$ 和 $y$）在堆上分配空间。\n- 它正确地指出了需要将访问重写为相对于环境指针 ($EP$) 。\n- 关键的是，它正确地解决了别名问题。通过确保任何生成被捕获变量地址的操作（例如 `&x`）现在都产生堆分配实例的地址，它为该变量维护了一个单一的规范位置，从而即使在存在指针的情况下也能保持程序的语义。这是现代编译器（用于 ML、Lisp 和 Scala 等语言）中使用的标准、正确且高效的技术。\n**结论：正确。**\n\n**C. 通过在返回时不弹出 $f$ 的原始栈帧来使其保持活动状态；将原始的 $FP$ 作为闭包的环境指针传递。这可以保持所有相对于 $FP$ 的地址的有效性，并避免任何代码重写。**\n\n这种策略被称为“意大利面式栈”（spaghetti stack），因为它打破了常规调用栈严格的后进先出 (LIFO) 规则。如果 $f$ 的栈帧不被弹出，它会在栈中创建一个“洞”，常规的栈管理机制（$SP$ 操作）无法处理。这极大地复杂化了内存管理，基本上需要一个用于栈的垃圾回收器。问题指定了一个“常规调用栈”，而这种方法违反了这一点。由于其复杂性和低效率，它不切实际，也未在主流架构或编译器中使用。\n**结论：不正确。**\n\n**D. 将被捕获的局部变量和被调用者保存的寄存器区域移动到堆中，以便保留闭包创建时的寄存器状态。同时将保存的 RA 也保留在堆中，以便在需要时进行栈回溯。重写任何静态链接以指向旧的 $FP$。**\n\n这是移动不必要信息的另一个例子。被调用者保存的寄存器在 $f$ 返回之前会被恢复，因此在 $f$ 执行完成后，它们保存的状态是短暂且无关紧要的。当闭包 $k$ 被调用时，它将有自己的执行上下文，并根据调用约定管理寄存器。同样，$f$ 的保存的 $RA$ 是用于从 $f$ 返回到其调用者的；它与 $k$ 的执行无关。将这些组件移动到堆违反了最小开销原则，并且没有任何正确的语义目的。\n**结论：不正确。**\n\n**E. 仅将被捕获的局部变量的值复制到堆环境中，但将之前获取的这些局部变量的地址仍指向其原始的栈槽。在每次调用 $k$ 时，通过在堆环境和原始栈槽之间复制值来进行同步，以保留别名的引用语义。**\n\n这个策略存在根本性缺陷，因为它破坏了指针语义。如果创建了一个指向局部变量 $x$ 的指针，`p = &x`，这个指针 `p` 将指向栈上的一个位置。在 $f$ 返回后，这个栈位置被释放，`p` 变成一个悬空指针。提议的“同步”并不能解决这个问题；它只是试图为一个已经损坏的模型打补丁。它创建了数据的两个独立副本（一个在栈上，一个在堆上），这违反了变量应有单一规范存储位置的原则。任何通过悬空指针 `p` 的更新都会写入无效内存，而对堆副本的更新也不会反映在 `p` 指向的地方。这个策略未能保持程序语义。\n**结论：不正确。**\n\n因此，策略 B 是唯一一个通过仅将必要数据迁移到堆上并重写访问来正确且高效地解决该问题的方法，它能保持语义的正确性，包括对别名的处理。", "answer": "$$\\boxed{B}$$", "id": "3680362"}, {"introduction": "理解了变量必须被捕获之后，下一个关键问题是它们是*如何*被捕获的。本练习通过一个经典的循环场景，探讨了按引用捕获（capture-by-reference）和按值捕获（capture-by-value）之间的关键区别，这种情况是许多程序员常见的 bug 来源 [@problem_id:3627909]。这个思想实验强调了一个看似微小的实现细节如何导致截然不同的程序行为。", "problem": "在一种具有词法作用域和一等函数的语言中，闭包是一个函数及其环境的封装，该环境将其每个自由变量绑定到一个存储位置。形式上，环境将变量名映射到位置，而存储区将位置映射到值；变量引用从其位置读取值，而赋值操作则更新该位置的值。闭包可以通过引用捕获变量（将名称绑定到现有位置）或通过值捕获变量（分配一个用当前值初始化的新位置）。如果一个变量的位置必须比其所在的活动记录生命周期更长，实现会将其位置提升到堆上，以便闭包在函数返回后仍能安全访问它。\n\n考虑两个闭包工厂，它们通过迭代索引变量 $i$（从 $0$ 到 $N-1$）来生成一个闭包向量，并在每次迭代中附加一个返回当前循环索引的零参数闭包。这两个工厂的唯一区别在于循环索引 $i$ 的捕获方式：\n- 工厂 $\\mathrm{R}$（引用捕获）：每个闭包的环境都将 $i$ 映射到循环所使用的 $i$ 的单一循环位置，因此所有闭包共享这一个位置。在循环的所有迭代中，实现对循环索引 $i$ 只重用一个可变位置。如果有任何闭包逃逸出该工厂函数，编译器会将这个单一位置提升到堆上。\n- 工厂 $\\mathrm{V}$（值捕获）：在每次迭代中，创建闭包之前，编译器会分配一个新位置并用 $i$ 的当前值对其进行初始化，然后闭包的环境将索引名称映射到该新位置。因此，每个闭包都有自己独立的位置，该位置被初始化为当时 $i$ 的值。\n\n假设闭包仅在工厂函数返回后才被调用。设 $N=3$ 并按如下方式定义结果向量：\n- 对于工厂 $\\mathrm{R}$：按构造顺序执行每个闭包，并将其返回值收集到一个向量 $\\mathrm{res}_{\\mathrm{R}}$ 中。\n- 对于工厂 $\\mathrm{V}$：类似地构成 $\\mathrm{res}_{\\mathrm{V}}$。\n\n一位编译器设计者希望添加一个静态诊断功能，以帮助程序员避免与工厂 $\\mathrm{R}$ 相关的经典延迟绑定循环捕获错误。哪个选项最能描述可观察到的结果，并根据上述模型提出一个合理且可操作的编译器警告？\n\nA. $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 当按引用捕获的循环变量流入一个逃逸闭包时发出警告：“循环变量 $i$ 在一个逃逸闭包中被按引用捕获；请按值捕获或引入每次迭代的绑定。”\n\nB. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,1,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 无需警告，因为编译器必须在循环内部将引用捕获透明地重写为值捕获。\n\nC. $\\mathrm{res}_{\\mathrm{R}}=\\left[2,2,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[2,2,2\\right]$; 在 $N=3$ 时，就 $i$ 可能发生的整数溢出发出警告。\n\nD. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,0,0\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 发出警告：“闭包不应返回值；闭包内的 return 语句已被弃用。”", "solution": "问题陈述描述了一种词法作用域语言中闭包的形式模型，区分了按引用捕获和按值捕获的语义。它要求评估两种具体场景并制定一个合适的编译器诊断信息。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 语言：词法作用域，一等函数。\n- 闭包：一个与环境打包的函数。\n- 环境：将变量名映射到存储位置。\n- 存储区：将位置映射到值。\n- 按引用捕获（工厂 $\\mathrm{R}$）：闭包的环境将变量名映射到一个已有的、共享的位置。具体来说，循环中创建的所有闭包都共享循环索引 $i$ 的单一位置。\n- 按值捕获（工厂 $\\mathrm{V}$）：闭包的环境将变量名映射到一个新位置，该位置在闭包创建时用变量的值进行初始化。\n- 堆提升：如果一个位置的生命周期必须超过其原始活动记录，它将被移动到堆上。\n- 循环：使用索引 $i$ 从 $0$ 迭代到 $N-1$。\n- 参数：$N=3$。\n- 场景：两个工厂 $\\mathrm{R}$ 和 $\\mathrm{V}$，各自生成一个零参数闭包的向量。每个闭包在被调用时返回循环索引 $i$ 的值。\n- 执行：所有闭包都在其各自的工厂函数返回*之后*被调用。\n- 输出：$\\mathrm{res}_{\\mathrm{R}}$ 和 $\\mathrm{res}_{\\mathrm{V}}$ 分别是包含来自工厂 $\\mathrm{R}$ 和 $\\mathrm{V}$ 的闭包返回值的向量。\n- 问题：描述 $\\mathrm{res}_{\\mathrm{R}}$ 和 $\\mathrm{res}_{\\mathrm{V}}$ 的特征，并为工厂 $\\mathrm{R}$ 的情况提出一个合理且可操作的编译器警告。\n\n**步骤 2：使用提取的已知条件进行验证**\n该问题在科学和技术上是合理的。闭包、环境、存储区和捕获语义的模型是编译器设计和编程语言理论中的一个标准和基本概念。问题提取得很好：初始条件清晰，过程是确定性的，问题也很具体。没有矛盾、歧义或信息缺失。所描述的场景是闭包行为的一个经典且非常实际的例子，在像 Python 或 JavaScript 这样的语言中通常被称为“延迟绑定循环问题”。该问题是客观且可形式化的。\n\n**步骤 3：结论和行动**\n问题陈述是有效的。我将继续进行推导和分析。\n\n### 结果推导\n\n循环使用索引变量 $i$ 从 $0$ 迭代到 $N-1$。给定 $N=3$，循环体将对 $i=0$、$i=1$ 和 $i=2$ 执行。一个标准的循环结构，例如 `for (i = 0; i < N; ++i)`，将在条件 $i < 3$ 不再为真时终止。这发生在 $i$ 从 $2$ 增加到 $3$ 之后。因此，循环完成后，单个循环变量 $i$ 的值是 $3$。\n\n**对工厂 $\\mathrm{R}$ 的分析（引用捕获）**\n根据问题描述，工厂 $\\mathrm{R}$ 对循环索引 $i$ 使用一个单一的、可变的位置。循环内创建的所有闭包都捕获对这同一个位置的引用。\n1.  为变量 $i$ 分配一个单一的存储位置，我们称之为 $L_i$。\n2.  在循环执行期间（$i=0, 1, 2$），创建三个闭包并附加到一个向量中。这些闭包中的每一个的环境都包含一个从名称 '$i$'到位置 $L_i$ 的绑定。\n3.  循环完成。存储在位置 $L_i$ 中的最终值是 $3$。\n4.  工厂函数返回。由于闭包已经逃逸出函数的作用域，位置 $L_i$ 被提升到堆上以确保其保持有效，并保留其最终值 $3$。\n5.  工厂函数返回后，闭包被调用。当每个闭包被调用时，它通过其环境访问位置 $L_i$ 来解析变量 $i$。在调用时，存储在 $L_i$ 的值是 $3$。\n6.  三个闭包中的每一个都将读取并返回值 $3$。\n因此，结果向量是 $\\mathrm{res}_{\\mathrm{R}} = \\left[3, 3, 3\\right]$。\n\n**对工厂 $\\mathrm{V}$ 的分析（值捕获）**\n根据问题描述，工厂 $\\mathrm{V}$ 为每个闭包分配一个新位置，并用 $i$ 的当前值进行初始化。\n1.  **迭代 $i=0$**：分配一个新位置 $L_{V0}$，并用值 $0$ 进行初始化。创建第一个闭包，其环境将 '$i$' 映射到 $L_{V0}$。\n2.  **迭代 $i=1$**：分配一个新位置 $L_{V1}$，并用值 $1$ 进行初始化。创建第二个闭包，其环境将 '$i$' 映射到 $L_{V1}$。\n3.  **迭代 $i=2$**：分配一个新位置 $L_{V2}$，并用值 $2$ 进行初始化。创建第三个闭包，其环境将 '$i$' 映射到 $L_{V2}$。\n4.  循环完成。原始的循环变量位置对创建的闭包没有影响，因为它们各自都有自己私有的 $i$ 的位置。\n5.  工厂函数返回后，闭包被调用。\n6.  第一个闭包从其位置 $L_{V0}$ 读取并返回 $0$。\n7.  第二个闭包从其位置 $L_{V1}$ 读取并返回 $1$。\n8.  第三个闭包从其位置 $L_{V2}$ 读取并返回 $2$。\n因此，结果向量是 $\\mathrm{res}_{\\mathrm{V}} = \\left[0, 1, 2\\right]$。\n\n**编译器警告**\n工厂 $\\mathrm{R}$ 的行为是错误的常见来源。程序员通常希望为每次迭代捕获循环变量的值，而不是对单一、变化的变量的引用。编译器诊断应有助于防止此错误。一个合理的警告必须正确识别出有问题的模式：在一个生命周期超过循环的闭包（即“逃逸”闭包）中按引用捕获的循环变量。一个可操作的警告应建议一个正确的替代方案，例如显式地按值捕获，或者创建一个新的、每次迭代都不同的变量并捕获它（这模拟了按值捕获）。\n\n### 逐项分析\n\n**A. $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 当按引用捕获的循环变量流入一个逃逸闭包时发出警告：“循环变量 $i$ 在一个逃逸闭包中被按引用捕获；请按值捕获或引入每次迭代的绑定。”**\n-   **结果描述**：计算出的结果 $\\mathrm{res}_{\\mathrm{R}}=\\left[3,3,3\\right]$ 和 $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$ 与我的推导完全匹配。\n-   **建议的警告**：该警告正确地指出了导致意外行为的具体条件（循环变量、引用捕获、逃逸闭包）。建议的补救措施（“按值捕获”或“引入每次迭代的绑定”）是实现可能预期行为的标准、正确方法。该警告既合理又可操作。\n-   **结论**：**正确**。\n\n**B. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,1,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 无需警告，因为编译器必须在循环内部将引用捕获透明地重写为值捕获。**\n-   **结果描述**：$\\mathrm{res}_{\\mathrm{R}}$ 的结果不正确。它没有考虑到所有闭包都引用同一个位置，该位置在循环后持有 $i$ 的最终值。\n-   **建议的措施**：断言编译器*必须*执行此重写是一种语言设计选择，而非普遍真理。许多语言（例如 C++）提供了对捕获模式的显式控制，自动更改程序员指定的语义是不正确的，并且可能会破坏有意依赖引用捕获的代码。警告是一种更合适、更安全的静态分析工具。\n-   **结论**：**不正确**。\n\n**C. $\\mathrm{res}_{\\mathrm{R}}=\\left[2,2,2\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[2,2,2\\right]$; 在 $N=3$ 时，就 $i$ 可能发生的整数溢出发出警告。**\n-   **结果描述**：两个结果都不正确。对于 $\\mathrm{res}_{\\mathrm{R}}$，$i$ 的最终值是 $3$（导致循环终止的值），而不是 $2$（最后一次迭代中使用的值）。对于 $\\mathrm{res}_{\\mathrm{V}}$，值应该是每次迭代都不同的，即 $\\left[0,1,2\\right]$。\n-   **建议的警告**：关于整数溢出的警告与本问题完全无关。值 $3$ 远在任何标准整数类型的容量之内。核心问题是关于变量绑定和作用域，而不是算术限制。\n-   **结论**：**不正确**。\n\n**D. $\\mathrm{res}_{\\mathrm{R}}=\\left[0,0,0\\right]$, $\\mathrm{res}_{\\mathrm{V}}=\\left[0,1,2\\right]$; 发出警告：“闭包不应返回值；闭包内的 return 语句已被弃用。”**\n-   **结果描述**：$\\mathrm{res}_{\\mathrm{R}}$ 的结果不正确。它错误地假设闭包捕获了 $i$ 的初始值 ($0$)，而不是对一个值被更新为 $3$ 的位置的引用。$\\mathrm{res}_{\\mathrm{V}}$ 的结果是正确的。\n-   **建议的警告**：该警告毫无意义。闭包是一等函数，返回值是一项主要且基本的能力。将其声明为“已弃用”与函数式和现代多范式编程的基本原则相矛盾。该警告没有解决捕获语义的实际问题。\n-   **结论**：**不正确**。", "answer": "$$\\boxed{A}$$", "id": "3627909"}, {"introduction": "在堆上为闭包创建环境会产生开销，因此一个关键的优化目标是使其尽可能小。本练习介绍了一种系统性的编译器优化技术——活性变量分析（live-variable analysis），用于精确识别并消除对“死亡”变量（即在闭包创建之后不再被使用的变量）的捕获。通过解决这个问题 [@problem_id:3627881]，你将学会如何应用数据流分析来最小化闭包的内存占用，从而提升程序的效率。", "problem": "考虑一个编译器中程序的中间表示，该编译器实现了基于引用捕获语义的词法闭包。词法闭包在一个特定的程序点创建，并可能在后续的控制流中被调用。闭包环境存储了闭包所引用的自由变量的绑定。为了消除无效捕获，我们希望只包含那些存活范围与闭包创建点相交的变量。在一个控制流图 (CFG) 上使用标准的后向活跃变量数据流分析 (DFA)，并遵循以下基本定义：\n- 一个变量 $v$ 在程序点 $p$ 是活跃的，当且仅当存在一条从 $p$ 到 $v$ 的某个使用的路径，且该路径不经过任何对 $v$ 的重定义。\n- 对于每个基本块 $n$，其活跃变量方程为\n$$\\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup \\left(\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]\\right), \\qquad \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s],$$\n其中 $\\mathrm{USE}[n]$ 是在 $n$ 中任何定义之前就被使用的变量集合，$\\mathrm{DEF}[n]$ 是在 $n$ 中被定义的变量集合，而 $\\mathrm{Succ}(n)$ 是 $n$ 在CFG中的后继。\n\n程序有外层作用域局部变量 $a$、$b$、$c$、$d$，其字节大小分别为 $s_a = 8$、$s_b = 8$、$s_c = 4$、$s_d = 16$。闭包在基本块 $B_3$ 的末尾创建。为了对跨越闭包边界的活跃性进行建模，在CFG中添加一条从 $B_3$ 到闭包体入口 $G_1$ 的边。外部程序和闭包体由以下基本块以三地址码形式给出：\n\n- 外部程序：\n  - $B_1$: $a := 1;$ $b := 2;$ $c := b + a;$ goto $B_2$.\n  - $B_2$ 跳转到 $B_2^\\mathrm{T}$ 或 $B_2^\\mathrm{F}$：\n    - $B_2^\\mathrm{T}$: if cond then $a := a + 1;$ goto $B_3$.\n    - $B_2^\\mathrm{F}$: else $c := b + 3;$ goto $B_3$.\n  - $B_3$: $t := \\mathrm{closure}(\\lambda u.\\ \\text{body } G);$ if cond2 then $d := a + c$ else $b := b + 5;$ goto $B_4$.\n  - $B_4$: call $h(t);$ return.\n\n- 闭包体：\n  - $G_1$: $x := a + c;$ goto $G_2$.\n  - $G_2$: if $\\phi$ then $y := b$ else $y := a;$ goto $G_3$.\n  - $G_3$: return $x + y$.\n\n假设变量 $x$ 和 $y$ 是闭包的局部变量，不属于外部变量集。使用上述活跃变量DFA定义，计算最小闭包环境，该环境是其存活范围与 $B_3$ 末尾的闭包创建点相交的外层变量集合。然后，计算该环境的总大小（以字节为单位），即该最小集合中所有变量 $v$ 的大小 $s_v$ 之和。请用一个精确的整数表示您的最终答案（以字节为单位）。无需四舍五入。请以字节为单位陈述您的最终数值答案。", "solution": "该问题要求计算词法闭包环境的最小大小。这可以通过识别闭包中那些存活范围与闭包创建点相交的自由变量集合来实现。问题明确指出，需要在程序的控制流图 (CFG) 上使用后向活跃变量数据流分析 (DFA)。\n\n首先，我们建立CFG并确定每个基本块的 `USE` 和 `DEF` 集合。该程序由一个包含基本块 $B_1, B_2, B_2^\\mathrm{T}, B_2^\\mathrm{F}, B_3, B_4$ 的外部函数和一个包含基本块 $G_1, G_2, G_3$ 的闭包体组成。外层作用域变量为 $\\{a, b, c, d\\}$，闭包的局部变量为 $\\{x, y\\}$。\n\nCFG的后继关系 $\\mathrm{Succ}(n)$ 如下：\n- $\\mathrm{Succ}(B_1) = \\{B_2\\}$\n- 为了分析简便，我们可以将空的跳转块 $B_2$ 与其后继合并。但根据给定的结构：$\\mathrm{Succ}(B_2) = \\{B_2^\\mathrm{T}, B_2^\\mathrm{F}\\}$。\n- $\\mathrm{Succ}(B_2^\\mathrm{T}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_2^\\mathrm{F}) = \\{B_3\\}$\n- $\\mathrm{Succ}(B_3) = \\{B_4, G_1\\}$。从 $B_3$ 到 $G_1$ 的边是为对闭包调用的活跃性进行建模而明确添加的。\n- $\\mathrm{Succ}(B_4) = \\emptyset$（因为 `return` 语句）。\n- $\\mathrm{Succ}(G_1) = \\{G_2\\}$\n- $\\mathrm{Succ}(G_2) = \\{G_3\\}$\n- $\\mathrm{Succ}(G_3) = \\emptyset$（因为 `return` 语句）。\n\n接下来，我们确定每个基本块 $n$ 的 $\\mathrm{USE}[n]$ 和 $\\mathrm{DEF}[n]$ 集合。$\\mathrm{USE}[n]$ 包含在 $n$ 中任何定义之前被使用的变量，而 $\\mathrm{DEF}[n]$ 包含在 $n$ 中被定义的变量。\n- $B_1: a := 1; b := 2; c := b + a;$\n  - $\\mathrm{USE}[B_1] = \\emptyset$\n  - $\\mathrm{DEF}[B_1] = \\{a, b, c\\}$\n- $B_2$: 跳转\n  - $\\mathrm{USE}[B_2] = \\emptyset$\n  - $\\mathrm{DEF}[B_2] = \\emptyset$\n- $B_2^\\mathrm{T}: a := a + 1;$\n  - $\\mathrm{USE}[B_2^\\mathrm{T}] = \\{a\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{T}] = \\{a\\}$\n- $B_2^\\mathrm{F}: c := b + 3;$\n  - $\\mathrm{USE}[B_2^\\mathrm{F}] = \\{b\\}$\n  - $\\mathrm{DEF}[B_2^\\mathrm{F}] = \\{c\\}$\n- $B_3: t := \\mathrm{closure}(...); \\text{if cond2 then } d := a + c \\text{ else } b := b + 5;$\n  - $\\mathrm{USE}[B_3] = \\{a, b, c\\}$\n  - $\\mathrm{DEF}[B_3] = \\{b, d\\}$（可能被定义的变量）\n- $B_4: \\text{call } h(t); \\text{return};$\n  - $\\mathrm{USE}[B_4] = \\emptyset$（相对于 $\\{a, b, c, d, x, y\\}$）\n  - $\\mathrm{DEF}[B_4] = \\emptyset$\n- $G_1: x := a + c;$\n  - $\\mathrm{USE}[G_1] = \\{a, c\\}$\n  - $\\mathrm{DEF}[G_1] = \\{x\\}$\n- $G_2: \\text{if } \\phi \\text{ then } y := b \\text{ else } y := a;$\n  - $\\mathrm{USE}[G_2] = \\{a, b\\}$\n  - $\\mathrm{DEF}[G_2] = \\{y\\}$\n- $G_3: \\text{return } x + y;$\n  - $\\mathrm{USE}[G_3] = \\{x, y\\}$\n  - $\\mathrm{DEF}[G_3] = \\emptyset$\n\n我们迭代应用活跃变量方程，直到 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合收敛。我们将所有集合初始化为 $\\emptyset$。\n$$ \\mathrm{IN}[n] = \\mathrm{USE}[n] \\cup (\\mathrm{OUT}[n] \\setminus \\mathrm{DEF}[n]) $$\n$$ \\mathrm{OUT}[n] = \\bigcup_{s \\in \\mathrm{Succ}(n)} \\mathrm{IN}[s] $$\n\n**迭代 1：**\n- $\\mathrm{OUT}[B_4] = \\emptyset$\n- $\\mathrm{IN}[B_4] = \\mathrm{USE}[B_4] \\cup (\\mathrm{OUT}[B_4] \\setminus \\mathrm{DEF}[B_4]) = \\emptyset \\cup (\\emptyset \\setminus \\emptyset) = \\emptyset$\n- $\\mathrm{OUT}[G_3] = \\emptyset$\n- $\\mathrm{IN}[G_3] = \\mathrm{USE}[G_3] \\cup (\\mathrm{OUT}[G_3] \\setminus \\mathrm{DEF}[G_3]) = \\{x, y\\} \\cup (\\emptyset \\setminus \\emptyset) = \\{x, y\\}$\n- $\\mathrm{OUT}[G_2] = \\mathrm{IN}[G_3] = \\{x, y\\}$\n- $\\mathrm{IN}[G_2] = \\mathrm{USE}[G_2] \\cup (\\mathrm{OUT}[G_2] \\setminus \\mathrm{DEF}[G_2]) = \\{a, b\\} \\cup (\\{x, y\\} \\setminus \\{y\\}) = \\{a, b, x\\}$\n- $\\mathrm{OUT}[G_1] = \\mathrm{IN}[G_2] = \\{a, b, x\\}$\n- $\\mathrm{IN}[G_1] = \\mathrm{USE}[G_1] \\cup (\\mathrm{OUT}[G_1] \\setminus \\mathrm{DEF}[G_1]) = \\{a, c\\} \\cup (\\{a, b, x\\} \\setminus \\{x\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_3] = \\mathrm{IN}[B_4] \\cup \\mathrm{IN}[G_1] = \\emptyset \\cup \\{a, b, c\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_3] = \\mathrm{USE}[B_3] \\cup (\\mathrm{OUT}[B_3] \\setminus \\mathrm{DEF}[B_3]) = \\{a, b, c\\} \\cup (\\{a, b, c\\} \\setminus \\{b, d\\}) = \\{a, b, c\\} \\cup \\{a, c\\} = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{T}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{T}] = \\mathrm{USE}[B_2^\\mathrm{T}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{T}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{T}]) = \\{a\\} \\cup (\\{a, b, c\\} \\setminus \\{a\\}) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_2^\\mathrm{F}] = \\mathrm{IN}[B_3] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2^\\mathrm{F}] = \\mathrm{USE}[B_2^\\mathrm{F}] \\cup (\\mathrm{OUT}[B_2^\\mathrm{F}] \\setminus \\mathrm{DEF}[B_2^\\mathrm{F}]) = \\{b\\} \\cup (\\{a, b, c\\} \\setminus \\{c\\}) = \\{b\\} \\cup \\{a, b\\} = \\{a, b\\}$\n- $\\mathrm{OUT}[B_2] = \\mathrm{IN}[B_2^\\mathrm{T}] \\cup \\mathrm{IN}[B_2^\\mathrm{F}] = \\{a, b, c\\} \\cup \\{a, b\\} = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_2] = \\mathrm{USE}[B_2] \\cup (\\mathrm{OUT}[B_2] \\setminus \\mathrm{DEF}[B_2]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\emptyset) = \\{a, b, c\\}$\n- $\\mathrm{OUT}[B_1] = \\mathrm{IN}[B_2] = \\{a, b, c\\}$\n- $\\mathrm{IN}[B_1] = \\mathrm{USE}[B_1] \\cup (\\mathrm{OUT}[B_1] \\setminus \\mathrm{DEF}[B_1]) = \\emptyset \\cup (\\{a, b, c\\} \\setminus \\{a, b, c\\}) = \\emptyset$\n\n第二次迭代显示所有 $\\mathrm{IN}$ 和 $\\mathrm{OUT}$ 集合都没有改变，因此分析已收敛到一个不动点。\n\n问题陈述，“最小闭包环境是其存活范围与基本块 $B_3$ 末尾的闭包创建点相交的外层变量集合”。在基本块上的DFA背景下，在一个块 $n$ 末尾的活跃变量集合是 $\\mathrm{OUT}[n]$。\n\n根据我们的分析，在块 $B_3$ 末尾的活跃变量集合是：\n$$ \\mathrm{OUT}[B_3] = \\{a, b, c\\} $$\n这些变量因为它们的后续使用而保持活跃，无论是在闭包体中（到 $G_1$ 的路径），还是在主程序流中（到 $B_4$ 的路径，尽管在这种情况下 $\\mathrm{IN}[B_4]=\\emptyset$）。$\\{a, b, c\\}$ 的活跃性完全由它们在闭包体内部的使用所决定，这些使用向后传播成为 $\\mathrm{IN}[G_1]$，而 $\\mathrm{IN}[G_1]$ 又决定了 $\\mathrm{OUT}[B_3]$。\n\n外层作用域变量的集合是 $\\{a, b, c, d\\}$。最小闭包环境由该集合中同时也在 $\\mathrm{OUT}[B_3]$ 中的变量组成。\n$$ \\text{捕获的变量} = \\mathrm{OUT}[B_3] \\cap \\{a, b, c, d\\} = \\{a, b, c\\} $$\n变量 $d$ 没有被捕获，因为它在块 $B_3$ 之后不是活跃的；不存在从 $B_3$ 末尾到 $d$ 的使用的路径。\n\n最后，我们使用给定的被捕获变量的大小来计算此环境的总大小：$s_a = 8$ 字节，$s_b = 8$ 字节，以及 $s_c = 4$ 字节。\n$$ \\text{总大小} = s_a + s_b + s_c = 8 + 8 + 4 = 20 \\text{ 字节} $$\n环境总大小为 $20$ 字节。", "answer": "$$\\boxed{20}$$", "id": "3627881"}]}