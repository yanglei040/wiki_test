{"hands_on_practices": [{"introduction": "理解类型推导的一个主要动机是它能够自动发现代码中的错误。这个练习将带你分析一个包含模式匹配的表达式，其不同分支返回不兼容的type。通过手动生成和分析类型约束，你将能精确地定位导致类型错误的“最小不可满足核心”，这正是现代编译器诊断错误的底层原理。[@problem_id:3624432]", "problem": "考虑一个带有不交和（disjoint sums）与模式匹配的简单类型、传值调用（call-by-value）的函数式核心语言。其基本类型为 $\\mathsf{int}$ 和 $\\mathsf{bool}$。不交和类型写作 $t_1 + t_2$，其规范构造子（canonical constructors）为 $\\text{Left}: t_1 \\to t_1 + t_2$ 和 $\\text{Right}: t_2 \\to t_1 + t_2$。模式匹配的形式为 $\\text{match}\\ e\\ \\text{with}\\ \\text{Left}\\ x \\to e_1\\ \\mid\\ \\text{Right}\\ y \\to e_2$。假设和类型（sum type）的标准类型规则如下：如果 $e: t_1 + t_2$，则在左分支中 $x: t_1$，在右分支中 $y: t_2$，并且 $e_1$ 和 $e_2$ 都必须具有相同的类型 $\\tau$，该类型也是整个匹配表达式的类型。整数加法运算符的类型为 $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$，一元布尔否定运算符的类型为 $\\mathsf{bool} \\to \\mathsf{bool}$。使用标准的 Hindley–Milner (HM) 类型推断的 Algorithm W，在应用任何合一（unification）或替换（substitution）之前，生成类型表达式的等式约束。\n\n在上述假设下，分析表达式 $\\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$。通过应用语法导向的类型规则和运算符类型，生成原始类型等式约束集，期间不执行合一。然后，确定这些原始约束的一个最小不可满足子集（a minimal unsatisfiable core）的基数（cardinality）。\n\n你的最终答案必须是一个数字，等于这个最小不可满足子集的大小。不需要四舍五入，也不涉及单位。", "solution": "该问题要求在一个具有不交和与模式匹配的简单类型函数式语言中，分析一个给定的 $\\lambda$-项。任务是应用 Hindley-Milner 类型推断的原理，特别是 Algorithm W，来生成一组原始类型等式约束。随后，我们必须确定这些约束的一个最小不可满足子集的基数，该子集也被称为最小不可满足核心（minimal unsatisfiable core）。\n\n待分析的项是 $E = \\lambda v.\\ \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to \\text{not}\\ y$。\n\n我们通过对该项进行语法导向的遍历来继续分析，为未知类型分配新的类型变量，并根据给定的类型规则生成约束。\n\n令 $\\tau_E$ 为整个表达式 $E$ 的类型。\n该表达式是一个 $\\lambda$-抽象。根据函数抽象的类型规则，其类型将是一个函数类型。令 $\\alpha_v$ 为绑定变量 $v$ 的新类型变量，令 $\\alpha_{body}$ 为抽象体的新类型变量。那么 $E$ 的类型是 $\\tau_E = \\alpha_v \\to \\alpha_{body}$。这定义了最终的类型结构，但本身并不生成合一约束。\n\n抽象体是 `match` 表达式，$M = \\text{match}\\ v\\ \\text{with}\\ \\text{Left}\\ x \\to x + 1\\ \\mid\\ \\text{Right}\\ y \\to e_2$。该表达式的类型是 $\\alpha_{body}$。\n对不交和进行模式匹配的类型规则施加了几个约束：\n1.  被匹配的表达式（审查对象，scrutinee）$v$ 的类型，即 $\\alpha_v$，必须是一个和类型。我们引入两个新的类型变量 $\\alpha_L$ 和 $\\alpha_R$ 来表示和的左、右分量的类型。这给出了我们的第一个约束，它涉及一个类型构造子（type constructor）：\n    $$C_1: \\alpha_v = \\alpha_L + \\alpha_R$$\n2.  `match` 表达式的两个分支必须求值得到相同的类型。令 $\\alpha_{e1}$ 为第一个分支表达式 $x + 1$ 的类型，$\\alpha_{e2}$ 为第二个分支表达式 $\\text{not}\\ y$ 的类型。这就产生了一个关键的等式约束：\n    $$C_2: \\alpha_{e1} = \\alpha_{e2}$$\n3.  整个 `match` 表达式的类型 $\\alpha_{body}$ 是其分支的共同类型。\n    $$C_3: \\alpha_{body} = \\alpha_{e1}$$\n\n接下来，我们分析分支表达式的类型以生成进一步的约束。\n在左分支 $\\text{Left}\\ x \\to x + 1$ 中，模式变量 $x$ 绑定到来自 `Left` 构造子的值。因此其类型为 $\\alpha_L$。表达式是 $x + 1$。整数加法运算符“+”声明的类型为 $\\mathsf{int} \\times \\mathsf{int} \\to \\mathsf{int}$，这对应于柯里化（curried）的函数类型 $\\mathsf{int} \\to (\\mathsf{int} \\to \\mathsf{int})$。\n为了使应用 $(+) x$ 是类型正确的（well-typed），$x$ 的类型（即 $\\alpha_L$）必须等于“+”的参数类型（即 $\\mathsf{int}$）。\n$$C_4: \\alpha_L = \\mathsf{int}$$\n$(+) x$ 的结果是一个类型为 $\\mathsf{int} \\to \\mathsf{int}$ 的函数。这个函数接着被应用于整数常量 $1$，其类型为 $\\mathsf{int}$。该应用是类型正确的，表达式 $x+1$ 的最终类型 $\\alpha_{e1}$ 是返回类型 $\\mathsf{int}$。\n$$C_5: \\alpha_{e1} = \\mathsf{int}$$\n\n在右分支 $\\text{Right}\\ y \\to \\text{not}\\ y$ 中，模式变量 $y$ 的类型为 $\\alpha_R$。表达式是 $\\text{not}\\ y$。一元布尔否定运算符 'not' 声明的类型为 $\\mathsf{bool} \\to \\mathsf{bool}$。\n为了使应用 `not y` 是类型正确的， $y$ 的类型（即 $\\alpha_R$）必须等于 'not' 的参数类型（即 $\\mathsf{bool}$）。\n$$C_6: \\alpha_R = \\mathsf{bool}$$\n此应用的结果类型为 $\\mathsf{bool}$。这就是表达式 $\\text{not}\\ y$ 的类型，即 $\\alpha_{e2}$。\n$$C_7: \\alpha_{e2} = \\mathsf{bool}$$\n\n我们现在已经生成了需要进行合一的完整原始等式约束集：\n$\\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{body} = \\alpha_{e1}, \\alpha_L = \\mathsf{int}, \\alpha_{e1} = \\mathsf{int}, \\alpha_R = \\mathsf{bool}, \\alpha_{e2} = \\mathsf{bool} \\}$。\n类型系统现在会尝试找到一个能同时满足所有这些等式的替换（即一个合一子，unifier）。\n然而，这个集合是不可满足的。矛盾源于以下约束子集：\n- $C_2: \\alpha_{e1} = \\alpha_{e2}$ (两个分支的类型必须相同。)\n- $C_5: \\alpha_{e1} = \\mathsf{int}$ (第一个分支的类型被推断为 $\\mathsf{int}$。)\n- $C_7: \\alpha_{e2} = \\mathsf{bool}$ (第二个分支的类型被推断为 $\\mathsf{bool}$。)\n\n结合这三个约束导致了等式 $\\mathsf{int} = \\mathsf{bool}$。由于 $\\mathsf{int}$ 和 $\\mathsf{bool}$ 是不同的、不可合一的基本类型，这构成了一个矛盾。该项是类型错误的（ill-typed）。\n\n问题要求的是这些原始约束的一个最小不可满足子集的基数。我们考虑子集 $S_{core} = \\{ C_2, C_5, C_7 \\} = \\{ \\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool} \\}$。我们已经确定 $S_{core}$ 是不可满足的。为了确认它是一个最小不可满足核心（MUC），我们必须证明从中移除任何单个约束都会得到一个可满足的集合。\n\n1.  移除 $C_2$：集合 $\\{\\alpha_{e1} = \\mathsf{int}, \\alpha_{e2} = \\mathsf{bool}\\}$ 可通过替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$ 满足。\n2.  移除 $C_5$：集合 $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e2} = \\mathsf{bool}\\}$ 可通过替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{bool}, \\alpha_{e2} \\mapsto \\mathsf{bool}\\}$ 满足。\n3.  移除 $C_7$：集合 $\\{\\alpha_{e1} = \\alpha_{e2}, \\alpha_{e1} = \\mathsf{int}\\}$ 可通过替换 $\\{\\alpha_{e1} \\mapsto \\mathsf{int}, \\alpha_{e2} \\mapsto \\mathsf{int}\\}$ 满足。\n\n由于每个大小为 2 的子集都是可满足的，所以 $S_{core}$ 是一个最小不可满足核心。大小为 1 的不可满足核心是不可能的，因为没有形如 $T_1 = T_2$（其中 $T_1, T_2$ 为不同常量）的原始约束。大小为 2 的不可满足核心需要两个像 $\\{\\alpha = T_1, \\alpha = T_2\\}$ 这样的约束，而这并未直接出现在我们生成的集合中。因此，一个 MUC 的大小不可能小于 3。既然我们已经找到了一个大小为 3 的 MUC，这就是最小不可满足子集的大小。\n\n这个最小不可满足子集的基数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "3624432"}, {"introduction": "在学会诊断错误之后，让我们来看一个成功推导的例子，它将展示出Hindley-Milner类型推导的真正威力。本练习将指导你为函数式编程中的基石函数 `foldr` 推导出其完整的、最为通用的多态类型。这个过程涉及到处理高阶函数、递归调用和最终的类型泛化，是掌握类型推导的经典实践。[@problem_id:3624329]", "problem": "给定一个核心函数式语言，该语言具有 lambda 抽象和代数数据类型，并配备了使用 W 算法的 Hindley–Milner (HM) 多态类型推断。语言提供了列表，包括空列表构造器 $[]$ 和 cons 构造器 $:$，并以下列类型事实为基础：\n- 空列表的类型为 $\\forall \\alpha.\\ \\mathrm{List}\\ \\alpha$。\n- cons 构造器的类型为 $\\forall \\alpha.\\ \\alpha \\to \\mathrm{List}\\ \\alpha \\to \\mathrm{List}\\ \\alpha$。\n- 对列表的模式匹配遵循标准类型规则，即如果表达式 $e$ 的类型为 $\\mathrm{List}\\ \\alpha$（对于某个 $\\alpha$），那么在 $[]$ 的分支中，结果具有某个类型 $\\tau$；在 $x:xs$ 的分支中，于扩展了 $x:\\alpha$ 和 $xs:\\mathrm{List}\\ \\alpha$ 的环境下，该分支的结果也必须是类型 $\\tau$；整个匹配表达式的类型则为 $\\tau$。\n\n考虑 $foldr$ 作为顶层递归绑定的递归定义：\n$$\n\\mathrm{let\\ rec}\\ foldr = \\lambda f.\\ \\lambda z.\\ \\lambda xs.\\ \\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\{ [] \\to z;\\ (x:xs') \\to f\\ x\\ (foldr\\ f\\ z\\ xs') \\}\\ \\mathrm{in}\\ foldr.\n$$\n假设用于 HM 多态的 W 算法已扩展到递归绑定，其方式是初始时为递归绑定的变量分配一个新的单类型，并将其与为其右侧推断出的类型进行合一（unify）。\n\n任务：\n1. 使用 W 算法，构建由上述定义生成的类型约束，这些约束足以推断出 $foldr$ 的主类型。将每个 lambda 参数视为绑定到一个新的类型变量，并根据所述的递归绑定规则处理 $foldr$ 的递归出现。\n2. 通过一阶合一求解约束，推导出 $foldr$ 的主类型模式。\n3. 令 $M$ 表示 $foldr$ 整个主类型中出现的箭头构造器 $\\to$ 的总数（计算所有出现次数，包括嵌套在参数类型内的），令 $V$ 表示主类型模式中不同全称量化类型变量的数量。计算值 $P = M \\times V$。\n\n最终结果只提供 $P$ 的值。无需四舍五入，不涉及单位。最终答案必须是一个实数值。", "solution": "该问题定义良好，科学上基于编译器理论和类型系统的原理，并且是客观的。所有必要的信息和定义都已提供。因此，该问题是有效的。\n\n任务是推断 $\\mathrm{foldr}$ 函数的主类型，然后基于其结构进行计算。$\\mathrm{foldr}$ 的定义是：\n$$\n\\mathrm{let\\ rec}\\ \\mathrm{foldr} = \\lambda f.\\ \\lambda z.\\ \\lambda xs.\\ \\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\{ [] \\to z;\\ (x:xs') \\to f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs') \\}\n$$\n我们使用 W 算法来推断类型。\n\n**步骤 1：建立类型环境和约束。**\n根据 $\\mathrm{let\\ rec}$ 的规则，我们在用于推导函数体类型的环境中为 $\\mathrm{foldr}$ 引入一个新的单类型变量，记为 $\\tau_{fr}$。初始环境是 $\\Gamma_0 = \\{ \\mathrm{foldr} : \\tau_{fr} \\}$。\n\n函数体是一系列 lambda 抽象。我们为每个参数引入新的类型变量：\n- $f$ 获得类型 $\\tau_f$。\n- $z$ 获得类型 $\\tau_z$。\n- $xs$ 获得类型 $\\tau_{xs}$。\n\n用于推导 $\\mathrm{case}$ 表达式类型的环境是 $\\Gamma_1 = \\Gamma_0 \\cup \\{ f:\\tau_f, z:\\tau_z, xs:\\tau_{xs} \\}$。整个 lambda 表达式的类型将是 $\\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$，其中 $\\tau_{case}$ 是 $\\mathrm{case}$ 表达式的类型。\n\n**步骤 2：对 `case` 表达式进行类型推导。**\n表达式是 $\\mathrm{case}\\ xs\\ \\mathrm{of}\\ \\dots$。$xs$ 的类型是 $\\tau_{xs}$。为了能在列表模式匹配中使用它，它的类型必须是列表类型。这产生我们的第一个约束：\n(1) $\\tau_{xs} = \\mathrm{List}\\ \\alpha$，对于一个新的类型变量 $\\alpha$。\n\n$\\mathrm{case}$ 表达式的结果类型 $\\tau_{case}$ 必须与每个分支的类型相同。\n\n*分支 1: `[] -> z`*\n空列表 $[]$ 的类型是 $\\forall \\beta. \\mathrm{List}\\ \\beta$。将其实例化，我们得到 $\\mathrm{List}\\ \\beta'$，其中 $\\beta'$ 是一个新的类型变量。为使模式匹配，我们将 $\\tau_{xs}$ 与 $\\mathrm{List}\\ \\beta'$ 合一，所以 $\\mathrm{List}\\ \\alpha = \\mathrm{List}\\ \\beta'$，这意味着 $\\alpha = \\beta'$。此分支中的表达式是 $z$，根据环境 $\\Gamma_1$，其类型为 $\\tau_z$。所以，此分支的类型是 $\\tau_z$。\n\n*分支 2: `(x:xs') -> f x (foldr f z xs')`*\ncons 构造器 $:$ 的类型是 $\\forall \\gamma. \\gamma \\to \\mathrm{List}\\ \\gamma \\to \\mathrm{List}\\ \\gamma$。将其实例化得到 $\\gamma' \\to \\mathrm{List}\\ \\gamma' \\to \\mathrm{List}\\ \\gamma'$。模式 $x:xs'$ 将 $x$ 绑定到类型 $\\gamma'$，将 $xs'$ 绑定到类型 $\\mathrm{List}\\ \\gamma'$。为使模式匹配有效，我们将 $\\tau_{xs}$ 与 $\\mathrm{List}\\ \\gamma'$ 合一，所以 $\\mathrm{List}\\ \\alpha = \\mathrm{List}\\ \\gamma'$，这意味着 $\\alpha = \\gamma'$。\n此分支体的环境是 $\\Gamma_2 = \\Gamma_1 \\cup \\{ x:\\alpha, xs':\\mathrm{List}\\ \\alpha \\}$。\n\n现在我们推导此分支体的类型：$f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs')$。\n首先，我们在 $\\Gamma_2$ 中推导递归调用 $\\mathrm{foldr}\\ f\\ z\\ xs'$ 的类型。\n- $\\mathrm{foldr}$ 的类型是 $\\tau_{fr}$。\n- $f$ 的类型是 $\\tau_f$。\n- $z$ 的类型是 $\\tau_z$。\n- $xs'$ 的类型是 $\\mathrm{List}\\ \\alpha$。\n该应用要求 $\\tau_{fr}$ 是一个接受这些参数的函数类型。设此递归调用的返回类型为 $\\tau_{rec}$。这产生以下约束：\n(2) $\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_{rec}$。\n\n接下来，我们推导外部应用 $f\\ x\\ (\\mathrm{foldr}\\ f\\ z\\ xs')$ 的类型。\n- $f$ 的类型是 $\\tau_f$。\n- $x$ 的类型是 $\\alpha$。\n- 表达式 $(\\mathrm{foldr}\\ f\\ z\\ xs')$ 的类型是 $\\tau_{rec}$。\n该应用要求 $\\tau_f$ 是一个接受 $x$ 和递归调用结果的函数。设此分支的最终类型为 $\\tau_{branch2}$。这产生以下约束：\n(3) $\\tau_f = \\alpha \\to \\tau_{rec} \\to \\tau_{branch2}$。\n\n两个分支的类型必须相等。分支 1 的类型是 $\\tau_z$。\n(4) $\\tau_{branch2} = \\tau_z$。\n\n整个 $\\mathrm{case}$ 表达式的类型 $\\tau_{case}$就是这个共同的分支类型。\n(5) $\\tau_{case} = \\tau_z$。\n\n**步骤 3：求解约束系统。**\n为 $\\mathrm{let\\ rec}$ 的主体（整个 lambda 表达式）推断出的类型是 $\\tau_E = \\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$。\n$\\mathrm{let\\ rec}$ 的规则要求我们将假定的类型 $\\tau_{fr}$ 与推断出的类型 $\\tau_E$ 进行合一：\n(6) $\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\tau_{xs} \\to \\tau_{case}$。\n\n现在我们将我们的发现代入这个中心方程。\n使用 (1) $\\tau_{xs} = \\mathrm{List}\\ \\alpha$ 和 (5) $\\tau_{case} = \\tau_z$，方程 (6) 变为：\n$\\tau_{fr} = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z$。\n\n我们有两个关于 $\\tau_{fr}$ 的表达式，分别来自 (2) 和上面这行。我们必须将它们合一：\n$$\n\\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z = \\tau_f \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_{rec}\n$$\n当且仅当它们的组成部分类型能够合一时，此合一才能成功。这意味着：\n(7) $\\tau_z = \\tau_{rec}$。\n\n现在我们可以使用这个新信息来简化我们的其他约束。\n将 (4) $\\tau_{branch2} = \\tau_z$ 和 (7) $\\tau_{rec} = \\tau_z$ 代入 (3)：\n$\\tau_f = \\alpha \\to \\tau_z \\to \\tau_z$。\n\n我们现在已经解决了所有相互依赖关系。让我们将 $\\tau_f$ 的最终形式代回到我们关于 $\\tau_{fr}$ 的表达式中：\n$$\n\\tau_{fr} = (\\alpha \\to \\tau_z \\to \\tau_z) \\to \\tau_z \\to \\mathrm{List}\\ \\alpha \\to \\tau_z\n$$\n这是 $\\mathrm{foldr}$ 的最通用单类型。\n\n**步骤 4：泛化以找到主类型模式。**\n此表达式中的类型变量是 $\\alpha$ 和 $\\tau_z$。由于这是一个顶层定义，初始上下文为空，因此没有自由变量来限制泛化。我们可以对 $\\alpha$ 和 $\\tau_z$ 进行全称量化。按照惯例，我们将它们重命名为 $\\alpha$ 和 $\\beta$。$\\mathrm{foldr}$ 的主类型模式是：\n$$\n\\forall \\alpha, \\beta.\\ (\\alpha \\to \\beta \\to \\beta) \\to \\beta \\to \\mathrm{List}\\ \\alpha \\to \\beta\n$$\n\n**步骤 5：计算 M 和 V。**\n我们需要找到 $V$，即不同全称量化类型变量的数量，和 $M$，即箭头构造器（$\\to$）的总数。\n\n-   $V$：量化的变量是 $\\alpha$ 和 $\\beta$。共有 $2$ 个不同的变量。\n    $$ V = 2 $$\n\n-   $M$：我们计算类型 $(\\alpha \\to \\beta \\to \\beta) \\to \\beta \\to \\mathrm{List}\\ \\alpha \\to \\beta$ 中箭头构造器 $\\to$ 的出现次数。\n    为了清晰起见，我们用完全括号化的形式来写它，记住 $\\to$ 是右结合的：\n    $$ ((\\alpha \\to (\\beta \\to \\beta))) \\to (\\beta \\to ((\\mathrm{List}\\ \\alpha) \\to \\beta)) $$\n    我们可以数出箭头：\n    1.  第一个参数类型中的 $\\alpha \\to (\\dots)$。\n    2.  第一个参数类型中的 $\\beta \\to \\beta$。\n    3.  分隔第一个参数和函数类型其余部分的主箭头。\n    4.  分隔第二个参数 $\\beta$ 和其余部分的箭头。\n    5.  分隔第三个参数 $\\mathrm{List}\\ \\alpha$ 和最终结果类型的箭头。\n    箭头总数是 $M = 1+1+1+1+1=5$。\n    $$ M = 5 $$\n\n**步骤 6：计算 P。**\n问题要求计算 $P = M \\times V$ 的值。\n$$ P = 5 \\times 2 = 10 $$\nP 的值是 $10$。", "answer": "$$\n\\boxed{10}\n$$", "id": "3624329"}, {"introduction": "理论知识最终需要通过实践来巩固。这个练习将带你从“使用者”转变为“构建者”，亲手实现一个微型的类型约束求解器。通过将类型表示为域（允许的类型集合），并将约束求解实现为集合的交集运算，你将对类型变量如何被约束和具体化有一个具体的操作性理解。这个练习旨在揭开类型检查器内部工作的神秘面紗。[@problem_id:3624368]", "problem": "设计并实现一个完整、可运行的程序，该程序通过为简单类型lambda演算表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$ 求解类型约束来执行基本的类型推断。其中，$==$ 表示内置的等号运算符，其使用被限制在一组特定的类型上。该程序必须使用编译器原理和程序设计语言理论中的以下基本基础：简单类型lambda演算、类型变量、类型环境以及通过对类型进行约束满足的合一（unification）。\n\n从以下核心定义和事实出发：\n- 类型环境将项变量与类型变量或具体类型关联起来。对于表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$，绑定子为 $x$ 和 $y$ 引入新的类型变量，表示为 $\\alpha$ 和 $\\beta$。\n- 在简单类型lambda演算中，$==$ 的类型规则要求两个操作数具有相同的类型，并且该运算符返回一个布尔值结果。运算符 $==$ 仅在一组指定的允许类型上定义，我们将其表示为 $S$。\n- 类型约束的合一通过求解类型之间的方程（例如，$\\alpha = \\beta$）以及域限制（例如，$\\alpha \\in S$，$\\beta \\in S$）来执行，使用在允许域上的集合论交集。\n\n在此任务中，$S$ 固定为 $S = \\{\\text{Int}, \\text{Bool}\\}$，并且只有当两个操作数都是来自 $S$ 的相同类型时，$==$ 才是类型正确的。因此，表达式主体 $(x == y)$ 为 $x$ 和 $y$ 的操作数类型生成了约束 $\\alpha = \\beta$、$\\alpha \\in S$ 和 $\\beta \\in S$。从第一性原理出发，求解这些约束可归结为计算 $\\alpha$ 和 $\\beta$ 的允许域与 $S$ 的交集。如果交集为空，则在给定假设下，$(x == y)$ 没有有效的类型。如果交集非空，则交集中的每个元素都为 $x$ 和 $y$ 提供了一个有效的实例化，并且整个表达式是类型正确的，其中 $==$ 产生一个布尔值结果。\n\n你的程序必须为此场景实现一个小型约束求解器，其具体行为如下：\n- 使用整数代码表示类型：$0 \\mapsto \\text{Int}$，$1 \\mapsto \\text{Bool}$，$2 \\mapsto \\text{Float}$，以及 $3 \\mapsto \\text{Var}$，其中 $\\text{Var}$ 表示在应用约束之前未受约束的类型变量。只有 $\\text{Int}$ 和 $\\text{Bool}$ 是 $==$ 的允许类型；包含 $\\text{Float}$ 仅用于测试失败场景。\n- 给定 $x$ 和 $y$ 的初始标注（每个标注为 $0$、$1$、$2$ 或 $3$ 中的一个），求解器必须：\n    1. 将 $3$（即 $\\text{Var}$）解释为具有域 $S$。\n    2. 将具体标注 $0$、$1$ 和 $2$ 分别解释为单例域 $\\{\\text{Int}\\}$、$\\{\\text{Bool}\\}$ 和 $\\{\\text{Float}\\}$。\n    3. 通过将 $x$ 和 $y$ 的域与 $S$ 求交集，然后将结果域彼此求交集，来强制执行等式约束 $\\alpha = \\beta$ 和允许性约束 $\\alpha \\in S$, $\\beta \\in S$。\n    4. 返回交集中可能的操作数类型代码列表，该列表仅限于 $S$ 中的类型。如果没有解，则返回空列表 $[]$。\n\n定义并运行以下参数值的测试套件。每个测试用例都是一对 $(x\\_\\text{init}, y\\_\\text{init})$，其代码如上所述，旨在覆盖一般情况和边界情况：\n- 测试用例 1：$(3, 3)$，$x$ 和 $y$ 均为无约束类型变量。\n- 测试用例 2：$(0, 3)$，$x$ 标注为 $\\text{Int}$，$y$ 无约束。\n- 测试用例 3：$(1, 1)$，$x$ 和 $y$ 均标注为 $\\text{Bool}$。\n- 测试用例 4：$(0, 1)$，$x$ 标注为 $\\text{Int}$，$y$ 标注为 $\\text{Bool}$。\n- 测试用例 5：$(2, 3)$，$x$ 标注为 $\\text{Float}$（不允许的类型），$y$ 无约束。\n\n你的程序应生成单行输出，其中包含一个由方括号括起来的、逗号分隔的结果列表，每个测试用例的结果本身是一个由方括号括起来的、逗号分隔的列表，其中包含与操作数类型解相对应的允许代码。例如，如果计算出的解是上述测试套件的解，则有效的输出格式为 $[[0,1],[0],[1],[],[]]$。不涉及单位或角度。所有输出均为整型代码，空列表表示没有有效解。\n\n程序必须是自包含的，不需要任何输入，并精确打印指定测试套件的聚合结果列表。求解器必须使用基于原则的类型域合一方法，在约束 $\\alpha = \\beta$、$\\alpha \\in S$ 和 $\\beta \\in S$ 下实现，并且除了测试用例参数和允许集 $S$ 外，不得依赖于硬编码的逐案处理结果。", "solution": "此问题要求设计并实现一个程序，为简单类型lambda演算表达式 $\\lambda x.\\,\\lambda y.\\,(x == y)$ 执行基本的类型推断。此任务属于编译器理论和程序设计语言语义学的范畴，特别关注类型系统和基于约束的合一。问题的核心是求解一个从表达式结构及其运算符的类型规则派生出的类型约束系统。\n\n表达式为 $\\lambda x.\\,\\lambda y.\\,(x == y)$。在简单类型lambda演算中，此表达式定义了一个函数，它接受两个参数 $x$ 和 $y$，并比较它们是否相等。类型推断过程首先为由lambda抽象引入的项变量分配新的类型变量。设 $x$ 的类型为 $\\alpha$，$y$ 的类型为 $\\beta$。类型环境 $\\Gamma$ 最初填充为 $\\Gamma = \\{x : \\alpha, y : \\beta\\}$。\n\n函数的主体是表达式 $(x == y)$。等号运算符 $==$ 的类型规则对其操作数的类型施加了约束。根据规定，该运算符要求两个操作数具有相同的类型，并且此类型必须属于一个预定义的允许类型集合，表示为 $S$。运算符本身被定义为返回一个 $\\text{Bool}$ 类型的结果。这些语义生成了以下约束集：\n1. 操作数类型相等：$\\alpha = \\beta$。\n2. 第一个操作数类型的允许性：$\\alpha \\in S$。\n3. 第二个操作数类型的允许性：$\\beta \\in S$。\n\n$==$ 运算符的允许类型集合为 $S = \\{\\text{Int}, \\text{Bool}\\}$。问题要求我们使用整数代码来表示这些类型以及其他类型：$0 \\mapsto \\text{Int}$，$1 \\mapsto \\text{Bool}$，以及 $2 \\mapsto \\text{Float}$。代码 $3$ 表示一个无约束的类型变量，记为 $\\text{Var}$。通过这种编码，允许集 $S$ 对应于代码集合 $S_{code} = \\{0, 1\\}$。\n\n问题简化为针对 $\\alpha$ 和 $\\beta$ 的不同初始标注求解这些约束。我们可以使用集合论来对类型和约束进行建模。每个类型变量都与一个域相关联，该域是其可以实例化的可能具体类型的集合。然后通过集合交集运算来执行约束求解。\n\n设 $D_x$ 是 $x$（类型 $\\alpha$）的初始可能类型域，$D_y$ 是 $y$（类型 $\\beta$）的初始域。这些初始域由提供的标注确定：\n- 对于具体类型标注（代码 $0, 1, 2$），域是一个单例集。例如，如果 $x$ 标注为 $\\text{Int}$（代码 $0$），则 $D_x = \\{\\text{Int}\\} = \\{0\\}$。\n- 对于类型变量标注（代码 $3$），问题规定其域被解释为允许集 $S$。因此，如果 $x$ 标注为 $\\text{Var}$，则 $D_x = S = \\{\\text{Int}, \\text{Bool}\\} = \\{0, 1\\}$。\n\n$x$ 和 $y$ 的允许类型的总体解是同时满足所有三个约束的类型集合。约束 $\\alpha \\in S$ 和 $\\beta \\in S$ 将域 $D_x$ 和 $D_y$ 分别限制为 $D_x \\cap S_{code}$ 和 $D_y \\cap S_{code}$。相等约束 $\\alpha = \\beta$ 要求最终类型必须对两者都是公共的，这通过对它们受限的域求交集来实现。因此，有效解的最终域 $D_{sol}$ 为：\n$$ D_{sol} = (D_x \\cap S_{code}) \\cap (D_y \\cap S_{code}) $$\n根据集合交集的结合律和交换律，这等价于：\n$$ D_{sol} = D_x \\cap D_y \\cap S_{code} $$\n空集 $D_{sol} = \\emptyset$ 表示对于给定的初始标注，约束是不可满足的，表达式是类型错误的。\n\n我们现在将此过程应用于每个测试用例。\n\n**测试用例 1：** $(x_\\text{init}, y_\\text{init}) = (3, 3)$。$x$ 和 $y$ 都是无约束变量 ($\\text{Var}$)。\n- $x$ 的初始域：$D_x = D(3) = \\{0, 1\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 允许集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0, 1\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0, 1\\}$。\n- 结果代码：$[0, 1]$。\n\n**测试用例 2：** $(x_\\text{init}, y_\\text{init}) = (0, 3)$。$x$ 是 $\\text{Int}$，$y$ 是 $\\text{Var}$。\n- $x$ 的初始域：$D_x = D(0) = \\{0\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 允许集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\{0\\}$。\n- 结果代码：$[0]$。\n\n**测试用例 3：** $(x_\\text{init}, y_\\text{init}) = (1, 1)$。$x$ 和 $y$ 都是 $\\text{Bool}$。\n- $x$ 的初始域：$D_x = D(1) = \\{1\\}$。\n- $y$ 的初始域：$D_y = D(1) = \\{1\\}$。\n- 允许集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{1\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\{1\\}$。\n- 结果代码：$[1]$。\n\n**测试用例 4：** $(x_\\text{init}, y_\\text{init}) = (0, 1)$。$x$ 是 $\\text{Int}$，$y$ 是 $\\text{Bool}$。\n- $x$ 的初始域：$D_x = D(0) = \\{0\\}$。\n- $y$ 的初始域：$D_y = D(1) = \\{1\\}$。\n- 允许集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{0\\} \\cap \\{1\\} \\cap \\{0, 1\\} = \\emptyset$。\n- 结果代码：$[]$。\n\n**测试用例 5：** $(x_\\textinit}, y_\\text{init}) = (2, 3)$。$x$ 是 $\\text{Float}$，$y$ 是 $\\text{Var}$。\n- $x$ 的初始域：$D_x = D(2) = \\{2\\}$。\n- $y$ 的初始域：$D_y = D(3) = \\{0, 1\\}$。\n- 允许集：$S_{code} = \\{0, 1\\}$。\n- 解：$D_{sol} = D_x \\cap D_y \\cap S_{code} = \\{2\\} \\cap \\{0, 1\\} \\cap \\{0, 1\\} = \\emptyset$。$\\{2\\}$ 与 $\\{0, 1\\}$ 中任意一个的交集都为空。\n- 结果代码：$[]$。\n\n程序将实现这种基于集合的逻辑。域将表示为布尔标志数组，而交集将通过在这些数组上执行逻辑与运算来实现。最终输出将所有测试用例的结果聚合成指定的格式。", "answer": "[[0,1],[0],[1],[],[]]", "id": "3624368"}]}