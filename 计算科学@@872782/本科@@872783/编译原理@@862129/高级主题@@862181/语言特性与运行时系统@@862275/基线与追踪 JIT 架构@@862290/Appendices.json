{"hands_on_practices": [{"introduction": "要理解追踪 JIT (Just-In-Time) 编译器的威力，最好的方法莫过于量化其性能优势。基线 JIT 必须生成能够处理任何数据类型的通用代码，这通常会带来额外开销，例如本例中处理 NaN 装箱值所需的掩码操作。本练习 ([@problem_id:3623717]) 将指导你计算和比较基线 JIT 和专用整数追踪的成本，让你亲身体会到追踪技术如何通过在热循环内部消除类型检查和转换开销来摊销其边界成本，从而实现显著的性能提升。", "problem": "一个动态语言运行时在 $64$ 位架构上使用“非数值”(Not a Number, NaN)装箱技术，将所有值表示在单个机器字中。在此方案中，整数存储在字的低 $32$ 位，并使用高位的静默 NaN 模式进行标记。掩码操作定义为在算术运算之前或之后应用单个按位掩码来选择字的低 $32$ 位，它通过与一个常量掩码进行一次逻辑运算来实现。一个基线即时(Just-In-Time, JIT)编译器为两个动态类型值的加法生成通用代码，过程如下：对每个操作数执行一次掩码操作以提取整数有效载荷，执行整数加法，然后应用一次掩码操作以确保结果在重新标记前被截断为 $32$ 位。因此，当两个操作数都是整数时，基线 JIT 每次动态加法恰好执行 $3$ 次掩码操作。\n\n一个追踪 JIT 记录一个热循环，并沿着一条轨迹将其特化为整数运算。在轨迹内部，值保持未装箱状态，内部的算术运算不执行掩码操作。然而，在轨迹边界处，追踪 JIT 必须应用掩码，在入口处将值从装箱转换为未装箱，在出口处从未装箱转换为装箱。假设该循环每次迭代有 $n$ 次算术加法，并且每次进入和退出轨迹时，有 $v$ 个整数活跃值穿过轨迹边界，这导致入口处产生 $v$ 次掩码操作，出口处也产生 $v$ 次掩码操作。假设轨迹执行的迭代次数服从一个独立的几何分布，其参数为 $s$（每次迭代因守卫失败而退出轨迹的概率），然后重新进入；也就是说，在稳态下，每次迭代都以概率 $s$ 独立地结束当前的轨迹运行。\n\n给定以下具体参数：$n = 30$，$v = 3$，以及 $s = 0.05$，请从第一性原理推导，在许多循环迭代的稳态下，当使用特化整数轨迹而非基线 JIT 时，每次算术加法所消除的掩码操作的期望数量。将你的答案四舍五入到四位有效数字。", "solution": "该问题要求我们计算，与基线 JIT 相比，当一个特化的追踪即时(Just-In-Time, JIT)编译器用于热循环时，每次算术加法所消除的掩码操作的期望数量。该比较应在稳态下进行。\n\n设 $C_{base}$ 为基线 JIT 每次加法操作的掩码操作次数。根据问题陈述，有 $C_{base} = 3$。\n设 $n$ 为每次循环迭代的算术加法次数，给定为 $n = 30$。\n设 $v$ 为穿过轨迹边界的活跃整数值的数量，给定为 $v = 3$。\n设 $s$ 为每次迭代退出轨迹的概率，给定为 $s = 0.05$。\n\n待求的量是在稳态下每次加法所消除的掩码操作的期望数量。这最好通过计算系统执行的一个代表性周期内，消除的掩码总期望数与加法总期望数的比率来得出。一个自然的周期是一次完整的轨迹运行，从进入到退出。\n\n设 $K$ 为单次轨迹运行中执行的迭代次数的随机变量。问题陈述，每次迭代都以概率 $s$ 独立地结束轨迹运行。这描述了一个几何分布。执行恰好 $k$ 次迭代的概率是成功完成 $k-1$ 次迭代（每次概率为 $1-s$）然后在第 $k$ 次迭代时未能继续（概率为 $s$）的概率。\n因此，$K$ 的概率质量函数为：\n$$ P(K=k) = (1-s)^{k-1}s, \\quad \\text{for } k \\in \\{1, 2, 3, \\dots\\} $$\n这是一个标准的几何分布。$K$ 的期望值推导如下：\n$$ E[K] = \\sum_{k=1}^{\\infty} k P(K=k) = \\sum_{k=1}^{\\infty} k (1-s)^{k-1}s $$\n提出因子 $s$ 并使用已知的算术-几何级数求和公式 $\\sum_{k=1}^{\\infty} k x^{k-1} = \\frac{1}{(1-x)^2}$，其中 $x = 1-s$：\n$$ E[K] = s \\sum_{k=1}^{\\infty} k (1-s)^{k-1} = s \\left( \\frac{1}{(1-(1-s))^2} \\right) = s \\left( \\frac{1}{s^2} \\right) = \\frac{1}{s} $$\n每次轨迹运行的期望迭代次数是 $E[K] = \\frac{1}{s}$。\n\n现在，我们计算一个完整轨迹周期内的加法和掩码操作的期望数量。\n\n1.  **每个周期的期望加法次数 ($E[A]$):**\n    每次迭代执行 $n$ 次加法。一次包含 $K$ 次迭代的轨迹运行执行 $nK$ 次加法。期望加法次数为：\n    $$ E[A] = E[nK] = n E[K] = \\frac{n}{s} $$\n\n2.  **基线 JIT 每个周期的期望掩码次数 ($E[M_{base}]$):**\n    基线 JIT 每次加法执行 $3$ 次掩码操作。对于一次迭代中的 $n$ 次加法，它执行 $3n$ 次掩码操作。在一次包含 $K$ 次迭代的轨迹运行中，总掩码次数将是 $3nK$。期望掩码次数为：\n    $$ E[M_{base}] = E[3nK] = 3n E[K] = \\frac{3n}{s} $$\n\n3.  **追踪 JIT 每个周期的期望掩码次数 ($E[M_{trace}]$):**\n    追踪 JIT 在每次轨迹运行时产生的掩码次数是固定的，与其长度 $K$ 无关。入口处有 $v$ 次掩码操作，出口处有 $v$ 次掩码操作。轨迹内部的算术运算不使用掩码。任何一次轨迹运行的总掩码次数是恒定的：\n    $$ M_{trace} = v + v = 2v $$\n    因此，期望掩码次数为：\n    $$ E[M_{trace}] = E[2v] = 2v $$\n\n每个周期消除的期望掩码次数是基线 JIT 和追踪 JIT 成本之间的差值：\n$$ E[M_{elim}] = E[M_{base}] - E[M_{trace}] = \\frac{3n}{s} - 2v $$\n\n最终的度量指标是每次算术加法所消除的期望掩码次数。这是一周期内消除的总期望掩码数与总期望加法数的比率：\n$$ E_{elim/add} = \\frac{E[M_{elim}]}{E[A]} = \\frac{\\frac{3n}{s} - 2v}{\\frac{n}{s}} $$\n简化此表达式：\n$$ E_{elim/add} = \\left(\\frac{3n}{s} - 2v\\right) \\frac{s}{n} = \\frac{3n}{s} \\frac{s}{n} - 2v \\frac{s}{n} = 3 - \\frac{2vs}{n} $$\n这是从第一性原理推导出的公式。\n\n现在，我们代入给定的数值：$n = 30$，$v = 3$，以及 $s = 0.05$。\n$$ E_{elim/add} = 3 - \\frac{2 \\times 3 \\times 0.05}{30} $$\n$$ E_{elim/add} = 3 - \\frac{6 \\times 0.05}{30} $$\n$$ E_{elim/add} = 3 - \\frac{0.3}{30} $$\n$$ E_{elim/add} = 3 - 0.01 $$\n$$ E_{elim/add} = 2.99 $$\n问题要求答案四舍五入到四位有效数字。值 $2.99$ 有三位有效数字。为了用四位表示，我们追加一个零。\n$$ E_{elim/add} \\approx 2.990 $$\n这表示当使用追踪 JIT 而非基线 JIT 时，在热循环内执行的每次加法平均节省的掩码次数。", "answer": "$$\\boxed{2.990}$$", "id": "3623717"}, {"introduction": "除了类型特化，现代 JIT 编译器还利用更激进的策略——推测性优化。编译器会“赌”一个高概率事件将会发生（例如，整数加法不会溢出），并生成一条极快的代码路径；如果赌错了，则通过一个昂贵的“慢路径”来纠正。这个练习 ([@problem_id:3623726]) 让你扮演编译器设计者的角色，通过推导“盈亏平衡点”的溢出概率 $ \\rho^* $，来精确地确定这种推测在何时是值得的。这种基于期望值的成本收益分析是决定 JIT 编译器优化策略的核心方法。", "problem": "一个动态语言运行时在一个紧凑循环中实现 $64$ 位有符号整数的加法，该循环执行许多形式为 $a+b$ 的动态加法。比较了两种即时（JIT）编译策略：\n\n1. 一种基线即时（JIT）编译器，它总是生成一个内联的、带溢出检查的加法。当没有溢出发生时，动态加法的平均成本为 $B_{n}$ 个周期。当发生溢出时，其平均成本为 $B_{o}$ 个周期。任何给定的动态加法发生溢出事件的概率为 $\\rho$，该事件是独立的，其中 $0  \\rho  1$。\n\n2. 一种追踪即时（JIT）编译器，它推测 $a+b$ 不会溢出，并生成一个由去优化守卫保护的、不带检查的加法。当没有溢出发生时，动态加法的平均成本为 $T_{n}$ 个周期。当发生溢出时，守卫失败并触发去优化；动态加法的平均成本为 $T_{o}$ 个周期。任何给定的动态加法发生溢出事件的情况与上述相同，其发生概率为 $\\rho$，并且在各次加法之间是独立的。\n\n假设处于稳态执行，没有预热效应，并使用全期望定律为每次动态加法的期望周期数建模。将 $B_{n}$、$B_{o}$、$T_{n}$ 和 $T_{o}$ 视为固定的正常数，它们反映了包括分支预测、流水线行为和慢速路径处理在内的微架构效应，且满足 $B_{o} > B_{n}$ 和 $T_{o} > T_{n}$。\n\n从期望值的定义出发，并且不调用任何专门的性能公式，推导出一个闭式解析表达式，用于表示收支平衡的溢出概率 $\\rho^{*}$。在该概率下，基线 JIT 和追踪 JIT 每次动态加法的期望周期数相等。你的最终答案必须是仅包含 $B_{n}$、$B_{o}$、$T_{n}$ 和 $T_{o}$ 的单个简化解析表达式。不需要进行数值计算。将最终答案表示为不带单位的单个表达式。", "solution": "目标是找到收支平衡的溢出概率 $\\rho^{*}$，在该概率下，基线 JIT 和追踪 JIT 每次动态加法的期望周期数相同。我们将从全期望定律出发，为每种策略定义期望成本。\n\n设 $C_B$ 为随机变量，表示由基线 JIT 执行的单次动态加法的周期成本。每次加法有两个互斥的结果：\n1.  没有溢出发生。这发生的概率为 $1 - \\rho$。成本为 $B_{n}$ 个周期。\n2.  发生溢出。这发生的概率为 $\\rho$。成本为 $B_{o}$ 个周期。\n\n根据全期望定律，基线 JIT 的期望成本 $E[C_B]$ 是每个结果的成本与其各自概率加权的和：\n$$E[C_B] = B_{n} \\cdot P(\\text{no overflow}) + B_{o} \\cdot P(\\text{overflow})$$\n$$E[C_B] = B_{n}(1 - \\rho) + B_{o}\\rho$$\n\n类似地，设 $C_T$ 为随机变量，表示由追踪 JIT 执行的单次加法的周期成本。两个结果是：\n1.  没有溢出发生，且推测成功。这发生的概率为 $1 - \\rho$。成本为 $T_{n}$ 个周期。\n2.  发生溢出，守卫失败，并触发去优化。这发生的概率为 $\\rho$。成本为 $T_{o}$ 个周期。\n\n追踪 JIT 的期望成本 $E[C_T]$ 为：\n$$E[C_T] = T_{n} \\cdot P(\\text{no overflow}) + T_{o} \\cdot P(\\text{overflow})$$\n$$E[C_T] = T_{n}(1 - \\rho) + T_{o}\\rho$$\n\n收支平衡点发生在期望成本相等的概率 $\\rho^{*}$ 处：\n$$E[C_B] = E[C_T]$$\n代入期望值的表达式，我们得到：\n$$B_{n}(1 - \\rho^{*}) + B_{o}\\rho^{*} = T_{n}(1 - \\rho^{*}) + T_{o}\\rho^{*}$$\n\n现在我们求解这个方程以得到 $\\rho^{*}$。首先，展开各项：\n$$B_{n} - B_{n}\\rho^{*} + B_{o}\\rho^{*} = T_{n} - T_{n}\\rho^{*} + T_{o}\\rho^{*}$$\n\n接下来，将所有包含 $\\rho^{*}$ 的项移到方程的一边，常数项移到另一边：\n$$B_{o}\\rho^{*} - B_{n}\\rho^{*} + T_{n}\\rho^{*} - T_{o}\\rho^{*} = T_{n} - B_{n}$$\n\n从左边提取公因子 $\\rho^{*}$：\n$$\\rho^{*}(B_{o} - B_{n} + T_{n} - T_{o}) = T_{n} - B_{n}$$\n\n最后，通过除以其系数来分离出 $\\rho^{*}$，假设分母不为零：\n$$\\rho^{*} = \\frac{T_{n} - B_{n}}{B_{o} - B_{n} + T_{n} - T_{o}}$$\n\n为了使表达式更具可解释性，我们可以重新排列分母：\n$$\\rho^{*} = \\frac{T_{n} - B_{n}}{(B_{o} - B_{n}) - (T_{o} - T_{n})}$$\n将分子和分母同乘以 $-1$ 得出：\n$$\\rho^{*} = \\frac{-(T_{n} - B_{n})}{-( (B_{o} - B_{n}) - (T_{o} - T_{n}) )} = \\frac{B_{n} - T_{n}}{(T_{o} - T_{n}) - (B_{o} - B_{n})}$$\n这个最终形式在物理上是直观的。分子 $B_{n} - T_{n}$ 代表了在普遍情况（无溢出）下，追踪 JIT 所带来的性能增益（周期节省）。分母 $(T_{o} - T_{n}) - (B_{o} - B_{n})$ 代表了与基线 JIT 的溢出惩罚相比，追踪 JIT 在发生溢出事件时产生的额外惩罚。因此，收支平衡概率是这个快速路径增益与额外慢速路径成本之比。", "answer": "$$ \\boxed{\\frac{B_n - T_n}{(T_o - T_n) - (B_o - B_n)}} $$", "id": "3623726"}, {"introduction": "性能优化绝不能以牺牲正确性为代价。当推测性优化的前提不成立时（例如，发生了一次意外的类型变化或算术溢出），JIT 编译器必须能够安全地“去优化”，即放弃快速的机器码，并精确地恢复到解释器在同一程序点的状态。本练习 ([@problem_id:3623731]) 是一个思想实验，旨在让你深入思考正确去优化的本质。通过辨别哪些程序状态（如活动变量、调用栈）是必须恢复的“语义状态”，而哪些仅仅是“实现细节”（如寄存器分配），你将深刻理解保证 JIT 编译器正确性的关键所在。", "problem": "一台用于动态类型语言的虚拟机同时实现了一个基线即时编译器（baseline JIT）和一个追踪即时编译器（tracing JIT）。两种编译器都维护去优化快照：基线JIT在编译后方法的安全点记录快照；追踪JIT将快照附加到追踪中的守卫点，以便失败的守卫可以重建一个解释器帧（或一个帧栈）并在解释器中恢复执行。\n\n你的任务是设计一个快照保真度测试，该测试在强制去优化之前修改局部变量和操作数栈条目，然后检查去优化后的执行是否与从同一程序点由解释器执行的情况完全相同。该测试框架可以在解释器下运行同一程序片段，也可以在JIT下于选定点触发去优化来运行，并且可以在该点读出局部变量和操作数栈的值。\n\n使用以下形式化基础：\n\n- 令解释器的小步操作语义为状态上的关系 $s \\Rightarrow s'$。一个状态 $s$ 是一个元组 $s = \\langle P, \\kappa, \\rho, S, H, M \\rangle$，其中 $P$ 是程序，$\\kappa$ 是带有程序计数器的帧组成的调用栈，$\\rho$ 是将局部变量标识符映射到值的环境， $S$ 是操作数栈， $H$ 是堆， $M$ 是持有的监视器（锁）及其可重入计数的多重集。在一个程序点，解释器可见的状态是投影 $\\pi(s) = \\langle \\kappa, \\rho, S, H, M \\rangle$。\n- 令 $\\mathcal{L}_i$ 为根据对解释器控制流图的标准存活性分析，在字节码索引 $i$ 处的活跃局部变量和栈槽位的集合。原始值的相等性是通常的值相等，而引用的相等性是基于 $H$ 中的对象标识。\n- 令 $T(s)$ 表示从状态 $s$ 在解释器语义下继续执行所产生的外部可观察事件的（可能无限的）序列（例如，I/O，程序可观察到的对 $H$ 的最终存储结果）。\n\n与JIT执行状态 $s_{\\mathrm{jit}}$ 在程序点 $i$ 相关联的去优化快照是正确的，如果它能重建一个解释器状态 $s_{\\mathrm{int}}$，使得 $\\pi(s_{\\mathrm{jit}})$ 和 $\\pi(s_{\\mathrm{int}})$ 在继续执行所需的解释器可见状态上一致，并且 $T(s_{\\mathrm{int}})$ 等于解释器在没有JIT的情况下到达同一点所产生的轨迹。\n\n你的测试在去优化之前修改局部变量和操作数栈条目，然后在去优化时刻断言不变量，并且通过在去优化后继续执行，并与在相应字节码索引处暂停并恢复的纯解释器运行进行比较。\n\n为了可靠地验证去优化能够精确地重建解释器可见状态，对于基线JIT和追踪JIT，快照保真度测试必须断言以下哪些不变量？选择所有适用的选项。\n\nA. 对于活跃集 $\\mathcal{L}_i$ 中的每个元素，去优化后的解释器帧的环境 $\\rho$ 和操作数栈 $S$ 中包含的值，必须与纯解释器执行在字节码索引 $i$ 处的值相等，其中原始值按值相等，引用值按 $H$ 中的对象标识相等。\n\nB. JIT编译的帧中所有机器寄存器和溢出槽位的内容必须与去优化点的一个假设的解释器寄存器分配相匹配；如果任何寄存器不同，测试应失败。\n\nC. 去优化后的帧栈 $\\kappa$（包括从追踪中的内联重建的任何帧）具有与纯解释器调用栈在相应点的调用序列和字节码索引相同的结构，并且持有的监视器 $M$（包括可重入计数）在对象标识和计数上匹配。\n\nD. 不在活跃集 $\\mathcal{L}_i$ 中的局部变量和栈槽位的值也必须与纯解释器执行在字节码索引 $i$ 处的值匹配，以检测可能稍后变得可见的潜在编译错误。\n\nE. 如果在去优化后继续执行，从去优化状态产生的可观察事件轨迹 $T(s_{\\mathrm{int}})$ 等于从在字节码索引 $i$ 处暂停并恢复的纯解释器状态产生的轨迹，即，这两个执行对程序而言是观察上不可区分的。\n\nF. 去优化点的垃圾回收器根集必须与解释器的根集完全相等；JIT在去优化期间保留的任何额外根都表示快照不匹配。\n\n通过选择所有且仅选择验证上述定义的快照保真度所必需的不变量来提供最佳答案。", "solution": "问题要求识别出快照保真度测试为验证从即时（JIT）编译状态到解释器状态的去优化是正确的所必须断言的必要不变量。问题提供了对解释器状态和去优化快照正确性的形式化定义。\n\n如果程序的执行可以从重建的解释器状态继续，就好像它一直是在解释器中运行一样，那么去优化就是正确的。这意味着重建的状态必须在语义上等同于解释器在同一程序点会有的状态，因此，程序的未来可观察行为也必须相同。\n\n问题将解释器状态定义为 $s = \\langle P, \\kappa, \\rho, S, H, M \\rangle$，其中 $P$ 是程序，$\\kappa$ 是调用栈，$\\rho$ 是局部变量的环境， $S$ 是操作数栈， $H$ 是堆， $M$ 是持有的监视器集合。“解释器可见状态”被定义为投影 $\\pi(s) = \\langle \\kappa, \\rho, S, H, M \\rangle$。从JIT状态 $s_{\\mathrm{jit}}$ 到解释器状态 $s_{\\mathrm{int}}$ 的去优化快照的正确性由两个条件定义：\n1.  **状态等价性：** 重建的状态 $s_{\\mathrm{int}}$ 必须与继续执行所需的解释器可见状态一致。问题将此澄清为重建“精确的解释器可见状态”。这意味着 $\\pi(s_{\\mathrm{int}})$ 的组件必须等价于纯解释器状态 $s_{\\mathrm{pure-int}}$ 在同一程序点的组件。\n2.  **行为等价性：** 从重建状态继续执行所产生的外部可观察事件序列 $T(s_{\\mathrm{int}})$ 必须等于解释器本应产生的轨迹 $T(s_{\\mathrm{pure-int}})$。\n\n因此，一个可靠的验证测试必须断言足以建立这两个条件的不变量。测试过程被描述为“在去优化时刻断言不变量，并且通过在去优化后继续执行”来断言。这意味着要同时检查状态和后续行为。\n\n让我们评估每个选项：\n\n**A. 对于活跃集 $\\mathcal{L}_i$ 中的每个元素，去优化后的解释器帧的环境 $\\rho$ 和操作数栈 $S$ 中包含的值，必须与纯解释器执行在字节码索引 $i$ 处的值相等，其中原始值按值相等，引用值按 $H$ 中的对象标识相等。**\n\n-   **分析：** 这个不变量直接测试了解释器可见状态的部分内容：局部变量环境 $\\rho$ 和操作数栈 $S$。未来执行的正确性从根本上取决于将要使用的变量和临时操作数的值。限制在*活跃集* $\\mathcal{L}_i$ 是至关重要的。根据定义，不在活跃集中的变量在其下一次写入之前不会被读取，因此它们的值与程序的未来语义无关。JIT编译器可以自由地忽略或重新利用死变量的存储空间。指定的比较方法——原始值按值比较，引用按对象标识比较——是程序状态语义等价性的标准。这是“在去优化时刻”的一个检查，对于验证数据状态的重建是必要的。\n-   **结论：** 正确。\n\n**B. JIT编译的帧中所有机器寄存器和溢出槽位的内容必须与去优化点的一个假设的解释器寄存器分配相匹配；如果任何寄存器不同，测试应失败。**\n\n-   **分析：** 这个不变量涉及JIT编译代码的实现特定细节（机器寄存器、用于溢出的栈布局）。去优化是从这种低级的、机器特定的表示到解释器的高级的、抽象的表示的转换。JIT的寄存器分配和内存布局是其自身的问题；重要的是它能正确重建抽象的解释器状态。没有“假设的解释器寄存器分配”可供比较，因为解释器是在一个抽象机器模型上操作的。这个检查错误地将实现与规范混为一谈。\n-   **结论：** 错误。\n\n**C. 去优化后的帧栈 $\\kappa$（包括从追踪中的内联重建的任何帧）具有与纯解释器调用栈在相应点的调用序列和字节码索引相同的结构，并且持有的监视器 $M$（包括可重入计数）在对象标识和计数上匹配。**\n\n-   **分析：** 这个不变量测试了解释器可见状态的另外两个关键组件：调用栈 $\\kappa$ 和持有的监视器 $M$。调用栈决定了控制流（例如，`return` 语句将控制权转移到哪里）并为每个活动函数提供上下文。JIT编译器，特别是追踪JIT，经常执行内联，将多个逻辑上的解释器帧编译成单个机器码函数。正确的去优化需要重建原始的解释器帧序列。持有的监视器集合 $M$ 对于正确的并发执行至关重要，确保同步原语按预期工作。这是另一个在“去优化时刻”验证控制和同步状态所必需的检查。\n-   **结论：** 正确。\n\n**D. 不在活跃集 $\\mathcal{L}_i$ 中的局部变量和栈槽位的值也必须与纯解释器执行在字节码索引 $i$ 处的值匹配，以检测可能稍后变得可见的潜在编译错误。**\n\n-   **分析：** 这是一个过于严格的条件。如选项A中所解释，死变量的值不影响程序的未来执行。要求它们与解释器的状态匹配对于语义正确性来说不是必需的。JIT编译器可以合法地将死变量槽位用于其自身的目的（例如，存储不同类型的中间结果），并且没有义务保留它们的原始值。强制这种匹配会惩罚正确且高效的编译器实现。\n-   **结论：** 错误。\n\n**E. 如果在去优化后继续执行，从去优化状态产生的可观察事件轨迹 $T(s_{\\mathrm{int}})$ 等于从在字节码索引 $i$ 处暂停并恢复的纯解释器状态产生的轨迹，即，这两个执行对程序而言是观察上不可区分的。**\n\n-   **分析：** 这个不变量直接对应于问题中正确性定义的第二部分：行为等价性，$T(s_{\\mathrm{int}}) = T(s_{\\mathrm{pure-int}})$。这是保真度的最终测试。虽然正确的状态重建（由A和C检查）应该意味着正确的未来行为，但这个检查对于*可靠的*验证是必要的。它可以检测到那些从栈状态中不明显可见的微妙错误，例如对堆 $H$ 或属于完整状态 $s$ 但未被选项A和C直接检查的其他系统状态的错误修改。问题指出测试框架“在去优化后继续执行并比较”，表明这是验证的预定部分。因此，这是一个必须断言的必要不变量。\n-   **结论：** 正确。\n\n**F. 去优化点的垃圾回收器根集必须与解释器的根集完全相等；JIT在去优化期间保留的任何额外根都表示快照不匹配。**\n\n-   **分析：** 垃圾回收（GC）根集包括所有可从其到达存活对象的引用。该集合来源于 $\\rho$、 $S$ 中的活跃变量以及任何全局/静态变量。选项A已经确保了所有从解释器角度看是活跃的引用都被正确恢复。JIT可能出于实现原因，在寄存器或内存中保留引用的时间比它们在程序角度上严格存活的时间更长。这被称为保守根。只要JIT的根集是解释器所需根集的超集，就不会有存活对象被错误地回收。要求完全相等过于严格，并且会禁止常见的、正确的编译器优化。它会导致对正确程序的测试失败。\n-   **结论：** 错误。\n\n总之，如上所述的可靠且全面的快照保真度测试必须验证去优化时刻解释器可见状态的核心组件（A和C），并且还要验证这个重建的状态能导致正确的未来行为（E），后者作为一个整体性检查，并且是正确性形式化定义的一部分。", "answer": "$$\\boxed{ACE}$$", "id": "3623731"}]}