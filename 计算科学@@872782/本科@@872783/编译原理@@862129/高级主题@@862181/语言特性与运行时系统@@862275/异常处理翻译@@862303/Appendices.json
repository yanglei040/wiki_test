{"hands_on_practices": [{"introduction": "正确翻译异常处理的复杂控制流是编译器的首要职责。第一个实践聚焦于一个经典且棘手的场景：一个包含提前 `return` 语句的 `try-finally` 代码块。你将分析几种底层代码翻译方案，以找出唯一能够正确保持语言语义的方案，确保 `finally` 块总能被执行，同时又能回到最初的出口路径 [@problem_id:3641508]。这个练习强调了编译器需要使用状态管理机制（如标志位）来引导清理代码完成后的控制流。", "problem": "一个用于支持结构化异常处理的高级语言的编译器，必须翻译一种将 `try` 块内的提前 `return` 与 `finally` 子句相结合的结构。`try-finally` 的语义定义是以下基本原则：在任何退出受保护区域（正常执行到底、`return`、`break`、`continue` 或异常）时，`finally` 块必须执行且仅执行一次，然后控制流继续，如同原始的退出已经发生一样。唯一的例外是，如果 `finally` 块本身抛出异常，那么该异常将取代之前的退出。\n\n考虑以下源过程，其中 `cleanup` 可能会抛出异常：\n\nint g(int x) {\n  try {\n    if (x < 0) return -1;\n    x = x + 1;\n  } finally {\n    cleanup(x);\n  }\n  return x;\n}\n\n编译器会将其降低（lower）到一种低级中间表示（IR），该 IR 具有显式标签 $L_{\\cdot}$、无条件分支 `goto`、条件分支 `if(·) goto` 和 `return` 语句。该 IR 还具有简单的三地址赋值 `:=`, 一个布尔标志 $f \\in \\{0,1\\}$（除非另有说明，否则初始化为 $0$），以及一个用于保存待定返回值的整数临时变量 $r$。调用（如 `cleanup(x)`）可能会抛出异常；如果调用抛出异常，控制流将不会执行该块中后续的 IR。IR 中没有隐式的异常处理：在 `cleanup` 期间抛出的异常会立即传播并中止本地控制流；它们不会在此函数中被捕获。\n\n你的任务是确定以下哪个候选翻译正确地执行了上述语义。具体来说，一个正确的翻译必须确保：\n- 如果 `try` 块内的路径执行了提前 `return`，则 `finally` 块执行且仅执行一次，然后函数返回指定的值，除非 `cleanup` 抛出异常，在这种情况下，异常会逸出而不是返回。\n- 如果 `try` 块内的路径正常执行到底，则 `finally` 块执行且仅执行一次，然后控制流返回最终的 `x` 值，除非 `cleanup` 抛出异常，在这种情况下，异常会逸出。\n- 没有任何路径会执行 `cleanup` 多于一次，也没有任何路径会跳过 `cleanup`。\n\n假设 $f$ 和 $r$ 是新分配的临时变量，没有在其他地方使用。选择正确的翻译。\n\n选项 A:\nL0:\n  f := 0;\n  if (x < 0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  if (f == 1) goto Lret; else goto Lnorm;\nLret:\n  return r;\nLnorm:\n  return x;\n\n选项 B:\nL0:\n  f := 0;\n  if (x < 0) goto Lret; else goto Linc;\nLret:\n  r := -1;\n  return r;\nLinc:\n  x := x + 1;\n  cleanup(x);\n  return x;\n\n选项 C:\nL0:\n  f := 0;\n  if (x < 0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return x;\n\n选项 D:\nL0:\n  f := 0;\n  if (x < 0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return r;\n\n哪个选项在所有执行路径下都保留了指定的语义，包括当 `cleanup(x)` 抛出异常时？\n\nA. 选项 A\n\nB. 选项 B\n\nC. 选项 C\n\nD. 选项 D", "solution": "问题要求为包含一个 `try-finally` 块和一个可能的提前 `return` 语句的高级语言函数，找出正确的低级中间表示（IR）。核心语义规则是，在任何退出 `try` 块时，`finally` 块都必须执行且仅执行一次，之后恢复原始的退出操作，除非 `finally` 块本身抛出异常。\n\n让我们首先根据指定的语义分析源过程 `g(x)` 的行为。\n\n```\nint g(int x) {\n  try {\n    if (x  0) return -1;\n    x = x + 1;\n  } finally {\n    cleanup(x);\n  }\n  return x;\n}\n```\n\n通过 `try` 块有两个主要的控制流路径：\n\n1.  **提前返回路径 ($x  0$):**\n    - 条件 $x  0$ 为真。\n    - 遇到语句 `return -1;`。这构成了从 `try` 块的提前退出。\n    - 在函数返回之前，必须执行 `finally` 块。因此，调用 `cleanup(x)`。传递给 `cleanup` 的 `x` 的值是其原始的负数值，因为它没有被修改。\n    - 如果 `cleanup(x)` 成功执行（不抛出异常），则挂起的退出操作 `return -1;` 被完成。函数返回数值 `-1`。\n    - 如果 `cleanup(x)` 抛出异常，则挂起的 `return -1;` 被取代。异常从函数 `g(x)` 中传播出去。\n\n2.  **正常执行到底路径 ($x \\ge 0$):**\n    - 条件 $x  0$ 为假。\n    - 语句 `x = x + 1;` 被执行，`x` 的值增加。\n    - `try` 块执行完毕。这是一个正常的“执行到底”退出。\n    - `finally` 块被执行。`cleanup(x)` 被调用，参数为新的、已增加的 `x` 值。\n    - 如果 `cleanup(x)` 成功执行，控制流继续到 `try-finally` 结构后面的语句，即 `return x;`。函数返回已增加的 `x` 值。\n    - 如果 `cleanup(x)` 抛出异常，语句 `return x;` 永远不会被执行到，异常会从 `g(x)` 中传播出去。\n\n一个到给定 IR 的正确翻译必须复制这种行为。关键的挑战在于，来自 `try` 块内部两条不同路径的控制流必须合并到 `finally` 块的同一段代码中，然后再次分叉以执行正确的后续操作（提前返回或正常执行到底）。这需要一种机制来“记住”哪个后续操作是合适的。为此提供了一个布尔标志 `f`。还提供了一个临时变量 `r` 来保存待定的返回值。\n\n现在，我们将根据这些要求评估每个选项。\n\n**选项 A:**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  if (f == 1) goto Lret; else goto Lnorm;\nLret:\n  return r;\nLnorm:\n  return x;\n```\n\n-   **路径 $x  0$：** 控制流经 `L0` → `Lretprep` → `Lcleanup`。在 `Lretprep`，待定的返回值 `-1` 被存储在 `r` 中，标志 `f` 被设置为 `1` 以表示一个待定的返回。然后用 `x` 的原始值调用 `cleanup(x)`。如果 `cleanup` 成功，测试 `if (f == 1)` 为真，导致跳转到 `Lret`，执行 `return r`。函数返回 `-1`。这是正确的。如果 `cleanup(x)` 抛出异常，执行在 `if` 语句之前中止，异常传播，这也是正确的。\n-   **路径 $x \\ge 0$：** 控制流经 `L0` → `Linc` → `Lcleanup`。在 `Linc`，`x` 的值增加。标志 `f` 保持其初始值 `0`。然后用新的、已增加的 `x` 值调用 `cleanup(x)`。如果 `cleanup` 成功，测试 `if (f == 1)` 为假，导致跳转到 `Lnorm`，执行 `return x`。函数返回已增加的 `x` 值。这是正确的。如果 `cleanup(x)` 抛出异常，执行中止，这也是正确的。\n-   **`cleanup` 的执行：** 在所有通过 `try` 块的非异常路径中，控制流都被无条件地转移到 `Lcleanup`，确保 `cleanup(x)` 只执行一次。\n\n此翻译正确地实现了指定语义的所有方面。\n**结论：正确**\n\n**选项 B:**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lret; else goto Linc;\nLret:\n  r := -1;\n  return r;\nLinc:\n  x := x + 1;\n  cleanup(x);\n  return x;\n```\n\n-   **路径 $x  0$：** 控制流跳转到 `Lret`。函数立即执行 `return r`（返回 `-1`）。`finally` 块的代码 `cleanup(x)` 被完全跳过。这直接违反了基本的 `try-finally` 语义规则。\n**结论：不正确**\n\n**选项 C:**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return x;\n```\n\n-   **路径 $x  0$：** 控制流经 `Lretprep` 到 `Lcleanup`。临时变量 `r` 被正确设置为 `-1`，`f` 被设置为 `1`。然而，在 `cleanup(x)` 执行后，代码无条件地执行 `return x;`。这会返回 `x` 原始的负数值，而不是预期的提前返回的值 `-1`。存储在 `r` 和 `f` 中的信息被忽略了。\n-   **路径 $x \\ge 0$：** 此路径行为正确，执行 `x := x + 1;`，然后 `cleanup(x);`，然后 `return x;`。\n-   由于提前返回路径处理不正确，整个翻译是有缺陷的。\n**结论：不正确**\n\n**选项 D:**\n\n```\nL0:\n  f := 0;\n  if (x  0) goto Lretprep; else goto Linc;\nLretprep:\n  r := -1;\n  f := 1;\n  goto Lcleanup;\nLinc:\n  x := x + 1;\n  goto Lcleanup;\nLcleanup:\n  cleanup(x);\n  return r;\n```\n\n-   **路径 $x \\ge 0$：** 控制流经 `Linc` 到 `Lcleanup`。`x` 的值增加。在 `cleanup(x)` 执行后，代码无条件地执行 `return r;`。然而，在这条路径上，临时变量 `r` 从未被初始化。函数将返回一个未定义或垃圾值，而不是所要求的已增加的 `x` 值。\n-   **路径 $x  0$：** 此路径行为正确。在 `cleanup(x)` 之后，`return r;` 被执行，并且由于 `r` 已被设置为 `-1`，所以返回了正确的值。\n-   由于正常执行到底路径处理不正确，此翻译是有缺陷的。\n**结论：不正确**\n\n根据分析，只有选项 A 在所有执行路径上都正确地实现了指定的语义。它正确地使用了一个标志来区分后续操作，并使用一个临时变量来存储待定的返回值，从而确保 `finally` 块总是被执行，并且采取了正确的后续行动。", "answer": "$$\\boxed{A}$$", "id": "3641508"}, {"introduction": "在保证了语义正确性之后，编译器必须考虑性能和代码大小。本实践将介绍翻译 `finally` 块的两种常见策略：在每个退出点内联复制清理代码，或使用一个共享的清理例程。你将进行一次量化分析，通过推导符号表达式来理解这两种策略在代码大小和控制流复杂度 ($V(G)$) 上的权衡 [@problem_id:3641500]。这是一个应用分析模型来指导编译器优化决策的基础练习。", "problem": "编译器必须将带有保证最终执行的高级构造（例如 Java 的关键字 $finally$）转换为底层控制流。考虑一个单一的结构化区域 $R$，它由一个受保护的计算和一个紧随其后的 $finally$ 代码块组成。受保护的计算可以沿着 $m$ 个不同的出口终止，其中 $m = m_{n} + m_{x}$，$m_{n}$ 是继续到不同接续点的正常出口，$m_{x}$ 是将控制权转移到不同异常处理器的异常出口。编译器在两种翻译策略之间进行选择：\n\n- 策略 $\\mathcal{D}$（复制）：沿着受保护计算的每个出口内联克隆 $finally$ 代码块。运行内联的最终执行代码后，控制权通过单个无条件分支直接转移到出口的目标。\n\n- 策略 $\\mathcal{S}$（共享清理）：生成一个单独的外部清理代码块来实现 $finally$ 代码。受保护区域的每个出口首先执行一次小的标签写入以记录预定目标，然后分支到共享清理代码块。在清理结束时，通过一个多路分派跳转到记录的目标。\n\n假设代码大小的成本模型，其中机器级指令的数量在基本块之间是可加的。设 $finally$ 代码块主体的大小为 $F$。设每个无条件分支的大小为 $j$。在共享清理策略中，设每个出口的标签写入大小为 $t$，清理结束时的多路分派实现为一个跳转表，其总大小为 $d + u m$，其中 $d$ 是固定的表头成本，$u$ 是每个目标的条目成本乘以 $m$。忽略所有其他开销，并假设无论在何处出现无条件分支，都使用相同的大小 $j$。\n\n为了从第一性原理分析对路径结构的影响，我们使用 McCabe 对控制流图（CFG）的圈复杂度的标准定义。对于一个连通的 CFG 组件，McCabe 的圈复杂度 $V$ 定义为 $V = E - N + 2$，其中 $E$ 是边的数量，$N$ 是节点的数量。对于结构化程序，$V$ 等于一加上独立判定点的数量。假设 $finally$ 代码块的主体包含 $s$ 个二元判定点。将具有 $m$ 个备选项的多路分派视为贡献了 $m - 1$ 个独立判定点。\n\n在这些假设下：\n\n1. 推导代码大小增量 $\\Delta S$ 的闭式表达式，$\\Delta S$ 定义为共享清理策略的代码大小减去复制策略的代码大小，用 $F$、$m$、$t$、$d$ 和 $u$ 表示。\n\n2. 推导路径计数增量 $\\Delta P$ 的闭式表达式，$\\Delta P$ 定义为在翻译后的区域上，共享清理策略的圈复杂度减去复制策略的圈复杂度，用 $m$ 和 $s$ 表示。\n\n将您的最终结果以闭式双分量行向量 $\\left(\\Delta S, \\Delta P\\right)$ 的形式给出。不需要进行数值舍入，也不涉及物理单位。最终答案应表示为精确的符号表达式。", "solution": "在尝试求解之前，将首先根据指定标准对问题进行验证。\n\n**问题验证**\n\n**步骤 1：提取已知条件**\n- 一个单一的结构化区域 $R$ 由一个受保护的计算和一个 `finally` 代码块组成。\n- 受保护的计算有 $m$ 个不同的出口。\n- $m = m_{n} + m_{x}$，其中 $m_{n}$ 是正常出口，$m_{x}$ 是异常出口。\n- 策略 $\\mathcal{D}$（复制）：为 $m$ 个出口中的每一个内联克隆 `finally` 代码块。然后通过单个无条件分支转移控制权。\n- 策略 $\\mathcal{S}$（共享清理）：使用一个单独的外部清理代码块。$m$ 个出口中的每一个都执行一次标签写入，并分支到清理代码块。清理以多路分派结束。\n- `finally` 代码块主体的大小：$F$。\n- 无条件分支的大小：$j$。\n- 每个出口的标签写入大小（策略 $\\mathcal{S}$）：$t$。\n- 多路分派的大小（策略 $\\mathcal{S}$）：$d + u m$，其中 $d$ 是固定成本，$u$ 是每个目标的条目成本。\n- McCabe 的圈复杂度：$V = E - N + 2$。\n- 对于结构化程序，$V = 1 + (\\text{独立判定点的数量})$。\n- `finally` 代码块主体中的二元判定点数量：$s$。\n- 具有 $m$ 个备选项的多路分派贡献 $m - 1$ 个独立判定点。\n- 任务是找到代码大小增量 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$ 和路径计数（圈复杂度）增量 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地植根于计算机科学的一个子领域——编译器设计。复制和共享清理这两种策略是实现异常处理和最终化构造（如 Java 的 `finally`）的标准、有据可查的技术。代码大小和圈复杂度的成本模型是简化的，但也是用于编译器优化分析的标准抽象。\n- **良构性：** 所有参数（$F$、$m$、$t$、$d$、$u$、$s$、$j$）都有清晰的定义。目标（推导 $\\Delta S$ 和 $\\Delta P$）是明确的。可以从给定的模型中推导出一个唯一、稳定且有意义的符号解。\n- **客观性：** 问题以精确、形式化的语言陈述，没有主观或基于观点的断言。\n\n该问题不违反任何无效标准。它是在指定领域内一个定义明确、可形式化的问题。其前提是一致且充分的，足以推导出所需的表达式。\n\n**步骤 3：结论与行动**\n问题被视为**有效**。将提供完整的解决方案。\n\n**求解推导**\n\n求解需要推导两个量：从复制策略（$\\mathcal{D}$）转变为共享清理策略（$\\mathcal{S}$）时，代码大小的变化量 $\\Delta S$ 和圈复杂度的变化量 $\\Delta P$。\n\n**第一部分：代码大小增量（$\\Delta S$）的推导**\n\n设 $S_{\\mathcal{D}}$ 是使用策略 $\\mathcal{D}$ 实现 `finally` 的总代码大小，$S_{\\mathcal{S}}$ 是使用策略 $\\mathcal{S}$ 的代码大小。我们定义 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$。受保护计算本身的大小对两种策略是共同的，因此对增量没有贡献。\n\n**策略 $\\mathcal{D}$（复制）的代码大小：**\n在此策略中，大小为 $F$ 的 `finally` 代码块主体为 $m$ 个出口中的每一个都复制了一份。在每个复制的代码块之后，使用一个大小为 $j$ 的无条件分支将控制权转移到相应的出口目标。\n总大小是 $m$ 个复制块的大小和 $m$ 个无条件分支大小的总和。\n$$S_{\\mathcal{D}} = m \\cdot F + m \\cdot j$$\n\n**策略 $\\mathcal{S}$（共享清理）的代码大小：**\n在此策略中，只生成 `finally` 代码块主体的一个副本，贡献大小为 $F$。受保护区域的 $m$ 个出口中的每一个都需要一次标签写入（大小为 $t$）来记录其目的地，然后是一个无条件分支（大小为 $j$）到共享清理块。最后，清理块以一个大小为 $d + um$ 的多路分派结束。\n总大小是这些组件的总和。\n$$S_{\\mathcal{S}} = \\left( \\sum_{i=1}^{m} (t + j) \\right) + F + (d + u m)$$\n$$S_{\\mathcal{S}} = m(t + j) + F + d + u m$$\n$$S_{\\mathcal{S}} = F + mt + mj + d + um$$\n\n**计算增量 $\\Delta S$：**\n现在，我们计算差值 $\\Delta S = S_{\\mathcal{S}} - S_{\\mathcal{D}}$。\n$$\\Delta S = (F + mt + mj + d + um) - (mF + mj)$$\n$mj$ 项被抵消。\n$$\\Delta S = F - mF + mt + d + um$$\n因式分解后，我们得到 $\\Delta S$ 的最终表达式：\n$$\\Delta S = (1 - m)F + m(t + u) + d$$\n\n**第二部分：圈复杂度增量（$\\Delta P$）的推导**\n\n设 $V_{\\mathcal{D}}$ 是策略 $\\mathcal{D}$ 的圈复杂度，$V_{\\mathcal{S}}$ 是策略 $\\mathcal{S}$ 的圈复杂度。我们定义 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。问题陈述中提到，对于结构化代码，圈复杂度 $V$ 可以计算为 $1$ 加上独立判定点的数量。设 $d_{p}$ 是受保护计算内部的判定点数量，这对两种策略是共同的。\n\n**策略 $\\mathcal{D}$（复制）的圈复杂度：**\n`finally` 代码块主体包含 $s$ 个二元判定点。在策略 $\\mathcal{D}$ 中，这个块被复制了 $m$ 次。由于每个副本都在独立的路径上，由 `finally` 逻辑贡献的总判定点数是每个副本中判定点数的总和，即 $m \\cdot s$。图中总的判定点数量是受保护块中的判定点数和 `finally` 机制中的判定点数的总和。\n策略 $\\mathcal{D}$ 的总判定点数 = $d_{p} + m s$。\n因此，圈复杂度为：\n$$V_{\\mathcal{D}} = 1 + (d_{p} + ms)$$\n\n**策略 $\\mathcal{S}$（共享清理）的圈复杂度：**\n在策略 $\\mathcal{S}$ 中，`finally` 代码块主体只有一个副本，贡献了 $s$ 个判定点。此外，根据定义，共享块末尾具有 $m$ 个备选项的多路分派贡献了 $m-1$ 个独立判定点。从受保护区域到共享块的无条件分支不增加判定点。\n策略 $\\mathcal{S}$ 的总判定点数 = $d_{p} + s + (m-1)$。\n因此，圈复杂度为：\n$$V_{\\mathcal{S}} = 1 + (d_{p} + s + m - 1)$$\n\n**计算增量 $\\Delta P$：**\n现在，我们计算差值 $\\Delta P = V_{\\mathcal{S}} - V_{\\mathcal{D}}$。\n$$\\Delta P = (1 + d_{p} + s + m - 1) - (1 + d_{p} + ms)$$\n公共项 $1 + d_{p}$ 被抵消。\n$$\\Delta P = (s + m - 1) - ms$$\n因式分解后，我们得到 $\\Delta P$ 的最终表达式：\n$$\\Delta P = s - ms + m - 1$$\n$$\\Delta P = (1 - m)s + m - 1$$\n\n所需的双分量行向量是 $(\\Delta S, \\Delta P)$。", "answer": "$$ \\boxed{ \\begin{pmatrix} (1 - m)F + m(t + u) + d  (1 - m)s + m - 1 \\end{pmatrix} } $$", "id": "3641500"}, {"introduction": "编译器优化必须是保守的，并尊重所有的语言语义，包括异常处理和内存一致性的语义。最后一个实践将探讨代码移动（一种优化）与异常处理之间微妙但至关重要的相互作用。你将分析将一个 `volatile` 内存读取操作从 `try` 块中“提升”出去是否是一种安全的转换，特别是当这个读取操作本身可能触发异常时 [@problem_id:3641517]。这个问题促使你深入思考 `try` 块的精确边界，以及为什么某些具有副作用的操作不能被自由地移动。", "problem": "一个类 Java 语言的编译器将异常转换为带有显式着陆区（landing pads）的控制流图（CFG, Control Flow Graph）：任何在 try 块的词法区域内可能抛出异常的操作，都会被赋予一条指向该区域处理程序的异常边，而区域外的操作则不会以该处理程序为目标。两个被广泛接受的事实作为我们的基本依据：\n- 语言定义的异常语义：语句序列的求值顺序是从左到右；在 try 块的动态范围内抛出的任何异常都会被匹配的 catch 子句捕获；在此之外抛出的异常则不会被该 catch 子句捕获。特别地，解引用一个空对象引用会抛出 $\\mathsf{NullPointerException}$。\n- Java 内存模型（JMM, Java Memory Model）对 volatile 的规则：对 volatile 字段的读取是一个具有副作用的内存操作，必须按其书写的方式执行，不得被消除或复制，并具有排序约束；观察或解引用一个对象以读取 volatile 字段时，仍然遵守正常的空解引用规则，并可能抛出 $\\mathsf{NullPointerException}$。\n\n考虑以下程序，其中 $\\mathsf{C}$ 是一个带有 volatile 字段 $v$ 的类，引用 $o$ 可能因并发更新而为 $\\mathsf{null}$：\n- class C { volatile int v; }\n- int m(C o) {\n    try {\n        int $t$ = $o.v$;  // volatile 读取，可能存在空解引用\n        return $t$;\n    } catch (NullPointerException e) {\n        return $0$;\n    }\n}\n\n假设编译器考虑将 volatile 读取 $o.v$ 提升（hoist）出 try 块，以便进行代码移动和重用。在上述基于 CFG 的标准异常处理转换下，选择一个选项，该选项正确描述了这种提升是否保留语义（semantics-preserving），并提供一个最小的、具体的反例程序来证明任何不健全性（unsoundness）。\n\nA. 将 $o.v$ 提升出 try 块通常是不健全的。一个最小的反例是当 $o = \\mathsf{null}$ 时调用上述的 $m(o)$：求值 $o.v$ 会抛出 $\\mathsf{NullPointerException}$。如果 $o.v$ 被提升，异常会在 try 块之外被抛出且不会被捕获，因此 $m(o)$ 不会像规定那样返回 $0$。因此，除非编译器能证明 $o \\neq \\mathsf{null}$，否则可能抛出异常的 volatile 读取必须保留在 try 块内部。\n\nB. 将 $o.v$ 提升出 try 块总是安全的，因为 volatile 读取不会抛出异常；只有后续的调用或算术运算才会抛出异常。因此，不存在提升会改变被捕获异常的反例。\n\nC. 如果编译器将被提升的读取的异常边重新连接到原始的处理程序，无论词法作用域如何，提升 $o.v$ 都是安全的，因为是 CFG 边而非词法区域定义了可捕获性。一个最小的见证（witness）表明，即使当 $o = \\mathsf{null}$ 时，重定向该边也足够了。\n\nD. 如果编译器复制 volatile 读取，则提升是安全的：将一个 $o.v$ 保留在 try 块内部，同时在 try 块之前也计算 $o.v$，并在可用时使用提升后的值。由于 volatile 读取是幂等的（idempotent）且不改变控制流，复制操作保留了异常和内存排序的语义；因此，不存在复制会改变捕获行为的反例。\n\n选择正确的选项。", "solution": "我们从基本原则出发：\n- 异常语义规定，一个可能抛出异常并在 try 块的动态范围内执行的操作，将被匹配的 catch 子句捕获。设 try 内部的序列为 $s_1; s_2; \\dots; s_n$，从左到右求值。如果任何 $s_i$ 在时刻 $t$ 抛出异常，控制权将转移到关联的处理程序。try 块外的操作不会以该 try 的处理程序为目标。\n- Java 内存模型 (JMM) 定义，volatile 读取是一个具有获取 (acquire) 语义的副作用内存操作，不能以改变可观察行为的方式被消除、复制或重排序。关键在于，通过对象引用读取字段仍然会执行解引用操作；如果该引用为 $\\mathsf{null}$，解引用将抛出 $\\mathsf{NullPointerException}$。\n\n在基于 CFG 的异常处理转换下，try 区域对应一组基本块 $B_{\\mathrm{try}}$，其中可能抛出异常的操作具有指向着陆区 $B_{\\mathrm{catch}}$ 的异常边。不在 $B_{\\mathrm{try}}$ 中的块内的操作，不会有指向 $B_{\\mathrm{catch}}$ 的异常边，除非编译器有意将它们放置在该区域。\n\n分析程序：\n- volatile 读取为 $r \\equiv o.v$。求值 $r$ 的语义包括首先检查 $o$；如果 $o = \\mathsf{null}$，解引用失败并抛出 $\\mathsf{NullPointerException}$。如果 $o \\neq \\mathsf{null}$，则 volatile 读取继续进行，并返回受 JMM 排序约束的 $v$ 的当前值。\n\n当 $o = \\mathsf{null}$ 时的原始行为：\n- 在原始程序中，$r$ 在 try 块内部计算。因此，来自 $r$ 的异常边指向 $\\mathsf{NullPointerException}$ 的 catch 子句，函数返回 $0$。\n\n将 $r$ 提升到 try 块外的效果：\n- 如果编译器将 $r$ 移动到一个不在 $B_{\\mathrm{try}}$ 中的块，那么当 $o = \\mathsf{null}$ 时，异常会在进入 try 区域之前被抛出。动态范围规则意味着 catch 子句不适用；异常未被捕获并向上传播，从而改变了程序的可观察行为（它不会返回 $0$）。相对于原始规范，这是一个遗漏的异常。\n\n逐项分析：\n- 选项 A：它指出将 $o.v$ 提升出 try 块是不健全的，并给出了当 $o = \\mathsf{null}$ 时调用 $m(o)$ 的具体反例。这直接利用了“解引用 $\\mathsf{null}$ 会抛出 $\\mathsf{NullPointerException}$”这一基本规则，以及“只有 try 块内的操作才有指向 catch 的异常边”这一 CFG 转换规则。行为上的差异（返回 $0$ 与传播异常）表明了语义违反。它还正确地指出了唯一的安全情况：证明 $o \\neq \\mathsf{null}$，从而消除了异常源。结论 — 正确。\n\n- 选项 B：它声称 volatile 读取不会抛出异常。这与基本的解引用规则相矛盾：通过引用 $o$ 访问字段需要解引用 $o$，如果 $o = \\mathsf{null}$，则会抛出 $\\mathsf{NullPointerException}$。因此，存在如上所述的反例。结论 — 错误。\n\n- 选项 C：它建议简单地将词法 try 块外部操作的异常边重新连接到处理程序。在标准转换中，异常的可捕获性由执行时的区域成员资格决定；简单地将区域外的所有异常重定向到处理程序会破坏词法作用域，并可能捕获本不应被捕获的异常（例如，由中间操作或不同代码路径抛出的异常）。此外，在底层，如果没有额外的补偿代码（例如，克隆区域或插入守卫），运行时无法区分特定的异常是由提升的操作引起的，还是由其他外部操作引起的。因此，简单地重新连接异常边通常不是保留语义的。结论 — 错误。\n\n- 选项 D：它声称复制 volatile 读取是安全的。这违反了 JMM 规则：volatile 读取不能随意复制；复制 $o.v$ 可能 (i) 由于线程间的交互，在两次读取中观察到两个不同的值，(ii) 引入一个额外的潜在异常点（两次解引用，每次在 $o = \\mathsf{null}$ 时都可能抛出异常），以及 (iii) 通过插入一个额外的 volatile 访问来改变 happens-before 关系。这些变化可能会改变返回的值以及异常的集合/时机，从而破坏原始语义。结论 — 错误。\n\n因此，唯一与基本语义和基于 CFG 的转换一致的选项是选项 A。", "answer": "$$\\boxed{A}$$", "id": "3641517"}]}