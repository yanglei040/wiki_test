{"hands_on_practices": [{"introduction": "将编程语言中的条件语句（如 `if-else`）转化为控制流图是编译器设计的基础。这个练习 [@problem_id:3633658] 旨在通过一个深度嵌套的条件逻辑，锻炼你识别基本块并构建相应控制流的能力。更进一步，它引入了“支配点”(dominator) 的概念，这是许多编译器优化算法（例如代码移动和冗余消除）的理论基石。", "problem": "考虑以下带有深度嵌套条件语句的结构化程序片段，其中所有条件和变量都用数学表示法表示。该程序使用变量 $x$、$y$、$z$、$s$、$a$ 和 $b$，并按如下方式执行：\n- 如果 $x > 0$：\n  - 如果 $y > 1$：\n    - 设置 $s := y$。\n    - 如果 $z = 0$，则设置 $a := s + 1$，否则设置 $a := s - 1$。\n  - 否则：\n    - 如果 $x + y > z$，则设置 $a := z$，否则设置 $a := x$。\n- 否则：\n  - 如果 $y > 0$，则设置 $a := y$，否则设置 $a := 0$。\n- 在上述操作之后，设置 $b := a + 1$，然后返回 $b$。\n\n您的任务是将此片段转换为基本块序列，并构建控制流图 (CFG)，其中控制流图 (CFG) 是一个有向图，其节点是基本块，其边表示可能的控制转移。基本块是具有单一入口和单一出口的、除了末尾之外不包含任何内部控制转移的最大直线式语句序列。\n\n将基本块标记为 $B_0$（入口）到 $B_{12}$，使得：\n- $B_0$：测试 $x > 0$。真边指向 $B_1$，假边指向 $B_7$。\n- $B_1$：测试 $y > 1$。真边指向 $B_2$，假边指向 $B_5$。\n- $B_2$：执行 $s := y$ 并测试 $z = 0$。真边指向 $B_3$，假边指向 $B_4$。\n- $B_3$：执行 $a := s + 1$ 并直接进入 $B_{10}$。\n- $B_4$：执行 $a := s - 1$ 并直接进入 $B_{10}$。\n- $B_5$：测试 $x + y > z$。真边指向 $B_6$，假边指向 $B_8$。\n- $B_6$：执行 $a := z$ 并直接进入 $B_{10}$。\n- $B_8$：执行 $a := x$ 并直接进入 $B_{10}$。\n- $B_7$：测试 $y > 0$。真边指向 $B_9$，假边指向 $B_{11}$。\n- $B_9$：执行 $a := y$ 并直接进入 $B_{12}$。\n- $B_{11}$：执行 $a := 0$ 并直接进入 $B_{12}$。\n- $B_{10}$：是 $B_3$、$B_4$、$B_6$、$B_8$ 的汇合点，并直接进入 $B_{12}$。\n- $B_{12}$：执行 $b := a + 1$ 并返回。\n\n使用支配关系的基本定义，即节点 $d$ 支配节点 $n$ 当且仅当从入口块 $B_0$ 到 $n$ 的每一条路径都经过 $d$，并且节点 $n \\neq B_0$ 的直接支配节点是 $n$ 的唯一的严格支配节点，该严格支配节点不严格支配 $n$ 的任何其他严格支配节点，手动计算每个 $i \\in \\{1,2,\\dots,12\\}$ 的直接支配节点 $\\operatorname{idom}(B_i)$。\n\n令 $\\operatorname{index}(B_j) = j$ 表示块 $B_j$ 的整数索引。定义量\n$$\nS = \\sum_{i=1}^{12} \\operatorname{index}(\\operatorname{idom}(B_i)).\n$$\n计算 $S$ 的值。请以精确整数形式提供最终答案。无需四舍五入，不涉及单位。", "solution": "## 问题验证\n\n### 步骤 1：提取已知信息\n\n问题提供了一个结构化程序片段和相应的基本块分解。已知信息如下：\n\n变量：$x$, $y$, $z$, $s$, $a$, $b$。\n\n程序逻辑：\n- 如果 $x > 0$：\n  - 如果 $y > 1$：\n    - 设置 $s := y$。\n    - 如果 $z = 0$，则设置 $a := s + 1$，否则设置 $a := s - 1$。\n  - 否则：\n    - 如果 $x + y > z$，则设置 $a := z$，否则设置 $a := x$。\n- 否则：\n  - 如果 $y > 0$，则设置 $a := y$，否则设置 $a := 0$。\n- 在上述操作之后，设置 $b := a + 1$，然后返回 $b$。\n\n基本块和 CFG 结构：\n- $B_0$：入口块，测试 $x > 0$。真边指向 $B_1$，假边指向 $B_7$。\n- $B_1$：测试 $y > 1$。真边指向 $B_2$，假边指向 $B_5$。\n- $B_2$：执行 $s := y$ 并测试 $z = 0$。真边指向 $B_3$，假边指向 $B_4$。\n- $B_3$：执行 $a := s + 1$ 并直接进入 $B_{10}$。\n- $B_4$：执行 $a := s - 1$ 并直接进入 $B_{10}$。\n- $B_5$：测试 $x + y > z$。真边指向 $B_6$，假边指向 $B_8$。\n- $B_6$：执行 $a := z$ 并直接进入 $B_{10}$。\n- $B_8$：执行 $a := x$ 并直接进入 $B_{10}$。\n- $B_7$：测试 $y > 0$。真边指向 $B_9$，假边指向 $B_{11}$。\n- $B_9$：执行 $a := y$ 并直接进入 $B_{12}$。\n- $B_{11}$：执行 $a := 0$ 并直接进入 $B_{12}$。\n- $B_{10}$：是 $B_3$、$B_4$、$B_6$、$B_8$ 的汇合点，并直接进入 $B_{12}$。\n- $B_{12}$：执行 $b := a + 1$ 并返回。\n\n定义：\n- 支配关系：节点 $d$ 支配节点 $n$ 当且仅当从入口块 $B_0$ 到 $n$ 的每一条路径都经过 $d$。\n- 直接支配节点：节点 $n \\neq B_0$ 的直接支配节点，记作 $\\operatorname{idom}(n)$，是 $n$ 的唯一的严格支配节点，该严格支配节点不严格支配 $n$ 的任何其他严格支配节点。\n- 索引：$\\operatorname{index}(B_j) = j$。\n\n目标量：\n- 计算 $S = \\sum_{i=1}^{12} \\operatorname{index}(\\operatorname{idom}(B_i))$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n根据验证标准对问题进行评估。\n1.  **科学依据**：该问题设置在编译原理领域，涉及控制流图 (CFG) 和支配节点分析。这些是计算机科学中标准、明确定义且基础的概念。该问题在科学上是合理的。\n2.  **适定性**：该问题对基本块和表示控制流的有向边进行了明确描述。它为支配关系和直接支配节点提供了形式化定义。任务是将这些定义应用于给定的 CFG 并计算一个总和，这会得出一个唯一的、明确定义的整数解。\n3.  **客观性**：该问题使用形式化的数学表示法和精确的定义来陈述。没有主观或模糊的陈述。\n4.  **不完整或矛盾的设置**：基本块及其相互连接的规范是完整的，并构建了一个具有单一入口（$B_0$）和单一出口（从 $B_{12}$）的有效的、连通的有向图。CFG 的逻辑正确地反映了源程序的嵌套条件结构。设置中没有矛盾之处。\n5.  **不切实际或不可行**：该程序片段及其 CFG 表示是在教学和分析编译器优化时使用的典型示例。该设置在其领域内是完全现实的。\n\n### 步骤 3：结论与行动\n\n该问题具有科学依据、客观、适定，且没有矛盾或歧义。这是编译原理中的一个有效问题。我将继续进行解答。\n\n## 解答\n\n任务是计算给定控制流图 (CFG) 中块 $B_1$ 到 $B_{12}$ 的直接支配节点的索引之和。\n\n首先，我们根据问题描述确定 CFG 的精确结构。节点集是 {$B_0, B_1, \\dots, B_{12}$}。入口节点是 $B_0$。表示控制转移的边如下：\n- $B_0 \\rightarrow B_1$ 和 $B_0 \\rightarrow B_7$\n- $B_1 \\rightarrow B_2$ 和 $B_1 \\rightarrow B_5$\n- $B_2 \\rightarrow B_3$ 和 $B_2 \\rightarrow B_4$\n- $B_3 \\rightarrow B_{10}$\n- $B_4 \\rightarrow B_{10}$\n- $B_5 \\rightarrow B_6$ 和 $B_5 \\rightarrow B_8$\n- $B_6 \\rightarrow B_{10}$\n- $B_8 \\rightarrow B_{10}$\n- $B_7 \\rightarrow B_9$ 和 $B_7 \\rightarrow B_{11}$\n- $B_9 \\rightarrow B_{12}$\n- $B_{11} \\rightarrow B_{12}$\n- $B_{10} \\rightarrow B_{12}$\n\n我们现在将确定每个块 $B_i$（其中 $i \\in \\{1, 2, \\dots, 12\\}$）的直接支配节点 $\\operatorname{idom}(B_i)$。我们应用定义：如果从入口节点 $B_0$ 到节点 $n$ 的所有路径都包含节点 $d$，那么 $d$ 支配 $n$。$n$ 的直接支配节点是 $n$ 的所有严格支配节点中，在从入口到 $n$ 的任何路径上离 $n$ 最近的那个。\n\n- $\\operatorname{idom}(B_1)$：到 $B_1$ 的唯一路径是 $B_0 \\rightarrow B_1$。$B_1$ 的严格支配节点是 {$B_0$}。因此，$\\operatorname{idom}(B_1) = B_0$。\n\n- $\\operatorname{idom}(B_7)$：到 $B_7$ 的唯一路径是 $B_0 \\rightarrow B_7$。$B_7$ 的严格支配节点是 {$B_0$}。因此，$\\operatorname{idom}(B_7) = B_0$。\n\n- $\\operatorname{idom}(B_2)$：到 $B_2$ 的每条路径都必须经过 $B_1$ ($B_0 \\rightarrow B_1 \\rightarrow B_2$)。$B_2$ 的严格支配节点是 {$B_0, B_1$}。由于 $B_1$ 在路径上位于 $B_0$ 之后，它是最近的严格支配节点。因此，$\\operatorname{idom}(B_2) = B_1$。\n\n- $\\operatorname{idom}(B_5)$：到 $B_5$ 的每条路径都必须经过 $B_1$ ($B_0 \\rightarrow B_1 \\rightarrow B_5$)。根据与 $B_2$ 相同的逻辑，$\\operatorname{idom}(B_5) = B_1$。\n\n- $\\operatorname{idom}(B_3)$：到 $B_3$ 的每条路径都必须经过 $B_2$ ($B_0 \\rightarrow B_1 \\rightarrow B_2 \\rightarrow B_3$)。严格支配节点是 {$B_0, B_1, B_2$}。最近的是 $B_2$。因此，$\\operatorname{idom}(B_3) = B_2$。\n\n- $\\operatorname{idom}(B_4)$：到 $B_4$ 的每条路径都必须经过 $B_2$ ($B_0 \\rightarrow B_1 \\rightarrow B_2 \\rightarrow B_4$)。因此，$\\operatorname{idom}(B_4) = B_2$。\n\n- $\\operatorname{idom}(B_6)$：到 $B_6$ 的每条路径都必须经过 $B_5$ ($B_0 \\rightarrow B_1 \\rightarrow B_5 \\rightarrow B_6$)。严格支配节点是 {$B_0, B_1, B_5$}。最近的是 $B_5$。因此，$\\operatorname{idom}(B_6) = B_5$。\n\n- $\\operatorname{idom}(B_8)$：到 $B_8$ 的每条路径都必须经过 $B_5$ ($B_0 \\rightarrow B_1 \\rightarrow B_5 \\rightarrow B_8$)。因此，$\\operatorname{idom}(B_8) = B_5$。\n\n- $\\operatorname{idom}(B_9)$：到 $B_9$ 的每条路径都必须经过 $B_7$ ($B_0 \\rightarrow B_7 \\rightarrow B_9$)。严格支配节点是 {$B_0, B_7$}。最近的是 $B_7$。因此，$\\operatorname{idom}(B_9) = B_7$。\n\n- $\\operatorname{idom}(B_{11})$：到 $B_{11}$ 的每条路径都必须经过 $B_7$ ($B_0 \\rightarrow B_7 \\rightarrow B_{11}$) 。因此，$\\operatorname{idom}(B_{11}) = B_7$。\n\n- $\\operatorname{idom}(B_{10})$：$B_{10}$ 是一个汇合点。其前驱节点是 {$B_3, B_4, B_6, B_8$}。要支配 $B_{10}$，一个节点必须支配其所有前驱节点。到 $B_3$ 和 $B_4$ 的路径经过 $B_0 \\rightarrow B_1 \\rightarrow B_2$。到 $B_6$ 和 $B_8$ 的路径经过 $B_0 \\rightarrow B_1 \\rightarrow B_5$。到这四个前驱节点中任何一个的所有路径都必须经过 $B_0$ 和 $B_1$。在 $B_1$ 之后，路径分岔。因此，要支配 $B_{10}$，一个节点必须支配所有它的前驱，而支配所有前驱的公共支配节点是 {$B_0, B_1$}。所以，从 $B_0$ 到 $B_{10}$ 的每条路径都必须包含 $B_1$。$B_{10}$ 的严格支配节点是 {$B_0, B_1$}。最近的是 $B_1$。因此，$\\operatorname{idom}(B_{10}) = B_1$。\n\n- $\\operatorname{idom}(B_{12})$：$B_{12}$ 是最终的汇合点。其前驱节点是 {$B_9, B_{10}, B_{11}$}。到 $B_9$ 和 $B_{11}$ 的路径必须经过 $B_0 \\rightarrow B_7$。到 $B_{10}$ 的路径必须经过 $B_0 \\rightarrow B_1$。由于存在从初始条件的 $B_1$ 分支和 $B_7$ 分支到达 $B_{12}$ 的路径，唯一保证在到达 $B_{12}$ 的*每一条*路径上的节点是入口节点 $B_0$。因此，$B_{12}$ 的唯一严格支配节点是 $B_0$。因此，$\\operatorname{idom}(B_{12}) = B_0$。\n\n我们现在可以编制一个直接支配节点的索引列表：\n- $\\operatorname{index}(\\operatorname{idom}(B_1)) = \\operatorname{index}(B_0) = 0$\n- $\\operatorname{index}(\\operatorname{idom}(B_2)) = \\operatorname{index}(B_1) = 1$\n- $\\operatorname{index}(\\operatorname{idom}(B_3)) = \\operatorname{index}(B_2) = 2$\n- $\\operatorname{index}(\\operatorname{idom}(B_4)) = \\operatorname{index}(B_2) = 2$\n- $\\operatorname{index}(\\operatorname{idom}(B_5)) = \\operatorname{index}(B_1) = 1$\n- $\\operatorname{index}(\\operatorname{idom}(B_6)) = \\operatorname{index}(B_5) = 5$\n- $\\operatorname{index}(\\operatorname{idom}(B_7)) = \\operatorname{index}(B_0) = 0$\n- $\\operatorname{index}(\\operatorname{idom}(B_8)) = \\operatorname{index}(B_5) = 5$\n- $\\operatorname{index}(\\operatorname{idom}(B_9)) = \\operatorname{index}(B_7) = 7$\n- $\\operatorname{index}(\\operatorname{idom}(B_{10})) = \\operatorname{index}(B_1) = 1$\n- $\\operatorname{index}(\\operatorname{idom}(B_{11})) = \\operatorname{index}(B_7) = 7$\n- $\\operatorname{index}(\\operatorname{idom}(B_{12})) = \\operatorname{index}(B_0) = 0$\n\n最后，我们计算所需的总和 $S$：\n$$\nS = \\sum_{i=1}^{12} \\operatorname{index}(\\operatorname{idom}(B_i))\n$$\n$$\nS = 0 + 1 + 2 + 2 + 1 + 5 + 0 + 5 + 7 + 1 + 7 + 0\n$$\n$$\nS = (0 + 0 + 0) + (1 + 1 + 1) + (2 + 2) + (5 + 5) + (7 + 7)\n$$\n$$\nS = 0 + 3 + 4 + 10 + 14\n$$\n$$\nS = 31\n$$\n总和 $S$ 的值为 $31$。", "answer": "$$\n\\boxed{31}\n$$", "id": "3633658"}, {"introduction": "在掌握了条件分支之后，我们将注意力转向循环结构，这是构成算法核心的常见模式。在控制流图中，循环通过“回边”(back-edge) 来体现，这使得图的分析变得更加复杂。这个练习 [@problem_id:3633677] 要求你为一个包含 `break` 语句的 `while` 循环构建控制流图，这有助于理解循环如何被提前终止，并让你实践计算圈复杂度 (cyclomatic complexity)，这是一个衡量代码结构复杂度的重要指标。", "problem": "给定以下直线式命令程序片段，它计算一个类似阶乘的值，并在乘法可能溢出时提前中止循环。您必须显式地对控制流进行建模，并遵守以下约定。\n\n程序：\n输入：一个机器整数 $n$。\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n\n构建控制流图（CFG）的约定：\n- 控制流图（CFG）是一个有向图，其节点是基本块，其边表示从一个块的末尾到另一个块开头的可能控制转移。\n- 基本块是具有单一入口和单一出口的语句的最大直线序列；它在任何分支、循环测试或跳转目标之前和之后结束。\n- 将所有返回（return）归一化到一个唯一的出口块。任何提前返回都必须首先赋予定的返回值，然后跳转到唯一的出口块，由该出口块执行函数的返回操作。除此归一化外，不要引入任何额外的控制结构。\n- 将谓词 $\\mathrm{Overflow}(r,i)$ 视为一个原子布尔测试。break 语句将控制权转移到 while 循环之后的位置；在返回归一化的情况下，控制流接着会流向返回正确值的唯一出口块。\n- 条件语句恰好有两条出边，分别对应真和假两种结果。除了上面明确写出的情况外，不存在短路求值。\n\n任务：\n- 为给定程序构建满足上述约定的最小基本块 CFG。\n- 令 $N$ 表示 CFG 中的节点（基本块）数量，$E$ 表示有向边的数量，$P$ 表示 CFG 的底层无向图中的连通分量数量。\n- 仅使用这些图量，确定 CFG 的圈复杂度 $M$。\n\n仅提供 $M$ 的数值作为您的最终答案。无需四舍五入。", "solution": "该问题要求计算给定程序片段的控制流图（CFG）的圈复杂度 $M$。圈复杂度将使用公式 $M = E - N + 2P$ 计算，其中 $N$ 是节点（基本块）的数量，$E$ 是有向边的数量，$P$ 是图中连通分量的数量。\n\n首先，我们必须根据提供的约定，通过将程序划分为基本块来构建CFG。基本块是具有单一入口和单一出口的直线代码的最大序列。新的基本块始于程序的开头、跳转或分支的目标处，或分支指令之后。给定的约定要求将所有返回语句归一化到一个唯一的出口块。\n\n让我们识别给定程序的基本块：\n\n程序：\n```\nInput: a machine integer $n$.\nif $n  0$ then\n    return $-1$\nfi\n$i := 1$\n$r := 1$\nwhile $i \\le n$ do\n    if $\\mathrm{Overflow}(r,i)$ then\n        break\n    fi\n    $r := r \\times i$\n    $i := i + 1$\nod\nreturn $r$\n```\n\n1.  **块 B1**：第一条指令是一个条件分支 `if $n  0$`，它本身构成了第一个基本块。这是 CFG 的入口点。\n    -   `B1: if $n  0$`\n\n2.  **块 B2**：如果 `B1` 中的条件为真，程序应 `return $-1$`。根据返回归一化规则，这变成对一个返回值持有者（我们称之为 `ret_val`）的赋值，然后无条件跳转到出口块。赋值语句 `ret_val := -1` 自成一个基本块。\n    -   `B2: ret_val := -1`\n\n3.  **块 B3**：如果 `B1` 中的条件为假，控制流将转到初始化代码 `i := 1` 和 `r := 1`。这两个顺序赋值语句构成一个基本块。\n    -   `B3: i := 1; r := 1`\n\n4.  **块 B4**：初始化后，控制到达 `while` 循环。循环的条件 `while $i \\le n$` 作为一个条件分支，构成一个新的基本块。它是循环体末尾的跳转目标，这加强了它作为块入口的地位。\n    -   `B4: if $i \\le n$`\n\n5.  **块 B5**：如果 `B4` 中的循环条件为真，控制进入循环体。第一条语句是另一个条件 `if $\\mathrm{Overflow}(r,i)$`，它构成一个新的基本块。\n    -   `B5: if $\\mathrm{Overflow}(r,i)$`\n\n6.  **块 B6**：如果 `B5` 中的溢出条件为假，则执行语句 `r := r \\times i` 和 `i := i + 1`。这段顺序代码构成一个基本块。此块之后，控制返回到 `B4` 中的循环条件检查。\n    -   `B6: r := r \\times i; i := i + 1`\n\n7.  **块 B7**：循环终止后到达此块。`break` 语句（来自 `B5`）和循环条件失败（来自 `B4`）都将控制权转移到这里。指令是 `return $r$`，它被归一化为赋值 `ret_val := r`。因为这个块是多个跳转的目标，所以它必须是一个独立的基本块。\n    -   `B7: ret_val := r`\n\n8.  **块 B8**：这是约定所要求的唯一出口块。它是所有终止函数路径的跳转目标。在此程序中，块 `B2` 和 `B7` 都跳转到此块。\n    -   `B8: return ret_val`\n\n我们已经识别出 $N = 8$ 个基本块。\n\n接下来，我们识别表示这些块之间控制流的有向边（$E$）：\n-   `B1` 有两个后继节点：`B2`（如果 `$n  0$` 为真）和 `B3`（如果为假）。(2 条边)\n-   `B2` 有一个后继节点：`B8`（无条件跳转到出口）。(1 条边)\n-   `B3` 有一个后继节点：`B4`（无条件流向循环测试）。(1 条边)\n-   `B4` 有两个后继节点：`B5`（如果 `$i \\le n$` 为真，进入循环）和 `B7`（如果为假，退出循环）。(2 条边)\n-   `B5` 有两个后继节点：`B7`（如果 `$\\mathrm{Overflow}(r,i)$` 为真，`break` 到循环之后）和 `B6`（如果为假，继续循环体）。(2 条边)\n-   `B6` 有一个后继节点：`B4`（无条件跳转到循环测试的开始处）。(1 条边)\n-   `B7` 有一个后继节点：`B8`（无条件跳转到出口）。(1 条边)\n-   `B8` 是终止块，没有后继节点。(0 条边)\n\n将边的数量相加：$E = 2 + 1 + 1 + 2 + 2 + 1 + 1 = 10$。\n\n现在，我们确定连通分量的数量 $P$。对于单个非空过程，其 CFG 是一个连通图，因为每个块都可以从入口块到达。在我们的构造中，`B1` 是入口块，所有其他块（`B2` 到 `B8`）都可以从 `B1` 到达。因此，该图有 $P = 1$ 个连通分量。\n\n最后，我们应用圈复杂度的公式：\n$M = E - N + 2P$\n代入我们找到的值：$N = 8$，$E = 10$，以及 $P = 1$。\n$M = 10 - 8 + 2(1) = 2 + 2 = 4$。\n\nCFG 的圈复杂度是 $4$。这个结果可以通过更简单的公式 $M = D + 1$ 来交叉验证，其中 $D$ 是判定点的数量。该程序有 $3$ 个判定点：`if $n  0$`、`while $i \\le n$` 和 `if $\\mathrm{Overflow}(r,i)$`。这得出 $M = 3 + 1 = 4$，证实了我们基于图的计算。", "answer": "$$\\boxed{4}$$", "id": "3633677"}, {"introduction": "现代编程语言广泛使用异常处理机制，如 `try-catch` 语句，它们引入了非结构化的控制转移，对构建精确的控制流图提出了挑战。此练习 [@problem_id:3633641] 深入探讨了如何为包含嵌套 `try` 块和 `rethrow` 语句的代码建模，揭示了异常如何改变程序的执行路径。通过此练习，你还将接触到“后置支配点”(post-dominator) 的概念，这对于理解和优化包含异常处理的程序至关重要。", "problem": "一个结构化语言的编译器，使用以下经过充分测试的规则和定义作为其基础，为过程构建控制流图（CFG）：一个 CFG 包含代表基本块的节点和代表可能控制转移的有向边；一个基本块是具有单一入口和单一出口的语句的最大直线序列；如果从节点 $u$ 到唯一出口节点的所有路径都经过节点 $v$，则节点 $v$ 后支配（post-dominates）节点 $u$；一个严格后支配者（strict post-dominator）排除了节点本身。该语言提供异常机制，异常类型之间存在单继承，其处理器具有以下语义：如果类型 $T$ 等于类型 $U$ 或 $T$ 继承自 $U$，则类型为 $T$ 的异常与为类型 $U$ 声明的处理器相匹配；一个 try 块可以有多个 catch 块，并且会选择最内层的、动态包围的、具有匹配 catch 的 try 块；一个 catch 块通常在整个 try-catch 结构之后继续执行控制流，但一个特殊的 \"rethrow\" 语句会重新引发当前异常，由下一个动态包围的匹配 catch 处理器来处理。\n\n考虑一个具有异常类型层次结构和嵌套 try-catch 块的过程。设 $E$ 为一个基异常类型， $F$ 和 $G$ 为两个不同的派生类型，其中 $F \\rightarrow E$ 和 $G \\rightarrow E$ 表示单继承。设 $p$ 为一个运行时布尔值，可能求值为任一分支。该过程的基本块被标记为 $b_{0}, b_{1}, \\dots, b_{12}$，并具有以下直线内容和语法布局，其中 throw 和 rethrow 会终止它们所在的块：\n\n- 外部 try 在 $b_{0}$ 之前开始，在 $b_{10}$ 之后结束。\n- 内部 try 在 $b_{1}$ 之前开始，在 $b_{5}$ 之后结束。\n- $b_{0}$：赋值 $x \\leftarrow 1$。\n- $b_{1}$：赋值 $y \\leftarrow 2$。\n- $b_{2}$：求值分支条件 $p$。\n- $b_{3}$：如果控制流从 $b_{2}$ 到达且 $p$ 为真，则执行 $\\mathrm{throw}\\ F$。\n- $b_{4}$：如果控制流从 $b_{2}$ 到达且 $p$ 为假，则执行 $\\mathrm{throw}\\ G$。\n- $b_{5}$：计算 $z \\leftarrow y + 1$（文本上位于内部 try 中，分支之后）。\n- $\\mathrm{catch}(F)$ 的入口是 $b_{6}$：执行处理器主体 $h_{F}$。\n- $b_{7}$：在 $h_{F}$ 之后立即执行 $\\mathrm{rethrow}$。\n- $\\mathrm{catch}(G)$ 的入口是 $b_{8}$：执行处理器主体 $h_{G}$。\n- $b_{9}$：在 $h_{G}$ 之后立即执行 $\\mathrm{rethrow}$。\n- $b_{10}$：计算 $w \\leftarrow x + y$（文本上位于内部 try 之后，外部 try 之内）。\n- 外部 $\\mathrm{catch}(E)$ 的入口是 $b_{11}$：执行处理器主体 $h_{E}$。\n- $b_{12}$：在外部 try-catch 之后执行 $done()$。\n- 唯一的出口节点在 $b_{12}$ 之后。\n\n使用以下基本规则构建 CFG：\n- 顺序边连接直线区域内的连续块，除非遇到终止符（throw 或 rethrow）；$b_{2}$ 有两个分支后继，$b_{3}$ 和 $b_{4}$。\n- 根据类型层次结构，从每个 $\\mathrm{throw}$ 添加异常边到最近的动态包围的匹配 $\\mathrm{catch}$ 的入口：$b_{3} \\rightarrow b_{6}$ 和 $b_{4} \\rightarrow b_{8}$。\n- 每个 $\\mathrm{rethrow}$ 将控制权转移到当前 try 外部最近的动态包围的匹配 $\\mathrm{catch}$ 的入口：$b_{7} \\rightarrow b_{11}$ 和 $b_{9} \\rightarrow b_{11}$。\n- 在 $b_{11}$ 处的外部 $\\mathrm{catch}(E)$ 主体执行完毕后，控制流在 $b_{12}$ 恢复，然后到达出口。\n\n假设从过程入口开始进行标准的可达性分析，并从后支配者分析中排除不可达节点。根据“如果从节点 $u$ 到出口的所有路径都包含节点 $v$ 且 $u \\neq v$，则节点 $v$ 严格后支配节点 $u$”的精确定义，确定被外部基类 catch 入口 $b_{11}$ 严格后支配的可达基本块的数量。\n\n请用一个整数表达你的最终答案。无需四舍五入。", "solution": "出发点是控制流图（CFG）和后支配的基本定义：对于节点 $u$ 和 $v$，如果从 $u$到唯一出口的所有路径都经过 $v$，则节点 $v$ 后支配 $u$。严格后支配还要求 $u \\neq v$。我们还使用结构化语言中经过充分测试的标准异常语义：类型为 $T$ 的 $\\mathrm{throw}$ 会导向最近的动态包围的 $\\mathrm{catch}$，其声明类型 $U$ 与 $T$ 或 $T$ 的基类匹配；而 $\\mathrm{rethrow}$ 会传播当前异常，由下一个包围的匹配 $\\mathrm{catch}$ 处理。\n\n我们首先枚举 CFG 的节点和边，然后确定可达性，最后应用后支配分析。\n\n节点是基本块 $b_{0}, b_{1}, \\dots, b_{12}$ 以及一个我们表示为 $exit$ 的出口节点。外部 try 在 $b_{0}$ 之前开始，在 $b_{10}$ 之后结束。内部 try 在 $b_{1}$ 之前开始，在 $b_{5}$ 之后结束。Throw 和 rethrow 会终止它们所在的块，因此只有异常后继。\n\n顺序边：\n- $b_{0} \\rightarrow b_{1}$ 和 $b_{1} \\rightarrow b_{2}$ 因为它们在任何分支或终止符之前是直线执行的。\n- $b_{2}$ 是一个条件分支，有两个后继：$b_{2} \\rightarrow b_{3}$（真分支，$p$ 为真）和 $b_{2} \\rightarrow b_{4}$（假分支，$p$ 为假）。\n- 从 $b_{3}$ 或 $b_{4}$ 到 $b_{5}$ 没有顺序边，因为 $b_{3}$ 和 $b_{4}$ 都以 $\\mathrm{throw}$ 终止。\n- 在每个 catch 内部，$b_{6} \\rightarrow b_{7}$ 和 $b_{8} \\rightarrow b_{9}$ 是处理器主体内部的顺序边。\n- 从 $b_{7}$ 或 $b_{9}$ 到 $b_{10}$ 没有顺序边，因为它们都是执行 $\\mathrm{rethrow}$ 的终止符。\n- 在外部 catch $b_{11}$ 之后，我们有 $b_{11} \\rightarrow b_{12}$，然后是 $b_{12} \\rightarrow exit$，这是到过程出口的正常控制流。\n\n来自 throw 和 rethrow 的异常边：\n- 从 $b_{3}$（$\\mathrm{throw}\\ F$）到最近的匹配 $F$ 的内部 catch：$b_{3} \\rightarrow b_{6}$。\n- 从 $b_{4}$（$\\mathrm{throw}\\ G$）到最近的匹配 $G$ 的内部 catch：$b_{4} \\rightarrow b_{8}$。\n- 从 $b_{7}$（在 $\\mathrm{catch}(F)$ 后的 $\\mathrm{rethrow}$）到最近的包围的、匹配 $E$ 的外部 catch：$b_{7} \\rightarrow b_{11}$，因为在类型层次结构中 $F \\rightarrow E$，并且在 rethrow 之后，内部 try 不再是包围块。\n- 从 $b_{9}$（在 $\\mathrm{catch}(G)$ 后的 $\\mathrm{rethrow}$）到最近的包围的、匹配 $E$ 的外部 catch：$b_{9} \\rightarrow b_{11}$，因为 $G \\rightarrow E$。\n\n从入口开始的可达性分析过程如下：\n- 从 $b_{0}$ 开始，我们到达 $b_{1}$，然后是 $b_{2}$。\n- 从 $b_{2}$ 出发，$b_{3}$ 和 $b_{4}$ 都可能到达，这取决于 $p$ 的运行时值；在 CFG 术语中，两个后继都被包括在内。\n- 从 $b_{3}$ 出发，唯一的后继是通过异常边到达的 $b_{6}$；从 $b_{4}$ 出发，唯一的后继是通过异常边到达的 $b_{8}$。\n- 从 $b_{6}$，我们到达 $b_{7}$；然后从 $b_{7}$，唯一的后继是通过异常边到达的 $b_{11}$（外部 $\\mathrm{catch}(E)$）。类似地，从 $b_{8}$ 我们到达 $b_{9}$；从 $b_{9}$ 我们通过异常边到达 $b_{11}$。\n- 从 $b_{11}$，我们到达 $b_{12}$，然后是 $exit$。\n\n因为从 $b_{2}$ 出来的两个分支都立即 throw，并且两个内部 catch 都立即 rethrow，所以没有可达路径到达 $b_{5}$ 或 $b_{10}$；因此，$b_{5}$ 和 $b_{10}$ 是不可达的，并从后支配者分析中排除。因此，可达节点集是\n$$\nR = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9}, b_{11}, b_{12}, exit \\}.\n$$\n\n我们现在应用关于 $b_{11}$ 的严格后支配定义。如果从节点 $u \\in R$ 到 $exit$ 的每条路径都包含 $b_{11}$ 且 $u \\neq b_{11}$，则 $u$ 被 $b_{11}$ 严格后支配。我们按类别考虑：\n\n- 内部 throw 之前和分支块 $b_{0}, b_{1}, b_{2}$：从这些块中的每一个出发，所有路径都通向 $b_{3}$ 或 $b_{4}$，然后进入相应的内部 catch（$b_{6}$ 或 $b_{8}$），然后 rethrow（$b_{7}$ 或 $b_{9}$），接着到 $b_{11}$，再到 $b_{12}$，最后到 $exit$。没有可以绕过 $b_{11}$ 的替代路径，因为两个内部处理器都 rethrow，并且内部 try 之后没有到 $b_{10}$ 的正常续行路径。因此，$b_{11}$ 后支配 $b_{0}, b_{1}, b_{2}$。\n\n- Throw 块 $b_{3}$ 和 $b_{4}$：每个块都立即转移到相应的内部 catch，然后 rethrow 到 $b_{11}$。因此，从 $b_{3}$ 和 $b_{4}$ 到 $exit$ 的所有路径都包含 $b_{11}$。因此，$b_{11}$ 后支配 $b_{3}$ 和 $b_{4}$。\n\n- 内部 catch 主体和 rethrow 块 $b_{6}, b_{7}, b_{8}, b_{9}$：从 $b_{6}$ 出发，唯一的路径是到 $b_{7}$ 然后到 $b_{11}$；从 $b_{7}$ 出发，唯一的路径直接到 $b_{11}$。$b_{8}$ 和 $b_{9}$ 的情况类似。因此，从这些节点出发的所有路径都包含 $b_{11}$，所以 $b_{11}$ 后支配 $b_{6}, b_{7}, b_{8}, b_{9}$。\n\n- 根据严格性（$u \\neq b_{11}$），外部 catch $b_{11}$ 本身被排除。\n\n- Catch 后的续行块 $b_{12}$：从 $b_{12}$ 出发的路径直接到 $exit$；它们不包含 $b_{11}$，因为 $b_{11}$ 在 $b_{12}$ 之前。因此，$b_{11}$ 不后支配 $b_{12}$。\n\n因此，被 $b_{11}$ 严格后支配的可达节点集合是\n$$\nS = \\{ b_{0}, b_{1}, b_{2}, b_{3}, b_{4}, b_{6}, b_{7}, b_{8}, b_{9} \\}.\n$$\n其基数为\n$$\n|S| = 9.\n$$\n\n这个计数表明了一个属性：外部基类 catch $b_{11}$ 后支配了专门的处理器路径（以及所有必然导致进入这些路径的更早节点），因为内部处理器会 rethrow，并且从这些路径到达 $exit$ 的唯一方式是通过外部基类 catch。因此，被 $b_{11}$ 严格后支配的可达基本块所需数量为 $9$。", "answer": "$$\\boxed{9}$$", "id": "3633641"}]}