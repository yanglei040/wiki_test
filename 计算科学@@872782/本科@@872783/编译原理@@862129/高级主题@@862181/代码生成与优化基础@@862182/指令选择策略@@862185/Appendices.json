{"hands_on_practices": [{"introduction": "将乘法运算替换为更快的移位和加减法组合是编译器中一种经典的强度折减优化。这个练习将挑战你为一个特定的常数乘法找到成本最低的指令序列，这需要你深入思考该常数的二进制表示形式，并比较不同表示法带来的成本差异。通过这个练习，你将亲身体会到，对于同一个计算任务，不同的指令选择策略会如何显著影响最终的性能 [@problem_id:3646809]。", "problem": "一个编译器后端所针对的架构，其指令集包含三种相关操作，具有以下语义和成本：\n- 左移一个立即数：对于任意寄存器值 $v$ 和非负整数 $p$，该操作返回 $v \\ll p$，成本为 $c_{s} = 3$ 个周期。\n- 两寄存器相加：对于任意寄存器值 $u$ 和 $v$，该操作返回 $u + v$，成本为 $c_{a} = 5$ 个周期。\n- 两寄存器相减：对于任意寄存器值 $u$ 和 $v$，该操作返回 $u - v$，成本为 $c_{a} = 5$ 个周期。\n\n假设寄存器数量无限，且寄存器之间的值复制成本可忽略不计。左移 $p=0$ 是一个空操作 (no-op)，成本为零。编译器必须仅使用这些操作来实现与一个已知的固定整数常量 $k$ 的乘法。目标程序为一个输入寄存器 $x$ 计算 $y = k \\cdot x$。指令选择器被限制于将 $y$ 构造成带符号的 $x$ 的移位实例的有限线性组合的策略，具体形式为 $y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})$，其中每个 $s_{i} \\in \\{+1,-1\\}$，每个 $p_{i}$ 是非负整数。该组合通过二元加法和减法实现；不允许其他操作。\n\n从二进制表示的基本事实和恒等式 $x \\ll p = x \\cdot 2^{p}$ 出发，推导在此限制下对于 $k = 1023$ 情况的最小成本指令序列。将最小总成本（以周期为单位）表示为单个实数值。无需四舍五入。", "solution": "用户希望我解决这个问题。我将首先进行验证。\n\n### 步骤1：提取已知条件\n- 操作1：左移。`v \\ll p`。对于非负整数 `p  0`，成本为 `c_{s} = 3` 个周期。对于 `p=0`，成本为 `0`。\n- 操作2：加法。`u + v`。成本为 `c_{a} = 5` 个周期。\n- 操作3：减法。`u - v`。成本为 `c_{a} = 5` 个周期。\n- 假设：寄存器数量无限。\n- 假设：寄存器复制成本可忽略不计。\n- 恒等式：`x \\ll p = x \\cdot 2^{p}`。\n- 任务：为已知的固定整数常量 `k` 实现 `y = k \\cdot x`。\n- 限制：实现必须具有 `y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})` 的形式，其中 `s_{i} \\in \\{+1,-1\\}` 且 `p_{i}` 是非负整数。该和式通过二元加法和减法计算。\n- 具体案例：`k = 1023`。\n- 目标：找到以周期为单位的最小总成本。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学或事实的可靠性**：该问题基于计算机算术和编译器优化的既定原则，特别是针对常数乘法的强度削减。恒等式 `x \\ll p = x \\cdot 2^{p}` 是二进制表示的一个基本属性。这些操作在类RISC架构中是标准的。该问题在科学上是可靠的。\n2.  **不可形式化或不相关**：该问题在指定约束下可以高度形式化为一个优化问题。它与编译器设计中的指令选择策略直接相关。\n3.  **不完整或矛盾的设置**：该问题是自包含的。它提供了允许的操作集、它们的成本、解决方案的结构以及要实现的特定常量 `k`。成本定义明确，包括 `p=0` 的零成本情况。没有矛盾之处。\n4.  **不切实际或不可行**：该设置是一个真实世界编译器问题的简化但合理的模型。无限寄存器的假设是此类分析中常见的简化。数据和条件在模型内部是一致且可行的。\n5.  **不适定或结构不良**：该问题是适定的。它要求最小成本，这定义了一个明确的优化目标。搜索空间是 `k` 表示为2的幂的和/差的集合。存在一个最小解，并且在成本上是唯一的。\n6.  **伪深刻、琐碎或同义反复**：该问题并非琐碎。它需要比较表示常量 `k` 的不同策略，并计算相关成本以找到最优解。多种表示法（例如，标准二进制与非相邻形式）的存在使得优化并非显而易见。\n7.  **超出科学可验证性**：该解可以通过直接计算和比较不同有效指令序列的成本来验证。\n\n### 步骤3：结论和行动\n问题是有效的。我将继续进行解答。\n\n问题要求使用移位、加法和减法操作序列来计算 `y = k \\cdot x` (其中 `k = 1023`) 的最小成本。允许的计算结构是 `y = \\sum_{i=1}^{m} s_{i} \\cdot (x \\ll p_{i})`，其中 `s_i \\in \\{+1,-1\\}`。这等同于找到常量 `k` 的一种 `k = \\sum_{i=1}^{m} s_{i} \\cdot 2^{p_{i}}` 形式的表示，该表示能最小化总指令成本。\n\n总成本 `C` 是移位操作成本与加/减法操作成本之和。\n为了计算 `y`，我们首先需要生成 `m` 个 `x \\ll p_i` 形式的项。然后，这 `m` 个项必须使用 `m-1` 次加法或减法进行组合。\n\n让我们更精确地定义成本函数。\n- 一次 `x \\ll p_i` 移位的成本，如果 `p_i  0` 则为 `c_s = 3`，如果 `p_i = 0` 则为 `0`。设 `N_s` 是和式中 `p_i  0` 的项数。移位的总成本为 `N_s \\cdot c_s`。\n- 组合 `m` 个项需要 `m-1` 次二元运算（加法或减法）。每次运算的成本是 `c_a = 5`。这些运算的总成本是 `(m-1) \\cdot c_a`。\n\n因此，给定表示的总成本 `C` 为：\n$$C = N_s \\cdot c_s + (m-1) \\cdot c_a$$\n代入给定的成本 `c_s = 3` 和 `c_a = 5`：\n$$C = 3N_s + 5(m-1)$$\n\n为了最小化 `C`，我们必须为 `k=1023` 找到一个能最小化 `m` 和 `N_s` 的表示。由于 `c_a  c_s`，最小化 `m`（项数）是降低成本的主要因素。\n\n我们将探讨两种表示 `k = 1023` 的策略。\n\n**策略1：标准二进制表示**\n\n首先，我们将 `k=1023` 表示为其标准二进制形式。\n`1023` 是 `2^{10} - 1`。在二进制中，这是一个由十个 `1` 组成的序列：`1111111111_{2}`。\n这对应于以下和式：\n$$k = 1023 = \\sum_{i=0}^{9} 1 \\cdot 2^i = 2^9 + 2^8 + 2^7 + 2^6 + 2^5 + 2^4 + 2^3 + 2^2 + 2^1 + 2^0$$\n对于此表示法：\n- 项数为 `m = 10`。\n- 幂 `p_i` 为 `\\{9, 8, 7, 6, 5, 4, 3, 2, 1, 0\\}`。\n- `p_i  0` 的移位数目为 `N_s = 9`。项 `2^0` 对应 `x \\ll 0`，其成本为 `0`。\n- 对这 `10` 个项求和所需的加法次数为 `m-1 = 9`。\n\n此策略的总成本 `C_1` 为：\n$$C_1 = 3 \\cdot N_s + 5 \\cdot (m-1) = 3 \\cdot 9 + 5 \\cdot (10-1) = 27 + 5 \\cdot 9 = 27 + 45 = 72$$\n因此，使用标准二进制展开的成本是 `72` 个周期。\n\n**策略2：使用减法的表示（非相邻形式）**\n\n二进制表示中的一串连续 `1` 可以使用恒等式 `\\sum_{i=j}^{n-1} 2^i = 2^n - 2^j` 来简化。\n对于 `k=1023`，即 `\\sum_{i=0}^{9} 2^i`，我们有 `n=10` 和 `j=0`。\n$$k = 1023 = 2^{10} - 2^0 = 1024 - 1$$\n这是将 `k` 表示为两个2的幂的差。\n$$k = 1 \\cdot 2^{10} + (-1) \\cdot 2^0$$\n对于此表示法：\n- 项为 `2^{10}` 和 `-2^0`。项数为 `m=2`。\n- 幂 `p_i` 为 `\\{10, 0\\}`。\n- `p_i  0` 的移位数目为 `N_s = 1`（对于 `p_1=10` 项）。`p_2=0` 项的移位成本为零。\n- 组合这 `2` 个项所需的操作次数为 `m-1 = 1`（一次减法）。\n\n此策略的总成本 `C_2` 为：\n$$C_2 = 3 \\cdot N_s + 5 \\cdot (m-1) = 3 \\cdot 1 + 5 \\cdot (2-1) = 3 + 5 = 8$$\n因此，使用这种更紧凑的表示法的成本是 `8` 个周期。\n\n**最优性分析**\n\n我们已经找到了两种可能的成本，`C_1 = 72` 和 `C_2 = 8`。到目前为止找到的最小成本是 `8`。我们必须确定是否存在更低的成本。\n成本函数 `C = 3N_s + 5(m-1)` 随 `m` 和 `N_s` 的增加而增加。为了达到最小成本，我们必须使用 `m` 和 `N_s` 的最小可能值。\n\n- `m=1` 的表示意味着 `k` 是2的幂。由于 `1023` 不是2的幂，因此必须有 `m \\ge 2`。\n- 表示 `k = 2^{10} - 1` 使用了最小可能的项数，`m=2`。\n- 当 `m=2` 时，成本为 `C = 3N_s + 5(2-1) = 3N_s + 5`。\n- 为了表示 `1023`，我们必须至少有一个非零的2的幂（即 `p_i  0`），所以 `N_s \\ge 1`。\n- 表示 `2^{10} - 1` 有一个非零的幂 (`2^{10}`），所以 `N_s=1`。\n- 这种配置（`m=2`, `N_s=1`）产生的成本为 `3 \\cdot 1 + 5 = 8`。这是任何具有 `m=2` 个项的表示的最小可能成本。\n\n任何具有 `m \\ge 3` 个项的表示的成本为 `C = 3N_s + 5(m-1) \\ge 3 \\cdot N_s + 5(3-1) = 3N_s + 10`。由于 `N_s \\ge 1`，该成本将至少为 `13`，大于 `8`。\n\n因此，将 `k = 1023` 表示为 `2^{10} - 1` 是最优的，最小成本为 `8` 个周期。\n\n指令序列将是：\n1. 计算 `t_1 = x \\ll 10`。成本：`3` 个周期。\n2. 值 `x` 即为 `x \\ll 0`。成本：`0` 个周期。\n3. 计算 `y = t_1 - x`。成本：`5` 个周期。\n总成本：`3 + 0 + 5 = 8` 个周期。", "answer": "$$\n\\boxed{8}\n$$", "id": "3646809"}, {"introduction": "在循环中访问数组是程序中最常见的操作之一，因此对其进行优化至关重要。现代处理器提供了复杂的寻址模式，能够将地址计算（如基地址 + 索引 × 缩放因子）合并到单条内存访问指令中。本练习将通过一个具体的循环更新任务，让你量化比较使用和不使用高级寻址模式两种策略的性能差异，从而揭示指令选择如何利用硬件特性来提升代码效率 [@problem_id:3646830]。", "problem": "编译器后端必须为一个中间表示 (IR) 中的紧凑循环生成目标代码，该循环对一个包含 $n$ 个 $64$ 位整数的连续数组执行逐元素更新 $a[i] = a[i] + k$。该中间表示 (IR) 使用带有显式地址算术和加载/存储操作的三地址码，并且目标机器支持比例变址寻址模式。\n\n$IR$ 中的循环体（使用临时变量 $t_1, t_2, \\dots$）如下：\nL:\n$t_1 \\leftarrow i \\times w$\n$t_2 \\leftarrow base\\_a + t_1$\n$t_3 \\leftarrow \\text{load}(t_2)$\n$t_4 \\leftarrow t_3 + k$\n$\\text{store}(t_2, t_4)$\n$i \\leftarrow i + 1$\nif $i  n$ goto L\n\n假设如下：\n- 元素大小为 $w = 8$ 字节，因此 $a[i]$ 位于地址 $base\\_a + i \\times w$。\n- 目标机器在加载和存储指令中都支持形式为 $[r_b + r_i \\times s]$ 的内存操作数，其中 $s \\in \\{1, 2, 4, 8\\}$。\n- 循环索引 $i$、边界 $n$、常量 $k$ 和基地址 $base\\_a$ 在整个循环过程中都保存在寄存器中。忽略循环设置开销，并假设没有寄存器溢出。\n- 成本模型（每条动态指令的延迟）如下：\n  - 整数加法或减法：$1$ 个周期。\n  - 整数乘法：$3$ 个周期。\n  - 比较：$1$ 个周期。\n  - 条件分支（假设总是正确预测）：$1$ 个周期。\n  - 加载或存储（使用任何合法寻址模式）：每个 $4$ 个周期。\n\n考虑两种指令选择策略：\n- 策略 A (朴素策略)：在每次迭代中，在寄存器中计算出 $i \\times w$ 的值，然后与 $base\\_a$ 相加，以计算加载和存储所用的地址。\n- 策略 B (寻址模式折叠)：在加载和存储指令中都使用比例变址寻址模式 $[base\\_a + i \\times w]$，从而消除了循环体中对 $i \\times w$ 的显式计算以及独立的基地址加法。循环仍然将 $i$ 递增 $1$ 并执行比较和分支操作。\n\n仅使用上述假设并从给定的 $IR$ 循环出发，推导策略 A 和策略 B 的每次迭代动态成本，然后计算在使用策略 B 而非策略 A 处理 $n = 4096$ 个元素时的总周期节省。将最终答案表示为一个精确的实数。无需四舍五入。", "solution": "用户希望我分析给定中间表示 (IR) 循环的两种指令选择策略，计算它们各自的每次迭代成本，并确定在特定迭代次数下的总周期节省。\n\n该问题已经过验证，并被认为是有效的，因为它是编译器设计领域中一个定义明确、具有科学依据的问题。所有必要的数据和约束条件均已提供。\n\n首先，我们必须根据所提供的 IR 和成本模型，确定每种策略的机器指令序列及其相关成本。循环执行 $n$ 次迭代，其中 $n = 4096$。\n\n我们将策略 A 的每次迭代成本表示为 $C_A$，策略 B 的每次迭代成本表示为 $C_B$。IR 中的循环体如下：\n$1$. `$t_1 \\leftarrow i \\times w$`\n$2$. `$t_2 \\leftarrow base\\_a + t_1$`\n$3$. `$t_3 \\leftarrow \\text{load}(t_2)$`\n$4$. `$t_4 \\leftarrow t_3 + k$`\n$5$. `$\\text{store}(t_2, t_4)$`\n$6$. `$i \\leftarrow i + 1$`\n$7$. `if i  n goto L`\n\n机器指令成本如下：\n- 整数加法/减法：$1$ 个周期\n- 整数乘法：$3$ 个周期\n- 比较：$1$ 个周期\n- 条件分支：$1$ 个周期\n- 加载或存储：$4$ 个周期\n\n元素大小为 $w = 8$ 字节。\n\n**策略 A (朴素策略) 分析**\n该策略为 IR 中的每个操作生成一条独立的机器指令。我们分析循环体对应的指令成本。\n\n1.  `$t_1 \\leftarrow i \\times w$`: 这对应一条整数乘法指令。\n    成本：$3$ 个周期。\n2.  `$t_2 \\leftarrow base\\_a + t_1$`: 这是一条整数加法指令，用于计算最终地址。\n    成本：$1$ 个周期。\n3.  `$t_3 \\leftarrow \\text{load}(t_2)$`: 一条加载指令，使用寄存器中计算出的地址。\n    成本：$4$ 个周期。\n4.  `$t_4 \\leftarrow t_3 + k$`: 核心的逐元素加法。\n    成本：$1$ 个周期。\n5.  `$\\text{store}(t_2, t_4)$`: 一条存储指令，使用相同的计算地址。\n    成本：$4$ 个周期。\n6.  `$i \\leftarrow i + 1$`: 循环索引递增。\n    成本：$1$ 个周期。\n7.  `if i  n goto L`: 这包括一个比较和随后的一个条件分支。\n    - 比较 $i$ 和 $n$：$1$ 个周期。\n    - 条件分支：$1$ 个周期。\n    循环控制的总成本：$1 + 1 = 2$ 个周期。\n\n策略 A 每次迭代的总成本是这些成本的总和：\n$$ C_A = 3 (\\text{mul}) + 1 (\\text{add}) + 4 (\\text{load}) + 1 (\\text{add}) + 4 (\\text{store}) + 1 (\\text{inc}) + 1 (\\text{cmp}) + 1 (\\text{branch}) $$\n$$ C_A = 16 \\text{ cycles} $$\n\n**策略 B (寻址模式折叠) 分析**\n该策略利用目标机器的比例变址寻址模式 $[r_b + r_i \\times s]$，将地址计算合并到加载和存储指令中。这里，$r_b$ 保存 $base\\_a$，$r_i$ 保存 $i$，比例因子 $s$ 设置为元素宽度 $w = 8$。机器支持 $s=8$，因此这是一个合法的优化。\n\n1.  `$t_1 \\leftarrow i \\times w$` 和 `$t_2 \\leftarrow base\\_a + t_1$`: 这两条 IR 语句不被翻译成独立的机器指令。相反，它们的功能被“折叠”到内存操作的寻址模式中。\n    显式指令成本：$0$ 个周期。\n2.  `$t_3 \\leftarrow \\text{load}(t_2)$`: 这变成一条使用复杂寻址模式 $[base\\_a + i \\times 8]$ 的单一 `load` 指令。题目说明，无论寻址模式如何，`load` 指令的成本都是 $4$ 个周期。\n    成本：$4$ 个周期。\n3.  `$t_4 \\leftarrow t_3 + k$`: 核心的逐元素加法仍然保留。\n    成本：$1$ 个周期。\n4.  `$\\text{store}(t_2, t_4)$`: 与 `load` 类似，这变成一条使用 $[base\\_a + i \\times 8]$ 寻址模式的单一 `store` 指令。成本也是 $4$ 个周期。\n    成本：$4$ 个周期。\n5.  `$i \\leftarrow i + 1$`: 循环索引递增不变。\n    成本：$1$ 个周期。\n6.  `if i  n goto L`: 循环控制逻辑也不变。\n    - 比较 $i$ 和 $n$：$1$ 个周期。\n    - 条件分支：$1$ 个周期。\n    循环控制的总成本：$1 + 1 = 2$ 个周期。\n\n策略 B 每次迭代的总成本是这些成本的总和：\n$$ C_B = 4 (\\text{load}) + 1 (\\text{add}) + 4 (\\text{store}) + 1 (\\text{inc}) + 1 (\\text{cmp}) + 1 (\\text{branch}) $$\n$$ C_B = 12 \\text{ cycles} $$\n\n**总节省计算**\n每次迭代的节省是两种策略成本之间的差值：\n$$ S_{\\text{iter}} = C_A - C_B = 16 - 12 = 4 \\text{ cycles} $$\n这一节省来自于消除了策略 A 中用于地址计算的显式 `MUL`（成本 $3$ 个周期）和 `ADD`（成本 $1$ 个周期）指令。\n\n需要处理的元素总数为 $n = 4096$。这对应于循环的 $4096$ 次迭代。\n总周期节省 $S_{\\text{total}}$ 是每次迭代的节省乘以迭代次数：\n$$ S_{\\text{total}} = n \\times S_{\\text{iter}} = 4096 \\times 4 $$\n$$ S_{\\text{total}} = 16384 $$\n总周期节省为 $16384$。", "answer": "$$\\boxed{16384}$$", "id": "3646830"}, {"introduction": "理论上的指令选择必须面对现实世界中硬件架构的限制，例如指令中立即数字段的位数有限。当代码中出现超出此范围的大常数时，编译器必须生成额外的指令来加载它们，这会带来性能开销。这个练习模拟了这种情况，要求你在只有一个专用寄存器可用时，通过智能地重新排序指令来最大限度地重用已加载的常数，从而最小化昂贵的内存加载次数 [@problem_id:3646810]。", "problem": "您正在为一台简单的标量机进行编译，需要为一个中间表示（IR）基本块执行指令选择，该基本块中的常量超出了立即数编码的范围。目标是最小化仅因实体化大常量而引入的额外内存加载次数。请考虑以下目标机和IR，然后选择能够最小化每次执行该块时字面量加载次数的指令选择策略。\n\n目标机模型和约束：\n- 立即数编码限制：带立即数的加法指令 $\\mathrm{ADDI}\\ R_d, R_s, \\mathrm{imm}$ 只接受范围在 $[-2{,}048, 2{,}047]$ 内的有符号立即数 $\\mathrm{imm}$（即 $12$ 位有符号数）。\n- 寄存器-寄存器加法 $\\mathrm{ADD}\\ R_d, R_s, R_t$ 可用，且仅使用寄存器。\n- 字面量加载：$\\mathrm{LDRL}\\ R_d, [\\mathrm{PC}+\\mathrm{off}]$ 从字面量池中加载一个完整的 $32$ 位字面量（基于程序计数器（PC）的相对寻址）。就本问题而言，每次 $\\mathrm{LDRL}$ 计为一次“额外加载”。\n- 常量寄存器约束：寄存器分配器提供且仅提供一个额外的通用寄存器 $r_c$ 用于存放任何实体化的字面量。任何 $\\mathrm{LDRL}$ 操作都必须以 $r_c$ 为目标寄存器。在任何时候，$r_c$ 最多只能持有一个字面量值；要改变 $r_c$ 中的值，需要发出另一条 $\\mathrm{LDRL}$ 指令（一次额外加载）。不允许使用其他寄存器来存放字面量，否则会发生在此处不允许的寄存器溢出（spilling）。\n- 映射约束：每个IR加法必须由一条机器指令 $\\mathrm{ADD}$ 或一条机器指令 $\\mathrm{ADDI}$ 实现。您不能将一个IR加法分解为多个加法来“累积”一个大常量。允许使用 $\\mathrm{LDRL}$ 将一个操作数（大常量）加载到寄存器中，但IR加法本身仍然只对应一条 $\\mathrm{ADD}$ 或一条 $\\mathrm{ADDI}$ 指令。\n- 调度：在基本块内部，当且仅当数据依赖关系得以保留时，您可以对指令进行重排序。不允许进行代数重组（例如改变加法的分组或创建新的常量）。\n\nIR基本块（三地址码；变量 $a、b、c、d$ 在入口处是活跃的）：\n- $t_1 := \\mathrm{add}(a, 50{,}000)$\n- $t_2 := \\mathrm{add}(b, 50{,}000)$\n- $t_3 := \\mathrm{add}(t_1, t_2)$\n- $t_4 := \\mathrm{add}(c, 70{,}000)$\n- $t_5 := \\mathrm{add}(t_3, 12)$\n- $t_6 := \\mathrm{add}(d, 1{,}024)$\n- $t_7 := \\mathrm{add}(t_6, 50{,}000)$\n\n已知事实：\n- 立即数 $12$ 和 $1{,}024$ 在 $12$ 位有符号数范围内，因此可以使用 $\\mathrm{ADDI}$ 而无需任何字面量加载。\n- 立即数 $50{,}000$ 和 $70{,}000$ 超出了 $12$ 位有符号数范围，因此无法在单条 $\\mathrm{ADDI}$ 指令中编码。要将这些数提供给 $\\mathrm{ADD}$ 指令，您必须通过 $\\mathrm{LDRL}$ 将常量实体化到 $r_c$ 中，然后使用以 $r_c$ 为第三个操作数的 $\\mathrm{ADD}$ 指令。\n\n问题：在上述约束条件下，哪种策略能在每次执行该块时产生最少的字面量加载（即 $\\mathrm{LDRL}$ 指令）次数？\n\nA. 不进行重排序。对于每个带有大常量的IR加法，在使用它的相应 $\\mathrm{ADD}$ 指令之前，立即发出 $\\mathrm{LDRL}\\ r_c, \\text{const}$ 指令。\n\nB. 不进行重排序。将 $50{,}000$ 提升并在整个块的执行过程中都保留在 $r_c$ 中（在块入口处加载一次），在需要 $50{,}000$ 的地方都使用 $\\mathrm{ADD}$；当需要 $70{,}000$ 时，仅在该使用之前将 $r_c$ 的值更改为 $70{,}000$，然后在后续使用前再将其改回 $50{,}000$。\n\nC. 合法地重排序独立的IR语句，将所有对 $50{,}000$ 的使用聚集在对 $70{,}000$ 的单次使用之前；在该聚集的指令簇中，将 $50{,}000$ 保留在 $r_c$ 中，然后为其单次使用切换一次 $r_c$ 到 $70{,}000$。\n\nD. 像选项C一样进行合法重排序，但是提升并保留 $70{,}000$ 在 $r_c$ 中，而在每次使用 $50{,}000$ 时都重新加载它。", "solution": "用户提供的问题是有效的。这是一个编译器理论中定义明确的问题，具体涉及指令选择和调度，具有清晰的约束和可衡量的目标。所有术语都是该学科的标准术语，模型虽然简化，但具有科学依据。\n\n问题要求找到一种指令选择策略，以最小化处理给定中间表示（IR）基本块中大常量所需的字面量加载（`$\\mathrm{LDRL}$`指令）次数。\n\n首先，让我们形式化IR及其依赖关系。IR指令如下：\n- $I_1: t_1 := \\mathrm{add}(a, 50{,}000)$\n- $I_2: t_2 := \\mathrm{add}(b, 50{,}000)$\n- $I_3: t_3 := \\mathrm{add}(t_1, t_2)$\n- $I_4: t_4 := \\mathrm{add}(c, 70{,}000)$\n- $I_5: t_5 := \\mathrm{add}(t_3, 12)$\n- $I_6: t_6 := \\mathrm{add}(d, 1{,}024)$\n- $I_7: t_7 := \\mathrm{add}(t_6, 50{,}000)$\n\n数据依赖关系构成一个有向无环图（DAG）：\n- $I_1 \\rightarrow I_3$（因为 $I_3$ 使用 $t_1$）\n- $I_2 \\rightarrow I_3$（因为 $I_3$ 使用 $t_2$）\n- $I_3 \\rightarrow I_5$（因为 $I_5$ 使用 $t_3$）\n- $I_6 \\rightarrow I_7$（因为 $I_7$ 使用 $t_6$）\n指令 $I_4$ 独立于块中的所有其他指令，因为它使用输入变量 $c$ 并产生一个在块内未被使用的结果 $t_4$。\n\n机器约束规定，任何超出范围 $[-2{,}048, 2{,}047]$ 的立即数值都必须使用 `$\\mathrm{LDRL}$` 指令从字面量池加载到专用寄存器 $r_c$ 中。\n- 常量 $12$ 和 $1{,}024$ 在范围内，可以在 `$\\mathrm{ADDI}$` 指令中编码，无需额外加载。\n- 常量 $50{,}000$ 和 $70{,}000$ 超出此范围。它们需要一条 `$\\mathrm{LDRL}$` 指令将值加载到 $r_c$ 中，然后是一条使用 $r_c$ 的 `$\\mathrm{ADD}$` 指令。\n\n大常量的使用情况如下：\n- 常量 $50{,}000$ 在 $I_1$、$I_2$ 和 $I_7$ 中使用。\n- 常量 $70{,}000$ 在 $I_4$ 中使用。\n\n目标是最小化 `$\\mathrm{LDRL}$` 指令的总数。这可以通过智能地调度指令和管理常量寄存器 $r_c$ 的内容来实现。我们现在将评估每种提出的策略。\n\n### 选项A分析\n\n**策略**：不进行重排序。对于每个带有大常量的IR加法，在使用它的相应 `$\\mathrm{ADD}$` 之前，立即发出 `$\\mathrm{LDRL}\\ r_c, \\text{const}$` 指令。\n\n这是一种朴素的局部策略，不尝试重用已存在于 $r_c$ 中的常量。指令序列固定为 $I_1, I_2, I_3, I_4, I_5, I_6, I_7$。\n\n1.  对于 $I_1$（使用 $50{,}000$）：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_2$（使用 $50{,}000$）：该策略规定每次使用都要发出 `$\\mathrm{LDRL}$`。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（2次加载）\n3.  $I_3$ 没有大常量。\n4.  对于 $I_4$（使用 $70{,}000$）：发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（3次加载）\n5.  $I_5$ 和 $I_6$ 是小立即数。\n6.  对于 $I_7$（使用 $50{,}000$）：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（4次加载）\n\n总字面量加载次数：$4$。\n\n**结论**：不正确。该策略效率极低。\n\n### 选项B分析\n\n**策略**：不进行重排序。将 $50{,}000$ 提升并在块入口处加载一次，保留在 $r_c$ 中，但当需要 $70{,}000$ 时，将 $r_c$ 切换为 $70{,}000$，然后在最后一次使用前再切换回 $50{,}000$。\n\n指令序列是固定的。该策略试图优化重用，但受限于固定的顺序。\n\n1.  在块入口处：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_1$（使用 $50{,}000$）：使用 $r_c$。无新加载。\n3.  对于 $I_2$（使用 $50{,}000$）：使用 $r_c$。无新加载。\n4.  $I_3$ 没有大常量。\n5.  对于 $I_4$（使用 $70{,}000$）：$r_c$ 中的值是 $50{,}000$。我们必须切换。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（2次加载）\n6.  在 $I_4$ 之后，策略要求为稍后在 $I_7$ 中的使用切换回 $50{,}000$。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（3次加载）\n7.  $I_5$ 和 $I_6$ 是小立即数。\n8.  对于 $I_7$（使用 $50{,}000$）：使用 $r_c$，它现在存有 $50{,}000$。无新加载。\n\n总字面量加载次数：$3$。\n\n**结论**：不正确。这比策略A好，但不进行重排序迫使采用了一种次优的加载-重加载模式。\n\n### 选项C分析\n\n**策略**：合法地重排序IR语句，将所有对 $50{,}000$ 的使用聚集在对 $70{,}000$ 的单次使用之前。在其使用期间将 $50{,}000$ 保留在 $r_c$ 中，然后切换到 $70{,}000$。\n\n该策略将指令调度与对 $r_c$ 的智能管理相结合。目标是在需要 $70{,}000$ 的任何计算之前，执行所有需要 $50{,}000$ 的计算。由于 $I_4$（使用 $70{,}000$）独立于其他指令链，它可以被移动到所有其他指令之后。一个合法的、重排序后的调度是：$I_1, I_2, I_3, I_6, I_7, I_5, I_4$。一个同样能达到目标的更简单的调度是：\n1.  $I_1: t_1 := \\mathrm{add}(a, 50{,}000)$\n2.  $I_2: t_2 := \\mathrm{add}(b, 50{,}000)$\n3.  $I_6: t_6 := \\mathrm{add}(d, 1{,}024)$\n4.  $I_7: t_7 := \\mathrm{add}(t_6, 50{,}000)$\n5.  $I_3: t_3 := \\mathrm{add}(t_1, t_2)$\n6.  $I_5: t_5 := \\mathrm{add}(t_3, 12)$\n7.  $I_4: t_4 := \\mathrm{add}(c, 70{,}000)$\n\n这个调度是合法的，因为所有依赖关系都得到了遵守。大常量使用的顺序变为：$50{,}000$（$I_1$）、$50{,}000$（$I_2$）、$50{,}000$（$I_7$），最后是 $70{,}000$（$I_4$）。\n\n1.  在块入口处：发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（1次加载）\n2.  对于 $I_1, I_2, I_7$：使用 $r_c$ 中的值。无新加载。\n3.  对于 $I_4$（使用 $70{,}000$）：$r_c$ 中的值是 $50{,}000$。我们必须切换。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（2次加载）\n\n总字面量加载次数：$2$。\n\n**结论**：正确。该策略是最佳的。它通过调度指令来最大化对最频繁使用的大常量的重用，然后在切换到另一个常量之前，从而最小化了加载次数。\n\n### 选项D分析\n\n**策略**：像选项C一样进行合法重排序，但是提升并保留 $70{,}000$，而在每次使用 $50{,}000$ 时都重新加载它。\n\n该策略重排序了指令，但在优先选择哪个常量上做出了糟糕的决定。一个合法的调度会将 $I_4$ 放在首位，然后是其他指令，同时遵守它们的依赖关系。\n示例调度：$I_4, I_1, I_2, I_6, I_7, I_3, I_5$。\n\n加载策略被描述为“提升并保留 $70{,}000$”（一个智能的、全局的选择），但“在每次使用 $50{,}000$ 时都重新加载它”（一个朴素的、局部的选择）。我们按其所述评估该策略。\n\n1.  在块入口处：为 $I_4$ 提升常量。发出 `$\\mathrm{LDRL}\\ r_c, =70000$`。（1次加载）\n2.  对于 $I_4$：使用 $r_c$。\n3.  对于 $50{,}000$ 的第一次使用（$I_1$）：策略说每次使用都要加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（2次加载）\n4.  对于 $50{,}000$ 的第二次使用（$I_2$）：策略说每次使用都要加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（3次加载）\n5.  对于 $50{,}000$ 的第三次使用（$I_7$）：策略说每次使用都要加载。发出 `$\\mathrm{LDRL}\\ r_c, =50000$`。（4次加载）\n\n总字面量加载次数：$4$。\n即使更宽容地将“每次使用时都加载”解释为“需要时加载”，该策略也需要先加载 $70{,}000$（1次加载），然后为后续使用加载 $50{,}000$（1次加载），总共也是2次加载，与选项C相同。然而，明确的措辞“在每次使用时都加载...”与“提升并保留”的措辞形成对比，这表明对未提升的常量采用了朴素的实现方式。这使得D中描述的策略劣于C。鉴于所给选项，C描述了明确的最优方法。\n\n**结论**：不正确。该策略是次优的，原因在于它要么优先考虑了频率较低的常量，要么为频率较高的常量明确指定了朴素的加载方法。\n\n**总结**：\n- 策略A：$4$ 次加载\n- 策略B：$3$ 次加载\n- 策略C：$2$ 次加载\n- 策略D：$4$ 次加载\n\n最少的字面量加载次数是 $2$ 次，由策略C实现。", "answer": "$$\\boxed{C}$$", "id": "3646810"}]}