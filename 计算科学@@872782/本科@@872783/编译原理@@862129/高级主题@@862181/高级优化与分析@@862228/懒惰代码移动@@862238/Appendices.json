{"hands_on_practices": [{"introduction": "要真正掌握懒惰代码移动，我们必须从理论走向实践。我们从剖析懒惰代码移动的内在机制开始。第一个练习要求你为一个给定表达式手动计算其核心的数据流集合——预期性 ($Anticipated$)、可用性 ($Available$)、最早性 ($Earliest$) 和最迟性 ($Latest$)。通过逐步完成这些计算，你将对该算法如何确定在何处以及何时放置计算才是安全且最优的，获得一个具体的理解。[@problem_id:3649357]", "problem": "考虑以下由基本块组成的控制流图（CFG），这些基本块构成一个单入口、单出口的过程。设我们感兴趣的算术表达式为二元表达式 $e \\equiv a + b$。这些块是：\n\n- $B_1$：一个条件分支，跳转到 $B_2$ 或 $B_3$；$B_1$ 不对 $a$ 或 $b$ 赋值，也不计算 $e$。\n- $B_2$：首先计算 $x \\leftarrow a + b$，然后赋值 $a \\leftarrow a + 1$，接着跳转到 $B_4$。\n- $B_3$：一个条件分支，跳转到 $B_4$ 或 $B_5$；$B_3$ 不对 $a$ 或 $b$ 赋值，也不计算 $e$。\n- $B_5$：计算 $y \\leftarrow a + b$，然后跳转到 $B_4$。\n- $B_4$：计算 $z \\leftarrow a + b$，然后返回。\n\n假设没有其他对 $a$ 或 $b$ 的赋值发生。控制流边为 $(B_1,B_2)$、$(B_1,B_3)$、$(B_2,B_4)$、$(B_3,B_4)$、$(B_3,B_5)$、$(B_5,B_4)$。入口块是 $B_1$。你可以假设块内是直线执行的。\n\n你的任务是，仅从核心数据流语义出发，为单个表达式 $e$ 手动计算用于部分冗余消除（PRE）的惰性代码移动（LCM）所使用的以下量：\n\n- $Ant$：$e$ 在每个程序点上的向下安全性（也称为可预期性）（特别是在块入口处的值 $Ant\\_in[B]$ 和块出口处的值 $Ant\\_out[B]$）。\n- $Avail$：$e$ 在每个程序点上的可用性（特别是在块入口处的值 $Avail\\_in[B]$ 和块出口处的值 $Avail\\_out[B]$）。\n- $Earliest$：$e$ 在每条控制流边上的最早安全插入条件。\n- $Latest$：$e$ 在每条控制流边上经过推迟（以不增加执行频率）后的最晚安全插入条件。\n\n你的推导应基于“必须”数据流分析对可预期性和可用性的基本定义：一个“必须”属性在某个程序点成立，当且仅当它在该点出发或到达该点的所有路径上都成立，其汇集运算符定义为逻辑与，并且块内局部传递函数遵循一个块是否计算 $e$ 以及它对于 $e$ 是否是透明的（块内没有对 $e$ 的操作数进行赋值）。除了这些语义，不要假设任何特定的算法捷径。\n\n然后，将 $Latest$ 解释为 LCM 的放置集合：在 $Latest$ 成立的那些边上精确插入 $e$，并删除任何现在变得冗余的原始计算。\n\n计算对于此 CFG 和 $e$，$Latest$ 成立的边的总数 $N$。提供 $N$ 作为你的最终答案。不需要四舍五入。将你的最终答案表示为单个实数值。", "solution": "用户要求我对给定的控制流图（CFG）上的表达式 $e \\equiv a + b$ 进行惰性代码移动（LCM）分析。目标是确定 `Latest` 属性成立的控制流边的数量 $N$，这对应于应该插入 $e$ 计算的边的集合。\n\n首先，我将为每个基本块建立关于表达式 $e \\equiv a+b$ 的局部数据流属性。关键属性是：\n- $e\\_use[B]$: 块 $B$ 在其内部重新定义任何操作数（$a$ 或 $b$）之前计算了 $e$。\n- $e\\_kill[B]$: 块 $B$ 包含对 $e$ 的操作数（$a$ 或 $b$）的赋值。\n- $e\\_gen[B]$: 表达式 $e$ 在 $B$ 中计算，并且其值在 $B$ 的出口处可用。如果 $e$ 被计算且随后在 $B$ 内部未被“杀死”，则该属性为真。\n每个块的属性如下：\n- $B_1$: `条件分支`。不计算 $e$ 也不对 $a$ 或 $b$ 赋值。\n  $e\\_use[B_1] = \\text{false}$, $e\\_kill[B_1] = \\text{false}$, $e\\_gen[B_1] = \\text{false}$。\n- $B_2$: `x ← a + b; a ← a + 1`。计算 $e$，然后对 $a$ 赋值。\n  $e\\_use[B_2] = \\text{true}$, $e\\_kill[B_2] = \\text{true}$, $e\\_gen[B_2] = \\text{false}$ (计算出的值被对 $a$ 的赋值“杀死”了)。\n- $B_3$: `条件分支`。不计算 $e$ 也不对 $a$ 或 $b$ 赋值。\n  $e\\_use[B_3] = \\text{false}$, $e\\_kill[B_3] = \\text{false}$, $e\\_gen[B_3] = \\text{false}$。\n- $B_4$: `z ← a + b`。计算 $e$。\n  $e\\_use[B_4] = \\text{true}$, $e\\_kill[B_4] = \\text{false}$, $e\\_gen[B_4] = \\text{true}$。\n- $B_5$: `y ← a + b`。计算 $e$。\n  $e\\_use[B_5] = \\text{true}$, $e\\_kill[B_5] = \\text{false}$, $e\\_gen[B_5] = \\text{true}$。\n\nLCM 分析分四步进行。\n\n**1. 计算可预期性 ($Ant$)**\n可预期性（或向下安全性）是一个后向“必须”分析。一个表达式在某点是可预期的，如果从该点出发的所有路径上，在它的任一操作数被重新定义之前，该表达式都被使用了。数据流方程为：\n$$Ant\\_out[B] = \\bigwedge_{S \\in succ(B)} Ant\\_in[S]$$\n$$Ant\\_in[B] = e\\_use[B] \\lor (Ant\\_out[B] \\land \\neg e\\_kill[B])$$\n边界条件是 $Ant\\_out[B_{exit}] = \\text{false}$。对于我们的 CFG，$B_4$ 是出口块，所以 $Ant\\_out[B_4] = \\text{false}$。我们将所有其他的 $Ant$ 值初始化为 $\\text{false}$ 并迭代至不动点。\n\n- 迭代 1:\n  - $Ant\\_in[B_4] = e\\_use[B_4] \\lor (Ant\\_out[B_4] \\land \\neg e\\_kill[B_4]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_5] = Ant\\_in[B_4] = \\text{true}$。\n  - $Ant\\_in[B_5] = e\\_use[B_5] \\lor (Ant\\_out[B_5] \\land \\neg e\\_kill[B_5]) = \\text{true} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_2] = Ant\\_in[B_4] = \\text{true}$。\n  - $Ant\\_in[B_2] = e\\_use[B_2] \\lor (Ant\\_out[B_2] \\land \\neg e\\_kill[B_2]) = \\text{true} \\lor (\\text{true} \\land \\text{false}) = \\text{true}$。\n  - $Ant\\_out[B_3] = Ant\\_in[B_4] \\land Ant\\_in[B_5] = \\text{true} \\land \\text{true} = \\text{true}$。\n  - $Ant\\_in[B_3] = e\\_use[B_3] \\lor (Ant\\_out[B_3] \\land \\neg e\\_kill[B_3]) = \\text{false} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n  - $Ant\\_out[B_1] = Ant\\_in[B_2] \\land Ant\\_in[B_3] = \\text{true} \\land \\text{true} = \\text{true}$。\n  - $Ant\\_in[B_1] = e\\_use[B_1] \\lor (Ant\\_out[B_1] \\land \\neg e\\_kill[B_1]) = \\text{false} \\lor (\\text{true} \\land \\text{true}) = \\text{true}$。\n\n经过一次迭代，达到不动点。表达式 $e$ 在每个块的入口处都是可预期的（对所有 $B$，$Ant\\_in[B] = \\text{true}$），并且在除最后一个块外的每个块的出口处也是可预期的（$Ant\\_out[B_4]=\\text{false}$）。\n\n**2. 计算可用性 ($Avail$)**\n可用性是一个前向“必须”分析。一个表达式在某点是可用的，如果所有通往该点的路径上都计算了该表达式，并且之后没有被“杀死”。数据流方程为：\n$$Avail\\_in[B] = \\bigwedge_{P \\in pred(B)} Avail\\_out[P]$$\n$$Avail\\_out[B] = e\\_gen[B] \\lor (Avail\\_in[B] \\land \\neg e\\_kill[B])$$\n边界条件是 $Avail\\_in[B_{entry}] = \\text{false}$。对于我们的 CFG，$B_1$ 是入口块，所以 $Avail\\_in[B_1] = \\text{false}$。我们将所有其他的 $Avail$ 值初始化为 $\\text{false}$ 并进行迭代。\n\n- 迭代 1:\n  - $Avail\\_out[B_1] = e\\_gen[B_1] \\lor (Avail\\_in[B_1] \\land \\neg e\\_kill[B_1]) = \\text{false} \\lor (\\text{false} \\land \\text{true}) = \\text{false}$。\n  - $Avail\\_in[B_2] = Avail\\_out[B_1] = \\text{false}$。\n  - $Avail\\_out[B_2] = e\\_gen[B_2] \\lor (Avail\\_in[B_2] \\land \\neg e\\_kill[B_2]) = \\text{false} \\lor (\\text{false} \\land \\text{false}) = \\text{false}$。\n  - $Avail\\_in[B_3] = Avail\\_out[B_1] = \\text{false}$。\n  - $Avail\\_out[B_3] = e\\_gen[B_3] \\lor (Avail\\_in[B_3] \\land \\neg e\\_kill[B_3]) = \\text{false} \\lor (\\text{false} \\land \\text{true}) = \\text{false}$。\n  - $Avail\\_in[B_5] = Avail\\_out[B_3] = \\text{false}$。\n  - $Avail\\_out[B_5] = e\\_gen[B_5] \\lor (Avail\\_in[B_5] \\land \\neg e\\_kill[B_5]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n  - $Avail\\_in[B_4] = Avail\\_out[B_2] \\land Avail\\_out[B_3] \\land Avail\\_out[B_5] = \\text{false} \\land \\text{false} \\land \\text{true} = \\text{false}$。\n  - $Avail\\_out[B_4] = e\\_gen[B_4] \\lor (Avail\\_in[B_4] \\land \\neg e\\_kill[B_4]) = \\text{true} \\lor (\\text{false} \\land \\text{true}) = \\text{true}$。\n\n达到不动点。表达式 $e$ 在任何块的入口处都不可用（对所有 $B$，$Avail\\_in[B] = \\text{false}$）。\n\n**3. 计算 $Earliest$**\n`Earliest` 属性标识了可以安全放置计算的最早点。如果在块 $B$ 的入口处表达式是可预期的（$Ant\\_in[B]$）但尚不可用（$Avail\\_in[B]$），那么在此处插入是安全的。\n$$Earliest\\_in[B] = Ant\\_in[B] \\land \\neg Avail\\_in[B]$$\n使用我们关于 $Ant\\_in$ 和 $Avail\\_in$ 的结果：\n对于所有块 $B \\in \\{B_1, B_2, B_3, B_4, B_5\\}$，我们有 $Ant\\_in[B] = \\text{true}$ 和 $Avail\\_in[B] = \\text{false}$。因此，对所有块，$Earliest\\_in[B] = \\text{true}$。\n\n**4. 计算 $Latest$**\n`Latest` 属性标识了计算可能的最晚放置位置，这是通过将 `Earliest` 的放置点尽可能地向后推迟，而不增加执行频率或越过表达式的使用点来确定的。这可以通过对推迟过程的推理来确定。\n\n- 路径 $B_1 \\to B_2 \\to B_4$：\n$B_2$ 中的计算 $x \\leftarrow a+b$ 是必需的。随后，$B_2$ 块修改了 $a$。因此，$B_4$ 中的计算 $z \\leftarrow a+b$ 依赖于 $a$ 的*新*值，也是必需的。这条路径上没有冗余。一个正确的 LCM 实现不应沿此路径插入任何代码，因为它没有带来任何好处。\n\n- 通过 $B_3$ 的路径：\n在过程的入口处，即 $B_1$ 之前，有一个 `Earliest` 放置点。这可以被推入 $B_1$。由于 $B_1$ 是透明的，并且表达式在其所有后继路径（到 $B_2$ 和 $B_3$）上都是可预期的，所以该放置可以被推到边 $(B_1, B_2)$ 和 $(B_1, B_3)$ 上。\n- 边 $(B_1,B_2)$ 上的放置不能被推迟到 $B_2$ 中，因为 $e\\_use[B_2]=\\text{true}$。然而，如前所述，此路径没有提供冗余，因此这里不应出现 `Latest` 放置。问题源于简单的 `Earliest` 分析，它没有考虑盈利性，将整个程序标记为插入的候选。一个更细致的分析会显示这里没有好处。\n- 边 $(B_1,B_3)$ 上的放置可以被推迟。$B_3$ 块是透明的（$e\\_use[B_3]=\\text{false}$ 且 $e\\_kill[B_3]=\\text{false}$）。因此，计算从边 $(B_1,B_3)$ 被推到 $B_3$ 的出边，即 $(B_3, B_4)$ 和 $(B_3, B_5)$。这就是“惰性”移动的本质：将计算移动过分支点。\n- 我们能将边 $(B_3, B_4)$ 上的放置推迟到 $B_4$ 块中吗？不能，因为 $B_4$ 使用了该表达式（$e\\_use[B_4]=\\text{true}$）。因此，推迟在此停止，边 $(B_3, B_4)$ 是一个 `Latest` 放置点。\n- 我们能将边 $(B_3, B_5)$ 上的放置推迟到 $B_5$ 块中吗？不能，因为 $B_5$ 使用了该表达式（$e\\_use[B_5]=\\text{true}$）。因此，推迟在此停止，边 $(B_3, B_5)$ 是一个 `Latest` 放置点。\n\n基于这种语义推理（它比一个未能正确建模此特定情况的简化数据流算法的幼稚应用更为稳健），有两条边上 `Latest` 成立。这些放置消除了 $B_4$ 中计算的部分冗余以及 $B_5$ 中原始计算的冗余。\n\n`Latest` 成立的边是 $(B_3,B_4)$ 和 $(B_3,B_5)$。这类边的总数是 $N$。\n\n$$N = 2$$", "answer": "$$\\boxed{2}$$", "id": "3649357"}, {"introduction": "掌握了基础的数据流分析之后，让我们将其应用于一个经典的优化场景：消除部分冗余。本问题呈现了一个常见的控制流模式，其中一个表达式在某些路径上是冗余的，但在其他路径上则不然。你的任务是运用懒惰代码移动的原理来确定正确的代码插入和删除位置，并且更重要地，通过计算期望的执行次数减少量来量化其性能收益。[@problem_id:3649324]", "problem": "考虑编译器中间表示中一个线性区域的以下控制流图 (CFG)。该区域由五个基本块 $B_{0}$、$B_{1}$、$B_{2}$、$B_{3}$ 和 $B_{4}$ 组成，它们之间存在有向边：\n- $B_{0} \\rightarrow B_{1}$，\n- $B_{1} \\rightarrow B_{2}$ 和 $B_{1} \\rightarrow B_{3}$，\n- $B_{2} \\rightarrow B_{4}$ 和 $B_{3} \\rightarrow B_{4}$，\n- $B_{4} \\rightarrow \\text{Exit}$。\n\n每个块的内容如下：\n- $B_{0}$：无语句（入口）。\n- $B_{1}$：$x := a$; $y := b$; 一个条件分支，以概率 $p = \\frac{3}{5}$ 跳转到 $B_{2}$，以概率 $1 - p = \\frac{2}{5}$ 跳转到 $B_{3}$。\n- $B_{2}$：$t := x + y$; $s := t + 1$。\n- $B_{3}$：$r := 2 \\cdot x$。\n- $B_{4}$：$u := x + y$; $v := u \\cdot m$。\n\n假设：\n- 在 $B_{2}$、$B_{3}$ 中，或在 $B_{2}$/$B_{3}$ 的末尾与 $B_{4}$ 的开头之间，没有对 $x$ 或 $y$ 的重定义。\n- $B_{4}$ 之后对 $x + y$ 的唯一使用是通过 $B_{4}$ 中的 $u$；其他地方没有使用。\n- 每次考虑时，该区域执行一次，从 $B_{1}$到 $B_{2}$ 或 $B_{3}$ 的分支是路径可变性的唯一来源。\n\n令惰性代码移动 (Lazy Code Motion, LCM) 表示一种变换，它通过在最晚安全点插入计算，并删除因这些插入而变得不必要的冗余计算，来消除部分冗余。\n\n你的任务是：\n1. 对于表达式 $e = x + y$，在惰性代码移动下，以块粒度计算 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合。对于本问题，将 $\\mathrm{Insert}(B)$ 理解为“在块 $B$ 的入口处插入 $e$ 的计算”，将 $\\mathrm{Delete}(B)$ 理解为“删除块 $B$ 内部 $e$ 的原始计算”。\n2. 使用给定的分支概率，计算在应用 LCM 之前和之后，每次执行该区域时 $e$ 的动态求值期望次数。\n3. 作为你的最终答案，提供每次执行该区域时 $e$ 的动态求值次数的期望减少量（即，LCM 前的期望次数减去 LCM 后的期望次数）。请用精确分数表示你的答案，不要四舍五入。", "solution": "该问题陈述清晰，科学上基于编译器优化的原理，并提供了确定唯一解所需的所有信息。因此，该问题是有效的。我们开始进行解答。\n\n分析的核心是所提供的控制流图 (CFG) 中的表达式 $e = x + y$。目标是应用惰性代码移动 (LCM) 来减少此表达式的动态求值次数。LCM 是一种部分冗余消除 (PRE) 算法，它通过尽可能晚地放置代码来避免不必要的过早计算。\n\n首先，我们必须分析原始程序中表达式 $e = x+y$ 出现的位置。\n- 在基本块 $B_2$ 中，计算了该表达式：$t := x + y$。其结果随后在同一块中被 $s := t + 1$ 使用。\n- 在基本块 $B_4$ 中，再次计算了该表达式：$u := x + y$。\n\n该 CFG 具有菱形结构，路径在 $B_1$ 之后分叉，在 $B_4$ 之前汇合。从 $B_1$ 到 $B_4$ 有两条主要路径：\n1. 路径 $P_1$：$B_1 \\rightarrow B_2 \\rightarrow B_4$\n2. 路径 $P_2$：$B_1 \\rightarrow B_3 \\rightarrow B_4$\n\n我们来检查块 $B_4$ 中计算 $u := x+y$ 的冗余性。\n- 在路径 $P_1$ 上，表达式 $x+y$ 在 $B_2$ 中被计算。由于假设声明 $x$ 和 $y$ 在 $B_1$ 中定义后到在 $B_4$ 中使用前没有被重定义，因此在 $B_2$ 中计算的 $x+y$ 的值在 $B_4$ 的入口处是可用的。所以，在 $B_4$ 中计算 $u := x+y$ 在这条路径上是冗余的。\n- 在路径 $P_2$ 上，表达式 $x+y$ *没有*在 $B_3$ 中被计算。因此，在 $B_4$ 中计算 $u := x+y$ 在这条路径上是必要的。\n\n由于在 $B_4$ 中的计算在通向它的某些路径上是冗余的，但并非在所有路径上都是，因此它被归类为*部分冗余*计算。LCM 的目的就是消除这种部分冗余。这是通过在表达式值不可用的路径上插入计算来实现的，从而使部分冗余的计算变得完全冗余并可删除。\n\n为了使 $B_4$ 中的计算 $u := x+y$ 变得完全冗余，我们必须确保无论走哪条路径，$x+y$ 的值在 $B_4$ 的入口处都是可用的。这要求我们在路径 $P_2$ 上 $B_4$ 之前的某个地方插入 $x+y$ 的计算。在插入位置被限制为块入口的情况下，这条路径上最晚的可能放置点是 $B_4$ 的入口本身。然而，本问题的一个关键方面是在 $B_2$ 内部对 $x+y$ 的使用。这个使用阻止了将路径 $P_1$ 的计算移动到比 $B_2$ 入口更晚的位置。\n\nLCM 算法必须找到一个能满足所有使用的放置点。$B_2$ 中 $e$ 的计算（用于 $s := t+1$）和 $B_4$ 中 $e$ 的计算可以通过将表达式提升到一个支配这两个使用的点来满足。最早的这样的点是 $B_1$ 的出口。在块级粒度上，将计算放置在 $B_1$ 的出口等同于将其插入到它的每个后继节点（$B_2$ 和 $B_3$）的入口处。\n\n这导致了以下的变换：\n1.  一个新的计算 `temp := x+y` 被插入到 $B_2$ 的入口处。\n2.  一个新的计算 `temp := x+y` 被插入到 $B_3$ 的入口处。\n\n现在我们分析这些插入的后果：\n- $B_2$ 中的原始计算 $t := x+y$ 变得完全冗余，因为 `temp`（持有 $x+y$ 的值）在 $B_2$ 的入口处是可用的。这个原始计算被删除，并可以被一个移动指令替换，例如，$t := \\text{temp}$。\n- 在这些插入之后，表达式 $x+y$ 在到达 $B_4$ 之前，在路径 $P_1$ 和 $P_2$ 上都被计算了。因此，`temp` 的值在 $B_4$ 的入口处是可用的。这使得 $B_4$ 中的原始计算 $u := x+y$ 变得完全冗余。它也被删除，并被一个移动指令替换，例如，$u := \\text{temp}$。\n\n基于此分析，我们可以确定 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合。\n\n**任务 1: 计算 $\\mathrm{Insert}$ 和 $\\mathrm{Delete}$ 集合**\n- $\\mathrm{Insert}(B_2)$：我们在 $B_2$ 的入口处插入 $e=x+y$ 的计算。\n- $\\mathrm{Insert}(B_3)$：我们在 $B_3$ 的入口处插入 $e=x+y$ 的计算。\n- $\\mathrm{Delete}(B_2)$：删除 $B_2$ 中 $e=x+y$ 的原始计算。\n- $\\mathrm{Delete}(B_4)$：删除 $B_4$ 中 $e=x+y$ 的原始计算。\n\n因此，集合为 $\\mathrm{Insert} = \\{B_2, B_3\\}$ 和 $\\mathrm{Delete} = \\{B_2, B_4\\}$。\n\n**任务 2: 计算 LCM 前后的动态求值期望次数**\n\n走路径 $P_1$（通过分支到 $B_2$）的概率给定为 $p = \\frac{3}{5}$。\n走路径 $P_2$（通过分支到 $B_3$）的概率为 $1-p = \\frac{2}{5}$。\n该区域执行一次。\n\n**LCM 之前：**\n- 如果走路径 $P_1$（概率为 $\\frac{3}{5}$），$e$ 在 $B_2$ 中求值一次，在 $B_4$ 中又求值一次。这相当于 $2$ 次动态求值。\n- 如果走路径 $P_2$（概率为 $\\frac{2}{5}$），$e$ 仅在 $B_4$ 中求值。这相当于 $1$ 次动态求值。\n期望求值次数 $E_{\\text{before}}$ 为：\n$$E_{\\text{before}} = 2 \\cdot P(P_1) + 1 \\cdot P(P_2) = 2 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{6}{5} + \\frac{2}{5} = \\frac{8}{5}$$\n\n**LCM 之后：**\n- 一个计算被放置在 $B_2$ 的入口和 $B_3$ 的入口。$B_2$ 和 $B_4$ 中的原始计算被删除。\n- 如果走路径 $P_1$（概率为 $\\frac{3}{5}$），代码会执行在 $B_2$ 入口处插入的计算。这是该路径上对 $e$ 的唯一一次求值。这相当于 $1$ 次动态求值。\n- 如果走路径 $P_2$（概率为 $\\frac{2}{5}$），代码会执行在 $B_3$ 入口处插入的计算。这是该路径上对 $e$ 的唯一一次求值。这相当于 $1$ 次动态求值。\n- 无论哪种情况，都只发生一次求值。\n期望求值次数 $E_{\\text{after}}$ 为：\n$$E_{\\text{after}} = 1 \\cdot P(P_1) + 1 \\cdot P(P_2) = 1 \\cdot \\frac{3}{5} + 1 \\cdot \\frac{2}{5} = \\frac{3}{5} + \\frac{2}{5} = 1$$\n\n**任务 3: 计算期望减少量**\n\n动态求值次数的期望减少量是变换前后期望次数之差。\n$$\\text{Reduction} = E_{\\text{before}} - E_{\\text{after}} = \\frac{8}{5} - 1 = \\frac{8}{5} - \\frac{5}{5} = \\frac{3}{5}$$", "answer": "$$\\boxed{\\frac{3}{5}}$$", "id": "3649324"}, {"introduction": "代码移动最具影响力的应用之一是优化循环。最后一个练习聚焦于循环不变代码，即表达式的值在所有迭代中都保持不变的情况。你将分析懒惰代码移动如何正确地识别这类计算并将其提升到循环之外的预备首部 (preheader) 中，并量化这一关键转换带来的显著性能增益。[@problem_id:3649373]", "problem": "考虑以下由控制流图（Control-Flow Graph, CFG）表示的程序。控制流图（CFG）是一个有向图，其节点是基本块，其边代表可能的控制流。节点为 $B_{0}$ 到 $B_{6}$，边如下所述。该程序使用变量 $x$、$y$、$i$ 和一个正整数 $m \\ge 1$。设 $h_{1}(\\cdot)$ 和 $h_{2}(\\cdot)$ 是不修改 $x$ 或 $y$ 的纯函数。\n\n- 块 $B_{0}$：初始化 $x$、$y$ 和 $i$ 为 $x := \\text{input}(),\\ y := \\text{input}(),\\ i := 0$；然后将控制转移到 $B_{1}$。\n- 块 $B_{1}$（前置首部）：一个空块，用于将入口连接到循环；将控制转移到 $B_{2}$。\n- 块 $B_{2}$（循环体入口）：包含一个基于谓词 $p(i)$ 的条件分支：\n  - 如果 $p(i)$ 为真，控制流转到 $B_{3}$。\n  - 如果 $p(i)$ 为假，控制流转到 $B_{4}$。\n- 块 $B_{3}$：包含使用 $u := h_{1}(x + y)$；将控制转移到 $B_{5}$。\n- 块 $B_{4}$：包含使用 $v := h_{2}(x + y)$；将控制转移到 $B_{5}$。\n- 块 $B_{5}$：更新 $i := i + 1$；如果 $i  m$，将控制转移回 $B_{2}$；否则转移到 $B_{6}$。\n- 块 $B_{6}$：退出。\n\n假设循环是 do-while 风格的：在到达 $B_{5}$ 中的退出测试之前，循环体至少执行一次，也就是说，从 $B_{1}$ 开始，不存在可以避免至少执行一次 $B_{3}$ 或 $B_{4}$ 而到达 $B_{6}$ 的路径。同时假设 $x$ 和 $y$ 仅在 $B_{0}$ 中赋值，并且在其他任何地方都不会被修改；因此，$x + y$ 是循环不变量。在每次迭代中，根据 $p(i)$ 的值，$B_{3}$ 或 $B_{4}$ 中只有一个会被执行，并且在所选择的分支中，该迭代会发生一次对 $x + y$ 的使用。\n\n懒惰代码移动（Lazy Code Motion, LCM）是一种程序优化技术，它通过利用数据流属性（如支配性、下向安全性、和预期性）将计算放置在安全且不冗余的位置。循环前置首部是一个支配循环体的块，并允许在进入循环之前执行计算。\n\n任务：\n- 仅使用控制流图（CFG）、支配性、循环不变量表达式的核心定义，以及懒惰代码移动（LCM）避免在不需要表达式的路径上进行计算的定性原则，确定 $x + y$ 计算的 $Latest$ 放置是否会将其置于循环外的 $B_{1}$ 中，而不是循环内的 $B_{2}$ 或更深的位置。将您的决定编码为 $I$，如果 $Latest$ 放置将 $x + y$ 保持在循环外（在 $B_{1}$ 中），则 $I = 1$，否则 $I = 0$。\n- 假设 $x + y$ 的计算被错误地放置在 $B_{2}$ 的开头执行，从而导致无论分支 $p(i)$ 如何，它都在每次迭代中被重新计算一次。将由此产生的总执行次数增量 $$\\Delta \\mathrm{execs} := \\text{(错误放置下的执行次数)} - \\text{($Latest$ 放置下的执行次数)}$$ 量化为关于 $m$ 的闭式表达式。\n\n以一个两元素的行矩阵 $\\begin{pmatrix} I  \\Delta \\mathrm{execs} \\end{pmatrix}$ 的形式提供您的最终答案。无需四舍五入，也无物理单位适用。", "solution": "首先对问题进行验证。\n\n### 步骤 1：提取已知条件\n- **控制流图（CFG）节点：** $B_{0}, B_{1}, B_{2}, B_{3}, B_{4}, B_{5}, B_{6}$。\n- **节点 $B_{0}$：** $x := \\text{input}()$, $y := \\text{input}()$, $i := 0$。\n- **节点 $B_{1}$：** 空的前置首部。\n- **节点 $B_{2}$：** 基于 $p(i)$ 的条件跳转。\n- **节点 $B_{3}$：** 包含使用 $u := h_{1}(x + y)$。\n- **节点 $B_{4}$：** 包含使用 $v := h_{2}(x + y)$。\n- **节点 $B_{5}$：** $i := i + 1$；基于 $i  m$ 的条件跳转。\n- **节点 $B_{6}$：** 退出。\n- **CFG 边：** $B_{0} \\to B_{1}$, $B_{1} \\to B_{2}$, $B_{2} \\to B_{3}$ (如果 $p(i)$), $B_{2} \\to B_{4}$ (如果不是 $p(i)$), $B_{3} \\to B_{5}$, $B_{4} \\to B_{5}$, $B_{5} \\to B_{2}$ (如果 $i  m$), $B_{5} \\to B_{6}$ (如果 $i \\ge m$)。\n- **常量和变量：** $m$ 是一个正整数，$m \\ge 1$。$x, y, i$ 是变量。\n- **函数：** $h_1(\\cdot)$ 和 $h_2(\\cdot)$ 是纯函数。\n- **假设：**\n    1. 循环是“do-while 风格”，保证至少执行一次。\n    2. $x$ 和 $y$ 仅在 $B_0$ 中赋值。\n    3. 表达式 $x+y$ 是循环不变量。\n    4. 在每次迭代中，$B_3$ 或 $B_4$ 中只有一个会被执行，并且每个都包含对 $x+y$ 的一次使用。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在编译器理论和程序优化领域内定义明确。控制流图、循环不变量表达式和懒惰代码移动（LCM）等概念是标准的计算机科学主题。所提供的 CFG 是一致的，假设也已明确陈述。该问题具有科学依据，是客观且自洽的。它不包含任何矛盾或歧义。\n\n### 步骤 3：结论与行动\n问题是**有效的**。将提供解答。\n\n### 解答推导\n任务是根据懒惰代码移动（LCM）的原则确定 $x+y$ 计算的最优位置，并量化非最优放置的成本。\n\n**第 1 部分：$x+y$ 的 `Latest` 放置和 $I$ 的确定**\n\n要优化的表达式是 $E = x + y$。\n1.  **循环不变性：** 问题陈述 $x$ 和 $y$ 仅在入口块 $B_{0}$ 中赋值，并且在循环内不被修改。因此，$E = x+y$ 的值在循环的所有迭代中都是恒定的，使其成为一个循环不变量表达式。这是循环代码移动的主要条件。\n\n2.  **预期性（下向安全性）：** 如果一个表达式在其操作数被重新定义之前，在从某个程序点出发的每条路径上都被使用，那么该表达式在该程序点就是预期的。让我们分析循环前置首部 $B_1$ 入口处的预期性。任何从 $B_1$ 出发的路径都必须前进到 $B_2$，然后到 $B_3$ 或 $B_4$，再到 $B_5$。问题陈述 $x+y$ 在 $B_3$ 和 $B_4$ 中都被使用。因此，无论在 $B_2$ 处采取哪个分支，表达式 $x+y$ 都保证在循环的每次迭代中被使用。由于不存在从 $B_1$ 到出口 $B_6$ 绕过循环的路径，因此表达式 $x+y$ 在 $B_1$ 的入口处是预期的。\n\n3.  **懒惰代码移动（LCM）：** LCM 将计算提升到尽可能早的位置，但在该可提升区域内将其放置在尽可能晚的位置，以最小化寄存器压力，同时不增加总计算次数。只有在安全且有利可图的情况下，才会将计算从循环中提升出来。\n    - **安全性：** 将计算放置在前置首部 $B_1$ 中是安全的，因为每条通过 $B_1$ 的路径都需要该表达式的值。不存在计算会被不必要地执行的路径。\n    - **盈利性：** 原始代码在循环内部计算 $x+y$，每次迭代计算一次。通过将计算移动到只执行一次的前置首部 $B_1$，我们将执行次数从 $m$（迭代次数）减少到 $1$。这是一个有利可图的转换。\n    - **懒惰性：** “懒惰”原则将计算延迟到尽可能晚的位置。然而，这种计算的下沉受到不跨越会增加其执行频率的边界的约束。最早的、循环外的放置位置是前置首部 $B_{1}$。将其从 $B_1$ 下沉到 $B_2$ 会将其从单次执行区域移动到多次执行区域（循环），从而将执行次数从 $1$ 增加到 $m$。LCM 不会执行这样的转换。能够维持执行次数为 $1$ 的最晚可能放置位置是在 $B_1$ 内。\n\n因此，计算 $t := x+y$ 的 `Latest` 放置位置是在循环前置首部 $B_1$ 中。这在循环之外。根据问题陈述，如果放置在 $B_1$ 中，则 $I=1$。\n$$I = 1$$\n\n**第 2 部分：$\\Delta \\mathrm{execs}$ 的计算**\n\n我们需要计算在错误放置和 `Latest` 放置之间，$x+y$ 的总执行次数差异。\n$$\\Delta \\mathrm{execs} = (\\text{错误放置下的执行次数}) - (\\text{Latest 放置下的执行次数})$$\n\n1.  **`Latest` 放置下的执行次数：** 如上所述，计算被放置在 $B_1$ 中。块 $B_1$ 在循环开始前只执行一次。\n    $$ \\text{executions}_{\\text{Latest}} = 1 $$\n\n2.  **错误放置下的执行次数：** 问题指定了在块 $B_2$ 开头的错误放置。块 $B_2$ 是循环体的入口点。为了找出执行次数，我们必须确定循环的迭代次数。\n    - 循环计数器 $i$ 在 $B_0$ 中初始化为 $0$。\n    - 包含 $B_2$ 的循环体被执行。\n    - 在每次迭代结束时，在块 $B_5$ 中，$i$ 会递增（$i := i+1$），并检查条件 $i  m$。\n    - 进入块 $B_2$ 时 $i$ 的值序列是 $0, 1, 2, \\dots$。\n    - 在条件 $i  m$ 中被测试的 $i$ 的值序列是 $1, 2, 3, \\dots$。\n    - 只要检查为真，循环就会继续。循环将在 $i_{check} = 1, 2, \\dots, m-1$ 时执行。循环将最后执行一次，导致检查 $i_{check}=m$。\n    - 对于 $i_{check}=m$，条件 $m  m$ 为假，循环终止。\n    - 对于从 $0$ 到 $m-1$ 的初始值 $i$，循环体都会被进入。\n    - 总迭代次数为 $(m-1) - 0 + 1 = m$。\n    - 由于 $B_2$ 每次迭代执行一次，所以它被执行 $m$ 次。\n    $$ \\text{executions}_{\\text{mis-placed}} = m $$\n\n3.  **执行次数差异：**\n    $$ \\Delta \\mathrm{execs} = \\text{executions}_{\\text{mis-placed}} - \\text{executions}_{\\text{Latest}} = m - 1 $$\n    鉴于 $m \\ge 1$，冗余执行的次数为 $\\Delta \\mathrm{execs} \\ge 0$。\n\n最终答案由 $I$ 和 $\\Delta \\mathrm{execs}$ 组成。\n$I=1$ 且 $\\Delta \\mathrm{execs} = m-1$。", "answer": "$$\\boxed{\\begin{pmatrix} 1  m-1 \\end{pmatrix}}$$", "id": "3649373"}]}