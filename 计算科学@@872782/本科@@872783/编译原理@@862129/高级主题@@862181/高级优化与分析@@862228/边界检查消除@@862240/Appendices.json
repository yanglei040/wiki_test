{"hands_on_practices": [{"introduction": "掌握边界检查消除技术需要从基础开始。本练习将引导你分析一个常见情景：循环中同时访问数组的两个位置，且这两个位置的索引通过一个固定的偏移量相关联 [@problem_id:3625287]。通过解决这个挑战，你将学会如何合并多个不等式约束，从而为编译器推导出绝对安全的循环执行范围，这是静态分析中的一项基本功。", "problem": "考虑一种静态类型语言，其数组从零开始索引。在这种语言中，边界检查通过要求任何数组访问 $a[k]$ 都满足 $0 \\le k  n$ 来确保内存安全，其中 $a$ 是一个长度为 $n$ 的数组。当编译器能够根据程序结构和算术证明循环中的所有数组访问在每次迭代中都满足边界条件时，它会使用边界检查消除技术。假设我们有一个循环变量 $i$ 遍历连续整数，并且索引之间存在仿射关系 $j = i + c$，其中 $c$ 是一个循环不变的整数常量。循环体对同一个长度为 $n$ 的数组 $a$ 执行两次数组访问：$a[i]$ 和 $a[j]$。假设 $n$ 和 $c$ 是满足 $0 \\le c  n$ 的整数，并且循环的下界是 $0$，因此 $i$ 从 $0$ 开始并在每次迭代中增加 $1$。你需要设计一个循环上界 $U$（包含此边界），并推导出消除 $a[i]$ 和 $a[j]$ 两个边界检查所需的对 $i$ 和 $j$ 的同步边界。\n\n仅使用以下基本事实：有效的数组索引必须满足 $0 \\le k  n$，$j = i + c$，$i$ 遍历整数，以及单调仿射函数在整数上保持顺序。推导出最紧凑的包含性上界 $U$，使得对于所有满足 $0 \\le i \\le U$ 的整数 $i$，访问 $a[i]$ 和 $a[j]$ 均可被证明在边界内。你的最终答案必须是这个最大值 $U$ 的一个关于 $n$ 和 $c$ 的单一闭式表达式。最终答案中不要提供不等式或等式；只提供表达式。无需进行取整操作。", "solution": "此问题经评估是有效的。它以编译器设计和静态分析的原理为科学基础，问题设定得当，目标明确，约束充分，并以客观、形式化的语言表述。这是一个程序优化领域的标准问题，可以通过严谨的数学和逻辑推导来解决。\n\n目标是为循环索引 $i$ 找到一个最大的包含性整数上界，记为 $U$，使得两次数组访问 $a[i]$ 和 $a[j]$ 都保证在长度为 $n$ 的数组 $a$ 的有效边界内。循环对满足 $0 \\le i \\le U$ 的所有整数 $i$ 进行迭代。\n\n对于一个长度为 $n$、从零开始索引的数组，一次有效数组访问的基本条件是索引 $k$ 必须满足以下不等式：\n$$0 \\le k  n$$\n\n这个条件必须对循环体内执行的两次访问 $a[i]$ 和 $a[j]$ 都成立。\n\n对于访问 $a[i]$，索引是 $i$。其有效性条件是：\n$$0 \\le i  n \\quad (\\text{约束 1})$$\n\n对于访问 $a[j]$，索引是 $j$。其有效性条件是：\n$$0 \\le j  n \\quad (\\text{约束 2})$$\n\n问题给出了索引 $i$ 和 $j$ 之间的仿射关系：\n$$j = i + c$$\n其中 $c$ 是一个循环不变的整数常量。将这个关系代入约束 2，我们得到一个关于 $i$ 的约束：\n$$0 \\le i + c  n$$\n这个不等式可以分解为两个独立的不等式：\n$$0 \\le i + c \\implies -c \\le i \\quad (\\text{约束 2a})$$\n$$i + c  n \\implies i  n - c \\quad (\\text{约束 2b})$$\n\n为了确保 $a[i]$ 和 $a[j]$ 始终在边界内，循环索引 $i$ 必须在每次迭代中都满足所有推导出的约束。关于 $i$ 的约束集合如下：\n1.  来自循环结构：$i \\ge 0$。\n2.  来自约束 1：$i  n$。\n3.  来自约束 2a：$i \\ge -c$。\n4.  来自约束 2b：$i  n - c$。\n\n我们必须找到一个能同时满足所有这些条件的 $i$ 的单一范围。让我们合并下界和上界。\n\n$i$ 的下界是 $i \\ge 0$ 和 $i \\ge -c$。问题陈述 $c$ 是满足 $0 \\le c  n$ 的整数。由于 $c$ 是非负的，$-c$ 必定是非正的，即 $-c \\le 0$。因此，条件 $i \\ge 0$ 比条件 $i \\ge -c$ 更严格（或者在 $c=0$ 时相等）。所以，$i$ 的有效下界是 $i \\ge 0$。这与循环从 $i=0$ 开始的给定信息是一致的。\n\n$i$ 的上界是 $i  n$ 和 $i  n - c$。同样，我们已知 $0 \\le c  n$。\n- 如果 $c=0$，这两个不等式是相同的：$i  n$。\n- 如果 $c > 0$，那么 $n - c  n$。在这种情况下，不等式 $i  n - c$ 严格比 $i  n$ 更强。\n在 $0 \\le c  n$ 指定的所有情况下，条件 $i  n - c$ 是主导的上界，因为它总是至少和 $i  n$ 一样严格。\n\n结合有效的下界和上界，索引 $i$ 的任何有效值都必须满足：\n$$0 \\le i  n - c$$\n\n循环被定义为对包含性范围 $[0, U]$ 内的所有整数 $i$ 执行。要消除边界检查，此范围内的每个 $i$ 值都必须满足推导出的条件 $0 \\le i  n - c$。这成立的充要条件是，循环范围中的最大值 $U$ 也满足该条件。\n因为 $U \\ge 0$，下界是显然满足的。关键约束来自上界：\n$$U  n - c$$\n\n问题要求的是“最紧凑的包含性上界”$U$。这是满足严格不等式 $U  n - c$ 的最大整数值 $U$。由于 $n$、$c$ 和 $U$ 都是整数，严格小于整数 $n-c$ 的最大整数 $U$ 由下式给出：\n$$U = (n - c) - 1$$", "answer": "$$\\boxed{n - c - 1}$$", "id": "3625287"}, {"introduction": "在上一个练习的基础上，我们来处理一个更贴近实际算法的场景 [@problem_id:3625309]。本练习将分析子数组反转算法中的数组访问，其中一个索引是循环变量的仿射函数。你将运用区间算术这一强大工具，精确推导索引表达式在整个迭代过程中的取值范围，这对于证明复杂访问模式的内存安全性至关重要。", "problem": "考虑一个长度为 $n$ 的数组 $a$，其有效索引 $i$ 满足 $0 \\le i  n$。一个程序通过在闭区间 $[l, r]$上迭代一个整数循环变量 $k$ 来反转子数组 $a[l \\ldots r]$，并在每次迭代中执行两次数组访问：$a[k]$ 和 $a[r - (k - l)]$。假设程序在循环开始前已确定前提条件 $0 \\le l \\le r  n$ 成立。编译器执行边界检查消除（BCE），当它能从程序的算术和控制流约束中证明所访问的索引始终满足 $0 \\le \\text{index}  n$ 时，就会移除一次数组边界检查。\n\n从数组边界检查的核心定义（即有效访问要求 $0 \\le \\text{index}  n$）和经过充分检验的整数区间算术事实（即对于一个仿射函数 $f(k) = \\alpha k + \\beta$，$k \\in [p, q]$，其像 $f([p,q])$ 为 $[\\alpha p + \\beta, \\alpha q + \\beta]$（如果 $\\alpha \\ge 0$）或 $[\\alpha q + \\beta, \\alpha p + \\beta]$（如果 $\\alpha \\le 0$））出发，正式推导在整个循环中两个索引 $k$ 和 $r - (k - l)$ 的紧确边界。使用这些边界来论证在所述前提条件下，编译器是否可以消除整个循环中两次数组访问的边界检查。最后，假设每次数组访问在不进行优化的情况下会产生一次边界检查，计算编译器在整个循环中可以消除的边界检查总数，并将其表示为关于 $l$ 和 $r$ 的闭式表达式。最终答案必须是单一的、无单位的闭式解析表达式。无需四舍五入。", "solution": "目标是确定编译器是否可以消除在一个反转子数组的循环中对两次数组访问 $a[k]$ 和 $a[r - (k - l)]$ 的边界检查，并计算被消除的检查总数。\n\n问题提供了以下已知条件：\n- 一个长度为 $n$ 的数组 $a$。\n- 有效索引 $i$ 的范围由 $0 \\le i  n$ 定义。\n- 一个循环使用整数变量 $k$ 在闭区间 $[l, r]$ 上迭代，因此 $l \\le k \\le r$。\n- 循环前已建立前提条件：$0 \\le l \\le r  n$。\n- 每次迭代执行两次数组访问：一次在索引 $k$，另一次在索引 $r - (k - l)$。\n- 对索引 $\\text{index}$ 的边界检查由条件 $0 \\le \\text{index}  n$ 定义。如果可以证明此条件对所有执行都成立，则可以消除检查。\n- 提供了一条整数区间算术的规则：对于一个仿射函数 $f(k) = \\alpha k + \\beta$，$k \\in [p, q]$，其像为 $[\\alpha p + \\beta, \\alpha q + \\beta]$（如果 $\\alpha \\ge 0$）和 $[\\alpha q + \\beta, \\alpha p + \\beta]$（如果 $\\alpha \\le 0$）。\n\n我们将分别分析每次数组访问，以确定其边界检查是否可以被消除。\n\n**分析第一次访问：$a[k]$**\n\n此次访问的索引就是 $k$。问题陈述循环对 $k \\in [l, r]$ 进行迭代，这意味着 $l \\le k \\le r$。已建立的前提条件是 $0 \\le l \\le r  n$。\n\n我们可以将这两个事实合并成一个不等式链：\n$$\n0 \\le l \\le k \\le r  n\n$$\n从这个不等式链中，我们可以提取出关于 $k$ 的两个具体不等式：\n1. $0 \\le l \\le k \\implies 0 \\le k$\n2. $k \\le r  n \\implies k  n$\n\n将它们合并得到 $0 \\le k  n$。这正是有效数组访问所需的条件。由于这个条件对迭代范围内的每个 $k$ 值都成立，编译器可以证明索引 $k$ 始终在数组 $a$ 的有效边界内。因此，对于循环的每次迭代，访问 $a[k]$ 的边界检查都可以被消除。\n\n**分析第二次访问：$a[r - (k - l)]$**\n\n设这次访问的索引为 $\\text{idx}_2$。\n$$\n\\text{idx}_2(k) = r - (k - l) = r - k + l\n$$\n这可以表示为关于 $k$ 的仿射函数：\n$$\n\\text{idx}_2(k) = (-1)k + (r + l)\n$$\n我们应用所提供的整数区间算术规则。在此背景下，函数是 $f(k) = \\text{idx}_2(k)$，系数 $\\alpha = -1$，常数 $\\beta = r + l$，$k$ 的区间是 $[p, q] = [l, r]$。\n\n由于 $\\alpha = -1 \\le 0$，$\\text{idx}_2(k)$ 的范围由区间 $[\\alpha q + \\beta, \\alpha p + \\beta]$ 给出。我们代入 $\\alpha$、$\\beta$、$p$ 和 $q$ 的具体值：\n- 范围的下界是 $\\alpha q + \\beta = (-1)r + (r + l) = -r + r + l = l$。\n- 范围的上界是 $\\alpha p + \\beta = (-1)l + (r + l) = -l + r + l = r$。\n\n因此，对于所有 $k \\in [l, r]$，索引 $\\text{idx}_2(k)$ 都落在范围 $[l, r]$ 内。这意味着 $l \\le \\text{idx}_2(k) \\le r$。\n\n现在，我们再次使用前提条件 $0 \\le l \\le r  n$。我们可以为 $\\text{idx}_2(k)$ 构建一个新的不等式链：\n$$\n0 \\le l \\le \\text{idx}_2(k) \\le r  n\n$$\n从这个不等式链中，我们推断出：\n1. $0 \\le l \\le \\text{idx}_2(k) \\implies 0 \\le \\text{idx}_2(k)$\n2. $\\text{idx}_2(k) \\le r  n \\implies \\text{idx}_2(k)  n$\n\n将它们合并得到 $0 \\le \\text{idx}_2(k)  n$。这个有效数组访问的条件在整个循环中对 $\\text{idx}_2(k)$ 的所有可能值都成立。因此，编译器也可以消除每次迭代中对 $a[r - (k - l)]$ 访问的边界检查。\n\n**计算消除的边界检查总数**\n\n循环对从 $l$ 到 $r$（含两端）的每个整数值 $k$ 进行迭代。总迭代次数为 $(r - l) + 1$。\n\n在每次迭代中，有两次数组访问。我们已经正式证明了两次访问的边界检查都可以被安全地消除。因此，每次迭代消除了 $2$ 次边界检查。\n\n消除的边界检查总数 $N_{\\text{elim}}$ 是迭代次数与每次迭代消除的检查次数的乘积：\n$$\nN_{\\text{elim}} = (\\text{迭代次数}) \\times (\\text{每次迭代消除的检查次数})\n$$\n$$\nN_{\\text{elim}} = (r - l + 1) \\times 2\n$$\n这就得出了编译器可以消除的边界检查总数的最终闭式表达式。", "answer": "$$\n\\boxed{2(r - l + 1)}\n$$", "id": "3625309"}, {"introduction": "真实世界的程序远不止简单的循环，它们充满了分支和复杂的控制流。本练习将挑战你分析一个 `switch-case` 语句，其中数组索引 `i` 的值取决于程序进入了哪个分支 [@problem_id:3625305]。要做出安全的优化决策，编译器必须保守地合并来自所有可能执行路径的信息，你将通过本练习掌握这一核心的“路径合并”分析技术。", "problem": "一个编译器正试图为一个程序中对长度为 $n$ 的数组 $A$ 的访问消除数组边界检查，该访问的索引 $i$ 由一个基于模式变量 $m$ 的 switch-case 语句设置。所有变量均为整数。一项先前的静态分析可靠地确定了以下各分支的定义和范围，其中所有区间都是闭区间，且所有变量都相互独立：\n- 分支 $0$：$i := 2x + 3$，其中 $x \\in [0,5]$。\n- 分支 $1$：$i := y - 1$，其中 $y \\in [4,20]$。\n- 分支 $2$：$i := r + s$，其中 $r \\in [1,6]$ 且 $s \\in [2,7]$。\n- 分支 $3$：$i := 5u$，其中 $u \\in [1,4]$。\n- 默认分支：$i := v$，其中 $v \\in [10,12]$。\n\n编译器当且仅当能仅根据上述事实可靠地证明，在访问时对于所有可能的执行，$0 \\le i  n$ 都成立，它才会执行边界检查消除。使用集合并集 $\\bigcup$ 的语义来保守地概括所有分支中 $i$ 的所有可能值，计算最小的整数 $n^{\\star}$，使得所有分支下 $i$ 的范围的并集是 $[0,n^{\\star})$ 的子集，从而允许可靠地消除检查。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "用户希望找到一个数组长度的最小整数值，记为 $n^{\\star}$，该值能保证数组访问 $A[i]$ 始终在界内，这是基于对索引变量 $i$ 的静态分析得出的。对于长度为 $n$ 的数组，访问在界内的条件是 $0 \\le i  n$。如果编译器能证明此条件对所有可能的程序执行都成立，它就可以消除边界检查。题目指出，这个证明是通过计算 switch 语句每个分支中 $i$ 的可能值范围，然后取这些范围的并集来构造的。\n\n设 $I$ 为索引 $i$ 可能取到的所有整数值的集合。条件 $0 \\le i  n$ 必须对 $I$ 中的每一个值都成立。这等价于要求集合 $I$ 是整数区间 $[0, n-1]$ 的一个子集。这意味着两个条件：$\\min(I) \\ge 0$ 和 $\\max(I) \\le n-1$。题目要求我们找到满足此条件的最小整数 $n^{\\star}$，因此我们需要找出 $i$ 的总体最小值和最大值。\n\n我们将使用区间算术来确定题目陈述中每个分支下 $i$ 的范围。变量 $x$、$y$、$r$、$s$、$u$ 和 $v$ 都是在它们指定的闭区间内的整数。\n\n1.  **分支 $0$**：$i := 2x + 3$，其中 $x \\in [0, 5]$。\n    函数 $f(x) = 2x + 3$ 是单调递增的。因此，$i$ 的最小值和最大值分别对应于 $x$ 的最小值和最大值。\n    $i$ 的最小值为 $i_{\\min,0} = 2(0) + 3 = 3$。\n    $i$ 的最大值为 $i_{\\max,0} = 2(5) + 3 = 13$。\n    在此分支下，$i$ 的取值范围（我们称之为 $R_0$）是整数区间 $[3, 13]$。\n\n2.  **分支 $1$**：$i := y - 1$，其中 $y \\in [4, 20]$。\n    函数 $f(y) = y - 1$ 是单调递增的。\n    $i$ 的最小值为 $i_{\\min,1} = 4 - 1 = 3$。\n    $i$ 的最大值为 $i_{\\max,1} = 20 - 1 = 19$。\n    $i$ 的取值范围 $R_1$ 是整数区间 $[3, 19]$。\n\n3.  **分支 $2$**：$i := r + s$，其中 $r \\in [1, 6]$ 且 $s \\in [2, 7]$。\n    对于独立变量的和，其最小值是各变量最小值的和，其最大值是各变量最大值的和。\n    $i$ 的最小值为 $i_{\\min,2} = \\min(r) + \\min(s) = 1 + 2 = 3$。\n    $i$ 的最大值为 $i_{\\max,2} = \\max(r) + \\max(s) = 6 + 7 = 13$。\n    $i$ 的取值范围 $R_2$ 是整数区间 $[3, 13]$。\n\n4.  **分支 $3$**：$i := 5u$，其中 $u \\in [1, 4]$。\n    函数 $f(u) = 5u$ 是单调递增的。\n    $i$ 的最小值为 $i_{\\min,3} = 5(1) = 5$。\n    $i$ 的最大值为 $i_{\\max,3} = 5(4) = 20$。\n    $i$ 的取值范围 $R_3$ 是整数区间 $[5, 20]$。\n\n5.  **默认分支**：$i := v$，其中 $v \\in [10, 12]$。\n    $i$ 的值直接由 $v$ 赋值。\n    $i$ 的最小值为 $i_{\\min,def} = 10$。\n    $i$ 的最大值为 $i_{\\max,def} = 12$。\n    $i$ 的取值范围 $R_{def}$ 是整数区间 $[10, 12]$。\n\n现在，我们必须通过取所有可能分支的范围的并集来确定 $i$ 的总体范围。设 $R_{total}$ 为该并集。\n$R_{total} = R_0 \\cup R_1 \\cup R_2 \\cup R_3 \\cup R_{def}$\n$R_{total} = [3, 13] \\cup [3, 19] \\cup [3, 13] \\cup [5, 20] \\cup [10, 12]$\n这些区间的并集形成一个单一的连续区间。为了找到这个区间，我们取所有下界的最小值和所有上界的最大值。\n$i$ 的总体最小值为 $\\min(i) = \\min(3, 3, 3, 5, 10) = 3$。\n$i$ 的总体最大值为 $\\max(i) = \\max(13, 19, 13, 20, 12) = 20$。\n因此，静态分析可靠地确定了在数组访问点，$i$ 的值必须位于整数区间 $[3, 20]$ 内。设 $I$ 为 $i$ 所有可能的整数值的集合，那么 $I \\subseteq \\{3, 4, \\dots, 20\\}$。\n\n对于长度为 $n$ 的数组，如果编译器能证明 $0 \\le i  n$，则可以消除边界检查。我们正在寻找可以作为这个 $n$ 的最小整数 $n^{\\star}$。这个条件必须对 $i$ 的所有可能值都成立。\n这意味着 $i$ 的可能值区间 $[3, 20]$ 必须是有效索引区间 $[0, n^{\\star}-1]$ 的一个子集。\n这给了我们两个条件：\n1.  $\\min(i) \\ge 0$：由于 $i$ 的最小可能值为 $3$，条件 $3 \\ge 0$ 得到满足。下界检查可以被消除。\n2.  $\\max(i)  n^{\\star}$：$i$ 的最大可能值为 $20$。因此，我们必须有 $20  n^{\\star}$。\n\n我们需要找到满足不等式 $20  n^{\\star}$ 的最小整数 $n^{\\star}$。大于 $20$ 的最小整数是 $21$。\n因此，通过选择 $n^{\\star} = 21$，数组长度为 $21$，有效索引为 $0, 1, \\dots, 20$。由于分析证明了 $3 \\le i \\le 20$，条件 $0 \\le i  21$ 始终为真，边界检查可以被安全地消除。任何小于 $21$ 的 $n$ 值都是不够的，因为索引 $i=20$ 是一个可能的值。例如，如果 $n=20$，访问 $A[20]$ 将会越界。\n\n因此，最小整数 $n^{\\star}$ 是 $21$。", "answer": "$$\\boxed{21}$$", "id": "3625305"}]}