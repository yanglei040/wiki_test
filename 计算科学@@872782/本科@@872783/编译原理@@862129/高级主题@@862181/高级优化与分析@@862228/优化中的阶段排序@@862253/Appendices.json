{"hands_on_practices": [{"introduction": "编译器优化并非各自为战，一个优化的执行可以为另一个优化创造条件。本练习将通过一个具体的例子来展示这种“协同效应”：一个规范化（Canonicalization）过程如何通过统一表达式的结构，从而使得后续的模式匹配（Pattern Matching）优化能够识别并转换更多的代码。通过亲手计算两种不同顺序下的优化效果，你将深刻体会到“先清理、后优化”策略的价值。[@problem_id:3662645]", "problem": "考虑一个优化编译器，它在一个简单的表达式语言上对抽象语法树（AST）进行操作。该语言有三种类型的节点：变量、整数常量以及二元运算符 $\\mathrm{Add}$ 和 $\\mathrm{Mul}$。一个名为 $O_{\\mathrm{Canonicalize}}$ 的编译器遍（pass）通过应用遵循语义的等式公理来为表达式生成一种规范形式。一个名为 $O_{\\mathrm{PatternMatch}}$ 的编译器遍应用由模式 $P$ 驱动的单个窥孔重写。\n\n基础和核心定义：\n- 表达式是基于签名 $\\{\\mathrm{Add}, \\mathrm{Mul}\\}$ 的树，其叶节点来自变量和整数常量。\n- 遍 $O_{\\mathrm{Canonicalize}}$ 在每个节点上（以后序遍历）应用以下汇合的、保持语义的规则直至饱和，从而定义了一个规范化函数 $C$：\n  1. 交换律归一化：对于 $\\mathrm{Add}(u,v)$ 和 $\\mathrm{Mul}(u,v)$，递归地将 $u$ 规范化为 $u'$，将 $v$ 规范化为 $v'$，然后对数对 $(u',v')$ 进行排序，使得对于下面定义的固定全序关系 $\\preceq$，有 $u' \\preceq v'$。\n  2. 中性元消除：$\\mathrm{Add}(u,0) \\to u$，$\\mathrm{Add}(0,u) \\to u$，$\\mathrm{Mul}(u,1) \\to u$，$\\mathrm{Mul}(1,u) \\to u$，以及 $\\mathrm{Mul}(u,0) \\to 0$，$\\mathrm{Mul}(0,u) \\to 0$。\n  3. 对具有两个常量子节点的二元节点进行常量折叠：当 $m$ 和 $n$ 是整数常量时，$\\mathrm{Add}(m,n) \\to m+n$ 和 $\\mathrm{Mul}(m,n) \\to m \\cdot n$。\n- 规范化表达式上的全序关系 $\\preceq$ 定义如下：常量按数值排序；变量按名称的字典序排序；复合节点按三元组 $(\\mathrm{op}, u', v')$ 的字典序排序，其中 $\\mathrm{op} \\in \\{\\mathrm{Add}, \\mathrm{Mul}\\}$ 按名称字符串排序，而 $u',v'$ 是递归比较的规范化子节点。这在交换律下确定了一个确定性的操作数顺序。\n- 遍 $O_{\\mathrm{PatternMatch}}$ 仅在每个顶层表达式的根部尝试匹配单个模式 $P \\colon \\mathrm{Add}(E,E)$，其中 $E$ 表示任意子树。当模式匹配时，一次重写将符合条件（例如，重写为 $\\mathrm{Mul}(2,E)$），但对于本问题，只有成功匹配的次数是重要的。\n- 对于给定的程序表达式序列，将 $m(P)$ 定义为在 $O_{\\mathrm{PatternMatch}}$ 的单次遍中匹配模式 $P$ 的顶层根的数量。\n\n考虑两种阶段顺序：\n- 顺序 $\\mathcal{A}$：首先将 $O_{\\mathrm{Canonicalize}}$ 应用于每个顶层表达式，然后在所得集合中的每个顶层表达式的根部应用一次 $O_{\\mathrm{PatternMatch}}$；令所得计数为 $m_{\\mathcal{A}}(P)$。\n- 顺序 $\\mathcal{B}$：首先在每个原始顶层表达式的根部应用一次 $O_{\\mathrm{PatternMatch}}$，然后应用 $O_{\\mathrm{Canonicalize}}$；令所得计数为 $m_{\\mathcal{B}}(P)$。\n\n考虑以下12个顶层中间表示（IR）表达式的列表（每个都以前缀形式表示为 $\\mathrm{Add}(\\cdot,\\cdot)$ 或 $\\mathrm{Mul}(\\cdot,\\cdot)$），其中 $a,b,c,d,f,g,h,i,j,k,m,p$ 是不同的变量，而 $0,1,2,3$ 是整数常量：\n- $E_{1} = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$。\n- $E_{2} = \\mathrm{Add}(\\mathrm{Add}(a,0),a)$。\n- $E_{3} = \\mathrm{Add}(\\mathrm{Mul}(c,1),c)$。\n- $E_{4} = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(b,a))$。\n- $E_{5} = \\mathrm{Add}(\\mathrm{Mul}(2,d),\\mathrm{Add}(d,d))$。\n- $E_{6} = \\mathrm{Add}(\\mathrm{Mul}(0,p),p)$。\n- $E_{7} = \\mathrm{Add}(\\mathrm{Mul}(f,1),\\mathrm{Mul}(1,f))$。\n- $E_{8} = \\mathrm{Add}(\\mathrm{Add}(g,1),\\mathrm{Add}(1,g))$。\n- $E_{9} = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(h,3))$。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$。\n\n计算该程序如上定义的数对 $\\big(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P)\\big)$，并将最终结果以行矩阵形式呈现。无需四舍五入。答案中不要包含任何单位。", "solution": "该问题要求计算一对值 $(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P))$，它们表示在两种不同的编译器阶段顺序 $\\mathcal{A}$ 和 $\\mathcal{B}$ 下，模式 $P \\colon \\mathrm{Add}(E,E)$ 的成功匹配次数。如果一个顶层表达式的形式为 $\\mathrm{Add}(E,E)$，即两个相同的子树相加，则模式 $P$ 匹配该表达式。\n\n两种阶段顺序是：\n- 顺序 $\\mathcal{A}$：将规范化遍 $O_{\\mathrm{Canonicalize}}$ 应用于所有表达式，然后应用模式匹配遍 $O_{\\mathrm{PatternMatch}}$。匹配次数为 $m_{\\mathcal{A}}(P)$。\n- 顺序 $\\mathcal{B}$：将模式匹配遍 $O_{\\mathrm{PatternMatch}}$ 应用于所有原始表达式，然后应用规范化遍 $O_{\\mathrm{Canonicalize}}$。匹配次数为 $m_{\\mathcal{B}}(P)$。\n\n令 $C(e)$ 表示表达式 $e$ 应用遍 $O_{\\mathrm{Canonicalize}}$ 后的规范形式。规范化规则包括：基于全序关系 $\\preceq$ 的排序交换律、中性元消除和常量折叠。排序顺序 $\\preceq$ 定义为常量（按值）$\\prec$ 变量（按字典序）$\\prec$ 复合节点。复合节点按操作符名称（即 $\\mathrm{Add} \\prec \\mathrm{Mul}$）的字典序排序，然后按其子节点递归排序。\n\n首先，我们计算顺序 $\\mathcal{B}$ 的 $m_{\\mathcal{B}}(P)$。\n在此顺序中，模式匹配遍 $O_{\\mathrm{PatternMatch}}$ 首先应用于原始的12个表达式列表。计数 $m_{\\mathcal{B}}(P)$ 是在任何转换之前，语法上匹配 $\\mathrm{Add}(E,E)$ 的表达式数量。\n\n我们检查每个表达式 $E_i$（其中 $i \\in \\{1, \\dots, 12\\}$）：\n- $E_1, \\dots, E_9$：根节点 $\\mathrm{Add}$ 的两个子节点在语法上不相同。例如，在 $E_1 = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$ 中，子节点 $\\mathrm{Mul}(a,b)$ 和 $\\mathrm{Mul}(b,a)$ 是不同的抽象语法树。这些不匹配。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$：左子节点 $\\mathrm{Add}(i,j)$ 与右子节点 $\\mathrm{Add}(i,j)$ 在语法上相同。这是一个匹配。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$：子节点 $\\mathrm{Add}(k,0)$ 和 $\\mathrm{Add}(0,k)$ 在语法上不相同。不匹配。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$：子节点在语法上不相同。不匹配。\n\n只有一个表达式 $E_{10}$ 在其原始形式下匹配模式 $P$。因此，顺序 $\\mathcal{B}$ 的计数为 $m_{\\mathcal{B}}(P) = 1$。\n\n其次，我们计算顺序 $\\mathcal{A}$ 的 $m_{\\mathcal{A}}(P)$。\n在此顺序中，我们首先将规范化遍 $O_{\\mathrm{Canonicalize}}$ 应用于每个表达式 $E_i$ 以获得其规范形式 $C(E_i)$。然后，我们检查 $C(E_i)$ 是否匹配模式 $\\mathrm{Add}(E,E)$。\n\n我们分析每个表达式的规范形式：\n- $E_1 = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(b,a))$：$C(\\mathrm{Mul}(a,b)) = \\mathrm{Mul}(a,b)$（假设 $a \\preceq b$）。$C(\\mathrm{Mul}(b,a))$ 在排序后也变为 $\\mathrm{Mul}(a,b)$。因此，$C(E_1) = \\mathrm{Add}(\\mathrm{Mul}(a,b),\\mathrm{Mul}(a,b))$。这匹配 $P$。\n- $E_2 = \\mathrm{Add}(\\mathrm{Add}(a,0),a)$：通过中性元消除，$C(\\mathrm{Add}(a,0)) = a$。因此，$C(E_2) = \\mathrm{Add}(a,a)$。这匹配 $P$。\n- $E_3 = \\mathrm{Add}(\\mathrm{Mul}(c,1),c)$：通过中性元消除，$C(\\mathrm{Mul}(c,1)) = c$。因此，$C(E_3) = \\mathrm{Add}(c,c)$。这匹配 $P$。\n- $E_4 = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(b,a))$：$C(\\mathrm{Add}(a,b)) = \\mathrm{Add}(a,b)$（假设 $a \\preceq b$）。$C(\\mathrm{Add}(b,a))$ 在排序后变为 $\\mathrm{Add}(a,b)$。因此，$C(E_4) = \\mathrm{Add}(\\mathrm{Add}(a,b),\\mathrm{Add}(a,b))$。这匹配 $P$。\n- $E_5 = \\mathrm{Add}(\\mathrm{Mul}(2,d),\\mathrm{Add}(d,d))$：规范化的子节点为 $C(\\mathrm{Mul}(2,d)) = \\mathrm{Mul}(2,d)$ 和 $C(\\mathrm{Add}(d,d)) = \\mathrm{Add}(d,d)$。根据 $\\preceq$，$\\mathrm{Add} \\prec \\mathrm{Mul}$，因此 $\\mathrm{Add}(d,d) \\preceq \\mathrm{Mul}(2,d)$。对子节点排序得到 $C(E_5) = \\mathrm{Add}(\\mathrm{Add}(d,d), \\mathrm{Mul}(2,d))$。子节点不相同。不匹配。\n- $E_6 = \\mathrm{Add}(\\mathrm{Mul}(0,p),p)$：根据吸收元规则，$C(\\mathrm{Mul}(0,p)) = 0$。表达式变为 $\\mathrm{Add}(0,p)$，规范化为 $p$。最终形式不是一个 $\\mathrm{Add}$ 节点。不匹配。\n- $E_7 = \\mathrm{Add}(\\mathrm{Mul}(f,1),\\mathrm{Mul}(1,f))$：$C(\\mathrm{Mul}(f,1)) = f$ 且 $C(\\mathrm{Mul}(1,f)) = f$。因此，$C(E_7) = \\mathrm{Add}(f,f)$。这匹配 $P$。\n- $E_8 = \\mathrm{Add}(\\mathrm{Add(g,1}),\\mathrm{Add}(1,g))$：$1 \\preceq g$，所以 $C(\\mathrm{Add}(g,1)) = \\mathrm{Add}(1,g)$。$C(\\mathrm{Add}(1,g))$ 已经是规范形式。因此，$C(E_8) = \\mathrm{Add}(\\mathrm{Add}(1,g),\\mathrm{Add}(1,g))$。这匹配 $P$。\n- $E_9 = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(h,3))$：$3 \\preceq h$，所以 $C(\\mathrm{Mul}(h,3)) = \\mathrm{Mul}(3,h)$。$C(\\mathrm{Mul}(3,h))$ 已经是规范形式。因此，$C(E_9) = \\mathrm{Add}(\\mathrm{Mul}(3,h),\\mathrm{Mul}(3,h))$。这匹配 $P$。\n- $E_{10} = \\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$：假设 $i \\preceq j$，$C(\\mathrm{Add}(i,j)) = \\mathrm{Add}(i,j)$。子节点相同且已经是规范形式。其形式保持为 $\\mathrm{Add}(\\mathrm{Add}(i,j),\\mathrm{Add}(i,j))$。这匹配 $P$。\n- $E_{11} = \\mathrm{Add}(\\mathrm{Add}(k,0),\\mathrm{Add}(0,k))$：$C(\\mathrm{Add}(k,0)) = k$ 且 $C(\\mathrm{Add}(0,k)) = k$。因此，$C(E_{11}) = \\mathrm{Add}(k,k)$。这匹配 $P$。\n- $E_{12} = \\mathrm{Add}(\\mathrm{Mul}(1,\\mathrm{Add}(m,0)),\\mathrm{Add}(0,\\mathrm{Add}(1,m)))$： \n  - 左子节点：$C(\\mathrm{Mul}(1, \\mathrm{Add}(m,0))) = C(\\mathrm{Mul}(1, C(\\mathrm{Add}(m,0)))) = C(\\mathrm{Mul}(1,m)) = m$。\n  - 右子节点：$C(\\mathrm{Add}(0, \\mathrm{Add}(1,m))) = C(\\mathrm{Add}(0, C(\\mathrm{Add}(1,m)))) = C(\\mathrm{Add}(0, \\mathrm{Add}(1,m))) = \\mathrm{Add}(1,m)$。\n  - 表达式变为 $\\mathrm{Add}(m, \\mathrm{Add}(1,m))$。我们对子节点进行排序。由于变量 $\\prec$ 复合节点，所以 $m \\preceq \\mathrm{Add}(1,m)$。子节点已经排序。最终形式为 $C(E_{12}) = \\mathrm{Add}(m, \\mathrm{Add}(1,m))$。子节点不相同。不匹配。\n\n规范化后匹配模式 $P$ 的表达式是 $E_1, E_2, E_3, E_4, E_7, E_8, E_9, E_{10}, E_{11}$。共有9个这样的表达式。\n因此，顺序 $\\mathcal{A}$ 的计数为 $m_{\\mathcal{A}}(P) = 9$。\n\n结果数对为 $(m_{\\mathcal{A}}(P), m_{\\mathcal{B}}(P)) = (9, 1)$。", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n9  1\n\\end{pmatrix}\n}\n$$", "id": "3662645"}, {"introduction": "优化的顺序直接影响到程序的最终性能。这个练习聚焦于编译器后端，探讨了死代码消除（Dead Code Elimination）和指令调度（Instruction Scheduling）之间的相互作用。你将分析一段包含“活”代码链和“死”代码链的代码序列，并计算在不同优化顺序下关键路径的长度，从而直观地看到先移除无关计算对于后续性能调度是多么重要。[@problem_id:3662593]", "problem": "考虑编译器中死代码消除 (DCE) 和指令调度之间的阶段排序。在无副作用和非易失性内存的假设下，死代码消除 (DCE) 会移除对任何外部可观察的程序状态没有贡献的计算。指令调度 (IS) 在满足数据依赖关系的前提下对指令进行排序，但不会改变延迟或依赖关系。将一个基本块的依赖结构建模为一个有向无环图 (DAG)，其节点是指令，其边表示真正的数据依赖。程序块 $P$ 的关键路径长度 $\\chi(P)$ 定义为 DAG 中所有从源到汇的路径上指令延迟总和的最大值。\n\n设 $P$ 为以下单一基本块（静态单赋值 (SSA) 形式），由两个独立的链组成。所有操作都是纯粹的，内存读取是非易失性的、在边界内的，并且不会触发陷阱。只有变量 $y$ 在块出口处是活跃的；所有其他临时变量都是死的（在块之后从未被使用）：\n\n活跃链：\n- $I_{1}: r_{a} \\leftarrow \\mathrm{ld}(a)$，延迟为 $5$，\n- $I_{2}: r_{b} \\leftarrow \\mathrm{ld}(b)$，延迟为 $5$，\n- $I_{3}: s_{1} \\leftarrow r_{a} + r_{b}$，延迟为 $1$，\n- $I_{4}: m_{1} \\leftarrow s_{1} \\times c$，延迟为 $3$，\n- $I_{5}: y \\leftarrow m_{1} + d$，延迟为 $1$ (活跃)。\n\n死链：\n- $I_{6}: r_{e} \\leftarrow \\mathrm{ld}(e)$，延迟为 $5$，\n- $I_{7}: t_{1} \\leftarrow r_{e} \\times f$，延迟为 $3$，\n- $I_{8}: t_{2} \\leftarrow t_{1} / g$，延迟为 $10$，\n- $I_{9}: t_{3} \\leftarrow t_{2} + h$，延迟为 $1$，\n- $I_{10}: t \\leftarrow t_{3} - k$，延迟为 $1$ (死代码；$t$ 未被使用)。\n\n假设调度器在当前存在的指令上构建其 DAG，并且机器有足够的资源，使得调度长度的下限为 $\\chi(P)$ 且不能短于 $\\chi(P)$。考虑两种阶段顺序：\n- $O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}$：首先对原始块执行指令调度，然后运行DCE。\n- $O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}$：首先对原始块运行DCE，然后执行指令调度。\n\n计算减少量 $R$，定义为\n$$\nR \\equiv \\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) - \\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P),\n$$\n并以周期为单位，将你的最终答案表示为一个精确的整数（无四舍五入）。", "solution": "我们从核心定义开始。该块的指令级依赖结构是一个有向无环图 (DAG)，其中每条指令是一个以其延迟为权重的节点，边代表真正的数据依赖。关键路径长度 $\\chi(P)$ 是DAG中所有从源到汇的路径上节点延迟总和的最大值。指令调度 (IS) 遵循依赖关系和延迟；在资源充足的情况下，调度长度不能短于DAG的关键路径。死代码消除 (DCE) 移除那些结果对任何活跃输出没有贡献且没有副作用的节点，从而可能缩短DAG及其关键路径。\n\n我们分析这两个独立的链。\n\n活跃链：\n- $I_{1}$ (延迟5) 和 $I_{2}$ (延迟5) 都为 $I_{3}$ (延迟1) 提供输入。由于 $I_{3}$ 依赖于 $r_{a}$ 和 $r_{b}$，到达 $I_{3}$ 的时间是其前驱节点到达时间的最大值。$I_{1}$ 和 $I_{2}$ 都是源头，因此它们的值准备好的最早时间各为 $5$。因此，$s_{1}$ 在 $I_{3}$ 处准备好的最早时间是 $5 + 1 = 6$。\n- $I_{4}$ (延迟3) 依赖于 $I_{3}$，因此其在最長路径上的完成时间是 $6 + 3 = 9$。\n- $I_{5}$ (延迟1) 依赖于 $I_{4}$，因此其在最長路径上的完成时间是 $9 + 1 = 10$。\n\n因此，活跃链的关键路径长度是\n$$\n\\chi_{\\text{live}} = 10.\n$$\n\n死链：\n这个链是线性的，所以我们将其延迟相加：\n- $I_{6}$ (延迟5) $\\rightarrow$ $I_{7}$ (延迟3)：$5 + 3 = 8$，\n- $\\rightarrow I_{8}$ (延迟10)：$8 + 10 = 18$，\n- $\\rightarrow I_{9}$ (延迟1)：$18 + 1 = 19$，\n- $\\rightarrow I_{10}$ (延迟1)：$19 + 1 = 20$。\n\n因此，\n$$\n\\chi_{\\text{dead}} = 20.\n$$\n\n由于两条链是独立的，整个DAG的关键路径 $\\chi(P)$ 是调度时图中存在的两条链的关键路径的最大值。\n\n对于阶段顺序 $O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}$，调度首先在包含两条链的原始块上运行。因此，调度器的DAG包含了死链。调度时的关键路径是\n$$\n\\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) = \\max\\left(\\chi_{\\text{live}}, \\chi_{\\text{dead}}\\right) = \\max(10, 20) = 20.\n$$\n\n对于阶段顺序 $O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}$，首先运行死代码消除。死链中的所有操作都是纯粹的，且链的结果 $t$ 未被使用，内存读取是非易失性且不会触发陷阱的，因此DCE会移除 $I_{6}$ 到 $I_{10}$。然后，调度器在只包含活跃链的简化块上操作。调度时的关键路径变为\n$$\n\\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P) = \\chi_{\\text{live}} = 10.\n$$\n\n根据定义，减少量 $R$ 是\n$$\nR \\equiv \\chi_{O_{\\mathrm{Sched}\\rightarrow \\mathrm{DCE}}}(P) - \\chi_{O_{\\mathrm{DCE}\\rightarrow \\mathrm{Sched}}}(P) = 20 - 10 = 10.\n$$\n\n因此，在指令调度之前执行死代码消除，可以将调度器可用的关键路径长度减少 $10$ 个周期。", "answer": "$$\\boxed{10}$$", "id": "3662593"}, {"introduction": "并非所有的优化组合都能产生正面效果；有时，一个看似有益的优化会破坏另一个关键优化的前提条件，这体现了阶段排序问题中的“冲突”现象。本练习为你构建了一个经典的冲突场景，涉及函数内联（Inlining）与尾调用优化（Tail-Call Optimization）。通过分析一个递归函数，你将看到不当的优化顺序（先内联）会如何改变代码的句法结构，从而阻止编译器识别出尾递归模式，最终导致程序运行时栈空间消耗的巨大差异。[@problem_id:3662669]", "problem": "考虑以下一个程序的简化中间表示，该程序所用语言具有可调用函数和返回功能。最大栈深度定义为程序 $P$ 在执行期间同时存在的活动记录（activation record）的最大数量，记为 $d(P)$。如果函数直接返回调用表达式的值而无需任何进一步计算，则该调用处于尾部位置（tail position）。尾调用优化（Tail-Call Optimization, TCO）是一种将尾递归函数重写为循环的优化，从而将栈深度限制在一个常数。内联展开（Inline Expansion, Inlining）是一种在调用点用小函数的主体替换其调用的优化。\n\n您将分析尾调用优化和内联展开之间的阶段排序（phase-ordering）交互作用。程序 $P_{n}$ 由一个整数 $n \\geq 1$ 参数化，并由两个函数组成：\n- 一个返回其参数的恒等辅助函数 $I(x)$。\n- 一个尾递归函数 $F(i,a)$，它迭代 $i$ 次，并递增一个累加器 $a$：\n$$\nI(x) \\triangleq x\n$$\n$$\nF(i,a) \\triangleq\n\\begin{cases}\na,  \\text{if } i = 0 \\\\\nI\\big(F(i-1,a+1)\\big),  \\text{if } i  0\n\\end{cases}\n$$\n入口点是 $F(n,0)$。\n\n编译器有两个优化遍（pass）：\n- $O_{\\mathrm{TailCallOpt}}$ （尾调用优化，TCO）：当且仅当函数 $G$ 在尾部位置返回一个形如 $G(\\ldots)$ 的直接调用表达式时，此遍会重写该函数。也就是说，其语法形式必须是确切的 $\\,\\texttt{return}\\;G(\\ldots)\\,$，没有中间的临时变量赋值，也没有返回后的收尾代码（epilogue）。当应用于 $F$ 中的自调用时，此遍将递归转换为循环，从而对所有 $n$ 都产生常数 $1$ 的栈深度。\n- $O_{\\mathrm{Inline}}$ （内联展开）：此遍在 $I$ 的调用点将其内联。将 $I$ 内联到 $F$ 中会将形如 $\\,\\texttt{return}\\;I(F(\\ldots))\\,$ 的尾返回转换为一个两步序列：将递归调用赋值给一个临时变量，然后返回该临时变量，即 $\\,\\texttt{tmp} \\leftarrow F(\\ldots);\\;\\texttt{return}\\;\\texttt{tmp}\\,$。根据规定的 $O_{\\mathrm{TailCallOpt}}$ 规则，这种形式在语法上不被识别为尾调用，因此之后不会执行尾调用重写。\n\n假设采用传统的调用栈语义，在没有尾调用优化的情况下，每次递归调用会增加一个活动记录，因此在没有尾调用优化的情况下，求值 $F(n,0)$ 在最深点会产生 $n+1$ 的栈深度（计算初始帧）。\n\n设 $d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})$ 表示先运行 $O_{\\mathrm{Inline}}$ 再运行 $O_{\\mathrm{TailCallOpt}}$ 时的最大栈深度，设 $d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})$ 表示先运行 $O_{\\mathrm{TailCallOpt}}$ 再运行 $O_{\\mathrm{Inline}}$ 时的最大栈深度。\n\n对于特定输入 $n = 1024$，计算比率\n$$\nR \\triangleq \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})}.\n$$\n提供 $R$ 的最终数值。无需四舍五入。以纯数字形式表示答案，不带单位。", "solution": "该问题的目标是计算比率 $R = \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n})}$，其中 $n=1024$。这需要我们分别计算在两种不同优化序列下的最大栈深度。\n\n**1. 分析 $O_{\\mathrm{Inline}} \\rightarrow O_{\\mathrm{TailCallOpt}}$ 阶段顺序**\n\n首先，我们分析先进行内联，再进行尾调用优化的情况。\n\n- **应用 $O_{\\mathrm{Inline}}$：** 编译器处理原始程序 $P_n$。函数 $F$ 的递归情况是 `return I(F(i-1, a+1))`。根据问题描述，$O_{\\mathrm{Inline}}$ 遍会将这个调用转换为一个使用临时变量的两步序列。\n  原始代码 `return I(F(i-1, a+1))` 被转换为 `tmp - F(i-1, a+1); return tmp`。\n  此遍之后，函数 $F$ 的递归调用不再处于尾部位置的直接返回形式。\n\n- **应用 $O_{\\mathrm{TailCallOpt}}$：** 接着，TCO遍分析被修改后的函数。$O_{\\mathrm{TailCallOpt}}$ 的规则要求函数以 `return G(...)` 的语法形式直接返回自递归调用。由于内联已经将代码改写为 `tmp - F(...); return tmp`，这个句法模式不再匹配。因此，TCO优化无法应用。\n\n- **最终栈深度：** 由于TCO没有被执行，程序以标准的递归方式执行。问题中已明确，在没有TCO的情况下，执行 $F(n,0)$ 会产生 $n+1$ 的最大栈深度。\n  因此，对于此阶段顺序，最大栈深度为：\n  $$d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{n}) = n+1$$\n\n**2. 分析 $O_{\\mathrm{TCO}} \\rightarrow O_{\\mathrm{Inline}}$ 阶段顺序**\n\n接下来，我们分析先进行尾调用优化，再进行内联的情况。\n\n- **应用 $O_{\\mathrm{TailCallOpt}}$：** 编译器首先处理原始程序 $P_n$。$F$ 中的递归步骤是 `return I(F(i-1, a+1))`。虽然这看起来是调用 `I`，但实际上这是一个对自身的尾递归调用，只是用一个恒等函数包装了一下。一个合理的尾调用优化器能够识别这种情况（或者问题明确指出TCO适用于“$F$中的自调用”）。\n  因此，TCO遍将 $F$ 识别为尾递归函数，并将其重写为一个迭代循环。优化后的函数不再包含递归调用。问题指出，这会产生一个常数（即 $1$）的栈深度。\n\n- **应用 $O_{\\mathrm{Inline}}$：** 第二遍是内联。然而，在TCO遍之后，原始的 `return I(F(...))` 递归调用已经被整个替换为一个循环结构。在新生成的代码中，不再有对函数 `I` 的调用。因此，$O_{\\mathrm{Inline}}$ 遍没有任何操作可执行。\n\n- **最终栈深度：** 最终程序是 $F$ 的迭代版本。执行此函数只需要一个栈帧。因此，最大栈深度为常数 $1$。\n  $$d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{n}) = 1$$\n\n**3. 最终计算**\n\n我们现在计算 $n = 1024$ 时的比率 $R$。\n\n- 分子：$d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{1024}) = n+1 = 1024+1 = 1025$。\n- 分母：$d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{1024}) = 1$。\n\n比率为：\n$$R = \\frac{d_{\\mathrm{Inline}\\rightarrow\\mathrm{TCO}}(P_{1024})}{d_{\\mathrm{TCO}\\rightarrow\\mathrm{Inline}}(P_{1024})} = \\frac{1025}{1} = 1025$$\n这个结果清晰地展示了优化顺序的重要性。`TCO -> Inline` 的顺序在栈空间使用上远比 `Inline -> TCO` 的顺序高效。", "answer": "$$\\boxed{1025}$$", "id": "3662669"}]}