{"hands_on_practices": [{"introduction": "静态单赋值（SSA）形式的核心在于 $\\phi$ 函数的正确放置。本练习将引导你完成最基础也是最关键的步骤：为一个给定的控制流图（CFG）计算支配边界（Dominance Frontiers），并运用标准的迭代算法来确定变量 $v$ 的 $\\phi$ 函数应放置在哪些基本块中 [@problem_id:3671703]。通过这个实践，你将掌握 SSA 构建背后严谨的机械化流程。", "problem": "考虑以下一个过程的控制流图（CFG），其基本块标记为 $B_1$ 到 $B_8$。入口点是 $B_1$，出口点是 $B_8$。该CFG的有向边如下：\n- $B_1 \\to B_2$, $B_1 \\to B_3$\n- $B_2 \\to B_4$\n- $B_3 \\to B_4$\n- $B_4 \\to B_5$, $B_4 \\to B_6$\n- $B_5 \\to B_7$\n- $B_6 \\to B_7$\n- $B_7 \\to B_4$, $B_7 \\to B_8$\n\n假设该过程包含一个单一变量 $v$，其赋值操作仅存在于基本块 $B_1$ 和 $B_2$ 中。你的任务是：\n1. 根据编译原理中支配关系（dominator relation）和支配边界（dominance frontier）的标准定义，计算每个节点 $n \\in \\{B_1,B_2,B_3,B_4,B_5,B_6,B_7,B_8\\}$ 的支配边界 $DF(n)$。\n2. 使用 Cytron 等人提出的用于静态单赋值形式（SSA）的迭代支配边界方法，从定义点集合 $\\{B_1,B_2\\}$ 开始，通过迭代直到收敛，确定所有必须为变量 $v$ 放置 $\\phi$ 函数的基本块。\n3. 作为最终答案，给出在此CFG中为变量 $v$ 插入的独立 $\\phi$ 函数的总数。将你的最终答案表示为单个整数，无需四舍五入。", "solution": "用户希望我解决一个关于编译理论中静态单赋值（SSA）形式的问题。\n\n我的计划如下：\n1.  **验证问题陈述：**\n    *   **提取已知信息：** 列出CFG结构（节点和边）、入口/出口块、变量 `$v$` 及其定义位置。\n    *   **检查有效性：**\n        *   **科学依据：** 该问题涉及编译理论，特别是SSA形式、支配和支配边界。这些是计算机科学中成熟的概念。CFG是一种标准表示法。该问题在科学上是合理的。\n        *   **适定性：** 该问题要求基于一个明确定义的算法（迭代支配边界）进行特定计算（支配边界、$\\phi$函数放置）。存在唯一解。\n        *   **客观性：** 语言精确且技术性强。没有主观因素。\n        *   **完整性：** CFG被完全描述。变量及其定义位置已给出。要使用的算法已指定。该问题是自包含的。\n        *   **一致性：** CFG结构是一致的。没有矛盾。\n        *   **现实性：** 该CFG是教科书中典型的例子。对于一个小过程来说，这是一个现实的表示。\n        *   **无其他缺陷：** 它不是比喻性的、微不足道的或无法验证的。\n\n    *   **结论：** 问题有效。我将继续解决。\n\n2.  **解决问题：**\n\n    *   **第1部分：计算支配边界**\n        1.  **计算支配节点：** 首先，我需要确定每个节点的支配节点集。\n            *   如果从入口节点（`$B_1$`）到节点 `$n$` 的每条路径都经过节点 `$d$`，则节点 `$d$` 支配节点 `$n$`。\n            *   我们来分析这个图：\n                *   入口: $B_1$\n                *   边:\n                    *   $B_1 \\to B_2$, $B_1 \\to B_3$\n                    *   $B_2 \\to B_4$\n                    *   $B_3 \\to B_4$\n                    *   $B_4 \\to B_5$, $B_4 \\to B_6$\n                    *   $B_5 \\to B_7$\n                    *   $B_6 \\to B_7$\n                    *   $B_7 \\to B_4$, $B_7 \\to B_8$\n                *   出口: $B_8$\n\n            *   我们来找出每个节点 `$n$` 的支配节点集 `$\\text{Dom}(n)$`：\n                *   `$\\text{Dom}(B_1)$`: $\\{B_1\\}$ （根据定义）\n                *   `$\\text{Dom}(B_2)$`: 到 $B_2$ 的路径：$B_1 \\to B_2$。所以是 $\\{B_1, B_2\\}$。\n                *   `$\\text{Dom}(B_3)$`: 到 $B_3$ 的路径：$B_1 \\to B_3$。所以是 $\\{B_1, B_3\\}$。\n                *   `$\\text{Dom}(B_4)$`: 到 $B_4$ 的路径：$(B_1, B_2, B_4)$，$(B_1, B_3, B_4)$。唯一的公共节点是 $B_1$。等等，有一个循环 $B_4 \\leftrightarrow B_7$。让我们更仔细地追踪路径。\n                    *   任何到 $B_4$ 的路径都必须从 $B_1$ 开始。经过 $B_1$ 后，可以到 $B_2$ 或 $B_3$。两条路径都通向 $B_4$。所以，$B_1$ 支配 $B_4$。\n                    *   此外，还有一个循环 $B_4 \\to B_5 \\to B_7 \\to B_4$ 和 $B_4 \\to B_6 \\to B_7 \\to B_4$。一旦我们进入循环 $\\{B_4, B_5, B_6, B_7\\}$，任何从入口到该循环中任一节点的路径都*必须*经过 $B_4$。\n                    *   所以，$B_4$ 是这个循环的头节点。\n                    *   到 $B_4$ 的路径：$(B_1, B_2, B_4)$，$(B_1, B_3, B_4)$。唯一的公共节点是 $B_1$。当然，$B_4$ 也支配它自己。所以 `$\\text{Dom}(B_4)$`: $\\{B_1, B_4\\}$。\n                *   `$\\text{Dom}(B_5)$`: 到 $B_5$ 的路径：必须经过 $B_4$。例如路径：$B_1 \\to B_2 \\to B_4 \\to B_5$。每条到 $B_5$ 的路径都必须经过 $B_1$ 和 $B_4$。所以 `$\\text{Dom}(B_5)$`: $\\{B_1, B_4, B_5\\}$。\n                *   `$\\text{Dom}(B_6)$`: 到 $B_6$ 的路径：必须经过 $B_4$。例如路径：$B_1 \\to B_2 \\to B_4 \\to B_6$。每条到 $B_6$ 的路径都必须经过 $B_1$ 和 $B_4$。所以 `$\\text{Dom}(B_6)$`: $\\{B_1, B_4, B_6\\}$。\n                *   `$\\text{Dom}(B_7)$`: 到 $B_7$ 的路径：必须经过 $B_4$。它们可以来自 $B_5$ 或 $B_6$。所以每条到 $B_7$ 的路径都必须经过 $B_1$ 和 $B_4$。所以 `$\\text{Dom}(B_7)$`: $\\{B_1, B_4, B_7\\}$。\n                *   `$\\text{Dom}(B_8)$`: 到 $B_8$ 的路径：必须经过 $B_7$。到 $B_8$ 的唯一边是 $B_7 \\to B_8$。所以每条到 $B_8$ 的路径都必须经过 $B_7$。而每条到 $B_7$ 的路径都经过 $B_1$ 和 $B_4$。所以 `$\\text{Dom}(B_8)$`: $\\{B_1, B_4, B_7, B_8\\}$。\n\n        2.  **计算立即支配者：** 一个节点 `$n \\ne n_{\\text{entry}}$` 的立即支配者 `$\\text{idom}(n)$` 是 `$\\text{Dom}(n) - \\{n\\}$` 中的唯一节点 `$d$`，它被 `$\\text{Dom}(n) - \\{n\\}$` 中所有其他节点所支配。\n            *   `$\\text{idom}(B_1)$`: 无（它是入口节点）\n            *   `$\\text{idom}(B_2)$`: `$\\text{Dom}(B_2) = \\{B_1, B_2\\}`. `$\\text{Dom}(B_2) - \\{B_2\\} = \\{B_1\\}`. 所以, `$\\text{idom}(B_2) = B_1`。\n            *   `$\\text{idom}(B_3)$`: `$\\text{Dom}(B_3) = \\{B_1, B_3\\}`. `$\\text{Dom}(B_3) - \\{B_3\\} = \\{B_1\\}`. 所以, `$\\text{idom}(B_3) = B_1`。\n            *   `$\\text{idom}(B_4)$`: `$\\text{Dom}(B_4) = \\{B_1, B_4\\}`. `$\\text{Dom}(B_4) - \\{B_4\\} = \\{B_1\\}`. 所以, `$\\text{idom}(B_4) = B_1`。\n            *   `$\\text{idom}(B_5)$`: `$\\text{Dom}(B_5) = \\{B_1, B_4, B_5\\}`. `$\\text{Dom}(B_5) - \\{B_5\\} = \\{B_1, B_4\\}`. $B_1$ 支配 $B_4$。所以, `$\\text{idom}(B_5) = B_4`。\n            *   `$\\text{idom}(B_6)$`: `$\\text{Dom}(B_6) = \\{B_1, B_4, B_6\\}`. `$\\text{Dom}(B_6) - \\{B_6\\} = \\{B_1, B_4\\}`. $B_1$ 支配 $B_4$。所以, `$\\text{idom}(B_6) = B_4`。\n            *   `$\\text{idom}(B_7)$`: `$\\text{Dom}(B_7) = \\{B_1, B_4, B_7\\}`. `$\\text{Dom}(B_7) - \\{B_7\\} = \\{B_1, B_4\\}`. $B_1$ 支配 $B_4$。所以, `$\\text{idom}(B_7) = B_4`。\n            *   `$\\text{idom}(B_8)$`: `$\\text{Dom}(B_8) = \\{B_1, B_4, B_7, B_8\\}`. `$\\text{Dom}(B_8) - \\{B_8\\} = \\{B_1, B_4, B_7\\}`. $B_1$ 支配 $B_4$，而 $B_4$ 支配 $B_7$。所以, `$\\text{idom}(B_8) = B_7`。\n\n        3.  **构建支配树：**\n            *   根: $B_1$\n            *   $B_1$ 的子节点: $B_2$, $B_3$, $B_4$\n            *   $B_2$ 的子节点: 无\n            *   $B_3$ 的子节点: 无\n            *   $B_4$ 的子节点: $B_5$, $B_6$, $B_7$\n            *   $B_5$ 的子节点: 无\n            *   $B_6$ 的子节点: 无\n            *   $B_7$ 的子节点: $B_8$\n            *   $B_8$ 的子节点: 无\n            *   树:\n                *   $B_1 \\to B_2$\n                *   $B_1 \\to B_3$\n                *   $B_1 \\to B_4 \\to B_5$\n                *   $B_1 \\to B_4 \\to B_6$\n                *   $B_1 \\to B_4 \\to B_7 \\to B_8$\n            *   检查 `$\\text{idom}(B_4) = B_1`。到 $B_4$ 的路径是 $B_1 \\to B_2 \\to B_4$ 和 $B_1 \\to B_3 \\to B_4$。公共支配节点是 $\\{B_1, B_4\\}$。是的，`$\\text{idom}(B_4)=B_1`。我的分析是正确的。\n\n        4.  **计算支配边界：**\n            *   一个节点 `$n$` 的支配边界 `$DF(n)$` 是所有节点 `$y$` 的集合，其中 `$n$` 支配 `$y$` 的一个直接前驱 `$p$`，但 `$n$` 并不*严格*支配 `$y$`。定义是：`$DF(n) = \\{ y | \\exists p \\in \\text{pred}(y) \\text{ s.t. } n \\text{ dom } p, \\text{ but } n \\text{ does not strictly dominate } y \\}$`。\n\n            我们为每个节点 `$n$` 计算：\n            *   `$DF(B_1)$`:\n                *   `$n = B_1$`。我们正在寻找节点 `$y$`，其中 `$B_1$` 支配 `$y$` 的一个前驱 `$p$`，但 `$B_1$` 并不严格支配 `$y$`。\n                *   `$B_1$` 严格支配除 `$B_1$` 之外的所有节点。\n                *   唯一 `$B_1$` 不严格支配的节点 `$y$` 是 `$B_1$` 本身。但 `$B_1$` 没有前驱。所以 `$DF(B_1) = \\{\\}$`。\n            *   `$DF(B_2)$`:\n                *   `$n = B_2$`.\n                *   `$B_2$` 只支配它自己。我们需要找到 `$y$`，使得 `$B_2$` 支配 `$p \\in \\text{pred}(y)$`。唯一可能的 `$p$` 是 `$B_2$` 本身。`$B_2$` 的后继是 `$\\{B_4\\}$`。所以 `$y = B_4$`。\n                *   `$B_4$` 的前驱是 `$p=B_2$`。`$B_2$` 支配 `$B_2$`。\n                *   `$B_2$` 是否严格支配 `$B_4$`？不是。`$\\text{Dom}(B_4) = \\{B_1, B_4\\}$`。\n                *   所以 `$B_4 \\in DF(B_2)$`。\n                *   `$DF(B_2) = \\{B_4\\}$`。\n            *   `$DF(B_3)$`:\n                *   `$n = B_3$`.\n                *   `$B_3$` 的后继: `$\\{B_4\\}$`。所以 `$y = B_4$`。\n                *   `$B_4$` 的前驱是 `$p=B_3$`。`$B_3$` 支配 `$B_3$`。\n                *   `$B_3$` 是否严格支配 `$B_4$`？不是。`$\\text{Dom}(B_4) = \\{B_1, B_4\\}$`。\n                *   所以 `$B_4 \\in DF(B_3)$`。\n                *   `$DF(B_3) = \\{B_4\\}$`。\n            *   `$DF(B_4)$`:\n                *   `$n = B_4$`.\n                *   被 `$B_4$` 支配的节点: `$B_4, B_5, B_6, B_7, B_8$`。\n                *   我们检查这些节点的后继。\n                *   `$B_4$` 的后继: `$\\{B_5, B_6\\}$`。对于 `$y=B_5$`, `$p=B_4$`。`$B_4$` 支配 `$B_4$`。`$B_4$` 严格支配 `$B_5$`。所以 `$B_5$` 不在 `$DF(B_4)$` 中。`$B_6$` 同理。\n                *   `$B_5$` 的后继: `$\\{B_7\\}$`。对于 `$y=B_7$`, `$p=B_5$`。`$B_4$` 支配 `$B_5$`。`$B_4$` 是否严格支配 `$B_7$`？是的。`$\\text{idom}(B_7)=B_4$`。所以 `$B_7$` 不在 `$DF(B_4)$` 中。\n                *   `$B_6$` 的后继: `$\\{B_7\\}$`。对于 `$y=B_7$`, `$p=B_6$`。`$B_4$` 支配 `$B_6$`。`$B_4$` 严格支配 `$B_7$`。所以 `$B_7$` 不在 `$DF(B_4)$` 中。\n                *   `$B_7$` 的后继: `$\\{B_4, B_8\\}$`。\n                *   情况 `$y = B_4$`: `$p=B_7$`。`$B_4$` 支配 `$B_7$`。`$B_4$` 是否严格支配 `$B_4$`？不是。所以，`$B_4 \\in DF(B_4)`。这是回边。\n                *   情况 `$y = B_8$`: `$p=B_7$`。`$B_4$` 支配 `$B_7$`。`$B_4$` 是否严格支配 `$B_8$`？是的。`$\\text{idom}(B_8)=B_7$`，且 `$\\text{idom}(B_7)=B_4$`。所以 `$B_4$` 是 `$B_8$` 在支配树中的祖先。所以 `$B_8$` 不在 `$DF(B_4)$` 中。\n                *   所以, `$DF(B_4) = \\{B_4\\}$`。\n            *   `$DF(B_5)$`:\n                *   `$n = B_5$`。`$B_5$` 只支配 `$B_5$`。\n                *   `$B_5$` 的后继是 `$y=B_7$`。前驱 `$p=B_5$`。\n                *   `$B_5$` 支配 `$B_5$`。`$B_5$` 是否严格支配 `$B_7$`？不是。`$\\text{Dom}(B_7) = \\{B_1, B_4, B_7\\}$`。\n                *   所以, `$B_7 \\in DF(B_5)`。\n                *   `$DF(B_5) = \\{B_7\\}$`。\n            *   `$DF(B_6)$`:\n                *   `$n = B_6$`。`$B_6$` 只支配 `$B_6$`。\n                *   `$B_6$` 的后继是 `$y=B_7$`。前驱 `$p=B_6$`。\n                *   `$B_6$` 支配 `$B_6$`。`$B_6$` 是否严格支配 `$B_7$`？不是。`$\\text{Dom}(B_7) = \\{B_1, B_4, B_7\\}$`。\n                *   所以, `$B_7 \\in DF(B_6)`。\n                *   `$DF(B_6) = \\{B_7\\}$`。\n            *   `$DF(B_7)$`:\n                *   `$n = B_7$`。`$B_7$` 支配 `$B_7$` 和 `$B_8$`。\n                *   `$B_7$` 的后继: `$\\{B_4, B_8\\}$`。\n                *   `$y = B_4$`。前驱 `$p = B_7$`。`$B_7$` 支配 `$B_7$`。`$B_7$` 是否严格支配 `$B_4$`？不是。`$B_4$` 支配 `$B_7$`。所以 `$B_4 \\in DF(B_7)`。\n                *   `$y = B_8$`。前驱 `$p=B_7$`。`$B_7$` 支配 `$B_7$`。`$B_7$` 是否严格支配 `$B_8$`？是的，`$\\text{idom}(B_8)=B_7$`。所以，`$B_8$` 不在 `$DF(B_7)`` 中。\n                *   所以, `$DF(B_7) = \\{B_4\\}$`。\n            *   `$DF(B_8)`:\n                *   `$n = B_8$`。`$B_8$` 只支配 `$B_8$`。\n                *   `$B_8$` 的后继: `{}`。\n                *   `$DF(B_8) = \\{\\}`。\n\n        *   **支配边界总结（第1部分）：**\n            *   `$DF(B_1) = \\{\\}`\n            *   `$DF(B_2) = \\{B_4\\}$`\n            *   `$DF(B_3) = \\{B_4\\}$`\n            *   `$DF(B_4) = \\{B_4\\}$`\n            *   `$DF(B_5) = \\{B_7\\}$`\n            *   `$DF(B_6) = \\{B_7\\}$`\n            *   `$DF(B_7) = \\{B_4\\}$`\n            *   `$DF(B_8) = \\{\\}`\n\n    *   **第2部分：计算 $\\phi$ 函数放置位置**\n        *   算法：迭代支配边界。\n        *   输入：一个包含变量 `$v$` 定义的节点集合 `$S$`。\n        *   输出：一个需要为 `$v$` 放置 $\\phi$ 函数的节点集合 `$\\Phi$`。\n        *   算法：\n            1.  `$W = S$` (工作列表)\n            2.  `$\\Phi = \\{\\}$` (带有 $\\phi$ 函数的节点集合)\n            3.  `while W is not empty:`\n            4.      `remove a node n from W`\n            5.      `for each y in DF(n):`\n            6.          `if y not in \\Phi:`\n            7.              `$\\Phi = \\Phi \\cup \\{y\\}$`\n            8.              `add y to W`\n        *   我们来追踪一下。\n        *   **初始状态：**\n            *   `$S = \\{B_1, B_2\\}$`（给定的 `$v$` 的定义位置）\n            *   `$W = \\{B_1, B_2\\}$`\n            *   `$\\Phi = \\{\\}$`\n\n        *   **迭代 1:**\n            *   从 `$W$` 中移除 `$B_1$`。`$W = \\{B_2\\}$`。\n            *   `$DF(B_1) = \\{\\}`。内部循环不做任何事。\n            *   `$\\Phi$` 保持为 `$\\{\\}$`。\n\n        *   **迭代 2:**\n            *   从 `$W$` 中移除 `$B_2$`。`$W = \\{\\}$`。\n            *   `$DF(B_2) = \\{B_4\\}$`。\n            *   令 `$y = B_4$`。\n            *   `$B_4$` 不在 `$\\Phi$` 中。\n            *   `$\\Phi = \\Phi \\cup \\{B_4\\} = \\{B_4\\}`。\n            *   将 `$B_4$` 添加到 `$W$`。所以, `$W = \\{B_4\\}`。\n\n        *   **迭代 3:**\n            *   `$W$` 非空。`$W = \\{B_4\\}`。\n            *   从 `$W$` 中移除 `$B_4$`。`$W = \\{\\}$`。\n            *   `$DF(B_4) = \\{B_4\\}$`。\n            *   令 `$y = B_4$`。\n            *   `$B_4$` 是否在 `$\\Phi$` 中？是的。`if` 条件 `$y not in \\Phi$` 为假。\n\n        *   **第4步：** `$W$` 现在为空。算法终止。\n\n        *   最终需要放置 $\\phi$ 函数的块集合是 `$\\Phi = \\{B_4\\}$`。\n\n    *   **第3部分：最终答案**\n        *   问题要求的是为 `$v$` 插入的独立 $\\phi$ 函数的总数。\n        *   这就是集合 `$\\Phi$` 的大小。\n        *   大小为 `$|\\{B_4\\}| = 1$`。\n        *   因此，在基本块 `$B_4$` 中插入了一个 $\\phi$ 函数。\n\n    *   整个推理链看起来是正确的。所用概念是标准的编译理论。将算法应用于特定CFG的过程是系统且可验证的。最终答案是结果集的大小。结果是 `1`。", "answer": "$$\n\\boxed{1}\n$$", "id": "3671703"}, {"introduction": "在掌握了基础算法后，让我们来处理一个更贴近真实代码的场景。程序中的循环常常包含 `break` 和 `continue` 等非结构化控制转移语句，这会形成复杂的控制流路径 [@problem_id:3671619]。本练习旨在检验你将这些复杂控制流转化为 CFG 并准确应用 $\\phi$ 函数放置算法的能力，从而深刻理解为何在循环头、循环出口等关键位置需要 $\\phi$ 函数来合并来自不同执行路径的变量值。", "problem": "一个优化编译器将程序转换为静态单赋值 (SSA) 形式，其中每个变量只被精确地赋值一次，并且在控制流连接点处对不同到达定义的合并通过 $\\phi$ 函数来表示。该编译器使用控制流图 (CFG) 作为结构基础，并遵循标准的支配和支配边界方法来放置 $\\phi$ 函数，同时通过活性分析进行剪枝，即仅当变量在某个连接点处是活跃的时，才在该点为该变量插入 $\\phi$ 函数。考虑以下结构化程序，该程序同时使用了循环以及通过 break 和 continue 进行的控制转移：\n- 输入：一个整数 $n$ 和一个从 $0$ 开始索引的整数数组 $A[\\,]$。\n- 变量：整数 $x$、$y$、$i$。\n- 初始化：$x \\leftarrow 0$；$i \\leftarrow 0$。\n- 循环：while ($i  n$) do\n  1. 如果 ($A[i]  0$) 则 $x \\leftarrow x + 1$ 否则 $x \\leftarrow x + A[i]$。\n  2. 如果 ($A[i] = 0$) 则 break。\n  3. 如果 ($(A[i] \\pmod{2}) = 0$) 则 $i \\leftarrow i + 1$；continue。\n  4. $y \\leftarrow x + i$。\n  5. $i \\leftarrow i + 1$。\n- 循环退出后，返回 $x$。\n假设采用常规的结构化方法将其转换为控制流图 (CFG)，其中：\n- 循环条件构成一个循环头，它有两个前驱：一个唯一的前置头和循环回边。\n- 第一个条件语句（步骤1）是一个 if-else 结构，在步骤2之前重新汇合。\n- 步骤2中的 break 将控制转移到唯一的循环出口块，当循环条件不满足时，该块也接收来自循环头的顺序执行路径。\n- 步骤3中的 continue 沿一条回边将控制转移到循环头。\n使用标准的基于支配和支配边界的 $\\phi$ 函数放置方法（如 Cytron 等人所述），并构建剪枝的 SSA（即仅在变量活跃的地方插入 $\\phi$ 函数），确定在整个程序中专门为变量 $x$ 必须插入的 $\\phi$ 函数的最小总数，包括在循环头和因 break 路径导致的循环出口处。以整数形式提供最终答案。无需四舍五入。", "solution": "该问题要求在将给定程序转换为剪枝的静态单赋值 (SSA) 形式时，确定变量 $x$ 所需的 $\\phi$ 函数的最小数量。根据题目要求，完成此任务的标准算法包括两个主要阶段：\n1.  使用支配边界准则放置 $\\phi$ 函数。\n2.  对变量不活跃之处插入的 $\\phi$ 函数进行剪枝。\n\n我们将系统地遵循这些步骤。\n\n首先，我们根据程序结构和给定的转换规则构建控制流图 (CFG)。我们定义以下基本块：\n-   `B_Init`：包含初始赋值 $x \\leftarrow 0$ 和 $i \\leftarrow 0$。它是循环的前置头。\n-   `B_Header`：循环头，用于评估条件 $i  n$。\n-   `B_IfBody`：循环体的入口，包含第一个条件测试 $A[i]  0$。\n-   `B_Then`：第一个条件语句的 'then' 分支，包含 $x \\leftarrow x + 1$。\n-   `B_Else`：第一个条件语句的 'else' 分支，包含 $x \\leftarrow x + A[i]$。\n-   `B_Join1`：第一个 `if-else` 语句的重新汇合点。\n-   `B_BreakTest`：包含用于 `break` 的第二个条件测试 $A[i] = 0$。\n-   `B_ContTest`：包含用于 `continue` 的第三个条件测试 $(A[i] \\pmod{2}) = 0$。\n-   `B_Continue`：包含 $i \\leftarrow i + 1$ 和 `continue` 转移。\n-   `B_BodyEnd`：包含循环体的最后部分，$y \\leftarrow x + i$ 和 $i \\leftarrow i + 1$。\n-   `B_Exit`：唯一的循环出口块，包含 `return x`。\n\n控制流如下：\n-   `B_Init` $\\to$ `B_Header`\n-   `B_Header` $\\to$ `B_IfBody` (如果 $i  n$)\n-   `B_Header` $\\to$ `B_Exit` (如果 $i \\ge n$)\n-   `B_IfBody` $\\to$ `B_Then` (如果 $A[i]  0$)\n-   `B_IfBody` $\\to$ `B_Else` (如果 $A[i] \\ge 0$)\n-   `B_Then` $\\to$ `B_Join1`\n-   `B_Else` $\\to$ `B_Join1`\n-   `B_Join1` $\\to$ `B_BreakTest`\n-   `B_BreakTest` $\\to$ `B_Exit` (如果 $A[i] = 0$，即 `break` 路径)\n-   `B_BreakTest` $\\to$ `B_ContTest` (如果 $A[i] \\ne 0$)\n-   `B_ContTest` $\\to$ `B_Continue` (如果 $(A[i] \\pmod{2}) = 0$)\n-   `B_ContTest` $\\to$ `B_BodyEnd` (如果 $(A[i] \\pmod{2}) \\ne 0$)\n-   `B_Continue` $\\to$ `B_Header` (回边)\n-   `B_BodyEnd` $\\to$ `B_Header` (回边)\n\nSSA 构建的核心原则是：对于任何一个节点 $N$，如果变量 $v$ 的不同到达定义在此汇合，那么节点 $N$ 就需要为变量 $v$ 设置一个 $\\phi$ 函数。所有这类节点 $N$ 的集合正是包含 $v$ 赋值的节点集合的迭代支配边界，记为 $DF^+$。\n\n变量 $x$ 的赋值（定义）出现在三个块中：\n-   `B_Init`: $x \\leftarrow 0$\n-   `B_Then`: $x \\leftarrow x + 1$\n-   `B_Else`: $x \\leftarrow x + A[i]$\n\n设 $S = \\{ \\text{B\\_Init, B\\_Then, B\\_Else} \\}$ 是包含 $x$ 定义的块的集合。我们必须计算 $DF^+(S)$。这是通过迭代完成的。设 $\\Phi$ 是放置 $\\phi$ 函数的块的集合。初始时，$\\Phi = \\emptyset$。\n\n1.  **初始 $\\phi$ 函数放置：** 我们计算 $S$ 中各块的支配边界。\n    -   `B_Then` 和 `B_Else` 中的定义是不同的。它们都到达 `B_Join1`，这是这些块之后的第一个控制流汇合点。形式上，`B_Join1` 处于 `B_Then` 和 `B_Else` 的支配边界中。因此，必须在 `B_Join1` 处为 $x$ 放置一个 $\\phi$ 函数。\n    $\\Phi_1 = DF(\\text{B\\_Then}) \\cup DF(\\text{B\\_Else}) = \\{ \\text{B\\_Join1} \\}$。\n    因此，在 `B_Join1` 处放置一个 $\\phi$ 函数。这是我们的第一个 $\\phi$ 函数。\n\n2.  **迭代 $\\phi$ 函数放置：** 在 `B_Join1` 处放置 $\\phi$ 函数实际上在该块为 $x$ 创建了一个新的定义。我们现在必须考虑 `B_Join1` 的支配边界。\n    -   `B_Init` 中（循环外）对 $x$ 的定义和 `B_Join1` 中（循环内，通过 `B_Continue` 和 `B_BodyEnd` 的回边流回）对 $x$ 的新定义都到达 `B_Header`。因此，`B_Header` 是这些定义的连接点。形式上，`B_Header` 处于 `B_Join1`（以及循环内其他块）的支配边界中。因此，需要在 `B_Header` 处放置一个 $\\phi$ 函数。\n    -   `break` 语句创建了一条从 `B_BreakTest` 到 `B_Exit` 的路径。此路径上的 $x$ 值来自 `B_Join1` 处的定义。正常的循环终止路径是从 `B_Header` 到 `B_Exit`。此路径上的 $x$ 值来自 `B_Header` 处的 $\\phi$ 函数。这两个不同的 $x$ 定义在 `B_Exit` 处相遇。因此，`B_Exit` 是一个连接点。形式上，`B_Exit` 处于 `B_Join1` 的支配边界中。\n    所以，我们有 $\\Phi_2 = DF(\\text{B\\_Join1}) = \\{ \\text{B\\_Header, B\\_Exit} \\}$。我们将这两个块添加到我们的 $\\phi$ 函数位置集合中。这是我们的第二个和第三个 $\\phi$ 函数。\n\n3.  **进一步迭代：** 我们现在必须考虑新的 $\\phi$ 函数位置 `B_Header` 和 `B_Exit` 的支配边界。\n    -   `DF(\\text{B\\_Header}) = \\emptyset`。`B_Header` 处的定义不会创建更多的连接点。\n    -   `DF(\\text{B\\_Exit}) = \\emptyset`。该块是这部分控制流的终点。\n    迭代终止。在未剪枝的 SSA 形式中，需要为 $x$ 设置 $\\phi$ 函数的块集合是 $\\{ \\text{B\\_Join1, B\\_Header, B\\_Exit} \\}$。这总共得到 $3$ 个 $\\phi$ 函数。\n\n现在，我们必须应用剪枝规则：只有当 $x$ 在块 $N$ 的入口处是“活跃”的，才在该块为 $x$ 插入 $\\phi$ 函数。如果一个变量的当前值可能在未来被使用，那么它就是活跃的。我们检查 $x$ 在这三个候选块的入口处的活性。\n\n$x$ 的使用出现在：\n-   `B_Then`：在表达式 $x + 1$ 中。\n-   `B_Else`：在表达式 $x + A[i]$ 中。\n-   `B_BodyEnd`：在表达式 $x + i$ 中。\n-   `B_Exit`：在表达式 `return x` 中。\n\n-   **在 `B_Join1` 处的活性：** $x$ 在 `B_Join1` 的入口处是活跃的吗？是的。存在一条从 `B_Join1` 到 `B_BodyEnd` 的路径，其中 $x$ 被用来计算 $y$。也存在一条通过 `break` 从 `B_Join1` 到 `B_Exit` 的路径，其中 $x$ 在 `return` 语句中被使用。由于存在未来的使用，所以 $x$ 是活跃的。在 `B_Join1` 处的 $\\phi$ 函数**不被剪枝**。\n\n-   **在 `B_Header` 处的活性：** $x$ 在 `B_Header` 的入口处是活跃的吗？是的。进入循环头的 $x$ 值可以在第一次迭代时在 `B_Then` 或 `B_Else` 中被使用。它也可以在循环通过 `B_Header` $\\to$ `B_Exit` 路径终止后被使用，该路径上有 `return x` 语句。由于存在未来的使用，所以 $x$ 是活跃的。在 `B_Header` 处的 $\\phi$ 函数**不被剪枝**。\n\n-   **在 `B_Exit` 处的活性：** $x$ 在 `B_Exit` 的入口处是活跃的吗？是的。`B_Exit` 块本身包含语句 `return x`，这是对 $x$ 的一次使用。如果一个变量在块中被使用（且在使用前没有被重新定义），那么它在该块的入口处总是活跃的。在 `B_Exit` 处的 $\\phi$ 函数**不被剪枝**。\n\n由于 $x$ 在所有三个块——`B_Join1`、`B_Header` 和 `B_Exit`——的入口处都是活跃的，因此通过支配边界准则放置的 $\\phi$ 函数都没有被剪枝。\n\n因此，变量 $x$ 所需的 $\\phi$ 函数的最小总数为 $3$。", "answer": "$$\n\\boxed{3}\n$$", "id": "3671619"}, {"introduction": "在 SSA 形式中放置 $\\phi$ 函数解决了数据流的表示问题，但为了生成最终的机器码，这些抽象的 $\\phi$ 函数必须被“降级”为具体的指令。本练习将带你探索 SSA 的后端实现，即如何将 $\\phi$ 函数的并行复制语义转化为一系列有序的寄存器移动指令 [@problem_id:3671657]。你将学习如何分析复制依赖、识别并打破寄存器交换所产生的循环，从而高效地将代码从 SSA 形式转换回传统形式。", "problem": "在静态单赋值（SSA）形式中，一个基本块入口处的$\\phi$-函数语义要求：当控制流沿着一个前驱边转移时，每个$\\phi$-节点都精确地选择在该边上产生的值，如同所有被选择的赋值在块入口处同时发生。设$B$是一个汇合块，其前驱为$P_1$和$P_2$。块$B$包含三个分别用于变量$x$、$y$和$z$的$\\phi$-节点。$B$中的目标寄存器分配已被固定：$x$被分配给寄存器$r_2$，$y$被分配给$r_3$，$z$被分配给$r_1$。在每个前驱的末尾，供给这些$\\phi$-节点的值位于以下机器寄存器中：\n\n- 沿着边 $P_1 \\to B$：$x_1$在$r_1$中，$y_1$在$r_2$中，$z_1$在$r_3$中。\n- 沿着边 $P_2 \\to B$：$x_2$在$r_2$中，$y_2$在$r_1$中，$z_2$在$r_3$中。\n\n为了消除$\\phi$-节点，您需要将它们降解为每条边上的并行拷贝，这些拷贝将源寄存器中的值移动到它们在$B$中的目标寄存器。一条边上的并行拷贝集必须通过一系列形式为 $a := b$ 的具体移动指令来实现，这些指令在该边上顺序执行，并共同维护同时发生的语义。您可以省略任何源和目标是同一寄存器的移动指令。您可以使用一个且仅一个全新的临时寄存器$t$（不同于$r_1$, $r_2$, $r_3$）来打破拷贝依赖中的循环；允许在每条边上独立使用$t$。将一条边上的“额外移动”定义为超出该边并行拷贝集所蕴含的非恒等拷贝数量的任何已执行的移动指令。\n\n任务：\n- 对于每条边$P_i \\to B$（$i \\in \\{1,2\\}$），在指定的寄存器位置下，推导出由三个$\\phi$-节点引发的并行拷贝集。\n- 在每条边上提出一个有效的顺序移动调度，该调度实现并行拷贝集，仅在绝对必要时使用$t$来避免破坏性循环，并最小化该边上的额外移动次数。\n- 在满足这些规则的所有有效调度中，确定在两条边$P_1 \\to B$和$P_2 \\to B$上的最小额外移动总数。\n\n最终答案请提供一个等于这两条边上最小额外移动总数的单个整数。无需四舍五入。", "solution": "题目要求我们确定将基本块$B$入口处的$\\phi$-函数降解为其前驱边$P_1 \\to B$和$P_2 \\to B$上的顺序移动指令所需的“额外移动”的最小总数。一个额外移动被定义为在给定边上超出非恒等拷贝数量的任何已执行的移动。\n\n首先，我们确定目标状态。在块$B$的入口处，变量$x$, $y$, $z$的值必须分别位于寄存器$r_2$, $r_3$, $r_1$中。$\\phi$-函数定义了使用哪个前驱的值：\n- $x_{B} = \\phi(x_1 \\text{ from } P_1, x_2 \\text{ from } P_2)$\n- $y_{B} = \\phi(y_1 \\text{ from } P_1, y_2 \\text{ from } P_2)$\n- $z_{B} = \\phi(z_1 \\text{ from } P_1, z_2 \\text{ from } P_2)$\n\n我们分别分析每个前驱边。\n\n**对边 $P_1 \\to B$ 的分析**\n\n在来自前驱$P_1$的边上，值$x_1$, $y_1$, $z_1$是$\\phi$-函数的源。题目说明了它们在块$P_1$末尾的位置：\n- $x_1$在寄存器$r_1$中。\n- $y_1$在寄存器$r_2$中。\n- $z_1$在寄存器$r_3$中。\n\n为了在块$B$的入口处建立所需状态，以下同时赋值（称为并行拷贝）必须在边$P_1 \\to B$上发生：\n- $B$中$x$的值（在$r_2$中）必须来自$x_1$（在$r_1$中）。这意味着拷贝$r_2 := r_1$。\n- $B$中$y$的值（在$r_3$中）必须来自$y_1$（在$r_2$中）。这意味着拷贝$r_3 := r_2$。\n- $B$中$z$的值（在$r_1$中）必须来自$z_1$（在$r_3$中）。这意味着拷贝$r_1 := r_3$。\n\n这条边的并行拷贝集是 $\\{r_2 := r_1, r_3 := r_2, r_1 := r_3\\}$。这三个都是非恒等拷贝。要用顺序移动来实现这一点，我们必须分析依赖关系。对于每个拷贝$r_d := r_s$，存在一个依赖$r_s \\to r_d$，因为需要$r_s$中的原始值。依赖图是：\n$r_1 \\to r_2$\n$r_2 \\to r_3$\n$r_3 \\to r_1$\n\n这些依赖形成一个3-循环：$r_1 \\to r_2 \\to r_3 \\to r_1$。直接的顺序实现，例如$r_2 := r_1$，会破坏后续拷贝所需的$r_1$中的值。这样的循环使得使用提供的临时寄存器$t$变得“绝对必要”。\n\n要打破一个长度为$k \\ge 2$的循环，使用临时寄存器的最优序列需要$k+1$次移动。这里，$k=3$。一个最小的移动调度是：\n1. $t := r_3$ (保存$z_1$的值)\n2. $r_3 := r_2$ (将$y_1$的值移动到其目标$r_3$)\n3. $r_2 := r_1$ (将$x_1$的值移动到其目标$r_2$)\n4. $r_1 := t$ (将保存的$z_1$的值移动到其目标$r_1$)\n\n非恒等拷贝的数量是$3$。执行的顺序移动数量是$4$。额外移动的数量是差值：$4 - 3 = 1$。这是该边上可能的最小值，因为需要一次额外移动来打破循环。\n\n**对边 $P_2 \\to B$ 的分析**\n\n在来自前驱$P_2$的边上，$x_2$, $y_2$, $z_2$是源。它们在块$P_2$末尾的位置是：\n- $x_2$在寄存器$r_2$中。\n- $y_2$在寄存器$r_1$中。\n- $z_2$在寄存器$r_3$中。\n\n边$P_2 \\to B$的并行拷贝可以类似地推导出来：\n- $B$中$x$的值（在$r_2$中）必须来自$x_2$（在$r_2$中）。这意味着拷贝$r_2 := r_2$。\n- $B$中$y$的值（在$r_3$中）必须来自$y_2$（在$r_1$中）。这意味着拷贝$r_3 := r_1$。\n- $B$中$z$的值（在$r_1$中）必须来自$z_2$（在$r_3$中）。这意味着拷贝$r_1 := r_3$。\n\n并行拷贝集是 $\\{r_2 := r_2, r_3 := r_1, r_1 := r_3\\}$。\n题目允许我们省略源和目标相同的移动。因此，移动$r_2 := r_2$不被执行。非恒等拷贝集是 $\\{r_3 := r_1, r_1 := r_3\\}$。\n\n这两个拷贝的依赖图是：\n$r_1 \\to r_3$\n$r_3 \\to r_1$\n\n这形成一个2-循环：$r_1 \\to r_3 \\to r_1$。这代表一个交换操作。与前一个情况一样，循环使得使用临时寄存器$t$成为必要。要打破这个长度为$k=2$的循环，我们需要$k+1 = 3$次顺序移动。一个最小的移动调度是：\n1. $t := r_1$ (保存$y_2$的值)\n2. $r_1 := r_3$ (将$z_2$的值移动到其目标$r_1$)\n3. $r_3 := t$ (将保存的$y_2$的值移动到其目标$r_3$)\n\n非恒等拷贝的数量是$2$。执行的顺序移动数量是$3$。额外移动的数量是差值：$3 - 2 = 1$。这是可能的最小值，因为需要一次额外移动来解决交换循环。\n\n**最小额外移动总数**\n\n最小额外移动数是每条边所需的最小额外移动数之和。\n- 边$P_1 \\to B$的最小额外移动数：$1$。\n- 边$P_2 \\to B$的最小额外移动数：$1$。\n\n两条边上的最小额外移动总数是$1 + 1 = 2$。", "answer": "$$\n\\boxed{2}\n$$", "id": "3671657"}]}