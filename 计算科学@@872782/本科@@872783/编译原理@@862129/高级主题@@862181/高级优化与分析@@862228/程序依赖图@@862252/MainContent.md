## 引言
在编译器和[程序分析](@entry_id:263641)领域，如何精确地理解和表示一个程序的内在逻辑是所有高级优化的前提。传统的[控制流图](@entry_id:747825)（CFG）虽然能描绘出所有可能的执行路径，但却隐藏了语句之间更为重要的因果关系——即一个操作的执行为何以及如何依赖于另一个操作。[程序依赖图](@entry_id:753802)（Program Dependence Graph, PDG）应运而生，它是一种更高级的[中间表示](@entry_id:750746)，通过显式地建模数据依赖和[控制依赖](@entry_id:747830)，直接揭示了程序的语义结构，为分析和转换代码提供了强大的理论基础。

本文将带领读者深入探索[程序依赖图](@entry_id:753802)的世界。无论你是[编译器设计](@entry_id:271989)的初学者，还是希望深化对[程序分析](@entry_id:263641)理解的软件工程师，都能从中获益。我们将分三个章节逐步展开：
- **原理与机制**：我们将从最基本的构件——数据依赖和[控制依赖](@entry_id:747830)——出发，详细拆解它们的定义、类型以及在处理指针、异常、短路求值等复杂语言特性时的微妙之处。我们还将探讨PDG与现代编译器中流行的[静态单赋值](@entry_id:755378)（SSA）形式之间的紧密联系。
- **应用与[交叉](@entry_id:147634)学科联系**：在掌握了基础原理后，我们将视野拓宽，探索PDG如何在[编译器优化](@entry_id:747548)、软件工程和计算机安[全等](@entry_id:273198)多个领域大放异彩。你将看到PDG如何指导[指令调度](@entry_id:750686)、[循环并行化](@entry_id:751483)、[程序切片](@entry_id:753804)、污点分析等关键任务。
- **动手实践**：理论结合实践是最好的学习方式。本章将通过一系列精心设计的练习，引导你亲手构建和分析依赖图，将抽象的理论知识转化为解决实际问题的能力。

现在，让我们从第一章开始，一同揭开[程序依赖图](@entry_id:753802)的神秘面纱。

## 原理与机制

在上一章中，我们介绍了[程序依赖图](@entry_id:753802)（Program Dependence Graph, PDG）作为一种强大的程序[中间表示](@entry_id:750746)，它能够显式地表示程序中语句之间的执行依赖关系。本章将深入探讨构成PDG的核心原理与机制。我们将精确地定义其基本组成部分——[数据依赖](@entry_id:748197)和[控制依赖](@entry_id:747830)，并探讨在不同编程语言特性和编译器表示（如[静态单赋值形式](@entry_id:755286)）下，这些依赖关系的微妙之处。最后，我们将展示PDG如何在[程序切片](@entry_id:753804)、[代码优化](@entry_id:747441)和[指令调度](@entry_id:750686)等关键编译任务中发挥其威力，并将其概念从单个过程扩展到整个程序。

### 构建基石：数据依赖与[控制依赖](@entry_id:747830)

[程序依赖图](@entry_id:753802)的核心思想是将程序的语义关系抽象为两种基本的依赖边：[数据依赖](@entry_id:748197)和[控制依赖](@entry_id:747830)。一个典型的PDG可以表示为图 $G = (V, E_d \cup E_c)$，其中 $V$ 是代表程序操作（如赋值、谓词判断）的节点集，$E_d$ 是数据依赖边的集合，$E_c$ 是[控制依赖](@entry_id:747830)边的集合。

#### [数据依赖](@entry_id:748197)

**[数据依赖](@entry_id:748197)** (data dependence) 描述了程序中因数据交互而产生的约束。正式地说，如果存在一条从语句 $S_i$ 到语句 $S_j$ 的执行路径，使得 $S_i$ 定义了变量 $v$ 的一个值，而 $S_j$ 使用了该值，并且在这条路径上变量 $v$ 没有被重新定义，那么我们就说语句 $S_j$ **[数据依赖](@entry_id:748197)**于语句 $S_i$。这种依赖关系构成了程序中数据流的基础。[数据依赖](@entry_id:748197)主要分为以下三种类型[@problem_id:3664779]：

1.  **真依赖（流依赖）(True/Flow Dependence, RAW)**：这是最直观的依赖类型，即“写后读”（Read-After-Write）。当语句 $S_i$ 写入一个值，而后续语句 $S_j$ 读取该值时，就存在一个从 $S_i$ 到 $S_j$ 的真依赖。例如，在代码序列 `$y := x + 1; z := y;` 中，$z$ 的计算依赖于 $y$ 的先前计算，因此存在一个从第一条语句到第二条语句的真依赖。真依赖是程序固有的数据流，任何代码变换都必须严格保持这种依赖关系，否则将改变程序的语义。

2.  **反依赖 (Anti-Dependence, WAR)**：反依赖，即“读后写”（Write-After-Read），发生在语句 $S_i$ 读取一个变量，而后续语句 $S_j$ 写入该变量时。考虑代码序列 `$S_1: A[i] := x;` 和 `$S_2: x := g(A[j]);` [@problem_id:3664812]。这里，$S_1$ 读取变量 $x$ 的值，而 $S_2$ 重新定义了 $x$。因此，存在一个从 $S_1$ 到 $S_2$ 的关于变量 $x$ 的反依赖。这种依赖并非真正的数据流动，而是由于变量名（存储位置）的复用引起的“伪依赖”或“名称依赖”。如果交换这两条语句的顺序，`$A[i]$` 将会错误地使用由 `$g(A[j])$` 计算出的新值。然而，编译器可以通过**变量重命名**（variable renaming）来打破这种依赖。例如，将 $S_2$ 改为 `$x_{\text{new}} := g(A[j]);`，就可以消除对 $x$ 的反依赖，从而为指令重排提供更大的自由度。

3.  **输出依赖 (Output Dependence, WAW)**：输出依赖，即“写后写”（Write-After-Write），发生在两个语句 $S_i$ 和 $S_j$ 写入同一个变量时。与反依赖类似，输出依赖也是一种由存储复用引起的名称依赖。例如，在 `$x := 5; x := 10;` 中，两条语句之间存在输出依赖。交换它们的顺序会改变程序结束时 $x$ 的最终值。同样，变量重命名也是解决输出依赖的有效方法。

在处理涉及指针和数组的语言时，数据依赖分析变得尤为复杂。考虑以下代码片段[@problem_id:3664731]：
- $S_4$: $p \leftarrow A + i$
- $S_5$: $q \leftarrow \text{if } h() \text{ then } (A + j) \text{ else } (B + j)$
- $S_7$: $*p \leftarrow t + 1$
- $S_8$: $s \leftarrow *q$

这里，$S_7$ 写入内存位置 `$*p$`（即 `A[i]`），而 $S_8$ 读取内存位置 `$*q$`。在编译时，我们可能无法确定 $h()$ 的返回值，也无法确定索引 $i$ 和 $j$ 是否相等。因此，指针 $q$ **可能指向** (may-alias) `A[j]`，而 `A[j]` 又**可能**与 `A[i]` 是同一内存位置。**别名分析** (alias analysis) 的任务就是确定这些指针是否可能指向相同的内存地址。当别名分析无法证明两个内存访问**必定不**指向同一位置时（no-alias），一个**保守**（conservative）的编译器必须假设它们**可能**指向同一位置（may-alias），并在PDG中添加一条相应的数据依赖边。在这个例子中，由于 `$*p$` 和 `$*q$` 可能别名，我们必须在 $S_7$ 和 $S_8$ 之间添加一条数据依赖边，以保证任何依赖于PDG的变换都是安全的。

#### 控制依赖

与数据依赖关注“什么值流向何处”不同，**控制依赖** (control dependence) 关注的是“一个操作的执行为何会发生”。它明确了程序的条件结构如何决定哪些代码会被执行。仅有数据依赖的图（Data Dependence Graph, DDG）虽然能展示所有可能的数据流路径，但却丢失了执行的条件性信息。例如，在一个 `if-then-else` 结构中，`then` 和 `else` 分支中的赋值语句在DDG中可能都存在到后续语句的数据依赖边，但这无法体现它们是**互斥**的——在单次执行中只有一个分支会被选择[@problem_id:3664797]。控制依赖正是为了弥补这一信息鸿沟。

控制依赖有一个基于**后支配** (postdominance) 概念的严格定义。在程序的控制流图（Control Flow Graph, CFG）中，如果从节点 $n$ 到唯一的出口节点 $\mathsf{Exit}$ 的**每一条**路径都经过节点 $p$，那么我们说节点 $p$ **后支配**节点 $n$。

**控制依赖的正式定义**：在一个CFG中，如果存在一条从节点 $X$ 到节点 $Y$ 的路径，使得 $Y$ 后支配这条路径上除 $X$ 之外的所有节点，并且 $X$ 本身不后支配 $Y$，那么节点 $Y$ **控制依赖**于节点 $X$。

这个定义听起来有些复杂，但其本质思想是：节点 $X$ 的执行结果（通常是一个条件分支）直接决定了 $Y$ 是否会被执行。$X$ 必须至少有一个出口路径可以绕过 $Y$（因此 $X$ 不后支配 $Y$），同时至少有一个出口路径必须通向 $Y$。

让我们通过一个 `if (p) then { S_T } else { S_F }` 的例子来理解它。设 $P$ 为谓词节点 `if (p)`，$S_T$ 和 $S_F$ 分别是 `then` 和 `else` 分支的语句。
- 走 `true` 分支的路径是 $P \rightarrow S_T \rightarrow \dots$。
- 走 `false` 分支的路径是 $P \rightarrow S_F \rightarrow \dots$。
由于存在一条从 $P$ 出发可以不经过 $S_T$ 的路径（即 `false` 分支），所以 $P$ 不后支配 $S_T$。然而，在从 $P$ 到 $S_T$ 的路径上，$S_T$ 后支配它自己。因此，$S_T$ 控制依赖于 $P$。同理，$S_F$ 也控制依赖于 $P$。PDG中会包含两条控制依赖边：$(P, S_T)$ 和 $(P, S_F)$。

对于循环结构，如 `while (q) { S_B }`，后面跟着 `S_A`，控制依赖的逻辑同样适用。
- 循环体 `S_B` 的执行取决于谓词 `q` 为真，因此 `S_B` 控制依赖于循环谓词节点。
- 循环后的语句 `S_A` 的执行则取决于循环的终止，即谓词 `q` 最终为假。因此，`S_A` 也控制依赖于该循环谓词节点 [@problem_id:3664797]。

### 控制依赖建模的精妙之处

控制依赖的定义虽然统一，但在应用于复杂的控制结构时，会展现出一些值得深入探讨的细节。

#### 短路求值

许多编程语言（如C、Java）对逻辑运算符 `&&` 和 `||` 采用**短路求值** (short-circuit evaluation) 语义。这意味着逻辑表达式的求值本身就构成了一个微型的控制流。
- 对于 `A && B`，只有当 `A` 为真时，`B` 才会被求值。
- 对于 `A || B`，只有当 `A` 为假时，`B` 才会被求值。

这种行为在PDG中会产生谓词之间的控制依赖。考虑表达式 `if ((P && Q) || R)` [@problem_id:3664831]。
- `Q` 的执行完全取决于 `P` 的结果。如果 `P` 为假，`Q` 就被跳过。因此，`Q` 控制依赖于 `P`。
- `R` 的执行取决于 `(P && Q)` 的结果。如果 `(P && Q)` 为真，`R` 就被跳过。因此，`R` 控制依赖于代表 `(P && Q)` 结果的复合谓词节点。

相比之下，如果语言采用**热切求值** (eager evaluation)，即无论如何都计算 `P`、`Q`、`R` 的值，然后再将它们组合起来，那么 `P`、`Q`、`R` 之间将不存在控制依赖关系。因此，求值策略直接影响PDG的精细结构。

我们可以通过一个具体的例子来精确计算控制依赖。考虑表达式 `$E = (a \land (b \lor c)) \lor (d \land e)$` [@problem_id:3664744]，它控制着一个 `if-then-else` 语句。通过仔细构建其短路求值的CFG，并应用后支配的定义，我们可以推导出 `then` 分支的执行依赖于谓词 $b$、$c$ 和 $e$ 的特定结果，而 `else` 分支的执行则依赖于 $d$ 和 $e$ 的特定结果。这揭示了即使是单个 `if` 语句，其分支的执行也可能依赖于布尔表达式内部的多个原子谓词。

#### 隐式控制流：异常

程序的控制流不仅仅由 `if`、`while` 等显式结构定义。**异常** (exceptions) 会引入隐式的、难以察觉的控制流路径。一条可能抛出异常的语句，例如 `$*p$`，实际上等同于一个条件分支：`if (p is valid) then continue normally else jump to exception handler` [@problem_id:3664787]。

在构建PDG时，这种隐式分支必须被考虑。假设我们有一个简单的序列 $n_1 \rightarrow n_2 \rightarrow n_3$，其中 $n_1$ 可能会抛出一个未捕获的异常。
- 在一个**不考虑异常**的CFG中，$n_2$ 和 $n_3$ 都后支配 $n_1$。因此，$n_2$ 和 $n_3$ 都不控制依赖于 $n_1$。
- 在一个**考虑异常**的CFG中，$n_1$ 有两个可能的后继：正常执行的 $n_2$ 和代表异常的路径。由于存在一条从 $n_1$ 到程序出口却不经过 $n_2$ 和 $n_3$ 的路径（即异常路径），$n_2$ 和 $n_3$ 都不再后支配 $n_1$。根据控制依赖的定义，这导致 $n_2$ 和 $n_3$ 都变得**控制依赖**于 $n_1$。这准确地反映了一个事实：$n_2$ 和 $n_3$ 的执行，取决于 $n_1$ 的成功（非异常）执行。

### PDG与现代编译器：静态单赋值形式的角色

**静态单赋值（Static Single Assignment, SSA）** 形式是现代编译器中一种普遍使用的中间表示。其核心特征是程序中的每个变量只被赋值一次。当原始程序中一个变量在不同控制流路径上有多个定义时，SSA会引入一个特殊的 **$\phi$-函数** (phi-function) 来合并这些值。例如：
`if (c) { x = 1; } else { x = 2; } y = x;`
在SSA形式中会变为：
`if (c) { $x_1$ = 1; } else { $x_2$ = 2; } $x_3$ = $\phi$($x_1$, $x_2$); y = $x_3$;`

SSA形式极大地简化了数据依赖分析。由于每个变量使用点都对应一个唯一的定义点，真依赖（流依赖）关系变得一目了然。在PDG的构建中，SSA与依赖图有着紧密的联系[@problem_id:3664815]：

- **$\phi$-函数与数据依赖**：一个 $\phi$-函数，如 `$x_3 = \phi(x_1, x_2)$`，在PDG中被视为一个普通的操作节点。它的语义是“使用”其参数 `$x_1$` 和 `$x_2$`，并“定义”结果 `$x_3$`。因此，PDG中会包含从 `$x_1$` 的定义点到 $\phi$-函数节点的数据依赖边，以及从 `$x_2$` 的定义点到 $\phi$-函数节点的数据依赖边。$\phi$-函数的传出参数数量等于其所在基本块的CFG前驱数量。

- **$\phi$-函数与控制依赖**：一个常见的误解是，$\phi$-函数控制依赖于决定哪条路径被选择的那个条件谓词。然而，根据标准的后支配定义，$\phi$-函数所在的块（控制流汇合点）通常后支配条件分支节点。因此，$\phi$-函数节点**不**控制依赖于该分支谓词。是分支谓词选择了哪个**值**流入 $\phi$-函数（通过数据依赖），而不是决定了 $\phi$-函数**是否执行**。

- **循环依赖**：在循环中，SSA形式能清晰地表示**循环携带依赖** (loop-carried dependence)。循环头部的 $\phi$-函数会合并来自循环前的值和来自上一轮循环迭代的值。例如，`$i_1$ = $\phi$($i_0$, $i_2$)` 中，`$i_0$` 是初始值，`$i_2$` 是上一轮循环体计算的值。PDG中会有一条从 `$i_2$` 定义点到 `$i_1$` 的 $\phi$-节点的数据依赖边，这清晰地构成了一个代表循环迭代关系的依赖环。

### 程序依赖图的应用

PDG之所以重要，不仅在于其理论上的优雅，更在于它在各种程序分析和变换任务中的巨大实用价值。

#### 程序切片

**程序切片** (program slicing) 是一种强大的程序理解和调试技术。给定一个程序点（称为**切片准则**，slicing criterion），例如“语句 $S$ 中变量 $v$ 的值”，一个后向切片（backward slice）会找出程序中所有可能影响到该值的语句。

在PDG上，计算切片变得异常简单：只需从切片准则对应的节点开始，沿着数据依赖和控制依赖边**反向遍历**图。所有被访问到的节点就构成了切片的结果。控制依赖的包含至关重要：例如，要理解循环后一个变量的值，切片必须包含循环谓词，因为它决定了循环执行的次数，从而影响变量的最终值。没有控制依赖，这种影响就会被忽略 [@problem_id:3664797]。

#### 编译器优化

许多编译器优化可以被看作是保持程序依赖关系不变的图变换[@problem_id:3664828]。

- **死代码消除 (Dead Code Elimination, DCE)**：如果一个操作节点在PDG中没有任何到达“可观察输出”（如打印语句、返回值）的依赖路径（包括数据和控制依赖），那么这个节点就是“死”的，可以被安全地移除。

- **公共子表达式消除 (Common Subexpression Elimination, CSE)**：如果PDG中有两个节点 $n_1$ 和 $n_2$ 执行完全相同的操作，它们的输入操作数来自相同的数据依赖前驱，并且它们的控制依赖条件相同（或 $n_1$ 的执行条件比 $n_2$ 更宽松），那么 $n_2$ 就是一个公共子表达式。优化过程就是将所有原来使用 $n_2$ 结果的节点重定向为使用 $n_1$ 的结果，然后 $n_2$ 就可以作为死代码被消除。

- **循环不变量代码外提 (Loop Invariant Code Motion, LICM)**：如果一个在循环内部的指令节点，其所有的输入数据依赖都来自循环外部的节点，那么这个指令就是**循环不变量**。在PDG中，这意味着该节点没有来自循环内部其他节点的传入数据依赖边（特别是没有循环携带依赖）。满足这个条件（以及一些关于副作用的安全检查），该节点就可以被安全地移动到循环的入口（preheader）处执行，只需修改其控制依赖关系即可。

#### 指令调度

指令调度（Instruction Scheduling）旨在重排指令以提高执行效率，例如在超标量处理器上。其合法性的基本约束就是不能违反任何程序依赖。交换两条语句 $S_1$ 和 $S_2$ 的顺序是合法的，当且仅当它们之间不存在任何从 $S_1$ 到 $S_2$ 的依赖。这包括真依赖、反依赖和输出依赖[@problem_id:3664812]。如前所述，反依赖和输出依赖可以通过变量重命名来消除，但真依赖是不可逾越的障碍。PDG为调度器提供了必须遵守的指令偏[序关系](@entry_id:138937)。

### 扩展至整个程序：[系统依赖图](@entry_id:755776)

到目前为止，我们讨论的PDG都局限于单个过程（函数或方法）内部。为了分析整个程序，我们需要将各个过程的PDG连接起来，形成一个**[系统依赖图](@entry_id:755776) (System Dependence Graph, SDG)** [@problem_id:3664827]。

SDG在PDG的基础上增加了用于表示过程调用的**跨过程依赖边**：
- **调用控制边 (Call-control edge)**：从调用点连接到被调用过程的入口节点，表示调用的发生。
- **参数传入边 (Parameter-in edge)**：对于每个[按值传递](@entry_id:753240)的参数，从调用点的实参节点连接到被调用过程对应的形参节点，表示数据从调用者传递给被调用者。
- **参数传出边 (Parameter-out edge)**：从被调用过程的返回语句（或一个抽象的“形式返回”节点）连接到调用点接收返回值的节点，表示数据从被调用者返回给调用者。

对于复杂的程序，仅仅在调用点和被调用过程之间传递依赖是不够的。我们还需要一种方法来概括一个[过程调用](@entry_id:753765)的整体数据流效应，而无需每次都重新分析其内部。这就是**摘要边 (summary edge)** 的作用。摘要边直接在**调用点**连接一个实参节点和一个接收返回值的节点。一条摘要边的存在，表示在被调用过程内部，存在一条从对应的形参到返回值的有效传递依赖路径。

计算摘要边，尤其是在存在**递归**的情况下，是一个挑战。因为一个[递归函数](@entry_id:634992)的摘要信息依赖于其自身的摘要信息。这形成了一个[不动点](@entry_id:156394)问题。正确的摘要[边集](@entry_id:267160)合是通过一个**迭代[不动点算法](@entry_id:143258)**来计算的：从一个空的摘要集合开始，反复分析函数体，根据已知的摘要信息推导出新的摘要信息，直到集合不再变化为止。这确保了即使在无限递归深度的情况下，[静态分析](@entry_id:755368)也能得出一个有限且正确的程序依赖模型。

通过这些机制，SDG将程序中所有语句的依赖关系——无论是过程内的还是过程间的——都统一到了一个单一的[图表示](@entry_id:273102)中，为全程序的分析和优化提供了坚实的基础。