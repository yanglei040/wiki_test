{"hands_on_practices": [{"introduction": "编译器优化必须在不改变程序可观察行为的前提下进行，这被称为“语义等价”。这个练习 [@problem_id:3659368] 构建了一个看似简单的场景，但一个草率的优化却会导致失败。它将迫使你思考，程序的输入/输出（I/O）等副作用也是其可观察行为的关键部分，任何正确的优化都必须予以保留。", "problem": "给定一种类似 Java 的中间语言，其具有以下可观察语义。调用日志记录例程 $\\mathsf{log}(s)$ 会将字符串 $s$ 追加到一个外部可见的输入/输出 (I/O) 轨迹中，并且没有其他效果。当且仅当 $p = \\texttt{null}$ 时，字段读取 `p.f` 会抛出一个 $\\mathsf{NullPointerException}$（简写为 NPE）。一个程序在初始状态 $\\sigma$ 下的可观察行为是一个序对 $(\\tau, o)$，其中 $\\tau$ 是由 $\\mathsf{log}$ 调用写入轨迹的字符串序列，而 $o$ 是一个正常返回值或一个异常标签（如 $\\mathsf{NPE}$）。当且仅当对于所有的初始状态 $\\sigma$，两个程序 $S$ 和 $S'$ 都能产生相同的 $(\\tau, o)$ 时，它们被认为是可观察等价的。\n\n一个优化编译器提议通过依赖解引用点的隐式 NPE 来消除显式的空检查。考虑以下源程序 $S$ 及其经过此优化后生成的转换版本 $S'$：\n- $S$: `if (p == null) { log(\"about-to-throw\"); }; x := p.f;`\n- $S'$: `x := p.f;`\n\n假设初始状态 $\\sigma$ 将 $p$ 绑定到 $\\texttt{null}$，且所有其他变量与本次讨论无关。编译器声称 $S$ 和 $S'$ 是可观察等价的，因为 `p.f` 处的隐式 NPE 包含了显式检查的功能。\n\n你的任务是：\n- 仅使用上述基本语义定义（轨迹作为有序的 I/O 事件序列，当在 `p.f` 上 $p = \\texttt{null}$ 时抛出异常，以及可观察等价定义为对于所有初始状态，轨迹和结果都相等），判断以下哪个陈述是正确的。\n\n选项：\nA. 禁止这种消除的一个通用正确性规则是：一个保持语义的转换必须对每个初始状态都保留外部可观察行为的序列和顺序以及终止的类型（正常值或异常）。由于当 $p = \\texttt{null}$ 时，$S$ 在 NPE 之前产生一个包含一个 $\\mathsf{log}$ 的轨迹，而 $S'$ 不产生这样的 $\\mathsf{log}$，因此在这种情况下该优化是不允许的。\n\nB. 该消除总是正确的，因为 `p.f` 中的隐式空检查包含了任何显式检查的功能，并且在解引用之前的任何日志记录相对于 NPE 都是不可观察的。\n\nC. 如果静态分析证明在所有路径上，解引用处的 $p \\neq \\texttt{null}$（例如，经支配性证明 $p$ 为非空），则该消除是正确的，因为那时 $S$ 中的分支是不可达的，并且不会发生可观察的 $\\mathsf{log}$。\n\nD. 只要日志记录函数是幂等的，该消除就是正确的，因为移除一个幂等的副作用不会改变可观察行为。\n\nE. 该消除被静态单赋值（SSA）形式所禁止，因为 SSA 表示法不允许移除保护解引用的条件语句。\n\n选择所有适用的选项。", "solution": "### 推导\n核心任务是确定从程序 $S$ 到 $S'$ 的转换是否是保持语义的，根据所提供的定义，这意味着它们必须是可观察等价的。只有当两个程序对于 **所有** 初始状态 $\\sigma$ 都产生相同的可观察行为 $(\\tau, o)$ 时，它们才是可观察等价的。\n\n让我们分析在指定初始状态 $\\sigma$（其中 $p = \\texttt{null}$）下的行为。\n\n**程序 $S$ 的分析**：\n1. 执行语句 `if (p == null)`。由于 $p = \\texttt{null}$，条件为真。\n2. 执行条件语句的主体 `log(\"about-to-throw\")`。这将字符串 `\"about-to-throw\"` 追加到 I/O 轨迹 $\\tau$ 中。轨迹变为 $\\tau = \\langle \\text{\"about-to-throw\"} \\rangle$。\n3. 执行下一条语句 `x := p.f`。由于 $p = \\texttt{null}$，此操作会抛出一个 $\\mathsf{NullPointerException}$（$\\mathsf{NPE}$）。程序因异常而终止。\n4. 在此初始状态下，$S$ 的可观察行为是序对 $(\\tau, o) = (\\langle \\text{\"about-to-throw\"} \\rangle, \\mathsf{NPE})$。\n\n**程序 $S'$ 的分析**：\n1. 执行语句 `x := p.f`。\n2. 由于 $p = \\texttt{null}$，此操作会抛出一个 $\\mathsf{NPE}$。程序因异常而终止。没有进行任何 $\\mathsf{log}$ 调用。\n3. 轨迹 $\\tau$ 是空的，即 $\\tau = \\langle \\rangle$。\n4. 在此初始状态下，$S'$ 的可观察行为是序对 $(\\tau, o) = (\\langle \\rangle, \\mathsf{NPE})$。\n\n**比较**：\n对于 $p = \\texttt{null}$ 的初始状态，可观察行为如下：\n- $S$: $(\\langle \\text{\"about-to-throw\"} \\rangle, \\mathsf{NPE})$\n- $S'$: $(\\langle \\rangle, \\mathsf{NPE})$\n\n这两个序对不相同，因为它们的第一个分量（轨迹）不同：$\\langle \\text{\"about-to-throw\"} \\rangle \\neq \\langle \\rangle$。\n\n由于存在至少一个初始状态，使得 $S$ 和 $S'$ 产生不同的可观察行为，因此它们 **不是** 可观察等价的。编译器提议的优化在一般情况下是不正确的。\n\n### 逐项分析\n\n**A. 禁止这种消除的一个通用正确性规则是：一个保持语义的转换必须对每个初始状态都保留外部可观察行为的序列和顺序以及终止的类型（正常值或异常）。由于当 $p = \\texttt{null}$ 时，$S$ 在 NPE 之前产生一个包含一个 $\\mathsf{log}$ 的轨迹，而 $S'$ 不产生这样的 $\\mathsf{log}$，因此在这种情况下该优化是不允许的。**\n这个陈述准确地反映了问题中提供的可观察等价性的定义。“外部可观察行为的序列和顺序”对应于轨迹 $\\tau$，“终止的类型”对应于结果 $o$。分析接着将此规则正确地应用于 $p = \\texttt{null}$ 的情况，并指出了轨迹的不同。如上文推导所示，这种轨迹上的差异证明了程序是不等价的。因此，该优化是不允许的这一结论是正确的。\n**结论：正确**\n\n**B. 该消除总是正确的，因为 `p.f` 中的隐式空检查包含了任何显式检查的功能，并且在解引用之前的任何日志记录相对于 NPE 都是不可观察的。**\n这个陈述提出的主张与问题的既定前提直接矛盾。问题明确地将由 $\\mathsf{log}$ 调用生成的 I/O 轨迹 $\\tau$ 定义为程序可观察行为的一个组成部分。因此，声称日志记录是“不可观察的”是错误的。轨迹的差异正是该转换不正确的原因。\n**结论：错误**\n\n**C. 如果静态分析证明在所有路径上，解引用处的 $p \\neq \\texttt{null}$（例如，经支配性证明 $p$ 为非空），则该消除是正确的，因为那时 $S$ 中的分支是不可达的，并且不会发生可观察的 $\\mathsf{log}$。**\n让我们分析在所有可能到达此代码的执行中，已知 $p \\neq \\texttt{null}$ 的情况。\n- 在程序 $S$ 中，条件 `if (p == null)` 将始终为假。因此，`if` 块内的 $\\mathsf{log}$ 调用是不可达的，永远不会执行。程序继续执行 `x := p.f`，该语句正常执行（不抛出 $\\mathsf{NPE}$）。产生的轨迹 $\\tau$ 是空的，即 $\\langle \\rangle$。\n- 在程序 $S'$ 中，语句 `x := p.f` 正常执行，因为 $p \\neq \\texttt{null}$。产生的轨迹 $\\tau$ 也是空的，即 $\\langle \\rangle$。\n在这种情况下，对于任何给定的非空 $p$ 值，两个程序都会产生相同的空轨迹，并正常终止，同时将相同的值赋给 $x$。因此，在 $p$ 被证明为非空的条件下，程序 $S$ 和 $S'$ 确实是可观察等价的。该陈述正确地指出了一个使该优化有效的条件。\n**结论：正确**\n\n**D. 只要日志记录函数是幂等的，该消除就是正确的，因为移除一个幂等的副作用不会改变可观察行为。**\n幂等性意味着一个操作无论应用一次还是多次，其效果都是相同的（例如，$f(f(x)) = f(x)$）。给定的 $\\mathsf{log}(s)$ 函数是*追加*到轨迹中。调用两次，例如 $\\mathsf{log}(\"a\")$; $\\mathsf{log}(\"a\")$，会产生轨迹 $\\langle \"a\", \"a\" \\rangle$，这与单次调用产生的轨迹 $\\langle \"a\" \\rangle$ 是不同的。因此，$\\mathsf{log}$ 函数不是幂等的。此外，所讨论的转换是从一次调用到零次调用。移除唯一的一次 $\\mathsf{log}$ 调用会将可观察轨迹从 $\\langle \\text{\"about-to-throw\"} \\rangle$ 变为 $\\langle \\rangle$，无论幂等性如何，这都是一个可观察的差异。这个推理在多个方面都是有缺陷的。\n**结论：错误**\n\n**E. 该消除被静态单赋值（SSA）形式所禁止，因为 SSA 表示法不允许移除保护解引用的条件语句。**\n这个陈述错误地将一个语义约束归因于中间表示（IR）的句法属性。静态单赋值（SSA）是 IR 的一个属性，它通过要求每个变量只被赋值一次来简化数据流分析。虽然编译器使用 SSA 来启用和简化各种优化，但 SSA 形式本身并不内在地“禁止”或“不允许”特定的转换。一个转换的正确性是由语言的语义决定的，而不是由 IR 的选择决定的。这个转换是不正确的，因为它违反了语义等价性，这一事实与程序是用 SSA 形式还是其他 IR 表示无关。\n**结论：错误**", "answer": "$$\\boxed{AC}$$", "id": "3659368"}, {"introduction": "循环是编译器优化的沃土，因为消除循环内的冗余指令能带来显著的性能提升。这个练习 [@problem_id:3659411] 聚焦于一种强大的技术，即利用在一个迭代中建立的事实（如指针变为非空）如何传递给后续迭代。通过分析此循环携带依赖，你将学会如何应用循环变形等技术来安全地移除冗余检查。", "problem": "考虑一种带指针和堆分配的一阶命令式语言，并假设编译器使用单一静态赋值（SSA）形式并构建控制流图（CFG）。一个指针变量 $p$ 初始时可能为 null，一个长度为 $n$ 的数组 $A$ 将在一个循环中被填充。该循环的写法如下：对于从 $0$ 到 $n-1$ 的每个迭代索引 $i$，循环体执行一次检查和可能的初始化，然后解引用 $p$：\n- 如果 $p$ 为 null，则赋值 `p := init()`，其中 `init()` 返回一个新分配的、非 null 的指针。\n- 从 $p$ 读取一个字段，并使用 $p$ 写入 $A[i]$。\n\n假设以下事实成立，这些事实在编译器正确性论证中被广泛使用：\n- 循环至少执行一次，即 $n \\ge 1$。\n- 函数 `init()` 返回一个非 null 指针，不抛出异常，并且除了分配一个新对象之外没有其他外部可见的副作用（没有会改变程序 I/O 或除创建对象之外的全局状态的可观察交互）。\n- 除了所描述的条件初始化外，循环体中没有任何地方对 $p$ 写入 null。没有其他别名会写入 $p$ 或可能导致 $p$ 变为 null 的内存。\n- 对 $p$ 的解引用操作要求 $p \\neq \\text{null}$ 才是安全的；只有当在所有到达解引用点的动态执行路径上，$p$ 都可被证明为非 null 时，移除 null 检查才是可靠的。\n\n在这些假设下，编译器旨在通过循环携带依赖来消除冗余的 null 检查：$p$ 在第一次迭代后（如果初始为 null）变为非 null，并在此后保持非 null。下列哪项源码到源码的转换相对于原始程序语义是可靠的，并允许在后续迭代中消除 null 检查？\n\nA. 将循环拆分为保留条件初始化和解引用的单个“预热”迭代，然后是针对剩余迭代的第二个循环，在第二个循环中移除了对 $p$ 的空检查，因为在所有后续迭代中 $p$ 都可被证明为非 null。\n\nB. 在没有任何保护性转换的情况下，为所有迭代移除循环内对 $p$ 的空检查；也就是说，假设在第一次迭代的解引用点 $p$ 是非 null 的。\n\nC. 在循环前置头中引入一个守卫：如果 $p$ 为 null，在进入循环前执行一次 `p := init()`；然后在循环内为所有迭代消除对 $p$ 的空检查，因为 $p$ 在循环头处现在是非 null 的。依赖 $n \\ge 1$ 来保持相对于第一次迭代的原始分配时机。\n\nD. 在循环前置头中无条件地赋值 `p := init()`（覆盖任何非 null 的 $p$），然后在循环内移除所有对 $p$ 的空检查。\n\n选择所有适用项。请基于 SSA、CFG 和循环的数据流属性，从上述定义和给定假设出发，提供你的推理，不要使用任何专门的快捷公式。所有变量和常量均指代此处定义的程序实体，$i$、$n$ 和数值界限应按其书面形式视为数学量。", "solution": "### 推导与选项分析\n\n首先，我们分析原始循环中指针 $p$ 的数据流属性。设 $p_i$ 表示在第 $i$ 次迭代开始时循环头处指针 $p$ 的值。设 $p'_i$ 表示在第 $i$ 次迭代内条件初始化块之后 $p$ 的值。\n\n第 $i$ 次迭代的循环体是：\n```\n// 在第 i 次迭代的循环头处，p 的值为 p_i\nif (p_i == null) {\n  p = init(); // 现在 p 是非 null 的\n} else {\n  // p 保持为 p_i，这是非 null 的\n}\n// p 现在是非 null 的。设此值为 p'_i。\n// ... 解引用 p ...\n// 迭代结束时 p 的值为 p'_i。\n// 这个值被带到下一次迭代：p_{i+1} = p'_i。\n```\n\n-   **迭代 $i=0$**：$p_0$ 是循环开始前 $p$ 的值，可能为 null 或非 null。\n    -   如果 $p_0$ 为 null，它将被赋值为 `init()` 的非 null 结果。\n    -   如果 $p_0$ 非 null，它将保持不变。\n    无论哪种情况，条件块之后 $p$ 的值 $p'_0$ 都保证为非 null。随后的解引用是安全的。\n\n-   **迭代 $i=1$**：本次迭代开始时 $p$ 的值 $p_1$，是上一次迭代结束时的值，即 $p'_0$。由于 $p'_0$ 可被证明为非 null，因此 $p_1$ 也可被证明为非 null。\n\n-   **归纳步骤**：假设对于某个 $k \\ge 1$，$p_k$ 是非 null 的。条件 `p_k == null` 将为 false。因此，$p$ 不会被重新赋值，其值保持为 $p_k$。条件块之后的值 $p'_k$ 等于 $p_k$，因此是非 null 的。传递给下一次迭代的值是 $p_{k+1} = p'_k$，它也是非 null 的。\n\n通过归纳法，对于所有迭代 $i \\ge 1$，指针 $p$ 在循环头处都可被证明为非 null。因此，null 检查 `if (p == null)` 对于除了第一次迭代（$i=0$）之外的所有迭代都是冗余的。转换的目标是消除这个冗余检查，同时保持程序语义。\n\n现在我们评估每个选项：\n\n**A. 将循环拆分为保留条件初始化和解引用的单个“预热”迭代，然后是针对剩余迭代的第二个循环，在第二个循环中移除了对 $p$ 的空检查，因为在所有后续迭代中 $p$ 都可被证明为非 null。**\n\n这种转换，称为循环剥离（loop peeling），将产生如下结构的代码：\n```\n// 迭代 i=0 (剥离)\nif (n >= 1) { // 这个检查是隐含的，因为只有当循环会运行时才会执行。\n  if (p == null) {\n    p = init();\n  }\n  // ... 解引用 p ...\n  A[0] = p.field;\n}\n\n// 针对剩余迭代 i=1 到 n-1 的循环\nfor (i = 1; i  n; i++) {\n  // 无需 null 检查，因为从第一次迭代开始 p 就可被证明为非 null。\n  // ... 解引用 p ...\n  A[i] = p.field;\n}\n```\n-   **可靠性**：此转换是可靠的。第一次迭代只执行一次（因为给定 $n \\ge 1$）并保持原始逻辑，确保 $p$ 在解引用前是非 null 的。在这次迭代之后，$p$ 保证为非 null。因此，覆盖迭代 $1$ 到 $n-1$ 的第二个循环可以安全地省略 null 检查。如果 $n=1$，第二个循环不执行，这是正确的。原始程序的语义被完美地保留了。\n-   **结论**：**正确**。\n\n**B. 在没有任何保护性转换的情况下，为所有迭代移除循环内对 $p$ 的空检查；也就是说，假设在第一次迭代的解引用点 $p$ 是非 null 的。**\n\n此转换导致：\n```\nfor (i = 0; i  n; i++) {\n  // 移除了 Null 检查\n  // ... 解引用 p ...\n  A[i] = p.field;\n}\n```\n-   **可靠性**：此转换是不可靠的。问题陈述明确允许 $p$ 初始为 null。如果循环开始前 $p$ 确实为 null，那么在第一次迭代（$i=0$）中，程序将尝试解引用一个 null 指针，导致运行时错误。这违反了安全性要求。\n-   **结论**：**不正确**。\n\n**C. 在循环前置头中引入一个守卫：如果 $p$ 为 null，在进入循环前执行一次 `p := init()`；然后在循环内为所有迭代消除对 $p$ 的空检查，因为 $p$ 在循环头处现在是非 null 的。依赖 $n \\ge 1$ 来保持相对于第一次迭代的原始分配时机。**\n\n这种转换，一种循环不变量代码外提（loop-invariant code motion）的形式，导致：\n```\n// 前置头\nif (p == null) {\n  p = init();\n}\n\n// 循环体\nfor (i = 0; i  n; i++) {\n  // 移除了 Null 检查\n  // ... 解引用 p ...\n  A[i] = p.field;\n}\n```\n-   **可靠性**：让我们分析一下语义。\n    1.  在前置头守卫之后，$p$ 在循环开始前保证为非 null。因此，在循环内移除 null 检查对所有迭代都是安全的。\n    2.  我们必须检查将初始化 `p := init()` 移出循环是否保留了原始语义。在原始程序中，如果 $p$ 为 null，`init()` 会在第一次迭代（$i=0$）期间、就在第一次解引用之前被调用。因为问题陈述了 $n \\ge 1$，我们知道循环体至少会执行一次，因此如果 $p$ 为 null，`init()` 将被调用。该转换将此调用从第一次迭代的*内部*移动到循环的*正前方*。问题指出 `init()` 除了分配之外没有其他外部可见的副作用。这意味着分配的精确时机（在第 0 次迭代之前 vs. 在第 0 次迭代期间）对程序的输出没有可观察的影响，因为从第 0 次迭代开始，分配的对象以相同的方式被使用。如果 $p$ 初始为非 null，则原始程序和转换后的程序都不会调用 `init()`。因此，在这两种情况下，程序的行为都得以保留。\n-   **结论**：**正确**。\n\n**D. 在循环前置头中无条件地赋值 `p := init()`（覆盖任何非 null 的 $p$），然后在循环内移除所有对 $p$ 的空检查。**\n\n此转换导致：\n```\n// 前置头\np = init(); // 无条件赋值\n\n// 循环体\nfor (i = 0; i  n; i++) {\n  // 移除了 Null 检查\n  // ... 解引用 p ...\n  A[i] = p.field;\n}\n```\n-   **可靠性**：此转换是不可靠的。考虑 $p$ 初始为非 null，指向一个特定的、已存在的对象的情况。原始程序将使用这个原始对象执行循环，因为 `if (p == null)` 检查将为 false。然而，转换后的程序无条件地用 `init()` 返回的新对象的指针覆盖 $p$。循环将在此新对象上操作。这改变了程序的基本行为，因为从 `p.field` 读取的数据将来自与原始程序中预期的不同对象。它还导致原始对象丢失（如果这是指向它的唯一指针，则会造成内存泄漏）。这违反了保留原始程序语义的要求。\n-   **结论**：**不正确**。", "answer": "$$\\boxed{AC}$$", "id": "3659411"}, {"introduction": "在理解了优化的基本原则后，是时候深入了解编译器如何自动实现这些分析。本练习 [@problem_id:3659400] 将带你扮演编译器的角色，手动执行一次数据流分析。你将使用 $\\\\text{MayNull}$ 和 $\\\\text{MustNonNull}$ 等抽象集合，在程序的控制流图上追踪指针属性，从而精确计算出哪些空指针检查可以被安全地消除。", "problem": "您将构建并应用一个流敏感、路径不敏感的数据流分析，用于消除空检查。该分析将使用两个抽象集合 $\\text{MayNull}$ 和 $\\text{MustNonNull}$，并在抽象解释和单调数据流框架的框架内进行。该分析必须从基本原理推导得出：通过抽象事实对具体执行的过近似来形式化其可靠性，并使用在合适格上的单调传递函数。假设每个语句具有单一赋值语义（无并发），给定变量之间存在精确的别名关系，并且对象分配总是返回一个非空引用。程序变量的全集为 $V = \\{x,y,z\\}$。在唯一入口点的初始抽象状态为 $\\text{MayNull} = \\emptyset$ 和 $\\text{MustNonNull} = \\emptyset$。\n\n考虑以下带有条件语句的顺序程序，它构成一个控制流图（除非采用分支，否则控制流将顺序执行，并且每个条件语句的两个分支在指定的结束点汇合）。此处，`new` 表示一次新的非空分配，`null` 表示空引用，`check(v)` 表示在解引用变量 $v$ 之前对其进行的运行时空检查。布尔值 $p$ 和 $q$ 是任意的，并且对于分析是未知的。\n\n($1$) `x := new`\n\n($2$) `y := null`\n\n($3$) `check(x)`\n\n($4$) `check(y)`\n\n($5$) if $(p)$ then\n\n($6$) $\\quad y := x$\n\n($7$) $\\quad \\texttt{check}(y)$\n\n($8$) else\n\n($9$) $\\quad x := null$\n\n($10$) $\\quad \\texttt{check}(x)$\n\n($11$) end-if\n\n($12$) `z := y`\n\n($13$) `check(z)`\n\n($14$) if $(q)$ then\n\n($15$) $\\quad x := new$\n\n($16$) end-if\n\n($17$) `check(x)`\n\n($18$) `y := new`\n\n($19$) `check(y)`\n\n($20$) `x := y`\n\n($21$) `check(x)`\n\n任务：\n- 根据“每个具体的空值行为都必须被抽象事实安全地过近似”这一可靠性要求，为语句 `x := new`、`x := null` 和 `x := y` 推导最小可靠传递函数（更新规则），并推导一个合并（join）操作符，用于在控制流汇合点合并抽象状态。您的推导必须从可靠过近似和单调性的形式化定义开始。\n- 将您推导出的规则应用于由行 ($1$)–($21$) 定义的控制流图，以计算每个 `check(·)` 位置之前的抽象状态。\n- 一个检查 `check(v)` 是可消除的，当且仅当在检查点紧邻之前的位置有 $v \\in \\text{MustNonNull}$。使用您计算出的抽象状态，确定在行 ($3$)、($4$)、($7$)、($10$)、($13$)、($17$)、($19$) 和 ($21$) 的检查中有多少是可消除的。\n\n答案格式：\n- 您的最终答案应为一个整数，等于可消除检查的总数。\n- 无需单位。", "solution": "### 1. 数据流分析的形式化\n\n该分析是流敏感和路径不敏感的。我们的目标是确定每个程序变量是否可能持有 `null` 值。\n\n#### 1.1. 抽象域和格\n程序在任何给定点的状态被抽象为一对集合 $(M_N, M_{NN})$，其中 $V = \\{x, y, z\\}$ 是所有程序变量的集合。\n- $M_N \\subseteq V$ 是**可能为空**的变量集合。如果存在至少一条到达当前程序点的路径，在该路径上变量 $v$ 可能被赋为 `null` 值，那么 $v$ 就在 $M_N$ 中。\n- $M_{NN} \\subseteq V$ 是**必须非空**的变量集合。如果在所有到达当前程序点的路径上，变量 $v$ 都被赋予了一个保证为非空的值，那么 $v$ 就在 $M_{NN}$ 中。\n\n一个一致的抽象状态 $(M_N, M_{NN})$ 必须满足 $M_N \\cap M_{NN} = \\emptyset$，因为一个变量不能同时“必须非空”和“可能为空”。\n\n所有抽象状态的集合构成一个格。偏序关系 $\\sqsubseteq$ 定义如下：\n$(M_{N1}, M_{NN1}) \\sqsubseteq (M_{N2}, M_{NN2})$ 当且仅当 $M_{N1} \\subseteq M_{N2}$ 且 $M_{NN1} \\supseteq M_{NN2}$。\n这个序关系捕捉了精度的概念。如果一个状态在格中“更高”（精度更低），意味着它在 `MayNull` 集合中包含更多变量，在 `MustNonNull` 集合中包含更少变量，表示更大的不确定性。\n- 代表最大不确定性的顶元素 $\\top$ 是 $(V, \\emptyset)$。\n- 程序入口处的分析初始状态给定为 $(\\emptyset, \\emptyset)$。\n\n#### 1.2. Join（合并）操作符\n在控制流的汇合点，我们必须合并所有输入路径的信息。设 $(M_{N1}, M_{NN1})$ 和 $(M_{N2}, M_{NN2})$ 是来自两条输入控制流路径的抽象状态。结果状态 $(M_N, M_{NN})$ 必须是两者的可靠过近似。这通过计算两个状态的最小上界（join）来实现，记为 $\\sqcup$。\n\n$$(M_N, M_{NN}) = (M_{N1}, M_{NN1}) \\sqcup (M_{N2}, M_{NN2})$$\n\n- 对于 `MayNull` 集合：如果在*任何*一条输入路径上一个变量可能为空，那么在合并后它也可能为空。为保持可靠性，我们取并集：$M_N = M_{N1} \\cup M_{N2}$。\n- 对于 `MustNonNull` 集合：只有当一个变量在*所有*输入路径上都必须非空时，它在合并后才必须非空。为保持可靠性，我们取交集：$M_{NN} = M_{NN1} \\cap M_{NN2}$。\n\n因此，join 操作符为：\n$$(M_{N1}, M_{NN1}) \\sqcup (M_{N2}, M_{NN2}) = (M_{N1} \\cup M_{N2}, M_{NN1} \\cap M_{NN2})$$\n\n#### 1.3. 传递函数\n传递函数 $F_s$ 将语句 $s$ 之前的抽象状态 $(M_N^{in}, M_{NN}^{in})$ 映射到其后的抽象状态 $(M_N^{out}, M_{NN}^{out})$。这些函数必须相对于格序 $\\sqsubseteq$ 是可靠且单调的。设输入状态为 $(M_N, M_{NN})$。\n\n**1. 语句: `v := new`**\n- 具体语义：变量 $v$ 被赋予一个新的非空值。\n- 可靠性：赋值后，$v$ 必须非空。因此，$v$ 必须在新的 `MustNonNull` 集合中，且不能在新的 `MayNull` 集合中。其他变量的状态保持不变。\n- 推导：\n  - $M_N^{out} = M_N \\setminus \\{v\\}$\n  - $M_{NN}^{out} = M_{NN} \\cup \\{v\\}$\n\n**2. 语句: `v := null`**\n- 具体语义：变量 $v$ 被赋予 `null` 值。\n- 可靠性：赋值后，$v$ 绝对是 null，因此它“可能为空”。它不能再是“必须非空”。\n- 推导：\n  - $M_N^{out} = M_N \\cup \\{v\\}$\n  - $M_{NN}^{out} = M_{NN} \\setminus \\{v\\}$\n\n**3. 语句: `v1 := v2`**\n- 具体语义：变量 $v_1$ 被赋予变量 $v_2$ 的值。\n- 可靠性：变量 $v_1$ 的新属性必须是变量 $v_2$ 属性的可靠近似。 $v_1$ 的旧属性被“杀死”。\n- 推导：\n  - 我们首先移除关于 $v_1$ 的任何现有信息：$M_{N,temp} = M_N \\setminus \\{v_1\\}$, $M_{NN,temp} = M_{NN} \\setminus \\{v_1\\}$。\n  - 如果 $v_2$ 可能为空（即 $v_2 \\in M_N$），那么 $v_1$ 现在也可能为空：$M_N^{out} = M_{N,temp} \\cup (\\{v_1\\} \\text{ if } v_2 \\in M_N \\text{ else } \\emptyset)$。\n  - 如果 $v_2$ 必须非空（即 $v_2 \\in M_{NN}$），那么 $v_1$ 现在也必须非空：$M_{NN}^{out} = M_{NN,temp} \\cup (\\{v_1\\} \\text{ if } v_2 \\in M_{NN} \\text{ else } \\emptyset)$。\n\n**4. 语句: `check(v)`**\n这个语句不改变程序状态。它是一个断言。其传递函数是恒等函数：$F_{\\texttt{check}(v)}(M_N, M_{NN}) = (M_N, M_{NN})$。该检查是可消除的，当且仅当 $v \\in M_{NN}^{in}$。\n\n### 2. 程序的数据流分析\n我们计算每行代码入口处的抽象状态 $(M_N, M_{NN})$。在第 ($1$) 行的初始状态是 $(\\emptyset, \\emptyset)$。\n\n- **第 ($1$) 行之前：** $(\\emptyset, \\emptyset)$\n- ($1$) `x := new`。输出状态：$(\\emptyset \\setminus \\{x\\}, \\emptyset \\cup \\{x\\}) = (\\emptyset, \\{x\\})$。\n- **第 ($2$) 行之前：** $(\\emptyset, \\{x\\})$\n- ($2$) `y := null`。输出状态：$(\\emptyset \\cup \\{y\\}, \\{x\\} \\setminus \\{y\\}) = (\\{y\\}, \\{x\\})$。\n- **第 ($3$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($3$) `check(x)`。$x \\in M_{NN}$ 吗？是的，$x \\in \\{x\\}$。**第 ($3$) 行的检查是可消除的。** 输出状态：$(\\{y\\}, \\{x\\})$。\n- **第 ($4$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($4$) `check(y)`。$y \\in M_{NN}$ 吗？不是，$y \\notin \\{x\\}$。检查不可消除。输出状态：$(\\{y\\}, \\{x\\})$。\n- **第 ($5$) 行之前：** $(\\{y\\}, \\{x\\})$\n- ($5$) `if (p) then`。状态 $(\\{y\\}, \\{x\\})$ 传播到两个分支。\n  - **`then` 分支 (第 $6-7$ 行):**\n    - **第 ($6$) 行之前：** $(\\{y\\}, \\{x\\})$\n    - ($6$) `y := x`。$x$ 的属性：$x \\notin M_N, x \\in M_{NN}$。$y$ 的新属性：$y \\notin M_N, y \\in M_{NN}$。输出状态：$(\\emptyset, \\{x, y\\})$。\n    - **第 ($7$) 行之前：** $(\\emptyset, \\{x, y\\})$\n    - ($7$) `check(y)`。$y \\in M_{NN}$ 吗？是的，$y \\in \\{x, y\\}$。**第 ($7$) 行的检查是可消除的。** 输出状态：$(\\emptyset, \\{x, y\\})$。\n    - **`then` 分支末尾的状态：** $S_{then} = (\\emptyset, \\{x, y\\})$。\n  - **`else` 分支 (第 $9-10$ 行):**\n    - **第 ($9$) 行之前：** $(\\{y\\}, \\{x\\})$\n    - ($9$) `x := null`。输出状态：$(\\{y\\} \\cup \\{x\\}, \\{x\\} \\setminus \\{x\\}) = (\\{x, y\\}, \\emptyset)$。\n    - **第 ($10$) 行之前：** $(\\{x, y\\}, \\emptyset)$\n    - ($10$) `check(x)`。$x \\in M_{NN}$ 吗？不是，$x \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y\\}, \\emptyset)$。\n    - **`else` 分支末尾的状态：** $S_{else} = (\\{x, y\\}, \\emptyset)$。\n- **第 ($12$) 行之前：** 第 ($11$) 行 `if` 语句后的汇合点。我们计算 $S_{then} \\sqcup S_{else}$。\n  - $(\\emptyset, \\{x, y\\}) \\sqcup (\\{x, y\\}, \\emptyset) = (\\emptyset \\cup \\{x, y\\}, \\{x, y\\} \\cap \\emptyset) = (\\{x, y\\}, \\emptyset)$。\n- ($12$) `z := y`。$y$ 的属性：$y \\in M_N, y \\notin M_{NN}$。$z$ 的新属性：$z \\in M_N, z \\notin M_{NN}$。输出状态：$(\\{x, y\\} \\cup \\{z\\}, \\emptyset) = (\\{x, y, z\\}, \\emptyset)$。\n- **第 ($13$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($13$) `check(z)`。$z \\in M_{NN}$ 吗？不是，$z \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y, z\\}, \\emptyset)$。\n- **第 ($14$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($14$) `if (q) then`。状态 $(\\{x, y, z\\}, \\emptyset)$ 传播到 `then` 分支（第 $15$ 行）和顺序执行路径。\n  - **`then` 分支 (第 $15$ 行):**\n    - **第 ($15$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n    - ($15$) `x := new`。输出状态：$(\\{x, y, z\\} \\setminus \\{x\\}, \\emptyset \\cup \\{x\\}) = (\\{y, z\\}, \\{x\\})$。\n    - **`then` 分支末尾的状态：** $S_{then2} = (\\{y, z\\}, \\{x\\})$。\n  - **顺序执行路径：** 状态不变。$S_{skip} = (\\{x, y, z\\}, \\emptyset)$。\n- **第 ($17$) 行之前：** 第 ($16$) 行 `if` 语句后的汇合点。我们计算 $S_{then2} \\sqcup S_{skip}$。\n  - $(\\{y, z\\}, \\{x\\}) \\sqcup (\\{x, y, z\\}, \\emptyset) = (\\{y, z\\} \\cup \\{x, y, z\\}, \\{x\\} \\cap \\emptyset) = (\\{x, y, z\\}, \\emptyset)$。\n- ($17$) `check(x)`。$x \\in M_{NN}$ 吗？不是，$x \\notin \\emptyset$。检查不可消除。输出状态：$(\\{x, y, z\\}, \\emptyset)$。\n- **第 ($18$) 行之前：** $(\\{x, y, z\\}, \\emptyset)$\n- ($18$) `y := new`。输出状态：$(\\{x, y, z\\} \\setminus \\{y\\}, \\emptyset \\cup \\{y\\}) = (\\{x, z\\}, \\{y\\})$。\n- **第 ($19$) 行之前：** $(\\{x, z\\}, \\{y\\})$\n- ($19$) `check(y)`。$y \\in M_{NN}$ 吗？是的，$y \\in \\{y\\}$。**第 ($19$) 行的检查是可消除的。** 输出状态：$(\\{x, z\\}, \\{y\\})$。\n- **第 ($20$) 行之前：** $(\\{x, z\\}, \\{y\\})$\n- ($20$) `x := y`。$y$ 的属性：$y \\notin M_N, y \\in M_{NN}$。$x$ 的新属性：$x \\notin M_N, x \\in M_{NN}$。输出状态：$(\\{z\\}, \\{y\\} \\cup \\{x\\}) = (\\{z\\}, \\{x, y\\})$。\n- **第 ($21$) 行之前：** $(\\{z\\}, \\{x, y\\})$\n- ($21$) `check(x)`。$x \\in M_{NN}$ 吗？是的，$x \\in \\{x, y\\}$。**第 ($21$) 行的检查是可消除的。**\n\n### 3. 结论\n此分析识别出可消除的空检查位于以下几行：\n- 第 ($3$) 行: `check(x)`\n- 第 ($7$) 行: `check(y)`\n- 第 ($19$) 行: `check(y)`\n- 第 ($21$) 行: `check(x)`\n\n可消除检查的总数为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3659400"}]}