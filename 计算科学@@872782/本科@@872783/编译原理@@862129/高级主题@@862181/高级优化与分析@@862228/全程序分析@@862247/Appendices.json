{"hands_on_practices": [{"introduction": "我们常常倾向于独立地分析每个函数，但这可能导致严重的错误。本练习将通过一个具体的例子揭示这一陷阱。我们将看到，在常见的“引用传递”参数机制下，一个看似安全的常量传播优化会因为跨函数调用的隐藏副作用（别名）而变得不再安全，从而凸显了全程序分析的必要性 [@problem_id:3661376]。", "problem": "考虑一个针对支持赋值和函数调用的简单语言的过程间常量传播分析。每个变量的分析域是常量格 $$\\mathcal{D} = \\mathbb{Z} \\cup \\{\\top, \\bot\\},$$ 其中 $\\bot$ 表示一个未初始化的值，任何 $n \\in \\mathbb{Z}$ 表示常量值 $n$，而 $\\top$ 表示一个未知的非常量值。偏序定义为 $$\\bot \\leq n \\leq \\top \\text{ for all } n \\in \\mathbb{Z},$$ 并且交（meet）运算符 $\\wedge$ 满足 $$n \\wedge m = \\begin{cases} n  \\text{if } n=m, \\\\ \\top  \\text{if } n \\neq m, \\end{cases} \\quad n \\wedge \\bot = \\bot, \\quad n \\wedge \\top = n, \\quad \\top \\wedge \\top = \\top, \\quad \\bot \\wedge \\top = \\bot.$$\n\n假设函数通过引用传递调用：当调用者中的变量 $a$ 作为实参传递给被调用者的形参 $c$ 时，被调用者中对 $c$ 的所有写入都会更新调用者中的 $a$。\n\n给定以下程序，其中包含一个函数和一个调用者。所有算术运算都在整数 $\\mathbb{Z}$ 上进行。\n\n函数体：\n- $f(c):$ \n  - $c := c + 2$\n\n调用者体：\n- $x := 5$\n- $f(x)$\n- $y := x + 3$\n\n从上述核心定义（常量格和引用传递的语义）出发，请完成以下任务：\n- 解释为什么一个朴素的过程内常量传播分析（在调用点将 $x$ 标记为常量 $5$，并认为对 $f$ 的调用不影响 $x$）在引用传递的语义下是不安全的。\n- 当被调用者可能写入形参 $c$ 且 $c$ 通过引用传递成为调用者变量的别名时，为调用点推导一个针对形参 $c$ 的保守过程间转换规则，以确保分析的稳健性（soundness）。你的规则必须用应用于实参抽象值的抽象转换器来表述，并且必须指明当被调用者的效果无法精确总结时该如何处理。\n\n然后，使用你推导出的安全规则，计算在赋值语句 $y := x + 3$ 之后的程序点上，$y$ 的常量传播值。你的最终答案必须是一个实数值，无需四舍五入。", "solution": "该问题需要一个包含三部分的答案：解释朴素分析的不安全性，推导一个安全的过程间规则，以及应用该规则来找到变量 $y$ 的值。\n\n**第一部分：不安全的朴素过程内分析**\n\n过程内分析独立地考虑每个函数。对`caller`体的朴素过程内常量传播分析会对 $f(x)$ 的调用做出一个过于简化的假设。具体来说，它会假设函数调用对其参数没有在调用者中可见的副作用。这个假设对于值传递是有效的，但对于引用传递是根本错误的。\n\n让我们用这个朴素的假设来追踪分析过程。设 $\\sigma$ 为抽象状态，它将程序变量映射到格 $\\mathcal{D}$ 中的值。\n1.  **初始状态：** 在任何语句执行之前，所有变量都是未初始化的：$\\sigma_0 = \\{x \\mapsto \\bot, y \\mapsto \\bot\\}$。\n2.  **在 `x := 5` 之后：** 变量 $x$ 被赋予常量值 $5$。抽象状态变为 $\\sigma_1 = \\{x \\mapsto 5, y \\mapsto \\bot\\}$。\n3.  **在 `f(x)` 处：** 朴素分析忽略了引用传递效应的可能性，假设 $x$ 的值在调用前后保持不变。调用后的状态被假定与调用前相同：$\\sigma_2 = \\sigma_1 = \\{x \\mapsto 5, y \\mapsto \\bot\\}$。\n4.  **在 `y := x + 3` 之后：** 分析使用 $x$ 当前的抽象值 $5$ 来计算右侧表达式。抽象加法 $5 \\hat{+} 3$ 的结果是 $8$。这个值被赋给 $y$。最终状态是 $\\sigma_3 = \\{x \\mapsto 5, y \\mapsto 8\\}$。\n\n该分析得出结论，$y$ 的常量值为 $8$。\n\n现在，考虑程序的实际具体执行过程：\n1.  `x := 5`：整型变量 $x$ 持有值 $5$。\n2.  `f(x)`：以 $x$ 为参数调用函数 $f$。由于机制是引用传递， $f$ 内部的形参 $c$ 成为变量 $x$ 的一个别名。\n3.  在 $f$ 内部，语句 `c := c + 2` 被执行。因为 $c$ 是 $x$ 的别名，这个操作等价于 `x := x + 2`。调用者作用域中 $x$ 的值从 $5$ 更新为 $5 + 2 = 7$。\n4.  在 $f$ 返回后，$x$ 的值是 $7$。\n5.  `y := x + 3`：使用 $x$ 的值 $7$。表达式 $7 + 3$ 计算结果为 $10$，该值被赋给 $y$。\n\n具体执行的结果是 $y=10$，而朴素分析预测的是 $y=8$。因此，该分析是**不安全的**。一个稳健（或安全）的分析必须过近似（over-approximate）所有可能的运行时行为。当一个变量的实际值是 $10$ 时，声称它是常量 $8$ 并不是过近似，而是一个精确但错误的陈述。这可能导致错误的优化，例如将 $y$ 的使用替换为常量 $8$，从而导致程序行为错误。\n\n**第二部分：推导一个安全的过程间规则**\n\n为确保稳健性，分析必须考虑函数调用对通过引用传递的参数的副作用。这需要一种过程间方法，其中关于被调用者行为的信息被用来更新调用者的状态。\n\n假设在一个函数调用点，调用者的一个实参 $a$ 通过引用传递给被调用者的一个形参 $c$。设 $v_a \\in \\mathcal{D}$ 是调用前 $a$ 的抽象值。分析需要一个规则来计算 $v'_a$，即函数调用返回后 $a$ 的抽象值。\n\n被调用者对其形参 $c$ 的影响可以用一个抽象转换器 $T_c: \\mathcal{D} \\to \\mathcal{D}$ 来总结。这个转换器 $T_c$ 将函数入口处 $c$ 的抽象值映射到函数出口处它的抽象值。由于 $a$ 和 $c$ 是别名关系，应用于 $c$ 的转换实际上也应用于 $a$。\n\n因此，更新后的值 $v'_a$ 是通过将转换器应用于调用前的值 $v_a$ 得到的：\n$$v'_a = T_c(v_a)$$\n\n对于给定的函数 $f(c): c := c + 2$，我们可以确定其转换器。该操作是与一个常量的加法。我们为我们的格 $\\mathcal{D}$ 定义一个抽象加法运算符 $\\hat{+}$：\n- 对于 $n, m \\in \\mathbb{Z}$，$n \\hat{+} m = n + m$。\n- 对于任何 $v \\in \\mathcal{D}$，$v \\hat{+} \\top = \\top$ 且 $\\top \\hat{+} v = \\top$。\n- 对于任何 $v \\in \\mathcal{D}$，$v \\hat{+} \\bot = \\bot$ 且 $\\bot \\hat{+} v = \\bot$。\n\n因此，函数 $f$ 关于其参数 $c$ 的转换器，记为 $T_{f,c}$，是：\n$$T_{f,c}(v) = v \\hat{+} 2$$\n\n然而，并非总能推导出如此精确的转换器。函数体可能过于复杂（例如，涉及数据依赖迭代次数的循环，或调用其他未知函数），或者其源代码可能不可用。在这种情况下，必须做出**保守**的假设以确保稳健性。\n\n如果无法精确确定被调用者对引用参数的影响，最安全的假设是该参数在调用后的值是未知的。在我们的格中，代表“未知”或“不是一个常量”的值是 $\\top$。\n\n这导出了以下针对通过引用传递给形参 $c$ 的变量 $a$ 的完整、安全的过程间转换规则：\n设 $v_a$ 是调用前 $a$ 的抽象值。调用后 $a$ 的抽象值 $v'_a$ 是：\n$$ v'_a = \\begin{cases} T_{c}(v_a)  \\text{如果被调用者对 } c \\text{ 的影响的转换器 } T_c \\text{ 可以被精确确定} \\\\ \\top  \\text{否则} \\end{cases} $$\n这个规则保证了分析绝不会在一个变量可能已被修改为不同或未知值时，声称它是一个常量。\n\n**第三部分：应用安全规则**\n\n我们现在使用推导出的安全规则重新分析调用者体。\n1.  **初始状态：** $\\sigma_0 = \\{x \\mapsto \\bot, y \\mapsto \\bot\\}$。\n2.  **在 `x := 5` 之后：** 赋值使 $x$ 的抽象值为 $5$。状态为 $\\sigma_1 = \\{x \\mapsto 5, y \\mapsto \\bot\\}$。\n3.  **在 `f(x)` 处：** 我们应用安全的过程间规则。\n    - 实参是 $x$，调用前的抽象值为 $v_x = 5$。\n    - 被调用者是 $f(c): c := c + 2$。如第二部分所推导， $f$ 对其引用参数 $c$ 的影响是已知的，并由转换器 $T_{f,c}(v) = v \\hat{+} 2$ 表示。\n    - 我们将转换器应用于 $x$ 的抽象值：\n      $$v'_x = T_{f,c}(v_x) = v_x \\hat{+} 2 = 5 \\hat{+} 2 = 7$$\n    - 调用返回后，$x$ 的抽象值更新为 $7$。新状态为 $\\sigma_2 = \\{x \\mapsto 7, y \\mapsto \\bot\\}$。\n4.  **在 `y := x + 3` 之后：** 分析使用 $x$ 当前的抽象值 $7$ 来计算右侧表达式。\n    - 要计算的抽象表达式是 $x \\hat{+} 3$。\n    - 代入 $x$ 的值：$7 \\hat{+} 3 = 10$。\n    - 这个常量值 $10$ 被赋给 $y$。最终的抽象状态是 $\\sigma_3 = \\{x \\mapsto 7, y \\mapsto 10\\}$。\n\n使用稳健的过程间规则，分析正确地确定了在指定程序点 $y$ 的值是常量 $10$。这与具体执行的结果相匹配，证明了所推导规则在此示例中的安全性和精确性。最终计算出的 $y$ 的值为 $10$。", "answer": "$$\\boxed{10}$$", "id": "3661376"}, {"introduction": "既然我们已经认识到跨过程分析的必要性，那么该如何构建一个呢？本练习将指导你实践一种基础技术：使用区间抽象域的抽象解释。通过为每个函数创建其行为的“摘要”，我们将能够安全地在整个程序范围内执行常量折叠，精确地推导出变量的取值范围 [@problem_id:3682735]。", "problem": "考虑一个编译器原理中的简单的全程序分析任务，其目标是使用范围摘要对算术表达式执行过程间常量折叠。该程序由四个过程和一个主过程组成，其操作语义通过整数上的赋值语句编写如下：\n\n- 过程 $f$ 接受一个整数参数 $a$ 并执行：\n  $r_1 \\leftarrow a + a$，$r_2 \\leftarrow r_1 + 3$，并返回 $r_2$。\n- 过程 $g$ 接受一个整数参数 $b$ 并执行：\n  $t \\leftarrow b + 2$，$u \\leftarrow t + b$，并返回 $u + 1$。\n- 过程 $h$ 不接受参数并返回 $0$。\n- 过程 $k$ 不接受参数并返回 $1$。\n- 主过程执行：\n  $x \\leftarrow f(h())$，$y \\leftarrow g(k())$，并返回 $x + y$。\n\n你的任务是使用抽象解释来构建一个过程间范围分析，以实现常量折叠。从抽象解释的核心定义和区间抽象域开始，将具体语义映射到抽象转换函数，为过程 $f$、$g$、$h$ 和 $k$ 推导出可靠的范围摘要，然后在主过程的调用中组合这些摘要，以获得 $x$、$y$ 以及最终 $x + y$ 的抽象值。\n\n假设区间抽象域由所有闭合整数区间 $[l,u]$ 组成，其中 $l \\leq u$，按其具体化上的子集关系排序，并且算术运算是标准的整数算术。仅使用来自具体语义的可靠推理来推导每个抽象转换函数；不要假设任何预先给定的快捷公式。明确说明为什么组合分析会为 $x$ 和 $y$ 产生单元区间，并解释为什么这足以进行常量折叠。\n\n在这种过程间范围分析下，主过程中的表达式 $x + y$ 可以折叠为哪个常量值？请用一个精确的整数表示你的最终答案，无需四舍五入。", "solution": "该问题要求基于抽象解释进行过程间范围分析。我们首先定义抽象解释框架的各个组成部分。\n\n抽象域是闭合整数区间的集合，记为 $\\mathcal{D} = \\{ [l, u] \\mid l, u \\in \\mathbb{Z}, l \\leq u \\} \\cup \\{ \\bot \\}$，其中 $\\mathbb{Z}$ 是整数集合，$\\bot$ 表示不可达状态。具体化函数 $\\gamma: \\mathcal{D} \\to \\mathcal{P}(\\mathbb{Z})$ 将一个抽象值映射到它所代表的具体整数值集合：\n$\\gamma([l, u]) = \\{ z \\in \\mathbb{Z} \\mid l \\leq z \\leq u \\}$\n$\\gamma(\\bot) = \\emptyset$\n\n我们必须为程序中的操作定义抽象转换函数。唯一的算术运算是加法。对于两个抽象值为 $[l_1, u_1]$ 和 $[l_2, u_2]$ 的变量，它们的和 $v_1 + v_2$ 可以取任何具体值 $z = z_1 + z_2$，其中 $z_1 \\in \\gamma([l_1, u_1])$ 且 $z_2 \\in \\gamma([l_2, u_2])$。$z$ 的最小可能值为 $l_1 + l_2$，最大值为 $u_1 + u_2$。因此，加法的可靠抽象转换函数（记为 $\\oplus$）是：\n$$[l_1, u_1] \\oplus [l_2, u_2] = [l_1 + l_2, u_1 + u_2]$$\n常量被表示为单元区间。例如，常量 $c$ 被表示为抽象值 $[c, c]$。\n\n接下来，我们为每个过程推导范围摘要。摘要是一个函数，它将输入参数的抽象值映射到返回结果的抽象值。\n\n**过程 $h()$**：\n该过程不接受参数并返回常量 $0$。\n具体返回值为集合 $\\{0\\}$。\n包含此集合的最精确的抽象值是区间 $[0, 0]$。\n因此，$h$ 的摘要是 $S_h() = [0, 0]$。\n\n**过程 $k()$**：\n该过程不接受参数并返回常量 $1$。\n具体返回值为集合 $\\{1\\}$。\n最精确的抽象值是区间 $[1, 1]$。\n因此，$k$ 的摘要是 $S_k() = [1, 1]$。\n\n**过程 $f(a)$**：\n该过程接受一个整数参数 $a$。设 $a$ 的抽象值为 $[l_a, u_a]$。\n1.  第一个语句是 $r_1 \\leftarrow a + a$。$r_1$ 的抽象值计算为 $[l_a, u_a] \\oplus [l_a, u_a] = [l_a + l_a, u_a + u_a] = [2l_a, 2u_a]$。\n2.  第二个语句是 $r_2 \\leftarrow r_1 + 3$。常量 $3$ 的抽象值为 $[3, 3]$。$r_2$ 的抽象值计算为 $[2l_a, 2u_a] \\oplus [3, 3] = [2l_a + 3, 2u_a + 3]$。\n3.  该过程返回 $r_2$。\n$f$ 的摘要是输入抽象状态的函数：$S_f([l_a, u_a]) = [2l_a + 3, 2u_a + 3]$。\n\n**过程 $g(b)$**：\n该过程接受一个整数参数 $b$。设 $b$ 的抽象值为 $[l_b, u_b]$。\n1.  第一个语句：$t \\leftarrow b + 2$。$2$ 的抽象值为 $[2, 2]$。$t$ 的抽象值为 $[l_b, u_b] \\oplus [2, 2] = [l_b + 2, u_b + 2]$。\n2.  第二个语句：$u \\leftarrow t + b$。$u$ 的抽象值为 $[l_b + 2, u_b + 2] \\oplus [l_b, u_b] = [(l_b + 2) + l_b, (u_b + 2) + u_b] = [2l_b + 2, 2u_b + 2]$。\n3.  该过程返回 $u + 1$。$1$ 的抽象值为 $[1, 1]$。抽象返回值为 $[2l_b + 2, 2u_b + 2] \\oplus [1, 1] = [2l_b + 3, 2u_b + 3]$。\n$g$ 的摘要是输入抽象状态的函数：$S_g([l_b, u_b]) = [2l_b + 3, 2u_b + 3]$。\n\n现在，我们使用这些摘要来分析 `main` 过程，以确定 $x$ 和 $y$ 的抽象值。\n\n**$x \\leftarrow f(h())$ 的分析**：\n1.  $f$ 的参数是调用 $h()$ 的结果。我们使用 $h$ 的摘要来找到其抽象返回值：$S_h() = [0, 0]$。\n2.  这个抽象值 $[0, 0]$ 成为分析 $f$ 的输入。我们将 $f$ 的摘要应用于参数 $a$ 的输入抽象值 $[0, 0]$。因此，我们设置 $l_a = 0$ 和 $u_a = 0$。\n3.  $x$ 的抽象值为 $S_f([0, 0]) = [2(0) + 3, 2(0) + 3] = [3, 3]$。\n$x$ 的抽象值是单元区间 $[3, 3]$。\n\n**$y \\leftarrow g(k())$ 的分析**：\n1.  $g$ 的参数是调用 $k()$ 的结果。我们使用 $k$ 的摘要：$S_k() = [1, 1]$。\n2.  这个抽象值 $[1, 1]$ 成为分析 $g$ 的输入。我们将 $g$ 的摘要应用于参数 $b$ 的输入抽象值 $[1, 1]$。因此，我们设置 $l_b = 1$ 和 $u_b = 1$。\n3.  $y$ 的抽象值为 $S_g([1, 1]) = [2(1) + 3, 2(1) + 3] = [2 + 3, 2 + 3] = [5, 5]$。\n$y$ 的抽象值是单元区间 $[5, 5]$。\n\n**最终返回值**：\n主过程返回表达式 $x + y$ 的值。我们使用我们为 $x$ 和 $y$ 找到的抽象值来计算这个和的抽象值。\n$x+y$ 的抽象值是 $[3, 3] \\oplus [5, 5] = [3 + 5, 3 + 5] = [8, 8]$。\n\n分析得出结论，表达式 $x + y$ 的计算结果为抽象值 $[8, 8]$。单元区间 $[c, c]$ 表示变量或表达式只能持有唯一的具体值 $c$。在这种情况下，$x$ 总是 $3$，$y$ 总是 $5$，它们的和 $x+y$ 总是 $8$。这允许编译器执行常量折叠，将整个表达式 $x+y$ 替换为常量整数 $8$。\n\n因此，表达式 $x+y$ 可以被折叠的常量值为 $8$。", "answer": "$$\\boxed{8}$$", "id": "3682735"}, {"introduction": "全程序分析的应用远不止于优化。本练习将介绍一种强大的反向分析技术——程序切片。通过从程序的某个特定输出点出发，反向追踪所有相关的数据和控制依赖，我们可以自动“切”出对该输出有影响的代码子集，这对于调试和代码理解具有不可估量的价值 [@problem_id:3682778]。", "problem": "考虑一个包含全局变量和四个函数的小型过程式程序。切片标准是函数 $main$ 返回的输出值。要求您在全程序分析下执行后向切片，移除不相关的函数和全局变量。假设所有函数都会终止，没有异常，且所有调用都是严格的（即被调用者在调用者继续执行前完全执行完毕）。使用标准的过程间切片语义：当且仅当一条语句与切片标准存在数据依赖或控制依赖时，该语句才被保留在切片中。如果一条语句定义了一个被切片中另一条语句后续使用的值，则存在数据依赖；如果一条语句的结果决定了切片中另一条语句是否执行，则存在控制依赖。将以下每一行视为一个单独的源代码级语句。一条语句可以是以下之一：全局初始化（赋值）、函数局部赋值（包括算术运算）、出现在赋值右侧的函数调用、条件测试（“if”谓词本身）或返回语句。不要将“else”标签计为单独的语句。\n\n全局变量（每行为一条独立语句）：\n- $G1$: $A := 5$\n- $G2$: $B := 10$\n- $G3$: $C := 0$\n- $G4$: $D := 7$\n\n函数 $square(x)$:\n- $S1$: $r := x \\times x$\n- $S2$: $C := C + 1$\n- $S3$: return $r$\n\n函数 $noise(y)$:\n- $N1$: $B := B + y$\n- $N2$: return $B$\n\n函数 $choose(p)$:\n- $H1$: if $p  0$\n- $H2$: return $p$  （then 分支）\n- $H3$: return $D$  （else 分支）\n\n函数 $unusedGlobalFun()$:\n- $U1$: $A := A + B$\n- $U2$: return $A$\n\n函数 $main()$:\n- $M1$: $t1 := square(A)$\n- $M2$: $t2 := choose(t1 - B)$\n- $M3$: if $(t2 \\bmod 2 = 0)$\n- $M4$: $z := square(t2)$\n- $M5$: return $z - D$  （then 分支）\n- $M7$: $noise(t2)$      （else 分支）\n- $M8$: return $t2 + A$  （else 分支）\n\n针对 $main$ 的输出（即 $main$ 返回的值）执行全程序后向切片。从切片中移除任何与此切片标准没有数据或控制依赖关系的无关函数和全局初始化。计算移除后后向切片中剩余的语句数量。以精确整数形式给出最终答案。无需四舍五入，也无需单位。", "solution": "后向切片分析过程如下，切片标准是 `main` 函数的所有返回语句。\n\n**1. 确定切片标准和初始集合**\n切片标准是 `main` 函数的两个返回语句：`M5` 和 `M8`。\n初始切片集合 `S = {M5, M8}`。\n\n**2. 迭代追溯依赖关系**\n\n*   **第1轮迭代：分析 `M5` 和 `M8` 的依赖**\n    *   **从 `M5: return z - D` 开始：**\n        *   数据依赖于变量 `z` 和 `D`。\n            *   `z` 由 `M4: z := square(t2)` 定义。将 `M4` 添加到 `S`。\n            *   `D` 由 `G4: D := 7` 定义。将 `G4` 添加到 `S`。\n        *   控制依赖于 `M3: if (t2 mod 2 = 0)`。将 `M3` 添加到 `S`。\n    *   **从 `M8: return t2 + A` 开始：**\n        *   数据依赖于变量 `t2` 和 `A`。\n            *   `t2` 由 `M2: t2 := choose(t1 - B)` 定义。将 `M2` 添加到 `S`。\n            *   `A` 由 `G1: A := 5` 定义。将 `G1` 添加到 `S`。\n        *   控制依赖于 `M3`。`M3` 已在 `S` 中。\n    *   **迭代后 `S` = `{M2, M3, M4, M5, M8, G1, G4}`。**\n\n*   **第2轮迭代：分析新加入语句的依赖**\n    *   **`M4: z := square(t2)`:**\n        *   数据依赖于 `t2`（由 `M2` 定义，已在 `S` 中）和 `square` 函数的返回值。\n        *   **切片 `square` 函数：** 切片标准是其返回语句 `S3: return r`。\n            *   将 `S3` 添加到 `S`。`S3` 数据依赖于 `r`。\n            *   `r` 由 `S1: r := x * x` 定义。将 `S1` 添加到 `S`。`S1` 依赖于参数 `x`。\n            *   `S2: C := C + 1` 不影响返回值 `r`，因此 `S2` 不在切片中。\n    *   **`M3: if (t2 mod 2 = 0)`:**\n        *   数据依赖于 `t2`（由 `M2` 定义，已在 `S` 中）。无新语句。\n    *   **`M2: t2 := choose(t1 - B)`:**\n        *   数据依赖于 `t1`、`B` 和 `choose` 函数的返回值。\n        *   `t1` 由 `M1: t1 := square(A)` 定义。将 `M1` 添加到 `S`。\n        *   `B` 由 `G2: B := 10` 定义。将 `G2` 添加到 `S`。\n        *   **切片 `choose` 函数：** 切片标准是其返回语句 `H2` 和 `H3`。\n            *   将 `H2` 和 `H3` 添加到 `S`。\n            *   `H2` 和 `H3` 都控制依赖于 `H1: if p > 0`。将 `H1` 添加到 `S`。\n            *   `H1` 和 `H2` 数据依赖于参数 `p`。\n            *   `H3` 数据依赖于全局变量 `D`（由 `G4` 定义，已在 `S` 中）。\n    *   **迭代后 `S` = `{M1, M2, M3, M4, M5, M8, G1, G2, G4, S1, S3, H1, H2, H3}`。**\n\n*   **第3轮迭代：分析 `M1` 的依赖**\n    *   **`M1: t1 := square(A)`:**\n        *   数据依赖于 `A`（由 `G1` 定义，已在 `S` 中）和 `square` 函数的返回值。\n        *   对 `square` 的切片已完成（`S1`, `S3`），没有新语句加入。\n\n迭代稳定，切片过程结束。\n\n**3. 最终切片审查与计数**\n\n*   **不相关的语句/函数：**\n    *   `G3: C := 0` 和 `S2: C := C + 1`：`C` 的值与最终输出无关。\n    *   `M7: noise(t2)`：其副作用（修改 `B`）不影响切片中的任何后续语句，因此 `M7` 不在切片中。\n    *   `noise` 函数 (`N1`, `N2`)：由于其调用点 `M7` 不在切片中，整个函数都是无关的。\n    *   `unusedGlobalFun` 函数 (`U1`, `U2`)：从未被调用，是无关的。\n\n*   **切片中的语句计数：**\n    *   **全局初始化：** `G1`, `G2`, `G4` (3条)\n    *   **函数 `square`：** `S1`, `S3` (2条)\n    *   **函数 `choose`：** `H1`, `H2`, `H3` (3条)\n    *   **函数 `main`：** `M1`, `M2`, `M3`, `M4`, `M5`, `M8` (6条)\n\n*   **总数：** $3 + 2 + 3 + 6 = 14$\n\n最终，后向切片中包含 14 条语句。", "answer": "$$\\boxed{14}$$", "id": "3682778"}]}