{"hands_on_practices": [{"introduction": "首先，让我们通过一个基础练习来巩固理解。这项实践 [@problem_id:3662990] 将引导你对一段简单的代码序列进行逐步的流敏感分析，展示指针的“指向集合”($\\text{points-to set}$)如何随每次赋值而演变。掌握这种追踪过程对于理解“必然别名关系”($\\text{must-alias relation}$)的核心概念至关重要，而后者是许多高级编译器优化的基础。", "problem": "考虑一个包含三个指针变量和两个不同栈分配整型位置的线性程序片段。按顺序执行的语句如下：\n语句 $s_{1}$: `p = `\n语句 $s_{2}$: `q = p;`\n语句 $s_{3}$: `r = `\n语句 $s_{4}$: `p = `\n\n假设一种流敏感、上下文不敏感的指针分析，它对指针变量执行强更新，并将每个栈分配的标量建模为一个唯一的抽象位置。该语言具有标准的取地址语义：运算符 `` 产生标量的地址，指针赋值复制引用的地址值，并且变量 $p$, $q$, $r$ 本身没有别名（即，没有指向指针的指针），没有并发干扰，也没有函数调用。\n\n从基本定义出发：一个指针变量 $v$ 在某个程序点的指向集 $PT(v)$ 是 $v$ 在该点可能表示的抽象位置的集合；并且，两个指针 $a$ 和 $b$ 在某个程序点处于必别名关系，如果在所有到达该点的可能执行中，$a$ 和 $b$ 都表示同一个单一的抽象位置。请在每个语句执行后构建指向图，并确定在语句 $s_4$ 执行后，$\\{p, q, r\\}$ 中处于必别名关系的无序指针對的数量。请以整数形式提供最终答案，不带单位，也无需四舍五入。", "solution": "该问题要求我们对给定的程序片段执行流敏感的指针分析，并确定执行结束时必别名指针對的数量。\n\n让我们首先将所描述的模型形式化。我们有两个不同的栈分配标量变量，$x$ 和 $y$。在用于分析的抽象内存模型中，它们分别对应于两个唯一的抽象位置，我们将其表示为 $l_x$ 和 $l_y$。我们有三个指针变量：$p$、$q$ 和 $r$。在任何程序点，我们分析的状态是这些指针各自的指向集的集合：$(PT(p), PT(q), PT(r))$。指针 $v$ 的指向集 $PT(v)$ 包含 $v$ 可能指向的抽象位置。\n\n该分析是流敏感的，意味着我们为每个程序点计算指向信息，并考虑语句的顺序。它采用强更新，意味着对指针变量 $v$ 的赋值会销毁 $v$ 之前的指向信息。这是允许的，因为没有指向 $p$、$q$ 或 $r$ 自身的指针。\n\n我们从语句 $s_1$ 之前的初始状态开始，此时指针未被初始化。它们的指向集是空的。令 $PT_k(v)$ 表示变量 $v$ 在语句 $s_k$ 执行后的指向集。\n\n初始状态 (在 $s_1$ 之前):\n$PT_0(p) = \\emptyset$\n$PT_0(q) = \\emptyset$\n$PT_0(r) = \\emptyset$\n\n现在，我们按顺序追踪每个语句的效果。\n\n语句 $s_1$ 之后：`p = `\n该语句将标量变量 $x$ 的地址赋给指针 $p$。在我们的抽象模型中，这意味着 $p$ 现在指向抽象位置 $l_x$。分析执行强更新，因此 $p$ 之前的指向集被丢弃并替换。\n$PT_1(p) = \\{l_x\\}$\n其他指针不受影响。\n$PT_1(q) = PT_0(q) = \\emptyset$\n$PT_1(r) = PT_0(r) = \\emptyset$\n$s_1$ 之后的指向图包含一条从 $p$ 到 $l_x$ 的边。\n\n语句 $s_2$ 之后：`q = p;`\n该语句将指针 $p$ 的值赋给指针 $q$。在指针分析的上下文中，这意味着 $q$ 现在指向 $p$ 所指向的任何位置。信息从 $p$ 流向 $q$。\n$q$ 的指向集成为 $p$ 的指向集的副本。\n$PT_2(q) = PT_1(p) = \\{l_x\\}$\n此步骤中其他指针不受影响。\n$PT_2(p) = PT_1(p) = \\{l_x\\}$\n$PT_2(r) = PT_1(r) = \\emptyset$\n$s_2$ 之后的指向图有两条边：一条从 $p$ 到 $l_x$，另一条从 $q$ 到 $l_x$。\n\n语句 $s_3$ 之后：`r = `\n该语句将标量变量 $x$ 的地址赋给指针 $r$。这与语句 $s_1$ 类似。指针 $r$ 现在指向抽象位置 $l_x$。\n$PT_3(r) = \\{l_x\\}$\n其他指针不受影响。\n$PT_3(p) = PT_2(p) = \\{l_x\\}$\n$PT_3(q) = PT_2(q) = \\{l_x\\}$\n在 $s_3$ 之后，所有三个指针 $p$、$q$ 和 $r$ 都指向同一个抽象位置 $l_x$。指向图有三条边，都指向 $l_x$。\n\n语句 $s_4$ 之后：`p = `\n该语句将标量变量 $y$ 的地址赋给指针 $p$。这对应于抽象位置 $l_y$。分析对 $p$ 执行强更新，因此其先前的指向信息（指向 $l_x$）被销毁并替换。\n$PT_4(p) = \\{l_y\\}$\n$q$ 和 $r$ 的指向集不受此语句影响。\n$PT_4(q) = PT_3(q) = \\{l_x\\}$\n$PT_4(r) = PT_3(r) = \\{l_x\\}$\n这是整个程序片段执行完毕后指向集的最终状态。\n\n现在，我们必须确定 $\\{p, q, r\\}$ 中处于必别名关系的无序對的数量。\n两个指针 $a$ 和 $b$ 之间存在必别名关系的定义是，在所有可能的执行中，它们都保证指向同一个单一的抽象位置。形式上，这要求在特定的程序点满足三个条件：\n1.  $a$ 的指向集必须是单元素集：$|PT(a)| = 1$。\n2.  $b$ 的指向集必须是单元素集：$|PT(b)| = 1$。\n3.  这两个单元素集必须相同：$PT(a) = PT(b)$。\n\n让我们使用最终的指向集来检查这三个无序對：\n- $PT_4(p) = \\{l_y\\}$\n- $PT_4(q) = \\{l_x\\}$\n- $PT_4(r) = \\{l_x\\}$\n\n对 1: $(p, q)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$。\n$|PT_4(q)| = |\\{l_x\\}| = 1$。\n但是，$PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(q)$。\n因此，$p$ 和 $q$ 不处于必别名关系。它们处于必不别名关系，因为它们保证指向不同的位置。\n\n对 2: $(p, r)$\n$|PT_4(p)| = |\\{l_y\\}| = 1$。\n$|PT_4(r)| = |\\{l_x\\}| = 1$。\n但是，$PT_4(p) = \\{l_y\\} \\neq \\{l_x\\} = PT_4(r)$。\n因此，$p$ 和 $r$ 不处于必别名关系。\n\n对 3: $(q, r)$\n$|PT_4(q)| = |\\{l_x\\}| = 1$。\n$|PT_4(r)| = |\\{l_x\\}| = 1$。\n并且，$PT_4(q) = \\{l_x\\} = PT_4(r)$。\n必别名关系的所有三个条件都得到满足。\n因此，$q$ 和 $r$ 处于必别名关系。\n\n统计处于必别名关系的无序指针對的数量，我们发现恰好有一对：$(q, r)$。\n最终答案是 $1$。", "answer": "$$\\boxed{1}$$", "id": "3662990"}, {"introduction": "在掌握了基础知识之后，下一个练习 [@problem_id:3663003] 引入了一个关键的复杂层次：指向指针的指针（多级指针）。通过分析一个修改指针变量本身的间接赋值操作（如 `*pp = `），你将学会如何追踪跨越多级间接引用的指针状态。这项技能对于正确分析系统编程中常见的复杂数据结构和函数指针至关重要。", "problem": "您正在静态指针和别名分析的层面上分析一个类C程序的片段。考虑四个地址不相交的独立标量位置：两个整型变量 $x$ 和 $y$，一个指向整数的指针 $p$，以及一个指向整数指针的指针 $pp$。假设采用一种流敏感、路径不敏感、上下文不敏感、字段不敏感的 may-points-to 分析，并对单例抽象位置执行强更新。程序从一个没有任何已知指向信息的未初始化状态开始，按顺序执行以下语句序列：\n- `p := `\n- `pp := `\n- `*pp := `\n- `*p := 3;`\n\n从指向关系的基本定义以及类C语言中赋值和间接存储的操作语义出发，推导：\n1. 最后一条语句 `*p := 3;` 写入的最终内存目标（即，具体的标量位置）。\n2. 序列结束时最终的指向集 $\\operatorname{Pts}(p)$ 和 $\\operatorname{Pts}(pp)$，其中对于指针变量 $v$，$\\operatorname{Pts}(v)$ 是 $v$ 可能指向的抽象位置的集合。\n\n设整数 $R$ 定义为\n$$\nR \\;=\\; |\\operatorname{Pts}(p)| \\;+\\; 2\\,|\\operatorname{Pts}(pp)| \\;+\\; v,\n$$\n其中 $|\\,\\cdot\\,|$ 表示集合的基数，$v$ 是最后一次存储操作 `*p := 3;` 写入的值。计算 $R$。请用一个整数表示您的最终答案。无需四舍五入。", "solution": "该问题要求对一个类C语句序列进行流敏感、路径不敏感的 may-points-to 分析。我们将逐条语句跟踪指针 $p$ 和 $pp$ 的指向集的状态。设变量 $x$、$y$、$p$ 和 $pp$ 的不同抽象内存位置分别表示为 $l_x$、$l_y$、$l_p$ 和 $l_{pp}$。指针变量 $v$ 的指向集将表示为 $\\operatorname{Pts}(v)$。分析规定，当赋值操作左侧被解引用的指针指向一个单例抽象位置时，执行强更新。\n\n初始状态：\n程序从未初始化的状态开始，此时没有任何已知的指向信息。\n设 $\\operatorname{Pts}_i(v)$ 是执行语句 $i$ 后 $v$ 的指向集。\n第一条语句之前的状态是：\n$$ \\operatorname{Pts}_{0}(p) = \\emptyset $$\n$$ \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\n语句 1: `p := `\n这是一个直接取地址赋值。指针 $p$ 被赋上了变量 $x$ 的地址。分析更新 $p$ 的指向集，使其包含 $x$ 的位置。旧集合被丢弃，新集合为 $\\{l_x\\}$。\n$$ \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{1}(pp) = \\operatorname{Pts}_{0}(pp) = \\emptyset $$\n\n语句 2: `pp := `\n这是另一个直接取地址赋值。指针 $pp$ 被赋上了指针变量 $p$ 的地址。分析更新 $pp$ 的指向集，使其包含 $p$ 的位置。\n$p$ 的指向集保持不变。\n$$ \\operatorname{Pts}_{2}(p) = \\operatorname{Pts}_{1}(p) = \\{l_x\\} $$\n$$ \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\n语句 3: `*pp := `\n这是一个间接赋值，也称为通过指针进行存储。左侧的变量是一个间接引用 `*pp`。为了确定哪个位置被修改，我们必须检查 $pp$ 的指向集。\n根据上一步，$\\operatorname{Pts}_{2}(pp) = \\{l_p\\}$。\n这是一个单例集，仅包含抽象位置 $l_p$。问题规定对单例抽象位置执行强更新。强更新意味着目标位置的现有信息被杀死（移除），并被赋值右侧的新信息所取代。\n更新的目标是 $pp$ 指向的位置，即 $l_p$。变量 $p$ 位于位置 $l_p$。因此，该语句修改了指针 $p$ 本身。\n右侧是 ``，表示变量 $y$ 的地址。\n因此，该语句的效果是改变 $p$ 的指向。$p$ 的旧指向集 $\\{l_x\\}$ 被杀死，并被包含 $l_y$ 的新集合所取代。\n$pp$ 的指向集不受此操作影响。\n$$ \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{3}(pp) = \\operatorname{Pts}_{2}(pp) = \\{l_p\\} $$\n\n语句 4: `*p := 3;`\n这是另一个间接赋值，存储整数值 $3$。为了确定内存目标，我们检查 $p$ 的指向集。\n根据上一步，$\\operatorname{Pts}_{3}(p) = \\{l_y\\}$。\n这也是一个单例集。$p$ 指向的唯一位置是 $l_y$，它对应于标量整型变量 $y$ 的抽象位置。\n因此，该语句将值 $3$ 写入 $y$ 的内存位置。\n此操作修改的是标量变量（$y$）的值，而不是指针。因此，$p$ 和 $pp$ 的指向集保持不变。\n\n最后一条语句执行后的状态是：\n$$ \\operatorname{Pts}_{\\text{final}}(p) = \\operatorname{Pts}_{3}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}_{\\text{final}}(pp) = \\operatorname{Pts}_{3}(pp) = \\{l_p\\} $$\n\n现在我们可以回答提出的具体问题了。\n\n1. 最后一条语句 `*p := 3;` 写入的最终内存目标：\n如上所述，指针 $p$ 仅指向位置 $l_y$。因此，存储操作 `*p := 3;` 写入位置 $l_y$，该位置对应于标量变量 $y$。\n\n2. 最终的指向集 $\\operatorname{Pts}(p)$ 和 $\\operatorname{Pts}(pp)$：\n最终的指向集是：\n$$ \\operatorname{Pts}(p) = \\{l_y\\} $$\n$$ \\operatorname{Pts}(pp) = \\{l_p\\} $$\n\n现在，我们必须计算 $R$ 的值。公式给出如下：\n$$ R = |\\operatorname{Pts}(p)| + 2\\,|\\operatorname{Pts}(pp)| + v $$\n该公式的组成部分是：\n- $|\\operatorname{Pts}(p)|$：$p$ 的最终指向集的基数。由于 $\\operatorname{Pts}(p) = \\{l_y\\}$，其基数为 $1$。\n$$ |\\operatorname{Pts}(p)| = 1 $$\n- $|\\operatorname{Pts}(pp)|$：$pp$ 的最终指向集的基数。由于 $\\operatorname{Pts}(pp) = \\{l_p\\}$，其基数为 $1$。\n$$ |\\operatorname{Pts}(pp)| = 1 $$\n- $v$：最后一次存储操作 `*p := 3;` 写入的值。写入的值是 $3$。\n$$ v = 3 $$\n\n将这些值代入 $R$ 的表达式中：\n$$ R = 1 + 2 \\times 1 + 3 $$\n$$ R = 1 + 2 + 3 $$\n$$ R = 6 $$", "answer": "$$\\boxed{6}$$", "id": "3663003"}, {"introduction": "最后，让我们将理论与实践联系起来，看看指针分析的精度如何直接影响编译器的优化能力。这个问题 [@problem_id:3662967] 探讨了一个由于存在未知条件而导致分析结果不精确的场景，产生了一个包含多个目标的“可指向集合”($\\text{may-points-to set}$)。你将亲眼见证这种不确定性如何阻碍常量传播优化，并理解编译器在这种情况下为何必须执行保守的“弱更新”($\\text{weak update}$)。", "problem": "给定以下 C 代码片段，它在一个没有函数调用且没有未定义行为的单一过程中执行：\n```c\nint x = 1;\nint y = 2;\nint *p = \nint *q = p ?  : \n*q = 5;\n```\n\n假设采用标准的保守指针分析，该分析是流不敏感和上下文不敏感的，并使用“可能指向”(may-points-to) 的解释。该分析不使用常量推理来评估条件表达式；它将条件表达式的两种结果都视为可能执行。设指针变量 $v$ 的“可能指向”集合用 $\\text{PT}(v)$ 表示，其基数用 $|\\text{PT}(v)|$ 表示。对于常量传播，使用稀疏条件常量传播 (SCCP)，其值格为 $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$，其中 $\\bot$ 表示不可达，$\\mathbb{Z}$ 中的每个整数表示一个已知常量，$\\top$ 表示一个未知的非恒定值。当通过指针的存储可能别名多个变量时，通过更新“可能指向”集合中的所有目标来对此效应建模；如果一个存储可能沿不同路径写入多个不同的值，则使用格的并运算(join)来表示合并结果。\n\n从 C 条件运算符将其第一个操作数作为布尔值求值并选择两个指针表达式之一的基本语义出发，定义并计算：\n- 在指定的“可能指向”分析下，基数 $|\\text{PT}(q)|$。\n- 在代码片段末尾，$x$ 和 $y$ 的 SCCP 格值，分别表示为 $V_{x}$ 和 $V_{y}$，并考虑指针分析和 SCCP 之间的指定交互。\n\n将您的最终答案表示为单行矩阵 $\\begin{pmatrix} |\\text{PT}(q)|  V_{x}  V_{y} \\end{pmatrix}$。无需四舍五入，也不涉及物理单位。根据需要使用格定义中的符号 $\\top$ 和 $\\bot$，并对已知的常量值使用整数。", "solution": "该问题要求使用指定的指针分析和常量传播模型来分析一段 C 代码片段。我们必须确定指针 `q` 的“可能指向”集合的基数，表示为 $|\\text{PT}(q)|$，以及在稀疏条件常量传播 (SCCP) 分析下变量 `x` 和 `y` 的最终格值，分别表示为 $V_x$ 和 $V_y$。\n\n首先，我们按照规定执行“可能指向”分析。该分析是流不敏感、上下文不敏感的，并且必须将条件运算符的两种结果都视为可能执行。流不敏感分析为整个过程计算一个单一的指向图，它聚合了所有赋值语句的效果，而不考虑控制流。\n\n与指针分析相关的语句是：\n1.  `int *p = `\n2.  `int *q = p ?  : `\n\n根据语句 1，指针 `p` 被赋予 `x` 的地址。这创建了一个指向关系，我们可以写成 `p → x`。用集合来表示，这意味着 $x \\in \\text{PT}(p)$。对于考虑整个过程的流不敏感分析，我们可以确定 $\\text{PT}(p) = \\{x\\}$。\n\n根据语句 2，指针 `q` 的值是基于一个条件表达式赋予的。问题明确指出，分析不使用常量推理来评估条件 `p`。相反，它必须假设真分支和假分支都是可执行的。\n-   如果条件为真，赋值语句将是 `q = `，导致关系 `q → y`。\n-   如果条件为假，赋值语句将是 `q = `，导致关系 `q → x`。\n\n一个保守的、流不敏感的“可能指向”分析会收集所有可能赋值中的所有可能目标。因此，`q` 的“可能指向”集合是两个分支目标的并集：$\\text{PT}(q) = \\{x\\} \\cup \\{y\\} = \\{x, y\\}$。\n\n这个集合的基数是它可能指向的不同变量的数量。\n$$|\\text{PT}(q)| = |\\{x, y\\}| = 2$$\n\n接下来，我们执行稀疏条件常量传播 (SCCP) 来确定 `x` 和 `y` 的最终值。SCCP 分析使用值格 $\\mathcal{L} = \\{\\bot\\} \\cup \\mathbb{Z} \\cup \\{\\top\\}$。该分析通过在此格上模拟程序的执行来进行，并使用预先计算的指针分析结果。\n\n设 $V_x$ 和 $V_y$ 分别是变量 `x` 和 `y` 的格值。我们追踪它们在程序中的值变化：\n1.  `int x = 1;`\n    这条语句用一个常量值初始化 `x`。`x` 的格值变为 $1$。\n    $V_x \\leftarrow 1$.\n\n2.  `int y = 2;`\n    类似地，这条语句用常量值 $2$ 初始化 `y`。\n    $V_y \\leftarrow 2$.\n    此时，我们有 $V_x = 1$ 和 $V_y = 2$。\n\n3.  `int *p = `\n    这条语句赋了一个指针值，不修改整型变量 `x` 或 `y`。它们的格值保持不变。\n\n4.  `int *q = p ?  : `\n    这条语句也赋了一个指针值，不修改 `x` 或 `y`。它们的格值保持为 $V_x = 1$ 和 $V_y = 2$。\n\n5.  `*q = 5;`\n    这是一个通过指针 `q` 的存储操作。SCCP 分析必须参考指针分析的结果来确定此存储操作的效果。我们已经确定 $\\text{PT}(q) = \\{x, y\\}$。这意味着存储操作可能修改 `x` 或 `y`。\n\n    问题为此场景提供了规则：“当通过指针的存储可能别名多个变量时，通过更新“可能指向”集合中的所有目标来对此效应建模”。这被解释为对指向集合中每个变量的“弱更新”(weak update)。对变量 `v` 进行值为 `C` 的存储的弱更新，意味着它的新格值成为其旧值与 `C` 的并运算结果。并运算，用 $\\sqcup$ 表示，在该格上的定义如下：\n    -   $a \\sqcup b = b \\sqcup a$ (交换律)\n    -   $C \\sqcup C = C$ 对于任意常量 $C \\in \\mathbb{Z}$。\n    -   $C_1 \\sqcup C_2 = \\top$ 对于任意不同常量 $C_1, C_2 \\in \\mathbb{Z}$。\n    -   $v \\sqcup \\top = \\top$ 对于任意值 $v \\in \\mathcal{L}$。\n    -   $v \\sqcup \\bot = v$ 对于任意值 $v \\in \\mathcal{L}$。\n\n    我们将此更新规则应用于 `x` 和 `y`。\n    -   对于 `x`：当前值为 $V_x = 1$。新值为 $V_x^{\\text{new}} = V_x \\sqcup 5 = 1 \\sqcup 5$。由于 $1$ 和 $5$ 是不同的常量，它们的并运算结果是 $\\top$。\n      $$V_x \\leftarrow \\top$$\n    -   对于 `y`：当前值为 $V_y = 2$。新值为 $V_y^{\\text{new}} = V_y \\sqcup 5 = 2 \\sqcup 5$。由于 $2$ 和 $5$ 是不同的常量，它们的并运算结果也是 $\\top$。\n      $$V_y \\leftarrow \\top$$\n\n在这最后一条语句之后，`x` 和 `y` 的格值都为 $\\top$，表示分析无法再保证它们持有特定的常量值。\n\n总而言之，分析结果如下：\n-   $|\\text{PT}(q)| = 2$\n-   $V_x = \\top$\n-   $V_y = \\top$", "answer": "$$\\boxed{\\begin{pmatrix} 2  \\top  \\top \\end{pmatrix}}$$", "id": "3662967"}]}