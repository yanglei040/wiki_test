{"hands_on_practices": [{"introduction": "要真正掌握部分冗余消除（PRE），最好的方法是从一个典型的基础案例开始。这个练习设定了一个经典的“菱形”控制流图（CFG），其中一个纯表达式（没有副作用的表达式）在两个分支路径中都被计算。通过这个练习，我们可以探索 PRE 的核心思想：识别出在某个代码块的所有后续路径上都会执行的计算，并将其“提升”到该代码块中，从而消除冗余。同时，这个例子也促使我们思考优化的权衡之处，例如执行速度的提升与可能的代码体积增大及寄存器压力增加之间的平衡。[@problem_id:3661827]", "problem": "给定一个控制流图（CFG），其入口块为 $B_0$，$B_0$ 立即分支到两个不相交的块 $B_1$ 和 $B_2$，这两个块随后都流入一个共同的后继块 $B_3$。这些块中的程序描述如下，其中所有变量表示整数寄存器，$\\oplus$ 表示按位异或。\n\n- 在 $B_0$ 中，操作数 $x$ 和 $y$ 都被定义，并且在 $B_1$、$B_2$ 或从 $B_0$ 到 $B_1$ 或 $B_2$ 的边上，$x$ 和 $y$ 都没有被修改。$B_0$ 中的条件分支由谓词 $p$ 决定：\n  - 在 $B_0$ 中：$x := \\text{def}_x$，$y := \\text{def}_y$，然后如果 $p$ 为真则分支到 $B_1$，否则分支到 $B_2$。\n- 在 $B_1$ 中，表达式 $x \\oplus y$ 的一次使用被赋值给一个局部名称 $u$：\n  - 在 $B_1$ 中：$u := x \\oplus y$；然后控制流转向 $B_3$。\n- 在 $B_2$ 中，相同表达式 $x \\oplus y$ 的一次使用被赋值给一个局部名称 $v$：\n  - 在 $B_2$ 中：$v := x \\oplus y$；然后控制流转向 $B_3$。\n- 在 $B_3$ 中，根据后续的使用情况，$u$ 和 $v$ 可能都处于活跃状态。\n\n假设在求值 $x$、$y$ 或 $x \\oplus y$ 时没有副作用，并且按位异或运算符 $\\oplus$ 是纯的（除了产生其结果外，它不读取或写入其操作数之外的内存，也没有其他可观察到的效果）。考虑应用部分冗余消除（PRE），PRE 被定义为一种优化，它通过将计算重新定位到更早的支配点并插入补偿代码以保持正确性，来移除在某些但不必是所有路径上冗余的计算。该优化基于数据流属性，如可用性（availability）、预期性（anticipatability）和透明性（transparency）。\n\n一个提议的 PRE 变换在 $B_0$ 中引入一个临时变量 $t$ 来计算一次 $t := x \\oplus y$，然后将 $B_1$ 和 $B_2$ 中的计算分别替换为移动操作 $u := t$ 和 $v := t$。\n\n关于这个 PRE 变换的正确性和收益性，以下哪些陈述是正确的？\n\nA. 在所述条件下，将 $t := x \\oplus y$ 提升到 $B_0$ 是语义安全的，因为 $x$ 和 $y$ 在 $B_0$ 中是可用的，并且表达式 $x \\oplus y$ 沿着从 $B_0$ 到其在 $B_1$ 和 $B_2$ 中使用的所有路径都是透明的。\n\nB. 这个变换严格减小了代码大小，因为它用 $B_0$ 中的一个实例替换了 $x \\oplus y$ 的两个实例，并且不需要任何额外的指令。\n\nC. 由于插入了副本 $u := t$ 和 $v := t$，这个变换可能会增加寄存器压力和代码大小；其收益性取决于一个成本模型，该模型比较一次计算加副本的成本与两次计算的成本。\n\nD. 如果 $x$ 或 $y$ 在 $B_0$ 和 $x \\oplus y$ 相应使用之间的某条路径上被重新定义，PRE 将需要插入补偿代码或避免提升以保持正确性，因为 $x \\oplus y$ 在该路径上将不再是透明的。\n\nE. 如果 $x \\oplus y$ 有副作用，将其提升到 $B_0$ 可能会改变可观察到的行为；因此，PRE 必须限制在没有副作用的纯表达式上，这适用于给定的 $\\oplus$。\n\n选择所有正确选项。", "solution": "用户需要对问题陈述进行批判性验证，然后是解决方案和对所提供选项的评估。\n\n### 步骤 1：提取已知条件\n\n-   **控制流图 (CFG)**：一个入口块 $B_0$ 分支到两个不相交的块 $B_1$ 和 $B_2$。$B_1$ 和 $B_2$ 都有一个共同的后继块 $B_3$。这形成了一个菱形的 CFG 结构。\n-   **块 $B_0$ 语义**：\n    -   操作数 $x$ 和 $y$ 被定义：$x := \\text{def}_x$, $y := \\text{def}_y$。\n    -   基于谓词 $p$ 的条件分支：如果 $p$ 为真则分支到 $B_1$，否则分支到 $B_2$。\n-   **路径属性 ($B_0 \\to B_1$, $B_0 \\to B_2$)**：在 $B_1$、$B_2$ 或连接它们的从 $B_0$ 出发的边上，$x$ 和 $y$ 都没有被修改。\n-   **块 $B_1$ 语义**：包含计算 $u := x \\oplus y$，其中 $u$ 是一个局部名称。控制流转向 $B_3$。\n-   **块 $B_2$ 语义**：包含计算 $v := x \\oplus y$，其中 $v$ 是一个局部名称。控制流转向 $B_3$。\n-   **块 $B_3$ 语义**：进入 $B_3$ 时，$u$ 和 $v$ 可能都处于活跃状态。\n-   **运算符属性**：运算符 $\\oplus$ 是按位异或。它被指定为纯的，意味着它没有副作用。\n-   **优化定义**：部分冗余消除（PRE）被定义为一种优化，它通过重新定位计算和插入补偿代码来移除在某些（但不必是所有）路径上冗余的计算。它基于数据流属性，如可用性、预期性和透明性。\n-   **提议的变换**：\n    1.  在块 $B_0$ 中插入 $t := x \\oplus y$。\n    2.  将 $B_1$ 中的 $u := x \\oplus y$ 替换为 $u := t$。\n    3.  将 $B_2$ 中的 $v := x \\oplus y$ 替换为 $v := t$。\n\n### 步骤 2：使用提取的已知条件进行验证\n\n-   **科学性**：该问题牢固地植根于编译器设计和优化的原理，特别是数据流分析和代码变换。CFG、基本块、活跃性、数据流属性（可用性、预期性）和 PRE 的概念在该领域是标准的。所描述的场景是用于教授 PRE 及相关优化的一个典型例子。该问题在科学上是合理的。\n-   **适定性**：问题对程序结构和提议的变换提供了清晰而完整的描述。问题要求对关于此变换的正确性和收益性的几个陈述进行评估，这是一个明确定义的任务。基于所提供的信息，可以进行唯一的分析。\n-   **客观性**：问题以精确、客观的语言陈述。使用的术语（$x$、$y$、$B_0$、$\\oplus$、PRE）要么在计算机科学的上下文中被定义，要么是标准术语。问题设置中没有主观或基于意见的主张。\n-   **其他缺陷**：在其领域内，该问题并非微不足道、自相矛盾或不切实际。它提出了编译器优化中常见的权衡分析。\n\n### 步骤 3：结论和行动\n\n问题陈述是有效的。我将继续进行分析和求解。\n\n### 推导与选项分析\n\n该问题描述了一个代码移动的经典案例，通常由部分冗余消除（PRE）算法处理。表达式 $e = x \\oplus y$ 在所有离开基本块 $B_0$ 的路径上都被计算。在数据流分析术语中，这意味着表达式 $e$ 在 $B_0$ 的出口是*可预期的*（或*非常活跃的*）。这是允许将计算提升到 $B_0$ 而不会在先前不包含该计算的路径上引入该计算的关键属性。\n\n让我们分析一下提议的变换：\n-   **之前**：如果谓词 $p$ 为真，计算 $x \\oplus y$ 在 $B_1$ 中执行；如果 $p$ 为假，则在 $B_2$ 中执行。在此代码的任何单次执行中，恰好发生一次 $x \\oplus y$ 的计算。源代码中有两个该计算的静态实例。\n-   **之后**：计算 $t := x \\oplus y$ 无条件地在 $B_0$ 中执行。然后，在 $B_1$（$u := t$）或 $B_2$（$v := t$）中执行一个复制（移动）操作。在任何单次执行中，发生一次 $x \\oplus y$ 的计算和一次复制操作。\n\n现在我们评估每个陈述。\n\n**A. 在所述条件下，将 $t := x \\oplus y$ 提升到 $B_0$ 是语义安全的，因为 $x$ 和 $y$ 在 $B_0$ 中是可用的，并且表达式 $x \\oplus y$ 沿着从 $B_0$ 到其在 $B_1$ 和 $B_2$ 中使用的所有路径都是透明的。**\n\n为了使提升变换在语义上是安全的（即保持程序的含义），必须满足两个条件：\n1.  被提升表达式的操作数必须在新位置可用。这里，$x$ 和 $y$ 在 $B_0$ 中定义，因此它们对于 $B_0$ 中的计算 $t := x \\oplus y$ 是可用的。\n2.  计算出的值必须与在原始位置计算出的值相同。这要求操作数（$x$ 和 $y$）在从新位置到原始位置的任何路径上都没有被重新定义。这个属性被称为*透明性*。问题陈述明确保证了这一点：“在 $B_1$、$B_2$ 或从 $B_0$ 到 $B_1$ 或 $B_2$ 的边上，$x$ 和 $y$ 都没有被修改”。\n\n由于两个条件都得到满足，提升是语义安全的。该陈述中提供的推理是完全正确的。\n结论：**正确**。\n\n**B. 这个变换严格减小了代码大小，因为它用 $B_0$ 中的一个实例替换了 $x \\oplus y$ 的两个实例，并且不需要任何额外的指令。**\n\n我们来分析静态指令数。\n-   **之前**：$B_1$ 中有一个计算指令（$u := x \\oplus y$），$B_2$ 中有一个（$v := x \\oplus y$）。总计：$2$ 条指令。\n-   **之后**：$B_0$ 中有一个计算指令（$t := x \\oplus y$），$B_1$ 中有一个复制指令（$u := t$），$B_2$ 中有一个复制指令（$v := t$）。总计：$3$ 条指令。\n该变换用一个计算和两个复制指令替换了两个计算指令。声称它“不需要任何额外的指令”是错误的；它在移除一个计算的同时增加了两个复制指令。静态代码大小从 $2$ 条指令增加到 $3$ 条指令（假设每个操作对应于一个大小相似的指令）。\n结论：**不正确**。\n\n**C. 由于插入了副本 $u := t$ 和 $v := t$，这个变换可能会增加寄存器压力和代码大小；其收益性取决于一个成本模型，该模型比较一次计算加副本的成本与两次计算的成本。**\n\n让我们分解这个陈述。\n1.  **代码大小**：如选项 B 的分析所确定，静态指令数从 $2$ 增加到 $3$。因此，该变换可以（并且确实）增加代码大小。\n2.  **寄存器压力**：新的临时变量 $t$ 在 $B_0$ 中定义，并且一直活跃到它在 $B_1$ 和 $B_2$ 中的最后一次使用。这意味着 $t$ 的值必须在条件分支之间保持。这增加了从 $B_0$ 到 $B_1$ 和 $B_0$ 到 $B_2$ 的控制流边上的活跃变量数量，从而增加了寄存器压力。如果机器的寄存器不足，这可能会导致更多的寄存器溢出。\n3.  **收益性**：一个优化是否“值得”（有收益）取决于一个成本模型。编译器必须权衡利弊。对于这个变换，动态路径成本发生了变化。\n    -   变换前成本：$C(B_0) + C(B_{1 \\text{ or } 2}) = C(B_0) + C_{x \\oplus y}$。\n    -   变换后成本：$C'(B_0) + C'(B_{1 \\text{ or } 2}) = (C(B_0) + C_{x \\oplus y}) + C_{\\text{copy}}$。\n    在执行速度方面，此变换向每个执行路径增加了复制指令的成本，因此看起来没有收益。然而，该陈述本身并未声称它*有*收益。它正确地指出其收益性*取决于*一个成本模型。措辞“比较一次计算加副本的成本与两次计算的成本”指的是静态权衡（1个 XOR 和 2个 MOV vs 2个 XOR），这可能是成本模型的一种构建方式。整个陈述正确地指出了缺点和进行成本效益分析的必要性。\n结论：**正确**。\n\n**D. 如果 $x$ 或 $y$ 在 $B_0$ 和 $x \\oplus y$ 相应使用之间的某条路径上被重新定义，PRE 将需要插入补偿代码或避免提升以保持正确性，因为 $x \\oplus y$ 在该路径上将不再是透明的。**\n\n这个陈述假设了对程序的一个修改。假设 $x$ 在从 $B_0$ 到 $B_1$ 的路径上被重新定义。\n-   在 $B_1$ 的计算点，$x$ 的值将不同于 $B_0$ 结束时 $x$ 的值。\n-   将 $t := x \\oplus y$ 提升到 $B_0$ 将使用来自 $B_0$ 的 $x$ 的值来计算表达式。\n-   在 $B_1$ 中使用这个 $t$ 的值在语义上是不正确的，因为它不会反映 $x$ 的重新定义。\n-   失败的原因恰恰是该路径对于表达式 $x \\oplus y$ 不再是*透明的*。\n-   PRE 算法必须确保正确性。它会检测到缺乏透明性，并且必须做出反应。两种主要策略是：（1）**完全避免提升**表达式，因为安全条件被违反了；或者（2）在更复杂的场景中，在操作数被重新定义后插入表达式的重新计算（所谓的**补偿代码**）。这个陈述准确地描述了这种情况以及一个正确的 PRE 实现会采取的可能行动。\n结论：**正确**。\n\n**E. 如果 $x \\oplus y$ 有副作用，将其提升到 $B_0$ 可能会改变可观察到的行为；因此，PRE 必须限制在没有副作用的纯表达式上，这适用于给定的 $\\oplus$。**\n\n像 PRE 这样的代码移动优化必须小心，不能改变程序语义。\n-   **副作用**：如果一个表达式引起副作用（例如，修改内存、执行 I/O、抛出异常），移动它可能会改变程序的行为。在更一般的 PRE 情况下，表达式可能被移动到它最初未被执行的路径上，从而错误地引入副作用。即使在这个问题的特定情况下，表达式在所有路径上都存在，将其从分支内部（$B_1$、$B_2$）移动到分支之前（$B_0$）也会改变副作用相对于其他程序操作*何时*发生，这是一个可观察到的变化。\n-   **异常**：如果 $x \\oplus y$ 可能引发异常（例如，如果它是 $x/y$ 且 $y$ 可能为 $0$），将其提升到 $B_0$ 可能会导致程序在原始代码中不会出错的路径上出错。为了使提升安全，必须保证异常在从提升点开始的每条路径上都会发生，这在本例中是成立的，但对于一般的 PRE 并不成立。\n-   **纯度**：为避免这些问题，像 PRE 这样的代码移动优化被保守地限制在保证没有副作用或不会引发虚假异常的*纯*表达式上。问题正确地指出，按位异或运算符 $\\oplus$ 是纯的，使其成为此优化的有效候选者。该陈述中提出的推理是安全编译器优化的一个基本原则。\n结论：**正确**。", "answer": "$$\\boxed{ACDE}$$", "id": "3661827"}, {"introduction": "在理想情况下，表达式是纯粹且安全的，但现实世界中的代码充满了挑战。这个练习引入了一个更实际的复杂情况：一个“不安全”的表达式，即可能导致程序错误的整数除法 $x/y$。简单地将这个计算提升到一个更早的位置可能会引入在原始程序中不存在的“除零”异常。这个思想实验揭示了安全 PRE 的一个关键原则：为了保持程序的语义正确性（特别是异常行为），我们不仅需要移动计算本身，还必须一同移动其“安全卫士”——即保证计算安全的条件检查。[@problem_id:3661859]", "problem": "一个控制流图 (CFG) 中的程序有块 $B_0 \\rightarrow B_2$，在 $B_2$ 处根据谓词 $p$ 进行条件分支，分为两个正常路径块 $B_4$ 和 $B_5$，这两个块都可以到达一个公共汇合块 $J$。存在一个罕见的错误处理块 $E$，当且仅当 $y=0$ 时应到达该块。两个正常路径分支中的当前代码片段如下：\n- 在 $B_4$ 中：if $y=0$ then goto $E$ else compute $t_1 := x/y$ and use $t_1$; then goto $J$。\n- 在 $B_5$ 中：if $y=0$ then goto $E$ else compute $t_2 := x/y$ and use $t_2$; then goto $J$。\n\n假设为整数除法，其中除以零必须触发错误处理器 $E$（即，该语言对除零具有精确的异常语义，并且在这些路径上没有其他副作用）。还假设 $x$ 和 $y$ 在路径 $B_2 \\rightarrow B_4$ 和 $B_2 \\rightarrow B_5$ 上未被修改，并且在 $B_2$ 之前被定义，而且 $y$ 只有在罕见的错误路径上才能为零。目标是对表达式 $x/y$ 应用部分冗余消除 (PRE)，使其在所有正常路径上仅计算一次，同时保留程序的原始异常行为并最小化守卫检查。\n\n根据编译器优化中使用的基本定义：\n- 表达式的冗余意味着表达式在其操作数未发生改变的某些路径上被多次计算。\n- 表达式在某个程序点的可用性意味着到达该点的所有路径都计算了该表达式，并且自上次计算以来其操作数未发生改变。\n- 表达式在某个程序点的可预期性意味着该表达式将在从该点出发的所有路径上被使用，且在其任何操作数被重新定义之前。\n- 在 CFG 中的支配意味着，如果从入口到节点 $N$ 的每条路径都经过节点 $D$，则节点 $D$ 支配节点 $N$。\n- 对于不安全的表达式（如 $x/y$），仅当一个守卫保证其求值不会引发异常的区域内，计算该表达式才是安全的；否则，推测性移动可能会违反精确的异常语义。\n\n根据这些原则，以下哪种转换是正确的，并且能满足所述目标？\n\nA. 在 $B_2$ 之后立即引入一个新块 $G$（以便 $G$ 支配 $B_4$ 和 $B_5$）。在 $G$ 中，执行单个守卫和计算：if $y=0$ then goto $E$ else compute $t := x/y$。将从 $B_2$ 到 $B_4$ 和从 $B_2$ 到 $B_5$ 的两条边都重定向以经过 $G$，消除 $B_4$ 和 $B_5$ 中每个分支的守卫，并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用。保持使用部分不变。无其他更改。\n\nB. 在 $B_2$ 中推测性地插入 $t := x/y$ 而不加任何守卫，移除 $B_4$ 和 $B_5$ 中每个分支的守卫，并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用。保持 $E$ 仅在后续代码像之前一样尝试除以零时才可达。\n\nC. 在 $B_2$ 之后的一个新的支配块 $G$ 中插入一个守卫，如果 $y=0$ 则将控制权转移到 $E$，否则不变地传递到 $B_4$ 或 $B_5$。此外，在 $G$ 中预计算 $t := x/y$ 并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用，但为了保守起见，保留 $B_4$ 和 $B_5$ 中原来每个分支的守卫。\n\nD. 仅将守卫提升到 $B_2$ 之后的一个新块 $G$ 中，该块在 $y=0$ 时将控制权转移到 $E$，否则转发到 $B_4$ 和 $B_5$，但保持 $B_4$ 中的 $t_1 := x/y$ 和 $B_5$ 中的 $t_2 := x/y$ 原样不变，其计算也保持完整。\n\n选择一个或多个选项，这些选项生成的程序在语义上与原始程序等价（就异常行为和值而言），在所有正常路径上仅计算一次 $x/y$，并且所需守卫检查的数量最少。", "solution": "2.  **问题验证**：\n    *   **步骤1：提取已知条件**：列出问题描述中的所有事实和约束。\n        *   CFG 结构：$B_0 \\rightarrow B_2$。\n        *   在 $B_2$ 处基于谓词 $p$ 进行条件分支。\n        *   分支通向两个正常路径块 $B_4$ 和 $B_5$。\n        *   $B_4$ 和 $B_5$ 都可以到达一个公共汇合块 $J$。\n        *   错误处理块 $E$ 当且仅当 $y=0$ 时可达。\n        *   在 $B_4$ 中的原始代码：`if y=0 then goto E else compute t1 := x/y and use t1; then goto J`。\n        *   在 $B_5$ 中的原始代码：`if y=0 then goto E else compute t2 := x/y and use t2; then goto J`。\n        *   假设：整数除法。\n        *   假设：除以零必须触发错误处理器 $E$（精确的异常语义）。\n        *   假设：$x$ 和 $y$ 在路径 $B_2 \\rightarrow B_4$ 和 $B_2 \\rightarrow B_5$ 上未被修改。\n        *   假设：$x$ 和 $y$ 在 $B_2$ 之前被定义。\n        *   假设：$y$ 只能在罕见的错误路径上为零。\n        *   目标：对 $x/y$ 应用 PRE。\n        *   目标要求：\n            1.  在所有正常路径上只计算一次 $x/y$。\n            2.  保留原始的异常行为。\n            3.  最小化守卫检查。\n        *   提供的定义：冗余、可用性、可预期性、支配、不安全表达式的安全性。\n\n    *   **步骤2：使用提取的已知条件进行验证**：根据验证标准检查问题。\n        *   **科学上是否成立？**：是的，这是编译器理论中的一个标准问题，特别是关于数据流分析和用于 PRE 的代码移动。这些概念（CFG、支配、PRE、精确异常）都是公认的。\n        *   **是否定义良好？**：是的，该问题描述了特定的代码结构和转换目标，并有明确的约束。可以对其进行推理求解。\n        *   **是否客观？**：是的，语言是精确和技术性的。没有主观因素。\n        *   **缺陷检查**：\n            1.  **科学/事实不健全？**：否。设置与编译器原则一致。\n            2.  **无法形式化？**：否。这是一个关于 CFG 转换的形式化问题。\n            3.  **不完整/矛盾？**：“当前代码片段...”暗示这是更大程序的一部分，但分析范围限于此片段。假设“$y$ 只能在罕见的错误路径上为零”可能有点强，但它与仅在 $y=0$ 时将控制转移到 $E$ 的目标是一致的。问题看起来是自洽的。\n            4.  **不现实/不可行？**：否。这是一个非常常见的优化场景。\n            5.  **不适定？**：否。目标是找到满足多个标准的*正确*转换。这是一个标准的优化问题。预期在选项中有一个唯一的最佳转换。\n            6.  **琐碎/同义反复？**：否。它需要理解代码移动、冗余和异常语义之间的相互作用，这是针对不安全表达式的 PRE 的核心概念。\n            7.  **无法验证？**：否。转换的正确性可以通过分析所得到的 CFG 的语义来正式验证。\n\n    *   **步骤3：结论和行动**：问题是**有效的**。接下来推导解决方案。\n\n3.  **解决方案推导**：\n    *   **分析初始状态**：\n        *   表达式 `$x/y$` 在从 $B_2$ 分出的两个分支（$B_4$ 和 $B_5$）中都被计算。\n        *   由于 $x$ 和 $y$ 在这些路径上没有被修改，表达式 `$x/y$` 是部分冗余的。它不是完全冗余的，因为它没有在进入 $B_2$ 的路径上计算。\n        *   表达式 `$x/y$` 是*不安全*的，因为存在除以零的可能性。\n        *   原始程序通过用 `if y=0` 守护每个计算来正确处理此问题。\n        *   表达式 `$x/y$` 在 $B_2$ 的出口处（以及 $B_4$ 和 $B_5$ 的入口处）是*可预期的*，因为它在所有路径（$B_4 \\rightarrow J$ 和 $B_5 \\rightarrow J$）上被使用，且在其操作数 $x$ 或 $y$ 被重新定义之前。\n        *   PRE 的目标是将计算移动到更早的点以消除冗余。理想的点将是一个支配 $B_4$ 和 $B_5$ 的块。\n\n    *   **应用 PRE 原则处理不安全表达式**：\n        *   标准的 PRE 会将计算 `$t := x/y$` 提升到一个公共支配节点。\n        *   然而，`$x/y$` 是不安全的。推测性地提升它（即，在原始计算点之前）可能会引入新的异常。例如，将 `$t := x/y$` 移动到 $B_2$ 会在 $y=0$ 时导致除零异常，即使原始程序路径本不会执行该除法。\n        *   问题陈述 $B_2$ 处的分支通向 $B_4$ 和 $B_5$。所以路径是 $B_2 \\rightarrow B_4 \\rightarrow J$ 和 $B_2 \\rightarrow B_5 \\rightarrow J$。\n        *   为了安全地执行 PRE，我们不能仅仅移动计算。我们还必须确保移动后的计算受到守卫保护。这被称为“安全 PRE”或“推测控制”。\n        *   原始代码在 $B_4$ 和 $B_5$ 中都有守卫 `if y=0`。这个守卫也是冗余的。\n        *   理想的转换将同时提升计算和守卫。\n\n    *   **构思理想的转换**：\n        1.  为了提升计算并使其只执行一次，必须将其放置在一个支配 $B_4$ 和 $B_5$ 的块中。由于分支发生在 $B_2$，公共支配节点是 $B_2$。为了将代码放置在 $B_2$ “之后”但在 $B_4$ 和 $B_5$ “之前”，必须引入一个新块 $G$，这实际上是对控制流的重构。最合乎逻辑的重构是让 $B_2$ 无条件跳转到 $G$，然后将 $B_2$ 的分支逻辑移入 $G$。\n        2.  产生的控制流将是：$... \\rightarrow B_2 \\rightarrow G$。\n        3.  块 $G$ 将包含提升的公共代码。首先，是不安全表达式的守卫：`if y = 0 then goto E`。这保留了异常语义，并通过使用单个守卫满足了最小化检查的目标。\n        4.  在此守卫的 `else` 路径中，现在可以安全地计算 `$t := x/y$`。\n        5.  计算之后，必须恢复原始的控制流。块 $G$ 接着将执行条件分支：`if p then goto B4' else goto B5'`，其中 $B_4'$ 和 $B_5'$ 是原始块的修改版本。\n        6.  在 $B_4'$ 和 $B_5'$ 中，原始的守卫和计算（`if y=0...`, `t1 := x/y`, `t2 := x/y`）被移除。对 $t_1$ 和 $t_2$ 的使用被替换为对提升的临时变量 $t$ 的使用。\n        7.  这个转换满足所有陈述的目标：`$x/y$` 在正常路径上仅计算一次（在 $G$ 中）；异常行为与原始程序相同；守卫检查的数量从两次减少到一次，达到最少。\n\n4.  **逐项分析选项**：\n\n    *   **选项 A**：“在 $B_2$ 之后立即引入一个新块 $G$（以便 $G$ 支配 $B_4$ 和 $B_5$）。在 $G$ 中，执行单个守卫和计算：if $y=0$ then goto $E$ else compute $t := x/y$。将从 $B_2$ 到 $B_4$ 和从 $B_2$ 到 $B_5$ 的两条边都重定向以经过 $G$，消除 $B_4$ 和 $B_5$ 中每个分支的守卫，并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用。保持使用部分不变。无其他更改。”\n        *   该选项描述了上面推导出的理想转换。引入一个新块 $G$，它支配后续的块。“将两条边都重定向以经过 G”是一种略微非正式但常见的说法，用于描述插入一个新块以容纳后续几条路径的公共代码的重构。描述的行动是：\n            1. 将守卫和计算提升到新的支配块 $G$ 中。\n            2. 只计算一次 `$x/y$`。\n            3. 消除 $B_4$ 和 $B_5$ 中现在已冗余的守卫和计算。\n            4. 使用新的临时变量 $t$。\n        *   这个转换正确地实现了安全的部分冗余消除。它仅计算一次 `$x/y$`，通过将守卫与计算一起提升来保留精确的异常语义，并将守卫检查的数量最小化为一次。\n        *   **结论**：**正确**。该选项准确地描述了所需的优化。\n\n    *   **选项 B**：“在 $B_2$ 中推测性地插入 $t := x/y$ 而不加任何守卫，移除 $B_4$ 和 $B_5$ 中每个分支的守卫，并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用。保持 $E$ 仅在后续代码像之前一样尝试除以零时才可达。”\n        *   这个转换将计算 `$t := x/y$` 移动到块 $B_2$ 但移除了保护性守卫。这是推测性代码移动。\n        *   这是不正确的，因为 `$x/y$` 是一个不安全的表达式。如果程序带着 $y=0$ 进入 $B_2$，这段新代码将执行 `$t := x/y$` 并引发异常。而原始程序在这一点上不会引发异常，因为除法是受保护的。\n        *   这违反了保留程序原始异常行为（“精确异常语义”）的约束。引入一个新的、不希望的异常是严重的语义变更。声明“保持 $E$ 可达...”也遭到了违反，因为显式的 `goto E` 被移除，并被一个运行时系统级别的故障所取代。\n        *   **结论**：**不正确**。\n\n    *   **选项 C**：“在 $B_2$ 之后的一个新的支配块 $G$ 中插入一个守卫...此外，在 $G$ 中预计算 $t := x/y$ 并将 $t_1 := x/y$ 和 $t_2 := x/y$ 替换为对 $t$ 的使用，但为了保守起见，保留 $B_4$ 和 $B_5$ 中原来每个分支的守卫。”\n        *   这个转换在一个新的支配块 $G$ 中，在执行安全检查后正确地预计算了 `$x/y$` 的值。它计算一次 `$x/y$` 并保留了异常行为。\n        *   然而，它明确指出保留了 $B_4$ 和 $B_5$ 中的原始守卫。一旦控制流通过了 $G$ 中的守卫，就可以确定 $y \\neq 0$。因此，$B_4$ 和 $B_5$ 中的守卫 `if y=0` 是冗余的，因为它们的条件将永远为假。\n        *   保留这些守卫违反了“最小化守卫检查”的既定目标。结果程序有三个守卫检查（$G$ 中1个，$B_4$ 中1个，$B_5$ 中1个），而最优解（选项 A）只有一个。\n        *   **结论**：**不正确**。这个转换在语义上是安全的，但不是最优的，并且未能满足所有既定目标。\n\n    *   **选项 D**：“仅将守卫提升到 $B_2$ 之后的一个新块 $G$ 中...但保持 $B_4$ 中的 $t_1 := x/y$ 和 $B_5$ 中的 $t_2 := x/y$ 原样不变，其计算也保持完整。”\n        *   这个转换只消除了守卫 `if y=0` 的冗余。它将检查提升到一个公共支配块 $G$ 中。\n        *   然而，它未能解决计算 `$x/y$` 的冗余问题。问题陈述明确说“保持 $B_4$ 中的 $t_1 := x/y$ 和 $B_5$ 中的 $t_2 := x/y$ 原样不变”。\n        *   这违反了对表达式 `$x/y$` 应用部分冗余消除以“在所有正常路径上仅计算一次 $x/y$”的首要目标。在这个转换后的程序中，计算仍然执行了两次。\n        *   **结论**：**不正确**。\n\n基于以上分析，只有选项 A 正确描述了一个满足所有给定约束和目标的转换。", "answer": "$$\\boxed{A}$$", "id": "3661859"}, {"introduction": "有时，即使我们知道一个表达式是部分冗余的，并且也考虑了安全检查，但程序的控制流结构本身可能会阻碍优化。当一个代码合并点之后紧跟着一个分支点时，任何在合并点进行的提升都可能错误地将计算引入到本不需要它的路径上。这个问题展示了一种更高级的编译器技术——代码克隆（或称尾部复制），它通过复制部分控制流图来解开复杂的依赖关系。这个练习旨在说明，为了创造优化的机会，编译器有时必须首先对代码结构进行重塑，从而为部分冗余消除等技术铺平道路。[@problem_id:3661855]", "problem": "一个编译器想要在一个使用静态单赋值 (SSA) 并表示为控制流图 (CFG) 的程序中，对表达式 $x+y$ 应用部分冗余消除 (PRE)。该程序使用带有溢出检查的整数算术；计算 $x+y$ 可能会引发溢出异常，因此需要非推测性 (non-speculative) PRE：在原始程序不计算 $x+y$ 的控制流路径上，编译器不得引入对 $x+y$ 的计算。\n\n考虑以下包含基本块 $B_0$、$B_1$、$B_2$、$J$、$S$、$U$、$N$ 和 $E$ 的 CFG：\n\n- $B_0$：初始化 $x := a$，$y := b$，然后根据谓词 $p$ 分支到 $B_1$ 或 $B_2$。\n- $B_1$：计算 $t := x + y$，然后跳转到 $J$。\n- $B_2$：更新 $y := y + 1$，然后跳转到 $J$。\n- $J$：使用 SSA 合并函数 $\\phi$ 合并来自 $B_1$ 和 $B_2$ 的路径，生成 $x_J := \\phi(x_{B_1}, x_{B_2})$ 和 $y_J := \\phi(y_{B_1}, y_{B_2})$，然后跳转到 $S$。\n- $S$：根据谓词 $q$ 分支到 $U$ (真) 或 $N$ (假)。\n- $U$：计算 $u := x_J + y_J$，使用 $u$，然后跳转到 $E$。\n- $N$：执行不使用 $x+y$ 的无关工作，然后跳转到 $E$。\n- $E$：退出。\n\n假设：\n- $x$ 和 $y$ 在 $J$、$S$、$U$ 或 $N$ 中未被修改（除了在 $U$ 中定义且仅在 $U$ 中使用的 $u$）。\n- $U$ 中的计算 $u := x_J + y_J$ 是 $S \\to U$ (真) 路径上对 $x+y$ 的唯一求值；在 $S \\to N$ (假) 路径上，原始程序中没有对 $x+y$ 的求值。\n- 因为 $x+y$ 可能引发溢出异常，非推测性 PRE 不得在 $S \\to N$ 路径上引入任何新的 $x+y$ 执行。\n\n观察：\n在路径 $B_0 \\to B_1 \\to J \\to S \\to U$ 上，表达式 $x+y$ 已在 $B_1$ 中计算为 $t := x + y$，并且沿着这条路径 $u := x_J + y_J$ 等于 $t$。在另一条路径 $B_0 \\to B_2 \\to J \\to S \\to U$ 上，$x+y$ 没有被提前计算。因此，在 $U$ 处，$x+y$ 是部分冗余的：它在一个进入路径上可用，但在另一个路径上不可用。\n\n标准的 PRE 会尝试放置 $x+y$ 以使其在所有通往 $U$ 的路径上都可用，从而能够消除 $U$ 中的 $u := x_J + y_J$。然而，由于跨越两个前驱节点且支配 $U$ 的最近放置点在 $S$ 或 $J$ 处或之前，将 $x+y$ 移动到那里会导致在 $q$ 为假时也对其进行求值，这违反了非推测性约束。\n\n哪种通过代码克隆（尾部复制）的重构方式，能够实现合法的 PRE 放置，从而使 $U$ 中的计算 $u := x_J + y_J$ 变得完全冗余并可以被移除，同时又不会在 $S \\to N$ 路径上引入任何新的 $x+y$ 执行？\n\n选择最佳选项：\n\nA. 克隆通往使用点的尾部：通过复制 $J$ 和 $S$ 并分裂它们指向 $U$ 的 $q$-true 出边，为 $B_1$ 路径创建路径特定的副本 $J_1, S_1, U_1$，为 $B_2$ 路径创建副本 $J_2, S_2, U_2$。重定向 $B_1 \\to J_1 \\to S_1 \\to U_1$ 和 $B_2 \\to J_2 \\to S_2 \\to U_2$。仅在 $S_2$ 的 $q$-true 边上（紧邻 $U_2$ 之前）插入一个 $x+y$ 的计算，并在 $J_1 \\to S_1 \\to U_1$ 路径上复用来自 $B_1$ 的 $t := x+y$。然后在 $U_1$ 和 $U_2$ 中替换并移除 $u := x_J + y_J$。这使得 $x+y$ 仅在 $q$ 为真时执行，并消除了克隆尾部中经 $\\phi$ 合并的操作数。\n\nB. 仅将汇合点 $J$ 克隆为 $J_1$ 和 $J_2$，重定向 $B_1 \\to J_1$ 和 $B_2 \\to J_2$，保持 $S$ 和 $U$ 共享，并为 $B_2$ 路径在 $J_2$ 处插入 $x+y$。移除 $U$ 中的 $u := x_J + y_J$。\n\nC. 仅将前驱节点 $B_1$ 克隆为一个也计算 $t := x + y$ 的新块 $B'_1$，保持 $J$、$S$ 和 $U$ 不变，并依赖 $t$ 的可用性来移除 $U$ 中的 $u := x_J + y_J$。\n\nD. 推测性地将 $x+y$ 提升到 $B_0$（前置头），删除 $U$ 中的 $u := x_J + y_J$，并依赖 $x$ 和 $y$ 在到达 $U$ 之前保持不变来确保在不克隆的情况下保证正确性。", "solution": "### 步骤 1：提取已知信息\n\n问题陈述提供了以下信息：\n- **优化目标**：对表达式 $x+y$ 应用非推测性部分冗余消除 (PRE)。\n- **约束**：表达式 $x+y$ 可能会引发异常（整数溢出），所以 PRE 必须是非推测性的。这意味着编译器不能在原始程序中不计算 $x+y$ 的任何控制流路径上引入新的 $x+y$ 求值。\n- **程序表示**：使用静态单赋值 (SSA) 的控制流图 (CFG)。\n- **CFG 结构和基本块**：\n    - $B_0$：初始化 $x := a$，$y := b$。根据谓词 $p$ 分支到 $B_1$ 或 $B_2$。\n    - $B_1$：计算 $t := x + y$。跳转到 $J$。\n    - $B_2$：更新 $y := y + 1$。跳转到 $J$。\n    - $J$：一个汇合块，合并来自 $B_1$ 和 $B_2$ 的路径。它包含 SSA 合并函数：$x_J := \\phi(x_{B_1}, x_{B_2})$ 和 $y_J := \\phi(y_{B_1}, y_{B_2})$。跳转到 $S$。\n    - $S$：根据谓词 $q$ 分支。如果 $q$ 为真，跳转到 $U$。如果 $q$ 为假，跳转到 $N$。\n    - $U$：计算 $u := x_J + y_J$，使用结果 $u$。跳转到 $E$。\n    - $N$：执行无关工作，不使用或计算 $x+y$。跳转到 $E$。\n    - $E$：退出块。\n- **假设**：\n    - 变量 $x$ 和 $y$ 在块 $J, S, U, N$ 中不被修改。\n    - 在 $U$ 中的计算 $u := x_J + y_J$ 是 $S \\to U$ 路径上的唯一计算。\n    - 在原始程序中，$S \\to N$ 路径上没有对 $x+y$ 的求值。\n- **问题观察**：表达式 $x+y$ 在块 $U$ 处是部分冗余的。它在路径 $B_0 \\to B_1 \\to J \\to S \\to U$ 上是可用的（在 $B_1$ 中计算），但在路径 $B_0 \\to B_2 \\to J \\to S \\to U$ 上不可用。\n- **挑战**：标准的 PRE 会将计算提升到支配 $U$ 的块，例如 $J$ 或 $S$。然而，这会导致 $x+y$ 在通往 $N$ 的路径上（特别是 $... \\to J \\to S \\to N$）被求值，违反了非推测性约束。\n- **问题**：确定哪种代码重构（通过代码克隆/尾部复制）可以实现有效的、非推测性的 PRE 转换，从而使 $u := x_J + y_J$ 完全冗余。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n1.  **科学基础**：该问题牢固地植根于编译器设计原则。部分冗余消除 (PRE)、控制流图 (CFG)、静态单赋值 (SSA)、非推测性执行和代码复制（尾部复制）都是编译器优化理论中标准的、成熟的概念。对加法等算术运算可能引发异常的担忧是现代编译器必须处理的一个实际问题。\n2.  **良构性**：该问题结构清晰。它定义了一个初始状态（CFG 和数据流）、一个明确的目标（消除 $U$ 中的冗余计算）、一个关键约束（非推测性），并要求使用特定的转换技术（代码克隆）来实现该目标。该描述允许推导出一个唯一的、合乎逻辑的解决方案。\n3.  **客观性**：语言精确且无偏见。它使用了计算机科学的标准术语。问题设置是程序片段的形式化表示，不含主观因素。\n\n该问题没有违反任何无效性标准。它在事实上是合理的，是可形式化的，是完整的，在编译器理论的背景下是现实的，并且不是微不足道的。\n\n### 步骤 3：结论与行动\n\n问题陈述是**有效的**。我将继续推导解决方案。\n\n### 问题分析与解决方案推导\n\n问题的核心是数据流（表达式 $x+y$ 的可用性）和控制流（$J$ 处的合并和 $S$ 处的分支）之间的相互作用。\n- 在来自 $B_1$ 的路径上，$x+y$ 被计算并且其值在 $U$ 处可用。假设来自 $B_0$ 的值为 $x_0$ 和 $y_0$。$B_1$ 计算 $t := x_0 + y_0$。从 $B_1$ 进入 $J$ 的值是 $(x_0, y_0)$。\n- 在来自 $B_2$ 的路径上，$y$ 的值被改变。$B_2$ 计算 $y' := y_0 + 1$。从 $B_2$ 进入 $J$ 的值是 $(x_0, y')$。表达式 $x+y$ 没有被计算。\n\n在块 $J$ 处，SSA $\\phi$ 函数合并这些值。为简单起见，我们假设在 SSA 表示上追踪这些值。\n- $x_J := \\phi(x_{from\\_B1}, x_{from\\_B2})$。由于 $x$ 在 $B_1$ 或 $B_2$ 中没有改变，所以 $x_J$ 就是来自 $B_0$ 的 $x$ 的值。\n- $y_J := \\phi(y_{from\\_B1}, y_{from\\_B2})$。这意味着如果控制流来自 $B_1$，$y_J$ 将是来自 $B_1$ 的值；如果控制流来自 $B_2$，$y_J$ 将是来自 $B_2$ 的值。\n\n$U$ 中的计算是 $u := x_J + y_J$。\n- 如果路径是 $B_1 \\to J \\to S \\to U$，那么 $x_J+y_J$ 等同于在 $B_1$ 中计算的原始 $x+y$。它是冗余的。\n- 如果路径是 $B_2 \\to J \\to S \\to U$，那么 $x_J+y_J$ 是一个新的计算（使用了修改后的 $y$）。它不是冗余的。\n\n因此，表达式 $x_J + y_J$ 是部分冗余的。为了使其完全冗余，我们需要在它到达 $U$ 之前，在来自 $B_2$ 的路径上计算它。执行此操作的最晚点是在 $B_2$ 中。最早点是在新 $y$ 定义之后。假设我们将其插入 $B_2$。然而，经典的 PRE 算法会尝试将计算尽可能地向上提升。将 $x_J+y_J$ 提升到 $J$ 或 $S$ 是有问题的，因为存在到 $N$ 的分支：\n- 路径 $B_0 \\to B_1 \\to J \\to S \\to N$\n- 路径 $B_0 \\to B_2 \\to J \\to S \\to N$\n这两条路径最初在块 $B_0$ 之后都不计算 $x+y$。将计算放置在 $J$ 或 $S$ 中会将其引入两条路径，违反了非推测性约束。\n\n解决方案是重构控制流，以将需要计算的路径与不需要计算的路径隔离开。这可以通过从合并点 $J$ 开始复制图的“尾部”来实现。这为 $J$ 的前驱节点创建了独立的控制流路径。\n\n所需的转换是为来自 $B_1$ 和 $B_2$ 的两条路径分别复制块 $J, S, U$。\n1.  **为来自 $B_1$ 的路径克隆**：创建副本 $J_1, S_1, U_1$。控制流变为 $B_1 \\to J_1 \\to S_1$。块 $S_1$ 根据 $q$ 分支：如果为真，则跳转到 $U_1$；如果为假，则可以跳转到原始的 $N$。\n2.  **为来自 $B_2$ 的路径克隆**：创建副本 $J_2, S_2, U_2$。控制流变为 $B_2 \\to J_2 \\to S_2$。块 $S_2$ 根据 $q$ 分支：如果为真，则跳转到 $U_2$；如果为假，则可以跳转到原始的 $N$。\n\n现在让我们分析这些新的、分离的路径上的数据流：\n- **路径 $B_1 \\to J_1 \\to S_1 \\to U_1$**：在 $B_1$ 中计算的值 $t$ 在整条路径上都可用。因此，$U_1$ 中的计算 $u := x+y$ 是完全冗余的，可以用一个移动操作代替，例如 $u:=t$。\n- **路径 $B_2 \\to J_2 \\to S_2 \\to U_2$**：表达式 $x+y$（使用来自 $B_2$ 的修改后的 $y$）不可用。为了使其在 $U_2$ 中变得冗余，我们必须插入一个新的计算。关键点是*在哪里*插入它。如果路径通往 $N$，我们决不能执行它。区分通往 $U_2$ 的路径和通往 $N$ 的路径的分支发生在 $S_2$。因此，插入计算的正确位置是在 $S_2$ 的分支逻辑*之后*，但在 $U_2$ 的计算*之前*。这可以建模为在边 $S_2 \\to U_2$ 上或在 $U_2$ 的最开始处插入它。让我们称新的临时变量为 $t_2$。我们在边 $S_2 \\to U_2$ 上插入 $t_2 := x+y$。然后，$U_2$ 中的计算变得完全冗余，可以被替换为 $u := t_2$。\n\n这种转换成功地消除了 $U$ 中的部分冗余，而没有在通往 $N$ 的路径上引入任何推测性计算。\n\n### 逐项分析选项\n\n- **A. 此选项正确地指出了需要进行尾部复制，为来自 $B_1$ 和 $B_2$ 的流创建了独立的路径。它正确地描述了如何处理每条路径：在一条路径上复用来自 $B_1$ 的现有计算，并在另一条路径上插入新的计算。关键是，它指明了将新计算插入“仅在 $S_2$ 的 $q$-true 边上”，这是满足非推测性约束的正确位置。这确保了新计算仅在程序确定要走通往 $U$ 而非 $N$ 的路径时才执行。它还正确地指出了在原始汇合点 $J$ 处消除非平凡 $\\phi$ 函数的副作用。措辞“重定向 $B_1 \\to J_1 \\to S_1 \\to U_1$”是一个轻微的简化，因为 $S_1$ 是一个条件分支，但从上下文中可以清楚地看出其意图。该转换的总体描述是准确和完整的。结论：**正确**。\n\n- **B. 这种转换是不够的。新的 CFG 将有 $J_1 \\to S$ 和 $J_2 \\to S$。块 $S$ 将成为新的合并点。该选项建议在 $J_2$ 中插入 $x+y$。现在考虑路径 $B_2 \\to J_2 \\to S \\to N$。这条路径现在包含了来自块 $J_2$ 的新 $x+y$ 计算。原始路径没有这个计算。这违反了非推测性约束。结论：**不正确**。\n\n- **C. 这种转换在这种情况下是无意义的。克隆一个作为合并点前驱的块，并不会改变 $J$（合并）和 $S$（分支）处有问题的控制流结构。$U$ 处的部分冗余是由缺少计算的 $B_2$ 路径引起的。克隆 $B_1$ 对处理来自 $B_2$ 的路径毫无作用。表达式 $x_J+y_J$ 在 $U$ 处仍将是部分冗余的。结论：**不正确**。\n\n- **D. 该选项提出了推测性执行。问题陈述明确禁止这样做：“因为 $x+y$ 可能引发溢出异常，非推测性 PRE 不得在 $S \\to N$ 路径上引入任何新的 $x+y$ 执行。”将计算提升到 $B_0$ 意味着无论之后走哪条路径，它都会被执行。如果走了路径 $... \\to S \\to N$，一个不必要且可能出错的计算就被执行了。这直接违反了给定的约束。结论：**不正确**。\n\n根据分析，只有选项 A 正确描述了在给定约束下实现目标的有效转换。", "answer": "$$\\boxed{A}$$", "id": "3661855"}]}