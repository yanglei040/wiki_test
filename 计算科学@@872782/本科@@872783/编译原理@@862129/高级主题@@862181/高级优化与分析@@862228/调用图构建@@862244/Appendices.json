{"hands_on_practices": [{"introduction": "在过程式语言（如C语言）中，函数指针是实现动态行为的关键，但同时也为静态分析带来了挑战。本练习将指导你使用一种基础但强大的技术——指针分析（Points-to Analysis），来为一段C语言代码构建调用图。通过系统地应用一系列基于包含关系的规则，你将学会如何解析通过复杂数据结构传递的函数指针目标，这是静态分析中的一项核心技能。[@problem_id:3625920]", "problem": "一个编译器必须为一个C程序构建一个保守调用图，该程序使用存储在结构体中并通过结构体访问的函数指针。假设该分析是一个全程序、流不敏感、上下文不敏感、基于包含关系的点对分析（通常称为Andersen风格）。该分析对结构体是字段敏感的（每个不同分配点或变量的每个不同结构体字段都会产生其自己的抽象字段位置），但数组元素被以合并的方式建模，即每个数组变量只有一个抽象数组元素位置。函数名被建模为抽象函数标签位置。该分析遵循以下基本规则，这些规则在本问题中被视为核心定义：\n\n- 取地址：如果赋值形式为 x = y，则 y 的抽象位置被包含在点对集 $\\mathrm{Pt}(x)$ 中。\n- 拷贝：如果赋值形式为 x = y，则 $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(y)$。\n- 通过指向结构体字段的指针进行存储：如果赋值为 x-f = y，则对于 $\\mathrm{Pt}(x)$ 中的每个抽象位置 $o$，关系 $\\mathrm{Pt}(o.f) \\supseteq \\mathrm{Pt}(y)$ 成立。如果 y 是一个函数名，则将该函数标签包含在 $\\mathrm{Pt}(o.f)$ 中。\n- 从结构体字段加载：如果赋值为 x = y-f，则对于 $\\mathrm{Pt}(y)$ 中的每个抽象位置 $o$，关系 $\\mathrm{Pt}(x) \\supseteq \\mathrm{Pt}(o.f)$ 成立。\n- 合并数组：对于数组变量 arr，所有元素写入 arr[$i$] = y 都会更新单个抽象元素位置 arr$[\\ast]$，因此 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(y)$；读取 x = arr[$i$] 则从 $\\mathrm{Pt}(\\text{arr}[\\ast])$ 加载。\n\n调用图包含一个从间接调用点到函数标签的有向边，对于该调用点的函数指针表达式的点对集中的每个函数，都存在这样一条边（根据上述点对语义）。如果两条边共享相同的被调用者但源于不同的调用点，则它们被视为不同的边。设调用点被标识为 $c_{1}$ 和 $c_{2}$。\n\n考虑以下C程序片段（仅显示类型和语句；其他代码如函数体与分析无关）：\n\n```c\ntypedef void (*F)(int);\n\nvoid A(int x) {}\nvoid B(int x) {}\nvoid C(int x) {}\nvoid D(int x) {}\n\nstruct S { F f; };\nstruct T { struct S *ps; F g; };\n\nint main() {\n  struct S s1, s2, s3;\n  struct T t1, t2;\n  struct S *p, *q;\n  struct T *pt;\n  struct S *arr[2];\n\n  s1.f = A;\n  s2.f = B;\n  s3.f = C;\n\n  t1.ps = \n  t2.ps = \n\n  p = \n  q = p;\n  q->f = B;\n\n  t1.g = D;\n\n  arr[0] = \n  arr[1] = t2.ps;\n\n  if (/* unknown */) { pt =  } else { pt =  }\n\n  /* c1 */ pt->ps->f(/* arg */);\n  /* c2 */ arr[i]->f(/* arg */);\n}\n```\n\n仅使用上述基本规则，推导出解析两个间接调用点 $c_{1}$ 和 $c_{2}$ 的潜在目标所需的最不保守的点对信息：\n- $c_{1}$ 是调用 pt-ps-f(...)\n- $c_{2}$ 是调用 arr[i]-f(...)\n\n将数组 arr 视为合并为单个抽象元素位置 arr$[\\ast]$，并假设 $i$ 在编译时未知。同时假设分析不会添加隐式的空值或未初始化的值；存在的抽象位置仅限于程序中的赋值语句和函数标签引入的位置。\n\n从第一性原理出发，计算分析所蕴含的独立间接调用图边的总数，将边计为有序对 $(c_{j}, \\text{callee})$。请提供您的最终答案，形式为一个精确值的整数（不进行四舍五入）。", "solution": "该问题要求为给定的C程序片段构建一个保守调用图。分析方法被指定为全程序、流不敏感、上下文不敏感、基于包含关系的点对分析。这是一种标准的Andersen风格分析。该分析进一步被定义为对结构体是字段敏感的，但对数组是字段不敏感的（合并的）。\n\n首先，我们必须验证问题陈述。\n1.  **提取已知信息**：问题提供了一个C代码片段，一套用于点对分析的特定规则（取地址、拷贝、存储、加载、数组合并），以及根据点对集构建调用图边的定义。目标是计算从两个指定的调用点 $c_1$ 和 $c_2$ 出发的间接调用图边的总数。\n2.  **验证**：该问题在编译器静态分析这一成熟领域中有科学依据。Andersen风格分析的规则是标准的。问题陈述清晰，提供了所有必要信息，可以根据给定规则推导出唯一解。语言客观而精确。该问题不违反任何无效性标准。\n3.  **结论**：该问题是有效的。\n\n我们现在开始求解。该分析是流不敏感的，因此我们将 `main` 函数中的所有赋值语句作为一个必须同时成立的约束集合来处理。点对关系是基于包含的，这意味着一个抽象位置 $L$ 的点对集，记为 $\\mathrm{Pt}(L)$，只会随着约束的增加而增长。\n\n让我们定义抽象位置。栈上分配的结构体变量 `s1`、`s2`、`s3`、`t1` 和 `t2` 是不同的抽象位置，我们将其表示为 $s_1, s_2, s_3, t_1, t_2$。它们的字段产生不同的抽象字段位置，例如 $s_1.f$、$t_1.ps$。函数名 `A`、`B`、`C`、`D` 代表不同的函数标签位置。指针变量 `p`、`q`、`pt` 拥有点对集 $\\mathrm{Pt}(p)$、$\\mathrm{Pt}(q)$、$\\mathrm{Pt}(pt)$。数组 `arr` 被合并为单个抽象元素位置 $\\text{arr}[\\ast]$。\n\n我们通过将给定规则应用于每个赋值语句来推导点对集：\n1.  `s1.f = A;`: 这创建了关系 $A \\in \\mathrm{Pt}(s_1.f)$。\n2.  `s2.f = B;`: 这创建了关系 $B \\in \\mathrm{Pt}(s_2.f)$。\n3.  `s3.f = C;`: 这创建了关系 $C \\in \\mathrm{Pt}(s_3.f)$。\n4.  `t1.ps = `: 取地址规则意味着 $s_1 \\in \\mathrm{Pt}(t_1.ps)$。注意 `t1.ps` 是一个字段，而不是一个指针变量，因此它直接包含该抽象位置。更准确地说，赋值 `x.f = ` 意味着 $y \\in \\mathrm{Pt}(x.f)$。\n5.  `t2.ps = `: 类似地，$s_2 \\in \\mathrm{Pt}(t_2.ps)$。\n6.  `p = `: 取地址规则意味着 $s_1 \\in \\mathrm{Pt}(p)$。\n7.  `q = p;`: 拷贝规则规定 $\\mathrm{Pt}(q) \\supseteq \\mathrm{Pt}(p)$。根据上一步，这意味着 $s_1 \\in \\mathrm{Pt}(q)$。\n8.  `q-f = B;`: 这是通过指针存储的规则。对于 $\\mathrm{Pt}(q)$ 中的每个抽象位置 $o$，我们添加约束 $\\mathrm{Pt}(o.f) \\supseteq \\{B\\}$。由于 $\\mathrm{Pt}(q) = \\{s_1\\}$，这意味着 $\\mathrm{Pt}(s_1.f) \\supseteq \\{B\\}$。因为分析是基于包含关系的，我们将其与约束（1）结合，得到 $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$。\n9.  `t1.g = D;`: 这意味着 $D \\in \\mathrm{Pt}(t_1.g)$。此信息对于目标调用点没有用，但是完整分析状态的一部分。\n10. `arr[0] = `: 合并数组规则意味着 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_3\\}$。\n11. `arr[1] = t2.ps;`: 这是从一个结构体字段拷贝到一个合并数组元素。它转化为约束 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\mathrm{Pt}(t_2.ps)$。根据约束（5），$\\mathrm{Pt}(t_2.ps)=\\{s_2\\}$，所以我们有 $\\mathrm{Pt}(\\text{arr}[\\ast]) \\supseteq \\{s_2\\}$。与（10）结合，我们得到 $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$。\n12. `if (/*...*/) { pt =  } else { pt =  }`: 流不敏感意味着两个分支都被考虑。这给出了两个约束：$t_1 \\in \\mathrm{Pt}(pt)$ 和 $t_2 \\in \\mathrm{Pt}(pt)$。因此，$\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$。\n\n与调用点相关的最终点对集总结如下：\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$\n- $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$\n- $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$\n- $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$\n- $\\mathrm{Pt}(s_2.f) = \\{B\\}$\n- $\\mathrm{Pt}(s_3.f) = \\{C\\}$\n- $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$\n\n现在我们解析每个调用点的调用目标。\n\n**调用点 $c_1$：`pt-ps-f(/* arg */)`**\n被调用的函数由表达式 `pt-ps-f` 的点对集决定。我们逐步解析这个表达式。\n首先，我们找到 `pt-ps` 指向的位置集合。让我们使用一个临时抽象指针 `temp_1`。表达式 `temp_1 = pt-ps` 对应于加载操作 `x = y-f`，其中 `x` 是 `temp_1`，`y` 是 `pt`，`f` 是 `ps`。\n规则是：对于每个 $o \\in \\mathrm{Pt}(pt)$，我们有 $\\mathrm{Pt}(\\text{temp}_1) \\supseteq \\mathrm{Pt}(o.ps)$。\n- $\\mathrm{Pt}(pt) = \\{t_1, t_2\\}$。\n- 对于 $o = t_1$，我们将 $\\mathrm{Pt}(t_1.ps) = \\{s_1\\}$ 添加到 $\\mathrm{Pt}(\\text{temp}_1)$。\n- 对于 $o = t_2$，我们将 $\\mathrm{Pt}(t_2.ps) = \\{s_2\\}$ 添加到 $\\mathrm{Pt}(\\text{temp}_1)$。\n- 因此，`pt-ps` 的位置集合是 $\\mathrm{Pt}(\\text{temp}_1) = \\{s_1, s_2\\}$。\n\n接下来，我们解析调用目标 `temp_1-f`。潜在被调用者的集合是 $\\mathrm{Pt}(\\text{temp}_1)$ 中每个位置的 `.f` 字段的点对集的并集。\n- 对于位置 $s_1 \\in \\mathrm{Pt}(\\text{temp}_1)$，被调用者来自 $\\mathrm{Pt}(s_1.f) = \\{A, B\\}$。\n- 对于位置 $s_2 \\in \\mathrm{Pt}(\\text{temp}_1)$，被调用者来自 $\\mathrm{Pt}(s_2.f) = \\{B\\}$。\n$c_1$ 的总目标集合是并集 $\\{A, B\\} \\cup \\{B\\} = \\{A, B\\}$。\n这产生了两个不同的调用图边：$(c_1, A)$ 和 $(c_1, B)$。\n\n**调用点 $c_2$：`arr[i]-f(/* arg */)`**\n函数由 `arr[i]-f` 的点对集决定。\n首先，我们解析 `arr[i]`。让它由一个临时指针 `temp_2` 表示。这是一个数组加载 `x = arr[i]`，其中 `x` 是 `temp_2`。\n合并数组的规则是 $\\mathrm{Pt}(\\text{temp}_2) \\supseteq \\mathrm{Pt}(\\text{arr}[\\ast])$。\n- 我们已经确定 $\\mathrm{Pt}(\\text{arr}[\\ast]) = \\{s_2, s_3\\}$。\n- 因此，`arr[i]` 的位置集合是 $\\mathrm{Pt}(\\text{temp}_2) = \\{s_2, s_3\\}$。\n\n接下来，我们解析调用目标 `temp_2-f`。被调用者是 $\\mathrm{Pt}(\\text{temp}_2)$ 中每个位置的 `.f` 字段的点对集的并集。\n- 对于位置 $s_2 \\in \\mathrm{Pt}(\\text{temp}_2)$，被调用者来自 $\\mathrm{Pt}(s_2.f) = \\{B\\}$。\n- 对于位置 $s_3 \\in \\mathrm{Pt}(\\text{temp}_2)$，被调用者来自 $\\mathrm{Pt}(s_3.f) = \\{C\\}$。\n$c_2$ 的总目标集合是并集 $\\{B\\} \\cup \\{C\\} = \\{B, C\\}$。\n这产生了两个不同的调用图边：$(c_2, B)$ 和 $(c_2, C)$。\n\n**总边数**\n问题规定，即使被调用者相同，来自不同调用点的边也是不同的。不同的边是：\n1.  $(c_1, A)$\n2.  $(c_1, B)$\n3.  $(c_2, B)$\n4.  $(c_2, C)$\n\n独立的间接调用图边的总数是每个调用点产生的边数之和：$2 + 2 = 4$。", "answer": "$$\\boxed{4}$$", "id": "3625920"}, {"introduction": "本练习从通用的指针追踪转向分析一种更结构化的模式：通过函数指针数组进行的间接调用。你将使用区间分析（Interval Analysis）来保守地确定可能的调用目标，这展示了编译器如何处理有界但编译时未知的数组索引。这个过程阐明了如何针对特定的编程范式定制分析方法，以在效率和精度之间取得平衡。[@problem_id:3625866]", "problem": "您正在为一个使用函数指针数组执行间接调用的程序构建一个上下文不敏感的调用图。该调用图定义在函数集合上，其中函数为节点。如果调用函数 $X$ 内部至少存在一个可能调用 $Y$ 的调用点，则存在一条从 $X$ 到被调用函数 $Y$ 的有向边。对于一个通过函数指针数组元素 $a[r]$ 进行调用的调用点，如果其数组索引 $r$ 在编译时无法精确得知，您将使用来自抽象解释的区间抽象：该索引被保守地近似为一个整数区间 $[l,u]$，意味着任何 $r \\in \\{l,l+1,\\dots,u\\}$ 都是可能的。您必须添加从外围调用函数到所有可能位于 $a[r]$（对于某个 $r \\in [l,u]$）中的函数的边。如果同一调用者内部的多个调用点可能到达同一个被调用者，您只需在该调用者和被调用者之间添加一条边。假设采用从零开始的索引、包含边界，以及一个标准的类C内存模型，其中 $a$ 没有别名。\n\n全局数组 $a$ 的长度为12，其内容为编译时常量，如下所示（等于 $\\mathtt{NULL}$ 的条目表示一个静态已知的空指针，它不能被调用，因此不贡献任何目标）：\n- $a[0] = u_{0}$, $a[1] = u_{1}$, $a[2] = u_{1}$, $a[3] = u_{2}$,\n- $a[4] = \\mathtt{NULL}$, $a[5] = u_{3}$, $a[6] = u_{3}$,\n- $a[7] = u_{4}$, $a[8] = u_{5}$, $a[9] = u_{5}$,\n- $a[10] = u_{6}$, $a[11] = \\mathtt{NULL}$.\n\n有三个调用函数，$F$、$G$ 和 $H$，每个都包含通过 $a[\\cdot]$ 的间接调用点，其区间信息从编译器的区间分析中得知如下：\n- 在 $F$ 内部有两个间接调用点：一个通过 $a[i]$ 调用，其中 $i \\in [3,8]$；另一个通过 $a[j]$ 调用，其中 $j \\in [5,10]$。\n- 在 $G$ 内部有一个间接调用点：它通过 $a[k]$ 调用，其中 $k \\in [0,4]$。\n- 在 $H$ 内部有一个间接调用点：它通过 $a[m]$ 调用，其中 $m \\in [7,11]$。\n\n仅使用上述调用图的基本定义和基于区间的间接调用保守解析方法，确定由于这些间接调用而必须添加到调用图中的不同调用者到被调用者边的总数。每个 $(\\text{调用者},\\text{被调用者})$ 对最多计数一次，即使同一调用者内部的多个调用点可以到达同一个被调用者。请以单个整数形式提供最终答案。无需四舍五入。", "solution": "我们从核心定义开始。一个定义在函数集合上的调用图，如果调用者函数中存在一个可能调用被调用者函数的调用点，则存在一条从调用者到被调用者的有向边。对于通过函数指针数组元素 $a[r]$ 进行的间接调用，若其索引被近似为一个区间 $[l,u]$，那么为了保证健全性，需要从外围的调用者向所有可能位于 $a[r]$（对于某个 $r \\in \\{l,l+1,\\dots,u\\}$）中的函数添加边，并排除值为 $\\mathtt{NULL}$ 的条目。在一个上下文不敏感的调用图中，同一调用者内部到达同一被调用者的多个调用点，只贡献该调用者与被调用者之间的一条边。因此，对于每个调用者，我们必须计算其所有调用点的潜在目标函数的并集，并计算不同目标的数量；然后我们将这些计数按调用者相加，因为边被定义为 $(\\text{调用者},\\text{被调用者})$ 对。\n\n我们已知数组 $a$ 的确切内容：\n- $a[0] = u_{0}$,\n- $a[1] = u_{1}$,\n- $a[2] = u_{1}$,\n- $a[3] = u_{2}$,\n- $a[4] = \\mathtt{NULL}$,\n- $a[5] = u_{3}$,\n- $a[6] = u_{3}$,\n- $a[7] = u_{4}$,\n- $a[8] = u_{5}$,\n- $a[9] = u_{5}$,\n- $a[10] = u_{6}$,\n- $a[11] = \\mathtt{NULL}$.\n\n我们现在分析每个调用者。\n\n对于调用者 $F$，有两个调用点，其索引区间分别为 $[3,8]$ 和 $[5,10]$。\n- 对于 $i \\in [3,8]$，索引为 $3,4,5,6,7,8$，产生的可能条目为 $a[3]=u_{2}$、$a[4]=\\mathtt{NULL}$、$a[5]=u_{3}$、$a[6]=u_{3}$、$a[7]=u_{4}$、$a[8]=u_{5}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合为 $\\{u_{2},u_{3},u_{4},u_{5}\\}$。\n- 对于 $j \\in [5,10]$，索引为 $5,6,7,8,9,10$，产生的条目为 $a[5]=u_{3}$、$a[6]=u_{3}$、$a[7]=u_{4}$、$a[8]=u_{5}$、$a[9]=u_{5}$、$a[10]=u_{6}$。此范围内没有 $\\mathtt{NULL}$ 条目，目标集合为 $\\{u_{3},u_{4},u_{5},u_{6}\\}$。\n- 对 $F$ 内部两个调用点的目标集合取并集，得到 $\\{u_{2},u_{3},u_{4},u_{5},u_{6}\\}$。\n因此，$F$ 贡献了到 5 个不同被调用者的边。\n\n对于调用者 $G$，有一个调用点，其中 $k \\in [0,4]$，即索引为 $0,1,2,3,4$。这些条目为 $a[0]=u_{0}$、$a[1]=u_{1}$、$a[2]=u_{1}$、$a[3]=u_{2}$、$a[4]=\\mathtt{NULL}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合为 $\\{u_{0},u_{1},u_{2}\\}$。因此，$G$ 贡献了到 3 个不同被调用者的边。\n\n对于调用者 $H$，有一个调用点，其中 $m \\in [7,11]$，即索引为 $7,8,9,10,11$。这些条目为 $a[7]=u_{4}$、$a[8]=u_{5}$、$a[9]=u_{5}$、$a[10]=u_{6}$、$a[11]=\\mathtt{NULL}$。排除 $\\mathtt{NULL}$ 后，可能的目标集合为 $\\{u_{4},u_{5},u_{6}\\}$。因此，$H$ 贡献了到 3 个不同被调用者的边。\n\n因为调用图是基于调用者-被调用者对定义的，并且我们对每个调用者，每个这样的对最多只计数一次，所以由于这些间接调用而添加的不同边的总数是各个调用者的不同目标集大小之和：\n$$\n|E| \\;=\\; 5 \\;+\\; 3 \\;+\\; 3 \\;=\\; 11.\n$$\n不同调用者之间不需要进一步去重，因为根据定义，调用者不同的边即为不同的边。因此，总数是 $11$。", "answer": "$$\\boxed{11}$$", "id": "3625866"}, {"introduction": "现在，我们将目光转向面向对象编程范式，这里的调用图构建依赖于对类继承体系和对象类型的分析。这个问题要求你应用快速类型分析（Rapid Type Analysis, RTA）来区分静态绑定（`super`调用）和动态绑定（`this`调用）。通过这个练习，你将亲身体会到利用运行时类型信息（哪些类被实例化）如何能够显著地精化调用图，从而提高分析的精度。[@problem_id:3625899]", "problem": "考虑一个类似Java的、单继承、名义类型、静态类型的面向对象语言，其中所有实例方法都是虚拟的，并且形式为 super.m() 的表达式使用直接超类解析规则。假设进行全程序、上下文不敏感、流不敏感的快速类型分析（RTA），其定义如下：给定一个实例方法体内的调用点，该调用点的接收者类型集 $T(\\text{this})$ 是在被分析程序中可能动态调用该外围方法的所有运行时类的集合。对于一个虚拟调用 this.m()，调用图会为每个接收者类 $R \\in T(\\text{this})$ 添加一条边，指向动态查找所选出的唯一目标；如果不同的接收者映射到同一个目标方法，重复的边将被合并。对于一个 super调用 super.m()，调用图会添加一条边，指向在调用词法上出现的那个类的直接超类中定义的方法体；这个目标不依赖于 $T(\\text{this})$。\n\n类层次结构和方法如下（方法体除了包含调用的部分外均不相关）：\n- 类 A 定义了实例方法 m()、n() 和 k()。\n- 类 B 继承 A 并重写了 m() 和 n()。类 B 还额外定义了一个实例方法 t()，其方法体按顺序包含四个调用点：super.m()、this.m()、super.n()、this.n()。\n- 类 C 继承 B 并重写了 m() 但没有重写 n()。\n- 类 D 继承 B 并重写了 n() 但没有重写 m()。\n\n入口点执行的分配和调用如下：\n- 分配一个 B 的实例和一个 C 的实例。\n- 在这两个已分配的实例上调用 t()（例如，通过静态类型为 B 的变量）。\n- D 的实例从未被分配，也没有其他分配或调用。\n\n仅使用上述语义和单继承的基本动态方法查找规则——即，在一个动态类为 $R$ 的接收者上的虚拟调用，会解析为通过搜索 $R$ 及其超类等找到的、在静态接收者类型中声明的方法的最具体重写版本——来构建由 B.t() 方法体中四个调用点贡献的调用图边。在指定的快速类型分析下，计算这四个调用点添加的不同调用图边的总数。用一个整数表示你的答案。不需要四舍五入。", "solution": "首先验证问题，以确保其自洽、有科学依据且定义明确。\n\n### 步骤 1：提取已知条件\n- **语言和语义**：一个类似Java的、单继承、名义类型、静态类型的面向对象语言。所有实例方法都是虚拟的。`super.m()` 调用解析到包含该调用点的类的直接超类中的方法。\n- **分析类型**：全程序、上下文不敏感、流不敏感的快速类型分析（RTA）。\n- **RTA 对虚拟调用的定义**：对于方法内的虚拟调用 `this.m()`，对于每个运行时类 $R \\in T(\\text{this})$，调用图包含一条指向通过动态查找解析出的目标方法的边。$T(\\text{this})$ 是可以调用该外围方法的所有运行时类的集合。指向同一目标的重复边将被合并。\n- **RTA 对 Super 调用的定义**：对于 `super.m()` 调用，会添加一条边，指向在调用词法上出现的那个类的直接超类中定义的方法。此解析独立于 $T(\\text{this})$。\n- **类层次结构**：\n    - `类 A` 定义了方法 $m()$、$n()$ 和 $k()$。\n    - `类 B 继承 A` 并重写了 $m()$ 和 $n()$。它定义了一个新方法 $t()$，其方法体包含调用：`super.m()`、`this.m()`、`super.n()`、`this.n()`。\n    - `类 C 继承 B` 并重写了 $m()$。它没有重写 $n()$。\n    - `类 D 继承 B` 并重写了 $n()$。它没有重写 $m()$。\n- **程序执行（入口点）**：\n    - 分配了一个类 $B$ 的实例。\n    - 分配了一个类 $C$ 的实例。\n    - 方法 $t()$ 在 $B$ 的实例和 $C$ 的实例上都被调用。\n    - 类 $D$ 的实例从未被分配。\n    - 程序中没有发生其他分配或调用。\n- **任务**：确定由 $B.t()$ 方法体内的四个调用点添加的不同调用图边的总数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题定义明确，并基于编译器设计和程序分析的既定原则。\n- **科学依据**：该问题描述了快速类型分析（RTA）和标准的面向对象分派语义（虚拟调用和super调用），这些都是编译器理论的核心概念。该模型是对这类分析工作方式的简化但准确的表示。\n- **定义明确**：类层次结构、方法定义和程序行为都得到了精确的说明。构建调用图的规则是明确的。这种设置允许一个唯一且可确定的解。\n- **客观和完整**：问题以正式、无歧义的术语陈述。提供了执行分析所需的所有必要信息。没有矛盾之处。\n\n### 步骤 3：结论与行动\n问题是有效的。将提供一个合理的解答。\n\n### 解答\n目标是计算源自方法 $B.t()$ 中四个调用点的不同调用图边的数量。这需要识别方法 $B.t()$ 的可能运行时接收者类型的集合，然后根据快速类型分析（RTA）的规则分析每个调用点。\n\n**1. 确定 $B.t()$ 的接收者类型集**\n方法 $B.t()$ 的RTA接收者类型集（表示为 $T(\\text{this})$）是方法 $t()$ 被动态调用的所有对象的运行时类的集合。\n- 程序分配了一个类 $B$ 的实例，并在此实例上调用 $t()$。接收者的动态类型是 $B$。在 $B$ 对象上对 $t()$ 进行动态分派时，从类 $B$ 开始。由于 $B$ 定义了 $t()$，调用解析为 $B.t()$。因此，$B \\in T(\\text{this})$。\n- 程序分配了一个类 $C$ 的实例，并在此实例上调用 $t()$。接收者的动态类型是 $C$。在 $C$ 对象上对 $t()$ 进行动态分派时，从类 $C$ 开始。类 $C$ 没有定义 $t()$，所以搜索进入其超类 $B$。类 $B$ 定义了 $t()$，所以调用解析为 $B.t()$。因此，$C \\in T(\\text{this})$。\n- 类 $D$ 的实例从未被分配，因此它不能成为任何方法调用的接收者。\n根据全程序信息，可能动态调用 $B.t()$ 的运行时类的集合是 $\\{B, C\\}$。因此，对于 $B.t()$ 内的所有调用点，接收者类型集为 $T(\\text{this}) = \\{B, C\\}$。\n\n**2. 分析 $B.t()$ 中的调用点**\n$B.t()$ 的方法体包含四个调用点。我们分析每一个调用点以确定它们贡献的调用图边。\n\n**调用点 1: `super.m()`**\n- 根据RTA对 `super` 调用的规则，目标由词法上下文静态确定。\n- 调用 `super.m()` 出现在方法 $B.t()$ 中，该方法定义在类 $B$ 中。\n- $B$ 的直接超类是 $A$。\n- 调用解析为类 $A$ 中 $m()$ 的实现。\n- 这向调用图添加了一条边：$B.t() \\rightarrow A.m()$。\n\n**调用点 2: `this.m()`**\n- 这是一个虚拟调用。目标取决于 $T(\\text{this}) = \\{B, C\\}$ 中的类型。\n- 对于运行时类型为 $B$ 的接收者：对 $m()$ 的动态查找从类 $B$ 开始。类 $B$ 重写了 $m()$。目标是 $B.m()$。这添加了边 $B.t() \\rightarrow B.m()$。\n- 对于运行时类型为 $C$ 的接收者：对 $m()$ 的动态查找从类 $C$ 开始。类 $C$ 重写了 $m()$。目标是 $C.m()$。这添加了边 $B.t() \\rightarrow C.m()$。\n- 这两个目标，$B.m()$ 和 $C.m()$，是不同的。因此，该调用点贡献了两条不同的边。\n\n**调用点 3: `super.n()`**\n- 这是另一个 `super` 调用，静态解析。\n- 该调用位于类 $B$ 的一个方法中。直接超类是 $A$。\n- 调用解析为类 $A$ 中 $n()$ 的实现。\n- 这向调用图添加了一条边：$B.t() \\rightarrow A.n()$。\n\n**调用点 4: `this.n()`**\n- 这是一个虚拟调用。目标取决于 $T(\\text{this}) = \\{B, C\\}$ 中的类型。\n- 对于运行时类型为 $B$ 的接收者：对 $n()$ 的动态查找从类 $B$ 开始。类 $B$ 重写了 $n()$。目标是 $B.n()$。这添加了边 $B.t() \\rightarrow B.n()$。\n- 对于运行时类型为 $C$ 的接收者：对 $n()$ 的动态查找从类 $C$ 开始。类 $C$ 没有重写 $n()$，所以搜索继续到其超类 $B$。类 $B$ 重写了 $n()$。目标是 $B.n()$。\n- 运行时类型 $B$ 和 $C$ 都解析到同一个目标方法 $B.n()$。RTA 定义规定重复的边被合并。\n- 因此，这个调用点只贡献一条不同的边：$B.t() \\rightarrow B.n()$。\n\n**3. 不同边的总和**\n我们列出由四个调用点从源 $B.t()$ 贡献的所有唯一边：\n1. 从 `super.m()`: $B.t() \\rightarrow A.m()$\n2. 从 `this.m()`: $B.t() \\rightarrow B.m()$\n3. 从 `this.m()`: $B.t() \\rightarrow C.m()$\n4. 从 `super.n()`: $B.t() \\rightarrow A.n()$\n5. 从 `this.n()`: $B.t() \\rightarrow B.n()$\n\n所有五个目标方法（$A.m()$、$B.m()$、$C.m()$、$A.n()$ 和 $B.n()$）都是不同的实现。因此，这五条边是不同的。\n添加的不同调用图边的总数是每次分析得出的边数之和：来自 `super.m()` 的 $1$ 条边，来自 `this.m()` 的 $2$ 条边，来自 `super.n()` 的 $1$ 条边，以及来自 `this.n()` 的 $1$ 条边。\n总边数 = $1 + 2 + 1 + 1 = 5$。", "answer": "$$\n\\boxed{5}\n$$", "id": "3625899"}]}