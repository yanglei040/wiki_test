{"hands_on_practices": [{"introduction": "理解编译器遍（pass）之间的相互作用，对于设计高效的优化流程至关重要。第一个练习 [@problem_id:3629247] 提供了一个简化模型，帮助你量化不同遍顺序所带来的影响，展示了一个遍如何为另一个遍创造机会，以及为何优化顺序至关重要。", "problem": "一个编译器管线包含三个优化遍，它们以某种顺序对单个过程的中间表示各执行一次：全局值编号 (Global Value Numbering, GVN)、循环不变代码外提 (Loop-Invariant Code Motion, LICM) 和死代码消除 (Dead Code Elimination, DCE)。这些优化遍遵循以下基本事实：\n\n- 全局值编号 (GVN) 识别具有相同值语义的计算，并在较早计算的值支配较晚计算时，消除后者这一冗余计算。\n- 循环不变代码外提 (LICM) 将其操作数在迭代中不变的计算从循环体中提升到一个支配该循环的位置（例如循环前置头部）。\n- 死代码消除 (DCE) 移除那些结果未被使用且没有副作用的指令，这是根据先前转换后的数据流分析确定的。\n\n假设该过程包含被划分为不相交组的独立代码模式，每组都可能贡献可被消除的指令，但这取决于优化遍之间的启用关系。设各组的数量为：\n- 类型 $1$：$t_{1} = 7$ 组。每组包含位于不同代码块中的重复的循环不变计算，这些代码块最初互不支配。只有在 $LICM$ 将这些计算提升到一个公共支配节点之后，$GVN$ 才能在每组中消除一个冗余计算。因此，当且仅当 $LICM$ 在管线中先于 $GVN$ 执行时，这些组中才会发生消除；在此情况下，$GVN$ 会为每组精确消除 $1$ 条指令；否则消除 $0$ 条。\n- 类型 $2$：$t_{2} = 5$ 组。每组包含一个 $GVN$ 总是可以消除的冗余，这与 $LICM$ 无关。此外，$GVN$ 转换会为每组精确地暴露出一个额外的死临时变量，当且仅当 $DCE$ 在 $GVN$ 之后运行时，$DCE$ 才能消除它。因此，在所有顺序中，$GVN$ 都会为每个这样的组消除精确 $1$ 条指令，并且仅当 $DCE$ 在 $GVN$ 之后出现时，$DCE$ 才会额外消除 $1$ 条指令。\n- 类型 $3$：$t_{3} = 4$ 组。每组包含一个循环内部的临时变量，其使用仅限于该循环。在 $LICM$ 将不变的生产者提出循环并重写使用点之后，该临时变量变得未使用。仅当 $DCE$ 在 $LICM$ 之后运行时，$DCE$ 才会消除这个临时变量。$GVN$ 对这些组不起作用。因此，当且仅当 $LICM$ 先于 $DCE$ 执行时，才会发生消除；在此情况下，$DCE$ 会为每组精确消除 $1$ 条指令；否则消除 $0$ 条。\n- 类型 $4$：$t_{4} = 6$ 组。每组需要一个启用链：首先 $LICM$ 必须进行提升以在重复计算之间建立支配关系；然后 $GVN$ 消除一个冗余计算；这又会暴露出一个死的临时变量，仅当 $DCE$ 在 $GVN$ 之后运行时，$DCE$ 才能消除它。在这些组中，如果 $LICM$ 先于 $GVN$ 且 $DCE$ 在 $GVN$ 之后运行，则每组精确消除 $2$ 条指令（一条由 $GVN$ 消除，一条由 $DCE$ 消除）。如果 $LICM$ 先于 $GVN$ 但 $DCE$ 在 $GVN$ 之前运行，则每组仅消除 $1$ 条指令（由 $GVN$ 消除）。如果 $LICM$ 不先于 $GVN$，则该组中消除 $0$ 条指令。\n\n假设所有组都是不相交且独立的（没有指令属于一个以上的组），没有副作用或未定义行为干扰消除，并且除了所描述的启用关系外，没有优化遍会创造新的机会。考虑这三个优化遍的所有 $6$ 种排列：$GVN \\rightarrow LICM \\rightarrow DCE$、$GVN \\rightarrow DCE \\rightarrow LICM$、$LICM \\rightarrow GVN \\rightarrow DCE$、$LICM \\rightarrow DCE \\rightarrow GVN$、$DCE \\rightarrow GVN \\rightarrow LICM$ 和 $DCE \\rightarrow LICM \\rightarrow GVN$。\n\n计算在这 $6$ 种排列下，被消除指令总数的算术平均值。以精确数字形式给出最终答案，不带单位。无需四舍五入。", "solution": "问题陈述已经过验证，被认为是合理的。它在科学上基于编译器优化的原理，问题设定良好，目标明确，数据充分，且没有矛盾或含糊之处。我们可以开始求解。\n\n目标是计算在三个优化遍所有可能的排序下，被消除指令总数的算术平均值。这三个优化遍分别是：全局值编号 ($GVN$)、循环不变代码外提 ($LICM$) 和死代码消除 ($DCE$)。我们分别用 $G$、$L$ 和 $D$ 来表示这些优化遍。这三个优化遍共有 $3! = 6$ 种唯一的排列。\n\n不相交指令组的数量如下：\n- 类型 $1$：$t_{1} = 7$\n- 类型 $2$：$t_{2} = 5$\n- 类型 $3$：$t_{3} = 4$\n- 类型 $4$：$t_{4} = 6$\n\n设 $pos(X)$ 为给定排列中优化遍 $X$ 的位置（$1$、$2$ 或 $3$）。每种类型组的指令消除条件可以形式化如下：\n\n- **类型 1 ($t_1$ 组)：** 当且仅当 $pos(L)  pos(G)$ 时，每组消除 $1$ 条指令。这将产生 $t_{1} \\times 1 = 7$ 条指令。否则，消除 $0$ 条指令。\n- **类型 2 ($t_2$ 组)：** $GVN$ 总是消除 $1$ 条指令。当且仅当 $pos(D) > pos(G)$ 时，$DCE$ 会额外消除 $1$ 条指令。因此，如果 $pos(D)  pos(G)$，总共产生 $t_{2} \\times 1 = 5$ 条指令；如果 $pos(D) > pos(G)$，则产生 $t_{2} \\times (1+1) = 10$ 条指令。\n- **类型 3 ($t_3$ 组)：** 当且仅当 $pos(D) > pos(L)$ 时，每组消除 $1$ 条指令。这将产生 $t_{3} \\times 1 = 4$ 条指令。否则，消除 $0$ 条指令。\n- **类型 4 ($t_4$ 组)：**\n    - 如果 $pos(L)  pos(G)$ 且 $pos(G)  pos(D)$，则每组总共消除 $2$ 条指令。这将产生 $t_{4} \\times 2 = 12$ 条指令。\n    - 如果 $pos(L)  pos(G)$ 且 $pos(D)  pos(G)$，则每组总共消除 $1$ 条指令。这将产生 $t_{4} \\times 1 = 6$ 条指令。\n    - 如果 $pos(L) > pos(G)$，则消除 $0$ 条指令。\n\n我们现在将系统地计算每种排列下的被消除指令总数 $E_i$。\n\n1.  **排列 $P_1: G \\rightarrow L \\rightarrow D$** ($pos(G)=1, pos(L)=2, pos(D)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $2  1$) 为假。消除数: $0$。\n    - 类型 2: $pos(D) > pos(G)$ (即 $3 > 1$) 为真。消除数: $t_2 \\times (1+1) = 5 \\times 2 = 10$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $3 > 2$) 为真。消除数: $t_3 \\times 1 = 4$。\n    - 类型 4: $pos(L) > pos(G)$。消除数: $0$。\n    - 总计 $E_1 = 0 + 10 + 4 + 0 = 14$。\n\n2.  **排列 $P_2: G \\rightarrow D \\rightarrow L$** ($pos(G)=1, pos(D)=2, pos(L)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $3  1$) 为假。消除数: $0$。\n    - 类型 2: $pos(D) > pos(G)$ (即 $2 > 1$) 为真。消除数: $t_2 \\times (1+1) = 10$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $2 > 3$) 为假。消除数: $0$。\n    - 类型 4: $pos(L) > pos(G)$。消除数: $0$。\n    - 总计 $E_2 = 0 + 10 + 0 + 0 = 10$。\n\n3.  **排列 $P_3: D \\rightarrow G \\rightarrow L$** ($pos(D)=1, pos(G)=2, pos(L)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $3  2$) 为假。消除数: $0$。\n    - 类型 2: $pos(D)  pos(G)$ (即 $1  2$) 为真。消除数: $t_2 \\times 1 = 5$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $1 > 3$) 为假。消除数: $0$。\n    - 类型 4: $pos(L) > pos(G)$。消除数: $0$。\n    - 总计 $E_3 = 0 + 5 + 0 + 0 = 5$。\n\n4.  **排列 $P_4: L \\rightarrow G \\rightarrow D$** ($pos(L)=1, pos(G)=2, pos(D)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $1  2$) 为真。消除数: $t_1 \\times 1 = 7$。\n    - 类型 2: $pos(D) > pos(G)$ (即 $3 > 2$) 为真。消除数: $t_2 \\times (1+1) = 10$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $3 > 1$) 为真。消除数: $t_3 \\times 1 = 4$。\n    - 类型 4: $pos(L)  pos(G)$ 且 $pos(G)  pos(D)$ (即 $1  2$ 且 $2  3$) 为真。消除数: $t_4 \\times 2 = 6 \\times 2 = 12$。\n    - 总计 $E_4 = 7 + 10 + 4 + 12 = 33$。\n\n5.  **排列 $P_5: L \\rightarrow D \\rightarrow G$** ($pos(L)=1, pos(D)=2, pos(G)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $1  3$) 为真。消除数: $t_1 \\times 1 = 7$。\n    - 类型 2: $pos(D)  pos(G)$ (即 $2  3$) 为真。消除数: $t_2 \\times 1 = 5$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $2 > 1$) 为真。消除数: $t_3 \\times 1 = 4$。\n    - 类型 4: $pos(L)  pos(G)$ 且 $pos(D)  pos(G)$ (即 $1  3$ 且 $2  3$) 为真。消除数: $t_4 \\times 1 = 6$。\n    - 总计 $E_5 = 7 + 5 + 4 + 6 = 22$。\n\n6.  **排列 $P_6: D \\rightarrow L \\rightarrow G$** ($pos(D)=1, pos(L)=2, pos(G)=3$)\n    - 类型 1: $pos(L)  pos(G)$ (即 $2  3$) 为真。消除数: $t_1 \\times 1 = 7$。\n    - 类型 2: $pos(D)  pos(G)$ (即 $1  3$) 为真。消除数: $t_2 \\times 1 = 5$。\n    - 类型 3: $pos(D) > pos(L)$ (即 $1 > 2$) 为假。消除数: $0$。\n    - 类型 4: $pos(L)  pos(G)$ 且 $pos(D)  pos(G)$ (即 $2  3$ 且 $1  3$) 为真。消除数: $t_4 \\times 1 = 6$。\n    - 总计 $E_6 = 7 + 5 + 0 + 6 = 18$。\n\n在所有 $6$ 种排列中，被消除指令的总数是每个排列的总和：\n$$ E_{\\text{total}} = E_1 + E_2 + E_3 + E_4 + E_5 + E_6 $$\n$$ E_{\\text{total}} = 14 + 10 + 5 + 33 + 22 + 18 = 102 $$\n算术平均值 $\\mu$ 是这个总和除以排列数 $6$：\n$$ \\mu = \\frac{E_{\\text{total}}}{6} = \\frac{102}{6} $$\n$$ \\mu = 17 $$\n被消除指令总数的算术平均值为 $17$。", "answer": "$$\\boxed{17}$$", "id": "3629247"}, {"introduction": "高效的编译不仅仅是逻辑上的代码转换，还必须考虑目标硬件架构。这个练习 [@problem_id:3629231] 探讨了编译器遍与缓存性能之间的关键关系，要求你分析不同的循环优化顺序如何能够极大地改变内存访问模式和整体效率。", "problem": "考虑一个三重嵌套循环，它在一个大小为 $N \\times N$ 的方形域上计算矩阵乘法累加。矩阵采用行主序布局，元素大小为 $8$ 字节（双精度）。其抽象计算如下：\n$$\n\\text{for } i = 0,\\ldots,N-1 \\quad \\text{for } j = 0,\\ldots,N-1 \\quad \\text{for } k = 0,\\ldots,N-1: \\quad C[i,j] \\leftarrow C[i,j] + A[i,k] \\cdot B[k,j].\n$$\n假设内存系统由一个单级缓存模型 $M$ 建模，该模型具有以下属性：\n- 缓存是全相联的，采用最近最少使用（LRU）替换策略，容量为 $Q$ 个缓存行。\n- 缓存行大小为 $L$ 字节，因此每个缓存行可以容纳 $w = \\frac{L}{8}$ 个双精度元素。\n- 缓存采用写分配和写回策略，但为解决此问题，您只需计算从内存填充缓存行的次数（将完整的行读入缓存），可以忽略写回操作。\n- 所有数组 $A$、$B$ 和 $C$ 都以连续的行主序存储，且缓存初始为空。\n\n对原始的循环嵌套应用了两种编译遍组织方式：\n\n- 编译遍组织 $\\mathcal{P}_1$（分块后交换）：首先对 $i$ 和 $j$ 循环应用循环分块，块大小为 $T_i$ 和 $T_j$，创建了基于 $I$ 和 $J$ 的块循环以及基于 $ii$ 和 $jj$ 的点循环。然后应用循环交换，使得每个 $(I,J)$ 块内部的循环顺序为 $ii$、$jj$、$k$。在模型 $M$ 下，假设在一个固定的 $(I,J)$ 块内，对应的 $C$ 块的所有缓存行在整个 $k$ 循环遍历期间都驻留在缓存中，即在处理该块时，来自 $A$ 和 $B$ 的工作集压力不会驱逐任何 $C$ 的缓存行。\n\n- 编译遍组织 $\\mathcal{P}_2$（交换后分块）：首先应用循环交换，使 $k$ 循环成为最外层循环，得到顺序 $k$、$i$、$j$。然后对内部的 $i$ 和 $j$ 循环应用循环分块，使用相同的块大小 $T_i$ 和 $T_j$，产生顺序 $k$、$I$、$J$、$ii$、$jj$。在模型 $M$ 下，假设在不同 $k$ 迭代中对同一个 $(I,J)$ 块的两次连续访问之间，由 $A$ 和 $B$ 产生的工作集超出了剩余的缓存容量，导致 $C$ 块的所有缓存行在下次访问前都被驱逐；也就是说，当在新的 $k$ 值下到达同一个 $C$ 的 $(I,J)$ 块时，其缓存行均不在缓存中。\n\n给定具体参数 $N=256$，$T_i=32$，$T_j=32$，$L=64$ 字节，以及 $Q=160$ 个缓存行。使用模型 $M$ 和上述假设，计算精确的比值\n$$\nR \\;=\\; \\frac{\\text{在 } \\mathcal{P}_2 \\text{ 下 } C \\text{ 从内存填充缓存行的总次数}}{\\text{在 } \\mathcal{P}_1 \\text{ 下 } C \\text{ 从内存填充缓存行的总次数}}\n$$\n请用一个精确的整数表示您的答案。不需要四舍五入，也不包含任何物理单位。", "solution": "该问题已被验证为具有科学依据、定义明确且客观。它基于编译器理论和计算机体系结构中关于缓存性能优化的标准原理。所提供的假设虽然有所简化，但是明确的，并允许进行直接、形式化的分析。我现在开始解答。\n\n我们首先正式定义问题陈述中给出的参数。\n矩阵维度为 $N = 256$。\n元素大小为 $8$ 字节（双精度）。\n缓存行大小为 $L = 64$ 字节。\n单个缓存行能容纳的双精度元素数量为 $w = \\frac{L}{8} = \\frac{64}{8} = 8$。\n$i$ 和 $j$ 循环的块大小为 $T_i = 32$ 和 $T_j = 32$。\n矩阵 $A$、$B$ 和 $C$ 以连续的行主序存储。我们只计算矩阵 $C$ 的缓存行填充次数。\n\n我们将分别对每种编译遍组织方式进行分析。\n\n### 编译遍组织 $\\mathcal{P}_1$ 的分析\n\n在编译遍组织 $\\mathcal{P}_1$ 下，循环嵌套在 $i$ 和 $j$ 循环上进行分块，并且最终的循环顺序被指定为 $k$ 循环在块循环的最内层。循环结构如下：\n$$\n\\begin{array}{l}\n\\text{for } I = 0 \\text{ to } N/T_i - 1 \\\\\n\\quad \\text{for } J = 0 \\text{ to } N/T_j - 1 \\\\\n\\quad \\quad \\text{for } ii = 0 \\text{ to } T_i - 1 \\\\\n\\quad \\quad \\quad \\text{for } jj = 0 \\text{ to } T_j - 1 \\\\\n\\quad \\quad \\quad \\quad \\text{for } k = 0 \\text{ to } N - 1 \\\\\n\\quad \\quad \\quad \\quad \\quad i \\leftarrow I \\cdot T_i + ii \\\\\n\\quad \\quad \\quad \\quad \\quad j \\leftarrow J \\cdot T_j + jj \\\\\n\\quad \\quad \\quad \\quad \\quad C[i,j] \\leftarrow C[i,j] + A[i,k] \\cdot B[k,j]\n\\end{array}\n$$\n问题陈述了此编译遍的关键假设：“在一个固定的 $(I,J)$ 块内，对应的 $C$ 块的所有缓存行在整个 $k$ 循环遍历期间都驻留在缓存中”。这被解释为，对于一个给定的 $(I,J)$ 块，在 $ii$、$jj$ 和 $k$ 循环的整个持续时间内，一旦属于该 $C$ 块的任何缓存行被加载，它就不会被驱逐。因此，矩阵 $C$ 的缓存填充仅在首次访问 $(I,J)$ 块内的每个缓存行时发生。一旦循环移动到一个新的 $(I,J)$ 块，我们假设前一个 $C$ 块的缓存行可能已被驱逐，新的 $C$ 块必须被加载。\n\n我们的任务是计算处理一个 $(I,J)$ 块所需的矩阵 $C$ 的缓存行填充次数，然后将其乘以总的块数。\n\n矩阵 $C$ 的一个块是一个大小为 $T_i \\times T_j$ 的子矩阵。由于 $C$ 是以行主序存储的，元素 $C[i,j]$ 位于与 $i \\cdot N + j$ 成比例的内存偏移处。因此，$C$ 的一个块由 $T_i$ 个独立、不连续的行段组成。每个行段对应于完整矩阵某一行中的 $T_j$ 个连续元素。\n\n我们来计算这样一个行段的缓存填充次数。每个行段有 $T_j$ 个元素。由于一行内的元素在内存中是连续的，容纳这 $T_j$ 个元素所需的缓存行数是 $\\lceil \\frac{T_j}{w} \\rceil$。\n根据给定参数，这个值为 $\\lceil \\frac{32}{8} \\rceil = \\lceil 4 \\rceil = 4$ 个缓存行/每行段。\n\n这个块由 $T_i$ 个这样的行段组成。因为这些行段来自矩阵的不同行（从第 $I \\cdot T_i$ 行到第 $I \\cdot T_i + T_i - 1$ 行），它们在内存中不连续，必须独立获取。一个 $C$ 块的总缓存填充次数是其 $T_i$ 个行段各自填充次数的总和。\n$$\n\\text{每个C块的填充次数} = T_i \\times \\left\\lceil \\frac{T_j}{w} \\right\\rceil = 32 \\times 4 = 128.\n$$\n $(I,J)$ 块的总数是每个维度上块数的乘积：\n$$\n\\text{块数} = \\left(\\frac{N}{T_i}\\right) \\times \\left(\\frac{N}{T_j}\\right) = \\left(\\frac{256}{32}\\right) \\times \\left(\\frac{256}{32}\\right) = 8 \\times 8 = 64.\n$$\n在 $\\mathcal{P}_1$ 下，矩阵 $C$ 的总缓存行填充次数是每个块的填充次数与块数的乘积：\n$$\nF_{\\mathcal{P}_1} = (\\text{块数}) \\times (\\text{每个C块的填充次数}) = 64 \\times 128 = 8192.\n$$\n或者，我们可以用符号来表示。由于 $T_j$ 是 $w$ 的倍数，向上取整函数可以省略。\n$$\nF_{\\mathcal{P}_1} = \\left(\\frac{N}{T_i}\\right) \\left(\\frac{N}{T_j}\\right) T_i \\left(\\frac{T_j}{w}\\right) = \\frac{N^2 T_i T_j}{T_i T_j w} = \\frac{N^2}{w}.\n$$\n$$\nF_{\\mathcal{P}_1} = \\frac{256^2}{8} = \\frac{65536}{8} = 8192.\n$$\n\n### 编译遍组织 $\\mathcal{P}_2$ 的分析\n\n在编译遍组织 $\\mathcal{P}_2$ 下，$k$ 循环是最外层的，而 $i, j$ 循环被分块。循环结构是：\n$$\n\\begin{array}{l}\n\\text{for } k = 0 \\text{ to } N - 1 \\\\\n\\quad \\text{for } I = 0 \\text{ to } N/T_i - 1 \\\\\n\\quad \\quad \\text{for } J = 0 \\text{ to } N/T_j - 1 \\\\\n\\quad \\quad \\quad \\text{for } ii = 0 \\text{ to } T_i - 1 \\\\\n\\quad \\quad \\quad \\quad \\text{for } jj = 0 \\text{ to } T_j - 1 \\\\\n\\quad \\quad \\quad \\quad \\quad i \\leftarrow I \\cdot T_i + ii \\\\\n\\quad \\quad \\quad \\quad \\quad j \\leftarrow J \\cdot T_j + jj \\\\\n\\quad \\quad \\quad \\quad \\quad C[i,j] \\leftarrow C[i,j] + A[i,k] \\cdot B[k,j]\n\\end{array}\n$$\n对于此编译遍，假设是：“在不同 $k$ 迭代中对同一个 $(I,J)$ 块的两次连续访问之间，由 $A$ 和 $B$ 产生的工作集超出了剩余的缓存容量，导致 $C$ 块的所有缓存行都被驱逐”。这意味着在最外层 $k$ 循环的每次迭代开始时，对于矩阵 $C$ 而言，缓存实际上是空的。因此，当内层循环遍历 $C$ 的所有块时，整个矩阵 $C$ 都必须从内存读入缓存。\n\n我们来计算一次性读取整个矩阵 $C$ 的缓存填充次数。矩阵 $C$ 的大小为 $N \\times N$，并存储在一个连续的内存块中。\n$C$ 中的元素总数为 $N^2 = 256^2 = 65536$。\n容纳整个矩阵所需的缓存行总数为：\n$$\n\\text{每次k迭代中C的填充次数} = \\left\\lceil \\frac{N^2}{w} \\right\\rceil = \\left\\lceil \\frac{256^2}{8} \\right\\rceil = \\lceil 8192 \\rceil = 8192.\n$$\n加载整个矩阵 $C$ 的过程在外部 $k$ 循环的每次迭代中都会发生。$k$ 循环从 $k=0$ 到 $N-1$ 运行，总共有 $N$ 次迭代。\n因此，在 $\\mathcal{P}_2$ 下，矩阵 $C$ 的总缓存行填充次数为：\n$$\nF_{\\mathcal{P}_2} = N \\times (\\text{每次k迭代中C的填充次数}) = N \\times \\left\\lceil \\frac{N^2}{w} \\right\\rceil.\n$$\n由于 $N^2$ 可以被 $w$ 整除，向上取整函数可以省略。\n$$\nF_{\\mathcal{P}_2} = N \\times \\frac{N^2}{w} = \\frac{N^3}{w}.\n$$\n$$\nF_{\\mathcal{P}_2} = \\frac{256^3}{8} = \\frac{16777216}{8} = 2097152.\n$$\n\n### 比值计算\n\n最后，我们按要求计算比值 $R$：\n$$\nR = \\frac{F_{\\mathcal{P}_2}}{F_{\\mathcal{P}_1}} = \\frac{2097152}{8192}.\n$$\n使用符号表达式：\n$$\nR = \\frac{N^3/w}{N^2/w} = N.\n$$\n代入 $N$ 的值：\n$$\nR = 256.\n$$\n缓存行填充次数的比值恰好是 $256$。", "answer": "$$\\boxed{256}$$", "id": "3629231"}]}