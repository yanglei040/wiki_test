{"hands_on_practices": [{"introduction": "理论学习之后，让我们通过一个具体的例子来实践编译器的分析-综合模型。这个练习将关注一个基础但重要的优化：布尔表达式的转换。我们将看到，分析阶段如何通过推断表达式的属性（例如是否纯粹、是否会抛出异常）来为综合阶段提供决策依据，从而安全地将具有短路求值行为的逻辑运算符替换为可能更高效的普通运算符。[@problem_id:3621439]", "problem": "一种处理带布尔表达式语言的编译器使用了编译的分析-综合模型：一个分析阶段用语义事实来标注中间表示（IR），而一个综合阶段则在这些事实的指导下执行保持语义的重写。该语言具有短路合取和短路析取，记作 $\\land_{\\mathrm{sc}}$ 和 $\\lor_{\\mathrm{sc}}$，求值顺序为从左到右。积极求值的布尔运算符 $\\land$ 和 $\\lor$ 会对两个操作数都进行求值。可观察等价性意味着最终产生的值、外部可见副作用的多重集以及异常行为的相等。\n\n分析阶段会为每个IR节点 $e$ 标注三个事实：\n- 如果 $e$ 是引用透明的（没有副作用），则 $pure(e)$ 为 $\\mathrm{true}$。\n- 如果对 $e$ 求值不会引发任何异常或未定义行为，则 $nothrow(e)$ 为 $\\mathrm{true}$。\n- 如果对 $e$ 求值不施加任何相对于其他表达式的求值顺序约束（特别是，没有通过副作用产生的表达式间依赖），则 $order\\_independent(e)$ 为 $\\mathrm{true}$。\n\n假设IR包含四个布尔值表达式 $e_1$、$e_2$、$e_3$、$e_4$，具有以下分析事实：\n- $pure(e_1)=\\mathrm{true}$, $nothrow(e_1)=\\mathrm{true}$, $order\\_independent(e_1)=\\mathrm{true}$。\n- $pure(e_2)=\\mathrm{false}$, $nothrow(e_2)=\\mathrm{true}$, $order\\_independent(e_2)=\\mathrm{false}$。\n- $pure(e_3)=\\mathrm{true}$, $nothrow(e_3)=\\mathrm{false}$, $order\\_independent(e_3)=\\mathrm{true}$。\n- $pure(e_4)=\\mathrm{true}$, $nothrow(e_4)=\\mathrm{true}$, $order\\_independent(e_4)=\\mathrm{true}$。\n\n考虑IR表达式\n$$\nE \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,).\n$$\n\n综合阶段仅在IR表明没有副作用且求值顺序安全时，才允许将短路运算符转换为无分支的积极求值。在这些规则下，以下哪些候选转换是合理的（即，它们在只进行规则允许的转换的同时，保持了 $E$ 的可观察等价性）？选择所有适用的选项。\n\nA. 将 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 替换为 $e_1 \\;\\land\\; e_4$，保持外部的 $\\lor_{\\mathrm{sc}}$ 和右侧的 $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ 不变。\n\nB. 将 $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ 替换为 $e_2 \\;\\land\\; e_3$，保持外部的 $\\lor_{\\mathrm{sc}}$ 和左侧的 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 不变。\n\nC. 将外部的 $\\lor_{\\mathrm{sc}}$ 替换为积极求值的 $\\lor$，并同时将 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 替换为 $e_1 \\;\\land\\; e_4$，得到 $E'=(\\, e_1 \\;\\land\\; e_4 \\,) \\;\\lor\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$。\n\nD. 将 $E$ 重写为算术表达式\n$$\nE'' \\;=\\; 1 \\;-\\; \\big( 1 - e_1 e_4 \\big)\\, \\big( 1 - e_2 e_3 \\big),\n$$\n其中布尔值表示为 $0$ 和 $1$，乘法和减法在 $\\{0,1\\}$ 上解释，以获得完全无分支的积极求值。\n\n答案选项应严格根据所述的分析事实和规则进行评估：只有当 $pure(\\cdot)$、$nothrow(\\cdot)$ 和 $order\\_independent(\\cdot)$ 表明对于被转换的特定操作数是安全时，才允许转换为无分支的积极求值。", "solution": "### 步骤 1：提取已知信息\n\n我将逐字列出问题陈述中提供的所有信息。\n\n*   **编译器模型：** 分析-综合模型。\n    *   分析阶段：用语义事实标注中间表示（IR）。\n    *   综合阶段：在这些事实的指导下执行保持语义的重写。\n*   **语言特性：**\n    *   短路合取（$\\land_{\\mathrm{sc}}$）和析取（$\\lor_{\\mathrm{sc}}$）。\n    *   短路运算符的求值顺序为从左到右。\n    *   积极布尔运算符（$\\land$, $\\lor$）对两个操作数都进行求值。\n*   **可观察等价性定义：** 以下各项的相等：\n    1.  最终产生的值。\n    2.  外部可见副作用的多重集。\n    3.  异常行为。\n*   **IR节点 $e$ 的分析事实（标注）：**\n    *   $pure(e)$: 如果 $e$ 是引用透明的（无副作用），则为 $\\mathrm{true}$。\n    *   $nothrow(e)$: 如果对 $e$ 求值不会引发任何异常或未定义行为，则为 $\\mathrm{true}$。\n    *   $order\\_independent(e)$: 如果对 $e$ 求值不施加任何相对于其他表达式的求值顺序约束，则为 $\\mathrm{true}$。\n*   **特定表达式及其事实：**\n    *   $e_1$: $pure(e_1)=\\mathrm{true}$, $nothrow(e_1)=\\mathrm{true}$, $order\\_independent(e_1)=\\mathrm{true}$。\n    *   $e_2$: $pure(e_2)=\\mathrm{false}$, $nothrow(e_2)=\\mathrm{true}$, $order\\_independent(e_2)=\\mathrm{false}$。\n    *   $e_3$: $pure(e_3)=\\mathrm{true}$, $nothrow(e_3)=\\mathrm{false}$, $order\\_independent(e_3)=\\mathrm{true}$。\n    *   $e_4$: $pure(e_4)=\\mathrm{true}$, $nothrow(e_4)=\\mathrm{true}$, $order\\_independent(e_4)=\\mathrm{true}$。\n*   **待转换的IR表达式：**\n    *   $E \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,).$\n*   **转换规则：**\n    *   “综合阶段仅在IR表明没有副作用且求值顺序安全时，才允许将短路运算符转换为无分支的积极求值。”\n    *   问题对此作出澄清：“只有当 $pure(\\cdot)$、$nothrow(\\cdot)$ 和 $order\\_independent(\\cdot)$ 表明对于被转换的特定操作数是安全时，才允许转换为无分支的积极求值。”\n\n### 步骤 2：使用提取的已知信息进行验证\n\n我现在将根据我的验证标准检查问题陈述。\n\n*   **科学上是否成立？** 是。该问题设置在编译器设计的背景下，这是计算机科学中一个成熟的子领域。分析-综合编译、中间表示、短路求值与积极求值、副作用、异常和引用透明等概念都是该领域中标准和基本的概念。该模型是编译器优化的一个简化但现实的表示。\n*   **是否定义明确？** 是。问题定义了一个特定的表达式 $E$，给出了其子表达式的属性，定义了转换规则，并要求评估四个特定转换的合理性。合理性（可观察等价性）和允许性（基于分析事实的规则）的标准都已明确陈述。应该存在一个唯一的答案（一组正确的选项）。\n*   **是否客观？** 是。语言是精确和技术性的。所有术语都在问题上下文中定义，或者是计算机科学中的标准术语。没有主观或基于意见的陈述。\n*   **缺陷检查：**\n    1.  **科学/事实不成立：** 否。在编译器理论的框架内，逻辑是合理的。\n    2.  **不可形式化/不相关：** 否。问题是高度形式化的，并且与编译器原理直接相关。\n    3.  **设置不完整或矛盾：** 否。提供的信息是充分的。规则是清晰的。$e_1, e_2, e_3, e_4$ 的属性已明确给出。转换规则已陈述。表达式 $E$ 已定义。所有需要的信息都存在。没有明显的矛盾。\n    4.  **不切实际/不可行：** 否。赋予表达式的属性是合理的。例如，$e_2$ 可能是一个向控制台打印的函数（$pure=\\mathrm{false}$），但保证不会抛出异常（$nothrow=\\mathrm{true}$）。$e_3$ 可能是一个除以可能为零的变量的运算（$nothrow=\\mathrm{false}$），但没有其他副作用（$pure=\\mathrmtrue$）。\n    5.  **定义不清/结构不良：** 否。问题结构清晰，要求评估特定的候选选项。“合理”的含义被明确定义为保持可观察等价性，而*允许*转换的条件也已明确陈述。\n    6.  **伪深刻/琐碎：** 否。这个问题需要对副作用、异常和求值顺序的相互作用进行仔细的逐步推理。它不是琐碎的。\n    7.  **超出科学可验证性范围：** 否。该问题是一个形式系统内的逻辑谜题，是完全可以验证的。\n\n### 步骤 3：结论和行动\n\n**结论：** 该问题是**有效的**。\n**行动：** 进入解答阶段。\n\n---\n\n### 解答推导\n\n现在我将推导解答。问题的核心是理解何时可以将短路运算符 $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ 替换为积极求值的运算符 $A \\;\\text{op}\\; B$。\n\n让我们分析 $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ 和 $A \\;\\text{op}\\; B$ 之间的区别。\n*   对于 $A \\;\\land_{\\mathrm{sc}}\\; B$：仅当 $A$ 为 $\\mathrm{true}$ 时才对 $B$ 求值。\n*   对于 $A \\;\\lor_{\\mathrm{sc}}\\; B$：仅当 $A$ 为 $\\mathrm{false}$ 时才对 $B$ 求值。\n*   对于 $A \\;\\land\\; B$ 和 $A \\;\\lor\\; B$：$A$ 和 $B$ 总是被求值。$A$ 和 $B$ 的求值顺序可能没有规定，但现代语言通常也为积极求值的运算符指定了从左到右的顺序。然而，问题提到了“无分支的积极求值”，并且规则提到了“安全的求值顺序”，这表明交换性是转换所期望的一个属性。\n\n从 $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ 到 $A \\;\\text{op}\\; B$ 的转换是安全的（保持可观察等价性）当且仅当在原本会跳过 $B$ 的情况下对其求值不会改变程序的行为。\n“跳过”的情况是：\n*   当 $A$ 为 $\\mathrm{false}$ 时，对于 $\\land_{\\mathrm{sc}}$。\n*   当 $A$ 为 $\\mathrm{true}$ 时，对于 $\\lor_{\\mathrm{sc}}$。\n\n如果我们现在在这些情况下对 $B$ 求值，可能会出什么问题？\n1.  **副作用：** $B$ 可能有副作用。如果 $B$ 被跳过，其副作用不会发生。如果对其求值，副作用就会发生。这违反了可观察等价性。为防止这种情况，$B$ 必须是纯的。因此，我们需要 $pure(B) = \\mathrm{true}$。\n2.  **异常：** $B$ 可能会引发异常。如果 $B$ 被跳过，则不会（从 $B$ ）引发异常。如果对其求值，则可能引发异常。这违反了可观察等价性。为防止这种情况，对 $B$ 求值必须不能引发异常。因此，我们需要 $nothrow(B) = \\mathrm{true}$。\n\n所以，对于 $A \\;\\text{op}_{\\mathrm{sc}}\\; B \\rightarrow A \\;\\text{op}\\; B$，我们需要 $pure(B) = \\mathrm{true}$ 和 $nothrow(B) = \\mathrm{true}$。\n\n那么 $A$ 的属性呢？在两种情况下 $A$ 总是被求值。然而，积极求值可能会重排 $A$ 和 $B$ 的求值顺序。如果 $A$ 和 $B$ 的求值顺序改变了（例如，并行求值，或先 $B$ 后 $A$），我们必须确保没有依赖关系。\n*   如果 $A$ 和 $B$ 以不同的顺序求值，则不应有顺序依赖。这就是 $order\\_independent$ 的作用。因此，我们需要 $order\\_independent(A) = \\mathrm{true}$ 和 $order_independent(B) = \\mathrm{true}$。\n*   同样，如果 $A$ 有副作用（$pure(A)=\\mathrm{false}$），而 $B$ 在 $A$ 之前求值（这可能发生在积极运算符中），那么 $A$ 的副作用会稍后出现。这是一个由 $order\\_independent(A)$ 覆盖的顺序问题。\n\n问题陈述了一个具体规则：“转换……仅在IR表明没有副作用且求值顺序安全时才被允许。”它进一步澄清为“当 $pure(\\cdot)$、$nothrow(\\cdot)$ 和 $order\\_independent(\\cdot)$ 表明对于被转换的特定操作数是安全时”。\n\n让我们为将 $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ 重写为 $A \\;\\text{op}\\; B$ 制定条件。\n改变之处在于 $B$ *总是*被求值。这不能引入新的副作用或异常。这意味着 $B$ 必须是纯的且不抛出异常。\n因此，我们要求 $pure(B) = \\mathrm{true}$ 和 $nothrow(B) = \\mathrm{true}$。\n那么 $A$ 呢？$A$ 在两种情况下总是被求值。然而，积极求值可能会改变 $A$ 和 $B$ 的求值顺序。为了使转换安全， $A$ 和 $B$ 之间的任何交互都必须是良性的。例如，如果 $B$ 的求值依赖于 $A$ 的副作用，那么我们就不能在 $A$ 之前对 $B$ 求值。$order\\_independent$ 标志就是为此设计的。如果 $A$ 和 $B$ 都是顺序无关的，那么它们可以以任何相对顺序进行求值。\n\n所以，将 $A \\;\\text{op}_{\\mathrm{sc}}\\; B$ 转换为 $A \\;\\text{op}\\; B$ 的最稳健的规则是*两个*操作数 $A$ 和 $B$ 都必须是纯的、不抛出异常的、且顺序无关的。\n让我们重述一下 $e_1, e_2, e_3, e_4$ 的属性：\n- $e_1$: $pure(\\mathrm{true})$, $nothrow(\\mathrm{true})$, $order\\_independent(\\mathrm{true})$。(此后称为 P, N, O)\n- $e_2$: $pure(\\mathrm{false})$, $nothrow(\\mathrm{true})$, $order\\_independent(\\mathrm{false})$。(此后称为 $\\neg$P, N, $\\neg$O)\n- $e_3$: $pure(\\mathrm{true})$, $nothrow(\\mathrm{false})$, $order\\_independent(\\mathrm{true})$。(此后称为 P, $\\neg$N, O)\n- $e_4$: $pure(\\mathrm{true})$, $nothrow(\\mathrm{true})$, $order\\_independent(\\mathrm{true})$。(此后称为 P, N, O)\n\n原始表达式是 $E \\;=\\; (\\, e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\,) \\;\\lor_{\\mathrm{sc}}\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$。\n令 $L = e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 且 $R = e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$。所以 $E = L \\lor_{\\mathrm{sc}} R$。\n\n让我们根据推导出的安全条件评估这些选项。\n\n**候选 A：将 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 替换为 $e_1 \\;\\land\\; e_4$。**\n转换是 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4 \\rightarrow e_1 \\;\\land\\; e_4$。\n这里的操作数是 $A = e_1$ 和 $B = e_4$。\n让我们检查 $e_1$ 和 $e_4$ 的属性。\n- $e_1$：$pure(\\mathrm{true})$，$nothrow(\\mathrm{true})$，$order\\_independent(\\mathrm{true})$。\n- $e_4$：$pure(\\mathrm{true})$，$nothrow(\\mathrm{true})$，$order\\_independent(\\mathrm{true})$。\n两个操作数都是纯的、不抛出异常的、且顺序无关的。因此，根据规则，允许将短路运算符替换为积极求值的运算符。这个转换也是合理的（保持可观察等价性），因为对一个纯的、不抛出异常的表达式（$e_4$）进行无条件求值不会引入任何新的副作用或异常。最终值在数学上是相同的。\n结论：**正确**。此转换是合理的且被允许。\n\n**候选 B：将 $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3$ 替换为 $e_2 \\;\\land\\; e_3$。**\n转换是 $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\rightarrow e_2 \\;\\land\\; e_3$。\n操作数是 $A = e_2$ 和 $B = e_3$。\n让我们检查它们的属性。\n- $e_2$：$pure(\\mathrm{false})$，$order\\_independent(\\mathrm{false})$。它不满足成为“安全”操作数的条件。\n- $e_3$：$nothrow(\\mathrm{false})$。它也不满足条件。\n由于两个操作数都未能满足安全标准，该转换不被规则所允许。\n此外，它也不是合理的。该转换将导致即使 $e_2$ 为 $\\mathrm{false}$ 也会对 $e_3$ 求值。由于 $nothrow(e_3) = \\mathrm{false}$，这可能会引入一个新的异常，违反了可观察等价性。\n结论：**不正确**。此转换不被允许且不合理。\n\n**候选 C：将外部的 $\\lor_{\\mathrm{sc}}$ 替换为积极求值的 $\\lor$，并同时将 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$ 替换为 $e_1 \\;\\land\\; e_4$，得到 $E'=(\\, e_1 \\;\\land\\; e_4 \\,) \\;\\lor\\; (\\, e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\,)$。**\n这是一个复合转换。一个转换只有当其所有组成部分都是合理且被允许时，它才是合理且被允许的。这可以看作两个步骤：首先转换内部的 $e_1 \\;\\land_{\\mathrm{sc}}\\; e_4$，然后转换外部的 $\\lor_{\\mathrm{sc}}$。\n第二步是将 $\\lor_{\\mathrm{sc}}$ 转换为 $\\lor$。操作数是 $A = (e_1 \\land e_4)$ 和 $B = (e_2 \\land_{\\mathrm{sc}} e_3)$。我们必须检查这些复合表达式的属性。\n- $A = (e_1 \\land e_4)$ 的属性：由于 $e_1$ 和 $e_4$ 都是 P, N, O，它们的组合 $A$ 也是纯的、不抛出异常的和顺序无关的。所以 $A$ 是一个安全的操作数。\n- $B = (e_2 \\land_{\\mathrm{sc}} e_3)$ 的属性：\n  - $pure(B)$：$e_2$ 不是纯的。当对 $B$ 求值时，总是会对 $e_2$ 求值。因此，$B$ 不是纯的。$pure(B)=\\mathrm{false}$。\n  - $nothrow(B)$：$e_3$ 可能抛出异常，并且在 $e_2$ 为真时对其求值。因此，$B$ 可能抛出异常。$nothrow(B)=\\mathrm{false}$。\n  - $order\\_independent(B)$：$e_2$ 不是顺序无关的。因此，$B$ 也不是顺序无关的。$order\\_independent(B)=\\mathrm{false}$。\n右操作数 $B$ 未能满足所有三个安全条件。因此，转换外部的 $\\lor_{\\mathrm{sc}}$ 是不被允许的。\n整个转换也不是合理的。如果 $e_1 \\land e_4$ 为 $\\mathrm{true}$，原始表达式 $E$ 将不会对右侧进行求值。而转换后的表达式 $E'$ 则会，这会导致 $e_2$ 的副作用发生，并可能从 $e_3$ 引发异常，这两种情况在 $E$ 中都不会发生。\n结论：**不正确**。此转换不被允许且不合理。\n\n**候选 D：将 $E$ 重写为算术表达式 $E'' \\;=\\; 1 \\;-\\; \\big( 1 - e_1 e_4 \\big)\\, \\big( 1 - e_2 e_3 \\big)$。**\n这个算术表达式，其中布尔值表示为 $0$ 或 $1$，等价于 $(e_1 \\land e_4) \\lor (e_2 \\land e_3)$。这个转换意味着一个“完全无分支的积极求值”，即 $e_1, e_2, e_3, e_4$ 都被求值。\n这在逻辑上等同于将所有三个短路运算符（$\\land_{\\mathrm{sc}}$, $\\lor_{\\mathrm{sc}}$, $\\land_{\\mathrm{sc}}$）替换为它们的积极求值对应物。\n我们已经在对选项B的分析中确定了转换 $e_2 \\;\\land_{\\mathrm{sc}}\\; e_3 \\to e_2 \\;\\land\\; e_3$ 是不被允许且不合理的。由于这个转换是重写为 $E''$ 的必要部分，所以整个重写是不被允许的。\n此外，该重写也不合理。例如，如果 $e_1$ 和 $e_4$ 都为真，$E$ 的值为 $\\mathrm{true}$，而不会对 $e_2$ 或 $e_3$ 求值。然而，$E''$ 会对所有四个表达式求值。这会引入 $e_2$ 的副作用和 $e_3$ 的潜在异常，违反了可观察等价性。\n结论：**不正确**。此转换不被允许且不合理。\n\n根据分析，只有转换A既被编译器的规则所允许，又是合理的因为它保持了可观察等价性。操作数 $e_1$ 和 $e_4$ 对于此优化是“完全安全”的，而任何改变 $e_2$ 或 $e_3$ 求值条件的转换都是不安全的。", "answer": "$$\\boxed{A}$$", "id": "3621439"}, {"introduction": "在掌握了表达式层面的优化后，我们来探讨一个更具挑战性的领域：内存操作的重排序。内存别名分析是编译器分析阶段的核心任务之一，其精度直接决定了优化的空间。本练习将通过不同精度的别名分析（$\\\\alpha \\\\in \\\\{0,1,2\\\\}$）来展示，更精确的分析结果如何使得综合阶段能够安全地执行更大胆的代码重排，从而提升程序性能。[@problem_id:3621393]", "problem": "在编译的分析-综合模型中，分析阶段计算保守的别名信息，综合（转换）阶段使用这些信息来证明内存重排序的合理性。一个基本准则是，在一个顺序、单线程、非易失性程序中，对内存读和写的重排序是保留语义的，当且仅当这两个内存操作不访问相同的抽象位置，并且其中至少一个是写操作。等价地，如果两个内存操作可能访问相同的抽象位置，并且至少一个是写操作，那么就存在一个潜在的内存依赖，并且重排序是不被允许的。\n\n考虑别名分析，其精度参数为 $\\alpha \\in \\{0,1,2\\}$，解释如下：\n- $\\alpha=0$：流不敏感、字段不敏感、上下文不敏感、堆不敏感；所有兼容类型的指针都可能互为别名，并且一个结构体的所有字段被合并到一个抽象位置类中。\n- $\\alpha=1$：流不敏感、字段敏感（同一结构体的不同字段是独立的抽象位置）、上下文不敏感、堆不敏感（所有堆分配被合并到一个抽象位置类中）。\n- $\\alpha=2$：流不敏感、字段敏感、上下文不敏感、堆分配点敏感（不同的语法分配点是不同的抽象位置）；此外，分配被建模为返回全新的、不重叠的内存。\n\n假设一种具有严格顺序语义、无并发、无易失性访问、无未定义行为的语言。考虑以下两个试图重排序加载和存储操作的直线代码片段和提议的优化序列。所有变量都表示指向整数的指针，$\\rightarrow$ 表示通过指向结构体实例的指针进行字段选择。\n\n片段 A（结构体字段）：\n- 程序：设 $p$ 是一个指向具有整数字段 $x$ 和 $y$ 的结构体的指针。按顺序执行：\n  $$\n  S_x:\\; p \\rightarrow x := 1;\\quad L_y:\\; t := p \\rightarrow y.\n  $$\n- 提议的序列 $\\Sigma_A$：将加载操作重排到存储操作之前，即转换为\n  $$\n  L_y:\\; t := p \\rightarrow y;\\quad S_x:\\; p \\rightarrow x := 1.\n  $$\n\n片段 B（不同的堆分配点）：\n- 程序：设 $a := \\mathrm{alloc}_1()$ 且 $b := \\mathrm{alloc}_2()$，其中 $\\mathrm{alloc}_1$ 和 $\\mathrm{alloc}_2$ 表示语法上不同的分配点，每个都返回一个全新的、不重叠的堆对象。按顺序执行：\n  $$\n  S_a:\\; *a := 0;\\quad L_b:\\; u := *b.\n  $$\n- 提议的序列 $\\Sigma_B$：将加载操作重排到存储操作之前，即转换为\n  $$\n  L_b:\\; u := *b;\\quad S_a:\\; *a := 0.\n  $$\n\n问题。仅使用上述定义和开头陈述的合法性准则，哪个选项正确地描述了在每种 $\\alpha \\in \\{0,1,2\\}$ 的情况下，$\\Sigma_A$ 和 $\\Sigma_B$ 中哪些是保留语义的？\n\nA. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_A$ 合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法。\n\nB. 在 $\\alpha=0$ 下：$\\Sigma_A$ 合法；在 $\\alpha=1$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。\n\nC. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：两者都不合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。\n\nD. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_B$ 合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。", "solution": "问题陈述在编译器设计的既定原则内提出了一个明确定义的问题，特别是关于别名分析及其在代码优化中的应用。对于不同分析精度级别（$\\alpha$）的定义以及内存操作重排序的合法性准则都是清晰、内部一致且足以推导出唯一解的。该问题是有效的。\n\n问题的核心是确定一个提议的对存储和其后的加载操作的重排序是否合法。合法性准则规定，仅当别名分析能够证明这两个内存操作访问不同的抽象位置时，这种重排序才是允许的。如果分析结论是这些位置*可能互为别名*，则存在一个潜在的写后读（RAW）依赖，并且重排序是不被允许的。我们将针对每个精度级别 $\\alpha \\in \\{0, 1, 2\\}$ 评估转换 $\\Sigma_A$ 和 $\\Sigma_B$ 的合法性。\n\n**对 $\\alpha=0$ 的分析**\n此级别的分析被定义为流不敏感、字段不敏感、上下文不敏感和堆不敏感。\n\n-   **片段 A ($\\Sigma_A$)**：操作是一个存储 $S_x: p \\rightarrow x := 1$ 和一个加载 $L_y: t := p \\rightarrow y$。因为分析是**字段不敏感**的，它将一个结构体的所有字段合并成一个单一的抽象位置。因此，从分析器的角度来看，$p \\rightarrow x$ 的抽象位置与 $p \\rightarrow y$ 的抽象位置是无法区分的。它们被认为是*可能互为别名*。因此，编译器必须假设 $S_x$ 和 $L_y$ 之间存在依赖关系，这使得 $\\Sigma_A$ 中的重排序**不合法**。\n\n-   **片段 B ($\\Sigma_B$)**：操作是一个存储 $S_a: *a := 0$ 和一个加载 $L_b: u := *b$。指针 $a$ 和 $b$ 是兼容类型（指向整数的指针）。分析是**堆不敏感**的，意味着所有堆分配被合并到一个单一的抽象位置类中。分析器无法区分在 $\\mathrm{alloc}_1()$ 分配的内存和在 $\\mathrm{alloc}_2()$ 分配的内存。它必须保守地假设 $a$ 和 $b$ 可能指向这个单一抽象堆区域内的相同位置。因此， $*a$ 和 $*b$ *可能互为别名*。编译器必须假设存在依赖，$\\Sigma_B$ 中的重排序是**不合法**的。\n\n-   **关于 $\\alpha=0$ 的结论**：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。\n\n**对 $\\alpha=1$ 的分析**\n此级别的分析是流不敏感、**字段敏感**、上下文不敏感和堆不敏感的。\n\n-   **片段 A ($\\Sigma_A$)**：分析是**字段敏感**的。这是与 $\\alpha=0$ 的关键区别。它将同一结构体的不同字段（$x$ 和 $y$）视为独立的抽象位置。因此，分析器可以证明 $p \\rightarrow x$ 和 $p \\rightarrow y$ 访问不相交的内存区域。由于 $S_x$ 和 $L_y$ 之间没有内存依赖，$\\Sigma_A$ 中的重排序是保留语义的，因此是**合法**的。\n\n-   **片段 B ($\\Sigma_B$)**：分析仍然是**堆不敏感**的。与 $\\alpha=0$ 一样，所有堆分配都被合并成一个单一的抽象位置。字段敏感性的改进在这里不适用。分析器仍然无法区分由 $a$（来自 $\\mathrm{alloc}_1()$）指向的内存和由 $b$（来自 $\\mathrm{alloc}_2()$）指向的内存。它必须保守地假设 $*a$ 和 $*b$ *可能互为别名*。$\\Sigma_B$ 中的重排序是**不合法**的。\n\n-   **关于 $\\alpha=1$ 的结论**：只有 $\\Sigma_A$ 合法。\n\n**对 $\\alpha=2$ 的分析**\n此级别的分析是流不敏感、**字段敏感**、上下文不敏感和**堆分配点敏感**的。\n\n-   **片段 A ($\\Sigma_A$)**：分析是字段敏感的，就像 $\\alpha=1$ 的情况一样。它可以证明 $p \\rightarrow x$ 和 $p \\rightarrow y$ 是不同的位置。因此，$\\Sigma_A$ 中的重排序仍然是**合法**的。\n\n-   **片段 B ($\\Sigma_B$)**：分析是**堆分配点敏感**的。这意味着它可以区分在不同语法分配点创建的对象。由于 $a$ 被赋值为 $\\mathrm{alloc}_1()$ 的结果，而 $b$ 被赋值为 $\\mathrm{alloc}_2()$ 的结果，并且这些是语法上不同的点，分析器将它们指向的内存位置建模为不同且不重叠的抽象位置。它可以证明 $*a$ 和 $*b$ 不互为别名。由于没有内存依赖，$\\Sigma_B$ 中的重排序是**合法**的。\n\n-   **关于 $\\alpha=2$ 的结论**：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法。\n\n**结论总结：**\n-   对于 $\\alpha=0$：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。\n-   对于 $\\alpha=1$：只有 $\\Sigma_A$ 合法。\n-   对于 $\\alpha=2$：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法。\n\n**选项评估：**\n\n-   **A. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_A$ 合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法。**\n    这个陈述与我们为所有三个 $\\alpha$ 值推导出的结论完全匹配。\n    **结论：正确。**\n\n-   **B. 在 $\\alpha=0$ 下：$\\Sigma_A$ 合法；在 $\\alpha=1$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都合法；在 $\\alpha=2$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法。**\n    这个陈述在所有三个方面都是不正确的。对于 $\\alpha=0$，$\\Sigma_A$ 不合法。对于 $\\alpha=1$，$\\Sigma_B$ 不合法。对于 $\\alpha=2$，两者都合法。\n    **结论：不正确。**\n\n-   **C. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：两者都不合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。**\n    这个陈述在 $\\alpha=1$（其中 $\\Sigma_A$ 是合法的）和 $\\alpha=2$（其中 $\\Sigma_A$ 也是合法的）方面是不正确的。\n    **结论：不正确。**\n\n-   **D. 在 $\\alpha=0$ 下：$\\Sigma_A$ 和 $\\Sigma_B$ 都不合法；在 $\\alpha=1$ 下：只有 $\\Sigma_B$ 合法；在 $\\alpha=2$ 下：只有 $\\Sigma_B$ 合法。**\n    这个陈述在 $\\alpha=1$（它颠倒了 $\\Sigma_A$ 和 $\\Sigma_B$ 的合法性）和 $\\alpha=2$（其中 $\\Sigma_A$ 也是合法的）方面是不正确的。\n    **结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3621393"}, {"introduction": "最后，我们将挑战一个更高级的全局优化技术：跨基本块的代码移动。现代编译器通常在静态单赋值（SSA）形式和控制流图（CFG）上执行这类优化。这个练习模拟了一个复杂的优化过程，你需要利用分析阶段提供的可移动性标志（$MotionSafe(n)$）和支配树信息，为综合阶段的指令放置做出正确决策，以实现代码的最优布局。[@problem_id:3621417]", "problem": "一个编译器应用分析-综合模型，在控制流图（CFG）上对处于静态单赋值（SSA）形式的程序执行全局代码移动。分析阶段为每个指令节点 $n$ 计算了一个布尔标志 $MotionSafe(n)$，该标志指示将 $n$ 移动到更早的CFG块是否会保持可观察的语义，包括内存效应和异常。综合阶段必须将每个可移动的计算放置到一个能支配其所有使用点的块中，同时要满足操作数可用性的条件，并遵守当 $MotionSafe(n)$ 不满足时，产生副作用或可能引发异常的操作必须保持原地不动的约束。为确保正确性，综合过程必须将每个可移动节点放置到仍能支配其所有使用点的最小块（在支配树中）中，以免不必要地增加活跃范围。\n\n考虑以下包含块 $b_0$（入口）、$b_1$、$b_2$、$b_3$ 和 $b_4$ 的CFG：\n- 控制流：$b_0 \\to b_1$，$b_1$ 分支到 $b_2$ 和 $b_3$，而 $b_2$ 和 $b_3$ 都进入 $b_4$。支配关系为：$b_0$ 支配 $b_1$，而 $b_1$ 支配 $b_2$、$b_3$ 和 $b_4$。直接支配节点为 $idom(b_1)=b_0$，$idom(b_2)=b_1$，$idom(b_3)=b_1$，$idom(b_4)=b_1$。\n- 指令（SSA名称在数学公式中）：\n  - 在 $b_1$ 中：$n_1$: $x := a + b$，其中 $MotionSafe(n_1) = \\mathrm{true}$。然后在 $p$ 上分支。\n  - 在 $b_2$ 中：$n_2$: $t_2 := x \\times 2$，其中 $MotionSafe(n_2) = \\mathrm{true}$。然后 $n_3$: $store(s, t_2)$，其中 $MotionSafe(n_3) = \\mathrm{false}$。然后跳转到 $b_4$。\n  - 在 $b_3$ 中：$n_4$: $t_4 := x \\times 3$，其中 $MotionSafe(n_4) = \\mathrm{true}$。然后 $n_5$: $t_5 := u / v$，其中 $MotionSafe(n_5) = \\mathrm{false}$，因为可能出现除零异常。然后跳转到 $b_4$。\n  - 在 $b_4$ 中：$\\phi$: $y := \\phi(t_2, t_4)$。然后 $n_6a$: $l := load(q)$，其中 $MotionSafe(n_6a) = \\mathrm{true}$ 并且别名分析保证对 $s$ 的存储不会与 $q$ 发生别名。然后 $n_6b$: $z := y + l$，其中 $MotionSafe(n_6b) = \\mathrm{true}$。\n\n定义：\n- 支配：如果从 $b_0$ 到块 $m$ 的每条路径都包含块 $d$，则块 $d$ 支配块 $m$。\n- 最小支配放置：对于一个在块 $\\{u_i\\}$ 中有使用点的节点 $n$，一个合法的放置块 $d$ 必须支配每个 $u_i$，并且在支配树中是最小的，意味着 $d$ 的任何严格后代都不能同时支配所有的 $\\{u_i\\}$。\n\n遵循以下规则：\n- 只有 $MotionSafe(n) = \\mathrm{true}$ 的节点 $n$ 才可以被提前移动。\n- $MotionSafe(n) = \\mathrm{false}$ 的节点保持原地不动，并且不得跨控制流重排序，以免其执行频率或顺序发生改变。\n- 移动后的节点必须被放置在其所有操作数都可用的地方（即，放置块必须支配其操作数的定义点），并且该节点必须支配其所有的使用点。\n\n下列哪个调度选择既合法又符合最小支配放置策略？\n\nA. 保持 $n_1$ 在 $b_1$ 中。将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。保持 $n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中。保持 $n_6a$ 和 $n_6b$ 在 $b_4$ 中。\n\nB. 将 $n_1$ 从 $b_1$ 移动到 $b_0$。将 $n_2$ 从 $b_2$ 移动到 $b_0$。将 $n_4$ 从 $b_3$ 移动到 $b_0$。将 $n_6a$ 从 $b_4$ 移动到 $b_0$。将 $n_6b$ 从 $b_4$ 移动到 $b_1$。保持 $n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中。\n\nC. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_5$ 从 $b_3$ 移动到 $b_1$。将 $n_6b$ 从 $b_4$ 移动到 $b_1$。保持 $n_1$ 在 $b_1$ 中，$n_3$ 在 $b_2$ 中，以及 $n_6a$ 在 $b_4$ 中。\n\nD. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。保持 $n_4$ 在 $b_3$ 中。保持 $n_1$ 在 $b_1$ 中，$n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中，以及 $n_6a$、$n_6b$ 在 $b_4$ 中。", "solution": "用户提供了一个关于编译器中全局代码移动优化的问题。任务是验证问题陈述的有效性，如果有效，则根据给定规则确定正确的代码调度。\n\n### 问题验证\n\n**步骤1：提取已知条件**\n\n- **模型**：用于全局代码移动的编译分析-综合模型。\n- **程序表示**：基于控制流图（CFG）的静态单赋值（SSA）形式。\n- **分析信息**：对每个指令节点 $n$，预先计算了一个布尔标志 $MotionSafe(n)$。\n- **综合目标**：将每个可移动的计算放置到一个能支配其所有使用点的块中。\n- **综合约束**：\n    1.  可移动的计算必须放置在其操作数可用的地方。\n    2.  $MotionSafe(n) = \\mathrm{false}$ 的操作必须保持原地不动。\n    3.  **最小支配放置策略**：将每个可移动节点放置到仍能支配其所有使用点的最小块（在支配树中）。其定义为：对于一个在块 $\\{u_i\\}$ 中有使用点的节点 $n$，一个合法的放置块 $d$ 必须支配每个 $u_i$，并且在支配树中 $d$ 的任何严格后代都不能同时支配所有的 $\\{u_i\\}$。\n- **CFG 结构**：\n    -   块：$b_0$ (入口), $b_1$, $b_2$, $b_3$, $b_4$。\n    -   控制流：$b_0 \\to b_1$；$b_1$ 分支到 $b_2$ 和 $b_3$；$b_2 \\to b_4$；$b_3 \\to b_4$。\n    -   直接支配节点：$idom(b_1)=b_0$, $idom(b_2)=b_1$, $idom(b_3)=b_1$, $idom(b_4)=b_1$。\n- **指令和移动安全性**：\n    -   在 $b_1$ 中：$n_1$: $x := a + b$, $MotionSafe(n_1) = \\mathrm{true}$。\n    -   在 $b_2$ 中：$n_2$: $t_2 := x \\times 2$, $MotionSafe(n_2) = \\mathrm{true}$。以及 $n_3$: $store(s, t_2)$, $MotionSafe(n_3) = \\mathrm{false}$。\n    -   在 $b_3$ 中：$n_4$: $t_4 := x \\times 3$, $MotionSafe(n_4) = \\mathrm{true}$。以及 $n_5$: $t_5 := u / v$, $MotionSafe(n_5) = \\mathrm{false}$。\n    -   在 $b_4$ 中：$\\phi$: $y := \\phi(t_2, t_4)$。以及 $n_{6a}$: $l := load(q)$, $MotionSafe(n_{6a}) = \\mathrm{true}$。以及 $n_{6b}$: $z := y + l$, $MotionSafe(n_{6b}) = \\mathrm{true}$。\n\n**步骤2：使用提取的已知条件进行验证**\n\n根据既定标准评估问题陈述。\n\n- **科学依据**：该问题基于编译器设计和优化这一成熟领域。诸如CFG、SSA、支配者分析和全局代码移动（与部分冗余消除或懒惰代码移动等算法相关）等概念是计算机科学中的标准内容。所提供的规则和定义与该领域一致。\n- **问题的适定性**：该问题是适定的。CFG结构定义清晰。明确陈述的支配关系与CFG的控制流一致。代码移动的规则，特别是“最小支配放置”策略，为综合阶段提供了明确的目标函数。这种结构允许为每个可移动指令推导出唯一、正确的放置位置。\n- **客观性**：问题以精确、客观和正式的语言陈述。所有术语要么是该领域的标准术语，要么有明确定义。\n- **一致性和完整性**：所提供的信息内部一致。从`idom`关系推导出的支配树（$b_0$是$b_1$的父节点，$b_1$是$b_2$、$b_3$和$b_4$的父节点）与控制流图所蕴含的支配属性相匹配。问题提供了确定每个指令放置位置所需的所有信息。\n\n**步骤3：结论与行动**\n\n问题陈述有效。这是一个来自编译器优化领域的科学合理、适定且客观的问题。我将继续推导解决方案。\n\n### 解决方案推导\n\n综合阶段必须为每个可移动指令（即$MotionSafe(n) = \\mathrm{true}$的指令）确定正确的放置位置。固定不动的指令（$MotionSafe(n) = \\mathrm{false}$）是$b_2$中的$n_3$和$b_3$中的$n_5$。\n\n首先，让我们根据所提供的直接支配节点建立支配树：\n- $b_0$是根节点。\n- $idom(b_1)=b_0$ 意味着$b_1$是$b_0$的子节点。\n- $idom(b_2)=b_1$，$idom(b_3)=b_1$ 和 $idom(b_4)=b_1$ 意味着$b_2$、$b_3$和$b_4$都是$b_1$的子节点。\n\n支配树如下：\n$$\n\\begin{array}{c}\nb_0 \\\\\n| \\\\\nb_1 \\\\\n\\swarrow \\downarrow \\searrow \\\\\nb_2 \\quad b_3 \\quad b_4\n\\end{array}\n$$\n\n我们现在将根据放置规则分析每个可移动指令。\n\n1.  **指令 $n_1: x := a + b$ (原在 $b_1$ 中)**\n    -   $MotionSafe(n_1) = \\mathrm{true}$。\n    -   **使用点**：结果 $x$ 被 $b_2$ 块中的 $n_2$ 和 $b_3$ 块中的 $n_4$ 使用。使用块的集合是 $\\{u_i\\} = \\{b_2, b_3\\}$。\n    -   **支配要求**：放置块必须同时支配 $b_2$ 和 $b_3$。$b_2$ 和 $b_3$ 的公共支配节点集合是 $\\{b_0, b_1\\}$。\n    -   **最小放置**：我们必须在 $\\{b_0, b_1\\}$ 中找到一个块 $d$，使得 $d$ 的任何严格后代都不在该集合中。在支配树中，$b_1$ 是 $b_0$ 的严格后代。因此，最小支配放置是 $b_1$。\n    -   **操作数可用性**：操作数 $a$ 和 $b$ 假定在过程入口处可用，因此它们在 $b_1$ 中可用。\n    -   **结论**：$n_1$ 的最优放置位置是其原始块 $b_1$。它应该保留在 $b_1$ 中。\n\n2.  **指令 $n_2: t_2 := x \\times 2$ (原在 $b_2$ 中)**\n    -   $MotionSafe(n_2) = \\mathrm{true}$。\n    -   **使用点**：结果 $t_2$ 被 $b_2$ 中的 $n_3$ 使用，并作为 $b_4$ 中 $\\phi$ 函数的输入。使用块的集合是 $\\{b_2, b_4\\}$。\n    -   **支配要求**：放置块必须同时支配 $b_2$ 和 $b_4$。$b_2$ 和 $b_4$ 的公共支配节点集合是 $\\{b_0, b_1\\}$。\n    -   **最小放置**：最小支配块同样是 $b_1$。\n    -   **操作数可用性**：操作数是 $x$，由 $b_1$ 块中的 $n_1$ 定义。由于 $b_1$ 是目标放置块，操作数 $x$ 是可用的（假设 $n_1$ 放置在 $n_2$ 之前）。\n    -   **结论**：$n_2$ 必须从 $b_2$ 移动到 $b_1$。\n\n3.  **指令 $n_4: t_4 := x \\times 3$ (原在 $b_3$ 中)**\n    -   $MotionSafe(n_4) = \\mathrm{true}$。\n    -   **使用点**：结果 $t_4$ 作为 $b_4$ 中 $\\phi$ 函数的输入。使用块的集合是 $\\{b_4\\}$。\n    -   **支配要求**：放置块必须支配 $b_4$。$b_4$ 的支配节点集合是 $\\{b_0, b_1, b_4\\}$。然而，代码移动（提升）是将指令移动到支配其原始块的块中。原始块 $b_3$ 的支配节点是 $\\{b_0, b_1\\}$。这两个块也都支配使用块 $b_4$。\n    -   **最小放置**：在有效的提升目标 $\\{b_0, b_1\\}$ 中，最小的是 $b_1$。\n    -   **操作数可用性**：操作数是 $x$，由 $b_1$ 中的 $n_1$ 定义。操作数在目标块 $b_1$ 中可用。\n    -   **结论**：$n_4$ 必须从 $b_3$ 移动到 $b_1$。\n\n4.  **指令 $n_{6a}: l := load(q)$ (原在 $b_4$ 中)**\n    -   $MotionSafe(n_{6a}) = \\mathrm{true}$。\n    -   **使用点**：结果 $l$ 被 $b_4$ 中的 $n_{6b}$ 使用。使用块的集合是 $\\{b_4\\}$。\n    -   **支配要求**：放置块必须支配 $b_4$。$b_4$ 的支配节点集合是 $\\{b_0, b_1, b_4\\}$。\n    -   **最小放置**：最小支配块是 $b_4$ 本身。\n    -   **结论**：$n_{6a}$ 的最优放置位置是其原始块 $b_4$。它应该保留在 $b_4$ 中。\n\n5.  **指令 $n_{6b}: z := y + l$ (原在 $b_4$ 中)**\n    -   $MotionSafe(n_{6b}) = \\mathrm{true}$。\n    -   **使用点**：问题没有指定 $z$ 的使用点。我们假设它在从 $b_4$ 退出时是活跃的，这使得 $b_4$ 成为使用块。\n    -   **操作数可用性**：操作数是 $y$ 和 $l$。操作数 $l$ 由 $b_4$ 中的 $n_{6a}$ 定义。操作数 $y$ 由 $b_4$ 入口处的 $\\phi$ 函数定义。$\\phi$ 函数的值仅在其所在的块*内部*定义，而不是在该块的入口处定义。因此，$y$ 在任何严格支配 $b_4$ 的块（即 $b_1$ 或 $b_0$）中都是不可用的。\n    -   **结论**：由于操作数 $y$ 在 $b_4$ 之外不可用，$n_{6b}$ 不能被移动。它必须保留在 $b_4$ 中。\n\n**最优放置总结**：\n- $n_1$：保留在 $b_1$ 中。\n- $n_2$：移动到 $b_1$。\n- $n_3$：保留在 $b_2$ 中（固定不动）。\n- $n_4$：移动到 $b_1$。\n- $n_5$：保留在 $b_3$ 中（固定不动）。\n- $n_{6a}$：保留在 $b_4$ 中。\n- $n_{6b}$：保留在 $b_4$ 中。\n\n### 逐项分析\n\n现在我们根据这个推导出的正确调度来评估每个选项。\n\n**A. 保持 $n_1$ 在 $b_1$ 中。将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。保持 $n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中。保持 $n_6a$ 和 $n_6b$ 在 $b_4$ 中。**\n- $n_1$ 放置在 $b_1$：正确。\n- $n_2$ 放置在 $b_1$：正确。\n- $n_4$ 放置在 $b_1$：正确。\n- $n_3$ 放置在 $b_2$：正确。\n- $n_5$ 放置在 $b_3$：正确。\n- $n_{6a}$ 放置在 $b_4$：正确。\n- $n_{6b}$ 放置在 $b_4$：正确。\n这个选项在每个细节上都与推导出的调度相匹配。\n**结论：正确。**\n\n**B. 将 $n_1$ 从 $b_1$ 移动到 $b_0$。将 $n_2$ 从 $b_2$ 移动到 $b_0$。将 $n_4$ 从 $b_3$ 移动到 $b_0$。将 $n_{6a}$ 从 $b_4$ 移动到 $b_0$。将 $n_{6b}$ 从 $b_4$ 移动到 $b_1$。保持 $n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中。**\n- 将 $n_1$ 移动到 $b_0$：不正确。这违反了最小支配放置规则，该规则要求放置在 $b_1$ 中。\n- 将 $n_2$ 移动到 $b_0$：不正确。最小放置位置是 $b_1$。\n- 将 $n_4$ 移动到 $b_0$：不正确。最小放置位置是 $b_1$。\n- 将 $n_{6b}$ 移动到 $b_1$：不正确。操作数 $y$（来自 $b_4$ 中的 $\\phi$ 函数）在 $b_1$ 中不可用。\n**结论：不正确。**\n\n**C. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。将 $n_4$ 从 $b_3$ 移动到 $b_1$。将 $n_5$ 从 $b_3$ 移动到 $b_1$。将 $n_{6b}$ 从 $b_4$ 移动到 $b_1$。保持 $n_1$ 在 $b_1$ 中，$n_3$ 在 $b_2$ 中，以及 $n_{6a}$ 在 $b_4$ 中。**\n- 将 $n_5$ 移动到 $b_1$：不正确。$MotionSafe(n_5)$ 为 $\\mathrm{false}$，所以 $n_5$ 必须保持在 $b_3$ 中不动。\n- 将 $n_{6b}$ 移动到 $b_1$：不正确。操作数 $y$ 在 $b_1$ 中不可用。\n**结论：不正确。**\n\n**D. 将 $n_2$ 从 $b_2$ 移动到 $b_1$。保持 $n_4$ 在 $b_3$ 中。保持 $n_1$ 在 $b_1$ 中，$n_3$ 在 $b_2$ 中，$n_5$ 在 $b_3$ 中，以及 $n_{6a}$、$n_{6b}$ 在 $b_4$ 中。**\n- 保持 $n_4$ 在 $b_3$ 中：不正确。问题陈述中指出，综合阶段*必须*根据策略放置每个可移动的计算。由于 $n_4$ 是可移动的（$MotionSafe(n_4) = \\mathrm{true}$），它必须被移动到其最优放置位置，即 $b_1$。将其保留在 $b_3$ 中与所述的综合策略不一致。\n**结论：不正确。**", "answer": "$$\\boxed{A}$$", "id": "3621417"}]}