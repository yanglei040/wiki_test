{"hands_on_practices": [{"introduction": "在开始动手实践之前，我们首先需要对基本的数值微分公式建立扎实的直观理解。这个练习 [@problem_id:2191753] 对前向、后向和中心差分法进行了直接比较。通过计算它们在给定函数下的各自误差，你将具体地理解为何中心差分公式因其更高的精度而通常是首选方法。", "problem": "考虑函数 $f(x) = x \\exp(-x)$。我们感兴趣的是在点 $x_0 = 1$ 处近似其导数 $f'(x)$。近似的质量由其绝对误差来衡量，绝对误差定义为近似值与导数真值之间的绝对差。\n\n你需要比较三种常用的近似导数的有限差分公式：\n1.  **前向差分近似**：$D_f(x_0, h) = \\frac{f(x_0+h) - f(x_0)}{h}$\n2.  **后向差分近似**：$D_b(x_0, h) = \\frac{f(x_0) - f(x_0-h)}{h}$\n3.  **中心差分近似**：$D_c(x_0, h) = \\frac{f(x_0+h) - f(x_0-h)}{2h}$\n\n设 $E_f$、$E_b$ 和 $E_c$ 分别是当步长 $h = 0.1$ 时，对应于前向、后向和中心差分近似的绝对误差。\n\n计算比值 $R = \\frac{E_f + E_b}{E_c}$ 的值。将你的最终答案四舍五入到三位有效数字。", "solution": "我们从 $f(x) = x \\exp(-x)$ 开始。其导数可以通过乘法法则得到：\n$$\nf'(x) = \\exp(-x) + x \\frac{d}{dx}\\big(\\exp(-x)\\big) = \\exp(-x) - x \\exp(-x) = \\exp(-x)\\,(1 - x).\n$$\n在 $x_{0} = 1$ 处，这得到\n$$\nf'(1) = \\exp(-1)\\,(1 - 1) = 0.\n$$\n因此，对于任何有限差分近似 $D$，在 $x_{0}=1$ 处的绝对误差就是该近似的绝对值：\n$$\nE_{f} = |D_{f}(1,h)|,\\quad E_{b} = |D_{b}(1,h)|,\\quad E_{c} = |D_{c}(1,h)|.\n$$\n\n当 $h = 0.1$ 时，使用 $f(x) = x \\exp(-x)$ 计算三个有限差分：\n- 前向差分：\n$$\nD_{f}(1,h) = \\frac{f(1+h) - f(1)}{h} = \\frac{(1.1)\\exp(-1.1) - \\exp(-1)}{0.1}.\n$$\n- 后向差分：\n$$\nD_{b}(1,h) = \\frac{f(1) - f(1-h)}{h} = \\frac{\\exp(-1) - (0.9)\\exp(-0.9)}{0.1}.\n$$\n- 中心差分：\n$$\nD_{c}(1,h) = \\frac{f(1+h) - f(1-h)}{2h} = \\frac{(1.1)\\exp(-1.1) - (0.9)\\exp(-0.9)}{0.2}.\n$$\n\n通过将 $\\exp(-1.1) = \\exp(-1)\\exp(-0.1)$ 和 $\\exp(-0.9) = \\exp(-1)\\exp(0.1)$ 写成，来提出因子 $\\exp(-1)$。定义 $t = \\exp(0.1)$，因此 $\\exp(-0.1) = 1/t$。那么\n$$\nD_{f}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1.1\\,\\frac{1}{t} - 1 \\right),\\quad\nD_{b}(1,h) = \\frac{\\exp(-1)}{0.1}\\left(1 - 0.9\\,t \\right),\n$$\n$$\nD_{c}(1,h) = \\frac{\\exp(-1)}{0.2}\\left(1.1\\,\\frac{1}{t} - 0.9\\,t \\right).\n$$\n设\n$$\nA = 1.1\\,\\frac{1}{t} - 1,\\quad B = 1 - 0.9\\,t,\\quad C = 1.1\\,\\frac{1}{t} - 0.9\\,t.\n$$\n则\n$$\nE_{f} = \\frac{\\exp(-1)}{0.1}\\,|A|,\\quad E_{b} = \\frac{\\exp(-1)}{0.1}\\,|B|,\\quad E_{c} = \\frac{\\exp(-1)}{0.2}\\,|C|.\n$$\n因此，该比值简化为\n$$\nR = \\frac{E_{f} + E_{b}}{E_{c}} = \\frac{\\frac{\\exp(-1)}{0.1}(|A|+|B|)}{\\frac{\\exp(-1)}{0.2}|C|} = 2\\,\\frac{|A|+|B|}{|C|}.\n$$\n\n数值上，我们使用 $t = \\exp(0.1) \\approx 1.1051709$ 和 $1/t = \\exp(-0.1) \\approx 0.9048374$。\n$$\nA = 1.1 \\times 0.9048374 - 1 \\approx 0.99532114 - 1 = -0.00467886\n$$\n$$\nB = 1 - 0.9 \\times 1.1051709 \\approx 1 - 0.99465381 = 0.00534619\n$$\n$$\nC = 1.1 \\times 0.9048374 - 0.9 \\times 1.1051709 \\approx 0.99532114 - 0.99465381 = 0.00066733\n$$\n因此，\n$$\nR = 2 \\times \\frac{|A|+|B|}{|C|} = 2 \\times \\frac{0.00467886 + 0.00534619}{0.00066733} = 2 \\times \\frac{0.01002505}{0.00066733} \\approx 30.043\n$$\n四舍五入到三位有效数字，我们得到：\n$$\nR \\approx 30.0\n$$", "answer": "$$\\boxed{30.0}$$", "id": "2191753"}, {"introduction": "虽然数学公式在纸面上看起来很完美，但在计算机上实现它们会带来新的挑战。这个问题 [@problem_id:2415137] 深入探讨了其中最关键的一个：截断误差和浮点舍入误差之间的权衡。你将分析“灾难性抵消”现象如何在步长$h$极小时破坏精度，并推导平衡这两种相对误差源的理论上的最优步长。", "problem": "考虑一个固定息票债券的连续复利价格，作为连续复利收益率 $y$ 的函数：\n$$\nP(y) \\;=\\; \\sum_{k=1}^{N} c_k \\, e^{-y t_k},\n$$\n其中 $t_k$ 是支付时间（以年为单位），$c_k$ 是相应的现金流。设债券的面值为 $F=100$，年票息率为 $c=0.05$，期限为 $T=10$ 年，每半年付息一次 ($m=2$)，因此 $N=mT=20$，$t_k = k/m$ 对于 $k=1,\\ldots,20$，$c_k = 2.5$ 对于 $k=1,\\ldots,19$，$c_{20} = 102.5$。设 $y_0 = 0.03$。\n\n假设您使用前向差分公式来估计导数 $P'(y_0)$：\n$$\nD_h \\;=\\; \\frac{P(y_0 + h) - P(y_0)}{h},\n$$\n计算在标准的双精度浮点算术中进行，其模型为每次算术运算的相对误差界限 $|\\delta|\\le \\epsilon_{mach}$，其中 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$。\n\n下列哪个陈述是正确的？选择所有适用的选项。\n\nA. 对于足够小的 $h$，$D_h$ 中的主要浮点舍入误差表现为 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$，这是由于减去两个几乎相等的数所致，这种现象被称为灾难性抵消。\n\nB. 前向差分近似 $D_h$ 的截断误差是 $O(h^2)$，其主项系数取决于 $P^{(3)}(y_0)$。\n\nC. 平衡主截断误差和舍入误差，可得到形式为 $h^* \\asymp \\sqrt{\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}$ 的渐近最优步长。\n\nD. 对于指定的债券，在 $y_0=0.03$ 处，使用双精度浮点数且 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$ 时，最小化主阶总误差的 $h^*$ 的数量级最接近 $10^{-9}$。\n\nE. 改用中心差分求导将完全消除所有 $h$ 的灾难性抵消。", "solution": "我们从第一性原理开始：前向差分公式定义为\n$$\nD_h \\;=\\; \\frac{P(y_0+h)-P(y_0)}{h}.\n$$\n根据关于 $y_0$ 的泰勒定理，对于某个介于 $y_0$ 和 $y_0+h$ 之间的 $\\xi$，\n$$\nP(y_0+h) \\;=\\; P(y_0) \\;+\\; h\\,P'(y_0) \\;+\\; \\frac{h^2}{2}\\,P''(\\xi).\n$$\n代入 $D_h$ 并减去 $P'(y_0)$，得到截断（离散化）误差\n$$\nD_h - P'(y_0) \\;=\\; \\frac{h}{2}\\,P''(\\xi),\n$$\n因此，截断误差为 $O(h)$，当 $h \\to 0$ 时，其主项行为为 $\\frac{h}{2} P''(y_0)$。\n\n接下来，我们对浮点舍入进行建模。在标准相对误差模型下，每个计算出的量都会被一个乘法因子 $(1+\\delta)$ 扰动，其中 $|\\delta|\\le \\epsilon_{mach}$。设计算值为\n$$\n\\widehat{P(y_0+h)} = P(y_0+h)(1+\\delta_1), \\quad \\widehat{P(y_0)} = P(y_0)(1+\\delta_2),\n$$\n其中 $|\\delta_1|,|\\delta_2| \\le \\epsilon_{mach}$。前向差分计算出的分子是\n$$\n\\widehat{P(y_0+h)} - \\widehat{P(y_0)} \\;=\\; \\big(P(y_0+h) - P(y_0)\\big) \\;+\\; \\delta_1 P(y_0+h) \\;-\\; \\delta_2 P(y_0).\n$$\n除以 $h$ 得到一个加性舍入误差项\n$$\n\\frac{\\delta_1 P(y_0+h) - \\delta_2 P(y_0)}{h}.\n$$\n对于小的 $h$，$P(y_0+h) \\approx P(y_0)$，因此分子中的差 $P(y_0+h)-P(y_0)$ 很小，而该项 $\\frac{\\delta_1 P(y_0+h) - \\delta_2 P(y_0)}{h}$ 的量级为\n$$\nO\\!\\left(\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right).\n$$\n这是灾难性抵消的标志：减去几乎相等的大量值会减少有效数字，从而在导数商中将相对舍入误差放大约 $1/h$。\n\n结合截断和舍入，主阶总误差可以表示为\n$$\nE(h) \\;\\approx\\; \\frac{h}{2}\\,|P''(y_0)| \\;+\\; C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h},\n$$\n其中 $C$ 是一个反映浮点计算和代数重排细节的适中常数。关于 $h$ 最小化这个主阶模型可以得到\n$$\n\\frac{d}{dh}\\left(\\frac{h}{2}|P''(y_0)| + C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)=0\n\\;\\Rightarrow\\;\n\\frac{1}{2}|P''(y_0)| - C\\,\\frac{\\epsilon_{mach}\\,|P(y_0)|}{h^2}=0,\n$$\n所以\n$$\nh^* \\;=\\; \\sqrt{\\frac{2C\\,\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}\n\\;\\asymp\\; \\sqrt{\\frac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}},\n$$\n其中 $\\asymp$ 表示在常数因子范围内相等。\n\n我们现在为指定的债券计算 $|P(y_0)|$ 和 $|P''(y_0)|$。对于连续复利和半年付息时间 $t_k = k/2, k=1,\\ldots,20$，我们有\n$$\nP(y_0) \\;=\\; \\sum_{k=1}^{19} 2.5\\,e^{-0.03\\, (k/2)} \\;+\\; 102.5\\,e^{-0.03 \\cdot 10}.\n$$\n设 $r = e^{-0.03/2} = e^{-0.015} \\approx 0.98511194$。第一个求和是几何级数：\n$$\n\\sum_{k=1}^{19} 2.5\\,r^k \\;=\\; 2.5\\,r\\,\\frac{1-r^{19}}{1-r}.\n$$\n使用 $1-r \\approx 0.01488806$，$r^{19} = e^{-0.015\\cdot 19} = e^{-0.285} \\approx 0.7520$，我们得到\n$$\n\\sum_{k=1}^{19} 2.5\\,r^k \\;\\approx\\; 2.5 \\times 0.98511194 \\times \\frac{1-0.7520}{0.01488806} \\;\\approx\\; 41.02.\n$$\n最终的现金流项是\n$$\n102.5\\,e^{-0.3} \\;\\approx\\; 102.5 \\times 0.740818 \\;\\approx\\; 75.93.\n$$\n因此\n$$\nP(y_0) \\;\\approx\\; 41.02 + 75.93 \\;\\approx\\; 116.95.\n$$\n\n接下来，计算\n$$\nP''(y) \\;=\\; \\sum_{k=1}^{N} c_k\\, t_k^2\\, e^{-y t_k}.\n$$\n因此，在 $y_0=0.03$ 处，\n$$\nP''(y_0) \\;=\\; \\sum_{k=1}^{19} 2.5 \\left(\\frac{k}{2}\\right)^2 e^{-0.03\\,(k/2)} \\;+\\; 102.5 \\cdot 10^2 \\cdot e^{-0.3}.\n$$\n最后一项的计算结果为\n$$\n102.5 \\cdot 100 \\cdot e^{-0.3} \\;\\approx\\; 102.5 \\times 100 \\times 0.740818 \\;\\approx\\; 7593.38.\n$$\n对票息项直接求和，近似得到\n$$\n\\sum_{k=1}^{19} 2.5 \\left(\\frac{k}{2}\\right)^2 e^{-0.03\\,(k/2)} \\;\\approx\\; 1242.46,\n$$\n所以\n$$\nP''(y_0) \\;\\approx\\; 7593.38 + 1242.46 \\;\\approx\\; 8835.84.\n$$\n因此，\n$$\n\\frac{|P(y_0)|}{|P''(y_0)|} \\;\\approx\\; \\frac{116.95}{8835.84} \\;\\approx\\; 1.32 \\times 10^{-2}.\n$$\n当 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$ 时，我们有\n$$\n\\epsilon_{mach}\\,\\frac{|P(y_0)|}{|P''(y_0)|} \\;\\approx\\; 1.47 \\times 10^{-18},\n$$\n所以\n$$\nh^* \\;\\asymp\\; \\sqrt{1.47 \\times 10^{-18}} \\;\\approx\\; 1.21 \\times 10^{-9},\n$$\n并且包含常数 $\\sqrt{2C}$（其中 $C$ 的数量级为 $1$）会使 $h^*$ 保持在 $10^{-9}$ 的数量级。因此最接近 $10^{-9}$ 的数量级是正确的。\n\n我们现在评估每个选项：\n\nA. 上面的舍入误差分析表明，对于小 $h$，主导项的行为类似 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$，这是由减去几乎相等的大量值引起的。结论：正确。\n\nB. 根据泰勒定理，前向差分的截断误差是 $O(h)$，其主项是 $\\frac{h}{2}P''(y_0)$，而不是 $O(h^2)$，并且它取决于 $P''(y_0)$，而不是 $P^{(3)}(y_0)$。结论：不正确。\n\nC. 如上所推导，平衡 $O(h)$ 的截断误差和 $O(\\epsilon_{mach}/h)$ 的舍入误差，可得到 $h^* \\asymp \\sqrt{\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{|P''(y_0)|}}$，结果相差一个常数因子。结论：正确。\n\nD. 使用计算出的 $P(y_0)$ 和 $P''(y_0)$ 以及 $\\epsilon_{mach} \\approx 1.11 \\times 10^{-16}$，得出 $h^*$ 的数量级为 $10^{-9}$。结论：正确。\n\nE. 中心差分将截断误差减小到 $O(h^2)$，但仍然涉及减去几乎相等的量 $P(y_0+h)$ 和 $P(y_0-h)$，因此舍入误差的量级仍然是 $O\\!\\left(\\dfrac{\\epsilon_{mach}\\,|P(y_0)|}{h}\\right)$。灾难性抵消并没有对所有的 $h$ 都被消除。结论：不正确。", "answer": "$$\\boxed{ACD}$$", "id": "2415137"}, {"introduction": "理论提供了地图，而计算则是旅程。在之前分析的基础上，这最后一个练习 [@problem_id:2415200] 挑战你将这些概念应用于一个计算金融领域的真实场景。你将编写一个程序，通过经验性方法找到最优步长$h$，以最小化计算期权“Vega”时的总误差，从而直接观察理论所预测的U形误差曲线。", "problem": "考虑一个在 Black–Scholes 框架下定价的无股息资产的欧式看涨期权。设即期价格为 $S_0$，行权价为 $K$，连续复利无风险利率为 $r$，到期时间为 $T$，波动率为 $\\sigma$。Black–Scholes 看涨期权价格为\n$$\nC(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2),\n$$\n其中\n$$\nd_1=\\frac{\\ln\\!\\left(\\frac{S_0}{K}\\right)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}},\\quad d_2=d_1-\\sigma\\sqrt{T},\n$$\n且 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数。该看涨期权的解析 Vega 是价格相对于 $\\sigma$ 的偏导数，由下式给出\n$$\n\\text{Vega}(S_0,K,r,T,\\sigma)=\\frac{\\partial C}{\\partial \\sigma}=S_0 \\sqrt{T}\\,\\varphi(d_1),\n$$\n其中 $\\varphi(\\cdot)$ 是标准正态概率密度函数。\n\n对于给定的参数向量 $(S_0,K,r,T,\\sigma)$，通过应用于波动率的对称差商定义 Vega 的数值估计量，\n$$\n\\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h},\n$$\n对于步长 $h>0$ 且满足 $\\sigma-h>0$。对于给定的 $(S_0,K,r,T,\\sigma)$ 和候选步长集合\n$$\n\\mathcal{H}=\\{10^{-12},10^{-11},10^{-10},10^{-9},10^{-8},10^{-7},10^{-6},10^{-5},10^{-4},10^{-3},10^{-2}\\},\n$$\n考虑其可采纳子集\n$$\n\\mathcal{H}_{\\text{adm}}=\\{h\\in\\mathcal{H}\\,:\\,0<h<\\sigma/2.0\\}.\n$$\n确定一个最优步长 $h^\\star \\in \\mathcal{H}_{\\text{adm}}$，使得绝对误差 $\\left|\\widehat{\\text{Vega}}(h^\\star)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right|$ 最小化。如果存在多个这样的步长，则选择最大的一个。\n\n对以下四种测试用例重复此过程：\n1.  $(S_0=100, K=100, r=0.01, T=1, \\sigma=0.2)$\n2.  $(S_0=100, K=100, r=0.01, T=0.01, \\sigma=0.2)$\n3.  $(S_0=100, K=102, r=0.02, T=0.5, \\sigma=0.05)$\n4.  $(S_0=100, K=100, r=0.03, T=2, \\sigma=0.6)$\n\n以 Python 列表的形式返回这四个 $h^\\star$ 值，并确保您的代码产生一个可以被 Python 的 `eval()` 函数解析的字符串，例如 `[1e-8,1e-6,1e-5,1e-7]`。", "solution": "问题陈述已经过严格验证，并被认为是有效的。它在科学上基于 Black-Scholes 期权定价理论和数值分析原理。它是一个适定问题，具有所有必要的参数、公式以及一个清晰、明确的目标。该问题没有矛盾和主观论断。因此，将给出一个解决方案。\n\n任务是为期权 Vega 的数值估计找到最佳步长 $h^\\star$。Vega 是期权价格相对于波动率 $\\sigma$ 的一阶偏导数。数值估计是使用对称差商进行的。最佳步长 $h^\\star$ 被定义为给定离散集 $\\mathcal{H}_{\\text{adm}}$ 中能够使 Vega 的数值估计与解析值之间绝对误差最小化的值。\n\n对于由参数集 $(S_0, K, r, T, \\sigma)$ 定义的每个测试用例，方法如下：\n\n1.  **解析 Vega 计算**：首先，使用提供的解析公式计算 Vega 的精确值：\n    $$ \\text{Vega}(S_0,K,r,T,\\sigma) = S_0 \\sqrt{T}\\,\\varphi(d_1) $$\n    其中 $\\varphi(\\cdot)$ 是标准正态分布的概率密度函数 (PDF)，而 $d_1$ 由下式给出：\n    $$ d_1=\\frac{\\ln(S_0/K)+\\left(r+\\frac{1}{2}\\sigma^2\\right)T}{\\sigma\\sqrt{T}} $$\n    这个解析值作为基准，用于与数值估计进行比较。\n\n2.  **数值估计与误差计算**：对于可采纳集 $\\mathcal{H}_{\\text{adm}}$ 中的每个步长 $h$，我们使用对称差商计算 Vega 的数值近似值，记为 $\\widehat{\\text{Vega}}(h)$：\n    $$ \\widehat{\\text{Vega}}(h)=\\frac{C(S_0,K,r,T,\\sigma+h)-C(S_0,K,r,T,\\sigma-h)}{2h} $$\n    在这里，$C(\\cdot)$ 是 Black-Scholes 看涨期权价格函数：\n    $$ C(S_0,K,r,T,\\sigma)=S_0\\,\\Phi(d_1)-K e^{-rT}\\,\\Phi(d_2) $$\n    其中 $\\Phi(\\cdot)$ 是标准正态分布的累积分布函数 (CDF)，且 $d_2 = d_1 - \\sigma\\sqrt{T}$。然后，每个 $h$ 的绝对误差计算如下：\n    $$ E(h)=\\left|\\widehat{\\text{Vega}}(h)-\\text{Vega}(S_0,K,r,T,\\sigma)\\right| $$\n\n3.  **最佳步长选择**：候选步长的集合由 $\\mathcal{H} = \\{10^{-12}, 10^{-11}, \\dots, 10^{-2}\\}$ 给出。可采纳集 $\\mathcal{H}_{\\text{adm}}$ 定义为 $\\{h\\in\\mathcal{H}\\,:\\,0<h<\\sigma/2.0\\}$。对于每个测试用例，我们计算所有 $h \\in \\mathcal{H}_{\\text{adm}}$ 对应的误差 $E(h)$。然后，我们找到最小的误差值 $E_{\\min} = \\min_{h \\in \\mathcal{H}_{\\text{adm}}} E(h)$。最后，我们确定所有达到此最小误差的步长集合 $\\{h' \\in \\mathcal{H}_{\\text{adm}} | E(h') = E_{\\min}\\}$。根据问题的规定，我们选择该集合中最大的步长作为最优步长 $h^\\star$。\n\n4.  **结果汇编**：对所有四个测试用例重复此过程，并将得到的四个最优步长 $h^\\star$ 值汇编成一个 Python 列表，以满足输出格式要求。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import norm\n\n# from scipy import ...\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (100.0, 100.0, 0.01, 1.0, 0.2),\n        (100.0, 100.0, 0.01, 0.01, 0.2),\n        (100.0, 102.0, 0.02, 0.5, 0.05),\n        (100.0, 100.0, 0.03, 2.0, 0.6),\n    ]\n\n    # Candidate set of step sizes H\n    H = [10**-12, 10**-11, 10**-10, 10**-9, 10**-8, 10**-7,\n         10**-6, 10**-5, 10**-4, 10**-3, 10**-2]\n\n    # Function to calculate Black-Scholes call price\n    def black_scholes_call(S0, K, r, T, sigma):\n        # Handle edge cases for sigma and T to avoid mathematical errors\n        if sigma == 0 or T == 0:\n            # If T > 0 and sigma == 0, the option price is deterministic.\n            # If T == 0, the option price is its intrinsic value.\n            return max(0.0, S0 - K * np.exp(-r * T))\n            \n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        d2 = d1 - sigma * np.sqrt(T)\n        price = S0 * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)\n        return price\n\n    # Function to calculate analytical Vega\n    def analytical_vega(S0, K, r, T, sigma):\n        # Vega is zero if T=0 or sigma=0\n        if sigma == 0 or T == 0:\n            return 0.0\n        d1 = (np.log(S0 / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))\n        vega = S0 * np.sqrt(T) * norm.pdf(d1)\n        return vega\n\n    optimal_h_results = []\n\n    for case in test_cases:\n        S0, K, r, T, sigma = case\n\n        # Determine the admissible set of step sizes.\n        H_adm = [h for h in H if 0 < h < sigma / 2.0]\n\n        # Calculate the true analytical Vega to use as a benchmark\n        true_vega = analytical_vega(S0, K, r, T, sigma)\n\n        errors_with_h = []\n        for h in H_adm:\n            # Calculate numerical Vega using symmetric difference quotient\n            C_plus = black_scholes_call(S0, K, r, T, sigma + h)\n            C_minus = black_scholes_call(S0, K, r, T, sigma - h)\n            numerical_vega = (C_plus - C_minus) / (2.0 * h)\n            \n            # Calculate the absolute error\n            error = abs(numerical_vega - true_vega)\n            errors_with_h.append((error, h))\n\n        # Find the minimum error among all step sizes\n        min_error = min(e for e, h in errors_with_h)\n\n        # Find all step sizes that achieve this minimum error\n        minimizing_hs = [h for e, h in errors_with_h if e == min_error]\n\n        # Select the largest h among the minimizers as per the tie-breaking rule\n        optimal_h = max(minimizing_hs)\n        optimal_h_results.append(optimal_h)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, optimal_h_results))}]\")\n\nsolve()\n```", "id": "2415200"}]}