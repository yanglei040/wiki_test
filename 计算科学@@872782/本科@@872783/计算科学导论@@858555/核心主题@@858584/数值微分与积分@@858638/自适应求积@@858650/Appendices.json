{"hands_on_practices": [{"introduction": "要真正掌握自适应求积，最好的方法就是亲手构建一个。这个练习将指导你仅使用基本的梯形法则，从头开始实现一个自适应积分方案。其核心思想是通过比较一个粗略的近似值（在整个区间上使用一个梯形）和一个更精细的近似值（在两个子区间上使用两个梯形）来估计积分误差，这个过程揭示了自适应方法中“估计、比较、细分”的核心反馈循环。通过这个练习，你将对自适应求积的内在逻辑有更深刻的理解 [@problem_id:3284319]。", "problem": "您的任务是构建一个基于第一性原理的、自包含的程序，该程序为梯形法则实现一个自适应数值积分方案。核心目标是使用一种自适应加密策略来近似一系列测试函数的定积分 $\\int_{a}^{b} f(x)\\,dx$。该策略通过比较整个区间上的梯形近似值与其两个半区间上梯形近似值之和来估计局部误差。\n\n从定积分作为黎曼和的极限的定义，以及在 $x=a$ 和 $x=b$ 之间构造 $f(x)$ 的线性插值函数开始。单个区间的梯形法则是通过在 $[a,b]$ 上对这个线性插值函数进行积分得出的。您的算法必须：\n- 在任何宽度为 $h=b-a$ 的子区间 $[a,b]$ 上，计算整个区间上的梯形近似值，以及在其两个半区间 $[a,m]$ 和 $[m,b]$（其中 $m=(a+b)/2$）上的组合梯形近似值。\n- 仅使用这两种近似值（整个区间与两个半区间之和）之间的比较来设计一个局部误差估计器，该估计器需通过对区间减半时局部截断误差如何随区间宽度变化的合理推断得出。不要假设或使用任何未从这种误差缩放推理中导出的快捷公式。\n- 如果估计的局部误差低于规定的容差，则接受该子区间，并可选择性地使用基于相同误差缩放原理推导出的偏差减小的修正估计值；否则，分割该区间并在每个半区间上进行递归。\n- 通过最大递归深度参数 $D_{\\max}$ 确保终止，并正确处理 $a=b$ 的退化区间。\n\n任何三角函数的角度单位都必须是弧度。本问题中没有物理单位。测试套件中的所有数值容差均为绝对容差。\n\n实现您的程序以评估以下测试套件。对于每个测试用例，使用您给定的容差的自适应梯形方案计算积分近似值，并将结果汇总到指定格式的单行输出中。\n\n测试套件：\n1. $f(x)=\\sin(x)$ 在 $[0,\\pi]$ 上，容差为 $10^{-12}$。\n2. $f(x)=e^{-x^{2}}$ 在 $[0,1]$ 上，容差为 $10^{-12}$。\n3. $f(x)=\\dfrac{1}{1+x^{2}}$ 在 $[-5,5]$ 上，容差为 $10^{-10}$。\n4. $f(x)=|x|$ 在 $[-1,1]$ 上，容差为 $10^{-10}$。\n5. $f(x)=\\dfrac{\\sin(100x)}{1+x^{2}}$ 在 $[0,1]$ 上，容差为 $10^{-8}$。\n6. $f(x)=5$ 在 $[2,5]$ 上，容差为 $10^{-12}$。\n7. $f(x)=\\sin(x)$ 在 $[1,1]$ 上（零长度区间），容差为 $10^{-12}$。\n\n覆盖性设计：\n- 第一个案例是一个光滑的周期函数在一个完整周期上的积分。\n- 第二个案例的被积函数呈钟形，在区间内尾部迅速衰减。\n- 第三个案例测试在一个对称大区间上的有理被积函数。\n- 第四个案例测试一个在中断点处不可微的被积函数。\n- 第五个案例是带有中等阻尼的振荡函数。\n- 第六个案例是常数函数，应立即终止。\n- 第七个案例是零长度区间的边界情况。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含一个逗号分隔的列表，用方括号括起来，不含额外的空格或文本。例如：\"[r1,r2,r3,r4,r5,r6,r7]\"。每个 $r_{i}$ 必须是一个浮点数，代表相应测试用例的积分近似值，由您的自适应梯形方法计算得出。", "solution": "该问题要求开发一种基于梯形法则的自适应数值积分方案。任务的核心是从第一性原理出发，具体通过比较一个区间上的粗略近似值与一个更精细的近似值，来推导误差估计和加密策略。\n\n### 基于原理的推导\n\n设备要近似的定积分为 $I = \\int_{a}^{b} f(x)\\,dx$。\n\n**1. 基于第一性原理的梯形法则**\n\n梯形法则用一个线性多项式 $p_1(x)$ 来近似被积函数 $f(x)$，该多项式在区间 $[a, b]$ 的端点处对函数进行插值。这些点的坐标是 $(a, f(a))$ 和 $(b, f(b))$。线性插值函数由下式给出：\n$$p_1(x) = f(a) + \\frac{f(b) - f(a)}{b-a}(x - a)$$\n在区间 $[a, b]$ 上对这个线性多项式进行积分，即可得到梯形近似值，记为 $T(a,b)$。设 $h = b - a$ 为区间的宽度。\n$$T(a,b) = \\int_{a}^{b} p_1(x) \\,dx = \\int_{a}^{b} \\left( f(a) + \\frac{f(b) - f(a)}{h}(x - a) \\right) \\,dx$$\n$$= \\left[ f(a)x + \\frac{f(b) - f(a)}{h} \\left( \\frac{x^2}{2} - ax \\right) \\right]_{a}^{b}$$\n$$= f(a)(b-a) + \\frac{f(b) - f(a)}{h} \\left( \\left(\\frac{b^2}{2} - ab\\right) - \\left(\\frac{a^2}{2} - a^2\\right) \\right)$$\n$$= f(a)h + \\frac{f(b) - f(a)}{h} \\left( \\frac{b^2 - 2ab + a^2}{2} \\right) = f(a)h + \\frac{f(b) - f(a)}{h} \\frac{(b-a)^2}{2}$$\n$$= f(a)h + (f(b) - f(a))\\frac{h}{2} = \\frac{h}{2}(2f(a) + f(b) - f(a)) = \\frac{h}{2}(f(a) + f(b))$$\n这就是单区间的梯形法则。我们称这个粗略近似为 $S_1$。\n$$S_1 = \\frac{h}{2}(f(a) + f(b))$$\n\n**2. 通过加密进行误差估计**\n\n为了估计误差，我们将 $S_1$ 与一个更精确的近似值 $S_2$ 进行比较，后者是通过将区间 $[a, b]$ 分割成两个等宽的子区间 $[a, m]$ 和 $[m, b]$ 得到的，其中 $m = (a+b)/2$。每个子区间的宽度是 $h/2$。近似值 $S_2$ 是对每个子区间应用梯形法则后的结果之和：\n$$S_2 = T(a, m) + T(m, b) = \\frac{h/2}{2}(f(a) + f(m)) + \\frac{h/2}{2}(f(m) + f(b))$$\n$$S_2 = \\frac{h}{4}(f(a) + 2f(m) + f(b))$$\n\n对于宽度为 $w$ 的区间，梯形法则的局部截断误差由 $E(w) = -\\frac{w^3}{12}f''(\\xi)$ 给出，其中 $\\xi$ 在该区间内，且假设 $f$ 是二阶连续可微的。这表明误差与区间宽度的三次方成正比，即 $E(w) \\approx Cw^3$。\n\n真实积分 $I$ 可以与我们的近似值 $S_1$ 和 $S_2$ 关联如下：\n$I = S_1 + E(h) \\approx S_1 + Ch^3$\n$I = S_2 + E(h/2) + E(h/2) \\approx S_2 + 2C(h/2)^3 = S_2 + \\frac{Ch^3}{4}$\n\n现在我们有两个方程和两个未知数 $I$ 和 $C$ 组成的方程组：\n$I - S_1 \\approx Ch^3$\n$I - S_2 \\approx \\frac{Ch^3}{4}$\n\n用第一个方程减去第二个方程可得：\n$(I - S_2) - (I - S_1) \\approx \\frac{Ch^3}{4} - Ch^3 \\implies S_1 - S_2 \\approx -\\frac{3}{4}Ch^3$\n\n这使我们能够用计算出的量 $S_1$ 和 $S_2$ 来表示未知项 $Ch^3$：\n$Ch^3 \\approx \\frac{4}{3}(S_2 - S_1)$\n\n现在可以估计更精确近似 $S_2$ 的误差 $E_2 = I - S_2$。\n$E_2 \\approx \\frac{Ch^3}{4} \\approx \\frac{1}{4} \\left( \\frac{4}{3}(S_2 - S_1) \\right) = \\frac{1}{3}(S_2 - S_1)$\n\n因此，更精细近似 $S_2$ 的绝对局部误差可以估计为：\n$$\\text{err} \\approx \\frac{1}{3}|S_2 - S_1|$$\n这个估计器完全是根据两种近似值的比较和局部误差的缩放性质推导出来的，符合要求。\n\n**3. 自适应算法与偏差减小**\n\n自适应算法以递归方式进行。对于给定的区间 $[a, b]$ 和绝对容差 $\\tau$：\n1.  计算 $S_1$、$S_2$ 和误差估计 $\\text{err} = \\frac{1}{3}|S_2 - S_1|$。\n2.  如果 $\\text{err}  \\tau$，则认为该区间的近似已足够精确。该分支的处理过程终止。\n3.  如果 $\\text{err} \\ge \\tau$，则将该区间分割为 $[a, m]$ 和 $[m, b]$。然后对每个子区间递归调用该算法，并相应地分配容差预算，通常每个子区间为 $\\tau/2$。递归调用的结果相加。\n\n问题提到使用“偏差减小的修正估计值”。这是理查森外推法的一种应用。通过用我们的误差估计 $E_2$ 来修正 $S_2$，可以得到真实积分 $I$ 的一个更好的估计：\n$$I \\approx S_2 + E_2 \\approx S_2 + \\frac{1}{3}(S_2 - S_1) = \\frac{4S_2 - S_1}{3}$$\n这个修正后的值，实际上就是区间 $[a,b]$ 上的辛普森法则：\n$$\\frac{4}{3} \\left( \\frac{h}{4}(f(a) + 2f(m) + f(b)) \\right) - \\frac{1}{3} \\left( \\frac{h}{2}(f(a) + f(b)) \\right) = \\frac{h}{3}(f(a) + 2f(m) + f(b)) - \\frac{h}{6}(f(a) + f(b))$$\n$$= \\frac{h}{6} (2f(a) + 4f(m) + 2f(b) - f(a) - f(b)) = \\frac{h}{6}(f(a) + 4f(m) + f(b))$$\n当一个区间被接受时（即 $\\text{err}  \\tau$），返回这个更高阶的辛普森法则近似值，可以在函数求值次数相同的情况下提供更精确的结果。\n\n**4. 实现结构与终止条件**\n\n该算法实现为一个递归函数。一个包装函数初始化该过程。\n- **递归的基准情形：**\n    1.  如果 $a = b$，积分为 $0$。\n    2.  设置最大递归深度 $D_{\\max}$ 以保证终止，即使在容差标准永远无法满足的情况下（例如，对于某些病态函数或浮点精度不足）。如果达到此深度，则返回当前对该子区间的最佳估计值。\n\n- **递归步骤：**\n    一个内部函数 `_adaptive_trapezoid(f, a, b, tol, fa, fb, depth)` 将执行主要逻辑。将 `fa=f(a)` 和 `fb=f(b)` 作为参数传递，可以避免在父子区间共用的端点上进行重复的函数求值。如果误差标准未满足，它将进行两次递归调用：\n    `_adaptive_trapezoid(f, a, m, tol/2, fa, fm, depth+1) + _adaptive_trapezoid(f, m, b, tol/2, fm, fb, depth+1)`\n    其中 $m=(a+b)/2$ 且 $fm=f(m)$。这种结构高效且稳健地实现了自适应积分方案。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the adaptive integration problem for the given test suite.\n    \"\"\"\n\n    MAX_DEPTH = 50\n\n    def _adaptive_trapezoid(f, a, b, tol, fa, fb, depth):\n        \"\"\"\n        Recursive helper function for adaptive trapezoidal integration.\n\n        This function approximates the integral of f(x) from a to b. It estimates\n        the error by comparing a one-panel trapezoid rule with a two-panel rule.\n        If the error is too large, it recursively calls itself on the two halves\n        of the interval.\n\n        Args:\n            f (callable): The function to integrate.\n            a (float): The start of the integration interval.\n            b (float): The end of the integration interval.\n            tol (float): The absolute tolerance for this subinterval.\n            fa (float): The value of f(a), passed to avoid re-computation.\n            fb (float): The value of f(b), passed to avoid re-computation.\n            depth (int): The current recursion depth.\n\n        Returns:\n            float: The approximated integral value for the interval [a, b].\n        \"\"\"\n        # Base case 1: Zero-length interval\n        if a == b:\n            return 0.0\n\n        # Base case 2: Maximum recursion depth reached\n        if depth  MAX_DEPTH:\n            # Reached depth limit, return best available coarse estimate.\n            # A warning could be printed here in a real application.\n            h = b - a\n            return (h / 2.0) * (fa + fb)\n\n        h = b - a\n        m = (a + b) / 2.0\n        fm = f(m)\n\n        # S1: Coarse approximation (1 trapezoid over [a,b])\n        s1 = (h / 2.0) * (fa + fb)\n\n        # S2: Finer approximation (2 trapezoids over [a,m] and [m,b])\n        s2 = (h / 4.0) * (fa + 2.0 * fm + fb)\n\n        # Estimate the error of the more accurate approximation, S2.\n        # This is derived from Richardson extrapolation, where error(S2) ~ (S2-S1)/3\n        error_estimate = abs(s2 - s1) / 3.0\n\n        if error_estimate  tol:\n            # Error is within tolerance. Return the bias-reduced (Simpson's rule) value.\n            # This is S2 + error_estimate, which is more accurate.\n            return s2 + (s2 - s1) / 3.0\n        else:\n            # Error is too large. Split the interval and recurse.\n            # The tolerance is split between the two sub-intervals.\n            left_integral = _adaptive_trapezoid(f, a, m, tol / 2.0, fa, fm, depth + 1)\n            right_integral = _adaptive_trapezoid(f, m, b, tol / 2.0, fm, fb, depth + 1)\n            return left_integral + right_integral\n\n    def adaptive_integrator(f, a, b, tol):\n        \"\"\"\n        Wrapper function to start the adaptive integration process.\n        \"\"\"\n        # Initial call to the recursive helper function.\n        # Pre-calculates f(a) and f(b) for efficiency.\n        return _adaptive_trapezoid(f, a, b, tol, f(a), f(b), 0)\n\n    # Test Suite Definition\n    test_cases = [\n        {'func': lambda x: np.sin(x), 'interval': (0, np.pi), 'tol': 1e-12},\n        {'func': lambda x: np.exp(-x**2), 'interval': (0, 1), 'tol': 1e-12},\n        {'func': lambda x: 1.0 / (1.0 + x**2), 'interval': (-5, 5), 'tol': 1e-10},\n        {'func': lambda x: np.abs(x), 'interval': (-1, 1), 'tol': 1e-10},\n        {'func': lambda x: np.sin(100 * x) / (1.0 + x**2), 'interval': (0, 1), 'tol': 1e-8},\n        {'func': lambda x: 5.0, 'interval': (2, 5), 'tol': 1e-12}, # Use 5.0 to ensure float\n        {'func': lambda x: np.sin(x), 'interval': (1, 1), 'tol': 1e-12},\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case['func']\n        a, b = case['interval']\n        tol = case['tol']\n        \n        # Handle the zero-length interval case explicitly in the wrapper for clarity,\n        # although the recursion also handles it.\n        if a == b:\n            result = 0.0\n        else:\n            result = adaptive_integrator(f, a, b, tol)\n        \n        results.append(result)\n\n    # Format the final output string exactly as required.\n    # The repr() function provides a high-precision string representation of floats.\n    print(f\"[{','.join(map(repr, results))}]\")\n\nsolve()\n\n```", "id": "3284319"}, {"introduction": "在科学与工程领域，我们处理的往往是离散的数据点，而非完美的数学函数。本练习将理论与实践相结合，要求你将自适应求积的原理应用于处理一组传感器读数，以计算材料吸收的总能量。它演示了如何将比较粗略估计和精细估计的相同逻辑应用于离散的迭代情景，从而让你体会到如何将数值方法应用于解决真实的实验科学问题 [@problem_id:2153091]。", "problem": "一个实验装置使用热流传感器来测量在时间 $t$ 内流入一种新型相变材料的热流率 $P(t)$。目标是确定该材料在3秒时间间隔内吸收的总能量 $E$，该能量由积分 $E = \\int_{0}^{3} P(t) \\,dt$ 给出。由于传感器的特性，我们无法获得 $P(t)$ 的连续函数。而是提供了一组带有时间戳的离散测量数据 $(t_i, P_i)$，其中时间单位为秒 (s)，功率单位为瓦 (W)。数据点以均匀的时间间隔采样，如下所示：\n\n$(t_0, P_0) = (0.0, 1.0)$\n$(t_1, P_1) = (0.5, 1.5)$\n$(t_2, P_2) = (1.0, 3.0)$\n$(t_3, P_3) = (1.5, 1.6)$\n$(t_4, P_4) = (2.0, 1.8)$\n$(t_5, P_5) = (2.5, 2.0)$\n$(t_6, P_6) = (3.0, 2.2)$\n\n为了估算总能量，你必须实现一个特定的自适应积分算法，该算法从 $t=0$ 开始处理数据。该算法评估信号在数据块上的“复杂性”，并相应地调整其步长。\n\n算法定义如下：\n1.  初始化总能量 $E = 0$，并从第一个数据点（索引 $i=0$）开始。\n2.  从当前索引 $i$ 开始，考虑一个由两个相邻区间组成的数据块，覆盖了点 $(t_i, P_i)$、$(t_{i+1}, P_{i+1})$ 和 $(t_{i+2}, P_{i+2})$。\n3.  使用梯形法则，在从 $t_i$ 到 $t_{i+2}$ 的整个块宽度上，计算此数据块的“粗略”积分估计值 $I_{\\text{coarse}}$。\n4.  将梯形法则分别应用于两个较小的区间 $[t_i, t_{i+1}]$ 和 $[t_{i+1}, t_{i+2}]$，然后将结果相加，计算出“精细”积分估计值 $I_{\\text{fine}}$。\n5.  比较这两个估计值。如果绝对差 $|I_{\\text{fine}} - I_{\\text{coarse}}|$ 小于或等于绝对容差 $\\tau = 0.2$，则该数据块被认为是“平滑的”。\n    -   如果数据块是平滑的，将更精确的精细估计值 $I_{\\text{fine}}$ 加到总能量 $E$ 上，并将当前索引前进2（即，下一步将从 $i+2$ 开始）。\n    -   如果数据块不平滑（差值超过 $\\tau$），则该区域是“复杂的”。仅将第一个小区间 $[t_i, t_{i+1}]$ 的积分贡献加到总能量 $E$ 上。然后，将当前索引仅前进1（即，下一步将从 $i+1$ 开始）。\n6.  如果当前索引 $i$ 使得无法形成一个包含两个区间的完整数据块（即，索引 $i+2$ 不存在），则计算剩余单个区间 $[t_i, t_{i+1}]$ 的积分，将其加到总能量 $E$ 上，并终止该过程。\n7.  从步骤2开始重复，直到处理完整个数据集。\n\n使用此算法，计算材料吸收的总能量 $E$。最终答案以焦耳 (J) 为单位表示。", "solution": "我们要使用指定的自适应算法，根据离散的、均匀采样的数据求解能量 $E=\\int_{0}^{3} P(t)\\,dt$。对于区间 $[t_{a},t_{b}]$，其端点值为 $P_{a}$ 和 $P_{b}$，梯形法则是\n$$\nI_{\\text{trap}}([t_{a},t_{b}])=\\frac{t_{b}-t_{a}}{2}\\left(P_{a}+P_{b}\\right).\n$$\n对于从索引 $i$ 开始的数据块，在 $[t_{i},t_{i+2}]$ 上的粗略估计和在 $[t_{i},t_{i+1}]$ 与 $[t_{i+1},t_{i+2}]$ 上的精细估计分别是\n$$\nI_{\\text{coarse}}^{(i)}=\\frac{t_{i+2}-t_{i}}{2}\\left(P_{i}+P_{i+2}\\right),\\qquad\nI_{\\text{fine}}^{(i)}=\\frac{t_{i+1}-t_{i}}{2}\\left(P_{i}+P_{i+1}\\right)+\\frac{t_{i+2}-t_{i+1}}{2}\\left(P_{i+1}+P_{i+2}\\right).\n$$\n对所有 $i$，采样间隔为 $h=t_{i+1}-t_{i}=0.5$，容差为 $\\tau=0.2$。初始化 $E=0$ 和 $i=0$。\n\n数据块 $i=0$ 使用 $(t_{0},P_{0})=(0.0,1.0)$, $(t_{1},P_{1})=(0.5,1.5)$, $(t_{2},P_{2})=(1.0,3.0)$。计算\n$$\nI_{\\text{coarse}}^{(0)}=\\frac{1.0-0.0}{2}(1.0+3.0)=\\frac{1.0}{2}\\cdot 4.0=2.0,\n$$\n$$\nI_{\\text{fine}}^{(0)}=\\frac{0.5}{2}(1.0+1.5)+\\frac{0.5}{2}(1.5+3.0)=0.25\\cdot 2.5+0.25\\cdot 4.5=0.625+1.125=1.75.\n$$\n差值为 $|I_{\\text{fine}}^{(0)}-I_{\\text{coarse}}^{(0)}|=|1.75-2.0|=0.25\\tau$，所以该数据块是复杂的。仅加上第一个小区间的积分：\n$$\nE\\leftarrow E+0.625=0.625,\\quad i\\leftarrow 1.\n$$\n\n数据块 $i=1$ 使用 $(t_{1},P_{1})=(0.5,1.5)$, $(t_{2},P_{2})=(1.0,3.0)$, $(t_{3},P_{3})=(1.5,1.6)$。计算\n$$\nI_{\\text{coarse}}^{(1)}=\\frac{1.5-0.5}{2}(1.5+1.6)=\\frac{1.0}{2}\\cdot 3.1=1.55,\n$$\n$$\nI_{\\text{fine}}^{(1)}=\\frac{0.5}{2}(1.5+3.0)+\\frac{0.5}{2}(3.0+1.6)=0.25\\cdot 4.5+0.25\\cdot 4.6=1.125+1.15=2.275.\n$$\n差值为 $|2.275-1.55|=0.725\\tau$，复杂的。仅加上第一个小区间的积分：\n$$\nE\\leftarrow 0.625+1.125=1.75,\\quad i\\leftarrow 2.\n$$\n\n数据块 $i=2$ 使用 $(t_{2},P_{2})=(1.0,3.0)$, $(t_{3},P_{3})=(1.5,1.6)$, $(t_{4},P_{4})=(2.0,1.8)$。计算\n$$\nI_{\\text{coarse}}^{(2)}=\\frac{2.0-1.0}{2}(3.0+1.8)=\\frac{1.0}{2}\\cdot 4.8=2.4,\n$$\n$$\nI_{\\text{fine}}^{(2)}=\\frac{0.5}{2}(3.0+1.6)+\\frac{0.5}{2}(1.6+1.8)=0.25\\cdot 4.6+0.25\\cdot 3.4=1.15+0.85=2.0.\n$$\n差值为 $|2.0-2.4|=0.4\\tau$，复杂的。仅加上第一个小区间的积分：\n$$\nE\\leftarrow 1.75+1.15=2.9,\\quad i\\leftarrow 3.\n$$\n\n数据块 $i=3$ 使用 $(t_{3},P_{3})=(1.5,1.6)$, $(t_{4},P_{4})=(2.0,1.8)$, $(t_{5},P_{5})=(2.5,2.0)$。计算\n$$\nI_{\\text{coarse}}^{(3)}=\\frac{2.5-1.5}{2}(1.6+2.0)=\\frac{1.0}{2}\\cdot 3.6=1.8,\n$$\n$$\nI_{\\text{fine}}^{(3)}=\\frac{0.5}{2}(1.6+1.8)+\\frac{0.5}{2}(1.8+2.0)=0.25\\cdot 3.4+0.25\\cdot 3.8=0.85+0.95=1.8.\n$$\n差值为 $|1.8-1.8|=0\\leq \\tau$，平滑的。加上精细估计值并前进2：\n$$\nE\\leftarrow 2.9+1.8=4.7,\\quad i\\leftarrow 5.\n$$\n\n当 $i=5$ 时，只剩下单个区间 $[t_{5},t_{6}]$。其梯形积分贡献为\n$$\nI_{\\text{trap}}([t_{5},t_{6}])=\\frac{0.5}{2}(2.0+2.2)=0.25\\cdot 4.2=1.05.\n$$\n相加并终止：\n$$\nE\\leftarrow 4.7+1.05=5.75.\n$$\n因此，在3秒时间间隔内吸收的总能量为 $E=5.75$ 焦耳。", "answer": "$$\\boxed{5.75}$$", "id": "2153091"}, {"introduction": "一个基础的自适应算法在遇到具有尖锐跳跃或不连续性的函数时可能会失效，陷入无限递归的陷阱。这个高级实践旨在解决这一关键问题，通过实现一个基于浮点运算限制的鲁棒停止准则来增强算法的可靠性。通过处理具有挑战性的赫维赛德阶跃函数，你将学习如何使你的数值积分器在面对现实世界中的复杂函数时，表现得更加稳健和可靠 [@problem_id:3203393]。", "problem": "您的任务是设计并实现一个误差控制的自适应求积算法。该算法通过引入一个与浮点分辨率相关的、有原则的停止准则，在存在跳跃间断点的情况下仍能保持鲁棒性。该任务的背景是在一个闭区间上对一个有界函数进行定积分的数值近似。此任务的基础包括：(i) 黎曼积分的定义，即闭区间上有界函数的黎曼和的极限；(ii) 基于等距节点上多项式插值的复合求积法则；(iii) 双精度浮点运算的性质，特别是机器ε的概念。\n\n任务要求：\n- 实现一个基于每个子区间上三节点多项式插值的自适应区间加密求积方法。您的递归必须由一个通过比较单个父区间与其两个子区间的计算结果得出的误差指标来引导。不要硬编码最大递归深度；您的方法必须由一个数值误差容限和下述的鲁棒停止准则来控制。\n- 构建并使用一个鲁棒的停止准则，通过强制设定一个与双精度机器ε相关的最小区间宽度，来防止在间断点附近的无限加密。设双精度机器ε为 $\\varepsilon_{\\mathrm{mach}}$，通过编程方式获得。定义最小区间宽度为\n$h_{\\min} = \\beta \\cdot \\max(1, \\lvert a \\rvert, \\lvert b \\rvert) \\cdot \\varepsilon_{\\mathrm{mach}},$\n其中 $\\beta = 256$，$ [a,b] $ 是当前区间。如果一个宽度为 $h$ 的区间满足 $h \\le h_{\\min}$，您必须终止对该区间的加密，并接受子区间的近似值，不再进行进一步细分。此外，如果由于浮点分辨率的限制，中点等于任一端点，也必须终止对该区间的加密。\n- 被积函数：使用平移至间断点 $x=\\frac{1}{2}$ 的亥维赛阶跃函数，\n$$ f(x) = H(x - 0.5) = \\begin{cases} 0,  x  0.5, \\\\ 0,  x = 0.5, \\\\ 1,  x  0.5, \\end{cases} $$\n其中间断点处的值设为 $0$，以强制产生非平凡的加密行为。\n- 误差容限：将用户指定的容限表示为 $\\tau$，并通过子区间与父区间的比较在自适应递归中强制执行该容限。您的算法应返回数值积分近似值和一个布尔指示符，该指示符说明在该积分评估的递归过程中，最小宽度限制是否至少被触发过一次。\n\n测试套件：\n在下列每个区间和容限下评估 $f(x)$ 的积分：\n1. $[0,1]$，容限为 $\\tau = 10^{-8}$。\n2. $[0,1]$，容限为 $\\tau = 10^{-20}$。\n3. $[0,0.49]$，容限为 $\\tau = 10^{-8}$。\n4. $[0.51,1]$，容限为 $\\tau = 10^{-8}$。\n\n答案规格：\n- 对于每个测试用例，返回两个输出：积分近似值（一个浮点数）和布尔指示符（如果最小宽度限制被触发则为true，否则为false）。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序如下：\n$$\n[\\text{I}_1,\\text{C}_1,\\text{I}_2,\\text{C}_2,\\text{I}_3,\\text{C}_3,\\text{I}_4,\\text{C}_4],\n$$\n其中 $\\text{I}_k$ 是测试用例k的积分近似值（浮点数），$\\text{C}_k$ 是限制触发指示符（布尔值）。\n不涉及物理单位，也没有出现角度；所有量都是无量纲的。", "solution": "问题陈述经评估是有效的。这是一个在数值分析领域内提法适定、有科学依据的问题。它为设计和实现一个带有鲁棒停止准则、用以处理含跳跃间断点函数的自适应求积算法，提供了一套完整且一致的要求。所有参数、待积函数以及测试用例都得到了明确的规定。\n\n该解决方案是通过综合数值积分、误差估计和浮点运算的原理来制定的。该算法是一个基于 Simpson 法则的递归自适应求积方法，并增加了一个停止准则，该准则通过遵循双精度浮点分辨率的限制来确保在存在间断点时算法能够终止。\n\n算法的核心组成部分如下：\n\n1.  **基本求积法则：Simpson 法则**\n    问题指定了一个基于每个子区间上三节点多项式插值的求积法则。对于一个区间 $[a, b]$，节点的标准选择是端点 $a$、$b$ 以及中点 $m = (a+b)/2$。对在这些点 $(a, f(a))$、$(m, f(m))$ 和 $(b, f(b))$ 上插值函数 $f(x)$ 的唯一二次多项式进行精确积分，即可得到 Simpson 法则。$f(x)$ 在 $[a, b]$ 上的积分近似值，记为 $S(a,b)$，由下式给出：\n    $$\n    S(a, b) = \\frac{b-a}{6} \\left( f(a) + 4f\\left(\\frac{a+b}{2}\\right) + f(b) \\right)\n    $$\n    Simpson 法则对最高为3次的多项式是精确的。\n\n2.  **带误差估计的自适应加密**\n    自适应求积的原理是仅在函数“难于”积分的区域（即估计的积分误差较大的区域）加密区间。这是通过一个递归过程实现的。对于给定的区间 $[a, b]$，我们计算一个粗略近似值 $I_{parent} = S(a, b)$。然后，我们在其中点 $m = (a+b)/2$ 处将该区间细分为两个子区间 $[a, m]$ 和 $[m, b]$。一个更精确的近似值 $I_{children}$ 是通过对每个子区间上的 Simpson 法则结果求和来计算的：\n    $I_{children} = S(a, m) + S(m, b)$\n    粗略近似 $S(a,b)$ 的误差阶为 $\\mathcal{O}((b-a)^5)$，而更精确近似 $I_{children}$ 的误差阶为 $\\mathcal{O}((m-a)^5 + (b-m)^5) = \\mathcal{O}(2 \\cdot (\\frac{b-a}{2})^5) = \\frac{1}{16}\\mathcal{O}((b-a)^5)$。这意味着更精确近似的误差大约是粗略近似误差的 $1/16$。因此，这两个计算值之间的差可以用来估计更精确近似 $I_{children}$ 的误差：\n    $$\n    E_{children} \\approx \\frac{1}{15} |I_{children} - I_{parent}|\n    $$\n    如果这个估计误差在指定的容限 $\\tau_{panel}$ 之内，则对区间 $[a,b]$ 的加密过程终止。我们采用一个常用策略，即检查是否有 $|I_{children} - I_{parent}|  15 \\cdot \\tau_{panel}$。整个积分域的全局容限，记为 $\\tau$，被分配到各个子区间。对于二分法，一个简单有效的方法是将父区间的容限一半分配给每个子区间，因此在每一层递归中，一个区间的容限会为其子区间减半。\n\n3.  **针对间断点的鲁棒停止准则**\n    对于具有跳跃间断点的函数，如指定的亥维赛函数 $f(x) = H(x - 0.5)$，在间断点 $x=0.5$ 附近的误差不会随着区间加密而以预期的速率减小。误差估计将持续无法通过容限检查，导致算法在试图解析该跳跃时出现无限递归。为保证终止，必须采用一个基于浮点运算限制的鲁棒停止准则。该指定准则包含两个部分，在对宽度为 $h=b-a$ 的区间 $[a, b]$ 的每个递归步骤开始时进行检查：\n    \n    a. **最小区间宽度 ($h_{min}$)**：如果区间宽度 $h$ 小于预设的最小值 $h_{min}$，则停止加密。这个最小值是相对于区间端点的尺度和机器精度 $\\varepsilon_{\\mathrm{mach}}$（在浮点运算中，使 $1.0 + \\varepsilon_{\\mathrm{mach}}  1.0$ 成立的最小数）来定义的。\n    $$\n    h_{\\min} = \\beta \\cdot \\max(1, |a|, |b|) \\cdot \\varepsilon_{\\mathrm{mach}}\n    $$\n    给定参数 $\\beta=256$，这就为区间宽度设定了一个下限，防止了无限细分。如果 $h \\le h_{\\min}$，我们停止递归。\n\n    b. **浮点分辨率限制**：当 $a$ 和 $b$ 变得非常接近时，它们的中点 $m = (a+b)/2$ 在计算上可能与 $a$ 或 $b$ 无法区分。如果 $m=a$ 或 $m=b$，在给定的浮点系统中，进一步的细分在数学上是不可能的。这个条件作为一个根本的保障措施。\n\n    如果满足这两个条件中的任意一个，当前区间的加密将被终止，并将更精确的近似值 $I_{children}$ 作为该区间的结果。返回一个布尔标志以表明这种特殊终止被触发了。\n\n4.  **算法综合**\n    完整的算法被实现为一个递归函数。一个主入口函数 `adaptive_quadrature(func, a, b, tol)` 负责设置初始区间和容限，并调用一个递归辅助函数。\n    递归辅助函数 `_recursive_quad(func, a, b, tol_sub, ...)` 对其给定的区间执行以下步骤：\n    i. 检查鲁棒停止准则。如果满足，则返回子区间近似值 $I_{children}$ 和一个 `true` 标志。\n    ii. 计算父区间近似值 $I_{parent}$ 和子区间近似值 $I_{children}$。\n    iii. 计算误差估计值 $|I_{children} - I_{parent}|$。\n    iv. 如果误差在区间的容限之内（$  15 \\cdot \\tau_{sub}$），则返回 $I_{children}$ 和一个 `false` 标志。\n    v. 否则，对两个子区间 $[a, m]$ 和 $[m, b]$ 递归调用该函数，每个子区间的容限为原容限的一半，即 $\\tau_{sub}/2$。\n    vi. 将两次子调用的积分结果相加。`cap_triggered` 状态是子调用返回状态的逻辑或，确保如果在任何子问题中触发了限制，最终结果能反映这一点。\n\n这个设计正确地实现了所有要求，提供了一个鲁棒的数值积分器，能够处理指定的测试用例，包括在一个包含间断点的区间上使用非常小的容限这一具有挑战性的场景，该场景专门用于测试停止准则。", "answer": "```python\nimport numpy as np\n\n# A global constant for double-precision machine epsilon is defined for convenience.\n_EPS = np.finfo(float).eps\n\ndef f(x: float) - float:\n    \"\"\"\n    Implements the integrand f(x) = H(x - 0.5), a Heaviside step function.\n    The value at the discontinuity x=0.5 is explicitly defined as 0.\n    \"\"\"\n    if x  0.5:\n        return 0.0\n    elif x  0.5:\n        return 1.0\n    else:  # x == 0.5\n        return 0.0\n\ndef _recursive_quad(func, a, b, tol, fa, fm, fb, I_panel):\n    \"\"\"\n    Recursive helper function for the adaptive quadrature algorithm.\n\n    This function performs one step of the adaptive refinement. It checks stopping criteria,\n    estimates error, and decides whether to accept the current approximation or to\n    recurse on sub-panels.\n\n    Args:\n        func: The function to integrate.\n        a, b: The endpoints of the current panel.\n        tol: The error tolerance for the current panel.\n        fa, fm, fb: Pre-computed function values at a, m=(a+b)/2, and b.\n        I_panel: The Simpson's rule approximation on the parent panel [a, b].\n\n    Returns:\n        A tuple (integral_value, cap_triggered), where integral_value is the\n        numerical approximation of the integral on [a, b], and cap_triggered\n        is a boolean indicating if the robust stopping criterion was met.\n    \"\"\"\n    h = b - a\n    m = (a + b) / 2.0\n\n    # 1. Robust Stopping Criterion\n    # This prevents unbounded recursion near discontinuities.\n    h_min = 256.0 * max(1.0, abs(a), abs(b)) * _EPS\n    cap_triggered_this_level = (h = h_min) or (m == a) or (m == b)\n\n    # 2. Compute Refined Approximation\n    # Subdivide the panel and apply Simpson's rule to each child.\n    ml = (a + m) / 2.0\n    mr = (m + b) / 2.0\n    fml = func(ml)\n    fmr = func(mr)\n\n    # Simpson's rule over child panels [a, m] and [m, b]\n    # Note: width of each child panel is h/2. The (h/2)/6 factor is (b-a)/12.\n    I_left = (h / 12.0) * (fa + 4.0 * fml + fm)\n    I_right = (h / 12.0) * (fm + 4.0 * fmr + fb)\n    I_children = I_left + I_right\n\n    if cap_triggered_this_level:\n        # If the panel is too small, accept the child approximation and terminate.\n        return I_children, True\n\n    # 3. Error Estimation and Recursion Decision\n    error_est = abs(I_children - I_panel)\n\n    # The error in the refined sum (I_children) is approx. 1/15 of the difference.\n    # We stop if the estimated error is less than the allocated tolerance.\n    # The check is written as `error_est  15 * tol` for numerical stability.\n    if error_est  15.0 * tol:\n        # The problem asks to accept the child-panel approximation.\n        # A more advanced version would add a correction term: I_children + error_est / 15.0\n        return I_children, False\n    else:\n        # If error is too large, recurse on the two child panels.\n        # The tolerance is distributed (halved for each child).\n        tol_sub = tol / 2.0\n        integral_left, cap_left = _recursive_quad(func, a, m, tol_sub, fa, fml, fm, I_left)\n        integral_right, cap_right = _recursive_quad(func, m, b, tol_sub, fm, fmr, fb, I_right)\n\n        # Combine results and propagate the cap_triggered flag.\n        return integral_left + integral_right, cap_left or cap_right\n\ndef adaptive_quadrature(func, a, b, tol):\n    \"\"\"\n    Top-level function for error-controlled adaptive quadrature.\n\n    Args:\n        func: The function to integrate.\n        a, b: The overall integration interval [a, b].\n        tol: The absolute error tolerance for the entire interval.\n\n    Returns:\n        A tuple (integral_value, cap_triggered).\n    \"\"\"\n    h = b - a\n    if h == 0.0:\n        return 0.0, False\n    \n    m = (a + b) / 2.0\n    fa, fm, fb = func(a), func(m), func(b)\n\n    # Initial Simpson's rule approximation over the whole interval [a, b]\n    I_panel = h / 6.0 * (fa + 4.0 * fm + fb)\n\n    return _recursive_quad(func, a, b, tol, fa, fm, fb, I_panel)\n\ndef solve():\n    \"\"\"\n    Executes the test suite and prints the final answer in the specified format.\n    \"\"\"\n    test_cases = [\n        (0.0, 1.0, 1e-8),    # Case 1: Standard run with discontinuity\n        (0.0, 1.0, 1e-20),   # Case 2: Tiny tolerance, should trigger h_min cap\n        (0.0, 0.49, 1e-8),   # Case 3: Smooth region (f(x)=0)\n        (0.51, 1.0, 1e-8)    # Case 4: Smooth region (f(x)=1)\n    ]\n\n    results = []\n    for a, b, tol in test_cases:\n        integral, cap_triggered = adaptive_quadrature(f, a, b, tol)\n        results.append(integral)\n        # Format boolean as lowercase 'true'/'false' string as per problem implications\n        results.append(str(cap_triggered).lower())\n\n    # Format the final output as a single comma-separated list in brackets.\n    output_str = \",\".join(map(str, results))\n    print(f\"[{output_str}]\")\n\nsolve()\n```", "id": "3203393"}]}