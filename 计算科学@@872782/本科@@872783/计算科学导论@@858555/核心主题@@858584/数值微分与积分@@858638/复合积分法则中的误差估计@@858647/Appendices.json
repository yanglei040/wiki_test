{"hands_on_practices": [{"introduction": "理论误差界是理解数值方法收敛性的基石，但其形式并非唯一。一个关键问题是，我们如何量化被积函数的光滑性——是采用其导数的最大值，还是某种平均值？本练习 [@problem_id:3125390] 将引导你推导复合辛普森法则的两种不同误差界：一种基于四阶导数的上确界（$L^\\infty$ 范数），另一种基于其均方根值（$L^2$ 范数）。通过对一个具体函数进行比较，你将深入理解不同误差界如何捕捉函数的不同特性，并认识到在特定情况下哪种界更为紧致。", "problem": "设 $Q_{S,m}(f)$ 表示在区间 $[0,1]$ 上对函数 $f$ 应用复合辛普森求积，使用 $m$ 个等长子区间，其中 $m$ 是一个正偶数，网格宽度为 $h = 1/m$。考虑求积误差泛函 $E_m(f) = \\int_{0}^{1} f(x)\\,dx - Q_{S,m}(f)$。你的任务是：\n\n- 使用带积分余项的泰勒定理以及辛普森法则对所有次数不超过3的多项式都精确这一事实，推导一个形式为 $|E_m(f)| \\leq C_{\\infty}\\, h^{4} \\, \\sup_{x \\in [0,1]} |f^{(4)}(x)|$ 的全局误差界，其中 $C_{\\infty} > 0$ 是一个不依赖于 $f$ 或 $m$ 的显式常数。\n\n- 使用4阶求积法则的皮亚诺核定理和柯西-施瓦茨不等式，推导一个形式为 $|E_m(f)| \\leq C_{2}\\, h^{4}\\, \\|f^{(4)}\\|_{L^{2}(0,1)}$ 的基于平均值的全局误差界，其中 $\\|g\\|_{L^{2}(0,1)} = \\left(\\int_{0}^{1} |g(x)|^{2}\\,dx\\right)^{1/2}$ 表示在 $[0,1]$ 上的勒贝格平方可积空间 ($L^{2}$) 范数。确定不依赖于 $f$ 或 $m$ 的显式常数 $C_{2} > 0$。\n\n- 将这两个界应用于函数 $f(x) = \\sin(10x)$ 在区间 $[0,1]$ 上的情况。计算两个界中乘以 $h^{4}$ 的显式常数，并构造比率 $R$，其定义为\n$R = \\dfrac{\\text{（基于 $L^{2}$ 平均值的误差界）}}{\\text{（基于上确界的误差界）}}$。\n以基本常数和函数的形式，给出 $R$ 的单个简化解析表达式。通过将 $R$ 与 $1$ 进行比较，判断对于此函数 $f$ 哪个界更紧。你最终报告的量必须是 $R$ 的表达式。不需要进行数值舍入。角度以弧度表示。", "solution": "用户提供的问题是数值分析中关于复合求积法则误差界的标准练习。它有科学依据、适定、客观，并包含所有必要的信息。该问题是有效的。\n\n该问题要求推导和比较复合辛普森法则的两种误差界。我们依次处理每个部分。\n\n**第一部分：基于上确界（$L^{\\infty}$）的误差界**\n\n复合辛普森法则 $Q_{S,m}(f)$ 通过将区间 $[0,1]$ 分成 $m$ 个宽度为 $h=1/m$ 的等长子区间来近似定积分 $\\int_{0}^{1} f(x)\\,dx$。由于辛普森法则是应用于成对的子区间，因此 $m$ 是一个偶数。设 $m=2n$。我们在 $n$ 个区间 $[x_{2i}, x_{2i+2}]$（其中 $i=0, 1, \\dots, n-1$，$x_j = jh$）上应用基本辛普森法则。每个这样的区间的宽度是 $2h$。\n\n复合法则的误差是每个区间 $[x_{2i}, x_{2i+2}]$ 上局部误差的总和：\n$$E_m(f) = \\int_{0}^{1} f(x)\\,dx - Q_{S,m}(f) = \\sum_{i=0}^{n-1} \\left( \\int_{x_{2i}}^{x_{2i+2}} f(x)\\,dx - \\frac{h}{3}[f(x_{2i}) + 4f(x_{2i+1}) + f(x_{2i+2})] \\right)$$\n在区间 $[a, b]$ 上，基本辛普森法则的误差由 $E_{[a,b]}(f) = -\\frac{(b-a)^5}{2880} f^{(4)}(\\eta)$ 给出，其中 $\\eta \\in (a, b)$，前提是 $f \\in C^4([a,b])$。该公式是利用该法则对次数不超过3的多项式精确这一事实推导出来的。对于我们的一个子区间 $[x_{2i}, x_{2i+2}]$，长度为 $b-a = 2h$。因此，局部误差为：\n$$E_i(f) = -\\frac{(2h)^5}{2880} f^{(4)}(\\eta_i) = -\\frac{32h^5}{2880} f^{(4)}(\\eta_i) = -\\frac{h^5}{90} f^{(4)}(\\eta_i)$$\n其中 $\\eta_i \\in (x_{2i}, x_{2i+2})$。\n\n总误差是这 $n = m/2$ 个局部误差之和：\n$$E_m(f) = \\sum_{i=0}^{n-1} \\left(-\\frac{h^5}{90} f^{(4)}(\\eta_i)\\right) = -\\frac{h^5}{90} \\sum_{i=0}^{m/2-1} f^{(4)}(\\eta_i)$$\n取绝对值，我们得到：\n$$|E_m(f)| = \\left| -\\frac{h^5}{90} \\sum_{i=0}^{m/2-1} f^{(4)}(\\eta_i) \\right| \\leq \\frac{h^5}{90} \\sum_{i=0}^{m/2-1} |f^{(4)}(\\eta_i)|$$\n通过用 $|f^{(4)}(x)|$ 在整个区间 $[0,1]$ 上的上确界来界定每个 $|f^{(4)}(\\eta_i)|$，我们有：\n$$|E_m(f)| \\leq \\frac{h^5}{90} \\sum_{i=0}^{m/2-1} \\sup_{x \\in [0,1]} |f^{(4)}(x)|$$\n该和式有 $n = m/2$ 个相同的项：\n$$|E_m(f)| \\leq \\frac{m}{2} \\frac{h^5}{90} \\sup_{x \\in [0,1]} |f^{(4)}(x)|$$\n代入 $m = 1/h$：\n$$|E_m(f)| \\leq \\frac{1}{2h} \\frac{h^5}{90} \\sup_{x \\in [0,1]} |f^{(4)}(x)| = \\frac{h^4}{180} \\sup_{x \\in [0,1]} |f^{(4)}(x)|$$\n这就是所求的误差界。常数为 $C_{\\infty} = \\frac{1}{180}$。\n\n**第二部分：基于平均值（$L^{2}$）的误差界**\n\n对于一个4阶的求积法则（对3次多项式精确），皮亚诺核定理指出误差泛函 $E_m(f)$ 可以表示为：\n$$E_m(f) = \\int_{0}^{1} K_m(t) f^{(4)}(t)\\,dt$$\n其中 $K_m(t) = E_{m,x}\\left[\\frac{(x-t)_+^3}{3!}\\right]$ 是复合法则的皮亚诺核。根据柯西-施瓦茨不等式：\n$$|E_m(f)| \\leq \\left( \\int_{0}^{1} |K_m(t)|^2\\,dt \\right)^{1/2} \\left( \\int_{0}^{1} |f^{(4)}(t)|^2\\,dt \\right)^{1/2} = \\|K_m\\|_{L^2(0,1)} \\|f^{(4)}\\|_{L^2(0,1)}$$\n复合核 $K_m(t)$ 是 $n=m/2$ 个平移后的局部核的并列。其平方的积分是局部核平方积分的总和：\n$$\\|K_m\\|_{L^2(0,1)}^2 = \\int_{0}^{1} |K_m(t)|^2\\,dt = \\sum_{i=0}^{n-1} \\int_{x_{2i}}^{x_{2i+2}} |K_i(t)|^2\\,dt$$\n其中 $K_i(t)$ 是在 $[x_{2i}, x_{2i+2}]$ 上的局部核。根据平移不变性，这可以简化为：\n$$\\|K_m\\|_{L^2(0,1)}^2 = n \\int_{-h}^{h} |K_{loc}(t)|^2\\,dt$$\n其中 $K_{loc}(t)$ 是基本辛普森法则在 $[-h, h]$ 上的皮亚诺核。对于 $t \\in [0,h]$，该核为 $K_{loc}(t) = -\\frac{(h-t)^3(h+3t)}{72}$。由于 $K_{loc}(t)$ 是一个偶函数，我们有：\n$$\\int_{-h}^{h} |K_{loc}(t)|^2\\,dt = 2 \\int_{0}^{h} \\left(-\\frac{(h-t)^3(h+3t)}{72}\\right)^2\\,dt = \\frac{2}{72^2} \\int_{0}^{h} (h-t)^6 (h+3t)^2\\,dt$$\n令 $u = h-t$，则 $t = h-u$ 且 $dt = -du$。积分变为：\n$$\\int_{h}^{0} u^6 (h+3(h-u))^2 (-du) = \\int_{0}^{h} u^6 (4h-3u)^2\\,du = \\int_{0}^{h} (16h^2u^6 - 24hu^7 + 9u^8)\\,du$$\n$$= \\left[ \\frac{16h^2u^7}{7} - \\frac{24hu^8}{8} + \\frac{9u^9}{9} \\right]_0^h = \\frac{16}{7}h^9 - 3h^9 + h^9 = \\left(\\frac{16}{7}-2\\right)h^9 = \\frac{2}{7}h^9$$\n因此，$\\int_{-h}^{h} |K_{loc}(t)|^2\\,dt = \\frac{2}{72^2} \\cdot \\frac{2}{7}h^9 = \\frac{4}{5184 \\cdot 7}h^9 = \\frac{1}{9072}h^9$。\n现在我们计算复合核的 $L^2$ 范数的平方，使用 $n=m/2=1/(2h)$：\n$$\\|K_m\\|_{L^2(0,1)}^2 = n \\frac{h^9}{9072} = \\frac{1}{2h} \\frac{h^9}{9072} = \\frac{h^8}{18144}$$\n取平方根：\n$$\\|K_m\\|_{L^2(0,1)} = \\sqrt{\\frac{h^8}{18144}} = \\frac{h^4}{\\sqrt{18144}} = \\frac{h^4}{\\sqrt{36^2 \\cdot 14}} = \\frac{h^4}{36\\sqrt{14}}$$\n误差界为 $|E_m(f)| \\leq \\frac{h^4}{36\\sqrt{14}} \\|f^{(4)}\\|_{L^2(0,1)}$。常数为 $C_2 = \\frac{1}{36\\sqrt{14}}$。\n\n**第三部分：特例化与比率计算**\n\n设 $f(x) = \\sin(10x)$。我们需要它的四阶导数：\n$f'(x) = 10\\cos(10x)$, $f''(x) = -100\\sin(10x)$, $f'''(x) = -1000\\cos(10x)$, $f^{(4)}(x) = 10000\\sin(10x) = 10^4\\sin(10x)$。\n\n基于上确界的界需要 $\\sup_{x \\in [0,1]} |f^{(4)}(x)|$。\n$$\\sup_{x \\in [0,1]} |10^4\\sin(10x)| = 10^4 \\sup_{x \\in [0,1]} |\\sin(10x)|$$\n自变量 $10x$ 的范围是从 $0$ 到 $10$ 弧度。由于 $10 > \\pi/2$，上确界为 $1$。\n$$\\sup_{x \\in [0,1]} |f^{(4)}(x)| = 10^4$$\n基于上确界的误差界为 $|E_m(f)| \\leq \\frac{1}{180} h^4 \\cdot 10^4 = \\frac{500}{9} h^4$。\n\n基于平均值的界需要 $\\|f^{(4)}\\|_{L^2(0,1)}$。\n$$\\|f^{(4)}\\|_{L^2(0,1)}^2 = \\int_{0}^{1} (10^4\\sin(10x))^2\\,dx = 10^8 \\int_{0}^{1} \\sin^2(10x)\\,dx$$\n使用 $\\sin^2(\\theta) = \\frac{1-\\cos(2\\theta)}{2}$：\n$$\\int_{0}^{1} \\sin^2(10x)\\,dx = \\int_{0}^{1} \\frac{1-\\cos(20x)}{2}\\,dx = \\frac{1}{2}\\left[x - \\frac{\\sin(20x)}{20}\\right]_0^1 = \\frac{1}{2} - \\frac{\\sin(20)}{40}$$\n所以，$\\|f^{(4)}\\|_{L^2(0,1)} = \\sqrt{10^8 \\left(\\frac{1}{2} - \\frac{\\sin(20)}{40}\\right)} = 10^4 \\sqrt{\\frac{1}{2} - \\frac{\\sin(20)}{40}}$。\n基于平均值的误差界为 $|E_m(f)| \\leq \\frac{h^4}{36\\sqrt{14}} \\cdot 10^4 \\sqrt{\\frac{1}{2} - \\frac{\\sin(20)}{40}}$。\n\n比率 $R$ 定义为基于平均值的界除以基于上确界的界：\n$$R = \\frac{\\left( \\frac{h^4}{36\\sqrt{14}} \\cdot 10^4 \\sqrt{\\frac{1}{2} - \\frac{\\sin(20)}{40}} \\right)}{\\left( \\frac{1}{180} h^4 \\cdot 10^4 \\right)}$$\n项 $h^4$ 和 $10^4$ 被消去：\n$$R = \\frac{180}{36\\sqrt{14}} \\sqrt{\\frac{1}{2} - \\frac{\\sin(20)}{40}} = \\frac{5}{\\sqrt{14}} \\sqrt{\\frac{20 - \\sin(20)}{40}}$$\n$$R = \\frac{5}{\\sqrt{14}\\sqrt{40}} \\sqrt{20 - \\sin(20)} = \\frac{5}{\\sqrt{560}} \\sqrt{20 - \\sin(20)}$$\n由于 $\\sqrt{560} = \\sqrt{16 \\cdot 35} = 4\\sqrt{35}$，我们有：\n$$R = \\frac{5}{4\\sqrt{35}} \\sqrt{20 - \\sin(20)}$$\n为了确定哪个界更紧，我们将 $R$ 与 $1$ 进行比较。\n$$R^2 = \\frac{25}{16 \\cdot 35} (20 - \\sin(20)) = \\frac{5}{112} (20 - \\sin(20))$$\n由于 $|\\sin(20)| \\leq 1$，我们有 $19 \\leq 20 - \\sin(20) \\leq 21$。\n$R^2 \\le \\frac{5}{112}(21) = \\frac{105}{112}  1$。\n由于 $R > 0$，我们有 $R  1$。这意味着对于函数 $f(x) = \\sin(10x)$，基于平均值（$L^2$）的界更紧。", "answer": "$$\\boxed{\\frac{5}{4\\sqrt{35}}\\sqrt{20 - \\sin(20)}}$$", "id": "3125390"}, {"introduction": "在实际应用中，我们通常无法得知被积函数的高阶导数，因此无法直接使用理论误差界。更实用的方法是“后验”误差估计，即通过比较不同精度下的数值结果来估计当前计算的误差。然而，并非所有估计方法都同样可靠。本练习 [@problem_id:3125467] 通过一个精心设计的例子，揭示了一种直观的嵌入式误差估计方法（比较同一网格上的梯形法则和辛普森法则）可能完全失效的情形，而基于理查森外推的 principled 方法却能给出精确的误差估计。这个练习对于培养正确使用和评判数值误差估计器的能力至关重要。", "problem": "考虑光滑函数 $f(x)$ 在 $[0,1]$ 上的定积分，以及在均匀网格上使用复合求积法则。您将比较两种估计复合辛普森法则误差的方法：(i) 基于步长为 $h$ 和 $h/2$ 的复合辛普森计算结果得到的两步估计，以及 (ii) 通过计算在同一网格上计算的嵌套法则（这里指复合辛普森法则和复合梯形法则）的差值形成的嵌入式估计。考虑一个特定的四次多项式\n$$\nf(x) \\;=\\; \\frac{16}{3}\\left(\\left(x-\\frac{1}{2}\\right)^{2} - \\frac{1}{16}\\right)\\left(-8\\left(x-\\frac{1}{2}\\right)^{2} + 3\\right),\n$$\n该函数关于 $x=\\frac{1}{2}$ 对称，满足 $f(0)=1$、$f\\!\\left(\\frac{1}{4}\\right)=0$、$f\\!\\left(\\frac{1}{2}\\right)=-1$、$f\\!\\left(\\frac{3}{4}\\right)=0$ 和 $f(1)=1$，并且在 $[0,1]$ 上不恒为零。\n\n设 $h=\\frac{1}{4}$（即有 $N=4$ 个子区间）和 $h/2=\\frac{1}{8}$（即有 $N=8$ 个子区间）。用 $S(h)$ 和 $S(h/2)$ 表示相应的复合辛普森近似值，用 $T(h)$ 和 $T(h/2)$ 表示相应的复合梯形近似值。令 $I=\\int_{0}^{1}f(x)\\,dx$ 表示精确积分值。\n\n您应当使用定义复合梯形法则（端点权重为 $1$，内部节点权重为 $2$，整体乘以 $\\frac{h}{2}$）和复合辛普森法则（内部奇数和偶数节点权重交替为 $4$ 和 $2$，端点权重为 $1$，整体乘以 $\\frac{h}{3}$）的基本原理，以及对于足够光滑的函数 $f$，复合辛普森法则的主阶全局误差与 $h^4$ 成比例这一事实。\n\n对于此函数 $f$ 和这些网格，以下哪个陈述是正确的？\n\nA. 在粗网格 $h=\\frac{1}{4}$ 上，嵌入式差值 $\\lvert S(h)-T(h)\\rvert$ 等于 $0$，这会错误地表明误差可以忽略不计，而基于 $h$ 和 $h/2$ 的两步估计完全等于真实误差 $\\lvert I-S(h/2)\\rvert=\\frac{1}{720}$。\n\nB. 在细化网格 $h/2=\\frac{1}{8}$ 上，嵌入式差值 $\\lvert S(h/2)-T(h/2)\\rvert$ 等于真实误差 $\\lvert I-S(h/2)\\rvert$，且两步估计为 $0$。\n\nC. 嵌入式差值和两步估计都为 $0$，因为复合辛普森法则对于均匀网格上的四次多项式是精确的。\n\nD. 两步估计等于 $\\frac{1}{192}$，而粗网格上的嵌入式差值等于 $\\frac{1}{720}$，因此在这种情况下嵌入式估计更可靠。", "solution": "问题陈述是数值分析中的一个有效练习。它内容完备，有明确定义的函数、积分区间、数值方法和网格参数。所述函数的性质在数学上与其定义一致，且问题提法恰当。我们可以开始求解。\n\n主要任务是计算积分 $I = \\int_{0}^{1} f(x) \\, dx$ 的几个数值近似值，并比较不同的误差估计。函数由下式给出\n$$f(x) = -\\frac{128}{3}\\left(x-\\frac{1}{2}\\right)^4 + \\frac{56}{3}\\left(x-\\frac{1}{2}\\right)^2 - 1$$\n这是一个四次多项式。它是一个关于点 $x=\\frac{1}{2}$ 的偶函数。问题指定了 $[0,1]$ 上的两个均匀网格：步长为 $h=\\frac{1}{4}$ 的粗网格（$N=4$ 个子区间）和步长为 $h/2=\\frac{1}{8}$ 的细化网格（$N=8$ 个子区间）。\n\n首先，我们在必要的网格点上计算函数 $f(x)$ 的值。\n粗网格点为 $\\{0, \\frac{1}{4}, \\frac{1}{2}, \\frac{3}{4}, 1\\}$。根据问题陈述，我们有：\n$f(0) = 1$\n$f(\\frac{1}{4}) = 0$\n$f(\\frac{1}{2}) = -1$\n$f(\\frac{3}{4}) = 0$\n$f(1) = 1$\n\n细网格点为 $\\{0, \\frac{1}{8}, \\frac{1}{4}, \\frac{3}{8}, \\frac{1}{2}, \\frac{5}{8}, \\frac{3}{4}, \\frac{7}{8}, 1\\}$。我们需要计算新点上的函数值：$\\frac{1}{8}, \\frac{3}{8}, \\frac{5}{8}, \\frac{7}{8}$。\n对于 $x=\\frac{1}{8}$，$x-\\frac{1}{2} = -\\frac{3}{8}$。\n$f(\\frac{1}{8}) = -\\frac{128}{3}(-\\frac{3}{8})^4 + \\frac{56}{3}(-\\frac{3}{8})^2 - 1 = -\\frac{128}{3}\\frac{81}{4096} + \\frac{56}{3}\\frac{9}{64} - 1 = -\\frac{27}{32} + \\frac{63}{24} - 1 = \\frac{-27+84-32}{32} = \\frac{25}{32}$。\n对于 $x=\\frac{3}{8}$，$x-\\frac{1}{2} = -\\frac{1}{8}$。\n$f(\\frac{3}{8}) = -\\frac{128}{3}(-\\frac{1}{8})^4 + \\frac{56}{3}(-\\frac{1}{8})^2 - 1 = -\\frac{128}{3}\\frac{1}{4096} + \\frac{56}{3}\\frac{1}{64} - 1 = -\\frac{1}{96} + \\frac{7}{24} - 1 = \\frac{-1+28-96}{96} = -\\frac{69}{96} = -\\frac{23}{32}$。\n根据对称性，$f(\\frac{7}{8}) = f(\\frac{1}{8}) = \\frac{25}{32}$ 且 $f(\\frac{5}{8}) = f(\\frac{3}{8}) = -\\frac{23}{32}$。\n\n接下来，我们计算积分的近似值。\n**复合梯形法则：** $T_N = h \\left( \\frac{f(x_0)+f(x_N)}{2} + \\sum_{i=1}^{N-1} f(x_i) \\right)$。\n对于 $h=\\frac{1}{4}$ ($N=4$)：\n$$T(h) = T(1/4) = \\frac{1}{4} \\left( \\frac{f(0)+f(1)}{2} + f(1/4)+f(1/2)+f(3/4) \\right) = \\frac{1}{4} \\left( \\frac{1+1}{2} + 0 - 1 + 0 \\right) = 0$$\n对于 $h/2=\\frac{1}{8}$ ($N=8$)：\n$$T(h/2) = T(1/8) = \\frac{1}{8} \\left( \\frac{f(0)+f(1)}{2} + \\sum_{i=1}^{7} f(x_i) \\right)$$\n总和为 $f(\\frac{1}{8}) + f(\\frac{1}{4}) + f(\\frac{3}{8}) + f(\\frac{1}{2}) + f(\\frac{5}{8}) + f(\\frac{3}{4}) + f(\\frac{7}{8}) = \\frac{25}{32} + 0 - \\frac{23}{32} - 1 - \\frac{23}{32} + 0 + \\frac{25}{32} = \\frac{4}{32} - 1 = -\\frac{7}{8}$。\n$$T(1/8) = \\frac{1}{8} \\left( 1 - \\frac{7}{8} \\right) = \\frac{1}{8} \\cdot \\frac{1}{8} = \\frac{1}{64}$$\n\n**复合辛普森法则：** $S_N = \\frac{h}{3} \\left( f(x_0) + 4\\sum_{i=1}^{N/2} f(x_{2i-1}) + 2\\sum_{i=1}^{N/2-1} f(x_{2i}) + f(x_N) \\right)$。\n对于 $h=\\frac{1}{4}$ ($N=4$)：\n$$S(h) = S(1/4) = \\frac{1/4}{3} \\left( f(0) + 4f(1/4) + 2f(1/2) + 4f(3/4) + f(1) \\right) = \\frac{1}{12} \\left( 1 + 4(0) + 2(-1) + 4(0) + 1 \\right) = 0$$\n对于 $h/2=\\frac{1}{8}$ ($N=8$)：\n$$S(h/2) = S(1/8) = \\frac{1/8}{3} \\left( f(0) + 4(f_{1/8}+f_{3/8}+f_{5/8}+f_{7/8}) + 2(f_{1/4}+f_{1/2}+f_{3/4}) + f(1) \\right)$$\n奇数索引内部点上的和为 $2(f(\\frac{1}{8})+f(\\frac{3}{8})) = 2(\\frac{25}{32}-\\frac{23}{32}) = 2(\\frac{2}{32}) = \\frac{1}{8}$。\n偶数索引内部点上的和为 $0 - 1 + 0 = -1$。\n$$S(1/8) = \\frac{1}{24} \\left( 1 + 4(\\frac{1}{8}) + 2(-1) + 1 \\right) = \\frac{1}{24} \\left( 1 + \\frac{1}{2} - 2 + 1 \\right) = \\frac{1}{24} \\cdot \\frac{1}{2} = \\frac{1}{48}$$\n\n现在我们计算精确积分 $I$。令 $u = x-\\frac{1}{2}$，则 $dx = du$。\n$$I = \\int_{-1/2}^{1/2} \\left( -\\frac{128}{3}u^4 + \\frac{56}{3}u^2 - 1 \\right) du = 2 \\int_{0}^{1/2} \\left( -\\frac{128}{3}u^4 + \\frac{56}{3}u^2 - 1 \\right) du$$\n$$I = 2 \\left[ -\\frac{128}{15}u^5 + \\frac{56}{9}u^3 - u \\right]_0^{1/2} = 2 \\left( -\\frac{128}{15}(\\frac{1}{32}) + \\frac{56}{9}(\\frac{1}{8}) - \\frac{1}{2} \\right)$$\n$$I = 2 \\left( -\\frac{4}{15} + \\frac{7}{9} - \\frac{1}{2} \\right) = 2 \\left( \\frac{-24+70-45}{90} \\right) = 2 \\left( \\frac{1}{90} \\right) = \\frac{1}{45}$$\n\n我们现在评估误差估计和真实误差。\n**$S(h/2)$ 的真实误差：**\n$$\\lvert I - S(h/2)\\rvert = \\left\\lvert \\frac{1}{45} - \\frac{1}{48} \\right\\rvert = \\left\\lvert \\frac{16 - 15}{720} \\right\\rvert = \\frac{1}{720}$$\n**两步估计：** 对于辛普森法则，这是一个 $p=4$ 阶的方法，其细化结果 $S(h/2)$ 的误差估计由理查森外推给出：\n$$E_{2S} = \\frac{S(h/2) - S(h)}{2^p - 1} = \\frac{S(1/8) - S(1/4)}{2^4 - 1} = \\frac{1/48 - 0}{15} = \\frac{1}{48 \\times 15} = \\frac{1}{720}$$\n该估计基于误差形式为 $E(h) \\approx C h^4$ 的假设。对于一个四次多项式，$f^{(4)}(x)$ 是一个常数，复合辛普森法则的误差公式 $E_S(h) = -\\frac{b-a}{180} h^4 f^{(4)}(\\xi)$ 变为精确的：$E_S(h) = C h^4$。这就是为什么两步估计完全等于真实误差的原因。\n\n**嵌入式差值估计：**\n在粗网格上 ($h=\\frac{1}{4}$)：\n$$\\lvert S(h) - T(h) \\rvert = \\lvert S(1/4) - T(1/4) \\rvert = \\lvert 0 - 0 \\rvert = 0$$\n在细化网格上 ($h/2=\\frac{1}{8}$)：\n$$\\lvert S(h/2) - T(h/2) \\rvert = \\lvert S(1/8) - T(1/8) \\rvert = \\left\\lvert \\frac{1}{48} - \\frac{1}{64} \\right\\rvert = \\left\\lvert \\frac{4 - 3}{192} \\right\\rvert = \\frac{1}{192}$$\n\n我们现在可以评估每个陈述。\n\n**A. 在粗网格 $h=\\frac{1}{4}$ 上，嵌入式差值 $\\lvert S(h)-T(h)\\rvert$ 等于 $0$，这会错误地表明误差可以忽略不计，而基于 $h$ 和 $h/2$ 的两步估计完全等于真实误差 $\\lvert I-S(h/2)\\rvert=\\frac{1}{720}$。**\n- 粗网格嵌入式差值 $\\lvert S(1/4)-T(1/4)\\rvert$ 确实为 $0$。\n- 这个 $0$ 的估计值对于 $S(1/4)$ 的真实误差 $\\lvert I-S(1/4) \\rvert = \\lvert \\frac{1}{45} - 0 \\rvert = \\frac{1}{45}$ 来说是一个很差的指标。因此它“错误地表明误差可以忽略不计”。\n- 两步估计为 $\\frac{1}{720}$。\n- 真实误差 $\\lvert I-S(h/2)\\rvert$ 为 $\\frac{1}{720}$。\n- 两步估计完全等于真实误差。\n该陈述的每个部分都是正确的。\n\n**B. 在细化网格 $h/2=\\frac{1}{8}$ 上，嵌入式差值 $\\lvert S(h/2)-T(h/2)\\rvert$ 等于真实误差 $\\lvert I-S(h/2)\\rvert$，且两步估计为 $0$。**\n- 细化网格上的嵌入式差值为 $\\frac{1}{192}$。真实误差为 $\\frac{1}{720}$。两者不相等。第一个分句是错误的。\n- 两步估计为 $\\frac{1}{720}$，而不是 $0$。第二个分句是错误的。\n该陈述是**不正确**的。\n\n**C. 嵌入式差值和两步估计都为 $0$，因为复合辛普森法则对于均匀网格上的四次多项式是精确的。**\n- 粗网格的嵌入式差值为 $0$，但细化网格的嵌入式差值为 $\\frac{1}{192}$，两步估计为 $\\frac{1}{720}$。声称“两者...都为 $0$”是错误的。\n- 其理由“因为复合辛普森法则对于四次多项式是精确的”是错误的。复合辛普森法则对于次数最多为 $3$ 的多项式是精确的，因为其误差项取决于四阶导数，该导数对于三次多项式为零，但对于四次多项式不为零。\n该陈述是**不正确**的。\n\n**D. 两步估计等于 $\\frac{1}{192}$，而粗网格上的嵌入式差值等于 $\\frac{1}{720}$，因此在这种情况下嵌入式估计更可靠。**\n- 两步估计为 $\\frac{1}{720}$，而不是 $\\frac{1}{192}$。\n- 粗网格的嵌入式差值为 $0$，而不是 $\\frac{1}{720}$。\n陈述中的数值是错误的。\n该陈述是**不正确**的。\n\n根据分析，只有陈述 A 是正确的。", "answer": "$$\\boxed{A}$$", "id": "3125467"}, {"introduction": "误差估计的最终目的是控制误差，而不仅仅是评估误差。自适应算法正是这一思想的集中体现，它利用局部误差估计来自动加密计算网格，仅在函数行为复杂的区域增加计算量，从而以最高效率达到预设的精度目标。在这个综合性练习 [@problem_id:3125400] 中，你将从零开始构建一个完整的自适应求积程序。你将运用局部误差估计的原理来驱动网格的递归细分，并实现一个先进的混合误差容忍度准则，最终构建出一个模拟专业数值计算库核心逻辑的强大工具。", "problem": "您需要设计并实现一个完整、可运行的程序，该程序构建一个用于一维定积分的自适应复合求积法则。目标是控制一个混合误差目标，该目标结合了绝对误差容限和相对误差容限，其中相对误差是相对于被积函数绝对值的积分来定义的。具体来说，您必须估计函数 $f$ 的积分，并同时估计其绝对值 $\\lvert f \\rvert$ 的积分，这样 $\\lvert f \\rvert$ 值较小的子区间就不会因为绝对容限而主导相对误差要求。\n\n从定积分 $\\int_a^b f(x)\\,dx$ 和通过将区间 $[a,b]$ 细分为多个子区间而形成的复合求积法则的基本定义出发，您必须构建一个自适应算法，该算法：\n- 基于从与泰勒展开和复合规则的渐近截断误差一致的原则性论证中导出的局部误差估计，递归地细分子区间。\n- 为每个子区间分配一个局部接受阈值，该阈值混合了绝对预算和相对预算，其中绝对预算与子区间在 $[a,b]$ 内的长度成比例分配，而子区间中的相对预算与该子区间对 $\\int \\lvert f \\rvert$ 的估计值成比例。此设计确保了 $\\lvert f \\rvert$ 较小的子区间不会因为相对误差约束而被强制过度细化，而是使用绝对预算。\n- 汇总所有被接受的子区间，以生成 $\\int_a^b f(x)\\,dx$ 的全局近似值和 $\\int_a^b \\lvert f(x) \\rvert\\,dx$ 的全局近似值。\n\n在给定绝对容限 $t_{\\mathrm{abs}}$ 和相对容限 $t_{\\mathrm{rel}}$ 的情况下，将全局接受准则定义为混合形式，要求 $\\int_a^b f(x)\\,dx$ 的绝对误差小于或等于 $t_{\\mathrm{abs}} + t_{\\mathrm{rel}} \\int_a^b \\lvert f(x) \\rvert\\,dx$。您必须根据独立计算的高精度参考值来验证结果。本问题中所有三角函数均使用弧度。\n\n您的程序必须实现：\n- 一个自适应复合规则，具有局部误差估计和局部接受阈值。该阈值包括一个与总长度 $(B-A)$ 内的子区间长度 $(b-a)$ 成正比的绝对预算项，以及一个与子区间对 $\\int \\lvert f \\rvert$ 的局部估计值成正比的相对预算项。\n- 在每个子区间中使用一致的求积模板，同时估计 $\\int f$ 和 $\\int \\lvert f \\rvert$，以便相对容限有意义地应用于积分的量值，而不仅仅是其有符号的值。\n\n测试套件：\n对于以下每个测试用例，使用您的自适应方法计算 $\\int_a^b f(x)\\,dx$ 的数值近似值 $I_{\\mathrm{num}}$，计算高精度参考值 $I_{\\mathrm{ref}}$ 和 $A_{\\mathrm{ref}} = \\int_a^b \\lvert f(x) \\rvert\\,dx$，然后输出一个布尔值，指示是否满足混合接受准则 $\\lvert I_{\\mathrm{ref}} - I_{\\mathrm{num}} \\rvert \\le t_{\\mathrm{abs}} + t_{\\mathrm{rel}} A_{\\mathrm{ref}}$。\n\n任何三角函数所需的角度单位均为弧度。\n\n使用以下测试用例，每个用例由 $(f, a, b, t_{\\mathrm{abs}}, t_{\\mathrm{rel}})$ 指定：\n\n- 情况 1：$f(x) = \\sin(x)$，$a=0$，$b=2\\pi$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n- 情况 2：$f(x) = \\sin(50 x)$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-9}$，$t_{\\mathrm{rel}} = 5\\cdot 10^{-4}$。\n- 情况 3：$f(x) = x - 0.5$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n- 情况 4：$f(x) = e^{-100 (x-0.5)^2} \\cos(10 x)$，$a=0$，$b=1$，$t_{\\mathrm{abs}} = 10^{-10}$，$t_{\\mathrm{rel}} = 10^{-6}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔列表形式的结果（例如，$[r_1,r_2,r_3,r_4]$），其中每个 $r_i$ 是对应测试用例的布尔值，指示是否满足混合准则。不应打印任何其他文本。", "solution": "数值逼近定积分 $I = \\int_a^b f(x)\\,dx$ 是计算科学中的一项基本任务。虽然像梯形法则或辛普森法则这样的简单复合规则对于在均匀网格上的良态函数是有效的，但对于在积分域上平滑度变化的函数，它们可能效率极低。自适应求积算法通过选择性地细化积分网格来解决这个问题，在函数复杂的区域投入更多的计算量，而在函数平滑的区域投入较少的计算量。\n\n自适应算法的核心是局部误差估计程序和相应的接受准则。我们将基于广为人知的辛普森求积法则和基于理查森外推法的误差估计来构建我们的方法。\n\n**1. 基本求积法则和误差估计**\n\n对于宽度为 $h = d-c$ 的单个子区间 $[c,d]$，辛普森法则提供了积分的估计值：\n$$ S(f, c, d) = \\frac{h}{6} \\left[ f(c) + 4f\\left(\\frac{c+d}{2}\\right) + f(d) \\right] $$\n根据泰勒级数分析，此规则的局部截断误差已知为 $E_S \\approx C h^5 f^{(4)}(\\xi)$，其中 $C$ 是某个常数，$\\xi \\in (c,d)$。误差的阶为 $O(h^5)$。\n\n为了在不知道 $f(x)$ 导数的情况下估计这个误差，我们比较了在 $[c,d]$ 上具有不同精度的两个积分近似值。\n令 $S_1$ 为在整个子区间 $[c,d]$ 上应用一次辛普森法则得到的粗略估计。\n令 $S_2$ 为将子区间细分为两半 $[c,m]$ 和 $[m,d]$（其中 $m=(c+d)/2$）并对它们各自的辛普森法则结果求和得到的精细估计：$S_2 = S(f, c, m) + S(f, m, d)$。\n\n粗略规则 $S_1$（步长为 $h$）的误差为 $E_1 \\approx C h^5 f^{(4)}(\\xi_1)$。\n精细规则 $S_2$ 的误差是两个步长为 $h/2$ 的子区间的误差之和，因此 $E_2 \\approx 2 \\times C (h/2)^5 f^{(4)}(\\xi_2) = \\frac{1}{16} C h^5 f^{(4)}(\\xi_2)$。\n假设 $f^{(4)}(x)$ 在该子区间上变化缓慢，我们有 $E_1 \\approx 16 E_2$。\n真实积分 $I$ 可以写成 $I = S_1 + E_1$ 和 $I = S_2 + E_2$。\n将这两者相减得到 $S_2 - S_1 = E_1 - E_2 \\approx 15 E_2$。\n因此，更精确估计 $S_2$ 的绝对误差可以估计为：\n$$ E_{S_2} \\approx \\frac{|S_2 - S_1|}{15} $$\n此外，我们可以通过应用理查森外推法获得一个更好的积分估计。这个改进的估计对应于布尔法则：\n$$ I_{\\text{panel}} \\approx S_2 + E_2 = S_2 + \\frac{S_2 - S_1}{15} $$\n这个更高阶的估计将用于被接受的子区间。\n\n**2. 混合误差准则和局部容限**\n\n标准的相对误差准则 $\\frac{|I_{\\text{num}}-I_{\\text{ref}}|}{|I_{\\text{ref}}|} \\le t_{\\text{rel}}$ 在真实积分 $I_{\\text{ref}}$ 接近零时会有问题。所提出的混合误差准则通过使用函数绝对值的积分作为相对容限的基础来避免此问题：\n$$ |I_{\\text{num}} - I_{\\text{ref}}| \\le t_{\\text{abs}} + t_{\\text{rel}} \\int_a^b |f(x)|\\,dx $$\n为实现这一全局误差目标，我们必须在局部子区间之间分配容限预算。对于总区间 $[A,B]$（宽度为 $W=B-A$）内宽度为 $h=d-c$ 的子区间 $[c,d]$，我们通过划分全局绝对和相对预算来定义一个局部容限 $\\tau$，具体规定如下：\n- 绝对容限预算 $t_{\\text{abs}}$ 与子区间宽度成比例分配：$t_{\\text{abs}} \\frac{h}{W}$。\n- 相对容限预算与子区间上积分的量值成比例。我们为此使用 $\\int_c^d |f(x)|\\,dx$ 的数值估计，称之为 $A_{\\text{panel}}$。其贡献为 $t_{\\text{rel}} A_{\\text{panel}}$。\n\n子区间的局部容限是这两部分之和：\n$$ \\tau_{\\text{panel}} = t_{\\text{abs}} \\frac{h}{W} + t_{\\text{rel}} A_{\\text{panel}} $$\n如果 $f(x)$ 积分的估计误差 $|S_{2,f} - S_{1,f}|/15$ 小于或等于此局部容限，则该子区间被接受。\n\n**3. 自适应算法**\n\n整个算法过程如下，使用一个栈来管理待细分的子区间，以避免深度递归。\n\n1.  将 $f$ 和 $|f|$ 的总积分估计值初始化为零：$I_{\\text{total}} = 0$, $A_{\\text{total}} = 0$。\n2.  将初始子区间 $(a, b)$ 推入一个栈中。\n3.  当栈不为空时：\n    a. 从栈中弹出一个子区间 $(c, d)$。\n    b. 在此子区间上同时计算 $f(x)$ 和 $|f(x)|$ 的粗略 ($S_1$) 和精细 ($S_2$) 积分估计。这需要计算函数在 $5$ 个点处的值。\n    c. 估计 $f$ 积分的误差：$E_f = |S_{2,f} - S_{1,f}|/15$。\n    d. 子区间上 $|f|$ 积分的估计值为 $A_{\\text{panel}} = S_{2,|f|} + (S_{2,|f|} - S_{1,|f|})/15$。由于 $|f(x)| \\ge 0$，我们确保 $A_{\\text{panel}} \\ge 0$。\n    e. 计算局部容限 $\\tau_{\\text{panel}} = t_{\\text{abs}} \\frac{d-c}{b-a} + t_{\\text{rel}} A_{\\text{panel}}$。\n    f. 如果 $E_f \\le \\tau_{\\text{panel}}$（或者如果子区间小于机器精度阈值），则接受该子区间。将其改进的积分估计 $I_{\\text{panel},f}$ 和 $A_{\\text{panel}}$ 分别加到总和 $I_{\\text{total}}$ 和 $A_{\\text{total}}$ 中。\n    g. 如果子区间未被接受，则在其中心点 $m=(c+d)/2$ 处进行细分，并将两个新的子区间 $(c, m)$ 和 $(m, d)$ 推入栈中以供进一步处理。\n4.  最终结果是累积的总和 $I_{\\text{total}}$。此过程将计算工作集中在函数的复杂区域，同时高效处理较平滑的区域，并始终遵循一个稳健的混合误差准则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import integrate\n\ndef adaptive_quadrature(f, a, b, t_abs, t_rel):\n    \"\"\"\n    Computes the definite integral of f from a to b using an adaptive\n    composite quadrature rule based on Simpson's method and a mixed\n    error tolerance.\n    \"\"\"\n    # A small number to prevent division by zero or infinite loops for tiny intervals.\n    MIN_INTERVAL_WIDTH = 1e-15\n\n    # Wrapper for the absolute value of the function\n    abs_f = lambda x: np.abs(f(x))\n\n    # Storing tuple of (c, d) for each panel to be processed\n    panel_stack = [(a, b)]\n\n    total_integral_f = 0.0\n    total_width = b - a\n\n    # Max iteration guard to prevent potential infinite loops on pathological functions\n    max_panels = 100000\n    panel_count = 0\n\n    while panel_stack and panel_count  max_panels:\n        panel_count += 1\n        c, d = panel_stack.pop()\n        h = d - c\n\n        # If panel is too small, accept it and its contribution is likely negligible anyway.\n        if h  MIN_INTERVAL_WIDTH:\n            # Use a simple rule for this tiny interval\n            m = c + h / 2.0\n            total_integral_f += (h / 6.0) * (f(c) + 4.0 * f(m) + f(d))\n            continue\n\n        # 5 points for Simpson's rule comparison (1 coarse, 2 fine)\n        x0, x1, x2, x3, x4 = c, c + h * 0.25, c + h * 0.5, c + h * 0.75, d\n\n        # Evaluations for f\n        f_vals = np.array([f(x0), f(x1), f(x2), f(x3), f(x4)])\n        # Evaluations for |f|\n        abs_f_vals = np.abs(f_vals)\n\n        # Coarse estimate (S1) for f over [c, d]\n        s1_f = (h / 6.0) * (f_vals[0] + 4.0 * f_vals[2] + f_vals[4])\n        # Fine estimate (S2) for f over [c, d]\n        s2_f = (h / 12.0) * (f_vals[0] + 4.0 * f_vals[1] + 2.0 * f_vals[2] + 4.0 * f_vals[3] + f_vals[4])\n\n        # Coarse estimate (S1) for |f|\n        s1_absf = (h / 6.0) * (abs_f_vals[0] + 4.0 * abs_f_vals[2] + abs_f_vals[4])\n        # Fine estimate (S2) for |f|\n        s2_absf = (h / 12.0) * (abs_f_vals[0] + 4.0 * abs_f_vals[1] + 2.0 * abs_f_vals[2] + 4.0 * abs_f_vals[3] + abs_f_vals[4])\n\n        # Error estimate for the integral of f\n        error_f = np.abs(s2_f - s1_f) / 15.0\n\n        # Boole's rule estimate for the integral of |f| on the panel\n        # Ensure it's non-negative as it's used for tolerance scaling.\n        integral_absf_panel = s2_absf + (s2_absf - s1_absf) / 15.0\n        integral_absf_panel = np.maximum(0, integral_absf_panel)\n\n        # Local tolerance for the panel\n        local_tolerance = t_abs * (h / total_width) + t_rel * integral_absf_panel\n        \n        # If error is acceptable, add improved estimate to total and continue\n        if error_f = local_tolerance:\n            # Boole's rule (Richardson extrapolation) gives a more accurate result\n            integral_f_panel = s2_f + (s2_f - s1_f) / 15.0\n            total_integral_f += integral_f_panel\n        else:\n            # Subdivide panel and push halves to stack\n            m = x2\n            panel_stack.append((c, m))\n            panel_stack.append((m, d))\n\n    return total_integral_f\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    test_cases = [\n        (lambda x: np.sin(x), 0, 2 * np.pi, 1e-10, 1e-6),\n        (lambda x: np.sin(50 * x), 0, 1, 1e-9, 5e-4),\n        (lambda x: x - 0.5, 0, 1, 1e-10, 1e-6),\n        (lambda x: np.exp(-100 * (x-0.5)**2) * np.cos(10 * x), 0, 1, 1e-10, 1e-6),\n    ]\n\n    results = []\n    for f, a, b, t_abs, t_rel in test_cases:\n        # Calculate numerical integral using our implemented method\n        I_num = adaptive_quadrature(f, a, b, t_abs, t_rel)\n\n        # Calculate high-accuracy reference values using scipy.integrate.quad\n        I_ref, _ = integrate.quad(f, a, b, epsabs=1e-14, epsrel=1e-14)\n        abs_f = lambda x: np.abs(f(x))\n        A_ref, _ = integrate.quad(abs_f, a, b, epsabs=1e-14, epsrel=1e-14)\n\n        # Check if the mixed error criterion is satisfied\n        actual_error = np.abs(I_ref - I_num)\n        allowed_error = t_abs + t_rel * A_ref\n        \n        results.append(actual_error = allowed_error)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, [r.lower() if isinstance(r, bool) else r for r in results]))}]\")\n\nsolve()\n```", "id": "3125400"}]}