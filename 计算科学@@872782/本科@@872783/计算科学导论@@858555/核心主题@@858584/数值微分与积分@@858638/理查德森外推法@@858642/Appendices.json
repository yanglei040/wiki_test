{"hands_on_practices": [{"introduction": "我们从一个基础的例子开始。这个练习将理查德森外推法应用于一个一阶数值方法，这是最简单的情形。通过解决这个问题 [@problem_id:2197905]，你将练习核心公式，并了解如何将两个精度较低的估计值合成为一个更精确的结果。", "problem": "一个航空航天工程师团队正在模拟一个新型空间探测器的大气层再入过程。他们对估算探测器所经历的最大减速度特别感兴趣，这是一个用于结构设计的关键参数。他们用于求解运动方程的数值算法具有一阶全局截断误差，这意味着估算值的误差为 $O(h)$ 阶，其中 $h$ 是模拟中使用的时间步长。\n\n设 $D(h)$ 为模拟使用时间步长 $h$ 运行时估算出的最大减速度。\n该团队进行了两次模拟：\n1.  使用时间步长 $h_1 = 0.4$ 秒，他们发现最大减速度为 $D(0.4) = 58.6$ m/s^2。\n2.  使用减小的时间步长 $h_2 = 0.2$ 秒，他们发现最大减速度为 $D(0.2) = 59.3$ m/s^2。\n\n为了在不进行另一次更小时间步长的冗长模拟的情况下获得更准确的结果，工程师们决定对这两个估算值应用理查德森外推法。计算改进后的最大减速度估算值。答案以 m/s^2 为单位，并四舍五入到三位有效数字。", "solution": "因为该数值方法具有一阶全局截断误差，所以估算量满足以下渐近误差模型\n$$\nD(h) = D^{\\ast} + C h + O(h^{2}),\n$$\n其中 $D^{\\ast}$ 是真实的最大减速度，而 $C$ 是一个与 $h$ 无关的常数。\n\n设 $h_{1} = 0.4$，$h_{2} = 0.2$，并定义加密比 $r = \\frac{h_{1}}{h_{2}} = 2$。那么\n$$\nD(h_{1}) = D^{\\ast} + C h_{1} + O(h_{1}^{2}), \\quad D(h_{2}) = D^{\\ast} + C \\frac{h_{1}}{r} + O\\!\\left(\\frac{h_{1}^{2}}{r^{2}}\\right).\n$$\n通过理查森外推法消去 $O(h)$ 项可得\n$$\nD_{\\text{RE}} = \\frac{r D(h_{2}) - D(h_{1})}{r - 1} = D(h_{2}) + \\frac{D(h_{2}) - D(h_{1})}{r - 1} = D^{\\ast} + O(h_{1}^{2}).\n$$\n代入 $r=2$，$D(0.4)=58.6$ 和 $D(0.2)=59.3$，\n$$\nD_{\\text{RE}} = \\frac{2 \\cdot 59.3 - 58.6}{2 - 1} = 118.6 - 58.6 = 60.0.\n$$\n四舍五入到三位有效数字，改进后的估算值为 $60.0$ m/s^2。", "answer": "$$\\boxed{60.0}$$", "id": "2197905"}, {"introduction": "理查森外推法不仅仅是一个固定的公式，更是一种通用的原理。这个问题 [@problem_id:2197931] 挑战你跳出标准的“步长减半”情景，为一个二阶方法和一个非标准的步长缩减比例推导外推公式。这将加深你对该技术核心——误差对消机制——的理解。", "problem": "一个数值模拟被用来估计一个物理量，其真实值用 $V$ 表示。模拟生成的近似值，记为 $A(h)$，依赖于一个离散化参数 $h  0$。已知该近似的误差遵循以下关系：\n$$A(h) = V + C h^{2} + O(h^{4})$$\n其中 $C$ 是一个不依赖于 $h$ 的常数，而 $O(h^{4})$ 代表对于小的 $h$ 可以忽略的高阶项。\n\n一位分析师进行了两次模拟。第一次模拟使用步长 $h$，得到结果 $A(h)$。第二次模拟使用更精细的步长 $h/3$，得到结果 $A(h/3)$。为了改进对 $V$ 的估计，该分析师希望组合这两个结果以消去 $h^{2}$ 阶的主误差项。\n\n请通过寻找 $A(h)$ 和 $A(h/3)$ 的特定线性组合来确定这个改进的 $V$ 估计值的公式，该线性组合能消除 $O(h^2)$ 误差项。", "solution": "我们已知渐近展开式\n$$A(h) = V + C h^{2} + O(h^{4}),$$\n并且，通过代入 $h \\mapsto h/3$ 并利用 $O\\!\\left((h/3)^{4}\\right)=O(h^{4})$，我们有\n$$A(h/3) = V + C \\left(\\frac{h}{3}\\right)^{2} + O(h^{4}) = V + \\frac{C}{9} h^{2} + O(h^{4}).$$\n寻求一个线性组合 $\\alpha A(h/3) + \\beta A(h)$，使得它能消除 $O(h^{2})$ 项，同时保持主项等于 $V$：\n$$\\alpha A(h/3) + \\beta A(h) = (\\alpha + \\beta) V + C h^{2} \\left(\\frac{\\alpha}{9} + \\beta\\right) + O(h^{4}).$$\n施加两个条件\n$$(i)\\ \\ \\alpha + \\beta = 1,\\qquad (ii)\\ \\ \\frac{\\alpha}{9} + \\beta = 0,$$\n以确保 $V$ 的系数为 $1$ 且 $h^{2}$ 项消失。求解，\n从 $(ii)$ 我们得到 $\\beta = -\\frac{\\alpha}{9}$；代入 $(i)$ 得到\n$$\\alpha - \\frac{\\alpha}{9} = 1 \\;\\Rightarrow\\; \\frac{8}{9}\\alpha = 1 \\;\\Rightarrow\\; \\alpha = \\frac{9}{8},\\quad \\beta = -\\frac{1}{8}.$$\n因此，消除了 $O(h^{2})$ 误差的改进估计值为\n$$\\frac{9}{8} A(h/3) - \\frac{1}{8} A(h) = \\frac{9 A(h/3) - A(h)}{8},$$\n其截断误差为 $O(h^{4})$。", "answer": "$$\\boxed{\\frac{9 A(h/3) - A(h)}{8}}$$", "id": "2197931"}, {"introduction": "现在，让我们在一个更真实的计算环境中应用理查森外推法。这个练习 [@problem_id:3226253] 将我们的技术与求解常微分方程的基本算法——欧拉法——相结合。通过编程实现，你将亲身体验外推法如何像一个“包装器”一样，用于提高其他数值求解器的精度。", "problem": "考虑一个常微分方程 (ODE) 的初值问题 (IVP)，其形式为 $y'(t) = f(t, y(t))$，初始条件为 $y(t_0) = y_0$。前向欧拉法源于导数作为有限差分极限的基本定义以及一阶泰勒展开的应用。实践中，前向欧拉法通过从 $t_0$ 开始，以步长 $h$ 推进求解，直至指定的最终时间 $T$，来更新精确解 $y(t_n)$ 的近似值 $y_n$，从而在 $T$ 时刻得到一个我们记为 $y_h(T)$ 的近似值。在对 $f$ 和 $y(t)$ 的标准正则性假设下，已知前向欧拉法的全局离散误差与步长 $h$呈线性关系。\n\n你的任务是：\n1. 实现一个函数，该函数使用前向欧拉法计算 $y_h(T)$，适用于任何给定的函数 $f(t,y)$、初始条件 $y_0$、初始时间 $t_0$、最终时间 $T$ 和均匀步长 $h$。假设 $T - t_0$ 是 $h$ 的整数倍。\n2. 假设欧拉法在 $T$ 处的近似值具有形式为 $y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$ 的渐近误差展开，其中常数 $C$ 和 $D$ 依赖于 $f$ 和解，但不依赖于 $h$。利用输出 $y_h(T)$ 和 $y_{h/2}(T)$，推导这两个近似值的一个线性组合（其常数权重与 $h$ 无关），该组合能消去首项 $\\mathcal{O}(h)$ 误差项，从而得到一个对 $y(T)$ 的 $\\mathcal{O}(h^2)$ 精度的估计。然后在代码中实现这个 Richardson 外推估计器。\n3. 对于下方的每个测试用例，计算绝对误差 $\\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$，其中 $y_{\\text{extrap}}(T)$ 是你的外推估计值，$y(T)$ 是在时间 $T$ 的精确解。\n\n使用以下测试套件。在所有情况下，取 $t_0 = 0$ 并使用所提供的 $h$，使得 $(T - t_0)/h$ 为整数：\n\n- 测试 1 (理想情况，线性齐次 ODE): $f(t,y) = y$, $y_0 = 1$, $T = 1$, $h = 0.2$。精确解为在 $t = T$ 处求值的 $y(t) = e^{t}$。\n- 测试 2 (线性非齐次 ODE): $f(t,y) = y + t$, $y_0 = 0$, $T = 2$, $h = 0.4$。精确解为在 $t = T$ 处求值的 $y(t) = e^{t} - t - 1$。\n- 测试 3 (非线性逻辑斯谛增长): $f(t,y) = r y \\left(1 - \\frac{y}{K}\\right)$，参数为 $r = 1$ 和 $K = 10$，$y_0 = 1$，$T = 3$，$h = 0.5$。精确解为在 $t=T$ 处求值的 $y(t) = \\frac{K}{1 + A e^{-r t}}$，其中 $A = \\frac{K - y_0}{y_0}$。\n- 测试 4 (边界情况，零导数): $f(t,y) = 0$, $y_0 = 3$, $T = 1$, $h = 0.5$。精确解为在 $t=T$ 处求值的常数函数 $y(t) = 3$。\n\n你的程序应：\n- 实现前向欧拉法，为每个测试用例计算 $y_h(T)$ 和 $y_{h/2}(T)$。\n- 使用两个近似值 $y_h(T)$ 和 $y_{h/2}(T)$ 实现推导出的 Richardson 外推估计器，以获得在 $T$ 处的 $\\mathcal{O}(h^2)$ 阶估计。\n- 计算并记录每个测试用例的绝对误差，四舍五入到十位小数。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如：\"[0.0123456789,0.0000001234,0.0012340000,0.0000000000]\"），列表中的条目是测试 1 到测试 4 的绝对误差，每个都四舍五入到十位小数。", "solution": "经评估，此问题有效。\n\n### 第 1 步：提取已知信息\n- **问题类型**：常微分方程 (ODE) 的初值问题 (IVP)。\n- **ODE 形式**：$y'(t) = f(t, y(t))$。\n- **初始条件**：$y(t_0) = y_0$。\n- **数值方法**：前向欧拉法，其中 $y_{n+1} = y_n + h f(t_n, y_n)$。\n- **在最终时间 $T$ 的近似值**：$y_h(T)$。\n- **渐近误差展开**：$y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$。\n- **约束条件**：$T - t_0$ 是步长 $h$ 的整数倍。\n- **任务 1**：实现一个用于前向欧拉法的函数，以计算 $y_h(T)$。\n- **任务 2**：推导并实现一个对 $y(T)$ 的 Richardson 外推估计器，该估计器具有 $\\mathcal{O}(h^2)$ 精度，使用 $y_h(T)$ 和 $y_{h/2}(T)$。\n- **任务 3**：为四个测试用例计算绝对误差 $\\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$。\n- **所有用例的初始时间**：$t_0 = 0$。\n\n- **测试用例 1**：\n  - $f(t,y) = y$\n  - $y_0 = 1$\n  - $T = 1$\n  - $h = 0.2$\n  - 精确解：$y(t) = e^{t}$\n\n- **测试用例 2**：\n  - $f(t,y) = y + t$\n  - $y_0 = 0$\n  - $T = 2$\n  - $h = 0.4$\n  - 精确解：$y(t) = e^{t} - t - 1$\n\n- **测试用例 3**：\n  - $f(t,y) = r y \\left(1 - \\frac{y}{K}\\right)$，其中 $r = 1, K = 10$\n  - $y_0 = 1$\n  - $T = 3$\n  - $h = 0.5$\n  - 精确解：$y(t) = \\frac{K}{1 + A e^{-r t}}$，其中 $A = \\frac{K - y_0}{y_0}$\n\n- **测试用例 4**：\n  - $f(t,y) = 0$\n  - $y_0 = 3$\n  - $T = 1$\n  - $h = 0.5$\n  - 精确解：$y(t) = 3$\n\n### 第 2 步：使用提取的已知信息进行验证\n该问题具有科学依据、是适定的且客观的。\n1.  **科学或事实的可靠性**：该问题建立在 ODE 数值分析的基本概念之上。前向欧拉法、其误差分析以及 Richardson 外推法都是标准且在数学上可靠的技术。所提供的 ODE 是教学和研究中使用的经典示例。该问题没有任何科学或事实错误。\n2.  **适定性**：该问题是适定的。对于每个测试用例，函数 $f(t,y)$ 足够光滑（在 $y$ 上是 Lipschitz 连续的），这保证了该 IVP 解的存在性和唯一性。任务定义清晰，并且所有必要的数据（初始条件、参数、时间区间）都已提供。\n3.  **客观性**：语言精确且无偏见。任务是定量的，需要进行具体的计算，没有主观解释的余地。\n4.  **完整性**：问题是自包含的。它指定了 ODE、初始条件、步长、最终时间以及用于误差比较的精确解。$(T - t_0)/h$ 是整数的约束简化了实现并避免了歧义。\n\n### 第 3 步：结论与行动\n问题是 **有效** 的。将提供一个完整的解决方案。\n\n### 基于原理的解决方案\n解决方案分三个阶段展开：首先，实现前向欧拉法；其次，推导 Richardson 外推公式；第三，将这些方法应用于指定的测试用例以计算所需的误差。\n\n**1. 前向欧拉法**\n前向欧拉法是求解形如 $y'(t) = f(t, y(t))$ 且 $y(t_0) = y_0$ 的初值问题的一阶数值方法。它在离散时间点 $t_n = t_0 + n h$（其中 $h$ 是步长）上逼近连续解 $y(t)$。该方法由 $y(t_{n+1})$ 在 $t_n$ 附近的一阶泰勒展开推导而来：\n$y(t_{n+1}) = y(t_n) + h y'(t_n) + \\mathcal{O}(h^2) = y(t_n) + h f(t_n, y(t_n)) + \\mathcal{O}(h^2)$。\n忽略 $\\mathcal{O}(h^2)$ 项，我们得到近似值 $y_n \\approx y(t_n)$ 的迭代公式：\n$$y_{n+1} = y_n + h f(t_n, y_n)$$\n从初始条件 $y_0$ 开始，我们可以对 $n = 0, 1, 2, \\dots, N-1$（其中 $N = (T-t_0)/h$）迭代应用此公式，以找到近似值 $y_N \\approx y(T)$。这就定义了函数 $y_h(T)$。\n\n**2. Richardson 外推法**\nRichardson 外推法是提高数值近似精度的一种通用技术。我们已知前向欧拉法的近似值 $y_h(T)$ 具有渐近误差展开：\n$$y_h(T) = y(T) + C h + D h^2 + \\mathcal{O}(h^3)$$\n此处，$y(T)$ 是精确解，而 $C$ 和 $D$ 是依赖于函数 $f$ 及其导数但不依赖于步长 $h$ 的常数。\n\n如果我们用减半的步长 $h/2$ 再次计算近似值，公式变为：\n$$y_{h/2}(T) = y(T) + C \\left(\\frac{h}{2}\\right) + D \\left(\\frac{h}{2}\\right)^2 + \\mathcal{O}(h^3)$$\n$$y_{h/2}(T) = y(T) + \\frac{1}{2} C h + \\frac{1}{4} D h^2 + \\mathcal{O}(h^3)$$\n我们的目标是找到 $y_h(T)$ 和 $y_{h/2}(T)$ 的一个线性组合，我们将其记为 $y_{\\text{extrap}}(T)$，它能提供一个对 $y(T)$ 的更精确的估计。设 $y_{\\text{extrap}}(T) = \\alpha y_h(T) + \\beta y_{h/2}(T)$。代入误差展开式：\n$$y_{\\text{extrap}}(T) = \\alpha \\left(y(T) + C h + D h^2\\right) + \\beta \\left(y(T) + \\frac{1}{2} C h + \\frac{1}{4} D h^2\\right) + \\mathcal{O}(h^3)$$\n$$y_{\\text{extrap}}(T) = (\\alpha + \\beta) y(T) + \\left(\\alpha + \\frac{\\beta}{2}\\right) C h + \\left(\\alpha + \\frac{\\beta}{4}\\right) D h^2 + \\mathcal{O}(h^3)$$\n为了获得对 $y(T)$ 的一个 $\\mathcal{O}(h^2)$ 精度的估计，我们要求 $y(T)$ 的系数为 $1$，首项误差项 $Ch$ 的系数为 $0$。这给出了一个关于 $\\alpha$ 和 $\\beta$ 的二元线性方程组：\n1. $\\alpha + \\beta = 1$\n2. $\\alpha + \\frac{\\beta}{2} = 0$\n从方程 (2) 中，我们得到 $\\alpha = -\\beta/2$。将其代入方程 (1) 得到 $-\\beta/2 + \\beta = 1$，化简为 $\\beta/2 = 1$，所以 $\\beta = 2$。因此，$\\alpha = -1$。\n因此，外推估计器为：\n$$y_{\\text{extrap}}(T) = 2 y_{h/2}(T) - y_h(T)$$\n让我们验证这个新估计的误差：\n$$y_{\\text{extrap}}(T) - y(T) = (2 y_{h/2}(T) - y_h(T)) - y(T)$$\n$$= \\left(2\\left(y(T) + \\frac{1}{2}Ch + \\frac{1}{4}Dh^2\\right) - \\left(y(T) + Ch + Dh^2\\right)\\right) - y(T) + \\mathcal{O}(h^3)$$\n$$= (2y(T) + Ch + \\frac{1}{2}Dh^2) - y(T) - Ch - Dh^2 - y(T) + \\mathcal{O}(h^3)$$\n$$= (2-1-1)y(T) + (1-1)Ch + (\\frac{1}{2}-1)Dh^2 + \\mathcal{O}(h^3) = -\\frac{1}{2} D h^2 + \\mathcal{O}(h^3)$$\n误差确实是 $h^2$ 阶的，因此该方法成功地消除了首项误差项。\n\n**3. 计算步骤**\n对于四个测试用例中的每一个，应用以下算法：\n1.  定义函数 $f(t,y)$、初始条件 $y_0, t_0$、最终时间 $T$ 和步长 $h$。\n2.  实现一个函数 `forward_euler(f, y0, t0, T, h)`，该函数执行迭代的欧拉更新并返回在时间 $T$ 的最终近似值。步数 $N$ 计算为整数 `(T - t0) / h`。\n3.  用给定的步长 $h$ 计算近似值：$A_h = \\text{forward_euler}(f, y_0, t_0, T, h)$。\n4.  用减半的步长 $h/2$ 计算近似值：$A_{h/2} = \\text{forward_euler}(f, y_0, t_0, T, h/2)$。\n5.  计算 Richardson 外推值：$y_{\\text{extrap}}(T) = 2 A_{h/2} - A_h$。\n6.  使用为特定测试用例提供的公式计算精确解 $y(T)$。\n7.  计算绝对误差：$E = \\lvert y_{\\text{extrap}}(T) - y(T) \\rvert$。\n8.  该测试用例的最终结果是此误差，四舍五入到十位小数。对所有测试用例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes absolute errors for Richardson-extrapolated Euler method solutions\n    for a suite of ODE test cases.\n    \"\"\"\n\n    def forward_euler(f, y0, t0, T, h):\n        \"\"\"\n        Computes the solution of an IVP y'(t) = f(t, y) with y(t0) = y0 at time T\n        using the forward Euler method with step size h.\n        \"\"\"\n        t = t0\n        y = y0\n        \n        # The problem statement guarantees (T - t0) / h is an integer.\n        # Using int() directly is safe, but rounding is more robust for floats.\n        num_steps = int(round((T - t0) / h))\n\n        for _ in range(num_steps):\n            y = y + h * f(t, y)\n            t = t + h\n        \n        return y\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda t, y: y,\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"exact_sol\": lambda t: np.exp(t)\n        },\n        {\n            \"f\": lambda t, y: y + t,\n            \"y0\": 0.0,\n            \"t0\": 0.0,\n            \"T\": 2.0,\n            \"h\": 0.4,\n            \"exact_sol\": lambda t: np.exp(t) - t - 1.0\n        },\n        {\n            \"f\": lambda t, y: 1.0 * y * (1.0 - y / 10.0), # r=1, K=10\n            \"y0\": 1.0,\n            \"t0\": 0.0,\n            \"T\": 3.0,\n            \"h\": 0.5,\n            \"exact_sol\": lambda t: 10.0 / (1.0 + ((10.0 - 1.0) / 1.0) * np.exp(-1.0 * t))\n        },\n        {\n            \"f\": lambda t, y: 0.0,\n            \"y0\": 3.0,\n            \"t0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.5,\n            \"exact_sol\": lambda t: 3.0\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        f = case[\"f\"]\n        y0 = case[\"y0\"]\n        t0 = case[\"t0\"]\n        T = case[\"T\"]\n        h = case[\"h\"]\n        exact_sol_func = case[\"exact_sol\"]\n\n        # 1. Compute approximations with step sizes h and h/2\n        y_h = forward_euler(f, y0, t0, T, h)\n        y_h_half = forward_euler(f, y0, t0, T, h / 2.0)\n\n        # 2. Apply Richardson extrapolation\n        y_extrap = 2.0 * y_h_half - y_h\n\n        # 3. Compute the exact solution\n        y_exact = exact_sol_func(T)\n        \n        # 4. Compute the absolute error\n        abs_error = abs(y_extrap - y_exact)\n        \n        results.append(abs_error)\n\n    # Format the results as strings rounded to 10 decimal places\n    # The f-string formatting ensures trailing zeros as in the example.\n    # The rounding prior to formatting correctly handles cases near the rounding boundary.\n    results_str = [f\"{round(res, 10):.10f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_str)}]\")\n\nsolve()\n```", "id": "3226253"}]}