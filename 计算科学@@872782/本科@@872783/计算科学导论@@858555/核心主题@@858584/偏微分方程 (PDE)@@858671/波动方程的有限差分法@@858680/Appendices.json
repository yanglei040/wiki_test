{"hands_on_practices": [{"introduction": "显式有限差分格式的稳定性对于获得有意义的结果至关重要。本练习聚焦于 Courant-Friedrichs-Lewy (CFL) 条件，它为时间步长设置了一个基本限制。通过计算最大稳定时间步长，您将具体理解物理波速 $c$ 与数值网格参数 $\\Delta x$ 和 $\\Delta t$ 之间的相互关系。", "problem": "一位计算物理学家正在模拟声波在一维管道中的传播，该过程由波动方程 $\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2}$ 描述。介质中的声速为 $c = 320$ m/s。该模拟在空间网格上采用显式有限差分格式，空间步长为 $\\Delta x = 0.8$ m。为使该数值方法保持稳定，所选择的时间步长 $\\Delta t$ 必须满足 Courant-Friedrichs-Lewy (CFL) 稳定性条件，该条件由关系式 $c \\frac{\\Delta t}{\\Delta x} \\le 1$ 给出。确定能确保模拟稳定性的时间步长 $\\Delta t$ 的最大可能值。答案以秒为单位表示。", "solution": "应用于一维波动方程的显式有限差分格式的 Courant-Friedrichs-Lewy (CFL) 稳定性条件由下式给出：\n$$\nc \\frac{\\Delta t}{\\Delta x} \\le 1.\n$$\n为确保稳定性并取可能的最大时间步长，我们将该不等式取等号：\n$$\nc \\frac{\\Delta t_{\\max}}{\\Delta x} = 1 \\quad \\Rightarrow \\quad \\Delta t_{\\max} = \\frac{\\Delta x}{c}.\n$$\n代入给定值 $\\Delta x = 0.8$ m 和 $c = 320$ m/s：\n$$\n\\Delta t_{\\max} = \\frac{0.8}{320}.\n$$\n化简该分数：\n$$\n\\frac{0.8}{320} = \\frac{8}{3200} = \\frac{1}{400} = 0.0025.\n$$\n因此，最大稳定时间步长为 $0.0025$ 秒。", "answer": "$$\\boxed{0.0025}$$", "id": "2172272"}, {"introduction": "标准的有限差分模板适用于内部点，但物理系统的模拟几乎总是涉及边界。本实践问题演示了如何正确处理固定（Dirichlet）边界条件。为邻近边界的格点推导更新方程，是在有限区域上实现求解器的关键技能。", "problem": "考虑一维波动方程，这是一个偏微分方程 (PDE)，它模拟了诸如琴弦振动等现象：\n$$ \\frac{\\partial^2 u}{\\partial t^2} = c^2 \\frac{\\partial^2 u}{\\partial x^2} $$\n其中 $u(x,t)$ 是在位置 $x$ 和时间 $t$ 的位移，而 $c$ 是恒定的波速。\n\n为数值求解该方程，我们可以使用有限差分法。我们在一个网格上将区域离散化，空间步长为 $\\Delta x$，时间步长为 $\\Delta t$。令 $u_i^j$ 表示 $u(i\\Delta x, j\\Delta t)$ 的数值近似。通过用二阶中心差分近似替代导数，我们得到内部网格点 $(i, j)$ 的标准显式更新格式：\n$$ u_i^{j+1} = 2(1-r^2)u_i^j + r^2(u_{i+1}^j + u_{i-1}^j) - u_i^{j-1} $$\n这个方程允许我们使用当前和之前时间步（$j$ 和 $j-1$）的值来计算下一个时间步（$j+1$）的位移。参数 $r = \\frac{c \\Delta t}{\\Delta x}$ 被称为库朗数。\n\n现在，考虑定义在空间域 $x \\in [0, L]$ 上的一根弦。网格点由 $i=0, 1, 2, \\dots, N$ 索引，其中 $x_i = i\\Delta x$ 且 $x_N=L$。弦在 $x=0$ 的一端是固定不动的，这施加了边界条件 $u(0, t) = 0$（对于所有时间 $t$）。在我们的离散记法中，这转换为 $u_0^j = 0$（对于所有时间索引 $j \\ge 0$）。\n\n你的任务是推导在 $i=1$ 处网格点的具体更新方程，该点与此固定边界相邻。请将新的位移 $u_1^{j+1}$ 表示为时间步 $j$ 和 $j-1$ 处位移的函数。", "solution": "我们从给定的一维波动方程内部点的显式有限差分更新格式开始：\n$$\nu_{i}^{j+1}=2(1-r^{2})u_{i}^{j}+r^{2}\\left(u_{i+1}^{j}+u_{i-1}^{j}\\right)-u_{i}^{j-1},\n$$\n其中库朗数为 $r=\\frac{c\\Delta t}{\\Delta x}$ 且 $u_{i}^{j}$ 近似于 $u(i\\Delta x,j\\Delta t)$。\n\n为了得到与固定边界相邻点的更新格式，令 $i=1$：\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}\\left(u_{2}^{j}+u_{0}^{j}\\right)-u_{1}^{j-1}.\n$$\n\n固定端的边界条件是 $u(0,t)=0$（对于所有 $t$），其离散形式为 $u_{0}^{j}=0$（对于所有 $j\\ge 0$）。将 $u_{0}^{j}=0$ 代入方程得到：\n$$\nu_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}\n$$\n\n这就使用在 $i=0$ 处的已知边界值，将新的位移 $u_{1}^{j+1}$ 表示成了时间步 $j$ 和 $j-1$ 处的值的函数。", "answer": "$$\\boxed{u_{1}^{j+1}=2(1-r^{2})u_{1}^{j}+r^{2}u_{2}^{j}-u_{1}^{j-1}}$$", "id": "2172248"}, {"introduction": "本练习旨在连接理论原则与实际编程实现。您将构建一个完整的一维波动方程求解器，并用它进行数值实验，以经验性地验证我们先前讨论过的 CFL 稳定性条件 [@problem_id:2172272]。通过观察当该条件被违反时模拟结果如何急剧崩溃，您将对数值稳定性为何不仅是数学上的奇特现象，更是实际应用中的必需品，建立起深刻的直觉。", "problem": "考虑在区间 $[0,L]$ 上，两端固定的拉紧弦的位移 $u(x,t)$，其运动由偏微分方程 $$u_{tt}(x,t) = c^2 u_{xx}(x,t),$$ 决定，其中 $c$ 是波速。弦的两端保持固定，意味着边界条件为 $u(0,t) = 0$ 和 $u(L,t) = 0$（对所有 $t \\ge 0$）。初始位移给定为 $$u(x,0) = \\sin\\left(\\frac{\\pi x}{L}\\right),$$ 初始速度为 $$u_t(x,0) = 0.$$ 所有距离的单位必须是米，时间的单位是秒，波速 $c$ 的单位是米/秒。按照惯例，正弦函数使用弧度。\n\n你的任务是使用均匀网格间距，为该方程推导并实现一个在空间和时间上均为二阶精度的显式有限差分方法。从泰勒展开的基本原理和中心差分的定义出发，在均匀网格上近似 $u_{tt}$ 和 $u_{xx}$，并推导将解从离散时间层 $n$ 推进到 $n+1$ 所需的更新规则。不要假设任何预先存在的格式：直接从定义构建该方法。在所有时间层上，使用固定边界条件处理两个端点。对于第一个时间步，使用基于给定初始位置和初始速度的相容二阶精度公式，以获得时间层 $n=1$ 处的解。\n\n通过运行一系列参数值的格式，并观察数值解是保持有界还是发散，使用 Courant–Friedrichs–Lewy (CFL) 条件来经验性地评估稳定性。定义一个经验性发散检测器如下：设 $M_0$ 为 $u(x,0)$ 在空间网格上的最大绝对值。在时间步进过程中，计算 $M_n$，即时间层 $n$ 上所有空间点的最大绝对值。如果在任何时刻 $M_n$ 变为未定义（非数值）、无穷大或超过 $10 M_0$，则声明模拟为不稳定（发散）；否则，声明其为稳定。该检测器必须在你的程序中实现。\n\n对于空间离散化，使用在 $[0,L]$ 上的 $N_x$ 个点的均匀网格，间距为 $\\Delta x = L/(N_x - 1)$ 米。对于时间离散化，使用均匀时间步长 $\\Delta t$ 秒，并模拟到最终时间 $T$ 秒。对于每个测试用例，计算布尔稳定性结果，其中 $True$ 表示稳定，$False$ 表示发散。\n\n实现你的程序以运行以下测试套件，该套件涵盖一个典型情况、一个接近 CFL 限制的边界情况以及一些超出限制的情况：\n- 测试 1：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.008$ 秒, $T = 0.5$ 秒。\n- 测试 2：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.010$ 秒, $T = 0.5$ 秒。\n- 测试 3：$c = 1.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.015$ 秒, $T = 1.0$ 秒。\n- 测试 4：$c = 2.0$ 米/秒, $L = 1.0$ 米, $N_x = 101$, $\\Delta t = 0.010$ 秒, $T = 0.5$ 秒。\n\n你的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[result_1,result_2,result_3,result_4]$），其中每个 $result_k$ 是你的经验性发散检测器为测试 $k$ 计算出的布尔稳定性结果。不应打印任何额外文本。输出的布尔值没有物理单位。涉及 $c$、$L$、$\\Delta x$、$\\Delta t$ 和 $T$ 的输入和计算必须按规定一致地使用米和秒。", "solution": "我们从通过泰勒展开获得中心差分的基本定义开始。在间距为 $\\Delta x$ 的均匀空间网格和间距为 $\\Delta t$ 的均匀时间网格上，令 $x_i = i \\Delta x$（对于 $i = 0,1,\\dots,N_x-1$）和 $t^n = n \\Delta t$（对于 $n = 0,1,2,\\dots$）。令 $u_i^n$ 表示 $u(x_i,t^n)$ 的数值近似。\n\n在点 $(x_i,t^n)$ 处，时间二阶导数的二阶中心差分近似可由泰勒展开\n$$u(x_i,t^{n\\pm 1}) = u(x_i,t^n) \\pm \\Delta t \\, u_t(x_i,t^n) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,t^n) \\pm \\frac{\\Delta t^3}{6} u_{ttt}(x_i,t^n) + \\cdots,$$\n得出\n$$u_{tt}(x_i,t^n) \\approx \\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2}.$$\n类似地，对于空间二阶导数，使用空间上的泰勒展开，\n$$u(x_{i\\pm 1},t^n) = u(x_i,t^n) \\pm \\Delta x \\, u_x(x_i,t^n) + \\frac{\\Delta x^2}{2} u_{xx}(x_i,t^n) \\pm \\frac{\\Delta x^3}{6} u_{xxx}(x_i,t^n) + \\cdots,$$\n我们得到\n$$u_{xx}(x_i,t^n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n\n将这些近似代入内部点 $i = 1,2,\\dots,N_x-2$ 处的波动方程 $u_{tt} = c^2 u_{xx}$，得到离散方程\n$$\\frac{u_i^{n+1} - 2 u_i^n + u_i^{n-1}}{\\Delta t^2} = c^2 \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.$$\n重新整理以得到从时间层 $n$ 到 $n+1$ 的更新，便得出显式格式\n$$u_i^{n+1} = 2 u_i^n - u_i^{n-1} + r^2 \\left(u_{i+1}^n - 2 u_i^n + u_{i-1}^n\\right),$$\n其中我们定义无量纲的 Courant 数\n$$r = \\frac{c \\, \\Delta t}{\\Delta x}.$$\n\n边界条件为 $u_0^n = 0$ 和 $u_{N_x-1}^n = 0$（对所有 $n$）。初始条件提供了 $u_i^0 = \\sin\\left(\\frac{\\pi x_i}{L}\\right)$（对所有 $i$），这与固定端点是一致的，因为 $\\sin(0) = 0$ 和 $\\sin(\\pi) = 0$。为初始化该格式，我们还需要 $u_i^1$。使用在 $t=0$ 附近关于时间的二阶精度泰勒展开，并利用给定的初始速度 $u_t(x,0) = 0$，我们得到\n$$u(x_i,\\Delta t) \\approx u(x_i,0) + \\Delta t \\, u_t(x_i,0) + \\frac{\\Delta t^2}{2} u_{tt}(x_i,0).$$\n将 $u_{tt}(x_i,0)$ 替换为 $c^2 u_{xx}(x_i,0)$，并在时间 $n=0$ 应用中心空间差分，得到\n$$u_i^1 = u_i^0 + \\Delta t \\cdot 0 + \\frac{1}{2} r^2 \\left(u_{i+1}^0 - 2 u_i^0 + u_{i-1}^0\\right), \\quad \\text{对于 } i=1,\\dots,N_x-2,$$\n其中 $u_0^1 = 0$ 和 $u_{N_x-1}^1 = 0$。\n\nCourant–Friedrichs–Lewy (CFL) 条件源于稳定性分析（例如，通过 von Neumann 傅里叶模态分析）。对于上述显式二阶中心差分格式，应用于单个傅里叶模的放大因子 $G$ 满足一个稳定性约束，该约束导致了要求\n$$r \\le 1.$$\n当 $r \\le 1$ 时，所有傅里叶模都满足 $|G| \\le 1$，方法是稳定的；当 $r  1$ 时，某些模的 $|G|  1$，这会导致指数增长和数值发散。\n\n算法设计原则：\n- 定义物理和数值参数 $c$、$L$、$N_x$、$\\Delta t$、$T$，使用米和秒。\n- 计算网格间距 $\\Delta x = L/(N_x-1)$ 和 Courant 数 $r = c \\Delta t / \\Delta x$。\n- 初始化 $u_i^0 = \\sin(\\pi x_i / L)$（对于 $i=0,\\dots,N_x-1$）和 $u_t(x,0) = 0$。\n- 使用包含 $u_{tt}(x,0) = c^2 u_{xx}(x,0)$ 的二阶公式计算 $u^1$。\n- 对于 $n \\ge 1$，使用内部点的显式更新来推进 $u^{n+1}$，并在端点处强制施加边界条件。\n- 在每个时间步，计算 $M_n = \\max_i |u_i^n|$ 并应用经验性发散检测器：如果 $M_n$ 变为非数值、无穷大或超过 $10 M_0$（其中 $M_0 = \\max_i |u_i^0|$），则声明不稳定；否则继续直到最终时间 $T$。\n- 返回一个指示稳定性的布尔值。\n\n测试套件基本原理：\n- 测试 1 选择 $r = 0.8$（$c = 1.0$, $\\Delta t = 0.008$, $\\Delta x = 0.01$）作为一个典型的稳定情况。\n- 测试 2 设置 $r = 1.0$ 作为一个边界情况，对于此格式应保持稳定。\n- 测试 3 使用 $r = 1.5$ 和更长的最终时间，以确保不稳定性能够经验性地显现出来。\n- 测试 4 使用 $r = 2.0$，这远超 CFL 限制，并且会迅速发散。\n\n基于 CFL 条件和经验性检测的预期结果：\n- 测试 1：$True$（稳定）。\n- 测试 2：$True$（稳定）。\n- 测试 3：$False$（发散）。\n- 测试 4：$False$（发散）。\n\n最终程序会汇总这些布尔值，并按要求将它们打印为用方括号括起来的单个逗号分隔列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef simulate_wave_1d_stability(c, L, Nx, dt, T):\n    \"\"\"\n    Simulate the 1D wave equation u_tt = c^2 u_xx with fixed ends using\n    second-order central differences in space and time. Empirically detect\n    instability (blow-up) via amplitude growth and NaN/Inf checks.\n\n    Parameters:\n        c  (float): wave speed (m/s)\n        L  (float): domain length (m)\n        Nx (int):   number of spatial grid points\n        dt (float): time step (s)\n        T  (float): final time (s)\n\n    Returns:\n        bool: True if stable (no blow-up detected), False otherwise.\n    \"\"\"\n    # Spatial discretization\n    dx = L / (Nx - 1)\n    x = np.linspace(0.0, L, Nx)\n\n    # Courant number\n    r = c * dt / dx\n\n    # Initial displacement u(x,0) = sin(pi x / L), initial velocity = 0\n    u0 = np.sin(np.pi * x / L)\n    # Boundary conditions are fixed ends: u(0,t) = 0, u(L,t) = 0\n    u0[0] = 0.0\n    u0[-1] = 0.0\n\n    # Prepare arrays for time stepping\n    u_prev = u0.copy()\n\n    # Compute u^1 using second-order accurate initialization:\n    # u^1 = u^0 + dt * v^0 + (dt^2 / 2) * c^2 * u_xx^0\n    # with v^0 = 0 and u_xx^0 approximated by central differences\n    u_curr = u0.copy()\n    # interior update for the first step\n    # u_curr[i] = u_prev[i] + 0 + 0.5 * r^2 * (u_prev[i+1] - 2*u_prev[i] + u_prev[i-1])\n    for i in range(1, Nx - 1):\n        u_curr[i] = u_prev[i] + 0.5 * (r ** 2) * (u_prev[i + 1] - 2.0 * u_prev[i] + u_prev[i - 1])\n    # Enforce boundary conditions\n    u_curr[0] = 0.0\n    u_curr[-1] = 0.0\n\n    # Empirical blow-up detector thresholds\n    M0 = np.max(np.abs(u0))\n    if not np.isfinite(M0):\n        return False  # pathological, treat as blow-up\n    threshold = 10.0 * (M0 if M0  0 else 1.0)  # avoid zero threshold\n\n    # Number of time steps\n    n_steps = int(np.floor(T / dt))\n\n    # Time stepping\n    for _ in range(1, n_steps):\n        u_next = u_curr.copy()\n        # Explicit update for interior points:\n        # u_next[i] = 2*u_curr[i] - u_prev[i] + r^2 * (u_curr[i+1] - 2*u_curr[i] + u_curr[i-1])\n        for i in range(1, Nx - 1):\n            u_next[i] = (\n                2.0 * u_curr[i]\n                - u_prev[i]\n                + (r ** 2) * (u_curr[i + 1] - 2.0 * u_curr[i] + u_curr[i - 1])\n            )\n        # Enforce boundary conditions\n        u_next[0] = 0.0\n        u_next[-1] = 0.0\n\n        # Check for blow-up\n        M_n = np.max(np.abs(u_next))\n        if not np.isfinite(M_n) or M_n  threshold:\n            return False\n\n        # Rotate time levels\n        u_prev, u_curr = u_curr, u_next\n\n    # If reached final time without blow-up, declare stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is a tuple: (c, L, Nx, dt, T)\n    test_cases = [\n        (1.0, 1.0, 101, 0.008, 0.5),  # r = 0.8, expected stable\n        (1.0, 1.0, 101, 0.010, 0.5),  # r = 1.0, expected stable\n        (1.0, 1.0, 101, 0.015, 1.0),  # r = 1.5, expected unstable\n        (2.0, 1.0, 101, 0.010, 0.5),  # r = 2.0, expected unstable\n    ]\n\n    results = []\n    for c, L, Nx, dt, T in test_cases:\n        result = simulate_wave_1d_stability(c, L, Nx, dt, T)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129202"}]}