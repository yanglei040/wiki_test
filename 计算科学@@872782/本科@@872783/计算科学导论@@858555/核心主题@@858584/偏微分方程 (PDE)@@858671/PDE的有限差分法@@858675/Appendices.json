{"hands_on_practices": [{"introduction": "对流扩散方程是输运现象建模的基础。当对流作用远强于扩散作用时（即高佩克莱特数），理论上更精确的标准中心差分格式可能会产生非物理的数值振荡。本练习将挑战你实现中心差分和迎风差分两种格式，让你亲眼观察在计算流体动力学中至关重要的、介于形式精度和数值稳定性之间的权衡。[@problem_id:3128259]", "problem": "要求您研究一维线性对流扩散偏微分方程 (PDE) $u_t + a\\,u_x = \\epsilon\\,u_{xx}$ 的空间离散化。该方程定义在区域 $x \\in [0,1]$ 上，其中对流速度 $a  0$ 和扩散系数 $\\epsilon  0$ 均为正常数。重点关注由设置 $u_t = 0$ 得到的定常问题所产生的稳态边界层结构，即 $\\epsilon\\,u_{xx} - a\\,u_x = 0$，其狄利克雷边界条件为 $u(0) = 1$ 和 $u(1) = 0$。您将分析当网格佩克莱特数增加时，不同的空间有限差分离散格式的行为，并量化数值解中是否出现离散振荡。\n\n仅从基本定义出发，在包含 $N$ 个点、网格间距为 $h = 1/(N-1)$ 的均匀网格上，为空间导数推导相容的二阶精度有限差分：\n- 使用中心差分格式 (CDS) 对一阶导数进行近似，$u_x(x_i) \\approx \\left(u_{i+1} - u_{i-1}\\right)/(2h)$，对二阶导数进行近似，$u_{xx}(x_i) \\approx \\left(u_{i+1} - 2u_i + u_{i-1}\\right)/h^2$。\n- 当 $a  0$ 时，对一阶导数使用迎风差分格式 (UDS)，$u_x(x_i) \\approx \\left(u_i - u_{i-1}\\right)/h$，同时保持与上述相同的二阶导数近似。\n\n在每种情况下，根据在内部网格点 $x_i$（$i = 1,\\dots,N-2$）处的稳态方程 $\\epsilon\\,u_{xx} - a\\,u_x = 0$ 构建内部未知数 $u_1,\\dots,u_{N-2}$ 的三对角线性系统，并将狄利克雷边界条件 $u_0 = 1$ 和 $u_{N-1} = 0$ 直接施加到右侧项中。求解该线性系统，以获得离散稳态剖面 $u_i$（$i=0,\\dots,N-1$）。\n\n将网格佩克莱特数定义为 $Pe_h = \\dfrac{a\\,h}{\\epsilon}$。如果离散解满足以下任一条件，则定义其为振荡的：\n- 它在从 $x=0$ 到 $x=1$ 的区间上不是单调递减的，即对于所有 $i=0,\\dots,N-2$，$\\Delta_i = u_{i+1} - u_i \\le \\tau$ 不成立，其中 $\\tau = 10^{-10}$。\n- 它在边界条件所暗示的物理一致区间之外表现出上冲或下冲，即 $\\min_i u_i  0 -\\tau$ 或 $\\max_i u_i  1 + \\tau$。\n\n对于下面的每个测试用例，使用 CDS 和 UDS 计算稳态解。然后使用以下整数代码对这两种方法的结果进行分类：\n- $0$ 如果 CDS 是非振荡的，且 UDS 是非振荡的，\n- $1$ 如果 CDS 是振荡的，但 UDS 是非振荡的，\n- $2$ 如果 CDS 是振荡的，且 UDS 也是振荡的，\n- $3$ 如果 CDS 是非振荡的，但 UDS 是振荡的。\n\n测试组（所有参数均为无量纲）：\n- 用例 A：$a = 1$，$\\epsilon = 0.1$，$N = 41$。\n- 用例 B：$a = 5$，$\\epsilon = 0.01$，$N = 41$。\n- 用例 C：$a = 50$，$\\epsilon = 0.01$，$N = 41$。\n- 用例 D：$a = 1$，$\\epsilon = 0.0125$，$N = 41$。\n\n您的程序必须输出一行，其中包含用例 A、B、C 和 D 的整数代码的逗号分隔列表，并按此顺序排列，用方括号括起来（例如，$[0,1,1,0]$）。此问题中无需报告物理单位，因为参数和变量都是无量纲的。角度单位不适用。所有最终数值输出必须是指定列表格式的整数。", "solution": "用户提供的问题是有效的，因为它具有科学依据、是适定的且客观的。它构成了偏微分方程数值分析中的一个标准练习，旨在专门考察用于对流扩散方程的有限差分方法的稳定性和准确性。\n\n该问题研究一维稳态线性对流扩散方程：\n$$\n\\epsilon u_{xx} - a u_x = 0\n$$\n该方程定义在空间区域 $x \\in [0, 1]$ 上，其中对流速度 $a  0$ 和扩散系数 $\\epsilon  0$ 均为正常数。方程受狄利克雷边界条件 $u(0) = 1$ 和 $u(1) = 0$ 的约束。已知该边值问题的解析解为：\n$$\nu(x) = \\frac{e^{ax/\\epsilon} - e^{a/\\epsilon}}{1 - e^{a/\\epsilon}}\n$$\n该精确解是单调的，从 $u(0)=1$ 递减至 $u(1)=0$。因此，在数值解中观察到的任何振荡都是离散化方法产生的伪影。\n\n我们使用一个包含 $N$ 个点的均匀网格对区域进行离散化，$x_i = i h$，其中 $i = 0, 1, \\dots, N-1$，网格间距为 $h = 1/(N-1)$。在这些网格点上求解数值解 $u_i \\approx u(x_i)$。边界条件固定了端点的值：$u_0 = 1$ 和 $u_{N-1} = 0$。内部点 $u_1, \\dots, u_{N-2}$ 的解是通过求解由离散化 PDE 推导出的线性方程组得到的。\n\n我们考虑两种不同的有限差分格式来处理内部网格点 $x_i$ 处的空间导数：\n\n1.  **中心差分格式 (CDS)**\n    该格式对一阶和二阶导数均采用二阶精度的中心差分：\n    $$\n    u_x(x_i) \\approx \\frac{u_{i+1} - u_{i-1}}{2h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    将这些代入控制方程 $\\epsilon u_{xx} - a u_x = 0$ 中，得到：\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_{i+1} - u_{i-1}}{2h} \\right) = 0\n    $$\n    两边乘以 $h^2$ 并合并关于 $u_{i-1}$、$u_i$ 和 $u_{i+1}$ 的项，我们得到每个内部节点 $i=1, \\dots, N-2$ 的离散方程：\n    $$\n    \\left(\\epsilon + \\frac{ah}{2}\\right) u_{i-1} - 2\\epsilon u_i + \\left(\\epsilon - \\frac{ah}{2}\\right) u_{i+1} = 0\n    $$\n    通过定义无量纲的网格佩克莱特数 $Pe_h = \\frac{ah}{\\epsilon}$（它比较了在一个网格单元上对流与扩散的强度），该方程可重写为：\n    $$\n    \\epsilon \\left( \\left(1 + \\frac{Pe_h}{2}\\right) u_{i-1} - 2 u_i + \\left(1 - \\frac{Pe_h}{2}\\right) u_{i+1} \\right) = 0\n    $$\n    一个与离散极值原理相关的关键稳定性判据要求，所得到矩阵的非对角系数的符号不能导致非物理极值。对于此方程，$u_{i+1}$ 的系数是 $(1 - Pe_h/2)$，如果 $Pe_h  2$，该系数会变为负数。众所周知，这种情况会导致数值解中出现伪振荡，尤其是在具有强梯度的区域。\n\n2.  **迎风差分格式 (UDS)**\n    该格式对对流项采用一阶精度的后向差分（因为 $a0$，所以“迎风”方向来自较小的 $x$），并对扩散项采用相同的二阶中心差分：\n    $$\n    u_x(x_i) \\approx \\frac{u_i - u_{i-1}}{h}, \\quad u_{xx}(x_i) \\approx \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2}\n    $$\n    将这些近似代入控制方程，得到：\n    $$\n    \\epsilon \\left( \\frac{u_{i+1} - 2u_i + u_{i-1}}{h^2} \\right) - a \\left( \\frac{u_i - u_{i-1}}{h} \\right) = 0\n    $$\n    两边乘以 $h^2$ 并合并项，得到离散方程：\n    $$\n    (\\epsilon + ah) u_{i-1} - (2\\epsilon + ah) u_i + \\epsilon u_{i+1} = 0\n    $$\n    在这种形式中，相邻点 $u_{i-1}$ 和 $u_{i+1}$ 的系数分别为 $(\\epsilon + ah)$ 和 $\\epsilon$。由于 $a, \\epsilon, h$ 均为正数，这些系数始终为正。得到的矩阵是对角占优的，并且该格式保证对于任何网格佩克莱特数的值都能产生非振荡解，其代价是只有一阶精度。\n\n对于这两种格式，都为内部未知数向量 $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-2}]^T$ 形成一个三对角线性方程组 $M \\mathbf{u}_{\\text{int}} = \\mathbf{b}$。边界条件被并入右端向量 $\\mathbf{b}$ 中。对于第一个内部节点（$i=1$），涉及 $u_0=1$ 的项被移到右侧；对于最后一个内部节点（$i=N-2$），涉及 $u_{N-1}=0$ 的项为零。这导致一个系统中只有 $\\mathbf{b}$ 的第一个元素非零。\n\n如果解不是单调递减的（具体来说，如果对任何 $i$ 有 $u_{i+1} - u_i  \\tau$，其中 $\\tau=10^{-10}$），或者如果它表现出超出由边界条件设定的物理范围的上冲/下冲（即 $\\min_i u_i  -\\tau$ 或 $\\max_i u_i  1 + \\tau$），则该解被认为是振荡的。\n\n解题步骤是：对每个测试用例，使用 CDS 和 UDS 求解这些线性系统，检查所得解是否存在振荡，并根据这两种方法的结果对分配相应的整数代码。这在所提供的 Python 代码中实现，该代码使用 `scipy.linalg.solve_banded` 来高效求解三对角系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import solve_banded\n\ndef solve():\n    \"\"\"\n    Solves the 1D steady convection-diffusion equation for specified test cases\n    using Central Difference Scheme (CDS) and Upwind Difference Scheme (UDS),\n    and classifies the results based on the presence of numerical oscillations.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (a, epsilon, N)\n        (1.0, 0.1, 41),    # Case A\n        (5.0, 0.01, 41),   # Case B\n        (50.0, 0.01, 41),  # Case C\n        (1.0, 0.0125, 41), # Case D\n    ]\n\n    # Tolerance for oscillation checks\n    tau = 1e-10\n\n    def check_oscillatory(u_sol, tau_val):\n        \"\"\"\n        Checks if a numerical solution is oscillatory.\n\n        A solution is defined as oscillatory if:\n        1. It is not monotone decreasing, i.e., u[i+1] > u[i] + tau for some i.\n        2. It has overshoot or undershoot outside the physical bounds [0, 1].\n        \"\"\"\n        # Check for non-monotonicity\n        if np.any(np.diff(u_sol) > tau_val):\n            return True\n            \n        # Check for overshoot/undershoot\n        if np.min(u_sol)  -tau_val or np.max(u_sol) > 1.0 + tau_val:\n            return True\n            \n        return False\n\n    def solve_system(a, epsilon, N, scheme):\n        \"\"\"\n        Constructs and solves the tridiagonal linear system for a given scheme.\n        \"\"\"\n        h = 1.0 / (N - 1)\n        N_int = N - 2  # Number of interior points\n        \n        # Define matrix coefficients based on the scheme\n        if scheme == 'CDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h / 2.0\n            B = -2.0 * epsilon\n            C = epsilon - a * h / 2.0\n        elif scheme == 'UDS':\n            # A*u_{i-1} + B*u_i + C*u_{i+1} = 0\n            A = epsilon + a * h\n            B = -(2.0 * epsilon + a * h)\n            C = epsilon\n        else:\n            raise ValueError(\"Unknown scheme specified.\")\n            \n        # Create tridiagonal matrix in banded format for scipy.linalg.solve_banded\n        # For a tridiagonal matrix, (l, u) = (1, 1), so matrix `ab` has shape (3, N_int).\n        # ab[0, 1:] = upper diagonal (C)\n        # ab[1, :] = main diagonal (B)\n        # ab[2, :-1] = lower diagonal (A)\n        ab = np.zeros((3, N_int))\n        ab[0, 1:] = C\n        ab[1, :] = B\n        ab[2, :-1] = A\n        \n        # Create the right-hand side vector b\n        # For i=1: A*u_0 + B*u_1 + C*u_2 = 0 => B*u_1 + C*u_2 = -A*u_0\n        # Since u_0 = 1, the first element of b is -A.\n        # For i=N-2: A*u_{N-3} + B*u_{N-2} + C*u_{N-1} = 0\n        # Since u_{N-1} = 0, the last element remains 0.\n        b = np.zeros(N_int)\n        b[0] = -A * 1.0\n        \n        # Solve the linear system for interior points\n        u_interior = solve_banded((1, 1), ab, b)\n        \n        # Assemble the full solution vector including boundaries u_0=1 and u_{N-1}=0\n        u_full = np.concatenate(([1.0], u_interior, [0.0]))\n        \n        return u_full\n\n    results = []\n    for case in test_cases:\n        a_val, eps_val, N_val = case\n        \n        # Solve for CDS and check for oscillations\n        u_cds = solve_system(a_val, eps_val, N_val, 'CDS')\n        cds_oscillatory = check_oscillatory(u_cds, tau)\n        \n        # Solve for UDS and check for oscillations\n        u_uds = solve_system(a_val, eps_val, N_val, 'UDS')\n        uds_oscillatory = check_oscillatory(u_uds, tau)\n        \n        # Classify the outcome based on the problem's integer codes\n        code = -1\n        if not cds_oscillatory and not uds_oscillatory:\n            code = 0  # Both non-oscillatory\n        elif cds_oscillatory and not uds_oscillatory:\n            code = 1  # CDS oscillatory, UDS non-oscillatory\n        elif cds_oscillatory and uds_oscillatory:\n            code = 2  # Both oscillatory\n        elif not cds_oscillatory and uds_oscillatory:\n            code = 3  # CDS non-oscillatory, UDS oscillatory\n        \n        results.append(code)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3128259"}, {"introduction": "Crank-Nicolson方法因其二阶精度和在纯扩散问题中优异的稳定性而备受推崇。然而，在处理刚性反应项或不连续初始条件时，它可能会出人意料地产生非物理的时间振荡。本练习将引导你发现这一微妙现象，并测试一种专业的修正方法——Rannacher启动，从而证明即使是稳健的格式也存在必须理解的局限性。[@problem_id:3128239]", "problem": "考虑一维扩散-反应偏微分方程 (PDE) $$u_t=\\kappa\\,u_{xx}-\\lambda\\,u$$，其定义在空间域 $$x\\in[0,1]$$ 和时间域 $$t\\in[0,T]$$ 上，具有齐次 Dirichlet 边界条件 $$u(0,t)=0$$ 和 $$u(1,t)=0$$，以及不连续的初始条件 $$u(x,0)=\\begin{cases}1,  0.25 \\le x \\le 0.75 \\\\ 0,  \\text{otherwise}\\end{cases}$$。该初始条件在 $$x=0.25$$ 和 $$x=0.75$$ 处存在跳跃不连续性。\n\n您的任务是使用 Crank-Nicolson (CN) 方法对该问题进行数值求解，并实现 Rannacher 启动程序作为一种可选的修正。您需要确定在不同的参数组合下，标准的 CN 方法或带有 Rannacher 启动的 CN 方法是否会产生违反物理极值原理（即解应保持在 $[0,1]$ 区间内）的数值振荡。\n\n具体来说，您的程序必须：\n1.  对 PDE 进行离散化。在空间上，使用二阶中心差分；在时间上，实现标准的 Crank-Nicolson 格式。\n2.  实现一个 Rannacher 启动选项：在模拟开始时，用两个步长为 $\\Delta t/2$ 的后向欧拉 (Backward Euler, BE) 步来代替第一个 Crank-Nicolson 步。\n3.  在每个时间步之后，检查解向量是否有任何值落在物理区间 $[0,1]$ 之外（允许 $10^{-3}$ 的容差）。如果解向量的任何元素小于 $-10^{-3}$ 或大于 $1+10^{-3}$，则认为出现了振荡。\n4.  对于下面列出的每个测试用例，运行模拟并确定是否检测到振荡。\n\n测试用例：\n-   案例 1：$\\kappa = 1.0$, $\\lambda = 400.0$, $N = 51$, $\\Delta t = 0.005$, $T = 0.1$, 使用标准 Crank-Nicolson。\n-   案例 2：$\\kappa = 1.0$, $\\lambda = 400.0$, $N = 51$, $\\Delta t = 0.005$, $T = 0.1$, 使用带 Rannacher 启动的 Crank-Nicolson。\n-   案例 3：$\\kappa = 1.0$, $\\lambda = 0.0$, $N = 51$, $\\Delta t = 0.0001$, $T = 0.1$, 使用标准 Crank-Nicolson。\n-   案例 4：$\\kappa = 1.0$, $\\lambda = 0.0$, $N = 51$, $\\Delta t = 0.005$, $T = 0.1$, 使用标准 Crank-Nicolson。\n\n您的程序应输出一个布尔值的逗号分隔列表，用方括号括起来，例如 `[True,False,False,True]`。列表中的每个布尔值对应于按顺序排列的每个测试用例，`True` 表示检测到振荡，`False` 表示未检测到振荡。", "solution": "该问题要求使用有限差分法求解一维扩散-反应方程，并分析在不连续初始条件下 Crank-Nicolson (CN) 方法的数值振荡行为，以及 Rannacher 启动程序的修正效果。\n\n#### 1. 空间半离散化\n\n首先，我们在空间上对 PDE 进行离散化。我们将空间域 $[0,1]$ 划分为 $N$ 个点，网格间距为 $\\Delta x = 1/(N-1)$。由于边界条件是齐次的，我们只需求解 $M=N-2$ 个内部点 $x_1, \\dots, x_M$ 的解。我们使用二阶中心差分来近似空间二阶导数：\n$$\nu_{xx}(x_i) \\approx \\frac{u_{i-1} - 2u_i + u_{i+1}}{(\\Delta x)^2}\n$$\n将此代入 PDE $u_t = \\kappa u_{xx} - \\lambda u$，我们可以得到一个关于内部点解向量 $\\mathbf{u}(t) = [u_1(t), \\dots, u_M(t)]^T$ 的大型常微分方程 (ODE) 组：\n$$\n\\frac{d\\mathbf{u}}{dt} = \\kappa A\\mathbf{u} - \\lambda I\\mathbf{u} = L\\mathbf{u}\n$$\n其中，$I$ 是 $M \\times M$ 的单位矩阵，而 $A$ 是代表离散拉普拉斯算子的 $M \\times M$ 三对角矩阵：\n$$\nA = \\frac{1}{(\\Delta x)^2} \\begin{pmatrix}\n-2  1   \\\\\n1  -2  1  \\\\\n \\ddots  \\ddots  \\ddots \\\\\n  1  -2  1 \\\\\n   1  -2\n\\end{pmatrix}\n$$\n因此，整个空间算子由矩阵 $L = \\kappa A - \\lambda I$ 表示。\n\n#### 2. 时间全离散化\n\n接下来，我们对半离散的 ODE 系统 $\\frac{d\\mathbf{u}}{dt} = L\\mathbf{u}$ 进行时间积分。\n\n-   **Crank-Nicolson (CN) 方法**: 该方法在时间上应用梯形法则，它在时间上是二阶精确且无条件稳定的（对于线性问题）。其离散形式为：\n    $$\n    \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = \\frac{1}{2}(L\\mathbf{u}^{n+1} + L\\mathbf{u}^n)\n    $$\n    整理后，我们得到在每个时间步需要求解的线性系统：\n    $$\n    (I - \\frac{\\Delta t}{2}L)\\mathbf{u}^{n+1} = (I + \\frac{\\Delta t}{2}L)\\mathbf{u}^n\n    $$\n\n-   **后向欧拉 (Backward Euler, BE) 方法**: 该方法是一阶精确的，但具有很强的耗散性（L-稳定性），能有效抑制高频振荡。其离散形式为：\n    $$\n    \\frac{\\mathbf{u}^{n+1} - \\mathbf{u}^n}{\\Delta t} = L\\mathbf{u}^{n+1}\n    $$\n    整理后得到线性系统：\n    $$\n    (I - \\Delta t L)\\mathbf{u}^{n+1} = \\mathbf{u}^n\n    $$\n\n-   **Rannacher 启动**: 标准 CN 方法虽然稳定，但在处理不光滑初始数据时，其放大因子的模在高频处趋近于-1，导致初始的数值振荡衰减缓慢。Rannacher 启动通过在前几个时间步使用强耗散的 BE 方法来解决此问题。具体来说，我们用两个步长为 $\\Delta t/2$ 的 BE 步从时间 $t=0$ 推进到 $t=\\Delta t$。之后的时间步则切换回二阶精度的 CN 方法。\n\n#### 3. 初始条件和算法\n\n初始条件 $u(x,0)$ 在内部网格点上被采样，以初始化向量 $\\mathbf{u}^0$。然后，算法按以下步骤执行：\n1.  根据 $N$ 构建空间离散化矩阵 $A$ 和 $L$。\n2.  根据不连续的初始条件函数初始化解向量 $\\mathbf{u}^0$。\n3.  如果使用 Rannacher 启动，则执行两次步长为 $\\Delta t/2$ 的 BE 求解。否则，直接进入主循环。\n4.  对于后续的每个时间步，使用 CN 格式构建并求解线性系统，更新解向量。\n5.  在每个时间步求解后，检查解向量中的值是否超出了物理范围 $[0, 1]$（加上容差），如果超出则判定为出现振荡。\n\n最终的 Python 代码实现了这个逻辑，使用稀疏矩阵来高效地构建和求解线性系统。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, identity\nfrom scipy.sparse.linalg import spsolve\n\ndef run_simulation(kappa, lambda_val, N, dt, T, use_rannacher):\n    \"\"\"\n    Solves the 1D diffusion-reaction equation and detects oscillations.\n\n    Args:\n        kappa (float): Diffusion coefficient.\n        lambda_val (float): Reaction coefficient.\n        N (int): Number of spatial grid points.\n        dt (float): Time step size.\n        T (float): Final time.\n        use_rannacher (bool): Flag to enable/disable Rannacher startup.\n\n    Returns:\n        bool: True if oscillations are detected, False otherwise.\n    \"\"\"\n    # Grid setup\n    dx = 1.0 / (N - 1)\n    M = N - 2  # Number of interior points\n    x_interior = np.linspace(dx, 1.0 - dx, M)\n\n    # Initial condition for interior points: a block function\n    u_current = np.zeros(M)\n    u_current[(x_interior >= 0.25)  (x_interior = 0.75)] = 1.0\n\n    # The maximum principle for this PDE with lambda >= 0 implies the solution\n    # should remain between 0 and 1. We check for violations of this principle beyond a tolerance.\n    oscillation_min_thresh = -1.0e-3\n    oscillation_max_thresh = 1.0 + 1.0e-3\n\n    def check_oscillation(u_vec):\n        return np.min(u_vec)  oscillation_min_thresh or np.max(u_vec) > oscillation_max_thresh\n\n    # Spatial discretization matrix A for u_xx using second-order central differences.\n    # The matrix is of size (M x M) for the M interior points.\n    diagonals = [np.ones(M - 1), -2 * np.ones(M), np.ones(M - 1)]\n    A = diags(diagonals, [-1, 0, 1], shape=(M, M), format='csc') / (dx**2)\n\n    # Full semi-discrete system matrix L = kappa*A - lambda*I\n    Id = identity(M, format='csc')\n    L = kappa * A - lambda_val * Id\n\n    # Time-stepping\n    num_steps = int(round(T / dt))\n    \n    start_step_cn = 0\n    if use_rannacher:\n        # Rannacher startup: two Backward Euler half-steps\n        dt_half = dt / 2.0\n        M_BE_half = Id - dt_half * L\n\n        # First half-step from t=0 to t=dt/2\n        u_half = spsolve(M_BE_half, u_current, use_umfpack=True)\n        if check_oscillation(u_half):\n            return True\n        \n        # Second half-step from t=dt/2 to t=dt\n        u_next = spsolve(M_BE_half, u_half, use_umfpack=True)\n        if check_oscillation(u_next):\n            return True\n        \n        u_current = u_next\n        start_step_cn = 1 # CN loop will start from the second full time step\n    \n    # Crank-Nicolson for the remaining steps\n    M_CN_lhs = Id - (dt / 2.0) * L\n    M_CN_rhs = Id + (dt / 2.0) * L\n    \n    for _ in range(start_step_cn, num_steps):\n        rhs_vector = M_CN_rhs.dot(u_current)\n        u_next = spsolve(M_CN_lhs, rhs_vector, use_umfpack=True)\n        \n        if check_oscillation(u_next):\n            return True\n            \n        u_current = u_next\n\n    return False\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: Stiff reaction, large dt, CN only -> Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n        # Case 2: Stiff reaction, large dt, CN with Rannacher -> Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 400.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': True},\n        # Case 3: No reaction, small dt, CN only -> Expect no oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.0001, 'T': 0.1, 'use_rannacher': False},\n        # Case 4: No reaction, large dt, CN only -> Expect oscillations\n        {'kappa': 1.0, 'lambda_val': 0.0, 'N': 51, 'dt': 0.005, 'T': 0.1, 'use_rannacher': False},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3128239"}, {"introduction": "在编写完数值求解器后，你如何确信代码没有错误且性能符合预期？本练习将介绍“人造解方法”（Method of Manufactured Solutions, MMS），这是科学计算中代码验证的黄金标准。你将为人为设计一个热方程的精确解，从而系统地测试你编写的Crank-Nicolson程序，并正式地验证它是否在时间和空间上都达到了理论上的二阶收敛精度。[@problem_id:3229592]", "problem": "考虑在一维空间区间和有限时间区间上带有人为源项的一维热方程。设热扩散系数为正常数 $\\,\\alpha  0\\,$，并考虑在 $\\,x \\in [0,1]\\,$ 和 $\\,t \\in [0,T]\\,$ 上带有齐次狄利克雷边界条件的问题。使用人为解方法如下。\n\n1. 选择人为解 $\\,u(x,t) = \\exp(t)\\,\\sin(\\pi x)\\,$。定义源项 $\\,f(x,t)\\,$，使得 $\\,u\\,$ 精确满足偏微分方程 $\\,u_t = \\alpha u_{xx} + f\\,$。施加从此 $\\,u\\,$ 导出的初始和边界条件，即对所有 $\\,t\\,$，有 $\\,u(x,0) = \\sin(\\pi x)\\,$ 和 $\\,u(0,t) = u(1,t) = 0\\,$。\n\n2. 将 $\\,[0,1]\\,$ 离散化为 $\\,N_x\\,$ 个等宽子区间，宽度为 $\\,\\Delta x = 1/N_x\\,$，网格点为 $\\,x_i = i\\,\\Delta x\\,$，其中 $\\,i = 0,1,\\dots,N_x\\,$。将 $\\, [0,T]\\,$ 离散化为 $\\,N_t\\,$ 个等长时间步，步长为 $\\,\\Delta t = T/N_t\\,$，时间点为 $\\,t^n = n\\,\\Delta t\\,$，其中 $\\,n = 0,1,\\dots,N_t\\,$。令 $\\,u_i^n \\approx u(x_i,t^n)\\,$ 表示在内部索引 $\\,i = 1,2,\\dots,N_x-1\\,$ 和时间点 $\\,n = 0,1,\\dots,N_t\\,$ 上的数值近似解。\n\n3. 使用 Crank–Nicolson 方法，即时间上的梯形法则结合空间上的二阶中心差分，来离散化内部节点处的热方程。在 $\\,x=0\\,$ 和 $\\,x=1\\,$ 处使用由人为解确定的精确狄利克雷边界值。从精确初始条件 $\\,u_i^0 = \\sin(\\pi x_i)\\,$ 开始进行时间步进。\n\n4. 计算最终时间 $\\,t = T\\,$ 时的离散 $\\,L^2\\,$ 误差，定义为\n$$\nE(N_x,N_t) \\;=\\; \\left( \\Delta x \\sum_{i=0}^{N_x} \\bigl(u_i^{N_t} - u(x_i,T)\\bigr)^2 \\right)^{1/2},\n$$\n约定 $\\,u_0^{N_t} = u_{N_x}^{N_t} = 0\\,$。\n\n您的程序必须通过人为解方法估计观测到的收敛阶，从而验证在时间和空间上的二阶精度。使用以下固定参数和测试套件。\n\n- 使用 $\\,\\alpha = 1\\,$ 和 $\\,T = 0.1\\,$。\n\n- 时间阶测试套件：固定一个足够精细的空间网格 $\\,N_x = 300\\,$，并改变时间步数 $\\,N_t \\in \\{50,100,200,400,800\\}\\,$。对于每个 $\\,N_t\\,$，计算 $\\,E(N_x,N_t)\\,$，然后通过对这五个案例的 $\\,\\log E\\,$ 与 $\\,\\log \\Delta t\\,$（其中 $\\,\\Delta t = T/N_t\\,$）进行最小二乘线性拟合，来估计观测到的时间阶 $\\,p_t\\,$。报告 $\\,p_t\\,$，四舍五入到两位小数。\n\n- 空间阶测试套件：固定一个足够小的时间步长 $\\,N_t = 1000\\,$，并改变空间子区间的数量 $\\,N_x \\in \\{10,20,40,80,160\\}\\,$。对于每个 $\\,N_x\\,$，计算 $\\,E(N_x,N_t)\\,$，然后通过对这五个案例的 $\\,\\log E\\,$ 与 $\\,\\log \\Delta x\\,$（其中 $\\,\\Delta x = 1/N_x\\,$）进行最小二乘线性拟合，来估计观测到的空间阶 $\\,p_x\\,$。报告 $\\,p_x\\,$，四舍五入到两位小数。\n\n- 此外，计算一个布尔通过标志，当且仅当 $\\,p_t \\ge 1.90\\,$ 和 $\\,p_x \\ge 1.90\\,$ 同时成立时，该标志定义为真。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，顺序为 $[p_t,p_x,pass]$。前两个条目必须是四舍五入到两位小数的浮点数，第三个条目必须是布尔字面量，例如 $[1.99,2.01,True]$。", "solution": "用户提供的问题被评估为有效。这是一个在偏微分方程数值分析领域中适定、科学上合理且完整的问题。任务是使用人为解方法来验证 Crank-Nicolson 方法求解一维热方程的收敛阶。\n\n分析和求解过程如下。\n\n首先，我们确定人为解 $u(x,t) = \\exp(t)\\sin(\\pi x)$ 为精确满足控制偏微分方程 (PDE) $u_t = \\alpha u_{xx} + f(x,t)$ 所需的源项 $f(x,t)$。\n\n我们计算 $u(x,t)$ 的偏导数：\n-   关于时间 $t$ 的偏导数是：\n    $$ u_t = \\frac{\\partial}{\\partial t} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\exp(t)\\sin(\\pi x) $$\n-   关于空间 $x$ 的二阶偏导数是：\n    $$ u_x = \\frac{\\partial}{\\partial x} \\left( \\exp(t)\\sin(\\pi x) \\right) = \\pi \\exp(t)\\cos(\\pi x) $$\n    $$ u_{xx} = \\frac{\\partial^2}{\\partial x^2} \\left( \\exp(t)\\sin(\\pi x) \\right) = -\\pi^2 \\exp(t)\\sin(\\pi x) $$\n\n将这些导数代入偏微分方程得到：\n$$ \\exp(t)\\sin(\\pi x) = \\alpha \\left( -\\pi^2 \\exp(t)\\sin(\\pi x) \\right) + f(x,t) $$\n求解源项 $f(x,t)$ 可得：\n$$ f(x,t) = \\exp(t)\\sin(\\pi x) + \\alpha \\pi^2 \\exp(t)\\sin(\\pi x) = (1 + \\alpha \\pi^2) \\exp(t)\\sin(\\pi x) $$\n\n接下来，我们使用 Crank-Nicolson 方法离散化该偏微分方程。空间域 $[0,1]$ 被离散化为 $N_x$ 个宽度为 $\\Delta x = 1/N_x$ 的子区间，时间域 $[0,T]$ 被离散化为 $N_t$ 个步长为 $\\Delta t = T/N_t$ 的时间步。设 $u_i^n$ 为 $u(x_i, t^n)$ 的数值近似值，其中 $x_i = i\\Delta x$ 且 $t^n = n\\Delta t$。\n\nCrank-Nicolson 格式在空间上应用中心差分，在时间上应用梯形法则，两者都在中点 $t^{n+1/2} = t^n + \\Delta t/2$ 处进行计算。这产生了一个在空间和时间上均为二阶精度的格式。在内部网格点 $(x_i, t^{n+1/2})$ 处的离散方程为：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( \\frac{u_{i+1}^{n+1} - 2u_i^{n+1} + u_{i-1}^{n+1}}{(\\Delta x)^2} + \\frac{u_{i+1}^{n} - 2u_i^{n} + u_{i-1}^{n}}{(\\Delta x)^2} \\right) + f(x_i, t^{n+1/2}) $$\n将源项近似为 $f(x_i, t^{n+1/2}) \\approx \\frac{1}{2}(f_i^{n+1} + f_i^n)$，其中 $f_i^n = f(x_i, t^n)$，我们得到：\n$$ \\frac{u_i^{n+1} - u_i^n}{\\Delta t} = \\frac{\\alpha}{2} \\left( D_{xx} u_i^{n+1} + D_{xx} u_i^{n} \\right) + \\frac{1}{2}(f_i^{n+1} + f_i^n) $$\n其中 $D_{xx}$ 代表二阶中心差分算子。\n\n为了求解在时间 $t^{n+1}$ 的未知值，我们重新排列方程，将 $n+1$ 步的项移到左侧 (LHS)，将 $n$ 步的项移到右侧 (RHS)。设 $\\nu = \\frac{\\alpha \\Delta t}{2(\\Delta x)^2}$。每个内部节点 $i \\in \\{1, 2, \\dots, N_x-1\\}$ 的方程变为：\n$$ -\\nu u_{i-1}^{n+1} + (1+2\\nu)u_i^{n+1} - \\nu u_{i+1}^{n+1} = \\nu u_{i-1}^n + (1-2\\nu)u_i^n + \\nu u_{i+1}^n + \\frac{\\Delta t}{2}(f_i^{n+1} + f_i^n) $$\n\n这个包含 $N_x-1$ 个线性方程的系统必须在每个时间步求解。设 $U^n = [u_1^n, u_2^n, \\dots, u_{N_x-1}^n]^T$ 为时间 $t^n$ 时内部节点解的向量。该系统可以写成矩阵形式：\n$$ A U^{n+1} = B U^n + d^n $$\n其中 $A$ 和 $B$ 是 $(N_x-1) \\times (N_x-1)$ 的三对角矩阵：\n$$ A = \\begin{pmatrix} 1+2\\nu  -\\nu  \\\\ -\\nu  1+2\\nu  -\\nu \\\\  \\ddots  \\ddots  \\ddots \\\\   -\\nu  1+2\\nu  -\\nu \\\\    -\\nu  1+2\\nu \\end{pmatrix} $$\n$$ B = \\begin{pmatrix} 1-2\\nu  \\nu  \\\\ \\nu  1-2\\nu  \\nu \\\\  \\ddots  \\ddots  \\ddots \\\\   \\nu  1-2\\nu  \\nu \\\\    \\nu  1-2\\nu \\end{pmatrix} $$\n向量 $d^n$ 包含离散化的源项：\n$$ d^n = \\frac{\\Delta t}{2} [f_1^{n+1}+f_1^n, \\dots, f_{N_x-1}^{n+1}+f_{N_x-1}^n]^T $$\n齐次狄利克雷边界条件 $u(0,t) = u(1,t) = 0$ 意味着对所有 $n$ 都有 $u_0^n = u_{N_x}^n = 0$。这些条件被并入系统中，因为在 $i=1$ 和 $i=N_x-1$ 的模板边界上涉及 $u_0$ 和 $u_{N_x}$ 的项为零。\n\n数值模拟按以下步骤进行：\n1.  使用精确初始条件在 $t=0$ 初始化解：$u_i^0 = u(x_i, 0) = \\sin(\\pi x_i)$，其中 $i=0, \\dots, N_x$。\n2.  对于从 $0$ 到 $N_t-1$ 的每个时间步 $n$：\n    a.  构造右侧向量 $RHS = B U^n + d^n$。\n    b.  求解线性系统 $A U^{n+1} = RHS$ 以获得未知向量 $U^{n+1}$。\n3.  在最后一个时间步之后，得到时间 $T=t^{N_t}$ 的数值解。\n\n误差使用最终时间 $T$ 的离散 $L^2$ 范数计算：\n$$ E(N_x, N_t) = \\left( \\Delta x \\sum_{i=0}^{N_x} (u_i^{N_t} - u(x_i,T))^2 \\right)^{1/2} $$\n由于边界条件是精确施加的，求和中 $i=0$ 和 $i=N_x$ 的项为零。\n\n为了验证精度阶，我们假设误差遵循形式 $E \\approx C (\\Delta x)^{p_x} + D (\\Delta t)^{p_t}$。\n-   对于时间阶测试 ($p_t$)，我们将 $N_x$ 固定在一个较大值 ($N_x=300$)，使得空间误差项可以忽略不计。误差则近似为 $E \\approx D (\\Delta t)^{p_t}$。取对数，我们有 $\\log(E) \\approx \\log(D) + p_t \\log(\\Delta t)$。我们对一系列 $N_t$ 值的点 $(\\log(\\Delta t), \\log(E))$ 进行线性最小二乘拟合。所得直线的斜率即为收敛阶的估计值 $p_t$。\n-   类似地，对于空间阶测试 ($p_x$)，我们将 $N_t$ 固定在一个较大值 ($N_t=1000$)，以使时间误差项可以忽略不计。那么 $E \\approx C (\\Delta x)^{p_x}$，并且 $\\log(E) \\approx \\log(C) + p_x \\log(\\Delta x)$。我们对一系列 $N_x$ 值的点 $(\\log(\\Delta x), \\log(E))$ 进行线性拟合，以找到斜率 $p_x$。\n\n给定的参数是 $\\alpha=1$ 和 $T=0.1$。实现将执行这两项收敛性研究，计算 $p_t$ 和 $p_x$，并根据两个阶数都至少为 $1.90$ 的条件来确定通过/失败标志。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D heat equation with a manufactured solution using the Crank-Nicolson method,\n    and computes the observed orders of convergence in time and space.\n    \"\"\"\n    \n    # --- Fixed Parameters ---\n    alpha = 1.0\n    T = 0.1\n\n    # --- Manufactured Solution and Source Term ---\n    # u(x,t) = exp(t) * sin(pi*x)\n    # f(x,t) = (1 + alpha*pi*pi) * exp(t) * sin(pi*x)\n    \n    def u_exact(x, t):\n        return np.exp(t) * np.sin(np.pi * x)\n\n    def f_source(x, t, alpha_val):\n        return (1.0 + alpha_val * np.pi**2) * np.exp(t) * np.sin(np.pi * x)\n\n    def run_simulation(Nx, Nt, alpha_val, T_final):\n        \"\"\"\n        Runs a single simulation for a given Nx, Nt and returns the L2 error.\n        \"\"\"\n        # Discretization parameters\n        dx = 1.0 / Nx\n        dt = T_final / Nt\n        x = np.linspace(0, 1, Nx + 1)\n        \n        # Grid for interior points\n        x_interior = x[1:Nx]\n\n        # Initial condition\n        u_current = u_exact(x_interior, 0)\n        \n        # Crank-Nicolson matrices A (LHS) and B (RHS) for interior points\n        nu = alpha_val * dt / (2.0 * dx**2)\n        M_interior = Nx - 1\n\n        # Matrix A\n        A = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(A, 1.0 + 2.0 * nu)\n        if M_interior > 1:\n            A_upper = np.diag(-nu * np.ones(M_interior - 1), 1)\n            A_lower = np.diag(-nu * np.ones(M_interior - 1), -1)\n            A += A_upper + A_lower\n\n        # Matrix B\n        B = np.zeros((M_interior, M_interior))\n        np.fill_diagonal(B, 1.0 - 2.0 * nu)\n        if M_interior > 1:\n            B_upper = np.diag(nu * np.ones(M_interior - 1), 1)\n            B_lower = np.diag(nu * np.ones(M_interior - 1), -1)\n            B += B_upper + B_lower\n        \n        # Time-stepping loop\n        for n in range(Nt):\n            t_current = n * dt\n            t_next = (n + 1) * dt\n            \n            # Source term vector\n            f_curr_vals = f_source(x_interior, t_current, alpha_val)\n            f_next_vals = f_source(x_interior, t_next, alpha_val)\n            d = (dt / 2.0) * (f_curr_vals + f_next_vals)\n            \n            # RHS vector\n            rhs = B @ u_current + d\n            \n            # Solve the linear system: A * u_next = rhs\n            u_next = np.linalg.solve(A, rhs)\n            \n            u_current = u_next\n            \n        # At this point, u_current is the numerical solution at t=T\n        u_numerical_final = np.zeros(Nx + 1)\n        u_numerical_final[1:Nx] = u_current\n        \n        # Exact solution at t=T\n        u_exact_final = u_exact(x, T_final)\n        \n        # Compute L2 error\n        error_vec = u_numerical_final - u_exact_final\n        l2_error = np.sqrt(dx * np.sum(error_vec**2))\n        \n        return l2_error\n\n    # --- Temporal Order Test ---\n    Nx_temp_test = 300\n    Nt_temp_list = [50, 100, 200, 400, 800]\n    \n    log_dt_temp = []\n    log_E_temp = []\n    \n    for Nt in Nt_temp_list:\n        error = run_simulation(Nx_temp_test, Nt, alpha, T)\n        dt = T / Nt\n        log_dt_temp.append(np.log(dt))\n        log_E_temp.append(np.log(error))\n        \n    # Least-squares fit to find the slope (order of convergence)\n    p_t = np.polyfit(log_dt_temp, log_E_temp, 1)[0]\n    \n    # --- Spatial Order Test ---\n    Nt_spatial_test = 1000\n    Nx_spatial_list = [10, 20, 40, 80, 160]\n    \n    log_dx_spatial = []\n    log_E_spatial = []\n    \n    for Nx in Nx_spatial_list:\n        error = run_simulation(Nx, Nt_spatial_test, alpha, T)\n        dx = 1.0 / Nx\n        log_dx_spatial.append(np.log(dx))\n        log_E_spatial.append(np.log(error))\n        \n    # Least-squares fit to find the slope\n    p_x = np.polyfit(log_dx_spatial, log_E_spatial, 1)[0]\n    \n    # --- Pass Flag ---\n    pass_flag = (p_t >= 1.90) and (p_x >= 1.90)\n    \n    # --- Final Output ---\n    # Format: [p_t (2dp), p_x (2dp), pass_flag]\n    print(f\"[{p_t:.2f},{p_x:.2f},{pass_flag}]\")\n\nsolve()\n\n```", "id": "3229592"}]}