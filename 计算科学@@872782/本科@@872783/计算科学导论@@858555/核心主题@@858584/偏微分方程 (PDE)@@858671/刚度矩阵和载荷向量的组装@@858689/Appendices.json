{"hands_on_practices": [{"introduction": "有限元分析的精髓在于将复杂的大型系统分解为简单、可管理的小块，即“单元”。第一个练习将带你深入这一过程的核心：为单个单元计算刚度矩阵。通过解析推导和数值积分两种方式计算矩阵中的一个元素，你将巩固对弱形式、形函数以及坐标变换如何共同定义单元属性的理解。[@problem_id:3098496]", "problem": "考虑一个矩形域上的稳态扩散模型 $-\\nabla \\cdot (A \\nabla u) = f$，并着重于使用有限元法（FEM）组装单元刚度矩阵。对于一个物理坐标为顶点在 $(0,0)$、$(2,0)$、$(2,1)$ 和 $(0,1)$ 的矩形的4节点双线性四边形单元，设材料传导率张量为 $A = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$。从参考正方形 $[-1,1] \\times [-1,1]$ 出发的单元映射由 $x(\\xi,\\eta) = 1 + \\xi$ 和 $y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta$ 给出。参考正方形上的标准双线性形函数为\n$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta)$, $N_2(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1-\\eta)$, $N_3(\\xi,\\eta) = \\tfrac{1}{4}(1+\\xi)(1+\\eta)$, 以及 $N_4(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1+\\eta)$。\n\n从单元刚度矩阵的弱形式定义出发，其第 $(i,j)$ 个元素为\n$$K_{e,ij} = \\int_{\\Omega_e} \\nabla N_i(x,y)^{\\top} A \\, \\nabla N_j(x,y) \\, \\mathrm{d}\\Omega,$$\n其中 $\\Omega_e$ 是物理单元域。仅使用上述核心定义，完成以下所有任务：\n- 通过将积分映射到参考域并应用梯度的链式法则，解析推导对角线元素 $K_{e,11}$ 的值。\n- 在参考正方形上使用每方向2点的张量积高斯求积（使用标准求积点 $\\xi, \\eta = \\pm 1/\\sqrt{3}$ 和权重 $w_{\\xi} = w_{\\eta} = 1$）数值组装 $K_{e,11}$，包括雅可比行列式因子，并证明其与您的解析结果相符。\n\n报告单个实数 $K_{e,11}$。答案中无需四舍五入，也无需包含单位。", "solution": "我们从单元刚度矩阵元素的弱形式定义开始：\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1(x,y)^{\\top} A \\, \\nabla N_1(x,y)\\, \\mathrm{d}\\Omega.$$\n我们将解析地计算 $K_{e,11}$，然后在参考正方形上通过数值求积进行验证以确保一致。\n\n解析推导：\n从参考坐标 $(\\xi,\\eta)$ 到物理坐标 $(x,y)$ 的映射为\n$$x(\\xi,\\eta) = 1 + \\xi,\\qquad y(\\xi,\\eta) = \\tfrac{1}{2} + \\tfrac{1}{2}\\eta.$$\n该映射的雅可比矩阵为\n$$J = \\begin{pmatrix} \\dfrac{\\partial x}{\\partial \\xi} & \\dfrac{\\partial x}{\\partial \\eta} \\\\ \\dfrac{\\partial y}{\\partial \\xi} & \\dfrac{\\partial y}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & \\tfrac{1}{2} \\end{pmatrix},\\quad \\det(J) = \\tfrac{1}{2}.$$\n梯度变换遵循 $\\nabla_{x} N = J^{-T} \\nabla_{\\xi} N$，因此\n$$J^{-T} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix},\\qquad \\nabla_{x} N_1 = \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial x} \\\\ \\dfrac{\\partial N_1}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} 1 & 0 \\\\ 0 & 2 \\end{pmatrix} \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial \\xi} \\\\ \\dfrac{\\partial N_1}{\\partial \\eta} \\end{pmatrix} = \\begin{pmatrix} \\dfrac{\\partial N_1}{\\partial \\xi} \\\\ 2 \\dfrac{\\partial N_1}{\\partial \\eta} \\end{pmatrix}.$$\n对于双线性形函数\n$$N_1(\\xi,\\eta) = \\tfrac{1}{4}(1-\\xi)(1-\\eta),$$\n其导数为\n$$\\dfrac{\\partial N_1}{\\partial \\xi} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\dfrac{\\partial N_1}{\\partial \\eta} = -\\tfrac{1}{4}(1-\\xi).$$\n因此，在物理坐标系中，\n$$\\dfrac{\\partial N_1}{\\partial x} = -\\tfrac{1}{4}(1-\\eta),\\qquad \\dfrac{\\partial N_1}{\\partial y} = 2\\left(-\\tfrac{1}{4}(1-\\xi)\\right) = -\\tfrac{1}{2}(1-\\xi).$$\n当 $A = \\begin{pmatrix} 2 & 0 \\\\ 0 & 1 \\end{pmatrix}$ 时，被积函数变为\n$$\\nabla N_1^{\\top} A \\nabla N_1 = 2\\left(\\dfrac{\\partial N_1}{\\partial x}\\right)^{2} + 1\\left(\\dfrac{\\partial N_1}{\\partial y}\\right)^{2} = 2\\left(\\tfrac{(1-\\eta)^{2}}{16}\\right) + \\left(\\tfrac{(1-\\xi)^{2}}{4}\\right) = \\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}.$$\n将积分变换到参考域可得\n$$K_{e,11} = \\int_{\\Omega_e} \\nabla N_1^{\\top} A \\nabla N_1 \\, \\mathrm{d}\\Omega = \\int_{-1}^{1}\\int_{-1}^{1} \\left(\\tfrac{(1-\\eta)^{2}}{8} + \\tfrac{(1-\\xi)^{2}}{4}\\right) \\det(J)\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta.$$\n由于 $\\det(J) = \\tfrac{1}{2}$，\n$$K_{e,11} = \\tfrac{1}{2} \\left[ \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta + \\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta \\right].$$\n分别计算积分：\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\left( \\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\xi \\right),$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\left( \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi \\right)\\left( \\int_{-1}^{1} \\mathrm{d}\\eta \\right).$$\n计算一维积分：\n$$\\int_{-1}^{1} (1-\\eta)^{2}\\, \\mathrm{d}\\eta = \\int_{-1}^{1} (1 - 2\\eta + \\eta^{2})\\, \\mathrm{d}\\eta = \\left[\\eta - \\eta^{2} + \\tfrac{\\eta^{3}}{3}\\right]_{-1}^{1} = \\tfrac{8}{3},$$\n$$\\int_{-1}^{1} \\mathrm{d}\\xi = 2,\\qquad \\int_{-1}^{1} (1-\\xi)^{2}\\, \\mathrm{d}\\xi = \\tfrac{8}{3},\\qquad \\int_{-1}^{1} \\mathrm{d}\\eta = 2.$$\n因此，\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\eta)^{2}}{8}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{8}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{2}{3},$$\n$$\\int_{-1}^{1}\\int_{-1}^{1} \\tfrac{(1-\\xi)^{2}}{4}\\, \\mathrm{d}\\xi\\, \\mathrm{d}\\eta = \\tfrac{1}{4}\\cdot \\tfrac{8}{3}\\cdot 2 = \\tfrac{4}{3}.$$\n于是\n$$K_{e,11} = \\tfrac{1}{2}\\left( \\tfrac{2}{3} + \\tfrac{4}{3} \\right) = \\tfrac{1}{2}\\cdot \\tfrac{6}{3} = \\tfrac{1}{2}\\cdot 2 = 1.$$\n\n数值求积验证：\n在 $[-1,1]$ 上每个方向使用2点高斯求积，求积点为 $\\xi,\\eta = \\pm \\tfrac{1}{\\sqrt{3}}$，权重为 $w_{\\xi} = w_{\\eta} = 1$，根据张量积法则可得\n$$K_{e,11}^{\\text{(quad)}} = \\det(J)\\sum_{k=1}^{2}\\sum_{\\ell=1}^{2} w_{\\xi_k} w_{\\eta_{\\ell}} \\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right].$$\n因为 $w_{\\xi_k} = w_{\\eta_{\\ell}} = 1$，我们可以分离求和：\n$$\\sum_{\\ell=1}^{2} (1-\\eta_{\\ell})^{2} = \\left(1 - \\tfrac{1}{\\sqrt{3}}\\right)^{2} + \\left(1 + \\tfrac{1}{\\sqrt{3}}\\right)^{2} = \\left(1 - \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) + \\left(1 + \\tfrac{2}{\\sqrt{3}} + \\tfrac{1}{3}\\right) = 2 + \\tfrac{2}{3} = \\tfrac{8}{3},$$\n$$\\sum_{k=1}^{2} (1-\\xi_{k})^{2} = \\tfrac{8}{3},\\qquad \\sum_{k=1}^{2} 1 = 2,\\qquad \\sum_{\\ell=1}^{2} 1 = 2.$$\n因此，\n$$\\sum_{k,\\ell}\\left[ \\tfrac{(1-\\eta_{\\ell})^{2}}{8} + \\tfrac{(1-\\xi_{k})^{2}}{4} \\right] = \\tfrac{1}{8}\\left(\\tfrac{8}{3}\\right)\\cdot 2 + \\tfrac{1}{4}\\left(\\tfrac{8}{3}\\right)\\cdot 2 = \\tfrac{2}{3} + \\tfrac{4}{3} = 2.$$\n乘以 $\\det(J) = \\tfrac{1}{2}$ 得到\n$$K_{e,11}^{\\text{(quad)}} = \\tfrac{1}{2}\\cdot 2 = 1.$$\n因此，使用 $2\\times 2$ 高斯求积的数值组装结果与解析值完全匹配。\n\n所以，所求的元素为\n$$K_{e,11} = 1.$$", "answer": "$$\\boxed{1}$$", "id": "3098496"}, {"introduction": "掌握了单个单元的计算后，下一步是将其组装成一个全局系统。这个过程不仅仅是数值的累加，更关键的是要正确地反映单元之间的物理连接。本练习将探讨一种常见的网格数据错误——重复定义节点——它会导致系统中出现不连续的“浮动”组件。你将学习如何通过分析最终组装的全局刚度矩阵的数学特性（特别是其零空间维度或称“零度”）来诊断这类问题。[@problem_id:3098508]", "problem": "考虑区间 $[0,1]$ 上的一维稳态扩散问题：求解 $u$ 使得\n$$- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x),$$\n其中 $a$ 是一个正标量扩散系数，$f(x)$ 是给定的源项。使用伽辽金有限元法，在由点坐标和双节点单元定义的网格上，采用连续分段线性基函数。您将根据从弱形式推导出的单元贡献来组装全局刚度矩阵 $K$ 和载荷向量 $F$。通过在共享的物理顶点处复制自由度（DOF）索引，在一些测试网格中故意引入一个缺陷，以创建不连通的组件。在施加狄利克雷边界条件后，通过检查限制在未知自由度上的组装矩阵 $K$ 的奇异性（秩亏）来检测此缺陷。\n\n从弱形式和标准线性“帽”函数的定义出发，推导单元刚度矩阵和一致的单元载荷规则。实现一个组装程序，该程序：\n- 从所有单元构建全局刚度矩阵 $K$ 和载荷向量 $F$。\n- 通过消除 $K$ 中相应的行和列以及 $F$ 中的相应条目，施加齐次狄利克雷边界条件（即，在指定的自由度上 $u=0$）。\n- 通过计算约减后的对称矩阵的近零特征值数量（零度）来检测奇异性。如果一个矩阵的特征值大小小于一个与最大特征值成比例的容差，则认为该矩阵有一个零特征值。\n\n使用 $a=1$ 和 $f(x)=x$。几何形状是无量纲的，不需要物理单位。网格由以下方式表示：\n- 自由度位置 $x_i$ 的坐标数组。\n- 单元连接列表，由数对 $(i,j)$ 组成，每个数对引用坐标数组中的自由度索引。\n\n您的程序必须处理以下网格和边界条件集的测试套件，并为每个案例输出其零度（近零特征值的整数计数）：\n\n- 测试用例 1（正常情况，正确组装）：\n  - 坐标：$[0,\\,0.5,\\,1]$。\n  - 单元：$(0,1)$ 和 $(1,2)$。\n  - 狄利克雷集：$\\{0\\}$。\n  - 预期行为：约减后的 $K$ 矩阵应为正定矩阵，零度为 $0$。\n\n- 测试用例 2（有缺陷的网格，共享顶点重复，导致出现未固定的组件）：\n  - 坐标：$[0,\\,0.5,\\,0.5,\\,1]$（位于 $x=0.5$ 的中间顶点由两个不同的自由度表示）。\n  - 单元：$(0,1)$ 和 $(2,3)$。\n  - 狄利克雷集：$\\{0\\}$。\n  - 预期行为：由于存在一个未固定的不连通组件，约减后的 $K$ 矩阵应为奇异矩阵，零度为 $1$。\n\n- 测试用例 3（有缺陷的网格，但完全固定）：\n  - 坐标：$[0,\\,0.5,\\,0.5,\\,1]$。\n  - 单元：$(0,1)$ 和 $(2,3)$。\n  - 狄利克雷集：$\\{0,\\,3\\}$。\n  - 预期行为：由于所有组件都由狄利克雷条件固定，约减后的 $K$ 矩阵应为正定矩阵，零度为 $0$。\n\n- 测试用例 4（有缺陷的网格，无狄利克雷条件，多个浮动组件）：\n  - 坐标：$[0,\\,0.5,\\,0.5,\\,1]$。\n  - 单元：$(0,1)$ 和 $(2,3)$。\n  - 狄利克雷集：$\\{\\}$。\n  - 预期行为：约减后的 $K$ 矩阵应为奇异矩阵，零度为 $2$（每个不连通的组件对应一个刚体模态）。\n\n最终输出格式要求：\n- 您的程序应生成单行输出，其中包含按上述顺序列出的测试用例的结果，形式为方括号内的逗号分隔列表。例如，$[n_1,n_2,n_3,n_4]$，其中每个 $n_k$ 是测试用例 $k$ 的整数零度。", "solution": "本任务旨在使用有限元方法（FEM）对一维稳态扩散问题进行数值分析。我们必须推导单元矩阵，实现一个组装过程，然后使用组装后刚度矩阵的特征值分析来检测一种特定类型的网格缺陷：由重复的自由度（DOF）导致的不连通组件。\n\n控制微分方程是区间 $[0,1]$ 上的一维扩散方程：\n$$\n- \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) = f(x)\n$$\n其中 $u(x)$ 是未知函数，$a$ 是扩散系数（给定为 $a=1$），$f(x)$ 是源项（给定为 $f(x)=x$）。\n\n**1. 弱形式**\n\n为了推导弱形式，我们将控制方程乘以一个合适的检验函数 $v(x)$，并在定义域 $\\Omega = [0,1]$ 上进行积分。\n$$\n- \\int_{0}^{1} v \\frac{d}{dx}\\left(a \\frac{du}{dx}\\right) dx = \\int_{0}^{1} v f(x) dx\n$$\n对左侧项应用分部积分：\n$$\n\\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx - \\left[ v a \\frac{du}{dx} \\right]_{0}^{1} = \\int_{0}^{1} v f(x) dx\n$$\n项 $\\left[ v a \\frac{du}{dx} \\right]_{0}^{1}$ 代表自然（诺伊曼）边界条件。对于本问题，我们施加的是狄利克雷边界条件，因此我们选择在狄利克雷边界上为零的检验函数 $v(x)$。这使得边界项消失。\n\n弱形式为：求解 $u \\in V$，使得对于所有 $v \\in \\hat{V}$：\n$$\nB(v, u) = L(v)\n$$\n其中 $V$ 是试探函数空间，$\\hat{V}$ 是检验函数空间。双线性形式 $B(v, u)$ 和线性泛函 $L(v)$ 定义如下：\n$$\nB(v, u) = \\int_{0}^{1} a \\frac{dv}{dx} \\frac{du}{dx} dx\n$$\n$$\nL(v) = \\int_{0}^{1} v(x) f(x) dx\n$$\n\n**2. 有限元离散化**\n\n我们将定义域 $[0,1]$ 离散化为单元网格。解 $u(x)$ 通过分段线性基函数 $\\phi_j(x)$（通常称为“帽”函数）的线性组合来近似：\n$$\nu_h(x) = \\sum_{j=1}^{N_{dof}} U_j \\phi_j(x)\n$$\n这里，$N_{dof}$ 是自由度（节点）的总数，$U_j$ 是解的未知节点值。基函数 $\\phi_j(x)$ 具有在节点 $j$ 处等于 $1$ 并在所有其他节点处等于 $0$ 的特性。\n\n在伽辽金方法中，检验函数 $v(x)$ 从与基函数相同的空间中选取，即对于 $i=1, \\dots, N_{dof}$，$v = \\phi_i(x)$。将此代入弱形式，得到一个线性方程组 $KU=F$，其中：\n- $K_{ij} = B(\\phi_i, \\phi_j) = \\int_{0}^{1} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$ 是全局刚度矩阵。\n- $F_i = L(\\phi_i) = \\int_{0}^{1} \\phi_i(x) f(x) dx$ 是全局载荷向量。\n\n**3. 单元矩阵推导**\n\n全局矩阵由每个单元的贡献组装而成。我们考虑一个连接坐标 $x_A$ 处的节点 $A$ 和坐标 $x_B$ 处的节点 $B$ 的通用单元 $e$。单元长度为 $h_e = x_B - x_A$。在此单元内，只有两个基函数 $\\phi_A(x)$ 和 $\\phi_B(x)$ 是非零的。\n\n单元上的局部基函数为：\n$$\n\\phi_A(x) = \\frac{x_B - x}{h_e} \\quad \\text{和} \\quad \\phi_B(x) = \\frac{x - x_A}{h_e}\n$$\n它们的导数在整个单元上是常数：\n$$\n\\frac{d\\phi_A}{dx} = -\\frac{1}{h_e} \\quad \\text{和} \\quad \\frac{d\\phi_B}{dx} = \\frac{1}{h_e}\n$$\n\n**单元刚度矩阵 $k^e$**：\n这个 $2 \\times 2$ 的单元刚度矩阵 $k^e$ 的项为 $k^e_{ij} = \\int_{x_A}^{x_B} a \\frac{d\\phi_i}{dx} \\frac{d\\phi_j}{dx} dx$。给定 $a=1$：\n$$\nk^e_{11} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(-\\frac{1}{h_e}\\right) dx = \\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = \\frac{h_e}{h_e^2} = \\frac{1}{h_e}\n$$\n$$\nk^e_{12} = \\int_{x_A}^{x_B} 1 \\cdot \\left(-\\frac{1}{h_e}\\right) \\left(\\frac{1}{h_e}\\right) dx = -\\frac{1}{h_e^2} \\int_{x_A}^{x_B} dx = -\\frac{1}{h_e}\n$$\n根据对称性，$k^e_{21} = k^e_{12} = -1/h_e$，且 $k^e_{22} = 1/h_e$。因此，单元刚度矩阵为：\n$$\nk^e = \\frac{1}{h_e} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}\n$$\n\n**单元载荷向量 $f^e$**：\n对于源项 $f(x)=x$，单元载荷向量 $f^e$ 的项为 $f^e_i = \\int_{x_A}^{x_B} x \\cdot \\phi_i(x) dx$。\n$$\nf^e_1 = \\int_{x_A}^{x_B} x \\left(\\frac{x_B - x}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ x_B \\frac{x^2}{2} - \\frac{x^3}{3} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(2x_A + x_B)\n$$\n$$\nf^e_2 = \\int_{x_A}^{x_B} x \\left(\\frac{x - x_A}{h_e}\\right) dx = \\frac{1}{h_e} \\left[ \\frac{x^3}{3} - x_A \\frac{x^2}{2} \\right]_{x_A}^{x_B} = \\frac{h_e}{6}(x_A + 2x_B)\n$$\n所以，对于 $f(x)=x$ 的一致单元载荷向量为：\n$$\nf^e = \\frac{h_e}{6} \\begin{pmatrix} 2x_A + x_B \\\\ x_A + 2x_B \\end{pmatrix}\n$$\n\n**4. 组装与边界条件**\n\n组装过程包括遍历每个单元，计算其 $k^e$ 和 $f^e$，并将其值加到全局矩阵 $K$ 和 $F$ 的适当位置，这个过程将局部单元节点映射到全局自由度索引。\n\n组装完成后，施加齐次狄利克雷边界条件（对于给定集合中的自由度 $k$，$u_k=0$）。为了分析矩阵的奇异性，我们关心的是与*未知*自由度对应的系统。设 $I$ 是未知自由度的索引集。我们通过仅选择 $K$ 中与 $I$ 中索引对应的行和列，来构建一个约减刚度矩阵 $K_{red}$。\n\n**5. 奇异性检测**\n\n对于一个没有任何狄利克雷边界条件的扩散问题，其刚度矩阵 $K$ 总是奇异的（对于连通网格，其零度为 $1$，对应于一个常数“刚体”模态）。在一个节点上施加狄利克雷条件会“锚定”解，并使得对应于其余未知量的约减矩阵变为非奇异（正定），前提是网格是连通的。\n\n本问题引入了一个缺陷，即一个物理上连通的网格在数据结构中被表示为不连通的组件（例如，坐标为 $[0, 0.5, 0.5, 1]$，单元为 $(0,1), (2,3)$）。这会创建两个独立的图。每个未被狄利克雷边界条件锚定的不连通组件都会对刚度矩阵贡献一个刚体模态，即一个零特征值。约减矩阵 $K_{red}$ 的零度（零空间的维度）就是这种未锚定组件的数量。\n\n我们可以通过计算 $K_{red}$ 的数值上为零的特征值的数量来计算零度。由于 $K_{red}$ 是对称半正定矩阵，其特征值是实数且非负。我们计算所有特征值，并统计其中绝对值小于某个容差（定义为最大特征值绝对值的一个小分数，例如 $|\\lambda_i| < 10^{-12} |\\lambda_{\\max}|$）的特征值的数量。这个数量就是 $K_{red}$ 的零度。", "answer": "```python\nimport numpy as np\n\ndef assemble_and_check(coords, elements, dirichlet_dofs):\n    \"\"\"\n    Assembles the stiffness matrix and load vector for a 1D diffusion problem,\n    imposes Dirichlet boundary conditions, and computes the nullity of the\n    reduced stiffness matrix.\n\n    Args:\n        coords (list or np.ndarray): Nodal coordinates.\n        elements (list of tuples): Element connectivity (pairs of DOF indices).\n        dirichlet_dofs (set): Set of DOF indices with Dirichlet boundary conditions.\n\n    Returns:\n        int: The nullity of the reduced stiffness matrix.\n    \"\"\"\n    n_dofs = len(coords)\n    K = np.zeros((n_dofs, n_dofs))\n    # The load vector F is not required for singularity check but is assembled for completeness.\n    F = np.zeros(n_dofs)\n    \n    # Constant diffusion coefficient\n    a = 1.0\n\n    # Assembly loop\n    for elem in elements:\n        dof1, dof2 = elem\n        x1, x2 = coords[dof1], coords[dof2]\n        \n        # Ensure h is positive, although order doesn't matter for stiffness matrix.\n        h = abs(x2 - x1)\n        if h  1e-15:\n            # Avoid division by zero for zero-length elements, though not in test cases.\n            continue\n            \n        # Elemental stiffness matrix for a=1\n        k_elem = (a / h) * np.array([[1.0, -1.0], [-1.0, 1.0]])\n\n        # Elemental load vector for f(x)=x\n        # f_elem = (h/6) * [2*x_A + x_B, x_A + 2*x_B]\n        # Use min/max to ensure x_A  x_B for the formula\n        x_A, x_B = min(x1, x2), max(x1, x2)\n        f_elem_vals = (h / 6.0) * np.array([2 * x_A + x_B, x_A + 2 * x_B])\n        # The order of f_elem must match the dof order in the element tuple\n        if x1 > x2:\n            f_elem = np.array([f_elem_vals[1], f_elem_vals[0]])\n        else:\n            f_elem = f_elem_vals\n        \n        # Add to global matrices\n        ix = np.ix_([dof1, dof2], [dof1, dof2])\n        K[ix] += k_elem\n        F[[dof1, dof2]] += f_elem\n\n    # Identify unknown DOFs\n    all_dofs = set(range(n_dofs))\n    unknown_dofs = sorted(list(all_dofs - set(dirichlet_dofs)))\n\n    if not unknown_dofs:\n        return 0 # No unknown DOFs, reduced matrix is empty, nullity is 0.\n    \n    # Extract reduced stiffness matrix\n    K_reduced = K[np.ix_(unknown_dofs, unknown_dofs)]\n    \n    if K_reduced.shape[0] == 0:\n        return 0\n\n    # Compute eigenvalues of the symmetric reduced matrix\n    eigenvalues = np.linalg.eigh(K_reduced)[0]\n    \n    # Determine the tolerance for a \"zero\" eigenvalue\n    max_eig_abs = np.max(np.abs(eigenvalues)) if eigenvalues.size > 0 else 0.0\n    \n    # If the largest eigenvalue is itself near zero, all are zero.\n    # The tolerance must be absolute in this case.\n    if max_eig_abs  1e-12:\n        return K_reduced.shape[0]\n\n    # Relative tolerance based on the largest eigenvalue\n    tolerance = max_eig_abs * 1e-12\n    \n    # Count eigenvalues smaller than the tolerance\n    nullity = np.sum(np.abs(eigenvalues)  tolerance)\n    \n    return int(nullity)\n\ndef solve():\n    \"\"\"\n    Runs the test suite and prints the results.\n    \"\"\"\n    # Test case 1 (happy path, correct assembly)\n    test_case_1 = {\n        \"coords\": [0.0, 0.5, 1.0],\n        \"elements\": [(0, 1), (1, 2)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 2 (buggy mesh with duplicated shared vertex, causing an unanchored component)\n    test_case_2 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0}\n    }\n\n    # Test case 3 (buggy mesh but fully anchored)\n    test_case_3 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": {0, 3}\n    }\n\n    # Test case 4 (buggy mesh with no Dirichlet conditions, multiple floating components)\n    test_case_4 = {\n        \"coords\": [0.0, 0.5, 0.5, 1.0],\n        \"elements\": [(0, 1), (2, 3)],\n        \"dirichlet_dofs\": set()\n    }\n    \n    test_cases = [test_case_1, test_case_2, test_case_3, test_case_4]\n    \n    results = []\n    for case in test_cases:\n        nullity = assemble_and_check(\n            case[\"coords\"], case[\"elements\"], case[\"dirichlet_dofs\"]\n        )\n        results.append(nullity)\n        \n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3098508"}, {"introduction": "正确组装刚度矩阵只是求解问题的第一步。对于大规模问题，高效地求解由此产生的线性系统至关重要。稀疏矩阵的结构——特别是其带宽和在分解过程中产生的“填充”（fill-in）——极大地影响着求解器的性能。最后一个练习将向你展示，不同的节点编号策略（例如，自然顺序与先进的Cuthill-McKee算法）如何重塑矩阵的稀疏模式，为你提供关于计算性能优化的重要一课。[@problem_id:3098591]", "problem": "考虑单位正方形上的标量泊松问题，其具有齐次狄利克雷边界条件：求 $u$ 使得\n$$\n-\\nabla \\cdot \\left(\\nabla u\\right) = g \\quad \\text{in } \\Omega = [0,1]\\times[0,1], \\qquad u = 0 \\quad \\text{on } \\partial \\Omega,\n$$\n其中 $g(x,y) \\equiv 1$。其弱形式为：求 $u \\in H_0^1(\\Omega)$，使得对于所有 $v \\in H_0^1(\\Omega)$，\n$$\n\\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega = \\int_{\\Omega} g \\, v \\, \\mathrm{d}\\Omega.\n$$\n使用 $\\Omega$ 三角剖分上的连续分段线性 Lagrange 基函数，通过有限元展开 $u_h(x,y) = \\sum_{i=1}^{N} U_i \\, \\varphi_i(x,y)$ 来近似 $u$，其中 $N$ 是内部节点的数量（即不在 $\\partial \\Omega$ 上的节点），而 $\\varphi_i$ 是与这些内部节点相关联的节点基函数。得到的线性系统形式为\n$$\nK \\, U = f,\n$$\n其中刚度矩阵项和载荷向量项定义为\n$$\nK_{ij} = \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}\\Omega, \\qquad f_i = \\int_{\\Omega} g \\, \\varphi_i \\, \\mathrm{d}\\Omega.\n$$\n你将在非均匀结构化三角剖分上组装 $K$ 和 $f$。该三角剖分是通过幂律坐标变换从均匀张量积网格映射生成的。具体来说，设 $N_x$ 和 $N_y$ 为正整数。通过 $\\xi_i = i/N_x$ 定义网格点 $\\{\\xi_i\\}_{i=0}^{N_x}$，通过 $\\eta_j = j/N_y$ 定义网格点 $\\{\\eta_j\\}_{j=0}^{N_y}$。对于正常实数参数 $\\alpha$ 和 $\\beta$，非均匀节点坐标定义为\n$$\nx_i = \\xi_i^{\\alpha}, \\quad i = 0,1,\\dots,N_x, \\qquad y_j = \\eta_j^{\\beta}, \\quad j=0,1,\\dots,N_y.\n$$\n通过沿从 $(x_i,y_j)$ 到 $(x_{i+1},y_{j+1})$ 的对角线将每个四边形单元 $\\bigl([x_i,x_{i+1}]\\times[y_j,y_{j+1}]\\bigr)$ 分割成两个三角形来形成三角剖分。通过舍弃所有节点位于 $\\partial \\Omega$ 上的基函数（即仅保留内部节点）来施加边界条件 $u=0$，并基于这些内部节点组装降阶系统 $K \\in \\mathbb{R}^{N \\times N}$ 和 $f \\in \\mathbb{R}^{N}$。\n\n你的任务是：\n- 使用线性三角形有限元，为所述的非均匀三角剖分和源 $g(x,y)=1$ 组装全局刚度矩阵 $K$ 和载荷向量 $f$。\n- 比较内部节点上的两种节点排序策略：\n  1. 自然字典序：按 $(i,j)$ 对节点进行排序，其中 $i$ 增长最快，即在限制到内部节点之前，索引为 $i + j (N_x+1)$，然后进行限制。\n  2. 逆 Cuthill–McKee (RCM) 排序：计算使 $K$ 的图的近似带宽最小化的置换，并将其应用于对称地置换 $K$。\n- 对于每种排序，计算以下两个量化指标：\n  1. 矩阵 $A$ 的半带宽，定义为 $b(A) = \\max\\{ |i-j| : A_{ij} \\neq 0\\}$。\n  2. 分解过程中的一个填充度量，定义为\n     $$\n     F(A) = \\operatorname{nnz}(L) + \\operatorname{nnz}(U) - \\operatorname{nnz}(A),\n     $$\n     其中 $L$ 和 $U$ 来自于 $A$ 的稀疏 LU 分解，分解时禁用列置换，并将对角主元阈值设为零，$\\operatorname{nnz}(\\cdot)$ 表示存储的非零项数量。所有情况都使用相同的分解设置，以便 $F(A)$ 在不同排序之间具有可比性。\n  \n设计并实现一个完整的、可运行的程序，为以下参数集 $(N_x,N_y,\\alpha,\\beta)$ 的测试套件执行组装和排序比较：\n- 情况 1：$(N_x,N_y,\\alpha,\\beta) = (8,8,2,1)$。\n- 情况 2：$(N_x,N_y,\\alpha,\\beta) = (2,2,1.5,1.2)$。\n- 情况 3：$(N_x,N_y,\\alpha,\\beta) = (12,7,3,0.5)$。\n\n对于每种情况，按以下顺序生成四个整数：\n- $b(K_{\\text{nat}})$, $F(K_{\\text{nat}})$, $b(K_{\\text{rcm}})$, $F(K_{\\text{rcm}})$,\n其中 $K_{\\text{nat}}$ 是自然排序下的降阶刚度矩阵，而 $K_{\\text{rcm}}$ 是由其稀疏图计算出的逆 Cuthill–McKee 置换对称置换后的同一矩阵。\n\n你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，结果按测试用例的顺序连接。例如，输出格式必须是\n$$\n[\\,b_1,F_1,b_1',F_1',b_2,F_2,b_2',F_2',b_3,F_3,b_3',F_3'\\,],\n$$\n其中 $b_k$ 和 $F_k$ 表示情况 $k$ 中自然排序的半带宽和填充量，而 $b_k'$ 和 $F_k'$ 表示情况 $k$ 中逆 Cuthill–McKee 排序的相应量。所有报告的量都必须是整数。", "solution": "用户希望我解决一个独立的、有效的问题，该问题涉及组装有限元刚度矩阵，并分析其在不同节点排序下的稀疏模式。\n\n### 1. 问题描述与离散化\n问题是在单位正方形 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程的解 $u$：\n$$-\\nabla \\cdot \\left(\\nabla u\\right) = g \\quad \\text{in } \\Omega,$$\n源项为常数 $g(x,y) = 1$，边界 $\\partial \\Omega$ 上施加齐次狄利克雷边界条件 $u = 0$。\n\n采用有限元法（FEM）进行离散化。起点是问题的弱形式：求 $u \\in H_0^1(\\Omega)$，使得对于所有测试函数 $v \\in H_0^1(\\Omega)$，\n$$a(u,v) = L(v) \\quad \\text{其中} \\quad a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\, \\mathrm{d}\\Omega \\quad \\text{且} \\quad L(v) = \\int_{\\Omega} g \\, v \\, \\mathrm{d}\\Omega.$$\n解 $u$ 由一个有限维空间中的函数 $u_h$ 近似，该空间由连续分段线性 Lagrange 基函数 $\\{\\varphi_i\\}_{i=1}^N$ 张成。近似解写成线性组合 $u_h(x,y) = \\sum_{j=1}^{N} U_j \\, \\varphi_j(x,y)$，其中 $U_j$ 是未知系数（节点上 $u$ 的近似值），$N$ 是自由度的数量。由于 $\\partial\\Omega$ 上的齐次狄利克雷条件 $u=0$，我们只考虑与网格内部节点相关的基函数 $\\varphi_i$。\n\n将 $u_h$ 代入弱形式，并选择基函数本身作为测试函数（$v = \\varphi_i$），我们得到一个线性方程组 $K U = f$，其中：\n- $U \\in \\mathbb{R}^N$ 是未知系数向量。\n- $K \\in \\mathbb{R}^{N \\times N}$ 是刚度矩阵，其项为 $K_{ij} = a(\\varphi_j, \\varphi_i) = \\int_{\\Omega} \\nabla \\varphi_i \\cdot \\nabla \\varphi_j \\, \\mathrm{d}\\Omega$。\n- $f \\in \\mathbb{R}^N$ 是载荷向量，其项为 $f_i = L(\\varphi_i) = \\int_{\\Omega} g \\, \\varphi_i \\, \\mathrm{d}\\Omega$。\n\n### 2. 网格生成\n区域 $\\Omega$ 使用结构化但非均匀的三角剖分进行离散。网格节点 $(x_i, y_j)$ 是通过从逻辑空间 $(\\xi, \\eta)$ 中的均匀网格进行幂律映射生成的：\n- 均匀网格节点：$\\xi_i = i/N_x$ (对于 $i \\in \\{0, 1, \\dots, N_x\\}$) 和 $\\eta_j = j/N_y$ (对于 $j \\in \\{0, 1, \\dots, N_y\\}$)。\n- 映射的物理节点：$x_i = \\xi_i^{\\alpha}$ 和 $y_j = \\eta_j^{\\beta}$ (对于给定的正常数参数 $\\alpha$ 和 $\\beta$)。\n- 网格由 $N_x \\times N_y$ 个形如 $[x_i, x_{i+1}] \\times [y_j, y_{j+1}]$ 的四边形单元组成。每个四边形通过连接节点 $(x_i, y_j)$ 和 $(x_{i+1}, y_{j+1})$ 的对角线被分割成两个三角形。\n\n### 3. 单元组装\n全局刚度矩阵 $K$ 是通过对网格中每个三角形单元 $T_k$ 的贡献求和来组装的。在具有顶点 $P_1=(x_1, y_1)$, $P_2=(x_2, y_2)$ 和 $P_3=(x_3, y_3)$ 的单个线性三角形单元 $T$ 上，基函数 $\\varphi_m$ (对于 $m=1,2,3$) 是线性的，其梯度 $\\nabla \\varphi_m$ 是常数。该三角形的单元刚度矩阵 $K^e \\in \\mathbb{R}^{3 \\times 3}$ 的项为：\n$$K^e_{mn} = \\int_{T} \\nabla \\varphi_m \\cdot \\nabla \\varphi_n \\, \\mathrm{d}A = (\\nabla \\varphi_m \\cdot \\nabla \\varphi_n) \\cdot \\operatorname{Area}(T).$$\n梯度可以计算为：\n$$ \\nabla \\varphi_1 = \\frac{1}{2 A} \\begin{pmatrix} y_2 - y_3 \\\\ x_3 - x_2 \\end{pmatrix}, \\quad \\nabla \\varphi_2 = \\frac{1}{2 A} \\begin{pmatrix} y_3 - y_1 \\\\ x_1 - x_3 \\end{pmatrix}, \\quad \\nabla \\varphi_3 = \\frac{1}{2 A} \\begin{pmatrix} y_1 - y_2 \\\\ x_2 - x_1 \\end{pmatrix}, $$\n其中 $A = \\operatorname{Area}(T)$。然后根据单元顶点的全局索引，将这些单元矩阵加到全局刚度矩阵中。由于我们只关心内部自由度，因此仅对两个顶点都位于区域 $\\Omega$ 内部的顶点对添加贡献。\n\n### 4. 节点排序与稀疏性分析\n所得稀疏矩阵 $K$ 的结构取决于内部节点的排序。内部节点的总数为 $N = (N_x-1)(N_y-1)$。\n1.  **自然字典序**：我们将内部节点的二维网格 $(i,j)$（其中 $i \\in \\{1, \\dots, N_x-1\\}$ 和 $j \\in \\{1, \\dots, N_y-1\\}$）映射到一维索引 $p$。指定的“i增长最快”顺序对应于映射 $p = (i-1) + (j-1)(N_x-1)$。该矩阵表示为 $K_{\\text{nat}}$。\n2.  **逆 Cuthill–McKee (RCM) 排序**：这是一种计算矩阵行和列的置换 $P$ 以减小其带宽的算法。置换后的矩阵为 $K_{\\text{rcm}} = P K_{\\text{nat}} P^T$。\n\n使用两个指标来比较 $K_{\\text{nat}}$ 和 $K_{\\text{rcm}}$ 的稀疏模式：\n1.  **半带宽**：$b(A) = \\max\\{|i-j| : A_{ij} \\neq 0\\}$。对于直接求解器，较小的带宽通常是理想的。\n2.  **填充**：$F(A) = \\operatorname{nnz}(L) + \\operatorname{nnz}(U) - \\operatorname{nnz}(A)$。该量度量了稀疏 LU 分解（$A \\approx LU$）期间创建的新非零项的数量。分解时禁用列置换，并将对角主元阈值设为零，以确保结果具有可比性。\n\n### 5. 算法实现\n对于每个测试用例 $(N_x, N_y, \\alpha, \\beta)$ 的总体算法如下：\n1.  使用幂律变换生成节点坐标的 $(N_x+1) \\times (N_y+1)$ 网格 $(x_i, y_j)$。\n2.  初始化一个大小为 $N \\times N$ 的空稀疏刚度矩阵 $K$，其中 $N=(N_x-1)(N_y-1)$。\n3.  遍历每个四边形单元 $(i,j)$，其中 $i \\in \\{0, \\dots, N_x-1\\}$ 且 $j \\in \\{0, \\dots, N_y-1\\}$。\n4.  对于单元内的两个三角形中的每一个：\n    a. 计算其 $3 \\times 3$ 的单元刚度矩阵 $K^e$。\n    b. 对于每对顶点，检查它们是否为内部节点。如果是，确定它们在降阶系统中的全局索引 $p$ 和 $q$。\n    c. 将 $K^e$ 中相应的项加到 $K_{pq}$ 上。\n5.  所得矩阵为 $K_{\\text{nat}}$。计算其半带宽 $b(K_{\\text{nat}})$ 和填充量 $F(K_{\\text{nat}})$。\n6.  计算 $K_{\\text{nat}}$ 的 RCM 置换，并形成置换后的矩阵 $K_{\\text{rcm}}$。\n7.  计算 $K_{\\text{rcm}}$ 的半带宽 $b(K_{\\text{rcm}})$ 和填充量 $F(K_{\\text{rcm}})$。\n8.  存储四个整数指标。\n\n对所有测试用例重复此过程，并将结果连接成一个列表。", "answer": "```python\nimport numpy as np\nfrom scipy.sparse import lil_matrix, csc_matrix\nfrom scipy.sparse.csgraph import reverse_cuthill_mckee\nfrom scipy.sparse.linalg import splu\n\ndef solve():\n    \"\"\"\n    Assembles the finite element stiffness matrix for a Poisson problem on a\n    nonuniform grid, and analyzes its sparsity under natural and RCM orderings.\n    \"\"\"\n    test_cases = [\n        # (Nx, Ny, alpha, beta)\n        (8, 8, 2.0, 1.0),\n        (2, 2, 1.5, 1.2),\n        (12, 7, 3.0, 0.5),\n    ]\n\n    all_results = []\n    \n    for case_params in test_cases:\n        Nx, Ny, alpha, beta = case_params\n\n        # 1. Generate node coordinates\n        xi = np.linspace(0, 1, Nx + 1)\n        eta = np.linspace(0, 1, Ny + 1)\n        x_coords_vec = xi**alpha\n        y_coords_vec = eta**beta\n        \n        # All node coordinates, ordered lexicographically with x-index fastest\n        nodes = np.array([[x, y] for y in y_coords_vec for x in x_coords_vec])\n\n        # 2. Setup for assembly based on interior nodes\n        num_interior_nodes_x = Nx - 1\n        num_interior_nodes_y = Ny - 1\n        N_interior = num_interior_nodes_x * num_interior_nodes_y\n\n        if N_interior == 0:\n            all_results.extend([0, 0, 0, 0])\n            continue\n            \n        K = lil_matrix((N_interior, N_interior), dtype=np.float64)\n\n        # Memoization for faster interior index lookup\n        memo_interior_idx = {}\n        def get_interior_idx(i, j):\n            if (i, j) in memo_interior_idx:\n                return memo_interior_idx[(i, j)]\n            \n            if 1 = i  Nx and 1 = j  Ny:\n                # Natural lexicographic ordering (i fastest)\n                idx = (i - 1) + (j - 1) * num_interior_nodes_x\n                memo_interior_idx[(i, j)] = idx\n                return idx\n            \n            memo_interior_idx[(i, j)] = None\n            return None\n\n        # 3. Assemble global stiffness matrix K\n        for j_quad in range(Ny):\n            for i_quad in range(Nx):\n                v_indices_global = [\n                    (i_quad, j_quad), (i_quad + 1, j_quad), \n                    (i_quad, j_quad + 1), (i_quad + 1, j_quad + 1)\n                ]\n                \n                # Each quad is split into two triangles by the diagonal from (xi,yj) to (xi+1,yj+1)\n                triangles_v_indices = [\n                    (v_indices_global[0], v_indices_global[1], v_indices_global[3]),\n                    (v_indices_global[0], v_indices_global[3], v_indices_global[2])\n                ]\n\n                for tri_v_indices in triangles_v_indices:\n                    v_coords = np.array([\n                        nodes[idx[0] + idx[1] * (Nx + 1)] for idx in tri_v_indices\n                    ])\n                    \n                    # Compute element stiffness matrix Ke for a linear triangle\n                    area = 0.5 * abs(\n                        (v_coords[1, 0] - v_coords[0, 0]) * (v_coords[2, 1] - v_coords[0, 1]) -\n                        (v_coords[2, 0] - v_coords[0, 0]) * (v_coords[1, 1] - v_coords[0, 1])\n                    )\n                    \n                    if area  1e-15: continue\n\n                    grad_matrix = np.zeros((3, 2))\n                    grad_matrix[0, 0] = v_coords[1, 1] - v_coords[2, 1]\n                    grad_matrix[0, 1] = v_coords[2, 0] - v_coords[1, 0]\n                    grad_matrix[1, 0] = v_coords[2, 1] - v_coords[0, 1]\n                    grad_matrix[1, 1] = v_coords[0, 0] - v_coords[2, 0]\n                    grad_matrix[2, 0] = v_coords[0, 1] - v_coords[1, 1]\n                    grad_matrix[2, 1] = v_coords[1, 0] - v_coords[0, 0]\n                    grad_matrix /= (2 * area)\n\n                    Ke = area * (grad_matrix @ grad_matrix.T)\n\n                    interior_indices = [get_interior_idx(vi[0], vi[1]) for vi in tri_v_indices]\n\n                    for r_loc in range(3):\n                        r_glob = interior_indices[r_loc]\n                        if r_glob is None: continue\n                        for c_loc in range(3):\n                            c_glob = interior_indices[c_loc]\n                            if c_glob is None: continue\n                            K[r_glob, c_glob] += Ke[r_loc, c_loc]\n\n        K_nat = K.tocsc()\n\n        # 4. Analyze matrices\n        def analyze_matrix(A):\n            if A.shape[0] == 0:\n                return 0, 0\n            \n            A_coo = A.tocoo()\n            if A_coo.nnz == 0:\n                 b = 0\n            else:\n                 b = np.max(np.abs(A_coo.row - A_coo.col))\n            \n            lu = splu(A, permc_spec=\"NATURAL\", diag_pivot_thresh=0.0)\n            fill_in = lu.L.nnz + lu.U.nnz - A.nnz\n            \n            return int(b), int(fill_in)\n            \n        b_nat, F_nat = analyze_matrix(K_nat)\n\n        if N_interior > 1:\n            perm = reverse_cuthill_mckee(K_nat, symmetric_mode=True)\n            K_rcm = K_nat[perm, :][:, perm]\n        else:\n            K_rcm = K_nat\n            \n        b_rcm, F_rcm = analyze_matrix(K_rcm)\n\n        all_results.extend([b_nat, F_nat, b_rcm, F_rcm])\n        \n    # 5. Format and print output\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3098591"}]}