{"hands_on_practices": [{"introduction": "双曲型偏微分方程，如平流方程，用于模拟波的传播。虽然像Lax-Wendroff这样的高阶格式对于光滑解更精确，但本练习将揭示“吉布斯现象”——当这些格式遇到尖锐不连续点时，会产生非物理的振荡。这是一个在计算流体力学中常见的挑战，通过这个实践，你将亲手量化这些振荡，并理解其与格式和参数选择的关系。[@problem_id:2393549]", "problem": "考虑一维线性平流方程 $u_t + a\\,u_x = 0$，定义在周期性域 $x \\in [0,1)$ 上，其中平流速度 $a  0$ 为常数。设 $a = 1$。初始条件为阶跃间断\n$$\nu(x,0) = \\begin{cases}\n1,  x \\ge 0.5,\\\\\n0,  x  0.5.\n\\end{cases}\n$$\n使用 $N$ 个均匀的单元中心点 $x_j = (j + 0.5)\\,\\Delta x$（其中 $j \\in \\{0,1,\\dots,N-1\\}$，$\\Delta x = 1/N$）对空间进行离散化，并施加周期性。使用由更新公式定义的 Lax–Wendroff 有限差分格式来演化离散解\n$$\nu_j^{n+1} = u_j^n - \\tfrac{1}{2}\\sigma\\left(u_{j+1}^n - u_{j-1}^n\\right) + \\tfrac{1}{2}\\sigma^2\\left(u_{j+1}^n - 2u_j^n + u_{j-1}^n\\right),\n$$\n其中使用周期性索引，Courant–Friedrichs–Lewy (CFL) 数 $\\sigma$ 为 $\\sigma = a\\,\\Delta t / \\Delta x$，$\\Delta t$ 是时间步长。对于下面的每种情况，使用指定的 $N$、$\\sigma$ 和终端时间 $t_{\\mathrm{end}}$ 来构造 $\\Delta t = \\sigma\\,\\Delta x/a$，并演化到使得 $t_n = n\\,\\Delta t \\le t_{\\mathrm{end}}$ 成立的最大整数步数 $n$。将此演化时间记为 $t_n$。\n\n为了量化平流间断附近的类吉布斯振荡，将时间 $t_n$ 时的理论间断位置定义为 $x_d(t_n) = \\mathrm{mod}(0.5 + a\\,t_n,\\,1)$。提取一个以 $x_d(t_n)$ 为中心、半宽为 $w_x = 0.1$ 的对称空间窗口，即所有满足其到 $x_d(t_n)$ 的最短周期距离不超过 $w_x$ 的网格点 $x_j$。在此窗口内，计算离散解在时间 $t_n$ 时的以下三个量：\n- 过冲幅值 $O = \\max\\{0,\\,\\max_{\\text{window}} u - 1\\}$。\n- 下冲幅值 $U = \\max\\{0,\\,0 - \\min_{\\text{window}} u\\}$。\n- 总变差比率 $R = \\mathrm{TV}(u(\\cdot,t_n)) / \\mathrm{TV}(u(\\cdot,0))$，其中离散总变差为 $\\mathrm{TV}(v) = \\sum_{j=0}^{N-1} |v_{j+1} - v_j|$，使用周期性索引。\n\n您的程序必须为以下五个测试案例中的每一个评估 $(O,U,R)$：\n1. $N=200$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n2. $N=200$, $\\sigma=0.9$, $t_{\\mathrm{end}}=0.2$。\n3. $N=50$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n4. $N=200$, $\\sigma=0.2$, $t_{\\mathrm{end}}=0.2$。\n5. $N=800$, $\\sigma=0.5$, $t_{\\mathrm{end}}=0.2$。\n\n所有量都是无量纲的。您的程序应产生单行输出，包含一个逗号分隔的列表的列表，其中第 $k$ 个内部列表是针对测试案例 $k$ 的 $[O_k,U_k,R_k]$，每个浮点数四舍五入到恰好六位小数。例如，要求的格式为\n$$\n[\\,[O_1,U_1,R_1],\\,[O_2,U_2,R_2],\\,\\dots,\\,[O_5,U_5,R_5]\\,].\n$$", "solution": "该问题要求使用 Lax-Wendroff 有限差分格式对一维线性平流方程进行数值求解。主要目标是量化将此二阶非单调格式应用于不连续初始剖面时产生的数值伪影，特别是类吉布斯振荡。\n\n控制偏微分方程是线性平流方程：\n$$\n\\frac{\\partial u}{\\partial t} + a \\frac{\\partial u}{\\partial x} = 0\n$$\n其中 $u(x, t)$ 是守恒量，$x \\in [0, 1)$ 是具有周期性边界条件的空间坐标，$t$ 是时间，$a$ 是恒定的平流速度，给定为 $a=1$。该方程的解析解是初始剖面的简单平移，$u(x,t) = u_0(x-at)$，其中 $u_0(x) = u(x,0)$。对于给定的阶跃函数初始条件：\n$$\nu(x,0) = \\begin{cases}\n1,  x \\ge 0.5 \\\\\n0,  x  0.5\n\\end{cases}\n$$\n初始位于 $x=0.5$ 的间断点以速度 $a=1$ 平流，其在时间 $t$ 的理论位置是 $x_d(t) = \\mathrm{mod}(0.5 + at, 1)$。\n\n计算域被离散为 $N$ 个均匀的单元中心网格点 $x_j = (j + 0.5)\\Delta x$（对于 $j \\in \\{0, 1, \\dots, N-1\\}$），空间步长为 $\\Delta x = 1/N$。周期性意味着索引按模 $N$ 处理，因此 $x_{j+N} = x_j$。\n\n时间演化由显式的 Lax-Wendroff 格式控制，该格式在空间和时间上都是二阶精确的。解 $u_j^n \\approx u(x_j, t_n)$ 的离散更新公式由下式给出：\n$$\nu_j^{n+1} = u_j^n - \\frac{1}{2}\\sigma(u_{j+1}^n - u_{j-1}^n) + \\frac{1}{2}\\sigma^2(u_{j+1}^n - 2u_j^n + u_{j-1}^n)\n$$\n此处，$\\sigma = a\\Delta t / \\Delta x$ 是 Courant-Friedrichs-Lewy (CFL) 数，它关联了时间步长 $\\Delta t$、空间步长 $\\Delta x$ 和平流速度 $a$。该格式在 $|\\sigma| \\le 1$ 时是稳定的。问题指定 $\\Delta t = \\sigma \\Delta x / a$。模拟运行到使得总演化时间 $t_n = n_{\\text{steps}} \\Delta t$ 不超过给定终端时间 $t_{\\mathrm{end}}$ 的最大整数步数 $n_{\\text{steps}}$。\n\nLax-Wendroff 格式通过引入一个与二阶空间导数成比例的项来达到二阶精度，该项抵消了一阶迎风格式的数值耗散。然而，这会引入数值色散，在陡峭梯度或间断附近引起非物理振荡（过冲和下冲），这是一种与吉布斯效应相关的现象。\n\n为了量化这些振荡，我们分析了最终时间 $t_n$ 的数值解 $u_j^{n}$。在平流间断的理论位置 $x_d(t_n)$ 周围定义了一个半宽为 $w_x = 0.1$ 的空间窗口。此窗口包含所有网格点 $x_j$，使得其到 $x_d(t_n)$ 的最短周期距离，即 $\\min(|x_j - x_d(t_n)|, 1 - |x_j - x_d(t_n)|)$，不大于 $w_x$。在此窗口内，我们计算：\n1.  过冲幅值 $O = \\max\\{0, \\max_{\\text{window}} u - 1\\}$。这测量了窗口中解超过初始最大值 $1$ 的最大值。\n2.  下冲幅值 $U = \\max\\{0, 0 - \\min_{\\text{window}} u\\}$。这测量了解在窗口中低于初始最小值 $0$ 的最大值。\n\n此外，我们通过计算时间 $t_n$ 的总变差 (TV) 与初始总变差的比率来评估振荡的增长。网格函数 $v$ 的离散总变差定义为 $\\mathrm{TV}(v) = \\sum_{j=0}^{N-1} |v_{j+1} - v_j|$，使用周期性索引 $v_N = v_0$。初始条件是周期域上的阶跃函数，它有两个跳跃（从 $0$到 $1$ 和从 $1$ 回到 $0$），因此其理论总变差为 $\\mathrm{TV}(u(\\cdot,0)) = 2$。比率为 $R = \\mathrm{TV}(u(\\cdot,t_n)) / \\mathrm{TV}(u(\\cdot,0))$。对于像 Lax-Wendroff 这样非总变差减小 (TVD) 的格式，此比率预期会大于 1，表明产生了新的极值，即振荡。\n\n每个测试案例的算法流程如下：\n1.  初始化参数：$N, \\sigma, t_{\\mathrm{end}}$，其中 $a=1$ 和 $w_x=0.1$。\n2.  计算模拟参数：$\\Delta x = 1/N$，$\\Delta t = \\sigma \\Delta x / a$，以及 $n_{\\text{steps}} = \\lfloor t_{\\mathrm{end}} / \\Delta t \\rfloor$。最终时间为 $t_n = n_{\\text{steps}} \\Delta t$。\n3.  设置网格 $x_j$ 和初始条件 $u^0$，其中如果 $x_j \\ge 0.5$ 则 $u_j^0 = 1$，否则 $u_j^0 = 0$。\n4.  计算初始总变差 $\\mathrm{TV}(u^0)$。\n5.  迭代应用 Lax-Wendroff 更新公式 $n_{\\text{steps}}$ 次以获得最终数值解 $u^{n_{\\text{steps}}}$。为提高效率，使用向量化数组操作，并采用循环移位来处理周期性边界条件。\n6.  确定理论间断位置 $x_d(t_n) = (0.5 + a t_n) \\pmod 1$。\n7.  识别位于以 $x_d(t_n)$ 为中心、半宽为 $w_x$ 的分析窗口内的网格点。\n8.  计算此窗口内解的最大值和最小值，以求得过冲 $O$ 和下冲 $U$。\n9.  计算最终解的总变差 $\\mathrm{TV}(u^{n_{\\text{steps}}})$ 和比率 $R$。\n10. 存储该案例计算出的三元组 $(O, U, R)$。\n对所有五个指定的测试案例重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D linear advection equation using the Lax-Wendroff scheme for\n    multiple test cases and quantifies numerical oscillations.\n    \"\"\"\n    test_cases = [\n        (200, 0.5, 0.2),\n        (200, 0.9, 0.2),\n        (50, 0.5, 0.2),\n        (200, 0.2, 0.2),\n        (800, 0.5, 0.2),\n    ]\n\n    results = []\n    a = 1.0  # Advection speed\n    w_x = 0.1  # Window half-width for analysis\n\n    for N, sigma, t_end in test_cases:\n        # 1. Setup simulation parameters\n        dx = 1.0 / N\n        dt = sigma * dx / a\n        if dt == 0:\n            num_steps = 0\n        else:\n            num_steps = int(t_end / dt)\n        t_n = num_steps * dt\n\n        # 2. Initialize grid and solution\n        x = (np.arange(N) + 0.5) * dx\n        u = np.where(x = 0.5, 1.0, 0.0)\n\n        # 3. Calculate initial total variation\n        # TV(v) = sum(|v_{j+1} - v_j|) with periodic indexing\n        # np.roll(u, -1) gives u_{j+1} at index j\n        tv_initial = np.sum(np.abs(np.roll(u, -1) - u))\n        if tv_initial == 0: tv_initial = 1.0 # Avoid division by zero, though not expected here.\n\n        # 4. Time evolution loop (Lax-Wendroff)\n        for _ in range(num_steps):\n            u_jp1 = np.roll(u, -1)  # u_{j+1}\n            u_jm1 = np.roll(u, 1)   # u_{j-1}\n            \n            # Central difference term (first derivative)\n            term1 = -0.5 * sigma * (u_jp1 - u_jm1)\n            \n            # Central difference term (second derivative)\n            term2 = 0.5 * sigma**2 * (u_jp1 - 2.0 * u + u_jm1)\n            \n            u = u + term1 + term2\n        \n        u_final = u\n\n        # 5. Analyze the final solution\n        # Theoretical discontinuity location\n        x_d = (0.5 + a * t_n) % 1.0\n\n        # Identify the analysis window\n        dist = np.abs(x - x_d)\n        periodic_dist = np.minimum(dist, 1.0 - dist)\n        window_mask = periodic_dist = w_x\n        \n        u_window = u_final[window_mask]\n\n        # Handle case where window might be empty, though unlikely with given params\n        if u_window.size  0:\n            max_u_window = np.max(u_window)\n            min_u_window = np.min(u_window)\n        else:\n            max_u_window = 1.0\n            min_u_window = 0.0\n\n        # Calculate overshoot and undershoot\n        overshoot = max(0.0, max_u_window - 1.0)\n        undershoot = max(0.0, 0.0 - min_u_window)\n\n        # Calculate total variation ratio\n        tv_final = np.sum(np.abs(np.roll(u_final, -1) - u_final))\n        tv_ratio = tv_final / tv_initial\n        \n        results.append([overshoot, undershoot, tv_ratio])\n\n    # 6. Format and print the final output\n    formatted_results = []\n    for O, U, R in results:\n        formatted_results.append(f\"[{O:.6f},{U:.6f},{R:.6f}]\")\n    \n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393549"}, {"introduction": "抛物线型偏微分方程，如热传导方程，描述了会使初始不规则性平滑化的扩散过程。我们将探索Crank-Nicolson方法，这是一种无条件稳定的格式。然而，本练习将揭示一个与直觉相反的行为：尽管该格式稳定，但在对尖锐的初始数据使用大时间步长时，它会引入违反连续方程极值原理的非物理振荡。这个实践将帮助你理解数值格式的稳定性和保单调性之间的重要区别。[@problem_id:2393571]", "problem": "考虑区间 $[0,1]$ 上带齐次狄利克雷边界条件的一维热（扩散）方程，\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in (0,1), \\ t  0, \\quad u(0,t) = 0, \\ u(1,t) = 0,\n$$\n以及一个不连续的初始条件\n$$\nu(x,0) = \\begin{cases}\n1,  x \\in [0.45, 0.55],\\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n所有量均为无量纲量。使用包含 $N=201$ 个等距点（包括边界）的均匀空间网格，因此 $\\Delta x = 1/(N-1)$。令 $\\alpha = 1$。\n\n令 $u_i^n$ 表示在内部网格点 $x_i = i \\, \\Delta x$（其中 $i=1,2,\\dots,N-2$）和时间层 $t_n = n \\, \\Delta t$ 处对 $u(x_i,t_n)$ 的数值近似。将从 $t_n$ 到 $t_{n+1}$ 推进一个时间步长的 Crank–Nicolson 有限差分格式定义为下式的唯一解 $u^{n+1}$：\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\, \\Delta t}{(\\Delta x)^2},\n$$\n其中 $I$ 是内部网格上的恒等算子，$L$ 是作用于内部网格值的带齐次狄利克雷边界条件的标准二阶差分算子：\n$$\n(L u)_i = u_{i+1} - 2 u_i + u_{i-1}, \\quad i=1,2,\\dots,N-2,\n$$\n并理解为由于边界条件，$u_0 = 0$ 且 $u_{N-1} = 0$。\n\n对于给定的时间步长 $\\Delta t$，将一个 Crank–Nicolson 时间步长后的振荡幅度定义为\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\n该量是从 $t=0$ 时的指定不连续初始条件出发，经过单个时间步长后，内部解超出物理上限 $1$ 的上冲量与低于物理下限 $0$ 的下冲量之和。\n\n测试套件：\n- 按规定使用 $N=201$ 和 $\\alpha = 1$。\n- 令 $\\Delta x = 1/(N-1)$。\n- 考虑四个时间步长\n  1. $\\Delta t_1 = 0.2 \\, (\\Delta x)^2 / \\alpha$,\n  2. $\\Delta t_2 = 1.0 \\, (\\Delta x)^2 / \\alpha$,\n  3. $\\Delta t_3 = 5.0 \\, (\\Delta x)^2 / \\alpha$,\n  4. $\\Delta t_4 = 25.0 \\, (\\Delta x)^2 / \\alpha$.\n  \n对每个 $\\Delta t_k$，计算如上定义的 $A(\\Delta t_k)$。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，顺序为 $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$，每个值四舍五入到六位小数。输出是无量纲的，并且只包含浮点数。", "solution": "我们从区间 $[0,1]$ 上的热方程 $\\partial_t u = \\alpha \\partial_{xx} u$ 开始，其带有齐次狄利克雷边界条件和限制在 $[0.45,0.55]$ 内的不连续阶跃初始条件。连续问题的极值原理意味着，对于 $t0$，解保持在 $0$ 和 $1$ 之间。然而，某些时间离散化方法，虽然在某种范数下是稳定的，但并不单调，并且当初始数据存在急剧不连续时，会产生非物理振荡，如下冲（值低于 $0$）或上冲（值高于 $1$）。Crank–Nicolson 格式是一种在 $\\ell^2$ 意义下二阶精确、隐式、无条件稳定的方法，但它不是总变差递减或保单调的，并且对于足够大的时间步长会产生此类振荡。\n\n我们用 $N=201$ 个均匀分布的节点（包括边界）对空间域进行离散化，因此 $\\Delta x = 1/(N-1)$。我们用 $i=1,2,\\dots,N-2$ 索引内部节点，并用 $u_i^n$ 表示在 $x_i=i\\Delta x$ 和时间 $t_n=n\\Delta t$ 处的数值近似。带齐次狄利克雷边界条件的标准中心二阶差分算子在内部索引上定义为\n$$\n(Lu)_i = u_{i+1} - 2u_i + u_{i-1}, \\quad i=1,\\dots,N-2,\n$$\n并强制边界值 $u_0=0$ 和 $u_{N-1}=0$。\n\n半离散系统 $\\dot{u}=\\alpha \\Delta_x u$ 的 Crank–Nicolson 时间步进格式为\n$$\n\\left( I - \\frac{r}{2} L \\right) u^{n+1} = \\left( I + \\frac{r}{2} L \\right) u^{n}, \\quad r = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\n在一维均匀网格上，这成为一个关于内部索引处 $u^{n+1}$ 的三对角线性系统。对 $i=1,\\dots,N-2$ 写出分量形式，\n$$\n-\\frac{r}{2} \\, u_{i-1}^{n+1} + (1+r) \\, u_i^{n+1} - \\frac{r}{2} \\, u_{i+1}^{n+1}\n=\n\\frac{r}{2} \\, u_{i-1}^{n} + (1-r) \\, u_i^{n} + \\frac{r}{2} \\, u_{i+1}^{n},\n$$\n由于 $u_0^n=u_{N-1}^n=0$，边界贡献为零。\n\n初始数据由下式设定\n$$\nu_i^0 = \\begin{cases}\n1,  x_i \\in [0.45,0.55],\\\\\n0,  \\text{otherwise},\n\\end{cases}\n\\qquad x_i = i \\Delta x, \\quad i=1,\\dots,N-2.\n$$\n\n为了量化一个时间步长后的非物理振荡，我们定义振幅\n$$\nA(\\Delta t) = \\max\\!\\left(0, \\ \\max_{1 \\le i \\le N-2} u_i^{1} - 1 \\right) \\;+\\; \\max\\!\\left(0, \\ 0 - \\min_{1 \\le i \\le N-2} u_i^{1} \\right).\n$$\n第一项衡量超出物理界限 $1$ 的上冲，第二项衡量低于 $0$ 的下冲。对于具有非负有界初始数据的热方程，精确解保持在 $[0,1]$ 内，因此任何正的 $A(\\Delta t)$ 都表示由离散格式引起的非物理振荡。\n\n我们现在讨论为什么大的 $r$ 会导致振荡。均匀网格上的离散拉普拉斯算子 $L$ 具有类似于离散正弦的本征模。对于波数为 $\\theta$ 的傅立叶分量，离散拉普拉斯算子的特征值为 $\\lambda_d(\\theta) = -4\\sin^2(\\theta/2)$。此模式的 Crank–Nicolson 放大因子是\n$$\ng(\\theta; r) = \\frac{1 + \\frac{r}{2}\\lambda_d(\\theta)}{1 - \\frac{r}{2}\\lambda_d(\\theta)}\n= \\frac{1 - 2 r \\sin^2(\\theta/2)}{1 + 2 r \\sin^2(\\theta/2)}.\n$$\n对于任何 $r0$，我们有 $|g(\\theta;r)| \\le 1$，确保了在 $\\ell^2$ 意义下的无条件稳定性。然而，如果 $2 r \\sin^2(\\theta/2)  1$，则 $g(\\theta;r)  0$，这会在单个时间步长内翻转这些傅立葉分量的符号，在存在高频内容的急剧不连续点附近产生振荡。$\\sin^2(\\theta/2)$ 的最大值为 $1$，因此对于 $r  1/2$，最高频率的模式在一步之后符号反转。因此，我们预计当 $r=0.2$ 时振荡可忽略不计，当 $r=1$ 时振荡性下冲/上冲增加，而当 $r=5$ 和 $r=25$ 时振荡更加显著。\n\n算法上，对于每个指定的 $\\Delta t_k$（等效于 $r_k$），我们：\n1. 根据内部网格上的阶跃初始条件构造 $u^0$。\n2. 形成三对角系统，其下对角线元素为 $-r_k/2$，对角线元素为 $1+r_k$，上对角线元素为 $-r_k/2$。\n3. 使用内部值和边界处的 $0$ 来组装右侧项 $(I + \\frac{r_k}{2} L) u^0$。\n4. 求解三对角系统以获得 $u^1$。\n5. 根据 $u^1$ 的内部值计算如上定义的 $A(\\Delta t_k)$。\n6. 对测试套件中的四个 $\\Delta t_k$ 测试值重复此过程。\n\n最后，我们输出列表 $[A(\\Delta t_1), A(\\Delta t_2), A(\\Delta t_3), A(\\Delta t_4)]$，每个值四舍五入到六位小数，以单行、括号内逗号分隔的形式呈现。此过程直接反映了 Crank–Nicolson 方法的数学结构，并量化了对于不连续初始数据，当时间步长较大时可能出现的非物理振荡。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef thomas_tridiagonal(lower, diag, upper, rhs):\n    \"\"\"\n    Solve a tridiagonal system Ax = rhs with A having\n    lower (a), diagonal (b), and upper (c) diagonals.\n    All inputs are 1D numpy arrays:\n      lower: length n-1\n      diag:  length n\n      upper: length n-1\n      rhs:   length n\n    Returns x of length n.\n    \"\"\"\n    n = diag.size\n    # Copy to avoid modifying inputs\n    a = lower.astype(float).copy()\n    b = diag.astype(float).copy()\n    c = upper.astype(float).copy()\n    d = rhs.astype(float).copy()\n\n    # Forward elimination\n    for i in range(1, n):\n        w = a[i-1] / b[i-1]\n        b[i] = b[i] - w * c[i-1]\n        d[i] = d[i] - w * d[i-1]\n\n    # Back substitution\n    x = np.empty(n, dtype=float)\n    x[-1] = d[-1] / b[-1]\n    for i in range(n-2, -1, -1):\n        x[i] = (d[i] - c[i] * x[i+1]) / b[i]\n\n    return x\n\ndef crank_nicolson_first_step_amplitude(N, alpha, dt):\n    \"\"\"\n    Compute the oscillation amplitude A(dt) after one Crank-Nicolson step\n    for the 1D heat equation on [0,1] with homogeneous Dirichlet BCs and\n    discontinuous initial condition: u(x,0)=1 on [0.45,0.55], 0 otherwise.\n    \"\"\"\n    # Grid setup\n    L = 1.0\n    dx = L / (N - 1)\n    r = alpha * dt / (dx * dx)\n\n    # Interior indices: 1..N-2 (Python 0..M-1)\n    M = N - 2\n    x_interior = np.linspace(dx, L - dx, M)\n\n    # Initial condition on interior: 1 on [0.45,0.55], else 0\n    u0 = np.where((x_interior = 0.45)  (x_interior = 0.55), 1.0, 0.0)\n\n    # Build Crank-Nicolson matrices (implicit LHS tridiagonal, RHS vector)\n    # LHS: (I - r/2 * L) = diag: 1 + r; off-diag: -r/2\n    lower = -0.5 * r * np.ones(M - 1)\n    diag = (1.0 + r) * np.ones(M)\n    upper = -0.5 * r * np.ones(M - 1)\n\n    # RHS: (I + r/2 * L) u0 = (1 - r) * u0 + (r/2) * (u0_{i-1} + u0_{i+1})\n    rhs = (1.0 - r) * u0.copy()\n    rhs[:-1] += 0.5 * r * u0[1:]     # contribution from u0_{i+1}\n    rhs[1:]  += 0.5 * r * u0[:-1]    # contribution from u0_{i-1}\n    # Boundary contributions are zero due to homogeneous Dirichlet BCs.\n\n    # Solve for u1\n    u1 = thomas_tridiagonal(lower, diag, upper, rhs)\n\n    # Compute amplitude A(dt) over interior values\n    max_val = float(np.max(u1))\n    min_val = float(np.min(u1))\n    overshoot = max(0.0, max_val - 1.0)\n    undershoot = max(0.0, -min_val)\n    A = overshoot + undershoot\n    return A\n\ndef solve():\n    # Parameters from the problem statement\n    N = 201\n    alpha = 1.0\n    L = 1.0\n    dx = L / (N - 1)\n\n    # Test suite time steps: dt_k = [0.2, 1.0, 5.0, 25.0] * dx^2 / alpha\n    r_values = [0.2, 1.0, 5.0, 25.0]\n    test_dts = [r * dx * dx / alpha for r in r_values]\n\n    results = []\n    for dt in test_dts:\n        A = crank_nicolson_first_step_amplitude(N, alpha, dt)\n        results.append(f\"{A:.6f}\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "2393571"}, {"introduction": "椭圆型偏微分方程，如泊松方程，通常用于模拟稳态系统。本练习使用标准的五点差分格式，这是求解此类方程的基本工具。我们将通过“制造解方法”发现该格式的一个关键限制：其精度具有各向异性。这意味着，相比于与网格轴对齐的特征，当格式试图解析与网格成对角线排列的尖锐特征时，其误差会显著增大。[@problem_id:2393578]", "problem": "考虑单位正方形域上的二维泊松方程，其解具有强但平滑的特征，主方向与网格轴对齐或成对角线方向。数学模型是标量场 $u(x,y)$ 在 $[0,1]\\times[0,1]$ 上的边值问题，\n$$- \\nabla^2 u(x,y) = f(x,y), \\quad (x,y)\\in (0,1)\\times(0,1),$$\n边界条件为狄利克雷（Dirichlet）边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，施加于边界 $\\partial([0,1]\\times[0,1])$ 上。拉普拉斯算子 $\\nabla^2$ 定义为 $\\nabla^2 u = \\partial^2 u / \\partial x^2 + \\partial^2 u / \\partial y^2$。您必须在均匀网格上使用标准的五点中心差分有限差分法来近似算子 $\\nabla^2$，并求解生成的线性系统以获得内部网格点上的 $u(x,y)$。\n\n使用人造解法（method of manufactured solutions）来定义两个精确解 $u_{\\text{exact}}(x,y)$，其锐度由宽度参数 $\\sigma  0$ 控制，其方向为：\n- 与直线 $x=y$ 对齐的对角线脊函数：\n  $$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right).$$\n- 沿 $x$ 轴方向，以 $x=0.5$ 为中心的轴对齐脊函数：\n  $$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp\\!\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right).$$\n\n对于每个人造解，通过将连续拉普拉斯算子 $\\nabla^2$ 应用于 $u_{\\text{exact}}$ 来计算其连续的右侧项 $f(x,y)$，并设 $f(x,y) = -\\nabla^2 u_{\\text{exact}}(x,y)$。对于对角线脊函数，请注意 $u_{\\mathrm{diag}}(x,y;\\sigma)$ 仅依赖于 $s=x-y$；对于函数 $g(s)$，使用恒等式 $\\partial^2 g/\\partial x^2 = g''(s)$ 和 $\\partial^2 g/\\partial y^2 = g''(s)$，两者共同意味着 $\\nabla^2 g(s) = 2 g''(s)$。对于轴对齐脊函数，请注意 $u_{\\mathrm{axis}}(x,y;\\sigma)$ 仅依赖于 $x$，因此 $\\nabla^2 u_{\\mathrm{axis}} = \\partial^2 u_{\\mathrm{axis}}/\\partial x^2$。这些运算都是连续求导；不要使用离散近似来构造 $f(x,y)$。\n\n使用一个包含 $N\\times N$ 个点的均匀笛卡尔网格对域进行离散化，网格间距为 $h = 1/(N-1)$，其中 $N$ 是一个奇数，以确保直线 $y=0.5$ 是一行网格线。在内部点 $(i,j)$ 上构建拉普拉斯算子的标准五点模板，通过将边界设置为精确的人造解来施加狄利克雷边界条件。仅使用标准五点模板为内部未知数构建并求解线性系统；不要使用任何高阶或九点模板。\n\n在相同的网格和相同的 $\\sigma$ 值下，计算出对角线和轴对齐人造解的数值解后，通过插入精确的边界值来重构完整网格。然后，评估以下两个沿线的最大绝对误差：\n- 对角线误差 $E_{\\mathrm{diag}}$：沿离散对角网格线 $x=y$（即索引为 $i=j$ 的节点）的数值解与精确解之间的最大绝对差，并按该线上精确解的最大幅值进行归一化。对于 $u_{\\mathrm{diag}}$，沿 $x=y$ 线上所有点的精确值均为 $1$。\n- 轴线误差 $E_{\\mathrm{axis}}$：沿水平线 $y=0.5$（即索引为 $j=(N-1)/2$ 的节点）的数值解与精确解之间的最大绝对差，并按该线上精确解的最大幅值进行归一化。对于 $u_{\\mathrm{axis}}$，沿 $y=0.5$ 线的精确峰值出现在 $x=0.5$ 处，其值为 $1$。\n\n定义失效比\n$$R(N,\\sigma) = \\frac{E_{\\mathrm{diag}}}{E_{\\mathrm{axis}}}.$$\n$R(N,\\sigma)  1$ 的值表明，对于对角线对齐的尖锐特征，五点模板产生的误差比轴对齐特征更大，这证明了网格对齐的各向异性以及在同等分辨率下无法解析对角线锐度的问题。\n\n您的程序必须：\n- 实现五点中心差分法，使用相同的网格和 $\\sigma$ 值求解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$ 的泊松问题。\n- 为每个测试用例计算 $E_{\\mathrm{diag}}$、$E_{\\mathrm{axis}}$ 和 $R(N,\\sigma)$。\n- 按照下文指定，将所有比率在一行上作为单个列表输出。\n\n不涉及物理单位。不使用角度。所有浮点输出均以普通十进制表示法表示。\n\n用于评估覆盖范围的测试套件：\n- 用例 1（欠解析的对角线特征）：$N=33$，$\\sigma=0.02$。\n- 用例 2（改进的分辨率）：$N=65$，$\\sigma=0.02$。\n- 用例 3（粗网格上的较宽特征）：$N=33$，$\\sigma=0.04$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含与上述用例相对应的三个比率 $R(N,\\sigma)$，格式为方括号内的逗号分隔列表，每个值四舍五入到 $6$ 位小数（例如 $[r_1,r_2,r_3]$）。", "solution": "所提出的问题是一个有效且适定的数值分析练习。它涉及使用五点有限差分法求解二维泊松方程，并利用人造解法来分析该模板的各向异性误差特征。所有必需的信息均已提供，物理和数学基础稳固，目标明确且可验证。\n\n该问题是在单位正方形域 $\\Omega = [0,1]\\times[0,1]$ 上求解泊松方程：\n$$ - \\nabla^2 u(x,y) = f(x,y), \\quad (x,y) \\in (0,1)\\times(0,1) $$\n边界条件为狄利克雷（Dirichlet）边界条件 $u(x,y) = u_{\\text{exact}}(x,y)$，适用于 $(x,y) \\in \\partial\\Omega$。算子 $\\nabla^2$ 是拉普拉斯算子，$\\nabla^2 u = \\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2}$。\n\n此处采用了人造解法。我们定义了两个精确解 $u_{\\mathrm{diag}}$ 和 $u_{\\mathrm{axis}}$，并通过应用连续算子 $f = -\\nabla^2 u_{\\text{exact}}$ 来推导相应的强制函数 $f(x,y)$。\n\n对于对角线脊函数，$u_{\\mathrm{diag}}(x,y;\\sigma) = \\exp(-\\frac{(x-y)^2}{2\\sigma^2})$。设 $g(s) = \\exp(-s^2/(2\\sigma^2))$，其中 $s=x-y$。其导数为 $g'(s) = -\\frac{s}{\\sigma^2}g(s)$ 和 $g''(s) = (\\frac{s^2}{\\sigma^4} - \\frac{1}{\\sigma^2})g(s)$。使用恒等式 $\\nabla^2 g(x-y) = 2g''(x-y)$，强制函数为：\n$$ f_{\\mathrm{diag}}(x,y;\\sigma) = -2 g''(x-y) = -2 \\left(\\frac{(x-y)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) = 2\\left(\\frac{1}{\\sigma^2} - \\frac{(x-y)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-y)^2}{2\\sigma^2}\\right) $$\n\n对于轴对齐脊函数，$u_{\\mathrm{axis}}(x,y;\\sigma) = \\exp(-\\frac{(x-0.5)^2}{2\\sigma^2})$。该函数仅依赖于 $x$。设 $h(x) = \\exp(-(x-0.5)^2/(2\\sigma^2))$。拉普拉斯算子为 $\\nabla^2 h(x) = \\frac{d^2h}{dx^2}$。二阶导数为 $\\frac{d^2h}{dx^2} = (\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2})h(x)$。强制函数为：\n$$ f_{\\mathrm{axis}}(x,y;\\sigma) = -\\frac{d^2u_{\\mathrm{axis}}}{dx^2} = -\\left(\\frac{(x-0.5)^2}{\\sigma^4} - \\frac{1}{\\sigma^2}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) = \\left(\\frac{1}{\\sigma^2} - \\frac{(x-0.5)^2}{\\sigma^4}\\right) \\exp\\left(-\\frac{(x-0.5)^2}{2\\sigma^2}\\right) $$\n\n该域使用一个包含 $N \\times N$ 个点的均匀笛卡尔网格进行离散化，其中 $N$ 是一个奇数。网格间距为 $h = 1/(N-1)$。设网格点为 $(x_i, y_j) = (ih, jh)$，其中 $i,j \\in \\{0, 1, \\dots, N-1\\}$。设 $U_{i,j}$ 是 $u(x_i, y_j)$ 的数值近似。\n\n对于内部网格点 $(x_i, y_j)$（其中 $i,j \\in \\{1, \\dots, N-2\\}$），负拉普拉斯算子的标准 $5$ 点中心差分近似为：\n$$ -\\nabla^2 u(x_i, y_j) \\approx \\frac{-U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} + 4U_{i,j}}{h^2} $$\n将其设为等于强制项 $f(x_i, y_j) = f_{i,j}$，得到离散方程：\n$$ 4U_{i,j} - U_{i+1,j} - U_{i-1,j} - U_{i,j+1} - U_{i,j-1} = h^2 f_{i,j} $$\n必须求解这个线性方程组，以获得 $(N-2) \\times (N-2)$ 个未知的内部值 $U_{i,j}$。边界上的值（即 $i=0$、$i=N-1$、$j=0$ 或 $j=N-1$）根据狄利克雷条件可知，$U_{i,j} = u_{\\text{exact}}(x_i, y_j)$。这些已知的边界值被移到与边界相邻的内部点方程的右侧。\n\n这会形成一个形如 $A\\mathbf{u} = \\mathbf{b}$ 的线性系统，其中 $\\mathbf{u}$ 是一个包含 $(N-2)^2$ 个未知内部网格值的向量，$A$ 是一个大小为 $(N-2)^2 \\times (N-2)^2$ 的稀疏、对称正定、块三对角矩阵，而 $\\mathbf{b}$ 是包含强制项 $f$ 和边界条件的右侧向量。矩阵 $A$ 的主对角线元素为 $4$，对应于 $5$ 点模板中四个邻居的元素为 $-1$。这个稀疏系统通过数值方法求解。\n\n在求解内部值之后，通过将内部解嵌入已知的精确边界值中来重构完整的数值解网格。\n\n然后，沿特定线评估误差。对角线误差 $E_{\\mathrm{diag}}$ 是为 $u_{\\mathrm{diag}}$ 情况计算的：\n$$ E_{\\mathrm{diag}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,i} - u_{\\mathrm{diag}}(x_i, x_i)|}{\\max_{i} u_{\\mathrm{diag}}(x_i, x_i)} = \\max_{i} |U_{i,i} - 1| $$\n轴线误差 $E_{\\mathrm{axis}}$ 是为 $u_{\\mathrm{axis}}$ 情况沿直线 $y=0.5$ 计算的，该直线对应于网格索引 $j_{\\text{mid}} = (N-1)/2$：\n$$ E_{\\mathrm{axis}} = \\frac{\\max_{i \\in \\{0, \\dots, N-1\\}} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})|}{\\max_{i} u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})} = \\max_{i} |U_{i,j_{\\text{mid}}} - u_{\\mathrm{axis}}(x_i, y_{j_{\\text{mid}}})| $$\n在这两种情况下，沿各自线的精确解的归一化最大幅值均为 $1$。\n\n最后，计算失效比 $R(N,\\sigma) = E_{\\mathrm{diag}} / E_{\\mathrm{axis}}$ 以量化模板的各向异性误差。所提供的程序为每个指定的测试用例实现了这整个过程。", "answer": "```python\nimport numpy as np\nfrom scipy import sparse\nfrom scipy.sparse.linalg import spsolve\n\ndef u_diag_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    return np.exp(-s_sq / (2 * sigma_sq))\n\ndef f_diag_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the diagonal ridge case.\"\"\"\n    s_sq = (X - Y)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-s_sq / (2 * sigma_sq))\n    return 2 * (1 / sigma_sq - s_sq / sigma_4) * exp_term\n\ndef u_axis_func(X, Y, sigma):\n    \"\"\"Computes the exact solution for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    return np.exp(-z_sq / (2 * sigma_sq))\n\ndef f_axis_func(X, Y, sigma):\n    \"\"\"Computes the forcing term for the axis-aligned ridge case.\"\"\"\n    z_sq = (X - 0.5)**2\n    sigma_sq = sigma**2\n    sigma_4 = sigma**4\n    exp_term = np.exp(-z_sq / (2 * sigma_sq))\n    return (1 / sigma_sq - z_sq / sigma_4) * exp_term\n\ndef solve_poisson(N, sigma, u_exact_func, f_func):\n    \"\"\"\n    Solves the 2D Poisson equation using a 5-point finite difference stencil.\n    \"\"\"\n    h = 1.0 / (N - 1)\n    x = np.linspace(0.0, 1.0, N)\n    y = np.linspace(0.0, 1.0, N)\n    X, Y = np.meshgrid(x, y, indexing='xy')\n\n    # Evaluate exact solution and forcing term on the full grid\n    u_exact = u_exact_func(X, Y, sigma)\n    f = f_func(X, Y, sigma)\n    \n    # Number of interior points in one dimension\n    M = N - 2\n    \n    # Construct the sparse matrix A for the linear system\n    main_diag = np.ones(M) * 4\n    off_diag = np.ones(M - 1) * -1\n    T = sparse.diags([off_diag, main_diag, off_diag], [-1, 0, 1], shape=(M, M), format='csr')\n    I_M = sparse.eye(M, format='csr')\n    A = sparse.kron(I_M, T) + sparse.diags([np.ones(M*(M-1))*-1, np.ones(M*(M-1))*-1], [-M, M], format='csr')\n    A = A.tocsc()\n\n    # Construct the right-hand side vector b\n    b_2d = h**2 * f[1:-1, 1:-1]\n    \n    # Add boundary condition contributions to b\n    # Note: U[j, i] corresponds to u at (x_i, y_j)\n    b_2d[:, 0] += u_exact[1:-1, 0]   # Left boundary (x=0)\n    b_2d[:, -1] += u_exact[1:-1, -1] # Right boundary (x=1)\n    b_2d[0, :] += u_exact[0, 1:-1]   # Bottom boundary (y=0)\n    b_2d[-1, :] += u_exact[-1, 1:-1] # Top boundary (y=1)\n    \n    b = b_2d.flatten(order='F') # Flatten column-major, for (i,j) -> k=(i-1)*M+(j-1)\n\n    # Solve the linear system\n    u_vec = spsolve(A, b)\n    \n    # Reshape solution vector to grid and insert into full solution grid\n    U_interior = u_vec.reshape((M, M), order='F')\n    U_numerical = np.copy(u_exact)\n    U_numerical[1:-1, 1:-1] = U_interior\n    \n    return U_numerical, u_exact\n\ndef solve():\n    test_cases = [\n        (33, 0.02),\n        (65, 0.02),\n        (33, 0.04),\n    ]\n\n    results = []\n    for N, sigma in test_cases:\n        # Diagonal case\n        U_diag_numerical, u_exact_diag_grid = solve_poisson(N, sigma, u_diag_func, f_diag_func)\n        diag_numerical = np.diag(U_diag_numerical)\n        diag_exact = np.diag(u_exact_diag_grid)\n        E_diag = np.max(np.abs(diag_numerical - diag_exact))\n\n        # Axis-aligned case\n        U_axis_numerical, u_exact_axis_grid = solve_poisson(N, sigma, u_axis_func, f_axis_func)\n        j_mid = (N - 1) // 2\n        axis_numerical_row = U_axis_numerical[j_mid, :]\n        axis_exact_row = u_exact_axis_grid[j_mid, :]\n        E_axis = np.max(np.abs(axis_numerical_row - axis_exact_row))\n        \n        # Failure ratio\n        R = E_diag / E_axis\n        results.append(R)\n\n    # Format results for printing\n    formatted_results = [f'{r:.6f}' for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2393578"}]}