{"hands_on_practices": [{"introduction": "这项练习旨在通过动手实践，帮助你掌握迭代求解器的基本应用。你将通过手动计算一个小型网格上单步雅可比（Jacobi）方法迭代后的电势值，从而具体理解这类方法是如何通过反复平均邻近点的值来逐步逼近解的。这个练习将抽象的迭代过程具象化，并将其与离散化的拉普拉斯方程直接联系起来。[@problem_id:2172039]", "problem": "考虑在一个方形无电荷区域内确定静电势 $u(x,y)$ 的问题。该电势满足二维拉普拉斯方程：\n$$\n\\frac{\\partial^2 u}{\\partial x^2} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n$$\n该区域被离散化为一个由点 $(x_i, y_j)$ 组成的均匀网格，其中 $x_i = i \\cdot h$ 且 $y_j = j \\cdot h$，$i,j \\in \\{0, 1, 2, 3\\}$。网格间距 $h$ 为常数。该网格产生四个内部点：$(x_1, y_1)$、$(x_1, y_2)$、$(x_2, y_1)$ 和 $(x_2, y_2)$。设这些网格点上的电势表示为 $u_{ij} = u(x_i, y_j)$。\n\n边界上的电势是固定的。与内部网格点相邻的边界点上的值如下：\n- 在左边界上：$u_{0,1} = 21.0$ V 和 $u_{0,2} = 21.0$ V。\n- 在右边界上：$u_{3,1} = 41.0$ V 和 $u_{3,2} = 41.0$ V。\n- 在下边界上：$u_{1,0} = 9.0$ V 和 $u_{2,0} = 9.0$ V。\n- 在上边界上：$u_{1,3} = 81.0$ V 和 $u_{2,3} = 81.0$ V。\n\n拉普拉斯方程使用标准的五点中心差分格式进行近似，该格式将一个内部点的电势与其四个最近邻点联系起来。使用雅可比方法求解由此产生的线性方程组。\n\n从所有四个内部点（其中 $i,j \\in \\{1,2\\}$）的初始猜测值 $u_{ij}^{(0)} = 0$ V 开始，计算经过一轮完整的雅可比方法迭代后这些点的电势数值。\n\n按此特定顺序提供 $u_{11}, u_{12}, u_{21}, u_{22}$ 的更新电势值。最终答案应为一组四个数字。最终答案中不要包含单位。", "solution": "在均匀网格上使用标准五点中心差分格式离散化的二维拉普拉斯方程，对于一个内部节点 $(i,j)$，可得：\n$$\n\\frac{u_{i+1,j}-2u_{i,j}+u_{i-1,j}}{h^{2}}+\\frac{u_{i,j+1}-2u_{i,j}+u_{i,j-1}}{h^{2}}=0,\n$$\n这可以简化为平均值关系式\n$$\nu_{i,j}=\\frac{1}{4}\\left(u_{i+1,j}+u_{i-1,j}+u_{i,j+1}+u_{i,j-1}\\right).\n$$\n雅可比迭代使用上一次迭代的邻近点值来更新每个内部点：\n$$\nu_{i,j}^{(k+1)}=\\frac{1}{4}\\left(u_{i+1,j}^{(k)}+u_{i-1,j}^{(k)}+u_{i,j+1}^{(k)}+u_{i,j-1}^{(k)}\\right),\n$$\n边界值保持不变。根据初始猜测值 $u_{ij}^{(0)}=0$（其中 $i,j\\in\\{1,2\\}$）和给定的边界数据，第一次迭代的更新如下：\n\n对于 $u_{11}$：\n$$\nu_{11}^{(1)}=\\frac{1}{4}\\left(u_{21}^{(0)}+u_{01}+u_{12}^{(0)}+u_{10}\\right)=\\frac{1}{4}\\left(0+21+0+9\\right)=7.5.\n$$\n\n对于 $u_{12}$：\n$$\nu_{12}^{(1)}=\\frac{1}{4}\\left(u_{22}^{(0)}+u_{02}+u_{13}+u_{11}^{(0)}\\right)=\\frac{1}{4}\\left(0+21+81+0\\right)=25.5.\n$$\n\n对于 $u_{21}$：\n$$\nu_{21}^{(1)}=\\frac{1}{4}\\left(u_{31}+u_{11}^{(0)}+u_{22}^{(0)}+u_{20}\\right)=\\frac{1}{4}\\left(41+0+0+9\\right)=12.5.\n$$\n\n对于 $u_{22}$：\n$$\nu_{22}^{(1)}=\\frac{1}{4}\\left(u_{32}+u_{12}^{(0)}+u_{23}+u_{21}^{(0)}\\right)=\\frac{1}{4}\\left(41+0+81+0\\right)=30.5.\n$$\n\n因此，从零开始经过一次雅可比迭代后，按顺序 $(u_{11},u_{12},u_{21},u_{22})$ 排列的更新电势值为 $(7.5, 25.5, 12.5, 30.5)$。", "answer": "$$\\boxed{\\begin{pmatrix} 7.5  25.5  12.5  30.5 \\end{pmatrix}}$$", "id": "2172039"}, {"introduction": "实际应用中的几何形状往往比简单的正方形更复杂。本练习将挑战你如何将有限差分原理应用于一个带有“凹角”的区域，这是工程问题中常见的几何特征。通过推导这个特殊节点上的正确离散方程，你将加深对五点差分格式是一个局部近似的理解——只要网格上定义了必要的相邻点，该格式就依然有效。[@problem_id:2172050]", "problem": "一位工程师正在分析一个特殊形状处理器芯片上的稳态温度分布。该芯片的几何形状可以建模为一个二维L形域。该域内的温度分布 $u(x,y)$ 由拉普拉斯方程 $\\nabla^2 u = 0$ 控制。\n\n该域定义为方形区域 $[-L, L] \\times [-L, L]$ 中除去第一象限的点集，即移除所有 $x  0$ 且 $y  0$ 的点。为了数值求解该方程，该域被一个间距为 $h$ 的均匀方形网格离散化，其中 $L$ 是 $h$ 的一个大的整数倍。\n\n我们关注位于原点 $P_0 = (0,0)$ 的独特“凹角”节点。设此节点的温度为 $u_0$。沿坐标轴的四个相邻网格点的温度表示为：\n- $u_N$ 于北点 $(0, h)$\n- $u_S$ 于南点 $(0, -h)$\n- $u_E$ 于东点 $(h, 0)$\n- $u_W$ 于西点 $(-h, 0)$\n\n请注意，点 $(0,h)$ 和 $(h,0)$ 位于L形域的边界上，而 $(0,-h)$ 和 $(-h,0)$ 是内部点。\n\n使用标准的二阶精度有限差分法（五点差分格式）在节点 $P_0$ 处近似拉普拉斯方程，以下哪个表达式正确地关联了 $u_0$ 与其邻近点？\n\nA) $u_0 = \\frac{1}{2} (u_S + u_W)$\n\nB) $u_0 = \\frac{1}{4} (u_N + u_S + u_E + u_W)$\n\nC) $u_0 = \\frac{1}{2} (u_N + u_E)$\n\nD) $u_0 = \\frac{1}{4} (2u_S + 2u_W + u_N + u_E)$\n\nE) 标准方法不适用于凹角。", "solution": "在点 $P_{0}=(0,0)$ 处，拉普拉斯方程为 $u_{xx}+u_{yy}=0$。在间距为 $h$ 的均匀网格上，标准的二阶中心差分给出\n$$\nu_{xx}(0,0)\\approx \\frac{u_{E}-2u_{0}+u_{W}}{h^{2}},\\qquad\nu_{yy}(0,0)\\approx \\frac{u_{N}-2u_{0}+u_{S}}{h^{2}}.\n$$\n在 $P_{0}$ 处施加 $u_{xx}+u_{yy}=0$ 可得\n$$\n\\frac{u_{E}-2u_{0}+u_{W}}{h^{2}}+\\frac{u_{N}-2u_{0}+u_{S}}{h^{2}}=0,\n$$\n化简为\n$$\nu_{E}+u_{W}+u_{N}+u_{S}-4u_{0}=0.\n$$\n求解 $u_{0}$ 得\n$$\nu_{0}=\\frac{1}{4}\\left(u_{N}+u_{S}+u_{E}+u_{W}\\right).\n$$\n尽管 $(0,h)$ 和 $(h,0)$ 是边界节点，但它们的值由边界条件提供，并且五点差分格式在 $P_{0}$ 处仍然有效，因为所有四个轴向邻近点都存在于网格上。因此，正确的关系是标准的四点平均值。", "answer": "$$\\boxed{B}$$", "id": "2172050"}, {"introduction": "当偏微分方程被离散化后，下一个关键步骤是高效地求解由此产生的庞大线性方程组。本练习将焦点从离散化细节转向计算性能，通过比较直接求解器和迭代求解器这两大类算法。通过分析它们的计算复杂度和规模可扩展性，你将理解为何算法选择对于解决大规模科学计算问题至关重要，以及如何预估特定计算方法的实际应用极限。[@problem_id:3128786]", "problem": "考虑单位正方形域上的二维拉普拉斯方程，其狄利克雷边界条件指定为 $\\nabla^2 u = 0$ 在 $[0,1]\\times[0,1]$ 上，且在边界上 $u=0$。在均匀网格上使用标准的五点有限差分格式，设每个轴上有 $N$ 个内部网格点，产生 $M=N^2$ 个未知数。离散线性系统的形式为 $A \\mathbf{u} = \\mathbf{b}$，其中 $A$ 是稀疏对称正定（SPD）矩阵。\n\n考虑计算科学实验室中常用的两类求解器：\n\n- 一种基于嵌套剖分和 Cholesky 分解的直接求解器，该求解器专为结构化二维网格定制。\n- 一种多重网格 V-循环迭代求解器，在每个层级上都有平滑操作。\n\n您的任务是从第一性原理出发，推导每种求解器的浮点运算次数如何随网格参数 $N$ 缩放，然后使用这些缩放关系来生成求解时间预测和实际限制。假设以下建模常数用于捕捉实现开销和每步运算成本：\n- 直接求解器的比例常数 $\\alpha = 40$。\n- 多重网格求解器的比例常数 $\\beta = 10$。\n这两个常数都是您推导出的主阶缩放的无量纲乘数。\n\n将硬件的持续浮点执行速率定义为 $r$（单位：浮点运算/秒），并将每次求解允许的最大墙钟时间定义为 $T_{\\max}$（单位：秒）。给定求解器模型的求解时间 $t$ 是通过将总运算次数除以 $r$ 计算得出的，并且必须以秒为单位表示。\n\n对于每个测试用例，您的程序必须：\n1. 计算直接求解器的预测求解时间 $t_{\\mathrm{direct}}$，单位为 $\\mathrm{s}$。\n2. 计算多重网格求解器的预测求解时间 $t_{\\mathrm{mg}}$，单位为 $\\mathrm{s}$。\n3. 计算使得直接求解器的预测时间不超过 $T_{\\max}$ 的最大整数 $N_{\\max,\\mathrm{direct}}$。\n4. 计算使得多重网格求解器的预测时间不超过 $T_{\\max}$ 的最大整数 $N_{\\max,\\mathrm{mg}}$。\n\n您必须以秒为单位表示所有时间，并四舍五入到六位小数。输出不得包含任何单位符号，只包含数值。不涉及角度，因此不需要角度单位。\n\n使用以下测试套件，每个用例以三元组 $(N,r,T_{\\max})$ 的形式给出：\n- 用例 A：$(N = 8,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例 B：$(N = 64,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例 C：$(N = 256,\\ r = 2\\times 10^{10},\\ T_{\\max} = 2)$。\n- 用例 D：$(N = 512,\\ r = 1\\times 10^{11},\\ T_{\\max} = 1)$。\n- 用例 E（边界情况）：$(N = 1,\\ r = 1\\times 10^{9},\\ T_{\\max} = 0.1)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例的结果本身是一个四元素列表，顺序为 $[t_{\\mathrm{direct}},t_{\\mathrm{mg}},N_{\\max,\\mathrm{direct}},N_{\\max,\\mathrm{mg}}]$。例如，整体输出格式必须是\n$[[t_{\\mathrm{direct},A},t_{\\mathrm{mg},A},N_{\\max,\\mathrm{direct},A},N_{\\max,\\mathrm{mg},A}],[t_{\\mathrm{direct},B},t_{\\mathrm{mg},B},N_{\\max,\\mathrm{direct},B},N_{\\max,\\mathrm{mg},B}],\\dots]$，\n所有数值条目都已显示，时间四舍五入到六位小数，且没有多余的空格。\n\n请从有限差分法和求解器结构的基本属性出发，设计您的算法并计算答案，不要使用提供给您的快捷公式。所有数值输出必须是指定的整数或浮点数。", "solution": "问题陈述已经过严格审查，并被确定为有效。它在科学上基于计算科学的既定原则，特别是偏微分方程的数值解。该问题是适定的，提供了推导唯一、有意义解所需的所有数据和定义。语言客观，约束条件一致且物理上合理。\n\n任务是分析两种不同求解器算法的计算复杂度，这两种算法用于求解二维拉普拉斯方程 $\\nabla^2 u = 0$ 的有限差分网格化所产生的线性系统。求解域是单位正方形 $[0,1]\\times[0,1]$，具有齐次狄利克雷边界条件（边界上 $u=0$）。离散化在均匀网格上使用标准的五点格式，每个轴上有 $N$ 个内部点，从而产生一个包含 $M = N^2$ 个线性方程的系统 $A \\mathbf{u} = \\mathbf{b}$。已知矩阵 $A$ 是稀疏对称正定（SPD）的。\n\n我们首先推导每种求解器系列的浮点运算（FLOPS）次数随网格参数 $N$ 的缩放关系。\n\n**1. 直接求解器：嵌套剖分与 Cholesky 分解**\n\n直接求解器通过分解矩阵 $A$ 来找到精确解（在机器精度范围内）。对于 SPD 矩阵，Cholesky 分解（$A=LL^T$）是首选方法。Cholesky 分解的计算成本高度依赖于未知数的排序，这会影响“填充”量——即 $A$ 中的零元素在因子 $L$ 中变为非零元素的数量。\n\n对网格点进行简单的字典序排序会导致矩阵 $A$ 的带宽约为 $N$。带状 Cholesky 分解的 FLOPS 缩放为 $O(M \\cdot (\\text{带宽})^2) = O(N^2 \\cdot N^2) = O(N^4)$。\n\n然而，问题指定使用**嵌套剖分**。对于由基于网格的问题产生的矩阵，这是一种效率高得多的排序策略。该方法递归地划分网格。对于二维网格，选择一个网格点的“分隔集”将网格分成两个子域。与分隔集相关的未知数最后排序。此过程递归地应用于子域。由此产生的矩阵结构可最大限度地减少填充。\n\n对于具有 $M=N^2$ 个未知数的二维问题，George 和 Liu 的开创性工作表明，使用嵌套剖分进行 Cholesky 分解的运算次数缩放为 $O(M^{3/2})$。用 $N$ 表示如下：\n$$\n\\text{FLOPS}_{\\mathrm{direct}} \\propto M^{3/2} = (N^2)^{3/2} = N^3\n$$\n问题提供了一个无量纲比例常数 $\\alpha = 40$ 来模拟与实现相关的开销。因此，总运算次数 $C_{\\mathrm{direct}}$ 为：\n$$\nC_{\\mathrm{direct}}(N) = \\alpha N^3 = 40 N^3\n$$\n\n**2. 迭代求解器：多重网格 V-循环**\n\n多重网格是一种先进的迭代方法，以其最优效率而闻名。其基本原理是，简单的松弛平滑器（如 Jacobi 或 Gauss-Seidel）能有效减少误差的高频分量，但对低频（平滑）误差分量的抑制速度非常慢。多重网格方法通过在更粗的网格上表示平滑误差来克服这一问题，在粗网格上，这些误差变得相对高频，可以被有效消除。\n\n一个单一的多重网格 V-循环包括：\n- 在细网格上进行几次预平滑步骤。\n- 将残差误差限制到更粗的网格上。\n- 在粗网格问题上递归调用求解器。这一过程持续进行，直到达到一个非常粗的网格，此时问题可以以可忽略不计的成本直接求解。\n- 将粗网格校正延长（插值）回细网格。\n- 在细网格上进行几次后平滑步骤。\n\n在具有 $M$ 个点的网格上，平滑、限制和延长的成本与 $M$ 成正比。如果网格尺寸在每一层都以一个常数因子（对于二维网格通常是因子 4）减小，则一个 V-循环的总功 $W(M)$ 遵循递推关系 $W(M) \\approx cM + W(M/4)$。其解是一个几何级数：\n$$\nW(M) \\approx cM + \\frac{cM}{4} + \\frac{cM}{16} + \\dots = cM \\sum_{k=0}^{\\infty} \\left(\\frac{1}{4}\\right)^k = cM \\frac{1}{1 - 1/4} = \\frac{4}{3}cM\n$$\n因此，每个 V-循环的功为 $O(M)$。多重网格的一个关键理论结果是，对于像拉普拉斯方程这样的椭圆问题，每个 V-循环的收敛率是一个与网格大小 $M$ 无关的常数。这意味着，只需固定少数几个 V-循环就足以将问题求解到给定的精度。\n\n因此，多重网格求解器的总运算次数与未知数数量 $M$ 成正比。\n$$\n\\text{FLOPS}_{\\mathrm{mg}} \\propto M = N^2\n$$\n使用提供的比例常数 $\\beta = 10$，总运算次数 $C_{\\mathrm{mg}}$ 为：\n$$\nC_{\\mathrm{mg}}(N) = \\beta N^2 = 10 N^2\n$$\n\n**3. 求解时间与最大问题规模**\n\n给定硬件的持续浮点执行速率 $r$，求解时间 $t$ 是总运算次数除以 $r$。\n\n对于直接求解器：\n$$\nt_{\\mathrm{direct}}(N, r) = \\frac{C_{\\mathrm{direct}}(N)}{r} = \\frac{40 N^3}{r}\n$$\n对于多重网格求解器：\n$$\nt_{\\mathrm{mg}}(N, r) = \\frac{C_{\\mathrm{mg}}(N)}{r} = \\frac{10 N^2}{r}\n$$\n\n在最大墙钟时间 $T_{\\max}$ 内可解的最大整数网格尺寸 $N_{\\max}$ 是通过设置 $t \\le T_{\\max}$ 并求解 $N$ 得到的。\n\n对于直接求解器，我们在 $\\frac{40 N^3}{r} \\le T_{\\max}$ 中求解 $N$：\n$$\nN^3 \\le \\frac{r T_{\\max}}{40} \\implies N \\le \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3}\n$$\n因为 $N$ 必须是整数，我们对结果取底：\n$$\nN_{\\max,\\mathrm{direct}} = \\left\\lfloor \\left( \\frac{r T_{\\max}}{40} \\right)^{1/3} \\right\\rfloor\n$$\n\n对于多重网格求解器，我们在 $\\frac{10 N^2}{r} \\le T_{\\max}$ 中求解 $N$：\n$$\nN^2 \\le \\frac{r T_{\\max}}{10} \\implies N \\le \\sqrt{\\frac{r T_{\\max}}{10}}\n$$\n作为一个整数，$N$ 是结果的底：\n$$\nN_{\\max,\\mathrm{mg}} = \\left\\lfloor \\sqrt{\\frac{r T_{\\max}}{10}} \\right\\rfloor\n$$\n\n现在将这些公式应用于每个测试用例以计算所需的数值结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes time-to-solution predictions and practical limits for direct\n    and multigrid solvers for the 2D Laplace equation.\n    \"\"\"\n    # Define the test cases from the problem statement as tuples of (N, r, T_max).\n    test_cases = [\n        # Case A\n        (8, 2e10, 2),\n        # Case B\n        (64, 2e10, 2),\n        # Case C\n        (256, 2e10, 2),\n        # Case D\n        (512, 1e11, 1),\n        # Case E\n        (1, 1e9, 0.1),\n    ]\n\n    # Proportionality constants from the problem.\n    # alpha for the direct solver (scaling with N^3).\n    alpha = 40.0\n    # beta for the multigrid solver (scaling with N^2).\n    beta = 10.0\n\n    all_results = []\n    for case in test_cases:\n        N, r, T_max = case\n\n        # 1. Compute predicted time-to-solution for the direct solver.\n        # Operation count C_direct = alpha * N^3.\n        # Time t_direct = C_direct / r.\n        t_direct = (alpha * N**3) / r\n\n        # 2. Compute predicted time-to-solution for the multigrid solver.\n        # Operation count C_mg = beta * N^2.\n        # Time t_mg = C_mg / r.\n        t_mg = (beta * N**2) / r\n\n        # 3. Compute the largest integer N_max,direct.\n        # We need t_direct = T_max, which is (alpha * N^3) / r = T_max.\n        # This simplifies to N = (r * T_max / alpha)^(1/3).\n        # Since N must be an integer, we take the floor.\n        N_max_direct = int(((r * T_max) / alpha)**(1/3))\n\n        # 4. Compute the largest integer N_max,mg.\n        # We need t_mg = T_max, which is (beta * N^2) / r = T_max.\n        # This simplifies to N = sqrt(r * T_max / beta).\n        # Since N must be an integer, we take the floor.\n        N_max_mg = int(((r * T_max) / beta)**(0.5))\n\n        # Format the case result as a string to exactly match the required output format,\n        # avoiding spaces that str(list) would introduce.\n        # Times are formatted to six decimal places.\n        case_result_str = f\"[{t_direct:.6f},{t_mg:.6f},{N_max_direct},{N_max_mg}]\"\n        all_results.append(case_result_str)\n\n    # Final print statement in the exact required format.\n    # The output is a single line: a list of lists, represented as a string.\n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "3128786"}]}