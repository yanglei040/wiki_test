{"hands_on_practices": [{"introduction": "本练习旨在探讨有限体积法的核心原则：守恒性。您将为一个在非均匀网格上、具有可变材料属性的扩散方程实现一个求解器。通过这个练习 ([@problem_id:3130123])，您将通过数值方式验证一个正确构建的守恒格式能够完美地维持系统总质量，从而切实理解为何有限体积法是处理守恒性至关重要问题的首选方法。", "problem": "考虑定义在区间 $[0,1]$ 上守恒形式的一维扩散方程：\n$$\nu_t = (k(x)\\,u_x)_x,\n$$\n其中 $u(x,t)$ 是标量场，$k(x) \\gt 0$ 是一个给定的、足够光滑的扩散率场。设在具有 $N$ 个单元的通用非均匀网格上使用单元中心有限体积法（FVM）。将单元交界面记为 $\\{x_{i-\\tfrac{1}{2}}\\}_{i=1}^{N+1}$，其中 $x_{\\tfrac{1}{2}} = 0$ 且 $x_{N+\\tfrac{1}{2}} = 1$；单元中心记为 $x_i = \\tfrac{1}{2}(x_{i-\\tfrac{1}{2}}+x_{i+\\tfrac{1}{2}})$；单元宽度记为 $\\Delta x_i = x_{i+\\tfrac{1}{2}}-x_{i-\\tfrac{1}{2}}$。设单元平均值为 $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{x_{i-\\tfrac{1}{2}}}^{x_{i+\\tfrac{1}{2}}} u(x,t)\\,dx$。将离散总质量定义为\n$$\nM(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i.\n$$\n\n仅从每个控制体上的积分平衡和散度（Gauss）定理出发，为单元 $\\{C_i\\}_{i=1}^N$ 推导一个形如下式的守恒半离散 FVM：\n$$\n\\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = F_{i-\\tfrac{1}{2}} - F_{i+\\tfrac{1}{2}},\n$$\n其中 $F_{i\\pm\\tfrac{1}{2}}$ 是交界面上物理扩散通量的一致性数值近似。然后使用时间步长 $\\Delta t \\gt 0$ 的一阶隐式（向后）Euler 方法进行时间离散化，从而在每个时间步为 $\\{\\bar{u}_i^{n+1}\\}_{i=1}^N$ 获得一个线性系统。在每个内部交界面上使用一个两点通量近似，该近似仅依赖于相邻单元以及从中心到交界面的距离，并近似了相邻单元中心之间的通量梯度。对于非均匀扩散率，使用与一维串联电阻一致的交界面系数。\n\n施加齐次 Neumann 边界条件（在 $x=0$ 和 $x=1$ 处通量为零）或周期性边界条件（通过将首尾单元等同，使得通过 $x=0$ 和 $x=1$ 的通量相互抵消）。在下文所有指定齐次 Neumann 条件的情况下，要求边界通量在离散意义上精确为零。对于周期性边界条件，通过边界将第一个和最后一个单元耦合起来。\n\n对所有测试用例使用以下初始条件，通过精确的单元平均值指定：\n$$\nu(x,0) = 1 + \\sin(2\\pi x),\n$$\n因此对于每个边界为 $a = x_{i-\\tfrac{1}{2}}$ 和 $b = x_{i+\\tfrac{1}{2}}$ 的单元 $i$，\n$$\n\\bar{u}_i(0) = 1 + \\frac{1}{b-a}\\int_a^b \\sin(2\\pi x)\\,dx = 1 + \\frac{-\\cos(2\\pi b) + \\cos(2\\pi a)}{2\\pi (b-a)}.\n$$\n区域长度为 $1$，因此在 $t=0$ 时的精确连续总质量等于 $1$。根据单元平均值和宽度计算离散质量 $M(0)$。\n\n实现全隐式 FVM 时间步进，并对以下测试组检验离散总质量 $M(t)$ 在隐式 Euler 方法下是否守恒。对于每个测试，将解推进 $n_{\\text{steps}}$ 步，步长为 $\\Delta t$，并将 $M(n_{\\text{steps}}\\Delta t)$ 与 $M(0)$ 进行比较。\n\n- 测试 1 (理想情况): $N=50$, 均匀网格 $\\Delta x_i = 1/N$, 齐次 Neumann 边界条件, 恒定扩散率 $k(x) \\equiv 1$, $\\Delta t = 0.1$, $n_{\\text{steps}} = 5$。\n- 测试 2 (非均匀与非均质): $N=37$, 非均匀网格，其宽度与 $1 + 0.6\\sin(2\\pi \\tfrac{i-0.5}{N})$ ($i=1,\\dots,N$) 成正比，然后进行归一化以使 $\\sum_i \\Delta x_i = 1$；齐次 Neumann 边界条件；非均质扩散率 $k(x) = 1 + 0.4 x$；$\\Delta t = 0.05$；$n_{\\text{steps}} = 10$。\n- 测试 3 (周期性，强渐变网格): $N=41$, 非均匀网格，其宽度成等比数列 $\\Delta x_i \\propto r^{i-1}$ ($i=1,\\dots,N$, $r=1.3$) , 然后进行归一化以使 $\\sum_i \\Delta x_i = 1$；周期性边界条件；非均质扩散率 $k(x) = 2 + 0.5\\cos(2\\pi x)$；$\\Delta t = 0.05$；$n_{\\text{steps}} = 7$。\n\n你的程序必须：\n- 根据指定的 $\\Delta x_i$ 显式构造网格以使 $\\sum_i \\Delta x_i = 1$，为内部交界面使用基于相邻单元中心的两点通量近似来组装守恒的 FVM 线性系统，施加指定的边界条件，并使用隐式 Euler 方法进行推进。\n- 为每个测试计算离散总质量 $M(0)$ 和 $M(n_{\\text{steps}}\\Delta t)$。\n- 对于每个测试，确定一个布尔结果：如果 $\\left|M(n_{\\text{steps}}\\Delta t) - M(0)\\right| \\le 10^{-12}$，则返回 $\\,\\text{True}\\,$，否则返回 $\\,\\text{False}\\,$。\n\n最终输出格式：你的程序应生成单行输出，其中包含一个用方括号括起来的、由逗号分隔的三个布尔结果列表（例如，$[\\,\\text{True},\\text{False},\\text{True}\\,]$）。不应打印任何额外文本。由于问题是无量纲的，因此不需要物理单位。问题不涉及角度。程序中所有数值都应视为无量纲标量。", "solution": "该问题要求推导并实现一种用于一维扩散方程的单元中心有限体积法（FVM），然后测试其在不同条件下的质量守恒特性。\n\n### 1. 有限体积公式\n控制偏微分方程（PDE）以守恒形式给出：\n$$ u_t = (k(x)\\,u_x)_x $$\n我们通过对该方程在一个控制体 $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 上积分来应用有限体积法：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx $$\n左侧（LHS），使用单元平均值 $\\bar{u}_i(t) = \\frac{1}{\\Delta x_i}\\int_{C_i} u(x,t)\\,dx$ 的定义和 Leibniz 积分法则，变为：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u_t \\,dx = \\frac{d}{dt}\\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} u(x,t)\\,dx = \\frac{d}{dt}\\left(\\bar{u}_i(t) \\Delta x_i\\right) $$\n右侧（RHS）使用微积分基本定理（散度定理的一维形式）进行积分：\n$$ \\int_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} (k(x)\\,u_x)_x \\,dx = \\left[ k(x)u_x \\right]_{x_{i-\\frac{1}{2}}}^{x_{i+\\frac{1}{2}}} = (k u_x)\\Big|_{x_{i+\\frac{1}{2}}} - (k u_x)\\Big|_{x_{i-\\frac{1}{2}}} $$\n设 $G(x,t) = k(x)u_x$ 为物理扩散通量。单元 $i$ 的精确平衡方程为：\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G(x_{i+\\frac{1}{2}}, t) - G(x_{i-\\frac{1}{2}}, t) $$\n然后，通过用数值通量 $G_{i\\pm\\frac{1}{2}}$（单元平均值 $\\bar{u}_j$ 的函数）来近似单元交界面（面）上的通量 $G$，对此方程进行半离散化。这得到了半离散 FVM 系统：\n$$ \\frac{d}{dt}\\left(\\bar{u}_i \\Delta x_i\\right) = G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}} $$\n注意，问题陈述中使用 $F$ 表示数值通量，但其符号约定与积分直接得到的结果不同。为避免歧义，我们在此使用 $G$ 的定义。关键在于“通量流入减通量流出”的守恒结构，在重新排列以匹配问题的形式后，会产生相同的底层模板。\n\n### 2. 数值通量近似\n在单元 $i$ 和 $i+1$ 之间的交界面上的通量 $G_{i+\\frac{1}{2}}$ 使用一个涉及 $\\bar{u}_i$ 和 $\\bar{u}_{i+1}$ 的两点模板进行近似。交界面上的导数 $u_x$ 通过单元中心 $x_i$ 和 $x_{i+1}$ 之间的有限差分来近似：\n$$ G_{i+\\frac{1}{2}} \\approx k_{i+\\frac{1}{2}} \\frac{\\bar{u}_{i+1} - \\bar{u}_i}{x_{i+1} - x_i} $$\n其中 $k_{i+\\frac{1}{2}}$ 是交界面上的有效扩散率。按照规定，对于非均质介质，选择该值以与串联电阻一致。在长度为 $L$、扩散率为 $k$ 的线段上，扩散的“阻力”为 $L/k$。单元中心 $x_i$ 和 $x_{i+1}$ 之间的总阻力是从 $x_i$ 到 $x_{i+\\frac{1}{2}}$ 和从 $x_{i+\\frac{1}{2}}$ 到 $x_{i+1}$ 的阻力之和。这导致有效传导率 $k_{i+\\frac{1}{2}} / (x_{i+1}-x_i) $ 的调和平均：\n$$ \\frac{1}{\\text{Total Resistance}} = \\frac{1}{\\frac{x_{i+1}-x_i}{k_{i+\\frac{1}{2}}}} = \\frac{1}{\\frac{x_{i+\\frac{1}{2}}-x_i}{k(x_i)} + \\frac{x_{i+1}-x_{i+\\frac{1}{2}}}{k(x_{i+1})}} $$\n已知 $x_i = \\frac{1}{2}(x_{i-\\frac{1}{2}}+x_{i+\\frac{1}{2}})$ 和 $\\Delta x_i = x_{i+\\frac{1}{2}}-x_{i-\\frac{1}{2}}$，我们有 $x_{i+1}-x_i = \\frac{1}{2}(\\Delta x_i + \\Delta x_{i+1})$，$x_{i+\\frac{1}{2}}-x_i = \\frac{1}{2}\\Delta x_i$ 和 $x_{i+1}-x_{i+\\frac{1}{2}} = \\frac{1}{2}\\Delta x_{i+1}$。那么项 $(\\bar{u}_{i+1} - \\bar{u}_i)$ 的通量系数为：\n$$ \\beta_{i+\\frac{1}{2}} = \\frac{k_{i+\\frac{1}{2}}}{x_{i+1} - x_i} = \\frac{1}{\\frac{\\frac{1}{2}\\Delta x_i}{k(x_i)} + \\frac{\\frac{1}{2}\\Delta x_{i+1}}{k(x_{i+1})}} = \\frac{2}{\\frac{\\Delta x_i}{k(x_i)} + \\frac{\\Delta x_{i+1}}{k(x_{i+1})}} $$\n数值通量为 $G_{i+\\frac{1}{2}} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i)$。内部单元 $i$ 的半离散方程为：\n$$ \\Delta x_i \\frac{d\\bar{u}_i}{dt} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1} - \\bar{u}_i) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i - \\bar{u}_{i-1}) $$\n\n### 3. 隐式时间离散\n使用一阶隐式（向后）Euler 方法，我们近似 $\\frac{d\\bar{u}_i}{dt} \\approx \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t}$ 并在新的时间层 $n+1$ 上计算空间项：\n$$ \\Delta x_i \\frac{\\bar{u}_i^{n+1} - \\bar{u}_i^n}{\\Delta t} = \\beta_{i+\\frac{1}{2}}(\\bar{u}_{i+1}^{n+1} - \\bar{u}_i^{n+1}) - \\beta_{i-\\frac{1}{2}}(\\bar{u}_i^{n+1} - \\bar{u}_{i-1}^{n+1}) $$\n重新整理这些项，得到关于未知向量 $\\mathbf{u}^{n+1} = [\\bar{u}_1^{n+1}, \\dots, \\bar{u}_N^{n+1}]^T$ 的线性系统：\n$$ -\\frac{\\Delta t}{\\Delta x_i}\\beta_{i-\\frac{1}{2}}\\bar{u}_{i-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_i}(\\beta_{i-\\frac{1}{2}} + \\beta_{i+\\frac{1}{2}})\\right)\\bar{u}_i^{n+1} - \\frac{\\Delta t}{\\Delta x_i}\\beta_{i+\\frac{1}{2}}\\bar{u}_{i+1}^{n+1} = \\bar{u}_i^n $$\n该方程定义了线性系统 $A\\mathbf{u}^{n+1} = \\mathbf{u}^n$ 的第 $i$ 行。对于内部单元，矩阵 $A$ 是三对角的。\n\n### 4. 边界条件\n**齐次 Neumann**：边界通量为零，$G_{\\frac{1}{2}} = G_{N+\\frac{1}{2}} = 0$。\n对于单元 $i=1$：$\\Delta x_1 \\frac{d\\bar{u}_1}{dt} = G_{\\frac{3}{2}} - G_{\\frac{1}{2}} = G_{\\frac{3}{2}}$。系统的第一行变为：\n$$ \\left(1 + \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\n对于单元 $i=N$：$\\Delta x_N \\frac{d\\bar{u}_N}{dt} = G_{N+\\frac{1}{2}} - G_{N-\\frac{1}{2}} = -G_{N-\\frac{1}{2}}$。最后一行变为：\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\n得到的系统矩阵 $A$ 是三对角的。\n\n**周期性**：单元 $1$ 和 $N$ 相邻。我们定义 $\\bar{u}_0 \\equiv \\bar{u}_N$ 和 $\\bar{u}_{N+1} \\equiv \\bar{u}_1$。\n对于单元 $i=1$：$G_{\\frac{1}{2}} = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$。第一行包含一个关于 $\\bar{u}_N$ 的项：\n$$ -\\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{1}{2}}\\bar{u}_N^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_1}(\\beta_{\\frac{1}{2}} + \\beta_{\\frac{3}{2}})\\right)\\bar{u}_1^{n+1} - \\frac{\\Delta t}{\\Delta x_1}\\beta_{\\frac{3}{2}}\\bar{u}_2^{n+1} = \\bar{u}_1^n $$\n对于单元 $i=N$：$G_{N+\\frac{1}{2}} = \\beta_{N+\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N) = \\beta_{\\frac{1}{2}}(\\bar{u}_1 - \\bar{u}_N)$。最后一行包含一个关于 $\\bar{u}_1$ 的项：\n$$ -\\frac{\\Delta t}{\\Delta x_N}\\beta_{\\frac{1}{2}}\\bar{u}_1^{n+1} -\\frac{\\Delta t}{\\Delta x_N}\\beta_{N-\\frac{1}{2}}\\bar{u}_{N-1}^{n+1} + \\left(1 + \\frac{\\Delta t}{\\Delta x_N}(\\beta_{N-\\frac{1}{2}} + \\beta_{\\frac{1}{2}})\\right)\\bar{u}_N^{n+1} = \\bar{u}_N^n $$\n矩阵 $A$ 是循环三对角的。\n\n### 5. 质量守恒\n离散总质量为 $M(t) = \\sum_{i=1}^N \\bar{u}_i(t)\\,\\Delta x_i$。对半离散系统求时间导数并对所有单元求和：\n$$ \\frac{dM}{dt} = \\sum_{i=1}^N \\frac{d}{dt}(\\bar{u}_i \\Delta x_i) = \\sum_{i=1}^N (G_{i+\\frac{1}{2}} - G_{i-\\frac{1}{2}}) $$\n这是一个伸缩求和，其结果为 $G_{N+\\frac{1}{2}} - G_{\\frac{1}{2}}$，即跨越区域边界的净通量。\n- 对于齐次 Neumann 边界条件，$G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}} = 0$，因此 $\\frac{dM}{dt} = 0$。\n- 对于周期性边界条件，区域没有边界，$G_{N+\\frac{1}{2}} = G_{\\frac{1}{2}}$ 代表相同的内部通量，因此它们的差为零，且 $\\frac{dM}{dt} = 0$。\n\n半离散的这一性质也延续到全离散的隐式 Euler 格式中。对所有 $i$ 的全离散方程求和：\n$$ \\sum_{i=1}^N \\Delta x_i (\\bar{u}_i^{n+1} - \\bar{u}_i^n) = \\Delta t \\sum_{i=1}^N (G_{i+\\frac{1}{2}}^{n+1} - G_{i-\\frac{1}{2}}^{n+1}) $$\n$$ M^{n+1} - M^n = \\Delta t (G_{N+\\frac{1}{2}}^{n+1} - G_{\\frac{1}{2}}^{n+1}) $$\n对于 Neumann 和周期性边界条件，RHS 均为零。因此，$M^{n+1} = M^n$。所实现的格式是精确质量守恒的。计算结果中的任何偏差将完全由浮点算术误差引起。考虑到 $10^{-12}$ 的容差，我们预期测试会通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Main function to run the FVM simulation for all test cases.\n    \"\"\"\n\n    def run_one_case(N, mesh_type, bc_type, k_func, dt, n_steps):\n        \"\"\"\n        Sets up and runs a single test case for the FVM simulation.\n        \"\"\"\n        # 1. Mesh Generation\n        if mesh_type == 'uniform':\n            dx_unnormalized = np.ones(N)\n        elif mesh_type == 'proportional':\n            i_vals = np.arange(1, N + 1)\n            dx_unnormalized = 1.0 + 0.6 * np.sin(2.0 * np.pi * (i_vals - 0.5) / N)\n        elif mesh_type == 'geometric':\n            r = 1.3\n            i_vals = np.arange(N)\n            dx_unnormalized = r**i_vals\n        else:\n            raise ValueError(\"Unknown mesh type\")\n\n        # Normalize dx so that the domain length is 1\n        dx = dx_unnormalized / np.sum(dx_unnormalized)\n\n        # Calculate interface and center positions\n        x_interfaces = np.zeros(N + 1)\n        x_interfaces[1:] = np.cumsum(dx)\n        x_centers = 0.5 * (x_interfaces[:-1] + x_interfaces[1:])\n\n        # 2. Initial Condition\n        a = x_interfaces[:-1]\n        b = x_interfaces[1:]\n        # Use a small tolerance for the denominator to avoid division by zero\n        # This is not strictly necessary due to how the mesh is created, but is good practice.\n        den = 2.0 * np.pi * (b - a)\n        # For cases where a and b are very close, the fraction approaches 0\n        safe_den = np.where(np.abs(den)  1e-15, 1, den)\n        num = -np.cos(2.0 * np.pi * b) + np.cos(2.0 * np.pi * a)\n        frac = np.where(np.abs(den)  1e-15, 0, num / safe_den)\n        u_initial = 1.0 + frac\n\n        # 3. Initial Mass\n        mass_initial = np.dot(u_initial, dx)\n\n        # 4. Time Stepping\n        u_current = np.copy(u_initial)\n        k_vals = k_func(x_centers)\n\n        for _ in range(n_steps):\n            A = np.zeros((N, N))\n            b = u_current\n\n            # 5. Assemble matrix A\n            # Internal cells (i in 1..N-2)\n            if N > 1:\n                for i in range(1, N - 1):\n                    beta_left = 2.0 / (dx[i - 1] / k_vals[i - 1] + dx[i] / k_vals[i])\n                    beta_right = 2.0 / (dx[i] / k_vals[i] + dx[i + 1] / k_vals[i + 1])\n                    c_i = dt / dx[i]\n                    A[i, i - 1] = -c_i * beta_left\n                    A[i, i] = 1.0 + c_i * (beta_left + beta_right)\n                    A[i, i + 1] = -c_i * beta_right\n\n            # Boundary Conditions\n            if bc_type == 'neumann':\n                if N > 1:\n                    # First row (i=0)\n                    beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                    c_0 = dt / dx[0]\n                    A[0, 0] = 1.0 + c_0 * beta_right_0\n                    A[0, 1] = -c_0 * beta_right_0\n                    # Last row (i=N-1)\n                    beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                    c_N = dt / dx[N - 1]\n                    A[N - 1, N - 2] = -c_N * beta_left_N\n                    A[N - 1, N - 1] = 1.0 + c_N * beta_left_N\n                else: # N=1 case\n                    A[0,0] = 1.0\n\n            elif bc_type == 'periodic':\n                if N > 1:\n                    beta_periodic = 2.0 / (dx[N - 1] / k_vals[N - 1] + dx[0] / k_vals[0])\n                    # First row (i=0)\n                    beta_right_0 = 2.0 / (dx[0] / k_vals[0] + dx[1] / k_vals[1])\n                    c_0 = dt / dx[0]\n                    A[0, 0] = 1.0 + c_0 * (beta_periodic + beta_right_0)\n                    A[0, 1] = -c_0 * beta_right_0\n                    A[0, N - 1] = -c_0 * beta_periodic\n                    # Last row (i=N-1)\n                    beta_left_N = 2.0 / (dx[N - 2] / k_vals[N - 2] + dx[N - 1] / k_vals[N - 1])\n                    c_N = dt / dx[N - 1]\n                    A[N - 1, N - 1] = 1.0 + c_N * (beta_left_N + beta_periodic)\n                    A[N - 1, N - 2] = -c_N * beta_left_N\n                    A[N - 1, 0] = -c_N * beta_periodic\n                else: # N=1 case, periodic means it connects to itself.\n                    beta_self = 2.0 / (dx[0]/k_vals[0] + dx[0]/k_vals[0])\n                    c_0 = dt/dx[0]\n                    A[0,0] = 1.0 + c_0 * (beta_self + beta_self) # left and right are same\n            \n            # 6. Solve the linear system\n            u_next = linalg.solve(A, b)\n            u_current = u_next\n\n        # 7. Final Mass and comparison\n        mass_final = np.dot(u_current, dx)\n\n        return np.abs(mass_final - mass_initial) = 1e-12\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1\n        (50, 'uniform', 'neumann', lambda x: 1.0, 0.1, 5),\n        # Test 2\n        (37, 'proportional', 'neumann', lambda x: 1.0 + 0.4 * x, 0.05, 10),\n        # Test 3\n        (41, 'geometric', 'periodic', lambda x: 2.0 + 0.5 * np.cos(2.0 * np.pi * x), 0.05, 7),\n    ]\n\n    results = []\n    for params in test_cases:\n        N, mesh_t, bc_t, k_f, dt, n_s = params\n        # The k_func needs to be vectorized if it's not already\n        k_func_vec = np.vectorize(k_f) if not isinstance(k_f(0.5), np.ndarray) else k_f\n        result = run_one_case(N, mesh_t, bc_t, k_func_vec, dt, n_s)\n        results.append(result)\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130123"}, {"introduction": "在确认了守恒特性之后，我们现在转向有限体积法的另一个关键方面：数值通量的设计。本练习对比了用于线性平流方程的简单中心通量和基于物理动机的迎风通量。您将亲身体会到为何一个直观的选择可能导致不稳定和非物理的结果，以及迎风格式如何正确地捕捉信息传播方向以确保解的稳定性 ([@problem_id:3130164])。", "problem": "要求您在线性守恒律的有限体积法背景下，构建、验证并以编程方式展示一个反例。考虑一维周期性区域上的标量线性平流方程 $u_t + a u_x = 0$，该区域具有 $N$ 个单元的均匀网格。令 $\\bar{u}_i^n$ 表示在时间 $t^n$ 时单元 $i$ 中的网格平均值。对于时间步长为 $\\Delta t$、空间网格尺寸为 $\\Delta x$ 的一个显式前向欧拉时间步，其有限体积更新是通过在每个控制体上对守恒律进行积分，并用选定的数值通量来近似物理通量而得到的。将单元 $i$ 和 $i+1$ 之间界面处的数值通量记为 $F_{i+\\frac{1}{2}}^n$。更新公式为\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right),\n$$\n并采用周期性边界条件。定义离散熵\n$$\nE^n = \\sum_{i=0}^{N-1} \\left|\\bar{u}_i^n\\right|.\n$$\n需要考虑两种数值通量：\n- 中心通量：$F_{i+\\frac{1}{2}}^n = a \\,\\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}$。\n- 迎风通量：如果 $a  0$，则 $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_i^n$；如果 $a  0$，则 $F_{i+\\frac{1}{2}}^n = a\\,\\bar{u}_{i+1}^n$；如果 $a=0$，则 $F_{i+\\frac{1}{2}}^n = 0$。\n\n您的任务是实现一个程序，对下面测试套件中的每个测试用例，使用中心通量和迎风通量（均采用周期性边界条件）执行单个前向欧拉时间步，计算每种通量对应的 $E^n$ 和 $E^{n+1}$，并为每个测试用例报告两个布尔值：\n- 一个布尔值，指示中心通量是否违反离散熵单调性，定义为中心通量的 $E^{n+1}  E^n$。\n- 一个布尔值，指示迎风通量是否违反离散熵单调性，定义为迎风通量的 $E^{n+1}  E^n$。\n\nCourant–Friedrichs–Lewy (CFL) 数为 $\\nu = \\frac{a\\,\\Delta t}{\\Delta x}$。使用以下测试套件，每个测试用例由 $(N, a, \\Delta x, \\Delta t, \\text{初始数据})$ 指定，其中初始数据是 $i = 0,1,\\ldots,N-1$ 的 $\\bar{u}_i^0$ 列表：\n1. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.9$, 初始数据 $[1,0,0,0]$。\n2. $N = 4$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 1.0$, 初始数据 $[1,0,0,0]$。\n3. $N = 4$, $a = -1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.7$, 初始数据 $[0,0,0,1]$。\n4. $N = 4$, $a = 0.0$, $\\Delta x = 1.0$, $\\Delta t = 0.5$, 初始数据 $[-2,1,0,3]$。\n5. $N = 5$, $a = 1.0$, $\\Delta x = 1.0$, $\\Delta t = 0.6$, 初始数据 $[0,1,-1,0,0]$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例的结果是一个不含空格的、包含两个布尔值的列表。例如，最终输出应类似于\n[[True,False],[True,False],[True,False],[False,False],[True,False]]。", "solution": "该问题要求在标量线性平流方程 $u_t + a u_x = 0$ 的有限体积法框架内，对两种不同数值通量函数的离散熵单调性进行计算验证。分析是在一维周期性区域上针对单个时间步进行的。\n\n有限体积法基于守恒律的积分形式。将 $u_t + f(u)_x=0$（其中通量为 $f(u)=au$）在宽度为 $\\Delta x$ 的控制体 $C_i = [x_{i-\\frac{1}{2}}, x_{i+\\frac{1}{2}}]$ 和时长为 $\\Delta t$ 的时间区间 $[t^n, t^{n+1}]$ 上积分，可以得到网格平均值 $\\bar{u}_i(t) = \\frac{1}{\\Delta x} \\int_{C_i} u(x,t) dx$ 的精确关系式：\n$$\n\\bar{u}_i(t^{n+1}) = \\bar{u}_i(t^n) - \\frac{1}{\\Delta x} \\int_{t^n}^{t^{n+1}} \\left( f(u(x_{i+\\frac{1}{2}},t)) - f(u(x_{i-\\frac{1}{2}},t)) \\right) dt\n$$\n应用一阶前向欧拉时间积分，并用数值通量函数 $F$ 近似网格界面处的精确通量 $f(u)$，我们便得到问题描述中给出的半离散有限体积格式：\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x}\\left(F_{i+\\frac{1}{2}}^n - F_{i-\\frac{1}{2}}^n\\right)\n$$\n其中 $\\bar{u}_i^n \\approx \\bar{u}_i(t^n)$，$F_{i\\pm\\frac{1}{2}}^n$ 是数值通量，它依赖于界面附近的网格平均值。Courant–Friedrichs–Lewy (CFL) 数定义为无量纲比率 $\\nu = \\frac{a \\Delta t}{\\Delta x}$。我们研究数值通量 $F$ 的两种定义。\n\n离散熵定义为解向量的离散 $L^1$ 范数，$E^n = \\sum_{i=0}^{N-1} |\\bar{u}_i^n|$。问题要求检查是否存在熵违背，其定义为条件 $E^{n+1}  E^n$。\n\n**1. 中心通量格式**\n\n界面 $x_{i+\\frac{1}{2}}$ 处的中心通量定义为相邻单元 $i$ 和 $i+1$ 中状态对应通量值的算术平均值：\n$$\nF_{i+\\frac{1}{2}}^n = a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2}\n$$\n将此式代入通用的有限体积更新方程，可得：\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} \\left( a \\frac{\\bar{u}_i^n + \\bar{u}_{i+1}^n}{2} - a \\frac{\\bar{u}_{i-1}^n + \\bar{u}_i^n}{2} \\right)\n$$\n该表达式可简化为中心格式的更新规则：\n$$\n\\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{a \\Delta t}{2 \\Delta x} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n) = \\bar{u}_i^n - \\frac{\\nu}{2} (\\bar{u}_{i+1}^n - \\bar{u}_{i-1}^n)\n$$\n此格式等价于前向时间中心空间 (FTCS) 有限差分法。在数值分析中，一个公认的结论是 FTCS 格式对于像线性平流方程这样的纯双曲型方程是无条件不稳定的。这种不稳定性会导致伪振荡的产生和放大，从而使离散 $L^1$ 范数（即我们的熵 $E^n$）增长。因此，我们预期对于非平凡的初始数据，该格式将违反熵单调性条件，即 $E^{n+1}  E^n$。\n\n**2. 迎风通量格式**\n\n迎风通量的构建基于信息传播的方向，该方向由平流速度 $a$ 的符号决定。\n\n- 如果 $a  0$，波从左向右传播。界面 $x_{i+\\frac{1}{2}}$ 处的通量由单元 $i$ 中的“迎风”状态决定：\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_i^n\n  $$\n  更新规则变为：\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_i^n - a \\bar{u}_{i-1}^n) = (1-\\nu)\\bar{u}_i^n + \\nu\\bar{u}_{i-1}^n\n  $$\n\n- 如果 $a  0$，波从右向左传播。界面 $x_{i+\\frac{1}{2}}$ 处的通量由单元 $i+1$ 中的“迎风”状态决定：\n  $$\n  F_{i+\\frac{1}{2}}^n = a \\bar{u}_{i+1}^n\n  $$\n  更新规则变为：\n  $$\n  \\bar{u}_i^{n+1} = \\bar{u}_i^n - \\frac{\\Delta t}{\\Delta x} (a \\bar{u}_{i+1}^n - a \\bar{u}_i^n) = \\bar{u}_i^n - \\nu (\\bar{u}_{i+1}^n - \\bar{u}_i^n) = (1+\\nu)\\bar{u}_i^n - \\nu\\bar{u}_{i+1}^n\n  $$\n\n- 如果 $a=0$，通量为零，$F_{i+\\frac{1}{2}}^n = 0$，解是定常的，$\\bar{u}_i^{n+1} = \\bar{u}_i^n$。\n\n一阶迎风格式是条件稳定的。稳定性条件是 CFL 条件，$0 \\le |\\nu| \\le 1$。问题中提供的所有测试用例都满足此条件。当 $0 \\le \\nu \\le 1$ ($a0$) 或 $-1 \\le \\nu \\le 0$ ($a0$) 时，$\\bar{u}_i^{n+1}$ 的更新是前一时间步各值 $\\bar{u}_j^n$ 的一个凸组合。这是因为其系数非负且总和为 1。Harten 的一个关键结论指出，可以写成凸组合形式的格式是总变差递减 (TVD) 的。TVD 格式具有 $L^1$ 收缩的性质，这意味着离散 $L^1$ 范数不会增加：$E^{n+1} \\leq E^n$。因此，我们预期对于所有给定的测试用例，迎风格式都将满足离散熵单调性。\n\n**计算实现**\n\n程序化的解决方案为每个测试用例实现了这些步骤。\n1. 初始网格平均值 $\\bar{u}^0$ 存储在 NumPy 数组中。\n2. 计算初始熵 $E^0 = \\sum_{i=0}^{N-1} |\\bar{u}_i^0|$。\n3. 计算 CFL 数 $\\nu$。\n4. 对于两种格式，都使用向量化操作计算更新后的解 $\\bar{u}^1$。周期性边界条件通过使用 `numpy.roll` 来访问相邻元素 $\\bar{u}_{i-1}^0$ 和 $\\bar{u}_{i+1}^0$ 来实现。\n5. 通过对更新后的解数组中元素的绝对值求和，来计算最终熵 $E^1_{\\text{central}}$ 和 $E^1_{\\text{upwind}}$。\n6. 对于每种格式，将最终熵与初始熵进行比较，以确定是否满足违背条件 $E^{n+1}  E^n$。结果存储为一对布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the finite volume problem for a series of test cases.\n\n    For each case, it performs a single forward Euler time step for the 1D\n    linear advection equation using both central and upwind numerical fluxes.\n    It then checks if the discrete L1-norm (entropy) has increased for\n    each scheme.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, a, dx, dt, initial_data_list)\n        (4, 1.0, 1.0, 0.9, [1, 0, 0, 0]),\n        (4, 1.0, 1.0, 1.0, [1, 0, 0, 0]),\n        (4, -1.0, 1.0, 0.7, [0, 0, 0, 1]),\n        (4, 0.0, 1.0, 0.5, [-2, 1, 0, 3]),\n        (5, 1.0, 1.0, 0.6, [0, 1, -1, 0, 0]),\n    ]\n\n    final_results = []\n    TOL = 1e-12 # A small tolerance for floating point comparisons\n\n    for case in test_cases:\n        N, a, dx, dt, u0_list = case\n        u0 = np.array(u0_list, dtype=float)\n\n        # Calculate initial discrete entropy (L1-norm)\n        E0 = np.sum(np.abs(u0))\n\n        # Calculate the CFL number\n        nu = a * dt / dx\n\n        # --- Central Flux Scheme ---\n        # Update rule: u_i^{n+1} = u_i^n - (nu/2) * (u_{i+1}^n - u_{i-1}^n)\n        u_prev_c = np.roll(u0, 1)   # u_{i-1}\n        u_next_c = np.roll(u0, -1)  # u_{i+1}\n        u1_central = u0 - (nu / 2.0) * (u_next_c - u_prev_c)\n        \n        # Calculate final entropy for the central scheme\n        E1_central = np.sum(np.abs(u1_central))\n        \n        # Check for entropy violation\n        central_violates = (E1_central - E0) > TOL\n\n        # --- Upwind Flux Scheme ---\n        if a > 0:\n            # Update rule: u_i^{n+1} = (1-nu)*u_i^n + nu*u_{i-1}^n\n            u_prev_u = np.roll(u0, 1)  # u_{i-1}\n            u1_upwind = u0 - nu * (u0 - u_prev_u)\n        elif a  0:\n            # Update rule: u_i^{n+1} = (1+nu)*u_i^n - nu*u_{i+1}^n\n            u_next_u = np.roll(u0, -1)  # u_{i+1}\n            u1_upwind = u0 - nu * (u_next_u - u0)\n        else:  # a == 0\n            # Update rule: u_i^{n+1} = u_i^n\n            u1_upwind = np.copy(u0)\n            \n        # Calculate final entropy for the upwind scheme\n        E1_upwind = np.sum(np.abs(u1_upwind))\n        \n        # Check for entropy violation\n        upwind_violates = (E1_upwind - E0) > TOL\n        \n        final_results.append([central_violates, upwind_violates])\n\n    # Format the final output string as specified in the problem statement.\n    # e.g., [[True,False],[True,False],...]\n    case_results_str = [f\"[{'True' if res[0] else 'False'},{'True' if res[1] else 'False'}]\" for res in final_results]\n    print(f\"[{','.join(case_results_str)}]\")\n\nsolve()\n```", "id": "3130164"}, {"introduction": "本压轴练习在守恒和通量设计原则的基础上，进入了非线性守恒律的领域，以经典的伯格斯方程（Burgers' equation）为例。您将实现并比较几种源于不同黎曼求解器（包括Godunov、HLL和Roe）的先进数值通量。此练习 ([@problem_id:3130154]) 将揭示捕捉激波和稀疏波等非线性现象的挑战，并引入确保物理正确解所需的关键概念——熵条件。", "problem": "您需要为带有非线性通量的标量守恒律实现一个一维、一阶有限体积法。您的目标是在每个单元交界面上建立局部黎曼问题，基于不同的局部黎曼求解器实现三种不同的数值通量，并检验求解器的选择如何影响守恒性和熵行为。\n\n从微分形式的基本守恒律出发\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0,\n$$\n其具体的非线性通量为\n$$\nf(u) = \\tfrac{1}{2} u^2.\n$$\n在区域 $[0,1]$ 上使用有限体积法，网格为均匀网格，并采用周期性边界条件。设 $N$ 为单元数量，定义单元平均值 $U_i^n$ 作为在时间层 $n$、网格间距为 $\\Delta x$、时间步长为 $\\Delta t$ 的条件下，$u$ 在单元 $i$ 上的平均值的近似。更新必须采用守恒的通量差分形式，该形式基于在状态 $(U_i^n, U_{i+1}^n)$ 之间的每个交界面上求解局部黎曼问题。\n\n您必须实现三种不同的数值通量，每种通量都源于在每个交界面上局部应用的不同黎曼求解器：\n- 针对标量通量 $f(u)$ 的 Godunov 精确黎曼求解器。\n- Harten–Lax–van Leer (HLL) 求解器，使用对左行波和右行波波速的物理一致性估计。\n- 不含任何熵修正的 Roe 线性化求解器。\n\n您的实现必须：\n- 使用 Courant–Friedrichs–Lewy (CFL) 时间步进方法，固定 $\\mathrm{CFL} = 0.5$，在每一步根据最大局部特征速度动态选择 $\\Delta t$。对于此通量，该速度等于 $|f'(u)| = |u|$。\n- 使用 $N = 400$ 个均匀间隔的单元、周期性边界条件，并模拟直到最终时间 $t_{\\mathrm{final}} = 0.15$。\n- 用分段常数的初始数据初始化三个黎曼问题，其中心位于单元 $i = N/2 - 1$ 和 $i = N/2$ 之间的交界面上：\n  1. 测试 A (激波): $u_L = 2$, $u_R = 0$。\n  2. 测试 B (稀疏波): $u_L = 0$, $u_R = 2$。\n  3. 测试 C (跨音速稀疏波): $u_L = -1$, $u_R = 1$。\n  每个测试使用相同的区域和网格。左状态 $u_L$ 填充单元 $i = 0, \\dots, N/2 - 1$，右状态 $u_R$ 填充单元 $i = N/2, \\dots, N - 1$。\n\n对于每个求解器和每个测试，量化以下指标：\n- 守恒性：总质量 $M(t) = \\sum_i U_i(t) \\Delta x$ 是否在 $10^{-12}$ 的绝对容差内守恒，即 $|M(t_{\\mathrm{final}}) - M(0)| \\le 10^{-12}$ 是否成立。\n- 熵：离散总熵\n$$\nE(t) = \\sum_i \\tfrac{1}{2} U_i(t)^2 \\Delta x\n$$\n是否非增，即 $E(t_{\\mathrm{final}}) \\le E(0) + 10^{-10}$ 是否成立。\n\n此外，仅针对测试 C，基于交界面上满足熵条件的声速点状态，量化一个交界面熵一致性指标。对于 Burgers 通量 $f(u)=\\tfrac{1}{2}u^2$ 和跨音速数据 $u_L  0  u_R$，熵解在初始时刻规定了交界面状态为 $u_\\ast = 0$，因此正确的交界面通量等于 $f(0) = 0$。对于每个求解器，在初始时刻的间断位置（单元 $i=N/2-1$ 和 $i=N/2$ 之间的交界面）评估其数值交界面通量，并报告其是否在 $10^{-12}$ 的绝对容差内等于 $0$。\n\n实现细节与约束：\n- 使用守恒通量差分形式的显式一阶有限体积更新。\n- 在区域的两端使用周期性边界条件。\n- 在每个时间步中，在每个交界面上独立地应用局部黎曼求解器。\n- 所有量均为无量纲；不需要物理单位。\n\n测试套件和输出规范：\n- 按上文定义实现三个测试 A、B、C，并按 Godunov、HLL、Roe 的固定顺序实现三个求解器。\n- 对于每个求解器和每个测试，按以下顺序计算两个布尔值：质量守恒布尔值，然后是熵非增布尔值。\n- 仅对测试 C，每个求解器还需计算一个布尔值，指示初始间断处的交界面通量是否在指定容差内等于 $0$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序排列：\n- 首先，对于顺序为 [Godunov, HLL, Roe] 的每个求解器和顺序为 [A, B, C] 的每个测试，追加两个布尔值 [mass_conserved, entropy_nonincreasing]，总共得到 $18$ 个布尔值。\n- 然后，按相同的求解器顺序 [Godunov, HLL, Roe] 追加用于测试 C 交界面通量熵一致性指标的三个布尔值。\n- 因此，最终输出包含 $21$ 个布尔值，例如：\"[True,True,False,True,...]\"。", "solution": "该问题被验证为具有科学依据、适定且客观。它构成了计算流体力学中的一个标准练习，用于评估双曲守恒律基本数值格式的性质。所有参数和条件都已充分指定，从而能够得到唯一且可验证的解。\n\n该问题要求为一维标量守恒律实现一个一阶有限体积法，该守恒律由下式给出\n$$\n\\partial_t u(x,t) + \\partial_x f(u(x,t)) = 0, \\quad x \\in [0,1], t > 0,\n$$\n其非线性 Burgers 通量函数为 $f(u) = \\frac{1}{2} u^2$。空间区域被离散为 $N=400$ 个宽度为 $\\Delta x = 1/N$ 的均匀单元。每个单元 $i$ 内的解由其单元平均值近似，$U_i(t) \\approx \\frac{1}{\\Delta x} \\int_{x_{i-1/2}}^{x_{i+1/2}} u(x,t) dx$。\n\n单元平均值 $U_i$ 的半离散有限体积格式为\n$$\n\\frac{d U_i}{dt} = - \\frac{1}{\\Delta x} \\left( F_{i+1/2} - F_{i-1/2} \\right),\n$$\n其中 $F_{i+1/2}$ 是单元 $i$ 和单元 $i+1$ 之间交界面上的数值通量。该通量是相邻单元状态的函数，$F_{i+1/2} = F(U_i, U_{i+1})$。时间积分采用前向欧拉格式：\n$$\nU_i^{n+1} = U_i^n - \\frac{\\Delta t^n}{\\Delta x} \\left( F_{i+1/2}^n - F_{i-1/2}^n \\right).\n$$\n时间步长 $\\Delta t^n$ 在每个时间层 $n$ 动态选择，以满足 Courant-Friedrichs-Lewy (CFL) 条件：\n$$\n\\Delta t^n = \\mathrm{CFL} \\frac{\\Delta x}{\\max_i | \\lambda(U_i^n) |},\n$$\n其中 Burgers 方程的特征速度为 $\\lambda(u) = f'(u) = u$，CFL 数固定为 $\\mathrm{CFL} = 0.5$。施加周期性边界条件，这意味着在计算通量时，单元 $N$ 等同于单元 $0$，单元 $-1$ 等同于单元 $N-1$。\n\n实现了三种不同的数值通量函数，每种函数对应一个不同的局部黎曼求解器。\n\n1.  **Godunov 通量 ($F_G$)**：该通量源于单元交界面上状态为 $(u_L, u_R)$ 的局部黎曼问题的精确解。对于凸的 Burgers 通量，交界面上的状态 $u_{int} = u(x/t=0; u_L, u_R)$ 决定了通量 $F_G = f(u_{int})$。状态 $u_{int}$ 取决于波的结构：\n    - 如果 $u_L  u_R$，则形成一个速度为 $s = \\frac{f(u_R)-f(u_L)}{u_R-u_L} = \\frac{1}{2}(u_L+u_R)$ 的激波。如果 $s  0$，交界面上的状态为 $u_L$。如果 $s \\le 0$，状态为 $u_R$。\n    - 如果 $u_L \\le u_R$，则形成一个稀疏波。如果 $u_L, u_R \\ge 0$，所有特征线都向右移动，因此 $u_{int}=u_L$。如果 $u_L, u_R \\le 0$，所有特征线都向左移动，因此 $u_{int}=u_R$。如果 $u_L  0  u_R$ (跨音速稀疏波)，则存在一个静止声速点，且 $u_{int}=0$。\n    最终得到的通量由下式给出：\n    $$\n    F_G(u_L, u_R) = \\begin{cases}\n    \\max(f(u_L), f(u_R))  \\text{if } u_L > u_R \\text{ and } s=0 \\\\\n    f(u_L)  \\text{if } u_L > u_R \\text{ and } s>0 \\\\\n    f(u_R)  \\text{if } u_L > u_R \\text{ and } s  0 \\\\\n    f(u_L)  \\text{if } u_L \\le u_R \\text{ and } u_L \\ge 0 \\\\\n    f(u_R)  \\text{if } u_L \\le u_R \\text{ and } u_R \\le 0 \\\\\n    f(0)  \\text{if } u_L  0  u_R\n    \\end{cases}\n    $$\n    对于 $s=0$ 且 $u_L>u_R$ 的情况，$u_L=-u_R$ 且 $f(u_L)=f(u_R)$，因此最大值就是 $f(u_L)$。\n\n2.  **Harten-Lax-van Leer (HLL) 通量 ($F_{HLL}$)**：这是一个近似黎曼求解器，它假设一个两道波的结构，波之间是常数状态。通量为：\n    $$\n    F_{HLL}(u_L, u_R) = \\begin{cases}\n    f(u_L),  \\text{if } S_L \\ge 0 \\\\\n    f(u_R),  \\text{if } S_R \\le 0 \\\\\n    \\frac{S_R f(u_L) - S_L f(u_R) + S_L S_R (u_R - u_L)}{S_R - S_L},  \\text{if } S_L  0  S_R\n    \\end{cases}\n    $$\n    其中 $S_L$ 和 $S_R$ 是最小和最大信号速度的估计值。对于标量问题，一个标准的、物理上一致的选择是 $S_L = \\min(\\lambda(u_L), \\lambda(u_R)) = \\min(u_L, u_R)$ 和 $S_R = \\max(\\lambda(u_L), \\lambda(u_R)) = \\max(u_L, u_R)$。\n\n3.  **Roe 通量 ($F_R$)**：该通量基于一个线性化黎曼问题。它为激波提供了高分辨率，但对稀疏波需要进行熵修正，此处明确省略了熵修正。\n    $$\n    F_R(u_L, u_R) = \\frac{1}{2}\\left( f(u_L) + f(u_R) \\right) - \\frac{1}{2} |\\hat{a}(u_L, u_R)| (u_R - u_L)\n    $$\n    Roe 平均波速 $\\hat{a}$ 必须满足性质 $f(u_R) - f(u_L) = \\hat{a}(u_R - u_L)$。对于 Burgers 方程，这可以得出 $\\hat{a}(u_L, u_R) = \\frac{1}{2}(u_L + u_R)$。\n\n三个测试案例（A：激波，B：稀疏波，C：跨音速稀疏波）的初始条件是分段常数，在单元 $i=N/2-1$ 和 $i=N/2$ 之间的交界面处存在间断。\n\n每个求解器的行为基于三个标准进行评估：\n1.  **质量守恒**：数值格式是守恒形式的，因此总质量 $M(t) = \\sum_{i=0}^{N-1} U_i(t) \\Delta x$ 应该在浮点精度范围内守恒。通过验证 $|M(t_{\\mathrm{final}}) - M(0)| \\le 10^{-12}$ 来检查这一点。\n2.  **熵条件**：对于一个物理上有效的解，此处定义的离散总熵 $E(t) = \\sum_{i=0}^{N-1} \\frac{1}{2} U_i(t)^2 \\Delta x$ 必须是非增的。通过验证 $E(t_{\\mathrm{final}}) \\le E(0) + 10^{-10}$ 来检查这一点。这个小的容差是为了考虑舍入误差。\n3.  **测试 C 的交界面通量**：对于跨音速稀疏波情况（测试 C），熵解要求初始间断处的状态为 $u_* = 0$，从而导致物理通量为 $f(0) = 0$。每个求解器在 $t=0$ 时计算出的数值通量 $F(u_L=-1, u_R=1)$ 将在 $10^{-12}$ 的容差内与此值进行比较。Godunov 求解器预期会精确匹配。HLL 和 Roe 求解器由于其构造方式，预期将无法通过此测试，这表明了它们在此类场景中已知的缺陷（HLL 的耗散性，Roe 的熵违背）。\n\n实现过程是通过遍历每个求解器和测试案例，运行模拟直到 $t_{\\mathrm{final}}=0.15$，然后计算指定的布尔值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements a 1D finite volume solver for Burgers' equation and evaluates\n    three numerical fluxes: Godunov, HLL, and Roe.\n    \"\"\"\n    N = 400\n    T_FINAL = 0.15\n    CFL_NUMBER = 0.5\n    DOMAIN_LENGTH = 1.0\n    \n    DX = DOMAIN_LENGTH / N\n    X = np.linspace(DX / 2, DOMAIN_LENGTH - DX / 2, N)\n\n    # Nonlinear flux function and its derivative (characteristic speed)\n    def f(u):\n        return 0.5 * u**2\n\n    # --- Numerical Flux Implementations ---\n\n    def godunov_flux(uL, uR):\n        \"\"\"Vectorized Godunov flux for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n        s = 0.5 * (uL + uR)\n\n        # Shock case (uL > uR)\n        flux_shock = np.where(s > 0, fL, fR)\n        # Handle s=0 case, where fL=fR\n        flux_shock = np.where(s == 0, fL, flux_shock)\n\n        # Rarefaction case (uL = uR)\n        flux_raref = np.where(uL >= 0, fL, fR) # Both states non-negative or non-positive\n        flux_raref = np.where((uL  0)  (uR > 0), 0.0, flux_raref) # Transonic case\n\n        return np.where(uL > uR, flux_shock, flux_raref)\n\n    def hll_flux(uL, uR):\n        \"\"\"Vectorized HLL flux for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n\n        sL = np.minimum(uL, uR)\n        sR = np.maximum(uL, uR)\n        \n        flux = np.zeros_like(uL)\n        \n        # Case 1: sL >= 0\n        mask1 = sL >= 0\n        flux[mask1] = fL[mask1]\n        \n        # Case 2: sR = 0\n        mask2 = sR = 0\n        flux[mask2] = fR[mask2]\n        \n        # Case 3: sL  0  sR\n        mask3 = ~(mask1 | mask2)\n        sL_m3 = sL[mask3]\n        sR_m3 = sR[mask3]\n        s_diff = sR_m3 - sL_m3\n        \n        # Avoid division by zero when sL = sR (i.e. uL = uR)\n        # Although masks should prevent this, it's safer.\n        safe_s_diff = np.where(s_diff == 0, 1.0, s_diff) # if s_diff is 0, uL=uR, numerator is 0 anyway.\n\n        hll_val = (sR_m3 * fL[mask3] - sL_m3 * fR[mask3] + sL_m3 * sR_m3 * (uR[mask3] - uL[mask3])) / safe_s_diff\n        flux[mask3] = hll_val\n        \n        return flux\n\n    def roe_flux(uL, uR):\n        \"\"\"Vectorized Roe flux (no entropy fix) for Burgers' equation.\"\"\"\n        fL = f(uL)\n        fR = f(uR)\n        a_hat = 0.5 * (uL + uR)\n        return 0.5 * (fL + fR) - 0.5 * np.abs(a_hat) * (uR - uL)\n\n    solvers = {\n        \"Godunov\": godunov_flux,\n        \"HLL\": hll_flux,\n        \"Roe\": roe_flux\n    }\n    \n    test_cases = {\n        \"A\": (2.0, 0.0), # Shock\n        \"B\": (0.0, 2.0), # Rarefaction\n        \"C\": (-1.0, 1.0) # Transonic rarefaction\n    }\n\n    def run_simulation(flux_func, uL, uR):\n        \"\"\"Runs a single simulation and returns initial and final states.\"\"\"\n        U = np.zeros(N)\n        mid_point = N // 2\n        U[:mid_point] = uL\n        U[mid_point:] = uR\n        U_initial = U.copy()\n\n        t = 0.0\n        while t  T_FINAL:\n            max_abs_u = np.max(np.abs(U))\n            if max_abs_u  1e-15:\n                # Solution is zero, no change\n                dt = T_FINAL - t\n            else:\n                dt = CFL_NUMBER * DX / max_abs_u\n            \n            if t + dt > T_FINAL:\n                dt = T_FINAL - t\n\n            # Periodic boundary conditions for flux calculation\n            u_left = U\n            u_right = np.roll(U, -1)\n            \n            fluxes = flux_func(u_left, u_right)\n\n            fluxes_left_face = np.roll(fluxes, 1) # Fluxes at i-1/2\n            \n            U = U - (dt / DX) * (fluxes - fluxes_left_face)\n            t += dt\n            \n        return U_initial, U\n\n    results = []\n\n    # Part 1: Run simulations and check conservation/entropy\n    solver_order = [\"Godunov\", \"HLL\", \"Roe\"]\n    test_order = [\"A\", \"B\", \"C\"]\n\n    for solver_name in solver_order:\n        for test_name in test_order:\n            uL, uR = test_cases[test_name]\n            flux_function = solvers[solver_name]\n            \n            U0, U_final = run_simulation(flux_function, uL, uR)\n\n            # Mass conservation check\n            mass0 = np.sum(U0) * DX\n            mass_final = np.sum(U_final) * DX\n            mass_conserved = abs(mass_final - mass0) = 1e-12\n\n            # Entropy non-increase check\n            entropy0 = np.sum(0.5 * U0**2) * DX\n            entropy_final = np.sum(0.5 * U_final**2) * DX\n            entropy_nonincreasing = entropy_final = entropy0 + 1e-10\n\n            results.extend([mass_conserved, entropy_nonincreasing])\n\n    # Part 2: Interface entropy-consistency indicator for Test C\n    uL_C, uR_C = test_cases[\"C\"]\n    for solver_name in solver_order:\n        flux_function = solvers[solver_name]\n        # Calculate flux for a single interface\n        interfacial_flux = flux_function(np.array([uL_C]), np.array([uR_C]))[0]\n        flux_is_zero = abs(interfacial_flux - 0.0) = 1e-12\n        results.append(flux_is_zero)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3130154"}]}