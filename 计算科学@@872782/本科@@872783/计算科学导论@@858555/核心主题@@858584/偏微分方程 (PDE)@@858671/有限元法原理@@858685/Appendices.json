{"hands_on_practices": [{"introduction": "动手实践的第一步是构建一个基本但功能完备的有限元求解器。这个练习将指导你处理一个一维稳态扩散问题，这是许多物理现象（如热传导或物质浓度分布）的数学模型。通过这个实践，你将掌握从偏微分方程推导其弱形式，并学习如何施加两种基本类型的边界条件：本质边界条件（Dirichlet）和自然边界条件（Robin）。特别地，你将看到Robin条件如何通过分部积分自然地出现在弱形式中，这为处理复杂的物理边界（如对流换热）提供了优雅的数学框架。[@problem_id:3129727]", "problem": "考虑区间 $[0,1]$ 上的一个一维稳态扩散模型，其传导系数 $k$ 为常数，源 $f(x)$ 空间均匀，由守恒定律 $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$ 控制。在左端点 $x=0$ 施加狄利克雷边界条件，在右端点 $x=1$ 施加一个模拟对流冷却的罗宾边界条件 (RBC)，表示为 $k \\nabla u \\cdot n + \\alpha u = g$，其中 $n$ 为 $x=1$ 处的外法线。在一维情况下，$x=1$ 处的外法线 $n=+1$，该条件简化为 $k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$。对于到环境水平 $u_{\\infty}$ 的对流冷却，通常设置 $g = \\alpha u_{\\infty}$，等效于 $k \\dfrac{du}{dx}(1) + \\alpha \\big(u(1) - u_{\\infty}\\big) = 0$。所有量均为无量纲。\n\n从守恒定律 $-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x)$ 和边界条件出发，通过虚功原理推导弱形式：乘以一个合适的测试函数，在 $[0,1]$ 上积分，并应用分部积分法以暴露出表示罗宾边界条件的边界积分。然后，在具有 $N$ 个单元的均匀网格上，使用分段线性基函数设计一个协调伽辽金有限元方法，并通过边界积分项弱施加罗宾边界条件。组装与此弱施加相一致的全局线性系统，在 $x=0$ 处强制施加狄利克雷边界条件，并求解得到的系统以获得 $u$ 的节点近似值。\n\n模型使用以下固定参数：\n- 区间长度 $L = 1$，\n- 均匀单元数量 $N = 40$ (因此网格尺寸为 $h = L/N$)，\n- 恒定传导系数 $k = 2$，\n- 均匀源 $f(x) \\equiv 1$，\n- $x=0$ 处的狄利克雷边界数据：$u(0) = U_0$，其中 $U_0 = 2$，\n- $x=1$ 处的环境水平 $u_{\\infty} = 1$，\n- 罗宾系数 $\\alpha$ 在一个测试套件中变化，以模拟不同的对流冷却强度。\n\n测试套件：\n- 情况1：$\\alpha = 0.0$ (当 $g=\\alpha u_{\\infty}=0$ 时的纯诺伊曼极限)，\n- 情况2：$\\alpha = 0.5$，\n- 情况3：$\\alpha = 5.0$，\n- 情况4：$\\alpha = 100.0$ (逼近对环境水平的类狄利克雷钳制)。\n\n对于每种情况，设置 $g = \\alpha u_{\\infty}$ 并计算有限元解。提取并报告每种情况下右端点温度 $u(1)$ 的值 (即网格中 $x=1$ 处的节点值)。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按测试套件的顺序排列 $\\big[\\alpha=\\text{情况 }1, \\alpha=\\text{情况 }2, \\alpha=\\text{情况 }3, \\alpha=\\text{情况 }4\\big]$。例如，一个可接受的格式是 $[u_1,u_2,u_3,u_4]$，其中每个 $u_i$ 是对应 $\\alpha$ 情况下计算出的右端点值 $u(1)$。\n- 所有量均为无量纲，因此输出中不需要物理单位。\n- 每个报告的量必须是实数（浮点数）。", "solution": "该问题是有效的。这是一个来自数学物理领域的适定边值问题，基于稳态扩散的标准理论。所有参数和条件都已完全指定，科学上合理，且无矛盾或歧义。\n\n### 1. 弱形式\n\n控制偏微分方程 (PDE)，或称强形式，是定义在域 $\\Omega = [0,1]$ 上的一维稳态扩散方程：\n$$-\\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) = f(x) \\quad \\text{for } x \\in (0,1)$$\n边界条件为：\n1.  $x=0$ 处的狄利克雷条件：$u(0) = U_0$。\n2.  $x=1$ 处的罗宾条件：$k \\dfrac{du}{dx}(1) + \\alpha u(1) = g$。\n\n为了推导弱形式，我们遵循虚功原理。我们将 PDE 乘以一个任意的测试函数 $v(x)$，并在域 $\\Omega$ 上积分。测试函数 $v$ 属于求解空间，但满足齐次本质 (狄利克雷) 边界条件。在这里，该空间为 $V = \\{ v \\in H^1(0,1) \\mid v(0)=0 \\}$，其中 $H^1(0,1)$ 是具有一阶导数平方可积函数的索博列夫空间。\n\n$$-\\int_0^1 \\dfrac{d}{dx}\\!\\left(k \\dfrac{du}{dx}\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx$$\n\n我们对左侧项应用分部积分，以降低试探函数 $u$ 的导数阶数，并将一个导数转移到测试函数 $v$ 上：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - \\left[ k \\dfrac{du}{dx} v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx$$\n\n接下来，我们计算边界项 $\\left[ k \\frac{du}{dx} v \\right]_0^1 = k \\frac{du}{dx}(1) v(1) - k \\frac{du}{dx}(0) v(0)$。由于测试函数 $v$ 必须满足齐次狄利克雷条件 $v(0)=0$，因此 $x=0$ 处的项为零。剩下：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - k \\dfrac{du}{dx}(1) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\n罗宾边界条件在此处被自然地并入。该条件为 $k \\frac{du}{dx}(1) = g - \\alpha u(1)$。将这个表达式代入我们方程中的通量项 $k \\frac{du}{dx}(1)$，我们得到：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx - (g - \\alpha u(1)) v(1) = \\int_0^1 f(x) v(x) \\, dx$$\n\n重排各项，将所有涉及未知解 $u$ 的表达式放在左侧 (LHS)，所有其他项放在右侧 (RHS)，我们便得到弱形式：求 $u(x)$，使得 $u(0) = U_0$ 并且对于所有测试函数 $v \\in V$：\n$$\\int_0^1 k \\dfrac{du}{dx} \\dfrac{dv}{dx} \\, dx + \\alpha u(1) v(1) = \\int_0^1 f(x) v(x) \\, dx + g v(1)$$\n\n这就是标准形式 $a(u,v) = L(v)$，其中：\n-   双线性形式为 $a(u,v) = \\int_0^1 k u'v' \\, dx + \\alpha u(1)v(1)$。\n-   线性泛函为 $L(v) = \\int_0^1 fv \\, dx + gv(1)$。\n\n### 2. 伽辽金有限元离散化\n\n我们将域 $[0,1]$ 离散化为 $N$ 个长度为 $h = 1/N$ 的均匀单元。这会产生位于 $x_i = i h$ (对于 $i=0, 1, \\dots, N$) 的 $N+1$ 个节点。我们将解 $u(x)$ 近似为分段线性基函数 $\\phi_j(x)$ 的线性组合：\n$$u_h(x) = \\sum_{j=0}^{N} U_j \\phi_j(x)$$\n其中 $U_j$ 是未知的节点值，$U_j \\approx u(x_j)$，而 $\\phi_j(x)$ 是“帽”函数，它在节点 $x_j$ 处等于 $1$，在所有其他节点 $x_i$ ($i \\neq j$) 处等于 $0$。\n\n伽辽金方法使用基函数自身作为测试函数，即 $v(x) = \\phi_i(x)$ (对于 $i=0, 1, \\dots, N$)。将近似解 $u_h(x)$ 和 $v(x) = \\phi_i(x)$ 代入弱形式，得到一个包含 $N+1$ 个线性代数方程的方程组：\n$$\\sum_{j=0}^{N} U_j \\left( \\int_0^1 k \\phi_j'(x) \\phi_i'(x) \\,dx + \\alpha \\phi_j(1) \\phi_i(1) \\right) = \\int_0^1 f(x) \\phi_i(x) \\, dx + g \\phi_i(1)$$\n这可以写成矩阵形式 $\\mathbf{K} \\mathbf{U} = \\mathbf{F}$，其中 $\\mathbf{U} = [U_0, U_1, \\dots, U_N]^T$ 是节点未知量向量。全局刚度矩阵 $\\mathbf{K}$ 和力向量 $\\mathbf{F}$ 的项为：\n$$K_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 k \\phi_j' \\phi_i' \\,dx + \\alpha \\phi_j(1) \\phi_i(1)$$\n$$F_i = L(\\phi_i) = \\int_0^1 f \\phi_i \\, dx + g \\phi_i(1)$$\n\n### 3. 系统组装和边界条件\n\n全局系统是通过对每个单元的贡献求和来组装的。对于一个跨越 $[x_{e-1}, x_e]$、长度为 $h$ 的通用单元 $e$，在 $k$ 和 $f$ 为常数的情况下，其单元刚度矩阵 $\\mathbf{k}^e$ 和单元力向量 $\\mathbf{f}^e$ 为：\n$$\\mathbf{k}^e = \\frac{k}{h} \\begin{pmatrix} 1 & -1 \\\\ -1 & 1 \\end{pmatrix}, \\quad \\mathbf{f}^e = \\frac{fh}{2} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$$\n\n**组装：** 全局矩阵 $\\mathbf{K}$ 和向量 $\\mathbf{F}$ 初始为零。对于每个单元，将其 $\\mathbf{k}^e$ 和 $\\mathbf{f}^e$ 加到相应的全局项中。组装后，$\\mathbf{K}$ 是一个三对角矩阵，$\\mathbf{F}$ 由单元贡献形成。\n\n**罗宾边界条件：** $x=1$ 处的罗宾条件影响涉及 $u(1)$ 和 $v(1)$ 的项。由于 $\\phi_j(1) = \\delta_{jN}$ 和 $\\phi_i(1) = \\delta_{iN}$，边界项的贡献仅在 $i=N$ 和 $j=N$ 同时成立时非零。\n-   项 $\\alpha \\phi_j(1) \\phi_i(1)$ 将 $\\alpha$ 加到矩阵项 $K_{N,N}$ 上。\n-   项 $g \\phi_i(1)$ 将 $g$ 加到向量项 $F_N$ 上。\n-   在 $g = \\alpha u_\\infty$ 的情况下，施加狄利克雷条件之前的最终系统具有 $K_{N,N} = k/h + \\alpha$ 和 $F_N = fh/2 + \\alpha u_\\infty$。\n\n**狄利克雷边界条件：** 条件 $u(0) = U_0$ 固定了 $U_0$ 的值。这是一个本质边界条件。我们通过对系统进行分区来强制施加它。第一个节点 $U_0$ 的方程被移除，其已知值被代入其余方程。未知量是 $U_1, \\dots, U_N$。完整系统的第 $i$ 个方程 (对于 $i \\in \\{1, \\dots, N\\}$) 是 $\\sum_{j=0}^{N} K_{ij} U_j = F_i$。这可以重写为：\n$$K_{i0} U_0 + \\sum_{j=1}^{N} K_{ij} U_j = F_i \\implies \\sum_{j=1}^{N} K_{ij} U_j = F_i - K_{i0} U_0$$\n由于基函数 $\\phi_0$ 仅与 $\\phi_1$ 重叠，项 $K_{i0}$ 仅在 $i=1$ 时非零。因此，只有降维后系统的第一个方程（对应于节点 $U_1$）的右侧被修改。\n我们求解降维后的 $N \\times N$ 系统 $\\mathbf{A} \\mathbf{U}_{\\text{unknown}} = \\mathbf{b}$，其中：\n-   $\\mathbf{U}_{\\text{unknown}} = [U_1, \\dots, U_N]^T$。\n-   $\\mathbf{A}$ 是 $\\mathbf{K}$ 中对应于索引 $1, \\dots, N$ 的子矩阵。\n-   $\\mathbf{b}$ 是 $\\mathbf{F}$ 中对应于索引 $1, \\dots, N$ 的子向量，其第一个元素被修改为：$b_0 = F_1 - K_{1,0} U_0$。\n\n### 4. 数值实现\n提供的参数为 $L=1$, $N=40$, $k=2$, $f=1$, $U_0=2$ 和 $u_\\infty=1$。网格尺寸为 $h=1/40$。程序将按照上述描述构建矩阵和向量，为测试套件中的每个 $\\alpha$ 值求解线性系统，并提取右端点处的解值 $U_N = U_{40}$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves a 1D steady diffusion problem using the Finite Element Method.\n\n    The problem is -d/dx(k * du/dx) = f on [0,1] with u(0)=U0\n    and a Robin condition k*du/dx(1) + alpha*u(1) = g at x=1.\n    \"\"\"\n    #\n    # 1. Define model parameters and test cases\n    #\n    L = 1.0        # Length of the domain\n    N = 40         # Number of elements\n    k = 2.0        # Thermal conductivity\n    f = 1.0        # Uniform source term\n    U0 = 2.0       # Dirichlet BC value at x=0\n    u_inf = 1.0    # Ambient level for Robin BC\n    \n    alpha_cases = [0.0, 0.5, 5.0, 100.0]\n\n    #\n    # 2. Derived parameters for FEM\n    #\n    h = L / N                  # Element size\n    num_nodes = N + 1          # Total number of nodes\n    \n    results = []\n\n    for alpha in alpha_cases:\n        #\n        # 3. Assemble the global stiffness matrix K and force vector F\n        #\n        K = np.zeros((num_nodes, num_nodes))\n        F = np.zeros(num_nodes)\n\n        # Element-level matrices\n        k_e = (k / h) * np.array([[1, -1], [-1, 1]])\n        f_e = (f * h / 2) * np.array([1, 1])\n\n        # Loop over elements to assemble global system\n        for i in range(N):\n            # Global indices for the two nodes of element i\n            node1_idx, node2_idx = i, i + 1\n            \n            # Add element stiffness contribution to global matrix\n            K[node1_idx:node2_idx+1, node1_idx:node2_idx+1] += k_e\n            \n            # Add element force contribution to global vector\n            F[node1_idx:node2_idx+1] += f_e\n\n        #\n        # 4. Apply boundary conditions\n        #\n\n        # 4.1 Apply Robin boundary condition at x=1 (node N)\n        # The weak form naturally adds terms to the last equation.\n        # a(u,v) term: alpha * u(1) * v(1) --> adds alpha to K[N,N]\n        # L(v) term: g * v(1) --> adds g to F[N]\n        g = alpha * u_inf\n        K[N, N] += alpha\n        F[N] += g\n\n        # 4.2 Apply Dirichlet boundary condition at x=0 (node 0)\n        # We partition the system to solve only for the unknown nodal values U_1, ..., U_N.\n        # The system for these N unknowns is A * U_unknown = b.\n        \n        # A is the submatrix of K corresponding to the unknown nodes (1 to N)\n        A = K[1:, 1:]\n        \n        # b is the corresponding subvector of F, modified by the known U0.\n        # The full equation for node 1 is K[1,0]*U0 + K[1,1]*U1 + ... = F[1]\n        # So, the modified RHS for the U1 equation is F[1] - K[1,0]*U0\n        b = F[1:]\n        b[0] -= K[1, 0] * U0\n        \n        #\n        # 5. Solve the linear system\n        #\n        U_unknown = np.linalg.solve(A, b)\n        \n        # The desired result is the value at the right endpoint, u(1),\n        # which corresponds to the last element of the solution vector.\n        u_at_1 = U_unknown[-1]\n        results.append(u_at_1)\n\n    #\n    # 6. Format and print the final output\n    #\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129727"}, {"introduction": "在掌握了基本求解器的构建后，我们将在上一个练习的基础上引入一个在工程和科学中普遍存在的复杂情况：非均质材料。真实世界中的系统很少由单一均匀的材料构成；更常见的是由多种材料拼接而成的复合结构。本练习将探讨当材料属性（如导热系数 $k(x)$）在空间上发生突变时，有限元方法该如何应对。你将通过对比两种不同的单元矩阵计算策略——一种“感知”到材料界面的精确策略，和一种“未感知”的简化策略——来量化几何离散与物理模型失配所带来的误差，从而深刻理解网格划分和数值积分在确保计算精度方面的重要性。[@problem_id:3129650]", "problem": "考虑区间 $[0,1]$ 上的一个一维边值问题，其非均匀材料属性由微分方程 $- \\dfrac{d}{dx}\\big(k(x)\\,u'(x)\\big) = f(x)$ 描述，并服从狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。假设电导率 $k(x)$ 是一个分段常数函数，在界面位置 $\\xi \\in (0,1)$ 处有一个跳跃间断点，由下式给出\n$$\nk(x) = \\begin{cases}\nk_1, & x  \\xi,\\\\\nk_2,  x \\ge \\xi,\n\\end{cases}\n$$\n且右侧项为常数 $f(x) = 1$。\n\n从问题的变分形式（即乘以测试函数 $v(x)$ 并分部积分）出发，使用索博列夫空间 $H_0^1([0,1])$ 推导弱形式中的双线性形式和线性泛函。在具有 $N$ 个单元的均匀网格上，使用标准的分段线性（帽）函数来构建伽辽金近似。在对齐情况（即 $\\xi$ 与网格节点重合）下，单元积分 $\\int k(x)\\,dx$ 简化为 $k_e\\,h$，其中 $k_e$ 在该单元上为常数，h 为单元长度。在未对齐情况（即界面严格位于单元内部）下，实现两种组装策略：\n- 一种界面感知策略，通过在 $x=\\xi$ 处分割单元并对具有 $k_1$ 和 $k_2$ 的子段贡献求和，来精确计算单元积分 $\\int k(x)\\,dx$。\n- 一种界面非感知策略，使用中点求积法则来近似计算单元积分，即 $\\int k(x)\\,dx \\approx k(x_m)\\,h$（其中 $x_m$ 是单元中点），因此不在单元内部强制施加界面条件。\n\n从基本原理出发，证明界面条件（即 $u(x)$ 的连续性和在 $x=\\xi$ 处通量 $k(x)\\,u'(x)$ 的连续性）是从弱形式中自然产生的。使用这些原理，实现一个有限元法（FEM；Finite Element Method）求解器，该求解器：\n1. 根据从 $\\int k(x)\\,dx$ 和基函数导数推导出的单元矩阵，组装全局刚度矩阵。\n2. 对每个基函数 $N_i(x)$，使用 $\\int f(x)\\,N_i(x)\\,dx$ 组装全局载荷向量。\n3. 在 $x=0$ 和 $x=1$ 处施加狄利克雷边界条件。\n\n为了验证，通过求解常微分方程 $u''(x) = -\\dfrac{1}{k_1}$（在 $[0,\\xi)$上）和 $u''(x) = -\\dfrac{1}{k_2}$（在 $[\\xi,1]$上），并应用 $u(0)=0$、$u(1)=0$ 以及界面条件 $u(\\xi^-)=u(\\xi^+)$ 和 $k_1\\,u'(\\xi^-)=k_2\\,u'(\\xi^+)$，来推导当 $f(x)=1$ 和 $k(x)$ 为分段常数时的精确解 $u(x)$。使用该精确解，通过足够精确的数值积分计算有限元近似解与精确解之间误差的 $L^2$-范数，\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2},\n$$\n\n您的程序必须为以下测试套件评估 $L^2$ 误差，该套件探讨了对齐与未对齐网格以及界面感知与非感知策略，包括一个 $k(x)$ 具有高对比度的边缘情况和一个界面非常靠近网格节点的情况：\n- 测试 $1$：$N=20$，$\\xi=0.5$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{True}$。\n- 测试 $2$：$N=20$，$\\xi=0.47$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{True}$。\n- 测试 $3$：$N=20$，$\\xi=0.47$，$k_1=1$，$k_2=5$，界面感知组装 $\\text{False}$。\n- 测试 $4$：$N=40$，$\\xi=0.3$，$k_1=0.01$，$k_2=100$，界面感知组装 $\\text{False}$。\n- 测试 $5$：$N=40$，$\\xi=0.025$，$k_1=2$，$k_2=3$，界面感知组装 $\\text{True}$。\n\n所有量均为无量纲。您的程序应生成单行输出，其中包含五个测试用例的 $L^2$ 误差，格式为逗号分隔的浮点数列表，保留六位小数，并用方括号括起来，即格式为 $[e_1,e_2,e_3,e_4,e_5]$，其中每个 $e_i$ 是一个浮点数。", "solution": "用户提供的问题已经过验证，被确定为一个适定的、有科学依据的、客观的计算科学问题。所有必要的数据和条件均已提供，不存在矛盾或歧义。\n\n### 1. 弱形式\n边值问题的强形式由下式给出：\n$$\n- \\frac{d}{dx}\\left(k(x) \\frac{du}{dx}\\right) = f(x), \\quad x \\in (0,1)\n$$\n带有狄利克雷边界条件 $u(0) = 0$ 和 $u(1) = 0$。解 $u(x)$ 和测试函数 $v(x)$ 在索博列夫空间 $H_0^1([0,1])$ 中寻找，该空间由满足齐次边界条件、自身平方可积且其弱导数也平方可积的函数组成。\n\n为了推导弱形式，我们将微分方程乘以一个测试函数 $v \\in H_0^1([0,1])$，并在定义域 $[0,1]$ 上积分：\n$$\n-\\int_0^1 \\frac{d}{dx}\\left(k(x) u'(x)\\right) v(x) \\, dx = \\int_0^1 f(x) v(x) \\, dx\n$$\n其中 $u'(x) = \\frac{du}{dx}$。我们对左侧项应用分部积分：\n$$\n\\int_0^1 k(x) u'(x) v'(x) \\, dx - \\left[ k(x) u'(x) v(x) \\right]_0^1 = \\int_0^1 f(x) v(x) \\, dx\n$$\n由于测试函数 $v \\in H_0^1([0,1])$，我们有 $v(0) = v(1) = 0$，这使得边界项消失。最终的弱形式为：寻找 $u \\in H_0^1([0,1])$，使得\n$$\na(u,v) = L(v) \\quad \\forall v \\in H_0^1([0,1])\n$$\n其中双线性形式 $a(u,v)$ 和线性泛函 $L(v)$ 定义如下：\n$$\na(u,v) = \\int_0^1 k(x) u'(x) v'(x) \\, dx\n$$\n$$\nL(v) = \\int_0^1 f(x) v(x) \\, dx\n$$\n\n### 2. 界面条件\n弱形式自然地包含了物理界面条件。如果我们假设解 $u$ 在子域 $[0, \\xi)$ 和 $(\\xi, 1]$ 上是二阶可微的，并且我们分别在这些子域上进行分部积分，我们得到：\n$$\n\\int_0^\\xi k_1 u' v' dx - [k_1 u' v]_0^{\\xi^-} + \\int_\\xi^1 k_2 u' v' dx - [k_2 u' v]_{\\xi^+}^1 = \\int_0^1 f v dx\n$$\n使用 $v(0)=v(1)=0$，上式简化为：\n$$\n\\int_0^1 k u' v' dx + [k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi) = \\int_0^1 f v dx\n$$\n将此式与弱形式进行比较，我们看到为了使两者对于每一个 $v \\in H_0^1([0,1])$ 都等价，项 $[k_2 u'(\\xi^+) - k_1 u'(\\xi^-)] v(\\xi)$ 必须为零。因为我们可以选择一个测试函数 $v$ 使得 $v(\\xi) \\neq 0$，所以必须有 $k_1 u'(\\xi^-) = k_2 u'(\\xi^+)$。这就是通量连续性条件，它作为自然边界条件从弱形式中产生。解的连续性 $u(\\xi^-) = u(\\xi^+)$ 是一个本质条件，通过在空间 $H^1([0,1])$ 中寻求解答 $u$ 来强制施加。\n\n### 3. 有限元离散化\n我们将域 $[0,1]$ 离散化为 $N$ 个长度为 $h = 1/N$ 的均匀单元。节点为 $x_i = i h$，其中 $i=0, 1, \\dots, N$。有限元解 $u_h(x)$ 近似为分段线性基（帽）函数 $N_j(x)$ 的线性组合：\n$$\nu_h(x) = \\sum_{j=0}^{N} U_j N_j(x)\n$$\n其中 $U_j$ 是未知的节点值。边界条件 $u(0)=0$ 和 $u(1)=0$ 意味着 $U_0 = 0$ 和 $U_N = 0$，因此求和实际上是针对 $N-1$ 个内部节点。\n\n将 $u_h(x)$ 代入弱形式，并选择测试函数为基函数本身（即 $v(x) = N_i(x)$，对于 $i=1, \\dots, N-1$），我们得到伽辽金线性方程组 $K \\mathbf{U} = \\mathbf{F}$：\n$$\n\\sum_{j=1}^{N-1} U_j \\underbrace{\\left( \\int_0^1 k(x) N'_j(x) N'_i(x) \\, dx \\right)}_{K_{ij}} = \\underbrace{\\int_0^1 f(x) N_i(x) \\, dx}_{F_i}\n$$\n其中 $\\mathbf{U}$ 是未知节点值的向量 $[U_1, \\dots, U_{N-1}]^T$。\n\n### 4. 系统组装\n刚度矩阵 $K$ 和载荷向量 $\\mathbf{F}$ 由单元贡献组装而成。对于一个跨越 $[x_e, x_{e+1}]$ 的单元 $e$，局部基函数的导数为 $\\pm 1/h$。$2 \\times 2$ 的单元刚度矩阵 $K^e$ 是：\n$$\nK^e = \\frac{1}{h^2} \\begin{pmatrix} 1  -1 \\\\ -1  1 \\end{pmatrix} \\int_{x_e}^{x_{e+1}} k(x) \\, dx\n$$\n关键项是电导率的积分，$I_e = \\int_{x_e}^{x_{e+1}} k(x) \\, dx$。\n- **界面感知策略**：$I_e$ 被精确计算。如果界面 $\\xi$ 在 $(x_e, x_{e+1})$ 内，则积分被分割：$I_e = \\int_{x_e}^{\\xi} k_1 dx + \\int_{\\xi}^{x_{e+1}} k_2 dx = k_1(\\xi-x_e) + k_2(x_{e+1}-\\xi)$。否则，$I_e$ 为 $k_1 h$ 或 $k_2 h$。\n- **界面非感知策略**：$I_e$ 使用中点法则进行近似：$I_e \\approx k(x_m)h$，其中 $x_m = (x_e+x_{e+1})/2$。这将基于单元中点为整个单元分配一个单一的电导率值，忽略了任何单元内的变化。\n\n对于 $f(x)=1$ 的载荷向量，内部节点 $i$ 的项是 $F_i = \\int_0^1 N_i(x) dx$。一个帽函数在其支撑集上的积分是其面积，即 $\\frac{1}{2} \\times \\text{底} \\times \\text{高} = \\frac{1}{2} \\times 2h \\times 1 = h$。因此，对于所有内部节点，$F_i = h$。\n\n组装后，求解 $(N-1) \\times (N-1)$ 的三对角系统 $K \\mathbf{U} = \\mathbf{F}$ 以获得节点值 $\\mathbf{U}$。\n\n### 5. 精确解\n对于分段常数 $k(x)$ 和恒定强迫项 $f(x)=1$，常微分方程为 $u_1''(x) = -1/k_1$（对于 $x \\in [0, \\xi)$）和 $u_2''(x) = -1/k_2$（对于 $x \\in [\\xi, 1]$）。两次积分得到：\n$$\nu_1(x) = -\\frac{x^2}{2k_1} + C_1 x + D_1\n$$\n$$\nu_2(x) = -\\frac{x^2}{2k_2} + C_2 x + D_2\n$$\n应用四个条件（$u(0)=0$、$u(1)=0$、$u(\\xi^-)=u(\\xi^+)$、$k_1 u'(\\xi^-)=k_2 u'(\\xi^+)$）可以确定四个积分常数 $C_1, C_2, D_1, D_2$。解为：\n$$\nu(x) = \\begin{cases}\n-\\frac{x^2}{2k_1} + C_1 x,  x  \\xi \\\\\n-\\frac{x^2}{2k_2} + C_2 x + D_2,  x \\ge \\xi\n\\end{cases}\n$$\n其中 $D_1=0$ 且\n$$\nC_1 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_1(k_1(1-\\xi) + k_2 \\xi)}, \\quad C_2 = \\frac{k_1(1-\\xi^2) + k_2 \\xi^2}{2k_2(k_1(1-\\xi) + k_2 \\xi)}, \\quad D_2 = \\frac{(\\xi^2-\\xi)(k_1-k_2)}{2k_2(k_1(1-\\xi) + k_2 \\xi)}\n$$\n\n### 6. 误差计算\n有限元解 $u_h(x)$ 的精度通过误差的 $L^2$-范数 $\\|u - u_h\\|_{L^2(0,1)}$ 来衡量：\n$$\n\\|u - u_h\\|_{L^2(0,1)} = \\left( \\int_0^1 \\big(u(x) - u_h(x)\\big)^2\\,dx \\right)^{1/2}\n$$\n该积分使用高阶求积法则进行数值计算。在这里，在一个包含 $10000$ 个点的细网格上应用梯形法则，以确保求积误差与有限元离散误差相比可以忽略不计。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the specified test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # N, xi, k1, k2, is_aware\n        (20, 0.5, 1, 5, True),\n        (20, 0.47, 1, 5, True),\n        (20, 0.47, 1, 5, False),\n        (40, 0.3, 0.01, 100, False),\n        (40, 0.025, 2, 3, True),\n    ]\n\n    results = []\n    for case in test_cases:\n        error = solve_fem_bvp(*case)\n        results.append(error)\n\n    # Format the output as specified\n    formatted_results = [\"{:.6f}\".format(r) for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef solve_fem_bvp(N, xi, k1, k2, is_aware):\n    \"\"\"\n    Solves the 1D BVP using FEM for a given set of parameters.\n\n    Args:\n        N (int): Number of elements.\n        xi (float): Interface location.\n        k1 (float): Conductivity for x  xi.\n        k2 (float): Conductivity for x = xi.\n        is_aware (bool): Flag for interface-aware assembly strategy.\n\n    Returns:\n        float: The L2 norm of the error.\n    \"\"\"\n    h = 1.0 / N\n    nodes = np.linspace(0, 1, N + 1)\n    num_dof = N - 1\n\n    # 1. Assemble Stiffness Matrix K and Load Vector F\n    K = np.zeros((num_dof, num_dof))\n    F = np.full(num_dof, h)\n\n    # Pre-calculate all element integrals of k(x), denoted I_e\n    I_e = np.zeros(N)\n    for e in range(N):\n        x_e = nodes[e]\n        x_e_plus_1 = nodes[e+1]\n\n        if is_aware:\n            # Interface-aware assembly (exact integral)\n            if xi = x_e:\n                I_e[e] = k2 * h\n            elif xi > x_e_plus_1:\n                I_e[e] = k1 * h\n            else:  # Interface is inside the element\n                I_e[e] = k1 * (xi - x_e) + k2 * (x_e_plus_1 - xi)\n        else:\n            # Interface-unaware assembly (midpoint rule)\n            x_m = (x_e + x_e_plus_1) / 2.0\n            k_mid = k1 if x_m  xi else k2\n            I_e[e] = k_mid * h\n\n    # Assemble K for interior nodes (DoFs 1 to N-1)\n    for i in range(num_dof):  # Matrix index i from 0 to N-2\n        # Diagonal entry K[i, i] corresponds to node i+1\n        # Contribution from element i and element i+1\n        K[i, i] = (I_e[i] + I_e[i+1]) / (h ** 2)\n        # Off-diagonal entries\n        if i > 0:\n            K[i, i - 1] = -I_e[i] / (h ** 2)\n        if i  num_dof - 1:\n            K[i, i + 1] = -I_e[i+1] / (h ** 2)\n\n    # 2. Solve the linear system for interior node values\n    U_interior = np.linalg.solve(K, F)\n\n    # Reconstruct full solution vector including boundary conditions\n    U_full = np.zeros(N + 1)\n    U_full[1:N] = U_interior\n\n    # 3. Calculate L2 error\n    # Define exact solution function\n    def get_exact_solution(xi_p, k1_p, k2_p):\n        A = k1_p * (1 - xi_p) + k2_p * xi_p\n        if np.isclose(A, 0): # Should not happen with positive k values\n            return lambda x: 0.0\n\n        C1_num = k1_p * (1 - xi_p**2) + k2_p * xi_p**2\n        C1 = C1_num / (2 * k1_p * A) if k1_p != 0 else 0\n        C2 = C1_num / (2 * k2_p * A) if k2_p != 0 else 0\n        D2 = ((xi_p**2 - xi_p) * (k1_p - k2_p)) / (2 * k2_p * A) if k2_p != 0 else 0\n        \n        def u_exact(x):\n            if x  xi_p:\n                return -x**2 / (2 * k1_p) + C1 * x if k1_p != 0 else 0\n            else:\n                return -x**2 / (2 * k2_p) + C2 * x + D2 if k2_p != 0 else 0\n        return u_exact\n\n    u_exact_func = get_exact_solution(xi, k1, k2)\n\n    # Define FEM solution function\n    def u_h(x, nodes_h, U_sol, h_val):\n        if x = 0.0: return 0.0\n        if x >= 1.0: return 0.0\n        \n        i = int(np.floor(x / h_val))\n        x_i = nodes_h[i]\n        # Linear interpolation within element i\n        val = U_sol[i] * (nodes_h[i+1] - x) / h_val + U_sol[i+1] * (x - x_i) / h_val\n        return val\n\n    # Numerical integration for L2 norm using a fine grid\n    num_quad_points = 10000\n    quad_points = np.linspace(0, 1, num_quad_points + 1)\n    \n    # Vectorized evaluation over the fine grid\n    exact_vals = np.array([u_exact_func(x) for x in quad_points])\n    fem_vals = np.array([u_h(x, nodes, U_full, h) for x in quad_points])\n\n    squared_errors = (exact_vals - fem_vals)**2\n    \n    # Trapezoidal rule for integration\n    integral = np.trapz(squared_errors, quad_points)\n\n    l2_error = np.sqrt(integral)\n    \n    return l2_error\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3129650"}, {"introduction": "前面的实践都集中在不随时间变化的稳态问题上。现在，我们将把有限元方法的应用扩展到描述系统演化的瞬态问题，以热传导方程为例。空间上的有限元离散会将原有的偏微分方程转化为一个常微分方程组，其形式为 $M \\dot{u}(t) + K u(t) = f(t)$。这个练习的核心任务是为这个半离散系统实现并比较不同的时间积分方案。通过分析它们的精度和处理刚性问题的能力，你将理解选择合适的时间步进格式对于获得稳定且准确的瞬态仿真结果是何等关键，并接触到质量矩阵在动力学问题中的核心作用。[@problem_id:3129641]", "problem": "您将编写一个完整、可运行的程序，该程序构建热方程的一维有限元方法 (FEM) 半离散模型，并从精度和刚度处理方面比较三种隐式时间积分器。\n\n半离散模型的形式为 $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$，其中 $M$ 是对称正定质量矩阵，$K$ 是对称半正定刚度矩阵。它们源于在单位区间上使用均匀网格和线性基函数，并施加齐次 Dirichlet 边界条件的协调 Galerkin 离散化。\n\n您的实现必须从以下基本原理推导得出：\n- 一维空间中热方程的强形式为 $\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t)$，并带有适当的边界和初始数据。\n- 弱形式通过乘以一个测试函数、在空间上进行分部积分并应用边界条件得到，当空间变量通过使用分段线性形函数的协调 Galerkin 方法离散化后，会得到一个形如 $M \\, \\dot{u}(t) + K \\, u(t) = f(t)$ 的半离散线性系统。\n- 时间积分器是通过使用代数稳定的隐式格式对 $\\dot{u}(t)$ 进行一致的时间离散化来构建的。\n\n基于此，您需要在不使用任何捷径公式的情况下，推导并实现以下应用于半离散系统的时间积分器：\n- 后向欧拉法（也称为隐式欧拉法）。\n- Crank–Nicolson 方法。\n- $2$ 阶后向差分公式 (BDF2)，并采用一致的单步隐式启动。\n\n您必须在每个阶段确保科学上的真实性和正确性，包括为网格组装 $M$ 和 $K$ 矩阵，以及处理齐次 Dirichlet 边界条件。\n\n为使问题完全可测试，请使用以下测试套件和评估指标，所有指标均以纯数学术语表示，不含物理单位：\n\n1) 精度测试（在固定最终时间点的时间收敛性）：\n- 设空间网格在 $[0,1]$ 上有 $N_\\text{el} = 50$ 个均匀单元，因此有 $N = N_\\text{el} - 1$ 个内部节点。使用标准的线性基函数，并在 $x=0$ 和 $x=1$ 处施加齐次 Dirichlet 边界条件，组装一致的 FEM 质量矩阵 $M$ 和刚度矩阵 $K$。\n- 将半离散初始条件 $u(0)$ 定义为矩阵束 $(K,M)$ 的前两个广义特征向量（对应于两个最小的广义特征值）的线性组合。具体来说，设 $K v_i = \\lambda_i M v_i$ 且 $v_i^\\top M v_j = \\delta_{ij}$，并定义 $u(0) = 1 \\cdot v_1 + 0.5 \\cdot v_2$。设 $f(t) \\equiv 0$。那么，精确的半离散解为 $u_\\text{exact}(t) = \\sum_{i} c_i e^{-\\lambda_i t} v_i$，其中系数 $c_i = v_i^\\top M u(0)$。\n- 选择最终时间 $T = 0.1$。对于每种方法，使用两种时间步长计算在 $T$ 时刻的数值解：$\\Delta t_\\text{coarse} = T/40$ 和 $\\Delta t_\\text{fine} = T/80$。对于每个 $\\Delta t$，计算误差 $e(\\Delta t) = \\| u_\\text{num}(T;\\Delta t) - u_\\text{exact}(T) \\|_M$，其中 $\\|w\\|_M = \\sqrt{w^\\top M w}$。\n- 对于每种方法，通过 $p = \\dfrac{\\log\\big(e(\\Delta t_\\text{coarse}) / e(\\Delta t_\\text{fine})\\big)}{\\log(2)}$ 来估计观测到的时间精度阶数。\n\n2) 刚度处理测试（在大时间步长下对最刚性模式的阻尼）：\n- 设空间网格在 $[0,1]$ 上有 $N_\\text{el} = 200$ 个均匀单元，同样施加齐次 Dirichlet 边界条件，并组装 $M$ 和 $K$。\n- 计算矩阵束 $(K,M)$ 的最大广义特征值 $\\lambda_{\\max}$ 和对应的 $M$-归一化广义特征向量 $v_{\\max}$，使得 $K v_{\\max} = \\lambda_{\\max} M v_{\\max}$ 且 $v_{\\max}^\\top M v_{\\max} = 1$。\n- 设 $u(0) = v_{\\max}$ 且 $f(t) \\equiv 0$。定义一个大时间步长 $\\Delta t_\\text{stiff} = 50 / \\lambda_{\\max}$，并使用后向欧拉法和 Crank–Nicolson 方法各走一个时间步。对于后向欧拉法和 Crank–Nicolson 方法，计算在 $M$-范数下的单步放大因子：\n  - $r_\\text{BE} = \\dfrac{\\|u^{1}_\\text{BE}\\|_M}{\\|u^0\\|_M}$，\n  - $r_\\text{CN} = \\dfrac{\\|u^{1}_\\text{CN}\\|_M}{\\|u^0\\|_M}$，\n  其中 $u^{1}_\\text{method}$ 表示一个时间步后的解。\n- 对于 BDF2，使用一致的单步隐式启动：首先用后向欧拉法走一步得到 $u^{1}$，然后用 BDF2 法走一步得到 $u^{2}$。将在 BDF2 步骤上测量的每步放大因子定义为 $r_\\text{BDF2} = \\dfrac{\\|u^{2}\\|_M}{\\|u^{1}\\|_M}$。\n- 此外，通过检查沿 $v_{\\max}$ 方向的模态系数的符号变化，来检测 Crank–Nicolson 方法是否在刚性模式上表现出振荡行为：计算 $c_0 = v_{\\max}^\\top M u^{0}$ 和 $c_1 = v_{\\max}^\\top M u^{1}_\\text{CN}$，如果 $c_0 \\cdot c_1  0$，则设置布尔标志 $\\text{osc}_\\text{CN} = \\text{True}$，否则为 $\\text{False}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表。聚合结果必须按以下顺序排列：\n  - 来自精度测试的后向欧拉法、Crank–Nicolson 和 BDF2 的三个观测阶数 $p$，每个都四舍五入到三位小数。\n  - 来自刚度处理测试的三个放大因子 $r_\\text{BE}$、 $r_\\text{CN}$ 和 $r_\\text{BDF2}$，每个都四舍五入到六位小数。\n  - 布尔标志 $\\text{osc}_\\text{CN}$。\n- 具体来说，输出格式为 $[p_\\text{BE},p_\\text{CN},p_\\text{BDF2},r_\\text{BE},r_\\text{CN},r_\\text{BDF2},\\text{osc}_\\text{CN}]$。\n\n注意和约束：\n- 所有数学量都是无量纲的；不报告任何物理单位。\n- 不涉及角度；不需要角度单位。\n- 不使用百分比。\n- 您必须基于半离散系统 $M \\, \\dot{u} + K \\, u = f$ 从第一性原理推导每个时间积分器。\n- 使用一致质量矩阵，而不是集中质量近似。\n- 通过消除边界自由度来使用齐次 Dirichlet 边界条件。\n- 您的程序必须严格遵守所要求的最终输出格式，并且不得读取任何输入。对于规定的测试套件，它必须是完全自包含和确定性的。", "solution": "用户提供了一个有效、适定且具有科学依据的问题。任务是为热方程构建一个一维有限元方法 (FEM) 模型，并评估三种隐式时间积分方案。解决方案首先推导必要的数学公式，然后在一个 Python 脚本中实现它们，以执行指定的数值实验。\n\n### 1. 空间离散化：有限元方法\n\n问题从定义域 $\\Omega = [0, 1]$ 上带齐次 Dirichlet 边界条件的一维热方程的强形式开始：\n$$\n\\begin{cases}\n\\partial_t u(x,t) - \\partial_{xx} u(x,t) = s(x,t)  \\text{for } x \\in (0,1), t  0 \\\\\nu(0,t) = 0, \\quad u(1,t) = 0  \\text{for } t  0 \\\\\nu(x,0) = u_0(x)  \\text{for } x \\in [0,1]\n\\end{cases}\n$$\n通过将偏微分方程乘以一个来自适当空间（此处为 $H^1_0(0,1)$，即一阶导数平方可积且在边界处为零的函数空间）的测试函数 $v(x)$，并在定义域 $\\Omega$ 上积分，可以推导出弱形式：\n$$\n\\int_0^1 v(x) \\partial_t u(x,t) \\,dx - \\int_0^1 v(x) \\partial_{xx} u(x,t) \\,dx = \\int_0^1 v(x) s(x,t) \\,dx\n$$\n对第二项应用分部积分，并使用齐次 Dirichlet 边界条件 ($v(0)=v(1)=0$)，得到：\n$$\n\\int_0^1 v \\partial_t u \\,dx + \\int_0^1 \\partial_x v \\partial_x u \\,dx = \\int_0^1 v s \\,dx\n$$\n对于 FEM 离散化，我们将区间 $[0,1]$ 划分为 $N_\\text{el}$ 个长度为 $h = 1/N_\\text{el}$ 的均匀单元。这产生了 $N = N_\\text{el} - 1$ 个内部节点。解 $u(x,t)$ 由一个函数 $u_h(x,t)$ 来近似，该函数是分段线性基函数 $\\phi_j(x)$（通常称为“帽子”函数）的线性组合：\n$$\nu_h(x,t) = \\sum_{j=1}^{N} u_j(t) \\phi_j(x)\n$$\n其中 $u_j(t)$ 是解的随时间变化的节点值，$\\phi_j(x)$ 是与节点 $j$ 相关联的基函数，使得 $\\phi_j(x_k) = \\delta_{jk}$。\n\n遵循 Galerkin 原理，我们选择基函数本身作为测试函数，即 $v(x) = \\phi_i(x)$，其中 $i=1, \\dots, N$。将近似解 $u_h$ 代入弱形式，得到一个常微分方程组 (ODEs)：\n$$\n\\sum_{j=1}^{N} \\left(\\int_0^1 \\phi_i \\phi_j \\,dx\\right) \\dot{u}_j(t) + \\sum_{j=1}^{N} \\left(\\int_0^1 \\phi'_i \\phi'_j \\,dx\\right) u_j(t) = \\int_0^1 \\phi_i s(x,t) \\,dx\n$$\n这就是半离散系统 $M \\dot{u}(t) + K u(t) = f(t)$，其中 $u(t)$ 是节点值向量 $[u_1(t), ..., u_N(t)]^T$，矩阵和向量的分量定义如下：\n- **质量矩阵**：$M_{ij} = \\int_0^1 \\phi_i(x) \\phi_j(x) \\,dx$\n- **刚度矩阵**：$K_{ij} = \\int_0^1 \\phi'_i(x) \\phi'_j(x) \\,dx$\n- **载荷向量**：$f_i(t) = \\int_0^1 \\phi_i(x) s(x,t) \\,dx$\n\n矩阵项的积分是逐单元计算的。对于大小为 $h$ 的均匀网格上的线性基函数，所得三对角矩阵的非零项为：\n- $M_{ii} = \\int_{x_{i-1}}^{x_{i+1}} \\phi_i^2 \\,dx = \\frac{2h}{3}$\n- $M_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi_i \\phi_{i\\pm1} \\,dx = \\frac{h}{6}$\n- $K_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi'_i)^2 \\,dx = \\frac{2}{h}$\n- $K_{i, i\\pm1} = \\int_{x_{i}}^{x_{i\\pm1}} \\phi'_i \\phi'_{i\\pm1} \\,dx = -\\frac{1}{h}$\n\n测试用例指定 $s(x,t)=0$，因此载荷向量为 $f(t) = 0$。\n\n### 2. 时间离散化：隐式时间积分器\n\n我们求解齐次半离散系统 $M \\dot{u} + K u = 0$。设 $u^n$ 是在时间 $t_n = n \\Delta t$ 处对 $u(t_n)$ 的数值近似。\n\n**后向欧拉法（隐式欧拉法）**\n这种一阶方法在 $t_{n+1}$ 处近似时间导数：$\\dot{u}(t_{n+1}) \\approx \\frac{u^{n+1}-u^n}{\\Delta t}$。系统在 $t_{n+1}$ 处进行评估：\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K u^{n+1} = 0 \\implies (M + \\Delta t K) u^{n+1} = M u^n\n$$\n在每个时间步，都必须为 $u^{n+1}$ 求解一个线性系统。该方法是 A-稳定的和 L-稳定的，为高频（刚性）分量提供强阻尼。\n\n**Crank-Nicolson**\n这种二阶方法基于梯形法则。时间导数在中间点 $t_{n+1/2}$ 处近似，而项 $K u$ 在 $t_n$ 和 $t_{n+1}$ 上取平均：\n$$\nM \\left(\\frac{u^{n+1} - u^n}{\\Delta t}\\right) + K \\left(\\frac{u^n + u^{n+1}}{2}\\right) = 0 \\implies \\left(M + \\frac{\\Delta t}{2} K\\right) u^{n+1} = \\left(M - \\frac{\\Delta t}{2} K\\right) u^n\n$$\n该方法是 A-稳定的，但不是 L-稳定的。对于刚性分量，其放大因子接近 -1，导致持续不衰减的振荡。\n\n**2 阶后向差分公式 (BDF2)**\n这是一种二阶、两步法。在 $t_{n+1}$ 处的导数使用 $t_{n+1}$、$t_n$ 和 $t_{n-1}$ 处的值进行近似：\n$$\n\\dot{u}(t_{n+1}) \\approx \\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\n$$\n将此代入常微分方程组 (ODE) 系统可得：\n$$\nM \\left(\\frac{3u^{n+1} - 4u^n + u^{n-1}}{2\\Delta t}\\right) + K u^{n+1} = 0 \\implies (3M + 2 \\Delta t K) u^{n+1} = 4M u^n - M u^{n-1}\n$$\n由于它是一个两步法，因此需要一个启动程序来从 $u^0$ 计算 $u^1$。按照规定，为此目的使用一阶后向欧拉法的单步计算。BDF2 是刚性稳定和 L-稳定的，因此适合处理刚性问题。\n\n### 3. 数值实验与实现\n\n所提供的问题指定了两个数值实验来评估这些积分器。\n\n**精度测试**：时间精度阶数是通过将数值解与已知的精确半离散解进行比较来测量的。初始条件是矩阵束 $(K, M)$ 的前两个广义特征向量的线性组合，$u(0) = c_1 v_1 + c_2 v_2$。那么，$M\\dot{u} + Ku = 0$ 的精确解是 $u(t) = c_1 e^{-\\lambda_1 t} v_1 + c_2 e^{-\\lambda_2 t} v_2$。通过计算两个不同时间步长 $\\Delta t_\\text{coarse}$ 和 $\\Delta t_\\text{fine}$ 的误差，观测到的精度阶数 $p$ 被估计为 $p = \\log(e_\\text{coarse}/e_\\text{fine}) / \\log(2)$。\n\n**刚度处理测试**：该测试评估最刚性模式的数值阻尼，该模式对应于最大的广义特征值 $\\lambda_\\text{max}$。从 $u(0)=v_\\text{max}$ 开始，取一个大的时间步 $\\Delta t_\\text{stiff} = 50/\\lambda_\\text{max}$。计算 $M$-范数下的单步放大因子 $r$，它量化了阻尼。对于 BDF2，遵循定义的两步程序。通过观察解的模态系数的符号来检查 Crank-Nicolson 方法产生振荡的趋势。\n\n该实现将构建矩阵 $M$ 和 $K$，然后执行这些测试。广义特征问题 $K v_i = \\lambda_i M v_i$ 使用 `scipy.linalg.eigh` 求解。时间步进方案涉及在每一步求解线性系统。为提高效率，系统矩阵（例如，$M + \\Delta t K$）在时间循环开始前使用 LU 分解进行一次因式分解。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh, lu_factor, lu_solve\n\ndef solve():\n    \"\"\"\n    Constructs a 1D FEM model for the heat equation and evaluates three implicit time integrators.\n    \"\"\"\n\n    def assemble_matrices(Nel):\n        \"\"\"Assembles the consistent mass (M) and stiffness (K) matrices for 1D FEM.\"\"\"\n        N = Nel - 1\n        h = 1.0 / Nel\n\n        # Mass Matrix M = h/6 * tridiag(1, 4, 1)\n        diag_M = np.full(N, 4.0 * h / 6.0)\n        offdiag_M = np.full(N - 1, 1.0 * h / 6.0)\n        M = np.diag(diag_M) + np.diag(offdiag_M, k=1) + np.diag(offdiag_M, k=-1)\n\n        # Stiffness Matrix K = 1/h * tridiag(-1, 2, -1)\n        diag_K = np.full(N, 2.0 / h)\n        offdiag_K = np.full(N - 1, -1.0 / h)\n        K = np.diag(diag_K) + np.diag(offdiag_K, k=1) + np.diag(offdiag_K, k=-1)\n        \n        return M, K\n\n    def compute_m_norm(vec, M):\n        \"\"\"Computes the M-norm of a vector.\"\"\"\n        return np.sqrt(vec.T @ M @ vec)\n\n    # --- Part 1: Accuracy Test ---\n    def run_accuracy_test():\n        Nel = 50\n        T = 0.1\n        N_steps_coarse = 40\n        N_steps_fine = 80\n        dt_coarse = T / N_steps_coarse\n        dt_fine = T / N_steps_fine\n\n        M, K = assemble_matrices(Nel)\n        \n        # Solve generalized eigenproblem K v = lambda M v\n        # eigh returns M-orthonormal eigenvectors\n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda1, lambda2 = eigenvalues[0:2]\n        v1, v2 = eigenvectors[:, 0], eigenvectors[:, 1]\n        \n        u0 = 1.0 * v1 + 0.5 * v2\n        u_exact_T = np.exp(-lambda1 * T) * v1 + 0.5 * np.exp(-lambda2 * T) * v2\n\n        errors = {}\n        for method in ['BE', 'CN', 'BDF2']:\n            errors[method] = []\n            for dt, num_steps in [(dt_coarse, N_steps_coarse), (dt_fine, N_steps_fine)]:\n                u = np.copy(u0)\n                \n                if method == 'BE':\n                    A_lu = lu_factor(M + dt * K)\n                    for _ in range(num_steps):\n                        rhs = M @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'CN':\n                    A_lu = lu_factor(M + 0.5 * dt * K)\n                    B = M - 0.5 * dt * K\n                    for _ in range(num_steps):\n                        rhs = B @ u\n                        u = lu_solve(A_lu, rhs)\n                \n                elif method == 'BDF2':\n                    # Startup step with Backward Euler\n                    A_be_lu = lu_factor(M + dt * K)\n                    rhs_be = M @ u\n                    u_curr = lu_solve(A_be_lu, rhs_be)\n                    u_prev = np.copy(u0)\n\n                    # BDF2 steps\n                    A_bdf2_lu = lu_factor(3 * M + 2 * dt * K)\n                    for _ in range(1, num_steps):\n                        rhs = 4 * M @ u_curr - M @ u_prev\n                        u_next = lu_solve(A_bdf2_lu, rhs)\n                        u_prev = u_curr\n                        u_curr = u_next\n                    u = u_curr\n\n                error_vec = u - u_exact_T\n                err = np.sqrt(error_vec.T @ M @ error_vec)\n                errors[method].append(err)\n        \n        # Calculate observed order of accuracy p\n        p_be = np.log(errors['BE'][0] / errors['BE'][1]) / np.log(2)\n        p_cn = np.log(errors['CN'][0] / errors['CN'][1]) / np.log(2)\n        p_bdf2 = np.log(errors['BDF2'][0] / errors['BDF2'][1]) / np.log(2)\n\n        return p_be, p_cn, p_bdf2\n\n    # --- Part 2: Stiffness Handling Test ---\n    def run_stiffness_test():\n        Nel = 200\n        M, K = assemble_matrices(Nel)\n        \n        eigenvalues, eigenvectors = eigh(K, M)\n        lambda_max = eigenvalues[-1]\n        v_max = eigenvectors[:, -1]\n        \n        u0 = v_max\n        dt = 50.0 / lambda_max\n\n        norm_u0 = compute_m_norm(u0, M)\n        if not np.isclose(norm_u0, 1.0):\n             # This should not happen with eigh, but good practice to check\n             norm_u0 = 1.0 \n\n        # Backward Euler\n        A_be = M + dt * K\n        rhs_be = M @ u0\n        u1_be = np.linalg.solve(A_be, rhs_be)\n        r_be = compute_m_norm(u1_be, M) / norm_u0\n\n        # Crank-Nicolson\n        A_cn = M + 0.5 * dt * K\n        B_cn = M - 0.5 * dt * K\n        rhs_cn = B_cn @ u0\n        u1_cn = np.linalg.solve(A_cn, rhs_cn)\n        r_cn = compute_m_norm(u1_cn, M) / norm_u0\n        \n        c0 = v_max.T @ M @ u0 # This is v_max.T @ M @ v_max = 1\n        c1 = v_max.T @ M @ u1_cn\n        osc_cn = bool(c0 * c1  0)\n\n        # BDF2\n        # u1 is from the BE startup step\n        u1 = u1_be\n        # Second step is BDF2\n        A_bdf2 = 3 * M + 2 * dt * K\n        rhs_bdf2 = 4 * M @ u1 - M @ u0\n        u2_bdf2 = np.linalg.solve(A_bdf2, rhs_bdf2)\n        \n        r_bdf2 = compute_m_norm(u2_bdf2, M) / compute_m_norm(u1, M)\n\n        return r_be, r_cn, r_bdf2, osc_cn\n\n    # --- Run tests and aggregate results ---\n    p_be, p_cn, p_bdf2 = run_accuracy_test()\n    r_be, r_cn, r_bdf2, osc_cn = run_stiffness_test()\n\n    results = [\n        round(p_be, 3),\n        round(p_cn, 3),\n        round(p_bdf2, 3),\n        round(r_be, 6),\n        round(r_cn, 6),\n        round(r_bdf2, 6),\n        osc_cn\n    ]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3129641"}]}