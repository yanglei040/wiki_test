{"hands_on_practices": [{"introduction": "在学习显式方法时，理解其稳定性是至关重要的第一步。本练习将带你超越理论公式，通过一个数值实验来亲手验证和感受 Courant–Friedrichs–Lewy (CFL) 稳定性条件。你将模拟一个“热点”的扩散过程，并找出临界时间步长——它是一条分界线，一边是物理上合理的模拟，另一边则是温度会变得不真实的低于零度的灾难性结果。通过这个实践，你将对离散极值原理及其在数值计算中的意义获得直观的理解。[@problem_id:3126925]", "problem": "考虑一个有限区间上的无量纲单位下的一维热方程，其边界条件为齐次狄利克雷边界条件：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}, \\quad x \\in [0,L], \\ t \\ge 0, \\quad u(0,t)=0,\\ u(L,t)=0,\n$$\n其中 $u(x,t)$ 是温度，$\\alpha > 0$ 是热扩散系数，$L>0$ 是区域长度。您将需要从基本原理出发，构建一个显式有限差分方法，并设计一个数值实验来展示当 Courant–Friedrichs–Lewy (CFL) 条件被违反时，正性（离散温度的非负性）如何丧失，并量化能够保持离散极值原理的最大时间步长。\n\n将空间域离散化为 $N$ 个内部点和两个边界点，使得空间网格的索引为 $i=0,1,2,\\dots,N,N+1$，其中 $i=0$ 和 $i=N+1$ 是边界。设空间步长为 $\\Delta x = L/(N+1)$。对于时间，使用步数 $n=0,1,2,\\dots$，时间步长为 $\\Delta t$。通过使用向前差分来近似时间导数，构建显式格式，\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t},\n$$\n并使用中心差分来近似空间二阶导数，\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}.\n$$\n使用得到的完全显式方法在每个时间步 $n \\to n+1$ 更新内部节点 $i=1,2,\\dots,N$。\n\n将离散温度初始化为非负且高度局部化的值：对于所有 $i$，设置 $u_i^0=0$，除了单个内部索引 $i^\\star$ 处 $u_{i^\\star}^0 = 1$。选择 $i^\\star$ 为最接近区间中点的内部点，即，\n$$\ni^\\star = \\left\\lfloor \\frac{N+1}{2} \\right\\rfloor.\n$$\n这模拟了一根除单个热点外其余部分均处于冷却状态的杆，并且是一个有效的非负初始条件。\n\n您的任务：\n1. 根据上述显式构造，确定关于 $\\Delta t$（作为 $\\alpha$ 和 $\\Delta x$ 的函数）的精确条件，该条件需保证在初始状态为非负时，每个内部节点的更新都是非负值的凸组合，从而在所有后续时间层上保持非负性。将仍然能保持此离散极值原理的最大时间步长定义为临界时间步长 $\\Delta t_\\star$。\n2. 设计一个数值实验，对于每个给定的参数集 $(\\alpha,L,N,K)$，从上述相同的初始状态开始，进行以下三次运行：\n   - 违规的时间步长 $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$（超出阈值）。\n   - 临界的时间步长 $\\Delta t_{\\text{border}} = \\Delta t_\\star$（恰在阈值上）。\n   - 安全的时间步长 $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$（低于阈值）。\n   对于这三种选择中的每一种，将显式格式演化恰好 $K$ 步，并在每一步之后检查是否有任何分量变得严格为负（即小于 $0$）。为每次运行记录一个布尔值，指示是否在这 $K$ 步期间的任何时候观察到负值。\n3. 从基本原理出发，根据给定的参数 $(\\alpha,L,N)$，用 $\\alpha$ 和 $\\Delta x$ 来量化 $\\Delta t_\\star$。将此值与每次测试的三个布尔值一起报告。\n\n测试套件：\n- 案例 1：$(\\alpha,L,N,K) = (1,1,50,5)$。\n- 案例 2：$(\\alpha,L,N,K) = (0.5,2,1,3)$。\n- 案例 3：$(\\alpha,L,N,K) = (3,1,20,5)$。\n\n最终输出规范：\n- 对于每个案例，按顺序输出一个包含四个条目的列表：$[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$，其中 $\\text{neg\\_bad}$、$\\text{neg\\_border}$ 和 $\\text{neg\\_good}$ 是布尔值，分别指示是否在 $\\Delta t_{\\text{bad}}$、$\\Delta t_{\\text{border}}$ 和 $\\Delta t_{\\text{good}}$ 的情况下观察到负值，而 $\\Delta t_\\star$ 是一个浮点数。\n- 最终的程序输出应为单行，其中包含按顺序排列的三个案例结果的列表，格式为用方括号括起来的逗号分隔列表，例如：\n$$\n[\\,[\\text{neg\\_bad}_1,\\text{neg\\_border}_1,\\text{neg\\_good}_1,\\Delta t_{\\star,1}],\\ [\\text{neg\\_bad}_2,\\text{neg\\_border}_2,\\text{neg\\_good}_2,\\Delta t_{\\star,2}],\\ [\\text{neg\\_bad}_3,\\text{neg\\_border}_3,\\text{neg\\_good}_3,\\Delta t_{\\star,3}]\\,].\n$$\n由于所有量都是无量纲的，因此不需要物理单位。不涉及角度。不得使用百分比；任何小数因子（如 $0.9$ 或 $1.1$）在需要时应在输出中表示为小数。", "solution": "该问题要求推导一维热方程显式有限差分格式的稳定性条件，并设计一个数值实验来验证它。\n\n### 步骤 1：稳定性条件与临界时间步长 $\\Delta t_\\star$ 的推导\n\n控制一维热方程由下式给出：\n$$\n\\frac{\\partial u}{\\partial t} = \\alpha \\frac{\\partial^2 u}{\\partial x^2}\n$$\n其中参数为热扩散系数 $\\alpha > 0$ 和区域长度 $L > 0$。边界条件为齐次狄利克雷边界条件：$u(0,t) = 0$ 和 $u(L,t) = 0$。\n\n问题指定在时间上使用向前差分，在空间上使用中心差分。令 $u_i^n$ 近似解 $u(x_i, t_n)$，其中 $x_i = i \\Delta x$ 且 $t_n = n \\Delta t$。空间域 $x \\in [0,L]$ 被离散化为 $N$ 个内部点，从而得到总共 $N+2$ 个网格点，索引为 $i=0, 1, \\dots, N+1$。空间步长为 $\\Delta x = L/(N+1)$。\n\n指定的有限差分近似为：\n$$\n\\frac{\\partial u}{\\partial t}(x_i,t_n) \\approx \\frac{u_i^{n+1}-u_i^n}{\\Delta t}\n$$\n$$\n\\frac{\\partial^2 u}{\\partial x^2}(x_i,t_n) \\approx \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2}\n$$\n将这些近似代入热方程，得到完全显式的时前空中心 (FTCS) 格式：\n$$\n\\frac{u_i^{n+1}-u_i^n}{\\Delta t} = \\alpha \\left( \\frac{u_{i+1}^n - 2 u_i^n + u_{i-1}^n}{\\Delta x^2} \\right)\n$$\n为了找到 $u_i^{n+1}$ 的更新规则，我们求解它：\n$$\nu_i^{n+1} = u_i^n + \\frac{\\alpha \\Delta t}{\\Delta x^2} (u_{i+1}^n - 2 u_i^n + u_{i-1}^n)\n$$\n让我们定义无量纲参数 $\\mu$，通常称为热方程的库朗数：\n$$\n\\mu = \\frac{\\alpha \\Delta t}{\\Delta x^2}\n$$\n通过将在时间层 $n$ 的空间模板上对应的项进行分组，可以重写更新方程：\n$$\nu_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n\n$$\n此方程适用于所有内部节点 $i=1, 2, \\dots, N$。\n\n问题要求找到保证非负性得以保持的条件。如果初始状态 $u^0$ 是非负的，即对所有 $i$ 都有 $u_i^0 \\ge 0$，我们希望确保对所有后续时间步 $n > 0$ 都有 $u_i^n \\ge 0$。从更新公式来看，$u_i^{n+1}$ 是其相邻点在前一时间步值的线性组合。如果所有的值 $u_j^n$ 都是非负的，那么当且仅当线性组合中的所有系数都为非负时，$u_i^{n+1}$ 才能保证是非负的。这是离散极值原理的一个充分条件。\n\n系数是 $\\mu$ 和 $(1 - 2\\mu)$。\n1.  参数 $\\mu = \\alpha \\Delta t / \\Delta x^2$ 是非负量（$\\alpha>0, \\Delta t>0$）的乘积，所以 $\\mu \\ge 0$ 总是满足的。\n2.  系数 $(1 - 2\\mu)$ 必须为非负：\n    $$\n    1 - 2\\mu \\ge 0 \\implies 1 \\ge 2\\mu \\implies \\mu \\le \\frac{1}{2}\n    $$\n这个条件 $\\mu \\le 1/2$ 是热方程 FTCS 格式的稳定性条件。它确保解不会无界增长，并且在此背景下，保持非负性。\n\n将 $\\mu$ 的定义代入不等式，我们得到关于时间步长 $\\Delta t$ 的条件：\n$$\n\\frac{\\alpha \\Delta t}{\\Delta x^2} \\le \\frac{1}{2} \\implies \\Delta t \\le \\frac{\\Delta x^2}{2\\alpha}\n$$\n问题将临界时间步长 $\\Delta t_\\star$ 定义为仍能保持此原理的最大时间步长。这对应于条件中的等式：\n$$\n\\Delta t_\\star = \\frac{\\Delta x^2}{2\\alpha}\n$$\n其中 $\\Delta x = L/(N+1)$。\n\n### 步骤 2：数值实验的设计\n\n该实验通过测试时间步长 $\\Delta t$ 相对于 $\\Delta t_\\star$ 的三种情景来验证所推导的条件：\n-   $\\Delta t_{\\text{bad}} = 1.1 \\, \\Delta t_\\star$：这对应于 $\\mu = 1.1 \\times 0.5 = 0.55$，违反了条件 $\\mu \\le 0.5$。\n-   $\\Delta t_{\\text{border}} = 1.0 \\, \\Delta t_\\star$：这对应于 $\\mu = 0.5$，位于稳定区域的边界上。\n-   $\\Delta t_{\\text{good}} = 0.9 \\, \\Delta t_\\star$：这对应于 $\\mu = 0.9 \\times 0.5 = 0.45$，安全地处于稳定区域内。\n\n对于每个参数集 $(\\alpha, L, N, K)$：\n1.  计算空间步长 $\\Delta x = L / (N+1)$。\n2.  计算临界时间步长 $\\Delta t_\\star = \\Delta x^2 / (2\\alpha)$。\n3.  对于三个时间步长（$\\Delta t_{\\text{bad}}$、$\\Delta t_{\\text{border}}$、$\\Delta t_{\\text{good}}$）中的每一个，执行一次模拟：\n    a. 初始化一个大小为 $N+2$ 的一维数组 `u`，以表示在网格点 $i=0, \\dots, N+1$ 上的温度。\n    b. 设置初始条件：`u` 在各处均为零，除了内部索引 $i^\\star = \\lfloor (N+1)/2 \\rfloor$ 处，$u_{i^\\star} = 1$。边界点 $u_0$ 和 $u_{N+1}$ 始终为零。\n    c. 初始化一个布尔标志 `negativity_observed = False`。\n    d. 将系统演化 $K$ 个时间步。在每一步 $n=0, \\dots, K-1$ 中：\n        i.  使用更新规则 $u_i^{n+1} = \\mu u_{i-1}^n + (1 - 2\\mu) u_i^n + \\mu u_{i+1}^n$ 从当前状态 $u^n$ 计算下一个状态 $u^{n+1}$，适用于所有内部点 $i=1, \\dots, N$。\n        ii. 计算出 $u^{n+1}$ 后，检查其是否有任何分量 $u_i^{n+1}$（对于 $i=1, \\dots, N$）是严格为负的。\n        iii. 如果任何分量小于 $0$，则设置 `negativity_observed = True` 并终止此时间步的模拟。\n    e. 记录 `negativity_observed` 的最终值。\n\n4.  一个参数集的结果是一个列表，包含三个布尔标志和计算出的 $\\Delta t_\\star$ 值：$[\\text{neg\\_bad}, \\text{neg\\_border}, \\text{neg\\_good}, \\Delta t_\\star]$。\n\n对于初始条件 $u_i^0 = \\delta_{i, i^\\star}$，第一个时间步将点 $u_{i^\\star}$ 更新为 $u_{i^\\star}^1 = (1 - 2\\mu)u_{i^\\star}^0 = 1 - 2\\mu$。如果 $\\mu > 0.5$，这个值将为负，并且在第一步就会观察到负值。如果 $\\mu \\le 0.5$，所有系数都是非负的，并且由于初始状态是非负的，所有后续状态在精确算术中都将保持非负。因此，我们预期所有测试案例的布尔结果都将是 `[True, False, False]`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(alpha, L, N, K, dt):\n    \"\"\"\n    Runs a single simulation for the 1D heat equation.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n        dt (float): Time step size.\n\n    Returns:\n        bool: True if negativity is observed, False otherwise.\n    \"\"\"\n    dx = L / (N + 1)\n    \n    # Initialize temperature array u of size N+2 for indices 0 to N+1\n    u = np.zeros(N + 2)\n    \n    # Set initial condition: a single hot spot\n    # Note: problem statement's i_star=floor((N+1)/2) is a 1-based index if interior\n    # points are 1...N. For a 0-indexed array, this corresponds to array index i_star.\n    i_star = int(np.floor((N + 1) / 2))\n    if 1 = i_star = N:\n        u[i_star] = 1.0\n\n    mu = alpha * dt / (dx**2)\n    negativity_observed = False\n\n    for _ in range(K):\n        # Create a copy to store the next state\n        u_new = u.copy()\n        \n        # Update interior points using a vectorized operation\n        u_new[1:-1] = mu * u[:-2] + (1 - 2 * mu) * u[1:-1] + mu * u[2:]\n        \n        # The boundary conditions u[0]=0 and u[N+1]=0 are implicitly handled\n        # as u_new is a copy of u and these values don't change.\n        \n        u = u_new\n        \n        # Check for negativity\n        if np.any(u  0):\n            negativity_observed = True\n            break\n            \n    return negativity_observed\n\ndef analyze_case(alpha, L, N, K):\n    \"\"\"\n    Analyzes one test case for the heat equation stability.\n\n    Args:\n        alpha (float): Thermal diffusivity.\n        L (float): Domain length.\n        N (int): Number of interior spatial points.\n        K (int): Number of time steps.\n\n    Returns:\n        list: A list containing [neg_bad, neg_border, neg_good, dt_star].\n    \"\"\"\n    # 1. Calculate the critical time step dt_star\n    dx = L / (N + 1)\n    dt_star = dx**2 / (2 * alpha)\n    \n    # 2. Define the three time steps for the experiment\n    dt_bad = 1.1 * dt_star\n    dt_border = dt_star\n    dt_good = 0.9 * dt_star\n    \n    # 3. Run simulations and record results\n    neg_bad = run_simulation(alpha, L, N, K, dt_bad)\n    neg_border = run_simulation(alpha, L, N, K, dt_border)\n    neg_good = run_simulation(alpha, L, N, K, dt_good)\n    \n    return [neg_bad, neg_border, neg_good, dt_star]\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for all test cases and print the output.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1, 50, 5),    # Case 1: (alpha, L, N, K)\n        (0.5, 2, 1, 3),   # Case 2\n        (3, 1, 20, 5)     # Case 3\n    ]\n\n    results = []\n    for case in test_cases:\n        alpha, L, N, K = case\n        result = analyze_case(alpha, L, N, K)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The map(str, ...) will correctly format each inner list.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126925"}, {"introduction": "当一个数值格式稳定后，接下来的关键问题是：“它的计算结果有多准确？” 本练习将向你介绍一种称为“收敛性研究”的基本验证技术。你将实现 FTCS 格式，并将其计算结果与一个已知的解析解进行比较，从而精确地量化数值误差。通过系统地加密网格，你将能计算出该方法的收敛率，亲手验证误差是否如理论所预测的那样减小，从而建立对代码实现的信心。[@problem_id:3126907]", "problem": "考虑基于能量守恒和 Fourier 热传导定律的一维热传导模型，该模型可导出以下抛物线型偏微分方程 (PDE)\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2},\n$$\n其中 $u(x,t)$ 是温度，$x \\in [0,1]$ 是空间坐标，$t \\in [0,T]$ 是时间，$\\nu$ 是热扩散系数。施加齐次狄利克雷边界条件 $u(0,t) = 0$ 和 $u(1,t) = 0$，并选择在 $[0,1]$ 上的有限傅里叶正弦级数作为初始条件。对于此类初始数据，每个正弦模态独立演化，精确解仍然是一个系数呈指数衰减的正弦级数。具体来说，对于初始数据\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x),\n$$\n其精确解为\n$$\nu(x,t) = \\sum_{k \\in \\mathcal{K}} a_k \\exp\\!\\big(-\\nu (k\\pi)^2 t\\big)\\,\\sin(k\\pi x).\n$$\n\n您的任务是使用均匀显式有限差分法实现一个数值基准测试，该方法使用向前差分进行时间推进，并使用中心差分来近似空间二阶导数。这种方法通常被称为向前时间中心空间 (Forward Time Centered Space, FTCS) 法。在 $[0,1]$ 上使用一个包含 $N_x$ 个区间的均匀空间网格（即网格间距 $\\Delta x = 1/N_x$），并通过稳定性参数选择时间步长 $\\Delta t$\n$$\nr = \\frac{\\nu \\,\\Delta t}{(\\Delta x)^2},\n$$\n该参数必须满足 $0  r \\le \\tfrac{1}{2}$ 以维持显式方法的数值稳定性。通过重复显式更新，将数值解从 $t=0$ 演化到 $t=T$。如果 $T$ 不是 $\\Delta t$ 的整数倍，则使用一个大小为 $\\Delta t_{\\text{last}} \\in (0,\\Delta t)$ 的最终部分时间步长，以确保最终时间恰好为 $t=T$，并使用相同的显式方法进行更新，其中 $r_{\\text{last}} = \\nu \\,\\Delta t_{\\text{last}} / (\\Delta x)^2$。\n\n对于每次计算，在最终时间 $t=T$ 时，使用 $[0,1]$ 上的离散 $L^2$ 范数和离散 $L^\\infty$ 范数来测量误差：\n$$\n\\|e\\|_{L^2} \\approx \\left(\\sum_{j=0}^{N_x} |e_j|^2\\,\\Delta x\\right)^{1/2},\\qquad\n\\|e\\|_{L^\\infty} \\approx \\max_{0 \\le j \\le N_x} |e_j|,\n$$\n其中 $e_j$ 是在网格节点 $x_j = j\\,\\Delta x$ 处的逐点误差，计算方式为数值解与 $t=T$ 时精确解之间的差值。使用一系列将网格间距减半（即 $N_x$ 加倍）的空间分辨率。使用两个最精细的分辨率，通过以下公式计算观测到的收敛率：\n$$\np_{L^2} = \\frac{\\log\\left(\\|e\\|_{L^2}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^2}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)},\\quad\np_{L^\\infty} = \\frac{\\log\\left(\\|e\\|_{L^\\infty}(\\Delta x_{\\text{coarse}}) / \\|e\\|_{L^\\infty}(\\Delta x_{\\text{fine}})\\right)}{\\log\\left(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}}\\right)}.\n$$\n\n为以下测试套件实现该基准测试。在所有情况下，空间域为 $x \\in [0,1]$，边界条件为 $u(0,t)=u(1,t)=0$，初始条件为指定的正弦级数，其振幅为 $a_k$：\n\n- 测试用例 $1$ (单模态的一般情况): $\\nu = 1$，$T = 0.05$，$\\mathcal{K} = \\{1\\}$，$a_1 = 1$，$r = 0.4$，空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 $2$ (更高频率的模态): $\\nu = 1$，$T = 0.05$，$\\mathcal{K} = \\{2\\}$，$a_2 = 1$，$r = 0.4$，空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n- 测试用例 $3$ (接近稳定性极限的叠加模态): $\\nu = 0.75$，$T = 0.05$，$\\mathcal{K} = \\{1, 2\\}$，$a_1 = 1$，$a_2 = 0.5$，$r = 0.49$，空间分辨率 $N_x \\in \\{20, 40, 80, 160\\}$。\n\n您的程序必须：\n- 根据指定的正弦级数，为每个测试用例构建精确解。\n- 从 $t=0$ 时的精确初始条件初始化数值解。\n- 使用给定的 $r$ 值，通过显式 FTCS 方法将数值解推进到 $t=T$，必要时包括一个较短的最后时间步长。\n- 为每个空间分辨率，计算在 $t=T$ 时刻的离散 $L^2$ 和 $L^\\infty$ 误差。\n- 仅使用该测试用例集合中两个最精细的分辨率，计算观测到的收敛率 $p_{L^2}$ 和 $p_{L^\\infty}$。\n\n最终输出格式要求：\n- 您的程序应产生单行输出，按顺序 $[p_{L^2}^{(1)}, p_{L^\\infty}^{(1)}, p_{L^2}^{(2)}, p_{L^\\infty}^{(2)}, p_{L^2}^{(3)}, p_{L^\\infty}^{(3)}]$ 包含六个结果，其中上标表示测试用例编号。\n- 将每个收敛率表示为浮点数。由于基准测试是无量纲的，因此不需要物理单位。\n- 您的程序应产生单行输出，其中包含一个以逗号分隔并用方括号括起来的结果列表 (例如, $[r_1,r_2,r_3,r_4,r_5,r_6]$)。", "solution": "用户提供的问题经评估为**有效**。它在科学上基于热传递和数值分析的原理，是适定的、客观的，并为一维热方程的向前时间中心空间 (FTCS) 方法的标准化收敛性研究提供了一套完整且一致的要求。\n\n求解过程如下：\n首先，我们对控制偏微分方程 (PDE) 进行离散化，然后实现数值格式，最后执行指定的基准测试来计算收敛率。\n\n### 1. 热方程的离散化\n\n一维热方程由下式给出\n$$\n\\frac{\\partial u}{\\partial t} = \\nu \\frac{\\partial^2 u}{\\partial x^2}\n$$\n定义在域 $x \\in [0, 1]$ 和 $t \\in [0, T]$ 上，其中 $\\nu$ 为热扩散系数。我们引入一个包含 $N_x$ 个区间的均匀空间网格，网格间距为 $\\Delta x = 1/N_x$。网格点为 $x_j = j \\Delta x$，其中 $j = 0, 1, \\dots, N_x$。时间域用均匀的时间步长 $\\Delta t$ 进行离散，使得 $t_n = n \\Delta t$。我们将解 $u(x_j, t_n)$ 的数值近似表示为 $u_j^n$。\n\nFTCS 方法按如下方式近似时间和空间导数：\n- 时间导数 $\\frac{\\partial u}{\\partial t}$ 使用一阶向前差分进行近似：\n$$\n\\frac{\\partial u}{\\partial t}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_j^{n+1} - u_j^n}{\\Delta t}\n$$\n- 空间二阶导数 $\\frac{\\partial^2 u}{\\partial x^2}$ 使用二阶中心差分进行近似：\n$$\n\\frac{\\partial^2 u}{\\partial x^2}\\bigg|_{(x_j, t_n)} \\approx \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n\n将这些近似代入热方程，得到 FTCS 格式的显式更新公式：\n$$\n\\frac{u_j^{n+1} - u_j^n}{\\Delta t} = \\nu \\frac{u_{j+1}^n - 2u_j^n + u_{j-1}^n}{(\\Delta x)^2}\n$$\n整理得到 $u_j^{n+1}$，我们获得了下一个时间步温度的更新规则：\n$$\nu_j^{n+1} = u_j^n + \\frac{\\nu \\Delta t}{(\\Delta x)^2} \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\n引入稳定性参数 $r = \\frac{\\nu \\Delta t}{(\\Delta x)^2}$，方程简化为：\n$$\nu_j^{n+1} = u_j^n + r \\left( u_{j+1}^n - 2u_j^n + u_{j-1}^n \\right)\n$$\n此公式应用于所有内部网格点，即 $j = 1, 2, \\dots, N_x-1$。\n\n### 2. 边界条件和初始状态的实现\n\n问题指定了齐次狄利克雷边界条件，$u(0,t) = 0$ 和 $u(1,t) = 0$。在我们的离散框架中，这转化为在所有时间步中固定网格端点的值：\n$$\nu_0^n = 0 \\quad \\text{和} \\quad u_{N_x}^n = 0 \\quad \\forall n \\ge 0\n$$\n初始条件是一个有限傅里叶正弦级数：\n$$\nu(x,0) = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x)\n$$\n数值解通过在时间 $t=0$ 时在每个网格点 $x_j$ 处评估此函数来初始化：\n$$\nu_j^0 = \\sum_{k \\in \\mathcal{K}} a_k \\sin(k\\pi x_j)\n$$\n\n### 3. 时间步进算法\n\n数值解从 $t=0$ 推进到最终时间 $t=T$。时间步长 $\\Delta t$ 由给定的稳定性参数 $r$ 和空间分辨率 $N_x$ 决定：$\\Delta t = r (\\Delta x)^2 / \\nu$。\n\n由于 $T$ 可能不是 $\\Delta t$ 的整数倍，该过程包括两个阶段：\n1.  计算完整时间步的数量，$N_{\\text{steps}} = \\lfloor T/\\Delta t \\rfloor$。使用标准的 FTCS 更新规则运行模拟 $N_{\\text{steps}}$ 次迭代。\n2.  计算剩余时间，$\\Delta t_{\\text{last}} = T - N_{\\text{steps}} \\Delta t$。如果 $\\Delta t_{\\text{last}}  0$，则执行一个最终的、较短的时间步。此最后一步的更新规则使用一个修正的稳定性参数，$r_{\\text{last}} = \\frac{\\nu \\Delta t_{\\text{last}}}{(\\Delta x)^2}$。\n\n### 4. 误差分析和收敛率\n\n将数值解 $u_j^{N_{\\text{final}}}$ 演化到 $t=T$ 后，我们通过将其与在相同网格点和最终时间评估的精确解析解进行比较来计算误差：\n$$\nu_{\\text{exact}}(x_j, T) = \\sum_{k \\in \\mathcal{K}} a_k \\exp(-\\nu (k\\pi)^2 T) \\sin(k\\pi x_j)\n$$\n逐点误差为 $e_j = u_j^{N_{\\text{final}}} - u_{\\text{exact}}(x_j, T)$。误差使用两个离散范数进行量化：\n- **离散 $L^2$ 范数:** $\\|e\\|_{L^2} = \\left(\\sum_{j=0}^{N_x} |e_j|^2 \\Delta x\\right)^{1/2}$\n- **离散 $L^\\infty$ 范数:** $\\|e\\|_{L^\\infty} = \\max_{0 \\le j \\le N_x} |e_j|$\n\n对于每个测试用例，我们为一系列空间分辨率 $N_x$ 计算这些误差。FTCS 格式的截断误差为 $O(\\Delta t + (\\Delta x)^2)$。由于我们固定了 $r$，我们有 $\\Delta t \\propto (\\Delta x)^2$，这使得该方法在空间上是二阶精度的，即全局误差预计表现为 $O((\\Delta x)^2)$。\n\n观测到的收敛阶数 $p$ 是使用来自两个最精细分辨率（网格间距为 $\\Delta x_{\\text{coarse}}$ 和 $\\Delta x_{\\text{fine}}$，其中 $\\Delta x_{\\text{coarse}} = 2 \\Delta x_{\\text{fine}}$）的误差计算的：\n$$\np = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(\\Delta x_{\\text{coarse}} / \\Delta x_{\\text{fine}})} = \\frac{\\log(\\text{error}_{\\text{coarse}} / \\text{error}_{\\text{fine}})}{\\log(2)}\n$$\n这对 $L^2$ 和 $L^\\infty$ 范数都进行计算。$p$ 的期望值约为 $2$。\n\n最终的程序为三个指定的测试用例实现了这整个过程，并收集六个收敛率以供最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(nu, T, r, initial_cond_coeffs, Nx):\n    \"\"\"\n    Runs a single simulation of the 1D heat equation using the FTCS method.\n\n    Args:\n        nu (float): Thermal diffusivity.\n        T (float): Final time.\n        r (float): Stability parameter r = nu * dt / dx^2.\n        initial_cond_coeffs (dict): Dictionary of {k: a_k} for the initial sine series.\n        Nx (int): Number of spatial intervals.\n\n    Returns:\n        tuple: A tuple containing the discrete L2 error and L-infinity error.\n    \"\"\"\n    # 1. Setup grid and time step\n    dx = 1.0 / Nx\n    x = np.linspace(0.0, 1.0, Nx + 1)\n    dt = r * dx**2 / nu\n\n    # 2. Define exact solution for verification\n    def exact_solution(x_grid, t):\n        sol = np.zeros_like(x_grid, dtype=np.float64)\n        for k, a_k in initial_cond_coeffs.items():\n            sol += a_k * np.exp(-nu * (k * np.pi)**2 * t) * np.sin(k * np.pi * x_grid)\n        return sol\n\n    # 3. Initialize numerical solution from IC\n    u_num = exact_solution(x, 0.0)\n\n    # 4. Time-stepping loop\n    num_steps = int(T / dt)\n    t_current = num_steps * dt\n    \n    # Vectorized FTCS update for full steps\n    for _ in range(num_steps):\n        # u_new = u_num.copy() # Avoids aliasing\n        # u_new[1:-1] = u_num[1:-1] + r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        # The following is a slightly more memory-efficient version\n        u_num[1:-1] += r * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # Handle final partial time step\n    dt_last = T - t_current\n    if dt_last > 1e-12: # Use a small tolerance to check for non-zero last step\n        r_last = nu * dt_last / dx**2\n        # u_new = u_num.copy()\n        # u_new[1:-1] = u_num[1:-1] + r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n        # u_num = u_new\n        u_num[1:-1] += r_last * (u_num[:-2] - 2 * u_num[1:-1] + u_num[2:])\n\n\n    # 5. Compute error at final time T\n    u_ex = exact_solution(x, T)\n    error_vec = u_num - u_ex\n    \n    # Calculate discrete L2 and L-infinity norms\n    err_l2 = np.sqrt(np.sum(error_vec**2) * dx)\n    err_linf = np.max(np.abs(error_vec))\n    \n    return err_l2, err_linf\n\ndef solve():\n    \"\"\"\n    Main function to run the benchmark for all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {1: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 1.0, \"T\": 0.05, \"r\": 0.4, \n            \"coeffs\": {2: 1.0}, \n            \"Nx_list\": [20, 40, 80, 160]\n        },\n        {\n            \"nu\": 0.75, \"T\": 0.05, \"r\": 0.49, \n            \"coeffs\": {1: 1.0, 2: 0.5},\n            \"Nx_list\": [20, 40, 80, 160]\n        }\n    ]\n\n    all_rates = []\n    \n    for case in test_cases:\n        errors_l2 = []\n        errors_linf = []\n        \n        for Nx in case[\"Nx_list\"]:\n            err_l2, err_linf = run_simulation(\n                case[\"nu\"], case[\"T\"], case[\"r\"], case[\"coeffs\"], Nx\n            )\n            errors_l2.append(err_l2)\n            errors_linf.append(err_linf)\n        \n        # Compute convergence rates using the two finest resolutions\n        # p = log(error_coarse / error_fine) / log(dx_coarse / dx_fine)\n        # Since dx_coarse / dx_fine = 2, the denominator is log(2).\n        \n        # error_coarse is at index -2 (e.g., Nx=80)\n        # error_fine is at index -1 (e.g., Nx=160)\n        p_l2 = np.log(errors_l2[-2] / errors_l2[-1]) / np.log(2.0)\n        p_linf = np.log(errors_linf[-2] / errors_linf[-1]) / np.log(2.0)\n        \n        all_rates.extend([p_l2, p_linf])\n        \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{rate:.6f}' for rate in all_rates)}]\")\n\nsolve()\n```", "id": "3126907"}, {"introduction": "一个好的数值方法不仅要稳定和准确，还应能捕捉问题的物理特性。热方程以其“平滑效应”而著称——它会自然地耗散掉尖锐的梯度。本练习将利用傅里叶分析，深入探究 FTCS 格式如何模拟这一物理行为。你将计算不同空间频率（即傅里叶模态）的衰减速率，从而量化地理解该方法的数值耗散特性，并洞察其如何模仿真实的物理扩散过程。[@problem_id:3126921]", "problem": "您将实现并使用一种显式前向时间、中心空间有限差分格式来求解一维热方程，以衡量离散傅里叶模被平滑的速度。从热方程作为基本出发点：温度场在长度为 $L$ 的空间区间上满足 $u_t = \\alpha u_{xx}$，并具有周期性边界条件，其中 $\\alpha$ 是热扩散系数。考虑一个包含 $N$ 个点的均匀网格，空间步长为 $\\Delta x = L/N$，并以时间步长 $\\Delta t$ 向前推进，使用显式前向时间更新方法，并结合中心二阶差分来近似空间二阶导数。将初始数据视为具有整数索引 $m \\in \\{0,1,\\dots,\\lfloor N/2 \\rfloor\\}$ 的单个离散傅里叶模。\n\n基于这些基本原理，推导离散傅里叶模的每时间步放大因子，然后构建一个计算，求出该模的幅度衰减至其初始幅度的至多 $e^{-1}$ 倍所需的时间步数。在此背景下，根据幅度来解释衰减，因此振荡性的符号变化是无关紧要的。对于每种情况，要输出的量是最小整数步数 $n$，使得经过 $n$ 次显式步骤后，该模的幅度小于或等于其初始幅度的 $e^{-1}$ 倍。如果在给定参数下，幅度不会衰减至 $e^{-1}$ 倍或更少（例如，每步的幅度因子等于 $1$），则输出 IEEE 浮点无穷大值。如果幅度在一步内降至零，则输出 $1$。所有输入参数必须使用国际单位制（SI 单位）处理：$L$ 的单位是米，$\\alpha$ 的单位是平方米/秒，$\\Delta t$ 的单位是秒。输出值为无量纲整数或浮点无穷大值。\n\n您的程序必须在没有用户输入的情况下运行，并处理以下参数集测试套件，每个参数集以 $(L, N, \\alpha, \\Delta t, m)$ 的形式给出：\n\n- 案例 1：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,8\\,)$。\n- 案例 2：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,1.220703125,\\,32\\,)$。\n- 案例 3：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.5,\\,0\\,)$。\n- 案例 4：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.01,\\,30\\,)$。\n- 案例 5：$(L, N, \\alpha, \\Delta t, m) = (\\,2,\\,100,\\,1.5\\times 10^{-4},\\,0.2,\\,25\\,)$。\n- 案例 6：$(L, N, \\alpha, \\Delta t, m) = (\\,1,\\,64,\\,10^{-4},\\,0.6103515625,\\,32\\,)$。\n\n这些案例测试了：平滑效果明显的一般中频模、最高频率的稳定性边界情况、不衰减的常数模、导致平滑非常缓慢的小时间步长、不同的网格和参数集，以及最高频率在一步内被湮灭的情况。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6]$）。每个条目必须是按规定计算的每个案例的最小整数 $n$，或者如果在该案例中幅度永远不会衰减至 $e^{-1}$ 倍或更少，则为浮点无穷大值。", "solution": "我们从具有周期性边界条件的空间区间上的热方程 $u_t = \\alpha u_{xx}$ 出发。在一个包含 $N$ 个点、空间步长为 $\\Delta x = L/N$、时间步长为 $\\Delta t$ 的均匀网格上，显式前向时间、中心空间有限差分格式由核心定义构建：时间上采用前向欧拉法，拉普拉斯算子采用中心二阶差分。将 $u_j^n$ 表示为网格索引 $j$ 和时间层 $n$ 处的数值近似，更新规则为\n$$\nu_j^{n+1} = u_j^n + \\alpha \\Delta t \\,\\frac{u_{j+1}^n - 2 u_j^n + u_{j-1}^n}{(\\Delta x)^2}.\n$$\n定义无量纲比率\n$$\nr = \\frac{\\alpha \\Delta t}{(\\Delta x)^2}.\n$$\n在周期性边界条件下，离散傅里叶模 $u_j^n = A^n \\exp\\!\\left(i \\frac{2\\pi m}{N} j\\right)$ 是离散拉普拉斯算子 $u_{j+1} - 2 u_j + u_{j-1}$ 的本征函数。作用于这样一个模，得到本征值\n$$\n\\lambda_m = -4 \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right),\n$$\n这源于恒等式 $\\exp(i\\theta) + \\exp(-i\\theta) - 2 = -4 \\sin^2(\\theta/2)$，其中 $\\theta = \\frac{2\\pi m}{N}$。将此代入更新公式，得到模 $m$ 的每步放大因子：\n$$\nG_m = 1 + r \\lambda_m = 1 - 4 r \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right).\n$$\n因此，经过 $n$ 步后，该模的振幅幅度乘以 $\\lvert G_m \\rvert^n$。为了找到将幅度衰减至其初始值的至多 $e^{-1}$ 倍所需的步数，我们需要\n$$\n\\lvert G_m \\rvert^n \\le e^{-1}.\n$$\n当 $0  \\lvert G_m \\rvert  1$ 时，取自然对数可得\n$$\nn \\ge \\frac{1}{-\\ln \\lvert G_m \\rvert}.\n$$\n由于该格式以整数时间步推进，满足该不等式的最小整数是\n$$\nn_{\\min} = \\left\\lceil \\frac{1}{-\\ln \\lvert G_m \\rvert} \\right\\rceil.\n$$\n必须仔细处理特殊情况：\n- 如果 $m = 0$，则 $\\sin^2\\!\\left(\\frac{\\pi m}{N}\\right) = 0$ 且 $G_0 = 1$，意味着没有衰减；我们输出浮点无穷大值。\n- 如果 $\\lvert G_m \\rvert = 1$（例如，当 $r = \\tfrac{1}{2}$ 且 $m = \\tfrac{N}{2}$ 时），则没有衰减；我们输出浮点无穷大值。\n- 如果 $G_m = 0$，则该模在一步内被湮灭；使得 $\\lvert G_m \\rvert^n \\le e^{-1}$ 成立的最小整数 $n$ 是 $n=1$。\n\n对于每个测试案例 $(L, N, \\alpha, \\Delta t, m)$ 的算法步骤：\n1. 计算 $\\Delta x = L/N$ 和 $r = \\alpha \\Delta t / (\\Delta x)^2$。\n2. 计算 $s = \\sin^2\\!\\left(\\frac{\\pi m}{N}\\right)$ 和 $G_m = 1 - 4 r s$。\n3. 设置 $g = \\lvert G_m \\rvert$。\n4. 如果 $g$ 在一个小的容差范围内数值上等于 $1$，则返回浮点无穷大值。\n5. 如果 $g$ 在一个小的容差范围内数值上等于 $0$，则返回 $1$。\n6. 否则，计算 $n_{\\min} = \\left\\lceil \\frac{1}{-\\ln g} \\right\\rceil$ 并返回该整数。\n\n所提供的测试套件确保了覆盖范围：\n- 案例 1 测试一个具有明显平滑效果的中频模 ($0  \\lvert G_m \\rvert  1$)。\n- 案例 2 设置 $r=\\tfrac{1}{2}$ 和 $m=\\tfrac{N}{2}$，得到 $\\lvert G_m \\rvert = 1$ 且没有衰减。\n- 案例 3 使用 $m=0$（常数模），该模式不会衰减。\n- 案例 4 使用一个非常小的时间步长 $\\Delta t$，导致平滑非常缓慢，从而得到一个大的 $n_{\\min}$。\n- 案例 5 改变 $L$、$N$ 和 $\\alpha$ 来展示参数敏感性。\n- 案例 6 设置 $r=\\tfrac{1}{4}$ 和 $m=\\tfrac{N}{2}$，得到 $G_m=0$，并在一步内立即湮灭。\n\n最终的程序计算这些量，并在一行内打印出六个结果，结果为逗号分隔的列表，并用方括号括起来。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef steps_to_e_minus_one(L, N, alpha, dt, m):\n    \"\"\"\n    Compute the smallest integer number of explicit time steps required\n    to attenuate the magnitude of discrete Fourier mode m by at most e^{-1}.\n    Special cases:\n      - If |G| == 1 (no attenuation), return float('inf').\n      - If |G| == 0 (annihilated in one step), return 1.\n    \"\"\"\n    dx = L / N\n    r = alpha * dt / (dx * dx)\n    s = np.sin(np.pi * m / N) ** 2\n    G = 1.0 - 4.0 * r * s\n    gmag = abs(G)\n\n    # Numerical tolerances to handle floating-point edge cases\n    # Treat values extremely close to 1 as no attenuation and close to 0 as annihilation.\n    if np.isclose(gmag, 1.0, rtol=1e-12, atol=1e-15):\n        return float('inf')\n    if np.isclose(gmag, 0.0, rtol=0.0, atol=1e-15):\n        return 1\n\n    # For 0  gmag  1, compute smallest integer n such that gmag^n = e^{-1}\n    # i.e., n >= 1 / (-ln(gmag)).\n    ln_g = np.log(gmag)\n    if ln_g >= 0.0:\n        # Unstable or no decay (shouldn't occur in our test suite if parameters are stable),\n        # conservatively return infinity.\n        return float('inf')\n\n    n_min = int(np.ceil(1.0 / (-ln_g)))\n    # Ensure at least 1 step when attenuation happens immediately (guard against pathological roundoff).\n    return max(1, n_min)\n\ndef solve():\n    # Define the test cases from the problem statement:\n    # Each case is a tuple: (L [m], N, alpha [m^2/s], dt [s], m)\n    test_cases = [\n        (1.0, 64, 1e-4, 0.5, 8),\n        (1.0, 64, 1e-4, 1.220703125, 32),\n        (1.0, 64, 1e-4, 0.5, 0),\n        (1.0, 64, 1e-4, 0.01, 30),\n        (2.0, 100, 1.5e-4, 0.2, 25),\n        (1.0, 64, 1e-4, 0.6103515625, 32),\n    ]\n\n    results = []\n    for L, N, alpha, dt, m in test_cases:\n        result = steps_to_e_minus_one(L, N, alpha, dt, m)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3126921"}]}