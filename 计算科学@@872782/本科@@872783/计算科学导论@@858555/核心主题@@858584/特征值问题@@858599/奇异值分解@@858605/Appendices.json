{"hands_on_practices": [{"introduction": "第一个练习旨在巩固奇异值分解（SVD）的基本定义。通过其组成部分（$U$, $\\Sigma$, $V^T$）重建一个矩阵，你将练习该分解的运算机制，并直观地看到正交矩阵和对角矩阵是如何协同作用形成原始变换的。[@problem_id:21856]", "problem": "奇异值分解 (SVD) 是将一个实矩阵 $A$ 分解为其他三个矩阵乘积的一种基本方法。对于一个大小为 $n \\times n$ 的方阵 $A$，其分解形式如下：\n$$\nA = U \\Sigma V^T\n$$\n此处，$U$ 和 $V$ 是 $n \\times n$ 的正交矩阵（意味着 $U^T U = I$ 且 $V^T V = I$，其中 $I$ 是单位矩阵），而 $\\Sigma$ 是一个 $n \\times n$ 的对角矩阵，其对角元素 $\\sigma_i$ 是非负的，并被称为 $A$ 的奇异值。按照惯例，奇异值按 $\\sigma_1 \\geq \\sigma_2 \\geq \\dots \\geq \\sigma_n \\geq 0$ 的顺序排列。\n\n考虑一个特定的 $2 \\times 2$ 矩阵 $A$，其 SVD 分解的各部分由以下给出：\n$$\nU = \\frac{1}{\\sqrt{2}} \\begin{pmatrix} 1 & -1 \\\\ 1 & 1 \\end{pmatrix}\n$$\n$$\n\\Sigma = \\begin{pmatrix} \\sigma_1 & 0 \\\\ 0 & \\sigma_2 \\end{pmatrix}\n$$\n$$\nV = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix}\n$$\n其中 $\\sigma_1$ 和 $\\sigma_2$ 是代表奇异值的正常数，且 $\\sigma_1 > \\sigma_2$。\n\n您的任务是从 $A$ 的 SVD 分解部分重构出原始矩阵 $A$。推导出矩阵 $A$ 中位于第一行第二列的元素，记作 $A_{12}$。", "solution": "我们有\n$$A \\;=\\; U\\,\\Sigma\\,V^T\\;=\\;U\\,\\Sigma\\,V$$\n因为对于给定的 $V$，有 $V^T=V$。写出这些矩阵：\n$$U=\\frac{1}{\\sqrt2}\\begin{pmatrix}1 & -1\\\\1 & 1\\end{pmatrix}, \n\\quad\n\\Sigma=\\begin{pmatrix}\\sigma_1 & 0\\\\0 & \\sigma_2\\end{pmatrix},\n\\quad\nV=\\begin{pmatrix}0 & 1\\\\1 & 0\\end{pmatrix}。$$\n首先计算\n$$\\Sigma\\,V\n=\\begin{pmatrix}\\sigma_1 & 0\\\\0 & \\sigma_2\\end{pmatrix}\n\\begin{pmatrix}0 & 1\\\\1 & 0\\end{pmatrix}\n=\\begin{pmatrix}\n\\sigma_1\\cdot0 + 0\\cdot1 & \\sigma_1\\cdot1 + 0\\cdot0\\\\\n0\\cdot0 + \\sigma_2\\cdot1 & 0\\cdot1 + \\sigma_2\\cdot0\n\\end{pmatrix}\n=\\begin{pmatrix}0 & \\sigma_1\\\\\\sigma_2 & 0\\end{pmatrix}。$$\n现在乘以 $U$：\n$$A\n=U\\,(\\Sigma V)\n=\\frac{1}{\\sqrt2}\\begin{pmatrix}1 & -1\\\\1 & 1\\end{pmatrix}\n\\begin{pmatrix}0 & \\sigma_1\\\\\\sigma_2 & 0\\end{pmatrix}。$$\n该乘积的 $(1,2)$ 位置上的元素是\n$$A_{12}\n=\\frac{1}{\\sqrt2}\\bigl(1\\cdot\\sigma_1 + (-1)\\cdot0\\bigr)\n=\\frac{\\sigma_1}{\\sqrt2}。$$", "answer": "$$\\boxed{\\frac{\\sigma_1}{\\sqrt{2}}}$$", "id": "21856"}, {"introduction": "这个问题更进一步，要求你计算一个给定矩阵的SVD，并将其表示为一系列秩一矩阵的和。这种外积展开对于理解图像压缩等应用至关重要，因为它揭示了任何矩阵都可以被视为由一系列代表主要方向和权重的简单分量叠加而成。[@problem_id:1388906]", "problem": "在许多应用中，从图像压缩到推荐系统，一个关键操作是用一系列更简单的秩一矩阵之和来近似一个大矩阵。奇异值分解（SVD）提供了一种系统的方法来构建这种表示。\n\nSVD 允许将任意秩为 $r$ 的 $m \\times n$ 矩阵 $A$ 精确表示为 $r$ 个秩一矩阵之和：\n$$A = \\sum_{i=1}^{r} \\sigma_i u_i v_i^T$$\n其中 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge \\sigma_r > 0$ 是奇异值，$u_i \\in \\mathbb{R}^m$ 是左奇异向量（它们构成一个标准正交集），$v_i \\in \\mathbb{R}^n$ 是右奇异向量（它们也构成一个标准正交集）。\n\n考虑矩阵：\n$$A = \\begin{pmatrix} 4 & 1 \\\\ 0 & 0 \\\\ 1 & 4 \\end{pmatrix}$$\n该矩阵的秩为 $r=2$。请根据其奇异值分解，确定其作为两个秩一矩阵之和的表示形式。\n\n你的最终答案应为两个有理数项的 $3 \\times 2$ 矩阵的显式和。", "solution": "我们被要求将给定的矩阵 $A \\in \\mathbb{R}^{3 \\times 2}$\n$$\nA=\\begin{pmatrix}4 & 1 \\\\ 0 & 0 \\\\ 1 & 4\\end{pmatrix}\n$$\n表示为两个秩一矩阵的和，使用其奇异值分解，并提供一个各项为有理数的显式和。\n\n根据 SVD，$A=\\sum_{i=1}^{r}\\sigma_{i}u_{i}v_{i}^{T}$，其中 $\\sigma_{i}>0$ 是奇异值，$u_{i}$ 和 $v_{i}$ 分别是标准正交的左奇异向量和右奇异向量。奇异值是 $A^{T}A$ 的特征值的平方根。\n\n计算\n$$\nA^{T}A=\\begin{pmatrix}4 & 0 & 1 \\\\ 1 & 0 & 4\\end{pmatrix}\\begin{pmatrix}4 & 1 \\\\ 0 & 0 \\\\ 1 & 4\\end{pmatrix}=\\begin{pmatrix}17 & 8 \\\\ 8 & 17\\end{pmatrix}.\n$$\n对于形如 $\\begin{pmatrix}a & b \\\\ b & a\\end{pmatrix}$ 的矩阵，其特征值为 $a+b$ 和 $a-b$。因此，$A^{T}A$ 的特征值为\n$$\n\\lambda_{1}=25,\\quad \\lambda_{2}=9,\n$$\n所以奇异值为\n$$\n\\sigma_{1}=5,\\quad \\sigma_{2}=3.\n$$\n相应的标准正交右奇异向量是 $A^{T}A$ 的特征向量。对于 $\\lambda_{1}=25$，一个特征向量与 $\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}$ 成比例；对于 $\\lambda_{2}=9$，一个特征向量与 $\\begin{pmatrix}1 \\\\ -1\\end{pmatrix}$ 成比例。单位化后得到\n$$\nv_{1}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix},\\quad v_{2}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ -1\\end{pmatrix}.\n$$\n左奇异向量为 $u_{i}=\\frac{1}{\\sigma_{i}}Av_{i}$。计算\n$$\nAv_{1}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}4 & 1 \\\\ 0 & 0 \\\\ 1 & 4\\end{pmatrix}\\begin{pmatrix}1 \\\\ 1\\end{pmatrix}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}5 \\\\ 0 \\\\ 5\\end{pmatrix}=\\frac{5}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ 1\\end{pmatrix},\n$$\n所以\n$$\nu_{1}=\\frac{1}{5}Av_{1}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ 1\\end{pmatrix}.\n$$\n类似地，\n$$\nAv_{2}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}4 & 1 \\\\ 0 & 0 \\\\ 1 & 4\\end{pmatrix}\\begin{pmatrix}1 \\\\ -1\\end{pmatrix}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}3 \\\\ 0 \\\\ -3\\end{pmatrix}=\\frac{3}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ -1\\end{pmatrix},\n$$\n所以\n$$\nu_{2}=\\frac{1}{3}Av_{2}=\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ -1\\end{pmatrix}.\n$$\n因此，\n$$\nA=\\sigma_{1}u_{1}v_{1}^{T}+\\sigma_{2}u_{2}v_{2}^{T}\n=5\\left(\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ 1\\end{pmatrix}\\right)\\left(\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & 1\\end{pmatrix}\\right)+3\\left(\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 \\\\ 0 \\\\ -1\\end{pmatrix}\\right)\\left(\\frac{1}{\\sqrt{2}}\\begin{pmatrix}1 & -1\\end{pmatrix}\\right).\n$$\n进行外积运算并简化标量因子，得到\n$$\nA=\\frac{5}{2}\\begin{pmatrix}1 & 1 \\\\ 0 & 0 \\\\ 1 & 1\\end{pmatrix}+\\frac{3}{2}\\begin{pmatrix}1 & -1 \\\\ 0 & 0 \\\\ -1 & 1\\end{pmatrix}.\n$$\n两个加数都是秩一矩阵，且所有项都是有理数，符合要求。直接求和检验得出\n$$\n\\begin{pmatrix}\\frac{5}{2} & \\frac{5}{2} \\\\ 0 & 0 \\\\ \\frac{5}{2} & \\frac{5}{2}\\end{pmatrix}+\\begin{pmatrix}\\frac{3}{2} & -\\frac{3}{2} \\\\ 0 & 0 \\\\ -\\frac{3}{2} & \\frac{3}{2}\\end{pmatrix}=\\begin{pmatrix}4 & 1 \\\\ 0 & 0 \\\\ 1 & 4\\end{pmatrix}=A.\n$$", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{5}{2} & \\frac{5}{2} \\\\ 0 & 0 \\\\ \\frac{5}{2} & \\frac{5}{2}\\end{pmatrix}+\\begin{pmatrix}\\frac{3}{2} & -\\frac{3}{2} \\\\ 0 & 0 \\\\ -\\frac{3}{2} & \\frac{3}{2}\\end{pmatrix}}$$", "id": "1388906"}, {"introduction": "对于大型矩阵，手动计算SVD是不切实际的。这个编程练习将演示如何使用从幂迭代法派生出的迭代算法，高效地找到主导奇异值及其对应的奇异向量，从而在抽象理论与计算科学之间架起一座桥梁。[@problem_id:3275076]", "problem": "你需要设计并实现一个程序，仅使用幂法原理，从第一性原理和核心定义出发，近似计算一个实矩阵的主奇异三元组。首先从以下定义开始：对于一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$，其最大奇异值 $ \\sigma_1 $ 是由欧几里得范数诱导的算子范数，即在单位向量 $ x \\in \\mathbb{R}^n $ 上 $ \\lVert A x \\rVert_2 $ 的上确界。你的概念基础只能使用关于对称半正定矩阵和幂法的已确立事实。\n\n你的任务是推导并实现一个迭代算法，该算法：\n- 近似计算最大奇异值 $ \\sigma_1 $ 以及相应的左、右奇异向量 $ u_1 \\in \\mathbb{R}^m $ 和 $ v_1 \\in \\mathbb{R}^n $。\n- 仅使用与 $ A $ 和 $ A^\\top $ 的矩阵向量乘积以及向量归一化。你决不能显式地构建 $ A^\\top A $。\n- 从一个单位范数初始向量 $ v^{(0)} \\in \\mathbb{R}^n $ 开始，该向量通过使用指定的伪随机种子对独立标准正态分布条目进行采样，然后归一化到单位长度得到。\n- 采用的停止准则是奇异值估计的相对变化至多为给定的容差 $ \\tau $，即当 $ \\frac{\\lvert \\sigma^{(k+1)} - \\sigma^{(k)} \\rvert}{\\max(\\sigma^{(k+1)}, \\varepsilon)} \\le \\tau $ 时停止，其中 $ \\varepsilon $ 是一个微小的正常数，你可以将其设置为一个合理的机器精度级别的值。同时施加最大迭代次数 $ k_{\\max} $。\n- 稳健地处理 $ A $ 是零矩阵的情况，此时 $ \\sigma_1 = 0 $ 且任何奇异向量都是可接受的；确保你的实现避免了除以零的错误。\n\n对于下面的每个测试用例，你的程序必须：\n- 运行上述算法以产生一个近似值 $ \\widehat{\\sigma}_1 $。\n- 使用一个可靠的奇异值数值程序计算一个参考值 $ \\sigma_1^{\\star} $。\n- 报告绝对误差 $ \\lvert \\widehat{\\sigma}_1 - \\sigma_1^{\\star} \\rvert $。\n\n测试套件：\n- 使用以下五个矩阵 $ A^{(i)} $，其维度已指明。对于每个矩阵，也使用指定的容差 $ \\tau $、最大迭代次数 $ k_{\\max} $ 和用于初始向量 $ v^{(0)} $ 的伪随机种子 $ s $。\n1. $ A^{(1)} \\in \\mathbb{R}^{4 \\times 3} $，其条目为\n   $ \\left[ \\left[ 3.0, 1.0, 1.0 \\right], \\left[ 0.0, 2.0, 0.0 \\right], \\left[ 0.0, 0.0, 1.0 \\right], \\left[ 1.0, 0.0, 0.5 \\right] \\right] $，其中 $ \\tau = 10^{-12} $，$ k_{\\max} = 1000 $，$ s = 0 $。\n2. $ A^{(2)} \\in \\mathbb{R}^{3 \\times 2} $，其条目为\n   $ \\left[ \\left[ 0.0, 0.0 \\right], \\left[ 0.0, 0.0 \\right], \\left[ 0.0, 0.0 \\right] \\right] $，其中 $ \\tau = 10^{-12} $，$ k_{\\max} = 1000 $，$ s = 1 $。\n3. $ A^{(3)} \\in \\mathbb{R}^{4 \\times 3} $，其条目为\n   $ \\left[ \\left[ 10.0, 0.0, 0.0 \\right], \\left[ 0.0, 0.0, 0.0 \\right], \\left[ 0.0, 0.0, 0.0 \\right], \\left[ 0.0, 0.0, 0.0 \\right] \\right] $，其中 $ \\tau = 10^{-12} $，$ k_{\\max} = 1000 $，$ s = 2 $。\n4. $ A^{(4)} \\in \\mathbb{R}^{3 \\times 3} $，其条目为\n   $ \\left[ \\left[ 5.0, 0.0, 0.0 \\right], \\left[ 0.0, 5.0, 0.0 \\right], \\left[ 0.0, 0.0, 5.0 \\right] \\right] $，其中 $ \\tau = 10^{-12} $，$ k_{\\max} = 1000 $，$ s = 3 $。\n5. $ A^{(5)} \\in \\mathbb{R}^{5 \\times 4} $，其条目为\n   $ \\left[ \\left[ 1.0, 0.0, 0.0, 0.0 \\right], \\left[ 0.0, 0.1, 0.0, 0.0 \\right], \\left[ 0.0, 0.0, 0.01, 0.0 \\right], \\left[ 0.0, 0.0, 0.0, 10^{-6} \\right], \\left[ 1.0, 1.0, 1.0, 1.0 \\right] \\right] $，其中 $ \\tau = 10^{-12} $，$ k_{\\max} = 2000 $，$ s = 4 $。\n\n最终输出规范：\n- 你的程序必须生成一行，其中包含按上述五个测试用例顺序排列的 $ \\sigma_1 $ 的绝对误差列表。\n- 格式：一个形如 $ \\left[ e_1, e_2, e_3, e_4, e_5 \\right] $ 的单行字符串，不含空格，其中每个 $ e_i $ 是以科学记数法格式化的绝对误差，小数点后有 $ 12 $ 位数字（例如，$ 1.234000000000\\mathrm{e}{-06} $）。", "solution": "该问题要求设计并实现一种迭代算法，以寻找一个实矩阵 $A \\in \\mathbb{R}^{m \\times n}$ 的主奇异三元组（$ \\sigma_1, u_1, v_1 $）。推导过程必须从第一性原理出发，并依赖于幂法以及对称半正定矩阵的性质。\n\n矩阵 $A$ 的奇异值分解（SVD）由 $A = U \\Sigma V^\\top$ 给出，其中 $U \\in \\mathbb{R}^{m \\times m}$ 和 $V \\in \\mathbb{R}^{n \\times n}$ 是正交矩阵，$\\Sigma \\in \\mathbb{R}^{m \\times n}$ 是一个矩形对角矩阵，其主对角线上的非负元素满足 $\\sigma_1 \\ge \\sigma_2 \\ge \\dots \\ge 0$。$U$ 的列是左奇异向量（$u_i$），$V$ 的列是右奇异向量（$v_i$）。它们通过以下方程相关联：\n$$ A v_i = \\sigma_i u_i $$\n$$ A^\\top u_i = \\sigma_i v_i $$\n其中 $i = 1, \\dots, \\min(m, n)$。\n\n从这些关系中，我们可以推导出与特征值问题的联系。考虑矩阵 $A^\\top A \\in \\mathbb{R}^{n \\times n}$。该矩阵是对称且半正定的。其性质是我们推导的核心。将 $A^\\top$ 应用于第一个SVD方程得到：\n$$(A^\\top A) v_i = A^\\top (A v_i) = A^\\top (\\sigma_i u_i) = \\sigma_i (A^\\top u_i) = \\sigma_i (\\sigma_i v_i) = \\sigma_i^2 v_i$$\n这表明 $A$ 的右奇异向量 $v_i$ 是 $A^\\top A$ 的特征向量，而奇异值的平方 $\\sigma_i^2$ 是对应的特征值。由于 $A^\\top A$ 是半正定的，其所有特征值都是非负的，即 $\\sigma_i^2 \\ge 0$。\n\n主奇异值 $\\sigma_1$ 是最大的奇异值。因此，其平方 $\\sigma_1^2$ 是矩阵 $A^\\top A$ 的最大特征值。这提示我们可以使用幂法，这是一种旨在寻找最大模特征值（主特征值）及其对应特征向量的迭代算法。\n\n当应用于矩阵 $B$ 时，幂法会生成一个向量序列 $x^{(k)}$，该序列收敛到与主特征值相关联的特征向量。标准迭代过程是：\n$$ x^{(k+1)} = \\frac{B x^{(k)}}{\\lVert B x^{(k)} \\rVert_2} $$\n从一个随机的初始单位范数向量 $x^{(0)}$ 开始，序列 $x^{(k)}$ 收敛到主特征向量（假设主特征值是唯一的，并且 $x^{(0)}$ 在其方向上的分量非零）。\n\n为了找到 $\\sigma_1$ 和 $v_1$，我们将幂法应用于矩阵 $B = A^\\top A$。迭代将是：\n$$ v^{(k+1)} = \\frac{(A^\\top A) v^{(k)}}{\\lVert (A^\\top A) v^{(k)} \\rVert_2} $$\n当迭代次数 $k \\to \\infty$ 时，向量 $v^{(k)}$ 收敛到 $v_1$。\n\n问题规定我们不能显式地构建矩阵 $A^\\top A$，这对于大型或稀疏矩阵来说在计算上更有优势。矩阵向量乘积 $(A^\\top A) v^{(k)}$ 可以通过两个连续的乘积来计算：首先是 $w^{(k)} = A v^{(k)}$，然后是 $y^{(k)} = A^\\top w^{(k)}$。\n\n一个更直接且数值上更稳定的算法，该算法在每一步中也提供了对 $u_1$ 和 $\\sigma_1$ 的估计，是通过交替应用 $A$ 和 $A^\\top$ 并进行归一化来构建的。该方法如下：\n\n1.  用一个随机的单位范数向量 $v^{(0)} \\in \\mathbb{R}^n$ 初始化。\n2.  对于 $k=0, 1, 2, \\dots$：\n    a. 计算一个未归一化的左奇异向量：$u_{temp}^{(k+1)} = A v^{(k)}$。\n    b. 该向量的范数是奇异值的估计：$\\sigma^{(k+1)} = \\lVert u_{temp}^{(k+1)} \\rVert_2$。\n    c. 归一化以获得估计的左奇异向量：$u^{(k+1)} = u_{temp}^{(k+1)} / \\sigma^{(k+1)}$。\n    d. 计算一个未归一化的右奇异向量：$v_{temp}^{(k+1)} = A^\\top u^{(k+1)}$。\n    e. 归一化以获得右奇异向量的下一次迭代：$v^{(k+1)} = v_{temp}^{(k+1)} / \\lVert v_{temp}^{(k+1)} \\rVert_2$。\n\n让我们验证此方案中 $v$ 的更新等同于对 $A^\\top A$ 的幂迭代。将步骤 (a-d) 的表达式代入 (e) 中：\n$$ v^{(k+1)} = \\frac{A^\\top u^{(k+1)}}{\\lVert A^\\top u^{(k+1)} \\rVert_2} = \\frac{A^\\top \\left( \\frac{A v^{(k)}}{\\lVert A v^{(k)} \\rVert_2} \\right) }{\\lVert A^\\top \\left( \\frac{A v^{(k)}}{\\lVert A v^{(k)} \\rVert_2} \\right) \\rVert_2} = \\frac{ A^\\top A v^{(k)} } { \\lVert A^\\top A v^{(k)} \\rVert_2 } $$\n这确实是应用于 $A^\\top A$ 的幂法。因此，当 $k \\to \\infty$ 时，$v^{(k)}$ 收敛到 $v_1$。因此，$u_{temp}^{(k+1)} = A v^{(k)}$ 收敛到 $A v_1 = \\sigma_1 u_1$。估计值 $\\sigma^{(k+1)} = \\lVert u_{temp}^{(k+1)} \\rVert_2$ 收敛到 $\\lVert \\sigma_1 u_1 \\rVert_2 = \\sigma_1 \\lVert u_1 \\rVert_2 = \\sigma_1$。最后，估计值 $u^{(k+1)}$ 收敛到 $u_1$。该算法正确地近似了主奇异三元组（$\\sigma_1, u_1, v_1$）。\n\n算法基于两个条件终止：\n1.  达到最大迭代次数 $k_{\\max}$。\n2.  奇异值估计的相对变化低于容差 $\\tau$：\n    $$ \\frac{\\lvert \\sigma^{(k+1)} - \\sigma^{(k)} \\rvert}{\\max(\\sigma^{(k+1)}, \\varepsilon)} \\le \\tau $$\n    其中 $\\varepsilon$ 是一个小的机器精度级别的常数，用于防止当 $\\sigma^{(k+1)}$ 接近零时发生除零错误。\n\n为了保证稳健性，如果在任何步骤中 $\\sigma^{(k+1)} = \\lVert A v^{(k)} \\rVert_2$ 为零（或在数值上无法与之区分），这意味着 $v^{(k)}$ 在 $A$ 的零空间中，或者 $A$ 是零矩阵。在这种情况下，它表明最大奇异值为零。算法应终止并报告估计值 $\\widehat{\\sigma}_1 = 0$。\n\n实现将遵循这个推导出的过程。对于每个测试用例，它将：\n1.  使用给定的种子初始化一个适当维度的随机单位向量 $v$。\n2.  如上所述迭代更新 $v$、$u$ 和 $\\sigma$，直到满足停止准则。\n3.  最终估计值 $\\widehat{\\sigma}_1$ 是最后计算出的 $\\sigma^{(k)}$ 的值。\n4.  将此估计值与使用高保真库函数（`numpy.linalg.norm(A, 2)`）计算的参考值 $\\sigma_1^\\star$ 进行比较，并报告绝对误差 $\\lvert \\widehat{\\sigma}_1 - \\sigma_1^\\star \\rvert$。", "answer": "```python\nimport numpy as np\n\ndef _compute_dominant_sv(A, tau, k_max, seed):\n    \"\"\"\n    Approximates the dominant singular value of a matrix A using the power method.\n\n    Args:\n        A (np.ndarray): The input matrix.\n        tau (float): The tolerance for the stopping criterion.\n        k_max (int): The maximum number of iterations.\n        seed (int): The seed for the random number generator.\n\n    Returns:\n        float: The estimated dominant singular value sigma_1.\n    \"\"\"\n    eps = np.finfo(A.dtype).eps\n    m, n = A.shape\n\n    if n == 0:\n        return 0.0\n\n    rng = np.random.default_rng(seed)\n    v = rng.standard_normal(size=n, dtype=A.dtype)\n    \n    norm_v = np.linalg.norm(v)\n    if norm_v  eps:\n        # Extremely unlikely event, but handle robustly.\n        v = np.ones(n, dtype=A.dtype)\n        norm_v = np.sqrt(n)\n    \n    v = v / norm_v\n    \n    sigma_prev = 0.0\n    sigma_curr = 0.0\n\n    for _ in range(k_max):\n        u_unnormalized = A @ v\n        \n        sigma_curr = np.linalg.norm(u_unnormalized)\n        \n        # Check for convergence\n        relative_change = abs(sigma_curr - sigma_prev) / max(sigma_curr, eps)\n        if relative_change = tau:\n            break\n            \n        # Handle the case of a zero or numerically zero matrix\n        if sigma_curr  eps:\n            sigma_curr = 0.0\n            break\n            \n        u = u_unnormalized / sigma_curr\n        \n        v_unnormalized = A.T @ u\n        \n        norm_v_unnormalized = np.linalg.norm(v_unnormalized)\n        if norm_v_unnormalized  eps:\n            # Convergence may occur if u is in the nullspace of A.T\n            break\n\n        v = v_unnormalized / norm_v_unnormalized\n        sigma_prev = sigma_curr\n        \n    return sigma_curr\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\n            np.array([[3.0, 1.0, 1.0], [0.0, 2.0, 0.0], [0.0, 0.0, 1.0], [1.0, 0.0, 0.5]], dtype=float),\n            1e-12, 1000, 0\n        ),\n        (\n            np.array([[0.0, 0.0], [0.0, 0.0], [0.0, 0.0]], dtype=float),\n            1e-12, 1000, 1\n        ),\n        (\n            np.array([[10.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]], dtype=float),\n            1e-12, 1000, 2\n        ),\n        (\n            np.array([[5.0, 0.0, 0.0], [0.0, 5.0, 0.0], [0.0, 0.0, 5.0]], dtype=float),\n            1e-12, 1000, 3\n        ),\n        (\n            np.array([[1.0, 0.0, 0.0, 0.0], [0.0, 0.1, 0.0, 0.0], [0.0, 0.0, 0.01, 0.0], [0.0, 0.0, 0.0, 1e-6], [1.0, 1.0, 1.0, 1.0]], dtype=float),\n            1e-12, 2000, 4\n        ),\n    ]\n\n    results = []\n    for case in test_cases:\n        A, tau, k_max, seed = case\n        \n        # Approximate sigma_1 using the derived power method\n        sigma1_hat = _compute_dominant_sv(A, tau, k_max, seed)\n        \n        # Compute the reference sigma_1 using a reliable method\n        # np.linalg.norm(A, 2) computes the largest singular value (operator 2-norm)\n        sigma1_ref = np.linalg.norm(A, 2)\n        \n        # Calculate the absolute error\n        result = abs(sigma1_hat - sigma1_ref)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    formatted_results = [f\"{res:.12e}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3275076"}]}