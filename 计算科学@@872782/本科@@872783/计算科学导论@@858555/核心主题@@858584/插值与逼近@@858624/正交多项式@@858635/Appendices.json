{"hands_on_practices": [{"introduction": "该练习 [@problem_id:2192753] 是您从零开始构建正交多项式的入门实践。通过将熟悉的格拉姆-施密特正交化过程应用于像 $1$ 和 $x$ 这样的简单函数，您将亲身体验函数空间中的正交性是如何定义和实现的，为后续所有概念奠定基础。", "problem": "考虑定义在一般区间 $[a, b]$ 上的实值多项式向量空间，其中 $a$ 和 $b$ 是实常数且 $a  b$。该空间配备有一个内积，对任意两个多项式 $f(x)$ 和 $g(x)$ 定义如下：\n$$\n\\langle f, g \\rangle = \\int_a^b f(x)g(x) \\, dx\n$$\n从次数至多为一的多项式子空间的基底 $\\{v_0(x) = 1, v_1(x) = x\\}$ 出发，构造一个由两个正交多项式 $\\{p_0(x), p_1(x)\\}$ 组成的集合。所构造的多项式必须满足以下条件：\n1.  集合 $\\{p_0(x), p_1(x)\\}$ 构成由 $\\{1, x\\}$ 张成的子空间的一个正交基，即 $\\langle p_0, p_1 \\rangle = 0$。\n2.  $p_0(x)$ 和 $p_1(x)$ 都是首一多项式。如果一个多项式的首项系数（$x$ 的最高次幂的系数）为1，则该多项式是首一的。对于一个常数多项式 $c$，如果 $c=1$，则它被认为是首一的。\n\n将您的答案以行矩阵的形式表示为一对多项式 $(p_0(x), p_1(x))$。", "solution": "我们被给定在 $[a,b]$ 上的多项式内积定义为 $\\langle f, g \\rangle = \\int_{a}^{b} f(x)g(x)\\,dx$，以及次数至多为一的子空间的初始基底 $\\{v_{0}(x), v_{1}(x)\\} = \\{1, x\\}$。我们将使用格拉姆-施密特过程，同时强制满足首一的要求。\n\n首先，从 $v_{0}(x)=1$ 得到 $p_{0}(x)$。由于一个常数多项式是首一的当且仅当它等于1，我们设\n$$\np_{0}(x) = 1.\n$$\n\n接下来，我们将 $v_{1}(x)=x$ 对 $p_{0}(x)$ 进行正交化：\n$$\nu_{1}(x) = v_{1}(x) - \\frac{\\langle v_{1}, p_{0} \\rangle}{\\langle p_{0}, p_{0} \\rangle} p_{0}(x).\n$$\n计算所需的内积：\n$$\n\\langle v_{1}, p_{0} \\rangle = \\int_{a}^{b} x \\cdot 1 \\, dx = \\frac{b^{2} - a^{2}}{2},\n\\qquad\n\\langle p_{0}, p_{0} \\rangle = \\int_{a}^{b} 1 \\cdot 1 \\, dx = b - a.\n$$\n因此\n$$\n\\frac{\\langle v_{1}, p_{0} \\rangle}{\\langle p_{0}, p_{0} \\rangle} = \\frac{\\frac{b^{2} - a^{2}}{2}}{b - a} = \\frac{a + b}{2}.\n$$\n所以，\n$$\nu_{1}(x) = x - \\frac{a + b}{2}.\n$$\n这个多项式已经是首一的（其首项系数为1），所以我们设\n$$\np_{1}(x) = x - \\frac{a + b}{2}.\n$$\n\n验证正交性：\n$$\n\\langle p_{0}, p_{1} \\rangle = \\int_{a}^{b} 1 \\cdot \\left(x - \\frac{a + b}{2}\\right) dx\n= \\left[\\frac{x^{2}}{2} - \\frac{a + b}{2}x\\right]_{a}^{b}\n= \\frac{b^{2} - a^{2}}{2} - \\frac{a + b}{2}(b - a) = 0,\n$$\n因为 $b^{2} - a^{2} = (b - a)(a + b)$。因此 $\\{p_{0}, p_{1}\\}$ 是一个正交集，并且两个多项式都是首一的。\n\n因此，由 $\\{1,x\\}$ 张成的子空间的一个正交首一基是\n$$\np_{0}(x) = 1, \\qquad p_{1}(x) = x - \\frac{a + b}{2}.\n$$", "answer": "$$\\boxed{\\begin{pmatrix} 1  x - \\frac{a+b}{2} \\end{pmatrix}}$$", "id": "2192753"}, {"introduction": "虽然格拉姆-施密特方法是基础，但生成正交多项式的一种更优雅且计算上更稳定的方法依赖于三项递推关系。此练习 [@problem_id:2192741] 演示了如何推导该递推关系的系数，这是许多数值算法的基石，特别是在处理涉及离散数据点的数据拟合问题时。", "problem": "在实验数据的数值分析中，使用相对于数据点正交的函数基通常是有利的。考虑在坐标 $\\{x_i\\} = \\{0, 1, 3, 6\\}$ 处的一组四个实验测量值。我们感兴趣的是生成一个关于离散内积正交的首一多项式序列 $\\{p_k(x)\\}_{k=0}^\\infty$。\n\n在这个点集上，两个实值函数 $f(x)$ 和 $g(x)$ 的内积定义为：\n$$ \\langle f, g \\rangle = \\sum_{i=1}^{4} f(x_i) g(x_i) $$\n该正交首一多项式序列由三项递推关系生成：\n$$ p_{k+1}(x) = (x - \\alpha_k) p_k(x) - \\beta_k p_{k-1}(x) $$\n对于 $k \\ge 0$，初始条件定义为 $p_0(x) = 1$ 和 $p_{-1}(x) = 0$。\n\n你的任务是确定递推系数 $\\alpha_1$ 的精确值。请将最终答案表示为最简分数形式。", "solution": "我们使用给定的离散内积\n$$\\langle f, g \\rangle = \\sum_{i=1}^{4} f(x_{i}) g(x_{i}), \\quad \\{x_{i}\\}=\\{0,1,3,6\\},$$\n和首一三项递推关系\n$$p_{k+1}(x)=(x-\\alpha_{k})p_{k}(x)-\\beta_{k}p_{k-1}(x), \\quad p_{0}(x)=1,\\; p_{-1}(x)=0.$$\n\n对于首一正交多项式，将递推关系与 $p_{k}$ 作内积可得\n$$\\langle p_{k+1},p_{k}\\rangle=\\langle (x-\\alpha_{k})p_{k},p_{k}\\rangle-\\beta_{k}\\langle p_{k-1},p_{k}\\rangle.$$\n根据正交性，$\\langle p_{k+1},p_{k}\\rangle=0$ 且 $\\langle p_{k-1},p_{k}\\rangle=0$，因此\n$$0=\\langle x p_{k},p_{k}\\rangle-\\alpha_{k}\\langle p_{k},p_{k}\\rangle,$$\n所以\n$$\\alpha_{k}=\\frac{\\langle x p_{k},p_{k}\\rangle}{\\langle p_{k},p_{k}\\rangle}.$$\n\n首先，计算 $\\alpha_{0}$：\n$$\\alpha_{0}=\\frac{\\langle x p_{0},p_{0}\\rangle}{\\langle p_{0},p_{0}\\rangle}\n=\\frac{\\sum_{i=1}^{4} x_{i}}{\\sum_{i=1}^{4} 1}\n=\\frac{0+1+3+6}{4}\n=\\frac{10}{4}\n=\\frac{5}{2}.$$\n因此\n$$p_{1}(x)=x-\\alpha_{0}=x-\\frac{5}{2}.$$\n\n现在使用以下公式计算 $\\alpha_{1}$：\n$$\\alpha_{1}=\\frac{\\langle x p_{1},p_{1}\\rangle}{\\langle p_{1},p_{1}\\rangle}\n=\\frac{\\sum_{i=1}^{4} x_{i}\\,p_{1}(x_{i})^{2}}{\\sum_{i=1}^{4} p_{1}(x_{i})^{2}}.$$\n在数据点处计算 $p_{1}(x)$ 的值：\n$$p_{1}(0)=-\\frac{5}{2},\\quad p_{1}(1)=-\\frac{3}{2},\\quad p_{1}(3)=\\frac{1}{2},\\quad p_{1}(6)=\\frac{7}{2}.$$\n平方：\n$$p_{1}(0)^{2}=\\frac{25}{4},\\quad p_{1}(1)^{2}=\\frac{9}{4},\\quad p_{1}(3)^{2}=\\frac{1}{4},\\quad p_{1}(6)^{2}=\\frac{49}{4}.$$\n分母：\n$$\\langle p_{1},p_{1}\\rangle=\\frac{25}{4}+\\frac{9}{4}+\\frac{1}{4}+\\frac{49}{4}=\\frac{84}{4}=21.$$\n分子：\n$$\\langle x p_{1},p_{1}\\rangle=0\\cdot\\frac{25}{4}+1\\cdot\\frac{9}{4}+3\\cdot\\frac{1}{4}+6\\cdot\\frac{49}{4}\n=\\frac{9}{4}+\\frac{3}{4}+\\frac{294}{4}=\\frac{306}{4}=\\frac{153}{2}.$$\n因此\n$$\\alpha_{1}=\\frac{\\frac{153}{2}}{21}=\\frac{153}{42}=\\frac{51}{14}.$$\n该分数已为最简形式。", "answer": "$$\\boxed{\\frac{51}{14}}$$", "id": "2192741"}, {"introduction": "当用于逼近更复杂的函数时，正交多项式才能真正发挥其威力。在这个高级实践 [@problem_id:3260453] 中，您将使用勒让德多项式基底为一个不连续函数构建最小二乘逼近，并探索其收敛特性和局限性，例如在不连续点附近的吉布斯现象。这项练习将理论表示与实际的计算分析联系起来。", "problem": "考虑平方可积函数空间 $L^2([-1,1])$，其标准内积为 $\\langle g,h\\rangle = \\int_{-1}^{1} g(x)\\,h(x)\\,\\mathrm{d}x$。令 $P_n(x)$ 表示第 $n$ 阶勒让德多项式，当限制在多项式上且在 $[-1,1]$ 上的权重为 1 时，它构成了 $L^2([-1,1])$ 的一个正交基。定义函数 $f(x) = \\operatorname{sgn}(x)$，并约定 $f(0)=0$。\n\n你的任务是构造 $f$ 在 $\\{P_0,P_1,\\dots,P_N\\}$ 张成的空间上的最小二乘（正交）投影，即找到系数 $a_0,a_1,\\dots,a_N$，使得多项式\n$$\nS_N(x) = \\sum_{n=0}^{N} a_n\\,P_n(x)\n$$\n最小化 $L^2([-1,1])$ 误差 $\\int_{-1}^{1} \\left(S_N(x)-f(x)\\right)^2 \\,\\mathrm{d}x$，并且其特征是残差与基的正交性，即对于每个满足 $0\\le k\\le N$ 的整数 $k$，都有 $\\langle f-S_N,P_k\\rangle = 0$。\n\n从上述基本定义和勒让德多项式的正交性出发，推导出一个计算上稳定的方法，以获得作为 $N$ 的函数的系数 $a_n$。然后，对下面描述的每个测试用例，计算以下四个量：\n- $S_N(0)$，\n- $S_N(\\varepsilon) - 1$，\n- $S_N(-\\varepsilon) + 1$，\n- 平方 $L^2([-1,1])$ 误差 $\\int_{-1}^{1} \\left(S_N(x)-f(x)\\right)^2 \\,\\mathrm{d}x$。\n\n这些量共同揭示了正交投影如何捕捉 $x=0$ 处的跳跃间断点以及 $x=0$ 附近的振荡行为（包括过冲和下冲）。\n\n你的程序必须使用由最小二乘投影所隐含的勒让德基来实现 $S_N(x)$ 的计算，并且必须在 $[-1,1]$ 上以数值稳定的方式计算勒让德多项式。\n\n使用以下测试套件，其中每个测试用例是一对 $(N,\\varepsilon)$，其中 $N$ 是非负整数，$\\varepsilon0$ 是一个小数：\n- 测试用例 1：$N=1$，$\\varepsilon=10^{-2}$，\n- 测试用例 2：$N=7$，$\\varepsilon=10^{-3}$，\n- 测试用例 3：$N=31$，$\\varepsilon=10^{-4}$，\n- 测试用例 4：$N=2$，$\\varepsilon=10^{-3}$。\n\n对于每个测试用例，按照上面指定的顺序生成一个包含四个浮点数的列表。将四个测试用例的结果按给定的相同顺序汇总到一个列表中，因此最终输出是列表的列表。\n\n最终输出格式：你的程序应该生成单行输出，包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例由其自己的四元素列表表示，例如：\n$$\n\\text{[[r_{1,1},r_{1,2},r_{1,3},r_{1,4}],[r_{2,1},r_{2,2},r_{2,3},r_{2,4}],[r_{3,1},r_{3,2},r_{3,3},r_{3,4}],[r_{4,1},r_{4,2},r_{4,3},r_{4,4}]]}\n$$\n本问题中的所有数字和符号均指纯数学量；不涉及物理单位。如果存在角度，则必须以弧度为单位，但此处不需要。", "solution": "该问题要求在空间 $L^2([-1,1])$ 中构造和分析符号函数 $f(x) = \\operatorname{sgn}(x)$ 的最小二乘多项式逼近。该逼近记为 $S_N(x)$，是 $f(x)$ 到由前 $N+1$ 个勒让德多项式 $\\{P_0, P_1, \\dots, P_N\\}$ 张成的子空间上的正交投影。\n\n投影 $S_N(x)$ 是一个次数至多为 $N$ 的多项式，由展开式给出\n$$\nS_N(x) = \\sum_{n=0}^{N} a_n\\,P_n(x)\n$$\n选择系数 $a_n$ 以最小化均方误差 $\\int_{-1}^{1} (f(x) - S_N(x))^2 \\,\\mathrm{d}x$。希尔伯特空间中的逼近理论的一个基本结果指出，当误差向量 $f-S_N$ 与逼近子空间正交时，达到这个最小值。这给出了正交性条件：\n$$\n\\langle f - S_N, P_k \\rangle = 0 \\quad \\text{对于 } k = 0, 1, \\dots, N\n$$\n其中内积为 $\\langle g, h \\rangle = \\int_{-1}^{1} g(x)h(x)\\,\\mathrm{d}x$。根据内积的线性和勒让德多项式的正交性，对于 $n \\neq k$ 有 $\\langle P_n, P_k \\rangle = 0$，我们可以独立地求解每个系数 $a_k$：\n$$\n\\langle f, P_k \\rangle - \\langle \\sum_{n=0}^{N} a_n P_n, P_k \\rangle = 0 \\implies \\langle f, P_k \\rangle - a_k \\langle P_k, P_k \\rangle = 0\n$$\n这就得到了傅里叶-勒让德系数的标准公式：\n$$\na_k = \\frac{\\langle f, P_k \\rangle}{\\langle P_k, P_k \\rangle}\n$$\n分母是第 $k$ 阶勒让德多项式的范数的平方，这是一个标准结果：\n$$\n\\langle P_k, P_k \\rangle = \\int_{-1}^{1} P_k(x)^2 \\,\\mathrm{d}x = \\frac{2}{2k+1}\n$$\n分子需要一个涉及我们特定函数 $f(x) = \\operatorname{sgn}(x)$ 的积分。\n$$\n\\langle f, P_k \\rangle = \\int_{-1}^{1} \\operatorname{sgn}(x) P_k(x) \\,\\mathrm{d}x = \\int_{-1}^{0} (-1)P_k(x)\\,\\mathrm{d}x + \\int_{0}^{1} (1)P_k(x)\\,\\mathrm{d}x\n$$\n勒让德多项式具有确定的奇偶性，$P_k(-x) = (-1)^k P_k(x)$。函数 $f(x) = \\operatorname{sgn}(x)$ 是一个奇函数。如果 $P_k(x)$ 是偶函数（即 $k$ 是偶数），则乘积 $\\operatorname{sgn}(x)P_k(x)$ 是奇函数；如果 $P_k(x)$ 是奇函数（即 $k$ 是奇数），则乘积是偶函数。\n如果 $k$ 是偶数，被积函数是奇函数，其在对称区间 $[-1, 1]$ 上的积分为零。因此，对于所有偶数 $k$，$\\langle f, P_k \\rangle = 0$。所以，所有偶数索引的系数 $a_{2m}$ 都为零。这反映了一个事实：一个奇函数由勒让德基函数得到的最佳多项式逼近本身也将是一个奇函数，仅由奇数索引（因此是奇函数）的勒让德多项式组成。\n如果 $k$ 是奇数，被积函数是偶函数，所以从 $-1$ 到 $1$ 的积分是从 $0$ 到 $1$ 的积分的两倍。\n$$\n\\langle f, P_k \\rangle = 2 \\int_{0}^{1} P_k(x)\\,\\mathrm{d}x \\quad \\text{对于奇数 } k\n$$\n因此，对于奇数 $k$ 的系数 $a_k$ 是：\n$$\na_k = \\frac{2 \\int_{0}^{1} P_k(x)\\,\\mathrm{d}x}{2/(2k+1)} = (2k+1) \\int_{0}^{1} P_k(x)\\,\\mathrm{d}x\n$$\n为了以稳定的方式计算该积分，我们使用勒让德多项式导数的恒等式：\n$$\n(2k+1)P_k(x) = P'_{k+1}(x) - P'_{k-1}(x) \\quad \\text{对于 } k \\ge 1\n$$\n两边从 $0$ 到 $1$ 积分：\n$$\n(2k+1)\\int_{0}^{1} P_k(x)\\,\\mathrm{d}x = \\int_{0}^{1} \\left(P'_{k+1}(x) - P'_{k-1}(x)\\right)\\,\\mathrm{d}x = [P_{k+1}(x) - P_{k-1}(x)]_{0}^{1}\n$$\n$$\n= (P_{k+1}(1) - P_{k-1}(1)) - (P_{k+1}(0) - P_{k-1}(0))\n$$\n使用对所有 $n$ 都有 $P_n(1)=1$ 的性质，第一项消失：$P_{k+1}(1) - P_{k-1}(1) = 1-1=0$。这给了我们一个用多项式在 $x=0$ 处的值表示的积分的简单表达式：\n$$\n(2k+1)\\int_{0}^{1} P_k(x)\\,\\mathrm{d}x = -(P_{k+1}(0) - P_{k-1}(0))\n$$\n将此代回我们对 $a_k$（对于奇数 $k \\ge 1$）的公式中，得到一个非常简单的结果：\n$$\na_k = P_{k-1}(0) - P_{k+1}(0)\n$$\n为了计算这个值，我们需要勒让德多项式在 $x=0$ 处的值。由于 $k$ 是奇数，所以 $k-1$ 和 $k+1$ 是偶数。对于奇数 $n$，$P_n(0)$ 的值为零。对于偶数 $n$，可以使用勒让德多项式在 $x=0$ 处的三项递推关系高效地计算它们：\n$$\n(n+1)P_{n+1}(0) = -nP_{n-1}(0) \\quad \\text{其中 } P_0(0)=1\n$$\n这个递推关系是数值稳定的。令 $k = 2m+1$ 为一个奇数索引。那么 $a_{2m+1} = P_{2m}(0) - P_{2m+2}(0)$。我们预先计算 $j=0, 1, \\dots, \\lfloor(N+1)/2\\rfloor$ 的 $P_{2j}(0)$，然后求出系数 $a_n$。\n\n确定系数后，我们为每个测试用例 $(N, \\varepsilon)$ 计算所需的四个量：\n\n1.  $S_N(0) = \\sum_{n=0}^{N} a_n P_n(0)$。由于对于偶数 $n$ 有 $a_n=0$，对于奇数 $n$ 有 $P_n(0)=0$，所以和中的每一项都为零。因此，$S_N(0)=0$。\n\n2.  $S_N(\\varepsilon) - 1$。我们计算 $S_N(\\varepsilon) = \\sum_{n=0}^N a_n P_n(\\varepsilon)$ 并减去 1。求和的计算是通过使用标准三项递推关系 $(n+1)P_{n+1}(x) = (2n+1)xP_n(x) - nP_{n-1}(x)$（其中 $P_0(x)=1, P_1(x)=x$）生成 $P_n(\\varepsilon)$ 的值来执行的。对于 $x \\in [-1,1]$，这种前向求值是数值稳定的。\n\n3.  $S_N(-\\varepsilon) + 1$。由于 $S_N(x)$ 是奇多项式的和，它是一个奇函数，满足 $S_N(-x) = -S_N(x)$。因此，$S_N(-\\varepsilon) + 1 = -S_N(\\varepsilon) + 1 = -(S_N(\\varepsilon) - 1)$。这个值就是前一个值的相反数。\n\n4.  平方 $L^2([-1,1])$ 误差，$E^2 = \\int_{-1}^{1} (f(x) - S_N(x))^2 \\,\\mathrm{d}x$。根据希尔伯特空间中的毕达哥拉斯定理（或帕塞瓦尔恒等式），这个误差可以不通过数值积分来计算：\n    $$\n    E^2 = \\langle f, f \\rangle - \\langle S_N, S_N \\rangle\n    $$\n    我们有 $\\langle f,f \\rangle = \\int_{-1}^{1} (\\operatorname{sgn}(x))^2 \\,\\mathrm{d}x = \\int_{-1}^{1} 1\\,\\mathrm{d}x = 2$。根据勒让德基的正交性，$\\langle S_N, S_N \\rangle = \\sum_{n=0}^{N} a_n^2 \\langle P_n, P_n \\rangle$。\n    误差的最终表达式为：\n    $$\n    E^2 = 2 - \\sum_{n=0}^{N} a_n^2 \\frac{2}{2n+1}\n    $$\n    这个公式使用了预先计算的系数 $a_n$，并且计算效率高且稳定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of finding the least-squares polynomial approximation\n    of the signum function and evaluating several related quantities.\n    \"\"\"\n\n    def compute_coeffs(N):\n        \"\"\"\n        Computes the coefficients a_n for the Legendre series expansion of sgn(x).\n        a_n is non-zero only for odd n.\n        a_{2m+1} = P_{2m}(0) - P_{2m+2}(0).\n        \"\"\"\n        # Max index for m such that n=2m+1 = N is m = (N-1)/2.\n        # To compute a_n, we need P_{n+1}(0), so max index for P_2m(0) is m = (N+1)//2.\n        max_m = (N + 1) // 2\n        \n        # p_even_at_0[m] will store P_{2m}(0)\n        p_even_at_0 = np.zeros(max_m + 1)\n        if max_m = 0:\n            p_even_at_0[0] = 1.0  # P_0(0)\n        \n        # Use recurrence (2m)P_{2m}(0) = -(2m-1)P_{2m-2}(0)\n        for m in range(1, max_m + 1):\n            p_even_at_0[m] = - (2 * m - 1) / (2 * m) * p_even_at_0[m - 1]\n\n        coeffs = np.zeros(N + 1)\n        \n        # Compute a_n for odd n = 2m+1\n        for m in range((N - 1) // 2 + 1):\n            n = 2 * m + 1\n            coeffs[n] = p_even_at_0[m] - p_even_at_0[m + 1]\n            \n        return coeffs\n\n    def evaluate_SN(coeffs, N, x):\n        \"\"\"\n        Evaluates the polynomial S_N(x) = sum_{n=0 to N} a_n P_n(x)\n        using the three-term recurrence for P_n(x).\n        \"\"\"\n        if N  0:\n            return 0.0\n        \n        if N == 0:\n            return coeffs[0] # which is 0 for this problem\n\n        # Use forward recurrence to compute P_n(x) and sum S_N(x)\n        p_prev = 1.0  # P_0(x)\n        p_curr = x    # P_1(x)\n        \n        sum_val = coeffs[0] * p_prev\n        if N = 1:\n            sum_val += coeffs[1] * p_curr\n            \n        for n in range(1, N):\n            p_next = ((2 * n + 1) * x * p_curr - n * p_prev) / (n + 1)\n            sum_val += coeffs[n + 1] * p_next\n            p_prev = p_curr\n            p_curr = p_next\n            \n        return sum_val\n\n    def compute_error_sq(coeffs, N):\n        \"\"\"\n        Computes the squared L2 error using Parseval's identity.\n        E^2 = ||f||^2 - ||S_N||^2 = 2 - sum(a_n^2 * ||P_n||^2).\n        \"\"\"\n        sum_sq = 0.0\n        for n in range(N + 1):\n            if coeffs[n] != 0:\n                norm_sq_Pn = 2.0 / (2 * n + 1)\n                sum_sq += coeffs[n]**2 * norm_sq_Pn\n        # ||f||^2 for f=sgn(x) on [-1,1] is integral of 1, which is 2.\n        return 2.0 - sum_sq\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 1e-2),\n        (7, 1e-3),\n        (31, 1e-4),\n        (2, 1e-3)\n    ]\n\n    results_list = []\n    for N, eps in test_cases:\n        coeffs = compute_coeffs(N)\n        \n        # 1. S_N(0)\n        # S_N is a sum of odd Legendre polynomials, so S_N(0)=0.\n        val_at_0 = 0.0\n        \n        # 2. S_N(eps) - 1\n        val_at_eps = evaluate_SN(coeffs, N, eps)\n        overshoot = val_at_eps - 1.0\n        \n        # 3. S_N(-eps) + 1\n        # S_N is an odd function, so S_N(-eps) = -S_N(eps)\n        # S_N(-eps) + 1 = -S_N(eps) + 1 = -(S_N(eps) - 1)\n        undershoot = -overshoot\n        \n        # 4. Squared L2 error\n        error_sq = compute_error_sq(coeffs, N)\n        \n        case_result = [val_at_0, overshoot, undershoot, error_sq]\n        results_list.append(f\"[{','.join(map(str, case_result))}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results_list)}]\")\n\nsolve()\n```", "id": "3260453"}]}