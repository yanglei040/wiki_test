{"hands_on_practices": [{"introduction": "达尔奎斯特等价定理（Dahlquist Equivalence Theorem）是数值分析的基石，它直观地告诉我们：一个数值格式若要收敛，它必须是相容的（局部精确）并且是稳定的（能控制误差传播）。这个练习将通过一个不满足稳定性条件的方法，让你亲眼见证局部截断误差趋近于零，而全局误差却因不稳定性而发生爆炸，从而深刻理解稳定性在实现收敛过程中不可或缺的作用。", "problem": "考虑常微分方程 (ODE) 的初值问题 $y'(t) = f(t,y(t))$，其中 $y(0) = y_0$，$y(t)$ 是一个足够光滑的标量函数，$f$ 是一个足够光滑的函数。定义局部截断误差 (LTE) 为将精确解代入所提出的单步数值递推关系式时产生的残差，定义全局截断误差 (GTE) 为在指定最终时刻数值近似解与精确解之间的差值。在线性多步法的背景下，零稳定性是指递推关系的齐次部分不会随着步数的增加而无界地放大扰动；对于单步法，稳定性指的是由线性化递推因子控制的误差传播的有界性。\n\n设计并实现一个数值实验，以区分相容性（如果方法的局部截断误差 LTE 满足 $\\text{LTE}/h \\to 0$ 当 $h \\to 0$ 时）和收敛性（当步长趋于零时，GTE 趋于零）这两个概念。使用在区间 $t \\in [0,1]$ 上的 ODE $y'(t) = -y(t)$，其精确解为 $y(t) = e^{-t}$ 且 $y_0 = 1$。构造并分析一种线性多步法，该方法是不稳定的，并检验其相容性，以此与一种稳定的单步法进行对比。\n\n任务：\n1. 对 $f(t,y) = -y$，实现两步递推关系 $y_{n+1} - 2 y_n + y_{n-1} = h f(t_n, y_n)$。使用从精确解中获取的 $y_0 = y(0)$ 和 $y_1 = y(h)$ 来初始化该方法，以分离传播效应而非初始近似效应。对于 $n = 1,2,\\dots,N-1$ 且 $Nh = 1$，将递推关系演化至 $t_N = 1$ 并计算最终时刻的绝对全局截断误差 $|y_N - e^{-1}|$。\n2. 对同一方法，通过将精确解代入递推关系式来计算单步残差，从而计算时间上的最大绝对局部截断误差，即 $\\max_{n=1,\\dots,N-1} \\left| y(t_{n+1}) - 2 y(t_n) + y(t_{n-1}) - h f(t_n, y(t_n)) \\right|$，其中 $t_n = n h$。\n3. 对 $f(t,y) = -y$ 且 $y_0 = 1$，实现前向 Euler 单步法 $y_{n+1} = y_n + h f(t_n, y_n)$，并类似地计算其时间上的最大绝对局部截断误差 $\\max_{n=0,\\dots,N-1} \\left| y(t_{n+1}) - y(t_n) - h f(t_n, y(t_n)) \\right|$ 及其最终时刻的绝对全局截断误差 $|y_N - e^{-1}|$。\n4. 使用以下步长测试集，该测试集探索了一般情况和逐步细化的步长：$h \\in \\{0.5, 0.25, 0.125, 0.0625\\}$。对于每个 $h$，令步数为 $N = 1/h$，以使 $t_N = 1$ 恰好成立。\n5. 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于所列顺序中的每个 $h$，按此顺序附加四个浮点数：不稳定两步法的时间上的最大绝对局部截断误差，不稳定两步法的最终时刻绝对全局截断误差，前向 Euler 法的时间上的最大绝对局部截断误差，以及前向 Euler 法的最终时刻绝对全局截断误差。因此，最终输出包含 16 个浮点数，对应四个步长中的每一个的四个值，所有值都在一个扁平列表中。此问题不涉及物理单位，也未使用角度。", "solution": "我们从初值问题 $y'(t) = f(t,y(t))$ 开始，其中 $f(t,y) = -y$，$y(0) = 1$，在 $t \\in [0,1]$ 上的精确解为 $y(t) = e^{-t}$。对于一个给定的格式，在时刻 $t_n$ 的局部截断误差 (LTE) 定义为将精确值代入单步数值递推关系式时得到的代数残差。在时刻 $t_N$ 的全局截断误差 (GTE) 定义为差值 $|y_N - y(t_N)|$，其中 $y_N$ 是数值解，$y(t_N)$ 是精确解。\n\n为了对比相容性与收敛性，我们考虑两种格式。\n\n第一种格式（两步法，不稳定且不相容）：\n该方法为 $y_{n+1} - 2 y_n + y_{n-1} = h f(t_n,y_n)$，对于 $f(t,y) = -y$，该式变为 $y_{n+1} = (2 - h) y_n - y_{n-1}$。其齐次递推关系为 $y_{n+1} - 2 y_n + y_{n-1} = 0$，特征多项式为 $\\rho(\\zeta) = \\zeta^2 - 2 \\zeta + 1 = (\\zeta - 1)^2$。在 $\\zeta = 1$ 处的二重根违反了线性多步法的零稳定性条件，该条件要求 $\\rho(\\zeta)$ 的所有根都满足 $|\\zeta| \\le 1$，并且任何满足 $|\\zeta| = 1$ 的根都必须是单根。因此，无论相容性如何，该方法都不是零稳定的，故不能收敛。\n\n为检验相容性，我们推导局部截断误差。根据定义，$t_n$ 处的 LTE 为\n$$\n\\tau_n = y(t_{n+1}) - 2 y(t_n) + y(t_{n-1}) - h f(t_n, y(t_n)).\n$$\n对足够光滑的 $y$ 在 $t_n$ 附近使用泰勒展开，\n$$\ny(t_{n\\pm 1}) = y(t_n) \\pm h y'(t_n) + \\frac{h^2}{2} y''(t_n) \\pm \\frac{h^3}{6} y^{(3)}(t_n) + \\mathcal{O}(h^4).\n$$\n相减，我们得到\n$$\ny(t_{n+1}) - 2 y(t_n) + y(t_{n-1}) = h^2 y''(t_n) + \\mathcal{O}(h^4),\n$$\n并且由于 $f(t,y) = -y$，我们有 $h f(t_n, y(t_n)) = -h y'(t_n) = h y(t_n)$。因此，\n$$\n\\tau_n = h^2 y''(t_n) + h y(t_n) + \\mathcal{O}(h^4).\n$$\n对于我们特定的 ODE，$y'(t) = -y(t)$ 意味着 $y''(t) = -y'(t) = y(t)$，所以\n$$\n\\tau_n = h^2 y(t_n) + h y(t_n) + \\mathcal{O}(h^4) = h y(t_n) + \\mathcal{O}(h^2).\n$$\n由于 $\\tau_n/h$ 在 $h \\to 0$ 时并不趋于零，该方法不满足相容性的标准定义（即至少为一阶精度）。因此，该方法不收敛，因为它既不是相容的，也不是零稳定的。\n\n为了理解为什么全局截断误差在此不消失，考虑误差 $e_n = y_n - y(t_n)$。减去精确的递推关系（精确解满足该关系，直到 LTE），误差满足\n$$\ne_{n+1} - 2 e_n + e_{n-1} = -h e_n - \\tau_n,\n$$\n其中 $\\tau_n$ 是如上所述的 LTE 残差。此误差递推关系的齐次部分\n$$\ne_{n+1} - 2 e_n + e_{n-1} = 0,\n$$\n其解的形式为 $e_n = C_1 + C_2 n$。在 $\\zeta = 1$ 处的重根意味着即使当强迫项 $-h e_n$ 很小时，扰动也会随 $n$ 呈多项式增长。包含大小为 $\\mathcal{O}(h)$ 的强迫项 $\\tau_n$，通过离散常数变易法论证可知 $e_n$ 随步数线性累积。在 $N = 1/h$ 步之后（因为 $Nh = 1$），累积的放大效应产生\n$$\ne_N \\sim \\mathcal{O}(N \\cdot h) = \\mathcal{O}(1),\n$$\n当 $h \\to 0$ 时，它不趋于零。因此，尽管 LTE $\\to 0$，但该方法由于不是零稳定的（并且也不是相容的）而不收敛；其 GTE 不会消失。\n\n第二种格式（单步法，稳定且收敛）：\n前向 Euler 方法为 $y_{n+1} = y_n + h f(t_n,y_n)$，这里是 $y_{n+1} = (1 - h) y_n$。通过代入精确解，其 LTE 为\n$$\n\\tau_n = y(t_{n+1}) - y(t_n) - h f(t_n, y(t_n)) = y(t_{n+1}) - y(t_n) + h y(t_n).\n$$\n使用泰勒展开，\n$$\ny(t_{n+1}) - y(t_n) = h y'(t_n) + \\frac{h^2}{2} y''(t_n) + \\mathcal{O}(h^3) = -h y(t_n) + \\frac{h^2}{2} y''(t_n) + \\mathcal{O}(h^3),\n$$\n并且由于 $y''(t_n) = y(t_n)$，我们得到\n$$\n\\tau_n = \\frac{h^2}{2} y(t_n) + \\mathcal{O}(h^3),\n$$\n所以 LTE 以二次方的速度趋于 $0$。误差递推关系为\n$$\ne_{n+1} = (1 - h) e_n + \\tau_n.\n$$\n对于 $h \\in (0,2)$，我们有 $|1 - h|  1$，这意味着误差是衰减的。对受迫响应求和表明\n$$\ne_N = \\sum_{k=0}^{N-1} (1 - h)^{N-1-k} \\tau_k,\n$$\n它由一个几何级数界定，其尺度与 $\\max_k |\\tau_k| = \\mathcal{O}(h^2)$ 成比例，从而当 $h \\to 0$ 时得到 $e_N = \\mathcal{O}(h)$。因此，前向 Euler 法既是相容的又是稳定的，故而是收敛的，其 GTE $\\to 0$。\n\n实验设计与计算：\n- 我们固定 $T = 1$ 和步长 $h \\in \\{0.5, 0.25, 0.125, 0.0625\\}$，以使 $N = 1/h$ 为整数。\n- 对于两步法，我们使用精确的初始值 $y_0 = y(0)$ 和 $y_1 = y(h)$，以专注于传播稳定性。我们通过将 $y(t_n)$ 代入递推关系并取 $n = 1,\\dots,N-1$ 上的最大值来计算时间上的最大绝对 LTE。在将递推关系演化到 $t_N = 1$ 后，我们计算最终时刻的绝对 GTE $|y_N - e^{-1}|$。\n- 对于前向 Euler 法，我们通过类似地代入法计算其时间上的最大绝对 LTE，并通过从 $y_0 = 1$ 开始演化数值递推关系来计算其最终时刻的绝对 GTE。\n\n预期的定性结果：\n- 对于两步法，时间上的最大绝对 LTE 随 $h$ 减小，但由于缺乏零稳定性和相容性，最终时刻的绝对 GTE 不趋于零；当 $h \\to 0$ 时，它保持在 $\\mathcal{O}(1)$ 的量级。\n- 对于前向 Euler 法，时间上的最大绝对 LTE 和最终时刻的绝对 GTE 都随 $h$ 减小；最终时刻的 GTE 线性趋于零，反映了收敛性。\n\n程序为每个 $h$ 输出，以单个扁平列表的形式，并按照测试集的顺序：\n1. 两步法的时间上的最大绝对 LTE，\n2. 两步法的最终时刻绝对 GTE，\n3. 前向 Euler 法的时间上的最大绝对 LTE，\n4. 前向 Euler 法的最终时刻绝对 GTE。\n\n这直接证明了，在没有稳定性的情况下，LTE $\\to 0$ 并不保证 GTE $\\to 0$，从而区分了（不充分的）局部行为与（期望的）全局收敛性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef y_exact(t: float) - float:\n    # Exact solution for y' = -y with y(0) = 1\n    return np.exp(-t)\n\ndef f_rhs(t: float, y: float) - float:\n    # Right-hand side f(t,y) = -y\n    return -y\n\ndef lte_two_step(h: float, T: float) - float:\n    # Compute maximum-in-time absolute LTE for two-step method:\n    # tau_n = y(t_{n+1}) - 2 y(t_n) + y(t_{n-1}) - h f(t_n, y(t_n))\n    N = int(round(T / h))\n    # times t_n = n h, n = 0..N\n    max_tau = 0.0\n    for n in range(1, N):  # n=1..N-1 has neighbors n-1 and n+1 within [0,N]\n        t_n = n * h\n        tau = y_exact(t_n + h) - 2.0 * y_exact(t_n) + y_exact(t_n - h) - h * f_rhs(t_n, y_exact(t_n))\n        max_tau = max(max_tau, abs(tau))\n    return max_tau\n\ndef gte_two_step(h: float, T: float) - float:\n    # Compute final-time absolute GTE for two-step method evolution with exact starts\n    N = int(round(T / h))\n    y = np.zeros(N + 1, dtype=float)\n    # exact starts\n    y[0] = y_exact(0.0)\n    if N = 1:\n        y[1] = y_exact(h)\n    # evolve: y_{n+1} = (2 - h) y_n - y_{n-1}\n    for n in range(1, N):\n        y[n + 1] = (2.0 - h) * y[n] - y[n - 1]\n    return abs(y[N] - y_exact(T))\n\ndef lte_forward_euler(h: float, T: float) - float:\n    # Compute maximum-in-time absolute LTE for forward Euler:\n    # tau_n = y(t_{n+1}) - y(t_n) - h f(t_n, y(t_n)), for n=0..N-1\n    N = int(round(T / h))\n    max_tau = 0.0\n    for n in range(0, N):\n        t_n = n * h\n        tau = y_exact(t_n + h) - y_exact(t_n) - h * f_rhs(t_n, y_exact(t_n))\n        max_tau = max(max_tau, abs(tau))\n    return max_tau\n\ndef gte_forward_euler(h: float, T: float) - float:\n    # Compute final-time absolute GTE for forward Euler evolution\n    N = int(round(T / h))\n    y = 1.0  # y0\n    for _ in range(N):\n        y = y + h * f_rhs(0.0, y)  # f depends only on y here; t not needed\n        # Using t argument consistently, but for f = -y, t is irrelevant.\n    return abs(y - y_exact(T))\n\ndef solve():\n    # Define the test cases from the problem statement.\n    T = 1.0\n    test_steps = [0.5, 0.25, 0.125, 0.0625]\n\n    results = []\n    for h in test_steps:\n        # Two-step method (consistent but not zero-stable)\n        lte_ts = lte_two_step(h, T)\n        gte_ts = gte_two_step(h, T)\n        # Forward Euler (stable for h in (0,2), convergent)\n        lte_fe = lte_forward_euler(h, T)\n        gte_fe = gte_forward_euler(h, T)\n        results.extend([lte_ts, gte_ts, lte_fe, gte_fe])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3156045"}, {"introduction": "在科学计算中，许多问题（如化学反应动力学和某些生物系统）表现出“刚性”（stiffness），即系统中存在多个尺度差异巨大的时间过程。本练习将引导你为一个刚性的捕食者-被捕食者模型实现一个显式方法和一个隐式方法。你将通过实验发现，刚性如何使得显式方法因稳定性限制而步履维艰，而精心选择的隐式方法却能保持高效和准确，这揭示了为特定问题选择合适求解器的重要性。", "problem": "创建一个完整的、可运行的程序，该程序对一个具有饱和功能性响应的捕食者-被捕食者系统进行步长减半收敛性研究，并利用该研究来论证常微分方程 (ODE) 求解器的一致性、稳定性和收敛性。该研究必须基于第一性原理：初值问题 (IVP) 的定义、一致性、稳定性和收敛性的概念，以及从泰勒展开和积分形式构建定步长单步法。利用这些思想设计一个程序，用于检测猎物饱和度引入的刚性何时会迫使隐式方法实现其理论精度阶，而显式方法在较粗糙的步长上则受到稳定性限制。\n\n您必须使用以下捕食者-被捕食者系统\n$$\n\\begin{aligned}\n\\frac{dx}{dt} = r\\,x\\left(1-\\frac{x}{K}\\right)\\;-\\;\\frac{c\\,x\\,y}{1+\\alpha x},\\\\\n\\frac{dy}{dt} = \\varepsilon\\left(\\eta\\,\\frac{c\\,x\\,y}{1+\\alpha x}\\;-\\;m\\,y\\right),\n\\end{aligned}\n$$\n其中 $x$ 是猎物密度，$y$ 是捕食者密度。饱和功能性响应由分母中的因子 $(1+\\alpha x)$ 体现，当猎物动态迅速饱和时（相对于其他速率，$r$ 较大和/或 $\\varepsilon$ 较小导致捕食者与被捕食者的时间尺度差异悬殊），可能会出现刚性。\n\n您的推理和算法设计必须仅基于以下基本要素：\n- 常微分方程的初值问题 (IVP) 概念：给定 $\\frac{d\\mathbf{u}}{dt}=\\mathbf{f}(t,\\mathbf{u})$ 和 $\\mathbf{u}(0)=\\mathbf{u}_0$，求解 $\\mathbf{u}(t)$。\n- 定义：如果一种方法的局部截断误差在步长 $h\\to 0$ 时趋于 $0$，则该方法是一致的。如果误差在扰动下不会不受控制地增长，则该方法是稳定的；对于线性标量测试 $\\frac{du}{dt}=\\lambda u$（其中 $\\mathrm{Re}(\\lambda)\\le 0$），这由复平面上对应于 $z=h\\lambda$ 的稳定区域来表征。如果一种方法的全局误差在 $h\\to 0$ 时趋于 $0$，则该方法是收敛的。一致性加稳定性意味着收敛性。\n- 定步长单步法可以通过匹配泰勒级数（对于显式龙格-库塔类格式）或通过应用微积分基本定理在步长上对矢量场进行平均（对于隐式梯形类格式）来构建。\n\n实现两种方法：\n- 一种显式二阶龙格-库塔方法（显式中点法），这是一种形式阶为 $2$ 的一致显式方法。\n- 隐式梯形法则（形式阶也为 $2$），在每一步中使用精确的雅可比矩阵通过牛顿法求解。\n\n在固定区间 $[0,T]$上使用这些方法，其中 $T$ 的值在下面指定。对于每种方法，使用均匀步长进行步长减半研究。对于每个步长 $h_k$，计算在 $t=T$ 时的数值解，并与高精度参考解进行比较以估计全局误差。使用最小可用步长中误差递减的后缀，通过对 $\\log(\\text{error})$ 与 $\\log(h)$ 进行线性拟合来估计实验收敛阶 (EOC)。在本研究中，如果使用最小步长下至少 $3$ 个严格递减的误差点估计出的 EOC 至少为 $1.7$，则称一种方法“达到其形式阶”。\n\n将“猎物饱和引起的刚性迫使隐式方法达到其形式阶”对于给定的参数集定义为：隐式梯形法达到了如上所定义的形式阶，同时显式中点法在粗糙步长上受到稳定性限制，表现为在步长减半序列中至少一个较粗糙的步长上未能产生有限的、非 NaN 的终点值（即，在指定的 $5$ 个步长中，它产生的有限终点近似值少于 $5$ 个）。在这种情况下，为该参数集报告值 $1$；否则，报告 $0$。\n\n数值细节和测试套件：\n- 使用最终时间 $T=2$（即，$T=2$）。\n- 使用初始条件 $(x(0),y(0))=(x_0,y_0)=(0.5,0.3)$。\n- 使用 $N_k\\in\\{20,40,80,160,320\\}$ 个均匀步长，对应于 $h_k=T/N_k$，$k=0,1,2,3,4$。这提供了 $5$ 个减半的步长。\n- 使用具有严格容差的、能处理刚性问题的积分器计算在 $t=T$ 时的高精度参考解；此参考解仅用于衡量定步长方法的终点全局误差。\n- 对于隐式梯形法中的牛顿求解，使用 $\\mathbf{f}$ 的精确雅可比矩阵，牛顿绝对容差为 $10^{-12}$，每步最大迭代次数为 $20$ 次。\n\n为以下三个参数集（测试套件）提供结果，每个参数集表示为 $(r,K,\\alpha,c,\\eta,m,\\varepsilon)$：\n- 情况 $\\mathsf{A}$（非刚性基准）：$(2,\\,1,\\,2,\\,3,\\,0.7,\\,0.4,\\,1)$。\n- 情况 $\\mathsf{B}$（通过猎物饱和和时间尺度分裂导致的中度刚性）：$(50,\\,1,\\,2,\\,4,\\,0.7,\\,0.4,\\,0.1)$。\n- 情况 $\\mathsf{C}$（高度刚性）：$(150,\\,1,\\,2,\\,4,\\,0.7,\\,0.4,\\,0.05)$。\n\n输出规范：\n- 对于顺序为 $(\\mathsf{A},\\mathsf{B},\\mathsf{C})$ 的每种情况，输出一个如上定义的整数 $0$ 或 $1$。\n- 您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如 $[1,0,1]$。\n\n所有计算都是无量纲的；不需要物理单位。不使用角度。最终输出必须是可计算的布尔值或整数，如指定的那样，并且必须采用单行格式。", "solution": "核心任务是通过对一个捕食者-被捕食者系统进行步长减半收敛性研究，来探究常微分方程求解器的数值特性。该系统的动力学可以被调整为刚性，这使得显式和隐式数值方法的不同行为得以清晰展示。我们将实现两种二阶方法，一种显式，一种隐式，并利用它们的性能对不同参数集下系统的刚性进行分类，同时严格遵守一致性、稳定性和收敛性的定义。\n\n该系统是一个二维自治常微分方程 (ODE)，由以下公式给出：\n$$\n\\begin{aligned}\n\\frac{dx}{dt} = r\\,x\\left(1-\\frac{x}{K}\\right)\\;-\\;\\frac{c\\,x\\,y}{1+\\alpha x} \\\\\n\\frac{dy}{dt} = \\varepsilon\\left(\\eta\\,\\frac{c\\,x\\,y}{1+\\alpha x}\\;-\\;m\\,y\\right)\n\\end{aligned}\n$$\n这可以写成标准向量形式的初值问题 (IVP) $\\frac{d\\mathbf{u}}{dt} = \\mathbf{f}(t, \\mathbf{u})$，并带有一个初始条件 $\\mathbf{u}(t_0) = \\mathbf{u}_0$。在这里，状态向量是 $\\mathbf{u}(t) = [x(t), y(t)]^T$，矢量场是 $\\mathbf{f}(\\mathbf{u}) = [f_x(x,y), f_y(x,y)]^T$。给定的初始条件是 $\\mathbf{u}(0) = [x_0, y_0]^T = [0.5, 0.3]^T$。研究将在时间区间 $[0, T]$ 上进行，其中 $T=2$。\n\n核心概念是：\n- **一致性 (Consistency)**：如果一种方法的局部截断误差（在单步中产生的误差）在步长 $h \\to 0$ 时趋近于零，则该方法是一致的。\n- **稳定性 (Stability)**：如果在一个步骤中引入的误差在后续步骤中不会无限增长，则该方法是稳定的。对于刚性问题，这通过模型方程 $\\frac{du}{dt} = \\lambda u$（其中复数 $\\lambda$ 满足 $\\mathrm{Re}(\\lambda) \\le 0$）进行分析。方法的稳定区域是复数值 $z=h\\lambda$ 的集合，在该区域内数值解保持有界。\n- **收敛性 (Convergence)**：如果全局误差（在固定的最终时间 $T$ 处的累积误差）在 $h \\to 0$ 时趋近于零，则该方法是收敛的。达尔奎斯特等价定理指出，对于一致的方法，稳定性等价于收敛性。收敛速度通常通过实验收敛阶 (EOC) 来衡量。\n\n我们将实现两种形式阶为 $2$ 的定步长单步法。\n\n**1. 显式二阶龙格-库塔方法（显式中点法）**\n\n该方法通过匹配解的泰勒级数展开中的项来导出。它使用两次函数求值将解从时间 $t_n$推进到 $t_{n+1} = t_n + h$：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(t_n, \\mathbf{u}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}\\left(t_n + \\frac{h}{2}, \\mathbf{u}_n + \\frac{h}{2}\\mathbf{k}_1\\right) \\\\\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + h \\mathbf{k}_2\n\\end{aligned}\n$$\n该方法是显式的，因为 $\\mathbf{u}_{n+1}$ 是直接从已知量计算得出的。它是一致的，局部截断误差为 $O(h^3)$ 阶，这导致全局误差为 $O(h^2)$ 阶。然而，其稳定区域是复平面中的一个有限区域。如果一个问题是刚性的，其雅可比矩阵的特征值可能具有大的负实部，这会迫使乘积 $h\\lambda$ 落在稳定区域之外，除非步长 $h$ 受到严格限制。这是一种稳定性限制。\n\n**2. 隐式梯形法则**\n\n该方法源自微积分基本定理 $\\mathbf{u}(t_{n+1}) - \\mathbf{u}(t_n) = \\int_{t_n}^{t_{n+1}} \\mathbf{f}(t, \\mathbf{u}(t)) dt$，通过使用梯形法则来近似积分：\n$$\n\\mathbf{u}_{n+1} = \\mathbf{u}_n + \\frac{h}{2} \\left[ \\mathbf{f}(t_n, \\mathbf{u}_n) + \\mathbf{f}(t_{n+1}, \\mathbf{u}_{n+1}) \\right]\n$$\n该方法是隐式的，因为未知量 $\\mathbf{u}_{n+1}$ 出现在方程的两边。它也是一种二阶方法。关键的是，它是 A-稳定的，意味着其稳定区域包含整个复平面的左半部分。此属性使其即使在刚性问题中使用大步长也能保持稳定，从而使其精度而非稳定性成为限制因素。\n\n为了使用梯形法则，我们必须在每一步中求解一个关于 $\\mathbf{u}_{n+1}$ 的非线性方程组。我们定义一个函数 $\\mathbf{G}(\\mathbf{w}) = \\mathbf{0}$，其中我们寻求根 $\\mathbf{w} = \\mathbf{u}_{n+1}$：\n$$\n\\mathbf{G}(\\mathbf{w}) = \\mathbf{w} - \\mathbf{u}_n - \\frac{h}{2} \\left[ \\mathbf{f}(t_n, \\mathbf{u}_n) + \\mathbf{f}(t_{n+1}, \\mathbf{w}) \\right] = \\mathbf{0}\n$$\n这使用牛顿法求解。从一个初始猜测 $\\mathbf{w}^{(0)}$（例如，$\\mathbf{w}^{(0)} = \\mathbf{u}_n$）开始，我们进行迭代：\n$$\n\\mathbf{w}^{(k+1)} = \\mathbf{w}^{(k)} - [J_G(\\mathbf{w}^{(k)})]^{-1} \\mathbf{G}(\\mathbf{w}^{(k)})\n$$\n$\\mathbf{G}$ 关于 $\\mathbf{w}$ 的雅可比矩阵是 $J_G(\\mathbf{w}) = I - \\frac{h}{2} J_f(t_{n+1}, \\mathbf{w})$，其中 $I$ 是单位矩阵，$J_f$ 是 ODE 矢量场 $\\mathbf{f}$ 的雅可比矩阵。对于我们的系统，$J_f$ 的分量是：\n$$\nJ_f(x, y) = \\begin{pmatrix} \\frac{\\partial f_x}{\\partial x}  \\frac{\\partial f_x}{\\partial y} \\\\ \\frac{\\partial f_y}{\\partial x}  \\frac{\\partial f_y}{\\partial y} \\end{pmatrix} = \\begin{pmatrix} r\\left(1-\\frac{2x}{K}\\right) - \\frac{cy}{(1+\\alpha x)^2}  -\\frac{cx}{1+\\alpha x} \\\\ \\frac{\\varepsilon\\eta cy}{(1+\\alpha x)^2}  \\varepsilon\\left(\\frac{\\eta cx}{1+\\alpha x} - m\\right) \\end{pmatrix}\n$$\n牛顿迭代涉及求解线性系统 $J_G(\\mathbf{w}^{(k)}) \\Delta\\mathbf{w}^{(k)} = -\\mathbf{G}(\\mathbf{w}^{(k)})$ 以获得更新量 $\\Delta\\mathbf{w}^{(k)}$，然后设置 $\\mathbf{w}^{(k+1)} = \\mathbf{w}^{(k)} + \\Delta\\mathbf{w}^{(k)}$。当残差 $\\mathbf{G}(\\mathbf{w}^{(k)})$ 的范数低于 $10^{-12}$ 的容差时，我们停止迭代。\n\n**研究的算法设计**\n\n对于每个参数集 $(\\mathsf{A}, \\mathsf{B}, \\mathsf{C})$，执行以下过程：\n1.  **参考解**：使用一个鲁棒的刚性求解器（`SciPy` 的 `Radau`）以非常严格的容差（`atol=10^{-13}`, `rtol=10^{-13}`）计算在 $t=T=2$ 时的高精度参考解 $\\mathbf{u}_{\\text{ref}}$。\n2.  **步长减半循环**：对步数 $N_k \\in \\{20, 40, 80, 160, 320\\}$ 进行循环，对应的步长为 $h_k = T/N_k$。\n3.  **方法评估**：对于每个 $h_k$：\n    *   使用显式中点法对 IVP 从 $t=0$ 积分到 $t=T$。记录最终状态 $\\mathbf{u}_{\\text{EM}}(T)$。我们检查结果是否为有限值。存储全局误差的 $L_2$ 范数 $\\|\\mathbf{u}_{\\text{EM}}(T) - \\mathbf{u}_{\\text{ref}}\\|_2$。\n    *   类似地使用隐式梯形法。存储最终状态 $\\mathbf{u}_{\\text{IT}}(T)$ 及其全局误差范数 $\\|\\mathbf{u}_{\\text{IT}}(T) - \\mathbf{u}_{\\text{ref}}\\|_2$。\n4.  **分析与分类**：\n    *   **显式方法的稳定性**：我们检查显式方法在 $5$ 个步长中是否产生了任何非有限（例如 `inf` 或 `NaN`）的 $\\mathbf{u}_{\\text{EM}}(T)$ 结果。如果是，则将标志 `explicit_is_unstable` 设置为 true。\n    *   **隐式方法的收敛性**：我们分析来自隐式方法的误差。我们找到误差列表（对应于最小的步长）中严格递减的最长后缀。如果此后缀包含至少 $3$ 个点，我们对这些点的 $\\log(\\text{error})$ 与 $\\log(h)$ 进行线性回归。此拟合的斜率是估计的 EOC。如果 EOC 至少为 $1.7$，则将标志 `implicit_realizes_order` 设置为 true。\n    *   **最终裁定**：对于给定的参数集，如果 `implicit_realizes_order` 为 true 且 `explicit_is_unstable` 为 true，则结果为 $1$。否则，结果为 $0$。\n\n这个过程有效地对比了两种方法。在非刚性情况下，两种方法都应收敛，且 EOC 接近 $2$。在刚性情况下，显式方法会因稳定性约束而在较大步长下失败，而 A-稳定的隐式方法将保持稳定并展示其理论收敛阶，从而满足得到结果 $1$ 的条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nfrom scipy.linalg import solve as solve_linear_system\n\ndef solve():\n    \"\"\"\n    Performs a step-halving convergence study on a predator-prey system to \n    detect stiffness based on the performance of explicit and implicit solvers.\n    \"\"\"\n\n    # --- Problem Definition ---\n    # Initial Value Problem (IVP) settings\n    T_FINAL = 2.0\n    U0 = np.array([0.5, 0.3])\n\n    # Step-halving study parameters\n    N_STEPS_LIST = [20, 40, 80, 160, 320]\n    H_LIST = [T_FINAL / n for n in N_STEPS_LIST]\n\n    # Newton's method parameters for the implicit solver\n    NEWTON_TOL = 1e-12\n    NEWTON_MAX_ITER = 20\n\n    # Test cases: (r, K, alpha, c, eta, m, epsilon)\n    test_cases = [\n        # Case A: Non-stiff baseline\n        (2.0, 1.0, 2.0, 3.0, 0.7, 0.4, 1.0),\n        # Case B: Moderately stiff\n        (50.0, 1.0, 2.0, 4.0, 0.7, 0.4, 0.1),\n        # Case C: Highly stiff\n        (150.0, 1.0, 2.0, 4.0, 0.7, 0.4, 0.05),\n    ]\n\n    # --- ODE System Definition ---\n    def f_ode(t, u, params):\n        r, K, alpha, c, eta, m, epsilon = params\n        x, y = u\n        \n        # Avoid potential division by zero or negative populations, though unlikely with the chosen IC\n        if x  0: x = 0\n        if y  0: y = 0\n            \n        common_term = (c * x * y) / (1.0 + alpha * x)\n        \n        dxdt = r * x * (1.0 - x / K) - common_term\n        dydt = epsilon * (eta * common_term - m * y)\n        \n        return np.array([dxdt, dydt])\n\n    def jacobian_f(t, u, params):\n        r, K, alpha, c, eta, m, epsilon = params\n        x, y = u\n        \n        # Avoid negative populations in Jacobian calculation\n        if x  0: x = 0\n        if y  0: y = 0\n\n        denom = 1.0 + alpha * x\n        denom_sq = denom * denom\n\n        df1_dx = r * (1.0 - 2.0 * x / K) - (c * y) / denom_sq\n        df1_dy = - (c * x) / denom\n        df2_dx = epsilon * eta * (c * y) / denom_sq\n        df2_dy = epsilon * (eta * (c * x) / denom - m)\n        \n        return np.array([[df1_dx, df1_dy], [df2_dx, df2_dy]])\n\n    # --- Numerical Methods ---\n    def explicit_midpoint_solver(f, u0, t_final, n_steps, params):\n        h = t_final / n_steps\n        u = u0.copy()\n        t = 0.0\n        for _ in range(n_steps):\n            k1 = f(t, u, params)\n            k2 = f(t + h / 2.0, u + h / 2.0 * k1, params)\n            u += h * k2\n            t += h\n            if not np.all(np.isfinite(u)):\n                return u # Propagate non-finite value immediately\n        return u\n\n    def implicit_trapezoidal_solver(f, jac, u0, t_final, n_steps, params):\n        h = t_final / n_steps\n        u_n = u0.copy()\n        t_n = 0.0\n        I = np.identity(len(u0))\n\n        for _ in range(n_steps):\n            f_n = f(t_n, u_n, params)\n            t_np1 = t_n + h\n            \n            # Newton's method to solve for u_{n+1}\n            w = u_n.copy() # Initial guess for u_{n+1}\n            for _ in range(NEWTON_MAX_ITER):\n                f_np1 = f(t_np1, w, params)\n                G = w - u_n - (h / 2.0) * (f_n + f_np1)\n                \n                if np.linalg.norm(G)  NEWTON_TOL:\n                    break\n\n                J_G = I - (h / 2.0) * jac(t_np1, w, params)\n                delta_w = solve_linear_system(J_G, -G)\n                w += delta_w\n            \n            u_n = w\n            t_n = t_np1\n            \n            if not np.all(np.isfinite(u_n)):\n                return u_n\n\n        return u_n\n\n    results = []\n    for params in test_cases:\n        # 1. Compute high-accuracy reference solution\n        ref_sol = solve_ivp(\n            f_ode, [0, T_FINAL], U0, method='Radau', \n            args=(params,), atol=1e-13, rtol=1e-13\n        )\n        u_ref = ref_sol.y[:, -1]\n\n        em_errors = []\n        it_errors = []\n        em_unstable = False\n\n        # 2. Run step-halving study for both methods\n        for i, N in enumerate(N_STEPS_LIST):\n            h = H_LIST[i]\n\n            # Explicit Midpoint\n            u_em = explicit_midpoint_solver(f_ode, U0, T_FINAL, N, params)\n            if not np.all(np.isfinite(u_em)):\n                em_unstable = True\n                em_errors.append(np.inf)\n            else:\n                em_errors.append(np.linalg.norm(u_em - u_ref))\n\n            # Implicit Trapezoidal\n            u_it = implicit_trapezoidal_solver(f_ode, jacobian_f, U0, T_FINAL, N, params)\n            if not np.all(np.isfinite(u_it)):\n                 it_errors.append(np.inf)\n            else:\n                it_errors.append(np.linalg.norm(u_it - u_ref))\n        \n        # 3. Analyze results and classify\n        \n        # Check if implicit method realizes its formal order\n        it_realizes_order = False\n        \n        # Find the longest strictly decreasing suffix of errors\n        fit_indices = []\n        if len(it_errors)  0:\n            fit_indices.append(len(it_errors) - 1)\n            for i in range(len(it_errors) - 2, -1, -1):\n                if it_errors[i+1]  it_errors[i] and it_errors[i+1]  0:\n                    fit_indices.insert(0, i)\n                else:\n                    break\n        \n        if len(fit_indices) = 3:\n            h_fit = np.log([H_LIST[i] for i in fit_indices])\n            err_fit = np.log([it_errors[i] for i in fit_indices])\n            \n            # Use polyfit to find the slope (Experimental Order of Convergence)\n            eoc = np.polyfit(h_fit, err_fit, 1)[0]\n            \n            if eoc = 1.7:\n                it_realizes_order = True\n        \n        # Final classification\n        if it_realizes_order and em_unstable:\n            results.append(1)\n        else:\n            results.append(0)\n\n    # Print the final result in the specified format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3112018"}, {"introduction": "许多物理系统拥有守恒量（或称不变量），例如能量或动量，其在精确解中保持恒定。然而，标准的数值方法常常会破坏这些守恒律，导致在长时间模拟中出现非物理的漂移。本练习将向你展示一种简单而强大的几何积分技术——投影法，它通过在每一步后将解投影回不变量流形来强制保持约束，从而显著改善数值解的长期稳定性和定性行为。", "problem": "你需要编写一个完整的、可运行的程序，该程序实现并评估一个基于投影的求解器，用于求解约束常微分方程（ODE）动力学问题。其背景是光滑常微分方程在保持不变量的约束流形上的初值问题（IVP）。科学基础必须从基本定义开始：常微分方程（ODE）是 $dx/dt = f(x)$，初值问题（IVP）指定 $x(0) = x_0$，不变量流形是由 $g(x) = 0$ 定义的集合，且该集合在精确流下是保持不变的。相容性通过局部截断误差来定义，稳定性通过数值解在扰动或大步长下的有界性来评估（对于线性问题，通过绝对稳定性分析），收敛性则是在满足相容性和稳定性的条件下，全局误差随步长趋于零的性质。本问题中所有角度都必须以弧度表示。\n\n你将评估通过投影步骤强制施加不变量对稳定性和观测收敛阶的影响。考虑单位圆流形 $\\mathcal{M} = \\{ x \\in \\mathbb{R}^2 : \\|x\\| = 1 \\}$ 上的约束动力学，其旋转动力学为\n$$\n\\frac{dx}{dt} = f(x) = \\omega J x,\n$$\n其中 $J = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$ 且 $\\omega  0$ 是一个恒定的角速度。从 $x(0) = (1,0)^\\top$ 出发的精确解为\n$$\nx(t) = \\begin{bmatrix} \\cos(\\omega t) \\\\ \\sin(\\omega t) \\end{bmatrix},\n$$\n该解对于所有 $t \\ge 0$ 都保持不变量 $\\|x(t)\\| = 1$。\n\n实现两种单步数值方法：\n- 显式欧拉法（EE）：$x_{n+1} = x_n + h f(x_n)$。\n- 投影显式欧拉法（PEE）：计算一个试探步 $x_{n+1}^\\ast = x_n + h f(x_n)$，然后通过归一化投影到流形 $\\mathcal{M}$ 上来强制施加不变量：\n$$\nx_{n+1} = \\frac{x_{n+1}^\\ast}{\\|x_{n+1}^\\ast\\|}.\n$$\n\n你必须量化以下概念：\n- 通过局部截断误差量化相容性：从精确的初始状态 $x(0)$ 开始，走一个大小为 $h$ 的单步，并与精确解 $x(h)$ 进行比较。局部截断误差定义为 $e_{\\text{loc}}(h) = \\|x(h) - \\Phi_h(x(0))\\|$，其中 $\\Phi_h$ 是单步数值映射。观测到的局部阶 $p_{\\text{loc}}$ 是在一系列递减的 $h$ 上，$\\log(e_{\\text{loc}}(h))$ 关于 $\\log(h)$ 的斜率。\n- 通过全局误差量化收敛性：以步长 $h$（其中 $T/h$ 为整数）积分到最终时间 $T$，并将数值状态与精确解 $x(T)$ 进行比较。全局误差为 $e_{\\text{glob}}(h,T) = \\|x(T) - x_N\\|$，其中 $x_N$ 是经过 $N = T/h$ 步后的数值状态。观测到的全局阶 $p_{\\text{glob}}$ 是 $\\log(e_{\\text{glob}}(h,T))$ 关于 $\\log(h)$ 的斜率。\n- 稳定性：对于一个大的步长和有限的时间范围 $T$，如果数值轨迹在不变量附近保持有界（此处形式化为 $\\max_{0 \\le n \\le N} \\|x_n\\| \\le 2$），则声明该方法为稳定的（布尔值True）。如果 $\\|x_n\\|$ 变为非有限值或超过 $2$，则声明为不稳定的（布尔值False）。\n\n你的程序必须执行以下测试套件，使用指定的参数并产生所需的输出：\n\n- 测试套件 A（相容性 / 局部截断误差）：\n  - 参数：$\\omega = 1$，初始状态 $x(0) = (1,0)^\\top$，步长 $h \\in \\{0.1, 0.05, 0.025, 0.0125\\}$。\n  - 任务：\n    1. 计算显式欧拉法（EE）的 $e_{\\text{loc}}(h)$。\n    2. 计算投影显式欧拉法（PEE）的 $e_{\\text{loc}}(h)$。\n    3. 通过对 $\\log(e_{\\text{loc}}(h))$ 关于 $\\log(h)$ 的线性回归来估计 EE 和 PEE 的 $p_{\\text{loc}}$。\n\n- 测试套件 B（收敛性 / 最终时间的全局误差）：\n  - 参数：$\\omega = 1$，最终时间 $T = 1$，初始状态 $x(0) = (1,0)^\\top$，步长 $h \\in \\{T/20, T/40, T/80, T/160\\} = \\{0.05, 0.025, 0.0125, 0.00625\\}$ 且 $T/h \\in \\mathbb{N}$。\n  - 任务：\n    1. 使用 EE 积分到 $T$ 并为每个 $h$ 计算 $e_{\\text{glob}}(h,T)$。\n    2. 使用 PEE 积分到 $T$ 并为每个 $h$ 计算 $e_{\\text{glob}}(h,T)$。\n    3. 通过对 $\\log(e_{\\text{glob}}(h,T))$ 关于 $\\log(h)$ 的线性回归来估计 EE 和 PEE 的 $p_{\\text{glob}}$。\n\n- 测试套件 C（大步长下的稳定性）：\n  - 参数：$\\omega = 5$，最终时间 $T = 4$，步长 $h = 0.5$（因此 $T/h = 8 \\in \\mathbb{N}$），初始状态 $x(0) = (1,0)^\\top$。\n  - 任务：\n    1. 使用 EE 进行积分并计算布尔值稳定性结果。\n    2. 使用 PEE 进行积分并计算相同的布尔值稳定性结果。\n\n最终输出格式：\n- 你的程序应该生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列\n$$\n[p_{\\text{loc,EE}}, p_{\\text{loc,PEE}}, p_{\\text{glob,EE}}, p_{\\text{glob,PEE}}, \\text{stable}_{\\text{EE}}, \\text{stable}_{\\text{PEE}}].\n$$\n- 前四个条目是浮点数，后两个条目是布尔值。角度以弧度为单位，不涉及物理单位。在输出字符串中，浮点数应四舍五入到三位小数。", "solution": "该问题要求实现并分析两种用于求解约束常微分方程（ODE）的数值方法。控制性常微分方程为 $\\frac{dx}{dt} = f(x)$，初始条件为 $x(0) = x_0$。这构成了一个初值问题（IVP）。动力学被约束在一个不变量流形上，该流形是由代数方程 $g(x) = 0$ 定义的集合 $\\mathcal{M}$，它在 ODE 的精确流下保持不变，即如果 $x_0 \\in \\mathcal{M}$，那么对于所有时间 $t$，都有 $x(t) \\in \\mathcal{M}$。\n\n具体问题考虑的是 $\\mathbb{R}^2$ 中的旋转动力学，由下式给出：\n$$\n\\frac{dx}{dt} = \\omega J x\n$$\n其中 $x \\in \\mathbb{R}^2$，$\\omega  0$ 是一个恒定的角速度，而 $J = \\begin{bmatrix} 0  -1 \\\\ 1  0 \\end{bmatrix}$ 是用于 $\\pi/2$ 旋转的斜对称矩阵。初始条件是 $x(0) = (1, 0)^\\top$。精确解是 $x(t) = (\\cos(\\omega t), \\sin(\\omega t))^\\top$。该解的轨迹局限于单位圆上，这个单位圆就是不变量流形 $\\mathcal{M} = \\{x \\in \\mathbb{R}^2 : \\|x\\| = 1 \\}$。相应的不变量是 $g(x) = \\|x\\|^2 - 1 = 0$。\n\n我们将分析用于此 IVP 的两种数值方法。\n\n第一种方法是标准的显式欧拉（EE）法。它是一种单步法，由更新规则定义：\n$$\nx_{n+1} = x_n + h f(x_n)\n$$\n其中 $h$ 是步长。对于给定的旋转系统，EE 更新为 $x_{n+1} = (I + h\\omega J)x_n$。状态的范数根据 $\\|x_{n+1}\\|^2 = \\|(I + h\\omega J)x_n\\|^2 = x_n^\\top (I - h\\omega J)(I + h\\omega J) x_n = x_n^\\top (I + (h\\omega)^2 I) x_n = (1+(h\\omega)^2)\\|x_n\\|^2$ 演化（利用了 $J^\\top J=I$）。由于对于 $h\\omega  0$，放大因子 $\\sqrt{1+(h\\omega)^2}$ 总是大于1，数值解会向外呈螺旋状发散，系统性地违反了不变量 $\\|x\\|=1$。这显示了 EE 方法在处理保守系统时的一个主要弱点。\n\n第二种方法是投影显式欧拉（PEE）法。这是一种旨在强制施加不变量的几何积分技术。它包括两个阶段：\n1. 使用显式欧拉法进行试探步：$x_{n+1}^\\ast = x_n + h f(x_n)$。\n2. 投影回流形 $\\mathcal{M}$：$x_{n+1} = \\frac{x_{n+1}^\\ast}{\\|x_{n+1}^\\ast\\|}$。\n通过归一化进行的这种投影确保了对于所有步数 $n \\ge 0$，都有 $\\|x_{n+1}\\| = 1$，从而通过构造保持了不变量。\n\n我们基于相容性、收敛性和稳定性来评估这些方法。\n\n相容性通过局部截断误差（LTE）$e_{\\text{loc}}(h) = \\|x(h) - \\Phi_h(x(0))\\|$进行评估，其中 $\\Phi_h$ 是单步数值映射。观测到的精度阶 $p_{\\text{loc}}$ 是通过 $\\log(e_{\\text{loc}})$ 关于 $\\log(h)$ 的斜率来估计的。对于 EE，对精确解和数值解进行泰勒展开，显示其 LTE 为 $O(h^2)$，对应的局部阶为 $p_{\\text{loc,EE}}=2$。对于 PEE，投影步骤出人意料地提高了局部精度。对于球体上的系统，如果其向量场与球体相切（如此处的情况，因为 $x \\cdot f(x) = \\omega x^\\top Jx = 0$），投影会校正垂直于流形切空间的一阶误差项，从而得到 $O(h^3)$ 的 LTE。因此，我们预期局部阶为 $p_{\\text{loc,PEE}}=3$。\n\n收敛性通过在固定时间 $T$ 的全局误差 $e_{\\text{glob}}(h,T) = \\|x(T) - x_N\\|$ 来评估，其中 $N=T/h$。全局收敛阶 $p_{\\text{glob}}$ 是通过 $\\log(e_{\\text{glob}})$ 关于 $\\log(h)$ 的斜率找到的。对于一个局部截断误差为 $O(h^{p+1})$ 的方法，其全局阶通常为 $p$。因此，我们预期 EE 的全局阶为 $p_{\\text{glob,EE}} = 1$。对于 PEE，虽然局部截断误差是 $O(h^3)$，但这种简单的步后投影方案通常不会提升基础方法的全局阶。相位误差的累积是一阶的，它主导了全局误差。因此，我们预期全局阶仍为 $p_{\\text{glob,PEE}}=1$，尽管与 EE 相比，其误差常数可能更小。\n\n稳定性是通过在有限时间范围 $T=4$ 内使用大步长 $h=0.5$ 进行积分来评估的。如果数值轨迹保持有界，具体来说是 $\\max_{n}\\|x_n\\| \\le 2$，则该方法被认为是稳定的。对于 EE，当 $\\omega=5$ 且 $h=0.5$ 时，每一步的范数放大因子是 $\\sqrt{1+(5 \\cdot 0.5)^2} = \\sqrt{1+2.5^2} = \\sqrt{7.25} \\approx 2.69$。由于初始范数为 $\\|x_0\\|=1$，仅一步之后范数就已达到 $\\|x_1\\| \\approx 2.69$，超过了界限 $2$。因此，预期 EE 方法是不稳定的。对于 PEE，投影步骤通过构造确保了对于 $n \\ge 1$ 有 $\\|x_n\\|=1$。整个轨迹上的最大范数将是 $1$，因此根据此定义，该方法是稳定的。\n\n程序实现了这三个测试套件。测试 A 计算局部误差，用于一系列递减的步长 $h$，并使用对数-对数数据的线性回归来找到 $p_{\\text{loc}}$。测试 B 计算在 $T=1$ 时的全局误差，用于一系列的 $h$，以找到 $p_{\\text{glob}}$。测试 C 使用大步长进行积分并检查稳定性准则。所有计算都使用 `numpy` 以实现高效的向量和矩阵运算，并使用 `numpy.polyfit` 进行线性回归以找到精度阶。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates Explicit Euler (EE) and Projected Explicit Euler (PEE)\n    methods for a constrained ODE system.\n    \"\"\"\n\n    # Define the ODE function dx/dt = omega * J * x\n    def f(x, omega):\n        # f(x) = omega * [-x[1], x[0]]\n        return omega * np.array([-x[1], x[0]])\n\n    # Define the exact solution x(t) = [cos(omega*t), sin(omega*t)]\n    def exact_solution(t, omega):\n        return np.array([np.cos(omega * t), np.sin(omega * t)])\n\n    # --- Test Suite A: Consistency (Local Truncation Error) ---\n    omega_A = 1.0\n    x0_A = np.array([1.0, 0.0])\n    h_vals_A = np.array([0.1, 0.05, 0.025, 0.0125])\n    \n    errors_loc_ee = []\n    errors_loc_pee = []\n\n    for h in h_vals_A:\n        x_exact_h = exact_solution(h, omega_A)\n        \n        # Tentative step (same for both methods)\n        x_star = x0_A + h * f(x0_A, omega_A)\n        \n        # EE state after one step\n        x1_ee = x_star\n        \n        # PEE state after one step\n        x1_pee = x_star / np.linalg.norm(x_star)\n        \n        # Compute local errors\n        errors_loc_ee.append(np.linalg.norm(x_exact_h - x1_ee))\n        errors_loc_pee.append(np.linalg.norm(x_exact_h - x1_pee))\n\n    # Estimate local orders using linear regression on log-log plot\n    log_h_A = np.log(h_vals_A)\n    log_err_loc_ee = np.log(np.array(errors_loc_ee))\n    log_err_loc_pee = np.log(np.array(errors_loc_pee))\n\n    p_loc_ee = np.polyfit(log_h_A, log_err_loc_ee, 1)[0]\n    p_loc_pee = np.polyfit(log_h_A, log_err_loc_pee, 1)[0]\n\n    # --- Test Suite B: Convergence (Global Error) ---\n    omega_B = 1.0\n    T_B = 1.0\n    x0_B = np.array([1.0, 0.0])\n    h_vals_B = np.array([T_B/20, T_B/40, T_B/80, T_B/160])\n    \n    errors_glob_ee = []\n    errors_glob_pee = []\n\n    x_exact_T = exact_solution(T_B, omega_B)\n\n    for h in h_vals_B:\n        N = int(round(T_B / h))\n        \n        # EE integration\n        x_n_ee = x0_B.copy()\n        for _ in range(N):\n            x_n_ee = x_n_ee + h * f(x_n_ee, omega_B)\n        \n        # PEE integration\n        x_n_pee = x0_B.copy()\n        for _ in range(N):\n            x_star_pee = x_n_pee + h * f(x_n_pee, omega_B)\n            norm_star = np.linalg.norm(x_star_pee)\n            if norm_star  0:\n                x_n_pee = x_star_pee / norm_star\n            else: # In case of zero vector, avoid division by zero\n                x_n_pee = x_star_pee\n\n        # Compute global errors\n        errors_glob_ee.append(np.linalg.norm(x_exact_T - x_n_ee))\n        errors_glob_pee.append(np.linalg.norm(x_exact_T - x_n_pee))\n\n    # Estimate global orders using linear regression\n    log_h_B = np.log(h_vals_B)\n    log_err_glob_ee = np.log(np.array(errors_glob_ee))\n    log_err_glob_pee = np.log(np.array(errors_glob_pee))\n\n    p_glob_ee = np.polyfit(log_h_B, log_err_glob_ee, 1)[0]\n    p_glob_pee = np.polyfit(log_h_B, log_err_glob_pee, 1)[0]\n\n    # --- Test Suite C: Stability ---\n    omega_C = 5.0\n    T_C = 4.0\n    h_C = 0.5\n    x0_C = np.array([1.0, 0.0])\n    N_C = int(round(T_C / h_C))\n    \n    # EE stability check\n    x_n_ee_C = x0_C.copy()\n    max_norm_ee = np.linalg.norm(x_n_ee_C)\n    for _ in range(N_C):\n        x_n_ee_C += h_C * f(x_n_ee_C, omega_C)\n        norm = np.linalg.norm(x_n_ee_C)\n        if not np.isfinite(norm):\n            max_norm_ee = np.inf\n            break\n        max_norm_ee = max(max_norm_ee, norm)\n    \n    stable_ee = max_norm_ee = 2.0\n\n    # PEE stability check\n    x_n_pee_C = x0_C.copy()\n    max_norm_pee = np.linalg.norm(x_n_pee_C)\n    for _ in range(N_C):\n        x_star_C = x_n_pee_C + h_C * f(x_n_pee_C, omega_C)\n        norm_star = np.linalg.norm(x_star_C)\n        if norm_star == 0:\n            max_norm_pee = 0 # norm becomes 0, still = 2\n            x_n_pee_C = x_star_C\n        else:\n             x_n_pee_C = x_star_C / norm_star\n        max_norm_pee = max(max_norm_pee, np.linalg.norm(x_n_pee_C))\n\n    stable_pee = max_norm_pee = 2.0\n\n    # Format and print the final output\n    print(f\"[{p_loc_ee:.3f},{p_loc_pee:.3f},{p_glob_ee:.3f},{p_glob_pee:.3f},{stable_ee},{stable_pee}]\")\n\nsolve()\n```", "id": "3111955"}]}