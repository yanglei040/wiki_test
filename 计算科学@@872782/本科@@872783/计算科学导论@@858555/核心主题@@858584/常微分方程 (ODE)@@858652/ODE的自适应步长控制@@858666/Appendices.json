{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。这项练习将指导你从零开始，亲手实现一个完整的自适应步长求解器[@problem_id:3259704]。通过实现经典的 Bogacki–Shampine 嵌入式龙格-库塔方法，你将深入理解误差估计和步长控制机制的运作核心，并学会如何通过一系列测试案例来验证求解器的鲁棒性。", "problem": "考虑一个由形式为 $y'(t) = f(t,y)$ 的常微分方程 (ODE) 和初始条件 $y(t_0) = y_0$ 定义的初值问题 (IVP)。单步法仅使用当前步的信息将解从 $(t,y)$ 推进到 $(t+h, y_{\\text{new}})$。在显式龙格-库塔 (RK) 方法中，增量是由阶段导数的加权组合构造的。一个嵌入式 RK 对通过相同的阶段计算提供两个不同阶的近似值，从而能够进行局部误差估计以实现自适应步长控制。\n\n您的任务是实现一个与 Bogacki–Shampine $2(3)$ 构造一致的嵌入式龙格-库塔对，并用它来驱动一个自适应步长选择算法。该算法必须：\n\n- 在每一步计算阶段导数，并生成一个高阶近似 $y^{[p]}$ 和一个低阶近似 $y^{[q]}$，其中 $p>q$。\n- 从差值 $y^{[p]} - y^{[q]}$ 估计局部截断误差。\n- 当缩放误差范数小于或等于 $1$ 时接受一个步长，否则拒绝。\n- 使用误差和步长之间的渐近标度关系来调整步长 $h$，通过应用安全因子并限制 $h$ 的增长和衰减来确保数值稳定性。\n- 遵守最终时间 $t_f$，必要时减小最后一步的步长，以使 $t$ 恰好达到 $t_f$。\n\n您必须为标量 ODE 实现自适应积分器，每步使用以下缩放误差范数：\n$$\nE = \\frac{|y^{[p]} - y^{[q]}|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[p]}|)},\n$$\n其中 $\\mathrm{atol}$ 是绝对容差，$\\mathrm{rtol}$ 是相对容差。如果 $E \\leq 1$，则接受该步长。步长控制器必须基于以下原理：阶为 $h^{m}$ 的误差意味着 $h_{\\text{new}} \\propto h\\,E^{-1/m}$，其中整数 $m$ 与误差估计器的阶数相匹配。包括一个乘法安全因子，并通过规定的界限限制增长和衰减。\n\n当出现三角函数时，角度量必须以弧度为单位解释。\n\n实现自适应求解器并将其应用于以下 IVP 测试套件。对于每种情况，以浮点数形式返回 $y(t_f)$ 的数值近似。\n\n- 案例 1 (理想情况，指数稳定):\n  - $f(t,y) = -y$, $y(0) = 1$, $t_0 = 0$, $t_f = 5$。\n  - 容差: $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在平滑问题上的一般性能和稳定性。\n\n- 案例 2 (带三角函数强迫项的时间相关增长，弧度):\n  - $f(t,y) = y\\sin(t)$, $y(0) = 1$, $t_0 = 0$, $t_f = 3$。\n  - 容差: $\\mathrm{rtol} = 10^{-7}$, $\\mathrm{atol} = 10^{-10}$。\n  - 理由：测试对时间相关系数的处理，并要求角度以弧度为单位。\n\n- 案例 3 (中度类刚性线性衰减):\n  - $f(t,y) = -15\\,y$, $y(0) = 1$, $t_0 = 0$, $t_f = 1$。\n  - 容差: $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在更快衰减下的步长自适应。\n\n- 案例 4 (奇点附近的非线性增长):\n  - $f(t,y) = y^2$, $y(0) = 1$, $t_0 = 0$, $t_f = 0.9$。\n  - 容差: $\\mathrm{rtol} = 10^{-6}$, $\\mathrm{atol} = 10^{-9}$。\n  - 理由：测试在 $t=1$ 处爆破点附近的鲁棒性。\n\n- 案例 5 (零动态，边界情况):\n  - $f(t,y) = 0$, $y(0) = 5$, $t_0 = 0$, $t_f = 10$。\n  - 容差: $\\mathrm{rtol} = 10^{-8}$, $\\mathrm{atol} = 10^{-12}$。\n  - 理由：测试当估计误差恒为零时控制器的行为。\n\n所有案例通用的控制器参数：\n- 安全因子 $s = 0.9$，\n- 最小增长因子 $g_{\\min} = 0.2$，\n- 最大增长因子 $g_{\\max} = 5.0$，\n- 初始步长 $h_0 = 10^{-3}$，\n- 最小步长 $h_{\\min} = 10^{-12}$，\n- 最大步长 $h_{\\max} = (t_f - t_0)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按案例 1 到 5 的顺序排列，例如 $[r_1,r_2,r_3,r_4,r_5]$，其中每个 $r_i$ 是案例 $i$ 的 $y(t_f)$ 的浮点数近似值。", "solution": "任务的核心是基于初值问题 (IVP)、龙格-库塔 (RK) 方法和局部截断误差的定义，从第一性原理出发构建一个自适应单步积分器。\n\n一个 IVP 指定了 $y'(t) = f(t,y)$ 及 $y(t_0) = y_0$。单步法使用单个步长 $h_n$ 从 $(t_n,y_n)$ 计算 $y_{n+1}$，而无需参考更早的历史记录。在显式龙格-库塔 (RK) 方法中，新值是阶段导数的加权组合。通用的显式 RK 构造如下：\n$$\nk_1 = f(t_n, y_n),\\quad\nk_2 = f(t_n + c_2 h, y_n + h a_{21} k_1),\\quad \\dots,\\quad\nk_s = f(t_n + c_s h, y_n + h \\sum_{j=1}^{s-1} a_{sj} k_j),\n$$\n一个 $p$ 阶近似为\n$$\ny^{[p]}_{n+1} = y_n + h \\sum_{j=1}^s b_j k_j.\n$$\n一个嵌入式对提供两组权重 $(b_j)$ 和 $(\\hat b_j)$，它们使用相同的阶段进行评估，以得到 $p>q$ 的 $y^{[p]}$ 和 $y^{[q]}$。差值\n$$\n\\Delta = y^{[p]}_{n+1} - y^{[q]}_{n+1}\n$$\n的计算成本可以忽略不计，并且它会随着由构造决定的 $h$ 的已知幂次进行缩放。\n\n对于 Bogacki–Shampine $2(3)$ 对，该方法使用 $s=4$ 个阶段，节点为 $c_2 = \\tfrac{1}{2}$、$c_3 = \\tfrac{3}{4}$、$c_4 = 1$。内部系数为 $a_{21} = \\tfrac{1}{2}$、$a_{32} = \\tfrac{3}{4}$（其中 $a_{31} = 0$），以及 $a_{41} = \\tfrac{2}{9}$、$a_{42} = \\tfrac{1}{3}$、$a_{43} = \\tfrac{4}{9}$。高阶权重（阶 $p=3$）为\n$$\nb_1 = \\tfrac{2}{9},\\quad b_2 = \\tfrac{1}{3},\\quad b_3 = \\tfrac{4}{9},\\quad b_4 = 0,\n$$\n而低阶权重（阶 $q=2$）为\n$$\n\\hat b_1 = \\tfrac{7}{24},\\quad \\hat b_2 = \\tfrac{1}{4},\\quad \\hat b_3 = \\tfrac{1}{3},\\quad \\hat b_4 = \\tfrac{1}{8}.\n$$\n阶段和近似值的计算如下\n$$\n\\begin{aligned}\nk_1 = f(t, y),\\\\\nk_2 = f\\Big(t + \\tfrac{1}{2}h,\\, y + h\\,\\tfrac{1}{2}\\,k_1\\Big),\\\\\nk_3 = f\\Big(t + \\tfrac{3}{4}h,\\, y + h\\,\\tfrac{3}{4}\\,k_2\\Big),\\\\\ny^{[3]} = y + h\\Big(\\tfrac{2}{9}k_1 + \\tfrac{1}{3}k_2 + \\tfrac{4}{9}k_3\\Big),\\\\\nk_4 = f\\Big(t + h,\\, y^{[3]}\\Big),\\\\\ny^{[2]} = y + h\\Big(\\tfrac{7}{24}k_1 + \\tfrac{1}{4}k_2 + \\tfrac{1}{3}k_3 + \\tfrac{1}{8}k_4\\Big).\n\\end{aligned}\n$$\n嵌入式差值 $\\Delta = y^{[3]} - y^{[2]}$ 提供了一个误差估计器，其主导行为为 $O(h^3)$；也就是说，对于平滑的 $f$，它像 $C h^3$ 一样缩放。这种缩放特性使得形式为 $h_{\\text{new}} = h \\cdot s \\cdot E^{-1/3}$ 的控制器是合理的，其中 $s$ 是一个安全因子，$E$ 是一个缩放误差范数。为确保数值鲁棒性，我们将乘法增长/衰减因子限制在 $g_{\\min} \\leq s E^{-1/3} \\leq g_{\\max}$ 范围内，并且还将 $h_{\\text{new}}$ 裁剪到 $[h_{\\min}, h_{\\max}]$。当 $E \\leq 1$ 时，步长被接受，$y$ 前进到 $y^{[3]}$；否则，步长被拒绝，并用一个更小的 $h$ 重新计算。\n\n对于标量问题，选择缩放误差范数以平衡绝对容差和相对容差：\n$$\nE = \\frac{|\\Delta|}{\\mathrm{atol} + \\mathrm{rtol}\\,\\max(|y|,|y^{[3]}|)}.\n$$\n这确保了接受准则 $E \\leq 1$ 能相对于解的量级控制误差，同时避免了当 $y$ 接近零时除以非常小的数。\n\n从 $t_0$ 积分到 $t_f$ 的算法步骤：\n- 初始化 $t = t_0, y = y_0$，在 $[h_{\\min}, h_{\\max}]$ 中选择 $h$（例如给定的 $h_0$），并设置控制器参数 $s, g_{\\min}, g_{\\max}$。\n- 当 $t < t_f$ 时循环：\n  - 如果 $t + h > t_f$，则设置 $h = t_f - t$ 以精确到达 $t_f$。\n  - 计算 $k_1, k_2, k_3, y^{[3]}, k_4$ 和 $y^{[2]}$。\n  - 根据 $y, y^{[3]}, y^{[2]}, \\mathrm{atol}$ 和 $\\mathrm{rtol}$ 计算 $E$。\n  - 如果 $E \\leq 1$，接受该步：设置 $t \\gets t + h, y \\gets y^{[3]}$。\n  - 计算候选增长因子 $g = s \\cdot E^{-1/3}$；如果 $E=0$，则设置 $g = g_{\\max}$。\n  - 将 $g$ 限制在 $[g_{\\min}, g_{\\max}]$ 内，然后更新 $h \\gets \\mathrm{clip}(h \\cdot g, h_{\\min}, h_{\\max})$。\n  - 如果步长被拒绝 ($E > 1$)，则如上更新 $h$ 并重新计算，但不推进 $t$ 或 $y$。\n- 返回 $y(t_f)$。\n\n我们现在简要分析每个测试案例及其预期行为：\n- 案例 1: $y'(t) = -y$，精确解为 $y(t) = e^{-t}$，因此 $y(5) = e^{-5}$。该方法应采取适中的步长并快速收敛。\n- 案例 2: $y'(t) = y\\sin(t)$（以弧度为单位），精确解为 $y(t) = \\exp(1 - \\cos t)$，得到 $y(3) = \\exp(1 - \\cos 3)$。算法必须平滑地处理时间相关的强迫项。\n- 案例 3: $y'(t) = -15y$，精确解为 $y(1) = e^{-15}$，由于快速衰减，初始时需要较小的步长，但随着 $y$ 的减小，控制器会增大 $h$。\n- 案例 4: $y'(t) = y^2$，对于 $t<1$ 的精确解为 $y(t) = \\frac{1}{1 - t}$，因此 $y(0.9) = 10$。当 $t$ 接近 $t=1$ 的爆破点时，该方法必须自适应地减小 $h$。\n- 案例 5: $y'(t) = 0$ 产生常数解 $y(t) = 5$；误差估计器恒为零，控制器会将 $h$ 增大到 $h_{\\max}$。\n\n通过实现 Bogacki–Shampine $2(3)$ 阶段和从 $O(h^3)$ 误差估计推导出的控制器，自适应求解器将为所有案例提供 $y(t_f)$，并以指定格式打印。", "answer": "```python\n# Python 3.12, numpy 1.23.5 allowed; no other libraries.\nimport numpy as np\n\ndef rk23_bogacki_shampine_step(f, t, y, h):\n    \"\"\"\n    Perform one Bogacki-Shampine 2(3) step for a scalar ODE y' = f(t,y).\n    Returns (y_high, y_low) where y_high is the 3rd-order solution, y_low is the 2nd-order embedded solution.\n    \"\"\"\n    k1 = f(t, y)\n    k2 = f(t + 0.5 * h, y + h * 0.5 * k1)\n    k3 = f(t + 0.75 * h, y + h * 0.75 * k2)\n    # 3rd-order solution\n    y3 = y + h * ( (2.0/9.0) * k1 + (1.0/3.0) * k2 + (4.0/9.0) * k3 )\n    # Stage 4 evaluated at t+h, y3\n    k4 = f(t + h, y3)\n    # 2nd-order embedded solution\n    y2 = y + h * ( (7.0/24.0) * k1 + (1.0/4.0) * k2 + (1.0/3.0) * k3 + (1.0/8.0) * k4 )\n    return y3, y2\n\ndef integrate_adaptive(f, t0, tf, y0, rtol, atol,\n                       h0=1e-3, hmin=1e-12, hmax=None,\n                       safety=0.9, growth_min=0.2, growth_max=5.0):\n    \"\"\"\n    Adaptive integrator using Bogacki-Shampine 2(3) pair for scalar ODEs.\n    \"\"\"\n    t = float(t0)\n    y = float(y0)\n    if hmax is None:\n        hmax = abs(tf - t0)\n    h = max(hmin, min(h0, hmax))\n    # Direction of integration\n    direction = 1.0 if tf >= t0 else -1.0\n    h *= direction\n    hmin_signed = hmin * direction\n    hmax_signed = hmax * direction\n\n    # Main integration loop\n    # Guard for max iterations to prevent infinite loops in pathological cases\n    max_steps = 10_000_000\n    steps = 0\n    while (direction > 0 and t < tf) or (direction < 0 and t > tf):\n        steps += 1\n        if steps > max_steps:\n            # Fallback: give current y\n            break\n\n        # Adjust step to not overshoot tf\n        remaining = tf - t\n        if direction * h > direction * remaining:\n            h = remaining\n\n        # Take one RK23 step\n        y3, y2 = rk23_bogacki_shampine_step(f, t, y, h)\n\n        # Scaled error norm (scalar)\n        scale = atol + rtol * max(abs(y), abs(y3))\n        # Prevent zero scale\n        if scale == 0.0:\n            scale = atol\n        err = abs(y3 - y2) / scale\n\n        # Accept or reject\n        if err <= 1.0:\n            # Accept the step\n            t = t + h\n            y = y3\n            # Compute growth factor; estimator scales ~ h^3\n            if err == 0.0:\n                g = growth_max\n            else:\n                g = safety * err ** (-1.0 / 3.0)\n            # Bound growth factor\n            g = max(growth_min, min(g, growth_max))\n            # Update h and clip\n            h = h * g\n            # Clip to [hmin, hmax] with sign\n            if direction > 0:\n                h = min(max(h, hmin_signed), hmax_signed)\n            else:\n                h = max(min(h, hmin_signed), hmax_signed)\n        else:\n            # Reject step; decrease h\n            g = safety * err ** (-1.0 / 3.0)\n            g = max(growth_min, min(g, growth_max))\n            h = h * g\n            # Ensure not below minimum\n            if direction > 0:\n                h = max(h, hmin_signed)\n            else:\n                h = min(h, hmin_signed)\n            # If h becomes too small, break to avoid infinite loop\n            if abs(h) <= hmin:\n                # Cannot reduce further; accept and break\n                # This is a conservative fallback\n                t = t + h\n                y = y3\n                break\n\n    return y\n\ndef solve():\n    # Define the test cases\n    # Case 1: y' = -y, y(0) = 1, tf = 5\n    def f1(t, y): return -y\n\n    # Case 2: y' = y*sin(t), radians, y(0) = 1, tf = 3\n    def f2(t, y): return y * np.sin(t)\n\n    # Case 3: y' = -15 y, y(0) = 1, tf = 1\n    def f3(t, y): return -15.0 * y\n\n    # Case 4: y' = y^2, y(0) = 1, tf = 0.9\n    def f4(t, y): return y * y\n\n    # Case 5: y' = 0, y(0) = 5, tf = 10\n    def f5(t, y): return 0.0\n\n    test_cases = [\n        # (f, t0, tf, y0, rtol, atol)\n        (f1, 0.0, 5.0, 1.0, 1e-6, 1e-9),\n        (f2, 0.0, 3.0, 1.0, 1e-7, 1e-10),\n        (f3, 0.0, 1.0, 1.0, 1e-6, 1e-9),\n        (f4, 0.0, 0.9, 1.0, 1e-6, 1e-9),\n        (f5, 0.0, 10.0, 5.0, 1e-8, 1e-12),\n    ]\n\n    results = []\n    for f, t0, tf, y0, rtol, atol in test_cases:\n        ytf = integrate_adaptive(\n            f=f, t0=t0, tf=tf, y0=y0, rtol=rtol, atol=atol,\n            h0=1e-3, hmin=1e-12, hmax=abs(tf - t0),\n            safety=0.9, growth_min=0.2, growth_max=5.0\n        )\n        results.append(ytf)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3259704"}, {"introduction": "构建了求解器之后，一个关键问题是如何在实际应用中设置其参数。这项练习[@problem_id:3095862]将理论与一个直观的物理模型——牛顿冷却定律——相结合，探讨了如何根据实际的物理测量精度要求来合理设置求解器的绝对和相对容差。通过这个过程，你将学会如何让数值误差的控制服务于有意义的物理目标。", "problem": "给定一个线性热模型，其由常微分方程（ODE）$T'(t) = -k\\,(T(t) - T_{\\infty})$ 表示，其中 $T(t)$ 是以摄氏度为单位、在时间 $t$（以秒为单位）时的温度，$k$ 是冷却系数，单位为 $\\mathrm{s}^{-1}$，$T_{\\infty}$ 是环境温度，单位为摄氏度。您必须设计并实现一种方法，该方法能根据温度的物理单位和允许的测量误差来调整自适应步长控制器的容差 $\\epsilon_{\\text{abs}}$（绝对容差）和 $\\epsilon_{\\text{rel}}$（相对容差），然后用已知的精确解来验证该方法。\n\n推导必须从适用于 ODE 自适应步长控制的有效基础出发：常微分方程的定义、线性冷却模型精确解的存在性、嵌入式龙格－库塔方法中局部误差估计器的概念，以及将估计的局部误差与绝对容差和相对容差的组合进行比较的广泛使用的自适应误差接受准则。您不能假设任何捷径公式；相反，必须通过量纲分析和误差接受准则的结构来论证从物理测量极限到求解器容差的映射关系。\n\n任务要求：\n- 使用摄氏度作为温度单位，秒作为时间单位。任何测量误差限制都必须遵守：绝对误差以摄氏度为单位，相对误差以无量纲小数表示（例如，相对误差为 $\\delta$ 意味着误差必须以 $\\delta \\cdot |T|$ 为界，并且您必须将 $\\delta$ 写成小数形式，如 $0.002$，而不是百分比）。\n- 建立一个从允许的测量误差到求解器容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$ 的原则性映射，该映射需与单位一致，并考虑安全裕度，以确保求解器的数值误差在整个积分区间内严格低于允许的测量误差。\n- 使用带有嵌入式局部误差估计的方法，并采用您的方法所调整的容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$，对 ODE 从 $t = 0$ 到 $t = t_{\\text{end}}$ 进行自适应数值积分。\n- 使用精确解析解计算整个积分网格上的数值误差，并检查是否符合测量限制。精确解为 $T(t) = T_{\\infty} + (T(0) - T_{\\infty})\\, e^{-k t}$，该解由求解线性一阶 ODE 得出。\n- 对于每个测试用例，计算在积分区间内量 $q(t) = |T_{\\text{num}}(t) - T_{\\text{exact}}(t)| - \\left(A_{\\text{abs}} + R_{\\text{rel}}\\,|T_{\\text{exact}}(t)|\\right)$ 的最大值，其中 $A_{\\text{abs}}$ 是以摄氏度为单位的允许绝对测量误差，$R_{\\text{rel}}$ 是以小数表示的允许相对测量误差。报告一个布尔值，指示是否满足 $\\max_{t \\in [0, t_{\\text{end}}]} q(t) \\le 0$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，$[\\text{True},\\text{False},\\text{True}]$）。\n\n测试套件：\n- 用例 $1$ (理想情况)：$k = 0.05\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 20\\,^{\\circ}\\mathrm{C}$，$T(0) = 100\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 100\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.05\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.002$ (小数)，安全系数 $s = 0.1$ (小数)。\n- 用例 $2$ (快速冷却，小温差)：$k = 0.5\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 20\\,^{\\circ}\\mathrm{C}$，$T(0) = 25\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 10\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.01\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.001$ (小数)，安全系数 $s = 0.1$ (小数)。\n- 用例 $3$ (接近平衡，慢速冷却)：$k = 0.02\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 30\\,^{\\circ}\\mathrm{C}$，$T(0) = 31\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 60\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.02\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.002$ (小数)，安全系数 $s = 0.1$ (小数)。\n- 用例 $4$ (大动态范围)：$k = 0.2\\,\\mathrm{s}^{-1}$，$T_{\\infty} = 25\\,^{\\circ}\\mathrm{C}$，$T(0) = 1000\\,^{\\circ}\\mathrm{C}$，$t_{\\text{end}} = 30\\,\\mathrm{s}$，$A_{\\text{abs}} = 0.1\\,^{\\circ}\\mathrm{C}$，$R_{\\text{rel}} = 0.001$ (小数)，安全系数 $s = 0.1$ (小数)。\n\n输出规范：\n- 您的程序必须实现该方法，运行四个测试用例，并输出一行包含四个布尔值的列表 $[\\text{b}_{1},\\text{b}_{2},\\text{b}_{3},\\text{b}_{4}]$，其中当且仅当第 $i$ 个测试用例的数值解在所有 $t$ in $[0, t_{\\text{end}}]$ 上都满足 $|T_{\\text{num}}(t) - T_{\\text{exact}}(t)| \\le A_{\\text{abs}} + R_{\\text{rel}}\\,|T_{\\text{exact}}(t)|$ 时，$\\text{b}_{i}$ 为 $\\text{True}$，否则为 $\\text{False}$。$A_{\\text{abs}}$ 的单位是摄氏度，时间的单位是秒，$R_{\\text{rel}}$ 是无量纲的小数。", "solution": "该问题要求设计并验证一种方法，用以根据指定的物理测量误差容限 $A_{\\text{abs}}$ 和 $R_{\\text{rel}}$ 来设置自适应 ODE 求解器的容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$。其背景是线性热模型，由以下常微分方程（ODE）描述：\n$$\nT'(t) = -k(T(t) - T_{\\infty})\n$$\n其中 $T(t)$ 是时间 $t$ 时的温度，$k$ 是冷却系数，$T_{\\infty}$ 是环境温度。初始条件为 $T(0)$。这是一个标准的初值问题（IVP）。\n\n推导始于 ODE 数值方法中自适应步长控制的基本原理。一个自适应求解器，例如嵌入式龙格－库塔方法，会在每个积分步骤中估计局部误差 $E_{\\text{local}}$。这个估计的误差会与一个容差 $\\tau$ 进行比较，以决定是否接受该步骤并调整下一步的大小。标准的容差准则是绝对容差 $\\epsilon_{\\text{abs}}$ 和相对容差 $\\epsilon_{\\text{rel}}$ 的加权组合：\n$$\n\\text{criterion: } E_{\\text{local}} \\le \\tau = \\epsilon_{\\text{abs}} + \\epsilon_{\\text{rel}} |y_{\\text{current}}|\n$$\n其中 $|y_{\\text{current}}|$ 是步骤开始时数值解的大小。$\\epsilon_{\\text{abs}}$ 的单位必须与解变量的单位（本例中为摄氏度）相匹配，而 $\\epsilon_{\\text{rel}}$ 是一个无量纲的分数。\n\n问题的核心要求是确保*全局数值误差*，定义为 $E_{\\text{global}}(t) = |T_{\\text{num}}(t) - T_{\\text{exact}}(t)|$，在整个积分区间 $t \\in [0, t_{\\text{end}}]$ 内保持在一个具有物理意义的界限以下。这个界限由允许的测量误差定义：\n$$\nE_{\\text{global}}(t) \\le A_{\\text{abs}} + R_{\\text{rel}}|T_{\\text{exact}}(t)|\n$$\n这里，$A_{\\text{abs}}$ 是以摄氏度为单位的允许绝对误差，$R_{\\text{rel}}$ 是以无量纲小数形式给出的允许相对误差。\n\n必须做出一个关键的区分：自适应求解器控制的是每一步的*局部误差*，而不是在整个区间上累积的*全局误差*。全局误差是所有步骤局部误差的累积结果。对于一个稳定的问题，全局误差与局部误差相关，但通常更大。为了保证全局误差保持在其规定的界限内，必须更严格地控制局部误差。\n\n这引出了从物理容限 $(A_{\\text{abs}}, R_{\\text{rel}})$ 到求解器容差 $(\\epsilon_{\\text{abs}}, \\epsilon_{\\text{rel}})$ 的原则性映射。我们引入一个安全系数 $s$，其中 $0 < s < 1$。这个系数代表了我们分配给每一步局部误差控制的允许全局误差预算的比例。通过将求解器容差设置为物理容限的一小部分 $s$，我们创建了一个严格的局部误差目标，期望这些微小局部误差的累积不会超过更大的全局误差容限。\n\n求解器的容差公式与要求的全局误差界限之间的结构相似性，为分量缩放提供了依据。这在量纲上也是一致的。绝对容差 $\\epsilon_{\\text{abs}}$ 与允许的绝对误差 $A_{\\text{abs}}$ 具有相同的单位，而相对容差 $\\epsilon_{\\text{rel}}$ 与允许的相对误差 $R_{\\text{rel}}$ 一样，是无量纲的。因此，映射定义为：\n$$\n\\epsilon_{\\text{abs}} = s \\cdot A_{\\text{abs}}\n$$\n$$\n\\epsilon_{\\text{rel}} = s \\cdot R_{\\text{rel}}\n$$\n给定安全系数 $s = 0.1$，求解器将被指示维持一个比目标全局误差界限小十倍的局部误差。\n\n验证过程对每个测试用例包括以下步骤：\n$1$. 使用指定的 $A_{\\text{abs}}$、$R_{\\text{rel}}$ 和 $s$ 计算求解器容差 $\\epsilon_{\\text{abs}}$ 和 $\\epsilon_{\\text{rel}}$。\n$2$. 使用自适应求解器（例如 `scipy.integrate.solve_ivp`），并配置这些容差，对 ODE $T'(t) = -k(T - T_{\\infty})$ 在初始条件 $T(0)$ 下从 $t=0$ 到 $t=t_{\\text{end}}$ 进行数值积分。\n$3$. 在求解器返回的每个时间点 $t_i$，计算精确解：$T_{\\text{exact}}(t_i) = T_{\\infty} + (T(0) - T_{\\infty}) e^{-kt_i}$。\n$4$. 对于每个点，计算验证量：$q(t_i) = |T_{\\text{num}}(t_i) - T_{\\text{exact}}(t_i)| - (A_{\\text{abs}} + R_{\\text{rel}}|T_{\\text{exact}}(t_i)|)$。\n$5$. 确定在所有时间点上 $q(t)$ 的最大值。当且仅当 $\\max_i q(t_i) \\le 0$ 时，该方法对该用例是成功的。正值表示数值误差在某个点上超出了允许的物理误差界限。\n$6$. 报告每个用例的布尔结果。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# Make sure to use the specified versions:\n# numpy>=1.23.5\n# scipy>=1.11.4\n# Python>=3.12\n\ndef solve():\n    \"\"\"\n    Implements and validates a methodology for tuning adaptive ODE solver \n    tolerances based on physical measurement error limits.\n    \"\"\"\n    \n    test_cases = [\n        # Case 1: k, T_inf, T0, t_end, A_abs, R_rel, s\n        (0.05, 20.0, 100.0, 100.0, 0.05, 0.002, 0.1),\n        # Case 2\n        (0.5, 20.0, 25.0, 10.0, 0.01, 0.001, 0.1),\n        # Case 3\n        (0.02, 30.0, 31.0, 60.0, 0.02, 0.002, 0.1),\n        # Case 4\n        (0.2, 25.0, 1000.0, 30.0, 0.1, 0.001, 0.1),\n    ]\n\n    results = []\n\n    for case in test_cases:\n        k, T_inf, T0, t_end, A_abs, R_rel, s = case\n\n        # Step 1: Develop principled mapping from physical error to solver tolerances\n        # The solver's local error tolerances are set to be a fraction `s` of the\n        # global physical error allowances to provide a safety margin.\n        eps_abs = s * A_abs\n        eps_rel = s * R_rel\n\n        # Step 2: Define the ODE right-hand side function\n        def thermal_model(t, T):\n            return -k * (T - T_inf)\n\n        # Step 3: Implement adaptive numerical integration\n        # Use solve_ivp, which employs an adaptive step-size method (default 'RK45').\n        # dense_output=True is not strictly needed here as we check against the\n        # output grid, which is sufficient for this problem's validation.\n        sol = solve_ivp(\n            fun=thermal_model,\n            t_span=(0, t_end),\n            y0=[T0],\n            method='RK45',\n            rtol=eps_rel,\n            atol=eps_abs\n        )\n        \n        t_num = sol.t\n        T_num = sol.y[0]\n\n        # Step 4: Use the exact solution to compute numerical error and check compliance\n        def exact_solution(t, T0, T_inf, k):\n            return T_inf + (T0 - T_inf) * np.exp(-k * t)\n\n        T_exact_vals = exact_solution(t_num, T0, T_inf, k)\n\n        # Step 5: Compute the maximum of the validation quantity q(t)\n        # q(t) = |T_num(t) - T_exact(t)| - (A_abs + R_rel * |T_exact(t)|)\n        # The condition q(t) <= 0 must hold for all t.\n        \n        # Absolute numerical error at each time step\n        numerical_error = np.abs(T_num - T_exact_vals)\n        \n        # Allowable physical error bound at each time step\n        allowed_error = A_abs + R_rel * np.abs(T_exact_vals)\n        \n        # The quantity q(t) measures by how much the numerical error exceeds the allowance\n        q_values = numerical_error - allowed_error\n        \n        # Check if the maximum of q(t) is non-positive.\n        is_compliant = np.max(q_values) <= 0.0\n        \n        results.append(is_compliant)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3095862"}, {"introduction": "在数值计算领域，“最优”方法往往取决于具体问题。此项高级练习[@problem_id:3095889]引导你建立一个量化成本模型，用于比较低阶和高阶自适应方法在求解不同类型（刚性与非刚性）问题时的效率。通过模拟计算成本，你将深刻体会到在精度和计算量之间进行权衡的艺术，并理解为何选择合适的数值方法至关重要。", "problem": "您必须编写一个完整且可运行的程序，该程序从常微分方程 (ODE) 自适应步长控制的基本原理出发，构建一个简单的定量成本模型，用以在固定的绝对局部误差容限下，从两种显式嵌入式 Runge–Kutta (RK) 方法中进行选择。该模型必须通过显式模拟一个自适应控制器，并计算在固定时间区间内积分一个标量线性 ODE 所需的右端函数求值总数，来平衡每步的局部工作量与总步数。这两种方法必须在一个刚性线性测试方程和一个非刚性线性测试方程上进行评估。\n\n基本基础。仅使用以下基础：常微分方程 (ODE) 的定义 $y'(t)=f(t,y(t))$、对于一个 $p$ 阶方法其每步局部截断误差行为类似于 $O(h^{p+1})$ 的概念、以及显式 RK 方法在线性测试方程 $y'=-\\lambda y$ 上的绝对稳定性概念。对于自适应控制器，您必须从局部误差的渐近缩放推导出步长更新规则。对于刚性问题，您必须引入一个绝对稳定性约束，强制 $h \\le r/\\lambda$，其中 $r$ 是给定方法沿负实轴的稳定区间的大致长度。\n\n目标 ODE。考虑在有限时间范围 $t \\in [0,T]$ 上的标量线性 ODE $y'=-\\lambda y$，其中 $y(0)=1$：\n- 非刚性：$\\lambda=1$。\n- 刚性：$\\lambda=1000$。\n\n用于比较的嵌入式方法。实现两种显式嵌入式 RK 对，其绝对局部误差控制基于该对中高阶解与低阶解之间的差异。\n- 方法 A (低阶)：一个阶数为 $\\{2,1\\}$ 的嵌入式对，基于二阶 Heun 方法 (显式梯形法)，并使用一阶前向 Euler 方法作为嵌入式估计器。每次尝试步计算 $2$ 次右端函数求值。对于线性测试方程，使用沿负实轴的近似稳定半径 $r_A=2.0$。\n- 方法 B (高阶)：Cash–Karp $\\{5,4\\}$ 嵌入对，具有 $6$ 级。每次尝试步计算 $6$ 次右端函数求值。对于线性测试方程，使用沿负实轴的近似稳定半径 $r_B=2.8$。\n\n自适应控制器规范。对于每次大小为 $h$ 的尝试步，计算绝对局部误差估计 $e=\\lvert y_{\\text{high}}-y_{\\text{low}}\\rvert$。如果 $e \\le \\text{tol}$，则接受该步，否则拒绝。每次尝试后，通过以下公式提出新的步长：\n$$\nh_{\\text{new}} = h \\cdot \\mathrm{clip}\\Big(s \\cdot \\big(\\tfrac{\\text{tol}}{\\max(e,\\varepsilon)}\\big)^{1/p},\\, f_{\\min},\\, f_{\\max}\\Big),\n$$\n其中 $p$ 是嵌入式对中高阶成员的阶数 (方法 A 为 $p=2$，方法 B 为 $p=5$)，$s$ 是一个安全因子，$\\varepsilon$ 是一个非常小的正数以避免除以零，且 $\\mathrm{clip}(x,f_{\\min},f_{\\max})=\\min(\\max(x,f_{\\min}),f_{\\max})$。您必须对每个尝试步强制施加绝对稳定性上限 $h \\le 0.95\\, r/\\lambda$，并且最后一步不得超过 $T$。使用固定的控制器常数 $s=0.9$、$f_{\\min}=0.2$、$f_{\\max}=5.0$ 和 $\\varepsilon=10^{-30}$。以 $t=0$、$y=1$ 和一个同时满足稳定性上限和区间长度的正初始步长进行初始化；一个合理的选择是对应方法的 $h_0=\\min\\big(T,\\,0.1\\,\\text{tol}^{1/p},\\,0.8\\,r/\\lambda\\big)$。\n\n成本模型和决策规则。对于每次运行，成本是右端函数求值的总数，即尝试的步数 (接受或拒绝的) 乘以每步的求值次数 (方法 A 为 $2$ 次，方法 B 为 $6$ 次)。对于每个测试用例，选择总成本严格更小的方法。如果成本完全相等，则选择方法 A。\n\n角度单位和物理单位。不涉及物理单位或角度单位。所有量均为无量纲实数。\n\n测试套件。您的程序必须评估以下四组参数集：\n- 情况 1：$\\lambda=1$，$T=5$，$\\text{tol}=10^{-6}$ (非刚性，严格容限)。\n- 情况 2：$\\lambda=1$，$T=5$，$\\text{tol}=10^{-1}$ (非刚性，宽松容限)。\n- 情况 3：$\\lambda=1000$，$T=1$，$\\text{tol}=10^{-6}$ (刚性，严格容限)。\n- 情况 4：$\\lambda=1000$，$T=1$，$\\text{tol}=10^{-2}$ (刚性，中等容限)。\n\n要求的最终输出格式。您的程序应生成单行输出，其中包含四个情况的决策，按顺序以方括号括起来的逗号分隔列表形式呈现，其中每个条目是一个整数方法标识符：$0$ 代表方法 A (低阶)，$1$ 代表方法 B (高阶)。例如，一个有效的输出看起来像 $[1,0,0,0]$。", "solution": "问题陈述已经过严格评估，并被确定为有效。它在科学上基于常微分方程 (ODE) 数值分析的原理，问题良构，具有清晰和确定性的算法，并且自成体系，提供了所有必要的参数和定义。因此，我们可以着手进行求解。\n\n任务是构建一个成本模型，以决定在两种显式嵌入式 Runge-Kutta (RK) 方法之间如何选择来积分一个标量线性 ODE。该决策基于自适应步长控制器在固定区间内将 ODE 积分到指定容限所需的函数求值总数。必须对 ODE 的非刚性和刚性实例分别模拟此成本模型。\n\n### 1. 理论基础\n\n**ODE 与测试方程：**\n问题考虑的是标量线性测试方程，这是分析数值 ODE 求解器稳定性和准确性的一个基本模型：\n$$\ny'(t) = -\\lambda y(t), \\quad y(0) = 1, \\quad t \\in [0, T]\n$$\n其精确解为 $y(t) = e^{-\\lambda t}$。参数 $\\lambda > 0$ 决定了方程的刚性；大的 $\\lambda$ 对应于解快速衰减的刚性问题。\n\n**嵌入式 Runge-Kutta 方法：**\n一个嵌入式 RK 对在每一步提供两个解，一个为高阶 $p$ ($y_{\\text{high}}$)，一个为低阶 $q$ ($y_{\\text{low}}$)。这两个解之间的差异提供了对低阶方法的局部截断误差 (LTE) 的估计：\n$$\ne = |y_{\\text{high}} - y_{\\text{low}}|\n$$\n此误差估计用于控制步长 $h$。所考虑的两种方法是：\n- **方法 A**：一个 $\\{2,1\\}$ 对，使用二阶 Heun 方法 ($p=2$) 和一阶前向 Euler 方法 ($q=1$)。它每步需要 $2$ 次右端函数 $f(t,y)$ 的求值。其在负实轴上的稳定半径给定为 $r_A=2.0$。\n- **方法 B**：Cash-Karp $\\{5,4\\}$ 对 ($p=5$, $q=4$)。它每步需要 $6$ 次函数求值。其稳定半径给定为 $r_B=2.8$。\n\n**从基本原理进行误差估计：**\n对于一个应用于 $y'=-\\lambda y$ 的 $q$ 阶 RK 方法，从精确解上的点 $y_n$ 出发一步后的 LTE 约等于泰勒级数差中的第一个非零项。来自嵌入式对的误差估计 $e$ 就是为了近似这个 LTE 而设计的。\n$$\ne \\approx |\\text{LTE}_{q}| \\approx \\left| \\frac{d^{q+1}y}{dt^{q+1}} \\frac{h^{q+1}}{(q+1)!} \\right|\n$$\n对于 $y(t)=e^{-\\lambda t}$，其 $(q+1)$ 阶导数为 $y^{(q+1)}(t) = (-\\lambda)^{q+1} e^{-\\lambda t} = (-\\lambda)^{q+1} y(t)$。因此，误差估计可以表示为：\n$$\ne \\approx \\frac{(h\\lambda)^{q+1}}{(q+1)!} |y(t)|\n$$\n对于方法 A，$q=1$，误差估计为 $e \\approx \\frac{1}{2}(h\\lambda)^2 |y|$。对于方法 B，$q=4$，误差估计为 $e \\approx \\frac{1}{120}(h\\lambda)^5 |y|$。\n\n**状态传播：**\n当一步被接受时，数值解使用高阶近似向前推进。对于任何应用于 $y'=-\\lambda y$ 的显式 RK 方法，更新形式为 $y_{n+1} = R(-h\\lambda) y_n$，其中 $R(z)$ 是方法的稳定性函数。对于一个 $p$ 阶方法，$R(z)$ 是一个多项式，它与 $e^z$ 的泰勒级数在 $z^p$ 项之前都匹配：\n$$\nR_p(z) = \\sum_{k=0}^{p} \\frac{z^k}{k!}\n$$\n- 对于方法 A ($p=2$)：$y_{n+1} = y_n \\left(1 - h\\lambda + \\frac{1}{2}(h\\lambda)^2\\right)$。\n- 对于方法 B ($p=5$)：$y_{n+1} = y_n \\sum_{k=0}^{5} \\frac{(-h\\lambda)^k}{k!}$。\n\n### 2. 自适应控制算法\n\n自适应积分器的模拟从 $t=0$ 到 $T$ 迭代进行。\n\n**初始化：**\n- 模拟从 $t=0$ 开始，初始值为 $y=1$。\n- 初始步长 $h_0$ 被保守地选择，以同时满足积分区间 $T$、容限 $\\text{tol}$ 和方法的稳定性限制：\n$$\nh_0 = \\min\\left(T, 0.1 \\cdot \\text{tol}^{1/p}, 0.8 \\cdot \\frac{r}{\\lambda}\\right)\n$$\n其中 $p$ 是高阶方法的阶数，$r$ 是其稳定半径。\n\n**主循环：**\n在每次迭代中，对于一个建议的步长 $h$，执行以下步骤：\n1.  **步长约束：** 实际尝试的步长 $h_{\\text{current}}$ 受稳定性要求和剩余区间长度的限制：\n    $$\n    h_{\\text{current}} = \\min\\left(h, 0.95 \\frac{r}{\\lambda}, T-t\\right)\n    $$\n2.  **尝试步长并估计误差：** 函数求值总数增加。局部误差估计 $e$ 使用上面推导的公式计算。\n3.  **接受/拒绝：**\n    - 如果 $e \\le \\text{tol}$，该步被接受。时间和解 $t$ 和 $y$ 使用 $h_{\\text{current}}$ 和高阶更新规则向前推进。\n    - 如果 $e > \\text{tol}$，该步被拒绝。状态 $(t, y)$ 保持不变。\n4.  **提出下一步长：** 使用指定的控制器公式计算下一次尝试的新步长：\n    $$\n    h_{\\text{new}} = h_{\\text{current}} \\cdot \\mathrm{clip}\\left(s \\cdot \\left(\\frac{\\text{tol}}{\\max(e, \\varepsilon)}\\right)^{1/p}, f_{\\min}, f_{\\max}\\right)\n    $$\n    参数给定为安全因子 $s=0.9$、裁剪因子 $f_{\\min}=0.2$ 和 $f_{\\max}=5.0$ 以及一个小的正则化项 $\\varepsilon=10^{-30}$。阶数 $p$是该对中高阶方法的阶数。\n\n### 3. 成本模型与决策\n\n对于给定的方法和测试用例，总成本是在整个模拟过程中累积的函数求值总数。决策规则是选择成本严格更低的方法。如果成本相同，则选择方法 A。对问题陈述中指定的所有四个测试用例重复此过程。", "answer": "```python\nimport math\nimport numpy as np\n\ndef run_simulation(lambda_val, T, tol, p, q, evals_per_step, r):\n    \"\"\"\n    Simulates an adaptive step-size ODE solver to calculate the total cost.\n\n    Args:\n        lambda_val (float): The lambda parameter of the ODE y' = -lambda*y.\n        T (float): The final integration time.\n        tol (float): The absolute local error tolerance.\n        p (int): The order of the higher-order method in the embedded pair.\n        q (int): The order of the lower-order method in the embedded pair.\n        evals_per_step (int): The number of RHS evaluations per step.\n        r (float): The stability radius of the higher-order method.\n\n    Returns:\n        int: The total number of RHS evaluations (cost).\n    \"\"\"\n    # Controller constants\n    s = 0.9\n    f_min = 0.2\n    f_max = 5.0\n    epsilon = 1.0e-30\n\n    # Initial conditions\n    t = 0.0\n    y = 1.0\n    total_evals = 0\n\n    # Stability cap\n    h_stab_max = (0.95 * r / lambda_val) if lambda_val > 0 else float('inf')\n\n    # Initial step size h\n    h0_acc = 0.1 * (tol**(1.0/p))\n    h0_stab = (0.8 * r / lambda_val) if lambda_val > 0 else float('inf')\n    h = min(T, h0_acc, h0_stab)\n    \n    # Pre-calculate factorials for the stability function\n    factorials = [math.factorial(i) for i in range(p + 1)]\n    \n    q_factorial = math.factorial(q + 1)\n\n    while t < T:\n        # Guard against floating-point issues near the end of the interval\n        if T - t < 1e-14 * T:\n            break\n\n        # Apply stability and interval-end constraints to the step size\n        h_current = min(h, h_stab_max, T - t)\n        \n        # An attempt costs function evaluations regardless of acceptance\n        total_evals += evals_per_step\n\n        # Calculate error estimate based on first principles for y'=-lambda*y\n        # e ~ |y| * |(-h*lambda)^(q+1) / (q+1)!|\n        e = abs(y) * (h_current * lambda_val)**(q + 1) / q_factorial\n\n        # Accept or reject the step\n        if e <= tol:\n            # Step accepted: update time and solution\n            t += h_current\n            # Update y using the stability function R_p(z) of the higher-order method\n            z = -h_current * lambda_val\n            R_p_z = sum((z**k) / factorials[k] for k in range(p + 1))\n            y *= R_p_z\n        # If rejected, t and y do not change.\n\n        # Propose the next step size based on the current attempt\n        # Use a small number epsilon to avoid division by zero\n        ratio = tol / max(e, epsilon)\n        scale_factor = s * (ratio**(1.0/p))\n        \n        # Clip the scaling factor to prevent overly aggressive changes\n        clipped_scale_factor = min(max(scale_factor, f_min), f_max)\n        \n        h = h_current * clipped_scale_factor\n        \n    return total_evals\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and determine the optimal method for each case.\n    \"\"\"\n    test_cases = [\n        # (lambda, T, tol)\n        (1.0, 5.0, 1.0e-6),      # Case 1: Nonstiff, tight tolerance\n        (1.0, 5.0, 1.0e-1),      # Case 2: Nonstiff, loose tolerance\n        (1000.0, 1.0, 1.0e-6),   # Case 3: Stiff, tight tolerance\n        (1000.0, 1.0, 1.0e-2),   # Case 4: Stiff, moderate tolerance\n    ]\n\n    # Method A: Heun(2)/Euler(1) embedded pair\n    method_A_params = {'p': 2, 'q': 1, 'evals_per_step': 2, 'r': 2.0}\n    # Method B: Cash-Karp 5(4) embedded pair\n    method_B_params = {'p': 5, 'q': 4, 'evals_per_step': 6, 'r': 2.8}\n\n    results = []\n    for lambda_val, T, tol in test_cases:\n        cost_A = run_simulation(lambda_val, T, tol, **method_A_params)\n        cost_B = run_simulation(lambda_val, T, tol, **method_B_params)\n\n        # Decision rule: Choose method with strictly smaller cost.\n        # If costs are equal, choose Method A.\n        # 0 for Method A, 1 for Method B.\n        if cost_B < cost_A:\n            decision = 1\n        else:\n            decision = 0\n        results.append(decision)\n    \n    # Print the final output in the required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3095889"}]}