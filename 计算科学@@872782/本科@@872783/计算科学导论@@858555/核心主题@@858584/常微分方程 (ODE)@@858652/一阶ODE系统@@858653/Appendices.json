{"hands_on_practices": [{"introduction": "在物理学和工程学中，许多问题都由高阶微分方程描述。本练习将提供一项基本技能的动手实践：将一个描述梁振动的四阶常微分方程，转化为一个由四个一阶方程组成的方程组。通过数值求解这个边值问题，你将获得处理常见结构力学问题的实用技能。[@problem_id:2444880]", "problem": "考虑一根细长的等截面 Euler–Bernoulli 梁，在分布载荷作用下进行小振幅时谐横向振动。令 $x \\in [0,L]$ 表示沿梁的轴向坐标，$t$ 表示时间，$w(x,t)$ 表示横向挠度。假设对于分布载荷 $q(x,t) = \\Re\\{q(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$，其稳态谐波响应形式为 $w(x,t) = \\Re\\{Y(x)\\,\\mathrm{e}^{\\mathrm{i}\\,\\omega t}\\}$，其中 $Y(x)$ 和 $q(x)$ 是实值振幅，$\\omega$ 是角频率，单位为弧度/秒。忽略阻尼和转动惯量。在这些假设下，控制方程简化为关于 $x$ 的四阶常微分方程\n$$\nE I\\,\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) - \\rho A\\,\\omega^{2} Y(x) = q(x),\n$$\n其悬臂梁（在 $x=0$ 处固支，在 $x=L$ 处自由）的边界条件为\n$$\nY(0)=0,\\quad Y'(0)=0,\\quad Y''(L)=0,\\quad Y'''(L)=0.\n$$\n此处，$E$ 是杨氏模量，$I$ 是截面二次矩，$\\rho$ 是材料质量密度，$A$ 是横截面积，$L$ 是梁长。分布载荷的振幅指定为 $q(x) = q_{0}\\,\\sin\\!\\big(\\pi x/L\\big)$。\n\n任务：\n- 将关于 $x$ 的单个四阶常微分方程转换为一个等价的、由四个关于 $x$ 的耦合一阶常微分方程组成的方程组。\n- 对下述测试套件中的每一组参数，求解区间 $x \\in [0,L]$ 上关于 $Y(x)$ 的所得边值问题。\n- 对于每种情况，报告尖端挠度振幅 $Y(L)$。\n\n所有输入参数均使用国际单位制（SI）。报告所有尖端挠度振幅，单位为米，使用科学记数法并四舍五入到小数点后六位。\n\n测试套件：\n- 情况 1（一般情况）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 100.0\\,\\mathrm{N/m}$，$\\omega = 50.0\\,\\mathrm{rad/s}$。\n- 情况 2（零载荷边缘情况）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 1.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 0.0\\,\\mathrm{N/m}$，$\\omega = 50.0\\,\\mathrm{rad/s}$。\n- 情况 3（准静态状态）：$E = 70\\times 10^{9}\\,\\mathrm{Pa}$，$I = 5.0\\times 10^{-6}\\,\\mathrm{m}^{4}$，$\\rho = 2700\\,\\mathrm{kg/m^{3}}$，$A = 2.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 1.0\\,\\mathrm{m}$，$q_{0} = 1000.0\\,\\mathrm{N/m}$，$\\omega = 0.01\\,\\mathrm{rad/s}$。\n- 情况 4（刚性梁）：$E = 210\\times 10^{9}\\,\\mathrm{Pa}$，$I = 5.0\\times 10^{-5}\\,\\mathrm{m}^{4}$，$\\rho = 7800\\,\\mathrm{kg/m^{3}}$，$A = 1.0\\times 10^{-3}\\,\\mathrm{m}^{2}$，$L = 2.0\\,\\mathrm{m}$，$q_{0} = 100.0\\,\\mathrm{N/m}$，$\\omega = 20.0\\,\\mathrm{rad/s}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含四个尖端挠度振幅，形式为逗号分隔的列表，并用方括号括起来，例如，“[v1,v2,v3,v4]”。\n- 对每个条目使用科学记数法，小数点后精确到六位，且无空格，例如，“[1.234567e-03,0.000000e+00, ...]”。\n- 数值单位必须是米。", "solution": "对用户提供的问题陈述进行验证。\n\n### 步骤 1：提取已知条件\n- **控制方程**：Euler–Bernoulli 梁横向振动的稳态振幅 $Y(x)$ 由以下四阶常微分方程（ODE）控制：\n$$\nE I\\,\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) - \\rho A\\,\\omega^{2} Y(x) = q(x)\n$$\n- **定义域**：轴向坐标 $x$ 在区间 $[0,L]$ 内。\n- **边界条件（悬臂梁）**：\n  - 在 $x=0$ 处固支：$Y(0)=0$, $Y'(0)=0$。\n  - 在 $x=L$ 处自由：$Y''(L)=0$, $Y'''(L)=0$。\n- **分布载荷**：分布载荷的振幅为 $q(x) = q_{0}\\,\\sin(\\pi x/L)$。\n- **常数**：\n  - $E$：杨氏模量\n  - $I$：截面二次矩\n  - $\\rho$：材料质量密度\n  - $A$：横截面积\n  - $L$：梁长\n  - $q_{0}$：载荷大小\n  - $\\omega$：角频率\n- **任务**：\n  1. 将四阶 ODE 转换为一个由四个耦合一阶 ODE 组成的系统。\n  2. 对四组不同的参数集，求解得到的关于 $Y(x)$ 的边值问题（BVP）。\n  3. 报告每种情况下梁尖端的挠度振幅 $Y(L)$。\n- **测试套件（国际单位制）**：\n  - 情况 1：$E = 210 \\times 10^{9}$, $I = 1.0 \\times 10^{-6}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 100.0$, $\\omega = 50.0$。\n  - 情况 2：$E = 210 \\times 10^{9}$, $I = 1.0 \\times 10^{-6}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 0.0$, $\\omega = 50.0$。\n  - 情况 3：$E = 70 \\times 10^{9}$, $I = 5.0 \\times 10^{-6}$, $\\rho = 2700$, $A = 2.0 \\times 10^{-3}$, $L = 1.0$, $q_{0} = 1000.0$, $\\omega = 0.01$。\n  - 情况 4：$E = 210 \\times 10^{9}$, $I = 5.0 \\times 10^{-5}$, $\\rho = 7800$, $A = 1.0 \\times 10^{-3}$, $L = 2.0$, $q_{0} = 100.0$, $\\omega = 20.0$。\n\n### 步骤 2：使用提取的已知条件进行验证\n根据既定标准对问题进行评估。\n- **有科学依据**：控制方程是公认的 Euler-Bernoulli 梁方程，用于描述受迫无阻尼振动。所有概念和参数（$E, I, \\rho, A, L, \\omega, q_0$）都是经典力学和结构工程中的标准参数。该问题在科学上是合理的。\n- **适定性**：该问题是一个线性四阶 ODE 的两点边值问题。边界条件是悬臂梁的标准边界条件，足以确保唯一解的存在，前提是驱动频率 $\\omega$ 不是梁的固有频率之一（否则会在该无阻尼模型中引起共振）。在情况 2 中，载荷为零，在非固有频率下考虑齐次问题，正确地导出一个平凡解。该问题是适定的。\n- **客观性**：问题陈述使用了精确的数学和物理语言。任务是具体的、定量的。该问题是客观的。\n- **完整性**：解决问题所需的所有必要参数、方程和边界条件均已提供。\n- **相关性**：该任务涉及将一个高阶 ODE 转换为一个一阶 ODE 系统并进行数值求解，这是计算物理学中的一个典型问题。\n\n### 步骤 3：结论与行动\n该问题在科学上是合理的、适定的、客观的且完整的。这是一个有效的问题，可以为其构建解决方案。\n\n### 求解推导\n\n第一步是将单个四阶 ODE 转换为一个等效的、由四个一阶 ODE 组成的系统。这是一种标准技术。我们定义一个包含四个分量的状态向量 $\\mathbf{y}(x)$：\n\\begin{align*}\n    y_1(x) = Y(x)   \\text{(挠度)} \\\\\n    y_2(x) = Y'(x)   \\text{(转角)} \\\\\n    y_3(x) = Y''(x)   \\text{(与弯矩成正比, } M=EIY'') \\\\\n    y_4(x) = Y'''(x)   \\text{(与剪力成正比, } V=EIY''')\n\\end{align*}\n通过对每个分量关于 $x$ 求导，我们可以用状态向量分量本身来表示它们的导数：\n\\begin{align*}\n    y_1'(x) = y_2(x) \\\\\n    y_2'(x) = y_3(x) \\\\\n    y_3'(x) = y_4(x)\n\\end{align*}\n第四个分量的导数 $y_4'(x) = Y''''(x)$ 可以通过整理控制 ODE 得到：\n$$\n\\frac{\\mathrm{d}^{4} Y}{\\mathrm{d} x^{4}}(x) = \\frac{\\rho A \\omega^2}{EI} Y(x) + \\frac{q(x)}{EI}\n$$\n代入状态向量分量和给定的载荷函数 $q(x) = q_0\\sin(\\pi x/L)$：\n$$\ny_4'(x) = \\frac{\\rho A \\omega^2}{EI} y_1(x) + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n$$\n这就构成了一个线性一阶 ODE 系统，可以写成矩阵形式 $\\mathbf{y}'(x) = \\mathbf{F}(x, \\mathbf{y}(x))$：\n$$\n\\frac{d}{dx}\n\\begin{pmatrix}\ny_1 \\\\\ny_2 \\\\\ny_3 \\\\\ny_4\n\\end{pmatrix}\n=\n\\begin{pmatrix}\ny_2 \\\\\ny_3 \\\\\ny_4 \\\\\n\\frac{\\rho A \\omega^2}{EI} y_1 + \\frac{q_0}{EI} \\sin\\left(\\frac{\\pi x}{L}\\right)\n\\end{pmatrix}\n$$\n该系统必须在满足边界条件的情况下求解。用状态向量表示，悬臂梁的条件是：\n-   在固支端，$x=0$：\n    -   $Y(0) = 0 \\implies y_1(0) = 0$\n    -   $Y'(0) = 0 \\implies y_2(0) = 0$\n-   在自由端，$x=L$：\n    -   $Y''(L) = 0 \\implies y_3(L) = 0$\n    -   $Y'''(L) = 0 \\implies y_4(L) = 0$\n\n这构成了一个两点边值问题（BVP）。我们将使用合适的算法对此 BVP 进行数值求解。SciPy 库中的 `scipy.integrate.solve_bvp` 函数是一个合适的工具。它实现了一种配置法，对于此类问题既高效又准确。\n\n数值计算步骤如下：\n1.  定义一个 Python 函数来表示 ODE 系统，该函数以 $x$ 和 $\\mathbf{y}$ 为输入，返回 $\\mathbf{y}'$。此函数还需要问题的物理参数。\n2.  为边界条件定义一个 Python 函数，该函数计算四个条件的残差：$[y_1(0), y_2(0), y_3(L), y_4(L)]$。对于一个有效解，这些残差必须为零。\n3.  为定义域 $[0,L]$ 创建一个初始点网格。一个均匀网格就足够了。\n4.  在此网格上为解 $\\mathbf{y}(x)$ 提供一个初始猜测。将所有分量猜测为零是一个合理的起点。\n5.  使用 ODE 函数、边界条件函数、初始网格和初始猜测值调用 `scipy.integrate.solve_bvp`。\n6.  求解器会迭代地优化解，直到满足边界条件并且 ODE 在指定的容差范围内求解。\n7.  找到解后，可以从得到的解对象中评估梁尖端的挠度值 $Y(L) = y_1(L)$。\n\n对问题陈述中提供的四个测试用例重复此过程。每个用例的最终结果都按要求格式化。", "answer": "```python\nimport numpy as np\nfrom scipy.integrate import solve_bvp\n\ndef solve():\n    \"\"\"\n    Solves the Euler-Bernoulli beam BVP for four test cases.\n    \"\"\"\n\n    test_cases = [\n        # Case 1 (general)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 50.0\n        },\n        # Case 2 (zero load edge case)\n        {\n            \"E\": 210.0e9, \"I\": 1.0e-6, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 0.0, \"omega\": 50.0\n        },\n        # Case 3 (quasi-static regime)\n        {\n            \"E\": 70.0e9, \"I\": 5.0e-6, \"rho\": 2700.0, \"A\": 2.0e-3,\n            \"L\": 1.0, \"q0\": 1000.0, \"omega\": 0.01\n        },\n        # Case 4 (stiff beam)\n        {\n            \"E\": 210.0e9, \"I\": 5.0e-5, \"rho\": 7800.0, \"A\": 1.0e-3,\n            \"L\": 2.0, \"q0\": 100.0, \"omega\": 20.0\n        }\n    ]\n\n    def ode_system(x, y, p):\n        \"\"\"\n        Defines the system of 4 first-order ODEs.\n        y is a vector [y1, y2, y3, y4]\n        y1 = Y, y2 = Y', y3 = Y'', y4 = Y'''\n        p is a tuple of parameters (E, I, rho, A, L, q0, omega)\n        \"\"\"\n        E, I, rho, A, L, q0, omega = p\n        \n        dy1_dx = y[1]\n        dy2_dx = y[2]\n        dy3_dx = y[3]\n\n        q_x = q0 * np.sin(np.pi * x / L)\n        \n        # From EI Y'''' - rho*A*omega^2*Y = q(x)\n        dy4_dx = (rho * A * omega**2 * y[0] + q_x) / (E * I)\n\n        return np.vstack((dy1_dx, dy2_dx, dy3_dx, dy4_dx))\n\n    def boundary_conditions(ya, yb, p):\n        \"\"\"\n        Defines the boundary conditions for the cantilever beam.\n        ya: solution at x=0\n        yb: solution at x=L\n        BCs: Y(0)=0, Y'(0)=0, Y''(L)=0, Y'''(L)=0\n        In state vector terms: y1(0)=0, y2(0)=0, y3(L)=0, y4(L)=0\n        \"\"\"\n        return np.array([ya[0], ya[1], yb[2], yb[3]])\n\n    results = []\n\n    for case in test_cases:\n        p = (\n            case[\"E\"], case[\"I\"], case[\"rho\"], case[\"A\"],\n            case[\"L\"], case[\"q0\"], case[\"omega\"]\n        )\n        L = case[\"L\"]\n\n        # Set up the initial mesh and guess for the solution\n        x_mesh = np.linspace(0, L, 201)  # 201 points for good resolution\n        y_guess = np.zeros((4, x_mesh.size))\n\n        # Solve the boundary value problem\n        sol = solve_bvp(\n            lambda x, y: ode_system(x, y, p),\n            lambda ya, yb: boundary_conditions(ya, yb, p),\n            x_mesh,\n            y_guess,\n            tol=1e-8\n        )\n        \n        # As a check, for q0=0 and omega != natural frequency, solution must be trivial\n        if case[\"q0\"] == 0.0:\n            tip_deflection = 0.0\n        else:\n            if sol.success:\n                # Evaluate the solution at the tip of the beam (x=L)\n                # sol.sol(L)[0] corresponds to y1(L) = Y(L)\n                tip_deflection = sol.sol(L)[0]\n            else:\n                # This should not happen for the given test cases\n                tip_deflection = np.nan\n\n        # Format the result to scientific notation with 6 decimal places\n        results.append(f\"{tip_deflection:.6e}\")\n    \n    # Print the final result in the specified format\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "2444880"}, {"introduction": "求解常微分方程组只是第一步，理解解的准确性同等重要，尤其是在处理敏感系统时。本练习将深入探讨数值积分的核心，通过在著名的混沌洛伦兹系统上，比较简单的一阶欧拉法和更稳健的四阶龙格－库塔（RK4）法。你将直接观察到不同方法如何累积误差，并理解为何高阶方法对于可靠的科学模拟是不可或缺的。[@problem_id:2444905]", "problem": "考虑一个一阶耦合常微分方程组的初值问题，该问题由向量场 $\\mathbf{f}(\\mathbf{x}, t)$ 定义为 $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$，并带有初始条件 $\\mathbf{x}(0) = \\mathbf{x}_0$。洛伦兹系统是一个典型的混沌流，由以下三维系统给出：\n$$\n\\frac{dx}{dt} = \\sigma (y - x), \\quad\n\\frac{dy}{dt} = x (\\rho - z) - y, \\quad\n\\frac{dz}{dt} = x y - \\beta z,\n$$\n参数为 $\\sigma = 10$，$\\rho = 28$ 和 $\\beta = 8/3$，初始条件为 $\\mathbf{x}_0 = (1, 1, 1)$。本问题中所有量均为无量纲，因此不需要物理单位。\n\n仅从初值问题、数值时间步进以及由对初始条件的敏感依赖性所表征的确定性混沌概念出发，为 $\\dfrac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t)$ 实现两种显式时间积分器：\n- 显式欧拉法，以及\n- 经典四阶龙格-库塔法。\n\n对于每个积分器，在步长为 $\\Delta t$ 的均匀时间网格上，在一个有限时间域 $[0, T]$ 内推进洛伦兹系统。为量化混沌系统中由离散化引起的数值误差增长，需定义一个高精度参考轨迹 $\\mathbf{x}_{\\text{ref}}(t)$，该轨迹由一个具有严格容差的自适应显式方法计算得出，并在相同的均匀时间网格上进行求值。在每个网格时间 $t_n$，将瞬时误差定义为欧几里得范数 $e_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2$。对于给定的阈值 $\\varepsilon  0$，将首次穿越阈值时间 $t_{\\text{cross}}$ 定义为使得 $e_n \\ge \\varepsilon$ 成立的最小网格时间 $t_n$。如果在 $[0, T]$ 上不存在这样的索引，则定义 $t_{\\text{cross}} = T$。\n\n您的程序必须：\n- 根据其算法定义实现显式欧拉法和经典四阶龙格-库塔法；\n- 以严格的误差容差计算高精度参考解，并在均匀网格上进行插值或精确求值；\n- 对于下方的每个测试用例，计算两个穿越阈值时间，一个用于显式欧拉法，一个用于经典四阶龙格-库塔法，每个测试用例使用相同的网格和参考解。\n\n测试套件规范：\n- 系统：洛伦兹系统，参数为 $\\sigma = 10$，$\\rho = 28$，$\\beta = 8/3$，初始条件 $\\mathbf{x}_0 = (1, 1, 1)$，在步长为 $\\Delta t$ 的均匀网格上从 $t = 0$ 积分到 $t = T$。\n- 高精度参考：自适应显式方法，相对容差 $\\mathrm{rtol} = 10^{-12}$，绝对容差 $\\mathrm{atol} = 10^{-12}$，在被测方法所使用的均匀网格上求值。\n- 阈值定义：欧几里得范数阈值 $\\varepsilon$，按各用例指定。\n\n为以下四个测试用例提供结果，每个用例由 $(\\Delta t, T, \\varepsilon)$ 标识：\n- 用例 1：$(0.001, 20.0, 0.01)$\n- 用例 2：$(0.002, 20.0, 0.01)$\n- 用例 3：$(0.005, 20.0, 0.01)$\n- 用例 4：$(0.001, 5.0, 1.0)$\n\n对于每个用例，计算并报告两个浮点数：显式欧拉法的 $t_{\\text{cross}}$，后跟经典四阶龙格-库塔法的 $t_{\\text{cross}}$，两者均使用与 $t$ 相同的时间单位，并表示为普通十进制数。如果未发生穿越，则对该方法和用例返回 $T$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按以下顺序排列：\n$[t_{\\text{cross}}^{\\text{Euler},1}, t_{\\text{cross}}^{\\text{RK4},1}, t_{\\text{cross}}^{\\text{Euler},2}, t_{\\text{cross}}^{\\text{RK4},2}, t_{\\text{cross}}^{\\text{Euler},3}, t_{\\text{cross}}^{\\text{RK4},3}, t_{\\text{cross}}^{\\text{Euler},4}, t_{\\text{cross}}^{\\text{RK4},4}]$。\n唯一允许的输出是此单行，且格式必须完全符合规定。不应打印任何额外文本。", "solution": "该问题要求实现并比较两种用于常微分方程（ODEs）的基本数值积分器：显式欧拉法和经典四阶龙格-库塔（RK4）法。本次数值实验的对象是洛伦兹系统，一个确定性混沌的典型例子。我们的目标是，对于每种积分器和一组给定的参数，确定数值解的轨迹与高精度参考轨迹的偏差达到指定误差阈值 $\\varepsilon$ 的时间。\n\n该问题被表述为一个一阶耦合常微分方程组的初值问题（IVP），其通用形式为：\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{f}(\\mathbf{x}, t), \\quad \\mathbf{x}(t_0) = \\mathbf{x}_0\n$$\n对于本问题，状态向量为 $\\mathbf{x}(t) = [x(t), y(t), z(t)]^T$，向量场 $\\mathbf{f}(\\mathbf{x}, t)$ 由洛伦兹方程给出：\n$$\n\\mathbf{f}(\\mathbf{x}) = \\begin{pmatrix} \\sigma (y - x) \\\\ x (\\rho - z) - y \\\\ xy - \\beta z \\end{pmatrix}\n$$\n该系统是自治的，因此 $\\mathbf{f}$ 不显式依赖于 $t$。参数被固定在其经典的混沌值：$\\sigma = 10$，$\\rho = 28$ 和 $\\beta = 8/3$。初始条件为 $\\mathbf{x}(0) = \\mathbf{x}_0 = [1, 1, 1]^T$。\n\n数值积分方法在离散时间网格 $t_n = n \\Delta t$ 上逼近连续解 $\\mathbf{x}(t)$，其中 $\\Delta t$ 是时间步长。\n\n首先，我们考虑显式欧拉法。这是一种一阶方法，源于对导数的简单前向差分近似。将解从时间 $t_n$ 推进到 $t_{n+1} = t_n + \\Delta t$ 的更新规则是：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\Delta t \\cdot \\mathbf{f}(\\mathbf{x}_n)\n$$\n其中 $\\mathbf{x}_n$ 是 $\\mathbf{x}(t_n)$ 的数值近似。该方法实现简单，但精度低（局部截断误差为 $\\mathcal{O}(\\Delta t^2)$ 阶），且稳定性有限。\n\n其次，我们实现经典四阶龙格-库塔（RK4）法。这是一种更复杂的单步法，通过在时间步内的几个中间点上计算向量场 $\\mathbf{f}$ 来获得更高的精度。其更新规则由下式给出：\n$$\n\\mathbf{x}_{n+1} = \\mathbf{x}_n + \\frac{\\Delta t}{6} (\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间阶段为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = \\mathbf{f}(\\mathbf{x}_n) \\\\\n\\mathbf{k}_2 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = \\mathbf{f}(\\mathbf{x}_n + \\frac{\\Delta t}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = \\mathbf{f}(\\mathbf{x}_n + \\Delta t \\cdot \\mathbf{k}_3)\n\\end{aligned}\n$$\nRK4 方法的局部截断误差为 $\\mathcal{O}(\\Delta t^5)$ 阶，这使得它在相同步长 $\\Delta t$ 下比欧拉法精确得多。\n\n为了量化这些固定步长方法的误差，我们必须首先计算一个高精度参考解 $\\mathbf{x}_{\\text{ref}}(t)$。这是通过使用一个自适应步长积分器实现的，具体而言是 `scipy.integrate` 库中的 `solve_ivp` 函数，并为其配置了非常严格的相对和绝对误差容差（$\\mathrm{rtol} = 10^{-12}$，$\\mathrm{atol} = 10^{-12}$）。我们指示该求解器在我们固定步长方法将要使用的相同均匀时间网格 $\\{t_n\\}$ 上评估参考解。\n\n有了来自欧拉法或 RK4 法的数值解 $\\mathbf{x}_{\\text{num}}(t_n)$ 以及参考解 $\\mathbf{x}_{\\text{ref}}(t_n)$，每个时间步的瞬时误差定义为它们之间差值的欧几里得范数：\n$$\ne_n = \\lVert \\mathbf{x}_{\\text{num}}(t_n) - \\mathbf{x}_{\\text{ref}}(t_n) \\rVert_2\n$$\n我们主要关注的量是穿越阈值时间 $t_{\\text{cross}}$，定义为网格中误差 $e_n$ 首次达到或超过给定阈值 $\\varepsilon$ 的时间 $t_n$。\n$$\nt_{\\text{cross}} = \\min \\{ t_n \\mid e_n \\ge \\varepsilon, n  0 \\}\n$$\n如果在整个积分区间 $[0, T]$ 内误差始终未达到阈值，则 $t_{\\text{cross}}$ 取为 $T$。\n\n计算流程如下：对于每个由 $(\\Delta t, T, \\varepsilon)$ 定义的测试用例：\n1.  构建从 $t=0$ 到 $t=T$、步长为 $\\Delta t$ 的均匀时间网格 $\\{t_n\\}$。\n2.  计算并存储所有网格点上的参考解 $\\mathbf{x}_{\\text{ref}}(t_n)$。\n3.  使用显式欧拉法模拟系统。在每一步 $n$，计算 $\\mathbf{x}_{\\text{Euler}}(t_{n+1})$，计算其与 $\\mathbf{x}_{\\text{ref}}(t_{n+1})$ 的误差 $e_{n+1}$，并检查是否有 $e_{n+1} \\ge \\varepsilon$。满足此条件的第一个 $t_{n+1}$ 被记录为 $t_{\\text{cross}}^{\\text{Euler}}$。如果循环结束，则 $t_{\\text{cross}}^{\\text{Euler}} = T$。\n4.  对 RK4 方法独立重复此过程，以找到 $t_{\\text{cross}}^{\\text{RK4}}$。\n\n整个过程都封装在所提供的 Python 代码中，该代码会遍历指定的测试用例，并按要求的格式报告所得的穿越阈值时间。结果将展示 RK4 方法的卓越精度，因为它与欧拉法相比，能在更长的时间内保持较小的误差，同时结果也将显示误差增长对步长 $\\Delta t$ 的敏感性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.integrate import solve_ivp\n\n# from scipy import ...\n\ndef solve():\n    \"\"\"\n    Solves the Lorenz system problem as specified.\n\n    This function implements the explicit Euler and classical RK4 methods to\n    integrate the Lorenz system. It compares their solutions against a\n    high-accuracy reference solution to find the time at which the numerical\n    error first exceeds a given threshold. This is performed for several\n    test cases.\n    \"\"\"\n\n    # Define the Lorenz system of ODEs\n    def lorenz(t, x, sigma, rho, beta):\n        \"\"\"\n        The vector field for the Lorenz system.\n        The 't' argument is required by scipy.integrate.solve_ivp.\n        \"\"\"\n        dxdt = sigma * (x[1] - x[0])\n        dydt = x[0] * (rho - x[2]) - x[1]\n        dzdt = x[0] * x[1] - beta * x[2]\n        return np.array([dxdt, dydt, dzdt])\n\n    # System parameters and initial condition\n    sigma = 10.0\n    rho = 28.0\n    beta = 8.0 / 3.0\n    x0 = np.array([1.0, 1.0, 1.0])\n    lorenz_params = (sigma, rho, beta)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (delta_t, T, epsilon)\n        (0.001, 20.0, 0.01),\n        (0.002, 20.0, 0.01),\n        (0.005, 20.0, 0.01),\n        (0.001, 5.0, 1.0),\n    ]\n\n    results = []\n    for dt, T, epsilon in test_cases:\n        # 1. Setup time grid\n        # Use round to prevent floating point inaccuracies in calculating num_steps\n        num_steps = int(round(T / dt))\n        t_points = np.linspace(0, T, num_steps + 1)\n\n        # 2. Compute high-accuracy reference solution\n        ref_sol = solve_ivp(\n            fun=lorenz,\n            t_span=(0, T),\n            y0=x0,\n            method='RK45',\n            t_eval=t_points,\n            rtol=1e-12,\n            atol=1e-12,\n            args=lorenz_params\n        )\n        x_ref = ref_sol.y.T  # Transpose to shape (num_steps+1, 3)\n\n        # 3. Compute t_cross for Explicit Euler\n        x_euler = np.zeros_like(x_ref)\n        x_euler[0] = x0\n        t_cross_euler = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_euler[n]\n            # Euler step\n            x_euler[n + 1] = x_n + dt * lorenz(t_n, x_n, *lorenz_params)\n\n            # Check error against reference\n            error = np.linalg.norm(x_euler[n + 1] - x_ref[n + 1])\n            if error = epsilon:\n                t_cross_euler = t_points[n + 1]\n                break\n        results.append(t_cross_euler)\n\n        # 4. Compute t_cross for Fourth-Order Runge-Kutta (RK4)\n        x_rk4 = np.zeros_like(x_ref)\n        x_rk4[0] = x0\n        t_cross_rk4 = T\n        for n in range(num_steps):\n            t_n = t_points[n]\n            x_n = x_rk4[n]\n            # RK4 stages\n            k1 = lorenz(t_n, x_n, *lorenz_params)\n            k2 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k1, *lorenz_params)\n            k3 = lorenz(t_n + dt / 2.0, x_n + dt / 2.0 * k2, *lorenz_params)\n            k4 = lorenz(t_n + dt, x_n + dt * k3, *lorenz_params)\n            # RK4 step\n            x_rk4[n + 1] = x_n + (dt / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check error against reference\n            error = np.linalg.norm(x_rk4[n + 1] - x_ref[n + 1])\n            if error = epsilon:\n                t_cross_rk4 = t_points[n + 1]\n                break\n        results.append(t_cross_rk4)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2444905"}, {"introduction": "真实世界的模拟常常涉及约束条件，这可能导致数值上的“刚性”系统，对标准积分器构成挑战。本练习探讨了罚函数法，这是一种通过有意引入刚性来近似约束的技术。通过实现一个 RK4 求解器，你将研究约束执行与数值稳定性之间的权衡，从而对计算科学中的一个主要障碍获得关键的洞察。[@problem_id:3199683]", "problem": "考虑一个平面力学系统，该系统被建模为一个质点，受限于一个理想情况下会将其运动约束在一个圆周上的完整约束。我们不精确地施加该约束，而是使用一个罚函数势来近似它，该势函数会对偏离约束的情况进行惩罚。该系统必须严格地表述和模拟为一个一阶常微分方程（ODE）组，并且数值实验必须评估增加罚刚度如何影响积分器的稳定性和约束违反的量级。\n\n基本原理与建模。从牛顿第二定律开始，该定律指出总力等于质量乘以加速度，即 $m \\,\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$，其中 $\\mathbf{q}(t) = [x(t), y(t)]^\\top$ 是位置向量，$m$ 是质量。设完整约束为由 $g(\\mathbf{q}) = x^2 + y^2 - R^2 = 0$ 定义的圆。使用罚函数势 $U(\\mathbf{q}) = \\frac{k}{2}\\, g(\\mathbf{q})^2$ 来近似此约束，其中 $k$ 是罚刚度。由此势产生的保守力由 $\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$ 给出。通过引入速度 $\\mathbf{v}(t) = \\dot{\\mathbf{q}}(t) = [v_x(t), v_y(t)]^\\top$ 并定义状态向量 $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$，将得到的二阶常微分方程转换为一阶常微分方程组。\n\n初始条件与单位。使用 $m = 1\\,\\mathrm{kg}$，$R = 1\\,\\mathrm{m}$，以及初始条件 $x(0) = R$，$y(0) = 0$，$v_x(0) = 0$，$v_y(0) = v_0$，$v_0 = 1\\,\\mathrm{m/s}$。所有位置必须以 $\\mathrm{m}$ 为单位，速度以 $\\mathrm{m/s}$ 为单位，时间以 $\\mathrm{s}$ 为单位，罚刚度 $k$ 以 $\\mathrm{N/m^3}$ 为单位。\n\n积分器与模拟协议。实现一个显式定步长四阶龙格－库塔方法（RK4）来对一阶常微分方程组进行积分。使用恒定的时间步长 $h = 0.005\\,\\mathrm{s}$，在总时间 $T = 5.0\\,\\mathrm{s}$ 内进行模拟。在每个时间步长，计算瞬时约束违反量，即径向偏差 $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$（单位为 $\\mathrm{m}$），并追踪整个模拟过程中的最大值。\n\n稳定性判据。为此测试目的，将积分器的数值稳定性定义如下：当且仅当在整个 $t \\in [0,T]$ 区间内，状态保持有限且有界，即 $\\mathbf{z}(t)$ 的所有分量都是有限的且 $\\lVert \\mathbf{z}(t) \\rVert_2  M_{\\mathrm{th}}$（其中 $M_{\\mathrm{th}} = 10^3$），则模拟是稳定的；否则为不稳定。如果检测到不稳定性，应立即停止该情况下的模拟。\n\n测试套件。针对以下罚刚度值模拟该系统：\n- 情况 1：$k = 100\\,\\mathrm{N/m^3}$（理想情况，相对较软的惩罚）\n- 情况 2：$k = 1{,}000\\,\\mathrm{N/m^3}$（中等惩罚）\n- 情况 3：$k = 10{,}000\\,\\mathrm{N/m^3}$（刚性惩罚）\n- 情况 4：$k = 50{,}000\\,\\mathrm{N/m^3}$（非常刚性，接近定步长显式积分器的稳定性边界）\n\n要求输出。对于每种情况，计算：\n- 最大约束违反量 $\\max_{t \\in [0,T]} \\delta r(t)$，表示为以 $\\mathrm{m}$ 为单位的浮点数。\n- 稳定性标志，一个布尔值，指示模拟是否根据所述判据保持稳定。\n\n最终输出格式。您的程序应生成单行输出，其中包含四种情况的结果，形式为方括号内以逗号分隔的列表，按顺序交错排列每种情况的最大违反量和稳定性标志：$[\\delta r_1, s_1, \\delta r_2, s_2, \\delta r_3, s_3, \\delta r_4, s_4]$，其中每个 $\\delta r_i$ 是以 $\\mathrm{m}$ 为单位的浮点数，每个 $s_i$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题要求对一个平面力学系统进行公式化和数值模拟，其中一个圆形的完整约束通过罚函数法进行近似。问题的核心在于将主控的二阶微分方程转换为一阶常微分方程（ODE）组，并对其进行数值积分，以研究罚刚度参数的影响。\n\n首先，我们建立物理模型。该系统是一个质量为 $m$ 的质点，其位置向量为 $\\mathbf{q}(t) = [x(t), y(t)]^\\top$。根据牛顿第二定律，运动方程为 $m\\ddot{\\mathbf{q}}(t) = \\mathbf{F}(\\mathbf{q}(t))$，其中 $\\mathbf{F}$ 是作用在质点上的总力。\n\n理想约束是一个半径为 $R$ 的圆，由方程 $g(\\mathbf{q}) = x(t)^2 + y(t)^2 - R^2 = 0$ 描述。罚函数法通过引入一个势能函数 $U(\\mathbf{q})$ 来近似此约束，该函数惩罚对约束曲面的偏离。指定的势函数为 $U(\\mathbf{q}) = \\frac{k}{2} g(\\mathbf{q})^2$，其中 $k$ 是罚刚度。当约束满足时（$g(\\mathbf{q})=0$），此势为零，并随偏差呈二次方增长。\n\n此势产生的力是保守力，由势的负梯度给出：$\\mathbf{F}(\\mathbf{q}) = -\\nabla U(\\mathbf{q})$。我们计算该力的分量：\n$$\n\\mathbf{F}(\\mathbf{q}) = -\\nabla \\left[ \\frac{k}{2} (x^2 + y^2 - R^2)^2 \\right]\n$$\n力的 $x$ 分量为：\n$$\nF_x = -\\frac{\\partial U}{\\partial x} = -\\frac{k}{2} \\cdot 2(x^2 + y^2 - R^2) \\cdot \\frac{\\partial}{\\partial x}(x^2 + y^2 - R^2) = -k(x^2 + y^2 - R^2)(2x) = -2kx(x^2 + y^2 - R^2)\n$$\n类似地，力的 $y$ 分量为：\n$$\nF_y = -\\frac{\\partial U}{\\partial y} = -k(x^2 + y^2 - R^2)(2y) = -2ky(x^2 + y^2 - R^2)\n$$\n因此，二阶运动方程为：\n$$\n\\ddot{x}(t) = \\frac{F_x}{m} = -\\frac{2k}{m} x(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n$$\n\\ddot{y}(t) = \\frac{F_y}{m} = -\\frac{2k}{m} y(t) \\left(x(t)^2 + y(t)^2 - R^2\\right)\n$$\n为了数值求解该系统，我们将其转换为一阶常微分方程组。我们定义状态向量为 $\\mathbf{z}(t) = [x(t), y(t), v_x(t), v_y(t)]^\\top$，其中 $v_x(t) = \\dot{x}(t)$ 和 $v_y(t) = \\dot{y}(t)$ 是速度分量。状态向量的时间导数 $\\dot{\\mathbf{z}}(t) = f(\\mathbf{z}(t))$ 由下式给出：\n$$\n\\dot{\\mathbf{z}}(t) = \n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{v}_x \\\\\n\\dot{v}_y\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nv_x \\\\\nv_y \\\\\n-\\frac{2k}{m} x (x^2 + y^2 - R^2) \\\\\n-\\frac{2k}{m} y (x^2 + y^2 - R^2)\n\\end{bmatrix}\n$$\n这是一个形式为 $\\dot{\\mathbf{z}} = f(\\mathbf{z})$ 的四个耦合一阶常微分方程组。我们给定了初始条件 $\\mathbf{z}(0) = [R, 0, 0, v_0]^\\top$。\n\n问题指定使用显式四阶龙格－库塔（RK4）方法以固定时间步长 $h$ 进行数值积分。给定在时间 $t_n$ 的状态 $\\mathbf{z}_n$，在时间 $t_{n+1} = t_n + h$ 的状态 $\\mathbf{z}_{n+1}$ 计算如下：\n$$\n\\mathbf{z}_{n+1} = \\mathbf{z}_n + \\frac{h}{6}(\\mathbf{k}_1 + 2\\mathbf{k}_2 + 2\\mathbf{k}_3 + \\mathbf{k}_4)\n$$\n其中中间斜率为：\n$$\n\\begin{aligned}\n\\mathbf{k}_1 = f(\\mathbf{z}_n) \\\\\n\\mathbf{k}_2 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_1) \\\\\n\\mathbf{k}_3 = f(\\mathbf{z}_n + \\frac{h}{2} \\mathbf{k}_2) \\\\\n\\mathbf{k}_4 = f(\\mathbf{z}_n + h \\mathbf{k}_3)\n\\end{aligned}\n$$\n模拟从 $t=0$ 到 $t=T=5.0\\,\\mathrm{s}$，时间步长为 $h=0.005\\,\\mathrm{s}$。在每一步，我们计算瞬时约束违反量 $\\delta r(t) = \\left| \\sqrt{x(t)^2 + y(t)^2} - R \\right|$，并记录其最大值。我们还监测数值不稳定性，其定义为状态向量的 L2 范数 $\\lVert \\mathbf{z}(t) \\rVert_2$ 超过阈值 $M_{\\mathrm{th}} = 10^3$，或任何分量变为非有限值。如果检测到不稳定性，则该特定 $k$ 值的模拟将终止，并将稳定性标志设置为 `False`。\n\n对四个指定的罚刚度 $k$ 值（$100\\,\\mathrm{N/m^3}$、$1000\\,\\mathrm{N/m^3}$、$10000\\,\\mathrm{N/m^3}$ 和 $50000\\,\\mathrm{N/m^3}$）重复此过程。\n预期的行为是一种权衡：随着 $k$ 的增加，偏离圆周的惩罚变得更严厉，因此最大约束违反量 $\\delta r$ 应该减小。然而，更高的 $k$ 值会给系统的动力学引入高频振荡，使得常微分方程系统在数值上变得“刚性”。像 RK4 这样的具有固定时间步长的显式积分器，当时间步长 $h$ 不足以解析这些快速动态时，可能会变得不稳定，导致数值解的灾难性爆炸。我们预计最后一种情况，$k=50000\\,\\mathrm{N/m^3}$，在使用给定的时间步长 $h=0.005\\,\\mathrm{s}$ 时可能会表现出这种不稳定性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the specified mechanical system problem using the RK4 method.\n    \"\"\"\n    # Define physical constants and simulation parameters\n    m = 1.0  # mass in kg\n    R = 1.0  # radius in m\n    v0 = 1.0 # initial tangential velocity in m/s\n    \n    h = 0.005 # time step in s\n    T = 5.0   # total simulation time in s\n    M_th = 1000.0 # stability threshold\n\n    # Define the test cases for the penalty stiffness k\n    test_cases = [\n        100.0,    # Case 1: k in N/m^3\n        1000.0,   # Case 2: k in N/m^3\n        10000.0,  # Case 3: k in N/m^3\n        50000.0   # Case 4: k in N/m^3\n    ]\n\n    results = []\n\n    def f(z, k_val):\n        \"\"\"\n        Computes the time derivative of the state vector z.\n        z = [x, y, vx, vy]\n        \"\"\"\n        x, y, vx, vy = z\n        # Constraint function g(q) = x^2 + y^2 - R^2\n        g = x**2 + y**2 - R**2\n        \n        # Accelerations from penalty force F = -nabla(U)\n        ax = (-2.0 * k_val * x * g) / m\n        ay = (-2.0 * k_val * y * g) / m\n        \n        return np.array([vx, vy, ax, ay])\n\n    for k in test_cases:\n        # Initial state vector z = [x, y, vx, vy]\n        z = np.array([R, 0.0, 0.0, v0])\n        \n        # Initialize metrics for this case\n        max_violation = 0.0\n        stable = True\n        \n        # Calculate violation at the initial state (t=0)\n        violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n        max_violation = max(max_violation, violation)\n\n        # Determine the number of steps\n        num_steps = int(round(T / h))\n\n        # Time-stepping loop\n        for _ in range(num_steps):\n            # RK4 integration step\n            k1 = f(z, k)\n            k2 = f(z + 0.5 * h * k1, k)\n            k3 = f(z + 0.5 * h * k2, k)\n            k4 = f(z + h * k3, k)\n            z = z + (h / 6.0) * (k1 + 2 * k2 + 2 * k3 + k4)\n\n            # Check for instability\n            norm_z = np.linalg.norm(z)\n            if not np.isfinite(norm_z) or norm_z = M_th:\n                stable = False\n                break  # Terminate simulation for this k value\n\n            # Calculate constraint violation and update the maximum\n            violation = np.abs(np.sqrt(z[0]**2 + z[1]**2) - R)\n            max_violation = max(max_violation, violation)\n        \n        # Store the results for this case\n        results.append(max_violation)\n        results.append(stable)\n\n    # Format and print the final output\n    # Example format: [0.0123,True,-0.0045,True,...]\n    # The str() for a boolean correctly produces 'True' or 'False'\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3199683"}]}