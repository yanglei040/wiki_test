{"hands_on_practices": [{"introduction": "我们首先学习一种数值分析中的基本技术：通过实验测量求解器的收敛阶。这个练习将通过推导和应用一种从数值结果中估计 $p$ 的方法，来巩固全局截断误差按 $E \\approx C h^p$ 比例缩放的理论概念。这项技能对于验证代码实现是否符合预期至关重要。[@problem_id:3156057]", "problem": "考虑一个由 $y^{\\prime}(t) = y(t)$ 定义的常微分方程 (ODE) 的初值问题 (IVP)，其中 $y(0) = 1$。其精确解为 $y(t) = e^{t}$。单步 ODE 求解器通过映射 $y_{n+1} = \\Phi(t_{n}, y_{n}, h)$ 来推进数值状态，其中步长为 $h$，且 $t_{n+1} = t_{n} + h$。若对于足够小的 $h$，一个方法在固定最终时间 $T$ 处的全局截断误差与 $h$ 的幂成比例，则该方法的阶为 $p$。局部截断误差是将精确解代入数值更新式后，在单步内产生的差异；全局截断误差是在 $t = T$ 时累积的差异。\n\n您的任务是构建一个步长加倍实验，通过在求解 $y^{\\prime} = y$（精确解为 $y = e^{t}$）时测量全局截断误差 $E(h)$ 和 $E(2h)$，来估计一个黑盒 ODE 求解器的阶 $p$。该实验必须基于第一性原理：使用局部和全局截断误差的定义，并推导全局误差如何随 $h$ 的缩放而变化，而无需预先假设任何目标公式。实现两个黑盒单步求解器作为未知方法：一个前向 Euler 求解器和一个 Heun（显式梯形）求解器。将每个求解器视为一个黑盒函数，给定 $f$、$y_{0}$、$t_{0}$、$T$ 和 $h$，该函数使用固定步长返回在 $t = T$ 时的数值近似解 $y_{N}$，其中 $N = T/h$ 是一个整数。\n\n对于每组参数，用步长 $h$ 和 $2h$ 计算在 $t = T$ 时的数值解；测量相应的全局截断误差 $E(h) = \\lvert y_{\\text{num}}(T; h) - e^{T} \\rvert$ 和 $E(2h) = \\lvert y_{\\text{num}}(T; 2h) - e^{T} \\rvert$；然后，利用方法阶数定义所蕴含的基本缩放关系，推导出 $p$ 的估计值。本问题不使用任何物理单位。不涉及角度。将每个估计的 $p$ 表示为保留六位小数的浮点数。\n\n使用以下参数值测试套件，每个参数值指定为元组 $(\\text{solver}, T, h)$，其中 $T/h \\in \\mathbb{N}$ 且 $T/(2h) \\in \\mathbb{N}$：\n- $(\\text{Euler}, 1.0, 0.1)$，其中 $T = 1.0$，$h = 0.1$，\n- $(\\text{Heun}, 1.0, 0.1)$，其中 $T = 1.0$，$h = 0.1$，\n- $(\\text{Euler}, 2.0, 0.05)$，其中 $T = 2.0$，$h = 0.05$，\n- $(\\text{Heun}, 2.0, 0.05)$，其中 $T = 2.0$，$h = 0.05$，\n- $(\\text{Euler}, 1.0, 0.5)$，其中 $T = 1.0$，$h = 0.5$，\n- $(\\text{Heun}, 1.0, 0.001)$，其中 $T = 1.0$，$h = 0.001$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的结果按上述顺序排列；例如，输出形式为 [$p_{1},$ $p_{2},$ $p_{3},$ $p_{4},$ $p_{5},$ $p_{6}$]，每个 $p_{i}$ 都四舍五入到六位小数。", "solution": "用户提供了一个来自计算科学领域的有效且适定的问题陈述。该问题在科学上基于常微分方程（ODE）数值方法的理论，内容自洽，并且有一个清晰、可验证的目标。\n\n任务是通过执行步长加倍实验来估计两个单步 ODE 求解器的收敛阶 $p$。这需要从第一性原理推导出 $p$ 的估计量，然后将其应用于一个特定的初值问题（IVP）。\n\n### 阶估计器的原理与推导\n\n如果一个用于求解 ODE 的数值方法的全局截断误差 $E$ 在固定的最终时间 $T$ 处，根据以下关系随步长 $h$ 缩放，则称该方法具有收敛阶 $p$：\n$$\nE(h) = \\lvert y_{\\text{num}}(T; h) - y(T) \\rvert \\approx C h^p\n$$\n对于足够小的 $h$。这里，$y_{\\text{num}}(T; h)$ 是使用步长 $h$ 在时间 $T$ 得到的数值解，$y(T)$ 是精确解，而 $C$ 是一个依赖于 ODE、其解、最终时间 $T$ 和具体方法，但假定与 $h$ 无关的常数。\n\n为了在不知道常数 $C$ 的情况下估计 $p$，我们可以使用两种不同的步长计算误差。问题指定了一个步长加倍实验，所以我们使用步长 $h$ 和 $2h$。根据缩放关系，误差为：\n$$\nE(h) \\approx C h^p \\quad (1)\n$$\n$$\nE(2h) \\approx C (2h)^p = C 2^p h^p \\quad (2)\n$$\n\n为了消去未知常数 $C$，我们可以将方程 $(2)$ 与方程 $(1)$ 相除：\n$$\n\\frac{E(2h)}{E(h)} \\approx \\frac{C 2^p h^p}{C h^p} = 2^p\n$$\n\n这个关系提供了一种直接估计 $p$ 的方法。通过对两边取以 2 为底的对数，我们分离出 $p$：\n$$\n\\log_2\\left(\\frac{E(2h)}{E(h)}\\right) \\approx \\log_2(2^p) = p\n$$\n\n因此，我们对方法阶数的估计量是：\n$$\np \\approx \\log_2\\left(\\frac{E(2h)}{E(h)}\\right)\n$$\n这个公式是直接从方法阶数的定义中推导出来的，并构成了我们数值实验的基础。\n\n### 数值实验的实现\n\n实验将在以下 IVP 上进行：\n- **常微分方程 (ODE)：** $y'(t) = y(t)$\n- **初始条件：** $y(0) = 1$\n- **精确解：** $y(t) = e^t$\n\n该 ODE 的右侧由函数 $f(t, y) = y$ 给出。\n\n我们将实现两个“黑盒”单步求解器：\n\n1.  **前向 Euler 方法：** 这是一种显式一阶方法。从步骤 $n$ 推进到 $n+1$ 的更新规则是：\n    $$\n    y_{n+1} = y_n + h f(t_n, y_n)\n    $$\n    对于我们特定的 IVP，这变为 $y_{n+1} = y_n + h y_n = y_n(1+h)$。\n\n2.  **Heun 方法（显式梯形法则）：** 这是一种显式二阶方法，属于预测-校正方法或 Runge-Kutta 方法族。其更新规则是：\n    $$\n    k_1 = f(t_n, y_n)\n    $$\n    $$\n    k_2 = f(t_n + h, y_n + h k_1)\n    $$\n    $$\n    y_{n+1} = y_n + \\frac{h}{2}(k_1 + k_2)\n    $$\n    这可以被看作是先执行一个初始的 Euler 步（预测步），然后在区间的开始和预测的结束点处对斜率进行平均（校正步）。\n\n对于问题陈述中指定的每个测试用例 $(\\text{solver}, T, h)$，执行以下算法：\n\n1.  设置初始条件 $y_0 = 1$ 和 $t_0 = 0$。\n2.  应用所选求解器，以大小为 $h$ 的步长进行 $N_1 = T/h$ 步计算，得到数值解 $y_{\\text{num}}(T; h)$。\n3.  应用同一求解器，以大小为 $2h$ 的步长进行 $N_2 = T/(2h)$ 步计算，得到数值解 $y_{\\text{num}}(T; 2h)$。\n4.  计算最终时间的精确解 $y(T) = e^T$。\n5.  确定全局截断误差：\n    $$\n    E(h) = \\lvert y_{\\text{num}}(T; h) - e^T \\rvert\n    $$\n    $$\n    E(2h) = \\lvert y_{\\text{num}}(T; 2h) - e^T \\rvert\n    $$\n6.  最后，使用推导出的公式计算估计阶数 $p$：\n    $$\n    p = \\log_2\\left(\\frac{E(2h)}{E(h)}\\right)\n    $$\n按要求将得到的 $p$ 值四舍五入到六位小数。对所有测试用例重复此过程。前向 Euler 方法预计将得出 $p \\approx 1$，而 Heun 方法应得出 $p \\approx 2$，估计的准确性取决于对于给定的步长 $h$，渐近误差行为的建立程度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the estimated order of convergence for Euler and Heun methods\n    using a step-doubling experiment based on a set of test cases.\n    \"\"\"\n\n    def ode_f(t, y):\n        \"\"\"The right-hand side of the ODE y' = y.\"\"\"\n        return y\n\n    def forward_euler_solver(f, y0, t0, T, h):\n        \"\"\"\n        Solves an IVP using the Forward Euler method.\n        \n        Args:\n            f: The function f(t, y) for the ODE y' = f(t, y).\n            y0: The initial value y(t0).\n            t0: The initial time.\n            T: The final time.\n            h: The step size.\n        \n        Returns:\n            The numerical solution at time T.\n        \"\"\"\n        y = y0\n        t = t0\n        num_steps = int(np.round((T - t0) / h))\n        \n        for _ in range(num_steps):\n            y = y + h * f(t, y)\n            t = t + h\n            \n        return y\n\n    def heun_solver(f, y0, t0, T, h):\n        \"\"\"\n        Solves an IVP using Heun's method (explicit trapezoidal rule).\n        \n        Args:\n            f: The function f(t, y) for the ODE y' = f(t, y).\n            y0: The initial value y(t0).\n            t0: The initial time.\n            T: The final time.\n            h: The step size.\n        \n        Returns:\n            The numerical solution at time T.\n        \"\"\"\n        y = y0\n        t = t0\n        num_steps = int(np.round((T - t0) / h))\n        \n        for _ in range(num_steps):\n            k1 = f(t, y)\n            k2 = f(t + h, y + h * k1)\n            y = y + (h / 2.0) * (k1 + k2)\n            t = t + h\n            \n        return y\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (\"Euler\", 1.0, 0.1),\n        (\"Heun\", 1.0, 0.1),\n        (\"Euler\", 2.0, 0.05),\n        (\"Heun\", 2.0, 0.05),\n        (\"Euler\", 1.0, 0.5),\n        (\"Heun\", 1.0, 0.001),\n    ]\n\n    solvers = {\n        \"Euler\": forward_euler_solver,\n        \"Heun\": heun_solver,\n    }\n\n    results = []\n    \n    for solver_name, T, h in test_cases:\n        solver_func = solvers[solver_name]\n        \n        # Initial conditions for the IVP y'=y, y(0)=1\n        y0 = 1.0\n        t0 = 0.0\n        \n        # Define the two step sizes for the experiment\n        h1 = h\n        h2 = 2.0 * h\n        \n        # Compute numerical solutions for both step sizes\n        y_num_h1 = solver_func(ode_f, y0, t0, T, h1)\n        y_num_h2 = solver_func(ode_f, y0, t0, T, h2)\n        \n        # Compute the exact solution at T\n        y_exact = np.exp(T)\n        \n        # Compute the global truncation errors\n        error_h1 = np.abs(y_num_h1 - y_exact)\n        error_h2 = np.abs(y_num_h2 - y_exact)\n        \n        # Estimate the order p\n        # p is approximately log2(E(2h) / E(h))\n        # Handle cases where error might be zero to avoid division by zero\n        if error_h1 == 0.0:\n            # If the smaller step size gives zero error, the order cannot be determined\n            # by this method. This is unlikely for these methods and ODE.\n            # We can represent this as infinity or NaN, but for the purpose of this\n            # problem, we assume non-zero error.\n            # In a real-world scenario, a different approach would be needed.\n            # Given the problem context, this case is not expected to occur.\n            p = np.nan \n        else:\n            p = np.log2(error_h2 / error_h1)\n        \n        results.append(p)\n\n    # Format results to six decimal places and create the final output string\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3156057"}, {"introduction": "理解误差的结构不仅仅是为了分析，我们还可以利用它来主动改进我们的解。本练习介绍理查森外推法（Richardson extrapolation），这是一种强大的技术，它通过组合两个不同步长的计算结果来消除主导误差项。你将看到，通过一个巧妙而简单的操作，我们可以将一个低阶方法的结果转化为一个更精确的高阶估计。[@problem_id:2409197]", "problem": "实现一个完整的程序，对于一组形式为 $\\dfrac{dy}{dt} = f(t,y)$ 且 $y(0) = y_0$ 的初值问题，执行以下操作：从局部截断误差和全局截断误差的定义出发，推导出一个理查森外推组合，该组合通过合并用步长 $h$ 和 $h/2$ 计算的两个欧拉解，来消除显式欧拉法的主导全局误差项。该组合必须基于全局误差关于 $h$ 的幂次方的渐近展开，从第一性原理推导得出，并且它必须产生一个新的近似，其全局截断误差为 $\\mathcal{O}(h^2)$ 阶。\n\n您的推导必须基于以下基本事实：\n- 显式欧拉法由递推关系 $y_{n+1} = y_n + h f(t_n, y_n)$ 定义，其中 $t_n = t_0 + n h$。\n- 局部截断误差是将精确解代入单步方法中得到的单步缺陷，对于光滑的 $f$，其量级为 $\\mathcal{O}(h^2)$。\n- 在固定的最终时间 $T$，全局截断误差是经过 $N = T/h$ 步后，精确解与数值解之间的累积差异；对于显式欧拉法，其量级为 $\\mathcal{O}(h)$。\n\n您的程序必须实现：\n1. 一个函数，用于计算在最终时间 $T$ 使用均匀步长 $h$ 的显式欧拉解 $y_h(T)$。\n2. 一个理查森外推组合，仅使用以步长 $h$ 和 $h/2$ 计算的两个欧拉解，产生一个改进的近似值 $y_{\\mathrm{RE}}(T)$，其全局截断误差量级为 $\\mathcal{O}(h^2)$。\n3. 一个经验验证程序，该程序也用步长 $h/4$ 计算解，以便您可以估计观测到的收敛阶：\n   - 对于显式欧拉法，估计 $p_{\\mathrm{E}} \\approx \\log_2\\!\\left(\\dfrac{|y_h(T) - y(T)|}{|y_{h/2}(T) - y(T)|}\\right)$。\n   - 对于理查森外推近似，首先构造 $y_{\\mathrm{RE}}(h) = \\mathrm{RE}(y_h, y_{h/2})$ 和 $y_{\\mathrm{RE}}(h/2) = \\mathrm{RE}(y_{h/2}, y_{h/4})$，然后估计 $p_{\\mathrm{RE}} \\approx \\log_2\\!\\left(\\dfrac{|y_{\\mathrm{RE}}(h) - y(T)|}{|y_{\\mathrm{RE}}(h/2) - y(T)|}\\right)$。\n\n角度必须以弧度为单位进行解释。\n\n测试套件：\n对于下面的每个案例，计算 $y_h(T)$、$y_{h/2}(T)$、$y_{h/4}(T)$，构造 $y_{\\mathrm{RE}}(h)$ 和 $y_{\\mathrm{RE}}(h/2)$，然后计算相对于精确解 $y(T)$ 的绝对误差。\n- 案例A（指数衰减）：$\\dfrac{dy}{dt} = -3 y$, $y(0) = 1$, $T = 1$, 基本步长 $h = 0.2$。精确解: $y(t) = e^{-3 t}$。\n- 案例B（线性非齐次）：$\\dfrac{dy}{dt} = t + y$, $y(0) = 0$, $T = 1$, 基本步长 $h = 0.2$。精确解: $y(t) = e^{t} - (t + 1)$。\n- 案例C（变系数增长）：$\\dfrac{dy}{dt} = \\sin(t)\\, y$, $y(0) = 1$, $T = 1$, 基本步长 $h = 0.2$。精确解: $y(t) = \\exp\\!\\big(1 - \\cos(t)\\big)$。\n\n对于每个案例，您的程序必须生成一个包含五个实数的列表：\n- 使用步长 $h$ 的欧拉法的绝对全局误差，即 $E_h = |y_h(T) - y(T)|$。\n- 使用步长 $h/2$ 的欧拉法的绝对全局误差，即 $E_{h/2} = |y_{h/2}(T) - y(T)|$。\n- 由 $h$ 和 $h/2$ 构建的理查森外推近似的绝对全局误差，即 $E_{\\mathrm{RE}}(h) = |y_{\\mathrm{RE}}(h) - y(T)|$。\n- 上面定义的观测阶 $p_{\\mathrm{E}}$。\n- 上面定义的观测阶 $p_{\\mathrm{RE}}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含三个案例的结果，按案例 A、案例 B、案例 C 的顺序，格式为一个逗号分隔的三个列表，并用一对单独的方括号括起来，其中不含任何空格。每个实数必须以科学记数法打印，并保留十位有效数字。例如，该行必须看起来像：\n[[E_h_A,E_h2_A,E_RE_A,pE_A,pRE_A],[E_h_B,E_h2_B,E_RE_B,pE_B,pRE_B],[E_h_C,E_h2_C,E_RE_C,pE_C,pRE_C]]\n确保所有三角函数的参数都以弧度为单位。由于本问题中所有量都是无量纲的，因此不需要单位。", "solution": "问题陈述已经过验证。\n\n给定的条件逐字提取如下：\n1.  初值问题：$\\dfrac{dy}{dt} = f(t,y)$ 且 $y(0) = y_0$。\n2.  显式欧拉法递推关系：$y_{n+1} = y_n + h f(t_n, y_n)$，其中 $t_n = t_0 + n h$。\n3.  显式欧拉法的局部截断误差量级为 $\\mathcal{O}(h^2)$。\n4.  在固定时间 $T$ 的显式欧拉法全局截断误差量级为 $\\mathcal{O}(h)$。\n5.  任务：推导一个理查森外推组合，用于两个步长分别为 $h$ 和 $h/2$ 的欧拉解，以消除主导全局误差项，假设全局误差存在渐近展开。得到的近似解必须具有 $\\mathcal{O}(h^2)$ 阶的全局误差。\n6.  任务：使用步长 $h$、$h/2$ 和 $h/4$ 实现一个经验性验证。\n7.  欧拉法的观测阶：$p_{\\mathrm{E}} \\approx \\log_2\\!\\left(\\dfrac{|y_h(T) - y(T)|}{|y_{h/2}(T) - y(T)|}\\right)$。\n8.  理查森外推的观测阶：$p_{\\mathrm{RE}} \\approx \\log_2\\!\\left(\\dfrac{|y_{\\mathrm{RE}}(h) - y(T)|}{|y_{\\mathrm{RE}}(h/2) - y(T)|}\\right)$，其中 $y_{\\mathrm{RE}}(h) = \\mathrm{RE}(y_h, y_{h/2})$ 且 $y_{\\mathrm{RE}}(h/2) = \\mathrm{RE}(y_{h/2}, y_{h/4})$。\n9.  测试案例 A：$\\dfrac{dy}{dt} = -3 y$，$y(0) = 1$，$T = 1$，$h = 0.2$。精确解: $y(t) = e^{-3 t}$。\n10. 测试案例 B：$\\dfrac{dy}{dt} = t + y$，$y(0) = 0$，$T = 1$，$h = 0.2$。精确解: $y(t) = e^{t} - (t + 1)$。\n11. 测试案例 C：$\\dfrac{dy}{dt} = \\sin(t)\\, y$，$y(0) = 1$，$T = 1$，$h = 0.2$。精确解: $y(t) = \\exp\\!\\big(1 - \\cos(t)\\big)$。\n12. 每个案例的所需输出：一个包含五个数字的列表：$|y_h(T) - y(T)|$，$|y_{h/2}(T) - y(T)|$，$|y_{\\mathrm{RE}}(h) - y(T)|$，$p_{\\mathrm{E}}$ 和 $p_{\\mathrm{RE}}$。\n\n使用提取的给定条件进行验证：\n该问题具有科学依据。它涉及理查森外推，这是数值分析中用于提高数值方法精度的一种标准且基础的技术。其前提——显式欧拉法的定义及其局部和全局截断误差的阶——是常微分方程数值解研究中的标准结果。该问题是适定的；它要求对明确定义的、具有唯一解析解的测试案例进行特定的推导和实现，从而确保可以获得并验证一个唯一且有意义的结果。其语言客观而精确。该问题没有违反任何无效性标准。这是一个与计算物理和数值方法直接相关的可形式化问题。\n\n结论：该问题有效。将提供解决方案。\n\n理查森外推公式的推导必须按规定从第一性原理出发。该方法的基础是数值格式的全局误差存在一个渐近展开。对于全局误差为 $\\mathcal{O}(h)$ 阶的显式欧拉法，该展开式具有以下形式：\n$$\ny_h(T) = y(T) + C_1 h + C_2 h^2 + C_3 h^3 + \\dots\n$$\n这里，$y(T)$ 是在最终时间 $T$ 的精确解，$y_h(T)$ 是用步长 $h$ 得到的数值近似解，系数 $C_k$ 与 $h$ 无关，但依赖于函数 $f(t,y)$ 及其在各点的导数。主导误差项是 $C_1 h$。\n\n我们的目标是通过组合两个独立的计算来消除这个主导项。让我们用步长 $h$ 进行数值积分，然后再用步长 $h/2$ 进行一次。相应数值解的渐近展开式为：\n$$\n(1) \\quad y_h(T) = y(T) + C_1 h + C_2 h^2 + \\mathcal{O}(h^3)\n$$\n$$\n(2) \\quad y_{h/2}(T) = y(T) + C_1 \\frac{h}{2} + C_2 \\left(\\frac{h}{2}\\right)^2 + \\mathcal{O}(h^3) = y(T) + \\frac{1}{2} C_1 h + \\frac{1}{4} C_2 h^2 + \\mathcal{O}(h^3)\n$$\n我们寻求 $y_h(T)$ 和 $y_{h/2}(T)$ 的一个线性组合，以消去与 $C_1 h$ 成正比的项。设外推近似为 $y_{\\mathrm{RE}}(T)$。为消去 $C_1 h$，我们可以将方程 $(2)$ 乘以 $2$，然后减去方程 $(1)$：\n$$\n2 y_{h/2}(T) - y_h(T) = \\left(2y(T) + C_1 h + \\frac{1}{2} C_2 h^2 + \\dots\\right) - \\left(y(T) + C_1 h + C_2 h^2 + \\dots\\right)\n$$\n$$\n2 y_{h/2}(T) - y_h(T) = (2-1)y(T) + (1-1)C_1 h + \\left(\\frac{1}{2}-1\\right)C_2 h^2 + \\mathcal{O}(h^3)\n$$\n$$\n2 y_{h/2}(T) - y_h(T) = y(T) - \\frac{1}{2} C_2 h^2 + \\mathcal{O}(h^3)\n$$\n由此，我们定义理查森外推解 $y_{\\mathrm{RE}}(T)$ 为：\n$$\ny_{\\mathrm{RE}}(T) = 2 y_{h/2}(T) - y_h(T)\n$$\n这个新近似的全局截断误差是差值 $y_{\\mathrm{RE}}(T) - y(T)$。根据我们的推导：\n$$\ny_{\\mathrm{RE}}(T) - y(T) = -\\frac{1}{2} C_2 h^2 + \\mathcal{O}(h^3)\n$$\n这证实了全局截断误差现在是 $\\mathcal{O}(h^2)$ 阶，符合要求。原始方法的主导误差项已成功消除。\n\n计算实现将包括三个主要部分。首先，一个函数 `explicit_euler` 将使用一个恒定的步长 $h$ 来求解给定的从初始时间 $t_0$ 到最终时间 $T$ 的常微分方程。该函数将实现递推关系 $y_{k+1} = y_k + h f(t_k, y_k)$，迭代 $N = \\text{round}((T-t_0)/h)$ 次。\n\n其次，一个主程序将为每个测试案例执行逻辑。对于一个基本步长 $h$，它将使用步长 $h$、$h/2$ 和 $h/4$ 调用 `explicit_euler` 函数三次，以获得数值解 $y_h(T)$、$y_{h/2}(T)$ 和 $y_{h/4}(T)$。\n\n第三，该程序将使用这些数值结果进行经验分析。它将计算理查森外推近似值：\n$$\ny_{\\mathrm{RE}}(h) = 2 y_{h/2}(T) - y_h(T)\n$$\n$$\ny_{\\mathrm{RE}}(h/2) = 2 y_{h/4}(T) - y_{h/2}(T)\n$$\n然后，相对于已知的精确解 $y(T)$ 计算绝对全局误差。最后，使用指定的对数公式计算观测到的收敛阶 $p_{\\mathrm{E}}$ 和 $p_{\\mathrm{RE}}$。这些经验阶对于欧拉法应约等于 $1$，对于理查森外推法应约等于 $2$，从而验证了精度的理论改进。所有测试案例的最终结果将根据指定格式进行格式化和打印。三角函数的输入将按科学计算中的标准以弧度处理。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements Richardson extrapolation for the explicit Euler method to solve\n    several initial value problems and empirically verifies the order of convergence.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"f\": lambda t, y: -3.0 * y,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"exact_y\": lambda t: np.exp(-3.0 * t),\n        },\n        {\n            \"f\": lambda t, y: t + y,\n            \"y0\": 0.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"exact_y\": lambda t: np.exp(t) - (t + 1.0),\n        },\n        {\n            \"f\": lambda t, y: np.sin(t) * y,\n            \"y0\": 1.0,\n            \"T\": 1.0,\n            \"h\": 0.2,\n            \"exact_y\": lambda t: np.exp(1.0 - np.cos(t)),\n        },\n    ]\n\n    def explicit_euler(f_ode, y_start, t_start, t_end, step_size):\n        \"\"\"\n        Computes the solution of an ODE using the explicit Euler method.\n        \"\"\"\n        t = t_start\n        y = y_start\n        # Use round() to avoid floating-point inaccuracies in step counting\n        num_steps = int(round((t_end - t_start) / step_size))\n        \n        for _ in range(num_steps):\n            y = y + step_size * f_ode(t, y)\n            t = t + step_size\n        return y\n\n    all_results = []\n    for case in test_cases:\n        f = case[\"f\"]\n        y0 = case[\"y0\"]\n        T = case[\"T\"]\n        h_base = case[\"h\"]\n        exact_y_func = case[\"exact_y\"]\n\n        # Define the three step sizes\n        h = h_base\n        h_half = h_base / 2.0\n        h_quarter = h_base / 4.0\n\n        # Compute Euler solutions for each step size\n        y_h = explicit_euler(f, y0, 0.0, T, h)\n        y_h_half = explicit_euler(f, y0, 0.0, T, h_half)\n        y_h_quarter = explicit_euler(f, y0, 0.0, T, h_quarter)\n\n        # Compute the exact solution at the final time T\n        y_exact = exact_y_func(T)\n\n        # Compute Richardson-extrapolated approximations\n        y_re_h = 2.0 * y_h_half - y_h\n        y_re_h_half = 2.0 * y_h_quarter - y_h_half\n\n        # Compute absolute errors\n        E_h = np.abs(y_h - y_exact)\n        E_h_half = np.abs(y_h_half - y_exact)\n        E_re_h = np.abs(y_re_h - y_exact)\n        E_re_h_half = np.abs(y_re_h_half - y_exact)\n\n        # Compute observed orders of convergence\n        # Handle cases where error is zero to avoid division by zero or log(0)\n        p_E = np.log2(E_h / E_h_half) if E_h_half > 0 else 0.0\n        p_RE = np.log2(E_re_h / E_re_h_half) if E_re_h_half > 0 else 0.0\n\n        results = [E_h, E_h_half, E_re_h, p_E, p_RE]\n        all_results.append(results)\n\n    # Format the final output string as specified\n    formatted_cases = []\n    for case_res in all_results:\n        formatted_nums = [f\"{num:.10e}\" for num in case_res]\n        formatted_cases.append(f\"[{','.join(formatted_nums)}]\")\n    \n    final_output = f\"[{','.join(formatted_cases)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "2409197"}, {"introduction": "人们很容易认为高阶方法总是更好，但这是一种危险的过度简化。本练习将探讨一个“恶意的”但平滑的常微分方程，它挑战了这一观念，揭示了局部截断误差的 $\\mathcal{O}(h^{p+1})$ 表达式中所隐藏的误差常数的关键作用。你将发现，常微分方程本身的性质（例如大的高阶导数）如何使得一个高阶方法表现不佳，除非步长选择得极其小心。[@problem_id:2409196]", "problem": "考虑一个常微分方程（ODE）的初值问题：$y^{\\prime}(t) = f(t)$，初始条件为 $y(0) = 0$。目标是分析当 $f(t)$ 光滑但具有较大的高阶导数时，对于一个高阶显式单步法，局部截断误差和全局截断误差的行为。使用步长为 $h$ 的经典四阶龙格-库塔方法（也称为 4 级四阶显式龙格-库塔方法）。\n\n使用的基本原理：\n- 局部截断误差的定义：对于一个从时间 $t_0$ 推进到 $t_0 + h$ 的单步法，局部截断误差为 $e_{\\mathrm{loc}}(t_0,h) = y(t_0 + h) - \\Phi(t_0,y(t_0),h)$，其中 $\\Phi$ 表示该方法在从精确状态 $y(t_0)$ 初始化时产生的一个数值步。\n- 全局截断误差的定义：对于在有限区间 $[0,T]$ 上的固定步长 $h$ 和 $N = T/h$ 个步骤，从精确初始条件 $y(0)$ 开始，在时间 $T$ 的全局截断误差为 $e_{\\mathrm{glob}}(T,h) = y(T) - y_N$，其中 $y_N$ 是 $N$ 步后的数值近似值。\n- 光滑函数 $f(t)$ 在 $t_0$ 附近的泰勒展开。\n\n你的任务：\n$1.$ 当右端项仅依赖于时间，即 $y^{\\prime}(t) = f(t)$ 且 $f \\in C^4$ 时，根据 $f(t)$ 的泰勒展开和经典 4 级龙格-库塔方法的构造，推导单步局部截断误差的主阶表达式。证明在这种情况下，单个龙格-库塔步骤简化为 $f(t)$ 在 $[t_0,t_0+h]$ 上的一个数值积分，并用 $f(t)$ 在 $t_0$ 处的导数来表示 $e_{\\mathrm{loc}}(t_0,h)$ 的主阶项。\n$2.$ 构造一个光滑但“恶意”的右端项 $f(t)$，其高阶导数很大：令 $f(t) = \\sin(\\Omega t)$，其中 $\\Omega$ 是一个角频率。角度必须以弧度处理。利用你的推导解释为什么对于固定的 $h$，即使使用高阶方法，大的 $\\Omega$ 值也会导致意想不到的大的局部截断误差。\n$3.$ 对于 $y^{\\prime}(t) = \\sin(\\Omega t)$，实现其精确解：当 $\\Omega \\neq 0$ 时为 $y(t) = \\int_0^t \\sin(\\Omega s)\\,ds = \\frac{1 - \\cos(\\Omega t)}{\\Omega}$，当 $\\Omega = 0$ 时为 $y(t) = 0$。\n$4.$ 为此 ODE 实现步长为 $h$ 的经典 4 级龙格-库塔方法的一个步骤，并通过将从 $y(0)=0$ 开始的单个数值步骤与精确解 $y(h)$ 进行比较，计算在 $t_0 = 0$ 处的局部截断误差 $e_{\\mathrm{loc}}(0,h)$。\n$5.$ 使用相同方法和固定步长 $h$ 实现从 $t = 0$ 到 $t = T$ 的数值解，并通过将最终数值与精确解 $y(T)$ 进行比较，计算全局截断误差 $e_{\\mathrm{glob}}(T,h)$。\n\n角度单位要求：\n- 所有三角函数参数必须以弧度为单位。\n\n测试套件和参数覆盖范围：\n使用 $T = 1$ 和以下测试用例，这些用例通过改变频率 $\\Omega$ 和步长 $h$ 来揭示不同的情况（理想情况、难度递增和边界情况）：\n- 用例 1：$(\\Omega, h) = (0, 0.1)$。\n- 用例 2：$(\\Omega, h) = (50, 0.02)$。\n- 用例 3：$(\\Omega, h) = (200, 0.01)$。\n- 用例 4：$(\\Omega, h) = (1000, 0.005)$。\n\n对于每个用例，计算两个浮点数：\n- 从 $t_0 = 0$ 到 $t_0 + h$ 的单步局部截断误差的大小：$|e_{\\mathrm{loc}}(0,h)|$。\n- 在 $T = 1$ 时的全局截断误差的大小：$|e_{\\mathrm{glob}}(1,h)|$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，结果按以下顺序排列：\n$[|e_{\\mathrm{loc}}|_{\\mathrm{用例}\\,1},|e_{\\mathrm{glob}}|_{\\mathrm{用例}\\,1},|e_{\\mathrm{loc}}|_{\\mathrm{用例}\\,2},|e_{\\mathrm{glob}}|_{\\mathrm{用例}\\,2},|e_{\\mathrm{loc}}|_{\\mathrm{用例}\\,3},|e_{\\mathrm{glob}}|_{\\mathrm{用例}\\,3},|e_{\\mathrm{loc}}|_{\\mathrm{用例}\\,4},|e_{\\mathrm{glob}}|_{\\mathrm{用例}\\,4}]$。\n\n所有数字必须以十进制浮点数形式打印。不应打印任何其他文本。", "solution": "该问题要求分析将经典四阶龙ge-库塔方法应用于简单常微分方程（ODE）$y'(t) = f(t)$（初始条件为 $y(0) = 0$）时的局部和全局截断误差。特别关注的是一个光滑但高度振荡的右端项 $f(t) = \\sin(\\Omega t)$ 如何影响这些误差。\n\n首先，我们必须推导局部截断误差的表达式。对于一个通用 ODE $y'(t) = F(t, y(t))$，经典的四阶龙格-库塔（RK4）方法使用以下步骤将解从 $t_n$ 推进到 $t_{n+1} = t_n + h$：\n$$ k_1 = F(t_n, y_n) $$\n$$ k_2 = F\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_1\\right) $$\n$$ k_3 = F\\left(t_n + \\frac{h}{2}, y_n + \\frac{h}{2}k_2\\right) $$\n$$ k_4 = F(t_n + h, y_n + h k_3) $$\n$$ y_{n+1} = y_n + \\frac{h}{6}(k_1 + 2k_2 + 2k_3 + k_4) $$\n\n对于特定的 ODE $y'(t) = f(t)$，函数 $F(t, y)$ 与 $y$ 无关，即 $F(t,y) = f(t)$。RK4 的各个阶段大大简化：\n$$ k_1 = f(t_n) $$\n$$ k_2 = f\\left(t_n + \\frac{h}{2}\\right) $$\n$$ k_3 = f\\left(t_n + \\frac{h}{2}\\right) $$\n$$ k_4 = f(t_n + h) $$\n单步更新规则变为：\n$$ y_{n+1} = y_n + \\frac{h}{6}\\left[f(t_n) + 2f\\left(t_n + \\frac{h}{2}\\right) + 2f\\left(t_n + \\frac{h}{2}\\right) + f(t_n + h)\\right] $$\n$$ y_{n+1} = y_n + h\\left[\\frac{1}{6}f(t_n) + \\frac{4}{6}f\\left(t_n + \\frac{h}{2}\\right) + \\frac{1}{6}f(t_n + h)\\right] $$\n这个公式恰好是 $f(t)$ 在区间 $[t_n, t_{n+1}]$ 上进行数值积分的辛普森法则。这是合乎逻辑的，因为 $y'(t) = f(t)$ 的精确解是通过积分得到的：$y(t_{n+1}) = y(t_n) + \\int_{t_n}^{t_{n+1}} f(s) ds$。\n\n局部截断误差 $e_{\\mathrm{loc}}(t_n, h)$ 定义为假设方法从精确解 $y(t_n)$ 开始，在单步中产生的误差。\n$$ e_{\\mathrm{loc}}(t_n, h) = y(t_{n+1}) - \\left(y(t_n) + h\\left[\\frac{1}{6}f(t_n) + \\frac{4}{6}f\\left(t_n + \\frac{h}{2}\\right) + \\frac{1}{6}f(t_n + h)\\right]\\right) $$\n$$ e_{\\mathrm{loc}}(t_n, h) = \\int_{t_n}^{t_{n+1}} f(s) ds - h\\left[\\frac{1}{6}f(t_n) + \\frac{4}{6}f\\left(t_n + \\frac{h}{2}\\right) + \\frac{1}{6}f(t_n + h)\\right] $$\n这是辛普森法则的误差。为了找到其主阶项，我们对 $f(s)$ 在 $t_n$ 附近进行泰勒级数展开。令 $t_n = t_0$。精确积分为：\n$$ \\int_{t_0}^{t_0+h} f(s) ds = \\sum_{k=0}^{\\infty} \\frac{f^{(k)}(t_0)}{(k+1)!}h^{k+1} $$\n$$ \\int_{t_0}^{t_0+h} f(s) ds = hf(t_0) + \\frac{h^2}{2}f'(t_0) + \\frac{h^3}{6}f''(t_0) + \\frac{h^4}{24}f'''(t_0) + \\frac{h^5}{120}f^{(4)}(t_0) + \\mathcal{O}(h^6) $$\n数值近似值也通过对 $f(t_0+h/2)$ 和 $f(t_0+h)$ 使用泰勒级数进行类似展开：\n$$ \\frac{h}{6}\\left[f(t_0) + 4f\\left(t_0 + \\frac{h}{2}\\right) + f(t_0 + h)\\right] $$\n合并项后，此展开得到：\n$$ hf(t_0) + \\frac{h^2}{2}f'(t_0) + \\frac{h^3}{6}f''(t_0) + \\frac{h^4}{24}f'''(t_0) + \\frac{5h^5}{576}f^{(4)}(t_0) + \\mathcal{O}(h^6) $$\n局部截断误差是精确积分与数值近似之间的差：\n$$ e_{\\mathrm{loc}}(t_0, h) = \\left(\\frac{1}{120} - \\frac{5}{576}\\right)h^5 f^{(4)}(t_0) + \\mathcal{O}(h^6) = \\left(\\frac{24 - 25}{2880}\\right)h^5 f^{(4)}(t_0) + \\mathcal{O}(h^6) $$\n$$ e_{\\mathrm{loc}}(t_0, h) = -\\frac{1}{2880}h^5 f^{(4)}(t_0) + \\mathcal{O}(h^6) $$\n这证实了局部截断误差是 $\\mathcal{O}(h^5)$ 阶的，正如一个四阶方法所预期的那样。\n\n现在，我们分析具体情况 $f(t) = \\sin(\\Omega t)$，其中 $\\Omega$ 是一个可能很大的角频率。我们必须计算 $f(t)$ 的四阶导数：\n$$ f(t) = \\sin(\\Omega t) $$\n$$ f'(t) = \\Omega \\cos(\\Omega t) $$\n$$ f''(t) = -\\Omega^2 \\sin(\\Omega t) $$\n$$ f'''(t) = -\\Omega^3 \\cos(\\Omega t) $$\n$$ f^{(4)}(t) = \\Omega^4 \\sin(\\Omega t) $$\n将此代入主阶误差项，得到：\n$$ e_{\\mathrm{loc}}(t_0, h) \\approx -\\frac{h^5}{2880} \\Omega^4 \\sin(\\Omega t_0) $$\n因此，误差的大小与 $\\Omega^4$ 成正比。这是一个关键的观察。即使步长 $h$ 很小，如果频率 $\\Omega$ 足够大，因子 $\\Omega^4$ 也会导致局部截断误差变得不可接受地大。保持精度的条件不仅仅是 $h$ 要小，而且无量纲量 $(\\Omega h)$ 要足够小，以控制 $h^5 \\Omega^4 = h (\\Omega h)^4$ 这一项。一个四阶方法对于具有有界导数的光滑函数是非常精确的，但对于导数快速增长的函数（如 $\\Omega$ 增大的情况），$\\mathcal{O}(h^5)$ 项中的常数可能会非常巨大，从而损害了方法的有效性，除非将 $h$ 设得小到不切实际。\n\n为了验证这一行为，我们将进行一个数值实验。初值问题是 $y'(t) = \\sin(\\Omega t)$，且 $y(0)=0$。\n精确解通过直接积分得到：当 $\\Omega \\neq 0$ 时，$y(t) = \\int_0^t \\sin(\\Omega s) ds = \\left[-\\frac{\\cos(\\Omega s)}{\\Omega}\\right]_0^t = \\frac{1 - \\cos(\\Omega t)}{\\Omega}$。当 $\\Omega = 0$ 时，$f(t)=0$，所以 $y(t)=0$。\n\n我们将计算：\n$1.$ 从 $t_0=0$ 开始、步长为 $h$ 的单步局部截断误差：$e_{\\mathrm{loc}}(0,h) = y(h) - y_1$，其中 $y_1$ 是从 $y_0 = y(0)=0$ 开始的一个 RK4 步骤的结果。\n$$ y_1 = \\frac{h}{6}\\left[f(0) + 4f\\left(\\frac{h}{2}\\right) + f(h)\\right] = \\frac{h}{6}\\left[0 + 4\\sin\\left(\\frac{\\Omega h}{2}\\right) + \\sin(\\Omega h)\\right] $$\n$2.$ 在 $T=1$ 时的全局截断误差：$e_{\\mathrm{glob}}(1,h) = y(1) - y_N$，其中 $y_N$ 是经过 $N=T/h$ 步后在 $t=1$ 时的数值解。\n数值解 $y_N$ 是通过递归应用 RK4 步骤计算的，在这种情况下，这相当于对每个子区间上的积分贡献求和：\n$$ y_N = \\sum_{n=0}^{N-1} \\frac{h}{6}\\left[f(t_n) + 4f\\left(t_n + \\frac{h}{2}\\right) + f(t_n + h)\\right] $$\n其中 $t_n = n \\cdot h$。\n\n所提供的测试用例将探讨在减小 $h$ 的同时增大 $\\Omega$，以使乘积 $\\Omega h$ 保持不变或增大的影响。对于用例 1 $(\\Omega=0, h=0.1)$，误差在解析上为零。对于用例 2、3、4，我们预计尽管相应地减小了 $h$，误差仍会随着 $\\Omega$ 的增大而急剧增加。该实现将为每个参数集计算 $|e_{\\mathrm{loc}}(0,h)|$ 和 $|e_{\\mathrm{glob}}(1,h)|$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes local and global truncation errors for the classical a\n    fourth-order Runge-Kutta method on a test ODE.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.0, 0.1),    # Case 1: (Omega, h)\n        (50.0, 0.02),   # Case 2\n        (200.0, 0.01),  # Case 3\n        (1000.0, 0.005) # Case 4\n    ]\n    \n    T = 1.0  # Final time for global error calculation.\n    \n    results = []\n    \n    for case in test_cases:\n        Omega, h = case\n        \n        # --- Define necessary functions ---\n        \n        def f(t, Omega_val):\n            \"\"\"The right-hand side of the ODE y'(t) = f(t).\"\"\"\n            return np.sin(Omega_val * t)\n            \n        def y_exact(t, Omega_val):\n            \"\"\"The exact solution of the IVP y'(t) = f(t), y(0)=0.\"\"\"\n            if Omega_val == 0.0:\n                return 0.0\n            return (1.0 - np.cos(Omega_val * t)) / Omega_val\n\n        # --- Task 4: Compute Local Truncation Error at t=0 ---\n        \n        # Exact solution at t=h\n        y_h_exact = y_exact(h, Omega)\n        \n        # One step of RK4 for y'(t)=f(t) from y(0)=0.\n        # This is equivalent to applying Simpson's rule to integrate f(t) from 0 to h.\n        # y_1 = y_0 + integral_approx\n        # y_0 = 0\n        t0 = 0.0\n        k1 = f(t0, Omega)\n        k2 = f(t0 + h / 2.0, Omega)\n        # k3 is the same as k2 since f is independent of y\n        k4 = f(t0 + h, Omega)\n        \n        y1_numerical = (h / 6.0) * (k1 + 4.0 * k2 + k4) # Using simplified 2*k2+2*k3 = 4*k2\n        \n        # Local truncation error at t=0\n        e_loc_mag = np.abs(y_h_exact - y1_numerical)\n        results.append(e_loc_mag)\n        \n        # --- Task 5: Compute Global Truncation Error at T=1 ---\n        \n        # Exact solution at t=T\n        y_T_exact = y_exact(T, Omega)\n\n        # Number of steps\n        # Given T/h is an integer for all test cases\n        N = int(round(T / h))\n        \n        y_numerical = 0.0\n        \n        # In this special case y'(t) = f(t), the global solution is the sum of\n        # the increments from each step.\n        for i in range(N):\n            ti = i * h\n            \n            # Since F(t,y) = f(t), the RK4 update is simply adding the\n            # Simpson's rule approximation of the integral over [ti, ti+h].\n            k1_global = f(ti, Omega)\n            k2_global = f(ti + h / 2.0, Omega)\n            k4_global = f(ti + h, Omega)\n            \n            increment = (h / 6.0) * (k1_global + 4.0 * k2_global + k4_global)\n            y_numerical += increment\n\n        # Global truncation error at T=1\n        e_glob_mag = np.abs(y_T_exact - y_numerical)\n        results.append(e_glob_mag)\n        \n    # Final print statement in the exact required format.\n    # Printing with many digits to avoid precision issues in evaluation.\n    print(f\"[{','.join(f'{r:.17f}' for r in results)}]\")\n\nsolve()\n```", "id": "2409196"}]}