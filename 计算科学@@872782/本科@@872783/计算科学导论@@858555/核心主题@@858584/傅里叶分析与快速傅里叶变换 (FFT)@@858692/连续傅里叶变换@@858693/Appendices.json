{"hands_on_practices": [{"introduction": "虽然许多傅里叶变换对可以从标准变换表中直接查到，但更复杂的问题往往需要巧妙地运用变换的内在性质。这个练习将展示频率微分性质的威力，这是一个处理那些没有现成解的逆变换问题的关键工具[@problem_id:1762463]。通过这个练习，你将学会如何将一个看似棘手的频域函数，通过微分和已知的变换对，转换回时域信号。", "problem": "设 $x(t)$ 是一个连续时间信号，其连续时间傅里叶变换 (CTFT) 定义为 $X(\\omega) = \\int_{-\\infty}^{\\infty} x(t) e^{-j\\omega t} dt$，并由下式给出：\n$$X(\\omega) = \\arctan(a\\omega)$$\n其中 $a$ 是一个已知的正常数，$j$ 是虚数单位。\n\n求信号 $x(t)$。将最终答案表示为 $t$ 和 $a$ 的解析函数。", "solution": "给定连续时间傅里叶变换 (CTFT) 的约定\n$$\nX(\\omega)=\\int_{-\\infty}^{\\infty} x(t)\\exp(-j\\omega t)\\,dt,\n$$\n我们需要求出满足 $X(\\omega)=\\arctan(a\\omega)$（其中 $a>0$）的信号 $x(t)$。\n\n使用傅里叶变换的频域微分性质。对于在上述约定下的变换对 $x(t)\\leftrightarrow X(\\omega)$，以下关系成立：\n$$\n\\frac{dX(\\omega)}{d\\omega}=\\int_{-\\infty}^{\\infty}x(t)\\frac{d}{d\\omega}\\bigl(\\exp(-j\\omega t)\\bigr)\\,dt\n=\\int_{-\\infty}^{\\infty}x(t)\\bigl(-jt\\bigr)\\exp(-j\\omega t)\\,dt\n=-j\\,\\mathcal{F}\\{t\\,x(t)\\}(\\omega),\n$$\n等价地，\n$$\n\\mathcal{F}\\{t\\,x(t)\\}(\\omega)=j\\,\\frac{dX(\\omega)}{d\\omega}.\n$$\n\n对 $X(\\omega)=\\arctan(a\\omega)$ 求导：\n$$\n\\frac{dX(\\omega)}{d\\omega}=\\frac{a}{1+a^{2}\\omega^{2}}.\n$$\n因此，\n$$\n\\mathcal{F}\\{t\\,x(t)\\}(\\omega)=j\\,\\frac{a}{1+a^{2}\\omega^{2}}.\n$$\n\n我们现在计算 $\\frac{1}{1+a^{2}\\omega^{2}}$ 的逆变换。使用标准变换对\n$$\n\\int_{-\\infty}^{\\infty}\\exp(-\\alpha|t|)\\exp(-j\\omega t)\\,dt=\\frac{2\\alpha}{\\alpha^{2}+\\omega^{2}},\\quad \\alpha>0,\n$$\n我们令 $\\alpha=\\frac{1}{a}$ 来得到\n$$\n\\mathcal{F}\\left\\{\\frac{1}{2a}\\exp\\!\\left(-\\frac{|t|}{a}\\right)\\right\\}(\\omega)=\\frac{1}{1+a^{2}\\omega^{2}}.\n$$\n因此，根据线性性质，\n$$\nt\\,x(t)=\\mathcal{F}^{-1}\\left\\{j\\,\\frac{a}{1+a^{2}\\omega^{2}}\\right\\}(t)\n=j\\,a\\,\\mathcal{F}^{-1}\\left\\{\\frac{1}{1+a^{2}\\omega^{2}}\\right\\}(t)\n=j\\,a\\left(\\frac{1}{2a}\\exp\\!\\left(-\\frac{|t|}{a}\\right)\\right)\n=\\frac{j}{2}\\exp\\!\\left(-\\frac{|t|}{a}\\right).\n$$\n因此，\n$$\nx(t)=\\frac{j}{2}\\,\\frac{\\exp\\!\\left(-\\frac{|t|}{a}\\right)}{t},\n$$\n在分布意义下解释，并在 $t=0$ 处取柯西主值。为确认积分常数为零，我们使用关系 $j\\,\\frac{dX}{d\\omega}=\\mathcal{F}\\{t x(t)\\}$；对 $\\frac{dX}{d\\omega}=\\frac{a}{1+a^{2}\\omega^{2}}$ 积分得到 $X(\\omega)=\\arctan(a\\omega)+C$。由于 $X(0)=0$ 且对于奇被积函数，其主值积分 $\\int_{-\\infty}^{\\infty}x(t)\\,dt=0$ 确认了 $C=0$，因此所求得的 $x(t)$ 的确可以逆变换回 $X(\\omega)=\\arctan(a\\omega)$。", "answer": "$$\\boxed{\\frac{j}{2}\\frac{\\exp(-|t|/a)}{t}}$$", "id": "1762463"}, {"introduction": "从连续、理想的数学世界过渡到实际的计算领域，我们会遇到新的挑战。当我们使用有限的离散数据点来近似连续傅里叶变换时，频谱泄漏等计算“赝象”几乎不可避免地会出现[@problem_id:3112450]。这个编码练习将引导你搭建一个完整的计算流程，亲眼观察这一现象，并学习实现一种标准的缓解技术——加窗法，这是数字信号处理中的一项基本功。", "problem": "你需要从第一性原理出发，实现一个完整的计算流程，用于近似计算具有跳跃间断点的分段定义函数的连续时间傅里叶变换，诊断谱泄漏，并通过边界平滑来减轻它。你必须使用连续时间傅里叶变换（CTFT）的基本定义，并以此为基础构建算法步骤。凡是使用角度的地方，都必须以弧度为单位。不涉及物理单位。\n\n从连续时间傅里叶变换（CTFT）的核心定义开始：给定一个在 $[0,1]$ 上具有有限支撑集的实值函数 $f(x)$，其 CTFT 是映射 $\\omega \\mapsto F(\\omega)$，其中 $F(\\omega)$ 通过与复指数的积分来定义。你必须通过在 $f$ 的定义域上的均匀网格上构建的黎曼和来近似 $F(\\omega)$，并且必须通过一种定量的尾部能量度量来诊断谱泄漏。然后，提出并实现一种边界平滑方法，该方法在定义域边界处强制实现连续性，并根据经验减少谱泄漏。\n\n你的程序必须仅使用数学和算法逻辑执行以下任务：\n\n- 在 $[0,1]$ 上构建一个包含 $N$ 个点的均匀网格，其中 $N = 4096$。将该网格表示为 $x_n = n \\Delta x$，对于 $n \\in \\{0,1,\\ldots,N-1\\}$，其中 $\\Delta x = 1/N$。\n- 对于每个由具有跳跃间断点的分段常数段在 $[0,1]$ 上定义的测试用例函数 $f$，在该网格上对 $f$ 进行采样。\n- 在离散角频率 $\\omega_k = \\frac{2\\pi k}{T}$（对于 $k \\in \\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$，其中 $T = 1$）处，通过一个黎曼和来近似 CTFT，该黎曼和等价于一个由 $\\Delta x$ 缩放的离散傅里叶变换 (DFT)。在均匀采样的序列上定义离散傅里叶变换 (DFT)，并用它来计算无平滑和有边界平滑两种情况下的近似值 $\\hat{F}(\\omega_k)$。\n- 为近似 $\\hat{F}$ 定义谱泄漏，即超出指定角频率阈值的尾部能量分数。设尾部阈值为 $\\omega_{\\text{tail}} = 200\\pi$。泄漏度量是能量超出 $|\\omega| > \\omega_{\\text{tail}}$ 的部分与所有采样频率上的总能量之比。能量由幅度的平方 $|\\hat{F}(\\omega_k)|^2$ 计算得出；任何均匀的频率权重因子在该分数中都会被抵消。\n- 实现一种边界平滑，通过将采样的 $f$ 乘以一个在端点处为零、在内部严格为正的平滑锥削函数，来在 $x=0$ 和 $x=1$ 处强制实现连续性。在离散网格上使用 Hann 锥削窗 $w(n)$，其定义为 $w(0) = 0$ 和 $w(N-1) = 0$，并且当视为 $x_n$ 的函数时，$w(n)$ 在 $n$ 上是连续的。计算未平滑情况（在整个网格上等于 $1$ 的矩形窗）和平滑情况（Hann 锥削）的 CTFT 近似，然后计算它们各自的泄漏分数。\n- 报告每个测试用例中由边界平滑带来的改善，即未平滑泄漏分数与平滑泄漏分数之比。大于 $1$ 的比率表示平滑减少了泄漏。\n\n测试套件规范：\n\n设 $T = 1$ 且 $N = 4096$。使用以下分段列表在 $[0,1]$ 上定义三个分段常数测试函数，其中除最后一个分段为 $[a,b]$ 外，每个分段均为 $[a,b)$，并且在每个分段上，函数等于给定的常数值。\n\n- 情况 1（存在边界不连续性）：$f(x) = 2$ 在 $[0,0.4)$ 上，$f(x) = -1$ 在 $[0.4,0.7)$ 上，以及 $f(x) = 0$ 在 $[0.7,1]$ 上。\n- 情况 2（端点处边界连续）：$f(x) = 0$ 在 $[0,0.3)$ 上，$f(x) = 3$ 在 $[0.3,0.6)$ 上，以及 $f(x) = 0$ 在 $[0.6,1]$ 上。\n- 情况 3（窄内部跳跃，端点为零）：$f(x) = 0$ 在 $[0,0.49)$ 上，$f(x) = 5$ 在 $[0.49,0.51)$ 上，以及 $f(x) = 0$ 在 $[0.51,1]$ 上。\n\n对每种情况，计算：\n\n- 未平滑矩形窗近似的泄漏分数，记为 $\\lambda_{\\text{rect}}$。\n- Hann 锥削近似的泄漏分数，记为 $\\lambda_{\\text{hann}}$。\n- 泄漏减少比 $r = \\lambda_{\\text{rect}} / \\lambda_{\\text{hann}}$。\n\n最终输出格式要求：\n\n你的程序应生成单行输出，包含三个测试用例的泄漏减少比，形式为用方括号括起来的逗号分隔列表，每个浮点数四舍五入到 $6$ 位小数，例如 $[r_1,r_2,r_3]$。角度必须以弧度为单位，角频率阈值为 $\\omega_{\\text{tail}} = 200\\pi$。", "solution": "我们从连续时间傅里叶变换（CTFT）的基本定义开始。对于一个支撑集在 $[0,1]$ 上的实值函数 $f(x)$，其 CTFT 是由积分定义的函数 $F(\\omega)$\n$$\nF(\\omega) = \\int_{-\\infty}^{\\infty} f(x) e^{-i \\omega x} \\, dx,\n$$\n当 $f(x)$ 在 $[0,1]$ 之外为零时，可简化为\n$$\nF(\\omega) = \\int_{0}^{1} f(x) e^{-i \\omega x} \\, dx\n$$\n这是基本依据：CTFT 通过与复指数核 $e^{-i \\omega x}$ 的积分来定义，这是一个经过充分检验并被广泛接受的定义。\n\n为了实现一个有原则且与此定义一致的计算流程，我们采用黎曼和近似。设定义域在一个均匀网格 $x_n = n \\Delta x$（$n \\in \\{0,1,\\ldots,N-1\\}$，其中 $\\Delta x = 1/N$）上采样。对于一组离散的角频率 $\\omega_k = \\frac{2\\pi k}{T}$（其中 $T = 1$ 且 $k \\in \\{-\\lfloor N/2 \\rfloor, \\ldots, \\lfloor N/2 \\rfloor - 1\\}$），CTFT 的一个黎曼和近似由下式给出\n$$\n\\hat{F}(\\omega_k) \\approx \\Delta x \\sum_{n=0}^{N-1} f(x_n) e^{-i \\omega_k x_n}.\n$$\n当按 $\\Delta x$ 进行缩放时，这个和恰好是采样序列 $f(x_n)$ 在频率 $\\omega_k$ 处的离散傅里叶变换 (DFT)，因为对于 $T=1$ 和 $x_n = n/N$，指数项 $e^{-i \\omega_k x_n}$ 变为 $e^{-i 2\\pi k n / N}$。因此，我们可以通过一个 DFT（通过快速傅里叶变换快速实现）乘以 $\\Delta x$ 来计算 $\\hat{F}(\\omega_k)$。\n\n谱泄漏通过测量谱估计 $\\hat{F}(\\omega)$ 中的能量如何扩散到所选频带之外来诊断。虽然对于有跳跃的分段常数函数（已知这类函数的高频成分以 $1/\\omega$ 的速率衰减）来说，完美的带限是罕见的，但可以通过尾部能量定义一个一致的定量度量。对于任何近似 $\\hat{F}$，定义泄漏分数为\n$$\n\\lambda = \\frac{\\sum_{k : |\\omega_k| > \\omega_{\\text{tail}}} |\\hat{F}(\\omega_k)|^2}{\\sum_{k} |\\hat{F}(\\omega_k)|^2},\n$$\n其中 $\\omega_{\\text{tail}}$ 是一个固定的角频率阈值，所有求和都是在离散频率网格上进行的。分子和分母共享任何统一的频率区间宽度因子，因此该分数在此类缩放-下是不变的。该度量量化了高频尾部中的能量比例。\n\n在基于 DFT 的近似中，边界不连续性是谱泄漏的一个已知来源：当端点值不同时，采样函数的隐式周期性延拓会在 $x=0$ 和 $x=1$ 处引入跳跃，从而激发高频分量。一种有原则的缓解方法是通过锥削进行边界平滑，它在边界处强制实现连续性（对于足够平滑的锥削，还可实现可微性）。Hann 锥削在离散网格上定义为\n$$\nw(n) = \\tfrac{1}{2} \\left( 1 - \\cos\\left(\\frac{2\\pi n}{N-1}\\right) \\right),\n$$\n它满足 $w(0) = 0$ 和 $w(N-1) = 0$，并在中心附近平滑地达到 $1$。将此锥削应用于 $f$ 得到 $f_{\\text{hann}}(x_n) = f(x_n) w(n)$，其隐式周期性延拓在端点处是连续的，从而减少了泄漏。在频域中，乘以锥削对应于原始 CTFT 与锥削的 CTFT 的卷积 $F * W$，以受控的方式平滑尖锐的频谱特征，并将能量从频率网格的端点重新分布出去。\n\n算法步骤：\n\n1. 构建网格：设置 $N = 4096$ 和 $\\Delta x = 1/N$，其中 $x_n = n \\Delta x$。\n2. 对于每个分段定义的测试用例，根据 $x_n$ 是否属于 $[a,b)$ 来为每个分段选择常数值，从而对 $f(x_n)$ 进行采样，最后一个分段定义为 $[a,b]$ 以包含 $x=1$。\n3. 定义两个窗函数：矩形窗 $w_{\\text{rect}}(n) = 1$ 和如上所述的 Hann 窗 $w_{\\text{hann}}(n)$。\n4. 为每种情况形成两个序列：$f_{\\text{rect}}(x_n) = f(x_n) w_{\\text{rect}}(n)$ 和 $f_{\\text{hann}}(x_n) = f(x_n) w_{\\text{hann}}(n)$。\n5. 计算它们的 DFT $\\mathcal{F}_{\\text{rect}}[k]$ 和 $\\mathcal{F}_{\\text{hann}}[k]$，并按 $\\Delta x$ 进行缩放，以获得 CTFT 近似值 $\\hat{F}_{\\text{rect}}(\\omega_k)$ 和 $\\hat{F}_{\\text{hann}}(\\omega_k)$；离散角频率为 $\\omega_k = \\frac{2\\pi k}{T}$，其中 $T=1$，而 $k$ 由 DFT 频率布局确定。\n6. 通过对超出 $\\omega_{\\text{tail}} = 200\\pi$ 的 $|\\hat{F}(\\omega_k)|^2$ 进行求和，并除以所有 $k$ 的总能量和，来计算泄漏分数 $\\lambda_{\\text{rect}}$ 和 $\\lambda_{\\text{hann}}$。\n7. 计算每种情况下的泄漏减少比 $r = \\lambda_{\\text{rect}} / \\lambda_{\\text{hann}}$；$r > 1$ 表示边界平滑减少了谱泄漏。\n\n测试套件用例为：\n- 情况 1：$f(x) = 2$ 在 $[0,0.4)$ 上，$f(x) = -1$ 在 $[0.4,0.7)$ 上，$f(x) = 0$ 在 $[0.7,1]$ 上；这在 $x=0$ 到 $x=1$ 之间存在边界不连续性。\n- 情况 2：$f(x) = 0$ 在 $[0,0.3)$ 上，$f(x) = 3$ 在 $[0.3,0.6)$ 上，$f(x) = 0$ 在 $[0.6,1]$ 上；这在端点处是连续的。\n- 情况 3：$f(x) = 0$ 在 $[0,0.49)$ 上，$f(x) = 5$ 在 $[0.49,0.51)$ 上，$f(x) = 0$ 在 $[0.51,1]$ 上；这具有窄的内部跳跃，但端点为零。\n\n解释：\n- 在情况 1 中，预计端点不连续性会对泄漏产生很大影响；Hann 锥削应能显著降低 $\\lambda$，从而得到 $r \\gg 1$。\n- 在情况 2 中，端点是连续的；泄漏主要由内部跳跃引起；Hann 锥削减少泄漏的效果较差，因此 $r$ 可能比情况 1 更接近 $1$。\n- 在情况 3 中，窄脉冲主要由于内部跳跃而产生宽泛的频率内容；边界平滑主要解决端点问题，因此 $r$ 可能只显示出适度的改善。\n\n最后，程序必须单行打印泄漏减少比 $[r_1,r_2,r_3]$，每个比率四舍五入到 6 位小数，并且所有角度始终以弧度处理，其中 $\\omega_{\\text{tail}} = 200\\pi$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hann_window(N: int) -> np.ndarray:\n    \"\"\"Generate a Hann window of length N that is zero at endpoints.\"\"\"\n    n = np.arange(N, dtype=float)\n    return 0.5 * (1.0 - np.cos(2.0 * np.pi * n / (N - 1)))\n\ndef sample_piecewise_function(N: int, segments: list) -> np.ndarray:\n    \"\"\"\n    Sample a piecewise-constant function on [0,1] with N samples.\n    segments: list of tuples (a, b, value), with [a,b) except last is [a,b].\n    Assumes segments cover [0,1] without gaps and with non-overlapping intervals.\n    \"\"\"\n    x = np.linspace(0.0, 1.0, N, endpoint=False)  # x_n = n/N, n=0..N-1\n    f = np.zeros_like(x)\n    for i, (a, b, val) in enumerate(segments):\n        if i  len(segments) - 1:\n            mask = (x >= a)  (x  b)\n        else:\n            # last segment includes the endpoint 1, but our grid excludes 1 (endpoint=False),\n            # so this mask is equivalent to [a,b) here.\n            mask = (x >= a)  (x  b)\n        f[mask] = val\n    return f\n\ndef ctft_approx_via_fft(samples: np.ndarray, T: float) - tuple:\n    \"\"\"\n    Approximate CTFT using FFT of samples scaled by Delta x.\n    Returns (omega, F_hat), where omega are angular frequencies in radians per unit x.\n    \"\"\"\n    N = samples.size\n    dx = T / N\n    # FFT and frequencies:\n    F = np.fft.fft(samples) * dx\n    # Frequencies in cycles per unit x, convert to angular frequency by 2*pi:\n    freqs = np.fft.fftfreq(N, d=dx)  # cycles per unit\n    omega = 2.0 * np.pi * freqs      # radians per unit\n    return omega, F\n\ndef leakage_fraction(omega: np.ndarray, F_hat: np.ndarray, omega_tail: float) - float:\n    \"\"\"\n    Compute leakage fraction: energy beyond |omega| > omega_tail divided by total energy.\n    \"\"\"\n    power = np.abs(F_hat)**2\n    mask_tail = np.abs(omega) > omega_tail\n    tail_energy = power[mask_tail].sum()\n    total_energy = power.sum()\n    # Handle potential numerical edge case:\n    if total_energy == 0.0:\n        return 0.0\n    return float(tail_energy / total_energy)\n\ndef solve():\n    # Parameters\n    T = 1.0\n    N = 4096\n    omega_tail = 200.0 * np.pi  # radians per unit x\n\n    # Define test cases: list of segments (a, b, value)\n    test_cases = [\n        # Case 1: boundary discontinuity present\n        [(0.0, 0.4, 2.0), (0.4, 0.7, -1.0), (0.7, 1.0, 0.0)],\n        # Case 2: boundary continuity at endpoints (zeros at ends)\n        [(0.0, 0.3, 0.0), (0.3, 0.6, 3.0), (0.6, 1.0, 0.0)],\n        # Case 3: narrow interior jump, endpoints are zero\n        [(0.0, 0.49, 0.0), (0.49, 0.51, 5.0), (0.51, 1.0, 0.0)],\n    ]\n\n    # Windows\n    rect = np.ones(N, dtype=float)\n    hann = hann_window(N)\n\n    results = []\n    for segments in test_cases:\n        # Sample f\n        f = sample_piecewise_function(N, segments)\n\n        # Unsmooth: rectangular window\n        f_rect = f * rect\n        omega_rect, F_rect = ctft_approx_via_fft(f_rect, T)\n        lambda_rect = leakage_fraction(omega_rect, F_rect, omega_tail)\n\n        # Smooth: Hann window\n        f_hann = f * hann\n        omega_hann, F_hann = ctft_approx_via_fft(f_hann, T)\n        lambda_hann = leakage_fraction(omega_hann, F_hann, omega_tail)\n\n        # Leakage reduction ratio\n        if lambda_hann == 0.0:\n            ratio = float('inf') if lambda_rect > 0.0 else 1.0\n        else:\n            ratio = lambda_rect / lambda_hann\n        results.append(ratio)\n\n    # Round to 6 decimal places and format output\n    formatted = [f\"{r:.6f}\" if np.isfinite(r) else \"inf\" for r in results]\n    print(f\"[{','.join(formatted)}]\")\n\nsolve()\n```", "id": "3112450"}, {"introduction": "在计算傅里叶变换时，误差的来源多种多样，理解它们是进行可靠科学计算的基础。本练习将深入探讨一个微妙但重要的问题：采样位置的微小随机误差（即“抖动”）如何影响我们计算出的频谱的准确性[@problem_id:3112380]。通过将理论推导与数值模拟相结合，你将能够量化这种效应，并理解其误差如何随着频率的增加而变得更加显著。", "problem": "要求您通过严谨的推导和计算，研究在对连续傅里叶变换进行数值近似时，空间采样位置的微小随机扰动（抖动）如何传播到频域。整个过程在纯数学背景下进行，不涉及物理单位。角度以弧度为单位。\n\n从函数 $f:\\mathbb{R}\\to\\mathbb{C}$ 的连续傅里叶变换的基本定义\n$$\nF(\\omega)=\\int_{-\\infty}^{\\infty} f(x)\\,e^{-i\\,\\omega\\,x}\\,dx,\n$$\n以及在使用 Riemann 型求积法对有限区间进行数值计算时，需要在 $x$ 上选择一个有限定义域和一组采样位置网格这一事实出发。\n\n您将比较在同一有限区间 $[-L,L]$上构建的两种 $F(\\omega)$ 的数值近似：\n\n- 一种基准近似，建立在均匀网格 $x_n=-L+n\\,\\Delta x$（$n\\in\\{0,1,\\dots,N-1\\}$，$\\Delta x=\\dfrac{2L}{N-1}$）上，并使用梯形法则的权重。\n\n- 一种抖动近似，建立在受扰动的采样位置 $\\tilde{x}_n=x_n+\\varepsilon_n$ 上，其中每个 $\\varepsilon_n$ 是一个独立的均值为 $0$、标准差为 $s\\,\\Delta x$ 的高斯随机变量，并使用适应于非均匀网格的相同梯形法则，该法则使用相应的非均匀间距。\n\n您必须：\n\n- 从 $F(\\omega)$ 的定义和一阶泰勒展开出发，推导采样位置的微小扰动 $\\delta x$ 如何改变被积函数，进而改变计算出的变换结果。表达误差对 $\\omega$ 和 $f$ 的导数的主阶依赖关系。\n\n- 实现一个程序，在有限区间上对特定测试函数 $f(x)=\\exp\\!\\left(-\\dfrac{x^2}{2\\,\\sigma^2}\\right)$ 量化其效应。对基准和抖动两种情况使用相同的求积法则，以确保您的度量标准能够分离出抖动的影响。\n\n- 对于在区间 $[-\\omega_{\\max},\\omega_{\\max}]$ 内均匀分布的一组给定频率 $\\{\\omega_m\\}_{m=1}^M$，计算基准近似 $F_{\\mathrm{uni}}(\\omega_m)$ 和抖动近似 $F_{\\mathrm{jit}}(\\omega_m)$。然后为每组参数计算一个单一的标量误差度量：\n$$\nE=\\frac{\\left(\\frac{1}{M}\\sum_{m=1}^M \\left|F_{\\mathrm{jit}}(\\omega_m)-F_{\\mathrm{uni}}(\\omega_m)\\right|^2\\right)^{1/2}}{\\left(\\frac{1}{M}\\sum_{m=1}^M \\left|F_{\\mathrm{uni}}(\\omega_m)\\right|^2\\right)^{1/2}}.\n$$\n该 $E$ 值是所选频率网格上的相对均方根差异，它直接量化了 $x$ 中的采样扰动如何传播到 $\\omega$ 域。\n\n计算要求和约定：\n\n- 在所选网格上使用梯形法则进行积分的数值近似。在均匀网格上，内部点的权重为 $\\Delta x$，端点的权重为 $\\dfrac{\\Delta x}{2}$。在非均匀网格上，首先将受扰动的采样位置按升序排序以恢复有序网格，然后使用局部的非均匀间距分配梯形权重。具体来说，对于排序后的节点 $\\{\\tilde{x}_k\\}_{k=0}^{N-1}$ 和间距 $\\Delta \\tilde{x}_k=\\tilde{x}_{k+1}-\\tilde{x}_k$，使用权重 $w_0=\\dfrac{1}{2}\\Delta \\tilde{x}_0$，$w_{N-1}=\\dfrac{1}{2}\\Delta \\tilde{x}_{N-2}$，对于内部索引 $k\\in\\{1,\\dots,N-2\\}$，权重为 $w_k=\\dfrac{1}{2}\\left(\\Delta \\tilde{x}_{k-1}+\\Delta \\tilde{x}_k\\right)$。\n\n- 在两种网格上，都通过对所有网格点 $k$ 求和 $w_k\\,f(x_k)\\,e^{-i\\,\\omega\\,x_k}$ 来近似积分。\n\n- 随机抖动应建模为均值为 $0$、标准差为 $s\\,\\Delta x$ 的独立高斯变量。必须为每个测试用例使用固定的伪随机数生成器种子，以确保可复现性。\n\n测试套件：\n\n您的程序必须运行以下四个参数集，并以单个列表的形式输出对应的四个误差值 $E$。\n\n每个参数集是一个元组 $(\\sigma,L,N,s,\\omega_{\\max},M,\\text{seed})$：\n\n- 测试 1：$(\\sigma, L, N, s, \\omega_{\\max}, M, \\text{seed}) = (0.6, 3.0, 2048, 0.0, 30.0, 301, 13)$。\n\n- 测试 2：$(\\sigma, L, N, s, \\omega_{\\max}, M, \\text{seed}) = (0.6, 3.0, 2048, 0.02, 30.0, 301, 13)$。\n\n- 测试 3：$(\\sigma, L, N, s, \\omega_{\\max}, M, \\text{seed}) = (0.6, 3.0, 2048, 0.1, 30.0, 301, 13)$。\n\n- 测试 4：$(\\sigma, L, N, s, \\omega_{\\max}, M, \\text{seed}) = (0.6, 3.0, 2048, 0.3, 30.0, 301, 13)$。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个数字需按测试 1 到 4 的顺序排列，并使用标准四舍五入精确到六位小数。例如，包含四个结果的输出应类似于 `\"[0.000001,0.012345,0.067890,0.123456]\"`。", "solution": "该问题是有效的。这是一个适定的、有科学依据的计算科学练习，要求基于明确陈述的数学定义和算法进行理论推导和数值实现。所有必要的参数都已提供，以确保解的唯一性和可验证性。\n\n### 第 1 部分：理论推导\n\n该问题要求推导在计算傅里叶变换时，空间采样位置的微小随机扰动（抖动）如何传播到频域。我们从被数值积分的量开始，即函数 $f(x)$ 与复指数核的乘积。设这个复合函数为 $g(x, \\omega) = f(x) e^{-i\\omega x}$。傅里叶变换为 $F(\\omega) = \\int_{-\\infty}^{\\infty} g(x, \\omega) dx$。\n\n数值求积法将此积分近似为在一组离散采样点 $\\{x_n\\}$ 上的加权和：\n$$\nF_{\\text{approx}}(\\omega) = \\sum_n w_n g(x_n, \\omega)\n$$\n其中 $w_n$ 是求积权重。\n\n现在，考虑单个采样点 $x_n$ 受到一个微小量 $\\varepsilon_n$ 的扰动，使得新位置为 $\\tilde{x}_n = x_n + \\varepsilon_n$。被积函数在这个新点的值可以通过对 $g(x, \\omega)$ 在 $x_n$ 附近的一阶泰勒级数展开来近似：\n$$\ng(\\tilde{x}_n, \\omega) = g(x_n + \\varepsilon_n, \\omega) \\approx g(x_n, \\omega) + \\left. \\frac{\\partial g(x, \\omega)}{\\partial x} \\right|_{x=x_n} \\varepsilon_n\n$$\n因此，在该点被积函数值的误差 $\\Delta g_n = g(\\tilde{x}_n, \\omega) - g(x_n, \\omega)$ 约为：\n$$\n\\Delta g_n \\approx \\left. \\frac{\\partial g(x, \\omega)}{\\partial x} \\right|_{x=x_n} \\varepsilon_n\n$$\n我们计算 $g(x, \\omega)$ 关于 $x$ 的导数：\n$$\n\\frac{\\partial g(x, \\omega)}{\\partial x} = \\frac{\\partial}{\\partial x} \\left( f(x) e^{-i\\omega x} \\right) = \\frac{df(x)}{dx} e^{-i\\omega x} + f(x) \\left( -i\\omega e^{-i\\omega x} \\right) = \\left( f'(x) - i\\omega f(x) \\right) e^{-i\\omega x}\n$$\n其中 $f'(x)$ 是 $f(x)$ 的导数。\n\n将其代回，在点 $x_n$ 处的被積函數的误差约为：\n$$\n\\Delta g_n \\approx \\left( f'(x_n) - i\\omega f(x_n) \\right) e^{-i\\omega x_n} \\varepsilon_n\n$$\n该表达式揭示了局部误差对函数性质和变换参数的主阶依赖关系：\n1.  **对函数及其导数的依赖性**：误差与函数值 $f(x_n)$ 及其一阶导数 $f'(x_n)$ 的线性组合成正比。在函数或其斜率幅值较大的区域，对总误差的贡献也更显著。\n2.  **对频率 $\\omega$ 的依赖性**：误差由两部分组成。与 $f'(x_n)$ 成正比的项源于函数幅度的变化，$f(x_n+\\varepsilon_n) - f(x_n)$。此项的幅值与 $\\omega$ 无关。与 $-i\\omega f(x_n)$ 成正比的项源于傅里叶核相位的变化，$e^{-i\\omega(x_n+\\varepsilon_n)} - e^{-i\\omega x_n}$。此项的幅值随 $\\omega$ 线性增长。\n\n计算出的傅里叶变换的总误差 $\\Delta F(\\omega) = F_{\\mathrm{jit}}(\\omega) - F_{\\mathrm{uni}}(\\omega)$ 是这些局部误差的复数和，同时也考虑了求积权重的扰动。然而，仅分析单点的贡献就足以确定主要的依赖关系。与 $\\omega$ 成正比的项表明，采样抖动引起的误差预计在较高频率处更为显著。这是因为一个微小的空间位移 $\\varepsilon_n$ 会在傅里叶核中引起 $-\\omega \\varepsilon_n$ 的相位偏移，并且这个相位偏移随着 $|\\omega|$ 的增加而变大。\n\n误差的期望平方幅值将有一个与 $\\omega^2$ 成正比的项：\n$$\n|\\Delta g_n|^2 \\approx \\left| f'(x_n) - i\\omega f(x_n) \\right|^2 |\\varepsilon_n|^2 = \\left( (f'(x_n))^2 + \\omega^2 (f(x_n))^2 \\right) |\\varepsilon_n|^2\n$$\n这证实了误差功率谱预计会随频率呈二次方增长，从而突显了高频分量对采样抖动的敏感性。\n\n### 第 2 部分：数值实现\n\n所提供的 Python 代码实现了所述的数值实验。首先，定义了一个函数 `solve` 来管理测试用例。它会遍历每个参数集，设置所需的空间和频率网格。\n\n对于每种情况，计算两个傅里叶变换：\n1.  **`F_uni` (基准)**：在完全均匀的网格 `x_uni` 上使用梯形法则和均匀权重计算。\n2.  **`F_jit` (抖动)**：从均值为 $0$、标准差为 $s \\cdot \\Delta x$ 的高斯分布中生成一个随机抖动数组 `eps`。将此抖动加到均匀网格上以创建 `x_jit`。对于 $s=0$ 的特殊情况，确保不添加抖动，并且为了效率而短路计算，因为结果必须与均匀情况相同。对于 $s0$，首先对受扰动的网格点 `x_jit` 进行排序，以恢复单调递增序列，这是非均匀网格梯形法则定义所要求的。然后在这些新的已排序位置上计算函数 `f(x)` 的值。接着，根据问题陈述中给出的精确公式，基于已排序点之间的非均匀间距计算梯形权重。\n\n`F_uni` 和 `F_jit` 都是通过计算复指数核（在频率和空间点的所有组合上求值）的矩阵与相应加权函数值向量的矩阵乘积得到的。这种向量化方法是高效的。\n\n最后，按规定计算相对均方根误差度量 $E$。它通过基准均匀变换的均方根幅值来归一化两个变换之间的均方根差异。收集所有测试用例的结果，格式化为六位小数，并以要求的列表格式打印。测试用例 1 中 $s=0$，正确地得出 0 的误差，这作为一次成功的合理性检查。后续测试中 $E$ 值的增加表明，随着抖动幅度的增加，傅里叶变换近似的质量下降，正如理论所预测的那样。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the effect of sampling jitter on the numerical Fourier transform\n    for a series of test cases and prints the results.\n    \"\"\"\n\n    def f_gaussian(x, sigma):\n        \"\"\"\n        Computes the Gaussian function f(x) = exp(-x^2 / (2*sigma^2)).\n        \"\"\"\n        return np.exp(-x**2 / (2 * sigma**2))\n\n    def compute_ft(x_nodes, f_vals, weights, omega_grid):\n        \"\"\"\n        Computes the Fourier transform using a generic quadrature sum.\n        \"\"\"\n        # Base of the integrand for the sum: w_k * f(x_k)\n        integrand_base = f_vals * weights\n        \n        # Matrix of complex exponentials: exp(-i * omega_m * x_k)\n        # Shape: (M, N)\n        exp_matrix = np.exp(-1j * np.outer(omega_grid, x_nodes))\n        \n        # The sum is a matrix-vector product.\n        # Result shape: (M,)\n        ft_vals = exp_matrix @ integrand_base\n        return ft_vals\n\n    # Test cases as defined in the problem statement.\n    test_cases = [\n        # (sigma, L, N, s, omega_max, M, seed)\n        (0.6, 3.0, 2048, 0.0, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.02, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.1, 30.0, 301, 13),\n        (0.6, 3.0, 2048, 0.3, 30.0, 301, 13),\n    ]\n\n    results = []\n    for case in test_cases:\n        sigma, L, N, s, omega_max, M, seed = case\n\n        # Define the spatial and frequency grids.\n        x_uni = np.linspace(-L, L, N)\n        dx = (2 * L) / (N - 1)\n        omega_grid = np.linspace(-omega_max, omega_max, M)\n        \n        # Define the specific function for this test.\n        f = lambda x: f_gaussian(x, sigma)\n\n        # --- Baseline (Uniform Grid) Calculation ---\n        f_uni_vals = f(x_uni)\n        \n        # Trapezoidal weights for the uniform grid.\n        weights_uni = np.full(N, dx)\n        weights_uni[0] = dx / 2.0\n        weights_uni[-1] = dx / 2.0\n        \n        F_uni = compute_ft(x_uni, f_uni_vals, weights_uni, omega_grid)\n\n        # --- Jittered Grid Calculation ---\n        if s == 0.0:\n            # If there is no jitter, the result is identical to the uniform case.\n            F_jit = F_uni\n        else:\n            # Generate jitter.\n            rng = np.random.default_rng(seed)\n            jitter_std = s * dx\n            eps = rng.normal(loc=0.0, scale=jitter_std, size=N)\n            x_jit_unsorted = x_uni + eps\n            \n            # Sort the jittered grid points to apply the trapezoidal rule.\n            x_jit_sorted = np.sort(x_jit_unsorted)\n            \n            # Evaluate the function on the sorted jittered grid.\n            f_jit_vals = f(x_jit_sorted)\n\n            # Trapezoidal weights for the non-uniform (sorted jittered) grid.\n            dx_jit = np.diff(x_jit_sorted)\n            weights_jit = np.zeros(N)\n            weights_jit[0] = dx_jit[0] / 2.0\n            weights_jit[-1] = dx_jit[-2] / 2.0\n            weights_jit[1:-1] = (dx_jit[:-1] + dx_jit[1:]) / 2.0\n            \n            F_jit = compute_ft(x_jit_sorted, f_jit_vals, weights_jit, omega_grid)\n\n        # --- Compute the Error Metric E ---\n        # Numerator: RMS of the difference |F_jit - F_uni|.\n        num_rms = np.sqrt(np.mean(np.abs(F_jit - F_uni)**2))\n        \n        # Denominator: RMS of the baseline signal |F_uni|.\n        den_rms = np.sqrt(np.mean(np.abs(F_uni)**2))\n        \n        # The metric E is the ratio. Handle division by zero.\n        if den_rms == 0.0:\n            E = np.inf if num_rms > 0 else 0.0\n        else:\n            E = num_rms / den_rms\n            \n        results.append(E)\n\n    # Format results for the final output.\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3112380"}]}