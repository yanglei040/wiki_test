{"hands_on_practices": [{"introduction": "虽然卷积和互相关在概念上密切相关，但它们的计算机制存在本质区别。本练习旨在通过编程实践，深入探讨核函数的对称性和边界条件（循环与线性）如何决定这两种运算结果的异同。通过亲手构造信号并验证其在不同条件下的行为，你将对这两种基本运算建立起精确而深刻的理解。[@problem_id:3114298]", "problem": "你需要编写一个完整、可运行的程序，该程序为精心选择的实值信号，在两种边界模型（循环边界条件和补零）下，构建并比较离散卷积和离散互相关。请基于离散卷积和离散互相关的核心定义进行操作。\n\n使用以下基本定义作为你推理和实现的基础。对于两个长度分别为 $N_x$ 和 $N_h$ 的有限长度实值离散时间信号 $x[n]$ 和 $h[n]$：\n- 线性卷积（使用补零）定义为\n$$\ny_{\\text{lin}}[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\;h[k-n],\n$$\n约定在其支持索引范围之外的值被视为零。实际上，对于在 $0 \\le n \\le N_x-1$ 上有定义的有限信号 $x[n]$ 和在 $0 \\le n \\le N_h-1$ 上有定义的 $h[n]$，此求和可简化为 $x[n]$ 和 $h[k-n]$ 均在其支持域内有定义的索引。输出长度为 $N_x + N_h - 1$。\n- 线性互相关（使用补零）定义为\n$$\nr_{xh,\\text{lin}}[k] = \\sum_{n=-\\infty}^{\\infty} x[n]\\;h[n+k],\n$$\n同样，其支持索引范围之外的值被视为零。\n- 对于周期为 $N$ 的循环边界条件（Circular Boundary Conditions, CBC），循环卷积定义为\n$$\ny_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(k-n)\\bmod N],\n$$\n循环互相关定义为\n$$\nr_{xh,\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(n+k)\\bmod N],\n$$\n对于 $0 \\le k \\le N-1$。\n\n你的任务是设计信号 $x[n]$ 和 $h[n]$，使得循环卷积 $x \\circledast h$ 和循环互相关 $r_{xh,\\text{circ}}[k]$ 在数值上相等，而线性（补零）卷积和线性互相关不相等。你必须从原理上解释为什么会发生这种情况，并明确指出翻转（时间反转）和边界模型的作用。\n\n实现以下三个测试用例以展示覆盖性：\n- 测试用例 1（设计用于满足循环相等性但不满足线性相等性）：设 $N = 5$，$x[n]$ 为 $[\\,3,\\,1,\\,4,\\,1,\\,5\\,]$，$h[n]$ 为 $[\\,2,\\,5,\\,7,\\,7,\\,5\\,]$。这里，$h[n]$ 相对于索引 $0$ 是循环偶对称的，因为 $h[1] = h[4]$ 且 $h[2] = h[3]$，这确保了在循环边界条件下的相等性，但 $h[n]$ 在中心翻转后不是回文的，因此补零卷积和相关不相等。\n- 测试用例 2（设计用于满足线性相等性但不满足循环相等性）：设 $N = 5$，$x[n]$ 为 $[\\,2,\\,1,\\,0,\\,4,\\,3\\,]$，$h[n]$ 为 $[\\,1,\\,2,\\,3,\\,2,\\,1\\,]$。这里，$h[n]$ 在中心翻转后是回文的，确保了线性卷积等于线性相关，但 $h[n]$ 相对于索引 $0$ 不是循环偶对称的，因此循环卷积和循环相关不相等。\n- 测试用例 3（两种相等性都成立的边界情况）：设 $N = 6$，$x[n]$ 为 $[\\,0,\\,1,\\,0,\\,2,\\,0,\\,3\\,]$，$h[n]$ 为常数 $[\\,4,\\,4,\\,4,\\,4,\\,4,\\,4\\,]$，因此循环和线性相等性都成立。\n\n算法要求：\n- 对于每个 $k$，直接根据其定义使用模数索引计算 $y_{\\text{circ}}[k]$ 和 $r_{xh,\\text{circ}}[k]$。\n- 使用标准的补零线性卷积计算 $y_{\\text{lin}}[k]$。\n- 使用上面给出的定义计算 $r_{xh,\\text{lin}}[k]$。在实现中，可以接受使用线性互相关等于与 $h[n]$ 的中心翻转版本进行线性卷积这一等价关系，即定义 $\\mathrm{flip}(h)[m] = h[N_h - 1 - m]$，并计算 $r_{xh,\\text{lin}}[k] = \\mathrm{conv}(x,\\mathrm{flip}(h))[k]$。这种对齐方式产生的输出索引与线性卷积相同，便于直接比较。\n- 对相等性检查使用数值容差。如果两个序列的逐元素最大绝对差小于 $10^{-12}$，则认为它们相等。\n\n要求输出：\n- 对于每个测试用例，生成两个布尔值：第一个表示 $y_{\\text{circ}}[k]$ 是否与 $r_{xh,\\text{circ}}[k]$ 逐元素相等，第二个表示 $y_{\\text{lin}}[k]$ 是否与 $r_{xh,\\text{lin}}[k]$ 逐元素相等（在通过中心翻转产生的卷积对齐索引下）。\n- 你的程序应生成单行输出，其中包含一个无空格、逗号分隔的列表的列表形式的结果，格式需严格遵守\n$$\n[\\,[b_{1,1},b_{1,2}],\\,[b_{2,1},b_{2,2}],\\,[b_{3,1},b_{3,2}]\\,],\n$$\n其中每个 $b_{i,j}$ 为 $\\mathrm{True}$ 或 $\\mathrm{False}$。\n\n此问题不涉及物理单位，也不出现角度和百分比。\n\n请使用 Python 3.12 版本，并仅使用运行时环境中指定的允许库来实现解决方案。", "solution": "解决这个问题的关键在于精确理解卷积与互相关之间的关系，以及这种关系如何受不同边界条件的影响——具体来说，是线性运算的补零和循环运算的模运算。\n\n两个实值信号 $x[n]$ 和 $h[n]$ 的离散卷积和互相关的基本定义如下：\n- 卷积：$(x * h)[k] = \\sum_{n} x[n] h[k-n]$\n- 互相关：$(x \\star h)[k] = \\sum_{n} x[n] h[n+k]$\n\n关键在于，互相关可以表示为与核 $h[n]$ 的时间反转（翻转）版本进行的卷积。我们定义一个时间反转算子 $\\mathrm{rev}(\\cdot)$。卷积 $(x * \\mathrm{rev}(h))[k]$ 由 $\\sum_{n} x[n] (\\mathrm{rev}(h))[k-n]$ 给出。可以证明，只要反转算子和求和边界根据所使用的边界模型被适当地定义，该表达式就等价于互相关的定义 $(x \\star h)[k]$。\n\n因此，卷积和互相关会产生相同的结果，即 $(x * h)[k] = (x \\star h)[k]$，当且仅当卷积核 $h[n]$ 在与边界模型相关的特定时间反转操作下是对称的。这个条件是 $h[n] = \\mathrm{rev}(h)[n]$。问题的关键在于，时间反转算子在线性上下文和循环上下文中的定义是不同的。\n\n**1. 线性（补零）运算**\n\n对于长度为 $N_x$ 的有限长度信号 $x[n]$ 和长度为 $N_h$ 的 $h[n]$，线性运算假定信号在其定义的支持域之外为零。相应的时间反转算子将核 $h[n]$ 围绕其中心索引进行翻转。其定义为：\n$$\n\\mathrm{rev}_{\\text{lin}}(h)[m] = h[N_h - 1 - m] \\quad \\text{对于 } 0 \\le m \\le N_h-1\n$$\n线性卷积和线性互相关相等，当且仅当 $h[m] = \\mathrm{rev}_{\\text{lin}}(h)[m]$，这意味着 $h[m] = h[N_h - 1 - m]$。具有此属性的序列称为**回文**序列。例如，$[\\,1,\\,2,\\,3,\\,2,\\,1\\,]$ 是回文序列。\n\n问题指定将线性互相关计算为 $x$ 与 $h$ 的翻转版本的卷积。这直接利用了恒等式 $(x \\star h)_{\\text{lin}} = (x * \\mathrm{rev}_{\\text{lin}}(h))_{\\text{lin}}$。因此，相等性的比较就变成了 $(x * h)_{\\text{lin}}$ 和 $(x * \\mathrm{rev}_{\\text{lin}}(h))_{\\text{lin}}$ 之间的直接比较。\n\n**2. 循环（周期性）运算**\n\n对于周期为 $N$ 的信号进行循环运算时，索引按模 $N$ 处理。循环时间反转算子将核 $h[n]$ 在圆上围绕索引 $n=0$ 进行翻转：\n$$\n\\mathrm{rev}_{\\text{circ}}(h)[n] = h[(-n) \\pmod N] \\quad \\text{对于 } 0 \\le n \\le N-1\n$$\n循环卷积 $y_{\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(k-n)\\bmod N]$ 等于循环互相关 $r_{xh,\\text{circ}}[k] = \\sum_{n=0}^{N-1} x[n]\\;h[(n+k)\\bmod N]$，当且仅当 $h[n] = \\mathrm{rev}_{\\text{circ}}(h)[n]$。这意味着 $h[n] = h[(-n) \\pmod N]$。具有此属性的序列称为**循环偶对称**。例如，对于 $N=5$，这要求 $h[1] = h[4]$ 和 $h[2] = h[3]$。序列 $[\\,2,\\,5,\\,7,\\,7,\\,5\\,]$ 对于 $N=5$ 是循环偶对称的。\n\n**通过设计产生差异**\n\n问题的测试用例旨在利用回文对称性和循环偶对称性是不同性质这一事实。一个信号可以具备其一而不具备其二，这使我们能够构建出一种情景：其中一对运算（例如循环运算）结果相等，而另一对（例如线性运算）则不相等。\n\n- **测试用例 1**：$h = [\\,2,\\,5,\\,7,\\,7,\\,5\\,]$ 且 $N=5$。\n  - 循环偶对称？：$h[1]=5$ 且 $h[(-1)\\bmod 5] = h[4]=5$。它们相等。$h[2]=7$ 且 $h[(-2)\\bmod 5] = h[3]=7$。它们相等。所以，$h$ 是循环偶对称的。我们预期 $y_{\\text{circ}} = r_{xh,\\text{circ}}$。\n  - 回文的？：$h[0]=2$ 且 $h[5-1-0] = h[4]=5$。它们不相等。所以，$h$ 不是回文的。我们预期 $y_{\\text{lin}} \\ne r_{xh,\\text{lin}}$。\n  - 预测：$[\\mathrm{True}, \\mathrm{False}]$\n\n- **测试用例 2**：$h = [\\,1,\\,2,\\,3,\\,2,\\,1\\,]$ 且 $N=5$。\n  - 回文的？：$h[0]=1, h[4]=1$。$h[1]=2, h[3]=2$。它是回文的。我们预期 $y_{\\text{lin}} = r_{xh,\\text{lin}}$。\n  - 循环偶对称？：$h[1]=2$ 且 $h[(-1)\\bmod 5] = h[4]=1$。它们不相等。它不是循环偶对称的。我们预期 $y_{\\text{circ}} \\ne r_{xh,\\text{circ}}$。\n  - 预测：$[\\mathrm{False}, \\mathrm{True}]$\n\n- **测试用例 3**：$h = [\\,4,\\,4,\\,4,\\,4,\\,4,\\,4\\,]$ 且 $N=6$。\n  - 一个常数信号显然既是回文的（$h[m]=4$ 且 $h[6-1-m]=4$）又是循环偶对称的（$h[n]=4$ 且 $h[(-n)\\bmod 6]=4$）。我们预期两种相等性都成立。\n  - 预测：$[\\mathrm{True}, \\mathrm{True}]$\n\n实现将遵循这些原则。循环运算通过使用循环和模运算直接根据其求和定义进行计算。线性运算为提高效率利用 `numpy.convolve`，其中线性互相关按照问题陈述中的规定，通过与中心翻转的核进行卷积来计算。通过确保结果序列之间的逐元素最大绝对差低于 $10^{-12}$ 的容差来检查相等性。", "answer": "```python\nimport numpy as np\n\ndef circular_convolution(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the circular convolution of two 1D signals x and h.\n    Assumes len(x) == len(h).\n    \"\"\"\n    N = len(x)\n    y = np.zeros(N)\n    for k in range(N):\n        for n in range(N):\n            y[k] += x[n] * h[(k - n) % N]\n    return y\n\ndef circular_cross_correlation(x: np.ndarray, h: np.ndarray) -> np.ndarray:\n    \"\"\"\n    Computes the circular cross-correlation of two 1D signals x and h.\n    Assumes len(x) == len(h).\n    \"\"\"\n    N = len(x)\n    r = np.zeros(N)\n    for k in range(N):\n        for n in range(N):\n            r[k] += x[n] * h[(n + k) % N]\n    return r\n\ndef solve():\n    \"\"\"\n    Solves the problem by running three predefined test cases and\n    comparing convolution and cross-correlation under different boundary models.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (N, x_list, h_list)\n        (5, [3, 1, 4, 1, 5], [2, 5, 7, 7, 5]),\n        (5, [2, 1, 0, 4, 3], [1, 2, 3, 2, 1]),\n        (6, [0, 1, 0, 2, 0, 3], [4, 4, 4, 4, 4, 4]),\n    ]\n\n    results = []\n    tolerance = 1e-12\n\n    for N, x_list, h_list in test_cases:\n        x = np.array(x_list, dtype=float)\n        h = np.array(h_list, dtype=float)\n\n        # 1. Circular operations\n        y_circ = circular_convolution(x, h)\n        r_circ = circular_cross_correlation(x, h)\n        \n        # Check for circular equality\n        circ_diff = np.max(np.abs(y_circ - r_circ))\n        is_circ_equal = circ_diff  tolerance\n\n        # 2. Linear operations\n        # Linear convolution\n        y_lin = np.convolve(x, h, mode='full')\n        \n        # Linear cross-correlation via convolution with flipped kernel\n        # h_flipped[m] = h[N_h - 1 - m] is equivalent to h[::-1]\n        h_flipped = h[::-1]\n        r_lin = np.convolve(x, h_flipped, mode='full')\n\n        # Check for linear equality\n        lin_diff = np.max(np.abs(y_lin - r_lin))\n        is_lin_equal = lin_diff  tolerance\n\n        results.append([is_circ_equal, is_lin_equal])\n\n    # Format the output string as per the requirement: [[b1,b2],[b3,b4],...] with no spaces.\n    # str(True) -> 'True', str(False) -> 'False'\n    result_str = \",\".join([f\"[{b1},{b2}]\" for b1, b2 in results])\n    print(f\"[{result_str}]\")\n\nsolve()\n```", "id": "3114298"}, {"introduction": "卷积的应用远不止于信号滤波，它也是求解线性微分方程的强大数学工具。本练习将引导你推导一维泊松方程的离散格林函数，并验证通过将其与源项进行卷积，可以得到方程的解。这个实践揭示了卷积作为一种描述线性系统对脉冲输入响应的核心作用，是连接信号处理与数学物理的重要桥梁。[@problem_id:3114358]", "problem": "考虑一维（1D）泊松问题，其定义在一个均匀网格上，该网格将区间 $\\left[0,L\\right]$ 离散化为 $N$ 个相等的子区间，网格点为 $x_{i} = i h$（$i = 0,1,\\dots,N$），网格间距为 $h = L/N$。令 $\\{u_{i}\\}_{i=0}^{N}$ 为函数 $u(x)$ 在这些网格点上的近似值，边界条件为固定端点 $u_{0} = 0$ 和 $u_{N} = 0$。在内部点 $i=1,\\dots,N-1$ 处，离散二阶导数由经过充分检验的三点二阶差分公式定义\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}},\n$$\n离散源项的采样值为 $\\{f_{i}\\}_{i=1}^{N-1}$，因此离散泊松方程可写作\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}} = f_{i}, \\quad i = 1,2,\\dots,N-1,\n$$\n且满足 $u_{0} = 0$ 和 $u_{N} = 0$。仅使用基本定义，推导与此边值问题相关的离散格林函数 $G_{i,j}$。对于每个固定的 $j \\in \\{1,\\dots,N-1\\}$，该函数序列满足\n$$\n\\frac{G_{i-1,j} - 2 G_{i,j} + G_{i+1,j}}{h^{2}} = \\delta_{i j}, \\quad i = 1,2,\\dots,N-1,\n$$\n以及 $G_{0,j} = 0$ 和 $G_{N,j} = 0$，其中 $\\delta_{ij}$ 表示离散的克罗内克 delta 函数。然后，从第一性原理出发，验证与格林函数的离散卷积\n$$\nu_{i} = \\sum_{j=1}^{N-1} G_{i,j} \\, f_{j},\n$$\n是满足给定固定端点条件的离散泊松方程的解。将格林函数 $G_{i,j}$ 的最终答案表示为包含 $i$、$j$、$N$ 和 $h$ 的单个闭式解析表达式。无需舍入。", "solution": "该问题是有效的。这是一个数值分析中标准的、适定的问题，涉及一维泊松方程的有限差分近似。所有术语都有精确定义，问题是自洽的且科学上是合理的。\n\n根据要求，求解过程包括两个主要部分：首先，从定义方程和边界条件推导离散格林函数 $G_{i,j}$；其次，从第一性原理验证该格林函数与源项的离散卷积能够得到离散泊松问题的解。\n\n### 第一部分：离散格林函数 $G_{i,j}$ 的推导\n\n对于一个固定的源索引 $j \\in \\{1, 2, \\dots, N-1\\}$，离散格林函数 $G_{i,j}$ 由以下关于 $i \\in \\{1, 2, \\dots, N-1\\}$ 的线性差分方程定义：\n$$\n\\frac{G_{i-1,j} - 2 G_{i,j} + G_{i+1,j}}{h^{2}} = \\delta_{i j}\n$$\n并满足齐次边界条件 $G_{0,j} = 0$ 和 $G_{N,j} = 0$。其中，$\\delta_{ij}$ 是克罗内克 delta 函数。\n\n方程两边乘以 $h^2$，得到：\n$$\nG_{i-1,j} - 2 G_{i,j} + G_{i+1,j} = h^{2} \\delta_{i j}\n$$\n\n对于任何满足 $i \\neq j$ 的索引 $i$，方程右侧为零，我们得到一个齐次二阶线性差分方程：\n$$\nG_{i-1,j} - 2 G_{i,j} + G_{i+1,j} = 0\n$$\n该差分方程的特征方程是 $r^2 - 2r + 1 = 0$，可以简化为 $(r-1)^2 = 0$。这表明存在一个重根 $r=1$。对于重根情况，$G_{i,j}$ 作为 $i$ 的函数的通解是一个线性函数：\n$$\nG_{i,j} = A i + B\n$$\n其中系数 $A$ 和 $B$ 在区域 $i  j$ 和 $i  j$ 中可以不同。\n\n让我们根据源位置 $j$ 将求解分为两个区域进行分析。\n\n**区域 1: $0 \\le i \\le j$**\n通解为 $G_{i,j} = c_1 i + d_1$。应用 $i=0$ 处的边界条件：\n$$\nG_{0,j} = c_1(0) + d_1 = 0 \\implies d_1 = 0\n$$\n因此，对于 $0 \\le i \\le j$，解的形式为：\n$$\nG_{i,j} = c_1 i\n$$\n\n**区域 2: $j \\le i \\le N$**\n通解为 $G_{i,j} = c_2 i + d_2$。应用 $i=N$ 处的边界条件：\n$$\nG_{N,j} = c_2 N + d_2 = 0 \\implies d_2 = -c_2 N\n$$\n因此，对于 $j \\le i \\le N$，解的形式为：\n$$\nG_{i,j} = c_2(i - N)\n$$\n\n现在，我们必须在点 $i=j$ 处连接这两种形式，并施加源项带来的条件。\n首先，序列 $G_{i,j}$ 的值在 $i=j$ 处必须是唯一确定的。这意味着来自两个区域的表达式在 $i=j$ 处必须相等：\n$$\nc_1 j = c_2 (j - N) \\quad (1)\n$$\n\n其次，我们使用在 $i=j$ 处的完整非齐次方程：\n$$\nG_{j-1,j} - 2 G_{j,j} + G_{j+1,j} = h^{2}\n$$\n代入来自各个区域的 $G_{i,j}$ 表达式：\n- $G_{j-1,j} = c_1(j-1)$ (因为 $j-1  j$)\n- $G_{j,j} = c_1 j = c_2(j-N)$\n- $G_{j+1,j} = c_2(j+1 - N)$ (因为 $j+1 > j$)\n将这些代入 $i=j$ 处的方程：\n$$\nc_1(j-1) - 2(c_1 j) + c_2(j+1 - N) = h^{2}\n$$\n展开并化简：\n$$\nc_1 j - c_1 - 2c_1 j + c_2(j-N) + c_2 = h^{2}\n$$\n$$\n-c_1 j - c_1 + c_2(j-N) + c_2 = h^{2}\n$$\n使用方程 $(1)$，我们可以用 $c_1 j$ 替换 $c_2(j-N)$：\n$$\n-c_1 j - c_1 + (c_1 j) + c_2 = h^{2}\n$$\n$$\nc_2 - c_1 = h^{2} \\quad (2)\n$$\n\n现在我们得到了一个关于系数 $c_1$ 和 $c_2$ 的二元线性方程组：\n1. $c_1 j = c_2 (j - N)$\n2. $c_2 = c_1 + h^{2}$\n\n将 $(2)$ 代入 $(1)$：\n$$\nc_1 j = (c_1 + h^{2})(j-N) = c_1 j - c_1 N + h^{2}j - h^{2}N\n$$\n$$\n0 = -c_1 N + h^2(j-N)\n$$\n$$\nc_1 N = h^{2}(j-N) \\implies c_1 = \\frac{h^{2}(j-N)}{N}\n$$\n现在，使用方程 $(2)$ 求 $c_2$：\n$$\nc_2 = c_1 + h^{2} = \\frac{h^{2}(j-N)}{N} + h^{2} = \\frac{h^{2}j - h^{2}N + h^{2}N}{N} = \\frac{h^{2}j}{N}\n$$\n正如预期的那样，系数 $c_1$ 和 $c_2$ 依赖于源索引 $j$。\n\n所以，$G_{i,j}$ 的分段表达式为：\n$$\nG_{i,j} = \\begin{cases} \\frac{h^{2}(j-N)}{N} i  \\text{若 } 0 \\le i \\le j \\\\ \\frac{h^{2}j}{N} (i-N)  \\text{若 } j \\le i \\le N \\end{cases}\n$$\n该表达式可以使用 $\\min(i,j)$ 和 $\\max(i,j)$ 合并成一个单一的闭式形式。令 $i_ = \\min(i,j)$ 且 $i_> = \\max(i,j)$。\n如果 $i \\le j$，则 $i_=i$ 且 $i_>=j$。该公式给出 $\\frac{h^2 i (j-N)}{N} = \\frac{h^2}{N} i_ (i_> - N)$。\n如果 $i > j$，则 $i_=j$ 且 $i_>=i$。该公式给出 $\\frac{h^2 j (i-N)}{N} = \\frac{h^2}{N} i_ (i_> - N)$。\n两种情况都吻合。因此，离散格林函数的单一闭式表达式为：\n$$\nG_{i,j} = \\frac{h^{2}}{N} \\min(i,j) (\\max(i,j) - N)\n$$\n\n### 第二部分：通过卷积验证解\n\n问题提出离散泊松方程的解由离散卷积给出：\n$$\nu_{i} = \\sum_{j=1}^{N-1} G_{i,j} f_{j}\n$$\n我们必须从第一性原理出发，验证这个 $u_i$ 的表达式同时满足微分方程和边界条件。\n\n首先，我们检查 $i \\in \\{1, 2, \\dots, N-1\\}$ 时的离散泊松方程。我们将离散二阶导数算子应用于 $u_i$：\n$$\n\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}}\n$$\n代入 $u_i$ 的表达式：\n$$\n\\frac{1}{h^{2}} \\left( \\left(\\sum_{j=1}^{N-1} G_{i-1,j} f_{j}\\right) - 2\\left(\\sum_{j=1}^{N-1} G_{i,j} f_{j}\\right) + \\left(\\sum_{j=1}^{N-1} G_{i+1,j} f_{j}\\right) \\right)\n$$\n由于求和都是针对相同的索引 $j$ 且是有限的，我们可以将它们合并：\n$$\n\\sum_{j=1}^{N-1} \\left( \\frac{G_{i-1,j} - 2G_{i,j} + G_{i+1,j}}{h^{2}} \\right) f_{j}\n$$\n根据格林函数 $G_{i,j}$ 的定义，括号中的项恰好是克罗内克 delta 函数 $\\delta_{ij}$：\n$$\n\\sum_{j=1}^{N-1} \\delta_{ij} f_{j}\n$$\n克罗内克 delta 函数的筛选性质意味着该和式将塌缩为单项，即 $j=i$ 的那一项：\n$$\nf_{i}\n$$\n因此，我们证明了 $\\frac{u_{i-1} - 2 u_{i} + u_{i+1}}{h^{2}} = f_i$，这验证了所提出的解在所有内部点都满足离散泊松方程。\n\n其次，我们必须检查边界条件。\n对于 $i=0$：\n$$\nu_{0} = \\sum_{j=1}^{N-1} G_{0,j} f_{j}\n$$\n根据构造，格林函数对所有 $j$ 都满足 $G_{0,j}=0$。因此：\n$$\nu_{0} = \\sum_{j=1}^{N-1} (0) f_{j} = 0\n$$\n对于 $i=N$：\n$$\nu_{N} = \\sum_{j=1}^{N-1} G_{N,j} f_{j}\n$$\n同样地，格林函数对所有 $j$ 都满足 $G_{N,j}=0$。因此：\n$$\nu_{N} = \\sum_{j=1}^{N-1} (0) f_{j} = 0\n$$\n两个边界条件都得到满足。验证完成。推导出的格林函数与源项进行卷积后，正确地求解了给定的边值问题。\n格林函数的最终闭式表达式如下所示。", "answer": "$$ \\boxed{\\frac{h^{2}}{N} \\min(i,j) (\\max(i,j) - N)} $$", "id": "3114358"}, {"introduction": "在实际应用中，我们常常需要从模糊且带噪声的观测数据中恢复原始信号，这是一个典型的逆问题。本练习将引导你从第一性原理出发，推导并实现维纳反卷积（Wiener deconvolution），这是一种利用信号与噪声的统计特性来最小化估计误差的最优滤波器。通过这个高级实践，你将掌握从基本滤波到设计复杂信号恢复算法的跨越，并深刻理解统计信号处理的核心思想。[@problem_id:3114304]", "problem": "给定一个离散时间、实值、有限长度的信号模型，其中未知输入 $x$ 通过一个冲激响应为 $h$ 的线性时不变系统进行观测，并受到加性噪声 $n$ 的污染，生成 $y$，其关系为 $y = x * h + n$，其中 $*$ 表示离散卷积。您的任务是，从第一性原理出发，推导出一个频域滤波器，该滤波器能够最小化估计值 $\\hat{x}$ 与真实输入 $x$ 之间的期望均方误差（Mean Squared Error (MSE)）。此推导需在 $x$ 和 $n$ 是宽平稳（wide-sense stationary）且相互独立的，并且已知 $x$ 的功率谱密度（Power Spectral Density (PSD)）$S_{xx}(\\omega)$ 和 $n$ 的功率谱密度 $S_{nn}(\\omega)$ 的条件下进行。然后，您必须实现由此得到的 Wiener 反卷积过程，以从 $y$ 中恢复 $\\hat{x}$，并使用快速傅里叶变换（Fast Fourier Transform (FFT)）在频域中进行操作。\n\n您的推导必须严格从与该主题相关的基本定义和原理开始。允许使用的基础包括：离散卷积的定义、宽平稳的定义及其通过傅里叶变换与自相关和功率谱密度的联系、均方误差的定义以及独立性性质。请勿使用或引用任何预先推导出的 Wiener 滤波器公式或中间的快捷表达式。您的推导应建立一个基于 $y$、系统频率响应 $H(\\omega)$ 以及频谱 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$ 的 $x$ 的最优频域估计器的结构。\n\n实现要求：\n- 使用长度为 $N$ 的循环卷积，以确保离散傅里叶变换能够精确地对角化卷积。对于长度均为 $N$ 的序列 $x$ 和冲激响应 $h$，通过 $y = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{x\\} \\cdot \\mathcal{F}\\{h\\}\\} + n$ 来构成 $y$，其中 $\\mathcal{F}$ 表示离散傅里叶变换，$\\mathcal{F}^{-1}$ 表示其逆变换。\n- 使用您推导的表达式，在离散频率网格 $\\omega_k = 2\\pi k / N$（其中 $k = 0, 1, \\dots, N-1$）上逐点应用，以构建频域反卷积滤波器。\n- 当 $x$ 为一阶自回归（AutoRegressive (AR) of order 1）过程时，即 $x[n] = \\phi x[n-1] + w[n]$，其中 $w[n]$ 是方差为 $\\sigma_w^2$ 的高斯白噪声，使用其已知的参数化功率谱密度形式：$$S_{xx}(\\omega) = \\frac{\\sigma_w^2}{\\left|1 - \\phi e^{-j\\omega}\\right|^2}.$$ 对于方差为 $\\sigma_n^2$ 的高斯白噪声 $n$，使用 $S_{nn}(\\omega) = \\sigma_n^2$。\n- 为了保证可复现性，请使用指定的固定种子生成所有随机序列。\n\n测试套件和参数：\n实现您的程序，使其无需任何用户输入即可运行以下三个测试用例。在每个用例中，所有序列的长度均为 $N$，并使用循环卷积。\n\n$1.$ 案例 A（中等模糊和中等噪声）：\n- $N = 256$。\n- 输入 $x$ 是 AR($1$) 过程，参数为 $\\phi = 0.9$，驱动噪声方差为 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是长度为 $N$ 的圆上的循环对称离散高斯核，标准差为 $s = 3.0$ 个样本，定义为 $h[k] = \\exp\\left(-\\frac{1}{2}\\left(\\frac{d(k)}{s}\\right)^2\\right)$，其中 $k=0,\\dots,N-1$，$d(k) = \\min(k, N-k)$，并进行归一化以使 $\\sum_{k=0}^{N-1} h[k] = 1$。\n- 加性噪声 $n$ 是高斯白噪声，方差为 $\\sigma_n^2 = 0.2$。\n- 随机种子：生成 AR($1$) 输入时使用种子 $x\\_seed = 0$，生成加性噪声时使用种子 $n\\_seed = 10$。\n\n$2.$ 案例 B（单位系统和极低噪声）：\n- $N = 128$。\n- 输入 $x$ 是 AR($1$) 过程，参数为 $\\phi = 0.6$，驱动噪声方差为 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是离散的 delta 函数，即 $h[0] = 1$ 且当 $k \\neq 0$ 时 $h[k] = 0$。\n- 加性噪声 $n$ 是高斯白噪声，方差为 $\\sigma_n^2 = 0.01$。\n- 随机种子：生成 AR($1$) 输入时使用种子 $x\\_seed = 1$，生成加性噪声时使用种子 $n\\_seed = 11$。\n\n$3.$ 案例 C（近陷波系统和高噪声）：\n- $N = 512$。\n- 输入 $x$ 是 AR($1$) 过程，参数为 $\\phi = 0.95$，驱动噪声方差为 $\\sigma_w^2 = 1.0$。\n- 冲激响应 $h$ 是一个双抽头（two-tap）滤波器，其中 $h[0] = 1$ 和 $h[1] = -0.95$，当 $k \\ge 2$ 时 $h[k] = 0$。\n- 加性噪声 $n$ 是高斯白噪声，方差为 $\\sigma_n^2 = 0.5$。\n- 随机种子：生成 AR($1$) 输入时使用种子 $x\\_seed = 2$，生成加性噪声时使用种子 $n\\_seed = 12$。\n\n对于每个案例，通过模拟一阶自回归递归式 $x[n] = \\phi x[n-1] + w[n]$（其中 $n = 0,\\dots,N-1$，$x[0] = w[0]$，且 $w[n]$ 是方差为 $\\sigma_w^2$ 的独立同分布高斯样本）来生成 $x$。将 $n$ 生成为方差为 $\\sigma_n^2$ 的独立高斯样本。通过长度为 $N$ 的循环卷积构建 $y$ 并加上 $n$。使用已知的 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$ 在离散频率网格上，通过您推导的 Wiener 反卷积滤波器计算 $\\hat{x}$。\n\n可量化的答案：\n对于每个测试用例，计算估计值与真实输入之间的实际均方误差，$$\\text{MSE} = \\frac{1}{N}\\sum_{n=0}^{N-1}\\left(\\hat{x}[n] - x[n]\\right)^2,$$ 并报告这三个 MSE 值。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按案例 A、案例 B、案例 C 顺序排列的三个 MSE 值，格式为用方括号括起来的逗号分隔列表，每个值四舍五入到六位小数（例如，$[\\text{mse\\_A},\\text{mse\\_B},\\text{mse\\_C}]$）。", "solution": "问题在于推导并实现一个最优线性滤波器，用以从测量值 $y$ 中估计信号 $x$。该测量值 $y$ 是将 $x$ 与系统响应 $h$ 进行卷积并叠加噪声 $n$ 后得到的结果。其模型由 $y = x * h + n$ 给出，其中 $*$ 表示离散卷积。最优性准则是最小化真实信号 $x$ 与其估计值 $\\hat{x}$ 之间的均方误差 (MSE)。\n\n我们的推导从第一性原理出发，假设信号 $x$ 和噪声 $n$ 是实值的、宽平稳 (WSS) 的随机过程，并且它们相互独立，均值为零。我们已知它们的功率谱密度 (PSD)，分别表示为 $S_{xx}(\\omega)$ 和 $S_{nn}(\\omega)$。\n\n设估计值 $\\hat{x}$ 是通过将一个冲激响应为 $g$ 的线性时不变 (LTI) 滤波器应用于观测信号 $y$ 而形成的。\n$$\n\\hat{x}[k] = (g * y)[k] = \\sum_{m} g[k-m] y[m]\n$$\n估计误差定义为 $e[k] = x[k] - \\hat{x}[k]$。我们的目标是找到能使 MSE 最小化的滤波器 $g$。对于一个 WSS 过程，MSE 是误差平方的期望值，且与时间索引 $k$ 无关。\n$$\n\\text{MSE} = J = E\\left[ e[k]^2 \\right]\n$$\n我们首先用输入信号和系统响应来表示误差 $e[k]$。\n$$\ne[k] = x[k] - (g * y)[k] = x[k] - (g * (x * h + n))[k]\n$$\n利用卷积的线性和结合律，我们得到：\n$$\ne[k] = x[k] - (g * h * x)[k] - (g * n)[k]\n$$\nMSE 是误差信号的方差，即 $J = E[e[k]^2]$。对于 WSS 过程，信号的平均功率由其在延迟为零时的自协方差 $R_{ee}[0]$ 给出。根据 Wiener-Khinchin 定理，这与它的 PSD $S_{ee}(\\omega)$ 的积分有关。\n$$\nJ = R_{ee}[0] = \\frac{1}{2\\pi} \\int_{-\\pi}^{\\pi} S_{ee}(\\omega) \\,d\\omega\n$$\n为了最小化 $J$，我们可以等价地对每个频率 $\\omega$ 最小化误差 PSD $S_{ee}(\\omega)$。这是可行的，因为被积函数是非负的。我们使用傅里叶变换转换到频域，傅里叶变换可以对角化 LTI 系统的卷积。令 $\\mathcal{F}$ 表示傅里叶变换算子。令 $X(\\omega)$、$H(\\omega)$、$N(\\omega)$、$G(\\omega)$ 和 $E(\\omega)$ 分别是 $x[k]$、$h[k]$、$n[k]$、$g[k]$ 和 $e[k]$ 的傅里叶变换。\n\n误差的频域表示为：\n$$\nE(\\omega) = X(\\omega) - G(\\omega) \\left( X(\\omega)H(\\omega) + N(\\omega) \\right)\n$$\n整理各项，我们得到：\n$$\nE(\\omega) = X(\\omega) \\left( 1 - G(\\omega)H(\\omega) \\right) - G(\\omega)N(\\omega)\n$$\n误差的 PSD $S_{ee}(\\omega)$ 是其傅里叶变换 $E(\\omega)$ 模平方的期望值。对于长度为 $N$ 的离散时间过程，其形式上定义为 $S_{ee}(\\omega_k) = E[|E(\\omega_k)|^2]$。\n$$\nS_{ee}(\\omega) = E\\left[ \\left| X(\\omega) \\left( 1 - G(\\omega)H(\\omega) \\right) - G(\\omega)N(\\omega) \\right|^2 \\right]\n$$\n展开模平方项 $|A-B|^2 = (A-B)(A-B)^* = |A|^2 - AB^* - A^*B + |B|^2$：\n$$\nS_{ee}(\\omega) = E\\left[ |X(\\omega)|^2 |1 - G(\\omega)H(\\omega)|^2 - X(\\omega)(1-G(\\omega)H(\\omega))G(\\omega)^*N(\\omega)^* - X(\\omega)^*(1-G(\\omega)H(\\omega))^*G(\\omega)N(\\omega) + |G(\\omega)|^2|N(\\omega)|^2 \\right]\n$$\n我们对每一项应用期望算子。由于 $x$ 和 $n$ 相互独立且均值为零，涉及 $X(\\omega)$ 和 $N(\\omega)$ 乘积的交叉项的期望为零。例如，$E[X(\\omega)N(\\omega)^*] = E[X(\\omega)]E[N(\\omega)^*] = 0 \\cdot 0 = 0$。\n这极大地简化了表达式：\n$$\nS_{ee}(\\omega) = E\\left[ |X(\\omega)|^2 \\right] |1 - G(\\omega)H(\\omega)|^2 + |G(\\omega)|^2 E\\left[ |N(\\omega)|^2 \\right]\n$$\n根据定义，$S_{xx}(\\omega) = E[|X(\\omega)|^2]$ 且 $S_{nn}(\\omega) = E[|N(\\omega)|^2]$。因此，误差 PSD 为：\n$$\nS_{ee}(\\omega) = S_{xx}(\\omega) |1 - G(\\omega)H(\\omega)|^2 + S_{nn}(\\omega) |G(\\omega)|^2\n$$\n我们的目标是找到使此表达式对每个 $\\omega$ 都最小化的复值滤波器响应 $G(\\omega)$。为清晰起见，我们展开各项，暂时省略对 $\\omega$ 的依赖：\n$$\nS_{ee} = S_{xx} (1 - GH)(1 - G^*H^*) + S_{nn} GG^*\n$$\n$$\nS_{ee} = S_{xx} (1 - G^*H^* - GH + |G|^2|H|^2) + S_{nn} |G|^2\n$$\n$$\nS_{ee} = S_{xx} - S_{xx}G^*H^* - S_{xx}GH + |G|^2 \\left( S_{xx}|H|^2 + S_{nn} \\right)\n$$\n为了找到关于复变量 $G$ 的最小值，我们可以使用 Wirtinger 微分，并将关于 $G^*$ 的导数设为零，将 $G$ 和 $G^*$ 视作独立变量。\n$$\n\\frac{\\partial S_{ee}}{\\partial G^*} = -S_{xx}H^* + G \\left( S_{xx}|H|^2 + S_{nn} \\right)\n$$\n将此导数设为零，得到最优滤波器 $G$：\n$$\n-S_{xx}H^* + G_{opt} \\left( S_{xx}|H|^2 + S_{nn} \\right) = 0\n$$\n求解 $G_{opt}$：\n$$\nG_{opt}(\\omega) = \\frac{S_{xx}(\\omega)H(\\omega)^*}{S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)}\n$$\n这就是著名的 Wiener 反卷积滤波器。分子项 $S_{xx}(\\omega)H(\\omega)^*$ 试图对系统进行逆运算，并由信号功率加权。分母是观测信号 $y$ 的 PSD，因为根据 $x$ 和 $n$ 的独立性，$S_{yy}(\\omega) = E[|X(\\omega)H(\\omega)+N(\\omega)|^2] = S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)$。该滤波器可以重写为：\n$$\nG_{opt}(\\omega) = \\frac{S_{xx}(\\omega)H(\\omega)^*}{S_{yy}(\\omega)} = \\frac{1}{H(\\omega)} \\frac{S_{xx}(\\omega)|H(\\omega)|^2}{S_{xx}(\\omega)|H(\\omega)|^2 + S_{nn}(\\omega)} = \\frac{1}{H(\\omega)} \\frac{\\text{SNR}(\\omega) \\cdot |H(\\omega)|^2}{\\text{SNR}(\\omega) \\cdot |H(\\omega)|^2 + 1}\n$$\n其中 $\\text{SNR}(\\omega) = S_{xx}(\\omega)/S_{nn}(\\omega)$。这种形式表明，在信噪比高的频率处，该滤波器近似于逆滤波器 $1/H(\\omega)$；而在信噪比低的频率处，它会衰减输出，从而防止噪声放大。\n\n在实现中，我们使用这些公式的离散版本。连续频率 $\\omega$ 被离散频率 $\\omega_k = 2\\pi k/N$（其中 $k \\in \\{0, 1, \\dots, N-1\\}$）所取代。傅里叶变换变为离散傅里叶变换 (DFT)，并使用快速傅里叶变换 (FFT) 算法进行计算。\n系统的频率响应 $H(\\omega_k)$ 由冲激响应 $h[n]$ 的 FFT 给出。PSD $S_{xx}(\\omega_k)$ 和 $S_{nn}(\\omega_k)$ 在这些离散频率上进行求值。\n- 对于 AR($1$) 过程 $x[n]=\\phi x[n-1]+w[n]$，其 PSD 为 $S_{xx}(\\omega) = \\frac{\\sigma_w^2}{|1 - \\phi e^{-j\\omega}|^2}$。\n- 对于白噪声 $n[n]$，其 PSD 是一个常数：$S_{nn}(\\omega) = \\sigma_n^2$。\n\n实现步骤如下：\n1.  根据给定的参数和随机种子，生成真实信号 $x[n]$ 和加性噪声 $n[n]$。\n2.  为给定案例定义冲激响应 $h[n]$。\n3.  通过 FFT 使用循环卷积计算观测信号 $y[n]$：$y = \\mathcal{F}^{-1}\\{\\mathcal{F}\\{x\\} \\cdot \\mathcal{F}\\{h\\}\\} + n$。\n4.  计算频率响应 $H[k] = \\mathcal{F}\\{h[n]\\}$。\n5.  在离散频率 $\\omega_k$ 上评估 PSD $S_{xx}[k]$ 和 $S_{nn}[k]$。\n6.  在频域中构建 Wiener 滤波器：$G[k] = \\frac{S_{xx}[k]H[k]^*}{S_{xx}[k]|H[k]|^2 + S_{nn}[k]}$。\n7.  在频域中将滤波器应用于观测信号：$\\hat{X}[k] = G[k] \\cdot \\mathcal{F}\\{y[n]\\}$。\n8.  将估计值变换回时域：$\\hat{x}[n] = \\mathcal{F}^{-1}\\{\\hat{X}[k]\\}$。\n9.  计算实际 MSE：$\\frac{1}{N}\\sum_{n=0}^{N-1} (\\hat{x}[n] - x[n])^2$。\n对所有三个指定的测试用例重复此过程。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the Wiener deconvolution filter for three test cases.\n    \"\"\"\n\n    def generate_ar1(N, phi, sigma_w_sq, seed):\n        \"\"\"Generates a single realization of an AR(1) process.\"\"\"\n        rng = np.random.default_rng(seed)\n        sigma_w = np.sqrt(sigma_w_sq)\n        w = rng.normal(scale=sigma_w, size=N)\n        x = np.zeros(N)\n        # Per problem spec: x[0] = w[0].\n        # Note: This makes the process not strictly stationary at the start.\n        x[0] = w[0]\n        for n in range(1, N):\n            x[n] = phi * x[n-1] + w[n]\n        return x\n\n    def run_case(N, phi, sigma_w_sq, h_def, sigma_n_sq, x_seed, n_seed):\n        \"\"\"\n        Runs a single deconvolution test case.\n\n        Args:\n            N (int): Signal length.\n            phi (float): AR(1) parameter for the input signal x.\n            sigma_w_sq (float): Driving noise variance for x.\n            h_def (tuple): Definition of the impulse response h.\n            sigma_n_sq (float): Variance of the additive white noise n.\n            x_seed (int): Random seed for generating x.\n            n_seed (int): Random seed for generating n.\n\n        Returns:\n            float: The mean squared error between the estimated signal and the true signal.\n        \"\"\"\n        # 1. Generate signals\n        x_true = generate_ar1(N, phi, sigma_w_sq, x_seed)\n        \n        rng_n = np.random.default_rng(n_seed)\n        noise = rng_n.normal(scale=np.sqrt(sigma_n_sq), size=N)\n\n        # 2. Define impulse response h\n        h = np.zeros(N)\n        htype, params = h_def\n        if htype == 'gaussian':\n            s = params['s']\n            k = np.arange(N)\n            d = np.minimum(k, N - k)\n            h = np.exp(-0.5 * (d / s)**2)\n            h /= np.sum(h) # Normalize\n        elif htype == 'delta':\n            h[0] = 1.0\n        elif htype == 'two-tap':\n            h[0] = 1.0\n            h[1] = -0.95\n\n        # 3. Create observed signal y = x * h + n using circular convolution\n        X_true_fft = np.fft.fft(x_true)\n        H_fft = np.fft.fft(h)\n        y_conv = np.real(np.fft.ifft(X_true_fft * H_fft))\n        y_obs = y_conv + noise\n\n        # 4. Construct the Wiener filter G\n        # Discrete frequencies\n        omega_k = (2 * np.pi / N) * np.arange(N)\n        \n        # PSD of AR(1) signal x\n        S_xx = sigma_w_sq / np.abs(1 - phi * np.exp(-1j * omega_k))**2\n        \n        # PSD of white noise n\n        S_nn = np.full(N, sigma_n_sq)\n        \n        # Wiener filter G in the frequency domain\n        G_numerator = S_xx * np.conj(H_fft)\n        G_denominator = S_xx * np.abs(H_fft)**2 + S_nn\n        G_fft = G_numerator / G_denominator\n\n        # 5. Apply the filter to estimate x\n        Y_obs_fft = np.fft.fft(y_obs)\n        X_hat_fft = G_fft * Y_obs_fft\n        x_hat = np.real(np.fft.ifft(X_hat_fft))\n\n        # 6. Calculate realized MSE\n        mse = np.mean((x_hat - x_true)**2)\n        \n        return mse\n\n    # --- Test Cases ---\n    test_cases = [\n        # Case A: Moderate blur, moderate noise\n        {\n            \"N\": 256, \"phi\": 0.9, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('gaussian', {'s': 3.0}),\n            \"sigma_n_sq\": 0.2, \"x_seed\": 0, \"n_seed\": 10\n        },\n        # Case B: Identity system, very low noise\n        {\n            \"N\": 128, \"phi\": 0.6, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('delta', {}),\n            \"sigma_n_sq\": 0.01, \"x_seed\": 1, \"n_seed\": 11\n        },\n        # Case C: Near-notched system, high noise\n        {\n            \"N\": 512, \"phi\": 0.95, \"sigma_w_sq\": 1.0,\n            \"h_def\": ('two-tap', {}),\n            \"sigma_n_sq\": 0.5, \"x_seed\": 2, \"n_seed\": 12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        mse = run_case(**case)\n        results.append(mse)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{m:.6f}' for m in results)}]\")\n\nsolve()\n```", "id": "3114304"}]}