{"hands_on_practices": [{"introduction": "要真正掌握高斯-赛德尔法，最好的方法就是亲手实践其迭代过程。本练习将引导你完成前两次迭代，并计算出近似解的坐标。通过追踪这些点在二维平面上的移动，你可以直观地理解该方法如何通过在由方程定义的直线上交替移动，一步步逼近系统的精确解。[@problem_id:2214528]", "problem": "考虑 $x_1$-$x_2$ 平面中的以下线性方程组：\n$$5x_1 - 2x_2 = 3$$\n$$x_1 + 4x_2 = 10$$\n高斯-赛德尔 (Gauss-Seidel) 方法是一种用于近似求解线性方程组的迭代算法。从一个初始猜测 $\\mathbf{x}^{(0)} = (x_1^{(0)}, x_2^{(0)})$ 开始，它为 $k = 1, 2, 3, \\ldots$ 生成一个近似序列 $\\mathbf{x}^{(k)} = (x_1^{(k)}, x_2^{(k)})$。在几何上，该方法的每一步都可以解释为在 $x_1$-$x_2$ 平面上的一个移动。\n\n令高斯-赛德尔方法生成的点序列表示为 $P_k = (x_1^{(k)}, x_2^{(k)})$。使用初始猜测 $P_0 = (0, 0)$，确定该方法前两次完整迭代所产生的点 $P_1 = (x_1^{(1)}, x_2^{(1)})$ 和 $P_2 = (x_1^{(2)}, x_2^{(2)})$ 的坐标。\n\n请将你的答案以 $x_1^{(1)}, x_2^{(1)}, x_1^{(2)}, x_2^{(2)}$ 这四个坐标的特定顺序，表示在一个单行矩阵中。所有值都表示为精确分数。", "solution": "我们将每个方程针对一个变量求解，以获得高斯-赛德尔迭代形式。由 $5x_{1}-2x_{2}=3$，解出 $x_{1}$：\n$$\nx_{1}=\\frac{3+2x_{2}}{5}.\n$$\n由 $x_{1}+4x_{2}=10$，解出 $x_{2}$：\n$$\nx_{2}=\\frac{10-x_{1}}{4}.\n$$\n在高斯-赛德尔方法中，在第 $k$ 次迭代时，我们使用最新的值顺序更新：\n$$\nx_{1}^{(k)}=\\frac{3+2x_{2}^{(k-1)}}{5},\\qquad x_{2}^{(k)}=\\frac{10-x_{1}^{(k)}}{4}.\n$$\n从 $P_{0}=(x_{1}^{(0)},x_{2}^{(0)})=(0,0)$ 开始：\n\n第一次迭代 $k=1$：\n$$\nx_{1}^{(1)}=\\frac{3+2x_{2}^{(0)}}{5}=\\frac{3+2\\cdot 0}{5}=\\frac{3}{5},\n$$\n$$\nx_{2}^{(1)}=\\frac{10-x_{1}^{(1)}}{4}=\\frac{10-\\frac{3}{5}}{4}=\\frac{\\frac{50}{5}-\\frac{3}{5}}{4}=\\frac{\\frac{47}{5}}{4}=\\frac{47}{20}.\n$$\n\n第二次迭代 $k=2$：\n$$\nx_{1}^{(2)}=\\frac{3+2x_{2}^{(1)}}{5}=\\frac{3+2\\cdot \\frac{47}{20}}{5}=\\frac{3+\\frac{47}{10}}{5}=\\frac{\\frac{30}{10}+\\frac{47}{10}}{5}=\\frac{\\frac{77}{10}}{5}=\\frac{77}{50},\n$$\n$$\nx_{2}^{(2)}=\\frac{10-x_{1}^{(2)}}{4}=\\frac{10-\\frac{77}{50}}{4}=\\frac{\\frac{500}{50}-\\frac{77}{50}}{4}=\\frac{\\frac{423}{50}}{4}=\\frac{423}{200}.\n$$\n因此，所求的坐标为 $x_{1}^{(1)}=\\frac{3}{5}$，$x_{2}^{(1)}=\\frac{47}{20}$，$x_{1}^{(2)}=\\frac{77}{50}$，以及 $x_{2}^{(2)}=\\frac{423}{200}$。", "answer": "$$\\boxed{\\begin{pmatrix}\\frac{3}{5}   \\frac{47}{20}   \\frac{77}{50}   \\frac{423}{200}\\end{pmatrix}}$$", "id": "2214528"}, {"introduction": "迭代法并非万能钥匙；一个核心问题是确保迭代序列收敛到真实的解。本练习提供了一个不满足对角占优条件的线性系统。通过计算前三次迭代，你将亲眼观察到迭代值如何迅速偏离并“发散”，从而深刻体会到检验收敛性在高斯-赛德尔法应用中的重要性。[@problem_id:1394885]", "problem": "一位工程师的任务是求解一个线性方程组，该方程组为一个简单的静态结构框架建模。该方程组如下：\n$$\n\\begin{cases}\n    x_1 + 2x_2 = 5 \\\\\n    3x_1 + x_2 = 4\n\\end{cases}\n$$\n工程师决定使用高斯-赛德尔法（一种迭代技术）来近似求解。该方法从解向量的一个初始猜测值开始，并在每次迭代中对其进行优化。\n\n从初始猜测值 $\\mathbf{x}^{(0)} = \\begin{pmatrix} x_1^{(0)} \\\\ x_2^{(0)} \\end{pmatrix} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始，计算经过三次完整的高斯-赛德尔法迭代后解向量 $\\mathbf{x}^{(3)} = \\begin{pmatrix} x_1^{(3)} \\\\ x_2^{(3)} \\end{pmatrix}$ 的值。", "solution": "高斯-赛德尔法使用最新可用的值顺序地更新每个变量。对于方程组\n$$\n\\begin{cases}\nx_{1} + 2 x_{2} = 5 \\\\\n3 x_{1} + x_{2} = 4\n\\end{cases}\n$$\n对每个方程求解相应的变量，以获得迭代公式：\n$$\nx_{1}^{(k+1)} = 5 - 2 x_{2}^{(k)}, \\quad x_{2}^{(k+1)} = 4 - 3 x_{1}^{(k+1)}.\n$$\n从 $\\mathbf{x}^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\end{pmatrix}$ 开始，计算三次完整的迭代。\n\n第一次迭代 ($k=0 \\to 1$):\n$$\nx_{1}^{(1)} = 5 - 2 x_{2}^{(0)} = 5 - 2 \\cdot 0 = 5,\n$$\n$$\nx_{2}^{(1)} = 4 - 3 x_{1}^{(1)} = 4 - 3 \\cdot 5 = 4 - 15 = -11.\n$$\n\n第二次迭代 ($k=1 \\to 2$):\n$$\nx_{1}^{(2)} = 5 - 2 x_{2}^{(1)} = 5 - 2 \\cdot (-11) = 5 + 22 = 27,\n$$\n$$\nx_{2}^{(2)} = 4 - 3 x_{1}^{(2)} = 4 - 3 \\cdot 27 = 4 - 81 = -77.\n$$\n\n第三次迭代 ($k=2 \\to 3$):\n$$\nx_{1}^{(3)} = 5 - 2 x_{2}^{(2)} = 5 - 2 \\cdot (-77) = 5 + 154 = 159,\n$$\n$$\nx_{2}^{(3)} = 4 - 3 x_{1}^{(3)} = 4 - 3 \\cdot 159 = 4 - 477 = -473.\n$$\n\n因此，经过三次完整的高斯-赛德尔迭代后，解向量为 $\\mathbf{x}^{(3)} = \\begin{pmatrix} 159 \\\\ -473 \\end{pmatrix}$。", "answer": "$$\\boxed{\\begin{pmatrix} 159 \\\\ -473 \\end{pmatrix}}$$", "id": "1394885"}, {"introduction": "在实际的计算应用中，迭代过程必须在某个时刻停止。但是，我们如何判断一个近似解已经“足够好”？本练习将深入探讨两种不同的停止准则，并揭示一个看似直观的准则在特定情况下可能会产生误导。通过对比分析，你将学会如何选择更稳健的收敛判据，这是编写可靠数值算法的关键一步。[@problem_id:3135103]", "problem": "要求您为应用于求解线性系统的 Gauss–Seidel 迭代法设计和分析一个终止准则。考虑一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个右侧向量 $b \\in \\mathbb{R}^{n}$。目标是使用 Gauss–Seidel 迭代法和初始猜测值 $x^{(0)}$ 来逼近系统 $A x^{\\star} = b$ 的解 $x^{\\star}$。在每次迭代 $k$ 中，定义残差 $r^{(k)} = b - A x^{(k)}$。任务是实现两个停止规则，并在精心选择的测试用例上比较它们的行为。\n\n使用的基本原理：\n- 线性系统 $A x = b$ 的定义以及通过顺序满足单个方程进行迭代优化的概念。\n- 残差的定义 $r(x) = b - A x$ 及其作为衡量 $x$ 距离解的程度的作用。\n- 向量的欧几里得范数（也称为 $2$-范数），记为 $\\| \\cdot \\|$，以及矩阵的诱导算子范数 $\\| A \\|$（$A$ 的最大奇异值）。\n\n要求：\n1. 从基本原理出发实现 Gauss–Seidel 迭代法：从 $x^{(0)}$ 开始，通过顺序更新分量来生成 $x^{(k+1)}$，使得在每次扫描中，每个标量方程都使用最新的可用分量值得到满足。避免使用任何快捷公式；您的更新应基于在当前扫描中使用最近更新的分量和前一次扫描中的剩余分量来逐个满足方程。\n2. 从迭代 $k = 1$ 开始实现并跟踪两个停止规则：\n   - 规则 R1（由右侧向量归一化的残差）：在满足 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|} \\leq \\tau$ 的最小 $k$ 值处停止。\n   - 规则 R2（由矩阵和迭代向量归一化的残差）：在满足 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| A \\| \\, \\| x^{(k)} \\|} \\leq \\tau$ 的最小 $k$ 值处停止。\n3. 边界情况的约定：\n   - 如果 $\\| r^{(k)} \\| = 0$，则无论分母如何，都将任一规则的比率视为 $0$ 并接受收敛。\n   - 对于规则 R1，如果 $\\| b \\| = 0$ 且 $\\| r^{(k)} \\| \\neq 0$，则将比率视为 $+\\infty$（在此迭代中不收敛）。\n   - 对于规则 R2，如果 $\\| x^{(k)} \\| = 0$ 且 $\\| r^{(k)} \\| \\neq 0$，则在该迭代中将比率视为 $+\\infty$。\n4. 对于每个测试用例，使用直接求解法计算精确解 $x^{\\star}$（以便评估前向误差）。将第 $k$ 次迭代的相对前向误差定义为 $\\displaystyle \\frac{\\| x^{(k)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$，并且仅用于分析（不要将其用作停止规则）。\n5. 定义容差 $\\tau = 10^{-4}$ 和最大迭代次数 $K_{\\max} = 5000$。对向量使用欧几里得范数，对矩阵使用诱导算子范数（最大奇异值）。不涉及角度；不涉及物理单位。\n6. 您的程序必须运行 Gauss–Seidel 迭代法，不提前终止，以收集完整的序列 $\\{ x^{(k)} \\}_{k=1}^{K_{\\max}}$，并对该序列评估两个停止规则。然后，对于每个测试用例，返回：\n   - $N_{\\mathrm{R1}}$：满足规则 R1 的最小 $k$ 值，如果到 $K_{\\max}$ 仍不满足，则为 $K_{\\max}$。\n   - $N_{\\mathrm{R2}}$：满足规则 R2 的最小 $k$ 值，如果到 $K_{\\max}$ 仍不满足，则为 $K_{\\max}$。\n   - $\\mathrm{inflated}$：一个布尔值，如果规则 R1 比规则 R2 更早发出收敛信号（即 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$），并且在迭代 $N_{\\mathrm{R1}}$ 时，相对前向误差 $\\displaystyle \\frac{\\| x^{(N_{\\mathrm{R1}})} - x^{\\star} \\|}{\\| x^{\\star} \\|}$ 严格大于 $\\tau$，则为 $\\mathrm{True}$。否则，$\\mathrm{inflated}$ 为 $\\mathrm{False}$。\n\n测试套件：\n- 案例 1（良好缩放、对称正定、对角占优）：\n  - $A = \\begin{pmatrix} 4   -1   0 \\\\ -1   4   -1 \\\\ 0   -1   3 \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 15 \\\\ 10 \\\\ 10 \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  这是一个普遍的理想情况，预计两个规则的行为相似。\n- 案例 2（构造用于通过缩放 $b$ 相对于矩阵范数来夸大规则 R1 下的感知进度）：\n  - $A = \\begin{pmatrix} 10^{-2}   2 \\cdot 10^{-3}   0 \\\\ 10^{-3}   2 \\cdot 10^{-2}   3 \\cdot 10^{-3} \\\\ 0   10^{-3}   3 \\cdot 10^{-2} \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 10^{8} \\\\ -10^{8} \\\\ 10^{8} \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  此案例的设计目的是，通过除以一个大的 $\\| b \\|$ 值，使得 $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|}$ 比替代规则更早地显得很小，从而可能夸大感知到的进度。\n- 案例 3（右侧为零的边界条件）：\n  - $A = \\begin{pmatrix} 4   -1   0 \\\\ -1   4   -1 \\\\ 0   -1   3 \\end{pmatrix}$，\n  - $b = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$，\n  - $x^{(0)} = \\begin{pmatrix} 0 \\\\ 0 \\\\ 0 \\end{pmatrix}$。\n  此案例验证对 $\\| b \\| = 0$ 的处理以及零残差意味着接受的约定。\n\n最终输出规范：\n- 您的程序应生成一行输出，其中包含结果，形式为每个案例的三元组的逗号分隔列表，每个三元组的格式为 $[N_{\\mathrm{R1}},N_{\\mathrm{R2}},\\mathrm{inflated}]$，整个集合用方括号括起来。例如，输出格式必须类似于 $[[N_{1,\\mathrm{R1}},N_{1,\\mathrm{R2}},\\mathrm{inflated}_1],[N_{2,\\mathrm{R1}},N_{2,\\mathrm{R2}},\\mathrm{inflated}_2],[N_{3,\\mathrm{R1}},N_{3,\\mathrm{R2}},\\mathrm{inflated}_3]]$，其中每个 $N$ 是一个整数，每个 $\\mathrm{inflated}$ 是 $\\mathrm{True}$ 或 $\\mathrm{False}$。", "solution": "该问题是有效的。这是数值线性代数中一个明确定义的练习，专注于实现和分析用于求解线性方程组的 Gauss-Seidel 迭代法。该问题在科学上是合理的，自洽的，并且所有提供的数据和条件都是一致且明确的。\n\n任务是使用 Gauss-Seidel 迭代法对三种不同的情况求解线性系统 $A x^{\\star} = b$。我们将从基本原理出发实现该方法，应用两种不同的停止准则，并分析它们的行为。分析涉及比较每个规则满足时的迭代次数，并评估一个特殊条件 `inflated`，该条件用于诊断由其中一个规则发出的过早收敛信号。\n\n**1. Gauss-Seidel 方法**\n\nGauss-Seidel 方法是一种迭代技术，用于逼近线性系统 $A x = b$ 的解。给定一个方阵 $A \\in \\mathbb{R}^{n \\times n}$ 和一个向量 $b \\in \\mathbb{R}^{n}$，我们寻求解向量 $x \\in \\mathbb{R}^{n}$。该系统可以分量形式写为：\n$$ \\sum_{j=1}^{n} A_{ij} x_j = b_i \\quad \\text{for } i = 1, 2, \\ldots, n $$\n其中 $A_{ij}$ 是 $A$ 的第 $i$ 行第 $j$ 列的元素。为了形成一个迭代方案，我们对第 $i$ 个方程求解第 $i$ 个分量 $x_i$：\n$$ A_{ii} x_i = b_i - \\sum_{j \\neq i} A_{ij} x_j $$\n假设对于所有 $i$，$A_{ii} \\neq 0$，我们可以写出：\n$$ x_i = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j \\neq i} A_{ij} x_j \\right) $$\nGauss-Seidel 迭代从一个初始猜测 $x^{(0)}$ 开始，构造一个近似解的序列 $\\{x^{(k)}\\}_{k=0}^{\\infty}$。为了从当前迭代 $x^{(k)}$ 计算下一个迭代 $x^{(k+1)}$，我们按顺序更新每个分量 $x_i^{(k+1)}$（对于 $i=1, \\ldots, n$）。该方法的核心原则是在当前迭代中使用最新计算出的分量值。在计算 $x_i^{(k+1)}$ 时，分量 $x_1^{(k+1)}, \\ldots, x_{i-1}^{(k+1)}$ 已经确定。对于剩余的分量，我们使用前一次迭代的值，即 $x_{i+1}^{(k)}, \\ldots, x_{n}^{(k)}$。这导出了 Gauss-Seidel 方法的定义性更新规则：\n$$ x_i^{(k+1)} = \\frac{1}{A_{ii}} \\left( b_i - \\sum_{j=1}^{i-1} A_{ij} x_j^{(k+1)} - \\sum_{j=i+1}^{n} A_{ij} x_j^{(k)} \\right) \\quad \\text{for } i = 1, \\ldots, n $$\n\n**2. 停止准则和分析**\n\n迭代方法需要一个规则来确定何时停止。一个常见的误差度量是残差 $r^{(k)} = b - A x^{(k)}$，它仅在 $x^{(k)}$ 是精确解时为零。我们的任务是评估两个基于残差欧几里得范数（记为 $\\| \\cdot \\|$）的停止规则。容差给定为 $\\tau = 10^{-4}$。\n\n*   **规则 R1（由右侧向量归一化）：** $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| b \\|} \\leq \\tau$\n    该准则衡量残差范数相对于右侧向量 $b$ 范数的大小。它很直观，但可能具有误导性。如果 $\\|b\\|$ 非常大，即使 $x^{(k)}$ 离真实解 $x^{\\star}$ 很远，这个比率也可能变得很小，给人一种错误的收敛感。相反，如果 $\\|b\\|$ 非常小，这个准则可能过于严格。测试用例 2 就是为了揭示这一弱点而设计的。\n\n*   **规则 R2（由矩阵和迭代向量归一化）：** $\\displaystyle \\frac{\\| r^{(k)} \\|}{\\| A \\| \\, \\| x^{(k)} \\|} \\leq \\tau$\n    该准则与后向误差的概念有关。左侧的值可以解释为，使得 $x^{(k)}$ 成为某个扰动系统精确解的、对矩阵 $A$ 的最小相对扰动。它通常比规则 R1 更稳健，因为它通过一个与系统当前状态（$A$ 和 $x^{(k)}$）内在相关的尺度来归一化残差，而不仅仅是输入 $b$。矩阵范数 $\\|A\\|$ 是诱导 2-范数，计算为 $A$ 的最大奇异值。\n\n对于我们的分析，我们将使用直接求解器计算精确解 $x^{\\star}$。迭代 $x^{(k)}$ 的真实精度由相对前向误差衡量：$\\frac{\\| x^{(k)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$。我们需要识别规则 R1 何时过早地发出收敛信号。这由 `inflated` 标志捕获，如果规则 R1 比规则 R2 更早停止（$N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$），并且在那时解尚不准确（在迭代 $N_{\\mathrm{R1}}$ 时的相对前向误差大于 $\\tau$），则该标志设置为 `True`。\n\n**3. 算法实现**\n\n对于每个测试用例，算法流程如下：\n\n1.  **初始化**：定义矩阵 $A$、向量 $b$ 和初始猜测 $x^{(0)}$。设置容差 $\\tau = 10^{-4}$ 和最大迭代次数 $K_{\\max} = 5000$。\n2.  **预计算**：\n    *   通过直接求解 $A x = b$（例如，使用 LU 分解）来计算精确解 $x^{\\star}$。\n    *   计算并存储常数范数：$\\|b\\|$, $\\|A\\|$（最大奇异值）和 $\\|x^{\\star}\\|$。\n3.  **迭代循环**：对固定的步数（从 $k=0$ 到 $K_{\\max}-1$）运行 Gauss-Seidel 迭代，以生成迭代序列 $\\{x^{(k)}\\}_{k=1}^{K_{\\max}}$。\n    *   在每一步中，为了从 $x^{(k)}$ 得到 $x^{(k+1)}$，遍历分量 $i = 1, \\ldots, n$ 并应用更新公式。\n    *   计算出 $x^{(k+1)}$ 后，计算残差 $r^{(k+1)} = b - A x^{(k+1)}$。\n    *   计算并存储两个停止准则规则左侧的值，注意处理指定的边界条件（例如，如果分母为零）。\n    *   计算并存储相对前向误差 $\\frac{\\| x^{(k+1)} - x^{\\star} \\|}{\\| x^{\\star} \\|}$。\n4.  **后处理**：循环完成后，分析存储的序列。\n    *   找到 $N_{\\mathrm{R1}}$，即满足规则 R1 条件的第一个迭代索引 $k \\ge 1$。如果从未满足，则设置 $N_{\\mathrm{R1}} = K_{\\max}$。\n    *   类似地，为规则 R2 找到 $N_{\\mathrm{R2}}$。\n    *   通过检查是否 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$ 以及在迭代 $N_{\\mathrm{R1}}$ 时的相对前向误差是否大于 $\\tau$ 来确定 `inflated` 布尔值的值。\n5.  **输出**：为每个测试用例收集三元组 $[N_{\\mathrm{R1}}, N_{\\mathrm{R2}}, \\mathrm{inflated}]$，并按指定格式化最终输出。\n\n对于 $b=0$ 的案例 3 的特殊处理：精确解为 $x^{\\star}=0$。从 $x^{(0)}=0$ 开始，Gauss-Seidel 更新产生 $x^{(1)}=0$。因此残差 $r^{(1)}$ 为 $0$。根据约定，如果 $\\|r^{(k)}\\|=0$，则停止准则的比率被视为 $0$，它小于或等于 $\\tau$。因此，两个规则都在 $k=1$ 时满足，导致 $N_{\\mathrm{R1}}=1$ 和 $N_{\\mathrm{R2}}=1$。在这种情况下，条件 $N_{\\mathrm{R1}}  N_{\\mathrm{R2}}$ 为假，所以 `inflated` 为 `False`。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and analyzes Gauss-Seidel iteration with two stopping rules.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"A\": np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 3]], dtype=float),\n            \"b\": np.array([15, 10, 10], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n        {\n            \"A\": np.array([[1e-2, 2e-3, 0], [1e-3, 2e-2, 3e-3], [0, 1e-3, 3e-2]], dtype=float),\n            \"b\": np.array([1e8, -1e8, 1e8], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n        {\n            \"A\": np.array([[4, -1, 0], [-1, 4, -1], [0, -1, 3]], dtype=float),\n            \"b\": np.array([0, 0, 0], dtype=float),\n            \"x0\": np.array([0, 0, 0], dtype=float),\n        },\n    ]\n\n    tau = 1e-4\n    K_max = 5000\n    results = []\n\n    for case in test_cases:\n        A = case[\"A\"]\n        b = case[\"b\"]\n        x_k = case[\"x0\"].copy()\n        n = A.shape[0]\n\n        # Pre-computation\n        try:\n            x_star = np.linalg.solve(A, b)\n        except np.linalg.LinAlgError:\n            x_star = np.full_like(b, np.nan)\n\n        norm_b = np.linalg.norm(b)\n        norm_A = np.linalg.svd(A, compute_uv=False)[0]\n        norm_x_star = np.linalg.norm(x_star)\n\n        # Storage for analysis\n        ratios_r1 = []\n        ratios_r2 = []\n        fwd_errors = []\n\n        # Iteration loop\n        for _ in range(K_max):\n            x_next = x_k.copy()\n            for i in range(n):\n                sum1 = A[i, :i] @ x_next[:i]\n                sum2 = A[i, i+1:] @ x_k[i+1:]\n                if A[i, i] != 0:\n                    x_next[i] = (b[i] - sum1 - sum2) / A[i, i]\n            \n            x_k = x_next\n            \n            # Compute metrics for this iteration (k+1)\n            residual = b - A @ x_k\n            norm_r = np.linalg.norm(residual)\n            norm_x = np.linalg.norm(x_k)\n\n            # Rule R1 ratio\n            if norm_r == 0:\n                ratio_r1 = 0.0\n            elif norm_b == 0:\n                ratio_r1 = np.inf\n            else:\n                ratio_r1 = norm_r / norm_b\n            ratios_r1.append(ratio_r1)\n\n            # Rule R2 ratio\n            if norm_r == 0:\n                ratio_r2 = 0.0\n            elif norm_A * norm_x == 0:\n                ratio_r2 = np.inf\n            else:\n                ratio_r2 = norm_r / (norm_A * norm_x)\n            ratios_r2.append(ratio_r2)\n\n            # Forward error\n            if norm_x_star == 0:\n                # Use absolute error if x_star is the zero vector\n                fwd_error = np.linalg.norm(x_k - x_star)\n            else:\n                fwd_error = np.linalg.norm(x_k - x_star) / norm_x_star\n            fwd_errors.append(fwd_error)\n\n        # Post-processing to find N_R1, N_R2\n        N_R1 = K_max\n        for k, ratio in enumerate(ratios_r1):\n            if ratio = tau:\n                N_R1 = k + 1\n                break\n        \n        N_R2 = K_max\n        for k, ratio in enumerate(ratios_r2):\n            if ratio = tau:\n                N_R2 = k + 1\n                break\n\n        # Determine 'inflated' flag\n        inflated = False\n        if N_R1  N_R2:\n            # fwd_errors is 0-indexed, N_R1 is 1-indexed\n            if fwd_errors[N_R1 - 1] > tau:\n                inflated = True\n\n        results.append([N_R1, N_R2, inflated])\n\n    # Final print statement in the exact required format.\n    # Convert boolean to string 'True' or 'False' as required.\n    formatted_results = [f\"[{r[0]},{r[1]},{str(r[2])}]\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3135103"}]}