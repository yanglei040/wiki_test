{"hands_on_practices": [{"introduction": "单纯形算法通过从可行域的一个顶点迭代到另一个顶点来优化目标函数，每一步都伴随着目标值的改善。这个移动过程是通过一个名为“轴心变换”（pivot）的基本操作完成的。本练习提供了一个具体的机会来执行一次完整的轴心变换操作，这是整个单纯形方法的基石。[@problem_id:2221017]", "problem": "一家市场分析公司正在使用线性规划来确定客户广告预算的最优分配。其目标是最大化客户触及数。决策变量为 $x_1$（在社交媒体上购买的广告单元数量）和 $x_2$（在搜索引擎上购买的广告单元数量）。该问题已被构建为一个标准最大化问题，其初始单纯形表如下所示。变量 $s_1$ 和 $s_2$ 是松弛变量，分别代表未使用的预算和员工工时。变量 $Z$ 代表需要最大化的总客户触及数。\n\n表的各行对应于目标函数 $Z$ 以及以 $s_1$ 和 $s_2$ 为基变量的两个约束。各列对应于变量 $Z, x_1, x_2, s_1, s_2$ 以及右端项 (RHS) 的值。\n\n初始单纯形表为：\n$$\n\\begin{array}{c|cccccc}\n\\text{基变量} & Z & x_1 & x_2 & s_1 & s_2 & \\text{右端项} \\\\\n\\hline\nZ & 1 & -5 & -4 & 0 & 0 & 0 \\\\\ns_1 & 0 & 10 & 8 & 1 & 0 & 80 \\\\\ns_2 & 0 & 2 & 3 & 0 & 1 & 24 \\\\\n\\end{array}\n$$\n\n根据标准单纯形法的最大化问题规则，执行一次完整的枢轴操作。确定Z行中 $x_2$ 的系数、Z行中 $s_1$ 的系数以及目标函数 $Z$ 的新值（Z行的右端项值）的更新值。\n\n您的答案应该是一组按指定顺序排列在行矩阵中的三个数值：（$x_2$ 的系数，$s_1$ 的系数，$Z$ 的值）。", "solution": "我们应用标准单纯形法对最大化问题的枢轴规则。\n\n1) 确定进基变量：在Z行中，决策变量中系数最负的是 $x_1$ 的 $-5$，所以 $x_1$ 进基。\n\n2) 对 $x_1$ 列进行最小比值检验以选择出基变量：\n$$\n\\frac{80}{10}=8 \\quad \\text{对于 } s_{1}, \\qquad \\frac{24}{2}=12 \\quad \\text{对于 } s_{2}.\n$$\n最小比值为 $8$，因此 $s_1$ 出基。枢轴元素是 $s_1$ 行和 $x_1$ 列中的 $10$。\n\n3) 进行枢轴变换，使枢轴元素为1，并从其他行中消去 $x_1$。\n\n将枢轴行（$s_1$ 行）除以 $10$ 进行归一化：\n$$\ns_{1}\\text{-行}: \\quad [0,\\;10,\\;8,\\;1,\\;0\\;|\\;80] \\;\\to\\; [0,\\;1,\\;\\tfrac{4}{5},\\;\\tfrac{1}{10},\\;0\\;|\\;8].\n$$\n\n将Z行加上 $5$ 倍新的 $s_1$ 行，以从Z行中消去 $x_1$：\n$$\nZ\\text{-行}: \\quad [1,\\;-5,\\;-4,\\;0,\\;0\\;|\\;0] + 5\\cdot[0,\\;1,\\;\\tfrac{4}{5},\\;\\tfrac{1}{10},\\;0\\;|\\;8]\n= [1,\\;0,\\;0,\\;\\tfrac{1}{2},\\;0\\;|\\;40].\n$$\n\n（从 $s_2$ 行中消去 $x_1$ 是完整枢轴操作的一部分，但对于所要求的Z行系数而言并非必要。）\n\n因此，在这次枢轴操作之后，Z行中 $x_2$ 的系数是 $0$，Z行中 $s_1$ 的系数是 $\\tfrac{1}{2}$，新的目标值 $Z$（Z行的右端项）是 $40$。", "answer": "$$\\boxed{\\begin{pmatrix}0 & \\frac{1}{2} & 40\\end{pmatrix}}$$", "id": "2221017"}, {"introduction": "线性规划中一个常见的误解是，无界的可行域必然导致无界的最优解。事实并非总是如此；目标函数的行为取决于其梯度与可行域的无界方向之间的关系。这个思想实验将引导你构建一个反例，以探索这一关键的几何概念，并理解为何即使在解空间无限的情况下，最优解仍可能存在。[@problem_id:2443959]", "problem": "在线性规划中，一个常见的误解是无界可行域必然导致目标函数无界。请仅使用基本原理，构建并分析一个二维线性规划问题，作为该说法的反例。\n\n从以下基本定义出发：\n- 可行域是满足问题所有线性约束的点的集合。\n- 如果存在一个方向向量，沿着该方向可以任意移动而仍保持在集合内，则该集合是无界的。\n- 线性目标函数是关于决策向量 $x$ 的线性形式 $c^{\\top}x$。\n\n考虑一个包含两个变量 $x_{1}$ 和 $x_{2}$ 的线性规划问题：\n- 决策变量：$x_{1} \\geq 0$，$x_{2} \\geq 0$。\n- 约束条件：$x_{1} \\leq 1$。\n- 目标：最大化 $z = x_{1}$。\n\n任务：\n1. 使用上述定义，直接从约束集论证可行域是无界的。\n2. 仅利用目标函数的线性性质和约束条件 $x_{1} \\leq 1$，确定目标函数的最优值。\n3. 解释为何在此实例中，可行域的无界性并未导致目标函数的无界性，并指出存在一个目标函数不增加的可行方向。\n\n请给出目标函数的最大值作为最终答案。答案需为精确数值，不进行四舍五入。", "solution": "该问题提出了一个线性规划问题，并要求进行分析，以证明无界可行域不一定意味着目标函数无界。我们将严格遵循基本原理和所给定义，系统地完成每一项任务。\n\n该线性规划问题由决策变量 $x_1$ 和 $x_2$ 定义如下：\n最大化 $z = x_1$\n约束条件：\n$x_1 \\leq 1$\n$x_1 \\geq 0$\n$x_2 \\geq 0$\n\n设可行域为集合 $S$。一个点 $p = (x_1, x_2)$ 属于 $S$ 当且仅当其坐标同时满足所有三个约束条件。因此，$S = \\{ (x_1, x_2) \\in \\mathbb{R}^2 \\mid 0 \\leq x_1 \\leq 1, x_2 \\geq 0 \\}$。该集合表示笛卡尔平面第一象限中的一个半无限带状区域。\n\n**任务1：可行域的无界性**\n\n为了证明可行域 $S$ 是无界的，我们必须根据所给定义证明，存在一个方向向量，沿着该方向可以任意移动而仍保持在集合内。\n\n我们选择一个点 $p_0 \\in S$。一个简单的选择是 $p_0 = (0, 0)$，它显然满足 $0 \\leq 0 \\leq 1$ 和 $0 \\geq 0$。\n现在，我们定义一个方向向量 $d = (0, 1)^T$。我们构造一条从 $p_0$ 点出发，方向为 $d$ 的射线。该射线上的任意点可以由参数 $\\lambda \\geq 0$ 表示为：\n$$ p(\\lambda) = p_0 + \\lambda d = (0, 0)^T + \\lambda (0, 1)^T = (0, \\lambda)^T $$\n任何此类点的坐标为 $(x_1, x_2) = (0, \\lambda)$。我们必须验证对于任意非负值 $\\lambda$，$p(\\lambda)$ 是否都保持在可行域 $S$ 内。我们检查约束条件：\n1.  $x_1 \\leq 1$：条件为 $0 \\leq 1$，成立。\n2.  $x_1 \\geq 0$：条件为 $0 \\geq 0$，成立。\n3.  $x_2 \\geq 0$：条件为 $\\lambda \\geq 0$，根据我们对参数 $\\lambda$ 的定义，此条件成立。\n\n由于对于任意 $\\lambda \\geq 0$，所有约束条件都得到满足，因此射线 $(0, \\lambda)$ 上的任意点都在可行集 $S$ 中。因为我们可以选择任意大的 $\\lambda$，所以我们可以沿方向 $d=(0,1)^T$ 从原点移动任意远的距离，并且仍然在 $S$ 内。因此，根据给定定义，可行域 $S$ 是无界的。\n\n**任务2：目标函数的最优值**\n\n目标是为可行域 $S$ 中的所有点 $(x_1, x_2)$ 最大化函数 $z = x_1$。$S$ 的定义包含了约束条件 $x_1 \\leq 1$。这个约束条件本身就对 $x_1$ 的可能取值施加了一个上界。\n\n目标函数 $z$ 是一个仅依赖于变量 $x_1$ 的线性函数。为了最大化 $z$，我们必须找到在可行域 $S$ 内允许的 $x_1$ 的最大可能值。定义 $S$ 的约束条件是 $0 \\leq x_1 \\leq 1$ 和 $x_2 \\geq 0$。从约束条件 $x_1 \\leq 1$ 可以清楚地看出，$x_1$ 的值永远不会超过 1。\n\n这个最大值在可行域内存在吗？是的。考虑点 $p^* = (1, 0)$。\n- $p^*$ 是否可行？我们检查约束条件：$x_1 = 1$ 满足 $0 \\leq 1 \\leq 1$，$x_2 = 0$ 满足 $0 \\geq 0$。因此，$p^* \\in S$。\n- 在此点，目标函数值为 $z = x_1 = 1$。\n\n因为对于任意点 $(x_1, x_2) \\in S$，我们有 $x_1 \\leq 1$，所以目标函数 $z = x_1$ 的上界为 1。由于我们已经找到了一个达到该值的可行点，因此目标函数的最大值恰好是 1。\n\n**任务3：解释有界目标函数与无界区域**\n\n在这种情况下，可行域的无界性并未导致目标函数的无界性。原因在于目标函数的梯度与可行域的无界方向之间的关系。\n\n目标函数为 $z = x_1$。这可以写成向量形式 $z = c^T x$，其中 $x = (x_1, x_2)^T$，成本向量（即 $z$ 的梯度）为 $c = (1, 0)^T$。\n\n在任务1中，我们确定了一个无界方向 $d = (0, 1)^T$。该向量表明我们可以沿 $x_2$ 正方向无限移动。要使目标函数无界，其值必须在沿着这样一个可行方向移动时无限增加。让我们分析目标函数沿此方向 $d$ 的变化。\n\n目标函数 $z$ 在方向 $d$ 上的变化率由方向导数给出，对于线性函数，这即是点积 $c^T d$。让我们计算这个值：\n$$ c^T d = (1, 0) \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix} = (1)(0) + (0)(1) = 0 $$\n结果 $c^T d = 0$ 表明，沿着无界方向 $d$ 移动根本不会改变目标函数的值。无界方向与目标函数增加的方向是正交的。\n\n为了说明这一点，考虑任意可行点 $p_0 = (x_{1,0}, x_{2,0}) \\in S$。我们从这个点沿方向 $d$ 移动。对于 $\\lambda \\geq 0$，新点为 $p(\\lambda) = p_0 + \\lambda d = (x_{1,0}, x_{2,0} + \\lambda)$。只要 $0 \\leq x_{1,0} \\leq 1$，这个新点对于所有 $\\lambda \\geq 0$ 都是可行的。这个新点的目标值为：\n$$ z(p(\\lambda)) = c^T p(\\lambda) = c^T(p_0 + \\lambda d) = c^T p_0 + \\lambda(c^T d) $$\n由于我们发现 $c^T d = 0$，此式可简化为：\n$$ z(p(\\lambda)) = c^T p_0 = x_{1,0} $$\n这证实了在可行集内，沿着任何平行于 $x_2$ 轴的射线，目标函数的值保持不变。区域的无界性存在于一个目标函数不增加的方向上。目标函数是有界的，因为它的值只依赖于 $x_1$，而 $x_1$ 本身受到约束的限制。\n\n总而言之，对于一个具有无界可行域的线性规划问题，若要其目标函数无界，必须存在一个无界的可行方向 $d$，使得 $c^T d > 0$。在这个反例中，不存在这样的方向；对于唯一的无界方向，我们有 $c^T d = 0$。", "answer": "$$\\boxed{1}$$", "id": "2443959"}, {"introduction": "单纯形法需要一个初始基本可行解来启动迭代过程，但找到这样一个解并非易事，尤其是在面对等式或“大于等于”约束时。两阶段法中的第一阶段（Phase I）是一个系统性的程序，它通过求解一个辅助问题来解决此问题，要么找到一个有效的初始基，要么证明原问题无解。这个编程练习将指导你实现这一关键阶段，将理论知识转化为解决任何线性规划问题的实用工具。[@problem_id:3192717]", "problem": "考虑线性规划 (LP) 中的形式可行性问题，即必须判断是否存在一个决策变量向量，满足一组有限的线性等式和不等式约束以及非负性限制。单纯形法通过寻找一个基本可行解 (BFS) 来构造性地解决可行性问题，该解由一组基变量构成，使得所有变量均为非负且满足约束条件。当无法直接构成一个基本可行解时，会使用标准的两阶段法。在第一阶段，通过引入人工变量来扩充约束，并最小化这些人工变量的总和。这可以由可行性的定义来证明：如果人工变量总和的最小值严格为正，则不存在任何原始变量向量能够在松弛或剩余变量非负的情况下满足所有约束，因此原始 LP 问题是不可行的。反之，若最小值为零，则证明原始约束存在一个基本可行解，并且所有人工变量都可以被驱动为零。\n\n您的任务是使用人工变量实现单纯形法的第一阶段，将其视为一个原始单纯形问题，目标是最大化人工变量总和的负数（等价于最小化它们的总和）。从以下基本基础开始：\n\n- LP 可行性定义：寻找 $x \\in \\mathbb{R}^n$ 使得 $A_{\\text{eq}} x = b_{\\text{eq}}$, $A_{\\text{le}} x \\le b_{\\text{le}}$, $A_{\\text{ge}} x \\ge b_{\\text{ge}}$ 且 $x \\ge 0$。\n- 松弛变量和剩余变量的构造：对于约束 $a_i^\\top x \\le b_i$，引入松弛变量 $s_i \\ge 0$ 写作 $a_i^\\top x + s_i = b_i$；对于约束 $a_i^\\top x \\ge b_i$，引入剩余变量 $s_i \\ge 0$ 写作 $a_i^\\top x - s_i = b_i$。\n- 人工变量的构造：对于无法提供直接基本可行解的约束（所有等式约束以及引入剩余变量后的所有 $\\ge$ 约束），添加一个人工变量 $a_i \\ge 0$ 写作 $a_i^\\top x - s_i + a_i = b_i$（对于 $\\ge$）或 $a_i^\\top x + a_i = b_i$（对于 $=$）。\n- 第一阶段目标：最小化 $\\sum_i a_i$，等价于最大化 $-\\sum_i a_i$。如果 $\\sum_i a_i$ 的最优值严格为正，则原始 LP 不可行。\n\n算法要求：\n\n- 使用检验数原则为第一阶段实现原始单纯形法。设 $M \\in \\mathbb{R}^{m \\times p}$ 是添加松弛、剩余和人工变量后的完整约束矩阵，其中 $p$ 是变量总数。设 $b \\in \\mathbb{R}^m$ 是经过必要符号调整以确保右侧非负后的右端向量。维护一个基索引集 $B$，使得 $B$ 从 $M$ 中选择 $m$ 列构成基矩阵 $M_B$。对于第一阶段的目标函数 $c \\in \\mathbb{R}^p$（其人工变量对应的条目为 $-1$，其他为 $0$），计算每个非基列 $j$ 的检验数 $r_j = c_j - c_B^\\top M_B^{-1} M_{\\cdot j}$。选择满足 $r_j > 0$ 的入基变量（使用 Bland 法则，即选择最小的索引以避免循环）。计算基变量的方向 $d = -M_B^{-1} M_{\\cdot j}$，对于 $d_i > 0$ 的索引使用最小比率测试 $t_i = x_{B,i} / (-d_i)$（等价于，对于 $M_B^{-1} M_{\\cdot j}$ 中分量为正的那些，使用 $x_{B,i} / (M_B^{-1} M_{\\cdot j})_i$），并进行主元变换。迭代直至不存在检验数为正的入基变量。第一阶段的最优值是 $-\\;c_B^\\top x_B$，它等于人工变量总和的最小值。\n\n- 行符号规范化：对于任何 $b_i < 0$ 的约束，将整行乘以 $-1$ 并翻转不等式方向（$\\le$ 变为 $\\ge$，反之亦然），以保持 $b_i \\ge 0$。等式约束乘以 $-1$ 后仍为等式。\n\n- 非负性：所有变量，包括原始变量、松弛变量、剩余变量和人工变量，都必须满足 $x \\ge 0$。\n\n测试套件：\n\n对于每个案例，变量为 $x_1, x_2 \\ge 0$。以 $(A, b, \\text{senses})$ 的形式提供约束，其中 $A \\in \\mathbb{R}^{m \\times 2}$，$b \\in \\mathbb{R}^m$，senses 是一个列表，其条目来自 $\\{\\text{le}, \\text{ge}, \\text{eq}\\}$，分别表示 $\\le$、$\\ge$、$=$。\n\n- 案例 $1$ (不可行): $A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 0 \\end{bmatrix}$, $b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$, senses $= ['le', 'ge']$。约束: $x_1 + x_2 \\le 1$, $x_1 \\ge 2$。\n- 案例 $2$ (可行，仅需松弛变量): $A = \\begin{bmatrix} 1 & 2 \\\\ 2 & 1 \\end{bmatrix}$, $b = \\begin{bmatrix} 4 \\\\ 5 \\end{bmatrix}$, senses $= ['le', 'le']$。约束: $x_1 + 2 x_2 \\le 4$, $2 x_1 + x_2 \\le 5$。\n- 案例 $3$ (可行，等式需要人工变量): $A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 2 \\end{bmatrix}$, $b = \\begin{bmatrix} 3 \\\\ 5 \\end{bmatrix}$, senses $= ['eq', 'le']$。约束: $x_1 + x_2 = 3$, $x_1 + 2 x_2 \\le 5$。\n- 案例 $4$ (不可行，等式不一致): $A = \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}$, $b = \\begin{bmatrix} 1 \\\\ 2 \\end{bmatrix}$, senses $= ['eq', 'eq']$。约束: $x_1 + x_2 = 1$, $x_1 + x_2 = 2$。\n- 案例 $5$ (可行，行符号翻转和混合类型): $A = \\begin{bmatrix} -1 & 1 \\\\ 0 & 1 \\end{bmatrix}$, $b = \\begin{bmatrix} -1 \\\\ 2 \\end{bmatrix}$, senses $= ['ge', 'le']$。约束: $-x_1 + x_2 \\ge -1$, $x_2 \\le 2$。\n\n输出规格：\n\n- 您的程序必须生成一行包含浮点数列表的输出，每个测试案例一个，每个浮点数等于第一阶段目标 $\\sum a_i$ 的最小化最优值（等价于 $-\\max (-\\sum a_i)$），并四舍五入到六位小数。\n- 在最终报告的数字中，将绝对值小于 $10^{-8}$ 的值解释为零。\n- 确切的输出格式必须是单行形式 $[v_1,v_2,v_3,v_4,v_5]$，其中每个 $v_k$ 是一个小数点后有六位数字的十进制数。\n\n此问题不涉及物理单位或角度，因此无需单位说明。", "solution": "用户的要求是实现单纯形法的第一阶段，以用于线性规划的可行性判断。该问题旨在确定一组线性约束是否存在非负解。这通过最小化辅助人工变量的总和来实现。如果最小和为零，则原始问题可行；如果严格为正，则不可行。\n\n### 问题验证\n\n**第 1 步：提取已知信息**\n\n- **问题定义**：寻找 $x \\in \\mathbb{R}^n$ 使得 $A_{\\text{eq}} x = b_{\\text{eq}}$，$A_{\\text{le}} x \\le b_{\\text{le}}$，$A_{\\text{ge}} x \\ge b_{\\text{ge}}$ 且 $x \\ge 0$。\n- **标准型转换**：\n    - 对于 $a_i^\\top x \\le b_i$，使用松弛变量 $s_i \\ge 0$：$a_i^\\top x + s_i = b_i$。\n    - 对于 $a_i^\\top x \\ge b_i$，使用剩余变量 $s_i \\ge 0$：$a_i^\\top x - s_i = b_i$。\n- **人工变量**：对于等式约束和 $\\ge$ 约束，添加一个人工变量 $a_i \\ge 0$ 以在初始基中服务。\n- **第一阶段目标**：最小化 $\\sum_i a_i$，等价于最大化 $z = -\\sum_i a_i$。$\\sum_i a_i$ 的严格为正的最小值意味着不可行。\n- **算法规格**：使用检验数的原始单纯形法。\n    - 完整约束矩阵 $M \\in \\mathbb{R}^{m \\times p}$。\n    - 右端向量 $b \\in \\mathbb{R}^m$，所有条目均非负。\n    - 大小为 $m$ 的基索引集 $B$。\n    - 第一阶段成本向量 $c$：人工变量为 $c_j = -1$，否则为 $0$。\n    - 检验数：$r_j = c_j - c_B^\\top M_B^{-1} M_{\\cdot j}$。\n    - 入基变量：具有 $r_j > 0$ 的最小索引 $j$（Bland 法则）。\n    - 出基变量：最小比率检验，使用 Bland 法则解决平局问题。\n- **行规范化**：如果 $b_i < 0$，将该约束乘以 $-1$ 并反转不等式方向。\n- **测试案例**：提供了五个不同的案例，每个都由矩阵 $A$、向量 $b$ 和一个类型列表（`le`、`ge`、`eq`）定义。\n- **输出格式**：一个单行列表，包含每个测试案例的人工变量最小和，四舍五入到六位小数。绝对值小于 $10^{-8}$ 的值被视为零。\n\n**第 2 步：使用提取的已知信息进行验证**\n\n根据验证标准评估问题陈述：\n\n1.  **科学依据**：该问题在根本上是合理的。它描述了单纯形法第一阶段的标准、教科书式的表述，这是运筹学和计算科学的基石。\n2.  **良构性**：该问题是良构的。目标清晰，算法明确定义（使用 Bland 法则的原始单纯形法以防止循环），并且每个测试案例的输入都已完全指定。这确保了一个唯一的、有意义的解（人工变量的最小和）存在且可计算。\n3.  **客观性**：该问题以精确、客观的数学语言陈述，没有任何主观性或歧义。\n4.  **完整性与一致性**：问题的设置是完整的且内部一致。它提供了所有必要的组成部分：约束转换规则、目标函数定义、算法步骤和具体的测试数据。\n\n**第 3 步：结论与行动**\n\n该问题是**有效的**。它是计算科学领域一个清晰、合理且可形式化的任务。解决方案将继续执行指定算法的实现。\n\n### 算法设计与解决方案\n\n解决方案的核心是一个 Python 函数，该函数为第一阶段目标实现了原始单纯形算法。步骤如下：\n\n1.  **预处理和单纯形表构造**：\n    - 处理输入约束 $(A, b, \\text{senses})$。每个右端项 $b_i$ 为负的约束都乘以 $-1$，其类型也相应翻转。这确保了所有 $b_i \\ge 0$。\n    - 为第一阶段问题构造一个完整的矩阵 $M$。其列对应于原始变量 ($x_j$)、松弛变量 ($s_k$)、剩余变量 ($sl_l$) 和人工变量 ($a_p$)。\n    - 创建第一阶段的成本向量 $c$。对于每个人工变量，其条目为 $-1$，对于所有其他变量，条目为 $0$，这与最大化 $z = -\\sum_i a_i$ 的目标一致。\n\n2.  **初始基的识别**：\n    - 需要辅助问题的一个初始基本可行解 (BFS)。\n    - 对于每个 $\\le$ 类型的约束（规范化后），相应的松弛变量可以作为该行的基变量。\n    - 对于每个 $\\ge$ 或 $=$ 类型的约束，引入一个人工变量，并作为该行的基变量。\n    - 这些基变量的索引集构成了初始基 $B$。如果不需要人工变量，则原始问题显然可行，最小和为 $0$。\n\n3.  **单纯形迭代**：\n    - 算法进行迭代，直到找到第一阶段问题的最优解。每次迭代包括以下步骤：\n    - **计算检验数**：计算单纯形乘子（或对偶变量）向量 $\\pi = c_B^\\top M_B^{-1}$，其中 $M_B$ 是由 $M$ 中对应于基 $B$ 中变量的列构成的基矩阵，$c_B$ 是它们的成本。然后，每个非基变量 $j$ 的检验数为 $r_j = c_j - \\pi M_{\\cdot j}$。\n    - **选择入基变量**：根据 Bland 法则，选择具有 $r_j > 0$ 的最小索引 $j$ 的非基变量进入基。如果不存在这样的变量，则当前解是最优的，循环终止。\n    - **选择出基变量（最小比率测试）**：为入基变量 $j$ 计算基变量的变化方向 $d = M_B^{-1} M_{\\cdot j}$。通过最小比率测试找到最大步长 $\\theta$：$\\theta = \\min \\{ x_{B,i} / d_i \\mid d_i > 0 \\}$，其中 $x_B = M_B^{-1} b$ 是当前基变量值的向量。离开基的变量是限制 $\\theta$ 的那一个。使用 Bland 法则打破平局：在所有产生最小比率的行中，选择对应于最小索引的基变量的那一行。\n    - **主元变换**：通过用入基变量的索引替换出基变量的索引来更新基 $B$。\n\n4.  **终止与结果**：\n    - 当所有检验数都为非正数时，循环终止。第一阶段目标的最优值为 $z_{\\text{opt}} = c_B^\\top x_B$。\n    - 人工变量的最小和为 $-z_{\\text{opt}}$。\n    - 返回该值。值 $0$（在小容差范围内）表示可行；严格为正的值表示不可行。\n\n该计算过程使用 Python 的 `NumPy` 库进行矩阵运算实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve_phase1(A, b, senses, tol=1e-9):\n    \"\"\"\n    Implements Phase I of the Simplex method to determine LP feasibility.\n\n    This function sets up and solves the Phase I linear program, which seeks to\n    minimize the sum of artificial variables.\n\n    Args:\n        A (np.ndarray): The coefficient matrix of the original constraints.\n        b (np.ndarray): The right-hand side vector of the original constraints.\n        senses (list): A list of strings ('le', 'ge', 'eq') indicating the sense\n                       of each constraint.\n        tol (float): A tolerance for floating-point comparisons.\n\n    Returns:\n        float: The minimum sum of artificial variables. A value of 0 indicates\n               feasibility, while a positive value indicates infeasibility. Returns\n               inf if the algorithm fails to converge or encounters an issue.\n    \"\"\"\n    m, n = A.shape\n\n    # 1. Preprocessing and Tableau Setup\n    A_p = A.copy().astype(float)\n    b_p = b.copy().astype(float)\n    senses_p = list(senses)\n\n    # Row normalization to ensure b_p >= 0\n    for i in range(m):\n        if b_p[i] < 0:\n            A_p[i, :] *= -1\n            b_p[i] *= -1\n            if senses_p[i] == 'le': senses_p[i] = 'ge'\n            elif senses_p[i] == 'ge': senses_p[i] = 'le'\n\n    # Build variable map to track original, slack, surplus, and artificial variables\n    var_map = []\n    # Original variables\n    for i in range(n):\n        var_map.append(('orig', i))\n    \n    # Add slack, surplus, and artificial variables based on constraint senses\n    for i in range(m):\n        if senses_p[i] == 'le':\n            var_map.append(('slack', i))\n        elif senses_p[i] == 'ge':\n            var_map.append(('surplus', i))\n            var_map.append(('artif', i))\n        elif senses_p[i] == 'eq':\n            var_map.append(('artif', i))\n\n    # If no artificial variables are needed, the problem is trivially feasible\n    if not any(v_type == 'artif' for v_type, _ in var_map):\n      return 0.0\n\n    # Build the full constraint matrix M for the Phase I problem\n    num_total_vars = len(var_map)\n    M = np.zeros((m, num_total_vars))\n    M[:, :n] = A_p\n    for k in range(n, num_total_vars):\n        v_type, v_orig_idx = var_map[k]\n        if v_type == 'slack': M[v_orig_idx, k] = 1.0\n        elif v_type == 'surplus': M[v_orig_idx, k] = -1.0\n        elif v_type == 'artif': M[v_orig_idx, k] = 1.0\n\n    # Build the cost vector c for Phase I (maximize -sum(a_i))\n    c = np.zeros(num_total_vars)\n    for k, (v_type, _) in enumerate(var_map):\n        if v_type == 'artif': c[k] = -1.0\n\n    # 2. Initial Basis Identification\n    basis = [-1] * m\n    for i in range(m):\n        if senses_p[i] == 'le':\n            # Find the slack variable for row i to be basic\n            for k, (v_type, v_orig_idx) in enumerate(var_map):\n                if v_type == 'slack' and v_orig_idx == i:\n                    basis[i] = k\n                    break\n        else:  # 'ge' or 'eq'\n            # Find the artificial variable for row i to be basic\n            for k, (v_type, v_orig_idx) in enumerate(var_map):\n                if v_type == 'artif' and v_orig_idx == i:\n                    basis[i] = k\n                    break\n    \n    # 3. Simplex Loop\n    max_iter = 5 * m # Set a practical iteration limit\n    for _ in range(max_iter):\n        M_B = M[:, basis]\n        c_B = c[basis]\n\n        try:\n            M_B_inv = np.linalg.inv(M_B)\n        except np.linalg.LinAlgError:\n            # Singular basis matrix, indicates a problem like linearly dependent constraints.\n            # In Phase I, this suggests the system is ill-defined or infeasible.\n            return np.inf\n\n        non_basis_indices = sorted([i for i in range(num_total_vars) if i not in basis])\n        pi = c_B @ M_B_inv # Simplex multipliers\n\n        # Bland's rule for entering variable: choose smallest index with positive reduced cost\n        entering_var = -1\n        for j in non_basis_indices:\n            rc = c[j] - pi @ M[:, j]\n            if rc > tol:\n                entering_var = j\n                break\n\n        if entering_var == -1: # Optimality reached\n            x_B = M_B_inv @ b_p\n            obj_val = c_B @ x_B\n            return -obj_val\n\n        # Minimum Ratio Test to find leaving variable\n        d = M_B_inv @ M[:, entering_var]\n        \n        if np.all(d <= tol):\n            # Unbounded problem. This should not occur in a well-formed Phase I.\n            return np.inf\n\n        x_B = M_B_inv @ b_p\n        \n        min_ratio = np.inf\n        potential_leaves = []\n        for i in range(m):\n            if d[i] > tol:\n                ratio = x_B[i] / d[i]\n                if ratio < min_ratio - tol:\n                    min_ratio = ratio\n                    potential_leaves = [(ratio, basis[i])]\n                elif abs(ratio - min_ratio) < tol:\n                    potential_leaves.append((ratio, basis[i]))\n        \n        if not potential_leaves:\n           # This case should be prevented by the check for d > tol.\n           return np.inf\n            \n        # Bland's rule for leaving variable: break ties with smallest variable index\n        leaving_var = min(var_idx for _, var_idx in potential_leaves)\n        \n        # Pivot: update the basis\n        leaving_row_idx = basis.index(leaving_var)\n        basis[leaving_row_idx] = entering_var\n\n    return np.inf # Failed to converge within iteration limit\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run the Phase I simplex solver.\n    \"\"\"\n    test_cases = [\n        # Case 1 (infeasible)\n        (np.array([[1, 1], [1, 0]]), np.array([1, 2]), ['le', 'ge']),\n        # Case 2 (feasible, slack-only)\n        (np.array([[1, 2], [2, 1]]), np.array([4, 5]), ['le', 'le']),\n        # Case 3 (feasible, equality requires artificial)\n        (np.array([[1, 1], [1, 2]]), np.array([3, 5]), ['eq', 'le']),\n        # Case 4 (infeasible, inconsistent equalities)\n        (np.array([[1, 1], [1, 1]]), np.array([1, 2]), ['eq', 'eq']),\n        # Case 5 (feasible, row sign flip)\n        (np.array([[-1, 1], [0, 1]]), np.array([-1, 2]), ['ge', 'le']),\n    ]\n\n    results = []\n    for A, b, senses in test_cases:\n        raw_result = solve_phase1(A, b, senses)\n        # Interpret values smaller than 1e-8 as zero, as per problem spec\n        if abs(raw_result) < 1e-8:\n            final_result = 0.0\n        else:\n            final_result = raw_result\n        results.append(final_result)\n\n    # Format the final output string exactly as required\n    formatted_results = [f\"{res:.6f}\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3192717"}]}