{"hands_on_practices": [{"introduction": "在编写任何代码之前，深入理解算法背后的数学原理至关重要。黄金分割搜索的效率并非偶然，它源于一个精确且恒定的区间收缩因子——黄金比例的共轭。这项练习将引导你从第一性原理出发，推导出这个关键常数，并运用它来预测算法的性能，这是算法分析中的一项核心技能。通过这项纯粹的计算练习 [@problem_id:3166848]，你将对该算法为何有效建立起深刻而直观的理解。", "problem": "考虑闭区间 $[-3,3]$ 上的函数 $f(x) = \\exp(-x^{2})$。您将通过使用黄金分割搜索法（Golden-Section Search, GSS）来最小化 $g(x) = -f(x)$，从而定位其全局最大值。GSS是一种区间搜索方法，其在区间内放置两个内点，使得在舍弃一次函数评估后，剩余的区间保持相同的内部分割比例，并重用一个先前评估过的点。\n\n任务：\n- 不使用导数，根据单峰性（unimodality）的定义以及 $\\exp(-x^{2})$ 在 $|x|$ 上的单调性，论证 $g(x)$ 在 $[-3,3]$ 上是单峰的，且在区间内的一点上达到唯一的最小值。\n- 根据黄金分割搜索的定义性自相似特性（不提供公式；从第一性原理推导），确定每次迭代中包围区间的长度收缩的恒定因子。\n- 使用该收缩因子和初始区间长度，确定所需的最小整数迭代次数 $N$，使得最终包围区间的长度最多为 $2 \\times 10^{-6}$，这保证了从该区间返回的任何点（例如，其中点）与真实最大值点的绝对值差最多为 $10^{-6}$。\n\n只报告整数 $N$ 作为您的最终答案。由于 $N$ 是整数，因此无需进行舍入说明。", "solution": "该问题被评估为有效，因为它在计算数学方面有科学依据，问题设定良好且有唯一解，并且陈述客观。它展示了黄金分割搜索算法的一个标准应用，没有任何逻辑矛盾或信息缺失。\n\n解题过程按照题目要求分为三个部分呈现。\n\n**第1部分：$g(x)$ 的单峰性**\n\n如果在一个区间 $[a,b]$ 上存在一个唯一点 $x^* \\in [a,b]$，使得函数在该点达到其唯一的最小值（或最大值），并且函数在 $x^*$ 的两侧都是严格单调的，那么函数 $h(x)$ 在该区间上被定义为严格单峰的。我们需要在区间 $[-3,3]$ 上最小化 $g(x) = -\\exp(-x^2)$。这等同于在同一区间上最大化函数 $f(x) = \\exp(-x^2)$。我们必须在不使用导数的情况下证明 $g(x)$ 在 $[-3,3]$ 上是严格单峰的。\n\n让我们分析一下各组成函数的行为。\n1.  函数 $u(x) = x^2$ 在 $x \\in [-3, 0]$ 上是严格递减的，在 $x \\in [0, 3]$ 上是严格递增的。它在该区间上的唯一最小值在 $x=0$ 处取得。\n2.  函数 $v(x) = -u(x) = -x^2$ 将具有相反的单调性。它在 $x \\in [-3, 0]$ 上是严格递增的，在 $x \\in [0, 3]$ 上是严格递减的。它在该区间上的唯一最大值在 $x=0$ 处取得。\n3.  指数函数 $f(x) = \\exp(v(x)) = \\exp(-x^2)$ 是其自变量的严格单调递增函数。因此，$f(x)$ 的单调性与其指数 $v(x)=-x^2$ 的单调性相同。所以，$f(x)$ 在 $[-3, 0]$ 上是严格递增的，在 $[0, 3]$ 上是严格递减的。这意味着 $f(x)$ 在 $x=0$ 处有一个唯一最大值。\n4.  需要最小化的函数是 $g(x) = -f(x) = -\\exp(-x^2)$。乘以 $-1$ 会反转单调性。因此，$g(x)$ 在 $[-3, 0]$ 上是严格递减的，在 $[0, 3]$ 上是严格递增的。\n\n根据定义，一个先严格递减到一个唯一最小值，然后严格递增的函数是严格单峰的。函数 $g(x)$ 在 $[-3,3]$ 上表现出这种行为，其唯一最小值出现在点 $x=0$ 处，该点在区间内。这就完成了对 $g(x)$ 在 $[-3,3]$ 上单峰性的论证。\n\n**第2部分：收缩因子的推导**\n\n黄金分割搜索（GSS）算法在每次迭代中将包围区间的长度缩减一个恒定的因子。设这个收缩因子为 $\\rho \\in (0,1)$。\n\n设第 $k$ 次迭代的包围区间为 $[a_k, b_k]$，其长度为 $L_k = b_k - a_k$。在区间内选择两个内点 $x_{k,1}$ 和 $x_{k,2}$，使得 $a_k < x_{k,1} < x_{k,2} < b_k$。这些点的放置是对称的，即无论舍弃原区间的哪一端，新区间的长度都相同。这个新长度是 $L_{k+1} = \\rho L_k$。\n这意味着子区间 $[a_k, x_{k,2}]$ 的长度必须等于子区间 $[x_{k,1}, b_k]$ 的长度。\n$$x_{k,2} - a_k = b_k - x_{k,1} = \\rho L_k$$\n由此，我们可以表达出内点的位置：\n$$x_{k,2} = a_k + \\rho L_k$$\n$$x_{k,1} = b_k - \\rho L_k = (a_k + L_k) - \\rho L_k = a_k + (1-\\rho)L_k$$\n为了使点正确排序（$x_{k,1} < x_{k,2}$），我们必须有 $1-\\rho < \\rho$，这意味着 $1 < 2\\rho$，即 $\\rho > \\frac{1}{2}$。\n\nGSS 的定义性特性是第 $k$ 次迭代中的一个内点可以在第 $k+1$ 次迭代中被重用。假设在 $x_{k,1}$ 和 $x_{k,2}$ 处评估函数后，我们发现最小值位于区间 $[a_k, x_{k,2}]$ 内。新的区间是 $[a_{k+1}, b_{k+1}] = [a_k, x_{k,2}]$。这个新区间的长度是 $L_{k+1} = x_{k,2} - a_k = \\rho L_k$。点 $x_{k,1}$ 包含在这个新区间内。\n\n对于第 $k+1$ 次迭代，我们需要在 $[a_{k+1}, b_{k+1}]$ 内选择两个新的内点 $x_{k+1,1}$ 和 $x_{k+1,2}$。根据相同的规则，它们必须位于：\n$$x_{k+1,1} = a_{k+1} + (1-\\rho)L_{k+1} = a_k + (1-\\rho)(\\rho L_k)$$\n$$x_{k+1,2} = a_{k+1} + \\rho L_{k+1} = a_k + \\rho(\\rho L_k) = a_k + \\rho^2 L_k$$\n\n自相似性或点重用原则要求旧点 $x_{k,1}$ 必须与新点 $x_{k+1,1}$ 或 $x_{k+1,2}$ 中的一个重合。旧点是 $x_{k,1} = a_k + (1-\\rho)L_k$。\n根据对称性，另一种情况（新区间为 $[x_{k,1}, b_k]$）将导致相同的条件。\n让我们检查两种匹配点的可能性：\n1.  $x_{k,1} = x_{k+1,1}$：$a_k + (1-\\rho)L_k = a_k + (1-\\rho)\\rho L_k$。由于 $L_k \\neq 0$ 且 $\\rho \\neq 1$，我们可以简化为 $1 = \\rho$。这与要求 $\\rho < 1$ 相矛盾。\n2.  $x_{k,1} = x_{k+1,2}$：$a_k + (1-\\rho)L_k = a_k + \\rho^2 L_k$。这简化为 $1-\\rho = \\rho^2$。\n\n整理后得到二次方程：\n$$\\rho^2 + \\rho - 1 = 0$$\n使用二次方程求根公式求解 $\\rho$：\n$$\\rho = \\frac{-1 \\pm \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{-1 \\pm \\sqrt{5}}{2}$$\n由于收缩因子 $\\rho$ 必须是正值（它是长度的比率），我们必须取正根：\n$$\\rho = \\frac{\\sqrt{5}-1}{2}$$\n这个值是黄金比例 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 的倒数，通常表示为 $\\frac{1}{\\phi}$。其近似值为 $0.618034$。\n\n**第3部分：最小迭代次数**\n\n初始区间为 $[-3, 3]$，所以其长度为 $L_0 = 3 - (-3) = 6$。\n$N$ 次迭代后区间的长度由 $L_N = \\rho^N L_0$ 给出。\n题目要求最终包围区间的长度 $L_N$ 最多为 $2 \\times 10^{-6}$。所以我们必须找到满足以下不等式的最小整数 $N$：\n$$L_N \\le 2 \\times 10^{-6}$$\n代入 $L_N$ 的表达式以及 $L_0$ 和 $\\rho$ 的值：\n$$\\left(\\frac{\\sqrt{5}-1}{2}\\right)^N (6) \\le 2 \\times 10^{-6}$$\n两边除以 6：\n$$\\left(\\frac{\\sqrt{5}-1}{2}\\right)^N \\le \\frac{2 \\times 10^{-6}}{6} = \\frac{1}{3} \\times 10^{-6}$$\n为了求解 $N$，我们对两边取自然对数。由于 $\\ln(x)$ 是一个增函数，不等号的方向保持不变。\n$$N \\ln\\left(\\frac{\\sqrt{5}-1}{2}\\right) \\le \\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right)$$\n因为项 $\\frac{\\sqrt{5}-1}{2} \\approx 0.618$ 小于 1，所以它的对数是负数。当我们除以这个负数时，我们必须反转不等号的方向：\n$$N \\ge \\frac{\\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right)}{\\ln\\left(\\frac{\\sqrt{5}-1}{2}\\right)}$$\n让我们来计算分子和分母：\n$$ \\ln\\left(\\frac{1}{3} \\times 10^{-6}\\right) = \\ln(1) - \\ln(3) - \\ln(10^6) = -\\ln(3) - 6\\ln(10) $$\n分母可以使用黄金比例 $\\phi = \\frac{1+\\sqrt{5}}{2}$ 表示为 $\\ln\\left(\\frac{1}{\\phi}\\right) = -\\ln(\\phi)$。\n$$ N \\ge \\frac{-\\ln(3) - 6\\ln(10)}{-\\ln(\\phi)} = \\frac{\\ln(3) + 6\\ln(10)}{\\ln\\left(\\frac{1+\\sqrt{5}}{2}\\right)} $$\n使用对数的数值：\n$$ \\ln(3) \\approx 1.09861 $$\n$$ \\ln(10) \\approx 2.30259 $$\n$$ \\ln\\left(\\frac{1+\\sqrt{5}}{2}\\right) \\approx \\ln(1.618034) \\approx 0.48121 $$\n代入这些值：\n$$ N \\ge \\frac{1.09861 + 6(2.30259)}{0.48121} = \\frac{1.09861 + 13.81554}{0.48121} = \\frac{14.91415}{0.48121} \\approx 30.993 $$\n由于迭代次数 $N$ 必须是整数，我们必须取大于或等于 $30.993$ 的最小整数。\n$$ N = 31 $$", "answer": "$$\\boxed{31}$$", "id": "3166848"}, {"introduction": "掌握了理论基础后，下一步便是将这些知识转化为实际可用的工具。这个实践任务要求你亲手编写黄金分割搜索算法，通过代码实现区间的迭代收缩和内部点的管理。这项编码练习 [@problem_id:3166878] 不仅能锻炼你的编程能力，更会通过精心设计的测试案例，揭示黄金分割搜索的一个基本特性：其收敛速度是稳定且可预测的，并不会因为“幸运地”在早期就猜中极值点而发生改变。", "problem": "你需要从第一性原理出发，设计并实现一个使用黄金分割搜索（GSS）的一维最小化算法。所使用的基本依据是闭区间上单峰函数的定义，以及采样点的选择必须保持搜索区间的自相似性，以便在每次迭代中可以复用一个函数值。一个连续单峰函数在一个区间上只有一个局部最小值，通过在缩减区间的同时保持连续区间长度间的固定比率，可以系统性地收敛到该最小值。你的任务是推导实现这种不变性的点位布置规则，实现所得算法，并量化当初始内点位置有利时，算法检测到收敛的速度有多快。\n\n实现黄金分割搜索算法，用于在区间 $[a,b]$上最小化一个连续单峰函数 $f(x)$。该算法必须：\n- 在$[a,b]$中初始化两个内部评估点，每次区间缩减后复用一次函数求值。\n- 在每次迭代中，通过比较内部点的函数值，将区间缩减到包含最小值点的子区间。\n- 当区间长度小于或等于预设容差$\\varepsilon$时终止。\n- 返回三个量：直到终止的迭代次数$n$、最小值点$x^\\star$的最终近似值，以及函数值$f(x^\\star)$。\n\n创建一个特殊测试用例，使初始内点之一在开始时与最小值点完全对齐。考虑区间$[0,1]$上的函数$f(x) = (x - \\tau)^2$，其中$\\tau$是黄金比例共轭$\\tau = (\\sqrt{5} - 1)/2 \\approx 0.618$。因为黄金分割搜索中的初始内点位于$x_1 = b - \\tau (b-a)$和$x_2 = a + \\tau (b-a)$，所以在$[0,1]$上，其中一个点等于$x^\\star = \\tau$。通过测量在严格容差$\\varepsilon$下的迭代次数$n$，验证算法检测到收敛的速度有多快。\n\n你的程序必须根据这些原理实现黄金分割搜索，并将其应用于以下测试套件。对于每个测试用例，返回一个形式为$[n, x^\\star, f(x^\\star)]$的列表，并如下文规定，将所有结果汇总到一个单行打印的列表中。\n\n测试套件：\n- 用例1（对齐的内点）：$f_1(x) = (x - \\tau)^2$，区间$[0,1]$，容差$\\varepsilon = 10^{-8}$。\n- 用例2（对称但未对齐）：$f_2(x) = (x - 0.5)^2$，区间$[0,1]$，容差$\\varepsilon = 10^{-8}$。\n- 用例3（最小值在端点）：$f_3(x) = x^2$，区间$[0,1]$，容差$\\varepsilon = 10^{-8}$。\n- 用例4（最小值点周围的极小初始区间）：$f_4(x) = (x - \\tau)^2$，区间$[\\tau - 10^{-12}, \\tau + 10^{-12}]$，容差$\\varepsilon = 10^{-9}$。\n- 用例5（光滑严格凸函数，较宽区间）：$f_5(x) = \\mathrm{e}^{x} + \\mathrm{e}^{-x}$，区间$[-1,2]$，容差$\\varepsilon = 10^{-8}$。\n\n最终输出格式：\n- 你的程序应产生单行输出，包含一个由方括号括起来的逗号分隔列表（例如，$[result_1,result_2,\\dots]$）。\n- 对于每个用例，输出列表$[n, x^\\star, f(x^\\star)]$，其中$n$是整数，而$x^\\star$和$f(x^\\star)$均为四舍五入到$10$位小数的浮点数。\n- 结果的顺序必须与上述测试套件的顺序相匹配。\n- 不涉及角度；无需角度单位。不涉及物理单位。", "solution": "该问题要求从第一性原理出发，设计并实现黄金分割搜索（GSS）算法，用于在闭区间$[a,b]$上最小化一个连续单峰函数$f(x)$。\n\n### 黄金分割搜索的原理与推导\n\n如果在一个区间$[a,b]$上存在唯一的值$x^\\star \\in [a,b]$使得$f(x)$在该点取得最小值，并且对于区间内任意两点$x_1 < x_2$，若$x_2 < x^\\star$则$f(x_1) > f(x_2)$，若$x_1 > x^\\star$则$f(x_1) < f(x_2)$，那么函数$f(x)$在该区间上是单峰的。简单来说，该函数在最小值点的左侧严格递减，在右侧严格递增。\n\n黄金分割搜索的核心是迭代地缩减区间$[a,b]$，同时确保最小值点$x^\\star$始终位于缩减后的区间内。为此，我们在两个内点$x_1$和$x_2$处对函数进行采样，满足$a < x_1 < x_2 < b$。\n\n通过比较函数值$f(x_1)$和$f(x_2)$，我们可以舍弃一部分区间：\n1.  如果$f(x_1) < f(x_2)$，最小值不可能在子区间$(x_2, b]$内，因为如果最小值在该子区间内，那么$x_1$和$x_2$都将位于最小值点的左侧，根据单峰性定义，这将意味着$f(x_1) > f(x_2)$，这与前提矛盾。因此，新的搜索区间必须是$[a, x_2]$。\n2.  如果$f(x_1) \\geq f(x_2)$，最小值不可能在子区间$[a, x_1)$内，因为如果最小值在该子区间内，那么$x_1$和$x_2$都将位于最小值点的右侧，这意味着$f(x_1) < f(x_2)$，这与前提矛盾。因此，新的搜索区间必须是$[x_1, b]$。\n\n提高效率的关键在于选择$x_1$和$x_2$的位置，使得其中一个点（及其对应的函数求值）可以在下一次迭代中被复用。这通过对称地放置点位并在每一步保持恒定的区间缩减比率来实现。\n\n设第$k$步的区间长度为$L_k = b_k - a_k$。我们希望每一步都将长度缩减一个常数因子$\\tau$，即$L_{k+1} = \\tau L_k$。让我们根据区间长度来定义内点的位置。我们选择一个参数$\\tau \\in (1/2, 1)$，并从区间两端对称地放置这些点：\n$x_{1,k} = b_k - \\tau(b_k - a_k)$\n$x_{2,k} = a_k + \\tau(b_k - a_k)$\n\n注意，因为$\\tau > 1/2$，我们有$a_k < x_{1,k} < x_{2,k} < b_k$，正如所要求的那样。\n\n现在，考虑$f(x_{1,k}) < f(x_{2,k})$的情况。新的区间是$[a_{k+1}, b_{k+1}] = [a_k, x_{2,k}]$。\n这个新区间的长度是$L_{k+1} = x_{2,k} - a_k = \\tau(b_k - a_k) = \\tau L_k$。这与我们恒定比率缩减的目标一致。\n新区间$[a_{k+1}, b_{k+1}]$包含一个旧的内点$x_{1,k}$。对于下一次迭代，我们需要两个新的内点$x_{1,k+1}$和$x_{2,k+1}$，它们由相同的规则定义：\n$x_{1,k+1} = b_{k+1} - \\tau L_{k+1} = x_{2,k} - \\tau(\\tau L_k) = (a_k + \\tau L_k) - \\tau^2 L_k = a_k + (\\tau - \\tau^2)L_k$。\n$x_{2,k+1} = a_{k+1} + \\tau L_{k+1} = a_k + \\tau(\\tau L_k) = a_k + \\tau^2 L_k$。\n\n为了复用一次函数求值，旧点$x_{1,k}$必须与新点$x_{1,k+1}$或$x_{2,k+1}$之一重合。旧点的位置是$x_{1,k} = b_k - \\tau L_k = (a_k+L_k) - \\tau L_k = a_k + (1-\\tau)L_k$。将其与新点进行比较，我们可以强制施加条件$x_{1,k} = x_{2,k+1}$（通过观察，这两个点是各自区间内更靠近中心的点）。这给出了方程：\n$a_k + (1-\\tau)L_k = a_k + \\tau^2 L_k$\n$1 - \\tau = \\tau^2$\n$\\tau^2 + \\tau - 1 = 0$\n\n求解这个二次方程的正根，得到：\n$\\tau = \\frac{-1 + \\sqrt{1^2 - 4(1)(-1)}}{2(1)} = \\frac{\\sqrt{5} - 1}{2}$\n\n这个值，约等于$0.618034$，是黄金比例共轭，通常表示为$\\phi^{-1}$或简写为$\\tau$。对于$f(x_{1,k}) \\geq f(x_{2,k})$的情况，一个对称的论证表明，旧点$x_{2,k}$成为新点$x_{1,k+1}$。\n\n因此，通过选择$\\tau = (\\sqrt{5} - 1)/2$，我们保证在每一步中，区间长度都按因子$\\tau$缩减，并且可以复用一次函数求值。\n\n### 算法实现\n\n算法流程如下：\n1.  **初始化**：给定$f(x)$、$[a,b]$和容差$\\varepsilon$。定义$\\tau = (\\sqrt{5}-1)/2$。计算初始内点$x_1 = b - \\tau(b-a)$和$x_2 = a + \\tau(b-a)$，并计算$f_1 = f(x_1)$和$f_2 = f(x_2)$。初始化迭代计数器$n=0$。\n2.  **迭代**：当区间长度$(b-a) > \\varepsilon$时：\n    a. 将$n$加1。\n    b. 如果$f_1 < f_2$：\n        i. 新区间为$[a, x_2]$。设置$b = x_2$。\n        ii. 旧的$x_1$成为新的$x_2$。设置$x_2 = x_1$和$f_2 = f_1$。\n        iii. 计算新的$x_1 = b - \\tau(b-a)$并求值$f_1 = f(x_1)$。\n    c. 否则 ($f_1 \\geq f_2$)：\n        i. 新区间为$[x_1, b]$。设置$a = x_1$。\n        ii. 旧的$x_2$成为新的$x_1$。设置$x_1 = x_2$和$f_1 = f_2$。\n        iii. 计算新的$x_2 = a + \\tau(b-a)$并求值$f_2 = f(x_2)$。\n3.  **终止**：当循环终止时，最小值点$x^\\star$位于最终区间$[a,b]$内。最小值点的最佳估计是该区间的中点，$x^\\star = (a+b)/2$。\n4.  **返回**：返回迭代次数$n$、最终近似值$x^\\star$和函数值$f(x^\\star)$。\n\n### 特殊测试用例分析（用例1）\n\n对于区间$[0,1]$上的函数$f_1(x) = (x - \\tau)^2$，真实最小值点位于$x^\\star = \\tau$。\n初始区间为$[a_0, b_0] = [0,1]$。初始内点为：\n$x_{1,0} = 1 - \\tau(1-0) = 1-\\tau$\n$x_{2,0} = 0 + \\tau(1-0) = \\tau$\n其中一个初始点$x_{2,0}$与真实最小值点完全重合。因此，$f(x_{2,0}) = (\\tau - \\tau)^2 = 0$。另一点的函数值为$f(x_{1,0}) = ((1-\\tau) - \\tau)^2 = (1-2\\tau)^2 > 0$。\n\n由于$f(x_{1,0}) > f(x_{2,0})$，算法将新区间设置为$[a_1, b_1] = [x_{1,0}, b_0] = [1-\\tau, 1]$。\n算法通过围绕函数值较低的点来缩减区间。在随后的每次迭代中，其中一个内点将恰好是$\\tau$，其函数值为$0$。算法将总是选择包含$\\tau$的子区间。\n\n然而，“收敛被检测到的速度有多快”这个问题可以通过检查终止准则$(b-a) \\leq \\varepsilon$来回答。算法的收敛速度仅由区间缩减因子$\\tau$决定。经过$n$次迭代后，区间的长度为$L_n = \\tau^n L_0$。满足容差所需的迭代次数可以通过求解$\\tau^n L_0 \\leq \\varepsilon$来找到，即$n \\geq \\log(\\varepsilon/L_0) / \\log(\\tau)$。对于$L_0=1$和$\\varepsilon=10^{-8}$，这要求$n \\geq \\log(10^{-8})/\\log(\\tau) \\approx 38.28$，意味着需要$n=39$次迭代。\n\n将初始点有利地放置在精确最小值点上并不会改变收敛所需的迭代次数。该算法没有机制来“检测”它是否已找到最小值；它仅根据区间宽度终止。这展示了黄金分割搜索的一个关键特性：它具有一个有保证但固定的线性收敛率，该收敛率与函数在单峰性之外的具体行为无关。相比之下，使用导数信息的算法（如牛顿法）在这种情况下可能会收敛得快得多。\n\n这种情况的例外是用例4，其中初始区间$[\\tau - 10^{-12}, \\tau + 10^{-12}]$的长度为$2 \\times 10^{-12}$，这已经小于容差$\\varepsilon = 10^{-9}$。在这种情况下，终止条件在第一次迭代之前就已满足，算法正确地返回$n=0$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for Golden-section search.\n    \"\"\"\n\n    def золотой_раздел(f, a, b, tol):\n        \"\"\"\n        Implements the Golden-section search algorithm.\n        \n        Args:\n            f: The unimodal function to minimize.\n            a: The lower bound of the interval.\n            b: The upper bound of the interval.\n            tol: The tolerance for the interval length.\n            \n        Returns:\n            A list containing [n, x_star, f_x_star]:\n            - n: Number of iterations.\n            - x_star: The approximation of the minimizer.\n            - f_x_star: The function value at the approximation.\n        \"\"\"\n        # The golden ratio conjugate\n        tau = (np.sqrt(5) - 1) / 2\n\n        # Initial interior points\n        x1 = b - tau * (b - a)\n        x2 = a + tau * (b - a)\n\n        # Initial function evaluations\n        f1 = f(x1)\n        f2 = f(x2)\n\n        n = 0\n        while (b - a) > tol:\n            n += 1\n            if f1 < f2:\n                # The minimum is in [a, x2]\n                b = x2\n                x2 = x1\n                f2 = f1\n                x1 = b - tau * (b - a)\n                f1 = f(x1)\n            else:\n                # The minimum is in [x1, b]\n                a = x1\n                x1 = x2\n                f1 = f2\n                x2 = a + tau * (b - a)\n                f2 = f(x2)\n        \n        # The final approximation is the midpoint of the last interval.\n        x_star = (a + b) / 2\n        f_x_star = f(x_star)\n        \n        return [n, x_star, f_x_star]\n\n    # Define constants and test functions\n    tau_val = (np.sqrt(5) - 1) / 2\n\n    def f1(x):\n        return (x - tau_val)**2\n\n    def f2(x):\n        return (x - 0.5)**2\n\n    def f3(x):\n        return x**2\n\n    def f4(x):\n        return (x - tau_val)**2\n\n    def f5(x):\n        return np.exp(x) + np.exp(-x)\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (f1, 0.0, 1.0, 1e-8),\n        (f2, 0.0, 1.0, 1e-8),\n        (f3, 0.0, 1.0, 1e-8),\n        (f4, tau_val - 1e-12, tau_val + 1e-12, 1e-9),\n        (f5, -1.0, 2.0, 1e-8),\n    ]\n\n    results = []\n    for case in test_cases:\n        func, a, b, tol = case\n        n, x_star, f_x_star = золотой_раздел(func, a, b, tol)\n        \n        # Format the result as a string with required precision\n        result_str = f\"[{n},{x_star:.10f},{f_x_star:.10f}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3166878"}, {"introduction": "一个算法思想的真正力量在于其适应性。黄金分割搜索的核心——即通过“夹逼”来锁定单峰函数的极值点——并不局限于连续函数。这项更具挑战性的实践 [@problem_id:3166898] 将引导你将该算法拓展到离散的整数域。在此过程中，你需要解决将连续比例点映射到整数时产生的取整策略和点冲突等新问题，从而深化对算法核心逻辑与具体实现细节之间区别的理解。", "problem": "我们要求您设计、分析并实现一种一维黄金分割搜索的离散变体，该变体适用于整数域上的单峰目标函数。考虑整数域 $[0,1000]$，并设 $f(x)$ 在此整数域上是单峰的，这意味着存在至少一个整数 $x^\\star$，使得 $f$ 在 $\\{0,1,\\dots,x^\\star\\}$ 上非增，并在 $\\{x^\\star,\\dots,1000\\}$ 上非减。您的任务是调整黄金分割搜索，使其每次迭代选择并评估两个由连续黄金分割点派生出的不同内部整数，并更新一个保证能收缩至最小化点的包围区间。核心要求是定义一个取整策略，将连续的内部点映射为整数，同时不破坏包围区间的恒定性或收敛性。\n\n从基本定义出发，您必须：\n- 使用在闭区间上对单峰函数进行区间搜索的原理，该原理维护一个已知包含最小化点的区间 $[a,b]$。\n- 使用基于恒定分割比（源于黄金分割原理）的内部点思想，以减少迭代过程中的函数求值次数。\n- 设计一个整数映射规则，该规则接收实值内部点，并生成两个严格位于当前区间 $[a,b]$ 内部的不同整数 $P$ 和 $Q$（即 $a < P < Q < b$），同时确保：\n  1) 每次迭代中，整数区间长度至少严格减少 $1$。\n  2) 每次更新后，整数上的单峰最小化点仍保留在区间内。\n  3) 如果在任意迭代中出现 $f(P) = f(Q)$，更新规则必须确保当存在多个整数最小化点时，算法最终返回最小的那个最小化点（即，达到最小值的最小整数 $x$）。\n\n实现要求：\n- 实现不得对 $[0,1000]$ 之外的任何 $x$ 求值 $f(x)$。\n- 当整数区间长度至多为 $2$ 时终止，然后通过直接检查区间内所有剩余的整数点来选择最小化点。\n- 程序必须能处理平台区（平坦底部）、严格单峰和边界最小值，并且对内部点的整数取整必须具有鲁棒性。\n\n测试集：\n实现您的算法，并将其应用于定义域 $\\{0,1,\\dots,1000\\}$ 上的以下五个单峰测试函数：\n\n- 情况 1：$f_1(x) = (x - 321.7)^2$。\n- 情况 2：$f_2(x) = |x - 250| + 0.001\\,x$。\n- 情况 3：$f_3(x) = \\max\\{|x - 700| - 2,\\,0\\}$。\n- 情况 4：$f_4(x) = x^2$。\n- 情况 5：$f_5(x) = \\begin{cases} 2\\,(873 - x), & x \\le 873 \\\\ 3\\,(x - 873), & x \\ge 873 \\end{cases}$。\n\n对于每种情况，计算使 $f(x)$ 最小化的整数 $x^\\star \\in \\{0,1,\\dots,1000\\}$，并遵循以下约定：如果多个整数达到相同的最小值，您必须返回其中最小的那个整数。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，形如“[r1,r2,r3,r4,r5]”）。每个条目必须是对应情况的整数最小化点，顺序与上面列出的情况一致。不应打印任何额外文本。", "solution": "该问题要求设计并实现一种离散一维优化算法，具体是针对整数域上单峰函数的黄金分割搜索的改编版。解决方案必须是鲁棒、收敛的，并能处理特定的平局打破规则。\n\n其基本原理是区间搜索。对于一个在闭整数区间 $[a, b]$ 上的单峰函数 $f(x)$，我们已知一个最小化点 $x^\\star$ 位于此区间内。目标是通过迭代缩小区间 $[a, b]$，同时确保 $x^\\star$ 始终在区间内。这通过在两个不同的内部点 $P$ 和 $Q$（满足 $a < P < Q < b$）处对函数进行求值来实现。\n\n区间的更新规则源于单峰性的定义。\n设函数 $f$ 在达到最小化点 $x^\\star$ 之前非增，之后非减。\n1. 如果 $f(P) < f(Q)$，最小化点 $x^\\star$ 不可能在区间 $(Q, b]$ 内。在 $Q$ 点的函数值高于在 $P$ 点的值，并且由于函数在 $x^\\star$ 右侧是非减的，任何最小化点都必须在 $Q$ 的左侧。因此，新区间变为 $[a, Q]$。\n2. 如果 $f(P) > f(Q)$，最小化点 $x^\\star$ 不可能在区间 $[a, P)$ 内。在 $P$ 点的函数值高于在 $Q$ 点的值。由于函数在 $x^\\star$ 左侧是非增的，任何最小化点都必须在 $P$ 的右侧。因此，新区间变为 $[P, b]$。\n3. 如果 $f(P) = f(Q)$，最小化点可能位于 $P$ 和 $Q$ 之间的平台区。问题要求找到最小的整数最小化点。为确保不丢弃最左侧的最小化点，我们必须保留对定义域左侧部分的考虑。因此，此情况按第一种情况处理：新区间变为 $[a, Q]$。\n\n综合起来，更新逻辑是：如果 $f(P) \\le f(Q)$，新区间为 $[a, Q]$；否则，新区间为 $[P, b]$。\n\n任务的核心是选择整数点 $P$ 和 $Q$。用于连续域的黄金分割搜索使用黄金比例共轭 $\\psi = (\\sqrt{5}-1)/2 \\approx 0.618$ 来放置这些点。这些点位于 $a + (1-\\psi)(b-a)$ 和 $a + \\psi(b-a)$。对于长度为 $L = b-a$ 的整数区间 $[a, b]$，其连续模拟点是 $p_{cont} = b - \\psi L$ 和 $q_{cont} = a + \\psi L$。\n\n对这些连续点进行简单的取整可能会失败。它们之间的距离是 $q_{cont} - p_{cont} = L(2\\psi - 1) = L(\\sqrt{5}-2) \\approx 0.236 L$。如果这个距离小于 $1$，取整可能会将两者映射到同一个整数，从而违反 $P < Q$ 的要求。这在 $L$ 很小时会发生，例如，如果 $L=4$，则 $p_{cont} \\approx a+1.528$ 且 $q_{cont} \\approx a+2.472$，这两个值都可能被取整为 $a+2$。\n\n为创建一个鲁棒的整数点选择策略，我们为任何长度 $b-a > 2$ 的区间 $[a,b]$ 定义以下过程：\n1. 计算理想的内部点 $Q = \\text{round}(a + \\psi (b-a))$ 和 $P = \\text{round}(b - \\psi (b-a))$。我们使用标准取整（四舍五入到最近的偶数）。\n2. 检查碰撞。如果 $P \\ge Q$，我们通过设置 $P = Q - 1$ 来强制使它们不同。对于某些较小的区间长度，这种修正是必要的。\n3. 此规则保证 $a < P < Q < b$。对于长度 $L = b-a \\ge 3$ 的区间，点 $q_{cont} = a + \\psi L$ 大于 $a + 3\\psi \\approx a + 1.854$。取整后，$Q \\ge a+2$。因此，修正后的点 $P = Q - 1$ 将至少为 $a+1$，满足 $P > a$。对称地，$Q < b$ 也得到保证。每次迭代中，区间长度 $b-a$ 保证至少缩小 $1$，从而确保收敛。\n\n搜索算法的步骤如下：\n1. 将区间 $[a, b]$ 初始化为整个定义域，即 $[0, 1000]$。\n2. 当区间内的整数数量 $b-a+1$ 大于 $3$ 时（或等价地，当 $b-a > 2$ 时）循环。\n   a. 使用上述鲁棒规则计算整数内部点 $P$ 和 $Q$。\n   b. 求值 $f(P)$ 和 $f(Q)$。\n   c. 如果 $f(P) \\le f(Q)$，更新 $b = Q$。\n   d. 如果 $f(P) > f(Q)$，更新 $a = P$。\n3. 一旦循环终止（$b-a \\le 2$），最小化点就包含在最终的小区间 $[a, b]$ 中。此时对整数集合 $\\{a, a+1, \\dots, b\\}$ 进行一次最终的穷举搜索，以找到最小化 $f(x)$ 的 $x$。如果多个整数产生相同的最小值，则选择其中最小的那个整数，以满足问题的平局打破要求。\n\n这个完整的算法正确地将黄金分割搜索应用于整数域，确保收敛到最小的整数最小化点，同时满足所有指定的约束条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing a discrete golden-section search for\n    the five specified test cases and printing the results.\n    \"\"\"\n\n    def golden_section_integer_search(f, a, b):\n        \"\"\"\n        Performs a golden-section search for a unimodal function on an\n        integer domain.\n\n        Args:\n            f: The unimodal objective function.\n            a: The lower bound of the integer interval.\n            b: The upper bound of the integer interval.\n\n        Returns:\n            The integer x that minimizes f(x) in [a, b]. If multiple\n            minimizers exist, the smallest is returned.\n        \"\"\"\n        psi = (np.sqrt(5) - 1) / 2  # Golden-ratio conjugate\n\n        # Main loop to shrink the bracketing interval\n        while (b - a) > 2:\n            L = b - a\n            \n            # Calculate integer interior points based on the golden ratio\n            # np.round rounds to the nearest even number for .5 cases\n            q_val = a + psi * L\n            p_val = b - psi * L\n            Q = int(np.round(q_val))\n            P = int(np.round(p_val))\n\n            # Robustness check: ensure interior points are distinct.\n            # This can happen for small integer interval lengths where rounding\n            # causes the two points to collide.\n            if P >= Q:\n                P = Q - 1\n            \n            # Evaluate the function at the interior points\n            fP = f(P)\n            fQ = f(Q)\n\n            # Update the bracket based on the function values.\n            # The rule f(P) <= f(Q) ensures that for plateaus (flat minima),\n            # the algorithm favors the left side, eventually finding the\n            # smallest integer minimizer.\n            if fP <= fQ:\n                b = Q\n            else:\n                a = P\n\n        # Termination: when b-a <= 2, the bracket is small enough.\n        # Perform a final exhaustive search on the remaining candidates.\n        min_val = f(a)\n        min_x = a\n        for x in range(a + 1, b + 1):\n            val = f(x)\n            # In case of a tie in value, the smaller x is kept.\n            if val < min_val:\n                min_val = val\n                min_x = x\n        \n        return min_x\n\n    # Define the five test functions as per the problem statement.\n    f1 = lambda x: (x - 321.7)**2\n    f2 = lambda x: np.abs(x - 250) + 0.001 * x\n    f3 = lambda x: np.maximum(np.abs(x - 700) - 2, 0)\n    f4 = lambda x: x**2\n    \n    def f5(x):\n        if x <= 873:\n            return 2 * (873 - x)\n        else:\n            return 3 * (x - 873)\n\n    test_cases = [f1, f2, f3, f4, f5]\n    initial_a, initial_b = 0, 1000\n\n    results = []\n    for f in test_cases:\n        result = golden_section_integer_search(f, initial_a, initial_b)\n        results.append(result)\n\n    # Print the final result in the specified format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3166898"}]}