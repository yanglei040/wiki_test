{"hands_on_practices": [{"introduction": "在数值计算中，最常见的陷阱之一是“灾难性抵消”（catastrophic cancellation），即两个相近的大数相减会导致有效数字的严重损失。这个练习 [@problem_id:2205457] 将通过一个看似简单的函数表达式，向你展示这个问题是如何发生的。更重要的是，你将学习一种强大的技巧——代数重构——来规避这个陷阱，从而显著提高计算的精度和稳定性。", "problem": "考虑函数 $f(x) = \\sqrt{x+1} - \\sqrt{x}$。对于非常大的正数 $x$ 值，使用标准浮点数运算直接计算 $f(x)$ 可能会由于两个几乎相等的数相减而导致严重的精度损失。您的任务是首先找到一个与 $f(x)$ 代数上等价的表达式，该表达式对于大的 $x$ 值在数值上更稳定，因为它避免了这种减法运算。然后，使用这个改进的表达式来计算当 $x = 4 \\times 10^{16}$ 时 $f(x)$ 的值。\n\n将您的答案表示为科学记数法形式的实数 $a \\times 10^b$，并四舍五入到三位有效数字。", "solution": "对于大的正数 $x$，我们希望避免在计算 $f(x) = \\sqrt{x+1} - \\sqrt{x}$ 时发生灾难性抵消。将分子和分母同乘以共轭表达式，以得到一个代数等价的形式：\n$$\nf(x) = \\left(\\sqrt{x+1} - \\sqrt{x}\\right)\\frac{\\sqrt{x+1} + \\sqrt{x}}{\\sqrt{x+1} + \\sqrt{x}} = \\frac{(x+1) - x}{\\sqrt{x+1} + \\sqrt{x}} = \\frac{1}{\\sqrt{x+1} + \\sqrt{x}}.\n$$\n这个表达式避免了两个几乎相等的大数相减，因此在数值上更加稳定。\n\n对于 $x = 4 \\times 10^{16}$，使用这个稳定的形式进行计算：\n$$\nf(4 \\times 10^{16}) = \\frac{1}{\\sqrt{4 \\times 10^{16} + 1} + \\sqrt{4 \\times 10^{16}}}.\n$$\n注意到 $\\sqrt{4 \\times 10^{16}} = 2 \\times 10^{8}$。此外，\n$$\n\\sqrt{4 \\times 10^{16} + 1} = 2 \\times 10^{8}\\sqrt{1 + \\frac{1}{4 \\times 10^{16}}}.\n$$\n令 $\\epsilon = \\frac{1}{4 \\times 10^{16}}$。使用二项式展开 $\\sqrt{1+\\epsilon} = 1 + \\frac{\\epsilon}{2} - \\frac{\\epsilon^{2}}{8} + \\cdots$，我们得到\n$$\n\\sqrt{4 \\times 10^{16} + 1} = 2 \\times 10^{8}\\left(1 + \\frac{\\epsilon}{2} - \\frac{\\epsilon^{2}}{8} + \\cdots \\right) = 2 \\times 10^{8} + 10^{8}\\epsilon + O(\\epsilon^{2}).\n$$\n因此分母是\n$$\n\\sqrt{4 \\times 10^{16} + 1} + \\sqrt{4 \\times 10^{16}} = 4 \\times 10^{8} + 10^{8}\\epsilon + O(\\epsilon^{2}).\n$$\n所以，\n$$\nf(4 \\times 10^{16}) = \\frac{1}{4 \\times 10^{8} + 10^{8}\\epsilon + O(\\epsilon^{2})} = \\frac{1}{4 \\times 10^{8}}\\left(1 - \\frac{10^{8}\\epsilon}{4 \\times 10^{8}} + O(\\epsilon^{2})\\right).\n$$\n由于 $\\epsilon = 2.5 \\times 10^{-17}$，首项是\n$$\n\\frac{1}{4 \\times 10^{8}} = 2.5 \\times 10^{-9},\n$$\n而修正项的量级是 $10^{-26}$，它不影响四舍五入到三位有效数字的结果。因此，精确到三位有效数字，\n$$\nf(4 \\times 10^{16}) \\approx 2.50 \\times 10^{-9}.\n$$", "answer": "$$\\boxed{2.50 \\times 10^{-9}}$$", "id": "2205457"}, {"introduction": "数值稳定性不仅影响静态公式的计算，在模拟随时间演变的动态系统时更是至关重要，例如求解微分方程。本练习 [@problem_id:2205446] 使用显式欧拉法来模拟一个简单的化学反应。你将亲眼看到，一个看似无伤大雅的选择——时间步长——如果超出了稳定性的边界，会导致数值解如何偏离物理现实，甚至得出荒谬的结果，从而深刻理解数值方法的稳定性阈值概念。", "problem": "一位科学家正在对一个简单的一级反应中的化学反应物浓度 $C(t)$ 进行建模。反应物浓度的变化率与浓度本身成正比，遵循以下微分方程：\n$$\n\\frac{dC}{dt} = -k C(t)\n$$\n给定速率常数 $k = 50.0 \\text{ s}^{-1}$，时间 $t=0$ 时的初始浓度为 $C(0) = 100.0 \\text{ mol/L}$。\n\n为了预测未来时刻的浓度，该科学家采用了一种使用固定时间步长 $h$ 的数值方案。该方法根据显式欧拉更新法则，使用前一个时间步 $t_n = nh$ 时的值来近似计算时间 $t_{n+1} = (n+1)h$ 时的浓度：\n$$\nC_{n+1} = C_n + h \\left( \\frac{dC}{dt} \\right)_{t=t_n}\n$$\n科学家决定使用 $h = 0.0410 \\text{ s}$ 的时间步长。计算用此方法预测的、经过三个时间步长后的浓度 $C_3$ 的数值。答案以 mol/L 为单位表示，并四舍五入至三位有效数字。", "solution": "给定一阶线性常微分方程 $\\frac{dC}{dt}=-kC(t)$ 和显式欧拉更新法则\n$$\nC_{n+1}=C_{n}+h\\left(\\frac{dC}{dt}\\right)_{t=t_{n}}=C_{n}+h(-kC_{n})=(1-kh)C_{n}。\n$$\n通过递推，可得\n$$\nC_{n}=C_{0}(1-kh)^{n}。\n$$\n已知 $C_{0}=100.0$，$k=50.0\\,\\text{s}^{-1}$，且 $h=0.0410\\,\\text{s}$，无量纲乘积为\n$$\nkh=(50.0)(0.0410)=2.05,\\quad 1-kh=1-2.05=-1.05。\n$$\n因此，经过三步之后，\n$$\nC_{3}=100.0\\,(-1.05)^{3}。\n$$\n计算乘方：\n$$\n(-1.05)^{2}=1.1025,\\quad (-1.05)^{3}=1.1025\\times(-1.05)=-1.157625,\n$$\n所以\n$$\nC_{3}=100.0\\times(-1.157625)=-115.7625。\n$$\n四舍五入到三位有效数字得到 $-1.16\\times 10^{2}$，即 $-116$。注意，显式欧拉因子满足 $|1-kh|=1.05>1$，表明对于此步长，该方法是不稳定的，这也解释了非物理的符号变化。", "answer": "$$\\boxed{-116}$$", "id": "2205446"}, {"introduction": "我们将稳定性的原则应用于一个非常实际的数据分析任务：计算方差。教科书中常见的方差计算公式，即基于 $\\sum x_i^2 - (\\sum x_i)^2/n$ 的方法，对于均值很大但方差很小的数据集来说是出了名的不稳定。这个更具挑战性的练习 [@problem_id:3197369] 将经典的“两遍扫描”算法与数值稳定的“单遍扫描”Welford算法进行对比，揭示了算法设计本身对于从真实世界数据中获得可靠结果是多么关键。", "problem": "要求您编写一个完整、可运行的程序，研究计算实数值数据的样本均值和样本方差的两种方法的数值稳定性：一种是称为 Welford 算法的数值稳定的单遍方法，另一种是使用涉及平方和恒等式的经典双遍公式。该任务必须以纯粹的数学和算法方式执行，其逻辑适用于任何现代编程语言。目的是展示在有限精度算术中，当数据具有大偏移和小离散度时，表达式 $$\\sum_{i=1}^{n} x_i^2 - \\frac{\\left(\\sum_{i=1}^{n} x_i\\right)^2}{n}$$ 中的相消如何导致巨大的精度损失。被测试的算法必须使用标准的二进制浮点数，采用电气和电子工程师协会 (IEEE) $754$ 双精度格式进行计算，并使用一个独立的高精度基准来评估误差。本问题不涉及物理单位。\n\n任务的基本依据：\n- 一个实数数据集 $x_1, x_2, \\dots, x_n$ 的样本均值定义为 $$\\bar{x} = \\frac{1}{n}\\sum_{i=1}^{n} x_i.$$\n- 无偏样本方差定义为 $$s^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} \\left(x_i - \\bar{x}\\right)^2.$$\n- 有限精度浮点算术（特别是电气和电子工程师协会 (IEEE) $754$ 双精度格式）在每次运算中都会引入舍入，而两个相近大数相减可能遭受灾难性相消，从而放大相对误差。\n\n您的程序必须：\n- 实现一个函数，使用 Welford 算法（单遍，在每个数据点到达时更新均值和累积的平方偏差和）计算样本均值和无偏样本方差。\n- 实现第二个函数，使用经典的双遍方法计算样本均值和无偏样本方差，该方法首先以浮点数计算总和与平方和，然后应用代数恒等式 $$\\sum_{i=1}^{n} x_i^2 - \\frac{\\left(\\sum_{i=1}^{n} x_i\\right)^2}{n}$$。\n- 实现一个高精度基准，使用任意精度十进制算术，根据上述定义从数据集的精确十进制表示中计算样本均值和无偏样本方差。在十进制算术中使用至少 $50$ 位的精度，以确保对于给定的数据集，该基准实际上没有舍入误差。\n\n测试套件设计：\n为以下四个数据集计算所需量，每个数据集都旨在测试稳定性的不同方面。对于下面的每个数据集，$n$ 表示数据点的数量。\n1. 理想情况，中等规模：从 $1$ 到 $1000$ 的整数，即 $x_i = i$，其中 $i \\in \\{1, 2, \\dots, 1000\\}$，$n = 1000$。\n2. 大偏移，中等离散度：$x_i = 10^{9} + i$，其中 $i \\in \\{-500, -499, \\dots, 498, 499\\}$，$n = 1000$。\n3. 极大偏移，微小交替抖动：$x_i = 10^{12} + \\delta_i$，其中 $i \\in \\{0, 1, \\dots, 1999\\}$，$n = 2000$，当 $i$ 为偶数时 $\\delta_i = 10^{-3}$，当 $i$ 为奇数时 $\\delta_i = -10^{-3}$。\n4. 大偏移，极小线性漂移：$x_i = 10^{9} + 10^{-8} i$，其中 $i \\in \\{0, 1, \\dots, 99999\\}$，$n = 100000$。\n\n本问题不使用角度单位。不需要物理单位。任何输出中不得出现百分比；所有量都是标准实数算术中的数值。\n\n对于每个数据集，计算：\n- 使用双遍浮点方法计算的样本均值和无偏样本方差。\n- 使用 Welford 单遍浮点方法计算的样本均值和无偏样本方差。\n- 使用至少 50 位精度的十进制算术计算的高精度基准样本均值和无偏样本方差。\n\n然后为每个数据集生成以下指标：\n- $E_{\\text{mean, two}} = \\left| \\bar{x}_{\\text{two}} - \\bar{x}_{\\text{baseline}} \\right|$，\n- $E_{\\text{mean, wel}} = \\left| \\bar{x}_{\\text{wel}} - \\bar{x}_{\\text{baseline}} \\right|$，\n- $E_{\\text{var, two}} = \\left| s^2_{\\text{two}} - s^2_{\\text{baseline}} \\right|$，\n- $E_{\\text{var, wel}} = \\left| s^2_{\\text{wel}} - s^2_{\\text{baseline}} \\right|$，\n- 一个布尔标志 $C$，表示在双遍方差计算中“怀疑发生灾难性相消”，如果 $$E_{\\text{var, two}} \\ge 1000 \\times \\max\\left(E_{\\text{var, wel}}, 10^{-300}\\right),$$ 则定义为真，否则为假。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含按顺序连接的四个数据集的所有指标，形式为用方括号括起来的逗号分隔列表。对于每个数据集，按上面列出的确切顺序附加五个指标，最终得到一个长度为 20 个数值和 4 个布尔值的顶级列表。例如，输出必须类似于 $$[\\text{m2\\_err\\_ds1}, \\text{mw\\_err\\_ds1}, \\text{v2\\_err\\_ds1}, \\text{vw\\_err\\_ds1}, \\text{C\\_ds1}, \\dots, \\text{m2\\_err\\_ds4}, \\text{mw\\_err\\_ds4}, \\text{v2\\_err\\_ds4}, \\text{vw\\_err\\_ds4}, \\text{C\\_ds4}]$$ 其中每个占位符都由其计算值替换。不要包含任何其他文本。", "solution": "该问题要求研究计算数据集样本均值和方差的两种不同算法的数值稳定性。分析的核心在于有限精度浮点算术的特性，特别是 IEEE $754$ 双精度标准。我们将比较一种经典的双遍算法与一种更稳健的单遍方法（即 Welford 算法），并使用高精度计算作为衡量准确性的基准。\n\n基本量是数据集 $\\{x_1, x_2, \\dots, x_n\\}$ 的样本均值 $\\bar{x}$ 和无偏样本方差 $s^2$：\n$$\n\\bar{x} = \\frac{1}{n} \\sum_{i=1}^{n} x_i\n$$\n$$\ns^2 = \\frac{1}{n-1} \\sum_{i=1}^{n} (x_i - \\bar{x})^2\n$$\n\n该分析依赖于三种计算方法：\n\n1.  **高精度基准**：为了量化有限精度算法的误差，需要一个“基准真相”或基准。该基准使用任意精度十进制算术计算，精度至少为 50 位。这确保了基准计算中的舍入误差与被测试的双精度算法中的误差相比可以忽略不计。均值和方差直接根据上述定义计算，所有中间和最终值均使用高精度数据类型。\n\n2.  **双遍算法（数值不稳定）**：这种常用方法涉及对数据进行两次遍历。在第一次遍历中，累加两个和：$\\sum_{i=1}^{n} x_i$ 和 $\\sum_{i=1}^{n} x_i^2$。在第二次遍历中，使用这些和通过以下代数恒等式计算方差：\n    $$\n    \\sum_{i=1}^{n} (x_i - \\bar{x})^2 = \\sum_{i=1}^{n} x_i^2 - \\frac{\\left(\\sum_{i=1}^{n} x_i\\right)^2}{n}\n    $$\n    因此，样本方差计算如下：\n    $$\n    s^2_{\\text{two}} = \\frac{1}{n-1} \\left( \\sum_{i=1}^{n} x_i^2 - \\frac{\\left(\\sum_{i=1}^{n} x_i\\right)^2}{n} \\right)\n    $$\n    这个被称为“教科书公式”的公式的数值不稳定性源于两个相近大数的相减。当数据点具有大的共同偏移（即均值 $\\bar{x}$ 很大）和小的离散度（即标准差 $s$ 很小）时，$\\sum x_i^2 \\approx n\\bar{x}^2$ 项和 $(\\sum x_i)^2/n = n\\bar{x}^2$ 项的值会非常接近。在有限精度算术中，这两个量的相减会导致一种称为“灾难性相消”的现象，其中大部分有效数字会丢失，导致最终计算出的方差产生巨大的相对误差。\n\n3.  **Welford 算法（数值稳定）**：这是一种单遍算法，通过增量更新均值和一个与平方差之和相关的量来避免灾难性相消问题。设 $M_k$ 是前 $k$ 个数据点的动态均值，设 $S_k$ 是与均值的平方偏差的动态和，即 $S_k = \\sum_{i=1}^{k} (x_i - M_k)^2$。Welford 算法基于以下递推关系：\n    $$\n    M_k = M_{k-1} + \\frac{x_k - M_{k-1}}{k}\n    $$\n    $$\n    S_k = S_{k-1} + (x_k - M_{k-1})(x_k - M_k)\n    $$\n    初始条件为 $M_1 = x_1$ 和 $S_1 = 0$。处理完所有 $n$ 个数据点后，无偏样本方差为 $s^2_{\\text{wel}} = S_n / (n-1)$。该方法在数值上是稳定的，因为它使用与*动态*均值的偏差来计算方差。项 $(x_k - M_{k-1})$ 和 $(x_k - M_k)$ 很小，从而防止了大数的累积和随后的灾难性相减。\n\n程序将实现这三种方法，将它们应用于旨在暴露双遍方法不稳定性的四个指定数据集，并计算每种浮点方法的均值和方差相对于高精度基准的绝对误差。通过将双遍方差计算的误差与 Welford 算法的误差进行比较，计算出一个布尔标志 $C$ 来检测可疑的灾难性相消。\n\n数据集设计如下：\n-   数据集 1：一个简单案例，规模适中，没有大偏移，预计两种方法都会表现良好。\n-   数据集 2：具有大偏移（$10^9$）的数据，双遍方法可能会开始表现出一些性能下降。\n-   数据集 3：具有极大偏移（$10^{12}$）和极小离散度的数据，旨在引发双遍方法中的严重灾难性相消。\n-   数据集 4：具有大偏移（$10^9$）和非常小的系统性漂移的数据。除了方差公式的不稳定性之外，这个案例还测试了输入数据本身的有限精度表示如何影响算法。\n\n通过比较误差 $E_{\\text{mean, two}}$、$E_{\\text{mean, wel}}$、$E_{\\text{var, two}}$ 和 $E_{\\text{var, wel}}$，将证明 Welford 算法相对于朴素双遍公式的优越数值稳定性，特别是在计算变异系数（$\\sigma / \\mu$）接近于零的数据的方差时。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom decimal import Decimal, getcontext\n\ndef solve():\n    \"\"\"\n    Computes sample mean and variance using three different methods\n    (two-pass float, Welford's float, and high-precision baseline)\n    for four datasets, and reports the errors and a cancellation flag.\n    \"\"\"\n\n    def two_pass_algorithm(data: np.ndarray):\n        \"\"\"Computes mean and variance using the naive two-pass formula.\"\"\"\n        n = data.shape[0]\n        if n < 2:\n            return np.nan, np.nan\n        \n        sum_x = np.sum(data)\n        sum_x_sq = np.sum(data**2)\n        \n        mean = sum_x / n\n        # This subtraction is prone to catastrophic cancellation\n        variance = (sum_x_sq - (sum_x**2) / n) / (n - 1)\n        \n        return mean, variance\n\n    def welford_algorithm(data: np.ndarray):\n        \"\"\"Computes mean and variance using Welford's stable one-pass algorithm.\"\"\"\n        n = 0\n        mean = 0.0\n        M2 = 0.0 # This is the running sum of squared deviations from the mean\n\n        for x in data:\n            n += 1\n            delta = x - mean\n            mean += delta / n\n            delta2 = x - mean\n            M2 += delta * delta2\n        \n        if n < 2:\n            return mean, 0.0\n        \n        variance = M2 / (n - 1)\n        return mean, variance\n\n    def high_precision_baseline(data_str: list[str]):\n        \"\"\"\n        Computes mean and variance using high-precision decimal arithmetic\n        to establish a ground truth.\n        \"\"\"\n        getcontext().prec = 60 # Set precision to 60 digits\n        \n        data_decimal = [Decimal(s) for s in data_str]\n        n = len(data_decimal)\n        \n        if n < 2:\n            return Decimal(0), Decimal(0)\n            \n        mean = sum(data_decimal) / Decimal(n)\n        \n        # Compute sum of squared deviations directly from the definition\n        sum_sq_dev = sum((x - mean)**2 for x in data_decimal)\n        variance = sum_sq_dev / Decimal(n - 1)\n        \n        return mean, variance\n\n    test_cases_defs = [\n        {\n            \"name\": \"ds1\", \"n\": 1000, \n            \"gen_float\": lambda n: np.arange(1, n + 1, dtype=np.float64),\n            \"gen_str\": lambda n: [str(i) for i in range(1, n + 1)],\n        },\n        {\n            \"name\": \"ds2\", \"n\": 1000,\n            \"gen_float\": lambda n: 1e9 + np.arange(-n//2, n//2, dtype=np.float64),\n            \"gen_str\": lambda n: [str(10**9 + i) for i in range(-n//2, n//2)],\n        },\n        {\n            \"name\": \"ds3\", \"n\": 2000,\n            \"gen_float\": lambda n: 1e12 + np.array([1e-3 if i % 2 == 0 else -1e-3 for i in range(n)], dtype=np.float64),\n            \"gen_str\": lambda n: ['1000000000000.001' if i % 2 == 0 else '999999999999.999' for i in range(n)],\n        },\n        {\n            \"name\": \"ds4\", \"n\": 100000,\n            \"gen_float\": lambda n: 1e9 + 1e-8 * np.arange(n, dtype=np.float64),\n            \"gen_str\": lambda n: [str(Decimal('1e9') + Decimal('1e-8') * Decimal(i)) for i in range(n)],\n        },\n    ]\n\n    results = []\n    \n    for case in test_cases_defs:\n        n = case[\"n\"]\n        \n        # Generate data for floating-point and high-precision calculations\n        float_data = case[\"gen_float\"](n)\n        str_data = case[\"gen_str\"](n)\n        \n        # Run all three algorithms\n        mean_two, var_two = two_pass_algorithm(float_data)\n        mean_wel, var_wel = welford_algorithm(float_data)\n        mean_base_dec, var_base_dec = high_precision_baseline(str_data)\n\n        # Convert baseline results to float for comparison\n        mean_base = float(mean_base_dec)\n        var_base = float(var_base_dec)\n        \n        # Calculate error metrics\n        E_mean_two = abs(mean_two - mean_base)\n        E_mean_wel = abs(mean_wel - mean_base)\n        E_var_two = abs(var_two - var_base)\n        E_var_wel = abs(var_wel - var_base)\n        \n        # Determine the catastrophic cancellation flag\n        # The max with 1e-300 prevents division by zero or issues with tiny numbers\n        cancellation_threshold = 1000 * max(E_var_wel, 1e-300)\n        C_flag = E_var_two >= cancellation_threshold\n\n        results.extend([E_mean_two, E_mean_wel, E_var_two, E_var_wel, C_flag])\n\n    # Final print statement in the exact required format.\n    # The default str() for a boolean is 'True' or 'False'.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3197369"}]}