{"hands_on_practices": [{"introduction": "这个练习揭示了一个在计算科学中至关重要的现象：灾难性抵消（catastrophic cancellation）。即使是像二次方程求根公式这样基础的数学公式，在浮点数运算下也可能因为两个相近的数值相减而导致精度的灾难性损失。通过这个练习，你将亲手计算并对比标准公式和一个经过数值优化的稳定算法的结果，从而深刻理解数值稳定性的重要性以及如何通过简单的代数变换来规避这类问题[@problem_id:2393691]。", "problem": "考虑一个实系数二次多项式 $p(x) = x^2 - 10^8 x + 1$。本题中的所有算术运算都在一个标准化的十进制浮点系统中进行，该系统具有 $t=8$ 位有效数字的精度，采用“舍入到最近值，平局时舍入到偶数”的规则，并且指数范围足够大，以至于遇到的数值不会发生上溢或下溢。每个基本运算（加、减、乘、除和平方根）都先被精确执行，然后根据所述规则舍入到最接近的可表示浮点数，之后再用于任何后续计算。\n\n(a) 在此浮点系统下，使用标准的二次求根公式，计算将作为 $p(x)=0$ 的根返回的两个浮点数。\n\n(b) 然后，仅使用对首一二次多项式精确成立的恒等式（特别是，两根之积等于 $c/a$ 这一事实），通过先在此浮点系统中使用标准二次求根公式计算绝对值较大的根，然后使用精确的乘积关系在此浮点系统中获得绝对值较小的根，来计算该绝对值较小根的数值稳定值。\n\n仅报告 (b) 部分中得到的稳定的绝对值较小的根作为你的最终答案，并四舍五入到八位有效数字。以 $a \\times 10^b$（其中 $1 \\leq |a|  10$）的科学记数法形式表示你的最终答案。", "solution": "该问题要求在一个指定的浮点算术系统内计算一个二次多项式的根。在进行求解之前，我们必须验证问题的陈述。\n\n给定条件如下：\n1.  二次多项式为 $p(x) = x^2 - 10^8 x + 1$。由此，我们确定系数为 $a=1$, $b=-10^8$, $c=1$。\n2.  算术框架是一个标准化的十进制浮点系统。\n3.  精度为 $t=8$ 位有效数字。\n4.  舍入规则是“舍入到最近值，平局时舍入到偶数”。\n5.  不会发生上溢或下溢。\n6.  每个基本算术运算（$+$, $-$, $*$, $/$, $\\sqrt{\\cdot}$）都单独进行舍入。\n\n该问题具有科学依据，是数值分析中关于有效数字损失的一个标准练习。它的提法是适定的（well-posed），所有必要的参数都已定义。它是客观的，其结构是合理的。因此，该问题被认为是有效的。我们开始求解。\n\n二次方程 $ax^2 + bx + c = 0$ 的根由标准二次求根公式给出：\n$$x_{1,2} = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a}$$\n所有计算都在指定的浮点系统中执行，我们用 $fl(\\cdot)$ 表示。\n\n首先，我们计算判别式 $D = b^2 - 4ac$。\n系数为 $a = 1.0000000 \\times 10^0$, $b = -1.0000000 \\times 10^8$, $c = 1.0000000 \\times 10^0$。\n$b^2$ 项是 $(-10^8)^2 = 10^{16}$。这可以精确地表示为 $1.0000000 \\times 10^{16}$。\n$4ac$ 项是 $4 \\times 1 \\times 1 = 4$。这可以精确地表示为 $4.0000000 \\times 10^0$。\n\n我们现在必须计算减法 $fl(b^2 - 4ac) = fl(10^{16} - 4)$。为了执行此操作，必须对齐较小数的指数以匹配较大数的指数。\n$$10^{16} - 4 = (1.0000000 \\times 10^{16}) - (0.0000000000000004 \\times 10^{16})$$\n$10^{16}$ 的尾数是 $1.0000000$。该系统存储 $t=8$ 位有效数字。减去 $4$ 会影响到远超系统精度的数字位。尾数的减法是 $1.0000000 - 0.0000000000000004$，当舍入回 $8$ 位有效数字时，结果仍然是 $1.0000000$。这是一个典型的吸收（absorption）或“大数吃小数”的例子。\n因此，计算出的判别式为：\n$$\\hat{D} = fl(b^2 - 4ac) = 1.0000000 \\times 10^{16}$$\n接下来，我们计算 $\\hat{D}$ 的平方根。\n$$fl(\\sqrt{\\hat{D}}) = fl(\\sqrt{1.0000000 \\times 10^{16}}) = 1.0000000 \\times 10^8$$\n这是一个精确计算。我们记此结果为 $\\hat{S} = 1.0000000 \\times 10^8$。\n\n现在，我们按照 (a) 部分的要求计算两个根。\n较大的根 $\\hat{x}_1$ 是使用分子中的“+”号计算的，因为 $-b = 10^8$ 是正数。\n$$\\hat{x}_1 = fl\\left(\\frac{-b + \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 + 10^8}{2}\\right) = fl\\left(\\frac{2 \\times 10^8}{2}\\right) = 1.0000000 \\times 10^8$$\n这个计算是数值稳定的，因为它涉及两个数量级相似的正数相加。\n\n较小的根 $\\hat{x}_2$ 是使用“-”号计算的。\n$$\\hat{x}_2 = fl\\left(\\frac{-b - \\hat{S}}{2a}\\right) = fl\\left(\\frac{10^8 - 10^8}{2}\\right) = fl\\left(\\frac{0}{2}\\right) = 0$$\n这个计算遭受了灾难性抵消。两个几乎相等的数 $-b$ 和 $\\hat{S}$ 相减，导致有效数字的完全丧失。计算出的根 $\\hat{x}_2=0$ 非常不准确。真实的较小根约等于 $10^{-8}$。\n\n对于 (b) 部分，我们被指示使用一种数值稳定的方法。对于首一二次方程 $x^2 + \\frac{b}{a}x + \\frac{c}{a} = 0$，韦达定理（Vieta's formulas）指出，两根之积为 $x_1 x_2 = \\frac{c}{a}$。\n在我们的例子中，$a=1$ 且 $c=1$，所以 $x_1 x_2 = 1$。\n\n稳定的步骤是首先计算绝对值较大的根 $\\hat{x}_1$，我们已经发现这个值是准确的：\n$$\\hat{x}_1 = 1.0000000 \\times 10^8$$\n然后，我们使用乘积关系来找到绝对值较小的根 $\\hat{x}'_2$：\n$$\\hat{x}'_2 = fl\\left(\\frac{c/a}{\\hat{x}_1}\\right)$$\n代入数值：\n$$\\hat{x}'_2 = fl\\left(\\frac{1}{1.0000000 \\times 10^8}\\right) = fl(1.0000000 \\times 10^{-8})$$\n数值 $1.0000000 \\times 10^{-8}$ 在指定的浮点系统中是精确可表示的。因此，该计算产生此值而没有任何舍入误差。\n稳定的绝对值较小的根是：\n$$\\hat{x}'_2 = 1.0000000 \\times 10^{-8}$$\n此值即为最终答案，需以包含八位有效数字的科学记数法表示。", "answer": "$$\\boxed{1.0000000 \\times 10^{-8}}$$", "id": "2393691"}, {"introduction": "在上一个练习的基础上，我们将在一个实际的编程场景中进一步探讨灾难性抵消问题。本练习以双曲正弦函数 $\\sinh(x)$ 为例，当自变量 $x$ 趋近于零时，其标准定义式会遭遇数值不稳定性。你将通过编写代码，实现并对比直接计算方法与使用泰勒级数近似这两种算法的精度，这让你能体验到数值库函数设计中为保证精度而采用的关键技术[@problem_id:2395275]。", "problem": "您需要研究在有限精度浮点运算下，计算小参数的双曲正弦函数的数值行为。令 $s(x)$ 表示数学函数 $\\sinh(x)$。为 $s(x)$ 定义两种数值近似方法：直接指数差和截断的麦克劳林多项式。对于每个输入 $x$，计算这两种近似值，并根据下面指定的参考值 $s(x)$ 来量化它们的精度。所有计算都应以双精度进行，所有输出均为无量纲值。\n\n需要使用的定义：\n- 直接指数差：$s_{\\mathrm{dir}}(x) = \\dfrac{e^{x} - e^{-x}}{2}$。\n- 7 次截断麦克劳林多项式：$s_{\\mathrm{ts}}(x) = x + \\dfrac{x^{3}}{3!} + \\dfrac{x^{5}}{5!} + \\dfrac{x^{7}}{7!}$。\n- 参考值：$s_{\\ast}(x)$ 是使用一个标准的、可靠的双曲正弦函数数值库，以双精度计算出的 $\\sinh(x)$ 的值。\n\n需要为每个 $x$ 报告的误差度量：\n- 相对误差函数 $\\mathrm{relerr}(a,b)$ 定义为：若 $b \\neq 0$，则 $\\mathrm{relerr}(a,b) = \\dfrac{|a-b|}{|b|}$；若 $b = 0$，则 $\\mathrm{relerr}(a,b) = |a-b|$。\n- 计算 $e_{\\mathrm{dir}}(x) = \\mathrm{relerr}\\!\\left(s_{\\mathrm{dir}}(x), s_{\\ast}(x)\\right)$ 和 $e_{\\mathrm{ts}}(x) = \\mathrm{relerr}\\!\\left(s_{\\mathrm{ts}}(x), s_{\\ast}(x)\\right)$。\n\n测试集（输入 $x$）：\n使用有序集合 $X = \\{\\,0,\\;10^{-16},\\;-10^{-16},\\;10^{-12},\\;10^{-8},\\;-10^{-8},\\;10^{-4},\\;10^{-1}\\,\\}$。\n\n要求的最终输出格式：\n- 您的程序必须生成单行输出，该输出是一个由方括号括起来的逗号分隔列表。\n- 此列表中的每个元素对应于一个输入 $x \\in X$（按给定顺序），并且本身必须是一个双元素列表 $[\\,e_{\\mathrm{dir}}(x),\\,e_{\\mathrm{ts}}(x)\\,]$。\n- 每个浮点数必须以科学记数法打印，包含 $12$ 位有效数字，并且行内任何地方都不能有空格。\n- 因此，对于 $|X| = 8$ 个输入，输出行必须包含 $8$ 个双元素列表，这些列表由一对外部方括号括起来，并按指定顺序排列。", "solution": "所述问题是有效的。它在科学上基于数值分析的原理，特别是关于浮点运算和函数近似的原理。所有定义在数学上都是精确的，目标明确，且问题是适定的，允许一个唯一且可验证的解。因此，我们可以继续进行分析和求解。\n\n目标是分析两种用于计算参数 $x$ 接近零时的双曲正弦函数 $\\sinh(x)$ 的不同方法的数值精度。双曲正弦在数学上定义为 $s(x) = \\sinh(x) = \\dfrac{e^x - e^{-x}}{2}$。我们需要将该表达式的直接求值（表示为 $s_{\\mathrm{dir}}(x)$）与截断的麦克劳林级数近似（$s_{\\mathrm{ts}}(x)$）进行比较，并以一个标准数值库提供的高精度参考值 $s_{\\ast}(x)$ 为基准。\n\n第一种近似方法 $s_{\\mathrm{dir}}(x) = \\dfrac{e^{x} - e^{-x}}{2}$ 是数学定义的直接实现。对于 $|x|$ 不接近零的值，这个公式是数值稳定和准确的。然而，当 $x \\to 0$ 时，我们有 $e^x \\to 1$ 和 $e^{-x} \\to 1$。在有限精度运算中，两个几乎相等的数 $e^x$ 和 $e^{-x}$ 相减会导致一种称为灾难性抵消的现象。当两个数非常接近时，它们的最高有效位相等。相减会抵消这些数位，留下的结果由较低有效位（通常是含噪声的）尾数位组成。这会导致相对精度的急剧损失。计算出的差的相对误差可以证明近似正比于 $\\dfrac{\\epsilon_{mach}}{|x|}$，其中 $\\epsilon_{mach}$ 是浮点系统的机器精度（对于双精度，$\\epsilon_{mach} \\approx 2.22 \\times 10^{-16}$）。随着 $|x|$ 变小，这个相对误差会增大，导致当 $|x|$ 在 $\\sqrt{\\epsilon_{mach}}$ 或更小的数量级时，结果完全不准确。\n\n第二种近似方法是 7 次截断麦克劳林级数，定义为 $s_{\\mathrm{ts}}(x) = x + \\dfrac{x^{3}}{3!} + \\dfrac{x^{5}}{5!} + \\dfrac{x^{7}}{7!}$。这源于 $\\sinh(x)$ 的完整麦克劳林级数，即 $\\sum_{n=0}^{\\infty} \\dfrac{x^{2n+1}}{(2n+1)!}$。对于小的 $|x|$，这个级数收敛得非常快。这种近似方法的主要误差来源是截断误差，它源于忽略了 9 次及更高次的项。被忽略的首项是 $\\dfrac{x^9}{9!}$。例如，如果 $|x|=10^{-4}$，首项误差的量级为 $(10^{-4})^9 / 9! \\approx 10^{-36} / 3.6 \\times 10^5 \\approx 2.7 \\times 10^{-42}$，这远低于机器精度。此外，$s_{\\mathrm{ts}}(x)$ 的计算涉及的项求和不会遭受灾难性抵消（对于 $x>0$，所有项都是正的；对于 $x0$，所有项都是负的）。因此，对于小的 $|x|$，我们预计 $s_{\\mathrm{ts}}(x)$ 会是一个高度准确的近似，其误差主要由非常小的截断误差和极小的浮点舍入误差决定。\n\n参考值 $s_{\\ast}(x)$ 是使用一个鲁棒的库函数计算的。这类函数被设计用于在函数的整个定义域内保持高精度。它们通常采用混合算法，在可能发生灾难性抵消的区域使用一种稳定的公式，例如基于 `expm1(x)` 函数的公式（该函数能为小 $x$ 精确计算 $e^x - 1$），而在 $|x|$ 较大且直接指数定义稳定的区域则切换回直接指数定义。\n\n分析预测了一个明确的权衡。对于非常小的 $|x|$（例如，$10^{-16}, 10^{-12}, 10^{-8}$），直接方法 $s_{\\mathrm{dir}}(x)$ 会因灾难性抵消而表现出较大的相对误差，而截断级数 $s_{\\mathrm{ts}}(x)$ 则会极其准确。随着 $|x|$ 增大（例如，增大到 $10^{-4}$ 和 $10^{-1}$），$s_{\\mathrm{dir}}(x)$ 中的灾难性抵消会减弱，其精度会提高。相反，$s_{\\mathrm{ts}}(x)$ 的截断误差虽然仍然很小，但会随着 $|x|^9$ 增长。在某个点上，直接方法的误差将变得小于 7 次多项式的截断误差。所提供的测试集 $X = \\{\\,0,\\;10^{-16},\\;-10^{-16},\\;10^{-12},\\;10^{-8},\\;-10^{-8},\\;10^{-4},\\;10^{-1}\\,\\}$ 被精心选择以展示这种行为。对于 $x=0$，两种方法都是精确的，得出 $\\sinh(0)=0$，因此误差为零。由于所有相关函数（$\\sinh(-x)=-\\sinh(x)$）都具有奇对称性，因此对于 $x$ 和 $-x$，误差度量 $e_{\\mathrm{dir}}(x)$ 和 $e_{\\mathrm{ts}}(x)$ 将是相同的。\n\n计算过程是通过以双精度算术实现函数 $s_{\\mathrm{dir}}(x)$ 和 $s_{\\mathrm{ts}}(x)$ 来进行的。对于测试集中的每个 $x$，我们计算这些值，从一个标准库中获取参考值 $s_{\\ast}(x)$，然后使用所提供的误差定义 $\\mathrm{relerr}(a,b)$ 计算相对误差 $e_{\\mathrm{dir}}(x) = \\mathrm{relerr}\\!\\left(s_{\\mathrm{dir}}(x), s_{\\ast}(x)\\right)$ 和 $e_{\\mathrm{ts}}(x) = \\mathrm{relerr}\\!\\left(s_{\\mathrm{ts}}(x), s_{\\ast}(x)\\right)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes and compares the numerical accuracy of two approximations\n    for the hyperbolic sine function for small arguments.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        0.0,\n        1e-16,\n        -1e-16,\n        1e-12,\n        1e-8,\n        -1e-8,\n        1e-4,\n        1e-1,\n    ]\n\n    results = []\n    \n    # Precompute factorials for the Taylor series.\n    # 3! = 6, 5! = 120, 7! = 5040\n    F3 = 6.0\n    F5 = 120.0\n    F7 = 5040.0\n\n    for x_val in test_cases:\n        x = np.double(x_val)\n\n        # 1. Reference value from a reliable library function\n        s_star = np.sinh(x)\n\n        # 2. Direct exponential difference approximation\n        s_dir = (np.exp(x) - np.exp(-x)) / 2.0\n\n        # 3. Truncated Maclaurin polynomial of degree 7\n        x_cubed = x * x * x\n        x_fifth = x_cubed * x * x\n        x_seventh = x_fifth * x * x\n        s_ts = x + x_cubed / F3 + x_fifth / F5 + x_seventh / F7\n\n        # 4. Compute relative errors\n        # The problem defines relerr(a,b) = |a-b| if b=0.\n        if s_star == 0.0:\n            e_dir = np.abs(s_dir - s_star)\n            e_ts = np.abs(s_ts - s_star)\n        else:\n            e_dir = np.abs(s_dir - s_star) / np.abs(s_star)\n            e_ts = np.abs(s_ts - s_star) / np.abs(s_star)\n\n        results.append((e_dir, e_ts))\n\n    # Format the output as specified: a list of [e_dir, e_ts] pairs,\n    # with each float in scientific notation with 12 significant digits and no spaces.\n    formatted_pairs = []\n    for e_dir, e_ts in results:\n        # Format specifier \".11e\" gives 1 digit before decimal point + 11 after.\n        s_dir_formatted = f\"{e_dir:.11e}\"\n        s_ts_formatted = f\"{e_ts:.11e}\"\n        formatted_pairs.append(f\"[{s_dir_formatted},{s_ts_formatted}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_pairs)}]\")\n\nsolve()\n```", "id": "2395275"}, {"introduction": "这个更高级的练习将向你介绍一种处理数值误差的通用且强大的技术：补偿算法（compensated arithmetic）。我们不再仅仅是设法避开灾难性抵消，而是学习如何精确地“捕获”浮点运算中产生的误差项。本练习将引导你使用著名的 Dekker `two-sum` 算法来执行一次高精度的减法运算，并量化其相对于朴素计算所恢复的精度位数，从而展示如何从看似丢失的信息中重获精确性[@problem_id:3131169]。", "problem": "给定几对实数，需要在电气和电子工程师协会 (IEEE) 754 binary64 格式（双精度）下表示和计算它们。此项任务的基本依据包括：IEEE 754 的“向最近舍入，偶数优先”原则；机器 epsilon 的定义（在 binary64 中 $1$ 与下一个可表示数之间的距离）；以及 Sterbenz 引理，该引理指出如果两个浮点数 $x$ 和 $y$ 满足 $0.5 \\leq \\left|x/y\\right| \\leq 2$，那么减法 $x - y$ 在二进制浮点运算中可以精确执行，没有舍入误差。您的目标是，当 $x \\approx y$ 时，通过实验评估计算 $x - y$ 的数值误差，包括朴素计算和使用补偿算法两种情况。补偿算法采用应用于 $x + (-y)$ 的 Dekker 加法无误差变换（通常称为“two-sum”算法）。您必须量化补偿算法相对于朴素减法恢复了多少位精度（以二进制位为单位）。\n\n需要完成的任务：\n- 将每个输入对 $(x, y)$ 表示为 IEEE 754 binary64 值。\n- 使用 binary64 算术计算朴素差值 $d_{\\text{naive}} = \\mathrm{fl}(x - y)$。\n- 将 Dekker 加法无误差变换应用于 $a + b$（其中 $a = x$，$b = -y$），产生一个高位部分 $h$ 和一个低位部分 $\\ell$，并将 $(h, \\ell)$ 解释为精确和 $x + (-y)$ 的补偿表示。\n- 通过将 $x$ 和 $y$ 转换为其 IEEE 754 隐含的精确有理数值（使用 binary64 表示的精确整数比），然后在精确有理数算术中构造数学上精确的基准真值差 $d_{\\text{true}} = x - y$。\n- 定义朴素绝对误差 $E_{\\text{naive}} = \\left|d_{\\text{naive}} - d_{\\text{true}}\\right|$ 和补偿绝对误差 $E_{\\text{comp}} = \\left|(h + \\ell) - d_{\\text{true}}\\right|$，其中和 $h + \\ell$ 必须通过将 $h$ 和 $\\ell$ 转换为其 IEEE 754 隐含的精确有理数值，在精确有理数算术中求值。\n- 定义恢复的精度位数为\n$$\nB = \\begin{cases}\n0,  \\text{if } E_{\\text{naive}} = 0 \\text{ and } E_{\\text{comp}} = 0, \\\\\n\\log_2\\left(\\dfrac{E_{\\text{naive}}}{E_{\\text{comp}}}\\right),  \\text{if } E_{\\text{naive}}  0 \\text{ and } E_{\\text{comp}}  0, \\\\\n53,  \\text{if } E_{\\text{naive}}  0 \\text{ and } E_{\\text{comp}} = 0,\n\\end{cases}\n$$\n其中 $53$ 是 IEEE 754 binary64 尾数中的二进制位数。将每个测试用例的 $B$ 值作为浮点数报告。\n\n使用以下测试套件（所有值都将被解释并在 binary64 中计算）：\n- 测试用例 $1$：$x = 1.234567890123456$，$y = 1.234567890123455$（十进制数值相近，典型的相消场景）。\n- 测试用例 $2$：$x = 1 \\times 10^{308}$，$y = \\operatorname{nextafter}(x, 0)$，其中 $\\operatorname{nextafter}(x, 0)$ 表示在朝向 $0$ 的方向上，最接近 $x$ 的可表示 binary64 值（数量级大，最后一个有效位上相差一个单位）。\n- 测试用例 $3$：$x = 1 + 2^{-30}$，$y = 1 + 2^{-30} - 2^{-52}$（在 $1$ 附近发生相消，间隔与机器 epsilon 相关）。\n- 测试用例 $4$：$x = 2^{-1022}$，$y = x - 2^{-1074}$（处于非规格化数范围内的差值；$2^{-1022}$ 是 binary64 中最小的正规格化数，$2^{-1074}$ 是最小的正非规格化数）。\n- 测试用例 $5$：$x = 2^{53} + 1$ 在 binary64 中解释，$y = 2^{53}$ 在 binary64 中解释（精确整数表示的边界）。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，“[result1,result2,result3,result4,result5]”），其中每个结果是相应测试用例的 $B$ 值，表示为 Python 浮点数。不涉及物理单位或角度单位，所有量均为纯实数。\n\n程序必须是自包含的，不需要任何输入，并严格遵守指定的执行环境。目标是测试 IEEE 754 舍入原则、精确性属性、机器 epsilon 以及补偿算法在减法中处理近似相消的实际行为。", "solution": "用户希望验证并解决一个关于浮点运算的问题。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n\n-   **计算系统**：IEEE 754 binary64 格式（双精度）。\n-   **舍入规则**：向最近舍入，偶数优先。\n-   **核心概念**：机器 epsilon，Sterbenz 引理 ($0.5 \\leq |x/y| \\leq 2 \\implies \\mathrm{fl}(x - y) = x - y$)，Dekker 的无误差变换（two-sum）。\n-   **目标**：对于 $x \\approx y$ 的数对 $(x, y)$，量化补偿算法相对于朴素减法所恢复的精度位数。\n\n-   **计算任务**：\n    1.  将输入 $(x, y)$ 表示为 binary64 值。\n    2.  计算朴素差值：$d_{\\text{naive}} = \\mathrm{fl}(x - y)$。\n    3.  计算补偿和：将 two-sum 算法应用于 $x + (-y)$，得到一对 $(h, \\ell)$。\n    4.  计算基准真值差：将 binary64 的 $x, y$ 转换为精确有理数并计算 $d_{\\text{true}} = x - y$。\n    5.  计算误差：\n        -   朴素绝对误差：$E_{\\text{naive}} = |d_{\\text{naive}} - d_{\\text{true}}|$，使用精确有理数算术。\n        -   补偿绝对误差：$E_{\\text{comp}} = |(h + \\ell) - d_{\\text{true}}|$，其中 $h+\\ell$ 在精确有理数算术中计算。\n    6.  计算恢复的精度位数 $B$：\n        $$\n        B = \\begin{cases}\n        0,  \\text{if } E_{\\text{naive}} = 0 \\text{ and } E_{\\text{comp}} = 0, \\\\\n        \\log_2\\left(\\dfrac{E_{\\text{naive}}}{E_{\\text{comp}}}\\right),  \\text{if } E_{\\text{naive}}  0 \\text{ and } E_{\\text{comp}}  0, \\\\\n        53,  \\text{if } E_{\\text{naive}}  0 \\text{ and } E_{\\text{comp}} = 0,\n        \\end{cases}\n        $$\n        其中 $53$ 是 binary64 的尾数精度。\n\n-   **测试用例（将在 binary64 中解释）**：\n    1.  $x = 1.234567890123456$, $y = 1.234567890123455$。\n    2.  $x = 1 \\times 10^{308}$, $y = \\operatorname{nextafter}(x, 0)$。\n    3.  $x = 1 + 2^{-30}$, $y = 1 + 2^{-30} - 2^{-52}$。\n    4.  $x = 2^{-1022}$, $y = x - 2^{-1074}$。\n    5.  $x = 2^{53} + 1$, $y = 2^{53}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n\n-   **科学依据**：该问题基于数值分析和 IEEE 754 标准的既定原则。诸如灾难性相消、补偿算法（Dekker 算法）、机器 epsilon、非规格化数和舍入规则等概念是计算科学的核心。该问题在科学上是合理的。\n-   **适定性**：问题定义清晰。输入、所需计算、误差度量和最终输出格式都已精确定义。$B$ 的公式涵盖了预期的结果（$E_{\\text{naive}} \\ge 0, E_{\\text{comp}} \\ge 0$）。对于 $E_{\\text{naive}}  0$ 且补偿变换产生精确结果（$E_{\\text{comp}} = 0$）的情况，通过分配 53 位的结果来处理，这对应于 binary64 格式的完全精度恢复。该问题是适定的。\n-   **客观性**：问题以客观、技术性的语言陈述，没有偏见或主观断言。\n\n该问题没有显示出说明中列出的任何无效性缺陷。这是一个计算科学领域中有效且不平凡的问题。\n\n**步骤 3：结论与行动**\n\n该问题是**有效的**。我将继续提供一个完整的解决方案。\n\n### 解决方案\n\n解决方案要求为每个测试用例实现指定的计算。这涉及标准浮点运算和精确有理数运算的结合。所有数学实体都按要求使用 LaTeX 排版。\n\n1.  **框架设置**：我们使用 Python，其中标准的 `float` 对象对应于 IEEE 754 binary64。`numpy` 库提供了 `nextafter` 函数。对于精确有理数运算，Python 的 `fractions.Fraction` 类是理想选择，因为 `Fraction(some_float)` 可以将一个 binary64 数正确地转换为其精确的有理数表示形式 $M/2^k$，其中 $M, k \\in \\mathbb{Z}$。\n\n2.  **Dekker 的 `two-sum` 算法**：问题指定使用 Dekker 的加法无误差变换，通常称为 `two-sum` 算法。给定两个浮点数 $a$ 和 $b$，此算法计算两个数，一个高位部分 $h$ 和一个低位部分 $\\ell$，使得 $h = \\mathrm{fl}(a+b)$ 且 $h+\\ell = a+b$ 精确成立。不需要 $|a| \\geq |b|$ 的标准算法是：\n    -   $h = a + b$\n    -   $a' = h - b$\n    -   $b' = h - a'$\n    -   $\\delta_a = a - a'$\n    -   $\\delta_b = b - b'$\n    -   $\\ell = \\delta_a + \\delta_b$\n    所有运算都是标准的浮点运算。在我们的问题中，我们将其应用于 $a=x$ 和 $b=-y$。\n\n3.  **基准真值和误差计算**：对于每个测试用例 $(x, y)$：\n    -   输入首先被实现为 binary64 值。\n    -   朴素差值计算为 $d_{\\text{naive}} = \\mathrm{fl}(x - y)$。\n    -   基准真值差 $d_{\\text{true}}$ 是通过将 $x$ 和 $y$ 转换为 `Fraction` 对象然后相减来计算的：$d_{\\text{true}} = \\text{Fraction}(x) - \\text{Fraction}(y)$。\n    -   朴素误差是 $E_{\\text{naive}} = |\\text{Fraction}(d_{\\text{naive}}) - d_{\\text{true}}|$。\n    -   将 `two-sum` 算法应用于 $(x, -y)$，得到 $(h, \\ell)$。补偿和在精确有理数中计算为 $\\text{Fraction}(h) + \\text{Fraction}(\\ell)$。\n    -   补偿误差是 $E_{\\text{comp}} = |(\\text{Fraction}(h) + \\text{Fraction}(\\ell)) - d_{\\text{true}}|$。根据无误差变换的性质，这个误差 $E_{\\text{comp}}$ 预期将精确为 $0$。\n\n4.  **测试用例分析**：\n    -   **情况 1**：$x = 1.234567890123456, y = 1.234567890123455$。这些十进制字面量被转换为它们最接近的 binary64 表示，我们称之为 $x_f$ 和 $y_f$。减法 $x_f - y_f$ 是灾难性相消的典型例子。这些 binary64 数的精确差值 $d_{\\text{true}}$ 是非零的。朴素计算的浮点结果 $d_{\\text{naive}} = \\mathrm{fl}(x_f - y_f)$ 会产生舍入误差，因此 $E_{\\text{naive}}  0$。补偿和是精确的，所以 $E_{\\text{comp}} = 0$。因此，我们预期恢复全部精度，$B=53$。\n    -   **情况 2**：$x = 1 \\times 10^{308}, y = \\operatorname{nextafter}(x, 0)$。这里，$x$ 和 $y$ 是相邻的 binary64 数。它们的比值 $|x/y|$ 极度接近 $1$，满足 Sterbenz 引理的条件（$0.5 \\le |x/y| \\le 2$）。因此，减法 $d_{\\text{naive}} = \\mathrm{fl}(x-y)$ 保证是精确的。这意味着 $E_{\\text{naive}} = 0$。因此，$E_{\\text{comp}}$ 也将为 $0$，且 $B=0$。\n    -   **情况 3**：$x = 1 + 2^{-30}, y = 1 + 2^{-30} - 2^{-52}$。$x$ 和 $y$（由浮点计算定义）在 binary64 中都是精确可表示的。它们的比值也接近 $1$，所以 Sterbenz 引理适用于它们的减法。$d_{\\text{naive}}$ 将是精确的，意味着 $E_{\\text{naive}} = 0$，从而得到 $B=0$。\n    -   **情况 4**：$x = 2^{-1022}, y = x - 2^{-1074}$。这里，$x$ 是最小的正规格化数，而 $y$ 是一个非规格化数。两者都是精确可表示的。差值 $d_{\\text{true}} = 2^{-1074}$ 是最小的正非规格化数，也是精确可表示的。比值 $|x/y|$ 接近 $1$，所以 Sterbenz 引理适用。减法是精确的，$E_{\\text{naive}} = 0$，且 $B=0$。\n    -   **情况 5**：$x = 2^{53} + 1, y = 2^{53}$。值 $2^{53}+1$ 在 binary64 中不可表示。它恰好位于两个可表示浮点数 $2^{53}$ 和 $2^{53}+2$ 的中间。根据“向最近舍入，偶数优先”规则，$2^{53}+1$ 会舍入到 $2^{53}$，因为 $2^{53}$ 的尾数是偶数。因此，在 binary64 中，输入值变为 $x = 2^{53}$ 和 $y = 2^{53}$。减法 $x-y$ 显然是 $0$。$d_{\\text{naive}}$ 和 $d_{\\text{true}}$ 均为 $0$，所以 $E_{\\text{naive}} = 0$ 且 $B=0$。\n\n实现将执行这些步骤，并报告每个用例计算出的 $B$ 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\nfrom fractions import Fraction\n\ndef solve():\n    \"\"\"\n    Solves the floating-point arithmetic problem as described.\n    \"\"\"\n\n    def two_sum(a: float, b: float) - tuple[float, float]:\n        \"\"\"\n        Implements Dekker's error-free transform for addition (two-sum).\n        Given two floating-point numbers a and b, returns a pair (h, l)\n        such that h = fl(a + b) and h + l = a + b exactly.\n        All internal calculations are floating-point operations.\n        Reference: Ogita, T., Rump, S. M.,  Oishi, S. (2005).\n        \"Accurate sum and dot product.\"\n        \"\"\"\n        h = a + b\n        a_prime = h - b\n        b_prime = h - a_prime\n        delta_a = a - a_prime\n        delta_b = b - b_prime\n        l = delta_a + delta_b\n        return (h, l)\n\n    # Define the test cases from the problem statement.\n    # Case 1: Close decimal magnitudes, typical cancellation scenario.\n    x1 = 1.234567890123456\n    y1 = 1.234567890123455\n    \n    # Case 2: Large magnitude with one ULP separation.\n    x2 = 1.0e308\n    y2 = np.nextafter(x2, 0.0)\n    \n    # Case 3: Cancellation near 1 with spacing tied to machine epsilon.\n    x3 = 1.0 + 2.0**-30\n    y3 = (1.0 + 2.0**-30) - 2.0**-52\n    \n    # Case 4: Difference in the subnormal regime.\n    x4 = 2.0**-1022\n    y4 = x4 - 2.0**-1074\n\n    # Case 5: Boundary of exact integer representability.\n    # float(2**53 + 1) is rounded to 2**53 due to ties-to-even rule.\n    x5 = float(2**53 + 1)\n    y5 = float(2**53)\n\n    test_cases = [\n        (x1, y1),\n        (x2, y2),\n        (x3, y3),\n        (x4, y4),\n        (x5, y5),\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        x, y = case\n        \n        # Compute the naive difference using binary64 arithmetic.\n        d_naive = x - y\n        \n        # Apply Dekker’s error-free transform for addition to x + (-y).\n        h, l = two_sum(x, -y)\n        \n        # Construct the mathematically exact ground truth difference.\n        x_frac = Fraction(x)\n        y_frac = Fraction(y)\n        d_true = x_frac - y_frac\n        \n        # Define the absolute naive error.\n        d_naive_frac = Fraction(d_naive)\n        E_naive = abs(d_naive_frac - d_true)\n        \n        # Define the compensated absolute error.\n        h_frac = Fraction(h)\n        l_frac = Fraction(l)\n        comp_sum_frac = h_frac + l_frac\n        E_comp = abs(comp_sum_frac - d_true)\n\n        # Define the bits of precision recovered.\n        B = 0.0\n        if E_naive == Fraction(0) and E_comp == Fraction(0):\n            B = 0.0\n        elif E_naive  Fraction(0) and E_comp == Fraction(0):\n            B = 53.0\n        elif E_naive  Fraction(0) and E_comp  Fraction(0):\n            # This case implies the two-sum was not perfectly error-free\n            # in practice, or d_true itself had some representation issues.\n            # We proceed with the formula as specified.\n            B = math.log2(float(E_naive / E_comp))\n        \n        results.append(B)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3131169"}]}