{"hands_on_practices": [{"introduction": "这项实践是让你从零开始构建离散事件模拟的基础练习。你将实现一个带有“批量服务”机制的单服务器排队系统，这比最简单的模型更进了一步。通过这项练习，你将掌握模拟的核心组成部分：管理仿真时钟、处理不同类型的事件、更新系统状态，以及收集吞吐量和等待时间等关键性能指标。[@problem_id:3119935]", "problem": "您需要设计并实现一个带批量服务的单服务器队列的离散事件模拟（DES），该模型被称为具有最大批处理规模的马尔可夫到达/马尔可夫服务/单服务器（$M/M/1$）队列。在此系统中，到达过程构成速率为 $\\lambda$ 的泊松过程，服务时间服从速率为 $\\mu$ 的指数分布（按批次计算）。服务器可以启动一次服务，同时为最多 $b$ 名顾客提供服务；服务开始时选择的批次大小为当前队列长度与最大批次大小 $b$ 之间的最小值，即 $k = \\min(b, q)$。一批次的服务时间不依赖于该批次的大小。顾客在先入先出（FIFO）队列中等待。\n\n从核心定义出发，您必须实现一个基于事件调度的离散事件模拟，该模拟遵循以下规则：\n\n- 到达根据速率为 $\\lambda$ 的泊松过程发生；到达间隔时间是独立的，且服从均值为 $1/\\lambda$ 的指数分布。\n- 当服务器空闲且队列非空时，立即对一个大小为 $k = \\min(b, q)$ 的批次开始服务，其中 $q$ 是当前队列长度。该批次中的所有 $k$ 名顾客在同一时刻开始服务，并在经历一个均值为 $1/\\mu$ 的单一指数分布的服务时间后一同离开。\n- 当一个批次正在服务时，新到达的顾客加入队列，并将在当前服务完成后于未来的某个批次中得到服务。\n- 顾客的等待时间定义为从到达时刻到服务开始时刻的时间。吞吐量定义为在模拟时域内离开的顾客总数除以模拟时域长度。\n\n您的模拟必须使用下一事件时间推进法：在任何步骤，下一事件是下一到达时间和下一服务完成时间中的最小值。模拟必须从时间 $t=0$ 运行到一个有限时域 $T$，初始状态为空队列和空闲服务器。您必须报告运行期间的以下性能指标：\n- 吞吐量 $\\tau$，定义为 $D/T$，其中 $D$ 是在时间 $T$ 之前完成服务的顾客数量。\n- 在时间 $T$ 之前开始服务的所有顾客的平均等待时间 $\\overline{W}$。\n\n重要的建模说明：\n- 假设一批次的服务时间分布为 $\\text{Exponential}(\\mu)$，与批次中的顾客数量无关。\n- 为保证可复现性，每个测试用例必须使用指定的伪随机种子。\n- 如果在时域内没有顾客开始服务，则将 $\\overline{W}$ 定义为 $\\mathrm{NaN}$（非数字），并将 $\\tau$ 定义为 $0$。\n\n使用的基本定义：\n- 泊松过程：到达具有独立、平稳的增量；到达间隔时间是独立的，服从参数为 $\\lambda$ 的指数分布随机变量。\n- 参数为 $\\alpha$ 的指数分布：一种具有无记忆性的非负随机变量，其均值为 $1/\\alpha$。\n- FIFO 规则：顾客按其到达时间的非递减顺序获得服务。\n\n实现一个完整、可运行的程序，为以下测试套件计算 $\\tau$ 和 $\\overline{W}$，其中每个参数集为 $(\\lambda, \\mu, b, T, \\text{seed})$：\n\n- 测试 $1$：$(\\lambda=0.8,\\;\\mu=1.0,\\;b=2,\\;T=20000,\\;\\text{seed}=1)$，一个负载适中的稳定情况。\n- 测试 $2$：$(\\lambda=2.0,\\;\\mu=1.0,\\;b=2,\\;T=20000,\\;\\text{seed}=2)$，一个接近名义容量 $\\mu \\cdot b$ 的边界负载情况。\n- 测试 $3$：$(\\lambda=1.5,\\;\\mu=1.0,\\;b=1,\\;T=20000,\\;\\text{seed}=3)$，一个经典的单顾客批次过载情况（一次服务一个）。\n- 测试 $4$：$(\\lambda=0.9,\\;\\mu=1.0,\\;b=4,\\;T=20000,\\;\\text{seed}=4)$，一个批次容量较大的稳定情况。\n- 测试 $5$：$(\\lambda=3.0,\\;\\mu=0.5,\\;b=10,\\;T=20000,\\;\\text{seed}=5)$，一个批次容量大的稳定高负载情况。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个测试用例贡献一对 $[\\tau,\\overline{W}]$，两个值都以浮点数形式打印，并四舍五入到小数点后六位。最终格式必须是：\n$$\\big[ [\\tau_1,\\overline{W}_1], [\\tau_2,\\overline{W}_2], [\\tau_3,\\overline{W}_3], [\\tau_4,\\overline{W}_4], [\\tau_5,\\overline{W}_5] \\big]$$\n其中顺序对应测试 1 到 5。吞吐量 $\\tau$ 的单位必须是每单位时间的顾客数，等待时间 $\\overline{W}$ 的时间单位必须与 $T$ 相同。", "solution": "该问题要求设计并实现一个带批量服务的单服务器队列的离散事件模拟，具体是一个归类为具有最大批处理规模 $b$ 的 $M/M/1$ 模型。该模拟必须使用下一事件时间推进机制构建，并将用于估计系统性能指标。该问题具有科学依据，定义明确，并为可复现的模拟提供了所有必要的参数。\n\n### 1. 离散事件模拟（DES）的概念框架\n\n离散事件模拟将系统随时间的演变建模为一系列改变系统状态的瞬时事件。此模拟的基本组成部分是：\n\n-   **状态变量**：完全描述系统在任何时间点状态的最小变量集。对于此问题，状态由队列中等待的顾客数量 $q$ 和服务器状态（空闲或繁忙）定义。为了计算单个顾客的等待时间，我们还必须存储每个等待顾客的到达时间。\n-   **模拟时钟（$t_{sim}$）**：一个跟踪模拟内部当前时间的变量。时间以离散的跳跃方式从一个事件推进到下一个事件。\n-   **事件**：引发系统状态变化的瞬时发生。在此模型中，有两种事件类型：顾客**到达**和批次**服务完成**（对应多个顾客的离开）。\n-   **事件调度**：管理未来事件的机制。鉴于只有两种未来事件需要跟踪（下一次到达和下一次潜在的服务完成），我们可以使用两个变量 $t_A$ 和 $t_D$ 来存储它们被安排的时间。预定时间最小的事件是下一个要发生的事件。\n\n### 2. 状态变量和统计累加器\n\n模拟动态维护以下变量以跟踪系统状态并计算最终指标：\n\n-   **模拟时钟**：$t_{sim}$\n-   **到达时间队列**：$Q_{times}$，一个先入先出（FIFO）数据结构，用于保存当前等待服务的顾客的到达时间。其长度对应于队列长度 $q = |Q_{times}|$。\n-   **服务器状态**：$S$，一个二进制指示器，其中 $S=0$ 表示服务器空闲，$S=1$ 表示服务器繁忙。\n-   **下一到达时间**：$t_A$，已安排的下一位顾客到达的时间。\n-   **下一离开时间**：$t_D$，当前批次服务完成的预定时间。当服务器空闲时，它被设置为无穷大（$\\infty$）。\n-   **服务中批次的大小**：$k_{service}$，当前正在服务的批次中的顾客数量。\n\n为了计算所需的性能指标，在整个模拟过程中会更新以下统计累加器：\n\n-   $N_D$：已离开（完成服务）的顾客总数。\n-   $N_S$：已开始服务的顾客总数。\n-   $W_{tot}$：所有已开始服务的顾客的等待时间累积总和。\n\n### 3. 模拟算法：下一事件时间推进\n\n模拟执行一个主循环，该循环重复地将时钟推进到下一个预定事件时间，处理该事件，并更新系统状态。该过程从 $t_{sim}=0$ 开始，一直持续到下一个事件时间将超过模拟时域 $T$ 为止。\n\n#### 初始化（在 $t_{sim}=0$ 时）\n\n1.  设置模拟时钟 $t_{sim} = 0$。\n2.  初始化系统状态：队列 $Q_{times}$ 为空，服务器空闲（$S=0$）。\n3.  初始化统计累加器：$N_D = 0$，$N_S = 0$ 和 $W_{tot} = 0$。\n4.  初始化服务器变量：$k_{service}=0$。\n5.  为伪随机数生成器设置种子以保证可复现性。\n6.  安排第一次到达：使用公式 $\\Delta t_A = -\\frac{1}{\\lambda}\\ln(U)$ 从速率为 $\\lambda$（均值为 $1/\\lambda$）的指数分布中生成一个到达间隔时间 $\\Delta t_A$，其中 $U$ 是一个来自 Uniform$(0,1)$ 分布的随机变量。将第一次到达时间设置为 $t_A = \\Delta t_A$。\n7.  将下一次离开时间设置为无穷大，$t_D = \\infty$，因为服务器最初是空闲的。\n\n#### 模拟主循环\n\n循环按以下方式进行：\n\n1.  **识别下一事件**：确定下一事件的时间，$t_{next} = \\min(t_A, t_D)$。\n2.  **检查终止条件**：如果 $t_{next} > T$，则模拟时域已过，循环终止。\n3.  **推进时钟**：将模拟时钟更新到下一事件时间：$t_{sim} = t_{next}$。\n4.  **处理事件**：\n    -   **如果 $t_{sim}$ 是到达时间（$t_{sim} = t_A$）：**\n        a. 一位新顾客到达。将其到达时间 $t_{sim}$ 添加到队列 $Q_{times}$ 中。\n        b. 安排下一次到达。生成一个新的到达间隔时间 $\\Delta t_A \\sim \\text{Exponential}(\\lambda)$，并设置新的到达时间 $t_A = t_{sim} + \\Delta t_A$。\n    -   **如果 $t_{sim}$ 是离开时间（$t_{sim} = t_D$）：**\n        a. 大小为 $k_{service}$ 的批次完成服务。增加总离开人数：$N_D \\leftarrow N_D + k_{service}$。\n        b. 服务器变为空闲。设置 $S=0$ 并将下一次离开时间重置为 $t_D = \\infty$。\n\n5.  **检查是否开始新服务**：此逻辑在任何事件后执行。\n    -   如果服务器空闲（$S=0$）且队列不为空（$|Q_{times}|>0$）：\n        a. 服务器变为繁忙：设置 $S=1$。\n        b. 确定此服务实例的批次大小：$k = \\min(b, |Q_{times}|)$。\n        c. 记录当前服务中批次的大小：$k_{service} = k$。\n        d. 对于队列前面的 $k$ 名顾客中的每一位：\n           i. 从 $Q_{times}$ 中出队其到达时间 $t_{arr}$。\n           ii. 计算其等待时间：$W_i = t_{sim} - t_{arr}$。\n           iii. 将此时间加到总等待时间中：$W_{tot} \\leftarrow W_{tot} + W_i$。\n        e. 将已开始服务的顾客数增加批次大小：$N_S \\leftarrow N_S + k$。\n        f. 为这个新批次安排服务完成。生成一个服务时间 $\\Delta t_S \\sim \\text{Exponential}(\\mu)$，并设置离开时间 $t_D = t_{sim} + \\Delta t_S$。\n\n#### 最终计算\n\n模拟循环终止后，计算性能指标：\n\n1.  **吞吐量 ($\\tau$)**：定义为完成服务的顾客速率。计算公式为 $\\tau = N_D / T$。如果没有顾客离开，$N_D=0$，因此 $\\tau=0$。\n2.  **平均等待时间 ($\\overline{W}$)**：在时间 $T$ 前开始服务的所有顾客的平均值。\n    -   如果 $N_S > 0$，则平均等待时间为 $\\overline{W} = W_{tot} / N_S$。\n    -   如果 $N_S = 0$，则没有顾客开始服务。在这种情况下，$\\overline{W}$ 定义为非数字（$\\mathrm{NaN}$）。\n\n这种严谨的、事件驱动的方法确保了系统动态根据指定规则得到准确建模。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef run_simulation(lambda_rate, mu_rate, b, T, seed):\n    \"\"\"\n    Runs a discrete event simulation of a single-server queue with bulk service.\n\n    Args:\n        lambda_rate (float): Arrival rate (Poisson process).\n        mu_rate (float): Service rate per batch (Exponential distribution).\n        b (int): Maximum batch size.\n        T (float): Simulation time horizon.\n        seed (int): Seed for the pseudo-random number generator.\n\n    Returns:\n        tuple[float, float]: A tuple containing the calculated throughput (tau)\n                             and mean waiting time (W_mean).\n    \"\"\"\n    rng = np.random.default_rng(seed)\n\n    # State variables\n    t_sim = 0.0\n    queue_arrival_times = deque()\n    server_busy = False\n\n    # Event times\n    t_arrival = rng.exponential(scale=1.0 / lambda_rate)\n    t_departure = float('inf')\n\n    # Statistical accumulators\n    departed_count = 0\n    started_service_count = 0\n    wait_time_sum = 0.0\n    \n    # Variable to store the size of the batch currently in service\n    batch_size_in_service = 0\n\n    while True:\n        # Determine the next event time and type\n        is_arrival_event = False\n        if t_arrival = t_departure:\n            next_event_time = t_arrival\n            is_arrival_event = True\n        else:\n            next_event_time = t_departure\n            is_arrival_event = False\n\n        # Check termination condition\n        if next_event_time > T:\n            break\n        \n        t_sim = next_event_time\n\n        if is_arrival_event:\n            # --- Process Arrival Event ---\n            queue_arrival_times.append(t_sim)\n            # Schedule the next arrival\n            t_arrival = t_sim + rng.exponential(scale=1.0 / lambda_rate)\n        else:\n            # --- Process Departure Event ---\n            departed_count += batch_size_in_service\n            server_busy = False\n            t_departure = float('inf')\n            batch_size_in_service = 0\n\n        # --- Check for new Service Start (after any event) ---\n        if not server_busy and len(queue_arrival_times) > 0:\n            server_busy = True\n            \n            # Determine batch size\n            batch_k = min(b, len(queue_arrival_times))\n            batch_size_in_service = batch_k\n            \n            # Process customers starting service\n            for _ in range(batch_k):\n                arrival_t = queue_arrival_times.popleft()\n                wait_time_sum += (t_sim - arrival_t)\n            \n            started_service_count += batch_k\n            \n            # Schedule the departure for this batch\n            service_time = rng.exponential(scale=1.0 / mu_rate)\n            t_departure = t_sim + service_time\n    \n    # --- Final Calculations after loop termination ---\n    tau = departed_count / T\n\n    if started_service_count > 0:\n        W_mean = wait_time_sum / started_service_count\n    else:\n        # As per problem spec, if no customer starts service, W is NaN.\n        # tau will naturally be 0 in this case as departed_count is 0.\n        W_mean = float('nan')\n\n    return tau, W_mean\n\ndef solve():\n    \"\"\"\n    Defines test cases, runs the simulation for each, and prints the formatted results.\n    \"\"\"\n    test_cases = [\n        # (lambda_rate, mu_rate, b, T, seed)\n        (0.8, 1.0, 2, 20000, 1),  # Test 1\n        (2.0, 1.0, 2, 20000, 2),  # Test 2\n        (1.5, 1.0, 1, 20000, 3),  # Test 3\n        (0.9, 1.0, 4, 20000, 4),  # Test 4\n        (3.0, 0.5, 10, 20000, 5)  # Test 5\n    ]\n\n    results = []\n    for case in test_cases:\n        tau, W_mean = run_simulation(*case)\n        \n        # Format results to six decimal places, handling NaN for waiting time.\n        tau_str = f\"{tau:.6f}\"\n        if np.isnan(W_mean):\n            W_mean_str = \"NaN\" \n        else:\n            W_mean_str = f\"{W_mean:.6f}\"\n            \n        results.append(f\"[{tau_str},{W_mean_str}]\")\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3119935"}, {"introduction": "构建模拟是一回事，而确保其正确性是另一项同等重要的任务。本练习的重点将从简单地计算结果转移到通过“不变量”来验证模型的逻辑完整性——这些规则在任何时候都必须成立。你将学习嵌入运行时断言来检查这些不变量，并使用“故障注入”来测试你的验证系统是否能检测到蓄意引入的错误，这是开发可靠科学软件的一项关键技能。[@problem_id:3119919]", "problem": "您将实现一个具有指数分布到达间隔和服务时间的单服务台排队离散事件模拟。其目标是在运行时验证不变性属性，并注入受控的逻辑故障以测试检测覆盖率。该模拟必须通过固定的随机种子来确保其确定性。其基本基础包括离散事件模拟的定义、到达事件的泊松过程概念以及实体守恒原则。\n\n系统定义如下：\n- 事件分为到达和服务完成（离开）。在时间 $t$ 处理完每个事件后，必须断言以下不变量：\n  1. 队列长度非负性：$Q(t) \\ge 0$，其中 $Q(t)$ 是在队列中等待的实体数量（不包括任何正在接受服务的实体）。\n  2. 实体守恒：$S(t) + D(t) = A(t)$，其中 $S(t)$ 是系统中当前的实体总数（等待中加服务中），$D(t)$ 是累计离开数，而 $A(t)$ 是累计到达数。\n- 到达遵循到达间隔呈指数分布，其速率为 $\\lambda$（单位：$\\text{s}^{-1}$，即每秒）。服务遵循指数分布，其速率为 $\\mu$（单位：$\\text{s}^{-1}$）。模拟时间以 $T_{\\text{end}}$ 为上界（单位：秒）。\n\n请根据以下规则实现离散事件模拟：\n- 使用一个按时间排序的优先级事件列表，严格按时间顺序处理事件。\n- 当有到达事件时：\n  - 增加累计到达数 $A(t)$，除非故障另有规定。\n  - 如果服务台空闲，则立即开始服务，并在抽取服务时间后安排一个离开事件；否则，增加队列长度。\n  - 相应地更新 $S(t)$。\n- 当有离开事件时：\n  - 增加累计离开数 $D(t)$。\n  - 如果队列非空，则减少队列长度并立即开始为下一个实体服务（安排其离开事件）；否则，将服务台标记为空闲。\n  - 相应地更新 $S(t)$。\n- 在每个事件之后，对两个不变量强制执行运行时断言。如果任何断言失败，模拟必须记录检测到违规，并停止处理该测试用例的后续事件。\n\n故障注入机制：\n- 故障 $f_1$（“负队列故障”）：在第一个离开事件发生时，在检查不变量之前，恶意地将 $Q(t)$ 设置为 $-1$。这用于测试对非负性不变量的检测。\n- 故障 $f_2$（“丢弃到达故障”）：在第 $k$ 次到达时（$k$ 为正整数），将到达事件处理进系统，但不增加 $A(t)$。这用于测试对守恒不变量的检测。\n\n单位：\n- 时间 $t$ 和 $T_{\\text{end}}$ 的单位必须是秒。\n- 速率 $\\lambda$ 和 $\\mu$ 的单位必须是 $\\text{s}^{-1}$。\n\n随机性：\n- 对所有随机抽样使用固定的种子 $s = 42$，以确保确定性。\n\n您的程序必须实现模拟和不变量检查，并且必须支持按测试用例切换两种故障。对于每个测试用例，返回一个布尔值，指示是否检测到任何不变量违规（如果检测到违规，则为 $\\text{True}$，否则为 $\\text{False}$）。\n\n测试套件（所有时间单位为秒，所有速率单位为 $\\text{s}^{-1}$，$k$ 是一个无单位的正整数索引）：\n- 案例 1（正常路径）：$\\lambda = 1.5$, $\\mu = 2.0$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 2（边界情况，无到达）：$\\lambda = 0.0$, $\\mu = 1.0$, $T_{\\text{end}} = 5.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 3（快速服务边缘情况）：$\\lambda = 10.0$, $\\mu = 100.0$, $T_{\\text{end}} = 1.0$, $f_1 = \\text{False}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 4（负队列故障）：$\\lambda = 0.5$, $\\mu = 0.5$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{True}$, $f_2 = \\text{False}$, $k = 3$。\n- 案例 5（丢弃到达故障）：$\\lambda = 2.0$, $\\mu = 3.0$, $T_{\\text{end}} = 10.0$, $f_1 = \\text{False}$, $f_2 = \\text{True}$, $k = 3$。\n\n最终输出规范：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，每个测试用例对应一个布尔值，顺序与上述案例一致（例如，$[\\text{True},\\text{False},\\dots]$）。不允许有其他输出。", "solution": "问题陈述已经过评估，并被确定为**有效**。它在科学上基于排队论和离散事件模拟的既定原则，并且问题提法清晰，为确定性实现提供了一套完整且一致的定义、参数和约束。\n\n任务是实现一个单服务台排队的离散事件模拟（DES），在排队论中因其**M**arkovian（马尔可夫，即指数）到达间隔和服务时间分布而被称为 M/M/1 排队。该实现将用于在运行时验证系统不变量，并测试对注入故障的检测能力。\n\n**1. 离散事件模拟的原理**\n\n离散事件模拟将系统的演化建模为在特定时间点发生的一系列离散事件。我们的模拟模型的核心组件是：\n- **系统状态**：一组在任何给定时间 $t$ 捕获系统基本信息的变量。\n- **仿真时钟**：一个表示模拟中当前时间 $t$ 的变量。\n- **事件列表**：一个数据结构，通常是优先队列，用于存储按预定发生时间排序的未来事件。\n\n模拟的进行方式是：从事件列表中重复提取下一个最紧急的事件，将仿真时钟推进到该事件的发生时间，并执行更新系统状态的事件处理例程。\n\n**2. 系统状态表示**\n\n对于 M/M/1 排队模型，系统在时间 $t$ 的状态由以下变量定义：\n- $Q(t)$：在队列中等待的实体数量。这是一个非负整数。\n- $B(t)$：一个表示服务台状态的二进制变量，其中 $B(t)=1$ 表示服务台繁忙，$B(t)=0$ 表示空闲。\n- $A(t)$：直到时间 $t$ 为止，已到达系统的实体累计数量。\n- $D(t)$：直到时间 $t$ 为止，已离开系统的实体累计数量。\n\n从这些变量中，我们可以推导出 $S(t)$，即当前系统中的实体总数（正在服务或在队列中等待）：\n$$S(t) = Q(t) + B(t)$$\n\n**3. 事件驱动逻辑与事件例程**\n\n模拟由事件调度算法驱动。一个实现为最小优先队列的事件列表将待处理事件存储为 `(event_time, event_type)` 元组。主循环持续处理时间戳最小的事件，直到事件列表为空或超过模拟结束时间 $T_{\\text{end}}$。\n\n两种类型的事件驱动系统动态：到达和离开。\n\n**到达事件例程**：\n在时间 $t$ 发生的到达事件会触发以下操作：\n1.  **故障注入检查**：如果启用了故障 $f_2$ 并且这是第 $k$ 次到达，则跳过对 $A(t)$ 的增加。否则，增加 $A(t)$：$A(t) \\leftarrow A(t^-) + 1$。\n2.  **状态更新**：\n    - 如果服务台空闲（$B(t^-)=0$），到达的实体立即进入服务。我们设置 $B(t) \\leftarrow 1$ 并安排一个新的 `Departure` 事件。这个未来离开事件的时间是 $t + \\tau_s$，其中 $\\tau_s$ 是从速率为 $\\mu$ 的指数分布中抽取的随机服务时间。\n    - 如果服务台繁忙（$B(t^-)=1$），该实体必须等待。队列长度增加：$Q(t) \\leftarrow Q(t^-) + 1$。\n3.  **安排下一次到达**：在时间 $t + \\tau_a$ 安排一个新的 `Arrival` 事件，其中 $\\tau_a$ 是从速率为 $\\lambda$ 的指数分布中抽取的随机到达间隔时间。仅当 $\\lambda  0$ 时才执行此操作。\n\n**离开事件例程**：\n在时间 $t$ 发生的离开事件表示一次服务的完成：\n1.  **状态更新**：累计离开数增加：$D(t) \\leftarrow D(t^-) + 1$。\n2.  **服务台和队列更新**：\n    - 如果队列不为空（$Q(t^-)  0$），队列中的下一个实体立即进入服务。我们减少队列长度，$Q(t) \\leftarrow Q(t^-) - 1$，并在时间 $t + \\tau_s$ 安排一个新的 `Departure` 事件，其中 $\\tau_s$ 从服务时间分布中抽取。服务台保持繁忙状态（$B(t)=1$）。\n    - 如果队列为空（$Q(t^-)=0$），服务台变为空闲：$B(t) \\leftarrow 0$。\n\n**4. 随机变量生成**\n\n到达间隔和服务时间是分别遵循速率为 $\\lambda$ 和 $\\mu$ 的指数分布的随机变量。可以使用逆变换采样法从速率参数为 $\\theta$ 的指数分布中生成一个随机变量 $x$。其公式如下：\n$$ x = -\\frac{1}{\\theta} \\ln(U) $$\n其中 $U$ 是从区间 $(0, 1)$ 上的均匀分布中抽取的随机数。为确保问题所要求的确定性行为，伪随机数生成器在每次模拟运行开始时使用固定值 $s=42$ 进行播种。\n\n**5. 不变量断言与故障注入**\n\n在处理完每个事件后，会断言两个基本的系统不变量，以确保模拟状态的逻辑正确性。故障注入机制被设计用于确定性地违反这些不变量，以测试监控逻辑。\n\n1.  **队列非负性**：$Q(t) \\ge 0$。物理上队列中的项目数不可能是负数。故障 $f_1$ 测试对此不变量违规的检测。在第一个离开事件发生时，它会在检查不变量之前恶意地将 $Q(t)$ 的值设置为 $-1$。\n\n2.  **实体守恒**：$A(t) = S(t) + D(t)$。这表达了守恒定律：一个已经到达的实体，要么仍在系统中（$S(t)$），要么已经离开（$D(t)$）。故障 $f_2$ 针对此不变量。在第 $k$ 次到达时，它会使模拟从累计计数 $A(t)$ 中“丢弃”该次到达，但仍然允许该实体进入系统。这将造成 $S(t) + D(t)$ 大于 $A(t)$ 的差异，从而违反了等式。\n\n如果任一检查失败，一个“检测到违规”标志将被设置为 `True`，并且该特定测试用例的模拟将终止。否则，模拟将继续。每个案例的最终结果是此标志的最终状态。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef run_simulation(lam: float, mu: float, T_end: float, f1: bool, f2: bool, k: int) -> bool:\n    \"\"\"\n    Runs a discrete event simulation of a single-server queue (M/M/1).\n\n    Args:\n        lam: The arrival rate (lambda) in s^-1.\n        mu: The service rate (mu) in s^-1.\n        T_end: The simulation end time in seconds.\n        f1: Boolean flag to enable the negative queue fault.\n        f2: Boolean flag to enable the drop arrival fault.\n        k: The index of the arrival to drop for the f2 fault.\n\n    Returns:\n        A boolean indicating if any invariant violation was detected.\n    \"\"\"\n    # Set the random seed for reproducibility in this specific run.\n    np.random.seed(42)\n\n    # State variables\n    current_time = 0.0\n    queue_length = 0\n    # server_busy is equivalent to B(t), where 1 is busy and 0 is idle.\n    server_busy = False\n    cumulative_arrivals = 0\n    cumulative_departures = 0\n    \n    # Internal counters for fault logic\n    arrival_handler_calls = 0\n    departure_handler_calls = 0\n\n    violation_detected = False\n\n    # Event list: min-heap of (time, type_id, event_id)\n    # type_id: 0 for Arrival, 1 for Departure\n    # event_id: unique counter to break ties and ensure heap stability\n    event_list = []\n    event_id_counter = 0\n\n    # Schedule the first arrival if arrival rate is positive\n    if lam > 0:\n        interarrival_time = np.random.exponential(scale=1.0/lam)\n        heapq.heappush(event_list, (interarrival_time, 0, event_id_counter))\n        event_id_counter += 1\n\n    # Main simulation loop\n    while event_list:\n        event_time, event_type_id, _ = heapq.heappop(event_list)\n        \n        # Stop if simulation time exceeds T_end\n        if event_time > T_end:\n            break\n\n        current_time = event_time\n\n        # --- Event Handlers ---\n        if event_type_id == 0:  # Arrival Event\n            arrival_handler_calls += 1\n            \n            # Process arrival into system; A(t) increment is conditional on fault f2\n            if not server_busy:\n                server_busy = True\n                service_time = np.random.exponential(scale=1.0/mu)\n                departure_time = current_time + service_time\n                heapq.heappush(event_list, (departure_time, 1, event_id_counter))\n                event_id_counter += 1\n            else:\n                queue_length += 1\n            \n            # Fault f2: on k-th arrival, do not increment cumulative_arrivals\n            if not(f2 and arrival_handler_calls == k):\n                cumulative_arrivals += 1\n            \n            # Schedule the next arrival\n            if lam > 0:\n                interarrival_time = np.random.exponential(scale=1.0/lam)\n                next_arrival_time = current_time + interarrival_time\n                heapq.heappush(event_list, (next_arrival_time, 0, event_id_counter))\n                event_id_counter += 1\n\n        elif event_type_id == 1:  # Departure Event\n            departure_handler_calls += 1\n            cumulative_departures += 1\n\n            if queue_length > 0:\n                queue_length -= 1\n                # Server remains busy, start service for next in queue\n                service_time = np.random.exponential(scale=1.0/mu)\n                departure_time = current_time + service_time\n                heapq.heappush(event_list, (departure_time, 1, event_id_counter))\n                event_id_counter += 1\n            else:\n                server_busy = False\n\n        # --- Invariant Assertion ---\n        # The monitor checks the state, which may be maliciously altered.\n        q_for_check = queue_length\n\n        # Fault f1: On first departure, set Q(t) to -1 before check.\n        if f1 and event_type_id == 1 and departure_handler_calls == 1:\n            q_for_check = -1\n\n        # Invariant 1: Non-negativity of queue length, Q(t) >= 0.\n        if q_for_check  0:\n            violation_detected = True\n\n        # Invariant 2: Conservation of entities, S(t) + D(t) = A(t).\n        # S(t) is calculated based on the state visible to the monitor,\n        # which includes any faulted values.\n        # S(t) = Q(t) + B(t), where B(t) is 1 if server is busy, 0 otherwise.\n        s_for_check = q_for_check + (1 if server_busy else 0)\n        if s_for_check + cumulative_departures != cumulative_arrivals:\n            violation_detected = True\n\n        if violation_detected:\n            break\n\n    return violation_detected\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (lambda, mu, T_end, f1, f2, k)\n        (1.5, 2.0, 10.0, False, False, 3),  # Case 1: Happy path\n        (0.0, 1.0, 5.0, False, False, 3),   # Case 2: No arrivals\n        (10.0, 100.0, 1.0, False, False, 3),# Case 3: Fast service\n        (0.5, 0.5, 10.0, True, False, 3),   # Case 4: Negative queue fault\n        (2.0, 3.0, 10.0, False, True, 3)    # Case 5: Drop arrival fault\n    ]\n\n    results = []\n    for case in test_cases:\n        lam, mu, T_end, f1, f2, k = case\n        result = run_simulation(lam, mu, T_end, f1, f2, k)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3119919"}, {"introduction": "当用于分析那些难以用纯数学方法解决的复杂动态系统时，离散事件模拟的威力才能真正显现。这项高级实践将挑战你为一个服务速率依赖于系统状态、且到达过程由反馈控制器管理的系统进行建模。你的任务将超越模拟本身：你将扮演一名计算科学家的角色，通过分析输出数据来描述系统的动态行为，如稳定性和振荡，从而连接起模拟、控制理论和数据分析之间的桥梁。[@problem_id:3119911]", "problem": "对一个单服务台、先进先出 (FIFO) 队列进行离散事件模拟 (DES)，该队列具有状态依赖的服务和离散时间反馈准入控制。作业以候选 Poisson 过程的形式到达，基础速率为 $\\lambda_{\\text{base}}$（单位：$\\text{s}^{-1}$）。在时间 $t$ 的每个候选到达以概率 $u(t) \\in [0,1]$ 被接受，该概率由一个离散时间反馈控制器确定；否则，该到达被丢弃。令 $L(t)$ 表示在时间 $t$ 系统中的作业总数（包括任何正在接受服务的作业）。当服务台在系统处于水平 $L$ 时开始服务，服务时间服从指数分布，其速率为 $\\mu(L)$（单位：$\\text{s}^{-1}$），其中\n$$\n\\mu(L) = \\frac{\\mu_0}{1 + \\alpha \\max(L-1,0)}.\n$$\n一旦服务开始，采样的服务时间分布参数将保持固定直至服务完成，即使在此期间 $L$ 发生变化。控制器仅在离散的控制时刻 $t_n = n \\Delta_c$（对于整数 $n \\ge 1$）进行更新。准入概率 $u(t)$ 是分段常数，并在 $t_n$ 时刻通过以下公式更新\n$$\nu(t_n^+) = \\operatorname{clip}\\Big(1 - K_p\\big(L(t_n^-) - L_{\\text{ref}}\\big) - K_d \\frac{L(t_n^-)-L(t_{n-1}^-)}{\\Delta_c},\\, 0,\\, 1\\Big),\n$$\n其中 $t_n^-$ 表示控制更新前的瞬间，$\\operatorname{clip}(x,0,1)=\\min(\\max(x,0),1)$，$K_p \\ge 0$ 和 $K_d \\ge 0$ 是控制器增益，$L_{\\text{ref}}$ 是参考水平。在两次控制更新之间，$u(t)$ 是恒定的。候选到达由一个速率为 $\\lambda_{\\text{base}}$ 的齐次 Poisson 过程生成，并在到达时刻通过概率为 $u(t)$ 的 Bernoulli 接受进行筛选。下一个候选到达、下一个计划的服务完成或下一个控制更新中最早发生的一个将被作为下一个事件处理。事件时间的冲突应按以下优先级顺序解决：服务完成、控制更新、候选到达。时间单位为秒，速率单位为 $\\text{s}^{-1}$。\n\n您的任务是编写一个完整的程序，该程序：\n1) 实现上述的 DES，包括状态依赖的服务速率 $\\mu(L)$、用于 $u(t)$ 的离散时间反馈控制器，以及带筛选的 Poisson 候选到达。\n2) 在均匀时间网格上对 $L(t)$进行采样，以分析稳定性和振荡。令 $\\Delta_s$ 为采样步长，$T_{\\max}$ 为模拟时域。在所有满足 $0 \\le t_k \\le T_{\\max}$ 的整数 $k$ 的 $t_k = k \\Delta_s$ 时刻收集 $L(t)$ 的样本。丢弃时长为 $T_w$ 的预热期，并仅分析 $t_k \\ge T_w$ 的样本。\n3) 将每个参数集的行为分类为以下三个整数代码之一：\n- $0$：稳定且无显著振荡。\n- $1$：稳定但有振荡（有界，且具有显著的周期性分量）。\n- $2$：不稳定（向上发散）。\n\n分类必须基于应用于预热后样本的以下定量标准：\na) 线性趋势检验。对 $T_w$ 之后的采样数据 $(t,L(t))$ 拟合一条最小二乘直线 $L(t) \\approx a t + b$。如果拟合斜率 $a$ 满足 $a  \\theta_{\\text{up}}$，则分类为不稳定（$2$）。使用 $\\theta_{\\text{up}} = 5 \\times 10^{-3}$，单位为作业数/秒。\nb) 振荡检验。如果 $|a| \\le \\theta_{\\text{zero}}$（其中 $\\theta_{\\text{zero}} = 2 \\times 10^{-3}$），则计算去趋势且零均值的采样信号的离散傅里叶变换。令 $P(f)$ 表示频率 $f$ 处的周期图功率。令 $P_{\\text{total}}$ 为所有严格正频率上的功率总和，令 $P_{\\text{peak}}$ 为所有严格正频率上的最大功率。如果比率 $R = P_{\\text{peak}}/P_{\\text{total}}$ 满足 $R \\ge r_{\\text{crit}}$（其中 $r_{\\text{crit}} = 0.4$），并且零均值的去趋势信号至少有 $N_{\\text{zc}} \\ge 5$ 个过零点，则分类为振荡稳定（$1$）。否则，分类为稳定且无显著振荡（$0$）。\n如果 $|a| \\in (\\theta_{\\text{zero}}, \\theta_{\\text{up}}]$，则对去趋势残差使用振荡检验进行分类；如果 $R \\ge r_{\\text{crit}}$ 且 $N_{\\text{zc}} \\ge 5$，则报告为 $1$，否则为 $0$。\n为确保数值稳健性，如果去趋势的预热后样本的标准差小于 $s_{\\min} = 0.3$，则无论谱比率如何，均分类为 $0$。\n\n对所有随机性使用固定的伪随机种子 $s = 20240523$。服务台初始为空闲状态，即 $L(0)=0$。初始准入概率为 $u(0^+)=1$。\n\n测试套件。在以下四个参数集上运行您的程序；所有时间单位为秒，所有速率单位为 $\\text{s}^{-1}$：\n- 案例 A (负载不足，预期稳定): $(\\lambda_{\\text{base}}, \\mu_0, \\alpha, L_{\\text{ref}}, K_p, K_d, \\Delta_c, \\Delta_s, T_w, T_{\\max}) = (0.70, 1.50, 0.20, 5, 0.05, 0.00, 3.0, 0.5, 500, 2000)$。\n- 案例 B (高增益节流带延迟，预期振荡): $(\\lambda_{\\text{base}}, \\mu_0, \\alpha, L_{\\text{ref}}, K_p, K_d, \\Delta_c, \\Delta_s, T_w, T_{\\max}) = (1.50, 1.20, 0.30, 4, 0.70, 0.00, 8.0, 0.5, 500, 2000)$。\n- 案例 C (无控制下的过载，预期不稳定): $(\\lambda_{\\text{base}}, \\mu_0, \\alpha, L_{\\text{ref}}, K_p, K_d, \\Delta_c, \\Delta_s, T_w, T_{\\max}) = (1.80, 1.00, 0.10, 100, 0.00, 0.00, 5.0, 0.5, 500, 2000)$。\n- 案例 D (导数阻尼，预期稳定): $(\\lambda_{\\text{base}}, \\mu_0, \\alpha, L_{\\text{ref}}, K_p, K_d, \\Delta_c, \\Delta_s, T_w, T_{\\max}) = (1.10, 1.20, 0.40, 8, 0.30, 0.80, 4.0, 0.5, 500, 2000)$。\n\n最终输出格式。您的程序应生成单行输出，其中包含案例 A–D 的分类代码，形式为方括号内以逗号分隔的列表。例如，$[0,1,2,0]$ 这样的输出是有效的。不应打印任何其他文本。", "solution": "用户为带有离散时间反馈控制器的单服务台队列的离散事件模拟 (DES) 提供了一份详细的问题陈述。任务要求实现此模拟，分析队列长度的时间序列数据，并根据一套定量标准将系统行为分类为稳定、振荡或不稳定。\n\n### 问题验证\n\n**第 1 步：提取给定信息**\n\n- **系统**：单服务台 FIFO 队列。\n- **到达**：候选作业通过速率为 $\\lambda_{\\text{base}}$ 的 Poisson 过程到达。以概率 $u(t)$ 被接受。\n- **状态**：$L(t)$ 是系统中的作业数量。\n- **服务**：指数服务时间。当服务开始时有 $L$ 个作业，速率为 $\\mu(L) = \\frac{\\mu_0}{1 + \\alpha \\max(L-1,0)}$。服务时长一旦采样即固定。\n- **控制器**：在离散时间 $t_n = n \\Delta_c$（$n \\ge 1$）更新准入概率 $u(t)$。\n- **控制律**：$u(t_n^+) = \\operatorname{clip}\\Big(1 - K_p\\big(L(t_n^-) - L_{\\text{ref}}\\big) - K_d \\frac{L(t_n^-)-L(t_{n-1}^-)}{\\Delta_c},\\, 0,\\, 1\\Big)$。\n- **事件**：候选到达、服务完成、控制更新。\n- **事件时间冲突处理**：优先级：(1) 服务完成，(2) 控制更新，(3) 候选到达。\n- **初始条件**：$L(0)=0$；$u(0^+)=1$；服务台空闲。随机种子为 $s=20240523$。\n- **分析**：以 $\\Delta_s$ 为间隔对 $L(t)$ 进行采样，直至 $T_{\\max}$。分析 $t \\ge T_w$ 的样本。\n- **分类代码**：$0$（稳定，非振荡），$1$（稳定，振荡），$2$（不稳定）。\n- **不稳定性判据**：拟合直线 $L(t) \\approx at+b$。若斜率 $a  \\theta_{\\text{up}} = 5 \\times 10^{-3}$，则分类为 $2$。\n- **振荡判据**：对于未被分类为不稳定的情况，分析去趋势、零均值信号的周期图 $P(f)$。若 $P_{\\text{peak}}/P_{\\text{total}} \\ge r_{\\text{crit}}=0.4$ 且过零点数 $N_{\\text{zc}} \\ge 5$，则分类为 $1$。否则为 $0$。此判据适用于 $|a| \\le \\theta_{\\text{up}}$。\n- **稳健性判据**：若去趋势样本的标准差小于 $s_{\\min}=0.3$，则分类为 $0$。\n- **测试案例**：\n    - A: $(\\lambda_{\\text{base}}, \\mu_0, \\alpha, L_{\\text{ref}}, K_p, K_d, \\Delta_c, \\Delta_s, T_w, T_{\\max}) = (0.70, 1.50, 0.20, 5, 0.05, 0.00, 3.0, 0.5, 500, 2000)$。\n    - B: $(1.50, 1.20, 0.30, 4, 0.70, 0.00, 8.0, 0.5, 500, 2000)$。\n    - C: $(1.80, 1.00, 0.10, 100, 0.00, 0.00, 5.0, 0.5, 500, 2000)$。\n    - D: $(1.10, 1.20, 0.40, 8, 0.30, 0.80, 4.0, 0.5, 500, 2000)$。\n\n**第 2 步：使用提取的给定信息进行验证**\n\n- **科学依据**：该问题是排队论和控制系统中的一个标准练习，它将一个著名的类 M/M/1 队列与一个离散时间比例-微分 (PD) 控制器相结合。所有概念都是计算科学与工程的基础。\n- **适定性**：问题被精确地规定。所有参数、初始条件、模型动力学和分析标准都已明确定义。控制律在第一步（$t_1$）的微分项需要模拟开始前的一个时刻（$t_0=0$）的 $L$ 值。标准且逻辑的选择是 $L(t_0^-) = L(0) = 0$，这使得问题完全确定。时间冲突处理规则解决了事件调度中的任何歧义。\n- **客观性**：问题以客观、数学化的术语陈述，没有任何主观性。\n\n该问题是一个有效、自洽且不平凡的任务，它严格测试了与离散事件模拟相关的实现和分析技能。\n\n**第 3 步：结论与行动**\n\n问题是 **有效的**。将提供一个解决方案。\n\n### 解决方案设计\n\n解决方案将使用 Python 实现，并遵循指定的环境。对于每个测试案例，将执行以下步骤：\n\n1.  **初始化**：设置模拟状态变量（`time`、队列长度 `L`、准入概率 `u` 等）和事件调度表。为每个案例重新设置伪随机数生成器的种子，以确保独立和可复现的运行。\n2.  **离散事件模拟**：一个主循环将模拟时钟推进到下一个事件的发生时间。事件调度机制遵循指定的优先级规则。\n    - 事件由一个元组 `(time, priority, type)` 表示。优先级设置为整数：`1` 代表服务完成，`2` 代表控制更新，`3` 代表候选到达。对这些元组的列表使用 `min()` 函数可以正确选择下一个事件。\n    - **采样**：状态 `L(t)` 是分段常数。在模拟过程中，当时间从前一个事件 $t_{prev}$ 推进到当前事件 $t_{curr}$ 时，我们在所有位于区间 $[t_{prev}, t_{curr})$ 内的所需采样时刻 $t_k = k\\Delta_s$ 对 $L$ 的（恒定）值进行采样。\n    - **事件处理器**：\n        - **到达**：根据当前概率 $u$ 对候选到达进行筛选。如果被接受，$L$ 增加。如果系统之前是空闲的，则启动一次服务。\n        - **完成**：$L$ 减少。如果队列中仍有作业，则以由新队列长度决定的速率 $\\mu(L)$ 启动一次新服务。\n        - **控制更新**：根据当前队列长度 $L(t_n^-)$ 和前一个控制时刻的队列长度 $L(t_{n-1}^-)$，使用 PD 控制律重新计算准入概率 $u$。\n3.  **时间序列分析**：模拟完成后，根据指定的标准分析生成的 $L(t)$ 时间序列。\n    - **移除预热期**：丢弃在 $T_w$ 之前记录的样本。\n    - **线性回归**：使用 `numpy.polyfit` 对预热期后的数据 $(t, L(t))$ 拟合一条直线，以找到斜率 $a$。如果 $a  \\theta_{\\text{up}}$，则系统被分类为不稳定（$2$）。\n    - **去趋势与稳定性检查**：对信号进行去趋势处理。如果其标准差低于 $s_{\\min}$，则将其分类为稳定非振荡（$0$）。\n    - **频谱分析**：对于其他情况，使用 `scipy.fft.rfft` 计算零均值、去趋势信号的离散傅里叶变换。计算峰值功率与总功率（对于正频率）的比率 $R$。\n    - **过零点分析**：计算零均值、去趋势信号中的过零点数 $N_{\\text{zc}}$。\n    - **最终分类**：如果 $R \\ge r_{\\text{crit}}$ 且 $N_{\\text{zc}} \\ge 5$，则系统被分类为振荡（$1$）；否则，为稳定非振荡（$0$）。\n\n这种结构化的方法确保了问题陈述的所有要求都得到精确满足。", "answer": "```python\nimport numpy as np\nfrom scipy.fft import rfft\n\ndef solve():\n    \"\"\"\n    Main function to run simulations for all test cases and print results.\n    \"\"\"\n    # Test suite: (lambda_base, mu_0, alpha, L_ref, K_p, K_d, Delta_c, Delta_s, T_w, T_max)\n    test_cases = [\n        # Case A\n        (0.70, 1.50, 0.20, 5, 0.05, 0.00, 3.0, 0.5, 500, 2000),\n        # Case B\n        (1.50, 1.20, 0.30, 4, 0.70, 0.00, 8.0, 0.5, 500, 2000),\n        # Case C\n        (1.80, 1.00, 0.10, 100, 0.00, 0.00, 5.0, 0.5, 500, 2000),\n        # Case D\n        (1.10, 1.20, 0.40, 8, 0.30, 0.80, 4.0, 0.5, 500, 2000),\n    ]\n\n    # Analysis parameters\n    analysis_params = {\n        'theta_up': 5e-3,\n        'r_crit': 0.4,\n        'N_zc_min': 5,\n        's_min': 0.3,\n        'theta_zero': 2e-3 # As defined in the problem description text\n    }\n\n    # Seed for reproducibility\n    seed = 20240523\n\n    results = []\n    for params in test_cases:\n        # Run simulation and analysis for one case\n        code = run_and_analyze_case(params, seed, analysis_params)\n        results.append(code)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef run_and_analyze_case(params, seed, analysis_params):\n    \"\"\"\n    Handles the simulation and analysis for a single parameter set.\n    \"\"\"\n    # 1. Unpack parameters and initialize simulation\n    lambda_base, mu_0, alpha, L_ref, K_p, K_d, Delta_c, Delta_s, T_w, T_max = params\n    \n    rng = np.random.default_rng(seed)\n\n    # State variables\n    time = 0.0\n    L = 0\n    u = 1.0\n    L_prev_control = 0.0 # L(t_{n-1}^-), initialized to L(0)\n\n    # Event schedule\n    t_arrival = rng.exponential(scale=1.0/lambda_base)\n    t_completion = float('inf')\n    t_control = Delta_c\n\n    # Sampling data storage\n    samples_t = []\n    samples_L = []\n    t_sample_next = 0.0\n\n    # 2. Discrete Event Simulation loop\n    while time = T_max:\n        # Event list with priorities: 1=completion, 2=control, 3=arrival\n        events = [\n            (t_completion, 1, 'completion'),\n            (t_control, 2, 'control'),\n            (t_arrival, 3, 'arrival')\n        ]\n        \n        t_next, _, event_type = min(events)\n        \n        # Sample L(t) in the interval [time, t_next)\n        while t_sample_next  t_next and t_sample_next = T_max:\n            samples_t.append(t_sample_next)\n            samples_L.append(L)\n            t_sample_next += Delta_s\n            \n        time = t_next\n        if time > T_max:\n            break\n\n        # Process the chosen event\n        if event_type == 'arrival':\n            t_arrival = time + rng.exponential(scale=1.0/lambda_base)\n            if rng.random()  u: # Thinning\n                if L == 0:\n                    L += 1\n                    current_mu = mu_0 / (1.0 + alpha * max(L - 1, 0))\n                    service_time = rng.exponential(scale=1.0/current_mu)\n                    t_completion = time + service_time\n                else:\n                    L += 1\n        \n        elif event_type == 'completion':\n            L -= 1\n            if L > 0:\n                current_mu = mu_0 / (1.0 + alpha * max(L - 1, 0))\n                service_time = rng.exponential(scale=1.0/current_mu)\n                t_completion = time + service_time\n            else:\n                t_completion = float('inf')\n\n        elif event_type == 'control':\n            p_err = L - L_ref\n            d_err = (L - L_prev_control) / Delta_c\n            u_raw = 1.0 - K_p * p_err - K_d * d_err\n            u = np.clip(u_raw, 0.0, 1.0)\n            \n            L_prev_control = L\n            t_control += Delta_c\n            \n    ts = np.array(samples_t)\n    Ls = np.array(samples_L)\n\n    # 3. Analyze trajectory\n    \n    # Filter for post-warm-up period\n    post_warmup_indices = ts >= T_w\n    t_ana = ts[post_warmup_indices]\n    L_ana = Ls[post_warmup_indices]\n    \n    if len(t_ana)  2: return 0 \n\n    # Linear trend test\n    slope, intercept = np.polyfit(t_ana, L_ana, 1)\n\n    if slope > analysis_params['theta_up']:\n        return 2\n\n    # Detrend signal\n    L_detrended = L_ana - (slope * t_ana + intercept)\n\n    # Small standard deviation check\n    if np.std(L_detrended)  analysis_params['s_min']:\n        return 0\n\n    # Oscillation test\n    L_fft_signal = L_detrended - np.mean(L_detrended)\n    \n    if np.allclose(L_fft_signal, 0): # Constant signal, no oscillations\n        return 0\n\n    # Compute periodogram\n    power = np.abs(rfft(L_fft_signal)[1:])**2\n    \n    if power.size == 0: return 0\n    P_total = np.sum(power)\n    if P_total == 0: return 0\n        \n    P_peak = np.max(power)\n    R = P_peak / P_total\n    \n    # Count zero crossings (robustly for float data)\n    N_zc = np.sum((L_fft_signal[:-1] * L_fft_signal[1:])  0)\n\n    if R >= analysis_params['r_crit'] and N_zc >= analysis_params['N_zc_min']:\n        return 1\n    else:\n        return 0\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3119911"}]}