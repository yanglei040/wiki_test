{"hands_on_practices": [{"introduction": "本练习旨在通过逆变换采样的一个基本应用，提供实践机会。通过处理定义在有限区间上的三角分布（一种简单但非均匀的分布），你将掌握从分段概率密度函数（PDF）推导累积分布函数（CDF）并将其反转以创建采样器的核心步骤。这个过程将为你处理更复杂的分布打下坚实的基础。", "problem": "要求您为一个具有有限支撑的三角概率分布实现逆变换采样。三角分布由三个实数参数 $a$、$c$ 和 $b$ 定义，其中 $a  b$ 且 $a \\le c \\le b$，$a$ 是左端点，$b$ 是右端点，$c$ 是众数（峰值位置）。其概率密度函数在 $[a, c]$ 和 $[c, b]$ 上是连续的分段线性函数，在 $[a, b]$ 之外为零。您的任务是从第一性原理出发推导采样器，并将其实现为一个程序。\n\n基本原理：\n- 概率密度函数 (PDF)：一个非负函数 $f(x)$，其在其支撑上的积分为 $1$。\n- 累积分布函数 (CDF)：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- 逆变换采样：如果 $U$ 是一个在 $[0,1]$上均匀分布的随机变量，且 $F$ 是一个连续、严格递增的 CDF，那么 $X = F^{-1}(U)$ 的 CDF 为 $F$。\n\n要求：\n1) 仅从上述定义出发，推导在 $[a, c, b]$ 上的三角分布的分段 CDF $F(x)$，并对其进行解析求逆，以获得对于 $u \\in [0,1]$ 的分位数函数 $F^{-1}(u)$。确保您的推导涵盖一般情况 $a  c  b$，并能正确处理极限情况 $c = a$ 和 $c = b$。\n\n2) 实现一个程序，在给定 $(a, c, b)$ 和一个包含多个 $u$ 值（每个 $u \\in [0,1]$）的列表时，使用您推导出的逆函数返回相应的样本 $x = F^{-1}(u)$。您必须处理以下细节：\n- 为保证数值鲁棒性，在应用逆函数之前，将每个 $u$ 的值限制在 $[0,1]$ 区间内。\n- 您的实现必须在 $c = a$ 和 $c = b$ 的情况下正常工作，无除零或无效分支问题。\n- 对于每个计算出的样本，将结果四舍五入到10位小数。\n\n3) 您不得依赖任何库中预打包的三角分布。您可以使用允许的库中的基本数值运算，但采样器必须直接实现您推导出的逆函数。\n\n此挑战的输入和输出是固定的；没有用户输入。您的程序必须在给定的参数集和 $u$ 值（见下文测试套件）下评估逆函数，并打印包含所有结果的单行输出。\n\n测试套件：\n- 情况1（一般“正常路径”）：$(a, c, b) = (0, 2, 5)$，u值为 $[0, 0.1, 0.4, 0.5, 0.9, 1]$。\n- 情况2（边界情况 $c = a$）：$(a, c, b) = (3, 3, 7)$，u值为 $[0, 0.25, 0.999999, 1]$。\n- 情况3（边界情况 $c = b$）：$(a, c, b) = (-2, 1, 1)$，u值为 $[0, 0.25, 0.8, 1]$。\n- 情况4（边界鲁棒性）：$(a, c, b) = (0, 1, 2)$，u值为 $[0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，每个测试用例贡献一个四舍五入样本的列表。具体来说，输出必须是形如\n$[[x_{1,1},x_{1,2},\\dots],[x_{2,1},\\dots],[x_{3,1},\\dots],[x_{4,1},\\dots]]$\n的单行字符串，不含空格。每个 $x_{i,j}$ 都必须是四舍五入到10位小数的浮点数。\n- 本问题不涉及物理单位；所有量均为无量纲实数。", "solution": "用户提供了一个问题陈述。我将首先对其进行验证。\n\n### 第1步：提取已知信息\n- **分布**：三角概率分布。\n- **参数**：实数 $a$、$c$、$b$ 满足 $a  b$ 且 $a \\le c \\le b$。$a$ 是最小值，$b$ 是最大值，$c$ 是众数。\n- **概率密度函数 (PDF)**：$f(x)$ 是连续的、分段线性的，支撑集为 $[a, b]$。\n- **累积分布函数 (CDF)**：$F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(t)\\, dt$。\n- **核心任务**：使用逆变换采样，从均匀随机变量 $U \\sim \\text{Uniform}[0,1]$ 生成样本 $X$，$X = F^{-1}(U)$。\n- **推导要求**：从第一性原理出发，推导分段 CDF $F(x)$ 及其逆函数，即分位数函数 $F^{-1}(u)$。推导必须覆盖一般情况 $a  c  b$ 和极限情况 $c = a$ 和 $c = b$。\n- **实现要求**：\n    1. 实现推导出的 $F^{-1}(u)$ 函数。\n    2. 不要使用库中预打包的三角分布函数。\n    3. 输入的 $u$ 值必须被限制在区间 $[0,1]$ 内。\n    4. 实现必须能正确处理 $c=a$ 和 $c=b$ 的情况。\n    5. 输出样本必须四舍五入到10位小数。\n- **测试套件**：\n    - 情况1：$(a, c, b) = (0, 2, 5)$，$u = [0, 0.1, 0.4, 0.5, 0.9, 1]$。\n    - 情况2：$(a, c, b) = (3, 3, 7)$，$u = [0, 0.25, 0.999999, 1]$。\n    - 情况3：$(a, c, b) = (-2, 1, 1)$，$u = [0, 0.25, 0.8, 1]$。\n    - 情况4：$(a, c, b) = (0, 1, 2)$，$u = [0, 10^{-12}, 0.5, 1 - 10^{-12}, 1]$。\n- **输出格式**：一个表示结果列表的列表的单行字符串，不含空格：`[[...],[...],[...],[...]]`。\n\n### 第2步：使用提取的已知信息进行验证\n- **科学依据**：该问题基于概率论（PDF、CDF）和计算统计学（逆变换采样）的基本、公认原理。三角分布是一个标准的、无争议的概率分布。此标准已满足。\n- **问题定义明确**：该问题提供了所有必要的定义、约束（$a  b$, $a \\le c \\le b$）和明确的目标。CDF 及其逆函数（对于连续、严格递增的函数）的存在性和唯一性由数学原保证。此标准已满足。\n- **客观性**：问题以精确的数学语言陈述，没有任何主观性或歧义。此标准已满足。\n- **缺陷检查**：问题不违反任何科学定律，是可形式化的、完整的和可验证的。约束条件一致，所需任务定义明确。\n\n### 第3步：结论与行动\n问题陈述是**有效**的。我将继续进行推导和求解。\n\n任务是推导三角分布的分位数函数并加以实现。这分三个阶段进行：首先，定义概率密度函数 (PDF)；其次，对 PDF 进行积分以求得累积分布函数 (CDF)；第三，对 CDF 求逆以获得分位数函数 $F^{-1}(u)$。\n\n**1. 概率密度函数 (PDF), $f(x)$**\n\nPDF $f(x)$ 描述了一个顶点位于 $(a, 0)$、$(c, h)$ 和 $(b, 0)$ 的三角形，其中 $h$ 是三角形的高度。PDF 下的总面积必须为 $1$。三角形的面积由 $\\frac{1}{2} \\times \\text{底} \\times \\text{高}$ 给出。\n$$\n\\text{面积} = \\frac{1}{2} (b-a) h = 1 \\implies h = \\frac{2}{b-a}\n$$\nPDF 是一个分段线性函数。\n对于 $a \\le x \\le c$，该线段穿过 $(a, 0)$ 和 $(c, h)$。其方程为：\n$$\nf(x) = \\frac{h-0}{c-a} (x-a) = \\frac{2(x-a)}{(b-a)(c-a)}\n$$\n对于 $c  x \\le b$，该线段穿过 $(c, h)$ 和 $(b, 0)$。其方程为：\n$$\nf(x) = h + \\frac{0-h}{b-c} (x-c) = \\frac{2}{b-a} - \\frac{2(x-c)}{(b-a)(b-c)} = \\frac{2(b-c) - 2(x-c)}{(b-a)(b-c)} = \\frac{2(b-x)}{(b-a)(b-c)}\n$$\n结合这些，PDF 为：\n$$\nf(x) = \\begin{cases}\n\\frac{2(x-a)}{(b-a)(c-a)}  \\text{if } a \\le x \\le c \\\\\n\\frac{2(b-x)}{(b-a)(b-c)}  \\text{if } c  x \\le b \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n这些表达式是在假设 $a  c  b$ 的情况下定义的。我们将看到，最终的分位数函数能正确处理 $c=a$ 和 $c=b$ 的边界情况。\n\n**2. 累积分布函数 (CDF), $F(x)$**\n\nCDF 是 PDF 的积分，即 $F(x) = \\int_{a}^{x} f(t) \\,dt$。\n对于 $x  a$，$F(x)=0$。对于 $x > b$，$F(x)=1$。\n\n对于 $a \\le x \\le c$：\n$$\nF(x) = \\int_{a}^{x} \\frac{2(t-a)}{(b-a)(c-a)} \\,dt = \\frac{2}{(b-a)(c-a)} \\left[ \\frac{(t-a)^2}{2} \\right]_{a}^{x} = \\frac{(x-a)^2}{(b-a)(c-a)}\n$$\n在众数 $c$ 处，CDF 的值为 $F(c) = \\frac{(c-a)^2}{(b-a)(c-a)} = \\frac{c-a}{b-a}$。这个值是在区间 $[a, c]$ 内的总概率质量。\n\n对于 $c  x \\le b$：\n$$\nF(x) = F(c) + \\int_{c}^{x} \\frac{2(b-t)}{(b-a)(b-c)} \\,dt \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{2}{(b-a)(b-c)} \\left[ -\\frac{(b-t)^2}{2} \\right]_{c}^{x} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{-(b-x)^2 - (-(b-c)^2)}{(b-a)(b-c)} \\\\\nF(x) = \\frac{c-a}{b-a} + \\frac{(b-c)^2 - (b-x)^2}{(b-a)(b-c)}\n$$\n通过化简可以得到一个更优雅的形式：\n$$\nF(x) = \\frac{(c-a)(b-c) + (b-c)^2 - (b-x)^2}{(b-a)(b-c)} = \\frac{(b-c)(c-a+b-c) - (b-x)^2}{(b-a)(b-c)} \\\\\nF(x) = \\frac{(b-c)(b-a) - (b-x)^2}{(b-a)(b-c)} = 1 - \\frac{(b-x)^2}{(b-a)(b-c)}\n$$\n所以，完整的 CDF 为：\n$$\nF(x) = \\begin{cases}\n0  \\text{if } x  a \\\\\n\\frac{(x-a)^2}{(b-a)(c-a)}  \\text{if } a \\le x \\le c \\\\\n1 - \\frac{(b-x)^2}{(b-a)(b-c)}  \\text{if } c  x \\le b \\\\\n1  \\text{if } x > b\n\\end{cases}\n$$\n\n**3. 逆 CDF (分位数函数), $F^{-1}(u)$**\n\n为实现逆变换采样，我们必须从方程 $u = F(x)$ 中解出 $x$，其中 $u \\in [0, 1]$。\n逆函数的形式取决于 $u$ 是落在对应于 $x \\le c$ 的范围内还是 $x > c$ 的范围内。分离这两种情况的 $u$ 的临界值是 $u_c = F(c) = \\frac{c-a}{b-a}$。\n\n情况1：$0 \\le u \\le u_c$（对应于 $a \\le x \\le c$）\n$$\nu = \\frac{(x-a)^2}{(b-a)(c-a)} \\\\\n(x-a)^2 = u(b-a)(c-a) \\\\\nx-a = \\sqrt{u(b-a)(c-a)} \\quad (\\text{因为 } x \\ge a \\text{，取正根}) \\\\\nx = a + \\sqrt{u(b-a)(c-a)}\n$$\n\n情况2：$u_c  u \\le 1$（对应于 $c  x \\le b$）\n$$\nu = 1 - \\frac{(b-x)^2}{(b-a)(b-c)} \\\\\n(b-x)^2 = (1-u)(b-a)(b-c) \\\\\nb-x = \\sqrt{(1-u)(b-a)(b-c)} \\quad (\\text{因为 } x \\le b \\text{，取正根}) \\\\\nx = b - \\sqrt{(1-u)(b-a)(b-c)}\n$$\n\n最终得到的分位数函数 $F^{-1}(u)$ 是：\n$$\nF^{-1}(u) = \\begin{cases}\na + \\sqrt{u (b-a) (c-a)}  \\text{if } 0 \\le u \\le \\frac{c-a}{b-a} \\\\\nb - \\sqrt{(1-u) (b-a) (b-c)}  \\text{if } \\frac{c-a}{b-a}  u \\le 1\n\\end{cases}\n$$\n这个单一、统一的公式是鲁棒的，并且能正确处理边界情况。\n- 如果 $c=a$，那么 $u_c = \\frac{c-a}{b-a} = 0$。条件 $0 \\le u \\le 0$ 仅对 $u=0$ 成立。对于任何 $u > 0$，使用第二个分支：$x = b - \\sqrt{(1-u) (b-a) (b-a)} = b - (b-a)\\sqrt{1-u}$。这对应于一个峰值在 $a$ 处的直角三角形。\n- 如果 $c=b$，那么 $u_c = \\frac{c-a}{b-a} = 1$。条件 $0 \\le u \\le 1$ 对所有 $u$ 都成立，因此始终使用第一个分支：$x = a + \\sqrt{u (b-a) (b-a)} = a + (b-a)\\sqrt{u}$。这对应于一个峰值在 $b$ 处的直角三角形。\n\n推导完成且合理。实现将遵循此最终公式。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and implements the inverse transform sampling for a triangular distribution.\n    The final output is printed in the exact required format.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: General case\n        {'params': (0, 2, 5), 'u_values': [0, 0.1, 0.4, 0.5, 0.9, 1]},\n        # Case 2: Edge case c = a\n        {'params': (3, 3, 7), 'u_values': [0, 0.25, 0.999999, 1]},\n        # Case 3: Edge case c = b\n        {'params': (-2, 1, 1), 'u_values': [0, 0.25, 0.8, 1]},\n        # Case 4: Boundary robustness\n        {'params': (0, 1, 2), 'u_values': [0, 10**-12, 0.5, 1 - 10**-12, 1]},\n    ]\n    \n    all_results = []\n\n    for case in test_cases:\n        a, c, b = case['params']\n        u_values = case['u_values']\n        \n        case_results = []\n        \n        # Pre-calculate terms for efficiency and clarity\n        # The problem states a  b, so b - a > 0 is guaranteed.\n        range_ab = b - a\n        range_ac = c - a\n        range_cb = b - c\n        \n        # Calculate the CDF value at the mode, which is the threshold for u\n        # This handles the case where b-a might equal 0 if the problem constraints were different,\n        # but here it's safe.\n        if range_ab == 0:\n            # Degenerate case, not covered by problem statement a  b\n            # but good practice for robustness. All samples are at 'a'.\n            fc = 0.5 # A reasonable default.\n        else:\n            fc = range_ac / range_ab\n        \n        for u in u_values:\n            # Per requirement, clamp u into [0, 1] for numerical robustness.\n            u_clamped = max(0.0, min(1.0, u))\n            \n            x = 0.0\n            # The logic directly implements the derived piecewise inverse CDF.\n            # The comparison u_clamped = fc correctly selects the formula branch,\n            # naturally handling the edge cases c=a (fc=0) and c=b (fc=1).\n            if u_clamped = fc:\n                # This branch corresponds to the interval [a, c]\n                # x = a + sqrt(u * (b-a) * (c-a))\n                term = u_clamped * range_ab * range_ac\n                x = a + np.sqrt(term)\n            else:\n                # This branch corresponds to the interval (c, b]\n                # x = b - sqrt((1-u) * (b-a) * (b-c))\n                term = (1 - u_clamped) * range_ab * range_cb\n                x = b - np.sqrt(term)\n            \n            # Round the result to 10 decimal places as required.\n            case_results.append(round(x, 10))\n            \n        all_results.append(case_results)\n\n    # Format the final output string to the exact required format.\n    # e.g., [[x11,x12,...],[x21,...],[x31,...],[x41,...]] with no spaces.\n    # Convert list of lists to string and remove whitespace.\n    output_string = str(all_results).replace(\" \", \"\")\n    \n    print(output_string)\n\nsolve()\n```", "id": "2403851"}, {"introduction": "在基础之上，本练习将该方法扩展到拉普拉斯分布，该分布定义在无限域上，在稳健统计学中非常重要。你将为这个对称的双指数分布推导其逆CDF，并特别关注由绝对值函数引起的分段特性。本练习还强调了在实现采样器时，对数值稳定性的实际需求。", "problem": "您需要实现逆变换采样方法，以在高等本科水平上从拉普拉斯（双指数）分布生成独立的随机变量。您的推导和算法必须从概率密度函数和累积分布函数的基本定义以及一个经过充分检验的事实开始：即通过逆累积分布函数变换一个均匀随机变量会产生目标分布的一个样本。具体来说，您必须基于以下基础：如果 $U$ 是一个在 $(0,1)$ 上均匀分布的连续随机变量，而 $F_X$ 是一个连续随机变量 $X$ 的累积分布函数，那么 $F_X(X)$ 在 $(0,1)$ 上均匀分布，反之，$X = F_X^{-1}(U)$ 的累积分布函数为 $F_X$。您不得假定任何针对拉普拉斯分布预先推導出的公式；必须从拉普拉斯概率密度函数出发，通过正确的分段积分和求逆来推导它们。\n\n任务：\n- 仅使用上述基本定义和事实，推导拉普拉斯（双指数）分布的逆累积分布函数，该函数的位置参数为 $\\mu$，尺度参数为 $b$，并完全用 $\\mu$、$b$ 和 $U$ 表示。\n- 设计并实现一个数值稳定的逆变换采样程序，在给定 $\\mu$、$b$、一个正整数 $n$ 和一个整数随机种子 $\\text{seed}$ 的情况下，生成 $n$ 个来自拉普拉斯分布的独立样本。您必须确保在边界 $0$ 和 $1$ 处的均匀值的映射不会产生非有限输出；解释并实现一种符合浮点算术的原则性方法来避免此类边界问题。\n- 对于随机抽样测试用例，计算并返回所生成样本的样本均值、总体方差（即除以 $n$ 而不是 $n-1$）和样本中位数。\n- 对于确定性映射测试用例，直接在指定的均匀值处评估逆累积分布函数，并返回映射后的值。\n\n约束条件：\n- 使用参数为 $\\mu$ 和 $b$（其中 $b>0$）的拉普拉斯概率密度函数。不要使用来自外部库的任何专门的分布例程；您的实现必须基于推导出的逆累积分布函数和均匀随机数生成器。\n- 程序应自成一体，无需用户输入，且仅使用 Python 标准库和指定的数值库。\n- 不涉及角度；不需要角度单位。不涉及物理量；不需要物理单位。\n- 所有输出必须表示为十进制浮点数。\n\n测试套件：\n为以下测试用G例提供结果：\n1. 随机生成（理想路径）：$\\mu = 0$，$b = 1$，$n = 100000$，$\\text{seed} = 314159$。\n2. 随机生成（平移且尺度更窄）：$\\mu = 2.5$，$b = 0.5$，$n = 50000$，$\\text{seed} = 271828$。\n3. 随机生成（边缘尺度，极小）：$\\mu = -3$，$b = 10^{-6}$，$n = 3$，$\\text{seed} = 99$。\n4. 确定性映射（逆映射的边界压力测试）：$\\mu = 1$，$b = 2$，在均匀值 $[10^{-12}, 0.5, 1 - 10^{-12}]$ 处进行评估。\n\n答案规范：\n- 对于前三个测试用例，输出一个包含三个浮点数的列表，按顺序代表所生成样本的 $[\\text{均值}, \\text{方差}, \\text{中位数}]$。\n- 对于第四个测试用例，输出一个包含三个浮点数的列表，代表指定均匀输入在逆累积分布函数下的映射值。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[result1,result2,result3]$），其中每个 $resultk$ 都符合上述规范。因此，这四个测试用例的聚合格式必须是一个包含四个元素的顶级列表，其中前三个元素是各含三个浮点数的列表，第四个元素是一个包含三个浮点数的列表。", "solution": "使用逆变换采样从拉普拉斯分布生成随机变量是数值方法中一个适定问题。它要求从第一性原理严格推导逆累积分布函数，然后进行数值上稳健的实现。\n\n### 步骤 1：拉普拉斯累积分布函数（CDF）的推导\n\n该过程始于位置参数为 $\\mu$、尺度参数为 $b > 0$ 的拉普拉斯分布随机变量 $X$ 的概率密度函数（PDF）。PDF 由下式给出：\n$$f_X(x; \\mu, b) = \\frac{1}{2b} \\exp\\left(-\\frac{|x-\\mu|}{b}\\right)$$\n累积分布函数（CDF），即 $F_X(x) = P(X \\le x)$，通过将 PDF 从 $-\\infty$ 积分到 $x$ 得到：\n$$F_X(x) = \\int_{-\\infty}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{|t-\\mu|}{b}\\right) dt$$\n由于存在绝对值项 $|t-\\mu|$，该积分必须分段计算。\n\n**情况 1：$x \\le \\mu$**\n对于积分范围 $(-\\infty, x]$ 中的任何 $t$，我们有 $t \\le x \\le \\mu$，这意味着 $t-\\mu \\le 0$。因此，$|t-\\mu| = -(t-\\mu) = \\mu-t$。CDF 为：\n$$F_X(x) = \\int_{-\\infty}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{\\mu-t}{b}\\right) dt = \\frac{1}{2b} \\int_{-\\infty}^{x} \\exp\\left(\\frac{t-\\mu}{b}\\right) dt$$\n执行积分：\n$$F_X(x) = \\frac{1}{2b} \\left[ b \\exp\\left(\\frac{t-\\mu}{b}\\right) \\right]_{-\\infty}^{x} = \\frac{1}{2} \\left( \\exp\\left(\\frac{x-\\mu}{b}\\right) - \\lim_{t\\to-\\infty} \\exp\\left(\\frac{t-\\mu}{b}\\right) \\right)$$\n$$F_X(x) = \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n\n**情况 2：$x > \\mu$**\n积分在点 $t=\\mu$ 处分开：\n$$F_X(x) = \\int_{-\\infty}^{\\mu} f_X(t) dt + \\int_{\\mu}^{x} f_X(t) dt$$\n第一项是 $F_X(\\mu)$，可以从情况 1 的结果中找到：$F_X(\\mu) = \\frac{1}{2} \\exp\\left(\\frac{\\mu-\\mu}{b}\\right) = \\frac{1}{2}$。这是符合预期的，因为该分布关于其中位数 $\\mu$ 是对称的。\n对于第二项，其中 $t \\in [\\mu, x]$，我们有 $t-\\mu \\ge 0$，所以 $|t-\\mu| = t-\\mu$。\n$$\\int_{\\mu}^{x} \\frac{1}{2b} \\exp\\left(-\\frac{t-\\mu}{b}\\right) dt = \\frac{1}{2b} \\left[ -b \\exp\\left(-\\frac{t-\\mu}{b}\\right) \\right]_{\\mu}^{x}$$\n$$= -\\frac{1}{2} \\left[ \\exp\\left(-\\frac{x-\\mu}{b}\\right) - \\exp\\left(-\\frac{\\mu-\\mu}{b}\\right) \\right] = -\\frac{1}{2} \\left(\\exp\\left(-\\frac{x-\\mu}{b}\\right) - 1\\right) = \\frac{1}{2} \\left(1 - \\exp\\left(-\\frac{x-\\mu}{b}\\right)\\right)$$\n合并 $x > \\mu$ 的两项：\n$$F_X(x) = F_X(\\mu) + \\frac{1}{2} \\left(1 - \\exp\\left(-\\frac{x-\\mu}{b}\\right)\\right) = \\frac{1}{2} + \\frac{1}{2} - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right) = 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n\n完整的分段 CDF 为：\n$$F_X(x) = \\begin{cases} \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)  \\text{if } x \\le \\mu \\\\ 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)  \\text{if } x > \\mu \\end{cases}$$\n\n### 步骤 2：逆 CDF（分位数函数）的推导\n\n逆变换采样方法依赖于这样一个事实：如果 $U$ 是一个在 $(0,1)$ 上均匀分布的随机变量，那么 $X = F_X^{-1}(U)$ 就是一个 CDF 为 $F_X$ 的随机变量。为了求得逆 CDF，我们对 $u \\in (0,1)$ 设 $u = F_X(x)$，然后解出 $x$。\n\n**情况 1：$0  u \\le 0.5$（对应于 $x \\le \\mu$）**\n$$u = \\frac{1}{2} \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n$$2u = \\exp\\left(\\frac{x-\\mu}{b}\\right)$$\n$$\\ln(2u) = \\frac{x-\\mu}{b}$$\n$$x = \\mu + b \\ln(2u)$$\n\n**情况 2：$0.5  u  1$（对应于 $x > \\mu$）**\n$$u = 1 - \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$1-u = \\frac{1}{2} \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$2(1-u) = \\exp\\left(-\\frac{x-\\mu}{b}\\right)$$\n$$\\ln(2(1-u)) = -\\frac{x-\\mu}{b}$$\n$$x = \\mu - b \\ln(2(1-u))$$\n\n完整的分段逆 CDF，$x = F_X^{-1}(u)$，为：\n$$F_X^{-1}(u) = \\begin{cases} \\mu + b \\ln(2u)  \\text{if } 0  u \\le 0.5 \\\\ \\mu - b \\ln(2(1-u))  \\text{if } 0.5  u  1 \\end{cases}$$\n\n### 步骤 3：算法设计与数值稳定性\n\n推导出的逆 CDF 包含对数项 $\\ln(u)$ 和 $\\ln(1-u)$，它们分别在 $u=0$ 和 $u=1$ 处是奇异的。理论逆 CDF 的定义域严格来说是开区间 $(0,1)$。然而，数值随机数生成器可能在闭区间或半闭区间（如 $[0,1)$）上运行，可能产生值 $0$。直接在 $u=0$ 处求值将导致 $\\ln(0)$，这是一个非有限值 $(-\\infty)$，违反了问题对有限输出的要求。\n\n为了创建一个数值稳定的实现，我们必须采用一种原则性方法来处理这些边界值。对于连续分布，浮点生成器产生精确的 $0.0$ 是一种数值假象。我们将此值解释为代表一个属于最小可表示正区间 $[0, \\epsilon_{\\text{min}})$ 的样本，其中 $\\epsilon_{\\text{min}}$ 是给定浮点类型的最小正规格化数。为确保有限输出，我们将任何输入 $u=0$ 映射到 $\\epsilon_{\\text{min}}$。这一正则化步骤保证了对数的参数始终为正，从而正确地产生一个大数量级的有限数，代表分布的尾部行为。`numpy.finfo` 实用程序提供了一种获取此机器 epsilon 的标准方法。测试用例不涉及精确为 $u=1$ 的输入，但类似的正则化方法也同样适用。\n\n算法如下：\n1.  对于给定的测试用例，定义参数 $\\mu$、$b$，对于随机情况，还需定义 $n$ 和 `seed`。\n2.  生成一个包含 $n$ 个在 $[0,1)$ 上均匀分布的随机数 $u_i$ 的数组，或使用提供的确定性值。\n3.  正则化均匀值：将任何精确为 $0$ 的 $u_i$ 替换为最小的可表示正浮点数。\n4.  使用布尔掩码以矢量化的方式应用分段逆 CDF 公式：\n    -   对于所有 $u_i \\le 0.5$，计算 $x_i = \\mu + b \\ln(2u_i)$。\n    -   对于所有 $u_i > 0.5$，计算 $x_i = \\mu - b \\ln(2(1-u_i))$。\n5.  对于随机生成情况，计算所得样本 $x_i$ 的样本均值、总体方差（除以 $n$）和样本中位数。\n6.  对于确定性映射情况，返回计算出的 $x_i$ 值。\n7.  按规定格式化所有结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by deriving and implementing inverse transform sampling\n    for the Laplace distribution, handling all specified test cases.\n    \"\"\"\n\n    def inverse_cdf_laplace(u, mu, b):\n        \"\"\"\n        Calculates samples from a Laplace distribution using the inverse CDF method.\n\n        This function implements the derived piecewise inverse CDF:\n        x = mu + b * log(2u)          if 0  u = 0.5\n        x = mu - b * log(2(1-u))        if 0.5  u  1\n\n        It includes a principled approach to handle boundary values of u to\n        ensure numerically stable, finite outputs.\n\n        Args:\n            u (np.ndarray): Array of uniform random numbers in [0, 1).\n            mu (float): The location parameter of the Laplace distribution.\n            b (float): The scale parameter (b > 0) of the Laplace distribution.\n\n        Returns:\n            np.ndarray: Array of samples from the Laplace(mu, b) distribution.\n        \"\"\"\n        # Copy input to avoid modifying the original array\n        u_reg = np.copy(u).astype(np.float64)\n\n        # The theoretical domain of the inverse CDF is (0,1). Practical RNGs\n        # may produce 0 from the interval [0,1). We regularize such values to\n        # prevent log(0) which results in a non-finite output. A value of 0.0\n        # is mapped to the smallest positive representable float (machine epsilon),\n        # ensuring the logarithm's argument is always positive.\n        tiny = np.finfo(u_reg.dtype).tiny\n        u_reg[u_reg == 0] = tiny\n        \n        # The test cases do not include u=1, but a robust implementation would\n        # also regularize it. e.g., u_reg[u_reg == 1] = 1.0 - tiny\n\n        # Initialize the output array for samples\n        samples = np.zeros_like(u_reg)\n\n        # Create a boolean mask to apply the piecewise function\n        mask_le_half = (u_reg = 0.5)\n        \n        # Branch 1: u = 0.5\n        samples[mask_le_half] = mu + b * np.log(2 * u_reg[mask_le_half])\n\n        # Branch 2: u > 0.5 (using the inverted mask)\n        mask_gt_half = ~mask_le_half\n        samples[mask_gt_half] = mu - b * np.log(2 * (1 - u_reg[mask_gt_half]))\n\n        return samples\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # 1. Random generation (happy path)\n        {'type': 'random', 'mu': 0.0, 'b': 1.0, 'n': 100000, 'seed': 314159},\n        # 2. Random generation (shifted and narrower scale)\n        {'type': 'random', 'mu': 2.5, 'b': 0.5, 'n': 50000, 'seed': 271828},\n        # 3. Random generation (edge scale, extremely small)\n        {'type': 'random', 'mu': -3.0, 'b': 1e-6, 'n': 3, 'seed': 99},\n        # 4. Deterministic mapping (boundary stress test)\n        {'type': 'deterministic', 'mu': 1.0, 'b': 2.0, 'u_values': np.array([1e-12, 0.5, 1 - 1e-12])}\n    ]\n\n    results = []\n    for case in test_cases:\n        if case['type'] == 'random':\n            rng = np.random.default_rng(case['seed'])\n            uniform_samples = rng.uniform(size=case['n'])\n            \n            laplace_samples = inverse_cdf_laplace(uniform_samples, case['mu'], case['b'])\n            \n            # Calculate required statistics\n            sample_mean = np.mean(laplace_samples)\n            # Population variance (ddof=0 is the default for np.var)\n            pop_variance = np.var(laplace_samples)\n            sample_median = np.median(laplace_samples)\n            \n            results.append([sample_mean, pop_variance, sample_median])\n        \n        elif case['type'] == 'deterministic':\n            mapped_values = inverse_cdf_laplace(case['u_values'], case['mu'], case['b'])\n            results.append(mapped_values.tolist())\n\n    # Final print statement in the exact required format.\n    # The format \"[list1,list2,...]\" is achieved by mapping each inner list to\n    # its string representation and then joining with commas.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3244399"}, {"introduction": "这最后一个练习通过构建一个基于直方图表示的经验分布采样器，将理论与现实世界的数据分析联系起来。你将使用分段均匀分布来为数据建模，并应用逆变换采样来生成模仿原始观测的新数据。当分布的解析形式未知时，这种强大的技术被广泛应用于模拟、自助法（bootstrapping）和建模中。", "problem": "给定经验数据的直方图摘要，形式为区间边界和区间计数。假设在每个区间内，其底层的概率密度是均匀的，因此产生的累积分布函数 (CDF) 是分段线性的。利用逆变换采样原理，构建一个采样器，将均匀分布的随机数映射为由该直方图所隐含的分段均匀分布的样本。然后，通过比较生成样本的经验统计量与直方图模型所隐含的相应解析值来验证您的采样器。\n\n使用的基本原理和定义：\n- 一个实值随机变量 $X$ 的累积分布函数 $F(x)$ 定义为 $F(x) = \\mathbb{P}(X \\le x)$。\n- 如果 $U$ 在 $[0,1]$ 上均匀分布，且 $F$ 是一个连续且严格递增的CDF，那么 $X = F^{-1}(U)$ 的CDF为 $F$（逆变换采样法）。对于分段线性的 $F$，其逆函数 $F^{-1}$ 是通过对每个线性段反演相应的仿射映射来计算的。\n- 对于一个由区间边界 $x_0  x_1  \\dots  x_N$ 和非负计数 $c_0,\\dots,c_{N-1}$（总数为 $C = \\sum_{i=0}^{N-1} c_i > 0$）表征的直方图，定义区间概率 $p_i = c_i / C$。在区间内分段均匀的假设下，CDF在每个区间上是线性的：对于 $x \\in [x_i, x_{i+1}]$，\n$$\nF(x) = \\sum_{j=0}^{i-1} p_j \\;+\\; p_i \\cdot \\frac{x - x_i}{x_{i+1} - x_i}。\n$$\n它在概率区间 $u \\in [F(x_i), F(x_{i+1})]$ 上的逆函数为\n$$\nF^{-1}(u) = x_i + (x_{i+1} - x_i)\\,\\frac{u - F(x_i)}{p_i},\n$$\n对于任何 $p_i > 0$ 的 $i$。\n\n编程任务：\n1. 实现一个函数，给定区间边界 $\\{x_i\\}_{i=0}^N$ 和计数 $\\{c_i\\}_{i=0}^{N-1}$，构建边界处的归一化累积概率，即 $F(x_i) = \\sum_{j=0}^{i-1} p_j$ 对于 $i=0,\\dots,N$，其中 $F(x_0)=0$ 且 $F(x_N)=1$。\n2. 实现一个逆变换采样器，该采样器：\n   - 从 $[0,1)$ 上的均匀分布中抽取 $u$。\n   - 找到区间索引 $i$ 使得 $F(x_i) \\le u  F(x_{i+1})$。\n   - 返回 $x = x_i + (x_{i+1}-x_i)\\,\\frac{u - F(x_i)}{p_i}$。\n   - 稳健地处理计数为零的区间。特别地，要确保对于任何连续的计数为零的区间块，当 $u$ 等于该块上的平坦CDF值时，逆映射会选择随后的具有正质量的区间。\n3. 实现以下解析计算：\n   - 分段均匀模型下的期望值：\n     $$\n     \\mathbb{E}[X] = \\sum_{i=0}^{N-1} p_i \\cdot \\frac{x_i + x_{i+1}}{2}.\n     $$\n   - 在任意阈值 $t$ 处的CDF：\n     $$\n     F(t) = \\begin{cases}\n     0,  t \\le x_0,\\\\\n     1,  t \\ge x_N,\\\\\n     \\sum_{j=0}^{k-1} p_j + p_k \\cdot \\dfrac{t - x_k}{x_{k+1} - x_k},  t \\in [x_k, x_{k+1}) \\text{ for some } k.\n     \\end{cases}\n     $$\n   - 在概率水平 $q \\in [0,1]$ 处的分位数（逆CDF）：\n     $$\n     F^{-1}(q) = \\begin{cases}\n     x_0,  q \\le 0,\\\\\n     x_N,  q \\ge 1,\\\\\n     x_i + (x_{i+1}-x_i)\\,\\dfrac{q - F(x_i)}{p_i},  q \\in [F(x_i), F(x_{i+1})) \\text{ for some } i \\text{ with } p_i > 0.\n     \\end{cases}\n     $$\n4. 实现从生成样本计算的经验对应量：\n   - 经验均值 $\\hat{\\mu} = \\dfrac{1}{M}\\sum_{m=1}^M X_m$。\n   - 在阈值 $t$ 处的经验CDF：$\\hat{F}(t) = \\dfrac{1}{M}\\sum_{m=1}^M \\mathbf{1}\\{X_m \\le t\\}$。\n   - 使用Hyndman–Fan类型7定义计算概率水平 $q$ 处的经验分位数：对于排序后的样本 $X_{(1)} \\le \\dots \\le X_{(M)}$，定义 $h = (M-1)q + 1$，$k = \\lfloor h \\rfloor$，$\\gamma = h - k$，以及\n     $$\n     \\hat{Q}_7(q) = (1-\\gamma)X_{(k)} + \\gamma X_{(k+1)},\n     $$\n     并约定当 $q=0$ 时为 $X_{(1)}$，当 $q=1$ 时为 $X_{(M)}$。\n\n测试套件和要求的输出：\n- 对于所有测试，使用上述的分段均匀模型。\n- 对于每个测试，使用指定的随机种子生成 $M$ 个样本。计算三个绝对误差：\n  - 均值的绝对误差：$|\\hat{\\mu} - \\mathbb{E}[X]|$。\n  - 在指定阈值 $t$ 处的CDF的绝对误差：$|\\hat{F}(t) - F(t)|$。\n  - $q$-分位数的绝对误差：$|\\hat{Q}_7(q) - F^{-1}(q)|$。\n- 测试：\n  - 测试A（一般非均匀区间）：\n    - 区间边界: $[-2.0,-1.0,0.0,1.0,3.0]$。\n    - 计数: $[10,20,40,30]$。\n    - 样本量: $M = 200000$。\n    - 随机种子: $123456789$。\n    - 阈值: $t = 0.5$。\n    - 分位数水平: $q = 0.95$。\n  - 测试B（存在内部计数为零的区间）：\n    - 区间边界: $[0.0,1.0,2.0,3.0,4.0,5.0]$。\n    - 计数: $[5,0,15,0,5]$。\n    - 样本量: $M = 100000$。\n    - 随机种子: $2023$。\n    - 阈值: $t = 2.5$。\n    - 分位数水平: $q = 0.8$。\n  - 测试C（窄、宽区间与零计数混合）：\n    - 区间边界: $[-1.0,0.0,0.1,0.5,3.0]$。\n    - 计数: $[0,50,0,50]$。\n    - 样本量: $M = 150000$。\n    - 随机种子: $777$。\n    - 阈值: $t = 0.05$。\n    - 分位数水平: $q = 0.5$。\n- 最终输出格式：\n  - 你的程序应产生单行输出，包含一个逗号分隔的九个浮点数误差列表，顺序为\n    $[|\\hat{\\mu}_A - \\mathbb{E}_A[X]|,|\\hat{F}_A(t)-F_A(t)|,|\\hat{Q}_{7,A}(q)-F_A^{-1}(q)|,|\\hat{\\mu}_B - \\mathbb{E}_B[X]|,|\\hat{F}_B(t)-F_B(t)|,|\\hat{Q}_{7,B}(q)-F_B^{-1}(q)|,|\\hat{\\mu}_C - \\mathbb{E}_C[X]|,|\\hat{F}_C(t)-F_C(t)|,|\\hat{Q}_{7,C}(q)-F_C^{-1}(q)|]$。\n  - 将每个报告的浮点数四舍五入到 $6$ 位小数。\n  - 列表必须用方括号打印，且不含空格，例如：$[0.001000,0.000500,0.002345, \\dots ]$，包含恰好 $9$ 个值，且无附加文本。", "solution": "问题陈述经评估后确定为有效。它具有科学依据，问题设定良好，并包含唯一可验证解所需的所有必要信息和定义。其基本原理是概率论和计算统计学中的标准内容。任务的规定足够清晰，可以进行无歧义的实现。因此，我们着手解决此问题。\n\n目标是为由直方图定义的概率分布构建并验证一个逆变换采样器。该模型假设在直方图的各个区间上为分段均匀概率密度函数（PDF）。\n\n设直方图由一组 $N+1$ 个区间边界 $x_0  x_1  \\dots  x_N$ 和 $N$ 个对应的非负区间计数 $c_0, c_1, \\dots, c_{N-1}$ 定义。观测总数为 $C = \\sum_{i=0}^{N-1} c_i$，且给定 $C>0$。\n\n首先，我们对计数进行归一化，得到区间概率 $p_i = c_i / C$，其中 $i=0, \\dots, N-1$。模型假设在每个区间 $[x_i, x_{i+1}]$ 内，概率密度是均匀的。因此，PDF $f(x)$ 是分段常数：\n$$\nf(x) =\n\\begin{cases}\n\\frac{p_i}{x_{i+1} - x_i}  \\text{if } x \\in [x_i, x_{i+1}) \\text{ and } p_i > 0 \\\\\n0  \\text{otherwise}\n\\end{cases}\n$$\n累积分布函数 (CDF) $F(x) = \\mathbb{P}(X \\le x) = \\int_{-\\infty}^{x} f(\\xi) d\\xi$ 是一个连续且分段线性的函数。在每个区间边界 $x_i$ 处的CDF值是所有前面区间的概率之和：\n$$\nF(x_i) = \\sum_{j=0}^{i-1} p_j\n$$\n对于区间 $[x_i, x_{i+1}]$ 内的任何点 $x$，CDF通过线性插值给出：\n$$\nF(x) = F(x_i) + p_i \\cdot \\frac{x - x_i}{x_{i+1} - x_i}\n$$\n注意，如果区间 $i$ 的计数为零（$c_i=0$，因此$p_i=0$），则CDF在该区间上是平坦的，即对于所有 $x \\in [x_i, x_{i+1}]$，$F(x) = F(x_i)$。\n\n任务的核心是实现逆变换采样法。该方法依赖于以下性质：如果 $U$ 是一个在 $[0,1]$ 上均匀分布的随机变量，那么 $X = F^{-1}(U)$ 就是一个具有CDF $F$ 的随机变量。对于 $u \\in [0,1]$，逆CDF $F^{-1}(u)$ 是通过反转 $F(x)$ 的表达式来找到的。对于给定的概率 $u \\in [F(x_i), F(x_{i+1}))$，对应于一个概率 $p_i > 0$ 的区间 $i$，其逆函数为：\n$$\nF^{-1}(u) = x_i + (x_{i+1} - x_i)\\,\\frac{u - F(x_i)}{p_i}\n$$\n算法流程如下：\n1.  **预计算：** 给定区间边界和计数的列表，我们首先计算区间概率数组 $\\{p_i\\}_{i=0}^{N-1}$。然后，我们计算在区间边界处的累积概率数组，记为 `cum_probs`，其中 `cum_probs[i]` $= F(x_i)$，对于 $i=0,\\dots,N$。该数组长度为 $N+1$，且 `cum_probs[0]`$=0$ 和 `cum_probs[N]`$=1$。\n2.  **采样：** 生成 $M$ 个样本的集合：\n    a. 从均匀分布 $U[0, 1)$ 中抽取 $M$ 个独立的随机数 $\\{u_k\\}_{k=1}^M$。\n    b. 对于每个 $u_k$，确定区间索引 $i$ 使得 $F(x_i) \\le u_k  F(x_{i+1})$。这个搜索过程可以对所有 $u_k$ 以向量化的方式高效执行，使用二分搜索算法，例如`numpy.searchsorted(cum_probs, u, side='right')`，它给出区间边界的索引，从中可以导出区间索引 $i$。此过程能自然地处理概率为零的区间，因为搜索会跳过CDF的平坦区域。\n    c. 对每个 $u_k$ 使用其已确定的区间索引 $i$ 应用逆CDF公式，计算出样本 $x_k = F^{-1}(u_k)$。为了效率，这一步也进行向量化处理。\n3.  **解析计算：**\n    - **期望值：** 解析均值 $\\mathbb{E}[X]$ 是每个区间的期望值按其概率加权的和。对于 $[x_i, x_{i+1}]$ 上的均匀分布，均值为 $(x_i + x_{i+1})/2$。因此，\n      $$ \\mathbb{E}[X] = \\sum_{i=0}^{N-1} p_i \\cdot \\frac{x_i + x_{i+1}}{2} $$\n    - **在阈值 $t$ 处的CDF**：要计算 $F(t)$，首先找到区间索引 $k$ 使得 $x_k \\le t  x_{k+1}$。然后应用 $F(x)$ 的分段线性公式。边缘情况 $t \\le x_0$ 和 $t \\ge x_N$ 分别导致 $F(t)=0$ 和 $F(t)=1$。\n    - **在概率 $q$ 处的分位数**：要计算 $F^{-1}(q)$，找到区间索引 $i$ 使得 $F(x_i) \\le q  F(x_{i+1})$，然后应用逆函数公式。\n4.  **从样本进行经验计算：**\n    - **经验均值 $\\hat{\\mu}$：** $M$ 个生成样本的算术平均值。\n    - **经验CDF $\\hat{F}(t)$：** $M$ 个样本中小于或等于阈值 $t$ 的样本所占的比例。\n    - **经验分位数 $\\hat{Q}_7(q)$：** 从排序后的样本中，使用Hyndman-Fan类型7定义计算，这对应于顺序统计量之间的线性插值。这在 `numpy.quantile` 中通过 `interpolation='linear'` 参数可用。\n5.  **验证：** 对于问题中定义的每个测试用例，采样器使用指定的随机种子生成 $M$ 个样本。计算均值、在 $t$ 处的CDF以及在 $q$ 处的分位数的解析值。将这些值与从生成样本计算出的经验对应量进行比较。解析值和经验值之间的绝对误差是最终结果。\n\n提供的Python代码实现了这整个过程。它通过一个 `PiecewiseUniform` 类来封装分布的属性和方法，并通过一个主 `solve` 函数来执行指定的测试套件并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by implementing and validating an inverse transform sampler\n    for a piecewise-uniform distribution defined by a histogram.\n    \"\"\"\n\n    class PiecewiseUniform:\n        \"\"\"\n        Represents a piecewise-uniform probability distribution derived from a histogram.\n        \"\"\"\n        def __init__(self, edges: list[float], counts: list[int]):\n            self.edges = np.array(edges, dtype=np.float64)\n            self.counts = np.array(counts, dtype=np.float64)\n            \n            if len(self.edges) != len(self.counts) + 1:\n                raise ValueError(\"Number of edges must be one more than the number of counts.\")\n            \n            total_counts = np.sum(self.counts)\n            if total_counts = 0:\n                # Based on problem statement C > 0, but good practice to check.\n                # If all counts are zero, probs are ill-defined.\n                # For this problem, we can assume valid inputs.\n                self.probs = np.zeros_like(self.counts)\n            else:\n                self.probs = self.counts / total_counts\n\n            # Cumulative probabilities at bin edges F(x_i)\n            self.cum_probs = np.zeros(len(self.edges), dtype=np.float64)\n            self.cum_probs[1:] = np.cumsum(self.probs)\n\n        def analytical_mean(self) -> float:\n            \"\"\"Computes the analytical expected value.\"\"\"\n            bin_midpoints = (self.edges[:-1] + self.edges[1:]) / 2.0\n            return np.sum(self.probs * bin_midpoints)\n\n        def analytical_cdf(self, t: float) -> float:\n            \"\"\"Computes the analytical CDF at a threshold t.\"\"\"\n            if t = self.edges[0]:\n                return 0.0\n            if t >= self.edges[-1]:\n                return 1.0\n            \n            # Find bin index k such that edges[k] = t  edges[k+1]\n            bin_idx = np.searchsorted(self.edges, t, side='right') - 1\n            \n            x_k = self.edges[bin_idx]\n            x_k_plus_1 = self.edges[bin_idx + 1]\n            p_k = self.probs[bin_idx]\n            F_x_k = self.cum_probs[bin_idx]\n            \n            # Handle case where bin width is zero to avoid division by zero\n            bin_width = x_k_plus_1 - x_k\n            if bin_width == 0:\n                return F_x_k\n            \n            return F_x_k + p_k * (t - x_k) / bin_width\n\n        def analytical_quantile(self, q: float) -> float:\n            \"\"\"Computes the analytical quantile (inverse CDF) at probability q.\"\"\"\n            if q = 0.0:\n                return self.edges[0]\n            if q >= 1.0:\n                return self.edges[-1]\n\n            # Find bin index i such that F(x_i) = q  F(x_{i+1})\n            bin_idx = np.searchsorted(self.cum_probs, q, side='right') - 1\n            \n            # This logic should always find a bin with non-zero probability,\n            # unless q falls in a flat region exactly. In that case, the quantile is\n            # the start of the next bin with positive mass. searchsorted handles this.\n            \n            F_x_i = self.cum_probs[bin_idx]\n            p_i = self.probs[bin_idx]\n\n            if p_i == 0:\n                # If q falls exactly on a cumulative probability level that starts a\n                # sequence of zero-count bins, the quantile is the edge of the next\n                # non-zero bin. This is what np.searchsorted finds.\n                return self.edges[bin_idx+1]\n\n            x_i = self.edges[bin_idx]\n            x_i_plus_1 = self.edges[bin_idx + 1]\n            \n            return x_i + (x_i_plus_1 - x_i) * (q - F_x_i) / p_i\n\n        def sample(self, M: int, seed: int) -> np.ndarray:\n            \"\"\"Generates M samples using inverse transform sampling.\"\"\"\n            rng = np.random.default_rng(seed)\n            u_samples = rng.uniform(0.0, 1.0, M)\n            \n            # Find bin indices for all uniform samples\n            bin_indices = np.searchsorted(self.cum_probs, u_samples, side='right') - 1\n            \n            # Fetch corresponding parameters for vectorization\n            x_i = self.edges[bin_indices]\n            x_i_plus_1 = self.edges[bin_indices + 1]\n            cum_prob_i = self.cum_probs[bin_indices]\n            prob_i = self.probs[bin_indices]\n\n            # The formula is undefined for prob_i = 0.\n            # We filter to avoid division by zero.\n            # `searchsorted` should prevent selection of bins with p=0 unless u falls\n            # exactly on a boundary, but u is from a continuous distribution.\n            # A failsafe is to only compute for prob_i > 0\n            samples = np.zeros_like(u_samples)\n            \n            # Mask for bins with positive probability\n            pos_prob_mask = prob_i > 0\n            \n            # Calculate samples for bins with positive probability\n            samples[pos_prob_mask] = x_i[pos_prob_mask] + \\\n                (x_i_plus_1[pos_prob_mask] - x_i[pos_prob_mask]) * \\\n                (u_samples[pos_prob_mask] - cum_prob_i[pos_prob_mask]) / prob_i[pos_prob_mask]\n\n            # For any bins with prob_i == 0 (should not happen with U[0,1) and searchsorted)\n            # the sample would be the left edge of the bin.\n            # The quantile for a flat CDF region is typically defined as the infimum of the set of x\n            # that satisfy F(x) >= q, which corresponds to the start of the next bin with mass.\n            # Our `searchsorted` logic already handles this correctly.\n            # Any u that falls into such a region gets assigned to the next bin.\n            # So, the mask is almost a theoretical precaution.\n\n            return samples\n\n    test_cases = [\n        {\n            \"name\": \"Test A\",\n            \"edges\": [-2.0, -1.0, 0.0, 1.0, 3.0],\n            \"counts\": [10, 20, 40, 30],\n            \"M\": 200000,\n            \"seed\": 123456789,\n            \"t\": 0.5,\n            \"q\": 0.95\n        },\n        {\n            \"name\": \"Test B\",\n            \"edges\": [0.0, 1.0, 2.0, 3.0, 4.0, 5.0],\n            \"counts\": [5, 0, 15, 0, 5],\n            \"M\": 100000,\n            \"seed\": 2023,\n            \"t\": 2.5,\n            \"q\": 0.8\n        },\n        {\n            \"name\": \"Test C\",\n            \"edges\": [-1.0, 0.0, 0.1, 0.5, 3.0],\n            \"counts\": [0, 50, 0, 50],\n            \"M\": 150000,\n            \"seed\": 777,\n            \"t\": 0.05,\n            \"q\": 0.5\n        }\n    ]\n\n    all_errors = []\n\n    for case in test_cases:\n        dist = PiecewiseUniform(case[\"edges\"], case[\"counts\"])\n        \n        # Generate samples\n        samples = dist.sample(case[\"M\"], case[\"seed\"])\n        \n        # Analytical values\n        ana_mean = dist.analytical_mean()\n        ana_cdf = dist.analytical_cdf(case[\"t\"])\n        ana_quantile = dist.analytical_quantile(case[\"q\"])\n        \n        # Empirical values\n        emp_mean = np.mean(samples)\n        emp_cdf = np.sum(samples = case[\"t\"]) / case[\"M\"]\n        emp_quantile = np.quantile(samples, case[\"q\"], method='linear')\n        \n        # Errors\n        err_mean = abs(emp_mean - ana_mean)\n        err_cdf = abs(emp_cdf - ana_cdf)\n        err_quantile = abs(emp_quantile - ana_quantile)\n        \n        all_errors.extend([err_mean, err_cdf, err_quantile])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(f'{e:.6f}' for e in all_errors)}]\")\n\nsolve()\n```", "id": "2403898"}]}