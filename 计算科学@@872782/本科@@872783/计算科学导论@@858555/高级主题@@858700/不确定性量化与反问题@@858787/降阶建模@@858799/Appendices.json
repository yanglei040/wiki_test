{"hands_on_practices": [{"introduction": "理论知识需要通过实践来巩固。本章提供了一系列动手练习，旨在加深您对降阶建模核心概念的理解。第一个练习将引导您将本征正交分解（POD）应用于一个经典问题：一维热方程。由于热方程的解具有耗散性，高频空间模式会迅速衰减，因此该系统非常适合用少数几个主导模态来近似。您将从一个参数化的解析解中生成快照，构建一个POD基，并检验该基对于训练集之外的新参数的泛化能力。", "problem": "要求您实现一个完整的、可运行的程序，该程序从一维热方程的训练快照中构建一个本征正交分解 (POD) 基，然后评估对于指定范围内几个未见的热扩散系数参数，正交投影误差如何随着保留的 POD 模态数量的增加而衰减。所有量都必须用纯数学术语处理，不带物理单位。\n\n考虑在单位区间上具有零狄利克雷边界条件的一维热方程：\n- 控制定律：$u_t = \\kappa\\,u_{xx}$，对于 $x \\in [0,1]$ 和 $t \\ge 0$。\n- 边界条件：$u(0,t) = 0$ 和 $u(1,t) = 0$，对于所有 $t \\ge 0$。\n- 初始条件：$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，其中系数由 $a_1=1.0$，$a_2=0.5$，$a_3=-0.3$，$a_4=0.2$，$a_5=0.1$，$a_6=-0.05$，$a_7=0.04$，$a_8=-0.02$ 给出。\n\n解构造的基本依据：一个经过充分检验的事实是，在这些边界条件下，上述初边值问题的解可以用傅里叶正弦级数表示，其模态振幅随时间呈指数衰减。您必须利用这一事实来解析地计算快照，而无需对偏微分方程进行数值离散化。\n\n定义与所需计算：\n- 将解析解定义为 $u(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)$。\n- 设空间网格在 $[0,1]$ 上是均匀的，包含 $N_x = 200$ 个点（包括端点）。\n- 设训练参数值为 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$，训练快照时间为 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$。\n- 通过将指定集合中每个 $t$ 和指定训练集中每个 $\\kappa$ 对应的所有空间快照 $u(\\cdot, t; \\kappa)$ 作为列，以任意固定的确定性顺序连接起来，构建训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。\n- 通过对训练快照矩阵进行奇异值分解 (SVD) $M_{\\text{train}} = U \\Sigma V^\\top$ 来计算 POD 基，即 $U$ 的列。其中 $U \\in \\mathbb{R}^{N_x \\times r_{\\max}}$ 具有标准正交列，且 $r_{\\max} \\le \\min(N_x, N_{\\text{snap}})$。按顺序使用这些 $U$ 的列作为 POD 模态；不要减去均值（即，直接对 $M_{\\text{train}}$ 执行 POD）。\n- 为进行评估，使用未见的测试参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 和相同的时间集 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$ 为每个测试参数构建 $M_{\\text{test}}(\\kappa) \\in \\mathbb{R}^{N_x \\times N_{\\text{test}}}$。\n- 对于给定的保留模态数 $r$，定义正交投影算子 $P_r = U_r U_r^\\top$，其中 $U_r \\in \\mathbb{R}^{N_x \\times r}$ 包含前 $r$ 个 POD 模态。对于每个测试参数 $\\kappa$，计算相对投影误差\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F},\n$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。将 $E(\\kappa,0)$ 取为零近似的相对误差（即 $P_0 = 0$）。\n- 为 $r \\in \\{0,1,2,3,5,8,10\\}$ 和每个 $\\kappa \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 计算 $E(\\kappa,r)$。\n\n测试套件与覆盖范围理据：\n- 选择 $r=0$ 测试了不保留任何模态的边界情况。\n- 选择 $r=10$ 超过了非零初始傅里叶分量的数量，用以探查误差饱和至零的预期情况。\n- 测试参数包括区间端点 $0.05$ 和 $0.25$ 以及内部值 $0.10$ 和 $0.17$，这些值均未在训练中使用，从而检验了模型在整个参数范围内的泛化能力。\n\n最终输出要求：\n- 您的程序应生成单行输出，其中包含一个无空格的浮点数嵌套列表形式的结果。外层列表必须按测试参数 $\\kappa \\in [0.05, 0.10, 0.17, 0.25]$ 的升序排列。对于每个测试参数，内层列表必须包含按此确切 $r$ 顺序排列的误差 $[E(\\kappa,0), E(\\kappa,1), E(\\kappa,2), E(\\kappa,3), E(\\kappa,5), E(\\kappa,8), E(\\kappa,10)]$。将每个浮点数表示为四舍五入到八位小数。例如，打印的形状必须类似于 $[[e_{11},e_{12},\\dots],[e_{21},\\dots],\\dots]$，其中 $e_{ij}$ 的位置由数值条目代替。", "solution": "该问题要求实现一个基于本征正交分解 (POD) 的一维热方程降阶模型。该过程涉及生成训练数据、构建一个低维基，并在未见的测试数据上评估该基的有效性。整个过程基于解析解，从而避免了控制偏微分方程 (PDE) 的离散化误差。\n\n步骤 1：解析解与数据生成\n\n该问题涉及热方程 $u_t = \\kappa\\,u_{xx}$，其定义域为 $x \\in [0,1]$，具有零狄利克雷边界条件 $u(0,t) = u(1,t) = 0$。初始条件是一个有限傅里叶级数，$u(x,0) = \\sum_{n=1}^{8} a_n \\sin(n\\pi x)$，其系数 $\\{a_n\\}$ 为给定值。由分离变量法推导出的解析解由下式给出：\n$$\nu(x,t;\\kappa) = \\sum_{n=1}^{8} a_n \\exp\\!\\big(-\\kappa (n\\pi)^2 t\\big)\\,\\sin(n\\pi x)\n$$\n此公式使我们能够生成解场的“快照”，这些快照是表示在特定时间 $t$ 和给定热扩散系数 $\\kappa$ 下温度分布 $u(\\cdot, t; \\kappa)$ 的向量。这些快照在 $[0,1]$ 上的一个包含 $N_x = 200$ 个点的均匀空间网格上进行评估。\n\n步骤 2：训练快照矩阵构建\n\n为了构建降阶模型，我们首先收集一组具有代表性的解。训练数据是使用训练参数集 $\\kappa_{\\text{train}} \\in \\{0.06, 0.14, 0.22\\}$ 和快照时间 $t \\in \\{0.00, 0.05, 0.10, 0.20, 0.50\\}$ 生成的。对于训练集中的每一对 $(\\kappa, t)$，我们计算相应的解快照向量。然后将这些快照向量作为列连接起来，形成训练快照矩阵 $M_{\\text{train}} \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$。这里，$N_x = 200$，快照总数为 $N_{\\text{snap}} = |\\kappa_{\\text{train}}| \\times |t| = 3 \\times 5 = 15$。\n\n步骤 3：本征正交分解 (POD)\n\nPOD 的核心是找到一个标准正交基，该基在最小二乘意义上能最优地表示训练数据。这通过对快照矩阵执行奇异值分解 (SVD) 来实现：\n$$\nM_{\\text{train}} = U \\Sigma V^\\top\n$$\n矩阵 $U \\in \\mathbb{R}^{N_x \\times N_{\\text{snap}}}$ 的列（来自薄奇异值分解，因为 $N_x > N_{\\text{snap}}$）是左奇异向量。这些向量构成了 POD 基。它们根据对角矩阵 $\\Sigma \\in \\mathbb{R}^{N_{\\text{snap}} \\times N_{\\text{snap}}}$ 中相应奇异值的大小进行排序，其中 $U$ 的第一列是能量最高的模态。\n一个重要的观察是，对于任何 $t$ 和 $\\kappa$，所有快照都位于由函数 $\\{\\sin(n\\pi x)\\}_{n=1}^8$ 张成的 $8$ 维子空间内。因此，快照矩阵 $M_{\\text{train}}$ 的秩不能超过 $8$。这意味着只有前 $8$ 个奇异值会显著非零，而 POD 基的有效维度将为 $8$。\n\n步骤 4：投影与误差评估\n\nPOD 基允许通过将任何解快照（无论是否在训练集内）正交投影到由前 $r$ 个 POD 模态张成的子空间上来近似该快照。我们将截断的基矩阵表示为 $U_r \\in \\mathbb{R}^{N_x \\times r}$，它包含 $U$ 的前 $r$ 列。到这个子空间上的正交投影算子是 $P_r = U_r U_r^\\top$。\n\n为了评估基的质量，我们为一组未见的参数 $\\kappa_{\\text{test}} \\in \\{0.05, 0.10, 0.17, 0.25\\}$ 使用相同的时间实例集生成测试数据。对于每个 $\\kappa \\in \\kappa_{\\text{test}}$，我们构建一个测试快照矩阵 $M_{\\text{test}}(\\kappa)$。使用 $r$ 个模态对该测试矩阵的近似由 $P_r M_{\\text{test}}(\\kappa)$ 给出。此近似的误差使用相对弗罗贝尼乌斯范数量化：\n$$\nE(\\kappa,r) = \\frac{\\lVert M_{\\text{test}}(\\kappa) - P_r M_{\\text{test}}(\\kappa) \\rVert_F}{\\lVert M_{\\text{test}}(\\kappa) \\rVert_F}\n$$\n为了计算效率，投影 $P_r M_{\\text{test}}(\\kappa)$ 计算为 $U_r (U_r^\\top M_{\\text{test}}(\\kappa))$。情况 $r=0$ 对应于用零来近似解，产生的误差为 $E(\\kappa,0)=1$。我们为每个 $\\kappa \\in \\kappa_{\\text{test}}$ 以及指定的保留模态集 $r \\in \\{0, 1, 2, 3, 5, 8, 10\\}$ 计算这个误差。结果被汇总到一个嵌套列表中以供最终输出。由于基础解空间是 $8$ 维的，我们预计当 $r \\ge 8$ 时，误差将降至接近于零。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import linalg\n\ndef solve():\n    \"\"\"\n    Constructs a POD basis for the 1D heat equation and evaluates projection error.\n    \"\"\"\n    # Define problem parameters\n    A_COEFFS = np.array([1.0, 0.5, -0.3, 0.2, 0.1, -0.05, 0.04, -0.02])\n    NX = 200\n    KAPPA_TRAIN = [0.06, 0.14, 0.22]\n    T_POINTS = [0.00, 0.05, 0.10, 0.20, 0.50]\n    KAPPA_TEST = [0.05, 0.10, 0.17, 0.25]\n    R_VALUES = [0, 1, 2, 3, 5, 8, 10]\n\n    # Spatial grid\n    x = np.linspace(0, 1, NX)\n\n    def analytical_u(x_grid, t, kappa, coeffs):\n        \"\"\"Computes the analytical solution u(x, t; kappa).\"\"\"\n        sol = np.zeros_like(x_grid)\n        for n_idx, a_n in enumerate(coeffs):\n            n = n_idx + 1\n            mode_component = a_n * np.exp(-kappa * (n * np.pi)**2 * t) * np.sin(n * np.pi * x_grid)\n            sol += mode_component\n        return sol\n\n    # --- Step 1: Construct Training Snapshot Matrix ---\n    train_snapshots = []\n    for kappa_train_val in KAPPA_TRAIN:\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_train_val, A_COEFFS)\n            train_snapshots.append(snapshot)\n    \n    M_train = np.stack(train_snapshots, axis=1)\n\n    # --- Step 2: Compute POD Basis via SVD ---\n    # Use thin SVD since Nx > N_snap\n    U, s, vh = linalg.svd(M_train, full_matrices=False)\n\n    # --- Step 3: Evaluate Projection Error for Test Cases ---\n    all_results = []\n    for kappa_test_val in KAPPA_TEST:\n        # Build the test snapshot matrix for the current kappa\n        test_snapshots = []\n        for t_val in T_POINTS:\n            snapshot = analytical_u(x, t_val, kappa_test_val, A_COEFFS)\n            test_snapshots.append(snapshot)\n        \n        M_test = np.stack(test_snapshots, axis=1)\n\n        norm_M_test = linalg.norm(M_test, 'fro')\n        \n        kappa_errors = []\n        for r in R_VALUES:\n            if norm_M_test == 0:\n                 # Should not happen in this problem, but for robustness\n                 # If M_test is zero, projection is perfect (error 0), except for r=0\n                 error = 1.0 if r == 0 else 0.0\n            elif r == 0:\n                # Per problem spec, P_0 = 0. Error is ||M - 0|| / ||M|| = 1.\n                error = 1.0\n            else:\n                # Truncate the POD basis\n                Ur = U[:, :r]\n                \n                # Project M_test onto the r-dimensional subspace\n                # P_r * M_test = Ur * Ur.T * M_test\n                projected_M_test = Ur @ (Ur.T @ M_test)\n                \n                # Compute the relative Frobenius norm of the error\n                error_matrix = M_test - projected_M_test\n                norm_error = linalg.norm(error_matrix, 'fro')\n                error = norm_error / norm_M_test\n\n            kappa_errors.append(error)\n        \n        all_results.append(kappa_errors)\n        \n    # --- Step 4: Format output string ---\n    outer_parts = []\n    for inner_list in all_results:\n        inner_parts = [f\"{x:.8f}\" for x in inner_list]\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    final_string = f\"[{','.join(outer_parts)}]\"\n\n    print(final_string)\n\nsolve()\n```", "id": "3184782"}, {"introduction": "在见证了POD在处理耗散系统时的卓越表现后，探索其局限性也同样重要。第二个练习将研究一个纯对流问题：平移的高斯脉冲。您将会发现，对于平移现象，标准的POD方法效率低下，因为每个时刻的快照都趋于正交，需要大量的模态才能准确重构。通过这个练习，您将亲身体会到为何POD对于传输主导的系统可能不是最佳选择，从而对降阶方法的适用范围建立更深刻的认识。", "problem": "考虑一个平移高斯脉冲的快照函数族，其定义为 $u(x,t) = \\exp\\!\\left(-\\big(x - c t\\big)^{2}\\right)$，空间区间为 $x \\in [-L,L]$，时间点为离散的 $t \\in \\{t_{0}, t_{1}, \\dots, t_{m-1}\\}$。根据第一性原理，本征正交分解 (Proper Orthogonal Decomposition, POD) 是这样一个过程：对于给定的秩 $r$，它在空间中选择一个 $r$ 维标准正交基，使得快照集在该基上的总投影平方误差最小。等价地，它产生快照数据的最佳秩 $r$ 近似（在所有网格点和时间点上的欧几里得最小二乘意义下）。\n\n您的任务是实现一个程序，该程序：\n- 构建快照矩阵 $X \\in \\mathbb{R}^{N_x \\times m}$，其第 $k$ 列是在 $[-L,L]$ 上的 $N_x$ 个均匀分布的网格点上采样得到的快照 $u(x,t_k)$。这需要给定速度 $c$、快照数量 $m$ 和最终时间 $T$（其中 $t_k$ 在 $[0,T]$ 内等距分布）。\n- 对于秩 $r \\in \\{1,2,5,10\\}$，计算最佳秩 $r$ 近似 $X_r$（由 POD 定义）以及相应的相对重构误差\n$$E_r = \\frac{\\lVert X - X_r \\rVert_F}{\\lVert X \\rVert_F},$$\n其中 $\\lVert \\cdot \\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 将每个测试用例的误差 $E_r$ 作为浮点数报告，并四舍五入到六位小数。\n\n使用的基本原理：\n- 欧几里得内积和弗罗贝尼乌斯范数的定义。\n- 本征正交分解（POD）的定义性优化属性：在所有 $r$ 维标准正交基中，POD 使快照的总投影平方误差最小化。这在最小二乘意义下产生了快照矩阵的最佳秩 $r$ 近似。\n\n测试套件：\n所有情况均使用 $L = 10$ 和 $N_x = 401$。四个测试用例如下：\n1. 情况 A（静止脉冲）：$c = 0$, $T = 5$, $m = 50$。\n2. 情况 B（缓慢平移）：$c = 0.5$, $T = 10$, $m = 100$。\n3. 情况 C（快速平移）：$c = 2.0$, $T = 4$, $m = 80$。\n4. 情况 D（少量快照）：$c = 0.5$, $T = 10$, $m = 5$。\n\n答案规格：\n- 对每个测试用例，输出一个包含四个浮点数的列表 $[E_{1},E_{2},E_{5},E_{10}]$，四舍五入到六位小数。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每个元素是对应一个测试用例的包含四个误差的方括号列表，顺序为情况 A、B、C、D。例如，正确格式的输出应类似于\n$[[e_{A,1},e_{A,2},e_{A,5},e_{A,10}],[e_{B,1},e_{B,2},e_{B,5},e_{B,10}],[e_{C,1},e_{C,2},e_{C,5},e_{C,10}],[e_{D,1},e_{D,2},e_{D,5},e_{D,10}]]$，\n该行中不含任何空格。\n\n单位：\n- 此问题不要求使用物理单位。\n\n角度单位：\n- 不适用。\n\n百分比：\n- 不适用；所有量均以小数表示。\n\n您的实现必须是自包含的，并且不需要用户输入、外部文件或网络访问。它必须在现代编程语言中运行，并以单行形式生成上文描述的精确最终输出格式。", "solution": "此问题的目标是计算一组平移高斯脉冲快照的秩-$r$近似的相对重构误差。其基本原理是，在弗罗贝尼乌斯范数定义的最小二乘意义下，快照矩阵 $\\mathbf{X}$ 的最佳秩-$r$近似 $\\mathbf{X}_r$ 是通过其奇异值分解（SVD）得到的，这一结果由Eckart-Young-Mirsky定理保证。\n\n计算过程分为几个步骤。首先，根据问题定义的参数（空间域 $[-L, L]$，时间域 $[0, T]$，离散化点数 $N_x$ 和 $m$，以及平移速度 $c$），我们构建快照矩阵 $\\mathbf{X} \\in \\mathbb{R}^{N_x \\times m}$。该矩阵的每一列都是在特定时间点 $t_k$ 采样的函数 $u(x,t_k) = \\exp(-(x - c t_k)^2)$ 的空间离散值。\n\n其次，对快照矩阵 $\\mathbf{X}$ 进行SVD，得到 $\\mathbf{X} = \\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$，并提取奇异值 $\\sigma_i$。\n\n最后，利用奇异值计算相对重构误差 $E_r$。弗罗贝尼乌斯范数与奇异值之间存在关系 $\\lVert \\mathbf{A} \\rVert_F^2 = \\sum_{i} \\sigma_i(\\mathbf{A})^2$。因此，误差可以高效地计算为：\n$$E_r = \\frac{\\lVert \\mathbf{X} - \\mathbf{X}_r \\rVert_F}{\\lVert \\mathbf{X} \\rVert_F} = \\frac{\\sqrt{\\sum_{i=r+1}^{k} \\sigma_i^2}}{\\sqrt{\\sum_{i=1}^{k} \\sigma_i^2}}$$\n其中 $k$ 是矩阵 $\\mathbf{X}$ 的秩。这个公式避免了显式构造近似矩阵 $\\mathbf{X}_r$，使得计算更直接、数值更稳定。对每个测试用例，我们执行这些步骤，计算出特定秩 $r \\in \\{1, 2, 5, 10\\}$ 对应的误差，并按要求格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the Proper Orthogonal Decomposition problem for a translating Gaussian pulse.\n    \"\"\"\n    # Global parameters for all test cases\n    L = 10.0\n    Nx = 401\n    ranks_to_compute = [1, 2, 5, 10]\n\n    # Test suite: (c, T, m)\n    # c: speed, T: final time, m: number of snapshots\n    test_cases = [\n        (0.0, 5.0, 50),   # Case A: stationary pulse\n        (0.5, 10.0, 100), # Case B: slow translation\n        (2.0, 4.0, 80),   # Case C: fast translation\n        (0.5, 10.0, 5),   # Case D: few snapshots\n    ]\n\n    all_results = []\n\n    for c, T, m in test_cases:\n        # 1. Create spatial and temporal grids\n        x = np.linspace(-L, L, Nx)\n        t = np.linspace(0.0, T, m)\n\n        # 2. Construct the snapshot matrix X using broadcasting\n        # x_col has shape (Nx, 1) and t_row has shape (1, m)\n        # Broadcasting expands them to (Nx, m) for element-wise operations\n        x_col = x[:, np.newaxis]\n        t_row = t[np.newaxis, :]\n        X = np.exp(-((x_col - c * t_row) ** 2))\n\n        # 3. Compute the singular values of X\n        # We only need the singular values, so compute_uv=False is most efficient.\n        s = np.linalg.svd(X, compute_uv=False)\n        num_singular_values = s.shape[0]\n\n        # 4. Calculate the total energy (squared Frobenius norm of X)\n        # This is the sum of the squares of all singular values.\n        norm_X_sq = np.sum(s**2)\n\n        case_errors = []\n        for r in ranks_to_compute:\n            # 5. Calculate the reconstruction error for rank r\n            \n            # If norm_X_sq is zero, all errors are zero.\n            if norm_X_sq == 0.0:\n                 error = 0.0\n            # If rank r is >= number of singular values, the approximation is perfect.\n            elif r >= num_singular_values:\n                error = 0.0\n            else:\n                # The error norm is based on the truncated singular values (from r to end).\n                # s[r:] corresponds to sigma_{r+1}, sigma_{r+2}, ...\n                norm_err_sq = np.sum(s[r:]**2)\n                error = np.sqrt(norm_err_sq / norm_X_sq)\n            \n            case_errors.append(error)\n\n        all_results.append(case_errors)\n\n    # 6. Format the output string exactly as specified.\n    # e.g., [[err1,err2,...],[err1,err2,...]] with no spaces.\n    formatted_sublists = []\n    for res_list in all_results:\n        # Format each number to 6 decimal places.\n        formatted_numbers = [f\"{err:.6f}\" for err in res_list]\n        # Join numbers with commas and enclose in brackets.\n        formatted_sublists.append(f\"[{','.join(formatted_numbers)}]\")\n    \n    # Join the sublists with commas and enclose in outer brackets.\n    final_output = f\"[{','.join(formatted_sublists)}]\"\n\n    print(final_output)\n\nsolve()\n```", "id": "3265968"}, {"introduction": "最后的练习将带您从数据重构的层面深入到动态预测的层面，并揭示一个降阶建模中常见但非常关键的陷阱。在这个练习中，我们将精心设计一个场景：一个完全稳定的全阶模型，其快照数据可以被POD基精确地表示，然而通过伽辽金投影构建的降阶模型（ROM）却会变得不稳定，导致结果发散。这个练习明确地表明，模型的稳定性不会在伽辽金投影下降阶后被自动保证，尤其对于具有非正规（non-normal）算子的系统更是如此，这强调了对最终ROM进行稳定性分析的必要性。", "problem": "要求您实现一个完整的降阶建模数值实验，用以展示以下现象：对于一个稳定的全阶线性时不变系统，本征正交分解（POD）基对于重构训练快照可以表现出色，然而，通过伽辽金投影得到的降阶模型（ROM）在进行时间积分时却可能产生不稳定的、会发生爆破的动力学行为。\n\n您的实现必须从全阶常微分方程开始\n$$\n\\frac{d\\mathbf{x}}{dt} = \\mathbf{A}\\mathbf{x} + \\mathbf{b},\n$$\n其中 $\\mathbf{A}\\in\\mathbb{R}^{n\\times n}$ 和 $\\mathbf{b}\\in\\mathbb{R}^{n}$ 是常数，$\\mathbf{x}(t)\\in\\mathbb{R}^{n}$ 是状态。所有计算都在实数域上进行，使用标准的欧几里得内积。在整个过程中，您将使用 $n=2$。\n\n基本定义与要求：\n- 本征正交分解 (POD) 基：给定一个快照矩阵\n$$\n\\mathbf{X} = \\begin{bmatrix}\\mathbf{x}(t_1)  \\mathbf{x}(t_2)  \\cdots  \\mathbf{x}(t_m)\\end{bmatrix}\\in\\mathbb{R}^{n\\times m},\n$$\n计算其奇异值分解 (SVD) $\\mathbf{X}=\\mathbf{U}\\mathbf{\\Sigma}\\mathbf{V}^\\top$。秩为 $r$ 的 POD 基 $\\mathbf{Q}\\in\\mathbb{R}^{n\\times r}$ 取自 $\\mathbf{U}$ 的前 $r$ 列。\n- 伽辽金投影：降阶算子和降阶强迫项为\n$$\n\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}\\in\\mathbb{R}^{r\\times r},\\qquad \\mathbf{b}_r=\\mathbf{Q}^\\top\\mathbf{b}\\in\\mathbb{R}^{r}.\n$$\n降阶状态 $\\mathbf{z}(t)\\in\\mathbb{R}^{r}$ 的演化遵循\n$$\n\\frac{d\\mathbf{z}}{dt} = \\mathbf{A}_r \\mathbf{z} + \\mathbf{b}_r,\\qquad \\mathbf{x}_r(t)=\\mathbf{Q}\\mathbf{z}(t).\n$$\n- 时间积分：对全阶模型和降阶模型均使用固定的时间步长 $h>0$ 的经典四阶龙格－库塔方法。将初始条件设置为 $\\mathbf{x}(0)=\\mathbf{0}$ 和 $\\mathbf{z}(0)=\\mathbf{Q}^\\top\\mathbf{x}(0)=\\mathbf{0}$。\n- 快照采集：在训练时域 $[0,T_{\\text{train}}]$ 上以恒定的时间步长 $h$ 对全阶模型进行积分，在每一步对状态进行采样以构成 $\\mathbf{X}$。\n- 重构误差：将训练快照的相对 POD 重构误差度量为\n$$\n\\varepsilon_{\\text{rec}} = \\frac{\\lVert \\mathbf{X} - \\mathbf{Q}\\mathbf{Q}^\\top \\mathbf{X}\\rVert_F}{\\lVert \\mathbf{X}\\rVert_F},\n$$\n其中 $\\lVert\\cdot\\rVert_F$ 表示弗罗贝尼乌斯范数。\n- 爆破检测：在测试时域 $[0,T_{\\text{test}}]$ 上以相同的 $h$ 对全阶模型和降阶模型进行演化。如果在任何时间步，当前状态的欧几里得范数超过阈值 $M$，或者任何分量变为非数值（not-a-number）或无穷大，则声明解“已爆破”。使用阈值 $M=10^6$。\n\n为针对降阶模型的不稳定性而构造的强迫项：\n- 对于每次测试，您必须按如下方式构造恒定强迫项 $\\mathbf{b}$。计算对称部分 $\\mathbf{S}=\\frac{1}{2}(\\mathbf{A}+\\mathbf{A}^\\top)$ 及其与 $\\mathbf{S}$ 的最大特征值相关的主单位特征向量 $\\mathbf{q}\\in\\mathbb{R}^{n}$（以任意但确定的方式处理并列情况）。设置\n$$\n\\mathbf{b}=-\\mathbf{A}\\mathbf{q}.\n$$\n这种构造确保了全阶稳态为 $\\mathbf{x}_\\infty = -\\mathbf{A}^{-1}\\mathbf{b}=\\mathbf{q}$。当 $\\mathbf{A}$ 是高度非正规的且 $\\mathbf{S}$ 的最大特征值为正时，用 $r=1$ 和 $\\mathbf{Q}=\\mathbf{q}$ 得到的标量降阶模型具有降阶动力学 $\\frac{dz}{dt} = a_r z + b_r$，其中 $a_r=\\mathbf{q}^\\top\\mathbf{A}\\mathbf{q}>0$ 和 $b_r=-a_r$，这是不稳定的，并会从 $z(0)=0$ 发散。\n\n所有测试通用的数值规范：\n- 使用 $n=2$。\n- 使用 $h=10^{-3}$。\n- 使用经典四阶龙格－库塔方法。\n- 对所有向量范数均使用欧几里得范数。\n- 使用 $\\mathbf{x}(0)=\\mathbf{0}$。\n\n测试组：\n为以下参数集实现上述过程。在每种情况下，定义 $\\mathbf{A}$，按规定计算 $\\mathbf{q}$ 和 $\\mathbf{b}$，在 $[0,T_{\\text{train}}]$ 上采集快照以构成 $\\mathbf{Q}$，然后构建降阶模型并在 $[0,T_{\\text{test}}]$ 上运行两个模型。\n\n- 测试 1（高度非正规，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 2（高度非正规，秩为2的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=50.0$，\n  - $r=2$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 3（对称负定，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-1.0  0.0 \\\\ 0.0  -2.0\\end{bmatrix}$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n- 测试 4（更高度非正规，秩为1的POD）：\n  - $\\mathbf{A}=\\begin{bmatrix}-0.1  \\alpha \\\\ 0  -1.0\\end{bmatrix}$，其中 $\\alpha=120.0$，\n  - $r=1$，\n  - $T_{\\text{train}}=4.0$，\n  - $T_{\\text{test}}=1.0$。\n\n要求的输出：\n- 对于每次测试，输出一个包含三个条目的列表：\n  - 标量 $\\varepsilon_{\\text{rec}}$，四舍五入到六位小数，\n  - 一个布尔值，指示降阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破，\n  - 一个布尔值，指示全阶模型是否在 $[0,T_{\\text{test}}]$ 上发生爆破。\n- 将所有测试的结果汇总到一行，格式为由方括号括起来的逗号分隔列表，顺序与测试顺序相同。示例格式：\n$[\\,[\\varepsilon_{\\text{rec}}^{(1)},\\,\\text{ROM}^{(1)}\\_\\text{blowup},\\,\\text{FOM}^{(1)}\\_\\text{blowup}],\\,[\\varepsilon_{\\text{rec}}^{(2)},\\,\\text{ROM}^{(2)}\\_\\text{blowup},\\,\\text{FOM}^{(2)}\\_\\text{blowup}],\\,\\ldots\\,]$.", "solution": "本数值实验旨在揭示一个降阶建模中的关键现象：一个稳定的全阶模型（FOM）在经过伽辽金投影后，其降阶模型（ROM）可能会变得不稳定。这种现象通常与系统的动力学矩阵 $\\mathbf{A}$ 的非正规性（non-normality, 即 $\\mathbf{A}\\mathbf{A}^\\top \\neq \\mathbf{A}^\\top\\mathbf{A}$）有关。\n\n核心原理在于矩阵谱（eigenvalues）与数值范围（numerical range）之间的区别。系统的长期稳定性由 $\\mathbf{A}$ 的谱决定——若所有特征值实部为负，则系统稳定。然而，降阶模型的稳定性由降阶矩阵 $\\mathbf{A}_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 的谱决定。$\\mathbf{A}_r$ 的特征值不一定与 $\\mathbf{A}$ 的特征值有直接关系，但它们必然位于 $\\mathbf{A}$ 的数值范围之内。对于非正规矩阵，其数值范围可能延伸到右半复平面，即使其所有特征值都在左半平面。\n\n本问题的构造巧妙地利用了这一点。通过特定的强迫项 $\\mathbf{b}$，全阶系统的动力学被引导至瞬态增长最强的方向。因此，从仿真快照中提取的主导POD模态 $\\mathbf{Q}$（对于 $r=1$）会近似对齐这个方向。当我们将原始矩阵 $\\mathbf{A}$ 投影到这个子空间上时，得到的标量降阶算子 $a_r = \\mathbf{Q}^\\top\\mathbf{A}\\mathbf{Q}$ 可能会有一个正实部，从而导致降阶模型不稳定并最终“爆破”。\n\n计算流程遵循问题描述：首先根据给定的 $\\mathbf{A}$ 构造强迫项 $\\mathbf{b}$；然后通过对FOM进行时间积分生成训练快照 $\\mathbf{X}$；接着通过SVD计算POD基 $\\mathbf{Q}$ 并评估重构误差；最后，构建ROM并分别对FOM和ROM进行时间积分，以检测是否发生不稳定性。\n\n实验中的不同测试用例旨在对比：\n- **测试 1 & 4**（非正规, r=1）：预期ROM不稳定。\n- **测试 2**（非正规, r=2）：由于 $r=n=2$，ROM与FOM动力学等价，预期ROM稳定。\n- **测试 3**（对称, r=1）：由于 $\\mathbf{A}$ 是正规的，其数值范围不进入右半平面，预期ROM稳定。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.linalg import eigh\n\ndef solve():\n    \"\"\"\n    Implements the full numerical experiment to demonstrate ROM instability\n    for a stable FOM.\n    \"\"\"\n\n    def rk4_step(f, y, h, A, b):\n        \"\"\"A single step of the classical fourth-order Runge-Kutta method.\"\"\"\n        k1 = f(y, A, b)\n        k2 = f(y + h / 2 * k1, A, b)\n        k3 = f(y + h / 2 * k2, A, b)\n        k4 = f(y + h * k3, A, b)\n        return y + h / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n\n    def lti_rhs(y, A, b):\n        \"\"\"RHS of the LTI system dy/dt = Ay + b.\"\"\"\n        return A @ y + b\n\n    def simulate(A, b, y0, T, h, M):\n        \"\"\"\n        Simulates an LTI system and returns snapshots and blow-up status.\n        \"\"\"\n        num_steps = int(T / h)\n        y = y0.copy()\n        snapshots = [y0.copy()]\n        blew_up = False\n        \n        for _ in range(num_steps):\n            y = rk4_step(lti_rhs, y, h, A, b)\n            if np.linalg.norm(y) > M or not np.all(np.isfinite(y)):\n                blew_up = True\n                # Continue collecting snapshots to see the blow-up, if needed for X\n                # But stop checking once blown up.\n                # Fill remaining snapshots to maintain matrix size if blow-up occurs mid-simulation\n                blown_up_y = y.copy()\n                while len(snapshots) < num_steps + 1:\n                    snapshots.append(blown_up_y)\n                return np.array(snapshots).T, True\n\n            snapshots.append(y.copy())\n            \n        return np.array(snapshots).T, blew_up\n\n    # General parameters\n    n = 2\n    h = 1e-3\n    M = 1e6\n    x0 = np.zeros(n)\n\n    # Test cases from the problem statement.\n    test_cases = [\n        # (A_params, r, T_train, T_test)\n        ({\"alpha\": 50.0}, 1, 4.0, 1.0),\n        ({\"alpha\": 50.0}, 2, 4.0, 1.0),\n        ({\"alpha\": None}, 1, 4.0, 1.0), # Symmetric case\n        ({\"alpha\": 120.0}, 1, 4.0, 1.0),\n    ]\n\n    results = []\n    \n    for i, (params, r, T_train, T_test) in enumerate(test_cases):\n        # 1. Define A\n        if i == 2: # Test 3: Symmetric case\n            A = np.array([[-1.0, 0.0], [0.0, -2.0]])\n        else: # Tests 1, 2, 4: Non-normal case\n            alpha = params[\"alpha\"]\n            A = np.array([[-0.1, alpha], [0.0, -1.0]])\n\n        # 2. Construct b\n        S = 0.5 * (A + A.T)\n        eigvals, eigvecs = eigh(S)\n        q = eigvecs[:, -1] # Dominant eigenvector (eigh sorts eigenvalues)\n        b = -A @ q\n\n        # 3. Generate FOM snapshots for training\n        X, _ = simulate(A, b, x0, T_train, h, M)\n\n        # 4. Compute POD basis Q\n        U, s, _ = np.linalg.svd(X, full_matrices=False)\n        Q = U[:, :r]\n\n        # 5. Calculate reconstruction error\n        # eps_rec = norm(X - Q @ Q.T @ X) / norm(X)\n        # Using singular values is more direct: sqrt(sum(s_i^2 for i>r)) / sqrt(sum(s_i^2))\n        if X.shape[1] > 1:\n            norm_X_sq = np.sum(s**2)\n            if norm_X_sq > 0:\n                norm_err_sq = np.sum(s[r:]**2)\n                eps_rec = np.sqrt(norm_err_sq / norm_X_sq)\n            else:\n                eps_rec = 0.0\n        else:\n            eps_rec = 0.0\n\n        # 6. Form the ROM\n        Ar = Q.T @ A @ Q\n        br = Q.T @ b\n        z0 = np.zeros(r)\n\n        # 7. Simulate FOM and ROM for testing, check blow-up\n        _, fom_blew_up = simulate(A, b, x0, T_test, h, M)\n        _, rom_blew_up = simulate(Ar, br, z0, T_test, h, M)\n\n        # 8. Record results\n        results.append([round(eps_rec, 6), rom_blew_up, fom_blew_up])\n\n    # Final print statement in the exact required format.\n    # Convert bools to lowercase 'true'/'false'\n    formatted_results = []\n    for res in results:\n        eps_str = f\"{res[0]:.6f}\"\n        rom_bool_str = str(res[1]).lower()\n        fom_bool_str = str(res[2]).lower()\n        formatted_results.append(f\"[{eps_str},{rom_bool_str},{fom_bool_str}]\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "2432128"}]}