{"hands_on_practices": [{"introduction": "预条件处理的核心思想是通过变换线性系统来改善其矩阵的谱特性，从而加速迭代求解器的收敛。这个练习将通过一个经典的二维泊松方程实例，让你亲手构建并分析最基础的对角缩放预条件子。通过从第一性原理出发进行理论预测，并编写代码进行数值验证，你将深刻理解预条件处理如何通过消除网格尺寸依赖性来聚集特征值，这是提升求解效率的关键一步。[@problem_id:3176221]", "problem": "您的任务是分析并实现一个对角缩放预条件子，用于在单位正方形上离散化的二维（$2D$）泊松方程，该方程具有齐次狄利克雷边界条件。考虑标准的 $5$ 点有限差分离散化，它产生一个对称正定（$SPD$）线性系统 $A\\boldsymbol{u}=\\boldsymbol{b}$，其中 $A\\in\\mathbb{R}^{N\\times N}$ 且 $N=n^2$，$n$ 是每个空间维度上的内部网格点数，网格间距为 $h=1/(n+1)$。定义对角缩放预条件子为 $M=\\operatorname{diag}(A)$。您的目标是：\n- 从离散拉普拉斯算子的定义以及关于相似变换和特征值的基本线性代数知识出发，推导出一个预测：当 $n$ 增加时，与 $A$ 的谱相比，$M^{-1}A$ 的谱是如何聚集的。您的预测必须从第一性原理出发进行推理，明确引用离散算子如何随 $h$ 缩放，以及对角缩放如何改变这种依赖关系。\n- 实现一个完整的、可运行的程序，该程序：\n  1. 对于给定的 $n$，使用单位正方形上的规范 $5$ 点模板（具有零狄利克雷边界条件）构造 $A$。\n  2. 构造 $M=\\operatorname{diag}(A)$，并通过相似对称矩阵 $M^{-1/2}AM^{-1/2}$ 评估预处理算子的谱。\n  3. 对每个矩阵，计算由 $\\max\\lambda-\\min\\lambda$ 定义的谱区间宽度，其中 $\\lambda$ 遍历所有特征值。令 $w(A)$ 表示 $A$ 的宽度，$w(M^{-1}A)$ 表示预处理算子的宽度。\n  4. 对每个测试用例，报告浮点数三元组 $\\left[w(A),\\,w(M^{-1}A),\\,w(A)/w(M^{-1}A)\\right]$。\n\n使用以下网格尺寸的测试套件，以确保覆盖一个小的边界情况和逐渐增大的实例：$n\\in\\{2,4,8,16\\}$。这些案例捕捉了一个非常小的 $n$ 的边界条件、一个典型的中等案例以及一个可以看到缩放效应的较大案例。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果，每个测试用例本身打印为一个包含三个浮点数的嵌套列表，小数点后保留六位数字，且无空格。例如，输出格式必须为 $\\left[[a_1,b_1,c_1],[a_2,b_2,c_2],\\dots\\right]$，其中每个 $a_i$、$b_i$ 和 $c_i$ 都是浮点数。不涉及任何物理单位或角度单位，所有输出均为纯数字。解决方案必须仅使用数值线性代数和泊松方程有限差分离散化的有效基础定义来证明关于谱聚集的预测，避免使用问题陈述中直接给出的任何快捷公式。", "solution": "我们从单位正方形上具有齐次狄利克雷边界条件的二维离散拉普拉斯算子的定义开始。令 $n$ 表示每个空间维度上的内部网格点数，$h=1/(n+1)$ 表示均匀网格间距。标准的 $5$ 点有限差分离散化对内部节点 $(i,j)$ 得到如下关系式\n$$\n-\\frac{1}{h^2}\\,u_{i-1,j} - \\frac{1}{h^2}\\,u_{i,j-1} + \\frac{4}{h^2}\\,u_{i,j} - \\frac{1}{h^2}\\,u_{i+1,j} - \\frac{1}{h^2}\\,u_{i,j+1} \\;=\\; f_{i,j},\n$$\n它产生一个 $N\\times N$ 的稀疏矩阵 $A$，其中 $N=n^2$，对角线元素等于 $4/h^2$，非对角线元素等于 $-1/h^2$，对应于 $x$ 和 $y$ 方向上最近邻的耦合。该矩阵是对称正定（$SPD$）的，因为它源于一个强制双线性形式和一个协调离散化。\n\n数值线性代数的基本事实告诉我们，特征值在标量乘法下会进行缩放，且相似矩阵具有相同的特征值。具体来说，如果 $D=\\operatorname{diag}(A)$ 且 $M=D$，那么 $M^{-1}A$ 与对称矩阵\n$$\nS \\;=\\; M^{-1/2}AM^{-1/2},\n$$\n相似，因此 $M^{-1}A$ 和 $S$ 具有相同的谱。因为 $S$ 是对称的，所以它的特征值是实数，可以高数值可靠性地进行分析和计算。\n\n为了从第一性原理预测谱的聚集，我们对 $A$ 的缩放行为进行推理。有限差分模板显示 $A$ 的所有元素都按 $1/h^2$ 的比例缩放。因此，$A$ 的特征值也按 $1/h^2$ 的比例缩放；也就是说，存在依赖于模式的无量纲常数 $\\alpha_{\\min}(n)$ 和 $\\alpha_{\\max}(n)$，使得\n$$\n\\lambda_{\\min}(A) \\approx \\frac{\\alpha_{\\min}(n)}{h^2},\\qquad\n\\lambda_{\\max}(A) \\approx \\frac{\\alpha_{\\max}(n)}{h^2}.\n$$\n随着 $n$ 的增加（以及 $h$ 的减小），$\\lambda_{\\min}(A)$ 和 $\\lambda_{\\max}(A)$ 都以 $1/h^2$ 的速度增长，谱区间宽度 $w(A)=\\lambda_{\\max}(A)-\\lambda_{\\min}(A)$ 也以 $1/h^2$ 的速度增长。因此，随着网格的加密，$A$ 的谱会无限扩展。\n\n使用 $M=\\operatorname{diag}(A)$ 进行对角缩放可以抵消这个统一的 $1/h^2$ 因子。在当前的离散化中，对角线元素始终为 $4/h^2$，因此\n$$\nM \\;=\\; \\frac{4}{h^2}\\,I,\n\\qquad\nM^{-1/2} \\;=\\; \\sqrt{\\frac{h^2}{4}}\\,I.\n$$\n因此\n$$\nS \\;=\\; M^{-1/2}AM^{-1/2}\n\\;=\\; \\left(\\sqrt{\\frac{h^2}{4}}\\,I\\right)\\,A\\,\\left(\\sqrt{\\frac{h^2}{4}}\\,I\\right)\n\\;=\\; \\frac{h^2}{4}\\,A.\n$$\n通过特征值的标量缩放，我们得到\n$$\n\\lambda(S) \\;=\\; \\frac{h^2}{4}\\,\\lambda(A),\n\\qquad\n\\lambda(M^{-1}A) \\;=\\; \\lambda(S).\n$$\n这表明 $M^{-1}A$ 的整个谱是通过将 $A$ 的谱乘以 $h^2/4$ 得到的。由于 $A$ 的特征值按 $1/h^2$ 的比例缩放，$M^{-1}A$ 的谱变为 $\\mathcal{O}(1)$，即与 $h$ 和 $n$ 无关且有界。在经典的二维 Dirichlet 情况下，模式结构意味着随着 $n$ 的增长，预处理后的特征值位于一个趋近于 $(0,2)$ 的区间内。直观上，这是因为 $M^{-1}A$ 具有单位对角线和大小为 $1/4$ 的最近邻耦合，因此大多数特征值都聚集在 $1$ 附近，且散布范围有界。相比之下，未预处理的谱随着 $h\\to 0$ 而无限展宽。\n\n然而，当映射回 $A$ 的原始尺度时，最小的预处理特征值仍然像 $\\mathcal{O}(h^2)$ 一样趋于零，而在预处理尺度下，它的行为类似于两个最低模式正弦平方和，对于大的 $n$，其行为类似于 $\\mathcal{O}((n+1)^{-2})$。因此，$M^{-1}A$ 的条件数像 $\\mathcal{O}(n^2)$ 一样增长，正如 $A$ 的条件数一样。对角缩放的主要好处，正如在许多迭代方法的收敛中所反映的，是将大部分特征值聚集到 $1$ 附近的一个有界区间内，并移除了全局的 $1/h^2$ 缩放，而不是消除了所有条件问题。\n\n程序的算法设计：\n- 对于测试套件中的每个 $n$，构建一维三对角矩阵 $T\\in\\mathbb{R}^{n\\times n}$，其对角线元素为 $2/h^2$，次对角线元素为 $-1/h^2$。二维算子通过克罗内克和 $A=I\\otimes T+T\\otimes I$ 组装而成，其中 $I$ 是 $n\\times n$ 的单位矩阵。\n- 提取 $D=\\operatorname{diag}(A)$，并通过将 $A$ 的一个密集副本的行和列按 $D$ 的逆平方根进行缩放，隐式地构造 $S=D^{-1/2}AD^{-1/2}$。\n- 使用对称特征值例程（实 Hermitian）计算 $A$ 和 $S$ 的特征值，然后计算谱宽度 $w(A)$ 和 $w(S)=w(M^{-1}A)$ 以及比率 $w(A)/w(M^{-1}A)$。\n- 将结果汇总为所需的单行输出格式，每个测试用例报告为 $\\left[w(A),\\,w(M^{-1}A),\\,w(A)/w(M^{-1}A)\\right]$。\n\n这个过程直接证明了理论预测：$w(A)$ 以 $1/h^2$ 的速度增长，而 $w(M^{-1}A)$ 保持有界且接近一个常数，导致比率 $w(A)/w(M^{-1}A)$ 以 $1/h^2$ 的速度增长，从而定量地说明了在对角缩放下的更强谱聚集效应。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import sparse as sp\n\ndef build_poisson_2d(n: int) -> sp.csr_matrix:\n    \"\"\"\n    Build the 2D Poisson finite difference matrix A on the unit square\n    with zero Dirichlet boundary conditions using the 5-point stencil.\n    Size is N = n^2, where n is the number of interior points per dimension.\n    \"\"\"\n    h = 1.0 / (n + 1)\n    e = np.ones(n)\n    # 1D tridiagonal: diag = 2/h^2, off-diag = -1/h^2\n    T = sp.diags([-e, 2.0 * e, -e], offsets=[-1, 0, 1], shape=(n, n), format='csr') / (h**2)\n    I = sp.eye(n, format='csr')\n    # 2D operator: Kronecker sum\n    A = sp.kron(I, T, format='csr') + sp.kron(T, I, format='csr')\n    return A\n\ndef spectral_width(evals: np.ndarray) -> float:\n    \"\"\"Compute spectral interval width: max(lambda) - min(lambda).\"\"\"\n    return float(np.max(evals) - np.min(evals))\n\ndef compute_metrics_for_n(n: int):\n    \"\"\"\n    For given n, construct A, preconditioner M=diag(A),\n    and compute spectral widths for A and M^{-1}A via the similar symmetric matrix.\n    Return [wA, wPre, wA_over_wPre] as floats.\n    \"\"\"\n    A = build_poisson_2d(n)\n    # Dense copy for eigenvalue computations (SPD, modest sizes)\n    A_dense = A.toarray()\n    # Eigenvalues of A (symmetric)\n    evals_A = np.linalg.eigvalsh(A_dense)\n\n    # Diagonal preconditioner M = diag(A), construct S = M^{-1/2} A M^{-1/2}\n    d = A.diagonal()\n    inv_sqrt_d = 1.0 / np.sqrt(d)\n    # Scale rows and columns: S = D^{-1/2} * A_dense * D^{-1/2}\n    S = (inv_sqrt_d[:, None] * A_dense) * inv_sqrt_d[None, :]\n    evals_S = np.linalg.eigvalsh(S)\n\n    wA = spectral_width(evals_A)\n    wPre = spectral_width(evals_S)\n    ratio = wA / wPre\n    return [wA, wPre, ratio]\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_ns = [2, 4, 8, 16]\n\n    results = []\n    for n in test_ns:\n        wA, wPre, ratio = compute_metrics_for_n(n)\n        # Round to 6 decimal places as specified for output formatting\n        metrics = [round(wA, 6), round(wPre, 6), round(ratio, 6)]\n        results.append(metrics)\n\n    # Build exact required single-line output: no spaces, nested lists\n    formatted = \"[\" + \",\".join(\"[\" + \",\".join(f\"{x:.6f}\" for x in triple) + \"]\" for triple in results) + \"]\"\n    print(formatted)\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3176221"}, {"introduction": "尽管预条件处理通常是有效的，但一个常见的误解是它总能改善问题。本练习旨在打破这一迷思，通过一个精心设计的非对称矩阵，展示了即便是最简单的对角（Jacobi）预条件子有时也可能恶化矩阵的条件数。通过亲手计算和比较预处理前后的条件数，你将体会到预条件子的选择必须与矩阵本身的结构（如对称性）相匹配，从而培养对算法选择的批判性思维。[@problem_id:2429417]", "problem": "在许多计算物理应用中，例如稳态对流扩散算子的迎风离散化，所得到的线性系统可能是不对称的，且对角线元素严重不平衡。一种常见的对角（雅可比）预处理器通过对角线元素的倒数来缩放行。虽然预处理通常旨在改善迭代求解器的收敛性，但它并不能普遍地减小矩阵的 $2$-范数条件数。\n\n从核心定义开始：\n- 一个非奇异矩阵 $X$ 的 $2$-范数条件数是 $\\kappa_{2}(X) = \\sigma_{\\max}(X)/\\sigma_{\\min}(X)$，其中 $\\sigma_{\\max}(X)$ 和 $\\sigma_{\\min}(X)$ 分别是 $X$ 的最大和最小奇异值。\n- $X$ 的奇异值是 $X^{\\mathsf{T}}X$ 特征值的平方根。\n- 雅可比预处理器 $P$ 是由 $A$ 的对角线形成的对角矩阵，左预处理算子是 $P^{-1}A$。\n\n考虑显式的 $2 \\times 2$ 矩阵\n$$\nA = \\begin{pmatrix}\n1  10 \\\\\n0.19  2\n\\end{pmatrix},\n$$\n这是一个具有不均衡对角缩放的局部迎风输运算子的简单模型。令 $P = \\operatorname{diag}(A) = \\operatorname{diag}(1, 2)$ 为雅可比预处理器，并定义 $B = P^{-1} A$。\n\n仅使用上述定义（不得假定其他公式），计算比率\n$$\nR \\equiv \\frac{\\kappa_{2}(P^{-1}A)}{\\kappa_{2}(A)} = \\frac{\\kappa_{2}(B)}{\\kappa_{2}(A)}.\n$$\n报告 $R$ 的最终数值，四舍五入到四位有效数字。答案是无量纲的；不要包含任何单位。", "solution": "问题陈述已经过验证，被认为是有效的。它在数值线性代数方面有科学依据，问题设定良好，提供了所有必要信息，并且表述客观。不存在不一致、模糊或事实错误。我们按要求进行计算。\n\n任务是计算比率 $R = \\frac{\\kappa_{2}(B)}{\\kappa_{2}(A)}$，其中 $A = \\begin{pmatrix} 1  10 \\\\ 0.19  2 \\end{pmatrix}$ 且 $B = P^{-1}A$，而 $P = \\operatorname{diag}(A)$。计算将分两个阶段进行：首先是矩阵 $A$，然后是矩阵 $B$。\n\n首先，我们确定条件数 $\\kappa_2(A)$。根据所给定义，$A$ 的奇异值是 $A^{\\mathsf{T}}A$ 特征值的平方根。\n$A$ 的转置是 $A^{\\mathsf{T}} = \\begin{pmatrix} 1  0.19 \\\\ 10  2 \\end{pmatrix}$。\n我们计算乘积 $A^{\\mathsf{T}}A$：\n$$\nA^{\\mathsf{T}}A = \\begin{pmatrix} 1  0.19 \\\\ 10  2 \\end{pmatrix} \\begin{pmatrix} 1  10 \\\\ 0.19  2 \\end{pmatrix} = \\begin{pmatrix} 1^2 + 0.19^2  1 \\cdot 10 + 0.19 \\cdot 2 \\\\ 10 \\cdot 1 + 2 \\cdot 0.19  10^2 + 2^2 \\end{pmatrix} = \\begin{pmatrix} 1.0361  10.38 \\\\ 10.38  104 \\end{pmatrix}\n$$\n$A^{\\mathsf{T}}A$ 的特征值（记为 $\\lambda$）是特征方程 $\\det(A^{\\mathsf{T}}A - \\lambda I) = 0$ 的根：\n$$\n(1.0361 - \\lambda)(104 - \\lambda) - (10.38)^2 = 0\n$$\n$$\n\\lambda^2 - (1.0361 + 104)\\lambda + (1.0361 \\cdot 104 - 10.38^2) = 0\n$$\n$$\n\\lambda^2 - 105.0361\\lambda + (107.7544 - 107.7444) = 0\n$$\n$$\n\\lambda^2 - 105.0361\\lambda + 0.01 = 0\n$$\n使用二次公式，特征值为 $\\lambda = \\frac{105.0361 \\pm \\sqrt{105.0361^2 - 4(0.01)}}{2}$。\n两个特征值是 $\\lambda_{\\max, A} \\approx 105.0360048$ 和 $\\lambda_{\\min, A} \\approx 9.52054 \\times 10^{-5}$。\n$A$ 的奇异值是 $\\sigma_{\\max}(A) = \\sqrt{\\lambda_{\\max, A}}$ 和 $\\sigma_{\\min}(A) = \\sqrt{\\lambda_{\\min, A}}$。\n因此，$A$ 的条件数是：\n$$\n\\kappa_2(A) = \\frac{\\sigma_{\\max}(A)}{\\sigma_{\\min}(A)} = \\sqrt{\\frac{\\lambda_{\\max, A}}{\\lambda_{\\min, A}}} \\approx \\sqrt{\\frac{105.0360048}{9.52054 \\times 10^{-5}}} \\approx \\sqrt{1103256} \\approx 1050.36\n$$\n\n接下来，我们确定条件数 $\\kappa_2(B)$。预处理器是 $P = \\operatorname{diag}(A) = \\begin{pmatrix} 1  0 \\\\ 0  2 \\end{pmatrix}$。\n其逆矩阵是 $P^{-1} = \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix}$。\n预处理后的矩阵 $B$ 是：\n$$\nB = P^{-1}A = \\begin{pmatrix} 1  0 \\\\ 0  0.5 \\end{pmatrix} \\begin{pmatrix} 1  10 \\\\ 0.19  2 \\end{pmatrix} = \\begin{pmatrix} 1  10 \\\\ 0.095  1 \\end{pmatrix}\n$$\n我们对 $B$ 采用相同的步骤。转置是 $B^{\\mathsf{T}} = \\begin{pmatrix} 1  0.095 \\\\ 10  1 \\end{pmatrix}$。\n乘积 $B^{\\mathsf{T}}B$ 是：\n$$\nB^{\\mathsf{T}}B = \\begin{pmatrix} 1  0.095 \\\\ 10  1 \\end{pmatrix} \\begin{pmatrix} 1  10 \\\\ 0.095  1 \\end{pmatrix} = \\begin{pmatrix} 1^2 + 0.095^2  1 \\cdot 10 + 0.095 \\cdot 1 \\\\ 10 \\cdot 1 + 1 \\cdot 0.095  10^2 + 1^2 \\end{pmatrix} = \\begin{pmatrix} 1.009025  10.095 \\\\ 10.095  101 \\end{pmatrix}\n$$\n$B^{\\mathsf{T}}B$ 的特征值（记为 $\\mu$）是特征方程 $\\det(B^{\\mathsf{T}}B - \\mu I) = 0$ 的根：\n$$\n(1.009025 - \\mu)(101 - \\mu) - (10.095)^2 = 0\n$$\n$$\n\\mu^2 - (1.009025 + 101)\\mu + (1.009025 \\cdot 101 - 10.095^2) = 0\n$$\n$$\n\\mu^2 - 102.009025\\mu + (101.911525 - 101.909025) = 0\n$$\n$$\n\\mu^2 - 102.009025\\mu + 0.0025 = 0\n$$\n特征值是 $\\mu = \\frac{102.009025 \\pm \\sqrt{102.009025^2 - 4(0.0025)}}{2}$。\n两个特征值是 $\\mu_{\\max, B} \\approx 102.0090005$ 和 $\\mu_{\\min, B} \\approx 2.45075 \\times 10^{-5}$。\n$B$ 的条件数是：\n$$\n\\kappa_2(B) = \\frac{\\sigma_{\\max}(B)}{\\sigma_{\\min}(B)} = \\sqrt{\\frac{\\mu_{\\max, B}}{\\mu_{\\min, B}}} \\approx \\sqrt{\\frac{102.0090005}{2.45075 \\times 10^{-5}}} \\approx \\sqrt{4162166.5} \\approx 2040.14\n$$\n\n最后，我们计算比率 $R$：\n$$\nR = \\frac{\\kappa_2(B)}{\\kappa_2(A)} \\approx \\frac{2040.14}{1050.36} \\approx 1.94233\n$$\n将最终结果四舍五入到四位有效数字，得到 $1.942$。", "answer": "$$\n\\boxed{1.942}\n$$", "id": "2429417"}, {"introduction": "在掌握了预条件处理的基本原理和潜在陷阱后，我们将深入探讨更强大预条件子的实际构建过程，例如不完全Cholesky（IC）分解。IC分解在理论上非常吸引人，但在实践中常因数值不稳定性（如出现小主元或负主元）而“崩溃”。本练习将引导你实现并比较几种应对这种崩溃的稳定化策略，包括对角修正和对称主元法，从而让你了解在构建高性能预条件子时，鲁棒性设计与理论效率同等重要。[@problem_id:3176187]", "problem": "您将实现并研究当小主元导致分解失败时，不完全分解的稳定性，并测试两种稳定化策略及其在所得预处理器矩阵中保持对称正定性（SPD）的效果。请以纯数学术语进行阐述，并实现一个完整的、可运行的程序来执行以下任务。\n\n从基本定义开始：\n- 一个实对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 是对称正定（SPD）的，如果对于所有非零 $\\boldsymbol{x} \\in \\mathbb{R}^{n}$，都有 $\\boldsymbol{x}^{\\top} A \\boldsymbol{x} \\gt 0$。\n- 如果 $A$ 是 SPD 矩阵，其（精确的）Cholesky 分解为 $A = L L^{\\top}$，其中 $L$ 是具有严格正对角元的下三角矩阵。\n- 零填充不完全 Cholesky 分解，记作 $\\mathrm{IC}(0)$，尝试计算 $A \\approx \\tilde{L} \\tilde{L}^{\\top}$，同时将 $\\tilde{L}$ 的稀疏模式限制在 $A$ 的稀疏模式内（在 $A$ 的非零模式之外不进行填充）。在算法的第 $j$ 步，主元计算如下：\n  $$ s_j \\equiv A_{j j} - \\sum_{k=0}^{j-1} \\tilde{L}_{j k}^2. $$\n  如果 $s_j$ 在数值上使用不安全，则宣布分解失败。\n- 在实践中，为避免数值不稳定性，算法可能会将任何小于指定阈值 $\\tau \\gt 0$ 的主元 $s_j$ 视为分解失败。\n\n在计算 $\\mathrm{IC}(0)$ 时，您将实现三种处理小主元 $s_j < \\tau$ 的策略：\n- 策略 $S_0$（无稳定化）：如果 $s_j < \\tau$，则宣布分解失败并停止。不生成预处理器。\n- 策略 $S_1$（对角位移）：如果 $s_j < \\tau$，用 $A_{j j} + \\delta$ 替换 $A_{j j}$，其中 $\\delta \\ge 0$ 是使新主元等于 $\\tau$ 的最小非负值，然后继续。这是一种修正的不完全 Cholesky 分解，它保持对称性并强制主元为正。\n- 策略 $S_2$（对称对角主元选择）：如果 $s_j < \\tau$，则在 $\\{j, j+1, \\dots, n-1\\}$ 中搜索一个 $p$，以最大化暂定主元\n  $$ \\hat{s}_p \\equiv A_{p p} - \\sum_{k=0}^{j-1} \\tilde{L}_{p k}^2, $$\n  然后应用一个对称置换来交换索引 $j$ 和 $p$（交换 $A$ 的第 $j$ 行和第 $p$ 行以及第 $j$ 列和第 $p$ 列；通过交换第 $j$ 行和第 $p$ 行来维护 $\\tilde{L}$ 已计算的第 $0$ 到 $j-1$ 列）。交换后，重新计算 $s_j$，如果 $s_j \\ge \\tau$ 则继续；否则，宣布分解失败。这保持了对称性，但通常会通过置换改变分解顺序和稀疏模式。\n\n对于任何完成了分解的策略，将预处理器定义为 $M \\equiv \\tilde{L} \\tilde{L}^{\\top}$。因为 $M$ 是由一个具有非零对角元的下三角矩阵及其转置的乘积构成的，如果所有主元都为正，那么它应该是 SPD 矩阵。在数值上，您将通过尝试计算 $M$ 的 Cholesky 分解来测试 $M$ 是否为 SPD 矩阵，当且仅当分解无误地成功时，才宣布成功。\n\n请针对维度 $n=6$，阈值 $\\tau = 0.05$ 以及以下三个定义了测试套件的实对称稀疏 SPD 测试矩阵来实现上述过程。所有未指定的元素均为零；所有矩阵都是对称的。\n- 矩阵 $A^{(1)}$（一个良态的三对角 SPD 矩阵）：\n  - 主对角线：$\\{2, 2, 2, 2, 2, 2\\}$。\n  - 第一副对角线和超对角线元素：在连续索引 $\\{(0,1), (1,2), (2,3), (3,4), (4,5)\\}$ 之间为 $-1$。\n- 矩阵 $A^{(2)}$（在 $\\mathrm{IC}(0)$ 下具有故意设置的小的安全主元的 SPD 矩阵）：\n  - 主对角线：$\\{1.01, 1.0001, 1.01, 1.02, 1.1, 1.2\\}$。\n  - 第一副对角线和超对角线元素：在连续索引 $\\{(0,1), (1,2), (2,3)\\}$ 之间为 $-1$；无其他非对角线非零元素。\n- 矩阵 $A^{(3)}$（在分解早期具有极小的安全主元的 SPD 矩阵）：\n  - 主对角线：$\\{1.000001, 1.00000001, 1.0000011, 1.5, 1.6, 1.7\\}$。\n  - 第一副对角线和超对角线元素：在连续索引 $\\{(0,1), (1,2)\\}$ 之间为 $-1$；无其他非对角线非零元素。\n\n对于每个矩阵 $A^{(i)}$（其中 $i \\in \\{1, 2, 3\\}$）和每种策略 $S_0, S_1, S_2$（按此顺序），使用阈值 $\\tau$ 运行 $\\mathrm{IC}(0)$，并记录一个二元指示符\n$$ b_{i,s} = \\begin{cases}\n1,  \\text{如果算法完成且得到的 } M = \\tilde{L} \\tilde{L}^{\\top} \\text{ 在数值上是 SPD 矩阵（Cholesky 分解成功）；} \\\\\n0,  \\text{其他情况。}\n\\end{cases} $$\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。该列表必须按以下顺序排列：\n$$ [\\, b_{1,S_0}, b_{1,S_1}, b_{1,S_2}, b_{2,S_0}, b_{2,S_1}, b_{2,S_2}, b_{3,S_0}, b_{3,S_1}, b_{3,S_2} \\,]. $$\n每个 $b_{i,s}$ 必须是整数 $0$ 或 $1$。不允许有其他输出。\n\n不涉及角度，也不涉及物理单位，因此不需要单位说明。程序必须是自包含的，且不得读取任何输入。", "solution": "本任务是为一组给定的对称正定（SPD）矩阵，实现并评估在零填充不完全 Cholesky 分解（记作 $\\mathrm{IC}(0)$）过程中处理小主元的三种策略。分解的稳定性和所得预处理器矩阵的对称正定性是主要的评估标准。\n\n首先，我们对 $\\mathrm{IC}(0)$ 算法进行形式化描述。给定一个对称矩阵 $A \\in \\mathbb{R}^{n \\times n}$，我们寻求一个下三角矩阵 $\\tilde{L}$，使得 $A \\approx \\tilde{L} \\tilde{L}^{\\top}$。$\\mathrm{IC}(0)$ 的关键约束是 $\\tilde{L}$ 的稀疏模式是 $A$ 的下三角部分稀疏模式的子集。也就是说，如果对于 $i > j$ 有 $A_{ij} = 0$，则 $\\tilde{L}_{ij} = 0$。\n\n$\\tilde{L}$ 的元素是逐列计算的，对于 $j = 0, 1, \\dots, n-1$。对于每一列 $j$，对角元素 $\\tilde{L}_{jj}$ 和次对角元素 $\\tilde{L}_{ij}$ ($i > j$) 计算如下：\n首先，计算对角主元 $s_j$：\n$$ s_j = A_{jj} - \\sum_{k=0}^{j-1} \\tilde{L}_{jk}^2 $$\n然后 $\\tilde{L}$ 的对角元素为：\n$$ \\tilde{L}_{jj} = \\sqrt{s_j} $$\n为使分解成功，所有主元 $s_j$ 都必须严格为正。在数值实践中，为了避免因除以小数而产生的不稳定性并减轻浮点误差的影响，我们要求主元大于一个小的正阈值，即 $s_j \\ge \\tau > 0$。如果违反此条件，则发生“分解失败”。\n\n然后计算第 $j$ 列的次对角元素，对于 $i = j+1, \\dots, n-1$：\n$$ \\tilde{L}_{ij} = \\frac{1}{\\tilde{L}_{jj}} \\left( A_{ij} - \\sum_{k=0}^{j-1} \\tilde{L}_{ik} \\tilde{L}_{jk} \\right), \\quad \\text{如果 } A_{ij} \\ne 0 $$\n如果 $A_{ij}=0$，则根据 $\\mathrm{IC}(0)$ 的稀疏性约束，强制 $\\tilde{L}_{ij}=0$。\n\n我们研究三种处理主元 $s_j < \\tau$ 的策略：\n\n策略 $S_0$（无稳定化）：这是基准方法。如果任何 $s_j < \\tau$，分解过程将立即终止，并且不生成预处理器。对于任何在 $\\mathrm{IC}(0)$ 过程中自然产生小主元的矩阵，该策略都会失败。\n\n策略 $S_1$（对角位移）：如果 $s_j < \\tau$，该策略会修改矩阵 $A$ 以确保主元是安全的。对角元素 $A_{jj}$ 增加一个最小非负值 $\\delta$，使得新的主元等于 $\\tau$。原始主元为 $s_j = A_{jj} - \\sum_{k=0}^{j-1} \\tilde{L}_{jk}^2$。修正后的主元为 $s'_j = (A_{jj}+\\delta) - \\sum_{k=0}^{j-1} \\tilde{L}_{jk}^2 = s_j + \\delta$。令 $s'_j = \\tau$ 可得 $\\delta = \\tau - s_j$。然后算法通过设置 $\\tilde{L}_{jj} = \\sqrt{\\tau}$ 来继续。虽然这在局部解决了小主元问题，但可能导致数值不稳定性。由于 $\\tilde{L}_{jj}$ 出现在分母中，$\\tilde{L}_{jj} = \\sqrt{\\tau}$ 的小值可能导致后续元素 $\\tilde{L}_{ij}$（对于 $i > j$）变得非常大。而一个大的 $\\tilde{L}_{ij}$ 又可能因为 $-\\tilde{L}_{ij}^2$ 项导致未来的主元 $s_i$ 变得很大且为负，从而在分解后期导致失败。\n\n策略 $S_2$（对称对角主元选择）：如果 $s_j < \\tau$，该策略尝试重新排序分解。它在剩余的行 $p \\in \\{j, \\dots, n-1\\}$ 中搜索能产生最大暂定主元的行，即 $\\hat{s}_p = A_{pp} - \\sum_{k=0}^{j-1} \\tilde{L}_{pk}^2$。如果这个最大暂定主元至少为 $\\tau$，则执行对称置换，交换行和列 $j$ 和 $p$。这将一个更大的对角元素移到当前主元位置。然后分解从第 $j$ 步继续。这种重新排序实际上是对一个置换后的矩阵 $P A P^{\\top}$（其中 $P$ 是一个置换矩阵）进行不完全分解。这种策略更为稳健，因为它避免了人为地制造小主元，而是利用矩阵的现有结构来保持稳定性。$\\tilde{L}$ 的稀疏模式将符合置换后矩阵的稀疏模式。\n\n对于每个测试矩阵 $A^{(i)}$ 和策略 $S_s$，我们计算指示符 $b_{i,s}$。如果分解完成，我们构建预处理器 $M = \\tilde{L} \\tilde{L}^{\\top}$。然后我们通过尝试对其进行 Cholesky 分解来测试 $M$ 在数值上是否为 SPD 矩阵。如果 $A$ 的分解完成并且 $M$ 的 Cholesky 分解成功，则 $b_{i,s}=1$；否则 $b_{i,s}=0$。给定的参数是 $n=6$ 和 $\\tau=0.05$。\n\n测试案例分析：\n- 矩阵 $A^{(1)}$：这是一个良态的离散拉普拉斯矩阵。其标准的 $\\mathrm{IC}(0)$ 分解已知非常稳定。主元为 $s_0=2$，$s_1=1.5$，$s_2 \\approx 1.33$ 等，所有这些都明显大于 $\\tau=0.05$。因此，不需要稳定化处理。所有三种策略（$S_0, S_1, S_2$）的执行过程将完全相同，都能成功完成，并生成一个 SPD 预处理器 $M \\approx A^{(1)}$。我们预计 $b_{1,S_0} = b_{1,S_1} = b_{1,S_2} = 1$。\n\n- 矩阵 $A^{(2)}$：该矩阵被设计用来产生一个小主元。\n  - $j=0$: $s_0 = 1.01 > \\tau$。\n  - $j=1$: $s_1 = A_{11} - \\tilde{L}_{10}^2 = 1.0001 - (-1/\\sqrt{1.01})^2 \\approx 0.010001 < \\tau$。\n  - 对于 $S_0$，这会导致立即分解失败。$b_{2,S_0}=0$。\n  - 对于 $S_1$，主元被强制设为 $s_1 = \\tau = 0.05$，因此 $\\tilde{L}_{11} = \\sqrt{0.05}$。然后，对于 $j=2$，我们计算 $\\tilde{L}_{21} = (A_{21} - 0) / \\tilde{L}_{11} = -1/\\sqrt{0.05} \\approx -4.47$。下一个主元是 $s_2 = A_{22} - \\tilde{L}_{21}^2 = 1.01 - (-1/\\sqrt{0.05})^2 = 1.01 - 20 = -18.99$。这个负主元导致分解失败。$b_{2,S_1}=0$。\n  - 对于 $S_2$，在 $j=1$ 时，它会搜索一个新的主元。对于 $p \\ge 1$ 的暂定主元是 $\\hat{s}_p = A_{pp} - \\tilde{L}_{p0}^2$。由于只有 $\\tilde{L}_{10}$ 非零，此搜索实际上是在 $p \\ge 2$ 的范围内寻找最大的对角元素 $A_{pp}$。$A_{55}=1.2$ 是最大的。在交换第 1 行/列和第 5 行/列后，算法使用一个大的、稳定的主元继续进行。这种交换策略很可能会使分解成功完成，从而得到一个 SPD 矩阵 $M$。因此，$b_{2,S_2}=1$。\n\n- 矩阵 $A^{(3)}$：这个情况比 $A^{(2)}$ 更为极端。\n  - $j=0$: $s_0 = 1.000001 > \\tau$。\n  - $j=1$: $s_1 = A_{11} - \\tilde{L}_{10}^2 = 1.00000001 - (-1/\\sqrt{1.000001})^2 \\approx 1.01 \\times 10^{-8} \\ll \\tau$。\n  - 其行为模式与 $A^{(2)}$ 相同。$S_0$ 立即失败（$b_{3,S_0}=0$）。$S_1$ 创建一个同样大的元素 $\\tilde{L}_{21} = -1/\\sqrt{0.05}$，导致后续出现负主元 $s_2 = A_{22} - \\tilde{L}_{21}^2 = 1.0000011 - 20 < 0$，从而导致分解失败（$b_{3,S_1}=0$）。$S_2$ 将再次找到一个大的对角元素（例如 $A_{55}=1.7$），将其置于主元位置，并成功完成分解（$b_{3,S_2}=1$）。\n\n预期的最终结果数组是 $[1, 1, 1, 0, 0, 1, 0, 0, 1]$。以下程序实现了这一逻辑以验证分析。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and evaluates three strategies for incomplete Cholesky factorization.\n    \"\"\"\n\n    def ic0(A, strategy, tau):\n        \"\"\"\n        Computes the Incomplete Cholesky Factorization with zero fill-in (IC(0)).\n        \n        Args:\n            A (np.ndarray): The input symmetric matrix.\n            strategy (str): The stabilization strategy ('S0', 'S1', 'S2').\n            tau (float): The pivot threshold.\n            \n        Returns:\n            np.ndarray or None: The lower triangular factor L, or None if breakdown occurs.\n        \"\"\"\n        n = A.shape[0]\n        # Work on a copy of A as it might be modified\n        A_mod = A.copy()\n        L = np.zeros((n, n))\n\n        for j in range(n):\n            # Compute pivot s_j\n            sum_sq = np.dot(L[j, :j], L[j, :j])\n            s_j = A_mod[j, j] - sum_sq\n\n            if s_j  tau:\n                if strategy == 'S0':\n                    return None  # Breakdown\n                \n                elif strategy == 'S1':\n                    # Diagonal shift strategy\n                    A_mod[j, j] += (tau - s_j)\n                    s_j = tau\n                \n                elif strategy == 'S2':\n                    # Symmetric pivoting strategy\n                    best_p = j\n                    max_pivot = s_j\n                    \n                    for p_candidate in range(j + 1, n):\n                        p_sum_sq = np.dot(L[p_candidate, :j], L[p_candidate, :j])\n                        p_pivot = A_mod[p_candidate, p_candidate] - p_sum_sq\n                        if p_pivot > max_pivot:\n                            max_pivot = p_pivot\n                            best_p = p_candidate\n                    \n                    if max_pivot  tau:\n                        return None  # Breakdown even after search\n\n                    p = best_p\n                    if p != j:\n                        # Apply symmetric permutation to A_mod\n                        A_mod[[j, p], :] = A_mod[[p, j], :]\n                        A_mod[:, [j, p]] = A_mod[:, [p, j]]\n                        # Permute already computed parts of L\n                        L[[j, p], :j] = L[[p, j], :j]\n                    \n                    s_j = max_pivot\n\n            # A non-positive pivot after stabilization means breakdown\n            if s_j = 0:\n                return None\n\n            L[j, j] = np.sqrt(s_j)\n\n            # Compute column j of L based on sparsity of A_mod\n            for i in range(j + 1, n):\n                if A_mod[i, j] != 0:\n                    sum_prod = np.dot(L[i, :j], L[j, :j])\n                    L[i, j] = (A_mod[i, j] - sum_prod) / L[j, j]\n                    \n        return L\n\n    # Define constants and test cases\n    n = 6\n    tau = 0.05\n    strategies = ['S0', 'S1', 'S2']\n\n    # Matrix A^(1)\n    A1 = np.diag([2.0] * n) + np.diag([-1.0] * (n - 1), k=1) + np.diag([-1.0] * (n - 1), k=-1)\n\n    # Matrix A^(2)\n    A2 = np.zeros((n, n))\n    np.fill_diagonal(A2, [1.01, 1.0001, 1.01, 1.02, 1.1, 1.2])\n    A2[0, 1] = A2[1, 0] = -1.0\n    A2[1, 2] = A2[2, 1] = -1.0\n    A2[2, 3] = A2[3, 2] = -1.0\n\n    # Matrix A^(3)\n    A3 = np.zeros((n, n))\n    np.fill_diagonal(A3, [1.000001, 1.00000001, 1.0000011, 1.5, 1.6, 1.7])\n    A3[0, 1] = A3[1, 0] = -1.0\n    A3[1, 2] = A3[2, 1] = -1.0\n\n    test_matrices = [A1, A2, A3]\n    results = []\n\n    for A in test_matrices:\n        for strategy in strategies:\n            b_is = 0\n            L = ic0(A, strategy, tau)\n            \n            if L is not None:\n                M = L @ L.T\n                try:\n                    # Test if M is numerically SPD\n                    np.linalg.cholesky(M)\n                    b_is = 1\n                except np.linalg.LinAlgError:\n                    b_is = 0\n            \n            results.append(b_is)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3176187"}]}