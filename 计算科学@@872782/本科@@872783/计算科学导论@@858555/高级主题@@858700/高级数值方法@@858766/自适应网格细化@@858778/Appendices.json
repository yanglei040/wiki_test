{"hands_on_practices": [{"introduction": "第一个实践练习提供了一个亲手从零开始构建完整的一维自适应网格加密求解器的机会。通过使用有限元方法为泊松边界值问题实现经典的“求解-估计-标记-加密”循环，您将具体理解局部误差指示器如何驱动网格自适应，从而有效提高解的精度。这个练习对于掌握自适应网格加密 (AMR) 的核心工作机制至关重要。[@problem_id:2420755]", "problem": "您需要实现一个完整、可运行的程序，该程序使用连续分段仿射帽函数执行一维有限元分析，并执行由残差型后验误差指示器驱动的自适应网格加密策略。考虑单位区间上的边值问题：求 $u:[0,1]\\to\\mathbb{R}$ 满足\n$$-u''(x)=f(x)\\ \\text{for}\\ x\\in(0,1),\\quad u(0)=0,\\quad u(1)=0.$$\n设 $\\mathcal{T}_h$ 是一个节点为 $0=x_0<x_1<\\dots<x_N=1$ 的网格，并设 $V_h$ 是在此网格上定义的、在 $x=0$ 和 $x=1$ 处为零的连续分段仿射函数空间。有限元法 (FEM) 旨在求解 $u_h\\in V_h$ 满足\n$$\\int_{0}^{1} u_h'(x)\\,v_h'(x)\\,dx=\\int_{0}^{1} f(x)\\,v_h(x)\\,dx\\quad \\text{for all}\\ v_h\\in V_h.$$\n使用与网格节点相关联的标准帽函数作为 $V_h$ 的基，组装全局线性系统，强施加狄利克雷边界条件，并求解 $u_h$ 的节点值。\n\n在每个长度为 $h_i=x_i-x_{i-1}$ 的单元 $K_i=(x_{i-1},x_i)$ 上定义单元误差指示器为\n$$\\eta_i^2 := h_i^2\\, f(m_i)^2 + \\tfrac{1}{2} h_i\\Big(\\mathbf{1}_{\\{i>1\\}}\\,J_{i-1}^2 + \\mathbf{1}_{\\{i<N\\}}\\,J_i^2\\Big),$$\n其中 $m_i=\\tfrac{1}{2}(x_{i-1}+x_i)$，对于每个内部节点 $x_j$（其中 $j\\in\\{1,\\dots,N-1\\}$），\n$$J_j := \\big|\\,u_h'(x_j^-)-u_h'(x_j^+)\\,\\big|,$$\n其中 $u_h'(x_j^-)$ 是左侧单元 $(x_{j-1},x_j)$ 上的导数，$u_h'(x_j^+)$ 是右侧单元 $(x_j,x_{j+1})$ 上的导数。在每个单元 $K_i$ 上，导数 $u_h'$ 是常数，等于 $u_h$ 在 $K_i$ 上的斜率。\n\n通过迭代以下循环来执行自适应加密：在当前网格上求解离散问题，计算 $(\\eta_i)_{i=1}^N$，选择一个使 $\\eta_i$ 最大化的索引 $i^\\star$（如果多个索引达到最大值，则选择最小的索引），并通过将其中心点 $m_{i^\\star}$ 作为新节点插入来二等分 $K_{i^\\star}$。将此过程重复指定的加密步数。\n\n在每个测试案例中，对于给定的 $f(x)$，双线性和线性形式中的所有积分都必须精确计算。下面所有测试案例中的右端项 $f(x)$ 都是次数最多为1的多项式，因此在每个单元上，$f(x)$ 乘以一个帽函数的精确积分存在闭式解。您不能引入任何单位。问题不涉及角度。\n\n测试套件。对于每种情况，从 $[0,1]$ 的一个包含 $N_0$ 个单元的均匀剖分（即节点位于 $x_j=j/N_0$，其中 $j=0,\\dots,N_0$）开始，运行如上定义的恰好 $S$ 个加密步骤，并报告最终的节点坐标：\n- 情况 A：对于所有 $x\\in[0,1]$，$f(x)=1$，其中 $N_0=2$ 且 $S=2$。\n- 情况 B：对于所有 $x\\in[0,1]$，$f(x)=2x+1$，其中 $N_0=3$ 且 $S=3$。\n- 情况 C：对于所有 $x\\in[0,1]$，$f(x)=-4x+2$，其中 $N_0=1$ 且 $S=4$。\n\n最终输出格式。您的程序必须生成单行输出，其中包含一个由三个列表组成的列表，按顺序对应情况A、B和C。每个内部列表必须按升序包含最终的网格节点坐标，写成四舍五入到小数点后恰好6位的小数。外部列表和每个内部列表都必须使用方括号和逗号，不含任何额外的空白或文本。例如，一个有效的格式是\n$$\\big[ [x_0^{(A)},x_1^{(A)},\\dots], [x_0^{(B)},x_1^{(B)},\\dots], [x_0^{(C)},x_1^{(C)},\\dots] \\big],$$\n其中每个 $x_j^{(\\cdot)}$ 都是一个四舍五入后的小数。程序不得读取任何输入。", "solution": "所给问题是泊松方程在齐次狄利克雷边界条件下的一个标准一维边值问题 (BVP)。我们的任务是求解在区间 $[0,1]$ 上满足以下条件的函数 $u(x)$：\n$$-u''(x) = f(x) \\quad \\text{for } x \\in (0,1),$$\n$$u(0) = 0, \\quad u(1) = 0.$$\n该问题将使用带有自适应网格加密策略的有限元法 (FEM) 来求解。问题陈述是适定的、科学上合理的，并包含了获得其唯一、可验证解所需的所有必要信息。我们接下来进行方法的推导和实现。\n\n首先，我们建立边值问题的弱形式。令 $V = H_0^1(0,1)$ 为在边界 $x=0$ 和 $x=1$ 处为零且其一阶导数平方可积的函数所构成的索博列夫空间。将微分方程乘以一个测试函数 $v(x) \\in V$ 并在定义域 $(0,1)$ 上积分，可得\n$$-\\int_0^1 u''(x) v(x) dx = \\int_0^1 f(x) v(x) dx.$$\n对左侧应用分部积分，并使用边界条件 $v(0)=v(1)=0$，我们得到弱形式：求解 $u \\in V$ 满足\n$$a(u,v) := \\int_0^1 u'(x) v'(x) dx = \\int_0^1 f(x) v(x) dx =: L(v) \\quad \\forall v \\in V.$$\n\n有限元法用一个有限维问题来近似这个无限维问题。我们引入一个由节点 $0=x_0 < x_1 < \\dots < x_N=1$ 组成的网格 $\\mathcal{T}_h$，它将区间 $[0,1]$ 剖分为 $N$ 个长度为 $h_i = x_i - x_{i-1}$ 的单元 $K_i=(x_{i-1}, x_i)$。我们定义了一个有限维子空间 $V_h \\subset V$，它是由该网格上在边界处为零的连续分段仿射函数构成。有限元问题是：求解 $u_h \\in V_h$ 满足\n$$a(u_h, v_h) = L(v_h) \\quad \\forall v_h \\in V_h.$$\n$V_h$ 中的任何函数 $u_h$ 都可以表示为基函数的线性组合。$V_h$ 的一个标准基选择是与内部节点 $\\{x_j\\}_{j=1}^{N-1}$ 相关联的“帽函数”集合 $\\{\\phi_j\\}_{j=1}^{N-1}$。帽函数 $\\phi_j(x)$ 定义为在节点 $x_j$ 处为1，在所有其他节点 $x_k$ (其中 $k \\neq j$) 处为0。它在每个单元上都是仿射的。\n因此，解 $u_h(x)$ 可以写为\n$$u_h(x) = \\sum_{j=1}^{N-1} U_j \\phi_j(x),$$\n其中 $U_j = u_h(x_j)$ 是未知的节点值。由于边界条件 $u_h(0)=u_h(1)=0$ 是强施加的，所以求和只针对内部节点。\n\n将此展开式代入弱形式，并对每个 $i \\in \\{1,\\dots,N-1\\}$ 选择 $v_h = \\phi_i$，得到一个线性方程组 $A\\mathbf{U} = \\mathbf{b}$，其中 $\\mathbf{U} = [U_1, \\dots, U_{N-1}]^T$ 是未知节点值的向量，刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$ 的各项为\n$$A_{ij} = a(\\phi_j, \\phi_i) = \\int_0^1 \\phi_j'(x) \\phi_i'(x) dx,$$\n$$b_i = L(\\phi_i) = \\int_0^1 f(x) \\phi_i(x) dx.$$\n$\\phi_j(x)$ 的导数是分段常数：在 $(x_{j-1}, x_j)$ 上 $\\phi_j'(x) = 1/h_j$，在 $(x_j, x_{j+1})$ 上为 $-1/h_{j+1}$，在其他地方为0。$\\phi_i'(x)$ 和 $\\phi_j'(x)$ 的支集仅在 $|i-j| \\le 1$ 时重叠，这使得矩阵 $A$ 成为三对角矩阵。其各项计算如下：\n$$A_{ii} = \\int_{x_{i-1}}^{x_{i+1}} (\\phi_i'(x))^2 dx = \\frac{1}{h_i} + \\frac{1}{h_{i+1}},$$\n$$A_{i,i+1} = A_{i+1,i} = \\int_{x_i}^{x_{i+1}} \\phi_{i+1}'(x) \\phi_i'(x) dx = -\\frac{1}{h_{i+1}}.$$\n对于载荷向量，给定 $f(x)$ 是一个次数最多为1的多项式，我们将其写为 $f(x) = cx+d$。$b_i$ 的积分必须精确计算：\n$$b_i = \\int_{x_{i-1}}^{x_i} (cx+d)\\frac{x-x_{i-1}}{h_i}dx + \\int_{x_i}^{x_{i+1}} (cx+d)\\frac{x_{i+1}-x}{h_{i+1}}dx.$$\n对这些积分进行精确计算可得到以下公式：\n$$b_i = (cx_i+d)\\frac{h_i+h_{i+1}}{2} + c \\frac{h_{i+1}^2 - h_i^2}{6} = f(x_i)\\frac{h_i+h_{i+1}}{2} + f'(x_i) \\frac{h_{i+1}^2 - h_i^2}{6}.$$\n组装好 $A$ 和 $\\mathbf{b}$ 后，求解系统 $A\\mathbf{U}=\\mathbf{b}$ 以找到 $u_h$ 的节点值。\n\n该任务的核心是自adaptive网格加密。在给定网格上求解出 $u_h$ 后，我们为每个单元 $K_i=(x_{i-1},x_i)$ 计算一个后验误差指示器 $\\eta_i$。指定的指示器是\n$$\\eta_i^2 = h_i^2 f(m_i)^2 + \\frac{1}{2} h_i \\left( \\mathbf{1}_{\\{i>1\\}} J_{i-1}^2 + \\mathbf{1}_{\\{i<N\\}} J_i^2 \\right)$$\n其中 $m_i=(x_{i-1}+x_i)/2$ 是单元中点，$J_j = |u_h'(x_j^-) - u_h'(x_j^+)|$ 是在内部节点 $x_j$ 处导数的不连续性的跳跃。\n在我们的情况下， $u_h$ 在单元 $K_k=(x_{k-1}, x_k)$ 上的导数是常数，等于 $(U_k-U_{k-1})/h_k$。因此，在内部节点 $x_j$ 处的跳跃是\n$$J_j = \\left| \\frac{U_j - U_{j-1}}{h_j} - \\frac{U_{j+1} - U_j}{h_{j+1}} \\right|,$$\n其中 $U_0=U_N=0$。\n然后，我们确定具有最大误差指示器 $\\eta_{i^\\star}$ 的单元 $K_{i^\\star}$，并通过在其中心点插入一个新节点来对其进行二等分。此过程在每个测试案例中重复 $S$ 次。\n\n一个可工作的 Python 脚本可以按如下方式构建：\n1.  设置一个主循环，遍历每个测试案例，包括 $f(x)$ 的参数（即 $c$ 和 $d$）、初始单元数 $N_0$ 和加密步数 $S$。\n2.  对于每个案例，通过均匀剖分 $[0,1]$ 来初始化节点列表。\n3.  进入一个循环，该循环重复 $S$ 次：\n    a.  基于当前节点列表，组装三对角刚度矩阵 $A$ 和载荷向量 $\\mathbf{b}$。\n    b.  求解线性系统 $A\\mathbf{U}=\\mathbf{b}$ 得到内部节点值。\n    c.  用边界值（0）扩充解向量。\n    d.  计算每个内部节点的导数跳跃 $J_j$。\n    e.  对于每个单元，使用给定公式计算误差指示器 $\\eta_i^2$。\n    f.  找到具有最大 $\\eta_i^2$ 的单元的索引。\n    g.  将该单元的中点添加到节点列表中。\n4.  在 $S$ 次加密后，将最终的节点列表四舍五入到指定精度并格式化为字符串。\n5.  将所有案例的结果收集到一个列表中，并以要求的格式打印最终输出。\n所有计算都将使用双精度浮点数来保持精度。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the 1D Poisson BVP with adaptive mesh refinement using FEM.\n    \"\"\"\n\n    test_cases = [\n        # Case A: f(x)=1, N0=2, S=2\n        (lambda x: 1.0, 0.0, 1.0, 2, 2),\n        # Case B: f(x)=2x+1, N0=3, S=3\n        (lambda x: 2.0 * x + 1.0, 2.0, 1.0, 3, 3),\n        # Case C: f(x)=-4x+2, N0=1, S=4\n        (lambda x: -4.0 * x + 2.0, -4.0, 2.0, 1, 4)\n    ]\n\n    all_results = []\n    \n    for f_func, c, d, N0, S in test_cases:\n        # Initialize mesh\n        nodes = np.linspace(0.0, 1.0, N0 + 1).tolist()\n\n        for _ in range(S):\n            nodes.sort()\n            current_nodes = np.array(nodes)\n            N = len(current_nodes) - 1  # Number of elements\n            num_interior_nodes = N - 1\n\n            if num_interior_nodes == 0:\n                # Trivial solution u_h = 0\n                full_U = np.zeros(N + 1)\n            else:\n                # Assemble stiffness matrix A\n                A = np.zeros((num_interior_nodes, num_interior_nodes))\n                h = np.diff(current_nodes)\n                \n                # Diagonal entries\n                for i in range(num_interior_nodes):\n                    idx = i + 1 # node index\n                    A[i, i] = 1.0 / h[idx-1] + 1.0 / h[idx]\n                \n                # Off-diagonal entries\n                for i in range(num_interior_nodes - 1):\n                    idx = i + 1 # node index\n                    A[i, i + 1] = -1.0 / h[idx]\n                    A[i + 1, i] = -1.0 / h[idx]\n\n                # Assemble load vector b\n                b = np.zeros(num_interior_nodes)\n                for i in range(num_interior_nodes):\n                    idx = i + 1  # node index\n                    x_i = current_nodes[idx]\n                    h_left = h[idx - 1]\n                    h_right = h[idx]\n                    \n                    val = (c * x_i + d) * (h_left + h_right) / 2.0\n                    val += c * (h_right**2 - h_left**2) / 6.0\n                    b[i] = val\n\n                # Solve linear system AU=b\n                interior_U = np.linalg.solve(A, b)\n                full_U = np.concatenate(([0], interior_U, [0]))\n\n            # Compute error indicators\n            h = np.diff(current_nodes)\n            \n            # Compute jumps J_j at interior nodes\n            # Python index k in `jumps` corresponds to math index j=k+1 for the node\n            jumps = np.zeros(num_interior_nodes)\n            if num_interior_nodes > 0:\n                derivs = (full_U[1:] - full_U[:-1]) / h\n                for j in range(1, N): # iterate over interior node indices\n                    jump_val = np.abs(derivs[j-1] - derivs[j])\n                    jumps[j-1] = jump_val\n\n            # Compute indicators eta_i for each element\n            # Python index k in `etas_sq` corresponds to math index i=k+1 for the element\n            etas_sq = np.zeros(N)\n            for i in range(N): # iterate over element indices 0 to N-1\n                m_i = (current_nodes[i] + current_nodes[i+1]) / 2.0\n                h_i = h[i]\n                \n                # Element residual term\n                term1 = h_i**2 * f_func(m_i)**2\n                \n                # Jump residual term\n                term2 = 0.0\n                # Jump at left node x_i (math index)\n                if i > 0:\n                    # jump at node x_i is J_i, which is jumps[i-1] in Python\n                    term2 += 0.5 * h_i * jumps[i-1]**2\n                # Jump at right node x_{i+1} (math index)\n                if i  N - 1:\n                    # jump at node x_{i+1} is J_{i+1}, which is jumps[i] in Python\n                    term2 += 0.5 * h_i * jumps[i]**2\n                \n                etas_sq[i] = term1 + term2\n\n            # Mark element for refinement\n            # np.argmax selects the first occurrence in case of a tie, which matches the spec.\n            i_star = np.argmax(etas_sq)\n\n            # Refine by bisection\n            new_node = (current_nodes[i_star] + current_nodes[i_star+1]) / 2.0\n            nodes.append(new_node)\n        \n        nodes.sort()\n        formatted_nodes = [f\"{node:.6f}\" for node in nodes]\n        all_results.append(f\"[{','.join(formatted_nodes)}]\")\n        \n    print(f\"[{','.join(all_results)}]\")\n\nsolve()\n```", "id": "2420755"}, {"introduction": "虽然实现 AMR 算法是一项关键技能，但理解其性能特征对于实际应用同样重要。这个练习将从实现转向分析，要求您推导一个解析模型来预测 AMR 方案生成的总网格单元数。通过将加密阈值与待解析特征的几何形状联系起来，您将探索精度与计算成本之间的基本权衡。[@problem_id:3094936]", "problem": "考虑一个面积为 $A$ 的正方形计算域，其最初由一个包含 $N_{c}$ 个方形单元的均匀粗网格离散化。域中存在一个单一的径向对称特征，由标量场 $f(x,y) = \\exp\\!\\big(-(x^{2} + y^{2})/s^{2}\\big)$ 表示，其中 $s  0$ 是该特征的特征尺寸参数。使用单层加密的自适应网格加密（AMR）算法。如果一个粗网格单元内 $f$ 的空间梯度幅值超过阈值 $\\tau  0$，则该单元被标记以进行加密。当一组被标记的单元被聚类成一个加密斑块时，该算法会强制执行一个最小填充率 $\\phi \\in (0,1]$，其定义为加密斑块中被标记单元数与总单元数之比。在一个简单但广泛使用的模型中，这意味着加密斑块的面积是被标记区域的面积除以 $\\phi$。每个被加密的粗网格单元被 $m \\times m$ 个细网格单元替换，其中 $m \\geq 2$ 是整数加密因子。假设被标记的区域是一个完全包含在域内的环形区域，并且 $0  \\tau \\leq \\tau_{\\max}$ 以确保被标记区域非空，其中 $\\tau_{\\max}$ 是平面上 $f$ 的梯度幅值的最大值。在这些假设下，并仅从上述定义出发，推导出一个关于叶单元总数（加密斑块外的粗网格单元加上加密斑块内的细网格单元）的闭式解析模型，该模型是 $\\tau$、$s$、$m$、$\\phi$、$A$ 和 $N_{c}$ 的函数。请将最终答案表示为单个解析表达式。不需要进行数值近似或四舍五入。所有量纲均为无量纲。", "solution": "用户要求我推导一个闭式解析模型，用于计算经过单层自适应网格加密（AMR）后计算网格中叶单元的总数。\n\n首先，我将验证问题陈述。\n\n### 步骤 1：提取已知条件\n-   计算域：面积为 $A$ 的正方形。\n-   初始离散化：包含 $N_{c}$ 个方形单元的均匀粗网格。\n-   标量场：$f(x,y) = \\exp(-(x^{2} + y^{2})/s^{2})$。\n-   特征尺寸参数：$s  0$。\n-   加密算法：单层 AMR。\n-   加密准则：如果单元内 $f$ 的空间梯度幅值超过阈值 $\\tau  0$，则标记该粗网格单元以进行加密。\n-   阈值范围：$0  \\tau \\leq \\tau_{\\max}$，其中 $\\tau_{\\max}$ 是 $f$ 的梯度幅值的最大值。\n-   被标记区域的几何形状：完全包含在域内的环形。\n-   加密因子：一个被加密的粗网格单元被 $m \\times m$ 个细网格单元替换，其中 $m \\geq 2$ 是一个整数。\n-   填充率：$\\phi \\in (0,1]$，定义为加密斑块中被标记单元数与总单元数之比。\n-   填充率模型：加密斑块的面积是被标记区域的面积除以 $\\phi$。\n-   目标：推导叶单元总数 $N_{total}$ 的闭式解析模型，作为 $\\tau$、$s$、$m$、$\\phi$、$A$ 和 $N_{c}$ 的函数。\n\n### 步骤 2：使用提取的已知条件进行验证\n该问题在计算科学领域具有科学依据，特别是在 AMR 算法的性能建模方面。所有术语，如基于梯度的加密准则、填充率和加密因子，都是该领域的标准术语。问题是适定的，提供了所有必要的信息和假设（例如，被标记区域的理想环形形状），从而可以推导出唯一的解析模型。语言客观而精确。问题是自洽的、逻辑一致的，并且没有违反任何科学或数学原理。使用连续模型（计算面积）来估计离散量（单元数量）是创建此类解析模型的标准且必要的简化方法。\n\n### 步骤 3：结论和行动\n问题是有效的。我将开始推导解答。\n\n叶单元的总数 $N_{total}$ 是未加密的粗网格单元和替换了被加密粗网格单元的细网格单元之和。\n设 $N_{c}$ 为初始粗网格单元的数量。设 $N_{refined}$ 为属于加密斑块的粗网格单元的数量。未加密的粗网格单元数量为 $N_{c} - N_{refined}$。\n每个被加密的粗网格单元被 $m^{2}$ 个细网格单元替换。细网格单元的总数为 $m^{2} N_{refined}$。\n因此，叶单元的总数为：\n$$N_{total} = (N_{c} - N_{refined}) + m^{2} N_{refined} = N_{c} + (m^{2} - 1) N_{refined}$$\n为了求得 $N_{total}$，我们必须确定 $N_{refined}$。问题陈述，加密斑块是由被标记的单元聚类形成的。我们可以通过将单元数量与其占据的面积相关联来建模。单个粗网格单元的面积是 $A_{cell} = A/N_{c}$。\n\n加密斑块中的粗网格单元数 $N_{refined}$ 可以表示为加密斑块面积 $A_{patch}$ 与单个粗网格单元面积之比：\n$$N_{refined} = \\frac{A_{patch}}{A_{cell}} = \\frac{A_{patch}}{A/N_{c}}$$\n问题提供了基于填充率 $\\phi$ 的斑块面积模型：$A_{patch} = A_{flagged}/\\phi$，其中 $A_{flagged}$ 是单元被标记以进行加密的区域的面积。\n将此代入 $N_{refined}$ 的表达式中：\n$$N_{refined} = \\frac{A_{flagged}/\\phi}{A/N_{c}} = \\frac{N_{c}}{A \\phi} A_{flagged}$$\n现在，我们必须求出 $A_{flagged}$。如果 $f$ 的空间梯度幅值超过阈值 $\\tau$，则单元被标记。该标量场是径向对称的，因此我们用径向坐标 $r = \\sqrt{x^{2} + y^{2}}$ 来表示它：\n$$f(r) = \\exp(-r^{2}/s^{2})$$\n梯度幅值为 $|\\nabla f| = |\\frac{df}{dr}|$。由于 $r \\ge 0$，我们有：\n$$|\\nabla f| = \\left| \\frac{d}{dr} \\exp(-r^{2}/s^{2}) \\right| = \\left| \\exp(-r^{2}/s^{2}) \\cdot \\left(-\\frac{2r}{s^{2}}\\right) \\right| = \\frac{2r}{s^{2}} \\exp(-r^{2}/s^{2})$$\n标记条件是 $|\\nabla f|  \\tau$。被标记区域的边界由等式 $|\\nabla f| = \\tau$ 给出：\n$$\\frac{2r}{s^{2}} \\exp(-r^{2}/s^{2}) = \\tau$$\n为了解出 $r$，我们引入一个代换。令 $u = r^{2}/s^{2}$。则 $r = s\\sqrt{u}$。方程变为：\n$$\\frac{2s\\sqrt{u}}{s^{2}} \\exp(-u) = \\tau \\implies \\frac{2\\sqrt{u}}{s} \\exp(-u) = \\tau$$\n两边平方得到：\n$$\\frac{4u}{s^{2}} \\exp(-2u) = \\tau^{2} \\implies u \\exp(-2u) = \\frac{s^{2}\\tau^{2}}{4}$$\n为了将其转换为朗伯W函数 (Lambert W function) 的标准形式 $z\\exp(z) = C$，我们令 $z = -2u$。这意味着 $u = -z/2$。将此代入方程：\n$$\\left(-\\frac{z}{2}\\right) \\exp(z) = \\frac{s^{2}\\tau^{2}}{4} \\implies z \\exp(z) = -\\frac{s^{2}\\tau^{2}}{2}$$\n条件 $0  \\tau \\leq \\tau_{\\max}$ 确保了朗伯W函数的参数 $C = -s^{2}\\tau^{2}/2$ 在范围 $[-1/e, 0)$ 内，对此范围，朗伯W函数的两个分支 $W_{0}(C)$ 和 $W_{-1}(C)$ 给出两个实数解。\n设 $z$ 的两个解为 $z_{1}$ 和 $z_{2}$：\n$$z_{1} = W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\quad \\text{和} \\quad z_{2} = W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right)$$\n我们使用 $r^{2} = s^{2}u = -s^{2}z/2$ 转换回 $r^{2}$。定义环形标记区域的两个半径是 $r_{inner}$ 和 $r_{outer}$。因为对于 $x \\in [-1/e, 0)$，$W_{0}(x) \\ge -1$ 且 $W_{-1}(x) \\le -1$，我们知道 $W_{0}(x)  W_{-1}(x)$。由此得出 $-W_{0}(x)  -W_{-1}(x)$。因此，较小的半径对应于 $W_{0}$ 分支，较大的半径对应于 $W_{-1}$ 分支。\n$$r_{inner}^{2} = -\\frac{s^{2}}{2} W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right)$$\n$$r_{outer}^{2} = -\\frac{s^{2}}{2} W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right)$$\n被标记的环形区域的面积是 $A_{flagged} = \\pi (r_{outer}^{2} - r_{inner}^{2})$：\n$$A_{flagged} = \\pi \\left[ -\\frac{s^{2}}{2} W_{-1}\\left(-\\fracs^{2}\\tau^{2}}{2}\\right) - \\left(-\\frac{s^{2}}{2} W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right)\\right) \\right]$$\n$$A_{flagged} = \\frac{\\pi s^{2}}{2} \\left[ W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) - W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\right]$$\n现在我们将这个 $A_{flagged}$ 的表达式代回到 $N_{refined}$ 的方程中：\n$$N_{refined} = \\frac{N_{c}}{A \\phi} \\left( \\frac{\\pi s^{2}}{2} \\left[ W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) - W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\right] \\right)$$\n最后，我们将这个 $N_{refined}$ 的表达式代入到单元总数 $N_{total}$ 的方程中：\n$$N_{total} = N_{c} + (m^{2} - 1) N_{refined}$$\n$$N_{total} = N_{c} + (m^{2} - 1) \\frac{N_{c} \\pi s^{2}}{2 A \\phi} \\left[ W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) - W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\right]$$\n将 $N_{c}$ 提取出来，得到最终的闭式解析模型：\n$$N_{total} = N_{c} \\left( 1 + \\frac{(m^{2} - 1)\\pi s^{2}}{2 A \\phi} \\left[ W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) - W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\right] \\right)$$\n该表达式给出了叶单元总数，作为指定参数 $\\tau, s, m, \\phi, A$ 和 $N_{c}$ 的函数。", "answer": "$$\\boxed{N_{c} \\left(1 + \\frac{(m^{2} - 1)\\pi s^{2}}{2 A \\phi} \\left[ W_{0}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) - W_{-1}\\left(-\\frac{s^{2}\\tau^{2}}{2}\\right) \\right]\\right)}$$", "id": "3094936"}, {"introduction": "自适应网格加密是一个强大的工具，但其有效性关键取决于误差指示器的质量。最后一个实践练习探讨了一个常见的陷阱：一个简单的基于梯度的指示器可能会被混叠效应误导，导致在信号分辨率不足的区域产生“假阳性”加密。通过一个人为构造的振荡解来研究这一现象，您将对 AMR 的局限性以及理解网格与解之间相互作用的重要性形成更批判性的视角。[@problem_id:3094969]", "problem": "您将探究一种简单的基于梯度的自适应网格加密 (AMR) 指标在应用于一个构造的光滑振荡函数时，是否会因混叠而产生假阳性。考虑周期性域 $[0,1)$，并定义一个构造解 $u(x) = \\sin(2\\pi \\nu x)$，其中 $\\nu$ 是单位长度内的周期数，所有三角函数参数均以弧度为单位。您将使用一个包含 $N$ 个点的均匀周期性网格来离散化该域，这些点位于 $x_j = j/N$（其中 $j \\in \\{0,1,\\dots,N-1\\}$），网格间距为 $h = 1/N$。在此网格上定义一个离散梯度指标：\n$$\nG_j = \\frac{\\left|u(x_{j+1}) - u(x_j)\\right|}{h},\n$$\n其中下标是周期性的，因此 $x_{N} \\equiv x_0$。如果 $G_j  \\tau$，则一个单元（下标为 $j$）被标记为需要加密，其中 $\\tau$ 是一个用户选择的阈值。\n\n为了定义什么构成由混叠引起的假阳性，我们假设在采样前应用了一个理想的抗混叠低通滤波器。对于频率为 $\\nu$ 的单频正弦波，以每单位长度 $N$ 个点的速率进行采样，其奈奎斯特截止频率为每单位长度 $N/2$ 个周期。在这个理想化模型下，如果 $\\nu \\ge N/2$，低通滤波器会在采样前完全抑制信号内容，这意味着一个理想的粗网格表示为 $u \\equiv 0$，因此梯度处处为零；如果 $\\nu  N/2$，滤波器会无损地通过信号。如果实际采样指标标记了至少一个单元，而理想的抗混叠指标不会标记任何单元，则声明为假阳性。形式上，给定\n$$\n\\text{actual\\_flags}(N,\\nu,\\tau) = \\#\\{\\, j \\in \\{0,\\dots,N-1\\} \\mid G_j  \\tau \\,\\},\n$$\n理想化的决策是\n$$\n\\text{ideal\\_flags}(N,\\nu,\\tau) = \n\\begin{cases}\n\\text{actual\\_flags}(N,\\nu,\\tau),  \\nu  N/2,\\\\\n0,  \\nu \\ge N/2,\n\\end{cases}\n$$\n假阳性是指布尔事件 $\\big(\\text{actual\\_flags}(N,\\nu,\\tau)  0\\big)$ 且 $\\big(\\text{ideal\\_flags}(N,\\nu,\\tau) = 0\\big)$。\n\n任务：编写一个完整、可运行的程序，对于下面列出的每个测试用例，构建离散样本，计算 $G_j$，统计被标记单元的数量，应用理想化的抗混叠准则，并输出是否发生假阳性。\n\n测试套件（每个元组为 $(N,\\nu,\\tau)$）：\n- $(32,17,10)$：频率略高于奈奎斯特频率，预期出现由混叠引起的标记，而理想的低通滤波器会移除该信号。\n- $(32,16,10)$：恰好在奈奎斯特频率上，采样的正弦函数在网格点上恒为零。\n- $(32,8,10)$：被充分解析的频率，标记（如果有的话）不是由混叠引起的。\n- $(33,20,10)$：在奇数大小的网格上，频率高于奈奎斯特频率，预期出现由混叠引起的标记。\n- $(64,63,10)$：远高于奈奎斯特频率，但混叠成一个非常低的离散频率；阈值可能足够高以抑制标记。\n\n所有计算均使用无单位量；三角函数中的所有角度均以弧度为单位。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果（例如，“[True,False,False,True,False]”）。输出必须是一个布尔值列表，按顺序对应上述测试用例。", "solution": "问题要求探究一种简单的基于梯度的自适应网格加密 (AMR) 指标是否会因混叠而产生假阳性。我们得到了一个使用构造解来测试此现象的特定框架。\n\n根据指定标准，该问题被评估为有效。它在科学上基于数值分析和信号处理的既定原则（特别是奈奎斯特-香农采样定理和有限差分近似）。该问题是适定的，所有量、条件和目标都得到了形式上明确的定义。其设置是自洽、一致且计算上可行的。该问题提出了一个关于计算科学中实际问题的非平凡问题，使其成为一个实质性的练习。\n\n分析过程如下。对于每个由参数元组 $(N, \\nu, \\tau)$ 指定的测试用例，我们必须确定是否发生假阳性。\n\n假阳性被形式化地定义为布尔事件 $(\\text{actual\\_flags}(N,\\nu,\\tau)  0) \\land (\\text{ideal\\_flags}(N,\\nu,\\tau) = 0)$。$\\text{actual\\_flags}$ 项是计算出的梯度指标超过阈值的网格单元数量，而 $\\text{ideal\\_flags}$ 表示如果在采样前应用了理想的抗混叠滤波器，将被标记的单元数量。\n\n问题陈述定义了这种理想滤波器的行为：\n$$\n\\text{ideal\\_flags}(N,\\nu,\\tau) = \n\\begin{cases}\n\\text{actual\\_flags}(N,\\nu,\\tau),  \\nu  N/2,\\\\\n0,  \\nu \\ge N/2,\n\\end{cases}\n$$\n此处，$N$ 是采样点数，$\\nu$ 是连续信号的频率。量 $N/2$ 是奈奎斯特频率，即在此采样率下可以唯一表示的最高频率。条件 $\\nu \\ge N/2$ 意味着信号被欠采样。在这个理想化模型中，任何等于或高于奈奎斯特频率的信号内容都会被完全衰减，从而产生零信号（$u \\equiv 0$），因此梯度指标处处为零。因此，$\\text{ideal\\_flags} = 0$。\n\n将此定义代入假阳性条件，我们发现假阳性只有在 $\\nu \\ge N/2$ 时才会发生。该条件简化为：\n$$\n(\\text{actual\\_flags}(N,\\nu,\\tau)  0) \\land (\\nu \\ge N/2)\n$$\n这构成了我们算法的基础。对于每个测试用例 $(N, \\nu, \\tau)$：\n1. 首先，我们检查频率 $\\nu$ 是否等于或高于奈奎斯特频率，即 $\\nu \\ge N/2$。如果不满足此条件，根据定义，假阳性是不可能发生的，该测试用例的结果为 `False`。\n2. 如果 $\\nu \\ge N/2$，我们必须接着计算实际被标记的单元数。离散信号值 $u_j$ 是在网格点 $x_j = j/N$（其中 $j \\in \\{0, 1, \\dots, N-1\\}$）上从连续构造解 $u(x) = \\sin(2\\pi \\nu x)$ 采样得到的。这给出：\n    $$\n    u_j = u(x_j) = \\sin\\left(2\\pi \\nu \\frac{j}{N}\\right)\n    $$\n3. 接下来，我们为每个单元计算离散梯度指标 $G_j$。网格间距为 $h=1/N$。该指标定义为由网格间距归一化的前向差分的幅度：\n    $$\n    G_j = \\frac{\\left|u_{j+1} - u_j\\right|}{h} = N \\left|u_{j+1} - u_j\\right|\n    $$\n    下标是周期性的，意味着 $u_N$ 被视为 $u_0$。\n4. 然后我们统计该指标超过给定阈值 $\\tau$ 的单元数量：\n    $$\n    \\text{actual\\_flags} = \\#\\{\\, j \\in \\{0,\\dots,N-1\\} \\mid G_j  \\tau \\,\\}\n    $$\n5. 最后，如果 $\\text{actual\\_flags}  0$（并且我们处于 $\\nu \\ge N/2$ 的情况），则发生了假阳性，该测试用例的结果为 `True`。否则，结果为 `False`。\n\n这个完整的程序将被实现并应用于每个提供的测试用例。例如，在 $(N, \\nu, \\tau) = (32, 17, 10)$ 的情况下，奈奎斯特频率为 $N/2 = 16$。由于 $\\nu = 17  16$，信号被欠采样。采样信号 $u_j = \\sin(2\\pi \\cdot 17 \\cdot j/32)$ 混叠成一个高频振荡 $u_j = (-1)^j \\sin(2\\pi j/32)$，这会产生大的梯度值。如果这些值中的任何一个超过 $\\tau=10$，则记录一个假阳性。相反，对于 $(N, \\nu, \\tau) = (32, 8, 10)$，频率 $\\nu=8$ 低于奈奎斯特频率 $16$，因此信号被充分解析。根据我们的定义，无论 `actual_flags` 的值如何，这种情况都不会产生假阳性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes whether a simple gradient-based AMR indicator produces false \n    positives due to aliasing for a set of test cases.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (N, nu, tau)\n    # N: number of grid points\n    # nu: frequency of the sine wave\n    # tau: threshold for the gradient indicator\n    test_cases = [\n        (32, 17, 10),\n        (32, 16, 10),\n        (32, 8, 10),\n        (33, 20, 10),\n        (64, 63, 10),\n    ]\n\n    results = []\n    \n    for N, nu, tau in test_cases:\n        # A false positive is defined as (actual_flags  0) AND (ideal_flags == 0).\n        # The condition (ideal_flags == 0) is equivalent to nu = N/2.\n        # Therefore, a false positive occurs if nu = N/2 AND actual_flags  0.\n\n        # Step 1: Check if the frequency is at or above the Nyquist frequency.\n        # The Nyquist frequency is N/2 cycles per unit length.\n        nyquist_freq = N / 2.0\n        \n        if nu  nyquist_freq:\n            # If the signal is well-resolved, a false positive (as defined) cannot occur.\n            results.append(False)\n            continue\n\n        # Step 2: If undersampled (nu = nyquist_freq), compute the actual flags.\n        # Define the grid and grid spacing.\n        # Domain is [0, 1), so grid spacing h = 1/N.\n        h = 1.0 / N\n        # Grid points x_j = j/N for j = 0, ..., N-1.\n        j = np.arange(N)\n        x = j * h\n\n        # Step 3: Sample the continuous function u(x) = sin(2*pi*nu*x) on the grid.\n        u = np.sin(2 * np.pi * nu * x)\n        \n        # Step 4: Compute the discrete gradient indicator G_j = |u_{j+1} - u_j| / h.\n        # np.roll(u, -1) provides u_{j+1} with periodic boundary conditions (u_N = u_0).\n        u_j_plus_1 = np.roll(u, -1)\n        G = np.abs(u_j_plus_1 - u) / h\n        \n        # Step 5: Count the number of cells where the indicator exceeds the threshold.\n        actual_flags = np.sum(G > tau)\n        \n        # Step 6: Determine if a false positive occurred.\n        # This happens if there are any flags raised despite the signal\n        # frequency being above the Nyquist limit.\n        is_false_positive = actual_flags > 0\n        results.append(is_false_positive)\n\n    # Final print statement in the exact required format.\n    # Convert booleans to lowercase 'true'/'false' for JSON-like format\n    bool_to_string = [str(r).lower() for r in results]\n    print(f\"[{','.join(bool_to_string)}]\")\n\nsolve()\n```", "id": "3094969"}]}