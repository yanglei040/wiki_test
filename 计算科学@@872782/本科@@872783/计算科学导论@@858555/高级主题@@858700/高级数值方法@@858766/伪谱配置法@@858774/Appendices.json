{"hands_on_practices": [{"introduction": "在应用伪谱法解决复杂的微分方程之前，首先必须深刻理解其核心工具——微分矩阵 $D$ 的基本性质。本练习 [@problem_id:3179523] 将引导你探索 $D$ 的零空间，这直接对应于“常数的导数为零”这一微积分基本法则。通过动手实现，你将验证这一性质在离散形式下的表现，并分析在求解边值问题时施加边界条件如何改变算子的结构，这是数值求解中的关键一步。", "problem": "您将实现并使用一个切比雪夫-洛巴托伪谱一阶导数配置矩阵，以研究端点条件如何影响离散微分算子的零空间。请完全使用精确数学术语和标准浮点运算，并遵循以下基本依据和事实。\n\n基本依据和事实：\n- 在伪谱配置法中，函数 $u(x)$ 通过一个穿过选定节点的插值多项式来近似，其导数则通过对该插值多项式求导来近似。这产生一个线性算子（一个矩阵），它将节点值映射到节点导数的近似值。\n- 对于切比雪夫-洛巴托节点，节点为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,\\ldots,N$，$N \\in \\mathbb{N}$ 是子区间的数量。如果 $p(x)$ 是任意一个次数至多为 $N$ 的多项式，那么在这些节点上的伪谱导数等于 $p(x)$ 在这些节点上的精确导数。\n- 常数函数 $p(x) \\equiv 1$ 的导数恒为零，因此任何一致的一阶导数伪谱微分矩阵 $D$ 在精确算术中都应满足 $D \\mathbf{1} = \\mathbf{0}$，其中 $\\mathbf{1}$ 是全一向量。在浮点运算中，此等式在舍入误差范围内成立。\n\n需要实现的定义：\n1. 切比雪夫-洛巴托节点：$x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,\\ldots,N$。\n2. 切比雪夫一阶导数伪谱矩阵 $D \\in \\mathbb{R}^{(N+1)\\times(N+1)}$：由重心拉格朗日公式构造。令\n   - 当 $j \\in \\{0,N\\}$ 时，$c_j = 2$，否则 $c_j = 1$，\n   - $s_j = (-1)^j$，\n   - $w_j = c_j s_j$，\n   - $x_j$ 如上所述，\n   - $X$ 是元素为 $X_{jk} = x_j$ 的矩阵，\n   - $\\Delta = X - X^\\top$ 是逐对差分矩阵。\n   对于 $j \\neq k$，\n   $$ D_{jk} = \\frac{w_j}{w_k} \\cdot \\frac{1}{x_j - x_k}, $$\n   对于每个 $j$，\n   $$ D_{jj} = -\\sum_{k\\neq j} D_{jk}. $$\n   这个 $D$ 矩阵将节点采样值 $u(x_k)$ 映射到 $u'(x_j)$ 的近似值。\n3. 通过行替换施加端点条件的算子：为了在配置系统中施加齐次狄利克雷边界条件 $u(x_0)=0$ 和 $u(x_N)=0$，将 $D$ 的第一行和最后一行替换为强制执行这些条件的坐标行向量：将第一行设置为 $[1, 0, \\ldots, 0]$，最后一行设置为 $[0, \\ldots, 0, 1]$。将得到的矩阵记为 $A$。\n4. 仅内部算子：移除 $D$ 的第一行和最后一行以及第一列和最后一列，形成内部块 $D_{\\mathrm{int}} \\in \\mathbb{R}^{(N-1)\\times(N-1)}$。这对应于在端点值被分开处理时，算子作用于内部未知数的情况。\n\n您的任务：\n- 根据上述定义，实现一个例程来为给定的 $N$ 构造 $D$。\n- 对于下述每种算子类型，将离散化的常数函数样本定义为兼容长度的全一向量 $\\mathbf{1}$，并计算无穷范数残差\n  $$ r = \\lVert \\text{Operator} \\cdot \\mathbf{1} \\rVert_{\\infty}. $$\n- 根据指定的数值阈值解释 $r$，以判断常数函数是否（近似地）位于该算子的零空间中。\n\n科学目标：\n- 根据伪谱导数对常数多项式求导为零的性质，证明在精确算术中 $D \\mathbf{1} = \\mathbf{0}$，并从数值上验证 $r$ 很小。\n- 分析移除端点列（仅内部算子）如何破坏了导致 $D \\mathbf{1} = \\mathbf{0}$ 的精确抵消，从而使常数函数不再位于零空间中。\n- 分析通过行替换施加的端点约束如何改变算子的零空间，使得 $\\mathbf{1}$ 不再被接纳，除非它满足边界条件，而对于齐次狄利克雷边界条件，除非常数为 $0$，否则它不满足。\n\n测试套件：\n对于以下每种情况，您将根据指定的标准计算一个布尔值。\n\n- 情况 1：算子类型为“full”，$N=8$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 2：算子类型为“full”，$N=32$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 3：算子类型为“interior”，$N=8$。设下界 $\\eta = 1\\times 10^{-8}$。如果 $r \\ge \\eta$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 4：算子类型为“bc_rows”，$N=8$。理论上 $r \\ge 1$，因为第一和最后一个残差分量等于 $1$。如果 $r \\ge 1$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 5：算子类型为“full”，$N=2$。设容差 $\\tau = 1\\times 10^{-13}$。如果 $r \\le \\tau$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n- 情况 6：算子类型为“interior”，$N=2$。设下界 $\\eta = 1\\times 10^{-8}$。如果 $r \\ge \\eta$，输出 $\\mathrm{True}$，否则输出 $\\mathrm{False}$。\n\n最终输出格式：\n您的程序应生成一行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。对于此问题，结果是按情况 1 到 6 顺序排列的六个布尔值。", "solution": "该问题陈述具有科学依据、适定且客观。它概述了一个标准的数值分析练习，涉及构建和检验一个切比雪夫伪谱微分矩阵。所有定义都是精确的，任务是清晰的，其背景处于计算科学的既定原则之内。因此，该问题是有效的。\n\n此问题的核心是研究一阶导数伪谱微分算子在不同配置下的零空间。如果一个线性算子将一个函数映射到零，那么该函数就位于该算子的零空间中。对于一个微分算子——无论是连续的还是离散的——常数函数是其零空间最基本的元素，因为常数的导数恒为零。我们将分析此性质在从切比雪夫配置法派生出的三种离散算子形式中如何体现。\n\n区间 $[-1, 1]$ 上的函数 $u(x)$ 由一个穿过 $N+1$ 个切比雪夫-洛巴托节点 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$（其中 $j=0, \\dots, N$）的 $N$ 次多项式插值 $p(x)$ 来近似。导数 $u'(x)$ 则通过 $p'(x)$ 来近似。这种关系定义了一个从函数值向量 $\\mathbf{u} = [u(x_0), \\dots, u(x_N)]^\\top$ 到近似导数值向量 $\\mathbf{u}' = [u'(x_0), \\dots, u'(x_N)]^\\top$ 的线性变换。该变换由 $(N+1) \\times (N+1)$ 的切比雪夫一阶导数伪谱矩阵 $D$ 表示。\n\n$D$ 的元素由以下公式给出：\n$$ D_{jk} = \\frac{c_j(-1)^j}{c_k(-1)^k} \\frac{1}{x_j - x_k} \\quad \\text{for } j \\neq k $$\n$$ D_{jj} = -\\sum_{k\\neq j} D_{jk} $$\n其中，当 $j \\in \\{0, N\\}$ 时，$c_j = 2$，否则 $c_j = 1$。\n\n我们考虑常数函数 $u(x) = 1$。其节点值向量是全一向量，$\\mathbf{1} = [1, 1, \\dots, 1]^\\top$。我们将检验算子与 $\\mathbf{1}$ 的乘积，并计算所得残差向量的无穷范数，$r = \\lVert \\text{Operator} \\cdot \\mathbf{1} \\rVert_{\\infty}$。\n\n**1. 完整微分算子 ($D$)**\n\n这是如上定义的标准切比雪夫微分矩阵。我们分析它对常数函数向量 $\\mathbf{1}$ 的作用。\n\n*   **理论分析：** 伪谱方法对于次数至多为 $N$ 的任何多项式都是精确的。常数函数 $u(x)=1$ 是一个 0 次多项式。其导数为 $u'(x)=0$。因此，离散微分算子 $D$ 必须将 $u(x)=1$ 的节点值映射到 $u'(x)=0$ 的节点值。这意味着 $D\\mathbf{1} = \\mathbf{0}$。\n    从代数上看，对角元素 $D_{jj} = -\\sum_{k\\neq j} D_{jk}$ 的构造确保了每行元素的和恰好为零：\n    $$ \\sum_{k=0}^{N} D_{jk} = D_{jj} + \\sum_{k\\neq j} D_{jk} = \\left(-\\sum_{k\\neq j} D_{jk}\\right) + \\sum_{k\\neq j} D_{jk} = 0 $$\n    向量 $D\\mathbf{1}$ 的第 $j$ 个分量由 $(D\\mathbf{1})_j = \\sum_{k=0}^{N} D_{jk} \\cdot 1_k = \\sum_{k=0}^{N} D_{jk}$ 给出。由于每行的和都为零，向量 $D\\mathbf{1}$ 是零向量。\n*   **数值验证（情况 1、2、5）：** 当用浮点运算实现时，此性质在机器精度范围内成立。计算出的残差 $r = \\lVert D \\mathbf{1} \\rVert_{\\infty}$ 将是一个与机器ε同量级的小数，反映了累积的舍入误差。对于 $N=2$、$N=8$ 和 $N=32$，计算出的残差都极小，满足条件 $r \\le \\tau = 1 \\times 10^{-13}$。因此，这些情况的测试结果为 $\\mathrm{True}$，确认了在数值精度范围内，全一向量位于 $D$ 的零空间中。\n\n**2. 内部算子 ($D_{\\mathrm{int}}$)**\n\n该算子是通过移除 $D$ 的第一行和最后一行及第一列和最后一列得到的 $(N-1) \\times (N-1)$ 子矩阵。它代表导数对内部节点的作用，假定边界值被分开处理。\n\n*   **理论分析：** 现在作用的向量是长度为 $N-1$ 的全一向量，记为 $\\mathbf{1}_{\\mathrm{int}}$。对于一个内部行 $j$（其中 $1 \\le j \\le N-1$），乘积 $D_{\\mathrm{int}}\\mathbf{1}_{\\mathrm{int}}$ 的第 $j$ 个分量是 $D_{\\mathrm{int}}$ 第 $j$ 行元素的和：\n    $$ (D_{\\mathrm{int}}\\mathbf{1}_{\\mathrm{int}})_j = \\sum_{k=1}^{N-1} D_{jk} $$\n    根据完整矩阵 $D$ 的行和为零性质，我们知道 $\\sum_{k=0}^{N} D_{jk} = 0$。我们可以将其重写为 $D_{j0} + \\sum_{k=1}^{N-1} D_{jk} + D_{jN} = 0$。因此，内部矩阵的行和为：\n    $$ \\sum_{k=1}^{N-1} D_{jk} = -(D_{j0} + D_{jN}) $$\n    这个和通常不为零。常数函数位于零空间的性质因将算子限制在内部而被破坏。\n*   **数值验证（情况 3，$N=8$）：** 对于 $N=8$，残差向量的元素是 $-(D_{j0} + D_{j8})$，其中 $j=1, \\dots, 7$。这些值显著不为零，导致一个大的无穷范数残差 $r$。测试正确地识别了这一点，对于 $r \\ge \\eta = 1 \\times 10^{-8}$ 产生 $\\mathrm{True}$。\n*   **特殊情况（情况 6，$N=2$）：** 对于 $N=2$，内部仅包含一个节点，$j=1$。节点为 $x_0=1$，$x_1=0$，$x_2=-1$。内部矩阵 $D_{\\mathrm{int}}$ 是一个包含元素 $D_{1,1}$ 的 $1 \\times 1$ 矩阵。残差就是 $r = |D_{1,1}|$。根据上述分析，$D_{1,1} = -(D_{1,0} + D_{1,2})$。对于偶数 $N$，当考虑中点 $j=N/2$（此处 $j=1=2/2$）时，由于切比雪夫节点和权重的对称性，项 $D_{j,0}$ 和 $D_{j,N}$ 会相互抵消。具体来说，$D_{1,0} = \\frac{1}{2}$，$D_{1,2} = -\\frac{1}{2}$，所以它们的和为 $0$。因此，$D_{1,1} = 0$，残差 $r=0$。测试 $r \\ge \\eta$ 变为 $0 \\ge 1 \\times 10^{-8}$，结果为 $\\mathrm{False}$。\n\n**3. 端点条件算子 ($A$)**\n\n该算子是通过将 $D$ 的第一行和最后一行替换为基向量来强制施加边界条件而形成的。对于齐次狄利克雷条件，第一行变为 $[1, 0, \\dots, 0]$，最后一行变为 $[0, \\dots, 0, 1]$。\n\n*   **理论分析：** 这个矩阵 $A$ 用于求解形如 $A\\mathbf{u} = \\mathbf{f}$ 的系统，其中第一个和最后一个方程是 $u_0=f_0$ 和 $u_N=f_N$。当我们测试 $A$ 对全一向量 $\\mathbf{1}$ 的作用时，我们实际上是在检查常数函数 $u(x)=1$ 是否在其零空间中。乘积 $A\\mathbf{1}$ 是：\n    - 第一个分量：$(A\\mathbf{1})_0 = [1, 0, \\dots, 0] \\cdot [1, \\dots, 1]^\\top = 1$。这对应于检查 $u(x_0)=1$ 是否满足 $u(x_0)=0$。它不满足。\n    - 内部各分量（$j=1, \\dots, N-1$）：$(A\\mathbf{1})_j = (D\\mathbf{1})_j = 0$（在精确算术中），因为这些行来自原始矩阵 $D$。\n    - 最后一个分量：$(A\\mathbf{1})_N = [0, \\dots, 0, 1] \\cdot [1, \\dots, 1]^\\top = 1$。这对应于检查 $u(x_N)=1$ 是否满足 $u(x_N)=0$。它不满足。\n    得到的残差向量是 $\\mathbf{r} = [1, 0, \\dots, 0, 1]^\\top$。无穷范数是 $r = \\lVert \\mathbf{r} \\rVert_{\\infty} = \\max(|1|, |0|, |1|) = 1$。常数函数不在 $A$ 的零空间中。只有平凡的常数函数 $u(x)=0$ 才会在。\n*   **数值验证（情况 4，$N=8$）：** 计算结果与理论预测完全匹配。残差向量为 $[1, 0, \\dots, 0, 1]^\\top$（其中内部的零会受到浮点误差的影响，但仍然非常小），其无穷范数为 $r=1$。测试 $r \\ge 1$ 得到满足，结果为 $\\mathrm{True}$。\n\n总之，这项研究表明，微分算子具有常数函数在其零空间中的基本性质是脆弱的。它对于完整、未修改的伪谱矩阵成立，但会被用于求解边值问题的标准修改所破坏，例如将算子限制在内部点或通过行替换强制施加边界条件。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef get_chebyshev_matrix(N: int) - np.ndarray:\n    \"\"\"\n    Constructs the Chebyshev first-derivative pseudospectral matrix D\n    for N+1 Chebyshev-Lobatto nodes.\n\n    Args:\n        N (int): The number of subintervals (degree of polynomial).\n\n    Returns:\n        np.ndarray: The (N+1)x(N+1) differentiation matrix.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n    \n    # Define Chebyshev-Lobatto nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n    \n    # Define weights\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[-1] = 2.0\n    \n    w = np.power(-1.0, j) * c\n\n    # Calculate off-diagonal elements using broadcasting\n    X = x.reshape(N + 1, 1)\n    dX = X - X.T\n    \n    W_ratio = w.reshape(N + 1, 1) / w.reshape(1, N + 1)\n    \n    # Temporarily add identity to dX to avoid division by zero on the diagonal.\n    # The diagonal values will be correctly computed later.\n    D = W_ratio / (dX + np.eye(N + 1))\n    np.fill_diagonal(D, 0.0)\n    \n    # Calculate diagonal elements such that row sums are zero\n    row_sums = D.sum(axis=1)\n    np.fill_diagonal(D, -row_sums)\n    \n    return D\n\ndef solve():\n    \"\"\"\n    Runs the test suite specified in the problem statement to analyze\n    the nullspace of various Chebyshev differentiation operators.\n    \"\"\"\n    results = []\n\n    # Case 1: 'full' operator, N=8\n    N1 = 8\n    tau1 = 1e-13\n    D1 = get_chebyshev_matrix(N1)\n    ones1 = np.ones(N1 + 1)\n    r1 = np.linalg.norm(D1 @ ones1, ord=np.inf)\n    results.append(r1 = tau1)\n\n    # Case 2: 'full' operator, N=32\n    N2 = 32\n    tau2 = 1e-13\n    D2 = get_chebyshev_matrix(N2)\n    ones2 = np.ones(N2 + 1)\n    r2 = np.linalg.norm(D2 @ ones2, ord=np.inf)\n    results.append(r2 = tau2)\n\n    # Case 3: 'interior' operator, N=8\n    N3 = 8\n    eta3 = 1e-8\n    D3 = get_chebyshev_matrix(N3)\n    D_int3 = D3[1:-1, 1:-1]\n    ones3 = np.ones(N3 - 1)\n    r3 = np.linalg.norm(D_int3 @ ones3, ord=np.inf)\n    results.append(r3 >= eta3)\n\n    # Case 4: 'bc_rows' operator, N=8\n    N4 = 8\n    eta4 = 1.0\n    D4 = get_chebyshev_matrix(N4)\n    A4 = D4.copy()\n    A4[0, :] = 0.0\n    A4[0, 0] = 1.0\n    A4[-1, :] = 0.0\n    A4[-1, -1] = 1.0\n    ones4 = np.ones(N4 + 1)\n    r4 = np.linalg.norm(A4 @ ones4, ord=np.inf)\n    results.append(r4 >= eta4)\n    \n    # Case 5: 'full' operator, N=2\n    N5 = 2\n    tau5 = 1e-13\n    D5 = get_chebyshev_matrix(N5)\n    ones5 = np.ones(N5 + 1)\n    r5 = np.linalg.norm(D5 @ ones5, ord=np.inf)\n    results.append(r5 = tau5)\n\n    # Case 6: 'interior' operator, N=2\n    N6 = 2\n    eta6 = 1e-8\n    D6 = get_chebyshev_matrix(N6)\n    D_int6 = D6[1:-1, 1:-1] # This is the single element D[1,1]\n    ones6 = np.ones(N6 - 1) # Vector of length 1\n    r6 = np.linalg.norm(D_int6 @ ones6, ord=np.inf)\n    results.append(r6 >= eta6)\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3179523"}, {"introduction": "掌握了基本的一阶微分矩阵后，我们便能构建更复杂的算子，例如二阶微分，并将其应用于实际的科学问题。本练习 [@problem_id:3179507] 将带你使用伪谱法求解一个经典的 Sturm-Liouville 特征值问题，该问题在物理学中可用于描述弦的振动基频或量子系统的能级。通过构建二阶微分算子并将其数值计算出的特征值与精确解进行比较，你将亲眼见证伪谱法引以为傲的“谱精度”。", "problem": "考虑在区间 $[-1,1]$ 上使用基于 Chebyshev 多项式的伪谱配置法 (PCM) 来近似导数。设 $N \\in \\mathbb{N}$，定义 Chebyshev 配置点（第一类）为 $x_j = \\cos\\left(\\frac{\\pi j}{N}\\right)$，其中 $j = 0,1,\\dots,N$，所有角度单位均为弧度。设 $D \\in \\mathbb{R}^{(N+1) \\times (N+1)}$ 表示一阶微分矩阵，它通过 Chebyshev 插值将配置点上的函数值向量映射到这些点上的一阶导数值向量。定义二阶微分矩阵为 $D^{(2)} = D^2$。考虑在 $[-1,1]$ 上具有齐次 Dirichlet 边界条件的 Sturm–Liouville 特征值问题：\n$$\n-u''(x) = \\lambda u(x), \\quad u(-1) = 0, \\quad u(1) = 0.\n$$\n已知该问题的精确特征值为\n$$\n\\lambda_k = \\left(\\frac{k \\pi}{2}\\right)^2, \\quad k = 1,2,3,\\dots,\n$$\n其中 $u_k(x)$ 满足在 $[-1,1]$ 上的边界条件。\n\n您的任务是：\n- 使用上面定义的 Chebyshev 配置点，从多项式插值的基本原理出发，构建 Chebyshev 一阶微分矩阵 $D$。\n- 形成 $D^{(2)} = D^2$，并通过限制在内部配置点 $x_j$（其中 $j = 1,2,\\dots,N-1$）上，将带有齐次 Dirichlet 边界条件的算子 $-u'' = \\lambda u$ 离散化。这会产生以下形式的矩阵特征值问题：\n$$\nA \\mathbf{u}_{\\text{int}} = \\lambda \\mathbf{u}_{\\text{int}},\n$$\n其中 $A \\in \\mathbb{R}^{(N-1) \\times (N-1)}$ 是从 $D^{(2)}$ 获得的，$\\mathbf{u}_{\\text{int}}$ 表示 $u$ 在配置点上的内部值的向量。使用齐次边界条件来消除对边界值的依赖。\n- 计算 $A$ 的特征值，将它们按升序排序，并与精确特征值 $\\lambda_k$（其中 $k = 1,\\dots,N-1$）进行比较。\n- 对于每个 $N$，报告前 $N-1$ 个特征值中的最大绝对相对误差：\n$$\nE_{\\max}(N) = \\max_{1 \\le k \\le N-1} \\frac{\\left| \\lambda_k^{\\text{num}} - \\lambda_k \\right|}{\\lambda_k}.\n$$\n\n您可以使用的基础知识包括：Chebyshev 点的定义、多项式插值及其导数的性质，以及有限区间上的 Dirichlet Sturm–Liouville 问题的形式及其精确特征值。\n\n对 $N$ 使用以下测试套件：\n- $N = 2$（具有最小非平凡内部的边界情况），\n- $N = 3$（小网格），\n- $N = 8$（中等网格），\n- $N = 16$（较大网格），\n- $N = 64$（精细网格）。\n\n您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表。每个条目必须是测试套件中相应 $N$ 的 $E_{\\max}(N)$ 值，并以科学记数法格式化，保留六位有效数字（例如 $[1.234567e-03,4.321000e-05,\\dots]$）。不涉及物理单位，所有角度单位都必须解释为弧度。最终输出必须是按照上面指定的测试套件 $N$ 值的顺序排列的列表。", "solution": "所提出的问题是使用 Chebyshev 伪谱配置法对一维 Sturm-Liouville 问题的特征值进行数值近似。具体来说，我们要解决在区间 $[-1, 1]$ 上具有齐次 Dirichlet 边界条件 $u(-1) = 0$ 和 $u(1) = 0$ 的特征值问题\n$$\n-u''(x) = \\lambda u(x)\n$$\n该任务要求构建 Chebyshev 微分矩阵，通过将问题限制在内部配置点来应用边界条件，然后计算所得离散算子的特征值。数值特征值的准确性将通过计算最大相对误差，与已知的精确特征值 $\\lambda_k = \\left(\\frac{k \\pi}{2}\\right)^2$（其中 $k = 1, 2, 3, \\dots$）进行评估。\n\n伪谱配置法基于使用一个全局插值多项式 $p(x)$ 来近似函数 $u(x)$，该多项式在一组指定的节点上与 $u(x)$ 相匹配。对于这个问题，我们使用 Chebyshev-Gauss-Lobatto 点，定义为\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j = 0, 1, \\dots, N.\n$$\n这些点是 $N$ 阶第一类 Chebyshev 多项式 $T_N(x)$ 的极值点。函数 $u(x)$ 的导数则由插值多项式 $p(x)$ 在这些相同点上的导数来近似。\n\n该方法的核心是构建 Chebyshev 一阶微分矩阵 $D \\in \\mathbb{R}^{(N+1) \\times (N+1)}$。如果 $\\mathbf{u} = [u(x_0), u(x_1), \\dots, u(x_N)]^T$ 是配置点上的函数值向量，那么一阶导数向量 $\\mathbf{u}' = [u'(x_0), u'(x_1), \\dots, u'(x_N)]^T$ 可由矩阵-向量乘积 $D\\mathbf{u}$ 近似。$D$ 的元素可以从 Lagrange 插值的原理推导出来。如果 $p(x) = \\sum_{k=0}^N u_k L_k(x)$ 是对数据进行插值的次数最多为 $N$ 的唯一多项式，其中 $L_k(x)$ 是 Lagrange 基多项式，则 $p'(x_i) = \\sum_{k=0}^N u_k L'_k(x_i)$。因此，微分矩阵的元素由 $(D)_{ik} = L'_k(x_i)$ 给出。对于 Chebyshev 点，这些元素有众所周知的解析形式：\n$$\n(D)_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j}  i \\neq j \\\\\n-\\frac{x_j}{2(1-x_j^2)}  1 \\le j \\le N-1 \\\\\n\\frac{2N^2+1}{6}  j = 0 \\\\\n-\\frac{2N^2+1}{6}  j = N\n\\end{cases}\n$$\n其中权重 $c_j$ 定义为 $c_0 = c_N = 2$ 和 $c_j = 1$（对于 $j = 1, \\dots, N-1$）。一种计算对角元素的数值上更稳定的方法是利用常数函数的导数为零这一性质。这意味着 $D$ 的每行之和必须为零，从而得到关系式 $(D)_{ii} = -\\sum_{j \\neq i} (D)_{ij}$。\n\n二阶导数通过应用两次一阶导数算子来近似。二阶导数向量 $\\mathbf{u}''$ 可由 $D^2 \\mathbf{u}$ 近似，其中 $D^{(2)} = D^2$ 是二阶微分矩阵。特征值问题 $-u''(x) = \\lambda u(x)$ 因此被离散化为\n$$\n-D^{(2)} \\mathbf{u} = \\lambda \\mathbf{u}.\n$$\n这表示一个由 $N+1$ 个线性方程组成的系统。现在必须应用边界条件 $u(-1) = 0$ 和 $u(1) = 0$。由于 $x_0 = \\cos(0) = 1$ 和 $x_N = \\cos(\\pi) = -1$，这些条件转化为 $u_0 = u(x_0) = 0$ 和 $u_N = u(x_N) = 0$。\n\n现在我们可以将系统简化为只包含内部点 $j = 1, \\dots, N-1$。对于内部行 $j$，方程为：\n$$\n-\\sum_{k=0}^{N} (D^{(2)})_{jk} u_k = \\lambda u_j.\n$$\n代入 $u_0 = 0$ 和 $u_N = 0$，和式简化为：\n$$\n-(D^{(2)})_{j0} u_0 - \\sum_{k=1}^{N-1} (D^{(2)})_{jk} u_k - (D^{(2)})_{jN} u_N = \\lambda u_j\n$$\n$$\n-\\sum_{k=1}^{N-1} (D^{(2)})_{jk} u_k = \\lambda u_j.\n$$\n这构成了一个大小为 $(N-1) \\times (N-1)$ 的标准矩阵特征值问题：\n$$\nA \\mathbf{u}_{\\text{int}} = \\lambda \\mathbf{u}_{\\text{int}},\n$$\n其中 $\\mathbf{u}_{\\text{int}} = [u_1, u_2, \\dots, u_{N-1}]^T$ 是内部点上的函数值向量，而 $A$ 是通过取 $D^{(2)}$ 中对应于行和列从 $1$ 到 $N-1$ 的子矩阵的负值而形成的 $(N-1) \\times (N-1)$ 矩阵。\n\n整体计算流程如下：\n1.  对于给定的整数 $N$，构建 $(N+1) \\times (N+1)$ 的 Chebyshev 微分矩阵 $D$。\n2.  计算二阶微分矩阵 $D^{(2)} = D^2$。\n3.  从 $-D^{(2)}$ 中提取内部子矩阵，以形成 $(N-1) \\times (N-1)$ 矩阵 $A$。\n4.  计算 $A$ 的特征值。由于原始算子是自伴的，$A$ 的特征值将是实数。将它们按升序排序以获得数值近似值 $\\lambda_k^{\\text{num}}$，其中 $k = 1, \\dots, N-1$。\n5.  生成精确特征值 $\\lambda_k = (\\frac{k\\pi}{2})^2$，其中 $k = 1, \\dots, N-1$。\n6.  在所有计算出的特征值中，计算最大绝对相对误差 $E_{\\max}(N)$：\n    $$\n    E_{\\max}(N) = \\max_{1 \\le k \\le N-1} \\frac{\\left| \\lambda_k^{\\text{num}} - \\lambda_k \\right|}{\\lambda_k}.\n    $$\n对指定测试套件中的每个 $N$ 值重复此过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef construct_chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev first derivative differentiation matrix.\n\n    Args:\n        N (int): The number of intervals, which defines the matrix size (N+1)x(N+1).\n\n    Returns:\n        numpy.ndarray: The (N+1)x(N+1) differentiation matrix D.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.0]])\n        \n    size = N + 1\n    D = np.zeros((size, size))\n    x = np.cos(np.pi * np.arange(size) / N)\n    \n    # Weights for the formula\n    c = np.ones(size)\n    c[0] = 2.0\n    c[-1] = 2.0\n\n    # Off-diagonal elements\n    for i in range(size):\n        for j in range(size):\n            if i != j:\n                D[i, j] = (c[i] / c[j]) * ((-1)**(i + j)) / (x[i] - x[j])\n    \n    # Diagonal elements using the row-sum-to-zero property\n    for i in range(size):\n        D[i, i] = -np.sum(D[i, :])\n        \n    return D\n\ndef solve():\n    \"\"\"\n    Solves the problem for the given test cases and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [2, 3, 8, 16, 64]\n    \n    results = []\n    \n    for N in test_cases:\n        # Step 1: Construct the Chebyshev first derivative matrix D.\n        D = construct_chebyshev_diff_matrix(N)\n        \n        # Step 2: Compute the second derivative matrix D^(2) = D^2.\n        D2 = D @ D\n        \n        # Step 3: Form the matrix A for the interior problem.\n        # The equation is -u'' = lambda*u. A is the discretization of -d^2/dx^2.\n        # Boundary conditions u(-1)=0, u(1)=0 are imposed by taking the submatrix\n        # corresponding to interior points (j=1, ..., N-1).\n        A = -D2[1:N, 1:N]\n        \n        # Step 4: Compute the eigenvalues of A.\n        # For a real matrix A, eigenvalues can be complex. The analytical problem\n        # has real eigenvalues, so we take the real part of the numerical solution.\n        # A should be nearly symmetric, yielding nearly real eigenvalues.\n        numerical_eigenvalues = np.sort(np.real(np.linalg.eigvals(A)))\n        \n        # Step 5: Compute the exact eigenvalues.\n        # The eigenvalues correspond to k = 1, 2, ..., N-1.\n        k = np.arange(1, N)\n        exact_eigenvalues = (k * np.pi / 2.0)**2\n        \n        # Step 6: Calculate the maximum absolute relative error.\n        # For N=2, A is 1x1, so there is only one eigenvalue.\n        if N > 1:\n            relative_errors = np.abs(numerical_eigenvalues - exact_eigenvalues) / exact_eigenvalues\n            max_relative_error = np.max(relative_errors)\n        else: # Case N=1 has no interior points, so error is undefined.\n            max_relative_error = np.nan\n\n        results.append(max_relative_error)\n\n    # Final print statement in the exact required format.\n    # The example format \"1.234567e-03\" has 7 significant digits, which corresponds\n    # to a precision of 6 digits after the decimal point in scientific notation.\n    print(f\"[{','.join(f'{r:.6e}' for r in results)}]\")\n\nsolve()\n```", "id": "3179507"}, {"introduction": "伪谱法同样能高效求解如波动传播等含时问题，但此时确保数值稳定性变得至关重要。本练习 [@problem_id:3179536] 将以线性平流方程为模型，引导你探索一种用于分析稳定性的强大工具——能量法。你将学习如何使用同步近似项 (Simultaneous Approximation Term, SAT) 这一先进技术来施加边界条件，并通过调节其参数来保证数值格式的稳定性，这是成功模拟时变物理系统的核心技能之一。", "problem": "考虑闭区间 $[-1,1]$ 上的一维线性平流方程 $u_t + a\\,u_x = 0$，其中 $a$ 是一个恒定的平流速度。在伪谱配置法中，使用 Chebyshev–Gauss–Lobatto 节点及相关的一阶微分矩阵来近似空间导数。以迎风方式通过同步近似项 (SAT) 施加入流边界条件。通过能量法，在与 Chebyshev–Gauss–Lobatto 求积一致的离散内积中，研究由此产生的半离散算子的稳定性。\n\n您必须使用的基本原理：\n- 直线法通过仅在空间上进行离散化，将一个偏微分方程转化为一个常微分方程组，得到 $u_t = \\mathcal{L}\\,u$，其中 $\\mathcal{L}$ 是半离散空间算子。\n- Chebyshev–Gauss–Lobatto 节点定义为 $x_j = \\cos\\!\\left(\\frac{\\pi j}{N}\\right)$，其中 $j=0,1,\\dots,N$，$N$ 是多项式次数参数，这些节点用于导数的配置。\n- Chebyshev–Gauss–Lobatto 节点上的一阶伪谱微分矩阵是通过对与这些节点相关的 Lagrange 插值多项式进行微分，并在节点处求值得到的。\n- 能量法通过研究某个定义了离散内积的对称正定矩阵 $H$ 的离散能量范数 $\\|u\\|_H^2 = u^\\top H u$ 的时间变化率来评估稳定性。如果对于所有状态 $u$ 都有 $\\frac{d}{dt}\\|u\\|_H^2 \\le 0$，则表明系统是稳定的，这等价于对称矩阵 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$ 是半负定的。\n\n您必须按照以下步骤进行，不得使用会使推导过程过于简单的简化公式：\n1. 对于给定的 $N$，在 $[-1,1]$ 上构建 Chebyshev–Gauss–Lobatto 节点 $x_j$。\n2. 通过对与这些节点相关的 Lagrange 基进行微分并在节点处求值，推导并组装 Chebyshev 配置一阶微分矩阵 $D$。\n3. 选择一个与 Chebyshev–Gauss–Lobatto 求积相关的对角、对称正定求积权重矩阵 $H$（您必须使用与 Chebyshev 权重一致的权重），使得 $u^\\top H v$ 近似于 $\\int_{-1}^1 u(x)\\,v(x)\\,\\frac{dx}{\\sqrt{1-x^2}}$。\n4. 为直线法构建半离散算子 $\\mathcal{L}$，其中包含一个强度为 $s \\ge 0$ 的迎风 SAT 入流边界罚项，该罚项仅添加入流边界处：\n   - 如果 $a0$，入流边界位于 $x=-1$（左端点）。\n   - 如果 $a  0$，入流边界位于 $x=+1$（右端点）。\n   迎风 SAT 罚项必须通过一个与入流端点对齐的秩一-项来惩罚入流边界值的偏差，该项通过相应求积权重的倒数进行缩放，以便其影响在 $H$-内积中进行度量。\n5. 推导对称部分 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$，并解释能量法如何将其特征值的符号与稳定性联系起来。\n6. 通过计算 $S$ 的最大特征值来实现一个数值测试来检验稳定性；通过测试最大特征值是否小于或等于 $10^{-10}$ 来将稳定性报告为一个布尔值（此容差考虑了浮点舍入误差）。\n\n此问题中不出现物理单位或角度；所有量均为无量纲。测试套件的最终答案必须是布尔值。\n\n测试套件：\n使用以下参数集 $(N,a,s)$，其中 $N$ 是 Chebyshev–Gauss–Lobatto 节点之间的区间数（因此有 $N+1$ 个节点），$a$ 是平流速度，$s$ 是迎风 SAT 罚项强度：\n- $(16, 1.0, 0.0)$\n- $(16, 1.0, 0.5)$\n- $(16, 1.0, 1.0)$\n- $(16, 1.0, 4.0)$\n- $(16, -1.0, 0.5)$\n- $(32, 1.0, 2.0)$\n- $(32, -1.0, 2.0)$\n\n程序输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,...]”）。每个条目必须是一个布尔值，按上面列出的顺序指示其对应测试用例的稳定性。", "solution": "该问题要求分析一维线性平流方程 $u_t + a\\,u_x = 0$ 在定义域 $x \\in [-1, 1]$ 上伪谱配置法的稳定性。稳定性将通过能量法对一种采用同步近似项 (SAT) 强制施加入流边界条件的半离散化方案进行研究。\n\n半离散化采用直线法，它通过离散化空间导数将偏微分方程 (PDE) 转化为常微分方程 (ODE) 组，形式为 $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$。这里，$\\vec{u}(t)$ 是解在时间 $t$ 时于配置点上的值的向量，$\\mathcal{L}$ 是半离散空间算子。\n\n**1. Chebyshev–Gauss–Lobatto 节点与求积**\n解 $u(x,t)$ 通过多项式插值进行近似，并在一些列配置点上强制满足偏微分方程。我们使用区间 $[-1, 1]$ 上的 $N+1$ 个 Chebyshev–Gauss–Lobatto (CGL) 节点，定义如下：\n$$\nx_j = \\cos\\left(\\frac{\\pi j}{N}\\right) \\quad \\text{for } j=0, 1, \\dots, N\n$$\n注意，节点从 $x_0 = 1$ 排序到 $x_N = -1$。\n\n稳定性分析利用了基于离散内积的能量法，该离散内积近似于连续内积 $\\langle u, v \\rangle_w = \\int_{-1}^1 u(x)v(x) \\frac{dx}{\\sqrt{1-x^2}}$。对应的离散内积为 $(\\vec{u}, \\vec{v})_H = \\vec{u}^\\top H \\vec{v}$，其中 $H$ 是一个包含求积权重的对角、对称正定矩阵。对于 CGL 节点和 Chebyshev 权重函数 $w(x) = (1-x^2)^{-1/2}$，求积权重由下式给出：\n$$\nw_j = \\frac{\\pi}{c_j N} \\quad \\text{for } j=0, 1, \\dots, N\n$$\n其中 $c_0 = c_N = 2$ 且对于 $j=1, \\dots, N-1$ 有 $c_j = 1$。求积矩阵为 $H = \\text{diag}(w_0, w_1, \\dots, w_N)$。该矩阵是对称且正定的。解的离散能量为 $\\|\\vec{u}\\|_H^2 = \\vec{u}^\\top H \\vec{u}$。\n\n**2. Chebyshev 配置微分矩阵**\n在 CGL 节点处的空间导数 $u_x$ 通过矩阵向量乘积 $D\\vec{u}$ 来近似，其中 $D$ 是 $(N+1) \\times (N+1)$ 的 Chebyshev 微分矩阵。$D$ 的元素是通过对与节点 $\\{x_j\\}$ 相关的 Lagrange 插值多项式进行微分，并在这些相同节点上求值得到的。$D$ 的元素由下式给出：\n$$\nD_{ij} = \\begin{cases}\n\\frac{c_i}{c_j} \\frac{(-1)^{i+j}}{x_i - x_j},  i \\neq j \\\\\n\\frac{-x_j}{2(1-x_j^2)},  i = j, \\quad j=1, \\dots, N-1 \\\\\n\\frac{2N^2+1}{6},  i = j = 0 \\\\\n-\\frac{2N^2+1}{6},  i = j = N\n\\end{cases}\n$$\n其中系数 $c_j$ 与为求积权重定义的系数相同。\n\n**3. 带 SAT 的半离散算子**\n$u_t + a\\,u_x = 0$ 的半离散化形式是 $\\frac{d\\vec{u}}{dt} = -aD\\vec{u}$。为了在不牺牲稳定性或精度的情况下施加边界条件，我们添加一个同步近似项 (SAT)。对于此问题，我们在齐次边界条件下分析稳定性，即指定的入流值为 $0$。\n\n算子 $\\mathcal{L}$ 构建为 $\\mathcal{L} = -aD + P$，其中 $P$ 是罚算子。罚项以迎风方式施加于入流边界。\n- 如果 $a > 0$，平流方向为 x 轴正方向。由于我们的节点从 $x_0=1$ 排序到 $x_N=-1$，入流边界位于 $x = -1$，对应于节点 $j=N$。\n- 如果 $a  0$，平流方向为 x 轴负方向。入流边界位于 $x = 1$，对应于节点 $j=0$。\n\nSAT 惩罚入流节点处数值解与指定边界值（此处为 $0$）之间的偏差。ODE 系统的罚项被构建为一个仅影响入流节点的秩一修正。按照规定，罚项强度 $s$ 通过相应求积权重的倒数进行缩放。\n对于 $a > 0$（入流在 $j=N$）：添加到右端项的罚项是 $-s \\frac{1}{H_{NN}} u_N \\vec{e}_N$。算子为 $\\mathcal{L} = -aD - \\frac{s}{H_{NN}} E_{NN}$，其中 $E_{NN}$ 是一个在 $(N,N)$ 位置为 $1$ 且其他位置为零的矩阵，$\\vec{e}_N$ 是相应的标准基向量。\n对于 $a  0$（入流在 $j=0$）：罚项是 $-s \\frac{1}{H_{00}} u_0 \\vec{e}_0$。算子为 $\\mathcal{L} = -aD - \\frac{s}{H_{00}} E_{00}$。\n\n**4. 能量法稳定性分析**\n半离散系统 $\\frac{d\\vec{u}}{dt} = \\mathcal{L}\\vec{u}$ 的稳定性通过考察离散能量 $\\|\\vec{u}\\|_H^2$ 的时间演化来评估：\n$$\n\\frac{d}{dt} \\|\\vec{u}\\|_H^2 = \\frac{d}{dt}(\\vec{u}^\\top H \\vec{u}) = \\dot{\\vec{u}}^\\top H \\vec{u} + \\vec{u}^\\top H \\dot{\\vec{u}}\n$$\n代入 $\\dot{\\vec{u}} = \\mathcal{L}\\vec{u}$：\n$$\n\\frac{d}{dt} \\|\\vec{u}\\|_H^2 = (\\mathcal{L}\\vec{u})^\\top H \\vec{u} + \\vec{u}^\\top H (\\mathcal{L}\\vec{u}) = \\vec{u}^\\top (\\mathcal{L}^\\top H + H \\mathcal{L}) \\vec{u} = \\vec{u}^\\top S \\vec{u}\n$$\n其中 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$。如果能量不随时间增长，即对于任何状态 $\\vec{u}$ 都有 $\\frac{d}{dt}\\|\\vec{u}\\|_H^2 \\le 0$，则系统是稳定的。这等价于对称矩阵 $S$ 是半负定的，意味着它的所有特征值都必须是非正的（$\\lambda_k(S) \\le 0$）。\n\n我们现在推导 $S$。Chebyshev 微分矩阵 $D$ 和 CGL 求积矩阵 $H$ 的一个关键性质是离散分部求和公式：\n$$\nHD + D^\\top H = E_{00} - E_{NN}\n$$\n这个恒等式反映了离散层面上的分部积分行为。\n\n让我们计算两种情况下的 $S$：\n情况 1：$a > 0$（入流在 $j=N$）。\n$\\mathcal{L} = -aD - \\frac{s}{H_{NN}} E_{NN}$。\n$$\nS = H\\left(-aD - \\frac{s}{H_{NN}} E_{NN}\\right) + \\left(-aD - \\frac{s}{H_{NN}} E_{NN}\\right)^\\top H\n$$\n$$\nS = -a(HD + D^\\top H) - \\frac{s}{H_{NN}}(H E_{NN} + E_{NN}^\\top H)\n$$\n由于 $H$ 是对角矩阵，所以 $H E_{NN} = H_{NN} E_{NN}$ 且 $E_{NN}^\\top H = H_{NN} E_{NN}$。\n$$\nS = -a(E_{00} - E_{NN}) - \\frac{s}{H_{NN}}(H_{NN} E_{NN} + H_{NN} E_{NN}) = -a E_{00} + a E_{NN} - 2s E_{NN}\n$$\n$$\nS = -a E_{00} + (a - 2s) E_{NN}\n$$\n这个矩阵 $S$ 是对角矩阵，其对角元为 $S_{00} = -a$，$S_{NN} = a-2s$，所有其他对角元均为 $0$。要使 $S$ 是半负定的，其所有对角元必须为非正。由于 $a>0$，则 $S_{00}=-a  0$。我们需要 $a - 2s \\le 0$，这意味着 $s \\ge a/2$。\n\n情况 2：$a  0$（入流在 $j=0$）。\n$\\mathcal{L} = -aD - \\frac{s}{H_{00}} E_{00}$。\n类似的推导得出：\n$$\nS = -a(E_{00} - E_{NN}) - \\frac{s}{H_{00}}(H E_{00} + E_{00}^\\top H) = -a E_{00} + a E_{NN} - 2s E_{00}\n$$\n$$\nS = (-a - 2s) E_{00} + a E_{NN}\n$$\n这是一个对角矩阵，其对角元为 $S_{00} = -a - 2s$ 和 $S_{NN}=a$。由于 $a0$，则 $S_{NN}=a0$。为了保证半负定性，我们需要 $-a - 2s \\le 0$，这意味着 $2s \\ge -a$，或者 $s \\ge -a/2 = |a|/2$。\n\n在这两种情况下，为保证稳定性，罚参数 $s$ 必须满足 $s \\ge |a|/2$。\n\n**5. 数值稳定性测试**\n数值实现将为每个测试用例 $(N, a, s)$ 构建矩阵 $D$、$H$ 和 $\\mathcal{L}$。然后它将构成对称矩阵 $S = H\\mathcal{L} + \\mathcal{L}^\\top H$ 并计算其特征值。如果 $S$ 的最大特征值小于或等于一个小的容差（这里是 $10^{-10}$，用以考虑浮点运算误差），则该方案被认为是稳定的。\n测试用例可以根据推导出的条件 $s \\ge |a|/2$ 进行评估：\n- $(16, 1.0, 0.0)$: $0.0 \\ge 1.0/2 \\implies 0.0 \\ge 0.5$ (错误，不稳定)。\n- $(16, 1.0, 0.5)$: $0.5 \\ge 1.0/2 \\implies 0.5 \\ge 0.5$ (正确，稳定)。\n- $(16, 1.0, 1.0)$: $1.0 \\ge 1.0/2 \\implies 1.0 \\ge 0.5$ (正确，稳定)。\n- $(16, 1.0, 4.0)$: $4.0 \\ge 1.0/2 \\implies 4.0 \\ge 0.5$ (正确，稳定)。\n- $(16, -1.0, 0.5)$: $0.5 \\ge |-1.0|/2 \\implies 0.5 \\ge 0.5$ (正确，稳定)。\n- $(32, 1.0, 2.0)$: $2.0 \\ge 1.0/2 \\implies 2.0 \\ge 0.5$ (正确，稳定)。\n- $(32, -1.0, 2.0)$: $2.0 \\ge |-1.0|/2 \\implies 2.0 \\ge 0.5$ (正确，稳定)。\n实现应证实这些解析预测。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef chebyshev_diff_matrix(N):\n    \"\"\"\n    Constructs the Chebyshev collocation differentiation matrix on\n    Chebyshev-Gauss-Lobatto nodes.\n\n    Args:\n        N (int): The polynomial degree, resulting in N+1 nodes.\n\n    Returns:\n        tuple[np.ndarray, np.ndarray]: A tuple containing:\n            - D (np.ndarray): The (N+1)x(N+1) differentiation matrix.\n            - x (np.ndarray): The (N+1) CGL nodes.\n    \"\"\"\n    if N == 0:\n        return np.array([[0.]]), np.array([[0.]])\n    \n    # CGL nodes\n    j = np.arange(N + 1)\n    x = np.cos(np.pi * j / N)\n\n    # c_j coefficients\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n\n    # Off-diagonal entries\n    # Use broadcasting to create matrices of x_i and x_j\n    X = np.tile(x, (N + 1, 1))\n    x_diff = X - X.T\n    \n    # Create matrix of (-1)^(i+j)\n    i = np.arange(N + 1)[:, np.newaxis]\n    j = np.arange(N + 1)[np.newaxis, :]\n    sign_matrix = (-1.0)**(i + j)\n\n    # Create matrix of c_i/c_j\n    c_ratio = np.outer(c, 1.0 / c)\n\n    D = c_ratio * sign_matrix / (x_diff + np.eye(N + 1)) # Add identity to avoid div by zero on diag\n    \n    # Diagonal entries\n    D[np.diag_indices_from(D)] = 0.0 # Clear diagonal before setting final values\n    \n    # Interior points\n    for j_diag in range(1, N):\n        D[j_diag, j_diag] = -x[j_diag] / (2.0 * (1.0 - x[j_diag]**2))\n        \n    # Endpoints\n    D[0, 0] = (2.0 * N**2 + 1.0) / 6.0\n    D[N, N] = -(2.0 * N**2 + 1.0) / 6.0\n\n    return D, x\n\ndef chebyshev_quadrature_matrix(N):\n    \"\"\"\n    Constructs the diagonal quadrature matrix H for CGL nodes.\n\n    Args:\n        N (int): The polynomial degree.\n\n    Returns:\n        np.ndarray: The (N+1)x(N+1) diagonal quadrature matrix H.\n    \"\"\"\n    c = np.ones(N + 1)\n    c[0] = 2.0\n    c[N] = 2.0\n    \n    weights = np.pi / (c * N)\n    H = np.diag(weights)\n    return H\n\ndef solve():\n    \"\"\"\n    Main function to perform stability analysis for the given test cases.\n    \"\"\"\n    test_cases = [\n        # (N, a, s)\n        (16, 1.0, 0.0),\n        (16, 1.0, 0.5),\n        (16, 1.0, 1.0),\n        (16, 1.0, 4.0),\n        (16, -1.0, 0.5),\n        (32, 1.0, 2.0),\n        (32, -1.0, 2.0),\n    ]\n\n    results = []\n    stability_tolerance = 1e-10\n\n    for N, a, s in test_cases:\n        # Step 1  2: Get differentiation matrix and nodes\n        D, x = chebyshev_diff_matrix(N)\n        \n        # Step 3: Get quadrature matrix\n        H = chebyshev_quadrature_matrix(N)\n        \n        # Step 4: Form the semi-discrete operator L\n        # The base operator is -a*D\n        L = -a * D\n        \n        # Add the upwind SAT penalty term\n        if a > 0:\n            # Inflow is at x = -1, which is node N\n            inflow_idx = N\n            H_inflow = H[inflow_idx, inflow_idx]\n            P = np.zeros((N + 1, N + 1))\n            P[inflow_idx, inflow_idx] = -s / H_inflow\n            L += P\n        elif a  0:\n            # Inflow is at x = 1, which is node 0\n            inflow_idx = 0\n            H_inflow = H[inflow_idx, inflow_idx]\n            P = np.zeros((N + 1, N + 1))\n            P[inflow_idx, inflow_idx] = -s / H_inflow\n            L += P\n        # If a = 0, there is no flow, and L is the zero matrix, which is stable.\n        # This case is not in the test suite.\n\n        # Step 5: Form the symmetric part S\n        S = H @ L + L.T @ H\n\n        # Step 6: Check stability by computing the largest eigenvalue of S\n        # Since S is symmetric, all eigenvalues are real.\n        eigenvalues = np.linalg.eigvalsh(S)\n        max_eigenvalue = np.max(eigenvalues)\n\n        is_stable = max_eigenvalue = stability_tolerance\n        results.append(is_stable)\n\n    # Format output as a list of boolean strings, e.g., \"[False,True,...]\"\n    # Python's `str()` on a boolean correctly yields \"True\" or \"False\".\n    # The problem asks for booleans, let's keep it that way. In Python display they are True/False\n    # but the string representation will depend on the final format. f-string will use `str()`.\n    # Let's check format again. \"Each entry must be a boolean...\". Yes `str()` is fine.\n    # Ah, the example [result1, result2] may refer to the values themselves, not the final string.\n    # The provided example output template in the problem template does `str()`, so `True`/`False` is correct.\n    \n    # Final check of test cases against analytical condition s >= |a|/2\n    # (16, 1.0, 0.0) -> 0.0 >= 0.5 (False)\n    # (16, 1.0, 0.5) -> 0.5 >= 0.5 (True)\n    # (16, 1.0, 1.0) -> 1.0 >= 0.5 (True)\n    # (16, 1.0, 4.0) -> 4.0 >= 0.5 (True)\n    # (16, -1.0, 0.5) -> 0.5 >= 0.5 (True)\n    # (32, 1.0, 2.0) -> 2.0 >= 0.5 (True)\n    # (32, -1.0, 2.0) -> 2.0 >= 0.5 (True)\n    # Expected: [False, True, True, True, True, True, True]\n    \n    # The final print must be exactly as specified\n    print(f\"[{','.join(str(r) for r in results)}]\")\n\n\nsolve()\n```", "id": "3179536"}]}