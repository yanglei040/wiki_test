{"hands_on_practices": [{"introduction": "在ILU分解的实际应用中，一个关键挑战是数值不稳定性，这通常在主元元素为零或接近零时发生。本编程练习将指导你从头开始实现ILU(0)算法，并测试一种常见的稳定化技术：对角扰动。通过找出防止分解失败所需的最小扰动值，你将对这一至关重要的实用工具有一个具体的理解。[@problem_id:3143608]", "problem": "你必须编写一个完整、可运行的程序，通过扫描一组预设的扰动值并报告防止分解失败的最小扰动，来凭经验确定一个小的对角扰动如何在无主元选择的情况下稳定零阶不完全LU分解（incomplete lower-upper factorization (ILU(0))）。仅使用此处陈述的数学推理和算法约束。所有计算都在实数上进行。\n\n基本和核心定义：\n- 从标准高斯消元法框架开始：对于一个方阵 $A \\in \\mathbb{R}^{n \\times n}$，理想的LU分解（无主元选择）旨在寻找一个单位对角线的下三角矩阵 $L$ 和一个上三角矩阵 $U$，使得 $A = L U$。零阶不完全LU分解（ILU(0)）应用相同的消元逻辑，但强制要求 $L$ 和 $U$ 的非零模式不引入任何超出 $A$ 模式（始终包含对角线）的额外填充项。具体来说，如果 $P \\subset \\{(i,j) : 1 \\le i,j \\le n\\}$ 表示 $A$ 的结构非零元集合（包括所有对角线位置 $(i,i)$），则 ILU(0) 计算的 $L$ 和 $U$ 满足：$L$ 是单位下三角矩阵，$U$ 是上三角矩阵，并且对于所有 $(i,j) \\notin P$， $L$（对于 $i>j$）和 $U$（对于 $i \\le j$）中的相应元素都设置为零，且算法永远不会创建它们。\n- 定义对角扰动为 $A_{\\epsilon} = A + \\epsilon I$，其中 $I$ 是大小为 $n$ 的单位矩阵，$\\epsilon \\in \\mathbb{R}$ 是一个非负标量。\n- 定义分解失败为在 ILU(0) 过程中，当需要进行除法运算时，主元 $|U_{jj}|$ 严格小于给定的正容差 $\\tau$ 的情况，即需要除以 $U_{jj}$ 且 $|U_{jj}|  \\tau$。或者等效地，如果在完成第 $i$ 行的更新后，计算出的对角元 $U_{ii}$ 满足 $|U_{ii}|  \\tau$。如果在任何步骤发生这种情况，则认为该 $\\epsilon$ 值的 ILU(0) 分解失败。\n\n任务：\n- 对于下面的每个测试用例，给定一个具体矩阵 $A$、一个候选扰动 $\\epsilon$ 的有限集 $S$ 和一个容差 $\\tau  0$。\n- 对于每个 $\\epsilon \\in S$，尝试对 $A_{\\epsilon}$ 执行 ILU(0) 分解，要求无主元选择并强制执行如上定义的零填充。如果在任何步骤中发现主元 $|U_{jj}|$ 满足 $|U_{jj}|  \\tau$，则声明该 $\\epsilon$ 值的分解失败。\n- 对每个测试用例，确定使 ILU(0) 过程能够无失败完成的最小 $\\epsilon \\in S$（按 $\\mathbb{R}$ 上的常规顺序）。如果 $S$ 中没有 $\\epsilon$ 能避免分解失败，则报告一个非数值浮点数。\n\n强制执行 ILU(0) 的算法约束：\n- 设 $P$ 为 $A$ 的结构非零模式，包含所有对角线元素 $(i,i)$，即使 $A_{ii} = 0$。\n- 按行递增顺序 $i = 1, 2, \\dots, n$ 构造 $L$ 和 $U$ 如下：\n  - 对于每个满足 $1 \\le j  i$ 且 $(i,j) \\in P$ 的 $j$，计算\n    $$\n    L_{ij} = \\frac{A_{\\epsilon,ij} - \\sum_{k=1}^{j-1} L_{ik} \\, U_{kj}}{U_{jj}},\n    $$\n    但仅当 $(i,k) \\in P$ 且 $(k,j) \\in P$ 时，才将乘积 $L_{ik} \\, U_{kj}$ 包含在求和中；如果此时 $|U_{jj}|  \\tau$，则声明分解失败。\n  - 对于每个满足 $i \\le j \\le n$ 且 $(i,j) \\in P$ 的 $j$，计算\n    $$\n    U_{ij} = A_{\\epsilon,ij} - \\sum_{k=1}^{i-1} L_{ik} \\, U_{kj},\n    $$\n    但仅当 $(i,k) \\in P$ 且 $(k,j) \\in P$ 时，才将乘积 $L_{ik} \\, U_{kj}$ 包含在求和中。\n  - 完成第 $i$ 行后，如果 $|U_{ii}|  \\tau$，则声明分解失败。\n- 对于所有 $(i,j) \\notin P$，强制 $L_{ij} = 0$ (当 $ij$) 和 $U_{ij} = 0$ (当 $i \\le j$)；对所有 $i$ 设置 $L_{ii} = 1$。\n\n测试套件：\n对于每个测试，按所列顺序使用给定的 $A$、候选集 $S$ 和容差 $\\tau$。矩阵是显式写出的。\n\n1. 测试 1 (主对角线接近零的三对角矩阵)：\n   - 大小 $n = 5$。\n   - 矩阵\n     $$\n     A = \\begin{bmatrix}\n     0  1  0  0  0 \\\\\n     1  0  1  0  0 \\\\\n     0  1  0  1  0 \\\\\n     0  0  1  0  1 \\\\\n     0  0  0  1  0\n     \\end{bmatrix}.\n     $$\n   - 候选集 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12},\\; 10^{-10},\\; 10^{-8} \\,\\}$。\n   - 容差 $\\tau = 10^{-12}$。\n\n2. 测试 2 (第二步产生小主元)：\n   - 大小 $n = 3$。\n   - 矩阵\n     $$\n     A = \\begin{bmatrix}\n     1  1  0 \\\\\n     1  1  1 \\\\\n     0  1  1\n     \\end{bmatrix}.\n     $$\n   - 候选集 $S = \\{\\, 0,\\; 10^{-16},\\; 5 \\cdot 10^{-13},\\; 10^{-12},\\; 10^{-9} \\,\\}$。\n   - 容差 $\\tau = 10^{-12}$。\n\n3. 测试 3 (严格对角占优对称正定情况)：\n   - 大小 $n = 5$。\n   - 矩阵\n     $$\n     A = \\begin{bmatrix}\n     2  -1  0  0  0 \\\\\n     -1  2  -1  0  0 \\\\\n     0  -1  2  -1  0 \\\\\n     0  0  -1  2  -1 \\\\\n     0  0  0  -1  2\n     \\end{bmatrix}.\n     $$\n   - 候选集 $S = \\{\\, 0,\\; 10^{-16},\\; 10^{-12} \\,\\}$。\n   - 容差 $\\tau = 10^{-12}$。\n\n4. 测试 4 (孤立的微小对角元素)：\n   - 大小 $n = 3$。\n   - 矩阵\n     $$\n     A = \\begin{bmatrix}\n     10^{-16}  0  0 \\\\\n     0  1  0 \\\\\n     0  0  1\n     \\end{bmatrix}.\n     $$\n   - 候选集 $S = \\{\\, 0,\\; 10^{-16},\\; 5 \\cdot 10^{-13},\\; 10^{-12},\\; 10^{-9} \\,\\}$。\n   - 容差 $\\tau = 10^{-12}$。\n\n所需输出格式：\n- 你的程序应生成单行输出，其中包含为测试1到4找到的最小稳定扰动，按顺序排列，形式为方括号内以逗号分隔的列表。如果没有 $\\epsilon \\in S$ 能避免分解失败，则在该位置输出一个非数值浮点值。\n- 格式示例（非实际答案）：$[0.0,1e-12,{\\dots}]$。\n\n角度、物理单位和百分比不适用于此任务；所有数值均为无量纲实数。最终答案必须是无单位的原始浮点数。", "solution": "问题要求根据给定的矩阵 $A$ 和分解失败容差 $\\tau$，从一个给定集合 $S$ 中凭经验确定一个最小的对角扰动 $\\epsilon$，该扰动可以稳定零阶不完全LU分解（ILU(0)）。\n\n方阵 $A$ 的LU分解将其分解为一个单位下三角矩阵 $L$ 和一个上三角矩阵 $U$ 的乘积，使得 $A = LU$。不完全LU分解 ILU($p$) 是这种分解的一种近似，其中允许一定数量的“填充”（在 $A$ 中为零的位置，在 $L$ 和 $U$ 中创建非零元），其数量由阶数 $p$ 控制。此问题中的特定变体是 ILU(0)，其中不允许任何填充。$L$ 和 $U$ 的稀疏模式必须是 $A$ 的稀疏模式的子集。也就是说，如果原始矩阵 $A$ 中的一个元素 $(i,j)$ 为零，那么它在 $L$（如果 $ij$）或 $U$（如果 $i \\le j$）中也必须保持为零。\n\n如果在 $U$ 的对角线上遇到零或非常小的主元，标准的LU分解算法可能会失败（分解失败）。这是因为该算法需要除以这些主元。ILU(0) 算法同样容易出现分解失败。一种常见的预防技术是在 $A$ 的对角线元素上增加一个小的正值。这被称为对角扰动或对角平移。我们构造矩阵 $A_{\\epsilon} = A + \\epsilon I$，其中 $I$ 是单位矩阵，$\\epsilon$ 是一个小的非负标量。这直接增大了对角线元素的量值，从而也倾向于增大主元 $U_{ii}$ 的量值，进而稳定分解过程。任务是从候选集 $S$ 中找到足以防止任何主元的绝对值低于给定容差 $\\tau$ 的最小 $\\epsilon$。\n\n解决这个问题的过程包括实现指定的 ILU(0) 算法，然后对每个测试用例，按升序遍历候选扰动 $\\epsilon \\in S$。第一个使 $A_\\epsilon$ 的 ILU(0) 分解能够无失败完成的 $\\epsilon$ 就是所求的结果。\n\nILU(0) 算法按照问题陈述的约束实现如下。设 $P$ 为对应于 $A$ 中结构非零元的索引 $(i,j)$ 集合，并包括所有对角线位置 $(i,i)$。矩阵 $L$ 和 $U$ 逐行构造，其中 $i = 1, \\dots, n$。\n\n对每一行 $i$：\n1.  计算 $L$ 的第 $i$ 行的相关元素。对于从 $1$ 到 $i-1$ 的每个 $j$，如果 $(i,j) \\in P$：\n    在计算 $L_{ij}$ 之前，对主元 $U_{jj}$ 进行分解失败检查：如果 $|U_{jj}|  \\tau$，则分解失败。否则，我们计算：\n    $$\n    L_{ij} = \\frac{A_{\\epsilon,ij} - \\sum_{k=1}^{j-1} L_{ik} U_{kj}}{U_{jj}}\n    $$\n    求和被限制为只包含 $(i,k) \\in P$ 且 $(k,j) \\in P$ 的项。这强制执行了零填充约束。在实践中，由于 $L$ 和 $U$ 是在遵守模式 $P$ 的前提下构建的，任何索引不在 $P$ 中的项本来也为零。\n\n2.  设置 $L$ 的对角线：$L_{ii} = 1$。\n\n3.  计算 $U$ 的第 $i$ 行的相关元素。对于从 $i$ 到 $n$ 的每个 $j$，如果 $(i,j) \\in P$：\n    $$\n    U_{ij} = A_{\\epsilon,ij} - \\sum_{k=1}^{i-1} L_{ik} U_{kj}\n    $$\n    同样，求和受到稀疏模式 $P$ 的限制。\n\n4.  在计算完第 $i$ 行的所有元素后，对新计算出的主元 $U_{ii}$ 进行最后的分解失败检查：如果 $|U_{ii}|  \\tau$，则分解失败。\n\n如果对所有行 $i=1, \\dots, n$ 此过程都得以完成，且没有任何分解失败检查失败，则认为对于所选的 $\\epsilon$，分解成功。\n\n对于每个提供的测试用例：\n- 候选扰动集 $S$ 已经排序。\n- 我们遍历 $\\epsilon \\in S$。\n- 对于给定的 $\\epsilon$，我们对 $A_{\\epsilon} = A + \\epsilon I$ 运行 ILU(0) 算法，容差为 $\\tau$。\n- 如果算法成功，我们记录这个 $\\epsilon$ 作为该测试用例的最小稳定扰动，并继续处理下一个测试用例。\n- 如果我们遍历了所有 $\\epsilon \\in S$ 且它们都导致了分解失败，我们为该测试用例记录一个非数值（`NaN`）。\n\n最终输出是按指定顺序排列的每个测试用例的最小 $\\epsilon$ 值的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef perform_ilu0(A, epsilon, tau):\n    \"\"\"\n    Performs ILU(0) factorization on a given matrix A with diagonal perturbation.\n\n    Args:\n        A (np.ndarray): The input square matrix.\n        epsilon (float): The non-negative scalar for diagonal perturbation.\n        tau (float): The positive tolerance for pivot breakdown.\n\n    Returns:\n        bool: True if the factorization is successful, False if breakdown occurs.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Create the perturbed matrix A_epsilon = A + epsilon * I\n    A_eps = A.copy()\n    if epsilon  0.0:\n        # Add epsilon to diagonal elements. Using A.copy() ensures original A is not modified.\n        # np.fill_diagonal can be used, but this is more explicit for non-square matrices in general\n        # and equally efficient for square ones.\n        for i in range(n):\n            A_eps[i, i] += epsilon\n\n    # Determine the sparsity pattern P. This includes all structurally\n    # nonzero entries of A, plus all diagonal entries by definition.\n    rows, cols = np.nonzero(A)\n    P = set(zip(rows, cols))\n    for i in range(n):\n        P.add((i, i))\n\n    # Initialize L and U matrices. L will have a unit diagonal.\n    L = np.zeros((n, n), dtype=float)\n    U = np.zeros((n, n), dtype=float)\n\n    for i in range(n):\n        # Compute the i-th row of L (off-diagonal elements, j  i)\n        for j in range(i):\n            if (i, j) in P:\n                # Calculate the sum term in the formula for L_ij\n                s = 0.0\n                # The sum is over k  j. The sparsity constraint on the sum is\n                # implicitly handled because L and U are built with this sparsity.\n                # However, an explicit check follows the problem spec exactly.\n                for k in range(j):\n                    if (i, k) in P and (k, j) in P:\n                        s += L[i,k] * U[k,j]\n                \n                # Breakdown check 1: before division by U_jj\n                if abs(U[j, j])  tau:\n                    return False  # Breakdown\n\n                L[i, j] = (A_eps[i, j] - s) / U[j, j]\n        \n        # Set the diagonal of L to 1\n        L[i, i] = 1.0\n\n        # Compute the i-th row of U (j >= i)\n        for j in range(i, n):\n            if (i, j) in P:\n                # Calculate the sum term in the formula for U_ij\n                s = 0.0\n                # The sum is over k  i.\n                for k in range(i):\n                    if (i, k) in P and (k, j) in P:\n                        s += L[i, k] * U[k, j]\n                \n                U[i, j] = A_eps[i, j] - s\n        \n        # Breakdown check 2: after computing the new diagonal pivot U_ii\n        if abs(U[i, i])  tau:\n            return False  # Breakdown\n    \n    return True  # Success\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and find the minimal stabilizing perturbation.\n    \"\"\"\n    test_cases = [\n        {\n            \"A\": np.array([\n                [0, 1, 0, 0, 0],\n                [1, 0, 1, 0, 0],\n                [0, 1, 0, 1, 0],\n                [0, 0, 1, 0, 1],\n                [0, 0, 0, 1, 0]\n            ], dtype=float),\n            \"S\": [0.0, 1e-16, 1e-12, 1e-10, 1e-8],\n            \"tau\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [1, 1, 0],\n                [1, 1, 1],\n                [0, 1, 1]\n            ], dtype=float),\n            \"S\": [0.0, 1e-16, 5e-13, 1e-12, 1e-9],\n            \"tau\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [ 2, -1,  0,  0,  0],\n                [-1,  2, -1,  0,  0],\n                [ 0, -1,  2, -1,  0],\n                [ 0,  0, -1,  2, -1],\n                [ 0,  0,  0, -1,  2]\n            ], dtype=float),\n            \"S\": [0.0, 1e-16, 1e-12],\n            \"tau\": 1e-12\n        },\n        {\n            \"A\": np.array([\n                [1e-16, 0, 0],\n                [0, 1, 0],\n                [0, 0, 1]\n            ], dtype=float),\n            \"S\": [0.0, 1e-16, 5e-13, 1e-12, 1e-9],\n            \"tau\": 1e-12\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        A, S, tau = case[\"A\"], case[\"S\"], case[\"tau\"]\n        minimal_epsilon = np.nan\n        \n        # The sets S are pre-sorted, so we check epsilon in increasing order.\n        for epsilon in S:\n            if perform_ilu0(A, epsilon, tau):\n                minimal_epsilon = epsilon\n                break  # Found the smallest epsilon, move to the next test case\n        \n        results.append(minimal_epsilon)\n\n    # Format the final output string exactly as required.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3143608"}, {"introduction": "对于大型稀疏系统，ILU分解的性能和稳定性不仅取决于算法本身，还严重依赖于计算的顺序。本项进阶练习探讨了两种相互竞争的重排策略：一种旨在最小化填充以保持稀疏性，另一种旨在最大化对角占优以增强数值稳定性。你将使用标准的科学计算库来比较这两种策略，并亲身体会重排为何是构建稳健ILU预条件子的关键步骤。[@problem_id:3143592]", "problem": "您将编写一个完整、可运行的程序，该程序构建一组稀疏测试矩阵，在计算不完全LU (ILU) 分解之前应用两种重排序策略，并比较量化的稳定性结果。被比较的两种重排序策略是：一种旨在最小化消元过程中的填充（fill-in），另一种旨在最大化对角强度。从稀疏高斯消元、矩阵置换和不完全分解定义的基本事实出发，设计您的算法，计算所需的指标，并报告每个测试用例的决策。此任务不涉及物理单位或角度。\n\n背景与定义。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏矩阵。一个完全LU分解在适当的主元选择下，找到单位下三角矩阵 $L$ 和上三角矩阵 $U$ 使得 $A = L U$。不完全LU (ILU) 分解通过基于舍弃容差和限制填充水平来丢弃某些填充项，从而产生近似的 $A \\approx L U$，得到一个稀疏预条件子。通过置换矩阵对 $A$ 进行重排序可以改变填充模式和主元幅值。设 $P_r \\in \\mathbb{R}^{n \\times n}$ 和 $P_c \\in \\mathbb{R}^{n \\times n}$ 是作用于行和列的置换矩阵。稀疏直接法通常处理一个置换后的系统 $P_r A P_c$。最小化填充通常通过在 $A^\\top + A$ 上使用最小度启发式算法派生的排序来近似实现。最大化对角强度可以看作是将列分配给行以最大化对角元素绝对值之和，这等价于在权重矩阵 $|A|$ 上的线性分配问题。\n\n算法规格。对于给定的稀疏矩阵 $A$，您将计算两个具有相同舍弃和填充参数但不同重排序策略的ILU分解。\n\n- 填充最小化重排序：\n  - 使用基于 $A^\\top + A$ 的近似最小度启发式算法的列置换，此处表示为策略 $P_f$，该策略由标准稀疏求解器选项提供。\n  - 使用求解器内置的填充减少置换选项，计算舍弃容差为 $\\tau$ 且填充因子为 $\\phi$ 的ILU分解。禁用数值主元选择，以使置换策略成为唯一的重排序来源。\n\n- 对角增强重排序：\n  - 通过求解稠密权重矩阵 $|A|$ 上的线性求和分配问题（匈牙利算法），计算一个列置换 $\\Pi$ 以最大化总和 $\\sum_{i=1}^{n} |a_{i, \\pi(i)}|$。应用此列置换形成 $B = A \\Pi$。\n  - 使用相同的 $\\tau$ 和 $\\phi$ 参数，但采用求解器的自然排序选项（无额外填充减少列置换）并禁用数值主元选择，来计算 $B$ 的ILU分解。\n\n对于两种分解，假设求解器返回 $L$、$U$ 以及对应于行和列重排序的内置置换，表示为实现矩阵 $P_r$ 和 $P_c$ 的索引数组。您必须评估以下指标：\n\n1. 归一化分解残差：对于填充最小化情况，形成 $A_{\\text{perm}} = A[P_r, :][:, P_c]$；对于对角增强情况，形成 $B_{\\text{perm}} = B[P_r, :][:, P_c]$，并计算\n   $$\n   r = \\frac{\\left\\|A_{\\text{perm}} - L U\\right\\|_F}{\\left\\|A\\right\\|_F}\n   $$\n   对于填充最小化，以及\n   $$\n   r = \\frac{\\left\\|B_{\\text{perm}} - L U\\right\\|_F}{\\left\\|A\\right\\|_F}\n   $$\n   对于对角增强。此处 $\\|\\cdot\\|_F$ 表示弗罗贝尼乌斯范数。\n\n2. 上三角对角线最小幅值：计算\n   $$\n   d_{\\min} = \\min_{1 \\le i \\le n} \\left| u_{ii} \\right|\n   $$\n   其中 $u_{ii}$ 是 $U$ 的对角线元素。\n\n3. 填充率，定义为\n   $$\n   \\rho = \\frac{\\operatorname{nnz}(L) + \\operatorname{nnz}(U)}{\\operatorname{nnz}(A)}\n   $$\n   其中 $\\operatorname{nnz}(\\cdot)$ 表示非零元素的数量。\n\n决策规则。对于每个测试用例，当且仅当满足以下条件之一时，宣布对角增强重排序为稳定性获胜者：\n- 其分解成功而填充减少分解失败；或\n- 两者均成功，且其归一化残差 $r$ 严格小于填充最小化策略的残差，差值超过容差 $\\epsilon = 10^{-9}$；或\n- 两者均成功且归一化残差之差在 $\\epsilon$ 范围内，但其 $d_{\\min}$ 严格大于填充最小化策略的 $d_{\\min}$（差值大于0）。\n\n否则，宣布填充最小化策略为获胜者。\n\n实现约束。使用标准的稀疏ILU例程，该例程需提供选项来指定舍弃容差和填充因子、作用于 $A^\\top + A$ 的填充减少置换，以及无置换的自然排序。通过将对角主元阈值设置为 $0$ 来禁用数值主元选择。求解线性分配问题以计算对角增强置换 $\\Pi$。仅对于所提供测试套件中的小规模问题，您可以将稀疏矩阵转换为稠密矩阵；程序不应要求任何用户输入。\n\n参数。对所有情况，使用舍弃容差 $\\tau = 10^{-3}$ 和填充因子 $\\phi = 10$。\n\n测试套件。精确实现以下四个测试矩阵（均为方形且大小适中）：\n\n1. $5 \\times 5$ 网格上的二维泊松算子，采用五点差分格式和狄利克雷型结构。设 $T \\in \\mathbb{R}^{5 \\times 5}$ 为三对角矩阵，其次对角线和超对角线元素为 $-1$，对角线元素为 $2$。设 $I \\in \\mathbb{R}^{5 \\times 5}$ 为单位矩阵。定义\n   $$\n   A_1 = I \\otimes T + T \\otimes I \\in \\mathbb{R}^{25 \\times 25}.\n   $$\n\n2. $5 \\times 5$ 网格上的对流扩散算子，其中扩散项如情况1所示，第一坐标方向上的一阶迎风对流强度为 $\\beta = 5$。设 $D \\in \\mathbb{R}^{5 \\times 5}$ 的主对角线元素为 $-1$，超对角线元素为 $1$，其余元素为零。定义\n   $$\n   A_2 = A_1 + \\beta \\, (I \\otimes D) + 0.1 \\, I_{25},\n   $$\n   其中 $I_{25} \\in \\mathbb{R}^{25 \\times 25}$。\n\n3. 需要匹配的非对角占优矩阵。对于 $n=20$，定义 $A_3 \\in \\mathbb{R}^{20 \\times 20}$，其元素满足 $a_{i,(i \\bmod n)+1} = 10$ 和 $a_{i,i} = 10^{-12}$（对所有 $i$），并加上一个量级为 $10^{-2}$、密度为 $0.05$ 的稀疏扰动，添加在均匀随机的位置。使用固定的种子以使随机部分可复现。\n\n4. 近奇异的缩放一维拉普拉斯算子。对于 $n=30$，设 $T \\in \\mathbb{R}^{30 \\times 30}$ 为三对角矩阵，其对角线元素为 $2$，次/超对角线元素为 $-1$。将第一行和第一列乘以因子 $\\delta = 10^{-8}$ 以形成 $A_4$，即对所有 $i,j$ 设置 $a_{1j} \\leftarrow \\delta \\, a_{1j}$ 和 $a_{i1} \\leftarrow \\delta \\, a_{i1}$。\n\n对每个矩阵 $A_k$，应用两种重排序策略并计算决策：如果对角增强是稳定性获胜者，则为 $1$，否则为 $0$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，格式为 $[r_1, r_2, r_3, r_4]$，其中每个 $r_k$ 是根据决策规则定义的整数 $\\{0,1\\}$。例如，一个有效的输出可以是 $[1,0,1,1]$。", "solution": "该问题要求比较稀疏矩阵不完全LU (ILU) 分解的两种不同重排序策略。第一种策略旨在最小化填充，即在分解过程中产生的新非零项，从而保持稀疏性。第二种策略旨在通过置换矩阵将大幅值元素置于对角线上来增强数值稳定性。我们将构建四个特定的测试矩阵，应用两种重排序策略并进行ILU分解，根据规定的量化指标评估结果，并应用决策规则来确定每种情况下的更优策略。\n\n首先，让我们正式阐述两种竞争性重排序策略背后的原理。设 $A \\in \\mathbb{R}^{n \\times n}$ 是一个稀疏矩阵。ILU分解计算一个稀疏的单位下三角矩阵 $L$ 和一个稀疏的上三角矩阵 $U$，使得 $A \\approx LU$。这种近似的质量和计算的稳定性严重依赖于主元序列，而主元序列可以通过置换 $A$ 的行和列来改变。\n\n第一种策略是**填充最小化**。对稀疏矩阵进行高斯消元通常会在 $A$ 中原本为零的位置引入非零值。这种现象称为填充。填充量对主元的选择顺序高度敏感。一个常用且有效的最小化填充的启发式算法是最小度算法。这个贪心算法选择在待分解子矩阵中具有最少非零元素的行/列中的对角元素作为下一个主元。对于非对称矩阵，此启发式算法通常应用于 $A^\\top + A$ 的对称结构。重排序由一个列置换矩阵 $P_f$ 表示，它在分解前对 $A$ 的列进行重排序。\n\n第二种策略是**对角增强**。高斯消元中的数值稳定性会因小主元的出现而受损，这可能导致因子 $L$ 和 $U$ 中元素的巨大增长。一种缓解这种情况的策略是置换矩阵以最大化其对角元素的幅值。这可以被看作一个最大权二分图匹配问题，该问题寻求一个 $\\{1, \\dots, n\\}$ 的置换 $\\pi$，以最大化置换后矩阵中对角元素绝对值之和：\n$$\n\\max_{\\pi} \\sum_{i=1}^{n} |a_{i, \\pi(i)}|\n$$\n这等价于在权重矩阵 $W$（其元素为 $w_{ij} = |a_{ij}|$）上的线性求和分配问题。解决此问题会得到一个列置换矩阵，我们记为 $\\Pi$，使得矩阵 $B = A\\Pi$ 的列被重排以增强对角优势。\n\n对于每个测试矩阵 $A$，我们将执行以下两个过程：\n1.  **填充最小化分解**：我们使用内置的基于 $A^\\top + A$ 的近似最小度置换来计算 $A$ 的ILU分解。禁用数值主元选择以隔离这种结构性重排序的效果。此过程产生因子 $L_f, U_f$ 和求解器决定的置换 $P_{r,f}, P_{c,f}$，使得 $A[P_{r,f},:][:,P_{c,f}] \\approx L_f U_f$。\n2.  **对角增强分解**：我们首先为 $A$ 求解线性分配问题以找到置换 $\\Pi$。我们形成矩阵 $B=A\\Pi$。然后我们使用“自然”（未置换）排序计算 $B$ 的ILU分解。同样，禁用数值主元选择。这会产生因子 $L_d, U_d$ 和置换 $P_{r,d}, P_{c,d}$，使得 $B[P_{r,d},:][:,P_{c,d}] \\approx L_d U_d$。请注意，由于我们对 $B$ 使用自然排序，如果求解器不强制执行任何其他行/列交换，这些置换 $P_{r,d}, P_{c,d}$ 可能是平凡的（单位矩阵）。\n\n这些分解的成功与否和质量通过三个指标进行评估。对于每个策略（我们用 'strat' 作为 'fill' 或 'diag' 的占位符），我们计算：\n-   归一化分解残差，$r_{\\text{strat}}$。对于填充情况，$A_{\\text{perm}} = A[P_{r,f},:][:,P_{c,f}]$ 且 $r_f = \\|A_{\\text{perm}} - L_f U_f\\|_F / \\|A\\|_F$。对于对角增强情况，我们使用置换后的矩阵 $B=A\\Pi$，所以 $B_{\\text{perm}} = B[P_{r,d},:][:,P_{c,d}]$，残差为 $r_d = \\|B_{\\text{perm}} - L_d U_d\\|_F / \\|A\\|_F$。弗罗贝尼乌斯范数由 $\\| \\cdot \\|_F$ 表示。较小的残差表示更准确的分解。\n-   上三角因子对角线的最小幅值，$d_{\\min, \\text{strat}} = \\min_i |(U_{\\text{strat}})_{ii}|$。此指标是数值稳定性的一个代理；较大的值更理想，因为它们对应于较大的主元。\n-   填充率，$\\rho_{\\text{strat}} = (\\operatorname{nnz}(L_{\\text{strat}}) + \\operatorname{nnz}(U_{\\text{strat}})) / \\operatorname{nnz}(A)$，它衡量因子相对于原始矩阵的密度。\n\n该算法过程将对四个不同的测试矩阵执行，这些矩阵旨在以不同方式挑战分解方法。对于每个矩阵，根据问题指定的决策规则宣布一个获胜者。该规则优先考虑成功而非失败，其次是分解精度（较低的残差 $r$），最后是数值稳定性（较大的主元幅值 $d_{\\min}$）。结果为 $1$ 表示对角增强策略更优，而 $0$ 表示填充最小化策略获胜。\n\n测试矩阵是：\n1.  $A_1$：一个对称正定矩阵，代表二维泊松方程。预计两种策略都会表现良好。\n2.  $A_2$：一个非对称的对流扩散算子。非对称性和对流项可能挑战稳定性。\n3.  $A_3$：一个构造的矩阵，其对角线元素非常小，而非对角线元素很大。此案例是专门为使那些不优先将大元素放在对角线上的方法失败而设计的。\n4.  $A_4$：通过缩放一维拉普拉斯算子的一行和一列创建的近奇异矩阵。这测试了方法对近奇异性和不良缩放的鲁棒性。\n\n所有ILU计算的参数是舍弃容差 $\\tau = 10^{-3}$ 和填充因子 $\\phi = 10$。残差比较的决策容差是 $\\epsilon=10^{-9}$。我们接下来将实现这个计算实验。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import diags, kron, identity, csr_matrix, csc_matrix, lil_matrix\nfrom scipy.sparse.linalg import spilu, norm\nfrom scipy.optimize import linear_sum_assignment\nfrom scipy.sparse import rand\n\ndef solve():\n    \"\"\"\n    Main function to run the ILU comparison for all test cases.\n    \"\"\"\n\n    def create_A1():\n        \"\"\"Creates test matrix A1: Poisson on a 5x5 grid.\"\"\"\n        n_grid = 5\n        T = diags([-1, 2, -1], [-1, 0, 1], shape=(n_grid, n_grid), format='csr')\n        I = identity(n_grid, format='csr')\n        A1 = kron(I, T) + kron(T, I)\n        return A1.tocsc()\n\n    def create_A2():\n        \"\"\"Creates test matrix A2: Convection-diffusion on a 5x5 grid.\"\"\"\n        n_grid = 5\n        beta = 5.0\n        A1 = create_A1()\n        I_grid = identity(n_grid, format='csr')\n        I_full = identity(n_grid**2, format='csr')\n        D = diags([-1, 1], [0, 1], shape=(n_grid, n_grid), format='csr')\n        A2 = A1 + beta * kron(I_grid, D) + 0.1 * I_full\n        return A2.tocsc()\n\n    def create_A3():\n        \"\"\"Creates test matrix A3: Off-diagonally large matrix.\"\"\"\n        n = 20\n        # Off-diagonal part: a_{i, (i%n)+1} = 10\n        row = np.arange(n)\n        col = (np.arange(n) + 1) % n\n        data = np.full(n, 10.0)\n        A3_offdiag = csr_matrix((data, (row, col)), shape=(n, n))\n\n        # Diagonal part: a_{i,i} = 1e-12\n        A3_diag = diags([1e-12], [0], shape=(n, n), format='csr')\n\n        # Random perturbation\n        rng = np.random.default_rng(42)\n        # scipy.sparse.rand in older versions uses np.random, newer can take a generator.\n        # To ensure backward compatibility, we set the seed directly.\n        np.random.seed(42)\n        A3_rand = rand(n, n, density=0.05, format='csr')\n        A3_rand.data *= 1e-2\n\n        A3 = A3_offdiag + A3_diag + A3_rand\n        return A3.tocsc()\n\n    def create_A4():\n        \"\"\"Creates test matrix A4: Nearly singular scaled Laplacian.\"\"\"\n        n = 30\n        delta = 1e-8\n        T = diags([-1, 2, -1], [-1, 0, 1], shape=(n, n), format='lil')\n        A4 = T.copy()\n        A4[0, :] *= delta\n        A4[:, 0] *= delta\n        return A4.tocsc()\n\n    def analyze_matrix(A, tau, phi):\n        \"\"\"\n        Performs both ILU strategies on a matrix A and returns the metrics.\n        \"\"\"\n        # --- Strategy 1: Fill-in Minimization ---\n        try:\n            # MMD_AT_PLUS_A is specified, which is a fill-reducing permutation on A^T + A\n            ilu_fill = spilu(A, drop_tol=tau, fill_factor=phi, \n                             permc_spec='MMD_AT_PLUS_A', diag_pivot_thresh=0)\n            \n            L_f, U_f = ilu_fill.L, ilu_fill.U\n            pr_f, pc_f = ilu_fill.perm_r, ilu_fill.perm_c\n            \n            A_perm_f = A[pr_f, :][:, pc_f]\n            residual_f = norm(A_perm_f - L_f @ U_f, 'fro') / norm(A, 'fro')\n            d_min_f = np.min(np.abs(U_f.diagonal()))\n            success_f = True\n        except RuntimeError:\n            success_f = False\n            residual_f, d_min_f = np.inf, 0\n\n        # --- Strategy 2: Diagonal Strengthening ---\n        try:\n            # Find permutation to maximize diagonal entries\n            cost_matrix = -np.abs(A.toarray())\n            _, p_col = linear_sum_assignment(cost_matrix)\n            \n            # Apply column permutation: B = A * Pi\n            B = A[:, p_col]\n\n            # Factorize B with natural ordering\n            ilu_diag = spilu(B, drop_tol=tau, fill_factor=phi, \n                             permc_spec='NATURAL', diag_pivot_thresh=0)\n                             \n            L_d, U_d = ilu_diag.L, ilu_diag.U\n            pr_d, pc_d = ilu_diag.perm_r, ilu_diag.perm_c\n\n            B_perm_d = B[pr_d, :][:, pc_d]\n            # Residual is normalized by original matrix A's norm\n            residual_d = norm(B_perm_d - L_d @ U_d, 'fro') / norm(A, 'fro')\n            d_min_d = np.min(np.abs(U_d.diagonal()))\n            success_d = True\n        except RuntimeError:\n            success_d = False\n            residual_d, d_min_d = np.inf, 0\n\n        return (success_f, residual_f, d_min_f), (success_d, residual_d, d_min_d)\n\n    test_cases = [create_A1, create_A2, create_A3, create_A4]\n    results = []\n    tau = 1e-3\n    phi = 10.0\n    epsilon = 1e-9\n\n    for create_matrix_func in test_cases:\n        A = create_matrix_func()\n        \n        fill_stats, diag_stats = analyze_matrix(A, tau, phi)\n        \n        success_f, r_fill, d_min_fill = fill_stats\n        success_d, r_diag, d_min_diag = diag_stats\n\n        # Decision Rule\n        diag_is_winner = 0\n        if success_d and not success_f:\n            diag_is_winner = 1\n        elif success_d and success_f:\n            if r_diag  r_fill - epsilon:\n                diag_is_winner = 1\n            elif abs(r_diag - r_fill) = epsilon and d_min_diag  d_min_fill:\n                diag_is_winner = 1\n        \n        results.append(diag_is_winner)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3143592"}]}