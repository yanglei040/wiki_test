{"hands_on_practices": [{"introduction": "在我们深入探讨利用克雷洛夫子空间求解问题的各种方法之前，首先必须牢固掌握这个核心概念。本练习将通过一个具体的计算任务，引导你亲手构建一个克雷洛夫子空间，并通过判断基向量的线性无关性来确定其维度。这个基础实践将帮助你从根本上理解这些高级迭代算法所依赖的数学结构([@problem_id:2183348])。", "problem": "考虑由下式给出的实矩阵 $A$ 和实列向量 $b$：\n$$A = \\begin{pmatrix} 1  1  0 \\\\ 1  2  1 \\\\ 0  1  1 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 4 \\\\ 1 \\\\ 0 \\end{pmatrix}$$\n由 $A$ 和 $b$ 生成的 $m$ 阶Krylov子空间，记作 $\\mathcal{K}_m(A, b)$，是由向量 $\\{b, Ab, A^2b, \\dots, A^{m-1}b\\}$ 张成的线性子空间。求Krylov子空间 $\\mathcal{K}_3(A, b)$ 的维数。", "solution": "Krylov子空间 $\\mathcal{K}_{3}(A,b)$ 是由 $\\{b, Ab, A^{2}b\\}$ 张成的空间。为了确定其维数，我们计算这些向量并检验它们的线性无关性。\n给定\n$$\nA=\\begin{pmatrix}1  1  0 \\\\ 1  2  1 \\\\ 0  1  1\\end{pmatrix},\\quad b=\\begin{pmatrix}4\\\\1\\\\0\\end{pmatrix},\n$$\n我们计算\n$$\nAb=A\\begin{pmatrix}4\\\\1\\\\0\\end{pmatrix}=\\begin{pmatrix}1\\cdot 4+1\\cdot 1+0\\cdot 0\\\\1\\cdot 4+2\\cdot 1+1\\cdot 0\\\\0\\cdot 4+1\\cdot 1+1\\cdot 0\\end{pmatrix}=\\begin{pmatrix}5\\\\6\\\\1\\end{pmatrix}.\n$$\n接下来，\n$$\nA^{2}b=A(Ab)=A\\begin{pmatrix}5\\\\6\\\\1\\end{pmatrix}=\\begin{pmatrix}1\\cdot 5+1\\cdot 6+0\\cdot 1\\\\1\\cdot 5+2\\cdot 6+1\\cdot 1\\\\0\\cdot 5+1\\cdot 6+1\\cdot 1\\end{pmatrix}=\\begin{pmatrix}11\\\\18\\\\7\\end{pmatrix}.\n$$\n将这些向量作为列构成矩阵：\n$$\nK=\\begin{pmatrix}4  5  11 \\\\ 1  6  18 \\\\ 0  1  7\\end{pmatrix}.\n$$\n这些向量线性无关当且仅当 $\\det(K)\\neq 0$。计算\n$$\n\\det(K)=4\\begin{vmatrix}6  18 \\\\ 1  7\\end{vmatrix}-5\\begin{vmatrix}1  18 \\\\ 0  7\\end{vmatrix}+11\\begin{vmatrix}1  6 \\\\ 0  1\\end{vmatrix}\n=4(42-18)-5(7)+11(1)=96-35+11=72\\neq 0.\n$$\n因此，$\\{b, Ab, A^{2}b\\}$ 是线性无关的，并且 $\\mathcal{K}_{3}(A,b)$ 的维数是 $3$。", "answer": "$$\\boxed{3}$$", "id": "2183348"}, {"introduction": "共轭梯度（CG）法是求解大型对称正定线性系统的首选克雷洛夫子空间方法。本练习聚焦于算法的起始步骤，即计算最优步长 $\\alpha_0$ ([@problem_id:2183332])。通过解决这个问题，你将深入理解驱动 CG 方法每一步迭代的优化思想——在当前搜索方向上最小化误差，这也是该算法高效性的关键所在。", "problem": "共轭梯度（CG）法是一种用于数值求解线性方程組 $Ax = b$ 的迭代算法，其中矩阵 $A$ 是对称正定（SPD）的。该方法生成一个近似解序列 $x_k$，该序列收敛于真实解。\n\n考虑由以下公式定义的 $2 \\times 2$ 线性方程组 $Ax = b$：\n$$\nA = \\begin{pmatrix} 3   2 \\\\ 2   3 \\end{pmatrix}, \\quad b = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\n$$\nCG算法的第一步是从一个初始猜测值 $x_0$ 开始，计算一个改进解 $x_1$。更新由公式 $x_1 = x_0 + \\alpha_0 p_0$ 给出，其中 $p_0$ 是初始搜索方向，$\\alpha_0$ 是使沿此方向误差最小化的最优步长。\n\n给定初始猜测值 $x_0 = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$，求共轭梯度法第一次迭代的最优步长 $\\alpha_0$ 的值。\n\n将您的答案表示为最简分数形式。", "solution": "对于使用对称正定矩阵的共轭梯度法，初始搜索方向为 $p_{0} = r_{0}$，其中残差为 $r_{0} = b - A x_{0}$。沿 $p_{0}$ 方向使二次型 $f(x) = \\frac{1}{2} x^{T} A x - b^{T} x$ 最小化的最优步长可以通过最小化 $f(x_{0} + \\alpha p_{0})$ 得到，结果为\n$$\n\\alpha_{0} = \\frac{p_{0}^{T} r_{0}}{p_{0}^{T} A p_{0}}.\n$$\n当 $p_{0} = r_{0}$ 时，上式变为\n$$\n\\alpha_{0} = \\frac{r_{0}^{T} r_{0}}{r_{0}^{T} A r_{0}}.\n$$\n\n使用 $x_{0} = \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix}$ 计算残差：\n$$\nA x_{0} = \\begin{pmatrix} 3   2 \\\\ 2   3 \\end{pmatrix} \\begin{pmatrix} 1 \\\\ 1 \\end{pmatrix} = \\begin{pmatrix} 5 \\\\ 5 \\end{pmatrix}, \\quad\nr_{0} = b - A x_{0} = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix} - \\begin{pmatrix} 5 \\\\ 5 \\end{pmatrix} = \\begin{pmatrix} -4 \\\\ -5 \\end{pmatrix}.\n$$\n那么\n$$\nr_{0}^{T} r_{0} = (-4)^{2} + (-5)^{2} = 16 + 25 = 41,\n$$\n以及\n$$\nA r_{0} = \\begin{pmatrix} 3   2 \\\\ 2   3 \\end{pmatrix} \\begin{pmatrix} -4 \\\\ -5 \\end{pmatrix} = \\begin{pmatrix} -22 \\\\ -23 \\end{pmatrix}, \\quad\nr_{0}^{T} A r_{0} = \\begin{pmatrix} -4   -5 \\end{pmatrix} \\begin{pmatrix} -22 \\\\ -23 \\end{pmatrix} = 88 + 115 = 203.\n$$\n因此，\n$$\n\\alpha_{0} = \\frac{41}{203}.\n$$\n分数 $\\frac{41}{203}$ 已是最简形式。", "answer": "$$\\boxed{\\frac{41}{203}}$$", "id": "2183332"}, {"introduction": "理论告诉我们，矩阵的谱分布（即特征值的分布）对共轭梯度法的收敛速度有决定性影响，但这种影响如何定量地展现出来？本练习将指导你从计算转向实验，通过编写一段数值程序来亲身验证这一重要理论 ([@problem_id:3149643])。你将构建具有不同特征值分布的矩阵，并观察 CG 方法收敛速度的显著差异，从而深刻理解算法性能背后的数学原理。", "problem": "要求您设计并执行一个数值实验，从第一性原理出发，阐释对称正定（SPD）矩阵的特征值聚集如何加速共轭梯度（CG）法（一种克雷洛夫子空间方法）。该实验必须实现为一个完整、可运行的程序。您的程序必须构造形如 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\}_{i=1}^n)\\, Q^\\top$ 的矩阵，其中 $Q$ 是一个正交矩阵，而特征值 $\\{\\lambda_i\\}$ 的选择旨在产生不同的谱聚集模式。您必须跟踪由共轭梯度（CG）法生成的残差序列 $\\{\\lVert r_k \\rVert_2\\}_{k=0,1,\\dots}$ 的欧几里得二范数，其中 $r_k = b - A x_k$，并以此来量化收敛性。\n\n请從以下核心定义和经过充分检验的事实出发：\n- 如果一个实矩阵 $A \\in \\mathbb{R}^{n \\times n}$ 满足 $A^\\top = A$ 且对于所有非零 $x \\in \\mathbb{R}^n$ 都有 $x^\\top A x > 0$，则该矩阵是对称正定（SPD）的。\n- 共轭梯度（CG）法是一种克雷洛夫子空间（KS）法，对于 SPD 矩阵 $A$，它产生的迭代解 $x_k \\in x_0 + \\mathcal{K}_k(A,r_0)$，其残差为 $r_k = b - A x_k$，其中第 $k$ 个克雷洛夫子空间是 $\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, A^2 r_0, \\dots, A^{k-1} r_0\\}$。\n- 存在一个满足 $p_k(0) = 1$ 的 $k$ 次多项式 $p_k$，使得 $r_k = p_k(A)\\, r_0$。因此，CG 的收敛性取决于一个 $k$ 次多项式在 $A$ 的谱（即集合 $\\{\\lambda_i\\}$）上能变得多小。\n\n您的程序必须执行以下操作：\n1. 固定维度 $n = 120$，最大迭代次数 $K_{\\max} = 50$，以及容差 $\\text{tol} = 10^{-10}$。使用初始猜测值 $x_0 = 0$ 和一个固定的右端项 $b \\in \\mathbb{R}^n$，该右端项的各元素为使用固定种子 $s_b = 27182$ 生成的独立标准正态分布项。使用固定种子 $s_Q = 31415$ 构造一个单一的正交矩阵 $Q \\in \\mathbb{R}^{n \\times n}$，方法是生成一个高斯随机矩阵，应用 $QR$ 分解，并调整列的符号以使 $Q$ 为正交矩阵（该过程近似于从正交群上的哈尔分布中进行一次抽样）。\n2. 对于下述每个测试用例，使用指定的特征值构造 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\})\\, Q^\\top$。运行共轭梯度（CG）法最多 $K_{\\max}$ 次迭代，跟踪相对残差范数序列 $\\rho_k = \\lVert r_k \\rVert_2 / \\lVert r_0 \\rVert_2$（$k = 0,1,\\dots,K_{\\max}$）。将测试用例的收斂迭代次数定义为满足 $\\rho_k \\le \\text{tol}$ 的最小整数 $k \\in \\{1,2,\\dots,K_{\\max}\\}$。如果在 $K_{\\max}$ 步内不存在这样的 $k$，则将次数记为 $K_{\\max} + 1$。\n3. 对所有测试用例使用相同的 $Q$ 和 $b$，以分离特征值分布的影响。\n\n测试套件（四个矩阵，旨在覆盖一个理想情况、一个分布广泛的谱、一个双簇情况以及一个边界情况）：\n- 案例 1（带两个离群值的紧密簇）：\n  - 维度 $n = 120$。\n  - 特征值：$116$ 个 $1.0$，$2$ 个 $5.0$，$2$ 个 $20.0$。\n- 案例 2（均匀分布的谱）：\n  - 维度 $n = 120$。\n  - 特征值：$120$ 个在闭区间 $\\left[0.1,\\,20.0\\right]$ 上线性间隔的不同值。\n- 案例 3（两个紧密簇）：\n  - 维度 $n = 120$。\n  - 特征值：$60$ 个 $0.5$ 和 $60$ 个 $5.0$。\n- 案例 4（边界情况：完美聚集）：\n  - 维度 $n = 120$。\n  - 特征值：$120$ 个 $3.0$。\n\n实现要求：\n- 使用基于残差和搜索方向的三项递推关系实现 CG，其中 $x_0 = 0$，$r_0 = b$，$p_0 = r_0$，步长 $\\alpha_k = \\dfrac{r_k^\\top r_k}{p_k^\\top A p_k}$，更新 $x_{k+1} = x_k + \\alpha_k p_k$ 和 $r_{k+1} = r_k - \\alpha_k A p_k$，以及方向更新 $p_{k+1} = r_{k+1} + \\beta_{k+1} p_k$，其中 $\\beta_{k+1} = \\dfrac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k}$。\n- 通过构造确保 $A$ 是严格对称的。\n\n最终输出规范：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。该列表必须包含四个整数，每个测试用例一个，按上面列出的顺序排列。对于每个测试用例，输出上文定义的收敛迭代次数。例如，输出必须类似于：\n  - 示例格式：$[\\text{case1\\_count},\\text{case2\\_count},\\text{case3\\_count},\\text{case4\\_count}]$。\n- 不得打印任何额外文本。\n\n不涉及角度单位，也没有物理单位。所有数值答案必须按照上述规则报告为整数。不需要用户输入；程序必须是自包含的，并在给定种子下具有确定性。", "solution": "我们从共轭梯度（CG）法在对称正定（SPD）矩阵上的基本性质以及克雷洛夫子空间的结构出发。设 $A \\in \\mathbb{R}^{n \\times n}$ 为 SPD 矩阵，$b \\in \\mathbb{R}^n$，并给定初始猜测值 $x_0 \\in \\mathbb{R}^n$。残差为 $r_k = b - A x_k$。CG 的第 $k$ 次迭代解满足 $x_k \\in x_0 + \\mathcal{K}_k(A,r_0)$，其中 $\\mathcal{K}_k(A,r_0) = \\operatorname{span}\\{r_0, A r_0, \\dots, A^{k-1} r_0\\}$。存在一个次数为 $k$ 且满足 $p_k(0) = 1$ 的多项式 $p_k$，使得 $r_k = p_k(A)\\, r_0$。这种多项式表示揭示了，CG 的收敛性取决于一个受 $p_k(0)=1$ 约束的 $k$ 次多项式在谱 $\\sigma(A) = \\{\\lambda_i\\}_{i=1}^n$ 上能变得多小。\n\n如果谱是聚集的，那么就存在次数相对较低的多项式，这些多项式在这些簇上同时很小。在极端情况下，即 $A$ 恰好有 $m$ 个不同特征值时，存在一个 $m$ 次多项式 $q$ 可以插值，使得对每个不同特征值 $\\lambda^{(j)}$ 都有 $q(\\lambda^{(j)}) = 0$，且满足 $q(0) = 1$。那么 $q(A)$ 是对应于这些特征值的不变子空间上的零算子，并且在精确算術中，CG 最多在 $m$ 步内终止，且 $r_m = 0$。这一原理是特征值聚集能够加速 CG 的一个根本原因。\n\n相比之下，如果特征值分布在一个宽区间内且有许多不同的值，那么受 $p_k(0)=1$ 约束的最佳 $k$ 次多项式在整个分布区间上无法一致地变小，除非 $k$ 很大。一个经典推论是涉及条件数 $\\kappa(A)$ 的基于切比雪夫的多项式界（在误差的 $A$-范数下），其中因子 $\\left(\\frac{\\sqrt{\\kappa}-1}{\\sqrt{\\kappa}+1}\\right)^k$ 控制着衰减率；宽泛的谱分布通常会增加 $\\kappa(A)$ 并减慢收敛速度。\n\n实验的算法设计：\n1. 我们将矩阵构造为 $A = Q \\,\\operatorname{diag}(\\{\\lambda_i\\})\\, Q^\\top$，其中 $Q$ 是正交矩阵。我们在所有测试中使用一个固定的 $Q$ 来分离谱效应。正交矩阵 $Q$ 是通过创建一个高斯随机矩阵并应用带有列符号归一化的 QR 分解来生成的，以使 $Q^\\top Q = I$。此方法近似于一个哈尔分布的正交矩阵。\n2. 我们将 $b$ 生成为标准正态随机向量，以避免偏向任何特定的特征子空间，并固定种子以保证可复现性。我们使用 $x_0 = 0$，因此 $r_0 = b$。\n3. 我们使用三项递推关系实现 CG：\n   - 初始化 $x_0 = 0$，$r_0 = b$，$p_0 = r_0$，$\\rho_0 = \\lVert r_0 \\rVert_2 / \\lVert r_0 \\rVert_2 = 1$。\n   - 对于 $k = 0,1,\\dots,K_{\\max}-1$：\n     - 计算 $Ap_k = A p_k$，$\\alpha_k = \\dfrac{r_k^\\top r_k}{p_k^\\top A p_k}$。\n     - 更新 $x_{k+1} = x_k + \\alpha_k p_k$，$r_{k+1} = r_k - \\alpha_k Ap_k$。\n     - 计算 $\\rho_{k+1} = \\lVert r_{k+1} \\rVert_2 / \\lVert r_0 \\rVert_2$。\n     - 如果 $\\rho_{k+1} \\le \\text{tol}$，将收敛迭代次数记录为 $k+1$ 并停止该案例的计算。\n     - 否则，计算 $\\beta_{k+1} = \\dfrac{r_{k+1}^\\top r_{k+1}}{r_k^\\top r_k}$ 并设置 $p_{k+1} = r_{k+1} + \\beta_{k+1} p_k$。\n   - 如果在 $K_{\\max}$ 步内没有 $\\rho_k$ 达到容差，则将次数定义为 $K_{\\max}+1$。\n4. 测试套件设计：\n   - 案例 1 使用 $116$ 个 $\\lambda = 1.0$ 和两个离群值 $\\lambda = 5.0$ 和 $\\lambda = 20.0$（各两个）。只有 3 个不同的特征值，因此在精确算術中，CG 最多在 3 步内终止。因此我们预期迭代次数会非常小。\n   - 案例 2 使用 $120$ 个在 $\\left[0.1, 20.0\\right]$ 上均匀分布的不同特征值。谱分布很宽，且许多不同的值意味着 CG 需要多次迭代才能减小残差，所以我们预期在 $K_{\\max} = 50$ 步内不会收敛到 $\\text{tol} = 10^{-10}$，从而得到次数 $51$。\n   - 案例 3 使用一个双簇谱，其中有 $60$ 个 $\\lambda = 0.5$ 和 $60$ 个 $\\lambda = 5.0$。有 2 个不同的特征值，因此在精确算術中，CG 最多在 2 步内终止。我们预期次数约为 2。\n   - 案例 4 是边界情况，有 $120$ 个 $\\lambda = 3.0$。只有 1 个不同的特征值；在精确算術中，CG 在 1 步内终止。在数值上，使用双精度计算，相对残差在一步之后应远低于 $\\text{tol} = 10^{-10}$。\n\n给定固定的种子，$n = 120$，容差 $\\text{tol} = 10^{-10}$ 和 $K_{\\max} = 50$，程序确定性地计算每个案例中使得 $\\rho_k \\le \\text{tol}$ 的最小 $k$。基于上述谱推理，预期的输出是强调由聚集带来的加速效应的整数。具体来说，我们预计结果为：\n- 案例 1：$3$，\n- 案例 2：$51$，\n- 案例 3：$2$，\n- 案例 4：$1$。\n\n最终程序将按案例顺序列出一行输出，包含四个逗号分隔的整数，并用方括号括起来，即 [3,51,2,1]。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef random_orthogonal(n: int, seed: int) - np.ndarray:\n    rng = np.random.default_rng(seed)\n    G = rng.standard_normal((n, n))\n    # QR decomposition\n    Q, R = np.linalg.qr(G)\n    # Normalize signs to ensure deterministic orientation\n    d = np.sign(np.diag(R))\n    d[d == 0] = 1.0\n    Q = Q @ np.diag(d)\n    return Q\n\ndef build_spd_from_spectrum(eigs: np.ndarray, Q: np.ndarray) - np.ndarray:\n    D = np.diag(eigs)\n    A = Q @ D @ Q.T\n    # Symmetrize to counteract tiny numerical asymmetry\n    A = 0.5 * (A + A.T)\n    return A\n\ndef conjugate_gradient(A: np.ndarray, b: np.ndarray, kmax: int, tol: float):\n    n = A.shape[0]\n    x = np.zeros(n)\n    r = b.copy()\n    p = r.copy()\n    rTr = float(r @ r)\n    r0_norm = np.sqrt(rTr)\n    rel_residuals = [1.0]  # k=0\n    if r0_norm == 0.0:\n        return rel_residuals, 0  # Already converged\n    for k in range(kmax):\n        Ap = A @ p\n        denom = float(p @ Ap)\n        # For SPD, denom should be positive\n        if denom == 0:\n            # Breakdown (should not happen for SPD), stop\n            return rel_residuals, kmax + 1\n        alpha = rTr / denom\n        x = x + alpha * p\n        r = r - alpha * Ap\n        r_new_Tr = float(r @ r)\n        rel = np.sqrt(r_new_Tr) / r0_norm\n        rel_residuals.append(rel)\n        if rel = tol:\n            return rel_residuals, (k + 1)\n        beta = r_new_Tr / rTr\n        p = r + beta * p\n        rTr = r_new_Tr\n    return rel_residuals, (kmax + 1)\n\ndef solve():\n    # Common parameters\n    n = 120\n    K_max = 50\n    tol = 1e-10\n    seed_Q = 31415\n    seed_b = 27182\n\n    # Construct a single orthogonal Q\n    Q = random_orthogonal(n, seed_Q)\n\n    # Right-hand side b\n    rng_b = np.random.default_rng(seed_b)\n    b = rng_b.standard_normal(n)\n\n    # Test cases (eigenvalue spectra)\n    # Case 1: 116 x 1.0, 2 x 5.0, 2 x 20.0\n    eigs_case1 = np.array([1.0]*116 + [5.0]*2 + [20.0]*2, dtype=float)\n\n    # Case 2: 120 distinct values in [0.1, 20.0]\n    eigs_case2 = np.linspace(0.1, 20.0, n, dtype=float)\n\n    # Case 3: 60 x 0.5, 60 x 5.0\n    eigs_case3 = np.array([0.5]*60 + [5.0]*60, dtype=float)\n\n    # Case 4: 120 x 3.0\n    eigs_case4 = np.array([3.0]*n, dtype=float)\n\n    spectra = [eigs_case1, eigs_case2, eigs_case3, eigs_case4]\n\n    results = []\n    for eigs in spectra:\n        A = build_spd_from_spectrum(eigs, Q)\n        _, iters = conjugate_gradient(A, b, K_max, tol)\n        results.append(int(iters))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3149643"}]}