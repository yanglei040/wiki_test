{"hands_on_practices": [{"introduction": "许多域分解方法的核心思想，是将一个庞大的全局问题转化为一个规模更小、仅定义在子域间交界面上的问题。本练习将指导您推导一个典型一維问题的舒尔补系统（Schur complement system），它正是交界面问题的数学体现[@problem_id:3120749]。通过亲手进行分块高斯消元，您将具体理解子域的内部未知量是如何被消除的，以及它们的耦合效应如何被凝聚成一个控制交界面的算子。", "problem": "考虑区间 $[0,L]$ 上的一维泊松边值问题 $-u''(x)=f(x)$，其齐次狄利克雷边界条件为 $u(0)=0$ 和 $u(L)=0$。使用具有 $n$ 个内部网格点、网格间距为 $h=L/(n+1)$ 的均匀网格，以及标准的二阶中心有限差分 (FD) 格式对该区间进行离散化，得到一个线性系统 $A u = b$，其中 $A \\in \\mathbb{R}^{n \\times n}$ 是一个三对角矩阵，其元素为 $A_{ii}=2/h^2$ 和 $A_{i,i\\pm 1}=-1/h^2$。\n\n采用一种在 $x=\\xi$ 处具有单个界面节点的非重叠区域分解 (DD)，其中 $\\xi$ 与某个满足 $1kn$ 的节点 $x_k$ 重合。这将自由度划分为三个组：左子域的内部自由度 $\\{u_1,\\dots,u_{k-1}\\}$，界面自由度 $\\{u_k\\}$，以及右子域的内部自由度 $\\{u_{k+1},\\dots,u_n\\}$。将该问题重写为分块形式：\n$$\n\\begin{pmatrix} A_{LL}  a_L  0 \\\\ a_L^T  a_{\\Gamma\\Gamma}  a_R^T \\\\ 0  a_R  A_{RR} \\end{pmatrix}\n\\begin{pmatrix} u_L \\\\ u_\\Gamma \\\\ u_R \\end{pmatrix}\n=\n\\begin{pmatrix} b_L \\\\ b_\\Gamma \\\\ b_R \\end{pmatrix}\n$$\n推导出关于界面自由度 $u_\\Gamma = u_k$ 的舒尔补算子 $S$ 的表达式，其中 $S u_\\Gamma = \\tilde{b}_\\Gamma$。", "solution": "我们从算子 $-u''(x)$ 在均匀网格上的标准二阶中心有限差分格式开始。对于 $n$ 个内部点和网格间距 $h=L/(n+1)$，得到的线性系统为\n$$\nA u = b,\\quad A=\\frac{1}{h^2} T_n,\\quad T_n=\\operatorname{tridiag}(-1,2,-1),\n$$\n其中 $u \\in \\mathbb{R}^n$ 汇集了节点值 $u_1,\\dots,u_n$，$b \\in \\mathbb{R}^n$ 汇集了缩放后的载荷值。\n\n我们将索引集划分为三个不相交的部分以反映区域分解：左侧内部 $\\{1,\\dots,k-1\\}$、界面 $\\Gamma=\\{k\\}$ 和右侧内部 $\\{k+1,\\dots,n\\}$，其中 $1kn$。根据此划分对矩阵 $A$ 和向量 $u, b$ 进行重新排序，得到如下所示的分块系统：\n$$\n\\begin{pmatrix} A_{LL}  a_L  0 \\\\ a_L^T  a_{\\Gamma\\Gamma}  a_R^T \\\\ 0  a_R  A_{RR} \\end{pmatrix}\n\\begin{pmatrix} u_L \\\\ u_\\Gamma \\\\ u_R \\end{pmatrix}\n=\n\\begin{pmatrix} b_L \\\\ b_\\Gamma \\\\ b_R \\end{pmatrix}\n$$\n舒尔补算子 $S$ 是通过形式化地消除内部自由度 $u_L$ 和 $u_R$ 导出的。从第一行和第三行方程中，我们求解内部自由度：\n$$\nu_L = A_{LL}^{-1}(b_L - a_L u_\\Gamma) \\quad\\text{和}\\quad u_R = A_{RR}^{-1}(b_R - a_R u_\\Gamma)\n$$\n将这些表达式代入第二行方程：\n$$\na_L^T A_{LL}^{-1}(b_L - a_L u_\\Gamma) + a_{\\Gamma\\Gamma} u_\\Gamma + a_R^T A_{RR}^{-1}(b_R - a_R u_\\Gamma) = b_\\Gamma\n$$\n重新整理各项，得到关于 $u_\\Gamma$ 的舒尔补系统 $S u_\\Gamma = \\tilde{b}_\\Gamma$，其中舒尔补算子 $S$ 为\n$$\nS = a_{\\Gamma\\Gamma} - a_L^T A_{LL}^{-1} a_L - a_R^T A_{RR}^{-1} a_R,\n$$\n修改后的右端项为 $\\tilde{b}_\\Gamma = b_\\Gamma - a_L^T A_{LL}^{-1} b_L - a_R^T A_{RR}^{-1} b_R$。\n\n现在我们来确定 $S$ 的具体形式。根据有限差分矩阵的结构，我们有：\n- $A_{LL}$ 是大小为 $(k-1) \\times (k-1)$ 的矩阵 $\\frac{1}{h^2} T_{k-1}$。\n- $A_{RR}$ 是大小为 $(n-k) \\times (n-k)$ 的矩阵 $\\frac{1}{h^2} T_{n-k}$。\n- $a_{\\Gamma\\Gamma}$ 是与 $u_k$ 相关的对角元，即 $2/h^2$。\n- $a_L$ 是将 $u_L$ 耦合到 $u_\\Gamma$ 的列向量。它在第 $k-1$ 个位置有一个非零元，值为 $-1/h^2$。即 $a_L = \\frac{-1}{h^2} e_{k-1}$。\n- $a_R$ 是将 $u_R$ 耦合到 $u_\\Gamma$ 的列向量。它在第 $1$ 个位置有一个非零元，值为 $-1/h^2$。即 $a_R = \\frac{-1}{h^2} e_1$。\n\n代入这些值，我们得到\n$$\nS = \\frac{2}{h^2} - \\left(\\frac{-1}{h^2} e_{k-1}\\right)^T \\left(\\frac{1}{h^2} T_{k-1}\\right)^{-1} \\left(\\frac{-1}{h^2} e_{k-1}\\right) - \\left(\\frac{-1}{h^2} e_1\\right)^T \\left(\\frac{1}{h^2} T_{n-k}\\right)^{-1} \\left(\\frac{-1}{h^2} e_1\\right)\n$$\n$$\nS = \\frac{2}{h^2} - \\frac{1}{h^2} e_{k-1}^T T_{k-1}^{-1} e_{k-1} - \\frac{1}{h^2} e_1^T T_{n-k}^{-1} e_1\n$$\n$e_{i}^T T_m^{-1} e_{j}$ 给出逆矩阵 $T_m^{-1}$ 的第 $(i,j)$ 个元素。因此，我们需要 $T_{k-1}^{-1}$ 的第 $(k-1,k-1)$ 个元素和 $T_{n-k}^{-1}$ 的第 $(1,1)$ 个元素。矩阵 $T_m^{-1}$ 的元素由 $(T_m^{-1})_{ij} = \\frac{\\min(i,j)(m+1-\\max(i,j))}{m+1}$ 给出。\n对于 $A_{LL}$，我们有 $m = k-1$，所以 $(T_{k-1}^{-1})_{k-1,k-1} = \\frac{(k-1)(k-1+1-k+1)}{k-1+1} = \\frac{k-1}{k}$。\n对于 $A_{RR}$，我们有 $m = n-k$，所以 $(T_{n-k}^{-1})_{1,1} = \\frac{1(n-k+1-1)}{n-k+1} = \\frac{n-k}{n-k+1}$。\n\n将这些结果代入 $S$ 的表达式中：\n$$\nS = \\frac{2}{h^2} - \\frac{1}{h^2}\\frac{k-1}{k} - \\frac{1}{h^2}\\frac{n-k}{n-k+1} = \\frac{1}{h^2}\\left(2 - \\frac{k-1}{k} - \\frac{n-k}{n-k+1}\\right)\n$$\n$$\nS = \\frac{1}{h^2}\\left(\\left(1-\\frac{k-1}{k}\\right) + \\left(1-\\frac{n-k}{n-k+1}\\right)\\right) = \\frac{1}{h^2}\\left(\\frac{1}{k} + \\frac{1}{n-k+1}\\right)\n$$", "answer": "$$\\boxed{\\frac{1}{h^{2}}\\left(\\frac{1}{k}+\\frac{1}{n-k+1}\\right)}$$", "id": "3120749"}, {"introduction": "并行算法并非没有代价；划分任务带来的好处会被处理器之间的通信开销所抵消。本练习聚焦于量化并行域分解中的这一关键开销[@problem_id:3120777]。通过根据网格规模和子域数量推导通信总量的精确公式，您将建立起对并行化与通信之间权衡的量化直觉，这是高性能计算中的一个核心主题。", "problem": "考虑求解一个标量椭圆型偏微分方程，该方程定义在一个大小为 $n \\times n$ 的均匀结构化网格上，每个网格点有 $1$ 个标量自由度。该区域通过块区域分解法 (DDM) 被划分为 $\\sqrt{p} \\times \\sqrt{p}$ 个连续的矩形子区域，其中 $p$ 是一个完全平方数，且 $n$ 可被 $\\sqrt{p}$ 整除。假设在定常迭代法的每次迭代中，都进行一次宽度为 $1$ 个网格点的最近邻光环交换，并且每对相邻子区域在每次迭代中都双向交换其整个共享边界。不执行角点（对角）交换，物理边界不产生进程间通信。将每次迭代的通信量定义为跨越所有进程边界发送的标量值的总数，该总数是对所有进程求和，并计入每次邻居交换的两个方向。\n\n基于每次迭代的通信量与界面自由度数量成比例的原则，根据上述假设，推导出一个关于 $n$ 和 $p$ 的每次迭代总通信量的精确闭式表达式。请用一个关于 $n$ 和 $p$ 的单一解析表达式来表示你的最终答案。不要对结果进行近似或四舍五入。", "solution": "该问题要求为一个在分区区域上求解的标量椭圆问题，推导其每次迭代总通信量的精确闭式表达式。推导必须基于所给定的参数和假设。\n\n首先，我们确定区域分解的几何结构。全局区域是一个大小为 $n \\times n$ 的均匀结构化网格。该区域被划分为 $p$ 个子区域，排列成一个 $\\sqrt{p} \\times \\sqrt{p}$ 的连续矩形块阵列。由于 $p$ 是一个完全平方数，且 $n$ 可被 $\\sqrt{p}$ 整除，因此每个子区域都是一个大小为 $m \\times m$ 的均匀方形网格，其中 $m$ 由下式给出：\n$$\nm = \\frac{n}{\\sqrt{p}}\n$$\n问题陈述了通信是最近邻光环交换，并且物理边界不产生进程间通信。因此，通信量仅在相邻子区域之间的内部界面上产生。其原则是通信量与界面自由度的数量成正比。我们首先来量化这些界面。\n\n子区域的 $\\sqrt{p} \\times \\sqrt{p}$ 排列形成了一个界面网格。我们可以分别计算水平界面和垂直界面的数量。\n有 $\\sqrt{p}$ 列子区域。这种排列产生了 $\\sqrt{p}-1$ 列垂直界面。每一列垂直界面都贯穿整个区域的高度，该高度由 $\\sqrt{p}$ 个子区域组成。因此，每一列垂直界面包含 $\\sqrt{p}$ 个独立的界面段。垂直界面的总数 $N_{vert}$ 为：\n$$\nN_{vert} = \\sqrt{p}(\\sqrt{p}-1)\n$$\n同样地，有 $\\sqrt{p}$ 行子区域，产生了 $\\sqrt{p}-1$ 行水平界面。每一行水平界面都贯穿整个区域的宽度，该宽度由 $\\sqrt{p}$ 个子区域组成。因此，每一行水平界面包含 $\\sqrt{p}$ 个独立的界面段。水平界面的总数 $N_{horiz}$ 为：\n$$\nN_{horiz} = \\sqrt{p}(\\sqrt{p}-1)\n$$\n内部界面的总数 $N_{iface}$ 是垂直界面和水平界面数量之和：\n$$\nN_{iface} = N_{vert} + N_{horiz} = \\sqrt{p}(\\sqrt{p}-1) + \\sqrt{p}(\\sqrt{p}-1) = 2\\sqrt{p}(\\sqrt{p}-1)\n$$\n这些界面中的每一个都代表了两个相邻子区域之间的一条共享边界。任何这样一条边界的长度对应于一个子区域一侧的网格点数，即 $m$。\n\n接下来，我们量化与单个界面相关的通信量。光环交换的宽度为 $1$ 个网格点。对于共享一个长度为 $m$ 的界面的任意一对相邻子区域（例如 $A$ 和 $B$），子区域 $A$ 向子区域 $B$ 发送一层包含 $m$ 个标量值的数据，子区域 $B$ 也向子区域 $A$ 发送一层包含 $m$ 个标量值的数据。问题将总通信量 $V$ 定义为跨所有进程边界发送的所有标量值的总和，并计入每次交换的两个方向。对于单个界面，其通信量贡献是双向发送数据之和：\n$$\nV_{iface} = m + m = 2m\n$$\n每次迭代的总通信量 $V$ 是内部界面总数 $N_{iface}$ 与每个界面的通信量 $V_{iface}$ 的乘积。\n$$\nV = N_{iface} \\times V_{iface} = \\left( 2\\sqrt{p}(\\sqrt{p}-1) \\right) \\times (2m)\n$$\n现在，我们将 $m = \\frac{n}{\\sqrt{p}}$ 的表达式代入 $V$ 的方程中，以将总体积表示为 $n$ 和 $p$ 的函数：\n$$\nV = \\left( 2\\sqrt{p}(\\sqrt{p}-1) \\right) \\times \\left( 2 \\frac{n}{\\sqrt{p}} \\right)\n$$\n分子和分母中的 $\\sqrt{p}$ 项相互抵消，得到简化后的表达式：\n$$\nV = 2(\\sqrt{p}-1) \\times 2n\n$$\n$$\nV = 4n(\\sqrt{p}-1)\n$$\n此表达式代表了每次迭代的精确总通信量。它与内部边界上的总自由度数 $2n(\\sqrt{p}-1)$ 成正比，这与问题陈述中提到的指导原则一致。因子 $2$ 源于跨越每个边界点的数据交换的双向性。", "answer": "$$\n\\boxed{4n(\\sqrt{p}-1)}\n$$", "id": "3120777"}, {"introduction": "在许多复杂问题中，计算负载在整个求解域内的分布并不均匀，这会导致负载不均，从而严重影响并行效率。这个动手编程挑战旨在解决此问题，要求您实现一个结合了层次化区域细化与局部负载迁移的动态负载均衡方案[@problem_id:3120721]。此任务从静态分析转向动态自适应，为您在设计能够在真实、演化的计算场景中保持高性能的算法方面，提供了宝贵的实践经验。", "problem": "给定一个一维域，该域被分解为多个子域，每个子域包含一定数量的自由度（DOF）。子域 $i$ 在时间步 $t$ 的负载表示为 $L_i(t)$，定义为在时间 $t$ 分配给子域 $i$ 的自由度数量。在时间 $t$，子域的总数为 $n(t)$，并且总负载是守恒的，即对于所有 $t$，$\\sum_{i=1}^{n(t)} L_i(t) = \\text{constant}$。时间 $t$ 的平均负载为 $\\bar{L}(t) = \\frac{1}{n(t)} \\sum_{i=1}^{n(t)} L_i(t)$。时间 $t$ 的瞬时不平衡度量定义为 $$I(t) = \\frac{\\max_{1 \\le i \\le n(t)} L_i(t)}{\\bar{L}(t)} - 1.$$\n\n请实现一个分层负载均衡方案，该方案基于以下守恒和局部迁移的原则：\n- 基本定义：$L_i(t)$ 计算自由度，因此在负载迁移和分裂下，$\\sum_{i=1}^{n(t)} L_i(t)$ 是不变的，前提是分裂仅将一个子域的自由度进行细分，而不创建或移除自由度。\n- 分层分裂：在每次迭代 $t \\to t+1$ 中，识别出重负载子域 $i$，其满足 $L_i(t)  (1 + \\tau)\\,\\bar{L}(t)$ 且其当前分层级别 $\\ell_i(t)$ 满足 $\\ell_i(t)  L_{\\max}$。对于每个这样的重负载子域，用两个子子域替换它，这两个子子域在一维环形排序中相邻插入，负载分别为 $L_i(t)/2$ 和 $L_i(t)/2$，级别为 $\\ell_i(t)+1$。将单次迭代中执行的分裂次数限制为 $S_{\\max}$，优先选择最重的合格子域。邻接关系是一个环：每个子域有两个相邻子域，一个在左，一个在右，两端环绕连接。\n- 守恒的局部迁移：在迭代 $t$ 中进行分层分裂后，将负载从过载子域迁移到相邻子域。对于每个子域 $i$，计算其过载量 $\\delta_i(t) = \\max\\{0,\\,L_i(t) - \\bar{L}(t)\\}$。将数量为 $\\alpha\\,\\delta_i(t)$ 的负载移出子域 $i$，平均分配给其左右相邻子域。这定义了流出量 $O_i(t) = \\alpha\\,\\delta_i(t)$ 和从相邻子域流入 $i$ 的流入量 $I_i(t) = \\frac{1}{2} O_{i-1}(t) + \\frac{1}{2} O_{i+1}(t)$，其中索引在模 $n(t)$ 意义下理解，以遵循环形结构。通过以下方式同时更新负载：$$L_i(t+1) = L_i(t) - O_i(t) + I_i(t)。$$ 这保持了 $\\sum_i L_i(t)$ 的守恒。\n\n对于每个测试用例，您必须测量两个量：\n- 峰值不平衡度 $I_{\\text{peak}}$，定义为从 $t=0$（任何均衡操作前的初始状态）到首次满足 $I(s) \\le \\varepsilon$ 的迭代 $s$（包含 $s$）期间 $I(t)$ 的最大值，如果不存在这样的 $s$，则为到 $t = T_{\\max}$ 为止的最大值。\n- 恢复步数 $s$，定义为满足 $I(t) \\le \\varepsilon$ 的最小非负整数 $t$。如果在 $T_{\\max}$ 次迭代内没有恢复，则报告 $s = -1$。\n\n从以下基础开始：\n- 初始负载向量 $\\mathbf{L}^{(0)}$ 给出环形邻接中各分量 $L_i(0)$。\n- 初始级别均为 $\\ell_i(0) = 0$。\n- 在每次迭代中，执行最多 $S_{\\max}$ 次如上定义的分裂，然后使用分数 $\\alpha$ 执行如上定义的迁移。参数 $\\tau$ 是相对于平均值的重负载阈值缩放因子，$L_{\\max}$ 是允许的最大分层级别，$S_{\\max}$ 是每次迭代的分裂上限，$\\alpha$ 是以小数表示的迁移分数（不是百分比），$T_{\\max}$ 是最大迭代次数，$\\varepsilon$ 是恢复容忍度阈值。\n\n设计并实现一个完整的程序，为下面的测试套件中的每个测试用例计算 $I_{\\text{peak}}$ 和 $s$。所有结果表示为没有物理单位的纯数字。不使用角度。任何分数或比率（如 $\\alpha$ 或 $\\tau$）必须作为小数量处理。\n\n测试套件（每个测试用例是一个元组 $(\\mathbf{L}^{(0)}, L_{\\max}, S_{\\max}, \\tau, \\alpha, T_{\\max}, \\varepsilon)$）：\n- 情况 1（有一个重负载子域的一般情况）：$(\\mathbf{L}^{(0)} = [8,8,8,30],\\, L_{\\max} = 2,\\, S_{\\max} = 1,\\, \\tau = 0.25,\\, \\alpha = 0.4,\\, T_{\\max} = 20,\\, \\varepsilon = 0.05)$。\n- 情况 2（边界情况，已平衡）：$(\\mathbf{L}^{(0)} = [10,10,10,10],\\, L_{\\max} = 1,\\, S_{\\max} = 1,\\, \\tau = 0.2,\\, \\alpha = 0.3,\\, T_{\\max} = 10,\\, \\varepsilon = 0.01)$。\n- 情况 3（边缘情况，单个子域极重且允许多次分裂）：$(\\mathbf{L}^{(0)} = [50,5,5,5,5],\\, L_{\\max} = 3,\\, S_{\\max} = 2,\\, \\tau = 0.1,\\, \\alpha = 0.2,\\, T_{\\max} = 50,\\, \\varepsilon = 0.02)$。\n- 情况 4（边缘情况，无迁移，受限分裂）：$(\\mathbf{L}^{(0)} = [20,5,5,5,5],\\, L_{\\max} = 1,\\, S_{\\max} = 1,\\, \\tau = 0.2,\\, \\alpha = 0.0,\\, T_{\\max} = 10,\\, \\varepsilon = 0.1)$。\n\n您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表。每个测试用例的结果必须是一个双元素列表 $[I_{\\text{peak}}, s]$，其中 $I_{\\text{peak}}$ 是一个四舍五入到 $6$ 位小数的浮点数，$s$ 是一个整数。例如，输出应类似于 $[[0.123456,7],[0.000000,0],\\dots]$，方括号内没有任何空格。", "solution": "用户提供的问题陈述已经过分析和验证。所有定义、条件和参数都被判断为在计算负载均衡的背景下是自洽的、有科学依据的，并且足够明确以产生唯一、可验证的解决方案。该问题是一个有效的算法挑战。\n\n任务是模拟一个一维环形子域上的分层负载均衡方案，该过程经过一系列时间步。模拟必须跟踪每个子域的负载，动态地分裂过载的子域并将负载迁移到相邻子域，目标是达到平衡状态。我们需要为每个提供的测试用例计算两个度量：峰值不平衡度 $I_{\\text{peak}}$ 和恢复步数 $s$。\n\n该解决方案被设计为一个离散时间模拟。在任何时间步 $t$，系统的状态由负载向量 $\\mathbf{L}^{(t)} = [L_1(t), L_2(t), \\dots, L_{n(t)}(t)]$ 和相应的分层级别向量 $\\boldsymbol{\\ell}^{(t)} = [\\ell_1(t), \\ell_2(t), \\dots, \\ell_{n(t)}(t)]$ 完全描述。模拟从 $t=0$ 迭代进行，最多到 $T_{\\max}$。\n\n以下是针对单个测试用例的算法分步解析：\n\n**1. 初始化**\n- 使用提供的初始负载 $\\mathbf{L}^{(0)}$ 设置 $t=0$ 时的初始状态，并将所有初始级别设置为零，即对所有 $i$ 都有 $\\ell_i(0)=0$。\n- 计算总负载 $L_{\\text{total}} = \\sum_{i=1}^{n(0)} L_i(0)$。这个量在整个模拟过程中是守恒的。\n- 创建一个空列表 `imbalance_history`，用于存储每个步骤的不平衡度量 $I(t)$。\n- 恢复步数初始化为 $s = -1$。\n\n**2. 迭代循环**\n模拟从时间 $t=0$ 迭代到 $T_{\\max}$。对于每个步骤 $t$：\n\n**步骤 2a：计算不平衡度并检查恢复情况**\n- 子域数量 $n(t)$ 是当前负载向量的长度。\n- 计算平均负载：$\\bar{L}(t) = L_{\\text{total}} / n(t)$。\n- 找到最大负载：$L_{\\max}(t) = \\max_i L_i(t)$。\n- 根据其定义计算瞬时不平衡度量：$I(t) = (L_{\\max}(t) / \\bar{L}(t)) - 1$。\n- 将值 $I(t)$ 记录在 `imbalance_history` 中。\n- 执行恢复检查：如果 $I(t) \\le \\varepsilon$ 且尚未找到恢复点，则将当前步数 $t$ 记录为恢复步数 $s$，并终止此测试用例的模拟循环。\n\n**步骤 2b：分层分裂**\n如果循环继续（即 $t  T_{\\max}$ 且未恢复），则更新系统状态。这从分裂阶段开始。\n- 计算一个子域被认为是“重负载”的阈值：$L_{\\text{heavy}} = (1 + \\tau) \\bar{L}(t)$。\n- 编译一个符合分裂条件的子域列表。如果子域 $i$ 的负载 $L_i(t) > L_{\\text{heavy}}$ 且其级别 $\\ell_i(t)  L_{\\max}$，则该子域符合条件。\n- 将符合条件的子域列表按其负载降序排序。这对于满足“优先分裂最重的合格子域”的要求至关重要。\n- 从这个排序后的列表中选择前 $S_{\\max}$ 个子域进行分裂。\n- 构建一组新的负载和级别向量。对于每个原始子域 $i$，如果它未被选中进行分裂，则将其负载 $L_i(t)$ 和级别 $\\ell_i(t)$ 复制到新向量中。如果它被选中，则它被替换为两个子子域，每个子域的负载为 $L_i(t)/2$，级别为 $\\ell_i(t)+1$。这些子子域在其父子域的位置上相邻插入。\n\n**步骤 2c：负载迁移**\n在分裂阶段之后，子域的数量可能已发生变化。迁移阶段使用此更新后的状态进行。\n- 确定新的子域数量 $n'$ 和新的平均负载 $\\bar{L}' = L_{\\text{total}} / n'$。\n- 对于更新后列表中的每个子域 $i$，计算其过载量：$\\delta_i = \\max\\{0, L_i - \\bar{L}'\\}$。\n- 每个子域的流出量则为 $O_i = \\alpha \\delta_i$。\n- 基于环形拓扑，流入每个子域 $i$ 的量是其相邻子域流出量的一半之和：$I_i = \\frac{1}{2} O_{i-1} + \\frac{1}{2} O_{i+1}$，其中索引取模 $n'$ 以处理环绕情况。\n- 执行同步更新以得到下一个时间步 $t+1$ 的负载：$L_i(t+1) = L_i - O_i + I_i$。级别向量从分裂后的状态继承而来。这些新的负载和级别构成了下一次迭代开始时的状态。\n\n**3. 最终确定**\n循环终止后（因恢复或达到 $t=T_{\\max}$）：\n- 如果在步数 $s$ 发生恢复，则峰值不平衡度 $I_{\\text{peak}}$ 是 `imbalance_history` 中直到并包括索引 $s$ 的最大值。\n- 如果没有发生恢复，则 $s$ 保持为 $-1$，而 $I_{\\text{peak}}$ 是整个 `imbalance_history`（从 $t=0$ 到 $t=T_{\\max}$）中的最大值。\n- 对 $[I_{\\text{peak}}, s]$ 即为该测试用例的结果。\n\n实现将使用 Python 和 `numpy` 库来方便进行向量化计算，特别是对于迁移步骤，可以使用 `np.roll` 等数组操作来优雅地表达基于环形拓扑的相邻数据交换。负载将作为浮点数处理，以适应除法和分数迁移规则。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the simulation for all test cases and print the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1 (general case with one heavy subdomain)\n        ({'L0': [8, 8, 8, 30], 'L_max': 2, 'S_max': 1, 'tau': 0.25, 'alpha': 0.4, 'T_max': 20, 'epsilon': 0.05}),\n        # Case 2 (boundary, already balanced)\n        ({'L0': [10, 10, 10, 10], 'L_max': 1, 'S_max': 1, 'tau': 0.2, 'alpha': 0.3, 'T_max': 10, 'epsilon': 0.01}),\n        # Case 3 (edge, very heavy single subdomain and multiple allowed splits)\n        ({'L0': [50, 5, 5, 5, 5], 'L_max': 3, 'S_max': 2, 'tau': 0.1, 'alpha': 0.2, 'T_max': 50, 'epsilon': 0.02}),\n        # Case 4 (edge, no migration, limited splitting)\n        ({'L0': [20, 5, 5, 5, 5], 'L_max': 1, 'S_max': 1, 'tau': 0.2, 'alpha': 0.0, 'T_max': 10, 'epsilon': 0.1}),\n    ]\n\n    results = []\n    for case in test_cases:\n        result = run_simulation(**case)\n        results.append(result)\n\n    result_strings = [f\"[{res[0]:.6f},{res[1]}]\" for res in results]\n    print(f\"[{','.join(result_strings)}]\")\n\ndef run_simulation(L0, L_max, S_max, tau, alpha, T_max, epsilon):\n    \"\"\"\n    Executes the hierarchical load balancing simulation for a single test case.\n    \"\"\"\n    loads = [float(l) for l in L0]\n    levels = [0] * len(L0)\n    \n    total_load = sum(loads)\n    imbalance_history = []\n    recovery_step = -1\n\n    for t in range(T_max + 1):\n        # Step 2a: Calculate Imbalance and Check for Recovery\n        n = len(loads)\n        if n == 0:\n            imbalance = 0.0\n        else:\n            avg_load = total_load / n\n            max_load = max(loads) if loads else 0.0\n            imbalance = (max_load / avg_load) - 1.0 if avg_load > 0 else 0.0\n        \n        imbalance_history.append(imbalance)\n\n        if recovery_step == -1 and imbalance = epsilon:\n            recovery_step = t\n            break  # Terminate on recovery\n\n        if t == T_max:\n            break # Do not update state after the final time step\n\n        # Step 2b: Hierarchical Splitting\n        avg_load = total_load / len(loads) if loads else 0.0\n        heavy_threshold = (1.0 + tau) * avg_load\n        \n        eligible_for_split = []\n        for i in range(len(loads)):\n            if loads[i] > heavy_threshold and levels[i]  L_max:\n                eligible_for_split.append((loads[i], i))\n\n        eligible_for_split.sort(key=lambda x: x[0], reverse=True)\n        indices_to_split = {idx for load, idx in eligible_for_split[:S_max]}\n\n        if indices_to_split:\n            new_loads = []\n            new_levels = []\n            for i in range(len(loads)):\n                if i in indices_to_split:\n                    parent_load = loads[i]\n                    parent_level = levels[i]\n                    new_loads.extend([parent_load / 2.0, parent_load / 2.0])\n                    new_levels.extend([parent_level + 1, parent_level + 1])\n                else:\n                    new_loads.append(loads[i])\n                    new_levels.append(levels[i])\n            loads = new_loads\n            levels = new_levels\n        \n        # Step 2c: Load Migration\n        n_after_split = len(loads)\n        if n_after_split = 1:\n            continue\n            \n        loads_np = np.array(loads, dtype=np.float64)\n        avg_load_after_split = total_load / n_after_split\n        \n        overloads = np.maximum(0, loads_np - avg_load_after_split)\n        outflows = alpha * overloads\n        \n        # Inflow to i is 0.5 * outflow from i-1 and 0.5 * outflow from i+1\n        inflows = 0.5 * (np.roll(outflows, 1) + np.roll(outflows, -1))\n        \n        loads_np = loads_np - outflows + inflows\n        loads = loads_np.tolist()\n        \n    # Finalization\n    if recovery_step != -1:\n        peak_imbalance = max(imbalance_history[:recovery_step + 1])\n    else:\n        peak_imbalance = max(imbalance_history)\n\n    return peak_imbalance, recovery_step\n\nsolve()\n\n```", "id": "3120721"}]}