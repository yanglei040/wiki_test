{"hands_on_practices": [{"introduction": "平滑粒子流体动力学（SPH）方法的核心是平滑核函数，它将离散的粒子属性平滑到连续的场中。核函数最重要的特性是其归一性，即在整个空间中的积分为1（$\\int W dV = 1$）。这个特性是保证质量守恒和近似精度的基石。本练习将通过数值方法验证常用的三次样条核函数的这一性质，从而加深对SPH数学基础的理解。[@problem_id:3194379]", "problem": "您的任务是设计并实现一个数值实验，以验证平滑粒子流体动力学（SPH）中的核函数归一化。目标是数值近似计算选定的SPH核函数 $W(\\mathbf{r}, h)$ 的空间积分，并检验在一系列光滑长度 $h$ 下，其结果是否接近 $1$。该实验应以纯粹的数学和算法术语进行表述，并由一个单一、完整的程序来执行。\n\n基本依据：使用平滑粒子流体动力学（SPH）中标准的、广泛采用的三次样条核函数定义。该核函数是径向对称的，因此 $W(\\mathbf{r}, h) = W(r, h)$，其中 $r = \\lVert \\mathbf{r} \\rVert$。三次样条核函数由以下分段函数定义：\n$$\nW(r,h) = \\frac{\\sigma_d}{h^d}\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中 $q = \\frac{r}{h}$，$d \\in \\{1, 2, 3\\}$ 是空间维度，$\\sigma_d$ 是依赖于维度的归一化常数：\n- 对于 $d = 1$，$\\sigma_1 = \\frac{2}{3}$。\n- 对于 $d = 2$，$\\sigma_2 = \\frac{10}{7\\pi}$。\n- 对于 $d = 3$，$\\sigma_3 = \\frac{1}{\\pi}$。\n\n实验设计要求：\n- 使用径向简化方法，数值近似计算空间积分 $\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h)\\, dV$。由于 $W$ 仅依赖于 $r$，您必须用 $r$ 来表示体积元 $dV$：\n    - 对于 $d = 1$，在 $r \\in [0, 2h]$ 上，$dV = 2\\, dr$。\n    - 对于 $d = 2$，在 $r \\in [0, 2h]$ 上，$dV = 2\\pi r\\, dr$。\n    - 对于 $d = 3$，在 $r \\in [0, 2h]$ 上，$dV = 4\\pi r^2\\, dr$。\n- 使用 $N$ 个采样点的均匀划分和复合梯形法则，在区间 $r \\in [0, 2h]$ 上执行数值积分。\n- 对于每个测试用例，计算数值近似值\n$$\nI(d,h,N) \\approx \\int_0^{2h} W(r,h)\\, S_d(r)\\, dr,\n$$\n其中 $S_d(r)$ 是相应的径向曲面测度因子，具体为 $S_1(r) = 2$，$S_2(r) = 2\\pi r$ 和 $S_3(r) = 4\\pi r^2$。\n\n输出规格：\n- 对于每个测试用例，返回一个布尔值，该值指示数值近似值 $I(d,h,N)$ 是否在 $1$ 的 $10^{-5}$ 容差范围内，即 $\\lvert I(d,h,N) - 1 \\rvert \\le 10^{-5}$ 是否成立。\n- 最终的程序输出必须是单行文本，其中包含所有测试用例的结果，格式为一个用方括号括起来的逗号分隔列表（例如，$[true,false,true]$，其中 Python 布尔值写作 $True$ 或 $False$）。\n\n单位规格：\n- 积分 $\\int W\\, dV$ 是无量纲的。所有报告的布尔值都是无单位的。\n\n测试套件：\n评估以下测试用例，每个用例由元组 $(d,h,N)$ 给出：\n1. $(1, 0.05, 100)$: 一维理想路径，具有较小的 $h$ 和中等分辨率 $N$。\n2. $(2, 0.05, 100)$: 二维理想路径，具有较小的 $h$ 和中等分辨率 $N$。\n3. $(3, 0.05, 100)$: 三维理想路径，具有较小的 $h$ 和中等分辨率 $N$。\n4. $(3, 1.0, 1000)$: 三维情况，具有较大的 $h$ 和高分辨率 $N$。\n5. $(2, 0.5, 600)$: 二维情况，具有中等大小的 $h$ 和高分辨率 $N$。\n6. $(1, 2.0, 1200)$: 一维情况，具有大 $h$ 和高分辨率 $N$。\n\n您的程序必须实现以上要求，并生成单行输出，其中按顺序包含六个布尔值，格式为用方括号括起来的逗号分隔列表。", "solution": "用户提供的问题是有效的。这是一个来自计算科学领域的适定的、有科学依据的任务，具体涉及验证平滑粒子流体动力学（SPH）核函数的一个基本性质。所有必要的信息都已提供，任务是基于标准的数学和算法原理来实现一个数值实验。\n\n解决方案是基于以下原理及其到算法的转化而设计的。\n\n### 1. 核函数归一化原理\n\n在 SPH 中，物理量是通过对邻近粒子的贡献求和来近似的，这些贡献由一个核函数 $W$ 加权。为了使该方法准确并守恒质量等物理量，核函数必须是归一化的。这意味着它在整个空间上的积分必须等于1：\n$$\n\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h) \\, dV = 1\n$$\n此处，$d$ 是空间维度的数量，$h$ 是定义核函数支撑域大小的光滑长度，$dV$ 是体积元。问题要求对三次样条核函数进行数值验证。\n\n### 2. 三次样条核函数\n\n问题提供了标准三次样条核函数的定义，它是一个具有紧支撑的分段多项式函数（仅在 $r  2h$ 时非零）。其公式为：\n$$\nW(r,h) = \\frac{\\sigma_d}{h^d}\n\\begin{cases}\n1 - \\frac{3}{2} q^2 + \\frac{3}{4} q^3,  0 \\le q  1, \\\\\n\\frac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中 $r = \\lVert \\mathbf{r} \\rVert$ 是径向距离，$q = r/h$ 是归一化半径，$\\sigma_d$ 是一个依赖于维度的常数（$\\sigma_1 = 2/3$，$\\sigma_2 = 10/(7\\pi)$，$\\sigma_3 = 1/\\pi$），其选择是为了确保归一化性质在解析上成立。\n\n该核函数的算法实现涉及创建一个以 $r$、$h$ 和 $d$ 为输入的函数。在该函数内部，计算 $q$ 的值。需要使用条件逻辑根据 $q$ 的值选择正确的多项式段。为了高效地对 $r$ 值数组进行计算，NumPy 的布尔数组掩码是应用分段公式的理想向量化选择。\n\n### 3. 积分的径向简化\n\n核函数 $W(r,h)$ 是径向对称的，意味着其值仅取决于到原点的距离 $r$，而与方向无关。这种对称性使得 $d$ 维积分可以显著简化。我们可以将积分从笛卡尔坐标变换到广义球坐标。体积元 $dV$ 变为 $r$ 和角度变量的函数。首先对角度变量进行积分，会得到一个因子，即半径为 $r$ 的超球体的表面积。这将多维积分简化为关于径向坐标 $r$ 的一维积分。\n$$\n\\int_{\\mathbb{R}^d} W(\\mathbf{r}, h) \\, dV = \\int_0^\\infty W(r,h) \\, S_d(r) \\, dr\n$$\n其中 $S_d(r)$ 是问题陈述中提供的“曲面测度因子”：\n- 对于 $d=1$：“体积”元是 $dx$。积分为 $\\int_{-2h}^{2h} W(x,h) dx$。由于偶对称性（$W$ 取决于 $r=|x|$），这等于 $2 \\int_0^{2h} W(r,h) dr$。因此，$S_1(r) = 2$。\n- 对于 $d=2$：体积元为 $dV = r \\, dr \\, d\\theta$。对 $\\theta$ 从 $0$ 到 $2\\pi$ 积分，得到一个因子 $2\\pi$。因此，$S_2(r) = 2\\pi r$。\n- 对于 $d=3$：体积元为 $dV = r^2 \\sin\\theta \\, dr \\, d\\theta \\, d\\phi$。对立体角（$\\int_0^{2\\pi} \\int_0^\\pi \\sin\\theta \\, d\\theta \\, d\\phi$）积分，得到 $4\\pi$。因此，$S_3(r) = 4\\pi r^2$。\n\n由于核函数在 $r=2h$ 范围内具有紧支撑（即对于 $r \\ge 2h$，$W(r,h) = 0$），积分上限变为 $2h$。最终需要数值计算的积分是：\n$$\nI(d,h) = \\int_0^{2h} W(r,h) \\, S_d(r) \\, dr\n$$\n被积函数为 $f(r) = W(r,h) S_d(r)$。算法将首先计算核函数值 $W(r,h)$，然后乘以根据维度 $d$ 选择的相应因子 $S_d(r)$，从而构建该被积函数。\n\n### 4. 通过复合梯形法则进行数值积分\n\n为了近似定积分 $I(d,h)$，问题指定了复合梯形法则。该方法通过将积分区间 $[0, 2h]$ 分成若干子区间，并对连接每个子区间端点处的函数值所形成的梯形面积求和，来近似被积函数下方的面积。\n\n对于一个区间 $[a,b]$，由 $N$ 个等距点 $\\{r_0, \\dots, r_{N-1}\\}$ 划分为 $N-1$ 个子区间，步长为 $\\Delta r = (b-a)/(N-1)$，其公式为：\n$$\n\\int_a^b f(r) dr \\approx \\frac{\\Delta r}{2} \\sum_{i=0}^{N-2} (f(r_i) + f(r_{i+1}))\n$$\n该方法易于实现，非常适用于本问题中的这类连续被积函数。复合梯形法则的误差随着点数 $N$ 的增加而减小。\n\n算法实现使用 `numpy.linspace(0, 2*h, N)` 生成包含 $N$ 个采样点 `r_vals` 的数组。然后计算相应的被积函数值 `f_vals`。`numpy.trapz(f_vals, r_vals)` 函数提供了复合梯形法则的直接、高效且数值稳定的实现，用于计算定积分的近似值。\n\n### 5. 算法综合\n\n完整的算法结构如下：\n1.  一个主函数 `solve` 遍历测试用例列表 $(d,h,N)$。\n2.  对于每个测试用例，调用一个辅助函数，例如 `calculate_integral_and_check_norm`。\n3.  这个辅助函数首先生成一个包含 $N$ 个从 $0$ 到 $2h$ 均匀分布的径向点 $r_i$ 的数组。\n4.  然后，它调用一个专用的核函数 `cubic_spline_kernel(r, h, d)`，该函数通过向量化操作计算所有点的核函数值 $W(r_i,h)$。\n5.  辅助函数接着根据维度 $d$ 选择正确的 $S_d(r_i)$，计算完整的被积函数值 $f(r_i) = W(r_i, h) S_d(r_i)$。\n6.  使用 `numpy.trapz` 计算数值积分 $I(d,h,N)$。\n7.  将绝对差 $|I(d,h,N) - 1|$ 与指定的容差 $10^{-5}$ 进行比较。\n8.  返回一个布尔结果（`True` 或 `False`）并将其追加到结果列表中。\n9.  最后，`solve` 函数将此布尔值列表格式化为所需的输出字符串 `\"[True,False,...]\"` 并打印出来。\n\n这种设计将数学原理直接转化为一个模块化且可验证的程序。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef cubic_spline_kernel(r: np.ndarray, h: float, d: int) - np.ndarray:\n    \"\"\"\n    Computes the SPH cubic spline kernel W(r, h) for a given dimension d.\n    The input r is expected to be a NumPy array.\n    \"\"\"\n    # 1. Determine the dimension-dependent normalization constant sigma_d.\n    if d == 1:\n        sigma_d = 2.0 / 3.0\n    elif d == 2:\n        sigma_d = 10.0 / (7.0 * np.pi)\n    elif d == 3:\n        sigma_d = 1.0 / np.pi\n    else:\n        # This case should not be reached with the given test suite.\n        raise ValueError(\"Dimension d must be 1, 2, or 3.\")\n\n    # 2. Calculate the normalized radius q = r/h.\n    # A small epsilon is added to h to avoid division by zero if h is ever 0.\n    q = r / (h + 1e-12)\n\n    # 3. Apply the piecewise function definition using boolean masking for vectorization.\n    # Initialize an array of zeros with the same shape as q.\n    kernel_values_unscaled = np.zeros_like(q, dtype=float)\n\n    # Condition for 0 = q  1\n    mask1 = q  1.0\n    q1 = q[mask1]\n    kernel_values_unscaled[mask1] = 1.0 - 1.5 * q1**2 + 0.75 * q1**3\n\n    # Condition for 1 = q  2\n    mask2 = (q = 1.0)  (q  2.0)\n    q2 = q[mask2]\n    kernel_values_unscaled[mask2] = 0.25 * (2.0 - q2)**3\n\n    # For q = 2, the values remain 0 as initialized.\n\n    # 4. Scale by the main normalization factor.\n    normalization_factor = sigma_d / (h**d)\n    return normalization_factor * kernel_values_unscaled\n\ndef calculate_integral_and_check_norm(d: int, h: float, N: int) - bool:\n    \"\"\"\n    Numerically integrates the kernel for a given test case and checks if it's normalized.\n    It returns True if |integral - 1| = 1e-5, and False otherwise.\n    \"\"\"\n    # Tolerance for checking the normalization.\n    tolerance = 1e-5\n\n    # 1. Set up the integration domain [0, 2h] and N sample points.\n    r_vals = np.linspace(0.0, 2.0 * h, N)\n\n    # 2. Calculate the kernel values at the sample points.\n    W_vals = cubic_spline_kernel(r_vals, h, d)\n\n    # 3. Calculate the full integrand, W(r,h) * S_d(r), where S_d is the surface measure.\n    if d == 1:\n        # S_1(r) = 2\n        integrand = 2.0 * W_vals\n    elif d == 2:\n        # S_2(r) = 2 * pi * r\n        integrand = 2.0 * np.pi * r_vals * W_vals\n    else:  # d == 3\n        # S_3(r) = 4 * pi * r^2\n        integrand = 4.0 * np.pi * r_vals**2 * W_vals\n    \n    # 4. Perform numerical integration using the composite trapezoid rule.\n    # np.trapz implements this rule efficiently.\n    integral_value = np.trapz(integrand, r_vals)\n\n    # 5. Check if the result is within the specified tolerance of 1.\n    is_normalized = abs(integral_value - 1.0) = tolerance\n    return is_normalized\n\ndef solve():\n    \"\"\"\n    Main function to run the numerical experiment for all test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (d, h, N).\n    test_cases = [\n        (1, 0.05, 100),\n        (2, 0.05, 100),\n        (3, 0.05, 100),\n        (3, 1.0, 1000),\n        (2, 0.5, 600),\n        (1, 2.0, 1200),\n    ]\n\n    results = []\n    for case in test_cases:\n        d, h, N = case\n        # For each case, calculate the integral and check the normalization condition.\n        result = calculate_integral_and_check_norm(d, h, N)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # str(True) is 'True', str(False) is 'False', matching problem requirements.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3194379"}, {"introduction": "拥有一个有效的核函数后，任何SPH模拟的第一步都是估算密度等物理场。本练习将探讨粒子排布方式——规则的晶格结构与更无序的“玻璃态”结构——如何影响SPH密度估算的精度。这个实践揭示了SPH的一个关键特性：在某些情况下，粒子的无序性反而有助于提高计算精度，这对于理解和减少SPH方法的内在误差至关重要。[@problem_id:2439536]", "problem": "本题要求您定量评估在二维空间中，粒子无序性如何影响均匀、可压缩流体的光滑粒子流体动力学（SPH）密度估计的准确性。考虑一个流体，其占据一个边长为 $L=1$、面积为 $A=L^2=1$ 的周期性单位正方形域。该流体的恒定表面密度为 $\\rho_0=1$（以无量纲单位表示）。该域内分布有 $N$ 个等质量粒子，其位置为 $\\{\\mathbf{r}_i\\}_{i=1}^N$，总质量为 $M=\\rho_0 A=1$，因此每个粒子的质量为 $m=M/N=1/N$。\n\n对于任意粒子 $i$，SPH密度估计定义为\n$$\n\\rho_i \\equiv \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right),\n$$\n其中 $\\|\\cdot\\|_\\mathrm{per}$ 表示单位环面上的最小镜像周期距离，$W(r,h)$ 是二维空间中的标准三次样条SPH核函数，其紧支集为 $2h$，光滑长度为 $h$。光滑长度必须选择为\n$$\nh = \\eta \\,\\Delta, \\quad \\text{其中} \\quad \\Delta = \\sqrt{\\frac{A}{N}} = \\frac{1}{\\sqrt{N}},\n$$\n其中 $\\eta=1.2$ 为固定常数。\n\n对于每个指定的 $N$ 值，必须考虑两种不同的粒子排列方式：\n\n- 晶格排列：在具有周期性边界的单位正方形内，粒子放置在大小为 $\\sqrt{N}\\times\\sqrt{N}$ 的正方形晶格上。\n- 类玻璃体排列：粒子放置在基数为2和3的二维Halton序列的前 $N$ 个点上，即对于 $k=1,2,\\ldots,N$，其位置为 $\\mathbf{r}_k=\\big(\\phi_2(k),\\,\\phi_3(k)\\big)$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒数函数。\n\n对于每种排列方式和每个 $N$ 值，计算以下无量纲误差度量，以比较SPH密度估计值 $\\{\\rho_i\\}$ 与精确的均匀密度 $\\rho_0$：\n- 平均绝对相对误差，\n$$\nE_1 = \\frac{1}{N}\\sum_{i=1}^N \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n- 均方根相对误差，\n$$\nE_2 = \\frac{1}{\\sqrt{N}}\\left(\\sum_{i=1}^N \\left(\\frac{\\rho_i-\\rho_0}{\\rho_0}\\right)^2\\right)^{1/2}.\n$$\n- 最大相对误差，\n$$\nE_\\infty = \\max_{1\\le i\\le N} \\frac{\\left|\\rho_i-\\rho_0\\right|}{\\rho_0}.\n$$\n\n在整个计算过程中严格使用无量纲单位，并将所有误差值表示为十进制数（而非百分比）。对于每个误差度量，将结果四舍五入到六位小数。\n\n测试套件：\n对以下有序的测试用例列表，评估三元组 $\\big[E_1,E_2,E_\\infty\\big]$，其中每个用例指定一个 $(N,\\text{arrangement})$ 对：\n- $(N=\\;100,\\;\\text{lattice})$\n- $(N=\\;100,\\;\\text{glass})$\n- $(N=\\;256,\\;\\text{lattice})$\n- $(N=\\;256,\\;\\text{glass})$\n- $(N=\\;441,\\;\\text{lattice})$\n- $(N=\\;441,\\;\\text{glass})$\n\n在核函数评估中，对所有粒子对间距采用单位正方形环面上的最小镜像周期距离。对于晶格排列中的每个 $N$，假设 $N$ 是一个完全平方数，以使晶格为 $\\sqrt{N}\\times\\sqrt{N}$。\n\n最终输出格式：\n您的程序应生成单行输出，其中包含一个以逗号分隔的列表的列表，每个内部列表按指定顺序对应一个测试用例，并按 $\\big[E_1,E_2,E_\\infty\\big]$ 的顺序列出三个四舍五入后的误差值。例如：\n\"[ [e11,e12,e13],[e21,e22,e23],... ]\"\n确保数值四舍五入到六位小数，并且除了这单行输出外没有其他文本。所有计算和输出均使用无量纲单位。", "solution": "问题陈述已经过验证，被确定为科学上合理、良定且完整。它构成了计算物理学领域中的一个标准数值实验，用以评估光滑粒子流体动力学（SPH）方法的准确性。任务是计算二维粒子分布的密度误差。将采用如下直接计算方法。\n\nSPH方法的核心思想是通过对一组离散粒子求和来表示连续场 $A(\\mathbf{r})$。对于密度场 $\\rho$，这表示为：\n$$\n\\rho(\\mathbf{r}) = \\sum_{j} m_j W\\left(\\left\\|\\mathbf{r} - \\mathbf{r}_j\\right\\|,\\, h\\right)\n$$\n其中 $m_j$ 和 $\\mathbf{r}_j$ 分别是粒子 $j$ 的质量和位置，$W$ 是一个光滑核函数，其特征宽度为 $h$（光滑长度）。问题将粒子 $i$ 在位置 $\\mathbf{r}_i$ 处的SPH密度估计指定为：\n$$\n\\rho_i = \\sum_{j=1}^N m\\, W\\!\\left(\\left\\|\\mathbf{r}_i - \\mathbf{r}_j\\right\\|_\\mathrm{per},\\, h\\right)\n$$\n该域是一个具有周期性边界条件的二维单位正方形，面积 $A=1$，总质量 $M=1$。流体具有恒定的参考表面密度 $\\rho_0=1$。因此，对于 $N$ 个粒子，每个粒子的质量为 $m = M/N = 1/N$。距离 $\\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$ 是单位环面上的最小镜像距离，对于位移矢量 $\\Delta\\mathbf{r} = (\\Delta x, \\Delta y)$，其计算公式为 $\\sqrt{(\\Delta x - \\text{round}(\\Delta x))^2 + (\\Delta y - \\text{round}(\\Delta y))^2}$。\n\n光滑长度 $h$ 与平均粒子间距 $\\Delta$ 相关。对于一个面积为 $A=1$、包含 $N$ 个粒子的二维域，平均间距为 $\\Delta = \\sqrt{A/N} = 1/\\sqrt{N}$。光滑长度设置为 $h = \\eta \\Delta$，其中常数 $\\eta = 1.2$。\n\n核函数 $W(r, h)$ 是二维标准三次样条函数，仅当 $r \\le 2h$ 时非零。其解析形式为：\n$$\nW(r,h) = \\frac{10}{7\\pi h^2} \\times \\begin{cases} 1 - \\frac{3}{2}q^2 + \\frac{3}{4}q^3,  0 \\le q \\le 1 \\\\ \\frac{1}{4}(2-q)^3,  1  q \\le 2 \\\\ 0,  q > 2 \\end{cases}\n$$\n其中 $q = r/h$ 是归一化距离。\n\n分析需要两种粒子配置：\n1.  **晶格排列**：粒子被放置在均匀的 $\\sqrt{N} \\times \\sqrt{N}$ 网格上。粒子 $(i,j)$ 的坐标取为 $(\\frac{i+0.5}{\\sqrt{N}}, \\frac{j+0.5}{\\sqrt{N}})$，其中 $i,j \\in \\{0, 1, \\dots, \\sqrt{N}-1\\}$。这确保了晶格在单位域内居中。\n2.  **类玻璃体排列**：粒子放置在基数为2和3的二维Halton序列的前 $N$ 个点上。第 $k$ 个粒子（$k=1, \\dots, N$）的位置是 $\\mathbf{r}_k = (\\phi_2(k), \\phi_3(k))$，其中 $\\phi_b(k)$ 是基数 $b$ 的根倒数函数。\n\n对于每种配置和指定的 $N$ 值，使用三种误差度量将SPH估计的密度 $\\{\\rho_i\\}_{i=1}^N$ 与精确密度 $\\rho_0=1$ 进行比较：\n-   平均绝对相对误差: $E_1 = \\frac{1}{N}\\sum_{i=1}^N |\\rho_i-1|$\n-   均方根相对误差: $E_2 = \\sqrt{\\frac{1}{N}\\sum_{i=1}^N (\\rho_i-1)^2}$\n-   最大相对误差: $E_\\infty = \\max_{1\\le i\\le N} |\\rho_i-1|$\n\n计算过程如下：\n1.  对于由 $(N, \\text{arrangement})$ 指定的每个测试用例，生成粒子位置 $\\{\\mathbf{r}_i\\}$。\n2.  计算所有 $i,j \\in \\{1, \\dots, N\\}$ 的成对周期性距离矩阵 $d_{ij} = \\|\\mathbf{r}_i - \\mathbf{r}_j\\|_\\mathrm{per}$。为提高效率，此计算被向量化。\n3.  对所有粒子对评估核函数 $W(d_{ij}, h)$，创建一个核函数值矩阵。\n4.  通过对核函数矩阵的第 $i$ 行求和，再乘以粒子质量 $m=1/N$，来计算每个粒子 $\\rho_i$ 的密度。\n5.  根据计算出的密度向量计算误差度量 $E_1, E_2, E_\\infty$。\n6.  按要求将最终误差值四舍五入到六位小数。\n\n整个过程使用 `numpy` 库在 Python 中实现，以高效处理数组操作。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the SPH density error problem.\n    \"\"\"\n    \n    # Define the problem constants and test cases.\n    RHO_0 = 1.0\n    ETA = 1.2\n    \n    test_cases = [\n        (100, 'lattice'),\n        (100, 'glass'),\n        (256, 'lattice'),\n        (256, 'glass'),\n        (441, 'lattice'),\n        (441, 'glass'),\n    ]\n\n    # --- Helper functions ---\n\n    def radical_inverse(k, base):\n        \"\"\"Computes the radical inverse of k in a given base.\"\"\"\n        inv = 0.0\n        f = 1.0 / base\n        while k  0:\n            inv += (k % base) * f\n            k //= base\n            f /= base\n        return inv\n\n    def generate_lattice(n_particles):\n        \"\"\"Generates particle positions on a regular square lattice.\"\"\"\n        n_side = int(np.sqrt(n_particles))\n        if n_side**2 != n_particles:\n            raise ValueError(\"N must be a perfect square for lattice arrangement\")\n        \n        points = np.zeros((n_particles, 2))\n        dx = 1.0 / n_side\n        \n        idx = 0\n        for i in range(n_side):\n            for j in range(n_side):\n                points[idx, 0] = (i + 0.5) * dx\n                points[idx, 1] = (j + 0.5) * dx\n                idx += 1\n        return points\n\n    def generate_glass(n_particles):\n        \"\"\"Generates particle positions from a Halton sequence.\"\"\"\n        points = np.zeros((n_particles, 2))\n        for k in range(1, n_particles + 1):\n            points[k-1, 0] = radical_inverse(k, 2)\n            points[k-1, 1] = radical_inverse(k, 3)\n        return points\n\n    def W_cubic_spline_vectorized(r, h):\n        \"\"\"Vectorized 2D cubic spline SPH kernel.\"\"\"\n        alpha_d = 10.0 / (7.0 * np.pi * h**2)\n        q = r / h\n        \n        res = np.zeros_like(q)\n        \n        # Condition: 1  q = 2\n        mask1 = (q  1.0)  (q = 2.0)\n        q1 = q[mask1]\n        res[mask1] = alpha_d * 0.25 * (2.0 - q1)**3\n        \n        # Condition: 0 = q = 1\n        mask2 = q = 1.0\n        q2 = q[mask2]\n        res[mask2] = alpha_d * (1.0 - 1.5 * q2**2 + 0.75 * q2**3)\n        \n        return res\n\n    def compute_errors(n_particles, arrangement_type):\n        \"\"\"\n        Computes the SPH density and error metrics for a given configuration.\n        \"\"\"\n        # 1. Set parameters\n        m = 1.0 / n_particles\n        delta = 1.0 / np.sqrt(n_particles)\n        h = ETA * delta\n\n        # 2. Generate particle positions\n        if arrangement_type == 'lattice':\n            positions = generate_lattice(n_particles)\n        elif arrangement_type == 'glass':\n            positions = generate_glass(n_particles)\n        else:\n            raise ValueError(f\"Unknown arrangement type: {arrangement_type}\")\n            \n        # 3. Compute pairwise periodic distances (vectorized)\n        delta_r = positions[:, np.newaxis, :] - positions[np.newaxis, :, :]\n        delta_r -= np.round(delta_r)  # Minimum image convention for unit domain\n        distances = np.linalg.norm(delta_r, axis=2)\n\n        # 4. Evaluate kernel for all pairs\n        kernel_values = W_cubic_spline_vectorized(distances, h)\n\n        # 5. Sum contributions to get densities\n        densities = m * np.sum(kernel_values, axis=1)\n\n        # 6. Compute error metrics\n        relative_errors = (densities - RHO_0) / RHO_0\n        \n        e1 = np.mean(np.abs(relative_errors))\n        e2 = np.sqrt(np.mean(relative_errors**2))\n        e_inf = np.max(np.abs(relative_errors))\n        \n        return [round(e1, 6), round(e2, 6), round(e_inf, 6)]\n\n    # --- Main execution loop ---\n    \n    all_results = []\n    for n, arr_type in test_cases:\n        errors = compute_errors(n, arr_type)\n        all_results.append(errors)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "2439536"}, {"introduction": "为了模拟流体的运动，我们需要计算作用在粒子上的力，而在SPH中，力源于压强梯度，最终通过核函数的梯度来计算。为了保证动量守恒（即牛顿第三定律的体现），核函数的梯度必须是反对称的（$\\nabla_i W_{ij} = -\\nabla_j W_{ji}$）。本练习将通过数值计算来验证这一基本性质，它是构建稳定SPH求解器的关键一步。[@problem_id:3194364]", "problem": "给定一个二维平滑粒子流体动力学（SPH）设置，其中平滑核仅依赖于粒子间的标量距离。从核是粒子间距的径向对称函数以及梯度遵循链式法则这一基本基础出发，您必须设计并实现一个数值测试，该测试针对几种不同的粒子排列，量化相对于一个粒子计算的核梯度在多大程度上是相对于另一个粒子计算的核梯度的负值。使用以下基础：欧几里得范数、梯度的链式法则和径向对称平滑核。完全在二维空间中进行操作，所有位置以米表示，平滑长度也以米表示。您的输出必须是无量纲的浮点数。\n\n在您的程序中实现以下内容：\n\n- 使用来自平滑粒子流体动力学（SPH）的标准二维三次样条核。该核被定义为分离距离 $r$ 和平滑长度 $h$ 的函数，其中 $q = r / h$。该核由下式给出\n$$\nW(r, h) = \\alpha_2 \\times\n\\begin{cases}\n1 - \\tfrac{3}{2} q^2 + \\tfrac{3}{4} q^3,  0 \\le q  1, \\\\\n\\tfrac{1}{4} (2 - q)^3,  1 \\le q  2, \\\\\n0,  q \\ge 2,\n\\end{cases}\n$$\n其中\n$$\n\\alpha_2 = \\frac{10}{7 \\pi h^2}.\n$$\n使用链式法则和径向对称性，相对于 $r$ 的梯度因子的大小由 $\\tfrac{dW}{dr}$ 决定，其中\n$$\n\\frac{dW}{dr} =\n\\alpha_2 \\times \\frac{1}{h} \\times\n\\begin{cases}\n-3 q + \\tfrac{9}{4} q^2,  0 \\le q  1, \\\\\n-\\tfrac{3}{4} (2 - q)^2,  1 \\le q  2, \\\\\n0,  q \\ge 2.\n\\end{cases}\n$$\n对于任意一对不同的粒子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$，定义矢量分离 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$、其欧几里得范数 $r_{ij} = \\lVert \\mathbf{r}_{ij} \\rVert_2$ 以及单位方向 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$（对于 $r_{ij}  0$）。相对于粒子 $\\mathbf{x}_i$ 的梯度是通过将 $\\hat{\\mathbf{r}}_{ij}$ 乘以 $\\tfrac{dW}{dr}$ 得到的，相对于粒子 $\\mathbf{x}_j$ 的梯度也以类似方式获得。在 $r_{ij} = 0$ 时，将梯度定义为零向量。\n\n- 对于下面的每个测试用例，计算所有无序粒子对的最大相对不对称性，定义为\n$$\n\\rho = \\max_{i  j} \\frac{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2}{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} \\right\\rVert_2 + \\left\\lVert \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2 + \\epsilon},\n$$\n其中 $\\epsilon = 10^{-30}$ 用于避免除以 $0$。为每个测试用例报告 $\\rho$ 作为无量纲浮点数。当梯度完全反对称时，该度量等于 $0$；如果数值计算与理论性质一致，则该度量很小（接近机器精度）。\n\n测试套件和参数：\n\n- 情况 1（理想路径）：在 $[0, 1] \\times [0, 1]$ 米上均匀采样的 $N = 20$ 个点，伪随机种子为 $123$，平滑长度 $h = 0.12$ 米。\n- 情况 2（共线对称）：沿 $x$ 轴分布的 $N = 8$ 个点，其 $x$ 坐标为 $\\{-0.5, -0.25, -0.1, -0.01, 0.01, 0.1, 0.25, 0.5\\}$ 米，$y = 0$ 米，平滑长度 $h = 0.10$ 米。\n- 情况 3（均匀网格）：在跨越 $[0, 1] \\times [0, 1]$ 米的 $5 \\times 5$ 均匀网格上的 $N = 25$ 个点，平滑长度 $h = 0.08$ 米。\n- 情况 4（近重合边缘）：通过在 $[0.4, 0.6] \\times [0.4, 0.6]$ 米上使用伪随机种子 $321$ 均匀采样 $5$ 个基点，然后将每个点复制并应用 $\\delta = 10^{-12}$ 米的 $x$ 轴偏移量，创建 $N = 10$ 个点，平滑长度 $h = 0.05$ 米。\n- 情况 5（各向异性矩形）：在 $[0, 2] \\times [0, 0.1]$ 米上使用伪随机种子 $456$ 均匀采样的 $N = 30$ 个点，平滑长度 $h = 0.20$ 米。\n\n单位和输出：\n\n- 所有位置以米为单位，平滑长度也以米为单位。\n- 报告的 $\\rho$ 值为无量纲，必须以十进制浮点数形式输出。\n- 您的程序应生成单行输出，其中包含五个案例的结果，格式为方括号内的逗号分隔列表，按案例 1 到 5 的顺序排列，例如 $[r_1, r_2, r_3, r_4, r_5]$。\n\n约束和实现细节：\n\n- 使用双精度浮点运算。\n- 当 $r_{ij} = 0$ 时，将梯度定义为零向量以避免除以 $0$，这与径向对称性一致。\n- 对所有向量范数使用欧几里得二范数。\n- 除已说明的假设外，不要做任何外部假设，并确保科学真实性。", "solution": "用户提供了一个计算科学领域的问题，具体涉及平滑粒子流体动力学（SPH）。通过对其科学和数学基础、完整性及内部一致性的严格审查，已确认该问题的有效性。此问题定义明确，提供了一项有意义的数值任务。因此，有必要提供完整的解决方案。\n\n这个问题的核心是数值上测试SPH核的一个基本属性：平滑核梯度的反对称性。这个属性是核函数作为两粒子间距离的径向对称函数的直接结果。它对于确保SPH模拟中线性动量的守恒至关重要，因为它有效地体现了粒子对相互作用的牛顿第三定律。\n\n让我们从形式化理论原理开始。平滑核 $W$ 是两个粒子位置 $\\mathbf{x}_i$ 和 $\\mathbf{x}_j$ 的函数，通过标量距离 $r_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2$ 来表达。我们将其表示为 $W_{ij} = W(r_{ij}, h)$，其中 $h$ 是平滑长度。\n\n核函数相对于粒子 $i$ 坐标的梯度 $\\nabla_{\\mathbf{x}_i} W_{ij}$ 可以使用链式法则求得：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} = \\frac{d W(r_{ij}, h)}{d r_{ij}} \\nabla_{\\mathbf{x}_i} r_{ij}\n$$\n距离 $r_{ij} = \\sqrt{(\\mathbf{x}_i - \\mathbf{x}_j) \\cdot (\\mathbf{x}_i - \\mathbf{x}_j)}$ 相对于 $\\mathbf{x}_i$ 的梯度是指向从 $\\mathbf{x}_j$ 到 $\\mathbf{x}_i$ 的单位向量：\n$$\n\\nabla_{\\mathbf{x}_i} r_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{\\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2} = \\hat{\\mathbf{r}}_{ij}\n$$\n因此，核函数相对于 $\\mathbf{x}_i$ 的梯度是：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} = \\frac{d W}{d r_{ij}} \\hat{\\mathbf{r}}_{ij}\n$$\n\n问题要求我们考虑和 $\\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji}$。项 $\\nabla_{\\mathbf{x}_j} W_{ji}$ 是对粒子对 $(j, i)$ 求值的核梯度，取关于粒子 $j$ 坐标的梯度。遵循相同的推导过程：\n$$\n\\nabla_{\\mathbf{x}_j} W_{ji} = \\frac{d W(r_{ji}, h)}{d r_{ji}} \\nabla_{\\mathbf{x}_j} r_{ji}\n$$\n其中 $r_{ji} = \\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2$，单位向量为 $\\hat{\\mathbf{r}}_{ji} = \\frac{\\mathbf{x}_j - \\mathbf{x}_i}{\\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2}$。\n\n根据欧几里得范数和向量减法的性质：\n1.  距离相等： $r_{ij} = \\lVert \\mathbf{x}_i - \\mathbf{x}_j \\rVert_2 = \\lVert -(\\mathbf{x}_j - \\mathbf{x}_i) \\rVert_2 = \\lVert \\mathbf{x}_j - \\mathbf{x}_i \\rVert_2 = r_{ji}$。\n2.  单位向量反向平行： $\\hat{\\mathbf{r}}_{ij} = \\frac{\\mathbf{x}_i - \\mathbf{x}_j}{r_{ij}} = -\\frac{\\mathbf{x}_j - \\mathbf{x}_i}{r_{ji}} = -\\hat{\\mathbf{r}}_{ji}$。\n\n由于 $r_{ij} = r_{ji}$，导数项 $\\frac{dW}{dr}$ 对于两个计算是相同的。因此，我们有：\n$$\n\\nabla_{\\mathbf{x}_j} W_{ji} = \\frac{d W}{d r_{ij}} (-\\hat{\\mathbf{r}}_{ij}) = - \\left( \\frac{d W}{d r_{ij}} \\hat{\\mathbf{r}}_{ij} \\right) = - \\nabla_{\\mathbf{x}_i} W_{ij}\n$$\n在解析上，这导出了精确的反对称性质：\n$$\n\\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} = \\mathbf{0}\n$$\n\n该数值测试的目的是验证在有限精度浮点运算下，这个解析结果的保持情况。度量 $\\rho$ 旨在测量梯度之和的相对大小，与它们各自大小之和进行比较。\n$$\n\\rho = \\max_{i  j} \\frac{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} + \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2}{\\left\\lVert \\nabla_{\\mathbf{x}_i} W_{ij} \\right\\rVert_2 + \\left\\lVert \\nabla_{\\mathbf{x}_j} W_{ji} \\right\\rVert_2 + \\epsilon}\n$$\n值为 $\\rho = 0$ 表示与理论完全数值吻合，而一个小的非零值则表示由于浮点表示和运算引起的微小偏差。小常数 $\\epsilon = 10^{-30}$ 确保了当两个梯度都为零时（例如，对于在彼此平滑半径之外的粒子）的数值稳定性。\n\n解决每个测试用例的算法如下：\n1.  根据测试用例的规范生成粒子位置 $(\\mathbf{x}_1, \\ldots, \\mathbf{x}_N)$。\n2.  初始化变量 $\\rho_{\\max} = 0$。\n3.  遍历所有唯一的无序粒子对 $(i, j)$，其中 $i  j$。\n4.  对于每对粒子，执行两次独立且完整的计算来确定梯度，从而允许任何浮点不精确性显现出来：\n    a. 计算 $\\nabla_{\\mathbf{x}_i} W_{ij}$。这包括计算 $\\mathbf{r}_{ij} = \\mathbf{x}_i - \\mathbf{x}_j$、$r_{ij} = \\lVert \\mathbf{r}_{ij} \\rVert_2$、$\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / r_{ij}$，以及使用提供的三次样条核分段公式计算导数大小 $\\frac{dW}{dr}(r_{ij}, h)$。\n    b. 类似地，通过计算 $\\mathbf{r}_{ji} = \\mathbf{x}_j - \\mathbf{x}_i$、$r_{ji} = \\lVert \\mathbf{r}_{ji} \\rVert_2$ 等来计算 $\\nabla_{\\mathbf{x}_j} W_{ji}$。\n5.  如果 $r_{ij} = 0$，则梯度被定义为零向量。\n6.  使用 $\\rho$ 的公式计算每对粒子的不对称性 $\\rho_{ij}$。\n7.  更新最大值：$\\rho_{\\max} = \\max(\\rho_{\\max}, \\rho_{ij})$。\n8.  $\\rho_{\\max}$ 的最终值是该测试用例的结果。\n\n这五个测试用例旨在在不同的粒子配置下探究此属性：一般随机分布、高度对称的共线排列、规则网格、包含近重合粒子以测试数值精度的案例，以及各向异性分布。这为SPH梯度公式的数值鲁棒性提供了一个全面的测试。实现将使用`numpy`中标准的双精度浮点运算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef dWdr_cubic_spline_2d(r, h):\n    \"\"\"\n    Computes the magnitude of the gradient factor dW/dr for the 2D cubic spline kernel.\n\n    Args:\n        r (float): The scalar separation distance between two particles.\n        h (float): The smoothing length.\n\n    Returns:\n        float: The value of dW/dr.\n    \"\"\"\n    # The problem provides the normalization constant alpha_2.\n    alpha_2 = 10.0 / (7.0 * np.pi * h**2)\n    q = r / h\n\n    # The gradient factor depends on the value of q.\n    if q = 2.0:\n        # Outside kernel support (compact support radius is 2h)\n        return 0.0\n    elif q = 1.0:\n        # For 1 = q  2\n        factor = -0.75 * (2.0 - q)**2\n    elif q = 0.0:\n        # For 0 = q  1\n        factor = -3.0 * q + (9.0 / 4.0) * q**2\n    else:\n        # This case should not be reached as r is a norm and is non-negative.\n        return 0.0\n    \n    # The full derivative is dW/dr = (1/h) * dW/dq\n    return alpha_2 * factor / h\n\ndef solve():\n    \"\"\"\n    Main function to run the five test cases and compute the maximum relative asymmetry rho.\n    \"\"\"\n    # Epsilon for numerical stability, as specified.\n    epsilon = 1e-30\n    \n    # List of parameters for each test case from the problem statement.\n    test_params = [\n        {'case': 1, 'N': 20, 'h': 0.12, 'seed': 123},\n        {'case': 2, 'N': 8, 'h': 0.10},\n        {'case': 3, 'N': 25, 'h': 0.08},\n        {'case': 4, 'N': 10, 'h': 0.05, 'seed': 321, 'delta': 1e-12},\n        {'case': 5, 'N': 30, 'h': 0.20, 'seed': 456},\n    ]\n\n    results = []\n    \n    # Process each test case.\n    for params in test_params:\n        # Step 1: Generate particle positions based on case-specific rules.\n        if params['case'] == 1:\n            rng = np.random.default_rng(params['seed'])\n            positions = rng.uniform(low=0.0, high=1.0, size=(params['N'], 2))\n        elif params['case'] == 2:\n            x_coords = np.array([-0.5, -0.25, -0.1, -0.01, 0.01, 0.1, 0.25, 0.5])\n            positions = np.zeros((params['N'], 2))\n            positions[:, 0] = x_coords\n        elif params['case'] == 3:\n            grid_points = np.linspace(0.0, 1.0, 5)\n            x, y = np.meshgrid(grid_points, grid_points)\n            positions = np.vstack([x.ravel(), y.ravel()]).T\n        elif params['case'] == 4:\n            rng = np.random.default_rng(params['seed'])\n            num_base_points = params['N'] // 2\n            base_points = rng.uniform(low=0.4, high=0.6, size=(num_base_points, 2))\n            offset_points = base_points.copy()\n            offset_points[:, 0] += params['delta']\n            positions = np.concatenate((base_points, offset_points))\n        elif params['case'] == 5:\n            rng = np.random.default_rng(params['seed'])\n            positions = rng.uniform(low=[0.0, 0.0], high=[2.0, 0.1], size=(params['N'], 2))\n\n        N = params['N']\n        h = params['h']\n        max_rho = 0.0\n\n        # Step 2: Iterate over all unique particle pairs (i, j) with i  j.\n        for i in range(N):\n            for j in range(i + 1, N):\n                # Perform two independent calculations to expose potential floating-point differences.\n                \n                # --- Gradient calculation for Nabla_i(W_ij) ---\n                vec_ij = positions[i] - positions[j]\n                norm_ij = np.linalg.norm(vec_ij)\n\n                if norm_ij == 0.0:\n                    # Gradients are zero vectors by definition for coincident particles. \n                    grad_i_Wij = np.zeros(2)\n                else:\n                    dwdr_val_ij = dWdr_cubic_spline_2d(norm_ij, h)\n                    grad_i_Wij = dwdr_val_ij * vec_ij / norm_ij\n\n                # --- Gradient calculation for Nabla_j(W_ji) ---\n                vec_ji = positions[j] - positions[i]\n                norm_ji = np.linalg.norm(vec_ji)\n                \n                if norm_ji == 0.0:\n                    grad_j_Wji = np.zeros(2)\n                else: \n                    dwdr_val_ji = dWdr_cubic_spline_2d(norm_ji, h)\n                    grad_j_Wji = dwdr_val_ji * vec_ji / norm_ji\n\n                # Step 3: Compute the asymmetry metric rho_ij for the pair.\n                numerator = np.linalg.norm(grad_i_Wij + grad_j_Wji)\n                denominator = np.linalg.norm(grad_i_Wij) + np.linalg.norm(grad_j_Wji) + epsilon\n\n                if denominator  epsilon:\n                    rho_ij = numerator / denominator\n                else: # This occurs if both gradients are zero.\n                    rho_ij = 0.0\n                \n                # Step 4: Update the maximum asymmetry found so far.\n                if rho_ij  max_rho:\n                    max_rho = rho_ij\n        \n        results.append(max_rho)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3194364"}]}