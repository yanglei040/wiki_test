{"hands_on_practices": [{"introduction": "在编写任何代码之前，通过“纸上谈兵”来掌握算法的内在机制至关重要。本练习将引导你手动完成速度Verlet算法的一个积分步长，这是一个解析练习[@problem_id:204367]。通过这种方式，你可以牢固地理解位置、速度和加速度在更新方案中是如何环环相扣的，这对于调试代码和理解数值行为至关重要。", "problem": "在 Born-Oppenheimer 近似内，分子中原子核的运动可以在一个势能面（PES）$V$ 上用经典力学来建模，该势能面是通过求解固定原子核几何构型下的不含时电子 Schrödinger 方程确定的。对于双原子分子，该势能面 $V(R)$ 仅取决于核间距 $R$。\n\n考虑一个折合质量为 $\\mu$ 的双原子分子。其振动由谐振子势 $V(R) = \\frac{k}{2}(R-R_e)^2$ 控制，其中 $k$ 是力常数，$R_e$ 是平衡键长。该分子受到一个外部的、随时间变化的电场（例如来自激光）的作用，这会引入一个额外的力 $F_{ext}(t) = F_0 \\cos(\\omega t)$。系统受到的总力是来自势的内力（恢复力）与外力之和。\n\n核间距 $R(t)$ 的经典轨迹可以使用数值积分算法进行模拟。分子动力学中最常用的算法之一是速度 Verlet 算法。对于一个一维系统，其位置为 $R(t)$，速度为 $v(t)$，加速度为 $a(t) = F(R(t), t)/\\mu$，一个时长为 $\\Delta t$ 的单次积分步骤执行如下：\n\n1.  计算新时间步的位置：\n    $$ R(t+\\Delta t) = R(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2 $$\n2.  计算新位置和新时间点的力 $F(R(t+\\Delta t), t+\\Delta t)$ 和加速度 $a(t+\\Delta t)$。\n3.  计算新时间步的速度：\n    $$ v(t+\\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t+\\Delta t)]\\Delta t $$\n\n假设该分子初始时在其平衡核间距（$R(0)=R_e$）处处于静止状态（$v(0)=0$）。\n\n使用速度 Verlet 算法，计算系统在经过一个时长为 $\\Delta t$ 的单次积分步骤后的速度 $v(\\Delta t)$。用给定的参数 $\\mu, k, R_e, F_0, \\omega$ 和 $\\Delta t$ 表示你的答案。", "solution": "1. 相关方程  \n   单步速度 Verlet 算法：  \n   $$R(t+\\Delta t)=R(t)+v(t)\\,\\Delta t+\\tfrac12a(t)\\,(\\Delta t)^2,$$  \n   $$v(t+\\Delta t)=v(t)+\\tfrac12\\bigl[a(t)+a(t+\\Delta t)\\bigr]\\,\\Delta t.$$  \n   内部恢复力：$F_{\\rm int}=-k\\,(R-R_e)$。  \n   外力：$F_{\\rm ext}(t)=F_0\\cos(\\omega t)$。  \n   总加速度：$a(t)=F(t)/\\mu$。\n\n2. $t=0$ 时的初始条件：  \n   $$R(0)=R_e,\\quad v(0)=0,\\quad F_{\\rm int}(0)=-k(R_e-R_e)=0,\\quad F_{\\rm ext}(0)=F_0.$$  \n   $$F(0)=F_0,\\quad a(0)=\\frac{F_0}{\\mu}.$$\n\n3. $t=\\Delta t$ 时的位置：  \n   $$R(\\Delta t)=R_e+0\\cdot\\Delta t+\\tfrac12\\frac{F_0}{\\mu}(\\Delta t)^2\n     =R_e+\\frac{F_0\\,(\\Delta t)^2}{2\\mu}.$$\n\n4. $t=\\Delta t$ 时的力和加速度：  \n   $$F_{\\rm int}(\\Delta t)=-k\\bigl(R(\\Delta t)-R_e\\bigr)\n     =-k\\,\\frac{F_0\\,(\\Delta t)^2}{2\\mu},$$  \n   $$F_{\\rm ext}(\\Delta t)=F_0\\cos(\\omega\\Delta t),$$  \n   $$F(\\Delta t)=-\\frac{kF_0\\,(\\Delta t)^2}{2\\mu}+F_0\\cos(\\omega\\Delta t),$$  \n   $$a(\\Delta t)=\\frac{F(\\Delta t)}{\\mu}\n     =-\\frac{kF_0\\,(\\Delta t)^2}{2\\mu^2}+\\frac{F_0}{\\mu}\\cos(\\omega\\Delta t).$$\n\n5. $t=\\Delta t$ 时的速度：  \n   $$v(\\Delta t)=0+\\tfrac12\\Bigl[a(0)+a(\\Delta t)\\Bigr]\\Delta t\n     =\\tfrac12\\Bigl[\\frac{F_0}{\\mu}\n     -\\frac{kF_0\\,(\\Delta t)^2}{2\\mu^2}+\\frac{F_0}{\\mu}\\cos(\\omega\\Delta t)\\Bigr]\\Delta t$$  \n   $$\\quad=\\frac{F_0\\Delta t}{2\\mu}\\bigl(1+\\cos(\\omega\\Delta t)\\bigr)\n     -\\frac{kF_0\\,(\\Delta t)^3}{4\\mu^2}.$$", "answer": "$$\\boxed{\\frac{F_0\\Delta t}{2\\mu}\\bigl(1+\\cos(\\omega\\Delta t)\\bigr)-\\frac{kF_0\\,(\\Delta t)^3}{4\\mu^2}}$$", "id": "204367"}, {"introduction": "理解了单个积分步长的计算方法后，下一个关键问题是：时间步长 $\\Delta t$ 在模拟“爆炸”前可以设多大？这个实践从简谐振子模型转向更真实（也更“刚性”）的莫尔斯势，旨在探索数值稳定性的概念[@problem_id:3144487]。你将研究时间步长的选择、甚至原子质量的调整如何决定模拟的成败，这是分子动力学实践中的一个核心挑战。", "problem": "考虑一个通过摩尔斯势（Morse potential）相互作用的一维双原子二聚体，使用简化的无量纲单位。摩尔斯势由以下函数定义：$$U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2,$$ 其中 $r$ 是两个原子间的标量距离，$D_e$ 是势阱深度，$a$ 控制最小值附近的刚度（曲率），$r_e$ 是平衡键长。两个原子的质量分别为 $m_1$ 和 $m_2$，它们沿直线的位置是 $x_1$ 和 $x_2$。力为 $-\\nabla U$，每个原子的运动方程遵循牛顿第二定律（Newton's second law）：$$m_i \\frac{d^2 x_i}{dt^2} = F_i,\\quad i \\in \\{1,2\\}.$$ 分子动力学（Molecular Dynamics, MD）指的是对这些运动方程进行时间积分。全程使用简化单位，不附加任何物理单位；所有量均为无量纲。\n\n从基本定律和定义（牛顿第二定律、速度定义 $v = dx/dt$ 和加速度定义 $a = dv/dt$）出发，推导一个与这些定律一致的二阶、时间可逆、辛积分方案，并实现该方案来推进原子的位置和速度。将二聚体初始化于位置 $x_1(0) = -r_0/2$ 和 $x_2(0) = r_0/2$，初始速度为零 $v_1(0) = 0$ 和 $v_2(0) = 0$，其中 $r_0 = r_e + \\delta r$，$\\delta r$ 是一个偏离平衡位置的微小正位移。在每个时间步，计算总能量：$$E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right).$$\n\n如果一个模拟在整个轨迹上满足以下所有标准，则定义其为数值稳定的：\n- 距离大小保持在 $$0.2\\, r_e \\le |x_2(t) - x_1(t)| \\le 2.0\\, r_e$$ 范围内。\n- 不发生数值溢出或未定义值（无 $\\mathrm{NaN}$ 或 $\\infty$）。\n- 分数能量漂移，定义为 $$\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}},$$ 满足 $$\\Delta_E \\le 0.2$$，其中 $\\overline{E}$ 是 $E(t)$ 在轨迹上的时间平均值。\n\n您的程序必须实现上述内容，并对下面的每个测试用例评估其稳定性。为了探究积分器在大时间步长 $dt$ 下的失效模式，以及质量缩放或更小的 $dt$ 如何缓解不稳定性，请对摩尔斯势和初始位移使用以下固定参数：\n- $D_e = 10$\n- $a = 8$\n- $r_e = 1$\n- $\\delta r = 0.05$\n设基础质量为 $m = 1$，并通过质量缩放因子 $s$ 定义实际原子质量为 $m_1 = s \\cdot m$ 和 $m_2 = s \\cdot m$。\n\n测试套件（每个测试用例是一个元组 $(dt, s, N)$，其中 $dt$ 是时间步长，$s$ 是质量缩放因子，$N$ 是积分步数）：\n1. $(0.01, 1, 2000)$: 小时间步长，基础质量。\n2. $(0.15, 1, 1000)$: 大时间步长，基础质量。\n3. $(0.15, 100, 1000)$: 大时间步长，大质量缩放。\n4. $(0.04, 1, 2000)$: 接近稳定性边界，基础质量。\n5. $(0.50, 100, 500)$: 极大时间步长，大质量缩放。\n\n对每个测试用例，运行模拟 $N$ 步，并根据上述标准返回一个指示稳定性的布尔值。\n\n最终输出格式：您的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表（例如，`[result1,result2,result3,result4,result5]`），其中每个结果是与给定顺序的测试用例相对应的布尔值。", "solution": "该问题要求推导并实现一个数值积分方案，以模拟通过摩尔斯势（Morse potential）相互作用的一维双原子系统的动力学。这是计算科学中的一个经典问题，特别是在分子动力学（MD）领域。目标是实现一个稳定且准确的积分器，对一组给定参数运行模拟，并根据规定的标准评估每个模拟的数值稳定性。\n\n首先，我们验证问题陈述。\n\n### 步骤1：提取给定条件\n-   **势能函数：** $U(r) = D_e \\left(1 - e^{-a(r - r_e)}\\right)^2$，其中 $r = |x_2 - x_1|$。\n-   **运动方程：** $m_i \\frac{d^2 x_i}{dt^2} = F_i$，对于原子 $i \\in \\{1,2\\}$。\n-   **力的定义：** 力是势的负梯度，$F = -\\nabla U$。\n-   **初始条件：** $x_1(0) = -r_0/2$，$x_2(0) = r_0/2$，其中 $r_0 = r_e + \\delta r$。初始速度为 $v_1(0) = 0$ 和 $v_2(0) = 0$。\n-   **总能量：** $E(t) = \\frac{1}{2} m_1 v_1(t)^2 + \\frac{1}{2} m_2 v_2(t)^2 + U\\left(|x_2(t) - x_1(t)|\\right)$。\n-   **固定参数：** $D_e = 10$，$a = 8$，$r_e = 1$，$\\delta r = 0.05$。\n-   **质量缩放：** $m_1 = m_2 = s$，其中 $s$ 是给定的质量缩放因子。\n-   **稳定性标准：**\n    1.  有界距离：$0.2 \\cdot r_e \\le |x_2(t) - x_1(t)| \\le 2.0 \\cdot r_e$。\n    2.  无数值溢出（例如 $\\mathrm{NaN}$ 或 $\\infty$）。\n    3.  分数能量漂移 $\\Delta_E = \\frac{\\max_t E(t) - \\min_t E(t)}{\\overline{E}} \\le 0.2$。\n-   **测试套件：** 5个元组 $(dt, s, N)$ 的列表，其中 $dt$ 是时间步长，$s$ 是质量缩放因子，$N$ 是步数。\n    1.  $(0.01, 1, 2000)$\n    2.  $(0.15, 1, 1000)$\n    3.  $(0.15, 100, 1000)$\n    4.  $(0.04, 1, 2000)$\n    5.  $(0.50, 100, 500)$\n\n### 步骤2：使用提取的给定条件进行验证\n该问题具有科学依据，使用了广为接受的摩尔斯势和牛顿运动定律。这是分子动力学模拟中的一个标准练习。问题是适定的，为每个测试用例提供了所有必需的物理参数、初始条件和数值参数。稳定性标准由客观、量化的指标定义。没有矛盾、歧义或不符合科学原理的前提。这是一个需要理论推导和计算实现的实质性任务。\n\n### 步骤3：结论和行动\n问题有效。我们开始求解。\n\n### 积分算法的推导与实现\n\n问题要求一个二阶、时间可逆、辛的积分方案。速度 Verlet（Velocity Verlet）算法满足这些性质，是 MD 模拟的标准选择。我们从位置 $x(t)$ 的泰勒级数展开式推导它。\n\n对于一个质量为 $m$ 的粒子，其位置 $x(t)$ 根据牛顿第二定律 $\\ddot{x}(t) = a(t) = F(x(t))/m$ 演化。在时间 $t+dt$ 的位置的泰勒级数展开式为：\n$$x(t+dt) = x(t) + \\dot{x}(t)dt + \\frac{1}{2}\\ddot{x}(t)dt^2 + O(dt^3)$$\n认识到 $\\dot{x}(t) = v(t)$ 和 $\\ddot{x}(t) = a(t)$，我们可以写出位置更新规则：\n$$x(t+dt) = x(t) + v(t)dt + \\frac{1}{2}a(t)dt^2$$\n这个更新对于 $dt$ 是二阶准确的。为使整个算法保持此精度，速度更新也必须是二阶的。一个简单的速度前向欧拉更新（forward Euler update）$v(t+dt) = v(t) + a(t)dt$ 仅为一阶，会降低整体精度。我们可以改用时间步开始和结束时加速度的平均值：\n$$v(t+dt) = v(t) + \\frac{a(t) + a(t+dt)}{2}dt$$\n这组方程定义了速度 Verlet 算法。然而，它的直接实现是隐式的，因为 $a(t+dt)$ 依赖于尚未完全确定的 $x(t+dt)$。速度 Verlet 的“蛙跳”（leapfrog）变体将计算重新排列成一个显式的、计算效率高的序列：\n\n1.  计算半个时间步 $t+dt/2$ 时的速度：\n    $$v(t + dt/2) = v(t) + \\frac{1}{2}a(t)dt$$\n2.  使用此半步速度更新整个时间步 $dt$ 的位置：\n    $$x(t+dt) = x(t) + v(t+dt/2)dt$$\n3.  在新位置计算新的力 $F(x(t+dt))$ 和加速度 $a(t+dt)$。\n4.  完成后半个时间步的速度更新：\n    $$v(t+dt) = v(t+dt/2) + \\frac{1}{2}a(t+dt)dt$$\n\n该方案与原始公式在代数上等价，是显式的，并且对 MD 具有优异的性质：它是二阶准确、时间可逆且辛的，这使得它具有良好的长期能量守恒性。\n\n### 在双原子系统上的应用\n\n我们将此算法应用于由 $i \\in \\{1,2\\}$ 索引的两个原子中的每一个。每个原子上的力来自摩尔斯势，它取决于原子间距 $r = |x_2 - x_1|$。原子 $i$ 上的力是 $F_i = -\\frac{\\partial U}{\\partial x_i}$。使用链式法则，其中 $r = |x_2 - x_1|$：\n$$F_1 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_1} = -\\frac{dU}{dr}(-\\text{sgn}(x_2 - x_1)) = \\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\n$$F_2 = -\\frac{dU}{dr}\\frac{\\partial r}{\\partial x_2} = -\\frac{dU}{dr}(\\text{sgn}(x_2 - x_1)) = -\\text{sgn}(x_2 - x_1)\\frac{dU}{dr}$$\n注意，牛顿第三定律 $F_1 = -F_2$ 得到满足。摩尔斯势的导数是：\n$$\\frac{dU}{dr} = 2aD_e \\left(1 - e^{-a(r - r_e)}\\right) e^{-a(r - r_e)}$$\n加速度则为 $a_1 = F_1/m_1$ 和 $a_2 = F_2/m_2$。在本问题中，$m_1 = m_2 = s$。\n\n模拟过程如下：\n1.  初始化位置 $x_1 = -r_0/2$，$x_2 = r_0/2$ 和速度 $v_1 = 0$，$v_2 = 0$。\n2.  计算初始力 $F_1, F_2$ 和加速度 $a_1, a_2$。\n3.  存储初始原子间距 $r(0) = |x_2 - x_1|$ 和总能量 $E(0)$。\n4.  循环 $N$ 个时间步：\n    a. 对每个原子 $i$，将速度更新至半步：$v_i(t+dt/2) = v_i(t) + \\frac{1}{2}a_i(t)dt$。\n    b. 对每个原子 $i$，将位置更新至全步：$x_i(t+dt) = x_i(t) + v_i(t+dt/2)dt$。\n    c. 计算新的间距 $r(t+dt)$ 和新的力 $F_i(t+dt)$ 与加速度 $a_i(t+dt)$。在此步骤中，检查数值溢出，若发生溢出则模拟立即失效。\n    d. 对每个原子 $i$，完成速度更新：$v_i(t+dt) = v_i(t+dt/2) + \\frac{1}{2}a_i(t+dt)dt$。\n    e. 存储新的间距 $r(t+dt)$ 和总能量 $E(t+dt)$。\n5. 在 $N$ 步之后，根据三个稳定性标准分析存储的轨迹数据（$r(t)$ 和 $E(t)$），以确定最终的布尔结果。\n\n此过程针对问题陈述中提供的每个测试用例进行实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(dt, s, N):\n    \"\"\"\n    Runs a molecular dynamics simulation for a two-atom dimer.\n\n    Args:\n        dt (float): The time step for integration.\n        s (float): The mass scale factor for the atoms.\n        N (int): The number of integration steps.\n\n    Returns:\n        bool: True if the simulation is stable, False otherwise.\n    \"\"\"\n    # Fixed parameters for the Morse potential and initial displacement\n    De = 10.0\n    a = 8.0\n    re = 1.0\n    delta_r = 0.05\n    \n    # Initial conditions\n    r0 = re + delta_r\n    x1, x2 = -r0 / 2.0, r0 / 2.0\n    v1, v2 = 0.0, 0.0\n    m1, m2 = float(s), float(s)\n\n    # History storage\n    r_hist = np.zeros(N + 1)\n    E_hist = np.zeros(N + 1)\n\n    # --- Utility functions ---\n    def calculate_forces_and_separation(x1_pos, x2_pos):\n        r_vec = x2_pos - x1_pos\n        r_mag = np.abs(r_vec)\n        \n        if r_mag == 0:\n            return np.inf, -np.inf, r_mag\n        \n        # This term can overflow if r_mag gets too small.\n        # -a * (r_mag - re) becomes large and positive.\n        exp_arg = -a * (r_mag - re)\n        if exp_arg > np.log(np.finfo(float).max): # Avoid overflow in exp\n             return np.inf, -np.inf, r_mag\n\n        exp_term = np.exp(exp_arg)\n        \n        # dU/dr\n        F_grad = 2 * a * De * (1 - exp_term) * exp_term\n\n        # Forces on atoms 1 and 2\n        F1 = np.sign(r_vec) * F_grad\n        F2 = -F1\n        \n        return F1, F2, r_mag\n\n    def potential_energy(r_mag):\n        return De * (1 - np.exp(-a * (r_mag - re)))**2\n\n    def kinetic_energy(vel1, vel2, mass1, mass2):\n        return 0.5 * mass1 * vel1**2 + 0.5 * mass2 * vel2**2\n\n    # --- Simulation setup (t=0) ---\n    F1_curr, F2_curr, r_mag_curr = calculate_forces_and_separation(x1, x2)\n    acc1_curr, acc2_curr = F1_curr / m1, F2_curr / m2\n\n    r_hist[0] = r_mag_curr\n    E_hist[0] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_curr)\n\n    # --- Main integration loop ---\n    for i in range(N):\n        # Velocity Verlet: half-step velocity update\n        v1_half = v1 + 0.5 * acc1_curr * dt\n        v2_half = v2 + 0.5 * acc2_curr * dt\n\n        # Velocity Verlet: full-step position update\n        x1 = x1 + v1_half * dt\n        x2 = x2 + v2_half * dt\n\n        # Calculate new forces and accelerations\n        F1_new, F2_new, r_mag_new = calculate_forces_and_separation(x1, x2)\n        \n        # Stability Check 2: Numerical overflow\n        if np.isinf(F1_new) or np.isnan(F1_new):\n            return False\n            \n        acc1_new = F1_new / m1\n        acc2_new = F2_new / m2\n\n        # Velocity Verlet: second half-step velocity update\n        v1 = v1_half + 0.5 * acc1_new * dt\n        v2 = v2_half + 0.5 * acc2_new * dt\n        \n        # Update accelerations for the next iteration\n        acc1_curr, acc2_curr = acc1_new, acc2_new\n\n        # Store diagnostics for analysis\n        r_hist[i+1] = r_mag_new\n        E_hist[i+1] = kinetic_energy(v1, v2, m1, m2) + potential_energy(r_mag_new)\n        \n        if np.isinf(E_hist[i+1]) or np.isnan(E_hist[i+1]):\n            return False\n\n    # --- Post-simulation stability analysis ---\n\n    # Stability Check 1: Separation magnitude bounds\n    min_r = np.min(r_hist)\n    max_r = np.max(r_hist)\n    if not (0.2 * re = min_r and max_r = 2.0 * re):\n        return False\n        \n    # Stability Check 3: Fractional energy drift\n    avg_E = np.mean(E_hist)\n    if avg_E == 0: # Should not occur in this problem\n        if np.max(E_hist) - np.min(E_hist) > 1e-9: # Tolerate zero drift if energy is always zero\n            return False\n    else:\n        delta_E = (np.max(E_hist) - np.min(E_hist)) / avg_E\n        if delta_E > 0.2:\n            return False\n            \n    # If all checks pass, the simulation is stable\n    return True\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.01, 1, 2000),      # small time step, base mass.\n        (0.15, 1, 1000),      # large time step, base mass.\n        (0.15, 100, 1000),    # large time step, heavy mass scaling.\n        (0.04, 1, 2000),      # near the stability boundary, base mass.\n        (0.50, 100, 500),     # extremely large time step, heavy mass scaling.\n    ]\n\n    results = []\n    for case in test_cases:\n        dt, s, N = case\n        is_stable = run_simulation(dt, s, N)\n        results.append(is_stable)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3144487"}, {"introduction": "一个稳定的模拟是得出正确科学结论的必要条件，但还不够。我们如何观察或采样系统轨迹也同样重要。本练习揭示了“混叠”这一隐藏的陷阱，即对高频运动的采样过慢，会产生一种截然不同的低频动态的假象[@problem_id:3144553]。通过模拟一个快速振荡器并对其输出进行降采样，你将亲眼见证奈奎斯特-香农采样定理的作用，并理解为何积分步长和数据输出频率是两个独立且都至关重要的考虑因素。", "problem": "考虑一个受线性恢复力作用的一维点质量，其运动由牛顿第二定律 $m \\, d^2 x/dt^2 = -k \\, x$ 描述，其中 $m$ 是质量，$k$ 是弹簧常数。其连续时间动力学是角频率为 $\\omega = \\sqrt{k/m}$（单位为 $\\mathrm{rad/s}$）、物理频率为 $f_{\\text{true}} = \\omega/(2\\pi)$（单位为 $\\mathrm{Hz}$）的简谐振子。您将实现速度Verlet算法，使用一个稳定的时间步长对该运动进行数值积分，然后探究降采样如何在采样轨迹中引起混叠现象。您的程序必须以 $\\mathrm{Hz}$ 为单位计算频率，角度始终以弧度为单位。\n\n仅从牛顿定律（$F = m a$）和运动学定义（$v = dx/dt$ 和 $a = dv/dt$）出发，实现速度Verlet算法，利用由力 $F = -k x$ 计算出的加速度，来推进谐振子的位置和速度随时间演化。在使用安全的步长时间 $\\Delta t$、在有限时长 $T$ 内计算出高分辨率轨迹后，通过保留每第 $s$ 个采样点来生成一个降采样序列。对于高分辨率序列和降采样序列，都通过检测 $x(t)$ 的过零点并对半周期区间进行平均来估计频率。评估采样频率 $f_s = 1/(\\Delta t \\, s)$ 是否满足针对数值实现的振荡频率的奈奎斯特准则，并演示混叠导致动力学误判的案例。\n\n您必须设计程序以处理以下参数值的测试套件。对于所有测试，使用质量 $m = 1$（单位 $\\mathrm{kg}$）、初始位置 $x_0 = 1$（单位 $\\mathrm{m}$）、初始速度 $v_0 = 0$（单位 $\\mathrm{m/s}$）、时间步长 $\\Delta t = 10^{-4}$（单位 $\\mathrm{s}$）以及总模拟时间 $T = 0.5$（单位 $\\mathrm{s}$）。弹簧常数 $k$ 的选择使得物理频率为 $f_{\\text{true}} = 50$（单位 $\\mathrm{Hz}$），即 $k = m \\, (2\\pi f_{\\text{true}})^2$。测试套件仅改变降采样因子 $s$：\n\n- 测试 $1$ （正常情况）：$s = 50$，因此 $f_s = 1/(\\Delta t \\, s) = 200$（单位 $\\mathrm{Hz}$），这应满足振子动力学的奈奎斯特准则。\n- 测试 $2$ （混叠）：$s = 167$，因此 $f_s \\approx 59.880239$（单位 $\\mathrm{Hz}$），这应违反奈奎斯特准则并表现出混叠。\n- 测试 $3$ （接近奈奎斯特边界）：$s = 100$，因此 $f_s = 100$（单位 $\\mathrm{Hz}$），这恰好是物理频率的两倍，位于奈奎斯特准则的边界上。\n- 测试 $4$ （相称采样导致极端混叠）：$s = 200$，因此 $f_s = 50$（单位 $\\mathrm{Hz}$），与物理频率相等，导致采样序列重复相同的相位而看似恒定。\n\n对于每个测试用例，计算并返回以下量值：\n- $f_{\\text{true}}$（单位 $\\mathrm{Hz}$），由 $\\omega = \\sqrt{k/m}$ 得出的物理振子频率。\n- $f_{\\text{Verlet}}$（单位 $\\mathrm{Hz}$），速度Verlet积分器数值实现的振荡频率，通过高分辨率轨迹的过零点估计。\n- $f_s$（单位 $\\mathrm{Hz}$），降采样后的采样频率。\n- $f_{\\text{down}}$（单位 $\\mathrm{Hz}$），通过降采样序列的过零点估计出的频率。\n- $\\text{nyquist\\_ok}$，一个布尔指示符，如果 $f_s \\ge 2 f_{\\text{Verlet}}$ 则编码为 $1$，否则为 $0$。\n\n所有频率输出必须以 $\\mathrm{Hz}$ 为单位表示，并打印到小数点后 $6$ 位。最终输出必须是单行，包含测试套件的结果，形式为逗号分隔的子列表列表，每个子列表的格式必须为 $[f_{\\text{true}}, f_{\\text{Verlet}}, f_s, f_{\\text{down}}, \\text{nyquist\\_ok}]$。例如，形式为 $[[\\dots],[\\dots],[\\dots],[\\dots]]$ 的一行。\n\n您的程序必须精确地产生这一行输出，不得包含任何额外文本。", "solution": "## 问题验证\n\n### 步骤1：提取已知条件\n- **物理系统**：一维点质量，受线性恢复力作用。\n- **运动方程**：$m \\, d^2 x/dt^2 = -k \\, x$。\n- **定义**：\n    - 质量：$m$\n    - 弹簧常数：$k$\n    - 位置：$x(t)$\n    - 速度：$v(t) = dx/dt$\n    - 加速度：$a(t) = dv/dt$\n    - 角频率：$\\omega = \\sqrt{k/m}$\n    - 物理频率：$f_{\\text{true}} = \\omega/(2\\pi)$\n- **数值方法**：速度Verlet算法。\n- **分析方法**：通过过零点检测估计频率。\n- **模拟参数（所有测试通用）**：\n    - 质量，$m = 1$ kg\n    - 初始位置，$x_0 = 1$ m\n    - 初始速度，$v_0 = 0$ m/s\n    - 高分辨率时间步长，$\\Delta t = 10^{-4}$ s\n    - 总模拟时间，$T = 0.5$ s\n    - 待模拟的物理频率，$f_{\\text{true}} = 50$ Hz\n- **派生常数**：$k = m \\, (2\\pi f_{\\text{true}})^2$。\n- **测试套件（改变降采样因子 $s$）**：\n    - 测试 1：$s = 50$\n    - 测试 2：$s = 167$\n    - 测试 3：$s = 100$\n    - 测试 4：$s = 200$\n- **每个测试用例的必需输出**：\n    1. $f_{\\text{true}}$ (Hz)：物理振子频率。\n    2. $f_{\\text{Verlet}}$ (Hz)：高分辨率模拟中数值实现的频率。\n    3. $f_s$ (Hz)：降采样后的采样频率，$f_s = 1/(\\Delta t \\cdot s)$。\n    4. $f_{\\text{down}}$ (Hz)：从降采样序列估计的频率。\n    5. $\\text{nyquist\\_ok}$：布尔值，编码为 $1$ (如果 $f_s \\ge 2 f_{\\text{Verlet}}$) 或 $0$ (否则)。\n- **输出格式**：单行，逗号分隔的子列表列表，例如 $[[\\dots],[\\dots],[\\dots],[\\dots]]$，频率格式化为6位小数。\n\n### 步骤2：使用提取的已知条件进行验证\n根据验证标准评估问题：\n- **科学依据**：问题基于经典力学的基础原理（简谐振子的牛顿第二定律）、标准数值方法（速度Verlet算法）和信号处理概念（奈奎斯特-香农采样定理，混叠）。所有概念在计算科学中均已成熟。\n- **适定性**：问题被完全指定。所有必要的参数（$m, x_0, v_0, \\Delta t, T, f_{\\text{true}}$）、积分方案和分析方法都已明确定义。任务清晰，可以得出一组唯一且可计算的结果。\n- **客观性**：问题以精确、技术性的语言陈述，没有任何主观或模糊的术语。\n- **缺陷清单**：问题未违反任何列出的无效性标准。它在科学上是合理的、可形式化的、完整的、可行的和结构良好的。对于一个$50\\,\\mathrm{Hz}$的振子（周期$T_{\\text{osc}} = 0.02\\,\\mathrm{s}$），所选时间步长$\\Delta t = 10^{-4}\\,\\mathrm{s}$ 提供了 $\\Delta t / T_{\\text{osc}} = 1/200$ 的比率，确保了Verlet积分器的数值稳定性。\n\n### 步骤3：结论与行动\n该问题是**有效的**。将提供完整解决方案。\n\n## 解决方案\n\n该问题要求我们使用速度Verlet算法模拟一个简谐振子，然后分析降采样对感知到的振荡频率的影响，从而演示混叠的概念。\n\n### 理论框架\n\n**1. 简谐振子（SHO）的动力学**\n该系统由牛顿第二定律描述，适用于线性恢复力（胡克定律）：\n$$ F = ma = -kx $$\n因此，加速度 $a$ 是位置 $x$ 的函数：\n$$ a(x) = -\\frac{k}{m}x $$\n这是简谐运动的方程。其解的形式为 $x(t) = A \\cos(\\omega t + \\phi)$，其中角频率 $\\omega$ 由下式给出：\n$$ \\omega = \\sqrt{\\frac{k}{m}} $$\n物理频率 $f_{\\text{true}}$ 与 $\\omega$ 的关系为 $f_{\\text{true}} = \\omega / (2\\pi)$。对于给定的参数 $m=1\\,\\mathrm{kg}$ 和 $f_{\\text{true}}=50\\,\\mathrm{Hz}$，弹簧常数 $k$ 计算如下：\n$$ k = m \\omega^2 = m (2\\pi f_{\\text{true}})^2 = 1 \\cdot (2\\pi \\cdot 50)^2 = (100\\pi)^2 \\approx 98696.044\\,\\mathrm{N/m} $$\n\n**2. 速度Verlet算法**\n速度Verlet算法是一种用于对牛顿运动方程进行积分的数值方法。它以一种时间可逆且具有良好长期能量守恒性的方式，将位置 $x$ 和速度 $v$ 从时间 $t$ 更新到 $t+\\Delta t$。更新规则如下：\n1. 将位置更新到完整时间步长：\n$$ x(t + \\Delta t) = x(t) + v(t)\\Delta t + \\frac{1}{2}a(t)(\\Delta t)^2 $$\n2. 计算新位置处的加速度：\n$$ a(t + \\Delta t) = -\\frac{k}{m}x(t + \\Delta t) $$\n3. 使用旧加速度和新加速度的平均值来更新速度：\n$$ v(t + \\Delta t) = v(t) + \\frac{1}{2}[a(t) + a(t + \\Delta t)]\\Delta t $$\n该算法的速度局部误差为 $O(\\Delta t^3)$ 阶，位置局部误差为 $O(\\Delta t^4)$ 阶，全局误差为 $O(\\Delta t^2)$ 阶。关键的是，它会引入一个小的相位误差，导致数值实现的频率 $f_{\\text{Verlet}}$ 与真实的解析频率 $f_{\\text{true}}$ 略有不同。对于简谐振子，数值频率略高于真实频率：$f_{\\text{Verlet}} > f_{\\text{true}}$。\n\n**3. 通过过零点估计频率**\n要估计振荡信号 $x(t)$ 的频率，我们可以识别出信号穿过零点的时间点。如果在时间步 $t_i$ 和 $t_{i+1}$ 之间，$x(t_i) \\cdot x(t_{i+1})  0$，则检测到一个过零点。可以使用线性插值法找到更精确的过零时间 $t_{\\text{cross}}$：\n$$ t_{\\text{cross}} = t_i - x(t_i) \\frac{t_{i+1} - t_i}{x(t_{i+1}) - x(t_i)} $$\n两个连续过零点之间的时间间隔对应于半个振荡周期 $T_{\\text{osc}}/2$。通过对整个轨迹上的这些半周期区间进行平均，我们可以得到平均半周期的稳健估计值 $\\langle T_{\\text{osc}}/2 \\rangle$。然后，估计频率为：\n$$ f_{\\text{est}} = \\frac{1}{2 \\langle T_{\\text{osc}}/2 \\rangle} $$\n\n**4. 采样、奈奎斯特准则和混叠**\n当一个连续信号以离散时间间隔进行采样时，采样频率 $f_s$ 必须足够高，才能捕捉信号的频率内容。奈奎斯特-香农采样定理指出，为避免信息丢失，采样频率 $f_s$ 必须严格大于信号中最高频率分量 $f_{\\text{max}}$ 的两倍。该条件是：\n$$ f_s > 2 f_{\\text{max}} $$\n在我们的案例中，信号的频率是数值实现的频率 $f_{\\text{Verlet}}$。问题将奈奎斯特准则定义为 $f_s \\ge 2 f_{\\text{Verlet}}$。如果不满足此准则，就会出现一种称为混叠的现象。原始信号中的高频 $f_{\\text{Verlet}}$ 在采样数据中会表现为一个较低的“混叠”频率 $f_{\\text{alias}}$，其计算公式为：\n$$ f_{\\text{alias}} = |f_{\\text{Verlet}} - n \\cdot f_s| $$\n其中 $n$ 是一个整数，其选择使得 $0 \\le f_{\\text{alias}} \\le f_s/2$。这种频率的错误表示正是我们将在某些测试用例中观察到的现象。\n\n### 算法实现计划\n\n对于由降采样因子 $s$ 定义的每个测试用例：\n1.  **高分辨率模拟**：使用小时间步长 $\\Delta t = 10^{-4}\\,\\mathrm{s}$ 运行速度Verlet算法一次，总时长为 $T = 0.5\\,\\mathrm{s}$，生成高分辨率的时间和位置数组 `t_high` 和 `x_high`。\n2.  **计算 $f_{\\text{true}}$**：这是一个给定的常数值 $50\\,\\mathrm{Hz}$。\n3.  **计算 $f_{\\text{Verlet}}$**：将过零点频率估计方法应用于 `t_high` 和 `x_high` 数组。这给出了我们模拟的基准数值频率。\n4.  **降采样轨迹**：通过从高分辨率数组中选择每 $s$ 个点来创建降采样轨迹（`t_down`, `x_down`）。\n5.  **计算 $f_s$**：降采样数据的采样频率计算为 $f_s = 1 / (\\Delta t \\cdot s)$。\n6.  **计算 $f_{\\text{down}}$**：将过零点频率估计方法应用于降采样轨迹（`t_down`, `x_down`）。如果检测到的过零点少于两个（如测试4中预期的），则频率报告为 $0.0\\,\\mathrm{Hz}$。\n7.  **检查奈奎斯特准则**：如果 $f_s \\ge 2 f_{\\text{Verlet}}$，则布尔值 `nyquist_ok` 设置为 $1$，否则为 $0$。\n8.  **存储和格式化**：收集五个计算量（$f_{\\text{true}}, f_{\\text{Verlet}}, f_s, f_{\\text{down}}, \\text{nyquist\\_ok}$）并为最终输出进行格式化。\n\n此过程将对测试套件中每个 $s$ 值重复进行，以演示不同的采样机制。\n- **测试 1 ($s=50$)：** $f_s = 200\\,\\mathrm{Hz}$。由于 $200 > 2 \\cdot f_{\\text{Verlet}} \\approx 100\\,\\mathrm{Hz}$，奈奎斯特准则得到满足。我们预期 $f_{\\text{down}} \\approx f_{\\text{Verlet}}$。\n- **测试 2 ($s=167$)：** $f_s \\approx 59.88\\,\\mathrm{Hz}$。这违反了准则。我们预期会发生混叠，其中 $f_{\\text{down}} \\approx |f_{\\text{Verlet}} - f_s| \\approx |50 - 59.88| = 9.88\\,\\mathrm{Hz}$。\n- **测试 3 ($s=100$)：** $f_s = 100\\,\\mathrm{Hz}$。这位于奈奎斯特边界上（$f_s = 2 f_{\\text{Verlet}}$）。频率仍应能被正确识别，因此 $f_{\\text{down}} \\approx f_{\\text{Verlet}}$。\n- **测试 4 ($s=200$)：** $f_s = 50\\,\\mathrm{Hz}$。这也违反了准则，并且关键的是，$f_s \\approx f_{\\text{Verlet}}$。每个周期采样一次，相位几乎相同。由于模拟从峰值开始（$x_0=1, v_0=0$），所有采样点都将接近峰值。将不会观察到过零点，$f_{\\text{down}}$ 将为 $0.0\\,\\mathrm{Hz}$。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of simulating a harmonic oscillator with the velocity Verlet \n    algorithm and analyzing aliasing effects from downsampling.\n    \"\"\"\n\n    def _run_verlet(k, m, x0, v0, dt, num_steps):\n        \"\"\"\n        Performs a velocity Verlet integration for a simple harmonic oscillator.\n        \"\"\"\n        t = np.zeros(num_steps + 1)\n        x = np.zeros(num_steps + 1)\n        v = np.zeros(num_steps + 1)\n\n        x[0] = x0\n        v[0] = v0\n        t[0] = 0.0\n\n        for i in range(num_steps):\n            a_current = -k / m * x[i]\n            \n            # Update position\n            x[i+1] = x[i] + v[i] * dt + 0.5 * a_current * dt**2\n            \n            # Calculate next acceleration\n            a_next = -k / m * x[i+1]\n            \n            # Update velocity\n            v[i+1] = v[i] + 0.5 * (a_current + a_next) * dt\n            \n            # Update time\n            t[i+1] = t[i] + dt\n            \n        return t, x\n\n    def _estimate_frequency(times, positions):\n        \"\"\"\n        Estimates frequency by finding zero-crossings with linear interpolation.\n        \"\"\"\n        crossings = []\n        for i in range(len(positions) - 1):\n            if positions[i] * positions[i+1]  0:\n                # Linear interpolation to find the exact time of crossing\n                t1, t2 = times[i], times[i+1]\n                p1, p2 = positions[i], positions[i+1]\n                t_cross = t1 - p1 * (t2 - t1) / (p2 - p1)\n                crossings.append(t_cross)\n\n        if len(crossings)  2:\n            return 0.0\n\n        half_periods = np.diff(crossings)\n        \n        if len(half_periods) == 0:\n            return 0.0\n            \n        avg_half_period = np.mean(half_periods)\n        \n        if avg_half_period = 0: # Avoid division by zero or negative\n            return 0.0\n\n        return 1.0 / (2.0 * avg_half_period)\n\n    # --- Main execution ---\n    \n    # Define problem parameters from the statement\n    m = 1.0             # kg\n    f_true = 50.0         # Hz\n    x0 = 1.0            # m\n    v0 = 0.0            # m/s\n    dt = 1e-4           # s\n    T_sim = 0.5         # s\n\n    # Derived constant\n    k = m * (2.0 * np.pi * f_true)**2\n\n    # Test suite of downsampling factors\n    test_suite_s = [50, 167, 100, 200]\n\n    all_results = []\n\n    # Run the high-resolution simulation once, as it's common to all tests\n    num_steps = int(T_sim / dt)\n    t_high, x_high = _run_verlet(k, m, x0, v0, dt, num_steps)\n    \n    # Estimate the numerically realized frequency from the high-res data\n    f_verlet = _estimate_frequency(t_high, x_high)\n\n    for s in test_suite_s:\n        # 1. Downsample the trajectory\n        t_down = t_high[::s]\n        x_down = x_high[::s]\n\n        # 2. Calculate the sampling frequency for the downsampled data\n        dt_s = dt * s\n        f_s = 1.0 / dt_s if dt_s > 0 else 0.0\n        \n        # 3. Estimate frequency from the downsampled data\n        f_down = _estimate_frequency(t_down, x_down)\n        \n        # 4. Check the Nyquist criterion using the accurate f_Verlet\n        nyquist_ok = 1 if f_s >= 2 * f_verlet else 0\n        \n        # 5. Store the tuple of results for this test case\n        case_results = [f_true, f_verlet, f_s, f_down, nyquist_ok]\n        all_results.append(case_results)\n\n    # Format the final output string exactly as specified\n    output_strings = []\n    for res in all_results:\n        # res = [f_true, f_verlet, f_s, f_down, nyquist_ok]\n        formatted_res = [\n            f\"{res[0]:.6f}\",\n            f\"{res[1]:.6f}\",\n            f\"{res[2]:.6f}\",\n            f\"{res[3]:.6f}\",\n            str(int(res[4]))\n        ]\n        output_strings.append(f\"[{','.join(formatted_res)}]\")\n        \n    final_output = f\"[{','.join(output_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3144553"}]}