{"hands_on_practices": [{"introduction": "开始接触基于主体的模型（Agent-based Model, ABM）的最佳方式之一是亲手执行一次模拟。这个练习将引导你扮演计算机的角色，为一个关于寄居蟹寻找新壳的简单生态系统，一步步地执行代理规则。通过这种方式 [@problem_id:1840928]，你将深入理解离散时间、行为规则和更新顺序等ABM的核心机制，为构建更复杂的模型打下坚实的基础。", "problem": "一位生态学家正在开发一个简单的基于主体的模型，以模拟寄居蟹寻找新壳的行为。该模型在一个由10个潮汐池组成的一维环境中进行，这些潮汐池从1到10顺序编号。\n\n模拟开始时，有三只寄居蟹（寄居蟹A、寄居蟹B、寄居蟹C）和四个空壳位于特定位置。每只寄居蟹和每个壳都有一个整数“尺寸”值。\n\n**初始状态 (时间 t=0):**\n*   **寄居蟹:**\n    *   寄居蟹A：尺寸10，位于2号潮汐池。\n    *   寄居蟹B：尺寸12，位于9号潮汐池。\n    *   寄居蟹C：尺寸8，位于5号潮汐池。\n*   **空壳:**\n    *   一个尺寸为11的壳，位于3号潮汐池。\n    *   一个尺寸为13的壳，位于8号潮汐池。\n    *   一个尺寸为9的壳，位于6号潮汐池。\n    *   一个尺寸为10的壳，位于7号潮汐池。\n\n模拟以离散的时间步进行。在每个时间步内，寄居蟹按照以下规则行动：\n\n1.  **行动顺序：** 寄居蟹按字母顺序依次处理：先是寄居蟹A，然后是寄居蟹B，最后是寄居蟹C。环境状态（壳的位置）在每只寄居蟹行动后更新。\n2.  **目标：** 一只当前壳尺寸为 $S$ 的寄居蟹，只会寻找尺寸为理想大小 $S+1$ 的新空壳。\n3.  **搜索协议：** 位于位置 $P$ 的寄居蟹首先在其当前所在的潮汐池 ($P$) 中寻找理想的壳。如果池 $P$ 中没有理想的壳，它会接着搜索相邻的池 $P-1$ 和 $P+1$（如果这些池在环境边界内，即1到10号池）。\n4.  **行动规则：**\n    *   如果在其当前池 ($P$) 中找到理想的壳，寄居蟹会换入新壳。它的旧壳被留在池 $P$ 中变为空壳。然后该寄居蟹的回合结束。\n    *   如果池 $P$ 中没有理想的壳，但在相邻的池中找到了一个，寄居蟹会移动到那个位置并换壳。如果 $P-1$ 和 $P+1$ 中都有理想的壳，寄居蟹会优先选择索引较小的位置。移动并换壳后，它的旧壳被留在其*原始*池中变为空壳。然后该寄居蟹的回合结束。\n    *   如果在当前或相邻的池中都找不到理想的壳，寄居蟹不移动也不换壳，其回合结束。\n\n根据这些规则，确定模拟运行两个完整时间步后，寄居蟹C所占据的壳的尺寸。", "solution": "我们按照既定规则模拟两个离散时间步。设在时间 $t$，寄居蟹 $X \\in \\{A,B,C\\}$ 的尺寸和位置分别用 $s_{X}(t)$ 和 $p_{X}(t)$ 表示，时间 $t$ 的空壳集合为 $E_{t}=\\{(P,\\text{尺寸})\\}$。\n\n$t=0$ 时的初始状态：\n- $s_{A}(0)=10$, $p_{A}(0)=2$；$s_{B}(0)=12$, $p_{B}(0)=9$；$s_{C}(0)=8$, $p_{C}(0)=5$。\n- $E_{0}=\\{(3,11),(8,13),(6,9),(7,10)\\}$。\n\n时间步 1 (依次处理A、B、C，每次行动后更新状态):\n- 寄居蟹A：理想尺寸为 $s_{A}(0)+1=11$。搜索池 $p_{A}(0)=2$：$E_{0}$ 中没有 $(2,11)$。相邻的池是1和3。池3有 $(3,11)\\in E_{0}$。行动：移动到3号池并换壳。更新：\n  - $s_{A}(1)=11$, $p_{A}(1)=3$。\n  - 壳更新：从 $E_{0}$ 中移除 $(3,11)$ 并添加A的旧壳 $(2,10)$。A行动后：$E=\\{(2,10),(8,13),(6,9),(7,10)\\}$。\n- 寄居蟹B：理想尺寸为 $s_{B}(0)+1=13$。搜索池 $p_{B}(0)=9$：没有 $(9,13)$。相邻的池是8和10。池8有 $(8,13)$。行动：移动到8号池并换壳。更新：\n  - $s_{B}(1)=13$, $p_{B}(1)=8$。\n  - 壳更新：移除 $(8,13)$ 并添加B的旧壳 $(9,12)$。B行动后：$E=\\{(2,10),(9,12),(6,9),(7,10)\\}$。\n- 寄居蟹C：理想尺寸为 $s_{C}(0)+1=9$。搜索池 $p_{C}(0)=5$：没有 $(5,9)$。相邻的池是4和6。池6有 $(6,9)$。行动：移动到6号池并换壳。更新：\n  - $s_{C}(1)=9$, $p_{C}(1)=6$。\n  - 壳更新：移除 $(6,9)$ 并添加C的旧壳 $(5,8)$。\n时间步1结束后：$E_{1}=\\{(2,10),(9,12),(7,10),(5,8)\\}$ 并且 $(s_{A}(1),p_{A}(1))=(11,3)$，$(s_{B}(1),p_{B}(1))=(13,8)$，$(s_{C}(1),p_{C}(1))=(9,6)$。\n\n时间步 2 (再次按A、B、C的顺序，使用 $E_{1}$):\n- 寄居蟹A：理想尺寸为 $s_{A}(1)+1=12$。搜索池 $p_{A}(1)=3$，然后是相邻的2和4。$E_{1}$ 中没有 $(3,12)$、$(2,12)$ 或 $(4,12)$。无行动：\n  - $s_{A}(2)=11$, $p_{A}(2)=3$，$E$ 不变。\n- 寄居蟹B：理想尺寸为 $s_{B}(1)+1=14$。搜索池 $p_{B}(1)=8$，然后是相邻的7和9。$E_{1}$ 中没有 $(8,14)$、$(7,14)$ 或 $(9,14)$。无行动：\n  - $s_{B}(2)=13$, $p_{B}(2)=8$，$E$ 不变。\n- 寄居蟹C：理想尺寸为 $s_{C}(1)+1=10$。搜索池 $p_{C}(1)=6$：$E_{1}$ 中没有 $(6,10)$。相邻的池是5和7。池7有 $(7,10)$。行动：移动到7号池并换壳。更新：\n  - $s_{C}(2)=10$, $p_{C}(2)=7$。\n  - 壳更新：移除 $(7,10)$ 并添加C的旧壳 $(6,9)$。最终的空壳集合变为 $\\{(2,10),(9,12),(5,8),(6,9)\\}$。\n\n因此，经过两个完整的时间步后，寄居蟹C占据了一个尺寸为 $s_{C}(2)=10$ 的壳。", "answer": "$$\\boxed{10}$$", "id": "1840928"}, {"introduction": "在掌握了手动模拟的基础后，我们可以用它来探索具体的科学概念。这个练习 [@problem_id:1840929] 建立了一个草原犬鼠种群模型，用以展示“阿利效应”（Allee effect）——一个重要的生态学原理，即种群密度过低会导致个体存活率下降。你将看到，个体之间基于局部信息的简单互动，如何涌现出复杂的种群动态。", "problem": "一位生态学家正在使用一个简单的基于代理的模型来研究一个假想的草原犬鼠物种。这些草原犬鼠生活在线性排列的5个洞穴中，编号从1到5。模拟以离散的年度周期（年）进行。系统状态由每年年初每个洞穴中草原犬鼠的数量定义。\n\n在第1年年初，系统的初始状态如下：\n- 洞穴1：3只草原犬鼠\n- 洞穴2：0只草原犬鼠\n- 洞穴3：2只草原犬鼠\n- 洞穴4：0只草原犬鼠\n- 洞穴5：1只草原犬鼠\n\n每个年度周期包括三个连续阶段：移动、生存和繁殖。\n\n1.  **移动阶段：** 所有位于奇数编号洞穴（1, 3, 5）中的草原犬鼠会移动到下一个编号更大的洞穴。洞穴5中的草原犬鼠移动到洞穴1（循环边界）。所有位于偶数编号洞穴（2, 4）中的草原犬鼠会移动到下一个编号更小的洞穴。\n\n2.  **生存阶段：** 该物种表现出强烈的阿利效应（Allee effect）。移动阶段结束后，对每个洞穴中的草原犬鼠进行生存评估。如果一个洞穴包含总共3个或更多个体，则该洞穴中的所有个体都存活下来。如果一个洞穴包含少于3个个体，则该洞穴中的所有个体都会死亡并从模拟中移除。设存活所需的最小群体规模为 $N_{min} = 3$。\n\n3.  **繁殖阶段：** 每个在生存阶段存活下来的草原犬鼠都会产生恰好一个后代。设繁殖率为 $R=1$。这些新的后代被添加到其亲本所在的洞穴中。下一年年初的总种群数量是所有存活者及其新后代的总和。\n\n遵循这些规则，计算在第3年年初整个系统中的草原犬鼠总数。", "solution": "我们将一步一步地模拟两个完整的年度周期，以找出第3年年初的种群数量。\n\n**第1年**\n\n**初始状态（第1年年初）：**\n草原犬鼠的初始分布为：\n- 洞穴1：3\n- 洞穴2：0\n- 洞穴3：2\n- 洞穴4：0\n- 洞穴5：1\n总种群数量为 $3 + 0 + 2 + 0 + 1 = 6$。\n\n**1. 移动阶段（第1年）：**\n我们应用移动规则：\n- 位于奇数编号洞穴1的3只草原犬鼠移动到洞穴2。\n- 位于奇数编号洞穴3的2只草原犬鼠移动到洞穴4。\n- 位于奇数编号洞穴5的1只草原犬鼠移动到洞穴1（循环边界）。\n- 偶数编号的洞穴（2和4）中没有草原犬鼠可以移动。\n\n移动阶段后，分布情况为：\n- 洞穴1：1 (来自洞穴5)\n- 洞穴2：3 (来自洞穴1)\n- 洞穴3：0\n- 洞穴4：2 (来自洞穴3)\n- 洞穴5：0\n\n**2. 生存阶段（第1年）：**\n我们将每个洞穴中的个体数量与生存阈值 $N_{min} = 3$ 进行比较。\n- 洞穴1：1个个体。由于 $1 < 3$，存活的个体为0。\n- 洞穴2：3个个体。由于 $3 \\ge 3$，所有3个个体都存活。\n- 洞穴3：0个个体。由于 $0 < 3$，存活的个体为0。\n- 洞穴4：2个个体。由于 $2 < 3$，存活的个体为0。\n- 洞穴5：0个个体。由于 $0 < 3$，存活的个体为0。\n\n存活的草原犬鼠总数为3，全部位于洞穴2。\n\n**3. 繁殖阶段（第1年）：**\n3个存活者中的每一个都产生 $R=1$ 个后代。\n- 新生后代总数 = $3 \\times 1 = 3$。\n这些后代被添加到其亲本所在的洞穴（洞穴2）。\n第2年年初的新种群数量是存活者和后代的总和。\n- 洞穴2的种群数量 = 3（存活者）+ 3（后代）= 6。\n\n**第2年年初的状态：**\n- 洞穴1：0\n- 洞穴2：6\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n总种群数量为 $0 + 6 + 0 + 0 + 0 = 6$。\n\n**第2年**\n\n**初始状态（第2年年初）：**\n分布情况如第1年年末所确定：\n- 洞穴1：0\n- 洞穴2：6\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n\n**1. 移动阶段（第2年）：**\n我们应用移动规则：\n- 位于偶数编号洞穴2的6只草原犬鼠移动到下一个编号更小的洞穴，即洞穴1。\n- 其他洞穴中没有草原犬鼠可以移动。\n\n移动阶段后，分布情况为：\n- 洞穴1：6 (来自洞穴2)\n- 洞穴2：0\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n\n**2. 生存阶段（第2年）：**\n我们将每个洞穴中的个体数量与生存阈值 $N_{min} = 3$ 进行比较。\n- 洞穴1：6个个体。由于 $6 \\ge 3$，所有6个个体都存活。\n- 所有其他洞穴都有0个个体，所以在每个洞穴中存活的个体为0。\n\n存活的草原犬鼠总数为6，全部位于洞穴1。\n\n**3. 繁殖阶段（第2年）：**\n6个存活者中的每一个都产生 $R=1$ 个后代。\n- 新生后代总数 = $6 \\times 1 = 6$。\n这些后代被添加到其亲本所在的洞穴（洞穴1）。\n第3年年初的新种群数量是存活者和后代的总和。\n- 洞穴1的种群数量 = 6（存活者）+ 6（后代）= 12。\n\n**第3年年初的状态：**\n- 洞穴1：12\n- 洞穴2：0\n- 洞穴3：0\n- 洞穴4：0\n- 洞穴5：0\n第3年年初的总种群数量为 $12 + 0 + 0 + 0 + 0 = 12$。", "answer": "$$\\boxed{12}$$", "id": "1840929"}, {"introduction": "从手动推演到计算模拟是掌握ABM的关键一步。这项高级练习 [@problem_id:3096201] 要求你编写一个野火蔓延的随机空间模型，其中包含了风场和燃料异质性等真实世界因素。这个挑战不仅在于实现模型本身，更在于利用它作为虚拟实验室来研究临界现象，并将其与统计物理学中的“逾渗理论”（percolation theory）联系起来，体验计算科学在研究复杂系统中的强大威力。", "problem": "考虑一个大小为 $L \\times L$ 的二维方格上的野火代理基模型 (ABM)。每个格点是一个代理，其离散状态为 $\\{ \\text{empty}, \\text{fuel}, \\text{burning}, \\text{burned} \\}$ 中的一种。燃料异质性通过每次运行的两个独立随机场来建模：一个燃料占据场和一个干燥度场。燃料占据场是参数为 $p \\in [0,1]$ 的伯努利场；一个格点有概率 $p$ 为燃料，否则为空。干燥度场为每个格点分配一个标量 $s \\in [0,1]$，该标量从 $s \\sim \\mathrm{Uniform}(1-h,1)$ 分布中独立采样，其中 $h \\in [0,1]$ 控制异质性。给定一个恒定的风场矢量 $\\vec{w} = (w_x,w_y) \\in \\mathbb{R}^2$。火灾动态以离散时间步演化。在时间 $t=0$ 时，最左侧列（列索引为 $0$）上的所有燃料格点被点燃（状态为 burning）。在随后的每个时间步 $t \\to t+1$ 中，每个燃烧中的格点会尝试点燃其在基本方向 $\\mathcal{N} = \\{\\text{east},\\text{west},\\text{south},\\text{north}\\}$ 上的四个最近邻格点，之后其自身状态变为 burned。一个邻近的燃料格点（非空、未烧毁且未在燃烧）被点燃的概率取决于风向校准和局部干燥度。\n\n定义四个基本方向的单位方向矢量为 $\\vec{d}_\\text{east}=(1,0)$、$\\vec{d}_\\text{west}=(-1,0)$、$\\vec{d}_\\text{south}=(0,1)$ 和 $\\vec{d}_\\text{north}=(0,-1)$，坐标对齐方式为 $x$ 轴向右增加，$y$ 轴向下增加。设 $q_0 \\in [0,1]$ 为基准点燃概率分量，$\\gamma \\ge 0$ 为风敏感性参数。对于方向 $d \\in \\mathcal{N}$，定义方向性点燃概率分量\n$$\nq_d = \\mathrm{clip}\\left(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}),\\,0,\\,1\\right),\n$$\n其中\n$$\na(\\vec{w},\\vec{d}) = \\begin{cases}\n\\frac{\\vec{w} \\cdot \\vec{d}}{\\|\\vec{w}\\|},  \\|\\vec{w}\\| > 0,\\\\\n0,  \\|\\vec{w}\\| = 0,\n\\end{cases}\n$$\n且 $\\mathrm{clip}(x,0,1)$ 将 $x$ 截断到区间 $[0,1]$ 内。如果多个燃烧中的邻居试图点燃同一个燃料格点，则假设各次尝试相互独立，并通过互补法则进行组合。如果格点 $(i,j)$ 的干燥度为 $s_{i,j}$，并接收到来自方向子集 $\\mathcal{A} \\subseteq \\mathcal{N}$ 的点燃尝试，则其在下一个时间步的点燃概率为\n$$\nP^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} \\left(1 - s_{i,j} \\, q_d\\right).\n$$\n边界是反射性的，即格外的格点不存在，也不会产生点燃尝试。当没有格点在燃烧时，火灾终止。定义一次运行实现穿越，如果在运行期间最右侧列（列索引为 $L-1$）中的任何格点曾变为燃烧或已烧毁状态。\n\n从逾渗的角度来看，在给定的燃料占据率 $p$ 下，经验穿越概率定义为实现穿越的独立运行（具有独立重采样的燃料和干燥度场）所占的比例。对于此ABM，逾渗阈值估计值 $p^\\ast$ 在离散扫描 $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$ 上操作性地定义为，其经验穿越概率至少为 $0.5$ 的最小扫描 $p$ 值。如果没有扫描的 $p$ 满足此标准，则定义 $p^\\ast = p_{\\max} + \\Delta p$ 作为哨兵值，表示阈值高于扫描范围。对于相同的格点拓扑，方格上的键逾渗的精确逾渗阈值为 $p_c^\\text{bond} = 0.5$。对于每个测试用例，通过报告差异 $p^\\ast - p_c^\\text{bond}$ 来比较ABM阈值 $p^\\ast$ 与 $p_c^\\text{bond}$。\n\n严格按照上述说明实现ABM，并使用离散扫描和重复运行来估计 $p^\\ast$。使用以下测试套件；每个测试用例是一个元组 $(L, w_x, w_y, h, q_0, \\gamma, p_{\\min}, p_{\\max}, \\Delta p, N_\\text{runs})$：\n- 测试用例1：$(40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例2：$(40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例3：$(40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n- 测试用例4：$(30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60)$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。对于每个测试用例，输出两个浮点数，四舍五入到3位小数：首先是估计的ABM阈值 $p^\\ast$，然后是差异 $p^\\ast - p_c^\\text{bond}$。最终输出列表按顺序汇总所有测试用例，产生8个数字：\n$$\n\\left[ p^\\ast_1,\\; p^\\ast_1 - 0.5,\\; p^\\ast_2,\\; p^\\ast_2 - 0.5,\\; p^\\ast_3,\\; p^\\ast_3 - 0.5,\\; p^\\ast_4,\\; p^\\ast_4 - 0.5 \\right].\n$$\n所有量都是无量纲的；不需要物理单位。角度，如果通过点积和归一化隐式引用，则通过无量纲的校准因子处理；不使用明确的角度单位。", "solution": "该问题要求为一个在二维格点上传播的野火实现一个随机代理基模型 (ABM)，并随后估计其逾渗阈值 $p^\\ast$。解决方案的制定首先是构建一个严格遵循指定动态的计算模型，然后将此模型部署在一个统计框架内以确定 $p^\\ast$。\n\n### 1. 模型构建与状态表示\n系统是一个大小为 $L \\times L$ 的方格。每个格点 $(i,j)$ 是一个代理，其状态属于集合 $\\{\\text{empty}, \\text{fuel}, \\text{burning}, \\text{burned}\\}$。在计算实现中，这些离散状态映射到整数值：empty $\\to 0$、fuel $\\to 1$、burning $\\to 2$ 和 burned $\\to 3$。整个格点的状态由一个 $L \\times L$ 的 NumPy 数组表示。\n\n指定了两种淬火无序源：\n1.  **燃料占据场**：一个参数为 $p$ 的伯努利场决定了燃料的初始布局。实现方式是生成一个 $L \\times L$ 的在 $[0,1]$ 区间内均匀分布的随机数数组，并将随机数小于 $p$ 的格点指定为燃料。\n2.  **干燥度场**：为每个格点分配一个标量干燥度 $s_{i,j} \\in [0,1]$，该值从均匀分布 $\\mathrm{Uniform}(1-h,1)$ 中独立采样。这由一个独立的 $L \\times L$ 浮点型 NumPy 数组表示。\n\n这两个场在每次模拟运行开始时生成一次。\n\n### 2. 方向性点燃概率的预计算\n模型通过调节基准点燃概率来整合风的影响。风是一个恒定矢量 $\\vec{w} = (w_x, w_y)$。它对基本方向 $d \\in \\{\\text{east}, \\text{west}, \\text{north}, \\text{south}\\}$ 上点燃过程的影响取决于风与该方向之间的一致性。对于 $\\|\\vec{w}\\| > 0$，校准因子由 $a(\\vec{w},\\vec{d}) = (\\vec{w} \\cdot \\vec{d}) / \\|\\vec{w}\\|$ 给出，否则为 $0$。方向矢量定义为 $\\vec{d}_\\text{east}=(1,0)$、$\\vec{d}_\\text{west}=(-1,0)$、$\\vec{d}_\\text{south}=(0,1)$ 和 $\\vec{d}_\\text{north}=(0,-1)$，其中y轴指向下方。\n\n然后，方向性点燃概率分量 $q_d$ 计算为 $q_d = \\mathrm{clip}(q_0 + \\gamma \\cdot a(\\vec{w},\\vec{d}), 0, 1)$，其中 $q_0$ 是基准概率分量，$\\gamma$ 是风敏感性。由于 $\\vec{w}$、$q_0$ 和 $\\gamma$ 在单个测试用例的所有运行中都是恒定的，因此在启动模拟运行之前，会预先计算四个值 $\\{q_{\\text{east}}, q_{\\text{west}}, q_{\\text{north}}, q_{\\text{south}}\\}$。\n\n### 3. 模拟算法\n单次模拟运行根据指定规则在离散时间步上演化格点的状态。\n\n**初始化**：\n一次运行开始时，首先按照第1节所述设置格点。生成燃料场和干燥度场后，通过将最左侧列（列索引 $0$）中所有燃料格点的状态更改为 'burning'（状态 $2$）来引燃初始火灾。\n\n**时间演化**：\n模拟在一个循环中进行，只要存在 'burning' 格点，循环就会继续。状态更新是同步的，这意味着它们是基于时间 $t$ 的格点状态计算的，以确定时间 $t+1$ 的状态。\n\n1.  **识别点燃源**：创建一个布尔掩码 `is_burning` 来定位当前处于状态 $2$ 的所有格点。\n2.  **计算点燃概率**：模拟的核心是为每个燃料格点计算点燃概率 $P^\\text{ignite}_{i,j}$。问题陈述指出，对于一个干燥度为 $s_{i,j}$ 且受到来自邻居集合 $\\mathcal{A}$ 的点燃尝试的格点 $(i,j)$，其总点燃概率为 $P^\\text{ignite}_{i,j} = 1 - \\prod_{d \\in \\mathcal{A}} (1 - s_{i,j} q_d)$。这个公式正确地组合了独立的概率事件。\n    为了高效实现这一点，我们首先计算*不*被点燃的概率。一个 $L \\times L$ 的数组 `prob_no_ignition` 被初始化为1。对于每个基本方向，我们识别出该方向上与燃烧格点相邻的燃料格点。这是通过移动 `is_burning` 掩码并使用向量化的 NumPy 操作来完成的。例如，要找到燃烧格点东侧的燃料格点，可将 `is_burning` 掩码向左移动一个位置。对于每个目标燃料格点，其 `prob_no_ignition` 值乘以相应的因子 $(1 - s_{i,j} q_d)$。对所有四个方向重复此操作。\n3.  **随机点燃**：在考虑了所有相邻火源后，每个燃料格点的最终点燃概率为 `ignite_prob = 1.0 - prob_no_ignition`。然后为每个格点从 $\\mathrm{Uniform}(0,1)$ 分布中抽取一个随机数。如果一个燃料格点抽取的随机数小于其计算出的 `ignite_prob`，则该格点被新点燃。\n4.  **状态更新**：执行同步更新。所有在时间步开始时为 'burning' 的格点转变为 'burned'（状态 $3$）。所有新被点燃的 'fuel' 格点转变为 'burning'（状态 $2$）。\n5.  **终止与穿越**：如果火灾熄灭（没有格点处于 'burning' 状态）或实现了穿越，则一次运行终止。穿越定义为最右侧列（索引 $L-1$）中的任何格点进入 'burning' 或 'burned' 状态。一个布尔标志跟踪穿越是否发生。如果发生穿越，该次运行的模拟将立即停止，并记录为一次成功。如果火在到达最右侧列之前熄灭，则运行失败。\n\n### 4. 逾渗阈值估计\n主要目标是估计逾渗阈值 $p^\\ast$。这是通过对燃料占据概率的离散范围 $p \\in \\{p_{\\min}, p_{\\min}+\\Delta p, \\dots, p_{\\max}\\}$ 进行系统扫描来实现的。对于每个 $p$ 值：\n1.  执行固定数量的独立模拟运行，即 $N_\\text{runs}$ 次。\n2.  统计导致穿越的运行次数。\n3.  经验穿越概率计算为（成功运行次数）/ $N_\\text{runs}$。\n4.  将此概率与阈值 $0.5$进行比较。扫描中第一个使经验穿越概率至少为 $0.5$ 的 $p$ 值被定义为估计的逾渗阈值 $p^\\ast$。随后扫描终止。\n5.  如果扫描完成时穿越概率从未达到 $0.5$，则将 $p^\\ast$ 赋予防护值 $p_{\\max} + \\Delta p$。\n\n### 5. 最终输出计算\n对于每个测试用例，按上述方法确定估计阈值 $p^\\ast$。最终报告的量是 $p^\\ast$ 本身以及差异 $p^\\ast - p_c^\\text{bond}$，其中参考的键逾渗阈值给定为 $p_c^\\text{bond}=0.5$。为每个测试用例计算这两个值，四舍五入到三位小数，并汇总成一个列表作为最终输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef run_simulation(L, p, h, q_coeffs):\n    \"\"\"\n    Executes a single run of the wildfire ABM.\n\n    Args:\n        L (int): Lattice size.\n        p (float): Fuel occupancy probability.\n        h (float): Dryness heterogeneity parameter.\n        q_coeffs (tuple): Tuple of (q_E, q_W, q_N, q_S) ignition probabilities.\n\n    Returns:\n        bool: True if the fire crosses the lattice, False otherwise.\n    \"\"\"\n    # State mapping: 0=empty, 1=fuel, 2=burning, 3=burned\n    states = np.zeros((L, L), dtype=np.int8)\n    \n    # 1. Initialization\n    is_fuel_mask = np.random.rand(L, L) < p\n    states[is_fuel_mask] = 1\n    \n    dryness = np.random.uniform(1 - h, 1.0, size=(L, L))\n    \n    q_E, q_W, q_N, q_S = q_coeffs\n    \n    # Ignite the leftmost column where there is fuel\n    leftmost_fuel = states[:, 0] == 1\n    states[leftmost_fuel, 0] = 2\n    \n    # Check for immediate crossing (for L=1 or if no fuel on left edge)\n    if not np.any(leftmost_fuel):\n        return False\n    if np.any(states[:, -1] >= 2):\n        return True\n\n    # 2. Time evolution loop\n    while True:\n        is_burning = (states == 2)\n        if not np.any(is_burning):\n            break  # Fire has extinguished\n\n        is_fuel = (states == 1)\n        prob_no_ignition = np.ones((L, L), dtype=np.float64)\n\n        # Vectorized calculation of ignition probabilities from all 4 directions\n        # Igniters from West influence their Eastern neighbors\n        igniters_W = np.zeros_like(is_burning)\n        igniters_W[:, 1:] = is_burning[:, :-1]\n        ignitable_E = igniters_W & is_fuel\n        if q_E > 0:\n            prob_no_ignition[ignitable_E] *= (1.0 - dryness[ignitable_E] * q_E)\n\n        # Igniters from East influence their Western neighbors\n        igniters_E = np.zeros_like(is_burning)\n        igniters_E[:, :-1] = is_burning[:, 1:]\n        ignitable_W = igniters_E & is_fuel\n        if q_W > 0:\n            prob_no_ignition[ignitable_W] *= (1.0 - dryness[ignitable_W] * q_W)\n            \n        # Igniters from North influence their Southern neighbors\n        igniters_N = np.zeros_like(is_burning)\n        igniters_N[1:, :] = is_burning[:-1, :]\n        ignitable_S = igniters_N & is_fuel\n        if q_S > 0:\n            prob_no_ignition[ignitable_S] *= (1.0 - dryness[ignitable_S] * q_S)\n        \n        # Igniters from South influence their Northern neighbors\n        igniters_S = np.zeros_like(is_burning)\n        igniters_S[:-1, :] = is_burning[1:, :]\n        ignitable_N = igniters_S & is_fuel\n        if q_N > 0:\n            prob_no_ignition[ignitable_N] *= (1.0 - dryness[ignitable_N] * q_N)\n\n        ignite_prob = 1.0 - prob_no_ignition\n        \n        # Stochastic ignition event\n        rand_vals = np.random.rand(L, L)\n        newly_ignited = (rand_vals < ignite_prob) & is_fuel\n\n        # 3. Synchronous state update\n        states[is_burning] = 3   # Burning sites become burned\n        states[newly_ignited] = 2 # Newly ignited sites start burning\n        \n        # 4. Check for crossing\n        if np.any(states[:, -1] >= 2):  # burning (2) or burned (3)\n            return True\n\n    return False # Fire extinguished without crossing\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (40, 0.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, 2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (40, -2.0, 0.0, 0.2, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n        (30, 1.0, 0.5, 0.4, 0.3, 0.4, 0.35, 0.75, 0.05, 60),\n    ]\n\n    results = []\n    p_c_bond = 0.5\n\n    for case in test_cases:\n        L, w_x, w_y, h, q_0, gamma, p_min, p_max, delta_p, N_runs = case\n\n        # Pre-compute directional ignition components\n        w_norm = np.sqrt(w_x**2 + w_y**2)\n        ax, ay = 0.0, 0.0\n        if w_norm > 1e-9:\n            ax = w_x / w_norm\n            ay = w_y / w_norm\n        \n        q_E = np.clip(q_0 + gamma * ax, 0, 1)\n        q_W = np.clip(q_0 + gamma * -ax, 0, 1)\n        q_S = np.clip(q_0 + gamma * ay, 0, 1) # y-axis increases downwards\n        q_N = np.clip(q_0 + gamma * -ay, 0, 1)\n\n        q_coeffs = (q_E, q_W, q_N, q_S)\n\n        p_values = np.arange(p_min, p_max + delta_p / 2, delta_p)\n        p_star = p_max + delta_p # Sentinel value\n\n        for p in p_values:\n            cross_count = 0\n            for _ in range(N_runs):\n                if run_simulation(L, p, h, q_coeffs):\n                    cross_count += 1\n            \n            empirical_prob = cross_count / N_runs\n            \n            if empirical_prob >= 0.5:\n                p_star = p\n                break\n        \n        results.append(p_star)\n        results.append(p_star - p_c_bond)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{val:.3f}' for val in results])}]\")\n\nsolve()\n```", "id": "3096201"}]}