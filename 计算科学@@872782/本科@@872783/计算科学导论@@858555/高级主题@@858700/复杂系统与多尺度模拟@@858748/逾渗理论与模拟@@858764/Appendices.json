{"hands_on_practices": [{"introduction": "渗流理论最引人入胜的发现之一是，在临界阈值 $p_c$ 处，初生的无限簇（incipient infinite cluster）表现出分形特征，这意味着它的结构在不同尺度下具有统计自相似性。本练习 [@problem_id:3171745] 将指导你通过计算来量化这种分形几何，使用两种经典方法——盒子计数法（box-counting）和质量标度法（mass-scaling）——来估算其分形维数 $d_f$。这个实践将帮助你具体地理解临界现象中的标度不变性（scale invariance）这一核心概念。", "problem": "您将实现一个计算实验，以估计在逾渗阈值 $p_c$ 下，二维方格点阵上位点逾渗的初生无限簇的分形维数 $d_f$。出发点是这样一个基本原理：临界状态下的标度不变性意味着在不同尺度下测量的计数之间存在幂律关系，并且分形维数 $d_f$ 量化了统计自相似簇的质量随空间尺度的标度关系。在具有开放边界的 $L \\times L$ 点阵上，使用最近邻连接（von Neumann，四连接）。\n\n定义与约束：\n- 方格点阵上的位点逾渗指每个位点以概率 $p$ 被独立占据。二维方格点阵上位点逾渗的逾渗阈值为 $p_c \\approx 0.592746$。\n- 簇是由通过最近邻键（上、下、左、右）连接的已占据位点组成的集合。\n- 如果一个簇同时接触到点阵的顶部和底部边界，或同时接触到左侧和右侧边界，则称其为贯穿簇。\n- 在有限尺寸下，初生无限簇在操作上通过以下方式近似：如果存在贯穿簇，则选择贯穿簇；否则，选择质量最大（即包含位点数最多）的簇。\n- 通过两种源于标度不变性的独立方法估计 $d_f$：\n  1. 盒计数法：计算在尺度 $s$ 下，被占据的盒子数量如何随尺度变化而变化。\n  2. 质量标度法：计算距离参考点欧几里得半径 $R$ 范围内的质量如何随 $R$ 变化。\n\n算法要求：\n1. 生成一个 $L \\times L$ 的布尔点阵，其中每个位点以概率 $p$ 被占据。使用固定的伪随机种子以确保可复现性。使用开放边界。\n2. 使用广度优先搜索 (BFS) 识别连通簇。记录每个簇的质量、是否接触上、下、左、右边界，以及其位点坐标。\n3. 如果存在至少一个贯穿簇，则选择质量最大的贯穿簇作为目标簇；否则，选择质量最大的簇。\n4. 盒计数法维数估计：\n   - 对于在点阵尺寸范围内选择的2的幂次方的尺度 $s$（例如，$s \\in \\{2,4,8,16,\\dots\\}$ 且 $s \\le \\lfloor L/2 \\rfloor$），将点阵划分为边长为 $s$ 的不重叠盒子。\n   - 统计包含至少一个来自所选簇的位点的盒子数量。仅使用所选簇的位点来统计覆盖情况。\n   - 使用自然对数，对标度不变性所蕴含的相应对数变量进行线性回归，从斜率中获得 $d_f$。\n5. 质量标度法维数估计：\n   - 选择所选簇的几何中心（簇位点的行和列索引的算术平均值）作为参考点。\n   - 对于选择为2的幂次方且最高达到点阵尺寸一小部分的半径 $R$（例如，$R \\in \\{2,4,8,16,\\dots\\}$ 且 $R \\le \\lfloor L/4 \\rfloor$），计算与参考点的欧几里得距离小于或等于 $R$ 的簇位点数量。\n   - 使用自然对数，对标度不变性所蕴含的相应对数变量进行线性回归，从斜率中获得 $d_f$。\n6. 如果任一方法可用的尺度数量少于2，则该估计值应返回一个非数字浮点数。\n\n数值选择：\n- 使用自然对数。\n- 对每种方法，使用普通最小二乘法 (OLS) 线性回归来估计得出 $d_f$ 的斜率。\n\n测试套件：\n在以下测试用例上运行您的程序，每个用例指定为 $(L, p, \\text{seed}, \\text{method})$，其中 $\\text{method} \\in \\{\\text{\"box\"}, \\text{\"mass\"}\\}$：\n- 案例 1：$(64, 0.592746, 1234, \\text{\"box\"})$。\n- 案例 2：$(64, 0.592746, 1234, \\text{\"mass\"})$。\n- 案例 3：$(128, 0.592746, 42, \\text{\"box\"})$。\n- 案例 4：$(128, 0.592746, 42, \\text{\"mass\"})$。\n- 案例 5：$(32, 0.592746, 7, \\text{\"box\"})$。\n- 案例 6：$(32, 0.58, 7, \\text{\"mass\"})$。\n\n答案规格：\n- 对于每个案例，输出一个浮点数，该浮点数等于所选方法的估计 $d_f$ 值，并四舍五入到3位小数。\n- 最终输出格式：您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如，$[d_1,d_2,d_3,d_4,d_5,d_6]$），其中每个 $d_i$ 是案例 $i$ 的浮点数结果。", "solution": "该问题要求估计二维位点逾渗中初生无限簇的分形维数 $d_f$。这是计算统计物理学中的一个经典问题。解决方案包括生成一个逾渗系统，识别临界簇，然后应用两种源于临界点标度不变性原理的不同方法：盒计数法和质量标度法。\n\n基本原理是，在逾渗阈值 $p=p_c$ 处，系统是统计自相似的。这意味着其几何性质与观察它们的长度尺度无关。这种自相似性或标度不变性是分形的特征。分形维数 $d_f$ 是一个指数，它量化了物体的“质量”或“内容”如何随其线性尺寸进行标度。对于一个 $d$ 维欧几里得对象，其质量随半径 $R$ 的标度关系为 $M \\propto R^d$。对于分形对象，此关系被推广为 $M(R) \\propto R^{d_f}$，其中 $d_f$ 通常为非整数。对于二维逾渗中的初生无限簇，理论预测 $d_f = 91/48 \\approx 1.8958$。\n\n整体计算流程如下：\n1.  生成一个随机的 $L \\times L$ 点阵，其中每个位点以概率 $p$ 被占据。\n2.  使用图遍历算法，即广度优先搜索 (BFS)，来识别所有由已占据位点组成的连通簇。\n3.  选择一个“目标簇”，作为初生无限簇的有限尺寸近似。如果存在贯穿簇，则选择最大的贯穿簇；否则，选择质量最大的簇。\n4.  对这个目标簇应用两种不同的方法来估计 $d_f$。\n\n**方法1：质量标度维数**\n\n此方法直接使用质量分形的定义关系。距离中心点欧几里得半径 $R$ 范围内的簇的质量 $M(R)$ 预计会遵循幂律标度关系：\n$$M(R) \\propto R^{d_f}$$\n为了提取指数 $d_f$，我们可以通过对两边取自然对数来将此关系线性化：\n$$\\ln(M(R)) = d_f \\ln(R) + C$$\n其中 $C$ 是一个常数。此方程具有直线形式 $y = m x + c$，其中因变量为 $y = \\ln(M(R))$，自变量为 $x = \\ln(R)$，斜率为 $m = d_f$。\n\n因此，算法如下：\n1.  通过计算其所有位点坐标的算术平均值，来确定目标簇的几何中心。\n2.  对于一系列递增的半径 $R$（选择为2的幂，最大到 $L/4$），计算与中心点的欧几里得距离在 $R$ 之内的簇位点数量 $M(R)$。\n3.  对点集 $(\\ln(R), \\ln(M(R)))$ 执行普通最小二乘法 (OLS) 线性回归。\n4.  所得回归线的斜率即为分形维数 $d_f$ 的估计值。\n\n**方法2：盒计数维数**\n\n盒计数法提供了另一种测量分形维数的方法。它量化了覆盖对象所需的给定尺寸 $s$ 的“盒子”数量如何随 $s$ 的变化而变化。对于分形对象，这个数量 $N(s)$ 遵循幂律标度关系：\n$$N(s) \\propto \\left(\\frac{1}{s}\\right)^{d_f} = s^{-d_f}$$\n随着 $s$ 减小，覆盖对象所需的盒子数量增加。同样，我们通过取自然对数来将其线性化：\n$$\\ln(N(s)) = -d_f \\ln(s) + C'$$\n这也是一个线性方程 $y = m x + c$，其中 $y = \\ln(N(s))$，$x = \\ln(s)$，斜率为 $m = -d_f$。因此，分形维数可以估计为 $d_f = -m$。\n\n算法如下：\n1.  对于一系列盒子尺寸 $s$（选择为2的幂，最大到 $L/2$），将 $L \\times L$ 点阵划分为一个由不重叠的 $s \\times s$ 盒子组成的网格。\n2.  统计包含至少一个属于目标簇的位点的盒子数量 $N(s)$。\n3.  对点集 $(\\ln(s), \\ln(N(s)))$ 执行 OLS 线性回归。\n4.  分形维数的估计值是回归线斜率的负值，即 $d_f = -m$。\n\n**实现细节**\n\n点阵使用 `numpy.random.default_rng` 和指定的种子生成，以确保可复现性。通过遍历点阵的所有位点来执行簇识别。如果一个已占据的位点尚未被访问，则从该位点启动广度优先搜索 (BFS) 来查找属于该簇的所有连通位点，并将它们标记为已访问。在 BFS 期间，收集簇的属性（质量、位点坐标以及是否接触四个边界中的每一个）。找到所有簇后，根据指定规则选择目标簇。线性回归使用 `scipy.stats.linregress` 函数执行，该函数提供了 OLS 的稳健实现。如果一个方法产生的用于回归的数据点少于两个，则按规定返回一个非数值 (`nan`)。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy import stats\nfrom collections import deque\n\ndef _bfs_cluster_find(grid, start_node, visited):\n    \"\"\"\n    Performs a Breadth-First Search to find a single cluster.\n    \"\"\"\n    L = grid.shape[0]\n    q = deque([start_node])\n    visited[start_node] = True\n    \n    cluster_sites = []\n    mass = 0\n    touches_top = False\n    touches_bottom = False\n    touches_left = False\n    touches_right = False\n    \n    while q:\n        r, c = q.popleft()\n        \n        cluster_sites.append((r, c))\n        mass += 1\n        \n        if r == 0: touches_top = True\n        if r == L - 1: touches_bottom = True\n        if c == 0: touches_left = True\n        if c == L - 1: touches_right = True\n        \n        # Von Neumann neighbors\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = r + dr, c + dc\n            \n            if 0 = nr  L and 0 = nc  L and grid[nr, nc] and not visited[nr, nc]:\n                visited[nr, nc] = True\n                q.append((nr, nc))\n                \n    return {\n        \"mass\": mass,\n        \"sites\": cluster_sites,\n        \"touches_top\": touches_top,\n        \"touches_bottom\": touches_bottom,\n        \"touches_left\": touches_left,\n        \"touches_right\": touches_right,\n    }\n\ndef find_clusters(grid):\n    \"\"\"\n    Identifies all connected clusters in the grid using BFS.\n    \"\"\"\n    L = grid.shape[0]\n    visited = np.zeros_like(grid, dtype=bool)\n    clusters = []\n    \n    for r in range(L):\n        for c in range(L):\n            if grid[r, c] and not visited[r, c]:\n                cluster = _bfs_cluster_find(grid, (r, c), visited)\n                clusters.append(cluster)\n    return clusters\n\ndef select_target_cluster(clusters, L):\n    \"\"\"\n    Selects the target cluster based on spanning/mass criteria.\n    \"\"\"\n    if not clusters:\n        return None\n        \n    spanning_clusters = []\n    for c in clusters:\n        is_spanning_v = c['touches_top'] and c['touches_bottom']\n        is_spanning_h = c['touches_left'] and c['touches_right']\n        if is_spanning_v or is_spanning_h:\n            spanning_clusters.append(c)\n            \n    if spanning_clusters:\n        return max(spanning_clusters, key=lambda c: c['mass'])\n    else:\n        return max(clusters, key=lambda c: c['mass'])\n\ndef estimate_df_box(cluster, L):\n    \"\"\"\n    Estimates fractal dimension using the box counting method.\n    \"\"\"\n    sites = cluster['sites']\n    \n    log_s_vals = []\n    log_N_vals = []\n    \n    s = 2\n    while s = L // 2:\n        if s > 0:\n            occupied_boxes = set()\n            for r, c in sites:\n                occupied_boxes.add((r // s, c // s))\n            \n            N_s = len(occupied_boxes)\n            if N_s > 0:\n                log_s_vals.append(np.log(s))\n                log_N_vals.append(np.log(N_s))\n        s *= 2\n        \n    if len(log_s_vals)  2:\n        return np.nan\n        \n    slope, _, _, _, _ = stats.linregress(log_s_vals, log_N_vals)\n    return -slope\n\ndef estimate_df_mass(cluster, L):\n    \"\"\"\n    Estimates fractal dimension using the mass scaling method.\n    \"\"\"\n    sites_arr = np.array(cluster['sites'])\n    if sites_arr.shape[0] == 0:\n        return np.nan\n        \n    center = np.mean(sites_arr, axis=0)\n    distances = np.sqrt(np.sum((sites_arr - center)**2, axis=1))\n    \n    log_R_vals = []\n    log_M_vals = []\n    \n    R = 2\n    while R = L // 4:\n        if R > 0:\n            mass_in_radius = np.sum(distances = R)\n            if mass_in_radius > 0:\n                log_R_vals.append(np.log(R))\n                log_M_vals.append(np.log(mass_in_radius))\n        R *= 2\n        \n    if len(log_R_vals)  2:\n        return np.nan\n\n    slope, _, _, _, _ = stats.linregress(log_R_vals, log_M_vals)\n    return slope\n\ndef solve():\n    \"\"\"\n    Main function to run test cases and compute fractal dimensions.\n    \"\"\"\n    test_cases = [\n        (64, 0.592746, 1234, \"box\"),\n        (64, 0.592746, 1234, \"mass\"),\n        (128, 0.592746, 42, \"box\"),\n        (128, 0.592746, 42, \"mass\"),\n        (32, 0.592746, 7, \"box\"),\n        (32, 0.58, 7, \"mass\"),\n    ]\n\n    results = []\n    lattice_cache = {}\n\n    for L, p, seed, method in test_cases:\n        cache_key = (L, p, seed)\n        \n        if cache_key in lattice_cache:\n            target_cluster = lattice_cache[cache_key]\n        else:\n            # 1. Generate grid\n            rng = np.random.default_rng(seed)\n            grid = rng.random((L, L))  p\n            \n            # 2. Find clusters\n            clusters = find_clusters(grid)\n            \n            # 3. Select target cluster\n            target_cluster = select_target_cluster(clusters, L)\n            lattice_cache[cache_key] = target_cluster\n        \n        df_estimate = np.nan\n        if target_cluster is not None:\n            if method == \"box\":\n                df_estimate = estimate_df_box(target_cluster, L)\n            elif method == \"mass\":\n                df_estimate = estimate_df_mass(target_cluster, L)\n        \n        results.append(df_estimate)\n\n    formatted_results = []\n    for r in results:\n        if np.isnan(r):\n            formatted_results.append(\"nan\")\n        else:\n            formatted_results.append(f\"{r:.3f}\")\n\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3171745"}, {"introduction": "除了静态的几何性质，渗流簇的结构还决定了系统的输运特性，例如电导率。本练习 [@problem_id:3171738] 探讨了一个经典应用：通过将渗流模型映射为一个由随机连接的电阻组成的网络，并求解基尔霍夫定律描述的电压分布，来计算系统的有效电导率。这个过程将让你能够估算电导率临界指数 $t$，这是描述相变点附近物理性质如何变化的另一个普适指数。", "problem": "您将编写一个完整的、可运行的程序，通过将逾渗映射到一个随机电阻网络来估计二维键逾渗的电导率临界指数 $t$。在该网络中，每个被占据的键的电导为 $g=1$，而每个未被占据的键则不存在。该估计必须通过计算方形晶格在逾渗阈值 $p_c$ 附近，其相对两侧之间的有效体电导率 $\\sigma(p)$，然后对 $pp_c$ 的情况拟合标度关系 $\\sigma(p)\\propto (p-p_c)^t$ 来实现。\n\n基本原理和假设。使用以下经过充分检验的基本原理：\n- 欧姆定律描述了流经电导为 $g$ 的电阻的电流 $I$ 与其两端电压差 $\\Delta V$ 之间的关系：$I=g\\,\\Delta V$。\n- 基尔霍夫电流定律指出，对于电阻网络的任何内部节点，当系统处于稳态时，流出该节点的电流代数和为 $0$。\n- 在固定边界电压下，网络的解可以通过求解由基尔霍夫电流定律和欧姆定律推导出的离散泊松方程（带有狄利克雷边界条件的图拉普拉斯算子）得到。\n- 对于无限方形晶格上的键逾渗，其逾渗阈值为 $p_c=\\tfrac{1}{2}$（这是一个精确已知且被广泛接受的事实）。\n\n定义和数值设置。考虑一个 $L\\times L$ 的方形节点晶格，其键只存在于最近邻（水平和垂直方向）之间。每个可能的键以概率 $p\\in(0,1)$ 被独立占据，每个被占据的键被赋予电导 $g=1$，而未被占据的键则不存在。在左边界（列索引 $x=0$）的所有节点上施加狄利克雷边界条件 $V=1$，在右边界（列索引 $x=L-1$）的所有节点上施加 $V=0$。顶部和底部边界（行索引 $y=0$ 和 $y=L-1$）是电学自由的（无固定电势）。对于任何一次实现，有效电导率 $\\sigma(p)$ 定义为在施加单位压降 $\\Delta V=1$ 的情况下，从左边界注入的总净电流，这在任意单位下等于左右边界之间的有效两端电导。\n\n为确保数值可解性，任何未连接到左边界或右边界的内部连通节点分量都应被排除在线性系统之外，因为在狄利克雷边界条件下，其电势是未定的。在实践中，您必须将求解限制在通过被占据的键与至少一个狄利克雷边界相连的内部节点集合上。\n\n指数 $t$ 的估计器。对于每个测试用例，您将：\n- 对于给定的一组大于 $p_c$ 的 $p$ 值中的每一个，生成多个独立的网络实现，并为每一个计算有效电导率 $\\sigma(p)$，然后取其样本均值 $\\overline{\\sigma}(p)$。\n- 仅使用那些 $\\overline{\\sigma}(p)0$ 的 $p$ 值，通过普通最小二乘法（未加权）将 $\\log \\overline{\\sigma}(p)$ 作为 $\\log(p-p_c)$ 的函数拟合线性关系 $\\log \\overline{\\sigma}(p)=t\\log(p-p_c)+C$，以估计 $t$。对数可以是任何底；为明确起见，请使用自然对数。\n- 如果剩下 $\\overline{\\sigma}(p)0$ 的不同 $p$ 值少于2个，则该测试用例返回哨兵值 $-1.0$。\n\n程序必须遵循的实现细节：\n- 在至少连接到一个狄利克雷边界的内部节点集上构建图拉普拉斯算子。对于一个内部节点 $i$，对角线元素等于其到所有被占据邻居的电导之和，非对角线元素对于连接到其他内部节点的被占据键等于 $-g$。右侧项 $b$ 的贡献来自于连接到具有固定电压的边界节点的被占据键 ($+gV_{\\text{boundary}}$)。\n- 求解稀疏线性系统 $A\\mathbf{v}=\\mathbf{b}$ 以获得内部节点电压 $\\mathbf{v}$；然后计算从左边界注入的净电流，其值为所有连接左边界节点及其最近邻内部节点的被占据键的 $g\\,(1-V_{\\text{neighbor}})$ 之和。\n- 对于每个被占据的键使用 $g=1$，对于未被占据的键使用 $g=0$。\n- 使用逾渗阈值 $p_c=\\tfrac{1}{2}$。\n- 使用带有受控种子的伪随机数生成器以确保可复现性。对于测试用例索引 $k\\in\\{0,1,2\\}$ 和样本索引 $s\\in\\{0,1,\\dots,S-1\\}$，将种子设置为 $12345+1000k+s$。\n\n测试套件。您的程序必须为以下三个测试用例估计 $t$，其中每个用例使用指定的晶格尺寸 $L$、占据概率集合 $p$（每个都严格大于 $p_c$）以及每个 $p$ 值的独立样本数 $S$：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$.\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$.\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$.\n\n可量化的输出。对于每个用例，输出是一个实数：通过上述线性拟合得到的估计指数 $t$，使用自然对数计算。如果在通过 $\\overline{\\sigma}(p)0$ 过滤后，可用的 $p$ 值少于2个，则该用例输出哨兵值 $-1.0$。最终的数值输出没有物理单位，并且必须打印并四舍五入到三位小数。\n\n最终输出格式。您的程序应生成单行输出，其中包含按用例顺序排列的三个结果，以逗号分隔并用方括号括起来，例如：$[1.234,1.289,1.301]$。不应打印任何其他文本。", "solution": "我们概述了一种基于基本电网络理论和逾渗定义的有原则的计算方法，以估计电导指数 $t$。\n\n目标标度关系是，对于二维方形晶格上的键逾渗，在其逾渗阈值 $p_c$ 附近，当 $p$ 从上方趋近于 $p_c$ 时 ($p\\downarrow p_c$)，有效体电导率的行为如同 $\\sigma(p)\\propto (p-p_c)^t$。取对数可得 $\\log \\sigma(p) = t \\log(p-p_c) + C$，这启发我们将 $t$ 估计为 $pp_c$ 时 $\\log \\sigma(p)$ 相对于 $\\log(p-p_c)$ 的斜率。\n\n我们完全基于欧姆定律和基尔霍夫电流定律，通过逾渗产生的随机电阻网络来构建 $\\sigma(p)$。考虑一个 $L\\times L$ 的方形节点网格，其键存在于水平和垂直方向的最近邻之间。每个可能的键以概率 $p$ 被独立占据。每个被占据的键被赋予电导 $g=1$（任意单位），而未被占据的键则不存在 ($g=0$)。通过将左边界所有节点的电势设置为 $V=1$，右边界所有节点的电势设置为 $V=0$ 来施加狄利克雷边界条件。顶部和底部边界是电学自由的（无固定电势）。对于给定的网络实现，内部节点的电压由每个内部节点 $i$ 处的基尔霍夫电流定律确定：\n$$\n\\sum_{j\\in \\mathcal{N}(i)} g_{ij}\\,(V_i - V_j) = 0,\n$$\n其中 $\\mathcal{N}(i)$ 表示节点 $i$ 的邻居集合，$g_{ij}\\in\\{0,1\\}$ 是 $i$ 和 $j$ 之间键的电导。这为内部节点的电压 $\\mathbf{v}$ 产生了一个线性系统 $A\\mathbf{v}=\\mathbf{b}$，其中 $A$ 是限制在内部节点上的图拉普拉斯算子，$\\mathbf{b}$ 收集了来自连接到狄利克雷边界节点的被占据键的贡献。具体来说，对于一个内部节点 $i$， $A$ 的对角线元素是 $i$ 到其所有被占据邻居的电导之和，每个非对角线元素 $A_{ij}$ 对于内部节点 $i$ 和 $j$ 之间的被占据键等于 $-g_{ij}$。右侧项 $b_i$ 是 $\\sum_{j\\in \\partial \\Omega} g_{ij}\\,V_j$，即对从 $i$ 连接到具有固定电势 $V_j$ 的边界节点 $j$ 的所有被占据键求和。\n\n如果一个内部连通分量没有连接到任何狄利克雷边界，就会出现一个微妙的问题：该分量内的电势在相差一个加性常数的情况下是未定的，因此该分量的子矩阵是奇异的。为避免此问题，我们将线性系统的定义域限制在通过被占据的键与至少一个狄利克雷边界（左或右）相连的内部节点集上。这可以通过图遍历（如广度优先搜索）来实现，从左边界和右边界出发，跨越被占据的键，并保留从任一侧可达的内部节点的并集。未连接到任一边界的节点被排除在 $A$ 和 $\\mathbf{b}$ 之外，因为它们不会影响边界之间的电流。\n\n在求解 $A\\mathbf{v}=\\mathbf{b}$ 之后，我们使用欧姆定律计算从左边界注入的总电流，计算跨越连接左边界节点（固定在 $V=1$）与其直接内部邻居的被占据键。如果一个被占据的键连接了一个左边界节点和一个电压为 $V_{\\text{n}}$ 的内部节点，那么从左到内流经该键的电流是 $g\\,(1 - V_{\\text{n}})$。对所有此类键求和，得到净注入电流 $I_{\\text{L}}$。由于右边界固定在 $V=0$，边界间的总压降为 $\\Delta V=1$，因此有效电导（在这些任意单位下的体电导率）等于 $\\sigma = I_{\\text{L}}$。\n\n为了估计 $t$，我们对每个测试用例按以下步骤进行：\n- 对于一组给定的占据概率 $pp_c$ 和独立样本数 $S$，我们使用一个伪随机数生成器生成 $S$ 个独立的键构型，其种子确定性地设置为 $12345+1000k+s$，其中 $k$ 是测试用例索引，$s\\in\\{0,1,\\dots,S-1\\}$。对于每个构型，我们如上所述计算 $\\sigma(p)$。然后我们计算 $S$ 个样本的样本均值 $\\overline{\\sigma}(p)$。\n- 我们丢弃任何 $\\overline{\\sigma}(p)\\le 0$ 的 $p$ 值（这可能是由于有限尺寸效应或在 $p_c$ 附近采样不足造成的）。如果至少剩下2个 $p$ 值，我们通过普通最小二乘回归，使用自然对数，来拟合线性模型 $\\log \\overline{\\sigma}(p) = t \\log(p - p_c) + C$。拟合的斜率就是我们对 $t$ 的估计。如果剩下的可用数据点少于2个，我们输出哨兵值 $-1.0$。\n\n方形晶格上键逾渗的逾渗阈值是 $p_c=\\tfrac{1}{2}$，我们对所有测试用例都使用这个值。测试套件包括三个用例：\n- 用例 0: $L=24$, $p\\in\\{0.55,\\,0.60,\\,0.65,\\,0.70\\}$, $S=12$.\n- 用例 1: $L=16$, $p\\in\\{0.52,\\,0.56,\\,0.60,\\,0.64\\}$, $S=12$.\n- 用例 2: $L=12$, $p\\in\\{0.505,\\,0.530,\\,0.560,\\,0.620\\}$, $S=20$.\n\n这些用例分别探测：一个中等规模的系统，其多个 $p$ 值都安全地高于 $p_c$；一个较小的系统，包含更接近 $p_c$ 的 $p$ 值，以测试灵敏度和潜在的有限尺寸效应；以及一个小型系统，通过增加采样来减轻 $p_c$ 附近的噪声。最终程序打印单行输出，包含三个四舍五入到三位小数的估计斜率，格式完全符合 $[t_0,t_1,t_2]$，例如 $[1.234,1.289,1.301]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.sparse import coo_matrix, csr_matrix\nfrom scipy.sparse.linalg import spsolve\nfrom collections import deque\n\ndef generate_bonds(L, p, rng):\n    \"\"\"\n    Generate occupied bond arrays for an LxL lattice.\n    Horizontal bonds H[y, x] connect (x,y) -> (x+1,y) for x in [0..L-2], y in [0..L-1].\n    Vertical bonds V[y, x] connect (x,y) -> (x,y+1) for y in [0..L-2], x in [0..L-1].\n    Returns boolean arrays H (shape L x (L-1)) and V ((L-1) x L).\n    \"\"\"\n    H = rng.random((L, L - 1))  p\n    V = rng.random((L - 1, L))  p\n    return H, V\n\ndef bfs_reachable(L, H, V, from_left=True):\n    \"\"\"\n    BFS to find nodes reachable from the left (x=0) or right (x=L-1) boundary via occupied bonds.\n    Returns a boolean array reach[y, x] of shape (L, L).\n    \"\"\"\n    reach = np.zeros((L, L), dtype=bool)\n    q = deque()\n    if from_left:\n        x0 = 0\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n    else:\n        x0 = L - 1\n        for y in range(L):\n            reach[y, x0] = True\n            q.append((x0, y))\n\n    while q:\n        x, y = q.popleft()\n        # Left neighbor\n        if x > 0 and H[y, x - 1]:\n            nx, ny = x - 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Right neighbor\n        if x  L - 1 and H[y, x]:\n            nx, ny = x + 1, y\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Up neighbor\n        if y > 0 and V[y - 1, x]:\n            nx, ny = x, y - 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n        # Down neighbor\n        if y  L - 1 and V[y, x]:\n            nx, ny = x, y + 1\n            if not reach[ny, nx]:\n                reach[ny, nx] = True\n                q.append((nx, ny))\n\n    return reach\n\ndef build_system(L, H, V, reach_union):\n    \"\"\"\n    Build the sparse linear system A v = b for interior nodes that are reachable from either boundary.\n    Interior nodes are those with x in [1..L-2]. Boundary nodes at x=0 (V=1) and x=L-1 (V=0) are Dirichlet.\n    reach_union is boolean mask of nodes reachable from left or right boundaries.\n    Returns (A_csr, b, node_index, index_to_node).\n    node_index maps (x,y) -> idx in [0..n-1] for interior reachable nodes.\n    index_to_node is list mapping idx -> (x,y).\n    \"\"\"\n    # Map interior reachable nodes to indices\n    node_index = {}\n    index_to_node = []\n    for y in range(L):\n        for x in range(1, L - 1):\n            if reach_union[y, x]:\n                node_index[(x, y)] = len(index_to_node)\n                index_to_node.append((x, y))\n\n    n = len(index_to_node)\n    if n == 0:\n        # Empty system\n        A = coo_matrix((0, 0), dtype=float).tocsr()\n        b = np.zeros((0,), dtype=float)\n        return A, b, node_index, index_to_node\n\n    rows = []\n    cols = []\n    data = []\n    b = np.zeros(n, dtype=float)\n\n    def add_entry(i, j, val):\n        rows.append(i)\n        cols.append(j)\n        data.append(val)\n\n    for idx, (x, y) in enumerate(index_to_node):\n        diag = 0.0\n\n        # Neighbor to the left: (x-1, y) via H[y, x-1]\n        if x - 1 >= 0 and H[y, x - 1]:\n            diag += 1.0\n            if x - 1 == 0:\n                # Left boundary at V=1\n                b[idx] += 1.0 * 1.0\n            else:\n                # Interior node at (x-1, y)\n                if reach_union[y, x - 1]:\n                    jdx = node_index[(x - 1, y)]\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Not in system (should not happen for an occupied bond unless excluded)\n                    pass\n\n        # Neighbor to the right: (x+1, y) via H[y, x]\n        if x  L - 1 and H[y, x]:\n            diag += 1.0\n            if x + 1 == L - 1:\n                # Right boundary at V=0 => no contribution to b\n                pass\n            else:\n                if reach_union[y, x + 1]:\n                    jdx = node_index[(x + 1, y)]\n                    add_entry(idx, jdx, -1.0)\n\n        # Neighbor above: (x, y-1) via V[y-1, x]\n        if y - 1 >= 0 and V[y - 1, x]:\n            diag += 1.0\n            if reach_union[y - 1, x]:\n                jdx = node_index.get((x, y - 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n                else:\n                    # Could be boundary column (but y-1 same column), handled by reach mask\n                    pass\n\n        # Neighbor below: (x, y+1) via V[y, x]\n        if y  L - 1 and V[y, x]:\n            diag += 1.0\n            if reach_union[y + 1, x]:\n                jdx = node_index.get((x, y + 1))\n                if jdx is not None:\n                    add_entry(idx, jdx, -1.0)\n\n        # Diagonal entry\n        add_entry(idx, idx, diag)\n\n    A = coo_matrix((data, (rows, cols)), shape=(n, n), dtype=float).tocsr()\n    return A, b, node_index, index_to_node\n\ndef compute_sigma(L, p, seed):\n    \"\"\"\n    Compute effective conductance sigma for one random instance at given L, p, with RNG seed.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    H, V = generate_bonds(L, p, rng)\n\n    # Reachable from left and right boundaries\n    reach_left = bfs_reachable(L, H, V, from_left=True)\n    reach_right = bfs_reachable(L, H, V, from_left=False)\n    reach_union = np.logical_or(reach_left, reach_right)\n\n    # Build and solve system\n    A, b, node_index, index_to_node = build_system(L, H, V, reach_union)\n\n    if A.shape[0] == 0:\n        # No interior reachable nodes => no conduction\n        return 0.0\n\n    try:\n        v = spsolve(A, b)\n    except Exception:\n        # Numerical fallback: treat as zero conductance if solve fails\n        return 0.0\n\n    # Map voltages back for easy lookup\n    volt = {}\n    for idx, (x, y) in enumerate(index_to_node):\n        volt[(x, y)] = v[idx]\n\n    # Net current injected at left boundary across occupied bonds to column x=1\n    total_current = 0.0\n    x_left_neighbor = 1\n    for y in range(L):\n        if H[y, 0]:  # Bond between (0,y) and (1,y)\n            vn = volt.get((x_left_neighbor, y))\n            if vn is not None:\n                total_current += (1.0 - vn)  # g=1\n\n    # sigma equals total current for unit voltage drop\n    return float(total_current)\n\ndef mean_sigma_over_samples(L, p, case_index, S):\n    \"\"\"\n    Compute mean sigma over S samples for given L and p with deterministic seeding.\n    \"\"\"\n    sigmas = []\n    for s in range(S):\n        seed = 12345 + 1000 * case_index + s\n        sigmas.append(compute_sigma(L, p, seed))\n    return float(np.mean(sigmas))\n\ndef estimate_t(p_values, sigma_means, pc=0.5):\n    \"\"\"\n    Estimate exponent t by linear regression of log(sigma) vs log(p - pc).\n    Returns -1.0 if fewer than two usable points.\n    \"\"\"\n    x = []\n    y = []\n    for p, sm in zip(p_values, sigma_means):\n        if sm > 0.0 and p > pc:\n            x.append(np.log(p - pc))\n            y.append(np.log(sm))\n    if len(x)  2:\n        return -1.0\n    x = np.array(x)\n    y = np.array(y)\n    # Ordinary least squares fit: y = t * x + c\n    t, c = np.polyfit(x, y, 1)\n    return float(t)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # (case_index, L, p_list, samples S)\n        (0, 24, [0.55, 0.60, 0.65, 0.70], 12),\n        (1, 16, [0.52, 0.56, 0.60, 0.64], 12),\n        (2, 12, [0.505, 0.530, 0.560, 0.620], 20),\n    ]\n\n    pc = 0.5\n    results = []\n    for case_index, L, p_list, S in test_cases:\n        sigma_means = []\n        for p in p_list:\n            m = mean_sigma_over_samples(L, p, case_index, S)\n            sigma_means.append(m)\n        t_est = estimate_t(p_list, sigma_means, pc=pc)\n        # Round to three decimals for output\n        if np.isnan(t_est) or np.isinf(t_est):\n            t_est = -1.0\n        t_est_rounded = f\"{t_est:.3f}\"\n        results.append(t_est_rounded)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3171738"}, {"introduction": "真实的物理系统很少是完全均匀的，本练习 [@problem_id:3171702] 将带领我们从理想化的均匀模型走向更贴近现实的非均匀分层介质模型。通过为不同层级的格点分配不同的占据概率，我们能够模拟如地质构造或复合材料等系统的复杂行为。你将发现，这种非均匀性会引起各向异性的输运现象，并且解决这个问题需要一种巧妙的、基于寻找“瓶颈路径”的图算法。", "problem": "您的任务是研究具有层状非均质性的二维晶格上的格点逾渗。每个垂直坐标为 $z$ 的晶格格点都被赋予一个仅取决于 $z$（层索引）的开放概率 $p(z)$。位于位置 $(x,z)$ 的格点 $i$ 有一个独立的阈值 $u_i \\in [0,1]$，该阈值代表其变为开放所需的最小缩放概率。一个全局标量 $s \\ge 0$ 用于缩放层概率，因此格点 $i$ 的有效开放条件为不等式 $s \\, p(z_i) \\ge u_i$。对于给定的阈值配置 $\\{u_i\\}$ 和层分布 $p(z)$，将垂直逾渗阈值 $s_c^{(v)}$ 定义为存在一条由开放格点组成的最近邻路径、将整个顶部边界（$z=0$）连接到底部边界（$z=L-1$）的最小 $s$ 值。类似地，将水平逾渗阈值 $s_c^{(h)}$ 定义为存在这样一条从左侧边界（$x=0$）连接到右侧边界（$x=L-1$）的路径的最小 $s$ 值。然后，垂直传输的有效临界占据率通过平均场代理定义为\n$$\\bar{p}_c^{(v)} \\equiv \\frac{1}{L} \\sum_{z=0}^{L-1} \\min\\!\\big(1, s_c^{(v)} \\, p(z)\\big),$$\n这是在垂直阈值下各层开放概率的空间平均值（在适用时饱和于 $1$）。为量化由分层引起的传输各向异性，定义各向异性指数\n$$\\mathcal{A} \\equiv \\frac{s_c^{(v)}}{s_c^{(h)}}.$$\n所有量均为无量纲。报告数值时，请将其表示为精确到 $6$ 位小数的小数。\n\n基本设定与约束：\n- 晶格：尺寸为 $L \\times L$ 的方形网格，其中 $L \\in \\mathbb{N}$，具有最近邻连接（四个邻居）和非周期性边界。\n- 格点阈值：对于以下所有测试用例，阈值 $\\{u_i\\}$ 都是固定的且先验已知；运行时没有随机性。\n- 层状非均质性：对于每个测试用例，开放概率分布 $p(z)$ 被规定为一个依赖于层的函数。除明确说明外，不要假定任何对称性。\n- 阈值定义：$s_c^{(v)}$ 和 $s_c^{(h)}$ 被定义为满足连接条件的最小 $s$ 值，其中开放条件 $s \\, p(z_i) \\ge u_i$ 应用于每个访问过的格点 $i$。\n\n您的任务是编写一个单一、完整的程序，根据上述定义为下面的每个测试用例计算对 $(\\bar{p}_c^{(v)}, \\mathcal{A})$。该程序必须以纯数学术语实现逻辑并产生确定性结果。\n\n测试套件：\n所有测试用例均使用 $L=3$。格点阈值 $u_i$ 对所有测试用例都相同，由以下 $3 \\times 3$ 数组给出\n- 对于 $z=0$（顶行）：$[0.2, 0.8, 0.2]$，\n- 对于 $z=1$（中行）：$[0.1, 0.1, 0.1]$，\n- 对于 $z=2$（底行）：$[0.2, 0.8, 0.2]$。\n层索引为 $z \\in \\{0,1,2\\}$，其中 $z=0$ 在顶部。\n\n定义四个非均质分布 $p(z)$ 如下：\n- 测试用例 1（均质基准）：对于所有 $z$，$p(z) = 0.5$。\n- 测试用例 2（高电导率中间层）：$p(0) = 0.3$，$p(1) = 0.9$，$p(2) = 0.3$。\n- 测试用例 3（低电导率中间障壁）：$p(0) = 0.3$，$p(1) = 0.1$，$p(2) = 0.3$。\n- 测试用例 4（高电导率顶层和底层）：$p(0) = 0.9$，$p(1) = 0.3$，$p(2) = 0.9$。\n\n为每个测试用例计算：\n- 如上定义的垂直有效临界占据率 $\\bar{p}_c^{(v)}$。\n- 各向异性指数 $\\mathcal{A} = s_c^{(v)}/s_c^{(h)}$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的、包含 8 个元素的逗号分隔列表，顺序为 $[\\bar{p}_c^{(v)}\\text{(用例 }1), \\mathcal{A}\\text{(用例 }1), \\bar{p}_c^{(v)}\\text{(用例 }2), \\mathcal{A}\\text{(用例 }2), \\bar{p}_c^{(v)}\\text{(用例 }3), \\mathcal{A}\\text{(用例 }3), \\bar{p}_c^{(v)}\\text{(用例 }4), \\mathcal{A}\\text{(用例 }4)]$，每个数字都四舍五入到恰好 $6$ 位小数并以小数形式表示（无百分号）。", "solution": "该问题定义明确，科学上合理，并包含确定性解决方案所需的所有必要信息。这是一个计算物理学问题，具体涉及非均质晶格上的逾渗理论。\n\n问题的核心是为一个具有固定格点特定阈值 $\\{u_i\\}$ 和依赖于层的开放概率 $p(z)$ 的系统确定垂直和水平逾渗阈值 $s_c^{(v)}$ 和 $s_c^{(h)}$。\n\n位于位置 $(x, z)$ 的格点 $i$ 在全局缩放因子 $s$ 满足条件 $s \\cdot p(z) \\ge u_{z,x}$ 时是开放的。这可以改写为为每个独立格点定义一个临界缩放因子 $s_i^*$：\n$$ s_i^* = \\frac{u_{z_i,x_i}}{p(z_i)} $$\n一个格点 $i$ 是开放的当且仅当 $s \\ge s_i^*$。所有测试用例的 $p(z)$ 值都是严格为正的，因此 $s_i^*$ 是良定义的。\n\n一条路径 $\\mathcal{P}$（即一个最近邻格点的序列）是完全开放的，如果所有格点 $i \\in \\mathcal{P}$ 都是开放的。这要求对所有 $i \\in \\mathcal{P}$ 都有 $s \\ge s_i^*$，这等价于要求 $s$ 大于或等于路径上的最大临界因子：\n$$ s \\ge \\max_{i \\in \\mathcal{P}} s_i^* $$\n因此，打开一条特定路径 $\\mathcal{P}$ 所需的最小缩放因子为 $s_{\\mathcal{P}} = \\max_{i \\in \\mathcal{P}} s_i^*$。\n\n逾渗阈值，例如 $s_c^{(v)}$，是存在至少一条垂直逾渗路径（连接顶部边界 $z=0$ 和底部边界 $z=L-1$）的最小缩放因子 $s$。这是所有可能的垂直逾渗路径的路径特定阈值 $s_{\\mathcal{P}}$ 中的最小值：\n$$ s_c^{(v)} = \\min_{\\mathcal{P} \\in \\{\\text{vertical paths}\\}} s_{\\mathcal{P}} = \\min_{\\mathcal{P} \\in \\{\\text{vertical paths}\\}} \\left( \\max_{i \\in \\mathcal{P}} s_i^* \\right) $$\n水平阈值 $s_c^{(h)}$ 也存在类似的表达式。这是一个经典的瓶颈最短路径问题。路径的“长度”或“成本”定义为其上任何节点的最大权重，我们寻求在两组节点（例如，顶部和底部边界）之间具有最小此类成本的路径。\n\n这个问题可以使用 Dijkstra 算法的一种变体来高效解决。我们将晶格格点视为图中的节点。到某个节点的“距离”将代表从起始边界到该节点的路径上可能的最小最大格点成本 $s_i^*$。\n\n找到一个通用逾渗阈值 $s_c$ 的算法如下：\n1. 对于给定的阈值晶格配置 $U = \\{u_{z,x}\\}$ 和层概率 $p(z)$，计算格点成本矩阵 $S^*$，其中每个元素为 $S_{z,x}^* = u_{z,x} / p(z)$。\n2. 初始化一个与晶格大小相同的距离矩阵 `dist`，所有条目设置为无穷大，并初始化一个空的优先队列 `pq`。该优先队列将存储 `(路径成本, (z, x))` 的元组。\n3. 对于起始边界上的每个格点 $(z_s, x_s)$（例如，对于垂直逾渗是 $z_s=0$），将其初始距离设置为其自身的成本，`dist`$[z_s, x_s] = S_{z_s,x_s}^*$，并将 `(S_{z_s,x_s}^*, (z_s, x_s))` 添加到优先队列中。\n4. 当优先队列不为空时，提取具有最小路径成本的条目 `(成本, (z, x))`。\n5. 对于格点 $(z, x)$ 的每个有效最近邻 $(z_n, x_n)$：\n    a. 计算通过当前格点到达此邻居的路径成本：`新成本` $= \\max(\\text{成本}, S_{z_n,x_n}^*)$。\n    b. 如果 `新成本` 小于当前已知的到该邻居的距离 `dist`$[z_n, x_n]$，则更新距离 `dist`$[z_n, x_n] = \\text{新成本}$，并将 `(新成本, (z_n, x_n))` 添加到优先队列中。\n6. 算法终止后，逾渗阈值 $s_c$ 是 `dist` 矩阵中目标边界上所有格点的最小值（例如，对于垂直逾渗是 $z=L-1$）。\n\n对于每个测试用例，此过程执行两次：一次用于垂直逾渗（从 $z=0$ 到 $z=L-1$）以找到 $s_c^{(v)}$，一次用于水平逾渗（从 $x=0$ 到 $x=L-1$）以找到 $s_c^{(h)}$。\n在确定阈值后，各向异性指数 $\\mathcal{A}$ 和有效临界占据率 $\\bar{p}_c^{(v)}$ 直接根据其定义计算：\n$$ \\mathcal{A} = \\frac{s_c^{(v)}}{s_c^{(h)}} $$\n$$ \\bar{p}_c^{(v)} = \\frac{1}{L} \\sum_{z=0}^{L-1} \\min\\!\\big(1, s_c^{(v)} \\, p(z)\\big) $$\n问题指定晶格大小为 $L=3$。固定的阈值矩阵为：\n$$ U = \\begin{pmatrix} 0.2  0.8  0.2 \\\\ 0.1  0.1  0.1 \\\\ 0.2  0.8  0.2 \\end{pmatrix} $$\n对于四个测试用例中的每一个，我们计算相应的格点成本矩阵 $S^*$ 并应用所述算法。例如，在测试用例 1 中，对于所有 $z$，有 $p(z)=0.5$，从而得到成本矩阵：\n$$ S^* = \\frac{1}{0.5} U = \\begin{pmatrix} 0.4  1.6  0.4 \\\\ 0.2  0.2  0.2 \\\\ 0.4  1.6  0.4 \\end{pmatrix} $$\n对于垂直逾渗，最优路径沿着第一列和第三列，例如 $(0,0) \\to (1,0) \\to (2,0)$，路径成本为 $\\max(0.4, 0.2, 0.4) = 0.4$。因此，$s_c^{(v)} = 0.4$。对于水平逾渗，最优路径是沿着中间行，即 $(1,0) \\to (1,1) \\to (1,2)$，路径成本为 $\\max(0.2, 0.2, 0.2) = 0.2$。因此，$s_c^{(h)} = 0.2$。这得出 $\\mathcal{A} = 0.4/0.2 = 2.0$ 且 $\\bar{p}_c^{(v)} = (1/3) \\sum_{z=0}^{2} \\min(1, 0.4 \\cdot 0.5) = 0.2$。对所有测试用例都遵循相同的过程。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef solve():\n    \"\"\"\n    Solves the percolation problem for all test cases.\n    \"\"\"\n    # Define the fixed lattice size and site thresholds U_{z,x}\n    L = 3\n    U = np.array([\n        [0.2, 0.8, 0.2],  # z=0 (top row)\n        [0.1, 0.1, 0.1],  # z=1 (middle row)\n        [0.2, 0.8, 0.2]   # z=2 (bottom row)\n    ])\n\n    test_cases = [\n        # Case 1: Homogeneous benchmark\n        np.array([0.5, 0.5, 0.5]),\n        # Case 2: High-conductivity middle layer\n        np.array([0.3, 0.9, 0.3]),\n        # Case 3: Low-conductivity middle barrier\n        np.array([0.3, 0.1, 0.3]),\n        # Case 4: High-conductivity top and bottom\n        np.array([0.9, 0.3, 0.9]),\n    ]\n    \n    results = []\n    for p_profile in test_cases:\n        # Calculate the site-cost matrix S*\n        # p_profile must be broadcastable to the shape of U\n        p_broadcasted = p_profile.reshape(L, 1)\n        S_star = U / p_broadcasted\n\n        # --- Calculate s_c_v (vertical threshold) ---\n        start_nodes_v = [(0, x) for x in range(L)]\n        target_boundary_v = 'bottom'\n        s_c_v = find_s_c(L, S_star, start_nodes_v, target_boundary_v)\n\n        # --- Calculate s_c_h (horizontal threshold) ---\n        start_nodes_h = [(z, 0) for z in range(L)]\n        target_boundary_h = 'right'\n        s_c_h = find_s_c(L, S_star, start_nodes_h, target_boundary_h)\n        \n        # --- Calculate anisotropy index A ---\n        # Handle potential division by zero, though not expected with given data\n        A = s_c_v / s_c_h if s_c_h != 0 else np.inf\n        \n        # --- Calculate effective critical occupation p_c_v_bar ---\n        p_c_v_bar_terms = [min(1.0, s_c_v * p_z) for p_z in p_profile]\n        p_c_v_bar = sum(p_c_v_bar_terms) / L\n        \n        results.extend([p_c_v_bar, A])\n\n    # Format output as required: 6 decimal places.\n    formatted_results = [f\"{r:.6f}\" for r in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\ndef find_s_c(L, S_star, start_nodes, target_boundary):\n    \"\"\"\n    Finds the percolation threshold using a Dijkstra-like algorithm for the\n    bottleneck shortest path problem.\n    _ L: Lattice size\n    _ S_star: Matrix of site costs s_i*\n    _ start_nodes: List of (z, x) tuples for the starting boundary\n    _ target_boundary: String specifying the target boundary ('bottom' or 'right')\n    \"\"\"\n    \n    dist = np.full((L, L), np.inf)\n    pq = []  # Min-heap (priority queue)\n\n    for z_start, x_start in start_nodes:\n        cost = S_star[z_start, x_start]\n        if cost  dist[z_start, x_start]:\n            dist[z_start, x_start] = cost\n            heapq.heappush(pq, (cost, (z_start, x_start)))\n\n    while pq:\n        cost, (z, x) = heapq.heappop(pq)\n        \n        # If we found a shorter path already, skip\n        if cost > dist[z, x]:\n            continue\n\n        # Explore neighbors\n        for dz, dx in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            zn, xn = z + dz, x + dx\n\n            # Check if neighbor is within bounds\n            if 0 = zn  L and 0 = xn  L:\n                # Path cost is the maximum of costs encountered so far\n                new_cost = max(cost, S_star[zn, xn])\n                \n                if new_cost  dist[zn, xn]:\n                    dist[zn, xn] = new_cost\n                    heapq.heappush(pq, (new_cost, (zn, xn)))\n    \n    # The threshold is the minimum of the costs on the target boundary\n    if target_boundary == 'bottom':\n        s_c = np.min(dist[L - 1, :])\n    elif target_boundary == 'right':\n        s_c = np.min(dist[:, L - 1])\n    else:\n        s_c = np.inf # Should not happen\n\n    return s_c\n\nsolve()\n```", "id": "3171702"}]}