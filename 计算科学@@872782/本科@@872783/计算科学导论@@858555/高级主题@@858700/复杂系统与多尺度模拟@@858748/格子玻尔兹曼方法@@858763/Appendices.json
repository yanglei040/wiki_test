{"hands_on_practices": [{"introduction": "我们从一个基本但至关重要的一维扩散问题开始。这个练习将指导你实现一个D1Q3格子玻尔兹曼模型，并进行网格加密研究来验证其数值精度。对于任何计算科学家来说，理解和量化数值方法的收敛阶都是一项基本技能，它能确保我们的模拟结果是可靠和准确的。[@problem_id:2500947]", "problem": "一个一维扩散热脉冲在周期性域上根据热方程演化。考虑一个长度为 $L$ 的周期性区间上的标量温度场 $T(x,t)$，它由方程 $\\partial_t T = \\alpha \\,\\partial_{xx} T$ 控制，其中 $\\alpha$ 是恒定的热扩散系数。我们将使用基于单弛豫时间 Bhatnagar–Gross–Krook (BGK) 模型的一维三速（D1Q3）格子玻尔兹曼方法 (LBM) 来近似该标量场的演化。D1Q3 模型采用物理单位下的离散粒子速度 $e_i \\in \\{-c, 0, +c\\}$、求积权重 $w_0 = 2/3$ 和 $w_{\\pm 1} = 1/6$，以及标量的线性平衡分布 $f_i^{\\mathrm{eq}} = w_i \\, T$。格子声速满足 $c_s^2 = c^2/3$。在与宏观热方程一致的扩散标度下，热扩散系数通过 $\\alpha = c_s^2 \\, (\\tau - 1/2)\\,\\Delta t$ 与格子参数相关联，其中 $\\tau$ 是无量纲弛豫时间，$\\Delta t$ 是物理时间步长。对于具有 $N_x$ 个节点和网格间距 $\\Delta x = L/N_x$ 的均匀网格，当 $c = \\Delta x/\\Delta t$ 时，D1Q3 中的迁移是精确的，这意味着在网格加密时，为保持 $\\alpha$ 不变，需要满足耦合关系 $\\Delta t = \\frac{\\Delta x^2}{3\\alpha}\\,(\\tau - 1/2)$。\n\n初始条件与精确解。设初始温度是一个振幅为 $A$、宽度参数为 $\\sigma_0$、中心位于 $x_0 = L/2$ 的周期性高斯脉冲。其 $2J+1$ 镜像周期近似为\n$$\nT(x,0) \\;=\\; A\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2}\\right).\n$$\n根据线性叠加原理和热方程的基本解，时间 $t$ 对应的周期性精确解为\n$$\nT_{\\mathrm{exact}}(x,t) \\;=\\; A\\sqrt{\\frac{\\sigma_0^2}{\\sigma_0^2 + 4\\alpha t}} \\;\\sum_{j=-J}^{J} \\exp\\!\\left(-\\frac{(x-x_0 + jL)^2}{\\sigma_0^2 + 4\\alpha t}\\right).\n$$\n所有量均为无量纲，因此任何最终数值都应作为无单位数报告。\n\n离散化与误差范数。在周期性网格上实现带有 BGK 碰撞和精确迁移的标量 D1Q3 LBM。宏观温度是零阶矩 $T = \\sum_i f_i$。通过 $f_i(x,0) = w_i \\, T(x,0)$ 初始化分布函数。演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步，以近似 $t^\\ast = N_t \\,\\Delta t$ 时的解。使用离散 $L^2$ 范数比较数值解 $T_{\\mathrm{num}}(x,t^\\ast)$ 与精确解 $T_{\\mathrm{exact}}(x,t^\\ast)$\n$$\nE \\;=\\; \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k,t^\\ast) - T_{\\mathrm{exact}}(x_k,t^\\ast)\\right]^2 \\right)^{1/2}.\n$$\n\n观测到的精度阶数。使用 $N_x \\in \\{64,128,256,512\\}$ 进行网格加密研究，同时通过上述扩散标度关系保持 $\\alpha$ 不变。对于每次加密，计算误差 $E$、网格间距 $\\Delta x$ 和时间步长 $\\Delta t$。估算：\n- 观测到的空间阶数 $p_x$，即 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率；\n- 观测到的时间阶数 $p_t$，即 $\\log E$ 对 $\\log \\Delta t$ 的最小二乘线性拟合的斜率。\n因为在扩散标度下 $\\Delta t \\propto \\Delta x^2$，所以必须对同一组加密数据进行两种拟合，以分别表征误差如何随 $\\Delta x$ 和 $\\Delta t$ 变化。\n\n测试套件。使用以下三组参数集，每组的域长度 $L=1$，中心 $x_0=L/2$，镜像数 $J=6$：\n- 情况 A（基准）：$\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 B（较低的热扩散系数）：$\\alpha=0.005$, $\\tau=0.8$, $\\sigma_0=0.05$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n- 情况 C（更尖锐的脉冲）：$\\alpha=0.02$, $\\tau=0.8$, $\\sigma_0=0.03$, $A=1.0$, $T_{\\mathrm{final}}=0.02$。\n\n程序要求。编写一个完整的程序，该程序：\n- 为每种情况和 $N_x \\in \\{64,128,256,512\\}$ 实现上述 D1Q3 标量 LBM。\n- 对每种情况，计算不同加密程度下的数组 $\\{E\\}$、$\\{\\Delta x\\}$ 和 $\\{\\Delta t\\}$，然后使用最小二乘拟合返回 $(p_x, p_t)$。\n- 其唯一的输出是一行包含六个浮点值的文本，按顺序为 $[p_x^{(A)},p_t^{(A)},p_x^{(B)},p_t^{(B)},p_x^{(C)},p_t^{(C)}]$，每个值四舍五入到三位小数，格式为方括号内以逗号分隔的列表。\n\n角度单位与物理单位。没有角度量，所有变量都是无量纲的。不应报告任何物理单位；所有输出都是纯数字。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，“[result1,result2,result3,result4,result5,result6]”）。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且自洽的。它提出了一个标准的数值分析任务，涉及将格子玻尔兹曼方法 (LBM) 应用于一维热方程。所有参数、方程和步骤都已足够清晰和正确地指定，可以得到唯一的解。因此，我们着手进行解的推导和实现。\n\n该问题要求在一个长度为 $L$ 的一维周期性域上，对标量热扩散方程\n$$\n\\partial_t T = \\alpha \\,\\partial_{xx} T\n$$\n进行数值求解。指定的方法是带有 Bhatnagar-Gross-Krook (BGK) 碰撞算子的 D1Q3 格子玻尔兹曼模型。\n\nD1Q3 模型将速度空间离散为三个方向，$i \\in \\{0, 1, 2\\}$，对应于微观粒子速度 $e_0 = 0$、$e_1 = +c$ 和 $e_2 = -c$。粒子分布函数 $f_i(x,t)$ 的演化由格子玻尔兹曼方程控制：\n$$\nf_i(x+e_i\\Delta t, t+\\Delta t) - f_i(x,t) = -\\frac{1}{\\tau} (f_i(x,t) - f_i^{\\mathrm{eq}}(x,t))\n$$\n其中 $\\tau$ 是无量纲弛豫时间，$f_i^{\\mathrm{eq}}$ 是局域平衡分布。方程左边表示粒子向相邻格子点的迁移，右边表示因碰撞而向平衡态的弛豫。\n\n对于标量扩散过程，平衡分布是宏观标量场（本例中为温度 $T$）的线性函数。它由 $f_i^{\\mathrm{eq}} = w_i T$ 给出，其中 $w_i$ 是求积权重。对于 D1Q3 模型，这些权重为 $w_0 = 2/3$ 和 $w_{1,2} = 1/6$。宏观温度通过分布函数的零阶矩恢复：\n$$\nT(x,t) = \\sum_{i=0}^{2} f_i(x,t)\n$$\n可以验证 $\\sum_i f_i^{\\mathrm{eq}} = \\sum_i w_i T = T(\\sum_i w_i) = T(2/3 + 1/6 + 1/6) = T$，这确保了在碰撞过程中标量 $T$ 的局域守恒。\n\n在每个时间增量中，数值算法分两步进行：碰撞和迁移。\n1.  **碰撞步**：在每个网格节点 $x_k$ 处计算碰撞后的分布函数 $f_i^{\\ast}$：\n    $$\n    f_i^{\\ast}(x_k, t) = f_i(x_k, t) - \\frac{1}{\\tau} (f_i(x_k, t) - f_i^{\\mathrm{eq}}(x_k, t))\n    $$\n    首先，从当前的分布函数计算宏观温度 $T(x_k,t) = \\sum_i f_i(x_k,t)$。然后，确定平衡分布函数 $f_i^{\\mathrm{eq}}(x_k,t) = w_i T(x_k,t)$，最后应用碰撞更新。\n\n2.  **迁移步**：碰撞后的分布函数根据其速度传播到相邻节点。当格子速度设为 $c = \\Delta x/\\Delta t$（其中 $\\Delta x$ 是网格间距，$\\Delta t$ 是时间步长）时，粒子在一个时间步内精确地从一个节点移动到其邻居节点。对于周期性域，这通过循环移位实现：\n    $$\n    f_0(x_k, t+\\Delta t) = f_0^{\\ast}(x_k, t) \\\\\n    f_1(x_k, t+\\Delta t) = f_1^{\\ast}(x_{k-1}, t) \\\\\n    f_2(x_k, t+\\Delta t) = f_2^{\\ast}(x_{k+1}, t)\n    $$\n    索引 $k-1$ 和 $k+1$ 采用周期性环绕处理。\n\n模拟在时间 $t=0$ 初始化。初始温度场 $T(x,0)$ 由周期性高斯函数之和给出。初始粒子分布被设置为与该场处于局域平衡：$f_i(x_k, 0) = f_i^{\\mathrm{eq}}(x_k, 0) = w_i T(x_k, 0)$。然后模拟演化 $N_t = \\mathrm{round}(T_{\\mathrm{final}}/\\Delta t)$ 个时间步。在实际的最终时间 $t^{\\ast} = N_t \\Delta t$ 计算最终的数值温度分布 $T_{\\mathrm{num}}(x_k, t^{\\ast})$。\n\n问题指定了一个扩散标度关系，以在网格加密过程中保持物理热扩散系数 $\\alpha$ 不变。该关系为：\n$$\n\\alpha = c_s^2 (\\tau - 1/2) \\Delta t\n$$\n其中 $c_s^2 = c^2/3 = (\\Delta x/\\Delta t)^2/3$ 是格子声速的平方。将 $c_s^2$ 代入 $\\alpha$ 的表达式并解出 $\\Delta t$，得到时间步长和网格间距之间的显式耦合关系：\n$$\n\\Delta t = \\frac{\\Delta x^2}{3\\alpha} (\\tau - 1/2)\n$$\n该关系意味着 $\\Delta t \\propto \\Delta x^2$。\n\n使用网格尺寸 $N_x \\in \\{64, 128, 256, 512\\}$ 进行网格加密研究。对于每个 $N_x$，网格间距为 $\\Delta x=L/N_x$，并计算相应的 $\\Delta t$。运行模拟，并使用离散 $L^2$ 范数，对照在 $t^{\\ast}$ 处求值的给定精确解计算误差 $E$：\n$$\nE = \\left(\\Delta x \\sum_{k=0}^{N_x-1} \\left[T_{\\mathrm{num}}(x_k, t^{\\ast}) - T_{\\mathrm{exact}}(x_k, t^{\\ast})\\right]^2 \\right)^{1/2}\n$$\n精度阶数是根据误差标度律 $E \\approx C (\\Delta x)^{p_x}$ 的假设确定的，其中 $C$ 为某个常数，$p_x$ 为空间阶数。取对数后得到 $\\log E \\approx \\log C + p_x \\log \\Delta x$。因此，空间阶数 $p_x$ 是 $\\log E$ 对 $\\log \\Delta x$ 的最小二乘线性拟合的斜率。类似地，由于 $\\Delta t \\propto \\Delta x^2$，我们有 $\\log E \\approx \\log C' + p_t \\log \\Delta t$，其中 $p_t = p_x/2$。时间阶数 $p_t$ 是 $\\log E$ 对 $\\log \\Delta t$ 的拟合斜率。将为指定的三个测试案例中的每一个计算这两个斜率。用于扩散问题的 LBM-BGK 格式在空间上预期具有二阶精度，因此我们预计 $p_x \\approx 2.0$，从而 $p_t \\approx 1.0$。\n\n实现过程首先是为初始条件和精确解析解定义函数。一个主模拟函数封装了针对给定物理和数值参数集的 LBM 算法。对每个加密级别调用此函数。收集由此产生的误差和网格参数。最后，对经对数转换的数据进行线性回归，以提取观测到的精度阶数，然后报告这些阶数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef setup_exact_solution_function(L, A, sigma0, alpha, J, x0):\n    \"\"\"\n    Creates a function that computes the exact solution for a given time t.\n    \"\"\"\n    def get_exact_solution(x_grid, t):\n        if t == 0:\n            var_term = sigma0**2\n            time_prefactor = A\n        else:\n            var_term = sigma0**2 + 4 * alpha * t\n            time_prefactor = A * np.sqrt(sigma0**2 / var_term)\n\n        if var_term == 0:\n            # Handle the case of a delta function, though not expected here.\n            T_exact = np.zeros_like(x_grid)\n            idx = np.abs(x_grid - x0).argmin()\n            T_exact[idx] = np.inf\n            return T_exact\n\n        T_exact = np.zeros_like(x_grid)\n        for j in range(-J, J + 1):\n            T_exact += np.exp(-((x_grid - x0 + j * L)**2) / var_term)\n        \n        return time_prefactor * T_exact\n\n    return get_exact_solution\n\n\ndef run_lbm_and_get_error(Nx, L, alpha, tau, T_final, A, sigma0, J, x0):\n    \"\"\"\n    Runs a single D1Q3 LBM simulation and computes the L2 error.\n    \"\"\"\n    # Grid and time parameters\n    dx = L / Nx\n    dt = (dx**2 / (3 * alpha)) * (tau - 0.5)\n    Nt = int(round(T_final / dt))\n    t_star = Nt * dt\n    x = np.linspace(0, L, Nx, endpoint=False) + dx / 2.0\n\n    # LBM parameters\n    w = np.array([2./3., 1./6., 1./6.]) # w0, w+, w-\n    omega = 1.0 / tau\n\n    # Initialization\n    exact_solution_func = setup_exact_solution_function(L, A, sigma0, alpha, J, x0)\n    T0 = exact_solution_func(x, 0)\n    \n    # Populations f0, f+, f-\n    f0 = w[0] * T0\n    f1 = w[1] * T0\n    f2 = w[2] * T0\n    \n    # Main time-stepping loop\n    for _ in range(Nt):\n        # Macroscopic temperature\n        T = f0 + f1 + f2\n        \n        # Collision\n        f0_eq = w[0] * T\n        f1_eq = w[1] * T\n        f2_eq = w[2] * T\n        \n        f0 = f0 - omega * (f0 - f0_eq)\n        f1 = f1 - omega * (f1 - f1_eq)\n        f2 = f2 - omega * (f2 - f2_eq)\n        \n        # Streaming\n        f1 = np.roll(f1, 1)  # moves right\n        f2 = np.roll(f2, -1) # moves left\n\n    # Final numerical temperature\n    T_num = f0 + f1 + f2\n    \n    # Exact solution at final time\n    T_exact = exact_solution_func(x, t_star)\n    \n    # L2 Error calculation\n    error = np.sqrt(dx * np.sum((T_num - T_exact)**2))\n    \n    return error, dx, dt\n\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and compute orders of accuracy.\n    \"\"\"\n    test_cases = [\n        # Case A (baseline)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case B (lower diffusivity)\n        {\"alpha\": 0.005, \"tau\": 0.8, \"sigma0\": 0.05, \"A\": 1.0, \"T_final\": 0.02},\n        # Case C (sharper pulse)\n        {\"alpha\": 0.02, \"tau\": 0.8, \"sigma0\": 0.03, \"A\": 1.0, \"T_final\": 0.02},\n    ]\n\n    # Shared parameters\n    L = 1.0\n    x0 = L / 2.0\n    J = 6\n    Nx_refinements = [64, 128, 256, 512]\n    \n    all_results = []\n    \n    for case_params in test_cases:\n        errors = []\n        dxs = []\n        dts = []\n        \n        for Nx in Nx_refinements:\n            error, dx, dt = run_lbm_and_get_error(Nx, L, **case_params, J=J, x0=x0)\n            errors.append(error)\n            dxs.append(dx)\n            dts.append(dt)\n        \n        # Log-transform data for linear regression\n        log_errors = np.log(np.array(errors))\n        log_dxs = np.log(np.array(dxs))\n        log_dts = np.log(np.array(dts))\n        \n        # Perform linear regression to find slopes (orders of accuracy)\n        px_res = linregress(log_dxs, log_errors)\n        pt_res = linregress(log_dts, log_errors)\n        \n        px = px_res.slope\n        pt = pt_res.slope\n        \n        all_results.extend([px, pt])\n\n    # Format the final output string\n    # [px_A, pt_A, px_B, pt_B, px_C, pt_C] rounded to 3 decimal places\n    output_str = f\"[{','.join([f'{r:.3f}' for r in all_results])}]\"\n    print(output_str)\n\nsolve()\n```", "id": "2500947"}, {"introduction": "在掌握了一维模拟的基础之后，我们现在将问题扩展到二维空间，这是模拟真实物理现象的关键一步。在这个练习中，你将使用D2Q5模型来模拟静止流体中高斯温度脉冲的扩散。通过验证温度场的方差随时间线性增长，你将亲手验证格子玻尔兹曼方法如何从微观的粒子分布演化中，精确地重现宏观的扩散物理定律。[@problem_id:2501032]", "problem": "要求您使用格子单位，为静止流体中的被动温度场实现一个用于热扩散的二维格子玻尔兹曼方法（LBM）。该计算模型应基于在二维五速（通常称为 D2Q5）离散速度集上的单弛豫时间 Bhatnagar–Gross–Krook (BGK) 碰撞算子。该区域在两个方向上都是周期性的。初始条件是位于区域中心的高斯温度脉冲。您的目标是数值上证明温度场沿一个笛卡尔坐标的方差随时间线性增长，其斜率等于热扩散系数的两倍，并量化测量斜率与理论值之间的绝对偏差。\n\n使用的基本原理：\n- 静止介质中被动标量的热方程：$\\partial_t T = \\alpha \\nabla^2 T$，其中 $T$ 是温度，$\\alpha$ 是热扩散系数。\n- 被动标量的 BGK 碰撞离散速度动力学更新：离散布居的迁移，随后是在静止流体中向仅依赖于 $T$ 的局部平衡态的弛豫。\n- 两个方向上的周期性边界条件。\n\n离散化和模型要求：\n- 使用 D2Q5 格子，其速度为 $\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$, $\\mathbf{e}_4=(0,-1)$，并使用等温被动标量模型的常用权重。\n- 宏观温度通过 $T=\\sum_i g_i$ 从布居中恢复，并且在没有流动的情况下，局部平衡态必须仅依赖于 $T$。\n- 区域是一个大小为 $N_x\\times N_y$ 的方形网格，在两个方向上都是周期性的，格子间距 $\\Delta x = 1$，时间步长 $\\Delta t=1$（均为无量纲的格子单位）。\n- 使用高斯温度脉冲进行初始化\n$$\nT(x,y,0)=A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right),\n$$\n该脉冲以网格中心 $(x_0,y_0)$ 为中心，其中 $A$ 是任意正振幅，$\\sigma_0$ 是初始标准差（均为格子单位）。\n- 选择 LBM 弛豫参数，使您的模拟能够实现以格子单位表示的指定热扩散系数 $\\alpha$。\n\n要测量的数值可观测量：\n- 在每个时间步 $t$，计算沿 $x$ 的温度加权平均位置，\n$$\n\\mu_x(t)=\\frac{\\sum_{x,y} x\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)},\n$$\n以及沿 $x$ 的相应方差，\n$$\n\\sigma_x^2(t)=\\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2\\,T(x,y,t)}{\\sum_{x,y} T(x,y,t)}.\n$$\n- 通过对整个模拟时间窗口（以格子单位计）内 $\\sigma_x^2(t)$ 与 $t$ 的线性回归，使用普通最小二乘法估计斜率 $s_{\\text{meas}}$。理论预测值为 $s_{\\text{theory}}=2\\alpha$。对于每个测试，报告绝对误差 $|s_{\\text{meas}}-2\\alpha|$。\n\n物理和数值单位：\n- 所有量均以格子单位表示（无量纲）。以“每格子时间步长的格子方差”为单位报告斜率和误差。\n\n网格、运行时间和初始条件规范：\n- 使用 $N_x=N_y=81$，$\\Delta x=\\Delta t=1$，周期性区域，并将高斯中心置于网格中心 $(x_0,y_0)=\\left(\\frac{N_x-1}{2},\\frac{N_y-1}{2}\\right)$。使用振幅 $A=1$。\n- 使用与静止流体（无平流）一致的局部平衡态。\n\n测试套件：\n运行以下三个模拟，并计算每种情况所要求的误差：\n1. 情况 1（理想情况）：$\\alpha=0.10$，$\\sigma_0=3.0$，$N_t=500$ 个时间步。\n2. 情况 2（接近弛豫稳定性边界的小扩散系数）：$\\alpha=0.02$，$\\sigma_0=5.0$，$N_t=500$ 个时间步。\n3. 情况 3（在稳定性限制内的较大扩散系数）：$\\alpha=0.15$，$\\sigma_0=4.0$，$N_t=500$ 个时间步。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含三个绝对误差，按上述情况的顺序以逗号分隔的列表形式，并用方括号括起来。例如，打印的行必须如下所示\n“[e1,e2,e3]”\n其中每个 $e_k$ 是一个以“每格子时间步长的格子方差”为单位的浮点数（无量纲）。", "solution": "问题陈述已经过严格验证，被认为是科学上合理、适定且客观的。它为一种数值方法提出了一个标准的验证测试，并提供了所有必要的物理和数值参数。我们将继续进行解的推导和实现。\n\n该问题要求对静止介质中被动标量 $T$ 的二维热方程进行数值模拟，该方程由下式给出\n$$\n\\partial_t T = \\alpha \\nabla^2 T\n$$\n其中 $\\alpha$ 是热扩散系数。我们将采用带有单弛豫时间（BGK）碰撞算子的格子玻尔兹曼方法（LBM）。\n\nLBM 在离散格子上模拟一组粒子分布函数 $g_i(\\mathbf{x}, t)$ 的演化。每个函数 $g_i$ 代表以离散速度 $\\mathbf{e}_i$ 运动的粒子密度。其演化由离散速度玻尔兹曼方程控制：\n$$\ng_i(\\mathbf{x}+\\mathbf{e}_i\\Delta t, t+\\Delta t) - g_i(\\mathbf{x}, t) = \\Omega_i(g)\n$$\n其中 $\\Omega_i$ 是碰撞算子，我们使用格子单位，其中时间步长 $\\Delta t = 1$ 且格子间距 $\\Delta x = 1$。对于 BGK 模型，碰撞算子描述了向局部平衡分布 $g_i^{eq}$ 的弛豫过程：\n$$\n\\Omega_i(g) = -\\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n$$\n其中 $\\tau$ 是无量纲弛豫时间。\n\nLBM 算法在每个时间增量中包含两个执行步骤：\n1.  **碰撞 (Collision):** 在每个格点 $\\mathbf{x}$ 计算碰撞后的分布 $g_i^*$。\n    $$\n    g_i^*(\\mathbf{x}, t) = g_i(\\mathbf{x}, t) - \\frac{1}{\\tau} \\left( g_i(\\mathbf{x}, t) - g_i^{eq}(\\mathbf{x}, t) \\right)\n    $$\n2.  **迁移 (Streaming):** 碰撞后的分布根据其速度迁移到相邻的格点。\n    $$\n    g_i(\\mathbf{x}+\\mathbf{e}_i, t+1) = g_i^*(\\mathbf{x}, t)\n    $$\n\n对于此问题，我们使用 D2Q5 格子，它在二维空间中有五个离散速度：\n$\\mathbf{e}_0=(0,0)$, $\\mathbf{e}_1=(1,0)$, $\\mathbf{e}_2=(0,1)$, $\\mathbf{e}_3=(-1,0)$ 和 $\\mathbf{e}_4=(0,-1)$。\n\n宏观温度 $T$ 通过分布函数求和得到：\n$$\nT(\\mathbf{x}, t) = \\sum_{i=0}^{4} g_i(\\mathbf{x}, t)\n$$\n对于静止流体（零速度），被动标量的局部平衡分布 $g_i^{eq}$ 仅依赖于局部温度 $T$：\n$$\ng_i^{eq} = w_i T\n$$\n其中 $w_i$ 是与离散速度相对应的一组权重。对于 D2Q5 模型，确保最终扩散方程具有各向同性的标准权重为 $w_0 = 1/3$ 和 $w_1 = w_2 = w_3 = w_4 = 1/6$。这些权重满足 $\\sum_i w_i = 1$ 和 $\\sum_i w_i e_{i\\alpha} e_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$，其中 $c_s^2 = 1/3$ 是格子声速的平方。\n\n通过 Chapman-Enskog 多尺度展开，可以证明该 LBM 格式能恢复宏观热方程，其热扩散系数 $\\alpha$ 由下式给出：\n$$\n\\alpha = c_s^2 \\left(\\tau - \\frac{1}{2}\\right) = \\frac{1}{3} \\left(\\tau - \\frac{1}{2}\\right)\n$$\n根据这个关系式，我们可以为给定的扩散系数 $\\alpha$ 确定所需的弛豫时间 $\\tau$：\n$$\n\\tau = 3\\alpha + \\frac{1}{2}\n$$\n为了数值稳定性，$\\tau$ 必须大于 $0.5$，这意味着 $\\alpha > 0$。所提供的测试用例满足此条件。\n\n模拟区域是一个大小为 $N_x \\times N_y = 81 \\times 81$ 的周期性方形网格。初始条件是一个以 $(x_0, y_0) = (40, 40)$ 为中心的高斯温度分布：\n$$\nT(x,y,0) = A\\exp\\!\\left(-\\frac{(x-x_0)^2+(y-y_0)^2}{2\\sigma_0^2}\\right)\n$$\n振幅 $A=1$。初始分布函数 $g_i(x,y,0)$ 根据此初始温度场设置为其平衡值：$g_i(x,y,0) = w_i T(x,y,0)$。\n\n在从 $t=0$ 到 $t=N_t$ 的每个时间步 $t$，我们计算温度分布沿 $x$ 坐标的方差 $\\sigma_x^2(t)$。其定义为：\n$$\n\\sigma_x^2(t) = \\frac{\\sum_{x,y} \\left(x-\\mu_x(t)\\right)^2 T(x,y,t)}{\\sum_{x,y} T(x,y,t)}\n$$\n其中 $\\mu_x(t)$ 是平均 $x$ 位置。由于初始条件的对称性和周期性区域，$\\mu_x(t)$ 将保持在 $x_0$ 不变。\n\n对于初始高斯分布，连续热方程的解析解表明方差随时间线性增长：$\\sigma_x^2(t) = \\sigma_x^2(0) + 2\\alpha t$。目标是数值上验证此关系。我们将对计算出的数据点 $(\\sigma_x^2(t), t)$（其中 $t \\in [0, N_t]$）执行普通最小二乘法（OLS）线性回归，以找到测量斜率 $s_{\\text{meas}}$。理论斜率为 $s_{\\text{theory}} = 2\\alpha$。最后，我们报告每个指定测试用例的绝对误差 $|s_{\\text{meas}} - s_{\\text{theory}}|$。\n\n实现将利用 `numpy` 进行高效的数组操作。带有周期性边界条件的迁移步骤可以使用 `numpy.roll` 函数自然地实现。OLS 回归将使用 `scipy.stats.linregress` 执行。整个过程被封装在一个函数中，该函数会遍历所提供的测试用例。", "answer": "```python\nimport numpy as np\nfrom scipy.stats import linregress\n\ndef solve():\n    \"\"\"\n    Implements a D2Q5 LBM simulation for thermal diffusion and validates\n    the linear growth of variance against theory.\n    \"\"\"\n    test_cases = [\n        # (alpha, sigma_0, N_t)\n        (0.10, 3.0, 500),\n        (0.02, 5.0, 500),\n        (0.15, 4.0, 500),\n    ]\n\n    results = []\n    for alpha, sigma_0, N_t in test_cases:\n        # 1. Setup and Initialization\n        Nx, Ny = 81, 81\n        A = 1.0\n\n        # D2Q5 Lattice Parameters\n        # e[i, 0] is x-component, e[i, 1] is y-component\n        e = np.array([[0, 0], [1, 0], [0, 1], [-1, 0], [0, -1]], dtype=int)\n        \n        # Standard weights for D2Q5 thermal model\n        w = np.array([1/3, 1/6, 1/6, 1/6, 1/6])\n\n        # Relation between diffusivity and relaxation time\n        # alpha = c_s^2 * (tau - 0.5) with c_s^2 = 1/3\n        tau = 3.0 * alpha + 0.5\n\n        # Create grid and initial temperature field\n        x = np.arange(Nx)\n        y = np.arange(Ny)\n        X, Y = np.meshgrid(x, y)\n        x0, y0 = (Nx - 1) / 2.0, (Ny - 1) / 2.0\n        \n        T_initial = A * np.exp(-((X - x0)**2 + (Y - y0)**2) / (2.0 * sigma_0**2))\n\n        # Initialize distribution functions at equilibrium\n        # g has shape (5, Ny, Nx)\n        g = w[:, np.newaxis, np.newaxis] * T_initial\n\n        # Arrays to store measurements\n        time_points = np.arange(N_t + 1)\n        variances_x = np.zeros(N_t + 1)\n\n        # 2. Main LBM Simulation Loop\n        for t in range(N_t + 1):\n            # a. Measurement\n            # Macroscopic temperature at current time t\n            T = np.sum(g, axis=0)\n\n            total_T = np.sum(T)\n            # Due to symmetry, mean should be constant. Recalculating for robustness.\n            mu_x = np.sum(X * T) / total_T\n            variances_x[t] = np.sum(((X - mu_x)**2) * T) / total_T\n            \n            # Stop after the last measurement is taken at t = N_t\n            if t == N_t:\n                break\n\n            # b. Collision\n            # T is already computed from g\n            g_eq = w[:, np.newaxis, np.newaxis] * T\n            g = g - (1.0 / tau) * (g - g_eq)\n\n            # c. Streaming\n            g_streamed = g.copy()\n            for i in range(1, 5): # Stream mobile populations (i=1 to 4)\n                # np.roll shift is (shift_axis_0, shift_axis_1)\n                # axis_0 is y, axis_1 is x\n                shift_vec = (e[i, 1], e[i, 0]) # (shift_y, shift_x)\n                g_streamed[i, :, :] = np.roll(g[i, :, :], shift=shift_vec, axis=(0, 1))\n            g = g_streamed\n\n        # 3. Analysis\n        # OLS regression of variance vs. time\n        regression = linregress(time_points, variances_x)\n        s_meas = regression.slope\n        s_theory = 2.0 * alpha\n\n        # Calculate absolute error\n        error = abs(s_meas - s_theory)\n        results.append(error)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "2501032"}, {"introduction": "格子玻尔兹曼方法的真正威力在于其强大的可扩展性，能够模拟复杂的流体物理。这个高级练习将挑战你超越理想气体模型，通过修改平衡分布函数来构建一个能够描述 van der Waals 非理想气体的D2Q9模型。这个练习的核心在于理解如何通过矩关系将宏观的物态方程（如非理想气体压力）融入到LBM的动力学框架中，为你打开模拟多相流和复杂流体的大门。[@problem_id:2407099]", "problem": "您需要为二维九速格子（D2Q9）上的格子玻尔兹曼方法（LBM）构建一个多项式平衡分布函数，该函数能以流速的二阶精度再现一个给定的非理想状态方程。请在格子单位下进行计算，以使所有量均为无量纲，并假设使用标准的D2Q9格子，其等温格子声速的平方等于 $c_s^2 = 1/3$。您的任务是从矩方法的观点出发：要求平衡分布函数的零阶、一阶和二阶速度矩分别恢复范德华流体的密度、动量和非理想压力张量。\n\n使用的基本依据和约束：\n- D2Q9离散速度集由九个向量 $c_i \\in \\mathbb{R}^2$ 给出，其中 $i \\in \\{0,\\dots,8\\}$：$(0,0)$, $(1,0)$, $(0,1)$, $(-1,0)$, $(0,-1)$, $(1,1)$, $(-1,1)$, $(-1,-1)$, $(1,-1)$。对应的权重为 $w_0 = 4/9$， $w_{1\\text{ 到 }4} = 1/9$， $w_{5\\text{ 到 }8} = 1/36$。\n- 设 $\\rho$ 为密度， $u \\in \\mathbb{R}^2$ 为宏观速度。平衡分布函数 $\\{ f_i^{eq} \\}_{i=0}^8$ 必须满足以下矩约束：\n  1) $\\sum_{i=0}^8 f_i^{eq} = \\rho$，\n  2) $\\sum_{i=0}^8 f_i^{eq} c_i = \\rho u$，\n  3) $\\sum_{i=0}^8 f_i^{eq} c_i c_i = p(\\rho,T)\\, I + \\rho\\, u u$，\n  其中 $I$ 是二维单位张量，像 $c_i c_i$ 和 $u u$ 这样的乘积表示外积。\n- 范德华状态方程为 $p(\\rho,T) = \\dfrac{\\rho\\, R\\, T}{1 - b \\rho} - a \\rho^2$，其中参数 $a  0$, $b  0$，热力学温度 $T  0$。在本问题中，取气体常数 $R = 1$（格子单位）。\n- 使用D2Q9标准的四阶各向同性恒等式，为 $f_i^{eq}$ 构建一个关于 $u$ 的二阶多项式拟设，其系数依赖于 $\\rho$ 和 $p(\\rho,T)$，并强制执行上述矩约束。不引入外力；严格通过修改平衡矩来实现非理想压力。\n\n算法要求：\n- 在一个程序中实现您推导出的D2Q9平衡态。对于每个测试用例，该程序计算用于量化您的 $\\{ f_i^{eq} \\}$ 是否满足三个矩约束的残差：\n  - 质量残差：$r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$。\n  - 动量残差范数：$r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$。\n  - 压力张量残差弗罗贝尼乌斯范数：$r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$。\n- 对于数值报告，每个测试用例输出三元组 $[r_0, r_1, r_2]$，并四舍五入到 $12$ 位小数。\n\n测试套件：\n- 使用以下五个测试用例，每个由 $(\\rho, u_x, u_y, a, b, T)$ 定义：\n  1) $(0.8, 0.12, -0.07, 0.5, 0.3, 0.9)$，\n  2) $(0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0)$，\n  3) $(3.2, 0.0, 0.0, 0.1, 0.3, 1.2)$，\n  4) $(1.0, 0.3, 0.4, 1.0, 0.1, 0.6)$，\n  5) $(0.9, 0.0, 0.0, 0.0, 0.4, 1.5)$。\n\n最终输出格式：\n- 您的程序应生成单行输出，包含五个结果三元组的列表，以逗号分隔并用方括号括起来，不含额外空格。例如，您的输出必须类似于：\n  \"[[r00,r01,r02],[r10,r11,r12],[r20,r21,r22],[r30,r31,r32],[r40,r41,r42]]\"\n其中每个 $r_{jk}$ 是按上述要求四舍五入到 $12$ 位小数的十进制数。", "solution": "该问题要求为D2Q9格子构建一个二阶多项式平衡分布函数 $f_i^{eq}$，该函数能够正确恢复范德华流体的宏观密度 $\\rho$、动量 $\\rho u$ 以及非理想动量通量张量 $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$。压力 $p(\\rho,T)$ 由 $p(\\rho,T) = \\dfrac{\\rho T}{1 - b \\rho} - a \\rho^2$ 给出（在格子单位下，气体常数 $R=1$）。推导过程将遵循矩方法。\n\n在格子玻尔兹曼方法（LBM）中，理想气体的标准二阶多项式平衡分布函数由下式给出：\n$$\nf_i^{eq, ideal} = w_i \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4} \\right)\n$$\n这里，$w_i$ 是格子权重，$c_{i\\alpha}$ 是离散速度的分量，$u_\\alpha$ 是宏观流体速度的分量，$c_s^2 = 1/3$ 是格子声速的平方。希腊字母索引 $\\alpha, \\beta$ 暗示对空间维度 $\\{x, y\\}$ 求和。\n\n该分布函数的矩为：\n1.  $\\sum_{i=0}^8 f_i^{eq, ideal} = \\rho$\n2.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha} = \\rho u_\\alpha$\n3.  $\\sum_{i=0}^8 f_i^{eq, ideal} c_{i\\alpha}c_{i\\beta} = \\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$\n\n这恢复了压力为 $p_{ideal} = \\rho c_s^2$ 的理想气体的动量通量张量。问题要求恢复的是非理想压力 $p(\\rho, T)$。目标动量通量张量是 $\\Pi_{\\alpha\\beta} = p(\\rho,T)\\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta$。\n\n为实现这一点，我们必须通过添加一个修正项 $\\Delta f_i^{eq}$ 来修改平衡分布函数，使得总分布函数 $f_i^{eq} = f_i^{eq, ideal} + \\Delta f_i^{eq}$ 满足所需的矩约束。该修正项不能改变零阶和一阶矩，并且必须适当地调整二阶矩。因此，对 $\\Delta f_i^{eq}$ 的约束是：\n1.  $\\sum_{i=0}^8 \\Delta f_i^{eq} = 0$\n2.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} = 0$\n3.  $\\sum_{i=0}^8 \\Delta f_i^{eq} c_{i\\alpha} c_{i\\beta} = \\Pi_{\\alpha\\beta} - (\\rho c_s^2 \\delta_{\\alpha\\beta} + \\rho u_\\alpha u_\\beta) = (p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$\n\n由于对动量通量张量的所需修正与速度 $u$ 无关，因此 $\\Delta f_i^{eq}$ 的一个合适的拟设也应与 $u$ 无关，并由离散速度 $c_i$ 的低阶多项式构成。我们提出一个形式如下的拟设：\n$$\n\\Delta f_i^{eq} = w_i K (c_i^2 - C)\n$$\n其中 $c_i^2 = c_{i\\alpha}c_{i\\alpha}$ 是离散速度向量 $c_i$ 模的平方。系数 $K$ 和 $C$ 是标量，它们依赖于 $\\rho$ 和 $T$，但与 $i$ 无关。\n\n我们使用D2Q9的各向同性关系来强制执行对此拟设的约束：$\\sum_i w_i = 1$，$\\sum_i w_i c_{i\\alpha}=0$，$\\sum_i w_i c_{i\\alpha}c_{i\\beta} = c_s^2 \\delta_{\\alpha\\beta}$，以及 $\\sum_i w_i c_{i\\alpha}c_{i\\beta}c_{i\\gamma}c_{i\\delta} = c_s^4 (\\delta_{\\alpha\\beta}\\delta_{\\gamma\\delta} + \\delta_{\\alpha\\gamma}\\delta_{\\beta\\delta} + \\delta_{\\alpha\\delta}\\delta_{\\beta\\gamma})$。对于 $D=2$ 维，二阶恒等式的迹给出 $\\sum_i w_i c_i^2 = \\sum_i w_i c_{i\\alpha}c_{i\\alpha} = \\sum_{\\alpha} c_s^2 \\delta_{\\alpha\\alpha} = D c_s^2 = 2 c_s^2$。\n\n1.  **$\\Delta f_i^{eq}$ 的零阶矩**：\n    $\\sum_i \\Delta f_i^{eq} = \\sum_i w_i K (c_i^2 - C) = K (\\sum_i w_i c_i^2 - C \\sum_i w_i) = K(2c_s^2 - C)$。\n    要使此式对于非平凡的 $K$ 为零，我们必须有 $C = 2c_s^2$。\n\n2.  **$\\Delta f_i^{eq}$ 的一阶矩**：\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha} = \\sum_i w_i K (c_i^2 - 2c_s^2) c_{i\\alpha} = K (\\sum_i w_i c_i^2 c_{i\\alpha} - 2c_s^2 \\sum_i w_i c_{i\\alpha})$。\n    两项都涉及三阶张量，由于格子对称性，它们都为零。因此，此约束自动满足。\n\n3.  **$\\Delta f_i^{eq}$ 的二阶矩**：\n    $\\sum_i \\Delta f_i^{eq} c_{i\\alpha}c_{i\\beta} = K (\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} - 2c_s^2 \\sum_i w_i c_{i\\alpha}c_{i\\beta})$。\n    四阶矩张量为 $\\sum_i w_i c_i^2 c_{i\\alpha}c_{i\\beta} = \\sum_{i, \\gamma} w_i c_{i\\gamma}c_{i\\gamma}c_{i\\alpha}c_{i\\beta} = c_s^4 \\sum_{\\gamma}(\\delta_{\\gamma\\gamma}\\delta_{\\alpha\\beta} + \\delta_{\\gamma\\alpha}\\delta_{\\gamma\\beta} + \\delta_{\\gamma\\beta}\\delta_{\\gamma\\alpha})$。对于 $D=2$，此式计算结果为 $c_s^4 (D\\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta} + \\delta_{\\alpha\\beta}) = (D+2)c_s^4\\delta_{\\alpha\\beta} = 4c_s^4\\delta_{\\alpha\\beta}$。\n    二阶矩变为：$K(4c_s^4\\delta_{\\alpha\\beta} - 2c_s^2(c_s^2\\delta_{\\alpha\\beta})) = 2Kc_s^4\\delta_{\\alpha\\beta}$。\n    将此与目标修正 $(p(\\rho,T) - \\rho c_s^2)\\delta_{\\alpha\\beta}$ 相等，得到：\n    $2Kc_s^4 = p(\\rho,T) - \\rho c_s^2 \\implies K = \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4}$。\n\n因此，修正项为：\n$$\n\\Delta f_i^{eq} = w_i \\frac{p(\\rho,T) - \\rho c_s^2}{2c_s^4} (c_i^2 - 2c_s^2)\n$$\n满足所有三个矩约束的完整平衡分布函数是：\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + \\frac{c_{i\\alpha}u_\\alpha}{c_s^2} + \\frac{(c_{i\\alpha}c_{i\\beta}-c_s^2\\delta_{\\alpha\\beta})u_\\alpha u_\\beta}{2c_s^4}\\right) + \\frac{p(\\rho,T)-\\rho c_s^2}{2 c_s^4}(c_i^2-2c_s^2) \\right)\n$$\n代入 $c_s^2 = 1/3$：\n$$\nf_i^{eq} = w_i \\left( \\rho \\left( 1 + 3(c_i \\cdot u) + \\frac{9}{2}(c_i \\cdot u)^2 - \\frac{3}{2}u^2 \\right) + \\frac{9}{2}(p(\\rho,T)-\\rho/3)(c_i^2-2/3) \\right)\n$$\n其中 $c_i \\cdot u = c_{i\\alpha} u_\\alpha$, $u^2 = u_\\alpha u_\\alpha$, 以及 $c_i^2 = c_{i\\alpha} c_{i\\alpha}$。此表达式是关于速度 $u$ 的二阶多项式，并满足所有指定条件。\n\n该实现为每个测试用例计算此 $f_i^{eq}$，并通过将数值计算出的 $\\{f_i^{eq}\\}$ 的矩与它们精确的目标值进行比较来计算残差 $r_0, r_1, r_2$。由于解析推导的正确性，这些残差应在机器浮点精度范围内为零。\n- 质量残差：$r_0 = \\left(\\sum_{i=0}^8 f_i^{eq}\\right) - \\rho$\n- 动量残差：$r_1 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i\\right) - \\rho u \\right\\|_2$\n- 应力残差：$r_2 = \\left\\| \\left(\\sum_{i=0}^8 f_i^{eq} c_i c_i\\right) - \\left(p(\\rho,T) I + \\rho u u\\right) \\right\\|_F$\n向量使用欧几里得范数，张量使用弗罗贝尼乌斯范数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Derives and verifies a D2Q9 LBM equilibrium distribution for a van der Waals fluid.\n    \"\"\"\n    # Define the D2Q9 lattice constants.\n    c = np.array([\n        [0, 0], [1, 0], [0, 1], [-1, 0], [0, -1],\n        [1, 1], [-1, 1], [-1, -1], [1, -1]\n    ], dtype=np.float64)\n    w = np.array([\n        4/9, 1/9, 1/9, 1/9, 1/9,\n        1/36, 1/36, 1/36, 1/36\n    ], dtype=np.float64)\n    cs2 = 1/3\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (0.8, 0.12, -0.07, 0.5, 0.3, 0.9),\n        (0.01, 0.0001, -0.0002, 0.2, 0.1, 1.0),\n        (3.2, 0.0, 0.0, 0.1, 0.3, 1.2),\n        (1.0, 0.3, 0.4, 1.0, 0.1, 0.6),\n        (0.9, 0.0, 0.0, 0.0, 0.4, 1.5),\n    ]\n\n    results = []\n    for case in test_cases:\n        rho, ux, uy, a, b, T = case\n        u = np.array([ux, uy], dtype=np.float64)\n        R = 1.0\n\n        # Calculate the van der Waals pressure.\n        # Added a check for the denominator to avoid division by zero or negative density.\n        if 1 - b * rho = 0:\n            # For test case 3, rho=3.2, b=0.3 -> 1-b*rho = 1-0.96=0.04. It's positive.\n            # For test case 4, rho=1.0, b=0.1 -> 1-b*rho = 0.9. Positive.\n            # Test case with rho=3.4, b=0.3 would fail. The test cases are safe.\n            p = np.nan\n        else:\n            p = (rho * R * T) / (1 - b * rho) - a * rho**2\n\n        # Initialize the equilibrium distribution array.\n        feq = np.zeros(9, dtype=np.float64)\n\n        # Calculate the equilibrium distribution for each discrete velocity.\n        for i in range(9):\n            ci_dot_u = np.dot(c[i], u)\n            u_sq = np.dot(u, u)\n            ci_sq = np.dot(c[i], c[i])\n            \n            # The standard second-order ideal gas part:\n            # f_ideal = rho * (1 + (ci_dot_u / cs2) + (ci_dot_u**2 / (2 * cs2**2)) - (u_sq / (2 * cs2)))\n            # The non-ideal pressure correction part:\n            # f_corr = (p - rho * cs2) / (2 * cs2**2) * (ci_sq - 2 * cs2)\n            # feq[i] = w[i] * (f_ideal + f_corr)\n\n            # Combined and simplified expression from the derivation:\n            term1 = rho * (1 + 3 * ci_dot_u + 4.5 * ci_dot_u**2 - 1.5 * u_sq)\n            term2 = 4.5 * (p - rho / 3) * (ci_sq - 2/3)\n            feq[i] = w[i] * (term1 + term2)\n\n        # Numerically compute the moments from the calculated feq.\n        rho_num = np.sum(feq)\n        rho_u_num = np.einsum('i,ia-a', feq, c)\n        Pi_num = np.einsum('i,ia,ib-ab', feq, c, c)\n\n        # Define the target macroscopic quantities.\n        rho_target = rho\n        rho_u_target = rho * u\n        Pi_target = p * np.identity(2) + rho * np.outer(u, u)\n\n        # Calculate the residuals.\n        r0 = rho_num - rho_target\n        r1 = np.linalg.norm(rho_u_num - rho_u_target)\n        r2 = np.linalg.norm(Pi_num - Pi_target) # Frobenius norm is default for matrices\n\n        # Append the rounded results to the list.\n        results.append([round(r0, 12), round(r1, 12), round(r2, 12)])\n\n    # Final print statement in the exact required format.\n    # The string representation is crafted to avoid any spaces.\n    results_str = str(results).replace(\" \", \"\")\n    print(results_str)\n\nsolve()\n```", "id": "2407099"}]}