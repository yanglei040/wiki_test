{"hands_on_practices": [{"introduction": "康威的“生命游戏”是元胞自动机最经典的范例之一，它展示了几个简单的规则如何涌现出复杂的、类似生命的行为。第一个练习邀请你在一个小的环形（首尾相连）网格上手动模拟一个经典的“闪烁器”模式。通过追踪每一代中每个细胞的状态，你将直观地理解局部邻域的相互作用如何驱动整个系统的演化，并体会到边界条件在有限系统中的重要性 [@problem_id:1666404]。", "problem": "康威生命游戏（Conway's Game of Life）是一种零玩家游戏，这意味着它的演化完全由其初始状态决定，无需任何进一步的输入。该游戏在一个由方形单元格组成的二维网格上进行，每个单元格可以处于两种可能的状态之一：存活或死亡。每个单元格都与其八个邻居（即水平、垂直或对角相邻的单元格）相互作用。在每个时间步，会发生以下状态转换：\n\n1.  任何存活单元格，如果其存活的邻居少于两个，则会因数量过少而死亡。\n2.  任何存活单元格，如果其有两或三个存活的邻居，则能存活到下一代。\n3.  任何存活单元格，如果其存活的邻居多于三个，则会因数量过多而死亡。\n4.  任何死亡单元格，如果其恰好有三个存活的邻居，则会因繁殖而变为存活单元格。\n\n考虑一个在小型的 $3 \\times 3$ 网格上并遵循这些规则的系统。该网格具有环形边界条件，这意味着网格会自我环绕，使得最右边的列与最左边的列相邻，最上面的行与最下面的行相邻。例如，左上角的单元格的邻居包括来自最下面一行和最右边一列的单元格。\n\n系统在第0代的初始状态是：三个存活单元格在网格的中央行形成一条水平线。所有其他单元格都处于死亡状态。\n\n从第0代开始（并包括第0代）的整个演化过程中，网格在任何单一代所包含的存活单元格的最大数量是多少？", "solution": "设网格由 $(i,j)$ 索引，其中 $i,j \\in \\{0,1,2\\}$，并具有环形边界条件，因此索引对3取模。在第0代，初始的存活单元格集合为\n$$\nS_{0}=\\{(1,0),(1,1),(1,2)\\},\n$$\n即完整的中间行。\n\n对于任意单元格 $(i,j)$，令 $N_{0}(i,j)$ 为其在第0代的存活邻居数量。我们分情况计算 $N_{0}(i,j)$。\n\n1) 对于中间行的存活单元格 $(i,j)=(1,j)$，$j\\in\\{0,1,2\\}$，由于第0行和第2行在第0代是死亡的，所以它们可能存活的邻居必定位于同一行。由于环绕效应，其水平邻居是 $(1,j-1)$ 和 $(1,j+1)$（索引对3取模），这两个单元格都在 $S_{0}$ 中。因此，\n$$\nN_{0}(1,j)=2.\n$$\n根据规则2，每个这样的存活单元格都能存活到下一代。\n\n2) 对于最上面一行的单元格 $(i,j)=(0,j)$，唯一可能存活的邻居位于第1行。其在第1行的邻居是 $(1,j-1)$、$(1,j)$ 和 $(1,j+1)$，所有这些单元格都位于 $S_{0}$ 中。因此，\n$$\nN_{0}(0,j)=3.\n$$\n根据规则4，每个这样的死亡单元格在下一代会变为存活单元格。\n\n3) 对于最下面一行的单元格 $(i,j)=(2,j)$，根据同样的对称性，其在第1行的邻居也是 $(1,j-1)$、$(1,j)$ 和 $(1,j+1)$，所以\n$$\nN_{0}(2,j)=3,\n$$\n每个这样的死亡单元格在下一代也会变为存活单元格。\n\n综合以上结果，$3\\times 3$ 网格中的每个单元格在第1代都变为存活状态，所以\n$$\n|S_{1}|=9.\n$$\n\n现在考虑第1代，此时 $S_{1}$ 是整个 $3\\times 3$ 网格。对于任意单元格，它的全部8个邻居都处于存活状态，因此每个单元格都有8个存活的邻居。由于 $8>3$，适用规则3，每个存活单元格都会死亡。因此，\n$$\nS_{2}=\\varnothing,\n$$\n并且所有后续代都保持为空。\n\n因此，按代数排列的存活单元格数量序列为：3（第0代）、9（第1代）、0（第2代），此后一直为0。从第0代开始（并包括第0代），在任何一代达到的存活单元格的最大数量是\n$$\n9.\n$$", "answer": "$$\\boxed{9}$$", "id": "1666404"}, {"introduction": "在探索了二维系统之后，我们转向一维元胞自动机。尽管结构更简单，它们却能产生惊人的复杂性。这个练习聚焦于著名的“规则90”，其中一个细胞的下一个状态由其两个邻居的异或（XOR）运算决定。你的任务是追踪从单个活动细胞开始生成的模式，这将揭示出它与分形几何之间令人惊奇的美丽联系，并阐释计算系统中“涌现”这一核心原则 [@problem_id:1421609]。", "problem": "在一个简化的线性生物细胞链模式形成模型中，每个细胞可以处于两种状态之一：“激活”（用 1 表示）或“非激活”（用 0 表示）。细胞的状态以离散的时间步（代）演化。在位置 $i$ 和时间 $t+1$ 的细胞状态，记为 $c_i(t+1)$，由其在时间 $t$ 的直接左右邻居的状态决定。更新规则由异或（XOR）运算给出：\n$$c_i(t+1) = c_{i-1}(t) \\oplus c_{i+1}(t)$$\n其中 $a \\oplus b$ 表示 $(a+b) \\pmod 2$。这意味着一个细胞变为激活状态，当且仅当其两个邻居中恰好有一个在上一代是激活的。\n\n考虑一个系统，在第 $t=0$ 代开始时，在一个无限长的、其余细胞均为非激活状态的链上，位置 $i=0$ 处有一个激活细胞。在 $t=0$ 时，所有 $i \\neq 0$ 的细胞都处于非激活状态。\n\n计算从第 $t=0$ 代到第 $t=7$ 代（含）的激活细胞的累计总数。这是从 $t=0$ 到 $t=7$ 每一代激活细胞数量的总和。", "solution": "我们在域 $\\mathbb{F}_{2}$ 上进行计算，因此异或运算是模2加法。更新规则是线性的：\n$$\nc_{i}(t+1)=c_{i-1}(t)+c_{i+1}(t)\\quad\\text{in }\\mathbb{F}_{2}.\n$$\n在初始条件 $c_{0}(0)=1$ 和对所有 $i\\neq 0$ 有 $c_{i}(0)=0$ 的情况下，可以通过对 $t$ 进行数学归纳来证明：\n$$\nc_{i}(t)=\\sum_{k=0}^{t}\\binom{t}{k}\\,c_{i+t-2k}(0)\\quad\\text{in }\\mathbb{F}_{2}.\n$$\n当 $t=0$ 时的基础情况立即成立。对于归纳步骤，\n$$\n\\begin{aligned}\nc_{i}(t+1)=c_{i-1}(t)+c_{i+1}(t)\\\\\n=\\sum_{k=0}^{t}\\binom{t}{k}\\,c_{i-1+t-2k}(0)+\\sum_{k=0}^{t}\\binom{t}{k}\\,c_{i+1+t-2k}(0)\\\\\n=\\sum_{k=0}^{t+1}\\left(\\binom{t}{k}+\\binom{t}{k-1}\\right)c_{i+(t+1)-2k}(0)\\\\\n=\\sum_{k=0}^{t+1}\\binom{t+1}{k}\\,c_{i+(t+1)-2k}(0),\n\\end{aligned}\n$$\n使用约定，当 $k<0$ 或 $k>t$ 时 $\\binom{t}{k}=0$，以及 Pascal 恒等式。因为只有 $c_{0}(0)=1$ 是非零的，上式可简化为\n$$\nc_{i}(t)\\equiv\\begin{cases}\n\\binom{t}{m}\\pmod 2,\\text{若 }m=\\frac{t+i}{2}\\in\\mathbb{Z},\\\\\n0,\\text{其他情况}.\n\\end{cases}\n$$\n因此，在时间 $t$ 的激活细胞数等于 Pascal 三角形第 $t$ 行中奇数二项式系数的个数。根据 Lucas 定理，如果 $t=\\sum_{j\\ge 0}t_{j}2^{j}$，其中 $t_{j}\\in\\{0,1\\}$，那么使得 $\\binom{t}{k}$ 为奇数的 $k$ 的数量为\n$$\n\\prod_{j}(t_{j}+1)=2^{\\sum_{j}t_{j}}=2^{s_{2}(t)},\n$$\n其中 $s_{2}(t)$ 是 $t$ 的二进制展开中 1 的个数。\n\n因此，令 $N(t)$ 表示在时间 $t$ 的激活细胞数，我们有 $N(t)=2^{s_{2}(t)}$。对于 $t=0$ 到 $7$：\n$$\n\\begin{aligned}\nt=0:\\ s_{2}(0)=0\\Rightarrow N(0)=2^{0}=1,\\\\\nt=1:\\ s_{2}(1)=1\\Rightarrow N(1)=2^{1}=2,\\\\\nt=2:\\ s_{2}(2)=1\\Rightarrow N(2)=2^{1}=2,\\\\\nt=3:\\ s_{2}(3)=2\\Rightarrow N(3)=2^{2}=4,\\\\\nt=4:\\ s_{2}(4)=1\\Rightarrow N(4)=2^{1}=2,\\\\\nt=5:\\ s_{2}(5)=2\\Rightarrow N(5)=2^{2}=4,\\\\\nt=6:\\ s_{2}(6)=2\\Rightarrow N(6)=2^{2}=4,\\\\\nt=7:\\ s_{2}(7)=3\\Rightarrow N(7)=2^{3}=8.\n\\end{aligned}\n$$\n从 $t=0$ 到 $t=7$ 的累计总数为\n$$\n\\sum_{t=0}^{7}N(t)=1+2+2+4+2+4+4+8=27.\n$$", "answer": "$$\\boxed{27}$$", "id": "1421609"}, {"introduction": "为了真正利用元胞自动机进行建模和实验，我们必须从手动模拟走向计算机编程实现。这个高级练习将挑战你构建一个一维初等元胞自动机模拟器的核心组件。通过实现用于规则的沃尔夫勒姆编码方案并创建一个更新函数，你将掌握探索广阔的元胞自动机规则空间及其涌现行为所需的基本编程技能 [@problem_id:3104964]。", "problem": "你需要实现一维基本元胞自动机（CA）规则的编码和解码，并通过在具有周期性边界条件的有限格点上模拟更新来验证实现。请从以下定义开始。一个基本元胞自动机是一个动力系统，它拥有一个由 $L$ 个单元组成的一维格点，每个单元在离散时间 $t\\in\\{0,1,2,\\dots\\}$ 具有一个二进制状态 $s_i(t)\\in\\{0,1\\}$。所有单元根据一个局部规则同步更新，该规则依赖于半径为 $1$ 的邻域，即三元组 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$。该规则由一个规则表指定，该表给出了 $2^3=8$ 种邻域中每一种的下一个状态。在 Stephen Wolfram 的编码中，规则表通过将 8 个输出解释为 $R$ 的比特位，映射到一个整数编码 $R\\in\\{0,1,\\dots,255\\}$。设“规则表向量”为一个长度为 8 的列表 $v$，其中 $v[k]\\in\\{0,1\\}$ 等于邻域 $(a,b,c)$ 的输出，该邻域的索引 $k$ 为 $k=4a+2b+c$。该索引按二进制升序从 $k=0$ 处的 $(0,0,0)$ 到 $k=7$ 处的 $(1,1,1)$。Wolfram 的整数编码 $R$ 于是定义为 $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k}.$$ 反之，给定 $R$，可通过读取其二进制展开来恢复规则表向量：$$v[k]=\\left\\lfloor \\frac{R}{2^k}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ 要在长度为 $L$ 且具有周期性边界条件的格点上模拟元胞自动机的一个时间步，对每个索引 $i\\in\\{0,1,\\dots,L-1\\}$，计算邻域 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$（其中索引对 $L$ 取模），形成索引 $k=4s_{i-1}(t)+2s_i(t)+s_{i+1}(t)$，并设置 $s_i(t+1)$ 等于比特位 $v[k]$。等价地，可以直接通过 $R$ 计算该比特位：$$s_i(t+1)=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2.$$ 你的任务是实现与这些定义一致的函数，并为一组测试套件生成指定的输出：\n- 实现一个编码器，将给定的规则表向量 $v$ 映射到整数编码 $R$。\n- 实现一个解码器，将给定的整数编码 $R$ 映射到规则表向量 $v$。\n- 实现一个模拟器，在给定 $R$、一个二进制初始状态 $x^{(0)}\\in\\{0,1\\}^L$ 和一个非负整数步数 $T$ 的情况下，返回在周期性边界条件下最终构型 $x^{(T)}$ 中状态为 $1$ 的单元数量。\n\n为了保证科学真实性，设计必须严格遵循上述定义。不允许使用其他启发式方法。状态更新仅使用整数算术。不涉及角度，也不需要物理单位。\n\n测试套件。你的程序必须为以下参数集计算输出：\n- 情况 A（编码）：$v=[0,1,1,0,1,0,0,1]$。\n- 情况 B（编码）：$v=[1,0,1,0,1,0,1,0]$。\n- 情况 C（解码）：$R=30$。\n- 情况 D（解码）：$R=255$。\n- 情况 E（模拟）：$R=110$，$L=15$，$T=10$，初始状态 $x^{(0)}$ 是在索引 $\\left\\lfloor L/2\\right\\rfloor$ 处为单个 $1$，其余位置为 $0$。\n- 情况 F（模拟，边界边缘情况）：$R=0$，$L=1$，$T=5$，初始状态 $x^{(0)}=[1]$。\n- 情况 G（模拟，零步数）：$R=90$，$L=2$，$T=0$，初始状态 $x^{(0)}=[1,0]$。\n\n要求的输出格式。你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。情况 A 的元素必须是编码后的整数 $R$。情况 B 的元素必须是编码后的整数 $R$。情况 C 和情况 D 的元素必须是解码后的规则表向量 $v$，按索引 $k=0,1,2,3,4,5,6,7$ 的升序排列。情况 E、情况 F 和情况 G 的元素必须是 $x^{(T)}$ 中状态为 $1$ 的单元格的整数计数。因此，最终输出应为一个包含 7 个元素的列表：两个整数、两个长度为 8 的列表和三个整数。", "solution": "解决方案从一维基本元胞自动机（CA）的核心定义、Wolfram 编码映射和同步局部更新规则出发，然后构建直接实现这些原理的算法。\n\n第一性原理和定义。一个基本元胞自动机由一维格点上的二进制状态 $s_i(t)\\in\\{0,1\\}$ 和一个仅依赖于最近邻居和当前单元的确定性局部更新规则指定。在时间 $t$ 位于位置 $i$ 的邻域是 $(s_{i-1}(t),s_i(t),s_{i+1}(t))$。由于每个分量都是二进制的，因此有 $2^3=8$ 种可能的邻域。因此，规则的完整规范是一个规则表，为这 8 种邻域中的每一种分配一个下一状态的输出。Stephen Wolfram 的编码将这 8 个输出映射到一个整数 $R\\in\\{0,1,\\dots,255\\}$ 的比特位，使得 $R$ 的二进制展开对这些输出进行编码。为了确保邻域三元组和比特位之间有精确的映射，我们用 $k=4a+2b+c$ 对邻域进行索引，其中 $(a,b,c)\\in\\{0,1\\}^3$ 被解释为一个二进制数，其中 $a$ 是最高有效位。然后，“规则表向量” $v$ 的长度为 8，其条目 $v[k]\\in\\{0,1\\}$ 等于邻域索引 $k$ 的输出。在此约定下，整数编码为 $$R=\\sum_{k=0}^{7} v[k]\\cdot 2^{k},$$ 逆映射为 $$v[k]=\\left\\lfloor \\frac{R}{2^{k}}\\right\\rfloor \\bmod 2 \\quad\\text{for}\\quad k\\in\\{0,1,2,3,4,5,6,7\\}.$$ 这种双射是整数以 2 为基数的基本表示法的直接结果。\n\n编码的算法设计。给定一个在 $\\{0,1\\}$ 中有 8 个条目的 $v$，使用上述求和公式计算 $R$。在算法层面，从 0 到 7 迭代 $k$ 并累加 $v[k]\\cdot 2^k$。这保证会产生一个在 $\\{0,1,\\dots,255\\}$ 范围内的整数，因为每一项 $v[k]\\cdot 2^k$ 要么是 $0$ 要么是 $2^k$，而不同的 2 的幂次之和会产生一个有效的以 2 为基数的表示。\n\n解码的算法设计。给定一个在 $\\{0,1,\\dots,255\\}$ 范围内的整数 $R$，通过整数除法和取模运算读取位置 $k$ 上的比特位来恢复 $v$：$v[k]=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$。在编程上，可以等效地使用位移和掩码操作，例如 `v[k] = (R >> k)  1`，这与使用标准整数算术的计算完全相同。这将生成一个长度为 8 的列表，其中邻域 $(0,0,0)$ 对应于 $k=0$，而 $(1,1,1)$ 对应于 $k=7$。\n\n模拟的算法设计。对于一个长度为 $L$ 且具有周期性边界条件的格点，邻域索引会环绕，使得 $i-1$ 和 $i+1$ 都对 $L$ 取模。要从 $x^{(t)}$ 计算 $x^{(t+1)}$，对每个位置 $i\\in\\{0,1,\\dots,L-1\\}$ 执行以下操作：\n- 读取 $a=s_{(i-1)\\bmod L}(t)$、$b=s_i(t)$ 和 $c=s_{(i+1)\\bmod L}(t)$。\n- 形成邻域索引 $k=4a+2b+c$。\n- 计算下一状态 $s_i(t+1)=\\left\\lfloor R/2^{k}\\right\\rfloor \\bmod 2$。\n将此过程迭代 $T$ 次以获得 $x^{(T)}$。$x^{(T)}$ 中 1 的计数为 $\\sum_{i=0}^{L-1} s_i(T)$，这是一个在 $\\{0,1,\\dots,L\\}$ 范围内的整数。\n\n测试套件中的覆盖范围和边缘情况。编码测试检验了从已知规则表向量到 $R$ 的映射。对于情况 A，向量 $v=[0,1,1,0,1,0,0,1]$ 对应于三个邻域比特的奇偶性（和对 2 取模），编码产生 $R=150$，因为 150 的二进制展开在位置 $k=1$、$k=2$、$k=4$ 和 $k=7$ 处为 1。对于情况 B，交替向量 $v=[1,0,1,0,1,0,1,0]$ 编码为 $R=85$，因为 85 在偶数比特位置 $k\\in\\{0,2,4,6\\}$ 上为 1。解码测试从给定的 $R$ 重建向量：情况 C 中 $R=30$ 产生的 $v$ 等于 30 在位置 $k=0,1,\\dots,7$ 的比特位，即 $[0,1,1,1,1,0,0,0]$，因为 $30=2+4+8+16$。情况 D 中 $R=255$ 产生全为 1 的向量 $[1,1,1,1,1,1,1,1]$。模拟测试验证了周期性边界条件下的动力学和特殊情况：情况 E 探索了对于 $R=110$，从长度为 $L=15$ 的格点上单个 $1$ 开始，经过 $T=10$ 步后的非平凡增长；情况 F 测试了 $L=1$ 和 $R=0$ 的边界情况，这保证了最终会消亡，因此在任意正步数后最终计数为 0；情况 G 测试了 $T=0$ 的路径，其中最终构型就是初始构型，计数的 1 的数量应等于初始总和，对于 $[1,0]$ 来说即为 1。\n\n最终输出格式。程序将七个结果汇总到一个单行的 Python 风格列表中，元素之间用逗号分隔且无空格，遵循格式要求。这些元素按顺序为：情况 A 和 B 的两个编码整数，情况 C 和 D 的两个解码向量，以及情况 E、F 和 G 模拟后 1 的数量的三个整数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\n\ndef encode_rule(v):\n    \"\"\"\n    Encode an elementary cellular automaton rule table vector into Wolfram's integer code.\n    v: list of 8 integers (0 or 1), where v[k] is the output for neighborhood index k = 4a + 2b + c\n       with (a,b,c) in {0,1}^3 and k ranging from 0 (000) to 7 (111).\n    Returns: integer R in [0,255].\n    \"\"\"\n    if len(v) != 8 or any(x not in (0, 1) for x in v):\n        raise ValueError(\"Rule table vector must be length 8 with binary entries.\")\n    R = 0\n    for k in range(8):\n        R += (v[k]  k)\n    return R\n\ndef decode_rule(R):\n    \"\"\"\n    Decode Wolfram's integer code R into the rule table vector v of length 8.\n    v[k] is the output for neighborhood index k = 4a + 2b + c with (a,b,c) in {0,1}^3.\n    \"\"\"\n    if not (0 = R = 255):\n        raise ValueError(\"Rule code R must be in [0, 255].\")\n    v = [(R >> k)  1 for k in range(8)]\n    return v\n\ndef simulate_rule(R, init_state, steps):\n    \"\"\"\n    Simulate the elementary CA with rule code R on a periodic lattice.\n    R: integer in [0,255]\n    init_state: list of length L with entries 0 or 1\n    steps: nonnegative integer T\n    Returns: integer count of ones in the final state after T steps.\n    \"\"\"\n    L = len(init_state)\n    if L == 0:\n        return 0\n    if steps  0:\n        raise ValueError(\"Steps must be nonnegative.\")\n    # Decode rule once for convenience\n    v = decode_rule(R)\n    # Use a Python list for states\n    curr = init_state[:]\n    if steps == 0:\n        return sum(curr)\n    for _ in range(steps):\n        nxt = [0] * L\n        for i in range(L):\n            a = curr[(i - 1) % L]\n            b = curr[i]\n            c = curr[(i + 1) % L]\n            k = (a  2) | (b  1) | c  # k = 4a + 2b + c\n            nxt[i] = v[k]\n        curr = nxt\n    return sum(curr)\n\ndef format_result(obj):\n    \"\"\"\n    Format the result into a string with no spaces, supporting nested lists.\n    \"\"\"\n    if isinstance(obj, list):\n        return \"[\" + \",\".join(format_result(x) for x in obj) + \"]\"\n    else:\n        return str(obj)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Case A: encode v = [0,1,1,0,1,0,0,1]\n    v_A = [0,1,1,0,1,0,0,1]\n    # Case B: encode v = [1,0,1,0,1,0,1,0]\n    v_B = [1,0,1,0,1,0,1,0]\n    # Case C: decode R = 30\n    R_C = 30\n    # Case D: decode R = 255\n    R_D = 255\n    # Case E: simulate R=110, L=15, T=10, initial single 1 at floor(L/2)\n    R_E = 110\n    L_E = 15\n    T_E = 10\n    init_E = [0] * L_E\n    init_E[L_E // 2] = 1\n    # Case F: simulate R=0, L=1, T=5, init [1]\n    R_F = 0\n    L_F = 1\n    T_F = 5\n    init_F = [1]\n    # Case G: simulate R=90, L=2, T=0, init [1,0]\n    R_G = 90\n    L_G = 2\n    T_G = 0\n    init_G = [1, 0]\n\n    results = []\n    # Case A\n    results.append(encode_rule(v_A))\n    # Case B\n    results.append(encode_rule(v_B))\n    # Case C\n    results.append(decode_rule(R_C))\n    # Case D\n    results.append(decode_rule(R_D))\n    # Case E\n    results.append(simulate_rule(R_E, init_E, T_E))\n    # Case F\n    results.append(simulate_rule(R_F, init_F, T_F))\n    # Case G\n    results.append(simulate_rule(R_G, init_G, T_G))\n\n    # Final print statement in the exact required format (no spaces).\n    print(\"[\" + \",\".join(format_result(r) for r in results) + \"]\")\n\nsolve()\n```", "id": "3104964"}]}