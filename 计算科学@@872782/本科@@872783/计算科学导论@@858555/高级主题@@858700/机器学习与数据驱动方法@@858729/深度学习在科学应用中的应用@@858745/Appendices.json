{"hands_on_practices": [{"introduction": "深度学习中的许多结构并非凭空出现，而是与经典的科学计算方法有着深刻的联系。本练习将揭示一种强大的类比关系：将求解偏微分方程的数值格式看作一个残差网络（ResNet）[@problem_id:3116956]。通过分析一个简单热力学方程的求解过程，你将亲手计算其稳定性边界$K$，从而从数值分析的视角理解残差连接的意义。", "problem": "考虑一个由热传导方程（一种偏微分方程，PDE）控制的一维扩散问题，其具有周期性边界条件。在均匀空间网格上，连续模型为 $u_t = \\alpha u_{xx}$。在一个具有时间步长 $dt$ 和空间网格间距 $dx$ 的标准有限差分显式时间步进格式中，单个求解器步骤可以写成一个离散算子 $\\mathcal{S}$ 应用于状态 $u^n$ 以产生 $u^{n+1} = \\mathcal{S}(u^n)$。在本问题中，您将使用一个残差网络（一个跳跃连接块）来模拟一个求解器步骤 $\\mathcal{S}$，并通过计算一个紧界 $K$ 来评估所得算子的稳定性，该紧界 $K$ 使得不等式 $\\|u^{n+1}\\|_2 \\le K \\|u^n\\|_2$ 对给定网格上的所有输入 $u^n$ 都成立。此处 $\\|\\cdot\\|_2$ 表示欧几里得范数。\n\n基本原理：\n- 有限差分通过局部模板来近似二阶导数。具有周期性边界条件的一维离散拉普拉斯算子使用标准的三点模板。\n- 周期性网格上的线性、移位不变的离散算子是循环的，并且可以由离散傅里叶变换 (DFT) 对角化。由欧几里得范数诱导的算子范数等于该算子在傅里叶基下的特征值的最大模长。\n\n您的任务是：\n- 实现一个残差网络，用于模拟热传导方程在周期性网格上的一个显式欧拉求解器步骤。设残差块为 $\\mathcal{R}(u) = u + f(u)$，其中 $f(u)$ 通过周期性卷积应用离散拉普拉斯算子，并将其乘以 $\\alpha dt$。对拉普拉斯算子使用标准三点模板和循环（周期性）索引。具体来说，对于一个状态向量 $u \\in \\mathbb{R}^N$，定义\n$$\n\\mathrm{Lap}(u)_i = \\frac{u_{i+1} - 2u_i + u_{i-1}}{dx^2},\n$$\n其中使用周期性索引，并设置\n$$\n\\mathcal{R}(u) = u + \\alpha\\, dt\\, \\mathrm{Lap}(u).\n$$\n将 $\\mathcal{R}$ 视为一个残差网络，其残差分支中有一个线性卷积层和一个恒等跳跃连接。\n\n- 利用 $\\mathcal{R}$ 的循环结构，确定最紧的界 $K$，使得对于所有 $u$，都有 $\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$。界 $K$ 必须根据第一性原理，通过对大小为 $N$ 的周期性网格上的循环算子的谱特性进行分析来计算。\n\n- 通过在每个测试用例的一小组随机生成的输入状态 $u$ 上进行检验，来数值验证不等式 $\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$ 是否成立。\n\n单位：\n- 设 $\\alpha$ 为扩散系数，单位为 $\\mathrm{m}^2/\\mathrm{s}$；$dx$ 的单位为 $\\mathrm{m}$；$dt$ 的单位为 $\\mathrm{s}$。界 $K$ 是无量纲的。\n\n不涉及角度单位。不涉及百分比。\n\n测试套件：\n使用以下参数集，每个参数集由 $(N, dx, \\alpha, dt)$ 指定：\n- 案例 1：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.01\\;\\mathrm{s})$。\n- 案例 2：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.50\\;\\mathrm{s})$。\n- 案例 3：$(N=\\;64, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.75\\;\\mathrm{s})$。\n- 案例 4：$(N=\\;65, dx=\\;0.01\\;\\mathrm{m}, \\alpha=\\;10^{-4}\\;\\mathrm{m}^2/\\mathrm{s}, dt=\\;0.75\\;\\mathrm{s})$。\n\n答案规格：\n- 对于每个测试用例，计算给定网格上算子 $\\mathcal{R}$ 的最紧界 $K$。\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的 $K$ 值按上述案例顺序排列并四舍五入到三位小数，例如 $[K_1,K_2,K_3,K_4]$。\n\n覆盖性设计：\n- 案例 1 是理想情况下的稳定区域（小 $dt$）。\n- 案例 2 是一个边界区域。\n- 案例 3 是偶数网格上的不稳定区域。\n- 案例 4 在与案例 3 相同的参数下，探讨了奇数网格尺寸对谱最大值的影响。\n\n所有数值必须由您的程序计算。不允许使用外部输入或文件。输出必须是严格符合指定格式的单行文本。", "solution": "任务是为一个数值算子 $\\mathcal{R}$ 寻找最紧的界 $K$。该算子模拟了求解一维热传导方程 $u_t = \\alpha u_{xx}$ 的显式欧拉法的一个步骤。对于大小为 $N$ 的周期性网格上的任意状态向量 $u \\in \\mathbb{R}^N$，界 $K$ 必须满足不等式 $\\|\\mathcal{R}(u)\\|_2 \\le K \\|u\\|_2$。\n\n算子 $\\mathcal{R}$ 定义为一个残差块：\n$$\n\\mathcal{R}(u) = u + \\alpha \\, dt \\, \\mathrm{Lap}(u)\n$$\n其中 $u$ 是大小为 $N$ 的状态向量，$\\alpha$ 是扩散系数，$dt$ 是时间步长，$\\mathrm{Lap}(u)$ 是离散拉普拉斯算子。在间距为 $dx$ 且具有周期性边界条件的均匀网格上，拉普拉斯算子的第 $i$ 个分量由三点模板给出：\n$$\n(\\mathrm{Lap}(u))_i = \\frac{u_{(i+1) \\pmod N} - 2u_i + u_{(i-1) \\pmod N}}{dx^2}\n$$\n算子 $\\mathcal{R}$ 是线性的，可以表示为矩阵向量乘积 $\\mathcal{R}(u) = A u$，其中 $A$ 是一个 $N \\times N$ 矩阵。定义无量纲参数 $\\gamma$ 为 $\\gamma = \\frac{\\alpha \\, dt}{dx^2}$。矩阵 $A$ 可以写成：\n$$\nA = I + \\gamma L_d\n$$\n其中 $I$ 是 $N \\times N$ 单位矩阵，$L_d$ 是表示周期性网格上模板为 $(1, -2, 1)$ 的未缩放离散拉普拉斯算子的矩阵。由于模板是移位不变的且边界条件是周期性的，因此 $L_d$ 和 $A$ 都是循环矩阵。$A$ 的第一行为 $(1 - 2\\gamma, \\gamma, 0, \\dots, 0, \\gamma)$。\n\n最紧的界 $K$ 是算子的诱导 2-范数，它对应于矩阵 $A$ 的谱范数，记为 $\\|A\\|_2$。对于一个正规矩阵（包括任何循环矩阵），其谱范数等于其谱半径 $\\rho(A)$，定义为其特征值的最大绝对值。\n$$\nK = \\|A\\|_2 = \\rho(A) = \\max_k |\\lambda_k(A)|\n$$\n循环矩阵的特征值 $\\lambda_k$ 由其第一行的离散傅里叶变换 (DFT) 给出。对于第一行为 $(c_0, c_1, \\dots, c_{N-1})$ 的循环矩阵，其特征值为 $\\lambda_k = \\sum_{j=0}^{N-1} c_j e^{-2\\pi i k j / N}$，其中 $k = 0, 1, \\dots, N-1$。\n\n对于矩阵 $A$，其第一行中唯一的非零元素是 $c_0 = 1 - 2\\gamma$、$c_1 = \\gamma$ 和 $c_{N-1} = \\gamma$。其特征值为：\n$$\n\\lambda_k = (1 - 2\\gamma) e^0 + \\gamma e^{-2\\pi i k(1)/N} + \\gamma e^{-2\\pi i k(N-1)/N}\n$$\n利用属性 $e^{-2\\pi i k(N-1)/N} = e^{-2\\pi i k} e^{2\\pi i k/N} = e^{2\\pi i k/N}$，表达式可简化为：\n$$\n\\lambda_k = 1 - 2\\gamma + \\gamma (e^{-2\\pi i k/N} + e^{2\\pi i k/N})\n$$\n应用欧拉公式 $2\\cos\\theta = e^{i\\theta} + e^{-i\\theta}$，我们得到：\n$$\n\\lambda_k = 1 - 2\\gamma + 2\\gamma \\cos\\left(\\frac{2\\pi k}{N}\\right) = 1 + 2\\gamma \\left(\\cos\\left(\\frac{2\\pi k}{N}\\right) - 1\\right)\n$$\n使用三角恒等式 $\\cos(2\\theta) - 1 = -2\\sin^2(\\theta)$，特征值可以写成其最终的实值形式：\n$$\n\\lambda_k = 1 - 4\\gamma \\sin^2\\left(\\frac{\\pi k}{N}\\right), \\quad \\text{for } k = 0, 1, \\dots, N-1\n$$\n界 $K$ 是这些特征值在所有可能的模态数 $k$ 上的绝对值的最大值：\n$$\nK = \\max_{k \\in \\{0, \\dots, N-1\\}} \\left| 1 - 4\\gamma \\sin^2\\left(\\frac{\\pi k}{N}\\right) \\right|\n$$\n设 $S_k = \\sin^2\\left(\\frac{\\pi k}{N}\\right)$。特征值的表达式是 $S_k$ 的一个线性函数。$S_k$ 的取值范围从 $S_0 = 0$ 到最大值 $S_{max} = \\sin^2\\left(\\frac{\\pi \\lfloor N/2 \\rfloor}{N}\\right)$。$|\\lambda_k|$ 的最大值必定出现在 $S_k$ 的其中一个极值点上。\n对于 $k=0$，$S_0=0$ 且 $\\lambda_0 = 1$。对于 $k=\\lfloor N/2 \\rfloor$，$S_k = S_{max}$ 且特征值为 $\\lambda_{ext} = 1 - 4\\gamma S_{max}$。因此，界 $K$ 由这两个特征值绝对值中的较大者决定：\n$$\nK = \\max(|\\lambda_0|, |\\lambda_{\\lfloor N/2 \\rfloor}|) = \\max\\left(1, \\left|1 - 4\\gamma S_{max}\\right|\\right)\n$$\n如果 $K \\le 1$，则该数值格式是稳定的。这种情况发生在 $|1 - 4\\gamma S_{max}| \\le 1$ 时，可简化为此格式著名的 Courant-Friedrichs-Lewy (CFL) 条件：$4\\gamma S_{max} \\le 2$，即 $\\gamma S_{max} \\le 0.5$。\n- 如果 $\\gamma S_{max} \\le 0.5$，则格式是稳定的。表达式 $1 - 4\\gamma S_{max}$ 的值在 $-1$ 和 $1$ 之间，因此其绝对值小于或等于 $1$。在这种情况下，$K=1$。\n- 如果 $\\gamma S_{max} > 0.5$，则格式是不稳定的。表达式 $1 - 4\\gamma S_{max}$ 小于 $-1$。其绝对值为 $|1 - 4\\gamma S_{max}| = 4\\gamma S_{max} - 1$，该值大于 $1$。在这种情况下，$K = 4\\gamma S_{max} - 1$。\n\n对每个测试用例实施此逻辑，以计算相应的界 $K$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the tightest stability bound K for a finite-difference scheme\n    for the Heat Equation, interpreted as a residual network.\n    \"\"\"\n\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (N, dx, alpha, dt)\n    test_cases = [\n        (64, 0.01, 1e-4, 0.01),  # Case 1: Stable\n        (64, 0.01, 1e-4, 0.50),  # Case 2: Boundary of stability\n        (64, 0.01, 1e-4, 0.75),  # Case 3: Unstable on an even grid\n        (65, 0.01, 1e-4, 0.75),  # Case 4: Unstable on an odd grid\n    ]\n\n    results = []\n    for case in test_cases:\n        N, dx, alpha, dt = case\n\n        # The operator is R(u) = u + alpha * dt * Lap(u).\n        # We can write this as R(u) = (I + gamma * L_d) * u,\n        # where gamma = alpha * dt / dx^2 and L_d is the discrete Laplacian matrix.\n        # The eigenvalues of the operator matrix A = I + gamma * L_d are:\n        # lambda_k = 1 - 4 * gamma * sin^2(pi * k / N) for k=0, ..., N-1.\n\n        # The bound K is the spectral radius of A, which is max(|lambda_k|).\n        # Let's compute gamma.\n        gamma = alpha * dt / (dx**2)\n\n        # The maximum of sin^2(pi*k/N) occurs at k = floor(N/2).\n        # This term determines the most negative eigenvalue, which dictates stability.\n        k_for_max_sin = np.floor(N / 2)\n        s_max_sq = np.sin(np.pi * k_for_max_sin / N)**2\n\n        # The eigenvalues are all real. The maximum absolute value is either at\n        # k=0 (lambda_0 = 1) or at k where sin^2 is maximized.\n        # The eigenvalue for the latter case is:\n        lambda_at_s_max = 1 - 4 * gamma * s_max_sq\n        \n        # The bound K is the maximum of |1| and |lambda_at_s_max|.\n        K = np.maximum(1.0, np.abs(lambda_at_s_max))\n\n        # A more direct formula based on stability condition gamma * s_max_sq = 0.5:\n        # if gamma * s_max_sq = 0.5:\n        #     K = 1.0\n        # else:\n        #     # In this case, lambda_at_s_max will be  -1, so its abs value is\n        #     # -(lambda_at_s_max) = 4 * gamma * s_max_sq - 1.\n        #     K = 4 * gamma * s_max_sq - 1\n\n        results.append(K)\n\n    # Format the results for output, rounding to three decimal places.\n    formatted_results = [f\"{res:.3f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3116956"}, {"introduction": "将科学原理融入深度学习模型是确保其预测结果物理真实性的关键。本练习将指导你实践一种核心技术：通过设计一个“物理约束”损失函数，来强制模型遵守已知的数学定律[@problem_id:3116982]。你将为一个累积分布函数（CDF）模型添加一个单调性惩罚项，确保它在学习数据分布的同时，不会违背其导数（概率密度函数）必须为非负的基本属性。", "problem": "您正在将一个累积分布函数（CDF）建模为一个函数 $\\hat{F}_{\\theta}(x)$，该函数使用一个简单的、可微的参数形式，以模仿一个无约束的神经网络。在科学应用中，学习到的CDF必须满足单调性这一基本属性：对于一个实值随机变量 $X$，其累积分布函数（CDF）$F(x) = \\mathbb{P}(X \\le x)$ 是非递减的，并且当其可微时，其导数 $F'(x)$ 等于概率密度函数（PDF）$f(x)$，且满足 $f(x) \\ge 0$。这意味着单调性约束 $F'(x) \\ge 0$ 几乎处处成立。在许多用于科学应用的深度学习架构中，无约束模型可能会违反此单调性，因此我们寻求一种有原则的损失函数来惩罚这种违规行为。\n\n从上述核心定义出发，设计一个包含以下部分的损失函数：\n- 一个在学习到的CDF $\\hat{F}_{\\theta}(x)$ 和从样本数据计算出的经验CDF $\\tilde{F}(x)$ 之间的数据保真项。\n- 一个单调性惩罚项，通过惩罚 $\\hat{F}_{\\theta}(x)$ 在网格上的负离散斜率来强制执行约束 $F'(x) \\ge 0$。\n\n使用以下基础和定义：\n- 对于一个样本 $\\{s_j\\}_{j=1}^m$，经验CDF $\\tilde{F}(x)$ 定义为 $\\tilde{F}(x) = \\frac{1}{m}\\sum_{j=1}^{m} \\mathbf{1}\\{s_j \\le x\\}$。\n- 给定一个网格 $\\{x_i\\}_{i=1}^{n}$，其中 $x_1  x_2  \\cdots  x_n$。定义离散斜率 $D_i = \\frac{\\hat{F}_{\\theta}(x_{i+1}) - \\hat{F}_{\\theta}(x_i)}{x_{i+1} - x_i}$，其中 $i \\in \\{1,\\dots,n-1\\}$。\n- 定义整流线性单元（ReLU）为 $\\operatorname{ReLU}(t) = \\max(0,t)$。\n\n您的任务：\n- 实现一个程序，为每个提供的测试用例计算总损失\n$$\nL(\\theta) = \\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2 \\;+\\; \\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}\\!\\left(-D_i\\right)\\right)^2,\n$$\n其中 $\\lambda$ 是一个非负惩罚权重。\n- 参数化的CDF模型指定为\n$$\n\\hat{F}_{\\theta}(x) = \\sigma\\!\\left(\\alpha \\sin(2\\pi x) + \\beta x + \\gamma\\right),\n$$\n其中 $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ 是logistic S型函数，$\\theta = (\\alpha,\\beta,\\gamma)$ 是实数参数。这种形式有界于 $[0,1]$，但不能保证单调，因此适合用于测试该惩罚项。\n\n算法规格：\n- 通过计算小于或等于 $x_i$ 的样本点比例，直接从给定的样本集计算网格上的 $\\tilde{F}(x_i)$。\n- 按照上述规定计算均方误差项和单调性惩罚项。\n- 不涉及物理单位。\n- 三角函数中的角度必须是弧度。\n- 每个测试用例都指定了 $(\\theta, \\lambda)$、一个网格 $\\{x_i\\}_{i=1}^{n}$ 和一个用于计算 $\\tilde{F}(x)$ 的样本集。\n\n测试套件：\n- 除非另有说明，否则使用在 $[0,1]$ 上均匀分布的网格点 $\\{x_i\\}_{i=1}^{n}$。\n- 情况一（一般单调趋势，理想情况）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$，其中 $i \\in \\{1,\\dots,21\\}$。\n  - 样本集（类均匀分布）：$\\{0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92\\}$。\n  - 参数：$\\alpha = 0.0$, $\\beta = 8.0$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况二（非单调振荡）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集：与情况一相同。\n  - 参数：$\\alpha = 1.0$, $\\beta = 0.5$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况三（具有更强惩罚的局部负斜率）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集（更集中于零附近）：$\\{0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95\\}$。\n  - 参数：$\\alpha = 0.6$, $\\beta = -0.1$, $\\gamma = -0.2$。\n  - 惩罚权重：$\\lambda = 50.0$。\n- 情况四（常数模型，单调性的边界场景）：\n  - 网格：$n = 21$ 个点，$x_i = \\frac{i-1}{20}$。\n  - 样本集：与情况三相同。\n  - 参数：$\\alpha = 0.0$, $\\beta = 0.0$, $\\gamma = 0.0$。\n  - 惩罚权重：$\\lambda = 10.0$。\n- 情况五（最小网格，经验样本中存在重复值）：\n  - 网格：$n = 2$ 个点 $\\{0.0, 1.0\\}$。\n  - 样本集：$\\{0.2, 0.2, 0.2, 0.8, 0.8\\}$。\n  - 参数：$\\alpha = -0.8$, $\\beta = 0.7$, $\\gamma = 0.5$。\n  - 惩罚权重：$\\lambda = 5.0$。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含五个测试用例的结果，结果为逗号分隔的列表，用方括号括起来，并四舍五入到六位小数（例如，$\\left[\\text{result}_1,\\text{result}_2,\\text{result}_3,\\text{result}_4,\\text{result}_5\\right]$）。", "solution": "该问题是有效的。它在科学上基于概率论和数值优化的原理，问题提出得很好，提供了所有必要的信息，并且其表述是客观的。它提出了一个科学机器学习中的标准任务：设计一个损失函数，以在参数模型上强制施加物理或数学约束（累积分布函数的单调性）。\n\n任务是为五个不同的测试用例计算总损失 $L(\\theta)$。损失函数由两部分组成：一个数据保真项和一个单调性惩罚项。\n$$\nL(\\theta) = \\underbrace{\\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2}_{\\text{均方误差 (MSE)}} \\;+\\; \\underbrace{\\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}\\!\\left(-D_i\\right)\\right)^2}_{\\text{单调性惩罚}}\n$$\n我们将为每个测试用例系统地计算每个组成部分。\n\nCDF的参数化模型由 $\\hat{F}_{\\theta}(x) = \\sigma\\!\\left(\\alpha \\sin(2\\pi x) + \\beta x + \\gamma\\right)$ 给出，其中 $\\sigma(z) = \\frac{1}{1 + e^{-z}}$ 是logistic S型函数，$\\theta = (\\alpha, \\beta, \\gamma)$。\n\n每个测试用例的处理过程如下：\n1.  定义点网格 $\\{x_i\\}_{i=1}^{n}$ 和样本集 $\\{s_j\\}_{j=1}^{m}$。\n2.  在每个网格点 $x_i$ 处计算经验CDF的值 $\\tilde{F}(x_i)$。根据定义，$\\tilde{F}(x_i) = \\frac{1}{m}\\sum_{j=1}^{m} \\mathbf{1}\\{s_j \\le x_i\\}$，即小于或等于 $x_i$ 的样本所占的比例。\n3.  使用给定的参数 $\\theta = (\\alpha, \\beta, \\gamma)$，在每个网格点 $x_i$ 处计算参数模型CDF的值 $\\hat{F}_{\\theta}(x_i)$。\n4.  计算MSE项：这是 $\\hat{F}_{\\theta}(x_i)$ 和 $\\tilde{F}(x_i)$ 之间差的平方在所有网格点上的均值。\n$$\n\\text{MSE} = \\frac{1}{n}\\sum_{i=1}^{n}\\left(\\hat{F}_{\\theta}(x_i) - \\tilde{F}(x_i)\\right)^2\n$$\n5.  计算单调性惩罚项：\n    a. 首先，计算离散斜率 $D_i$，其中 $i \\in \\{1, \\dots, n-1\\}$：\n    $$\n    D_i = \\frac{\\hat{F}_{\\theta}(x_{i+1}) - \\hat{F}_{\\theta}(x_i)}{x_{i+1} - x_i}\n    $$\n    b. 接下来，惩罚任何负斜率。每个区间的惩罚是 $\\left(\\operatorname{ReLU}(-D_i)\\right)^2$，其中 $\\operatorname{ReLU}(t) = \\max(0, t)$。仅当 $D_i  0$ 时，此项才非零。\n    c. 总惩罚是所有区间的加权和：\n    $$\n    \\text{Penalty} = \\lambda \\sum_{i=1}^{n-1}\\left(\\operatorname{ReLU}(-D_i)\\right)^2\n    $$\n6.  总损失 $L(\\theta)$ 是MSE和惩罚项之和。\n\n我们现在将此程序应用于每个测试用例。\n\n**情况 1:**\n- 网格：$[0,1]$ 上的 $n=21$ 个点，$x_i = \\frac{i-1}{20}$。\n- 样本集：$m=15$ 个点 $\\{0.05, \\dots, 0.92\\}$。\n- 参数：$\\theta = (\\alpha=0.0, \\beta=8.0, \\gamma=0.0)$。\n- 惩罚权重：$\\lambda = 10.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(8x)$。参数 $8x$ 的导数是 $8 > 0$。由于 $\\sigma$ 是一个严格递增的函数，$\\hat{F}_{\\theta}(x)$ 保证是单调的。因此，所有的离散斜率 $D_i$ 都将是正的。$\\operatorname{ReLU}(-D_i)$ 项对于所有的 $i$ 都将是 $0$，导致单调性惩罚为 $0$。总损失将仅为 $\\sigma(8x_i)$ 和计算出的 $\\tilde{F}(x_i)$ 之间的MSE。\n\n**情况 2:**\n- 网格、样本集和 $\\lambda$ 与情况1相同。\n- 参数：$\\theta = (\\alpha=1.0, \\beta=0.5, \\gamma=0.0)$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(\\sin(2\\pi x) + 0.5x)$。正弦项 $\\sin(2\\pi x)$ 引入了振荡。参数的导数是 $2\\pi \\cos(2\\pi x) + 0.5$，它可能为负（例如，在 $x=0.5$ 附近）。这将导致出现具有负斜率 $D_i$ 的区间，从而产生一个非零的单调性惩罚。总损失将是MSE和此惩罚项之和。\n\n**情况 3:**\n- 网格：$[0,1]$ 上的 $n=21$ 个点。\n- 样本集：$m=12$ 个点 $\\{0.01, \\dots, 0.95\\}$。\n- 参数：$\\theta = (\\alpha=0.6, \\beta=-0.1, \\gamma=-0.2)$。\n- 惩罚权重：$\\lambda = 50.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(0.6\\sin(2\\pi x) - 0.1x - 0.2)$。负系数 $\\beta=-0.1$ 导致了下降趋势，使得负斜率更可能出现且更显著。因此，我们预期会有一个显著的非零单调性惩罚，这个惩罚会被较大的权重 $\\lambda=50.0$ 放大。\n\n**情况 4:**\n- 网格、样本集与情况3相同。\n- 参数：$\\theta = (\\alpha=0.0, \\beta=0.0, \\gamma=0.0)$。\n- 惩罚权重：$\\lambda = 10.0$。\n模型为 $\\hat{F}_{\\theta}(x) = \\sigma(0) = 0.5$。这是一个常数函数。离散斜率 $D_i$ 全部恒等于 $0$。$\\operatorname{ReLU}(-D_i) = \\operatorname{ReLU}(0) = 0$ 项。单调性惩罚将为 $0$。总损失将是常数值 $0.5$ 和经验CDF $\\tilde{F}(x_i)$ 之间的MSE。\n\n**情况 5:**\n- 网格：$n=2$ 个点，$x_1=0.0, x_2=1.0$。\n- 样本集：$m=5$ 个点 $\\{0.2, 0.2, 0.2, 0.8, 0.8\\}$。\n- 参数：$\\theta = (\\alpha=-0.8, \\beta=0.7, \\gamma=0.5)$。\n- 惩罚权重：$\\lambda = 5.0$。\n只有一个区间，从 $x_1=0.0$ 到 $x_2=1.0$。\n经验CDF值为 $\\tilde{F}(0.0) = \\frac{0}{5} = 0.0$ 和 $\\tilde{F}(1.0) = \\frac{5}{5} = 1.0$。\n模型值为 $\\hat{F}_{\\theta}(0.0) = \\sigma(-0.8\\sin(0) + 0.7(0) + 0.5) = \\sigma(0.5)$ 和 $\\hat{F}_{\\theta}(1.0) = \\sigma(-0.8\\sin(2\\pi) + 0.7(1) + 0.5) = \\sigma(1.2)$。\nMSE项是 $\\frac{1}{2}\\left((\\sigma(0.5) - 0.0)^2 + (\\sigma(1.2) - 1.0)^2\\right)$。\n只有一个离散斜率，$D_1 = \\frac{\\hat{F}_{\\theta}(1.0) - \\hat{F}_{\\theta}(0.0)}{1.0-0.0} = \\sigma(1.2) - \\sigma(0.5)$。由于 $\\sigma$ 是递增的且 $1.2 > 0.5$，$D_1$ 是正的。\n因此，$\\operatorname{ReLU}(-D_1) = 0$，单调性惩罚为 $0$。总损失仅为MSE项。\n\n实现将遵循此逻辑处理每个案例，并按规定执行数值计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total loss for a parametric CDF model across five test cases.\n    The loss includes a data fidelity term and a monotonicity penalty.\n    \"\"\"\n\n    test_cases = [\n        # Case one\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92]),\n            \"params\": {\"alpha\": 0.0, \"beta\": 8.0, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case two\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.05, 0.12, 0.18, 0.22, 0.31, 0.37, 0.41, 0.48, 0.53, 0.60, 0.66, 0.74, 0.80, 0.86, 0.92]),\n            \"params\": {\"alpha\": 1.0, \"beta\": 0.5, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case three\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95]),\n            \"params\": {\"alpha\": 0.6, \"beta\": -0.1, \"gamma\": -0.2},\n            \"lambda_val\": 50.0\n        },\n        # Case four\n        {\n            \"grid_n\": 21,\n            \"grid_lims\": (0.0, 1.0),\n            \"samples\": np.array([0.01, 0.03, 0.07, 0.10, 0.14, 0.18, 0.25, 0.35, 0.50, 0.70, 0.85, 0.95]),\n            \"params\": {\"alpha\": 0.0, \"beta\": 0.0, \"gamma\": 0.0},\n            \"lambda_val\": 10.0\n        },\n        # Case five\n        {\n            \"grid_points\": np.array([0.0, 1.0]),\n            \"samples\": np.array([0.2, 0.2, 0.2, 0.8, 0.8]),\n            \"params\": {\"alpha\": -0.8, \"beta\": 0.7, \"gamma\": 0.5},\n            \"lambda_val\": 5.0\n        }\n    ]\n\n    results = []\n    \n    # Define helper functions based on the problem statement\n    def sigmoid(z):\n        return 1.0 / (1.0 + np.exp(-z))\n\n    def f_hat(x, alpha, beta, gamma):\n        z = alpha * np.sin(2.0 * np.pi * x) + beta * x + gamma\n        return sigmoid(z)\n\n    def relu(t):\n        return np.maximum(0, t)\n\n    for case in test_cases:\n        # Step 1: Define grid and samples\n        if \"grid_points\" in case:\n            x_grid = case[\"grid_points\"]\n        else:\n            x_grid = np.linspace(case[\"grid_lims\"][0], case[\"grid_lims\"][1], case[\"grid_n\"])\n        \n        samples = case[\"samples\"]\n        n = len(x_grid)\n        m = len(samples)\n        \n        params = case[\"params\"]\n        alpha, beta, gamma = params[\"alpha\"], params[\"beta\"], params[\"gamma\"]\n        lambda_val = case[\"lambda_val\"]\n\n        # Step 2: Compute empirical CDF F_tilde\n        # For each x_i in x_grid, count how many samples are = x_i\n        f_tilde_values = np.sum(samples = x_grid[:, np.newaxis], axis=1) / m\n        \n        # Step 3: Compute parametric CDF F_hat\n        f_hat_values = f_hat(x_grid, alpha, beta, gamma)\n\n        # Step 4: Calculate the MSE term\n        mse_term = np.mean((f_hat_values - f_tilde_values)**2)\n\n        # Step 5: Calculate the monotonicity penalty term\n        # a. Compute discrete slopes D_i\n        if n > 1:\n            delta_f_hat = np.diff(f_hat_values)\n            delta_x = np.diff(x_grid)\n            # Avoid division by zero, though not expected in these cases\n            # A small tolerance epsilon could be added for robustness\n            discrete_slopes = delta_f_hat / delta_x\n            \n            # b. Apply ReLU to negative slopes and square\n            penalty_per_interval = relu(-discrete_slopes)**2\n            \n            # c. Sum and weight by lambda\n            monotonicity_penalty = lambda_val * np.sum(penalty_per_interval)\n        else:\n            monotonicity_penalty = 0.0\n\n        # Step 6: Compute total loss\n        total_loss = mse_term + monotonicity_penalty\n        results.append(total_loss)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join([f'{r:.6f}' for r in results])}]\")\n\nsolve()\n```", "id": "3116982"}, {"introduction": "更高级的物理约束是将其直接构建到模型的架构中，从而确保模型天生就遵守某些对称性。本练习将带你进入几何深度学习的前沿，探索如何构建一个旋转等变（equivariant）的神经网络，用于预测分子的物理性质[@problem_id:3117017]。你将通过实现一个消息传递机制来理解，如何让模型的中间特征随分子旋转而相应旋转，并最终输出一个在任何旋转下都保持不变的标量（如能量），从而硬性编码了物理定律的旋转不变性。", "problem": "要求您设计并实现一个最小化的、旋转等变的消息传递方案，该方案能为分子构型生成一个旋转不变的标量预测值。目标是编码这样一条科学要求：像能量这样的标量可观测量，在三维特殊正交群（SO）的任何旋转下都保持不变，记作 $\\mathrm{SO}(3)$。\n\n从基本定义开始，一个旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 满足 $\\mathbf{R}^\\top \\mathbf{R} = \\mathbf{I}$ 且 $\\det(\\mathbf{R}) = 1$。一个标量物理属性（如能量 $E$）必须对所有 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 满足 $E(\\mathbf{R}\\mathbf{r}) = E(\\mathbf{r})$，其中 $\\mathbf{r} = (\\mathbf{r}_1,\\dots,\\mathbf{r}_N)$ 是 $\\mathbb{R}^3$ 中的原子坐标。\n\n您将实现一个单层等变消息传递机制和一个能产生不变的类能量标量的读出（readout）机制。程序必须遵循以下规范：\n\n1) 输入表示。一个分子是一组包含 $N$ 个原子的集合，每个原子具有位置 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 和整数类型 $Z_i \\in \\mathbb{Z}_{\\ge 1}$（使用原子序数）。定义成对相对向量 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$、距离 $d_{ij} = \\|\\mathbf{r}_{ij}\\|_2$ 和单位方向 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij}/d_{ij}$。为避免除以零，如果 $d_{ij} \\le \\delta$（其中 $\\delta  0$ 是一个非常小的数），则按约定设置 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{0}$。\n\n2) 消息传递（向量值，旋转等变）。定义一个与距离和类型相关的标量系数\n$$\ns_{ij} = \\exp(-\\beta\\, d_{ij})\\left(a_0 + a_1 Z_i + a_2 Z_j + a_3 Z_i Z_j\\right),\n$$\n并计算一个节点级向量消息\n$$\n\\mathbf{m}_i = \\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}.\n$$\n这里的 $\\beta, a_0, a_1, a_2, a_3$ 是固定的实数常量。\n\n3) 不变读出（标量类能量预测）。定义一个逐节点标量\n$$\ne_i = c_1 \\|\\mathbf{m}_i\\|_2^2 + c_2 \\sum_{j \\ne i} \\exp(-\\gamma\\, d_{ij}),\n$$\n以及总预测值\n$$\nE(\\mathbf{r}, \\mathbf{Z}) = \\sum_{i=1}^N e_i + c_3 \\sum_{i=1}^N Z_i,\n$$\n其中 $c_1, c_2, c_3, \\gamma$ 是固定的实数常量。\n\n4) 等变性/不变性要求。消息 $\\mathbf{m}_i$ 在 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 变换下必须像向量一样变换，而最终的 $E(\\mathbf{r}, \\mathbf{Z})$ 必须满足 $E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z}) = E(\\mathbf{r}, \\mathbf{Z})$。\n\n5) 旋转生成。使用罗德里格斯公式从给定的轴-角 $(\\hat{\\mathbf{a}}, \\theta)$ 构建 $\\mathbf{R}$\n$$\n\\mathbf{R} = \\cos\\theta\\, \\mathbf{I} + \\sin\\theta\\, [\\hat{\\mathbf{a}}]_\\times + (1-\\cos\\theta)\\, \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^\\top,\n$$\n其中 $[\\hat{\\mathbf{a}}]_\\times$ 是单位轴 $\\hat{\\mathbf{a}}$ 的斜对称矩阵，$\\theta$ 是以弧度为单位的角度。\n\n程序中使用的常量：\n- $\\delta = 10^{-12}$,\n- $a_0 = 0.5$, $a_1 = 0.1$, $a_2 = -0.05$, $a_3 = 0.02$,\n- $\\beta = 1.3$, $\\gamma = 0.9$,\n- $c_1 = 0.7$, $c_2 = 0.2$, $c_3 = 0.05$.\n\n相等性的数值容差：\n- 如果 $|x-y| \\le \\tau$ 且 $\\tau = 10^{-10}$，则认为两个浮点预测值 $x$ 和 $y$ 相等。\n\n角度单位：\n- 所有角度 $\\theta$ 均以弧度为单位。\n\n测试套件。您的程序必须硬编码以下四个测试用例，每个用例包含位置 $\\mathbf{r}$（以任何一致的长度单位）、整数类型 $\\mathbf{Z}$ 和一个旋转轴-角 $(\\hat{\\mathbf{a}}, \\theta)$：\n\n- 用例 1（一般情况，非退化三角形）：$\\mathbf{Z} = [8, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (0.9572, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (-0.2399872, 0.927297, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} \\propto (1.0, 2.0, 3.0)$ 归一化为单位长度，角度 $\\theta = 1.234$。\n\n- 用例 2（线性三原子分子，180° 旋转）：$\\mathbf{Z} = [6, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (1.1, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (-1.1, 0.0, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 0.0, 1.0)$，角度 $\\theta = \\pi$。\n\n- 用例 3（单个原子）：$\\mathbf{Z} = [8]$，位置\n  $$\n  \\mathbf{r}_1 = (1.0, 2.0, 3.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 0.0, 1.0)$，角度 $\\theta = 0.7$。\n\n- 用例 4（退化情况，重合位置以压力测试 $\\delta$ 的处理）：$\\mathbf{Z} = [1, 1, 1]$，位置\n  $$\n  \\mathbf{r}_1 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_2 = (0.0, 0.0, 0.0),\\;\n  \\mathbf{r}_3 = (0.0, 0.0, 0.0),\n  $$\n  旋转轴 $\\hat{\\mathbf{a}} = (0.0, 1.0, 0.0)$，角度 $\\theta = 2.2$。\n\n对于每个用例，计算 $E(\\mathbf{r}, \\mathbf{Z})$ 和 $E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z})$，然后使用容差 $\\tau$ 对它们进行比较。预期的输出是每个用例对应的一个布尔值，表示旋转不变性是否在容差范围内成立。\n\n最终输出格式。您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表，例如\n$[b_1,b_2,b_3,b_4]$\n其中每个 $b_k$ 是用例 $k$ 的布尔值。", "solution": "该问题要求设计并验证一个用于计算标量分子属性的计算模型，该模型通过其构造，在三维旋转下保持不变。这是物理学启发的机器学习中的一个基本概念，将已知的物理对称性融入模型架构中可以提高其准确性、数据效率和泛化能力。我们关注的对称群是三维特殊正交群 $\\mathrm{SO}(3)$，它代表了所有正常旋转。\n\n如果对于任意旋转矩阵 $\\mathbf{R} \\in \\mathrm{SO}(3)$ 和任意原子位置构型 $\\mathbf{r} = (\\mathbf{r}_1, \\dots, \\mathbf{r}_N)$，标量属性 $E$ 始终保持不变：$E(\\mathbf{R}\\mathbf{r}, \\mathbf{Z}) = E(\\mathbf{r}, \\mathbf{Z})$，则称该属性为旋转不变的，其中 $\\mathbf{Z}$ 代表不变的原子类型。我们将通过分析每个组件的变换属性来证明所规定的模型架构保证了这种不变性。\n\n该设计依赖于等变性（equivariance）和不变性（invariance）的概念。一个向量值函数 $f(\\mathbf{x})$ 如果满足 $f(\\mathbf{R}\\mathbf{x}) = \\mathbf{R}f(\\mathbf{x})$，则称其是等变的，这意味着其输出像向量一样变换。一个标量值函数 $g(\\mathbf{x})$ 如果满足 $g(\\mathbf{R}\\mathbf{x}) = g(\\mathbf{x})$，则称其是不变的。该模型由一系列保持这些属性的操作构建而成。\n\n**1. 输入特征及其变换属性**\n\n该模型始于从原子位置 $\\mathbf{r}_i \\in \\mathbb{R}^3$ 导出的基本几何量。在旋转 $\\mathbf{R}$ 的作用下，位置向量变换为 $\\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_i$。\n\n- **相对位置向量**：对于任意一对原子 $i$ 和 $j$，其相对位置向量为 $\\mathbf{r}_{ij} = \\mathbf{r}_j - \\mathbf{r}_i$。这些向量是等变的，因为 $\\mathbf{r}'_{ij} = \\mathbf{r}'_j - \\mathbf{r}'_i = \\mathbf{R}\\mathbf{r}_j - \\mathbf{R}\\mathbf{r}_i = \\mathbf{R}(\\mathbf{r}_j - \\mathbf{r}_i) = \\mathbf{R}\\mathbf{r}_{ij}$。\n\n- **成对距离**：距离 $d_{ij} = \\|\\mathbf{r}_{ij}\\|_2$ 是欧几里得范数。由于旋转是等距变换（保持长度不变），距离是不变的：$d'_{ij} = \\|\\mathbf{r}'_{ij}\\|_2 = \\|\\mathbf{R}\\mathbf{r}_{ij}\\|_2 = \\|\\mathbf{r}_{ij}\\|_2 = d_{ij}$。\n\n- **单位方向向量**：定义为 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{r}_{ij} / d_{ij}$（对于 $d_{ij} > \\delta$），这些向量是等变的：$\\hat{\\mathbf{r}}'_{ij} = \\mathbf{r}'_{ij} / d'_{ij} = (\\mathbf{R}\\mathbf{r}_{ij}) / d_{ij} = \\mathbf{R}(\\mathbf{r}_{ij} / d_{ij}) = \\mathbf{R}\\hat{\\mathbf{r}}_{ij}$。当 $d_{ij} \\le \\delta$ 的特殊情况下，设置 $\\hat{\\mathbf{r}}_{ij} = \\mathbf{0}$，这是旋转的一个不动点（$\\mathbf{R}\\mathbf{0} = \\mathbf{0}$）。\n\n原子类型 $Z_i$ 是不依赖于位置的标量，因此是内在地不变的。\n\n**2. 等变消息传递**\n\n该模型通过一个消息传递机制为每个原子 $i$ 计算一个中间向量表示 $\\mathbf{m}_i$。此阶段被设计为等变的。\n\n- **不变的消息系数 ($s_{ij}$)**：原子 $i$ 和 $j$ 之间相互作用的强度由一个标量系数 $s_{ij} = \\exp(-\\beta\\, d_{ij})\\left(a_0 + a_1 Z_i + a_2 Z_j + a_3 Z_i Z_j\\right)$ 调节。该系数仅是不变量（$d_{ij}$, $Z_i$, $Z_j$）和固定常量（$a_k$, $\\beta$）的函数，这使得 $s_{ij}$ 本身也是一个不变标量。\n\n- **等变向量消息 ($\\mathbf{m}_i$)**：原子 $i$ 的消息是所有指向其邻居的等变方向向量的加权和：\n$$\n\\mathbf{m}_i = \\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}\n$$\n由于这是等变向量 ($\\hat{\\mathbf{r}}_{ij}$) 与不变标量权重 ($s_{ij}$) 的线性组合，因此得到的向量 $\\mathbf{m}_i$ 也是等变的。它在旋转下的变换为：\n$$\n\\mathbf{m}'_i = \\sum_{j \\ne i} s'_{ij}\\, \\hat{\\mathbf{r}}'_{ij} = \\sum_{j \\ne i} s_{ij}\\, (\\mathbf{R}\\hat{\\mathbf{r}}_{ij}) = \\mathbf{R} \\left(\\sum_{j \\ne i} s_{ij}\\, \\hat{\\mathbf{r}}_{ij}\\right) = \\mathbf{R}\\mathbf{m}_i\n$$\n\n**3. 不变读出与总预测**\n\n最后阶段将等变向量集合 $\\{\\mathbf{m}_i\\}$ 映射到一个单一的、总的不变标量 $E$。\n\n- **逐节点不变标量 ($e_i$)**：首先为每个节点计算一个不变标量。\n$$\ne_i = c_1 \\|\\mathbf{m}_i\\|_2^2 + c_2 \\sum_{j \\ne i} \\exp(-\\gamma\\, d_{ij})\n$$\n项 $\\|\\mathbf{m}_i\\|_2^2$ 是等变向量 $\\mathbf{m}_i$ 的范数的平方。一个等变向量的范数总是不变的，因为 $\\|\\mathbf{R}\\mathbf{v}\\|_2^2 = (\\mathbf{R}\\mathbf{v})^\\top(\\mathbf{R}\\mathbf{v}) = \\mathbf{v}^\\top\\mathbf{R}^\\top\\mathbf{R}\\mathbf{v} = \\mathbf{v}^\\top\\mathbf{I}\\mathbf{v} = \\|\\mathbf{v}\\|_2^2$。第二项是不变距离 $d_{ij}$ 的函数之和，因此也是不变的。因此，作为不变项的线性组合，$e_i$ 是不变的。\n\n- **总不变预测 ($E$)**：最终的预测是这些逐节点不变量和一个不变的原子类型贡献项的总和。\n$$\nE(\\mathbf{r}, \\mathbf{Z}) = \\sum_{i=1}^N e_i + c_3 \\sum_{i=1}^N Z_i\n$$\n作为不变量的总和，总预测值 $E$ 保证是旋转不变的，从而满足了问题的核心要求。\n\n**4. 实现与验证**\n\n该算法使用 `numpy` 进行数值计算。旋转矩阵 $\\mathbf{R}$ 通过罗德里格斯公式从指定的轴-角对 $(\\hat{\\mathbf{a}}, \\theta)$ 生成：$\\mathbf{R} = \\cos\\theta\\, \\mathbf{I} + \\sin\\theta\\, [\\hat{\\mathbf{a}}]_\\times + (1-\\cos\\theta)\\, \\hat{\\mathbf{a}}\\hat{\\mathbf{a}}^\\top$，其中 $[\\hat{\\mathbf{a}}]_\\times$ 是对应于与 $\\hat{\\mathbf{a}}$ 进行叉积运算的斜对称矩阵。将该逻辑应用于提供的测试用例，以数值方式确认，在定义的容差 $\\tau = 10^{-10}$ 内，为原始原子坐标和旋转后原子坐标计算出的 $E$ 值是相同的。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Implements and verifies a rotation-invariant scalar prediction for molecular configurations.\n    \"\"\"\n    # Define constants from the problem statement.\n    DELTA = 1e-12\n    A0, A1, A2, A3 = 0.5, 0.1, -0.05, 0.02\n    BETA = 1.3\n    GAMMA = 0.9\n    C1, C2, C3 = 0.7, 0.2, 0.05\n    TOLERANCE_TAU = 1e-10\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        {\n            \"Z\": np.array([8, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.9572, 0.0, 0.0],\n                [-0.2399872, 0.927297, 0.0]\n            ]),\n            \"a\": np.array([1.0, 2.0, 3.0]),\n            \"theta\": 1.234\n        },\n        {\n            \"Z\": np.array([6, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [1.1, 0.0, 0.0],\n                [-1.1, 0.0, 0.0]\n            ]),\n            \"a\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": np.pi\n        },\n        {\n            \"Z\": np.array([8], dtype=int),\n            \"r\": np.array([\n                [1.0, 2.0, 3.0]\n            ]),\n            \"a\": np.array([0.0, 0.0, 1.0]),\n            \"theta\": 0.7\n        },\n        {\n            \"Z\": np.array([1, 1, 1], dtype=int),\n            \"r\": np.array([\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0],\n                [0.0, 0.0, 0.0]\n            ]),\n            \"a\": np.array([0.0, 1.0, 0.0]),\n            \"theta\": 2.2\n        }\n    ]\n    \n    def compute_E(positions, types):\n        \"\"\"\n        Computes the total scalar prediction E for a given molecular configuration.\n        \"\"\"\n        num_atoms = len(types)\n        \n        # Handle single-atom and empty cases.\n        if num_atoms = 1:\n            return C3 * np.sum(types)\n\n        total_e_sum = 0.0\n        for i in range(num_atoms):\n            m_i = np.zeros(3)\n            e_i_dist_term = 0.0\n            \n            for j in range(num_atoms):\n                if i == j:\n                    continue\n                \n                # Calculate relative vector, distance, and unit vector\n                r_ij = positions[j] - positions[i]\n                d_ij = np.linalg.norm(r_ij)\n                \n                if d_ij = DELTA:\n                    r_hat_ij = np.zeros(3)\n                else:\n                    r_hat_ij = r_ij / d_ij\n                \n                # Calculate scalar coefficient s_ij\n                s_ij = np.exp(-BETA * d_ij) * (A0 + A1 * types[i] + A2 * types[j] + A3 * types[i] * types[j])\n                \n                # Update message vector m_i\n                m_i += s_ij * r_hat_ij\n                \n                # Update distance-dependent term for e_i\n                e_i_dist_term += np.exp(-GAMMA * d_ij)\n            \n            # Calculate per-node scalar e_i\n            m_i_norm_sq = np.dot(m_i, m_i) # More efficient than np.linalg.norm()**2\n            e_i = C1 * m_i_norm_sq + C2 * e_i_dist_term\n            total_e_sum += e_i\n            \n        # Calculate total prediction E\n        total_E = total_e_sum + C3 * np.sum(types)\n        return total_E\n\n    results = []\n    for case in test_cases:\n        Z, r, a, theta = case[\"Z\"], case[\"r\"], case[\"a\"], case[\"theta\"]\n        \n        # 1. Compute E for the original configuration\n        E_original = compute_E(r, Z)\n        \n        # 2. Generate the rotation matrix R using Rodrigues' formula\n        a_norm = np.linalg.norm(a)\n        if a_norm  DELTA: # Handles zero vector for axis\n             a_hat = np.zeros(3)\n        else:\n             a_hat = a / a_norm\n        \n        I = np.identity(3)\n        a_cross_matrix = np.array([\n            [0, -a_hat[2], a_hat[1]],\n            [a_hat[2], 0, -a_hat[0]],\n            [-a_hat[1], a_hat[0], 0]\n        ])\n        a_outer_product = np.outer(a_hat, a_hat)\n        \n        R = np.cos(theta) * I + np.sin(theta) * a_cross_matrix + (1 - np.cos(theta)) * a_outer_product\n\n        # 3. Apply rotation to coordinates\n        # r is (N, 3). R is (3, 3). We need (r @ R.T) or (R @ r.T).T\n        r_rotated = r @ R.T\n\n        # 4. Compute E for the rotated configuration\n        E_rotated = compute_E(r_rotated, Z)\n        \n        # 5. Check for invariance within the given tolerance\n        is_invariant = np.abs(E_original - E_rotated) = TOLERANCE_TAU\n        results.append(is_invariant)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3117017"}]}