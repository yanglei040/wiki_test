{"hands_on_practices": [{"introduction": "在并行计算中，我们面临的首要决策之一是如何分布数据。对于大型数据集，由于内存限制，将所有数据复制到每个计算节点上往往是不可行的。本练习 [@problem_id:3191832] 提供了一个实际场景，您将计算内存需求，从而在数据复制和分片之间做出选择，并量化数据分片带来的必要通信开销。", "problem": "一位计算科学家正在评估在一个集群上处理单个大型一维数组的两种并行化策略：在每个节点上复制整个数组，以及将数组分片到各个节点并使用最近邻的幽灵单元。目标是确定复制策略是否可行，如果不可行，则确定在分片策略下需要多少节点才能满足每个节点的内存限制，并量化每次迭代中幽灵单元交换的通信时间。\n\n使用的基本定义和事实：\n- 在共享内存设计中，所有线程都可以访问一个单一的内存地址空间，而在分布式内存设计中，每个进程都拥有私有内存，任何非本地可用的数据都必须通过通信获得。\n- 在分布式内存设置下的复制策略中，每个节点在本地存储整个数组，因此每个节点的内存占用等于整个数组的大小。\n- 在跨 $p$ 个节点进行一维块分解的分片策略下，每个节点存储其本地数据块以及用于两个邻居（左和右）的幽灵单元。如果每个边界需要 $g$ 个幽灵元素，那么每个节点除了其本地数据块外，还额外存储 $2g$ 个元素。\n- 在一个仅考虑带宽的通信模型中（忽略延迟），通信时间与移动的字节数成正比：$T = \\beta \\times B$，其中 $B$ 是传输的总字节数，$\\beta$ 是每字节秒数的系数。\n\n给定数据：\n- 数组长度为 $A = 6.0 \\times 10^{9}$ 个元素。\n- 每个元素大小为 $s = 8$ 字节。\n- 每个节点的随机存取存储器（RAM）为 $M = 24 \\times 10^{9}$ 字节。\n- 每个节点每次迭代需要为每个邻居（共两个邻居）准备 $g = 5.0 \\times 10^{6}$ 个幽灵元素。\n- 带宽模型的比例系数为 $\\beta = 2.5 \\times 10^{-10}$ 秒/字节。\n\n任务：\n1. 通过将整个数组的大小与每个节点的内存 $M$ 进行比较，判断复制策略是否可行。\n2. 如果复制策略不可行，确定最小整数 $p$，使得分片布局（同时考虑本地数据块和幽灵单元）能够放入单个节点的内存中。\n3. 使用仅考虑带宽的模型，计算每次迭代中每个节点与两个邻居交换幽灵单元的通信时间（仅计算发送；假设对称交换，并忽略延迟）。以秒为单位表示时间。\n\n将通信时间四舍五入到四位有效数字。按顺序报告你的最终答案，包含两个值：最小的 $p$ 和每个节点的幽灵单元交换时间（以秒为单位）。", "solution": "首先根据所需标准对问题陈述进行验证。\n\n### 步骤1：提取给定信息\n- 数组长度：$A = 6.0 \\times 10^{9}$ 个元素\n- 每个元素的大小：$s = 8$ 字节\n- 每个节点的RAM：$M = 24 \\times 10^{9}$ 字节\n- 每个邻居的幽灵元素数量：$g = 5.0 \\times 10^{6}$ 个元素\n- 幽灵单元交换的邻居数量：$2$\n- 带宽模型系数：$\\beta = 2.5 \\times 10^{-10}$ 秒/字节\n\n### 步骤2：使用提取的给定信息进行验证\n- **科学依据**：问题使用了高性能和并行计算中的标准概念，包括内存限制、域分解（分片）、用于边界数据交换的幽灵单元，以及简化的仅带宽通信模型。这些是计算科学中基本且成熟的原则。所提供的数值很大，但对于现代高性能计算集群是合理的。\n- **提法明确**：问题的结构清晰，包含一组明确的任务，这些任务导向一个唯一的、可量化的解。提供了所有必要的数据。\n- **客观性**：问题以精确、定量的术语陈述，没有任何主观或模糊的语言。\n\n### 步骤3：结论与行动\n该问题是有效的，因为它有科学依据、提法明确、客观，并包含足够的信息以得到唯一解。我将继续进行完整解答。\n\n### 任务1：复制策略的可行性\n首先，我们确定在每个节点上复制整个数组是否是一个可行的策略。这需要将数组的总大小与单个节点上的可用内存进行比较。\n\n数组的总大小 $S_{total}$ 是元素数量 $A$ 与每个元素大小 $s$ 的乘积。\n$$S_{total} = A \\times s$$\n代入给定值：\n$$S_{total} = (6.0 \\times 10^{9} \\text{ elements}) \\times (8 \\text{ bytes/element}) = 48 \\times 10^{9} \\text{ bytes}$$\n\n每个节点的可用内存为 $M = 24 \\times 10^{9}$ 字节。\n我们将 $S_{total}$ 与 $M$ 进行比较：\n$$48 \\times 10^{9} \\text{ bytes} > 24 \\times 10^{9} \\text{ bytes}$$\n由于数组总大小 $S_{total}$ 大于每个节点的内存 $M$，因此在每个节点上复制整个数组是不可行的。\n\n### 任务2：分片策略所需的最少节点数\n由于复制策略不可行，我们必须使用分片（域分解）策略。我们需要找到最少的节点数 $p$，使得每个节点上的数组部分（包括幽灵单元）能够放入节点的内存 $M$ 中。\n\n对于一个跨 $p$ 个节点分片的一维数组，每个节点存储一个大小为 $A/p$ 个元素的本地数据块。此外，每个节点还为它的两个邻居（左和右）存储幽灵单元。问题陈述中指出每个边界需要 $g$ 个幽灵元素。因此，每个节点必须额外存储 $2g$ 个元素。\n\n单个节点上存储的总元素数 $N_p$ 是其本地数据块和幽灵单元的总和：\n$$N_p = \\frac{A}{p} + 2g$$\n\n每个节点的总内存占用 $M_p$ 是元素数量 $N_p$ 乘以每个元素的大小 $s$：\n$$M_p = \\left(\\frac{A}{p} + 2g\\right) \\times s$$\n\n为了使这种布局可行，每个节点的内存占用 $M_p$ 必须小于或等于每个节点的可用内存 $M$：\n$$M_p \\leq M$$\n$$\\left(\\frac{A}{p} + 2g\\right) \\times s \\leq M$$\n\n我们对这个不等式求解 $p$：\n$$\\frac{A}{p} + 2g \\leq \\frac{M}{s}$$\n$$\\frac{A}{p} \\leq \\frac{M}{s} - 2g$$\n$$p \\geq \\frac{A}{\\frac{M}{s} - 2g}$$\n\n现在，我们代入给定值：\n$A = 6.0 \\times 10^{9}$\n$M = 24 \\times 10^{9}$\n$s = 8$\n$g = 5.0 \\times 10^{6}$\n\n首先，计算分母中的项：\n$$\\frac{M}{s} - 2g = \\frac{24 \\times 10^{9}}{8} - 2 \\times (5.0 \\times 10^{6})$$\n$$\\frac{M}{s} - 2g = 3.0 \\times 10^{9} - 1.0 \\times 10^{7}$$\n$$\\frac{M}{s} - 2g = 300 \\times 10^{7} - 1.0 \\times 10^{7} = 299 \\times 10^{7} = 2.99 \\times 10^{9}$$\n\n现在，将此结果代回关于 $p$ 的不等式中：\n$$p \\geq \\frac{6.0 \\times 10^{9}}{2.99 \\times 10^{9}}$$\n$$p \\geq \\frac{6.0}{2.99} \\approx 2.00668896...$$\n\n由于节点数 $p$ 必须是一个整数，$p$ 的最小值是满足此条件的最小整数，即 $2.00668896...$ 的上取整。\n$$p_{min} = 3$$\n\n### 任务3：每个节点的通信时间\n每次迭代的通信时间 $T$ 使用仅带宽模型 $T = \\beta \\times B$ 计算，其中 $B$ 是每个节点传输的总字节数。\n\n问题要求计算“与两个邻居交换幽灵单元（仅发送）”的时间。这意味着我们计算一个节点发送的数据量。一次典型的幽灵单元交换涉及一个节点将其左边界数据发送给其左邻居，并将其右边界数据发送给其右邻居。每次传输都涉及 $g$ 个元素。\n\n一个节点发送的总元素数 = $g$（到左边） + $g$（到右边） = $2g$。\n一个节点发送的总字节数 $B$ 是：\n$$B = 2g \\times s$$\n$$B = 2 \\times (5.0 \\times 10^{6}) \\times 8 = 1.0 \\times 10^{7} \\times 8 = 8.0 \\times 10^{7} \\text{ bytes}$$\n\n现在，我们计算通信时间 $T$：\n$$T = \\beta \\times B$$\n$$T = (2.5 \\times 10^{-10} \\text{ s/byte}) \\times (8.0 \\times 10^{7} \\text{ bytes})$$\n$$T = (2.5 \\times 8.0) \\times (10^{-10} \\times 10^{7}) \\text{ s}$$\n$$T = 20.0 \\times 10^{-3} \\text{ s} = 0.02 \\text{ s}$$\n\n问题要求将通信时间四舍五入到四位有效数字。计算出的精确值为 $0.02$。为了用四位有效数字表示，我们写作 $0.02000$，或用科学记数法表示为 $2.000 \\times 10^{-2}$。\n\n最终答案需要两个值：最小整数 $p$ 和通信时间（以秒为单位）。\n- 最小 $p = 3$\n- 通信时间 $T = 2.000 \\times 10^{-2}$ s", "answer": "$$\n\\boxed{\n\\begin{pmatrix}\n3  & 2.000 \\times 10^{-2}\n\\end{pmatrix}\n}\n$$", "id": "3191832"}, {"introduction": "在决定对数据进行分片后，我们必须管理数据分区之间的边界。本练习 [@problem_id:3191809] 深入探讨了这种管理的量化分析，特别是“幽灵单元”（ghost cells）所带来的存储开销。通过比较分布式内存中的开销分数与共享内存中类似的数据分块（tiling）概念，您将更深刻地理解区域分解中固有的几何权衡（即表面积与体积之比）。", "problem": "您正在一个二维均匀笛卡尔网格上对一个标量场进行显式时间步进有限差分更新的建模。该网格的间距为 $h$，它将一个矩形子域离散化，该子域在水平方向上有 $n_{1}$ 个单元，在垂直方向上有 $n_{2}$ 个单元。在分布式内存环境中，每个子域由一个进程所有，并假定其为严格内部区域（即有四个邻居）。数值模板的半径为一（一个五点模板），每个进程围绕其 $n_{1} \\times n_{2}$ 的内部单元分配一个单元厚度的鬼层。为了便于索引和缓冲区打包，鬼层包括角落的鬼单元，因此局部内存分配为 $(n_{1}+2) \\times (n_{2}+2)$。在单节点共享内存环境中，您转而将计算分块成 $t_{1} \\times t_{2}$ 内部单元的瓦片，并且在更新 $t_{1} \\times t_{2}$ 内部区域之前，为每个瓦片将一个单元厚度的光环层（包括角落）暂存到高速内存中。\n\n仅从矩形的基本几何事实（周长等于两倍边长之和；面积等于边长之积）以及将一层单元厚度的光环层定义为填充矩形与其内部矩形之间的集合差出发，执行以下推理步骤：\n\n- 推导围绕单个分布式内存子域的进程间接口的总物理长度 $H$ 的表达式，用 $h$、$n_{1}$ 和 $n_{2}$ 表示。\n- 从离散结构出发，推导每个分布式内存子域存储的鬼单元数量 $G_{D}$（包括所有角落），以及相应的无量纲存储开销分数 $f_{D} = G_{D}/(n_{1} n_{2})$。\n- 对于共享内存瓦片，推导在 $t_{1} \\times t_{2}$ 内部区域之外暂存的额外元素数量 $G_{S}$（包括角落），以及相应的无量纲暂存开销分数 $f_{S} = G_{S}/(t_{1} t_{2})$。\n- 定义分布式内存光环层开销分数与共享内存瓦片边界开销分数的比率 $R = f_{D}/f_{S}$，并将 $R$ 简化为一个用 $n_{1}$、$n_{2}$、$t_{1}$ 和 $t_{2}$ 表示的封闭形式表达式。\n\n请以 $R$ 的简化解析表达式的形式提供您的最终答案。不要代入数值。最终答案不带任何单位。", "solution": "该问题涉及两种情景：一种是带有鬼层的分布式内存子域，另一种是带有暂存光环层的共享内存瓦片。推导可以基于基本几何学和矩形网格的组合学。\n\n首先，考虑子域的物理几何。内部区域在水平方向上包含 $n_{1}$ 个单元，在垂直方向上包含 $n_{2}$ 个单元。每个单元的宽度为 $h$，高度为 $h$，因此内部矩形的物理边长为 $n_{1} h$ 和 $n_{2} h$。围绕这个内部子域的进程间接口的总物理长度就是这个矩形的周长。根据矩形周长等于其边长之和的两倍这一基本事实，我们得到\n$$\nH = 2\\big(n_{1} h + n_{2} h\\big) = 2 h \\big(n_{1} + n_{2}\\big).\n$$\n\n其次，考虑分布式内存子域的离散光环层，其中分配了一层包含角落的单元厚度的层。填充后的数组大小为 $(n_{1}+2) \\times (n_{2}+2)$，内部区域大小为 $n_{1} \\times n_{2}$。鬼区域是这两者之间的集合差，因此鬼单元的总数是单元数量之差：\n$$\nG_{D} = (n_{1}+2)(n_{2}+2) - n_{1} n_{2} = 2 n_{1} + 2 n_{2} + 4.\n$$\n无量纲存储开销分数是鬼单元数量除以内部区域的单元面积：\n$$\nf_{D} = \\frac{G_{D}}{n_{1} n_{2}} = \\frac{2 n_{1} + 2 n_{2} + 4}{n_{1} n_{2}}.\n$$\n\n第三，对于具有一层单元厚度暂存光环层（包括角落）的 $t_{1} \\times t_{2}$ 内部单元大小的共享内存瓦片，同样的填充与内部的逻辑也适用。总暂存区域有 $(t_{1}+2)(t_{2}+2)$ 个元素，其中 $t_{1} t_{2}$ 个是内部元素。因此，额外暂存的元素数量为\n$$\nG_{S} = (t_{1}+2)(t_{2}+2) - t_{1} t_{2} = 2 t_{1} + 2 t_{2} + 4,\n$$\n而无量纲暂存开销分数为\n$$\nf_{S} = \\frac{G_{S}}{t_{1} t_{2}} = \\frac{2 t_{1} + 2 t_{2} + 4}{t_{1} t_{2}}.\n$$\n\n最后，定义分布式内存光环层开销分数与共享内存瓦片边界开销分数的比率：\n$$\nR = \\frac{f_{D}}{f_{S}} = \\frac{\\dfrac{2 n_{1} + 2 n_{2} + 4}{n_{1} n_{2}}}{\\dfrac{2 t_{1} + 2 t_{2} + 4}{t_{1} t_{2}}}.\n$$\n通过对分子和分母进行适当的乘法来简化这个繁分数，可得\n$$\nR = \\frac{(2 n_{1} + 2 n_{2} + 4)\\, t_{1} t_{2}}{(2 t_{1} + 2 t_{2} + 4)\\, n_{1} n_{2}}.\n$$\n这个封闭形式的表达式比较了分布式内存中分数形式的光环层开销与共享内存分块中分数形式的边界暂存开销的大小，它纯粹是内部维度 $n_{1}$、$n_{2}$、$t_{1}$ 和 $t_{2}$ 的函数，并且是从基本的周长和集合差计数原则推导得出的。", "answer": "$$\\boxed{\\frac{(2 n_{1} + 2 n_{2} + 4)\\, t_{1} t_{2}}{(2 t_{1} + 2 t_{2} + 4)\\, n_{1} n_{2}}}$$", "id": "3191809"}, {"introduction": "除了静态存储，并行系统的性能主要取决于处理单元之间数据交换的成本。本练习 [@problem_id:3191797] 通过比较两种“乒乓”通信场景来探讨这种动态成本：一种是共享内存中通过缓存一致性实现的隐式通信，另一种是分布式内存中显式的消息传递。这将揭示共享内存访问中经常被忽视的成本（如“伪共享”），并将其与定义明确的网络通信成本进行对比。", "problem": "一位开发人员正在分析共享内存系统和分布式内存系统之间的性能差异。在共享内存系统中，位于不同中央处理器（CPU）核心上的两个线程交替写入同一内存位置，该位置假定在同一缓存行中，从而引发缓存一致性流量。在分布式内存系统中，两个进程通过网络交替地向对方发送固定大小的消息。目标是从基本原理出发，构建一个量化模型，并实现一个程序，该程序能为给定数量的事件计算总时间，并统计一致性或消息传递事件的数量。\n\n使用以下基本基础：\n\n- 共享内存系统中的缓存一致性对每个缓存行强制执行单写者不变量。当一个没有所有权的线程尝试写入另一个核心拥有的缓存行时，一致性协议会执行失效操作并转移所有权，这相对于本地写入会产生额外的延迟。这是在现代多处理器中经过充分验证的观察结果。设缓存行大小为 $C$ 字节。设每次事件的本地写入时间为 $t_{w}$（单位为纳秒）。设一致性传输产生的延迟为 $L_{\\text{coh}}$（单位为纳秒），外加一个由持续内存系统带宽 $B_{\\text{sm}}$（单位为千兆字节/秒，使用千兆字节定义 $1\\,\\text{GB}=10^{9}$ 字节）决定的数据移动时间。模型必须反映出，只有当写入者不是缓存行的当前所有者时，才会发生一致性传输。\n\n- 通过网络进行的消息传递具有延迟-带宽行为：发送一个大小为 $M$ 字节的消息所需的时间，是一个固定延迟 $L_{\\text{net}}$（单位为纳秒）、一个由链路带宽 $B_{\\text{net}}$（单位为千兆字节/秒，其中 $1\\,\\text{GB}=10^{9}$ 字节）决定的传输时间，以及一个每条消息的软件开销 $o$（单位为纳秒）的总和。这是一个被广泛接受的延迟-带宽模型。\n\n开发人员必须在两个系统中考虑一种综合访问模式：\n\n- 共享内存乒乓：两个线程交替写入同一个逻辑位置，总共进行 $E$ 次。该位置在数组中的地址步长为 $s$ 字节。如果 $s < C$，则两个线程的写入会竞争同一个缓存行，从而导致一致性事件。如果 $s \\ge C$，则写入发生在不同的缓存行上，不会有争用。\n- 分布式内存乒乓：两个进程交替向对方发送大小为 $M$ 字节的消息，总共进行 $E$ 次。\n\n任务：\n为共享内存和分布式内存系统推导总时间 ($T_{\\text{sm}}, T_{\\text{dist}}$) 和事件计数 ($X_{\\text{sm}}, X_{\\text{dist}}$) 的模型。然后，为给定的五个测试用例计算这些值。", "solution": "### 基于原理的解决方案推导\n\n目标是在“乒乓”访问模式下，为两种不同的并行编程范式推导出总时间和事件计数的量化模型。\n\n#### 1. 共享内存系统模型 ($T_{\\text{sm}}$, $X_{\\text{sm}}$)\n在共享内存乒乓场景中，两个线程交替写入一个内存位置。关键因素是这些写入是否竞争同一个缓存行。\n\n**一致性延迟的条件：** 当一个线程尝试写入它不具有所有权的缓存行时，会触发一致性事件。如果两个线程的写入目标位于同一个缓存行内，就会发生这种情况。给定缓存行大小 $C$ 和两个线程写入位置之间的地址步长 $s$，如果 $s < C$，则会发生诱发一致性的“伪共享”或“真共享”场景。如果 $s \\ge C$，则可以保证写入位置位于不同的缓存行中，线程可以独立操作，不会在其核心之间引发一致性流量。\n\n**一致性事件计数 ($X_{\\text{sm}}$)：** 我们考虑一个包含 $E$ 个写入事件的交替序列。假设线程 A 的第一次写入（事件 1）确立了其对缓存行的所有权。这次初始写入不涉及从另一个核心的传输。线程 B 的第二次写入（事件 2）需要将所有权从线程 A 的缓存转移到线程 B 的缓存。线程 A 的第三次写入（事件 3）又需要将所有权从 B 传回 A。这种模式对所有后续写入都成立。因此，对于总共 $E$ 次写入事件，一致性传输发生在事件 $2, 3, \\dots, E$。一致性传输的次数是 $E-1$。如果 $E \\le 1$，则不发生传输。此逻辑仅在 $s < C$ 时适用。\n\n因此，一致性事件的数量 $X_{\\text{sm}}$ 为：\n$$ X_{\\text{sm}}(E) = \\begin{cases} \\max(0, E-1) & \\text{if } s < C \\\\ 0 & \\text{if } s \\ge C \\end{cases} $$\n结果必须是整数。\n\n**总时间 ($T_{\\text{sm}}$)：** 总时间是所有本地写入时间和所有一致性传输时间的总和。$E$ 个事件中的每一个都涉及一次本地写入，成本为 $t_w$。单次一致性传输的成本是固定延迟 $L_{\\text{coh}}$ 和数据移动时间的总和。移动的数据是一个大小为 $C$ 的缓存行。带宽 $B_{\\text{sm}}$ 以 GB/s 为单位给出。我们将其转换为字节/纳秒。由于 $1\\,\\text{GB} = 10^9\\,\\text{bytes}$ 且 $1\\,\\text{s} = 10^9\\,\\text{ns}$，因此 $B_{\\text{sm}}\\,\\text{GB/s}$ 的带宽在数值上等于 $B_{\\text{sm}}\\,\\text{bytes/ns}$。传输一个缓存行的时间是 $t_{\\text{transfer}} = \\frac{C}{B_{\\text{sm}}}$。因此，一次一致性事件的成本是 $L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}$。\n\n总时间 $T_{\\text{sm}}(E)$ 是 $E$ 次本地写入和 $X_{\\text{sm}}(E)$ 次一致性事件的总和：\n$$ T_{\\text{sm}}(E) = (E \\cdot t_w) + X_{\\text{sm}}(E) \\cdot \\left(L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}\\right) $$\n代入 $X_{\\text{sm}}(E)$ 的表达式：\n$$ T_{\\text{sm}}(E) = E \\cdot t_w + \\begin{cases} \\max(0, E-1) \\cdot \\left(L_{\\text{coh}} + \\frac{C}{B_{\\text{sm}}}\\right) & \\text{if } s < C \\\\ 0 & \\text{if } s \\ge C \\end{cases} $$\n\n#### 2. 分布式内存系统模型 ($T_{\\text{dist}}$, $X_{\\text{dist}}$)\n在分布式内存乒乓中，两个进程交替向对方发送消息。\n\n**消息事件计数 ($X_{\\text{dist}}$)：** 问题陈述指出，进程总共参与 $E$ 次发送事件。每次发送都构成一个独立的消息传递事件。因此，消息总数就是 $E$。\n$$ X_{\\text{dist}}(E) = E $$\n结果必须是整数。\n\n**总时间 ($T_{\\text{dist}}$)：** 总时间是所有 $E$ 次消息发送成本的总和。问题描述了单次消息发送的延迟-带宽模型。发送一个大小为 $M$ 的消息所需的时间是一个固定网络延迟 $L_{\\text{net}}$、一个每消息软件开销 $o$ 和一个传输时间的总和。传输时间由消息大小 $M$ 和网络带宽 $B_{\\text{net}}$ 决定。与 $B_{\\text{sm}}$ 类似，$B_{\\text{net}}$ 以 GB/s 为单位在数值上等于 $B_{\\text{net}}$ 以 bytes/ns 为单位。传输时间为 $t_{\\text{transmit}} = \\frac{M}{B_{\\text{net}}}$。因此，每条消息的总成本是 $L_{\\text{net}} + o + \\frac{M}{B_{\\text{net}}}$。\n\n由于这 $E$ 个事件在乒乓模式中是顺序发生的，总时间是 $E$ 乘以单个事件的成本。\n$$ T_{\\text{dist}}(E) = E \\cdot \\left( L_{\\text{net}} + o + \\frac{M}{B_{\\text{net}}} \\right) $$\n\n这些推导出的模型将被实现，用以计算所提供测试套件的结果。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the total time and event counts for shared and distributed memory\n    ping-pong scenarios based on provided performance models.\n    \"\"\"\n\n    # Test suite: (E, C, s, t_w, L_coh, B_sm, L_net, B_net, o, M)\n    test_cases = [\n        # Case 1: general case with false sharing\n        (1000, 64, 8, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 2: boundary, single event\n        (1, 64, 8, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 3: no false sharing, stride crosses cache line\n        (1000, 64, 128, 3, 100, 40, 5000, 10, 200, 64),\n        # Case 4: fast shared memory link, slower network\n        (1000, 64, 8, 2, 10, 200, 20000, 5, 100, 64),\n        # Case 5: larger message size effect\n        (500, 64, 8, 3, 100, 40, 5000, 10, 200, 1024),\n    ]\n\n    all_results = []\n    for case in test_cases:\n        E, C, s, t_w, L_coh, B_sm, L_net, B_net, o, M = case\n\n        # Shared Memory Calculation\n        # Bandwidth B_sm is in GB/s, which is numerically equivalent to bytes/ns.\n        # Check for false sharing condition s  C\n        if s  C:\n            # Coherence transfers occur for every event except the first one.\n            X_sm = max(0, E - 1)\n            # Cost of a single coherence event = latency + data transfer time\n            coherence_cost = float(L_coh) + float(C) / float(B_sm)\n            # Total time = sum of all local write times + sum of all coherence costs\n            T_sm = float(E * t_w) + float(X_sm) * coherence_cost\n        else:\n            # No false sharing means no coherence transfers.\n            X_sm = 0\n            # Total time is just the sum of local write times.\n            T_sm = float(E * t_w)\n\n        # Distributed Memory Calculation\n        # Bandwidth B_net is in GB/s, which is numerically equivalent to bytes/ns.\n        # Number of message events is the total number of events E.\n        X_dist = E\n        # Cost of a single message = latency + overhead + transmission time\n        message_cost = float(L_net) + float(o) + float(M) / float(B_net)\n        # Total time is the number of events multiplied by the cost per event.\n        T_dist = float(E) * message_cost\n\n        # Ensure event counts are integers\n        X_sm = int(X_sm)\n        X_dist = int(X_dist)\n\n        # Append results for this case\n        all_results.append([T_sm, X_sm, T_dist, X_dist])\n\n    # Format the final output string precisely as specified, without spaces.\n    inner_results_str = [\n        f\"[{r[0]},{r[1]},{r[2]},{r[3]}]\" for r in all_results\n    ]\n    final_output = f\"[{','.join(inner_results_str)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3191797"}]}