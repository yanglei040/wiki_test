{"hands_on_practices": [{"introduction": "并行编程模型并非“一刀切”的解决方案；其性能在很大程度上取决于底层的硬件架构。本练习对并行前缀和这一基础算法，在共享内存（基于线程）和分布式内存（基于MPI）两种实现下进行了具体比较。通过分析“功”（work）和“跨度”（span），你将量化同步延迟和消息传递成本如何形成截然不同的性能特征，从而深入理解如何为给定系统选择正确的模型。[@problem_id:3169829]", "problem": "您正在研究 $N$ 个双精度元素上的并行前缀和（扫描），使用两种编程模型：一种是基于线程的共享内存实现，另一种是基于进程的消息传递接口（MPI）实现。假设结合律操作为加法。您的目标是在一个简单的成本模型下，比较它们的总功（total work）和关键路径长度（span），然后量化因不同协调模式而在 $\\Theta(\\log_2 P)$ 跨度项中产生的常数因子差异。\n\n基本依据与假设：\n- 对 $N$ 个项目进行顺序扫描需要执行 $N-1$ 次加法。\n- 在分叉-连接模型中，功 $T_1$ 是所有处理单元执行的原始操作总数，而跨度 $T_{\\infty}$ 是最长依赖操作链的长度（即关键路径）。\n- 一个有 $P$ 个叶节点的平衡二叉树的高度为 $\\log_2 P$。\n\n两种实现及其成本模型：\n- 基于线程的共享内存实现：数据被划分为 $P$ 个连续的块，每个线程一个。线程计算其块的局部扫描，然后使用平衡树的上扫（up-sweep）和下扫（down-sweep）对 $P$ 个块的总和进行线程间扫描，最后将每块的偏移量加到局部元素上。在关键路径上，每个树层级会产生一个延迟为 $b$ 的屏障和一个常数时间的局部合并成本 $c$。\n- 使用递归倍增的基于MPI的实现：每个进程首先对其块执行局部扫描，然后参与 $\\log_2 P$ 轮的点对点消息交换（递归倍增）来计算块总和的前缀。在关键路径上，每一轮都会产生一个消息延迟 $L$，一个大小为 $s$ 字节的有效载荷的每字节传输时间 $g$，以及一个局部合并成本 $c$。\n\n在比较跨度时，请专注于产生 $\\Theta(\\log_2 P)$ 项的协调部分。在计算比率时，您可以忽略两种模型中相同的局部每块扫描和偏移量应用部分的贡献，因为这些贡献会相互抵消，不影响 $\\Theta(\\log_2 P)$ 协调项或其常数因子。\n\n给定参数：\n- 处理单元数量 $P = 1024$。\n- 线程屏障延迟 $b = 0.3$ 微秒。\n- 局部合并成本 $c = 0.01$ 微秒。\n- MPI每条消息的延迟 $L = 4.8$ 微秒。\n- MPI逆带宽 $g = 0.003$ 微秒/字节。\n- 有效载荷大小 $s = 8$ 字节。\n\n任务：\n1) 使用上述核心定义，用 $N$ 和 $P$ 符号化地表征每种实现的主阶功 $T_1$，并保留两者之间在渐进上不可忽略的、对 $P$ 的依赖关系差异。\n2) 根据给定的成本模型，为每种实现推导协调跨度 $T_{\\infty}$ 的渐进形式和常数因子，并从第一性原理出发证明其 $\\Theta(\\log_2 P)$ 依赖性。\n3) 使用给定的数值参数，计算协调跨度之比 $R$，\n$$\nR \\equiv \\frac{T_{\\infty}^{\\text{threads}}}{T_{\\infty}^{\\text{MPI}}}.\n$$\n将您的答案四舍五入到四位有效数字。将 $R$ 报告为无单位的纯数。", "solution": "该问题要求分析两种并行前缀和实现，一种使用共享内存线程，另一种使用MPI。分析涉及确定每种实现的总功（$T_1$）和协调跨度（$T_{\\infty}$），然后对其协调跨度进行数值比较。\n\n### 任务1：功（$T_1$）的特性描述\n\n功 $T_1$ 表示所有处理单元执行的加法总数。输入包含 $N$ 个元素，划分为 $P$ 个大小为 $N/P$ 的块。\n\n**1. 基于线程的共享内存实现：**\n该算法分三个阶段进行。我们计算每个阶段的功。\n- **局部扫描：** $P$ 个线程中的每一个都在其大小为 $N/P$ 的局部块上执行顺序前缀和。对 $k$ 个项目进行顺序扫描需要 $k-1$ 次加法。因此，一个线程的功是 $(N/P) - 1$。对于所有 $P$ 个线程，总功是 $W_{\\text{local}} = P \\left( \\frac{N}{P} - 1 \\right) = N - P$。\n- **线程间扫描：** 对 $P$ 个块的总和（每个局部扫描的最后一个元素）执行并行扫描，使用涉及上扫和下扫的平衡二叉树结构（Blelloch扫描）。使用此方法对 $P$ 个元素进行并行扫描的功是 $2(P-1)$ 次加法。所以，$W_{\\text{inter}} = 2(P-1)$。\n- **偏移量应用：** 从 $1$ 到 $P-1$ 的每个线程都将其对应的块总和前缀加到其局部块中的所有 $N/P$ 个元素上。线程 $0$ 不需要偏移量。这导致 $(P-1)$ 个线程各执行 $N/P$ 次加法。总功是 $W_{\\text{offset}} = (P-1)\\frac{N}{P} = N - \\frac{N}{P}$。\n\n基于线程模型的总功 $T_{1}^{\\text{threads}}$ 是所有阶段功的总和：\n$$T_{1}^{\\text{threads}} = W_{\\text{local}} + W_{\\text{inter}} + W_{\\text{offset}}$$\n$$T_{1}^{\\text{threads}} = (N-P) + 2(P-1) + \\left(N - \\frac{N}{P}\\right)$$\n$$T_{1}^{\\text{threads}} = 2N + P - \\frac{N}{P} - 2$$\n\n**2. 基于MPI的实现：**\n该算法也有三个阶段。\n- **局部扫描：** 此阶段与基于线程的模型相同。功为 $W_{\\text{local}} = N - P$。\n- **进程间扫描（递归倍增）：** 使用递归倍增算法计算 $P$ 个块总和的前缀和。这需要 $\\log_2 P$ 轮通信。在每一轮 $k$（其中 $k$ 的范围从 $0$ 到 $\\log_2 P - 1$）中，进程 $i \\in [2^k, P-1]$ 接收一个部分和并执行一次加法。第 $k$ 轮的加法次数是 $P - 2^k$。总功是所有轮次的总和：\n$$W_{\\text{inter}} = \\sum_{k=0}^{\\log_2 P - 1} (P - 2^k) = P \\sum_{k=0}^{\\log_2 P - 1} 1 - \\sum_{k=0}^{\\log_2 P - 1} 2^k = P\\log_2 P - (2^{\\log_2 P} - 1) = P\\log_2 P - P + 1$$\n- **偏移量应用：** 此阶段与基于线程的模型相同。功为 $W_{\\text{offset}} = N - \\frac{N}{P}$。\n\n基于MPI模型的总功 $T_{1}^{\\text{MPI}}$ 是：\n$$T_{1}^{\\text{MPI}} = W_{\\text{local}} + W_{\\text{inter}} + W_{\\text{offset}}$$\n$$T_{1}^{\\text{MPI}} = (N-P) + (P\\log_2 P - P + 1) + \\left(N - \\frac{N}{P}\\right)$$\n$$T_{1}^{\\text{MPI}} = 2N + P\\log_2 P - 2P - \\frac{N}{P} + 1$$\n\n### 任务2：协调跨度（$T_{\\infty}$）的推导\n\n跨度 $T_{\\infty}$ 代表关键路径长度。我们被要求只分析协调部分。\n\n**1. 基于线程的协调跨度：**\n协调阶段包括在高度为 $\\log_2 P$ 的平衡二叉树上进行一次上扫和一次下扫。\n- **上扫：** 关键路径从叶节点到根节点，遍历 $\\log_2 P$ 个层级。每个层级都需要同步（延迟为 $b$ 的屏障），然后进行局部合并操作（成本为 $c$）。一个层级的跨度是 $b+c$。因此，上扫的跨度是 $(\\log_2 P)(b+c)$。\n- **下扫：** 关键路径从根节点到叶节点，再次遍历 $\\log_2 P$ 个层级。每个层级产生相同的成本 $b+c$。下扫的跨度也是 $(\\log_2 P)(b+c)$。\n\n总协调跨度 $T_{\\infty}^{\\text{threads}}$ 是两个顺序阶段跨度的总和：\n$$T_{\\infty}^{\\text{threads}} = (\\log_2 P)(b+c) + (\\log_2 P)(b+c) = 2(b+c)\\log_2 P$$\n这具有所要求的 $\\Theta(\\log_2 P)$ 依赖性，其理由是遍历深度为 $\\log_2 P$ 的树两次，一次向上，一次向下。\n\n**2. 基于MPI的协调跨度：**\n协调阶段使用递归倍增，包括 $\\log_2 P$ 个顺序轮次。\n- **单轮跨度：** 在每一轮中，关键路径上的进程等待一条消息，接收它，并执行一次局部组合。此操作的时间是消息延迟 $L$、传输时间 $g \\cdot s$（其中 $s$ 是有效载荷大小，$g$ 是逆带宽）和局部合并成本 $c$ 的总和。所以，每轮的跨度是 $L+gs+c$。\n\n总协调跨度 $T_{\\infty}^{\\text{MPI}}$ 是每轮跨度乘以轮数：\n$$T_{\\infty}^{\\text{MPI}} = (L+gs+c)\\log_2 P$$\n这具有所要求的 $\\Theta(\\log_2 P)$ 依赖性，其理由是递归倍增算法固有的 $\\log_2 P$ 个顺序通信阶段。\n\n### 任务3：比率 $R$ 的计算\n\n协调跨度之比 $R$ 定义为：\n$$R = \\frac{T_{\\infty}^{\\text{threads}}}{T_{\\infty}^{\\text{MPI}}}$$\n代入任务2中推导出的表达式：\n$$R = \\frac{2(b+c)\\log_2 P}{(L+gs+c)\\log_2 P}$$\n$\\log_2 P$ 项相互抵消，得到：\n$$R = \\frac{2(b+c)}{L+gs+c}$$\n现在，我们代入给定的数值参数：\n- $b = 0.3 \\, \\mu s$\n- $c = 0.01 \\, \\mu s$\n- $L = 4.8 \\, \\mu s$\n- $g = 0.003 \\, \\mu s / \\text{byte}$\n- $s = 8 \\, \\text{bytes}$\n\n分子是：\n$$2(b+c) = 2(0.3 + 0.01) = 2(0.31) = 0.62$$\n分母是：\n$$L+gs+c = 4.8 + (0.003 \\times 8) + 0.01 = 4.8 + 0.024 + 0.01 = 4.834$$\n比率 $R$ 是：\n$$R = \\frac{0.62}{4.834} \\approx 0.1282579644$$\n四舍五入到四位有效数字，我们得到：\n$$R \\approx 0.1283$$", "answer": "$$\\boxed{0.1283}$$", "id": "3169829"}, {"introduction": "在共享内存编程中，有效地在线程间平衡工作负载对性能至关重要，但调度行为本身也会引入开销。本实践在OpenMP动态调度的背景下探讨了这一经典权衡。你将建立一个数学模型，以找到最小化总低效率的最优“块大小”，从而在“需要细粒度任务以防止线程空闲”与“频繁任务分配的成本”之间取得平衡。[@problem_id:3169831]", "problem": "考虑一个在 $P$ 个硬件线程上使用 Open Multi-Processing (OpenMP) 动态调度执行的共享内存循环。该循环有 $N$ 次迭代，索引为 $i \\in \\{1,2,\\dots,N\\}$，每次迭代的计算时间建模为 $c(i)=a+bi$，其中 $a>0$ 和 $b\\geq 0$ 是常数。OpenMP 运行时使用固定的块大小 $s$（每次分块的迭代次数）。每次块分配会产生 $\\delta$ 时间单位的调度开销；除了每次分块的这个成本外，没有其他开销或同步来源。动态调度器在线程变为空闲时将块分配给它们。\n\n采用以下与动态调度和单调递增的单次迭代成本曲线相符的科学合理建模假设：\n- 动态调度器消除了大部分负载不平衡，除了在循环末尾，由于块的不可分割性，导致在处理最后一个块时最多有 $P-1$ 个线程处于空闲状态。\n- 在这个尾部阶段，每个空闲线程的平均空闲时间约等于一个代表性尾部块计算时间的一半。\n- 当 $s \\ll N$ 时，一个代表性尾部块的计算时间可以建模为块大小乘以接近 $i \\approx N$ 时的单次迭代成本。\n\n使用这些假设和第一性原理，构建总低效时间（定义为所有线程的总空闲时间加上总调度开销之和）的模型，作为块大小 $s$ 以及参数 $a$、$b$、$N$、$P$ 和 $\\delta$ 的函数。然后，推导出使该低效时间最小化的实值块大小 $s^{\\ast}$。\n\n最后，对以下参数值进行表达式求值：$N=10{,}000$，$P=8$，$a=2$，$b=0.005$ 以及 $\\delta=3$。报告最优实值块大小 $s^{\\ast}$（单位为每次分块的迭代次数），四舍五入至三位有效数字。最终数值答案中不要包含任何单位。", "solution": "该场景是一个使用 Open Multi-Processing (OpenMP) 动态调度的并行循环。根据定义，动态调度在线程可用时，以 $s$ 次迭代为一块将工作分配给线程。每次分配会产生 $\\delta$ 时间单位的开销。执行的总块数为 $N/s$，假设 $s$ 能整除 $N$；为了建模和优化，我们可以将 $s$ 视为一个正实数变量，并连续地解释 $N/s$。\n\n基本建模步骤：\n1. 调度开销。由于每次块分配的成本为 $\\delta$，总共发出了 $N/s$ 个块，因此总调度开销为\n$$\nT_{\\text{overhead}}(s) = \\delta \\frac{N}{s}.\n$$\n\n2. 尾部空闲时间。对于动态调度和单调递增的单次迭代成本 $c(i)=a+bi$，主要的负载不平衡发生在循环的末尾，因为块是不可分割的。在最后的尾部阶段，当一个线程完成最后一个块时，最多可以有 $P-1$ 个线程处于空闲状态。对于具有不可分割粒度的任务，一个标准的排队和调度论证是，尾部区间内每个空闲线程的平均空闲时间大约是最后一个块计算时间的一半。因此，尾部所有线程的总空闲时间可以建模为\n$$\nT_{\\text{idle}}(s) \\approx \\frac{P-1}{2} \\, T_{\\text{chunk,tail}}(s).\n$$\n当 $s \\ll N$ 且 $c(i)$ 在块内变化缓慢时，一个代表性尾部块的计算时间可以近似为块大小乘以接近 $i \\approx N$ 时的单次迭代成本，即\n$$\nT_{\\text{chunk,tail}}(s) \\approx s \\big(a + bN\\big).\n$$\n结合以上两点，\n$$\nT_{\\text{idle}}(s) \\approx \\frac{P-1}{2} \\, s \\big(a + bN\\big).\n$$\n\n3. 总低效时间。将两部分贡献相加，\n$$\nL(s) = T_{\\text{idle}}(s) + T_{\\text{overhead}}(s) \\approx \\frac{P-1}{2} \\, s \\big(a + bN\\big) + \\delta \\frac{N}{s}.\n$$\n我们寻求使 $L(s)$ 最小化的实值块大小 $s>0$。\n\n通过微积分进行优化：\n计算关于 $s$ 的导数：\n$$\n\\frac{dL}{ds} = \\frac{P-1}{2} \\big(a + bN\\big) - \\delta \\frac{N}{s^{2}}.\n$$\n为求最优解，令 $\\frac{dL}{ds}=0$：\n$$\n\\frac{P-1}{2} \\big(a + bN\\big) = \\delta \\frac{N}{s^{2}}.\n$$\n求解 $s^{2}$：\n$$\ns^{2} = \\frac{\\delta N}{\\frac{P-1}{2} \\big(a + bN\\big)} = \\frac{2 \\delta N}{(P-1)\\big(a + bN\\big)}.\n$$\n因此，最优实值块大小为\n$$\ns^{\\ast} = \\sqrt{\\frac{2 \\delta N}{(P-1)\\big(a + bN\\big)}}.\n$$\n\n数值计算：\n给定 $N=10{,}000$，$P=8$，$a=2$，$b=0.005$，以及 $\\delta=3$，\n- 计算 $a+bN$：\n$$\na + bN = 2 + 0.005 \\times 10{,}000 = 2 + 50 = 52.\n$$\n- 计算 $(P-1)\\big(a + bN\\big)$：\n$$\n(P-1)\\big(a + bN\\big) = 7 \\times 52 = 364.\n$$\n- 计算 $2 \\delta N$：\n$$\n2 \\delta N = 2 \\times 3 \\times 10{,}000 = 60{,}000.\n$$\n因此，\n$$\ns^{\\ast} = \\sqrt{\\frac{60{,}000}{364}} \\approx \\sqrt{164.8351648} \\approx 12.8388\\ldots\n$$\n四舍五入到三位有效数字，\n$$\ns^{\\ast} \\approx 12.8.\n$$\n\n这个 $s^{\\ast}$ 是模型下的一个实值最优解。它满足 $s \\ll N$ 的假设，因此与所使用的尾部块近似方法一致。", "answer": "$$\\boxed{12.8}$$", "id": "3169831"}, {"introduction": "超越粗粒度的并行机制，现代并发算法常依赖于细粒度的、使用原子操作的非阻塞同步，以避免锁的开销。然而，正如本练习所示，“无锁”不等于“无竞争”；高竞争可能导致“活锁”（livelock），即线程虽在忙碌却无任何进展。本题旨在挑战你分析这种失效模式，并为一个概率性退避策略的有效性建模，这对于构建健壮且可扩展的并发数据结构至关重要。[@problem_id:3169794]", "problem": "考虑一个使用基于指针的链表实现的多生产者单消费者无锁队列。每个入队操作通过使用硬件原语“比较并交换”(CAS)来更新一个共享的尾指针，从而附加一个节点。CAS的定义如下：它接受一个内存地址和两个值，如果该内存地址的当前内容与预期的旧值相等，则原子地将该地址赋为新值，并返回操作是否成功。假设每次在同一尾指针上的CAS尝试，如果与另一次CAS尝试在时间上重叠，会因竞争而失败；一次成功的CAS更新完成一次入队操作。\n\n在高竞争下构造一个最小的活锁场景如下：两个标记为$A$和$B$的线程同时尝试入队。每个线程读取当前的尾指针，准备其新节点，并发出一个CAS操作以将尾指针更新为该节点。由于这些CAS操作重叠，两者都失败了。在没有任何退避或延迟的情况下，两个线程立即重试，读取相同的尾指针，并再次几乎同时发出CAS，从而反复失败。这种没有进展的重复相互干扰构成了活锁。\n\n为了缓解活锁，提出一种概率性退避策略：在一次CAS失败后，一个线程通过选择一个以离散时间槽为单位的随机延迟来推迟其下一次尝试，因此在任何给定的时间槽中，它以独立的概率$r$尝试CAS。该概率$r$可由退避策略调整，并根据竞争情况自适应变化。假设有$N$个相同的生产者线程，时间被划分为相等的时间槽，并且在每个时间槽内的尝试在线程间是独立的。\n\n将竞争概率$p$定义为：在给定一个线程在某个时间槽中尝试CAS的条件下，至少有另一个线程也在同一时间槽中尝试CAS的概率（如果发生，则导致该次尝试的冲突）。在独立性和相同尝试概率的假设下，每个线程的尝试概率$r$和竞争概率$p$之间存在固定的关系。\n\n仅从上述定义和独立伯努利试验的标准概率定律出发，推导每个时间槽的期望入队吞吐量$T(p)$的闭式解析表达式，该表达式是$p$和$N$的函数。请将最终答案表示为单个简化的符号表达式，不要提供任何数值近似或四舍五入。", "solution": "目标是推导每个时间槽的期望入队吞吐量$T$，即每个时间槽内成功入队操作的期望数量。\n\n根据问题描述，当且仅当在一个给定的时间槽中恰好有一个线程尝试CAS操作时，才会发生一次成功的入队。如果没有线程尝试，则没有入队。如果有两个或更多线程尝试，它们的CAS操作会发生冲突，全部失败，导致没有入队。\n\n设$r$为单个线程在给定时间槽中尝试CAS的概率。我们有$N$个相同且独立的线程。设$K$为表示在给定时间槽中尝试CAS的线程数量的随机变量。由于每个线程的尝试都是一个成功概率为$r$的独立伯努利试验，总尝试次数$K$遵循参数为$N$和$r$的二项分布。\n$K$的概率质量函数由下式给出：\n$$P(K=k) = \\binom{N}{k} r^k (1-r)^{N-k}$$\n其中$k \\in \\{0, 1, \\dots, N\\}$。\n\n吞吐量$T$是成功入队的期望数量。只有当$K=1$时才会成功。因此，期望吞吐量为：\n$$T = 1 \\cdot P(K=1) + 0 \\cdot P(K \\neq 1) = P(K=1)$$\n将$k=1$代入二项概率质量函数，我们将吞吐量表示为$r$和$N$的函数：\n$$T(r) = \\binom{N}{1} r^1 (1-r)^{N-1} = N r (1-r)^{N-1}$$\n\n问题要求将吞吐量$T$表示为竞争概率$p$和$N$的函数。因此，我们必须建立$r$和$p$之间的关系。\n\n竞争概率$p$的定义是“在给定一个线程在某个时间槽中尝试CAS的条件下，至少有另一个线程也在同一时间槽中尝试CAS的概率”。\n\n让我们考虑一个特定的线程，比如线程$i$。条件事件是“$A_i$：线程$i$尝试CAS”。我们关心的事件是“$C_i$：其他$N-1$个线程中至少有一个尝试CAS”。因此，根据定义，有$p = P(C_i | A_i)$。\n由于各线程的尝试是独立的，事件$A_i$不提供关于其他$N-1$个线程行为的任何信息。因此，条件概率等于无条件概率：\n$$p = P(C_i | A_i) = P(C_i)$$\n事件$C_i$是指其他$N-1$个线程中至少有一个尝试CAS。计算其补集事件$\\neg C_i$的概率更为简单，即其他$N-1$个线程中没有一个尝试CAS。\n这$N-1$个线程中的每一个都以概率$r$尝试，以概率$1-r$不尝试。由于它们都是独立的，它们中没有一个尝试的概率是：\n$$P(\\neg C_i) = (1-r)^{N-1}$$\n那么概率$p$是：\n$$p = P(C_i) = 1 - P(\\neg C_i) = 1 - (1-r)^{N-1}$$\n这就提供了$p$和$r$之间所需的关系。“多生产者”和活锁场景所隐含的先验假设$N \\ge 2$确保了$N-1 \\ge 1$，从而使此表达式定义良好。\n\n现在我们可以用$p$和$N$来表示$T$。我们有两个方程：\n$$1) \\quad T = N r (1-r)^{N-1}$$\n$$2) \\quad p = 1 - (1-r)^{N-1}$$\n\n从方程(2)中，我们可以直接用$p$来表示项$(1-r)^{N-1}$：\n$$(1-r)^{N-1} = 1-p$$\n接下来，我们求解方程(2)以得到$r$。\n$$(1-r)^{N-1} = 1-p$$\n$$1-r = (1-p)^{\\frac{1}{N-1}}$$\n$$r = 1 - (1-p)^{\\frac{1}{N-1}}$$\n\n现在，我们将$r$和$(1-r)^{N-1}$的这些表达式代回到$T$的方程中：\n$$T(p) = N \\cdot r \\cdot (1-r)^{N-1} = N \\left( 1 - (1-p)^{\\frac{1}{N-1}} \\right) (1-p)$$\n\n这就是每个时间槽的期望吞吐量$T(p)$的闭式解析表达式，它是竞争概率$p$和线程数$N$的函数。该表达式已按要求进行了简化。", "answer": "$$\\boxed{N(1-p)\\left(1 - (1-p)^{\\frac{1}{N-1}}\\right)}$$", "id": "3169794"}]}