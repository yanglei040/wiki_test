{"hands_on_practices": [{"introduction": "为什么我们不能直接在多个线程中使用标准的伪随机数生成器（PRNG）？本练习将让你亲眼见证两种常见错误的后果：在每个线程中使用相同的种子，以及不加控制地共享同一个生成器实例。通过构建这个“随机数生成器隔离带”，你将理解为什么显式的流管理是必不可少的。[@problem_id:3178991]", "problem": "要求您编写一个完整、可运行的程序，以定量和确定性的方式演示多线程代码中伪随机数生成器状态的意外共享如何产生相关的流，以及如何为每个线程隔离流以防止这种情况。背景是计算科学导论中的伪随机数生成，并且该任务必须使用关于确定性状态机和经验统计比较的基本原理来解决。伪随机数生成器是一个确定性的有限状态机，具有状态更新函数和输出函数。如果两个线程从同一个状态机消耗数据，它们的输出属于同一个底层流，并且不是独立的。如果两个线程各自使用相同的种子创建自己的状态机，它们将产生完全相同的流。正确的隔离需要从一个主种子派生出每个线程的初始状态，且这些状态不能重叠。\n\n使用的基本原理：\n- 伪随机数生成器 (PRNG) 是一个确定性的有限状态机：存在一个状态更新函数 $F$ 和一个输出函数 $G$，使得对于给定的初始状态 $s_0$，状态通过 $s_{t+1} = F(s_t)$ 演化并产生输出 $x_t = G(s_t)$。确定性意味着同一个状态机的两个消费者产生的是同一个唯一序列 $\\{x_t\\}$ 的不同部分，因此它们的输出通过共享状态而相关。流的独立性要求初始状态不同且不重叠。\n- 可以使用 Pearson 相关系数 $r$ 对独立性进行经验性比较，该系数根据有限样本上的标准定义从两个实数序列计算得出。两个独立同分布的 Uniform$(0,1)$ 序列的独立性意味着，对于足够大的样本量 $n$，$r$ 会集中在 $0$ 附近，而完全相同的序列则得到 $r = 1$。\n- 在此类实验中，通过固定种子并仔细控制共享状态的消耗调度，可以获得确定性的可复现性。\n\n您的程序必须实现三个多线程实验，每个实验都创建两个伪随机数流，每个流提取 $n$ 个数，使用标准数值库中提供的置换同余生成器 (PCG) 引擎 (PCG$64$)。所有数值量和变量必须解释为纯数字，不带物理单位。\n\n需要实现的实验：\n1) 意外的“每线程相同种子”错误。创建 $2$ 个工作线程。每个线程创建自己的本地 PRNG 实例，但两个线程都使用相同的固定种子 $s$。每个线程生成 $n$ 个在 $[0,1)$ 区间内的实数。计算两个长度为 $n$ 的序列之间的经验 Pearson 相关系数 $r_1$。由于两个线程生成的是相同的确定性序列，因此当在完全相同的序列上精确计算时，这个 $r_1$ 应等于 $1$。\n2) 共享全局生成器并强制交替。创建 $2$ 个工作线程，它们共享一个使用种子 $s$ 初始化的全局 PRNG 实例。强制执行严格的交替调度，使线程按 $A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}$ 的精确顺序提取随机数，其中 $A_i$ 是分配给线程 A 的提取值，$B_i$ 分配给线程 B。另外，使用相同的种子 $s$ 生成一个长度为 $2n$ 的单线程参考序列 $Z$。通过按相同的交替顺序交错两个线程的输出来构建合并序列 $M$。输出一个布尔值 $b_2$，指示 $M$ 是否与 $Z$ 按元素相同。$b_2 = \\text{True}$ 的值表明两个线程流是单个流的确定性相关子序列。\n3) 通过主种子实现正确的每线程流隔离。使用单个主种子 $s$ 初始化一个主种子序列对象，然后为两个每线程的 PRNG 实例 (PCG$64$) 派生出两个独立的子种子序列，从而使两个流在构造上不重叠。运行 $2$ 个线程，每个线程从其自己的 PRNG 生成 $n$ 个在 $[0,1)$ 区间内的实数。计算两个序列之间的经验 Pearson 相关系数 $r_3$。对于足够大的 $n$，这个 $r_3$ 的绝对值应该接近 $0$。\n\n测试套件和参数：\n- 使用以下三个测试用例，每个都是一个三元组 $(\\text{scenario}, n, s)$：\n  - $\\big($\"same\\_seed\\_per\\_thread\", $4096$, $123456789\\big)$\n  - $\\big($\"shared\\_generator\\_interleaved\", $4096$, $123456789\\big)$\n  - $\\big($\"spawn\\_isolated\\_per\\_thread\", $4096$, $123456789\\big)$\n- 对于相关系数 $r_1$ 和 $r_3$，将其报告为四舍五入到 $6$ 位小数的浮点数。\n- 对于实验 $2$ 中的相等性检查，报告布尔值 $b_2$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。该列表必须按顺序对应上述测试套件，即 $[r_1, b_2, r_3]$，其中 $r_1$ 和 $r_3$ 是精确到 $6$ 位小数的浮点数，而 $b_2$ 是一个布尔字面量。例如，一个语法上有效的输出看起来会像 $[1.000000,True,0.001234]$。", "solution": "该问题要求对多线程程序中伪随机数生成器 (PRNG) 状态管理的效果进行确定性、定量的演示。核心原理是 PRNG 是一个确定性的有限状态机。其输出序列完全由其初始状态（或种子）决定。正确的并行 PRNG 用法要求每个执行线程都在独立的随机数流上操作，这需要每个线程的 PRNG 都用一个能保证其序列不与其它序列重叠的状态来初始化。\n\n一个 PRNG 可以用一个状态空间 $S$、一个初始状态 $s_0 \\in S$、一个状态转移函数 $F: S \\to S$ 和一个输出函数 $G: S \\to \\mathbb{R}$ 来建模。状态序列由 $s_{t+1} = F(s_t)$ 给出，伪随机数序列为 $x_t = G(s_t)$。\n\n为了经验性地评估两个随机数流的独立性，我们使用 Pearson 相关系数 $r$。对于两个样本序列 $X = \\{x_i\\}_{i=1}^n$ 和 $Y = \\{y_i\\}_{i=1}^n$，其样本均值分别为 $\\bar{x}$ 和 $\\bar{y}$，相关性计算如下：\n$$\nr = \\frac{\\sum_{i=1}^n (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^n (x_i - \\bar{x})^2} \\sqrt{\\sum_{i=1}^n (y_i - \\bar{y})^2}}\n$$\n对于完全相关的序列（即，相差一个线性变换），$|r|=1$。对于统计上独立的序列，对于大的样本量 $n$，$r$ 期望接近 $0$。\n\n我们将使用 `numpy` 库提供的 PCG$64$ 生成器来实现三个实验，每个线程的样本量为 $n=4096$，种子为 $s=123456789$。\n\n1.  **实验 1：每线程使用相同种子。**\n    这个实验模拟了一个常见的错误，即两个线程 $T_A$ 和 $T_B$ 各自创建了一个新的 PRNG 实例，但使用了相同的种子 $s$。由于 PRNG 是确定性的，两个线程都初始化了一个相同的状态机：$(F, G, s_0=s)$。因此，两个线程将生成完全相同的 $n$ 个数字序列。来自 $T_A$ 的序列（我们称之为 $X_A$）将与来自 $T_B$ 的序列 $X_B$ 逐元素相同。因此，计算 $X_A$ 和 $X_B$ 之间的 Pearson 相关系数 $r_1$ 将得到一个精确等于 $r_1=1$ 的值，这表明完全缺乏独立性。\n\n2.  **实验 2：共享全局生成器并强制交替。**\n    这个实验演示了两个线程 $T_A$ 和 $T_B$ 共享单个 PRNG 实例的后果。PRNG 的状态 $s_t$ 成为了一个共享资源。为了使结果具有确定性和可验证性，我们使用同步原语（信号量）来强制执行严格的交替提取调度。$T_A$ 提取一个数，然后 $T_B$ 提取一个，然后 $T_A$ 再提取，依此类推。两个线程的总提取序列是 $\\{A_0, B_0, A_1, B_1, \\dots, A_{n-1}, B_{n-1}\\}$。这个交错的过程等同于单个线程提取 $2n$ 个数。为了证明这一点，我们使用一个以相同种子 $s$ 初始化的单线程来生成一个长度为 $2n$ 的参考序列 $Z$。然后我们通过交错来自 $T_A$ 和 $T_B$ 的输出来构建一个合并序列 $M$。我们期望布尔比较 $b_2 = (M \\equiv Z)$ 的结果为 True，这证实了两个线程并未生成独立的流，而是生成了一个单一底层流的不相交子序列。\n\n3.  **实验 3：通过派生实现正确的流隔离。**\n    这个实验演示了在并行应用程序中创建独立随机数流的正确方法。我们不直接使用相同的种子，而是使用一个主种子 $s$ 来初始化一个 `SeedSequence` 对象。该对象充当一个工厂，为多个 PRNG 生成加密强度高且独立的种子数据。我们使用其 `spawn(2)` 方法创建两个子 `SeedSequence` 对象，$ss_A$ 和 $ss_B$。这些子对象保证能初始化 PRNG，使其产生不重叠且统计独立的序列。线程 $T_A$ 使用从 $ss_A$ 初始化的 PRNG，线程 $T_B$ 使用从 $ss_B$ 初始化的 PRNG。生成的序列 $X_A$ 和 $X_B$ 将是统计独立的。它们之间计算出的 Pearson 相关系数 $r_3$ 将接近于零，反映了这种独立性。$r_3$ 的量级预计在 $1/\\sqrt{n}$ 左右。对于 $n=4096$，我们预计 $|r_3| \\approx 1/\\sqrt{4096} \\approx 0.0156$。\n\n下面的程序实现了这三个实验，计算了所需的指标（$r_1$、$b_2$、$r_3$），并按規定格式化输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport threading\n\ndef solve():\n    \"\"\"\n    Runs three experiments to demonstrate PRNG state management in multithreading.\n    1. Same seed per thread - correlated streams.\n    2. Shared generator - dependent streams.\n    3. Spawning child seeds - independent streams.\n    \"\"\"\n    \n    # Define the test parameters from the problem statement.\n    # n and s are the same for all three experiments.\n    n = 4096\n    s = 123456789\n\n    # --- Experiment 1: \"same_seed_per_thread\" ---\n    # Each thread creates its own PRNG from the same seed.\n    def worker_exp1(seed, size, out_array):\n        \"\"\"Worker for experiment 1: creates a local PRNG.\"\"\"\n        rng = np.random.Generator(np.random.PCG64(seed))\n        out_array[:] = rng.random(size)\n\n    stream1_exp1 = np.empty(n, dtype=np.float64)\n    stream2_exp1 = np.empty(n, dtype=np.float64)\n    \n    thread1 = threading.Thread(target=worker_exp1, args=(s, n, stream1_exp1))\n    thread2 = threading.Thread(target=worker_exp1, args=(s, n, stream2_exp1))\n    \n    thread1.start()\n    thread2.start()\n    thread1.join()\n    thread2.join()\n\n    # The streams should be identical, so correlation is 1.0.\n    r1 = np.corrcoef(stream1_exp1, stream2_exp1)[0, 1]\n\n    # --- Experiment 2: \"shared_generator_interleaved\" ---\n    # Threads share one PRNG, with access ordered by semaphores.\n    def worker_A_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker A: acquires sem_a, releases sem_b.\"\"\"\n        for i in range(size):\n            sem_a.acquire()\n            out_array[i] = rng.random()\n            sem_b.release()\n\n    def worker_B_exp2(rng, size, sem_a, sem_b, out_array):\n        \"\"\"Worker B: acquires sem_b, releases sem_a.\"\"\"\n        for i in range(size):\n            sem_b.acquire()\n            out_array[i] = rng.random()\n            sem_a.release()\n\n    shared_rng = np.random.Generator(np.random.PCG64(s))\n    stream_a_exp2 = np.empty(n, dtype=np.float64)\n    stream_b_exp2 = np.empty(n, dtype=np.float64)\n\n    # Semaphores to enforce strict A, B, A, B... alternation.\n    sem_a = threading.Semaphore(1)\n    sem_b = threading.Semaphore(0)\n\n    thread_a = threading.Thread(target=worker_A_exp2, args=(shared_rng, n, sem_a, sem_b, stream_a_exp2))\n    thread_b = threading.Thread(target=worker_B_exp2, args=(shared_rng, n, sem_a, sem_b, stream_b_exp2))\n    \n    thread_a.start()\n    thread_b.start()\n    thread_a.join()\n    thread_b.join()\n\n    # Interleave the results from the two threads.\n    merged_sequence = np.empty(2 * n, dtype=np.float64)\n    merged_sequence[0::2] = stream_a_exp2\n    merged_sequence[1::2] = stream_b_exp2\n    \n    # Generate the single-threaded reference sequence.\n    ref_rng = np.random.Generator(np.random.PCG64(s))\n    reference_sequence = ref_rng.random(2 * n)\n\n    # The interleaved threaded sequence should be identical to the reference.\n    b2 = np.array_equal(merged_sequence, reference_sequence)\n\n    # --- Experiment 3: \"spawn_isolated_per_thread\" ---\n    # Each thread gets an independent PRNG from a spawned SeedSequence.\n    def worker_exp3(rng, size, out_array):\n        \"\"\"Worker for experiment 3: uses a pre-made PRNG.\"\"\"\n        out_array[:] = rng.random(size)\n\n    # Create a master SeedSequence and spawn two independent children.\n    ss = np.random.SeedSequence(s)\n    child_sequences = ss.spawn(2)\n    \n    rng1_exp3 = np.random.Generator(np.random.PCG64(child_sequences[0]))\n    rng2_exp3 = np.random.Generator(np.random.PCG64(child_sequences[1]))\n\n    stream1_exp3 = np.empty(n, dtype=np.float64)\n    stream2_exp3 = np.empty(n, dtype=np.float64)\n\n    thread1_exp3 = threading.Thread(target=worker_exp3, args=(rng1_exp3, n, stream1_exp3))\n    thread2_exp3 = threading.Thread(target=worker_exp3, args=(rng2_exp3, n, stream2_exp3))\n    \n    thread1_exp3.start()\n    thread2_exp3.start()\n    thread1_exp3.join()\n    thread2_exp3.join()\n    \n    # The streams should be independent, so correlation is near 0.\n    r3 = np.corrcoef(stream1_exp3, stream2_exp3)[0, 1]\n\n    # Final print statement in the exact required format.\n    print(f\"[{r1:.6f},{b2},{r3:.6f}]\")\n\nsolve()\n```", "id": "3178991"}, {"introduction": "既然我们知道了需要独立的随机数流，那么如何从一个传统的、有状态的生成器（如线性同余生成器 LCG）中创建它们呢？本练习将介绍一种强大的技术：序列分割。你将实现一个“跳跃”函数，它可以瞬间在PRNG序列中前进数百万步，从而让每个并行进程都能在正确的、不重叠的位置开始，并确保无论是在1个还是1000个处理器上运行，大型模拟都能得到比特级别完全相同的结果。[@problem_id:3170099]", "problem": "要求您设计并实现一个原则性方案，使用块分割（block-splitting）方法为 $p$ 个消息传递接口（MPI）进程分配独立的伪随机数生成器（PRNG）流，并验证 $\\hat{\\pi}$ 的蒙特卡洛估计量在不同进程数量下的可复现性。整个解决方案必须以一个完整的、可运行的程序来表达。\n\n使用的基本原理：\n- 伪随机数生成器（PRNG）流的定义：由状态更新规则产生的确定性序列 $\\{x_n\\}$。\n- 模为 $m$ 的线性同余生成器（LCG）由递推关系 $x_{n+1} = (a x_n + c) \\bmod m$ 定义，初始状态为 $x_0$。\n- 通过取高位比特并乘以 $2$ 的适当次幂进行缩放，将一个均匀整数状态映射到 $[0,1)$ 区间内的均匀实数变量，以生成一个浮点数。\n- 通过在 $[0,1]^2$ 内均匀采样 $(x,y)$ 并计算单位圆四分之一区域内的命中点数来蒙特卡洛估计 $\\pi$ ，其估计量为 $\\hat{\\pi} = 4 H / N$，其中 $H$ 是命中次数，$N$ 是总试验次数。\n\n设计目标：\n1. 为 $p$ 个进程中的每一个分配一个不相交的连续试验索引块，以便在固定的总试验次数 $N$ 下，所有分配的试验索引的并集恰好是 $\\{0,1,\\dots,N-1\\}$，且与 $p$ 无关，并且没有两个进程共享同一个索引。根据需要使用块分割方法，允许最后一个块大小不等。一个标准的连续分区定义为：令 $q = \\lfloor N/p \\rfloor$ 和 $r = N \\bmod p$，则进程 $i$ 被分配的块起始位置为 $S_i = i q + \\min(i,r)$，块长度为 $L_i = q + 1$（如果 $i  r$）或 $L_i = q$（其他情况）。\n2. 每个试验索引 $t$ 对应两次 PRNG 抽取 $(u_{2t}, u_{2t+1})$ 以构成坐标对 $(x,y)$。因此，进程 $i$ 必须从位置 $2 S_i$ 开始其 PRNG 流，并消耗 $2 L_i$ 个值。为了高效实现这一点，需要实现一个针对 LCG 的跳步（skip-ahead）程序，以将状态向前推进 $k$ 步，而无需逐一迭代。\n\n科学与算法要求：\n- 使用一个 LCG，其模数 $m = 2^{64}$，乘数 $a = 6364136223846793005$，增量 $c = 1442695040888963407$，以及一个在 $\\{0,1,\\dots,m-1\\}$ 中的任意但固定的种子 $x_0$。当 $c$ 为奇数时，这些常数可产生一个周期完整的模 $2^{64}$ LCG，这是一个经过充分测试的配置。\n- 推导并实现一种使用仿射变换复合的高效跳步方法。对于单步操作，$T(x) = a x + c \\bmod m$ 是一个仿射映射。展示如何使用平方求幂和变换复合来計算 $T^k(x) = A_k x + C_k \\bmod m$，并避免模除法。\n- 通过取 $x_n$ 的高 53 位并乘以 $2^{-53}$，将每个 $x_n$ 映射为一个双精度实数 $u_n \\in [0,1)$，以确保在双精度网格上的均匀性。\n- 通过块分割将试验分配给 $p$ 个模拟进程，通过跳步适当地推进每个进程的 PRNG 状态，并累加所有进程的命中数 $H$，来模拟蒙特卡洛估计量 $\\hat{\\pi}$。\n\n测试套件：\n- 对于每个测试用例，程序必须返回一个布尔值，指示可复现性或块分配属性是否如规定成立。共有四个测试用例：\n    1. 理想路径可复现性：$N = 200000$，进程数 $p \\in \\{1,2,4,8\\}$。验证所有 $\\hat{\\pi}$ 估计值作为浮点数完全相等。\n    2. N 不可整除情况下的可复现性：$N = 123457$，进程数 $p \\in \\{3,5,7\\}$。验证在所有 $p$ 值下 $\\hat{\\pi}$ 均相等。\n    3. 进程数相对于试验次数较多的边界情况：$N = 64$，进程数 $p \\in \\{1,64,128\\}$。验证在所有 $p$ 值下 $\\hat{\\pi}$ 均相等，并且正确处理了长度为零的块。\n    4. 块分配正确性：$N = 1000$, $p = 33$。验证块分割分区完全覆盖了试验索引集 $\\{0,\\dots,999\\}$ 且无重叠。如果块是连续、不相交且完全覆盖索引集，则测试返回 $true$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，$[result_1,result_2,result_3,result_4]$）。\n- 对于上述四个测试用例，输出必须是按顺序排列的四个布尔值，分别对应于测试 1 到 4。\n\n所有计算纯属数学运算，不涉及任何物理单位。不使用角度。不使用百分比。整个程序必须是自包含的，不得读取输入，并且在给定固定种子 $x_0$ 的情况下必须是确定性的。问题陈述中未限制实现语言，但您提交的最终答案必须是按单独规定编写的一个完整的、可运行的 Python 程序。", "solution": "此问题的核心在于证明，只要底层伪随机数流的划分在数学上是精确的，无论计算工作如何在并行进程之间划分，蒙特卡洛模拟都能产生逐位相同的结果。我们将设计一个系统，通过结合三个关键组件来实现这一目标：一种健壮的工作负载划分方法（块分割），一种用于在伪随机数流中导航的高效算法（LCG 跳步），以及一个用于估计 $\\pi$ 的确定性蒙特卡洛程序。\n\n首先，我们为线性同余生成器（LCG）在无需显式迭代的情况下前进任意步数 $k$ 建立数学基础。LCG 由以下递推关系定义：\n$$\nx_{n+1} = (a x_n + c) \\pmod m\n$$\n其中 $x_n$ 是第 $n$ 步的状态，$a$、$c$ 和 $m$ 分别是乘数、增量和模数。这是一个在模 $m$ 整数环上的仿射变换 $T(x) = ax + c$。将生成器应用 $k$ 次等同于将该变换自身复合 $k$ 次，得到 $T^k(x)$。\n\n设单步变换由系数对 $(a, c)$ 表示。两个此类变换 $(a_1, c_1)$ 和 $(a_2, c_2)$ 的复合产生一个新的变换：\n$$\n(T_1 \\circ T_2)(x) = T_1(T_2(x)) = a_1(a_2 x + c_2) + c_1 = (a_1 a_2) x + (a_1 c_2 + c_1)\n$$\n得到的变换由新的系数对 $(a_1 a_2, a_1 c_2 + c_1)$ 定义。这种复合运算是可结合的。这种代数结构允许我们使用二进制幂（也称为平方求幂）来计算 $k$ 步变换的参数 $(A_k, C_k)$，其中 $T^k(x) = A_k x + C_k \\pmod m$。\n\n寻找给定步数 $k$ 的 $(A_k, C_k)$ 的算法如下：\n1. 将“总”变换初始化为单位变换，$(A_{total}, C_{total}) = (1, 0)$。\n2. 将“当前”变换初始化为单步 LCG 参数，$(A_{current}, C_{current}) = (a, c)$。\n3. 当 $k > 0$ 时：\n    a. 如果 $k$ 是奇数，则将总变换与当前变换复合：$(A_{total}, C_{total}) \\leftarrow (A_{total} A_{current}, A_{total} C_{current} + C_{total})$。\n    b. 将当前变换平方：$(A_{current}, C_{current}) \\leftarrow (A_{current}^2, A_{current} C_{current} + C_{current})$。\n    c. 更新 $k \\leftarrow \\lfloor k/2 \\rfloor$。\n所有算术运算均在模 $m$ 下进行。对于此问题，$m = 2^{64}$，因此我们使用无符号 64 位整数算术。$k$ 步后的最终状态为 $x_k = (A_k x_0 + C_k) \\pmod m$。\n\n其次，我们解决工作负载分配问题。问题指定了一种块分割策略，用于将 $N$次蒙特卡洛总试验分配给 $p$ 个进程。给出的公式是：\n- $q = \\lfloor N/p \\rfloor$\n- $r = N \\bmod p$\n- 对于进程 $i \\in \\{0, 1, \\dots, p-1\\}$：\n  - 起始试验索引：$S_i = i q + \\min(i, r)$\n  - 试验次数：$L_i = q + 1$（若 $i  r$），否则为 $L_i = q$。\n这种标准分区方案创建了一组连续、不相交的试验索引块 $\\{[S_i, S_i + L_i - 1]\\}_{i=0}^{p-1}$，其并集恰好是所有试验索引的集合 $\\{0, 1, \\dots, N-1\\}$。\n\n第三，我们将并行方案与 PRNG 联系起来。每个蒙特卡洛试验 $t$ 需要两个随机变量 $(u_{2t}, u_{2t+1})$ 来构成坐标对 $(x,y)$。因此，被分配了从 $S_i$ 开始的试验索引的进程 $i$，必须从全局 PRNG 流中的索引 $2S_i$ 处开始生成随机数。它将总共消耗 $2L_i$ 个随机数。通过使用上面推导的、以 $k=2S_i$ 为参数的跳步算法，每个进程都可以从全局种子 $x_0$ 直接计算出其唯一的起始状态 $x_{2S_i}$，然后继续生成其包含 $2L_i$ 个伪随机数的局部序列。\n\n从 64 位整数状态 $x_n$ 到双精度浮点数 $u_n \\in [0,1)$ 的转换是通过取 $x_n$ 的最高有效 53 位并按 $2^{-53}$ 缩放来执行的。这可以表示为 `(x_n >> 11) * (2**-53)`，它将整数状态映射到该区间内可表示的双精度数网格上。\n\n$\\pi$ 的蒙特卡洛估计过程是：在单位正方形 $[0,1)^2$ 中生成 $N$ 个点 $(x, y)$，并统计落在四分之一单位圆内的“命中”点数 $H$，即 $x^2 + y^2  1$。估计量为 $\\hat{\\pi} = 4H/N$。由于我们的并行方案确保了生成的随机数对总集合 $\\{(u_{2t}, u_{2t+1})\\}_{t=0}^{N-1}$ 与进程数 $p$ 无关，因此总命中数 $H = \\sum_{i=0}^{p-1} H_i$（其中 $H_i$是进程 $i$ 计数的命中数）将是不变的。因此，最终估计值 $\\hat{\\pi}$ 在不同的 $p$ 值下必须是逐位相同的。\n\n实现将包括执行 LCG 跳步、计算块分割以及为给定的 $(N, p)$ 对运行完整模拟的函数。然后，测试套件将调用这些函数来验证所需的可复现性和正确分区属性。对于所有测试，我们使用指定的 LCG 参数 $m=2^{64}$，$a=6364136223846793005$，$c=1442695040888963407$ 和一个固定的初始种子 $x_0 = 42$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite for parallel random number generation.\n    \"\"\"\n\n    # LCG parameters from the problem statement.\n    # m = 2**64, but we use a mask for 64-bit unsigned arithmetic.\n    M_64_MASK = (1  64) - 1\n    A = 6364136223846793005\n    C = 1442695040888963407\n    # An arbitrary but fixed seed.\n    X0 = 42\n\n    def lcg_skip_ahead(k, a, c, mask):\n        \"\"\"\n        Computes the parameters (A_k, C_k) for an LCG skip of k steps.\n        The k-step transformation is T^k(x) = A_k * x + C_k (mod m).\n        This is equivalent to computing M^k where M is the matrix [[a, c], [0, 1]].\n        We do this via binary exponentiation on the transform parameters.\n\n        Args:\n            k (int): The number of steps to skip ahead.\n            a (int): The LCG multiplier.\n            c (int): The LCG increment.\n            mask (int): The mask for modulo 2**64 arithmetic.\n\n        Returns:\n            tuple[int, int]: The effective multiplier and increment (A_k, C_k).\n        \"\"\"\n        if k == 0:\n            return 1, 0\n\n        # total_a, total_c represent the composed transform so far.\n        # Identity transform: 1*x + 0.\n        total_a, total_c = 1, 0\n        \n        # current_a, current_c represent the transform for powers of 2 steps.\n        # Starts with the 1-step transform.\n        current_a, current_c = a, c\n\n        while k > 0:\n            if k  1:\n                # Compose total transform with current: total_new = total_old o current.\n                # T_new(x) = total_a * (current_a * x + current_c) + total_c\n                # T_new(x) = (total_a * current_a) * x + (total_a * current_c + total_c)\n                total_c = (total_a * current_c + total_c)  mask\n                total_a = (total_a * current_a)  mask\n\n            # Square the current transform: current_new = current o current\n            # T_new(x) = a'(a'x + c') + c' = (a'^2)x + (a'c' + c')\n            current_c = (current_a * current_c + current_c)  mask\n            current_a = (current_a * current_a)  mask\n            \n            k >>= 1\n        \n        return total_a, total_c\n\n    def get_block_split(N, p, i):\n        \"\"\"\n        Calculates the start index and length of the block for process i.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Total number of processes.\n            i (int): The process rank (0-indexed).\n\n        Returns:\n            tuple[int, int]: (start_trial, num_trials) for process i.\n        \"\"\"\n        q = N // p\n        r = N % p\n        start_trial = i * q + min(i, r)\n        num_trials = q + 1 if i  r else q\n        return start_trial, num_trials\n\n    def run_simulation(N, p, x0, a, c, mask):\n        \"\"\"\n        Runs the Monte Carlo simulation for pi with N trials on p processes.\n\n        Args:\n            N (int): Total number of trials.\n            p (int): Number of simulated processes.\n            x0 (int): The initial seed for the entire stream.\n            a (int): LCG multiplier.\n            c (int): LCG increment.\n            mask (int): Modulo mask.\n\n        Returns:\n            float: The estimated value of pi.\n        \"\"\"\n        total_hits = 0\n        \n        # Scale for converting 53 high bits to a float in [0,1)\n        scale = 1.0 / (1  53)\n        \n        for i in range(p):\n            start_trial, num_trials = get_block_split(N, p, i)\n            \n            if num_trials == 0:\n                continue\n\n            # Each trial needs 2 random numbers.\n            skip_steps = 2 * start_trial\n            A_k, C_k = lcg_skip_ahead(skip_steps, a, c, mask)\n            \n            # This is the starting state for process i's PRNG stream.\n            x = (A_k * x0 + C_k)  mask\n            \n            local_hits = 0\n            for _ in range(num_trials):\n                # Generate u1 (for x-coordinate)\n                x = (a * x + c)  mask\n                u1 = (x >> 11) * scale\n                \n                # Generate u2 (for y-coordinate)\n                x = (a * x + c)  mask\n                u2 = (x >> 11) * scale\n                \n                if u1 * u1 + u2 * u2  1.0:\n                    local_hits += 1\n            \n            total_hits += local_hits\n            \n        if N == 0:\n            return 0.0  # Or other sensible value for N=0\n        \n        return 4.0 * total_hits / N\n\n    def test_reproducibility(N, p_list, x0, a, c, mask):\n        \"\"\"Helper to test reproducibility across different process counts.\"\"\"\n        if not p_list:\n            return True\n        results = [run_simulation(N, p, x0, a, c, mask) for p in p_list]\n        return len(set(results)) == 1\n\n    def test_block_assignment(N, p):\n        \"\"\"Verify that block splitting creates a correct partition.\"\"\"\n        current_pos = 0\n        total_len = 0\n        for i in range(p):\n            start, length = get_block_split(N, p, i)\n            if start != current_pos:\n                return False  # Partition is not contiguous\n            current_pos += length\n            total_len += length\n        \n        # Check if the partition covers the entire set and only the set\n        return current_pos == N and total_len == N\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Test 1: Happy path reproducibility\n        lambda: test_reproducibility(200000, [1, 2, 4, 8], X0, A, C, M_64_MASK),\n        # Test 2: Non-divisible N reproducibility\n        lambda: test_reproducibility(123457, [3, 5, 7], X0, A, C, M_64_MASK),\n        # Test 3: Boundary case with p > N\n        lambda: test_reproducibility(64, [1, 64, 128], X0, A, C, M_64_MASK),\n        # Test 4: Block assignment correctness\n        lambda: test_block_assignment(1000, 33)\n    ]\n\n    results = []\n    for test_func in test_cases:\n        results.append(test_func())\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3170099"}, {"introduction": "序列分割虽然强大，但如果我们的并行任务不是一个简单的长序列该怎么办？最后的这个练习将探索一种现代而优雅的解决方案：基于计数器的生成器。通过为每一份工作贴上唯一的ID标签，并使用一个无状态函数来生成随机数，你将实现完美的复现性，而无需关心工作是如何被调度的。你将验证，即使计算顺序被分块、融合或完全打乱，结果也保持不变，这对于复杂、动态的并行算法来说是一个至关重要的特性。[@problem_id:3170077]", "problem": "给定一个关于索引 $i$ 和 $j$ 的嵌套并行循环结构，其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$。任务是为伪随机数生成构建一个确定性的流标记方案，该方案在循环执行调度（例如循环分块和循环融合）发生变化时保持不变。该构建必须使用一个基于计数器的映射，将索引对 $(i, j)$ 映射到由 $c = i \\cdot K + j$ 定义的单个整数计数器 $c$。此伪随机数生成器必须是无状态的，并且其输出必须仅从种子 $s$ 和计数器 $c$ 派生。\n\n基本原理：\n- 伪随机数生成器（PRNG）是一种确定性算法，它将一个种子 $s$ 和一个状态映射到一个输出。对于基于计数器的 PRNG，状态是一个计数器 $c$，输出是对于一个固定函数 $F$ 的 $F(s, c)$。\n- 无论执行调度或并行顺序如何，确定性函数 $F(s, c)$ 对于相同的输入总能产生相同的输出。\n- 映射 $c = i \\cdot K + j$ 是索引对 $(i, j)$（其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$）与整数 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 之间的一个双射，其逆映射为 $i = \\left\\lfloor \\frac{c}{K} \\right\\rfloor$ 和 $j = c \\bmod K$。\n\n你的程序必须：\n1. 实现一个定义为 $F(s, c)$ 的无状态、基于计数器的 PRNG，该 PRNG 从 $s$ 和 $c$ 生成一个 $64$ 位无符号整数。该函数必须仅依赖于 $s$ 和 $c$，并且程序必须证明在不同循环遍历顺序下的可复现性。\n2. 使用映射 $c = i \\cdot K + j$ 为所有 $(i, j)$ 对标记流。对于给定的 $(i, j)$，PRNG 的输出在不同调度下必须相同，因为其值仅取决于 $c$ 和 $s$。\n3. 在以下情况下验证可复现性：\n   - 行主序嵌套循环。\n   - 使用分块大小 $T_i$ 和 $T_j$ 的循环分块。\n   - 融合为关于 $c$ 的单个循环。\n   - 通过排列计数器 $c$ 的序列进行任意重排序。\n4. 通过展示当 $s$ 改变时输出会改变，而当 $s$ 固定时可复现性依然保持，来验证改变种子 $s$ 的效果。\n\n测试套件：\n- 程序必须运行以下五个测试用例，并为每个用例返回一个布尔值，以表明所需属性是否成立。\n  - 测试 $1$（行主序与分块）：\n    - 参数：$N = 4$, $K = 5$, $T_i = 2$, $T_j = 3$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有的 $(i, j)$，行主序遍历和分块遍历的输出是相同的。\n  - 测试 $2$（嵌套与融合）：\n    - 参数：$N = 5$, $K = 7$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有的 $(i, j)$，嵌套遍历和对 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 的融合遍历的输出是相同的。\n  - 测试 $3$（边界情况 $K = 1$）：\n    - 参数：$N = 8$, $K = 1$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有的 $i$，嵌套遍历和对 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 的融合遍历的输出是相同的，其中当 $K=1$ 时 $c=i$。\n  - 测试 $4$（种子改变与可复现性）：\n    - 参数：$N = 3$, $K = 4$, $s_1 = 0x0123456789ABCDEF$, $s_2 = 0xF0E1D2C3B4A59687$。\n    - 属性：\n      - 使用固定的 $s_1$，对于所有的 $(i, j)$，行主序遍历和分块遍历的输出是相同的。\n      - 当 $s_1 \\ne s_2$ 时，至少存在一个 $(i, j)$，使得 $F(s_1, c) \\ne F(s_2, c)$。\n    - 只有当两个属性都满足时，测试才返回 $true$。\n  - 测试 $5$（任意排列）：\n    - 参数：$N = 3$, $K = 7$, $s = 0x0123456789ABCDEF$。\n    - 属性：对于所有的 $(i, j)$，在计数器 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$ 的任意排列下的输出与行主序遍历的输出匹配。\n\n最终输出格式：\n- 您的程序应产生单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果，例如 $[result_1,result_2,result_3,result_4,result_5]$，其中每个 $result_k$ 是 $True$ 或 $False$。不应打印任何额外文本。\n- 程序必须是自包含的，不需要任何输入，并且必须能够在现代环境中直接运行。\n\n此问题不涉及物理单位或角度，因此不需要单位转换。", "solution": "该解决方案建立在两个核心原则之上：创建一个无状态、确定性的伪随机数生成器（PRNG），以及应用一个从多维循环空间到一维计数器空间的双射映射。\n\n**1. 无状态确定性原则**\n\nPRNG 通常是一个有状态函数，每次调用都会更新内部状态以生成序列中的下一个数。这种方法在并行环境中存在问题，因为对共享状态的并发更新需要同步，这会引入开销，并根据线程调度导致输出序列的不确定性。\n\n解决方案是使用一个无状态的 PRNG，它是一个纯函数 $F(s, c)$，其输出完全取决于其输入：一个全局种子 $s$ 和一个计数器 $c$。它在两次调用之间不维护任何内部状态。因此，对于给定的种子 $s$ 和计数器值 $c$，函数 $F(s, c)$ 将始终产生完全相同的输出，无论它在何时或哪个处理器上执行。\n\n对于此问题，我们实现这样一个生成 $64$ 位无符号整数的函数 $F(s, c)$。一个稳健的选择是基于 `splitmix64` 算法的函数。该函数将种子 $s$ 和计数器 $c$ 组合成一个初始值，然后应用一系列的位移、异或操作以及与预定的大素数常数的乘法。这些操作能有效地混合输入的比特，以产生具有良好统计随机性的输出。所有算术运算均使用 $64$ 位无符号整数运算，确保溢出时回绕，这对算法的性质至关重要。\n\n设 $s$ 和 $c$ 为 $64$ 位无符号整数。函数 $F(s, c)$ 定义如下，其中所有操作均在模 $2^{64}$ 下执行：\n1.  初始化状态：$x = s + c$。\n2.  第一轮混合：$x = (x \\oplus (x \\gg 30)) \\cdot 0xBF58476D1CE4E5B9$。\n3.  第二轮混合：$x = (x \\oplus (x \\gg 27)) \\cdot 0x94D049BB133111EB$。\n4.  最终混合：$x = x \\oplus (x \\gg 31)$。\n结果是 $x$ 的最终值。\n\n**2. 双射映射原则**\n\n为了使无状态 PRNG 在多维问题空间（例如关于索引 $(i, j)$ 的嵌套循环）中有用，我们必须唯一地标记该空间中的每个点。问题指定了一个从循环索引对 $(i, j)$ 到单个整数计数器 $c$ 的双射映射。给定的映射是一个标准的行主序线性化：\n$$c = i \\cdot K + j$$\n其中 $i \\in \\{0, 1, \\dots, N-1\\}$ 且 $j \\in \\{0, 1, \\dots, K-1\\}$。此函数保证每个唯一的索引对 $(i, j)$ 都映射到一个唯一的计数器 $c \\in \\{0, 1, \\dots, N \\cdot K - 1\\}$。这种唯一性是将随机数生成与循环执行顺序解耦的关键。\n\n**3. 调度变化下的不变性**\n\n通过复合双射映射和无状态 PRNG，我们得到了一个函数 $G(s, i, j) = F(s, i \\cdot K + j)$，它为循环迭代空间中的每个点 $(i, j)$ 生成一个伪随机数。\n\n不同的循环执行调度，例如：\n-   **行主序遍历**：对每个 $i$ 遍历 $j$。\n-   **循环分块**：将迭代空间分解为更小的矩形分块并遍历这些分块。\n-   **循环融合**：将嵌套循环折叠成一个关于计数器 $c$ 的单循环。\n-   **任意排列**：以一种打乱的、非顺序的次序访问点 $(i, j)$。\n\n这些仅仅是为所有对 $(i, j)$ 评估函数 $G(s, i, j)$ 的不同顺序。由于任何特定对的 $G(s, i, j)$ 值都独立于任何其他对的评估顺序，因此当生成的数字最终集合被组织成一个 $N \\times K$ 的网格时，在所有调度下都将是相同的。\n\n提供的测试套件验证了这种不变性。\n-   **测试 1 和 4**：比较行主序遍历与分块遍历。每个 $(i, j)$ 生成的值都基于相同的 $c = i \\cdot K + j$，因此结果数字集合必须相同。\n-   **测试 2 和 3**：比较嵌套行主序遍历与关于 $c$ 的融合循环。融合循环直接使用 $c$，而嵌套循环首先计算 $c = i \\cdot K + j$。逆映射 $i = \\lfloor c/K \\rfloor, j = c \\pmod K$ 确保为给定 $c$ 计算的值被放置在正确的 $(i, j)$ 位置。结果必须匹配。\n-   **测试 4**：验证改变种子 $s$ 会改变输出，从而证实了 PRNG 对种子的敏感性，这是一项基本要求。\n-   **测试 5**：比较行主序遍历与任意排列的执行顺序。这是对调度不变性的最有力证明，证明了只要从 $0$ 到 $N \\cdot K - 1$ 的每个计数器值 $c$ 都被精确处理一次，最终结果就是确定性的。\n\n该实现将证实所有这些属性都成立，从而为每个测试用例得出 `True` 值。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef F(s, c):\n    \"\"\"\n    A stateless, counter-based PRNG that produces a 64-bit unsigned integer.\n    The function is based on the splitmix64 algorithm.\n    It is a pure function of the seed 's' and the counter 'c'.\n    \"\"\"\n    # Ensure inputs and all intermediate calculations use 64-bit unsigned integers.\n    s_64 = np.uint64(s)\n    c_64 = np.uint64(c)\n\n    # Combine seed and counter to initialize the state.\n    state = s_64 + c_64\n\n    # The splitmix64 mixing function.\n    state = (state ^ (state >> np.uint64(30))) * np.uint64(0xbf58476d1ce4e5b9)\n    state = (state ^ (state >> np.uint64(27))) * np.uint64(0x94d049bb133111eb)\n    state = state ^ (state >> np.uint64(31))\n    \n    return state\n\ndef generate_row_major(N, K, s):\n    \"\"\"Generates PRNs in a row-major nested loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i in range(N):\n        for j in range(K):\n            c = i * K + j\n            results[i, j] = F(s, c)\n    return results\n\ndef generate_tiled(N, K, Ti, Tj, s):\n    \"\"\"Generates PRNs in a tiled loop traversal.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for i_tile in range(0, N, Ti):\n        for j_tile in range(0, K, Tj):\n            for i in range(i_tile, min(i_tile + Ti, N)):\n                for j in range(j_tile, min(j_tile + Tj, K)):\n                    c = i * K + j\n                    results[i, j] = F(s, c)\n    return results\n\ndef generate_fused(N, K, s):\n    \"\"\"Generates PRNs in a single, fused loop over the counter 'c'.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    for c in range(N * K):\n        i = c // K\n        j = c % K\n        results[i, j] = F(s, c)\n    return results\n\ndef generate_permuted(N, K, s):\n    \"\"\"Generates PRNs by processing counters in a permuted, arbitrary order.\"\"\"\n    results = np.zeros((N, K), dtype=np.uint64)\n    counters = np.arange(N * K, dtype=np.uint64)\n    \n    # Use a fixed seed for the permutation to ensure the test is deterministic.\n    rng = np.random.default_rng(seed=42)\n    rng.shuffle(counters)\n    \n    for c in counters:\n        c_int = int(c)\n        i = c_int // K\n        j = c_int % K\n        results[i, j] = F(s, c)\n    return results\n\ndef solve():\n    \"\"\"\n    Runs the test suite to verify the properties of the stateless,\n    counter-based PRNG scheme.\n    \"\"\"\n    test_cases = [\n        # Test 1: Row-major vs. Tiled\n        {'N': 4, 'K': 5, 'Ti': 2, 'Tj': 3, 's': 0x0123456789ABCDEF},\n        # Test 2: Nested vs. Fused\n        {'N': 5, 'K': 7, 's': 0x0123456789ABCDEF},\n        # Test 3: Boundary case K=1\n        {'N': 8, 'K': 1, 's': 0x0123456789ABCDEF},\n        # Test 4: Seed change vs. reproducibility\n        {'N': 3, 'K': 4, 's1': 0x0123456789ABCDEF, 's2': 0xF0E1D2C3B4A59687},\n        # Test 5: Arbitrary permutation\n        {'N': 3, 'K': 7, 's': 0x0123456789ABCDEF},\n    ]\n\n    results = []\n\n    # --- Test 1: Row-major vs. Tiled ---\n    p = test_cases[0]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_tiled = generate_tiled(p['N'], p['K'], p['Ti'], p['Tj'], p['s'])\n    results.append(np.array_equal(res_row_major, res_tiled))\n\n    # --- Test 2: Nested vs. Fused ---\n    p = test_cases[1]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n\n    # --- Test 3: Boundary case K=1 ---\n    p = test_cases[2]\n    res_nested = generate_row_major(p['N'], p['K'], p['s'])\n    res_fused = generate_fused(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_nested, res_fused))\n    \n    # --- Test 4: Seed change vs. reproducibility ---\n    p = test_cases[3]\n    # Tiling requires tile sizes. We use a reasonable choice for the test.\n    Ti_t4, Tj_t4 = 2, 2\n    # Property 1: Reproducibility with fixed seed s1\n    res_row_major_s1 = generate_row_major(p['N'], p['K'], p['s1'])\n    res_tiled_s1 = generate_tiled(p['N'], p['K'], Ti_t4, Tj_t4, p['s1'])\n    prop1 = np.array_equal(res_row_major_s1, res_tiled_s1)\n    # Property 2: Different outputs for different seeds\n    res_row_major_s2 = generate_row_major(p['N'], p['K'], p['s2'])\n    prop2 = not np.array_equal(res_row_major_s1, res_row_major_s2)\n    results.append(prop1 and prop2)\n\n    # --- Test 5: Arbitrary permutation ---\n    p = test_cases[4]\n    res_row_major = generate_row_major(p['N'], p['K'], p['s'])\n    res_permuted = generate_permuted(p['N'], p['K'], p['s'])\n    results.append(np.array_equal(res_row_major, res_permuted))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3170077"}]}