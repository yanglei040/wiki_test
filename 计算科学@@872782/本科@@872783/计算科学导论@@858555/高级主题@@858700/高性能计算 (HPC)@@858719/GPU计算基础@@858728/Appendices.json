{"hands_on_practices": [{"introduction": "GPU的高性能在很大程度上依赖于拥有足够多的活动线程束（warps）来隐藏内存访问延迟，而“占用率”（occupancy）正是衡量这一点的关键指标。本练习将指导你根据流式多处理器（SM）的有限硬件资源（如寄存器和共享内存）来计算一个内核的理论最大占用率。通过这个实践[@problem_id:3139038]，你将学会如何识别限制并行度的资源瓶颈，并理解单个线程的资源消耗与整体 GPU 吞吐量之间的重要权衡。", "problem": "考虑一个由相同的流式多处理器 (SM) 组成的图形处理单元 (GPU)。每个 SM 都有有限的硬件资源：容量为 $R_{\\mathrm{SM}}$ 的寄存器文件（以 $32$ 位寄存器的数量计算），容量为 $S_{\\mathrm{SM}}$ 字节的共享内存，容量为 $T_{\\mathrm{SM}}$ 线程的线程槽，以及在任何时候最多 $B_{\\max}$ 个驻留块的架构限制。一个包含 $b$ 个线程的线程块会消耗寄存器，因为每个线程使用 $r$ 个寄存器；它也会消耗共享内存，因为每个块在共享内存中分配 $s$ 字节。基本约束是：一个 SM 上所有驻留块使用的总寄存器数不能超过 $R_{\\mathrm{SM}}$，使用的总共享内存不能超过 $S_{\\mathrm{SM}}$，总线程数不能超过 $T_{\\mathrm{SM}}$，并且块的数量不能超过 $B_{\\max}$。所有计数均为整数，且一个 SM 仅调度整个块。占用率是一个 SM 上被驻留线程填充的线程槽的比例，定义为驻留线程数除以 $T_{\\mathrm{SM}}$，并且其值不能超过 $1$。\n\n给定一个特定的 GPU，其参数为 $R_{\\mathrm{SM}}=65536$，$S_{\\mathrm{SM}}=98304\\,\\mathrm{bytes}$，$T_{\\mathrm{SM}}=2048$ 和 $B_{\\max}=16$。考虑两个内核：\n\n- 内核 A：每线程寄存器数 $r=64$，每块共享内存 $s=12288\\,\\mathrm{bytes}$，每块线程数 $b=256$。\n- 内核 B (基准)：每线程寄存器数 $r_{0}=32$，每块共享内存 $s_{0}=8192\\,\\mathrm{bytes}$，每块线程数 $b_{0}=128$。\n\n使用基本原理和上述资源限制，确定每个内核在单个 SM 上可以并发调度的最大驻留块数。由此，计算每个内核在单个 SM 上的占用率。最后，假设一个简化的性能模型，其中吞吐量与占用率成正比，运行时间与吞吐量成反比。在此模型下，计算内核 A 的运行时间与内核 B 的运行时间之比（即 $\\text{runtime}_{A}/\\text{runtime}_{B}$）。将您的最终答案四舍五入到四位有效数字，并表示为一个无量纲小数。", "solution": "首先根据给定标准验证问题。\n\n**步骤 1：提取给定信息**\n提供了以下数据和定义：\n- GPU 流式多处理器 (SM) 资源：\n  - 寄存器文件容量：$R_{\\mathrm{SM}} = 65536$ 个寄存器。\n  - 共享内存容量：$S_{\\mathrm{SM}} = 98304$ 字节。\n  - 线程槽容量：$T_{\\mathrm{SM}} = 2048$ 个线程。\n  - 最大驻留块数：$B_{\\max} = 16$。\n- 每个块的内核资源消耗：\n  - 每线程寄存器数：$r$。\n  - 每块线程数：$b$。\n  - 每块共享内存：$s$。\n- $N$ 个驻留块的约束条件：\n  1. 总寄存器数：$N \\times b \\times r \\le R_{\\mathrm{SM}}$。\n  2. 总共享内存：$N \\times s \\le S_{\\mathrm{SM}}$。\n  3. 总线程数：$N \\times b \\le T_{\\mathrm{SM}}$。\n  4. 总块数：$N \\le B_{\\max}$。\n- 内核 A 参数：\n  - $r_A = 64$ 个寄存器/线程。\n  - $s_A = 12288$ 字节/块。\n  - $b_A = 256$ 个线程/块。\n- 内核 B 参数（基准）：\n  - $r_B = 32$ 个寄存器/线程。\n  - $s_B = 8192$ 字节/块。\n  - $b_B = 128$ 个线程/块。\n- 占用率定义：$\\frac{\\text{驻留线程数}}{T_{\\mathrm{SM}}}$。\n- 性能模型：吞吐量与占用率成正比，运行时间与吞吐量成反比。\n\n**步骤 2：使用提取的给定信息进行验证**\n对问题的有效性进行评估：\n- **科学依据：** 该问题使用了 GPU 资源分配和占用率计算的标准简化模型。寄存器、共享内存、线程块和 SM 限制等概念是 GPU 架构和编程（例如，在 CUDA 中）的基础。所提供的硬件资源值和内核配置对于现代 GPU 而言是现实的。\n- **适定性：** 所有必要的变量、常数和关系都已明确定义。该问题是自包含的，并为唯一的数值解提供了清晰的路径。\n- **客观性：** 问题以精确、定量的术语陈述，没有任何主观或模棱两可的语言。\n\n该问题没有表现出任何列出的缺陷（例如，科学上不健全、不完整、矛盾或不可行）。它是计算科学领域中一个定义明确的计算问题。\n\n**步骤 3：结论与行动**\n问题被判定为有效。将提供解决方案。\n\n**求解推导**\n\n问题的核心是确定每个内核在单个 SM 上可以并发驻留的最大块数 $N$。这个数字受到 SM 有限资源的限制。由于 SM 只能调度完整的块，因此每个资源限制所支持的最大块数是总资源容量与每块资源消耗量之比的向下取整。驻留块的总最大数 $N$ 是这些单个限制中的最小值。\n\n对于一个每块有 $b$ 个线程、每线程有 $r$ 个寄存器、每块有 $s$ 字节共享内存的内核，最大块数 $N$ 由下式给出：\n$N = \\min( N_{\\text{reg}}, N_{\\text{smem}}, N_{\\text{thread}}, N_{\\text{block}} )$\n其中：\n- $N_{\\text{reg}} = \\lfloor \\frac{R_{\\mathrm{SM}}}{b \\times r} \\rfloor$（来自寄存器的限制）\n- $N_{\\text{smem}} = \\lfloor \\frac{S_{\\mathrm{SM}}}{s} \\rfloor$（来自共享内存的限制）\n- $N_{\\text{thread}} = \\lfloor \\frac{T_{\\mathrm{SM}}}{b} \\rfloor$（来自线程槽的限制）\n- $N_{\\text{block}} = B_{\\max}$（架构对块的限制）\n\n一旦为每个内核找到 $N$，就可以计算占用率。驻留线程的数量为 $N \\times b$。那么，占用率 $O$ 为：\n$O = \\frac{N \\times b}{T_{\\mathrm{SM}}}$\n\n最后，根据性能模型推导出运行时间比率。\n运行时间 $\\propto \\frac{1}{\\text{吞吐量}}$ 且 吞吐量 $\\propto O$。\n因此，运行时间 $\\propto \\frac{1}{O}$。\n运行时间的比率为 $\\frac{\\text{runtime}_A}{\\text{runtime}_B} = \\frac{1/O_A}{1/O_B} = \\frac{O_B}{O_A}$。\n\n**内核 A 分析**\n- 参数：$r_A=64$，$s_A=12288$，$b_A=256$。\n- SM 限制：$R_{\\mathrm{SM}}=65536$，$S_{\\mathrm{SM}}=98304$，$T_{\\mathrm{SM}}=2048$，$B_{\\max}=16$。\n\n1.  计算内核 A 的各个块限制：\n    - 寄存器限制：$N_{A, \\text{reg}} = \\lfloor \\frac{65536}{256 \\times 64} \\rfloor = \\lfloor \\frac{65536}{16384} \\rfloor = \\lfloor 4 \\rfloor = 4$。\n    - 共享内存限制：$N_{A, \\text{smem}} = \\lfloor \\frac{98304}{12288} \\rfloor = \\lfloor 8 \\rfloor = 8$。\n    - 线程限制：$N_{A, \\text{thread}} = \\lfloor \\frac{2048}{256} \\rfloor = \\lfloor 8 \\rfloor = 8$。\n    - 架构块限制：$N_{A, \\text{block}} = 16$。\n\n2.  确定内核 A 的最大驻留块数：\n    $N_A = \\min(4, 8, 8, 16) = 4$ 个块。\n    内核 A 的限制因素是寄存器文件容量。\n\n3.  计算内核 A 的占用率：\n    驻留线程数 = $N_A \\times b_A = 4 \\times 256 = 1024$。\n    $O_A = \\frac{1024}{T_{\\mathrm{SM}}} = \\frac{1024}{2048} = 0.5$。\n\n**内核 B 分析**\n- 参数：$r_B=32$，$s_B=8192$，$b_B=128$。\n- SM 限制相同。\n\n1.  计算内核 B 的各个块限制：\n    - 寄存器限制：$N_{B, \\text{reg}} = \\lfloor \\frac{65536}{128 \\times 32} \\rfloor = \\lfloor \\frac{65536}{4096} \\rfloor = \\lfloor 16 \\rfloor = 16$。\n    - 共享内存限制：$N_{B, \\text{smem}} = \\lfloor \\frac{98304}{8192} \\rfloor = \\lfloor 12 \\rfloor = 12$。\n    - 线程限制：$N_{B, \\text{thread}} = \\lfloor \\frac{2048}{128} \\rfloor = \\lfloor 16 \\rfloor = 16$。\n    - 架构块限制：$N_{B, \\text{block}} = 16$。\n\n2.  确定内核 B 的最大驻留块数：\n    $N_B = \\min(16, 12, 16, 16) = 12$ 个块。\n    内核 B 的限制因素是共享内存容量。\n\n3.  计算内核 B 的占用率：\n    驻留线程数 = $N_B \\times b_B = 12 \\times 128 = 1536$。\n    $O_B = \\frac{1536}{T_{\\mathrm{SM}}} = \\frac{1536}{2048} = \\frac{3}{4} = 0.75$。\n\n**运行时间比率计算**\n内核 A 的运行时间与内核 B 的运行时间之比为：\n$\\frac{\\text{runtime}_A}{\\text{runtime}_B} = \\frac{O_B}{O_A} = \\frac{0.75}{0.5} = 1.5$。\n\n问题要求答案四舍五入到四位有效数字。\n$1.5$ 表示为 $1.500$。", "answer": "$$\\boxed{1.500}$$", "id": "3139038"}, {"introduction": "优化 GPU 内核性能的一个核心环节是确保高效的内存访问。当一个线程束（warp）中的线程访问非连续的内存地址时，会导致多次独立的内存事务，这种“非合并访问”（non-coalesced access）会严重降低实际的内存带宽。本练习将让你亲手计算一个跨步（strided）内存访问模式所产生的内存事务数量[@problem_id:3138937]，从而量化其性能影响，并探索如何通过数据对齐填充来有效减少事务数量，提升内存访问效率。", "problem": "图形处理器 (GPU) 以包含 $32$ 个线程的线程束 (warp) 为单位执行内存操作。全局内存以 $128$ 字节的固定大小段 (segment) 提供服务，一个线程束对其请求的字 (word) 所在的每一个不同的 $128$ 字节段，都会生成一次内存事务 (memory transaction)。考虑一个内核 (kernel)，其中线程束中的每个线程从全局内存中的一个数组加载一个 $4$ 字节的浮点值。线程 $t \\in \\{0,1,\\ldots,31\\}$ 访问的地址是\n$$\nA(t) \\;=\\; A_{0} \\;+\\; \\delta \\;+\\; t \\, s \\, b,\n$$\n其中 $A_{0}$ 与一个 $128$ 字节的边界对齐，$\\delta$ 是从该边界开始的字节偏移量，$s$ 是连续线程之间以元素为单位的步长 (stride)，$b=4$ 字节是元素大小。假设对于以下参数，没有单个的 $4$ 字节访问会跨越一个 $128$ 字节的边界。\n\n假设 $s=3$ 且 $\\delta=44$ 字节。\n\n仅使用上述定义和基本整数算术，确定一个线程束在这些参数下生成的 $128$ 字节事务的数量。然后，确定必须添加到基地址的最小非负填充量 $p$ （以字节为单位）（即，用 $\\delta+p$ 替换 $\\delta$），以使第一个访问的地址与一个 $128$ 字节的段边界对齐，并重新计算在这种填充下的 $128$ 字节事务数量。\n\n请完整报告您的推理过程，但为了评分，请仅提供最终的最小填充量 $p$ 作为您的答案。最终填充量以字节表示。无需四舍五入。", "solution": "问题要求计算将内存访问模式的起始地址与一个 $128$ 字节的段边界对齐所需的最小非负填充量 $p$，并确定在有和没有此填充两种情况下的内存事务数量。\n\n首先，让我们将给定的信息形式化。一个线程束由 $32$ 个线程组成，索引为 $t \\in \\{0,\n1, \\ldots, 31\\}$。每个线程访问一个 $4$ 字节的字。内存段大小为 $128$ 字节。线程 $t$ 访问的起始字节地址由以下函数给出：\n$$A(t) = A_0 + \\delta + t \\cdot s \\cdot b$$\n其中 $A_0$ 是一个与 $128$ 字节边界对齐的基地址（即 $A_0 \\pmod{128} = 0$），$\\delta$ 是初始字节偏移量，$s$ 是以元素为单位的步长，$b=4$ 字节是一个元素的大小。对于线程束中任何线程访问的每个唯一的 $128$ 字节段，都会生成一个内存事务。包含地址 $A$ 处字节的段由索引 $\\lfloor A / 128 \\rfloor$ 标识。\n\n初始情况的具体参数是 $s=3$ 和 $\\delta=44$ 字节。因此，线程 $t$ 访问的地址是：\n$$A(t) = A_0 + 44 + t \\cdot 3 \\cdot 4 = A_0 + 44 + 12t$$\n由于 $A_0$ 与一个 $128$ 字节的边界对齐，地址 $A(t)$ 的段索引为 $\\lfloor (A_0 + 44 + 12t) / 128 \\rfloor = A_0/128 + \\lfloor (44 + 12t) / 128 \\rfloor$。常数项 $A_0/128$ 只是将所有段索引移动一个整数值，不影响访问的唯一段的数量。因此，我们可以通过考虑相对于 $A_0$ 的地址来分析内存访问模式，我们将其表示为 $A_{rel}(t) = 44 + 12t$。\n\n为了找到事务的数量，我们必须确定对于 $t \\in \\{0, 1, \\ldots, 31\\}$，唯一的段索引 $\\lfloor A_{rel}(t) / 128 \\rfloor$ 的数量。\n第一个线程（$t=0$）访问的地址是 $A_{rel}(0) = 44 + 12(0) = 44$。\n此访问的段索引是 $\\lfloor 44 / 128 \\rfloor = 0$。\n\n最后一个线程（$t=31$）访问的地址是 $A_{rel}(31) = 44 + 12(31) = 44 + 372 = 416$。\n此访问的段索引是 $\\lfloor 416 / 128 \\rfloor = 3$。\n\n线程束访问的地址是单调的，从 $44$ 开始，连续线程之间的步长为 $12$ 字节。由于以字节为单位的步长（$12$）小于段大小（$128$），线程将访问第一个和最后一个段之间的所有中间段。因此，访问的唯一段的总数是最后一个和第一个段索引之差再加一。\n事务数量 = $(\\text{最后一个段索引}) - (\\text{第一个段索引}) + 1 = 3 - 0 + 1 = 4$。\n所以，对于初始参数，线程束生成 $4$ 个内存事务。\n\n接下来，我们必须确定需要添加到基地址的最小非负填充量 $p$（以字节为单位），以使第一个访问的地址与 $128$ 字节的段边界对齐。对于线程 $t=0$，新的第一个地址将是 $A'(0) = A_0 + \\delta + p$。\n给定 $\\delta = 44$，新的第一个地址是 $A'(0) = A_0 + 44 + p$。\n为了使 $A'(0)$ 与一个 $128$ 字节的边界对齐，它必须是 $128$ 的倍数。\n$$A_0 + 44 + p = k \\cdot 128$$\n对于某个整数 $k$。由于 $A_0$ 已经是 $128$ 的倍数，我们可以写成 $A_0 = m \\cdot 128$，对于某个整数 $m$。\n$$m \\cdot 128 + 44 + p = k \\cdot 128$$\n$$44 + p = (k-m) \\cdot 128$$\n设 $k' = k-m$。我们需要找到最小的非负整数 $p$，使得对于某个整数 $k'$，有 $44 + p = k' \\cdot 128$。\n为确保 $p \\ge 0$，我们需要 $k' \\cdot 128 \\ge 44$。由于 $k'$ 必须是整数，$k'$ 的最小可能值为 $1$。\n对于 $k' = 1$，我们有：\n$$44 + p = 128 \\implies p = 128 - 44 = 84$$\n所需的最小非负填充量是 $p=84$ 字节。\n\n最后，我们重新计算使用此填充后的内存事务数量。新的偏移量是 $\\delta' = \\delta + p = 44 + 84 = 128$。\n相对于 $A_0$ 的新地址函数是：\n$$A'_{rel}(t) = \\delta' + t \\cdot s \\cdot b = 128 + t \\cdot 3 \\cdot 4 = 128 + 12t$$\n第一个线程（$t=0$）现在访问 $A'_{rel}(0) = 128$。段索引是 $\\lfloor 128 / 128 \\rfloor = 1$。\n最后一个线程（$t=31$）访问 $A'_{rel}(31) = 128 + 12(31) = 128 + 372 = 500$。段索引是 $\\lfloor 500 / 128 \\rfloor = 3$。\n事务的数量同样是段索引之差再加一：\n事务数量 = $3 - 1 + 1 = 3$。\n通过添加 $84$ 字节的填充，内存事务的数量从 $4$ 减少到 $3$，提高了内存访问效率。\n\n问题要求的是最小填充量 $p$。根据我们的计算，这个值是 $84$。", "answer": "$$\n\\boxed{84}\n$$", "id": "3138937"}, {"introduction": "高效的 GPU 编程不仅在于管理资源和优化内存访问，更在于选择适合硬件架构的算法。一个看似并行度很高的算法，如果频繁使用昂贵的同步操作，其性能可能远不如一个更“了解”GPU架构的替代方案。本练习将引导你运用“功-跨度”（work-span）模型，深入分析和比较两种并行规约（reduction）算法[@problem_id:3138934]：一种是经典的、依赖块级同步的二叉树方法，另一种是针对 GPU 优化的、以线程束为中心的方法。通过计算，你将清晰地看到，通过最大化利用线程束内部的隐式同步并最小化昂贵的块级同步（如 `__syncthreads()`），我们能实现多大的性能提升。", "problem": "图形处理器 (GPU) 以单指令多线程 (SIMT) 方式执行线程：一个线程束 (warp) 内的线程以锁步 (lockstep) 方式执行，而块级屏障同步（例如，统一计算设备架构 (CUDA) 函数 `__syncthreads()`）确保块内所有线程在任何线程继续执行之前都到达同一点。在并行算法分析中，总工作量 (work) 是原始操作的总数，而跨度 (span)（也称为关键路径长度）是必须顺序执行的最长依赖步骤链的长度。考虑在一个块内使用共享内存将 $B$ 个浮点值归约为单个总和。假设每次浮点加法成本为 $T_{\\text{add}}$ 个周期，每次块级屏障成本为 $T_{\\text{sync}}$ 个周期，并且您可以忽略全局内存传输成本以及除这两种成本之外的任何指令级开销。\n\n您将比较针对 $B=256$ 个线程和线程束大小 $W=32$ 的两种块内归约策略：\n\n1. 完全在共享内存中实现的二叉树归约，其中在每个归约层级，活动线程对共享内存中的元素对执行加法，并使用块级屏障以使线程在进入下一层级之前重新汇合。假设在初始写入共享内存后有一个屏障，随后每个归约层级有一个屏障。\n\n2. 以线程束为中心的归约，其中每个线程束首先仅使用线程束同步指令（在线程束内不需要块级屏障）归约其 $W$ 个值，然后每个线程束的0号通道线程将其部分和写入共享内存，单个块级屏障确保这些部分和的可见性，最后由单个线程束使用线程束同步指令归约 $B/W$ 个部分和，无需再使用块级屏障。\n\n从总工作量和跨度的核心定义以及上述 SIMT 执行模型出发，完成以下任务：\n\n- 推导出每种策略的总工作量和跨度，表示为 $B$、$W$、$T_{\\text{add}}$ 和 $T_{\\text{sync}}$ 的函数。\n- 根据这些推导，确定每种策略执行的块级屏障同步次数，以及峰值共享内存占用（以内存最密集步骤中部分和同时占用的4字节槽位数衡量）。\n- 使用您的跨度表达式，计算在 $B=256$，$W=32$，$T_{\\text{add}}=4$ 个周期和 $T_{\\text{sync}}=80$ 个周期的情况下，二叉树策略的预测跨度时间与以线程束为中心的策略的预测跨度时间之比 $R$。\n\n将您的最终比率 $R$ 四舍五入到四位有效数字。将 $R$ 报告为纯数字（无单位）。", "solution": "对问题陈述进行了严格审查，并根据既定标准进行了验证。\n\n### 步骤1：提取已知条件\n- **执行模型**：单指令多线程 (SIMT)。\n- **实体**：线程被分组为线程束，线程束被分组为块。\n- **同步**：线程束级执行是锁步的（隐式同步）。块级同步通过屏障（例如 `__syncthreads()`）是显式的。\n- **定义**：\n    - **总工作量**：原始操作的总数。\n    - **跨度**：必须顺序执行的最长依赖步骤链的长度（关键路径长度）。\n- **问题设置**：在一个块内将 $B$ 个浮点值归约为单个总和。\n- **成本模型**：\n    - 浮点加法成本：$T_{\\text{add}}$ 个周期。\n    - 块级屏障成本：$T_{\\text{sync}}$ 个周期。\n    - 全局内存和其他指令开销将被忽略。\n- **参数**：\n    - 线程数（和值的数量）：$B = 256$。\n    - 线程束大小：$W = 32$。\n    - $T_{\\text{add}} = 4$ 个周期。\n    - $T_{\\text{sync}} = 80$ 个周期。\n- **策略1（二叉树归约）**：\n    - 完全在共享内存中实现。\n    - 在每个归约层级，活动线程执行对元素的加法。\n    - 使用块级屏障在下一层级之前重新汇合线程。\n    - 假设：在初始共享内存写入后有一个屏障，随后每个归约层级有一个屏障。\n- **策略2（以线程束为中心的归约）**：\n    - 每个线程束使用线程束同步指令归约其 $W$ 个值（无需块级屏障）。\n    - 每个线程束的0号通道线程将其部分和写入共享内存。\n    - 单个块级屏障确保部分和的可见性。\n    - 单个线程束使用线程束同步指令归约 $B/W$ 个部分和。\n\n### 步骤2：使用提取的已知条件进行验证\n- **科学基础**：该问题在并行计算和GPU架构的原理方面有很好的基础。SIMT模型、总工作量-跨度分析以及两种归约策略都是计算科学中的标准概念。\n- **定义明确**：该问题定义清晰，具有特定的参数、成本模型和算法描述。它要求一个唯一的、可计算的比率。\n- **客观性**：语言精确且技术性强，没有主观性陈述。成本模型的假设已明确说明。\n\n### 步骤3：结论与行动\n该问题有效。这是一个定义明确的并行算法分析练习。将提供完整的解决方案。\n\n### 解题推导\n\n我们首先为每种策略推导总工作量、跨度、屏障数量和共享内存占用的符号表达式。\n\n将 $B$ 个数归约为单个总和的总工作量是所需的加法次数，恒为 $B-1$。因此，对于两种策略，总工作量均为 $(B-1)T_{\\text{add}}$。我们将重点关注差异显著的跨度。\n\n**策略1：二叉树归约**\n\n1.  **总工作量 ($W_1$)**：总加法次数为 $B-1$。总工作量为 $W_1 = (B-1) T_{\\text{add}}$。\n\n2.  **跨度 ($S_1$)**：$B$ 个元素的归约发生在 $\\log_2(B)$ 个层级中。根据问题陈述，在数据加载到共享内存后有一个初始屏障，然后在每个归约层级后有一个屏障。关键路径由一系列加法和屏障同步组成。\n    - 关键路径上的线程首先在初始屏障处等待：成本为 $T_{\\text{sync}}$。\n    - 然后它参与 $\\log_2(B)$ 个归约层级。每个层级包括一次加法和一次屏障。关键路径上线程的每个层级成本为 $T_{\\text{add}} + T_{\\text{sync}}$。\n    总跨度是这些顺序成本的总和：\n    $$S_1 = T_{\\text{sync}} (\\text{初始}) + \\sum_{i=1}^{\\log_2(B)} (T_{\\text{add}} + T_{\\text{sync}})$$\n    $$S_1 = T_{\\text{sync}} + \\log_2(B) \\cdot (T_{\\text{add}} + T_{\\text{sync}})$$\n    $$S_1 = (\\log_2(B)) T_{\\text{add}} + (1 + \\log_2(B)) T_{\\text{sync}}$$\n\n3.  **块级屏障数量 ($N_{\\text{sync},1}$)**：根据推导，有一个初始屏障和 $\\log_2(B)$ 个归约层级的每个层级一个屏障。\n    $$N_{\\text{sync},1} = 1 + \\log_2(B)$$\n\n4.  **峰值共享内存占用 ($M_1$)**：该策略要求在归约开始时将所有 $B$ 个初始值存储在共享内存中。这是内存使用量最大的点。\n    $$M_1 = B \\text{ 个槽位}$$\n\n**策略2：以线程束为中心的归约**\n\n1.  **总工作量 ($W_2$)**：总加法次数仍为 $B-1$。总工作量为 $W_2 = (B-1) T_{\\text{add}}$。\n\n2.  **跨度 ($S_2$)**：跨度是其三个顺序阶段的跨度之和。\n    - **阶段1：线程束内归约。** 所有 $B/W$ 个线程束并行操作。每个线程束将 $W$ 个值归约为一个部分和。这需要使用线程束同步操作（例如，shuffles）进行 $\\log_2(W)$ 次顺序加法，这些操作不会产生 $T_{\\text{sync}}$ 成本。此阶段的跨度由单个线程束的归约时间决定。\n      跨度（阶段1）= $(\\log_2(W)) T_{\\text{add}}$。\n    - **阶段2：块级同步。** 将 $B/W$ 个部分和写入共享内存。然后调用单个块级屏障以确保所有这些写入对所有线程都可见。\n      跨度（阶段2）= $T_{\\text{sync}}$。\n    - **阶段3：最终归约。** 单个线程束从共享内存中读取 $B/W$ 个部分和，并将它们归约为最终值。此归约使用线程束同步操作需要 $\\log_2(B/W)$ 个顺序步骤。\n      跨度（阶段3）= $(\\log_2(B/W)) T_{\\text{add}}$。\n    总跨度 $S_2$ 是这三个阶段的跨度之和：\n    $$S_2 = (\\log_2(W)) T_{\\text{add}} + T_{\\text{sync}} + (\\log_2(B/W)) T_{\\text{add}}$$\n    使用对数属性 $\\log(a) + \\log(b) = \\log(ab)$，我们简化得到：\n    $$S_2 = (\\log_2(W) + \\log_2(B/W)) T_{\\text{add}} + T_{\\text{sync}}$$\n    $$S_2 = (\\log_2(B)) T_{\\text{add}} + T_{\\text{sync}}$$\n\n3.  **块级屏障数量 ($N_{\\text{sync},2}$)**：该策略明确只使用一个此类屏障。\n    $$N_{\\text{sync},2} = 1$$\n\n4.  **峰值共享内存占用 ($M_2$)**：共享内存仅用于存储来自每个线程束的中间部分和。共有 $B/W$ 个这样的和。\n    $$M_2 = B/W \\text{ 个槽位}$$\n\n### 数值计算\n\n现在我们代入给定值：$B=256$，$W=32$，$T_{\\text{add}}=4$ 个周期，以及 $T_{\\text{sync}}=80$ 个周期。\n\n首先，我们计算对数值：\n- $\\log_2(B) = \\log_2(256) = \\log_2(2^8) = 8$。\n- $\\log_2(W) = \\log_2(32) = \\log_2(2^5) = 5$。\n- $\\log_2(B/W) = \\log_2(256/32) = \\log_2(8) = 3$。\n\n**导出量汇总：**\n\n| 指标 | 策略1（符号表达式） | 策略1（数值） | 策略2（符号表达式） | 策略2（数值） |\n|---|---|---|---|---|\n| 跨度 | $(\\log_2 B) T_{\\text{add}} + (1+\\log_2 B) T_{\\text{sync}}$ | $8 \\cdot 4 + (1+8) \\cdot 80 = 752$ 个周期 | $(\\log_2 B) T_{\\text{add}} + T_{\\text{sync}}$ | $8 \\cdot 4 + 80 = 112$ 个周期 |\n| 屏障数量 | $1 + \\log_2 B$ | $1+8=9$ | $1$ | $1$ |\n| 共享内存占用 | $B$ 个槽位 | $256$ 个槽位 | $B/W$ 个槽位 | $256/32 = 8$ 个槽位 |\n\n**计算比率 $R$**\n\n问题要求计算二叉树策略的跨度 ($S_1$) 与以线程束为中心的策略的跨度 ($S_2$) 之比 $R$。\n\n$$R = \\frac{S_1}{S_2} = \\frac{(\\log_2(B)) T_{\\text{add}} + (1 + \\log_2(B)) T_{\\text{sync}}}{(\\log_2(B)) T_{\\text{add}} + T_{\\text{sync}}}$$\n\n使用计算出的跨度数值：\n\n$$R = \\frac{752}{112}$$\n\n简化分数：\n$$R = \\frac{376}{56} = \\frac{188}{28} = \\frac{94}{14} = \\frac{47}{7}$$\n\n现在，我们计算小数值并四舍五入到四位有效数字：\n$$R = \\frac{47}{7} \\approx 6.7142857...$$\n四舍五入到四位有效数字得到 $6.714$。", "answer": "$$\\boxed{6.714}$$", "id": "3138934"}]}