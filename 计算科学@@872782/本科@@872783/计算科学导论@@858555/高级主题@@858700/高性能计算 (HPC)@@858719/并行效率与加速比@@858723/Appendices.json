{"hands_on_practices": [{"introduction": "在并行计算中，处理器之间的通信往往是主要的性能开销。这个练习探讨了一种常见的优化策略：使用数据压缩来减少通信量。通过这个练习，你将推导出一个解析条件，判断在何种情况下，压缩数据带来的计算成本低于其节省的数据传输时间，从而为评估此类权衡提供一个清晰的分析框架 [@problem_id:3169043]。", "problem": "一个数据并行模拟在 $p$ 个相同的处理单元上执行。设 $T_{1}$ 为最佳单核实现所需的墙钟时间，该实现仅包含计算，总计算时间为 $W$。在 $p$ 个处理单元上的并行实现将计算分为一个串行部分 $s \\in (0,1)$ 和一个完全并行的部分 $1-s$，其中串行部分在一个处理单元上运行，而并行部分在 $p$ 个处理单元之间均匀分配，无负载不均衡。此外，并行实现执行 $N$ 次相同的最近邻交换。在每次交换中，每个处理单元参与一个大小为 $M$ 字节的点对点消息。通信遵循标准的延迟-带宽模型：发送一个大小为 $x$ 字节的消息耗时 $L + x/B$ 秒，其中 $L$ 是延迟，$B$ 是以字节/秒为单位的持续带宽。\n\n为了减少通信量，考虑采用无损数据压缩步骤。压缩将消息大小减小一个因子 $\\eta \\in (0,1]$，因此大小为 $M$ 的消息变为 $\\eta M$。然而，压缩发出的消息和解压缩传入的消息会消耗中央处理器 (CPU) 时间。将每次交换中每个处理单元的压缩-解压缩CPU总成本建模为 $\\kappa M$ 秒，其中 $\\kappa$ 是一个以秒/字节为单位的常数。假设压缩和解压缩成本不能与通信或其他计算重叠。\n\n仅使用加速比 $S(p) = T_{1}/T_{p}$ 的定义和上述延迟-带宽通信模型，推导在固定 $p$ 值下，启用压缩能够严格提高加速比的条件。以单个符号表达式的形式，报告边界值 $\\eta^{\\ast}$（仅为 $\\kappa$ 和 $B$ 的函数），使得当且仅当 $\\eta  \\eta^{\\ast}$ 时，启用压缩可提高加速比。您的最终答案必须是 $\\eta^{\\ast}$ 的闭式解析表达式，不带单位，也不含不等式。不要对结果进行四舍五入。", "solution": "首先对问题进行验证，以确保其自洽、一致且科学合理。\n\n**步骤1：提取已知条件**\n- 处理单元数量：$p$\n- 最佳单核实现的墙钟时间：$T_{1}$\n- 单核实现的总计算时间：$W$，其中 $T_{1} = W$\n- 计算的串行部分：$s \\in (0,1)$\n- 计算的并行部分：$1-s$\n- 最近邻交换次数：$N$\n- 每次交换的消息大小（未压缩）：$M$ 字节\n- 通信延迟：$L$ 秒\n- 通信带宽：$B$ 字节/秒\n- 大小为 $x$ 字节的消息的通信成本：$L + x/B$ 秒\n- 压缩因子：$\\eta \\in (0,1]$\n- 压缩后的消息大小：$\\eta M$\n- 每次交换、每个核心的压缩-解压缩CPU总成本：$\\kappa M$ 秒\n- 压缩/解压缩成本常数：$\\kappa$ 秒/字节\n- 约束条件：压缩和解压缩成本不能与通信或其他计算重叠。\n- 加速比定义：$S(p) = T_{1}/T_{p}$\n- 目标：找到边界值 $\\eta^{\\ast}$（一个仅关于 $\\kappa$ 和 $B$ 的函数），使得当且仅当 $\\eta  \\eta^{\\ast}$ 时，启用压缩能严格提高加速比。\n\n**步骤2：使用提取的已知条件进行验证**\n问题表述清晰且科学上成立。它提出了并行计算中性能权衡的标准分析，对计算部分使用了类阿姆达尔定律（Amdahl's Law）的模型，对通信部分使用了标准的延迟-带宽模型。所有术语都有明确定义，且假设（如成本不重叠）也已明确说明，使得问题自洽且无歧义。在计算科学的背景下，这些参数都具有物理意义。问题中没有矛盾、科学谬误或主观因素。\n\n**步骤3：结论与行动**\n问题有效。将进行求解。\n\n**推导**\n\n设 $T_{p,\\text{no comp}}$ 为在 $p$ 个处理单元上不使用压缩的总墙钟时间，$T_{p,\\text{comp}}$ 为使用压缩的时间。\n\n单处理器执行时间给定为 $T_{1} = W$。\n\n并行执行时间是串行计算、并行计算和通信时间的总和。根据问题描述，这些阶段是独立的，其成本在关键路径上是可加的。\n\n不使用压缩时，执行时间 $T_{p,\\text{no comp}}$ 的组成部分为：\n1.  计算的串行部分所需时间：$sW$\n2.  计算的并行部分所需时间：$\\frac{(1-s)W}{p}$\n3.  通信所需时间：共有 $N$ 次交换，每次交换大小为 $M$ 的消息耗时 $L + \\frac{M}{B}$。总通信时间为 $N \\left(L + \\frac{M}{B}\\right)$。\n\n因此，不使用压缩的总时间为：\n$$T_{p,\\text{no comp}} = sW + \\frac{(1-s)W}{p} + N \\left(L + \\frac{M}{B}\\right)$$\n\n使用压缩时，消息大小减小为 $\\eta M$，但引入了额外的压缩和解压缩计算成本。该成本为每次交换 $\\kappa M$，且不能与其他操作重叠。\n\n使用压缩时，执行时间 $T_{p,\\text{comp}}$ 的组成部分为：\n1.  计算的串行部分所需时间：$sW$\n2.  计算的并行部分所需时间：$\\frac{(1-s)W}{p}$\n3.  压缩/解压缩所需时间：对于 $N$ 次交换中的每一次，每个处理器产生 $\\kappa M$ 的成本。增加的总CPU时间为 $N \\kappa M$。\n4.  通信所需时间：消息大小现在是 $\\eta M$。总通信时间为 $N \\left(L + \\frac{\\eta M}{B}\\right)$。\n\n因此，使用压缩的总时间为：\n$$T_{p,\\text{comp}} = sW + \\frac{(1-s)W}{p} + N \\kappa M + N \\left(L + \\frac{\\eta M}{B}\\right)$$\n\n加速比定义为 $S(p) = T_{1}/T_{p}$。设 $S_{\\text{no comp}}(p)$ 和 $S_{\\text{comp}}(p)$ 分别为不使用压缩和使用压缩时的加速比。\n$$S_{\\text{no comp}}(p) = \\frac{T_{1}}{T_{p,\\text{no comp}}}$$\n$$S_{\\text{comp}}(p) = \\frac{T_{1}}{T_{p,\\text{comp}}}$$\n\n如果 $S_{\\text{comp}}(p)  S_{\\text{no comp}}(p)$，则压缩严格提高了加速比。\n$$\\frac{T_{1}}{T_{p,\\text{comp}}}  \\frac{T_{1}}{T_{p,\\text{no comp}}}$$\n由于对于一个非平凡问题，$T_{1}=W$ 必须为正，且执行时间总是正的，我们可以对两边取倒数并反转不等号：\n$$T_{p,\\text{comp}}  T_{p,\\text{no comp}}$$\n这直观地意味着，要提高加速比，总执行时间必须减少。\n\n代入执行时间的表达式：\n$$sW + \\frac{(1-s)W}{p} + N \\kappa M + N \\left(L + \\frac{\\eta M}{B}\\right)  sW + \\frac{(1-s)W}{p} + N \\left(L + \\frac{M}{B}\\right)$$\n串行和并行计算的项 $sW$ 和 $\\frac{(1-s)W}{p}$ 在两边是公有的，可以消去。通信成本中的延迟部分 $NL$ 也可以消去。\n$$N \\kappa M + N \\frac{\\eta M}{B}  N \\frac{M}{B}$$\n假设消息数量 $N$ 和消息大小 $M$ 为正（否则通信是微不足道的，压缩也无意义），我们可以将整个不等式两边同时除以 $NM$：\n$$\\kappa + \\frac{\\eta}{B}  \\frac{1}{B}$$\n我们需要找到边界值 $\\eta^{\\ast}$，使得当且仅当 $\\eta  \\eta^{\\ast}$ 时不等式成立。为此，我们解出 $\\eta$：\n$$\\frac{\\eta}{B}  \\frac{1}{B} - \\kappa$$\n两边乘以带宽 $B$（一个正量），不等式方向不变：\n$$\\eta  B \\left(\\frac{1}{B} - \\kappa\\right)$$\n$$\\eta  1 - \\kappa B$$\n这个不等式给出了压缩有利时 $\\eta$ 需满足的条件。边界值是该不等式的右侧。\n因此，边界值 $\\eta^{\\ast}$ 为：\n$$\\eta^{\\ast} = 1 - \\kappa B$$\n改进的条件是 $\\eta  \\eta^{\\ast}$，这要求 $\\eta^{\\ast}$ 是在 $\\eta$ 的允许范围内的值。其物理意义是，无量纲乘积 $\\kappa B$ 代表了计算处理一个字节的时间与传输一个字节的时间之比。只有当这个比值小于1时，压缩才是有利的。如果 $\\kappa B \\ge 1$，那么 $\\eta^{\\ast} \\le 0$，而由于 $\\eta \\in (0,1]$，不存在能够提高性能的 $\\eta$ 值。推导出的 $\\eta^{\\ast}$ 表达式仅是 $\\kappa$ 和 $B$ 的函数，符合题目要求。", "answer": "$$\\boxed{1 - \\kappa B}$$", "id": "3169043"}, {"introduction": "理想的并行加速比通常会受到处理器数量以外的因素限制。这个思想实验探讨了多核系统中一个关键的瓶颈：共享内存的容量。通过对内存分页效应进行建模，你将发现系统架构如何对性能施加一个硬性上限，这是设计可扩展应用程序时至关重要的一课 [@problem_id:3169117]。", "problem": "一位计算科学家在一台共享内存工作站上运行一个由 $N$ 个独立任务组成的易并行工作流。当每个任务单独在单个处理核心上执行时，其计算时间是统一的 $t$，并需要 $m$ 字节的私有工作集（位于随机存取存储器 RAM 中）。因此，总的串行计算时间为 $T_{\\text{comp}} = N t$。该工作站拥有 $p$ 个相同的核心，它们共享一个容量为 $M$ 字节的 RAM。假设 $M \\geq m$，这样至少有一个任务可以驻留在内存中而无需分页。操作系统为每个核心调度最多一个任务，但当 $p m  M$ 时，会发生虚拟内存分页。在持续的稳态颠簸情况下，有效并发驻留任务数受到能容纳的最大工作集数量的限制：$p_{\\text{eff}} = \\min\\!\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$。在这些假设下：\n- 从加速比和易并行工作负载理想性能的基本定义出发，推导出实际完工时间 $T(p)$，其形式为一个理想并行计算时间与一个由有限内存容量（分页）引起的惩罚项之和。也就是说，将 $T(p)$ 表示为 $T(p) = \\text{(理想计算时间)} + \\text{(分页惩罚项)}$ 的形式，并用 $T_{\\text{comp}}$、$p$、$M$ 和 $m$ 明确地表示出分页惩罚项 $\\psi(p)$。\n- 使用加速比 $S(p)$ 关于串行时间和并行时间的定义，计算 $S(p)$ 关于 $p$、$M$ 和 $m$ 的封闭形式表达式。\n\n将最终答案以 $S(p)$ 的单一封闭形式解析表达式给出。不需要数值近似。最终的方框答案中不要包含任何单位。", "solution": "在尝试任何解决方案之前，需对问题陈述进行验证。\n\n### 步骤1：提取已知条件\n-   $N$: 独立任务的数量。\n-   $t$: 单个任务在单个核心上的计算时间。\n-   $m$: 单个任务的私有工作集大小（字节）。\n-   $T_{\\text{comp}} = N t$: 总串行计算时间。\n-   $p$: 工作站上相同核心的数量。\n-   $M$: 随机存取存储器（RAM）的总容量（字节）。\n-   假设：$M \\geq m$。\n-   $p_{\\text{eff}} = \\min\\!\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$: 有效并发驻留任务数。\n-   第一个目标：以 $T(p) = \\text{(理想计算时间)} + \\text{(分页惩罚项)}$ 的形式推导完工时间 $T(p)$，并确定分页惩罚项 $\\psi(p)$。\n-   第二个目标：计算加速比 $S(p)$ 关于 $p$、$M$ 和 $m$ 的封闭形式表达式。\n\n### 步骤2：使用提取的已知条件进行验证\n1.  **科学依据：** 该问题使用了计算科学的标准概念，包括并行加速比、易并行工作负载、共享内存，以及一个简化但合理的模型来描述因内存颠簸（虚拟内存分页）导致的性能下降。该模型中，有效并行度受限于能装入物理RAM的工作负载数量，这是一个有效且常见的一阶近似。\n2.  **适定性：** 问题提供了一个清晰、自洽的模型，包含了所有必要的变量和定义。目标明确，可以根据所给框架推导出唯一的解。\n3.  **客观性：** 问题以精确的技术语言陈述，没有主观性或模糊性。\n4.  **完整性和一致性：** 所有变量都有定义，它们之间的关系也已明确说明。假设 $M \\geq m$ 确保了问题设置的非平凡性，并允许至少一个任务运行。$p_{\\text{eff}}$ 的定义是明确的。\n5.  **现实性和可行性：** 该模型是一个简化模型，但捕捉了并行计算中一个真实的性能瓶颈。参数是符号化的，避免了数值数据的不一致性。\n6.  **结构和非平凡性：** 问题结构良好，需要进行非平凡的推理来连接理想并行性、内存约束和实际性能这些概念。这是该领域一个标准的概念性问题。\n\n### 步骤3：结论与行动\n该问题被判定为**有效**，因为其科学上合理、自洽且适定。将推导解答。\n\n### 推导过程\n解决方案的推导首先确定理想性能，然后引入内存约束以求得实际性能，最后推导出加速比。\n\n总串行计算时间，即在单个核心（$p=1$）上运行整个工作负载的时间，由 $T_1 = T_{\\text{comp}} = N t$ 给出。\n\n对于易并行工作负载，任务是独立的。在具有无限内存的理想情况下，总工作量 $T_{\\text{comp}}$ 将完美地分配到 $p$ 个可用核心上。理想的并行执行时间或完工时间将是：\n$$T_{\\text{ideal}}(p) = \\frac{T_{\\text{comp}}}{p}$$\n这一项代表了问题陈述中要求的“(理想计算时间)”。\n\n问题引入了内存约束。并发运行 $p$ 个任务所需的总内存为 $p \\cdot m$。如果 $p \\cdot m  M$，系统无法将所有工作集同时保存在RAM中，导致虚拟内存分页和性能下降（颠簸）。问题通过定义一个有效并发任务数 $p_{\\text{eff}}$ 来对此建模，它代表了系统在不因内存限制而导致性能崩溃的情况下可以维持的最大并行度。该有效并行度由下式给出：\n$$p_{\\text{eff}} = \\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$$\n在这里，$\\lfloor M/m \\rfloor$ 是能够装入总RAM $M$ 的完整任务工作集的最大数量。因此，可以并发运行的实际任务数受限于核心数 $p$ 或内存容量，取两者中较小者。\n\n实际完工时间 $T(p)$ 是总工作量 $T_{\\text{comp}}$ 除以有效并行度 $p_{\\text{eff}}$：\n$$T(p) = \\frac{T_{\\text{comp}}}{p_{\\text{eff}}} = \\frac{T_{\\text{comp}}}{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)}$$\n\n第一个目标是将 $T(p)$ 表示为理想时间与一个惩罚项 $\\psi(p)$ 的和。\n$$T(p) = T_{\\text{ideal}}(p) + \\psi(p)$$\n我们可以求解分页惩罚项 $\\psi(p)$：\n$$\\psi(p) = T(p) - T_{\\text{ideal}}(p)$$\n代入 $T(p)$ 和 $T_{\\text{ideal}}(p)$ 的表达式：\n$$\\psi(p) = \\frac{T_{\\text{comp}}}{p_{\\text{eff}}} - \\frac{T_{\\text{comp}}}{p}$$\n提出公因子 $T_{\\text{comp}}$ 并代入 $p_{\\text{eff}}$ 的定义，得到分页惩罚项的显式表达式：\n$$\\psi(p) = T_{\\text{comp}} \\left( \\frac{1}{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)} - \\frac{1}{p} \\right)$$\n当 $p \\le \\lfloor M/m \\rfloor$ 时，内存充足。在这种情况下，$\\min(p, \\lfloor M/m \\rfloor) = p$，惩罚项 $\\psi(p)$ 变为 $T_{\\text{comp}}(1/p - 1/p) = 0$，符合预期。当 $p  \\lfloor M/m \\rfloor$ 时，内存不足，$\\min(p, \\lfloor M/m \\rfloor) = \\lfloor M/m \\rfloor$，此时会产生一个非零的惩罚项 $\\psi(p) = T_{\\text{comp}}(1/\\lfloor M/m \\rfloor - 1/p)$。\n\n第二个目标是推导加速比 $S(p)$。加速比定义为串行执行时间与并行执行时间之比：\n$$S(p) = \\frac{T_1}{T(p)}$$\n我们有 $T_1 = T_{\\text{comp}}$ 和 $T(p) = T_{\\text{comp}} / p_{\\text{eff}}$。将这些代入加速比的定义中：\n$$S(p) = \\frac{T_{\\text{comp}}}{T_{\\text{comp}} / p_{\\text{eff}}}$$\n简化表达式可得：\n$$S(p) = p_{\\text{eff}}$$\n最后，我们代入 $p_{\\text{eff}}$ 的定义，以获得用 $p$、$M$ 和 $m$ 表示的加速比的封闭形式表达式：\n$$S(p) = \\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)$$\n这个结果表明，加速比随处理器数量线性增加（$S(p)=p$），直到系统内存容量饱和。超过该点（$p  \\lfloor M/m \\rfloor$）后，加速比稳定在一个常数值 $S(p) = \\lfloor M/m \\rfloor$，这表明由于内存瓶颈，增加更多处理器不会带来进一步的性能提升。", "answer": "$$\\boxed{\\min\\left(p, \\left\\lfloor \\frac{M}{m} \\right\\rfloor\\right)}$$", "id": "3169117"}, {"introduction": "理论模型（如阿姆达尔定律）虽然强大，但其参数必须通过实际测量来确定。这个动手编程练习将指导你完成一个稳健的数值方法，从含有噪声的加速比数据中估算程序的串行部分比例 $f$。这项实践连接了理论性能建模与实际性能分析，是计算科学家需要掌握的一项关键技能 [@problem_id:3169134]。", "problem": "给定一组测量的并行加速比，这组数据应遵循一个针对固定问题规模且含有轻微测量噪声的性能模型。其科学基础如下。加速比 $S(p)$ 定义为比率 $S(p) = T(1)/T(p)$，其中 $T(p)$ 是在 $p$ 个相同处理单元上的运行时间。对于固定规模工作负载的共享内存或消息传递并行化，一个经过充分检验的模型是：运行时间分解为一个串行部分和一个理想地分配到 $p$ 个处理器上的并行部分，对于串行分数 $f \\in [0,1]$，这导致 $T(p) = T(1)\\,(f + (1 - f)/p)$，因此 $S(p) = 1/(f + (1 - f)/p)$。测量值 $S_{\\text{meas}}(p)$ 在此结构周围包含少量噪声。您的任务是设计并实现一种鲁棒的数值方法，该方法通过对性能模型进行适当的线性化，并使用有限差分从含噪声的 $(p_i, S_{\\text{meas}}(p_i))$ 数据中估计 $f$。\n\n要求：\n- 从上述模型和定义出发，推导一种方法，将 $f$ 的估计问题转化为从受扰动的测量中估计斜率的问题。该方法必须通过聚合多个有限差分斜率来对轻度噪声保持鲁棒性。\n- 您必须仅根据提供的测量数据来估计 $f$，不能依赖任何关于 $f$ 的先验知识。\n- 不涉及物理单位。所有输出必须是小数（而不是百分比）。\n\n需要实现的算法规范：\n- 对于由数据对 $(p_i, S_{\\text{meas}}(p_i))$ 组成的数据集，计算 $x_i = 1/p_i$ 和 $y_i = 1/S_{\\text{meas}}(p_i)$。\n- 按 $x_i$ 的升序对数据对进行排序。\n- 对于此排序顺序中的所有相邻数据对，计算有限差分斜率 $m_j = (y_{j+1} - y_j)/(x_{j+1} - x_j)$。\n- 通过取 $\\{m_j\\}$ 的中位数 $\\widehat{m}$ 来鲁棒地聚合这些斜率。将此聚合斜率解释为对串行分数补数的估计，并定义 $\\widehat{f} = 1 - \\widehat{m}$。\n- 最后，通过将任何低于 $0$ 的值裁剪为 $0$，任何高于 $1$ 的值裁剪为 $1$，将 $\\widehat{f}$ 限制在区间 $[0,1]$ 内。\n- 对每个数据集，返回估计值 $\\widehat{f}$，精确到 $4$ 位小数。\n\n测试套件（每个数据集是处理器数量及其对应的测量加速比的列表）：\n- 数据集 A（具有中等串行分数的一般情况）：$p = [\\,1,\\,2,\\,4,\\,8,\\,16,\\,32\\,]$，$S_{\\text{meas}}(p) = [\\,1.0,\\,1.79,\\,3.10,\\,4.68,\\,6.45,\\,7.78\\,]$。\n- 数据集 B（接近理想的可扩展性，串行分数非常小）：$p = [\\,1,\\,8,\\,16,\\,32,\\,64,\\,128\\,]$，$S_{\\text{meas}}(p) = [\\,1.0,\\,7.45,\\,13.90,\\,24.50,\\,39.00,\\,56.70\\,]$。\n- 数据集 C（串行分数较大）：$p = [\\,1,\\,2,\\,4,\\,8,\\,16\\,]$，$S_{\\text{meas}}(p) = [\\,1.0,\\,1.43,\\,1.80,\\,2.11,\\,2.28\\,]$。\n- 数据集 D（最小两点情况，边界条件）：$p = [\\,8,\\,16\\,]$，$S_{\\text{meas}}(p) = [\\,3.3333333333,\\,4.0\\,]$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，列表中的每个估计值格式化为精确的 $4$ 位小数，且不含空格。例如：“[0.1234,0.0056,0.4000,0.2000]”。", "solution": "经评估，用户提供的问题是有效的。它在科学上基于并行计算性能建模的原理，特别是阿姆达尔定律。该问题是良构的，提供了完整且无歧义的算法规范，以及其执行所需的所有数据。所使用的语言客观而精确。因此，下面提供一个合理的解决方案。\n\n问题的核心是从一组带噪声的并行程序加速比测量值 $S_{\\text{meas}}(p)$ 中估计其串行分数 $f$。其底层的性能模型由针对固定规模工作负载的阿姆达尔定律给出，该定律将 $p$ 个处理单元上的加速比 $S(p)$ 与串行分数 $f$ 联系起来。\n\n在 $p$ 个处理器上的运行时间 $T(p)$ 被建模为一个恒定的串行部分和一个完全可并行化部分的和：\n$$T(p) = T(1) f + T(1) \\frac{1-f}{p} = T(1) \\left( f + \\frac{1-f}{p} \\right)$$\n这里，$f \\in [0, 1]$ 是程序在单个处理器上执行时间中固有串行且无法并行的部分所占的比例。加速比 $S(p)$ 是串行运行时间 $T(1)$ 与并行运行时间 $T(p)$ 的比率：\n$$S(p) = \\frac{T(1)}{T(p)} = \\frac{T(1)}{T(1) \\left( f + \\frac{1-f}{p} \\right)} = \\frac{1}{f + \\frac{1-f}{p}}$$\n该模型相对于变量 $p$ 是非线性的。为了方便估计 $f$，可以通过变量替换将模型线性化。我们定义两个新变量：\n$$x = \\frac{1}{p} \\quad \\text{and} \\quad y = \\frac{1}{S(p)}$$\n将这些定义代入加速比方程，可以得到 $y$ 和 $x$ 之间的线性关系：\n$$y(x) = f + (1-f)x$$\n该方程是标准直线形式 $y = c + mx$，其中 y 轴截距 $c$ 是串行分数 $f$，斜率 $m$ 是可并行化分数 $1-f$。因此，问题从为 $S(p)$ 拟合一个非线性模型，转变为为 $y(x)$ 拟合一个线性模型。目标是估计 $f$。从线性模型中我们可以看到，如果我们能够鲁棒地估计斜率 $\\widehat{m}$，我们就可以推导出串行分数的估计值 $\\widehat{f} = 1 - \\widehat{m}$。\n\n所规定的算法提供了一种从含噪声的数据点 $(p_i, S_{\\text{meas}}(p_i))$ 估计该斜率的具体数值方法。步骤如下：\n\n$1$. **数据转换**：对于每个测量对 $(p_i, S_{\\text{meas}}(p_i))$，我们在线性化空间中计算对应的点 $(x_i, y_i)$，其中 $x_i = 1/p_i$ 和 $y_i = 1/S_{\\text{meas}}(p_i)$。\n\n$2$. **数据排序**：根据 $x_i$ 的值，将转换后的点集 $\\{(x_i, y_i)\\}$ 按升序排序。此步骤至关重要，因为它将数据点沿自变量轴排列，这是计算相邻点之间有意义的有限差分的先决条件。\n\n$3$. **有限差分斜率计算**：对于排序序列中每对相邻点 $(x_j, y_j)$ 和 $(x_{j+1}, y_{j+1})$，使用有限差分公式计算斜率的局部估计值：\n$$m_j = \\frac{y_{j+1} - y_j}{x_{j+1} - x_j}$$\n在没有噪声的情况下，所有这些斜率 $m_j$ 都将相同且等于 $1-f$。然而，$S_{\\text{meas}}(p_i)$ 中的测量噪声会传播到 $y_i$，导致计算出的 $m_j$ 值发生变化。\n\n$4$. **鲁棒的斜率聚合**：为了从局部斜率集合 $\\{m_j\\}$ 中获得一个单一、鲁棒的真实斜率估计值，算法指定使用中位数。聚合的斜率估计值为 $\\widehat{m} = \\text{median}(\\{m_j\\})$。中位数是一种鲁棒的统计度量，这意味着它比算术平均值对离群数据点（可能由异常嘈杂的测量引起）更不敏感。\n\n$5$. **串行分数估计**：使用从线性模型推导出的关系，从聚合斜率 $\\widehat{m}$ 估计串行分数 $f$：\n$$\\widehat{f} = 1 - \\widehat{m}$$\n\n$6$. **裁剪**：串行分数 $f$ 在物理上被约束在区间 $[0, 1]$ 内。由于噪声的存在，原始估计值 $\\widehat{f}$ 可能会略微超出此范围。最后一步是裁剪该估计值，以确保其位于这些具有物理意义的界限内：$\\widehat{f}_{\\text{clipped}} = \\max(0, \\min(1, \\widehat{f}))$。这在最终结果上强制施加了物理约束。\n\n该过程构成了一种完整且鲁棒的方法，用于根据底层性能模型的合理线性化，从提供的数据中估计串行分数。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem of estimating the serial fraction 'f' from parallel speedup data.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Dataset A (general case with moderate serial fraction)\n        {'p': [1, 2, 4, 8, 16, 32], 'S': [1.0, 1.79, 3.10, 4.68, 6.45, 7.78]},\n        # Dataset B (near-ideal scalability, very small serial fraction)\n        {'p': [1, 8, 16, 32, 64, 128], 'S': [1.0, 7.45, 13.90, 24.50, 39.00, 56.70]},\n        # Dataset C (large serial fraction)\n        {'p': [1, 2, 4, 8, 16], 'S': [1.0, 1.43, 1.80, 2.11, 2.28]},\n        # Dataset D (minimal two-point case, boundary condition)\n        {'p': [8, 16], 'S': [3.3333333333, 4.0]},\n    ]\n\n    results = []\n    \n    for case in test_cases:\n        p_values = np.array(case['p'], dtype=np.float64)\n        s_values = np.array(case['S'], dtype=np.float64)\n        \n        # Step 1: Compute x_i = 1/p_i and y_i = 1/S_meas(p_i).\n        x_values = 1.0 / p_values\n        y_values = 1.0 / s_values\n        \n        # Combine x and y into pairs for sorting.\n        # A list of tuples (x, y) is created.\n        points = list(zip(x_values, y_values))\n        \n        # Step 2: Sort pairs by x_i in ascending order.\n        points.sort(key=lambda point: point[0])\n        \n        # Unzip back into sorted x and y arrays\n        sorted_x, sorted_y = zip(*points)\n        sorted_x = np.array(sorted_x)\n        sorted_y = np.array(sorted_y)\n        \n        # Step 3: Compute finite-difference slopes m_j.\n        # This is only possible if there are at least 2 points.\n        if len(points)  2:\n            # According to the model, an estimate isn't possible, but test cases have = 2 points.\n            # A single point would lead to an undefined slope.\n            # For robustness, handle this edge case, though not triggered by test data.\n            results.append(np.nan) \n            continue\n\n        slopes = []\n        for j in range(len(points) - 1):\n            delta_y = sorted_y[j+1] - sorted_y[j]\n            delta_x = sorted_x[j+1] - sorted_x[j]\n            \n            # Avoid division by zero, although sorted distinct p values should prevent this.\n            if delta_x == 0:\n                continue \n            \n            m_j = delta_y / delta_x\n            slopes.append(m_j)\n        \n        # If no valid slopes were computed (e.g., all x are identical), handle it.\n        if not slopes:\n            results.append(np.nan)\n            continue\n            \n        # Step 4: Aggregate these slopes robustly by taking the median.\n        m_hat = np.median(slopes)\n        \n        # Step 5: Interpret this aggregated slope as estimating the complement of the serial fraction.\n        f_hat = 1.0 - m_hat\n        \n        # Step 6: Bound f_hat to the interval [0,1].\n        f_clipped = np.clip(f_hat, 0.0, 1.0)\n        \n        results.append(f_clipped)\n\n    # Format results to exactly 4 decimal places for the final output.\n    formatted_results = [f\"{res:.4f}\" for res in results]\n    \n    # Final print statement in the exact required format.\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n```", "id": "3169134"}]}