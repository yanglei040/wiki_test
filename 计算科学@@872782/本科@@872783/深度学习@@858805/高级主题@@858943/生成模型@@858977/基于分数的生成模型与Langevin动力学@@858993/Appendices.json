{"hands_on_practices": [{"introduction": "理论学习之后，通过动手实践来巩固对分数函数的理解至关重要。我们将从一个基础但极具启发性的练习开始：推导多维高斯分布的分数函数。这个练习 [@problem_id:3172987] 不仅能让你熟练运用分数函数的定义 $s(x) = \\nabla_{x} \\ln p(x)$，还能揭示其深刻的几何意义——分数场作为一个向量场，总是指向数据分布概率密度增加最快的方向。对于高斯分布这一特殊情况，我们将看到分数函数是一个简单的线性函数，这个结论为检验更复杂的神经网络模型提供了宝贵的基准。", "problem": "考虑一个$d$维随机变量 $x \\in \\mathbb{R}^{d}$，它服从多元高斯分布，其均值为 $\\mu \\in \\mathbb{R}^{d}$，协方差矩阵为严格正定的 $\\Sigma \\in \\mathbb{R}^{d \\times d}$。其概率密度函数为\n$$\np(x) = \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right).\n$$\n在基于分数的生成模型中，分数函数定义为 $s(x) = \\nabla_{x} \\ln p(x)$。从给定的密度函数和分数函数的定义出发，推导$s(x)$关于$\\mu$和$\\Sigma$的显式解析表达式。然后，利用过阻尼朗之万动力学随机微分方程（SDE）$dX_{t} = s(X_{t})\\, dt + \\sqrt{2}\\, dW_{t}$（其中$W_{t}$是标准的$d$维维纳过程），简要解释为什么确定性漂移是$x$的仿射函数，并确定该漂移消失的点。\n\n仅给出$s(x)$的闭式表达式作为最终结果。无需进行数值四舍五入，也不涉及物理单位。", "solution": "问题陈述经确认为具有科学依据、适定且客观。它在概率论和随机过程的标准数学框架内，为推导唯一且有意义的解提供了所有必要的定义和约束。\n\n出发点是一个$d$维多元高斯分布的概率密度函数（PDF），其随机变量为$x \\in \\mathbb{R}^{d}$，均值为$\\mu \\in \\mathbb{R}^{d}$，协方差矩阵为严格正定的$\\Sigma \\in \\mathbb{R}^{d \\times d}$：\n$$\np(x) = \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right)\n$$\n分数函数，记为$s(x)$，定义为概率密度函数对数关于$x$的梯度：\n$$\ns(x) = \\nabla_{x} \\ln p(x)\n$$\n为了推导$s(x)$的表达式，我们首先计算$p(x)$的自然对数：\n$$\n\\ln p(x) = \\ln \\left( \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right) \\right)\n$$\n利用对数的性质，特别是$\\ln(a \\cdot b) = \\ln(a) + \\ln(b)$和$\\ln(\\exp(c)) = c$，我们可以将各项分开：\n$$\n\\ln p(x) = \\ln \\left( \\frac{1}{(2\\pi)^{d/2} |\\Sigma|^{1/2}} \\right) + \\ln \\left( \\exp\\!\\left(-\\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\\right) \\right)\n$$\n$$\n\\ln p(x) = -\\frac{d}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(|\\Sigma|) - \\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu)\n$$\n前两项，$-\\frac{d}{2} \\ln(2\\pi)$和$-\\frac{1}{2} \\ln(|\\Sigma|)$，相对于变量$x$是常数。因此，它们的梯度为零。现在我们可以通过求$\\ln p(x)$的梯度来计算分数函数$s(x)$：\n$$\ns(x) = \\nabla_{x} \\left( -\\frac{d}{2} \\ln(2\\pi) - \\frac{1}{2} \\ln(|\\Sigma|) - \\frac{1}{2} (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right)\n$$\n$$\ns(x) = 0 - 0 - \\frac{1}{2} \\nabla_{x} \\left( (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right)\n$$\n为了计算二次型的梯度，我们使用矩阵微积分中的一个标准结果。对于向量变量$z$和对称矩阵$A$，梯度由$\\nabla_{z} (z^{\\top} A z) = 2 A z$给出。在我们的例子中，变量是$x$，对应于$z$的向量是$(x - \\mu)$，对应于$A$的矩阵是$\\Sigma^{-1}$。根据定义，协方差矩阵$\\Sigma$是对称的，而对称矩阵的逆也是对称的，所以$\\Sigma^{-1}$也是对称的。应用链式法则，我们得到：\n$$\n\\nabla_{x} \\left( (x - \\mu)^{\\top} \\Sigma^{-1} (x - \\mu) \\right) = 2 \\Sigma^{-1} (x - \\mu)\n$$\n将此结果代回$s(x)$的表达式中：\n$$\ns(x) = -\\frac{1}{2} \\left( 2 \\Sigma^{-1} (x - \\mu) \\right) = - \\Sigma^{-1} (x - \\mu)\n$$\n这就是多元高斯分布分数函数的显式解析表达式。\n\n问题进一步要求解释为什么过阻尼朗之万动力学随机微分方程中的确定性漂移是$x$的仿射函数，并确定其消失点。该随机微分方程（SDE）为：\n$$\ndX_{t} = s(X_{t})\\, dt + \\sqrt{2}\\, dW_{t}\n$$\n确定性漂移项是$s(X_{t})$。根据我们推导出的分数表达式，可以将其写为：\n$$\ns(X_t) = -\\Sigma^{-1}(X_t - \\mu) = -\\Sigma^{-1}X_t + \\Sigma^{-1}\\mu\n$$\n该表达式的形式为$A x + b$，其中$A = -\\Sigma^{-1}$是一个$d \\times d$矩阵，$b = \\Sigma^{-1}\\mu$是一个$d \\times 1$向量。根据定义，这种形式的函数是仿射变换。因此，确定性漂移是状态$X_t$的仿射函数。\n\n为了找到漂移消失的点，我们令$s(x) = 0$：\n$$\n- \\Sigma^{-1} (x - \\mu) = 0\n$$\n由于$\\Sigma$是严格正定矩阵，它是可逆的，其逆矩阵$\\Sigma^{-1}$也是可逆的。我们可以从左侧给方程两边同乘$-\\Sigma$：\n$$\n(-\\Sigma)(-\\Sigma^{-1}) (x - \\mu) = (-\\Sigma) 0\n$$\n$$\nI (x - \\mu) = 0\n$$\n其中$I$是$d \\times d$单位矩阵。这可以简化为：\n$$\nx - \\mu = 0 \\implies x = \\mu\n$$\n因此，漂移在$x = \\mu$处消失，这里是高斯分布的均值。这是符合预期的，因为分数函数指向对数概率最陡峭的上升方向，而梯度在分布的众数处（对于高斯分布即其均值）必须为零。", "answer": "$$\\boxed{-\\Sigma^{-1}(x - \\mu)}$$", "id": "3172987"}, {"introduction": "理解了分数函数的概念后，下一步是利用它通过朗之万动力学来生成数据。然而，连续时间的随机微分方程（SDE）必须经过离散化才能在计算机上模拟。这个实践 [@problem_id:3172952] 旨在让你亲手实现并比较两种主流的离散化采样方法：欧拉-丸山（Euler-Maruyama）法和预测-校正（Predictor-Corrector）法。通过编写代码来分析不同采样器生成的平稳分布的统计特性（如二阶矩），你将深入理解将理论SDE转化为实用生成算法时所面临的数值挑战与其中的精妙之处，例如偏差-方差的权衡。", "problem": "您必须编写一个完整、可运行的程序，用于比较一个简单 Euler–Maruyama 采样器和一个预测-校正采样器在一维基于分数的过程中的表现。此比较必须基于对每个采样器生成的平稳分布的二阶矩进行估计时的偏差-方差权衡。请从以下基本原理和定义开始，不要假设任何快捷公式。\n\n考虑一个由基于分数的生成模型中的模型分数函数驱动的一维随机微分方程 (SDE)。设分数函数为 $s_{\\theta}(x) = -\\left(1+\\delta\\right)x$，其中 $\\delta$ 是一个标量参数，用于编码模型相对于标准正态目标分布的真实分数的失配情况。该 SDE 为\n$$\n\\mathrm{d}X_t = s_{\\theta}(X_t) \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t,\n$$\n其中 $W_t$ 是一个标准维纳过程。\n\n使用步长 $h$ 和 Euler–Maruyama 方法（Euler–Maruyama (EM)）对 SDE 进行离散化，该方法产生如下形式的更新：\n$$\nX_{k+1} = X_k + h\\, s_{\\theta}(X_k) + \\sqrt{2h}\\, Z_k,\n$$\n其中 $Z_k \\sim \\mathcal{N}(0,1)$ 是独立的标准正态随机变量。\n\n定义一个预测-校正 (PC) 方案，该方案首先应用上述的 Euler–Maruyama 预测器得到一个中间值 $X_{k+1}^{(\\text{pred})}$，然后使用相同的分数函数和步长 $c$ 应用一个确定性校正步骤：\n$$\nX_{k+1} = X_{k+1}^{(\\text{pred})} + c\\, s_{\\theta}\\!\\left(X_{k+1}^{(\\text{pred})}\\right).\n$$\n该 PC 方案将随机预测器与基于 $s_{\\theta}$ 的确定性漂移校正器相结合。\n\n真实分布的目标二阶矩是标准正态变量的二阶矩，即 $E[X^2] = 1$。对于每个采样器（EM 和 PC），假设步数 $T$ 足够大，使得马尔可夫链达到平稳状态。关注每种方案导出的平稳分布下的二阶矩 $E[X^2]$，计算：\n- 绝对偏差，定义为 $\\left| E[X^2] - 1 \\right|$。\n- $E[X^2]$ 的蒙特卡洛估计量的方差，该估计量由来自平稳分布的 $M$ 个独立样本的平均值构成。在平稳分布下，对于 $X \\sim \\mathcal{N}(0, V)$，利用 $E[X^2] = V$ 和 $E[X^4] = 3V^2$ 这一事实来确定 $M$ 个独立样本的 $X^2$ 样本均值的估计量方差。\n\n您的程序必须为下面指定的每个测试用例计算 EM 和 PC 的这些量。利用平稳状态下的独立性理想化假设，将估计量方差表示为平稳方差 $V$ 和样本大小 $M$ 的封闭形式函数。\n\n测试套件（每个测试用例是一个元组 $(\\delta, h, T, c)$）：\n1. $(0,\\, 0.05,\\, 400,\\, 0)$：无校正器的基线（预测-校正简化为 Euler–Maruyama）。\n2. $(0,\\, 0.05,\\, 400,\\, 0.005)$：带有小确定性漂移的校正器，匹配的分数。\n3. $(0.1,\\, 0.05,\\, 400,\\, 0.005)$：正向模型失配，相同步数。\n4. $(-0.2,\\, 0.1,\\, 400,\\, 0.1)$：负向模型失配，更大步长。\n\n对于估计量方差的计算，每个测试用例中每种方法使用 $M = 10000$ 个独立样本。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果。\n- 对于每个测试用例，按此顺序附加四个浮点数：$\\left[\\text{bias}_{\\text{EM}}, \\text{var}_{\\text{EM}}, \\text{bias}_{\\text{PC}}, \\text{var}_{\\text{PC}}\\right]$。\n- 将所有测试用例的结果连接成一个列表，并保持上面列出的测试套件的顺序。例如，两个测试用例的输出将如下所示：$\\left[\\text{b}_{1,\\text{EM}}, \\text{v}_{1,\\text{EM}}, \\text{b}_{1,\\text{PC}}, \\text{v}_{1,\\text{PC}}, \\text{b}_{2,\\text{EM}}, \\text{v}_{2,\\text{EM}}, \\text{b}_{2,\\text{PC}}, \\text{v}_{2,\\text{PC}}\\right]$。\n\n您的程序必须是自包含的，不需要用户输入，并遵守执行环境的限制。", "solution": "该问题要求比较 Euler–Maruyama (EM) 采样器和预测-校正 (PC) 采样器，应用于源于基于分数的生成模型的一维 Ornstein–Uhlenbeck 型随机微分方程 (SDE)。比较的基础是估计每个采样器生成的平稳分布的二阶矩时的偏差和方差。我们将首先为每种数值方案推导平稳方差的解析表达式。\n\n该 SDE 如下所示：\n$$\n\\mathrm{d}X_t = s_{\\theta}(X_t) \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t\n$$\n其分数函数为 $s_{\\theta}(x) = -(1+\\delta)x$。代入分数函数，我们得到一个线性 SDE：\n$$\n\\mathrm{d}X_t = -(1+\\delta)X_t \\,\\mathrm{d}t + \\sqrt{2}\\,\\mathrm{d}W_t\n$$\n该连续时间过程的平稳分布是一个零均值正态分布 $\\mathcal{N}(0, V_{true})$，其中方差 $V_{true}$ 满足涨落-耗散关系 $-(1+\\delta)V_{true} + 1 = 0$，即 $V_{true} = 1/(1+\\delta)$。然而，问题指定目标二阶矩为 $E[X^2] = 1$，对应于标准正态分布（即底层 SDE 中 $\\delta=0$ 的情况）。偏差将相对于这个目标值 1 来衡量。\n\n两种离散化方案都是线性的，具有一般形式 $X_{k+1} = A X_k + B Z_k$，其中 $Z_k \\sim \\mathcal{N}(0,1)$。这是一个一阶自回归过程 (AR(1))。如果 $|A|1$，该过程具有唯一的平稳分布。由于新息 $Z_k$ 是高斯的，平稳分布也是均值为零的高斯分布，$X \\sim \\mathcal{N}(0, V)$。方差 $V$ 可以通过在平稳状态下令等式两边的方差相等来求得：\n$$\n\\mathrm{Var}(X_{k+1}) = \\mathrm{Var}(A X_k + B Z_k)\n$$\n由于 $X_k$ 和 $Z_k$ 是独立的，\n$$\nV = A^2 \\mathrm{Var}(X_k) + B^2 \\mathrm{Var}(Z_k) = A^2 V + B^2\n$$\n求解 $V$，我们得到平稳方差：\n$$\nV = \\frac{B^2}{1 - A^2}\n$$\n该公式是我们分析的基石。\n\n对于每个采样器，我们首先找到其平稳方差 $V$。然后从 $V$ 推导出我们感兴趣的量：\n1.  二阶矩估计量的绝对偏差：$b = |E[X^2] - 1| = |V-1|$。\n2.  $E[X^2]$ 的蒙特卡洛估计量的方差。该估计量是样本均值 $\\hat{E}[X^2] = \\frac{1}{M}\\sum_{i=1}^M X_i^2$，其中 $X_i \\sim \\mathcal{N}(0, V)$ 是来自平稳分布的 $M$ 个独立样本。该估计量的方差为：\n    $$\n    \\mathrm{Var}(\\hat{E}[X^2]) = \\mathrm{Var}\\left(\\frac{1}{M}\\sum_{i=1}^M X_i^2\\right) = \\frac{1}{M}\\mathrm{Var}(X^2)\n    $$\n    对于 $X \\sim \\mathcal{N}(0, V)$，给定 $E[X^4] = 3V^2$。因此：\n    $$\n    \\mathrm{Var}(X^2) = E[(X^2)^2] - (E[X^2])^2 = E[X^4] - V^2 = 3V^2 - V^2 = 2V^2\n    $$\n    因此，估计量的方差为 $v = \\frac{2V^2}{M}$。\n\n现在，我们将此框架应用于每个采样器。\n\n**1. Euler–Maruyama (EM) 采样器**\n\n更新规则为：\n$$\nX_{k+1} = X_k + h s_{\\theta}(X_k) + \\sqrt{2h} Z_k\n$$\n代入 $s_{\\theta}(X_k) = -(1+\\delta)X_k$：\n$$\nX_{k+1} = X_k - h(1+\\delta)X_k + \\sqrt{2h} Z_k = \\left(1 - h(1+\\delta)\\right)X_k + \\sqrt{2h} Z_k\n$$\n这是一个 AR(1) 过程，其系数为：\n$$\nA_{\\text{EM}} = 1 - h(1+\\delta) \\quad \\text{和} \\quad B_{\\text{EM}} = \\sqrt{2h}\n$$\n平稳方差 $V_{\\text{EM}}$ 为：\n$$\nV_{\\text{EM}} = \\frac{B_{\\text{EM}}^2}{1-A_{\\text{EM}}^2} = \\frac{(\\sqrt{2h})^2}{1 - (1 - h(1+\\delta))^2} = \\frac{2h}{1 - (1 - 2h(1+\\delta) + h^2(1+\\delta)^2)} = \\frac{2h}{2h(1+\\delta) - h^2(1+\\delta)^2}\n$$\n$$\nV_{\\text{EM}} = \\frac{2}{(1+\\delta)(2 - h(1+\\delta))}\n$$\nEM 采样器的偏差和估计量方差为：\n$$\n\\text{bias}_{\\text{EM}} = |V_{\\text{EM}} - 1| \\quad \\text{和} \\quad \\text{var}_{\\text{EM}} = \\frac{2V_{\\text{EM}}^2}{M}\n$$\n\n**2. 预测-校正 (PC) 采样器**\n\nPC 方案包括一个预测步骤和一个校正步骤。\n预测器：\n$$\nX_{k+1}^{(\\text{pred})} = X_k + h s_{\\theta}(X_k) + \\sqrt{2h} Z_k = (1 - h(1+\\delta))X_k + \\sqrt{2h} Z_k\n$$\n校正器：\n$$\nX_{k+1} = X_{k+1}^{(\\text{pred})} + c s_{\\theta}(X_{k+1}^{(\\text{pred})}) = X_{k+1}^{(\\text{pred})} - c(1+\\delta)X_{k+1}^{(\\text{pred})} = (1 - c(1+\\delta))X_{k+1}^{(\\text{pred})}\n$$\n结合这两个步骤，我们将 $X_{k+1}$ 直接用 $X_k$ 表示：\n$$\nX_{k+1} = (1 - c(1+\\delta)) \\left[ (1 - h(1+\\delta))X_k + \\sqrt{2h}Z_k \\right]\n$$\n$$\nX_{k+1} = (1 - c(1+\\delta))(1 - h(1+\\delta)) X_k + (1 - c(1+\\delta))\\sqrt{2h} Z_k\n$$\n这同样是一个 AR(1) 过程，其系数为：\n$$\nA_{\\text{PC}} = (1 - c(1+\\delta))(1 - h(1+\\delta)) \\quad \\text{和} \\quad B_{\\text{PC}} = (1 - c(1+\\delta))\\sqrt{2h}\n$$\n平稳方差 $V_{\\text{PC}}$ 为：\n$$\nV_{\\text{PC}} = \\frac{B_{\\text{PC}}^2}{1-A_{\\text{PC}}^2} = \\frac{\\left((1 - c(1+\\delta))\\sqrt{2h}\\right)^2}{1 - \\left((1 - c(1+\\delta))(1 - h(1+\\delta))\\right)^2}\n$$\n$$\nV_{\\text{PC}} = \\frac{(1 - c(1+\\delta))^2 (2h)}{1 - (1 - c(1+\\delta))^2 (1 - h(1+\\delta))^2}\n$$\nPC 采样器的偏差和估计量方差为：\n$$\n\\text{bias}_{\\text{PC}} = |V_{\\text{PC}} - 1| \\quad \\text{和} \\quad \\text{var}_{\\text{PC}} = \\frac{2V_{\\text{PC}}^2}{M}\n$$\n注意，如果 $c=0$，则 $A_{\\text{PC}}=A_{\\text{EM}}$ 且 $B_{\\text{PC}}=B_{\\text{EM}}$，因此 $V_{\\text{PC}} = V_{\\text{EM}}$。这是一致的，因为零步长校正器使得 PC 方案与 EM 方案完全相同。程序将实现这些推导出的公式，为每个测试用例计算所需的量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the bias-variance tradeoff for EM and PC samplers for a 1D SDE.\n\n    The solution is based on the analytical derivation of the stationary variance\n    for the discretized processes, which are AR(1) models.\n    \"\"\"\n    \n    # Define the test cases from the problem statement.\n    # Each tuple is (delta, h, T, c). The parameter T is not used in the\n    # analytical stationary-state calculation.\n    test_cases = [\n        (0.0, 0.05, 400, 0.0),\n        (0.0, 0.05, 400, 0.005),\n        (0.1, 0.05, 400, 0.005),\n        (-0.2, 0.1, 400, 0.1),\n    ]\n\n    # Sample size for Monte Carlo estimator variance calculation.\n    M = 10000.0\n\n    results = []\n    for delta, h, T, c in test_cases:\n        # Common term in the score function s_theta(x) = -(1 + delta) * x\n        one_plus_delta = 1.0 + delta\n\n        # --- Euler-Maruyama (EM) Analysis ---\n        \n        # The EM update is X_{k+1} = (1 - h*(1+delta)) * X_k + sqrt(2*h) * Z_k\n        # This is an AR(1) process X_{k+1} = A*X_k + B*Z_k\n        # The stationary variance is V_EM = B^2 / (1 - A^2)\n        \n        # A_em = 1.0 - h * one_plus_delta\n        # B_em_sq = 2.0 * h\n        # v_em = B_em_sq / (1.0 - A_em**2)\n        \n        # Using an expanded form for better numerical stability with small h\n        v_em_numerator = 2.0 * h\n        v_em_denominator = (2.0 * h * one_plus_delta) - (h**2 * one_plus_delta**2)\n\n        # Ensure stability by checking denominator > 0, which corresponds to\n        # 0  h*(1+delta)  2\n        if v_em_denominator = 0:\n            # This case won't be hit with the given test values.\n            v_em = float('inf')\n        else:\n            v_em = v_em_numerator / v_em_denominator\n        \n        # Absolute bias: |E[X^2] - 1| = |V_em - 1|\n        bias_em = abs(v_em - 1.0)\n        \n        # Estimator variance: Var([sum X_i^2]/M) = Var(X^2) / M = 2*V_em^2/M\n        var_em_estimator = (2.0 * v_em**2) / M\n\n        # --- Predictor-Corrector (PC) Analysis ---\n\n        # The PC update is X_{k+1} = (1-c*(1+d)) * X_{k+1_pred}\n        # which results in X_{k+1} = A_pc * X_k + B_pc * Z_k\n        \n        # Coefficients for the AR(1) form of the PC scheme\n        alpha_h = 1.0 - h * one_plus_delta\n        alpha_c = 1.0 - c * one_plus_delta\n        \n        A_pc = alpha_c * alpha_h\n        B_pc_sq = (alpha_c**2) * (2.0 * h)\n        \n        v_pc_numerator = B_pc_sq\n        v_pc_denominator = 1.0 - A_pc**2\n        \n        # Ensure stability by checking |A_pc|  1\n        if v_pc_denominator = 0:\n            # This case won't be hit with the given test values.\n            v_pc = float('inf')\n        else:\n            v_pc = v_pc_numerator / v_pc_denominator\n\n        # Absolute bias: |E[X^2] - 1| = |V_pc - 1|\n        bias_pc = abs(v_pc - 1.0)\n        \n        # Estimator variance: 2*V_pc^2/M\n        var_pc_estimator = (2.0 * v_pc**2) / M\n\n        results.extend([bias_em, var_em_estimator, bias_pc, var_pc_estimator])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3172952"}, {"introduction": "在实际应用中，我们通常无法得到真实数据分布的精确分数函数，而是通过神经网络学习一个近似的替代品 $s_\\theta(\\mathbf{x})$。一个关键的理论问题是：这个学习到的分数场是否“保守”？真实的分数场是某个标量势（对数概率 $\\ln p(\\mathbf{x})$）的梯度，因此它是保守的，其线积分与路径无关。这个练习 [@problem_id:3172994] 提供了一种强大的方法来诊断学习到的分数场的非保守性。通过数值计算分数场在连接相同两点的不同路径上的线积分，你可以直接衡量其“路径依赖性”，这是一个清晰的指标，反映了学习场偏离真实梯度场的程度，从而将深刻的数学概念与实用的模型分析工具联系起来。", "problem": "考虑一个在 $\\mathbb{R}^2$ 上的二维密度 $p(\\mathbf{x})$ 和一个生成参数化分数场 $s_\\theta(\\mathbf{x})$ 的基于分数的生成模型。该分数场旨在近似真实分数 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。在过阻尼朗之万动力学中（这是一种用于采样的随机微分方程 (SDE)），其连续时间更新为 $\\mathrm{d}\\mathbf{x}_t = \\tfrac{1}{2}s_\\theta(\\mathbf{x}_t)\\,\\mathrm{d}t + \\mathrm{d}\\mathbf{W}_t$，其中 $\\mathbf{W}_t$ 是一个标准维纳过程。如果 $s_\\theta(\\mathbf{x})$ 等于真实的梯度场，那么根据线积分基本定理，差值 $\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)$ 可以计算为 $s_\\theta$ 在 $\\mathbf{x}_0$ 和 $\\mathbf{x}$ 之间的路径积分。与保守（梯度）场的偏差可以通过此类线积分的路径依赖性来检测。\n\n您的任务是实现一个程序，该程序：\n- 将一个科学上合理的目标分布 $p(\\mathbf{x})$ 定义为 $d = 2$ 维空间中两个等权重高斯分布的混合。使用\n$$\np(\\mathbf{x}) = \\tfrac{1}{2}\\,\\mathcal{N}\\!\\left(\\mathbf{x}\\mid\\boldsymbol{\\mu}_1,\\boldsymbol{\\Sigma}_1\\right) + \\tfrac{1}{2}\\,\\mathcal{N}\\!\\left(\\mathbf{x}\\mid\\boldsymbol{\\mu}_2,\\boldsymbol{\\Sigma}_2\\right),\n$$\n其中 $\\boldsymbol{\\mu}_1 = [0,0]^\\top$，$\\boldsymbol{\\mu}_2 = [2,-1]^\\top$，$\\boldsymbol{\\Sigma}_1 = \\begin{bmatrix}1.0  0.3 \\\\ 0.3  0.5\\end{bmatrix}$，以及 $\\boldsymbol{\\Sigma}_2 = \\begin{bmatrix}0.9  -0.2 \\\\ -0.2  0.8\\end{bmatrix}$。\n- 使用 $s(\\mathbf{x}) = \\left(\\nabla_{\\mathbf{x}} p(\\mathbf{x})\\right)/p(\\mathbf{x})$ 和恒等式 $\\nabla_{\\mathbf{x}} \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}) = -\\boldsymbol{\\Sigma}^{-1}(\\mathbf{x}-\\boldsymbol{\\mu})\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma})$ 从第一性原理计算真实分数 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。\n- 构建一个包含受控非保守分量的参数化分数场 $s_\\theta(\\mathbf{x})$：\n$$\ns_\\theta(\\mathbf{x}) = s(\\mathbf{x}) + \\varepsilon\\,\\mathbf{R}(\\mathbf{x}),\n$$\n其中 $\\varepsilon \\ge 0$ 是一个标量参数，$\\mathbf{R}(\\mathbf{x})$ 是在 $d=2$ 中定义的旋转场，具体为\n$$\n\\mathbf{R}(\\mathbf{x}) = \\frac{\\mathbf{Q}\\,(\\mathbf{x} - \\mathbf{c})}{1 + \\lVert \\mathbf{x} - \\mathbf{c} \\rVert^2}, \\quad \\mathbf{Q} = \\begin{bmatrix}0  -1 \\\\ 1  0\\end{bmatrix}, \\quad \\mathbf{c} = [0.5,-0.5]^\\top.\n$$\n注意，$\\mathbf{Q}$ 将向量旋转 $90^\\circ$；$\\mathbf{R}(\\mathbf{x})$ 的旋度非零，因此它不是任何标量势的梯度。\n- 通过沿共享端点的两条路径对 $s_\\theta(\\mathbf{x})$ 进行数值积分来估计 $\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)$：\n    1. 一条直线路径\n    $$\n    \\boldsymbol{\\gamma}_{\\text{straight}}(t) = \\mathbf{x}_0 + t\\,(\\mathbf{x} - \\mathbf{x}_0), \\quad t \\in [0,1],\n    $$\n    其路径导数为 $\\boldsymbol{\\gamma}'_{\\text{straight}}(t) = \\mathbf{x} - \\mathbf{x}_0$。\n    2. 一条带有与位移正交的正弦绕道的曲线路径：\n    $$\n    \\boldsymbol{\\gamma}_{\\text{curved}}(t) = \\mathbf{x}_0 + t\\,\\mathbf{d} + a\\,\\sin(\\pi t)\\,\\hat{\\mathbf{n}}, \\quad t \\in [0,1],\n    $$\n    其中 $\\mathbf{d} = \\mathbf{x} - \\mathbf{x}_0$，单位法向量 $\\hat{\\mathbf{n}} = \\frac{\\mathbf{Q}\\,\\mathbf{d}}{\\lVert \\mathbf{d} \\rVert}$ 是通过将 $\\mathbf{d}$ 旋转 $90^\\circ$ 得到的，而 $a \\ge 0$ 控制绕道振幅。路径导数为\n    $$\n    \\boldsymbol{\\gamma}'_{\\text{curved}}(t) = \\mathbf{d} + a\\,\\pi\\,\\cos(\\pi t)\\,\\hat{\\mathbf{n}}.\n    $$\n- 使用具有 $N$ 个步长的 $t \\in [0,1]$ 的均匀离散化和复合梯形法则来近似线积分\n$$\nI_{\\text{path}} \\approx \\int_{0}^{1} s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)\\,\\mathrm{d}t.\n$$\n如果 $\\lVert \\mathbf{d} \\rVert = 0$，则两个积分都必须报告为 $0$，以满足零位移下的基本定理。\n\n然后，对于下面套件中的每个测试用例，计算两个量：\n- $D = \\left\\lvert I_{\\text{straight}} - I_{\\text{curved}} \\right\\rvert$，它量化了路径依赖性，从而量化了 $s_\\theta$ 的非保守性。\n- $E = \\left\\lvert I_{\\text{straight}} - \\left(\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)\\right) \\right\\rvert$，它衡量了直线路径估计相对于真实对数密度差的绝对误差。\n\n使用 $N = 4096$ 个离散化步长。为了在计算 $\\log p(\\mathbf{x})$ 时保证数值稳定性，请对混合分量使用数学上可靠的 log-sum-exp 合并。将报告的每个浮点数四舍五入到 $6$ 位小数。\n\n测试套件：\n- 案例 1：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.0$，$a = 0.5$。\n- 案例 2：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.05$，$a = 0.5$。\n- 案例 3：$\\mathbf{x}_0 = [0,0]^\\top$，$\\mathbf{x} = [2,1]^\\top$，$\\varepsilon = 0.2$，$a = 0.5$。\n- 案例 4（边界情况）：$\\mathbf{x}_0 = [1,-1]^\\top$，$\\mathbf{x} = [1,-1]^\\top$，$\\varepsilon = 0.25$，$a = 1.0$。\n- 案例 5（高曲率）：$\\mathbf{x}_0 = [0,-2]^\\top$，$\\mathbf{x} = [3,1]^\\top$，$\\varepsilon = 0.1$，$a = 2.0$。\n\n最终输出格式：\n- 您的程序应生成单行输出，其中包含结果，格式为列表的列表，每个内部列表对应一个测试用例，并按顺序排列。每个内部列表的形式必须为 $[D,E]$，且两个条目都四舍五入到 $6$ 位小数。例如：$[[d_1,e_1],[d_2,e_2],\\dots]$。", "solution": "该问题要求分析基于分数的生成模型中使用的参数化分数场 $s_\\theta(\\mathbf{x})$。真实分数场 $s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$ 的一个关键性质是它是一个保守向量场，这意味着其在两点之间的线积分与路径无关。近似分数场 $s_\\theta(\\mathbf{x})$ 可能不保守，从而在诸如朗之万动力学之类的采样算法中引入误差。本练习旨在量化非保守扰动对分数线积分的影响。\n\n解决方案分几个步骤进行：\n1.  定义目标概率密度 $p(\\mathbf{x})$，并推导其对数 $\\log p(\\mathbf{x})$ 和真实分数 $s(\\mathbf{x})$ 的表达式。\n2.  定义非保守参数化分数场 $s_\\theta(\\mathbf{x})$。\n3.  定义两条积分路径 $\\boldsymbol{\\gamma}_{\\text{straight}}(t)$ 和 $\\boldsymbol{\\gamma}_{\\text{curved}}(t)$ 及其导数。\n4.  使用复合梯形法则构建数值线积分。\n5.  定义指标 $D$（路径依赖性）和 $E$（估计误差）。\n\n**1. 目标密度与真实分数**\n\n目标密度是 $d=2$ 维的高斯混合模型 (GMM)：\n$$\np(\\mathbf{x}) = \\frac{1}{2}\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_1, \\boldsymbol{\\Sigma}_1) + \\frac{1}{2}\\,\\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_2, \\boldsymbol{\\Sigma}_2)\n$$\n参数为 $\\boldsymbol{\\mu}_1 = [0,0]^\\top$, $\\boldsymbol{\\mu}_2 = [2,-1]^\\top$, $\\boldsymbol{\\Sigma}_1 = \\begin{bmatrix}1.0  0.3 \\\\ 0.3  0.5\\end{bmatrix}$ 和 $\\boldsymbol{\\Sigma}_2 = \\begin{bmatrix}0.9  -0.2 \\\\ -0.2  0.8\\end{bmatrix}$。\n\n为了稳定地计算对数 $\\log p(\\mathbf{x})$，我们使用 log-sum-exp (LSE) 恒等式。令 $p_i(\\mathbf{x}) = \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu}_i, \\boldsymbol{\\Sigma}_i)$，我们有：\n$$\n\\log p(\\mathbf{x}) = \\log\\left(\\frac{1}{2}\\left(e^{\\log p_1(\\mathbf{x})} + e^{\\log p_2(\\mathbf{x})}\\right)\\right) = -\\log(2) + \\text{LSE}(\\log p_1(\\mathbf{x}), \\log p_2(\\mathbf{x}))\n$$\n多元正态分布的对数密度由下式给出：\n$$\n\\log \\mathcal{N}(\\mathbf{x}\\mid\\boldsymbol{\\mu},\\boldsymbol{\\Sigma}) = -\\frac{d}{2}\\log(2\\pi) - \\frac{1}{2}\\log|\\det(\\boldsymbol{\\Sigma})| - \\frac{1}{2}(\\mathbf{x}-\\boldsymbol{\\mu})^\\top\\boldsymbol{\\Sigma}^{-1}(\\mathbf{x}-\\boldsymbol{\\mu})\n$$\n\n真实分数是对数密度的梯度，$s(\\mathbf{x}) = \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$。使用链式法则和恒等式 $\\nabla_{\\mathbf{x}} p(\\mathbf{x}) = p(\\mathbf{x}) \\nabla_{\\mathbf{x}} \\log p(\\mathbf{x})$：\n$$\ns(\\mathbf{x}) = \\frac{\\nabla_{\\mathbf{x}} p(\\mathbf{x})}{p(\\mathbf{x})} = \\frac{\\frac{1}{2}\\nabla_{\\mathbf{x}} p_1(\\mathbf{x}) + \\frac{1}{2}\\nabla_{\\mathbf{x}} p_2(\\mathbf{x})}{\\frac{1}{2} p_1(\\mathbf{x}) + \\frac{1}{2} p_2(\\mathbf{x})}\n$$\n使用给定的恒等式 $\\nabla_{\\mathbf{x}} p_i(\\mathbf{x}) = p_i(\\mathbf{x}) \\nabla_{\\mathbf{x}} \\log p_i(\\mathbf{x})$，其中 $\\nabla_{\\mathbf{x}} \\log p_i(\\mathbf{x}) = -\\boldsymbol{\\Sigma}_i^{-1}(\\mathbf{x}-\\boldsymbol{\\mu}_i) = s_i(\\mathbf{x})$，分数可以表示为各个分量分数的加权平均：\n$$\ns(\\mathbf{x}) = \\frac{p_1(\\mathbf{x})s_1(\\mathbf{x}) + p_2(\\mathbf{x})s_2(\\mathbf{x})}{p_1(\\mathbf{x}) + p_2(\\mathbf{x})}\n$$\n通过提出 $\\log p_1(\\mathbf{x})$ 和 $\\log p_2(\\mathbf{x})$ 的最大值，可以使用 LSE 技巧来稳定地计算此形式。\n\n**2. 参数化分数场**\n\n参数化分数场 $s_\\theta(\\mathbf{x})$ 是通过向真实分数添加一个非保守（旋转）分量来构建的：\n$$\ns_\\theta(\\mathbf{x}) = s(\\mathbf{x}) + \\varepsilon\\,\\mathbf{R}(\\mathbf{x})\n$$\n其中 $\\varepsilon \\ge 0$ 是一个控制非保守部分大小的标量。旋转场 $\\mathbf{R}(\\mathbf{x})$ 定义为：\n$$\n\\mathbf{R}(\\mathbf{x}) = \\frac{\\mathbf{Q}\\,(\\mathbf{x} - \\mathbf{c})}{1 + \\lVert \\mathbf{x} - \\mathbf{c} \\rVert^2}, \\quad \\text{with } \\mathbf{Q} = \\begin{bmatrix}0  -1 \\\\ 1  0\\end{bmatrix}, \\quad \\mathbf{c} = [0.5,-0.5]^\\top.\n$$\n矩阵 $\\mathbf{Q}$ 将一个二维向量旋转 $+90^\\circ$。$\\mathbf{R}(\\mathbf{x})$ 的旋度非零，证实了它不是一个梯度场。\n\n**3. 积分路径**\n\n我们计算 $s_\\theta(\\mathbf{x})$ 从起点 $\\mathbf{x}_0$ 到终点 $\\mathbf{x}$ 沿两条不同路径的线积分，这两条路径都由 $t \\in [0,1]$ 参数化。\n1.  **直线路径**：一条直接线段。\n    $$\n    \\boldsymbol{\\gamma}_{\\text{straight}}(t) = \\mathbf{x}_0 + t\\,(\\mathbf{x} - \\mathbf{x}_0) \\quad \\implies \\quad \\boldsymbol{\\gamma}'_{\\text{straight}}(t) = \\mathbf{x} - \\mathbf{x}_0\n    $$\n2.  **曲线路径**：一条正弦绕道。令 $\\mathbf{d} = \\mathbf{x} - \\mathbf{x}_0$ 为位移向量，$\\hat{\\mathbf{n}} = \\mathbf{Q}\\,\\mathbf{d} / \\lVert \\mathbf{d} \\rVert$ 为正交单位向量。\n    $$\n    \\boldsymbol{\\gamma}_{\\text{curved}}(t) = \\mathbf{x}_0 + t\\,\\mathbf{d} + a\\,\\sin(\\pi t)\\,\\hat{\\mathbf{n}} \\quad \\implies \\quad \\boldsymbol{\\gamma}'_{\\text{curved}}(t) = \\mathbf{d} + a\\,\\pi\\,\\cos(\\pi t)\\,\\hat{\\mathbf{n}}\n    $$\n参数 $a \\ge 0$ 控制绕道的振幅。\n\n**4. 数值线积分**\n\n沿路径 $\\boldsymbol{\\gamma}$ 的线积分由 $I_{\\text{path}} = \\int_{\\boldsymbol{\\gamma}} s_\\theta(\\mathbf{x}) \\cdot \\mathrm{d}\\mathbf{x}$ 给出。使用参数化 $\\boldsymbol{\\gamma}(t)$，这变为：\n$$\nI_{\\text{path}} = \\int_{0}^{1} s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)\\,\\mathrm{d}t\n$$\n该积分使用具有 $N=4096$ 个步长的复合梯形法则进行数值近似。令 $t_k = k/N$ 对于 $k=0, 1, \\dots, N$，并令 $g(t) = s_\\theta(\\boldsymbol{\\gamma}(t)) \\cdot \\boldsymbol{\\gamma}'(t)$。积分近似为：\n$$\nI_{\\text{path}} \\approx \\frac{1}{N} \\left( \\frac{g(t_0) + g(t_N)}{2} + \\sum_{k=1}^{N-1} g(t_k) \\right)\n$$\n一个特殊情况是当 $\\mathbf{x}_0 = \\mathbf{x}$ 时，这意味着 $\\mathbf{d}=\\mathbf{0}$。在这种情况下，两条路径都是静止的，路径导数为零，并且两个积分 $I_{\\text{straight}}$ 和 $I_{\\text{curved}}$ 都被定义为 $0$。\n\n**5. 误差指标**\n\n为每个测试用例计算两个指标：\n-   **路径依赖性 ($D$)**：沿两条路径的积分之间的绝对差。如果 $s_\\theta$ 是保守的，这个值将为 $0$。非零值表示存在偏差。\n    $$\n    D = \\left\\lvert I_{\\text{straight}} - I_{\\text{curved}} \\right\\rvert\n    $$\n-   **估计误差 ($E$)**：直线路径积分与真实对数密度差之间的绝对误差。对于一个完全保守的场 ($\\varepsilon=0$)，这反映了数值积分误差。对于 $\\varepsilon  0$，它还包括由非保守分量引起的误差。\n    $$\n    E = \\left\\lvert I_{\\text{straight}} - \\left(\\log p(\\mathbf{x}) - \\log p(\\mathbf{x}_0)\\right) \\right\\rvert\n    $$\n\n程序使用 `numpy` 以向量化方式高效地实现这些步骤，处理每个测试用例以计算并报告 $D$ 和 $E$ 的值。", "answer": "```python\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes path-dependence and estimation error for a non-conservative score field.\n    \"\"\"\n    # Define problem constants\n    D_DIM = 2\n    MU1 = np.array([0.0, 0.0])\n    MU2 = np.array([2.0, -1.0])\n    SIGMA1 = np.array([[1.0, 0.3], [0.3, 0.5]])\n    SIGMA2 = np.array([[0.9, -0.2], [-0.2, 0.8]])\n    Q = np.array([[0.0, -1.0], [1.0, 0.0]])\n    C = np.array([0.5, -0.5])\n    N_STEPS = 4096\n\n    # Pre-compute matrix inverses and log-determinants\n    SIGMA1_INV = np.linalg.inv(SIGMA1)\n    SIGMA2_INV = np.linalg.inv(SIGMA2)\n    _, LOG_DET_SIGMA1 = np.linalg.slogdet(SIGMA1)\n    _, LOG_DET_SIGMA2 = np.linalg.slogdet(SIGMA2)\n    \n    LOG_PDF_CONST = -0.5 * D_DIM * np.log(2 * np.pi)\n\n    def log_pdf_gaussian_batch(x, mu, inv_sigma, log_det_sigma):\n        \"\"\"Computes log-PDF for a batch of points for a single Gaussian.\"\"\"\n        # x shape: (D_DIM, M)\n        # mu shape: (D_DIM,)\n        diff = x - mu[:, np.newaxis]  # shape (D_DIM, M)\n        mahalanobis = np.einsum('im,ij,jm-m', diff, inv_sigma, diff)\n        return LOG_PDF_CONST - 0.5 * log_det_sigma - 0.5 * mahalanobis\n\n    def log_pdf_gmm_batch(x):\n        \"\"\"Computes log-PDF for a batch of points for the GMM.\"\"\"\n        log_p1 = log_pdf_gaussian_batch(x, MU1, SIGMA1_INV, LOG_DET_SIGMA1)\n        log_p2 = log_pdf_gaussian_batch(x, MU2, SIGMA2_INV, LOG_DET_SIGMA2)\n        \n        max_log = np.maximum(log_p1, log_p2)\n        lse = max_log + np.log(np.exp(log_p1 - max_log) + np.exp(log_p2 - max_log))\n        \n        return -np.log(2) + lse\n\n    def true_score_batch(x):\n        \"\"\"Computes the true score field for a batch of points.\"\"\"\n        diff1 = x - MU1[:, np.newaxis]\n        diff2 = x - MU2[:, np.newaxis]\n        s1 = -SIGMA1_INV @ diff1\n        s2 = -SIGMA2_INV @ diff2\n        \n        log_p1 = log_pdf_gaussian_batch(x, MU1, SIGMA1_INV, LOG_DET_SIGMA1)\n        log_p2 = log_pdf_gaussian_batch(x, MU2, SIGMA2_INV, LOG_DET_SIGMA2)\n        \n        max_log = np.maximum(log_p1, log_p2)\n        exp1 = np.exp(log_p1 - max_log)\n        exp2 = np.exp(log_p2 - max_log)\n        \n        # Broadcasting for weighted average\n        score = (exp1[np.newaxis, :] * s1 + exp2[np.newaxis, :] * s2) / (exp1 + exp2)[np.newaxis, :]\n        return score\n\n    def rotational_field_batch(x):\n        \"\"\"Computes the rotational field component for a batch of points.\"\"\"\n        diff = x - C[:, np.newaxis]\n        norm_sq = np.sum(diff * diff, axis=0)\n        return (Q @ diff) / (1.0 + norm_sq)\n\n    def parametric_score_batch(x, epsilon):\n        \"\"\"Computes the perturbed parametric score field.\"\"\"\n        return true_score_batch(x) + epsilon * rotational_field_batch(x)\n\n    def compute_metrics(case):\n        \"\"\"Computes D and E for a single test case.\"\"\"\n        x0, x, epsilon, a = case\n        x0, x = np.array(x0), np.array(x)\n\n        d_vec = x - x0\n        d_norm = np.linalg.norm(d_vec)\n\n        if np.isclose(d_norm, 0):\n            return 0.0, 0.0\n\n        t = np.linspace(0, 1, N_STEPS + 1)\n\n        # Path 1: Straight\n        gamma_straight = x0[:, np.newaxis] + d_vec[:, np.newaxis] * t\n        gamma_prime_straight = np.tile(d_vec[:, np.newaxis], (1, len(t)))\n        \n        s_theta_straight = parametric_score_batch(gamma_straight, epsilon)\n        integrand_straight = np.einsum('ij,ij-j', s_theta_straight, gamma_prime_straight)\n        I_straight = np.trapz(integrand_straight, t)\n\n        # Path 2: Curved\n        n_hat = (Q @ d_vec) / d_norm\n        gamma_curved = (x0[:, np.newaxis] + d_vec[:, np.newaxis] * t +\n                        a * np.sin(np.pi * t) * n_hat[:, np.newaxis])\n        gamma_prime_curved = (d_vec[:, np.newaxis] +\n                              a * np.pi * np.cos(np.pi * t) * n_hat[:, np.newaxis])\n\n        s_theta_curved = parametric_score_batch(gamma_curved, epsilon)\n        integrand_curved = np.einsum('ij,ij-j', s_theta_curved, gamma_prime_curved)\n        I_curved = np.trapz(integrand_curved, t)\n\n        # True log-density difference\n        log_p_x = log_pdf_gmm_batch(x[:, np.newaxis])[0]\n        log_p_x0 = log_pdf_gmm_batch(x0[:, np.newaxis])[0]\n        true_diff = log_p_x - log_p_x0\n        \n        # Metrics D and E\n        D = np.abs(I_straight - I_curved)\n        E = np.abs(I_straight - true_diff)\n\n        return D, E\n\n    test_cases = [\n        ([0.0, 0.0], [2.0, 1.0], 0.0, 0.5),      # Case 1\n        ([0.0, 0.0], [2.0, 1.0], 0.05, 0.5),     # Case 2\n        ([0.0, 0.0], [2.0, 1.0], 0.2, 0.5),      # Case 3\n        ([1.0, -1.0], [1.0, -1.0], 0.25, 1.0),   # Case 4\n        ([0.0, -2.0], [3.0, 1.0], 0.1, 2.0),     # Case 5\n    ]\n\n    results = []\n    for case in test_cases:\n        D_val, E_val = compute_metrics(case)\n        results.append(f\"[{D_val:.6f},{E_val:.6f}]\")\n\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3172994"}]}