{"hands_on_practices": [{"introduction": "Inception模块的一个核心设计原则是在保持甚至扩大感受野的同时，降低计算成本。这个练习将带你从第一性原理出发，深入探讨一个关键的优化技巧：用两个堆叠的$3 \\times 3$卷积替代一个$5 \\times 5$卷积。通过亲手计算和比较感受野、计算量以及非线性变换的数量，你将揭示这种“卷积分解”为何能在现代卷积神经网络设计中成为一项基本且高效的策略。[@problem_id:3137618]", "problem": "考虑一个 Inception 模块中的一个分支，该分支在一个空间尺寸为 $H \\times W$、具有 $C_{\\text{in}}$ 个输入通道和 $F$ 个输出通道的输入特征图上以两种备选方式实现。变体 $1$ 使用单个二维卷积，其核大小为 $5 \\times 5$，步幅为 $1$，无空洞，并使用“相同”零填充，将 $C_{\\text{in}} \\rightarrow F$ 映射。变体 $2$ 使用两个堆叠的二维卷积，每个卷积的核大小为 $3 \\times 3$，步幅为 $1$，无空洞，并使用“相同”零填充，其中第一个卷积将 $C_{\\text{in}} \\rightarrow F$ 映射，第二个卷积将 $F \\rightarrow F$ 映射。每次卷积后立即应用一个修正线性单元 (ReLU) 非线性激活函数。假设使用标准密集卷积（无分组且无深度可分离卷积），并在运算计数中忽略偏置成本和非线性激活成本。\n\n仅使用离散卷积的定义、组合步幅为$1$的卷积会使索引位移相加这一事实，以及通过计算卷积固有的求和运算中每个输出空间位置的乘累加（MAC）操作次数，从第一性原理出发，确定以下属性：\n\n- 在所述条件下，两种设计是否具有相同的感受野大小。\n- 在何种关于 $C_{\\text{in}}$ 和 $F$ 的代数条件下，变体 $2$ 的每个位置的 MAC 计数与变体 $1$ 相等。\n- 对于“相同”填充下的左上角输出空间位置，变体 $1$ 和变体 $2$ 的求和中有多少贡献项涉及填充输入。\n- 在每个变体中，信号在单个输入到输出路径上经历多少次非线性变换。\n\n选择所有正确的陈述：\n\nA. 在步幅为 $1$ 且无空洞的情况下，两个堆叠的 $3 \\times 3$ 卷积与一个 $5 \\times 5$ 卷积具有相同的感受野大小，即 $5 \\times 5$。\n\nB. 当且仅当 $C_{\\text{in}} = \\dfrac{9}{16} F$ 时，变体 $1$ 和变体 $2$ 的每个位置的 MAC 计数相等，前提是变体 $2$ 使用 $C_{\\text{in}} \\rightarrow F$ 然后 $F \\rightarrow F$ 的卷积，并且忽略偏置。\n\nC. 在每次卷积都使用“相同”零填充的情况下，对于左上角的输出位置，变体 $2$ 聚合了 $81$ 个二阶核贡献，其中 $45$ 个涉及填充输入，而变体 $1$ 聚合了 $25$ 个贡献，其中 $16$ 个涉及填充输入；因此，变体 $2$ 在边界处涉及的受填充影响的计算绝对数量更大。\n\nD. 因为组合了两个核，变体 $2$ 的感受野变为 $7 \\times 7$。\n\nE. 如果在每次卷积后都放置一个修正线性单元 (ReLU)，则在变体 $1$ 和变体 $2$ 中，沿输入到输出路径应用的非线性变换数量是相同的。", "solution": "问题陈述已经过验证，被认为是科学上合理、定义明确、客观且自洽的。我们开始进行解答。\n\n问题要求基于四个属性对两种备选的卷积分支设计（变体 $1$ 和变体 $2$）进行分析：感受野大小、计算成本（MACs）、填充的影响以及非线性变换的数量。我们将从第一性原理推导每个属性。\n\n设输入特征图的维度为 $H \\times W \\times C_{\\text{in}}$。两种变体都产生一个大小为 $H \\times W \\times F$ 的输出特征图。\n\n- **变体 1**：一个 $5 \\times 5$ 卷积，将 $C_{\\text{in}} \\rightarrow F$ 映射，步幅为 $1$。\n- **变体 2**：两个堆叠的 $3 \\times 3$ 卷积，步幅均为 $1$。第一个将 $C_{\\text{in}} \\rightarrow F$ 映射，第二个将 $F \\rightarrow F$ 映射。\n\n### 1. 感受野大小\n\n神经元的感受野是输入空间中影响其值的区域。对于一系列步幅为 $1$ 的卷积，感受野大小是累加增长的。对于第 $i$ 层，其核大小为 $k_i$，其后的感受野大小 $R_i$ 的通用公式为 $R_i = R_{i-1} + k_i - 1$，其中 $R_0 = 1$（单个输入像素）。\n\n- **变体 1**：我们有一个单层，核大小为 $k_1 = 5$。感受野大小为 $R_1 = R_0 + k_1 - 1 = 1 + 5 - 1 = 5$。感受野为 $5 \\times 5$。\n\n- **变体 2**：我们有两个堆叠的层，核大小均为 $k=3$。\n    - 第一次卷积后 ($k_1 = 3$)：感受野大小为 $R_1 = R_0 + k_1 - 1 = 1 + 3 - 1 = 3$。一个中间神经元看到一个 $3 \\times 3$ 大小的输入区域。\n    - 第二次卷积后 ($k_2 = 3$)：最终输出神经元的感受野大小为 $R_2 = R_1 + k_2 - 1 = 3 + 3 - 1 = 5$。一个输出神经元看到一个 $3 \\times 3$ 大小的中间特征图区域，而其中每个中间神经元的感受野已经是 $3 \\times 3$。相对于原始输入的总感受野是 $5 \\times 5$。\n\n因此，两种变体都具有相同的 $5 \\times 5$ 感受野大小。\n\n### 2. 每个位置的乘累加 (MAC) 计数\n\n计算输出特征图单个空间位置所需的 MAC 操作次数是输出通道数、输入通道数和核的空间大小（$K \\times K$）的乘积。忽略了偏置成本。\n\n- **变体 1**：\n    - 核大小：$5 \\times 5 = 25$。\n    - 输入通道数：$C_{\\text{in}}$。\n    - 输出通道数：$F$。\n    - 每个位置的 MAC 数 (V1) = $C_{\\text{in}} \\times F \\times 5 \\times 5 = 25 C_{\\text{in}} F$。\n\n- **变体 2**：总成本是两个卷积层成本的总和。\n    - **第一次卷积**：\n        - 核大小：$3 \\times 3 = 9$。\n        - 输入通道数：$C_{\\text{in}}$。\n        - 输出通道数：$F$。\n        - MACs (Conv1) = $C_{\\text{in}} \\times F \\times 3 \\times 3 = 9 C_{\\text{in}} F$。\n    - **第二次卷积**：\n        - 核大小：$3 \\times 3 = 9$。\n        - 输入通道数：$F$（来自第一层的输出）。\n        - 输出通道数：$F$。\n        - MACs (Conv2) = $F \\times F \\times 3 \\times 3 = 9 F^2$。\n    - **每个位置的总 MAC 数 (V2)** = MACs(Conv1) + MACs(Conv2) = $9 C_{\\text{in}} F + 9 F^2$。\n\n为了找到 MAC 计数相等的条件，我们令 MACs(V1) = MACs(V2)：\n$$25 C_{\\text{in}} F = 9 C_{\\text{in}} F + 9 F^2$$\n假设 $F \\neq 0$，我们可以两边除以 $F$：\n$$25 C_{\\text{in}} = 9 C_{\\text{in}} + 9 F$$\n$$16 C_{\\text{in}} = 9 F$$\n$$C_{\\text{in}} = \\frac{9}{16} F$$\n\n### 3. 左上角输出的填充输入贡献\n\n我们分析空间位置 $(0, 0)$ 处输出的计算。“相同”填充会添加零行/列，以确保输出空间维度与输入匹配。对于大小为 $K \\times K$、步幅为 $1$ 的核，每侧所需的填充为 $P = (K-1)/2$。\n\n- **变体 1**：核大小 $K = 5$，所以填充为 $P = (5-1)/2 = 2$。在计算 $(0,0)$ 处的输出时，$5 \\times 5$ 的核覆盖了填充后输入中对应于原始输入索引从 $-2$ 到 $2$ 的区域。\n    - 求和中的空间项总数为 $5 \\times 5 = 25$。这些就是“贡献”。\n    - 具有非负索引的输入值来自原始特征图。对于左上角位置，这对应于索引 $(i,j)$，其中 $i,j \\in \\{0, 1, 2\\}$。这是一个 $3 \\times 3$ 的网格，因此有 $9$ 个非填充贡献。\n    - 来自填充零的贡献数量为 $25 - 9 = 16$。\n\n- **变体 2**：这涉及两个 $3 \\times 3$ 的卷积。设核为 $W_1$（第一层）和 $W_2$（第二层）。一个输出像素 $Y$ 是通过中间图 $I$ 得到的输入 $X$ 的函数。示意性地表示为 $Y \\sim W_2 \\star I = W_2 \\star (W_1 \\star X)$。为进行结构分析，忽略 ReLU 和通道维度，这等效于 $Y \\sim (W_2 \\star W_1) \\star X$，其中 $W_{\\text{eff}} = W_2 \\star W_1$ 是一个大小为 $(3+3-1) \\times (3+3-1) = 5 \\times 5$ 的有效核。\n    - 一个输出像素值的计算可以展开为一系列项的和，每一项都是一个来自 $W_1$ 的权重、一个来自 $W_2$ 的权重和一个输入像素值 $X$ 的乘积。\n    $Y_{i,j} = \\sum_{p,q} W_2(p,q) I_{i-p, j-q} = \\sum_{p,q} W_2(p,q) \\left( \\sum_{r,s} W_1(r,s) X_{i-p-r, j-q-s} \\right)$。\n    - 对于单个输出像素，此类“二阶核贡献”的总数是每个核中权重数量的乘积：$3 \\times 3 \\times 3 \\times 3 = 81$。\n    - 我们需要计算这 $81$ 个项中有多少项在计算 $(0,0)$ 处的输出时使用了填充输入。如果输入索引 $(i,j)$ 满足 $i0$ 或 $j0$，则该项涉及填充输入。输入索引由 $(-p-r, -q-s)$ 给出，其中 $p,q,r,s \\in \\{-1, 0, 1\\}$（如果核索引是相对于中心的）。计算非填充项更容易，即 $-p-r \\ge 0$ 和 $-q-s \\ge 0$，这等价于 $p+r \\le 0$ 和 $q+s \\le 0$。\n    - 我们来计算来自 $\\{-1,0,1\\}$ 的满足 $k_1+k_2 \\le 0$ 的数对 $(k_1, k_2)$ 的数量：\n        - 如果 $k_1 = -1$，$k_2$ 可以是 $-1, 0, 1$（$3$ 种选择）。\n        - 如果 $k_1 = 0$，$k_2$ 可以是 $-1, 0$（$2$ 种选择）。\n        - 如果 $k_1 = 1$，$k_2$ 可以是 $-1$（$1$ 种选择）。\n        - 总选择 = $3+2+1=6$。\n    - 非填充项的数量是当两个索引都为非负数时，因此行索引对 $(p,r)$ 有 $6$ 种选择，列索引对 $(q,s)$ 也有 $6$ 种选择。总的非填充项 = $6 \\times 6 = 36$。\n    - 涉及填充输入的项数是总数减去非填充项数：$81 - 36 = 45$。\n    - 比较两种变体，变体 $1$ 在边界处有 $16$ 个受填充影响的计算，而变体 $2$ 有 $45$ 个。因此，$45 > 16$，变体 $2$ 涉及更多此类计算。\n\n### 4. 输入到输出路径上的非线性变换数量\n\n“单个输入到输出路径”指的是信号从一个输入神经元到一个输出神经元所经历的操作序列。每次卷积后都会应用一个修正线性单元 (ReLU)。\n\n- **变体 1**：路径是：输入 $\\rightarrow$ 卷积 $\\rightarrow$ ReLU $\\rightarrow$ 输出。信号通过一个非线性变换。\n\n- **变体 2**：路径是：输入 $\\rightarrow$ 卷积1 $\\rightarrow$ ReLU1 $\\rightarrow$ 卷积2 $\\rightarrow$ ReLU2 $\\rightarrow$ 输出。信号通过第一个 ReLU，然后由第二个卷积处理，最后通过第二个 ReLU。经历的非线性变换总数为两个。\n\n因此，两种变体中的非线性变换数量不相同。\n\n### 评估选项\n\n**A. 在步幅为 $1$ 且无空洞的情况下，两个堆叠的 $3 \\times 3$ 卷积与一个 $5 \\times 5$ 卷积具有相同的感受野大小，即 $5 \\times 5$。**\n我们在第 1 节的推导表明，两个堆叠的 $3 \\times 3$ 卷积的感受野是 $5 \\times 5$，这与单个 $5 \\times 5$ 卷积的感受野相同。\n**结论：正确。**\n\n**B. 当且仅当 $C_{\\text{in}} = \\dfrac{9}{16} F$ 时，变体 $1$ 和变体 $2$ 的每个位置的 MAC 计数相等，前提是变体 $2$ 使用 $C_{\\text{in}} \\rightarrow F$ 然后 $F \\rightarrow F$ 的卷积，并且忽略偏置。**\n我们在第 2 节的推导证实了这个精确的代数条件。计算 $25 C_{\\text{in}} F = 9 C_{\\text{in}} F + 9 F^2$ 直接得出 $C_{\\text{in}} = \\frac{9}{16}F$。\n**结论：正确。**\n\n**C. 在每次卷积都使用“相同”零填充的情况下，对于左上角的输出位置，变体 $2$ 聚合了 $81$ 个二阶核贡献，其中 $45$ 个涉及填充输入，而变体 $1$ 聚合了 $25$ 个贡献，其中 $16$ 个涉及填充输入；因此，变体 $2$ 在边界处涉及的受填充影响的计算绝对数量更大。**\n我们在第 3 节的分析证实了所有数值声明。变体 1：总共 $25$ 个贡献，其中 $16$ 个是填充的。变体 2：$81$ 个二阶贡献，其中 $45$ 个是填充的。变体 $2$ 涉及更多受填充影响的计算（$45 > 16$）这一结论也是正确的。\n**结论：正确。**\n\n**D. 因为组合了两个核，变体 $2$ 的感受野变为 $7 \\times 7$。**\n这是不正确的。如第 1 节所示，感受野大小是 $5 \\times 5$。一个 $7 \\times 7$ 的感受野需要，例如，三个堆叠的 $3 \\times 3$ 卷积。\n**结论：不正确。**\n\n**E. 如果在每次卷积后都放置一个修正线性单元 (ReLU)，则在变体 $1$ 和变体 $2$ 中，沿输入到输出路径应用的非线性变换数量是相同的。**\n这是不正确的。如第 4 节所示，变体 1 有一个非线性变换，而变体 2 有两个。\n**结论：不正确。**", "answer": "$$\\boxed{ABC}$$", "id": "3137618"}, {"introduction": "一个Inception模块的威力来自于其多分支并行结构，但这引出了一个关键的设计问题：如何在有限的计算资源（FLOPs）下，为不同尺寸的卷积分支分配合理的通道数？本练习将此架构设计问题转化为一个带约束的优化问题。你将运用拉格朗日乘数法，在给定的计算预算下，最大化一个旨在平衡感受野覆盖和通道深度的效用函数，从而从数学上推导出最优的资源分配方案。[@problem_id:3137632]", "problem": "考虑一个单一的 Inception 模块，它有三个并行的卷积分支，作用于相同的输入特征图。输入特征图的空间维度为 $H = 10$ 和 $W = 10$，输入通道数为 $c_{\\text{in}} = 10$。这三个分支分别使用空间尺寸为 $k_{1} = 1$、$k_{2} = 3$ 和 $k_{3} = 5$ 的卷积核，并产生 $c_{1}$、$c_{2}$ 和 $c_{3}$ 个输出通道。假设输出的空间维度与输入的空间维度相匹配（使用相同的填充和单位步长）。将通道数 $c_{i}$ 视为连续的非负实变量，以便进行基于微积分的优化。\n\n作为基本依据，使用标准的卷积运算计数：对于一个在 $H \\times W$ 空间位置上应用的、卷积核大小为 $k \\times k$、输入通道数为 $c_{\\text{in}}$、输出通道数为 $c_{\\text{out}}$ 的二维卷积，其浮点运算总数（FLOPs）与 $H W \\, c_{\\text{in}} \\, c_{\\text{out}} \\, k^{2}$ 成正比。设三个分支的总 FLOPs 用 $B$ 表示，并假设有一个必须严格满足的硬性预算 $B = 150000$ FLOPs。\n\n为了捕捉跨分支的收益递减和尺度偏好，将有效感受野覆盖效用定义为以下凹函数\n$$U(c_{1}, c_{2}, c_{3}) = w_{1} \\ln(c_{1} k_{1}) + w_{2} \\ln(c_{2} k_{2}) + w_{3} \\ln(c_{3} k_{3}),$$\n其中权重为 $w_{1} = 1$、$w_{2} = 2$ 和 $w_{3} = 3$。目标是在 FLOPs 预算的约束下最大化 $U$。\n\n构建并求解选择 $(c_{1}, c_{2}, c_{3})$ 以在等式约束\n$$H W \\, c_{\\text{in}} \\left(c_{1} k_{1}^{2} + c_{2} k_{2}^{2} + c_{3} k_{3}^{2}\\right) = B.$$\n下最大化 $U$ 的约束优化问题。使用第一性原理和拉格朗日乘数法推导最优分配。以最优通道分配 $\\left(c_{1}^{\\star}, c_{2}^{\\star}, c_{3}^{\\star}\\right)$ 的单行向量形式表示你的最终答案，要求为精确形式（不进行四舍五入）。", "solution": "首先根据指定标准对问题进行验证。\n\n**步骤 1：提取已知条件**\n- 输入特征图维度：$H = 10$，$W = 10$。\n- 输入通道数：$c_{\\text{in}} = 10$。\n- 并行分支数量：$3$。\n- 三个分支的卷积核大小：$k_{1} = 1$，$k_{2} = 3$，$k_{3} = 5$。\n- 三个分支的输出通道数：$c_{1}, c_{2}, c_{3}$（连续非负实变量）。\n- 总 FLOPs 预算：$B = 150000$。\n- FLOPs 约束方程：$H W \\, c_{\\text{in}} \\left(c_{1} k_{1}^{2} + c_{2} k_{2}^{2} + c_{3} k_{3}^{2}\\right) = B$。\n- 待最大化的效用函数：$U(c_{1}, c_{2}, c_{3}) = w_{1} \\ln(c_{1} k_{1}) + w_{2} \\ln(c_{2} k_{2}) + w_{3} \\ln(c_{3} k_{3})$。\n- 效用函数的权重：$w_{1} = 1$，$w_{2} = 2$，$w_{3} = 3$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题在深度学习领域有充分的理论基础。它模拟了神经架构中的一个常见设计选择，特别是在 Inception 风格模块的并行分支之间分配计算资源（FLOPs）。FLOPs 的近似计算是标准方法，使用凹效用函数来模拟收益递减是优化中一种有效且常用的技术。\n- **适定性：** 该任务是在一个线性等式约束下，最大化一个严格凹函数（$U$ 是对数函数之和）。这是一个经典的凸优化问题，保证了唯一、稳定且有意义解的存在性。\n- **客观性：** 问题使用精确的数学语言陈述，所有术语和变量都有明确定义。\n- **一致性与完整性：** 问题为获得唯一解提供了所有必要的信息和条件，不存在矛盾之处。\n\n**步骤 3：结论与行动**\n该问题是有效的，因为它具有科学依据、适定性、客观性、完整性和一致性。可以继续求解过程。\n\n这是一个约束优化问题。我们的目标是在总 FLOPs 预算的约束下，最大化效用函数 $U(c_{1}, c_{2}, c_{3})$。拉格朗日乘数法适用于此任务。\n\n目标函数是\n$$U(c_{1}, c_{2}, c_{3}) = w_{1} \\ln(c_{1} k_{1}) + w_{2} \\ln(c_{2} k_{2}) + w_{3} \\ln(c_{3} k_{3})$$\n约束由以下方程给出\n$$H W \\, c_{\\text{in}} \\left(c_{1} k_{1}^{2} + c_{2} k_{2}^{2} + c_{3} k_{3}^{2}\\right) = B$$\n我们将约束函数 $g(c_{1}, c_{2}, c_{3})$ 定义为\n$$g(c_{1}, c_{2}, c_{3}) = H W \\, c_{\\text{in}} \\left(c_{1} k_{1}^{2} + c_{2} k_{2}^{2} + c_{3} k_{3}^{2}\\right) - B = 0$$\n拉格朗日函数 $\\mathcal{L}$ 是通过将目标函数和约束函数与一个拉格朗日乘子 $\\lambda$ 组合而成的：\n$$\\mathcal{L}(c_{1}, c_{2}, c_{3}, \\lambda) = U(c_{1}, c_{2}, c_{3}) - \\lambda g(c_{1}, c_{2}, c_{3})$$\n$$\\mathcal{L}(c_{1}, c_{2}, c_{3}, \\lambda) = \\sum_{i=1}^{3} w_{i} \\ln(c_{i} k_{i}) - \\lambda \\left[ H W \\, c_{\\text{in}} \\left(\\sum_{i=1}^{3} c_{i} k_{i}^{2}\\right) - B \\right]$$\n为了找到最优值 $(c_{1}^{\\star}, c_{2}^{\\star}, c_{3}^{\\star})$，我们必须通过对拉格朗日函数求关于每个变量（$c_{1}, c_{2}, c_{3}, \\lambda$）的偏导数并将其设为零来找到其临界点。\n\n关于 $c_{i}$（其中 $i=1, 2, 3$）的偏导数是：\n$$\\frac{\\partial \\mathcal{L}}{\\partial c_{i}} = \\frac{\\partial}{\\partial c_{i}} \\left( w_{i} \\ln(c_{i} k_{i}) \\right) - \\lambda \\frac{\\partial}{\\partial c_{i}} \\left( H W \\, c_{\\text{in}} c_{i} k_{i}^{2} \\right)$$\n使用链式法则，$\\frac{d}{dx} \\ln(ax) = \\frac{1}{ax} \\cdot a = \\frac{1}{x}$。所以，$\\frac{\\partial}{\\partial c_i} (w_i \\ln(c_i k_i)) = w_i \\frac{1}{c_i k_i} \\cdot k_i = \\frac{w_i}{c_i}$。\n$$\\frac{\\partial \\mathcal{L}}{\\partial c_{i}} = \\frac{w_{i}}{c_{i}} - \\lambda H W c_{\\text{in}} k_{i}^{2} = 0$$\n这给了我们一个由三个方程组成的方程组：\n1. $\\frac{w_{1}}{c_{1}} - \\lambda H W c_{\\text{in}} k_{1}^{2} = 0$\n2. $\\frac{w_{2}}{c_{2}} - \\lambda H W c_{\\text{in}} k_{2}^{2} = 0$\n3. $\\frac{w_{3}}{c_{3}} - \\lambda H W c_{\\text{in}} k_{3}^{2} = 0$\n\n从这些方程中，我们可以用 $\\lambda$ 来表示每个 $c_{i}$：\n$$c_{i} = \\frac{w_{i}}{\\lambda H W c_{\\text{in}} k_{i}^{2}}$$\n第四个方程来自对 $\\lambda$ 的偏导数，它恰好恢复了约束条件：\n$$\\frac{\\partial \\mathcal{L}}{\\partial \\lambda} = -\\left[ H W \\, c_{\\text{in}} \\left(\\sum_{i=1}^{3} c_{i} k_{i}^{2}\\right) - B \\right] = 0$$\n$$H W \\, c_{\\text{in}} \\left(c_{1} k_{1}^{2} + c_{2} k_{2}^{2} + c_{3} k_{3}^{2}\\right) = B$$\n现在，将 $c_{i}$ 的表达式代入约束方程以求解 $\\lambda$：\n$$H W \\, c_{\\text{in}} \\sum_{i=1}^{3} \\left( \\frac{w_{i}}{\\lambda H W c_{\\text{in}} k_{i}^{2}} \\right) k_{i}^{2} = B$$\n项 $k_{i}^{2}$ 被消去：\n$$H W \\, c_{\\text{in}} \\sum_{i=1}^{3} \\left( \\frac{w_{i}}{\\lambda H W c_{\\text{in}}} \\right) = B$$\n提出公因式 $1/(\\lambda H W c_{\\text{in}})$：\n$$H W \\, c_{\\text{in}} \\frac{1}{\\lambda H W c_{\\text{in}}} \\sum_{i=1}^{3} w_{i} = B$$\n项 $H W c_{\\text{in}}$ 被消去，剩下：\n$$\\frac{1}{\\lambda} \\sum_{i=1}^{3} w_{i} = B$$\n求解 $\\lambda$：\n$$\\lambda = \\frac{\\sum_{i=1}^{3} w_{i}}{B}$$\n现在我们将这个 $\\lambda$ 的值代回到 $c_{i}$ 的表达式中：\n$$c_{i}^{\\star} = \\frac{w_{i}}{\\left(\\frac{\\sum_{j=1}^{3} w_{j}}{B}\\right) H W c_{\\text{in}} k_{i}^{2}} = \\frac{w_{i} B}{\\left(\\sum_{j=1}^{3} w_{j}\\right) H W c_{\\text{in}} k_{i}^{2}}$$\n这就是最优通道分配 $c_{i}^{\\star}$ 的通解。\n\n我们现在可以代入给定的数值：\n- $H=10, W=10 \\implies HW = 100$\n- $c_{\\text{in}} = 10$\n- $B = 150000$\n- $k_{1}=1, k_{2}=3, k_{3}=5 \\implies k_{1}^{2}=1, k_{2}^{2}=9, k_{3}^{2}=25$\n- $w_{1}=1, w_{2}=2, w_{3}=3 \\implies \\sum_{j=1}^{3} w_{j} = 1+2+3 = 6$\n\n让我们计算 $c_{i}^{\\star}$ 表达式中的公因子：\n$$\\frac{B}{\\left(\\sum_{j=1}^{3} w_{j}\\right) H W c_{\\text{in}}} = \\frac{150000}{6 \\cdot 100 \\cdot 10} = \\frac{150000}{6000} = \\frac{150}{6} = 25$$\n现在我们可以计算每个最优通道数：\n$$c_{1}^{\\star} = \\frac{w_{1}}{k_{1}^{2}} \\cdot 25 = \\frac{1}{1} \\cdot 25 = 25$$\n$$c_{2}^{\\star} = \\frac{w_{2}}{k_{2}^{2}} \\cdot 25 = \\frac{2}{9} \\cdot 25 = \\frac{50}{9}$$\n$$c_{3}^{\\star} = \\frac{w_{3}}{k_{3}^{2}} \\cdot 25 = \\frac{3}{25} \\cdot 25 = 3$$\n因此，最优分配为 $(c_{1}^{\\star}, c_{2}^{\\star}, c_{3}^{\\star}) = (25, 50/9, 3)$。\n\n为了验证结果，我们可以检查是否满足 FLOPs 预算：\n$$H W c_{\\text{in}} (c_{1}^{\\star} k_{1}^{2} + c_{2}^{\\star} k_{2}^{2} + c_{3}^{\\star} k_{3}^{2}) = 10 \\cdot 10 \\cdot 10 \\left( 25 \\cdot 1^{2} + \\frac{50}{9} \\cdot 3^{2} + 3 \\cdot 5^{2} \\right)$$\n$$= 1000 \\left( 25 + \\frac{50}{9} \\cdot 9 + 3 \\cdot 25 \\right)$$\n$$= 1000 (25 + 50 + 75) = 1000(150) = 150000$$\n这与预算 $B$ 相符，证实了解答的正确性。\n\n最终答案是最优通道分配的行向量。", "answer": "$$ \\boxed{ \\begin{pmatrix} 25  \\frac{50}{9}  3 \\end{pmatrix} } $$", "id": "3137632"}, {"introduction": "我们已经从理论上设计了一个高效的多分支模块，现在是时候通过编码实践来验证其优势了。这个练习旨在探究Inception模块对输入扰动（如此处的模糊）的鲁棒性，这是其多尺度设计的核心价值所在。你将通过编写代码，设计一系列对照实验，比较点卷积（$1 \\times 1$）和空间卷积（$3 \\times 3$）分支在图像模糊后的性能退化情况，从而直观地理解为何并行处理不同尺度的特征能够提升模型的稳健性。[@problem_id:3137579]", "problem": "考虑一个Inception风格的多分支模块，它由两个线性卷积分支组成：一个逐点分支和一个空间分支。逐点分支使用 $1 \\times 1$ 卷积，空间分支使用 $3 \\times 3$ 卷积。设图像为一个实值离散数组 $I \\in \\mathbb{R}^{H \\times W}$。设离散二维卷积用 $*$ 表示，数组 $A$ 的 $L^2$ 范数为 $\\|A\\|_2 = \\sqrt{\\sum_{i,j} A_{i,j}^2}$。定义高斯模糊算子为与一个离散、归一化的高斯核 $G_\\sigma \\in \\mathbb{R}^{m \\times m}$ 进行卷积，其中 $m = 2\\lceil 3\\sigma \\rceil + 1$，核的条目由 $G_\\sigma[i,j] \\propto \\exp\\left(-\\frac{i^2 + j^2}{2\\sigma^2}\\right)$ 给出（对于以零为中心的整数坐标 $i,j$），并且核被归一化以使 $\\sum_{i,j} G_\\sigma[i,j] = 1$。对于特殊情况 $\\sigma = 0$，定义 $G_0$ 为大小为 $1 \\times 1$ 的离散$\\delta$核，即 $G_0 = [1]$。\n\n设逐点分支的核为大小为 $1 \\times 1$ 的 $K_{1} = [1]$，表示一个单位映射。设空间分支的核为归一化盒式滤波器 $K_{3} \\in \\mathbb{R}^{3 \\times 3}$，其条目为 $K_{3}[i,j] = \\frac{1}{9}$，对于所有的 $i,j \\in \\{-1,0,1\\}$。\n\n对于给定的图像 $I$ 和模糊水平 $\\sigma$，定义分支前输出\n$$\nY_{1,\\text{clean}} = I * K_{1}, \\quad Y_{3,\\text{clean}} = I * K_{3},\n$$\n以及模糊后输出\n$$\nI_{\\text{blur}} = I * G_\\sigma, \\quad Y_{1,\\text{blur}} = I_{\\text{blur}} * K_{1}, \\quad Y_{3,\\text{blur}} = I_{\\text{blur}} * K_{3}.\n$$\n定义分支 $b \\in \\{1,3\\}$ 的相对退化为\n$$\nD_b(I,\\sigma) = \\frac{\\|Y_{b,\\text{blur}} - Y_{b,\\text{clean}}\\|_2}{\\|Y_{b,\\text{clean}}\\|_2},\n$$\n约定如果 $\\|Y_{b,\\text{clean}}\\|_2 = 0$，则 $D_b(I,\\sigma) = 0$。\n\n你的任务是编写一个完整的程序，对于一组固定的图像和模糊水平测试集，为每个测试用例计算布尔值\n$$\n\\text{result} = \\left( D_3(I,\\sigma) \\le D_1(I,\\sigma) + \\tau \\right),\n$$\n其中 $\\tau$ 是一个数值容差，定义为 $\\tau = 10^{-8}$。\n\n该程序必须实现以下科学受控的模糊实验，对所有卷积使用对称边界处理的离散卷积：\n\n- 在大小为 $H = 64$, $W = 64$ 的网格上的图像定义：\n  - 块周期为 $p$ 的棋盘格图像，定义为\n    $$\n    I[i,j] = \\left( \\left\\lfloor \\frac{i}{p} \\right\\rfloor + \\left\\lfloor \\frac{j}{p} \\right\\rfloor \\right) \\bmod 2 \\in \\{0,1\\}, \\quad \\text{然后通过 } I \\leftarrow 2I - 1 \\text{ 映射到 } \\{-1,1\\}。\n    $$\n  - 垂直阶跃图像，定义为当 $j  \\left\\lfloor \\frac{W}{2} \\right\\rfloor$ 时 $I[i,j] = 0$，否则 $I[i,j] = 1$。\n  - 脉冲图像，定义为所有 $i,j$ 的 $I[i,j] = 0$，除了 $I[\\left\\lfloor \\frac{H}{2} \\right\\rfloor, \\left\\lfloor \\frac{W}{2} \\right\\rfloor] = 1$。\n  - 零均值随机噪声图像，定义为 $I[i,j]$ 从标准正态分布中独立采样，使用固定的种子以保证可复现性。\n\n- 具有不同案例的测试集，旨在覆盖一般情况、高频敏感性、类边缘结构、脉冲响应、对噪声的强模糊以及边界情况：\n  1. 棋盘格图像， $p = 4$, $\\sigma = 1.0$。\n  2. 棋盘格图像， $p = 2$, $\\sigma = 2.0$。\n  3. 垂直阶跃图像， $\\sigma = 1.5$。\n  4. 脉冲图像， $\\sigma = 0.75$。\n  5. 噪声图像，种子为 $0$，$\\sigma = 3.0$。\n  6. 棋盘格图像， $p = 8$, $\\sigma = 0.0$。\n\n对于每个测试用例，使用 $\\tau = 10^{-8}$ 计算如上定义的布尔结果。你的程序应该生成单行输出，包含一个用方括号括起来的逗号分隔列表，例如\n$$\n[\\text{result}_1,\\text{result}_2,\\dots,\\text{result}_6].\n$$\n列表中每个条目唯一可接受的输出是字面量 $\\text{True}$ 或 $\\text{False}$。不涉及物理单位，也不使用角度。确保所有计算都使用所指定的精确定义的离散卷积和高斯核来执行。", "solution": "问题陈述已经过验证，被认为是科学上合理、适定且计算上可行的。所有定义、常数和条件都已提供，构成一个自洽且一致的问题。因此，我们可以着手提出一个合理的解决方案。\n\n任务是对于一组特定的图像 $I$ 和模糊水平 $\\sigma$，确定空间卷积分支的相对退化 $D_3(I, \\sigma)$ 是否小于或等于逐点分支的相对退化 $D_1(I, \\sigma)$ 加上一个小的容差 $\\tau$。问题的核心在于精确实现离散二维卷积、生成指定的图像和核，以及计算 $L^2$ 范数。\n\n让我们首先澄清所涉及的量。逐点分支使用一个 $1 \\times 1$ 的单位核 $K_1 = [1]$，空间分支使用一个 $3 \\times 3$ 的归一化盒式滤波器 $K_3$，其中 $K_3[i,j] = 1/9$。输入图像 $I$ 通过与归一化高斯核 $G_\\sigma$ 卷积进行模糊，生成 $I_{\\text{blur}} = I * G_\\sigma$。\n\n对于清晰图像 $I$ 的分支输出是：\n$$\nY_{1,\\text{clean}} = I * K_1 = I\n$$\n$$\nY_{3,\\text{clean}} = I * K_3\n$$\n\n对于模糊图像 $I_{\\text{blur}}$ 的输出是：\n$$\nY_{1,\\text{blur}} = I_{\\text{blur}} * K_1 = I_{\\text{blur}}\n$$\n$$\nY_{3,\\text{blur}} = I_{\\text{blur}} * K_3\n$$\n\n每个分支 $b \\in \\{1, 3\\}$ 的相对退化定义为分支输出变化量的 $L^2$ 范数与原始输出的 $L^2$ 范数之比：\n$$\nD_b(I,\\sigma) = \\frac{\\|Y_{b,\\text{blur}} - Y_{b,\\text{clean}}\\|_2}{\\|Y_{b,\\text{clean}}\\|_2}\n$$\n问题规定，如果分母 $\\|Y_{b,\\text{clean}}\\|_2$ 为零，则 $D_b(I,\\sigma) = 0$。最终要进行的比较是 $D_3(I, \\sigma) \\le D_1(I, \\sigma) + \\tau$，其中 $\\tau = 10^{-8}$。\n\n该解决方案是作为针对问题陈述中指定的每个测试用例的一系列计算步骤来实现的。\n\n1.  **图像生成**：对每个测试用例，根据其数学定义生成大小为 $H=64, W=64$ 的相应图像 $I$。这包括具有周期 $p$ 的棋盘格图案、垂直阶跃函数、单像素脉冲，以及来自带种子的随机数生成器的零均值随机噪声场，以保证可复现性。\n\n2.  **核生成**：\n    *   核 $K_1$ 和 $K_3$ 在整个实验中是恒定的。\n    *   对于每个指定的 $\\sigma$ 值，生成高斯核 $G_\\sigma$。核的大小为 $m = 2 \\lceil 3\\sigma \\rceil + 1$。其条目通过公式 $G_\\sigma[i,j] \\propto \\exp\\left(-\\frac{i^2 + j^2}{2\\sigma^2}\\right)$ 在一个以 $(0,0)$ 为中心的整数坐标网格上计算，然后进行归一化以确保条目之和为 $1$。特殊情况 $\\sigma=0$ 会得到 $1 \\times 1$ 的单位核 $G_0 = [1]$。\n\n3.  **卷积运算**：所有卷积都按规定使用带对称边界处理的离散二维卷积来执行。这在计算上是通过使用 `scipy.signal.convolve2d` 函数并设置参数 `mode='same'` 和 `boundary='symm'` 来实现的。`'same'` 模式确保输出数组与输入图像具有相同的维度，而 `'symm'` 实现指定的边界条件。运算顺序严格遵循定义：输入图像 $I$ 首先被模糊成 $I_{\\text{blur}}$，然后通过分支卷积。虽然对于无限信号，卷积是可结合的（即 $(A*B)*C = A*(B*C)$），但对于带边界处理的离散信号，此属性并不严格成立，因此我们严格遵循规定的运算顺序 $Y_{3,\\text{blur}} = (I*G_\\sigma)*K_3$。\n\n4.  **退化计算**：\n    *   首先，计算清晰输出 $Y_{1,\\text{clean}}$ 和 $Y_{3,\\text{clean}}$。\n    *   然后，计算模糊图像 $I_{\\text{blur}} = I * G_\\sigma$。\n    *   接着，从 $I_{\\text{blur}}$ 计算模糊输出 $Y_{1,\\text{blur}}$ 和 $Y_{3,\\text{blur}}$。\n    *   使用 `numpy.linalg.norm` 计算 $L^2$ 范数。\n    *   根据定义计算退化值 $D_1$ 和 $D_3$，并检查处理分母接近零的情况，此时退化值设为 $0$。\n\n5.  **最终比较**：通过评估表达式 $D_3 \\le D_1 + \\tau$ 获得布尔结果。对所有六个测试用例重复此过程，并将结果收集到一个列表中。\n\n整个过程构成了一个定义明确的数值实验，用于研究不同卷积滤波器结构对输入扰动的鲁棒性，这是设计鲁棒深度神经网络的核心概念。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.signal import convolve2d\n\ndef solve():\n    \"\"\"\n    Performs a series of scientifically controlled blur experiments on different images\n    to compare the relative degradation of a pointwise and a spatial convolutional branch.\n    \"\"\"\n    # Define global parameters from the problem statement\n    H, W = 64, 64\n    tau = 1e-8\n\n    # Define the test suite\n    # Each case is a tuple: (image_type, parameter, sigma)\n    # The parameter is 'p' for checkerboard, 'seed' for noise, or None.\n    test_cases = [\n        ('checkerboard', 4, 1.0),\n        ('checkerboard', 2, 2.0),\n        ('vertical_step', None, 1.5),\n        ('impulse', None, 0.75),\n        ('noise', 0, 3.0),\n        ('checkerboard', 8, 0.0),\n    ]\n\n    results = []\n\n    # Process each test case\n    for image_type, param, sigma in test_cases:\n        \n        # --- 1. Generate Image I ---\n        if image_type == 'checkerboard':\n            p = param\n            # Create coordinate grids\n            i_coords, j_coords = np.mgrid[0:H, 0:W]\n            # Calculate block indices\n            i_blocks = i_coords // p\n            j_blocks = j_coords // p\n            # Create checkerboard pattern {0, 1}\n            I = ((i_blocks + j_blocks) % 2).astype(float)\n            # Map to {-1, 1}\n            I = 2 * I - 1\n        elif image_type == 'vertical_step':\n            I = np.zeros((H, W), dtype=float)\n            j_mid = W // 2\n            I[:, j_mid:] = 1.0\n        elif image_type == 'impulse':\n            I = np.zeros((H, W), dtype=float)\n            i_mid, j_mid = H // 2, W // 2\n            I[i_mid, j_mid] = 1.0\n        elif image_type == 'noise':\n            seed = param\n            rng = np.random.default_rng(seed)\n            I = rng.standard_normal((H, W))\n        \n        # --- 2. Define Convolution Kernels ---\n        K1 = np.array([[1.0]], dtype=float)\n        K3 = np.ones((3, 3), dtype=float) / 9.0\n        \n        # --- 3. Generate Gaussian Kernel G_sigma ---\n        if sigma == 0:\n            G_sigma = np.array([[1.0]], dtype=float)\n        else:\n            m_half = int(np.ceil(3 * sigma))\n            x = np.arange(-m_half, m_half + 1)\n            # Use 'ij' indexing to match matrix row/column convention\n            ii, jj = np.meshgrid(x, x, indexing='ij')\n            G_sigma = np.exp(-(ii**2 + jj**2) / (2 * sigma**2))\n            G_sigma /= np.sum(G_sigma)\n            \n        # --- 4. Compute Degradations D1 and D3 ---\n\n        # Pre-blur outputs (clean)\n        Y1_clean = I # Convolution with K1 (identity)\n        Y3_clean = convolve2d(I, K3, mode='same', boundary='symm')\n\n        # Blurred image\n        I_blur = convolve2d(I, G_sigma, mode='same', boundary='symm')\n\n        # Post-blur outputs\n        Y1_blur = I_blur # Convolution with K1 (identity)\n        Y3_blur = convolve2d(I_blur, K3, mode='same', boundary='symm')\n        \n        # Calculate degradation for Branch 1\n        norm_Y1_clean = np.linalg.norm(Y1_clean)\n        if np.isclose(norm_Y1_clean, 0):\n            D1 = 0.0\n        else:\n            norm_diff_Y1 = np.linalg.norm(Y1_blur - Y1_clean)\n            D1 = norm_diff_Y1 / norm_Y1_clean\n\n        # Calculate degradation for Branch 3\n        norm_Y3_clean = np.linalg.norm(Y3_clean)\n        if np.isclose(norm_Y3_clean, 0):\n            D3 = 0.0\n        else:\n            norm_diff_Y3 = np.linalg.norm(Y3_blur - Y3_clean)\n            D3 = norm_diff_Y3 / norm_Y3_clean\n            \n        # --- 5. Compute the final boolean result ---\n        is_less_or_equal = (D3 = D1 + tau)\n        results.append(is_less_or_equal)\n        \n    # --- 6. Print the final results in the specified format ---\n    print(f\"[{','.join(map(str, results))}]\")\n\n# Execute the main function\nsolve()\n```", "id": "3137579"}]}