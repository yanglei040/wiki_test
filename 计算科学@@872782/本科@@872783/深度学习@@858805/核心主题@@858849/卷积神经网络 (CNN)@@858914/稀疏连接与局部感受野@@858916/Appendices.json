{"hands_on_practices": [{"introduction": "要构建有效的卷积神经网络（CNN），首要任务是掌握感受野（receptive field）如何随着网络深度的增加而扩展。这个练习将引导你从基本定义出发，推导出计算感受野大小的通用公式，从而将理论知识内化为深刻的直觉。通过这种方式，你将不再仅仅是套用公式，而是能够真正理解是什么因素（例如核大小 $k$、步长 $s$ 和扩张率 $d$）在驱动感受野的增长 [@problem_id:3175390]。", "problem": "一个一维卷积神经网络由 $L$ 个相同的层堆叠而成，每个层都是一个离散、线性、移位不变的卷积，其核大小为 $k$，步长为 $s$，扩张率为 $d$，且没有填充和池化。考虑扩张、带步长的离散卷积的标准定义：第 $\\ell$ 层输出位置 $n$ 的预激活值是 $k$ 个权重应用于以扩张率 $d$ 间隔的输入的有限和，并且连续的输出在上一层的输入索引中以步长 $s$ 间隔。顶层单个输出位置的局部感受野是指能够影响它的原始输入层中不同输入位置的数量。稀疏连接意味着这个数量是有限的，并且不随输入长度的变化而变化。\n\n仅从这些基本定义出发，不使用任何预先记忆的公式，推导出一个关于深度 $L$ 处感受野大小 $R_L$ 的通用闭式表达式，该表达式是 $k$、$s$、$d$ 和 $L$ 的函数，并假设所有层共享相同的 $(k,s,d)$ 且不使用任何填充。然后，通过计算一个具有 $k=3$，$s=2$，$d=2$ 和 $L=4$ 的合成网络的感受野大小来验证你的表达式。\n\n请以指定合成网络感受野大小的单个整数形式提供最终答案。不需要单位，也不需要四舍五入。", "solution": "该问题要求推导一维卷积神经网络感受野大小的通用闭式表达式，然后针对一个特定情况进行计算。推导必须从基本定义出发。\n\n设网络的层从 $\\ell=1$ 到 $\\ell=L$ 进行索引。输入数据被指定为第 $\\ell=0$ 层。我们将第 $\\ell$ 层中单个神经元的感受野大小（表示为 $R_\\ell$）定义为第 $0$ 层中能够影响其预激活值的不同输入位置的数量。$L$ 个层中的每一层都是相同的，其特征是核大小为 $k$，步长为 $s$，扩张率为 $d$。\n\n为了推导 $R_L$ 的通用表达式，我们首先建立一个递归关系。考虑第 $\\ell$ 层中的一个神经元。它的值是由第 $\\ell-1$ 层中的 $k$ 个输入计算得出的。由于扩张率为 $d$，这些输入在第 $\\ell-1$ 层的特征图中并不位于相邻位置。如果第一个输入位于位置 $j$，则后续输入位于位置 $j+d, j+2d, \\dots, j+(k-1)d$。第 $\\ell$ 层神经元的总感受野是这 $k$ 个来自第 $\\ell-1$ 层的输入神经元感受野的并集。\n\n为了确定这个并集的大小，我们必须理解来自第 $\\ell-1$ 层的感受野在原始输入空间（第 $0$ 层）中是如何相互定位的。令 $J_{\\ell-1}$ 表示到第 $\\ell-1$ 层的累积步长。$J_{\\ell-1}$ 是在第 $0$ 层输入空间中，第 $\\ell-1$ 层两个相邻神经元感受野起始点之间的距离。累积步长可以递归定义。由于所有层都具有相同的步长 $s$，第 $\\ell$ 层的累积步长为：\n$$J_\\ell = s \\cdot J_{\\ell-1}$$\n基准情况为 $J_0 = 1$（因为第 $0$ 层中的相邻输入神经元相距一个位置），此递归的解是一个等比数列：\n$$J_\\ell = s^\\ell$$\n\n现在，我们来分析第 $\\ell$ 层神经元的 $k$ 个输入的跨度。这些输入在第 $\\ell-1$ 层特征图中位于相对位置 $0, d, 2d, \\dots, (k-1)d$。第一个输入（相对位置 $0$）和最后一个输入（相对位置 $(k-1)d$）在第 $\\ell-1$ 层坐标系中间隔了 $(k-1)d$ 的距离。在原始输入空间中对应的位移是这个间隔与到第 $\\ell-1$ 层的累积步长的乘积：\n$$\\text{Shift in input space} = ((j+(k-1)d) - j) \\times J_{\\ell-1} = (k-1)d \\cdot J_{\\ell-1}$$\n第 $\\ell$ 层的总感受野大小 $R_\\ell$ 等于其一个组成神经元（来自第 $\\ell-1$ 层）的感受野大小（即 $R_{\\ell-1}$）加上其他输入神经元感受野移动所覆盖的额外跨度。这个额外的跨度等于上面计算出的位移。这给出了感受野大小的以下递归关系：\n$$R_\\ell = R_{\\ell-1} + (k-1)d \\cdot J_{\\ell-1}$$\n代入累积步长的表达式 $J_{\\ell-1} = s^{\\ell-1}$，我们得到：\n$$R_\\ell = R_{\\ell-1} + (k-1)d \\cdot s^{\\ell-1}$$\n此递归的基准情况是输入层（$0$）中神经元的感受野，它就是神经元本身。因此，$R_0 = 1$。我们可以通过伸缩求和来解出 $R_L$ 的递归：\n$$R_L = R_0 + \\sum_{\\ell=1}^{L} (R_\\ell - R_{\\ell-1})$$\n代入递归关系和基准情况 $R_0=1$：\n$$R_L = 1 + \\sum_{\\ell=1}^{L} (k-1)d \\cdot s^{\\ell-1}$$\n我们可以将求和索引更改为 $i = \\ell-1$，其范围从 $0$ 到 $L-1$：\n$$R_L = 1 + \\sum_{i=0}^{L-1} (k-1)d \\cdot s^i$$\n项 $(k-1)d$ 相对于求和索引是常数，因此可以提取出来：\n$$R_L = 1 + (k-1)d \\sum_{i=0}^{L-1} s^i$$\n这个和是一个有限等比数列，它有一个众所周知的闭式形式，具体取决于 $s$ 的值。\n\n情况1：$s \\neq 1$。\n等比数列的和为 $\\sum_{i=0}^{L-1} s^i = \\frac{s^L - 1}{s-1}$。\n因此，感受野大小为：\n$$R_L = 1 + (k-1)d \\left(\\frac{s^L - 1}{s-1}\\right)$$\n\n情况2：$s = 1$。\n和变为 $\\sum_{i=0}^{L-1} 1^i = L$。\n因此，感受野大小为：\n$$R_L = 1 + (k-1)d \\cdot L$$\n这就完成了通用闭式表达式的推导。\n\n问题的第二部分是计算具有以下参数的合成网络的感受野大小：\n- 层数：$L=4$\n- 核大小：$k=3$\n- 步长：$s=2$\n- 扩张率：$d=2$\n\n由于 $s=2 \\neq 1$，我们使用情况1的公式：\n$$R_L = 1 + (k-1)d \\left(\\frac{s^L - 1}{s-1}\\right)$$\n代入给定的数值：\n$$R_4 = 1 + (3-1) \\cdot 2 \\cdot \\left(\\frac{2^4 - 1}{2-1}\\right)$$\n$$R_4 = 1 + 2 \\cdot 2 \\cdot \\left(\\frac{16 - 1}{1}\\right)$$\n$$R_4 = 1 + 4 \\cdot (15)$$\n$$R_4 = 1 + 60$$\n$$R_4 = 61$$\n指定合成网络的感受野大小为 $61$。", "answer": "$$\\boxed{61}$$", "id": "3175390"}, {"introduction": "理论上计算出的感受野大小有什么实际意义呢？这个练习将抽象概念与一个具体的信号处理任务——边缘检测——联系起来。你将探索感受野大小 $R$ 如何直接影响模型在含噪声数据中稳健识别特征的能力。通过确定完成任务所需的最小感受野，你将体会到感受野并非越大越好，而是需要与任务本身的尺度相匹配 [@problem_id:3175463]。", "problem": "考虑一个来自二值图像的水平扫描线的一维抽象，该图像包含一个单一的垂直边缘。干净信号由边缘左侧的恒定强度 $I_{\\ell}$ 和边缘右侧的恒定强度 $I_{r}$ 组成，形成一个对比度为 $\\Delta = |I_{\\ell} - I_{r}|$ 的理想阶跃。观测到的信号在每个像素处被独立的加性高斯噪声所破坏，该噪声均值为零，方差为 $\\sigma^{2}$。\n\n一个大小为 $R$（其中 $R$ 为偶数）的局部感受野定义了一个稀疏连接模式，该模式仅使用以给定扫描位置为中心的 $R$ 个连续样本。考虑一个作用于此感受野的线性检测器：感受野左半部分的权重均为 $+\\frac{1}{R/2}$，右半部分的权重均为 $-\\frac{1}{R/2}$。在给定位置的检测器输出是感受野中 $R$ 个观测样本的加权和。假设扫描过程的步长为 $1$，因此存在一个位置，使得感受野正好位于真实边缘的中心。对检测器输出的绝对值定义一个固定的决策阈值 $\\tau \\ge 0$，并定义一个所需可靠性 $q \\in (0,1)$，理解为十进制小数。\n\n鲁棒检测定义为：当感受野位于真实边缘中心时，检测器输出的绝对值超过 $\\tau$ 的概率至少为 $q$。假设边缘距离信号边界足够远，使得对齐后的感受野完全包含在长度为 $N$ 的信号内；特别地，感受野大小受限于 $2 \\le R \\le N$。\n\n从线性滤波、局部感受野以及独立高斯噪声在线性变换下的性质等基本定义出发，推导一种方法，用于在给定 $(N, I_{\\ell}, I_{r}, \\sigma, \\tau, q)$ 的情况下，确定保证上述意义上鲁棒检测的最小偶数 $R$。如果在约束 $R \\le N$ 下不存在这样的 $R$，则返回整数 $-1$ 以报告不可能性。\n\n您的程序必须实现此推导，为以下测试套件中的每个参数集计算最小的 $R$。每个参数集被指定为一个有序元组 $(N, I_{\\ell}, I_{r}, \\sigma, \\tau, q)$：\n\n- 测试用例 1：$(N = 128, I_{\\ell} = 0.0, I_{r} = 1.0, \\sigma = 0.2, \\tau = 0.5, q = 0.95)$。\n- 测试用例 2：$(N = 128, I_{\\ell} = 0.0, I_{r} = 0.6, \\sigma = 0.3, \\tau = 0.25, q = 0.90)$。\n- 测试用例 3：$(N = 256, I_{\\ell} = 0.0, I_{r} = 0.4, \\sigma = 0.1, \\tau = 0.5, q = 0.90)$。\n- 测试用例 4：$(N = 64, I_{\\ell} = 0.0, I_{r} = 1.0, \\sigma = 0.0, \\tau = 0.7, q = 0.99)$。\n- 测试用例 5：$(N = 4, I_{\\ell} = 0.0, I_{r} = 0.6, \\sigma = 0.3, \\tau = 0.25, q = 0.90)$。\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔的整数列表，其顺序与测试用例相同（例如，$[R_{1},R_{2},R_{3},R_{4},R_{5}]$）。不允许有其他输出。此问题中不出现角度，输出中也不需要物理单位。所有概率必须作为十进制小数处理和表示，而不是百分比。", "solution": "在尝试解决方案之前，对问题陈述的有效性进行严格评估。\n\n### 步骤 1：提取给定条件\n- **信号模型**：考虑来自二值图像的一维扫描线。\n- **干净信号**：一个理想的阶跃函数，边缘左侧强度为 $I_{\\ell}$，右侧为 $I_{r}$。\n- **对比度**：$\\Delta = |I_{\\ell} - I_{r}|$。\n- **噪声模型**：每个像素处存在均值为 $0$、方差为 $\\sigma^2$ 的独立加性高斯噪声。\n- **检测器**：大小为 $R$ 的局部感受野，$R$ 为偶数。该检测器是一个带权重的线性滤波器。\n- **检测器权重**：感受野左半部分 $R/2$ 个样本的权重为 $+\\frac{1}{R/2}$，右半部分 $R/2$ 个样本的权重为 $-\\frac{1}{R/2}$。\n- **检测器输出**：感受野中 $R$ 个观测样本的加权和。\n- **扫描与对齐**：使用步长为 $1$。考虑感受野完美对齐于真实边缘中心的一个特定位置。\n- **决策规则**：对检测器输出的绝对值应用一个固定的决策阈值 $\\tau \\ge 0$。\n- **可靠性要求**：检测器输出的绝对值超过 $\\tau$ 的概率必须达到 $q \\in (0,1)$。\n- **鲁棒检测**：当感受野位于边缘中心时，必须满足条件 $P(\\text{检测器输出绝对值}  \\tau) \\ge q$。\n- **约束条件**：$2 \\le R \\le N$，其中 $N$ 为信号长度。假设感受野完全包含在信号内。\n- **目标**：对于给定的参数集 $(N, I_{\\ell}, I_{r}, \\sigma, \\tau, q)$，找到满足鲁棒检测标准的最小偶数 $R$。\n- **不可能性**：如果在约束 $R \\le N$ 下不存在这样的 $R$，则结果应为 $-1$。\n\n### 步骤 2：使用提取的给定条件进行验证\n- **科学基础**：该问题在信号处理、统计学和机器学习的基本原理方面有很好的基础。它模拟了一个在加性高斯白噪声（AWGN）下的经典边缘检测场景，使用了一个线性滤波器（一个简化的类Haar特征检测器）和统计决策理论。这些概念是标准的且科学合理的。\n- **适定性**：该问题是适定的。它要求在明确定义的不等式和边界约束（$R$ 是一个偶数，$2 \\le R \\le N$）下，最小化一个整型变量 $R$。可以确定唯一最小解的存在性（或证明其不存在）。\n- **目标**：问题以精确、客观和数学化的语言陈述。主观术语被赋予了正式的定义（例如，“鲁棒检测”）。\n\n该问题没有表现出任何缺陷，例如科学上的不健全、模糊性、矛盾或依赖非标准的非科学主张。所有参数都已提供，目标也已明确指定。\n\n### 步骤 3：结论与行动\n该问题是 **有效的**。将推导一个有原则的解决方案。\n\n### 解决方案的推导\n\n令大小为 $R$ 的感受野以边缘为中心。观测样本为 $s_i = \\mu_i + \\eta_i$，其中 $i=1, \\dots, R$，$\\mu_i$ 是干净信号的强度，而 $\\eta_i$ 是来自高斯分布 $\\mathcal{N}(0, \\sigma^2)$ 的独立同分布（i.i.d.）随机变量。\n\n当感受野居中时，干净信号的值在左半部分（$i=1, \\dots, R/2$）为 $\\mu_i = I_{\\ell}$，在右半部分（$i=R/2+1, \\dots, R$）为 $\\mu_i = I_{r}$。\n\n检测器是一个带有权重 $w_i$ 的线性滤波器：\n$$\nw_i = \\begin{cases}\n+ \\frac{1}{R/2}  \\text{for } i = 1, \\dots, R/2 \\\\\n- \\frac{1}{R/2}  \\text{for } i = R/2+1, \\dots, R\n\\end{cases}\n$$\n检测器输出 $D$ 是一个由加权和给出的随机变量：\n$$\nD = \\sum_{i=1}^{R} w_i s_i = \\frac{1}{R/2} \\sum_{i=1}^{R/2} s_i - \\frac{1}{R/2} \\sum_{i=R/2+1}^{R} s_i\n$$\n\n我们确定 $D$ 的统计特性。由于 $D$ 是独立高斯随机变量的线性组合，$D$ 本身也服从高斯分布。我们需要找到它的均值 $\\mu_D$ 和方差 $\\sigma_D^2$。\n\n检测器输出的均值（期望值）是：\n$$\n\\mu_D = E[D] = E\\left[\\sum_{i=1}^{R} w_i (\\mu_i + \\eta_i)\\right] = \\sum_{i=1}^{R} w_i \\mu_i + \\sum_{i=1}^{R} w_i E[\\eta_i]\n$$\n由于 $E[\\eta_i] = 0$，第二项消失。\n$$\n\\mu_D = \\sum_{i=1}^{R/2} \\left(+\\frac{1}{R/2}\\right) I_{\\ell} + \\sum_{i=R/2+1}^{R} \\left(-\\frac{1}{R/2}\\right) I_{r}\n$$\n$$\n\\mu_D = \\frac{R/2}{R/2} I_{\\ell} - \\frac{R/2}{R/2} I_{r} = I_{\\ell} - I_{r}\n$$\n\n检测器输出的方差是：\n$$\n\\sigma_D^2 = \\text{Var}(D) = \\text{Var}\\left(\\sum_{i=1}^{R} w_i (\\mu_i + \\eta_i)\\right) = \\text{Var}\\left(\\sum_{i=1}^{R} w_i \\eta_i\\right)\n$$\n由于噪声样本 $\\eta_i$ 是独立的，和的方差是方差的和：\n$$\n\\sigma_D^2 = \\sum_{i=1}^{R} w_i^2 \\text{Var}(\\eta_i) = \\sum_{i=1}^{R} w_i^2 \\sigma^2\n$$\n$$\n\\sigma_D^2 = \\sigma^2 \\left( \\sum_{i=1}^{R/2} \\left(\\frac{1}{R/2}\\right)^2 + \\sum_{i=R/2+1}^{R} \\left(-\\frac{1}{R/2}\\right)^2 \\right)\n$$\n$$\n\\sigma_D^2 = \\sigma^2 \\left( (R/2) \\frac{1}{(R/2)^2} + (R/2) \\frac{1}{(R/2)^2} \\right) = \\sigma^2 \\left( \\frac{1}{R/2} + \\frac{1}{R/2} \\right) = \\frac{2\\sigma^2}{R/2} = \\frac{4\\sigma^2}{R}\n$$\n输出的标准差是 $\\sigma_D = \\sqrt{4\\sigma^2/R} = \\frac{2\\sigma}{\\sqrt{R}}$。\n\n所以，检测器输出是一个高斯随机变量 $D \\sim \\mathcal{N}\\left(I_{\\ell} - I_{r}, \\frac{4\\sigma^2}{R}\\right)$。\n\n鲁棒检测条件是 $P(|D|  \\tau) \\ge q$。这可以写成 $P(D  \\tau) + P(D  -\\tau) \\ge q$。\n令 $Z = \\frac{D-\\mu_D}{\\sigma_D}$ 为一个标准正态变量，$Z \\sim \\mathcal{N}(0,1)$。\n该条件变为：\n$$\nP\\left(Z  \\frac{\\tau - \\mu_D}{\\sigma_D}\\right) + P\\left(Z  \\frac{-\\tau - \\mu_D}{\\sigma_D}\\right) \\ge q\n$$\n令 $\\Phi(x)$ 为标准正态分布的累积分布函数（CDF）。该不等式为：\n$$\n\\left(1 - \\Phi\\left(\\frac{\\tau - \\mu_D}{\\sigma_D}\\right)\\right) + \\Phi\\left(\\frac{-\\tau - \\mu_D}{\\sigma_D}\\right) \\ge q\n$$\n令 $\\Delta = |I_{\\ell} - I_{r}|$。则 $\\mu_D = \\pm \\Delta$。概率表达式关于 $\\mu_D$ 的符号是对称的。使用性质 $\\Phi(-x) = 1-\\Phi(x)$，如果我们假设 $\\mu_D=\\Delta$，表达式简化为 $\\Phi\\left(-\\frac{\\tau-\\Delta}{\\sigma_D}\\right) + \\Phi\\left(\\frac{-\\tau-\\Delta}{\\sigma_D}\\right)$，对于 $\\mu_D=-\\Delta$ 也同样成立。我们可以将其写为 $\\Phi\\left(\\frac{\\Delta-\\tau}{\\sigma_D}\\right) + \\Phi\\left(\\frac{-\\Delta-\\tau}{\\sigma_D}\\right)$。\n代入 $\\sigma_D = \\frac{2\\sigma}{\\sqrt{R}}$：\n$$\nP(R) = \\Phi\\left(\\frac{(\\Delta - \\tau)\\sqrt{R}}{2\\sigma}\\right) + \\Phi\\left(\\frac{(-\\Delta - \\tau)\\sqrt{R}}{2\\sigma}\\right) \\ge q\n$$\n我们需要找到满足此不等式的最小偶数 $R \\in [2, N]$。\n\n我们分析概率函数 $P(R)$ 相对于 $R$ 的行为。\n1.  **情形 $\\sigma = 0$**：检测器输出是确定性的：$D = \\mu_D$。那么 $|D| = \\Delta$。如果 $\\Delta  \\tau$，概率 $P(|D|  \\tau)$ 为 $1$；如果 $\\Delta \\le \\tau$，概率为 $0$。如果 $\\Delta  \\tau$，任何 $R$ 都有效，因此最小偶数 $R$ 是 $2$。如果 $\\Delta \\le \\tau$，没有 $R$ 有效，所以答案是 $-1$。\n2.  **情形 $\\sigma  0$ 且 $\\Delta  \\tau$**：随着 $R$ 增加，$\\sigma_D$ 减小。$D$ 的分布在其均值 $\\mu_D$ 周围变得更加集中。由于 $|\\mu_D|=\\Delta  \\tau$，均值位于区间 $[-\\tau, \\tau]$ 之外。因此，将概率质量集中在 $\\mu_D$ 周围会增加其在 $[-\\tau, \\tau]$ 之外的概率。所以，$P(R)$ 是 $R$ 的单调递增函数。我们可以从 $R=2$ 开始，以 $2$ 为增量递增，直到满足条件或 $R  N$，从而找到最小的 $R$。\n3.  **情形 $\\sigma  0$ 且 $\\Delta \\le \\tau$**：随着 $R$ 增加，$\\sigma_D$ 减小。由于 $|\\mu_D|=\\Delta \\le \\tau$，均值位于区间 $[-\\tau, \\tau]$ 之内或其边界上。将概率质量集中在 $\\mu_D$ 周围会增加其在 $[-\\tau, \\tau]$ 之内的概率，从而减小 $P(|D|  \\tau)$。因此，$P(R)$ 是 $R$ 的非增函数。如果对于最小可能的 $R$（即 $R=2$）不满足条件 $P(R) \\ge q$，那么对于任何更大的 $R$ 也不会满足。因此，我们只需要检查 $R=2$。如果通过，答案是 $2$；否则是 $-1$。\n\n算法如下：\n对于每个参数集 $(N, I_{\\ell}, I_{r}, \\sigma, \\tau, q)$：\n1.  计算 $\\Delta = |I_{\\ell} - I_{r}|$。\n2.  如果 $\\sigma = 0$：若 $\\Delta  \\tau$，则返回 $2$，否则返回 $-1$。\n3.  如果 $\\sigma  0$ 且 $\\Delta  \\tau$：从 $2$ 到 $N$ 遍历偶数 $R$。对于每个 $R$，计算 $P(R)$。第一个满足 $P(R) \\ge q$ 的 $R$ 就是答案。如果循环完成仍未找到这样的 $R$，则返回 $-1$。\n4.  如果 $\\sigma  0$ 且 $\\Delta \\le \\tau$：计算 $P(2)$。如果 $P(2) \\ge q$，则返回 $2$。否则返回 $-1$。\n\n标准正态CDF $\\Phi(x)$ 可以使用误差函数 $\\text{erf}(x)$ 计算，即 $\\Phi(x) = \\frac{1}{2}\\left(1 + \\text{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom scipy.special import erf\n\ndef solve():\n    \"\"\"\n    Solves for the minimal receptive field size R for robust edge detection.\n    \"\"\"\n\n    # Test cases as specified in the problem statement.\n    # Each case is an ordered tuple (N, I_l, I_r, sigma, tau, q).\n    test_cases = [\n        (128, 0.0, 1.0, 0.2, 0.5, 0.95),  # Test case 1\n        (128, 0.0, 0.6, 0.3, 0.25, 0.90), # Test case 2\n        (256, 0.0, 0.4, 0.1, 0.5, 0.90), # Test case 3\n        (64, 0.0, 1.0, 0.0, 0.7, 0.99), # Test case 4\n        (4, 0.0, 0.6, 0.3, 0.25, 0.90),   # Test case 5\n    ]\n\n    results = []\n\n    def norm_cdf(x):\n        \"\"\"\n        Computes the standard normal cumulative distribution function (CDF).\n        \"\"\"\n        return 0.5 * (1.0 + erf(x / np.sqrt(2.0)))\n\n    def calculate_prob(R, delta, sigma, tau):\n        \"\"\"\n        Calculates the probability P(|D| > tau) for a given R.\n        \"\"\"\n        if sigma == 0:\n            return 1.0 if delta > tau else 0.0\n        \n        # Using the simplified expression P = Phi(-arg1) + Phi(arg2)\n        # where arg1 = (tau-delta)*sqrt(R)/(2*sigma) and arg2 = (-tau-delta)*sqrt(R)/(2*sigma)\n        # this is equivalent to P = Phi((delta-tau)*sqrt(R)/(2*sigma)) + Phi((-delta-tau)*sqrt(R)/(2*sigma))\n        \n        sqrt_R = np.sqrt(R)\n        denominator = 2.0 * sigma\n\n        arg1 = (delta - tau) * sqrt_R / denominator\n        arg2 = (-delta - tau) * sqrt_R / denominator\n        \n        return norm_cdf(arg1) + norm_cdf(arg2)\n\n    for case in test_cases:\n        N, I_l, I_r, sigma, tau, q = case\n        \n        delta = abs(I_l - I_r)\n        \n        found_R = -1\n\n        # Handle the special case of zero noise\n        if sigma == 0.0:\n            if delta > tau:\n                found_R = 2\n            else:\n                found_R = -1\n        # Case where probability increases with R\n        elif delta > tau:\n            # Iterate through even integers for R from 2 to N\n            for R in range(2, N + 1, 2):\n                prob = calculate_prob(R, delta, sigma, tau)\n                if prob >= q:\n                    found_R = R\n                    break\n        # Case where probability is non-increasing with R\n        else: # delta = tau\n            # Only need to check the smallest R\n            R = 2\n            prob = calculate_prob(R, delta, sigma, tau)\n            if prob >= q:\n                found_R = R\n            else:\n                found_R = -1\n\n        results.append(found_R)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3175463"}, {"introduction": "在将卷积应用于有限长度的信号或图像时，一个不可避免的实际问题是如何处理边界。由于局部感受野在数据边缘会“悬空”，我们需要对边界之外的区域做出假设，这正是“填充”（padding）策略的作用。本练习通过量化不同填充策略（如零填充、反射填充和循环填充）所引入的边界伪影，揭示了每种策略背后隐藏的信号模型假设及其对最终结果的影响 [@problem_id:3175412]。", "problem": "考虑一个长度为 $n$ 的一维离散输入信号，表示为 $x[0], x[1], \\ldots, x[n-1]$。卷积神经网络 (CNN) 中的单层卷积单元通过将每个输出单元 $y[i]$ 仅连接到以 $i$ 为中心的输入的局部邻域，来建立稀疏连接（Sparse Connectivity）和局部感受野（Local Receptive Fields）。设卷积核长度为奇数 $m$，权重为 $w[0], w[1], \\ldots, w[m-1]$，并定义感受野半径 $r = \\lfloor m/2 \\rfloor$。位置 $i$ 处的局部计算（使用深度学习中常见的互相关约定）为\n$$\ny[i] = \\sum_{k=0}^{m-1} w[k] \\, \\tilde{x}[i + k - r],\n$$\n其中 $\\tilde{x}[\\cdot]$ 表示将 $x[\\cdot]$ 扩展到边界之外，以支持那些使得核窗口索引超出 $[0, n-1]$ 范围的位置 $i$。\n\n我们研究由不同填充策略引起的边界效应，这些策略对任意整数索引 $j$ 定义如下：\n\n- 零填充：\n$$\n\\tilde{x}[j] = \n\\begin{cases}\nx[j],  \\text{if } 0 \\le j \\le n-1, \\\\\n0,  \\text{otherwise}.\n\\end{cases}\n$$\n\n- 反射填充（关于边界对称反射，复制边界值）：\n$$\n\\tilde{x}[j] = \n\\begin{cases}\nx[j],  \\text{if } 0 \\le j \\le n-1, \\\\\nx[-j-1],  \\text{if } j  0, \\\\\nx[2n - 1 - j],  \\text{if } j \\ge n.\n\\end{cases}\n$$\n\n- 循环填充（周期性扩展）：\n$$\n\\tilde{x}[j] = x[j \\bmod n].\n$$\n\n对于每个测试用例，我们将为生成观测到的有限片段的底层无限信号指定一个真实扩展规则。“真实输出” $y_{\\text{true}}[i]$ 的定义是：对所有 $i \\in \\{0, 1, \\ldots, n-1\\}$，使用真实扩展规则应用上述局部感受野计算得到的结果。\n\n定义边界索引集\n$$\nB = \\{ i \\in \\{0, 1, \\ldots, n-1\\} \\mid i  r \\text{ or } i \\ge n - r \\}.\n$$\n也就是说，$B$ 包含其感受野与边界重叠的输出位置。对于一种填充策略 $P \\in \\{\\text{zero}, \\text{reflection}, \\text{circular}\\}$，将伪影分数定义为边界上的均方误差，\n$$\nA(P) = \\frac{1}{|B|} \\sum_{i \\in B} \\left( y_{P}[i] - y_{\\text{true}}[i] \\right)^2,\n$$\n其中 $y_{P}[i]$ 是使用填充策略 $P$ 计算的输出。该分数是无量纲的。\n\n对所有测试用例使用以下固定卷积核：\n$$\nm = 5, \\quad r = 2, \\quad w = \\frac{1}{16}[1, 4, 6, 4, 1].\n$$\n\n三角函数中使用的角度必须以弧度为单位。\n\n测试套件（每个测试用例由 $(n, x, \\text{ground truth})$ 完全指定）：\n- 用例 1（紧凑脉冲，真实扩展规则为零扩展）：\n  - $n = 16$,\n  - $x[i] = 1$ 若 $i \\in \\{6, 7, 8, 9\\}$，否则 $x[i] = 0$，\n  - 真实扩展规则：零填充。\n- 用例 2（线性斜坡，真实扩展规则为对称反射）：\n  - $n = 15$,\n  - $x[i] = i$ 对于 $i \\in \\{0, 1, \\ldots, 14\\}$,\n  - 真实扩展规则：反射填充。\n- 用例 3（离散余弦，真实扩展规则为循环/周期性；余弦函数的参数以弧度为单位）：\n  - $n = 32$,\n  - $x[i] = \\cos\\!\\left(\\frac{2\\pi i}{n}\\right)$ 对于 $i \\in \\{0, 1, \\ldots, 31\\}$,\n  - 真实扩展规则：循环填充。\n- 用例 4（小型边缘情况，真实扩展规则为零扩展）：\n  - $n = 3$,\n  - $x = [0, 2, 0]$,\n  - 真实扩展规则：零填充。\n\n您的程序必须为每个测试用例和每种填充策略 $P \\in \\{\\text{zero}, \\text{reflection}, \\text{circular}\\}$ 计算如上定义的伪影分数 $A(P)$。最终输出必须是单行，包含一个列表的列表，其中每个内部列表按给定顺序对应一个测试用例，并按 $[A(\\text{zero}), A(\\text{reflection}), A(\\text{circular})]$ 的顺序包含三个浮点数。\n\n最终输出格式：\n- 形式为\n$$\n[[a_{1,\\text{zero}}, a_{1,\\text{reflection}}, a_{1,\\text{circular}}], [a_{2,\\text{zero}}, a_{2,\\text{reflection}}, a_{2,\\text{circular}}], [a_{3,\\text{zero}}, a_{3,\\text{reflection}}, a_{3,\\text{circular}}], [a_{4,\\text{zero}}, a_{4,\\text{reflection}}, a_{4,\\text{circular}}]]\n$$\n的单行字符串，每个 $a_{\\cdot,\\cdot}$ 采用原始十进制表示法。", "solution": "该问题要求针对四个测试用例，为三种不同的填充策略 $P \\in \\{\\text{zero}, \\text{reflection}, \\text{circular}\\}$ 计算伪影分数 $A(P)$。每个测试用例提供了一个长度为 $n$ 的一维信号 $x$，并指定了一个真实扩展规则，该规则定义了 $x$ 被假定为其片段来源的底层无限信号。伪影分数用于量化给定填充策略在信号边界处引入的误差。\n\n方法步骤如下：\n\n1.  **遍历测试用例**：总体算法按顺序处理四个测试用例中的每一个。对于每个用例，提取输入信号 $x$、其长度 $n$ 以及真实填充规则。卷积核 $w = \\frac{1}{16}[1, 4, 6, 4, 1]$ 及其对应的感受野半径 $r = 2$ 在所有用例中保持不变。\n\n2.  **实现填充函数**：计算的核心依赖于根据给定的填充规则将有限信号 $x$ 扩展为一个有效的无限信号 $\\tilde{x}$。必须根据提供的数学定义实现三个函数，以检索任意整数索引 $j$ 处的值 $\\tilde{x}[j]$：\n    -   **零填充**：如果 $0 \\le j \\le n-1$，则返回 $x[j]$，否则返回 $0$。\n    -   **反射填充**：对于 $0 \\le j \\le n-1$ 返回 $x[j]$，对于 $j  0$ 返回 $x[-j-1]$，对于 $j \\ge n$ 返回 $x[2n-1-j]$。\n    -   **循环填充**：返回 $x[j \\bmod n]$。\n\n3.  **实现卷积**：设计一个函数来执行指定的一维互相关运算：\n    $$y[i] = \\sum_{k=0}^{m-1} w[k] \\, \\tilde{x}[i + k - r]$$\n    该函数接收信号 $x$ 和一个填充规则作为输入，并计算长度为 $n$ 的输出信号 $y$。\n\n4.  **计算真实输出和填充后输出**：对每个测试用例：\n    -   通过使用指定的真实填充规则应用卷积函数，计算出真实输出 $y_{\\text{true}}$。\n    -   通过使用各自的填充规则应用卷积函数，计算出待评估的三种填充策略的输出 $y_{\\text{zero}}$、$y_{\\text{reflection}}$ 和 $y_{\\text{circular}}$。\n\n5.  **计算伪影分数**：为每种填充策略 $P$ 计算伪影分数 $A(P)$。\n    -   首先，确定受边界影响的输出索引集合 $B = \\{ i \\in \\{0, 1, \\ldots, n-1\\} \\mid i  r \\text{ or } i \\ge n - r \\}$。确定其基数 $|B|$。对于 $n > 2r$ 的情况，有 $|B|=2r$；否则 $|B|=n$。\n    -   该分数是填充后输出 $y_P$ 与真实输出 $y_{\\text{true}}$ 之间的均方误差，仅在集合 $B$ 中的索引上计算：\n    $$A(P) = \\frac{1}{|B|} \\sum_{i \\in B} \\left( y_{P}[i] - y_{\\text{true}}[i] \\right)^2$$\n    如果所选的填充策略 $P$ 与真实规则匹配，则误差应为 $0$，因此 $A(P) = 0$。\n\n6.  **汇总并格式化结果**：收集每个测试用例计算出的分数 $[A(\\text{zero}), A(\\text{reflection}), A(\\text{circular})]$。最终输出是所有四个用例结果的汇总，并按要求格式化为单个列表的列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by calculating artifact scores for various padding strategies.\n    \"\"\"\n    \n    # Define fixed kernel parameters\n    m = 5\n    r = 2\n    w = np.array([1, 4, 6, 4, 1]) / 16.0\n    \n    # Define test cases from the problem statement\n    test_cases = [\n        # Case 1: Compact pulse, ground truth zero\n        {\n            \"n\": 16,\n            \"x\": np.array([1.0 if 6 = i = 9 else 0.0 for i in range(16)]),\n            \"ground_truth\": \"zero\"\n        },\n        # Case 2: Linear ramp, ground truth reflection\n        {\n            \"n\": 15,\n            \"x\": np.arange(15, dtype=float),\n            \"ground_truth\": \"reflection\"\n        },\n        # Case 3: Discrete cosine, ground truth circular\n        {\n            \"n\": 32,\n            \"x\": np.cos(2 * np.pi * np.arange(32) / 32),\n            \"ground_truth\": \"circular\"\n        },\n        # Case 4: Small edge case, ground truth zero\n        {\n            \"n\": 3,\n            \"x\": np.array([0.0, 2.0, 0.0]),\n            \"ground_truth\": \"zero\"\n        }\n    ]\n\n    all_results = []\n    padding_strategies = ['zero', 'reflection', 'circular']\n\n    # --- Helper functions for padding and convolution ---\n    \n    def get_padded_value(x_sig, j, n_sig, mode):\n        \"\"\"\n        Retrieves the value of a signal at index j, applying the specified padding rule.\n        \"\"\"\n        if 0 = j  n_sig:\n            return x_sig[j]\n        \n        if mode == 'zero':\n            return 0.0\n        \n        if mode == 'reflection':\n            if j  0:\n                # Per problem: x[-j-1] for j  0\n                idx = -j - 1\n            else:  # j >= n_sig\n                # Per problem: x[2n - 1 - j] for j >= n\n                idx = 2 * n_sig - 1 - j\n            \n            # Check if the reflected index is within bounds of the original signal\n            if 0 = idx  n_sig:\n                return x_sig[idx]\n            return 0.0  # Fallback for indices reflected out of bounds\n\n        if mode == 'circular':\n            # Per problem: x[j mod n]\n            return x_sig[j % n_sig]\n        \n        raise ValueError(\"Unknown padding mode\")\n\n    def convolve_1d(x_sig, n_sig, padding_mode):\n        \"\"\"\n        Computes the 1D cross-correlation using the fixed kernel w and specified padding.\n        \"\"\"\n        y = np.zeros(n_sig)\n        for i in range(n_sig):\n            val = 0.0\n            for k in range(m):\n                x_idx = i + k - r\n                val += w[k] * get_padded_value(x_sig, x_idx, n_sig, padding_mode)\n            y[i] = val\n        return y\n\n    # --- Main logic loop ---\n    \n    for case in test_cases:\n        n = case[\"n\"]\n        x = case[\"x\"]\n        gt_mode = case[\"ground_truth\"]\n        \n        # Compute the ground-truth output signal\n        y_true = convolve_1d(x, n, gt_mode)\n        \n        # Determine the boundary index set B\n        boundary_indices = [i for i in range(n) if i  r or i >= n - r]\n        num_boundary_points = len(boundary_indices)\n        \n        case_scores = []\n        for p_mode in padding_strategies:\n            # Compute the output signal for the current padding strategy\n            y_p = convolve_1d(x, n, p_mode)\n            \n            # Calculate the sum of squared errors over the boundary set B\n            sse = 0.0\n            for i in boundary_indices:\n                error = y_p[i] - y_true[i]\n                sse += error * error\n            \n            # Calculate the artifact score (mean squared error)\n            artifact_score = sse / num_boundary_points if num_boundary_points > 0 else 0.0\n            case_scores.append(artifact_score)\n            \n        all_results.append(case_scores)\n        \n    # --- Format final output ---\n    \n    final_output_segments = []\n    for scores in all_results:\n        segment = f\"[{','.join(map(str, scores))}]\"\n        final_output_segments.append(segment)\n        \n    print(f\"[{','.join(final_output_segments)}]\")\n\nsolve()\n```", "id": "3175412"}]}