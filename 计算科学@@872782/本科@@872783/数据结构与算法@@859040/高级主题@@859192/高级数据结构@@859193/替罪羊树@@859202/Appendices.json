{"hands_on_practices": [{"introduction": "替罪羊树自我平衡策略的核心，在于准确地找出导致失衡的“替罪羊”节点。本练习将引导你动手实现基于核心的 $\\alpha$-权重平衡条件的检测逻辑 [@problem_id:3216147]。通过在插入操作后沿路径向上检查，你将亲身体验替罪羊树是如何定位需要重建的子树的，这是构建完整替罪羊树功能的第一步。", "problem": "你的任务是实现一种逻辑，用于在一棵刚刚经历单次插入操作的二叉树中，根据替罪羊树的准则来检测不平衡的子树。检测必须沿着特定的插入路径执行。请从以下基本定义和事实开始：\n\n- 二叉树是一种数据结构，其中每个节点最多有两个子节点，通常分别称为左子节点和右子节点。\n- 对于任意节点，定义子树大小函数 $s(v)$ 为以节点 $v$ 为根的子树中的节点总数，包括 $v$ 自身。\n- 对于一个实数参数 $\\alpha$（满足 $ \\frac{1}{2}  \\alpha  1$），如果一个节点 $u$ 的左右子树的大小都不超过 $\\alpha \\cdot s(u)$，则称该节点是 $\\alpha$-权重平衡的。也就是说，如果 $L(u)$ 表示 $u$ 的左子树大小，$R(u)$ 表示 $u$ 的右子树大小，那么当 $L(u) \\le \\alpha \\cdot s(u)$ 且 $R(u) \\le \\alpha \\cdot s(u)$ 时，$u$ 是 $\\alpha$-权重平衡的。如果节点 $u$ 不是 $\\alpha$-权重平衡的，即 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$，则它是一个 $\\alpha$-替罪羊。\n\n你必须实现一个程序，在给定一棵二叉树、一个参数 $\\alpha$ 以及一条以新插入节点结尾的特定插入路径后，从新插入节点的父节点开始沿给定路径向上遍历，检测第一个 $\\alpha$-替罪羊祖先。如果该路径上没有祖先违反 $\\alpha$-权重平衡条件，则返回 $-1$。检测必须基于插入操作应用后的精确子树大小。\n\n程序中使用的表示细节如下：\n- 每棵树由一个三元组列表 $(\\text{id}, \\text{left}, \\text{right})$ 指定，其中 $\\text{id}$、$\\text{left}$ 和 $\\text{right}$ 均为整数，$-1$ 表示空子节点。\n- 插入路径以列表 $[p_0, p_1, \\dots, p_k]$ 的形式给出，其中 $p_0$ 是根标识符，$p_k$ 是新插入节点的标识符。插入操作根据一个明确的方向指示符将 $p_k$ 作为 $p_{k-1}$ 的左子节点或右子节点。\n- 应用插入操作后，计算从根可达的所有节点的 $s(v)$，并在路径 $[p_0, p_1, \\dots, p_{k-1}]$ 上检测满足违规条件 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$ 的最深祖先（即离 $p_k$ 最近的祖先）。\n\n你的程序必须完全按照规定嵌入并处理以下五个测试用例：\n\n- 测试用例 1：\n  - 节点：$(8, 4, 12)$, $(4, 2, -1)$, $(12, 10, 14)$, $(2, -1, -1)$, $(6, -1, -1)$, $(10, -1, -1)$, $(14, -1, -1)$。\n  - 根节点：$8$。\n  - 参数：$\\alpha = 0.7$。\n  - 插入路径：$[8, 12, 14, 15]$，在父节点 $14$ 处方向为 $R$，意为将节点 $15$ 作为 $14$ 的右子节点附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 2：\n  - 节点：$(10, 5, -1)$, $(5, 3, -1)$, $(3, -1, -1)$。\n  - 根节点：$10$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[10, 5, 3, 2]$，在父节点 $3$ 处方向为 $L$，意为将节点 $2$ 作为 $3$ 的左子节点附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 3：\n  - 节点：$(50, 40, -1)$, $(40, 30, -1)$, $(30, 20, -1)$, $(20, 10, -1)$, $(10, -1, -1)$。\n  - 根节点：$50$。\n  - 参数：$\\alpha = 0.8$。\n  - 插入路径：$[50, 40, 30, 20, 10, 5]$，在父节点 $10$ 处方向为 $L$，意为将节点 $5$ 作为 $10$ 的左子节点附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 4：\n  - 节点：$(1, -1, -1)$。\n  - 根节点：$1$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[1, 2]$，在父节点 $1$ 处方向为 $L$，意为将节点 $2$ 作为 $1$ 的左子节点附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n- 测试用例 5：\n  - 节点：$(9, 4, 13)$, $(4, -1, 6)$, $(6, 5, 7)$, $(5, -1, -1)$, $(7, -1, -1)$, $(13, -1, -1)$。\n  - 根节点：$9$。\n  - 参数：$\\alpha = 0.6$。\n  - 插入路径：$[9, 4, 6, 7, 8]$，在父节点 $7$ 处方向为 $R$，意为将节点 $8$ 作为 $7$ 的右子节点附加。\n  - 预期检测：在插入后计算 $s(v)$，并确定路径上的第一个 $\\alpha$-替罪羊祖先，如果没有则为 $-1$。\n\n你的程序应生成单行输出，其中包含五个测试用例的结果，格式为方括号内以逗号分隔的列表，顺序与测试用例相同（例如 $[r_1, r_2, r_3, r_4, r_5]$）。每个 $r_i$ 必须是检测到的替罪羊节点标识符的整数，如果该用例未检测到替罪羊，则为 $-1$。", "solution": "问题要求我们根据替罪羊树理论中关于 $\\alpha$-权重平衡的定义，在二叉树的插入路径上识别出第一个“替罪羊”祖先。当一个节点的某个子树的大小超过其自身总子树大小的特定比例 $\\alpha$ 时，该节点就成为替罪羊。\n\n对于每个测试用例，解决方案系统地遵循四个主要步骤：\n1.  **树的构建**：使用比所提供的三元组列表更方便的类图结构在内存中表示树。每个节点都是一个对象，包含其标识符、对其左子节点、右子节点和父节点的引用，以及一个用于存储其子树大小的属性。我们首先从输入列表中创建所有节点对象，并将它们存储在一个将整数标识符映射到对象的字典中。然后，我们再次遍历列表以建立这些对象之间的父子链接，从而形成以指定根节点为根的完整树结构。\n\n2.  **模拟插入**：问题指明刚刚发生了一次插入操作。我们通过为插入的元素创建一个新节点，并将其作为子节点附加到其指定的父节点上来模拟此过程。父节点是给定插入路径中的倒数第二个节点，附加的方向（左或右）已明确提供。新节点的 `parent` 指针也相应设置。\n\n3.  **子树大小计算**：插入后，新插入节点的所有祖先的子树大小都会改变。为确保正确性，我们必须重新计算树中每个节点的大小。节点 $v$ 的子树大小 $s(v)$ 定义为 $1$（节点自身）加上其左右子树的大小：$s(v) = 1 + s(\\text{v.left}) + s(\\text{v.right})$。这个递归定义自然地导向了使用后序遍历（一种深度优先搜索）进行计算。该算法在计算一个节点自身的大小之前，会递归地计算其子节点的大小。这个过程从树的根节点开始，从而保证在评估节点 $v$ 时，其子树中所有节点的大小都已经被计算和存储。\n\n4.  **替罪羊检测**：核心任务是找到插入节点的第一个违反 $\\alpha$-权重平衡条件的祖先。一个节点 $u$ 是 $\\alpha$-权重平衡的条件是 $L(u) \\le \\alpha \\cdot s(u)$ 且 $R(u) \\le \\alpha \\cdot s(u)$，其中 $L(u)$ 和 $R(u)$ 分别是左右子树的大小。如果 $L(u) > \\alpha \\cdot s(u)$ 或 $R(u) > \\alpha \\cdot s(u)$，则发生违规，使 $u$ 成为替罪羊。\n    为了找到“最深”的这样一个祖先（即离新叶节点最近的那个），我们从新添加节点的父节点开始，沿着插入路径向根节点方向向上遍历。插入路径为 $[p_0, p_1, \\dots, p_{k-1}, p_k]$，因此需要检查的祖先路径是 $[p_{k-1}, p_{k-2}, \\dots, p_0]$。对于此路径上的每个祖先 $u$，我们获取其子节点预先计算好的大小 $L(u)$ 和 $R(u)$，以及它自身的大小 $s(u)$。然后我们应用替罪羊测试。在此向上遍历过程中，第一个未通过测试的节点就是所要求的替罪羊。如果遍历完成仍未找到任何此类节点，则意味着路径上没有祖先是替罪羊，我们根据问题要求返回 $-1$。\n\n让我们将此逻辑应用于测试用例 2：\n- **给定**：根节点 $10$，$\\alpha = 0.6$，插入路径 $[10, 5, 3, 2]$，方向为 L。\n- **初始树**：一个线性链：$10 \\to 5 \\to 3$。\n- **插入**：将节点 $2$ 作为节点 $3$ 的左子节点附加。树变为 $10 \\to 5 \\to 3 \\to 2$。\n- **大小计算**：后序遍历得出：$s(2) = 1$，$s(3) = 1 + s(2) = 2$，$s(5) = 1 + s(3) = 3$，$s(10) = 1 + s(5) = 4$。\n- **替罪羊检测**：自底向上要检查的祖先路径是 $[3, 5, 10]$。\n  1.  **检查节点 $3$**：$s(3) = 2$。其左子节点是 $2$，大小为 $L(3) = s(2) = 1$。其右子节点为空，所以 $R(3) = 0$。平衡条件与 $\\alpha \\cdot s(3) = 0.6 \\cdot 2 = 1.2$ 进行比较。由于 $L(3) = 1 \\ngtr 1.2$ 且 $R(3) = 0 \\ngtr 1.2$，节点 $3$ 是平衡的。\n  2.  **检查节点 $5$**：$s(5) = 3$。其左子节点是 $3$，大小为 $L(5) = s(3) = 2$。其右子节点为空，所以 $R(5) = 0$。平衡条件与 $\\alpha \\cdot s(5) = 0.6 \\cdot 3 = 1.8$ 进行比较。这里，$L(5) = 2 > 1.8$。条件被违反。\n- **结果**：节点 $5$ 是遇到的第一个替罪羊。算法终止并返回 $5$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in the binary tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.parent = None\n        self.size = 0\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test cases.\n    \"\"\"\n    test_cases = [\n        {\n            \"nodes\": [(8, 4, 12), (4, 2, -1), (12, 10, 14), (2, -1, -1), (6, -1, -1), (10, -1, -1), (14, -1, -1)],\n            \"root\": 8,\n            \"alpha\": 0.7,\n            \"path\": [8, 12, 14, 15],\n            \"side\": 'R'\n        },\n        {\n            \"nodes\": [(10, 5, -1), (5, 3, -1), (3, -1, -1)],\n            \"root\": 10,\n            \"alpha\": 0.6,\n            \"path\": [10, 5, 3, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(50, 40, -1), (40, 30, -1), (30, 20, -1), (20, 10, -1), (10, -1, -1)],\n            \"root\": 50,\n            \"alpha\": 0.8,\n            \"path\": [50, 40, 30, 20, 10, 5],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(1, -1, -1)],\n            \"root\": 1,\n            \"alpha\": 0.6,\n            \"path\": [1, 2],\n            \"side\": 'L'\n        },\n        {\n            \"nodes\": [(9, 4, 13), (4, -1, 6), (6, 5, 7), (5, -1, -1), (7, -1, -1), (13, -1, -1)],\n            \"root\": 9,\n            \"alpha\": 0.6,\n            \"path\": [9, 4, 6, 7, 8],\n            \"side\": 'R'\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        results.append(process_case(case))\n    \n    print(f\"[{','.join(map(str, results))}]\")\n\ndef process_case(case_data):\n    \"\"\"\n    Processes a single test case: builds the tree, performs insertion,\n    calculates sizes, and finds the scapegoat.\n    \"\"\"\n    node_list = case_data[\"nodes\"]\n    root_id = case_data[\"root\"]\n    alpha = case_data[\"alpha\"]\n    insertion_path = case_data[\"path\"]\n    insertion_side = case_data[\"side\"]\n\n    nodes = {}\n\n    # First pass: create all node objects\n    all_node_ids = set()\n    for key, left, right in node_list:\n        all_node_ids.add(key)\n        if left != -1: all_node_ids.add(left)\n        if right != -1: all_node_ids.add(right)\n    \n    for key in all_node_ids:\n        if key in nodes: continue\n        nodes[key] = Node(key)\n\n    # Second pass: link nodes\n    for key, left_key, right_key in node_list:\n        node = nodes[key]\n        if left_key != -1:\n            node.left = nodes[left_key]\n            nodes[left_key].parent = node\n        if right_key != -1:\n            node.right = nodes[right_key]\n            nodes[right_key].parent = node\n\n    # Perform insertion\n    parent_key = insertion_path[-2]\n    new_node_key = insertion_path[-1]\n\n    parent_node = nodes[parent_key]\n    new_node = Node(new_node_key)\n    nodes[new_node_key] = new_node\n    new_node.parent = parent_node\n\n    if insertion_side == 'L':\n        parent_node.left = new_node\n    else: # 'R'\n        parent_node.right = new_node\n    \n    # Calculate subtree sizes using post-order traversal (DFS)\n    root_node = nodes[root_id]\n    compute_sizes(root_node)\n\n    # Traverse up the insertion path to find the scapegoat\n    ancestor_path = insertion_path[:-1]\n    scapegoat_id = -1\n\n    for node_key in reversed(ancestor_path):\n        current_node = nodes[node_key]\n        \n        left_size = current_node.left.size if current_node.left else 0\n        right_size = current_node.right.size if current_node.right else 0\n        total_size = current_node.size\n        \n        # Check for alpha-weight-balance violation\n        if left_size > alpha * total_size or right_size > alpha * total_size:\n            scapegoat_id = current_node.key\n            break\n            \n    return scapegoat_id\n\n\ndef compute_sizes(node):\n    \"\"\"\n    Recursively computes the size of the subtree rooted at `node`.\n    Uses post-order traversal logic.\n    \"\"\"\n    if node is None:\n        return 0\n    \n    left_size = compute_sizes(node.left)\n    right_size = compute_sizes(node.right)\n    \n    node.size = 1 + left_size + right_size\n    return node.size\n\nsolve()\n```", "id": "3216147"}, {"introduction": "了解如何定位替罪羊节点后，下一个关键问题是：何时启动寻找替罪羊的机制？本练习探讨了一种常见的插入触发条件：新插入节点的深度超出了基于树大小的对数限制。通过分析一个最坏情况下的插入序列，你将推导出触发首次重建所需的最少操作次数 [@problem_id:3268397]，从而揭示平衡参数 $\\alpha$ 与树的失衡容忍度之间的深刻联系。", "problem": "考虑一棵替罪羊树（Scapegoat Tree），它是一种基于比较的二叉搜索树（BST），通过部分重建来维持平衡，并由一个满足 $ \\frac{1}{2}  \\alpha  1$ 的实数 $\\alpha$ 参数化。其插入规则如下：维护一个等于曾经存在的最大节点数的全局计数器 $q$；在向以当前树为根的BST中每次插入节点时，如果新插入节点的深度 $d$ 超过 $\\left\\lfloor \\log_{1/\\alpha}(q) \\right\\rfloor$，则会触发对某个祖先子树的重建。假设没有删除操作，因此在 $k$ 次插入后，我们有 $q = k$。你将考虑一个由 $k$ 个不同键组成的严格递增的插入序列，使得在任何重建发生之前，BST路径退化为一条长度为 $k-1$ 的单独右倾斜路径。\n\n从上述定义以及对数和单调函数的基本性质出发，从基本原理推导出一个精确的封闭形式表达式，用于表示触发第一次重建所需向初始空树中插入的最小次数 $k$。该表达式可以使用朗伯W函数（Lambert $W$ function，定义为 $W(z)\\exp(W(z))=z$），并应表示为 $\\alpha$ 的函数。你的答案必须是仅含 $\\alpha$ 的单个符号表达式。不需要进行四舍五入。", "solution": "本题旨在找到在给定特定插入模式下，向初始为空的替罪羊树中插入多少次（最小次数 $k$）会触发第一次重建。\n\n首先，我们确定第 $k$ 次插入时树的状态。题目指出，插入了 $k$ 个不同的键，且顺序严格递增。\n- 插入的第一个键成为二叉搜索树（BST）的根，深度为 $d=0$。\n- 第二个键因为更大，成为根的右子节点，深度为 $d=1$。\n- 这个过程持续进行，第 $i$ 个插入的键成为第 $(i-1)$ 个键的右子节点。\n- 因此，在 $k$ 次插入后，树变成一个由 $k$ 个节点组成的退化的右倾斜路径。假设根的深度为0，则第 $k$ 个节点被插入到深度为 $d = k-1$ 的位置。\n\n题目声明没有删除操作。因此，在 $k$ 次插入后，树中的总节点数为 $k$。用于跟踪曾经存在的最大节点数的全局计数器 $q$ 因此为 $q=k$。\n\n插入时触发重建的条件是新节点的深度 $d$ 超过 $\\left\\lfloor \\log_{1/\\alpha}(q) \\right\\rfloor$。代入第 $k$ 次插入的值，我们得到：\n$d = k-1$\n$q = k$\n重建条件变为：\n$$k-1 > \\left\\lfloor \\log_{1/\\alpha}(k) \\right\\rfloor$$\n\n我们要寻找满足此不等式的最小整数 $k \\ge 1$。我们来分析这个不等式。因为 $k-1$ 是一个整数，所以对于整数 $A$，条件 $A > \\lfloor B \\rfloor$ 等价于 $A \\ge \\lfloor B \\rfloor + 1$。\n因此，我们寻找满足以下条件的最小整数 $k \\ge 1$：\n$$k-1 \\ge \\left\\lfloor \\log_{1/\\alpha}(k) \\right\\rfloor + 1$$\n\n为解决这个问题，我们可以分析两边函数的行为。处理此类涉及向下取整或向上取整函数的问题，一种常用技巧是首先解决问题的连续版本。让我们考虑连续函数 $f(x) = x-1$ 和 $g(x) = \\log_{1/\\alpha}(x)$。不等式 $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$ 与不等式 $x-1 > \\log_{1/\\alpha}(x)$ 密切相关。\n\n让我们通过求解方程 $x-1 = \\log_{1/\\alpha}(x)$ 来找到交点。\n使用对数换底公式 $\\log_{b}(a) = \\frac{\\ln(a)}{\\ln(b)}$，我们可以用自然对数 $\\ln$ 重写该方程：\n$$x-1 = \\frac{\\ln(x)}{\\ln(1/\\alpha)} = \\frac{\\ln(x)}{-\\ln(\\alpha)}$$\n$$-(x-1)\\ln(\\alpha) = \\ln(x)$$\n$$\\ln(x) + (x-1)\\ln(\\alpha) = 0$$\n$$\\ln(x) + x\\ln(\\alpha) - \\ln(\\alpha) = 0$$\n$$\\ln(x) - \\ln(\\alpha) = -x\\ln(\\alpha)$$\n$$\\ln\\left(\\frac{x}{\\alpha}\\right) = -x\\ln(\\alpha)$$\n对两边取指数：\n$$\\frac{x}{\\alpha} = \\exp(-x\\ln(\\alpha))$$\n乘以 $\\alpha\\ln(\\alpha)$：\n$$x\\ln(\\alpha) = \\alpha\\ln(\\alpha)\\exp(-x\\ln(\\alpha))$$\n现在，乘以 $\\exp(x\\ln(\\alpha))$：\n$$x\\ln(\\alpha) \\exp(x\\ln(\\alpha)) = \\alpha\\ln(\\alpha)$$\n该方程的形式为 $u\\exp(u) = z$，其中 $u = x\\ln(\\alpha)$ 且 $z = \\alpha\\ln(\\alpha)$。其解由朗伯W函数给出，即 $u = W(z)$。\n$$x\\ln(\\alpha) = W(\\alpha\\ln(\\alpha))$$\n$$x = \\frac{W(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)}$$\n函数 $y=t\\exp(t)$ 在 $t=-1$ 时取得最小值 $-1/e$。对于任何 $z \\in [-1/e, 0)$，方程 $t\\exp(t)=z$ 有两个实数解，由朗伯W函数的两个分支表示：$W_0(z)$（主分支，其中 $W_0(z) \\ge -1$）和 $W_{-1}(z)$（下分支，其中 $W_{-1}(z) \\le -1$）。\n\nW函数的自变量是 $z=\\alpha\\ln(\\alpha)$。对于给定范围 $\\frac{1}{2}  \\alpha  1$，$\\alpha\\ln(\\alpha)$ 的值在区间 $(\\frac{1}{2}\\ln(\\frac{1}{2}), 0) \\approx (-0.346, 0)$ 内。这个区间位于 $[-1/e, 0)$ 内部，因此 $x$ 存在两个实数根。\n\n我们来分析函数 $h(x) = x-1 - \\log_{1/\\alpha}(x)$。它的根就是我们刚才找到的解。$h(1) = 1-1-\\log_{1/\\alpha}(1) = 0$，所以 $x=1$ 是一个根。其导数为 $h'(x) = 1 - \\frac{1}{x\\ln(1/\\alpha)}$。由于 $\\frac{1}{2}  \\alpha  1$，我们有 $1  1/\\alpha  2$ 和 $0  \\ln(1/\\alpha)  \\ln(2)  1$。因此 $h'(1) = 1 - \\frac{1}{\\ln(1/\\alpha)}  0$。函数从 $h(1)=0$ 开始，递减到一个最小值，然后对于所有更大的 $x$ 递增（因为当 $x \\to \\infty$ 时 $h(x) \\to \\infty$）。这意味着存在另一个根 $x^* > 1$。对于所有 $x > x^*$，我们有 $h(x) > 0$，即 $x-1 > \\log_{1/\\alpha}(x)$。\n\n较大的根 $x^*$ 对应于 $u = x\\ln(\\alpha)$ 的更负的值（因为 $\\ln(\\alpha)$ 是负数）。$u$ 的两个解是 $W_0(\\alpha\\ln(\\alpha)) \\in [-1, 0)$ 和 $W_{-1}(\\alpha\\ln(\\alpha)) \\le -1$。较大的根 $x^*$ 必须对应于更负的 $u$，而这来自于 $W_{-1}$ 分支。\n因此，临界点是：\n$$x^* = \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)}$$\n\n我们正在寻找满足 $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$ 的最小整数 $k$。\n\n我们来分析任何整数 $k \\le x^*$。对于这样的 $k$，我们有 $h(k) \\le 0$（因为 $k=1$ 是一个根，并且 $h(x)$ 在两个根之间是负的）。所以，$k-1 \\le \\log_{1/\\alpha}(k)$。由于 $k-1$ 是一个整数，这意味着 $k-1 \\le \\lfloor \\log_{1/\\alpha}(k) \\rfloor$。这与我们需要满足的条件相反，因此没有整数 $k \\le x^*$ 可以是解。\n\n现在，我们来分析任何整数 $k > x^*$。这样的最小整数是 $k_{min} = \\lfloor x^* \\rfloor + 1$。对于任何这样的 $k$，我们有 $h(k) > 0$，所以 $k-1 > \\log_{1/\\alpha}(k)$。这意味着 $k-1 \\ge \\lfloor \\log_{1/\\alpha}(k) \\rfloor$。我们必须检查等式是否可能成立。\n如果等式成立，则 $k-1 = \\lfloor \\log_{1/\\alpha}(k) \\rfloor$。这意味着 $k-1 \\le \\log_{1/\\alpha}(k)$，这与 $k-1 > \\log_{1/\\alpha}(k)$ 相矛盾。因此，等式不可能成立，对于任何整数 $k > x^*$，严格不等式 $k-1 > \\lfloor \\log_{1/\\alpha}(k) \\rfloor$ 必定为真。\n\n满足重建条件的最小整数 $k$ 是大于 $x^*$ 的最小整数。这正是 $\\lfloor x^* \\rfloor + 1$。\n因此，所需的最小插入次数 $k$ 由下式给出：\n$$k = \\left\\lfloor \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)} \\right\\rfloor + 1$$\n这是在指定条件下触发第一次重建所需的最少插入次数的精确、封闭形式表达式。", "answer": "$$\n\\boxed{\\left\\lfloor \\frac{W_{-1}(\\alpha\\ln(\\alpha))}{\\ln(\\alpha)} \\right\\rfloor + 1}\n$$", "id": "3268397"}, {"introduction": "高效处理插入操作只是替罪羊树的一部分，它同样需要优雅地应对删除操作。一种常见的策略是，当树因大量删除而变得过于稀疏时，进行一次全局重建。这个练习要求你扮演一个“对手”的角色，设计一个最短的操作序列来强制触发代价最高昂的全局重建 [@problem_id:3268410]。完成这一挑战将使你深刻理解删除机制背后的平摊效率保证，以及树是如何通过维护最大尺寸记录来确保长期性能的。", "problem": "考虑一种替罪羊树（Scapegoat Tree），它是一种权重平衡二叉搜索树（BST），由一个固定的平衡常数 $\\alpha \\in (\\frac{1}{2}, 1)$ 参数化。替罪羊树维护以下不变式和规则：\n\n- 对于任何大小为 $s(v)$ 的子树的节点 $v$，权重平衡要求是：对于 $v$ 的每个子节点 $u$，其子树大小满足 $s(u) \\leq \\alpha \\, s(v)$。\n- 每次插入时，一个键会作为叶节点插入，并且在必要时，会识别出一个违规的祖先节点，并重建其子树以满足权重平衡条件。\n- 每次删除时，树会维护一个变量 $m$，其值等于自上次完全重建以来树所达到的最大大小。删除后，如果当前键的数量 $n$ 满足 $n  \\alpha \\, m$，则整棵树将被重建，并且 $m$ 会被重置为 $n$。\n\n一个对手知道 $\\alpha$ 的值，并可以从一棵空的替罪羊树开始，执行一个由插入和删除组成的序列。对手的目标是强制触发一次可能的最昂贵的单次重建，定义为当树中恰好包含 $N$ 个键时重建整棵树（即根节点的子树），从而使代价与 $N$ 成正比。\n\n在所有能使树在恰好有 $N$ 个键时实现全树重建的对手序列中，确定其最小可能长度，并以 $\\alpha$ 和 $N$ 的封闭形式表达式给出。序列的长度是指直到并包括触发重建的操作在内所执行的总操作数（插入次数加删除次数）。请以精确形式提供您的答案；无需四舍五入。", "solution": "题目要求找到一个操作序列（插入和删除）的最小长度，该序列能强制一棵替罪羊树在其大小恰好变为 $N$ 的那一刻进行全树重建。\n\n问题陈述，如果删除操作后得到的节点数 $n$ 和自上次完全重建以来的最大树大小 $m$ 满足条件 $n  \\alpha m$，则会由该次删除触发一次全树重建。对手的目标是在树的最终大小为 $n=N$ 时触发此事件。因此，操作序列必须最终达到这样一种状态：一次删除操作导致树的大小变为 $N$，并且条件 $N  \\alpha m$ 得到满足。\n\n设操作序列由 $I$ 次插入和 $D$ 次删除组成。序列的总长度为 $L = I + D$。由于树中最终的节点数为 $N$，我们有关系式 $I - D = N$。我们可以用 $I$ 和 $N$ 来表示总长度 $L$：\n$$L = I + D = I + (I - N) = 2I - N$$\n为了最小化长度 $L$，对手必须最小化总插入次数 $I$。\n\n变量 $m$ 跟踪树曾达到的最大大小。要满足重建条件 $N  \\alpha m$，树必须在某个时刻至少包含 $m$ 个节点。实现这一目标的最有效方法是执行插入操作，直到树的大小达到某个峰值，我们将此峰值设为我们的 $m$。因此，插入次数 $I$ 必须至少为 $m$，即 $I \\ge m$。为了最小化 $I$，对手应选择可行的最小 $m$ 值，并设 $I=m$。问题因此归结为找到 $m$ 的最小可行值。\n\n对手最小化操作的策略如下：\n1. 执行 $m$ 次插入，使树的大小达到 $n=m$。此时，最大大小变量也是 $m$。尚未发生任何删除操作。\n2. 执行 $m - (N+1)$ 次删除，将树的大小减小到 $N+1$。\n3. 执行最后一次删除，将树的大小从 $N+1$ 减小到 $N$。这最后一次操作必须触发全树重建。\n\n为使此策略成功且最小化，必须满足与重建触发相关的两个条件：\na) 最后一次删除（将大小从 $N+1$ 减小到 $N$）必须触发重建。根据规则，这意味着新的大小 $N$ 必须满足：\n$$N  \\alpha m$$\nb) 为确保这是删除阶段触发的第一次此类全树重建，前一次删除（将大小从 $N+2$ 减到 $N+1$）必须*没有*触发重建。一般来说，任何导致大小 $k > N$ 的删除都不应触发重建。最严格的情况是针对这样的最小大小，即 $N+1$。因此，大小 $N+1$ 必须*不*满足重建条件：\n$$N+1 \\ge \\alpha m$$\n\n结合这两个不等式，我们得到整数 $m$ 必须满足的单一条件：\n$$N  \\alpha m \\le N+1$$\n两边同除以 $\\alpha$（因为 $\\alpha \\in (\\frac{1}{2}, 1)$，$\\alpha$ 是正数），我们得到：\n$$\\frac{N}{\\alpha}  m \\le \\frac{N+1}{\\alpha}$$\n区间 $(\\frac{N}{\\alpha}, \\frac{N+1}{\\alpha}]$ 的长度为 $\\frac{N+1}{\\alpha} - \\frac{N}{\\alpha} = \\frac{1}{\\alpha}$。因为 $\\alpha \\in (\\frac{1}{2}, 1)$，我们有 $\\frac{1}{\\alpha} \\in (1, 2)$。一个长度大于 1 的区间保证至少包含一个整数，因此总存在一个整数 $m$ 满足此条件。\n\n为了最小化总操作数 $L = 2I - N$，我们必须最小化 $I$。由于最小插入次数为 $I=m$，我们必须找到满足所推导不等式的最小整数 $m$。严格大于 $\\frac{N}{\\alpha}$ 的最小整数 $m$ 由下式给出：\n$$m_{\\min} = \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1$$\n我们已经确定在所需区间内存在一个整数 $m$，并且由于此公式给出了大于下界 $\\frac{N}{\\alpha}$ 的最小整数，因此这个 $m_{\\min}$ 必须是最小的有效峰值大小。\n\n因此，最小插入次数为 $I_{\\min} = m_{\\min} = \\lfloor \\frac{N}{\\alpha} \\rfloor + 1$。\n为达到最终大小 $N$ 所需的相应删除次数为 $D = I_{\\min} - N = (\\lfloor \\frac{N}{\\alpha} \\rfloor + 1) - N$。\n对手序列的最小总长度为 $L_{\\min} = I_{\\min} + D$。\n$$L_{\\min} = \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) + \\left( \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N \\right)$$\n$$L_{\\min} = 2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N$$\n这就是所需的最小操作数。对手的序列包括 $I_{\\min}$ 次插入以达到峰值大小 $m_{\\min}$，然后是 $D = m_{\\min} - N$ 次删除。在此过程中，不需要发生由插入触发的全树重建（对手可以选择插入的键以保持树足够平衡），并且根据我们对 $m_{\\min}$ 的选择，直到最后一次删除之前，不会发生由删除触发的重建。", "answer": "$$\n\\boxed{2 \\left( \\left\\lfloor \\frac{N}{\\alpha} \\right\\rfloor + 1 \\right) - N}\n$$", "id": "3268410"}]}