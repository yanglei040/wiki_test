{"hands_on_practices": [{"introduction": "要真正掌握二项堆，我们必须首先深刻理解其独特的结构。第一个练习将挑战你，将节点总数 $N$ 与堆中的树的数量联系起来。通过解决这个问题，你将具体地理解二项堆的构成与其规模的二进制表示之间的优美关系。[@problem_id:3216510]", "problem": "二项堆是由二项树组成的森林，其中每棵二项树 $B_{i}$ 有 $2^{i}$ 个节点，且森林对每种阶 $i$ 的树最多包含一棵。考虑通过逐个插入 $N$ 个不同的键来构建一个二项堆，使用标准的二项堆插入操作，该操作通过链接来合并相同阶的树，并假设不发生删除或键值减小操作。固定一个整数 $k \\geq 3$，并考虑所有满足 $1 \\leq N \\leq 2^{k} - 1$ 的整数 $N$。请确定，在这 $N$ 次插入之后，二项堆的根列表中恰好有 3 棵树的此类 $N$ 的数量，并以 $k$ 的函数形式表示。将您的最终答案表示为关于 $k$ 的封闭形式解析表达式。", "solution": "## 问题验证\n\n### 步骤1：提取已知信息\n- **数据结构：** 二项堆是由二项树组成的森林。\n- **二项树属性：** 阶为 $i$ 的树，记作 $B_i$，有 $2^i$ 个节点。\n- **堆结构属性：** 一个二项堆对每种阶 $i$ 的树最多包含一棵。\n- **操作：** 通过逐个插入 $N$ 个不同的键来构建堆。\n- **插入方法：** 使用标准的通过链接来合并相同阶的树的方法。\n- **操作约束：** 不发生删除或`decrease-key`操作。\n- **参数：** 固定一个整数 $k \\geq 3$。\n- **$N$ 的范围：** 节点数 $N$ 是一个满足 $1 \\leq N \\leq 2^k - 1$ 的整数。\n- **目标条件：** 最终的二项堆必须在其根列表中恰好有 3 棵树。\n- **目标：** 确定在指定范围内满足目标条件的整数 $N$ 的数量，表示为关于 $k$ 的封闭形式解析函数。\n\n### 步骤2：使用提取的已知信息进行验证\n根据验证标准评估问题陈述：\n\n1.  **科学依据：** 该问题基于二项堆的标准且成熟的理论，这是计算机科学和算法中的一种基本数据结构。所描述的属性（例如，一棵树 $B_i$ 有 $2^i$ 个节点，包含 $N$ 个项的堆的结构）是教科书中的定义。\n2.  **良构性：** 问题提供了所有必要信息。定义清晰，$N$ 的范围由 $k$ 精确定义，要满足的条件（恰好3棵树）是明确的。问题要求计数，这意味着存在一个作为 $k$ 的函数的唯一数值答案。\n3.  **客观性：** 语言是形式化和客观的。没有主观或基于观点的陈述。\n4.  **无缺陷：**\n    - 它不违反科学原理。\n    - 这是一个数据结构和算法领域的正式问题，特别与二项堆相关。\n    - 设置是完整和一致的。约束 $k \\geq 3$ 至关重要且已给出。\n    - 在该数据结构的理论背景下，这些条件并非不切实际或不可行。\n    - 问题结构良好，并导向一个唯一的、有意义的解。\n    - 问题并非微不足道；它需要理解二项堆结构的核心属性。\n\n### 步骤3：结论与行动\n问题是 **有效的**。这是一个关于二项堆属性的、定义明确的组合问题。将提供完整解答。\n\n## 解法\n\n包含 $N$ 个节点的二项堆的结构由整数 $N$ 的二进制表示唯一确定。具体来说，一个包含 $N$ 个节点的二项堆含有一棵阶为 $i$ 的二项树 $B_i$，当且仅当 $N$ 的二进制表示中第 $i$ 位为 $1$。设 $N$ 的二进制表示为 $(c_{m} c_{m-1} \\dots c_1 c_0)_2$，其中 $c_i \\in \\{0, 1\\}$。那么，节点数 $N = \\sum_{i=0}^{m} c_i 2^i$。该堆将由树的集合 $\\{B_i \\mid c_i = 1\\}$ 组成。\n\n因此，二项堆根列表中的树的数量等于森林中二项树的数量。这又等于 $N$ 的二进制表示中 $1$ 的数量。这个量也称为 $N$ 的人口计数或汉明权重。\n\n问题要求的是使得包含 $N$ 个项的堆恰好有 3 棵树的整数 $N$ 的数量。这等价于找出二进制表示中恰好包含三个 $1$ 的整数 $N$ 的数量。\n\n问题指定 $N$ 的范围为 $1 \\leq N \\leq 2^k - 1$，对于一个固定的整数 $k \\geq 3$。\n数字 $2^k - 1$ 在二进制中表示为连续 $k$ 个 $1$ 的字符串。在范围 $1 \\leq N \\leq 2^k - 1$ 内的任何整数 $N$ 都可以用最多 $k$ 个比特（从比特位置 $0$ 到比特位置 $k-1$）来表示。我们可以将任何此类 $N$ 的二进制表示看作一个长度为 $k$ 的二进制字符串，可能带有前导零。例如，如果 $k=5$，数字 $N=7$ 是 $(111)_2$，可以写成 5 比特的字符串 $(00111)_2$。\n\n因此，问题转化为以下组合问题：在范围 $1 \\leq N \\leq 2^k - 1$ 内，有多少个整数 $N$ 的二进制表示中恰好有三个 $1$？\n\n这等价于计算长度为 $k$ 且恰好包含三个 $1$ 的二进制字符串的数量。这 $k$ 个比特的位置对应于二项树的阶，即位置 $0, 1, \\dots, k-1$。要形成一个二进制表示中有三个 $1$ 的数，我们必须从 $k$ 个可用的比特位置中恰好选择 $3$ 个位置来放置 $1$。剩下的 $k-3$ 个位置将用 $0$ 填充。\n\n从 $k$ 个元素的集合中选择 $3$ 个不同位置的方法数由二项式系数“k 选 3”给出，记作 $\\binom{k}{3}$。\n\n每个这样的选择都对应一个唯一的整数 $N  2^k$。由于我们选择三个 $1$，得到的数字 $N$ 将是三个不同 2 的幂之和。当选择最低的三个比特位置（0、1 和 2）时，出现最小的可能数，即 $N = 2^0 + 2^1 + 2^2 = 1 + 2 + 4 = 7$。因为问题陈述 $k \\geq 3$，所以 $N$ 的最小可能值总是 7，满足条件 $N \\geq 1$。因此，所有这些组合都会在指定范围内产生一个有效的 $N$。\n\n此类整数 $N$ 的数量为：\n$$ \\binom{k}{3} $$\n为了将其表示为 $k$ 的封闭形式解析表达式，我们展开二项式系数：\n$$ \\binom{k}{3} = \\frac{k!}{3!(k-3)!} = \\frac{k(k-1)(k-2)(k-3)!}{(3 \\cdot 2 \\cdot 1)(k-3)!} $$\n对于 $k \\geq 3$，$(k-3)!$ 项可以消掉，剩下：\n$$ \\frac{k(k-1)(k-2)}{6} $$\n此表达式给出了在范围 $1 \\leq N \\leq 2^k-1$ 内，使得大小为 $N$ 的二项堆恰好有 3 棵树的整数 $N$ 的数量。", "answer": "$$\\boxed{\\frac{k(k-1)(k-2)}{6}}$$", "id": "3216510"}, {"introduction": "在牢固掌握了堆的结构之后，我们现在可以设计利用该结构的高效算法。这个问题要求你在 $O(\\log n)$ 时间内找到第二小元素，这是一个常见而富有洞察力的挑战。为了成功，你必须推断出第二小元素的潜在候选者可能存在的位置，这需要结合你对最小堆属性和根列表组织的知识。[@problem_id:3216453]", "problem": "一个索引优先级队列被实现为一个二项堆，其键满足堆序性质（一个节点的键大于或等于其父节点的键）。假设该二项堆包含 $n$ 个元素，维持一个指向最小根的直接指针，并支持常规操作，但在查询期间不允许修改数据结构。\n\n根据基本定义：二项堆是一个由二项树 $\\{B_k\\}$ 组成的森林，其中每个 $B_k$ 有 $2^k$ 个节点，其根的度为 $k$。该森林每种阶的树最多包含一棵，因此根的数量最多为 $\\lfloor \\log_2 n \\rfloor + 1$。在每个具有堆序性质的二项树中，根节点的键是其所在树中最小的。在最小根所在的树中，除去根节点后的最小值必定在根节点的子节点中，因为任何子节点的所有后代的键都大于或等于该子节点的键。\n\n选择一个选项，该选项既能正确地确定第二小元素必须位于何处，又能在不修改堆的情况下，以最坏情况 $O(\\log n)$ 的时间复杂度完成：\n\nA. 只检查最小根的子节点并返回其中最小的；这是可行的，因为第二小的元素必须在最小根的子节点中，且根的度最多为 $O(\\log n)$。\n\nB. 只检查除最小根之外的其他根节点并返回其中最小的；这是可行的，因为树中的任何节点都大于或等于其根节点，并且根节点的数量为 $O(\\log n)$。\n\nC. 在除去最小值的 $n-1$ 个元素上构建一个临时的二叉堆，然后提取其最小值以获得第二小值；这是可行的，构建需要 $O(n)$ 时间，提取需要 $O(\\log n)$ 时间。\n\nD. 检查最小根的子节点和所有其他根节点的并集，并返回该集合中最小的元素；这是可行的，因为最小根之外的任何元素都至少等于其所在树的根，而最小根树内的任何元素（不包括根）都至少等于其对应的子节点；该集合的大小为 $O(\\log n)$。\n\nE. 执行一次 delete-min 操作使第二小元素成为新的最小值，然后记录它，并通过重新插入被移除的子树来恢复原始堆；这是可行的，delete-min 操作需要 $O(\\log n)$ 的成本，外加额外的重新插入成本。", "solution": "问题陈述已经过验证，被认为是定义明确、科学上合理且内部一致的。它描述了一个关于二项堆的标准计算机科学问题。所提供的定义和约束是标准且明确的。\n\n任务是在一个包含 $n$ 个元素、实现为最小堆的二项堆中，在最坏情况 $O(\\log n)$ 时间内找到第二小的元素，且不修改数据结构。\n\n设二项堆为 $H$。它是一个满足最小堆性质的二项树森林。问题指出，我们有一个指向具有全局最小键的根的直接指针。设此根为 $r_{\\min}$，其键为 $k_{\\min}$。根据定义，$k_{\\min}$ 是整个堆 $H$ 中最小的键。\n\n堆中的第二小元素的键必须大于 $k_{\\min}$。为了找到这个元素，我们必须识别出所有其键可能是第二小的潜在候选者。堆中所有节点的集合可以划分为两个不相交的集合：\n1. 包含最小根 $r_{\\min}$ 的二项树 $T_{\\min}$。\n2. 森林中所有其他二项树的集合 $\\{T_1, T_2, \\dots, T_m\\}$。\n\n第二小元素必须是排除 $r_{\\min}$ 后的所有节点集合中键最小的元素。我们可以通过从每个分区中找到最小候选者然后比较它们来找到这个集合的最小值。\n\n来自树 $T_{\\min}$ 的候选集：\n$T_{\\min}$ 中的节点（不包括根 $r_{\\min}$）是 $r_{\\min}$ 的后代。设 $c_1, c_2, \\dots, c_d$ 是 $r_{\\min}$ 的子节点，其中 $d$ 是 $r_{\\min}$ 的度。由于最小堆性质，对于任何节点 $x$，其键都大于或等于其父节点的键。这意味着两件事：\n- 对于 $r_{\\min}$ 的任何子节点 $c_i$，$key(c_i) \\ge key(r_{\\min})$。\n- 对于以子节点 $c_i$ 为根的子树中的任何节点 $x$，$key(x) \\ge key(c_i)$。\n因此，$r_{\\min}$ 的所有后代中的最小键必须属于其直接子节点之一。第二小键的第一组候选者是 $r_{\\min}$ 的子节点的键集合。\n\n来自其他树 $\\{T_1, T_2, \\dots, T_m\\}$ 的候选集：\n设这些其他树的根为 $r_1, r_2, \\dots, r_m$。对于此集合中的任何树 $T_j$，最小堆性质保证其根 $r_j$ 拥有该树内的最小键。因此，所有这些其他树的并集中的最小键就是它们根的键的最小值，即 $\\min\\{key(r_1), key(r_2), \\dots, key(r_m)\\}$。第二小键的第二组候选者是堆的根列表中所有其他二项树的根的键集合。\n\n综合这些发现，整个堆中的第二小元素必须是这两个候选集并集的最小值：最小根 $r_{\\min}$ 的子节点集合，以及堆的根列表中所有其他根的集合。\n\n我们来分析这种方法的时间复杂度。\n一个包含 $n$ 个元素的二项堆最多由 $\\lfloor \\log_2 n \\rfloor + 1$ 棵二项树组成，即 $O(\\log n)$。所以，根列表中的总根数是 $O(\\log n)$。因此，“其他根”的数量也是 $O(\\log n)$。\n一个包含 $n$ 个元素的二项堆中，根的度最多为 $\\lfloor \\log_2 n \\rfloor$。因此，最小根 $r_{\\min}$ 的子节点数量是 $O(\\log n)$。\n需要检查的候选者总数是 $r_{\\min}$ 的子节点数量与其他根数量之和，即 $O(\\log n) + O(\\log n) = O(\\log n)$。\n在一个大小为 $O(\\log n)$ 的集合中找到最小元素需要 $O(\\log n)$ 次比较。这种方法不会改变堆的结构，满足了问题的约束。\n\n现在，我们评估每个选项：\n\nA. 只检查最小根的子节点并返回其中最小的；这是可行的，因为第二小的元素必须在最小根的子节点中，且根的度最多为 $O(\\log n)$。\n这是不正确的。这种方法没有考虑到第二小元素可能是森林中另一棵二项树的根。例如，在一个包含两棵树的堆中，一棵根为 $1$（子节点为 $10$），另一棵根为 $2$，第二小的元素是 $2$，它不是最小根 $1$ 的子节点。\n\nB. 只检查除最小根之外的其他根节点并返回其中最小的；这是可行的，因为树中的任何节点都大于或等于其根节点，并且根节点的数量为 $O(\\log n)$。\n这是不正确的。这种方法没有考虑到第二小元素可能是最小根的子节点。例如，在一个只有一棵树的堆中，根为 $1$，子节点为 $2$，此时没有其他根。第二小的元素是 $2$，是最小根的子节点。\n\nC. 在除去最小值的 $n-1$ 个元素上构建一个临时的二叉堆，然后提取其最小值以获得第二小值；这是可行的，构建需要 $O(n)$ 时间，提取需要 $O(\\log n)$ 时间。\n这是不正确的。虽然该算法能正确找到第二小的元素，但其时间复杂度主要由临时堆的构建决定，这需要遍历 $n-1$ 个元素并花费 $O(n)$ 时间。问题要求最坏情况时间复杂度为 $O(\\log n)$。\n\nD. 检查最小根的子节点和所有其他根节点的并集，并返回该集合中最小的元素；这是可行的，因为最小根之外的任何元素都至少等于其所在树的根，而最小根树内的任何元素（不包括根）都至少等于其对应的子节点；该集合的大小为 $O(\\log n)$。\n这是正确的。如上所述，第二小元素的候选集正是最小根的子节点与根列表中所有其他根的并集。该集合的大小为 $O(\\log n)$，找到最小值需要 $O(\\log n)$ 时间。此过程不修改堆。选项中提供的理由也是合理的。\n\nE. 执行一次 delete-min 操作使第二小元素成为新的最小值，然后记录它，并通过重新插入被移除的子树来恢复原始堆；这是可行的，delete-min 操作需要 $O(\\log n)$ 的成本，外加额外的重新插入成本。\n这是不正确的。问题陈述中明确包含约束：“在查询期间不允许修改数据结构”。`delete-min` 操作从根本上修改了堆的结构。即使堆可以在之后恢复，查询本身也涉及修改，违反了问题的核心约束。", "answer": "$$\\boxed{D}$$", "id": "3216453"}, {"introduction": "掌握二项堆的最后一步是实现其核心功能。这个动手实践问题将指导你实现 `delete` 操作，这是一个构建在 `decrease_key` 和 `extract_min` 等其他原语之上的强大功能。通过不仅实现算法，还通过经验验证其 $O(\\log n)$ 的摊销时间复杂度，你将在理论分析与实用、高性能代码之间架起一座桥梁。[@problem_id:3216452]", "problem": "您需要实现一个完整的、支持直接指针删除操作的二项堆，并在一个固定的测试套件上凭经验验证其正确性和摊销时间界限。请使用二项树和堆的核心定义，以及针对基本指针和键操作的单位成本模型，从第一性原理出发进行工作。\n\n二项堆是一个由二项树组成的森林，满足以下基本属性和不变量：\n- 一个阶为 $k$ 的二项树，记为 $B_k$，由以下事实递归定义：$B_0$ 是一个单节点，而 $B_k$ 是通过将一个 $B_{k-1}$ 的根链接为另一个 $B_{k-1}$ 的根的最左边的孩子而形成的。这意味着一些经过充分检验的结构事实：$B_k$ 恰好有 $2^k$ 个节点，其高度为 $k$，其根的度数为 $k$，并且根的孩子按从左到右的顺序分别是 $B_{k-1}, B_{k-2}, \\ldots, B_0$ 的根。\n- 二项堆是一组零个或多个二项树的集合，其中没有两棵树具有相同的阶（根的度数），并且根列表按阶的升序维护。每棵树都遵循最小堆序：每个节点的键都大于或等于其父节点的键。\n\n从这些核心定义出发，设计并实现：\n- 一个支持 $insert$、$meld$（两个堆的并集）、$find\\_min$、$extract\\_min$、$decrease\\_key$ 和 $delete(p)$ 操作的二项堆，其中 $p$ 是一个指向节点的直接指针。$delete(p)$ 操作必须通过组合基本堆操作来实现，其方式必须在上述不变量下对二项堆有效。\n- 一个单位成本的步数计数器，每当您的代码执行一次键比较、键交换、父子链接或断开链接、兄弟指针更改或在根列表上进行扫描前进时，该计数器就计为一个基本步骤。您必须设计此计数器，以使在 $delete(p)$ 期间计数的步数是在指针模型中对 $delete(p)$ 的抽象成本的一个忠实的上界。\n\n您的程序必须：\n- 构建一个二项堆并维护显式节点指针以供后续删除。\n- 在给定指向节点的直接指针 $p$ 的情况下，仅使用与上述不变量一致的允许的二项堆原语来实现 $delete(p)$。\n- 对于每个测试用例，在一个按规定构建的全新堆上精确执行一次 $delete(p)$ 操作，并且：\n  1. 通过按非递减顺序提取所有元素，并与预期的排序列表进行比较，来验证结果堆是一个有效的二项堆，并且删除后的键的多重集等于原始多重集减去被删除的键。\n  2. 仅记录 $delete(p)$ 操作的步数 $S$（不包括验证所用的步数），并检查是否满足 $S \\leq A \\lceil \\log_2(\\max\\{1,n\\}) \\rceil + B$，其中 $A$ 和 $B$ 是固定的正常数，$n$ 是调用 $delete(p)$ 之前的堆大小。所有测试用例必须使用相同的常数 $A$ 和 $B$。\n\n测试套件。对于每个用例，所有键都是唯一的整数。\n- 案例 1（一般情况）：按顺序插入键 $[7,3,17,24,1,8,12,30,25,2,5,16,9,14,4]$，令 $p$ 为插入键 $16$ 时返回的指针，然后删除 $p$。\n- 案例 2（删除最小根）：插入键 $[10,20,5,30]$，令 $p$ 为键 $5$ 的指针，然后删除 $p$。\n- 案例 3（单例）：插入键 $[42]$，令 $p$ 为键 $42$ 的指针，然后删除 $p$。\n- 案例 4（合并后删除内部元素）：通过插入 $[50,40,60]$ 构建堆 $H_1$，通过插入 $[15,70,65,55,45]$ 构建堆 $H_2$。将 $H_2$ 合并到 $H_1$ 中。令 $p$ 为键 $65$（来自 $H_2$）的指针，然后从合并后的堆中删除 $p$。\n- 案例 5（较大堆）：插入键 $[1,2,\\ldots,100]$，令 $p$ 为键 $57$ 的指针，然后删除 $p$。\n\n对于每个用例，您的程序必须输出一个布尔值，指示正确性检查和摊销界限检查是否都已通过，并使用您选择的固定常数 $A$ 和 $B$ 的不等式。选择足够大以便安全且对您实现的单位成本模型有意义的 $A$ 和 $B$；所有用例都必须使用相同的 $A$ 和 $B$。\n\n最终输出格式。您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表的结果（例如，类似 $[true,false,\\ldots]$，但使用您所用语言的布尔文字）。该列表的长度必须正好为 5，顺序与上述用例一致。不允许有其他额外输出。", "solution": "问题陈述已经过验证，并被确定为数据结构和算法领域中一个定义明确、具有科学依据的问题。它要求实现一个支持直接指针删除操作的二项堆，并对其进行经验性验证。其定义、属性和所需操作都是标准的，并与已有的计算机科学文献一致。测试套件是具体的，成功标准是客观且可验证的。\n\n### 1. 数据结构设计\n\n二项堆实现为一个二项树森林，这些树的根存储在一个按其阶（度）排序的单向链表中。\n\n**节点结构**：堆中的每个元素由一个 `Node` 对象表示，具有以下属性：\n- `key`：存储在节点中的值，为整数。\n- `parent`：指向父节点的指针。对于根节点，它为 `None`。\n- `child`：指向节点最左边孩子的指针。\n- `sibling`：指向节点右边下一个兄弟节点的指针。对于根节点，此指针链接到堆的根列表中的下一个根。\n- `degree`：节点的子节点数，对应于以此节点为根的二项树的阶。\n\n**堆结构**：`BinomialHeap` 类封装了整个数据结构及其相关操作。它主要包含：\n- `head`：指向根列表中第一个根（阶最小的那个）的指针。\n- `step_counter`：一个整数，用于跟踪单位成本模型指定的原始操作数量。\n\n### 2. 核心操作和成本模型\n\n实现遵循单位成本模型，其中 `step_counter` 会对以下每个原始操作进行递增：键比较、键交换、父子链接/断开链接、兄弟指针更改以及在根列表上的扫描前进。\n\n**连接二项树 (`_link`)**：两个阶为 $k-1$ 的二项树，比如说一个根为 $y$ 的 $B_{k-1}$ 和另一个根为 $z$ 的 $B_{k-1}$，可以被连接成一个 $B_k$ 树。假设 $z.key \\le y.key$，$y$ 成为 $z$ 的新的最左边的孩子。这涉及更新三个指针：$y$ 的父指针变为 $z$，$y$ 的兄弟指针设置为 $z$ 的旧孩子，而 $z$ 的孩子指针变为 $y$。此操作耗费 $3$ 个步骤。\n\n**合并根列表 (`_merge_root_lists`)**：这个辅助函数将两个已排序的根列表（来自两个堆）合并成一个单一的排序列表，非常类似于归并排序算法的合并步骤。成本为每个被考虑的节点计一次“扫描前进”步骤，以及每个添加到合并列表中的节点计一次“兄弟指针更改”。\n\n**合并 (Union)**：`meld` 操作，用于形成两个二项堆的并集，是最基本的操作。\n1.  它首先使用 `_merge_root_lists` 合并两个堆的根列表。\n2.  然后它会对新合并的根列表执行一次合并（consolidation）遍，以强制执行没有两棵树具有相同阶的属性。它使用三个指针（`prev_x`、`x`、`next_x`）遍历根列表，并连接相同阶的树。如果根 $x$ 和 $next\\_x$ 具有相同的度，它们就会被连接。结果树的度可能与列表中下一个根的度相同，这需要进一步的连接。这个过程类似于二进制加法。成本包括用于遍历的“扫描前进”、用于确定哪个根成为父节点的“键比较”以及 `_link` 操作的成本。\n\n**插入 (Insert)**：插入一个键涉及创建一个新的单例二项堆（一个单独的 $B_0$ 树）并将其与现有堆进行合并。`insert` 方法返回一个指向新创建节点的直接指针。\n\n**`find_min_node`**：这个内部实用工具通过对根列表进行单次线性扫描来找到具有最小键的根。成本是每个根一次“键比较”和一次“扫描前进”。\n\n**`extract_min`**：此操作从堆中移除具有最小键的节点。\n1.  使用 `find_min_node` 定位最小根 $x$。\n2.  从根列表中移除节点 $x$（一次“兄弟指针更改”）。\n3.  $x$ 的孩子们（它们是 $B_{k-1}, \\ldots, B_0$ 的根）形成一个新的二项堆。这涉及到反转孩子列表以维持阶的递增顺序，并将每个孩子与其父节点 $x$ 断开链接（“兄弟指针更改”和“父子断开链接”的成本）。\n4.  然后将这个新堆与原始堆进行合并。\n总成本主要由查找最小值和最终的合并操作决定，摊销复杂度为 $O(\\log n)$。\n\n**`decrease_key`**：此操作减小给定节点 $p$ 的键值。更新键后，最小堆属性可能被违反。为了恢复它，通过反复与父节点的键交换，只要它小于父节点的键，就将该键“上浮”。此过程中的每一步都耗费一次“键比较”和一次“键交换”。到根的路径长度最多为 $O(\\log n)$。\n\n### 3. `delete(p)` 的实现\n\n`delete(p)` 操作在给定指向节点 $p$ 的直接指针的情况下，使用两个基本操作的标准组合来实现，确保与堆不变量的一致性：\n1.  **`decrease_key(p, -infinity)`**：待删除节点的键被更改为一个比堆中任何其他可能的键都小的值（例如 `float('-inf')`）。这个操作会使该节点上浮，成为其所在二项树的根。其成本与 `decrease_key` 相同，与节点的初始深度成正比，上限为 $O(\\log n)$。\n2.  **`extract_min()`**：节点 $p$ 现在保证拥有整个堆中的最小键，使用 `extract_min` 操作将其移除。其成本是 `extract_min` 的标准摊销 $O(\\log n)$。\n\n因此 `delete(p)` 的总摊销成本为 $O(\\log n) + O(\\log n) = O(\\log n)$。\n\n### 4. 验证与摊销界限分析\n\n对于每个测试用例，都将验证实现的正确性和性能。\n- **设置**：按规定构建一个全新的堆。保留要删除的节点指针 $p$。记录删除前的堆大小 $n$。\n- **执行**：步数计数器重置为 $0$，并调用 `delete(p)`。记录最终的步数 $S$。\n- **正确性检查**：通过使用 `extract_min` 破坏性地提取所有剩余元素，来确认删除后堆的有效性。如果堆结构正确，此过程将按非递减顺序产生元素。将此结果列表与预期的列表进行比较，预期列表是初始键的排序列表减去被删除的键。\n- **摊销界限检查**：将测得的步数 $S$ 与理论摊销界限进行核对。我们使用不等式 $S \\le A \\lceil \\log_2(\\max\\{1,n\\}) \\rceil + B$。基于对 `decrease_key` 和 `extract_min` 中所涉及的基本操作的高级分析（两者都受对数因子限制），我们选择保守的正常数 $A=20$ 和 $B=20$。这些常数在所有测试用例中都是固定的。项 $\\max\\{1,n\\}$ 处理了空堆的边界情况，其中 $\\log_2(0)$ 未定义，且 $\\lceil \\log_2(1) \\rceil = 0$。\n\n当且仅当正确性检查和摊销界限检查都成功时，一个测试用例才算通过。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Represents a node in a binomial tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.parent = None\n        self.child = None\n        self.sibling = None\n        self.degree = 0\n\nclass BinomialHeap:\n    \"\"\"Implements a binomial heap with a direct-pointer delete operation.\"\"\"\n    def __init__(self):\n        self.head = None\n        self.step_counter = 0\n\n    def reset_counter(self):\n        \"\"\"Resets the step counter to zero.\"\"\"\n        self.step_counter = 0\n\n    def _link(self, y, z):\n        \"\"\"Links two trees of the same rank. y becomes a child of z.\"\"\"\n        y.parent = z\n        self.step_counter += 1  # parent-child link\n        y.sibling = z.child\n        self.step_counter += 1  # sibling pointer change\n        z.child = y\n        self.step_counter += 1  # parent-child link\n        z.degree += 1\n\n    def _merge_root_lists(self, h2):\n        \"\"\"Merges the root list of another heap with this heap's.\"\"\"\n        h1_head = self.head\n        h2_head = h2.head\n        \n        if h1_head is None:\n            return h2_head\n        if h2_head is None:\n            return h1_head\n\n        new_head = None\n        p1, p2 = h1_head, h2_head\n        \n        if p1.degree = p2.degree:\n            new_head = p1\n            p1 = p1.sibling\n        else:\n            new_head = p2\n            p2 = p2.sibling\n        \n        tail = new_head\n        \n        while p1 is not None and p2 is not None:\n            self.step_counter += 1 # scan advance\n            if p1.degree = p2.degree:\n                tail.sibling = p1\n                p1 = p1.sibling\n            else:\n                tail.sibling = p2\n                p2 = p2.sibling\n            self.step_counter += 1 # sibling pointer change\n            tail = tail.sibling\n        \n        if p1 is not None:\n            tail.sibling = p1\n            self.step_counter += 1 # sibling pointer change\n        elif p2 is not None:\n            tail.sibling = p2\n            self.step_counter += 1 # sibling pointer change\n        \n        return new_head\n\n\n    def meld(self, other_heap):\n        \"\"\"Unions this heap with another binomial heap.\"\"\"\n        temp_heap = BinomialHeap()\n        self.head = self._merge_root_lists(other_heap)\n        \n        if self.head is None:\n            return\n\n        prev_x = None\n        x = self.head\n        next_x = x.sibling\n        \n        while next_x is not None:\n            self.step_counter += 1 # scan advance over root list\n            \n            # Case 1  2 (degrees are different OR three consecutive same-degree roots)\n            if (x.degree != next_x.degree) or \\\n               (next_x.sibling is not None and next_x.sibling.degree == x.degree):\n                prev_x = x\n                x = next_x\n            # Case 3  4 (two consecutive same-degree roots)\n            else:\n                self.step_counter += 1 # key comparison\n                if x.key = next_x.key:\n                    x.sibling = next_x.sibling\n                    self.step_counter += 1 # sibling pointer change\n                    self._link(next_x, x)\n                else:\n                    if prev_x is None:\n                        self.head = next_x\n                    else:\n                        prev_x.sibling = next_x\n                    self.step_counter += 1 # sibling pointer change\n                    self._link(x, next_x)\n                    x = next_x\n            next_x = x.sibling\n\n    def insert(self, key):\n        \"\"\"Inserts a key into the heap and returns the node pointer.\"\"\"\n        h_prime = BinomialHeap()\n        node = Node(key)\n        h_prime.head = node\n        self.meld(h_prime)\n        return node\n\n    def find_min_node(self):\n        \"\"\"Finds the node with the minimum key in the root list.\"\"\"\n        y = None\n        x = self.head\n        if x is None:\n            return None, None\n        \n        min_val = x.key\n        y = x\n        prev_y = None\n        prev_x = x\n        x = x.sibling\n        \n        while x is not None:\n            self.step_counter += 1 # scan advance\n            self.step_counter += 1 # key comparison\n            if x.key  min_val:\n                min_val = x.key\n                y = x\n                prev_y = prev_x\n            prev_x = x\n            x = x.sibling\n        return y, prev_y\n\n    def extract_min(self):\n        \"\"\"Extracts the node with the minimum key.\"\"\"\n        min_node, prev_min_node = self.find_min_node()\n        if min_node is None:\n            return None\n\n        # Remove min_node from the root list\n        if prev_min_node is None:\n            self.head = min_node.sibling\n        else:\n            prev_min_node.sibling = min_node.sibling\n        self.step_counter += 1 # sibling pointer change\n        \n        # Create a new heap from the children of the extracted min\n        h_prime = BinomialHeap()\n        \n        # Reverse the list of children\n        child = min_node.child\n        reversed_child_list_head = None\n        while child is not None:\n            self.step_counter += 1 # scan advance\n            next_child = child.sibling\n            child.sibling = reversed_child_list_head\n            self.step_counter += 1 # sibling pointer change\n            child.parent = None\n            self.step_counter += 1 # parent-child unlink\n            reversed_child_list_head = child\n            child = next_child\n        \n        h_prime.head = reversed_child_list_head\n        self.meld(h_prime)\n        return min_node.key\n\n    def decrease_key(self, p, new_key):\n        \"\"\"Decreases the key of node p to new_key.\"\"\"\n        p.key = new_key\n        y = p\n        z = y.parent\n        \n        while z is not None and y.key  z.key:\n            self.step_counter += 1 # key comparison\n            # Key swap\n            y.key, z.key = z.key, y.key\n            self.step_counter += 1 # key swap (counted as 1 primitive)\n            y = z\n            z = y.parent\n        \n        if z is not None: # Account for the final failed comparison\n            self.step_counter += 1\n\n    def delete(self, p):\n        \"\"\"Deletes the node p from the heap.\"\"\"\n        self.decrease_key(p, float('-inf'))\n        self.extract_min()\n\n    def get_size(self):\n        \"\"\"Computes the number of nodes in the heap.\"\"\"\n        if self.head is None:\n            return 0\n        size = 0\n        curr = self.head\n        while curr:\n            size += (1  curr.degree)\n            curr = curr.sibling\n        return size\n\ndef solve():\n    \"\"\"Main function to run test cases and generate final output.\"\"\"\n    test_cases = [\n        # (initial_keys, key_to_delete)\n        ([7, 3, 17, 24, 1, 8, 12, 30, 25, 2, 5, 16, 9, 14, 4], 16),\n        # (initial_keys, key_to_delete)\n        ([10, 20, 5, 30], 5),\n        # (initial_keys, key_to_delete)\n        ([42], 42),\n        # Case 4 requires special setup\n        \"case4\",\n        # (initial_keys, key_to_delete)\n        (list(range(1, 101)), 57),\n    ]\n\n    # Amortized bound constants\n    A = 20\n    B = 20\n\n    results = []\n\n    for i, case in enumerate(test_cases):\n        heap = BinomialHeap()\n        node_pointers = {}\n        p_to_delete = None\n        keys_to_delete_val = -1\n        \n        if case == \"case4\":\n            h1 = BinomialHeap()\n            h1_keys = [50, 40, 60]\n            for key in h1_keys: h1.insert(key)\n            \n            h2 = BinomialHeap()\n            h2_keys = [15, 70, 65, 55, 45]\n            for key in h2_keys:\n                node = h2.insert(key)\n                node_pointers[key] = node\n\n            heap = h1\n            heap.meld(h2)\n\n            initial_keys = h1_keys + h2_keys\n            keys_to_delete_val = 65\n            p_to_delete = node_pointers[keys_to_delete_val]\n        else:\n            initial_keys, keys_to_delete_val = case\n            for key in initial_keys:\n                node = heap.insert(key)\n                node_pointers[key] = node\n            p_to_delete = node_pointers[keys_to_delete_val]\n\n        n = heap.get_size()\n        \n        # --- Perform deletion and validation ---\n        # 1. Reset counter and call delete\n        heap.reset_counter()\n        heap.delete(p_to_delete)\n        s = heap.step_counter\n\n        # 2. Correctness check\n        extracted_keys = []\n        original_counter = heap.step_counter\n        heap.reset_counter() # Don't count validation steps\n        \n        while heap.head is not None:\n            extracted_keys.append(heap.extract_min())\n\n        heap.step_counter = original_counter # Restore counter if needed\n\n        expected_sorted = sorted(initial_keys)\n        expected_sorted.remove(keys_to_delete_val)\n        \n        correctness_ok = (extracted_keys == expected_sorted)\n        \n        # 3. Amortized bound check\n        log_n = np.log2(max(1, n))\n        bound = A * np.ceil(log_n) + B\n        bound_ok = (s = bound)\n        \n        results.append(correctness_ok and bound_ok)\n\n    # Final print statement in the exact required format\n    print(f\"[{','.join(map(str, results)).lower()}]\")\n\nsolve()\n\n```", "id": "3216452"}]}