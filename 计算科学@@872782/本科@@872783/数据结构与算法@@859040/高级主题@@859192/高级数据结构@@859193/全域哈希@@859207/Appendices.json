{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方法就是亲自动手实践。我们从一个看似简单直观的哈希函数族 $h_a(x) = (ax) \\pmod m$ 开始。这个练习将引导你通过严谨的数学分析，揭示其在特定条件下的弱点，从而深刻理解为什么“全域性”是构建健壮哈希表的关键且并非平凡的属性。[@problem_id:3281273]", "problem": "给定一个大小为 $m$ 的哈希表和一个键的全域 $U = \\{0, 1, 2, \\dots, m-1\\}$。考虑一个由乘数 $a$ 参数化的哈希函数族 $\\mathcal{H}$，其中 $a$ 是从 $\\{0, 1, 2, \\dots, m-1\\}$ 中均匀随机选择的。对于每一个 $a \\in \\{0, 1, 2, \\dots, m-1\\}$，哈希函数 $h_a : U \\to \\{0, 1, \\dots, m-1\\}$ 定义为\n$$\nh_a(x) \\triangleq (a \\cdot x) \\bmod m.\n$$\n如果对于任意不同的 $x, y \\in U$，碰撞概率 $\\Pr_{h \\sim \\mathcal{H}}[h(x) = h(y)]$ 至多为 $1/m$，则称该哈希函数族是全域的（universal）。你的任务是通过明确找出一对不同的键 $x \\neq y$，使得其碰撞概率超过 $1/m$，来证明上述函数族 $\\mathcal{H}$ 不是全域的，并给出一个对于通用 $m$ 寻找此类键对的系统方法。\n\n仅使用哈希函数族、碰撞的核心定义以及模运算和线性同余的基本性质作为出发点，对特定表大小 $m = 36$ 执行以下操作：\n\n- 从第一性原理出发，推导对于任意不同 $x, y \\in U$ 的碰撞概率 $\\Pr_{a}[h_a(x) = h_a(y)]$ 的表达式，该表达式用 $m$ 和差值 $d \\triangleq (x - y) \\bmod m$ 表示。\n- 基于该表达式，设计一种系统性的搜索方法，该方法在给定 $m$ 的情况下，能找出一对不同的键 $x \\neq y$，使其碰撞概率严格大于 $1/m$。用 $m$ 的结构特性来描述你的方法。\n- 将你的方法应用于 $m=36$ 的情况，选择具体的 $x, y \\in U$ 来最大化该函数族中的碰撞概率。\n- 计算你所选的 $x, y$ 的精确碰撞概率。将最终答案表示为单个最简分数。不要四舍五入，也不要包含任何单位。\n\n你的最终答案必须只是那个最简分数。", "solution": "该问题陈述是算法分析领域一个有效的、良构的数学问题。我们将给出一个完整的解答。\n\n问题要求我们证明哈希函数族 $\\mathcal{H} = \\{h_a | a \\in \\{0, 1, \\dots, m-1\\}\\}$（其中 $h_a(x) \\triangleq (a \\cdot x) \\bmod m$）不是一个全域哈希函数族。一个哈希函数族被定义为全域的，如果对于来自全域 $U$ 的任意一对不同键 $x, y$，碰撞的概率不大于 $1/m$，即 $\\Pr_{h \\in \\mathcal{H}}[h(x) = h(y)] \\le 1/m$。在我们的情况下，随机选择哈希函数 $h$ 对应于从集合 $\\{0, 1, \\dots, m-1\\}$ 中均匀随机选择参数 $a$。\n\n首先，我们为两个不同的键 $x, y \\in U = \\{0, 1, \\dots, m-1\\}$ 推导碰撞概率的一般表达式。当且仅当 $h_a(x) = h_a(y)$ 时，发生碰撞。\n$$\n(a \\cdot x) \\bmod m = (a \\cdot y) \\bmod m\n$$\n这等价于 $m$ 整除差值 $(a \\cdot x) - (a \\cdot y)$。用模运算的语言来说，这表示为一个线性同余方程：\n$$\na \\cdot x - a \\cdot y \\equiv 0 \\pmod{m}\n$$\n$$\na \\cdot (x - y) \\equiv 0 \\pmod{m}\n$$\n令 $d \\triangleq (x - y) \\bmod m$。由于 $x$ 和 $y$ 是不同的且属于 $\\{0, 1, \\dots, m-1\\}$，差值 $x-y$ 是一个在范围 $[-(m-1), m-1]$ 内的非零整数。因此，$d$ 是一个在范围 $\\{1, 2, \\dots, m-1\\}$ 内的非零整数。该同余方程变为：\n$$\na \\cdot d \\equiv 0 \\pmod{m}\n$$\n我们需要在集合 $\\{0, 1, \\dots, m-1\\}$ 中找到 $a$ 的解的数量。这是初等数论中的一个标准问题。形式为 $ax \\equiv b \\pmod{n}$ 的线性同余方程对 $x$ 有解，当且仅当 $\\gcd(a, n)$ 整除 $b$。若有解，则模 $n$ 恰好有 $\\gcd(a, n)$ 个解。在我们的例子中，同余方程是 $a \\cdot d \\equiv 0 \\pmod{m}$，我们要求解的是 $a$。$a$ 的解的数量由 $\\gcd(d, m)$ 给出。\n\n为严谨起见，令 $g = \\gcd(d, m)$。同余方程为 $ad \\equiv 0 \\pmod m$。这等价于 $m \\mid ad$。两边除以 $g$，我们得到 $(m/g) \\mid a(d/g)$。由于 $\\gcd(d/g, m/g) = 1$，根据欧几里得引理，我们必有 $(m/g) \\mid a$。因此，$a$ 必须是 $m/g$ 的倍数。在集合 $\\{0, 1, \\dots, m-1\\}$ 中，$a$ 的可能值为：\n$$\n0 \\cdot \\frac{m}{g}, 1 \\cdot \\frac{m}{g}, 2 \\cdot \\frac{m}{g}, \\dots, (g-1) \\cdot \\frac{m}{g}\n$$\n这样的 $a$ 值恰好有 $g = \\gcd(d, m)$ 个。\n\n参数 $a$ 是从 $m$ 个可能性中均匀随机选择的。因此，碰撞的概率是导致碰撞的 $a$ 的选择数量与 $a$ 的总选择数量之比：\n$$\n\\Pr_{a}[h_a(x) = h_a(y)] = \\frac{\\text{Number of solutions for } a}{\\text{Total choices for } a} = \\frac{\\gcd(d, m)}{m} = \\frac{\\gcd((x-y) \\bmod m, m)}{m}\n$$\n这就是推导出的碰撞概率表达式。\n\n接下来，我们设计一个系统方法来找出一对键 $x, y$，使其碰撞概率超过 $1/m$。全域性条件要求 $\\Pr \\le 1/m$，这可以转化为：\n$$\n\\frac{\\gcd(d, m)}{m} \\le \\frac{1}{m}\n$$\n这可以简化为 $\\gcd(d, m) \\le 1$。由于最大公约数总是一个正整数，这意味着我们必须有 $\\gcd(d, m) = 1$。要使该函数族是全域的，这个条件必须对所有可能的 $d = (x-y) \\bmod m$ 的值都成立，而 $d$ 的取值范围是集合 $\\{1, 2, \\dots, m-1\\}$。根据定义，对于所有 $d \\in \\{1, 2, \\dots, m-1\\}$ 都有 $\\gcd(d, m) = 1$ 的条件成立，当且仅当 $m$ 是一个素数。\n\n如果 $m$ 是一个合数，那么必然存在至少一个整数 $k \\in \\{2, \\dots, m-1\\}$ 是 $m$ 的因子。对于这样的 $k$，我们有 $\\gcd(k, m) = k > 1$。\n这提供了我们的系统方法：\n1. 如果 $m$ 是合数，找到 $m$ 的一个真因子 $k$（即除了 $1$ 和 $m$ 之外的因子）。\n2. 选择一对不同的键 $x, y \\in U$，使得 $(x-y) \\bmod m = k$。一个简单的选择是 $x=k$ 和 $y=0$。由于 $k \\in \\{2, \\dots, m-1\\}$，所以 $x$ 和 $y$ 都是 $U$ 中的有效不同键。\n3. 对于这对键，碰撞概率为 $\\frac{\\gcd(k, m)}{m} = \\frac{k}{m}$，因为 $k > 1$，所以这个概率严格大于 $\\frac{1}{m}$。这证明了对于任何合数 $m$，该函数族都不是全域的。\n\n为了最大化碰撞概率，我们需要在 $d \\in \\{1, 2, \\dots, m-1\\}$ 的范围内最大化 $\\gcd(d, m)$。当 $d | m$ 时，$\\gcd(d, m)$ 的最大可能值是 $m$ 的最大真因子。这个值等于 $m/p$，其中 $p$ 是 $m$ 的最小素因子。因此，我们应该选择 $d$ 为这个最大的真因子。\n\n现在我们将此方法应用于 $m=36$ 的具体情况。\n数字 $m=36$ 是一个合数。其素因数分解为 $2^2 \\cdot 3^2$。$36$ 的真因子集合是 $\\{2, 3, 4, 6, 9, 12, 18\\}$。\n为了最大化碰撞概率，我们需要选择 $d = (x-y) \\bmod 36$ 以使 $\\gcd(d, 36)$ 最大化。对于 $d \\in \\{1, \\dots, 35\\}$，$\\gcd(d, 36)$ 的最大值是 $36$ 的最大真因子。$36$ 的最小素因子是 $2$，所以最大真因子是 $36/2 = 18$。\n因此，我们应该选择 $d=18$。\n\n我们选择一对键 $(x, y)$ 使得 $(x-y) \\bmod 36 = 18$。最简单的选择是 $x=18$ 和 $y=0$。这两个键是不同的，并且都属于全域 $U = \\{0, 1, \\dots, 35\\}$。\n\n最后，我们计算在 $m=36$ 的情况下，这对选定的键 $(18, 0)$ 的精确碰撞概率。\n$$\n\\Pr_{a}[h_a(18) = h_a(0)] = \\frac{\\gcd(18-0, 36)}{36} = \\frac{\\gcd(18, 36)}{36}\n$$\n$18$ 和 $36$ 的最大公约数是 $18$。\n$$\n\\Pr = \\frac{18}{36} = \\frac{1}{2}\n$$\n这个 $1/2$ 的概率远大于全域性阈值 $1/36$，这明确地表明了这个哈希函数族不是全域的。最终答案是这个表示为最简分数的概率。", "answer": "$$\n\\boxed{\\frac{1}{2}}\n$$", "id": "3281273"}, {"introduction": "理论告诉我们，全域哈希能够抵御最坏情况的输入，但“眼见为实”。这个编程挑战要求你通过编写代码，实现并比较一个固定的确定性哈希函数与一个从全域哈希族中随机选择的哈希函数。你将通过经验性数据，直观地看到随机化是如何挫败对手并保证算法性能的。[@problem_id:3281122]", "problem": "您需要设计并实现一个完整的、可运行的程序，以经验性方式比较在使用固定确定性哈希函数与使用从一个全域哈希族中均匀随机选择的哈希函数时，链式哈希表中最坏情况搜索成本的分布。该程序必须计算最坏情况搜索成本的经验互补累积分布函数 (CCDF) 值，并为指定的测试套件输出这些值。本说明中的每个数学实体都使用 LaTeX 符号表示，以提供精确的含义。\n\n本作业所依据的基本定义和事实如下：\n\n- 使用独立链地址法的哈希表将来自一个域的一组键存储在一个包含 $m$ 个桶的数组中，其中每个桶都保存一个映射到该桶的键的链表。对于键 $x$ 和哈希函数 $h$，桶索引为 $h(x) \\in \\{0,1,\\dots,m-1\\}$。\n- 在独立链地址法下，最坏情况搜索成本等于最长链的长度。设 $L_{\\max}$ 表示任意桶中键的最大数量。在独立链地址法下搜索任意键时，最坏情况时间与 $L_{\\max}$ 成正比。\n- 一个从域 $\\mathcal{U}$ 到 $\\{0,1,\\dots,m-1\\}$ 的哈希函数族 $\\mathcal{H}$ 被称为全域的（universal），如果对于任意不同的键 $x,y \\in \\mathcal{U}$，都有 $$\\Pr_{h \\sim \\mathcal{H}}[h(x) = h(y)] \\le \\frac{1}{m}.$$ 全域哈希在访问键之前从 $\\mathcal{H}$ 中均匀随机地选择一个 $h$。\n- 在简单均匀哈希假设 (SUHA) 下，对于任意固定的 $n$ 个不同键的集合和一个将每个键独立且均匀地映射到 $\\{0,1,\\dots,m-1\\}$ 的随机选择的哈希函数，任何固定桶 $i$ 的占用数 $X_i$ 服从参数为 $(n,p)$（其中 $p = \\frac{1}{m}$）的二项随机变量分布。在此模型中，标准的尾部界限（例如，独立指示器随机变量和的 Chernoff 界）表明，单个桶占用数的尾部概率会随着阈值偏离均值而呈指数级下降。因此，$m$ 个桶上的最大占用数 $L_{\\max}$ 会集中在其由 $n$、$m$ 和独立性效应决定的典型尺度周围。\n\n您的程序将经验性地估计 $L_{\\max}$ 在指定阈值下的 CCDF。对于给定的阈值 $t$，CCDF 值为 $$\\Pr[L_{\\max} \\ge t],$$ 估计为最大链长至少为 $t$ 的试验所占的比例。为分离确定性与全域性的影响：\n\n- 确定性哈希对所有试验使用固定的函数 $h(x) = x \\bmod m$。随机性仅在适用时来自于随机生成的输入键集。\n- 全域哈希使用族 $$h_{a,b}(x) = \\big((a \\cdot x + b) \\bmod p\\big) \\bmod m,$$ 其中 $p$ 是一个大于最大可能键值的素数，$a$ 从 $\\{1,2,\\dots,p-1\\}$ 中均匀选择，$b$ 从 $\\{0,1,\\dots,p-1\\}$ 中均匀选择。每次试验都独立抽取一对新的 $(a,b)$。\n\n键生成方案：\n\n- 随机键：从 $\\{0,1,\\dots,U-1\\}$ 中均匀随机生成 $n$ 个不同的键，其中 $U$ 是键域的一个指定上界，且 $U \\ge n$。\n- 针对确定性函数 $h(x) = x \\bmod m$ 的对抗性键：使用特定的集合 $$S = \\{r + k \\cdot m \\mid k \\in \\{0,1,\\dots,n-1\\}\\},$$ 其中 $r = 0$，这会强制所有键在确定性哈希函数下碰撞到同一个桶中。确保 $U \\ge r + (n-1) \\cdot m + 1$，以便所有键都在 $\\{0,1,\\dots,U-1\\}$ 范围内。\n\n实现约束：\n\n- 哈希表使用独立链地址法，最坏情况搜索成本以 $L_{\\max}$（即插入所有 $n$ 个键后的最大桶占用数）来衡量。\n- 在阈值 $\\{t_1,t_2,\\dots\\}$ 处的经验 CCDF 是通过运行指定数量的独立试验来计算的，每次试验都对全部 $n$ 个键进行哈希，形成桶占用数，并记录 $L_{\\max} \\ge t_j$ 是否成立。\n- 将经验概率表示为四舍五入到四位小数的十进制数。\n\n测试套件规范：\n\n运行以下情况以探究不同行为，包括良性路径的随机输入、确定性下的对抗性行为以及高负载因子：\n\n1. 情况 A (确定性，随机键)：$m = 64$，$n = 64$，$U = 2^{20}$，试验次数 $T = 2000$，阈值 $\\{3,5,7,9\\}$，确定性哈希 $h(x) = x \\bmod m$，键是 $\\{0,1,\\dots,U-1\\}$ 中 $n$ 个不同的均匀随机元素。\n\n2. 情况 B (全域性，随机键)：$m = 64$，$n = 64$，$U = 2^{20}$，素数 $p = 10^9 + 7$，试验次数 $T = 2000$，阈值 $\\{3,5,7,9\\}$，全域哈希 $h_{a,b}(x)$，键是 $\\{0,1,\\dots,U-1\\}$ 中 $n$ 个不同的均匀随机元素，每次试验使用新的 $(a,b)$。\n\n3. 情况 C (确定性，对抗性键)：$m = 64$，$n = 64$，$U = m \\cdot n + 1$，试验次数 $T = 100$，阈值 $\\{16,32,48,64\\}$，确定性哈希 $h(x) = x \\bmod m$，在每次试验中相同地使用键 $S = \\{0 + k \\cdot m \\mid k \\in \\{0,1,\\dots,n-1\\}\\}$。\n\n4. 情况 D (全域性，高负载下的随机键)：$m = 16$，$n = 256$，$U = 2^{20}$，素数 $p = 10^9 + 7$，试验次数 $T = 1000$，阈值 $\\{16,24,32,40,48\\}$，全域哈希 $h_{a,b}(x)$，每次试验使用新的 $(a,b)$，键是 $\\{0,1,\\dots,U-1\\}$ 中 $n$ 个不同的均匀随机元素。\n\n最终输出格式：\n\n- 您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表形式的结果。\n- 列表条目必须是按以下确切顺序连接的经验估计 CCDF 值（四舍五入到四位小数）：\n  - 情况 A 的阈值按升序排列，\n  - 其后是情况 B 的阈值按升序排列，\n  - 其后是情况 C 的阈值按升序排列，\n  - 其后是情况 D 的阈值按升序排列。\n- 例如，输出应类似于 $[\\text{A}_1,\\text{A}_2,\\text{A}_3,\\text{A}_4,\\text{B}_1,\\dots,\\text{D}_5]$，没有空格，所有条目都表示为四舍五入到四位小数的十进制数。", "solution": "我们解释用于比较的科学和算法基础，以及链式哈希表中经验互补累积分布函数 (CCDF) 值的计算方法。\n\n基本基础和定义：\n\n- 一个链式哈希表包含 $m$ 个桶。哈希过程将每个键 $x$ 映射到一个索引 $h(x) \\in \\{0,1,\\dots,m-1\\}$。插入 $n$ 个键后，桶 $i$ 的占用数是 $$X_i = \\left|\\{x \\text{ among the } n \\text{ keys} : h(x) = i\\}\\right|,$$ 并且最坏情况搜索成本（以比较次数为单位）与 $$L_{\\max} = \\max_{i \\in \\{0,1,\\dots,m-1\\}} X_i.$$ 成比例。\n\n- 负载因子定义为 $$\\alpha = \\frac{n}{m}.$$ 在均衡哈希下，一个典型的桶大约有 $\\alpha$ 个键。\n\n- 全域哈希从一个全域哈希族 $\\mathcal{H}$ 中均匀随机地选择一个 $h$，该族保证对于不同的键 $x \\ne y$，$$\\Pr_{h \\sim \\mathcal{H}}[h(x) = h(y)] \\le \\frac{1}{m}.$$ 一个经典的构造是 $$h_{a,b}(x) = \\big((a \\cdot x + b) \\bmod p\\big) \\bmod m,$$ 其中素数 $p > \\max(\\mathcal{U})$，$a$ 在 $\\{1,2,\\dots,p-1\\}$ 上均匀分布，$b$ 在 $\\{0,1,\\dots,p-1\\}$ 上均匀分布。\n\n- 简单均匀哈希假设 (SUHA) 将哈希建模为将每个键独立且均匀地映射到桶中，这意味着对于一个固定的包含 $n$ 个不同键的集合，每个桶 $i$ 的占用数 $X_i \\sim \\text{Binomial}(n, p)$，其中 $p = \\frac{1}{m}$。\n\n为什么全域性有帮助：\n\n- 在 SUHA 下，桶 $i$ 的平均占用数是 $$\\mu = \\mathbb{E}[X_i] = n \\cdot \\frac{1}{m} = \\alpha.$$ 诸如二项随机变量的 Chernoff 不等式等尾部界限表明，对于任何 $\\delta > 0$，\n  $$\\Pr[X_i \\ge (1+\\delta)\\mu] \\le \\left(\\frac{e^{\\delta}}{(1+\\delta)^{(1+\\delta)}}\\right)^{\\mu},$$\n  这表明超过均值的尾部概率呈指数级衰减。对 $m$ 个桶应用联合界可得\n  $$\\Pr\\left[L_{\\max} \\ge t\\right] = \\Pr\\left[\\bigcup_{i=0}^{m-1}\\{X_i \\ge t\\}\\right] \\le m \\cdot \\Pr[X_0 \\ge t],$$\n  因此，任何桶超过阈值 $t$ 的概率都可以使用单个桶的尾部概率来界定。对于诸如 $n = m$ 的情况，这表明 $L_{\\max}$ 集中在一个关于 $n$ 的缓慢增长函数周围（对于完全独立的哈希，已知典型尺度为 $\\Theta\\!\\left(\\frac{\\log n}{\\log \\log n}\\right)$）。\n\n- 使用固定函数 $h$ 的确定性哈希是脆弱的：如果对手在看到 $h$ 之后可以选择键，他可以让所有键都碰撞到同一个桶中，使得 $L_{\\max} = n$。相比之下，全域哈希在哈希之前随机抽取 $h$，从而在键不依赖于 $h$ 的情况下防止了这种对抗性集中。\n\n经验性方法论：\n\n- 我们通过对每种情况运行 $T$ 次独立试验来经验性地估计 $L_{\\max}$ 的 CCDF。在每次试验中，我们：\n  1. 根据情况的方案生成 $n$ 个不同键的集合 $S$：\n     - 随机方案：从 $\\{0,1,\\dots,U-1\\}$ 中不放回地均匀抽样大小为 $n$ 的集合 $S$。\n     - 针对 $h(x) = x \\bmod m$ 的对抗性方案：定义 $$S = \\{r + k \\cdot m \\mid k \\in \\{0,1,\\dots,n-1\\}\\},$$ 其中 $r = 0$，确保 $h(x)$ 将 $S$ 中的每个键映射到同一个桶。\n  2. 选择哈希函数：\n     - 确定性：使用 $h(x) = x \\bmod m$。\n     - 全域性：每次试验抽取新的 $(a,b)$ 并使用 $$h_{a,b}(x) = \\big((a \\cdot x + b) \\bmod p\\big) \\bmod m.$$\n  3. 通过对 $S$ 中的所有 $n$ 个键进行哈希并计算桶索引来计算占用数 $X_0,\\dots,X_{m-1}$。\n  4. 计算 $L_{\\max} = \\max_i X_i$ 并为该情况下的每个阈值 $t$ 记录指示符 $\\mathbf{1}\\{L_{\\max} \\ge t\\}$。\n- 在阈值 $t$ 处的经验 CCDF 是所有试验中 $\\mathbf{1}\\{L_{\\max} \\ge t\\}$ 的平均值，它通过大数定律估计 $\\Pr[L_{\\max} \\ge t]$。\n\n算法设计与复杂度：\n\n- 对于每次试验，对 $n$ 个键进行哈希并计算占用数的时间复杂度为 $O(n + m)$，使用数组或向量化计数。对于 $T$ 次试验，每种情况的时间是 $O(T(n + m))$，对于指定的规模是可行的。\n- 全域哈希使用模 $p$ 算术，并通过 $a$ 和 $b$ 引入随机性。选择素数 $p$ 为 $10^9 + 7$ 可确保在所有情况下 $p > U$，从而使映射是良定义的，并避免了模偏差。\n\n测试套件的解释：\n\n- 情况 A ($m = 64$, $n = 64$) 在确定性哈希和随机键下捕捉了一个良性场景：因为键是均匀随机的，并且 $h(x) = x \\bmod m$，所以余数接近均匀分布，一个固定桶的占用数分布类似于参数为 $p = \\frac{1}{m}$ 的二项分布，这类似于 SUHA。我们期望 $L_{\\max}$ 接近 $n=m$ 时的典型值，在像 $t \\in \\{3,5,7,9\\}$ 这样的阈值处有相对较小的上尾。\n\n- 情况 B 镜像了情况 A，但每次试验都使用全域哈希。因为我们是均匀随机地抽取 $h$，我们期望在 SUHA 下的占用行为与情况 A 非常相似，因此在相同阈值下的尾部概率也相似。微小的差异来自于精确的独立性结构和随机化来源。\n\n- 情况 C 是针对确定性的对抗性情况：所有键在 $h(x) = x \\bmod m$ 下都会碰撞，导致每次试验都确定性地得到 $L_{\\max} = n = 64$，因此在阈值 $t$ 处的 CCDF 对于所有 $t \\le n$ 等于 $1$，对于大于 $n$ 的 $t$ 等于 $0$。阈值 $\\{16,32,48,64\\}$ 展示了这种阶梯函数行为。\n\n- 情况 D 在全域哈希下测试高负载（$\\alpha = \\frac{n}{m} = \\frac{256}{16} = 16$）。平均桶占用数为 16，因此阈值 $\\{16,24,32,40,48\\}$ 探测了尾部越来越罕见的事件。在 SUHA 下，随着 $t$ 远大于 $\\alpha$，CCDF 值应该迅速减小。\n\n输出规范：\n\n- 程序打印单行，其中包含一个用方括号括起来的、逗号分隔的经验 CCDF 值列表，顺序完全如下：\n  - 情况 A 的阈值按升序排列，\n  - 情况 B 的阈值按升序排列，\n  - 情况 C 的阈值按升序排列，\n  - 情况 D 的阈值按升序排列。\n- 所有概率都是四舍五入到四位小数的十进制值，没有额外的文本或空格。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef hash_deterministic_x_mod_m(keys: np.ndarray, m: int) - np.ndarray:\n    \"\"\"Deterministic hash: h(x) = x mod m.\"\"\"\n    return keys % m\n\ndef hash_universal_axpb_mod_p_mod_m(keys: np.ndarray, m: int, p: int, rng: np.random.Generator) - np.ndarray:\n    \"\"\"Universal hash: h_{a,b}(x) = ((a*x + b) mod p) mod m, with fresh (a,b) per call.\"\"\"\n    # Draw a in {1,...,p-1}, b in {0,...,p-1}\n    a = rng.integers(1, p, dtype=np.int64)\n    b = rng.integers(0, p, dtype=np.int64)\n    # Compute ((a*keys + b) % p) % m safely with int64\n    # Use modular arithmetic to avoid overflow: Python ints are arbitrary precision, but numpy int64 is fine here.\n    hashed = (np.mod(a * keys + b, p)) % m\n    return hashed\n\ndef empirical_ccdf_Lmax(m: int,\n                        n: int,\n                        U: int,\n                        thresholds: np.ndarray,\n                        trials: int,\n                        mode: str,\n                        p: int | None,\n                        rng: np.random.Generator) - list[float]:\n    \"\"\"\n    Estimate CCDF P[L_max = t] at each threshold t via trials.\n    mode:\n      - 'deterministic_random': fixed h(x)=x mod m, random distinct keys\n      - 'deterministic_adversarial': fixed h(x)=x mod m, adversarial keys colliding to one bucket\n      - 'universal_random': universal hashing per trial, random distinct keys\n    p: prime modulus for universal hashing when needed\n    \"\"\"\n    tail_counts = np.zeros(len(thresholds), dtype=np.int64)\n\n    # Precompute adversarial key set if needed\n    if mode == 'deterministic_adversarial':\n        # Keys S = {0 + k*m | k=0..n-1}\n        # Ensure within [0, U-1]; Problem guarantees U = m*n + 1\n        keys_fixed = (np.arange(n, dtype=np.int64) * m) % U\n\n    for _ in range(trials):\n        if mode == 'deterministic_random':\n            # Sample n distinct keys uniformly from [0, U-1]\n            keys = rng.choice(U, size=n, replace=False).astype(np.int64)\n            buckets = hash_deterministic_x_mod_m(keys, m)\n        elif mode == 'deterministic_adversarial':\n            # Use fixed adversarial keys every trial\n            buckets = hash_deterministic_x_mod_m(keys_fixed, m)\n        elif mode == 'universal_random':\n            keys = rng.choice(U, size=n, replace=False).astype(np.int64)\n            buckets = hash_universal_axpb_mod_p_mod_m(keys, m, p, rng)\n        else:\n            raise ValueError(\"Unknown mode\")\n\n        # Count occupancies in m buckets\n        counts = np.bincount(buckets, minlength=m)\n        Lmax = int(counts.max())\n\n        # Update tail counts for all thresholds\n        tail_counts += (Lmax = thresholds).astype(np.int64)\n\n    # Convert to probabilities\n    probs = tail_counts / float(trials)\n    # Round to 4 decimals\n    return [float(f\"{prob:.4f}\") for prob in probs]\n\ndef solve():\n    rng = np.random.default_rng(seed=42)  # Fixed seed for reproducibility\n\n    # Define prime p for universal hashing\n    p = 1_000_000_007\n\n    # Define test cases from the problem statement.\n    # Each case specifies (m, n, U, thresholds, trials, mode)\n    test_cases = [\n        # Case A: deterministic, random keys\n        {\n            \"m\": 64,\n            \"n\": 64,\n            \"U\": 2**20,\n            \"thresholds\": np.array([3, 5, 7, 9], dtype=np.int64),\n            \"trials\": 2000,\n            \"mode\": \"deterministic_random\",\n            \"p\": None,\n        },\n        # Case B: universal, random keys\n        {\n            \"m\": 64,\n            \"n\": 64,\n            \"U\": 2**20,\n            \"thresholds\": np.array([3, 5, 7, 9], dtype=np.int64),\n            \"trials\": 2000,\n            \"mode\": \"universal_random\",\n            \"p\": p,\n        },\n        # Case C: deterministic, adversarial keys\n        {\n            \"m\": 64,\n            \"n\": 64,\n            \"U\": 64*64 + 1,\n            \"thresholds\": np.array([16, 32, 48, 64], dtype=np.int64),\n            \"trials\": 100,\n            \"mode\": \"deterministic_adversarial\",\n            \"p\": None,\n        },\n        # Case D: universal, random keys under heavy load\n        {\n            \"m\": 16,\n            \"n\": 256,\n            \"U\": 2**20,\n            \"thresholds\": np.array([16, 24, 32, 40, 48], dtype=np.int64),\n            \"trials\": 1000,\n            \"mode\": \"universal_random\",\n            \"p\": p,\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        m = case[\"m\"]\n        n = case[\"n\"]\n        U = case[\"U\"]\n        thresholds = case[\"thresholds\"]\n        trials = case[\"trials\"]\n        mode = case[\"mode\"]\n        p_mod = case[\"p\"]\n        probs = empirical_ccdf_Lmax(m=m, n=n, U=U, thresholds=thresholds, trials=trials, mode=mode, p=p_mod, rng=rng)\n        results.extend(probs)\n\n    # Final print statement in the exact required format: single line, comma-separated list in brackets, no spaces.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3281122"}, {"introduction": "全域哈希是许多高级数据结构的基石，例如需要多个哈希函数的布隆过滤器。在实际应用中，为了节省随机性，我们常常会寻找“捷径”来生成这些哈希函数。这个练习探讨了一种常见的捷径，并要求你分析其理论上的有效性，从而帮助你辨析成对独立与完全独立之间的微妙但至关重要的区别。[@problem_id:3281235]", "problem": "您正在设计一个具有 $m$ 位的布隆过滤器（BF），并希望对每个键 $x$ 使用 $k$ 个哈希位置。假设 $m = 2^r$（其中 $r$ 为某个整数），并考虑一个哈希函数族 $\\mathcal{H}$，其中的函数 $h : \\mathcal{U} \\to \\{0,1\\}^r$ 是 $2$-通用的（2-universal），这意味着对于任何不同的 $x,y \\in \\mathcal{U}$ 以及从 $\\mathcal{H}$ 中均匀随机选择的 $h$，碰撞概率满足 $\\Pr[h(x) = h(y)] \\leq 1/2^r$，并且对于任何 $x \\in \\mathcal{U}$，$h(x)$ 在 $\\{0,1\\}^r$ 上均匀分布。您从 $\\mathcal{H}$ 中独立抽样 $h_1,h_2 \\sim \\mathcal{H}$，并提议通过以下方式为每个 $x$ 生成 $k$ 个哈希值：取\n$g_1(x) = h_1(x)$，$g_2(x) = h_2(x)$，$g_3(x) = h_1(x) \\oplus h_2(x)$，然后通过对先前获得的值使用按位异或 $\\oplus$ 继续形成额外的值，目标是在 $\\{0,1\\}^r$ 中总共产生 $k$ 个哈希值，然后您将这些值解释为 $\\{0,\\dots,m-1\\}$ 中的索引。\n  \n从第一性原理出发，回想一下，布隆过滤器的假阳性分析假设：对于每个查询键 $y \\notin S$（其中 $S$ 是大小为 $n$ 的已插入键的集合），$k$ 个位置 $g_1(y),\\dots,g_k(y)$ 在 $\\{0,\\dots,m-1\\}$ 中是独立均匀的，并且表现为独立的抽样。这意味着在插入 $n$ 个键后，一个给定的位仍然为 $0$ 的概率约为 $\\left(1 - \\frac{1}{m}\\right)^{kn} \\approx e^{-kn/m}$，并且在独立性的理想化假设下，假阳性概率约为 $\\left(1 - e^{-kn/m}\\right)^k$。\n\n当 $h_1,h_2$ 从一个 $2$-通用族中独立选择且 $m = 2^r$ 时，以下哪个陈述最能描述上述基于 $\\oplus$ 的构造的有效性？\n\nA. 对于任何 $k$ 都有效，因为一个 $2$-通用族确保 $h_1$ 和 $h_2$ 的任何确定性函数都能产生 $k$ 个两两独立且均匀的哈希值，因此标准的布隆过滤器分析可以不变地应用。\n\nB. 它通常是无效的：仅使用两个独立的种子 $h_1,h_2$，集合 $\\{h_1,h_2,h_1 \\oplus h_2\\}$ 最多包含三个不同的函数，所有进一步的值都是前两个函数的确定性函数，这破坏了布隆过滤器分析中使用的独立性假设；对于 $k>3$，您甚至无法获得 $k$ 个不同的值。一个有理论支持的替代方案是定义 $g_i(x) = \\big(h_1(x) + i \\cdot h_2(x)\\big) \\bmod m$，它保留了均匀的边际分布，并产生标准的假阳性行为。\n\nC. 只要 $m = 2^r$ 就有效，因为在这种情况下 $\\oplus$ 与模 $m$ 加法重合，因此这 $k$ 个值保持独立和均匀。\n\nD. 仅当 $k \\leq 3$ 时有效，因为此时输出是均匀的，并且假阳性概率与使用 $k$ 个独立哈希函数的情况完全匹配。\n\nE. 如果您对每个键的 $k$ 个值进行随机排序（即，对每个键 $x$ 的值应用一个新的随机排列），它就会变得有效，这恢复了布隆过滤器分析所需的独立性。", "solution": "用户希望我分析一种为布隆过滤器生成哈希函数的提议方法，并评估关于其有效性的几个陈述。\n\n### 步骤 1：提取已知信息\n\n1.  **布隆过滤器参数**：一个具有 $m$ 位和 $k$ 个哈希函数的布隆过滤器。\n2.  **位数组大小**：$m = 2^r$，其中 $r$ 为某个整数。\n3.  **基础哈希函数**：一个哈希函数族 $\\mathcal{H}$，其函数为 $h : \\mathcal{U} \\to \\{0,1\\}^r$。\n4.  **$\\mathcal{H}$ 的属性**：\n    *   **2-通用性**：对于任意不同的 $x,y \\in \\mathcal{U}$ 和从 $\\mathcal{H}$ 中均匀随机选择的 $h$，$\\Pr[h(x) = h(y)] \\leq 1/2^r = 1/m$。\n    *   **均匀性**：对于任意 $x \\in \\mathcal{U}$，$h(x)$ 在 $\\{0,1\\}^r$ 上均匀分布。集合 $\\{0,1\\}^r$ 被解释为索引 $\\{0, \\dots, m-1\\}$。\n5.  **提议的哈希方案**：\n    *   从 $\\mathcal{H}$ 中独立且均匀地抽样两个函数 $h_1$ 和 $h_2$。\n    *   键 $x$ 的 $k$ 个哈希值是基于 $h_1(x)$ 和 $h_2(x)$ 生成的。\n    *   前三个值由 $g_1(x) = h_1(x)$，$g_2(x) = h_2(x)$ 和 $g_3(x) = h_1(x) \\oplus h_2(x)$ （按位异或）给出。\n    *   通过“继续对先前获得的值使用按位异或 $\\oplus$ 形成额外的值”来生成其他值。\n6.  **标准的布隆过滤器分析（作为背景）**：\n    *   假设对于任何键， $k$ 个哈希位置是独立且均匀随机的。\n    *   在插入 $n$ 个键后，得出近似的假阳性概率为 $(1 - e^{-kn/m})^k$。\n\n### 步骤 2：使用提取的已知信息进行验证\n\n*   **科学基础**：该问题在计算机科学领域，特别是在数据结构和算法方面，有充分的理论基础。通用哈希、布隆过滤器以及减少哈希所需随机性的技术（例如使用两个哈希函数生成 k 个哈希）都是标准主题。所提出的方案是此类技术的一种变体。所有概念在数学和计算上都有明确的定义。\n*   **适定性**：该问题是适定的。它要求根据布隆过滤器分析的标准假设来评估一个特定的哈希方案。基础哈希函数的属性以及它们的组合方法都已明确说明，为分析提供了清晰的基础。短语“通过对先前获得的值使用按位异或继续形成额外的值”是分析的关键。通过从 $h_1(x)$ 和 $h_2(x)$ 开始并重复应用 $\\oplus$ 运算符可以为一个键 $x$ 生成的值集，是 $h_1(x)$ 和 $h_2(x)$ 在域 $GF(2)$ 上的所有线性组合的集合。这个集合是 $\\{0 \\cdot h_1(x) \\oplus 0 \\cdot h_2(x), 1 \\cdot h_1(x) \\oplus 0 \\cdot h_2(x), 0 \\cdot h_1(x) \\oplus 1 \\cdot h_2(x), 1 \\cdot h_1(x) \\oplus 1 \\cdot h_2(x)\\}$，可以简化为 $\\{0, h_1(x), h_2(x), h_1(x) \\oplus h_2(x)\\}$。这种解释在这种情况下是标准的，并不代表存在缺陷。\n*   **客观性**：问题陈述是客观的，并使用了精确的技术语言。\n*   **完整性和一致性**：设置是自洽且一致的。短语“通过对先前获得的值使用按位异或继续形成额外的值”是分析的关键。通过从 $h_1(x)$ 和 $h_2(x)$ 开始并重复应用 $\\oplus$ 运算符可以为一个键 $x$ 生成的值集，是 $h_1(x)$ 和 $h_2(x)$ 在域 $GF(2)$ 上的所有线性组合的集合。这个集合是 $\\{0 \\cdot h_1(x) \\oplus 0 \\cdot h_2(x), 1 \\cdot h_1(x) \\oplus 0 \\cdot h_2(x), 0 \\cdot h_1(x) \\oplus 1 \\cdot h_2(x), 1 \\cdot h_1(x) \\oplus 1 \\cdot h_2(x)\\}$，可以简化为 $\\{0, h_1(x), h_2(x), h_1(x) \\oplus h_2(x)\\}$。这种解释在这种情况下是标准的，并不代表存在缺陷。\n*   **无其他缺陷**：该问题不违反任何其他有效性标准。\n\n### 步骤 3：结论与行动\n\n该问题有效。我将继续进行分析和求解。\n\n### 推导与分析\n\n该问题要求评估一个方案，该方案使用来自一个 2-通用族的两个独立基础哈希函数 $h_1, h_2$ 为一个键 $x$ 生成 $k$ 个哈希值。哈希值通过按位异或运算生成。令 $a = h_1(x)$ 和 $b = h_2(x)$。由于 $h_1$ 和 $h_2$ 是从一个 $h(x)$ 在 $\\{0,1\\}^r$ 上均匀分布的族中独立选择的，因此 $a$ 和 $b$ 可被视为在 $\\{0,1\\}^r$ 上的独立、均匀的随机变量。\n\n提议的哈希值为 $g_1(x)=a$，$g_2(x)=b$，$g_3(x)=a \\oplus b$，依此类推。任何通过对先前值进行异或运算生成的后续值，仍将是 $a$ 和 $b$ 在二元域 $GF(2)$ 上的线性组合。由 $\\{a, b\\}$ 张成的 $GF(2)$ 上的向量空间是 $\\{0, a, b, a \\oplus b\\}$。该空间最多包含四个不同的元素。如果我们想要不同的非零哈希值，我们最多只能获得三个：$a$、$b$ 和 $a \\oplus b$（假设 $a, b$ 非零且 $a \\neq b$，这种情况以高概率发生）。\n\n**结论 1：对 $k$ 的限制**\n该方案不能生成超过 3 个不同的非零哈希值。因此，对于任何期望的 $k>3$，该方案存在根本性缺陷，因为它甚至无法产生所需数量的不同哈希位置。\n\n现在，让我们分析 $k \\le 3$ 情况下的属性，使用 $g_1(x)=a$，$g_2(x)=b$ 和 $g_3(x)=a \\oplus b$。标准的布隆过滤器分析假设给定键的 $k$ 个哈希值是均匀且相互独立的。\n\n**属性 1：均匀性**\n*   $g_1(x) = h_1(x)$：根据问题定义，在 $\\{0,1\\}^r$ 上是均匀的。\n*   $g_2(x) = h_2(x)$：根据问题定义，在 $\\{0,1\\}^r$ 上是均匀的。\n*   $g_3(x) = h_1(x) \\oplus h_2(x)$：为了证明这是均匀的，我们计算它对于任何值 $z \\in \\{0,1\\}^r$ 的概率。\n    $$ \\Pr[g_3(x) = z] = \\Pr[h_1(x) \\oplus h_2(x) = z] = \\Pr[h_1(x) = z \\oplus h_2(x)] $$\n    由于 $h_1$ 和 $h_2$ 是独立的：\n    $$ \\Pr[h_1(x) = z \\oplus h_2(x)] = \\sum_{y \\in \\{0,1\\}^r} \\Pr[h_1(x) = z \\oplus y \\text{ and } h_2(x) = y] $$\n    $$ = \\sum_{y \\in \\{0,1\\}^r} \\Pr[h_1(x) = z \\oplus y] \\Pr[h_2(x) = y] $$\n    由于两者都是均匀的，概率为 $1/m = 1/2^r$：\n    $$ = \\sum_{y \\in \\{0,1\\}^r} \\left(\\frac{1}{m}\\right) \\left(\\frac{1}{m}\\right) = m \\cdot \\frac{1}{m^2} = \\frac{1}{m} $$\n    因此，$g_3(x)$ 也是均匀分布的。生成的哈希值具有均匀的边际分布。\n\n**属性 2：独立性**\n标准分析要求 $k$ 个哈希值是*相互独立*的。让我们检查 $k=3$ 的情况。这些值是 $g_1(x), g_2(x), g_3(x)$。它们是相互独立的吗？\n不，因为根据定义 $g_3(x) = g_1(x) \\oplus g_2(x)$。这是一种确定性关系。如果知道了 $g_1(x)$ 和 $g_2(x)$ 的值，那么 $g_3(x)$ 的值就完全确定了。这违反了相互独立的假设。对于相互独立性，我们需要对于任何三元组 $(v_1,v_2,v_3)$，都有 $\\Pr[g_1(x)=v_1, g_2(x)=v_2, g_3(x)=v_3] = \\Pr[g_1(x)=v_1]\\Pr[g_2(x)=v_2]\\Pr[g_3(x)=v_3] = (1/m)^3$。然而，在我们的方案中：\n$$ \\Pr[g_1(x)=v_1, g_2(x)=v_2, g_3(x)=v_3] = \\begin{cases} \\Pr[g_1(x)=v_1, g_2(x)=v_2] = 1/m^2  \\text{如果 } v_3 = v_1 \\oplus v_2 \\\\ 0  \\text{如果 } v_3 \\neq v_1 \\oplus v_2 \\end{cases} $$\n由于 $0 \\neq (1/m)^3$，这些值不是相互独立的。\n\n**结论 2：独立性假设不成立**\n提议的方案违反了标准布隆过滤器假阳性概率分析所需的相互独立性假设。这意味着公式 $(1 - e^{-kn/m})^k$ 对此方案不是一个有效的近似。哈希位置之间的依赖性将导致一个不同的，并且通常更高的假阳性率。\n\n### 逐项分析\n\n**A. 这个陈述是不正确的。**\n1.  它不适用于“任何 $k$”。如上所示，不可能生成超过 3 个不同的非零哈希值。\n2.  虽然函数 $g_1, g_2, g_3$ 确实是两两独立的，但标准的布隆过滤器分析要求*相互*独立，而这一点不成立。两两独立不是一个充分条件。\n因此，此选项是**不正确**的。\n\n**B. 这个陈述提供了一个准确而全面的批判。**\n1.  它正确地指出该方案“通常是无效的”。\n2.  它正确地指出了生成的函数集很小，并且对于 $k3$，无法获得 $k$ 个不同的值。\n3.  它正确地指出确定性关系“破坏了独立性假设”。\n4.  它正确地指出了一个众所周知且经过理论分析的替代构造，通常称为“双重哈希”或 Kirsch-Mitzenmacher 优化，已知其性能非常接近理想的独立模型。\n因此，此选项是**正确**的。\n\n**C. 这个陈述是不正确的。**\n它的前提是错误的。按位异或（$\\oplus$）与整数模 $2^r$ 加法不是同一个操作。例如，对于 $r=2$, $m=4$。令 $a=1$（二进制 $01$）和 $b=2$（二进制 $10$）。那么 $a \\oplus b = 01_2 \\oplus 10_2 = 11_2 = 3$。然而，$(a+b) \\pmod 4 = (1+2) \\pmod 4 = 3$。这个例子碰巧成立。让我们试试另一个。令 $a=1, b=1$。那么 $a \\oplus b = 1 \\oplus 1 = 0$，但是 $(a+b) \\pmod 4 = 2$。这两个操作是不同的。此外，即使操作相同，这些值仍然不是独立的，因为 $g_3$ 将是 $g_1$ 和 $g_2$ 的确定性函数。\n因此，此选项是**不正确**的。\n\n**D. 这个陈述是不正确的。**\n虽然它正确地指出了 $k$ 的上限以及单个输出是均匀的，但其关于假阳性概率的关键论断是错误的。如前所述，这些函数不是相互独立的。这种缺乏独立性改变了假阳性的概率结构。查询键的所有 $k$ 个位都被设置的概率不再是单个概率的乘积，因此假阳性概率不会“完全匹配”理想情况。众所周知，它实际上是不同的（并且更差）。\n因此，此选项是**不正确**的。\n\n**E. 这个陈述是不正确的。**\n问题在于哈希函数*值*之间的统计依赖性，而不是分配给它们的索引。对于一个给定的键 $x$，哈希位置的集合是 $\\{h_1(x), h_2(x), h_1(x) \\oplus h_2(x)\\}$。对这三个值用作数组索引的顺序进行排列，并不能改变其中一个值是另外两个值的异或这一事实。在过滤器数组中探测的 `k` 个位置的集合是相同的，与排列无关；这种依赖性是值集合本身固有的。\n因此，此选项是**不正确**的。", "answer": "$$\\boxed{B}$$", "id": "3281235"}]}