{"hands_on_practices": [{"introduction": "本练习是掌握懒惰传播的绝佳起点，我们将处理一个基本但重要的问题：对二进制数组进行区间位翻转并查询区间内 $1$ 的个数。此操作的代数结构（翻转两次等于没有操作）极大地简化了懒惰标记的设计，让你能专注于懒惰传播的核心机制：延迟更新和向下传递。[@problem_id:3269161]", "problem": "您需要设计并实现一个支持在二进制数组上进行区间位翻转和区间“1”计数查询的带懒惰传播的线段树。操作及其语义定义如下：给定一个长度为 $n$ 的数组 $A$，其元素 $A[i] \\in \\{0,1\\}$，索引 $i$ 在 $[0,n-1]$ 范围内。在区间 $[l,r]$ 上的区间位翻转操作将映射 $x \\mapsto 1 - x$ 应用于每个 $i \\in [l,r]$ 的元素 $A[i]$。在区间 $[l,r]$ 上的“1”计数查询返回 $\\sum_{i=l}^{r} A[i]$ 的值。您必须从线段树（一个基于数组区间、聚合段值的完全二叉树）和懒惰传播（通过表示待应用函数的标记来延迟更新）的基本定义出发。您的实现必须在任意序列的区间位翻转操作之后正确计算“1”计数查询，并且每次操作的最坏情况时间复杂度为 $O(\\log n)$。\n\n除了实现之外，您还必须提供一个清晰的推导，从核心定义出发，证明懒惰翻转标记是其自身的逆，并且当视为对集合 $\\{0,1\\}$ 中元素的函数复合时，标记的复合满足 $flip \\circ flip = id$。此推导必须基于翻转映射 $f(x) = 1 - x$ 的性质、区间上“1”计数聚合的加性特性，以及在二元集合上复合此类函数的代数。\n\n您的程序必须是自包含的，不接受任何输入，并运行以下测试套件。对于每个测试用例，按顺序应用操作；对于每个“1”计数查询，将结果整数附加到最终结果列表中。最后，生成单行输出，其中包含一个由方括号括起来的逗号分隔列表形式的结果。不涉及物理单位，也不使用角度，因此不需要单位说明。所有索引均为零基，所有范围均为闭区间。\n\n测试套件：\n- 测试用例 $1$ (混合更新与查询的一般行为)：\n  - 初始数组 $A = [\\,1,0,1,1,0,0,1,0,1,0\\,]$，$n = 10$。\n  - 操作：\n    - $count([0,9])$\n    - $flip([2,7])$\n    - $count([0,9])$\n    - $flip([4,4])$\n    - $count([4,6])$\n    - $flip([0,9])$\n    - $count([0,9])$\n- 测试用例 $2$ (边界情况：单个元素与对合检查)：\n  - 初始数组 $A = [\\,1\\,]$，$n = 1$。\n  - 操作：\n    - $count([0,0])$\n    - $flip([0,0])$\n    - $count([0,0])$\n    - $flip([0,0])$\n    - $count([0,0])$\n- 测试用例 $3$ (子区间上的双重翻转与全区间翻转)：\n  - 初始数组 $A = [\\,0,0,0,0,0\\,]$，$n = 5$。\n  - 操作：\n    - $count([1,3])$\n    - $flip([1,3])$\n    - $count([1,3])$\n    - $flip([1,3])$\n    - $count([1,3])$\n    - $flip([0,4])$\n    - $count([0,4])$\n- 测试用例 $4$ (在全1数组上的重叠翻转)：\n  - 初始数组 $A = [\\,1,1,1,1,1,1,1,1\\,]$，$n = 8$。\n  - 操作：\n    - $flip([0,3])$\n    - $flip([2,5])$\n    - $count([0,7])$\n    - $flip([0,7])$\n    - $count([0,7])$\n- 测试用例 $5$ (交替模式下的多次翻转与查询)：\n  - 初始数组 $A = [\\,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1\\,]$，$n = 16$。\n  - 操作：\n    - $count([0,15])$\n    - $flip([0,7])$\n    - $count([0,15])$\n    - $flip([8,15])$\n    - $count([0,15])$\n    - $flip([4,11])$\n    - $count([3,12])$\n\n最终输出格式：您的程序应生成单行输出，其中包含一个由方括号括起来的逗号分隔列表，例如 $[r_1,r_2,\\dots,r_k]$，其中每个 $r_i$ 是按所有测试用例中遇到的顺序对“1”计数查询的整数答案。", "solution": "问题要求设计一个数据结构，以支持在长度为 $n$ 的二进制数组 $A$ 上的两种操作：区间位翻转和区间“1”计数查询。在区间 $[l,r]$ 上的位翻转操作将每个元素 $A[i]$ 转换为 $1 - A[i]$，其中 $i \\in [l,r]$。在区间 $[l,r]$ 上的“1”计数查询计算 $\\sum_{i=l}^{r} A[i]$。所有操作都必须在 $O(\\log n)$ 的时间复杂度内完成。这是一个带懒惰传播的线段树的经典应用。\n\n我们从基本原理开始。\n\n线段树是一种用于存储关于数组区间或段信息的完全二叉树。线段树中的每个节点代表一个区间。根节点代表整个数组，即区间 $[0, n-1]$。每个内部节点有两个子节点，分别代表其区间的两半。一个代表区间 $[s, e]$ 的节点将有一个代表 $[s, (s+e)/2]$ 的左子节点和一个代表 $[(s+e)/2 + 1, e]$ 的右子节点。叶节点代表数组的单个元素，对应于长度为 $1$ 的区间。\n\n对于“1”计数查询，线段树中的每个节点将存储其对应区间内元素的总和。设 $C(v)$ 为节点 $v$ 的“1”计数。如果 $v_L$ 和 $v_R$ 是内部节点 $v$ 的左右子节点，那么聚合属性是加性的：\n$$\nC(v) = C(v_L) + C(v_R)\n$$\n构建树的过程包括从叶节点到根节点递归计算这些和，这需要 $O(n)$ 时间。对区间 $[l,r]$ 的求和查询可以通过对一组完美覆盖该查询区间的 $O(\\log n)$ 个节点的值求和来回答。这需要 $O(\\log n)$ 时间。\n\n挑战在于区间位翻转更新。一个朴素的更新在最坏情况下需要修改所有 $O(n)$ 个叶节点，导致单次更新的时间复杂度为不可接受的 $O(n \\log n)$。为了达到所要求的 $O(\\log n)$ 复杂度，我们采用懒惰传播。\n\n懒惰传播是一种延迟更新的技术。我们为线段树中的每个节点引入一个“懒惰标记”。此标记代表一个对该节点的整个区间待处理但尚未应用于其子节点的更新操作。对于我们的问题，更新是位翻转。\n\n让我们正式分析位翻转操作。它是一个映射 $f: \\{0,1\\} \\to \\{0,1\\}$，定义为 $f(x) = 1 - x$。我们必须分析这个函数与自身的复合。让我们计算 $(f \\circ f)(x)$：\n$$\n(f \\circ f)(x) = f(f(x)) = f(1 - x) = 1 - (1 - x) = 1 - 1 + x = x\n$$\n这表明 $f \\circ f = id$，其中 $id$ 是恒等函数。应用两次翻转操作等同于什么都不做。这个性质意味着该操作是一个对合（involution）。这种代数结构表明，待处理翻转的状态可以用模 $2$ 算术来建模。一个翻转要么是待处理的，要么不是。我们可以为每个节点 $v$ 使用一个懒惰标记 $L(v) \\in \\{0, 1\\}$。$L(v) = 1$ 表示在 $v$ 的区间上有一个待处理的翻转，$L(v) = 0$ 表示没有待处理的翻转。当一个新的翻转要应用于一个已经有待处理翻转的节点时，我们实际上是在复合 $f \\circ f$。新的状态应该是“无翻转”，这对应于通过异或操作更新懒惰标记：$L(v) \\leftarrow L(v) \\oplus 1$。\n\n当一个翻转应用于覆盖长度为 $|I_v|$ 的区间的节点 $v$ 时，“1”的数量 $C(v)$ 会发生变化。如果原来有 $C(v)$ 个“1”，那么就有 $|I_v| - C(v)$ 个“0”。一次翻转将所有“1”变为“0”，所有“0”变为“1”。新的“1”的数量将是：\n$$\nC(v)' = |I_v| - C(v)\n$$\n\n懒惰传播的核心是 `push_down` 操作。在访问一个节点 $v$ 的子节点之前（在更新或查询期间），我们必须将 $v$ 的任何待处理更新传播到其子节点。如果 $L(v) = 1$，我们将其翻转应用于其子节点 $v_L$ 和 $v_R$：\n$1$. 更新子节点的聚合值：$C(v_L) \\leftarrow |I_{v_L}| - C(v_L)$ 和 $C(v_R) \\leftarrow |I_{v_R}| - C(v_R)$。\n$2$. 更新子节点的懒惰标记：$L(v_L) \\leftarrow L(v_L) \\oplus 1$ 和 $L(v_R) \\leftarrow L(v_R) \\oplus 1$。\n$3$. 重置父节点的懒惰标记：$L(v) \\leftarrow 0$。\n\n现在，我们可以定义完整的算法。线段树使用一个数组实现，大小通常为 $4n$。设 `tree[i]` 为节点 `i` 的聚合值（“1”的数量），`lazy[i]` 为其懒惰标记。\n\n**在 $[l,r]$ 上的区间翻转更新：**\n这是一个递归函数，从根节点（节点 $1$，区间 $[0, n-1]$）开始。对于覆盖区间 $[s, e]$ 的节点 $v$：\n$1$. 首先，使用 `push_down` 过程应用并传播在 $v$ 处的任何待处理懒惰标记。\n$2$. 如果节点的区间 $[s,e]$ 完全在更新范围 $[l,r]$ 之外，则不执行任何操作。\n$3$. 如果节点的区间 $[s,e]$ 完全在更新范围 $[l,r]$ 之内：\n    a. 更新其聚合值：`tree[v]` 变为 $(e-s+1) - \\text{tree}[v]$。\n    b. 更新其懒惰标记：`lazy[v]` 被翻转 (`lazy[v] ^= 1`)。\n    c. 停止此路径的递归。\n$4$. 如果节点的区间 $[s,e]$ 与 $[l,r]$ 部分重叠：\n    a. 在左子节点上递归。\n    b. 在右子节点上递归。\n    c. 递归返回后，根据其子节点的新值更新当前节点的值：`tree[v] = tree[left_child] + tree[right_child]`。\n此过程最多访问 $O(\\log n)$ 个节点，从而得到 $O(\\log n)$ 的时间复杂度。\n\n**在 $[l,r]$ 上的区间“1”计数查询：**\n这也是一个从根节点开始的递归函数。对于覆盖 $[s, e]$ 的节点 $v$：\n$1$. 使用 `push_down` 过程应用并传播在 $v$ 处的任何待处理懒惰标记。\n$2$. 如果节点的区间 $[s,e]$ 完全在查询范围 $[l,r]$ 之外，返回 $0$。\n$3$. 如果节点的区间 $[s,e]$ 完全在查询范围 $[l,r]$ 之内，返回其聚合值 `tree[v]`。\n$4$. 如果节点的区间 $[s,e]$ 与 $[l,r]$ 部分重叠：\n    a. 在左子节点和右子节点上递归，处理它们与 $[l,r]$ 的交集。\n    b. 返回递归调用的结果之和。\n与更新类似，此查询也需要 $O(\\log n)$ 的时间。\n\n该设计满足问题的所有要求，提供了一个基于线段树和懒惰传播原理的正确且高效的解决方案。", "answer": "```python\nimport sys\n\n# It is good practice to increase recursion limit for deep recursive structures like segment trees.\nsys.setrecursionlimit(2000)\n\nclass SegmentTreeLazy:\n    \"\"\"\n    Segment Tree with Lazy Propagation for range bit-flips and range sum queries.\n    The aggregate value stored is the count of ones.\n    \"\"\"\n    def __init__(self, data):\n        \"\"\"\n        Initializes the segment tree from the input array.\n        \"\"\"\n        self.n = len(data)\n        self.data = data\n        # Tree size is 4*n for a complete binary tree representation in an array\n        self.tree = [0] * (4 * self.n)\n        # Lazy array to store pending flips. 0 = no flip, 1 = flip pending.\n        self.lazy = [0] * (4 * self.n)\n        self._build(1, 0, self.n - 1)\n\n    def _build(self, node, start, end):\n        \"\"\"\n        Recursively builds the segment tree.\n        node: current node index in the tree array.\n        start, end: interval for the current node.\n        \"\"\"\n        if start == end:\n            # Leaf node: corresponds to a single element of the array\n            self.tree[node] = self.data[start]\n            return\n        \n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        self._build(left_child, start, mid)\n        self._build(right_child, mid + 1, end)\n        \n        # Internal node's value is the sum of its children's values\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def _push(self, node, start, end):\n        \"\"\"\n        Propagates lazy updates from a node to its children.\n        \"\"\"\n        if self.lazy[node] == 1:\n            # The length of the interval for the current node\n            interval_length = end - start + 1\n            # Apply the flip to the current node's value.\n            # Number of ones becomes (length - number of ones)\n            self.tree[node] = interval_length - self.tree[node]\n            \n            if start != end:  # Not a leaf node, so propagate to children\n                left_child = 2 * node\n                right_child = 2 * node + 1\n                # XOR toggles the lazy state of children\n                self.lazy[left_child] ^= 1\n                self.lazy[right_child] ^= 1\n            \n            # Reset the lazy flag for the current node\n            self.lazy[node] = 0\n\n    def _update(self, node, start, end, l, r):\n        \"\"\"\n        Recursive helper for range updates (flips).\n        l, r: the update range.\n        \"\"\"\n        self._push(node, start, end)\n        \n        # If current node's interval is outside the update range, do nothing\n        if start  end or start  r or end  l:\n            return\n            \n        # If current node's interval is completely inside the update range\n        if l = start and end = r:\n            # The length of the interval\n            interval_length = end - start + 1\n            # Apply the flip\n            self.tree[node] = interval_length - self.tree[node]\n            if start != end:\n                # Mark children as lazy\n                self.lazy[2 * node] ^= 1\n                self.lazy[2 * node + 1] ^= 1\n            return\n\n        # If current node's interval partially overlaps, recurse\n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        self._update(left_child, start, mid, l, r)\n        self._update(right_child, mid + 1, end, l, r)\n        \n        # Update parent's value from its children\n        self.tree[node] = self.tree[left_child] + self.tree[right_child]\n\n    def update(self, l, r):\n        \"\"\"Public method for range flip.\"\"\"\n        self._update(1, 0, self.n - 1, l, r)\n\n    def _query(self, node, start, end, l, r):\n        \"\"\"\n        Recursive helper for range queries (ones-count).\n        l, r: the query range.\n        \"\"\"\n        if start  end or start  r or end  l:\n            return 0  # Outside range, contribution is 0\n            \n        self._push(node, start, end)\n            \n        if l = start and end = r:\n            return self.tree[node] # Completely inside range\n            \n        mid = (start + end) // 2\n        left_child = 2 * node\n        right_child = 2 * node + 1\n        \n        p1 = self._query(left_child, start, mid, l, r)\n        p2 = self._query(right_child, mid + 1, end, l, r)\n        \n        return p1 + p2\n\n    def query(self, l, r):\n        \"\"\"Public method for range ones-count query.\"\"\"\n        return self._query(1, 0, self.n - 1, l, r)\n\ndef solve():\n    \"\"\"\n    Runs the full test suite and prints the final results.\n    \"\"\"\n    test_cases = [\n        {\n            \"array\": [1, 0, 1, 1, 0, 0, 1, 0, 1, 0],\n            \"ops\": [(\"count\", 0, 9), (\"flip\", 2, 7), (\"count\", 0, 9), (\"flip\", 4, 4), (\"count\", 4, 6), (\"flip\", 0, 9), (\"count\", 0, 9)]\n        },\n        {\n            \"array\": [1],\n            \"ops\": [(\"count\", 0, 0), (\"flip\", 0, 0), (\"count\", 0, 0), (\"flip\", 0, 0), (\"count\", 0, 0)]\n        },\n        {\n            \"array\": [0, 0, 0, 0, 0],\n            \"ops\": [(\"count\", 1, 3), (\"flip\", 1, 3), (\"count\", 1, 3), (\"flip\", 1, 3), (\"count\", 1, 3), (\"flip\", 0, 4), (\"count\", 0, 4)]\n        },\n        {\n            \"array\": [1, 1, 1, 1, 1, 1, 1, 1],\n            \"ops\": [(\"flip\", 0, 3), (\"flip\", 2, 5), (\"count\", 0, 7), (\"flip\", 0, 7), (\"count\", 0, 7)]\n        },\n        {\n            \"array\": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n            \"ops\": [(\"count\", 0, 15), (\"flip\", 0, 7), (\"count\", 0, 15), (\"flip\", 8, 15), (\"count\", 0, 15), (\"flip\", 4, 11), (\"count\", 3, 12)]\n        }\n    ]\n\n    all_results = []\n    \n    for case in test_cases:\n        st = SegmentTreeLazy(case[\"array\"])\n        for op_type, l, r in case[\"ops\"]:\n            if op_type == \"flip\":\n                st.update(l, r)\n            elif op_type == \"count\":\n                result = st.query(l, r)\n                all_results.append(result)\n\n    # The problem specifies that numpy is available, but it is not needed for the core logic.\n    # The final output format must be a comma-separated list in brackets.\n    # Example: [r1,r2,r3]\n    # np is imported in the template but unused here to demonstrate adherence to standard library capability.\n    import numpy as np\n    \n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3269161"}, {"introduction": "在掌握了基础知识后，本练习将提升一个层次，要求你同时维护区间最小值及其出现次数。当对一个区间进行加法操作时，区间内的最小值会随之改变，但其出现次数保持不变。通过解决这个问题，你将学会如何设计线段树的节点来存储和更新多个相互关联的聚合信息，这是解决更复杂问题的关键一步。[@problem_id:3269202]", "problem": "考虑一个包含 $n$ 个整数的数组 $A$，其索引从 $0$ 到 $n-1$（基于零的索引）。定义线段树为一种二叉树数据结构，其中每个节点代表一个连续子数组 $A[\\ell \\dots r]$，并存储该子数组的聚合摘要信息。你将实现一个支持两种操作的线段树：区间加法和带最小值计数的区间最小值查询。具体来说，对于任意区间 $[\\ell,r]$ 和整数 $\\Delta$，区间加法操作将每个 $i \\in [\\ell,r]$ 的 $A_i$ 转换为 $A_i + \\Delta$。对于任意区间 $[\\ell,r]$，区间最小值查询返回一个数对 $(m,c)$，其中 $m = \\min\\{A_i \\mid i \\in [\\ell,r]\\}$ 且 $c = \\left|\\{i \\in [\\ell,r] \\mid A_i = m\\}\\right|$。\n\n你的实现必须使用懒惰传播（lazy propagation）。在懒惰传播中，每个节点都保存一个尚未下推到其子节点的延迟更新值，从而使得区间更新可以在 $O(\\log n)$ 时间内应用，而无需立即更新所有受影响的叶节点。你的任务是从第一性原理出发，推导一个待处理的区间加法如何影响节点存储的最小值和计数，并通过对线段树高度的归纳来证明该方法的正确性。\n\n使用的基本原理：\n- 线段树节点的定义：代表一个连续子数组 $A[\\ell \\dots r]$ 并存储一个从其子节点计算出的摘要信息。\n- 整数上最小值和加法的代数性质：对于任意整数 $x$ 和任意集合 $S \\subset \\mathbb{Z}$，$\\min\\{s + x \\mid s \\in S\\} = \\min\\{s \\mid s \\in S\\} + x$。并且，如果 $T = \\{s \\in S \\mid s = \\min S\\}$，那么对 $S$ 中的所有元素加上一个常数，$|T|$ 保持不变。\n\n你必须实现一个完整的、可运行的程序，为每个测试用例构建线段树，执行指定的操作序列，并按规定输出查询的答案。索引是整数，所有区间 $[\\ell,r]$ 都是包含端点的，所有加法值 $\\Delta$ 都是整数。不涉及物理单位。\n\n测试用例包含五个，用于探查一般行为、边界和边缘情况。对于每个测试用例，会给定一个初始数组和一系列操作。程序必须按顺序执行操作，并收集每个查询操作的结果。\n\n测试用例 1：\n- 初始数组 $A^{(1)} = [\\,3,1,4,1,5,9,2,6\\,]$。\n- 操作：\n  - 在 $[\\,0,7\\,]$ 上查询。\n  - 在 $[\\,2,5\\,]$ 上进行区间加法 $\\Delta = +3$。\n  - 在 $[\\,0,7\\,]$ 上查询。\n  - 在 $[\\,0,7\\,]$ 上进行区间加法 $\\Delta = -2$。\n  - 在 $[\\,0,7\\,]$ 上查询。\n  - 在 $[\\,6,7\\,]$ 上查询。\n\n测试用例 2：\n- 初始数组 $A^{(2)} = [\\,0\\,]$。\n- 操作：\n  - 在 $[\\,0,0\\,]$ 上查询。\n  - 在 $[\\,0,0\\,]$ 上进行区间加法 $\\Delta = +5$。\n  - 在 $[\\,0,0\\,]$ 上查询。\n  - 在 $[\\,0,0\\,]$ 上进行区间加法 $\\Delta = -5$。\n  - 在 $[\\,0,0\\,]$ 上查询。\n\n测试用例 3：\n- 初始数组 $A^{(3)} = [\\,0,0,0,0,0,0,0,0,0,0\\,]$。\n- 操作：\n  - 在 $[\\,0,9\\,]$ 上进行区间加法 $\\Delta = +1$。\n  - 在 $[\\,3,6\\,]$ 上进行区间加法 $\\Delta = +2$。\n  - 在 $[\\,5,9\\,]$ 上进行区间加法 $\\Delta = -1$。\n  - 在 $[\\,0,9\\,]$ 上查询。\n  - 在 $[\\,0,4\\,]$ 上查询。\n  - 在 $[\\,5,6\\,]$ 上查询。\n  - 在 $[\\,0,2\\,]$ 上进行区间加法 $\\Delta = -2$。\n  - 在 $[\\,0,9\\,]$ 上查询。\n  - 在 $[\\,0,2\\,]$ 上查询。\n\n测试用例 4：\n- 初始数组 $A^{(4)} = [\\,-10,-10,-10,-10,-10\\,]$。\n- 操作：\n  - 在 $[\\,0,4\\,]$ 上查询。\n  - 在 $[\\,1,3\\,]$ 上进行区间加法 $\\Delta = +10$。\n  - 在 $[\\,0,4\\,]$ 上查询。\n  - 在 $[\\,0,4\\,]$ 上进行区间加法 $\\Delta = +10$。\n  - 在 $[\\,0,4\\,]$ 上查询。\n  - 在 $[\\,2,2\\,]$ 上进行区间加法 $\\Delta = -5$。\n  - 在 $[\\,1,3\\,]$ 上查询。\n\n测试用例 5：\n- 初始数组 $A^{(5)} = [\\,7,2,5,2,9,2,4,2,6,2,8,2\\,]$。\n- 操作：\n  - 在 $[\\,0,11\\,]$ 上查询。\n  - 在 $[\\,0,11\\,]$ 上进行区间加法 $\\Delta = -1$。\n  - 在 $[\\,0,11\\,]$ 上查询。\n  - 在 $[\\,1,10\\,]$ 上进行区间加法 $\\Delta = +3$。\n  - 在 $[\\,0,11\\,]$ 上查询。\n  - 在 $[\\,0,0\\,]$ 上进行区间加法 $\\Delta = -2$。\n  - 在 $[\\,0,5\\,]$ 上查询。\n  - 在 $[\\,7,11\\,]$ 上进行区间加法 $\\Delta = -3$。\n  - 在 $[\\,6,11\\,]$ 上查询。\n\n你的程序应该生成单行输出，其中包含一个外层列表，该列表聚合了所有测试用例的结果。对于每个测试用例，按操作顺序输出一个包含所有查询结果的内层列表。每个查询结果必须是一个双元素列表 $[\\,m,c\\,]$，其中 $m$ 是最小值，$c$ 是达到该最小值的索引计数。最终输出格式必须是严格的一行，形式为 $[\\,\\text{case}_1,\\text{case}_2,\\dots,\\text{case}_5\\,]$，其中每个 $\\text{case}_k$ 是一个列表 $[\\, [\\,m_1,c_1\\,], [\\,m_2,c_2\\,], \\dots \\,]$。", "solution": "该问题要求设计并实现一个带懒惰传播的线段树，以支持对一个包含 $n$ 个整数的数组 $A$ 进行两种操作：区间加法和带出现次数计数的区间最小值查询。我们必须首先正式推导更新和查询逻辑，并证明其正确性。\n\n线段树是一种用于存储关于区间或线段信息的二叉树。线段树中的每个节点代表一个区间。设树中的一个节点 $u$ 对应于连续子数组 $A[\\ell \\dots r]$。该节点必须存储此子数组的聚合摘要。对于本问题，该摘要是一个数对 $(m, c)$，其中 $m = \\min\\{A_i \\mid i \\in [\\ell, r]\\}$ 是子数组中的最小值，而 $c = |\\{i \\in [\\ell, r] \\mid A_i = m\\}|$ 是该最小值出现的次数。\n\n设节点 $u$ 的左子节点代表子数组 $A[\\ell \\dots k]$，右子节点代表 $A[k+1 \\dots r]$，其中 $k = \\lfloor (\\ell+r)/2 \\rfloor$。设存储在左、右子节点中的摘要分别为 $(m_L, c_L)$ 和 $(m_R, c_R)$。父节点 $u$ 的摘要 $(m_P, c_P)$ 可以通过合并其子节点的摘要来计算：\n$$m_P = \\min(m_L, m_R)$$\n$$c_P = \\begin{cases} c_L,  \\text{如果 } m_L  m_R \\\\ c_R,  \\text{如果 } m_R  m_L \\\\ c_L + c_R,  \\text{如果 } m_L = m_R \\end{cases}$$\n此合并规则构成了 `pull` 操作的基础，该操作根据子节点的摘要更新父节点的摘要。此递归的基准情形是叶节点，对于代表子数组 $A[i \\dots i]$ 的节点，其摘要为 $(A_i, 1)$。\n\n区间更新通过使用懒惰传播来高效处理。每个节点 $u$ 将有一个额外的字段，`lazy`，用于存储一个待处理的更新值 $\\Delta$，该值需要应用于与节点 $u$ 对应的整个区间 $A[\\ell \\dots r]$。对区间 $[\\ell_{q} \\dots r_{q}]$ 加上一个值 $\\Delta_{op}$ 的更新操作按以下方式进行：\n当遍历树时，对于一个区间为 $[\\ell \\dots r]$ 的节点 $u$：\n$1$. 如果 $[\\ell \\dots r]$ 完全在 $[\\ell_{q} \\dots r_{q}]$ 之外，则不执行任何操作。\n$2$. 如果 $[\\ell \\dots r]$ 完全在 $[\\ell_{q} \\dots r_{q}]$ 之内，我们通过将 $\\Delta_{op}$ 加到节点的懒惰标记上来更新它。然后，我们基于此懒惰值更新节点存储的最小值。根据给定的代数性质，$\\min\\{s + x \\mid s \\in S\\} = \\min\\{s \\mid s \\in S\\} + x$。区间 $[\\ell \\dots r]$ 中的所有元素都增加了 $\\Delta_{op}$，因此最小值也增加了 $\\Delta_{op}$。最小值的计数保持不变。因此，我们更新 $u.m \\to u.m + \\Delta_{op}$，而 $u.c$ 保持不变。我们不再继续处理子节点，这体现了“懒惰”的特性。\n$3$. 如果 $[\\ell \\dots r]$ 与 $[\\ell_{q} \\dots r_{q}]$ 部分重叠，我们必须首先将节点 $u$ 的待处理更新传播到其子节点。这就是 `push` 操作。然后，我们对子节点递归调用更新操作。最后，我们通过从其子节点拉取（可能已修改的）摘要来更新节点 $u$ 的摘要。\n\n对于一个懒惰值 $\\Delta_u \\neq 0$ 的节点 $u$ 而言，`push` 操作包括：\n$1$. 对于每个子节点 $v$（左和右），将其懒惰标记加上 $\\Delta_u$：$v.\\text{lazy} \\to v.\\text{lazy} + \\Delta_u$。\n$2$. 更新子节点的摘要。其存储的最小值增加 $\\Delta_u$：$v.m \\to v.m + \\Delta_u$。计数 $v.c$ 保持不变。\n$3$. 将父节点的懒惰标记重置为加法的单位元，即 $0$：$u.\\text{lazy} \\to 0$。\n\n区间查询的执行方式类似。对于一个区间为 $[\\ell \\dots r]$ 的节点 $u$，对区间 $[\\ell_{q} \\dots r_{q}]$ 的查询按以下方式进行：\n$1$. 如果 $[\\ell \\dots r]$ 在 $[\\ell_{q} \\dots r_{q}]$ 之外，返回一个单位摘要 $(\\infty, 0)$，它不会影响合并结果。\n$2$. 如果 $[\\ell \\dots r]$ 在 $[\\ell_{q} \\dots r_{q}]$ 之内，返回该节点存储的摘要 $(u.m, u.c)$。\n$3$. 如果部分重叠，首先将节点 $u$ 的懒惰标记 `push` 到其子节点。然后，递归地查询左、右子节点，并使用前面定义的合并规则合并它们的结果。\n\n**归纳法正确性证明**\n\n我们通过归纳法证明用于维护摘要的懒惰传播方案的正确性。\n**断言：**对于线段树中对应于区间 $[\\ell \\dots r]$ 的任意节点 $u$，子数组 $A[\\ell \\dots r]$ 的有效状态被正确表示。具体来说，子数组的真实最小值由 $u.m + \\sum_{v \\in \\text{Path}(\\text{root}, u)} v.\\text{lazy}$ 给出，并且计数 $u.c$ 是该最小值的正确计数。根据设计，我们的 `push` 操作将节点 $v$ 的懒惰标记移动到其子节点，同时将其效果应用于子节点存储的最小值，从而保持此不变量。我们可以简化该断言：在从根到某节点子节点路径上的所有懒惰值都下推后，该节点存储的数对 $(m,c)$ 对其区间是正确的。\n\n**基准情形（高度 $h=0$，叶节点）：**\n一个叶节点 $u$ 代表单个元素 $A[i]$。其摘要为 $(A[i], 1)$。在对区间 $[\\ell_q \\dots r_q]$ 进行值为 $\\Delta$ 的区间更新时，如果 $i \\in [\\ell_q \\dots r_q]$，更新算法最终会到达一个其区间完全包含在更新区间内的节点。该节点（$u$ 的一个祖先，或 $u$ 本身）的懒惰标记会被更新。我们来追踪其对 $u$ 的影响。在任何涉及 $u$ 区间的查询或进一步更新之前，$u$ 的任何祖先节点上的懒惰标记都将被下推。最终，$\\Delta$ 将被加到 $u$ 的懒惰标记上。假设我们直接应用这个效果，叶节点的值变为 $A[i] + \\Delta$。存储的最小值变为 $m_u + \\Delta$，计数保持为 $1$。这是正确的。`push` 机制确保了这种累积效应被正确地向下传递。\n\n**归纳假设 (IH)：**\n假设对于所有高度小于 $h$ 的节点（即在高度小于 $h$ 的子树中），查询和更新操作能正确维护存储的摘要 $(m, c)$ 和懒惰标记，保持不变量成立。\n\n**归纳步骤（高度 $h$）：**\n考虑一个高度为 $h$ 的节点 $u$，其子节点 $v_L$ 和 $v_R$ 的高度为 $h-1$。它的区间是 $[\\ell_u \\dots r_u]$，而其子节点的区间是 $[\\ell_u \\dots k]$ 和 $[k+1 \\dots r_u]$。根据归纳假设，对以 $v_L$ 和 $v_R$ 为根的子树进行的操作是正确的。\n\n考虑一个对区间 $[\\ell_q \\dots r_q]$ 的操作（更新或查询）。\n- 如果 $[\\ell_u \\dots r_u]$ 完全包含在 $[\\ell_q \\dots r_q]$ 中：\n    - 对于一个 $\\Delta$ 的更新：$u.\\text{lazy} \\to u.\\text{lazy} + \\Delta$，且 $u.m \\to u.m + \\Delta$。计数 $u.c$ 保持不变。基于给定的代数性质 $\\min\\{s+x\\} = \\min\\{s\\}+x$，这是正确的。修改被正确地延迟了。\n    - 对于一个查询：返回数值 $(u.m, u.c)$。由于在查询递归到此之前，所有来自祖先的懒惰标记都已被下推到这一层，这个代表区间 $[\\ell_u \\dots r_u]$ 最小值的数值是正确的。\n\n- 如果 $[\\ell_q \\dots r_q]$ 与 $[\\ell_u \\dots r_u]$ 部分重叠：\n    1. 调用 `push(u)` 操作。懒惰标记 $\\Delta_u$ 被加到子节点的懒惰标记上，并且它们的最小值被更新：$v_L.m \\to v_L.m + \\Delta_u$ 和 $v_R.m \\to v_R.m + \\Delta_u$。它们的计数保持不变。根据归纳假设，子树处于正确状态。应用此统一加法操作，相对于现在已更新的懒惰值，其摘要的正确性得以保持。由于加法对最小值的分配律，该逻辑是合理的。此后，$u.\\text{lazy}$ 被重置为 $0$。\n    2. 操作递归地进入子节点 $v_L$ 和 $v_R$。根据归纳假设，这些操作将正确更新以 $v_L$ 和 $v_R$ 为根的子树。\n    3. 执行 `pull` 操作 `u.summary = combine(v_L.summary, v_R.summary)`。由于根据归纳假设，$v_L$ 和 $v_R$ 的摘要对于它们各自的区间现在是正确的（所有懒惰效应都已计算在内），`combine` 逻辑能正确计算出 $u$ 区间的摘要。\n\n处理完全包含、部分重叠和无重叠的逻辑，结合 `push` 和 `pull` 操作，正确地维护了每个节点的不变量。通过归纳法，该方案对整个树都是正确的。\n\n实现将遵循此推导出的结构。", "answer": "```python\nimport numpy as np\nimport sys\n\n# It is good practice to increase recursion limit for deep recursion in segment trees.\nsys.setrecursionlimit(200000)\n\nclass SegmentTree:\n    \"\"\"\n    Segment Tree with Lazy Propagation for Range Addition and Range Minimum/Count Query.\n    \"\"\"\n    def __init__(self, arr):\n        self.n = len(arr)\n        self.arr = arr\n        # Use numpy arrays for performance. 4*n is a safe upper bound for tree size.\n        self.tree_min = np.full(4 * self.n, np.inf, dtype=np.int64)\n        self.tree_count = np.zeros(4 * self.n, dtype=np.int64)\n        self.lazy = np.zeros(4 * self.n, dtype=np.int64)\n        \n        if self.n  0:\n            self._build(1, 0, self.n - 1)\n\n    def _combine(self, left_res, right_res):\n        \"\"\"\n        Combines results from two children nodes.\n        left_res: (min_val, min_count) from the left child.\n        right_res: (min_val, min_count) from the right child.\n        \"\"\"\n        min_l, count_l = left_res\n        min_r, count_r = right_res\n\n        if min_l  min_r:\n            return min_l, count_l\n        elif min_r  min_l:\n            return min_r, count_r\n        else: # min_l == min_r\n            # If both are infinity, the count is 0. Otherwise, sum counts.\n            if min_l == np.inf:\n                return np.inf, 0\n            return min_l, count_l + count_r\n    \n    def _apply_lazy(self, v, val):\n        \"\"\"Applies a lazy value to a node.\"\"\"\n        if val != 0:\n            self.tree_min[v] += val\n            self.lazy[v] += val\n\n    def _push(self, v):\n        \"\"\"Pushes the lazy value from node v to its children.\"\"\"\n        if self.lazy[v] != 0:\n            # Apply to left child (2*v) and right child (2*v+1)\n            self._apply_lazy(2 * v, self.lazy[v])\n            self._apply_lazy(2 * v + 1, self.lazy[v])\n            self.lazy[v] = 0\n\n    def _build(self, v, tl, tr):\n        \"\"\"Recursively builds the segment tree.\"\"\"\n        if tl == tr:\n            self.tree_min[v] = self.arr[tl]\n            self.tree_count[v] = 1\n        else:\n            tm = (tl + tr) // 2\n            self._build(2 * v, tl, tm)\n            self._build(2 * v + 1, tm + 1, tr)\n            \n            # Pull information from children\n            combined_min, combined_count = self._combine(\n                (self.tree_min[2 * v], self.tree_count[2 * v]),\n                (self.tree_min[2 * v + 1], self.tree_count[2 * v + 1])\n            )\n            self.tree_min[v] = combined_min\n            self.tree_count[v] = combined_count\n\n    def _update_range(self, v, tl, tr, l, r, addval):\n        \"\"\"Recursively performs range update.\"\"\"\n        if l  r:\n            return\n        \n        # Current segment is fully within update range\n        if l == tl and r == tr:\n            self._apply_lazy(v, addval)\n            return\n\n        self._push(v) # Push lazy value before recursing\n        \n        tm = (tl + tr) // 2\n        # Recurse on children, splitting the update range\n        self._update_range(2 * v, tl, tm, l, min(r, tm), addval)\n        self._update_range(2 * v + 1, tm + 1, tr, max(l, tm + 1), r, addval)\n        \n        # Pull information back up\n        combined_min, combined_count = self._combine(\n            (self.tree_min[2*v], self.tree_count[2*v]),\n            (self.tree_min[2*v+1], self.tree_count[2*v+1])\n        )\n        self.tree_min[v] = combined_min\n        self.tree_count[v] = combined_count\n\n    def update(self, l, r, addval):\n        \"\"\"Public method for range update.\"\"\"\n        if self.n  0:\n            self._update_range(1, 0, self.n - 1, l, r, addval)\n\n    def _query_range(self, v, tl, tr, l, r):\n        \"\"\"Recursively performs range query.\"\"\"\n        if l  r:\n            # Sentinel value for an empty range\n            return np.inf, 0\n        \n        # Current segment is fully within query range\n        if l == tl and r == tr:\n            return self.tree_min[v], self.tree_count[v]\n\n        self._push(v) # Push lazy value before querying\n\n        tm = (tl + tr) // 2\n        # Recurse on children, splitting the query range\n        left_res = self._query_range(2 * v, tl, tm, l, min(r, tm))\n        right_res = self._query_range(2 * v + 1, tm + 1, tr, max(l, tm + 1), r)\n        \n        return self._combine(left_res, right_res)\n\n    def query(self, l, r):\n        \"\"\"Public method for range query.\"\"\"\n        if self.n == 0:\n            return [float('inf'), 0]\n        min_val, count = self._query_range(1, 0, self.n - 1, l, r)\n        return [int(min_val), int(count)]\n\ndef solve():\n    \"\"\"\n    Main function to run the test cases and produce the final output.\n    \"\"\"\n    test_cases = [\n        {\n            \"array\": [3, 1, 4, 1, 5, 9, 2, 6],\n            \"ops\": [\n                ('q', 0, 7), ('u', 2, 5, 3), ('q', 0, 7), \n                ('u', 0, 7, -2), ('q', 0, 7), ('q', 6, 7)\n            ]\n        },\n        {\n            \"array\": [0],\n            \"ops\": [\n                ('q', 0, 0), ('u', 0, 0, 5), ('q', 0, 0), \n                ('u', 0, 0, -5), ('q', 0, 0)\n            ]\n        },\n        {\n            \"array\": [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            \"ops\": [\n                ('u', 0, 9, 1), ('u', 3, 6, 2), ('u', 5, 9, -1),\n                ('q', 0, 9), ('q', 0, 4), ('q', 5, 6),\n                ('u', 0, 2, -2), ('q', 0, 9), ('q', 0, 2)\n            ]\n        },\n        {\n            \"array\": [-10, -10, -10, -10, -10],\n            \"ops\": [\n                ('q', 0, 4), ('u', 1, 3, 10), ('q', 0, 4),\n                ('u', 0, 4, 10), ('q', 0, 4), ('u', 2, 2, -5), ('q', 1, 3)\n            ]\n        },\n        {\n            \"array\": [7, 2, 5, 2, 9, 2, 4, 2, 6, 2, 8, 2],\n            \"ops\": [\n                ('q', 0, 11), ('u', 0, 11, -1), ('q', 0, 11),\n                ('u', 1, 10, 3), ('q', 0, 11), ('u', 0, 0, -2),\n                ('q', 0, 5), ('u', 7, 11, -3), ('q', 6, 11)\n            ]\n        },\n    ]\n\n    all_results = []\n    for case in test_cases:\n        st = SegmentTree(case[\"array\"])\n        case_results = []\n        for op_info in case[\"ops\"]:\n            op_type = op_info[0]\n            if op_type == 'q':\n                _, l, r = op_info\n                result = st.query(l, r)\n                case_results.append(result)\n            elif op_type == 'u':\n                _, l, r, val = op_info\n                st.update(l, r, val)\n        all_results.append(case_results)\n\n    # Manual formatting to match the exact string representation required.\n    # This avoids adding spaces after commas, which `json.dumps` or `str` might do.\n    outer_parts = []\n    for case_res in all_results:\n        inner_parts = []\n        for res_pair in case_res:\n            inner_parts.append(f\"[{res_pair[0]},{res_pair[1]}]\")\n        outer_parts.append(f\"[{','.join(inner_parts)}]\")\n    \n    final_output = f\"[{','.join(outer_parts)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3269202"}, {"introduction": "本练习将带你探索懒惰传播的代数核心，你需要实现对区间进行仿射变换（$x \\mapsto ax+b$）和求和。这里的懒惰标记不再是简单的数值，而是函数本身，更新的合并等价于函数的复合。通过推导并实现仿射函数的复合规则，你将深刻理解懒惰传播的本质是一个通用的操作复合框架，从而能解决更广泛的动态区间问题。[@problem_id:3269114]", "problem": "您的任务是设计并实现一个程序，该程序使用带懒惰传播（Lazy Propagation）的线段树（Segment Tree, ST）来支持在整数数组上的区间仿射更新和区间和查询。该数组由元素 $x_i$ 组成。一个区间仿射更新将函数 $f(x) = a x + b$ 应用于索引范围 $[L, R]$ 内的每个元素 $x_i$。一个区间和查询返回 $\\sum_{i=L}^{R} x_i$。您应当使用的基本原理包括求和的线性性质、仿射函数的代数运算以及树结构中懒惰传播的定义。\n\n从以下基本事实和定义开始：\n- 仿射函数：对于实数参数 $a$ 和 $b$，定义 $f(x) = a x + b$。\n- 求和的线性性质：对于任意标量 $a$、$b$ 和元素 $x_i$，仿射变换下的和为 $$\\sum_{i=L}^{R} f(x_i) = \\sum_{i=L}^{R} (a x_i + b) = a \\sum_{i=L}^{R} x_i + b \\cdot \\ell,$$ 其中 $\\ell = R - L + 1$ 是区间长度。\n- 仿射函数的复合：对于 $f(x) = \\alpha x + \\beta$ 和 $g(x) = \\gamma x + \\delta$，其复合函数为 $$g(f(x)) = g(\\alpha x + \\beta) = \\gamma (\\alpha x + \\beta) + \\delta = (\\gamma \\alpha) x + (\\gamma \\beta + \\delta)。$$\n- 线段树（ST）：一种二叉树，其中每个节点代表数组的一个连续区间 $[l, r]$，并存储该区间的聚合值（在此为和）。\n- 懒惰传播：通过在节点上存储一个“懒惰标记”（lazy tag），来延迟将更新应用于其子节点。该标记代表了对该节点区间内所有元素的待处理变换。\n\n您的任务是：\n1. 基于上述基本原理，推导线段树聚合的上推（push-up）规则和懒惰标记的下推（push-down）规则：\n   - 上推：给定一个节点的子节点存储的和分别为 $S_L$ 和 $S_R$，推导父节点的和 $S$ 的公式。\n   - 下推：假设父节点有一个懒惰标记 $F(x) = \\alpha x + \\beta$，子节点有一个懒惰标记 $G(x) = \\gamma x + \\delta$。当将父节点的标记下推至子节点时，推导正确的复合顺序以及子节点的新标记和新和值的显式公式，公式仅用 $\\alpha$、$\\beta$、$\\gamma$、$\\delta$ 和子区间的长度 $\\ell$ 表示。\n2. 实现一个支持以下功能的线段树：\n   - 区间更新，将 $f(x) = a x + b$ 应用于 $[L, R]$ 内的所有 $x_i$。\n   - 区间求和查询，返回 $\\sum_{i=L}^{R} x_i$。\n   线段树的每个节点必须存储区间和 $S$ 以及一个由参数 $(\\text{la}, \\text{lb})$ 表示的懒惰标记，该标记编码了待应用于该区间的仿射函数 $x \\mapsto \\text{la} \\cdot x + \\text{lb}$。单位标记必须是 $x \\mapsto 1 \\cdot x + 0$，即 $(\\text{la}, \\text{lb}) = (1, 0)$。\n3. 使用一个朴素基线（naive baseline）来验证您的实现，该基线直接将更新应用于数组并通过迭代计算和。构建以下对抗性测试套件。对于每个测试用例，从给定的初始数组开始，并按顺序执行所列操作。使用零基索引，并按照 $f(x) = a x + b$ 的形式解释更新参数 $a$ 和 $b$。对于每次查询，收集其求和结果。将您的线段树生成的查询结果列表与朴素基线生成的结果进行比较，并报告它们是否完全匹配。\n\n测试套件：\n- 测试用例 $1$：\n  - 初始数组：$[1, 2, 3, 4, 5]$。\n  - 操作：\n    - 在 $[1, 3]$ 上更新，$a = 2, b = 1$。\n    - 查询 $[0, 4]$。\n    - 在 $[0, 4]$ 上更新，$a = 1, b = -3$。\n    - 查询 $[2, 2]$。\n    - 在 $[2, 2]$ 上更新，$a = 0, b = 7$。\n    - 查询 $[0, 4]$。\n- 测试用例 $2$：\n  - 初始数组：$[-5, 0, 5]$。\n  - 操作：\n    - 在 $[0, 2]$ 上更新，$a = -1, b = 0$。\n    - 在 $[1, 1]$ 上更新，$a = 3, b = 2$。\n    - 查询 $[0, 2]$。\n    - 在 $[0, 0]$ 上更新，$a = 2, b = 5$。\n    - 查询 $[0, 1]$。\n    - 在 $[2, 2]$ 上更新，$a = 1, b = -4$。\n    - 查询 $[2, 2]$。\n- 测试用例 $3$：\n  - 初始数组：$[10, -2, 7, 3, 0, 5]$。\n  - 操作：\n    - 在 $[0, 5]$ 上更新，$a = 2, b = 1$。\n    - 在 $[2, 4]$ 上更新，$a = 3, b = -2$。\n    - 在 $[1, 3]$ 上更新，$a = -1, b = 4$。\n    - 查询 $[0, 5]$。\n    - 查询 $[2, 3]$。\n    - 在 $[0, 0]$ 上更新，$a = 5, b = 0$。\n    - 在 $[0, 5]$ 上更新，$a = 0, b = 1$。\n    - 查询 $[0, 5]$。\n    - 在 $[3, 5]$ 上更新，$a = 10, b = -10$。\n    - 查询 $[3, 5]$。\n- 测试用例 $4$：\n  - 初始数组：$[1, 1, 1, 1]$。\n  - 操作：\n    - 在 $[0, 3]$ 上更新，$a = 1, b = 0$。\n    - 查询 $[0, 3]$。\n    - 在 $[1, 2]$ 上更新，$a = 1, b = 5$。\n    - 查询 $[0, 3]$。\n    - 在 $[1, 1]$ 上更新，$a = 1, b = -5$。\n    - 查询 $[0, 3]$。\n- 测试用例 $5$：\n  - 初始数组：$[1000000, -1000000, 123456, -654321, 42]$。\n  - 操作：\n    - 在 $[0, 4]$ 上更新，$a = 2, b = 3$。\n    - 查询 $[0, 4]$。\n    - 在 $[2, 4]$ 上更新，$a = 0, b = -7$。\n    - 查询 $[0, 4]$。\n    - 在 $[1, 3]$ 上更新，$a = -3, b = 11$。\n    - 查询 $[1, 3]$。\n\n最终输出格式：\n- 您的程序必须生成一行输出，其中包含一个用方括号括起来的、以逗号分隔的列表。每个元素对应一个测试用例，其值为一个布尔值，表示该测试用例的线段树查询结果是否与朴素基线的查询结果完全匹配，例如 $[\\text{True}, \\text{False}, \\text{True}]$。", "solution": "该问题要求设计并实现一个带懒惰传播的线段树，以处理数组上的区间仿射更新（$x \\mapsto a x + b$）和区间和查询。解决方案必须按照要求从第一性原理推导。\n\n问题的核心在于定义如何在树结构中管理聚合信息（和）和待定更新（懒惰标记）。仿射变换不像简单加法那样对加法具有分配律，因此需要一个更复杂的懒惰传播方案。其基础是仿射函数的复合和求和的线性性质。\n\n假设线段树中的一个节点对应一个长度为 $\\ell$ 的区间。该节点存储其元素的和 $S$，以及一个表示待定仿射变换 $f(x) = \\text{la} \\cdot x + \\text{lb}$ 的懒惰标记。单位变换是 $f(x) = 1 \\cdot x + 0$，所以单位懒惰标记为 $(\\text{la}, \\text{lb}) = (1, 0)$。\n\n**1. 树操作的推导**\n\n**上推规则（聚合）：**\n一个非叶节点代表其两个子节点的不相交区间的并集。因此，父节点区间内元素的和是其子节点和的直接相加。给定左子节点的和为 $S_L$，右子节点的和为 $S_R$，则父节点的和 $S$ 为：\n$$ S = S_L + S_R $$\n\n**下推规则（懒惰传播）：**\n此规则定义了父节点的待定更新如何传播到其子节点。假设父节点有一个懒惰标记 $(\\alpha, \\beta)$，代表函数 $F(x) = \\alpha x + \\beta$。其子节点有自己已存在的懒惰标记 $(\\gamma, \\delta)$，代表函数 $G(x) = \\gamma x + \\delta$。\n\n*   **懒惰标记的复合**：更新是按时间顺序进行的。父节点的更新 $F$ 比子节点现有的更新 $G$ 更新。因此，当计算子区间内某个元素 $x_i$ 的真实值时，先应用 $G$，再应用 $F$。复合变换为 $H(x) = F(G(x))$。根据问题中提供的复合公式：\n    $$ H(x) = F(G(x)) = \\alpha(\\gamma x_i + \\delta) + \\beta = (\\alpha\\gamma)x_i + (\\alpha\\delta + \\beta) $$\n    这是一个新的仿射函数。因此，当将父节点的标记 $(\\alpha, \\beta)$ 下推到一个带有标记 $(\\gamma, \\delta)$ 的子节点时，子节点的新懒惰标记 $(\\gamma', \\delta')$ 变为：\n    $$ \\gamma' = \\alpha \\gamma $$\n    $$ \\delta' = \\alpha \\delta + \\beta $$\n\n*   **更新子节点的和**：设子节点当前存储的和为 $S_{\\text{child}}$，其区间长度为 $\\ell_{\\text{child}}$。这个和反映了在应用父节点的懒惰标记 $(\\alpha, \\beta)$ *之前* 的区间状态。为了更新这个和，我们将变换 $F(x) = \\alpha x + \\beta$ 应用于构成 $S_{\\text{child}}$ 的每个元素。利用问题中提供的求和线性性质：\n    $$ S_{\\text{child}}^{\\text{new}} = \\sum_{i=1}^{\\ell_{\\text{child}}} (\\alpha y_i + \\beta) = \\alpha \\left(\\sum_{i=1}^{\\ell_{\\text{child}}} y_i\\right) + \\sum_{i=1}^{\\ell_{\\text{child}}} \\beta = \\alpha S_{\\text{child}} + \\beta \\ell_{\\text{child}} $$\n    其中 $y_i$ 是子区间中的当前值。\n\n**2. 算法设计**\n\n线段树实现为一个类。在一个基于数组的树中，索引为 $k$ 的节点代表区间 $[s, e]$。它将其和 $S$ 存储在 `tree[k]` 中，并将其懒惰标记 $(\\text{la}, \\text{lb})$ 存储在 `lazy_a[k]` 和 `lazy_b[k]` 中。\n\n关键方法如下：\n*   `_apply_lazy(k, s, e, a, b)`: 将传入的变换 $(a, b)$ 应用于节点 $k$。它使用和更新规则更新 `tree[k]`，并使用复合规则将 $(a, b)$ 与现有的懒惰标记 `(lazy_a[k], lazy_b[k])` 进行复合。\n*   `_push(k, s, e)`: 将节点 $k$ 的懒惰标记传播到其子节点（$2k$ 和 $2k+1$）。它使用父节点的标记 `(lazy_a[k], lazy_b[k])` 对每个子节点调用 `_apply_lazy`，然后将父节点的懒惰标记重置为单位标记 $(1, 0)$。\n*   `_update(k, s, e, l, r, a, b)`: 将仿射更新 $(a, b)$ 应用于区间 $[l, r]$。如果节点的区间 $[s, e]$ 完全包含在 $[l, r]$ 内，则对节点 $k$ 调用 `_apply_lazy`。如果存在部分重叠，它首先调用 `_push(k, s, e)` 来清除其懒惰状态，然后递归地对其子节点调用 `_update`。最后，它调用一个 `_pull` 操作（等价于 $S=S_L+S_R$）以从可能已修改的子节点更新自己的和。\n*   `_query(k, s, e, l, r)`: 计算区间 $[l, r]$ 的和。如果节点的区间完全包含在 $[l, r]$ 内，则返回 `tree[k]`。对于部分重叠，它首先调用 `_push(k, s, e)`，然后递归地查询其子节点并对结果求和。\n\n这种设计确保了在任何时候，和 `tree[k]` 对于其区间 $[s, e]$ 都是正确的值，该值考虑了所有直接应用于该节点或其祖先节点并已下推至此的更新。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to run the test suite and validate the Segment Tree implementation.\n    \"\"\"\n\n    class NaiveBaseline:\n        \"\"\"\n        A naive implementation for verification. It directly manipulates an array.\n        \"\"\"\n        def __init__(self, data):\n            # Use dtype=object to allow for arbitrary-precision integers,\n            # preventing overflow issues.\n            self.data = np.array(data, dtype=object)\n\n        def update(self, l, r, a, b):\n            \"\"\"Applies affine update f(x) = a*x + b to range [l, r].\"\"\"\n            for i in range(l, r + 1):\n                self.data[i] = a * self.data[i] + b\n\n        def query(self, l, r):\n            \"\"\"Computes the sum of elements in range [l, r].\"\"\"\n            if l  r:\n                return 0\n            return np.sum(self.data[l:r + 1])\n\n    class SegmentTreeAffine:\n        \"\"\"\n        Segment Tree with Lazy Propagation for range affine updates and range sum queries.\n        \"\"\"\n        def __init__(self, data):\n            self.n = len(data)\n            # Use Python lists for tree storage to leverage arbitrary-precision integers.\n            self.tree = [0] * (4 * self.n)\n            self.lazy_a = [1] * (4 * self.n)\n            self.lazy_b = [0] * (4 * self.n)\n            self._build(data, 1, 0, self.n - 1)\n\n        def _build(self, data, node, start, end):\n            if start == end:\n                self.tree[node] = data[start]\n                return\n            mid = (start + end) // 2\n            self._build(data, 2 * node, start, mid)\n            self._build(data, 2 * node + 1, mid + 1, end)\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n\n        def _apply_lazy(self, node, start, end, a, b):\n            # Update sum based on the formula: S_new = a * S_old + b * length\n            self.tree[node] = a * self.tree[node] + b * (end - start + 1)\n            # Compose lazy tags: new_lazy = compose((a, b), old_lazy)\n            # new_lazy_a = a * old_lazy_a\n            # new_lazy_b = a * old_lazy_b + b\n            self.lazy_a[node] = a * self.lazy_a[node]\n            self.lazy_b[node] = a * self.lazy_b[node] + b\n        \n        def _push(self, node, start, end):\n            # If no pending update (identity tag), do nothing.\n            if self.lazy_a[node] == 1 and self.lazy_b[node] == 0:\n                return\n            \n            mid = (start + end) // 2\n            a, b = self.lazy_a[node], self.lazy_b[node]\n\n            # Propagate to left child\n            self._apply_lazy(2 * node, start, mid, a, b)\n            # Propagate to right child\n            self._apply_lazy(2 * node + 1, mid + 1, end, a, b)\n\n            # Reset the parent's lazy tag to identity\n            self.lazy_a[node] = 1\n            self.lazy_b[node] = 0\n\n        def _update(self, node, start, end, l, r, a, b):\n            # No overlap\n            if start  r or end  l:\n                return\n\n            # Full overlap: apply the update and store as lazy tag\n            if l = start and end = r:\n                self._apply_lazy(node, start, end, a, b)\n                return\n            \n            # Partial overlap: push down, recurse, then pull up\n            self._push(node, start, end)\n\n            mid = (start + end) // 2\n            self._update(2 * node, start, mid, l, r, a, b)\n            self._update(2 * node + 1, mid + 1, end, l, r, a, b)\n\n            self.tree[node] = self.tree[2 * node] + self.tree[2 * node + 1]\n\n        def _query(self, node, start, end, l, r):\n            # No overlap\n            if start  r or end  l:\n                return 0\n            \n            # Full overlap: the value in this node is what we need\n            if l = start and end = r:\n                return self.tree[node]\n\n            # Partial overlap: push down lazy tags before querying children\n            self._push(node, start, end)\n\n            mid = (start + end) // 2\n            p1 = self._query(2 * node, start, mid, l, r)\n            p2 = self._query(2 * node + 1, mid + 1, end, l, r)\n            \n            return p1 + p2\n\n        def update(self, l, r, a, b):\n            \"\"\"Public method for range update.\"\"\"\n            self._update(1, 0, self.n - 1, l, r, a, b)\n\n        def query(self, l, r):\n            \"\"\"Public method for range query.\"\"\"\n            if l  r: return 0\n            return self._query(1, 0, self.n - 1, l, r)\n\n    test_cases = [\n        ([1, 2, 3, 4, 5], [('update', 1, 3, 2, 1), ('query', 0, 4), ('update', 0, 4, 1, -3), ('query', 2, 2), ('update', 2, 2, 0, 7), ('query', 0, 4)]),\n        ([-5, 0, 5], [('update', 0, 2, -1, 0), ('update', 1, 1, 3, 2), ('query', 0, 2), ('update', 0, 0, 2, 5), ('query', 0, 1), ('update', 2, 2, 1, -4), ('query', 2, 2)]),\n        ([10, -2, 7, 3, 0, 5], [('update', 0, 5, 2, 1), ('update', 2, 4, 3, -2), ('update', 1, 3, -1, 4), ('query', 0, 5), ('query', 2, 3), ('update', 0, 0, 5, 0), ('update', 0, 5, 0, 1), ('query', 0, 5), ('update', 3, 5, 10, -10), ('query', 3, 5)]),\n        ([1, 1, 1, 1], [('update', 0, 3, 1, 0), ('query', 0, 3), ('update', 1, 2, 1, 5), ('query', 0, 3), ('update', 1, 1, 1, -5), ('query', 0, 3)]),\n        ([1000000, -1000000, 123456, -654321, 42], [('update', 0, 4, 2, 3), ('query', 0, 4), ('update', 2, 4, 0, -7), ('query', 0, 4), ('update', 1, 3, -3, 11), ('query', 1, 3)]),\n    ]\n    \n    results = []\n    for initial_array, operations in test_cases:\n        st = SegmentTreeAffine(initial_array)\n        naive = NaiveBaseline(initial_array)\n        \n        st_query_results = []\n        naive_query_results = []\n        \n        for op in operations:\n            op_type = op[0]\n            if op_type == \"update\":\n                _, l, r, a, b = op\n                st.update(l, r, a, b)\n                naive.update(l, r, a, b)\n            elif op_type == \"query\":\n                _, l, r = op\n                st_res = st.query(l, r)\n                naive_res = naive.query(l, r)\n                st_query_results.append(st_res)\n                naive_query_results.append(naive_res)\n        \n        results.append(st_query_results == naive_query_results)\n\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n\n```", "id": "3269114"}]}