{"hands_on_practices": [{"introduction": "掌握任何数据结构的第一步是能够准确地识别其结构。这个练习要求你将D元堆的定义转化为可执行的代码，不仅要验证给定数组是否为具有特定元数 $d$ 的堆，还要找出所有能使其成为合法最大堆的 $d$ 值。这项实践将迫使你深入理解基于数组的堆表示中父节点与子节点之间的索引关系，这是掌握D元堆的基石。[@problem_id:3225715]", "problem": "给定您几个由不同整数组成的有限序列。每个序列代表一个排列，并被解释为 $d$-叉堆的根树的层序序列化，其中 $d$ 是一个满足 $d  1$ 的整数。一个 $d$-叉堆是一棵根树，其中每个节点最多有 $d$ 个子节点，且最大堆属性要求对于每个节点，其键值大于或等于其所有子节点的键值。我们使用基于0索引的 $d$-叉堆的标准数组表示法：对于索引为 $i$ 的节点，其子节点占据索引 $d i + 1$ 到 $d i + d$，只要这些索引在数组的边界内。\n\n从根树、层序序列化和最大堆属性的基本定义出发，对于每个给定的长度为 $n$ 的序列 $A$，确定所有满足 $2 \\le d \\le n$ 的整数 $d$ 的集合，使得将 $A$ 解释为层序的 $d$-叉堆时，在整个树中都满足最大堆属性。该解释必须使用由索引定义的父子关系：对于每个满足 $0 \\le i \\le n-1$ 的索引 $i$，其子节点索引为 $j \\in \\{d i + 1, d i + 2, \\dots, d i + d\\}$ 且 $j  n$，最大堆属性要求对于所有这样的 $j$，都有 $A[i] \\ge A[j]$。\n\n您的程序必须处理以下测试序列集，其中每个序列都是其对应 $n$ 的 $\\{1,2,\\dots,n\\}$ 的一个排列：\n\n- 测试用例 1：$[1, 2, 3, 4, 5, 6, 7]$\n- 测试用例 2：$[7, 6, 5, 4, 3, 2, 1]$\n- 测试用例 3：$[9, 1, 8, 7, 2, 3, 4, 5, 6]$\n- 测试用例 4：$[9, 7, 8, 3, 5, 6, 2, 1, 4]$\n- 测试用例 5：$[2, 1]$\n- 测试用例 6：$[8, 5, 7, 4, 6, 3, 2, 1]$\n\n对于每个测试用例，您必须返回所有满足 $2 \\le d \\le n$ 的整数 $d$ 的列表，使得该序列是上述数组到树解释下的有效最大 $d$-叉堆。如果不存在这样的 $d$，则返回空列表。\n\n最终输出格式：您的程序应生成单行输出，包含一个用方括号括起来的逗号分隔列表形式的结果，其中每个元素对应一个测试用例，并且本身是一个不含空格的整数列表，每个测试用例的整数按升序排列（例如，对于三个测试用例，格式为 `[[2,3],[],[5]]`，但没有空格）。具体来说，打印的格式必须是像 `[[2,3],[],[5]]` 这样的单行。\n\n不适用任何物理单位或角度单位。所有答案均为指定格式的整数列表。输入是固定的；不要从标准输入读取。", "solution": "问题要求我们对于一个给定的长度为 $n$ 的整数序列 $A$，确定在 $2 \\le d \\le n$ 范围内的所有整数 $d$ 的集合，使得 $A$ 构成一个有效的最大 $d$-叉堆。验证过程必须遵循所提供的特定父子索引关系。\n\n让我们从基本原理开始。一个序列 $A$ 被解释为一棵根树的层序序列化。在使用基于0索引的 $d$-叉堆的标准数组表示法中，索引为 $i$ 的节点，其子节点位于索引 $di+1, di+2, \\dots, di+d$ 处。只有当子节点的索引在数组边界内（即 $j  n$）时，它才是树结构的一部分。\n\n最大堆属性规定，树中任何节点的键值必须大于或等于其所有子节点的键值。将其转换到数组表示法中，对于任何索引为 $i$ 的父节点及其任何有效索引为 $j$ 的子节点，必须满足条件 $A[i] \\ge A[j]$。\n\n为了解决这个问题，我们必须构建一个算法，来为给定的序列 $A$ 和给定的叉数 $d$ 验证此属性。一个系统性的方法是遍历所有可能是父节点的节点，并对照其所有存在的子节点检查堆属性。\n\n首先，我们必须确定数组中哪些节点可以是父节点。如果一个索引为 $i$ 的节点在数组边界内至少有一个子节点，那么它就是父节点。节点 $i$ 的第一个子节点的索引是 $di+1$。为了使这个子节点存在，我们需要 $di+1  n$。这个不等式可以重排为 $di  n-1$，这意味着 $i  (n-1)/d$。由于索引必须是整数，父节点的最大可能索引是 $\\lfloor (n-2)/d \\rfloor$。因此，我们只需要对索引 $i$ 在 $0 \\le i \\le \\lfloor (n-2)/d \\rfloor$ 范围内的节点检查堆属性。索引大于此值的节点保证是叶子节点，因为它们的第一个潜在子节点将位于索引 $n$ 或之外。\n\n这导出了一个直接的验证算法，我们称之为 `is_valid_heap(A, d)`。该函数将遍历从 $0$ 到 $\\lfloor (n-2)/d \\rfloor$ 的所有潜在父节点索引 $i$。对于每个父节点 $i$，它将接着遍历其潜在的子节点。节点 $i$ 的子节点索引由 $j = di+k$ 给出，其中 $k=1, 2, \\dots, d$。对于每个潜在的子节点索引 $j$，我们首先检查它是否在数组边界内（$j  n$）。如果在边界内，我们就验证最大堆条件：$A[i] \\ge A[j]$。如果在任何时候我们发现一对 $(i, j)$ 使得 $A[i]  A[j]$，那么最大堆属性就被违反了，序列 $A$ 不是一个有效的最大 $d$-叉堆。在这种情况下，我们的函数可以立即返回 `False`。如果循环完成而没有发现任何此类违规，这意味着该属性对所有父子对都成立，函数正确地返回 `True`。如果数组的长度 $n \\le 1$，那么对于任何 $d$，它都可被视为一个平凡的有效堆，因为没有父子关系需要检查。\n\n主要问题是为每个给定的序列 $A$ 找出所有有效的 $d$ 值。我们可以通过遍历指定范围 $2 \\le d \\le n$ 内的每个整数 $d$ 来实现这一点。对于每个 $d$，我们调用我们的验证函数 `is_valid_heap(A, d)`。如果它返回 `True`，我们就将 $d$ 添加到序列 $A$ 的有效叉数列表中。在检查完所有可能的 $d$ 值之后，这个列表将包含该序列的完整解。\n\n对问题陈述中提供的每个测试用例序列重复此过程。最终输出是这些结果汇集成的一个格式化列表。\n\n总的算法如下：\n1. 对于每个输入序列 $A$：\n2. 设 $n$ 为 $A$ 的长度。\n3. 初始化一个空列表 `valid_ds`，用于存储有效的叉数。\n4. 对于从 2 到 $n$（含）的每个整数 $d$：\n5.  a. 假设 $A$ 是一个有效的最大 $d$-叉堆（设置一个标志，例如 `is_heap = True`）。\n6.  b. 遍历从 $0$ 到 $\\lfloor (n-2)/d \\rfloor$ 的每个潜在父节点索引 $i$。\n7.  c. 对于每个父节点 $i$，遍历其子节点索引 $j = di+k$，其中 $k=1, 2, \\dots, d$。\n8.  d. 如果子节点索引 $j$ 超出边界（$j \\ge n$），我们可以跳出关于 $k$ 的内层循环，因为后续的子节点索引也必然超出边界。\n9.  e. 如果 $j  n$ 且 $A[i]  A[j]$，则堆属性被违反。设置 `is_heap = False` 并跳出当前 $d$ 的所有循环。\n10. f. 在检查完当前 $d$ 的所有父节点后，如果 `is_heap` 仍然是 `True`，则将 $d$ 追加到 `valid_ds` 中。\n11. 在遍历完所有 $d$ 之后，列表 `valid_ds` 包含序列 $A$ 的结果。\n12. 收集所有测试用例的 `valid_ds` 列表，并根据输出规范进行格式化。\n此方法是穷举性的，通过直接为每种可能性检查最大 $d$-叉堆的定义来保证正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the d-ary heap problem for the given test suite.\n    \"\"\"\n\n    test_cases = [\n        [1, 2, 3, 4, 5, 6, 7],\n        [7, 6, 5, 4, 3, 2, 1],\n        [9, 1, 8, 7, 2, 3, 4, 5, 6],\n        [9, 7, 8, 3, 5, 6, 2, 1, 4],\n        [2, 1],\n        [8, 5, 7, 4, 6, 3, 2, 1],\n    ]\n\n    def is_d_ary_max_heap(A, d):\n        \"\"\"\n        Checks if a sequence A represents a valid max d-ary heap.\n\n        Args:\n            A (list): The sequence of integers.\n            d (int): The arity to check.\n\n        Returns:\n            bool: True if A is a valid max d-ary heap, False otherwise.\n        \"\"\"\n        n = len(A)\n        if n = 1:\n            return True\n\n        # The last parent node is at index floor((n-2)/d).\n        # We need to iterate i from 0 up to and including this index.\n        # The range is thus 0 to floor((n-2)/d) + 1.\n        num_parents = (n - 2) // d + 1\n\n        for i in range(num_parents):\n            parent_val = A[i]\n            \n            # Iterate through children\n            for k in range(1, d + 1):\n                child_idx = d * i + k\n                \n                if child_idx  n:\n                    child_val = A[child_idx]\n                    if parent_val  child_val:\n                        return False\n                else:\n                    # Since child indices are consecutive, if one is out of bounds,\n                    # the rest will be too. We can break the inner loop.\n                    break\n        \n        return True\n\n    all_results = []\n    for A in test_cases:\n        n = len(A)\n        valid_ds = []\n        # Per the problem, d must be an integer with d > 1.\n        # The search space is given as 2 = d = n.\n        if n > 1:\n            for d in range(2, n + 1):\n                if is_d_ary_max_heap(A, d):\n                    valid_ds.append(d)\n        all_results.append(valid_ds)\n\n    # Format the output string exactly as required, without spaces.\n    inner_strings = [f\"[{','.join(map(str, res))}]\" for res in all_results]\n    final_output = f\"[{','.join(inner_strings)}]\"\n    \n    print(final_output)\n\nsolve()\n```", "id": "3225715"}, {"introduction": "在理解了D元堆的结构之后，下一步是分析其性能。D元堆的一个关键优势是其高效的建堆（`build_heap`）操作，通常具有线性时间复杂度。本练习将带你超越高阶的 $O(n)$ 分析，要求你推导出一个精确的、在最坏情况下的建堆成本公式，这种精细的分析对于深刻理解算法行为至关重要，也为更高级的性能调优奠定了数学基础。[@problem_id:3225640]", "problem": "给定一个 $d$ 叉最大堆（其中 $d \\ge 2$），它使用 0-基索引存储在一个连续数组中。对于每个索引 $i$，其子节点的索引为 $d i + 1, d i + 2, \\ldots, d i + d$，这些索引需要在数组边界之内。考虑自底向上的堆构建过程（通常称为 Floyd 建堆算法）：从最后一个内部节点开始，一直到根节点，对每个节点 $i$ 执行一次下沉（sift-down）操作。该操作会重复地将节点 $i$ 处的键值与其子节点中较大的一个进行交换，前提是该子节点大于当前键值。节点 $i$ 的下沉操作会逐层进行，直到该键值到达一个位置，其所有存在的子节点都比它小，或者它到达了一个叶节点。使用以下成本模型：\n\n- 两个键值之间的每次比较成本为 $1$。\n- 在任何具有 $k$ 个现有子节点的节点上，确定最大的子节点需要恰好 $k - 1$ 次比较。\n- 选出最大的子节点后，将当前键值与该子节点进行比较需要恰好 $1$ 次比较。\n\n假设输入规模 $n$ 等于一棵高度为 $H \\ge 1$ 的完全 $d$ 叉树的节点数，且其最后一层完全填满，即\n$$\nn \\;=\\; \\frac{d^{H+1} - 1}{d - 1}.\n$$\n在这种建堆过程的最坏情况下（即每次下沉操作都直达叶节点层），请仅根据 $n$ 和 $d$，从基本原理推导出整个建堆过程所执行的键值比较总数的精确封闭形式表达式。你的最终答案必须是关于 $n$ 和 $d$ 的单一封闭形式解析表达式（不含未求值的和或极限）。不要进行近似或四舍五入。[@problem_id:1568]", "solution": "问题要求在最坏情况下，对一个包含 $n$ 个节点且最后一层被完全填满的完全 $d$ 叉树，使用自底向上的 $d$ 叉堆构建方法时，键值比较的总次数。\n\n首先，我们根据题意确定树的结构和算法的成本模型。\n\n该树是一棵高度为 $H \\ge 1$ 的完全 $d$ 叉树，根节点位于第 $h=0$ 层，叶节点位于第 $h=H$ 层。任何层 $h$ 上的节点数量为 $d^h$。总节点数 $n$ 是从第 $0$ 层到第 $H$ 层所有节点数量的总和：\n$$n = \\sum_{h=0}^{H} d^h = \\frac{d^{H+1} - 1}{d - 1}$$\n这与给定的 $n$ 的公式相符。\n\n建堆算法从最后一个内部节点开始，一直遍历到根节点。对于本问题，内部节点是指所有非叶节点，即位于第 $h=0, 1, \\ldots, H-1$ 层的节点。对于每个内部节点，算法都会执行一次下沉（sift-down）操作。\n\n从节点 $i$ 开始的单次下沉操作的成本由比较次数决定。问题定义了最坏情况，即节点 $i$ 处的键值一直下沉到叶节点。键值下沉的层数等于节点 $i$ 的高度。位于第 $h$ 层的节点的高度为 $H-h$。\n\n在下沉操作的每一步中，临时节点上的键值会与其子节点进行比较。由于该树是完全的且最后一层是满的，下沉路径上的任何节点（非叶节点）都将恰好有 $d$ 个子节点。成本模型规定：\n1.  在 $d$ 个子节点中找到最大值需要 $d-1$ 次比较。\n2.  将当前键值与这个最大的子节点比较需要 $1$ 次比较。\n\n因此，在下沉操作中每向下一层，成本为 $(d-1) + 1 = d$ 次比较。\n对于一个位于第 $h$ 层的节点，其高度为 $H-h$。从该节点开始的最坏情况下的下沉操作包含 $H-h$ 步下沉。因此，对一个位于第 $h$ 层的节点进行下沉的总成本为 $d \\times (H-h)$。\n\n整个建堆过程的总比较次数 $C$ 是对所有内部节点进行下沉操作的成本之和。\n$$C = \\sum_{\\text{internal nodes } i} (\\text{cost to sift-down } i)$$\n我们可以按层级 $h$ 对节点进行分组。第 $h$ 层有 $d^h$ 个节点。内部节点位于第 $h=0, 1, \\ldots, H-1$ 层。\n$$C = \\sum_{h=0}^{H-1} (\\text{number of nodes at level } h) \\times (\\text{cost for a node at level } h)$$\n$$C = \\sum_{h=0}^{H-1} d^h \\cdot [d(H-h)] = d \\sum_{h=0}^{H-1} d^h(H-h)$$\n\n和 $\\sum_{h=0}^{H-1} d^h(H-h)$ 代表所有内部节点的高度之和。由于叶节点（位于第 $H$ 层）的高度为 $H-H=0$，这个和等价于树中所有节点的高度之和。设此和为 $S_{H}$。\n$$S_H = \\sum_{h=0}^{H} d^h(H-h)$$\n让我们从基本原理出发来计算这个和。我们可以将和式拆分：\n$$S_H = H \\sum_{h=0}^{H} d^h - \\sum_{h=0}^{H} h d^h$$\n第一项包含一个标准的几何级数：\n$$H \\sum_{h=0}^{H} d^h = H \\left(\\frac{d^{H+1}-1}{d-1}\\right) = Hn$$\n第二项是一个算术-几何级数，$A_H = \\sum_{h=0}^{H} h d^h = \\sum_{h=1}^{H} h d^h$。我们可以使用一种涉及几何级数导数的著名技巧来计算该级数。设 $G(x) = \\sum_{h=0}^{H} x^h = \\frac{x^{H+1}-1}{x-1}$。\n那么 $\\sum_{h=0}^{H} h x^h = x \\frac{d}{dx}G(x)$。\n$$\\frac{dG(x)}{dx} = \\frac{(H+1)x^H(x-1) - (x^{H+1}-1)(1)}{(x-1)^2} = \\frac{(H+1)x^{H+1} - (H+1)x^H - x^{H+1} + 1}{(x-1)^2} = \\frac{Hx^{H+1} - (H+1)x^H + 1}{(x-1)^2}$$\n乘以 $x$ 并设 $x=d$：\n$$A_H = \\sum_{h=1}^{H} h d^h = d \\frac{Hd^{H+1} - (H+1)d^H + 1}{(d-1)^2} = \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\n现在，将此结果代回 $S_H$ 的表达式中：\n$$S_H = Hn - A_H = H\\frac{d^{H+1}-1}{d-1} - \\frac{Hd^{H+2} - (H+1)d^{H+1} + d}{(d-1)^2}$$\n为了合并这些项，我们将它们通分到共同的分母 $(d-1)^2$下：\n$$S_H = \\frac{H(d^{H+1}-1)(d-1) - [Hd^{H+2} - (H+1)d^{H+1} + d]}{(d-1)^2}$$\n让我们展开分子：\n$$\n\\begin{align*}\n\\text{Numerator} = H(d^{H+2} - d^{H+1} - d + 1) - Hd^{H+2} + (H+1)d^{H+1} - d \\\\\n= Hd^{H+2} - Hd^{H+1} - Hd + H - Hd^{H+2} + Hd^{H+1} + d^{H+1} - d \\\\\n= d^{H+1} - Hd + H - d \\\\\n= d^{H+1} - H(d-1) - d\n\\end{align*}\n$$\n所以，高度之和为：\n$$S_H = \\frac{d^{H+1} - H(d-1) - d}{(d-1)^2}$$\n我们可以通过代入 $n$ 的关系式来简化这个表达式。由 $n = \\frac{d^{H+1}-1}{d-1}$，我们得到 $d^{H+1} = n(d-1)+1$。\n$$S_H = \\frac{(n(d-1)+1) - H(d-1) - d}{(d-1)^2} = \\frac{n(d-1) - H(d-1) - (d-1)}{(d-1)^2} = \\frac{(n - H - 1)(d-1)}{(d-1)^2} = \\frac{n-H-1}{d-1}$$\n总比较次数为 $C = d \\cdot S_H$。\n$$C = d \\left(\\frac{n-H-1}{d-1}\\right)$$\n最后一步是用 $n$ 和 $d$ 来表示 $H$。从 $d^{H+1} = n(d-1)+1$ 出发，我们对等式两边取以 $d$ 为底的对数：\n$$\\log_d(d^{H+1}) = \\log_d(n(d-1)+1)$$\n$$H+1 = \\log_d(n(d-1)+1)$$\n$$H = \\log_d(n(d-1)+1) - 1$$\n将 $H$ 的这个表达式代入我们的 $C$ 公式中：\n$$C = \\frac{d}{d-1} \\left( n - \\left( \\log_d(n(d-1)+1) - 1 \\right) - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) + 1 - 1 \\right)$$\n$$C = \\frac{d}{d-1} \\left( n - \\log_d(n(d-1)+1) \\right)$$\n这就是以 $n$ 和 $d$ 表示的总比较次数的最终封闭形式表达式。", "answer": "$$ \\boxed{ \\frac{d\\left(n - \\log_{d}\\left(n(d-1)+1\\right)\\right)}{d-1} } $$", "id": "3225640"}, {"introduction": "最后的实践将所有概念融会贯通，解决一个核心的实际问题：如何选择最优的元数 $d$？元数 $d$ 的选择体现了D元堆设计的核心权衡：较大的 $d$ 会降低堆的高度，但同时会增加在每一层中寻找极值子节点的比较次数。本练习指导你建立一个量化模型，在给定的工作负载和抽象的硬件成本假设下找到最优的 $d$ 值，从而将理论分析与设计最高效数据结构的实际目标联系起来。[@problem_id:3225717]", "problem": "您的任务是设计并实现一个完整、可运行的程序，该程序能够根据一组给定的特定于机器的成本参数和工作负载权重，选择一个$d$叉堆的度$d$，以最小化一个基于最坏情况下的基本操作的成本模型。目标是通过使用一个原则性的成本模型，以一种受控、可复现的方式模拟一项经验性研究，该模型将中央处理器（CPU）、缓存层次结构和随机存取存储器（RAM）带宽的影响抽象为基本操作成本。您的程序不得执行任何计时测量；相反，它必须使用一个基于标准定义推导出的解析模型来计算最小化成本的$d$。\n\n使用的基本原理：\n- $d$叉堆是一个以层序存储在数组中的完全树。其高度是满足以下条件的最小整数$L$：一个分支因子为$d$、高度为$L$的树至少可以容纳$n$个节点。等价地，$L$是满足$d^{L} \\ge n$的最小整数，这意味着对于$n \\ge 1$，$L = \\lceil \\log_{d} n \\rceil$。\n- 一个位于索引$i$（使用从零开始的索引）的节点的父节点位于索引$\\left\\lfloor \\dfrac{i-1}{d} \\right\\rfloor$，其子节点位于索引$d\\cdot i + j$，其中$j \\in \\{1,2,\\dots,d\\}$，前提是这些索引在数组范围内存在。\n- 基于$d$叉最小堆构建的标准优先队列的操作语义：\n  - `decrease-key`（减小键值）和`insert`（插入）都可能通过与父节点反复比较和交换，将一个键向上移动，直到恢复堆属性。在最坏情况下，向上移动的次数等于高度$L$。\n  - `extract-min`（提取最小值）移除根节点，换入最后一个元素，然后通过在最多$d$个子节点中反复选择最小者并向下交换来恢复堆，直到恢复堆属性。在最坏情况下，向下移动的次数等于高度$L$。\n\n使用的成本模型：\n- 仅计算两种基本成本：\n  - $c_{c}$：每次键比较的成本。\n  - $c_{s}$：每次交换两个键的成本（将一次交换视为具有此成本的单个基本操作；内部赋值和内存流量被抽象到$c_{s}$中）。\n- 每次操作的最坏情况基本计数，由操作语义证明：\n  - `insert`和`decrease-key`：最多向上遍历$L$层，执行最多$L$次比较和$L$次交换。\n  - `extract-min`：一次固定的交换以移除根节点并将最后一个元素置于根部，外加最多向下遍历$L$层。在每一层，从最多$d$个子节点中选择最小者执行最多$d-1$次比较，然后进行一次交换以将空位下移。\n- 工作负载模型：\n  - 设$w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$和$w_{\\mathrm{dec}}$为非负权重，分别表示`extract-min`、`insert`和`decrease-key`的相对频率。您可以假设$w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}}  0$。\n  - 对于给定的$d$，每次操作的最坏情况加权成本是相应基本计数乘以基本成本的加权和。\n\n任务：\n- 仅使用上述基本原理和最坏情况推理，推导出每次操作的最坏情况加权成本的表达式，该表达式是$d$、$n$、$c_{c}$、$c_{s}$、$w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$和$w_{\\mathrm{dec}}$的函数。推导必须从所述语义出发。不要假设任何平均情况行为。\n- 实现一个程序，该程序：\n  - 对于每个测试用例，考虑$[2, d_{\\max}]$闭区间内的所有整数$d$。\n  - 计算堆高度$L(d,n) = \\lceil \\log_{d} n \\rceil$，并遵循$L(d,1) = 0$的约定。\n  - 使用您推导出的计数以及给定的基本成本和权重，计算该$d$的最坏情况加权成本。\n  - 选择使该成本最小化的$d$。如果出现成本相同的情况，则选择最小的$d$。\n  - 为每个测试用例输出所选的$d$。\n- 输出格式：您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔的结果列表（例如，“[result1,result2,result3]”）。\n\n测试套件：\n- 每个测试用例是一个元组$(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$，具有以下特定值。所有数字都是精确且无单位的。\n  - 用例 1：$(n=1, w_{\\mathrm{ex}}=1.0, w_{\\mathrm{in}}=0.0, w_{\\mathrm{dec}}=0.0, c_{c}=5.0, c_{s}=10.0, d_{\\max}=16)$\n  - 用例 2：$(n=1000000, w_{\\mathrm{ex}}=0.6, w_{\\mathrm{in}}=0.3, w_{\\mathrm{dec}}=0.1, c_{c}=3.0, c_{s}=8.0, d_{\\max}=32)$\n  - 用例 3：$(n=1000000, w_{\\mathrm{ex}}=0.8, w_{\\mathrm{in}}=0.1, w_{\\mathrm{dec}}=0.1, c_{c}=50.0, c_{s}=5.0, d_{\\max}=16)$\n  - 用例 4：$(n=5000000, w_{\\mathrm{ex}}=0.2, w_{\\mathrm{in}}=0.6, w_{\\mathrm{dec}}=0.2, c_{c}=2.0, c_{s}=40.0, d_{\\max}=64)$\n  - 用例 5：$(n=1000, w_{\\mathrm{ex}}=1.0, w_{\\mathrm{in}}=0.0, w_{\\mathrm{dec}}=0.0, c_{c}=1.0, c_{s}=1.0, d_{\\max}=2)$\n\n答案规范：\n- 您的程序必须为上述五个用例中的每一个计算出最小化成本的$d$，并按顺序以指定的精确格式将它们打印为单行。", "solution": "用户要求设计一个程序，为$d$叉堆找到最优的度$d$，以最小化一个基于最坏情况的操作成本模型。该过程首先对问题陈述进行形式化验证，然后推导成本函数并加以实现。\n\n### 问题验证\n\n**第 1 步：提取给定条件**\n\n*   **堆结构**：$d$叉堆是一个存储在数组中的完全树。\n*   **堆高度 ($L$)**：对于$n \\ge 1$，$L = \\lceil \\log_{d} n \\rceil$。给定一个特殊约定：$L(d, 1) = 0$。\n*   **父/子索引（从0开始）**：节点$i$的父节点是$\\lfloor(i-1)/d\\rfloor$。子节点是$d \\cdot i + j$，其中$j \\in \\{1, 2, \\dots, d\\}$。\n*   **操作语义（最坏情况）**：\n    *   `insert` / `decrease-key`：$L$次比较和$L$次交换。\n    *   `extract-min`：$1$次固定的交换，外加$L$次向下步骤。每个向下步骤最多包含$d-1$次比较和$1$次交换。\n*   **成本基元**：\n    *   $c_c$：每次键比较的成本。\n    *   $c_s$：每次键交换的成本。\n*   **工作负载模型**：\n    *   $w_{\\mathrm{ex}}$、$w_{\\mathrm{in}}$、$w_{\\mathrm{dec}}$：`extract-min`、`insert`和`decrease-key`操作的非负权重，且$w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}}  0$。\n*   **目标**：对于每个测试用例，找到整数$d \\in [2, d_{\\max}]$，使最坏情况加权成本最小化。成本相同时选择最小的$d$。\n*   **测试套件**：提供了五个测试用例，包含$(n, w_{\\mathrm{ex}}, w_{\\mathrm{in}}, w_{\\mathrm{dec}}, c_{c}, c_{s}, d_{\\max})$的具体值。\n\n**第 2 步：使用提取的给定条件进行验证**\n\n根据验证标准对问题陈述进行分析。\n\n*   **科学依据**：该问题基于标准且成熟的$d$叉堆数据结构。成本模型是算法分析中常用的有效抽象，用于在不进行直接机器计时的情况下模拟性能。它在科学上和算法上都是合理的。\n*   **良构性（Well-Posed）**：问题定义清晰。目标是在一个有限的离散整数域$d \\in [2, d_{\\max}]$上找到一个函数的最小值。最小值必然存在。平局打破规则（选择最小的$d$）确保了解决方案的唯一性。\n*   **目标**：语言精确且数学化。所有参数和约束都进行了量化定义。\n*   **完整性与一致性**：问题提供了推导成本函数和执行所需搜索所需的所有数据和定义。对于$n=1$的情况明确说明了约定，避免了歧义。没有矛盾之处。\n\n**第 3 步：结论与行动**\n\n此问题**有效**。它自成体系，有科学依据，良构，且提供了解决问题所需的所有信息。可以开始求解过程。\n\n### 最坏情况加权成本函数的推导\n\n目标是推导出每次操作的总最坏情况加权成本，记为$C(d)$，作为度$d$和给定参数的函数。此推导直接遵循问题陈述中指定的基本操作成本。\n\n1.  **堆高度**：对于$n$个元素和度为$d$的堆，其高度由$L(d, n) = \\lceil \\log_{d} n \\rceil$给出。对于$n=1$的特殊情况，$L(d, 1) = \\lceil \\log_{d} 1 \\rceil = \\lceil 0 \\rceil = 0$，这与给定的约定一致。\n\n2.  **单个操作的成本**：我们通过对其组成的基本操作（比较和交换）的成本求和来确定每种操作类型的最坏情况成本。\n\n    *   **Insert 和 Decrease-Key**：问题陈述指出，在最坏情况下，一个元素会沿着树的整个高度向上移动。这涉及$L(d, n)$层。在每一层，会发生一次与父节点的比较和一次交换。\n        `insert`操作的成本$C_{\\mathrm{in}}(d)$为：\n        $$C_{\\mathrm{in}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n        类似地，`decrease-key`操作的成本$C_{\\mathrm{dec}}(d)$为：\n        $$C_{\\mathrm{dec}}(d) = L(d, n) \\cdot c_c + L(d, n) \\cdot c_s = L(d, n) (c_c + c_s)$$\n\n    *   **Extract-Min**：此操作包括两个阶段。首先，根被堆中的最后一个元素替换，这需要一次交换。其次，新的根元素“下沉”以恢复堆属性。这个向下遍历最多覆盖$L(d, n)$层。在每一层，该元素与其最多$d$个子节点进行比较以找到最小值，这需要最多$d-1$次比较。然后，与最小子节点进行一次交换。\n        `extract-min`操作的成本$C_{\\mathrm{ex}}(d)$是初始交换和下沉过程的成本之和：\n        $$C_{\\mathrm{ex}}(d) = (1 \\cdot c_s) + L(d, n) \\cdot ((d-1) \\cdot c_c + 1 \\cdot c_s)$$\n        $$C_{\\mathrm{ex}}(d) = c_s + L(d, n) ((d-1)c_c + c_s)$$\n\n3.  **总加权成本函数**：总最坏情况加权成本$C(d)$是每个操作的成本乘以其各自权重的总和。\n    $$C(d) = w_{\\mathrm{ex}} \\cdot C_{\\mathrm{ex}}(d) + w_{\\mathrm{in}} \\cdot C_{\\mathrm{in}}(d) + w_{\\mathrm{dec}} \\cdot C_{\\mathrm{dec}}(d)$$\n    代入上面推导出的表达式：\n    $$ C(d) = w_{\\mathrm{ex}} \\left(c_s + L(d, n) ((d-1)c_c + c_s)\\right) + w_{\\mathrm{in}} \\left(L(d, n) (c_c + c_s)\\right) + w_{\\mathrm{dec}} \\left(L(d, n) (c_c + c_s)\\right) $$\n    我们可以提出$L(d, n)$来简化表达式：\n    $$ C(d) = w_{\\mathrm{ex}} c_s + L(d, n) \\left[ w_{\\mathrm{ex}} ((d-1)c_c + c_s) + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})(c_c + c_s) \\right] $$\n    让我们展开并按$c_c$和$c_s$对括号内的项进行分组：\n    $$ \\left[ w_{\\mathrm{ex}}(d-1)c_c + w_{\\mathrm{ex}}c_s + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_c + (w_{\\mathrm{in}} + w_{\\mathrm{dec}})c_s \\right] $$\n    $$ = c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) $$\n    这就得出了总最坏情况加权成本的最终解析表达式：\n    $$ C(d) = w_{\\mathrm{ex}} c_s + \\lceil \\log_{d} n \\rceil \\left[ c_c \\left( w_{\\mathrm{ex}}(d-1) + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) + c_s \\left( w_{\\mathrm{ex}} + w_{\\mathrm{in}} + w_{\\mathrm{dec}} \\right) \\right] $$\n    对于$[2, d_{\\max}]$范围内的每个整数$d$，将评估此函数，以找到使$C(d)$最小化的$d$值。对数的上取整$\\lceil \\log_{d} n \\rceil$可以使用任何方便的对数底数计算为`ceil(log(n) / log(d))`（例如，自然对数）。\n\n### 最小化过程\n\n对于每个测试用例，我们将遍历从$2$到$d_{\\max}$（含）的所有可能的整数值$d$。在每次迭代中，我们使用推导出的公式计算成本$C(d)$。我们记录到目前为止找到的最小成本和对应的$d$值。如果对于给定的$d$新计算的成本严格小于当前的最小值，我们就更新最小成本和最优$d$。该过程天然地遵循了选择最小$d$的平局打破规则，因为较小的$d$值会先被评估。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the optimal arity 'd' for a d-ary heap for a given set of\n    test cases based on a worst-case operational cost model.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each tuple is (n, w_ex, w_in, w_dec, c_c, c_s, d_max)\n    test_cases = [\n        (1, 1.0, 0.0, 0.0, 5.0, 10.0, 16),\n        (1000000, 0.6, 0.3, 0.1, 3.0, 8.0, 32),\n        (1000000, 0.8, 0.1, 0.1, 50.0, 5.0, 16),\n        (5000000, 0.2, 0.6, 0.2, 2.0, 40.0, 64),\n        (1000, 1.0, 0.0, 0.0, 1.0, 1.0, 2),\n    ]\n\n    results = []\n    for case in test_cases:\n        n, w_ex, w_in, w_dec, c_c, c_s, d_max = case\n\n        min_cost = float('inf')\n        best_d = -1\n\n        # Iterate through all possible arities d from 2 to d_max (inclusive).\n        for d in range(2, d_max + 1):\n            # Calculate heap height L(d, n).\n            # L = ceil(log_d(n)).\n            # Per problem spec, L(d, 1) is 0.\n            if n = 1:\n                L = 0\n            else:\n                # Use numpy for safe floating point logarithm calculation.\n                # np.ceil returns a float, so cast to int.\n                L = int(np.ceil(np.log(n) / np.log(d)))\n\n            # From the derivation, the total weighted cost C(d) is:\n            # C(d) = w_ex * c_s + L * [c_c * (w_ex * (d-1) + w_in + w_dec) + c_s * (w_ex + w_in + w_dec)]\n\n            # Pre-calculate terms for clarity.\n            total_weight = w_ex + w_in + w_dec\n            comparison_workload = w_ex * (d - 1) + w_in + w_dec\n            \n            # Cost from comparisons and swaps during sift-up/sift-down.\n            variable_cost_per_level = c_c * comparison_workload + c_s * total_weight\n            \n            # Total cost is the fixed cost of extract-min plus the height-dependent costs.\n            cost = w_ex * c_s + L * variable_cost_per_level\n\n            # Check if this d yields a new minimum cost.\n            # The problem asks to choose the smallest d in case of a tie.\n            # By using '' and iterating d in increasing order, the first d\n            # that achieves the minimum cost will be selected, fulfilling the tie-breaker rule.\n            if cost  min_cost:\n                min_cost = cost\n                best_d = d\n        \n        results.append(best_d)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3225717"}]}