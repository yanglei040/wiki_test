{"hands_on_practices": [{"introduction": "对于一维空间中的点集，最远的点对总是由集合中的最小值和最大值构成。这个练习旨在通过增强树节点来存储其子树中的最小值和最大值，从而将一个看似需要遍历整个集合的问题，转化为在树的根节点处进行 $O(1)$ 时间的查询。这项实践是理解增强思想的绝佳起点，它展示了如何通过存储聚合信息来极大提升特定查询的效率。[@problem_id:3210318]", "problem": "给定一个实数线上的一维整数点的动态有限集合。目标是支持对该集合的三种操作：插入一个点、删除一个点，以及查询当前集合中相距最远的两个点。你必须设计并实现一个基于增强的平衡二叉搜索树（BST）的数据结构，以便在任意插入和删除序列下，对于大小为 $n$ 的集合，实现 $O(\\log n)$ 的查询时间。\n\n从以下基础知识开始：\n- 二叉搜索树（BST）维持一个不变性，即对于任何键为 $k$ 的节点，其左子树中的所有键都 $ k$，其右子树中的所有键都 $\\ge k$。\n- 平衡BST维持 $O(\\log n)$ 的高度，这通过树旋转和结构调整，使得搜索、插入和删除操作的时间复杂度达到 $O(\\log n)$。\n- 在实数线上的一个全序集中，任意两点之间的差值相对于排序是单调的。\n\n你的任务是推导并实现一棵增强树，在每个节点上维护足够的信息，以便在 $O(\\log n)$ 时间内回答当前集合上的最远点对查询。这种增强必须在插入和删除操作下得以维护，并且最终的操作必须保持与平衡BST设计一致的渐近复杂度保证。\n\n假设动态集合遵循以下规则：\n- 点是整数，集合不包含重复项。插入一个已经存在的点不会改变集合。\n- 删除一个不存在的点不会改变集合。\n- 当集合中至少有两个点时，“相距最远的”点对是具有最小值和最大值的点对。当集合中只有一个点 $x$ 时，最远点对定义为 $x$ 和 $x$，距离为 $0$。当集合为空时，将最远点对的结果定义为三元组 $[0,0,0]$。\n\n你的程序必须实现该数据结构并处理以下操作序列的测试套件。对于每个测试用例，将所有操作应用于一个初始为空的集合，然后输出最远点对的结果，格式为一个列表 $[m,M,d]$，其中 $m$ 是最终集合中的最小点， $M$ 是最终集合中的最大点， $d = M - m$ 是距离。如果最终集合为空，则输出 $[0,0,0]$。\n\n测试套件（每个项目符号都是一个从空集开始的测试用例）：\n- 插入 $3$，插入 $-2$，插入 $5$。\n- 插入 $10$。\n- （无操作；集合保持为空。）\n- 插入 $-100$，插入 $-50$，插入 $-75$，删除 $-75$，插入 $-60$，删除 $-100$，插入 $-10$。\n- 插入 $-1000000000$，插入 $1000000000$，插入 $0$，删除 $0$。\n- 插入 $4$，插入 $4$，删除 $7$，插入 $-1$，插入 $9$，删除 $4$。\n\n你的程序应生成单行输出，其中包含一个用方括号括起来的、以逗号分隔的结果列表。每个测试用例的结果本身必须是一个列表 $[m,M,d]$。例如，一个有效的输出格式是 $[[m_1,M_1,d_1],[m_2,M_2,d_2],\\dots]$，不含多余的空格或文本。", "solution": "我们首先为实数线上的最远点对问题建立数学基础。设 $S$ 是 $\\mathbb{Z}$（视为实数线上的点）的一个有限子集。定义两点 $a,b \\in S$ 之间的距离为 $|b-a|$。由于该集合是全序的，我们可以按非递减顺序列举 $S$ 为 $x_1 \\le x_2 \\le \\dots \\le x_n$。对于任意一对 $x_i, x_j$ 且 $i \\le j$，观察到 $|x_j - x_i| = x_j - x_i$ 因为 $x_j \\ge x_i$。根据单调性，对于固定的 $x_i$，$x_j - x_i$ 在 $x_j = x_n$ 时最大化；对于固定的 $x_j$，$x_j - x_i$ 在 $x_i = x_1$ 时最大化。因此，最远点对总是 $(x_1, x_n)$，其距离为 $x_n - x_1$。这个结论直接源于实数线的有序结构，不依赖于任何捷径公式；它是通过比较所有可能的点对以及差值相对于极值的单调增加得出的。\n\n为了在动态更新下快速回答最远点对查询，我们依赖于平衡二叉搜索树（BST），具体来说是一种称为Treap（树+堆）的随机化平衡BST。Treap对键维持BST不变性，并对随机分配的优先级维持堆不变性。其期望高度为 $O(\\log n)$，从而使搜索、插入和删除的期望时间为 $O(\\log n)$。\n\n增强原理：为了回答最远点对查询，能够获取当前集合中的最小和最大键就足够了。在一个朴素的BST中，查找最小值或最大值需要下降到最左或最右的节点，这需要 $O(h)$ 的时间，其中 $h$ 是树高；在平衡树中 $h = O(\\log n)$。我们可以通过增强每个节点，使其包含其子树中存在的最小和最大键，从而使查询达到 $O(1)$。具体来说，对于一个键为 $k$、子节点为 $L$ 和 $R$ 的节点，定义增强字段如下：\n- $\\text{sub\\_min} = \\min\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_min}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_min}\\} \\text{ if } R \\ne \\varnothing)\\right)$,\n- $\\text{sub\\_max} = \\max\\left(\\{k\\} \\cup (\\{L.\\text{sub\\_max}\\} \\text{ if } L \\ne \\varnothing) \\cup (\\{R.\\text{sub\\_max}\\} \\text{ if } R \\ne \\varnothing)\\right)$.\n\n增强的正确性：我们通过对树的结构归纳法来论证。对于叶节点，$\\text{sub\\_min} = \\text{sub\\_max} = k$ 是正确的。假设对于子树 $L$ 和 $R$，这些字段是正确的。那么，当前节点子树中的最小元素就是 $k$、 $L$ 中的最小值和 $R$ 中的最小值三者之中的最小值；最大值同理。因此，这些公式能够维护正确的值。在插入、删除和旋转（用于维护treap的堆属性）操作后，我们从子节点到父节点重新计算这些增强字段。因为旋转只改变局部的父子关系，同时保留中序序列，所以通过上述公式重新计算可以保持正确性。\n\n复杂度分析：Treap的插入和删除操作在期望长度为 $O(\\log n)$ 的搜索路径上执行期望常数次旋转。每个节点的 $\\text{sub\\_min}$ 和 $\\text{sub\\_max}$ 更新是 $O(1)$ 的。因此，插入和删除操作的期望运行时间都是 $O(\\log n)$。如果树非空，最远点对查询简化为在 $O(1)$ 时间内读取根节点的 $\\text{sub\\_min}$ 和 $\\text{sub\\_max}$。在问题要求的 $O(\\log n)$ 复杂度限制下，此设计满足并超过了要求。\n\n边界情况和定义：\n- 当集合为空时，没有最小值或最大值。我们将查询结果定义为 $[0,0,0]$。\n- 当集合中只有一个元素 $x$ 时，最小值和最大值都是 $x$，最远距离为 $0$，得出 $[x,x,0]$。\n- 重复的插入被忽略（集合语义），因为最远点对仅取决于极值，所以不必允许重复。删除不存在的元素不做任何操作。\n\n实现计划：\n- 节点表示为包含以下字段：键 $k$、优先级 $p$、指向左右子节点的指针，以及增强字段 $\\text{sub\\_min}$、$\\text{sub\\_max}$。\n- 实现treap操作：插入（带旋转的递归）、删除（带旋转的递归）和更新（从子节点重新计算增强字段）。\n- 实现查询：如果根节点为 $\\varnothing$，返回 $[0,0,0]$；否则返回 $[\\text{root.sub\\_min}, \\text{root.sub\\_max}, \\text{root.sub\\_max} - \\text{root.sub\\_min}]$。\n\n与问题陈述一致的测试套件解释：\n- 插入 $3$, $-2$, $5$ 后: $m = -2$, $M = 5$, $d = 7$。\n- 插入 $10$ 后: $m = 10$, $M = 10$, $d = 0$。\n- 无操作: 空集 $\\Rightarrow [0,0,0]$。\n- 在负数上进行交错删除操作后: 最终集合为 $\\{-60,-50,-10\\}$，所以 $m=-60$, $M=-10$, $d=50$。\n- 大数值: 最终集合为 $\\{-1000000000, 1000000000\\}$，$m=-1000000000$, $M=1000000000$, $d=2000000000$。\n- 重复插入和删除不存在的元素: 最终集合为 $\\{-1,9\\}$, $m=-1$, $M=9$, $d=10$。\n\n程序构建treap，执行测试套件，并以指定的确切格式打印包含每个测试用例结果的聚合列表的单行输出。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport random\n\nclass TreapNode:\n    __slots__ = (\"key\", \"prio\", \"left\", \"right\", \"sub_min\", \"sub_max\")\n    def __init__(self, key, prio):\n        self.key = key\n        self.prio = prio\n        self.left = None\n        self.right = None\n        self.sub_min = key\n        self.sub_max = key\n\ndef update(node: TreapNode):\n    \"\"\"Recompute augmented fields for a node from its children.\"\"\"\n    if node is None:\n        return\n    min_val = node.key\n    max_val = node.key\n    if node.left is not None:\n        if node.left.sub_min  min_val:\n            min_val = node.left.sub_min\n        if node.left.sub_max  max_val:\n            max_val = node.left.sub_max\n    if node.right is not None:\n        if node.right.sub_min  min_val:\n            min_val = node.right.sub_min\n        if node.right.sub_max  max_val:\n            max_val = node.right.sub_max\n    node.sub_min = min_val\n    node.sub_max = max_val\n\ndef rotate_right(y: TreapNode) - TreapNode:\n    \"\"\"Right rotation around y.\"\"\"\n    x = y.left\n    y.left = x.right\n    x.right = y\n    update(y)\n    update(x)\n    return x\n\ndef rotate_left(x: TreapNode) - TreapNode:\n    \"\"\"Left rotation around x.\"\"\"\n    y = x.right\n    x.right = y.left\n    y.left = x\n    update(x)\n    update(y)\n    return y\n\ndef insert(node: TreapNode, key: int, prio_func) - TreapNode:\n    \"\"\"Insert key into treap rooted at node using prio_func to assign priority.\n       Set semantics: if key already exists, no change.\"\"\"\n    if node is None:\n        return TreapNode(key, prio_func(key))\n    if key == node.key:\n        # Duplicate insert ignored (set semantics)\n        return node\n    if key  node.key:\n        node.left = insert(node.left, key, prio_func)\n        update(node)\n        if node.left is not None and node.left.prio  node.prio:\n            node = rotate_right(node)\n    else:\n        node.right = insert(node.right, key, prio_func)\n        update(node)\n        if node.right is not None and node.right.prio  node.prio:\n            node = rotate_left(node)\n    update(node)\n    return node\n\ndef delete(node: TreapNode, key: int) - TreapNode:\n    \"\"\"Delete key from treap rooted at node. If key not present, no change.\"\"\"\n    if node is None:\n        return None\n    if key  node.key:\n        node.left = delete(node.left, key)\n    elif key  node.key:\n        node.right = delete(node.right, key)\n    else:\n        # Found node to delete\n        if node.left is None and node.right is None:\n            return None\n        elif node.left is None:\n            node = rotate_left(node)\n            node.left = delete(node.left, key)\n        elif node.right is None:\n            node = rotate_right(node)\n            node.right = delete(node.right, key)\n        else:\n            # Rotate the higher-priority child up\n            if node.left.prio  node.right.prio:\n                node = rotate_right(node)\n                node.right = delete(node.right, key)\n            else:\n                node = rotate_left(node)\n                node.left = delete(node.left, key)\n    update(node)\n    return node\n\nclass AugmentedTreap:\n    def __init__(self, seed: int = 42):\n        # Use a deterministic pseudo-random priority function seeded for reproducibility.\n        random.seed(seed)\n        # Pre-generate a map from keys to priorities lazily to keep deterministic.\n        self.root = None\n        self.prio_cache = {}\n        self.rng = random.Random(seed)\n\n    def prio_func(self, key: int) - float:\n        # Deterministic priority per key using a simple hash-like transform.\n        # This keeps reproducibility while providing reasonable randomization for balance.\n        if key not in self.prio_cache:\n            # Use a combination of random and key to avoid collisions.\n            # Assign a random float in (0,1) scaled by a deterministic function of the key.\n            # But final value is determined solely by the seeded RNG on first use.\n            self.prio_cache[key] = self.rng.random()\n        return self.prio_cache[key]\n\n    def insert(self, key: int):\n        self.root = insert(self.root, key, self.prio_func)\n\n    def delete(self, key: int):\n        self.root = delete(self.root, key)\n\n    def farthest_pair(self):\n        \"\"\"Return [min, max, distance] for current set; [0,0,0] if empty.\"\"\"\n        if self.root is None:\n            return [0, 0, 0]\n        m = self.root.sub_min\n        M = self.root.sub_max\n        return [m, M, M - m]\n\ndef run_case(ops):\n    treap = AugmentedTreap(seed=123456)  # fixed seed for deterministic structure\n    for op in ops:\n        cmd = op[0]\n        if cmd == 'ins':\n            treap.insert(op[1])\n        elif cmd == 'del':\n            treap.delete(op[1])\n        else:\n            # ignore unknown commands\n            pass\n    return treap.farthest_pair()\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [('ins', 3), ('ins', -2), ('ins', 5)],\n        [('ins', 10)],\n        [],\n        [('ins', -100), ('ins', -50), ('ins', -75), ('del', -75), ('ins', -60), ('del', -100), ('ins', -10)],\n        [('ins', -1000000000), ('ins', 1000000000), ('ins', 0), ('del', 0)],\n        [('ins', 4), ('ins', 4), ('del', 7), ('ins', -1), ('ins', 9), ('del', 4)],\n    ]\n\n    results = []\n    for ops in test_cases:\n        result = run_case(ops)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nif __name__ == \"__main__\":\n    solve()\n```", "id": "3210318"}, {"introduction": "在掌握了基础的聚合思想后，我们来挑战一个更复杂的数值查询：区间和。直接在平衡二叉搜索树中计算一个任意区间的元素总和，效率低下。本练习将引导你通过在每个节点上增强一个“子树和”(`subtree_sum`)字段，并将复杂的区间和查询 $[low, high]$ 分解为两个更简单的“小于等于”(`Sum(=k)`)查询，从而在对数时间内解决问题。[@problem_id:3210369]", "problem": "设计并实现一棵增强型平衡二叉搜索树 (BBST)，该树支持整数键，允许通过多次插入相同值来处理重复键，并能在每次操作的渐近时间 $O(\\log n)$ 内回答区间和查询，其中 $n$ 是计入多重性的已插入元素总数。从二叉搜索树的基本原则出发：对于任意键为 $k$ 的节点，其左子树中的所有键都严格小于 $k$，右子树中的所有键都严格大于 $k$；并且平衡树能确保树高为 $O(\\log n)$。允许进行增强，前提是增强的属性派生自 BBST 的结构及其不变量。\n\n您的程序必须构建并维护这样一棵树，以支持对整数键的以下操作：\n\n- 将键 $x$ 插入树中。如果插入的键与现有键相等，则其多重性增加 $1$。\n- 从树中删除键 $x$。删除一个键会使其多重性减少 $1$，如果多重性变为 $0$，则从树中移除该键。\n- 计算位于闭区间 $[low, high]$ 内所有键的总和（计入多重性）。\n\n您必须设计增强方案，使得在 BBST 上对 $[low, high]$ 的区间和查询能在渐近时间 $O(\\log n)$ 内完成。解决方案必须从二叉搜索树的不变量和平衡高度属性推导得出，不得依赖任何特殊的内置数据结构。\n\n测试套件。您的程序必须按顺序执行以下场景，并汇总所有查询的输出：\n\n场景 $\\mathsf{A}$（一般情况、插入、删除和查询）：\n- 按顺序 $[5,3,8,1,4,7,9]$ 插入键来初始化树。\n- 查询区间 $[3,8]$ 的和。\n- 删除键 $4$。\n- 查询区间 $[3,8]$ 的和。\n\n场景 $\\mathsf{B}$（边界条件：空树、负值和无效区间）：\n- 初始化一棵空树。\n- 查询区间 $[0,10]$ 的和。\n- 插入键 $-2$。\n- 查询区间 $[-5,-1]$ 的和。\n- 查询区间 $[2,1]$ 的和（注意这是一个无效区间，因为 $low > high$；定义结果为 $0$）。\n\n场景 $\\mathsf{C}$（重复项和选择性删除）：\n- 按顺序 $[2,2,2,3,3,10]$ 插入键来初始化树。\n- 查询区间 $[2,3]$ 的和。\n- 删除一次键 $2$。\n- 查询区间 $[2,2]$ 的和。\n\n场景 $\\mathsf{D}$（区间完全覆盖当前集合及删除效果）：\n- 按顺序 $[0,-5,5,1]$ 插入键来初始化树。\n- 查询区间 $[-10,10]$ 的和。\n- 删除键 $1$。\n- 查询区间 $[-10,10]$ 的和。\n\n最终输出格式。您的程序应生成单行输出，其中包含所有查询结果的有序列表，格式为逗号分隔并用方括号括起，例如 $[result\\_1,result\\_2,\\dots]$。每个查询的输出必须是整数。本问题不涉及物理单位、角度或百分比。", "solution": "用户提供的问题经评估为**有效**。这是一个来自数据结构与算法领域的、提法明确且有科学依据的问题，不包含矛盾、歧义或不成立的前提。该问题可以通过形式化推导并实现一棵增强型平衡二叉搜索树（BBST）来解决。\n\n任务是设计一棵 BBST，它能支持整数键的插入、删除和区间和查询，所有操作的渐近时间复杂度均为 $O(\\log n)$，其中 $n$ 是包含重复项的元素总数。\n\n### 原理与设计\n\n标准的二叉搜索树（BST）维持一个不变量：对于任意键为 $k$ 的节点，其左子树中的所有键都小于 $k$，右子树中的所有键都大于 $k$。为了处理重复键，我们可以增强每个节点，为其存储一个多重性或计数值。平衡二叉搜索树（例如 AVL 树或红黑树）进一步保证树高保持在 $O(\\log n)$，从而确保了搜索、插入和删除等基于遍历的操作是高效的。\n\n要在 $O(\\log n)$ 时间内回答闭区间 $[low, high]$ 的区间和查询，标准的 BST 是不够的，因为它需要进行中序遍历，耗时 $O(k + \\log n)$，其中 $k$ 是区间内的元素数量。关键在于通过增强树节点，为其增加额外信息，从而无需访问区间内的每个节点即可计算总和。\n\n区间 $[low, high]$ 的求和查询可以分解为两个更基本的查询：\n$$ \\text{RangeSum}(low, high) = \\text{Sum}(\\leq high) - \\text{Sum}(\\leq low - 1) $$\n其中 $\\text{Sum}(\\leq k)$ 是树中所有小于或等于 $k$ 的键的总和。如果我们能在 $O(\\log n)$ 时间内计算出 $\\text{Sum}(\\leq k)$，那么区间和查询也能在 $O(\\log n)$ 时间内解决。\n\n为此，我们为 BBST 中的每个节点 $v$ 增强以下信息：\n1. $v.key$：存储在节点上的整数键。\n2. $v.count$：键 $v.key$ 的多重性。\n3. $v.left$, $v.right$：指向左右子节点的指针。\n4. $v.height$：以 $v$ 为根的子树的高度（用于平衡，例如在 AVL 树中）。\n5. $v.subtree\\_sum$：以 $v$ 为根的子树中所有键的总和（计入多重性）。\n\n关键的增强是 $v.subtree\\_sum$。这个值可以递归地进行维护。对于任意节点 $v$，其 $subtree\\_sum$ 定义为：\n$$ v.subtree\\_sum = (v.key \\times v.count) + (v.left.subtree\\_sum \\text{ if } v.left) + (v.right.subtree\\_sum \\text{ if } v.right) $$\n其中，如果子节点为空，则其子树和为 $0$。\n\n这个增强属性可以在插入和删除操作期间进行维护。当插入或删除节点，或为再平衡执行旋转时，必须更新受影响节点及其祖先的 `subtree_sum`。由于这些操作只修改从根到叶的一条路径（并在旋转时涉及常数个节点），更新过程耗时 $O(\\log n)$，从而保持了插入和删除操作的整体时间复杂度。\n\n### $\\text{Sum}(\\leq k)$ 的算法\n\n借助 `subtree_sum` 增强，我们可以通过遍历从根开始的一条路径，在 $O(\\log n)$ 时间内计算出 $\\text{Sum}(\\leq k)$。设当前节点为 `curr`，并初始化一个累计总和 `sum = 0`。\n\n从根节点开始：\n- 如果 $k  curr.key$：当前节点及其右子树中的所有键都大于 $k$。答案必然完全存在于左子树中。我们移动到左子节点：`curr = curr.left`。\n- 如果 $k > curr.key$：左子树中的所有键以及当前节点的键都小于或等于 $k$。我们将左子树的总和（`curr.left.subtree_sum`）和当前节点键的总和（`curr.key \\times curr.count`）加入到我们的累计总和中。然后，我们继续在右子树中搜索更多的键：`sum += curr.left.subtree_sum + (curr.key \\times curr.count)`，然后 `curr = curr.right`。\n- 如果 $k == curr.key$：左子树中的所有键和当前节点的键都小于或等于 $k$。右子树中的所有键都大于 $k$。因此，我们加上左子树的总和以及当前节点的总和，然后终止。`sum += curr.left.subtree_sum + (curr.key \\times curr.count)`。\n\n这个过程遍历一条单一路径，耗时 $O(\\text{height}) = O(\\log n)$。\n\n### 使用 AVL 树的实现\n\n我们将使用 AVL 树作为底层的 BBST。AVL 树通过确保任何节点的两个子树的高度差最多为 $1$ 来维持平衡。这种平衡是通过在插入和删除过程中的旋转（左旋和右旋）来维护的。每次修改和旋转后，每个节点的 `height` 和 `subtree_sum` 属性都会被更新。\n\n`insert` 操作会为键找到正确的位置。如果键已存在，其 `count` 会递增。如果不存在，则创建一个新节点。然后，在向上回溯到根的过程中，通过执行必要的旋转来重新平衡树。\n\n`delete` 操作会找到该键。如果其 `count > 1`，则递减计数。如果 `count == 1`，则使用标准的 BST 删除算法移除该节点（例如，用其中序后继替换它）。然后，树被重新平衡。\n\n`range_sum` 方法将实现逻辑 $\\text{Sum}(\\leq high) - \\text{Sum}(\\leq low - 1)$。问题规定如果 $low > high$，结果应为 $0$；这作为一个基本情况来处理。\n\n下面的 Python 实现封装了这一设计。`Node` 类持有键、计数、高度、总和以及子节点指针。`AugmentedAVLTree` 类实现了所述的操作和平衡逻辑。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\nclass Node:\n    \"\"\"Node for the Augmented AVL Tree.\"\"\"\n    def __init__(self, key):\n        self.key = key\n        self.count = 1\n        self.height = 1\n        self.subtree_sum = key\n        self.left = None\n        self.right = None\n\nclass AugmentedAVLTree:\n    \"\"\"\n    Augmented AVL Tree to support range-sum queries.\n    - Handles duplicate keys via a `count` attribute in each node.\n    - Augments nodes with `subtree_sum` for O(log n) range sum queries.\n    \"\"\"\n\n    def __init__(self):\n        self.root = None\n        self.query_results = []\n\n    def _get_height(self, node):\n        return node.height if node else 0\n\n    def _get_sum(self, node):\n        return node.subtree_sum if node else 0\n\n    def _update_node_attributes(self, node):\n        \"\"\"Updates height and subtree_sum of a node based on its children.\"\"\"\n        if not node:\n            return\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        node.subtree_sum = (node.key * node.count) + self._get_sum(node.left) + self._get_sum(node.right)\n\n    def _get_balance(self, node):\n        return self._get_height(node.left) - self._get_height(node.right) if node else 0\n\n    def _right_rotate(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        self._update_node_attributes(y)\n        self._update_node_attributes(x)\n        return x\n\n    def _left_rotate(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        self._update_node_attributes(x)\n        self._update_node_attributes(y)\n        return y\n\n    def _rebalance(self, node, key):\n        \"\"\"Rebalances the node and returns the new root of the subtree.\"\"\"\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance  1 and key  node.left.key:\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance  -1 and key  node.right.key:\n            return self._left_rotate(node)\n        # Left Right Case\n        if balance  1 and key  node.left.key:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Left Case\n        if balance  -1 and key  node.right.key:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def insert(self, key):\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if not node:\n            return Node(key)\n        \n        if key  node.key:\n            node.left = self._insert_recursive(node.left, key)\n        elif key  node.key:\n            node.right = self._insert_recursive(node.right, key)\n        else:\n            node.count += 1\n            # Only sum needs update if key exists, height and balance don't change\n            self._update_node_attributes(node)\n            return node\n        \n        return self._rebalance(node, key)\n\n    def delete(self, key):\n        self.root = self._delete_recursive(self.root, key)\n\n    def _delete_recursive(self, node, key):\n        if not node:\n            return node\n        \n        if key  node.key:\n            node.left = self._delete_recursive(node.left, key)\n        elif key  node.key:\n            node.right = self._delete_recursive(node.right, key)\n        else:\n            if node.count  1:\n                node.count -= 1\n                self._update_node_attributes(node)\n                return node\n            \n            if not node.left or not node.right:\n                temp = node.left if node.left else node.right\n                node = None\n                return temp\n            else:\n                temp = self._get_min_value_node(node.right)\n                node.key = temp.key\n                node.count = temp.count\n                # Set count to 1 to ensure standard deletion of successor\n                temp.count = 1\n                node.right = self._delete_recursive(node.right, temp.key)\n        \n        if not node:\n            return node # Tree was empty or node became null\n\n        # Rebalance the node\n        self._update_node_attributes(node)\n        balance = self._get_balance(node)\n\n        # Left Left Case\n        if balance  1 and self._get_balance(node.left) = 0:\n            return self._right_rotate(node)\n        # Left Right Case\n        if balance  1 and self._get_balance(node.left)  0:\n            node.left = self._left_rotate(node.left)\n            return self._right_rotate(node)\n        # Right Right Case\n        if balance  -1 and self._get_balance(node.right) = 0:\n            return self._left_rotate(node)\n        # Right Left Case\n        if balance  -1 and self._get_balance(node.right)  0:\n            node.right = self._right_rotate(node.right)\n            return self._left_rotate(node)\n        \n        return node\n\n    def _get_min_value_node(self, node):\n        current = node\n        while current.left is not None:\n            current = current.left\n        return current\n\n    def range_sum(self, low, high):\n        if low  high:\n            return 0\n        sum_high = self._sum_le(high)\n        sum_low_minus_1 = self._sum_le(low - 1)\n        return sum_high - sum_low_minus_1\n\n    def _sum_le(self, k):\n        \"\"\"Returns the sum of all keys less than or equal to k.\"\"\"\n        current = self.root\n        total_sum = 0\n        while current:\n            if k  current.key:\n                current = current.left\n            elif k  current.key:\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                current = current.right\n            else: # k == current.key\n                total_sum += self._get_sum(current.left) + (current.key * current.count)\n                break\n        return total_sum\n    \n    def process_query(self, low, high):\n        result = self.range_sum(low, high)\n        self.query_results.append(result)\n\ndef solve():\n    all_results = []\n\n    # Scenario A\n    tree_a = AugmentedAVLTree()\n    for key in [5, 3, 8, 1, 4, 7, 9]:\n        tree_a.insert(key)\n    tree_a.process_query(3, 8)\n    tree_a.delete(4)\n    tree_a.process_query(3, 8)\n    all_results.extend(tree_a.query_results)\n\n    # Scenario B\n    tree_b = AugmentedAVLTree()\n    tree_b.process_query(0, 10)\n    tree_b.insert(-2)\n    tree_b.process_query(-5, -1)\n    tree_b.process_query(2, 1) # Invalid range\n    all_results.extend(tree_b.query_results)\n\n    # Scenario C\n    tree_c = AugmentedAVLTree()\n    for key in [2, 2, 2, 3, 3, 10]:\n        tree_c.insert(key)\n    tree_c.process_query(2, 3)\n    tree_c.delete(2)\n    tree_c.process_query(2, 2)\n    all_results.extend(tree_c.query_results)\n\n    # Scenario D\n    tree_d = AugmentedAVLTree()\n    for key in [0, -5, 5, 1]:\n        tree_d.insert(key)\n    tree_d.process_query(-10, 10)\n    tree_d.delete(1)\n    tree_d.process_query(-10, 10)\n    all_results.extend(tree_d.query_results)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, all_results))}]\")\n\nsolve()\n```", "id": "3210369"}]}