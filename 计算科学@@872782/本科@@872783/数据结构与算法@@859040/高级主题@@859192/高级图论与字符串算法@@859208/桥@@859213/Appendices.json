{"hands_on_practices": [{"introduction": "在深入研究寻找桥的复杂算法之前，我们首先需要巩固一些基本概念。一个常见的直觉是，如果网络中每个节点都至少有两个连接（即图的最小度 $\\delta(G) \\ge 2$），那么网络就是冗余的，不存在单点故障。这个练习 [@problem_id:1487123] 旨在挑战并澄清这一误解，通过分析最小度与桥的存在性之间的真实关系，帮助你建立更严谨的图论直觉。", "problem": "一位网络架构师正在设计一个新的鲁棒通信网络。该网络的拓扑结构被建模为一个简单连通图 $G=(V, E)$，其中顶点集合 $V$ 代表数据中心，边集合 $E$ 代表高带宽光纤链路。如果移除某条链路会导致网络断开成两个或更多个独立的连通分量，则该链路被视为“单点故障”。在图论中，这样的边被称为桥。\n\n该架构师正在探索与顶点度相关的各种设计约束，以增强网络的弹性。一个顶点的度是连接到该顶点的链路数量。图的最小度，记为 $\\delta(G)$，是图中所有顶点的最小度数。架构师希望理解网络图的最小度与桥可能存在性之间的基本关系。\n\n对于任何至少有两个顶点的简单连通图 $G$，以下哪个陈述正确地描述了这种关系？\n\nA. 一个连通图 $G$ 没有桥，当且仅当其最小度 $\\delta(G) \\geq 2$。\n\nB. 如果一个连通图 $G$ 有桥，那么它的最小度 $\\delta(G)$ 必须为 1。\n\nC. 对于任何整数 $k \\geq 1$，都可以构造一个有桥的连通图 $G$，使得 $G$ 的最小度恰好为 $k$。\n\nD. 如果一条边是连通图 $G$ 中的桥，那么它的至少一个端点的度必须为 1。\n\nE. 任何最小度 $\\delta(G) \\geq 2$ 的连通图 $G$ 都不能包含桥。", "solution": "我们回顾一下定义。在一个简单连通图 $G=(V,E)$ 中，如果移除边 $e \\in E$ 会增加连通分量的数量，则 $e$ 是一条桥。最小度为 $\\delta(G)=\\min_{v \\in V}\\deg(v)$。\n\n逐一评估每个陈述：\n\nA. 陈述：“$G$ 没有桥当且仅当 $\\delta(G) \\geq 2$。” 正向命题是正确的：如果 $G$ 没有桥，那么没有顶点的度可以为 $1$，因为如果存在一个度为 $\\deg(u)=1$ 的顶点 $u$，那么它唯一的关联边将是一个桥，这产生矛盾。因此 $\\delta(G) \\geq 2$。反向命题是错误的。反例：取两个圈，用一条边将它们连接起来。形式上，设 $G$ 是由两个不相交的圈 $C_{m}$ 和 $C_{n}$，通过添加一条边 $xy$ 得到的，其中 $x \\in V(C_{m})$ 且 $y \\in V(C_{n})$。那么 $\\delta(G)=2$，但添加的边 $xy$ 是两部分之间唯一的连接，所以 $xy$ 是一个桥。因此 A 是错误的。\n\nB. 陈述：“如果 $G$ 有一个桥，那么 $\\delta(G)=1$。” 这是错误的。与上面相同的反例有一个桥 $xy$，而其 $\\delta(G)=2$。因此 B 是错误的。\n\nC. 陈述：“对于任何整数 $k \\geq 1$，存在一个有桥的连通图 $G$，且 $\\delta(G)=k$。” 构造方法：\n- 对于 $k=1$，任何至少有两个顶点的树都是连通的，有桥，且 $\\delta(G)=1$。\n- 对于 $k \\geq 2$，取两个连通的 $k$-正则图（例如，两个 $K_{k+1}$ 的副本，$K_{k+1}$ 是 $k$-正则的）。从每个副本中各选一个顶点，并在它们之间添加一条边。生成的图是连通的；添加的边是两个副本之间唯一的互连，因此它是一个桥。所选端点的度增加到 $k+1$，而所有其他顶点的度仍为 $k$，所以最小度保持为 $\\delta(G)=k$。因此 C 是正确的。\n\nD. 陈述：“如果一条边是桥，那么它的至少一个端点的度为 $1$。” 这是错误的。在前面用一条边连接两个圈（或两个三角形）的构造中，桥的端点度至少为 $2$（在两个三角形的例子中实际上是 $3$），而不是 $1$。因此 D 是错误的。\n\nE. 陈述：“任何最小度 $\\delta(G) \\geq 2$ 的连通图都不包含桥。” 这是 A 中正确命题的逆命题，并且可以被用于 A 和 B 的同一个反例所证伪。因此 E 是错误的。\n\n因此，唯一正确的陈述是 C。", "answer": "$$\\boxed{C}$$", "id": "1487123"}, {"introduction": "掌握了桥的基本性质后，我们转向一个更具实践性的挑战：如何在图中系统地找出所有的桥。这个问题 [@problem_id:3218710] 将引导你实现一个核心算法，用于在一个带权图中识别所有桥，并根据特定标准（权重和端点）找出所谓的“薄弱环节”。这项练习是网络可靠性分析中的一项基本技能，让你从理论走向代码实现。", "problem": "给定一个由有限的顶点和边集描述的无向加权图。设图为 $G = (V, E)$，其权重函数为 $w : E \\to \\mathbb{N}$，其中 $\\mathbb{N}$ 是非负整数集。每条边 $e \\in E$ 连接两个顶点 $u, v \\in V$，并具有一个相关的整数权重 $w(e)$。允许在同一对无序顶点之间存在多条边，且图可能是不连通的。顶点由从 $0$ 到 $n-1$ 的连续整数标记，其中 $n = |V|$。\n\n如果从 $G$ 中移除一条边 $e \\in E$ 会增加 $G$ 的连通分量数量，则称该边为桥。形式上，如果图 $G' = (V, E \\setminus \\{e\\})$ 的连通分量数量严格多于 $G$，则 $e$ 是一座桥。定义 $G$ 的“最弱一环”为权重最小的桥。如果有多座权重相同的最小权重桥，则选择其无序端点对（按升序排列）在字典序上最小的那一座。如果仍然存在平局（例如，具有相同无序端点和相同权重的平行边），则选择在给定输入顺序中最早出现的边。\n\n您的任务是编写一个程序，从无向图、连通性和深度优先搜索（DFS）的核心定义出发，推导并实现一种方法来确定桥的集合，并根据上述规则选出最弱一环。对于每个测试用例，程序必须返回最弱一环的端点和权重，形式为列表 $[u, v, w]$，其中 $u  v$；如果不存在桥，则返回一个空列表 $[]$。\n\n输入不是交互式提供的；相反，您的程序必须嵌入并使用以下测试套件。每个测试用例指定了 $n$ 和一个由三元组 $(u, v, w)$ 组成的边列表，其中 $u$ 和 $v$ 是满足 $0 \\le u, v \\le n-1$ 的整数，且 $w \\in \\mathbb{N}$。\n\n测试套件：\n- 测试用例 1（包含环和叶节点的正常路径）：$n = 5$，边 $= [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]$。\n- 测试用例 2（没有桥：一个简单环）：$n = 3$，边 $= [(0, 1, 7), (1, 2, 8), (2, 0, 9)]$。\n- 测试用例 3（路径图，所有边都是桥）：$n = 4$，边 $= [(0, 1, 7), (1, 2, 1), (2, 3, 5)]$。\n- 测试用例 4（包含一个环和一个单边分量的不连通图）：$n = 5$，边 $= [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]$。\n- 测试用例 5（平行边；只有叶节点的边是桥）：$n = 3$，边 $= [(0, 1, 1), (0, 1, 2), (1, 2, 4)]$。\n- 测试用例 6（权重相同，通过端点的字典序解决）：$n = 4$，边 $= [(0, 1, 3), (2, 3, 3)]$。\n\n您的程序应生成单行输出，其中包含所有测试用例的结果，形式为一个用方括号括起来的逗号分隔列表，其中每个元素要么是空列表 $[]$，要么是定义的列表 $[u, v, w]$。例如，三个测试用例的有效输出应类似于 $[[u_1, v_1, w_1],[],[u_3, v_3, w_3]]$。", "solution": "问题陈述已解析并确定为有效。它在图论和算法领域内提出了一个明确定义的任务，并提供了所有必要的条件和数据。桥和“最弱一环”的定义是精确且可形式化的。\n\n任务是识别给定无向加权图 $G = (V, E)$ 中的“最弱一环”。这被定义为权重最小的桥，并有针对字典序最小的端点和最早输入顺序的特定平局打破规则。\n\n桥是一条边，其移除会增加图中连通分量的数量。寻找图中所有桥的标准算法基于深度优先搜索（DFS）遍历。从第一性原理推导此方法的过程如下。\n\n对图 $G$ 进行 DFS 遍历会将其边分为两类：树边（构成一个 DFS 生成森林）和回边（将一个顶点连接到其在 DFS 树中的一个祖先，不包括其直接父节点）。一条边 $(u, v)$（其中 $u$ 是 $v$ 在 DFS 树中的父节点）是桥，当且仅当不存在从以 $v$ 为根的子树中的任何顶点到 $u$ 或其任何祖先的回边。这种回边的存在意味着存在从 $v$ 回到 $u$ 的替代路径（从而形成一个环），这意味着移除树边 $(u, v)$ 不会使图断开。\n\n这个原理可以通过在 DFS 期间为每个顶点 $u$ 跟踪两个关键值来形式化：\n1. 发现时间 `disc[u]`：一个时间戳（一个单调递增的计数器），记录 $u$ 首次被访问的时间。\n2. 低链接值 `low[u]`：从 $u$（包括其自身）出发，通过遍历其子树中零条或多条树边，然后再经过至多一条回边所能到达的最低发现时间。\n\n该算法通过一个递归的 DFS 函数进行。对于每个顶点 $u$，我们初始化 `low[u] = disc[u]`。然后，对于 $u$ 的每个邻居 $v$：\n- 如果 $v$ 已被访问过，则边 $(u, v)$ 是一条回边。顶点 $u$ 可以到达一个祖先或一个已访问过的节点，因此我们更新其低链接值：`low[u] = min(low[u], disc[v])`。\n- 如果 $v$ 未被访问过，则 $(u, v)$ 是一条树边。我们执行一个递归调用 `dfs(v)`。从递归返回后，整个以 $v$ 为根的子树的 `low[v]` 值已被计算出来。顶点 $u$ 可以到达 $v$ 所能到达的所有地方，因此我们相应地更新 `low[u]`：`low[u] = min(low[u], low[v])`。\n\n此更新后，我们应用桥的条件。边 $(u, v)$ 是桥当且仅当 `low[v] > disc[u]`。这个不等式表示从以 $v$ 为根的子树能到达的最早的顶点是 $v$ 本身。没有从 $v$ 的子树到 $u$ 或其任何祖先的回边。因此，移除边 $(u, v)$ 将把以 $v$ 为根的子树与图的其余部分分离开，从而增加连通分量的数量。\n\n此问题的特殊考虑：\n- **多重边**：图可能包含平行边。在 DFS 中简单的父顶点检查（即 `if v == parent`）是不够的，因为它会错误地忽略所有指向父节点的平行边，而不仅仅是用于遍历的那一条。这里采用了一种更鲁棒的方法，即向递归调用传递父边的索引，并仅忽略该特定边，从而正确地将平行边识别为可能形成环的回边。\n- **不连通图**：主过程必须遍历从 $0$ 到 $n-1$ 的所有顶点，并从未访问过的顶点开始 DFS，以确保所有连通分量都被遍历。\n\n整体算法如下：\n1. 用它们的原始索引 $0, 1, 2, \\dots$ 来增强输入边，以便于最终的平局打破规则。\n2. 构建图的邻接表表示，其中每个条目存储邻居、权重和原始边索引。\n3. 初始化 `disc`、`low` 和 `visited` 数组。\n4. 遍历所有顶点。如果一个顶点未被访问，则从它开始修改后的 DFS。\n5. DFS 函数使用 `low[v] > disc[u]` 条件识别所有桥。每个发现的桥都存储为一个元组，包含其权重、按升序排序的端点和其原始索引：$(w, u_{sorted}, v_{sorted}, \\text{index})$。\n6. 遍历完成后，如果未找到桥，则结果为空列表。\n7. 否则，对发现的桥列表进行排序。Python 的默认元组排序机制自然地实现了所需的多级排序标准：首先按权重，然后按第一个端点，接着按第二个端点，最后按原始索引。\n8. 排序后列表的第一个元素就是“最弱一环”。其端点和权重被格式化为所需的输出列表 $[u, v, w]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef find_weakest_link(n, edges):\n    \"\"\"\n    Finds the \"weakest link\" in a graph, defined as the bridge with the minimum\n    weight, with specific tie-breaking rules.\n    \"\"\"\n    if n == 0 or not edges:\n        return []\n\n    # Adjacency list: adj[u] -> list of (v, w, edge_idx)\n    adj = [[] for _ in range(n)]\n    for i, (u, v, w) in enumerate(edges):\n        # We assume u and v are valid vertex indices\n        adj[u].append((v, w, i))\n        adj[v].append((u, w, i))\n\n    # Tarjan's bridge-finding algorithm data structures\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    time = 0\n    bridges = []\n\n    def dfs(u, parent_edge_idx):\n        \"\"\"\n        Performs Depth-First Search to find bridges.\n        \n        Args:\n            u: The current vertex.\n            parent_edge_idx: The index of the edge used to arrive at u. This is\n                             used to handle multigraphs correctly, preventing the\n                             traversal from immediately going back on the same edge.\n        \"\"\"\n        nonlocal time\n        disc[u] = low[u] = time\n        time += 1\n\n        for v, w, edge_idx in adj[u]:\n            if edge_idx == parent_edge_idx:\n                continue\n\n            if disc[v] != -1:  # v is a visited vertex (back edge)\n                low[u] = min(low[u], disc[v])\n            else:  # v is an unvisited vertex (tree edge)\n                dfs(v, edge_idx)\n                low[u] = min(low[u], low[v])\n\n                if low[v] > disc[u]:\n                    # The edge (u, v) is a bridge.\n                    # Sort endpoints for lexicographical comparison.\n                    u_sorted, v_sorted = sorted((u, v))\n                    # Store tuple for sorting: (weight, u, v, original_index)\n                    bridges.append((w, u_sorted, v_sorted, edge_idx))\n    \n    # Iterate through all vertices to handle disconnected graphs\n    for i in range(n):\n        if disc[i] == -1:\n            dfs(i, -1)\n    \n    if not bridges:\n        return []\n\n    # Sort according to the problem's tie-breaking rules:\n    # 1. Minimum weight (primary key)\n    # 2. Lexicographically minimal endpoint pair (secondary keys u, then v)\n    # 3. Earliest edge in input order (tertiary key, edge_idx)\n    # Python's default tuple sorting handles this hierarchy correctly.\n    bridges.sort()\n\n    weakest = bridges[0]\n    w, u, v, _ = weakest\n    return [u, v, w]\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the solver for each case, and prints the results.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5, [(0, 1, 5), (1, 2, 2), (2, 3, 10), (1, 3, 4), (3, 4, 3)]),\n        (3, [(0, 1, 7), (1, 2, 8), (2, 0, 9)]),\n        (4, [(0, 1, 7), (1, 2, 1), (2, 3, 5)]),\n        (5, [(0, 1, 5), (1, 2, 6), (2, 0, 4), (3, 4, 8)]),\n        (3, [(0, 1, 1), (0, 1, 2), (1, 2, 4)]),\n        (4, [(0, 1, 3), (2, 3, 3)]),\n    ]\n\n    results = []\n    for n, edges in test_cases:\n        result = find_weakest_link(n, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    # The str() function for a list automatically adds spaces, e.g., '[1, 2, 4]'.\n    # This matches the example output format style.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218710"}, {"introduction": "识别桥的能力是一项强大的工具，可以用于解决更复杂的图论问题。在最后的这个练习 [@problem_id:3218591] 中，你将综合运用已学知识，设计一个更智能的路径规划算法。该算法的目标是找到一条在穿越最少数量的桥的前提下，长度也最短的路径，这在设计高鲁棒性的通信或运输网络中是一个至关重要的考量。", "problem": "给定一个无向简单图，其顶点编号从 $0$ 到 $n-1$，以及一个无权边集。如果移除一条边会增加图的连通分量数量，则该边被称为桥。对于给定的两个顶点 $u$ 和 $v$，定义一条从 $u$ 到 $v$ 的路径的目标为一个字典序有序对 $(b, \\ell)$，其中 $b$ 是路径上的桥边数量，$\\ell$ 是路径上的边数。目标是选择一条从 $u$ 到 $v$ 的最优路径，最优的定义如下：首先最小化 $b$，然后在所有具有最小 $b$ 值的路径中，最小化 $\\ell$。如果 $u$ 和 $v$ 不连通，则要求输出为序对 $(-1,-1)$。\n\n仅使用无向图、连通分量和桥的基本定义。您必须实现一个完整的程序，对下面的每个测试用例，计算所定义的最优序对 $(b,\\ell)$。如果指定的 $u$ 和 $v$ 之间没有路径，则为该测试用例输出 $(-1,-1)$。\n\n您的程序必须生成单行输出，其中包含与测试用例相对应的结果列表，每个结果是该测试用例的序对 $[b,\\ell]$。格式必须是单个列表的列表，例如 $[[b_1,\\ell_1],[b_2,\\ell_2],\\dots]$。\n\n使用的测试套件：\n- 测试用例 1：\n  - $n=8$\n  - 边集 $\\{(0,1),(1,2),(2,3),(3,0),(1,7),(3,4),(4,5),(5,6),(6,4)\\}$\n  - $u=0$, $v=5$\n- 测试用例 2：\n  - $n=5$\n  - 边集 $\\{(0,1),(1,2),(2,3),(3,4),(4,0)\\}$\n  - $u=0$, $v=3$\n- 测试用例 3：\n  - $n=4$\n  - 边集 $\\{(0,1),(2,3)\\}$\n  - $u=0$, $v=3$\n- 测试用例 4：\n  - $n=7$\n  - 边集 $\\{(0,1),(1,2),(1,3),(3,4),(3,5),(5,6)\\}$\n  - $u=2$, $v=6$\n- 测试用例 5：\n  - $n=3$\n  - 边集 $\\{(0,1),(1,2)\\}$\n  - $u=1$, $v=1$\n\n最终输出格式：\n- 您的程序应精确打印一行，该行为一个列表的列表，其中每个内部列表是对应于上述顺序的测试用例的 $[b,\\ell]$。对于不可达的顶点对，使用 $[-1,-1]$。例如，一个有效的输出形如 $[[0,3],[1,4],[-1,-1]]$。", "solution": "用户提出的问题是图论中一个明确定义的练习，具体要求基于字典序目标函数计算两个顶点之间的最优路径。该问题在科学上是合理的，自洽的，并且是算法上可解的。\n\n目标是找到一条从源顶点 $u$ 到目标顶点 $v$ 的路径，该路径能最小化序对 $(b, \\ell)$，其中 $b$ 是路径上的桥数量，$\\ell$ 是总边数（路径长度）。最小化是按字典序进行的，意味着首要目标是最小化 $b$，次要目标是在所有具有最小 $b$ 值的路径中最小化 $\\ell$。\n\n这个问题可以建模为一个加权图上的最短路问题，其中遍历一条边的“权重”不是单个标量，而是一个值的序对。设遍历一条边 $(x, y)$ 的成本为一个序对 $(w_b, w_\\ell)$，其中如果该边是桥，则 $w_b=1$，否则 $w_b=0$；对于所有边，$w_\\ell=1$。一条路径的总成本是其构成边的成本的按分量求和。问题就变成了找到一条从 $u$ 到 $v$ 的路径，其总成本在字典序上最小。\n\n解决方案策略包括两个主要阶段：\n1.  **桥的识别**：预处理图以识别所有桥边。\n2.  **最优路径搜索**：使用一种改进的最短路算法来找到最小化字典序成本 $(b, \\ell)$ 的路径。\n\n**阶段 1：桥的识别**\n\n在无向图中，桥是一条移除后会增加连通分量数量的边。一个标准且高效的用于在图中寻找所有桥的算法是基于深度优先搜索 (DFS) 遍历。在 DFS 期间，我们为每个顶点 $i$ 维护两个值：\n-   `disc[i]`：顶点 $i$ 的“发现时间”，即首次访问 $i$ 时的时间（一个在每次访问顶点时递增的计数器）。\n-   `low[i]`：顶点 $i$ 的“low-link”值，即从 $i$（包括其自身）通过 DFS 树可达的最小发现时间，可能需要通过遍历一条“返祖边”到一个祖先节点。\n\n算法过程如下：\n我们为所有顶点初始化发现时间、low-link 值和父节点跟踪器。我们从 $0$ 到 $n-1$ 遍历每个顶点。如果一个顶点尚未被访问，我们从它开始进行 DFS。\n\n在用于顶点 $u$（其父节点为 $p$）的递归 DFS 函数中：\n1.  将 $u$ 标记为已访问。将 `disc[u]` 和 `low[u]` 设置为当前时间，并增加时间计数器。\n2.  对于 $u$ 的每个邻居 $v$：\n    a. 如果 $v$ 是父节点 $p$，则忽略它。\n    b. 如果 $v$ 已被访问（且不是父节点），这意味着存在一条从 $u$ 到祖先 $v$ 的返祖边。这条返祖边表示存在一个环。我们更新 `low[u]` 如下：$low[u] = \\min(low[u], disc[v])$。\n    c. 如果 $v$ 未被访问，我们将 $p$ 设置为 $v$ 的父节点，并对 $v$ 递归调用 DFS。递归调用返回后，我们根据其子节点 $v$ 的 low-link 值更新 `low[u]`：$low[u] = \\min(low[u], low[v])$。\n    d. 桥检测的关键步骤：如果 $low[v] > disc[u]$，则边 $(u, v)$ 是一个桥。这个条件意味着从以 $v$ 为根的子树能到达的最早的顶点是 $v$ 本身，并且从该子树没有返祖边连接到 $u$ 的任何祖先。因此，移除边 $(u, v)$ 会将 $v$ 及其后代与 $u$ 断开。\n\n我们将所有这样识别出的桥收集到一个集合中，以便在下一阶段进行高效查找。\n\n**阶段 2：最优路径搜索**\n\n在识别出桥的集合后，我们可以开始寻找最优路径。这是一个带有向量值成本函数的最短路问题，可以使用 Dijkstra 算法解决，但需要修改以处理字典序比较。\n\n算法如下：\n1.  为所有顶点初始化一个距离数据结构 `dist`。`dist[i]` 将存储迄今为止找到的从 $u$到 $i$ 的路径的字典序最小的序对 $(b, \\ell)$。我们初始化 `dist[u] = (0, 0)`，对于所有其他顶点 $i \\neq u$，初始化 `dist[i] = (\\infty, \\infty)$。\n2.  使用一个最小优先队列来存储形如 $(b, \\ell, \\text{vertex})$ 的元组。优先队列会自然地根据序对 $(b, \\ell)$ 对元素进行字典序排序。\n3.  将起始元组 $(0, 0, u)$ 推入优先队列。\n4.  当优先队列不为空时：\n    a. 提取具有最小字典序成本的元素：$(b_{curr}, \\ell_{curr}, v_{curr})$。\n    b. 如果 $(b_{curr}, \\ell_{curr})$ 在字典序上大于当前已知的 `dist[v_{curr}]`，这意味着我们之前已经找到了到 $v_{curr}$ 的更优路径。我们跳过此条目并继续。\n    c. 对于 $v_{curr}$ 的每个邻居 $v_{next}$：\n        i. 确定边 $(v_{curr}, v_{next})$ 的成本。如果它是桥，则成本为 $(1, 1)$。否则，成本为 $(0, 1)$。设此成本为 $(b_{edge}, \\ell_{edge})$。\n        ii. 计算到 $v_{next}$ 的新路径的成本：$(b_{new}, \\ell_{new}) = (b_{curr} + b_{edge}, \\ell_{curr} + \\ell_{edge})$。\n        iii. 将这个新成本与当前已知的 $v_{next}$ 的最佳成本 `dist[v_{next}]` 进行比较。如果 $(b_{new}, \\ell_{new})$ 在字典序上小于 `dist[v_{next}]`，我们就找到了一个更优的路径。\n        iv. 更新 `dist[v_{next}] = (b_{new}, \\ell_{new})$ 并将新元组 $(b_{new}, \\ell_{new}, v_{next})$ 推入优先队列。\n\n5.  算法终止后，`dist[v]` 将包含到目标顶点 $v$ 的最优序对 $(b, \\ell)$。如果 `dist[v]` 仍然是 $(\\infty, \\infty)$，这意味着 $v$ 从 $u$ 不可达，结果为 $(-1, -1)$。特殊情况 $u=v$ 通过初始化 `dist[u]=(0,0)` 得到正确处理，产生一个成本为 $(0,0)$ 的路径。这个过程保证能找到最优路径，因为与标准的 Dijkstra 算法一样，它按“距离”（在此例中为字典序成本）的递增顺序探索顶点。", "answer": "```python\nimport numpy as np\nimport heapq\nfrom collections import defaultdict\nimport sys\n\n# It is good practice to increase the recursion limit for deep graphs in DFS.\nsys.setrecursionlimit(2000)\n\ndef find_optimal_path(n, edges, u, v):\n    \"\"\"\n    Finds the optimal path from u to v based on lexicographical minimization of (bridges, length).\n    \"\"\"\n    if u == v:\n        return [0, 0]\n\n    adj = defaultdict(list)\n    for x, y in edges:\n        adj[x].append(y)\n        adj[y].append(x)\n\n    # --- Phase 1: Find all bridges using Tarjan's bridge-finding algorithm ---\n    \n    # Using numpy arrays for performance with large N.\n    disc = np.full(n, -1, dtype=int)\n    low = np.full(n, -1, dtype=int)\n    parent = np.full(n, -1, dtype=int)\n    visited = np.full(n, False, dtype=bool)\n    \n    bridges = set()\n    time = 0\n\n    def find_bridges_dfs(curr_node):\n        nonlocal time\n        visited[curr_node] = True\n        disc[curr_node] = low[curr_node] = time\n        time += 1\n\n        for neighbor in adj[curr_node]:\n            if neighbor == parent[curr_node]:\n                continue\n            if visited[neighbor]:\n                low[curr_node] = min(low[curr_node], disc[neighbor])\n            else:\n                parent[neighbor] = curr_node\n                find_bridges_dfs(neighbor)\n                low[curr_node] = min(low[curr_node], low[neighbor])\n                if low[neighbor] > disc[curr_node]:\n                    # The edge (curr_node, neighbor) is a bridge.\n                    # Store it in a canonical form (smaller, larger) for easy lookup.\n                    bridge_edge = tuple(sorted((curr_node, neighbor)))\n                    bridges.add(bridge_edge)\n\n    # The graph might be disconnected, so we iterate through all vertices.\n    for i in range(n):\n        if not visited[i]:\n            find_bridges_dfs(i)\n\n    # --- Phase 2: Modified Dijkstra's algorithm for lexicographical shortest path ---\n    \n    # dist[i] will store the pair (number_of_bridges, length)\n    dist = {i: (float('inf'), float('inf')) for i in range(n)}\n    dist[u] = (0, 0)\n\n    # Priority queue stores (bridges, length, vertex)\n    pq = [(0, 0, u)]\n\n    while pq:\n        b_curr, l_curr, v_curr = heapq.heappop(pq)\n\n        # If we found a better path already, skip\n        if (b_curr, l_curr) > dist[v_curr]:\n            continue\n\n        if v_curr == v:\n            # Since Dijkstra explores paths in increasing cost order,\n            # the first time we reach v, it's via an optimal path.\n            break\n\n        for v_next in adj[v_curr]:\n            edge = tuple(sorted((v_curr, v_next)))\n            b_edge = 1 if edge in bridges else 0\n            l_edge = 1\n            \n            b_new = b_curr + b_edge\n            l_new = l_curr + l_edge\n\n            # Lexicographical comparison\n            if (b_new, l_new)  dist[v_next]:\n                dist[v_next] = (b_new, l_new)\n                heapq.heappush(pq, (b_new, l_new, v_next))\n\n    final_dist = dist[v]\n    if final_dist == (float('inf'), float('inf')):\n        return [-1, -1]\n    else:\n        return [final_dist[0], final_dist[1]]\n\ndef solve():\n    \"\"\"\n    Main function to run all test cases and print the results.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        {'n': 8, 'edges': {(0, 1), (1, 2), (2, 3), (3, 0), (1, 7), (3, 4), (4, 5), (5, 6), (6, 4)}, 'u': 0, 'v': 5},\n        # Test case 2\n        {'n': 5, 'edges': {(0, 1), (1, 2), (2, 3), (3, 4), (4, 0)}, 'u': 0, 'v': 3},\n        # Test case 3\n        {'n': 4, 'edges': {(0, 1), (2, 3)}, 'u': 0, 'v': 3},\n        # Test case 4\n        {'n': 7, 'edges': {(0, 1), (1, 2), (1, 3), (3, 4), (3, 5), (5, 6)}, 'u': 2, 'v': 6},\n        # Test case 5\n        {'n': 3, 'edges': {(0, 1), (1, 2)}, 'u': 1, 'v': 1},\n    ]\n\n    results = []\n    for case in test_cases:\n        result = find_optimal_path(case['n'], case['edges'], case['u'], case['v'])\n        results.append(result)\n\n    # The final output must be a single line in the specified format.\n    # We use join and map to construct the string representation of the list of lists.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3218591"}]}