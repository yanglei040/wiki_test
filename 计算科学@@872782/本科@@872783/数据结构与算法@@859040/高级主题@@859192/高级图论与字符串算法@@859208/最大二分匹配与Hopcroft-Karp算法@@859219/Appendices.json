{"hands_on_practices": [{"introduction": "理论学习之后，最好的检验方式就是亲手实现。这个练习将引导你将增广路和 Hopcroft-Karp 算法的理论知识转化为实际的代码。通过解决一个经典的“特工分配任务”问题，你将从头开始构建一个高效的二分图最大匹配求解器，这是掌握该算法核心机制的关键一步。[@problem_id:3250161]", "problem": "给定一个二分图族，表示哪些代理人可以执行哪些任务。在具体的情境中，一群间谍必须获取一组机密。每名间谍只能尝试获取一项机密，每项机密最多只能由一名间谍获取。如果一名间谍有能力获取某项机密，则在该间谍和该机密之间存在一条边。形式上，考虑一个二分图 $G = (U,V,E)$，其中 $U$ 是间谍集合，$V$ 是机密集合，$E \\subseteq U \\times V$ 是可能的获取关系集合。一个匹配 $M \\subseteq E$ 是一组两两不相邻的边，其大小为 $|M|$。二分图最大匹配问题旨在找到一个基数尽可能大的匹配。\n\n您应使用的基本依据是图论和算法理论中的以下核心定义和事实：\n- 一个二分图 $G = (U,V,E)$ 拥有顶点集 $U$ 和 $V$，满足 $U \\cap V = \\varnothing$，且所有边都只连接 $U$ 和 $V$ 中的顶点。\n- 一个匹配 $M$ 是一个边的子集，其中任意两条边都不共享端点。\n- 相对于匹配 $M$ 的一条增广路是一条简单路径，其起点和终点均为未匹配顶点，且路径上的边交替地属于 $M$ 和不属于 $M$。如果存在增广路，沿其增广会严格增加 $|M|$ 的值。\n\n您的任务是编写一个完整的程序，对每个测试用例，计算可以同时窃取的最大机密数量，该数量等于最大匹配的大小。该程序应实现一种基于增广路和层次图概念的算法，该算法适合高效地在二分图中寻找最大匹配。\n\n对于下方的每个测试用例，间谍的索引范围为整数 $[0, n-1]$，机密的索引范围为整数 $[0, m-1]$，集合 $E$ 以有序对 $(u,v)$ 的集合形式给出，其中 $u \\in U$ 且 $v \\in V$。如果出现重复的有序对，其效果与单条边相同，应被视为单个连接。\n\n要求的最终输出格式为单行，其中包含一个由方括号括起来的逗号分隔的整数列表，按测试用例的顺序排列，每个整数是相应测试用例的最大匹配的大小。例如，一个有效的输出可能看起来像 $[3,0,4]$。\n\n此问题不涉及物理单位、角度或百分比。所有输出都必须是整数。\n\n测试套件：\n- 测试用例 $1$ (一般情况)：$n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$。\n- 测试用例 $2$ (无边的边界情况)：$n = 3$, $m = 4$, $E = \\varnothing$。\n- 测试用例 $3$ (存在完美匹配)：$n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$。\n- 测试用例 $4$ (机密有限的不平衡图)：$n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$。\n- 测试用例 $5$ (不相交的组件和重复的边)：$n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$。\n- 测试用例 $6$ (链状结构，允许多条最短增广路)：$n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$。\n\n您的程序应生成单行输出，其中包含按测试用例顺序排列、由方括号括起来的逗号分隔的结果列表。例如，输出应精确地像 $[r_1,r_2,r_3,r_4,r_5,r_6]$，其中每个 $r_i$ 是测试用例 $i$ 的最大匹配大小。", "solution": "我们从标准的图论基础开始：对于一个二分图 $G = (U,V,E)$，一个匹配 $M \\subseteq E$ 是一组没有共享端点的边，而一条关于 $M$ 的增广路是一条简单路径，其起点和终点均为未匹配顶点，并且路径上的边在“不属于 $M$”和“属于 $M$”之间交替出现。一个经典且经过充分检验的事实是：如果存在关于匹配 $M$ 的增广路，那么沿着它进行增广会严格增加匹配的基数；反之，一个匹配是最大匹配当且仅当不存在增广路。\n\n为了高效地计算最大匹配，可以在每次迭代中寻找多条顶点不相交的最短增广路，而不是一次只寻找一条。Hopcroft–Karp 算法利用了这一思想，它通过广度优先搜索（BFS, Breadth-First Search）从 $U$ 中所有当前未匹配的顶点同时开始构建一个层次图，找出到 $V$ 中未匹配顶点的最短距离，然后执行深度优先搜索（DFS, Depth-First Search），该搜索仅限于已发现的 BFS 层次，以找到一个顶点不相交的最短增广路的最大集合。每次增广都会增加匹配的大小，而 BFS 确保后续增广路的长度在不同阶段中严格增加，从而得到最坏情况下的时间复杂度为 $O(|E| \\sqrt{|U| + |V|})$。\n\n算法设计详述：\n1. 使用邻接表表示二分图：对于 $U$ 中的每个顶点 $u$，维护一个从输入对中去重得到的邻居集合 $N(u) \\subseteq V$。\n2. 维护两个匹配数组：$\\mathrm{pairU}[u]$ 给出与 $u$ 匹配的 $V$ 中机密的索引，如果未匹配则为 $-1$；$\\mathrm{pairV}[v]$ 给出与 $v$ 匹配的 $U$ 中间谍的索引，如果未匹配则为 $-1$。\n3. 执行 BFS 阶段：\n   - 初始化一个距离数组 $\\mathrm{dist}[u]$，将所有 $u \\in U$ 的距离设为 $\\infty$。\n   - 对每个自由（未匹配）的 $u \\in U$，设置 $\\mathrm{dist}[u] = 0$ 并将 $u$ 入队。\n   - 对每个出队的 $u$，遍历其每个邻居 $v \\in N(u)$：\n     - 如果 $v$ 与某个 $u' = \\mathrm{pairV}[v]$ 匹配，并且 $\\mathrm{dist}[u']$ 为 $\\infty$，则设置 $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$ 并将 $u'$ 入队。\n     - 如果 $v$ 是自由的（即 $\\mathrm{pairV}[v] = -1$），记录下在此 BFS 分层中至少存在一条最短增广路。\n   - BFS 阶段返回一个布尔值，指示是否从层次图中到达了 $V$ 中的任何自由顶点，这意味着至少存在一条增广路。\n4. 对每个自由的 $u \\in U$ 执行 DFS 阶段，以在遵守 BFS 层次的前提下寻找并提交增广路：\n   - 对于给定的 $u$，探索其邻居 $v \\in N(u)$。如果 $v$ 是自由的，则立即将 $u$ 与 $v$ 匹配。\n   - 否则，令 $u' = \\mathrm{pairV}[v]$；如果 $\\mathrm{dist}[u'] = \\mathrm{dist}[u] + 1$，则递归地尝试通过 $u'$ 进行增广。如果成功，则将 $u$ 与 $v$ 重新匹配并返回成功。\n   - 如果没有邻居能导向增广，则设置 $\\mathrm{dist}[u] = \\infty$，以在此阶段中剪枝未来的 DFS 尝试。\n5. 重复 BFS 和 DFS 阶段，直到 BFS 表明不再有增广路存在。成功增广的总次数即为最大匹配的基数。\n\n正确性依赖于两大支柱：首先，沿着不相交的最短增广路进行增广不会相互产生负面干扰，因为每条路径都是顶点不相交的，并且只是翻转交替边的匹配状态；其次，BFS 分层确保在一个阶段中找到的所有增广路都是最短的，并且在增广之后，最短可能增广路的长度会严格增加，从而将阶段数量限制在 $O(\\sqrt{|U| + |V|})$ 以内。\n\n我们现在分析测试套件的结果：\n- 测试用例 $1$：$n = 5$, $m = 6$, $E = \\{(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)\\}$。一个有效的最大匹配是 $\\{(0,0), (1,2), (2,1), (3,4), (4,5)\\}$，其大小为 $5$，因此结果是 $5$。\n- 测试用例 $2$：$n = 3$, $m = 4$, $E = \\varnothing$。没有边，因此不存在任何匹配边，最大匹配的大小为 $0$。\n- 测试用例 $3$：$n = 4$, $m = 4$, $E = \\{(0,0),(1,1),(2,2),(3,3)\\}$。集合 $\\{(0,0),(1,1),(2,2),(3,3)\\}$ 是一个大小为 $4$ 的完美匹配，因此结果是 $4$。\n- 测试用例 $4$：$n = 3$, $m = 5$, $E = \\{(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)\\}$。所有间谍只能获取机密 $0$ 和 $1$；最多可以匹配两名间谍，因此最大匹配的大小为 $2$。\n- 测试用例 $5$：$n = 6$, $m = 6$, $E = \\{(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)\\}$。尽管存在重复的 $(0,0)$，去重后仍能得到有效的边。一个最大匹配是 $\\{(0,0),(1,1),(2,3),(3,2),(4,4),(5,5)\\}$，大小为 $6$，因此结果是 $6$。\n- 测试用例 $6$：$n = 7$, $m = 7$, $E = \\{(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)\\}$。存在一个完美匹配，例如 $\\{(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,0)\\}$，其大小为 $7$，因此结果是 $7$。\n\n因此，六个测试用例的输出按顺序为 $[5,0,4,2,6,7]$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef hopcroft_karp_max_matching(n_left, n_right, edges):\n    \"\"\"\n    Compute maximum bipartite matching using the Hopcroft–Karp algorithm.\n\n    n_left: number of vertices on the left side U (spies), indexed 0..n_left-1\n    n_right: number of vertices on the right side V (secrets), indexed 0..n_right-1\n    edges: list of (u, v) pairs where u in U, v in V\n\n    Returns: size of maximum matching (integer)\n    \"\"\"\n    # Build deduplicated adjacency list for U\n    adj = [set() for _ in range(n_left)]\n    for u, v in edges:\n        if 0 = u  n_left and 0 = v  n_right:\n            adj[u].add(v)\n        else:\n            # Ignore any out-of-range edges; not expected in given test suite\n            pass\n    adj = [sorted(list(neis)) for neis in adj]\n\n    # Pairing arrays: -1 means free/unmatched\n    pairU = [-1] * n_left\n    pairV = [-1] * n_right\n    dist = [0] * n_left\n    INF = 10**9\n\n    def bfs():\n        \"\"\"\n        BFS builds layers from all free U vertices.\n        Returns True if there exists at least one augmenting path.\n        \"\"\"\n        q = deque()\n        for u in range(n_left):\n            if pairU[u] == -1:\n                dist[u] = 0\n                q.append(u)\n            else:\n                dist[u] = INF\n\n        found_free_v = False\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                pu = pairV[v]\n                if pu != -1:\n                    if dist[pu] == INF:\n                        dist[pu] = dist[u] + 1\n                        q.append(pu)\n                else:\n                    # Reached a free vertex on V; indicates an augmenting path exists\n                    found_free_v = True\n        return found_free_v\n\n    def dfs(u):\n        \"\"\"\n        DFS restricted to BFS layers to find and commit augmenting paths.\n        \"\"\"\n        for v in adj[u]:\n            pu = pairV[v]\n            # If v is free, we can match u -> v\n            if pu == -1:\n                pairU[u] = v\n                pairV[v] = u\n                return True\n            # Otherwise try to advance on layer graph\n            if dist[pu] == dist[u] + 1 and dfs(pu):\n                pairU[u] = v\n                pairV[v] = u\n                return True\n        # Prune: no augmenting path from u in this phase\n        dist[u] = INF\n        return False\n\n    matching = 0\n    while bfs():\n        for u in range(n_left):\n            if pairU[u] == -1:\n                if dfs(u):\n                    matching += 1\n    return matching\n\ndef solve():\n    # Define the test cases from the problem statement.\n    # Each test case is (n_left, n_right, edges)\n    test_cases = [\n        # Test Case 1\n        (5, 6, [(0,0),(0,1),(1,0),(1,2),(1,3),(2,1),(2,3),(3,2),(3,4),(4,4),(4,5)]),\n        # Test Case 2\n        (3, 4, []),\n        # Test Case 3\n        (4, 4, [(0,0),(1,1),(2,2),(3,3)]),\n        # Test Case 4\n        (3, 5, [(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)]),\n        # Test Case 5 (includes duplicate edge (0,0))\n        (6, 6, [(0,0),(0,0),(0,1),(1,1),(2,2),(2,3),(3,2),(4,3),(4,4),(5,5)]),\n        # Test Case 6\n        (7, 7, [(0,0),(0,1),(1,1),(1,2),(2,2),(2,3),(3,3),(3,4),(4,4),(4,5),(5,5),(5,6),(6,0),(6,6)]),\n    ]\n\n    results = []\n    for n_left, n_right, edges in test_cases:\n        result = hopcroft_karp_max_matching(n_left, n_right, edges)\n        results.append(result)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250161"}, {"introduction": "二分图中的最大匹配数不仅仅是一个孤立的数字，它通过著名的 Kőnig 定理与另一个核心图论概念——最小顶点覆盖——紧密相连。这个练习要求你在找到最大匹配的基础上，进一步构造出相应的最小顶点覆盖。这不仅能加深你对 Kőnig 定理的理解，也展示了算法结果在解决相关问题时的延展应用。[@problem_id:3250194]", "problem": "您的任务是为几个二分图中的每一个，从一个最大匹配构造一个最小顶点覆盖，并使用一种基于核心图论原理的高效方法。二分图是一个图 $G = (V, E)$，其顶点集 $V$ 可以划分为 $V = L \\cup R$，其中每条边 $e \\in E$ 的一个端点在 $L$ 中，另一个在 $R$ 中。匹配 $M \\subseteq E$ 是一组成对顶点不相交的边的集合。匹配的大小是它包含的边的数量。顶点覆盖 $C \\subseteq V$ 是一个与 $E$ 中每条边都相交的顶点集合。目标是计算一个大小尽可能小的最小顶点覆盖 $C$。一个基本事实（柯尼希定理）断言，对于任何二分图，最大匹配的大小等于最小顶点覆盖的大小；也就是说，如果 $M$ 是一个最大匹配，$C$ 是一个最小顶点覆盖，则有 $|M| = |C|$。\n\n您的程序必须对每个给定的二分图执行以下操作：\n- 使用一种高效算法计算最大匹配，该算法在每个实例上的渐进时间复杂度不劣于 $O(|E| \\sqrt{|V|})$。\n- 从计算出的最大匹配构造一个相应的最小顶点覆盖 $C$ 并报告其大小。\n- 确保报告的大小等于计算出的最大匹配的大小。\n\n用作基础的定义：\n- 图 $G$ 中的路径是一个顶点序列，其中连续的顶点由边连接。相对于匹配 $M$ 的增广路是一条始于和终于未匹配顶点，并且在不属于 $M$ 的边和属于 $M$ 的边之间交替的路径。\n- 根据贝尔热定理，一个匹配是最大匹配当且仅当不存在关于它的增广路。\n- Hopcroft–Karp 算法是用于最大二分匹配的高效算法，它通过广度优先搜索 (BFS) 和深度优先搜索 (DFS) 重复寻找一个顶点不相交的最短增广路的最大集合，其中广度优先搜索 (BFS) 是逐层遍历，而深度优先搜索 (DFS) 是沿路径探索。\n\n每个测试用例的输入模型：\n- 二分图由三个参数指定：左侧顶点数 $n_L$、右侧顶点数 $n_R$ 以及边列表 $E \\subseteq \\{0, 1, \\dots, n_L - 1\\} \\times \\{0, 1, \\dots, n_R - 1\\}$。\n- 左侧顶点由整数 $0$ 到 $n_L - 1$ 标记，右侧顶点由整数 $0$ 到 $n_R - 1$ 标记。\n\n硬编码在程序内部的测试套件：\n- 案例 1（通用正常路径）：$n_L = 3$，$n_R = 3$，边 $E = [ (0,0), (0,1), (1,1), (2,1), (2,2) ]$。\n- 案例 2（空图边界情况）：$n_L = 2$，$n_R = 3$，边 $E = [\\,]$。\n- 案例 3（星形，多对一）：$n_L = 3$，$n_R = 1$，边 $E = [ (0,0), (1,0), (2,0) ]$。\n- 案例 4（多个连通分量，非完美匹配）：$n_L = 4$，$n_R = 4$，边 $E = [ (0,0), (0,1), (1,1), (2,2), (3,2) ]$。\n- 案例 5（右侧容量受限）：$n_L = 4$，$n_R = 3$，边 $E = [ (0,0), (0,1), (1,1), (1,2), (2,2), (3,2) ]$。\n\n程序要求：\n- 实现 Hopcroft–Karp 算法为每个案例计算最大匹配，确保渐进时间复杂度界为 $O(|E| \\sqrt{|V|})$。\n- 通过从左侧未匹配顶点开始遍历交替路径来从计算出的匹配中推导出一个最小顶点覆盖。该遍历仅使用从 $L$ 到 $R$ 的非匹配边和从 $R$ 回到 $L$ 的匹配边。然后形成覆盖 $C = \\left( L \\setminus T_L \\right) \\cup \\left( R \\cap T_R \\right)$，其中 $T_L$ 和 $T_R$ 分别是在此交替遍历中可达的左侧和右侧顶点集合。\n- 对每个测试用例，输出一个等于 $|C|$ 的整数，即最小顶点覆盖的大小（根据柯尼希定理，该值必须等于最大匹配的大小）。\n\n最终输出格式：\n- 您的程序应生成一行输出，其中包含一个用方括号括起来的逗号分隔列表，结果顺序与测试用例相同：例如，格式为 $[r_1, r_2, r_3, r_4, r_5]$，其中每个 $r_i$ 是为案例 $i$ 计算的最小顶点覆盖的整数大小。", "solution": "该问题是有效的，因为它定义明确、自成一体，并基于图论的既定原则，特别是关于最大二分匹配和最小顶点覆盖的原则。它要求实现 Hopcroft–Karp 算法以及随后构造最小顶点覆盖，这是算法学中一个标准且可形式化的任务。\n\n解决方案分为两个主要部分。首先，我们使用 Hopcroft–Karp 算法为给定的、顶点集划分为 $V = L \\cup R$ 的二分图 $G = (V, E)$ 计算最大匹配。其次，我们使用计算出的最大匹配 $M$ 基于柯尼希定理的构造性证明来构造一个最小顶点覆盖 $C$。\n\n**第一部分：用于最大二分匹配的 Hopcroft–Karp 算法**\n\nHopcroft–Karp 算法在 $O(|E| \\sqrt{|V|})$ 的时间复杂度内找到二分图中的最大匹配。该算法以迭代方式工作。从一个空匹配 $M$ 开始，它重复地寻找一个顶点不相交的最短增广路的最大集合，并用它们来增加 $M$ 的大小。增广路是一条在不属于 $M$ 的边和属于 $M$ 的边之间交替的路径，从 $L$ 中的一个未匹配顶点开始，到 $R$ 中的一个未匹配顶点结束。根据贝尔热定理，一个匹配是最大匹配当且仅当不存在关于它的增广路。\n\nHopcroft–Karp 算法的每次迭代包括两个阶段：\n\n1.  **广度优先搜索 (BFS):**\n    通过从左部划分 $L$ 中所有未匹配的顶点同时开始进行 BFS，构建一个分层图。遍历在两个划分之间交替进行：从一个顶点 $u \\in L$ 通过一条不在当前匹配 $M$ 中的边到达一个顶点 $v \\in R$，然后从一个顶点 $v \\in R$ 通过一条在 $M$ 中的边返回到一个顶点 $u' \\in L$。BFS 计算最短增广路的长度。它将顶点划分为多个层次，其中对于顶点 $u \\in L$ 的 `dist[u]` 是其在分层图中的层级。一旦 BFS 阶段到达 $R$ 中的一个或多个未匹配顶点，该阶段就终止。如果没有 $R$ 中的未匹配顶点是可达的，则不存在增广路，算法终止，因为当前的匹配 $M$ 已经是最大匹配。\n\n2.  **深度优先搜索 (DFS):**\n    从 $L$ 中的每个未匹配顶点执行 DFS，以寻找由 BFS 确定的最短长度的、顶点不相交的增广路。DFS 只在 $w$ 位于分层图的下一层时，即 $\\text{dist}[w] = \\text{dist}[u] + 1$ 时，才从顶点 $u$ 遍历到顶点 $w$。当一条 DFS 路径到达 $R$ 中的一个未匹配顶点时，就找到了一条增广路。通过取 $M$ 和该路径的对称差来更新匹配 $M$，这实际上是沿着路径交换了匹配边和非匹配边，并使 $|M|$ 增加 1。DFS 继续从 $L$ 中剩余的未匹配顶点寻找其他顶点不相交的增广路。\n\n这个 BFS 后跟 DFS 的循环会重复进行。可以证明，最短增广路的长度在每次迭代后都会严格增加。这个性质保证了算法最多执行 $O(\\sqrt{|V|})$ 次迭代，从而得到 $O(|E|\\sqrt{|V|})$ 的总时间复杂度。\n\n**第二部分：从最大匹配构造最小顶点覆盖**\n\n柯尼希定理指出，在任何二分图中，最大匹配中的边数等于最小顶点覆盖中的顶点数。我们使用该定理的构造性证明，从通过 Hopcroft–Karp 算法计算出的最大匹配 $M$ 来找到一个最小顶点覆盖 $C$。\n\n构造过程如下：\n\n1.  令 $U_L$ 为左部划分 $L$ 中所有未匹配顶点的集合。\n2.  从 $U_L$ 中的所有顶点开始进行图遍历（例如，使用 DFS 或 BFS）。此遍历探索交替路径：\n    - 从一个顶点 $u \\in L$ 出发，如果边 $(u,v)$ **不**在匹配 $M$ 中，则遍历到一个顶点 $v \\in R$。\n    - 从一个顶点 $v \\in R$ 出发，如果边 $(v,u')$ **在**匹配 $M$ 中，则遍历到一个顶点 $u' \\in L$。\n3.  令 $T$ 为在此遍历期间访问的所有顶点的集合。我们可以将 $T$ 划分为 $T_L = T \\cap L$ 和 $T_R = T \\cap R$。\n4.  最小顶点覆盖 $C$ 随后被定义为顶点集 $C = (L \\setminus T_L) \\cup T_R$。\n\n为了确认此构造的有效性，我们考虑两个性质：$C$ 是一个顶点覆盖，且其大小等于 $|M|$。\n\n- **$C$ 是一个顶点覆盖：** 考虑任意一条边 $(u, v) \\in E$，其中 $u \\in L$ 且 $v \\in R$。\n    - 如果边 $(u, v)$ 在匹配 $M$ 中：如果 $u \\in T_L$，那么它的匹配伙伴 $v$ 必须是通过一条非匹配边从 $u$ 到达的，这是一个矛盾。因此，$u$ 不可能在 $T_L$ 中。这意味着 $u \\in (L \\setminus T_L)$，所以 $u \\in C$，这条边被覆盖。\n    - 如果边 $(u, v)$ 不在匹配 $M$ 中：如果 $u \\in T_L$，那么 $v$ 可以通过非匹配边 $(u, v)$ 从 $u$ 到达。因此，$v \\in T_R$，所以 $v \\in C$，这条边被覆盖。如果 $u \\notin T_L$，那么 $u \\in (L \\setminus T_L)$，所以 $u \\in C$，这条边被覆盖。\n    在所有情况下，每条边都被覆盖了。\n\n- **$|C| = |M|$：** $C$ 中的顶点由“不可达”的左侧顶点 $(L \\setminus T_L)$ 和“可达”的右侧顶点 $(T_R)$ 组成。可以证明，匹配 $M$ 在集合 $T_R$ 与 $T_L$ 中的已匹配顶点之间建立了一个双射，同样地，在集合 $(L \\setminus T_L)$ 与 $(R \\setminus T_R)$ 中的已匹配顶点之间也建立了一个双射。因此，集合 $C$ 中恰好包含匹配 $M$ 中每条边的一个顶点。所以， $|C| = |M|$。根据柯尼希定理，由于 $M$ 是最大匹配，因此 $C$ 必须是最小顶点覆盖。\n\n实现将把这两个部分应用于提供的每个测试用例。对于由 $n_L$、$n_R$ 和边列表 $E$ 指定的每个图，我们首先运行 Hopcroft–Karp 算法以找到 $|M|$ 并存储匹配对。然后，我们执行交替路径遍历以找到集合 $T_L$ 和 $T_R$，并计算所得顶点覆盖 $C$ 的大小，这将是我们对该案例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\nclass HopcroftKarp:\n    \"\"\"\n    Implementation of the Hopcroft-Karp algorithm for maximum bipartite matching\n    and construction of a minimum vertex cover.\n    \"\"\"\n    def __init__(self, nL, nR, edges):\n        \"\"\"\n        Initializes the bipartite graph.\n        - nL: Number of vertices in the left partition (U)\n        - nR: Number of vertices in the right partition (V)\n        - edges: A list of tuples (u, v) representing edges\n        \"\"\"\n        self.nL = nL\n        self.nR = nR\n        # Adjacency list for left vertices\n        self.adj = [[] for _ in range(nL)]\n        for u, v in edges:\n            self.adj[u].append(v)\n        \n        # Matching pairs for left (L) and right (R) partitions\n        self.pairL = np.full(nL, -1, dtype=int)\n        self.pairR = np.full(nR, -1, dtype=int)\n        \n        # Distance array for BFS, only for left vertices\n        self.dist = np.full(nL, -1, dtype=int)\n        \n        # Store computed matching for vertex cover construction\n        self.max_matching_size = 0\n\n    def _bfs(self):\n        \"\"\"\n        Performs BFS to find layers in the graph and check for augmenting paths.\n        \"\"\"\n        queue = deque()\n        self.dist.fill(-1) # Reset distances for left vertices\n        \n        # Start BFS from all unmatched vertices in L\n        for u in range(self.nL):\n            if self.pairL[u] == -1:\n                queue.append(u)\n                self.dist[u] = 0\n        \n        found_path = False\n        while queue:\n            u = queue.popleft()\n            for v in self.adj[u]:\n                # u_matched is the vertex in L matched with v\n                u_matched = self.pairR[v]\n                if u_matched == -1:\n                    # Found an augmenting path to an unmatched right vertex\n                    found_path = True\n                # If u_matched has not been visited yet (dist is -1)\n                elif self.dist[u_matched] == -1:\n                    # This is part of an alternating path\n                    self.dist[u_matched] = self.dist[u] + 1\n                    queue.append(u_matched)\n        return found_path\n\n    def _dfs(self, u):\n        \"\"\"\n        Performs DFS to find an augmenting path from vertex u.\n        \"\"\"\n        for v in self.adj[u]:\n            u_matched = self.pairR[v]\n            # If v is free or we can find an augmenting path from its partner u_matched\n            if u_matched == -1 or (self.dist[u_matched] == self.dist[u] + 1 and self._dfs(u_matched)):\n                self.pairL[u] = v\n                self.pairR[v] = u\n                return True\n        # Mark u as visited in this DFS phase to ensure paths are vertex-disjoint\n        self.dist[u] = -1 \n        return False\n\n    def find_max_matching(self):\n        \"\"\"\n        Computes the maximum matching size using the Hopcroft-Karp algorithm.\n        \"\"\"\n        matching_size = 0\n        # Continue as long as augmenting paths are found by BFS\n        while self._bfs():\n            for u in range(self.nL):\n                if self.pairL[u] == -1:\n                    if self._dfs(u):\n                        matching_size += 1\n        self.max_matching_size = matching_size\n        return matching_size\n\n    def find_min_vertex_cover(self):\n        \"\"\"\n        Constructs a minimum vertex cover from the computed maximum matching.\n        This must be called after find_max_matching().\n        \"\"\"\n        # Find unmatched vertices in the left partition\n        unmatched_L = {u for u in range(self.nL) if self.pairL[u] == -1}\n\n        # Sets of reachable vertices from unmatched_L via alternating paths\n        reachable_L = set(unmatched_L)\n        reachable_R = set()\n        \n        q = deque(list(unmatched_L))\n        visited_in_traversal = set(unmatched_L)\n\n        while q:\n            u = q.popleft() # A reachable vertex from L\n            # Traverse non-matching edges from L to R\n            for v in self.adj[u]:\n                if self.pairL[u] != v and v not in reachable_R:\n                    reachable_R.add(v)\n                    # Traverse matching edge from R to L\n                    u_matched = self.pairR[v]\n                    if u_matched != -1 and u_matched not in reachable_L:\n                        reachable_L.add(u_matched)\n                        q.append(u_matched)\n\n        # The minimum vertex cover C = (L \\ T_L) U T_R\n        # where T_L = reachable_L and T_R = reachable_R\n        unreachable_L = set(range(self.nL)) - reachable_L\n        min_cover = unreachable_L | reachable_R\n        \n        return len(min_cover)\n\ndef solve():\n    # Define the test cases from the problem statement.\n    test_cases = [\n        # Case 1: general happy path\n        {'n_L': 3, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (2, 1), (2, 2)]},\n        # Case 2: empty graph boundary\n        {'n_L': 2, 'n_R': 3, 'edges': []},\n        # Case 3: star-shaped, many-to-one\n        {'n_L': 3, 'n_R': 1, 'edges': [(0, 0), (1, 0), (2, 0)]},\n        # Case 4: multiple components, non-perfect\n        {'n_L': 4, 'n_R': 4, 'edges': [(0, 0), (0, 1), (1, 1), (2, 2), (3, 2)]},\n        # Case 5: right-limited capacity\n        {'n_L': 4, 'n_R': 3, 'edges': [(0, 0), (0, 1), (1, 1), (1, 2), (2, 2), (3, 2)]},\n    ]\n\n    results = []\n    for case in test_cases:\n        # Initialize the HopcroftKarp instance for the current graph.\n        solver = HopcroftKarp(case['n_L'], case['n_R'], case['edges'])\n        \n        # First, compute the maximum matching. This populates the pair arrays.\n        max_matching_size = solver.find_max_matching()\n        \n        # Second, construct the minimum vertex cover from the matching.\n        min_vertex_cover_size = solver.find_min_vertex_cover()\n        \n        # By Kőnig's theorem, these sizes must be equal.\n        # assert max_matching_size == min_vertex_cover_size\n        \n        results.append(min_vertex_cover_size)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3250194"}, {"introduction": "一个图是否拥有完美匹配是一回事，而这个完美匹配是否唯一则是更深层次的结构性问题。这个高级练习挑战你设计一个算法来判定唯一完美匹配的存在性。你需要运用对 $M$-交错环（$M$-alternating cycles）的理解，在找到一个完美匹配后，通过分析图的结构来判断其唯一性，这将极大提升你对匹配理论背后组合结构的洞察力。[@problem_id:3250170]", "problem": "给定一个有限二分图，由两个不相交的顶点集 $U$ 和 $V$ 以及一个边集 $E \\subseteq U \\times V$ 指定。一个匹配是边集 $M \\subseteq E$ 的一个子集，其中 $M$ 中没有两条边共享同一个端点。一个完美匹配是一个能够饱和 $U \\cup V$ 中每个顶点的匹配。当且仅当一个二分图有且仅有一个完美匹配时，我们称其拥有唯一的完美匹配。\n\n您的任务是设计并实现一个算法，该算法基于匹配和增广路径的核心定义，用于判断给定的二分图是否具有唯一的完美匹配。该算法必须：\n- 使用对于二分图而言在顶点数和边数方面渐近最优的方法来计算最大匹配。\n- 仅根据核心定义所蕴含的结构特性，来判断是否存在完美匹配，如果存在，再判断其是否唯一，而不是通过在修改后的图上重复计算最大匹配来解决。\n\n您的程序必须解决以下固定的二分图测试套件。每个测试用例都完全由一个三元组 $(|U|, |V|, E)$ 指定，其中 $U = \\{0,1,\\dots,|U|-1\\}$，$V = \\{0,1,\\dots,|V|-1\\}$，边以有序对 $(u,v)$ 的形式给出，满足 $u \\in U$ 和 $v \\in V$。所有索引都是从零开始的。不涉及物理单位。\n\n测试套件：\n- 情况 $1$：$(|U|, |V|, E) = (2, 2, \\{(0,0), (1,1), (0,1)\\})$。此图每侧有两个顶点和三条边。\n- 情况 $2$：$(|U|, |V|, E) = (2, 2, \\{(0,0), (0,1), (1,0), (1,1)\\})$。这是完全二分图 $K_{2,2}$。\n- 情况 $3$：$(|U|, |V|, E) = (3, 3, \\{(0,0), (1,0), (2,1)\\})$。此图不存在完美匹配。\n- 情况 $4$：$(|U|, |V|, E) = (4, 4, \\{(0,0), (0,1), (0,2), (0,3), (1,1), (1,2), (1,3), (2,2), (2,3), (3,3)\\})$。这是一个嵌套邻域（链式）二分图。\n- 情况 $5$：$(|U|, |V|, E) = (3, 3, \\{(0,0), (1,0), (1,1), (2,1), (2,2), (0,2)\\})$。此图包含一个覆盖所有顶点的偶环。\n\n对于每个测试用例，您的程序必须输出一个布尔值：当且仅当图具有唯一的完美匹配时输出 $True$，否则输出 $False$。最终输出必须是一行，其中包含按顺序排列的各用例结果，形式为方括号括起来的逗号分隔列表，例如 $[True,False,True,False,True]$。\n\n约束与期望：\n- 算法必须从匹配和增广路径的基本定义出发，并使用一种可证明高效的二分图最大匹配过程，其时间复杂度为 $O(|E| \\sqrt{|V|})$，其中 $V = |U| + |V|$，$E$ 是边的数量。\n- 如果存在完美匹配，算法必须仅使用定义所蕴含的结构性推论（例如，交错路径的性质）来确定其唯一性，并且在这个唯一性检查阶段的运行时间必须为 $O(|V| + |E|)$。\n- 如果 $|U| \\neq |V|$，则不可能存在完美匹配；在这种情况下，答案必须是 $False$。\n\n您的程序应生成一行输出，其中包含结果，形式为方括号括起来的逗号分隔列表（例如 $[result_1,result_2,result_3,result_4,result_5]$），其中每个 $result_i$ 对应于用例 $i$ 的结果，值为 $True$ 或 $False$。", "solution": "该问题要求设计一个算法来确定给定的二分图是否拥有唯一的完美匹配。解决方案必须基于匹配理论的基本原理并采用高效的算法。\n\n在一个二分图 $G = (U \\cup V, E)$ 中，完美匹配是边集 $M \\subseteq E$ 的一个子集，它能精确地覆盖图中每个顶点一次。完美匹配存在的必要条件是两个顶点划分的大小必须相等，即 $|U| = |V|$。如果 $|U| \\neq |V|$，则不可能存在完美匹配，因此也不可能存在唯一的完美匹配。令 $n = |U| = |V|$。如果存在完美匹配，其大小将为 $n$。\n\n总体策略是一个两阶段过程：\n1.  通过计算最大匹配来确定是否存在完美匹配。\n2.  如果找到完美匹配，则通过搜索图中的特定结构特征来确定其是否唯一。\n\n**步骤1：完美匹配的存在性**\n\n为了确定是否存在完美匹配，我们首先找到最大匹配的大小，最大匹配是拥有尽可能多边的匹配。如果这个最大匹配的大小等于 $n$，则存在完美匹配。否则，不存在完美匹配。\n\n在二分图中寻找最大匹配的已知最高效算法是 Hopcroft-Karp 算法。该算法基于匹配理论中的一个基本结果，即 Berge 定理，该定理指出，一个匹配 $M$ 是最大匹配当且仅当不存在 $M$-增广路径。一条 $M$-增广路径是一条其边在匹配 $M$ 之内和之外交替出现，且其端点是未匹配顶点的路径。\n\nHopcroft-Karp 算法分阶段运行。在每个阶段，它会找到一个顶点不相交的最短增广路径的极大集。这是通过以下方式实现的：\n- 从 $U$ 中所有未匹配的顶点开始进行广度优先搜索（BFS），以构建一个分层图。这可以确定最短增广路径的长度。\n- 在这个分层图上进行深度优先搜索（DFS），以找到极大集中的所有路径，并沿着这些路径增广匹配。\n\n阶段的数量被证明最多为 $O(\\sqrt{|U \\cup V|})$。每个阶段耗时 $O(|E|)$，从而使得总时间复杂度为 $O(|E|\\sqrt{|U \\cup V|})$，这满足了问题的要求。\n\n如果 Hopcroft-Karp 算法返回的匹配 $M$ 的大小 $|M|  n$，我们断定不存在完美匹配，答案为 $False$。\n\n**步骤2：完美匹配的唯一性**\n\n如果找到了一个大小为 $n$ 的完美匹配 $M$，我们接着必须确定它是否是唯一的。假设存在另一个不同的完美匹配 $M'$。让我们考虑这两个匹配的对称差，记为 $M \\oplus M' = (M \\setminus M') \\cup (M' \\setminus M)$。\n\n由 $M \\oplus M'$ 中的边形成的子图具有特定的结构。由于每个顶点都恰好是 $M$ 中一条边和 $M'$ 中一条边的端点，因此子图 $(U \\cup V, M \\oplus M')$ 中的每个顶点的度数必须为 2。一个每个顶点度数都为 2 的图是若干个不相交环的并集。此外，由于这些边来自两个匹配的对称差，每个环中的边必须在 $M$ 中和 $M'$ 中交替出现。这样的环被称为 **$M$-交错环**（$M$-alternating cycle）。\n\n这就引出了关于唯一性的核心定理：一个完美匹配 $M$ 是唯一的，当且仅当图 $G$ 中不存在 $M$-交错环。\n\n一个 $M$-交错环的存在意味着存在另一个完美匹配。如果我们有一个 $M$-交错环，我们可以沿着这个环交换匹配边和非匹配边，从而产生一个新的边集 $M' = M \\oplus C$，它也是一个完美匹配。反之，如果存在两个完美匹配 $M$ 和 $M'$，它们的对称差 $M \\oplus M'$ 必然形成一个或多个不相交的 $M$-交错环。\n\n因此，检查唯一性的问题就简化为相对于步骤1中找到的完美匹配 $M$ 搜索一个 $M$-交错环。这可以通过从 $G$ 和 $M$ 构建一个有向图 $D_M$ 来高效完成：\n- $D_M$ 的顶点集是 $U \\cup V$。\n- 对于每条**不**在匹配 $M$ 中的边 $(u, v) \\in E$（即 $(u, v) \\in E \\setminus M$），我们添加一条从 $u$ 到 $v$ 的有向边。\n- 对于每条**在**匹配 $M$ 中的边 $(u, v) \\in E$（即 $(u, v) \\in M$），我们添加一条从 $v$ 到 $u$ 的有向边。\n\n无向图 $G$ 中的一个 $M$-交错环，例如 $u_0 - v_0 - u_1 - v_1 - \\dots - u_k - v_k - u_0$，其中 $(u_i,v_i) \\notin M$ 且 $(u_{i+1},v_i) \\in M$，精确地对应于有向图 $D_M$ 中的一个有向环 $u_0 \\to v_0 \\to u_1 \\to v_1 \\to \\dots \\to u_k \\to v_k \\to u_0$。\n\n我们可以使用标准的深度优先搜索（DFS）在有向图 $D_M$ 中检测环。在遍历过程中，我们维护每个顶点的状态：未访问（白色）、当前在递归栈中（灰色）或已完全访问（黑色）。如果从一个顶点开始的 DFS 遇到了一个灰色顶点，说明找到了一个反向边，这表示存在一个环。\n\n这个环检测算法的运行时间与有向图的大小成线性关系，即 $O(|U|+|V| + |E|)$，满足问题对唯一性检查阶段的效率约束。\n\n如果在 $D_M$ 中检测到环，则完美匹配 $M$ 不是唯一的。如果 DFS 完成且没有找到任何环，则不存在 $M$-交错环，完美匹配 $M$ 是唯一的。\n\n**算法总结：**\n1.  给定一个二分图 $G=(U \\cup V, E)$，检查是否有 $|U| = |V|$。若否，返回 $False$。令 $n = |U|$。\n2.  使用 Hopcroft-Karp 算法计算一个最大匹配 $M$。\n3.  检查是否有 $|M| = n$。若否，返回 $False$。\n4.  如上所述构建有向图 $D_M$。\n5.  在 $D_M$ 上执行基于 DFS 的环检测。\n6.  如果找到环，返回 $False$（不唯一）。\n7.  如果没有找到环，返回 $True$（唯一）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the unique perfect matching problem for a fixed test suite.\n    \"\"\"\n    \n    # Each test case is a tuple: (size_U, size_V, list_of_edges)\n    test_cases = [\n        (2, 2, [(0, 0), (1, 1), (0, 1)]),\n        (2, 2, [(0, 0), (0, 1), (1, 0), (1, 1)]),\n        (3, 3, [(0, 0), (1, 0), (2, 1)]),\n        (4, 4, [(0, 0), (0, 1), (0, 2), (0, 3), (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]),\n        (3, 3, [(0, 0), (1, 0), (1, 1), (2, 1), (2, 2), (0, 2)])\n    ]\n\n    results = []\n    for u_size, v_size, edges in test_cases:\n        results.append(has_unique_perfect_matching(u_size, v_size, edges))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef has_unique_perfect_matching(u_size, v_size, edges):\n    \"\"\"\n    Determines if a bipartite graph has a unique perfect matching.\n    \n    Args:\n        u_size (int): Number of vertices in partition U.\n        v_size (int): Number of vertices in partition V.\n        edges (list of tuples): The edge set E.\n\n    Returns:\n        bool: True if a unique perfect matching exists, False otherwise.\n    \"\"\"\n    if u_size != v_size:\n        return False\n    \n    if u_size == 0:\n        return True # An empty graph has a unique perfect matching (the empty set).\n\n    n = u_size\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v)\n    \n    # Step 1  2: Find a maximum matching using Hopcroft-Karp\n    hk = HopcroftKarp(n, n, adj)\n    matching_size, match_u, match_v = hk.get_max_matching()\n\n    # Step 3: Check if the matching is perfect\n    if matching_size  n:\n        return False\n\n    # Step 4: Check for uniqueness by searching for M-alternating cycles\n    # Build the directed graph D_M\n    # Vertices u in U are 0..n-1. Vertices v in V are n..n+n-1.\n    total_vertices = 2 * n\n    directed_adj = [[] for _ in range(total_vertices)]\n    \n    for u in range(n):\n        for v in adj[u]:\n            if match_u[u] == v:\n                # Edge is in the matching M: add directed edge v -> u\n                directed_adj[n + v].append(u)\n            else:\n                # Edge is not in M: add directed edge u -> v\n                directed_adj[u].append(n + v)\n\n    # Step 5: Perform DFS-based cycle detection on D_M\n    # 0: white (unvisited), 1: gray (visiting), 2: black (visited)\n    visited = np.zeros(total_vertices, dtype=int)\n    \n    for i in range(total_vertices):\n        if visited[i] == 0:\n            recursion_stack = np.zeros(total_vertices, dtype=bool)\n            if dfs_cycle_check(i, directed_adj, visited, recursion_stack):\n                return False # Cycle found, not unique\n\n    return True # No cycles found, unique\n\ndef dfs_cycle_check(v, adj, visited, recursion_stack):\n    \"\"\"\n    Helper DFS function to detect cycles in a directed graph.\n    \"\"\"\n    visited[v] = 1\n    recursion_stack[v] = True\n    \n    for neighbor in adj[v]:\n        if visited[neighbor] == 0:\n            if dfs_cycle_check(neighbor, adj, visited, recursion_stack):\n                return True\n        elif recursion_stack[neighbor]: # Back edge found\n            return True\n            \n    recursion_stack[v] = False\n    return False\n\nclass HopcroftKarp:\n    \"\"\"Implementation of the Hopcroft-Karp algorithm.\"\"\"\n    \n    def __init__(self, u_size, v_size, adj):\n        self.u_size = u_size\n        self.v_size = v_size\n        self.adj = adj\n        self.NIL = -1\n        self.match_u = np.full(u_size, self.NIL, dtype=int)\n        self.match_v = np.full(v_size, self.NIL, dtype=int)\n        self.dist = np.full(u_size, -1, dtype=int)\n\n    def bfs(self):\n        \"\"\"\n        Builds layers of augmenting paths.\n        Returns True if an augmenting path is found, False otherwise.\n        \"\"\"\n        self.dist.fill(-1)\n        queue = []\n        for u in range(self.u_size):\n            if self.match_u[u] == self.NIL:\n                self.dist[u] = 0\n                queue.append(u)\n        \n        path_found = False\n        head = 0\n        while head  len(queue):\n            u = queue[head]\n            head += 1\n            for v in self.adj[u]:\n                matched_u = self.match_v[v]\n                if matched_u == self.NIL:\n                    path_found = True\n                elif self.dist[matched_u] == -1:\n                    self.dist[matched_u] = self.dist[u] + 1\n                    queue.append(matched_u)\n        return path_found\n\n    def dfs(self, u, ptr):\n        \"\"\"\n        Finds an augmenting path starting from u.\n        \"\"\"\n        for i in range(ptr[u], len(self.adj[u])):\n            ptr[u] = i + 1\n            v = self.adj[u][i]\n            matched_u = self.match_v[v]\n            if matched_u == self.NIL or \\\n               (self.dist[matched_u] == self.dist[u] + 1 and self.dfs(matched_u, ptr)):\n                self.match_u[u] = v\n                self.match_v[v] = u\n                return True\n        return False\n\n    def get_max_matching(self):\n        \"\"\"\n        Computes the maximum matching.\n        \n        Returns:\n            A tuple (matching_size, match_u, match_v).\n        \"\"\"\n        matching_size = 0\n        while self.bfs():\n            ptr = np.zeros(self.u_size, dtype=int)\n            for u in range(self.u_size):\n                if self.match_u[u] == self.NIL:\n                    if self.dfs(u, ptr):\n                        matching_size += 1\n        return matching_size, self.match_u, self.match_v\n\n# Execute the main function when the script is run.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3250170"}]}