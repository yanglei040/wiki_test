{"hands_on_practices": [{"introduction": "现实世界中的网络流问题，瓶颈不仅可能出现在路径（边）上，也可能出现在交叉点（节点）上。这个练习将挑战你扩展标准的网络流模型，来处理带有节点容量的场景。掌握这种转换是应用最大流算法解决更复杂系统建模问题的关键一步。[@problem_id:3249870]", "problem": "考虑一个有向流网络，其中有一个指定的源节点 $s$ 和汇节点 $t$。除了边的容量外，每个内部节点还有一个容量，限制了可以流过该节点的总流量。该网络有节点 $s$、$v_{1}$、$v_{2}$、$v_{3}$、$v_{4}$ 和 $t$。有向边及其容量如下：$s \\to v_{1}$ 容量为 $8$，$s \\to v_{2}$ 容量为 $7$，$v_{1} \\to v_{3}$ 容量为 $5$，$v_{1} \\to v_{4}$ 容量为 $3$，$v_{2} \\to v_{3}$ 容量为 $4$，$v_{2} \\to v_{4}$ 容量为 $6$，$v_{3} \\to t$ 容量为 $9$，$v_{4} \\to t$ 容量为 $5$。节点容量为：$c(v_{1}) = 6$，$c(v_{2}) = 5$，$c(v_{3}) = 7$，$c(v_{4}) = 4$，源节点 $s$ 和汇节点 $t$ 没有节点容量限制（等效于无穷大）。\n\n仅使用流网络的基础知识——边和节点的容量限制以及中间节点的流量守恒——并应用与 Ford–Fulkerson 方法、Edmonds–Karp 算法或 Dinic's 算法一致的正确规约或算法策略，确定该网络中最大的 $s$-$t$ 流量值。\n\n请以一个表示最大流量值的实数形式提供最终答案。无需四舍五入。", "solution": "我们从流网络的定义开始。一个可行流 $f$ 为每条有向边 $(u,v)$ 赋予一个非负值 $f(u,v)$，使得对于每个边的容量 $c(u,v)$，都有 $0 \\le f(u,v) \\le c(u,v)$，并且在每个中间节点上流量守恒：对于任何节点 $w \\notin \\{s,t\\}$，流入该节点的总流量等于流出该节点的总流量。对于有节点容量的情况，每个内部节点 $w$ 还需满足，流经 $w$ 的总流量至多为节点容量 $c(w)$，这可以通过确保从 $w$ 流出的总流量（等价地，流入的总流量）不超过 $c(w)$ 来实现。\n\n一个标准的、经过充分检验的规约方法是将节点容量转换为边容量，具体做法是：将每个节点 $v$ 拆分为两个节点 $v_{\\mathrm{in}}$ 和 $v_{\\mathrm{out}}$，并连接一条容量为 $c(v)$ 的边 $(v_{\\mathrm{in}}, v_{\\mathrm{out}})$；然后将指向 $v$ 的每条原始入边 $(u,v)$ 重定向为 $(u, v_{\\mathrm{in}})$，并将从 $v$ 出发的每条原始出边 $(v,w)$ 重定向为 $(v_{\\mathrm{out}}, w)$。源节点 $s$ 和汇节点 $t$ 可以不拆分，或视作具有无限容量。转换后图中的最大流等于原始带节点容量网络中的最大流。\n\n我们分析给定的网络。边和容量：\n- $s \\to v_{1}$ 容量为 $8$，\n- $s \\to v_{2}$ 容量为 $7$，\n- $v_{1} \\to v_{3}$ 容量为 $5$，\n- $v_{1} \\to v_{4}$ 容量为 $3$，\n- $v_{2} \\to v_{3}$ 容量为 $4$，\n- $v_{2} \\to v_{4}$ 容量为 $6$，\n- $v_{3} \\to t$ 容量为 $9$，\n- $v_{4} \\to t$ 容量为 $5$。\n\n节点容量：\n- $c(v_{1}) = 6$，\n- $c(v_{2}) = 5$，\n- $c(v_{3}) = 7$，\n- $c(v_{4}) = 4$，\n- $c(s)$ 和 $c(t)$ 等效于无穷大。\n\n根据基本容量限制，可以离开 $v_{1}$ 的总流量最多为 $6$，并且还必须遵守其出边上 $5$ 和 $3$ 的边容量。可以离开 $v_{2}$ 的总流量最多为 $5$，并且还必须遵守 $4$ 和 $6$ 的边容量。在汇节点一侧，可以流过 $v_{3}$ 的总流量最多为 $7$，并且还必须遵守到 $t$ 的边容量 $9$；对于 $v_{4}$，最多为 $4$，并且必须遵守到 $t$ 的边容量 $5$。\n\n这些观察立即得出了总 $s$-$t$ 流量的上限：\n- 从源节点一侧看，无论边容量 $8$ 和 $7$ 更大，最多只能有 $c(v_{1}) + c(v_{2}) = 6 + 5 = 11$ 个单位的流量通过与源节点相邻的两个内部节点。\n- 从汇节点一侧看，无论边容量 $9$ 和 $5$ 更大，在到达 $t$ 之前，两个内部节点最多只能吸收 $c(v_{3}) + c(v_{4}) = 7 + 4 = 11$ 个单位的流量。\n\n因此，最大流量值的上限为 $11$。\n\n我们现在构造一个达到 $11$ 的显式可行流，这与上限相结合，证明了其最优性。设变量表示中间边上的流量：\n- $x_{13} = f(v_{1}, v_{3})$，满足 $0 \\le x_{13} \\le 5$，\n- $x_{14} = f(v_{1}, v_{4})$，满足 $0 \\le x_{14} \\le 3$，\n- $y_{23} = f(v_{2}, v_{3})$，满足 $0 \\le y_{23} \\le 4$，\n- $y_{24} = f(v_{2}, v_{4})$，满足 $0 \\le y_{24} \\le 6$。\n\n节点容量限制转换为：\n- $x_{13} + x_{14} \\le 6$ 对于 $v_{1}$，\n- $y_{23} + y_{24} \\le 5$ 对于 $v_{2}$，\n- $x_{13} + y_{23} \\le 7$ 对于 $v_{3}$ (并且根据边 $v_{3} \\to t$ 也 $\\le 9$，因此 $7$ 是约束性的)，\n- $x_{14} + y_{24} \\le 4$ 对于 $v_{4}$ (并且根据边 $v_{4} \\to t$ 也 $\\le 5$，因此 $4$ 是约束性的)。\n\n到达 $t$ 的总流量等于 $(x_{13} + y_{23}) + (x_{14} + y_{24})$。选择以下值：\n- $x_{14} = 3$ 且 $y_{24} = 1$，使得 $x_{14} + y_{24} = 4$，饱和了节点 $v_{4}$ 的容量，并遵守了边容量界限 $3$ 和 $6$。\n- $x_{13} = 3$ 且 $y_{23} = 4$，使得 $x_{13} + y_{23} = 7$，饱和了节点 $v_{3}$ 的容量，并遵守了边容量界限 $5$ 和 $4$。\n\n验证节点容量：\n- $v_{1}$: $x_{13} + x_{14} = 3 + 3 = 6 \\le 6$，\n- $v_{2}$: $y_{23} + y_{24} = 4 + 1 = 5 \\le 5$，\n- $v_{3}$: $x_{13} + y_{23} = 3 + 4 = 7 \\le 7$，\n- $v_{4}$: $x_{14} + y_{24} = 3 + 1 = 4 \\le 4$。\n\n验证边容量：\n- $v_{1} \\to v_{3}$: $x_{13} = 3 \\le 5$，\n- $v_{1} \\to v_{4}$: $x_{14} = 3 \\le 3$，\n- $v_{2} \\to v_{3}$: $y_{23} = 4 \\le 4$，\n- $v_{2} \\to v_{4}$: $y_{24} = 1 \\le 6$，\n- $v_{3} \\to t$: 总计 $7 \\le 9$，\n- $v_{4} \\to t$: 总计 $4 \\le 5$，\n- 从 $s \\to v_{1}$ 和 $s \\to v_{2}$ 的容量是足够的，因为 $f(s,v_{1}) = x_{13} + x_{14} = 6 \\le 8$ 且 $f(s,v_{2}) = y_{23} + y_{24} = 5 \\le 7$。\n\n根据构造，每个中间节点都满足流量守恒，并且源流量和汇流量匹配：总流量值为\n$$\n(x_{13} + y_{23}) + (x_{14} + y_{24}) = 7 + 4 = 11.\n$$\n这个可行流达到了上限 $11$，因此根据最大流和容量限制的基本原理，给定带节点容量网络中的最大 $s$-$t$ 流量为 $11$。", "answer": "$$\\boxed{11}$$", "id": "3249870"}, {"introduction": "许多实际应用场景，例如物流配送，涉及将资源从多个源点分配到多个汇点。这个练习将带你超越单源单汇的经典模型，要求你通过引入一个“超级源点”和一个“超级汇点”来实现标准的多源多汇问题规约。通过编码实现这一过程，你将加深对图变换技巧在算法设计中作用的理解。[@problem_id:3249859]", "problem": "您的任务是计算在具有多个源顶点和多个汇顶点的有向网络中可行流的最大值。您的程序必须仅依赖于网络流的基本定义和经过充分测试的算法原理。流网络是一个有向图，其边上具有容量。一个可行的流函数必须满足：对于每条有向边，该边上的流量介于零与其容量之间；对于除指定的源点和汇点之外的每个顶点，净流量守恒。一个割是顶点的任意划分，该划分将所有源点与所有汇点分开，并且任何可行流的值都不能超过任何割的容量。\n\n基于这些基础，推导并实现一个正确且高效的方法，用于计算具有一组源点和一组汇点的网络的最大流。该方法必须基于一种构造：通过增加一个超级源点和一个超级汇点来将具有多个源点和汇点的网络简化为单源单汇实例。超级源点连接到所有原始源点，所有原始汇点连接到超级汇点，这些新边的容量要足够大。其正确性应由流量守恒和容量约束以及最大流最小割定理共同保证，不应假设任何捷径公式。\n\n您必须实现一个完整的、可运行的程序，该程序为下面测试套件中的每个测试用例构建相应的增广网络并计算其最大流值。您的算法设计必须基于经典原理，例如构建残差网络并通过广度优先搜索 (BFS) 或深度优先搜索 (DFS) 寻找增广路径，例如 Ford–Fulkerson 方法的 Edmonds–Karp 专门化或 Dinic 算法中实现的那样。在首次使用时定义任何缩略词（例如，广度优先搜索 (BFS)，深度优先搜索 (DFS)）。\n\n本规范中的所有数字都是整数，并应被解释为无量纲的。没有物理单位。\n\n硬编码在程序中的输入格式：\n- 每个测试用例包括：顶点数 $n$（标记为 $0$ 到 $n-1$），一个带容量的有向边列表，一组源顶点和一组汇顶点。\n\n测试套件：\n- 测试用例 $1$ (具有多条路径和平衡汇点的通用情况):\n  - 顶点: $n = 8$，标记为 $0,1,2,3,4,5,6,7$。\n  - 源点: $\\{0,1\\}$。\n  - 汇点: $\\{6,7\\}$。\n  - 带容量的有向边 (三元组 $(u,v,c)$ 表示一条从 $u$ 到 $v$ 容量为 $c$ 的边):\n    $\\{(0,2,10),(0,3,5),(1,3,15),(1,4,4),(2,5,15),(3,2,4),(3,5,8),(3,4,6),(4,5,10),(5,6,10),(5,7,10),(4,7,5),(2,6,5)\\}$。\n  - 预期的最大流值将由您的算法确定。\n- 测试用例 $2$ (具有零容量割和不连通源点的边界情况):\n  - 顶点: $n = 5$，标记为 $0,1,2,3,4$。\n  - 源点: $\\{0,1\\}$。\n  - 汇点: $\\{3,4\\}$。\n  - 边: $\\{(0,2,7),(2,3,0),(2,4,0)\\}$。注意，顶点 $1$ 没有出边，并且从 $0$ 到任何汇点的唯一路径都经过零容量边。\n- 测试用例 $3$ (单个瓶颈边决定最大流):\n  - 顶点: $n = 6$，标记为 $0,1,2,3,4,5$。\n  - 源点: $\\{0,1\\}$。\n  - 汇点: $\\{4,5\\}$。\n  - 边: $\\{(0,2,100),(1,2,100),(2,3,7),(3,4,100),(3,5,100)\\}$。\n- 测试用例 $4$ (平行边和分流到多个汇点):\n  - 顶点: $n = 6$，标记为 $0,1,2,3,4,5$。\n  - 源点: $\\{0,1\\}$。\n  - 汇点: $\\{4,5\\}$。\n  - 边包括表示为独立三元组的平行边:\n    $\\{(0,2,5),(0,2,7),(1,2,3),(2,3,4),(2,3,6),(3,4,100),(2,5,1)\\}$。\n\n输出规范:\n- 对于每个测试用例，您的程序必须计算从给定源点集到给定汇点集的整数最大流值。\n- 您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，按测试用例的顺序列出结果，例如：$\\texttt{[x\\_1,x\\_2,x\\_3,x\\_4]}$，其中 $x_i$ 是测试用例 $i$ 的最大流值。\n\n约束和说明:\n- 所有容量均为非负整数。\n- 在构建超级源点和超级汇点时，将超级源点连接到每个原始源点，并将每个原始汇点连接到超级汇点，边的容量至少为原始图中所有有限容量的总和，这足以避免限制真实的最大流。\n- 不读取外部输入；所有测试用例均按规定硬编码。", "solution": "该问题要求计算具有多个源顶点和多个汇顶点的有向网络中的最大可行流。我们必须首先验证问题的提法，然后在有效的情况下，基于网络流理论的基本原理推导并实现一个解决方案。\n\n### 问题验证\n\n**第1步：提取给定信息**\n\n- **目标**：计算在具有一组源顶点 $S$ 和一组汇顶点 $T$ 的有向图中的可行流的最大值。\n- **网络定义**：一个有向图 $G=(V, E)$，其中每条边 $(u,v) \\in E$ 都有一个非负整数容量函数 $c(u,v)$。\n- **流的性质**：\n    1.  **容量约束**：对于任何边 $(u,v) \\in E$，流 $f(u,v)$ 必须满足 $0 \\le f(u,v) \\le c(u,v)$。\n    2.  **流量守恒**：对于任何顶点 $v \\in V \\setminus (S \\cup T)$，流入 $v$ 的总流量必须等于流出 $v$ 的总流量：$\\sum_{(u,v) \\in E} f(u,v) = \\sum_{(v,w) \\in E} f(v,w)$。\n- **方法论**：通过创建一个增广图，将多源多汇问题简化为单源单汇问题。这包括添加一个连接到所有原始源点 $s \\in S$ 的超级源点 $s'$，以及一个所有原始汇点 $t \\in T$ 都连接到的超级汇点 $t'$。这些新边的容量必须足够大。问题建议容量至少为图中所有其他有限容量的总和。然后应使用从第一性原理推导出的经典最大流算法（如 Ford-Fulkerson（使用 Edmonds-Karp）或 Dinic）来找到解决方案。\n- **缩略词**：必须在首次使用时定义，例如，广度优先搜索 (BFS)。\n- **测试用例**：\n    - **用例1**：$n=8$ 个顶点，$S=\\{0,1\\}$，$T=\\{6,7\\}$，以及13条带给定容量的边。\n    - **用例2**：$n=5$ 个顶点，$S=\\{0,1\\}$，$T=\\{3,4\\}$，以及3条边，其中包含零容量边作为一个关键特征。\n    - **用例3**：$n=6$ 个顶点，$S=\\{0,1\\}$，$T=\\{4,5\\}$，以及5条边，设计为具有单个瓶颈。\n    - **用例4**：$n=6$ 个顶点，$S=\\{0,1\\}$，$T=\\{4,5\\}$，以及7条边，包括平行边。\n- **输出**：包含每个测试用例的整数最大流值的单行逗号分隔列表，例如 `[x_1,x_2,x_3,x_4]`。\n\n**第2步：使用提取的给定信息进行验证**\n\n根据验证标准对问题陈述进行评估。\n\n1.  **科学或事实不健全**：该问题是图论和计算机科学中一个标准的、明确定义的问题。网络流的概念、最大流最小割定理以及像 Edmonds-Karp 这样的算法是该领域的基石。所提出的简化技术是处理多源多汇问题的标准且数学上合理的方法。没有违反科学原理或数学逻辑的地方。\n2.  **不可形式化或不相关**：该问题可以在图论的语言中被严格地形式化。它直接关乎最大流算法的主题。\n3.  **不完整或矛盾的设置**：所有测试用例都完整地指定了顶点数量、源点和汇点集合，以及一个完整的带容量的边列表。关于设置新边容量的说明清晰且充分。没有矛盾之处。\n4.  **不切实际或不可行**：该问题纯粹是数学问题。所有量都是抽象的无量纲整数。没有相关的物理约束。\n5.  **不适定或结构不良**：对于给定的网络，最大流值是唯一的。指定的简化和算法方法（例如 Edmonds-Karp）保证能找到这个唯一值。问题是适定的。\n6.  **伪深刻、琐碎或同义反复**：该问题需要正确实现一个非平凡的图算法。测试用例经过精心构建，涵盖了通用、边界、瓶颈和类多重图等场景，确保解决方案必须具有鲁棒性。问题不琐碎。\n7.  **超出科学可验证范围**：结果在数学上是可验证的。对于任何计算出的流值，都可以验证其是可实现的，并通过找到一个等容量的割来证明它是最大的。\n\n**第3步：结论与行动**\n\n该问题是**有效的**。它有科学依据，是适定的，并且是完整的。我们着手提供一个完整的解决方案。\n\n### 推导与求解\n\n在网络 $G=(V, E)$ 中寻找从源点集 $S$ 到汇点集 $T$ 的最大流问题，可以通过将其转换为等价的单源单汇最大流问题来解决。这是一种标准的构造方法。\n\n**1. 增广网络构造**\n\n我们从原始网络 $G=(V, E)$ 构造一个增广网络 $G'=(V', E')$。\n- **顶点**：添加一个新的超级源点 $s'$ 和一个新的超级汇点 $t'$。新的顶点集为 $V' = V \\cup \\{s', t'\\}$。\n- **边**：新的边集 $E'$ 由 $E$ 中所有原始边，加上从超级源点到每个原始源点的新边，以及从每个原始汇点到超级汇点的新边组成。\n    - $E' = E \\cup \\{ (s', s) \\mid s \\in S \\} \\cup \\{ (t, t') \\mid t \\in T \\}$。\n- **容量**：我们为 $G'$ 定义一个新的容量函数 $c'$。\n    - 对于所有原始边 $(u,v) \\in E$，使其容量保持不变：$c'(u,v) = c(u,v)$。\n    - 对于连接超级源点的新边，我们将其容量设置为有效无穷大，以确保它们不会成为瓶颈。一个安全的有限值是保证大于或等于原始网络中最大可能流的值。最大流的一个上界是原始图中所有有限容量的总和，$C_{total} = \\sum_{(u,v) \\in E} c(u,v)$。我们为所有 $s \\in S$ 设置 $c'(s', s) = C_{total}$。如果类型系统支持，使用更大的值或真正的无穷大也可以。为简单和正确起见，我们可以将容量设置为相应源点的所有出边容量之和，$c'(s', s) = \\sum_{(s,u) \\in E} c(s,u)$，但使用全局总和 $C_{total}$ 更易于实现且同样正确。\n    - 类似地，对于通往超级汇点的新边，我们为所有 $t \\in T$ 设置 $c'(t, t') = C_{total}$。\n\n**2. 构造的正确性**\n\n我们必须证明，$G'$ 中从 $s'$ 到 $t'$ 的最大流等于 $G$ 中从集合 $S$ 到集合 $T$ 的最大流。多源多汇流的值 $|f|$ 定义为从所有源点流出的总净流量，即 $|f| = \\sum_{s \\in S} \\left( \\sum_{(s,u) \\in E} f(s,u) - \\sum_{(v,s) \\in E} f(v,s) \\right)$。\n\n- $G$ 中的任何可行流 $f$ 都可以扩展为 $G'$ 中一个值相同的可行流 $f'$。对于 $(u,v) \\in E$，定义 $f'(u,v) = f(u,v)$。对于 $s \\in S$，将 $f'(s', s)$ 设置为 $G$ 中离开 $s$ 的净流量。对于 $t \\in T$，将 $f'(t, t')$ 设置为 $G$ 中进入 $t$ 的净流量。根据 $G$ 中节点 $V \\setminus (S \\cup T)$ 的流量守恒，以及对节点 $S$ 和 $T$ 的构造，$f'$ 在 $G'$ 中满足流量守恒。新边上的容量约束也得到满足，因为它们的容量被设置得足够大。流 $f'$ 的值 $|f'| = \\sum_{s \\in S} f'(s', s)$ 正是 $G$ 中流 $f$ 值的定义。因此，$\\text{max-flow}(G) \\le \\text{max-flow}(G')$。\n\n- 反之，任何在 $G'$ 中值为 $|f'|$ 的可行流 $f'$ 都可以限制在 $G$ 的边上，形成 $G$ 中的一个可行流 $f$。对于 $V \\setminus (S \\cup T)$ 上的 $f$，容量和守恒约束是平凡满足的。该流的值是来自 $S$ 的总净流出量，根据 $G'$ 中源节点的守恒性，这等于从 $s'$ 到达的流量，即 $|f'|$。因此，$\\text{max-flow}(G') \\le \\text{max-flow}(G)$。\n\n结合这两点，我们得到 $\\text{max-flow}(G) = \\text{max-flow}(G')$。这确立了等价性并验证了该简化方法。\n\n**3. 算法实现：Edmonds-Karp 算法**\n\n为了在单源单汇网络 $G'$ 中找到最大流，我们将采用 Edmonds-Karp 算法，它是 Ford-Fulkerson 方法的一种实现。\n\n- **Ford-Fulkerson 方法**：该方法基于残差网络和增广路径的概念。给定一个流网络 $G$ 和一个流 $f$，残差网络 $G_f$ 包含代表增加流量的剩余容量的边。对于 $G$ 中的每条边 $(u,v)$，残差网络有一条正向边 $(u,v)$，其残差容量为 $c_f(u,v) = c(u,v) - f(u,v)$，以及一条反向边 $(v,u)$，其残差容量为 $c_f(v,u) = f(u,v)$（表示“推回”流量的可能性）。该方法重复寻找一条*增广路径*——即在残差网络中从源点到汇点的一条所有边都具有正容量的路径——并沿着该路径增加流量。当再也找不到增广路径时，过程终止。\n\n- **Edmonds-Karp 专门化**：Ford-Fulkerson 方法没有指定如何寻找增广路径。路径的选择会影响算法的性能。Edmonds-Karp 算法指定增广路径应为边数最少的路径，这可以使用**广度优先搜索 (BFS)** 高效地找到。这种选择保证了算法在多项式时间内运行，具体为 $O(|V| |E|^2)$。\n\n总体算法如下：\n1.  如上所述，构建带有超级源点 $s'$ 和超级汇点 $t'$ 的增广图 $G'=(V', E')$。使用邻接矩阵表示残差容量来代表网络。对于有平行边的图，其容量相加。\n2.  将所有流量初始化为 $0$。残差容量矩阵用增广图的容量进行初始化。\n3.  将最大流值 `max_flow` 初始化为 $0$。\n4.  在一个循环中重复执行以下步骤：\n    a. 使用 BFS 在当前残差图中找到从 $s'$ 到 $t'$ 的最短增广路径。BFS 还会存储路径的父指针。\n    b. 如果不存在这样的路径，算法终止。当前的 `max_flow` 即为可能的最大值。\n    c. 如果找到一条路径，确定其瓶颈容量 $\\Delta$，即路径上所有边的最小残差容量。\n    d. 增广流量：将 $\\Delta$ 加到 `max_flow` 值上。通过将路径上正向边的容量减少 $\\Delta$ 并将反向边的容量增加 $\\Delta$ 来更新残差图。\n5.  返回最终的 `max_flow` 值。\n\n该过程通过将每个给定的测试用例简化为标准问题，并使用经过验证的高效算法来解决，从而正确地计算出最大流。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the multi-source, multi-sink max-flow problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        {\n            \"n\": 8,\n            \"sources\": {0, 1},\n            \"sinks\": {6, 7},\n            \"edges\": [\n                (0, 2, 10), (0, 3, 5), (1, 3, 15), (1, 4, 4), (2, 5, 15),\n                (3, 2, 4), (3, 5, 8), (3, 4, 6), (4, 5, 10), (5, 6, 10),\n                (5, 7, 10), (4, 7, 5), (2, 6, 5)\n            ],\n        },\n        {\n            \"n\": 5,\n            \"sources\": {0, 1},\n            \"sinks\": {3, 4},\n            \"edges\": [(0, 2, 7), (2, 3, 0), (2, 4, 0)],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 100), (1, 2, 100), (2, 3, 7), (3, 4, 100), (3, 5, 100)\n            ],\n        },\n        {\n            \"n\": 6,\n            \"sources\": {0, 1},\n            \"sinks\": {4, 5},\n            \"edges\": [\n                (0, 2, 5), (0, 2, 7), (1, 2, 3), (2, 3, 4), (2, 3, 6),\n                (3, 4, 100), (2, 5, 1)\n            ],\n        },\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        sources = case[\"sources\"]\n        sinks = case[\"sinks\"]\n        edges = case[\"edges\"]\n\n        # 1. Construct the augmented graph\n        # Super-source will be at index n, super-sink at n+1\n        super_source = n\n        super_sink = n + 1\n        num_vertices_aug = n + 2\n\n        # Adjacency matrix for residual capacities\n        graph = np.zeros((num_vertices_aug, num_vertices_aug), dtype=np.int64)\n\n        total_capacity_sum = 0\n        for u, v, c in edges:\n            graph[u, v] += c\n            total_capacity_sum += c\n        \n        # A sufficiently large capacity for super-edges\n        # Sum of all original capacities is a safe upper bound on the max flow.\n        # If total_capacity_sum is 0, we use 1 to handle disconnected graphs.\n        inf_capacity = total_capacity_sum if total_capacity_sum  0 else 1\n\n        for s in sources:\n            graph[super_source, s] = inf_capacity\n        for t in sinks:\n            graph[t, super_sink] = inf_capacity\n\n        results.append(edmonds_karp(graph, super_source, super_sink))\n\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef bfs(graph, s, t, parent):\n    \"\"\"\n    Breadth-First Search to find an augmenting path in the residual graph.\n    `graph` is the residual capacity matrix.\n    `s` is the source, `t` is the sink.\n    `parent` is an array to store the path.\n    Returns True if a path is found, False otherwise.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    visited = [False] * num_vertices\n    \n    # Use a list as a queue for BFS. For problem constraints, performance is acceptable.\n    queue = []\n    queue.append(s)\n    visited[s] = True\n    parent[s] = -1\n\n    while queue:\n        u = queue.pop(0)\n        for v in range(num_vertices):\n            if not visited[v] and graph[u, v]  0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == t:\n                    return True\n    return False\n\ndef edmonds_karp(graph, source, sink):\n    \"\"\"\n    Implements the Edmonds-Karp algorithm to find the maximum flow.\n    `graph` is the initial capacity matrix.\n    `source` and `sink` are the vertices for the flow.\n    \"\"\"\n    num_vertices = graph.shape[0]\n    parent = np.empty(num_vertices, dtype=np.int64)\n    max_flow = 0\n\n    # `residual_graph` will be modified in place\n    residual_graph = np.copy(graph)\n\n    while bfs(residual_graph, source, sink, parent):\n        # Find the bottleneck capacity of the path found by BFS\n        path_flow = np.iinfo(np.int64).max\n        v = sink\n        while v != source:\n            u = parent[v]\n            path_flow = min(path_flow, residual_graph[u, v])\n            v = u\n\n        # Update residual capacities of the edges and reverse edges\n        v = sink\n        while v != source:\n            u = parent[v]\n            residual_graph[u, v] -= path_flow\n            residual_graph[v, u] += path_flow\n            v = u\n\n        # Add path flow to overall flow\n        max_flow += path_flow\n\n    return max_flow\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3249859"}, {"introduction": "最大流算法不仅用于计算流量的最大值，它还是一个进行网络分析和优化的强大工具。这个高级练习要求你进行创造性思考：如何通过改变网络结构本身——在这里是反转一条边的方向——来最大程度地提升网络的最大流量？解决这类问题能让你体会到如何将核心算法作为子程序来解决更宏大的优化问题。[@problem_id:3249907]", "problem": "给定一个有指定源点和汇点的有向容量图。你可以选择其中一条有向边并将其方向反转，容量保持不变。你的任务是，在最优地选择要反转的单条边时，确定从源点到汇点的最大可行流在此操作下如何变化。\n\n从流网络的基本定义开始。设一个有向图表示为 $G=(V,E)$，其容量函数为 $c:E\\to\\mathbb{R}_{\\ge 0}$。一个可行流是一个函数 $f:E\\to\\mathbb{R}_{\\ge 0}$，满足以下条件：\n- 容量限制：对于每条边 $(u,v)\\in E$，$0\\le f(u,v)\\le c(u,v)$。\n- 流量守恒：对于每个顶点 $v\\in V\\setminus\\{s,t\\}$，$\\sum_{(u,v)\\in E} f(u,v) = \\sum_{(v,w)\\in E} f(v,w)$。\n流的值为 $|f| = \\sum_{(s,w)\\in E} f(s,w)$。\n\n在流 $f$ 下，点对 $(u,v)$ 的残留容量定义为：如果 $(u,v)\\in E$，则 $r(u,v) = c(u,v) - f(u,v)$；如果 $(v,u)\\in E$，则 $r(u,v) = f(v,u)$；否则 $r(u,v)=0$。残留路径是残留图中从 $s$ 到 $t$ 的任何有向路径，其所有边上的残留容量都严格为正。Ford–Fulkerson 方法及其被称为 Edmonds–Karp 算法的广度优先搜索特例，系统地在残留图中寻找增广路径以增加流值，直到不存在这样的路径为止。根据最大流最小割定理，最大流等于最小 s-t 割容量。\n\n问题目标：对于下面的每个测试实例，计算从 $s$ 到 $t$ 的原始最大流值。然后，考虑将一条边 $(u,v)\\in E$ 的方向反转为 $(v,u)$，同时保持其容量 $c(u,v)$ 不变，生成一个修改后的网络，其容量函数 $c'$ 满足 $c'(u,v) = c(u,v) - c(u,v)$（即，移除该边在原始方向上的容量）和 $c'(v,u) = c(v,u) + c(u,v)$（即，将相同容量加到反方向上），所有其他容量保持不变。对于每个实例，确定在最优选择要反转的边后，通过这次单边反转可实现的最大 s-t 流值。如果多条边在反转后能得到相同的最优最大流，则选择最小的边索引。\n\n你的程序必须：\n- 使用基于上述定义的规范算法（例如，使用广度优先搜索的 Ford–Fulkerson 方法（Edmonds–Karp）或 Dinic 算法），为给定网络正确计算 s-t 最大流值。\n- 枚举所有单边反转情况，为每个修改后的网络重新计算最大流，并选择能使所得最大流值最大化的反转（以最小的边索引打破平局）。\n- 对于每个测试用例，报告四个整数：原始最大流 $M_0$，反转后的最优最大流 $M_1$，差值 $D = M_1 - M_0$，以及所选边的索引 $e^\\*$。\n\n图由节点数 $n$、带整数容量的有向边、源点 $s$ 和汇点 $t$ 指定。节点标记为 $0,1,\\dots,n-1$。边索引是其在所提供列表中的位置，从 0 开始。容量是无量纲的非负整数。\n\n测试套件：\n- 测试用例 1：$n=6$， $s=0$， $t=5$，带索引和容量的边\n  - $0$: $(0,1,7)$\n  - $1$: $(1,2,6)$\n  - $2$: $(2,5,6)$\n  - $3$: $(0,3,7)$\n  - $4$: $(3,4,6)$\n  - $5$: $(4,5,1)$\n  - $6$: $(5,4,5)$\n- 测试用例 2：$n=4$， $s=0$， $t=3$，边\n  - $0$: $(0,1,5)$\n  - $1$: $(1,3,5)$\n  - $2$: $(0,2,5)$\n  - $3$: $(2,3,5)$\n  - $4$: $(1,2,1)$\n- 测试用例 3：$n=4$， $s=0$， $t=3$，边\n  - $0$: $(0,1,5)$\n  - $1$: $(1,2,4)$\n  - $2$: $(3,2,7)$\n- 测试用例 4：$n=3$， $s=0$， $t=2$，边\n  - $0$: $(0,1,5)$\n  - $1$: $(1,2,5)$\n\n最终输出格式：\n- 你的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表，不含空格。每个测试用例的结果本身必须是 $[M_0,M_1,D,e^\\*]$ 形式的整数列表。例如，两个测试用例的一个有效总输出将是 $[[3,4,1,2],[5,5,0,0]]$。", "solution": "该问题要求我们分析在流网络中反转单条边对从源点 $s$ 到汇点 $t$ 的最大流值的影响。具体来说，我们必须找出哪一次单边反转能产生可能的最大流，并报告这个最优值、其与原始值的差值以及为反转所选边的索引。\n\n这是一个在离散选择集（图的边）上的优化问题。可能修改的集合是有限的，对应于图中原始边集 $E$ 中的每一条边。一个直接且正确的方法是遍历每一种可能的单边反转，为每个生成的修改后图计算最大流，并确定哪种反转产生最大值。\n\n解决方案的核心是在有向容量图中计算最大流的可靠算法。Edmonds–Karp 算法是 Ford–Fulkerson 方法的一个特例化实现，是一个合适的选择。它保证能终止并得到正确的最大流，并且具有多项式时间复杂度，对于给定的问题约束来说足够高效。\n\n整体算法流程如下：\n\n**1. 最大流计算 (Edmonds–Karp 算法)**\n\n设图为 $G=(V, E)$，其中每条边 $(u,v) \\in E$ 都有容量函数 $c(u,v)$，一个源点 $s \\in V$ 和一个汇点 $t \\in V$。我们使用邻接矩阵来表示网络，其中条目 $C[u][v]$ 存储边 $(u,v)$ 的当前容量。\n\n该算法在残留图 $G_f$ 上操作，该图指示在两个顶点之间任意方向上还可以推送多少流量。给定一个流 $f$，从 $u$ 到 $v$ 的残留容量 $c_f(u,v)$ 定义为：\n- 如果 $(u,v) \\in E$（一条“正向”边），则 $c_f(u,v) = c(u,v) - f(u,v)$。\n- 如果 $(v,u) \\in E$（一条“反向”边），则 $c_f(u,v) = f(v,u)$。\n- 否则 $c_f(u,v) = 0$。\n\nEdmonds–Karp 算法在残留图中迭代地寻找从 $s$ 到 $t$ 的“增广路径”。增广路径是一条简单路径，其中每条边的残留容量都严格为正。该算法使用广度优先搜索（BFS）来寻找最短的此类增广路径。\n\n步骤如下：\na. 对所有 $(u,v) \\in E$，初始化流量 $f(u,v) = 0$。总最大流为 $M = 0$。\nb. 在残留图中使用 BFS 寻找一条从 $s$ 到 $t$ 的路径 $P$。\nc. 如果不存在这样的路径，算法终止。当前流量 $M$ 即为最大流。\nd. 如果找到路径 $P$，确定其瓶颈容量 $\\delta = \\min_{(u,v) \\in P} \\{c_f(u,v)\\}$。这是可以沿此路径发送的最大额外流量。\ne. 将流量增加 $\\delta$。对于路径 $P$ 中的每条边 $(u,v)$：\n    - 减少正向边的残留容量：$c_f(u,v) \\leftarrow c_f(u,v) - \\delta$。\n    - 增加反向边的残留容量：$c_f(v,u) \\leftarrow c_f(v,u) + \\delta$。\nf. 将增广的流量加到总流量中：$M \\leftarrow M + \\delta$。\ng. 返回步骤 (b)。\n\n**2. 主过程**\n\n对于每个测试用例，我们给定节点数 $n$、源点 $s$、汇点 $t$ 以及一个边列表。设该边列表为 $E_{list}$。\n\na. **计算原始最大流 ($M_0$)**：为给定图构建初始容量矩阵。应用上述 Edmonds–Karp 算法计算最大流 $M_0$。\n\nb. **寻找最优边反转**：\n    i. 初始化迄今为止找到的最佳流为 $M_1 = -1$，以及对应的最佳边索引 $e^* = -1$。（使用一个小于任何可能流的值，如 -1，可以确保第一个计算出的值成为初始基准）。\n    ii. 遍历原始边列表 $E_{list}$ 中的每条边 $e_i = (u,v)$ 及其容量 $c_i$，其中 $i$ 是从 $0$ 到 $|E_{list}|-1$ 的边索引。\n    iii. 对于每条边 $e_i$：\n        - 创建一个修改后的容量矩阵，代表边 $e_i$ 已反转的图 $G_i$。从原始容量矩阵开始，将 $(u,v)$ 的容量设置为 $0$，并将 $(v,u)$ 的容量增加 $c_i$。形式上，新的容量函数 $c_i'$ 满足 $c_i'(u,v) = c(u,v) - c_i$ 和 $c_i'(v,u) = c(v,u) + c_i$。\n        - 使用 Edmonds–Karp 算法计算修改后图 $G_i$ 的最大流 $M_{new}$。\n        - 更新迄今为止找到的最优解。如果 $M_{new}  M_1$，则设置 $M_1 = M_{new}$ 和 $e^* = i$。严格不等式和按索引递增顺序的迭代正确地处理了打破平局的规则，该规则要求选择最小的边索引。\n\nc. **报告结果**：遍历所有边后，$M_1$ 将持有反转后可能的最大流值，$e^*$ 将是待反转的最优边的索引。计算差值 $D = M_1 - M_0$。该测试用例的最终结果是四元组 $[M_0, M_1, D, e^*]$。\n\n这个全面的过程正确地解决了问题的所有要求，通过评估每个可能选择的结果来系统地找到最优的边反转，并利用一个标准的、有良好基础的算法进行核心的最大流计算。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nfrom collections import deque\n\ndef bfs(capacity, source, sink, parent):\n    \"\"\"\n    Breadth-First Search to find an augmenting path in the residual graph.\n    The residual graph is implicitly represented by the capacity matrix.\n    \"\"\"\n    n = len(capacity)\n    visited = [False] * n\n    parent[:] = [-1] * n\n    \n    queue = deque()\n    queue.append(source)\n    visited[source] = True\n    \n    while queue:\n        u = queue.popleft()\n        for v in range(n):\n            if not visited[v] and capacity[u, v]  0:\n                queue.append(v)\n                visited[v] = True\n                parent[v] = u\n                if v == sink:\n                    return True\n    return False\n\ndef calculate_max_flow(n, edges, s, t):\n    \"\"\"\n    Calculates max flow for a graph defined by n, edges, s, t.\n    Uses the Edmonds-Karp algorithm.\n    \"\"\"\n    capacity = np.zeros((n, n), dtype=int)\n    for u, v, cap in edges:\n        capacity[u, v] += cap\n        \n    parent = np.empty(n, dtype=int)\n    max_flow = 0\n    \n    while bfs(capacity, s, t, parent):\n        path_flow = float('Inf')\n        v = t\n        while v != s:\n            u = parent[v]\n            path_flow = min(path_flow, capacity[u, v])\n            v = u\n        \n        v = t\n        while v != s:\n            u = parent[v]\n            capacity[u, v] -= path_flow\n            capacity[v, u] += path_flow\n            v = u\n        \n        max_flow += path_flow\n        \n    return int(max_flow)\n\ndef calculate_max_flow_on_matrix(capacity_matrix, n, s, t):\n    \"\"\"\n    Calculates max flow on a given capacity matrix. This is used\n    for the modified graphs to avoid rebuilding from the edge list.\n    \"\"\"\n    # We need a copy to modify during the algorithm\n    capacity = capacity_matrix.copy()\n    \n    parent = np.empty(n, dtype=int)\n    max_flow = 0\n    \n    while bfs(capacity, s, t, parent):\n        path_flow = float('Inf')\n        v = t\n        while v != s:\n            u = parent[v]\n            path_flow = min(path_flow, capacity[u, v])\n            v = u\n        \n        v = t\n        while v != s:\n            u = parent[v]\n            capacity[u, v] -= path_flow\n            capacity[v, u] += path_flow\n            v = u\n        \n        max_flow += path_flow\n        \n    return int(max_flow)\n    \ndef solve():\n    \"\"\"\n    Main function to solve the problem for the given test suite.\n    \"\"\"\n    test_cases = [\n        # Test case 1\n        (6, 0, 5, [(0, 1, 7), (1, 2, 6), (2, 5, 6), (0, 3, 7), (3, 4, 6), (4, 5, 1), (5, 4, 5)]),\n        # Test case 2\n        (4, 0, 3, [(0, 1, 5), (1, 3, 5), (0, 2, 5), (2, 3, 5), (1, 2, 1)]),\n        # Test case 3\n        (4, 0, 3, [(0, 1, 5), (1, 2, 4), (3, 2, 7)]),\n        # Test case 4\n        (3, 0, 2, [(0, 1, 5), (1, 2, 5)])\n    ]\n\n    results = []\n    \n    for n, s, t, edges in test_cases:\n        # Step 1: Compute original max flow M0\n        M0 = calculate_max_flow(n, edges, s, t)\n        \n        # Build the original capacity matrix once\n        original_capacity = np.zeros((n, n), dtype=int)\n        for u_orig, v_orig, cap_orig in edges:\n            original_capacity[u_orig, v_orig] += cap_orig\n            \n        # Step 2: Iterate through all edge reversals\n        M1 = -1\n        e_star = -1\n        \n        if not edges: # Handle case with no edges\n            M1 = 0\n            e_star = 0 # Dummy value, no meaningful choice\n        else:\n            for e_idx, (u, v, cap) in enumerate(edges):\n                modified_capacity = original_capacity.copy()\n                \n                # Reverse the edge\n                modified_capacity[u, v] -= cap\n                modified_capacity[v, u] += cap\n                \n                # Compute max flow for the modified graph\n                current_flow = calculate_max_flow_on_matrix(modified_capacity, n, s, t)\n                \n                # Update if this reversal is better\n                if current_flow  M1:\n                    M1 = current_flow\n                    e_star = e_idx\n            \n            # If no reversal was ever considered (e.g. single-edge graph), handle init\n            if e_star == -1 and edges:\n                e_star = 0\n                modified_capacity = original_capacity.copy()\n                u, v, cap = edges[0]\n                modified_capacity[u, v] -= cap\n                modified_capacity[v, u] += cap\n                M1 = calculate_max_flow_on_matrix(modified_capacity, n, s, t)\n\n        # Step 3: Calculate difference and store results\n        D = M1 - M0\n        results.append([M0, M1, D, e_star])\n    \n    # Final print statement in the exact required format.\n    formatted_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    print(f\"[{','.join(formatted_results)}]\")\n\nsolve()\n\n```", "id": "3249907"}]}