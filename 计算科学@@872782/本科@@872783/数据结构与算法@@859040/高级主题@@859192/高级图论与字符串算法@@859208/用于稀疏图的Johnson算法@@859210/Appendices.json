{"hands_on_practices": [{"introduction": "本章的第一个实践练习将从零开始构建约翰逊算法。这个练习不仅仅是计算所有顶点对之间的最短路径距离，还要求你实现一个前驱矩阵来重构这些路径[@problem_id:3242404]。通过这个过程，你将加深对整个算法流程的理解，从贝尔曼-福特算法的重赋权步骤到后续的多次狄克斯特拉算法的运行，从而将理论知识转化为可运行的代码。", "problem": "给定一个有向加权图 $G = (V,E)$，其顶点索引为 $V = \\{0,1,\\dots,n-1\\}$，边权重为实数值。一条路径 $P = (v_0,v_1,\\dots,v_k)$ 的权重定义为其边权重之和，即 $$W(P) = \\sum_{i=0}^{k-1} w(v_i,v_{i+1}).$$ 从源点 $s$ 到顶点 $t$ 的最短路径距离定义为 $$d(s,t) = \\min_{P \\in \\mathcal{P}(s,t)} W(P),$$ 其中 $\\mathcal{P}(s,t)$ 是从 $s$ 到 $t$ 的所有有向路径的集合。如果不存在路径，则 $d(s,t)$ 定义为 $+\\infty$。\n\n目标是为稀疏图实现一个版本的 Johnson 算法，该算法生成两项产出：\n- 一个全源距离矩阵 $D$，使得对于所有 $s,t \\in V$，都有 $D[s][t] = d(s,t)$。\n- 一个通过前驱矩阵 $P$ 实现的紧凑全源最短路径表示，使得对于原始图 $G$ 中从 $s$ 到 $t$ 的某条最短路径， $P[s][t]$ 是顶点 $t$ 的前驱顶点的索引。如果 $t=s$ 或者 $t$ 从 $s$ 不可达，则 $P[s][t] = -1$。\n\n你的方法必须基于最短路径的基本定义、势函数下重设权重的正确性，以及诸如 Bellman–Ford 算法和 Dijkstra 算法等成熟的单源最短路径 (SSSP) 算法。你必须检测图中是否存在任何负权重环。如果检测到负权重环，Johnson 算法对该图无效；在这种情况下，将该图的输出定义如下：布尔标志为 $false$，且扁平化的距离矩阵和扁平化的前驱矩阵均为空列表。\n\n你的程序必须是一个完整的、可运行的实现，对于每个提供的测试用例，返回三项内容：\n- 一个布尔值 $b$，如果未检测到负权重环，则为 $true$，否则为 $false$。\n- 一个全源距离的扁平化列表，首先按源点排序，然后按目标点排序，即 $(D[0][0],D[0][1],\\dots,D[0][n-1],D[1][0],\\dots,D[n-1][n-1])$。\n- 一个全源前驱的扁平化列表，按相同方式排序，即 $(P[0][0],P[0][1],\\dots,P[0][n-1],P[1][0],\\dots,P[n-1][n-1])$。\n\n如果顶点 $t$ 从源点 $s$ 不可达，则 $D[s][t]$ 必须为 $+\\infty$；在你的输出中，使用编程语言对正无穷大的浮点表示来表达。对于任何满足 $t=s$ 或 $t$ 从 $s$ 不可达的 $t$，设置 $P[s][t] = -1$。\n\n测试套件：\n使用以下图作为测试用例。每个测试用例由顶点数 $n$ 和一个有向边列表 $(u,v,w)$ 描述，其中 $u,v \\in \\{0,1,\\dots,n-1\\}$，权重为 $w$。\n\n- 测试用例 1（正常路径，稀疏，有负权边但无负权环）：$n = 5$，边为\n  $(0,1,-2)$、$(1,2,3)$、$(0,3,4)$、$(3,4,1)$、$(4,2,-1)$、$(1,4,2)$。\n- 测试用例 2（边界情况：无边）：$n = 4$，边为\n  （无）。\n- 测试用例 3（边缘情况：单顶点图）：$n = 1$，边为\n  （无）。\n- 测试用例 4（存在负权环）：$n = 3$，边为\n  $(0,1,1)$、$(1,2,-2)$、$(2,0,0)$。\n\n最终输出格式：\n你的程序应生成单行输出，其中包含一个方括号括起来的逗号分隔列表形式的结果。此列表中的每个元素对应一个测试用例，且其本身必须是一个三元列表 $[b,\\text{distances\\_flat},\\text{predecessors\\_flat}]$，其中 $b$ 是一个布尔值，$\\text{distances\\_flat}$ 是距离的扁平化列表，$\\text{predecessors\\_flat}$ 是前驱的扁平化列表。例如，打印的输出应如下所示：\n$[[b_1,[d_{1,0},d_{1,1},\\dots],[p_{1,0},p_{1,1},\\dots]],[b_2,[\\dots],[\\dots]],\\dots]$。\n\n你的实现不能读取任何输入，并且必须按原样运行以针对提供的测试套件生成指定的输出。", "solution": "该问题要求计算有向加权图 $G=(V, E)$ 中的所有点对之间的最短路径。图中存在实值边权重，可能包括负值，这要求我们谨慎选择算法。从每个顶点运行 Dijkstra 算法是无效的，因为其正确性依赖于非负的边权重。从每个顶点执行 Bellman-Ford 算法是一种有效但低效的方法，其时间复杂度为 $O(|V|^2|E|)$，对于大图来说是不可接受的。Johnson 算法提供了一种优雅且更高效的方法，尤其适用于稀疏图。它通过重设边的权重来消除负权重，从而允许使用更快的 Dijkstra 算法。\n\nJohnson 算法的核心原理基于一个势函数 $h: V \\to \\mathbb{R}$。对于图中每条原始权重为 $w(u, v)$ 的边 $(u, v) \\in E$，我们定义一个新的、重设后的边权重 $w_h(u, v)$ 为：\n$$w_h(u, v) = w(u, v) + h(u) - h(v)$$\n\n这种重设权重的方案有一个显著的特性：它能保持最短路径不变。考虑任意一条从源点 $s=v_0$ 到目标点 $t=v_k$ 的路径 $P = (v_0, v_1, \\dots, v_k)$。这条路径在重设权重后的图中的权重 $W_h(P)$ 为：\n$$W_h(P) = \\sum_{i=0}^{k-1} w_h(v_i, v_{i+1}) = \\sum_{i=0}^{k-1} (w(v_i, v_{i+1}) + h(v_i) - h(v_{i+1}))$$\n这个和是伸缩的，可以化简为：\n$$W_h(P) = \\left(\\sum_{i=0}^{k-1} w(v_i, v_{i+1})\\right) + h(v_0) - h(v_k) = W(P) + h(s) - h(t)$$\n由于对于任何从 $s$到 $t$ 的路径，$h(s)$ 和 $h(t)$ 都是常数，因此当且仅当一条路径的原始权重 $W(P)$ 最小时，其重设后的权重 $W_h(P)$ 也最小。因此，最短路径在这种变换下是不变的。\n\n挑战在于找到一个势函数 $h$，使得所有重设权重后的边都是非负的，即对所有 $(u, v) \\in E$，都有 $w_h(u, v) \\ge 0$。这个条件等价于：\n$$w(u, v) + h(u) - h(v) \\ge 0 \\implies h(v) \\le h(u) + w(u, v)$$\n这个不等式是三角不等式，它是最短路径算法的基础。这表明势 $h(v)$ 可以定义为从某个源顶点出发的最短路径距离。\n\n为了构造这样的势函数，我们增广原始图 $G$ 以创建一个新图 $G' = (V', E')$。我们添加一个不在 $V$ 中的新源顶点 $s'$，形成 $V' = V \\cup \\{s'\\}$。然后，我们从 $s'$ 向每个顶点 $v \\in V$ 添加权重为零的有向边，创建 $E' = E \\cup \\{(s', v) \\mid v \\in V, w(s', v) = 0\\}$。\n\n接着，我们使用 Bellman-Ford 算法计算从 $s'$ 到 $G'$ 中所有其他顶点的最短路径距离。我们将势函数 $h(v)$ 定义为从 $s'$ 到 $v$ 在 $G'$ 中的最短路径距离，即 $h(v) = d_{G'}(s', v)$。根据最短路径的三角不等式性质，对于任何边 $(u,v) \\in E \\subset E'$，必须有 $d_{G'}(s', v) \\le d_{G'}(s', u) + w(u, v)$，这正是 $h(v) \\le h(u) + w(u, v)$。这保证了我们选择的势将导致非负的重设权重 $w_h(u,v) \\ge 0$。\n\nBellman-Ford 算法还有一个至关重要的次要作用：检测负权重环。如果图 $G$ 包含负权重环，那么 $G'$ 也会包含。Bellman-Ford 能够检测到这样的环；如果在 $|V'|-1$ 轮松弛操作后，某个距离仍然可以被缩短，那么就存在一个从源点可达的负权重环。由于 $s'$ 连接到所有原始顶点，因此 $G$ 中的任何负权环都是可达的。如果检测到这样的环，Johnson 算法无法继续进行，我们必须报告此失败情况。\n\n如果没有发现负权重环，算法按以下步骤进行：\n1.  **增广：** 通过添加新源顶点 $s'$ 和所有 $v \\in V$ 的零权重边 $(s', v)$ 来构造图 $G'$。\n2.  **计算重赋权的势：** 在 $G'$ 上以 $s'$ 为源点运行 Bellman-Ford 算法。如果检测到负权重环，则终止并报告图的无效性。否则，将每个顶点 $v \\in V$ 的势设为 $h(v) = d_{G'}(s', v)$。\n3.  **图权重重设：** 对原始图 $G$ 中的所有边，计算非负权重 $w_h(u, v) = w(u, v) + h(u) - h(v)$。\n4.  **通过 Dijkstra 计算全源最短路径：** 对每个顶点 $u \\in V$，在重设权重的图上以 $u$ 为源点运行 Dijkstra 算法，以找到对所有 $v \\in V$ 的最短路径距离 $d_h(u, v)$ 和前驱。\n5.  **距离转换：** 使用逆变换恢复原始图中的最终最短路径距离：$d(u, v) = d_h(u, v) - h(u) + h(v)$。如果 $d_h(u,v)$ 是无穷大，则 $d(u,v)$ 也是无穷大。前驱矩阵无需转换，因为最短路径的结构被保留了下来。\n\n总时间复杂度主要由 Bellman-Ford 步骤决定，为 $O(|V||E'|) = O(|V|(|V|+|E|)) = O(|V||E|)$（因为在连通图中 $|E| \\ge |V|-1$），以及 $|V|$ 次 Dijkstra 算法的运行。使用二叉堆实现的 Dijkstra，此步骤需要 $O(|V|(|E|+|V|\\log|V|))$。对于 $|E|$ 接近 $|V|$ 的稀疏图，复杂度约为 $O(|V|^2 \\log|V|)$，这比运行 $|V|$ 次 Bellman-Ford 算法有显著改进。\n\n实现将构建距离矩阵 $D$（其中 $D[s][t] = d(s, t)$）和前驱矩阵 $P$（其中 $P[s][t]$ 是从 $s$ 到 $t$ 的某条最短路径上 $t$ 的前驱）。根据问题要求，$D[s][t] = \\infty$（如果 $t$ 从 $s$ 不可达），$P[s][t] = -1$（如果 $t=s$ 或 $t$ 从 $s$ 不可达）。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\nimport json\n\ndef solve():\n    \"\"\"\n    Main function to define test cases and run Johnson's algorithm on them.\n    Produces the final formatted output.\n    \"\"\"\n    \n    # Test Suite\n    test_cases = [\n        # Test case 1 (happy path, sparse, negative edges but no negative cycle)\n        {\n            \"n\": 5,\n            \"edges\": [(0, 1, -2), (1, 2, 3), (0, 3, 4), (3, 4, 1), (4, 2, -1), (1, 4, 2)]\n        },\n        # Test case 2 (boundary: no edges)\n        {\n            \"n\": 4,\n            \"edges\": []\n        },\n        # Test case 3 (edge case: single-vertex graph)\n        {\n            \"n\": 1,\n            \"edges\": []\n        },\n        # Test case 4 (negative cycle present)\n        {\n            \"n\": 3,\n            \"edges\": [(0, 1, 1), (1, 2, -2), (2, 0, 0)]\n        }\n    ]\n\n    results = []\n    for case in test_cases:\n        n = case[\"n\"]\n        edges = case[\"edges\"]\n        has_neg_cycle, dist_matrix, pred_matrix = johnson_algorithm(n, edges)\n        \n        if has_neg_cycle:\n            results.append([False, [], []])\n        else:\n            dist_flat = dist_matrix.flatten().tolist()\n            pred_flat = pred_matrix.flatten().tolist()\n            results.append([True, dist_flat, pred_flat])\n\n    # Final print statement in the exact required format.\n    # Use json.dumps for compact, space-less representation of lists.\n    print(json.dumps(results, separators=(',', ':')).replace('\\\"inf\\\"', 'inf'))\n\ndef johnson_algorithm(n, edges):\n    \"\"\"\n    Implements Johnson's algorithm for all-pairs shortest paths.\n    \n    Args:\n        n (int): The number of vertices.\n        edges (list): A list of tuples (u, v, w) representing directed edges.\n        \n    Returns:\n        A tuple (has_neg_cycle, dist_matrix, pred_matrix).\n        - has_neg_cycle (bool): True if a negative-weight cycle is detected.\n        - dist_matrix (np.array): The n x n all-pairs shortest path distance matrix.\n        - pred_matrix (np.array): The n x n predecessor matrix.\n    \"\"\"\n    if n == 0:\n        return False, np.array([]), np.array([])\n\n    # Step 1: Form the augmented graph G'\n    augmented_edges = list(edges)\n    num_vertices_augmented = n + 1\n    new_source = n\n    for i in range(n):\n        augmented_edges.append((new_source, i, 0))\n\n    # Step 2: Run Bellman-Ford from the new source\n    dist_h = np.full(num_vertices_augmented, float('inf'))\n    dist_h[new_source] = 0\n\n    for _ in range(num_vertices_augmented - 1):\n        for u, v, w in augmented_edges:\n            if dist_h[u] != float('inf') and dist_h[u] + w  dist_h[v]:\n                dist_h[v] = dist_h[u] + w\n\n    # Check for negative-weight cycles\n    for u, v, w in augmented_edges:\n        if dist_h[u] != float('inf') and dist_h[u] + w  dist_h[v]:\n            return True, None, None\n            \n    h = dist_h[:n]\n\n    # Step 3: Reweight the original graph\n    adj_list_reweighted = [[] for _ in range(n)]\n    for u, v, w in edges:\n        w_h = w + h[u] - h[v]\n        adj_list_reweighted[u].append((v, w_h))\n\n    # Step 4  5: Run Dijkstra from each vertex and compute final results\n    all_pairs_dist = np.full((n, n), float('inf'))\n    all_pairs_pred = np.full((n, n), -1, dtype=int)\n\n    for s in range(n):\n        # Run Dijkstra on the reweighted graph\n        dist_reweighted, pred_reweighted = dijkstra(n, adj_list_reweighted, s)\n        \n        # Convert distances back to original weights and store results\n        for t in range(n):\n            if dist_reweighted[t] != float('inf'):\n                all_pairs_dist[s, t] = dist_reweighted[t] - h[s] + h[t]\n            all_pairs_pred[s, t] = pred_reweighted[t]\n\n    return False, all_pairs_dist, all_pairs_pred\n\n\ndef dijkstra(n, adj, start_node):\n    \"\"\"\n    Dijkstra's algorithm for SSSP on a weighted graph with non-negative weights.\n    \n    Args:\n        n (int): Number of vertices.\n        adj (list): Adjacency list representation of the graph.\n        start_node (int): The source vertex.\n        \n    Returns:\n        A tuple (dist, pred):\n        - dist (np.array): Shortest path distances from the start node.\n        - pred (np.array): Predecessor array for reconstructing paths.\n    \"\"\"\n    dist = np.full(n, float('inf'))\n    pred = np.full(n, -1, dtype=int)\n    dist[start_node] = 0\n    pq = [(0, start_node)]  # (distance, vertex)\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        \n        if d > dist[u]:\n            continue\n\n        for v, weight in adj[u]:\n            if dist[u] + weight  dist[v]:\n                dist[v] = dist[u] + weight\n                pred[v] = u\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist, pred\n\nif __name__ == '__main__':\n    solve()\n```", "id": "3242404"}, {"introduction": "一个强大的算法不仅应能检测到问题的存在，还应提供有意义的诊断信息。在这个练习中，你将对基础实现进行扩展，使其在检测到负权重环时，能够精确地识别并报告构成环的顶点序列[@problem_id:3242418]。这项技能对于调试图数据和理解为何最短路径无定义至关重要，是算法应用与问题排查的关键一步。", "problem": "给定一个稀疏的有向加权图，稀疏意味着边的数量 $|E|$ 满足 $|E| \\ll |V|^2$，其中 $V$ 是顶点集，$E$ 是边集。设图为 $G = (V, E)$，权重函数为 $w : E \\to \\mathbb{R}$。路径的权重定义为其构成边的权重之和。负环是一个总边权重严格小于 $0$ 的有向环。从顶点 $u$ 到顶点 $v$ 的最短路径距离是从 $u$ 到 $v$ 的所有有向路径权重的下确界；如果不存在路径，则距离为 $+\\infty$。所有顶点均由从 $0$ 开始的整数标记。\n\n你的任务是实现一个适用于稀疏图的 Johnson 算法版本，该版本使用 Bellman–Ford 松弛原理和基于势能的重赋权来计算所有点对的最短路径。当不存在负环时，使用 Dijkstra 算法；但如果存在负环，则需重构并报告该负环中的顶点序列。算法基础必须从第一性原理推导得出：\n\n- Bellman–Ford 松弛原理：如果 $d[v]$ 表示到顶点 $v$ 的当前距离估计值，并且存在权重为 $w(u, v)$ 的边 $(u, v) \\in E$，那么当 $d[u] + w(u, v)  d[v]$ 时，可以进行松弛。当从一个连接到每个顶点且权重为零的超级源点 $s$ 运行 Bellman–Ford 算法时，经过 $|V| - 1$ 次迭代后仍存在任何松弛，则意味着存在一个从 $s$ 可达的负环。\n- 通过势能进行重赋权：给定一个势函数 $h : V \\to \\mathbb{R}$，通过 $w'(u, v) = w(u, v) + h(u) - h(v)$ 定义新的边权重。对于从 $s$ 到 $t$ 的任何路径 $P$，$w'(P) = w(P) + h(s) - h(t)$。如果 $h$ 等于增广图中从超级源点出发的最短路径距离，那么所有的 $w'(u, v)$ 都将是非负的，从而可以在 $w'$ 上使用 Dijkstra 算法。\n- 三角不等式和路径最优性属性：最短路径满足对于任何顶点 $x, y, z$，$d[x, z] \\le d[x, y] + w(y, z)$，并且基于势能的重赋权保留了路径权重的相对顺序，因此也保留了最短路径的身份。\n\n除了检测负环的存在，当负环存在时，程序必须重构并返回一个负环的顶点序列。该环必须作为环上不同顶点标签的有序列表返回，末尾不重复起始顶点，并进行归一化，使其从环中最小的顶点标签开始。如果没有负环，程序必须返回所有点对最短路径距离矩阵，按行主序展平。对于不可达的点对，距离必须编码为 $+\\infty$。\n\n输入作为一组图的测试套件嵌入在程序中。没有外部输入。程序必须生成单行输出，其中包含所有测试用例的结果，形式为方括号括起来的逗号分隔列表。每个测试用例的结果必须是以下之一：\n- 一个整数列表，表示重构出的负环的顶点序列，或\n- 一个距离列表（有限距离为整数，不可达点对为浮点无穷大值），通过按行主序展平所有点对矩阵获得。\n\n使用以下参数值的测试套件，旨在覆盖理想路径、边界情况和边缘情况：\n\n- 测试用例 1（理想路径，稀疏，有负边但无负环）：$|V| = 5$，边\n  $\\{(0, 1, 3), (0, 2, 8), (1, 2, -4), (1, 3, 1), (2, 3, 2), (3, 4, 7), (4, 1, -2)\\}$。\n  预期结果类型：展平的所有点对距离。\n- 测试用例 2（存在负环）：$|V| = 3$，边\n  $\\{(0, 1, -1), (1, 2, -1), (2, 0, -1)\\}$。\n  预期结果类型：一个负环顶点序列（归一化为从最小标签开始）。\n- 测试用例 3（不连通的稀疏图，无负环）：$|V| = 4$，边\n  $\\{(0, 1, 2), (2, 3, 5)\\}$。\n  预期结果类型：展平的所有点对距离，对不可达点对使用 $+\\infty$。\n- 测试用例 4（单顶点图）：$|V| = 1$，边 $\\{\\}$。\n  预期结果类型：展平的所有点对距离。\n- 测试用例 5（自环负环）：$|V| = 2$，边\n  $\\{(0, 0, -2), (0, 1, 5)\\}$。\n  预期结果类型：一个负环顶点序列（归一化为从最小标签开始）。\n\n你的程序应生成单行输出，包含格式为\n$[r_1, r_2, r_3, r_4, r_5]$\n的结果，其中每个 $r_i$ 是上述为测试用例 $i$ 描述的列表。不涉及物理单位、角度和百分比；答案是指定的纯数值。", "solution": "用户要求实现 Johnson 算法，用于计算稀疏、有向、加权图中的所有点对最短路径。该算法还必须能够检测并在存在负权环时报告一个负权环。解决方案必须按照问题描述中概述的第一性原理推导得出。\n\n该问题在计算上是明确定义的，科学上基于成熟的图论，并提出了一个完整、无矛盾的规范。因此，该问题被认为是有效的。\n\n解决方案通过一个基于 Bellman-Ford 松弛、基于势能的重赋权和 Dijkstra 算法原理的三阶段过程实现。\n\n**1. 负环检测与势能计算**\n\n所有点对最短路径问题中的主要挑战是负边权的存在，这排除了直接使用像 Dijkstra 这样的高效算法。Johnson 算法通过首先检测负环来解决这个问题，如果没有负环，则将边重赋权为非负值。\n\n这一阶段通过在增广图上使用 Bellman-Ford 算法来完成。设给定图为 $G=(V, E)$，权重函数为 $w$。我们构建一个新图 $G'=(V', E')$，其中：\n- 顶点集为 $V' = V \\cup \\{s\\}$，其中 $s$ 是一个不在 $V$ 中的新“超级源点”顶点。\n- 边集为 $E' = E \\cup \\{(s, v) : v \\in V\\}$。\n- 对于 $E$ 中的边，权重函数仍为 $w$。对于新边，我们定义对所有 $v \\in V$，$w(s, v)=0$。\n\n根据构造， $G$ 中的任何负环也存在于 $G'$ 中（因为 $s$ 不可能成为任何环的一部分），并且可以从 $s$ 到达。我们现在从 $s$ 开始在 $G'$ 上运行 Bellman-Ford 算法。该算法将到 $s$ 的距离估计初始化为 $d[s]=0$，到所有其他顶点 $v \\in V$ 的距离估计初始化为 $d[v]=\\infty$。然后，它迭代地松弛 $E'$ 中的所有边。对于权重为 $w(u,v)$ 的边 $(u, v)$，如果 $d[u] + w(u,v)  d[v]$，则松弛操作为更新 $d[v] = d[u] + w(u,v)$。\n\nBellman-Ford 算法对每条边执行 $|V'|-1 = |V|$ 次松弛迭代。经过 $|V|$ 次迭代后，如果从 $s$ 到任何顶点 $v$ 的最短路径存在且不涉及负环，其距离 $\\delta(s, v)$ 将被找到。这是因为任何这样的简单路径最多可以有 $|V|$ 条边（从 $s$ 到某个 $u \\in V$，然后在 $V$ 内有一条长度最多为 $|V|-1$ 的路径）。\n\n为了检测负环，我们再执行一次额外的第 $(|V|+1)$ 次松弛迭代。如果任何距离 $d[v]$ 仍然可以减少，这证明存在一个可从 $s$ 到达的负权环。\n\n如果对于边 $(u, v)$ 发生这样的松弛，即 $d[u] + w(u, v)  d[v]$，我们可以重构该环。顶点 $v$ 要么在一个负环上，要么可以从一个负环到达。通过从 $v$ 回溯前驱（在松弛过程中存储） $|V|$ 步，我们保证能到达一个位于负环上的顶点 $y$。然后，我们可以通过从 $y$ 经由前驱反复回溯直到再次遇到 $y$ 来重构此环中的顶点序列。得到的序列随后被归一化，以环中具有最小整数标签的顶点开始。\n\n如果在 $|V|$ 次迭代后没有更多可行的松弛，则图 $G$ 没有负环。计算出的距离 $d[v]$ 代表从 $s$ 到每个顶点 $v$ 的最短路径距离，记为 $h(v) = \\delta_{G'}(s, v)$。这些值将用作重赋权的势能。\n\n**2. 通过势能进行图的重赋权**\n\n如果没有发现负环，我们使用计算出的势能 $h(v)$ 为原始图 $G$ 定义一个新的非负权重函数 $w'$：\n$$w'(u, v) = w(u, v) + h(u) - h(v)$$\n对于每条边 $(u, v) \\in E$。\n\n$w'$ 的非负性由最短路径的三角不等式性质保证。对于 $E$ 中的任何边 $(u, v)$，$G'$ 中从 $s$ 到 $v$ 的最短路径不可能比从 $s$ 到 $u$ 的路径后接边 $(u, v)$ 更长。形式上：\n$$\\delta_{G'}(s, v) \\le \\delta_{G'}(s, u) + w(u, v)$$\n代入我们的势能 $h(v) = \\delta_{G'}(s, v)$，我们得到：\n$$h(v) \\le h(u) + w(u, v)$$\n重新整理这个不等式得到：\n$$w(u, v) + h(u) - h(v) \\ge 0$$\n因此，保证每个新权重 $w'(u, v)$ 都是非负的。\n\n**3. 使用 Dijkstra 算法计算所有点对最短路径**\n\n有了非负权重函数 $w'$，我们现在可以通过在重赋权图 $(G, w')$ 上从每个顶点 $u \\in V$ 运行 Dijkstra 算法来高效地计算所有点对最短路径。这将产生重赋权图中所有点对 $(u, v)$ 的最短路径距离 $\\delta'(u, v)$。\n\n这些距离必须转换回去以对应于原始权重函数 $w$。任何路径 $P = \\langle v_0, v_1, \\dots, v_k \\rangle$ 在 $w'$ 下的权重通过一个伸缩求和与它在 $w$ 下的权重相关联：\n$$w'(P) = \\sum_{i=1}^{k} w'(v_{i-1}, v_i) = \\sum_{i=1}^{k} (w(v_{i-1}, v_i) + h(v_{i-1}) - h(v_i)) = w(P) + h(v_0) - h(v_k)$$\n这种转换保留了最短路径的身份，意味着在 $(G, w')$ 中的最短路径在 $(G, w)$ 中也是最短路径。因此，原始图中的最短路径距离 $\\delta(u,v)$ 可以从重赋权图中的最短路径距离 $\\delta'(u, v)$ 中恢复：\n$$\\delta(u, v) = \\delta'(u, v) - h(u) + h(v)$$\n如果从 $u$ 到 $v$ 不存在路径，Dijkstra 算法将得到 $\\delta'(u, v) = \\infty$，因此 $\\delta(u, v) = \\infty$。\n\n通过应用这个三阶段过程，我们可以稳健地计算任何稀疏加权有向图中的所有点对最短路径，正确处理带有负边权的情况，并在存在负环时提供一个具体的负环示例。对于无环情况的最终结果是 $|V| \\times |V|$ 的距离矩阵 $\\delta(u, v)$，然后将其按行主序展平为一个列表。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport heapq\n\ndef johnson_algorithm(num_vertices, edges):\n    \"\"\"\n    Implements Johnson's algorithm for all-pairs shortest paths.\n    Detects and reconstructs a negative cycle if one exists.\n    \"\"\"\n    if num_vertices == 0:\n        return []\n\n    # Step 1: Bellman-Ford on the augmented graph\n    # Add super-source 's' (vertex num_vertices) and 0-weight edges to all vertices\n    s = num_vertices\n    h = np.full(num_vertices + 1, np.inf)\n    h[s] = 0\n    predecessor = np.full(num_vertices, -1, dtype=int)\n\n    # The augmented graph has |V|+1 vertices, so we need |V| iterations\n    for i in range(num_vertices):\n        updated_in_iteration = False\n        # Relax original edges\n        for u, v, weight in edges:\n            if h[u] != np.inf and h[u] + weight  h[v]:\n                h[v] = h[u] + weight\n                predecessor[v] = u\n                updated_in_iteration = True\n        # For the first iteration, also relax edges from the super-source\n        if i == 0:\n            for v_idx in range(num_vertices):\n                if h[s] + 0  h[v_idx]:\n                    h[v_idx] = 0\n                    # Predecessor from 's' is not tracked as it's not in the original graph\n                    updated_in_iteration = True\n        if not updated_in_iteration and i > 0:\n            break\n    \n    # Check for negative cycles\n    for u, v, weight in edges:\n        if h[u] != np.inf and h[u] + weight  h[v]:\n            # Negative cycle found. Reconstruct it.\n            # Find a vertex on the cycle by tracing back |V| times from 'v'.\n            cycle_node = v\n            for _ in range(num_vertices):\n                if predecessor[cycle_node] == -1: # Should not happen in a cycle\n                    return None # Error case\n                cycle_node = predecessor[cycle_node]\n\n            # Trace back from cycle_node to find the cycle vertices\n            cycle = []\n            curr = cycle_node\n            while True:\n                cycle.append(curr)\n                if predecessor[curr] == -1: return None # Should not happen\n                curr = predecessor[curr]\n                if curr == cycle_node:\n                    break\n                if curr in cycle: # Should not happen in simple cycles\n                   # Fallback for complex cycle structures found from a path\n                   # Start reconstruction from the first repeated node\n                   cycle_node = curr\n                   cycle = []\n                   continue\n            \n            cycle.reverse()\n\n            # Normalize the cycle to start with the smallest vertex ID\n            if not cycle:\n                # Handle self-loop case detected by Bell-Ford\n                if u == v:\n                    return [u]\n                \n            min_val = min(cycle)\n            min_idx = cycle.index(min_val)\n            normalized_cycle = cycle[min_idx:] + cycle[:min_idx]\n            return normalized_cycle\n\n    potentials = h[:num_vertices]\n\n    # Step 2: Reweight the graph\n    reweighted_edges = {}\n    for i in range(num_vertices):\n        reweighted_edges[i] = []\n    for u, v, weight in edges:\n        if potentials[u] != np.inf and potentials[v] != np.inf:\n            new_weight = weight + potentials[u] - potentials[v]\n            reweighted_edges[u].append((v, new_weight))\n\n    # Step 3: Run Dijkstra from each vertex\n    all_pairs_dist = np.full((num_vertices, num_vertices), np.inf)\n    \n    for i in range(num_vertices):\n        all_pairs_dist[i, i] = 0\n\n    for start_node in range(num_vertices):\n        dist_prime = np.full(num_vertices, np.inf)\n        dist_prime[start_node] = 0\n        pq = [(0, start_node)]\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d > dist_prime[u]:\n                continue\n\n            for v, weight_prime in reweighted_edges.get(u, []):\n                if dist_prime[u] + weight_prime  dist_prime[v]:\n                    dist_prime[v] = dist_prime[u] + weight_prime\n                    heapq.heappush(pq, (dist_prime[v], v))\n        \n        # Convert distances back to original weights\n        for v in range(num_vertices):\n            if dist_prime[v] != np.inf:\n                all_pairs_dist[start_node, v] = dist_prime[v] - potentials[start_node] + potentials[v]\n\n    return all_pairs_dist\n\n\ndef solve():\n    \"\"\"\n    Defines test cases and runs the Johnson algorithm on them, printing the results.\n    \"\"\"\n    test_cases = [\n        (5, {(0, 1, 3), (0, 2, 8), (1, 2, -4), (1, 3, 1), (2, 3, 2), (3, 4, 7), (4, 1, -2)}),\n        (3, {(0, 1, -1), (1, 2, -1), (2, 0, -1)}),\n        (4, {(0, 1, 2), (2, 3, 5)}),\n        (1, set()),\n        (2, {(0, 0, -2), (0, 1, 5)})\n    ]\n\n    results = []\n    for V, edges in test_cases:\n        result = johnson_algorithm(V, edges)\n        \n        if isinstance(result, np.ndarray):\n            # It's the distance matrix\n            flat_list = result.flatten().tolist()\n            # As per problem, \"integers for finite distances\"\n            processed_res = [int(round(x)) if x != np.inf else float('inf') for x in flat_list]\n        else:\n            # It's the cycle list\n            processed_res = result\n        \n        results.append(processed_res)\n\n    # Custom string formatting to match expected output, e.g., [[0,1],[...]]\n    # str(list) adds spaces, which we want to remove for compact output.\n    result_strings = [str(r).replace(\" \", \"\") for r in results]\n    final_output = f\"[{','.join(result_strings)}]\"\n    print(final_output.replace('\\'inf\\'', 'inf'))\n\nsolve()\n```", "id": "3242418"}, {"introduction": "当算法的一个核心组件出现故障时，它会如何表现？这个思想实验模拟了约翰逊算法中狄克斯特拉步骤的一个特定错误[@problem_id:3242537]。通过精确计算由此产生的最终误差，你将更深刻地体会到狄克斯特拉算法对非负权重的严格要求，以及局部故障如何影响整个算法框架的最终结果。", "problem": "考虑一个有向加权图 $G = (V, E)$，其中 $V = \\{s, a, b, c, t\\}$，$E$ 由以下重加权后的边和权重给出。这些边和权重是由 Johnson 算法的标准重加权步骤产生的，该步骤使用顶点势函数 $h: V \\to \\mathbb{R}$，使得所有重加权后的边权重为非负。重加权后的权重表示为 $w'(u, v) = w(u, v) + h(u) - h(v)$，在本问题中，重加权图 $G' = (V, E, w')$ 被指定为：\n- 边 $(s, a)$ 的权重为 $w'(s, a) = 1$，\n- 边 $(a, b)$ 的权重为 $w'(a, b) = 1$，\n- 边 $(b, t)$ 的权重为 $w'(b, t) = 1$，\n- 边 $(s, c)$ 的权重为 $w'(s, c) = 9$，\n- 边 $(c, t)$ 的权重为 $w'(c, t) = 1$，\n- 边 $(s, t)$ 的权重为 $w'(s, t) = 10$。\n\n假设 Johnson 算法正确地完成了重加权步骤，因此 $G'$ 中的所有最短路径通过关系式 $d_{G}(u, v) = d_{G'}(u, v) - h(u) + h(v)$ 对应于 $G$ 中的最短路径，其中 $d_{G'}(u, v)$ 表示 $G'$ 中的最短路径距离。\n\n现在，考虑在 Johnson 算法中，在图 $G'$ 上使用 Dijkstra 算法从源点 $s$ 计算单源最短路径。假设其实现使用了一个偶尔会违反堆性质的优先队列（PQ）。在一次从 $s$ 开始的特定运行中，该优先队列执行了以下操作：\n- 它首先正确地提取了 $s$ 并松弛其出边。\n- 它第二次正确地提取了 $a$ 并松弛其出边。\n- 在第三次提取最小值操作时，它错误地返回了 $t$，而不是实际的最小键值顶点 $b$（这是本次运行中唯一的堆性质违规）。此后，所有后续操作都忠实地遵循 Dijkstra 算法的规则。\n\n利用最短路径长度的定义以及 Dijkstra 算法在非负边权重图上所需的正确性不变量，确定 Johnson 算法为原始图 $G$ 中的点对 $(s, t)$ 报告的最终距离的最坏情况绝对误差。将您的答案表示为单个实数。不要四舍五入；需要精确值。", "solution": "用户希望确定因 Johnson 算法执行过程中的特定故障导致的最短路径距离计算中的绝对误差。该问题定义明确，并在算法理论方面具有科学依据。\n\n解决过程包括三个主要步骤：\n1.  确定重加权图 $G'$ 中的真实最短路径距离。\n2.  模拟 Dijkstra 算法在 $G'$ 上的错误执行，以找出错误计算出的距离。\n3.  计算绝对误差，并说明该误差如何从重加权图 $G'$ 转换到原始图 $G$。\n\n**步骤 1：$G'$ 中的真实最短路径距离**\n\n问题提供了一个重加权图 $G' = (V, E, w')$，其顶点集为 $V = \\{s, a, b, c, t\\}$，边权重为非负的 $w'$。我们需要找到从源顶点 $s$ 到目标顶点 $t$ 的真实最短路径距离，我们将其表示为 $d_{G'}(s, t)$。我们可以枚举从 $s$ 到 $t$ 的简单路径并计算它们的总权重：\n- 路径 $p_1 = (s, t)$：长度为 $d(p_1) = w'(s, t) = 10$。\n- 路径 $p_2 = (s, a, b, t)$：长度为 $d(p_2) = w'(s, a) + w'(a, b) + w'(b, t) = 1 + 1 + 1 = 3$。\n- 路径 $p_3 = (s, c, t)$：长度为 $d(p_3) = w'(s, c) + w'(c, t) = 9 + 1 = 10$。\n\n真实的最短路径距离是这些路径长度的最小值：\n$$d_{G'}(s, t) = \\min(10, 3, 10) = 3$$\n\n**步骤 2：模拟错误的 Dijkstra 算法**\n\nJohnson 算法在重加权图 $G'$ 上从每个顶点运行 Dijkstra 算法。问题描述了其中一次从源点 $s$ 开始的运行，并伴随一个特定的优先队列故障。让我们跟踪 Dijkstra 算法的状态，记录每个顶点 $v$ 的距离估计值 $d[v]$ 以及最短路径已确定的顶点集合 $S$。\n\n- **初始化：** 距离数组初始化为 $d[s] = 0$，对于所有其他顶点 $v \\in V \\setminus \\{s\\}$，初始化为 $d[v] = \\infty$。已确定路径的顶点集合为 $S = \\emptyset$。优先队列（PQ）包含所有顶点，以其距离估计值为键。\n\n- **第一次提取（正确）：** 从优先队列中提取顶点 $s$。我们设置 $S = \\{s\\}$。对从 $s$ 出发的边进行松弛：\n  - $d[a]$ 变为 $\\min(\\infty, d[s] + w'(s, a)) = 0 + 1 = 1$。\n  - $d[c]$ 变为 $\\min(\\infty, d[s] + w'(s, c)) = 0 + 9 = 9$。\n  - $d[t]$ 变为 $\\min(\\infty, d[s] + w'(s, t)) = 0 + 10 = 10$。\n  距离数组现在为 $d = \\{s:0, a:1, b:\\infty, c:9, t:10\\}$。优先队列中包含 $\\{(a, 1), (c, 9), (t, 10), (b, \\infty)\\}$。\n\n- **第二次提取（正确）：** 具有最小距离估计值的顶点是 $a$，其 $d[a] = 1$。提取该顶点，并设置 $S = \\{s, a\\}$。对其出边 $(a, b)$ 进行松弛：\n  - $d[b]$ 变为 $\\min(\\infty, d[a] + w'(a, b)) = 1 + 1 = 2$。\n  距离数组为 $d = \\{s:0, a:1, b:2, c:9, t:10\\}$。优先队列现在有效地包含 $\\{(b, 2), (c, 9), (t, 10)\\}$。\n\n- **第三次提取（错误）：** 优先队列中距离最小的顶点是 $b$，其 $d[b] = 2$。然而，问题陈述优先队列错误地返回了 $t$。算法提取 $t$ 并将其加入已确定集合，即 $S = \\{s, a, t\\}$。此时，算法认为到 $t$ 的距离已经最终确定。因此，计算出的从 $s$ 到 $t$ 的最短路径距离被固定为：\n$$d_{G', \\text{computed}}(s, t) = d[t] = 10$$\n顶点 $t$ 没有出边需要松弛。\n\n- **后续提取（正确过程）：** 问题陈述后续操作是正确的。Dijkstra 算法在非负权重图上的一个关键不变量是，一旦一个顶点被添加到集合 $S$ 中，其路径距离就被视为最终值，不会再被更新。算法忠实地遵循此规则进行。\n  - 下一个提取的顶点是 $b$。$S = \\{s, a, t, b\\}$。对其出边 $(b, t)$ 进行松弛。通过 $b$ 的路径会得到一个距离 $d[b] + w'(b, t) = 2 + 1 = 3$。然而，由于 $t$ 已经在 $S$ 中，其距离 $d[t]=10$ 不会被更新。\n  - 最后一个提取的顶点是 $c$。$S = \\{s, a, t, b, c\\}$。对其出边 $(c, t)$ 进行松弛。通过 $c$ 的路径距离为 $d[c] + w'(c, t) = 9 + 1 = 10$。这不比 $d[t]=10$ 短，因此无论如何都不会发生更新。\n\n算法终止，得出的计算距离为 $d_{G', \\text{computed}}(s, t) = 10$。\n\n**步骤 3：计算绝对误差**\n\nJohnson 算法的最后一步是使用在重加权步骤中推导出的势函数 $h(v)$，将最短路径距离从 $G'$ 转换回原始图 $G$：\n$$d_G(u, v) = d_{G'}(u, v) - h(u) + h(v)$$\n\n原始图 $G$ 中点对 $(s, t)$ 的真实最短距离是：\n$$d_{G, \\text{true}}(s, t) = d_{G'}(s, t) - h(s) + h(t) = 3 - h(s) + h(t)$$\n\n在原始图 $G$ 中错误计算出的距离是：\n$$d_{G, \\text{computed}}(s, t) = d_{G', \\text{computed}}(s, t) - h(s) + h(t) = 10 - h(s) + h(t)$$\n\n绝对误差是计算值与真实值之差的绝对值：\n\\begin{align*}\n\\text{Absolute Error} = |d_{G, \\text{computed}}(s, t) - d_{G, \\text{true}}(s, t)| \\\\\n= |(10 - h(s) + h(t)) - (3 - h(s) + h(t))| \\\\\n= |10 - 3 - h(s) + h(s) + h(t) - h(t)| \\\\\n= |7| \\\\\n= 7\n\\end{align*}\n势函数项 $h(s)$ 和 $h(t)$ 相互抵消，这表明在重加权图中计算距离的误差与为原始图报告的最终距离的误差是相同的。问题中“最坏情况”的措辞指的是，标准的 Dijkstra 算法实现不会修正已确定顶点的距离，从而让错误持续存在，这代表了针对此特定故障的最坏结果。", "answer": "$$\\boxed{7}$$", "id": "3242537"}]}