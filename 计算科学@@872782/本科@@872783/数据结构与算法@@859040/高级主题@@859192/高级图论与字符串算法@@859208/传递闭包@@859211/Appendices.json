{"hands_on_practices": [{"introduction": "我们首先从一个基本问题入手：如何从一个图的邻接矩阵计算其传递闭包。本练习将引导你使用 Warshall-Floyd 算法来确定所有顶点对之间的可达性，然后利用计算出的闭包矩阵来解决一个经典的图论问题——将图划分为其各个连通分量。这个实践将帮助你巩固抽象矩阵运算与具体图属性之间的联系 [@problem_id:3279632]。", "problem": "您的任务是计算无向图的所有连通分量。您需要先从对称邻接矩阵出发，构建其可达性关系的传递闭包。请完全在纯数学和逻辑的框架内，根据以下基础进行操作。基本构成包括：简单无向图的定义、邻接矩阵的定义、路径和可达性的定义，以及在逻辑半环（其中加法是逻辑析取，乘法是逻辑合取）上矩阵乘积的解释。基于这些，推导出一个算法，该算法计算传递闭包，然后将顶点集划分为连通分量。\n\n用作起点的定义：\n- 一个简单无向图拥有一个顶点集 $\\{0,1,\\dots,n-1\\}$ 和一个边集，边集是无序对的子集。其对称邻接矩阵是一个 $n\\times n$ 的矩阵 $A$，其元素在 $\\{0,1\\}$ 中，其中 $A[i,j]=1$ 当且仅当顶点 $i$ 和 $j$ 之间存在一条边，否则 $A[i,j]=0$。对称性条件为对所有 $i,j$ 都有 $A[i,j]=A[j,i]$。\n- 从顶点 $i$ 到顶点 $j$ 的路径是一个顶点序列，其中相邻顶点间都有边；可达性是指至少存在一条路径。\n- 在逻辑半环上，逻辑析取（记作 $\\lor$）作为加法，逻辑合取（记作 $\\land$）作为乘法。布尔矩阵乘法对应于路径拼接，布尔矩阵的幂对应于有界长度路径的存在性。\n\n任务：\n1. 仅使用上述基础，推导出一个正确且能终止的算法。该算法给定一个大小为 $n\\times n$ 的对称邻接矩阵 $A$，计算其可达性的自反传递闭包 $R$，即一个布尔矩阵 $R$，其中 $R[i,j]=1$ 当且仅当存在一条从 $i$ 到 $j$ 的长度至少为 $0$ 的路径。您必须在不执行如图深度优先搜索或广度优先搜索等图遍历的情况下获得 $R$；相反，您必须直接在逻辑半环下对矩阵进行操作。\n2. 使用计算出的闭包 $R$ 将 $\\{0,1,\\dots,n-1\\}$ 划分为连通分量。两个顶点 $i$ 和 $j$ 处于同一连通分量中，当且仅当 $R[i,j]=1$。将每个分量输出为按严格递增顺序排列的顶点索引列表。输出的分量列表应按每个分量中最小顶点索引的递增顺序排列。\n\n此任务的输入规范：\n- 没有运行时输入。您的程序必须在内部使用以下测试套件并从中产生输出。\n- 测试套件包含以下对称邻接矩阵。每个矩阵元素都在 $\\{0,1\\}$ 中，每个矩阵都是对称的，索引是基于 $0$ 的。\n  1. 测试 $T_1$ ($n=6$):\n     $\n     A_1=\n     \\begin{bmatrix}\n     0  1  0  0  0  0\\\\\n     1  0  1  0  0  0\\\\\n     0  1  0  0  0  0\\\\\n     0  0  0  0  1  0\\\\\n     0  0  0  1  0  0\\\\\n     0  0  0  0  0  0\n     \\end{bmatrix}\n     $\n  2. 测试 $T_2$ ($n=4$):\n     $\n     A_2=\n     \\begin{bmatrix}\n     0  1  1  1\\\\\n     1  0  1  1\\\\\n     1  1  0  1\\\\\n     1  1  1  0\n     \\end{bmatrix}\n     $\n  3. 测试 $T_3$ ($n=3$):\n     $\n     A_3=\n     \\begin{bmatrix}\n     0  0  0\\\\\n     0  0  0\\\\\n     0  0  0\n     \\end{bmatrix}\n     $\n  4. 测试 $T_4$ ($n=1$):\n     $\n     A_4=\n     \\begin{bmatrix}\n     0\n     \\end{bmatrix}\n     $\n  5. 测试 $T_5$ ($n=5$):\n     $\n     A_5=\n     \\begin{bmatrix}\n     0  1  0  0  0\\\\\n     1  0  1  0  0\\\\\n     0  1  0  0  0\\\\\n     0  0  0  1  0\\\\\n     0  0  0  0  0\n     \\end{bmatrix}\n     $\n     注意：在 $A_5$ 中，位置 $(3,3)$ 处的对角线元素 $1$ 表示顶点 $3$ 上的自环。在无向图中，自环本身不会连接不同的顶点。\n\n输出规范：\n- 对于每个测试矩阵 $A_k$，按规定计算连通分量列表。将所有测试的结果汇总到一行中。\n- 最终输出格式：您的程序应生成一个单行，其中包含一个无空格的类JSON数组，其中第 $k$ 个元素是 $A_k$ 的分量列表，每个分量是一个顶点索引列表。例如，一个包含两个测试的输出可能看起来像 $[[[0,1],[2]],[[0]]]$。\n- 此问题不涉及物理单位、角度或百分比。\n\n交付成果：\n- 一个完整的、可运行的程序，该程序按规定执行计算，并以要求的格式精确打印一行输出。", "solution": "所述问题是有效的。这是一个在图算法和离散数学领域内定义明确、自成体系且具有科学依据的问题。它基于标准的、无争议的定义，并要求推导和实现一个经典的算法。约束条件清晰，不包含矛盾。该问题可以使用已建立的数学原理进行形式化和解决。\n\n解决方案分两部分呈现。首先，我们推导出一个使用逻辑半环上的矩阵运算来计算图的邻接关系自反传递闭包的算法。其次，我们描述如何使用这个闭包矩阵将图的顶点划分为连通分量。\n\n### 第1部分：自反传递闭包的计算\n\n给定一个简单无向图 $G$，其顶点集为 $V = \\{0, 1, \\dots, n-1\\}$，由其对称的 $n \\times n$ 邻接矩阵 $A$ 表示。$A$ 的元素在 $\\{0, 1\\}$ 中，其中 $A[i,j]=1$ 表示顶点 $i$ 和顶点 $j$ 之间存在一条边。所有矩阵运算都在逻辑半环 $(\\{0, 1\\}, \\lor, \\land)$ 上执行，其中 $\\lor$ 是逻辑析取（OR），$\\land$ 是逻辑合取（AND）。\n\n元素 $A[i,j]$ 表示从顶点 $i$ 到顶点 $j$ 存在长度为 $1$ 的路径。在逻辑半环上的矩阵乘积 $A^2 = A \\otimes A$ 定义为 $(A^2)[i,j] = \\bigvee_{k=0}^{n-1} (A[i,k] \\land A[k,j])$。一个元素 $(A^2)[i,j]$ 为 $1$ 当且仅当存在一个中间顶点 $k$，使得存在路径 $i \\to k \\to j$。这对应于一条长度为 $2$ 的路径。通过归纳，矩阵的幂 $A^p$ 是一个矩阵，其中 $(A^p)[i,j]=1$ 当且仅当从 $i$ 到 $j$ 存在一条长度恰好为 $p$ 的路径。\n\n问题要求计算自反传递闭包，记为 $R$，其中 $R[i,j]=1$ 当且仅当存在一条从 $i$ 到 $j$ 的长度至少为 $0$ 的路径。任何顶点到自身都存在一条长度为 $0$ 的路径。从 $i$ 到 $j$ 存在长度 $\\ge 0$ 的路径意味着存在长度为 $0$ 的路径，或长度为 $1$ 的路径，或长度为 $2$ 的路径，依此类推。这可以表示为矩阵幂的无穷析取：\n$$ R = I \\lor A \\lor A^2 \\lor A^3 \\lor \\dots $$\n其中 $I$ 是单位矩阵，代表长度为 $0$ 的路径。在一个有 $n$ 个顶点的图中，任意两个不同顶点之间的任何长度为 $n$ 或更长的路径必定包含一个环。这意味着如果两个顶点之间存在路径，那么也存在一条简单路径（没有重复顶点），其长度最多为 $n-1$。因此，我们只需要考虑长度至多为 $n-1$ 的路径来确定任意两个不同顶点之间的可达性。自反性由长度为 $0$ 的路径处理。因此，该级数可以截断：\n$$ R = I \\lor A \\lor A^2 \\lor \\dots \\lor A^{n-1} $$\n虽然这可以通过重复的矩阵乘法计算，但一个更直接、更有效的计算此闭包的方法是 Warshall-Floyd 算法，该算法源于图结构上的动态规划原理。\n\n设 $R^{(k)}[i,j]$ 为一个布尔值，表示从顶点 $i$ 到顶点 $j$ 是否存在一条只使用来自集合 $\\{0, 1, \\dots, k\\}$ 的中间顶点的路径。\n基本情况考虑没有中间顶点的路径，即长度为 $0$（一个顶点到自身）或长度为 $1$（一条直接的边）的路径。我们初始化一个矩阵 $R$ 来表示这一点：$R \\leftarrow A \\lor I$。这个矩阵可以被认为是 $R^{(-1)}$。\n\n对于递推步骤，使用来自 $\\{0, 1, \\dots, k\\}$ 的中间顶点从 $i$到 $j$ 的路径存在的条件是以下两者之一：\n1.  已存在一条使用来自 $\\{0, 1, \\dots, k-1\\}$ 的中间顶点的路径。\n2.  存在一条从 $i$到 $k$ 的路径和一条从 $k$到 $j$ 的路径，两者都只使用来自 $\\{0, 1, \\dots, k-1\\}$ 的中间顶点。\n\n当我们引入一个新的允许的中间顶点 $k$ 时，这给出了每个元素 $[i,j]$ 的递推关系：\n$$ R^{(k)}[i,j] = R^{(k-1)}[i,j] \\lor (R^{(k-1)}[i,k] \\land R^{(k-1)}[k,j]) $$\n通过将 $k$ 从 $0$ 迭代到 $n-1$，我们系统地为所有端点对 $(i,j)$ 考虑了所有可能的中间顶点。最终的矩阵 $R \\equiv R^{(n-1)}$ 将表示任意两个顶点之间是否存在任意长度的路径。\n\n计算自反传递闭包 $R$ 的完整算法如下：\n1.  初始化一个 $n \\times n$ 矩阵 $R$，使得 $R[i,j] = A[i,j] \\lor \\delta_{ij}$，其中 $\\delta_{ij}$ 是克罗内克δ（如果 $i=j$ 则为 $1$，否则为 $0$）。这等价于 $R \\leftarrow A \\lor I$。\n2.  对于 $k$ 从 $0$ 到 $n-1$：\n    对于 $i$ 从 $0$ 到 $n-1$：\n        对于 $j$ 从 $0$ 到 $n-1$：\n            $R[i,j] \\leftarrow R[i,j] \\lor (R[i,k] \\land R[k,j])$。\n循环完成后，$R$ 就是自反传递闭包矩阵。\n\n关于测试用例 $A_5$ 中自环的说明：矩阵 $A_5$ 有一个元素 $A_5[3,3]=1$。这表示一条从顶点 $3$ 到其自身的长度为 $1$ 的路径。自反传递闭包的计算始于用 $A \\lor I$ 初始化 $R$。由于 $I[3,3]$ 也为 $1$，$A_5$ 中的自环不会为初始 $R$ 矩阵增加新信息，也不会影响最终结果，因为从一个顶点到其自身的可达性由“自反”属性保证。\n\n### 第2部分：划分为连通分量\n\n对于无向图，可达性关系是一种等价关系：\n-   **自反性**：每个顶点都可以从自身到达。对所有 $i$，$R[i,i]=1$，这由我们的算法保证。\n-   **对称性**：如果顶点 $j$ 可以从 $i$ 到达，那么 $i$ 也可以从 $j$ 到达。由于无向图的初始邻接矩阵 $A$ 是对称的，其在逻辑半环上的所有幂 $A^p$ 也都是对称的，因此 $R$ 是对称的。所以，$R[i,j] = R[j,i]$。\n-   **传递性**：如果 $j$ 可从 $i$ 到达，且 $k$ 可从 $j$ 到达，则 $k$ 可从 $i$ 到达。这由我们算法计算的传递闭包的定义所保证。\n\n等价关系将其基础集合划分为不相交的等价类。对于顶点集 $V$ 上的可达性关系，这些等价类恰好是图的连通分量。顶点 $i$ 的等价类是所有与 $i$ 相互可达的顶点 $j$ 的集合，即 $\\{j \\in V \\mid R[i,j]=1\\}$。\n\n要找到所有连通分量，我们可以遍历所有顶点，并为每个尚未分配到分量的顶点确定其等价类。以下算法正确地划分顶点集 $\\{0, 1, \\dots, n-1\\}$：\n1.  初始化一个大小为 $n$ 的布尔数组 `visited`，所有元素均为 `false`。\n2.  初始化一个空列表 `components`。\n3.  遍历 $i$ 从 $0$ 到 $n-1$：\n    a.  如果 `visited[i]` 是 `false`，这意味着我们发现了一个属于新的、未被发现的分量的顶点。这个顶点 $i$ 将是该分量中最小的索引。\n    b.  创建一个新的空列表 `current_component`。\n    c.  包含 $i$ 的分量是所有可从 $i$ 到达的顶点 $j$ 的集合。我们通过检查闭包矩阵 $R$ 的第 $i$ 行来找到这些顶点。遍历 $j$ 从 $0$ 到 $n-1$。\n    d.  如果 $R[i,j] = 1$，将 $j$ 添加到 `current_component`，并通过设置 `visited[j]` 为 `true` 将其标记为已访问。\n    e.  检查完所有 $j$ 后，`current_component` 包含了新分量的所有顶点，并按递增顺序排序（因为 $j$ 是从 $0$ 到 $n-1$ 遍历的）。将 `current_component` 添加到 `components` 列表中。\n4.  最终的 `components` 列表包含了所有连通分量。该列表本身是按每个分量中最小顶点索引排序的，因为我们是通过从 $0$ 到 $n-1$ 遍历 $i$ 来发现它们的。\n\n这个由两部分组成的程序正确地推导并应用了一个基于矩阵的算法，以按要求找到连通分量。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem for a fixed test suite of adjacency matrices.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        np.array([\n            [0, 1, 0, 0, 0, 0],\n            [1, 0, 1, 0, 0, 0],\n            [0, 1, 0, 0, 0, 0],\n            [0, 0, 0, 0, 1, 0],\n            [0, 0, 0, 1, 0, 0],\n            [0, 0, 0, 0, 0, 0]\n        ], dtype=int),\n        np.array([\n            [0, 1, 1, 1],\n            [1, 0, 1, 1],\n            [1, 1, 0, 1],\n            [1, 1, 1, 0]\n        ], dtype=int),\n        np.array([\n            [0, 0, 0],\n            [0, 0, 0],\n            [0, 0, 0]\n        ], dtype=int),\n        np.array([\n            [0]\n        ], dtype=int),\n        np.array([\n            [0, 1, 0, 0, 0],\n            [1, 0, 1, 0, 0],\n            [0, 1, 0, 0, 0],\n            [0, 0, 0, 1, 0],\n            [0, 0, 0, 0, 0]\n        ], dtype=int)\n    ]\n\n    all_results = []\n    for A in test_cases:\n        all_results.append(compute_components(A))\n    \n    # Format the final output as a single JSON-like string with no spaces.\n    # The str() representation of Python lists is similar to JSON, but with spaces.\n    # We remove the spaces to match the specified output format.\n    final_output = str(all_results).replace(\" \", \"\")\n    print(final_output)\n\ndef compute_components(A: np.ndarray) - list:\n    \"\"\"\n    Computes the connected components of a graph from its adjacency matrix.\n\n    This function first computes the reflexive transitive closure of the graph's\n    reachability relation using the Warshall-Floyd algorithm over the logical\n    semiring. Then, it uses the closure matrix to partition the vertices into\n    connected components.\n\n    Args:\n        A: A numpy ndarray representing the symmetric adjacency matrix of the graph.\n\n    Returns:\n        A list of lists, where each inner list represents a connected component.\n        Components are sorted by their minimum vertex index, and vertices within\n        each component are sorted in increasing order.\n    \"\"\"\n    n = A.shape[0]\n    \n    # Part 1: Compute the reflexive transitive closure matrix R using Warshall-Floyd.\n    # Initialize R with paths of length 0 or 1.\n    # R is initialized to A OR I, where I is the identity matrix.\n    # This represents paths of length 0 (reflexive) and 1 (direct edges).\n    # Numpy's bitwise operators | (OR) and  (AND) work for this logical-semiring algebra.\n    R = A | np.identity(n, dtype=int)\n\n    # Warshall-Floyd algorithm to find all-pairs reachability.\n    # This systematically considers each vertex k as a potential intermediate\n    # vertex in paths between any two vertices i and j.\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                # R[i,j] is true if a path i-j exists, OR\n                # if a path i-k and a path k-j both exist.\n                R[i, j] = R[i, j] | (R[i, k]  R[k, j])\n\n    # Part 2: Partition vertices into connected components using R.\n    # The reachability relation R is an equivalence relation for undirected graphs.\n    # Its equivalence classes are the connected components.\n    visited = [False] * n\n    components = []\n    \n    # Iterate through all vertices to find components.\n    # This approach ensures components are ordered by their smallest vertex index.\n    for i in range(n):\n        if not visited[i]:\n            # Found a new component starting with vertex i.\n            # The component is the set of all vertices reachable from i.\n            # This is given by the i-th row of the closure matrix R.\n            current_component = []\n            for j in range(n):\n                if R[i, j] == 1:\n                    current_component.append(j)\n                    # Mark all vertices in this component as visited.\n                    visited[j] = True\n            \n            # The vertices j are added in increasing order, so the component list is sorted.\n            components.append(current_component)\n            \n    return components\n\n# Ensure the script runs when executed.\nif __name__ == \"__main__\":\n    solve()\n\n```", "id": "3279632"}, {"introduction": "在掌握了 Warshall-Floyd 算法的基础上，本练习将探索一种强大的优化技巧。对于稠密图，我们可以更紧凑地表示邻接矩阵，将每一行编码为一个整数，这使得我们可以用高效的位运算来代替矩阵行上的逻辑运算，从而显著加速传递闭包的计算过程 [@problem_id:3279685]。", "problem": "给定一个有 $n$ 个顶点的有向图，它以稠密形式表示为一个包含 $n$ 个非负整数的数组。索引为 $i$ 处的整数使用位位置编码从顶点 $i$ 到其他顶点的有向边的存在：当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的有向边时，该整数在位置 $j$ 上的最低有效位被设置。该图是 0-索引的。您必须计算可达性的自反传递闭包，定义为关系 $R^{*}$，它包含所有满足“存在一条从顶点 $i$ 到顶点 $j$ 的长度大于或等于 $0$ 的路径”的顶点对 $(i,j)$。该闭包必须使用 Warshall 算法计算，并通过对整数编码的行进行位运算来实现。\n\n使用的基本基础和定义：\n- 一个有向图 $G$ 由一个顶点集合 $V=\\{0,1,\\dots,n-1\\}$ 和一个有向边集合 $E\\subseteq V\\times V$ 定义。\n- $G$ 的邻接矩阵 $A$ 是一个 $n\\times n$ 矩阵，其中当且仅当 $(i,j)\\in E$ 时 $A_{ij}=1$，否则 $A_{ij}=0$。\n- 传递闭包 $R^{+}$ 是所有满足“存在一条从 $i$ 到 $j$ 的长度大于或等于 $1$ 的路径”的有序对 $(i,j)$ 的集合。\n- 自反传递闭包 $R^{*}$ 在 $R^{+}$ 的基础上增加了所有顶点对 $(i,i)$（对于每个 $i\\in V$），对应于长度为 $0$ 的路径。\n- 关系的复合是可结合的，并且布尔半环上的邻接矩阵使用逻辑析取和逻辑合取来表示路径上可达性的并集和复合。\n\n您的程序必须：\n- 将每个测试用例解释为一个包含 $n$ 个整数的数组，这些整数如上所述编码了邻接矩阵的行。\n- 使用在这些整数上实现的位运算的 Warshall 算法计算 $R^{*}$。具体来说，您必须通过迭代地允许中间顶点 $k$ 并通过执行与布尔矩阵运算一致的整数位运算来更新从每个 $i$ 可达的顶点集，从而实现该算法。在执行闭包计算之前，您必须通过将对角线元素 $A_{ii}$ 初始设置为 $1$ 来处理自可达性。\n- 以相同的整数编码行形式生成传递闭包：输出一个包含 $n$ 个整数的数组，其中索引 $i$ 处的整数在第 $j$ 位上被设置，当且仅当顶点 $j$ 可以通过一条长度大于或等于 $0$ 的路径从顶点 $i$ 到达。\n\n测试套件：\n使用以下测试用例集，每个测试用例由整数编码的邻接行指定。每个邻接输入最初不包含自反边；您必须根据需要添加它们来计算 $R^{*}$。\n- 测试用例 $1$（链）：$n=4$，行 $[2,4,8,0]$。这编码了边 $0\\to 1$，$1\\to 2$，$2\\to 3$。\n- 测试用例 $2$（没有自环的近乎完全的稠密图）：$n=5$，行 $[30,29,27,23,15]$。对于每个 $i$，存在一条边 $i\\to j$ 适用于所有 $j\\neq i$。\n- 测试用例 $3$（有向环）：$n=6$，行 $[2,4,8,16,32,1]$。这编码了边 $i\\to (i+1)\\bmod 6$。\n- 测试用例 $4$（混合连通分量）：$n=7$，行 $[2,4,0,16,8,0,0]$。有一个链 $0\\to 1\\to 2$，一个在 $3$ 和 $4$ 之间的双向对，以及孤立顶点 $5$ 和 $6$。\n- 测试用例 $5$（单个顶点）：$n=1$，行 $[0]$。\n- 测试用例 $6$（空图）：$n=0$，行 $[]$。\n\n答案规范：\n- 对于每个测试用例，以具有相同索引约定的整数数组形式输出自反传递闭包。\n- 最终输出格式必须是单行，包含一个由方括号括起来的、按测试用例分隔的结果的逗号分隔列表，其中每个测试用例的结果本身是一个由方括号括起来的、逗号分隔的整数列表，并且没有任何空格。例如，一个有效的格式是 $[[a_{1,1},\\dots,a_{1,n_1}],[a_{2,1},\\dots,a_{2,n_2}],\\dots]$，其中 $a_{t,i}$ 是整数，$n_t$ 是测试用例 $t$ 中的顶点数。\n\n您的任务是实现计算，并为提供的测试套件生成与此确切格式匹配的单行输出。输出中的值必须仅为整数和整数列表，如规范所述。", "solution": "该问题要求计算有向图 $G=(V,E)$ 的自反传递闭包，记作 $R^*$，其中 $V = \\{0, 1, \\dots, n-1\\}$。该图以紧凑的位格式提供，其中一个包含 $n$ 个整数的数组表示邻接矩阵 $A$。索引 $i$ 处的整数编码了 $A$ 的第 $i$ 行，第 $j$ 位对应于条目 $A_{ij}$。我们被要求使用通过位运算实现的 Warshall 算法。\n\n首先，我们将问题形式化。如果存在一条从顶点 $i$ 到顶点 $j$ 的长度为 $0$ 或更长的路径，则自反传递闭包 $R^*$ 包含顶点对 $(i,j)$。任何顶点到其自身都存在一条长度为 $0$ 的路径。因此，$R^*$ 必须包含所有 $i \\in V$ 的所有顶点对 $(i,i)$。问题描述正确地指导我们通过在主计算前确保可达性矩阵的所有对角线元素都为 $1$ 来实现这一点。这等价于从表示关系 $A \\cup I$ 的矩阵开始，其中 $A$ 是邻接关系，$I$ 是单位关系。在我们的位表示中，对于从 $0$ 到 $n-1$ 的每个行索引 $i$，我们必须设置该索引处整数的第 $i$ 位。这通过位或运算完成：$M_i \\leftarrow M_i \\lor (1 \\ll i)$，其中 $M_i$ 是第 $i$ 行的整数，$\\ll$ 表示位左移运算符。让我们将得到的整数数组表示为 $M$。\n\n计算的核心是 Warshall 算法。它通过系统地考虑所有路径的所有可能中间顶点来计算传递闭包。设 $M^{(k)}_{ij}$ 为一个布尔值，表示是否仅使用来自集合 $\\{0, 1, \\dots, k-1\\}$ 的中间顶点，存在一条从顶点 $i$ 到顶点 $j$ 的路径。该算法以 $M^{(0)}$ 作为（自反的）邻接矩阵开始，并从 $k=0$ 迭代到 $n-1$。更新规则由布尔半环上的递推关系给出：\n$$M^{(k)}_{ij} = M^{(k-1)}_{ij} \\lor (M^{(k-1)}_{ik} \\land M^{(k-1)}_{kj})$$\n这表明，如果满足以下任一条件，则存在一条使用不超过 $k-1$ 的中间顶点从 $i$ 到 $j$ 的路径：\n1. 已存在一条使用不超过 $k-2$ 的中间顶点从 $i$ 到 $j$ 的路径。\n2. 存在一条从 $i$ 到 $k$ 的路径和一条从 $k$ 到 $j$ 的路径，两者都使用不超过 $k-2$ 的中间顶点。\n\n实现的关键洞见是，循环可以将中间顶点 $k$ 放在最外层。状态可以就地更新。设被更新的单个矩阵为 $M$。算法如下：\n`for k from 0 to n-1:`\n  `for i from 0 to n-1:`\n    `for j from 0 to n-1:`\n      `M[i,j] := M[i,j] OR (M[i,k] AND M[k,j])`\n\n我们必须将此矩阵公式转换为对我们整数编码的行的位运算。整数 $M_i$ 表示矩阵的整个第 $i$ 行，即 $(M_{i,0}, M_{i,1}, \\dots, M_{i,n-1})$。让我们分析固定行 $i$ 和中间顶点 $k$ 的更新。我们检查谓词 $M_{ik}$，它测试是否存在从 $i$ 到 $k$ 的路径。\n- 如果 $M_{ik}$ 为 $0$（假），则 $(M_{ik} \\land M_{kj})$ 始终为 $0$。更新规则简化为 $M_{ij} \\leftarrow M_{ij}$。因此，第 $i$ 行不发生改变。\n- 如果 $M_{ik}$ 为 $1$（真），则对于所有 $j \\in \\{0, \\dots, n-1\\}$，行 $i$ 的更新规则变为 $M_{ij} \\leftarrow M_{ij} \\lor M_{kj}$。这意味着如果我们能从 $i$ 到达 $k$，那么我们就能从 $i$ 到达任何可以从 $k$ 到达的顶点 $j$。从 $i$ 可达的新顶点集是旧集合与从 $k$ 可达的顶点集的并集。\n\n这个可达性集合的并集直接对应于整数行上的位或运算。对于所有 $j$ 的操作 $M_{ij} \\leftarrow M_{ij} \\lor M_{kj}$ 等价于 $M_i \\leftarrow M_i \\lor M_k$。\n\n因此，Warshall 算法的完整位运算实现如下：\n1. 设 $M$ 为表示图的整数数组。\n2. 对于每个顶点 $i \\in \\{0, \\dots, n-1\\}$，添加一个自环以确保自反性：$M_i \\leftarrow M_i \\lor (1 \\ll i)$。\n3. 对于每个中间顶点 $k \\in \\{0, \\dots, n-1\\}$：\n4.  对于每个起始顶点 $i \\in \\{0, \\dots, n-1\\}$：\n5.   检查是否存在从 $i$ 到 $k$ 的路径。如果 $M_i$ 的第 $k$ 位被设置，则为真。这可以用表达式 $(M_i \\land (1 \\ll k)) \\neq 0$ 来测试。\n6.   如果存在这样的路径，则通过与 $k$ 的可达性取并集来更新 $i$ 的可达性：$M_i \\leftarrow M_i \\lor M_k$。\n\n在这些循环完成后，数组 $M$ 将包含最终自反传递闭包矩阵 $R^*$ 的整数编码行。此过程正确且高效地解决了指定的问题。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the reflexive transitive closure problem for a suite of test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    test_cases = [\n        [2, 4, 8, 0],              # Test case 1: n=4, chain 0-1-2-3\n        [30, 29, 27, 23, 15],     # Test case 2: n=5, almost complete graph\n        [2, 4, 8, 16, 32, 1],     # Test case 3: n=6, cycle 0-1-...-5-0\n        [2, 4, 0, 16, 8, 0, 0],   # Test case 4: n=7, mixed components\n        [0],                       # Test case 5: n=1, single vertex\n        [],                        # Test case 6: n=0, empty graph\n    ]\n\n    results = []\n    for adj_rows in test_cases:\n        n = len(adj_rows)\n        \n        if n == 0:\n            results.append([])\n            continue\n\n        # Use numpy array with a sufficiently large unsigned integer type\n        # to handle bitwise operations for up to 64 vertices.\n        # This also matches the code structure provided in the problem.\n        R = np.array(adj_rows, dtype=np.uint64)\n        \n        # Step 1: Add self-loops to compute the reflexive closure.\n        # This corresponds to initializing the reachability matrix with the\n        # identity matrix OR-ed with the adjacency matrix.\n        for i in range(n):\n            R[i] |= (np.uint64(1)  i)\n            \n        # Step 2: Apply Warshall's algorithm using bitwise operations.\n        # The outer loop must be over the intermediate vertex k.\n        for k in range(n):\n            for i in range(n):\n                # If there is a path from i to k (i.e., k-th bit is set in R[i])\n                if (R[i]  (np.uint64(1)  k)):\n                    # Then i can reach everything that k can reach.\n                    # This is a union of reachability sets, which corresponds to\n                    # a bitwise OR on the integer-encoded rows.\n                    R[i] |= R[k]\n                    \n        results.append(R.tolist())\n\n    # Final print statement in the exact required format.\n    # e.g., [[r1_1,r1_2],[r2_1,r2_2,r2_3],...] with no spaces.\n    inner_results = [f\"[{','.join(map(str, res))}]\" for res in results]\n    final_output = f\"[{','.join(inner_results)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3279685"}, {"introduction": "现实世界中的网络常常随时间动态变化。每当图中添加一条边时，我们是否必须从头重新计算整个传递闭包？这个高级练习将挑战你推导并实现一个增量更新算法。你将发现，添加一条边 $(a,b)$ 是如何创造新路径的，以及如何通过只考虑能到达 $a$ 的节点和 $b$ 能到达的节点来高效地更新闭包矩阵 [@problem_id:3279786]。", "problem": "给定一个有向图，其顶点集为 $\\{0,1,\\dots,n-1\\}$，由一个二进制邻接矩阵 $A \\in \\{0,1\\}^{n \\times n}$ 表示。对于顶点 $i$ 和 $j$，如果存在一条从 $i$ 到 $j$ 的长度至少为 $1$ 的有向路径，我们称 $j$ 是从 $i$ 可达的。$A$ 的传递闭包 $T \\in \\{0,1\\}^{n \\times n}$ 记录了可达性：当且仅当在由 $A$ 定义的图中存在一条从 $i$ 到 $j$ 的长度至少为 $1$ 的有向路径时，$T[i,j]=1$，否则 $T[i,j]=0$。请注意，$T[i,i]=1$ 当且仅当存在一个经过 $i$ 的有向环。\n\n请仅从有向路径和可达性的核心定义出发，推导一个增量算法，用于在图中添加一条有向边 $(a,b)$ 时，将 $T$ 更新为 $T'$。您的推导必须且只能基于以下基础：\n- 有向图的邻接矩阵 $A$ 和传递闭包 $T$ 的定义。\n- 有向路径的定义，即一系列顶点序列，其中每对连续顶点都对应图中的一条边。\n- 关于二元关系的基本命题逻辑（例如，可达性是邻接关系的传递闭包）。\n\n您不得依赖、引用或假设任何已有的关于传递闭包或其更新的特定算法公式；相反，您必须通过逻辑推导，得出因添加一条边而可能变得新可达的顶点对集合。\n\n在推导出算法后，请将其实现为一个程序，对下方的每个测试用例执行以下步骤：\n1. 构建大小为 $n \\times n$ 的初始邻接矩阵 $A$。\n2. 计算初始传递闭包 $T$，该闭包编码了长度至少为 $1$ 的路径。\n3. 在添加单条边 $(a,b)$ 时，应用您的增量更新方法以获得更新后的闭包 $T'$，而不是从头重新计算闭包。\n4. 对每个测试用例，计算新可达有序对的整数数量，其定义为满足 $T[i,j]=0$ 且 $T'[i,j]=1$ 的索引对 $(i,j)$ 的数量。\n\n测试套件。每个测试用例以 $(n,\\ \\text{边列表},\\ (a,b))$ 的形式给出，其中 $n$ 是顶点数，边列表是初始包含的有向边集合，而 $(a,b)$ 是要添加的单条边。所有顶点的编号从 $0$ 到 $n-1$。请严格使用以下五个测试用例：\n- 测试用例 1：$(n=5,\\ \\{(0,1),(1,2),(3,4)\\},\\ (2,3))$。\n- 测试用例 2：$(n=4,\\ \\{(0,1),(1,2),(2,3)\\},\\ (0,3))$。\n- 测试用例 3：$(n=3,\\ \\{(0,1),(1,0),(1,2)\\},\\ (0,1))$。\n- 测试用例 4：$(n=2,\\ \\{(0,1)\\},\\ (1,1))$。\n- 测试用例 5：$(n=3,\\ \\{(0,1),(1,2)\\},\\ (2,0))$。\n\n您的程序必须生成单行输出，其中包含一个用方括号括起来的逗号分隔列表（例如 $[x_1,x_2,x_3,x_4,x_5]$），其中 $x_k$ 是测试用例 $k$ 的新可达有序对的整数数量。\n\n所有输出均为无单位整数。不需要外部输入；程序必须内嵌上述测试套件并打印所需的单行输出。", "solution": "该问题要求推导一个增量更新算法，用于在有向图中添加单条边时更新其传递闭包。推导过程必须基于第一性原理。随后，需要实现该算法并将其应用于一个特定的测试套件。\n\n对问题陈述的初步验证确认，其在图论方面具有科学依据，问题定义明确、客观且内部一致。未发现任何缺陷。\n\n**增量更新算法的推导**\n\n设该有向图为 $G=(V, E)$，其中 $V = \\{0, 1, \\dots, n-1\\}$ 是顶点集，$E$ 是边集。该图由其邻接矩阵 $A \\in \\{0, 1\\}^{n \\times n}$ 表示，其中若 $(i,j) \\in E$，则 $A[i,j] = 1$，否则 $A[i,j] = 0$。\n\n$G$ 的传递闭包由矩阵 $T \\in \\{0, 1\\}^{n \\times n}$ 表示。根据定义，$T[i,j] = 1$ 当且仅当存在一条从顶点 $i$ 到顶点 $j$ 的长度至少为 $1$ 的有向路径。否则，$T[i,j] = 0$。\n\n我们要向图 $G$ 中添加一条有向边 $(a, b)$，得到一个新图 $G' = (V, E \\cup \\{(a,b)\\})$。我们需要通过更新原始闭包 $T$ 来找到 $G'$ 的传递闭包 $T'$，而不是从头重新计算。核心任务是识别出那些变得新可达的有序对 $(i,j)$。如果 $T[i,j]=0$ 且 $T'[i,j]=1$，则称序对 $(i,j)$ 是新可达的。\n\n根据定义，$G$ 中的任何路径也是 $G'$ 中的路径。因此，如果 $T[i,j] = 1$，那么必然有 $T'[i,j] = 1$。新的可达性连接（即 $T'[i,j]=1$ 但 $T[i,j]=0$ 的情况）只能源于 $G'$ 中利用了新增边 $(a,b)$ 的路径。\n\n考虑一条在 $G'$ 中从顶点 $i$ 到顶点 $j$ 且利用了边 $(a,b)$ 的路径。这样的路径必须是三部分的拼接：\n1. 从顶点 $i$ 到顶点 $a$ 的一条路径。\n2. 新增的边 $(a,b)$。\n3. 从顶点 $b$ 到顶点 $j$ 的一条路径。\n\n我们来分析到达 $a$ 和从 $b$ 出发的路径。这些子路径必须存在于原始图 $G$ 中。\n从一个顶点到其自身的“路径”长度可以为 $0$。为了正式处理 $i=a$ 或 $j=b$ 的情况，使用自反传递闭包（记作 $T^*$）会很方便。矩阵 $T^*$ 定义为：如果存在一条从 $i$ 到 $j$ 长度为 $0$ 或更长的路径，则 $T^*[i,j] = 1$。它可以通过将 $T$ 的对角线元素设为 $1$ 来计算，因为从任何顶点到其自身都存在一条长度为 $0$ 的路径。在矩阵代数中，$T^* = T \\lor I$，其中 $I$ 是 $n \\times n$ 的单位矩阵，$\\lor$ 表示逐元素的逻辑或运算。\n\n因此，在 $G'$ 中存在一条使用边 $(a,b)$ 的路径 $i \\to j$ 的条件可以表述为：\n- 在 $G$ 中存在一条从 $i$ 到 $a$ 的长度 $\\ge 0$ 的路径。这等价于逻辑条件 $T^*[i,a]=1$。\n- 并且，在 $G$ 中存在一条从 $b$ 到 $j$ 的长度 $\\ge 0$ 的路径。这等价于逻辑条件 $T^*[b,j]=1$。\n\n综合这些，一条通过新边 $(a,b)$ 从 $i$ 到 $j$ 的路径存在的充要条件是 $(T^*[i,a] \\land T^*[b,j]) = 1$，其中 $\\land$ 是逻辑与运算。\n\n这个表达式捕捉了由新边创建的所有可达性。新图 $G'$ 的完整传递闭包 $T'$可以表示为旧可达性与这个新可达性来源的并集：\n$$T'[i,j] = T[i,j] \\lor (T^*[i,a] \\land T^*[b,j])$$\n\n我们感兴趣的是*新*可达对的数量。如果一个序对 $(i,j)$ 在旧闭包 $T$ 中的条目为 $0$，而在新闭包 $T'$ 中的条目为 $1$，则称其为新可达的。根据 $T'$ 的方程，这种情况恰好在以下条件下发生：\n$$T[i,j] = 0 \\quad \\text{且} \\quad (T^*[i,a] \\land T^*[b,j]) = 1$$\n\n这个推导为我们提供了一个直接的算法来寻找新可达的顶点对：\n1.  从初始的传递闭包矩阵 $T$ 开始。\n2.  计算自反传递闭包 $T^* = T \\lor I$。\n3.  识别出在 $G$ 中所有能到达 $a$ 的顶点集合 $P_a$（包括 $a$ 本身）。该集合为 $P_a = \\{i \\in V \\mid T^*[i,a]=1\\}$。这对应于 $T^*$ 第 $a$ 列中非零条目的索引。\n4.  识别出在 $G$ 中所有从 $b$ 可达的顶点集合 $S_b$（包括 $b$ 本身）。该集合为 $S_b = \\{j \\in V \\mid T^*[b,j]=1\\}$。这对应于 $T^*$ 第 $b$ 行中非零条目的索引。\n5.  所有潜在新路径的集合是笛卡尔积 $P_a \\times S_b$。\n6.  为了计算严格新增路径的数量，遍历所有序对 $(i,j) \\in P_a \\times S_b$，当且仅当 $T[i,j]=0$ 时，将计数器加一。\n\n该过程通过仅考虑由单条边 $(a,b)$ 引入的结构变化来正确计算新可达对的数量，符合要求。对于从邻接矩阵 $A$ 初始计算 $T$，像 Floyd-Warshall 算法这样的标准算法是合适且高效的。Floyd-Warshall 算法通过迭代地将每个顶点视为所有路径中的潜在中间节点来计算传递闭包。\n\n**应用于测试用例**\n\n对于每个测试用例 $(n, \\text{边列表}, (a,b))$：\n1.  根据给定的边列表，构建一个 $n \\times n$ 的邻接矩阵 $A$。\n2.  使用 Floyd-Warshall 算法从 $A$ 计算初始传递闭包 $T$。\n3.  通过对 $T$ 和单位矩阵 $I$ 进行逻辑或运算，获得自反闭包 $T^*$。\n4.  确定集合 $P_a = \\{i \\mid T^*[i,a]=1\\}$ 和 $S_b = \\{j \\mid T^*[b,j]=1\\}$。\n5.  统计满足 $i \\in P_a$，$j \\in S_b$ 且 $T[i,j]=0$ 的序对 $(i, j)$ 的数量。这个计数就是该测试用例的最终结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the incremental transitive closure problem for a given test suite.\n    \"\"\"\n    \n    # Test suite as defined in the problem statement.\n    # Each case is (n, edge_list, (a, b))\n    test_cases = [\n        (5, [(0, 1), (1, 2), (3, 4)], (2, 3)),\n        (4, [(0, 1), (1, 2), (2, 3)], (0, 3)),\n        (3, [(0, 1), (1, 0), (1, 2)], (0, 1)),\n        (2, [(0, 1)], (1, 1)),\n        (3, [(0, 1), (1, 2)], (2, 0)),\n    ]\n\n    results = []\n\n    for n, edges, new_edge in test_cases:\n        a, b = new_edge\n\n        # Step 1: Construct the initial adjacency matrix A\n        A = np.zeros((n, n), dtype=int)\n        for u, v in edges:\n            A[u, v] = 1\n\n        # Step 2: Compute the initial transitive closure T\n        # We use the Floyd-Warshall algorithm for this standard computation.\n        T = np.copy(A)\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    T[i, j] = T[i, j] or (T[i, k] and T[k, j])\n\n        # Step 3: Apply the incremental update logic to find new paths.\n        \n        # First, compute the reflexive-transitive closure T_star.\n        # T_star[i, j] = 1 if there's a path of length = 0.\n        # This is equivalent to T OR'd with the identity matrix.\n        I = np.identity(n, dtype=int)\n        T_star = np.logical_or(T, I).astype(int)\n\n        # According to the derived algorithm, a new path from i to j is formed\n        # if and only if i can reach a (or i is a) and b can reach j (or b is j),\n        # and there was no pre-existing path from i to j.\n\n        # Find all vertices that can reach a (predecessors in closure graph).\n        predecessors_of_a = np.where(T_star[:, a] == 1)[0]\n        \n        # Find all vertices reachable from b (successors in closure graph).\n        successors_of_b = np.where(T_star[b, :] == 1)[0]\n\n        # Step 4: Compute the integer count of newly reachable ordered pairs.\n        newly_reachable_count = 0\n        for i in predecessors_of_a:\n            for j in successors_of_b:\n                # Check if this path candidate did NOT exist before.\n                if T[i, j] == 0:\n                    newly_reachable_count += 1\n        \n        results.append(newly_reachable_count)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\nsolve()\n```", "id": "3279786"}]}