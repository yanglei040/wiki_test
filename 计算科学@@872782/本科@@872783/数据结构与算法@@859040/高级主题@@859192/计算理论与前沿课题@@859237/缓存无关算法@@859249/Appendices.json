{"hands_on_practices": [{"introduction": "矩阵转置是计算中最基本的操作之一，但其实现方式对性能有着深远的影响。本练习 [@problem_id:3208160] 旨在揭示内存访问模式的重要性。通过对比分析一个简单的“朴素”转置算法和一个缓存无关的递归算法，你将亲身体会到，即使是同样的功能，不同的算法结构如何导致截然不同的缓存效率，从而深入理解缓存无关设计的第一原则：通过分治策略在所有内存层级上优化数据局部性。", "problem": "给定两种算法，用于将一个以行主序存储的 $N \\times N$ 矩阵 $A$ 转置到一个独立的矩阵 $B$（也以行主序存储）中，其中每个元素占用一个单位的存储空间。内存由理想缓存模型建模：一个大小为 $M$ 个元素、块大小为 $B$ 个元素、采用最优替换策略的全相联缓存。每次缓存未命中会从主存和缓存之间传输恰好一个包含 $B$ 个连续元素的块。计算每种算法产生的块传输（缓存未命中）次数。假设满足高缓存条件 $M = \\Omega(B^2)$，并且 $N$ 渐进地大于 $M/B$（即，存在一个常数 $\\alpha > 0$，使得对于所有足够大的 $N$，都有 $N \\ge \\alpha \\cdot M/B$）。\n\n算法描述：\n- 朴素转置：\n  对于 $i$ 从 $0$ 到 $N - 1$：\n    对于 $j$ 从 $0$ 到 $N - 1$：\n      设置 $B[j][i] \\leftarrow A[i][j]$。\n- 缓存无关转置：\n  一种分治算法，它通过将矩阵划分为子矩阵来递归地将问题分解为子问题，并在这些子矩阵上进行递归，直到达到常数大小的基本情况，其间不依赖任何与 $M$ 或 $B$ 相关的参数。\n\n从第一性原理出发，对两种算法的访问模式进行建模，并选择能够正确描述在上述假设下，它们的块传输渐进数量（忽略常数因子和低阶项）作为 $N$、$B$ 和 $M$ 的函数的选项。\n\nA. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法产生 $\\Theta(N^2 / B)$ 次块传输。\n\nB. 朴素算法和缓存无关算法都产生 $\\Theta(N^2 / B)$ 次块传输。\n\nC. 朴素算法在读取 $A$ 时产生 $\\Theta(N^2 / B)$ 次块传输，在写入 $B$ 时产生 $\\Theta(N^2 / B)$ 次块传输，总计 $\\Theta(N^2 / B)$ 次；而缓存无关算法产生 $\\Theta(N^2 / (B \\sqrt{M}))$ 次块传输。\n\nD. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法由于递归开销产生 $\\Theta((N^2 \\log N) / B)$ 次块传输。", "solution": "用户需要对两种矩阵转置算法的缓存复杂度进行详细分析。\n\n### 问题验证\n\n**第 1 步：提取已知条件**\n- **矩阵**：一个 $N \\times N$ 的矩阵 $A$ 被转置成一个 $N \\times N$ 的矩阵 $B$。\n- **数据布局**：$A$ 和 $B$ 都以行主序存储。\n- **元素大小**：每个元素占用一个单位的存储空间。\n- **缓存模型**：理想缓存模型，具有以下参数：\n    - 全相联。\n    - 缓存大小：$M$ 个元素。\n    - 块大小：$B$ 个元素。\n    - 替换策略：最优。\n- **块传输**：一次缓存未命中会传输一个包含 $B$ 个连续元素的块。\n- **目标**：计算两种算法的块传输（缓存未命中）次数。\n- **假设**：\n    1.  高缓存条件：$M = \\Omega(B^2)$，这意味着存在一个常数 $c > 0$，使得对于足够大的 $B$，有 $M \\ge cB^2$。\n    2.  大矩阵条件：$N$ 渐进地大于 $M/B$。具体来说，存在一个常数 $\\alpha > 0$，使得对于所有足够大的 $N$，有 $N \\ge \\alpha \\cdot M/B$。\n- **算法 1（朴素转置）**：\n  ```\n  For i from 0 to N-1:\n    For j from 0 to N-1:\n      Set B[j][i] - A[i][j].\n  ```\n- **算法 2（缓存无关转置）**：\n  - 一种分治算法。\n  - 递归地将矩阵划分为子矩阵。\n  - 递归持续进行，直到达到常数大小的基本情况。\n  - 算法的结构不依赖于缓存参数 $M$ 或 $B$。\n\n**第 2 步：使用提取的已知条件进行验证**\n这个问题陈述是分析缓存感知和缓存无关算法的一个标准练习，这是计算机科学和高性能计算中的一个基本主题。\n- **科学依据**：该问题基于成熟的理想缓存模型、行主序内存布局和标准算法范式。这些都是算法分析的核心概念。不存在伪科学。\n- **适定性**：问题定义清晰。它要求计算块传输的渐进数量，这是一个在给定模型和假设下具体、可解的量。所提供的假设（高缓存、大 $N$）是这类分析的标准假设，确保问题聚焦于渐进上有意义的情况。\n- **客观性**：语言精确、数学化，并且没有主观性。\n- **不完整或矛盾的设置**：问题是自洽的，为分析提供了所有必要的定义和约束。没有矛盾之处。\n- **不切实际或不可行**：虽然理想缓存模型是对真实硬件的简化，但它是一个理论上合理且广泛用于算法分析的模型。该问题是一个理论练习，因此物理现实性不是主要关注点。\n- **不适定或结构不良**：问题结构良好。算法的描述足以对其内存访问模式进行渐进分析。\n\n**第 3 步：结论与行动**\n问题陈述是 **有效的**。可以进行分析。\n\n### 解题推导\n\n目标是确定每种算法的缓存未命中次数的渐进数量。当请求的内存地址不在缓存中时，就会发生缓存未命中，这需要从主存传输一个大小为 $B$ 个元素的块。\n\n**朴素转置算法分析**\n\n该算法由嵌套循环结构给出：\n```\nFor i from 0 to N-1:\n  For j from 0 to N-1:\n    B[j][i] - A[i][j]\n```\n我们分别分析从矩阵 $A$ 读取和向矩阵 $B$ 写入的内存访问。两个矩阵都以行主序存储，这意味着对于一个 $N \\times N$ 矩阵 $X$，元素 $X[r][c]$ 位于距矩阵基地址 $r \\times N + c$ 的内存偏移处。\n\n1.  **从矩阵 $A$ 读取**：\n    算法按 $A[0][0], A[0][1], \\dots, A[0][N-1]$，然后 $A[1][0], \\dots, A[1][N-1]$，依此类推的顺序访问 $A$ 的元素。对于任何固定的行 $i$，关于 $j$ 的内层循环会扫描元素 $A[i][0], \\dots, A[i][N-1]$。由于是行主序布局，这些元素在内存中是连续存储的。这是一种顺序扫描。\n    - 每次缓存未命中会将一个包含 $B$ 个元素的块带入缓存。\n    - 要读取一整行 $N$ 个元素，必须传输 $\\lceil N/B \\rceil$ 个块。\n    - 由于对 $N$ 行中的每一行都执行此操作，读取整个 $A$ 的总未命中次数为 $N \\times \\lceil N/B \\rceil$。\n    - 渐进地，这是 $\\Theta(N^2/B)$。这种访问模式表现出极好的空间局部性。\n\n2.  **向矩阵 $B$ 写入**：\n    算法按 $B[0][0], B[1][0], \\dots, B[N-1][0]$，然后 $B[0][1], \\dots, B[N-1][1]$，依此类推的顺序写入 $B$ 的元素。对于任何固定的外层循环索引 $i$，关于 $j$ 的内层循环会写入元素 $B[0][i], B[1][i], \\dots, B[N-1][i]$。这些是矩阵 $B$ 的第 $i$ 列的元素。\n    - 在行主序中，$B[j][i]$ 的内存地址是 `base_B` $+ j \\times N + i$。下一个写入的元素 $B[j+1][i]$ 的地址是 `base_B` $+ (j+1) \\times N + i$。\n    - 连续内存访问之间的步幅是 $N$ 个元素。\n    - 问题假设对于某个 $\\alpha  0$，有 $N \\ge \\alpha \\cdot M/B$。这意味着 $N$ 很大。在这种分析相关的典型场景中，单列在内存中的大小（整个列的地址空间为 $N \\times N$，尽管只有 $N$ 个元素）远远超过缓存大小 $M$。\n    - 当步幅 $N$ 大于块大小 $B$ 时，每次访问 `B[j][i]` 和 `B[j+1][i]` 都会落入不同的缓存块。\n    - 此外，如果在遍历一列期间接触到的不同块的总数超过了缓存的容量 ($M/B$)，那么块在被重用之前就会被替换出去。内层循环中（对于固定的 $i$）的第 $j$ 次访问会接触一个块。第 $(j+1)$ 次访问会接触一个相距 $N$ 字节的块。到我们访问足够多的元素以至于可能重用某个块时（反正这种访问模式下不会发生），我们至少已经带入了 $M/B$ 个其他块，导致了替换。\n    - 因此，对一列的 $N$ 次写入中的每一次都会导致一次缓存未命中。由于外层循环运行 $N$ 次，写入 $B$ 的总未命中次数是 $N \\times N = N^2$。\n    - 渐进地，这是 $\\Theta(N^2)$。这种访问模式表现出极差的空间局部性。\n\n**朴素转置的总未命中次数**：\n总块传输次数是读取 $A$ 和写入 $B$ 的未命中次数之和：\n$$ \\text{总未命中次数} = \\Theta(N^2/B) + \\Theta(N^2) = \\Theta(N^2) $$\n写入 $B$ 的成本主导了整体复杂度。\n\n**缓存无关转置算法分析**\n\n该算法使用分治策略。一个 $N \\times N$ 矩阵被划分为四个 $(N/2) \\times (N/2)$ 的子矩阵。然后通过递归地转置这些子矩阵来执行转置操作。\n对于一个 $n \\times n$ 子问题，其缓存未命中次数 $Q(n)$ 的递推关系如下：\n- 如果子问题很大，无法放入缓存，则将问题分解。转置一个 $n \\times n$ 的矩阵涉及对 $(n/2) \\times (n/2)$ 的子矩阵进行四次递归调用。因此，$Q(n) = 4Q(n/2)$。\n- 如果子问题足够小，可以放入缓存，递归实际上就停止了，该子问题可以用最优的内存传输次数来解决。\n\n我们来确定基本情况的大小。一个关于 $n \\times n$ 子矩阵的递归子问题需要访问 $A$ 的一个 $n \\times n$ 部分和 $B$ 的一个 $n \\times n$ 部分。这些子矩阵不是连续的内存块。一个 $n\\times n$ 的子矩阵由 $n$ 个独立的行段组成，每个行段的长度为 $n$。\n- 一个这样的 $n \\times n$ 子矩阵所占用的块数大约为 $n \\times \\lceil n/B \\rceil$。对于 $nB$，这是 $\\Theta(n^2/B)$。对于 $n \\le B$，这是 $\\Theta(n)$。\n- 递归的基本情况发生在子问题足够小，以至于其组成部分（来自 $A$ 和 $B$）可以同时放入缓存中。这使得小的转置操作能够以最大的数据重用率执行。\n- 让我们找出能使一个来自 $A$ 的 $n \\times n$ 子问题和一个来自 $B$ 的 $n \\times n$ 子问题都能放入缓存的最大边长 $n$。所需的总块数大约是 $2 \\times (n \\cdot \\lceil n/B \\rceil)$。我们要求这个值小于缓存容量 $M/B$。\n- 使用高缓存假设 ($M = \\Omega(B^2)$)，已知当子问题的数据足迹与缓存大小 $M$ 处于同一数量级时，会发生转换。数据足迹大约是 $2n^2$ 个元素。因此，我们设 $c \\cdot n^2 \\approx M$ (对于某个常数 $c$)，这给出 $n \\approx \\sqrt{M}$。我们用 $n_0 = \\Theta(\\sqrt{M})$ 表示这个交叉大小。\n- 对于大小为 $n \\le n_0$ 的子问题，它可以很好地放入缓存中。一次性加载它所需的缓存未命中次数是它所占用的块数，即 $\\Theta(n^2/B)$。所以，基本情况的成本是 $Q(n_0) = \\Theta(n_0^2/B)$。\n\n我们现在可以求解原始 $N \\times N$ 问题的总未命中次数的递推关系。递归进行 $k$ 层，直到子问题大小 $N/2^k$ 与 $n_0$ 处于同一数量级。\n$$ \\frac{N}{2^k} \\approx n_0 \\implies 2^k \\approx \\frac{N}{n_0} \\implies k \\approx \\log_2\\left(\\frac{N}{n_0}\\right) $$\n未命中次数为 $Q(N) = 4^k Q(N/2^k) = 4^k Q(n_0)$。\n代入 $4^k = (2^k)^2 \\approx (N/n_0)^2$ 和 $Q(n_0)$ 的表达式：\n$$ Q(N) \\approx \\left(\\frac{N}{n_0}\\right)^2 \\cdot \\Theta\\left(\\frac{n_0^2}{B}\\right) = \\frac{N^2}{n_0^2} \\cdot \\Theta\\left(\\frac{n_0^2}{B}\\right) = \\Theta\\left(\\frac{N^2}{B}\\right) $$\n缓存无关算法实现了最优的内存传输次数，相当于简单地线性扫描矩阵。它能自动适应缓存大小，而无需显式地知道它。\n\n**结果摘要**：\n- 朴素转置块传输次数：$\\Theta(N^2)$\n- 缓存无关转置块传输次数：$\\Theta(N^2/B)$\n\n### 逐项分析选项\n\n**A. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法产生 $\\Theta(N^2 / B)$ 次块传输。**\n此选项与我们为两种算法推导出的结果相匹配。朴素算法的性能受限于跨步写入，导致 $\\Theta(N^2)$ 次未命中。缓存无关算法的递归结构确保了在存储器层次结构的各个层次上都有良好的缓存局部性，从而实现了最优的 $\\Theta(N^2/B)$ 次未命中。\n**结论：正确**\n\n**B. 朴素算法和缓存无关算法都产生 $\\Theta(N^2 / B)$ 次块传输。**\n这是不正确的。虽然它正确地陈述了缓存无关算法的复杂度，但它错误地声称朴素算法也能达到这种性能。如分析所示，由于向目标矩阵写入时的内存访问模式，朴素算法的效率要低得多。\n**结论：不正确**\n\n**C. 朴素算法在读取 $A$ 时产生 $\\Theta(N^2 / B)$ 次块传输，在写入 $B$ 时产生 $\\Theta(N^2 / B)$ 次块传输，总计 $\\Theta(N^2 / B)$ 次；而缓存无关算法产生 $\\Theta(N^2 / (B \\sqrt{M}))$ 次块传输。**\n这个选项因几个原因而不正确。\n- 对于朴素算法，它正确地说明了读取成本，但错误地将写入成本表述为 $\\Theta(N^2/B)$。写入成本是 $\\Theta(N^2)$。因此总成本是 $\\Theta(N^2)$，而不是 $\\Theta(N^2/B)$。\n- 对于缓存无关算法，它给出的复杂度是 $\\Theta(N^2 / (B \\sqrt{M}))$。这是众所周知的缓存无关矩阵*乘法*的复杂度，而不是转置。如前所推导，转置的复杂度是 $\\Theta(N^2/B)$。\n**结论：不正确**\n\n**D. 朴素算法产生 $\\Theta(N^2)$ 次块传输，而缓存无关算法由于递归开销产生 $\\Theta((N^2 \\log N) / B)$ 次块传输。**\n这个选项正确地陈述了朴素算法的复杂度。然而，它错误地陈述了缓存无关算法的复杂度。对于这个问题，递归结构不会在缓存未命中复杂度中引入对数因子。分析表明，工作量集中在递归树的叶子节点上（即能放入缓存的基本情况），将这些加总并不会产生 $\\log N$ 项。正确的复杂度是 $\\Theta(N^2/B)$。\n**结论：不正确**", "answer": "$$\\boxed{A}$$", "id": "3208160"}, {"introduction": "在掌握了缓存无关设计的基本思想后，我们进一步探索如何对更复杂的递归算法进行性能分析。中位数查找是一个经典的算法问题，而“中位数的中位数”策略是其确定性线性时间解法。此练习 [@problem_id:3220337] 让你专注于分析该算法在外部存储模型下的I/O成本，而不是传统的CPU时间复杂度。你将学习如何为递归过程建立并求解I/O代价的递推关系式，这是评估缓存无关算法效率的一项关键技能，并最终证明该算法如何达到最优的I/O效率。", "problem": "给定一个包含 $N$ 个不同键的数组，这些键连续存储在主内存中。内存模型为两级，包含一个大小为 $M$ 的缓存和一个磁盘，数据以大小为 $B$ 的块进行移动。\n\n考虑理想缓存下的缓存无关模型，并满足高缓存假设 $M \\geq B^{2}$。在该模型中，算法不知道 $M$ 或 $B$ 的值，但其性能通过磁盘与缓存之间的输入/输出 (I/O) 块传输次数进行分析。对大小为 $x$ 的数组进行一次顺序扫描会产生恰好 $x/B$ 次块传输；读取和写入操作被同等看待。\n\n设计一个缓存无关的选择算法，返回 $N$ 个键的中位数。请使用以下基本事实和约束：\n\n- 算法必须是基于比较和缓存无关的，将其数据访问模式组织成连续的子数组，而无需针对 $M$ 或 $B$ 进行调优。\n- 对于主元选择，使用“中位数的中位数”策略，将键分为 5 个一组：形成每 5 个键的中位数，递归地选择这些中位数的中位数，并将其用作主元。\n- 在分组大小为 5 的中位数的中位数算法中，假设经过充分验证的最坏情况收缩特性成立：至少有 $3N/10$ 的键严格小于主元，并且至少有 $3N/10$ 的键严格大于主元。因此，包含中位数的递归子问题的规模最多为 $7N/10$。\n- 在每个递归层级，假设缓存无关的、连续的、顺序的扫描会产生以下具体的 I/O 成本：\n  1. 一次扫描读取 $N$ 个键并计算 5 个一组的中位数（$N/B$ 次传输）。\n  2. 一次扫描将 $N/5$ 个中位数写入一个单独的连续缓冲区（$(N/5)/B$ 次传输）。\n  3. 两次扫描围绕选定的主元对原始的 $N$ 个键进行划分（总计 $2N/B$ 次传输）。\n- 对 $N/5$ 个中位数和最多 $7N/10$ 大小的划分区的递归选择都遵循相同的方案，并根据相同的假设产生 I/O。\n\n仅从这些事实以及外存 I/O 模型和缓存无关设计的基本原理出发，推导该算法执行的总块传输次数 $T(N)$ 的一个关于 $N$ 和 $B$ 的闭式上界。您的推导必须明确建立并求解相应的递推关系，不得使用快捷公式。简要讨论为什么朴素的递归模式在缓存无关设置下可能无法实现相同的界限（例如，对两个划分区都进行递归或导致非顺序访问），但您最终的数值界限必须反映上述算法。将您的最终界限表示为关于 $N$ 和 $B$ 的单个解析表达式。无需取整。", "solution": "本题要求推导一个缓存无关中位数选择算法在包含 $N$ 个键的数组上执行的总块传输次数的闭式上界，记为 $T(N)$。该算法使用分组大小为 5 的中位数的中位数方法。分析是在外存模型中进行的，该模型具有大小为 $M$ 的缓存和大小为 $B$ 的块，并满足高缓存假设 $M \\geq B^2$。\n\n首先，我们建立 $T(N)$ 的递推关系。该算法以递归方式进行。在每一步中，对于一个大小为 $N$ 的问题，执行以下操作：\n\n1.  **主元选择**：\n    a. 扫描大小为 $N$ 的输入数组，形成 $\\lceil N/5 \\rceil$ 个 5 键分组。计算每个分组的中位数。这需要对 $N$ 个键进行一次顺序扫描。此次扫描的 I/O 传输次数为 $N/B$。\n    b. 将 $\\lceil N/5 \\rceil$ 个中位数收集到一个新的连续缓冲区中。为了简化对大 $N$ 的分析，我们将 $\\lceil N/5 \\rceil$ 近似为 $N/5$。将这些中位数写入新缓冲区构成对这 $N/5$ 个中位数的一次顺序扫描，产生 $(N/5)/B$ 次 I/O 传输。\n    c. 算法递归调用自身来寻找这 $N/5$ 个中位数的中位数。设这次递归调用的成本为 $T(N/5)$。得到的键即为当前层级的主元。\n\n2.  **划分**：\n    a. 原始的 $N$ 个键的数组围绕选定的主元进行划分。此过程涉及读取 $N$ 个键，并将它们写入两个独立的输出缓冲区：一个用于存放小于主元的键，另一个用于存放大于主元的键。题目说明这会产生总计 $2N/B$ 次传输，对应于对 $N$ 个元素的一次完整读取扫描和一次完整写入扫描。\n\n3.  **递归子问题**：\n    a. 划分后，算法确定两个划分区中哪一个包含整体中位数。题目指出，由于中位数的中位数保证，后续递归子问题的规模最多为 $7N/10$。然后算法对这个划分区进行递归调用。此步骤的成本最多为 $T(7N/10)$。\n\n综合这些成本，对于大小为 $N$ 的问题，总块传输次数 $T(N)$ 的上界是线性扫描成本和递归调用成本之和。当前层级的线性扫描成本是步骤 $1a$、$1b$ 和 $2a$ 的成本总和：\n$$ \\text{线性扫描成本} = \\frac{N}{B} + \\frac{N/5}{B} + \\frac{2N}{B} = \\left(1 + \\frac{1}{5} + 2\\right)\\frac{N}{B} = \\frac{16}{5}\\frac{N}{B} $$\n因此，$T(N)$ 的递推关系为：\n$$ T(N) \\le T\\left(\\frac{N}{5}\\right) + T\\left(\\frac{7N}{10}\\right) + \\frac{16}{5}\\frac{N}{B} $$\n该递推的基准情形发生在问题规模 $N$ 小到可以容纳在常数个内存块内时，即 $N \\le B$。在这种情况下，I/O 次数是常数，即 $T(N) = O(1)$。我们寻求的是对于大 $N$ 的渐近上界。\n\n我们可以通过观察子问题的规模分数之和为 $\\frac{1}{5} + \\frac{7}{10} = \\frac{2}{10} + \\frac{7}{10} = \\frac{9}{10}  1$ 来求解这个线性递推关系。这表明在每个递归层级完成的工作量呈几何级数递减，总工作量由顶层的工作量主导。总体复杂度应与扫描成本呈线性关系，即 $T(N) = O(N/B)$。\n\n为了找到常数因子，我们可以假设一个形式为 $T(N) \\le k \\frac{N}{B}$ 的解，其中 $k$ 为某个常数，并使用代入法求解 $k$。\n$$ k\\frac{N}{B} \\ge T\\left(\\frac{N}{5}\\right) + T\\left(\\frac{7N}{10}\\right) + \\frac{16}{5}\\frac{N}{B} $$\n假设该界对较小的输入成立：\n$$ k\\frac{N}{B} \\ge k\\frac{N/5}{B} + k\\frac{7N/10}{B} + \\frac{16}{5}\\frac{N}{B} $$\n对于 $N0$ 和 $B0$，我们可以将不等式两边同除以 $N/B$：\n$$ k \\ge k\\left(\\frac{1}{5}\\right) + k\\left(\\frac{7}{10}\\right) + \\frac{16}{5} $$\n$$ k \\ge k\\left(\\frac{2}{10} + \\frac{7}{10}\\right) + \\frac{16}{5} $$\n$$ k \\ge k\\left(\\frac{9}{10}\\right) + \\frac{16}{5} $$\n$$ k - \\frac{9}{10}k \\ge \\frac{16}{5} $$\n$$ \\frac{1}{10}k \\ge \\frac{16}{5} $$\n$$ k \\ge 10 \\cdot \\frac{16}{5} $$\n$$ k \\ge 32 $$\n选择最小的有效整数常数 $k=32$，我们得到上界 $T(N) \\le 32 \\frac{N}{B}$。这表明总 I/O 传输次数与存储数据所需的块数呈线性关系，对于一个必须读取其所有输入的问题来说，这是最优的。\n\n或者，我们可以对递归树所有层级完成的工作求和。总工作量是一个几何级数的和：\n$$ T(N) \\le \\sum_{i=0}^{\\infty} \\left(\\frac{9}{10}\\right)^i \\left(\\frac{16}{5}\\frac{N}{B}\\right) = \\frac{16}{5}\\frac{N}{B} \\sum_{i=0}^{\\infty} \\left(\\frac{9}{10}\\right)^i $$\n这个无穷几何级数的和为 $\\frac{1}{1 - 9/10} = 10$。\n$$ T(N) \\le \\frac{16}{5}\\frac{N}{B} \\cdot 10 = 32\\frac{N}{B} $$\n这证实了我们的结果。\n\n关于朴素递归模式为何可能失败的简要讨论：该算法的 I/O 效率取决于其缓存无关设计，该设计依赖于两个关键原则。首先，分治法创建的子问题最终会变得足够小以适应缓存，而无论缓存大小 $M$ 为何。其次，对大型数据集的所有操作都被构造为顺序扫描。一个朴素的递归算法可能在第二点上失败。例如，如果对 $N/5$ 个中位数和 $7N/10$ 划分区的递归调用要在一个大型数组内的非连续内存位置上操作，内存访问模式将是非顺序的，从而导致大量的缓存未命中和块传输。指定的算法通过将子问题显式写入新的连续缓冲区来避免这种情况，确保每个递归阶段都顺序处理其数据。此外，仅对一个划分区（包含中位数的那个）进行递归至关重要。一个像排序算法那样对两个划分区都进行递归的朴素算法，将导致更高的 I/O 复杂度，即 $O\\left(\\frac{N}{B}\\log_{M/B}\\frac{N}{B}\\right)$，从而无法达到选择问题的最优线性界。", "answer": "$$\n\\boxed{32 \\frac{N}{B}}\n$$", "id": "3220337"}, {"introduction": "前面的练习侧重于分析已有的算法，而本次实践将挑战你从分析者转变为设计者。面对一个新颖的网格动态规划问题——寻找最优瓶颈路径，你需要自行设计一个缓存无关的分治算法。此练习 [@problem_id:3220393] 不仅能巩固你对分治思想的理解，更能展示缓存无关范式的强大通用性，让你学会如何将这些设计原则应用于看似与矩阵代数或排序无关的领域，从而从根本上优化其内存访问效率，实现最优的I/O性能。", "problem": "考虑一个由实值矩阵 $H \\in \\mathbb{R}^{r \\times c}$ 表示的二维栅格场，其总大小为 $N = r c$。从单元格 $(1,1)$ 到单元格 $(i,j)$ 的路径被定义为任何一个始于 $(1,1)$、终于 $(i,j)$，并且每一步只向右或向下移动单位步长的网格位置序列。对于任何路径 $P$，其瓶颈值定义为沿路径遇到的最小高度，即 $\\min\\{H(x,y) : (x,y) \\in P\\}$。对于每个单元格 $(i,j)$，定义最优瓶颈值 $F(i,j)$ 为所有此类路径的瓶颈值中的最大值。\n\n您必须设计一个缓存无关算法（即，不以缓存大小 $M$ 或块大小 $B$ 作为参数的算法），在具有块大小 $B$ 和缓存大小 $M$ 的理想缓存模型上，并满足标准的高缓存假设 $M = \\Omega(B^2)$，计算整个数组 $F$。\n\n您的任务是：\n- 从第一性原理出发，构建一个能计算所有 $(i,j)$ 的 $F$ 值的正确的分治策略，并解释为什么该算法遵循路径依赖结构，且其正确性或效率不依赖于对 $M$ 或 $B$ 的了解。\n- 仅使用理想缓存模型的基本属性和内存传输的渐进分析，估算您的算法执行的内存传输的渐进数量，该数量仅作为 $N$ 和 $B$ 的函数。您的估算必须是一个不包含 $M$ 且忽略常数因子的闭式表达式。\n\n请用一个关于 $N$ 和 $B$ 的单一闭式解析表达式来表示您的最终答案。无需单位，也无需四舍五入。", "solution": "该问题要求设计并分析一个缓存无关算法，用以计算一个 $r \\times c$ 网格中所有单元格的最优瓶颈路径值。\n\n首先，我们为最优瓶颈值 $F(i,j)$ 建立一个形式化的递推关系。从单元格 $(1,1)$ 到单元格 $(i,j)$ 的路径只能来自相邻的单元格 $(i-1,j)$（通过向下移动一步）或 $(i,j-1)$（通过向右移动一步）。设 $P$ 为一条到 $(i,j)$ 的路径，其瓶颈值为 $b(P) = \\min_{(x,y) \\in P} H(x,y)$。最优瓶颈值 $F(i,j)$ 是所有从 $(1,1)$ 到 $(i,j)$ 的有效路径 $P$ 的 $b(P)$ 中的最大值。\n\n如果到 $(i,j)$ 的路径 $P$ 的最后一步来自 $(i-1,j)$，那么 $P$ 由一条到 $(i-1,j)$ 的路径 $P'$ 和单元格 $(i,j)$ 组成。$P$ 的瓶颈值为 $\\min(b(P'), H(i,j))$。为了最大化该值，我们必须选择到 $(i-1,j)$ 的具有最大可能瓶颈值的路径 $P'$，即 $F(i-1,j)$。因此，通过 $(i-1,j)$ 的路径能达到的最佳瓶颈值为 $\\min(F(i-1,j), H(i,j))$。\n\n类似地，如果最后一步来自 $(i,j-1)$，则路径 $P$ 由一条到 $(i,j-1)$ 的路径 $P''$ 和单元格 $(i,j)$ 组成。此类路径的最佳瓶颈值为 $\\min(F(i,j-1), H(i,j))$。\n\n由于到 $(i,j)$ 的路径必须来自 $(i-1,j)$ 或 $(i,j-1)$，因此 $F(i,j)$ 是通过这两种选择可达到的最优瓶颈值的最大值。\n$$F(i,j) = \\max(\\min(F(i-1,j), H(i,j)), \\min(F(i,j-1), H(i,j)))$$\n利用 $\\min$ 对 $\\max$ 的分配律，可以简化为：\n$$F(i,j) = \\min(H(i,j), \\max(F(i-1,j), F(i,j-1)))$$\n该递推的基例是 $F(1,1) = H(1,1)$。对于边界上的单元格，递推会使用网格之外的值，这些值可以定义为 $-\\infty$。这导致当 $i  1$ 时 $F(i,1) = \\min(H(i,1), F(i-1,1))$，当 $j  1$ 时 $F(1,j) = \\min(H(1,j), F(1,j-1))$。\n\n这个递推关系表明可以采用标准的动态规划方法，例如逐行或逐列填充矩阵 $F$。然而，如果数据无法装入缓存，这种迭代方法在内存传输方面可能效率极低，最多可导致 $O(N)$ 次传输，其中 $N=rc$。我们的目标是设计一种缓存无关算法，它无需针对特定的缓存参数 $M$ 和 $B$ 进行调优即可实现更好的性能。\n\n**缓存无关的分治算法**\n\n我们定义一个递归过程，称之为 `Compute_F(subregion)`，它计算网格中一个矩形子区域的 $F$ 值。其关键思想是将问题划分为更小的子问题，并按照尊重数据依赖关系的顺序来解决它们。\n\n对于从行 $i_1$ 到 $i_2$、列 $j_1$ 到 $j_2$ 的矩形区域，算法 `Compute_F` 如下：\n设该区域的维度为 $R = i_2 - i_1 + 1$ 和 $C = j_2 - j_1 + 1$。\n\n1.  **基例：** 如果问题规模很小（例如 $R=1, C=1$），计算是微不足道的，依赖于先前计算好的值。在理论上的缓存无关分析中，我们假设递归会一直进行，直到子问题的数据能装入缓存，此时执行一次迭代式的动态规划扫描。\n2.  **递归步骤：**\n    - 如果 $C \\ge R$（区域的宽度大于或等于其高度）：\n        a. 将区域垂直地划分为两半。令 $j_{mid} = j_1 + \\lfloor C/2 \\rfloor - 1$。\n        b. 在左子区域上递归调用 `Compute_F`：`Compute_F(从 (i_1, j_1) 到 (i_2, j_mid) 的区域)`。\n        c. 在右子区域上递归调用 `Compute_F`：`Compute_F(从 (i_1, j_mid+1) 到 (i_2, j_2) 的区域)`。\n    - 否则（$R  C$，区域的高度大于其宽度）：\n        a. 将区域水平地划分为两半。令 $i_{mid} = i_1 + \\lfloor R/2 \\rfloor - 1$。\n        b. 在上子区域上递归调用 `Compute_F`：`Compute_F(从 (i_1, j_1) 到 (i_mid, j_2) 的区域)`。\n        c. 在下子区域上递归调用 `Compute_F`：`Compute_F(从 (i_mid+1, j_1) 到 (i_2, j_2) 的区域)`。\n\n初始调用是对整个 $r \\times c$ 网格执行 `Compute_F`。\n\n**正确性与缓存无关性**\n\n该算法的正确性取决于递归调用的顺序执行。对于任何单元格 $(i,j)$，其值 $F(i,j)$ 仅依赖于 $(i-1,j)$ 和 $(i,j-1)$ 处的值。\n- 当垂直划分时，左子问题在右子问题开始处理之前被完全解决。右子问题中任何需要左子问题（即边界上）单元格值的单元格，都会发现该值已被计算。右子问题内部的依赖关系通过进一步的递归来处理。\n- 当水平划分时，上子问题在下子问题之前被解决。下子问题中的任何单元格都可以从已完成的上子问题中获得其上方邻居的值 $F(i-1,j)$。\n这种顺序保证了所有依赖关系都得到满足。\n\n该算法是缓存无关的，因为其逻辑不涉及缓存大小 $M$ 或块大小 $B$。递归分解在所有尺度上都有效，能够自然地适应任何层级的内存层次结构。其效率来源于递归会持续进行，直到子问题足够小以至于可以装入缓存，此时便可以高效地解决。\n\n**内存传输的渐进分析**\n\n我们在理想缓存模型上分析内存传输（I/O 操作）的数量。\n设 $I(R,C)$ 是解决一个 $R \\times C$ 子问题所需的内存传输次数。该算法总是划分较长的维度，这倾向于产生接近方形的子问题。\n\n当一个 $k_r \\times k_c$ 子问题的数据能装入大小为 $M$ 的缓存时，递归停止。数据包括 $H$ 和 $F$ 的子矩阵，因此我们需要 $O(k_r k_c) \\le M$。由于划分的“方形化”特性，在递归的基例中，我们将得到 $k_r \\approx k_c \\approx \\sqrt{M}$ 的子问题。\n\n关键部分是基例的成本。当解决一个 $k \\times k$（其中 $k \\approx \\sqrt{M}$）的子问题时，其数据必须被加载到缓存中。高缓存假设 $M = \\Omega(B^2)$ 意味着 $k = \\Omega(B)$。如果矩阵 $H$ 和 $F$ 以标准的行主序布局存储，加载一个 $k \\times k$ 的子矩阵需要访问 $k$ 行。由于每行的长度 $k \\ge B$，每行大约占据 $k/B$ 个内存块。因此，加载一个 $k \\times k$ 子矩阵的成本为 $O(k \\cdot (k/B)) = O(k^2/B)$ 次内存传输。由于 $k^2 \\approx M$，一个基例的成本是 $O(M/B)$。\n\n接下来，我们计算基例的数量。总问题大小为 $N = rc$。递归将此问题划分为大小约为 $M$ 的子问题。因此，基例子问题的数量大约为 $N/M$。\n\n内存传输的总次数是基例数量与每个基例的 I/O 成本的乘积：\n$$ \\text{Total I/O} = (\\text{Number of base cases}) \\times (\\text{I/O per base case}) $$\n$$ \\text{Total I/O} = O\\left(\\frac{N}{M}\\right) \\times O\\left(\\frac{M}{B}\\right) = O\\left(\\frac{N}{B}\\right) $$\n这与简单扫描数据的 I/O 复杂度相同，意味着该算法实现了最优的空间局部性。\n\n问题要求给出一个忽略常数因子的、关于内存传输渐进数量的闭式解析表达式。这对应于大O表达式中的主导项。", "answer": "$$\\boxed{\\frac{N}{B}}$$", "id": "3220393"}]}