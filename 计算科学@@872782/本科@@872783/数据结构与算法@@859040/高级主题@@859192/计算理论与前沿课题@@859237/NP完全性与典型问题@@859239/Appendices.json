{"hands_on_practices": [{"introduction": "顶点覆盖问题（Vertex Cover）是经典的NP完全问题，但其难度在特定结构的图上可能会显著降低。本练习将引导你探索当图的结构被限制为树时，如何利用动态规划设计一个高效的多项式时间算法。通过将问题分解为基于子树的重叠子问题，你将学习如何自底向上地构建出全局最优解，从而深刻理解NP完全问题在特定领域的可解性。[@problem_id:3256361]", "problem": "考虑经典的判定问题 $\\text{VERTEX-COVER}$（顶点覆盖）：给定一个图 $G = (V,E)$ 和一个整数 $k$，判断是否存在一个大小最多为 $k$ 的子集 $S \\subseteq V$，使得 $E$ 中的每条边至少有一个端点在 $S$ 中。在一般图中，此问题是已知的非确定性多项式时间（NP）完全问题。然而，当输入图是一棵树时，该问题展现出的结构使其存在多项式时间的解法。从第一性原理出发，即顶点覆盖、树和最优子结构的定义，推导出一个动态规划（DP）算法。该算法在给定一棵包含 $|V| = n$ 个顶点的树 $T = (V,E)$ 时，能在关于 $n$ 的多项式时间内计算出最小顶点覆盖的大小。具体来说：\n\n1. 形式化描述在树上支持动态规划所需的最优子结构，不要依赖任何预先给出的公式。\n2. 通过论证所有边都被覆盖，并且解是最小的（通过树结构上的局部到全局最优性论证），来证明你的方法的正确性。\n3. 分析算法的时间和空间复杂度，将其表示为 $n$ 的函数。\n\n然后，将你的算法应用于以下树实例 $T$，其顶点集为 $V = \\{1,2,3,4,5,6,7,8,9,10,11,12,13,14\\}$，边集为\n$$\nE = \\{(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(4,8),(4,9),(7,10),(7,11),(9,12),(10,13),(10,14)\\}.\n$$\n以顶点 $1$ 为根，计算 $T$ 的最小顶点覆盖的大小。将你的最终答案表示为单个整数（无单位）。无需四舍五入。", "solution": "题目要求推导并应用一个动态规划算法，来寻找给定树的最小顶点覆盖的大小。一个图 $G=(V,E)$ 的顶点覆盖是一个顶点子集 $S \\subseteq V$，使得对于每条边 $(u,v) \\in E$， $u$ 和 $v$ 中至少有一个在 $S$ 中。最小顶点覆盖是可能尺寸最小的顶点覆盖。该问题对于一般图是 NP 完全的，但对于树则可以在多项式时间内解决。\n\n我们将首先形式化动态规划方法，证明其正确性，分析其复杂度，然后将其应用于所提供的具体树实例。\n\n### 1. 最优子结构与动态规划公式\n\n要在树 $T = (V,E)$ 上应用动态规划，我们首先将其在任意一个顶点（我们记为 $r$）上“生根”。对于给定的实例，我们被指定使用顶点 $1$ 作为根。这就在树上建立了一个父子结构。对于任意节点 $u \\in V$，令 $T_u$ 表示以 $u$ 为根的子树，它包括 $u$ 及其所有后代。\n\n动态规划方法的核心思想是以自底向上的方式（即通过后序遍历）计算每个子树 $T_u$ 的最小顶点覆盖的大小。一个简单的状态 $DP(u)$ 来表示 $T_u$ 的最小顶点覆盖的大小是不够的。决定是否将 $u$ 包含在 $T_u$ 的覆盖中，会对其父节点 parent$(u)$ 产生影响。具体来说，如果 $u$ 未被包含在覆盖中，那么其父节点 parent$(u)$ *必须* 被包含在内，以覆盖边 (parent$(u)$, $u$)。因此，我们的 DP 状态必须区分这两种情况。\n\n我们为每个节点 $u \\in V$ 定义两个值：\n- $DP_{in}(u)$: 子树 $T_u$ 的最小顶点覆盖的大小，约束条件是节点 $u$ *被包含* 在顶点覆盖中。\n- $DP_{out}(u)$: 子树 $T_u$ 的最小顶点覆盖的大小，约束条件是节点 $u$ *不被包含* 在顶点覆盖中。\n\n最优子结构属性成立：子树 $T_u$ 的最优解可以由以 $u$ 的子节点为根的子树的最优解构造而成。令 $Children(u)$ 为节点 $u$ 的子节点集合。\n\n递推关系推导如下：\n\n**情况1：$u$ 在顶点覆盖中 ($DP_{in}(u)$)。**\n如果我们将 $u$ 包含在覆盖中，其自身的代价是 $1$。通过包含 $u$，所有对于 $v \\in Children(u)$ 的边 $(u,v)$ 都被覆盖了。对于每个子节点 $v$，我们现在可以自由选择是否将 $v$ 包含在 $T_v$ 的覆盖中。为了使 $T_u$ 的覆盖大小最小，我们应该为每个子节点的子树选择两个选项中较小的一个。因此，对于每个 $v \\in Children(u)$，我们将 $\\min(DP_{in}(v), DP_{out}(v))$ 加到总和中。\n$$DP_{in}(u) = 1 + \\sum_{v \\in Children(u)} \\min(DP_{in}(v), DP_{out}(v))$$\n\n**情况2：$u$ 不在顶点覆盖中 ($DP_{out}(u)$)。**\n如果我们不将 $u$ 包含在覆盖中，其自身的代价是 $0$。然而，为了覆盖对于每个子节点 $v \\in Children(u)$ 的边 $(u,v)$，我们*必须*将 $v$ 包含在其子树 $T_v$ 的顶点覆盖中。在 $T_u$ 的结构内，没有其他选择可以覆盖这些边（因为 $u$ 不在覆盖中，而 $v$ 是边 $(u,v)$ 的唯一另一个端点）。因此，对于每个子节点 $v$，我们必须选择将 $v$ 包含在内的解。\n$$DP_{out}(u) = \\sum_{v \\in Children(u)} DP_{in}(v)$$\n\n**基本情况：**\n递归在树的叶节点处终止。对于任意叶节点 $l$，$Children(l) = \\emptyset$。\n- $DP_{in}(l) = 1$: 子树 $T_l$（仅包含节点 $l$）的覆盖是 $\\{l\\}$，大小为 $1$。\n- $DP_{out}(l) = 0$: 子树 $T_l$ 的覆盖是 $\\emptyset$，大小为 $0$。由于 $T_l$ 内没有边，空集是一个有效的覆盖。\n\n最后，在为所有节点直到根节点 $r$ 计算了这些值之后，整个树 $T$ 的最小顶点覆盖的大小是根节点两种可能性的最小值：$\\min(DP_{in}(r), DP_{out}(r))$。\n\n### 2. 正确性证明\n\n我们通过对树的结构进行归纳来证明其正确性，论证我们的算法为每个子树 $T_u$ 找到了一个有效且最小的顶点覆盖。\n\n**有效性（所有边都被覆盖）：**\n- **基本情况：**对于一个叶节点 $l$，子树 $T_l$ 没有边，所以该性质不证自明。\n- **归纳假设 (I.H.)：**假设对于节点 $u$ 的所有子节点 $v$，$DP_{in}(v)$ 和 $DP_{out}(v)$ 的值对应于它们各自子树 $T_v$ 的有效顶点覆盖。\n- **归纳步骤：**考虑子树 $T_u$。其边由集合 $\\{(u,v) \\mid v \\in Children(u)\\}$ 以及每个子树 $T_v$ 内的所有边组成。\n  - 如果我们计算 $DP_{in}(u)$，我们将 $u$ 包含在覆盖中。这覆盖了所有边 $(u,v)$。根据归纳假设，为每个 $T_v$ 选择的子解覆盖了那些子树内的所有边。因此，$T_u$ 中的所有边都被覆盖。\n  - 如果我们计算 $DP_{out}(u)$，我们不包含 $u$。递推关系迫使我们为每个子节点 $v$ 选择 $DP_{in}(v)$ 解。这意味着每个 $v \\in Children(u)$ 都被包含在覆盖中，从而覆盖了所有边 $(u,v)$。根据归纳假设，$DP_{in}(v)$ 解也覆盖了 $T_v$ 内的所有边。因此，$T_u$ 中的所有边都被覆盖。\n在两种情况下，我们都为 $T_u$ 产生了一个有效的顶点覆盖。\n\n**最小性（最优性）：**\n- **基本情况：**对于一个叶节点 $l$，$DP_{in}(l)=1$ 和 $DP_{out}(l)=0$ 显然是对应约束下的最优解。\n- **归纳假设：**假设对于节点 $u$ 的所有子节点 $v$，$DP_{in}(v)$ 和 $DP_{out}(v)$ 是在各自约束条件下 $T_v$ 的*最小*顶点覆盖的大小。\n- **归纳步骤：**考虑 $T_u$ 的一个最优顶点覆盖 $S^*$。\n  - 如果 $u \\in S^*$，那么 $S^* \\setminus \\{u\\}$ 必须覆盖子树 $T_v$ 内的所有边。要以最优方式做到这一点，对于每个 $T_v$，$S^*$ 在 $T_v$ 中的部分必须是 $T_v$ 的一个最小顶点覆盖。其大小将是 $\\min(|S^*_{v,in}|, |S^*_{v,out}|)$，根据归纳假设，这等于 $\\min(DP_{in}(v), DP_{out}(v))$。对所有子节点求和并为 $u$ 加上 $1$，表明 $|S^*| = DP_{in}(u)$。\n  - 如果 $u \\notin S^*$，那么为了覆盖边 $(u,v)$，每个子节点 $v$ 都必须在 $S^*$ 中。然后 $S^*$ 的其余部分必须是对于每个 $T_v$ 在给定 $v$ 被包含的情况下的一个最优覆盖。根据归纳假设，每个 $T_v$ 的大小是 $DP_{in}(v)$。对所有子节点求和表明 $|S^*| = DP_{out}(u)$。\n由于 $T_u$ 的任何最优解都必须属于这两种类别之一，因此 $DP_{in}(u)$ 和 $DP_{out}(u)$ 的最小值给出了 $T_u$ 的最小顶点覆盖的大小。这种局部最优性会传播到根节点，确保了全局最优解。\n\n### 3. 复杂度分析\n\n- **时间复杂度：**该算法为每个节点 $u \\in V$ 计算两个值，$DP_{in}(u)$ 和 $DP_{out}(u)$。节点 $u$ 的计算需要对其子节点进行求和。一次后序遍历（例如，使用深度优先搜索）确保当我们在计算 $u$ 的值时，其所有子节点的值都已可用。总计算时间是在每个节点上完成的工作之和。节点 $u$ 处的工作量与其子节点数量 $|Children(u)|$ 成正比。\n因此，总时间与 $\\sum_{u \\in V} |Children(u)|$ 成正比。在一棵有 $n$ 个顶点的树中，所有节点的子节点数量之和等于总边数，即 $|E| = n-1$。因此，时间复杂度为 $O(n-1) = O(n)$。\n- **空间复杂度：**我们需要为 $n$ 个顶点中的每一个存储两个 DP 值。这需要 $O(n)$ 的空间。此外，如果算法是递归实现的，调用栈的深度最多可以为 $n$（在路径图的情况下），这也会贡献 $O(n)$ 的空间。因此，总空间复杂度为 $O(n)$。\n\n### 4. 应用于给定实例\n\n树是 $T=(V,E)$，其中 $V=\\{1, \\dots, 14\\}$ 且 $E = \\{(1,2),(1,3),(1,4),(2,5),(2,6),(3,7),(4,8),(4,9),(7,10),(7,11),(9,12),(10,13),(10,14)\\}$。我们以顶点 $1$ 为根。父子关系如下：\n- $Children(1) = \\{2,3,4\\}$\n- $Children(2) = \\{5,6\\}$\n- $Children(3) = \\{7\\}$\n- $Children(4) = \\{8,9\\}$\n- $Children(7) = \\{10,11\\}$\n- $Children(9) = \\{12\\}$\n- $Children(10) = \\{13,14\\}$\n- 顶点 $\\{5,6,8,11,12,13,14\\}$ 是叶节点。\n\n我们以后序遍历（自底向上）的方式计算 DP 值。对于任何节点 $u$，我们将其 DP 值表示为一个对 $(DP_{in}(u), DP_{out}(u))$。\n\n**叶节点：**对于任何叶节点 $l \\in \\{5,6,8,11,12,13,14\\}$：\n- $(DP_{in}(l), DP_{out}(l)) = (1, 0)$\n\n**节点 2：** $Children(2)=\\{5,6\\}$\n- $DP_{in}(2) = 1 + \\min(DP_{in}(5), DP_{out}(5)) + \\min(DP_{in}(6), DP_{out}(6)) = 1 + \\min(1,0) + \\min(1,0) = 1+0+0 = 1$\n- $DP_{out}(2) = DP_{in}(5) + DP_{in}(6) = 1+1 = 2$\n- 对于节点 $2$： $(1, 2)$\n\n**节点 10：** $Children(10)=\\{13,14\\}$\n- $DP_{in}(10) = 1 + \\min(1,0) + \\min(1,0) = 1$\n- $DP_{out}(10) = 1+1 = 2$\n- 对于节点 $10$： $(1, 2)$\n\n**节点 7：** $Children(7)=\\{10,11\\}$\n- $DP_{in}(7) = 1 + \\min(DP_{in}(10), DP_{out}(10)) + \\min(DP_{in}(11), DP_{out}(11)) = 1 + \\min(1,2) + \\min(1,0) = 1+1+0 = 2$\n- $DP_{out}(7) = DP_{in}(10) + DP_{in}(11) = 1+1 = 2$\n- 对于节点 $7$： $(2, 2)$\n\n**节点 3：** $Children(3)=\\{7\\}$\n- $DP_{in}(3) = 1 + \\min(DP_{in}(7), DP_{out}(7)) = 1 + \\min(2,2) = 1+2 = 3$\n- $DP_{out}(3) = DP_{in}(7) = 2$\n- 对于节点 $3$： $(3, 2)$\n\n**节点 9：** $Children(9)=\\{12\\}$\n- $DP_{in}(9) = 1 + \\min(DP_{in}(12), DP_{out}(12)) = 1 + \\min(1,0) = 1$\n- $DP_{out}(9) = DP_{in}(12) = 1$\n- 对于节点 $9$： $(1, 1)$\n\n**节点 4：** $Children(4)=\\{8,9\\}$\n- $DP_{in}(4) = 1 + \\min(DP_{in}(8), DP_{out}(8)) + \\min(DP_{in}(9), DP_{out}(9)) = 1 + \\min(1,0) + \\min(1,1) = 1+0+1 = 2$\n- $DP_{out}(4) = DP_{in}(8) + DP_{in}(9) = 1+1 = 2$\n- 对于节点 $4$： $(2, 2)$\n\n**根节点 1：** $Children(1)=\\{2,3,4\\}$\n- $DP_{in}(1) = 1 + \\min(DP_{in}(2), DP_{out}(2)) + \\min(DP_{in}(3), DP_{out}(3)) + \\min(DP_{in}(4), DP_{out}(4))$\n  $DP_{in}(1) = 1 + \\min(1,2) + \\min(3,2) + \\min(2,2) = 1 + 1 + 2 + 2 = 6$\n- $DP_{out}(1) = DP_{in}(2) + DP_{in}(3) + DP_{in}(4) = 1 + 3 + 2 = 6$\n- 对于节点 $1$： $(6, 6)$\n\n整个树 $T$ 的最小顶点覆盖的大小是 $\\min(DP_{in}(1), DP_{out}(1))$。\n大小 = $\\min(6, 6) = 6$。", "answer": "$$\\boxed{6}$$", "id": "3256361"}, {"introduction": "我们继续探索顶点覆盖问题，这次的焦点是二分图。这种情况揭示了一种与动态规划不同的解题策略：将问题规约（reduce）到另一个我们已经拥有多项式时间算法的、看似不相关的问题上。本练习挑战你将二分图上的顶点覆盖问题与最大匹配问题（最终通过最大流问题）联系起来，这是一种能够为其解锁高效解法的基本技巧。[@problem_id:3256322]", "problem": "考虑顶点覆盖（VERTEX-COVER）问题的决策版本：给定一个图 $G=(V,E)$ 和一个整数 $k$，是否存在一个子集 $C \\subseteq V$，其大小 $|C| \\le k$，使得 $E$ 中的每条边至少有一个端点在 $C$ 中？分析将顶点覆盖问题限制在二分图 $G=(L \\cup R, E)$ 上的情况，其中 $L$ 和 $R$ 构成 $V$ 的一个划分，并且每条边的一个端点在 $L$ 中，另一个在 $R$ 中。仅使用算法中的基本定义和广为接受的多项式时间原语（不假设任何关于二分图的特定定理），确定在该限制下，顶点覆盖问题是否仍然是NP-完全的。如果不是，推导一个多项式时间算法，该算法在给定一个二分图 $G=(L \\cup R, E)$ 的情况下，计算最小顶点覆盖的精确大小。\n\n在建立你的算法并证明其正确性之后，将其应用于下面明确定义的二分图 $G_{a,b,c}$，并以单一整数的形式报告最小顶点覆盖的精确大小（无需四舍五入）：\n\n- 左部为 $L = \\{\\ell_1,\\ldots,\\ell_{a+b}\\}$，右部为 $R = \\{r_1,\\ldots,r_{a+c}\\}$。\n- 对于 $i \\in \\{1,\\ldots,a\\}$ 中的每个 $\\ell_i$，与 $j \\in \\{1,\\ldots,a+c\\}$ 中的每个 $r_j$ 之间都存在边。\n- 对于 $i \\in \\{a+1,\\ldots,a+b\\}$ 中的每个 $\\ell_i$，与 $j \\in \\{1,\\ldots,c\\}$ 中的每个 $r_j$ 之间都存在边。\n\n对于参数 $a=7$, $b=5$, $c=8$ 的实例，计算你的最终整数值。你的最终答案必须是一个单一整数。不要提供任何不等式或方程式作为最终答案。", "solution": "首先验证问题陈述的正确性和完整性。\n\n**步骤1：提取已知条件**\n- **问题：** 顶点覆盖问题的决策版本：给定一个图 $G=(V,E)$ 和一个整数 $k$，是否存在一个大小为 $|C| \\le k$ 的顶点覆盖 $C \\subseteq V$？\n- **限制：** 输入图 $G$ 是一个二分图，$G=(L \\cup R, E)$。\n- **任务1：** 确定二分图上的顶点覆盖问题是否是NP完全的。\n- **任务2：** 如果不是NP完全的，则推导一个多项式时间算法来计算最小顶点覆盖的大小。此推导必须仅使用基本定义和广为接受的多项式时间原语，而不假设关于二分图的特定命名定理（例如，Kőnig定理）。\n- **任务3：** 将所建立的理解应用于一个特定的二分图 $G_{a,b,c}$，其定义如下：\n    - 左部划分：$L = \\{\\ell_1, \\ldots, \\ell_{a+b}\\}$\n    - 右部划分：$R = \\{r_1, \\ldots, r_{a+c}\\}$\n    - 边：\n        1. 从 $i \\in \\{1,\\ldots,a\\}$ 的每个 $\\ell_i$ 到 $j \\in \\{1,\\ldots,a+c\\}$ 的每个 $r_j$。\n        2. 从 $i \\in \\{a+1,\\ldots,a+b\\}$ 的每个 $\\ell_i$ 到 $j \\in \\{1,\\ldots,c\\}$ 的每个 $r_j$。\n- **任务4：** 计算参数为 $a=7$, $b=5$, $c=8$ 时，$G_{a,b,c}$ 的最小顶点覆盖的精确大小。\n\n**步骤2：使用提取的已知条件进行验证**\n该问题定义明确、自成一体，并且在理论计算机科学领域，特别是算法和计算复杂性方面，具有科学依据。顶点覆盖、二分图和NP完全性的定义都是标准的。避免使用特定命名定理的约束是一种教学指令，以确保解法是从更基本的原理推导出来的，这是学术问题中一种有效且常见的结构。该问题不模糊、不矛盾，也非微不足道。\n\n**结论：** 问题有效。\n\n**求解推导**\n\n一个集合 $C \\subseteq V$ 是图 $G=(V,E)$ 的一个顶点覆盖，如果对于每条边 $(u,v) \\in E$，至少 $u$ 或 $v$ 中的一个在 $C$ 中。一个集合 $I \\subseteq V$ 是一个独立集，如果对于任何两个顶点 $u,v \\in I$，它们之间没有边。一个集合 $C$ 是一个顶点覆盖当且仅当其补集 $V \\setminus C$ 是一个独立集。这一基本关系意味着，寻找一个最小顶点覆盖在计算上等价于寻找一个最大独立集，因为最小顶点覆盖的大小 $\\tau(G)$ 和最大独立集的大小 $\\alpha(G)$ 通过 $\\tau(G) + \\alpha(G) = |V|$ 相关联。\n\n对于一般图，顶点覆盖是一个经典的NP完全问题。我们研究当它被限制在二分图上时的复杂性。这可以通过将问题与二分图中的最大匹配问题联系起来解决，后者已知可在多项式时间内求解。解决最大二分图匹配的一个标准方法是将其归约为最大流问题，这是一个广为接受的多项式时间原语。\n\n设 $G=(L \\cup R, E)$ 是给定的二分图。我们如下构建一个流网络 $N$：\n1. 创建一个源点 $s$ 和一个汇点 $t$。\n2. 对于每个顶点 $u \\in L$，添加一条从 $s$ 到 $u$ 的有向边，容量为 $c(s,u)=1$。\n3. 对于每个顶点 $v \\in R$，添加一条从 $v$ 到 $t$ 的有向边，容量为 $c(v,t)=1$。\n4. 对于每条边 $(u,v) \\in E$ (其中 $u \\in L$，$v \\in R$)，添加一条从 $u$ 到 $v$ 的有向边，容量为无限大，$c(u,v)=\\infty$。\n\n该网络 $N$ 中的最大流值等于 $G$ 中最大匹配的大小。根据最大流最小割定理，最大流的值等于一个最小 $s-t$ 割的容量。割是将 $N$ 的顶点划分为两个集合 $S$ 和 $T=V(N)\\setminus S$ 的划分，其中 $s \\in S$，$t \\in T$。割 $(S,T)$ 的容量是所有边 $(x,y)$ (其中 $x \\in S$，$y \\in T$) 的容量之和。\n\n$N$ 中的一个最小割必须具有有限容量，因此没有边 $(u,v)$ (其中 $u \\in L$，$v \\in R$) 可以从 $S$ 跨越到 $T$。设最小割为 $(S,T)$。令 $L_S = L \\cap S$，$L_T = L \\cap T$，$R_S = R \\cap S$，$R_T = R \\cap T$。该割的容量是从 $s$到 $L_T$ 的边和从 $R_S$到 $t$ 的边的容量之和。此容量为 $|L_T| + |R_S|$。\n我们在原图 $G$ 中定义一个顶点集 $C = L_T \\cup R_S$。这个集合的大小为 $|C| = |L_T| + |R_S|$。我们可以证明 $C$ 是一个顶点覆盖。考虑任意一条边 $(u,v) \\in E$，其中 $u \\in L, v \\in R$。如果 $u \\in L_T$，则 $u \\in C$。如果 $u \\in L_S$，则 $v$ 不可能在 $R_T$ 中（否则容量无限的边 $(u,v)$ 将跨越最小割）。因此，如果 $u \\in L_S$，则 $v$ 必须在 $R_S$ 中，所以 $v \\in C$。无论哪种情况，边 $(u,v)$ 都被 $C$ 覆盖。\n所以，我们找到了一个顶点覆盖 $C$，其大小等于最小割的容量。因此，\n$$ \\tau(G) \\le |C| = \\text{最小割容量} = \\text{最大流值} = |\\text{最大匹配}| $$\n此外，对于任何图，最小顶点覆盖的大小至少是最大匹配的大小，即 $\\tau(G) \\ge |\\text{最大匹配}|$。结合这两点，我们得到 $\\tau(G) = |\\text{最大匹配}|$。\n\n由于最大二分图匹配可以在多项式时间内求解（例如，通过用于最大流的Edmonds-Karp或Dinic算法），二分图的最小顶点覆盖大小也可以在多项式时间内计算。因此，限制在二分图上的顶点覆盖问题属于P类问题，从而不是NP完全的（除非P=NP）。找到最小顶点覆盖大小的一个多项式时间算法是构建相应的流网络并计算最大流。\n\n**在图 $G_{a,b,c}$ 上的应用**\n\n对于特定的图 $G_{a,b,c}$，我们可以用更直接的组合论证来找到最小顶点覆盖的大小。\n我们划分顶点集：\n- $L = L_A \\cup L_B$，其中 $|L_A|=a$，$|L_B|=b$。（$L_A = \\{\\ell_1, \\ldots, \\ell_a\\}$, $L_B = \\{\\ell_{a+1}, \\ldots, \\ell_{a+b}\\}$）。\n- $R = R_C \\cup R_A'$，其中 $|R_C|=c$，$|R_A'|=a$。（$R_C = \\{r_1, \\ldots, r_c\\}$, $R_A' = \\{r_{c+1}, \\ldots, r_{a+c}\\}$）。\n\n边的结构如下：\n- 由 $L_A \\cup R$ 导出的子图是一个完全二分图 $K_{a, a+c}$。\n- 由 $L_B \\cup R_C$ 导出的子图是一个完全二分图 $K_{b,c}$。\n\n设 $C$ 是 $G_{a,b,c}$ 的一个最小顶点覆盖。我们基于对顶点集 $L_A$ 的处理进行分情况讨论。\n\n**情况1：$L_A \\subseteq C$。**\n如果我们将 $L_A$ 的所有顶点都包含在覆盖中，所有与 $L_A$ 相关联的边都被覆盖。这包括 $L_A$ 和 $R$ 之间的所有边。到目前为止产生的成本是 $|L_A| = a$。剩下未被覆盖的边是 $L_B$ 和 $R_C$ 之间的边。这些顶点上的子图是 $K_{b,c}$。为了覆盖这些边，我们必须将 $K_{b,c}$ 的一个顶点覆盖添加到 $C$ 中。完全二分图 $K_{m,n}$ 的最小顶点覆盖大小为 $\\min(m,n)$，这通过取较小划分中的所有顶点来实现。因此，覆盖 $K_{b,c}$ 的边的额外成本是 $\\min(b,c)$。在这种情况下，顶点覆盖的总大小是 $a + \\min(b,c)$。\n\n**情况2：$L_A \\not\\subseteq C$。**\n如果 $L_A$ 没有被完全包含在 $C$ 中，那么必定至少存在一个顶点 $\\ell \\in L_A$ 使得 $\\ell \\notin C$。根据顶点覆盖的定义，$\\ell$ 的所有邻居都必须在 $C$ 中。根据问题描述，$\\ell$ 连接到 $R$ 中的每个顶点。因此，整个集合 $R$ 必须是 $C$ 的一个子集，即 $R \\subseteq C$。如果 $R \\subseteq C$，图中的每条边都被覆盖，因为每条边都有一个端点在 $R$ 中。这种覆盖的最小大小为 $|R| = a+c$。\n\n$G_{a,b,c}$ 的最小顶点覆盖的大小是这两种情况成本的最小值：\n$$ \\tau(G_{a,b,c}) = \\min(a + \\min(b,c), a+c) $$\n由于 $c$ 是一个非负整数，我们有 $\\min(b,c) \\le c$。这意味着 $a + \\min(b,c) \\le a+c$。因此，这两个值的最小值总是 $a + \\min(b,c)$。\n最小顶点覆盖的大小是 $a + \\min(b,c)$。\n\n**最终计算**\n给定参数 $a=7$, $b=5$, $c=8$。\n将这些值代入我们推导出的公式：\n$$ \\tau(G_{7,5,8}) = 7 + \\min(5, 8) $$\n$$ \\min(5, 8) = 5 $$\n$$ \\tau(G_{7,5,8}) = 7 + 5 = 12 $$\n指定图实例的最小顶点覆盖的精确大小是12。", "answer": "$$\\boxed{12}$$", "id": "3256322"}, {"introduction": "当一个问题被证明是NP难问题时，我们是否就束手无策了？通常，我们会转向近似算法，它牺牲部分最优性以换取计算效率。本练习将通过集合覆盖问题（Set-Cover）来分析一个标准的贪心算法，并要求你构建一个特定的“最坏情况”实例，以精确推导该算法的近似比，从而深入理解近似算法的性能和局限。[@problem_id:3256360]", "problem": "考虑经典的集合覆盖 (Set-Cover) 问题，该问题是已知的非确定性多项式时间 (NP) 完全问题。在其加权版本中，给定一个有限全集 $U$ 和一个子集族 $\\mathcal{S} \\subseteq 2^{U}$，其中每个集合 $S \\in \\mathcal{S}$ 都有一个相关的非负成本 $c(S)$。一个集合覆盖是一个子集族 $\\mathcal{C} \\subseteq \\mathcal{S}$，其并集为 $U$。用于加权集合覆盖的标准贪心近似算法迭代地选择集合 $S \\in \\mathcal{S}$，以最小化比率 $c(S)/|S \\setminus C|$，其中 $C$ 是已覆盖元素的集合，直到 $U$ 被完全覆盖为止。\n\n设计一个由整数 $r \\geq 2$ 和实数参数 $\\epsilon$（其中 $0  \\epsilon  1$）参数化的加权集合覆盖实例的特定族，如下所示。设全集为任意集合 $U$，其大小为 $|U| = 2^{r}$。将 $U$ 分割为 $r+1$ 个不相交的块 $B_{1}, B_{2}, \\dots, B_{r}, B_{r+1}$，其大小对于每个 $1 \\leq j \\leq r$ 为 $|B_{j}| = 2^{r-j}$，且 $|B_{r+1}| = 1$。定义集合族 $\\mathcal{S}$ 由以下集合组成：\n- 单个全局集合 $G = U$，其成本为 $c(G) = 2 + \\epsilon$，以及\n- $r+1$ 个块集合 $A_{j} = B_{j}$，对于所有 $1 \\leq j \\leq r+1$，其成本为 $c(A_{j}) = 1$。\n\n仅使用集合覆盖的核心定义和所述的贪心规则，推导贪心算法在此实例族上的精确近似比。该近似比定义为贪心算法返回的总成本除以最优成本。将您的最终答案表示为关于 $r$ 和 $\\epsilon$ 的单个简化符号表达式。无需四舍五入，不涉及单位。", "solution": "该问题要求推导标准贪心算法在特定实例族上对加权集合覆盖问题的精确近似比。近似比定义为贪心算法产生的覆盖的总成本除以最优覆盖的成本。\n\n让我们首先将问题给出的条件形式化。\n全集是一个集合 $U$，其大小为 $|U| = 2^r$，其中 $r \\geq 2$ 是一个整数。\n全集 $U$ 被划分为 $r+1$ 个不相交的块：$U = B_1 \\cup B_2 \\cup \\dots \\cup B_r \\cup B_{r+1}$。\n这些块的大小由 $|B_j| = 2^{r-j}$（对于 $1 \\leq j \\leq r$）和 $|B_{r+1}| = 1$ 给出。\n这些块的大小之和为 $\\sum_{j=1}^{r} |B_j| + |B_{r+1}| = \\left(\\sum_{j=1}^{r} 2^{r-j}\\right) + 1$。该和是一个几何级数：$\\sum_{k=0}^{r-1} 2^k = \\frac{2^r - 1}{2-1} = 2^r - 1$。因此，总大小为 $(2^r - 1) + 1 = 2^r$，这与 $|U|$ 的大小相符。\n\n子集族 $\\mathcal{S}$ 由以下部分组成：\n1.  一个全局集合 $G = U$，其成本为 $c(G) = 2 + \\epsilon$，其中 $0  \\epsilon  1$。\n2.  一组 $r+1$ 个块集合 $A_j = B_j$（对于 $1 \\leq j \\leq r+1$），每个集合的成本为 $c(A_j) = 1$。\n\n解决方案需要两个组成部分：最优解的成本 $C_{OPT}$，以及由贪心算法产生的解的成本 $C_{Greedy}$。\n\n**1. 确定最优成本 ($C_{OPT}$)**\n\n$U$ 的一个集合覆盖必须是 $\\mathcal{S}$ 的一个子集族，其并集为 $U$。我们确定了两个最优覆盖的主要候选方案：\n-   **候选方案 1：** 选择单个集合 $G$。由于 $G=U$，这构成了一个有效的覆盖。此覆盖的成本为 $C_1 = c(G) = 2 + \\epsilon$。\n-   **候选方案 2：** 选择所有块集合的集合 $\\{A_1, A_2, \\dots, A_{r+1}\\}$。由于块 $\\{B_1, \\dots, B_{r+1}\\}$ 构成 $U$ 的一个划分，它们的并集是 $U$。因此，$\\bigcup_{j=1}^{r+1} A_j = \\bigcup_{j=1}^{r+1} B_j = U$。这是一个有效的覆盖。此覆盖的成本为 $C_2 = \\sum_{j=1}^{r+1} c(A_j) = \\sum_{j=1}^{r+1} 1 = r+1$。\n\n任何其他有效的覆盖都将是其中之一的超集，因此成本更高。例如，$\\{G, A_1\\}$ 是一个有效的覆盖，但其成本高于 $\\{G\\}$。\n最优成本 $C_{OPT}$ 是所有可能的有效覆盖成本中的最小值。因此，$C_{OPT} = \\min(C_1, C_2) = \\min(2+\\epsilon, r+1)$。\n\n给定约束条件 $r \\geq 2$ 和 $0  \\epsilon  1$：\n-   $r+1$ 的值是一个大于或等于 $3$ 的整数。\n-   $2+\\epsilon$ 的值是一个实数，满足 $2  2+\\epsilon  3$。\n由于 $r+1 \\geq 3$ 且 $2+\\epsilon  3$，因此 $2+\\epsilon \\le r+1$ 总是成立的。\n因此，通过选择单个集合 $G$ 可以达到最小成本。\n$$C_{OPT} = 2 + \\epsilon$$\n\n**2. 确定贪心算法的成本 ($C_{Greedy}$)**\n\n贪心算法迭代地选择能最小化成本效益比的集合 $S$，该比率定义为 $\\frac{c(S)}{|S \\setminus C|}$，其中 $C$ 是已覆盖元素的集合。设 $C_k$ 为第 $k$ 次迭代后已覆盖元素的集合。\n\n**第 1 次迭代：**\n最初，已覆盖元素的集合为空，$C_0 = \\emptyset$。我们为每个集合 $S \\in \\mathcal{S}$ 计算比率。\n-   对于全局集合 $G$：$\\frac{c(G)}{|G \\setminus C_0|} = \\frac{2+\\epsilon}{|G|} = \\frac{2+\\epsilon}{2^r}$。\n-   对于块集合 $A_j=B_j$ ($1 \\leq j \\leq r$)：$\\frac{c(A_j)}{|A_j \\setminus C_0|} = \\frac{1}{|B_j|} = \\frac{1}{2^{r-j}}$。\n-   对于块集合 $A_{r+1}=B_{r+1}$：$\\frac{c(A_{r+1})}{|A_{r+1} \\setminus C_0|} = \\frac{1}{|B_{r+1}|} = \\frac{1}{1} = 1$。\n\n块集合的比率集合为 $\\{\\frac{1}{2^{r-1}}, \\frac{1}{2^{r-2}}, \\dots, \\frac{1}{2^1}, \\frac{1}{2^0}=1, 1\\}$。其中的最小值是 $\\frac{1}{2^{r-1}}$，对应于集合 $A_1$。\n现在，我们将这个最小比率与集合 $G$ 的比率进行比较。\n我们比较 $\\frac{1}{2^{r-1}}$ 和 $\\frac{2+\\epsilon}{2^r}$。\n两边同乘以 $2^r$ 得到 $2$ 和 $2+\\epsilon$。\n由于 $0  \\epsilon  1$，我们有 $2  2+\\epsilon$。因此，$\\frac{2}{2^r}  \\frac{2+\\epsilon}{2^r}$，这意味着 $\\frac{1}{2^{r-1}}  \\frac{2+\\epsilon}{2^r}$。\n贪心算法选择比率最小的集合，即 $A_1$。产生的成本为 $1$。已覆盖元素的集合变为 $C_1 = B_1$。\n\n**第 $k$ 次迭代 (对于 $2 \\leq k \\leq r$)：**\n我们假设在第 $1, 2, \\dots, k-1$ 次迭代中，算法选择了集合 $A_1, A_2, \\dots, A_{k-1}$。\n已覆盖元素的集合是 $C_{k-1} = \\bigcup_{i=1}^{k-1} B_i$。需要考虑的剩余集合是 $\\{G, A_k, A_{k+1}, \\dots, A_{r+1}\\}$。\n未覆盖元素的数量是 $|U \\setminus C_{k-1}| = |U| - \\sum_{i=1}^{k-1} |B_i| = 2^r - \\sum_{i=1}^{k-1} 2^{r-i}$。\n这个和是一个几何级数：$\\sum_{i=1}^{k-1} 2^{r-i} = 2^{r-1} + 2^{r-2} + \\dots + 2^{r-k+1} = 2^{r-k+1}(2^{k-2} + \\dots + 1) = 2^{r-k+1}(2^{k-1}-1) = 2^r-2^{r-k+1}$。\n所以， $|U \\setminus C_{k-1}| = 2^r - (2^r-2^{r-k+1}) = 2^{r-k+1}$。\n\n现在我们评估比率：\n-   对于全局集合 $G$：$\\frac{c(G)}{|G \\setminus C_{k-1}|} = \\frac{2+\\epsilon}{|U \\setminus C_{k-1}|} = \\frac{2+\\epsilon}{2^{r-k+1}}$。\n-   对于块集合 $A_j$（其中 $j \\geq k$），由于 $B_j$ 与 $C_{k-1}$ 不相交，我们有 $|A_j \\setminus C_{k-1}|=|A_j|=|B_j|$。\n    比率为 $\\frac{c(A_j)}{|A_j \\setminus C_{k-1}|} = \\frac{1}{|B_j|}$。\n    对于 $j \\in \\{k, \\dots, r+1\\}$，这些比率的最小值对应于具有最大大小 $|B_j|$ 的集合 $A_j$，即大小为 $|B_k|=2^{r-k}$ 的 $A_k$。最小比率为 $\\frac{1}{2^{r-k}}$。\n\n将块集合的最小比率与 $G$ 的比率进行比较：\n我们比较 $\\frac{1}{2^{r-k}}$ 和 $\\frac{2+\\epsilon}{2^{r-k+1}}$。\n两边同乘以 $2^{r-k+1}$ 得到 $2$ 和 $2+\\epsilon$。\n由于 $2  2+\\epsilon$，我们有 $\\frac{1}{2^{r-k}}  \\frac{2+\\epsilon}{2^{r-k+1}}$。\n贪心算法选择 $A_k$。这对从 $2$ 到 $r$ 的所有 $k$ 都成立。\n\n**最后一次迭代 ($k=r+1$)：**\n经过 $r$ 次迭代后，算法选择了集合 $A_1, A_2, \\dots, A_r$。\n已覆盖的集合是 $C_r = \\bigcup_{j=1}^{r} B_j$。唯一未被覆盖的元素在块 $B_{r+1}$ 中。\n可用于覆盖这些元素的集合是 $G$ 和 $A_{r+1}$。\n-   对于全局集合 $G$：$\\frac{c(G)}{|G \\setminus C_r|} = \\frac{2+\\epsilon}{|B_{r+1}|} = \\frac{2+\\epsilon}{1} = 2+\\epsilon$。\n-   对于块集合 $A_{r+1}$：$\\frac{c(A_{r+1})}{|A_{r+1} \\setminus C_r|} = \\frac{1}{|B_{r+1}|} = \\frac{1}{1} = 1$。\n\n比较这些比率，$1  2+\\epsilon$。算法选择 $A_{r+1}$。\n现在 $U$ 中的所有元素都已被覆盖，算法终止。\n\n贪心算法选择的集合是 $\\mathcal{C}_{Greedy} = \\{A_1, A_2, \\dots, A_r, A_{r+1}\\}$。\n这个覆盖的总成本是 $C_{Greedy} = \\sum_{j=1}^{r+1} c(A_j) = \\sum_{j=1}^{r+1} 1 = r+1$。\n\n**3. 计算近似比**\n\n近似比由公式 $\\frac{C_{Greedy}}{C_{OPT}}$ 给出。\n代入推导出的值：\n$$ \\text{近似比} = \\frac{r+1}{2+\\epsilon} $$\n\n该表达式是贪心算法对于给定实例族的精确近似比。", "answer": "$$\\boxed{\\frac{r+1}{2+\\epsilon}}$$", "id": "3256360"}]}