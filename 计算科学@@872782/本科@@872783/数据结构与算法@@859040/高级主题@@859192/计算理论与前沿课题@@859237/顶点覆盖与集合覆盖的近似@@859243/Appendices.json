{"hands_on_practices": [{"introduction": "基于极大匹配的2-近似算法是解决NP难的顶点覆盖问题的一种基础而实用的方法。这个练习将引导你一步步地执行该算法，从而直观地理解其工作原理，并学习如何将其结果与最优解进行比较来评估其性能。[@problem_id:1481691]", "problem": "在计算复杂性理论领域，顶点覆盖问题是 NP-hard 问题的一个经典例子。给定一个图，目标是找到一个最小规模的顶点子集，使得图中的每条边都至少与该子集中的一个顶点相连。这样的子集称为最小（或最优）顶点覆盖，其对于图 $G$ 的大小记为 $\\tau(G)$。\n\n由于对于大型图来说，找到最优解在计算上是困难的，因此通常使用近似算法。其中一种算法是基于极大匹配的2-近似算法。它保证得到的解的大小不超过最优解大小的两倍。该算法的步骤如下：\n1.  从一个空的匹配集 $M = \\emptyset$ 开始。匹配是指一组边，其中任意两条边都不共享公共顶点。\n2.  构造一个**极大匹配**。如果一个匹配无法通过从图中添加任何其他边来扩展，则该匹配是极大的。对于本问题，你将使用一个特定的贪心过程来构造极大匹配：遍历一个预定义的边列表，对于每一条边，当且仅当它不与 $M$ 中已有的任何边共享端点时，才将其添加到 $M$ 中。\n3.  最终得到的顶点覆盖（我们称之为 $C_{approx}$）由极大匹配 $M$ 中所有边的所有端点构成。\n\n考虑一个无向图 $G = (V, E)$，其顶点集为 $V = \\{A, B, C, D, E, F, G, H\\}$，边集为 $E = \\{(A,B), (A,C), (B,C), (C,D), (D,E), (D,F), (E,F), (F,G), (G,H)\\}$。\n\n为了构造极大匹配，请按以下特定顺序处理集合 $E$ 中的边：\n$(G,H), (F,G), (E,F), (D,F), (D,E), (C,D), (B,C), (A,C), (A,B)$。\n\n你的任务是计算本次特定执行的近似比。近似比定义为所生成的顶点覆盖的大小与最优顶点覆盖的大小的比值，即 $\\frac{|C_{approx}|}{\\tau(G)}$。\n\n计算这个近似比。最终答案以保留两位有效数字的小数形式表示。", "solution": "我们遵循指定的贪心策略构造极大匹配。初始化 $M=\\emptyset$ 并按给定顺序处理边，如果某条边不与 $M$ 中已有的任何边共享端点，则将其加入 $M$。\n\n- 处理 $(G,H)$：添加，因此 $M=\\{(G,H)\\}$，已用端点为 $\\{G,H\\}$。\n- $(F,G)$ 共享顶点 $G$，跳过。\n- $(E,F)$ 与 $\\{G,H\\}$ 不共享端点，添加：$M=\\{(G,H),(E,F)\\}$，已用端点为 $\\{E,F,G,H\\}$。\n- $(D,F)$ 共享顶点 $F$，跳过。\n- $(D,E)$ 共享顶点 $E$，跳过。\n- $(C,D)$ 与 $\\{E,F,G,H\\}$ 不共享端点，添加：$M=\\{(G,H),(E,F),(C,D)\\}$，已用端点为 $\\{C,D,E,F,G,H\\}$。\n- $(B,C)$ 共享顶点 $C$，跳过。\n- $(A,C)$ 共享顶点 $C$，跳过。\n- $(A,B)$ 与当前 $M$ 中的边不共享端点，添加：$M=\\{(G,H),(E,F),(C,D),(A,B)\\}$，已用端点为 $\\{A,B,C,D,E,F,G,H\\}$。\n\n因此，极大匹配的大小为 $|M|=4$，而2-近似算法输出的顶点覆盖 $C_{approx}$ 由 $M$ 中所有边的端点构成，因此 $C_{approx}=V$ 并且\n$$\n|C_{approx}|=8.\n$$\n\n接下来，计算最优顶点覆盖的大小 $\\tau(G)$。一个通用的下界由最大匹配 $\\nu(G)$ 的大小给出：\n$$\n\\tau(G)\\geq \\nu(G).\n$$\n因为我们找到了一个大小为 $4$ 的匹配，所以 $\\nu(G)\\geq 4$，因此 $\\tau(G)\\geq 4$。\n\n我们证明 $\\tau(G)\\geq 5$。在 $\\{A,B,C\\}$ 上的子图是一个三角形，因此任何顶点覆盖都必须至少包含 $\\{A,B,C\\}$ 中的 $2$ 个顶点。类似地，在 $\\{D,E,F\\}$ 上的子图也是一个三角形，因此必须至少包含 $\\{D,E,F\\}$ 中的 $2$ 个顶点。如果 $\\tau(G)=4$，那么该覆盖将恰好由 $\\{A,B,C\\}$ 中的 $2$ 个顶点和 $\\{D,E,F\\}$ 中的 $2$ 个顶点组成，而没有来自 $\\{G,H\\}$ 的顶点。这将导致边 $(G,H)$ 未被覆盖，这是一个矛盾。因此\n$$\n\\tau(G)\\geq 5.\n$$\n\n我们现在给出一个大小为 $5$ 的顶点覆盖来证明其最优性。取\n$$\nS=\\{A,C,D,E,G\\}.\n$$\n该集合覆盖了：\n- 通过 $A$ 和 $C$ 覆盖了 $\\{A,B,C\\}$ 上的三角形；\n- 通过 $C$ 或 $D$ 覆盖了边 $(C,D)$；\n- 通过 $D$ 和 $E$ 覆盖了 $\\{D,E,F\\}$ 上的三角形；\n- 通过 $G$ 覆盖了路径边 $(F,G)$ 和 $(G,H)$。\n\n因此 $S$ 是一个大小为 $5$ 的顶点覆盖，所以\n$$\n\\tau(G)=5.\n$$\n\n所以，近似比为\n$$\n\\frac{|C_{approx}|}{\\tau(G)}=\\frac{8}{5}=1.6,\n$$\n其保留两位有效数字的小数形式为 $1.6$。", "answer": "$$\\boxed{1.6}$$", "id": "1481691"}, {"introduction": "在了解了算法的运作方式后，理解其性能边界也至关重要。本练习构建了一个“最坏情况”的特例，展示了2-近似算法的性能如何精确地达到其理论保证的上限。通过这个练习，你将深刻体会到为何该算法被称为“2-近似”算法，以及这个界限的实际意义。[@problem_id:1412471]", "problem": "一位系统架构师正在为分布式计算网络设计一种监控策略。该网络被建模为一个图 $G=(V, E)$，其中顶点集 $V$ 代表服务器，边集 $E$ 代表直接通信链路。一个“监控集”是服务器的一个子集 $C \\subseteq V$，使得 $E$ 中的每条通信链路都至少连接到 $C$ 中的一个服务器。这在形式上被称为顶点覆盖（Vertex Cover）。\n\n找到一个最小可能规模的监控集是一个 NP-难问题。因此，该架构师采用了一种近似算法。该算法的工作方式如下：\n1. 从一个空的监控集 $C = \\emptyset$ 开始。\n2. 当网络中仍有未被覆盖的链路时，选择一条任意的未被覆盖的链路 $(u, v)$。\n3. 将服务器 $u$ 和 $v$ 都添加到监控集 $C$ 中。\n4. 所有连接到 $u$ 或 $v$ 的链路现在都被视为已覆盖。\n5. 重复此过程，直到所有链路都被覆盖。\n\n这个过程等价于在图中找到一个极大匹配 $M$，然后由 $M$ 中所有边的端点构成顶点覆盖 $C$。\n\n为了对该算法进行压力测试，架构师构建了一个特殊的测试用例图。这个图 $G$ 由 $k=50$ 个分离的、不相交的连通分量组成。每个连通分量都是一个 $K_{1,n}$ 类型的“星形图”，其中 $n=10$。一个 $K_{1,n}$ 图由一个中心服务器通过链路连接到 $n$ 个外围服务器组成。因此，整个图 $G$ 由 50 个独立的星形服务器集群组成。\n\n对于这个测试，通过从 50 个星形图连通分量中的每一个精确地选择一条链路，来生成一个特定的极大匹配 $M$。\n\n对于这个特定的图和所选的极大匹配，由所述算法产生的监控集中的服务器总数是多少？", "solution": "该算法从一个极大匹配的端点构建其监控集。如果 $M$ 是所选的极大匹配，那么监控集是\n$$\nC=\\bigcup_{(u,v)\\in M}\\{u,v\\},\n$$\n所以其基数满足\n$$\n|C|=\\sum_{(u,v)\\in M}2=2|M|.\n$$\n图 $G$ 是 $k=50$ 个星形图 $K_{1,n}$（其中 $n=10$）的不交并。在一个星形图 $K_{1,n}$ 中，每条边都与唯一的中心顶点相关联，所以一个匹配最多只能包含一条边；因此，在每个星形图中选择一条边会产生一个在每个连通分量中恰好有一条边且是极大的匹配。因此，根据指定的构造方法——从 50 个连通分量中的每一个精确选择一条边——我们得到\n$$\n|M|=k=50.\n$$\n应用监控集和匹配大小之间的关系可得\n$$\n|C|=2|M|=2k=2\\cdot 50=100.\n$$\n因此，该算法产生的监控集包含 100 个服务器。", "answer": "$$\\boxed{100}$$", "id": "1412471"}, {"introduction": "现在，我们将探讨更具一般性的带权顶点覆盖问题，其中每个顶点都有不同的成本。这个练习剖析了一种看似直观但存在缺陷的贪心策略，通过分析这种策略，你将认识到算法设计中严谨证明的重要性，并理解局部最优选择有时如何导致全局较差的结果。[@problem_id:3281692]", "problem": "您正在研究加权顶点覆盖（Weighted Vertex Cover, WVC）问题：给定一个无向图 $G=(V,E)$ 和一个非负权重函数 $w:V \\to \\mathbb{R}_{\\ge 0}$，顶点覆盖是一个集合 $C \\subseteq V$，使得 $E$ 中的每条边都至少与 $C$ 中的一个顶点相邻。一个覆盖 $C$ 的代价为 $\\sum_{v \\in C} w(v)$。算法课程中通常教授的基于匹配的 WVC 问题的 $2$-近似算法，会选择极大匹配中每条边的两个端点。现在考虑以下有缺陷的变体，该变体试图通过总是优先选择较便宜的端点来降低成本：\n\n算法 Cheaper-From-Matching：\n1. 计算 $G$ 中的任意一个极大匹配 $M$。\n2. 初始化 $C' \\leftarrow \\varnothing$。\n3. 对于 $M$ 中的每条边 $\\{u,v\\}$，将较便宜的端点 $\\arg\\min\\{w(u),w(v)\\}$ 添加到 $C'$ 中。\n4. 当存在未覆盖的边 $\\{x,y\\} \\in E$ 且 $\\{x,y\\} \\cap C' = \\varnothing$ 时，将较便宜的端点 $\\arg\\min\\{w(x),w(y)\\}$ 添加到 $C'$ 中。\n5. 输出 $C'$。\n\n构造以下由整数 $k \\ge 3$ 参数化的实例族。设 $G_k$ 是一个有 $k+1$ 个顶点的星形图，其中心顶点为 $u$，叶顶点为 $v_1,\\dots,v_k$，即 $E=\\{\\{u,v_i\\}: i \\in \\{1,\\dots,k\\}\\}$。定义权重函数为 $w(u)=2$ 且对所有 $i \\in \\{1,\\dots,k\\}$ 有 $w(v_i)=1$。假设在步骤1中选择的极大匹配 $M$ 是 $\\{\\{u,v_1\\}\\}$。\n\n仅使用核心定义（顶点覆盖、极大匹配和代价），在 $G_k$ 上运行算法 Cheaper-From-Matching，并计算其近似比。近似比定义为算法输出的总权重除以最优WVC代价，结果表示为关于 $k$ 的简化闭式表达式。无需四舍五入。", "solution": "该问题要求计算一个名为“Cheaper-From-Matching”的特定算法在一族特定图 $G_k$ 上的近似比。近似比定义为算法产生的顶点覆盖的代价除以最优顶点覆盖的代价。为了计算这个比率，我们必须首先确定最优解的代价，然后确定算法产生的解的代价。\n\n该问题定义在一个有 $k+1$ 个顶点的星形图 $G_k = (V,E)$ 上，其中 $k \\ge 3$ 是一个整数。\n顶点集是 $V = \\{u, v_1, v_2, \\dots, v_k\\}$，其中 $u$ 是中心顶点，$v_1, \\dots, v_k$ 是叶顶点。\n边集是 $E = \\{\\{u, v_i\\} \\mid i \\in \\{1, 2, \\dots, k\\}\\}$。\n权重函数由 $w(u) = 2$ 和对所有 $i \\in \\{1, \\dots, k\\}$ 的 $w(v_i) = 1$ 给出。\n\n首先，我们找出 $G_k$ 的最优加权顶点覆盖（WVC）的代价。顶点覆盖是顶点的一个子集 $C \\subseteq V$，使得每条边至少有一个端点在 $C$ 中。\n在星形图中，一个极小顶点覆盖有两个主要候选者：\n$1$. 只包含中心顶点的集合，$C_1 = \\{u\\}$。这个集合覆盖了所有的边 $\\{u, v_i\\}$，因为 $u$ 是每条边的一个端点。这个覆盖的代价是 $\\text{cost}(C_1) = w(u) = 2$。\n$2$. 包含所有叶顶点的集合，$C_2 = \\{v_1, v_2, \\dots, v_k\\}$。对于每条边 $\\{u, v_i\\}$，顶点 $v_i$ 在 $C_2$ 中，所以所有的边都被覆盖。这个覆盖的代价是 $\\text{cost}(C_2) = \\sum_{i=1}^{k} w(v_i) = \\sum_{i=1}^{k} 1 = k$。\n\n任何其他的顶点覆盖都必须是这两个极小覆盖之一的超集。例如，如果一个覆盖 $C$ 不包含 $u$，那么为了覆盖所有的边，它必须包含所有的 $v_i$，这意味着 $C_2 \\subseteq C$。如果一个覆盖 $C$ 包含 $u$，那么它是 $C_1$ 的超集。因此，最优（最小代价）顶点覆盖必须是 $C_1$ 或 $C_2$。\n\n最优WVC的代价，记为 $C_{OPT}$，是这两个覆盖代价的最小值：\n$\\text{cost}(C_{OPT}) = \\min(\\text{cost}(C_1), \\text{cost}(C_2)) = \\min(2, k)$。\n问题指定 $k \\ge 3$。由于 $k \\ge 3$，因此 $k > 2$。所以，最小代价是 $2$。\n在 $G_k$ 上，WVC 的最优代价是 $2$，由顶点覆盖 $\\{u\\}$ 实现。\n\n接下来，我们在 $G_k$ 上运行算法“Cheaper-From-Matching”，找出它产生的顶点覆盖，我们将其记为 $C'$。\n算法执行如下：\n步骤 1：计算一个极大匹配 $M$。问题陈述中选择的匹配是 $M = \\{\\{u, v_1\\}\\}$。这是一个极大匹配，因为顶点 $u$ 是 $G_k$ 中所有边的端点，所以一旦 $u$ 在 $\\{u, v_1\\}$ 中被匹配，就不能再向匹配中添加任何其他边。\n\n步骤 2：覆盖集被初始化：$C' \\leftarrow \\varnothing$。\n\n步骤 3：对于 $M$ 中的每条边，将较便宜的端点添加到 $C'$。$M$ 中唯一的边是 $\\{u, v_1\\}$。我们比较其端点的权重：$w(u) = 2$ 和 $w(v_1) = 1$。较便宜的端点是 $v_1$。所以，我们将 $v_1$ 添加到覆盖中。\n$C' \\leftarrow \\{v_1\\}$。\n\n步骤 4：此步骤只要存在未覆盖的边就进行迭代。如果 $\\{x,y\\} \\cap C' = \\varnothing$，则边 $\\{x,y\\}$ 是未覆盖的。\n当前，$C' = \\{v_1\\}$。图的边是 $E = \\{\\{u,v_1\\}, \\{u,v_2\\}, \\dots, \\{u,v_k\\}\\}$。\n边 $\\{u, v_1\\}$ 是覆盖的，因为 $v_1 \\in C'$。\n边 $\\{u, v_2\\}, \\{u, v_3\\}, \\dots, \\{u, v_k\\}$ 是未覆盖的，因为 $u \\notin C'$ 且对于任何 $i \\in \\{2, \\dots, k\\}$，$v_i \\notin C'$。\n`while` 循环开始。\n- 在第一次迭代中，算法选择一条未覆盖的边，例如 $\\{u, v_2\\}$。它将较便宜的端点 $\\arg\\min\\{w(u), w(v_2)\\}$ 添加到 $C'$。由于 $w(u)=2$ 和 $w(v_2)=1$，顶点 $v_2$ 被添加。现在，$C' = \\{v_1, v_2\\}$。\n- 未覆盖的边集现在是 $\\{\\{u, v_3\\}, \\dots, \\{u, v_k\\}\\}$。\n- 循环继续。在下一次迭代中，它可能会选择 $\\{u, v_3\\}$。较便宜的端点是 $v_3$，所以它被添加到 $C'$。现在，$C' = \\{v_1, v_2, v_3\\}$。\n- 这个过程对所有剩余的未覆盖边 $\\{u, v_i\\}$（对于 $i \\in \\{4, \\dots, k\\}$）重复进行。每次，较便宜的顶点 $v_i$ 被添加到 $C'$。\n- 当所有边都被覆盖时，循环终止。这发生在顶点 $v_2, v_3, \\dots, v_k$ 全部被添加到 $C'$ 之后。\n\n步骤 5：算法输出最终集合 $C'$。\n算法产生的最终覆盖是 $C' = \\{v_1, v_2, \\dots, v_k\\}$。\n\n现在，我们计算算法产生的覆盖 $C'$ 的总权重：\n$\\text{cost}(C') = \\sum_{v \\in C'} w(v) = \\sum_{i=1}^{k} w(v_i) = \\sum_{i=1}^{k} 1 = k$。\n\n最后，我们计算近似比，即算法的代价与最优代价的比率。\n近似比 = $\\frac{\\text{cost}(C')}{\\text{cost}(C_{OPT})}$。\n我们发现 $\\text{cost}(C') = k$ 且 $\\text{cost}(C_{OPT}) = 2$。\n因此，近似比是 $\\frac{k}{2}$。\n这是一个关于 $k$ 的简化闭式表达式。", "answer": "$$\n\\boxed{\\frac{k}{2}}\n$$", "id": "3281692"}]}