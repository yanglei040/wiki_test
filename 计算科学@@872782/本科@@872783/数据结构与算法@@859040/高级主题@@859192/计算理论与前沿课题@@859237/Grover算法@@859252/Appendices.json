{"hands_on_practices": [{"introduction": "Grover 算法的威力始于一个被称为“神谕”（Oracle）的关键组件，它能“识别”并标记出我们要寻找的目标。这个练习旨在揭开神谕的神秘面纱，通过具体的例子展示如何将标记特定量子态（$|101\\rangle$）的抽象功能，转化为具体的数学算符和量子门电路 [@problem_id:1426367]。掌握神谕的构建是理解并实现 Grover 算法的第一步。", "problem": "在量子计算理论中，Grover 算法为搜索无结构数据库提供了显著的加速。该算法的一个关键组成部分是一个称为神谕（oracle）的“黑箱”算子 $U_f$，它用于识别所需的目标项。\n\n考虑一个 3 量子比特的量子寄存器。该系统的状态可以描述为一个 8 维复希尔伯特空间中的向量，该空间由计算基态 $\\{|000\\rangle, |001\\rangle, |010\\rangle, |011\\rangle, |100\\rangle, |101\\rangle, |110\\rangle, |111\\rangle\\}$ 张成，这些基态按其二进制到整数值的顺序排列。\n\n神谕算子 $U_f$ 作用于基态 $|x\\rangle$ 的规则为 $U_f|x\\rangle = (-1)^{f(x)}|x\\rangle$，其中 $f(x)$ 是一个布尔函数，当 $|x\\rangle$ 是我们正在寻找的标记态时，$f(x)=1$，否则 $f(x)=0$。\n\n对于本问题，我们正在寻找一个单一的标记项，即状态 $|\\omega\\rangle = |101\\rangle$。\n\n下列哪个表达式正确地表示了针对此特定搜索问题的神谕算子 $U_f$？选择所有适用项。\n\n在以下选项中：\n- $I$ 表示 $8 \\times 8$ 单位矩阵。\n- $X_k$ 表示作用于第 $k$ 个量子比特的泡利-X算子，其中量子比特从左到右索引为 0, 1, 2。例如，$X_1$ 是算子 $I_0 \\otimes X_1 \\otimes I_2$ 的简写。\n- $Z_k$ 表示作用于第 $k$ 个量子比特的泡利-Z算子。\n- $CCZ$ 表示受控-受控-Z门，它会翻转基态 $|111\\rangle$ 的符号，而保持所有其他计算基态不变。\n\nA. $I - 2 |101\\rangle\\langle 101|$\n\nB. $I - |101\\rangle\\langle 101|$\n\nC. $Z_0 \\otimes Z_2$\n\nD. $X_1 \\cdot CCZ \\cdot X_1$\n\nE. $8 \\times 8$ 对角矩阵 `diag(1, 1, 1, 1, 1, -1, 1, 1)`", "solution": "对于单一标记态 $|\\omega\\rangle=|101\\rangle$ 的神谕算子定义为 $U_{f}|x\\rangle=(-1)^{f(x)}|x\\rangle$，其中当且仅当 $|x\\rangle=|101\\rangle$ 时 $f(x)=1$，否则 $f(x)=0$。因此，$U_{f}$ 会翻转 $|101\\rangle$ 的符号，而保持所有其他计算基态不变。\n\n选项 A：考虑算子 $U=I-2|101\\rangle\\langle 101|$。这是一个关于与 $|101\\rangle$ 正交的超平面的反射。它会将任何向量在 $|101\\rangle$ 方向上的分量反向，而在该超平面内的分量保持不变。因此，$U|101\\rangle=-|101\\rangle$，而对于任何与 $|101\\rangle$ 正交的基态 $|x\\rangle$，有 $U|x\\rangle=|x\\rangle$。这与所需的作用相匹配。因此 A 是正确的。\n\n选项 B：考虑算子 $U=I-|101\\rangle\\langle 101|$。作用于 $|101\\rangle$ 得到\n$$\nU|101\\rangle=(I-|101\\rangle\\langle 101|)|101\\rangle=|101\\rangle-|101\\rangle=0,\n$$\n这不是幺正的，也没有实现相位翻转，而是将目标态投影掉。因此 B 是不正确的。\n\n选项 C：算子 $Z_{0}\\otimes I_{1} \\otimes Z_{2}$ 作用于基态 $|q_{0}q_{1}q_{2}\\rangle$ 时，会附加一个相位 $(-1)^{q_{0}+q_{2}}$。作用于 $|101\\rangle$ 上得到 $(-1)^{1+1}=(-1)^{2}=+1$，所以 $|101\\rangle$ 的相位没有被翻转。因此 C 是不正确的。\n\n选项 D：令 $U=X_{1}\\cdot CCZ\\cdot X_{1}$。$CCZ$ 门仅对 $|111\\rangle$ 施加一个 $-1$ 的相位。通过 $X_{1}$ 进行的相似变换（conjugation）意味着该门控操作的目标状态被改变。$U$ 作用于任意基态 $|q_0 q_1 q_2\\rangle$ 的过程是：首先 $X_1$ 将其变为 $|q_0 (q_1\\oplus 1) q_2\\rangle$，然后 $CCZ$ 检查新状态是否为 $|111\\rangle$ 并施加相位，最后 $X_1$ 将其变回原态。仅当 $|q_0 (q_1\\oplus 1) q_2\\rangle = |111\\rangle$ 时，才会施加 $-1$ 相位。这要求 $q_0=1$, $q_1\\oplus 1=1$, $q_2=1$，即 $(q_{0},q_{1},q_{2})=(1,0,1)$。因此，$U$ 翻转了 $|101\\rangle$ 的符号，而保持所有其他计算基态不变。因此 D 是正确的。\n\n选项 E：当计算基态按 $|000\\rangle,|001\\rangle,\\dots,|111\\rangle$ 的顺序排列时，对角矩阵\n$$\n\\mathrm{diag}(1,1,1,1,1,-1,1,1)\n$$\n表示一个算子，该算子将第六个基态（即 $|101\\rangle$）乘以 $-1$，而将所有其他基态乘以 $+1$。这与神谕算子的作用完全匹配。因此 E 是正确的。\n\n综上所述，正确的选项是 A、D 和 E。", "answer": "$$\\boxed{ADE}$$", "id": "1426367"}, {"introduction": "识别目标后，Grover 算法通过一系列“振幅放大”迭代来提高找到目标的概率。这个过程可以被直观地理解为在希尔伯特空间中的一次次旋转。本练习通过一个精巧的特例——当目标解占总数的四分之一（$M=N/4$）时——来探索最佳迭代次数 [@problem_id:1426374]。你会发现，在这种理想情况下，仅需一次迭代就能百分之百地锁定目标，这为我们提供了关于算法几何本质的深刻洞见。", "problem": "一位量子计算研究员的任务是搜索一个包含总共 $N$ 个项目的大型非结构化数据库。其目标是识别具有特定属性的项目，我们称之为“标记”项目。该研究员使用Grover量子搜索算法来完成此任务。\n\n根据数据库的规范可知，标记项目的数量 $M$ 正好是项目总数的四分之一，即 $M = N/4$。该算法始于系统处于所有可能状态的均匀叠加态。然后，单次Grover迭代会对系统状态施加一个特定的幺正变换。\n\n假设量子计算机在没有任何错误的情况下运行，确定所需的最小非负整数Grover迭代次数 $k_{opt}$，以在测量时最大化测得标记项目的概率。此外，计算这个最大成功概率 $P_{max}$。\n\n请以数对 $(k_{opt}, P_{max})$ 的形式给出您的答案。", "solution": "设 $N$ 为数据库项目的总数，$M$ 为标记项目的数量。在Grover算法中，动力学被限制在由标记状态和未标记状态的均匀叠加所张成的二维子空间内。用 $|s\\rangle$ 表示所有项目的均匀叠加态，并通过以下定义的角度 $\\theta$ 来参数化其与标记子空间的交叠：\n$$\n\\sin^{2}(\\theta)=\\frac{M}{N}.\n$$\n单次Grover迭代会在该平面内向标记子空间方向产生一个角度为 $2\\theta$ 的旋转。经过 $k$ 次Grover迭代后，状态与标记子空间的交叠幅度为\n$$\n\\sin\\big((2k+1)\\theta\\big),\n$$\n因此，经过 $k$ 次迭代后的成功概率为\n$$\nP_{k}=\\sin^{2}\\big((2k+1)\\theta\\big).\n$$\n给定 $M=\\frac{N}{4}$，我们有\n$$\n\\sin^{2}(\\theta)=\\frac{1}{4}\\quad\\Rightarrow\\quad \\sin(\\theta)=\\frac{1}{2}\\quad\\Rightarrow\\quad \\theta=\\arcsin\\!\\left(\\frac{1}{2}\\right)=\\frac{\\pi}{6}.\n$$\n因此，\n$$\nP_{k}=\\sin^{2}\\!\\left((2k+1)\\frac{\\pi}{6}\\right).\n$$\n为了在非负整数 $k$ 上最大化 $P_{k}$，注意到当参数等于 $\\frac{\\pi}{2}+m\\pi$（其中 $m$ 为整数）时，$\\sin^{2}(\\cdot)$ 达到其最大值 $1$。我们需要找到满足\n$$\n(2k+1)\\frac{\\pi}{6}=\\frac{\\pi}{2}\n$$\n的最小非负整数 $k$。求解 $k$ 可得：\n$$\n2k+1=3 \\implies 2k = 2 \\implies k=1.\n$$\n当 $k=1$ 时，成功概率为：\n$$\nP_{max}=\\sin^{2}\\!\\left((2(1)+1)\\frac{\\pi}{6}\\right)=\\sin^{2}\\!\\left(\\frac{3\\pi}{6}\\right)=\\sin^{2}\\!\\left(\\frac{\\pi}{2}\\right)=1.\n$$\n因此，最大化成功概率的最小非负整数Grover迭代次数为 $k_{\\text{opt}}=1$，最大成功概率为 $P_{\\max}=1$。", "answer": "$$\\boxed{\\begin{pmatrix} 1  1 \\end{pmatrix}}$$", "id": "1426374"}, {"introduction": "虽然 Grover 算法为无结构搜索提供了惊人的二次加速，但它并非解决所有搜索问题的万能钥匙。理解其适用边界与了解其能力同样重要。这个练习将挑战你对算法适用性的判断，通过比较 Grover 算法和经典算法（如二分查找）在处理*结构化*数据时的效率，来强调 Grover 算法的核心优势在于*无结构*搜索 [@problem_id:3237894]。这有助于培养批判性思维，让你在面对实际问题时能够选择最合适的工具。", "problem": "给定几个在不同数据访问模型上定义的搜索任务。每个任务都指定了数据库结构和允许的原始查询。无论是在经典计算还是量子计算中，单次原始查询都计为一个单位的成本，而非查询计算是免费的。量子访问是通过一个与 Grover 算法兼容的预言机（oracle）实现的，在适用时，该预言机会根据一个布尔谓词翻转与标记项对应的基态的相位。经典访问是通过每个任务指定的比较和检查原语实现的。选择所有最能说明经典比较类算法（如二分搜索）的渐近查询复杂度严格优于 Grover 算法的情况的任务。\n\nA. 数据库：一个包含 $N$ 个不同键的升序排序数组。任务：给定一个查询键 $x$，找到索引 $i$ 使得数组元素 $a_i$ 等于 $x$（如果存在）。经典访问：一个比较原语，输入索引 $i$ 时，返回 $\\{\\text{less}, \\text{equal}, \\text{greater}\\}$ 之一，以指示 $x$ 是小于、等于还是大于 $a_i$。量子访问：一个预言机，输入 $i$ 时，当且仅当 $a_i = x$ 时标记 $i$。\n\nB. 数据库：一个包含 $N$ 个项的未排序列表。任务：找到满足给定谓词 $P$ 的任意一项，该谓词可作为一个布尔函数使用。经典访问：检查一个项以评估 $P$。量子访问：一个预言机，它会精确标记那些第 $i$ 项满足谓词 $P$ 的索引 $i$。\n\nC. 数据库：一个包含 $N$ 个桶的哈希表，其中键是均匀随机存储的。任务：给定一个哈希值 $h$，找到某个存储的键，其哈希值等于 $h$。经典访问：计算一个被探测键的哈希值并与 $h$ 比较；桶的顺序是任意的。量子访问：一个预言机，它会标记哈希值等于 $h$ 的键的索引。\n\nD. 数据库：一个包含 $N$ 个不同键的旋转排序数组，即一个通过取一个严格递增数组并以一个未知的枢轴点旋转得到的数组，使得该数组保持分段递增且只有一个断点。任务：找到最小元素。经典访问：一个比较原语，输入索引 $i$ 和 $j$ 时，返回 $a_i  a_j$ 是否成立。量子访问：一个预言机，当且仅当 $a_i$ 是唯一的最小值时，它会标记索引 $i$。", "solution": "这个问题的核心是比较经典搜索算法与Grover量子搜索算法在不同数据结构上的查询复杂度。Grover算法为大小为 $N$ 的无结构搜索问题提供了 $O(\\sqrt{N})$ 的查询复杂度，这被证明是该类问题的最优解。然而，如果数据存在可利用的结构（如排序），经典算法可能通过利用该结构实现更优的性能。问题要求找出经典算法严格优于Grover算法的情况，即经典复杂度 $T_C(N)$ 满足 $T_C(N) = o(\\sqrt{N})$。\n\n**A. 排序数组搜索**\n- **经典算法**：数据是排序的，允许使用**二分搜索**。每次比较都可以将搜索空间减半，因此查询复杂度为 $T_C(N) = O(\\log N)$。\n- **Grover算法**：将搜索视为在 $N$ 个索引中寻找一个目标，这是一个无结构搜索问题，量子查询复杂度为 $T_Q(N) = O(\\sqrt{N})$。\n- **比较**：由于 $O(\\log N)$ 渐近地严格小于 $O(\\sqrt{N})$，经典算法在此任务中胜出。\n\n**B. 未排序列表搜索**\n- **经典算法**：数据是无结构的。必须进行**线性扫描**，最坏情况下的查询复杂度为 $T_C(N) = O(N)$。\n- **Grover算法**：这是Grover算法的理想应用场景，查询复杂度为 $T_Q(N) = O(\\sqrt{N})$。\n- **比较**：量子算法提供了二次加速，严格优于经典算法。\n\n**C. 哈希表逆向查找**\n- **经典算法**：任务是根据哈希值找到键，但由于桶的顺序是任意的，无法利用哈希表的结构进行直接查找。这退化为对所有键的**无结构搜索**，查询复杂度为 $T_C(N) = O(N)$。\n- **Grover算法**：同样是一个无结构搜索，查询复杂度为 $T_Q(N) = O(\\sqrt{N})$。\n- **比较**：量子算法严格优于经典算法。\n\n**D. 旋转排序数组搜索**\n- **经典算法**：数据具有分段排序的结构。可以通过一种**改进的二分搜索**来定位最小元素（即旋转的枢轴点）。每次比较同样能将搜索范围缩小，因此查询复杂度为 $T_C(N) = O(\\log N)$。\n- **Grover算法**：从量子角度看，这仍然是在 $N$ 个位置中寻找一个特定标记项（最小值），查询复杂度为 $T_Q(N) = O(\\sqrt{N})$。\n- **比较**：与情况A类似，由于 $O(\\log N)$ 严格优于 $O(\\sqrt{N})$，经典算法胜出。\n\n综上所述，任务 A 和 D 中的数据结构（排序数组和旋转排序数组）允许经典算法（如二分搜索及其变体）以 $O(\\log N)$ 的复杂度解决问题，这比Grover算法的 $O(\\sqrt{N})$ 复杂度要好得多。", "answer": "$$\\boxed{AD}$$", "id": "3237894"}]}