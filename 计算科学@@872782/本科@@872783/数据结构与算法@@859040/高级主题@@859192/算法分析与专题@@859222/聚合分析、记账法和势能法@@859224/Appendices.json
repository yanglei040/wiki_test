{"hands_on_practices": [{"introduction": "我们从聚合方法开始动手实践，这通常是理解摊销分析最直观的切入点。这个练习 [@problem_id:3204566] 提供了一个经典的场景：一个支持强大的 `MULTI-POP` 操作的栈。通过分析一个操作序列的总成本，我们将揭示为何一个看似昂贵的 `MULTI-POP` 操作在平均意义下是相当高效的，从而体会到摊销分析的核心思想。", "problem": "考虑一个遵循后进先出（LIFO）原则的栈抽象数据类型（ADT），它支持以下操作：一个 $PUSH(x)$ 操作，将元素 $x$ 放置到栈顶；以及一个 $MULTI\\text{-}POP(k)$ 操作，它重复应用基本 $POP$ 操作最多 $k$ 次，或直到栈变为空，以先发生者为准。假设栈初始为空。采用以下单位成本模型：每个 $PUSH$ 的实际成本为 $1$，每个成功的基本 $POP$ 的实际成本为 $1$；$MULTI\\text{-}POP(k)$ 的实际成本是它执行的成功基本 $POP$ 操作的次数。给定一个操作序列，该序列由恰好 $n^{2}$ 次 $PUSH$ 和恰好 $n$ 次 $MULTI\\text{-}POP(n)$ 以任意交错方式组成。\n\n使用摊还分析的聚合方法，从栈的核心定义和所述成本模型出发，推导出整个序列的最坏情况下的总实际成本，作为 $n$ 的函数。您的答案必须是关于 $n$ 的单个封闭形式表达式。最终表达式无需四舍五入，也不应包含任何单位。", "solution": "该问题被评估为有效，因为它在科学上基于计算机科学的原理，特别是算法和数据结构分析。问题是适定的，所有必要的条件、定义和约束都已明确说明。语言客观、正式。\n\n任务是使用聚合方法，为一个由 $n^2$ 次 `PUSH` 操作和 $n$ 次 `MULTI-POP(n)` 操作组成的 $n^2 + n$ 次操作序列，找出其最坏情况下的总实际成本。\n\n设 $C_{total}$ 为整个操作序列的总实际成本。总成本是序列中所有单个操作的实际成本之和。\n$$\nC_{total} = \\sum_{i=1}^{n^2+n} c_i\n$$\n其中 $c_i$ 是序列中第 $i$ 个操作的实际成本。\n\n该序列包含两种类型的操作：`PUSH` 和 `MULTI-POP`。我们可以将总成本分解为所有 `PUSH` 操作的成本之和（称之为 $C_{PUSH}$）以及所有 `MULTI-POP` 操作的成本之和（$C_{MULTI\\text{-}POP}$）。\n$$\nC_{total} = C_{PUSH} + C_{MULTI\\text{-}POP}\n$$\n\n首先，我们分析由 `PUSH` 操作贡献的成本。\n问题陈述中说明有恰好 $n^2$ 次 `PUSH` 操作。\n每个 `PUSH` 操作的实际成本定义为 $1$。\n因此，所有 `PUSH` 操作的总成本是固定的，无论它们在序列中的位置如何：\n$$\nC_{PUSH} = n^2 \\times 1 = n^2\n$$\n\n接下来，我们分析由 `MULTI-POP` 操作贡献的成本。\n有 $n$ 次 `MULTI-POP(n)` 操作。\n一个 `MULTI-POP(k)` 操作的实际成本定义为它执行的成功基本 `POP` 操作的次数。如果一个基本 `POP` 从非空栈中移除了一个元素，则该 `POP` 是成功的。\n栈的核心原则是，一个元素只有在之前被压入栈后才能被弹出。由于栈初始为空，每个被弹出的元素都必须对应于序列中较早发生的一次唯一的 `PUSH` 操作。每个被压入的元素最多只能被弹出一次。\n\n这个基本关系为聚合分析提供了一个关键的界限。整个操作序列中成功的基本 `POP` 的总数不能超过执行的 `PUSH` 操作的总数。\n设 $N_{pop}$ 为序列中成功的基本 `POP` 的总数，设 $N_{push}$ 为 `PUSH` 操作的总数。\n我们有：\n$$\nN_{pop} \\le N_{push}\n$$\n在这个问题中，$N_{push} = n^2$。\n所有 `MULTI-POP` 操作的总成本 $C_{MULTI\\text{-}POP}$ 等于成功的基本 `POP` 的总数 $N_{pop}$。\n因此，我们得到了该部分成本的一个上界：\n$$\nC_{MULTI\\text{-}POP} = N_{pop} \\le n^2\n$$\n\n现在，我们可以为任何可能的给定操作交错方式下的总实际成本 $C_{total}$ 建立一个上界。\n$$\nC_{total} = C_{PUSH} + C_{MULTI\\text{-}POP} \\le n^2 + n^2 = 2n^2\n$$\n\n为了确定这个上界是否代表了确切的最坏情况下的总实际成本，我们必须证明存在至少一个操作序列能够达到这个成本。如果我们能构造出这样一个序列，那么 $2n^2$ 确实就是最坏情况成本。\n\n考虑以下序列，这是其中一种可能的任意交错方式：\n1.  首先，连续执行所有 $n^2$ 次 `PUSH` 操作。\n2.  然后，连续执行所有 $n$ 次 `MULTI-POP(n)` 操作。\n\n我们来计算这个特定序列的总成本，假设 $n \\ge 1$。$n=0$ 的情况是平凡的，导致 $0$ 次操作和 $0$ 成本，这与 $2(0)^2=0$ 相匹配。\n-   **`PUSH` 阶段的成本：** 有 $n^2$ 次 `PUSH` 操作，每次成本为 $1$。此阶段的总成本为 $n^2 \\times 1 = n^2$。此阶段后，栈中包含 $n^2$ 个元素。\n\n-   **`MULTI-POP` 阶段的成本：** 此阶段包含 $n$ 次对 `MULTI-POP(n)` 的调用。\n    -   在第 1 次调用 `MULTI-POP(n)` 时，栈中包含 $n^2$ 个元素。由于 $n \\le n^2$（对于 $n \\ge 1$），该操作成功弹出 $n$ 个元素。其成本为 $n$。栈现在包含 $n^2 - n$ 个元素。\n    -   在第 2 次调用 `MULTI-POP(n)` 时，栈中包含 $n^2 - n$ 个元素。由于 $n \\le n^2 - n$（对于 $n \\ge 2$），该操作成功弹出 $n$ 个元素。其成本为 $n$。栈现在包含 $n^2 - 2n$ 个元素。\n    -   一般地，在第 $i$ 次调用 `MULTI-POP(n)` 时（其中 $1 \\le i \\le n$），栈中包含 $n^2 - (i-1)n$ 个元素。为使操作能弹出 $n$ 个元素，栈的大小必须至少为 $n$。我们检查这个条件：\n        $$\n        n^2 - (i-1)n = n(n - (i-1)) = n(n - i + 1)\n        $$\n        由于 $i \\le n$，我们有 $n-i \\ge 0$，这意味着 $n-i+1 \\ge 1$。因此，栈的大小 $n(n-i+1)$ 总是大于或等于 $n$。\n    -   这证明了 $n$ 次 `MULTI-POP(n)` 调用中的每一次都将完全成功，恰好弹出 $n$ 个元素。\n    -   $n$ 次 `MULTI-POP(n)` 操作中每次的成本都是 $n$。\n    -   此阶段的总成本为 $n \\times (\\text{每次调用的成本}) = n \\times n = n^2$。\n\n这个特定的最坏情况序列的总实际成本是两个阶段成本的总和：\n$$\nC_{total, worst} = (\\text{PUSH 操作的成本}) + (\\text{MULTI-POP 操作的成本}) = n^2 + n^2 = 2n^2\n$$\n\n由于我们已经为任何序列的总成本建立了一个 $2n^2$ 的上界，并且构造了一个达到该成本的特定序列，我们得出结论，整个序列的确切最坏情况下的总实际成本是 $2n^2$。这完成了使用聚合方法的推导。", "answer": "$$\n\\boxed{2n^{2}}\n$$", "id": "3204566"}, {"introduction": "在掌握了聚合方法后，我们转向一种更精巧的工具：势能法。势能法引入了一个“势函数”来追踪预先储存的“功”，就像物理学家使用势能概念一样，这使得分析更为形式化和强大。这个关于标准二进制计数器的练习 [@problem_id:3204641] 是学习该方法的理想案例，它将引导我们推导出一个出人意料地简洁而精确的总成本公式。", "problem": "一个二进制计数器以二进制（基为 $2$）形式存储非负整数，其中最低有效位在位置 $0$。对于从状态 $i$ 到状态 $i+1$ 的每一次增量操作，我们将操作的实际成本定义为 $i$ 和 $i+1$ 的二进制表示之间值发生变化的位数。此成本即为 $i$ 和 $i+1$ 之间的汉明距离，其中汉明距离是两个等长字符串在对应位置上字符不同的数量。\n\n从计数器状态 $0$ 开始，对于一个固定的正整数 $m$，连续执行 $m$ 次增量操作。设 $\\mathcal{C}(m)$ 为这 $m$ 次增量操作累积的总实际成本。请从第一性原理出发，使用聚合方法、记账方法或势能方法中的任意一种，推导出一个关于 $\\mathcal{C}(m)$ 的精确闭式表达式，该表达式仅含 $m$ 项，且不含求和符号。你可以使用函数符号 $s_{2}(m)$ 来表示 $m$ 的二进制表示中 1 的数量。\n\n你的最终答案必须是 $\\mathcal{C}(m)$ 的单个闭式解析表达式，答案中不得包含不等式或方程式。无需进行四舍五入。", "solution": "该问题是有效的，因为它是算法分析中的一个标准的、适定性良好的问题。它在数学和计算机科学上具有科学依据，表述规范且客观。我们将使用摊销分析中的势能方法来推导总成本 $\\mathcal{C}(m)$ 的闭式表达式。\n\n设经过 $i$ 次增量操作后二进制计数器的状态由整数 $i$ 表示。初始状态为 $0$。我们执行 $m$ 次增量操作序列，使计数器经历状态 $0, 1, 2, \\dots, m$。\n\n设 $c_k$ 为第 $k$ 次增量操作的实际成本，该操作使计数器从状态 $k-1$ 转换到状态 $k$。问题将此成本定义为在此转换过程中翻转的位数。$m$ 次增量操作的总实际成本为 $\\mathcal{C}(m) = \\sum_{k=1}^{m} c_k$。\n\n为应用势能方法，我们定义一个势函数 $\\Phi$，它将数据结构的状态映射到一个实数。对于处于状态 $i$ 的计数器，一个合适的势函数选择，我们称之为 $\\Phi(i)$，是 $i$ 的二进制表示中 1 的数量。我们使用问题中的符号 $s_2(i)$ 来表示这个量。\n$$\n\\Phi(i) = s_2(i)\n$$\n为使势能方法有效，对于所有状态 $i$，必须满足 $\\Phi(i) \\ge \\Phi(0)$。初始状态为 $0$，且 $\\Phi(0) = s_2(0) = 0$。由于任何非负整数的二进制表示中 1 的数量都是非负的，因此对于所有 $i \\ge 0$，都有 $s_2(i) \\ge 0$。于是，条件 $\\Phi(i) \\ge \\Phi(0)$ 得以满足。\n\n第 $k$ 次操作的摊销成本 $a_k$ 定义为实际成本加上势能的变化：\n$$\na_k = c_k + \\Phi(k) - \\Phi(k-1)\n$$\n我们来分析第 $k$ 次增量操作（从状态 $k-1$ 到 $k$）中计数器的变化。假设 $k-1$ 的二进制表示有 $j$ 个后缀 1。也就是说，其二进制形式为 $\\dots p_j 0 1 \\dots 1$，其中末尾有一个由 $j$ 个 1 组成的连续块，其前面是一个 0。\n增量操作会将这 $j$ 个 1 翻转为 0，并将最右边的 0（在位置 $j$）翻转为 1。位置 $j$ 左側的所有位保持不变。\n此操作中位的翻转次数为 $j$（对于 $1 \\to 0$ 的翻转）加上 $1$（对于 $0 \\to 1$ 的翻转）。因此，实际成本为：\n$$\nc_k = j+1\n$$\n这也涵盖了 $k-1$ 为偶数的情况，即其二进制表示以 $0$ 结尾。在这种情况下，$j=0$，只有最后一位从 $0$ 翻转为 $1$，所以 $c_k=1$，与公式相符。\n\n现在，我们来评估势能的变化，$\\Phi(k) - \\Phi(k-1) = s_2(k) - s_2(k-1)$。\n状态 $k-1$ 中 1 的数量可以用高于位置 $j$ 的位中 1 的数量（我们称之为 $N$）和 $j$ 个后缀 1 来表示。所以，$s_2(k-1) = N+j$。\n在状态 $k$，$j$ 个后缀 1 已变为 0，而位置 $j$ 处的 0 已变为 1。更高阶的位保持不变。因此，状态 $k$ 中 1 的数量为 $s_2(k) = N+1$。\n1 的数量变化为：\n$$\ns_2(k) - s_2(k-1) = (N+1) - (N+j) = 1-j\n$$\n这给了我们势能的变化：$\\Delta\\Phi_k = \\Phi(k) - \\Phi(k-1) = 1-j$。\n\n现在我们可以计算摊销成本 $a_k$：\n$$\na_k = c_k + \\Delta\\Phi_k = (j+1) + (1-j) = 2\n$$\n每次增量操作的摊销成本是一个常数，$2$。\n\n总实际成本 $\\mathcal{C}(m)$ 与总摊销成本通过摊销分析的基本定理相关联：\n$$\n\\sum_{k=1}^{m} c_k = \\sum_{k=1}^{m} a_k - (\\Phi(m) - \\Phi(0))\n$$\n代入已知量：\n$$\n\\mathcal{C}(m) = \\sum_{k=1}^{m} 2 - (s_2(m) - s_2(0))\n$$\n常数摊销成本的总和是 $\\sum_{k=1}^{m} 2 = 2m$。初始状态的势为 $\\Phi(0) = s_2(0) = 0$。最终状态的势为 $\\Phi(m) = s_2(m)$。\n代入这些值，我们得到总实际成本的表达式：\n$$\n\\mathcal{C}(m) = 2m - (s_2(m) - 0)\n$$\n$$\n\\mathcal{C}(m) = 2m - s_2(m)\n$$\n这就是从 $0$ 开始对一个二进制计数器连续进行 $m$ 次增量操作期间发生的位翻转总次数的精确闭式表达式。该表达式由项 $2m$ 和一个修正项组成，该修正项是最终状态 $m$ 中 1 的数量。", "answer": "$$\\boxed{2m - s_{2}(m)}$$", "id": "3204641"}, {"introduction": "掌握了基础知识后，让我们用一个更具挑战性的变体来检验我们的理解。如果操作的成本不再是统一的，分析会如何改变？这个练习 [@problem_id:3204622] 修改了二进制计数器的成本模型，要求我们从第一性原理出发，为这个非标准模型量身打造一个新的势函数。这个过程将展示摊销分析在处理复杂问题时的真正威力与灵活性。", "problem": "给定一个无限二进制计数器，其位由非负整数索引，第 $i$ 位的权重为 $2^{i}$，第 $0$ 位是最低有效位 (LSB)。计数器从全零状态开始。一次增量操作将计数器加 $1$，这会把末尾连续的 $1$ 位（如果有的话）翻转为 $0$，然后将下一个更高位的 $0$ 翻转为 $1$。实际成本模型如下：翻转第 $i$ 位产生的成本为 $i+1$。因此，一次增量操作的实际成本是该次增量中所有被翻转的位 $i$ 的 $i+1$ 之和。考虑从全零状态开始的任意 $m$ 次增量序列，假设没有溢出（即计数器有足够多的位，使得所有 $m$ 次增量都是可行的）。\n\n请仅从二进制增量的形式化语义和上述成本模型出发，完成以下任务：\n- 使用聚合方法，通过计算每个位 $i$ 在前 $m$ 次增量中翻转了多少次并对这些贡献求和，推导出 $m$ 次增量总成本 $C(m)$ 的一个闭式上界。你的推导必须从第一性原理出发，并且只能使用基本的级数知识。\n- 使用核算法，提出一个每次增量操作的固定摊销费用 $c$ 和一个信用不变式。该信用不变式根据位 $i$ 当前是 $1$ 还是 $0$ 来为它分配一个非负数量的存储信用。该不变式需满足：对于每次增量操作，从翻转为 $0$ 的位中释放的信用与收取的费用 $c$ 一起，足以支付该次增量的实际成本并重新建立不变式。证明该方案对从零状态开始的所有 $m$ 都有效，并确定使之可行的最小常数 $c$。\n- 使用势能法，定义一个仅取决于当前位模式的势函数 $\\Phi$，并证明每次增量操作的摊销成本（定义为实际成本加上势能的变化）精确地等于你在核算法中找到的同一个常数 $c$，且对每一次增量操作都成立，无论 $m$ 是多少。\n- 最后，使用你的聚合分析来计算 $\\lim_{m \\to \\infty} \\frac{C(m)}{m}$，并论证你得到的常数 $c$ 是紧的。\n\n报告最小常数 $c$ 作为你的最终答案。不需要四舍五入，也不涉及单位。最终答案必须是一个实数。", "solution": "该问题要求在一个非标准成本模型下对二进制计数器的增量操作进行摊销分析。我们需要使用聚合方法、核算法和势能法来找到并证明一个 $m$ 次增量序列的最紧的常数摊销成本。\n\n首先，我们确定成本模型和操作动态。一个二进制计数器从 $0$ 开始。一次增量操作加 $1$。这会导致末尾连续的一串 $1$ 翻转为 $0$，并且下一个 $0$ 翻转为 $1$。翻转第 $i$ 位的成本定义为 $i+1$。一次增量的实际成本是所有被翻转位的成本之和。\n\n**1. 聚合方法**\n\n聚合方法计算一个包含 $m$ 次操作序列的总实际成本 $C(m)$，然后确定每次操作的平均成本，即 $C(m)/m$。\n\n为了求 $C(m)$，我们对 $m$ 次增量过程中的所有位翻转成本进行求和。我们可以按位来求和，而不是按增量操作来求和。总成本为 $C(m) = \\sum_{i=0}^{\\infty} (\\text{翻转第 } i \\text{ 位的成本}) \\times (\\text{第 } i \\text{ 位在 } m \\text{ 次增量中翻转的次数})$。\n\n翻转第 $i$ 位的成本给定为 $i+1$。\n当计数器从一个值 $v$ 变到 $v+1$ 时，如果 $v$ 和 $v+1$ 的二进制表示在第 $i$ 位上不同，则第 $i$ 位会翻转。这种情况精确地发生在加 $1$ 操作引起的进位传播到第 $i$ 位时。当且仅当增量操作之前，第 $0, 1, \\dots, i-1$ 位全为 $1$ 时，第 $i$ 位才会从 $0$ 翻转为 $1$ 或从 $1$ 翻转为 $0$。这发生在计数器值为 $k \\cdot 2^i + (2^i - 1)$（对于任意整数 $k \\ge 0$）的形式时。增量操作将值变为 $(k+1) \\cdot 2^i$。因此，如果第 $j$ 次增量操作的 $j$ 是 $2^i$ 的倍数，那么第 $i$ 位就会翻转。\n\n在一个包含 $m$ 次增量的序列中（从值 $0$ 到 $m-1$，最终计数器值为 $m$），第 $i$ 位在第 $1 \\cdot 2^i, 2 \\cdot 2^i, 3 \\cdot 2^i, \\dots, \\lfloor m/2^i \\rfloor \\cdot 2^i$ 次增量时翻转。第 $i$ 位翻转的次数恰好是 $\\lfloor m/2^i \\rfloor$ 次。\n\n总成本 $C(m)$ 是对所有位 $i$ 的求和：\n$$C(m) = \\sum_{i=0}^{\\infty} (i+1) \\left\\lfloor \\frac{m}{2^i} \\right\\rfloor$$\n这个和是有限的，因为当 $2^i  m$ 时，$\\lfloor m/2^i \\rfloor$ 项为 $0$。\n\n为了找到一个闭式上界，我们使用不等式 $\\lfloor x \\rfloor \\le x$：\n$$C(m) \\le \\sum_{i=0}^{\\infty} (i+1) \\frac{m}{2^i} = m \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i}$$\n该求和是一个算术-几何级数。设 $S = \\sum_{k=0}^{\\infty} (k+1)x^k$。这个级数是一个相关几何级数的导数。我们知道对于 $|x|1$，$\\sum_{k=0}^{\\infty} x^k = \\frac{1}{1-x}$。对 $x$ 求导得到 $\\sum_{k=1}^{\\infty} kx^{k-1} = \\frac{1}{(1-x)^2}$。令 $i=k-1$，则有 $\\sum_{i=0}^{\\infty} (i+1)x^i = \\frac{1}{(1-x)^2}$。\n对于我们的求和，$x=1/2$，所以：\n$$S = \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i} = \\frac{1}{(1-1/2)^2} = \\frac{1}{(1/4)} = 4$$\n因此，总成本的上界为：\n$$C(m) \\le 4m$$\n这表明每次操作的摊销成本为 $4$。\n\n**2. 核算法**\n\n在核算法中，我们为每次操作收取一个固定的摊销成本 $c$。这笔费用的一部分用于支付即时的实际成本，其余部分作为“信用”存储在数据结构上。这些信用可以在以后用于支付昂贵的操作。总信用绝不能为负。\n\n基于我们的聚合分析，我们提议摊销费用为 $c=4$。我们需要定义一个信用不变式。一个常见的策略是在被置为 $1$ 的位上存储信用。我们定义信用不变式如下：\n*如果第 $i$ 位是 $1$，它存储 $\\phi_i$ 的信用。*\n*如果第 $i$ 位是 $0$，它存储 $0$ 的信用。*\n\n我们需要确定函数 $\\phi_i$。初始状态是全零，所以总信用为 $0$。\n考虑一次增量操作，它将第 $0, 1, \\dots, k-1$ 位从 $1$ 翻转为 $0$，并将第 $k$ 位从 $0$ 翻转为 $1$。\n这次操作的实际成本是 $A_k = (\\sum_{i=0}^{k-1} (i+1)) + (k+1) = \\frac{k(k+1)}{2} + (k+1) = \\frac{(k+1)(k+2)}{2}$。\n为了支付这次操作的费用，我们使用收取的费用 $c$ 以及从 $1$ 翻转为 $0$ 的位释放的任何信用。\n释放的信用：$\\sum_{i=0}^{k-1} \\phi_i$。\n操作之后，我们必须通过在现在为 $1$ 的第 $k$ 位上存储信用，来重新建立不变式。\n需要存储的信用：$\\phi_k$。\n\n核算法的基本不等式是：\n摊销费用 + 释放的信用 $\\ge$ 实际成本 + 存储的信用\n$$c + \\sum_{i=0}^{k-1} \\phi_i \\ge \\frac{(k+1)(k+2)}{2} + \\phi_k$$\n我们需要找到一个非负函数 $\\phi_i$，使得对于 $c=4$ 和所有 $k \\ge 0$，这个不等式都成立。我们尝试通过将其设为等式来找到 $\\phi_i$：\n$$4 = \\frac{(k+1)(k+2)}{2} + \\phi_k - \\sum_{i=0}^{k-1} \\phi_i$$\n让我们测试一个简单的线性函数，比如 $\\phi_i = i+B$。\n$$4 = \\frac{k^2+3k+2}{2} + (k+B) - \\sum_{i=0}^{k-1} (i+B)$$\n$$4 = \\frac{k^2+3k+2}{2} + k+B - \\left(\\frac{(k-1)k}{2} + Bk\\right)$$\n$$8 = k^2+3k+2 + 2k+2B - k^2+k - 2Bk$$\n$$8 = 6k+2+2B(1-k)$$\n这个方程依赖于 $k$，所以 $\\phi_i=i+B$ 是不正确的。\n\n让我们从第一性原理推导 $\\phi_i$。在 $m$ 次增量后，总成本为 $C(m) = \\sum_{j=1}^m (\\text{摊销成本}_j - \\Delta \\Phi_j) = mc - (\\Phi_m - \\Phi_0)$。当 $\\Phi_0=0$ 时，$C(m)=mc - \\Phi_m$。根据聚合方法，$C(m) = \\sum_{i=0}^\\infty (i+1)\\lfloor m/2^i \\rfloor$。我们设置 $mc - \\Phi_m \\ge C(m)_{exact}$。我们需要 $\\Phi_m\\le mc-C(m) = m \\sum \\frac{i+1}{2^i} - \\sum(i+1)\\lfloor \\frac{m}{2^i} \\rfloor = \\sum (i+1)(m/2^i - \\lfloor m/2^i \\rfloor) = \\sum(i+1)\\{m/2^i\\}$。我们知道 $\\{m/2^i\\} = \\sum_{j=0}^{i-1} b_j 2^{j-i}$，其中 $b_j$ 是 $m$ 的第 $j$ 位。 $\\Phi_m = \\sum_j b_j \\phi_j \\le \\sum_i (i+1) \\sum_{j=0}^{i-1} b_j 2^{j-i} = \\sum_j b_j (\\sum_{i=j+1}^\\infty (i+1)2^{j-i})$。如果我们设置 $\\phi_j = \\sum_{i=j+1}^{\\infty} (i+1)2^{j-i} = 2^j \\sum_{i=j+1}^{\\infty} \\frac{i+1}{2^i}$，该条件就满足。该求和为 $S - S_j = 4 - (4 - \\frac{j+3}{2^j}) = \\frac{j+3}{2^j}$。所以，$\\phi_j = 2^j (\\frac{j+3}{2^j}) = j+3$。\n我们的信用不变式是：一个被置为 $1$ 的位 $i$ 存储 $\\phi_i = i+3$ 的信用。\n让我们为 $c=4$ 验证这一点。\n$$4 + \\sum_{i=0}^{k-1} (i+3) \\ge \\frac{(k+1)(k+2)}{2} + (k+3)$$\n$$4 + \\frac{(k-1)k}{2} + 3k \\ge \\frac{k^2+3k+2}{2} + k+3$$\n$$4 + \\frac{k^2-k+6k}{2} \\ge \\frac{k^2+3k+2+2k+6}{2}$$\n$$4 + \\frac{k^2+5k}{2} \\ge \\frac{k^2+5k+8}{2}$$\n$$\\frac{8+k^2+5k}{2} \\ge \\frac{k^2+5k+8}{2}$$\n这是一个等式，所以它成立。对于任何增量操作，费用 $c=4$ 恰好足够支付实际成本并维持信用不变式。因此，最小常数费用为 $c=4$。\n\n**3. 势能法**\n\n势能法定义一个势函数 $\\Phi$，它将数据结构的状态映射到一个非负实数，且初始状态的 $\\Phi=0$。一次操作的摊销成本 $c_a$ 是其真实成本 $c_{act}$ 加上势能的变化，即 $c_a = c_{act} + \\Delta\\Phi$。\n\n我们使用核算法中的信用函数来定义我们的势函数。让计数器的状态由值为 $1$ 的位的索引集合 $S$ 来定义。\n$$\\Phi(S) = \\sum_{i \\in S} (i+3)$$\n初始状态是全零，所以 $S=\\emptyset$ 且 $\\Phi(\\emptyset)=0$。因为 $i \\ge 0$，所以对于所有状态 $\\Phi(S) \\ge 0$。\n\n考虑一次增量操作，它将第 $0, 1, \\dots, k-1$ 位从 $1$ 翻转为 $0$，并将第 $k$ 位从 $0$ 翻转为 $1$。\n之前的状态是 $S_{old} = \\{0, 1, \\dots, k-1\\} \\cup S'$，其中 $S'$ 表示大于 $k$ 的值为 $1$ 的位。\n之后的状态是 $S_{new} = \\{k\\} \\cup S'$。\n实际成本是 $c_{act} = \\frac{(k+1)(k+2)}{2}$。\n势能的变化是 $\\Delta\\Phi = \\Phi(S_{new}) - \\Phi(S_{old})$。\n$\\Phi(S_{new}) = (k+3) + \\sum_{i \\in S'} (i+3)$。\n$\\Phi(S_{old}) = \\sum_{i=0}^{k-1} (i+3) + \\sum_{i \\in S'} (i+3)$。\n$\\Delta\\Phi = (k+3) - \\sum_{i=0}^{k-1} (i+3) = (k+3) - \\left(\\frac{(k-1)k}{2} + 3k\\right) = k+3 - \\frac{k^2-k+6k}{2} = \\frac{2k+6 - k^2-5k}{2} = \\frac{-k^2-3k+6}{2}$。\n摊销成本是：\n$$c_a = c_{act} + \\Delta\\Phi = \\frac{k^2+3k+2}{2} + \\frac{-k^2-3k+6}{2} = \\frac{8}{2} = 4$$\n每次增量操作的摊销成本都恰好是 $4$，无论计数器的状态如何。这证实了 $c=4$ 是一个有效的常数摊销成本。\n\n**4. 渐近分析与紧密性**\n\n常数 $c=4$ 是平均成本的一个上界。要证明它是紧的，我们必须证明每次操作的平均成本可以任意接近于 $4$。我们可以通过分析当操作次数 $m$ 趋于无穷大时的平均成本来做到这一点。\n\n$m$ 次增量后的平均成本是 $\\frac{C(m)}{m}$。使用聚合分析中的公式：\n$$\\frac{C(m)}{m} = \\frac{1}{m} \\sum_{i=0}^{\\infty} (i+1) \\left\\lfloor \\frac{m}{2^i} \\right\\rfloor = \\sum_{i=0}^{\\infty} (i+1) \\frac{\\lfloor m/2^i \\rfloor}{m}$$\n当 $m \\to \\infty$时，$\\frac{\\lfloor m/2^i \\rfloor}{m}$ 项趋近于 $\\frac{m/2^i}{m} = \\frac{1}{2^i}$。所以我们可以求极限：\n$$\\lim_{m\\to\\infty} \\frac{C(m)}{m} = \\lim_{m\\to\\infty} \\sum_{i=0}^{\\infty} (i+1) \\frac{\\lfloor m/2^i \\rfloor}{m} = \\sum_{i=0}^{\\infty} (i+1) \\lim_{m\\to\\infty} \\frac{\\lfloor m/2^i \\rfloor}{m}$$\n（交换极限和求和的顺序是合理的，这可由控制收敛定理证明，因为各项被一个绝对收敛的级数 $(i+1)/2^i$ 所界定。）\n$$\\lim_{m\\to\\infty} \\frac{C(m)}{m} = \\sum_{i=0}^{\\infty} \\frac{i+1}{2^i} = 4$$\n由于每次操作的平均成本趋近于 $4$，任何小于 $4$ 的常数摊销成本都不可能对所有的 $m$ 有效。如果我们选择一个 $c'  4$，那么对于一个足够大的 $m$，总支付 $m c'$ 将会小于总实际成本 $C(m) \\approx 4m$，这违反了摊销成本的定义。\n因此，常数 $c=4$ 是最小可能值，即，它是紧的。\n\n总之，所有三种摊销分析方法都一致地指向最小常数摊销成本为 $4$。", "answer": "$$\\boxed{4}$$", "id": "3204622"}]}