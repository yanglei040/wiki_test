{"hands_on_practices": [{"introduction": "记账法是摊还分析中一种直观的方法，其核心思想是为未来的昂贵操作“预存费用”。本练习要求我们从一个固定的付费方案（每次追加操作支付3个单位成本）出发，反向推导出一个动态数组要支持该方案而不出现“赤字”，其容量增长因子 $\\alpha$ 最小需要是多少。这个练习将帮助你理解摊还成本与数据结构底层设计之间的紧密联系。[@problem_id:3206856]", "problem": "你正在设计一个动态数组，当其容量已满时，它会以几何级数按因子 $\\alpha > 1$ 增长。成本模型如下：将一个追加的元素写入任何可用槽位的成本为 $1$；当数组调整大小时，将每个现有元素复制到新数组的成本为每个元素 $1$。假设内存分配和指针更新的成本是与 $n$ 无关的常数，并在此忽略不计。\n\n你将使用摊还分析中的记账法：为每次追加操作分配一个摊还费用，该费用可能超过其实际成本，并将任何盈余作为信用存储起来，用于支付未来因调整大小而产生的移动成本。信用在任何时候都不能为负。\n\n设计一个记账方案，其中每次追加操作收取恰好 $3$ 个单位的费用：$1$ 个单位用于支付其自身的即时写入，另外 $2$ 个单位作为信用存入，仅用于支付未来调整大小时的移动成本（信用可用于支付移动任何元素，而不必是产生该信用的那个元素）。假设数组初始为空，初始容量为 $1$，并考虑任意有限次的无删除的追加序列。对于所有这样的序列，确定能使该记账方案得以维持而永远不会出现信用赤字的最小增长因子 $\\alpha$。\n\n你的最终答案必须是一个精确的 $\\alpha$ 值，不得四舍五入。", "solution": "我们希望找到动态数组的最小增长因子 $\\alpha$，使得一种特定的摊还分析记账方案可以无限期地维持下去。\n\n### 步骤 1：将问题形式化\n设 $n$ 是动态数组中元素的数量。数组的容量为 $C$。当追加一个元素时，如果 $n  C$，则该元素被添加到一个空槽位中。如果 $n = C$，则数组已满，必须在追加新元素之前进行调整大小的操作。\n\n初始状态是一个空数组（$n=0$），容量为 $C_0=1$。\n当触发调整大小时，会分配一个容量为 $C_{new} = \\alpha C_{old}$ 的新数组，并将现有的 $n=C_{old}$ 个元素复制到新数组中。我们可以将每次调整大小后的容量序列建模为 $C_k = \\alpha^k$，其中 $k=0, 1, 2, \\ldots$。当我们尝试添加第 $(\\lfloor \\alpha^{k-1} \\rfloor+1)$ 个元素时，会触发从容量 $C_{k-1} = \\lfloor \\alpha^{k-1} \\rfloor$ 到 $C_k = \\lfloor \\alpha^k \\rfloor$ 的大小调整（为简化分析，我们假设 $\\alpha$ 是整数或容量总是 $\\alpha^k$）。\n\n成本模型是：\n-   写入一个元素的实际成本：$1$ 个单位。\n-   调整大小时复制一个元素的实际成本：$1$ 个单位。\n\n记账方案是：\n-   每次追加操作的摊还费用：$3$ 个单位。\n-   每次追加，$1$ 个单位用于支付即时写入。\n-   每次追加，$2$ 个单位作为信用存入一个“银行”。\n-   调整大小时复制元素的成本必须通过从这个信用银行中提取来支付。\n-   关键约束是信用余额永远不能为负。\n\n我们必须找到最小的 $\\alpha > 1$，使得对于任意次数的追加操作，这个方案都成立。\n\n### 步骤 2：分析信用余额\n设 $B_i$ 是第 $i$ 次追加操作后的信用余额。设 $c_{\\text{actual}, i}$ 是第 $i$ 次追加的实际成本。根据所述的记账方案，对于每次操作 $i$，我们存入 $2$ 个信用，然后支付任何调整大小的成本。摊还成本 $c'_{i} = 3$。余额更新为 $B_i = B_{i-1} + 3 - c_{\\text{actual}, i}$。约束条件是对所有 $i$，$B_i \\ge 0$。\n\n实际成本 $c_{\\text{actual}, i}$ 是：\n-   如果追加不触发调整大小，则 $c_{\\text{actual}, i} = 1$。\n-   如果追加触发调整大小，则 $c_{\\text{actual}, i} = 1 + M$，其中 $M$ 是要复制的元素数量。\n\n信用余额在支付了一次大的调整大小操作后最为紧张。这些是需要分析的关键点。让我们分析在支付第 $k$ 次调整大小的费用之前的系统状态。这发生在追加第 $i$ 个元素时，其中 $i = \\alpha^{k-1} + 1$（为简化，假设 $\\alpha^{k-1}$ 是整数）。\n\n此时，数组中有 $n = i-1 = \\alpha^{k-1}$ 个元素，容量为 $C = \\alpha^{k-1}$。数组已满。\n到目前为止已执行的追加操作次数为 $n = \\alpha^{k-1}$。\n对于这 $n$ 次追加中的每一次，都存入了 $2$ 个单位的信用。\n因此，存入的总信用额为 $2n = 2\\alpha^{k-1}$。\n\n然而，其中一些信用已经用于之前的调整大小操作。调整大小发生在追加第 $j = \\alpha^0+1, \\alpha^1+1, \\dots, \\alpha^{k-2}+1$ 个元素时。\n由追加第 $j=\\alpha^m+1$ 个元素触发的调整大小的成本是当时元素的数量，即 $\\alpha^m$。\n因此，在当前这次调整大小*之前*发生的所有调整大小的总成本是 $m=0, 1, \\dots, k-2$ 的成本之和。\n$$ \\text{Cost}_{\\text{resizes}, \\text{past}} = \\sum_{m=0}^{k-2} \\alpha^m $$\n这是一个等比数列，其和为：\n$$ \\sum_{m=0}^{k-2} \\alpha^m = \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n\n在第 $k$ 次调整大小之前可用的信用余额 $B$ 是总存款减去过去的总支出：\n$$ B = 2\\alpha^{k-1} - \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n\n现在，必须支付第 $k$ 次调整大小的费用。成本是要复制的元素数量，即 $n=\\alpha^{k-1}$。这个成本必须从可用余额 $B$ 中支付。余额永不为负的约束意味着余额必须至少等于即将到来的调整大小的成本。\n$$ B \\ge \\alpha^{k-1} $$\n代入 $B$ 的表达式：\n$$ 2\\alpha^{k-1} - \\frac{\\alpha^{k-1}-1}{\\alpha-1} \\ge \\alpha^{k-1} $$\n\n### 步骤 3：解关于 $\\alpha$ 的不等式\n我们简化这个不等式：\n$$ \\alpha^{k-1} \\ge \\frac{\\alpha^{k-1}-1}{\\alpha-1} $$\n由于 $\\alpha > 1$，分母 $(\\alpha-1)$ 是正数，所以我们可以用它乘以不等式两边而不改变不等号的方向：\n$$ \\alpha^{k-1}(\\alpha-1) \\ge \\alpha^{k-1}-1 $$\n$$ \\alpha^k - \\alpha^{k-1} \\ge \\alpha^{k-1}-1 $$\n$$ \\alpha^k - 2\\alpha^{k-1} + 1 \\ge 0 $$\n这个不等式必须对所有调整大小事件都成立，即对所有整数 $k \\ge 1$（第一次调整大小对应于 $k=1$，此时容量为 $C_0=\\alpha^0=1$）都成立。\n\n让我们分析不等式 $\\alpha^k - 2\\alpha^{k-1} + 1 \\ge 0$。我们可以提出因子 $\\alpha^{k-1}$：\n$$ \\alpha^{k-1}(\\alpha - 2) + 1 \\ge 0 $$\n设 $g(k) = \\alpha^{k-1}(\\alpha - 2) + 1$。我们需要对所有 $k \\ge 1$ 都有 $g(k) \\ge 0$。\n\n情况 1：$\\alpha = 2$。\n不等式变为 $2^{k-1}(2 - 2) + 1 \\ge 0$，简化为 $1 \\ge 0$。这对所有 $k$ 都成立。因此，$\\alpha=2$ 是一个可能的解。\n\n情况 2：$\\alpha > 2$。\n在这种情况下，$(\\alpha-2) > 0$。由于 $\\alpha > 1$，$\\alpha^{k-1}$ 总是正的。因此，$\\alpha^{k-1}(\\alpha - 2) > 0$，且 $g(k) = \\alpha^{k-1}(\\alpha - 2) + 1 > 1$。该条件总是满足。\n\n情况 3：$1  \\alpha  2$。\n在这种情况下，$(\\alpha-2)$ 是负的。项 $\\alpha^{k-1}$ 是正的并且随 $k$ 增长。因此，项 $\\alpha^{k-1}(\\alpha - 2)$ 是负的，并且其绝对值随着 $k$ 的增加而增加。\n当 $k \\to \\infty$ 时，$\\alpha^{k-1} \\to \\infty$，所以 $\\alpha^{k-1}(\\alpha - 2) \\to -\\infty$。\n这意味着对于范围 $(1, 2)$ 内的任何 $\\alpha$，我们都可以找到一个足够大的 $k$，使得 $g(k) = \\alpha^{k-1}(\\alpha - 2) + 1  0$。这将对应于大量追加操作后出现信用赤字。因此，任何小于 $2$ 的 $\\alpha$ 都无法在所有可能的追加序列中维持该记账方案。\n\n综合这些情况，条件 $\\alpha^{k-1}(\\alpha - 2) + 1 \\ge 0$ 对所有 $k \\ge 1$ 成立，当且仅当 $\\alpha \\ge 2$。\n问题要求的是最小的此类增长因子 $\\alpha$。这是有效范围的最小值，即 $\\alpha=2$。", "answer": "$$\\boxed{2}$$", "id": "3206856"}, {"introduction": "动态数组的 $O(1)$ 摊还成本是一个著名的结论，但这并非一个普适定律。本练习将挑战一个关键假设：复制元素的成本是线性的。通过探索一个假设性的场景——复制成本是二次方级别的，我们将发现单次操作的摊还成本会随着数组规模的增长而增长，从而深刻理解底层成本模型对摊还分析结果的重要性。[@problem_id:3206794]", "problem": "给定一个连续存储元素的动态数组。该数组初始为空，初始容量为 $1$。每当一次追加操作会超出当前容量时，数组会进行大小调整，即分配一个容量为当前容量 $2$ 倍的新数组，然后按顺序将所有现有元素迁移到新数组中。\n\n成本模型如下：每次将单个元素写入可用槽位的追加操作成本为 $1$ 个单位；当发生大小调整时，将 $k$ 个现有元素复制到新数组的成本为 $k^2$ 个单位（此成本是在触发大小调整的追加操作的 $1$ 单位成本之外的）。你总共执行了恰好 $n$ 次追加操作，其中 $n$ 是 $2$ 的幂（即，对于某个整数 $t \\ge 0$，有 $n = 2^t$）。\n\n仅使用“单次操作的摊还成本等于总成本除以操作次数”这一定义，以及指定的大小调整策略，推导出每次追加操作的精确摊还成本，并表示为 $n$ 的函数。请将你的最终答案以一个关于 $n$ 的单一、简化的闭式解析表达式的形式给出。最终答案中不要包含单位。无需进行四舍五入。", "solution": "问题要求计算对一个动态数组执行 $n$ 次追加操作序列的单次追加操作的精确摊还成本，其中 $n$ 是 $2$ 的幂（$n = 2^t$，对于某个整数 $t \\ge 0$）。摊还成本定义为总成本除以操作次数。\n\n首先，我们必须计算执行 $n$ 次追加操作的总成本。总成本 $C_{total}$ 是两个部分之和：所有追加操作的总成本和所有调整大小并复制操作的总成本。\n\n成本模型规定如下：\n1.  基本追加成本：每次将元素写入可用槽位的追加操作成本为 $1$ 个单位。\n2.  调整大小成本：当触发大小调整时，复制 $k$ 个现有元素的成本为 $k^2$ 个单位。这不包括触发此次调整的追加操作本身的 $1$ 个单位成本。\n\n**基本追加总成本：**\n由于总共有 $n$ 次追加操作，每次的基本成本为 $1$，因此基本追加总成本为 $n \\times 1 = n$。\n\n**调整大小总成本：**\n当尝试向一个已满的数组追加元素时，就会发生大小调整。数组的初始容量为 $1$。每次调整大小时，容量会加倍。\n我们来追踪数组的状态，特别是它的大小（元素数量）和容量。\n-   初始时，大小为 $0$，容量为 $1$。\n-   第 $1$ 次追加：大小变为 $1$。数组此时已满。\n-   第 $2$ 次追加：由于大小（$1$）等于容量（$1$），这次操作触发了第一次大小调整。需要复制的元素数量为 $k=1$。新容量将为 $2 \\times 1 = 2$。此次复制的成本为 $k^2 = 1^2 = 1$。\n-   第 $3$ 次追加：此时大小为 $2$，容量为 $2$。这次操作触发了一次大小调整。需要复制的元素数量为 $k=2$。新容量将为 $2 \\times 2 = 4$。此次复制的成本为 $k^2 = 2^2 = 4$。\n-   第 $5$ 次追加：此时大小为 $4$，容量为 $4$。这次操作触发了一次大小调整。需要复制的元素数量为 $k=4$。新容量将为 $2 \\times 4 = 8$。此次复制的成本为 $k^2 = 4^2 = 16$。\n\n从这个模式中，我们可以进行归纳。当数组中的元素数量是 $2$ 的幂（比如 $2^j$）时，下一次追加新元素就会触发一次大小调整。需要复制的元素数量为 $k=2^j$。单次调整大小操作的成本为 $k^2 = (2^j)^2 = 4^j$。\n\n我们总共执行 $n=2^t$ 次追加操作。会触发大小调整的数组大小分别为 $1, 2, 4, \\dots, 2^{t-1}$。\n-   当大小为 $1=2^0$ 时，下一次追加会触发大小调整。复制成本为 $(2^0)^2 = 4^0$。这对应于 $j=0$ 的情况。\n-   当大小为 $2=2^1$ 时，下一次追加会触发大小调整。复制成本为 $(2^1)^2 = 4^1$。这对应于 $j=1$ 的情况。\n-   这个过程一直持续到数组大小为 $2^{t-1}$。下一次追加（即第 $2^{t-1}+1$ 次操作）会触发一次大小调整，使容量变为 $2 \\times 2^{t-1} = 2^t$。需要复制的元素数量为 $k=2^{t-1}$，成本为 $(2^{t-1})^2 = 4^{t-1}$。这对应于 $j=t-1$ 的情况。\n\n在最后一次追加操作（第 $n=2^t$ 次）之后，数组的大小将为 $2^t$，容量也为 $2^t$。在这 $n$ 次操作的序列中，不会再有大小调整发生。因此，大小调整对应于 $j$ 从 $0$ 到 $t-1$ 的所有情况。\n\n调整大小的总成本 $C_{\\text{resize}}$ 是所有这些调整大小操作的成本之和：\n$$C_{\\text{resize}} = \\sum_{j=0}^{t-1} (2^j)^2 = \\sum_{j=0}^{t-1} 4^j$$\n这是一个包含 $t$ 项的有限几何级数，其首项为 $4^0=1$，公比为 $4$。其和由公式 $\\frac{r^{\\text{项数}} - 1}{r-1}$ 给出。\n$$C_{\\text{resize}} = \\frac{4^t - 1}{4 - 1} = \\frac{4^t - 1}{3}$$\n此计算对 $t \\ge 1$ 成立。如果 $t=0$，则 $n=1$，此时和式为空，其值为 $0$。我们的公式得出 $\\frac{4^0-1}{3}=0$，因此该公式对 $t=0$ 也成立。\n\n现在，我们可以通过将基本追加总成本和调整大小总成本相加来得到总成本 $C_{\\text{total}}$：\n$$C_{\\text{total}} = (\\text{追加总成本}) + (\\text{调整大小总成本}) = n + \\frac{4^t - 1}{3}$$\n\n为了完全用 $n$ 来表示这个成本，我们使用给定的关系 $n=2^t$。两边平方得到 $n^2 = (2^t)^2 = 2^{2t} = (2^2)^t = 4^t$。\n将 $4^t = n^2$ 代入 $C_{\\text{total}}$ 的表达式中：\n$$C_{\\text{total}} = n + \\frac{n^2 - 1}{3}$$\n\n最后，每次追加的摊还成本 $A(n)$ 是总成本除以操作次数 $n$。\n$$A(n) = \\frac{C_{\\text{total}}}{n} = \\frac{n + \\frac{n^2 - 1}{3}}{n}$$\n我们可以简化这个表达式：\n$$A(n) = \\frac{n}{n} + \\frac{n^2 - 1}{3n} = 1 + \\frac{n^2 - 1}{3n}$$\n为了将其写成单个分数的形式，我们通分：\n$$A(n) = \\frac{3n}{3n} + \\frac{n^2 - 1}{3n} = \\frac{3n + n^2 - 1}{3n}$$\n将分子中的各项重新排列，得到最终的简化表达式：\n$$A(n) = \\frac{n^2 + 3n - 1}{3n}$$\n这就是以 $n$ 表示的、单一简化的闭式解析表达式形式的单次追加精确摊还成本。", "answer": "$$ \\boxed{\\frac{n^2 + 3n - 1}{3n}} $$", "id": "3206794"}, {"introduction": "优异的摊还性能往往依赖于对参数的精细选择。本练习探讨了一个既能增长也能缩容的动态数组。我们将分析一个“最坏情况”的场景，其中增长和缩容因子设置得过于接近，导致了所谓的“颠簸”（thrashing）现象。这个练习将展示一个交替进行插入和删除的操作序列如何导致每次操作都触发昂贵的数组大小调整，从而使摊还成本退化为线性时间，而非我们所期望的常数时间。[@problem_id:3206966]", "problem": "动态数组将元素存储在连续的内存块中，其当前大小为 $s$，容量为 $C$。当 $s = C$ 时，数组会扩容，方法是分配一个容量为 $\\alpha C$ 的新内存块，并复制所有 $s$ 个元素；当 $s \\leq \\beta C$ 时，数组会缩容，方法是分配一个容量为 $\\beta C$ 的新内存块，并复制所有 $s$ 个元素。假设成本模型如下：复制一个元素的成本为 $1$，每次不触发调整大小的插入或删除操作的成本为 $1$，而分配内存的成本可以忽略不计。操作序列的摊销成本使用聚合分析法定义：每次操作的摊销成本是总成本除以操作次数。\n\n考虑增长因子和收缩因子几乎互为倒数的情况，此时数组容易发生振荡性的调整大小。设 $k$ 为一个固定的正整数，并设置增长因子为 $\\alpha = \\frac{k+1}{k}$，收缩因子为 $\\beta = \\frac{k}{k+1}$，因此 $\\alpha \\beta = 1$。假设初始容量为 $C_{0} = n$，$n$ 能被 $k$ 整除，且数组初始时是满的，即 $s = n$。现在重复执行以下包含两个操作的循环：\n1. 插入一个元素。\n2. 删除一个元素。\n\n在调整大小策略 $s = C \\Rightarrow$ 扩容至 $\\alpha C$ 和 $s \\leq \\beta C \\Rightarrow$ 缩容至 $\\beta C$ 下，并使用所述的成本模型，当 $\\alpha \\beta = 1$ 时，这个交替序列会在每次操作时都引发调整大小，从而产生一种“颠簸”行为。\n\n从第一性原理出发，推导上述交替序列中每次操作的精确摊销成本（总成本除以总操作次数），并用一个关于 $n$ 的解析闭式表达式表示。无需四舍五入。请将你的最终答案以单个表达式的形式给出。", "solution": "问题要求使用聚合分析法，计算对动态数组执行一个特定操作序列时，每次操作的摊销成本。分析需要从第一性原理出发进行逐步推导，跟踪数组的状态（大小 $s$ 和容量 $C$）以及产生的成本。\n\n给定的参数如下：\n- 增长因子：$\\alpha = \\frac{k+1}{k}$，其中 $k$ 为正整数。\n- 收缩因子：$\\beta = \\frac{k}{k+1}$，这意味着 $\\alpha \\beta = 1$。\n- 扩容条件：如果在插入前数组已满（即 $s=C$），则触发调整大小。\n- 缩容条件：如果在删除后数组利用率过低（即 $s \\leq \\beta C$），则触发调整大小。\n- 成本模型：一次插入或删除操作的成本是 $1$ 加上其触发的任何调整大小操作的成本。调整大小的成本等于被复制的元素数量。\n\n数组的初始状态给定如下：\n- 初始容量：$C_0 = n$。\n- 初始大小：$s_0 = n$（数组已满）。\n- 题目还给定了 $n$ 能被 $k$ 整除。\n\n操作序列是一个重复的循环，每次循环包含一次插入和一次删除。我们将分析一个完整循环的成本和状态变化。\n\n**第1步：分析第一个操作（插入）**\n\n系统初始状态为 $(s_0, C_0) = (n, n)$。\n执行一次插入操作。\n首先，我们检查调整大小的条件。由于 $s_0 = n$ 且 $C_0 = n$，满足条件 $s=C$。这会在插入新元素之前触发一次扩容操作。\n一个新的、更大的数组被分配。新容量 $C_1$ 计算如下：\n$$C_1 = \\alpha C_0 = \\left(\\frac{k+1}{k}\\right) n$$\n这次扩容操作的成本是必须从旧数组复制到新数组的元素数量。此时，数组大小为 $s_0 = n$。\n$$ \\text{Cost}_{\\text{copy, grow}} = s_0 = n $$\n调整大小后，执行插入操作本身。这有 $1$ 的基本成本。\n第一个操作（带调整大小的插入）的总成本是复制成本和基本插入成本之和：\n$$ \\text{Cost}_1 = \\text{Cost}_{\\text{copy, grow}} + \\text{Cost}_{\\text{base insert}} = n + 1 $$\n此操作后，数组的大小增加一。数组的新状态是：\n- 新大小：$s_1 = s_0 + 1 = n + 1$。\n- 新容量：$C_1 = \\left(\\frac{k+1}{k}\\right) n$。\n\n**第2步：分析第二个操作（删除）**\n\n系统现在处于状态 $(s_1, C_1) = \\left(n+1, \\left(\\frac{k+1}{k}\\right)n\\right)$。\n执行一次删除操作。这会使元素数量减少一。\n数组的大小变为 $s' = s_1 - 1 = (n+1) - 1 = n$。\n移除元素后，我们检查缩容的条件。条件是 $s' \\leq \\beta C_1$。\n我们来计算缩容阈值 $\\beta C_1$：\n$$ \\beta C_1 = \\left(\\frac{k}{k+1}\\right) \\times C_1 = \\left(\\frac{k}{k+1}\\right) \\left(\\frac{k+1}{k}\\right) n = 1 \\cdot n = n $$\n因此要检查的条件是 $s' \\leq n$。由于 $s' = n$，条件 $n \\leq n$ 得到满足。这会触发一次缩容操作。\n一个新的、更小的数组被分配。新容量 $C_2$ 为：\n$$ C_2 = \\beta C_1 = n $$\n这次缩容操作的成本是要复制的元素数量，即当前大小 $s' = n$。\n$$ \\text{Cost}_{\\text{copy, shrink}} = s' = n $$\n删除操作的基本成本是 $1$。\n第二个操作（带调整大小的删除）的总成本是复制成本和基本删除成本之和：\n$$ \\text{Cost}_2 = \\text{Cost}_{\\text{copy, shrink}} + \\text{Cost}_{\\text{base delete}} = n + 1 $$\n此操作后，数组的状态是：\n- 新大小：$s_2 = s' = n$。\n- 新容量：$C_2 = n$。\n\n**第3步：计算摊销成本**\n\n经过两次操作（一次插入，一次删除）后，数组的状态为 $(s_2, C_2) = (n, n)$。这与初始状态 $(s_0, C_0)$ 完全相同。\n操作和成本的序列将无限重复。因此，我们可以通过分析一个包含两次操作的循环来计算摊销成本。\n一个循环中的总操作次数为 $2$。\n一个循环的总成本是两次操作的成本之和：\n$$ \\text{Total Cost}_{\\text{cycle}} = \\text{Cost}_1 + \\text{Cost}_2 = (n+1) + (n+1) = 2n + 2 $$\n根据聚合分析法，每次操作的摊销成本定义为总成本除以总操作次数。\n$$ \\text{Amortized Cost} = \\frac{\\text{Total Cost}_{\\text{cycle}}}{\\text{Number of Operations}_{\\text{cycle}}} = \\frac{2n + 2}{2} = n + 1 $$\n这就是给定序列中每次操作的精确摊销成本，它展示了“颠簸”行为，即每次操作都会触发昂贵的调整大小，导致摊销成本与数组大小 $n$ 呈线性关系。条件“$n$ 能被 $k$ 整除”确保了中间容量 $C_1$ 是一个整数，从而使问题是良定义的。", "answer": "$$\\boxed{n+1}$$", "id": "3206966"}]}