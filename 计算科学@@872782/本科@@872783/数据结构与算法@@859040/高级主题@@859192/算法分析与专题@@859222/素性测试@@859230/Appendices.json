{"hands_on_practices": [{"introduction": "要真正掌握一个算法，最好的方法之一就是亲手追踪其执行过程。本次练习将引导你对一个精心挑选的数字执行 Miller-Rabin 素性测试，让你亲身体验该算法的每一个步骤。通过处理一个能够骗过较弱测试的合数，你将揭示 Miller-Rabin 测试如何利用模 $1$ 的非平凡平方根来识别合数的强大之处[@problem_id:3088381]。", "problem": "考虑奇合数 $n=341$ 和底数 $a=2$。Miller-Rabin强素数测试的步骤是：将 $n-1$ 写成 $2^{r}d$ 的形式，其中 $d$ 是奇数；计算模幂 $x_{0}\\equiv a^{d} \\pmod{n}$；然后构建平方链 $x_{j+1}\\equiv x_{j}^{2}\\pmod{n}$，其中 $j=0,1,\\dots,r-1$。在此框架下，当对于某个 $j\\geq 1$ 有 $x_{j}\\equiv 1 \\pmod{n}$，而 $x_{j-1}\\not\\equiv \\pm 1 \\pmod{n}$ 时，就出现了见证其为合数的步骤，这揭示了模 $n$ 下 $1$ 的一个非平凡平方根。使用模运算、幂运算和 $n-1$ 的分解的定义，对给定的 $n$ 和 $a$ 执行一次完整的 Miller-Rabin 迭代：确定 $r$ 和 $d$，计算 $x_{0}$ 以及后续的 $x_{j}$ 值直到 $j=r$，找出最早的见证其为合数的步骤，然后使用最大公约数 (GCD) 从该步骤中提取 $n$ 的一个非平凡因子。\n\n请给出与第一个见证步骤相关的 $\\gcd\\!\\big(x_{j-1}-1,n\\big)$ 的精确整数值作为最终答案。不要四舍五入，请以精确整数形式表示答案。", "solution": "问题陈述是 Miller-Rabin 素性测试的一个有效应用，这是数论中一个明确定义的算法。所有必要的数据（$n=341$，$a=2$）和定义都已提供，问题是自洽、客观且科学合理的。我们可以开始求解。\n\n目标是对整数 $n=341$ 和底数 $a=2$ 执行一次 Miller-Rabin 测试迭代，找出见证其为合数的步骤，并利用该信息找到一个非平凡因子。\n\n首先，我们必须将 $n-1$ 分解为 $2^r d$ 的形式，其中 $d$ 是一个奇数。\n给定 $n=341$，我们有 $n-1 = 340$。\n我们从 $340$ 中分解出 $2$ 的幂次：\n$$340 = 10 \\times 34 = (2 \\times 5) \\times (2 \\times 17) = 4 \\times 85 = 2^2 \\times 85$$\n这里，$d=85$ 是奇数。因此，我们确定 $r=2$ 和 $d=85$。\n\nMiller-Rabin 测试序列由 $x_0 \\equiv a^d \\pmod{n}$ 和 $x_{j+1} \\equiv x_j^2 \\pmod{n}$ 定义，其中 $j=0, 1, \\dots, r-1$。\n\n我们首先计算 $x_0$：\n$$x_0 \\equiv a^d \\pmod{n} \\equiv 2^{85} \\pmod{341}$$\n为了高效地计算这个模幂，我们使用二进制幂（也称为重复平方）方法。指数 $d=85$ 的二进制表示是 $1010101_2$，对应于 2 的幂次之和：$85 = 64 + 16 + 4 + 1$。\n我们计算 $2$ 的各次幂模 $341$ 的值：\n\\begin{align*} 2^1 \\equiv 2 \\pmod{341} \\\\ 2^2 \\equiv 4 \\pmod{341} \\\\ 2^4 \\equiv 4^2 \\equiv 16 \\pmod{341} \\\\ 2^8 \\equiv 16^2 \\equiv 256 \\pmod{341} \\\\ 2^{16} \\equiv 256^2 = 65536 \\pmod{341} \\end{align*}\n为了化简 $65536$，我们用 $341$ 去除它：$65536 = 192 \\times 341 + 4$。所以，$2^{16} \\equiv 4 \\pmod{341}$。\n\\begin{align*} 2^{32} \\equiv 4^2 \\equiv 16 \\pmod{341} \\\\ 2^{64} \\equiv 16^2 \\equiv 256 \\pmod{341} \\end{align*}\n现在，我们结合这些结果来计算 $2^{85}$：\n$$2^{85} = 2^{64} \\cdot 2^{16} \\cdot 2^4 \\cdot 2^1$$\n$$x_0 \\equiv 2^{85} \\equiv 256 \\cdot 4 \\cdot 16 \\cdot 2 \\pmod{341}$$\n我们分步计算这个乘积：\n$$256 \\cdot 4 = 1024$$\n用 $341$ 除 $1024$ 得到 $1024 = 3 \\times 341 + 1$，所以 $1024 \\equiv 1 \\pmod{341}$。\n将此结果代回 $x_0$ 的表达式：\n$$x_0 \\equiv (1) \\cdot 16 \\cdot 2 \\equiv 32 \\pmod{341}$$\n所以，$x_0 = 32$。\n\n测试首先检查 $x_0 \\equiv \\pm 1 \\pmod{n}$ 是否成立。由于 $32 \\not\\equiv 1 \\pmod{341}$ 且 $32 \\not\\equiv -1 \\pmod{341}$（因为 $-1 \\equiv 340 \\pmod{341}$），测试进入下一步。\n\n接着，我们计算序列 $x_j$，其中 $j=1, \\dots, r-1$。由于 $r=2$，我们只需要计算 $x_1$。\n$$x_1 \\equiv x_0^2 \\pmod{n} \\equiv 32^2 \\pmod{341}$$\n$$x_1 \\equiv 1024 \\pmod{341}$$\n如前所述，$1024 = 3 \\times 341 + 1$。因此：\n$$x_1 \\equiv 1 \\pmod{341}$$\n测试发现当 $j=1$ 时，我们有 $x_1 \\equiv 1 \\pmod{341}$。见证其为合数的条件已满足，因为 $x_1 \\equiv 1 \\pmod{n}$，而序列中的前一项 $x_{1-1}=x_0=32$ 不全等于 $\\pm 1 \\pmod{n}$。这是第一个见证 $n$ 是合数的步骤。\n\n存在这样的 $x_0$ 意味着它是模 $n$ 下 $1$ 的一个非平凡平方根。也就是说，$x_0^2 \\equiv 1 \\pmod{n}$ 但 $x_0 \\not\\equiv \\pm 1 \\pmod{n}$。这可以改写为 $x_0^2 - 1 \\equiv 0 \\pmod{n}$，或 $(x_0 - 1)(x_0 + 1) \\equiv 0 \\pmod{n}$。\n这意味着 $n$ 整除乘积 $(x_0 - 1)(x_0 + 1)$。由于 $n$ 不能整除 $x_0-1$（因为 $x_0 \\not\\equiv 1 \\pmod n$）且 $n$ 不能整除 $x_0+1$（因为 $x_0 \\not\\equiv -1 \\pmod n$），所以 $n$ 必须与 $(x_0 - 1)$ 和 $(x_0 + 1)$ 都共享一个非平凡因子。\n\n问题要求使用最大公约数 (GCD) 从见证步骤中提取一个非平凡因子。具体来说，我们必须计算 $\\gcd(x_{j-1}-1, n)$，其中 $j=1$ 是第一个见证步骤。\n这需要计算 $\\gcd(x_0 - 1, n)$。\n代入我们找到的值：\n$$\\gcd(32 - 1, 341) = \\gcd(31, 341)$$\n要计算这个 GCD，我们可以使用欧几里得算法。由于 $31$ 是一个素数，我们可以直接测试 $31$ 是否是 $341$ 的因子。\n$$341 \\div 31 = 11$$\n除法是整除的。因此，$31$ 是 $341$ 的一个因子，且最大公约数是 $31$。\n$$\\gcd(31, 341) = 31$$\n这就是从 Miller-Rabin 测试中提取出的 $n=341$ 的非平凡因子。", "answer": "$$\\boxed{31}$$", "id": "3088381"}, {"introduction": "在了解了 Miller-Rabin 测试的内部机制后，下一个关键问题是：我们为什么需要它？本次动手实践将让你编写代码，去主动寻找那些能够通过费馬素性测试“伪装”成素数的合数，但会被 Miller-Rabin 测试识破。这个编程任务让你从算法的应用者转变为探索者，通过亲手捕获这些“费馬伪素数”，你将对不同素性测试的强度差异以及高级算法的必要性有更深刻的体会[@problem_id:3260318]。", "problem": "要求您设计并实现一个完整的、可运行的程序，用以合成满足以下条件的合数 $n$：该数能够通过以 $a=2$ 为底的费马素性检验，但会被同样以 $a=2$ 为底的 Miller–Rabin 检验（MR）识别为合数。目标是探究这类整数的结构，并阐明为何在数据结构和算法中需要更强的检验方法。\n\n请从以下基本事实出发：\n\n1. 费马小定理：对于一个素数 $p$ 和任意满足 $\\gcd(a,p)=1$ 的整数 $a$，有 $a^{p-1} \\equiv 1 \\pmod{p}$。这启发了针对奇数 $n>2$ 的费马检验：对于一个与 $n$ 互质的选定底数 $a$，若 $a^{n-1} \\equiv 1 \\pmod{n}$，则称 $n$ 为“可能为素数”。\n2. Miller–Rabin 检验（MR）：对于奇数 $n>2$，将 $n-1$ 写成 $n-1 = 2^s d$ 的形式，其中 $d$ 为奇数。对于一个与 $n$ 互质的选定底数 $a$，计算 $x_0 \\equiv a^d \\pmod{n}$，然后重复平方，$x_{r+1} \\equiv x_r^2 \\pmod{n}$，其中 $r = 0,1,\\dots,s-2$。如果 $x_0 \\equiv 1 \\pmod{n}$ 或者存在某个 $x_r \\equiv -1 \\pmod{n}$，MR 检验将宣称 $n$ 为“可能为素数”；否则，MR 检验将宣称 $n$ 为合数。\n\n在此任务中，您必须：\n\n- 实现一个函数，用于检查奇数 $n>2$ 是否满足 $2^{n-1} \\equiv 1 \\pmod{n}$（费马检验，底为 $a=2$）。\n- 针对奇数 $n>2$，实现一个以 $a=2$ 为底的 Miller–Rabin 检验。该检验使用 $n-1=2^s d$ 的分解和上述序列，并返回一个布尔值，指示 MR 检验是否接受 $n$ 为“可能为素数”（true）或检测到 $n$ 为合数（false）。\n- 合成同时满足通过以 $a=2$ 为底的费马检验（true）和未通过以 $a=2$ 为底的 MR 检验（false）的整数 $n$。只考虑奇数 $n>2$。\n- 通过检查卡迈克尔数的 Korselt 准则来探究这些数的结构：一个奇合数 $n$ 是卡迈克尔数，当且仅当 $n$ 是无平方因子的，并且对于 $n$ 的每一个素因子 $p$，都有 $(p-1) \\mid (n-1)$。实现一个函数，返回一个布尔值，指示给定的 $n$ 是否满足 Korselt 准则。\n\n对于每个给定的测试用例，您的程序必须按升序搜索奇数 $n$ 直至给定的上限 $L$，收集最多 $K$ 个满足 $2^{n-1} \\equiv 1 \\pmod{n}$ 且未通过以 $a=2$ 为底的 MR 检验的整数 $n$，然后为每个收集到的 $n$ 报告一个数对，该数对由整数 $n$ 和一个指示其是否满足 Korselt 准则的布尔值组成。如果在上限 $L$ 内存在的此类整数少于 $K$ 个，则报告所有找到的整数。如果在上限 $L$ 内不存在此类整数，则报告一个空列表。\n\n此问题不涉及物理单位或角度。所有输出均为纯数值和布尔值。\n\n测试套件和最终输出规范：\n\n- 使用以下包含三个用例的测试套件：\n  1. 用例 1：$L=5000$，$K=10$。\n  2. 用例 2：$L=300$，$K=5$。\n  3. 用例 3：$L=20000$，$K=7$。\n- 对于每个用例，生成一个数对列表 $[n,c]$，其中 $n$ 是合成的整数，$c$ 是指示 $n$ 是否满足 Korselt 准则的布尔值。\n- 您的程序应生成单行输出，其中包含三个用例的结果，结果为逗号分隔的列表，并用方括号括起来。每个用例的结果本身必须是其 $[n,c]$ 数对的方括号括起的逗号分隔列表。例如，输出格式必须严格遵循以下形式\n  $$[ [n_1,c_1],[n_2,c_2],\\dots ],[ \\dots ],[ \\dots ]$$\n  不含任何空格，其中最外层方括号包含三个测试用例的结果，每个内层方括号包含该用例找到的数对。具体来说，您的程序必须打印类似如下的内容\n  $$[[n_1,c_1],[n_2,c_2]],[[\\dots]],[[\\dots]]$$\n  但使用实际计算出的值，并确保该行中没有任何空格。", "solution": "经过深入分析，该问题被认定为有效。它在科学上基于已确立的数论，问题陈述清晰，要求明确一致，并以客观的数学语言表达。核心任务是识别和分析一类特殊的合数：那些被以 $a=2$ 为底的费马素性检验识别为“可能为素数”，但被同样底数的、更强的 Miller-Rabin（MR）检验正确识别为合数的数。这些数是基于底数 $2$ 的费马伪素数，但不是基于底数 $2$ 的强伪素数。\n\n问题陈述中关于 Miller-Rabin 检验的描述，在检查 $x_r \\equiv -1 \\pmod{n}$ 的索引范围上略有含糊。我们将采用 MR 检验的标准解释，这与该问题旨在将其与较弱的费马检验进行对比的意图相符。对于奇数 $n > 2$（其中 $n-1 = 2^s d$，$d$ 为奇数）和底数 $a$，标准的 MR 检验在 $a^d \\equiv 1 \\pmod{n}$ 或对于某个 $0 \\le r  s$ 范围内的 $r$ 有 $a^{2^r d} \\equiv -1 \\pmod{n}$ 成立时通过。如果一个数未能通过此检验，则被判定为合数。\n\n解决方案将通过为每个所需的数论检验实现辅助函数，然后将它们集成到指定的搜索算法中来构建。\n\n### 方法与实现步骤\n\n**1. 模幂运算**\n\n费马检验和 Miller-Rabin 检验的核心都是高效计算 $a^b \\pmod{m}$。这可以通过平方求幂法（exponentiation by squaring）实现，Python 的内置函数 `pow(base, exp, mod)` 提供了该功能。此函数将用于所有模幂运算需求。\n\n**2. 费马素性检验（底为 $a=2$）**\n\n该检验是费马小定理的直接应用。对于给定的奇数 $n > 2$，我们检查它是否满足同余式 $2^{n-1} \\equiv 1 \\pmod{n}$。问题要求找出通过此检验的整数。函数 `is_fermat_prp(n)` 将实现此检查。由于搜索范围是奇数 $n$，条件 $\\gcd(2, n)=1$ 总是满足的。如果 $n$ 是一个以 2 为底的费马伪素数，函数返回 `True`，否则返回 `False`。\n\n`is_fermat_prp(n)`：\n- 计算 $2^{n-1} \\pmod{n}$。\n- 如果结果为 $1$，返回 `True`，否则返回 `False`。\n\n**3. Miller-Rabin 检验（底为 $a=2$）**\n\nMR 检验提供了一种更严格的素性检查。对于奇数 $n > 2$，我们首先将 $n-1$ 分解为 $2^s d$ 的形式，其中 $d$ 为奇数。然后，检验会检查序列值 $x_r = 2^{2^r d} \\pmod{n}$，其中 $r = 0, 1, \\dots, s-1$。如果 $n$ 是一个以 2 为底的强可能素数（通过检验），函数 `is_miller_rabin_prp(n)` 将返回 `True`；如果它被确定为合数，则返回 `False`。\n\n`is_miller_rabin_prp(n)`：\n- 找到 $s$ 和 $d$，使得 $n-1 = 2^s d$ 且 $d$ 为奇数。这通过重复将 $n-1$ 除以 $2$ 直到其变为奇数来完成。\n- 计算 $x \\equiv 2^d \\pmod{n}$。\n- 如果 $x=1$ 或 $x=n-1$，$n$ 通过检验。返回 `True`。\n- 循环 $s-1$ 次：在每一步中将 $x$ 对 $n$ 取模并平方。\n  - $x \\leftarrow x^2 \\pmod{n}$。\n  - 如果 $x=n-1$，$n$ 通过检验。返回 `True`。\n- 如果循环完成而 $x=n-1$ 的条件未被满足，$n$ 未通过检验。返回 `False`。\n\n**4. 结构探究：Korselt 准则**\n\n问题要求检查合成的数是否满足卡迈克尔数的 Korselt 准则。一个奇合数 $n$ 满足此准则，如果它是无平方因子的，并且对于 $n$ 的每个素因子 $p$，都有 $(p-1) \\mid (n-1)$。\n\n`is_korselt_carmichael(n)`：\n- **步骤 4a：素因数分解和无平方因子检查**：该函数首先需要找到 $n$ 的所有不同素因子。对于给定的上限，试除法是足够的。在分解过程中，我们可以同时检查 $n$ 是否是无平方因子的。如果在任何时候我们找到一个因子 $p$ 且 $n/p$ 也能被 $p$ 整除，那么 $n$ 就不是无平方因子的，函数可以立即返回 `False`。\n- **步骤 4b：整除性检查**：如果发现 $n$ 是无平方因子的，我们遍历其每个不同的素因子 $p_i$。对于每个 $p_i$，我们检查 $(p_i-1)$ 是否能整除 $(n-1)$。如果这个条件对任何一个素因子不成立，函数返回 `False`。\n- 如果所有素因子都满足条件，函数返回 `True`。\n\n需要一个使用试除法（检查到 $\\sqrt{k}$）的辅助函数 `is_prime(k)`，以确保我们只搜索合数 $n$。\n\n**5. 合成与最终输出生成**\n\n主程序逻辑遍历所提供的测试用例 $(L, K)$。对于每个用例，它从 $3$ 开始搜索奇数 $n$ 直至上限 $L$。\n\n对于给定的 $(L, K)$，主搜索循环如下：\n- 初始化一个空列表 `found_numbers`。\n- 从 $3$ 到 $L$ 以步长 $2$ 遍历 $n$。\n- 对于每个 $n$：\n  - 使用 `is_prime(n)` 检查 $n$ 是否为合数。如果是素数，则继续下一个 $n$。\n  - 检查 `is_fermat_prp(n)` 是否为 `True`。\n  - 检查 `is_miller_rabin_prp(n)` 是否为 `False`。\n  - 如果两个条件都满足，$n$ 就是我们感兴趣的数。\n    - 检查 `is_korselt_carmichael(n)`。\n    - 将数对 $[n, \\text{korselt_result}]$ 添加到 `found_numbers`。\n    - 如果找到的数的数量达到 $K$，则中断搜索循环。\n- 循环结束后，列表 `found_numbers` 包含当前测试用例的结果。\n\n最后，所有测试用例的结果将按照严格的规范格式化为单个字符串：`[[case1_results],[case2_results],[case3_results]]`，不含任何空格。这通过为每个用例的结果列表生成字符串表示，然后用逗号连接这些字符串，并用一对最外层的方括号括起来实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Main function to solve the problem as specified.\n    It synthesizes composite integers that pass the Fermat test but fail the Miller-Rabin test for base 2,\n    and checks them against Korselt's criterion.\n    \"\"\"\n\n    def is_prime(n):\n        \"\"\"\n        Checks if a number is prime using trial division.\n        Assumes n is an odd integer  2 for optimization inside the main loop.\n        \"\"\"\n        if n  2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        # Only need to check odd divisors up to sqrt(n)\n        for i in range(3, int(n**0.5) + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_fermat_prp(n):\n        \"\"\"\n        Checks if n passes the Fermat primality test for base a=2.\n        Returns True if 2^(n-1) === 1 (mod n).\n        \"\"\"\n        return pow(2, n - 1, n) == 1\n\n    def is_miller_rabin_prp(n):\n        \"\"\"\n        Checks if n passes the Miller-Rabin primality test for base a=2.\n        Returns True if n is a strong probable prime to base 2, False if composite.\n        \"\"\"\n        if n = 2 or n % 2 == 0:\n            return n == 2\n        \n        # Write n-1 as 2^s * d\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # x = 2^d mod n\n        x = pow(2, d, n)\n        \n        if x == 1 or x == n - 1:\n            return True\n            \n        for _ in range(s - 1):\n            x = pow(x, 2, n)\n            if x == n - 1:\n                return True\n        \n        return False\n\n    def is_korselt_carmichael(n):\n        \"\"\"\n        Checks if n satisfies Korselt's criterion for Carmichael numbers.\n        1. n must be square-free.\n        2. For every prime factor p of n, (p-1) must divide (n-1).\n        This function assumes n is odd and composite.\n        \"\"\"\n        n_minus_1 = n - 1\n        \n        # Factorize n and check for square-free property and divisibility.\n        temp_n = n\n        factors = []\n        \n        # Trial division for factorization\n        d = 3\n        while d * d = temp_n:\n            if temp_n % d == 0:\n                # Found a prime factor\n                factors.append(d)\n                if n_minus_1 % (d - 1) != 0:\n                    return False\n                \n                temp_n //= d\n                # Check if not square-free\n                if temp_n % d == 0:\n                    return False\n            d += 2\n        \n        # Handle the last factor if it exists\n        if temp_n  1:\n            factors.append(temp_n)\n            if n_minus_1 % (temp_n - 1) != 0:\n                return False\n\n        # Must be composite, so at least 2 factors. This is guaranteed by the calling context.\n        return True if len(factors) = 2 else False\n\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (5000, 10),\n        (300, 5),\n        (20000, 7),\n    ]\n\n    overall_results = []\n    for L, K in test_cases:\n        case_results = []\n        # Search odd integers n from 3 up to L\n        for n in range(3, L + 1, 2):\n            if len(case_results) = K:\n                break\n            \n            # Problem asks for composite integers n\n            if is_prime(n):\n                continue\n            \n            # Condition: Pass Fermat base 2, Fail MR base 2\n            if is_fermat_prp(n) and not is_miller_rabin_prp(n):\n                korselt_result = is_korselt_carmichael(n)\n                case_results.append([n, korselt_result])\n        \n        overall_results.append(case_results)\n\n    # Format the final output string precisely as required, with no spaces.\n    case_strings = []\n    for case_res in overall_results:\n        # Convert each [n, c] pair to a string like \"[n,True]\"\n        pair_strings = [f\"[{item[0]},{item[1]}]\" for item in case_res]\n        # Join pairs into \"[p1,p2,...]\"\n        case_strings.append(f\"[{','.join(pair_strings)}]\")\n    \n    # Join all case strings into \"[c1,c2,c3]\"\n    final_output = f\"[{','.join(case_strings)}]\"\n    print(final_output)\n\nsolve()\n```", "id": "3260318"}, {"introduction": "在现实世界的应用中，极致的性能往往不是来自于单一的最优算法，而是多种策略的巧妙结合。这项综合性练习将挑战你设计一个混合素性测试策略，它首先使用快速的试除法筛掉大部分合数，然后对“幸存者”使用强大的 Miller-Rabin 测试。你的核心任务是基于一个给定的数学成本模型，通过分析和计算来确定两种方法之间的最佳切换阈值 $B$，从而最小化预期的总运行时间，这完美地体现了从算法理论到高性能计算实践的飞跃[@problem_id:3260252]。", "problem": "您需要设计并实现一个完整的、可运行的程序，通过将小素数试除法（上界为阈值 $B$）与 Miller–Rabin 概率性测试相结合，对一组给定的整数进行素性测试。核心要求是，在一个数学上明确的输入分布模型下，自适应地选择阈值 $B$ 以最小化期望运行时间。\n\n请从以下基本依据出发：\n\n- 素数的定义：一个整数 $n \\geq 2$ 是素数，当且仅当其仅有的正因数是 $1$ 和 $n$。\n- 基本的整除性事实：对于一个均匀随机整数 $n$，事件“$p$ 整除 $n$”的概率为 $1/p$，其中 $p$ 是任意素数。\n- 小素数整除性的独立性建模假设，我们将其作为算法设计的近似处理：将对于不同素数 $p$ 的随机事件“$p$ 整除 $n$”建模为相互独立，因此 $n$ 不能被任何 $\\leq x$ 的素数整除的概率为乘积 $\\prod_{p \\leq x} \\left(1 - \\frac{1}{p}\\right)$。根据 Mertens 第三定理，该乘积可渐近近似为 $\\prod_{p \\leq x} \\left(1 - \\frac{1}{p}\\right) \\sim \\frac{e^{-\\gamma}}{\\log x}$，其中 $\\gamma$ 是 Euler–Mascheroni 常数。但请注意，您在计算中不得直接使用此渐近公式。\n- 费马小定理：对于素数 $n$，每个满足 $1 \\le a  n$ 的底数 $a$ 都满足 $a^{n-1} \\equiv 1 \\pmod{n}$。\n- Miller–Rabin 合数见证数的概念：将 $n - 1$ 写成 $d \\cdot 2^s$ 的形式（其中 $d$ 为奇数），如果对于一个底数 $a$（$1  a  n$），我们有 $a^d \\not\\equiv 1 \\pmod{n}$ 且对于所有的 $0 \\le r  s$ 都有 $a^{d \\cdot 2^r} \\not\\equiv -1 \\pmod{n}$，则 $a$ 是 $n$ 的合数性质的一个见证数。\n\n成本模型与 $B$ 的自适应选择：\n\n- 单个素数的一次试除成本为 $c_d$ 个抽象时间单位。您必须将 $c_d$ 视为每个测试用例的给定值。\n- 一轮 Miller–Rabin 测试（一个底数）的成本为 $c_{mr} \\cdot (\\log_2 n)^3$ 个抽象时间单位。您必须将 $c_{mr}$ 视为每个测试用例的给定值。\n- 对 $k$ 个独立的 Miller–Rabin 底数进行测试的成本为 $k \\cdot c_{mr} \\cdot (\\log_2 n)^3$ 个时间单位。\n- 在上述独立性模型下，$n$ 通过所有素数 $\\leq B$ 的试除（即没有此类素数能整除 $n$）的概率是 $\\prod_{p \\leq B} \\left(1 - \\frac{1}{p}\\right)$。当按升序测试所有不大于 $B$ 的素数时，执行的试除次数的期望值等于在每次除法之前存活概率对这些素数的总和。您必须在您的解决方案中从第一性原理推导出这个期望值，并在代码中实现它，而不使用渐近捷径。\n\n您的程序必须：\n\n1. 对于每个给定的测试用例，计算作为 $B$ 的函数的总期望运行时间，该函数包括：\n   - 直到 $B$ 的期望试除成本，以及\n   - 由“没有小于等于 $B$ 的小素数能整除 $n$”的概率加权的期望 Miller–Rabin 成本。\n2. 在离散集合 $\\{0\\} \\cup \\{p \\in \\mathbb{P} \\mid p \\leq B_{\\max}\\}$ 上自适应地选择阈值 $B$，以最小化此期望总运行时间。其中 $\\mathbb{P}$ 表示素数集合，$B_{\\max}$ 是每个测试用例给定的上界。将 $B=0$ 解释为“不进行试除”。\n3. 执行实际的素性测试：首先用所有 $\\leq \\min(B, \\lfloor \\sqrt{n} \\rfloor)$ 的素数对 $n$ 进行试除，如果未找到因数，则使用一组固定的底数执行一个对 $n  2^{64}$ 有效的确定性 Miller–Rabin 测试。您必须在解决方案中证明所选底数的合理性。\n\n测试套件和参数：\n\n使用以下六个测试用例，每个用例指定为一个元组 $(n, k, c_d, c_{mr}, B_{\\max})$。所有整数 $n$ 都严格小于 $2^{64}$。\n\n- 测试用例 1: $(n = 1, k = 7, c_d = 1.0, c_{mr} = 0.2, B_{\\max} = 10000)$。\n- 测试用例 2: $(n = 2, k = 7, c_d = 1.0, c_{mr} = 0.2, B_{\\max} = 10000)$。\n- 测试用例 3: $(n = 221, k = 7, c_d = 1.0, c_{mr} = 0.2, B_{\\max} = 10000)$。\n- 测试用例 4: $(n = 3215031751, k = 7, c_d = 1.0, c_{mr} = 0.2, B_{\\max} = 10000)$。\n- 测试用例 5: $(n = 2305843009213693951, k = 7, c_d = 1.0, c_{mr} = 0.2, B_{\\max} = 10000)$。\n- 测试用例 6: $(n = 1000000000000000000, k = 7, c_d = 0.5, c_{mr} = 2.0, B_{\\max} = 10000)$。\n\n最终输出格式：\n\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。列表中的每一项对应一个测试用例，并且本身必须是一个包含两个元素的列表，其中包括选择的阈值 $B$ 和一个指示 $n$ 是否为素数的布尔值。例如，输出必须类似于 $[[B_1, \\mathrm{True}], [B_2, \\mathrm{False}], \\dots]$，除了 Python 默认列表字符串化中存在的空格外，不需要任何其他空格。不得打印任何额外文本。", "solution": "用户要求编写一个程序，对一组整数进行素性测试。该方法结合了试除法和 Miller-Rabin 测试。任务的一个关键组成部分是自适应地选择试除法阈值（用 $B$ 表示），以最小化期望总运行时间。此优化基于一个显式的输入分布概率模型。\n\n解决方案的结构如下：\n1.  **期望运行时间模型的推导**：我们首先推导总期望运行时间函数 $E(B)$，它是期望试除成本和期望 Miller-Rabin 测试成本之和。\n2.  **最优阈值选择算法**：我们设计一个算法，在允许的离散选择集合上找到使 $E(B)$ 最小化的 $B$ 值。\n3.  **素性测试算法**：我们详细介绍组合素性测试算法，包括对确定性 Miller-Rabin 底数的选择所做的合理性证明。\n4.  **实现与测试用例应用**：最后，我们概述解决所提供测试用例的实现策略。\n\n### 1. 期望运行时间模型的推导\n\n总运行时间 $T$ 是试除法运行时间 $T_{TD}$ 和 Miller-Rabin 运行时间 $T_{MR}$ 的和。根据期望的线性性质，总期望运行时间为 $E[T] = E[T_{TD}] + E[T_{MR}]$。我们将输入数 $n$ 建模为一个均匀随机整数，对于不同的素数 $p$，事件“$p$ 整除 $n$”被视为相互独立的，且 $P(p|n) = 1/p$。\n\n**1.1. 期望试除成本, $E[T_{TD}]$**\n\n设小于或等于阈值 $B$ 的素数按升序排列为 $p_1, p_2, \\dots, p_m$。试除法算法按顺序测试是否能被每个 $p_i$ 整除，并在找到因数时停止。单次除法成本为 $c_d$。\n\n- 对 $p_1$ 的测试总是会执行。成本：$c_d$。\n- 仅当 $p_1$ 不能整除 $n$ 时，才会执行对 $p_2$ 的测试。在我们的模型下，这种情况发生的概率为 $(1 - 1/p_1)$。期望成本：$c_d (1 - 1/p_1)$。\n- 一般地，仅当 $n$ 不能被任何前面的素数 $p_1, \\dots, p_{i-1}$ 整除时，才会执行对 $p_i$ 的测试。这个“存活”事件的概率是 $S_{i-1} = \\prod_{j=1}^{i-1} (1 - 1/p_j)$。由对 $p_i$ 的测试贡献的期望成本是 $c_d S_{i-1}$。\n\n如规定，总的期望试除次数是每次测试前存活概率的总和。对于阈值 $B=p_m$，总的期望试除成本是直到 $p_m$ 的每次素数测试的期望成本之和：\n$$ E[T_{TD}](B) = \\sum_{i=1}^{m} c_d \\prod_{j=1}^{i-1} \\left(1 - \\frac{1}{p_j}\\right) $$\n其中空集上的乘积（对于 $i=1$）定义为 $1$。\n\n**1.2. 期望 Miller-Rabin 成本, $E[T_{MR}]$**\n\n仅当数字 $n$ 通过了所有素数 $p \\le B$ 的试除后，才会执行 Miller-Rabin 测试。此事件的概率是在测试完所有 $m$ 个素数后的存活概率：\n$$ P(\\text{通过 TD}) = \\prod_{j=1}^{m} \\left(1 - \\frac{1}{p_j}\\right) $$\n使用 $k$ 个底数执行 Miller-Rabin 测试的成本为 $C_{MR} = k \\cdot c_{mr} \\cdot (\\log_2 n)^3$。只有在试除阶段没有找到因数时，才会产生此成本。\n因此，期望 Miller-Rabin 成本为：\n$$ E[T_{MR}](B) = C_{MR} \\cdot P(\\text{通过 TD}) = \\left( k \\cdot c_{mr} \\cdot (\\log_2 n)^3 \\right) \\cdot \\prod_{p \\le B} \\left(1 - \\frac{1}{p}\\right) $$\n\n**1.3. 总期望运行时间, $E(B)$**\n\n结合这两个部分，作为阈值 $B$ 的函数的总期望运行时间为：\n$$ E(B) = c_d \\sum_{i=1}^{\\pi(B)} \\prod_{j=1}^{i-1} \\left(1 - \\frac{1}{p_j}\\right) + \\left( k \\cdot c_{mr} \\cdot (\\log_2 n)^3 \\right) \\cdot \\prod_{j=1}^{\\pi(B)} \\left(1 - \\frac{1}{p_j}\\right) $$\n其中 $\\pi(B)$ 是小于或等于 $B$ 的素数个数，$p_j$ 是第 $j$ 个素数。对于 $B=0$ 的情况，不执行试除，因此第一项（和）为 $0$。第二项的乘积是空集上的乘积，结果为 $1$，得出 $E(0) = k \\cdot c_{mr} \\cdot (\\log_2 n)^3$。\n\n### 2. 最优阈值选择算法\n\n为了找到最小化 $E(B)$ 的最优阈值 $B$，我们在离散集合 $\\{0\\} \\cup \\{p \\in \\mathbb{P} \\mid p \\leq B_{\\max}\\}$ 上进行搜索。我们可以为每个候选素数高效地计算 $E(B)$。\n\n1.  使用筛法（如 Eratosthenes 筛法）生成所有直到 $B_{\\max}$ 的素数。\n2.  计算恒定的 Miller-Rabin 成本因子 $C'_{MR} = k \\cdot c_{mr} \\cdot (\\log_2 n)^3$。对于 $n \\le 1$ 的情况，由于 $\\log_2 n$ 是非正数或未定义的，且其素性是平凡的，此成本取为 $0$。\n3.  将 `optimal_B` 初始化为 $0$，`min_cost` 初始化为 $E(0) = C'_{MR}$。\n4.  遍历生成的直到 $B_{\\max}$ 的素数 $p_i$。在每次迭代中，我们更新期望试除成本和存活概率，以计算当前素数作为阈值时的总成本。\n    - 设 $E_{TD}(p_{i-1})$ 为阈值为 $p_{i-1}$ 时的期望试除成本，$S_{i-1}$ 为存活概率。\n    - 阈值为 $p_i$ 时的期望试除成本为 $E_{TD}(p_i) = E_{TD}(p_{i-1}) + c_d \\cdot S_{i-1}$。\n    - 新的存活概率为 $S_i = S_{i-1} \\cdot (1 - 1/p_i)$。\n    - 总成本为 $E(p_i) = E_{TD}(p_i) + C'_{MR} \\cdot S_i$。\n5.  如果 $E(p_i)$ 小于 `min_cost`，则将 `min_cost` 更新为 $E(p_i)$，并将 `optimal_B` 更新为 $p_i$。\n6.  最终的 `optimal_B` 就是所求的阈值。\n\n### 3. 素性测试算法\n\n对于一个给定的整数 $n$ 和一个优化后的阈值 $B$，素性测试按以下步骤进行：\n\n1.  **基础情况**：\n    - 如果 $n  2$，$n$ 不是素数。\n    - 如果 $n=2$ 或 $n=3$，$n$ 是素数。\n    - 如果 $n > 2$ 且 $n$ 是偶数，$n$ 不是素数。\n\n2.  **试除阶段**：\n    - 试除的上限是 $L = \\min(B, \\lfloor\\sqrt{n}\\rfloor)$。\n    - 遍历从 $3$ 到 $L$ 的所有素数 $p$。如果任何一个 $p$ 能整除 $n$，则 $n$ 是合数，测试终止。\n\n3.  **确定性 Miller-Rabin 阶段**：\n    - 仅当在试除阶段没有找到素因数时，才执行此阶段。\n    - 如果试除上限 $L$ 是 $\\lfloor\\sqrt{n}\\rfloor$，那么不存在素因数，$n$ 确定是素数。\n    - 否则，$L=B  \\lfloor\\sqrt{n}\\rfloor$，我们必须进行更稳健的测试。这里使用 Miller-Rabin 测试。\n    - **底数的合理性证明**：对于整数 $n  2^{64}$，通过测试一个特定的、小的底数集合，可以使 Miller-Rabin 测试变为确定性的（即保证正确）。经计算验证，对于任何合数 $n  2^{64}$，集合 $\\{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37\\}$ 中的至少一个素数会成为其合数性质的 Miller-Rabin 见证数。因此，我们使用这 $12$ 个底数。如果 $n$ 通过了所有这些底数的测试，则可以保证 $n$ 是素数。问题描述中的参数 $k$ 仅用于成本模型，并不决定最终确定性实现中底数的数量。\n    - **测试逻辑**：要用底数 $a$ 测试 $n$，我们首先将 $n-1$ 写成 $d \\cdot 2^s$ 的形式（其中 $d$ 为奇数）。如果我们找到一个底数 $a$，使得 $a^d \\not\\equiv 1 \\pmod{n}$ 并且对于 $[0, s-1)$ 中的所有整数 $r$ 都有 $a^{d \\cdot 2^r} \\not\\equiv -1 \\pmod{n}$，那么 $n$ 就是合数。如果 $n$ 通过了我们确定性集合中所有底数的此项测试，那么它就是素数。\n\n### 4. 实现与测试用例应用\n\n所述算法用 Python 实现。为了提高效率，使用 NumPy 布尔数组实现了一个筛法。模幂运算由 Python 的内置函数 `pow(base, exp, mod)` 处理。主程序遍历提供的测试用例，为每个用例计算最优阈值 $B$，使用此 $B$ 对 $n$ 进行素性测试，并按规定格式化结果。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\nimport math\n\ndef solve():\n    \"\"\"\n    Main function to solve the primality testing problem for all test cases.\n    It orchestrates the optimization of the threshold B and the primality test itself.\n    \"\"\"\n\n    # Pre-compute primes up to the maximum B_max specified in test cases.\n    # The largest b_max is 10000.\n    sieve_limit = 10000\n    primes_sieve = _sieve_primes(sieve_limit)\n\n    def find_optimal_b(n, k, cd, cmr, b_max, primes):\n        \"\"\"\n        Finds the optimal trial division threshold B to minimize the modeled expected runtime.\n\n        The expected runtime E(B) is the sum of expected trial division cost and\n        the expected Miller-Rabin cost.\n        E(B) = E_td(B) + E_mr(B)\n             = c_d * sum_{i=1 to pi(B)} [prod_{j=1 to i-1} (1-1/p_j)] +\n               (k * c_mr * (log2(n))^3) * prod_{j=1 to pi(B)} (1-1/p_j)\n        \"\"\"\n        # For n = 1, primality is trivial and log2(n) is problematic.\n        # The cost model implies E(B) = E_td(B) which is minimized at B=0.\n        if n = 1:\n            return 0\n        \n        c_mr_base = k * cmr * (math.log2(n) ** 3)\n        \n        # Start with the cost for B=0 (only Miller-Rabin test).\n        min_cost = c_mr_base\n        optimal_b = 0\n        \n        # Iteratively calculate cost for B = next prime in the sieve.\n        expected_td_cost_sum = 0.0\n        survival_prob = 1.0\n        \n        for p in primes:\n            if p > b_max:\n                break\n            \n            # Update the expected trial division cost.\n            # E_td(p_i) = E_td(p_{i-1}) + c_d * (survival probability before dividing by p_i)\n            # The running sum `expected_td_cost_sum` represents E_td(p).\n            expected_td_cost_sum += survival_prob * cd\n            \n            # Update survival probability for passing the test with the current prime p.\n            survival_prob *= (1.0 - 1.0 / float(p))\n            \n            # Total expected cost for the current threshold B=p.\n            current_total_cost = expected_td_cost_sum + c_mr_base * survival_prob\n            \n            if current_total_cost  min_cost:\n                min_cost = current_total_cost\n                optimal_b = int(p)\n                \n        return optimal_b\n\n    def is_prime(n, b, primes):\n        \"\"\"\n        Performs primality testing on n using trial division up to threshold b,\n        followed by a deterministic Miller-Rabin test for n  2^64.\n        \"\"\"\n        if n  2: return False\n        if n == 2 or n == 3: return True\n        if n % 2 == 0 or n % 3 == 0: return False\n\n        # Phase 1: Trial Division\n        # The actual bound for trial division is min(B, sqrt(n)).\n        td_limit = min(b, math.isqrt(n))\n        \n        # We can iterate through the pre-computed primes for efficiency.\n        # Primes start at 2. We already handled 2 and 3.\n        for p in primes:\n            if p > td_limit:\n                break\n            if p = 3: # Already checked\n                continue\n            if n % p == 0:\n                return False\n\n        # If trial division covered all primes up to sqrt(n), the number is prime.\n        if b >= math.isqrt(n):\n            return True\n\n        # Phase 2: Deterministic Miller-Rabin Test for n  2^64\n        # We write n - 1 = d * 2^s where d is odd.\n        d = n - 1\n        s = 0\n        while d % 2 == 0:\n            d //= 2\n            s += 1\n        \n        # This set of bases is proven to be sufficient for a deterministic test for all n  2^64.\n        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]\n        \n        for a in bases:\n            if a >= n:\n                break\n            \n            x = pow(a, d, n)\n            if x == 1 or x == n - 1:\n                continue\n            \n            # Loop for s-1 times\n            composite = True\n            for _ in range(s - 1):\n                x = pow(x, 2, n)\n                if x == n - 1:\n                    composite = False\n                    break\n            \n            if composite:\n                return False # n is definitely composite\n\n        return True # n is deterministically prime\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (1, 7, 1.0, 0.2, 10000),\n        (2, 7, 1.0, 0.2, 10000),\n        (221, 7, 1.0, 0.2, 10000),\n        (3215031751, 7, 1.0, 0.2, 10000),\n        (2305843009213693951, 7, 1.0, 0.2, 10000),\n        (1000000000000000000, 7, 0.5, 2.0, 10000)\n    ]\n\n    results = []\n    for n, k, cd, cmr, b_max in test_cases:\n        optimal_b = find_optimal_b(n, k, cd, cmr, b_max, primes_sieve)\n        is_n_prime = is_prime(n, optimal_b, primes_sieve)\n        results.append([optimal_b, is_n_prime])\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\".replace(\" \", \"\"))\n\ndef _sieve_primes(limit):\n    \"\"\"\n    Generates primes up to a given limit using a Sieve of Eratosthenes.\n    Helper function using NumPy for efficiency.\n    \"\"\"\n    if limit  2:\n        return np.array([], dtype=int)\n    primes_mask = np.ones(limit + 1, dtype=bool)\n    primes_mask[0:2] = False\n    for i in range(2, int(np.sqrt(limit)) + 1):\n        if primes_mask[i]:\n            primes_mask[i*i::i] = False\n    return np.where(primes_mask)[0]\n\nsolve()\n```", "id": "3260252"}]}