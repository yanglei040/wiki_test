{"hands_on_practices": [{"introduction": "本练习旨在将一个基本的几何定义——沃罗诺伊图（Voronoi diagram）——直接转化为一个计算解法 [@problem_id:3223457]。通过在一个离散网格上使用曼哈顿（$L_1$）距离，你将探索空间如何根据与一组站点的邻近性被划分，从而在一个清晰且可触摸的情境中巩固沃罗诺伊图的核心概念。", "problem": "给定平面上的一个有限站点集合，每个站点都具有整数坐标，以及一个具有整数端点的矩形域。对于给定的曼哈顿（也称为 $L_1$）距离，站点的受限 Voronoi 单元是域的一个子集，由所有比其他任何站点更接近该站点的点组成，其中距离相等的情况将确定性地处理。您的任务是针对多个测试用例，计算限制在矩形域整数格点上的离散 $L_1$ Voronoi 图，并报告分配给每个站点的格点数量。\n\n定义和假设：\n- 两点 $(x,y)$ 和 $(a,b)$ 之间的曼哈顿距离是 $d_1\\big((x,y),(a,b)\\big) = |x-a| + |y-b|$。\n- 给定一个站点集合 $S = \\{p_1, p_2, \\dots, p_k\\}$，其中 $p_i = (x_i, y_i)$，以及一个矩形域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$，$p_i$ 的离散受限 Voronoi 单元是\n$$\nV_R(p_i) = \\left\\{(x,y) \\in \\mathbb{Z}^2 : x_{\\min} \\le x \\le x_{\\max},\\ y_{\\min} \\le y \\le y_{\\max},\\ d_1\\big((x,y),p_i\\big) \\le d_1\\big((x,y),p_j\\big)\\ \\text{for all}\\ j \\in \\{1,\\dots,k\\}\\right\\}。\n$$\n- 距离相等时由最小的站点索引决定：如果点 $(x,y)$ 使得 $d_1\\big((x,y),p_i\\big) = d_1\\big((x,y),p_j\\big)$ 对于多个 $i$ 成立，那么 $(x,y)$ 将被分配给这些最小化距离的站点中索引最小的那个。\n- 所有坐标均为整数；不涉及物理单位。\n\n您的程序必须根据第一性原理实现以下内容：\n- 对于每个测试用例，遍历 $R$ 中的所有整数格点，并根据曼哈顿距离规则和距离相等时的处理规则将每个点精确地分配给一个站点。\n- 对于每个测试用例，输出一个长度为 $k$ 的整数列表，其中第 $i$ 个整数是分配给站点 $p_i$ 的格点数量。\n\n测试套件（每个用例由一个域和按指定顺序排列的站点列表组成）：\n- 用例 1：$R = [0,8] \\times [0,8]$，$S = \\{(1,1),(6,2),(5,7)\\}$。\n- 用例 2：$R = [0,6] \\times [0,6]$，$S = \\{(2,2),(4,4),(6,2)\\}$。\n- 用例 3：$R = [0,6] \\times [0,6]$，$S = \\{(3,3)\\}$。\n- 用例 4：$R = [0,5] \\times [0,5]$，$S = \\{(-1,2),(7,2),(2,-1),(2,7)\\}$。\n\n要求的最终输出格式：\n- 您的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果。顶层列表为每个测试用例包含一个内部列表，顺序与上述相同，每个内部列表按该用例中站点的给定顺序列出站点计数。例如，一个包含两个用例的有效输出字符串应类似于 $[[a_1,a_2],[b_1,b_2,b_3]]$，不含空格。\n- 不得打印任何额外文本。\n\n约束和期望：\n- 使用距离和 Voronoi 单元的基本定义来证明您的方法。避免使用快捷公式或依赖外部专门的计算几何例程。\n- 您的算法必须在给定矩形内的整数格点上操作，并遵守确定性的距离相等处理规则。\n- 每个测试用例的答案是一个整数列表。聚合的单行输出是这些列表的列表。", "solution": "对问题陈述进行验证。\n\n### 步骤 1：提取给定信息\n- **任务**：在离散、受限的 $L_1$ Voronoi 图中，计算分配给每个站点的整数格点数量。\n- **站点集合**：一个有限集合 $S = \\{p_1, p_2, \\dots, p_k\\}$，其中每个站点 $p_i = (x_i, y_i)$ 都具有整数坐标。\n- **域**：一个矩形域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$，其中端点为整数。\n- **距离度量**：曼哈顿（$L_1$）距离，定义为 $d_1\\big((x,y),(a,b)\\big) = |x-a| + |y-b|$。\n- **Voronoi 单元定义**：站点 $p_i$ 的离散受限 Voronoi 单元是在域 $R$ 内的整数点 $(x,y)$ 的集合，这些点到 $p_i$ 的距离小于或等于到任何其他站点 $p_j$ 的距离。\n$$V_R(p_i) = \\left\\{(x,y) \\in \\mathbb{Z}^2 : x_{\\min} \\le x \\le x_{\\max},\\ y_{\\min} \\le y \\le y_{\\max},\\ d_1\\big((x,y),p_i\\big) \\le d_1\\big((x,y),p_j\\big)\\ \\text{for all}\\ j \\in \\{1,\\dots,k\\}\\right\\}$$\n- **距离相等处理规则**：如果一个点 $(x,y)$ 到多个站点的最小距离相同，则将其分配给输入站点列表中索引最小的那个站点。\n- **测试用例**：\n    1.  $R = [0,8] \\times [0,8]$，$S = \\{(1,1),(6,2),(5,7)\\}$。\n    2.  $R = [0,6] \\times [0,6]$，$S = \\{(2,2),(4,4),(6,2)\\}$。\n    3.  $R = [0,6] \\times [0,6]$，$S = \\{(3,3)\\}$。\n    4.  $R = [0,5] \\times [0,5]$，$S = \\{(-1,2),(7,2),(2,-1),(2,7)\\}$。\n- **输出**：一个单行字符串，表示一个列表的列表，其中每个内部列表包含给定测试用例中每个站点的整数点数。\n\n### 步骤 2：使用提取的给定信息进行验证\n- **科学依据**：该问题在计算几何学中有坚实的基础。Voronoi 图、曼哈顿距离和离散格点等概念是标准的数学和算法主题。\n- **适定性**：该问题是适定的。域是一个有限的整数点集。对于每个点，到每个站点的距离都是唯一定义的。距离相等处理规则是确定性的且详尽的，确保了域中的每个点都只被分配给一个站点。因此，存在唯一的解（计数的集合）。\n- **客观性**：问题陈述使用了精确、客观的数学语言，没有歧义或主观论断。\n- **缺陷检查**：该问题没有违反任何无效性标准。它在科学上是合理的，可形式化的，完整的，并且结构良好。\n\n### 步骤 3：结论与行动\n该问题是**有效的**。将提供一个解决方案。\n\n### 基于原理的解决方案\n该解决方案是所提供的离散、受限 Voronoi 图定义的直接实现。其核心原理是根据与一组站点 $S$ 的邻近度，对给定矩形域 $R$ 内的整数格点进行划分。\n\n设站点集合为 $S = \\{p_0, p_1, \\dots, p_{k-1}\\}$，其中索引对应于距离相等时的处理优先级。域 $R = [x_{\\min}, x_{\\max}] \\times [y_{\\min}, y_{\\max}]$ 定义了一个有限的整数点网格。我们必须考虑每个点 $q=(x,y)$，使得 $x \\in \\{x_{\\min}, \\dots, x_{\\max}\\}$ 且 $y \\in \\{y_{\\min}, \\dots, y_{\\max}\\}$。\n\n对于每个测试用例，算法按以下步骤进行：\n1.  将计数向量 $\\mathbf{c} = [c_0, c_1, \\dots, c_{k-1}]$ 初始化为全零。元素 $c_i$ 将存储分配给站点 $p_i$ 的总格点数。\n2.  生成域 $R$ 内的所有整数格点 $q=(x,y)$。\n3.  对于每个点 $q$，计算其到每个站点 $p_i \\in S$ 的曼哈顿距离 $d_1(q, p_i)$。将这些距离存储在一个序列 $D_q = (d_1(q,p_0), d_1(q,p_1), \\dots, d_1(q,p_{k-1}))$ 中。\n4.  确定 $q$ 被分配给哪个站点。这通过找到序列 $D_q$ 中对应最小值的索引 $i^*$ 来实现。问题规定，如果多个站点共享相同的最小距离，则选择索引最小的那个。在数学上，这表示为：\n    $$i^* = \\arg\\min_{i \\in \\{0, \\dots, k-1\\}} \\{d_1(q, p_i)\\}$$\n    根据约定，$\\arg\\min$ 函数返回第一个达到最小值的索引，从而满足了距离相等时的处理规则。\n5.  为分配的站点增加计数器：$c_{i^*} \\leftarrow c_{i^*} + 1$。\n6.  在遍历完域中所有点 $q$ 后，向量 $\\mathbf{c}$ 将包含每个站点的最终计数。\n\n这种暴力枚举在计算上是直接的，并直接反映了数学定义。为了高效实现，我们可以采用向量化。我们可以构建两个矩阵 $X$ 和 $Y$，表示网格上每个点的 $x$ 和 $y$ 坐标。对于每个站点 $p_i=(x_i, y_i)$，可以通过单次操作为整个网格计算出一个距离矩阵 $D_i$：$D_i = |X - x_i| + |Y - y_i|$。然后可以将这 $k$ 个距离矩阵堆叠成一个三维数组。接着可以沿站点维度应用 `argmin` 操作，生成一个二维分配矩阵，其中每个元素包含对应网格点的获胜站点的索引 $i^*$。最后，计算分配矩阵中每个索引的出现次数即可得到所需结果。这种向量化方法不是捷径，而是对逐点评估这一基本原则的计算高效实现。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Computes the number of lattice points in a restricted discrete L1 Voronoi diagram\n    for several test cases.\n    \"\"\"\n    # Define the test cases from the problem statement.\n    # Each case is a tuple: (domain, list_of_sites)\n    # Domain is a tuple: (x_min, x_max, y_min, y_max)\n    # Sites are given as a list of (x, y) tuples.\n    test_cases = [\n        # Case 1\n        (((0, 8), (0, 8)), [(1, 1), (6, 2), (5, 7)]),\n        # Case 2\n        (((0, 6), (0, 6)), [(2, 2), (4, 4), (6, 2)]),\n        # Case 3\n        (((0, 6), (0, 6)), [(3, 3)]),\n        # Case 4\n        (((0, 5), (0, 5)), [(-1, 2), (7, 2), (2, -1), (2, 7)]),\n    ]\n\n    all_results = []\n    for domain_spec, sites_list in test_cases:\n        (x_min, x_max), (y_min, y_max) = domain_spec\n        sites = np.array(sites_list, dtype=np.int32)\n        num_sites = len(sites)\n\n        # Create the integer lattice grid for the domain\n        x_range = np.arange(x_min, x_max + 1)\n        y_range = np.arange(y_min, y_max + 1)\n        grid_x, grid_y = np.meshgrid(x_range, y_range)\n\n        # A list to hold the distance matrix for each site\n        all_dists = []\n\n        # For each site, calculate the L1 distance to every point in the grid\n        for site in sites:\n            site_x, site_y = site\n            dist_matrix = np.abs(grid_x - site_x) + np.abs(grid_y - site_y)\n            all_dists.append(dist_matrix)\n\n        # Stack the distance matrices into a 3D array (num_sites, height, width)\n        dist_stack = np.stack(all_dists, axis=0)\n\n        # Find the index of the site with the minimum distance for each grid point.\n        # np.argmin naturally handles the tie-breaking rule by returning the\n        # index of the first occurrence of the minimum value.\n        assignments = np.argmin(dist_stack, axis=0)\n\n        # Count the number of points assigned to each site.\n        # .flatten() turns the 2D assignment matrix into a 1D array.\n        # minlength ensures that even sites with 0 points are included in the count.\n        counts = np.bincount(assignments.flatten(), minlength=num_sites)\n        \n        all_results.append(counts.tolist())\n\n    # Final print statement in the exact required format: [[...],[...]]\n    # str() on a list adds spaces, so we remove them.\n    print(str(all_results).replace(\" \", \"\"))\n\nsolve()\n```", "id": "3223457"}, {"introduction": "本练习超越了直接定义，介绍了一种计算几何中强大的算法范式：扫描线算法 [@problem_id:3223497]。通过计算多个矩形的并集面积，你将学习如何将一个二维问题简化为一系列一维问题，并使用数据结构来管理活跃区间。这项技术是高效解决各种几何问题的基础。", "problem": "给定欧几里得平面上有限个坐标轴对齐的矩形。每个矩形由四个整数 $(x_1, y_1, x_2, y_2)$ 指定，其中 $x_1 \\le x_2$ 且 $y_1 \\le y_2$，分别表示左下角 $(x_1, y_1)$ 和右上角 $(x_2, y_2)$。若矩形满足 $x_1 = x_2$ 或 $y_1 = y_2$，则其面积为零，对并集面积没有贡献。任务是利用基于计算几何学基本原理的平面扫描算法，高效地计算这些矩形并集的面积。\n\n基本原理和要求：\n- 平面上一组集合的并集面积是该并集的二维勒贝格测度。对于坐标轴对齐的矩形，在通常的欧几里得度量下，其并集面积是有限且良定义的。\n- 矩形是闭集，但只要所有矩形使用相同的约定，无论对坐标轴对齐的矩形选择闭、开还是半开的边界约定，并集面积都是不变的，因为边界的测度为零。\n- 一种有效的方法是，构想一条垂直线沿 $x$ 轴扫描，同时维护当前有效 $y$ 区间并集的总长度。在两个连续的 $x$ 坐标位置之间累积的面积，等于该条带的水平距离乘以其覆盖的 $y$ 长度。\n\n您的程序必须实现一个沿 $x$ 轴的高效平面扫描算法，并使用合适的数据结构（如带有坐标压缩的线段树（ST））来维护 $y$ 区间并集的长度。对于 $n$ 个矩形，目标渐进时间复杂度为 $O(n \\log n)$。您必须处理重复矩形、嵌套矩形、不相交矩形、边缘接触、零面积矩形、负坐标以及不会超出典型 64 位整数范围的大坐标值。\n\n测试套件：\n为以下每个独立的测试用例计算并集面积。在每个测试用例中，输入是一系列矩形，以 $(x_1,y_1,x_2,y_2)$ 四元组的形式给出。\n\n- 测试用例 $1$：$\\big((0,0,3,2),(2,1,5,4),(1,3,4,5)\\big)$\n- 测试用例 $2$：$\\big((0,0,2,1),(2,0,4,1)\\big)$\n- 测试用例 $3$：$\\big((0,0,10,10),(2,2,8,8)\\big)$\n- 测试用例 $4$：$\\big((0,0,1,1),(3,3,4,5)\\big)$\n- 测试用例 $5$：$\\big((0,0,2,2),(1,1,1,5),(2,2,5,2)\\big)$\n- 测试用例 $6$：$\\big((-3,-1,-1,2),(-2,1,1,3)\\big)$\n- 测试用例 $7$：$\\big((0,0,100000000,1),(50000000,0,150000000,1)\\big)$\n- 测试用例 $8$：$\\big((0,0,3,1),(0,1,3,2),(0,2,3,3),(1,-1,2,4)\\big)$\n\n输出规范：\n您的程序应生成单行输出，其中包含一个用方括号括起来的逗号分隔列表。第 $i$ 个条目是第 $i$ 个测试用例的并集面积，表示为一个整数。例如，格式必须严格符合 $\\texttt{[a_1,a_2,\\dots,a_8]}$，其中 $a_i$ 表示为第 $i$ 个测试用例计算出的面积。", "solution": "该问题是使用扫描线算法解决的，这是一种计算几何中的标准技术。算法的核心思想是将二维的面积问题转化为一系列一维的长度问题。\n\n1.  **事件点与扫描线**：我们将一条垂直的“扫描线”从左到右扫过整个平面。只有在扫描线遇到矩形的左边界或右边界时，矩形并集在扫描线上的垂直剖面才会发生变化。因此，我们将每个矩形的左、右两条垂直边定义为“事件点”。左边界是“进入”事件，右边界是“离开”事件。所有事件点都按其 $x$ 坐标排序。\n\n2.  **坐标压缩**：由于矩形的 $y$ 坐标可能很大或分布稀疏，我们只关心它们之间的相对顺序。我们将所有矩形上下边的 $y$ 坐标收集起来，排序并去重，形成一个唯一的 $y$ 坐标列表。这个列表将平面划分为一系列基础的水平“条带”。这一步称为坐标压缩，它使得我们可以用一个较小的索引范围来代表这些 $y$ 坐标，从而高效地构建数据结构。\n\n3.  **线段树**：我们使用一棵线段树来维护扫描线上被矩形覆盖的 $y$ 区间的总长度。线段树的每个叶节点对应于坐标压缩后得到的一个基础水平条带。树中的每个节点存储两个信息：\n    -   `count`：该节点所代表的 $y$ 区间被多少个“活跃”矩形完全覆盖。\n    -   `length`：该节点所代表的 $y$ 区间中，实际被覆盖的总长度。如果 `count > 0`，则 `length` 等于该区间的全长；否则，`length` 等于其子节点 `length` 之和。\n\n4.  **扫描过程**：\n    -   算法按 $x$ 坐标顺序处理每个事件。\n    -   在处理两个连续事件 $x_{i-1}$ 和 $x_i$ 之间的“板坯”区域时，扫描线上的覆盖情况是不变的。该板坯对总面积的贡献是 $(x_i - x_{i-1}) \\times \\text{covered\\_length}$，其中 `covered_length` 是线段树根节点的 `length` 值，代表当前扫描线上被覆盖的总长度。\n    -   在每个事件 $x_i$ 处，我们根据事件类型更新线段树。如果是矩形的左边界（进入事件），我们对该矩形跨越的 $y$ 区间范围在线段树中执行“增加”操作（`count` 加 1）。如果是右边界（离开事件），则执行“减少”操作（`count` 减 1）。\n    -   每次更新后，线段树会重新计算每个节点的 `length`，确保根节点的 `length` 值始终是当前扫描线上覆盖的总长度。\n\n5.  **复杂度分析**：对于 $n$ 个矩形，我们有 $2n$ 个事件点和最多 $2n$ 个唯一的 $y$ 坐标。对事件点排序需要 $O(n \\log n)$ 时间。线段树构建在 $O(n)$ 个基础区间上。对于每个事件，线段树的更新或查询操作需要 $O(\\log n)$ 时间。因此，总时间复杂度为 $O(n \\log n)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the union area of rectangles problem for a suite of test cases.\n    \"\"\"\n\n    test_cases = [\n        # Test case 1\n        [(0, 0, 3, 2), (2, 1, 5, 4), (1, 3, 4, 5)],\n        # Test case 2\n        [(0, 0, 2, 1), (2, 0, 4, 1)],\n        # Test case 3\n        [(0, 0, 10, 10), (2, 2, 8, 8)],\n        # Test case 4\n        [(0, 0, 1, 1), (3, 3, 4, 5)],\n        # Test case 5\n        [(0, 0, 2, 2), (1, 1, 1, 5), (2, 2, 5, 2)],\n        # Test case 6\n        [(-3, -1, -1, 2), (-2, 1, 1, 3)],\n        # Test case 7\n        [(0, 0, 100000000, 1), (50000000, 0, 150000000, 1)],\n        # Test case 8\n        [(0, 0, 3, 1), (0, 1, 3, 2), (0, 2, 3, 3), (1, -1, 2, 4)],\n    ]\n\n    results = []\n    for rectangles in test_cases:\n        area = calculate_union_area(rectangles)\n        results.append(area)\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(map(str, results))}]\")\n\ndef calculate_union_area(rectangles):\n    \"\"\"\n    Calculates the area of the union of a list of axis-aligned rectangles.\n    \n    This function implements a plane sweep algorithm with a segment tree.\n    \"\"\"\n    events = []\n    y_coords = set()\n\n    for x1, y1, x2, y2 in rectangles:\n        # Per the problem statement, zero-area rectangles do not contribute.\n        if x1  x2 and y1  y2:\n            events.append((x1, y1, y2, 1))  # 1 for enter\n            events.append((x2, y1, y2, -1)) # -1 for leave\n            y_coords.add(y1)\n            y_coords.add(y2)\n\n    if not events:\n        return 0\n\n    # Sort events by x-coordinate\n    events.sort()\n\n    # Coordinate compression for y-coordinates\n    all_y = sorted(list(y_coords))\n    y_map = {y: i for i, y in enumerate(all_y)}\n    \n    num_y_intervals = len(all_y) - 1\n    if num_y_intervals = 0:\n        return 0\n\n    # Segment tree represented by numpy arrays.\n    # The size 4 * num_y_intervals is a safe upper bound for a segment tree.\n    counts = np.zeros(4 * num_y_intervals, dtype=int)\n    lengths = np.zeros(4 * num_y_intervals, dtype=int)\n\n\n    def update_segment_tree(node_idx, node_start, node_end, update_start, update_end, value):\n        \"\"\"Recursively update the segment tree.\"\"\"\n        # The range this node represents is [node_start, node_end].\n        # The range to update is [update_start, update_end].\n\n        # If the update range is outside the node's range, do nothing.\n        if update_start > node_end or update_end  node_start:\n            return\n\n        # If the node's range is completely within the update range.\n        if update_start = node_start and node_end = update_end:\n            counts[node_idx] += value\n        # Otherwise, recurse on children.\n        else:\n            mid = (node_start + node_end) // 2\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            update_segment_tree(left_child_idx, node_start, mid, update_start, update_end, value)\n            update_segment_tree(right_child_idx, mid + 1, node_end, update_start, update_end, value)\n        \n        # After updating counts, recalculate the covered length for this node.\n        if counts[node_idx] > 0:\n            # This node's entire y-interval range is covered.\n            lengths[node_idx] = all_y[node_end + 1] - all_y[node_start]\n        elif node_start == node_end:\n            # Leaf node with count 0 has 0 covered length.\n            lengths[node_idx] = 0\n        else:\n            # Internal node with count 0: covered length is sum of children's.\n            left_child_idx = 2 * node_idx + 1\n            right_child_idx = 2 * node_idx + 2\n            lengths[node_idx] = lengths[left_child_idx] + lengths[right_child_idx]\n\n\n    total_area = 0\n    last_x = events[0][0]\n\n    for event in events:\n        current_x, y1, y2, type_val = event\n        \n        # Calculate the area of the slab between last_x and current_x\n        dx = current_x - last_x\n        if dx > 0:\n            covered_length = lengths[0]  # Root of the segment tree\n            total_area += covered_length * dx\n        \n        # Process the current event by updating the segment tree\n        y1_idx = y_map[y1]\n        y2_idx = y_map[y2]\n\n        # The update is for the range of intervals [y1_idx, y2_idx - 1]\n        if y1_idx  y2_idx:\n            update_segment_tree(0, 0, num_y_intervals - 1, y1_idx, y2_idx - 1, type_val)\n\n        last_x = current_x\n        \n    return total_area\n\n# Execute the solution\nsolve()\n\n```", "id": "3223497"}, {"introduction": "这最后一个练习旨在挑战你解决一个几何优化问题：找到两个凸多边形之间的最短距离 [@problem_id:3223483]。该解决方案要求你将复杂问题分解为更简单的子问题，即找到边与边之间的距离。本练习将磨练你应用几何推理和系统性案例分析来寻找最优解的能力。", "problem": "给定欧几里得平面上的两个封闭、严格不相交的凸多边形。对于每对多边形，您必须计算一个最短的连接线段（“桥”），其一个端点在多边形 $A$ 的边界上，另一个端点在多边形 $B$ 的边界上。此问题必须从计算几何的第一性原理出发解决，除了基本的向量算术外，不得依赖任何专门的第三方库。\n\n需要使用的基本依据和定义如下。一个凸多边形 $P$ 是 $\\mathbb{R}^2$ 中的一个紧凸子集，由有限个点的凸包给出；它可以由一个逆时针（CCW）顺序的顶点循环序列表示，其中连续的顶点由直线段连接，最后一个顶点连接回第一个顶点。向量 $x$ 的欧几里得范数为 $\\lVert x \\rVert_2 = \\sqrt{x_1^2 + x_2^2}$。两个非空集合 $X,Y \\subset \\mathbb{R}^2$ 之间的距离是 $d(X,Y) = \\inf\\{\\lVert x - y \\rVert_2 : x \\in X, y \\in Y\\}$。对于封闭、不相交的凸集，这个下确界至少可以由一对点达到。点 $p$ 和 $q$ 之间的线段是集合 $\\{(1 - t)p + tq : t \\in [0,1]\\}$。\n\n您的任务。对于下面的每个测试用例，执行以下操作：\n- 计算一对点 $(p^\\star, q^\\star)$，其中 $p^\\star \\in \\partial A$ 且 $q^\\star \\in \\partial B$，使得欧几里得距离 $\\lVert p - q \\rVert_2$ 在所有 $p \\in \\partial A$，$q \\in \\partial B$ 中最小。这里 $\\partial A$ 和 $\\partial B$ 表示多边形的边界。\n- 在所有最小化距离的点对中，按如下方式打破平局：选择在 $A$ 上的点是字典序最小的点对，如果仍然存在平局，则选择在 $B$ 上的点是字典序最小的点对。其中，点的字典序定义为：如果 $x_1  x_2$ 或 ($x_1 = x_2$ 且 $y_1  y_2$)，则 $(x_1,y_1) \\prec (x_2,y_2)$。\n- 报告桥的端点及其长度。\n\n不需要角度单位。不涉及物理单位。所需的数值输出必须四舍五入到 $6$ 位小数。\n\n此问题的输入模型固定在程序内部；不要读取任何外部输入。您必须使用以下凸多边形测试套件，每个多边形都以逆时針顺序的顶点有序列表给出，且末尾不重复第一个顶点。\n\n测试套件：\n- 测试用例 $1$：\n  - 多边形 $A$：$[(-2,-1),(-2,1),(-1,1),(-1,-1)]$。\n  - 多边形 $B$：$[(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]$。\n- 测试用例 $2$：\n  - 多边形 $A$：$[(0,0),(1,1),(0,2)]$。\n  - 多边形 $B$：$[(3,0.5),(3,1.5),(5,1.5),(5,0.5)]$。\n- 测试用例 $3$：\n  - 多边形 $A$：$[(0,0),(0,1),(4,1),(4,0)]$。\n  - 多边形 $B$：$[(1,3),(1,4),(5,4),(5,3)]$。\n- 测试用例 $4$：\n  - 多边形 $A$：$[(0,0),(0,1),(1,1),(1,0)]$。\n  - 多边形 $B$：$[(1.001,0),(1.001,1),(2.001,1),(2.001,0)]$。\n- 测试用例 $5$：\n  - 多边形 $A$：$[(0,0),(0,1),(1,1),(1,0)]$。\n  - 多边形 $B$：$[(3,3),(3,4),(4,4),(4,3)]$。\n\n要求：\n- 对于每个测试用例，输出所选桥在 $A$ 上的端点坐标 $(p^\\star_x,p^\\star_y)$ 和在 $B$ 上的端点坐标 $(q^\\star_x,q^\\star_y)$，然后是桥的长度 $\\ell^\\star = \\lVert p^\\star - q^\\star \\rVert_2$，所有数值都四舍五入到 $6$ 位小数。\n- 最终输出格式必须是单行，包含一个类似 JSON 的列表的列表，每个测试用例一个，按顺序排列。每个内部列表的形式必须是 $[p^\\star_x,p^\\star_y,q^\\star_x,q^\\star_y,\\ell^\\star]$，所有数字都四舍五入到 $6$ 位小数。例如，一个包含两个结果的列表看起来像这样：$[[x_1,y_1,x_2,y_2,\\ell_1],[x_3,y_3,x_4,y_4,\\ell_2]]$。\n\n设计约束和指导：\n- 您的推理应基于基本定义：凸性、欧几里得范数以及紧集上连续函数的性质。\n- 您可以假定一个来自初等几何的众所周知且可验证的事实：两个不相交的闭凸多边形之间的距离是由位于它们边界上的一对点实现的，并且对于多边形，最小化点出现在边或顶点上。但是，您不得使用任何预先推导出的“捷径”公式来求最终距离。相反，您应通过在段参数的框约束下最小化二次型来推导两条线段之间的距离。\n- 为确保全面覆盖，给定的测试套件包括了最近点位于顶点到边、具有平行支撑线的边到边、顶点到顶点以及近乎接觸的情况。\n\n您的程序应生成单行输出，其中包含结果，格式为逗号分隔的内部列表列表，并用方括号括起来，与上述规定完全一致。", "solution": "问题要求我们找到欧几里得平面上两个不相交的闭凸多边形 $A$ 和 $B$ 之间的最短连接线段，即“桥”。对于每对多边形，我们必须在其各自的边界 $\\partial A$ 和 $\\partial B$ 上确定一对点 $(p^\\star, q^\\star)$，以最小化欧几里得距离 $\\lVert p - q \\rVert_2$。\n\n该解决方案基于几何学和优化的基本原理。由于多边形是凸的且紧的（即封闭且有界），根据 Weierstrass 极值定理，至少存在一对这样的最小化点。两个多边形之间的距离 $d(A, B)$ 是两个多边形所有可能的特征（顶点和边）对之间距离的最小值。这可以表示为：\n$$\nd(A, B) = \\min_{i,j} d(e_i, f_j)\n$$\n其中 $e_i$ 是多边形 $A$ 的一条边，$f_j$ 是多边形 $B$ 的一条边。这种方法是全面的，因为边与其他特征之间的距离隐含地覆盖了顶点到特征的距离，因为顶点是边的端点。\n\n问题的核心，根据提示的指导，是确定两条线段之间的距离。设线段 $e_A$ 由其端点 $p_1, p_2$ 定义，另一线段 $e_B$ 由 $q_1, q_2$ 定义。$e_A$ 上的任意点可以参数化为 $p(s) = p_1 + s(p_2 - p_1)$，其中 $s \\in [0,1]$；$e_B$ 上的任意点可以参数化为 $q(t) = q_1 + t(q_2 - q_1)$，其中 $t \\in [0,1]$。\n\n我们的目标是最小化平方欧几里得距离 $D^2(s,t) = \\lVert p(s) - q(t) \\rVert_2^2$，约束条件为 $s,t \\in [0,1]$。令 $u = p_2 - p_1$，$v = q_2 - q_1$，$w_0 = p_1 - q_1$。平方距离为：\n$$\nD^2(s,t) = \\lVert w_0 + su - tv \\rVert_2^2 = (w_0+su-tv) \\cdot (w_0+su-tv)\n$$\n这是 $s$ 和 $t$ 的二次函数：\n$$\nF(s,t) = (u \\cdot u)s^2 - 2(u \\cdot v)st + (v \\cdot v)t^2 + 2(w_0 \\cdot u)s - 2(w_0 \\cdot v)t + (w_0 \\cdot w_0)\n$$\n由于该函数是凸函数，其在定义域 $[0,1] \\times [0,1]$ 上的最小值要么出现在梯度为零的内部临界点，要么出现在定义域的边界上。\n\n临界点 $(s_0, t_0)$ 通过求解线性方程组 $\\nabla F(s,t) = 0$ 得到：\n$$\n\\begin{cases}\n(u \\cdot u) s - (u \\cdot v) t = -w_0 \\cdot u \\\\\n-(u \\cdot v) s + (v \\cdot v) t = w_0 \\cdot v\n\\end{cases}\n$$\n该方程组矩阵的行列式是 $(u \\cdot u)(v \\cdot v) - (u \\cdot v)^2$，根据 Cauchy-Schwarz 不等式，该值非负。如果行列式为正（即线段不平行），则存在唯一解 $(s_0, t_0)$。\n- 如果 $(s_0, t_0) \\in [0,1] \\times [0,1]$，则最短距离在内部点 $p(s_0)$ 和 $q(t_0)$ 之间。\n- 否则，最小值必定位于参数空间的边界上（即 $s \\in \\{0,1\\}$ 或 $t \\in \\{0,1\\}$）。这对应于计算一个线段的端点到另一条完整线段的距离。例如，设置 $s=0$ 将问题简化为求点 $p_1$到线段 $e_B$ 的最短距离。\n\n这为寻找两条线段之间距离提供了一个稳健的策略：\n1.  计算内部点对内部点的情况下的距离，仅当解出的参数 $(s_0, t_0)$ 在 $[0,1]^2$ 内时有效。\n2.  计算四个端点到线段的距离：$d(p_1, e_B)$、$d(p_2, e_B)$、$d(q_1, e_A)$ 和 $d(q_2, e_A)$。\n3.  这些潜在距离中的最小值就是两条线段之间的真正最小距离。这涵盖了所有情况：顶点-顶点、顶点-边和边-边。\n\n整个算法分两步进行：\n**第一步：确定最小距离。** 遍历多边形 $A$ 和 $B$ 的所有边对 $(e_i, f_j)$。对于每对边，使用上述线段-线段距离法计算它们的最小平方距离。全局最小平方距离 $\\ell^{\\star 2}$ 是所有边对计算出的这些值中的最小值。\n\n**第二步：识别所有最优的点对。** 再次遍历所有边对。对于每对边 $(e_i, f_j)$，找到这些线段上所有能达到距离 $\\ell^\\star$ 的点对 $(p,q)$。这需要仔细处理：\n-   如果最小值是由一个线段的端点和另一条线段上的一个点实现的，那么多个边对可能会识别出相同的最优对（因为一个顶点由两条边共享）。\n-   如果线段平行且它们的投影重叠，则存在一个连续的最优对集合。对于这种特殊情况，我们必须直接应用平局打破规则。选择边上字典序最小的点，这对应于它的一个端点。这样就从连续体中确定了一个唯一的最优点对。\n\n**平局打破：** 在收集了所有达到最小距离 $\\ell^\\star$ 的点对 $(p,q)$ 后，我们应用指定的平局打破规则。候选点对集合首先按点 $p \\in \\partial A$ 的字典序排序，然后，对于平局情况，按点 $q \\in \\partial B$ 的字典序排序。排序后列表中的第一对即为最终答案 $(p^\\star, q^\\star)$。这种两步走的方法确保我们在根据问题标准解决任何模糊性或多个解之前，正确地识别全局最小距离。\n\n最终的实现使用 `numpy` 进行向量运算，并严格遵守所描述的逻辑，同时使用一个小的容差 $\\epsilon$ 仔细处理浮点数比较。", "answer": "```python\nimport numpy as np\n\n# A small tolerance for floating-point comparisons\nEPSILON = 1e-9\n\ndef solve():\n    \"\"\"\n    Main function to solve the computational geometry problem for all test cases.\n    \"\"\"\n\n    def dist_point_segment_sq(p, a, b):\n        \"\"\"\n        Calculates the squared Euclidean distance from a point p to a line segment [a, b].\n        Returns the squared distance and the closest point on the segment.\n        \"\"\"\n        ab = b - a\n        ap = p - a\n        \n        len_sq = np.dot(ab, ab)\n        if len_sq  EPSILON:\n            return np.dot(ap, ap), a\n\n        t = np.dot(ap, ab) / len_sq\n        \n        if t  0.0:\n            closest_point = a\n        elif t > 1.0:\n            closest_point = b\n        else:\n            closest_point = a + t * ab\n            \n        dist_sq = np.dot(p - closest_point, p - closest_point)\n        return dist_sq, closest_point\n\n    def get_segment_pair_min_dist_sq(p1, p2, q1, q2):\n        \"\"\"\n        Calculates the minimum squared distance between two line segments [p1,p2] and [q1,q2].\n        \"\"\"\n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        \n        det = a * c - b * b\n        \n        # Start with a very large number\n        min_dist_sq = float('inf')\n\n        # Case 1: Interior to Interior (if not parallel)\n        if det > EPSILON:\n            s = (b * e - c * d) / det\n            t = (a * e - b * d) / det\n            if 0.0 = s = 1.0 and 0.0 = t = 1.0:\n                dist_sq = np.dot((p1 + s * u) - (q1 + t * v), (p1 + s * u) - (q1 + t * v))\n                min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        # Case 2: Endpoint to Segment\n        dist_sq, _ = dist_point_segment_sq(p1, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(p2, q1, q2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q1, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        dist_sq, _ = dist_point_segment_sq(q2, p1, p2)\n        min_dist_sq = min(min_dist_sq, dist_sq)\n        \n        return min_dist_sq\n\n    def find_segment_pair_optimal_points(p1, p2, q1, q2, target_dist_sq):\n        \"\"\"\n        Finds all pairs of points between two segments that achieve the target squared distance.\n        \"\"\"\n        optimal_pairs = []\n        \n        u = p2 - p1\n        v = q2 - q1\n        w = p1 - q1\n\n        a = np.dot(u, u)\n        b = np.dot(u, v)\n        c = np.dot(v, v)\n        d = np.dot(u, w)\n        e = np.dot(v, w)\n        det = a * c - b * b\n\n        # Case 1: Parallel Segments with Overlap\n        if det  EPSILON and b > 0: # Ensure they are not collinear and opposing\n            # Distance between parallel lines\n            dist_lines_sq = float('inf')\n            if c > EPSILON:\n                proj_p1_on_line_q = q1 + (np.dot(p1 - q1, v) / c) * v\n                dist_lines_sq = np.dot(p1 - proj_p1_on_line_q, p1 - proj_p1_on_line_q)\n\n            if abs(dist_lines_sq - target_dist_sq)  EPSILON:\n                # Find overlap interval\n                s_of_q1 = np.dot(q1 - p1, u) / a if a > EPSILON else 0.0\n                s_of_q2 = np.dot(q2 - p1, u) / a if a > EPSILON else 0.0\n                \n                s_overlap_min = max(0.0, min(s_of_q1, s_of_q2))\n                s_overlap_max = min(1.0, max(s_of_q1, s_of_q2))\n\n                if s_overlap_min = s_overlap_max + EPSILON:\n                    p1_lex_smaller = (p1[0]  p2[0]) or (abs(p1[0] - p2[0])  EPSILON and p1[1]  p2[1])\n                    s_best = s_overlap_min if p1_lex_smaller else s_overlap_max\n                    p_best = p1 + s_best * u\n                    t_best = np.dot(p_best - q1, v) / c if c > EPSILON else 0.0\n                    q_best = q1 + t_best * v\n                    optimal_pairs.append((p_best, q_best))\n                    \n        # Case 2: Interior to Interior (non-parallel)\n        if det > EPSILON:\n            s_opt = (b * e - c * d) / det\n            t_opt = (a * e - b * d) / det\n            if 0.0 = s_opt = 1.0 and 0.0 = t_opt = 1.0:\n                p_cand = p1 + s_opt * u\n                q_cand = q1 + t_opt * v\n                dist_sq = np.dot(p_cand - q_cand, p_cand - q_cand)\n                if abs(dist_sq - target_dist_sq)  EPSILON:\n                    optimal_pairs.append((p_cand, q_cand))\n        \n        # Case 3: Endpoint to Segment\n        dist_sq, q_on_seg = dist_point_segment_sq(p1, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p1, q_on_seg))\n            \n        dist_sq, q_on_seg = dist_point_segment_sq(p2, q1, q2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p2, q_on_seg))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q1, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q1))\n            \n        dist_sq, p_on_seg = dist_point_segment_sq(q2, p1, p2)\n        if abs(dist_sq - target_dist_sq)  EPSILON:\n            optimal_pairs.append((p_on_seg, q2))\n            \n        return optimal_pairs\n\n    test_cases = [\n        {'A': [(-2,-1),(-2,1),(-1,1),(-1,-1)], 'B': [(1,-0.5),(1,0.5),(2,0.5),(2,-0.5)]},\n        {'A': [(0,0),(1,1),(0,2)], 'B': [(3,0.5),(3,1.5),(5,1.5),(5,0.5)]},\n        {'A': [(0,0),(0,1),(4,1),(4,0)], 'B': [(1,3),(1,4),(5,4),(5,3)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(1.001,0),(1.001,1),(2.001,1),(2.001,0)]},\n        {'A': [(0,0),(0,1),(1,1),(1,0)], 'B': [(3,3),(3,4),(4,4),(4,3)]}\n    ]\n\n    final_results = []\n\n    for case in test_cases:\n        poly_A_verts = [np.array(v) for v in case['A']]\n        poly_B_verts = [np.array(v) for v in case['B']]\n\n        edges_A = [(poly_A_verts[i], poly_A_verts[(i + 1) % len(poly_A_verts)]) for i in range(len(poly_A_verts))]\n        edges_B = [(poly_B_verts[i], poly_B_verts[(i + 1) % len(poly_B_verts)]) for i in range(len(poly_B_verts))]\n        \n        # Pass 1: Find the minimum distance\n        min_dist_sq = float('inf')\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                dist_sq = get_segment_pair_min_dist_sq(p1, p2, q1, q2)\n                min_dist_sq = min(min_dist_sq, dist_sq)\n\n        # Pass 2: Collect all pairs achieving the minimum distance\n        candidate_pairs = []\n        for p1, p2 in edges_A:\n            for q1, q2 in edges_B:\n                pairs = find_segment_pair_optimal_points(p1, p2, q1, q2, min_dist_sq)\n                candidate_pairs.extend(pairs)\n        \n        # Apply tie-breaking rules\n        candidate_pairs.sort(key=lambda item: (item[0][0], item[0][1], item[1][0], item[1][1]))\n        \n        # Filter for unique pairs\n        unique_candidates = []\n        if candidate_pairs:\n            unique_candidates.append(candidate_pairs[0])\n            for i in range(1, len(candidate_pairs)):\n                p_curr, q_curr = candidate_pairs[i]\n                p_last, q_last = unique_candidates[-1]\n                if np.linalg.norm(p_curr - p_last) > EPSILON or np.linalg.norm(q_curr - q_last) > EPSILON:\n                    unique_candidates.append(candidate_pairs[i])\n\n        p_star, q_star = unique_candidates[0]\n        length = np.sqrt(min_dist_sq)\n\n        result = [\n            round(p_star[0], 6), round(p_star[1], 6),\n            round(q_star[0], 6), round(q_star[1], 6),\n            round(length, 6)\n        ]\n        final_results.append(result)\n\n    # Format output as a JSON-like string\n    output_str = \"[\" + \",\".join([f\"[{','.join(f'{x:.6f}' for x in r)}]\" for r in final_results]) + \"]\"\n    print(output_str)\n\nsolve()\n```", "id": "3223483"}]}