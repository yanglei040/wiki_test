{"hands_on_practices": [{"introduction": "对链表上的算法进行分析是一项基本功。本练习关注一个用于从已排序链表中移除重复元素的迭代算法。通过这个练习，你将学会如何通过建立一个循环不变量来精确地计算操作次数，并理解指针操作如何影响遍历过程，最终揭示算法的运行时间仅取决于列表的长度，而与具体的数据分布无关。[@problem_id:3207266]", "problem": "考虑一个包含 $n$ 个节点的单链表 $L$，其中每个节点存储一个整数键和一个指向下一个节点的指针。假设 $L$ 中的键按非递减顺序排序，因此所有重复的键都出现在连续的节点中。以下迭代算法会移除所有重复项，为每个不同的键只保留一个节点：\n\n- 设 $x$ 表示 $L$ 的头节点。\n- 当 $x \\neq \\text{null}$ 且 $x.\\text{next} \\neq \\text{null}$ 时：\n    - 如果 $x.\\text{key} = x.\\text{next}.\\text{key}$，则设置 $x.\\text{next} := x.\\text{next}.\\text{next}$。\n    - 否则，设置 $x := x.\\text{next}$。\n\n假设在标准的单位成本随机存取机（RAM）模型中，每次键比较（例如 $x.\\text{key} = x.\\text{next}.\\text{key}$）和每次指针赋值（例如 $x := x.\\text{next}$ 或 $x.\\text{next} := x.\\text{next}.\\text{next}$）都花费常数时间，记为 $O(1)$。在此模型下，对于任何符合给定假设的输入实例，从第一性原理推导出一个闭式表达式，表示该算法作为 $n$ 的函数所执行的键比较的确切次数。然后，根据该计数推导出该算法作为 $n$ 的函数的紧渐近时间复杂度（使用大$\\Theta$表示法）。将你的最终答案表示为一个使用大$\\Theta$表示法的单一解析表达式。", "solution": "该问题要求分析一个给定的迭代算法，该算法用于从一个已排序的单链表中移除重复项。分析必须首先得出一个表示键比较次数的确切闭式表达式，然后推导出使用大$\\Theta$表示法的紧渐近时间复杂度。\n\n设单链表为 $L$，由 $n$ 个节点组成。我们按顺序将原始节点表示为 $N_1, N_2, \\ldots, N_n$。设 $k_i$ 为存储在节点 $N_i$ 中的键。由于列表按非递减顺序排序，我们有 $k_1 \\le k_2 \\le \\ldots \\le k_n$。算法如下：\n1. 初始化一个指针 $x$ 指向列表的头节点 $N_1$。\n2. 当 $x \\neq \\text{null}$ 且 $x.\\text{next} \\neq \\text{null}$ 时循环。\n3. 在循环内部，比较 $x.\\text{key}$ 和 $x.\\text{next}.\\text{key}$。\n   a. 如果它们相等，则找到了一个重复项。通过设置 $x.\\text{next} := x.\\text{next}.\\text{next}$ 来移除节点 $x.\\text{next}$。指针 $x$ 保持在当前位置以检查更多的重复项。\n   b. 如果它们不相等，则 $x$ 的当前键没有重复项。通过设置 $x := x.\\text{next}$ 将指针 $x$ 前移到下一个节点。\n\n主要任务是找出键比较的确切次数。键比较 $x.\\text{key} = x.\\text{next}.\\text{key}$ 在 `while` 循环的每次迭代中都恰好执行一次。因此，键比较的总次数等于循环的总迭代次数。\n\n我们来分析循环迭代的次数。只要 $x.\\text{next} \\neq \\text{null}$，循环就会继续。我们将证明对于任何大小为 $n \\ge 1$ 的输入列表，循环都恰好执行 $n-1$ 次。\n如果 $n=0$，列表为空，$x$ 初始化为 $\\text{null}$，循环条件 $x \\neq \\text{null}$ 为假，进行 $0$ 次比较。\n如果 $n=1$，$x$ 指向 $N_1$，但 $x.\\text{next}$ 为 $\\text{null}$。循环条件 $x.\\text{next} \\neq \\text{null}$ 为假，进行 $0$ 次比较。注意在这种情况下 $n-1 = 0$。\n\n现在，考虑 $n \\ge 2$ 的情况。让我们追踪每次迭代开始时 $x.\\text{next}$ 指向的节点。设迭代次数为 $i$，从 $i=1$ 开始。\n- **迭代 $i=1$**：最初，$x$ 指向 $N_1$。因此，$x.\\text{next}$ 指向 $N_2$。循环条件为真，进行第一次比较。\n- **迭代 $i=2$ 开始时**：在第一次迭代之后，我们分析 $x.\\text{next}$ 的位置。\n  - 情况1 ($k_1 = k_2$)：执行赋值操作 $x.\\text{next} := x.\\text{next}.\\text{next}$。由于 $x$ 是 $N_1$ 而 $x.\\text{next}$ 是 $N_2$，所以 $N_1$ 的新 $x.\\text{next}$ 变为 $N_3$。指针 $x$ 本身不改变。因此，在第二次迭代开始时，$x$ 仍然是 $N_1$ 且 $x.\\text{next}$ 指向 $N_3$。\n  - 情况2 ($k_1 \\neq k_2$)：执行赋值操作 $x := x.\\text{next}$。由于 $x$ 是 $N_1$ 而 $x.\\text{next}$ 是 $N_2$，$x$ 现在指向 $N_2$。新的 $x.\\text{next}$ 是原始列表中 $N_2$ 的后继节点，即 $N_3$。\n在这两种情况下，第二次迭代开始时，在 $x.\\text{next}$ 处被考虑的节点都是 $N_3$。\n\n我们可以推广这个观察。让我们提出一个不变量：在迭代 $i$（其中 $1 \\le i  n$）的开始，指针 $x.\\text{next}$ 指向原始节点 $N_{i+1}$。\n- **基本情况 ($i=1$)**：如上所示，这是成立的。\n- **归纳步骤**：假设不变量对于迭代 $i$ 成立，其中 $1 \\le i  n-1$。所以在迭代 $i$ 开始时，$x.\\text{next}$ 指向 $N_{i+1}$。进行一次比较。\n  - 如果 $x.\\text{key} = x.\\text{next}.\\text{key}$，$x$ 保持不变，$x.\\text{next}$ 被更新以指向 $N_{i+2}$。\n  - 如果 $x.\\text{key} \\neq x.\\text{next}.\\text{key}$，$x$ 被更新以指向 $N_{i+1}$，所以它的 `next` 指针指向 $N_{i+2}$。\n在两种结果中，在迭代 $i+1$ 开始时，$x.\\text{next}$ 引用的节点都是 $N_{(i+1)+1} = N_{i+2}$。不变量成立。\n\n这个归纳论证表明，循环会迭代 $i=1, 2, \\ldots, n-1$ 次。在第 $(n-1)$ 次迭代中，$x.\\text{next}$ 指向 $N_n$。这次迭代之后：\n- 如果 $x.\\text{key} = N_n.\\text{key}$：$x.\\text{next}$ 被设置为 $N_n.\\text{next}$，即 $\\text{null}$。\n- 如果 $x.\\text{key} \\neq N_n.\\text{key}$：$x$ 被设置为 $N_n$，其 `next` 指针为 $\\text{null}$。\n在任何一种情况下，在下一次可能的迭代之前，循环条件 $x.\\text{next} \\neq \\text{null}$ 将为假。因此，循环在恰好 $n-1$ 次迭代后终止。\n\n对于 $n \\ge 1$，键比较的次数 $C(n)$ 恰好是 $n-1$。对于 $n=0$，$C(0)=0$。覆盖所有非负 $n$ 的闭式表达式是 $C(n) = \\max(0, n-1)$。假设列表大小非平凡（$n \\ge 1$），则计数为 $n-1$。\n\n接下来，我们推导紧渐近时间复杂度 $T(n)$。我们使用标准的单位成本RAM模型，其中每个基本操作的成本为 $O(1)$。\n该算法包括：\n1. 一个初始指针赋值（$x := \\text{head}$）：这花费常数时间 $O(1)$。\n2. `while` 循环：\n   - 循环条件检查：条件 $x \\neq \\text{null}$ 和 $x.\\text{next} \\neq \\text{null}$ 在每次迭代开始时以及循环终止时最后一次被检查。对于 $n \\ge 1$，这总共相当于 $n$ 次检查。每次检查的成本为 $O(1)$，因此检查的总成本为 $n \\times O(1) = O(n)$。\n   - 循环体：对于 $n \\ge 1$，循环执行 $n-1$ 次。在每次迭代中，算法执行：\n     - 一次键比较：$O(1)$。\n     - 一次指针赋值（在 `if` 或 `else` 分支中）：$O(1)$。\n   因此，每次迭代内部的工作量是常数级的，$O(1)$。在所有迭代中，循环体花费的总时间为 $(n-1) \\times O(1) = O(n)$。\n\n总时间复杂度是各项成本的总和：\n$T(n) = (\\text{初始化}) + (\\text{循环检查}) + (\\text{循环体执行})$\n对于 $n \\ge 1$，$T(n) = O(1) + O(n) + O(n) = O(n)$。这确立了时间复杂度的上界。\n\n对于下界，我们观察到对于任何 $n \\ge 1$ 的输入，算法必须执行 $n-1$ 次迭代。每次迭代都涉及至少一次键比较和相关的指针操作，这需要某个最小的常数时间 $c > 0$。因此，总时间必须至少与 $n-1$ 成正比。\n对于某个常数 $c>0$ 和 $n \\ge 1$，$T(n) \\ge c \\cdot (n-1)$。\n这意味着 $T(n) \\in \\Omega(n-1)$，可以简化为 $T(n) \\in \\Omega(n)$。\n\n由于 $T(n) \\in O(n)$ 且 $T(n) \\in \\Omega(n)$，该算法的紧渐近时间复杂度为 $\\Theta(n)$。", "answer": "$$\\boxed{\\Theta(n)}$$", "id": "3207266"}, {"introduction": "接下来，我们将探讨如何利用数据结构的内在属性来简化算法分析。这个问题要求在一个最小堆中找到最大元素。通过首先证明最大元素必须存在于堆的哪个特定区域，我们可以避免对整个数据结构进行暴力搜索，从而显著缩小搜索范围并精确计算最坏情况下的比较次数。[@problem_id:3207269]", "problem": "考虑一个存储在数组 $A[1], A[2], \\dots, A[n]$ 中的二叉最小堆，其中整数 $n \\geq 1$。二叉最小堆是一个完全二叉树，其中每个节点的值都小于或等于其子节点的值。其标准数组表示将索引为 $i$ 的节点映射到索引为 $2i$ 和 $2i+1$ 的子节点（只要这些索引不超过 $n$）。现提出一个迭代过程来寻找堆中的最大元素：\n- 初始化 $m \\leftarrow A[k]$，其中 $k = \\left\\lfloor \\frac{n}{2} \\right\\rfloor + 1$（数组中第一个叶子节点的位置）。\n- 对于从 $k+1$ 到 $n$ 的每个索引 $i$（按升序），执行比较：“如果 $A[i] > m$，则更新 $m \\leftarrow A[i]$；否则保持 $m$ 不变。”\n假设算法的成本仅由形式为“$A[i] > m$”的键值比较次数来衡量，并且所有其他操作的成本为零。仅使用二叉堆及其数组表示的定义属性，推导出一个关于 $n$ 的精确封闭形式表达式，表示该算法在所有大小为 $n$ 的有效堆上执行的键值比较的最坏情况次数。你的最终答案必须是关于 $n$ 的单个解析表达式；不要给出不等式、渐近阶或分段定义。不需要取整。", "solution": "我们从二叉最小堆及其数组表示的核心定义开始。二叉最小堆是一个完全二叉树，其中每个节点的键值小于或等于其子节点的键值。数组表示将根节点置于索引 $1$ 处，对于任何索引 $i$，只要其子节点的索引 $2i$ 和 $2i+1$ 不超过 $n$，就将它们放置在相应位置。索引为 $i$ 的节点是内部节点，当且仅当它至少有一个子节点，这恰好在 $2i \\leq n$ 时发生。因此，内部节点集合恰好是满足 $1 \\leq i \\leq \\left\\lfloor \\frac{n}{2} \\right\\rfloor$ 的索引 $i$。相反，叶子节点是满足 $i > \\left\\lfloor \\frac{n}{2} \\right\\rfloor$ 直至 $n$ 的索引 $i$。因此，大小为 $n$ 的堆中叶子节点的数量 $L$ 为：\n$$ L = n - \\left\\lfloor \\frac{n}{2} \\right\\rfloor $$\n接下来，我们论证最小堆的最大元素必定位于叶子节点之中。考虑任意一个索引为 $i$ 的非叶子节点。根据堆的性质，其索引为 $2i$ 的子节点（如果存在）满足 $A[2i] \\geq A[i]$，类似地，如果索引为 $2i+1$ 的子节点存在，则满足 $A[2i+1] \\geq A[i]$。沿着从内部节点到叶子节点的任何路径，键值的序列是非递减的。因此，对于任何内部节点，都存在一个叶子节点，其键值大于或等于该内部节点的键值。因此，最大键值不可能严格地存在于内部节点集合中；它必须在某个叶子节点上取到。\n\n给定的迭代算法将 $m$ 初始化为第一个叶子节点索引 $k = \\left\\lfloor \\frac{n}{2} \\right\\rfloor + 1$ 处的键值，然后从 $k+1$ 到 $n$ 扫描剩余的叶子节点，每次扫描一个叶子节点就执行一次比较。算法没有提前终止的条件；因此，无论键值的输入排列如何，算法都将对第一个叶子节点之后的所有叶子节点各执行一次比较。执行的键值比较的确切次数是叶子节点的总数减一。叶子节点的数量为 $L = n - \\left\\lfloor \\frac{n}{2} \\right\\rfloor$。因此，比较次数为：\n$$ \\text{comparisons} = L - 1 = \\left(n - \\left\\lfloor \\frac{n}{2} \\right\\rfloor\\right) - 1 $$\n我们可以使用对所有整数 $n$ 都成立的恒等式 $\\left\\lceil \\frac{n}{2} \\right\\rceil = n - \\left\\lfloor \\frac{n}{2} \\right\\rfloor$ 来简化这个表达式。代入可得：\n$$ \\text{comparisons} = \\left\\lceil \\frac{n}{2} \\right\\rceil - 1 $$\n因为该算法确定性地对每个剩余的叶子节点都恰好进行一次比较，所以这个计数既是对于任何大小为 $n$ 的有效堆的最坏情况计数，也是确切计数。因此，所需的关于 $n$ 的精确封闭形式表达式是：\n$$ \\left\\lceil \\frac{n}{2} \\right\\rceil - 1 $$", "answer": "$$\\boxed{\\left\\lceil \\frac{n}{2} \\right\\rceil - 1}$$", "id": "3207269"}, {"introduction": "最后，我们将分析的维度从一维扩展到二维。本练习探讨了一种在行列均有序的二维矩阵中进行搜索的巧妙算法。通过从一个精心选择的角点开始，并在每一步做出明智的决策，该算法在每次比较后都能排除一行或一列，从而保证了高效的搜索路径。我们将精确推导其最坏情况下的比较次数，这有助于你掌握对二维空间遍历算法的分析技巧。[@problem_id:3207190]", "problem": "考虑一个大小为 $n \\times m$ 的实数二维矩形矩阵 $A$，其中 $n \\geq 1$ 且 $m \\geq 1$。$A$ 的每一行从左到右按非递减顺序排序，$A$ 的每一列从上到下按非递减顺序排序。定义一个确定性迭代搜索算法来定位给定的实数键 $x$，其过程如下：算法从右上角位置 $(i,j) = (1,m)$ 开始，并在索引保持在边界 $1 \\leq i \\leq n$ 和 $1 \\leq j \\leq m$ 内时重复以下步骤：\n- 将 $A[i,j]$ 与 $x$ 进行比较。\n- 如果 $A[i,j] = x$，则终止并报告成功。\n- 如果 $A[i,j] > x$，则更新 $j \\leftarrow j - 1$。\n- 如果 $A[i,j]  x$，则更新 $i \\leftarrow i + 1$。\n如果索引越界（具体来说，如果 $i = n+1$ 或 $j = 0$），则终止并报告 $x$ 不存在。\n\n仅使用数据结构与算法中关于迭代算法和基于比较模型的基础定义，从第一性原理出发，推导该算法在任何有效输入矩阵 $A$ 和任何实数键 $x$ 上执行的比较次数的精确最坏情况，并将其表示为 $n$ 和 $m$ 的函数。您的最终答案必须是关于 $n$ 和 $m$ 的单个封闭形式解析表达式。此答案无需四舍五入或指定单位。", "solution": "比较的次数等于算法迭代的次数。我们旨在找到所有可能输入下迭代次数的最大值，即最坏情况。\n\n算法从矩阵的右上角 $(i,j) = (1,m)$ 开始。在每次迭代中，指针要么向下移动（$i \\leftarrow i+1$），要么向左移动（$j \\leftarrow j-1$）。\n\n最坏情况发生在算法执行了最长的路径后终止，这通常是因为未找到键而导致索引越界。一条路径由一系列“向下”和“向左”的移动组成。要从第1行移动到第$n$行，需要$n-1$次“向下”移动。要从第$m$列移动到第$1$列，需要$m-1$次“向左”移动。\n\n算法的最长可能路径是从右上角 $(1,m)$ 移动到左下角 $(n,1)$。这样一条路径总共包含 $(n-1)$ 次“向下”移动和 $(m-1)$ 次“向左”移动。因此，移动的总步数是 $(n-1) + (m-1) = n+m-2$。\n\n比较的总次数等于访问的单元格数量。这包括起始单元格和路径上每一步访问的单元格。因此，总比较次数为 $1$（起始位置）加上总移动步数：\n$$ \\text{总比较次数} = 1 + (n+m-2) = n+m-1 $$\n这条最长路径是可以实现的。例如，如果搜索的键 $x$ 小于 $A[n,1]$ 且大于 $A[n-1,2]$（假设 $n,m > 1$），算法将被引导至左下角。\n\n因此，该算法在最坏情况下的精确比较次数为 $n+m-1$。", "answer": "$$\\boxed{n+m-1}$$", "id": "3207190"}]}