{"hands_on_practices": [{"introduction": "渐进符号的定义在数学上是严谨的。对这些定义的误解或不精确的应用，常常会导致完全错误的结论。这项练习将挑战你扮演一名侦探，在一个声称 $n \\in \\mathcal{O}(1)$ 的错误证明中找出逻辑谬误 [@problem_id:3210000]。通过这个过程，你将加深对定义中常数 $c$ 和阈值 $n_0$ 确切角色的理解。", "problem": "考虑函数 $f(n) = n$ 属于集合 $\\mathcal{O}(1)$ 的论断以及下面这个所谓的证明。\n\n论断：$f(n) \\in \\mathcal{O}(1)$。\n\n所谓的证明：根据定义，我们只需找到常数 $c > 0$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有 $n \\ge n_0$ 都有 $0 \\le f(n) \\le c \\cdot 1$。首先，对于每个 $n \\ge 1$，取 $c = n$。那么 $f(n) = n \\le c \\cdot 1$ 成立，所以所需的不等式得到满足。其次，观察到 $\\lim_{n \\to \\infty} \\frac{f(n)}{1} = \\lim_{n \\to \\infty} n$ “存在”，因此其增长是“良好定义的”，所以在渐近记法的意义上，它被一个常数所界定。最后，选择 $n_0 = 10$；对于所有 $n \\ge n_0$，我们有 $n \\le n_0$，因此 $f(n) \\le n_0 \\cdot 1$。所以 $f(n) \\in \\mathcal{O}(1)$。\n\n选出所有正确指出了该所谓证明中逻辑错误的选项。\n\nA. 该论证允许常数 $c$ 依赖于 $n$ (使用了 $c = n$)，这违反了 $\\mathcal{O}$ 定义中的量词结构；常数必须独立于 $n$ 来选择。\n\nB. 使用极限 $\\lim_{n \\to \\infty} \\frac{f(n)}{1}$ 来得出 $\\mathcal{O}(1)$ 的结论是无效的；不仅因为这个极限是无穷大，而且极限的存在本身并不能确立 $\\mathcal{O}(1)$ 所要求的一致常数界。\n\nC. 声称对于 $n \\ge n_0$ 有 $n \\le n_0$ 的步骤颠倒了不等式，并误解了 $n_0$ 的作用；$n_0$ 是一个阈值，界限必须在该值之后保持成立，而不是 $n$ 本身的上界。\n\nD. 第一步中选择 $c = n$ 是可以接受的，因为它使得对于每个 $n$ 都有 $f(n) \\le c \\cdot 1$ 为真，所以该证明正确地满足了 $\\mathcal{O}(1)$ 的定义。\n\nE. 该证明使用了不等式 $f(n) \\le c \\cdot 1$，但 $\\mathcal{O}(1)$ 的定义实际上要求 $f(n) \\ge c \\cdot 1$；不等式的方向是错误的。\n\nF. 唯一的问题是 $n_0 = 10$ 的具体选择；选择一个足够大的 $n_0$ 会使得不等式 $n \\le n_0$ 对所有 $n \\ge n_0$ 成立，从而可以修正这个证明。", "solution": "用户提供了一个关于函数 $f(n) = n$ 属于集合 $\\mathcal{O}(1)$ 这个论断的所谓证明，并要求从一个选项列表中找出所有的逻辑错误。\n\n首先，让我们回顾一下大O记法的正式定义。一个函数 $f(n)$ 属于 $\\mathcal{O}(g(n))$ 当且仅当存在常数 $c \\in \\mathbb{R}_{0}$ 和 $n_0 \\in \\mathbb{N}$，使得对于所有整数 $n \\ge n_0$，不等式 $0 \\le |f(n)| \\le c \\cdot |g(n)|$ 成立。对于本题中的函数 $f(n) = n$ 和 $g(n) = 1$（当 $n \\ge 1$ 时它们是非负的），我们可以将不等式简化为 $0 \\le n \\le c \\cdot 1$。该定义的逻辑结构至关重要：$\\exists c > 0, \\exists n_0 \\in \\mathbb{N} : \\forall n \\ge n_0, f(n) \\le c \\cdot g(n)$。这意味着常数 $c$ 和 $n_0$ 必须被选择一次，并对所有超过阈值 $n_0$ 的 $n$ 值都有效。它们不能是 $n$ 的函数。\n\n$n \\in \\mathcal{O}(1)$ 这个论断是错误的。要使其为真，需要存在一个固定的常数 $c$ 使得对于所有足够大的 $n$ 都有 $n \\le c$。这是不可能的，因为函数 $f(n)=n$ 是无界的。因此，所提供的“证明”必然存在缺陷。我们现在将分析这个所谓证明的每一步，然后评估给出的选项。\n\n这个所谓的证明包含三个不同的、有缺陷的论证：\n1.  **论证1**：“对于每个 $n \\ge 1$，取 $c = n$。那么 $f(n) = n \\le c \\cdot 1$ 成立”。这个论证将常数 $c$ 设置为等于变量 $n$。这违反了 $\\mathcal{O}$ 记法定义中的量词顺序。常数 $c$ 必须独立于 $n$。\n2.  **论证2**：“$\\lim_{n \\to \\infty} \\frac{f(n)}{1} = \\lim_{n \\to \\infty} n$ ‘存在’，因此其增长是‘良好定义的’，所以被一个常数所界定...”。这个论证在多个方面都是谬误的。极限 $\\lim_{n \\to \\infty} n$ 并不作为一个有限实数存在；它发散到 $\\infty$。$f(n) \\in \\mathcal{O}(g(n))$ 的一个充分条件是 $\\limsup_{n \\to \\infty} \\frac{|f(n)|}{|g(n)|}  \\infty$。在这种情况下，极限是 $\\infty$，这证明了 $n \\notin \\mathcal{O}(1)$。该论证误解了极限检验法，并错误地声称极限“存在”。\n3.  **论证3**：“选择 $n_0 = 10$；对于所有 $n \\ge n_0$，我们有 $n \\le n_0$，所以 $f(n) \\le n_0 \\cdot 1$”。这个论证包含一个基本的逻辑矛盾。其前提是该陈述对所有 $n \\ge n_0$ 都成立。但是，所声称的不等式 $n \\le n_0$ 仅在 $n=n_0$ 时为真，而对所有 $n > n_0$ 都为假。它并非“对所有 $n \\ge n_0$”都成立。这误解了 $n_0$ 作为 $n$ 的下限阈值的作用，反而将其视为 $n$ 的一个上界。\n\n现在我们来评估每个选项。\n\n**A. 该论证允许常数 $c$ 依赖于 $n$ (使用了 $c = n$)，这违反了 $\\mathcal{O}$ 定义中的量词结构；常数必须独立于 $n$ 来选择。**\n这个选项正确地指出了所谓证明中第一个论证的错误。定义要求 $\\exists c$ 使得 $\\forall n \\ge n_0$。该证明试图使用一个等价于 $\\forall n \\ge n_0, \\exists c$ 的结构，这是一个不同的逻辑陈述，不满足定义。\n结论：**正确**。\n\n**B. 使用极限 $\\lim_{n \\to \\infty} \\frac{f(n)}{1}$ 来得出 $\\mathcal{O}(1)$ 的结论是无效的；不仅因为这个极限是无穷大，而且极限的存在本身并不能确立 $\\mathcal{O}(1)$ 所要求的一致常数界。**\n这个选项正确地指出了第二个论证中的错误。极限 $\\lim_{n \\to \\infty} n$ 是 $\\infty$，而不是一个有限值。比值 $\\frac{f(n)}{g(n)}$ 的极限发散到无穷大这一事实，证明了 $f(n) \\notin \\mathcal{O}(g(n))$。证明中提出的推理完全是颠倒的。\n结论：**正确**。\n\n**C. 声称对于 $n \\ge n_0$ 有 $n \\le n_0$ 的步骤颠倒了不等式，并误解了 $n_0$ 的作用；$n_0$ 是一个阈值，界限必须在该值之后保持成立，而不是 $n$ 本身的上界。**\n这个选项正确地指出了第三个论证中的错误。“对于所有 $n \\ge n_0$ 我们有 $n \\le n_0$”这一陈述对于任何 $n > n_0$ 显然是错误的。它从根本上误解了 $n_0$ 确立了一个半无限区间 $[n_0, \\infty)$，在该区间上不等式必须得到满足。\n结论：**正确**。\n\n**D. 第一步中选择 $c = n$ 是可以接受的，因为它使得对于每个 $n$ 都有 $f(n) \\le c \\cdot 1$ 为真，所以该证明正确地满足了 $\\mathcal{O}(1)$ 的定义。**\n这个选项提出了一个不正确的理由。虽然选择 $c=n$ 确实使得不等式 $n \\le n$ 成立，但根据 $\\mathcal{O}$ 记法的规则，这种对 $c$ 的选择是不允许的，正如在选项 A 的分析中所解释的。因此，这个选项错误地为一个有缺陷的步骤辩护。\n结论：**不正确**。\n\n**E. 该证明使用了不等式 $f(n) \\le c \\cdot 1$，但 $\\mathcal{O}(1)$ 的定义实际上要求 $f(n) \\ge c \\cdot 1$；不等式的方向是错误的。**\n这个选项错误地陈述了 $\\mathcal{O}$ 记法的定义。$f(n) \\in \\mathcal{O}(g(n))$ 的定义要求一个上界，即 $f(n) \\le c \\cdot g(n)$。用于下界的不等式 $f(n) \\ge c \\cdot g(n)$ 对应于 $\\Omega$ 记法。所谓的证明使用了正确的 $\\mathcal{O}$ 记法不等式。\n结论：**不正确**。\n\n**F. 唯一的问题是 $n_0 = 10$ 的具体选择；选择一个足够大的 $n_0$ 会使得不等式 $n \\le n_0$ 对所有 $n \\ge n_0$ 成立，从而可以修正这个证明。**\n这个选项不正确，原因有二。首先，它声称关于 $n_0$ 的错误是*唯一*的问题，这是错误的，正如在选项 A 和 B 中所记录的。其次，它提出的“修正”方案是不可能的。不存在任何 $n_0$ 值能使得“对所有 $n \\ge n_0$ 都有 $n \\le n_0$”这一陈述为真。其推理从根本上就是有缺陷的，无法通过选择一个不同的 $n_0$ 来修正。\n结论：**不正确**。", "answer": "$$\\boxed{ABC}$$", "id": "3210000"}, {"introduction": "在算法分析中，一项关键技能是能够快速比较不同函数的增长率。这项练习要求你使用小o符号（$o$）的正式定义，为一组常见的函数——从对数函数到阶乘函数——进行排序 [@problem_id:3209962]。这有助于你建立一个关于“函数增长层级”的直观且正式的理解，这是评估算法效率的基础。", "problem": "考虑函数 $f_1(n) = n \\log n$、$f_2(n) = n^{3/2}$、$f_3(n) = n!$、$f_4(n) = 2^n$ 和 $f_5(n) = (\\log n)^2$。使用小$o$和小$\\omega$的严格定义，构建这些函数在 $n \\to \\infty$ 时最紧密的渐近关系链。也就是说，确定一个 $\\{1,2,3,4,5\\}$ 的排列 $\\pi$，使得\n$$\nf_{\\pi(1)}(n) \\in o\\!\\left(f_{\\pi(2)}(n)\\right), \\quad\nf_{\\pi(2)}(n) \\in o\\!\\left(f_{\\pi(3)}(n)\\right), \\quad\nf_{\\pi(3)}(n) \\in o\\!\\left(f_{\\pi(4)}(n)\\right), \\quad\nf_{\\pi(4)}(n) \\in o\\!\\left(f_{\\pi(5)}(n)\\right),\n$$\n并且等价地，对于每个 $i \\in \\{1,2,3,4\\}$，都有 $f_{\\pi(i+1)}(n) \\in \\omega\\!\\left(f_{\\pi(i)}(n)\\right)$。根据第一性原理证明链中的每一个环节。\n\n设 $p_k$ 表示第 $k$ 个素数，其中 $p_1 = 2$、$p_2 = 3$、$p_3 = 5$、$p_4 = 7$ 和 $p_5 = 11$。在确定了正确的排列 $\\pi$ 之后，计算精确整数\n$$\nE \\;=\\; \\prod_{i=1}^{5} p_{\\pi(i)}^{\\,i}.\n$$\n将最终值表示为一个精确的整数，无需四舍五入。", "solution": "该问题要求完成两项主要任务。首先，我们必须使用小$o$记号的定义，为给定的五个函数建立一个严格的渐近排序。其次，基于这个排序，我们必须计算一个整数值 $E$，该值由素数的特定次幂的乘积得出。\n\n需要排序的函数是：\n$f_1(n) = n \\log n$\n$f_2(n) = n^{3/2}$\n$f_3(n) = n!$\n$f_4(n) = 2^n$\n$f_5(n) = (\\log n)^2$\n\n小$o$的定义如下：如果对于所有常数 $c > 0$，存在一个常数 $n_0$，使得对于所有 $n > n_0$，都有 $0 \\le g(n)  c \\cdot h(n)$，则函数 $g(n)$ 属于 $o(h(n))$。对于当 $n$ 足够大时为正的函数，这等价于以下极限定义：\n$$\ng(n) \\in o(h(n)) \\iff \\lim_{n \\to \\infty} \\frac{g(n)}{h(n)} = 0\n$$\n我们将使用这个基于极限的定义来证明排序的每一步。对数的底不影响渐近排序，因为不同底的对数之间通过一个常数因子相关联：$\\log_a n = \\frac{\\log_b n}{\\log_b a}$。为了微积分（特别是L'Hôpital法则）的计算，我们将使用自然对数，记作 $\\ln(n)$。\n\n目标是找到一个 $\\{1,2,3,4,5\\}$ 的排列 $\\pi$，使得 $f_{\\pi(1)}(n) \\in o(f_{\\pi(2)}(n))$，$f_{\\pi(2)}(n) \\in o(f_{\\pi(3)}(n))$，以此类推。\n\n让我们进行两两比较。\n\n1.  比较 $f_5(n) = (\\ln n)^2$ 和 $f_1(n) = n \\ln n$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_5(n)}{f_1(n)} = \\lim_{n \\to \\infty} \\frac{(\\ln n)^2}{n \\ln n} = \\lim_{n \\to \\infty} \\frac{\\ln n}{n}\n    $$\n    这个极限是 $\\frac{\\infty}{\\infty}$ 的不定形式，因此我们应用L'Hôpital法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\ln n}{n} = \\lim_{n \\to \\infty} \\frac{\\frac{d}{dn}(\\ln n)}{\\frac{d}{dn}(n)} = \\lim_{n \\to \\infty} \\frac{1/n}{1} = 0\n    $$\n    由于极限为 $0$，我们有 $f_5(n) \\in o(f_1(n))$。\n\n2.  比较 $f_1(n) = n \\ln n$ 和 $f_2(n) = n^{3/2}$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_1(n)}{f_2(n)} = \\lim_{n \\to \\infty} \\frac{n \\ln n}{n^{3/2}} = \\lim_{n \\to \\infty} \\frac{\\ln n}{n^{1/2}}\n    $$\n    再次，我们得到 $\\frac{\\infty}{\\infty}$ 形式并应用L'Hôpital法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\ln n}{n^{1/2}} = \\lim_{n \\to \\infty} \\frac{\\frac{d}{dn}(\\ln n)}{\\frac{d}{dn}(n^{1/2})} = \\lim_{n \\to \\infty} \\frac{1/n}{\\frac{1}{2}n^{-1/2}} = \\lim_{n \\to \\infty} \\frac{2n^{1/2}}{n} = \\lim_{n \\to \\infty} \\frac{2}{n^{1/2}} = 0\n    $$\n    因此，$f_1(n) \\in o(f_2(n))$。这证实了任何多对数因子都比任何（指数为正的）多项式因子增长得慢。\n\n3.  比较 $f_2(n) = n^{3/2}$ 和 $f_4(n) = 2^n$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_2(n)}{f_4(n)} = \\lim_{n \\to \\infty} \\frac{n^{3/2}}{2^n}\n    $$\n    这是 $\\frac{\\infty}{\\infty}$ 的形式。应用L'Hôpital法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{n^{3/2}}{2^n} = \\lim_{n \\to \\infty} \\frac{\\frac{3}{2}n^{1/2}}{2^n \\ln 2}\n    $$\n    这仍然是 $\\frac{\\infty}{\\infty}$ 的形式。再次应用该法则：\n    $$\n    \\lim_{n \\to \\infty} \\frac{\\frac{3}{2} \\cdot \\frac{1}{2} n^{-1/2}}{2^n (\\ln 2)^2} = \\lim_{n \\to \\infty} \\frac{3}{4 n^{1/2} 2^n (\\ln 2)^2} = 0\n    $$\n    分母增长到无穷大，而分子是常数。因此，$f_2(n) \\in o(f_4(n))$。这证实了多项式函数比指数函数增长得慢的一般原则。\n\n4.  比较 $f_4(n) = 2^n$ 和 $f_3(n) = n!$：\n    我们计算比值的极限：\n    $$\n    \\lim_{n \\to \\infty} \\frac{f_4(n)}{f_3(n)} = \\lim_{n \\to \\infty} \\frac{2^n}{n!}\n    $$\n    让我们考虑项 $a_n = \\frac{2^n}{n!}$。我们可以将其写作：\n    $$\n    a_n = \\frac{2}{1} \\cdot \\frac{2}{2} \\cdot \\frac{2}{3} \\cdot \\frac{2}{4} \\cdots \\frac{2}{n}\n    $$\n    对于 $n > 2$，项 $\\frac{2}{k}$（其中 $k=3, \\dots, n$）都小于或等于 $\\frac{2}{3}$。\n    所以对于 $n \\ge 3$，我们有 $0  \\frac{2^n}{n!} = \\frac{2^2}{2!} \\cdot \\frac{2}{3} \\cdots \\frac{2}{n} \\le 2 \\cdot \\left(\\frac{2}{3}\\right)^{n-2}$。\n    当 $n \\to \\infty$ 时，$\\left(\\frac{2}{3}\\right)^{n-2} \\to 0$。根据夹逼定理，$\\lim_{n \\to \\infty} \\frac{2^n}{n!} = 0$。\n    因此，$f_4(n) \\in o(f_3(n))$。\n\n综合这些结果，我们得到以下严格的渐近排序：\n$$\nf_5(n) \\in o(f_1(n)), \\quad f_1(n) \\in o(f_2(n)), \\quad f_2(n) \\in o(f_4(n)), \\quad f_4(n) \\in o(f_3(n))\n$$\n这对应于问题所要求的链：$f_{\\pi(1)}(n), f_{\\pi(2)}(n), f_{\\pi(3)}(n), f_{\\pi(4)}(n), f_{\\pi(5)}(n)$。\n通过匹配函数，我们确定排列 $\\pi$：\n- $f_{\\pi(1)}(n)$ 是增长最慢的函数，即 $f_5(n)$。所以，$\\pi(1) = 5$。\n- $f_{\\pi(2)}(n)$ 是序列中的下一个，即 $f_1(n)$。所以，$\\pi(2) = 1$。\n- $f_{\\pi(3)}(n)$ 是 $f_2(n)$。所以，$\\pi(3) = 2$。\n- $f_{\\pi(4)}(n)$ 是 $f_4(n)$。所以，$\\pi(4) = 4$。\n- $f_{\\pi(5)}(n)$ 是增长最快的函数，即 $f_3(n)$。所以，$\\pi(5) = 3$。\n\n排列是 $\\pi(1)=5$, $\\pi(2)=1$, $\\pi(3)=2$, $\\pi(4)=4$, $\\pi(5)=3$。\n\n现在我们计算 $E$ 的值。给定的素数是 $p_1 = 2$、$p_2 = 3$、$p_3 = 5$、$p_4 = 7$ 和 $p_5 = 11$。\n$E$的公式是：\n$$\nE \\;=\\; \\prod_{i=1}^{5} p_{\\pi(i)}^{\\,i} = p_{\\pi(1)}^1 \\cdot p_{\\pi(2)}^2 \\cdot p_{\\pi(3)}^3 \\cdot p_{\\pi(4)}^4 \\cdot p_{\\pi(5)}^5\n$$\n代入 $\\pi(i)$ 的值：\n$$\nE = p_5^1 \\cdot p_1^2 \\cdot p_2^3 \\cdot p_4^4 \\cdot p_3^5\n$$\n代入素数值：\n$$\nE = (11)^1 \\cdot (2)^2 \\cdot (3)^3 \\cdot (7)^4 \\cdot (5)^5\n$$\n现在我们计算每一项的值：\n- $11^1 = 11$\n- $2^2 = 4$\n- $3^3 = 27$\n- $7^4 = (7^2)^2 = 49^2 = 2401$\n- $5^5 = 3125$\n\n我们将这些值相乘：\n$$\nE = 11 \\cdot 4 \\cdot 27 \\cdot 2401 \\cdot 3125\n$$\n为了简化计算，我们可以重新排列各项。让我们将易于相乘的项组合在一起。\n$$\nE = (4 \\cdot 3125) \\cdot (11 \\cdot 27) \\cdot 2401\n$$\n计算括号内的值：\n- $4 \\cdot 3125 = 12500$\n- $11 \\cdot 27 = 297$\n所以，表达式变为：\n$$\nE = 12500 \\cdot 297 \\cdot 2401\n$$\n现在将 $12500$ 乘以 $297$：\n$$\n12500 \\cdot 297 = 12500 \\cdot (300 - 3) = 12500 \\cdot 300 - 12500 \\cdot 3 = 3750000 - 37500 = 3712500\n$$\n表达式现在是：\n$$\nE = 3712500 \\cdot 2401\n$$\n这可以计算为 $3712500 \\cdot (2400 + 1)$：\n$$\nE = 3712500 \\cdot 2400 + 3712500 \\cdot 1\n$$\n让我们计算 $37125 \\cdot 24$：\n$37125 \\cdot 24 = 37125 \\cdot (20 + 4) = 742500 + 148500 = 891000$。\n所以，$3712500 \\cdot 2400 = 37125 \\cdot 100 \\cdot 24 \\cdot 100 = 891000 \\cdot 10000 = 8910000000$。\n最后，我们加上剩余部分：\n$$\nE = 8910000000 + 3712500 = 8913712500\n$$\n精确的整数值是 $8,913,712,500$。\n让我们通过不同的分组方式重新验证计算：\n$E = (2^2 \\cdot 5^5) \\cdot (3^3 \\cdot 7^4) \\cdot 11^1 = (4 \\cdot 3125) \\cdot (27 \\cdot 2401) \\cdot 11$。\n- $4 \\cdot 3125 = 12500$。\n- $27 \\cdot 2401 = 27 \\cdot (2400+1) = 64800 + 27 = 64827$。\n$E = 12500 \\cdot 64827 \\cdot 11$。\n$E = 12500 \\cdot (64827 \\cdot 11) = 12500 \\cdot 713097$。\n要计算 $125 \\cdot 713097$，我们可以使用性质 $125 = 1000/8$：\n$125 \\cdot 713097 = \\frac{713097000}{8} = 89137125$。\n所以，$E = 12500 \\cdot 713097 = 100 \\cdot (125 \\cdot 713097) = 100 \\cdot 89137125 = 8913712500$。\n两种计算方法得出相同的结果，证实了最终答案。\n$$\nE = 8913712500\n$$", "answer": "$$\n\\boxed{8913712500}\n$$", "id": "3209962"}, {"introduction": "这项练习旨在连接抽象的渐进分析与现实世界的算法性能。虽然一个算法在渐进意义上可能更优，但在实际的输入规模下，常数因子和低阶项也至关重要。你将通过计算“交叉点”（crossover point），即渐进更快的算法开始真正变得更高效的输入规模，来体会算法选择中的一个关键实践考量 [@problem_id:3210023]。", "problem": "您正在比较两种解决相同问题的算法，其输入大小为 $n$，精确的运行时间模型分别为 $T_{A}(n) = 500\\,n\\,\\ln n$ 和 $T_{B}(n) = 0.1\\,n^{2}$，其中 $\\ln$ 表示自然对数。从渐近分析的角度来看，$T_{A}(n)$ 属于 $\\Theta(n \\ln n)$ 类，而 $T_{B}(n)$ 属于 $\\Theta(n^{2})$ 类。根据渐近记号的基本定义以及 $n \\ln n \\in o(n^{2})$ 这一事实，存在一个阈值 $n_{0}$，当 $n$ 超过该值时，算法 A 的运行时间将严格小于算法 B。将交叉点 $n_{0}$ 定义为方程 $T_{A}(n) = T_{B}(n)$ 的较大正数解，因此对于所有 $n \\ge n_{0}$，算法 A 都比算法 B 更快。请计算这个 $n_{0}$ 的近似值。为便于近似计算，假设 $n$ 是一个实数。将您的最终数值答案四舍五入到四位有效数字。", "solution": "我们被要求找到两种算法运行时间 $T_{A}(n) = 500\\,n\\,\\ln n$ 和 $T_{B}(n) = 0.1\\,n^{2}$ 的交叉点。交叉点 $n_0$ 被定义为方程 $T_{A}(n) = T_{B}(n)$ 的较大正数解。\n\n首先，我们建立方程：\n$$500\\,n\\,\\ln n = 0.1\\,n^{2}$$\n由于我们寻找的是 $n>0$ 的解，我们可以安全地将两边同除以 $n$：\n$$500\\,\\ln n = 0.1\\,n$$\n将两边同乘以10以消去小数：\n$$5000\\,\\ln n = n$$\n这是一个超越方程，没有闭式解，因此我们必须使用数值方法来求解。\n为了理解解的性质，我们分析函数 $g(n) = n - 5000\\,\\ln n$。我们寻找 $g(n)=0$ 的根。其导数为：\n$g'(n) = 1 - \\frac{5000}{n}$\n当 $n=5000$ 时导数为零。对于 $0  n  5000$，$g'(n)  0$；对于 $n > 5000$，$g'(n) > 0$。这表明函数在 $n=5000$ 处有一个全局最小值。\n最小值 $g(5000) = 5000 - 5000 \\ln(5000) \\approx 5000(1-8.517) = -37585  0$。\n由于 $\\lim_{n \\to 0^+} g(n) = +\\infty$ 且 $\\lim_{n \\to \\infty} g(n) = +\\infty$，而最小值是负的，所以存在两个根：一个在 $(0, 5000)$ 区间，另一个在 $(5000, \\infty)$ 区间。问题要求的是较大的根。\n\n我们可以使用不动点迭代法来求解方程 $n = 5000\\,\\ln n$。迭代公式为 $n_{k+1} = h(n_k)$，其中 $h(n) = 5000\\,\\ln n$。\n导数 $h'(n) = \\frac{5000}{n}$。对于我们寻找的较大根 $n_0 > 5000$，我们有 $|h'(n_0)| = \\frac{5000}{n_0}  1$，保证了迭代的收敛性，只要我们从一个足够大的初始猜测值开始。\n让我们选择一个初始猜测值 $n_1 = 10000$。\n\n执行迭代：\n- $n_2 = 5000\\,\\ln(10000) \\approx 5000 \\times 9.21034 = 46051.7$\n- $n_3 = 5000\\,\\ln(46051.7) \\approx 5000 \\times 10.73755 = 53687.8$\n- $n_4 = 5000\\,\\ln(53687.8) \\approx 5000 \\times 10.89083 = 54454.2$\n- $n_5 = 5000\\,\\ln(54454.2) \\approx 5000 \\times 10.90510 = 54525.5$\n- $n_6 = 5000\\,\\ln(54525.5) \\approx 5000 \\times 10.90639 = 54532.0$\n- $n_7 = 5000\\,\\ln(54532.0) \\approx 5000 \\times 10.90651 = 54532.6$\n- $n_8 = 5000\\,\\ln(54532.6) \\approx 5000 \\times 10.90652 = 54532.6$\n\n迭代收敛于约 $54532.6$。问题要求将答案四舍五入到四位有效数字。\n这个数是 $54532.6$。\n第一位有效数字是 $5$。\n第二位有效数字是 $4$。\n第三位有效数字是 $5$。\n第四位有效数字是 $3$。\n第五位数字是 $2$。由于 $2  5$，我们向下舍入（即保持第四位数字不变）。\n四舍五入到四位有效数字的结果是 $54530$。用科学记数法表示为 $5.453 \\times 10^4$。\n\n因此，对于所有大于或等于约 $54530$ 的输入规模 $n$，算法A将比算法B更高效。", "answer": "$$\n\\boxed{5.453 \\times 10^{4}}\n$$", "id": "3210023"}]}