{"hands_on_practices": [{"introduction": "循环不变量不仅是验证算法正确性的工具，更是指导算法设计的强大蓝图。本练习将颠覆传统的证明思路：我们不再是为给定的代码寻找不变量，而是从一个给定的循环不变量出发，逆向推导出循环体本身。通过这个过程，你将亲身体会到如何利用不变量作为“规格说明”，从第一性原理出发，构建出保证正确性和终止性的算法。[@problem_id:3248351]", "problem": "给定一个整数底数 $x$ 和一个非负整数指数 $n$。考虑一个通过维护三个整型变量 $p$、$k$ 和 $y$ 来计算 $x^n$ 的算法，其初始化和循环守卫如下：\n- 初始化：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$ 以及 $n_{\\text{original}} \\leftarrow n$。\n- 循环守卫：当 $y > 0$ 时继续循环。\n- 每次迭代开始时需要保持的循环不变量：$p = x^k$ 且 $k + y = n_{\\text{original}}$。\n\n你的任务是逆向工程一个正确的循环体，即确定必须在循环体中执行的赋值语句，以保持循环不变量，并确保在终止时后置条件 $p = x^{n_{\\text{original}}}$ 成立。\n\n你的推导必须从以下基本依据出发：\n- 自然数上求幂运算的定义：对于所有整数 $x$ 和所有整数 $k \\ge 0$，有 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$。\n- 自然数上的数学归纳法原理以及自然数上常规序的良基性。\n- 命令式程序中用于部分正确性的循环不变量和用于完全正确性的自然数变体的标准定义。\n\n假设使用以下定义域和约定：\n- $x$ 是任意整数，$n$ 是满足 $n \\ge 0$ 的任意整数。\n- 对于本问题，定义对于每个整数 $x$ 都有 $x^0 = 1$，包括 $x = 0$ 的情况，因此 $0^0$ 被视为 $1$。\n\n任务：\n1. 推导一个最小的循环体（仅包含对 $p$、$k$ 和 $y$ 的赋值），该循环体在每次迭代开始时保持不变量 $p = x^k$ 且 $k + y = n_{\\text{original}}$，递减一个自然数变体以确保终止，并在循环终止时产生后置条件 $p = x^{n_{\\text{original}}}$。\n2. 仅从上述基本依据出发，使用循环不变量方法证明你的循环的部分正确性和完全正确性。\n3. 实现一个程序，该程序针对一组测试用例执行你的循环，并为每个测试用例返回：\n   - 终止时计算出的值 $p$。\n   - 一个布尔值，指示在每次迭代开始时不变量是否成立，以及在终止时后置条件 $p = x^{n_{\\text{original}}}$ 是否成立。\n\n测试套件：\n- $(x, n) = (2, 10)$\n- $(x, n) = (5, 0)$\n- $(x, n) = (0, 7)$\n- $(x, n) = (0, 0)$\n- $(x, n) = (-3, 4)$\n- $(x, n) = (-3, 5)$\n- $(x, n) = (2, 50)$\n- $(x, n) = (1, 100)$\n\n答案规格和输出格式：\n- 对于每个测试用例，输出一个双元素列表 $[p, b]$，其中 $p$ 是使用你推导的循环计算出的整数 $x^n$，$b$ 是一个布尔值，当且仅当在每次迭代开始时不变量都成立且最终状态满足 $p = x^{n_{\\text{original}}}$ 时为 $\\text{True}$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的、以逗号分隔的结果列表，例如：$[\\,[p_1, b_1],[p_2, b_2],\\dots]$。\n- 不需要用户输入。程序必须是自包含的，并且只能使用整数算术和控制流；在循环体内计算 $p$ 时，不要调用任何内置的求幂函数。为了在你的实现中验证不变量，你可以使用定义性递推式 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$ 来计算 $x^k$。", "solution": "根据给定的循环不变量设计一个计算 $x^n$ 的循环体是程序验证和算法逆向工程中的一个标准练习。本解答将首先验证问题陈述，然后进行形式化推导和正确性证明。\n\n### 第1步：问题验证\n\n首先提取问题陈述中给出的信息和条件。\n\n- **输入**：一个整数底数 $x$ 和一个非负整数指数 $n$。\n- **算法变量**：三个整型变量 $p$、$k$ 和 $y$。\n- **初始化**：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及一个常量 $n_{\\text{original}} \\leftarrow n$。\n- **循环守卫**：只要 $y > 0$ 循环就继续。\n- **循环不变量**：命题 $I(p, k, y) \\equiv (p = x^k) \\land (k + y = n_{\\text{original}})$ 必须在每次循环迭代开始时成立。\n- **后置条件**：终止时，$p$ 的最终值必须是 $x^{n_{\\text{original}}}$。\n- **基本依据**：推导必须基于：\n    1. 求幂的递归定义：对于 $k \\ge 0$，有 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$。\n    2. 数学归纳法原理。\n    3. 用于证明部分和完全正确性的循环不变量理论。\n- **定义域约定**：$x$ 是任意整数，$n$ 是 $n \\ge 0$ 的整数，并且为了本问题的目的，对于所有整数 $x$ 都有 $x^0=1$，包括 $0^0=1$。\n\n该问题在科学上和数学上是合理的、适定的和客观的。这是计算机科学中关于算法设计和正确性的一个标准问题，特别关注循环不变量。前提是一致的，并且提供了推导所需的所有必要信息。这个问题并非无足轻重，因为它需要系统地应用程序验证的原理。因此，该问题被认为是有效的。\n\n### 第2步：循环体的推导\n\n设在任意一次循环迭代开始时变量的状态为 $(p, k, y)$。根据假设（循环不变量），我们假定此时：\n1. $p = x^k$\n2. $k + y = n_{\\text{original}}$\n\n循环守卫是 $y > 0$，所以我们也可以假设 $y$ 是一个正整数。\n目标是找到一系列对 $p$、$k$ 和 $y$ 的赋值，使得产生的新状态 $(p', k', y')$ 也满足不变量，即 $p' = x^{k'}$ 且 $k' + y' = n_{\\text{original}}$。此外，我们必须确保循环会终止。\n\n**确保终止**：\n如果 $y$ 最终变得小于或等于 $0$，循环就会终止。由于 $y$ 是一个在循环内部为正的整数，保证朝向终止前进的一个简单方法是在每次迭代中递减 $y$。我们提议以下更新：\n$$y' \\leftarrow y - 1$$\n这定义了一个变体函数 $V(y) = y$，它是一个非负整数，每次迭代都会严格递减，从而保证了终止。\n\n**保持不变量**：\n现在，我们必须确定在给定 $y$ 更新的情况下，保持不变量的 $k$ 和 $p$ 的更新方式。\n\n首先，考虑不变量的第二部分，$k + y = n_{\\text{original}}$。我们需要新状态 $(k', y')$ 满足 $k' + y' = n_{\\text{original}}$。\n代入我们提议的更新 $y' = y - 1$：\n$$k' + (y - 1) = n_{\\text{original}}$$\n从迭代开始时成立的不变量，我们知道 $y = n_{\\text{original}} - k$。将此代入上一个方程：\n$$k' + (n_{\\text{original}} - k - 1) = n_{\\text{original}}$$\n$$k' - k - 1 = 0$$\n$$k' = k + 1$$\n这给出了 $k$ 所需的赋值：\n$$k' \\leftarrow k + 1$$\n\n接下来，考虑不变量的第一部分，$p = x^k$。我们需要新状态 $(p', k')$ 满足 $p' = x^{k'}$。\n代入我们推导出的更新 $k' = k + 1$：\n$$p' = x^{k+1}$$\n使用求幂的基本定义，$x^{k+1} = x^k \\cdot x$。所以，我们必须有：\n$$p' = x^k \\cdot x$$\n从迭代开始时成立的不变量，我们知道 $p = x^k$。将此代入 $p'$ 的方程：\n$$p' = p \\cdot x$$\n这提供了 $p$ 所需的赋值：\n$$p' \\leftarrow p \\cdot x$$\n\n因此，推导出的最小循环体由以下三个赋值组成：\n1. $p \\leftarrow p \\cdot x$\n2. $k \\leftarrow k + 1$\n3. $y \\leftarrow y - 1$\n\n只要这些赋值都使用迭代开始时的 $p, k, y$ 的值，它们的顺序就无关紧要。提议的顺序执行可以实现这一点。\n\n### 第3步：正确性证明\n\n我们使用循环不变量方法来证明完全正确性。\n\n- **循环不变量 ($I$)**：$(p = x^k) \\land (k + y = n_{\\text{original}})$。\n- **变体 ($V$)**：$V(y) = y$。\n\n**1. 初始化（基本情况）**：\n我们必须证明不变量 $I$ 在循环的第一次迭代之前成立。\n- 初始状态是 $p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$ 和 $n_{\\text{original}} \\leftarrow n$。\n- 检查第一个合取项：是否 $p = x^k$？这意味着检查是否 $1 = x^0$。根据问题的求幂定义，这对所有整数 $x$ 都成立。\n- 检查第二个合取项：是否 $k + y = n_{\\text{original}}$？这意味着检查是否 $0 + n = n$。这是成立的。\n- 不变量的两个部分都成立。初始化是正确的。\n\n**2. 保持性（归纳步骤）**：\n假设在一次迭代开始时，不变量 $I$ 成立且循环守卫 $y > 0$ 为真。设状态为 $(p, k, y)$。我们必须证明在执行循环体之后，不变量对于新状态 $(p', k', y')$ 仍然成立。\n- **假设**：$p = x^k$，$k + y = n_{\\text{original}}$，且 $y > 0$。\n- **循环体**：$p' \\leftarrow p \\cdot x$，$k' \\leftarrow k + 1$，$y' \\leftarrow y - 1$。\n- **第一个合取项的证明 ($p' = x^{k'}$) **：\n  - $p' = p \\cdot x$ （根据赋值）\n  - $p' = (x^k) \\cdot x$ （根据假设 $p = x^k$）\n  - $p' = x^{k+1}$ （根据求幂的定义）\n  - 由于 $k' = k + 1$，我们得到 $p' = x^{k'}$。第一个合取项成立。\n- **第二个合取项的证明 ($k' + y' = n_{\\text{original}}$)**：\n  - $k' + y' = (k + 1) + (y - 1)$ （根据赋值）\n  - $k' + y' = k + y$\n  - 由于根据假设 $k + y = n_{\\text{original}}$，我们得到 $k' + y' = n_{\\text{original}}$。第二个合取项成立。\n- 循环体保持了不变量。这建立了部分正确性：如果循环终止，其结果是正确的。\n\n**3. 终止性和后置条件**：\n- **终止性**：变体是 $V(y) = y$。在初始化时，$y=n \\ge 0$。循环条件是 $y > 0$。在循环内部，$y$ 是严格为正的。更新是 $y' \\leftarrow y - 1$，所以 $y'  y$。一个严格递减的非负整数序列必须是有限的。因此，循环必须终止。\n- **后置条件**：当守卫 $y > 0$ 变为假时，循环终止。由于 $y$ 是一个在每一步都减 1 的整数，终止精确地发生在 $y = 0$ 时。\n  - 此时，不变量仍然成立（在最后一次未执行的检查开始时它是成立的）。\n  - 从 $k + y = n_{\\text{original}}$，当 $y=0$ 时，我们得到 $k = n_{\\text{original}}$。\n  - 从 $p = x^k$，代入 $k = n_{\\text{original}}$，我们得到 $p = x^{n_{\\text{original}}}$。\n- 这就是所期望的后置条件。\n\n初始化、保持性和终止性的结合证明了带有推导出的循环体的算法的完全正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the derived algorithm on a suite of test cases\n    and verifying the loop invariant and postcondition for each case.\n    \"\"\"\n\n    def power_for_verification(base, exp):\n        \"\"\"\n        Computes base^exp using the fundamental recursive definition.\n        Handles the special case 0^0 = 1 as per the problem statement.\n        This function is used only for verifying the invariant and postcondition,\n        not in the main computation of p.\n        \"\"\"\n        if exp  0:\n            raise ValueError(\"Exponent must be non-negative.\")\n        if exp == 0:\n            return 1\n        \n        # Using integer arithmetic to avoid potential floating point issues\n        # and to handle large numbers.\n        result = 1\n        for _ in range(exp):\n            result *= base\n        return result\n\n    def execute_and_verify(x, n):\n        \"\"\"\n        Executes the derived exponentiation algorithm for a given base x and exponent n.\n        It checks if the loop invariant holds at the start of every iteration and\n        if the postcondition holds upon termination.\n\n        Returns:\n            A list [p, b], where p is the computed result and b is a boolean\n            indicating if all checks passed.\n        \"\"\"\n        # Initialization\n        p = 1\n        k = 0\n        y = n\n        n_original = n\n\n        all_checks_passed = True\n\n        # Check invariant after initialization and before the first iteration.\n        # This is a crucial step, especially for the n=0 case where the loop is skipped.\n        try:\n            p_check = (p == power_for_verification(x, k))\n            ky_check = (k + y == n_original)\n            if not (p_check and ky_check):\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        # Loop\n        while y > 0:\n            # Check invariant at the start of the current iteration\n            try:\n                p_check = (p == power_for_verification(x, k))\n                ky_check = (k + y == n_original)\n                if not (p_check and ky_check):\n                    all_checks_passed = False\n            except Exception:\n                all_checks_passed = False\n\n            # Loop body derived from the invariant\n            p = p * x\n            k = k + 1\n            y = y - 1\n        \n        # Check postcondition upon termination\n        try:\n            postcondition_check = (p == power_for_verification(x, n_original))\n            if not postcondition_check:\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        return [p, all_checks_passed]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 10),\n        (5, 0),\n        (0, 7),\n        (0, 0),\n        (-3, 4),\n        (-3, 5),\n        (2, 50),\n        (1, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        x, n = case\n        result = execute_and_verify(x, n)\n        # Convert Python boolean to string 'True'/'False' for final output format\n        result[1] = 'True' if result[1] else 'False'\n        results.append(str(result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3248351"}, {"introduction": "在掌握了如何用不变量指导设计后，让我们来处理一个更经典的算法问题，并走完形式化证明的全流程。本练习要求你为一个已排序数组实现原地去重，这需要你精确地定义问题、设计高效的双指针算法、构建循环不变量，并最终严格证明其正确性。这是一个将理论应用于实践的绝佳机会。[@problem_id:3205683]", "problem": "给定一个长度为 $n$ 的已排序数组 $A$，其中 $n \\in \\mathbb{Z}_{\\ge 0}$，排序意味着 $\\forall i \\in \\{0, 1, \\dots, n-2\\}$, $A[i] \\le A[i+1]$。目标是就地移除重复值，使得每个不同值的首次出现被保留，并且保留值的顺序得以维持。这被称为稳定移除，意味着如果 $x$ 出现在位置 $p_1  p_2  \\dots  p_m$，则在移除后，保留的单个 $x$ 必须与原始的不同值序列具有相同的相对顺序。就地操作要求除了常数个标量变量外，使用 $O(1)$ 的额外空间。\n\n你的任务是：\n\n1. 规约：形式化地陈述算法的前置条件、后置条件和允许使用的资源。精确定义什么是正确的输出，即修改后的数组 $A$ 和一个整数 $k$，$k$ 是保留的不同值的数量，并且前缀 $A[0], A[1], \\dots, A[k-1]$ 精确地包含 $A$ 中按其原始出现顺序排列的不同值。保证 $0 \\le k \\le n$。\n\n2. 伪代码：提供无歧义的伪代码，该伪代码计算 $k$ 并实现在所述约束下的就地稳定移除。仅使用常数额外空间（例如，常数数量的索引和临时标量）。不要分配与 $n$ 成比例的辅助数组。\n\n3. 循环不变量：为你使用的主要循环陈述一个精确的循环不变量。你的不变量必须既能捕捉到已处理前缀的结构属性，也能捕捉到与读写索引相关的进度条件。该不变量必须足够强，以便在终止时能推导出后置条件。\n\n4. 正确性：使用循环不变量方法证明部分正确性。展示初始化、保持和终止，并推断出循环完成后，后置条件在稳定移除的情况下成立。此外，通过证明终止来论证完全正确性。提供关于 $n$ 的时间复杂度和空间复杂度界限，两者都需从基本定义（基本步骤计数和资源使用定义）出发进行论证。\n\n5. 实现：编写一个完整、可运行的程序，实现你的伪代码，并将其应用于以下固定的测试套件。程序不得读取任何输入。对于每个测试用例，它必须根据你的算法就地修改数组，计算 $k$，并输出一行包含所有测试用例汇总结果的内容。\n\n测试套件数组：\n- 情况 $1$：$A = [1,1,2,2,2,3,3,4]$\n- 情况 $2$：$A = []$\n- 情况 $3$：$A = [5]$\n- 情况 $4$：$A = [7,7,7,7]$\n- 情况 $5$：$A = [1,2,3,4,5]$\n- 情况 $6$：$A = [-3,-3,-2,-1,-1,0,0,0,1]$\n\n要求的最终输出格式：\n- 程序必须生成单行输出，该输出是一个无空格、用方括号括起来的逗号分隔列表。每个元素对应一个测试用例，本身是一个形如 $[k,\\text{unique\\_prefix}]$ 的列表，其中 $k$ 是保留元素的整数数量，$\\text{unique\\_prefix}$ 是修改后数组的前 $k$ 个元素的列表。例如，两个用例的输出可能看起来像 $[[2,[a,b]],[1,[c]]]$，其中 $a$、$b$、$c$ 表示来自相应数组的整数。\n- 对于本问题，数组中的整数应显示为普通整数（这些量不需要单位）。", "solution": "从已排序数组中就地移除重复元素是一个经典的算法任务，可以使用双指针技术高效解决。解决方案必须满足就地修改（使用 $O(1)$ 辅助空间）和稳定性的约束。鉴于输入数组已排序，通过保留每个值首次出现的实例，稳定性要求自然得到满足。\n\n### 1. 规约\n\n算法的形式化规约如下：\n\n**前置条件：**\n输入是一个长度为 $n$ 的数组 $A$，其中 $n \\in \\mathbb{Z}_{\\ge 0}$。\n数组 $A$ 按非递减顺序排序。形式上，对于原始数组 $A_{in}$，满足 $\\forall i \\in \\{0, 1, \\dots, n-2\\}, A_{in}[i] \\le A_{in}[i+1]$。\n\n**后置条件：**\n算法必须返回一个整数 $k$ 并修改数组 $A$，使得：\n1.  $k$ 是原始数组 $A_{in}$ 中不同元素的数量。因此，$0 \\le k \\le n$。\n2.  修改后数组的前缀 $A[0 \\dots k-1]$ 精确地包含 $A_{in}$ 的不同元素。\n3.  前缀 $A[0 \\dots k-1]$ 中的元素按严格递增顺序排列，并保留其原始相对顺序（稳定移除）。对于来自 $A_{in}$ 的任意两个不同值 $x, y$，如果 $x$ 的首次出现位于索引 $i$，$y$ 的首次出现位于索引 $j$，且 $i  j$，那么 $x$ 在 $A[0 \\dots k-1]$ 中的最终位置在 $y$ 的最终位置之前。\n4.  数组 $A$ 在索引 $k, k+1, \\dots, n-1$ 处的内容未指定且无关紧要。\n\n**资源约束：**\n算法必须就地操作，仅使用常数数量的额外内存，即 $O(1)$ 辅助空间。输入数组本身不计入此限制。\n\n### 2. 伪代码\n\n该算法使用一个“读”指针和一个“写”指针来遍历数组。读指针 $i$ 扫描数组的每个元素。写指针 $k$ 跟踪已处理的、唯一元素前缀的末尾。\n\n```\nALGORITHM remove_duplicates(A)\nINPUT: A, a sorted array of length n.\n\n1.  n = length(A)\n2.  IF n == 0 THEN\n3.      RETURN 0\n4.  END IF\n5.\n6.  k = 1  // Initialize write pointer; A[0] is always the first unique element.\n7.  FOR i FROM 1 TO n-1 DO  // i is the read pointer.\n8.      // Compare current element with the last unique element found.\n9.      IF A[i] > A[k-1] THEN\n10.         // Found a new unique element.\n11.         A[k] = A[i]  // Place it at the next position in the unique prefix.\n12.         k = k + 1    // Increment the size of the unique prefix.\n13.     END IF\n14. END FOR\n15.\n16. RETURN k // k is the number of unique elements.\n```\n\n### 3. 循环不变量\n\n算法的核心是 `FOR` 循环（第 $7$-$14$ 行）。我们可以通过定义一个循环不变量来建立其正确性。设 $k_{i}$ 表示在给定读指针 $i$ 的循环迭代开始时，写指针 $k$ 的值。\n\n**循环不变量：** 在 `FOR` 循环的每次迭代开始时，对于读指针 $i$（其中 $i \\in \\{1, 2, \\dots, n\\}$），以下性质成立：\n1.  子数组 $A[0 \\dots k-1]$ 包含子数组 $A[0 \\dots i-1]$ 中的所有唯一元素。\n2.  $A[0 \\dots k-1]$ 中的元素按严格递增顺序排序：$\\forall j \\in \\{0, \\dots, k-2\\}, A[j]  A[j+1]$。\n3.  写指针的索引 $k$ 满足 $1 \\le k \\le i$。\n\n### 4. 正确性\n\n我们使用循环不变量证明部分正确性，然后通过论证终止性来证明完全正确性。\n\n**基本情况：** 算法正确处理 $n=0$ 和 $n=1$ 的情况。\n- 如果 $n=0$，函数返回 $0$，满足 $k=0$ 的后置条件。\n- 如果 $n=1$，从 $i=1$ 到 $0$ 的循环不执行。函数返回初始值 $k=1$，这是正确的。数组 $A[0 \\dots 0]$ 包含单个唯一元素。\n\n**循环不变量证明（对于 $n \\ge 2$）：**\n\n**初始化：**\n在循环的第一次迭代之前，$i=1$ 且 $k=1$。\n1.  **不变量 1：** 需要考虑的子数组是 $A[0 \\dots i-1] = A[0 \\dots 0]$。唯一元素前缀是 $A[0 \\dots k-1] = A[0 \\dots 0]$。该子数组正确地包含了其自身的唯一元素。不变量成立。\n2.  **不变量 2：** 前缀 $A[0 \\dots k-1]$ 的长度为 $1$，因此排序属性不证自明地成立。不变量成立。\n3.  **不变量 3：** $k=1$ 且 $i=1$，所以 $1 \\le k \\le i$ 变为 $1 \\le 1 \\le 1$。不变量成立。\n\n**保持：**\n假设对于某个 $i$（其中 $1 \\le i  n$），不变量在迭代开始时成立。我们必须证明它在下一次迭代开始时（对于 $i+1$）仍然成立。\n- 在迭代 $i$ 开始时，$A[0 \\dots k-1]$ 按排序顺序包含 $A[0 \\dots i-1]$ 的唯一元素。\n- 循环体考虑元素 $A[i]$。由于原始数组 $A$ 是排序的，我们知道 $A[i] \\ge A[i-1]$。根据不变量，$A[k-1]$ 是 $A[0 \\dots i-1]$ 中的最大元素，所以 $A[i-1] \\le A[k-1]$ 不一定为真，但 $A[k-1]$ 是来自 $A[0 \\dots i-1]$ 的元素之一，并且由于所有内容都已排序，$A[k-1]$ 是该唯一前缀中的最大值。我们也知道 $A[k-1] \\le A[i-1] \\le A[i]$ 可能不成立，但因为 $A[k-1]$ 是在 $A[0 \\dots i-1]$ 中找到的最后一个唯一元素，且整个数组是排序的，我们必有 $A[k-1] \\le A[i]$。因此，存在两种情况：\n\n1.  **情况：$A[i] > A[k-1]$**（第 $9$ 行）。这意味着 $A[i]$ 是一个不在 $A[0 \\dots k-1]$ 中的新唯一元素。算法执行 $A[k] = A[i]$ 并将 $k$ 增加到 $k_{new} = k+1$。\n    - 在下一次迭代开始时（对于 $i+1$），新考虑的子数组是 $A[0 \\dots i]$。\n    - 新的唯一前缀 $A[0 \\dots k_{new}-1]$ 现在包含之前的唯一元素加上 $A[i]$。它正确地包含了 $A[0 \\dots i]$ 中的所有唯一元素。（不变量 1 成立）。\n    - 由于 $A[k-1]  A[i]$ 且 $A[0 \\dots k-1]$ 是严格排序的，新的前缀 $A[0 \\dots k_{new}-1]$ 也是严格排序的。（不变量 2 成立）。\n    - 我们有 $k_{new}=k+1$。根据假设 $k \\le i$，我们有 $k+1 \\le i+1$，所以 $k_{new} \\le i+1$。同时 $k_{new} \\ge 1+1 = 2 \\ge 1$。因此 $1 \\le k_{new} \\le i+1$。（不变量 3 成立）。\n\n2.  **情况：$A[i] = A[k-1]$**（由于 $A$ 是排序的，$A[i]  A[k-1]$ 是不可能的）。这意味着 $A[i]$ 是已找到的最后一个唯一元素的重复项。算法不执行任何操作。$k$ 的值保持不变。\n    - 在下一次迭代开始时（对于 $i+1$），子数组是 $A[0 \\dots i]$。\n    - 唯一前缀 $A[0 \\dots k-1]$ 仍然包含来自 $A[0 \\dots i]$ 的唯一元素，因为 $A[i]$ 是一个重复项。（不变量 1 成立）。\n    - 前缀 $A[0 \\dots k-1]$ 未改变，因此它仍然是严格排序的。（不变量 2 成立）。\n    - $k$ 不变，$i$ 递增到 $i+1$。由于 $k \\le i  i+1$，关系 $1 \\le k \\le i+1$ 对下一次迭代成立。（不变量 3 成立）。\n\n在两种情况下，循环不变量都得以保持。\n\n**终止：**\n当 $i=n$ 时，循环终止。此时，循环不变量对 $i=n$ 成立。\n1.  **不变量 1 意味着：** $A[0 \\dots k-1]$ 包含 $A[0 \\dots n-1]$ 中的所有唯一元素。这正是关于数组内容的后置条件。\n2.  **不变量 2 意味着：** 前缀 $A[0 \\dots k-1]$ 是排序的，满足后置条件。\n3.  $k$ 的最终值是这些唯一元素的计数。这满足关于返回值的后置条件。\n稳定性是隐式保证的，因为读指针 $i$ 从左到右遍历数组，并且我们保留每个值的首次出现。\n\n**完全正确性：**\n算法的终止是有保证的。`FOR` 循环使用计数器 $i$ 从 $1$ 迭代到 $n-1$。变量 $i$ 是严格递增的且受 $n$ 的限制。循环将精确执行 $n-1$ 次（对于 $n \\ge 1$），然后终止。由于部分正确性已得到证明，这也就证明了完全正确性。\n\n**复杂度分析：**\n-   **时间复杂度：** 算法包含一个 `FOR` 循环，迭代 $n-1$ 次。在循环内部，执行常数数量的操作（比较、可能的赋值、可能的递增）。因此，总时间复杂度与 $n$ 成正比，即 $O(n)$。\n-   **空间复杂度：** 算法使用几个标量变量进行索引和循环控制（$n, k, i$）。这些变量使用的内存量是常数，不依赖于输入大小 $n$。数组修改是就地执行的。因此，辅助空间复杂度是 $O(1)$。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef remove_duplicates(A: np.ndarray) -> int:\n    \"\"\"\n    Removes duplicates from a sorted numpy array in-place.\n\n    Args:\n        A: A sorted numpy array of numbers.\n\n    Returns:\n        The number of unique elements `k`. The first `k` elements of `A`\n        will be the unique elements in sorted order.\n    \"\"\"\n    n = len(A)\n    if n == 0:\n        return 0\n\n    # k is the index of the next unique element to be written.\n    # It also serves as the count of unique elements found so far.\n    # A[0] is always the first unique element.\n    k = 1\n    \n    # Iterate through the array from the second element.\n    for i in range(1, n):\n        # If the current element is greater than the last recorded unique element,\n        # it's a new unique element.\n        if A[i] > A[k - 1]:\n            # Place the new unique element at the position k.\n            if i != k: # Optimization: avoid self-assignment\n              A[k] = A[i]\n            # Increment the count of unique elements.\n            k += 1\n            \n    return k\n\ndef solve():\n    \"\"\"\n    Defines the test suite, runs the algorithm on each case,\n    and prints the aggregated results in the specified format.\n    \"\"\"\n    test_cases_lists = [\n        [1, 1, 2, 2, 2, 3, 3, 4],\n        [],\n        [5],\n        [7, 7, 7, 7],\n        [1, 2, 3, 4, 5],\n        [-3, -3, -2, -1, -1, 0, 0, 0, 1]\n    ]\n\n    test_cases_np = [np.array(case, dtype=np.int64) for case in test_cases_lists]\n\n    results = []\n    for test_array in test_cases_np:\n        # The function modifies the array in-place and returns k.\n        k = remove_duplicates(test_array)\n        \n        # Get the prefix of unique elements from the modified array.\n        unique_prefix = test_array[:k].tolist()\n        \n        # Format the result string for this case as [k,[prefix]] without spaces.\n        result_str = f\"[{k},{str(unique_prefix).replace(' ', '')}]\"\n        results.append(result_str)\n\n    # Final print statement in the exact required format: [[...],[...],...]\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3205683"}, {"introduction": "算法的正确性不仅依赖于其内部逻辑，还依赖于其运行所基于的基本假设或“前置条件”。如果这些基本假设本身不成立，会发生什么？本练习通过一个引人深思的思想实验来探讨这一点：当提供给快速排序算法的比较操作不满足传递性时，算法的行为会如何改变。这个例子将揭示抽象的数学属性与具体程序行为之间深刻而关键的联系。[@problem_id:3262688]", "problem": "考虑一种快速排序的实现，它使用一个用户提供的比较运算符，记作二元函数 $G(x,y)$。当且仅当比较器认为 $x$ “大于” $y$ 时，$G(x,y)$ 返回 $\\text{true}$。在这种比较器下，快速排序的标准正确性规范是：对于一个输出数组 $A[0..n-1]$，对于所有满足 $0 \\le i  j \\le n-1$ 的索引 $i$ 和 $j$，必须有 $\\neg G\\!\\left(A[i],A[j]\\right)$ 成立，这意味着在 $G$ 的定义下，没有元素严格位于其后的元素之前。假设枢轴的选择是确定性的（例如，总是选择最后一个元素），并且分区方案是 Lomuto 分区或 Hoare 分区，两者都以常规方式实现，但使用 $G$ 来进行比较。\n\n基本前提：\n- 用于排序的比较器应导出一个严格弱序：即集合 $S$ 上的一个二元关系 $R$，该关系在可比较的元素上是非自反的、非对称的和传递性的；由此可以推导出一个一致的“小于”关系。传递性定律是指，对于所有 $x,y,z \\in S$，如果 $R(x,y)$ 且 $R(y,z)$，则 $R(x,z)$。\n- 快速排序依赖于分区不变量：分区阶段相对于一个枢轴重新排列元素，使得一个子数组包含被认为“不大于”枢轴的元素，而另一个子数组包含被认为“大于”枢轴的元素，然后递归地对子数组进行排序。如果比较器导出一个传递性排序并且分区不变量是健全的，那么通过对子数组大小进行归纳即可证明其正确性。\n- 如果每次分区都严格减小子问题的规模（例如，通过将枢轴固定在某个索引处，或通过返回长度严格更小的子数组），则快速排序的终止性得以保证。\n\n现在假设 $G$ 对元素对是确定性的，但非传递性的。具体来说，存在不同的元素 $a$、$b$ 和 $c$，使得 $G(a,b)$、$G(b,c)$ 和 $G(c,a)$ 都成立（一个 $3$-环）。令 $A$ 表示一个包含 $a$、$b$ 和 $c$ 的输入数组（可能还包含其他元素）。\n\n在这些假设下，哪些陈述是正确的？\n\nA. 即使 $G$ 是非传递性的，使用 Lomuto 分区方案的快速排序在任何有限输入上都会终止，因为枢轴被放置在某个索引 $p$（$0 \\le p \\le n-1$）处，从而严格减小了子问题的规模。\n\nB. 如果 $G$ 包含一个环，例如 $G(a,b)$、$G(b,c)$ 和 $G(c,a)$，那么 $\\{a,b,c\\}$ 的任何排列都无法满足算法的正确性规范。\n\nC. Hoare 分区方案在处理非传递性比较器时可以进入无限循环，因为指针可能无法越过彼此，从而导致对相同范围的子数组进行递归调用。\n\nD. 循环不变量的替代形式 $p \\cdot x^y = x^{n_{\\text{original}}}$ 蕴含了终止条件下的后置条件 $p=x^{n_{\\text{original}}}$，但它本身不是求幂算法的循环不变量，因为它没有明确地将 $p$ 和 $k$ 联系起来。", "solution": "此问题探讨了当提供给快速排序算法的比较运算符不满足传递性时，算法的行为会发生何种变化。分析需要首先验证问题的前提，然后逐一评估每个陈述的正确性。\n\n### 问题验证\n\n**步骤 1：提取已知条件**\n- 一个快速排序实现使用二元函数 $G(x,y)$，当且仅当 $x$ 被认为“大于” $y$ 时，该函数返回 $\\text{true}$。\n- 排序后输出数组 $A[0 .. n-1]$ 的正确性规范是：对于所有满足 $0 \\le i  j \\le n-1$ 的 $i, j$，必须有 $\\neg G(A[i], A[j])$ 成立。\n- 枢轴选择是确定性的。\n- 分区方案是 Lomuto 或 Hoare。\n- 一个有效的排序比较器应导出一个严格弱序（非自反、非对称、传递性）。传递性定义为：对于所有 $x,y,z$，如果 $G(x,y)$ 且 $G(y,z)$，则 $G(x,z)$。\n- 快速排序的正确性依赖于分区不变量和传递性。\n- 快速排序的终止性依赖于严格减小子问题的规模。\n- **假设**：比较器 $G$ 是确定性的，但非传递性的。具体来说，存在不同的元素 $a,b,c$，使得 $G(a,b)$、$G(b,c)$ 和 $G(c,a)$ 都为真（一个 $3$-环）。\n- 输入数组 $A$ 包含这三个元素 $\\{a, b, c\\}$。\n\n**步骤 2：使用提取的已知条件进行验证**\n- **科学依据：** 该问题牢固地定位于理论计算机科学领域，特别是算法分析。它探讨了排序算法要保证正确性和终止性所需的前提条件，这是高级算法课程中的一个标准主题。传递性、严格弱序以及快速排序的机制（Lomuto 和 Hoare 分区）等概念都是公认的。\n- **良构性：** 该问题定义了对标准假设（非传递性）的一个特定偏离，并要求推导其对一个明确定义的算法（快速排序）的逻辑后果。问题的结构旨在评估一组形式化陈述，可以为这些陈述推导出确定的真值。\n- **客观性：** 该问题使用数学和计算机科学中常见的精确、形式化语言陈述。诸如“$G(x,y)$”、“$\\neg G(A[i], A[j])$”、“非传递性”和“$3$-环”之类的术语都是明确无歧义的。\n\n**步骤 3：结论与行动**\n问题陈述在科学上是健全的、良构的、客观的，并且不包含内部矛盾或缺失信息。这是一个有效的理论问题，可以继续进行解答。\n\n### 推导与选项分析\n\n问题的核心是比较器 $G$ 违反了传递性。用于排序的标准比较器会在元素上导出一个全序或偏序。像 $G(a,b)$、$G(b,c)$ 和 $G(c,a)$ 这样的环的存在，从根本上破坏了任何此类排序的无环性质。这对依赖于此比较器的排序算法的正确性以及潜在的终止性都有影响。\n\n#### 陈述 A 分析\n**陈述 A：** 即使 $G$ 是非传递性的，使用 Lomuto 分区方案的快速排序在任何有限输入上都会终止，因为枢轴被放置在某个索引 $p$（$0 \\le p \\le n-1$）处，从而严格减小了子问题的规模。\n\nLomuto 分区方案的工作方式是选择一个枢轴元素（例如，子数组 $A[lo..hi]$ 的最后一个元素 $A[hi]$），并重新排列子数组，使得所有“不大于”枢轴的元素都在其左侧，而所有“大于”枢轴的元素都在其右侧。关键步骤是，在分区之后，枢轴元素本身被交换到一个最终位置，比如索引 $p$。然后对子数组 $A[lo..p-1]$ 和 $A[p+1..hi]$ 进行快速排序的递归调用。\n\n关于终止性的关键观察点是，位于索引 $p$ 的枢轴元素被排除在两个递归调用之外。因此，子问题中的元素总数为 $(p-1 - lo + 1) + (hi - (p+1) + 1) = (p-lo) + (hi-p) = hi-lo$。原始问题的规模是 $hi-lo+1$。由于递归深度受数组大小的限制，并且每个递归步骤都在严格更小的子数组上操作，因此该算法必须终止。这个关于问题规模缩减的结构性论证与比较器 $G$ 的属性（如传递性）无关。分区过程会发生，递归将在空或单元素子数组处触底。\n\n因此，陈述中提供的推理是健全的。无论 $G$ 是否具有传递性，Lomuto 分区方案都能确保终止。\n\n**对 A 的结论：正确**\n\n#### 陈述 B 分析\n**陈述 B：** 如果 $G$ 包含一个环，例如 $G(a,b)$、$G(b,c)$ 和 $G(c,a)$，那么 $\\{a,b,c\\}$ 的任何排列都无法满足算法的正确性规范。\n\n正确性规范要求对于一个已排序的数组 $A$，$\\forall i  j, \\neg G(A[i], A[j])$。这意味着数组中较早出现的元素不能“大于”较晚出现的元素。\n\n让我们来检验 $\\{a,b,c\\}$ 的三个非循环排列。\n- 考虑排列 $(a,b,c)$。根据规范，必须有 $\\neg G(a,b)$，但我们已知 $G(a,b)$ 为真，所以该排列是无效的。\n- 考虑 $(b,c,a)$。必须有 $\\neg G(b,c)$，但我们已知 $G(b,c)$ 为真。\n- 考虑 $(c,a,b)$。必须有 $\\neg G(c,a)$，但我们已知 $G(c,a)$ 为真。\n没有一个长度为 3 的排列可以满足规范。因此，陈述 B 是正确的。\n\n**对 B 的结论：正确**\n\n#### 陈述 C 分析\n**陈述 C：** Hoare 分区方案在处理非传递性比较器时可以进入无限循环，因为指针可能无法越过彼此，从而导致对相同范围的子数组进行递归调用。\n\n此陈述声称 Hoare 分区方案**可能**不终止。为了反驳这一点，我们需要证明它**总是**终止。标准的 Hoare 分区实现（例如，Cormen 等人在《算法导论》中描述的）可以保证，即使某些元素与枢轴相等，返回的索引 $j$ 也会将数组 $A[lo..hi]$ 分成两个子数组 $A[lo..j]$ 和 $A[j+1..hi]$，其中至少有一个不是空的，并且两个子数组都严格小于原始数组 $A[lo..hi]$。\n\n终止性是 Hoare 分区的一个结构属性，它源于指针的移动方式和递归调用的设置。即使比较器是非传递性的，分区函数本身仍然会执行：指针会移动，元素会被交换，并且会返回一个索引来分割数组。只要实现能够防止因对与枢轴“等价”的元素处理不当而导致的对原始范围的递归调用，算法就会终止。精心设计的 Hoare 分区实现（例如，确保指针至少移动一步，并正确处理边界）可以保证终止，而与比较器的传递性无关。因此，声称它**可以**进入无限循环是错误的。算法可能会产生无意义的“排序”输出，但它会终止。\n\n**对 C 的结论：错误**\n\n#### 陈述 D 分析\n**陈述 D：** 循环不变量的替代形式 $p \\cdot x^y = x^{n_{\\text{original}}}$ 蕴含了终止条件下的后置条件 $p=x^{n_{\\text{original}}}$，但它本身不是求幂算法的循环不变量，因为它没有明确地将 $p$ 和 $k$ 联系起来。\n\n此陈述引用了第一个动手实践问题（`id=3248351`）。该问题中的循环不变量是 $(p = x^k) \\land (k + y = n_{\\text{original}})$。\n\n让我们来检验陈述 D 中的命题 `$p \\cdot x^y = x^{n_{\\text{original}}}$` 是否是一个循环不变量。\n从已知的循环不变量中，我们有 $p = x^k$ 和 $k = n_{\\text{original}} - y$。将 $k$ 的表达式代入 $p$ 的表达式中：\n$p = x^{(n_{\\text{original}} - y)}$\n两边同时乘以 $x^y$：\n$p \\cdot x^y = x^{(n_{\\text{original}} - y)} \\cdot x^y$\n$p \\cdot x^y = x^{n_{\\text{original}} - y + y}$\n$p \\cdot x^y = x^{n_{\\text{original}}}$\n\n这表明 `$p \\cdot x^y = x^{n_{\\text{original}}}$` 是原始循环不变量的一个直接数学推论。因此，它本身也是一个有效的循环不变量。陈述 D 声称它“不是求幂算法的循环不变量”，这是错误的。其给出的理由（“因为它没有明确地将 $p$ 和 $k$ 联系起来”）在逻辑上是无关的；一个命题是否为不变量，取决于它是否在每次迭代中保持为真，而与它提到哪些变量无关。\n\n**对 D 的结论：错误**\n\n综上所述，只有陈述 A 和 B 是正确的。", "answer": "$$\\boxed{AB}$$", "id": "3262688"}]}