{"hands_on_practices": [{"introduction": "使用循环不变量证明算法的正确性依赖于三个关键步骤：初始化、保持和终止。第一个练习为您提供了一个绝佳的机会来实践这一基本流程。通过分析一个简单的阶乘算法 [@problem_id:3248254]，您将一步步地验证一个给定的不变量，从而巩固您对这三个属性如何协同工作以保证正确性的理解。", "problem": "给定以下伪代码片段，用于计算非负整数 $n$ 的阶乘：\n- 输入: $n \\in \\mathbb{Z}_{\\ge 0}$\n- 初始化: $result := 1$\n- For循环: 对于 $i$ 从 $1$ 到 $n$ (包含 $n$) 执行 $result := result \\cdot i$\n\n我们尝试使用循环不变量来证明其正确性：在每次迭代开始时，对于当前的循环索引 $i$，断言 $result = (i-1)!$ 成立。假设使用标准的 for 循环语义，其中不变量在循环入口处被评估，并且循环按顺序遍历 $i = 1, 2, \\dots, n$。\n\n如果存在错误，以下哪个选项最好地指出了此代码-不变量对中的错误，该错误会阻碍对部分正确性和最终后置条件 $result = n!$ 的正确证明？\n\nA. 在循环入口处，当 $i = 1$ 时，不变量为假，因为 $0! \\ne 1$。\n\nB. 循环体 $result := result \\cdot i$ 违反了不变量，因为它将 $result$ 更改为 $i!$，因此在循环体执行后，相同的不变量无法保持成立。\n\nC. 终止时，循环在 $i = n$ 时退出，因此不变量仅得出 $result = (n-1)!$，这是一个差一错误。\n\nD. 只要在循环前将 $result$ 初始化为 $1$，就不存在错误；不变量在每个循环入口处都成立，并在终止时能推导出 $result = n!$。\n\nE. 初始化应为 $result := 0$ 以反映基线条件 $0! = 0$。\n\n选择唯一最佳答案。", "solution": "该问题要求分析一个伪代码片段以及一个为证明其正确性而提出的循环不变量。目标是计算非负整数 $n$ 的阶乘，记作 $n!$。算法如下：\n\n- 输入: $n \\in \\mathbb{Z}_{\\ge 0}$\n- 初始化: $result := 1$\n- 循环: for $i$ from $1$ to $n$ do $result := result \\cdot i$\n\n提出的循环不变量是：在每次以循环索引 $i$ 开始的迭代之初，断言 $P(i): result = (i-1)!$ 成立。需要证明的最终后置条件是 $result = n!$。\n\n要使用循环不变量验证循环的正确性，我们必须确立三个属性：\n\n1.  **初始化：** 在循环的第一次迭代之前，不变量为真。\n2.  **保持：** 如果不变量在一次迭代开始时为真，那么在下一次迭代开始时它仍然为真。\n3.  **终止：** 当循环终止时，不变量结合终止条件，能够推导出算法的正确性（即后置条件成立）。\n\n让我们针对给定的代码和不变量来分析这三个属性。\n\n**1. 初始化**\n循环从 $i = 1$ 开始。在第一次迭代之前，变量 $result$ 被初始化为 $1$。我们必须检查不变量 $P(1)$ 此时是否成立。\n对于 $i=1$，不变量是 $result = (1-1)! = 0!$。\n根据阶乘函数的标准定义，$0! = 1$。\n由于 $result$ 的初始值为 $1$，断言 $1 = 1$ 为真。\n因此，初始化属性成立。\n\n**2. 保持**\n我们假设不变量在任意一次迭代 $i$（其中 $1 \\le i \\le n$）开始时成立。这是归纳假设：假设 $result = (i-1)!$。\n在循环体内，语句 $result := result \\cdot i$ 被执行。\n执行此语句后，$result$ 的值变为 $(i-1)! \\cdot i$。\n根据阶乘函数的递归定义，$(i-1)! \\cdot i = i!$。\n循环的下一次迭代将以索引 $i+1$ 开始（假设 $i  n$）。这次迭代的不变量是 $P(i+1): result = ((i+1)-1)! = i!$。\n由于在第 $i$ 次迭代结束时，$result$ 的值确实是 $i!$，所以在第 $i+1$ 次迭代开始时，不变量成立。\n因此，保持属性成立。\n\n**3. 终止**\n`for i from 1 to n` 的 `for` 循环在 $i=n$ 的迭代完成后终止。此时，循环计数器递增到 $n+1$，循环条件（默认为 $i \\le n$）变为假。\n所以，当 $i = n+1$ 时循环终止。\n我们使用循环不变量和这个终止条件来证明后置条件。\n不变量是 $result = (i-1)!$。\n将终止时的 $i$ 值 $i = n+1$ 代入不变量，得到：\n$result = ((n+1)-1)! = n!$。\n这正是所期望的后置条件。在最后一次迭代（当 $i=n$ 时）之后，$result$ 的值被更新为 $(n-1)! \\cdot n = n!$，这与在终止时从不变量推导出的结论是一致的。\n\n我们再考虑 $n=0$ 的基线情况。循环 `for i from 1 to 0` 不会执行。代码初始化 $result := 1$ 然后终止。最终值为 $result = 1$，这是正确的，因为 $0! = 1$。循环不变量证明框架正确地处理了这种情况，因为在没有任何迭代的情况下，后置条件也得到了满足。\n\n由于所有三个属性（初始化、保持和终止）都成立，因此该代码-不变量对是正确的，并构成了部分正确性的有效证明。\n\n现在，我们来评估每个选项：\n\n**A. 在循环入口处，当 $i = 1$ 时，不变量为假，因为 $0! \\ne 1$。**\n这个陈述在事实上是错误的。根据定义，$0! = 1$。正如我们在初始化步骤的分析中所示，当 $i=1$ 时不变量成立。因此，这个选项是**错误的**。\n\n**B. 循环体 $result := result \\cdot i$ 违反了不变量，因为它将 $result$ 更改为 $i!$，因此在循环体执行后，相同的不变量无法保持成立。**\n这个选项误解了“保持”的含义。不变量 $P(i)$ 指出 `result = (i-1)!`。在循环体执行后，`result` 变为 `i!`。这并未违反保持属性；这是确保*下一次*迭代的不变量 $P(i+1)$ 成立的关键步骤。不变量并不需要在循环体的整个执行过程中都保持成立。它必须在迭代的边界（入口）处成立。因此，这个选项是**错误的**。\n\n**C. 终止时，循环在 $i = n$ 时退出，因此不变量仅得出 $result = (n-1)!$，这是一个差一错误。**\n这个陈述基于对 for 循环终止的错误理解。循环会执行 $i=1, 2, \\dots, n$。当循环计数器大于 $n$ 时，循环终止。在标准语义中，这发生在 $i$ 变为 $n+1$ 时。将终止条件 $i = n+1$ 应用于不变量，可以得出正确的后置条件 $result = ((n+1)-1)! = n!$。该选项关于循环“在 $i=n$ 时退出”的前提是错误的，从而导致了不正确的结论。因此，这个选项是**错误的**。\n\n**D. 只要在循环前将 $result$ 初始化为 $1$，就不存在错误；不变量在每个循环入口处都成立，并在终止时能推导出 $result = n!$。**\n这个陈述准确地总结了我们的分析。对于给定的代码和不变量，初始化、保持和终止这三个属性都成立。这个`代码-不变量对`是证明阶乘算法正确性的有效组合。因此，这个选项是**正确的**。\n\n**E. 初始化应为 $result := 0$ 以反映基线条件 $0! = 0$。**\n这个陈述包含一个事实错误：$0! = 1$，而不是 $0$。此外，将 $result$ 初始化为 $0$ 会导致对于任何 $n \\ge 1$，最终结果都因乘以 $0$ 而变为 $0$，这是不正确的。因此，这个选项是**错误的**。", "answer": "$$\\boxed{D}$$", "id": "3248254"}, {"introduction": "循环不变量不仅可以用来证明代码的正确性，也是诊断代码错误的强大工具。这个练习将挑战您分析一个经典的二分搜索算法的错误实现 [@problem_id:3248327]。您的任务是假设一个正确的不变量，然后通过追踪逻辑，精确定位出代码在何处以及如何未能保持该不变量，从而揭示程序中的缺陷。", "problem": "给定一个过程，用于在严格递增的有序数组 $A[0 \\ldots n-1]$ 中搜索目标值 $t$。预期的循环不变量是一个闭区间声明：在每次循环迭代开始时，如果存在索引 $k$ 使得 $A[k] = t$，则 $low \\le k \\le high$；等价地，如果 $t$ 存在，其索引位于子数组 $A[low \\ldots high]$ 中。该算法如下：\n\n初始化 $low \\leftarrow 0$, $high \\leftarrow n-1$。\n当 $low \\le high$ 时：\n- 令 $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$。\n- 如果 $A[mid] = t$，返回 $mid$。\n- 否则如果 $A[mid]  t$，设置 $high \\leftarrow mid - 1$。\n- 否则，设置 $low \\leftarrow mid + 1$。\n如果循环终止，返回 $t$ 不存在。\n\n假设使用标准整数算术，除法为精确下取整，且无溢出。仅使用关于严格递增数组的核心事实（对于所有索引 $i$ 和 $j$，如果 $i  j$ 则 $A[i]  A[j]$）和不变量的定义。你的任务是确定哪一步导致算法因违反所述不变量而有时会错过一个存在的目标，并通过准确指出不变量如何未能被保持来证明你的选择。\n\n关于不变量，哪个选项最能指出缺陷及其原因？\n\nA. 初始化违反了不变量，因为 $high$ 应设置为 $n$ 而不是 $n-1$，因此初始子数组 $A[low \\ldots high]$ 没有覆盖所有可能的候选项。\n\nB. 在分支 $A[mid]  t$ 中，不变量的维持性被破坏：更新 $high \\leftarrow mid - 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，对于某个满足 $A[k] = t$ 的 $k$，条件 $low \\le k \\le high$ 可能不再成立。\n\nC. 在分支 $A[mid] > t$ 中，不变量的维持性被破坏：更新 $low \\leftarrow mid + 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，对于某个满足 $A[k] = t$ 的 $k$，条件 $low \\le k \\le high$ 可能不再成立。\n\nD. 不变量的陈述有误；它应该使用一个半开区间，即如果 $t$ 存在，则 $t$ 必须在 $A[low \\ldots high)$ 中，而使用闭区间是算法可能错过 $t$ 的原因。", "solution": "问题陈述是算法分析中的一个有效练习，特别是使用循环不变量来验证算法的正确性。任务是根据给定的不变量来分析一个有缺陷的二分搜索实现。该问题提法恰当，有计算机科学原理的科学依据，并且是客观的。\n\n分析的核心在于循环不变量的三个性质：初始化、维持和终止。设所述循环不变量为 $P$。\n$P$：在每次循环迭代开始时，如果存在索引 $k$ 使得 $A[k] = t$，则 $low \\le k \\le high$。\n\n**1. 初始化**\n\n算法初始化 $low \\leftarrow 0$ 和 $high \\leftarrow n-1$。循环不变量 $P$ 必须在第一次迭代前成立。初始搜索空间是整个数组 $A[0 \\ldots n-1]$。如果目标值 $t$ 存在于数组的某个索引 $k$ 处，那么根据数组索引的定义，$k$ 必须在 $[0, n-1]$ 的范围内。因此，条件 $low \\le k \\le high$（即 $0 \\le k \\le n-1$）是成立的。初始化步骤正确地建立了不变量。\n\n**2. 维持**\n\n我们假设不变量 $P$ 在一次 `while` 循环迭代开始时成立。也就是说，如果对于某个 $k$ 有 $A[k] = t$，那么 $low \\le k \\le high$。我们必须证明 $P$ 在下一次迭代开始时仍然成立。\n\n算法计算 $mid \\leftarrow \\left\\lfloor \\dfrac{low + high}{2} \\right\\rfloor$。\n循环体中有三种情况：\n\n情况1：$A[mid] = t$。算法找到目标并返回 $mid$，终止。循环不再继续，因此对于此路径，维持属性不再被测试。结果是正确的。\n\n情况2：$A[mid]  t$。数组 $A$ 是严格递增的，意味着对于任何索引 $i  j$，我们有 $A[i]  A[j]$。如果 $A[mid]  t$，那么对于任何索引 $j \\le mid$，我们有 $A[j] \\le A[mid]  t$。这意味着如果目标值 $t$ 存在于数组的索引 $k$ 处，其索引必须大于 $mid$。即，$k > mid$。\n结合我们的假设（$low \\le k \\le high$）和这个推论（$k > mid$），目标索引 $k$（如果存在）必须位于区间 $[mid + 1, high]$ 内。\n为了维持不变量，下一个搜索区间 $[low_{new}, high_{new}]$ 必须包含 $[mid + 1, high]$。正确的更新应该是 $low \\leftarrow mid + 1$。\n然而，该算法执行的是 $high \\leftarrow mid - 1$。新的搜索区间变为 $[low, mid-1]$。一个已知大于 $mid$ 的索引 $k$ 不可能在这个新区间内。因此，如果目标存在，新状态就违反了不变量 $low_{new} \\le k \\le high_{new}$。\n\n情况3：`Else`。当 $A[mid] \\ne t$ 且 $A[mid]  t$ 不成立时，会触发此情况，这意味着 $A[mid] > t$。因为数组是严格递增的，如果 $A[mid] > t$，那么对于任何索引 $j \\ge mid$，我们有 $A[j] \\ge A[mid] > t$。这意味着如果目标值 $t$ 存在于数组的索引 $k$ 处，其索引必须小于 $mid$。即，$k  mid$。\n结合我们的假设（$low \\le k \\le high$）和这个推论（$k  mid$），目标索引 $k$（如果存在）必须位于区间 $[low, mid - 1]$ 内。\n为了维持不变量，下一个搜索区间 $[low_{new}, high_{new}]$ 必须包含 $[low, mid - 1]$。正确的更新应该是 $high \\leftarrow mid - 1$。\n然而，该算法执行的是 $low \\leftarrow mid + 1$。新的搜索区间变为 $[mid+1, high]$。一个已知小于 $mid$ 的索引 $k$ 不可能在这个新区间内。因此，如果目标存在，新状态就违反了不变量 $low_{new} \\le k \\le high_{new}$。\n\n当 $A[mid] \\ne t$ 时，算法的两个更新分支都是不正确的，并且违反了循环不变量的维持性质。这两种情况的逻辑似乎被互换了。\n\n现在，我们来评估给出的选项：\n\n**A. 初始化违反了不变量，因为 $high$ 应设置为 $n$ 而不是 $n-1$，因此初始子数组 $A[low \\ldots high]$ 没有覆盖所有可能的候选项。**\n正如在初始化分析中所示，设置 $low \\leftarrow 0$ 和 $high \\leftarrow n-1$ 正确地建立了不变量。这个范围完全覆盖了数组 $A[0 \\ldots n-1]$ 的所有有效索引。对于一个大小为 $n$ 的 0 索引数组的闭区间不变量，将 $high$ 设置为 $n$ 是不正确的，因为它可能导致访问越界的 $A[n]$。此选项**不正确**。\n\n**B. 在分支 $A[mid]  t$ 中，不变量的维持性被破坏：更新 $high \\leftarrow mid - 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，对于某个满足 $A[k] = t$ 的 $k$，条件 $low \\le k \\le high$ 可能不再成立。**\n我们对情况 $A[mid]  t$ 的维持步骤的分析精确地证实了这一说法。如果 $A[mid]  t$，目标必须在当前搜索空间的上半部分（$k > mid$）。更新 $high \\leftarrow mid-1$ 丢弃了这一半，并将搜索限制在下半部分，从而破坏了不变量。这个选项准确地描述了算法中的一个关键缺陷。此选项**正确**。\n\n**C. 在分支 $A[mid] > t$ 中，不变量的维持性被破坏：更新 $low \\leftarrow mid + 1$ 可能会排除 $t$ 在升序数组中唯一可能存在的区域，因此在此更新后，如果 $t$ 存在，对于某个满足 $A[k] = t$ 的 $k$，条件 $low \\le k \\le high$ 可能不再成立。**\n我们对 `Else` 情况 ($A[mid] > t$) 的维持步骤的分析也证实了这一说法。如果 $A[mid] > t$，目标必须在搜索空间的下半部分（$k  mid$）。更新 $low \\leftarrow mid+1$ 丢弃了这一半，并将搜索限制在上半部分，破坏了不变量。这个选项也准确地描述了算法中的一个关键缺陷。此选项**正确**。\n\n**D. 不变量的陈述有误；它应该使用一个半开区间，即如果 $t$ 存在，则 $t$ 必须在 $A[low \\ldots high)$ 中，而使用闭区间是算法可能错过 $t$ 的原因。**\n对于二分搜索，选择闭区间 $[low, high]$ 不变量是一种标准且有效的方法。所呈现的算法存在缺陷是因为其更新逻辑没有正确地维持这个不变量。一个正确的算法*可以*使用这个不变量来编写。问题出在代码上，而不是不变量的陈述上。此选项**不正确**。\n\n**结论：**\n选项 B 和 C 都描述了算法维持步骤中有效的、致命的缺陷。该算法错误地交换了 $A[mid]  t$ 和 $A[mid] > t$ 情况下的更新逻辑。然而，问题要求选择唯一的最佳选项。在所提供的伪代码中，`Else if A[mid]  t` 分支出现在最后的 `Else` 分支（处理 $A[mid] > t$ 的情况）之前。选项 B 中描述的缺陷与代码控制流中两个不正确更新语句的第一个相关联。因此，可以认为在分析条件逻辑序列时，B 指出了遇到的最直接的缺陷。", "answer": "$$\\boxed{B}$$", "id": "3248327"}, {"introduction": "除了验证和调试，循环不变量还可以作为设计算法的蓝图。在这个高级练习中，您将逆向工程一个循环的逻辑 [@problem_id:3248351]。给定一个求幂算法的不变量、初始化和终止条件，您的任务是推导出循环体内部必要的操作，以确保不变量得以保持并且算法能够达到其目标。这个练习展示了不变量如何指导算法的构建过程，将您的技能从分析提升到综合与设计。", "problem": "给定一个整数底数 $x$ 和一个非负整数指数 $n$。考虑一个通过维护三个整型变量 $p$、$k$ 和 $y$ 来计算 $x^n$ 的算法，其初始化和循环守卫如下：\n- 初始化：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及 $n_{\\text{original}} \\leftarrow n$。\n- 循环守卫：当 $y > 0$ 时继续循环。\n- 每次迭代开始时需要保持的循环不变量：$p = x^k$ 且 $k + y = n_{\\text{original}}$。\n\n你的任务是逆向工程一个正确的循环体，即确定循环体中必须执行的赋值语句，以维持循环不变量，并确保在终止时后置条件 $p = x^{n_{\\text{original}}}$ 成立。\n\n你的推导必须从以下基本依据出发：\n- 自然数上的幂运算定义：对于所有整数 $x$ 和所有整数 $k \\ge 0$，有 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$。\n- 自然数上的数学归纳法原理以及自然数上常规序的良基性。\n- 命令式程序中用于部分正确性的循环不变量和用于完全正确性的自然数变体的标准定义。\n\n假设以下域和约定：\n- $x$ 是任意整数，$n$ 是满足 $n \\ge 0$ 的任意整数。\n- 对于本问题，定义对于所有整数 $x$，包括 $x = 0$ 的情况，都有 $x^0 = 1$，因此 $0^0$ 取为 $1$。\n\n任务：\n1. 推导一个最小循环体（仅包含对 $p$、$k$ 和 $y$ 的赋值），该循环体在每次迭代开始时保持不变量 $p = x^k$ 且 $k + y = n_{\\text{original}}$，递减一个自然数变体以确保终止，并在循环终止时产生后置条件 $p = x^{n_{\\text{original}}}$。\n2. 仅从上述基本依据出发，使用循环不变量方法证明你的循环的部分正确性和完全正确性。\n3. 实现一个程序，该程序对一组测试用例执行你的循环，并为每个测试用例返回：\n   - 终止时计算出的值 $p$。\n   - 一个布尔值，指示在每次迭代开始时不变量是否成立，以及在终止时后置条件 $p = x^{n_{\\text{original}}}$ 是否成立。\n\n测试套件：\n- $(x, n) = (2, 10)$\n- $(x, n) = (5, 0)$\n- $(x, n) = (0, 7)$\n- $(x, n) = (0, 0)$\n- $(x, n) = (-3, 4)$\n- $(x, n) = (-3, 5)$\n- $(x, n) = (2, 50)$\n- $(x, n) = (1, 100)$\n\n答案规格和输出格式：\n- 对于每个测试用例，输出一个二元列表 $[p, b]$，其中 $p$ 是使用你推导的循环计算出的整数 $x^n$，$b$ 是一个布尔值，当且仅当每次迭代开始时不变量都成立且最终状态满足 $p = x^{n_{\\text{original}}}$ 时，$b$ 为 $\\text{True}$。\n- 你的程序应生成单行输出，其中包含用方括号括起来的逗号分隔列表形式的结果，例如：$[\\,[p_1, b_1],[p_2, b_2],\\dots]$。\n- 无需用户输入。程序必须是自包含的，并且只使用整数算术和控制流；在循环体内计算 $p$ 时不要调用任何内置的幂函数。为了在实现中验证不变量，你可以使用定义性递推式 $x^0 = 1$ 和 $x^{k+1} = x^k \\cdot x$ 来计算 $x^k$。", "solution": "基于给定的循环不变量设计循环体来计算 $x^n$ 的问题，是程序验证和算法逆向工程中的一个标准练习。我将首先验证问题陈述，然后进行形式化推导和正确性证明。\n\n### 步骤 1：问题验证\n\n我首先提取问题中所述的给定信息和条件。\n\n- **输入**：一个整数底数 $x$ 和一个非负整数指数 $n$。\n- **算法变量**：三个整型变量 $p$、$k$ 和 $y$。\n- **初始化**：$p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及一个常量 $n_{\\text{original}} \\leftarrow n$。\n- **循环守卫**：只要 $y > 0$，循环就继续。\n- **循环不变量**：命题 $I(p, k, y) \\equiv (p = x^k) \\land (k + y = n_{\\text{original}})$ 必须在每次循环迭代开始时成立。\n- **后置条件**：终止时，$p$ 的最终值必须是 $x^{n_{\\text{original}}}$。\n- **基本依据**：推导必须基于：\n    1. 幂运算的递归定义：对于 $k \\ge 0$，$x^0 = 1$ 且 $x^{k+1} = x^k \\cdot x$。\n    2. 数学归纳法原理。\n    3. 用于证明部分正确性和完全正确性的循环不变量理论。\n- **域约定**：$x$ 是任意整数，$n$ 是 $n \\ge 0$ 的整数，并且为本问题之目的，对所有整数 $x$，包括 $0^0=1$，都有 $x^0=1$。\n\n这个问题在科学上和数学上是合理的、适定的和客观的。它是计算机科学中关于算法设计和正确性的一个标准问题，特别关注循环不变量。前提是一致的，并且提供了推导所需的所有必要信息。这个问题并非无足轻重，因为它需要系统地应用程序验证的原理。因此，该问题被认定为有效。\n\n### 步骤 2：循环体的推导\n\n设在任意一次循环迭代开始时变量的状态为 $(p, k, y)$。根据假设（循环不变量），我们假定此时：\n1. $p = x^k$\n2. $k + y = n_{\\text{original}}$\n\n循环守卫是 $y > 0$，所以我们也可以假设 $y$ 是一个正整数。\n目标是找到对 $p$、$k$ 和 $y$ 的一系列赋值，得到的新状态 $(p', k', y')$ 也满足不变量，即 $p' = x^{k'}$ 且 $k' + y' = n_{\\text{original}}$。此外，我们必须确保循环终止。\n\n**确保终止性**：\n如果 $y$ 最终变得小于或等于 $0$，循环就会终止。由于 $y$ 是一个在循环内部为正的整数，保证朝向终止前进的一个简单方法是在每次迭代中递减 $y$。让我们提议更新：\n$$y' \\leftarrow y - 1$$\n这定义了一个变体函数 $V(y) = y$，它是一个非负整数，每次迭代都会严格递减，从而保证终止。\n\n**保持不变量**：\n现在，我们必须确定在给定 $y$ 的更新情况下，对 $k$ 和 $p$ 的更新，以保持不变量。\n\n首先，考虑不变量的第二部分，$k + y = n_{\\text{original}}$。我们需要新状态 $(k', y')$ 满足 $k' + y' = n_{\\text{original}}$。\n代入我们提议的更新 $y' = y - 1$：\n$$k' + (y - 1) = n_{\\text{original}}$$\n从迭代开始时成立的不变量，我们知道 $y = n_{\\text{original}} - k$。将此代入上一个方程：\n$$k' + (n_{\\text{original}} - k - 1) = n_{\\text{original}}$$\n$$k' - k - 1 = 0$$\n$$k' = k + 1$$\n这给出了对 $k$ 所需的赋值：\n$$k' \\leftarrow k + 1$$\n\n接下来，考虑不变量的第一部分，$p = x^k$。我们需要新状态 $(p', k')$ 满足 $p' = x^{k'}$。\n代入我们推导出的更新 $k' = k + 1$：\n$$p' = x^{k+1}$$\n使用幂运算的基本定义，$x^{k+1} = x^k \\cdot x$。所以，我们必须有：\n$$p' = x^k \\cdot x$$\n从迭代开始时成立的不变量，我们知道 $p = x^k$。将此代入 $p'$ 的方程中：\n$$p' = p \\cdot x$$\n这提供了对 $p$ 所需的赋值：\n$$p' \\leftarrow p \\cdot x$$\n\n因此，推导出的最小循环体由以下三个赋值组成：\n1. $p \\leftarrow p \\cdot x$\n2. $k \\leftarrow k + 1$\n3. $y \\leftarrow y - 1$\n\n只要这些赋值都使用迭代开始时的 $p, k, y$ 值，它们的顺序就无关紧要。提议的顺序执行可以实现这一点。\n\n### 步骤 3：正确性证明\n\n我们使用循环不变量方法来证明完全正确性。\n\n- **循环不变量 ($I$)**：$(p = x^k) \\land (k + y = n_{\\text{original}})$。\n- **变体 ($V$)**：$V(y) = y$。\n\n**1. 初始化（基本情况）**：\n我们必须证明不变量 $I$ 在循环的第一次迭代之前成立。\n- 初始状态是 $p \\leftarrow 1$，$k \\leftarrow 0$，$y \\leftarrow n$，以及 $n_{\\text{original}} \\leftarrow n$。\n- 检查第一个合取项：$p = x^k$ 是否成立？这意味着检查 $1 = x^0$ 是否成立。根据问题的幂运算定义，这对所有整数 $x$都成立。\n- 检查第二个合取项：$k + y = n_{\\text{original}}$ 是否成立？这意味着检查 $0 + n = n$ 是否成立。这是成立的。\n- 不变量的两个部分都成立。初始化是正确的。\n\n**2. 保持性（归纳步骤）**：\n假设在一次迭代开始时，不变量 $I$ 成立且循环守卫 $y > 0$ 为真。设状态为 $(p, k, y)$。我们必须证明在执行循环体后，不变量对于新状态 $(p', k', y')$ 仍然成立。\n- **假设**：$p = x^k$，$k + y = n_{\\text{original}}$，且 $y > 0$。\n- **循环体**：$p' \\leftarrow p \\cdot x$，$k' \\leftarrow k + 1$，$y' \\leftarrow y - 1$。\n- **第一个合取项的证明 ($p' = x^{k'}$)**：\n  - $p' = p \\cdot x$ (根据赋值)\n  - $p' = (x^k) \\cdot x$ (根据假设 $p = x^k$)\n  - $p' = x^{k+1}$ (根据幂运算的定义)\n  - 由于 $k' = k + 1$，我们有 $p' = x^{k'}$。第一个合取项成立。\n- **第二个合取项的证明 ($k' + y' = n_{\\text{original}}$)**：\n  - $k' + y' = (k + 1) + (y - 1)$ (根据赋值)\n  - $k' + y' = k + y$\n  - 由于根据假设 $k + y = n_{\\text{original}}$，我们有 $k' + y' = n_{\\text{original}}$。第二个合取项成立。\n- 循环体保持了不变量。这建立了部分正确性：如果循环终止，其结果是正确的。\n\n**3. 终止性和后置条件**：\n- **终止性**：变体是 $V(y) = y$。在初始化时，$y=n \\ge 0$。循环条件是 $y > 0$。在循环内部，$y$ 是严格为正的。更新是 $y' \\leftarrow y - 1$，所以 $y'  y$。一个严格递减的非负整数序列必须是有限的。因此，循环必须终止。\n- **后置条件**：当守卫 $y > 0$ 变为假时，循环终止。由于 $y$ 是一个每次递减 $1$ 的整数，终止精确地发生在 $y = 0$ 时。\n  - 此时，不变量仍然成立（它在最后一次、未执行的检查开始时是成立的）。\n  - 从 $k + y = n_{\\text{original}}$，当 $y=0$ 时，我们得到 $k = n_{\\text{original}}$。\n  - 从 $p = x^k$，代入 $k = n_{\\text{original}}$，我们得到 $p = x^{n_{\\text{original}}}$。\n- 这就是期望的后置条件。\n\n初始化、保持性和终止性的结合证明了带有推导出的循环体的算法的完全正确性。", "answer": "```python\n# The complete and runnable Python 3 code goes here.\n# Imports must adhere to the specified execution environment.\nimport numpy as np\n\ndef solve():\n    \"\"\"\n    Solves the problem by running the derived algorithm on a suite of test cases\n    and verifying the loop invariant and postcondition for each case.\n    \"\"\"\n\n    def power_for_verification(base, exp):\n        \"\"\"\n        Computes base^exp using the fundamental recursive definition.\n        Handles the special case 0^0 = 1 as per the problem statement.\n        This function is used only for verifying the invariant and postcondition,\n        not in the main computation of p.\n        \"\"\"\n        if exp  0:\n            raise ValueError(\"Exponent must be non-negative.\")\n        if exp == 0:\n            return 1\n        \n        # Using integer arithmetic to avoid potential floating point issues\n        # and to handle large numbers.\n        result = 1\n        for _ in range(exp):\n            result *= base\n        return result\n\n    def execute_and_verify(x, n):\n        \"\"\"\n        Executes the derived exponentiation algorithm for a given base x and exponent n.\n        It checks if the loop invariant holds at the start of every iteration and\n        if the postcondition holds upon termination.\n\n        Returns:\n            A list [p, b], where p is the computed result and b is a boolean\n            indicating if all checks passed.\n        \"\"\"\n        # Initialization\n        p = 1\n        k = 0\n        y = n\n        n_original = n\n\n        all_checks_passed = True\n\n        # Check invariant after initialization and before the first iteration.\n        # This is a crucial step, especially for the n=0 case where the loop is skipped.\n        try:\n            p_check = (p == power_for_verification(x, k))\n            ky_check = (k + y == n_original)\n            if not (p_check and ky_check):\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        # Loop\n        while y > 0:\n            # Check invariant at the start of the current iteration\n            try:\n                p_check = (p == power_for_verification(x, k))\n                ky_check = (k + y == n_original)\n                if not (p_check and ky_check):\n                    all_checks_passed = False\n            except Exception:\n                all_checks_passed = False\n\n            # Loop body derived from the invariant\n            p = p * x\n            k = k + 1\n            y = y - 1\n        \n        # Check postcondition upon termination\n        try:\n            postcondition_check = (p == power_for_verification(x, n_original))\n            if not postcondition_check:\n                all_checks_passed = False\n        except Exception:\n            all_checks_passed = False\n\n        return [p, all_checks_passed]\n\n    # Define the test cases from the problem statement.\n    test_cases = [\n        (2, 10),\n        (5, 0),\n        (0, 7),\n        (0, 0),\n        (-3, 4),\n        (-3, 5),\n        (2, 50),\n        (1, 100),\n    ]\n\n    results = []\n    for case in test_cases:\n        x, n = case\n        result = execute_and_verify(x, n)\n        # Convert Python boolean to string 'True'/'False' for final output format\n        result[1] = 'True' if result[1] else 'False'\n        results.append(str(result).replace(\"'\", \"\"))\n\n    # Final print statement in the exact required format.\n    print(f\"[{','.join(results)}]\")\n\nsolve()\n```", "id": "3248351"}]}